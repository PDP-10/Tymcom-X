;Update PAKCOP.INF whenever VERSIO is changed.

SUBTTL	SAXPRM	Parameters for SA-10 + IBM-disk + STC-tape
;The prefix "SAX" is "SA-10" using roman numerals.

COMMENT ~	Created by Joe Smith for the P034/P00 monitor, September 1985

The SA-10 lives on the I/O bus and emulates two IBM block multiplexor channels.
(Systems Concepts makes a four channel SA-10, but TYMSHARE does not use any.)

On TYMCOM-X systems, SAX channel 0 goes to the STC tape controller.
On TYMCOM-X systems, SAX channel 1 goes the disk subsystem.

The disk subsystem consists of:
  One or two Ampex DC830 Controller with one or two strings each.
    Each disk string has up to 8 DM331 single-spindle disk drives.
      Current maximum of 32 disk packs (two SCUs with two strings each).
      Each module has two mountable 200 megabyte disks (3330 equivalents).
        Total of 6.4 gigabytes on 32 disks.
                         - or -
  One or two 3672 Storage Control Units with one or two strings each.
    Each disk string has a 3673 string controller and four 3675 disks modules.
      Current maximum of 32 disk packs (two SCUs with two strings each).
      Each module has two mountable 200 megabyte disks (3330 equivalents).
        Total of 6.4 gigabytes on 32 disks.
                         - or -
  One 3674 Storage Control Unit with up to four strings.
    The disk string is a 3653 CTLR and up to three 3650 disk modules (8 disks).
    The disk string may be a 3673 string controller and four 3675 disks modules.
      Current maximum of 32 disk packs (one SCU with four strings).
      Each module has two fixed 317 megabyte disks (3350 equivalents).
        Total of 10.2 gigabytes on 32 disks if all are 3650s.

There is an absolute maximum of 256 disks on an IBM-compatible channel:
  16 SCUs * 2 CTLRs * 8 packs  - or -  8 SCUs * 4 CTLRs * 8 packs

Note: A 24-pack 3675 system (4.8 Gb) can be replaced with a 16-pack 3650 system.

        -------------------------------------------------------------

Nomenclature:

 TYM "Channel" = one of the 4 channels on an SA-10, a PDP-10 can have 8
		channels if it has two expanded SA-10's.  Selected by the
		device code and 2 bits of a CONO instruction.

 IBM "Channel" = one of 16 block multiplexor channels attached to a 370.
		Selected by bits 4-7 of 3rd byte of an I/O instruction.

PAKCOP "Kontroller" = Mythical device that can handle up to 32 disk drives.
		Up to 8 kontrollers, for a maximum of 256 disk drives.
		(Software currently set up for only 1 kontroller.)

 TYM "Kontroller" = Device that can handle 16 disk drives (two strings).
		A 16-pack (2-string) system has 1 kontroller.
		A 32-pack (4-string) system has 2 kontrollers.
		One kontroller = 1 Memorex 3672 + 2 Memorex 3673 string CTLRs.
		Or 1 kontroller = 1 Ampex DC830 + 2 strings of 331 disks.
		1 Memorex 3674 = 2 kontrollers = 4 strings.

 IBM "SCU+CTLR"   = Storage Control Unit and disk string controller.
		Selected by bits 0-4 of 4th byte of an I/O instruction.
		Up to 32 SCU+CTLR's, each with 8 disks, maximum of 256 disks.
	The new model SCU can handle 4 strings of 8, total of 32 disks.
	The old model SCU has only 2 strings of 8 disks, requiring two SCU's.

 TYM "Unit"  = one of 16 disk drives attached to a kontroller.
 IBM "Drive" = one of 8 disks on a string.  Selected by bits 5-7 of 4th byte.

 TYM "Disk Address" = Combination of KONTROLLER+UNIT = one of 256 disks.
 IBM "Storage Subsystem Address" = 4th byte of I/O instruction, one of 256 disks

TYMCOM-X arbitrarily assigns the first available disk unit address as X'1C0'.
This is channel 1 address 'C0' hex, caused by "KN0==300" (octal).  The first
kontroller handles unit addresses 'C0' to 'CF', a second kontroller would
handle unit addresses 'D0' to 'EF'.  (Note: PAKCOP uses a different definition
It uses KONTROLLER to refer to a device combination that can handle 32 disks. .

        -------------------------------------------------------------

Definition of CB's in PAKCOP.MAC

%UNI incremented per unit, equals total units at end
%KUN incremented per unit, reset for each KONCB, equals unit on this kontroller
%CUN incremented per unit, reset for each CHNCB, equals unit on this channel
%KON  incremented per KONCB, equals total kontrollers at end
%KCUN incremented per KONCB, reset for each CHNCB, equals kon on this channel
%CHN  incremented per CHNCB, equals total channels at end

%.A0   SA-10 #0                                %SAX=0
		CONI, CONO, and DATAI for the entire SA-10
 %.B0   Channel 0 of SA 0                       %CHN=0
		TAPE stuff
 %.B1   Channel 1 of SA 0                       %CHN=1
		CONO and CONSO for this channel (one of 4 possible channels)
  %.C0   Kontroller for first 32 disks           %KON=0 %KCUN=0
   %.D0   Disk unit (300-7 on 1st string of 1st 3672 or 1st string on 1st 3674)
   %.D10  Disk unit (310-7 on 2nd string of 1st 3672 or 2nd string on 1st 3674)
   %.D20  Disk unit (320-7 on 1st string of 2nd 3672 or 3rd string on 1st 3674)
   %.D30  Disk unit (330-7 on 2nd string of 2nd 3672 or 4th string on 1st 3674)
  %.C1   Kontroller for next 32 disks            %KON=1 %KCUN=1
   %.D40  Disk unit (340-7 on 1st string of 3rd 3672 or 1st string on 2nd 3674)
   %.D50  Disk unit (350-7 on 2nd string of 3rd 3672 or 2nd string on 2nd 3674)
   %.D60  Disk unit (360-7 on 1st string of 4th 3672 or 3rd string on 2nd 3674)
   %.D70  Disk unit (370-7 on 2nd string of 4th 3672 or 4th string on 2nd 3674)
 %.B2   Channel 2 of SA 0 (does not exist)
 %.B3   Channel 3 of SA 0 (does not exist)
%.A1   SA-10 #1 (does not exist)
		CONI, CONO, and DATAI for the entire second SA-10
 %.B4   Channel 0 of SA 1 (does not exist)
 %.B5   Channel 1 of SA 1 (does not exist)
 %.B6   Channel 2 of SA 1 (does not exist)
 %.B7   Channel 3 of SA 1 (does not exist)

~  ;End of COMMENT
SUBTTL	CONO and CONI bits

	SA0=274		;I/O device code for first SA-10  (300-317 in low core)
	SA1=400		;I/O device code for second SA-10 (320-337 in low core)

;SA-10 CONO bits

CLERSA==1B18	;400000 (FTASER) Reset the SA-10
CLRMER==1B19	;200000 (FTASER) Clear memory errors
;	77B25	;176000 unused?
;	1B26+1B30; 1040 Set clock on, no-op if already on
;	1B26+0B30; 1000 Stop clock, pulse it if already stopped
;	29-30 + 31-32   Set/Clear flags
;	7B29+1B30;  740 Enable interrupts from channel  (in bits 31&32)
;	7B29+0B30;  700 Disable interrupts from channel (in bits 31&32)
;	6B29+1B30;  640 Set attention flag for channel  (in bits 31&32)
;	6B29+0B30;  600 Dismiss interrupt from channel  (in bits 31&32)
;	5B29+1B30;  540 Set STATUS REQUEST for channel  (in bits 31&32)
;	5B29+0B30;  500 Clear STATUS REQUEST            (in bits 31&32)
;	4B29+1B30;  440 Set GO bit for channel          (in bits 31&32)
;	4B29+0B30;  400 Clear GO bit for channel        (in bits 31&32)
;	3B29	;   300 Reset channel                   (in bits 31&32)
;	2B29	;         ?
;	1B29	;         ?
;	0B29	;       NOOP, set up to return one of 6 words on next DATAI
;	   5B32	;    50     Return high order 2 bits of memory address
;	   4B32	;           ?
;	   3B32	;    30     Return RH of memory buffer
;	   2B32	;    20     Return LH memory buffer in 18-35, channel in 16-17
;	   1B32	;    10     Return 20 bits of memory address
;	   0B32	;           ?
;	3B32	;    30 Addresses the channel (0, 1, 2, or 3) if not NOOP
;	7B35	;     7 PI assignment

;SA-10 CONI bits

;	1B18	;400000 This SAX caused an interrupt (test for CONSO skip chain)
MEMERR==3B20	;300000 (FTASER)
;	1B19	;200000 PARITY error detected by channel
;	1B20	;100000 NXM error detected by channel
;	17B24	; 71000 Interrupt enable flags   (21=0,22=1,23=2,24=3)
;	17B28	;  3400 GO flags                 (25=0,26=1,27=2,28=3)
;	17B32	;   170 Attention (STATUS) flags (29=0,30=1,31=2,33=3)
;	7B35	;     7 PI assignment

;----------------------

;Error bits returned instead of CONI data

ERRCMR== 1B30	;(BPXKON) COMMAND REJECT
ERRBOP== 1B29	;(BPXKON) BUS OUT PARITY
ERRBIP== 1B28	;(BPXKON) BUS IN PARITY
ERRPRT== 1B27	;(BPXKON) PROTECTION (SET FILE MASK) FAILURE
ERRUNK== 1B26	;(BPXKON) UNKNOWN ERROR (NO BITS CHECK BUT UNIT CHECK)
ERROVR== 1B25	;(BPXKON) OVERRUN
ERRNXM== 1B24	;(BPXKON) NXM
ERRPAR== 1B23	;(BPXKON) PARITY ERROR
ERRSRC== 1B22	;(BPXKON) SEARCH ERROR (NO RECORD FOUND)
ERRINV== 1B21	;(BPXKON) INVALID TRACK FORMAT
ERRRCV== 1B20	;(BPXKON) RECOVERABLE DATA CHECK
ERRDTA== 1B19	;(BPXKON) UNRECOVERABLE DATA CHECK
ERRCNT== 1B18	;(BPXKON) COUNT ERROR (CHANNEL TERMINATION)
ERRBSY==(1B17)	;(BPXKON) BUSY
ERRATN==(1B16)	;(BPXKON) ATTENTION FLAG
ERRUXC==(1B15)	;(BPXKON) UNIT EXCEPTION
ERREQP==(1B14)	;(BPXKON) PERMANENT EQUIPMENT CHECK
ERREQC==(1B13)	;(BPXKON) EQUIPMENT CHECK
ERRLEN==(1B12)	;(BPXKON) LENGTH ERROR
ERRCON==(1B11)	;(BPXKON) CONTROL ERROR
ERRSEL==(1B10)	;(BPXKON) SELECT ERROR
ERRWPT==(1B9)	;(BPXKON) WRITE PROTECT ERROR (COMMAND REJECT ALSO ON)

;SA-10 ERROR BITS (first 8 bits of reported status)

ASYNCH==(1B0)	;(FTASER)
SELERR==(1B2)	;         SELECT ERROR
BUSERR==(1B3)	;         BUS IN PARITY ERROR
 BUSIN==(1B3)	;(FTASER)
CONERR==(1B4)	;(BPXKON) CONTROL ERROR
CNTLER==(1B4)	;(FTASER)
LENERR==(1B6)	;         LENGTH ERROR
PIFERR==(1B7)	;(PAKCOP) PROGRAM INTERUPT FLAG
PRGINT==(1B7)	;(FTASER)

;SA-10 REPORTED STATUS BITS

ATTEN== (1B8)	; (BOTH)  ATTENTION
ATTN==  (1B8)	;(FTASER) ATTENTION
STSMOD==(1B9)	; (BOTH)  STATUS MODIFIER
STAMOD==(1B9)	;(FTASER) STATUS MODIFIER
CUEND== (1B10)	;         CONTROL UNIT END
BUSY==  (1B11)	;         BUSY
CHNEND==(1B12)	;(PAKCOP) CHANNEL END
DEVEND==(1B13)	;         DEVICE END (COMES FROM PACK ON LINE)
UCHK==  (1B14)	; (BOTH)  UNIT CHECK
UNITCK==(1B14)	;(FTASER) UNIT CHECK
UXCP==  (1B15)	; (BOTH)  UNIT EXCEPTION
UNITEX==(1B15)	;(FTASER) UNIT EXCEPTION

;SA-10 CONTROL BITS  (first 8 bits of control word)

TIC==   (1B1)	;TRANSFER IN CHANNEL
NOMEMT==200	;NO MEMORY TRANSFER
TRBIT== 100	;TRANSFER BIT STREAM MODE (DISK AND 7-TRACK)
XCTCMD== 40	;EXECUTE COMMAND (HALT IF THIS BIT NOT SET)
CHAIN==  20	;CHAIN COMMAND
TRBYTE== 10	;TRANSFER BYTE MODE (INDUSTRY MODE, DISK AND TAPE)
INTRPT==  4	;INTERUPT
IGNLEN==  2	;IGNORE LENGTH ERROR
OFFSET==  1	;BYTE MODE OFFSET
TRWORD==  0	;TRANSFER WORD MODE
TRTAPE==110	;TRANSFER TAPE COMPATABILITY (9-TRACK DEC FORMAT)

;BYTMOD==TRBYTE+CHAIN+XCTCMD+IGNLEN	;(BPXKON)
 BYTMOD==TRBYTE+CHAIN+XCTCMD		;(PAKCOP) NORMAL FOR A BYTE MODE TRANSFER
 NOXFR== NOMEMT+XCTCMD+IGNLEN		;(BPXKON)
;STROFA==XCTCMD+CHAIN+TRBYTE+OFFSET+IGNLEN;(BPXKON)
 WRDMOD==TRBIT+XCTCMD+CHAIN		;NORMAL FOR A WORD MODE TRANSFER
 ENDCMD==NOMEMT+0			;End of command list (XCTCMD is off)

	SAXBAS==300	;Base address for SA-10 (absolute address in low core)
	SA0BAS==SAXBAS+00 ;4 words per channel, 4 channels on SA10 #0
	SA1BAS==SAXBAS+20 ;4 words per channel, 4 channels on SA10 #1

;Format of a command

; BYTE (8) SAX.MODE, CCW.OPCODE, UNIT		;1st word (only 24 bits used)
; BYTE (12) -COUNT (24) ADDRESS.OF.BYTES	;2nd word (1B0 off for TIC)
;  (more pairs, or else TIC .-1)
; BYTE (8) 200					;End of command chain
SUBTTL	CCW-OP - Channel Command Word Operation codes

;Function codes (1st byte of CCW) for 3380 + 3330-11 or 3380-2 + 3350
;Same codes work for Memorex devices  3672 +  3675   or  3674  + 3650

  ;Command controls
;     ==  0	;X'00'          TEST I/O
;     == 20	;X'10'          .
;     ==  3	;X'03'          NO-OP
RECAL==  23	;X'13' (BPXKON) RECALIBRATE
SETSEC== 43	;X'23'  (BOTH)  SET SECTOR
SEEK==    7	;X'07'  (BOTH)  SEEK
;     == 27	;X'17'          RESTORE
SEEKCY== 13	;X'0B' (BPXKON) SEEK CYLINDER
;     == 33	;X'1B'          SEEK HEAD
;     == 17	;X'0F'          SPACE COUNT
SETFMK== 37	;X'1F' (PAKCOP) SET FILE MASK (FOR ALTERNATE TRACKS)

  ;Sense commands
SENSE==   4	;X'04'  (BOTH)  SENSE
;     == 24	;X'14'          UNCONDITIONAL RESERVE
;     ==224	;X'94'          DEVICE RELEASE
RRBL==  244	;X'A4' (BPXKON) READ AND RESET BUFFERED LOG
;     ==264	;X'B4'          DEVICE RESERVE
;     ==344	;X'E4'          SENSE I/O TYPE

  ;Write commands
;     ==  1	;X'01'          WRITE SPECIAL COUNT, KEY, DATA
BPXWT==   5	;X'05' (BPXKON) WRITE DATA
WRT33==   5	;X'05' (PAKCOP) WRITE DATA
;     == 15	;X'0D'          WRITE KEY AND DATA
;     == 21	;X'11'          ERASE
WRTR0==  25	;X'15' (PAKCOP) WRITE RECORD ZERO
WHOM==   31	;X'19' (PAKCOP) WRITE HOME ADDRESS
WCKD==   35	;X'1D' (PAKCOP) WRITE COUNT, KEY, DATA
;     ==135	;X'5D'          .

  ;Read commands
;     ==  2	;X'02'          READ IPL
BPXRD==   6	;X'06' (BPXKON) READ DATA
RED33==   6	;X'06' (PAKCOP) READ DATA
;     == 16	;X'0E'          READ KEY AND DATA
RCNT==   22	;X'12' (PAKCOP) READ COUNT
RDR0==   26	;X'16' (PAKCOP) READ RECORD ZERO
RHOM==   32	;X'1A' (PAKCOP) READ HOME ADDRESS
;     == 36	;X'1E'          READ COUNT, KEY, DATA
;     ==136	;X'5E'          READ MULTIPLE COUNT, KEY, DATA

  ;Multitrack read
;     ==202	;X'82'          .
;     ==206	;X'86'          READ DATA MULTITRACK
;     ==216	;X'8E'          READ KEY AND DATA MULTITRACK
;     ==222	;X'92'          READ COUNT MULTITRACK
;     ==226	;X'96'          READ RECORD ZERO MULTITRACK
;     ==232	;X'9A'          READ HOME ADDRESS MULTITRACK
;     ==236	;X'9E'          READ COUNT, KEY, DATA MULTITRACK
;     ==336	;X'DE'          .

  ;Search commands
;     == 51	;X'29'          SEARCH KEY EQUAL
;     ==251	;X'A9'          SEARCH KEY EQUAL MULTITRACK
SRCIDE== 61	;X'31'  (BOTH)  SEARCH ID EQUAL
;     ==261	;X'B1'          SEARCH ID EQUAL MULTITRACK
;     ==111	;X'49'          SEARCH KEY HIGH
;     ==311	;X'C9'          SEARCH KEY HIGH MULTITRACK
;     ==121	;X'51'          SEARCH ID HIGH
;     ==321	;X'D1'          SEARCH ID HIGH MULTITRACK
;     ==151	;X'69'          SEARCH KEY EQUAL OR HIGH
;     ==351	;X'E9'          SEARCH KEY EQUAL OR HIGH MULTITRACK
;     ==161	;X'71'          SEARCH ID EQUAL OR HIGH
;     ==361	;X'F1'          SEARCH ID EQUAL OR HIGH MULTITRACK

SRCHA==  71	;X'39'          SEARCH HOME ADDRESS EQUAL
;     ==271	;X'B9'          SEARCH HOME ADDRESS EQUAL MULTITRACK


;Bits in the Home Address flag byte
HA.CNT==200	;R0 count field moved to skip a defect
;;.KEY==100	;Current key field moved to skip a defect
HA.DAT== 40	;Current data field moved to skip a defect
;;.;;;== 20	;Bit not used
;;.OVR== 10	;Record overflows track
;;.;;;==  4	;Bit not used
HA.BAD==  2	;This track is bad
HA.ALT==  1	;This is an alternate track
		;0 = Good primary track or unused alternate track
		;1 = Alternate track, R0 points to defective primary track
		;2 = Defective primary track, R0 points to alternate track
		;3 = Defective alternate track, unusable
SUBTTL	Sense bits returned (as a result of CCW opcode SENSE=4)

;	CMDREJ==400000	;(FTASER)
;	INTREQ==200000	;(FTASER)
;	BUSOUT==100000	;(FTASER)
;	EQPCHK== 40000	;(FTASER)
;	DATCHK== 20000	;(FTASER)
;	OVERUN== 10000	;(FTASER)
;	CNVCHK== 20000	;(FTASER)

SCMDRJ==(1B0)	;(PAKCOP) COMMAND REJECT
;	(1B1)	;         OFF-LINE (INTERVENTION REQUIRED)
;	(1B2)	;         BUS OUT PARITY ERROR
;	(1B3)	;         EQUIPMENT CHECK
SDATCH==(1B4)	;(PAKCOP) DATA CHECK
;	(1B5)	;         PERMANENT OVERRUN
;	(1B6)	;         (3640 disks only) TRACK CONDITION CHECK
;	(1B7)	;         (3640 disks only) SEEK CHECK
;	(1B8)	;         PERMANENT ERROR, other bits should be on
;	(1B9)	;         INVALID TRACK FORMAT
;	(1B10)	;         END OF CYLINDER on multrack search
;	(1B11)	;         always zero
SNOREC==(1B12)	;(PAKCOP) NO RECORD FOUND
;	(1B13)	;         FILE PROTECTED
SNOWRT==(1B14)	;(PAKCOP) WRITE INHIBITED, COMMAND REJECT is also on
;	(1B15)	;         OPERATION INCOMPLETE, other bits should be on
;	(1B16)	;	(3640 disks only) RPS FEATURE
;	(1B17)	;	CORRECTABLE
;	(1B18)	;	ALTERNATE CONTROLLER SELECTED (3353/3354 or 3355/3356)
;	(1B19)	;	ENVIRONMENTAL DATA PRESENT
;	(1B20)	;	EMULATION MODE (335x disks only)
;	(1B21)	;	(3640 disks only) FIXED HEAD
;	(1B22)	;	(3640 disks only) DATA MODULE SIZE = 70 MB
;	(1B23)	;	(3640 disks only) DATA MODULE SIZE = 35 MB
  ;The remaining 21 bytes (24 bytes total) have varying interpretations
SUBTTL	Defintions from FTASER.MAC

REPEAT 0,<
;FORMAT OF SA-10 WORDS:

;    UNIT COMMAND LIST WORDS:

;        DEVICE COMMAND WORDS:

;            BITS	MEAN
;            0		1=NO MEMORY TRANSFER, 0=MEM TRANS.
;     	     1&4	00-WORD MODE
;            		01-BYTE MODE
;            		10-NATURAL MODE
;            		11-TAPE COMPATABILITY MODE
;            2		1=EXECUTE,0=HALT
;            3		CHAIN TO NEXT COMMAND
;            5		PROGRAM INTERRUPT
;            6		1=IGNORE LENGTH ERR,0=DON'T IGNORE
;            8-15	DEVICE COMMAND
;            16-23	DEVICE ADDRESS

;        DATA WORDS:

;            BITS	MEAN
;            0		1=THIS IS THE LAST DATA WORD IN THIS
;	    		GROUP, 0=NOT LAST.
;            1-11	2'S COMPLEMENT OF WORD/BYTE COUNT
;            14-35	1ST MEM ADDR, UNLESS 0 & WE ARE READING
;			FROM THE DEVICE, IN WHICH CASE MEANS
;			NO DATA TRANSFER.

;        TRANSFERS IN CHANNEL:

;            BITS	MEAN
;            0		MUST BE 0
;            1		MUST BE 1
;            14-35	ADDR OF NEXT COMMAND


;    BMX WORDS:

;	     BITS	MEAN
;	     0-7	DEVICE ADDRESS
;	     8-11	1101-START DEVICE
;	    		1110-WAITING ON DEVICE
;	    		1111-TERMINATED DEVICE
;	    		0000-END OF LIST
;	     14-35	ADDR OF DEVICE(UNIT) CMD LST
;FLAGS:

    ;FOR UNIT CMDS:

	NOMXFR==400000	;(FTASER)
	EXECUT==100000	;(FTASER)
	CMDCHN== 40000	;(FTASER)
	FRCINT== 10000	;(FTASER)
	IGNLEN==  4000	;(FTASER)
	OFFSET==  2000	;(FTASER)
	    CNEXNO==CMDCHN!EXECUT!NOMXFR

    ;FOR TRANSFERS IN CHANNEL:
	TIC==200000	;(FTASER)


    ;FOR DATA WORDS:
	LASDAT==400000	;(FTASER)


    ;FOR HALTS:
	HALT==400000	;(FTASER)


    ;FOR BMX WORDS:
	STRTDV==15	;(FTASER)
	TERMDV==17	;(FTASER)


    ;TO SET UP BMX MODE:
	BMX==400000	;(FTASER)

>  ;End of REPEAT 0 around FTASER definitions

;End of SAXPRM.MAC
SUBTTL	PAKCOP definitions
;TITLE	PAKCOP - Pack copy, format, etc for 3330's and 3350's
;  .LOAD /SAVE:PAKCOP SAXPRM.MAC+PAKCOP.MAC
IFNDEF SA0,<PRINTX ?Need to search SAXPRM for SA-10 definitions>

	VERSIO==30	;Version number

IFNDEF RECSIZ,<RECSIZ==^D128>
IFNDEF FT3350,<FT3350==

;                  Table of Contents for PAKCOPY
;
;
;			   Section			      Page
;
;    1. CONO and CONI bits . . . . . . . . . . . . . . . . . .   2
;    2. CCW-OP - Channel Command Word Operation codes  . . . .   3
;    3. Sense bits returned (as a result of CCW opcode SENSE .   4
;    4. Defintions from FTASER.MAC . . . . . . . . . . . . . .   5
;    5. "DDT" - Go to DDT if it is loaded, else RESTART  . . .  10
;    6. "RESTART" - check status of all on-line packs  . . . .  15
;    7. "INIT" - Initialize HOME and BAT pages on one unit . .  21
;    8. "COPY" - Copy a set of packs . . . . . . . . . . . . .  22
;    9. "OLDC" - Old copy routine (1 pack at a time) . . . . .  38
;   10. "NEW" - Change unit ID on an existing home page  . . .  41
;   11. "STATUS" - List status of all on-line units  . . . . .  42
;   12. "AVERIFY" - Verify that alternate tracks are readabl .  42
;   13. "AFORMAT" - Verify that the alternate tracks are for .  42
;   14. "LIST" - List map of bad spots from BAT page . . . . .  47
;   15. "ALIST" - List information about alternate track ass .  48
;   16. "DOIT" - HERE TO HANDLE A COMMAND WHICH REQUIRES VER .  50
;   17. "ZFORMAT" - Zero alternate track assignments, format .  51
;   18. "ASSIGN" - Assign one alternate track  . . . . . . . .  53
;   19. "DEASSIGN" - Deassign an alternate track . . . . . . .  57
;   20. "ERRMAK" - Make a bad alternate track (to test COPY  .  58
;   21. "FORMAT" - Rewrite COUNT-KEY-DATA on pack  . . . . . .  63
;   22. "VERIFY" - Verify that all pages can be read . . . . .  70
;   23. "SHH" - Quiets the bell  . . . . . . . . . . . . . . .  72
;   24. "SWITCH" - Print settings of the sense switches  . . .  72
;   25. "BOOTS" - Load BOOTS from disk pages 3,4,5 . . . . . .  73
;   26. TTY initialization (set KL10 flag if appropriate)  . .  77
;AC ASSIGNMENTS
P=17	;PDL
U=16	;UNIT
K=15	;KONTROLER
C=14	;CHANNEL
S=13	;SA-10
CH=12	;CHARACTER
DAT=11	;POINTER TO DATA AREA
CMD=10	;POINTER TO COMMAND AREA
CYL=7
HEAD=6
REC=5

;TEMPS
T1=1
T2=2
T3=3
T4=4
F==0

OPDEF PJRST [JRST]

;UUO'S FOR OUTPUT

OPDEF ODEC [1B8]	;DECIMAL OUTPUT
OPDEF OOCT [2B8]	;OCTAL OUTPUT
OPDEF OCHR [3B8]	;CHARACTER OUTPUT
OPDEF OCHI [4B8]	;CHARACTER OUTPUT IMMEDIATE
OPDEF OASC [5B8]	;ASCIZ OUTPUT
OPDEF CRLF [6B8]	;CR-LF OUTPUT
OPDEF OSIX [7B8]	;OUTPUT SIXBIT

;UUO MAY DESTROY T1,T2,CH

	;FLAG BITS IN F

F.NBAT==1	;COPY - ABORT IF BAD AREAS IN BAT BLOCKS
F.NERR==2	;COPY - CONTINUE IF READ ERRS ON SOURCE
F.NALT==4	;COPY - ABORT IF READ OR WRITE ERRS ON DEST
F.BCOP==10	;BAD COPY
KL10==20	;KL10 cpu

BLKSIZ==^D<128>		;Words per block
PAGSIZ==^D<512>		;Words per page
RECSIZ==RECSIZ		;Number of PDP-10 words per record
RECPAG==PAGSIZ/RECSIZ	;Records per page, either 1 or 4
BYTSIZ==<^D36*RECSIZ>/8	;Number of 8-bit bytes in a record, 576 or 2304

IFE FT3350,<    ;3330(3675) definitions
    HEADS=^D<19>	;Heads 0-18
    CYLS=^D<808>	;Cylinders 0-807
    ALTS=^D<815-808>	;7 maintenance cylinders, 808-814
    BYTES=^D<13030>	;Unformatted bytes per track
    GAP=^D<135>		;see OS/VS2 MVS Data Management Services Guide
    ;RECTRK=18 if formatted in blocks, =5 if formatted in pages (=20 blocks)
>  ;End 3330

IFN FT3350,<    ;3350(3650) definitions
    HEADS=^D<30>	;Heads 0-29
    CYLS=^D<555>	;Cylinders 0-554
    ALTS=^D<560-555>	;5 maintenance cylinders, 555-559
    BYTES=^D<19069>	;Unformatted bytes per track
    GAP=^D<185>		;see OS/VS2 MVS Data Management Services Guide
    ;RECTRK=7 if formatted in pages, =25 if formatted in blocks
>  ;End 3350

RECTRK==<BYTES+GAP>/<BYTSIZ+GAP> ;Records per track (18 or 5 or 7)
PAGCYL=<RECTRK*HEADS>/RECPAG	;Pages per cylinder (85, 95, or 210)
RECCYL=PAGCYL*RECPAG		;Blocks per cylinder must be multiple of 4
PAGES=PAGCYL*CYLS		;Total pages (68680, 76760, or 116550)

DEFINE PRINTD(A1,A2,B1,B2,C1,C2),<IF2,<PRINTX A1 A2 B1 B2 C1 C2>>

  RADIX 10
PRINTD (\RECSIZ,words per record =,\RECTRK,records per track &,\HEADS,heads)
PRINTD (\PAGCYL,pages per cylinder *,\CYLS,cylinders =,\PAGES,pages)
  RADIX 8

COPCML==HEADS*<RECTRK*<SIDZ.C+REDZ.C>+SEKZ.C>+1
COPDTL==SEKZ.D*RECTRK*HEADS
COPDL1==RECSIZ*HEADS*RECTRK
XTRREC==100			;Extra record for write check
;APR BITS
NXM==1B29
APRCLK==1B26

;TURN ON DISK PI'S

DSKON==1B28+1B25+1B32	;TURN ON PI, CHANNEL, CHANNEL 4

;UNIT STATUS BITS

;OFLIN==(1B0)	;OFF-LINE, HIGH ORDER BIT FOR SKIPL
SNGDNS==(1B1)	;SINGLE DENSITY
NOWRT==(1B2)	;WRITE PROTECTED
NOFMT==(1B3)	;NOT FORMATTED
DRVUSD==(1B4)	;USED IN COPY PROGRAM

RVFZ.C==RECPAG*<SEKZ.C+SIDZ.C+REDZ.C>+1
RVFZ.D==RECPAG*<SEKZ.D+REDZ.D>

FT1Z.C=<RECTRK+1>*WCKZ.C	;FORMAT 1 TRACK
FT1Z.D=<RECTRK+1>*WCKZ.D

AVFZ.C==SEKZ.C+RH0Z.C
AFMZ.C==MSKZ.C+SEKZ.C+WH0Z.C+1

FMTZ.C=HEADS*<FT1Z.C+SEKZ.C+SIDZ.C>+SECZ.C+1	;FORMAT CYL
FMTZ.D=HEADS*<FT1Z.D+SEKZ.D>
;KL10 DEFINITIONS

DTE==200	;DTE DEVICE CODE

DTEFLG=EBRADD+444	;DTE OPERATION DONE FLAG
DTEF11=EBRADD+450	;DATA FROM 11
DTECMD=EBRADD+451	;COMMAND TO 11
DTEMTD=EBRADD+455	;CTY OUTPUT DONE
DTEMTI=EBRADD+456	;CTY INPUT READY
CL11PT==1B26		;CLEAR DOORBELL
TO11DB==1B22		;DOORBELL
.DTESP==11B27		;ENTER SECONDARY PROTOCOL COMMAND
.DTCTO==10B27		;CTY OUTPUT CHAR
.DTRSW==3B27		;READ SWITCHES

;TIMER STUFF
TIM==20			;TIMER DEVICE CODE
TICK==^D1666		;SET INTERVAL FOR 1/60 SEC
TO.CIT==1B18		;CLEAR TIMER
TO.SIT==1B21		;START TIMER
TI.ITD==1B22		;TIMR DONE
TO.CTD==1B22		;CLEAR TIMER DONE


LG.LUB==1B2		;LOAD UBR

LP.NXM==1B25
LP.CSF==1B22
SUBTTL	Start of program is at location 1000 (DDT at 1001)

DEFINE	PRINT(A,B,C),<IF2,<PRINTX A B C>>

	LOC <JOBVER=:137>
	VERSIO			;VERSION NUMBER

	LOC 0			;MAKE EBR AT PAGE 0.
				; (KL DOESN'T DO LUUOS TO EBR LIKE IT SHOULD, INSTEAD
				; IT DOES THEM TO VIRTUAL PAGE 0.)

UBRADD:
EBRADD:	BLOCK	1000		;SPACE FOR EPT IN CASE ITS A KL

EBR==EBRADD/1000
UBR==UBRADD/1000


START::	SKIPA	T1,JOBSYM##	;Program starts at location 1000
	 JRST	SYSDDT		;Start at 1001 to go to DDT
	MOVEM	T1,36		;Set up symbol pointer for EDDT
	MOVE	T1,[JSR UUOH]
	MOVEM	T1,EBRADD+41	;SET UP UUO HANDLER
	MOVE	T1,[UUOERR]
	MOVEM	T1,UBRADD+430	;UBR ALSO SET TO THIS.
	MOVEI	P,PDL-1
	PUSHJ	P,TTYINI	;Determine if KI CTY or KL with KLDCP console
	PUSHJ	P,ABTINI	;INITIALIZE ABORT
	OASC	HELLO
	SKIPE	DDT
	 OASC	[ASCIZ /
Typing Control-C here will jump to DDT.
/]
REDDAT:	OASC	[ASCIZ /

Enter date as MM-DD-YYYY /]
	PUSHJ P,REDLIN
	MOVEI T1,^D10
	MOVEM T1,RADIX	;SET INPUT RADIX
	PUSHJ P,SCAN
	CAIN CH,"C"-100	;Control-C?
	 JRST SYSDDT
	CAIE T1,1
	 JRST BADDAT	;MUST BE A NUMBER
	MOVE T1,ACCUM
	CAIG T1,^D12
	CAIGE T1,1
	 JRST BADDAT
	MOVEM T1,MONTH
	PUSHJ P,SCAN
	CAIN T1,3
	 PUSHJ P,SCAN	;ALLOW ONE SPECIAL CHR BETWEEN NUMBS
	CAIE T1,1
	 JRST BADDAT
	MOVE T1,ACCUM
	CAIG T1,^D31
	CAIGE T1,1
	 JRST BADDAT
	MOVEM T1,DAY
	PUSHJ P,SCAN
	CAIN T1,3
	 PUSHJ P,SCAN
	CAIE T1,1
	 JRST BADDAT
	MOVE T1,ACCUM
	CAIG T1,^D2008
	CAIGE T1,^D1974
	 JRST BADDAT
	SUBI T1,^D1964
	MOVE T2,T1
	ANDI T2,3
	MOVE T3,T1
	IMULI T1,^D365
	ADDI T3,3
	LSH T3,-2
	ADD T1,T3	;NOW HAVE NUMBER OF DAYS TO START OF YEAR
	MOVE T3,MONTH
	ADD T1,MONTAB-1(T3)
	CAILE T3,2
	SKIPE T2	;IS IT A LEAP YEAR
	 SKIPA
	ADDI T1,1	;LEAP YEAR AND MONTH LATER THAN FEB
	ADD T1,DAY	;NOW THE DAY
	SUBI T1,1
	MOVEM T1,THSDAT
REDTIM:	OASC [ASCIZ /
Enter time as HHMM /]
	PUSHJ P,REDLIN
	PUSHJ P,SCAN
	CAIN T1,1	;MUST BE A NUMBER
	 SKIPGE T1,ACCUM	;AND NOT NEGATIVE
	JRST BADTIM
	IDIVI T1,^D100	;DIVIDE INTO HOURS AND MINUTES
	CAIGE T2,^D60	;IF HOURS TOO BIG
	CAIL T1,^D24	;OR HOURS TOO BIG
	 JRST BADTIM	;DON'T ACCEPT IT
	IMULI T1,^D60
	ADD T1,T2	;CONVERT WHOLE THING TO MINUTES
	HRLM T1,THSDAT
	PUSHJ	P,ABTINI	;Set abort address to .+1
	MOVEI	P,PDL-1		;Reset stack when aborted
	PUSHJ	P,TTYINI	;Reset CTY type when aborted
	JRST	RESTRT		;Read status on all disk units

BADTIM:	OASC [ASCIZ /
INCORRECT TIME, RETYPE /]
	JRST REDTIM

DEFINE TTL(NAME,DISK,VER),<
	TITLE	NAME - Pack copy & format for DISK, version VER
IF2,<	PRINTX	NAME - Pack copy & format for DISK, version VER>
HELLO:	ASCIZ  /NAME - Pack copy & format for DISK, version VER/>

IFE FT3350,<
  IFE RECSIZ-^D128,<TTL(PAKCOP,<3330 in blocks>,\VERSIO)>
  IFE RECSIZ-^D512,<TTL(PAKCP3,<3330 in pages>,\VERSIO)>
>
IFN FT3350,<
  IFE RECSIZ-^D128,<TTL(PAKCPX,<3650 in blocks>,\VERSIO)>
  IFE RECSIZ-^D512,<TTL(PAKCP5,<3650 in pages>,\VERSIO)>
>
	DEFINE MSIZE
<X <31,28,31,30,31,30,31,31,30,31,30,31>>

	DEFINE X (A)
<%%Z==0
IRP A,<%%Z==%%Z+^D'A
	%%Z>>

MONTAB:	0
	MSIZE

BADDAT:	OASC [ASCIZ /
INCORRECT DATE, RETYPE /]
	JRST REDDAT

	DEFINE X(A)
<%%Z==0
IRP A,<%%Z==%%Z+^D'A
IFE ^D'A-^D28,<%%Z==%%Z+1>
	%%Z>>
MONTB2:	0	;FOR BACK CONVERSION
	MSIZE
SUBTTL	Control-Block definitions

SAXN==1		;NUMBER OF SA-10'S
 CH0N==2	;2 CHANNELS ON SA-10 0
  KN00==0	;NO KONTROLERS ON CHANNEL 0
  KN01==2	;2 ON SECOND
   BP0N==^D32	;32 UNITS
   BP0M==^D32	;OUT OF 32
    KN0==300	;First unit is 'C0'
   BP1N==^D32	;32 UNITS
   BP1M==^D32	;OUT OF 32
    KN1==340	;First unit is 'E0'
;NOW THE MACRO TO GENERATE CONTROL INFORMATION

%SAX==0	;SA-10 NUMBER
%CHN==0	;CHANNEL NUMBER
%KON==0	;KONTROLER NUMBER
%UNI==0	;UNIT NUMBER

	DEFINE CHNM(NUM)
<%.B'NUM>
	DEFINE KONM(NUM)
<%.C'NUM>
	DEFINE SXNM(NUM)
<%.A'NUM>
	DEFINE UNNM(NUM)
<%.D'NUM>
	DEFINE KDNM(NUM)
<KN'NUM>
	DEFINE KCNM(KNUM,CNUM)
<%'KNUM'.'CNUM>
	DEFINE INTNM(SAN)
<SA'SAN'INT>
SUBTTL	UNITCB - Unit Control Block

	DEFINE UNITCB(UN)
<%.D'UN:
IFG UN-4,<XLIST>
	PHASE 0
UNIIOW:!0
UNIBMX:!CHNM(\%CHN)+%CUN+CHNBMX
UNIKON:!KONM(\%KON)
UNISAX:!SXNM(\%SAX)
UNICHN:!CHNM(\%CHN)
UNISYS:!UNNM(\<%UNI+1>),,0
UNIRST:!0		;RESTART WORD FOR DEVICE
UNISTS:!0
UNINUM:!KDNM(\%KON)+%KUN
UNIERF:!0		;Error flag bits
UNIERR:!0		;CYL,HEAD,REC at time of error
UNIBAD:!0		;Number of bad tracks
UNICNT:!0		;Continue address (for RETRY)
UNISAC:!0		;SAVE AC'S
	BLOCK 20-1
UNIPDL:!0		;USE THIS FOR A PDL FOR THIS UNIT
	BLOCK 40-1
UNIPC:!	0	;SAVE PC
UNIRDS:!BYTE (8) BYTMOD,SENSE,KDNM(\%KON)+%KUN
	BYTE (12)-^D24 (24) %.D'UN+UNISNS
	BYTE (8) ENDCMD
UNISNS:!EXP 0,0,0,0,0,0	;24 sense bytes
	DEPHASE
%UNI==%UNI+1
%CUN==%CUN+1
%KUN==%KUN+1
	LIST >

	DEFINE KONCB(KNX)
<%KUN==0
	REPEAT BP'KNX'N,<UNITCB(\%UNI)>
%.C'KNX: PAGE
KCNM(\%KCUN,\%CHN)==.
	PHASE 0
KONRNG:!KN'KNX,,KN'KNX+BP'KNX'M
KONBSU:!0
KONRST:!0
KONKON:!KCNM(\<%KCUN+1>,\%CHN)
	%T==%UNI-%KUN
KONTAB:!REPEAT BP'KNX'N,<UNNM(\%T)
	%T==%T+1>
	REPEAT BP'KNX'M-BP'KNX'N,<0
	%CUN==%CUN+1>
	DEPHASE
%KCUN==%KCUN+1
%KON==%KON+1
	PAGE >

	DEFINE CHNCB(CN,SAN,CN1)
<%CUN==0
%KCUN==0
	REPEAT KN'SAN'CN,<KONCB(\%KON)>
IFN %CUN,<
%.B'CN1:
	PHASE 0
CHNIIE:!CONO SA'SAN,7B29+1B30+4+<CN>B32
CHNGO:!	CONO SA'SAN,4B29+1B30+4+<CN>B32
CHNCLR:!CONO SA'SAN,6B29+4+<CN>B32
CHNCHK:!CONSO SA'SAN,100_<-CN>
CHNSTS:!SAXBAS+SAN*20+CN*4+1
CHNKON:	KCNM(0,\CN1)
CHNBMX:!REPEAT %CUN,<-1>
	0
	DEPHASE
>
IFE %CUN,<%.B'CN=0>
KCNM(\%KCUN,\CN1)==0
%CHN==%CHN+1
>
SUBTTL	SAXCB - SA10 Control Block

	DEFINE SAXCB(SAN)
<	%TS==0
	REPEAT CH'SAN'N,<CHNCB (\%TS,\SAN,\%CHN)
	%TS==%TS+1>
SA'SAN'INT: CONSO SA'SAN,1B18	;IS THIS INTERUPT FOR THIS SA-10
	JRST INTNM(\<SAN+1>)	;ON TO NEXT CHANNEL
	JSR CHNSAV	;SAVE CHANNEL
	JSP S,SAXCOD
%.A'SAN:
	PHASE 0
SAXCNI:!CONI SA'SAN,T2
SAXCNO:!CONO SA'SAN,(T2)
SAXDTI:!DATAI SA'SAN,T2
	%TS==%CHN-CH'SAN'N
SAXCHN:!REPEAT CH'SAN'N,<CHNM(\%TS)
	%TS==%TS+1>
	REPEAT 4-CH'SAN'N,<0>
	DEPHASE
%SAX==%SAX+1
>

	REPEAT SAXN,<SAXCB(\%SAX)>

UNNM(\%UNI)==0
SUBTTL	"DDT" - Go to DDT if it is loaded, else RESTART

SYSDDT:	SKIPE	DDT	;Here on start from 1001 or ^C during date question
	 JRST	DDT	;Go to DDT if it is there
	JRST	START	;Oops, tried "ST 1001" but no DDT loaded.

GODDT:	SKIPE	DDT	;Here on "DDT" command
	 JRST	GODDT1	;Go to DDT if it is there
	OASC	[ASCIZ /?DDT not loaded
/]
	JRST	RESTRT

GODDT1:	OASC	[ASCIZ /Entering DDT, use RESTRT<ESC>G to continue
/]
	PUSHJ	P,DDT	;Put return PC of RESTRT on the stack for "POPJ P,$X"

SUBTTL	"RESTART" - check status of all on-line packs

RESTRT::CONO APR,1B19	;RESET WORLD
	CONO APR,@CLRNXM
	CONO PI,1B23	;AND PI TO MAKE SURE
	MOVE T1,[JSR CHINT]
	MOVEM T1,EBRADD+50
	MOVEI P,PDL-1
	MOVEI T1,10
	MOVEM T1,RADIX	;RESET RADIX TO OCTAL
	MOVSI T1,-^D255
MEMLP:	MOVE T2,(T1)
	CONSZ APR,@NXMFLG
	JRST MEMFND
	ADDI T1,1777
	AOBJN T1,MEMLP
MEMFND:	HRRZM T1,MEMSIZ	;SET UPT MEMORY SIZE
	HLRZ T1,JOBSA##	;THIS IS LEFT HERE BY LOADER
	MOVEM T1,MEMLOW	;AND SAVE IT AS LOW MEMORY ADDRESS
	PUSHJ P,CLRIO	;RESET ALL I/O WAIT FLAGS
	HLRZ U,SYSUNI	;NOW RESET ALL DRIVE FLAGS
ONLCHK:	HRRZ K,UNIKON(U)
	HRRZ S,UNISAX(U)
	HRRZ C,UNICHN(U)
	XCT SAXCNI(S)	;READ CONI DATA
	JUMPE T2,SAXOFL	;SA-10 IS OFF LINE
	MOVE T1,[200000,RQZRO]  ;*?* (shouldn't this be XWD)?
	MOVE T2,CHNSTS(C)
	MOVEM T1,-1(T2)	;SET POINTER TO A RANDOM COMMAND
	MOVEI T1,^D10000
	XCT CHNGO(C)	;AND START CHANNEL
	XCT CHNCHK(C)
	SOJG T1,.-1	;WAIT FOR RESPONSE FOR A WHILE
	JUMPLE T1,CHNOFL	;CHANNEL OFF LINE
	MOVEI T2,600000
	XCT SAXCNO(S)	;CLEAR SA-10
	MOVE T2,CHNSTS(C)
	MOVEI T1,CHNBMX(C)
	TLO T1,600000
	MOVEM T1,-1(T2)	;SET POINTER TO BLOCK MULTIPLEXOR LIST
	MOVE T1,UNINUM(U)
	DPB T1,[POINT 8,SEK0AD,23]
	MOVEI T1,SEK0AD
	CONO PI,DSKON	;TURN DISK ON
	PUSHJ P,STRTU
	CONO PI,1B23	;RESET PI'S
	SKIPN T1,UNIERF(U)
	JRST UNIONL
	TLNE T1,SELERR
	JRST KONOFL	;SELECT ERROR-KONTROLLER OFF-LINE
SAYOFL:	OASC [ASCIZ /
#U OFF-LINE/]
	SETOM UNISTS(U)	;ASSUME UNIT OFF-LINE
	CONO PI,1B23
NXTUNI:	HLRZ U,UNISYS(U)
NXTUN2:	JUMPN U,ONLCHK	;CHECK REST OF UNIT
NXTUN3:	PUSHJ P,ABTINI	;RESET ABORT LOCATION
	JRST CMDSET	;SET TO RECIEVE A COMMAND
UNIONL:	SETZM UNISTS(U)	;SET UNIT ON-LINE
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,WRTQ0,23]
	DPB T2,[POINT 8,WRTQ0+3,23]	;THE WRITE
	MOVEI T1,WRTQ0
	CONO PI,DSKON
	PUSHJ P,STRTU
	SKIPN T1,UNIERF(U)
	JRST TRY500	;SEE IF SINGLE OR DOUBLE DENSITY
	TLNN T1,UCHK
	JRST SAYOFL	;NOT UNIT CHECK, SAY OFF-LINE
	MOVE T1,UNISNS(U)	;GET SENSE BITS
	TLNE T1,SNOREC	;CHECK IF NO RECORD FOUND
	JRST NONFMT
	TLNN T1,SNOWRT	;DID IT SAY WRITE PROTECT?
	JRST SAYOFL	;STRANG CONDITION, SAY OFF-LINE
	MOVSI T1,NOWRT
	IORM T1,UNISTS(U)	;MARK WRITE PROTECT
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,REDQ0,23]	;NOW SET THE READ
	DPB T2,[POINT 8,REDQ0+3,23]
	MOVEI T1,REDQ0
	PUSHJ P,STRTU
	SKIPN T1,UNIERF(U)
	JRST TRY500	;MUST HAVE READ THE RECORD
	TLNN T1,UCHK
	JRST SAYOFL	;SOME FUNNY ERROR
	MOVE T1,UNISNS(U)
	TLNN T1,SNOREC	;CHECK IF NO RECORD FOUND
	JRST SAYOFL	;AGAIN A FUNNY ERROR
NONFMT:	MOVSI T1,NOFMT	;NOT FORMATTED
	IORM T1,UNISTS(U)
TRY500:	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,SEK500,23]
	MOVEI T1,SEK500
	PUSHJ P,STRTU
	CONO PI,1B23	;RESET
	SKIPN T1,UNIERF(U)
	JRST PRTONL	;PRINT THE ON-LINE MESSAGE
	TLNN T1,UCHK
	JRST SAYOFL	;FUNNY ERROR
	MOVE T1,UNISNS(U)
	TLNN T1,SCMDRJ	;SHOULD BE COMMAND REJECT
	JRST SAYOFL
	MOVSI T1,SNGDNS	;SIGLE DENSITY
	IORM T1,UNISTS(U)
PRTONL:	OASC [ASCIZ /
#U /]
	LDB T1,[POINT 3,UNISTS(U),3]
	OASC @ONLTAB(T1)
	JRST NXTUNI	;NEXT UNIT

ONLTAB:	[ASCIZ /ON-LINE, DUAL DENSITY/]
	[ASCIZ /ON-LINE, DUAL DENSITY, UNFORMATED/]
	[ASCIZ /ON-LINE, DUAL DENSITY, WRITE PROTECT/]
	[ASCIZ /ON-LINE, DUAL DENSITY, WRITE PROTECT, UNFORMATED/]
	[ASCIZ /ON-LINE/]
	[ASCIZ /ON-LINE, UNFORMATED/]
	[ASCIZ /ON-LINE, WRITE PROTECT/]
	[ASCIZ /ON-LINE, WRITE PROTECT, UNFORMATED/]

CHNOFL:	OASC [ASCIZ /
SA-10 CHANNEL OFF-LINE, UNITS /]
	MOVEI T2,600000
	XCT SAXCNO(S)	;RESET SA-10 IF CHANNEL OFF-LINE
CHNOF1:	PUSHJ P,PRTKON
	JUMPE U,NXTUN3	;FINISHED
	HRRZ T1,UNICHN(U)
	CAME T1,C
	JRST NXTUN2	;DIFFERENT CHANNEL
	OCHI ","
	JRST CHNOF1

KONOFL:	OASC [ASCIZ /
STRING CONTROLLER OFF-LINE, UNITS /]
	PUSHJ P,PRTKON
	JRST NXTUN2	;WILL GET TO CMDSET IF LAST UNIT
;CLEAR I/O WAIT FLAGS AND BLOCK MULTIPLEXOR LIST

CLRIO:	CONO PI,1B23
	SETZM DEVWAT	;NO DEVICES WAITING
	HLRZ U,SYSUNI
CLRIO1:	SETZM UNIIOW(U)
	MOVSI T2,DRVUSD
	ANDCAM T2,UNISTS(U)	;CLEAR DRIVE IN USE BIIT FRROM COPY
	SETOM @UNIBMX(U)
	SETOM UNIRST(U)	;ALSO THE RESTART WORD
	HRRZ K,UNIKON(U)
	SETZM KONBSU(K)
	HRRZ S,UNISAX(U)
	MOVEI T2,600000
	XCT SAXCNO(S)	;RESET SA-10
	HLRZ U,UNISYS(U)
	JUMPN U,CLRIO1
	POPJ P,

SAXOFL:	OASC [ASCIZ /
SA-10 OFF-LINE, UNITS /]
SAXOF1:	PUSHJ P,PRTKON	;PRINT UNITS FOR THIS KONTROLER
	JUMPE U,NXTUN3	;FINISHED
	HRRZ T1,UNISAX(U)
	CAME T1,S
	JRST NXTUN2	;CONTINUE LOOKING, DIFFERENT SA-10
	OCHI ","
	JRST SAXOF1

PRTKON:	MOVE T3,UNINUM(U)
	HRRZ K,UNIKON(U)	;JUST IN CASE
	OOCT T3
PRTKN2:	MOVE T4,UNINUM(U)
	SETOM UNISTS(U)	;SAY UNIT IS OFF-LINE
	HLRZ U,UNISYS(U)
	JUMPE U,PRTKN1	;END OF UNIT LIST
	HRRZ T1,UNIKON(U)
	CAME T1,K	;ARE THEY THE SAME?
	 JRST PRTKN1	;NO, DIFFERENT "KONTROLLER"
	MOVE T1,UNINUM(U)
	TRNE T1,7	;STILL ON SAME STRING?
	JRST PRTKN2	;YES, CONTINUE

PRTKN1:	CAMN T3,T4	;JUST A SINGLE UNIT?
	POPJ P,		;YES, NOTHING MORE TO PRINT
	OCHI "-"
	OOCT T4
	POPJ P,
SUBTTL	STRTU/UNIGO/UNIRTY - start transfer on unit, wait for completion

UNIGOC:	PUSH	P,CYL		;Preserve AOBJN pointers in CYL and HEAD
	PUSH	P,HEAD
	PUSH	P,REC		;Preserve count in REC
	PUSHJ	P,UNIGO
	  SOS	-3(P)
	POP	P,REC
	POP	P,HEAD
	POP	P,CYL
	JRST	CPOPJ1

UNIGO:	MOVNI	T3,1		;No retrys
UNIRTY:	HLRZ	T1,CMD		;Start of command list
	PUSHJ	P,STRTU		;Start unit, wait for I/O to finish
	SKIPN	T1,UNIERF(U)	;Get error flag
	 JRST	CPOPJ1		;Success
	PUSHJ	P,COMERR	;Check retry count
	  JRST	UNIRTY		;Need to retry
	PJRST	COMERP		;Print error message, error return

STRTU:	POP P,UNIPC(U)	;SAVE RETURN ADDRESS
	MOVEM 17,UNISAC+17(U)	;SAVE AC'S
	MOVEI 17,UNISAC(U)
	BLT 17,UNISAC+16(U)
	MOVE 17,UNISAC+17(U)	;RESTORE SO ALL IN GOOD ORDER
	SETZM UNIERF(U)	;NO ERRORS
	SETOM UNIIOW(U)	;AND IN I/O WAIT
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,T1,7]	;SET UNIT
	TLO T1,(15B11)	;SET START ALSO
	MOVEM T1,UNIRST(U)
	MOVEM T1,@UNIBMX(U)	;SET IN BLOCK MULTIPLEX LIST
	AOS DEVWAT
	HRRZ C,UNICHN(U)
	XCT CHNIIE(C)	;ENABLE INTERUPT
	XCT CHNGO(C)	;AND START CHANNEL
WAIT:	JSP T1,TSTALT	;SEE IF HE WANTS TO ABORT
	HLRZ U,SYSUNI	;LLOK FOR UNITS THAT HAVE FINISHED
WAIT1:	SKIPLE UNIIOW(U)
	JRST WAITFN	;FOUNT ONE
	HLRZ U,UNISYS(U)	;NEXT UNIT
	JUMPN U,WAIT1
	SKIPE DEVWAT
	JRST WAIT
MAINGO:	MOVSI 17,SAVAC	;ALL DONE
	BLT 17,17	;RETURN
	POPJ P,

WAITFN:	SETZM UNIIOW(U)
	SOS DEVWAT
	MOVSI 17,UNISAC(U)
	BLT 17,17
	JRST @UNIPC(U)	;RESTART ROUTINE
SUBTTL	Command parser

GO::	MOVEI	P,PDL-1
CMDSET:	PUSHJ P,CLRIO
	MOVE T1,MEMLOW
	MOVEM T1,MEMFRE
	MOVEI T1,10
	MOVEM T1,RADIX
	SETOM BELFLG
	CONO PI,DSKON	;NOW WE HAVE THE WORLD RESET
CMDLP:	SETZM DOFLG	;CLEAR HELD COMMAND
;<
CMDLP1:	OASC [ASCIZ /

PAKCOP> /]
	SKIPE BELFLG	;THIS IS RESET BY THE SHH COMMAND
	PUSHJ P,BELWAT	;RING BELL EVERY 5 SECS UNTIL INPUT
	PUSHJ P,REDLIN
	PUSHJ P,SCAN	;GET SOMETHING FROM THE COMMAND LINE
	XCT CMDDSP(T1)	;DEPENDS ON WHAT WE SEE
BADCMD:	SETZM DOFLG	;CLEAR HELD COMMAND ON REAL ERROR
BADCD1:	OASC [ASCIZ /
TYPE HELP FOR LIST OF COMMANDS/]
	JRST CMDLP1

CMDDSP:	JRST CHKCMD	;ID IS 0, SEE WHAT COMMAND
	JFCL		;NUMBER NOT PERMITTED
	JRST CMDLP	;TERMINATION, JUST SAY * AGAIN
	JFCL		;SPECIAL CHARACTER NOT PERMITTED

CHKCMD:	MOVSI T2,770000
	MOVEI T3,0	;GET SET TO CREAT A MASK
	MOVE T1,ACCUM	;SET UP FOR THE SIXBIT OF THE ID
MAKMSK:	TDNN T1,T2
	JRST MSKDON	;FINISHED
	IOR T3,T2
	LSH T2,-6
	JUMPN T2,MAKMSK
MSKDON:	MOVSI T4,-CMDLEN	;TABLE LENGTH
	MOVEI U,0	;SAVE DISPATCH POINTER
CMDCHK:	CAMN T1,CMDNAM(T4)
	JRST @CMDGO(T4)	;EXACT MATCH, GO
	MOVE T2,CMDNAM(T4)
	AND T2,T3
	CAME T1,T2
	JRST NXTCMD
	JUMPN U,BADCMD	;MATCH ON WHAT WE HAVE, ANOTHER SEEN?
	MOVE U,T4	;NO, REMEMBER IT
NXTCMD:	AOBJN T4,CMDCHK
	JUMPE U,BADCMD	;NOTHING MATCHED, BAD COMMAND
	JRST @CMDGO(U)	;DISPATCH
;HERE ARE THE COMMAND DISPATCH TABLES

	DEFINE NAMES
<	X RESTART,RESTRT
	X DDT,GODDT
	X DOIT,DOITCM
	X COPY,PAKCOP
	X NEW,NEWID
	X INIT,HINIT
	X STATUS,STSCMD
	X LIST,MAPLST
	X BOOTS,LOAD
	X LOAD,LOAD
	X ALIST,ALTLST
	X SHH,QUIET
	X VERIFY,VERCMD
	X HELP,HELP
	X FORMAT,FORMAT
	X AFORMAT,AFMCMD
	X AVERIFY,AVRCMD
	X SWITCHES,PRTSWS
	X OLDC,OLDCOP,DOIT
	X REFRESH,REFACMD,DOIT
	X ASSIGN,ASSCMD,DOIT
	X DEASSIGN,DEACMD,DOIT
	X ERRMAK,ERRCMD,DOIT
	X ZFORMAT,ZFMCMD,DOIT
>

	DEFINE X(A,B,C)
<	<SIXBIT /A/>>

CMDNAM:	NAMES
CMDLEN==.-CMDNAM

	DEFINE X(A,B,C)
<	B>

CMDGO:	NAMES

HELP:	OASC HLPMSG
	JRST CMDLP

HLPMSG:	ASCIZ /
COMMANDS ARE:

HELP      PRINT THIS MESSAGE

BOOTS     LOAD BOOTS FROM THE DISK IF IT IS THERE

SHH       STOP RINGING THE BELL AND WAIT FOR MORE COMMANDS

RESTART   RESTART THE PROGRAM AND RECHECK DRIVE STATES

FORMAT    FORMAT A PACK OR PACKS

VERIFY    CHECK FORMATTING ON A PACK OR PACKS

AVERIFY   CHECK FORMATTING OF ALTERNATE TRACKS ON A PACK OR PACKS

AFORMAT   CHECK AND CORRECT IF NECESSARY THE ALTERNATE TRACK
              FORMATTING ON A PACK OR PACKS. ALSO RUNS AVERIFY.

ALIST     LIST INFORMATION ABOUT ALTERNATE TRACKS ON A PACK OR
              PACKS

LIST      LIST INFORMATION FROM THE HOME AND BAT BLOCKS ON A PACK
              OR PACKS

STATUS    LIST THE STATUS (WRITE PROTECTED, ETC.) OF ALL DRIVES
              ON-LINE

INIT      CLEAR THE BAT BLOCKS AND GENERATE A FRESH HOME BLOCK ON A PACK.
              INTENDED FOR PACKS THAT HAVE BEEN FORMATTED BUT DO NOT
              HAVE AN ID.

NEW       CHANGE THE ID ON A PACK

SWITCHES  PRINT A LIST OF SENSE SWITCH MEANINGS FOR THE COPY COMMAND

COPY      DO A SET OF PACK COPIES. TAKES A SET OF SOURCE AND
              DESTINATION PACKS

    *********************************************
    *   THE COMMANDS BELOW ARE NOT TO BE USED   *
    *   WITHOUT SUPERVISOR AUTHORIZATION!!!     *
    *********************************************

ASSIGN    SPECIFY PARTICULAR ALTERNATE TRACK ASSIGNMENTS

DEASSIGN  REMOVE PARTICULAR ALTERNATE TRACK ASSIGNMENTS

ERRMAK    GENERATE ALTERNATE TRACK ASSIGNMENTS WITH ERRORS

ZFORMAT   ZERO ALL ALTERNATE TRACK ASSIGMENTS, FORMAT ENTIRE PACK

OLDC      OLD COPY ROUTINE THAT DOES NOT USE BLOCK MULTIPLEXING

DDT       GO TO DDT
/
SUBTTL	"INIT" - Initialize HOME and BAT pages on one unit

HINIT:	PUSHJ P,ONEUNT	;INIT HOME AND BAT BLOCKS
	HRRZ CMD,MEMFRE
	MOVEI DAT,RVFZ.C(CMD)
	HRLS DAT
	HRLS CMD
	HRROI K,HOMPTR	;DON'T TELL ABOUT CONSISTANCY ERR
	PUSHJ P,REDVER
	 JRST DOINIT	;HOME BLOCKS BAD, INIT
	OASC [ASCIZ /UNIT ALREADY HAS HOME BLOCKS, OVERWRITE? /]
	PUSHJ P,REDLIN
	PUSHJ P,YESNO
	 JRST CMDSET	;HE SAID NO
DOINIT:	HLRS DAT
	MOVE T1,DAT
	ADDI T1,1
	SETZM (DAT)
	BLT T1,777(DAT)	;ZERO OUT BLOCK
	MOVEI K,BATPTR
	MOVE T1,[-BRMAX,,BATREG]
	MOVEM T1,BATFIR(DAT)	;IS IS ALL THAT IS INITIALIZED
	PUSHJ P,WRTVER
	 JRST CMDSET	;ERROR, WRTVER TOLD US
	HLRS DAT
	MOVE T1,DAT
	ADDI T1,1
	SETZM (DAT)
	BLT T1,777(DAT)
	MOVEI K,HOMPTR
	SETOM HOMSRC(DAT)
	SETOM HOMSUN(DAT)
;	MOVE T1,(K)	;GET THE HOME BLOCK ADDRESSES
;	MOVEM T1,HOMHOM(DAT)
HOMGID:	OASC [ASCIZ /ID: /]
	PUSHJ P,REDLIN
	PUSHJ P,SCNID
	JUMPN T1,HOMGID	;NOT A REAL ID, TRY AGAIN
	MOVE T1,ACCUM
	MOVEM T1,HOMHID(DAT)
	PUSHJ P,WRTVER	;WRITE IT OUT
	 JFCL
	JRST CMDSET	;AND FINISH UP
SUBTTL	"COPY" - Copy a set of packs

;THESE ARE MESSAGES FOR HOW PAKCOPY OPERATED DEPENDING ON
;SETTINGS OF SENSE SWITCHES

MDOBAT:	ASCIZ /ALTERNATE TRACKS WILL BE ASSIGNED FOR BLOCKS
INDICATED BAD IN BAT BLOCKS (SENSE SWITCH 1 [40] OFF)
/	;Zero BAT page on destination after bad tracks are reassigned
MNOBAT:	ASCIZ /COPY WILL ABORT IF ANY BAD REGIONS ARE
INDICATED IN THE BAT BLOCKS (SENSE SWITCH 1 [40] ON)
/	;If destination BAT page is nonzero
MNOERR:	ASCIZ /COPY WILL ABORT ON READ ERRORS FROM SOURCE PACK
FOR BLOCKS NOT MARKED BAD (SENSE SWITCH 2 [20] OFF)
/	;Blocks already know to be bad are ignored
MDOERR:	ASCIZ /READ ERRORS FROM SOURCE PACK WILL BE REPORTED BUT
COPY WILL CONTINUE (SENSE SWITCH 2 [20] ON)
/	;Files will lose data - the only record is the hardcopy
MDOALT:	ASCIZ /ALTERNATE TRACKS WILL BE ASSIGNED FOR BLOCKS
WITH READ OR WRITE ERRORS ON DESTINATION PACK (SENSE SWITCH 3 [10] OFF)
/	;For errors found during the copy
MNOALT:	ASCIZ /COPY WILL ABORT ON READ OR WRITE ERRORS ON
DESTINATION PACK (SENSE SWITCH 3 [10] ON)
/

PAKCOP:	TRZ F,F.NBAT!F.NERR!F.NALT
	TLNN F,KL10
	JRST PAKCKI

PAKCKL:	MOVEI T1,.DTRSW		;GET SWITCH SETTINGS
	MOVEM T1,DTECMD
	SETZM DTEFLG
	CONO DTE,TO11DB
	SKIPN DTEFLG
	JRST .-1
	MOVE T1,DTEF11
	TRNE T1,40
	TRO F,F.NBAT
	TRNE T1,20
	TRO F,F.NERR
	TRNE T1,10
	TRO F,F.NALT
	JRST PAKCKX

PAKCKI:	CONI APR,T1		;GET SENSE SWITCH SETTINGS
	TLNE T1,(1B12)
	TRO F,F.NBAT
	TLNE T1,(1B13)
	TRO F,F.NERR
	TLNE T1,(1B14)
	TRO F,F.NALT
PAKCKX:	TRNE F,F.NBAT
	OASC MNOBAT
	TRNE F,F.NERR
	OASC MDOERR
	TRNE F,F.NALT
	OASC MNOALT	;NOW HAVE REPORTED ON STATE
	OASC [ASCIZ /
SOURCE DRIVES: /]
	PUSHJ P,REDDV1	;READ A LIST OF SOURCE DRIVES
	SETZM SPCLNK	;HERE IS A LIST POINTER TO THE WAITERS
CPYDRV:	PUSHJ P,@DRVDSP	;GET A SOURCE DRIVE NUMBER
	 JRST CPYLP0	;WE ARE ALL SET UP, GET STARTED
	MOVE T1,UNISTS(U)
	TLNE T1,NOFMT
	JRST SRCNFT	;SOURCE PACK NOT FORMATTED
	TLNN T1,NOWRT
	JRST SRCWRT	;SOURCE PACK IS WRITABLE
	MOVS T1,U
	PUSH P,T1
	OASC [ASCIZ /COPY FROM #U TO: /]
	PUSHJ P,ONEUN1	;GET THE DESTINATION DRIVE
	HRRM U,(P)
	POP P,U
	MOVE T1,UNISTS(U)
	TLNE T1,NOFMT
	JRST DSTNFT	;DESTINATION DRIVE IS NOT FORMATTED
	TLNE T1,NOWRT
	JRST DSTNWT	;DESTINATION DRIVE IS WRITE PROTECTED
	TLOE T1,DRVUSD
	JRST DSTUSD	;DESTINATION DRIVE IN USE BY A COPY
	MOVEM T1,UNISTS(U)	;MARK USED
	MOVS T2,U
	XOR T1,UNISTS(T2)
	TLNE T1,SNGDNS
	JRST WRGDNS	;DRIVES NOT OF THE SAME DENSITY
	HRRZ DAT,MEMFRE	;GET A PLACE TO PUT THINGS
	MOVEI CMD,3000+RVFZ.D(DAT)	;ENOUGH ROOM FOR 2 HOME AND 2 BAT BLOCKS
	HRLS DAT
	HRLS CMD
	MOVSS U		;GET INFO FROM SOURCE DRIVE
	MOVEI K,HOMPTR
	PUSHJ P,REDVER
	 JRST CPYABT	;ABORT THE COPY IF CANNOT READ HOME PAGES
	ADD DAT,[1000,,0]
	MOVEI K,BATPTR
	PUSHJ P,REDVER
	 JRST CPYABT	;BAD BAT BLOCKS, ALSO ABORT
	MOVSS U		;GET INFO FROM DESTINATION DRIVE
	MOVEI K,HOMPTR
	ADD DAT,[1000,,0]
	PUSHJ P,REDVER
	 JRST CPYABS	;ABORT BUT U IS SWAPPED
	MOVEI K,BATPTR
	ADD DAT,[1000,,0]
	PUSHJ P,REDVER
	 JRST CPYABS
	HLRZS DAT
	SUBI DAT,3000	;NOW HAVE DAT POINTED BACK TO START
	TRZ F,F.BCOP	;COPY NOT BAD YET
	MOVS T1,HOMCOP(DAT)	;INTERCHANGE HALVES SO DATE IN TOP
	MOVS T4,HOMCOP+2000(DAT)	;COMPARE DATES
	CAML T1,T4
	JRST COPOK1	;OK IN THIS RESPECT
	OASC [ASCIZ /DESTINATION COPY DATE LATER THAN SOURCE COPY DATE
/]
	TRO F,F.BCOP
COPOK1:	MOVE T4,HOMHID(DAT)
	XOR T4,HOMHID+2000(DAT)
	TLNN T4,777700
	JRST COPOK2
	OASC [ASCIZ /SOURCE AND DESTINATION SYSTEM NUMBERS DIFFER
/]
	TRO F,F.BCOP
COPOK2:	TRNN T4,7777
	JRST COPOK3
	OASC [ASCIZ /SOURCE AND DESTINATION UNIT NUMBERS DIFFER
/]
	TRO F,F.BCOP
COPOK3:	TDNE T4,[77,,770000]
	JRST COPOK4
	OASC [ASCIZ /SOURCE AND DESTINATION SET NUMBERS ARE THE SAME
/]
	JRST CPYABS	;WE DEFINATELY ABORT HERE
COPOK4:	TRNE F,F.BCOP	;EVERYTHING OK?
	JRST CPYABS	;NO, ABORT
	OASC [ASCIZ /
COPY FROM /]
	OSIX HOMHID(DAT)
	OASC [ASCIZ / (/]
	MOVE T1,HOMCOP(DAT)	;PRINT COPY DATE ALSO
	PUSHJ P,PRDATZ
	OASC [ASCIZ /) TO /]
	OSIX HOMHID+2000(DAT)
	OASC [ASCIZ / (/]
	MOVE T1,HOMCOP+2000(DAT)	;PRINT COPY DATE ALSO
	PUSHJ P,PRDATZ
	OASC [ASCIZ /)
OK? /]
	PUSHJ P,REDLIN
	PUSHJ P,YESNO
	 JRST CPYABS	;ABORT THE COPY
;SORT BAT ENTRIES IN INCREASING PAGE NUMBER

	MOVEI T4,3000(DAT)	;POINT TO THE BAT BLOCK
	ADD T4,BATFIR(T4)
BATSR1:	SKIPN (T4)	;SORT THE BLOCK. ANY DATA LEFT?
	 JRST BATSRD	;NO, DONE
	MOVE T3,T4	;GET POINTER FOR THIS PASS
	MOVE K,T4	;REMEMBER POINTER TO SMALLEST BLOCK
	MOVE T1,BATELB(T4)	;AND THE BLOCK NUMBER
BATSR3:	AOBJP T3,BATSR2	;OUT OF POINTER, END OF PASS
	AOBJP T3,BATSR2
	SKIPN (T3)
	 JRST BATSR2	;END OF BLOCK
	MOVE T2,BATELB(T3)
	CAML T2,T1	;IS THIS ONE SMALLER?
	 JRST BATSR3	;NO
	MOVE T1,T2	;YES, SAVE IT
	MOVE K,T3	;AND THE POINTER
	JRST BATSR3	;AND CONTINUE
BATSR2:	CAMN K,T4	;IS THE SMALLEST ALREADY FIRST?
	 JRST BATSR4	;YES, JUST START ANOTHER PASS
	DMOVE T1,(K)
	EXCH T1,(T4)	;EXCHANGE SMALLEST AND FIRST
	EXCH T2,1(T4)
	DMOVEM T1,(K)
BATSR4:	AOBJP T4,BATSRD	;IF WE RUN OUT OF POINTER, WE ARE DONE
	AOBJN T4,BATSR1
			;FALL INTO BATSRD
;DESTINATION BAT PAGE NOW SORTED
BATSRD:	MOVEI T4,3000(DAT)
	ADD T4,BATFIR(T4)	;SET UP POINTER AGAIN
	MOVEI CMD,4000(DAT)
	HRLS CMD
	MOVEI DAT,AFMZ.C+FT1Z.C(CMD)	;FOR ROOM TO ASSIGN ALT
	HRLS DAT	;A PLACE WE CAN READ FROM
	MOVNI T1,1	;DO NOT WORRY ABOUT SMALLER THAN THIS
	PUSH P,T1	;SAVE SMALLEST TO WORRY ABOUT-1 AND
	PUSH P,T4	;POINTER
BATCK1:	MOVE T4,(P)
BATCK0:	SKIPN (T4)	;ARE WE OUT OF DATA
	 JRST BATCKD	;YES
IFN <RECPAG-1>,<MOVEI T1,RECPAG
	HRRM T1,BATNBB(T4)	;STORE BLOCK/PAGE COUNT IN RH. OF NBB
	IMULM T1,BATELB(T4)>	;CONVERT PAGE # TO BLOCK #
BATCK8:	MOVE T1,BATELB(T4)	;BLOCK #
	CAMG T1,-1(P)
	 JRST BATCK2	;DO NOT LOOK AT THIS BLOCK
	PUSHJ P,TRANS	;TRANSLATE INTO CYL, HEAD, RECORD
	MOVSI T4,-DATLEN	;GET SET TO TEST IT
BATCK3:	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSKF	;SEEK
	PUSHJ P,GENSID	;SEARCH ID=
	PUSHJ P,GENWRT	;WRITE
	MOVSI T1,(BYTE (8) ENDCMD)
	MOVEM T1,(CMD)
	HRL T1,DAT
	HRRI T1,1(DAT)	;SET DATA TO WRITE
	MOVE T2,DATTAB(T4)
	MOVEM T2,(DAT)
	BLT T1,RECSIZ-1(DAT)
	MOVNI T3,1	;NOW DO THE READ
BATCE1:	HLRZ T1,CMD	;THIS IS THE RETRY POINT
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	 JRST BATGE1	;GOT AN ERROR, EXAMINE IT
	HLRS DAT
	HLRS CMD	;WROTE WITHOUT ERROR
	PUSHJ P,GENSKF
	PUSHJ P,GENSID
	PUSHJ P,GENRED	;NOW READ IT BACK
	MOVSI T1,(BYTE (8) ENDCMD)
	MOVEM T1,(CMD)
	MOVNI T3,1
BATCE2:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	 JRST BATGE2	;NO READ ERROR THIS TIME
	MOVE T2,DATTAB(T4)	;NOW CHECK DATA
	HRRZ T1,DAT
	HRLI T1,-RECSIZ
	CAME T2,(T1)
	 JRST BATAL1	;DATA IS WRONG BUT NOT ERR, SET ALT
	AOBJN T1,.-2
	AOBJN T4,BATCK3		;ALL DATA CORRECT, NEXT PATTERN
BATCK2:	MOVE T4,(P)	;TRY ANOTHER BLOCK
	AOS BATELB(T4)
IFN <RECPAG-1>,<;IF IN BLOCKS
	HRRZ T1,BATNBB(T4)	;# OF BLOCKS LEFT TO DO
	SOJLE T1,.+3
	HRRM T1,BATNBB(T4)
	JRST BATCK8		;DO NEXT BLOCK IN PAGE
	MOVEI T1,RECPAG		;RESET FOR NEXT PAGE (IF BAYNBB NONZERO)
	HRRM T1,BATNBB(T4)>
	LDB T1,[POINT BASNBB,BATNBB(T4),BANNBB]	;NUMBER-1
	SOJL T1,BATCK4	;DEC, IF NEG, FINISHED THIS PTR
	DPB T1,[POINT BASNBB,BATNBB(T4),BANNBB]	;RESTORE IT
	JRST BATCK8	;AND TRY NEXT PAGE IN REGION
BATCK4:	AOBJP T4,BATCKD
	AOBJP T4,BATCKD	;POSSIBLY OUT OF DATA
	MOVEM T4,(P)	;NO, RESTORE SAVED COPY
	JRST BATCK0	;AND GO

BATCKD:	POP P,T1
	POP P,T1	;CLEAR STACK
	HLRS CMD
	MOVEI DAT,-4000(CMD)	;RESET DAT
	MOVE T1,HOMHID+2000(DAT)	;DEST ID
	MOVEM T1,HOMHID(DAT)	;TO COPY OF SOURCE HOME BLOCK
	MOVEI T1,2000(DAT)	;SAVE HOME AND BAT BLOCK COPIES
	MOVEM T1,MEMFRE
	MOVE T4,SPCLNK		;REMEMBER FOR WHEN WE RESTART
	HRRZM U,SPCLNK
	PUSHJ P,QUEUNT
	 JRST PAKDO		;HERE IS WHERE WE START
	SOS DEVWAT	;RESET WHAT QUE DID
	SETZM UNIIOW(U)	;FOR NOT
	JRST CPYDRV	;AND GET NEXT DRIVE

DATTAB:	0		;DATA PATTERNS FOR TESTING FOR BAD BLOCKS
	-1
	525252525252
	252525252525
DATLEN==.-DATTAB
;ERROR ON TESTING A BLOCK MARKED BAD

BATGE1:	PUSHJ P,COMERR	;IN CASE RECOVERABLE
	 JRST BATCE1	;YES
	JRST BATALT	;NEED ALTERNATE BLOCK

BATGE2:	PUSHJ P,COMERR
	 JRST BATCE2
BATALT:	MOVE T2,UNIERF(U);READ ERROR SETS UNIT CHECK
	TLNN T2,UCHK
	 JRST BATALB	;PROBABLY HARDWARE, ABORT
	MOVSI T2,SDATCH!SNOREC	;DATA CHECK OR NO RECORD FOUND?
	TDNN T2,UNISNS(U)
	 JRST BATALB	;NO, HARDWARE, ABORT

;FOUND A BAD SPOT ON THE DESTINATION, RIGHT WHERE BAT PAGE SAID IT WAS.

BATAL1:	TRNE F,F.NBAT
	 JRST BATABT	;HE SAID NOT TO ASSIGN ALTERNATES, ABORT
	PUSHJ P,GETALT
	  JRST CPYABT	;CAN NOT ASSIGN ALTERNATE, ABORT
	MOVEI REC,RECTRK	;NUMBER IN THIS TRACK
	PUSHJ P,BAKTRN	;DO A BACK TRANSLATION
	MOVEM T1,-1(P)	;TO TOP REC OF TRACK, DO NOT REASSIGN TRACK
	JRST BATCK2	;CHECK NEXT BLOCK

BATALB:	PUSH P,T1
	OASC [ASCIZ /
PROBABLE HARDWARE ERROR ON DESTINATION PACK
/]
BATAB1:	POP P,T1
	PUSHJ P,COMERP
	JRST CPYABS

BATABT:	OASC [ASCIZ /
BAD BLOCK ON DESTINATION PACK AT CYL #C HEAD #H REC #R
/]
	JRST CPYABS

;TRANSLATE CYL,HEAD, REC TO LOGICAL BLOCK

BAKTRN:	HRRZ T1,HEAD
	IMULI T1,RECTRK
	ADDI T1,-1(REC)
	CAIL T1,RECCYL
	MOVEI T1,RECCYL-1	;IN CASE IT GOES ACROSS CYL
	HRRZ T2,CYL
	IMULI T2,RECCYL
	ADD T1,T2
	POPJ P,
;DESTINATION BAT PAGE TAKEN CARE OF, NOW REALLY START COPY

CPYLP0:	SKIPN U,SPCLNK	;IS THERE SOMEONE WAITING?
	JRST CMDSET	;NO, FINISHED
	AOS UNIIOW(U)	;SET HIM TO START
	AOS DEVWAT	;1 MORE WAITER
	HLRZM U,UNISAC+CMD(U)	;STORE SPACE
	PUSHJ P,ALLWAT
	JRST CPYLP0	;MAKE SURE ALL GET FINISHED

;For 3330, read heads 0-4, 5-9, 10-14, 15-18 (only 4 tracks on last one)
 DOTRK==5				;NUMBER OF TRACKS TO DO AT ONE TIME
 NUMCOP==<HEADS+DOTRK-1>/DOTRK		;NUMBER OF READS PER CYL (4 for 3330)
 REMTRK==HEADS-<DOTRK*<NUMCOP-1>>	;NUMBER OF TRACK IN 'ODD' READ

CDAT.Z==DOTRK*RECTRK*RECSIZ	;DATA AREA NEEDED FOR A READ (DATA FROM DISK)
CPYZ.D==DOTRK*SEKZ.D*RECTRK+SECZ.D	;DATA SPACE FOR COMMANDS
CPYZ.C==DOTRK*<SEKZ.C+RECTRK*<SIDZ.C+REDZ.C>>+SECZ.C+1	;COMMAND SPACE

PAKDO:	JUMPN CMD,PAKDO1	;DO THIS IF WE HAVE SPACE
	MOVEI T1,CDAT.Z*2+CPYZ.D+CPYZ.C	;SPACE NEEDED
	ADD T1,MEMFRE
	CAML T1,MEMSIZ
	JRST WAIT	;NOT ENOUGH (WILL GET HERE AGAIN)
	HRRZ CMD,MEMFRE	;GOT IT, SET UP
	MOVEM T1,MEMFRE
PAKDO1:	HRRZM T4,SPCLNK	;NEXT ONE IN LINE
	JUMPE T4,PAKDO2	;IS THERE SOMEONE?
	AOS UNIIOW(T4)
	AOS DEVWAT	;MAKE SURE HE GETS STARTED
	SETZM UNISAC+CMD(T4)
PAKDO2:	HRLS CMD
	PUSH P,DAT	;THIS POINTS TO THE HOME AND BAT BLOCKS
	MOVEI DAT,CPYZ.C(CMD)
	HRLS DAT
	MOVSI CYL,-CYLS/2	;3330-1 (100 megabytes = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVSI CYL,-CYLS
	MOVSS U		;FROM THE SOURCE UNIT
PAKCYL:	MOVSI T1,-NUMCOP	;HERE FOR EACH CYLINDER
PAKRED:	PUSH P,T1	;SAVE THAT ALSO (HEAD NUMBER IN RH)
	PUSHJ P,SETCOP	;SET UP FOR A COPY
	MOVEI T3,GENRED	;WANT TO READ
	PUSHJ P,TRNSET	;SET UP THE TRANSFER
	MOVNI T3,1
PAKRT1:	HLRZ T1,CMD	;HERE TO RETRY READ FROM SOURCE
	PUSHJ P,STRTU	;GO
	SKIPE T1,UNIERF(U)
	 JRST PAKER1	;ERROR ON READ FROM SOURCE
;NOW NEED TO DO SOMETHING SPECIAL FOR HOM AND BAT IF HERE

	PUSHJ P,SETCOP	;SET TRANSFER PARAMETERS (CMD,DAT,HEAD,T4)
	MOVSI T3,-NUMSPR	;THE NUMBER OF SPECIAL RECORDS
	HLRO T1,HEAD
	SETCA T1,	;COUNT MINUS ONE
	ADDI T1,(HEAD)	;THIS IS THE MAX THE HEAD GET THIS TIME
	IMULI T1,RECTRK
	ADDI T1,RECTRK-1	;MAX RECORD NUMBER IN CYL
	CAIL T1,RECCYL	;DO NOT LET IT GET TOO BIG
	MOVEI T1,RECCYL-1
	PUSH P,T1
	HRRZ T1,HEAD
	IMULI T1,RECTRK
	PUSH P,T1	;FIRST RECORD ON CYL
	HRRZ T1,CYL
	IMULI T1,RECCYL
	ADDM T1,(P)
	ADDM T1,-1(P)	;NOW HAVE RECS IN THIS TRANS
SPRCHK:	HRRZ T1,SPCRTB(T3)	;GET A RECORD NUMBER
	CAMG T1,-1(P)	;IF SMALLER THAN BIGEST
	CAMGE T1,(P)	;AND BIGGER THAN SMALLEST (OR EQUAL)
	JRST NXTSPR	;NO, TRY NEXT
	SUB T1,(P)	;FIND OFFSET
	IMULI T1,RECSIZ
	ADD T1,T4	;HERE IS THE RECORD
	HLRZ T2,SPCRTB(T3)
	PUSHJ P,(T2)	;DO SPECIAL ROUTINE
NXTSPR:	AOBJN T3,SPRCHK
	POP P,T1	;CLEAR STACK
	POP P,T1
	MOVEI T3,GENWRT
	MOVSS U
	PUSHJ P,TRNSET
	MOVNI T3,1	;NOW WRITE IT
PAKRT2:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	 JRST PAKER2	;ERROR WRITING
	PUSHJ P,SETCOP	;NOW READ BACK
	MOVEI T3,GENRED
	ADDI T4,CDAT.Z	;TO DIFFERENT PLACE
	PUSHJ P,TRNSET
	MOVNI T3,1
PAKRT3:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	 JRST PAKER3	;ERROR REREADING
	PUSHJ P,SETCOP	;NOW NEED TO COMPARE DATA
	HLRO T1,HEAD
	MOVNS T1
	ADDI T1,(HEAD)
	IMULI T1,RECTRK
	CAILE T1,RECCYL
	 MOVEI T1,RECCYL
	HRRZ T2,HEAD
	IMULI T2,RECTRK
	SUB T1,T2	;NOW HAVE BLOCKS TRANSFERED
	IMULI T1,RECSIZ
	MOVNS T1	;NUMBER OF WORDS
	HRL T4,T1	;NOW AN AOBJN POINTER
PAKDCK:	MOVE T1,(T4)
	CAME T1,CDAT.Z(T4)
	 JRST PAKAB1	;BAD ABBORT
	AOBJN T4,PAKDCK
	MOVSS U	;GET SOURCE IN RH AGAIN
	POP P,T1
	TRNE T1,-1	;IS IT FIRST COPY ON THIS CYL
	ADDI T1,DOTRK-REMTRK	;NEED TO ADD DOTRK
	ADDI T1,REMTRK-1	;ELSE REMTRK (-1 FOR AOBJN)
	AOBJN T1,PAKRED		;DO REST OF CYL
	AOBJN CYL,PAKCYL	;DO NEXT CYL
;HERE WHEN PACK HAS BEEN COPIED
	POP P,DAT
	HRLS DAT
	HLRS CMD
	MOVSS U	;DEST IN RH
	MOVE T1,THSDAT
	MOVEM T1,HOMCOP(DAT)
	MOVEI K,HOMPTR
	PUSHJ P,WRTVER		;WRITE OUT THE HOME PAGE
	 JRST PAKAB2	;ABORT AGAIN
	MOVSS U
	OASC [ASCIZ /COPY COMPLETED FROM #U TO/]
	MOVSS U
	OASC [ASCIZ / #U
/]
	JRST FMTENC	;THIS WILL RESTART SPACE WAITERS ETC
;HERE ON ERRORS

PAKER1:PUSHJ P,COMERR	;ERROR FROM SOURCE PACK
	 JRST PAKRT1	;RECOVERABLE, RETRY
	MOVE T2,UNIERF(U)
	TLNN T2,UCHK
;*;	JRST PAKSHW	;TREAT AS HARDWARE ERROR AND ABORT
	jfcl pakshw
	MOVSI T2,SDATCH!SNOREC	;DATA CHECK OR NO RECORD FOUND?
	TDNN T2,UNISNS(U)
;*;	JRST PAKSHW
	jfcl pakshw
	PUSH P,CYL
	PUSHJ P,COMERP	;PRINT THE ERROR MESSAGE (WILL SET CYL, HEAD, REC)
	PUSHJ P,BAKTRN	;BACK TRANSLATE FOR BAT COMPARE
IFN <RECPAG-1>,<ADDI T1,RECPAG-1
	IDIVI T1,RECPAG	;CONVERT TO A PAGE ADDRESS>
	POP P,CYL
	MOVE T4,-1(P)	;POINTER TO THE BAT AND HOM BLOCKS
	ADDI T4,1000	;POINT TO BAT
	ADD T4,BATFIR(T4)
PKR1S:	SKIPN (T4)
	 JRST PAKE1F	;NOT IN A BAT BLOCK
	MOVE T3,BATELB(T4)
	CAMGE T1,T3
	 JRST PKR1N	;NOT IN THIS REGION
	LDB T2,[POINT BASNBB,BATNBB(T4),BANNBB]
	ADD T3,T2
	CAMG T1,T3
	 JRST PKR1B	;IT IS IN THIS REQION
PKR1N:	AOBJP T4,PAKE1F
	AOBJN T4,PKR1S	;CONTINUE SEARCH
PAKE1F:	TRNN F,F.NERR	;SHOULD WE CONTINUE FROM ERROR?
	 JRST PAKTM1	;NO, TERMINATE
	OASC [ASCIZ /CONTINUING
/]
PAKCON:	MOVE T1,UNICNT(U)	;NOW CONTINUE
        ADDI T1,2               ;POINT TO DATA RECORD POINTER
        HRR T2,(T1)             ;POINT TO DATA RECORD
        SETZM (T2)              ;ZERO 1ST WORD OF BAD RECORD
        HRLS T2                 ;THEN ZERO ENTIRE RECORD
        MOVEI T3,RECSIZ-1(T2)
        AOS T2
        BLT T2,(T3)
        AOS T1                  ;STEP PAST DATA WORD
	HRLI T1,TIC
	HLRZ T2,CMD
	MOVEM T1,(T2)
	MOVNI T3,1
	JRST PAKRT1

PKR1B:	OASC [ASCIZ /ERROR IS IN A BLOCK MARKED BAD. CONTINUING
/]
	JRST PAKCON

PAKSHW:	PUSH P,T1
	OASC [ASCIZ /
PROBABLE HARDWARE ERROR ON SOUCE PACK
/]
	POP P,T1
	PUSHJ P,COMERP
PAKTM1:	OASC [ASCIZ /COPY FROM #U/]
	MOVSS U
	OASC [ASCIZ / TO #U ABORTED
/]
	JRST FMTENC	;START WAITERS
;THIS IS WRITE ERROR ON DESTINATION PACK

PAKER2:	PUSHJ P,COMERR
	 JRST PAKRT2	;RETRY
	PUSH P,T1
	OASC [ASCIZ /WRITE ERROR ON DESTINATION PACK
/]
DESECM:	POP P,T1
	PUSH P,CYL
	PUSHJ P,COMERP
	POP P,CYL
	MOVE T1,UNIERF(U)
	TLNN T1,UCHK
	 JRST DSTHWD	;HARDWARE ERROR
	MOVSI T1,SDATCH!SNOREC	;DATA CHECK OR NO RECORD FOUND?
	TDNN T1,UNISNS(U)
	 JRST DSTHWD
	TRNE F.NALT
	 JRST DESABT	;ABORT, NOT ALLOWED TO GET ALT
	PUSHJ P,GETALT	;GET ALTERNATE TRACK
	  JRST DESABT	;CAN NOT GET ONE
	MOVSS U
	POP P,T1
	JRST PAKRED	;RESTART

DSTHWD:	OASC [ASCIZ /PROBABLE HARDWARE ERROR
/]
DESABT:	MOVSS U
	JRST PAKTM1

PAKER3:	PUSHJ P,COMERR
	 JRST PAKRT3
	PUSH P,T1
	OASC [ASCIZ /READ ERROR ON DESTINATION PACK
/]
	JRST DESECM	;TO COMMON CODE
;HERE WHEN DATA DOES NOT COMPARE BUT NO ERRORS

PAKAB1:	OASC [ASCIZ /DATA DOES NOT COMPARE BUT NO HARDWARE
DETECTED ERRORS
/]
	JRST DESECM	;ABORT

;HERE IF WE CAN NOT WRITE THE HOME BLOCK

PAKAB2:	OASC [ASCIZ /CAN NOT WRITE HOME BLOCKS ON DESTINATION
PACK AFTER ALL BLOCKS COPIED.
DESTINATION PACK MAY CONTAIN INCORRECT COPY DATE AND OTHER
WRONG DATA
/]
	JRST DESECM
BATSPC:	SETZM BATREG(T1)	;CLEAR BAT BLOCKS
	HRLI T2,BATREG(T1)
	HRRI T2,BATREG+1(T1)
	BLT T2,775(T1)	;DO NOT CLEAR COD AND SELF
	SETZM BATSEC(T1)	;THE NUMBER OF BAD SECTORS
	SETZM BATCNT(T1)	;AND BAD REGIONS
	POPJ P,

HOMSPC:	MOVE T2,-4(P)	;GET POINTER TO HOME BLOCK
	MOVE T2,HOMHID(T2)	;GET ID
	MOVEM T2,HOMHID(T1)
	SETOM HOMSRC(T1)	;NOT IN SYS SEARCH LIST
	SETZM HOMSNM(T1)	;OR IN STR
	SETZM HOMLOG(T1)
	SETOM HOMSUN(T1)	;OR IN SWAP LIST
	SETZM HOMCOP(T1)	;VERY EARLY DATE
	POPJ P,

DEFINE MAKSPC(ADRS,BLK)
<IFG <<BLK*1000+777>-<REMTRK*RECTRK*RECSIZ>>,<
	PRINTX ?RECORD OVERFLOW FOR BLK - REDO SPECIAL PROCESSING>
	XWD ADRS,BLK*RECPAG>

SPCRTB:	MAKSPC(HOMSPC,LBNHOM)
	MAKSPC(HOMSPC,LB2HOM)
	MAKSPC(BATSPC,<<LBNHOM+1>>)
	MAKSPC(BATSPC,<<LB2HOM+1>>)
NUMSPR==.-SPCRTB

SETCOP:	HLRS CMD
	HLRS DAT
	MOVEI T4,CPYZ.D(DAT)	;DATA AREA
	HRRZ HEAD,-1(P)
	SKIPE HEAD
	 TLOA HEAD,-DOTRK
	HRLI HEAD,-REMTRK	;SET ONE OR THE OTHER
	POPJ P,

TRNSET:	MOVEI REC,1
	PUSHJ P,GENSKF
	MOVE T1,-1(P)
	SUB T1,HEAD
	TRNN T1,-1	;SEE IF FIRST TIME THROUGH
	PUSHJ P,GENSEC	;GENERATE A SET SECTOR THE FIRST TIME
	HRLI REC,-RECTRK
	HRRZ T1,HEAD
	CAIN T1,HEADS-1	;LAST HEAD HAS 16 RECORDS IF FORMATTING IN BLOCKS
	HRLI REC,-<RECCYL-RECTRK*<HEADS-1>>
	JRST TRNRC1
TRNREC:	PUSHJ P,GENSKF
	SUBI CMD,SEKZ.C	;JUST WANT DATA
TRNRC1:	PUSHJ P,GENSID
	PUSHJ P,(T3)	;EITHER GENRED OR GENWRT
	HRRM T4,-1(CMD)	;PLACE TO TRANSFER
	ADDI T4,RECSIZ
	AOBJN REC,TRNREC
	AOBJN HEAD,TRNSET
	MOVSI T1,(BYTE (8) ENDCMD)
	MOVEM T1,(CMD)
	POPJ P,	;FINISHED

;DO A SET SECTOR

GENSEC:	AOS -1(CMD)	;THE SEEK DATA HAS MOVED
	PUSHJ P,GENSC0	;GENERATE THE SET SECTOR COMMAND
	DMOVE T1,-2(DAT)
	DMOVEM T1,-1(DAT)	;REALLY MOVE THE DATE
	MOVE T1,SECTAB-1(REC)	;GET SECTOR ARG
	MOVEM T1,-2(DAT)
	AOJA DAT,CPOPJ		;AND DONE

SECZ.D==1

;3330 = 18 blocks @ 2,9,15,22,29,36,42,49,56,63,69,76,83,90,97,103,110,117
;3330 =  5 pages  @ 2,       25,       48,        71,      95
;3350 =  7 pages  @ 1,   17,    34,    50,     66,    83,    99
;3350 = 25 blocks @
;1,6,11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96,101,106,111,116,121

%%Z==0
SECTAB:	REPEAT RECTRK,< RADIX 10	;;237 and 410 are magic numbers
%%Y==128*<237+%%Z*<GAP+BYTSIZ>>/<BYTES+410>
	BYTE (8) %%Y
%%Z==%%Z+1
; PRINTD (Record,\%%Z,is at RPS sector,\%%Y)
	RADIX 8>
;COPY ERROR MESSAGES

SRCNFT:	OASC [ASCIZ /SOURCE DRIVE NOT FORMATTED
/]
	JRST CPYDRV

SRCWRT:	OASC [ASCIZ /SOURCE DRIVE NOT WRITE PROTECTED
/]
	JRST CPYDRV

DSTNWT:	OASC [ASCIZ /DESTINATION DRIVE WRITE PROTECTED
/]
	JRST CPYDRV

DSTNFT:	OASC [ASCIZ /DESTINATION DRIVE NOT FORMATTED
/]

DSTUSD:	OASC [ASCIZ /DESTINATION DRIVE ALREADY IN USE
/]
	JRST CPYDRV

WRGDNS:	OASC [ASCIZ /SOURCE AND DESTINATION DRIVE NOT SAME TYPE
/]
	MOVSI T1,DRVUSD
	ANDCAM T1,UNISTS(U)	;RESET IN USE BIT
	JRST CPYDRV

CPYABS:	MOVSS U		;ABORT COPY BUT U IS SWAPPED
CPYABT:	OASC [ASCIZ /COPY FROM #U/]
	MOVSI T1,DRVUSD
	ANDCAM T1,UNISTS(U)
	MOVSS U
	ANDCAM T1,UNISTS(U)
	OASC [ASCIZ / TO #U ABORTED
/]
	JRST CPYDRV
SUBTTL	"OLDC" - Old copy routine (1 pack at a time)

OLDCOP:	JSP T1,DOWAT
	OASC [ASCIZ /
SOURCE: /]
	PUSHJ P,ONEUN1	;GET A DRIVE
	PUSH P,U
	OASC [ASCIZ /
DESTINATION: /]
	PUSHJ P,ONEUN1
	CAMN U,(P)
	JRST SAMEU	;SAME UNIT
	HRLM U,(P)
	POP P,U
	HRRZ CMD,MEMFRE
	MOVEI DAT,COPCML(CMD)	;SAVE SOME SPACE
	HRLS DAT
	HRLS CMD
	MOVSI CYL,-CYLS/2	;3330-1 (100 megabytes = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVSI CYL,-CYLS
COPCYL:	HLRS DAT
	HLRS CMD
	MOVEI T4,COPDTL(DAT)	;LEAVE SPACE FOR COMMAND DATA
	MOVSI HEAD,-HEADS
COPHED:	MOVSI REC,-RECTRK
	HRRI REC,1	;START WITH RECORD 1
COPREC:	PUSHJ P,GENSKF
	TRNE REC,-2
	SUBI CMD,2	;IF NOT RECORD 1, NO SEEK NEEDED
	PUSHJ P,GENSID	;BUT DATA NEEDED FOR SEARCH ID=
	PUSHJ P,GENRED	;A READ
	HRRM T4,-1(CMD)
	ADDI T4,RECSIZ
	AOBJN REC,COPREC
	AOBJN HEAD,COPHED
	MOVNI T3,1
COPRTY:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST COPERR
	HLRS CMD
	HLRS DAT
	MOVEI T4,COPDTL(DAT)	;NOW WRITE INFORMATION OUT
	MOVSS U		;DIFFERENT UNIT
	MOVSI HEAD,-HEADS
COPHD1:	MOVSI REC,-RECTRK
	HRRI REC,1
COPRC1:	PUSHJ P,GENSKF
	TRNE REC,-2
	SUBI CMD,2
	PUSHJ P,GENSID
	PUSHJ P,GENWRT
	HRRM T4,-1(CMD)
	ADDI T4,RECSIZ
	AOBJN REC,COPRC1
	AOBJN HEAD,COPHD1
	MOVNI T3,1
COPRT1:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST COPER1
	HLRS CMD
	HLRS DAT
	MOVEI T4,COPDL1+COPDTL(DAT)	;READ BACK
	MOVSI HEAD,-HEADS
COPHD2:	MOVSI REC,-RECTRK
	HRRI REC,1
COPRC2:	PUSHJ P,GENSKF
	TRNE REC,-2
	SUBI CMD,2
	PUSHJ P,GENSID
	PUSHJ P,GENRED
	HRRM T4,-1(CMD)
	ADDI T4,RECSIZ
	AOBJN REC,COPRC2
	AOBJN HEAD,COPHD2
	MOVNI T3,1
COPRT2:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST COPER2
	HLRZ T4,DAT
	ADDI T4,COPDTL
	HRLI T4,-COPDL1
	MOVE T1,(T4)
	CAME T1,COPDL1(T4)
	JRST COPER3
	AOBJN T4,.-3
	MOVSS U
	AOBJN CYL,COPCYL
	OASC [ASCIZ /
COPY COMPLETED/]
	JRST CMDSET

SAMEU:	OASC [ASCIZ /
SAME UNIT/]
	JRST CMDSET

COPERR:	PUSHJ P,COMERR
	 JRST COPRTY
	PUSHJ P,COMERP
	JRST CMDSET

COPER1:	PUSHJ P,COMERR
	 JRST COPRT1
	PUSHJ P,COMERP
	JRST CMDSET

COPER2:	PUSHJ P,COMERR
	 JRST COPRT2
	PUSHJ P,COMERP
	JRST CMDSET

COPER3:	OASC [ASCIZ /
DATA COMPARE ERROR/]
	JRST CMDSET
SUBTTL	"NEW" - Change unit ID on an existing home page

NEWID:	PUSHJ P,ONEUNT	;GET A DRIVE TO CHANGE ID ON
	HRRZ CMD,MEMFRE
	MOVEI DAT,RVFZ.C(CMD)
	HRLS DAT
	HRLS CMD
	MOVEI K,HOMPTR
	PUSHJ P,REDVER
	 JRST CMDSET	;ERROR READING HOME BLOCKS ABORT
NEWIDG:	OASC [ASCIZ /ID: /]
	PUSHJ P,REDLIN
	PUSHJ P,SCNID
	JUMPN T1,NEWIDG
	HLRS DAT
	MOVE T1,ACCUM
	MOVEM T1,HOMHID(DAT)
	PUSHJ P,WRTVER
	 JRST CMDSET
	JRST CMDSET
SUBTTL	"STATUS" - List status of all on-line units

STSCMD:	HLRZ	U,SYSUNI
STSLP:	SKIPGE	UNISTS(U)
	 JRST	NXTSTS	;UNIT IS OFF-LINE, IGNORE IT
	OASC	[ASCIZ /
#U /]
	LDB	T1,[POINT 3,UNISTS(U),3]
	OASC	@ONLTAB(T1)
NXTSTS:	HLRZ	U,UNISYS(U)
	JUMPN	U,STSLP
	JRST	CMDLP


SUBTTL	"AVERIFY" - Verify that alternate tracks are readable

AVRCMD:	PUSHJ	P,REDDRV
AVRLP:	PUSHJ	P,@DRVDSP
	  JRST	CMDSET
	HRRZ	CMD,MEMFRE
	MOVEI	DAT,AVFZ.C(CMD)
	HRLS	DAT
	HRLS	CMD
	OASC	[ASCIZ /
UNIT #U
/]
	PUSHJ	P,AVERIF
	  JRST	AVRLP
	OASC	[ASCIZ /ALTERNATE TRACKS VERIFIED
/]
	JRST	AVRLP


SUBTTL	"AFORMAT" - Format all unassigned alternate tracks

AFMCMD:	PUSHJ	P,REDDRV
AFMLP:	PUSHJ	P,@DRVDSP
	  JRST	CMDSET
	HRRZ	CMD,MEMFRE
	MOVEI	DAT,AFMZ.C(CMD)
	HRLS	DAT
	HRLS	CMD
	OASC	[ASCIZ /
UNIT #U
/]
	PUSHJ	P,AFORMA	;Format alternate tracks
	 OASC	[ASCIZ /Error detected while formatting alternate tracks
/]
	PUSHJ	P,AVERIF	;Verify alternate tracks
	 JRST	[OASC	[ASCIZ /Alternate track verify failed
/]
		JRST	AFMLP]
	OASC	[ASCIZ /ALTERNATE TRACKS FORMATTED AND VERIFIED
/]
	JRST	AFMLP
;ALTERNATE TRACK VERIFY AND/OR FORMAT

HABITS:	POINT 2,(DAT),7		;Flag byte from Home Addr (HA.ALT!HA.BAD only)

AVERIF:	TDZA	T1,T1		;AVERIFY - verify alternate tracks
AFORMA:	 MOVSI	T1,(1B0)	;AFORMAT - reformat all unassigned alternates
	MOVEM	T1,UNIBAD(U)	;Zero count in RH
	MOVEI	CYL,CYLS/2
	MOVSI	T1,SNGDNS
	 TDNN	T1,UNISTS(U)
	MOVEI	CYL,CYLS
	HRLI	CYL,-ALTS	;7 or 5 ALTERNATE CYLS
AVFCYL:	MOVSI	HEAD,-HEADS
AVFHED:	HLRS	DAT		;Reset addresses
	HLRS	CMD
	PUSHJ	P,GENSEK	;Seek to CYL,HEAD
	PUSHJ	P,GENHR0	;Read flag byte from HA and read R0
	PUSHJ	P,UNIGOC	;Go, but preserve CYL and HEAD
	  JRST	AVFER1		;Cannot read R0, reformat it if requested
	LDB	T1,[POINT 16,1(DAT),15]	;CYL from R0
	LDB	T2,[POINT 16,1(DAT),31]	;REC from R0
	LDB	T3,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	CAIN	T1,(CYL)	;If R0 does not
	CAIE	T2,(HEAD)	; point to itself
	 CAIE	T3,HA.ALT	; and flagged as alternate then continue
	  JRST	AVEROK		;Alternate not assigned
;Here when alternate is in use, R0 points to defective primary track
	PUSH	P,CYL
	PUSH	P,HEAD
	LDB	CYL,[POINT 16,1(DAT),15]
	LDB	HEAD,[POINT 16,1(DAT),31]
	HLRS	DAT
	HLRS	CMD
	PUSHJ	P,GENSEK
	PUSHJ	P,GENHR0	;Read HA and R0 from original bad track
	PUSHJ	P,UNIGO
	  JRST	[POP P,HEAD	;Hardware read error on original bad track
		POP P,CYL
		JRST AVFMT]	;Reformat alternate track (deassign it)
	POP	P,HEAD
	POP	P,CYL		;HEAD and CYL of alternate track
	LDB	T2,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	CAIE	T2,HA.BAD
	 JRST	AVFER2		;Original not marked bad
	LDB	T2,[POINT 16,1(DAT),15]
	LDB	T3,[POINT 16,1(DAT),31]
	CAIN	T2,(CYL)
	CAIE	T3,(HEAD)
	 JRST	AVFER2		;Original does not point to alternate
	JRST	AVFNXT		;Alternate is OK

;Here when alternate track is not in use.  Reformat if AFORMAT

AVEROK:	TRNN	T3,HA.BAD	;Is alternate known to be bad?  (2 or 3)
AVFMT:	SKIPL	UNIBAD(U)	; or doing AVERIFY?
	 JRST	AVFNXT		;Yes, don't reformat alternate
	PUSHJ	P,ASSGOD	;AFORMAT - make sure track is still useable
	  JRST	AVFER4		;Failed, try one more time
AVFNXT:	AOBJN	HEAD,AVFHED
	AOBJN	CYL,AVFCYL
	HRRZ	T1,UNIBAD(U)
	SKIPN	T1		;Error return if any bad alternate tracks
	 AOS	(P)
	POPJ	P,		;FINISHED

;Here when alternate track does not really point to a bad track

AVFER2:	OASC [ASCIZ /INCORRECT ALTERNATE TRACK. CYL,HEAD #C,#H
/]

;Here if hardware read error, cannot read HA or R0 on alternate track

AVFER1:	SKIPL	UNIBAD(U)	;AFORMAT?
	 JRST	AVFER3		;No, message has already been output
	OASC	[ASCIZ /Attempting to reformat this alternate track
/]
	PUSHJ	P,ASSGOD	;Try to reformat the track, skip if OK
AVFER4:	  PUSHJ	P,ASSBAD	;Format error, mark defective alternate
	    JFCL		;ASSGOD succeeded or ASSBAD failed
AVFER3:	AOS	UNIBAD(U)	;Count bad alternates detected
	JRST	AVFNXT		;FORMAT/VERIFY next
SUBTTL	Read/write HA and R0

;GENERATE A READ HOME ADDRESS (1 BYTE) AND A READ R0 (4 BYTES)

GENHR0:	MOVSI T2,(BYTE (8) BYTMOD!IGNLEN,RHOM)
	MOVEM T2,0(CMD)
	MOVSI T2,(BYTE (8) BYTMOD!IGNLEN,RDR0)
	MOVEM T2,2(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,0(CMD),23]
	DPB T2,[POINT 8,2(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE (12) -1)
	MOVEM T2,1(CMD)		;Read flag byte into 0(DAT)
	MOVEI T2,1(DAT)
	HRLI T2,(BYTE (12) -4)
	MOVEM T2,3(CMD)		;Read C C H H into 1(DAT)
	MOVSI T2,(BYTE (8) ENDCMD)
	MOVEM T2,4(CMD)
	POPJ P,

RH0Z.C==5
RH0Z.D==2

;Set File Mask - need to rewrite HA or R0
;GENSEK must be called between SETMSK and GENHW0

SETMSK:	MOVSI	T1,(BYTE (8) 300)	;SET FILE MASK FOR ALL WRITES OK
	MOVEM	T1,(DAT)
	MOVSI	T1,(BYTE (8) BYTMOD,SETFMK)
	MOVEM	T1,(CMD)
	HRRZ	T1,DAT
	HRLI	T1,(BYTE (12) -1)
	MOVEM	T1,1(CMD)
	MOVE	T1,UNINUM(U)
	DPB	T1,[POINT 8,(CMD),23]
	ADDI	CMD,2
	ADDI	DAT,1
	POPJ	P,
;Here to write Home Address (HA) and Record 0 (R0).
;SETMSK and GENSEK already done.  T2 has CYL,,HEAD to write in R0.
;T1 has 0 for good track, has 2 for bad track

GENHW0:
IFN FT3350,<	;Have to do more work with 3350 type disks
	SD3350==6		;6 bytes for "skip defect" info
;DAT+0 will get: C C H H                4 bytes from Read Home Address
;DAT+1 will get: x x x x  x x 0 0       6 skip defect bytes
;DAT+3 is where DAT will be adjusted to for new HA data
	MOVSI	T3,(BYTE (8) BYTMOD,RHOM)
	MOVEM	T3,0(CMD)		;Read existing Home Address
	MOVSI	T3,(BYTE (12) 4000-1)
	MOVEM	T3,1(CMD)		;Skip over the flag byte
	MOVSI	T3,(BYTE (12) -4)
	HRRI	T3,0(DAT)
	MOVEM	T3,2(CMD)		;Read current CC HH to DAT+0
	MOVSI	T3,(BYTE (8) BYTMOD,SENSE)
	MOVEM	T3,3(CMD)		;Read sense bytes
	MOVSI	T3,(BYTE (12) 4000-^D<24-SD3350>)
	MOVEM	T3,4(CMD)		;But skip the first 18 (24-6)
	MOVSI	T3,(BYTE (12) -SD3350)
	HRRI	T3,1(DAT)
	MOVEM	T3,5(CMD)		;Read in 6 skip defect bytes
	MOVSI	T3,(BYTE (8) BYTMOD,SRCHA)
	MOVEM	T3,6(CMD)		;Search for Home Address
	MOVSI	T3,(BYTE (12) -4)
	HRRI	T3,0(DAT)
	MOVEM	T3,7(CMD)		;Using the former CC HH
	MOVSI	T3,TIC
	HRRI	T3,6(CMD)		;Build a TIC back to SRCHA
	MOVEM	T3,10(CMD)		; (the TIC is always skipped over)
	MOVSI	T3,(BYTE (8) BYTMOD,WHOM)
	MOVEM	T3,11(CMD)		;Write Home Address
	MOVSI	T3,(BYTE (12) 4000-SD3350) ;6 bytes chained to next 8 bytes
	HRRI	T3,1(DAT)
	MOVEM	T3,12(CMD)		;Chain the skip defect bytes before rest
	MOVE	T3,UNINUM(U)
	DPB	T3,[POINT 8,0(CMD),23]	;Set unit numbers in RHOM
	DPB	T3,[POINT 8,3(CMD),23]	;                    SENSE
	DPB	T3,[POINT 8,6(CMD),23]	;                    SRCHA
	DPB	T3,[POINT 8,11(CMD),23]	;                    WHOM
	ADDI	CMD,12			;4 commands, 6 data transfers, 1 TIC
	ADDI	DAT,1+<SD3350+3>/4	;4 + 6 bytes of data
>  ;End IFN FT3350
IFE FT3350,<	;Just a simple Write Home Address command
	MOVSI T3,(BYTE (8) BYTMOD,WHOM)
	MOVEM T3,0(CMD)
>  ;End IFE FT3350
;DAT is set to:  F C C H  H 0 0 0       Data for 3330 Write Home Address
;DAT+2 set to:   C C H H  R K D D	Data for Record 0
	DPB	T1,[POINT 8,0(DAT),7]	;Store flag byte
	DPB	CYL,[POINT 16,0(DAT),23];Store 2 bytes of cyl
	MOVE	T1,HEAD
	LSH	T1,-^D8
	DPB	T1,[POINT 8,0(DAT),31]	;Store high half of head
	DPB	HEAD,[POINT 8,1(DAT),7]	;Data is F,C,C,H,H
	MOVSI	T3,(BYTE (12) -5)	;Last 5 bytes
	HRR	T3,DAT
	MOVEM	T3,1(CMD)		;Point to the 5 bytes

;Now write R0 pointing to alternate track

	DPB	T2,[POINT 16,2(DAT),31]	;Store alternate head
	MOVSS	T2
	DPB	T2,[POINT 16,2(DAT),15]	;Store alternate cylinder
	MOVEI	T2,<BYTE (8) 0,0,0,^D8>
	MOVEM	T2,3(DAT)		;Store R,KL,DL,DL
	MOVSI	T1,(BYTE (8) BYTMOD!IGNLEN,WRTR0)
	MOVEM	T1,2(CMD)		;Write Record 0
	MOVSI	T1,(BYTE (12) -^D8)
	HRRI	T1,2(DAT)
	MOVEM	T1,3(CMD)		;Controller will write 8 zeros data
	MOVE	T1,UNINUM(U)
IFE FT3350<DPB	T1,[POINT 8,0(CMD),23]>	;Put unit number in WHOM
	DPB	T1,[POINT 8,2(CMD),23]	;Put unit number in WRTR0
	ADDI	CMD,4
	ADDI	DAT,4
	POPJ	P,

MSKZ.C==2
IFE FT3350,<WH0Z.C==4>
IFN FT3350,<WH0Z.C==4+13>
SUBTTL	"LIST" - List map of bad spots from BAT page

MAPLST:	PUSHJ P,REDDRV
MAPLOP:	PUSHJ P,@DRVDSP	;GET NEXT DRIVE
	 JRST CMDSET	;FINISHED
	HRRZ CMD,MEMFRE
	MOVEI DAT,RVFZ.C(CMD)
	HRLS DAT
	HRLS CMD
	OASC [ASCIZ /
UNIT #U
/]
	MOVEI K,HOMPTR	;GET A POINTER TO THE HOME BLOCKS
	PUSHJ P,REDVER	;READ AND VERIFY HOMVE BLOCKS
	 JRST BADHOM	;BAD HOME BLOCKS
	OASC [ASCIZ /UNIT ID: /]
	OSIX HOMHID(DAT)
	CRLF
	SKIPN HOMSNM(DAT)
	JRST NOSTR	;NOT IN A STRUCTURE
	OASC [ASCIZ /STRUCTURE: /]
	OSIX HOMSNM(DAT)
	OASC [ASCIZ / LOGICAL UNIT: /]
	OSIX HOMLOG(DAT)
	CRLF
NOSTR:	SKIPN HOMCOP(DAT)	;HOW ABOUT COPY DATE?
	JRST	[OASC [ASCIZ /NO COPY DATE
/]
		JRST BADHOM]
	OASC [ASCIZ /LAST COPY DATE: /]
	MOVE T1,HOMCOP(DAT)
	PUSHJ P,PRDAT
	CRLF
BADHOM:	MOVEI K,BATPTR
	PUSHJ P,REDVER
	 JRST MAPLOP	;FINISHED
	OASC [ASCIZ /NUMBER OF BAD REGIONS: /]
	ODEC BATCNT(DAT)
	OASC [ASCIZ /
NUMBER OF BAD SECTORS: /]
	ODEC BATSEC(DAT)
	CRLF
	HRRZ K,DAT
	ADD K,BATFIR(DAT)	;GENERATE POINTER
	MOVEI T4,0
BATLOP:	SKIPN (K)
	JRST DONBAT
	ADDI T4,1
	MOVE T1,BATELB(K)
IFN <RECPAG-1>,<IMULI T1,RECPAG>
	PUSHJ P,TRANS
	OASC [ASCIZ /RECORD,HEAD,CYL #R,#H,#C
   /]
	LDB T1,[POINT BASNBB,BATNBB(K),BANNBB]
	ADDI T1,1
IFN <RECPAG-1>,<IMULI T1,RECPAG>
	ODEC T1
	OASC [ASCIZ / RECORD(S) /]
	HRRZ T1,BATDAT(K)
	JUMPE T1,BATNDT
	PUSHJ P,PRDATO	;DATE ONLY
	CRLF
NXTBAT:	AOBJP K,MAPLOP
	AOBJN K,BATLOP
	JRST MAPLOP

BATNDT:	OASC [ASCIZ /NO DATE
/]
	JRST NXTBAT

DONBAT:	JUMPN T4,MAPLOP
	OASC [ASCIZ /NO BAD SPOTS
/]
	JRST MAPLOP
SUBTTL	"ALIST" - List information about alternate track assignments

ALTLST:	PUSHJ P,REDDRV
ALOOP:	PUSHJ P,@DRVDSP	;GET NEXT DRIVE
	 JRST CMDSET	;FINISHED
	MOVEI REC,0	;WILL ACCUMULATE TOTAL LEFT
	MOVEI CYL,CYLS/2	;3330-1 (100 megabytes = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI CYL,CYLS
	HRLI CYL,-ALTS	;NUMBER OF ALT CYLS, 7 or 5
	HRRZ CMD,MEMFRE
	MOVEI DAT,SEKZ.C+RH0Z.C(CMD)
	OASC [ASCIZ /
UNIT #U
/]
	HRLS DAT
	HRLS CMD
ALTCYL:	MOVSI HEAD,-HEADS
ALTHED:	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGOC
	 JRST DEFALT	;UNRECOVERABLE ERROR READING R0
	LDB T3,HABITS		;Flag byte from HA (HA.ALT!HA.BAD only)
	TRNE T3,HA.BAD		;0 or 1 means ALT is usable
	 JRST DEFALT		;2 or 3 means ALT is defective
	LDB T1,[POINT 16,1(DAT),15]
	LDB T2,[POINT 16,1(DAT),31]
	CAIN T1,(CYL)		;Check if R0 points to self
	CAIE T2,(HEAD)
	 TRNN T3,HA.ALT		;1 means ALT in use if not pointing to self
	  AOJA REC,NOTDEF	;ALT is unassigned or points to self
	OASC [ASCIZ /CYL,HEAD: #C,#H IS ALTERNATE FOR CYL,HEAD: /]
	LDB T1,[POINT 16,1(DAT),15]
	ODEC T1
	OCHI ","
	LDB T1,[POINT 16,1(DAT),31]
	ODEC T1
	CRLF
	JRST NOTDEF

DEFALT:	OASC [ASCIZ /CYL,HEAD: #C,#H ALTERNATE TRACK IS DEFECTIVE
/]
NOTDEF:	HLRS CMD
	HLRS DAT
	AOBJN HEAD,ALTHED
	AOBJN CYL,ALTCYL
	OASC [ASCIZ /#R ALTERNATE TRACKS REMAINING
/]
	JRST ALOOP
SUBTTL	"DOIT" - HERE TO HANDLE A COMMAND WHICH REQUIRES VERIFICATION

DOITCM:	SKIPN T1,DOFLG
	 JRST BADCMD	;THERE IS NOTHING WAITING
	SETZM DOFLG
	JRST (T1)	;GO DO IT

DOWAT:	MOVEM T1,DOFLG	;JSP HERE ON CMD REQUIRING VERIFY
	JRST BADCD1	;DO NOT DESTROY DOFLG BUT ACT LIKE ILL CMD


;SCAN A NUMBER, MUST BE A NUMBER OR REQUEST RETYPE

SCNUM:	PUSHJ P,REDLIN
	PUSHJ P,SCAN
	CAIN T1,1
	 POPJ P,	;IT WAS A NUMBER, NOW IN ACCUM
	OASC [ASCIZ /NOT A NUMBER, RETYPE: /]
	JRST SCNUM

;RCYHD - Read cylinder #, put it in LH of CYL (RH gets max), read # into HEAD

RCYHD:	OASC [ASCIZ /CYLINDER: /]	;READ CYLINDER AND HEAD
	MOVEI T1,^D10
	MOVEM T1,RADIX
BADCY1:	PUSHJ P,SCNUM
	MOVEI CYL,CYLS/2+ALTS
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	 MOVEI CYL,CYLS+ALTS
	SKIPL ACCUM
	CAMG CYL,ACCUM
	 JRST BADCYL	;CYLINDER IS INCORRECT
	HRL CYL,ACCUM	;PICK IT UP
	OASC [ASCIZ /HEAD: /]
BADHD1:	PUSHJ P,SCNUM
	SKIPL HEAD,ACCUM
	CAIL HEAD,HEADS
	 JRST BADHED
	MOVEI T1,10
	MOVEM T1,RADIX	;RESET RADIX
	POPJ P,

BADHED:	OASC [ASCIZ /
ILLEGAL HEAD NUMBER, RETYPE /]
	JRST BADHD1

BADCYL:	OASC [ASCIZ /
ILLEGAL CYLINDER NUMBER, RETYPE /]
	JRST BADCY1
SUBTTL	"ZFORMAT" - Zero alternate track assignments, format entire pack

REFACM:	OASC	[ASCIZ /The command "1REFRESH" works only on 940 systems.
Use the command "ZFORMAT" to zero alternate assigments and format the pack.
/]
	JRST	CMDLP

ZFMCMD:	JSP	T1,DOWAT
	OASC	[ASCIZ /
UNIT TO ZERO ALTERNATE TRACKS ON: /]
	PUSHJ	P,ONEUN1	;GET A DRIVE
	MOVEI	CYL,CYLS/2
	MOVSI	T1,SNGDNS
	TDNN	T1,UNISTS(U)
	 MOVEI	CYL,CYLS
	MOVEM	CYL,UNIBAD(U)	;Remember start of alternate cylinders
	ADDI	CYL,ALTS-1	;Start at high end and work down
	MOVE	CMD,MEMFRE
	MOVSI	DAT,AFMZ.C+FT1Z.C(CMD)
	HRLS	CMD		;GET BOTH SET IN LEFT HALF
REFCYL:	MOVSI	HEAD,-HEADS
REFHED:	PUSHJ	P,ASSGOD	;Write new HA and R0, format rest of track
	  JRST	REFAIL
REFCNT:	AOBJN	HEAD,REFHED
	SOJGE	CYL,REFCYL
	OASC	[ASCIZ /UNIT #U, ALTERNATE TRACKING ZEROED
/]
	JRST	CMDSET

;Error in writing HA, R0, or rest of track.  Here would be a good place to
;skip the defect by changing the SD bytes on a 3650.

REFAIL:	CAML	CYL,UNIBAD(U)	;Check if below start of alternate cylinders
	 JRST	REFAL1		;Defective alternate
	PUSHJ	P,GETALT	;Defective primary, go get an alternate
	  JRST	REFAL2		;Complain and continue
	JRST	REFCNT

REFAL1:	PUSHJ	P,ASSBAD	;Mark this alternate track as defective
REFAL2:	  OASC	[ASCIZ /Continuing ZFORMAT
/]
	JRST	REFCNT
SUBTTL	"ASSIGN" - Assign one alternate track
ASSCMD:	JSP T1,DOWAT
	OASC [ASCIZ /
UNIT TO ASSIGN ALTERNATE ON: /]
	PUSHJ P,ONEUN1
	PUSHJ P,RCYHD	;Get CYL(LH) and HEAD numbers
	MOVE CMD,MEMFRE
	HRLS CMD
	MOVEI DAT,AFMZ.C+FT1Z.C(CMD)
	HRLS DAT
	MOVSS CYL	;NOW R.H. IS CYLINDER DESIRED
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	  JRST CMDSET
	HLRZ T1,CYL	;THIS IS SET UP WITH THE MAX
	CAILE T1,ALTS(CYL)
	 JRST ASSLOW	;THIS IS A LOW CYLINDER NOT SPARE
	LDB T1,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	CAIN T1,HA.ALT	;Is this alternate already in use?
	 JRST ASHERR	;Cannot change assigment of in-use alternate
ASSCD1:	PUSHJ P,ASSBAD	;Set HA flag to 3 for defective alternate
	 JFCL		;ERROR
	JRST CMDSET	;FINISHED

ASSLOW:	LDB T1,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	JUMPE T1,ASSLOG	;0 means no alternate assigned, go get one
	CAIE T1,HA.BAD	;2 means alternate already assigned, get a new one
	 JRST ASHERR	;1 and 3 are not legal for primary tracks
ASSLOG:	PUSHJ P,GALT2	;Locate and assign an alternate
	 JFCL
	JRST CMDSET	;FINISHED IN EITHER CASE

ASHERR:	PUSH P,T1
	OASC [ASCIZ /
CYL #C HEAD #H, IS /]
	POP P,T1
	OASC @DEFTBL(T1)
	CRLF
	JRST CMDSET

DEFTBL:	[ASCIZ /GOOD/]
	[ASCIZ /AN ALTERNATE/]
	[ASCIZ /DEFECTIVE/]
	[ASCIZ /A DEFECTIVE ALTERNATE/]
;MARK A TRACK BAD OR MARK IT GOOD AND FORMAT IT

ASSGOD:	TDZA	T1,T1		;Zero means good
ASSBAD:	 MOVEI	T1,HA.BAD+HA.ALT;3 means alternate track is defective
ASSXXX:	PUSH	P,T1		;T1 has flag byte to write in the HA
	HLRS	DAT
	HLRS	CMD
	PUSHJ	P,SETMSK	;SET A FILE MASK
	PUSHJ	P,GENSEK	;GENERATE SEEK
	HRL	T2,CYL
	HRR	T2,HEAD		;SAME CYL AND HEAD
	MOVE	T1,(P)		;Get flag byte
	PUSHJ	P,GENHW0	;WRITE HOME ADDRESS AND R0
	MOVE	T1,(P)
	TRNN	T1,HA.BAD	;If not marking it as bad,
	 PUSHJ	P,TRKFMT	; format this track
	MOVSI	T1,(BYTE (8) ENDCMD)
	MOVEM	T1,(CMD)
	PUSHJ	P,UNIGOC	;START IT UP (preserve HEAD and CYL)
	  JRST	ASSFAI		;Error
	POP	P,T1
	JRST	CPOPJ1		;OK

ASSFAI:	POP	P,T1		;Get flag byte
	LDB	T2,UNYREC	;Record number at time of failure
	JUMPN	T2,CPOPJ	;General failure if not for R0
	TRCE	T1,HA.CNT	;Try setting this bit in the flag byte
	TRCN	T1,HA.DAT	;If HA.CNT was on, clear it and try HA.DAT
	 JRST	ASSXXX		;HA.CNT or HA.DAT or HA.CNT+HA.DAT
	OASC	ASSDIE
	POPJ	P,		;Tried all 4 combinations, give up

ASSDIE:	ASCIZ /
I give up.  If you want to use this pack, you will have to take it to an
IBM system and run SA (Surface Analysis) on it.  Until then, this pack
cannot be used on a PDP-10.
/
;Get an available alternate track
GETALT:	HLRS CMD
	HLRS DAT
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0	;READ HOME INFORMATION ON OLD TRACK
	PUSHJ P,UNIGOC
	  POPJ P,	;ERROR
	LDB T1,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)

;Here from ASSIGN command with HA/R0 already read

GALT2:	CAIE T1,HA.BAD	;HERE AS ALTERNATE ENTRY IF HOME INFO READ
	 JRST GALT1	;NOT ALREADY DEFECTIVE, GET ALTERNATE
	PUSH P,1(DAT)	;SAVE POINTER TO OLD (DEFECTIVE) ALTERNATE TRACK
	PUSHJ P,GALT1	;SET UP NEW ALTERNATE
	 JRST	[POP P,T1
		POPJ P,]	;ERROR SETTING ALTERNATE
	POP P,T2
	PUSH P,HEAD
	PUSH P,CYL
	LDB HEAD,[POINT 16,T2,31]
	LDB CYL,[POINT 16,T2,15]
	PUSHJ P,ASSBAD	;MARK PREVIOUSLY USED ALTERNATE AS BEING DEFECTIVE
	 JFCL		;JUST IGNORE ERROR
	POP P,CYL
	POP P,HEAD
	JRST CPOPJ1

GALT1:	PUSH P,CYL
	PUSH P,HEAD	;SAVE CYL AND HEAD TO ASSIGN ALT FOR
	MOVEI CYL,CYLS/2
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	 MOVEI CYL,CYLS	;SET APPROPRIATE STARTING PLACE
	HRLI CYL,-ALTS	;7 or 5 CYLS TO SEARCH
GALCY:	MOVSI HEAD,-HEADS
GALHED:	HLRS CMD
	HLRS DAT
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGOC	;Read HA and R0
	 JRST GALHD1
	LDB T1,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	JUMPE T1,GALFND	;CAN USE THIS AS ALTERNATE
GALHD1:	AOBJN HEAD,GALHED
	AOBJN CYL,GALCY
	OASC [ASCIZ /NO MORE ALTERNATE TRACKS AVAILABLE
/]
GALFAL:	OASC [ASCIZ /ALTERNATE TRACK NOT ASSIGNED
/]
	POP P,HEAD
	POP P,CYL
	POPJ P,
;Found an alternate track, mark it as being in use
;Previous HEAD and CYL are on the stack

GALFND:	HLRS DAT
	HLRS CMD
	PUSHJ P,SETMSK
	PUSHJ P,GENSEK
	HRR T2,0(P)	;GET HEAD
	HRL T2,-1(P)	;AND CYL
	MOVEI T1,HA.ALT	;1 means this is an alternate
	PUSHJ P,GENHW0
	EXCH CYL,-1(P)
	EXCH HEAD,0(P)
	PUSHJ P,TRKFMT	;GENERATE FORMAT INFORMATION
	MOVSI T1,(BYTE (8) ENDCMD)
	MOVEM T1,(CMD)
	EXCH CYL,-1(P)
	EXCH HEAD,0(P)
	PUSHJ P,UNIGOC
	  JRST GALFAL
	OASC [ASCIZ /CYL,HEAD #C,#H ASSIGNED AS ALTERNATE FOR CYL,HEAD/]
	HRR T2,HEAD
	HRL T2,CYL
	POP P,HEAD
	POP P,CYL
	PUSH P,T2	;SAVE OLD HEAD,CYL
	OASC [ASCIZ / #C,#H
/]
	HLRS DAT
	HLRS CMD
	PUSHJ P,SETMSK
	PUSHJ P,GENSEK
	POP P,T2
	MOVEI T1,HA.BAD	;2 means bad primary track
	PUSHJ P,GENHW0
	MOVSI T1,(BYTE (8) ENDCMD)
	MOVEM T1,(CMD)
	PUSHJ P,UNIGO
	 POPJ P,
	JRST CPOPJ1	;ALL FINISHED
SUBTTL	"DEASSIGN" - Deassign an alternate track

DEACMD:	JSP T1,DOWAT
	OASC [ASCIZ /
UNIT TO DEASSIGN ALTERNATE ON: /]
	PUSHJ P,ONEUN1
	PUSHJ P,RCYHD	;Get CYL and HEAD numbers
	MOVE CMD,MEMFRE
	HRLS CMD
	MOVEI DAT,AFMZ.C+FT1Z.C(CMD)
	HRLS DAT
	MOVSS CYL	;NOW R.H. IS CYLINDER DESIRED
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST CMDSET
	HLRZ T1,CYL	;THIS IS SET UP WITH THE MAX
	CAILE T1,ALTS(CYL)
	 JRST DEALOW	;NOT ONE OF THE ALTERNATE TRACKS
	LDB T1,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	CAIE T1,HA.BAD	;IS IT MARKED BAD?
	 JRST ASHERR	;NO, ERROR
	JRST DEACM1	;JUST DO AN ASSGOD ON IT

DEALOW:	LDB T1,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	CAIE T1,HA.BAD	;IS IT MARKED AS HAVING AN ALTERNATE?
	 JRST ASHERR	;NO
	PUSH P,1(DAT)	;SAVE INFORMATION ON ALTERNATE
	PUSHJ P,ASSGOD	;ASSIGN THIS AS A GOOD TRACK
	 JRST [POP P,T2
	       JRST CMDSET]	;FAILED
	POP P,T2
	PUSH P,CYL
	PUSH P,HEAD	;SAVE FOR CHECK
	LDB CYL,[POINT 16,T2,15]
	LDB HEAD,[POINT 16,T2,31]
	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST CMDSET	;FAILED TO READ HA/R0
	LDB T1,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	CAIE T1,HA.ALT	;1 means alternate in use
	 JRST DEAER1	;ALTERNATE NOT RIGHT
	LDB T1,[POINT 16,1(DAT),31]
	POP P,T2
	CAIE T1,(T2)
	 JRST DEAER2	;DOES NOT AGREE
	LDB T1,[POINT 16,1(DAT),15]
	POP P,T2
	CAIE T1,(T2)
	 JRST DEAER3
DEACM1:	PUSHJ P,ASSGOD
	 JFCL
	JRST CMDSET

DEAER1:	POP P,T2	;DUMP HEAD
	POP P,T2	;DUMP CYL
	JRST ASHERR

DEAER2:	POP P,T2	;DUMP CYL
DEAER3:	OASC [ASCIZ /
CYL #C HEAD #H, IS NOT MARKED AS ALTERNATE FOR CORRECT TRACK
/]
	JRST CMDSET
SUBTTL	"ERRMAK" - Make a bad alternate track (to test COPY routine)

ERRCMD:	JSP T1,DOWAT
	OASC [ASCIZ /
UNIT TO CHANGE ALTERNATE TRACKING ON: /]
	PUSHJ P,ONEUN1
	OASC [ASCIZ /SET /]
	PUSHJ P,RCYHD	;Get CYL and HEAD numbers
	HLRZS CYL	;REAL CYL NUMBER IN LEFT HALF
	MOVE CMD,MEMFRE
	MOVEI DAT,AFMZ.C+FT1Z.C(CMD)
	HRLS CMD
	PUSH P,CYL
	PUSH P,HEAD	;SAVE FOR GENHW0
	PUSHJ P,SETMSK
	PUSHJ P,GENSEK
	OASC [ASCIZ /TO /]
	PUSHJ P,RCYHD	;Get CYL and HEAD numbers
FLGAGN:	OASC [ASCIZ /FLAG BYTE: /]
	PUSHJ P,SCNUM
;*;	SKIPL T1,ACCUM
;*;	CAILE T1,2
;*;	 JRST BADFLG
	MOVE T1,ACCUM	;Get flag byte (0 to 255)
	HRL T2,CYL
	HRR T2,HEAD
	EXCH CYL,-1(P)
	EXCH HEAD,0(P)
	PUSH P,T1	;SAVE FLAG BYTE
	PUSHJ P,GENHW0	;Write HA and R0
	POP P,T1
	POP P,HEAD
	POP P,CYL
	TRNN T1,HA.BAD	;DO NOT FORMAT IF MARKING BAD
	 PUSHJ P,TRKFMT	;IN CASE THIS IS THE ALTERNATE
	MOVSI T1,(BYTE (8) ENDCMD)
	MOVEM T1,(CMD)
	PUSHJ P,UNIGO
	 JFCL
	JRST CMDSET

BADFLG:	OASC [ASCIZ /BAD FLAG BYTE
/]
	JRST FLGAGN
;CONSTANTS

LBNHOM==1	;FIRST HOME BLOCK
LB2HOM==6	;SECOND HOME BLOCK

BLKNAM==0	;BLOCK NAME STORED HERE
BLKCOD==776	;CODE STORED HERE
BLKSLF==777	;OWN ADDRESS STORED HERE

HOMHID==1	;PHYSICAL UNIT ID IN HOME BLOCK
HOMSRC==3	;NUMBER OF STR IN SYS SEARCH LIST (-1 IF NOT IN)
HOMSNM==2	;FILE STRUCTURE NAME (0 IF NOT IN STR)
HOMLOG==5	;LOGICAL UNIT NAME (AS DSKB3)
;HOMHOM==12	;HOME BLOCK ADDRESS (LBNHOM,,LB2HOM)
HOMSUN==12	;NUMBER OF UNIT IN SWAP LIST (-1 IF NOT IN)
HOMCOP==774	;DATE OF LAST PACKCOPY

BATCNT==3	;COUNT OF NUMBER OF BAD REGIONS
BATSEC==2	;NUMBER OF BAD SECTORS
BATFIR==1	;RELATIVE AOBJN POINTER TO DATA AREA
BATNBB==0	;WITHIN 2 WORD GROUP. WORD OF NUMBER BAD(-1)
 BASNBB==^D9	;SIZE OF BYTE FIELD
 BANNBB==^D8	;POSITION
BATELB==1	;R.H. FIRST LOGICAL BLOCK OF BAD REGION
BATDAT==0	;R.H. DATE IN DAYS SINCE JAN 1,1964 GMT
BATREG==4	;FIRST WORD OF BAT BLOCK DATA
BRMAX==BLKCOD-BATREG	;SPACE WE HAVE

HOMPTR:	LBNHOM,,LB2HOM	;FIRST AND SECOND HOME BLOCKS
	SIXBIT /HOM/	;NAME WHICH SHOULD BE IN BLKNAM
	070717	;CODE IN BLKCOD
	SIXBIT /HOME/	;WHAT TO CALL IT ON PRINTOUT

BATPTR:	LBNHOM+1,,LB2HOM+1
	SIXBIT /BAT/
	505050
	SIXBIT /BAT/
REDVER:	MOVEI T4,0	;FLAG, 0 NEITHER READ
RDVNXB:	HLRZ T1,(K)	;PICK UP ADDRESS
	TRNE T4,-1	;R.H. IS -1 IF READING SECOND
	HRRZ T1,(K)
	HLRS CMD
	HLRS DAT
	ADDI DAT,1000	;PUT THE DATA AREA FIRST
IFN <RECPAG-1>,<IMULI T1,RECPAG
	PUSH P,T1>
	PUSHJ P,TRANS	;TRANSLATE ADDRESS
	PUSHJ P,GENSKF	;GENERATE FULL SEEK (WITH RECORD)
	PUSHJ P,GENSID	;AND SEARCH ID=
	MOVSS DAT	;GET BACK THE CORRECT DATA AREA
	PUSHJ P,GENRED		;AND READ INTO PAGE+000
%%Z==1
	REPEAT RECPAG-1,<
	ADDI DAT,RECSIZ
	MOVSS DAT		;Point to SEEK area
	AOS T1,(P)		;Increment BLOCK number
	PUSHJ P,TRANS
	PUSHJ P,GENSKF
	PUSHJ P,GENSID
	MOVSS DAT		;Do PAGE+200, PAGE+400, PAGE+600
	PUSHJ P,GENRED
>
IFN <RECPAG-1>,<
	POP P,T1		;RESET DAT FROM PAGE+600 BACK TO PAGE+000
	SUBI DAT,RECSIZ*<RECPAG-1>
>
	HRLS DAT		;RESET TO START OF PAGE
	MOVSI T1,(BYTE (8) ENDCMD)
	MOVEM T1,(CMD)
	PUSHJ P,UNIGO
	 JRST RDVERR
	MOVE T1,BLKNAM(DAT)
	MOVE T2,BLKCOD(DAT)
	CAMN T1,1(K)	;CHECK WITH EXPECTED
	CAME T2,2(K)
	JRST RDVCON	;CONSISTANCY ERROR
	HLRZ T1,(K)
	TRNE T4,-1
	HRRZ T1,(K)
	MOVE T2,BLKSLF(DAT)
	TLZ T2,777776	;GET RID OF EXTRA BITS
	CAME T1,T2
	JRST RDVCON
	JUMPN T4,CPOPJ1	;IF T4 NON-ZERO HAVE READ BOTH
	HLLOS T4	;SET T4 R.H. TO FORCE SECOND TO READ
	JRST RDVNXB	;AND GO

;T4=0,0 READ FIRST NONE READ
;T4=-1,0 READ FIRST ERROR READING SECOND
;T4=0,-1 READ SECOND NO ERROR ON FIRST
;T4=-1,-1 READ SECOND ERROR READING FIRST

RDVERR:	MOVEI T1,[ASCIZ /HARDWARE READ ERROR
/]
RDVER1:	PUSHJ P,RDVERP	;PRINT
	JUMPL T4,CPOPJ	;FAIL IF L.H. T4 NOT 0 (BOTH BAD)
	SETCA T4,
	JRST RDVNXB

RDVCON:	TLNE K,-1	;THIS IS A FLAG FOR NO ERROR MSG
	POPJ P,
	MOVEI T1,[ASCIZ /CONSISTANCY ERROR
/]
	JRST RDVER1

RDVERP:	PUSH P,T1
	MOVEI T1,[ASCIZ /FIRST /]
	TRNE T4,-1
	MOVEI T1,[ASCIZ /SECOND /]
	OASC (T1)
	OSIX 3(K)	;NAME
	OASC [ASCIZ / BLOCK /]
	POP P,T1
	OASC (T1)
	POPJ P,
SUBTTL	WRTVER - Write and verify HOME/BAT pages

WRTVER:	MOVE	T1,1(K)		;WRITE OUT A PAIR OF BLOCKS (HOME, BAT)
	MOVEM	T1,BLKNAM(DAT)	;SIXBIT/HOM/ OR SIXBIT/BAT/
	MOVE	T1,2(K)
	MOVEM	T1,BLKCOD(DAT)	;UNLIKELY CODE
	HLRZ	T1,(K)		;PAGE NUMBER
	PUSHJ	P,WRTVR1	;WRITE THE FIRST ONE
	  POPJ	P,		;ERROR
	HRRZ	T1,(K)		;AND THE SECOND ONE
WRTVR1:	HLRS	DAT		;RESET RH BACK TO START OF PAGE
	HLRS	CMD		;RESET BACK TO START OF COMMAND LIST
	DPB	T1,[POINT 19,BLKSLF(DAT),35]	;SET SELF
	ADDI	DAT,1000	;DATA AREA FOR GENSKF/GENSID
IFN <RECPAG-1>,<IMULI T1,RECPAG
	PUSH	P,T1>		;SAVE STARTING BLOCK NUMBER
	PUSHJ	P,TRANS		;TRANSLATE ADDRESS
	PUSHJ	P,GENSKF	;GENERATE SEEK
	PUSHJ	P,GENSID	;GENERATE SEARCH ID
	MOVSS	DAT		;POINT TO DATA AGAIN
	PUSHJ	P,GENWRT	;WRITE FIRST BLOCK OF PAGE
%%Z==1
REPEAT RECPAG-1,<
	ADDI	DAT,RECSIZ	;POINT TO START OF NEXT BLOCK
	MOVSS	DAT		;FOR GENSKF/GENSID
	AOS	T1,(P)		;GET NEXT BLOCK NUMBER
	PUSHJ	P,TRANS
	PUSHJ	P,GENSKF
	PUSHJ	P,GENSID
	MOVSS	DAT		;BACK TO PAGE AREA
	PUSHJ	P,GENWRT	;DO PAGE+200, PAGE+400, PAGE+600
>
IFN <RECPAG-1>,<
	POP	P,T1		;RESET DAT FROM PAGE+600 BACK TO PAGE+000
	SUBI	DAT,RECSIZ*<RECPAG-1>
>
	HRLS	DAT		;RESET TO START OF PAGE
	MOVSI	T1,(BYTE (8) ENDCMD)
	MOVEM	T1,(CMD)	;HALT I/O
	PUSHJ	P,UNIGO
	  POPJ	P,
	JRST	CPOPJ1	;NO ERRORS
SUBTTL	GENSKF/GENWRT/GENRED

GENSKF:	PUSHJ P,GENSEK
	DPB REC,[POINT 8,-1(DAT),23]	;PUT IN RECORD
	POPJ P,

GENWRT:	MOVSI T2,(BYTE (8) WRDMOD,WRT33)
	SKIPA
GENRED:	MOVSI T2,(BYTE (8) WRDMOD,RED33)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE (12) -RECSIZ)
	MOVEM T2,1(CMD)
	ADDI CMD,2
	POPJ P,

REDZ.C==2
REDZ.D==RECSIZ

TRANS:	IDIVI T1,RECCYL		;Translate block number to CYL,HEAD,REC
	MOVE CYL,T1
	MOVE T1,T2
	IDIVI T1,RECTRK
	MOVE HEAD,T1
	MOVEI REC,1(T2)		;Records are numbered 1-18, not 0-17
	POPJ P,
SUBTTL	"FORMAT" - Rewrite COUNT-KEY-DATA on pack

FORMAT:	PUSHJ P,REDDRV	;READ A LIST OF DRIVES TO FORMAT
	SETZM SPCLNK	;THIS IS A FLAG THAT SOMEONE WANTS SPACE
FMTLP:	PUSHJ P,@DRVDSP	;GET THE NEXT DRIVE NUMBER
	 JRST FMTLP3	;ALL DRIVES COMPLETED OR BAD OR SOMETHING
	MOVE T1,UNISTS(U)	;GET STATUS OF UNIT
	TLNE T1,NOWRT		;AND SEE IF WRITE PROTECTED
	JRST FMTWPT	;TELL HIM THE DRIVE IS WRITE PROTECTED
	TLNN T1,NOFMT
	JRST FMTAST	;SAYS FORMATED, ASK IF REFORMAT
FMTLP1:	MOVE T1,SPCLNK
	MOVEM T1,UNISAC(U)
	HRRZM U,SPCLNK	;MAKE A LIST FOR STARTING
	JRST FMTLP	;BUT AFTER ALL QUESTIONS

FMTLP3:	HRRZ U,SPCLNK	;GET NEXT UNIT NOT STARTED
	JUMPE U,ALLCMP	;ANG GET GOING IF NONE THERE
	MOVE T1,MEMFRE
	ADDI T1,FMTZ.C+FMTZ.D
	CAML T1,MEMSIZ
	JRST FNOMEM	;NOT ENOUGH MEMORY
	MOVE CMD,MEMFRE
	MOVEM T1,MEMFRE	;UPDATE FREE MEMORY
FMTLP2:	MOVEI DAT,FMTZ.C(CMD)	;SET DATA SIZE
	MOVE T1,UNISAC(U)	;NEXT LINK ON CHAIN
	MOVEM T1,SPCLNK
	PUSHJ P,QUEUNT	;QUE THE UNIT FOR THE TRANSFER
	 JRST FMTDO	;GO TO DO ACTUAL WORK FOR ONE UNIT
	JRST FMTLP3	;CONTINUE SETTING THINGS UP

ALLCMP:	PUSHJ P,ALLWAT	;WAIT FOR ALL UNITS TO COMPLETE
	JRST CMDSET	;FINISHED, NEXT COMMAND

FMTWP:	OASC [ASCIZ /
UNIT #U IS WRITE PROTECTED, NOT FORMATED
/]
	POPJ P,

FNOMEM:	HRRZM U,SPCLNK	;SET LINK
	PUSHJ P,ALLWAT
	HLRZ CMD,SPCLNK		;GET THE FREE LOCATION
	JRST FMTLP2	;AND CONTINUE SETTING UP FORMATTING

FMTWPT:	PUSHJ P,FMTWP
	JRST FMTLP

FMTAST:	OASC [ASCIZ /
UNIT #U IS ALREADY FORMATTED, REFORMAT? /]
	PUSHJ P,REDLIN
	PUSHJ P,YESNO
	 JRST FMTLP	;HE SAID NO  (AT LEAST NOT YES)
	JRST FMTLP1	;REFORMAT
;QUEUNT - Save PC and ACs in unit block, to be started later

QUEUNT:	MOVE T1,(P)
	MOVEM T1,UNIPC(U)	;SET UP PC
	MOVEI T1,1
	MOVEM T1,UNIIOW(U)
	MOVEM 17,UNISAC+17(U)	;SAVE AC'S
	MOVEI 17,UNISAC(U)
	BLT 17,UNISAC+16(U)
	MOVE 17,UNISAC+17(U)
	MOVEI T1,UNIPDL-1(U)
	MOVEM T1,UNISAC+P(U)
	AOS DEVWAT	;ONE MORE WAITER
CPOPJ1:	AOS (P)
CPOPJ:	POPJ P,

ALLWAT:	MOVEM 17,SAVAC+17
	MOVEI 17,SAVAC
	BLT 17,SAVAC+16
	MOVE 17,SAVAC+17
	JRST WAIT	;WAIT FOR UNITS TO FINISH

YESNO:	PUSHJ P,SCAN
	JUMPN T1,CPOPJ
	MOVS T1,ACCUM
	CAIE T1,'YES'
	CAIN T1,'YE '
	JRST CPOPJ1
	CAIN T1,'Y  '
	AOS (P)
	POPJ P,
;FORMAT one pack

FMTDO:	HRLS DAT
	HRLS CMD	;SAVE STARTING ADDRESSES
	PUSHJ P,AFORMA
	  OASC [ASCIZ/
Warning: The alternate tracks on this pack are untrustworthy.
Use the ZFORMAT command to re-format the alternate tracks.
/]			;Continue anyway
	MOVEI	CYL,<CYLS/2>-1	;3330-1 (100 megabyte = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI	CYL,CYLS-1	;SET CORRECT NUMBER OF CYLINERS
	HLRS DAT
	HLRS CMD
FMTCYL:	MOVEI HEAD,HEADS-1
FMTHED:	PUSHJ P,GENSEK	;GENERATE A SEEK
	CAIN HEAD,HEADS-1
	 PUSHJ P,GENSC0		;GENERATE A SET SECTOR TO 0
	PUSHJ P,GENSID	;GENERATE A SEARCH ID AND TIC
	PUSHJ P,TRKFMT	;GENERATE 1 TRACK OF FORMAT
	SOJGE HEAD,FMTHED	;NOW FOR THE REST OF THE HEADS
FMTCYD:	MOVSI T1,(BYTE (8) ENDCMD)
	MOVEM T1,(CMD)
	MOVNI T3,1	;RETRY COUNTER FIRST ERROR
FMTRTY:	HLRZ T1,CMD	;RETRY HERE
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	 JRST FMTERR	;THERE IS A FORMAT ERROR
FMTCY:	HLRS CMD
	HLRS DAT
	SOJGE CYL,FMTCYL
	PUSHJ P,VERIFY	;NOW VERIFY THE FORMATTED PACK
	 JRST NOFVF	;NOT VERIFIED
	OASC [ASCIZ /
FORMATTED AND VERIFIED, UNIT #U
/]
FMTENC:	SKIPN SPCLNK	;IS THERE A SPACE WAITER
	JRST WAIT	;NO, GO TO THE WAIT LOOP
	HLLM CMD,SPCLNK	;YES, GIVE HIM OUR SPACE
	JRST MAINGO	;AND START THINGS UP

NOFVF:	OASC [ASCIZ /
UNIT #U DOES NOT VERIFY
/]
	JRST FMTENC
GENSC0:	MOVSI T2,(BYTE (8) BYTMOD,SETSEC)	;SET SECTOR
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	MOVEI T2,-2(DAT)	;FOR SECTOR 0 USE 0 BYTES OF SEEK
	HRLI T2,(BYTE (12) -1)
	MOVEM T2,1(CMD)
	ADDI CMD,2
	POPJ P,

SECZ.C==2
SZSDAT==2

FMTERR:	TLNN T1,UCHK
	JRST FMTER1	;NO A UNIT CHECK SO NOT OFF-LINE
	MOVE T1,UNISNS(U)
	TLNE T1,(BYTE (8) 0,10)	;CHECK FOR NO RECORD FOUND
	JRST FMTNRC	;NO RECORD, CHECK ALTERNATE TRACKS
	TLNN T1,(BYTE (8) 0,2)	;SET FOR WRITE LOCK
	JRST FMTER1
	PUSHJ P,FMTWP	;SAY WRITE PROTECT
	JRST FMTENC	;AND TERMINATE

FMTER1:	PUSHJ P,COMERR
	 JRST FMTRTY	;NEED TO RETRY
FMTER3:	PUSHJ P,COMERP
	OASC [ASCIZ /Continuing FORMAT anyway
/]
	JRST FMTCY	;[JMS]

FMTER2:	OASC [ASCIZ /FORMAT ABORTED
/]
	JRST FMTENC

TRKFMT:	MOVSI REC,-RECTRK	;18 RECORDS
	MOVEI T1,BYTSIZ
	PUSHJ P,GENWCK
	AOBJN REC,.-2
	MOVEI T1,1	;1 BYTE
	MOVEI REC,XTRREC-1	;WILL GENERATE RECORD 100 ACTUALLY
	
	JRST GENWCK	;A FINAL WRITE COUNT KEY DATA

FMTNRC:	PUSHJ P,COMERR	;MAKE SURE MESSAGE PRINTS
	 JFCL
	PUSHJ P,COMERP
	PUSHJ P,ATRCHK	;CHECK ON ALTERNATE TRACK ERROR
	 SKIPA
	JRST FMTER3
	OASC [ASCIZ /NOTIFY THE SHIFT SUPERVISOR
SAVE THIS PRINTOUT WITH PACK
/]
	JRST FMTER2
;VERIFY SUBROUTINE, CMD AND DAT SET UP (ALSO U OF COURSE)
;SKIP RETURN IF OK, NOFMT HAS BEEN RESET
;ON NON-SKIP RETURN, NOFMT HAS BEEN SET JUST TO MAKE SURE

VERIFY:	HRLS DAT
	HRLS CMD	;JUST TO MAKE SURE
	PUSHJ P,AVERIF	;CHECK ALTERNATE TRACKING
;*;	  POPJ P,	;DO NOT MARK UNFORMATTED IF BAD
	  OASC	[ASCIZ /Alternate track verify failure, checking rest of pack
/]
	HLRS DAT
	HLRS CMD
	MOVEI CYL,<CYLS/2>-1	;3330-1 (100 megabyte = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI CYL,CYLS-1
VERCYL:	MOVEI HEAD,HEADS-1
VERHED:	PUSHJ P,GENSEK
	CAIN HEAD,HEADS-1
	 PUSHJ P,GENSC0
	PUSHJ P,GENSID
	MOVEI T1,RECTRK+1
	PUSHJ P,GENRCN	;GENERATE SOME READ COUNTS
	SOJG T1,.-1
	SOJGE HEAD,VERHED
	MOVSI T1,(BYTE (8) ENDCMD)
	MOVEM T1,(CMD)
	MOVNI T3,1
VERRTY:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST VERERR
	MOVEI	HEAD,HEADS-1	;NO CHECK THE DATA
	HLRS DAT
VERDHD:	MOVSI REC,-RECTRK	;NORMALLY 18 RECORDS
	ADDI DAT,2	;FOR THE SEEK DATA
VERREC:	MOVEI T1,BYTSIZ
	PUSHJ P,CHKREC	;CHECK DATA FOR 1 RECORD
	 JRST BADVER	;WRONG DATA
	AOBJN REC,VERREC
	MOVEI T1,1
	MOVEI REC,XTRREC-1
	PUSHJ P,CHKREC
	 JRST BADVER
	SOJG HEAD,VERDHD	;FINAL CHECK FOR RECORD 100
	HLRS CMD
	HLRS DAT
	SOJGE CYL,VERCYL
	MOVSI T1,NOFMT
	ANDCAM T1,UNISTS(U)
	JRST CPOPJ1

BADVER:	MOVSI T1,NOFMT
	IORM T1,UNISTS(U)	;JUST TO MAKE SURE
	POPJ P,


GENRCN:	MOVSI T2,(BYTE (8) BYTMOD,RCNT)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE (12) -10)
	MOVEM T2,1(CMD)
	SETZM (DAT)
	SETZM 1(DAT)
	ADDI DAT,2
	ADDI CMD,2
	POPJ P,

CHKREC:	LDB T2,[POINT 16,1(DAT),31]
	CAME T2,T1
	POPJ P,
	LDB T2,[POINT 16,(DAT),15]
	CAIE T2,(CYL)
	POPJ P,
	LDB T2,[POINT 16,(DAT),31]
	CAIE T2,(HEAD)
	POPJ P,
	LDB T2,[POINT 8,1(DAT),7]
	CAIE T2,1(REC)
	POPJ P,
	LDB T2,[POINT 8,1(DAT),15]
	JUMPN T2,CPOPJ
	ADDI DAT,2
	JRST CPOPJ1

VERERR:	TLNN T1,UCHK
	JRST VERER1
	MOVE T1,UNISNS(U)
	TLNN T1,(BYTE (8) 0,10)	;NO RECORD FOUNT
	JRST VERER1
	PUSHJ P,ATRCHK	;CHECK ALTERNATE TRACK ERROR
	 JRST BADVER	;IT IS
	OASC [ASCIZ /
UNIT #U INCORRECT FORMAT
/]
	JRST BADVER

VERER1:	PUSHJ P,COMERR
	 JRST VERRTY
	PUSHJ P,COMERP
	JRST BADVER
;CHECK ON ALTERNATE TRACK TO SEE IF BAD INFO THERE

ATRCHK:	PUSHJ P,FNDERR	;THIS SHOULD SET CYL AND HEAD TO CORRECT VALUES
	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST CPOPJ1	;JUST SAY NOT BAD FORMAT
	LDB T1,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	TRNN T1,HA.BAD	;DOES THIS ONE SAY BAD?
	 JRST CPOPJ1	;NO
	PUSH P,CYL
	PUSH P,HEAD	;SAVE INFORMATION
	LDB CYL,[POINT 16,1(DAT),15]
	LDB HEAD,[POINT 16,1(DAT),31]
	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST ERRPJ1	;GET STUFF OFF STACK AND SKIP
	POP P,HEAD
	POP P,CYL	;GET BACK CYL AND HEAD
	LDB T1,HABITS	;Flag byte from HA (HA.ALT!HA.BAD only)
	CAIE T1,HA.ALT	;1 means alternate track in use
	 JRST ATRERR	;IT IS WRONG
	LDB T1,[POINT 16,1(DAT),15]
	LDB T2,[POINT 16,1(DAT),31]
	CAMN T1,CYL
	CAME T2,HEAD
	 SKIPA
	JRST CPOPJ1	;THAT LOOKS OK, LET OTHER MSG COME OUT
ATRERR:	OASC [ASCIZ /
UNIT #U BAD ALTERNATE TRACK SETUP ON CYL #C HEAD #H
GIVE THIS PACK AND PRINTOUT TO THE SHIFT SUPERVISOR
/]
	POPJ P,		;AND RETURN

ERRPJ1:	POP P,T1
	POP P,T1
	JRST CPOPJ1
SUBTTL	"VERIFY" - Verify that all pages can be read

VERCMD:	PUSHJ P,REDDRV
	SETZM SPCLNK
VERLP:	PUSHJ P,@DRVDSP
	 JRST ALLCMP	;FINISHED
	MOVE T1,MEMFRE
	ADDI T1,FMTZ.C+FMTZ.D	;SAME SIZES AS FOR FORMAT
	CAML T1,MEMSIZ
	JRST VNOMEM
	MOVE CMD,MEMFRE
	MOVEM T1,MEMFRE
VERLP2:	MOVEI DAT,FMTZ.C(CMD)
	PUSHJ P,QUEUNT
	 JRST VERDO	;GO DO THE ACTUAL WORK
	JRST VERLP	;NEXT

VNOMEM:	HRRZM U,SPCLNK
	PUSHJ P,ALLWAT
	HLRZ CMD,SPCLNK
	SETZM SPCLNK
	JRST VERLP2

VERDO:	PUSHJ P,VERIFY
	 JRST NOFVF	;SAME AS FOR NON-VERIFY ON FORMAT
	OASC [ASCIZ /
VERIFIED UNIT #U
/]
	JRST FMTENC	;SAME AS END FOR FORMAT
;GENERATE A SEEK

GENSEK:	MOVSI T2,(BYTE (8) BYTMOD,SEEK)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE (12) -6)
	MOVEM T2,1(CMD)
	ADDI CMD,2
	SETZM (DAT)
	DPB CYL,[POINT 16,(DAT),31]
	SETZM 1(DAT)
	DPB HEAD,[POINT 16,1(DAT),15]
	ADDI DAT,2
	POPJ P,

GENSID:	MOVSI T2,(BYTE (8) BYTMOD+OFFSET,SRCIDE)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	MOVEI T2,-2(DAT)
	HRLI T2,(BYTE (12) -5)
	MOVEM T2,1(CMD)
	HRRZ T2,CMD
	HRLI T2,TIC
	MOVEM T2,2(CMD)
	ADDI CMD,3
	POPJ P,

GENWCK:	MOVSI T2,(BYTE (8) BYTMOD!IGNLEN,WCKD)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE(12) -10)
	MOVEM T2,1(CMD)
	ADDI CMD,2
	SETZM 1(DAT)
	DPB T1,[POINT 16,1(DAT),31]
	DPB CYL,[POINT 16,(DAT),15]
	DPB HEAD,[POINT 16,(DAT),31]
	MOVEI T2,1(REC)
	DPB T2,[POINT 8,1(DAT),7]
	ADDI DAT,2
	POPJ P,

SEKZ.C==2
SEKZ.D==2	;SIZES FOR SEEK
SIDZ.C==3	;AND FOR SEARCH ID=
SZIDAT==0	;DATA FROM SEEK
WCKZ.C==2
WCKZ.D==2
SUBTTL	"SHH" - Quiets the bell

QUIET:	SETZM BELFLG
	JRST CMDLP	;JUST RESET FLAG TO RING BELL

SUBTTL	"SWITCH" - Print settings of the sense switches

PRTSWS:	OASC [ASCIZ /
SENSE SWITCH SETTINGS FOR THE COPY COMMAND ARE:

/]
	OASC MDOBAT
	OASC MNOBAT
	CRLF
	OASC MNOERR
	OASC MDOERR
	CRLF
	OASC MDOALT
	OASC MNOALT
	JRST CMDLP
SUBTTL	Program to load BOOTS from IBM disks on an SA10 channel
;Note that this routine runs on both the KI and the KL, no CPU dependencies.

COMMENT ~	Revision history for BOTLOD.

V20  ??-???-??	Loads from KI paper tape, relocates itself into physical
BOTLOD.M00	addresses 774000-777777 on KI's with at least 256K of core.
		BOOTS is 6 blocks long, starting at record 13 of track 0 cyl 0,
		going to record 18 of track 0 cylinder 0.

V20  24-JUN-76	BOOTS is now 7 blocks long, the 7th block is on record 0 of
BOTLOD.M01	track 1 cylinder 0 (an imbedded SEEK and SEARCH ID= was added).

V20   2-JUN-78	No change in KI version, the KL version is loaded by KLCDP into
BOTLOD.M02	locations 334000-337000 (last 2K of unmapped core).

xxx  10-DEC-85	Converted BOTLOD.M02 to use IFCPU macros.
BOTLOD.M03	(Just to get a CREF listing.)

V21  20-JAN-86	Rewrote BOTLOD for the 3650 project (7 pages per track).
BOTLOD.M04	Make KI and KL versions exactly the same, load into page 334.
		Read all 3 pages (12 blocks) reserved for BOOTS into pages
		335-337, using READ MULTITRACK commands.

V22  16-Feb-86	READ MULTITRACK appears to read R0, which is not wanted.  Moved
BOTLOD.M05	BOTLOD to page 333, BOOTS to pages 334-336, data in 337.  Three
		different command lists are tried: 3650 with 7 pages per track,
		3675 with 5 pages per track, 3675 with 18 blocks per track.

V23  27-Mar-86	Change the timing in the STRTIT routine.  Make it match the
BOTLOD.M06	algorithm used in COMMON.MAC.

V24   7-Aug-86	Put BOTLOD in MON##.CMD so it is part of the monitor.  If
BOTLOD.MAC	assembled without S.MAC, user-mode BOTLOD is created.

~  ;End of COMMENT
SUBTTL	Definitions

;Disk Page Number 1 is Head 0 Records 5-8 on 3330-II or 3675B  (block format)
;Disk Page Number 1 is Head 0 Record 2 on 3650 or 3675P        (page format)
;
;DPN    3330      3650    Use
; 0   H0R01-R04   H0R1    IPL     IBM Initial Program Load, KS/8080 boot pointer
; 1   H0R05-R08   H0R2    HOM1    Primary HOM page
; 2   H0R09-R12   H0R3    BAT1    Primary BAT page
; 3   H0R13-R18   H0R4    BOOT1   First 4 blocks of BOOTS
; 4  H0R17/H1R2   H0R5    BOOT2   Two blocks on 1st track, two on 2nd track
; 5   H1R03-R06   H0R6    BOOT3   Last 4 blocks of BOOTS    (H1R1 on 3675P)
; 6   H1R07-R10   H0R7    HOM2    Secondary HOM page        (H1R2 on 3675P)
; 7   H1R11-R14   H1R1    BAT2    Secondary BAT page        (H1R3 on 3675P)
; 8   H1R15-R18   H1R2    SATRIB  RIB for SAT.SYS on DSKB0:

	J=S		;SA-10 number, 0 or 1
	F=F		;Channel number, 0 to 3
	U=U		;Disk unit, X'C0' to X'FF'
	P1=DAT		;Pointer to SABASE
	P2=CMD		;Pointer to command list
	P=P		;Stack
	T1=T1		;Temp
	T2=T2		;Used for CONI status input
	T3=T3		;Used for CONO command output
	T4=T4		;Temp

	APR== 000	;CPU Arithmetic processor
	PI==  004	;Priority interrupt system
	PAG== 010	;Pager

	PC.USR==(1B5)	;User mode bit in PC flags

;BOTLOD - Called via 146 restart, or when ONCE wants to reload BOOTS from disk
;  BOTLOD is BLT'ed to the first half of page 334 and executed from there.
;  Pages 335,336,337 are undisturbed (COMMON puts context pages there).
;  BOOTS is read in to pages 774 + 775 + 776, and uses page 777.
LOAD:
BOTLOD::MOVSI	0,(JRST (1))	;Return instruction
	JSP	1,0		;Get PC and flags
	SUBI	1,.		;Set for relocation
	CONO	PAG,0		;Disable paging on KL,KS,F3, turn off cache
	MOVEI	0,400000	;Load right for KI (do not update accts others)
	DATAO	PAG,0		;Disable paging on KI
	HRLZI	0,BTS001(1)	;Source (position independent)
	HRRI	0,BOOTFI	;Destination (fixed at 334000)
	BLT	0,BTSEND	;Put where paper-tape or DECtape puts BOTLOD
	JRST	BOOTFI		;Go to BOOT First Instruction
SUBTTL	Program to load BOOTS from IBM disks on an SA10 channel

	BOOTS=774000			;CRASH code copies UPT to pages 335-337
BTS000:	IOWD	BOTLEN,BOOTFI		;1st word of SAV file and paper tape
BTS001:	PHASE	334000			;Put this below 112K boundry for KLDCP

BOOTFI::CONO	APR,200000		;BOOTS First Instruction = Reset I/O bus
	CONO	PI,10400+1177		;Clear PI, off PI, off selected PI
	MOVE	P,[IOWD PDLLEN,EPDL]	;Set up stack
	MOVE	T1,NOSA10		;Set up HALT instruction
	MOVEM	T1,BOOTS		; if nothing can be read

;Try both SA10 device codes

	MOVSI	J,-SAXN			;AOBJN for two SA10's
SALOOP:	XCT	BPCNI1(J)		;Do CONI into T1
	SKIPE	T1			;Bit 17 always set on a working SA10
	 PUSHJ	P,SAFND			;Go check out this I/O device
	AOBJN	J,SALOOP		;Try next SA10
	SKIPN	BOOTS			;Was nonzero data read in?
NOSA10:: HALT	NOSA10			;Could not find BOOTS anywhere
	JRST	BOOTS			;*HACK* Yes, go to it anyway

;Found an SA10, try all 4 channels on it

;J/ SAX number, 0 or 1
;F/ channel number, 0 to 3
;P1/ pointer to 4-word block in SABASE

SAFND:	MOVSI	C,-CHANN		;AOBJN to do 4 channels on each SA10
SAFND1:	MOVEI	T1,^D100000		;Loop counter
	MOVE	T3,REQSTS(C)		;Request status be stored
	XCT	BPCNO3(J)		;  CONO SA,540     (550,560,570)
	MOVE	T2,SSBITS(C)		;Check if SS bit has come on yet
	XCT	BPCNS2(J)		;  CONSO SA,100       (40,20,10)
	 SOJG	T1,.-1			;Not yet, wait a while
	SKIPE	T1			;If we did not time out,
	 PUSHJ	P,CHFND			;Go investigate this channel
	AOBJN	C,SAFND1		;Try all 4 channels
	POPJ	P,			;Done all, try next SA10
SUBTTL	CONO and CONI bits for SA10

	SAXN==2		;Up to 2 SA10 devices per CPU
	SAX1==274	;First SA10 device code
	SAX2==400	;Second SA10 device code

SABASE:	EXP	300		;Base of block in absolute low core for channels
	EXP	320		; (Set by DIP switches on the SA10)
BPCNI1:	CONI	SAX1,T1		;Check if device responds
	CONI	SAX2,T1
BPCNS2:	CONSO	SAX1,(T2)	;Skip if status stored
	CONSO	SAX2,(T2)
BPCNO3:	CONO	SAX1,(T3)	;Set GO, STATUS, etc
	CONO	SAX2,(T3)

;CONO commands to SA10
	SA.RST==400000	;Reset SA10 and all 4 channels on it
	SSTS==     640	;Set STATUS STORED bit for channel
	CSTS==     600	;Clear STATUS STORED bit for channel
	SREQ==     540	;Request status for channel
	BUSY==     440	;Set GO flag for channel
	CHN0==      00	;This command is for channel 0 (tape on TYMCOM-X)
	CHN1==      10	;This command is for channel 1 (disk on TYMCOM-X)
	CHN2==      20	;This command is for channel 2 (not used by TYMCOM-X)
	CHN3==      30	;This command is for channel 3 (not used by TYMCOM-X)
	PIA==        7	;Set PI Assignment

	CHANN==4	;4 channels, index by F
SETBSY:	EXP BUSY+CHN0,BUSY+CHN1,BUSY+CHN2,BUSY+CHN3	;Set BUSY (GO)
REQSTS:	EXP SREQ+CHN0,SREQ+CHN1,SREQ+CHN2,SREQ+CHN3	;Request status
CLRSTS:	EXP CSTS+CHN0,CSTS+CHN1,CSTS+CHN2,CSTS+CHN3	;Clear status-stored
SETSTS:	EXP SSTS+CHN0,SSTS+CHN1,SSTS+CHN2,SSTS+CHN3	;Set status-stored

;CONI bits from SA10		;Bit 17 always on for CONI and SKIPE
IEBITS:	EXP	40000,20000,10000,04000		;Chan interrupt enabled
GOBITS:	EXP	02000,01000,00400,00200		;GO flag is set for channel
SSBITS:	EXP	00100,00040,00020,00010		;Status has been Stored
SUBTTL	Found a working SA10 channel

;J/ SAX number, 0 or 1
;C/ channel number, 0 to 3
;U/ disk unit number in 3rd byte
;P1/ pointer to 4-word block in SABASE

CHFND:	HRRZ	P1,C			;Channel number
	IMULI	P1,4			;4 words per channel
	ADD	P1,SABASE(J)		;Set initial command address
	MOVE	T1,[TIC,,NOPCMD]	;Transfer to no-op command
	MOVEM	T1,(P1)			;Set CCW for this channel
	MOVE	U,NOOPD0		;NO-OP to first disk on this channel
CHFN1:	MOVEM	U,NOPCMD		;Store command
	PUSHJ	P,STRTIT		;Start device
	  JRST	CHFN2			;Device not responding (U modified)
	PUSHJ	P,UTFND			;Found working unit, read from it
CHFN2:	CAML	U,MAXDEV		;Last device?
	 POPJ	P,			;Done, try next channel
	ADDI	U,<BYTE(8)0,0,1>	;No, increment unit number in 3rd byte
	JRST	CHFN1			;Try next disk unit

;Found a working disk unit.  Third byte of DU has unit number
;J/SAX#, C/Channel #, P1/Channel base, P2/Command list

UTFND:	LDB	T1,[POINT 8,U,23]	;Get device/controller address
	MOVEI	P2,LIST0		;Start of command lists

;Modify all occurrances of FDISKA to be current device address

UTFND0:	HLRZ	T2,(P2)			;Get LH of command
	CAIN	T2,TIC			;Transfer in channel?
	 ADDI	P2,1			;Yes, skip over it
	DPB	T1,[POINT 8,0(P2),23]	;No, store new device address
	ADDI	P2,2			;Point to next pair
	CAIGE	P2,LIST9		;Hit end of last list?
	 JRST	UTFND0			;No, do more commands

;Tell SA10 to look at command list and read BOOTS from the disk

	MOVSI	P2,-NLISTS		;Try all supported formats
READIT:	MOVE	T1,LISTS(P2)		;Point to a command list
	MOVEM	T1,(P1)			;Tell channel where to go
	PUSHJ	P,STRTIT		;Start channel and device
	  JRST	NOREAD			;Some sort of error
	MOVE	T1,BOOTS		;Check first word
	CAMN	T1,BOOTFI		;Is it CONO APR,200000 ?
	 JRST	BOOTS			;All good.  Go start it
NOREAD:	AOBJN	P2,READIT		;Try the next one
	POPJ	P,			;All tries to read failed

LISTS:	TIC,,LIST1			;3650 in blocks
	TIC,,LIST2			;3675 in blocks
	TIC,,LIST3			;3650 in pages
	TIC,,LIST4			;3675 in pages
NLISTS==.-LISTS
SUBTTL	Routine to start I/O on the channel and device

;Bits returned from channel in SABASE+1
	;     ==(3B1)		;Type of status 0=end,1=init,2=async,3=requested
	SELERR==(1B2)		;Select error - no control unit at this address
	;     ==(1B3)		;Bus In Parity Error
	;     ==(1B4)		;Control error
	;     ==(0B5)		; always zero
	LENERR==(1B6)		;Length error - count does not match
	;     ==(1B7)		;Program requested interrupt
	;  ==(BYTE (8)0,200)	;Attention
	SM== (BYTE (8)0,100)	;Status modifier
	CUE==(BYTE (8)0,040)	;Control unit end
	BSY==(BYTE (8)0,020)	;Control unit busy (SM=1) or string busy (SM=0)
	CE== (BYTE (8)0,010)	;Channel end
	DE== (BYTE (8)0,004)	;Device end
	;  ==(BYTE (8)0,002)	;Unit check
	;  ==(BYTE (8)0,001)	;Unit exception
	;   ==BYTE (8)0,000,377	;Device address

;Here to start I/O on an IBM disk, skip return if successful
;J/SAX#, C/Channel #, P1/300,304,310,314, 320,324,330,334

STRTIT:	MOVEI	T1,^D50000		;Wait for previous activity to stop
	SOJG	T1,.			;*HACK*
STRT1:	MOVE	T3,SETSTS(C)		;Tell channel to store status now
	XCT	BPCNO3(J)		;  CONO SA,640
	MOVE	T3,SETBSY(C)		;Set the GO flag
	XCT	BPCNO3(J)		;  CONO SA,440
	MOVE	T3,CLRSTS(C)		;Clear the Status Stored bit
	XCT	BPCNO3(J)		;  CONO SA,600

	MOVEI	T1,^D100000		;Time out loop
	MOVE	T2,SSBITS(C)		;Wait for Status Stored bit to set
	XCT	BPCNS2(J)		;  CONSO SA,100
	 SOJG	T1,.-1
	JUMPE	T1,STRT4		;Timed out, channel is not working
	MOVE	T2,1(P1)		;Get status word
	TLNE	T2,SELERR		;Select error?
	 JRST	STRT4A			;Yes, no disks at this address
	TLNN	T2,BSY			;BUSY?
	 JRST	STRT3			;No, transfer is done
	TLNE	T2,SM			;BUSY and STATUS MODIFIER?
	 JRST	STRT2			;Yes, wait for CONTROL UNIT END
	TLNE	T2,CUE			;BUSY and CONTROL UNIT END?
	 JRST	STRT1			;Yes, restart
STRT3:	TLNN	T2,CE+DE		;Channel End and Device End?
	 JRST	STRT5			;No.  BSY should not be off!
	TLNN	T2,175114		;Any errors?
	 JRST	HPOPJ1			;No, give skip return

;Here for reasonable errors, such as unit exists but is off-line

STRT5:	MOVEI	T3,SA.RST		;Reset all channels on the SA10
	XCT	BPCNO3(J)		;  CONO SA,400000
	POPJ	P,			;Error return to try next unit

;Here on timeout
STRT4:	MOVE	U,MAXDEV		;Go to new channel

;Here on select error - no disk string responded to this address
STRT4A:	TRO	U,<BYTE (8)0,0,7>	;Skip rest of disk string
	POPJ	P,			;Give error return from STRTIT

;Here for BSY+SM = SCU (3672/3674) is busy (as opposed to 3673+3675 busy)

STRT2:	MOVE	T3,CLRSTS(C)		;Clear status stored bit
	XCT	BPCNO3(J)		;  CONO SA,600
	MOVE	T2,SSBITS(C)		;Wait for new status to be stored
	XCT	BPCNS2(J)		;  CONSO SA,100
	 JRST	.-1
	MOVE	T2,1(P1)		;Get new status
	TLNE	T2,CUE			;Control Unit End?
	 JRST	STRT1			;Finally.  Now go get device status
	JRST	STRT2			;No, wait unit it does show up


HPOPJ1:	AOS	(P)			;And skip return for success
HPOPJ:	POPJ	P,
SUBTTL	Command list for IBM 3330-II disks

  ;1st byte = mode for channel
BYTMOD== 10+40+20+2	;Byte mode, execute, CMD chain, ignore length error
OFSMOD== 10+40+20+2+1	;Offset byte mode for SEARCH ID==
WRDMOD==100+40+20	;Read words in natural mode, execute, CMD chain
NOXFER==200+40		;Don't transfer bytes to/from memory, execute CMD
DHALT== 200		;No memory transfer, don't execute (end of command list)
TIC=(BYTE(8)100)	;200000 = Tranfer In Channel = GOTO command

  ;2nd byte = command to disk
NOOP==   3		;No operation (to test for SELECT ERROR)
SENSE==  4		;Read sense bits
WRITE==  5		;Write one record
READ==   6		;Read one record
SEEK==   7		;Position to cylinder, select head
SEARCH==61		;Search for ID=

  ;3rd byte = device address
FDISKA==300		;First TYMCOM-X disk address (C0-DF on 1st 3674)
LDISKA==377		;Last  TYMCOM-X disk address (D0-FF on 2nd 3674)
NOOPD0:	BYTE	(8)NOXFER,NOOP,FDISKA	;NOOP for first disk address X'C0'=300
MAXDEV:	BYTE	(8)NOXFER,NOOP,LDISKA	;NOOP for last disk address  X'FF'=377

;Arguments for SEEK and SEARCH ID
  ;Disk page 3 is record 4 for 3650 pages and 3675 pages
H0R4:	BYTE	(16)0,0,0(8)^D3+1	;BIN 0, CYL 0, HEAD 0, REC  4
  ;Disk page 3 is record 13 for 3650 blocks and 3675 blocks
H0R13:	BYTE	(16)0,0,0(8)^D12+1	;BIN 0, CYL 0, HEAD 0, REC 13
  ;3675 in pages does not have record 6, but 3650 in pages does
H0R6:	BYTE	(16)0,0,0(8)^D5+1	;BIN 0, CYL 0, HEAD 0, REC  6
  ;3675 in blocks does not have record 19, but 3650 in blocks does
H0R19:	BYTE	(16)0,0,0(8)^D18+1	;BIN 0, CYL 0, HEAD 0, REC 19
  ;3675 has to continue on record 1 on the next track
H1R1:	BYTE	(16)0,0,1(8)^D0+1	;BIN 0, CYL 0, HEAD 1, REC  1

LIST0:!		;Start address of UTFND0

;The tests are done in the following order:
; 3650 in blocks has a record 19, the others do not.
; 3675 in blocks has a record 13, the page mode packs do not.
; 3650 in pages has a record 7, 3675 in pages does not.
; 3675 in pages will get "record not found" for all the above tests.

;Command list for 3650 formatted in blocks (25 blocks per track)

LIST1:	BYTE	(8)BYTMOD,SEEK,FDISKA	;SEEK
	BYTE	(12)-6(24)H0R13		; to BIN 0, CYL 0, HEAD 0
	BYTE	(8)OFSMOD,SEARCH,FDISKA	;SEARCH ID=
	BYTE	(12)-5(24)H0R13		; for CYL 0, HEAD 0, REC 13 (DPN=3)
	  XWD	TIC,.-2			;TIC if search fails
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+0000	; Disk block 12 into core page 774
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+0200	; Block 13
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+0400	; Block 14
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+0600	; Block 15
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+1000	; Disk block 16 into core page 775
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+1200	; Block 17
					;(3675 in blocks fails this next seek)
	BYTE	(8)BYTMOD,SEEK,FDISKA	;SEEK
	BYTE	(12)-6(24)H0R19		; to BIN 0, CYL 0, HEAD 1
	BYTE	(8)OFSMOD,SEARCH,FDISKA	;SEARCH ID=
	BYTE	(12)-5(24)H0R19		; for CYL 0, HEAD 0, REC 19 (DPN=4.5)
	  XWD	TIC,.-2			;TIC if search fails
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+1400	; Block 18 is in record 19
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+1600	; Block 19
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+2000	; Disk block 20 into core page 776
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+2200	; Block 21
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+2400	; Block 22
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+2600	; Block 23
	BYTE	(8)NOXFER,NOOP,FDISKA	;NO OP
	BYTE	(8)DHALT		;End of command list
IF2,<IFN <LIST2-.>,<PRINTX ? UTFND0 expects LIST2 to follow LIST1>>

;Command list for 3675 formatted in blocks (18 blocks per track)

LIST2:	BYTE	(8)BYTMOD,SEEK,FDISKA	;SEEK
	BYTE	(12)-6(24)H0R13		; to BIN 0, CYL 0, HEAD 0
	BYTE	(8)OFSMOD,SEARCH,FDISKA	;SEARCH ID=
	BYTE	(12)-5(24)H0R13		; for CYL 0, HEAD 0, REC 13 (DPN=3)
	  XWD	TIC,.-2			;TIC if search fails
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+0000	; Disk block 12 into core page 774
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+0200	; Block 13
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+0400	; Block 14
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+0600	; Block 15
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+1000	; Disk block 16 into core page 775
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+1200	; Block 17
	BYTE	(8)BYTMOD,SEEK,FDISKA	;SEEK
	BYTE	(12)-6(24)H1R1		; to BIN 0, CYL 0, HEAD 1
	BYTE	(8)OFSMOD,SEARCH,FDISKA	;SEARCH ID=
	BYTE	(12)-5(24)H1R1		; for CYL 0, HEAD 1, REC 0 (DPN=4.5)
	  XWD	TIC,.-2			;TIC if search fails
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+1400	; Block 18
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+1600	; Block 19
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+2000	; Disk block 20 into core page 776
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+2200	; Block 21
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+2400	; Block 22
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-200(24)BOOTS+2600	; Block 23
	BYTE	(8)NOXFER,NOOP,FDISKA	;NO OP
	BYTE	(8)DHALT		;End of command list
IF2,<IFN <LIST3-.>,<PRINTX ? UTFND0 expects LIST3 to follow LIST2>>

;Command list for 3650 formatted in pages (7 pages per track)

LIST3:	BYTE	(8)BYTMOD,SEEK,FDISKA	;SEEK
	BYTE	(12)-6(24)H0R4		; to BIN 0, CYL 0, HEAD 0
	BYTE	(8)OFSMOD,SEARCH,FDISKA	;SEARCH ID=
	BYTE	(12)-5(24)H0R4		; for CYL 0, HEAD 0, REC 4 (DPN=3)
	  XWD	TIC,.-2			;TIC if search fails
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-1000(24)BOOTS+0000	; Disk page 3 into core page 774
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-1000(24)BOOTS+1000	; Disk page 4 into core page 775
					;(3675 in pages fails this next seek)
	BYTE	(8)BYTMOD,SEEK,FDISKA	;SEEK
	BYTE	(12)-6(24)H0R6		; to BIN 0, CYL 0, HEAD 0
	BYTE	(8)OFSMOD,SEARCH,FDISKA	;SEARCH ID=
	BYTE	(12)-5(24)H0R6		; for CYL 0, HEAD 0, REC 6 (DPN=5)
	  XWD	TIC,.-2			;TIC if search fails
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-1000(24)BOOTS+2000	; Disk page 5 into core page 776
	BYTE	(8)NOXFER,NOOP,FDISKA	;NO OP
	BYTE	(8)DHALT		;End of command list
IF2,<IFN <LIST4-.>,<PRINTX ? UTFND0 expects LIST4 to follow LIST3>>

;Command list for 3675 formatted in pages (5 pages per track)

LIST4:	BYTE	(8)BYTMOD,SEEK,FDISKA	;SEEK
	BYTE	(12)-6(24)H0R4		; to BIN 0, CYL 0, HEAD 0
	BYTE	(8)OFSMOD,SEARCH,FDISKA	;SEARCH ID=
	BYTE	(12)-5(24)H0R4		; for CYL 0, HEAD 0, REC 4 (DPN=3)
	  XWD	TIC,.-2			;TIC if search fails
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-1000(24)BOOTS+0000	; Disk page 3 into core page 774
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-1000(24)BOOTS+1000	; Disk page 4 into core page 775
	BYTE	(8)BYTMOD,SEEK,FDISKA	;SEEK
	BYTE	(12)-6(24)H1R1		; to BIN 0, CYL 0, HEAD 1
	BYTE	(8)OFSMOD,SEARCH,FDISKA	;SEARCH ID=
	BYTE	(12)-5(24)H1R1		; for CYL 0, HEAD 1, REC 0 (DPN=5)
	  XWD	TIC,.-2			;TIC if search fails
	 BYTE	(8)WRDMOD,READ,FDISKA	;READ
	 BYTE	(12)-1000(24)BOOTS+2000	; Disk page 6 into core page 776
NOPCMD:	BYTE	(8)NOXFER,NOOP,FDISKA	;NO OP
	BYTE	(8)DHALT		;End of command list
IF2,<IFN <LIST9-.>,<PRINTX ? UTFND0 expects LIST4 to be last>>

LIST9:!		;End address for UTFND0

HLITS:	LIT
	JRST	BOOTFI		;Last word read from PTR is executed in RIM
BOTLEN=.-BOOTFI			;Length of Exec mode BOTLOD
	JRST	BOOTFI		;Last word of SAV file is JRST to start addr
	PDLLEN==20
EPDL:	BLOCK	PDLLEN		;Stack
BTSEND:	DEPHASE			;End of BOTLOD

	UPDL=EPDL-BOOTFI+BTS001		;Stack when in user mode
	UNUSED==BOOTFI+1000-BTSEND	;Block of unused words on page 334

;DEFINE PR(A,B),<IF2,<	PRINTX [A B]>>
;	LALL
;PR(BOTLOD starts at,\BOOTFI)
;PR(Length of BOTLOD =,\BOTLEN)
;PR(BOTLOD ends at,\BTSEND)
;PR(\UNUSED,words unused in page 334)
SUBTTL	"BOOTS" - Load BOOTS from disk pages 3,4,5

REPEAT 0,<;Old version
LOAD:	CONO	APR,1B19	;LOAD BOOTS FROM THE DISK
	CONO	PI,1B23
	MOVEI	T1,SAXBAS
	MOVEM	T1,BASEA
	MOVSI	T4,-SAXN
BPLOOP:	XCT	BPCNI(T4)	;READ STATUS TO T1
	JUMPN	T1,SAFND	;FOUND AN SA10
BPLOO1:	MOVEI	T1,20
	ADDM	T1,BASEA	;SET BASE ADDRESS FOR NEXT SA10
	AOBJN	T4,BPLOOP	;NOT DONE SO TRY NEXT SA10
	OASC	[ASCIZ /
CAN NOT FIND BOOTS - RESTARTING
/]
	JRST	RESTRT

SAFND:	MOVEI	T3,SRGO		;STATUS REQ. FOR CHAN 0
	MOVEI	T2,1B29		;STATUS FLAG FOR CHAN 0
	JRST	SAFND3		;SET UP FLAGS
SAFND1:	MOVEI	T1,^D100000	;LOOP COUNTER
	XCT	BPCNO1(T4)	;STATUS REQ CONO
	TRC	T3,100		;CHANGE STATUS REQUEST TO GO
	XCT	BPCNO2(T4)	;STATUS STORED?
	SOJG	T1,.-1		;WAIT A WHILE
	JUMPG	T1,CHFND	;BUT NOT TOO LONG A WHILE
SAFND2:	LSH	T2,-1		;NEXT CHANNEL
	ADDI	T3,10	
SAFND3:	HRRM	T3,CHGO(T4)	;UPDATE CHANNEL  NUMBER
	TRC	T3,240		;CHANGE GO TO CLEAR STATUS
	HRRM	T3,CHCLR(T4)
	TRC	T3,340		;CHANGE CLEAR STATUS TO REQUEST STATUS
	TRNN	T2,1B33		;LAST CHANNEL?
	 JRST	SAFND1		;NO
	JRST	BPLOO1		;YES. TRY NEXT SA10

CHFND:	MOVE	C,T3
	LSH	C,-1
	ANDI	C,14		;ISOLATE CHANNEL NUMBER*4
	ADD	C,BASEA		;SET BASE ADDRESS FOR THIS CHANNEL
	MOVE	T1,ENDLTC	;TIC TO EOL-1 (NO-OP)
	MOVEM	T1,(C)
	MOVE	T1,NOOPD0	;NO-OP TO DEVICE 0
CHFN1:	MOVEM	T1,ENDLST-1	;CHANNEL COMMAND WORD
	PUSHJ	P,STRTIT	;START DEVICE
	 JRST	UTFND		;FOUND WORKING UNIT
CHFN2:	CAMN	T1,MAXDEV	;LAST DEVICE?
	 JRST	SAFND2		;YES. TRY NEXT CHANNEL
	ADDI	T1,1B23		;ERROR. TRY NEXT UNIT NUMBER
	JRST	CHFN1		;NO. TRY NEXT ONE
;Load BOOTS (continued)
UTFND:	MOVE	K,CMDTIC	;SET UP TO START COMMAND LIST
	MOVEM	K,(C)
	MOVEI	S,CMDLST	;FIX UP ADDRESS
	MOVE	DAT,[POINT 8,(S),23]; DEVICE ADDRESS IN COMMAND LIST
	LDB	CMD,[POINT 8,ENDLST-1,23]; GET DEVICE ADDRESS
	MOVE	U,[POINT 8,(S),7]	;TO GET CODE
	MOVE	K,MEMSIZ
	SUBI	K,4000-137
UTFND1:	LDB	CH,U
	CAIN	CH,100	;TIC
	 AOJA	S,UTFND1
	CAIN	CH,240	;NOP AT END
	 JRST	UTFNDE
	DPB	CMD,DAT	;STORE UNIT
	ADDI	S,1
	CAIN	CH,160	;IS IT READ
	SKIPN	ENDLST	;AND RELOC NOT DONE
	 AOJA	S,UTFND1
	ADDM	K,(S)
	AOJA	S,UTFND1

UTFNDE:	SETZM	ENDLST	;CLEAR TERMINATOR
	PUSHJ	P,STRTIT	;START DEVICE
	  JRST	RDDONE	;READ COMPLETED O.K.
	JRST	CHFN2	;NO GOOD. TRY NEXT DEVICE
RDDONE:	HRRZ	S,MEMSIZ	;GET BOOTS STARTING ADDRESS
	MOVE	K,140-4000(S)	;CHECK FIRST WORD
	CAME	K,LOAD
	 JRST	CHFN2	;NOT BOOTS
	OASC [ASCIZ /
BOOTS LOADED
/]
	JRST	140-4000(S)		;ALL GOOD. GO START BOOTS
;Start I/O on selected unit.  Skip return if failed, nonskip = success
STRTIT:	HRRZ	U,CHCLR(T4)
	TRO	U,1B30		;SET THE SET BIT
	XCT	STSET(T4)	;SET STATUS FLAG SO CLR CAN FOLLOW GO
	XCT	CHGO(T4)
	MOVEI	K,0
STRT2:	XCT	CHCLR(T4)
	MOVEI	U,^D100000	;TIME OUT LOOP
	XCT	BPCNO2(T4)	;WAIT FOR STATUS STORED
	SOJG	U,.-1
	JUMPE	U,STRT4		;TIMED OUT
	CAIE	K,0		;PREVIOUS BUSY STATUS?
	 HRLZI	K,BSY		;YES. MAKE THIS ONE BUSY + NEW STATUS
	IOR	K,1(C)		;GET STATUS WORD
	TLNN	K,BSY		;BUSY?
	 JRST	STRT3		;NO.
	TLNE	K,SM		;BUSY AND STATUS MODIFIER?
	 JRST	STRT2		;YES. WAIT FOR CONTROL UNIT END
	TLNE	K,CUE		;BUSY AND CONTROL UNIT END?
	 JRST	STRTIT		;YES. RESTART
STRT3:	TLNN	K,175114	;ANY ERRORS?
	 POPJ	P,
	TLNE	K,SELERR	;WAS IT SELECT ERROR?
	 TRO	T1,7B23		;YES USE NEXT KONTROLLER
STRT4:	XCT	RSET(T4)	;YES. RESET SA-10
	SKIPN	U		;TIMED OUT?
	 MOVE	T1,MAXDEV	;GO TO NEW CHANNEL
	AOS	(P)		;AND SKIP RETURN
	POPJ	P,

	DEFINE GSAX (A,B)
<%%SX==0
	REPEAT SAXN,<GSAX1 (A,B,\%%SX)
	%%SX==%%SX+1>>

	DEFINE GSAX1 (A,B,C)
<	A SA'C,B>
STSET:	GSAX (CONO,(U))
RSET:	GSAX (CONO,400000)
CMDTIC:	XWD	200000,CMDLST
SRGO==440
CHGO:	GSAX (CONO,440)
CHCLR:	GSAX (CONO,600)
BPCNI:	GSAX (CONI,T1)
BPCNO1:	GSAX (CONO,(T3))
BPCNZ2:	GSAX (CONSZ,(T2))
BASEA:	SAXBAS
ENDLTC:	XWD	200000,ENDLST-1
MAXDEV:	BYTE	(8)240,3,377
BPCNO2:	GSAX (CONSO,(T2))
NOOPD0:	BYTE	(8)240,3,300


;This is the command list to read in BOOTS from the HOM pages

CMDLST:	BYTE	(8)72,7		;SEEK
	BYTE	(12)-6(24)ENDLST+1	;SEEK ARG POINTER
	BYTE	(8)73,61	;SEARCH ID=
	BYTE	(12)-5(24)ENDLST+1
	XWD	200000,.-2
IFE RECTRK-^D18,<	;3330 Formatted in blocks
	BYTE (8)160,6		;R13 (DPN=3)
	BYTE (12)-200(24)0001
	BYTE (8)160,6		;R14
	BYTE (12)-200(24)0201
	BYTE (8)160,6		;R15
	BYTE (12)-200(24)0401
	BYTE (8)160,6		;R16
	BYTE (12)-200(24)0601
	BYTE (8)160,6		;R17 (DPN=4)
	BYTE (12)-200(24)1001
	BYTE (8)160,6		;R18
	BYTE (12)-200(24)1201
	BYTE (8) 72,7		;SEEK
	BYTE (12) -6(24) C0H1R1
	BYTE (8) 73,61		;SEARCH ID=
	BYTE (12) -5(24) C0H1R1
	XWD 200000,.-2
	BYTE (8) 160,6		;R1
	BYTE (12)-200(24)1401
	BYTE (8) 160,6		;R2
	BYTE (12)-200(24)1601
	BYTE (8) 160,6		;R3 (DPN=5)
	BYTE (12)-200(24)2001
	BYTE (8) 160,6		;R4
	BYTE (12)-200(24)2201
	BYTE (8) 160,6		;R5
	BYTE (12)-200(24)2401
	BYTE (8) 160,6		;R6
	BYTE (12)-200(24)2601
	BYTE	(8)240,3	;NO-OP
ENDLST:	1
	BYTE	(8)0,0,0,0,0,0,15	;CYL 0 HEAD 0 RECORD ^D13
>
IFE RECTRK-^D25,<	;3350 Formatted in blocks
	BYTE (8)160,6		;R13 (DPN=3)
	BYTE (12)-200(24)0001
	BYTE (8)160,6		;R14
	BYTE (12)-200(24)0201
	BYTE (8)160,6		;R15
	BYTE (12)-200(24)0401
	BYTE (8)160,6		;R16
	BYTE (12)-200(24)0601
	BYTE (8)160,6		;R17 (DPN=4)
	BYTE (12)-200(24)1001
	BYTE (8)160,6		;R18
	BYTE (12)-200(24)1201
	BYTE (8) 160,6		;R19
	BYTE (12)-200(24)1401
	BYTE (8) 160,6		;R20
	BYTE (12)-200(24)1601
	BYTE (8) 160,6		;R21 (DPN=5)
	BYTE (12)-200(24)2001
	BYTE (8) 160,6		;R22
	BYTE (12)-200(24)2201
	BYTE (8) 160,6		;R23
	BYTE (12)-200(24)2401
	BYTE (8) 160,6		;R24
	BYTE (12)-200(24)2601
	BYTE	(8)240,3	;NO-OP
ENDLST:	1
	BYTE	(8)0,0,0,0,0,0,15	;CYL 0 HEAD 0 RECORD ^D13
>
IFE RECTRK-^D5,<	;3330 Formatted in pages
	BYTE (8)160,6		;R4 (DPN=3)
	BYTE (12)-1000(24)0001
	BYTE (8)160,6		;R5 (DPN=4)
	BYTE (12)-1000(24)1001
	BYTE (8) 72,7		;SEEK
	BYTE (12) -6(24) C0H1R1
	BYTE (8) 73,61		;SEARCH ID=
	BYTE (12) -5(24) C0H1R1
	BYTE (8) 160,6		;R1 (DPN=5)
	BYTE (12)-1000(24)2001
	BYTE	(8)240,3	;NO-OP
ENDLST:	1
	BYTE	(8)0,0,0,0,0,0,4	;CYL 0 HEAD 0 RECORD ^D4
>
IFE RECTRK-^D7,<	;3650 Formatted in pages
	BYTE (8)160,6		;R4 (DPN=3)
	BYTE (12)-1000(24)0001
	BYTE (8)160,6		;R5 (DPN=4)
	BYTE (12)-1000(24)1001
	BYTE (8) 160,6		;R6 (DPN=5)
	BYTE (12)-1000(24)2001
	BYTE	(8)240,3	;NO-OP
ENDLST:	1
	BYTE	(8)0,0,0,0,0,0,4	;CYL 0 HEAD 0 RECORD ^D4
>
IFN <RECTRK-^D18>*<RECTRK-^D5>*<RECTRK-^D7>*<RECTRK-^D25>,<
	PRINTX ?Unknown value of RECTRK detected at CMDLST>
C0H1R1:	BYTE (8) 0,0,0,0,0,1,1		;CYL 0 HEAD 1 RECORD 1

BSY==(BYTE (8)0,20)	;BUSY
CUE==(BYTE (8)0,40)	;CONTROL-UNIT END
SM==(BYTE (8)0,100)	;STATUS MODIFIER
>  ;End REPEAT 0
SUBTTL	TTY initialization (set KL10 flag if appropriate)

TTYINI:	SETZ	T1,		;CHECK PROCESSOR TYPE
	BLT	T1,0
	JUMPN	T1,KTYINI	;KL leaves 1,,1 in AC after null BLT
	MOVEI	T1,NXM		;It's a KI
	MOVEM	T1,NXMFLG
	MOVEM	T1,CLRNXM
	DATAO	PAG,[400000+UBR,,400000+EBR]
	CONO	APR,APRCLK	;RESET CLOCK
	CONSO	APR,APRCLK
	 JRST	.-1		;THEN WAIT FOR A TICK
	CONO	APR,APRCLK	;AND RESET
	MOVEI	T1,0
	DATAO	TTY,T1		;SEND NULL
TTYIN0:	CONSO	TTY,20		;WAIT FOR DONE (TEST BUSY)
	 JRST	TTYIN1
	CONSO	APR,APRCLK	;TEST CLOCK
	 JRST	TTYIN0
	CONO	APR,APRCLK
	AOJA	T1,TTYIN0	;COUNT CLOCK TICKS UNTIL DONE

TTYIN1:	MOVEI	T2,0		;T1 HAS # OF CLOCK TICKS
	CAIGE	T1,5
	 MOVEI	T2,2
	CAIGE	T1,3
	 MOVEI	T2,5		;30 CPS
	MOVEM	T2,TTYFIL	;SET FILL COUNT
	MOVEI	CH,0
	JRST	OCHR		;Send a null to get the output-done flag

KTYINI:	TLO	F,KL10		;FLAG KL10 CPU
	CONO	PAG,EBR		;SET UP EPT
	DATAO	PAG,[LG.LUB+UBR]
	MOVEI	T1,LP.NXM
	MOVEM	T1,NXMFLG
	TRO	T1,LP.CSF
	MOVEM	T1,CLRNXM
	SETZM	DTEMTI
	SETZM	DTEMTD
	SETZM	DTECMD
	SETZM	DTEF11
	SETZM	DTEFLG
	CONO	DTE,CL11PT
	MOVEI	T1,.DTESP	;GIVE CMD TO ENTER 2DARY PROTOCOL
	MOVEM	T1,DTECMD
	MOVEI	T2,10
KTY1:	CONO	DTE,TO11DB	;RING DOORBELL
	MOVSI	T1,10		;AND WAIT FOR COMMAND TO BE RECEIVED
	SKIPN	DTEFLG
	 SOJG	T1,.-1
	JUMPG	T1,KTY2
	SOJGE	T2,KTY1
	 HALT	.		;COMMAND NOT RECEIVED - DIE
KTY2:	CONO	TIM,TO.CIT	;CLEAR TIMER
	CONO	TIM,TO.SIT!TICK	;TURN TIMER ON
	MOVEI	T3,.DTCTO	;SEND NULL CHAR
	MOVEM	T3,DTECMD
	CONO	DTE,TO11DB
KTY3:	SKIPE	DTEMTD		;COUNT TICKS UNTIL DONE
	 JRST	TTYIN1
	CONSO	TIM,TI.ITD
	 JRST	KTY3
	CONO	TIM,TO.SIT!TICK
	AOJA	T1,KTY3

;KL TTY Output

KLTYO:	MOVEI	CH,.DTCTO(CH)
	MOVEM	CH,DTECMD
	CONO	DTE,TO11DB
	HRLM	CH,(P)
	SETZ	CH,
	EXCH	CH,DTEMTD
	JUMPE	CH,.-1
	HLRZ	CH,(P)
	ANDI	CH,377
	POPJ	P,

;KL TTY Input

KLTYI:	SKIPN	DTEMTI		;WAIT FOR INPUT READY
	 JRST	.-1
	MOVE	CH,DTEF11
	SETZM	DTEMTI
	POPJ	P,
SUBTTL	TTY output routines

OUTASC:	HRLI T1,(POINT 7,0)
	MOVEI CH,0
	PUSHJ P,OCHR	;Send a null to not lose 1st char on KL
OUTAS1:	ILDB CH,T1
	JUMPE CH,CPOPJ	;FINISHED WHEN 0 BYTE
	CAIN CH,"#"
	 JRST OASCSH
OUTAS2:	PUSHJ P,OCHR
	JRST OUTAS1

OUTOCT:	IDIVI T1,10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTOCT
	HLRZ CH,(P)
	ADDI CH,"0"
OCHR:	TLNE	F,KL10
	JRST	[SKIPE DTEMTI
		JRST .+2
		JRST .+3]
	CONSZ TTY,40	;CHECK FOR INPUT WAITING
	PUSHJ P,TTYINC	;CHHECK FOR ALTMODE AND ^O
	SKIPE CTOFLG
	POPJ P,
OCHR1:	TLNE	F,KL10
	JRST	[PUSHJ P,KLTYO
		JRST OCHR2]
	CONSZ TTY,20
	 JRST .-1
	DATAO TTY,CH
OCHR2:	CAIN CH,15
	SKIPN TTYFIL
	 POPJ P,	;DONE
	PUSH P,T1
	MOVE T1,TTYFIL
	MOVEI CH,177
	PUSHJ P,OCHR
	SOJG T1,.-1
	POP P,T1
	MOVEI CH,15
	POPJ P,	;FINISHED
;More TTY output routines

OUTSIX:	MOVEI T1,0
	LSHC T1,6
	MOVEI CH," "(T1)
	PUSHJ P,OCHR
	JUMPN T2,OUTSIX
	POPJ P,

OUTDEC:	IDIVI T1,^D10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTDEC
	HLRZ CH,(P)
	ADDI CH,"0"
	JRST OCHR

OASCSH:	ILDB CH,T1
	CAIN CH,"U"
	JRST OASCU
	CAIN CH,"C"
	JRST OASCC
	CAIN CH,"H"
	JRST OASCH
	CAIN CH,"R"
	JRST OASCR
	JUMPN CH,OUTAS2
	POPJ P,	;IN CASE OF NULL FOR END

OASCU:	PUSH P,T1
	MOVE T1,UNINUM(U)
	PUSHJ P,OUTOCT
	POP P,T1
	JRST OUTAS1

OASCC:	PUSH P,T1
	HRRZ T1,CYL
	PUSHJ P,OUTDEC
	POP P,T1
	JRST OUTAS1

OASCR:	PUSH P,T1
	HRRZ T1,REC
	PUSHJ P,OUTDEC
	POP P,T1
	JRST OUTAS1

OASCH:	PUSH P,T1
	HRRZ T1,HEAD
	PUSHJ P,OUTDEC
	POP P,T1
	JRST OUTAS1
;More TTY output routines
PRDAT:	PUSH P,T1
	HLRZS T1
	IDIVI T1,^D60
	PUSH P,T1
	ODEC T1
	OCHI ":"
	POP P,T1
	CAIG T1,^D9
	OCHI "0"	;MAKE SURE 2 DIGITS IN MINUTES
	ODEC T1
	POP P,T1
	HRRZS T1
	OCHI " "
PRDATO:	IDIVI T1,^D<365*4+1>	;DATE IN T1, PRINT IT
	IMULI T1,4
	ADDI T1,^D1964
	PUSH P,T1	;SAVE YEAR
	MOVE T1,T2
	CAIGE T1,^D366
	JRST BREAK1	;THIS IS A LEAP YEAR
	SUBI T1,^D366
	IDIVI T1,^D365
	ADDM T1,(P)	;ADD TO YEAR (STILL 1 SHORT)
	MOVEI T3,MONTAB+1
	AOSA (P)	;ADD ONE MORE TO YEAR AND SKIP
BREAK1:	MOVEI T3,MONTB2+1
	HRLI T3,T1	;SET UP INDEX
	MOVSI T1,-^D12
	CAML T2,@T3
	AOBJN T1,.-1
	SUBI T3,1
	SUB T2,@T3	;GET DAY
	ADDI T2,1
	PUSH P,T1	;SAVE MONTH
	ODEC T2
	POP P,T1
	OSIX MONNAM(T1)
	POP P,T2
	ODEC T2	;AND THE YEAR
	POPJ P,

	DEFINE ZOT (A)
<IRP A,<SIXBIT /-A-/>>

MONNAM:	ZOT <JAN,FEB,MAR,APR,MAY,JUNE,JULY,AUG,SEPT,OCT,NOV,DEC>

PRDATZ:	JUMPN T1,PRDAT	;JUST PRINT DATE IF THERE IS ONE
	OASC [ASCIZ /NO DATE/]
	POPJ P,		;ELSE MESSAGE
SUBTTL	LUUO handler

UUOH:	0
	LDB CH,[POINT 9,EBRADD+40,8]	;GET DISPATCH
	CAIL CH,UUONUM
	JRST UUOERR
	PUSHJ P,@UUODSP(CH)
	JRST @UUOH

UUODSP:	UUOERR
	UODEC
	UOOCT
	UOCHR
	UOCHI
	UOASC
	UOCRLF
	UOSIX
UUONUM==.-UUODSP

UUOERR:	MOVEI T1,[ASCIZ /
***UUO ERROR***
/]
	PUSHJ P,OUTASC
	JRST ABORT

UODEC:	MOVE T1,@EBRADD+40
	JRST OUTDEC

UOOCT:	MOVE T1,@EBRADD+40
	JRST OUTOCT

UOCHR:	MOVE CH,@EBRADD+40
	JRST OCHR

UOCHI:	HRRZ CH,EBRADD+40
	JRST OCHR

UOASC:	HRRZ T1,EBRADD+40
	JRST OUTASC

UOCRLF:	MOVEI T1,[ASCIZ /
/]
	JRST OUTASC

UOSIX:	MOVE T2,@EBRADD+40
	JRST OUTSIX
;BELLS
BELWAT:	MOVEI	T1,^D120
	TLNE	F,KL10
	 JRST	KLBLWT
BEL2:	CONSZ	TTY,40		;KI-10 loop
	 POPJ	P,		;CHARACTER IS WAITING TO BE READ
	CONSO	APR,APRCLK
	 JRST	BEL2
	CONO	APR,APRCLK	;CLEAR CLOCK FLAG
	SOJG	T1,BEL2		;NOT ENOUGH TIME
	SETZM	CTOFLG		;RESET CONTROL O FLAG
	OCHI	7
	JRST	BELWAT		;NOW WAIT ANOTHER 5 SECS

SUBTTL	TTY input routines

KLBLWT:	CONO	TIM,TO.SIT!TO.CTD!TICK	;KL-10 loop
KLBL1:	SKIPE	DTEMTI		;INPUT CHAR WAITING?
	POPJ	P,		;YES, GO GET IT
	CONSO	TIM,TI.ITD	;TICK?
	JRST	KLBL1
	CONO	TIM,TO.SIT!TO.CTD!TICK
	SOJG	T1,KLBL1
	SETZM	CTOFLG
	OCHI	7
	JRST	BELWAT

TSTALT:	TLNE	F,KL10
	JRST	[SKIPN DTEMTI
		JRST (T1)
		MOVE T2,DTEF11
		SETZM DTEMTI
		JRST TSTAL1]
	CONSO TTY,40	;DO A JSP T1,TSTALT TO SEE IF ALTMODE
	JRST (T1)	;NO CHR
	DATAI TTY,T2
TSTAL1:	ANDI T2,177
	CAIE T2,175
	CAIN T2,176
	JRST ABORT	;YES, ALTMODE
	CAIE T2,33
	JRST (T1)	;NOT ALTMODE, IGNORE
ABORT:	CONO PI,1B23
	CONO APR,1B19
	SETZM CTOFLG
	MOVEI P,PDL-1
	OASC [ASCIZ /

***ABORTED***

/]
	JRST @ABTDSP	;GO TO ABORT LOCATION

ABTINI:	POP P,ABTDSP
	JRST @ABTDSP	;SET ABORT LOCATION

TTYINC:	PUSH P,T1
	PUSH P,T2
	MOVEI T2,0
	JSP T1,TSTALT	;WILL ABORT IF ALTMODE WAITING
	CAIE T2,"Z"-100	;DELETE TO DISABLE ^O
	JRST TTYINN	;NOT CONTROL O
	POP P,T2
	POP P,T1
	PUSH P,CH
	MOVEI CH,"^"
	PUSHJ P,OCHR1
	MOVEI CH,"O"
	PUSHJ P,OCHR1
	MOVEI CH,15
	PUSHJ P,OCHR1
	MOVEI CH,12
	PUSHJ P,OCHR1
	SETCMM CTOFLG
	POP P,CH
	POPJ P,
TTYINN:	POP P,T2
	POP P,T1
	POPJ P,
;More TTY input routines
REDLIN:	MOVEI T1,^D100	;MAX  NUMBER OF CHRS
	MOVE T2,[POINT 7,INPBUF]
	MOVEM T2,SCNPTR	;FOR READING
	SETZM CTOFLG
	SETZM RUBFLG
	SETZM SAVCHR	;NO SAVED CHRS YET
RDLN1:	TLNE	F,KL10
	JRST	[PUSHJ P,KLTYI
		 JRST RDLN2]
	CONSO TTY,40
	JRST RDLN1
	DATAI TTY,CH
RDLN2:	ANDI CH,177
	CAIE CH,175
	CAIN CH,176
	JRST ABORT	;ABORT ON ALTMODE
	CAIN CH,33
	JRST ABORT
	CAIN CH,"O"-100
	JRST RDLN1	;IGNORE CONTROL O
	CAIN CH,"U"-100
	JRST CTLU
	CAIN CH,177
	JRST RUBOUT
	PUSHJ P,OFFRUB
	PUSHJ P,OCHR1
	SOJL T1,ENDLN2
	IDPB CH,T2
	CAIL CH,40
	JRST RDLN1
	CAIN CH,15	;IS IT RETURN
	JRST ENDLN1	;YES
ENDLN2:	MOVEI CH,15
	PUSHJ P,OCHR	;NO, SEND ONE
ENDLN1:	MOVEI CH,12
	PUSHJ P,OCHR	;AND A LINE FEED
	MOVEI CH,0
	IDPB CH,T2
	POPJ P,

OFFRUB:	SKIPN RUBFLG
	POPJ P,
	PUSH P,CH
	MOVEI CH,"\"
	PUSHJ P,OCHR1
	POP P,CH
	SETZM RUBFLG
	POPJ P,

RUBOUT:	CAIN T1,^D100
	JRST RUBCRL
	MOVEI CH,"\"
	SKIPN RUBFLG
	PUSHJ P,OCHR1	;ENTER RUBOUT MODE
	SETOM RUBFLG
	LDB CH,T2
	PUSHJ P,OCHR1
	SUBI T2,1
	REPEAT 4,<IBP T2>
	AOJA T1,RDLN1

RUBCRL:	PUSHJ P,OFFRUB
RUBCR1:	MOVEI CH,15
	PUSHJ P,OCHR1
	MOVEI CH,12
	PUSHJ P,OCHR1
	JRST REDLIN

CTLU:	PUSHJ P,OFFRUB
	MOVEI CH,"^"
	PUSHJ P,OCHR1
	MOVEI CH,"U"
	PUSHJ P,OCHR1
	JRST RUBCR1
;SCAN INPUT LINE. 4 CASES
;T1=0 ID, SIXBIT IN ACCUM
;T1=1 NUMBER, NUMBER IN ACCUM
;T1=2 TERMINATOR, CHR IN CH
;T1=3 SPECIAL CHR, CHR IN CH

SCNID:	TDZA T1,T1	;USE T1 AS FLAG TO TREAT NUMBER AS ID
SCAN:	MOVEI T1,1
	SKIPN CH,SAVCHR
SCAN1:	ILDB CH,SCNPTR
	CAIN CH," "
	JRST SCAN1
	CAIGE CH," "
	JRST SCAN2	;TERMINATOR
	CAIG CH,"9"
	CAIGE CH,"0"
	JRST SCNLET	;LETTER, TRY IDENT
	JUMPE T1,SCNLET	;TREAT AS IDENT
	MOVEI T1,-"0"(CH)
SCNNUM:	ILDB CH,SCNPTR
	CAIG CH,"9"
	CAIGE CH,"0"
	JRST ENDNUM	;END OF THE NUMBER
	IMUL T1,RADIX
	ADDI T1,-"0"(CH)
	JRST SCNNUM

ENDNUM:	MOVEM CH,SAVCHR	;SAVE TERMINATING CHR
	MOVEM T1,ACCUM
	MOVEI T1,1
	POPJ P,

SCAN2:	MOVEM CH,SAVCHR	;SAVE TERMINATOR SO DON'T RUN OFF LINE
	MOVEI T1,2
	POPJ P,

SCNLET:	SETZM ACCUM
	MOVE T1,[POINT 6,ACCUM]
SCNLT1:	CAIL CH,140
	SUBI CH,40	;FOR LOWER CASE
	CAIG CH,"Z"
	CAIGE CH,"0"
	JRST ENDID	;END OF IDENT
	CAIGE CH,"A"
	CAIG CH,"9"	;ALSO RECOGNIZE DIGITS
	SKIPA
	JRST ENDID
	SUBI CH,40
	TLNE T1,770000
	IDPB CH,T1
	ILDB CH,SCNPTR
	JRST SCNLT1	;SCAN REST OF ID

ENDID:	SKIPN ACCUM	;ANTHING THERE?
	JRST SCNSPC	;NO, MUST HAVE BEEN A SPECIAL CHR
	MOVEM CH,SAVCHR	;SAVE TERM
	MOVEI T1,0
	POPJ P,

SCNSPC:	SETZM SAVCHR	;NO SAVED CHR
	MOVEI T1,3
	POPJ P,
;READ A DRIVE LIST

REDDRV:	OASC [ASCIZ /
DRIVE(S): /]
REDDV1:	PUSHJ P,REDLIN
	MOVSI T4,-DRVLEN	;LENGTH OF THE DRIVE LIST
	PUSHJ P,SCAN
	XCT RDVTAB(T1)	;GO TO IT

RDVTAB:	JRST DRVALL	;CHECK FOR ALL
	JRST DRVNUM
	JRST NODRV	;JUST TERM, NO DRIVES
	JRST BADDRV

BADDRV:	OASC [ASCIZ /
BAD DRIVE LIST, RETYPE/]
	JRST REDDRV

NODRV:	OASC [ASCIZ /
NO DRIVES SPECIFIED/]
	JRST REDDRV

DRVALL:	MOVS T1,ACCUM
	CAIE T1,'ALL'
	CAIN T1,'AL '
	JRST ALLDRV
	CAIE T1,'A  '
	JRST BADDRV	;NOT ALL, NO OTHER ID IS GOOD
ALLDRV:	JSR DRVDSP	;CO-ROUTINE RETURN
	HLRZ U,SYSUNI
	JUMPE U,CPOPJ	;RETURN
CHKDRA:	SKIPGE UNISTS(U)
	JRST NXTDRA	;TRY NEXT
	MOVEM U,DRVSAV	;SAVE INFORMATION
	AOS (P)
	JSR DRVDSP
	MOVE U,DRVSAV
NXTDRA:	HLRZ U,UNISYS(U)
	JUMPN U,CHKDRA	;CHECK FOR ON LINE
	POPJ P,

DRVDSP:	0
	POPJ P,
;Read a drive number
DRVNUM:	PUSHJ P,DRVSRC
	 JRST NXDRV	;THAT DRIVE DOES NOT EXIST
	 JRST MLTDRV	;DRIVE IS MULTIPLY USED
	MOVEM U,DRVTAB(T4)
	PUSHJ P,SCAN
	XCT RDVTB2(T1)
	JRST BADDRV
	PUSHJ P,SCAN
	CAIE T1,1
	 JRST BADDRV	;MUST BE NUMBER
	AOBJN T4,DRVNUM
	OASC [ASCIZ /
TOO MANY DRIVES, RETYPE/]
	JRST REDDRV

RDVTB2:	JRST BADDRV
	JRST BADDRV
	AOJA T4,GODRV	;ADD 1 TO COUNT TO MAKE AOBJN PNTR
	CAIE CH,","	;MUST BE A SPECIAL CHR THAT IS ,

GODRV:	MOVNS T4
	HRLZM T4,DRVSAV
GODRV1:	JSR DRVDSP
	SKIPL T4,DRVSAV
	POPJ P,		;RAN OUT OF DRIVES
	AOS (P)
	MOVE U,DRVTAB(T4)
	AOBJN T4,.+1
	MOVEM T4,DRVSAV
	JRST GODRV1

NXDRV:	OASC [ASCIZ /
DRIVE /]
	OOCT ACCUM
	OASC [ASCIZ / IS OFF-LINE OR DOES NOT EXIST/]
	JRST BADDRV

MLTDRV:	OASC [ASCIZ /
DRIVE /]
	OOCT ACCUM
	OASC [ASCIZ / IS SPECIFIED MORE THAN ONCE/]
	JRST BADDRV
;SEARCH DRIVES FOR THE NUMBER GIVEN. NUMBER IS IN ACCUM
;CALL PUSHJ P,DRVSRC
;	NO SUCH DIRVE
;	DRIVE ALREADY IN DRIVE LIST
;     OK

DRVSRC:	HLRZ U,SYSUNI
	MOVE T1,ACCUM
DRVSR1:	SKIPL UNISTS(U)	;NOT UNIT OFF-LINE
	CAME T1,UNINUM(U)
	JRST DRVSR2	;OFF-LINE OR WRONG NUMBER, TRY NEXT
	AOS (P)		;FOUND CORRECT DIRVE AND ITS ON-LINE
	TRNN T4,-1
	JRST CPOPJ1	;NOTHING IN LIST, TAKE GOOD RETURN
	MOVN T1,T4
	HRLZS T1
DRVSR3:	CAMN U,DRVTAB(T1)	;DOES IT MATCH?
	POPJ P,		;YES, MULTIPLE USE ERROR
	AOBJN T1,DRVSR3
	JRST CPOPJ1	;TAKE GOOD RETURN

DRVSR2:	HLRZ U,UNISYS(U)	;NEXT DRIVE
	JUMPN U,DRVSR1
	POPJ P,		;OUT OF DRIVES, NX RETURN

ONEUNT:	OASC [ASCIZ /
DRIVE: /]
ONEUN1:	PUSHJ P,REDLIN
	PUSHJ P,SCAN
	CAIE T1,1
	 JRST ONENXD
	MOVEI T4,0
	PUSHJ P,DRVSRC
	 JRST ONENXD	;NO DRIVE
	 JRST ONENXD	;SHOULD NEVER GET HERE
	POPJ P,

ONENXD:	OASC [ASCIZ /
BAD DRIVE NUMBER, RETYPE/]
	JRST ONEUNT
SUBTTL	Device interrupt handlers

;HERE WHEN WE HAVE FOUND THE CORRECT SA-10, S SET UP

SAXCOD:	XCT SAXCNI(S)
	TRNE T2,1B19!1B20
	JRST SAXMEM	;MEMORY PROBLEM
	ANDI T2,170	;GET THE STATUS FLAGS
	JFFO T2,.+2	;FIND ONE ONE
	JRST SAXDIE	;LOSE BIG
	SUBI T3,^D29	;NOW T3 IS THE CHANNEL NUMBER
	MOVEI T1,SAXCHN(S)
	ADD T1,T3	;NOW WE HAVE APOINTER TO THE CHANNEL
	SKIPN C,(T1)
	JRST SAXDIS	;UNKNOWN CHANNEL, DISMISS INTERUPT
	HRRZ K,CHNKON(C)	;GET A POINTER TO THE FIRST CHANNEL
	LDB T1,[POINT 8,@CHNSTS(C),23]	;GET THE UNIT
KONSRC:	HRRZ T2,KONRNG(K)
	CAML T1,T2	;IS IT BELOW TOP
	JRST NXTKON	;NO, TRY ANOTHER KONTROLER
	HLRZ T2,KONRNG(K)
	CAML T1,T2	;IS IT GREATER OR = TO BOTTOM
	JRST KONFND	;HAVE CORRECT CONTROLER, GET UNIT
NXTKON:	HRRZ K,KONKON(K)
	JUMPN K,KONSRC	;SEARCH FOR CORRECT KONTROLER
SAXDIS:	LSH T3,3	;SET UP CHANNEL NUMBER
	MOVEI T2,6B29+4
	IOR T2,T3
	XCT SAXCNO(S)
	POPJ P,		;DISMIS INTERUPT

SAXMEM:	MOVEI T1,[ASCIZ /
PARITY ERROR AT LOCATION /]
	TRNE T2,1B19
	 MOVEI T1,[ASCIZ /
NXM AT LOACTION /]
	OASC (T1)
	MOVEI T2,1B32
	XCT SAXCNO(S)
	XCT SAXDTI(S)
	OOCT T2
RSTBEL:	OASC[ASCIZ /
TYPE ANY CHARACTER TO RESTART
/]
	TLNE	F,KL10
	JRST	BELLKL
	CONO TTY,1B26
BELIT:	MOVEI T1,^D300
BELL1:	CONSZ TTY,40
	JRST RESTRT	;SEEN A CHARACTER, RESTART
	CONSO APR,APRCLK
	JRST BELL1
	CONO APR,APRCLK
	SOJG T1,BELL1
	OCHI 7
	JRST BELIT

BELLKL:	SETZM	DTEMTD		;CLEAR CHAR WAITING IF ANY
	MOVEI	T1,^D5*^D60	;RING EVERY5 SECONDS
	PUSHJ	P,KLBLWT
	SETZM	DTEMTI
	JRST	RESTRT
SAXDIE:	OASC [ASCIZ /
UNDEFINED SA-10 INTERUPT CONDITION/]
	JRST RSTBEL

CHINT:	0
	JRST SA0INT	;START SA-10

CHNSAV:	0		;JSR HERE TO SAVE AC'S AND SET PDL
	MOVEM 17,CHNACS+17
	MOVEI 17,CHNACS
	BLT 17,CHNACS+16
	MOVEI P,CHNPDL-1
	PUSHJ P,@CHNSAV
	MOVSI 17,CHNACS
	BLT 17,17
RETCHL:	JEN @CHINT	;DISMIS INTERUPT

CHNDIE:	OASC [ASCIZ /
UNDEFINED INTERUPT ON CHANNEL/]
	JRST RSTBEL
INTNM(\%SAX)==CHNDIE
ANYERR==SELERR+BUSERR+CONERR+LENERR+PIFERR+ATTEN+CUEND+BUSY+UCHK+UXCP
;SET FOR ANY ERROR CONDITION

KONFND:	MOVE T1,@CHNSTS(C)
	LDB U,[POINT 8,T1,23]	;GET UNIT
	HLRZ T2,KONRNG(K)	;AND BASE OF UNIT RANGE
	SUB U,T2
	ADDI U,KONTAB(K)
	SKIPN U,(U)	;GET POINTER TO THE UNIT
	 JRST [TLNE T1,CUEND	;IF CONTROL UNIT END ON,
	        JRST KONEND	;WE DON'T EXPECT VALID DEVICE ADDRESS, GO RESTART EVERYONE
	       JRST UNTDIS]	;NO UNIT, JUST DISMISS.
	TLNE T1,ANYERR
	 JRST KONERR	;FOUND AN ERROR CONDITION (MAYBE)
UNTFIN:	MOVEI T1,1
	SKIPGE UNIIOW(U)
	 MOVEM T1,UNIIOW(U)	;SET IOW IF WAITING
	SKIPE KONRST(K)	;DOES IT NEED RESTARTING?
	JRST KONEND	;YES, PRETEND KONTROL UNIT END
UNTDIS:	XCT CHNCLR(C)	;CLEAR STATUS FLAG
	XCT CHNGO(C)	;AND RESTART IN CASE WE MISSED A GO
	POPJ P,

KONERR:	TLNE T1,UCHK
	 JRST RDSTS	;NEED TO READ STATUS ON UNIT CHECK
	TLNE T1,BUSY
	 JRST CHKBSY	;MAY BE CONTROL UNIT BUSY ETC
	TLNE T1,CUEND
	 JRST KONEND	;CONTROL UNIT END, RESTART WAITERS
KONER1:	MOVEM T1,UNIERF(U)
	JRST UNTFIN	;SET TERMINATED FLAG

CHKBSY:	TLNN T1,STSMOD
	 JRST DEVBSY	;A DEVICE BUSY
CUBSY2:	MOVSI T2,(1B0)
	HLRZ T3,KONRNG(K)	;GET LOW NUMBER
	SUB T3,UNINUM(U)	;SUBTRACT UNIT NUMBER (GIVES - OFFSET)
	LSH T2,(T3)
	IORM T2,KONBSU(K)	;SET RESTART FLAG
	TLNN T1,CUEND	;IS CUEND ALSO ON?
	 JRST UNTDIS	;JUST DISMISS
KONEND:	SKIPN T2,KONBSU(K)
	 JRST [HRRZ K,KONKON(K)	;Interrupt not really for this kontroller
	       JUMPE K,UNTDIS	;Check next KON if there is one
	       JRST KONEND]	;CUEND says 300 even for 340-377 on 3674
	MOVEI T4,KONTAB(K)
	SETZM KONBSU(K)	;WE WILL RESTART ALL OF THESE
	SETZM KONRST(K)	;NOW RESTARTED
KONEN2:	JFFO T2,.+2	;LOOK FOR NEXT
	 JRST UNTDIS	;FINISHED, DISMISS INTERRUPT
	LSH T2,1(T3)
	ADD T4,T3
	SKIPN U,(T4)	;SEE IF A UNIT THERE
	 AOJA T4,KONEN2	;SEE IF MORE UNITS TO RESTART
	MOVE T1,UNIRST(U)
	MOVEM T1,@UNIBMX(U)	;SET RESTART
	AOJA T4,KONEN2	;AND CONTINUE
;Busy device
DEVBSY:	TLNN T1,CUEND!DEVEND
	JRST KONER1
	TLNE T1,CUEND	;IF REALLY CONTROL UNIT END
	SETOM KONRST(K)	;THEN NEED TO RESTART LATER
	JRST RDSTS1

RDSTS:	MOVEM T1,UNIERF(U)	;SET ERROR FLAG
	MOVE T1,CHNSTS(C)
	MOVE T1,1(T1)
	MOVEM T1,UNICNT(U)	;SAVE THE ADDRESSPOINTER
RDSTS1:	MOVEI T1,UNIRDS(U)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,T1,7]	;SET UP A START FOR READ STS
	TLO T1,(15B11)
	MOVEM T1,UNIRST(U)
	MOVEM T1,@UNIBMX(U)
	JRST UNTDIS

;FIND CYL,HEAD, REC OF ERROR

FNDERR:	MOVE T1,UNICNT(U)
CYLSRC:	SKIPGE -1(T1)
	SOJA T1,CYLSRC	;NEGATIVE WORDS ARE HALTS AND TRANSFERS
	LDB T2,[POINT 8,-1(T1),15]
	CAIE T2,SEEK
	CAIN T2,SRCIDE	;BACK UP TO SEEK OR SEARCHID
	SKIPA
	SOJA T1,CYLSRC
	HRRZ T1,(T1)	;GET DATA ADDRESS
	LDB CYL,[POINT 16,(T1),31]
	LDB HEAD,[POINT 16,1(T1),15]
	LDB REC,[POINT 8,1(T1),23]
	DPB CYL,UNYCYL		;Remember it in case called via UNIGOC
	DPB HEAD,UNYHED
	DPB REC,UNYREC
	POPJ P,

UNYREC:	POINT 8,UNIERR(U),35
UNYHED:	POINT 8,UNIERR(U),27
UNYCYL:	POINT 16,UNIERR(U),19
;;;	POINT 4,UNIERR(U),3	;Unused
;I/O error detected, T3 has retry count
COMERR:	MOVE T1,UNIERF(U)
	TLNN T1,UCHK
	 JRST SAXERR	;SA-10 DETECTED ERROR
	HLLZ T1,UNISNS(U)
	TLZ T1,3	;GET RID OF EXTRA 2 BITS
	JFFO T1,.+2
	  POPJ P,		;MUST BE ENVIRON DATA, RETRY
	MOVE T1,ERRTB1(T2)	;GET INFORMATION ON ERROR TYPE
	JUMPL T1,(T1)	;NEEDS DISPATCH
ERRREN:	SKIPGE T3	;CHECK ON RETRY COUNTER
	 HLRZ T3,T1	;GET RETRY NEW COUNT
	SOJGE T3,CPOPJ	;STILL SOME RETRY TO GO
	JRST CPOPJ1	;TAKE NON-RECOVERY RETURN

;COMERP - Set CYL,HEAD,REC and output error message in T1

COMERP:	JUMPE T1,CPOPJ	;NO ERROR MESSAGE
	PUSH P,T1
	PUSHJ P,FNDERR	;Set up CYL,HEAD,REC
	OASC [ASCIZ /

UNRECOVERABLE ERROR ON UNIT #U, CYLINDER #C, HEAD #H, RECORD #R
/]
	POP P,T1
	OASC (T1)
	OASC [ASCIZ /
/]
	POPJ P,

;This table of 16 bits from the SA10 match the first 2 sense bytes

ERRTB1:	-1,,CMDRJC			;00 COMMAND REJECT POSSIBLE WRITE PROTECT
	-1,,OFLIN			;01 UNIT OFF LINE
	1,,[ASCIZ /BUS OUT PARITY ERROR/];02 (RETRY ONCE)
	-1,,EQCHK			;03 EQUIPMENT CHECK
	-1,,DTACHK			;04 DATA CHECK
	0,,[ASCIZ /OVERRUN/]		;05 (CHANNEL TOO SLOW)
	0,,[ASCIZ /ERROR BYTE 0 BIT 6/]	;06 (TRACK CONDITION CHECK ON 3640)
	0,,[ASCIZ /ERROR BYTE 0 BIT 7/]	;07 (SEEK CHECK ON 3640)
	0,,[ASCIZ /PERMANENT ERROR/]	;08 (RETRIES FAILED)
	0,,[ASCIZ /INVALID TRACK FORMAT/];09 (COUNT/KEY/DATA MESSED UP)
	0,,[ASCIZ /END OF CYLINDER/]	;10 (ON MULTI-TRACK READ)
	0,,[ASCIZ /ERROR BYTE 1 BIT 3/]	;11 (NOT USED ON 3674)
	0,,[ASCIZ /NO RECORD FOUND/]	;12 (SEARCH ID= FAILED)
	0,,[ASCIZ /FILE MASK PROTECTION/];13 (ILLEGAL WRITE)
	0,,[ASCIZ /WRITE INHIBITED/]	;14 (COMMAND REJECT IS ALSO ON)
	0,,[ASCIZ /OPERATION INCOMPLETE/];15
SUBTTL	DTACHK - Error in data field
DTACHK:	MOVSI T1,(1B17)
	TDNN T1,UNISNS(U)
	JRST DTANRC	;UNRECOVERABLE DATA CHECK
	PUSH P,T2
	PUSH P,T4
	LDB T1,[POINT 16,UNISNS+4(U),15]	;GET RECORD BYTE SIZE
	LDB T2,[POINT 8,UNISNS+3(U),31]
	DPB T2,[POINT 8,T1,19]
	LDB T2,[POINT 16,UNISNS+4(U),31]	;NO OFFSET FROM END OF REC
	SUB T1,T2	;COMPUT OFFSET FROM START OF REC
	MOVE T2,UNICNT(U)
	LDB T4,[POINT 8,-2(T2),7]	;THIS SHOULD BE THE COMMAND
	MOVE T2,-1(T2)	;THIS IS THE TRANSFER WORD
	LDB T3,[POINT 12,T2,11]	;SIZE
	TRO T3,770000
	HRLM T3,T2	;MAKE IT INTO AN AOBJN POINTER
	TRNE T4,TRBYTE	;IS IT BYTE MODE?
	JRST BYTDTC	;YES, HANDLE DIFFERENTLY
	PUSH P,T2
	LSH T1,3	;CONVERT BYTES TO BITS
	IDIVI T1,^D36	;AND FORM A WORD POINTER
	HRLS T1
	ADDM T1,(P)	;ADD TO THE AOBJN POINTER FOR THE DATA
	POP P,T1
	JUMPGE T1,CDTRRD	;ERROR OUTSIDE DATA AREA, IGNORE
	LDB T3,[POINT 24,UNISNS+5(U),23]
	LSH T3,^D12	;THE CORRECTION SYNDROME
	MOVEI T4,0
	MOVNS T2
	LSHC T3,(T2)	;NOW HAVE BITS CORRECTLY POSITIONED
GORCV1:	XORM T3,(T1)	;FIRST WORD GET FIXED
	AOBJP T1,CDTRRD	;STILL IN DATA AREA?
	XORM T4,(T1)	;YES, FIX UP SECOND WORD
CDTRRD:	HRRZ T2,UNICNT(U)
	HRLI T2,TIC
	HLRZ T1,CMD
	MOVEM T2,(T1)	;START COMMAND CHAIN WITH A TIC
	POP P,T4
	POP P,T2
	MOVNI T3,1	;RESET ERROR COUNT TO NONE
	POPJ P,		;TAKE RECOVERABLE ERROR RETURN

DTANRC:	MOVEI T1,[ASCIZ /DATA CHECK
/]
	JRST ERRREN

BYTDTC:	HLRO T3,T2	;GET BYTE COUNT
	ASH T3,-2	;CONVERT TO WORDS (4 BYTES /WORD)
	HRLM T3,T2
	PUSH P,T2
	IDIVI T1,4
	HRLS T1		;MAKE SURE TO ADD TO BOTH AHLVES
	ADDM T1,(P)	;T1 HAS WORD OFFSET, T2 BYTE
	POP P,T1
	JUMPGE T1,CDTRRD	;NOTHING TO CORRECT
	LDB T3,[POINT 24,UNISNS+5(U),23]
	LSH T3,^D8	;DO NOT SHIFT FOR EXTRA 4 BITS ON RIGHT
	MOVEI T4,0
	LSH T2,3	;CONVERT BYTES TO BITS
	MOVNS T2
	LSHC T3,(T2)	;SHIFT
	LSH T3,4	;AND REPOSITION T3 (4 EXTRA BITS ON RIGHT
	JRST GORCV1
;Off-line

OFLIN:	SETOM UNISTS(U)	;SET UNIT OFF-LINE
	OASC [ASCIZ /

UNIT #U	 HAS GONE OFF-LINE

/]
	MOVEI T1,0
	JRST CPOPJ1	;NON-RECOVERABLE WITH NO ERR

;Command reject

CMDRJC:	MOVE T1,UNISNS(U)
	TLNE T1,(BYTE (8) 0,2)
	 JRST UNIWPT	;UNIT IS WRITE PROTECTED
	MOVEI T1,[ASCIZ /COMMAND REJECT/]
	JRST ERRREN	;AND GIVE ERROR

UNIWPT:	MOVSI T1,NOWRT
	IORM T1,UNISTS(U)	;SET FLAG
	MOVEI T1,[ASCIZ /UNIT IS WRITE PROTECTED/]
	JRST ERRREN

;Equipment check

EQCHK:	MOVE	T1,UNISNS(U)
	TLNN	T1,(BYTE (8) 0,200)	;Check bit 0 of byte 1
	 JRST	EQCHK1
	MOVEI	T1,[ASCIZ /PERMANENT EQUIPMENT CHECK/]
	JRST	ERRREN

EQCHK1:	LDB	T1,[POINT 4,UNISNS+1(U),31] ;Get last nibble of byte 7
	MOVE	T1,EQCHK2(T1)		;Get message and retry count
	JRST	ERRREN

EQCHK2:	^D10,,[ASCIZ /EQUIPMENT CHECK - (NO MESSAGE)/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - TRANSMIT TARGET ERROR/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - MICRO DETECTED/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - TRANSMIT HIGH DIFFERENCE/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - SYNC OUT TIMING ERROR/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - INITIAL DRIVE STATUS/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - TRANSMIT CYLINDER ADDRESS/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - TRANSMIT HEAD ADDRESS/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - TRANSMIT LOW DIFFERENCE/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - NONRETRY DRIVE STATUS/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - SEEK ERROR/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - RETRY SEEK INCOMPLETE/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - NO INTERRUPT FROM DRIVE/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - SKIP DEFECT REORIENTATION/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - UNKNOWN DEVICE TYPE/]
	^D10,,[ASCIZ /EQUIPMENT CHECK - RETRY REORIENTATION/]



SAXERR:	HLLZ T3,UNIERF(U)
	TLZ T3,3
	MOVEI T1,0	;NO MSG YET
	MOVEI T2,0
SAXER1:	JFFO T3,.+2
	JRST CPOPJ1	;RAN OUT OF BITS
	LSH T3,1(T4)	;GET RID OF BITS SCANNED
	ADD T2,T4	;FIND BIT NUMBER
	SKIPE T1,SAERTB(T2)	;IS THIS AN ERROR BIT?
	JRST CPOPJ1	;YES, TAKE FIRST
	AOJA T2,SAXER1	;ELSE CONTINUE

SAERTB:	0		;Bits 0 and 1 have type of status
	0		;	"	"
	[ASCIZ /SELECT ERROR /]
	[ASCIZ /BUS IN PARITY ERROR /]
	[ASCIZ /CONTROL ERROR /]
	0		;Always zero
	[ASCIZ /LENGTH ERROR /]
	[ASCIZ /INTERUPT ERROR /]
	[ASCIZ /ATTENTION /]
	0		;Status modifier
	0		;Control-unit end
	[ASCIZ /BUSY /]
	0		;Channel end
	0		;Device end
	0		;Unit check
	[ASCIZ /UNIT EXCEPTION /]
SUBTTL	Data area

PDL:	BLOCK 40
MEMSIZ:	0
MEMLOW:	0	;FIRST WORD OF MEMORY TO USE
MEMFRE:	0	;FIRST FREE WORD OF MEMORY
SYSUNI:	%.D0,,0	;POINTER TO FIRST UNIT DATA BLOCK
DEVWAT:	0	;NUMBER OF WAITING UNITS
SAVAC:	BLOCK 20	;PALCE TO SAVE AC'S
TTYFIL:	0
SEK0AD:	BYTE (8) BYTMOD,SEEK
	BYTE (12) -6 (24) SEKAD0	;GENERATE COMMAND FOR A SEEK
	BYTE (8) ENDCMD
SEKAD0:	BYTE (16) 0,0,0		;CYL=0 HEAD=0

CHNACS:	BLOCK 20
CHNPDL:	BLOCK 40

RQZRO:	BYTE (8) TRWORD+NOMEMT+XCTCMD,0,0
	BYTE (8) 0		;AND A HALT

WRTQ0:	BYTE (8) BYTMOD,SRCIDE
	BYTE (12) -5 (24) ADR377
	TIC,,WRTQ0
	BYTE (8) BYTMOD!IGNLEN,WRT33
	BYTE (12) -1 (24) BLANK
	BYTE (8) ENDCMD

REDQ0:	BYTE (8) BYTMOD,SRCIDE
	BYTE (12) -5 (24) ADR377
	TIC,,REDQ0
	BYTE (8) BYTMOD!IGNLEN,RED33
	BYTE (12) -1 (24) BLANK
	BYTE (8) ENDCMD

ADR377:	BYTE (16) 0,0 (8) XTRREC
BLANK:	0

SEK500:	BYTE (8) BYTMOD,SEEK
	BYTE (12) -6 (24) SK5ADR
	BYTE (8) ENDCMD

SK5ADR:	BYTE (16) 0,^D500,0
BELFLG:	0	;FLAG TO RING BELL
ACCUM:	0	;RESULTS OF SCAN STORED HERE
SAVCHR:	0	;SAVE INPUT CHRACTER ON SCAN
SCNPTR:	0	;SCAN POINTER FOR SCAN
INPBUF:	BLOCK <^D100+1+4>/5
SPCLNK:	0
DRVSAV:	0	;SAVE WORD OF INFORMATION FOR NEXT DRIVE ROUTINE
DRVTAB:	BLOCK 20	;MAX NUMBER OF DRIVES IN A LIST
	DRVLEN==.-DRVTAB
SUBTTL	LITerals

RADIX:	10	;FOR INPUT CONVERSION
MONTH:	0
DAY:	0
THSDAT:	0

CTOFLG:	0
RUBFLG:	0
ABTDSP:	0
DOFLG:	0
CLRNXM:	0
NXMFLG:	0

LITS::	LIT
	VAR
	RELOC	.-140
SUBTTL	End of PAKCOP

	;This word is zero if DDT is not loaded.  If DDT is loaded, you can
	;get here by starting PAKCOP at location 1001 instead of 1000.
DDT::	;Use "LOAD %S PAKCOP.MAC/COMPILE, %W EDDT.REL" to put DDT here



	END	START

  l x