TITLE SCNSER - TYMNET VERSION OF SCNSER

	STOPCD(,ENTRY,SCNSER)

	SCNVER==1	;Version number reported to the base
	SCNREL==0	;Release number reported to the base

;THE 620 AND PDP-10 SHARE CORE AS A MEANS OF COMMUNICATION.
;THE 620 PUTS THINGS DESTINED FOR THE PDP-10 INTO A RING
;BUFFER AND VICE VERSA. THE PDP-10 EXAMINES THE STATE OF THE
;RING BUFFER EVERY CLOCK TICK. FOR OUTPUT, THE PDP-10 NEVER
;PUTS OUT MORE THAN 30 (=%CHRMX) CHARACTERS ON A GIVEN LINE
;WITHOUT CHECKING THE INPUT RINGS IN CASE THE 620 REQUESTS
;THE PDP-10 TO STOP DOING OUTPUT ON THAT LINE.

;NOTE VERY CAREFULLY THAT THESE ROUTINES DEPEND ON THE FACT THAT
;CLOCK LEVEL NEVER INTERRUPTS UUO LEVEL AND VICE VERSA.
;FOR THIS REASON THERE ARE NO INTERLOCKS BETWEEN THE TWO
;LEVELS. ANYONE WHO CHANGES THIS BEWARE!!!!!!!!!!

SUBTTL	TABLE OF CONTENTS
		;Insert table of contents here
SUBTTL	DEFINITIONS

AUXSTM==:^D29		;MAX NUMBER OF CHRS ALLOWED IN AUX STRING
AUXSTL==1+<<AUXSTM+6>/5>;SIZE OF AUX STRING STORAGE BLOCK

STDALT==33		;STANDARD ALTMODE

TTCHKS==4		;SIZE OF TELETYPE BUFFERLETS
TT2CHK==TTCHKS*2

IMGDIM==2		;TIME TO WAIT IN IMAGE AFTER FIRST CHR
IMGTIM==^D10		;TIME TO WAIT IN IMAGE MODE FOR FIRST CHR
TIRSVD==3		;Number of chunks reserved for emergencies
TIWKC==^D72		;# of input chars to wake job (72 or 132)
IFG TIWKC-^D72,<PRINTX Setting TIWKC above 72 causes PTY backpressure problems
		TIWKC==^D72>
TILOW==TIWKC+^D8	;# of unread input chars to trigger backpressure
			;(TIWRNN set to TILOW.  TIHLTN based on IRING size)
OWTIM==^D20		;1/2 OF ORANGE-BALL-WAIT TIMEOUT ON ZAP
			;(SEE TTYZAP)

CTY==120		;FOR SPECIAL TYPOUT ON PARITY ERR

%CHRMX==^D30		;MAX NUMBER OF CHRS TO OUTPUT ON LINE WITHOUT
			;RETURNING TO INPUT RING CODE (THE EFFECT IS
			;THAT %CHRMX IS THE NUMBER OF CHARACTERS OF
			;"DELAY" IN GETTING BACKPRESSURE APPLIED
			;TO THE LINE)  Should be <4*N>-2 for efficiency

%PBTIM==^D15		;PTY BLOCK INPUT TIMEOUT

;CONDITIONAL ASSEMBLY FLAGS

YLBUG==0		;1 IF BASE TURNS ALL ORANGE BALLS INTO YELLOW
OPCRET==1		;1 IF PROGRAMS THINK TTCALLS IGNORE IMAGE

SUBTTL	THE EXTERNALS FOR SCNSER

;FROM COMMON
EXTERNAL BITNTB,LINFLG,NMXFLG,ALR620,JBTABT,JBTUNM,JBTUN1
EXTERNAL JBTCIN,JBTCOT,JBTBCS,JBTLIC,JBTAWQ,JBTBET,JBTBIO
EXTERNAL IRING,ORING,ORPPDP,IRPPDP,ORP620,IRP620,MSKIRG,MSKORG
EXTERNAL JOBN,HIGHJB,CONFIG,QUEPCB

;GENERAL EXTERNALS
EXTERNAL TPOPJ,TPOPJ1,CPOPJ,CPOPJ1,IPOPJ,IPOPJ1
EXTERNAL STTIOD,JBTSTS,LINTAB,JBTPRV
EXTERNAL PJOBN,WSYNC,SETRUN,PEVEN8,JOB,REFLAG
EXTERNAL TTYTAB,PUNIT,STATES,UPTIME,PVYMOD
EXTERNAL DEVOPR,THSDAT,JFYSEC,TIME	;NAME OF OPER CONSOLE
EXTERNAL GET4WD,GIV4WD,BIOCOR

;EXTERNALS USED BY MUUO ROUTINES
EXTERNAL OUT,BUFCLR,ADRERR,ADVBFF,ADVBFE
EXTERNAL GTCGSZ,RELEA6
EXTERNAL CHKSEG,SETIO2

EXTERNAL TTVINI,TTVIN2		;BIT IN LINTAB (LH) TO SAY SHOULD RUN INITIA

;UUOCON ALSO USES TTYFND,LDLCOM,TTYU;STC,TTYFUW
;AND DDBLDB,LDBDCH,LDBDDB

;FOR CLOCK1
EXTERNAL AXAVAL,AXREQ,AXSWT,AXWAIT,MLOWQ,RNQ,WSCHED,CHGCLK
EXTERNAL FCREQ,FCWAIT
EXTERNAL BPAVAL,BPREQ,BPWAIT

;FILSER ALSO USES TTYFUW,TTYSTR

;PICON
EXTERNAL ABTUUO,TAKTRJ,TAKNZJ,TAKOTJ,TSTKTJ,TSTKTP,TSTTRJ,JBTPIP,TAKTRP
SUBTTL	TERMINAL CHARACTERISTICS DEFINITIONS

;TERMINAL CHARACTERISTICS

DEFINE TCHARS <;;Define TCNxxx, also expanded at TCNDSP and TCVMAX
Z(CRD,1,TYMTC,TMCCRD)
Z(IR,17,TYMTC,TMCIR)
Z(OR,17,TYMTC,TMCOR)
Z(PAR,1,TYMTC,TMCPAR)
Z(HDX,1,TYMTC,TMCHDX)
Z(PA,7,TYMTC,TMCPA)
Z(PB,7,TYMTC,TMCPB)
Z(PC,17,TYMTC,TMCPC)
Z(XON,1,TYMTC,TMCXON)
Z(ECH,1,TYMTC,TMCECH)
Z(RXE,1,TYMTC,TMCRXE)
Z(PD,17,TYMTC,TMCPD)	;PARM D, was TCNTYP/TMCTYP
Z(NXO,1,BYTTC,LDPNXO)
Z(WID,377,ACWIDC,0)
Z(FC1,3,BYTTC,LDPFC1)
Z(FC2,3,BYTTC,LDPFC2)
Z(BSP,1,ACBSPC,0)
Z(ERA,1,ACERAC,0)
Z(DEF,1,ACDEFC,0)
Z(LCO,1,BYTTC,LDPLCO)
Z(TAB,1,BYTTC,LDPTAB)
Z(FRM,1,BYTTC,LDPFRM)
Z(LCT,1,BYTTC,LDPLCT)
Z(NFC,1,BYTTC,LDPNFC)
Z(PTP,1,ACPTPC,0)
Z(BSD,1,BYTTC,LDPBSD)
Z(CLA,377777777777,ACTCLA,0)	;Class (was TMCTTP)
Z(RTC,1,BYTTC,LDPRTC)
Z(KAT,1,TYMTC,TMCKAT)		;KATAKANA (Japanese modes), was TMCTYP
Z(TYP,377777777777,ACTTYP,0)
>  ;Max of 36 fields, so that TYMNET or PTY can be notified

ZZN==0
DEFINE Z(NAME,MAXVAL,TYPE,ARG) = <
	TCN'NAME==ZZN
	ZZN==ZZN+1
>
TCHARS
TCNN==ZZN
IFG <TCNN-^D36>,<
	PRINTX MORE THAN 36 TYMCOM-X TERMINAL CHARACTERISTICS
	QQQQQQ
>
TCBALL:	<-1 _ <^D36-TCNN>>
SUBTTL TYMNET TERMINAL CHARACTERISTICS

;DEFINE NAMES AND FIELD WIDTHS

DEFINE TERCHR <;;Terminal characteristics that TYMNET-II responds to
TC(ECO,1)	; 0. ECHO
TC(CIE,1)	; 1. ECHO CONTROL-I
TC(ELF,1)	; 2. ECHO LF AS LF/CR/DELAY
TC(ECR,1)	; 3. ECHO CR AS CR/LF
TC(CRD,1)	; 4. CR DELAY
TC(IR,4)	; 5. INPUT BAUD RATE CODE
TC(OR,4)	; 6. OUTPUT BAUD RATE CODE
TC(PAR,1)	; 7. PARITY (EVEN OR NONE)
TC(HDX,1)	; 8. HALF DUPLEX
TC(PA,3)	; 9. PARAMETER A
TC(PB,3)	;10. PARAMETER B
TC(PC,4)	;11. PARAMETER C
TC(XON,1)	;12. X-ENABLE FOR REMOTE
TC(ECH,1)	;13. ECHO CONTROL-H
TC(RXE,1)	;14. REVERSE X-ENABLE
TC(PD,4)	;15. PARAMETER D to ISIS (TMCPD was TMCTYP)
TC(KAT,1)	;16. KATAKANA MODE (See comments at TYMTC2)
TC(TOB,1)	;17. TERMINATE OUTPUT ON BREAK
TC(ESC,1)	;18. ECHO ESCAPE
TC(QM,1)	;19. Q-MODE (echo } and ~, they are not ALTMODEs)
TC(SPA,1)	;20. SPACE PARITY  (not in EBUS02.J01!!)
>

;DEFINE TERMINAL CHARACTERISTICS CODES

ZZN==0
DEFINE TC(N,Z)  <TMC'N==ZZN
ZZN==ZZN+1>
TERCHR

TMCALL==77	;PROBE CODE TO GET ALL TERMINAL CHARACTERISTICS
SUBTTL	DEFINE RECEIVED CHARACTERISTICS BYTE POINTERS

ZZWORD==0
ZZPOS==-1
DEFINE TC(N,W) <IFG <ZZPOS+W>-^D35,<ZZPOS==-1
ZZWORD==ZZWORD+1>
ZZPOS==ZZPOS+W
LDP'N:	POINT W,LDBTMR+ZZWORD(U),ZZPOS>

TABTMR:	TERCHR
SUBTTL	DEFINE SENT CHARACTERISTICS BYTE POINTERS

ZZWORD==0
ZZPOS==-1
DEFINE TC(N,W) <IFG <ZZPOS+W>-^D35,<ZZPOS==-1
ZZWORD==ZZWORD+1>
ZZPOS==ZZPOS+W
LDS'N:	POINT W,LDBTMS+ZZWORD(U),ZZPOS>

TABTMS:	TERCHR
INTERN LDSRXE	;CTYSIM needs this pointer

MAXTMC==.-TABTMS-1
TMCSLP==^D21	;IF MAXTMC .lt. TMC .ge. MAXTMC+TMCSLP, WE WILL
		;IGNORE TYMNET MESSAGES FOR THE <TMC> RATHER
		;THAN CRASHING (THIS LETS TYMNET GET AHEAD OF US)
TMCSIZ==ZZWORD+1
IFG MAXTMC-^D35,<PRINTX MORE THAN 36 TERMINAL CHARACTERISTICS
QQQQQQ>
SUBTTL OUTPUT REQUEST BITS

;WHEN A PORT WANTS SOMETHING SENT TO TYMNET, IT SETS ONE OF
;THESE BITS IN ITS LDBOUT WORD. MESSAGES CORRESPONDING TO
;HIGH-ORDER BITS ARE SENT FIRST.

DEFINE OUTBIT, <
ZZZ(HSH)	;HUSH - SUPRESS MESSAGES FROM INITIALIZATION ROUTINE
ZZZ(TRO)	;TERMINATE BLOCK OUTPUT
ZZZ(CGB)	;CHARACTER GOBBLER
ZZZ(BIN)	;BLOCK INPUT
ZZZ(TRI)	;TERMINATE BLOCK INPUT
ZZZ(BPN)	;BACKPRESSURE ON
ZZZ(BPF)	;BACKPRESSURE OFF
;-------messages above this line may be output on a backpressured port
ZZZ(BOP)	;BLOCK OUTPUT IN PROGRESS (PTYS ONLY)
ZZZ(SRD)	;RED BALL
ZZZ(SEC)	;ECHO MODE
ZZZ(STP)	;TERMINAL CHARACTERISTICS PROBE
ZZZ(STC)	;SET TERMINAL CHARACTERISTICS
ZZZ(SBL)	;SEND BELL (!)
ZZZ(FIL)	;FILLER CHARACTERS
ZZZ(RUB)	;RUBOUT CHARACTERS
ZZZ(OUT)	;OUTPUT CHARACTERS
ZZZ(BOT)	;BLOCK OUTPUT
ZZZ(SYL)	;YELLOW BALL	(Set by TTYZAP if not a zap from Tymnet)
ZZZ(HNG)	;SOFT ZAP	(Drop DTR to autodial modem, keep circuit)
ZZZ(ZAP)	;HARD ZAP	(Wait for orange ball if host initiated)
ZZZ(ECO)	;ECHO CHARACTERS
ZZZ(SGR)	;GREEN BALL
ZZZ(SOG)	;ORANGE BALL
>

ZZN==0
DEFINE ZZZ(NAME), <
	IFE <ZZN-36>, <
		PRINTX MORE THAN 36 OUTPUT BITS
		QQQQQQ
	>
	LOP'NAME:POINT 1,LDBOUT(U),ZZN
	ZZN==ZZN+1
>
OUTBIT

BPOKBN==LOPBPF-LOPHSH	;BIT# OF LOWEST-PRIORITY MESSAGE
			;THAT CAN BE SENT ON A BACKPRESSURED PORT
NUMECO==LOPECO-LOPHSH	;BIT # OF ECHO
LAPBIT==LOPSOG-LOPHSH   ;LAST LEGAL PRIORITY BIT
SUBTTL LINE DATA BLOCK

;LINTAB:	ONE WORD PER PORT. RH = ADR OF LINE DATA BLOCK
;		LH 13-17 =0 FOR @ LINTAB

;LDBDDB		ONE LINE DATA BLOCK PER PORT. LINK BETWEEN
;		THE LINE DATA BLOCK AND THE TTY DDB IS THE
;		THING MANIPULATED BY ATTACH AND DETACH.

CTYLDB::PHASE	0	;TTY LDB PROTOTYPE
LDICLR:!
LDBDDB::!0	;(RH)	ADDR OF ATTACHED DDB, IF ATTACHED
LDBLIN:! 0	;27-35	Port number (LDPLNO, 9 bits)
		;18-26	9 unused bits
		; 2-17	Origination host number (LDPHST, 16 bits)
		; 1	1 unused bit
LNLZIN==400000	; 0	Zapper received from TYMNET & not echoed yet
LDBOPB:! 0	;BYTE POINTER TO SET NEED-OUTPUT BIT
LDBOUT:! 0	;BITS SPECIFYING WHAT WANTS TO BE OUTPUT
LDBTCB:! 0	;(PTYS) BITS INDICATING CHANGED TERMINAL CHARACTERISTICS

LDBBIO:! 0	;(LH)	BLOCK OUTPUT BUFFER ADDR
		;(RH)	BLOCK INPUT BUFFER ADDR

LDBBKP:! 0	;^U POINTER, RESET TO HERE
LDBBKI:! 0	;(RH)	# INPUT CHARACTERS SINCE LBBBKP
		;(LH)	# BREAK2 CHARACTERS SINCE LDBBKP

LDBTIP:! 0	;INPUT PUTTER
LDBTIT:! 0	;INPUT TAKER
LDBTIC:! 0	;# CHARACTERS IN INPUT BUFFER
LDBECT:! 0	;ECHO TAKER
LDBECC:! 0	;# CHARACTERS IN ECHO BUFFER
LDBBKC:! 0	;(RH)	# BREAK CHARACTERS IN INPUT BUFFER
		;(LH)	# BREAK CHARACTERS IN ECHO BUFFER
LDBBK2:! 0	;(RH)	# BREAK2 CHARACTERS IN INPUT BUFFER
		;(LH)	# BREAK2 CHARACTERS IN ECHO BUFFER

LDBTOP:! 0	;OUTPUT PUTTER
LDBTOT:! 0	;OUTPUT TAKER
LDBTOC:! 0	;# CHARACTERS IN OUTPUT BUFFER

LDBFLP:! 0	;OUTPUT FILLER POINTER (FOR HT/VT/FF PADDING)

LDBRBI:! 0	;RUBOUT ECHO PUTTER
LDBRBO:! 0	;RUBOUT ECHO TAKER
LDBRBC:! 0	;# RUBOUT ECHO CHARACTERS
LDBLOG::!0	;TYMNET login data
		;< 0	logged-in, bits 4-35 hold data from supervisor
		;= 0	not in use
		;> 0	in the process of logging in
LLLZAP==200000	; 1	zapper received or HANG uuo done on port
LLLNLN==100000	; 2	no line, the base has given up on this port
		; 3     unused TYMCOM-X bit
		; 4-11  first byte from needle (bits 4&5 not used by EBUS)
LLLHDX==004000	; 6	terminal is half duplex (32.-63. decimal)
		; 7-11	terminal identifier code (0.-31. decimal)
		;14-19	originating node # (high-order 8 bits)
		;22-27	originating node # (low-order 6 bits) (20&21 unused)
		;29-35	originating port # (obsolete, not valid in ISIS CONSAT)
LDBBYT:! 0	;RANDOM BYTES

L2LOEX==400000	;0	(MUST BE SIGN BIT) OUTPUT SHOULD BE
		;	GIVEN MORE ROOM (TO KEEP FROM TRAPPING
		;	DURING AN OUTSTR)
L2LCCS==200000	;1	SEEN 1 ESCAPE/^C
L2LTBK==100000	;2	(LDPTBK) TABS ARE BREAKS (BREAKSET 2 MODE)
L2LBBP==040000	;3	(LDPBBP) BACKSPACE IS PUNCTATION, NOT A BREAK
L2LNTB==020000	;4	(LDPNTB) DON'T ECHO HT, VT, FF
L2LLDF==010000	;5	JOB WANTS TO LEAVE DEFERRED ECHO MODE
L2LDEL==004000	;6	DELETE IN PROGRESS (I.E., WE HAVE TYPED
		;	A SLASH AND ARE ECHOING DELETED CHARS)
L2LOWS==002000	;7	ONCE-IN-20-SECOND LOGIC HAS FOUND
		;	L2LOWT SET
L2LBSP==001000	;8	(LDPBSP) SEND BACKSPACE FOR CHARACTER-DELETES
L2LOWT==000400	;9	LOGOUT LOGIC HAS SENT A YELLOW BALL AND
		;	IS WAITING FOR AN ORANGE BALL BACK
		;10-11	(LDPMOD) MONITOR MODE
		;12-13	(LDPFC2) FILLER CLASS 2 (HT)
		;14-21	(LDPWID) LINE WIDTH
		;22-23	(LDPFC1) FILLER CLASS 1 (VT FF)
		;24-27	(LDPTIM) IMAGE-INPUT-TIMEOUT TIMER
		;28-35	(LDPPOS) CURRENT LINE POSITION (0-511.)
LDBMOD:! 0	;BYTES TO INDICATE THE MODE LINE IS IN

LMLTBI==400000	;0	TRMI REQUESTED BUT TRMIHR NOT RECEIVED
LMLPSP==200000	;1	1 IF PORT STATUS RECEIVED BUT NOT READ
		;2-5	LAST PORT STATUS MESSAGE RECEIVED (see comment @ ACPSM)
LMLBIO==001000	;8	PORT ENABLED FOR BLOCK I/O
		;9-15	IMAGE COUNT FOR CHARGING
		;16-22	LINE MODE BITS FOR INPUT
		;16-18	ECHO MODE
		;19-22	INPUT MODE
		;23-31	IMAGE MODE BREAK CHARACTER
		;32-35	(UNUSED)
LDBDCH::!0	;DEVICE CHARACTERISTICS

;BITS IN LH

LDLNOP==400000	; *0	TYMNET REQUESTS NO MORE OUTPUT
		;	(MUST BE SIGN BIT)
LDLSOX==200000	;  1	SUPPRESS OUTPUT TRANSLATION
LDLECS==100000	; *2	EAT COMMAND SYNC
LDLPTY==040000	;  3	PSEUDO-TTY
LDLCOM==:20000	;! 4	IN COMMAND MODE
LDLBKA==010000	;! 5	SINGLE CHARACTER ACTIVATES
LDLBK2==004000	;! 6	IN BREAK2 MODE
LDLIMI==002000	;! 7	IN IMAGE MODE
LDLDEF==001000	;!*8	DEFERRED ECHO MODE
LDLOSU==000400	; *9	OUTPUT SUPRESS (^O)
LDLNFC==000200	; *10	NO FREE CRS ON LONG LINES
LDLNEC==000100	; *11	NO ECHO
LDLAUX==000040	; *12	AUX CIRCUIT
LDLLCT==000020	; *13	LOWER CASE TO UPPER CASE
LDLTAB==000010	; *14	TTY DOES TABS
LDLLCP==000004	; *15	LOCAL COPY (2741)
LDLPTP==000002	; *16	IN PAPER TAPE MODE
LDLFRM==000001	; *17	TTY DOES FORMS AND VTABS

;! -- REFERENCED THROUGH LDPMDF TO SET LINE MODE
;* -- GIVEN TO USER IN SAME BIT POSITION BY GETLCH

;BITS IN RH

LDRBPS==400000	;BACKPRESSURE HAS BEEN SENT
LDRXOS==200000	;XOFF HAS BEEN SENT
LDRNXO==100000	;(LDPNXO) DON'T SEND XON/XOFF
LDRDEM==040000	;STAY IN DEFERRED ECHO MODE
LDRFCS==020000	;FULL CHARACTER SET MODE
LDRBIP==010000	;PTY BLOCK INPUT IN PROGRESS
LDBDCX:! 0	;DEVICE CHARACTERISTICS EXTENSION

;BITS IN LH

LXL120==400000	;1 IF FAST LINE, 0 IF SLOW (MUST BE SIGN BIT)
;LXLxx==200000	;(UNUSED 2-6-81)
LXLBSD==100000	;BACKSPACE == RUBOUT/^A (LPDBSD)
LXLERA==040000	;IF L2LBSP SET: SEND <BS><SP><BS> NOT JUST <BS>
		;FOR CHARACTER DELETE (LDPERA)
LXLDLR==020000	;SUPPRESS $ ECHO ON ALTMODES
LXLLCO==010000	;SET FOR CONV OF UPPER TO LOWER CASE ON OUTPUT (LDPLCO)
LXLOOK==004000	;OK TO SEND ORANGE BALL -- SET WHEN A YELLOW BALL
		;ARRIVES THAT THE MONITOR DIDN'T REFLECT (BECAUSE
		;THE USER WAS TRAPPING YELLOW BALLS)
LXLRTC==002000	;[Darren] Half-assed ^R/^T compatibility - says to
		; treat ^T as .USESTAT command if set.

;BITS IN RH -- SET WHEN EVENTS THAT COULD CAUSE INTERRUPTS
;	       HAPPEN TO A PORT FOR LATER POLLING WITH
;	       GETLCH OR THE POLPRT UUO (WHICH CLEAR
;	       THE BITS READ)

LXRESC==400000	;ESCAPE SEEN
LXROBS==200000	;ORANGE BALL SEEN
LXRPSS==100000	;PORT STATUS MESSAGE SEEN (see comment at ACPSM)
LXRICL==040000	;INPUT CHARACTERS LOST
LXROCL==020000	;OUTPUT CHARACTERS LOST
LXRCHR==010000	;CHARACTER SEEN
LXRBRK==004000	;BREAK CONDITION SEEN:
		;1) BREAK CHARACTER READ IN NORMAL STATE
		;2) IMAGE BREAK HAPPENED IN IMAGE STATE
		;3) BREAK2 CHARACTER READ WITH BK2 SET
		;4) BLOCK RECEIVED IN BLOCK INPUT MODE
LXRYBS==002000	;YELLOW BALL SEEN
LXRCGS==001000	;CHARACTER GOBBLER SEEN
LXRIOS==000400	;OUTPUT DONE
LXRTCC==000200	;TERMINAL CHARACTERISTIC CHANGED OR PORT JUST ATTACHED

LDBCLA:! 0	; [dws] Optional sixbit terminal class
LDBTYP==LDBCLA	;[JMS] TYPE same as CLASS for now
LDBSTR::!BLOCK AUXSTL	;SPACE FOR AUX CIRCUIT STRING (LH of CONFIG item 154)
LDBTMR:! BLOCK TMCSIZ	;TERMINAL CHARACTERISTICS RECEIVED
LDBTMS:! BLOCK TMCSIZ	;TERMINAL CHARACTERISTICS TO BE SENT
LDBTMT:! 0		;BIT N=1 TO SEND T.C. N

;LDBTMT BIT DEFINITIONS

ZZN==0
DEFINE TC(N,Z) <LTS'N==1B<ZZN>
ZZN==ZZN+1>
;TTY LDB. THERE IS ONE OF THESE PER PORT.
TERCHR

LDICLE==.-1
DEPHASE
LDBLEN==:.-CTYLDB
SUBTTL	RANDOM LDB BYTE POINTERS

TRMBYP:	POINT  5,LDBLOG(U),11	;Terminal ID code (see also LLLHDX)

LDPLNO::POINT  9,LDBLIN(U),35	;Port number (TTY0 thru TTY777)
LDPHST:	POINT 16,LDBLIN(U),17	;Origination host number (new in EBUS 2.01)

LDPTBK:	POINT 1,LDBBYT(U),2	;TABS-AS-BREAKS
LDPBBP:	POINT 1,LDBBYT(U),3	;BACKSPACE-AS-PUNCTUATION
LDPNTB:	POINT 1,LDBBYT(U),4	;NO SPECIAL TAB HANDLING
LDPBSP:	POINT 1,LDBBYT(U),8	;BS OR ERASE FOR CHAR DELETE
LDPMOD:	POINT 2,LDBBYT(U),11	;MONITOR MODE
LDPFC2:	POINT 2,LDBBYT(U),13	;FILLER CLASS 2
LDPFA2:	POINT 2,LDBBYT(P1),13
LDPWID:	POINT 8,LDBBYT(U),21	;LINE WIDTH
LDPWDA:	POINT 8,LDBBYT(P1),21
LDPFC1:	POINT 2,LDBBYT(U),23	;FILLER CLASS 1
LDPFA1:	POINT 2,LDBBYT(P1),23
LDPTIM:	POINT 4,LDBBYT(U),27	;IMAGE INPUT TIMEOUT TIMER
LDPPOS:	POINT 8,LDBBYT(U),35	;ESTIMATED POSITION ON LINE

LDPPSM:	POINT 4,LDBMOD(U),5	;LAST PORT-STATUS MSG
LDPCHG:	POINT 7,LDBMOD(U),15	;IMAGE COUNT FOR CHARGING
LDPLMD:	POINT 7,LDBMOD(U),22	;ALL THE LINE MODE (INPUT AND ECHO)
LDPMEC:	POINT 3,LDBMOD(U),18	;ECHO LINE MODE
LDPMIN:	POINT 4,LDBMOD(U),22	;INPUT LINE MODE
LDPIMB:	POINT 9,LDBMOD(U),31	;IMAGE MODE BREAK CHARACTER
LDPMOU:	POINT 4,LDBMOD(U),35	;OUTPUT LINE MODE

LDPSOX:	POINT 1,LDBDCH(U),1	;SUPPRESS OUTPUT TRANSLATION
LDPCOM:	POINT 1,LDBDCH(U),4	;COMMAND MODE BIT
LDPMDF:	POINT 5,LDBDCH(U),8	;SOURCE OF LINE MODE INFO
LDPNFC:	POINT 1,LDBDCH(U),10	;NO FREE CRLFS
LDPLCT:	POINT 1,LDBDCH(U),13	;LOWER CASE TRANSLATION (TO UPPER)
LDPTAB:	POINT 1,LDBDCH(U),14	;HARDWARE TABS
LDPPTP:	POINT 1,LDBDCH(U),16	;PAPER TAPE MODE
LDPFRM:	POINT 1,LDBDCH(U),17	;HARDWARE FF/VT
LDPNXO:	POINT 1,LDBDCH(U),20	;DON'T SEND XON/XOFF
LDPDEM:	POINT 1,LDBDCH(U),21	;PERPETUAL DEFERRED ECHO MODE

LDPBSD:	POINT 1,LDBDCX(U),2	;BACKSPACE == RUBOUT/^A
LDPERA:	POINT 1,LDBDCX(U),3	;ERASE ON CHAR DEL
LDPLCO:	POINT 1,LDBDCX(U),5	;LOWER CASE OUTPUT ONLY
LDPRTC:	POINT 1,LDBDCX(U),7	;[Darren] special ^T mode
LDPCLA:	POINT 36,LDBCLA(U),35	;Terminal CLASS
LDPTYP:	POINT 36,LDBTYP(U),35	;Terminal TYPE
SUBTTL DEVICE DATA BLOCK

;TTY DDB INTERRUPT-TO-CHANNEL BYTE POINTERS

ZZWORD==0
ZZBIT==-1
DEFINE ZZZ(N) = <IFG <ZZBIT+6>-^D35,<ZZBIT==-1
ZZWORD==ZZWORD+1>
ZZBIT==ZZBIT+6
DDPT'N:	POINT 6,DDBTRP+ZZWORD(F),ZZBIT>

DDPTAB:

ZZZ(SC)	;ESCAPE/^C RECEIVED
ZZZ(CH)	;CHARACTER RECEIVED
ZZZ(LN)	;BREAK RECEIVED
ZZZ(TI)	;I/O WAIT
ZZZ(TS)	;I/O WAIT SATISFIED
ZZZ(LC)	;LOST CHARACTERS
ZZZ(OB)	;ORANGE BALL RECEIVED
ZZZ(ZP)	;ZAPPER RECEIVED
ZZZ(PS)	;PORT STATUS MESSAGE RECEIVED   (See comment at ACPSM)
ZZZ(YB)	;YELLOW BALL RECEIVED
ZZZ(CG)	;CHARACTER GOBBLER RECEIVED
ZZZ(TC)	;TERMINAL CHARACTERISTIC CHANGED AT OTHER END OF PTY

TRPLEN==.-DDPTAB

;TRAP NUMBER INTERNALS

TTNESC==:DDPTSC-DDPTAB
TTNCHR==:DDPTCH-DDPTAB
TTNLIN==:DDPTLN-DDPTAB
TTNYLB==:DDPTOB-DDPTAB

;OTHER DDB BYTE POINTERS

DDPBBP:	POINT 1,DDBDCH(F),0	;BACKSPACE AS PUNCTUATION
DDPTBK:	POINT 1,DDBDCH(F),1	;TABS ARE BREAKS
DDPNTB:	POINT 1,DDBDCH(F),2	;NO SPECIAL TAB ACTION
DDPIMB: POINT 9,DDBDCH(F),35	;IMAGE MODE BREAK CHARACTER
DDPMOD: POINT 4,DEVIOS(F),35	;DATA MODE
DDPCOM: POINT 1,DDBDCH(F),3	;SAVED STATE OF LDLCOM
DDPNZP:	POINT 1,DEVMOD(F),5	;NO-ZAP BIT
SUBTTL	TTY DDB. ONCE CREATES ONE OF THESE PER JOB FOR TTYTAB TO POINT TO.

TTYLST:		;LABEL FOR FIRST TTY DDB IN CHAIN
SCNDDB::PHASE	0	;GLOBAL LABEL
	SIXBIT /TTY0/		;DEVNAM (PHYSICAL NAME)
	XWD 0,STTYBF+1		;DEVCHR. SIZE OF USER BUFFER
	0			;DEVIOS
	XWD 0,SCNDSP		;DEVSER
	XWD DVTTY+DVIN+DVOUT,<<1_B>+<1_A>+<1_AL>+<1_I>+<1_IB>+<1_XA>>
				;DEVMOD
	0			;DEVLOG (LOGICAL NAME)
	0			;DEVBUF
	0			;DEVIAD
	0			;DEVOAD
DEVCLS:! XWD 200000,0		;CLASS
DDBDCH:! 0	;PROCESS-RELATED DEVICE CHARACTERISTICS NOT IN DEVIOS
	DCLBBP==400000	;0	BACKSPACE IS PUNCTATION (DDPBBP)
	DCLTBK==200000	;1	TABS ARE BREAKS (DDPTBK)
	DCLNTB==100000	;2	DON'T ECHO HT/VT/FF (DDPNTB)
	DCLCOM==0403	SAVED STATE OF LDLCOM (DDPCOM)
			;27-35	IMAGE MODE BREAK CHARACTER (DDPIMB)
DDBBLK::!			;(LH) BACK LINK (PREVIOUS TTY DDB)
DDBLDB::!0			;(RH) LDB ADDR
DDBTRP:! BLOCK <TRPLEN+5>/6	;INTERRUPT-TO-CHANNEL ASSIGNMENTS

DEPHASE

SCNDDS==:.-SCNDDB
SUBTTL	TTY FILE STATUS BITS

;LEFT HALF

TTYOUW==:400000	;0	TI MEANS OUTPUT WAIT, NOT INPUT WAIT
TWTSPC== 200000	;1	TI BECAUSE SYSTEM OUT OF BUFFERLETS
IOSBKA== 100000	;2	BREAK ON ALL CHARACTERS
TINFIO== 040000	;3	CAUSE AN OUTPUT-DONE INTERRUPT WHEN OUTPUT DONE
TIOUSE== 020000	;4	UUO IN PROGRESS, DON'T ZAP DDB

;RIGHT HALF

BK2IOS== 001000	;26	BREAK ON PUNCTUATION
DLRSUP== 000400	;27	NO ESCAPE ECHO
NOECHO== 000200	;28	NO ECHO
FCS==    000100	;29	FULL CHARACTER SET
SUBTTL	HOST TO BASE AND BASE TO HOST MESSAGE TYPES

;Buffer ring message formats

;Each logical record in the buffer ring is some number of 8-bit bytes.
;These start on a word boundry, the last 4 bits of each PDP-10 word are
;ignored, and records currently do not wrap around in the buffer.

;The first byte of each logical record is the message type, the next 8 bits
;is the port number.  If the high order bit is set in the message type, then
;the remaining 7 bits in the first byte specify the number of characters that
;follow.  Otherwise the first byte is a command code.

;BASE HOST    "{"=from host, "}"=to host, "#"=crash, "-"=ignore
;00##00	UNUSED, ERROR
;TYP.00,xxx,xxx,xxx

;01{-01	SYSTEM IS ANSWERED, IGNORED ON INPUT BY KI/KL/F3, CHECKED BY KS
TYPANS==01 ;xxx,xxx,xxx

;02{-01	SYSTEM IS SHUT, IGNORED ON INPUT
TYPSHT==02 ;xxx,xxx,xxx

;03{}03	RESET THE INTERFACE, QUIETLY ZAP ALL CIRCUITS (DR11 IS BAD ON KS)
TYPRES==03 ;DEBUGF,VER,REV      (used to be TYPCRS - sender has crashed)

;04#}04	RESET ACKNOWLEGE, TELL DEBUG STATUS, VERSION NUMBER, REVISION LEVEL
TYPRAK==04 ;DEBUGF,VER,REV      (used to be TYPDIE - recipient should crash)

;05#}05	THE NODE HAS BEEN TAKEN OVER BY A NEW SUPERVISOR
TYPNSP==05 ;000,xxx,xxx

;06#}06	EXTERNALLY INITIATED NEW CIRCUIT.  TREAT NEXT SET OF DATA BYTES SPECIAL
TYPLOG==06 ;PORT,xxx,xxx

;07#}07	SUPERVISOR RESPONSE TO ESTABLISHING AN AUX CIRCUIT
TYPAUX==07 ;NEWPORT,KEY,xxx

;08{}10	BACKPRESSURE ON
TYPNOP==10 ;PORT,xxx,xxx

;09{}11	BACKPRESSURE OFF
TYPOUP==11 ;PORT,xxx,xxx

;0A{}12	CHARACTER GOBBLER, IGNORED ON INPUT
TYPGOB==12 ;PORT,xxx,xxx

;0B{}13	CIRCUIT ZAPPER, RECIPIENT MUST ECHO ZAPPER ON SAME PORT
TYPZAP==13 ;PORT,xxx,xxx

;0C{}14	ENTER DEFERED ECHO MODE
TYPEDC==14 ;PORT,xxx,xxx

;0D{}15	LEAVE DEFERRED ECHO MODE
TYPLDC==15 ;PORT,xxx,xxx

;0E{}16	GREEN BALL
TYPGRN==16 ;PORT,xxx,xxx

;0F{}17	RED BALL
TYPRED==17 ;PORT,xxx,xxx

;10{}20	YELLOW BALL
TYPYEL==20 ;PORT,xxx,xxx

;11{}21	ORANGE BALL
TYPORG==21 ;PORT,xxx,xxx

;12{-22	HANG CHARACTER (DROP DTR, DON'T ZAP CIRCUIT, IGNORED ON INPUT)
TYPHNG==22 ;PORT,xxx,xxx

;13{-23	ENTER 2741 TRANSPARENT MODE (IGNORED ON INPUT)
TYPETM==23 ;PORT,xxx,xxx

;14{-24	LEAVE 2741 TRANSPARENT MODE (IGNORED ON INPUT)
TYPLTM==24 ;PORT,xxx,xxx

;15#}25	LOST BALL.  BLACK BALL IF DATA=FF, GRAY BALL IF DATA=00
TYPLOS==25 ;PORT,DATA,xxx

;16{#26	REQUEST NEW PORT NUMBER FOR BUILDING AUX CIRCUIT (KEY RETURNED BY 07)
TYPSUP==26 ;KEY,000,xxx

;17#}27	SUPERVISOR RESPONSE, 3RD BYTE IS ERROR CODE
TYPSUR==27 ;KEY,ERRCODE,xxx

;18{#30	SUPERVISOR LOGIN CHARACTER IN 3RD BYTE
TYPAXC==30 ;KEY,CHAR,xxx

;19{#31	TEST PATTERN PROBE (32 BITS OF TEST DATA)
TYPTSP==31 ;PORT,DATA1,DATA2,  DATA3,DATA4,xxx,xxx

;1A#}32	TEST PATTERN RESPONSE
TYPTSR==32 ;PORT,DATA1,DATA2,  DATA3,DATA4,xxx,xxx

;1B{#33	HOST SAD, 32 UNHAPPY BITS
TYPSAD==33 ;000,DATA1,DATA2,  DATA3,DATA4

;1C{#34	ECHO ON
TYPECN==34 ;PORT,xxx,xxx

;1D{#35	ECHO OFF
TYPECF==35 ;PORT,xxx,xxx

;1E{#36	SET TERMINAL CHARACTERISTICS, NUMBER AND VALUE
TYPTCS==36 ;PORT,TCHNUM,VALUE

;1F{#37	TERMINAL CHARACTERISTICS PROBE, FOR A PARTICULAR TCHNUM
TYPTCP==37 ;PORT,TCHNUM,xxx

;20#}40	TERMINAL CHARACTERISTICS RESPONSE, ANSWER TO PROBE
TYPTCR==40 ;PORT,TCHNUM,VALUE

;21{#41	TELL SUPERVISOR NUMBER OF PORTS AND HOST NUMBER
TYPHSI==41 ;MAXPORT,HOST#,xxx

;22{#42	REQUEST FOR SUPERVISOR CLOCK INFO (BASE IGNORES THIS)
TYPCLP==42 ;xxx,xxx,xxx

;23#}43	RESPONSE WITH SUPERVISOR CLOCK INFO IN SECONDS SINCE 1-JAN-1974
TYPCLR==43 ;000,DATA1,DATA2,  DATA3,DATA4,xxx,xxx

;24{#44	INITIATE BLOCK OUTPUT
TYPBKO==44 ;PORT,COUNT1,COUNT2,  ADDR1,ADDR2,ADDR3,xxxx

;25#}45	BLOCK OUTPUT COMPLETE
TYPBOC==45 ;PORT,xxx,xxx

;26{#46	INITIATE BLOCK INPUT
TYPBIN==46 ;PORT,COUNT1,COUNT2,  ADDR1,ADDR2,ADDR3,xxxx

;27#}47	BLOCK INPUT TERMINATED - OUT OF BUFFER
TYPINB==47 ;PORT,COUNT1,COUNT2

;28#}50	BLOCK INPUT TERMINATED - END OF TRANSMISSION
TYPINE==50 ;PORT,COUNT1,COUNT2

;29#}51	BLOCK INPUT TERMINATED - TIMEOUT BY BASE
TYPINT==51 ;PORT,COUNT1,COUNT2

;2A{#52	REQUEST BLOCK INPUT TERMINATION
TYPIRQ==52 ;PORT,xxx,xxx

;2B#}53	BLOCK INPUT TERMINATED - BY HOST REQUEST
TYPIHR==53 ;PORT,COUNT1,COUNT2

;2C{#54	REQUEST BLOCK OUTPUT TERMINATION
TYPORQ==54 ;PORT,xxx,xxx

;2D#}55	BLOCK OUTPUT TERMINATED - BY HOST REQUEST
TYPOHR==55 ;PORT,xxx,xxx

;2E{}56	NEGOTIATE FOR NUMBER OF BLOCK I/O PORTS
TYPNEG==56 ;PORT,DATA,xxx

;2F#}57	BREAK RECIEVED
TYPBRK==57 ;PORT,xxx,xxx

;30#}60	PORT STATUS RECEIVED  (Obsolete, not in EBUS, see comment at ACPSM)
TYPPSR==60 ;PORT,DATA,xxx

;31{-61	ENTER ALTERNATE DEVICE MODE (TURN ON PRINTER), IGNORED ON INPUT
TYPEAD==61 ;PORT,xxx,xxx

;32{-62	LEAVE ALTERNATE DEVICE MODE (TURN OFF PRINTER), IGNORED ON INPUT
TYPLAD==62 ;PORT,xxx,xxx

;33{#63	SET KEEP-ALIVE-FAILURE TIMER
TYPKAF==63 ;000,DATA1,DATA2
SUBTTL	Special KS2020 microcode for KMC

IFKMC<
	BYP1==^D9	;RIGHTMOST BIT POSITION OF FIRST BYTE
	BYP2==^D17	;      SECOND BYTE OF A BUFFER RING WORD
	BYP3==^D27	;      THIRD BYTE
	BYP4==^D35	;      LAST BYTE POSITION IN A BUF RING WORD
	OPDEF	UUILDB	[101000,,0]	;KMC ILDB
	OPDEF	UUIDPB	[102000,,0]	;KMC IDPB
	OPDEF	EXTEND	[123000,,0]	;EXTENDED INSTRUCTION OPCODE
	OPDEF	MOVSLJ	[016000,,0]	;MOVE STRING LEFT JUSTIFIED
	DEFINE	TYPI(TYPE)		;FOR LOADING TYPES WITH A
	<TYPE_^D8>			;	MOVSI INSTR
	>;END IFKMC
IFNKMC<
	BYP1==^D7	;RIGHTMOST BIT POSITION OF FIRST BYTE
	BYP2==^D15	;      SECOND BYTE OF A BUFFER RING WORD
	BYP3==^D23	;      THIRD BYTE
	BYP4==^D31	;      LAST BYTE POSITION IN A BUF RING WORD
	OPDEF	UUILDB	[ILDB 0]	;NORMAL ILDB
	OPDEF	UUIDPB	[IDPB 0]	;NORMAL IDPB
	DEFINE	TYPI(TYPE)		;FOR LOADING TYPES WITH A
	<TYPE_^D10>			;	MOVSI INSTR
	>;END IFNKMC
SUBTTL	BUFFER RING BYTE POINTERS

INPTYP:	POINT 8,IRING(P4),BYP1	;TYPE
INPLIN:	POINT 8,IRING(P4),BYP2	;LINE NUMBER
INPCHR:	POINT 8,IRING(P4),BYP3	;CHARACTER
INPCH2:	POINT 8,IRING(P4),BYP4	;SECOND DATA CHARACTER
INPDL1:	POINT 16,IRING(P4),BYP2	;FIRST TWO CHRS
INPDL2:	POINT 16,IRING(P4),BYP4	;SECOND TWO CHRS

;POINTER FOR PUTTING THINGS IN THE OUTPUT RING

OUPTYP:	POINT 8,ORING(P4),BYP1	;TYPE
OUPLIN:	POINT 8,ORING(P4),BYP2	;PORT NUMBER

;POINTERS FOR ASSEMBLING FULL WORDS FOR OUTPUT (IN P3)

WRPLIN:	POINT 8,P3,BYP2		;PORT NUMBER (TYPE is set via TYPI macro)
WRPCHR:	POINT 8,P3,BYP3		;DATA CHARACTER
WRPCH2:	POINT 8,P3,BYP4		;SECOND DATA CHARACTER
WRP3N4:	POINT 16,P3,BYP4	;Bytes 3 and 4
SUBTTL CHARACTER TABLES

;HERE IS THE CHARACTER TABLE. IT INCLUDES A CHARACTER MODE FOR
;EACH OF INPUT, OUTPUT, ECHO, AND READ (BY PROGRAM). IT ALSO
;INCLUDES A SPECIAL ACTION CODE FOR EACH OF THESE.

DEFINE CHRATR (INP,OUT,RED,ECH,SPAI,SPAO,SPAR,SPAE)
	<BYTE (2) INP,OUT (3) SPAO,RED,ECH,SPAR (5) SPAI (4) SPAE>

CHPINP:	POINT 2,P3,1	;POINTER TO THE INPUT FIELD
CHPOUT:	POINT 2,P3,3	;POINTER TO THE OUTPUT FIELD
CHPSPO:	POINT 3,P3,6	;POINTER TO THE OUTPUT SPECIAL ACTION FIELD
CHPRED:	POINT 3,P3,9	;POINTER TO THE READ FIELD
CHPECH:	POINT 3,P3,12	;POINTER TO THE ECHO FIELD
CHPSPR:	POINT 3,P3,15	;POINTER TO THE READ SPECIAL ACTION FIELD
CHPSPI:	POINT 5,P3,20	;POINTER TO THE INPUT SPECIAL ACTION FIELD
CHPSPE:	POINT 4,P3,24	;POINTER TO THE ECHO SPECIAL ACTION FIELD

SALL
CHRTAB:
SUBTTL	CONTROL CHARACTERS

CHRATR 0,2,2,2,0		;NULL
CHRATR 0,2,2,2,13		;^A
CHRATR 2,2,2,2			;^B
CHRATR 0,2,0,0,1,0,0,0		;^C
REPEAT 3,<
CHRATR 2,2,2,2>			;^D,^E,^F
CHRATR 2,2,2,3			;^G
CHRATR 0,0,0,0,17,4,6,11	;BACKSPACE
CHRATR 0,0,0,0,6,1,5,3		;^I
CHRATR 2,2,2,3			;LINE FEED
CHRATR 2,0,2,0,0,2,0,5		;VERTICAL TAB
CHRATR 2,0,2,0,0,3,0,6		;FORM FEED
CHRATR 0,0,1,0,2,0,0,1		;RETURN
CHRATR 2,2,2,2			;^N
CHRATR 0,2,2,2,3		;^O
CHRATR 2,2,2,2			;^P
CHRATR 0,2,2,2,4		;^Q
REPEAT 2,<
CHRATR 2,2,2,2>			;^R,^S
CHRATR 0,2,2,2,20		;^T
CHRATR 0,2,2,0,5,0,0,2		;^U
REPEAT 4,<
CHRATR 2,2,2,2>			;^V,^W,^X,^Y
CHRATR 2,2,0,0,0,0,3,7		;^Z
CHRATR 0,2,0,0,7,0,1,4		;ESCAPE (33)
CHRATR 0,2,2,2,16		;^\
CHRATR 2,2,2,2			;^]
CHRATR 0,2,2,2,10		;^^
CHRATR 0,2,0,2,11,0,2,0		;^_
SUBTTL	NUMBERS AND PUNCTUATION

REPEAT 20,<
CHRATR 3,1,3,4>			;PUNCTUATION
REPEAT 12,<
CHRATR 1,1,1,1>			;0-9
REPEAT 7,<
CHRATR 3,1,3,4>			;PUNCTUATION
SUBTTL	UPPER CASE

REPEAT 32,<
CHRATR 1,3,1,1>			;A-Z
REPEAT 4,<
CHRATR 3,1,3,4>			;PUNCTUATION
CHRATR 0,1,3,4,15		;_ (FOR TYMEX2 MODE)
CHRATR 3,1,3,4			;^
SUBTTL	LOWER CASE

REPEAT 32,<
CHRATR 1,1,4,1>			;a-z
REPEAT 2,<
CHRATR 3,1,3,4>			;PUNCTUATION
CHRATR 0,1,0,0,14,0,4,10	;ALTMODE (175) OR }
CHRATR 0,1,0,0,14,0,4,10	;ALTMODE (176) OR ~
CHRATR 0,2,2,2,12		;RUBOUT (177)
COMMENT ;
SUMMARY OF MEANING OF FIELDS

INPUT
	0-SPECIAL ACTION
	1-NORMAL CHARACTER
	2-BREAK CHARACTER
	3-CLASS 2 BREAK CHARACTER

OUTPUT
	0-SPECIAL ACTION
	1-OUTPUT AND COUNT FOR FREE RETURN
	2-OUTPUT BUT DO NOT COUNT
	3-UPPER CASE CHARACTER

REMOTE ECHO
	0-SPECIAL ACTION
	1-COUNT FOR FREE RETURN
	2-DO NOT COUNT FOR FREE RETURN
	3-SAME AS 2
	4-SAME AS 1

DEFERED ECHO
	0-SPECIAL ACTION
	1-PRINT CHARACTER AND COUNT FOR FREE RETURN
	2-BREAK CHARACTER, DO NOT PRINT, DO NOT COUNT
	3-BREAK CHARACTER, PRINT, DO NOT COUNT
	4-CLASS 2 BREAK CHARACTER, PRINT AND COUNT
	5-IMAGE CHARACTER
	6-BREAK CHARACTER, PRINT AND COUNT

READ
	0-SPECIAL ACTION
	1-NORMAL CHARACTER
	2-BREAK CHARACTER
	3-CLASS 2 BREAK CHARACTER
	4-LOWER CASE CHARACTER
;

;DEFINE STOP CHARACTERS (ESCAPES) FOR VARIOUS MODES

STOP10==3	;^C
STOP9==37	;^_
SUBTTL	Channel 1 interrupt processing

KEY10:	633751506262		;Magic value that TYMNET BASE wants to see

;UPDKEY - Update the KEY 60 times per second, at channel 1 level
;Called by JSP T1,UPDKEY    (T2 is scratch).

UPDKEY::MOVE	T2,KEY10		;Set key for TYMNET
KEYSET::EXCH	T2,KEY620##		;(JFCL if base is not being used)
	SKIPN	T2			;If it was zero,
	 SETZM	KEYTIM##		; reset KEY620 timer
	SKIPE	T2			;If zero,
	CAMN	T2,KEY10		; or the value we set,
	 SKIPA				;OK
	  MOVEM	T2,BADKEY		;Remember bad key for later
	MOVE	T2,UPTIME##		;Get current system uptime
	SKIPE	DINITF##		;Is ONCE initializing the disks?
	 MOVEM	T2,THSTIM##		;Yes, make THSTIM look current
	SUB	T2,THSTIM##		;Check on how long since SCNTIC ran
	CAML	T2,JFYMIN##		;More than one minute?
KAF1::	 STOPCD (,XCT,S..KAF)		;Keep alive failure
	JRST	(T1)			;Return to PICON

;CHKBAS - Check if the nonzero value in 30 came from the base.
;Called by JSP T1,CHKBAS whenever CRSHWD is nonzero.
;T2 is scratch, stack is not set up.
;Error return of PDP-10 should crash, skip return to continue.

CHKBAS::LDB	T2,[POINT 16,CRSHWD,15]	;Check if first 16 bits
	CAME	T2,ORP620		; match the base's ORING pointer
	CAMN	T2,ORPOLD
	 SKIPA				;OK
	  JRST	(T1)			;No match, don't blame it on base
	LDB	T2,[POINT 16,CRSHWD,31]	;Check if second 16 bits
	CAME	T2,IRP620		; match the base's IRING pointer
	CAMN	T2,IRPOLD
	 SKIPA
	  JRST	(T1)			;No match, don't blame it on base
	SETOM	BASDWN##		;Base problems.  Mark it as down
	MOVEI	T2,^D15000		;Delay for about 1/60th of a second
	SOJG	T2,.			; for base to write into KEY620
	MOVE	T2,KEY620##		;Get the key
	CAMN	T2,KEY10		;If we overwrote it,
	 MOVE	T2,BADKEY		; get previous value
	MOVEM	T2,KEY620##		;Reset it if necessary
	LSH	T2,^D<16-36>		;Get 16 bits of KEY620
	MOVEM	P,SCN1PD		;Need a stack for STOPCD
	MOVEI	P,SCN1PD
	CAIN	T2,04			;Did base complain about a bad message?
	 STOPCD (.,STOP,BASE04,PRTCRS,<Bad message type from host>)
	 STOPCD (.+1,INFO,BASE,PRTCRS,<BASE has crashed - bad KEY620>)
	MOVE	P,SCN1PD		;Restore AC
	SETZM	CRSHWD##		;Clear out location 30 to keep system up
	JRST	1(T1)			;Skip return back to PICON

SCN1PD:	BLOCK	2			;Dummy stack for PUSHJ P,DIE

;Here from PRTIRP to output SAV30, ORP620, IRP620, and KEY620

PRTCRS:	PUSHJ	P,INLMES##
	 ASCIZ /ORP620: /
	MOVE	T1,ORP620
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##
	 ASCIZ /  IRP620: /
	MOVE	T1,IRP620
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##		;Called from STOPCD(BASE),STOPCD(BASE04)
	 ASCIZ /   SAV30: /
	MOVE	T1,SAV30##		;Saved contents of CRSHWD
	PUSHJ	P,HWDPNT##
	PUSHJ	P,INLMES##
	 ASCIZ / = /
	LDB	T1,[POINT 16,SAV30,15]	; Get Base ORING pointer field
	PUSHJ	P,PRTOCT##
	PUSHJ	P,PRCOM##		;Comma
	LDB	T1,[POINT 16,SAV30,31]	; Get Base IRING pointer field
	PUSHJ	P,PRTOCT##
PRTKEY::PUSHJ	P,INLMES##		;Here from STOPCD(CRASH)
	 ASCIZ /   Key: /
	MOVE	T1,KEY620		;Get Key value
	CAMN	T1,KEY10
	 JRST	[JSP T1,CONMES##
		 ASCIZ /OK
/]
	LSH	T1,^D<16-36>		;Get high order 16 bits and
	PUSHJ	P,PRTOCT##		; print as an octal number.
	PJRST	CRLF##			;Finish the line.

COMMENT ~	Values stored in KEY620 when the Varian base goes down
* 00="Normal - host going down - key not refreshed.",
  01="Host crashing due to base crash.",
  02="MIC error or MIC reject tring to read key.",
* 03="Read bad key from host.",
* 04="Bad data type or port number from host.",  HOST MUST CRASH
  05="Illogical data type from host.",
  06="MIC busy trying to read host (IN10).",
  07="Input ring processing time-out.",
* 10="MIC time-out error (sen 337).",
* 11="Parity error from MIC (sen 237).",
* 12="MIC busy for 232 cycles in addr portion of 'look'.",
  13="Host told base to crash...this is a no-no!!",
  14="MIC busy (look) from prior operation in 'look'.",
  15="Overran block i/o table.",
  16="Terminate block input req. is invalid.",
  17="Base crash...power failure.",
  20="Base crash...manual restart.",
  21="Base crash....",
**22="Base crash...GCI crash.", BASE CRASHES ITSELF
  23="Base crash...WCD crash.",
**24="Base crash...WCI crash.", BASE CRASHES ITSELF
* 25="Base crash...GCOL crash.",
  26="Base crash...speed crash.",
  27="Base crash...unidentified crash.",
  30="Base crash....",
  31="Base crash...WWI crash.",
  32="Base crash...empty crash.",
  33="Base crash...parity error.",
  34="Base crash...bad 201 interrupt.",
  35="Base crash....",
  36="Base crash....",
  37="Base crash....";
**120="Bad ISIS message.", BASE CRASHES ITSELF
**140="Bad stack usage.", BASE CRASHES ITSELF
**202="Buss Error.", BASE CRASHES ITSELF
**203="Address Error", BASE CRASHES ITSELF
**204="Illegal Instruction.", BASE CRASHES ITSELF
**354="Engine told 68K to crash.", BASE CRASHES ITSELF
**355="Split Char Pair.", BASE CRASHES ITSELF
~  ;End of COMMENT
SUBTTL INPUT RING DISPATCHER

;HERE EVERY TICK FROM CHANNEL 7

    ;KEEP TRACK OF MAXIMUM INTER-CALL DELAY

SCNINT::MOVE	T4,UPTIME	;Check on how long it has been since SCNSER
	EXCH	T4,THSTIM##	; last had a chance to run
	JUMPL	T4,SCNNT0	;Don't check on the very first tick
	SUB	T4,THSTIM##
	MOVNS	T4
	CAMLE	T4,MXTIM##
	 MOVEM	T4,MXTIM##	;Save maximum so far
	AOS	KEYTIM##	;Increment # of ticks since key was reset
	AOS	IRPTIM##	;          # of ticks since last input message
	AOS	ORPTIM##	;          # of ticks since last output message

    ;CHECK FOR CTY OUTPUT

SCNNT0:	SKIPG	CTYLDB+LDBTOC	;If there are characters for the CTY
	SKIPGE	CTYBLF		; or if someone wants to ding its bell,
	 PUSHJ	P,OPRCTY	; go do it
	PUSHJ	P,CTYINP##	;Check for input on the CTY
	  JFCL			;No input (character in T3 if CTYINP skips)

    ;CHECK IF RING NEEDS TO BE RESET

	SKIPN	T1,BASDWN##	;Has base crashed or 10 in system restart?
	 JRST	SCNTIC		;No, rings are fine
;BASDWN=-1 means base has crashed or is not responding.
;BASDWN=+1 means system startup - ask for date/time from the supervisor.
	SKIPG	T1		;Startup?
	 PUSHJ	P,DETALL	;No, detach all jobs when base dies
	SETZB	T2,IRPPDP
	EXCH	T2,IRP620	;Reset IRING pointers
	SKIPE	T2
	 MOVEM	T2,IRPOLD	;Save old pointer for CHKBAS
	SETZB	T2,ORPPDP
	EXCH	T2,ORP620	;Reset ORING pointers
	SKIPE	T2
	 MOVEM	T2,ORPOLD	;Save old pointer for CHKBAS
IFCPU (F3),<
	PUSHJ	P,FNSYNC	;Synchronize with the PDP-11 base
	  POPJ	P,		;Not ready yet, try again next time
>;END IFCPU F3
	MOVE	P4,ORPPDP	;Get current ORING pointer (starts at zero)
	MOVE	P3,[<TYPRAK>B<BYP1>+<SCNVER>B<BYP3>+<SCNREL>B<BYP4>]
	SKIPL	BASDWN		;Send reset-ack if base died, CLK at startup
	 MOVE	P3,[<TYPCLP>B<BYP1>+<SCNVER>B<BYP3>+<SCNREL>B<BYP4>]
	SKIPGE	DEBUGF##	;System being debugged?
	 TLO	P3,(1B<BYP2>)	;Yes, set LSB of 2nd byte
	MOVEM	P3,ORING(P4)	;Put first message in ring
	PUSHJ	P,ORPLOG	;Put message into ORING log
	ADDI	P4,1
	MOVSI	P3,TYPI TYPHSI	;Message type 41
	MOVEI	T1,RPORTN##	;Number of real ports
IFKMC<	LPERDR==<^D16>*4	;ONE OF 64. 32. or 16. LINES PER DR
	;LPERDR must match that defined in the KMC microcode
	MAXDR==RPORTN##/LPERDR	;HIGHEST DR = # OF PORTS/LINES PER DR
	TRZ	T1,3		;Must have a multiple of 4
	CAIL	T1,LPERDR	;Determine lines on 1st node
	 MOVEI	T1,<LPERDR-1>&74;Must be a multiple of 4 .LT. ^D64
>;END IFKMC
	DPB	T1,WRPLIN	;Highest port number we will accept
	MOVE	T1,SYSNUM##	;Our host number
	DPB	T1,WRPCHR	; in 3rd byte
	MOVEM	P3,ORING(P4)
	PUSHJ	P,ORPLOG	;Put message into ORING log
	ADDI	P4,1
	MOVEM	P4,ORPPDP	;Let base see those 2 messages
IFKMC<	MOVEI	T1,<4320000&<7777_<3*MAXDR>>>_-9
		;T1/4320 or 320 or 20 or 0 (SEE DRFLAG:) SO AS TO PUT
		;OUT 41 MESSAGES TO DRs 2,3 & 4 IF THEY ARE THERE
	SETZ	W,		;INITIALIZE W FOR NON-PTY OUTPUT
	MOVSI	P3,TYPI TYPHSI	;41 MESSAGES
	PUSHJ	P,MDRMSG
>;END IFKMC
	SETZM	BASDWN##	;Flag that we think the base is up
	SETZM	BASVER##	;Zero version number for BASEOK message
	SETZM	BADKEY		;Reset saved bad key
	POPJ	P,		;Come back next tick

    ;CHECK OTHER UNUSUAL OUTPUT REQUESTS

SCNTIC:	SETZ	W,		;LET OUTPUT CODE KNOW IT'S REAL NOT PTY OUTPUT
	PUSHJ	P,SETOUT
	  JRST	SCNIN		;NO ROOM FOR CHARACTERS
	SKIPN	P3,UPSHUT	;IS THERE A SHUT OR ANSWERED MESSAGE
	 JRST	SCNNT2
IFNKMC<	PUSHJ	P,CLSCHR	;JUST FOR THE SAKE OF GOOD FORM
	  JRST	SCNIN		;DON'T UNDERSTAND HOW WE GOT HERE BUT OK
	SETZM	UPSHUT		;WILL SEND NOW, MARK NO MORE MSG
	PUSHJ	P,WRDOUT	;SEND IT
	  JRST	SCNIN		;THE LAST OF THE SPACE
>;END IFNKMC
IFKMC<	PUSHJ	P,MDRUP		;GET 3-BIT UP FLAGS
	HLRZ	P3,P3
	CAIN	P3,TYPI TYPSHT
	 MOVEM	T1,DRMSHT
	CAIN	P3,TYPI TYPANS
	 MOVEM	T1,DRMANS
	SETZM	UPSHUT>;END IFKMC
SCNNT2:	PUSHJ	P,SNDSAD	;SEND A SAD MESSAGE IF APPROPRIATE
	  JRST	SCNIN
IFKMC<	PUSHJ	P,SNDHSI	;SEE IF ANY DRs NEED A TYPHSI MSG ETC.
	  JRST	SCNIN>;END IFKMC
	PUSHJ	P,SNDAUX	;Check progress on AUX circuit builds
	  JRST	SCNIN		;OUT OF ROOM NOW
IFCPU (<KI,KL>), <	;TYMNET BASES REQUIRE BIO PORT NEGOTIATION,
			; NEXILIS BASES DO NOT
	SKIPGE	BIOCNT+0	;ANY CHANGE IN THE NUMBER OF BIO PORTS?
	PUSHJ	P,SNDBIO	;REQUEST TO THE BASE.
	  JRST	SCNIN
> ;END IFCPU (<KI,KL>)
SUBTTL	HERE TO PROCESS ALL THE MESSAGES IN THE INPUT RING, THEN
;JUMP TO OUTPUT CODE. FSCN GETS SET TO -1 IF ANY MESSAGES
;WERE PROCESSED.

SCNIN:	MOVE	P4,IRPPDP
	CAMN	P4,IRP620	;Anything in the input ring?
	 JRST	SCNOUT		;No, try output ring
	SETOM	FSCN		;Yes, flag that we found something
IFCPU (<F3,KS>),<
	SKIPGE	IRPTIM##	;Is this the first message after base went down?
	 STOPCD (,XCT,BASEOK)	;Yes, output BASEOK message
>  ;End IFCPU(F3,KS)
	SETZM	IRPTIM##	;Reset IRING timer
	MOVE	T1,IRP620	;Remember current IRING pointer so that
	MOVEM	T1,IRPSTP	; we can tell when it is time to pause input
				; and send backpressure on lines that need it
SCNIN0:	CAMN	P4,IRPSTP	;Processed all data present at start of pass?
	 JRST	SCNOUT		;Yes, go do output
	PUSHJ	P,IRPLOG	;No, LOG current IRING data, P4=INDEX
;;;;;;;;BEGIN KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKMC<
	MOVE	P1,IRPMB2	;SAVE PREVIOUS BASE POINTER
	MOVEM	P1,IRPMB3
	MOVE	P1,IRPMB1	;SAVE PREVIOUS BASE POINTER
	MOVEM	P1,IRPMB2
	MOVE	P1,IRP620
	MOVEM	P1,IRPMB1	;SAVE CURRENT BASE POINTER TOO

	MOVE	P1,IRPMP2	;SAVE PREVIOUS MESSAGE POINTER
	MOVEM	P1,IRPMP3
	MOVE	P1,IRPMP1	;SAVE PREVIOUS MESSAGE POINTER
	MOVEM	P1,IRPMP2
	MOVEM	P4,IRPMP1	;SAVE MESSAGE POINTER TOO

	MOVE	P1,IRPMS2	;SAVE PREVIOUS MESSAGE
	MOVEM	P1,IRPMS3
	MOVE	P1,IRPMSG	;SAVE PREVIOUS MESSAGE
	MOVEM	P1,IRPMS2
	MOVE	P1,IRING(P4)	;SAVE FIRST WORD OF MESSAGE IN IRPMSG
	MOVEM	P1,IRPMSG
>;END IFKMC
;;;;;;;;END KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	LDB	P1,INPTYP	;P1/ MESSAGE TYPE
	LDB	U,INPLIN	;U/ PORT #
	CAILE	U,RMXLIN##
	 JRST	BADPRT		;Check if message does not use port number
BADPR1:	MOVE	U,LINTAB(U)	;U/ PORT LDB
	HLL	U,LDBDCH(U)
	TRZE	P1,200		;IF 200 BIT SET, IT'S DATA
	 JRST	CHRMLT		;P1 has count of characters to be input
	CAILE	P1,MXTYP	;Check if in range
TTYBMT:: STOPCD (SCNIN2,INFO,TTYBMT,PRTIRG,<Bad Message Type from Base>);;CNTPRT-1
CNTPRT:	XCT	TYPTRN(P1)	;DISPATCH TO IT
SCNIN1:	ANDI	P4,MSKIRG	;MASK FOR WRAP AROUND
	MOVEM	P4,IRPPDP	;PUT IT AWAY FOR 620
	JRST	SCNIN0		;GO SEE IF MORE INPUT

SCNIN2:	AOJA	P4,SCNIN1	;Ignore this word, go get next one

;Check for legal messages that do not have port number in 2nd byte

BADPRT:	CAIE	P1,TYPANS	;(1) Answered, port = 0
	CAIN	P1,TYPSHT	;(2) Shut, port = 0
	 JRST	CNTPRT
	CAIE	P1,TYPRES	;(3) Reset, port = flag bits (0,1,200,201)
	CAIN	P1,TYPRAK	;(4) Reset ack, port = flag bits
	 JRST	CNTPRT
	CAIE	P1,TYPNSP	;(5) New supervisor, port = 0
	CAIN	P1,TYPSUR	;(27) Supervisor Response, port = key
	 JRST	CNTPRT
	CAIE	P1,TYPTSR	;(32) Test pattern response, port = data
	CAIN	P1,TYPCLR	;(43) Clock Response, port = 0
	 JRST	CNTPRT
	MOVEI	U,0		;Use port 0 if out of range
	STOPCD (BADPR1,INFO,TTYBPN,PRTIRG,<Bad Port Number from Base>);;BADPRT+3
PRINTF([TTYBPN needs filter to skip multi-word IRING messages to continue])

;PRTIRG - Print PDP-10 ring pointers, and word at IRING+IRPPDP for STOPCD

PRTIRG::PUSHJ	P,INLMES##	;Called from stopcodes TTYBMT,TTYBPN,CTYBMT
	 ASCIZ /ORPPDP: /
	MOVE	T1,ORPPDP
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##
	 ASCIZ /  IRPPDP: /
	MOVE	T1,IRPPDP
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##	;Output word that IRPPDP points to
	 ASCIZ /   IRING+/
	MOVE	P4,IRPPDP	;In case called from CTYBMT in CTYSIM
	HRRZ	T1,P4
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##
	 ASCIZ \/ \
	LDB	T1,INPTYP	;Message type
	PUSHJ	P,PRTOCT##
	PUSHJ	P,PRCOM##
	LDB	T1,INPLIN	;Get port number (U has LDB address)
	PUSHJ	P,PRTOCT##
	PUSHJ	P,PRCOM##
	LDB	T1,INPCHR	;Get first data byte
	PUSHJ	P,PRTOCT##
	PUSHJ	P,PRCOM##
	LDB	T1,INPCH2	;Get 2nd data byte
	PUSHJ	P,PRTOCT##
	PUSHJ	P,CRLF##
	PJRST	PRTCRS		;Output ORP620 and IRP620
SUBTTL	IRING message type dispatch table

TYPTRN:	PHASE	0		;Use XCT TYPTRN(P1)
TYP.00:	 STOPCD (,XCT,TTYBMT)	; 0 ILLEGAL
TYPANS:	JRST	RCVANS		; 1 KMC ANSWERED, IGNORED BY KL & KI
TYPSHT:	AOJA	P4,SCNIN1	; 2 SHUT, IGNORE
TYPRES:	JRST	RCVRES		; 3 BASE CRASHED AND RELOADED OR DR-11 DIED
TYPRAK:	JRST	RCVRAK		; 4 BASE ACK TO MESSAGE TYPE 3
TYPNSP:	JRST	RCVNSP		; 5 TAKEOVER OF BASE, RESET AUX CIRS
TYPLOG:	JRST	LOGIN		; 6 START LOGIN PROCESS ON THIS PORT
TYPAUX:	JRST	RCVAUX		; 7 AUX CIRCUIT PORT ESTABLISHED
TYPNOP:	PUSHJ	P,NOOUT		;10 BACKPRESSURE ON
TYPOUP:	PUSHJ	P,DOOUT		;11 BACKPRESSURE OFF
TYPGOB:	PUSHJ	P,GOBCHR	;12 CHR. GOBBLER, CLEAR INPUT BUFFER
TYPZAP:	PUSHJ	P,RCVZAP	;13 CIRCUIT ZAPPER
TYPEDC:	PUSHJ	P,EDEC		;14 ENTER DEFFERED ECHO MODE
TYPLDC:	PUSHJ	P,LDEC		;15 LEAVE DEFERRED ECHO MODE
TYPGRN:	JRST	GREEN		;16 GREEN BALL
TYPRED:	JRST	RED		;17 RED BALL
TYPYEL:	PUSHJ	P,YELLOW	;20 YELLOW BALL
TYPORG:	PUSHJ	P,ORANGE	;21 ORANGE BALL
TYPHNG:	AOJA	P4,SCNIN1	;22 HANG, IGNORE
TYPETM:	AOJA	P4,SCNIN1	;23 ENTER 2741 TRANSPARENT MODE
TYPLTM:	AOJA	P4,SCNIN1	;24 LEAVE 2741 TRANSPARENT MODE
TYPLOS:	PUSHJ	P,RCVLOS	;25 LOST BALL (CHARACTERS LOST ON INPT)
TYPSUP:	 STOPCD (,XCT,TTYBMT)	;26 SUPERVISOR REQUEST
TYPSUR:	JRST	RCVSUR		;27 SUPERVISOR RESPONSE
TYPAXC:	 STOPCD (,XCT,TTYBMT)	;30 AUX CIRCUIT CHARACTER
TYPTSP:	 STOPCD (,XCT,TTYBMT)	;31 TEST PROBE
TYPTSR:	AOJA	P4,SCNIN1	;32 TEST RESPONSE, IGNORE
TYPSAD:	 STOPCD (,XCT,TTYBMT)	;33 HOST SAD
TYPECN:	 STOPCD (,XCT,TTYBMT)	;34 ECHO ON, SHOULD NOT COME IN
TYPECF:	 STOPCD (,XCT,TTYBMT)	;35 ECHO OFF, SHOULD NOT COME IN
TYPTCS:	 STOPCD (,XCT,TTYBMT)	;36 SEND TERMINAL CHRS. SHOULD NOT COME IN
TYPTCP:	 STOPCD (,XCT,TTYBMT)	;37 TERM CHRS PROBE. SHOULD NOT COME IN
TYPTCR:	JRST	RCVTMC		;40 TERM CHRS RESPONSE
TYPHSI:	 STOPCD (,XCT,TTYBMT)	;41 PORT AND SYSTEM NUMBER
TYPCLP:	 STOPCD (,XCT,TTYBMT)	;42 REQUEST FOR SUPERVISOR TIME
TYPCLR:	JRST	CLKRSP		;43 CLOCK RESPONSE FROM SUP.
TYPBKO:	 STOPCD (,XCT,TTYBMT)	;44 INITIATE BLOCK OUTPUT
TYPBOC:	PUSHJ	P,BLKOHR	;45 BLOCK OUTPUT COMPLETE SAME AS TERMINATED
TYPBIN:	 STOPCD (,XCT,TTYBMT)	;46 INITIATE BLOCK INPUT
TYPINB:	PUSHJ	P,BLKIBF	;47 BLOCK INPUT TERMINATED: OUT OF BUFFER
TYPINE:	PUSHJ	P,BLKEOT	;50 BLOCK INPUT TERMINATED: END OF TRANSMISSION
TYPINT:	PUSHJ	P,BLKITM	;51 BLOCK INPUT TERMINATED: TIMEOUT BY BASE
TYPIRQ:	 STOPCD (,XCT,TTYBMT)	;52 REQUEST BLOCK INPUT TERMINATION
TYPIHR:	PUSHJ	P,BLKIHR	;53 BLOCK INPUT TERMINATED: BY HOST REQUEST
TYPORQ:	 STOPCD (,XCT,TTYBMT)	;54 REQUEST BLOCK OUTPUT TERMINATION.
TYPOHR:	PUSHJ	P,BLKOHR	;55 BLOCK OUTPUT TERMINATED: BY HOST REQUEST
TYPNEG:	JRST	BLKNEG		;56 NEGOTIATE FOR NUMBER OF BLOCK I/O PORTS
TYPBRK:	AOJA	P4,SCNIN1	;57 BREAK, IGNORE FOR NOW
TYPPSR:	JRST	RCVPS		;60 PORT STATUS RECEIVED (not used)
TYPEAD:	AOJA	P4,SCNIN1	;61 ENTER ALTERNATE DEVICE MODE, IGNORE
TYPLAD:	AOJA	P4,SCNIN1	;62 LEAVE ALTERNATE DEVICE MODE, IGNORE
TYPKAF:	 STOPCD (,XCT,TTYBMT)	;63 SET KEEP-ALIVE FAILURE TIMER
	DEPHASE

MXTYP==.-TYPTRN-1
SUBTTL NON-CHARACTER INPUT HANDLER ROUTINES

GOBCHR:	HRRZ	F, LDBDDB(U)
	JUMPE	F, SIMRZP		;IF NO JOB, TREAT AS ZAPPER
	LDB	J, PJOBN
	MOVE	T2, JBTSTS(J)
	TLNN	T2, JLOG		;IF NOT LOGGED-IN,
	 JRST	SIMRZP			;  TREAT AS ZAPPER
	AOJ	P4, GOBCH1
FRCCGB:	HRRZ	F, LDBDDB(U)
	JUMPE	F, GOBCH2		;IF IT'S ATTACHED
	LDB	J, PJOBN
GOBCH1:	LDB	T1, DDPTCG
	JUMPE	T1, GOBCH2		;AND IT'S TRAPPING GOBBLERS,
	PUSHJ	P, TAKTRP		;  TAKE THE TRAP
GOBCH2:	MOVEI	T1, LXRCGS
	IORM	T1, LDBDCX(U)		;SET CHARACTER-GOBBLER SEEN
	PJRST	TSETBI			;CLEAR THE INPUT BUFFERS

NOOUT:	AOJ	P4,
FRCNOO:	LDB	T1, LOPZAP
	JUMPN	T1, CPOPJ		;IF ABOUT TO SEND ZAPPER, DO NOTHING
	MOVSI	T1, LDLNOP
	IORM	T1, LDBDCH(U)		;SET BACKPRESSURE FLAG
	DPB	T1, LDBOPB(U)		;CLEAR NEED-OUTPUT
	POPJ	P,

DOOUT:	AOJ	P4,
FRCDOO:	MOVSI	T1, LDLNOP
	ANDCAM	T1, LDBDCH(U)		;CLEAR BACKPRESSURE FLAG
	MOVEI	T1, 1
	DPB	T1, LDBOPB(U)		;SET NEED-OUTPUT
	POPJ	P,

;Here for message 06 - externally initiated login request

LOGIN:	MOVE	T1,LDBLIN(U)
	TLNE	T1,LNLZIN		;IF THERE'S AN UNECHOED ZAPPER,
	 JRST	[MOVEI	T1,NZAPLG
		 PUSHJ	P,ZAPBUG	;NOTE IT
		 JRST	.+1	]
	SKIPE	LDBLOG(U)		;IF LOGGED-IN OR LOGGING IN,
					;  TREAT AS CIRCUIT ZAPPER
	  JRST	[PUSHJ	P,ZAPLOG	;NOTE THE ZAP (increment P4)
		 JRST	SCNIN1]		;  Return to loop

	MOVEI	T1,1B32			;This bit will be shifted to
	MOVEM	T1,LDBLOG(U)		; 1B0 after reading 4 characters
	LDB	T1,INPDL2		;Get 3rd+4th byte of login message
	LDB	T2,[POINT 16,BASVER,31]	;Check version of base code
	CAIL	T2,<02_^D8>+01		;If EBUS version 2.01 or later,
	 DPB	T1,LDPHST		; store originating host number
	SETZM	LDBMOD(U)		;NOTHING SO FAR
	AOJA	P4,SCNIN1

PRINTF (<[BUG at LDEC has not been completely fixed, causes TTYNNC]>)
LDEC:	SKIPE	LDBECC(U)		;ARE WE STILL ECHOING?
	 JFCL	ZAPDFR			;YES, TREAT AS CIRCUIT ZAPPER
	MOVSI	T1,LDLDEF
	TLNN	U,LDLAUX		;NOT FOR AUX CIRCUITS
	 ANDCAM	T1,LDBDCH(U)		;RESET DEFERED ECHO FLAG
	AOJA	P4,SETLMD		;AND RESET LINE MODE

EDEC:	MOVSI	T1,LDLDEF
	TLNN	U,LDLAUX
	 IORM	T1,LDBDCH(U)		;ENTER DEFFERED ECHO MODE
	AOJA	P4,SETLMD
GREEN:	MOVEI	T1, 1
	DPB	T1, LOPSGR	;SET SEND-GREEN-BALL FLAG
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT BIT
	AOJA	P4, SCNIN1

RED:	MOVEI	T1, 0
	DPB	T1, LOPSGR	;CLEAR SEND-GREEN-BALL FLAG
	MOVEI	T1, 1
	DPB	T1, LOPSRD	;SET SEND-RED
	DPB	T1, LDBOPB(U)	;AND WANNA-OUTPUT
	AOJA	P4, SCNIN1

ORANGE:	AOJ	P4,
FRCORG:	PUSHJ	P, OBREC	;HANDLE INTERRUPT OR HIBER
	  JFCL
OBFND:	MOVSI	T1, L2LOWT
OBFND1:	ANDCAM	T1, LDBBYT(U)	;CLEAR ORANGE-WAIT FLAG
	MOVEI	T1, 1
	DPB	T1, LDBOPB(U)	;SET NEED-OUTPUT (ZAP CODE MAY WAIT)
	POPJ	P,

YELLOW:	AOJ	P4,
FRCYEL:	IFN YLBUG, <
	PUSHJ	P, OBREC	;WAS JOB WAITING FOR AN ORANGE BALL?
	  JRST	.+2		;NO
	 JRST	OBFND		;YES, TREAT AS ORANGE BALL
	MOVSI	T1, L2LOWT
	TDNE	T1, LDBBYT(U)	;IS ZAP LOGIC WAITING FOR ORANGE?
	 JRST	OBFND1		;YES, TREAT AS ORANGE
	>
	MOVEI	T1, LXRYBS
	IORM	T1, LDBDCX(U)	;SET YELLOW-BALL-RECEIVED BIT
	HRRZ	F, LDBDDB(U)
	JUMPE	F, YELLW1	;IF IT'S ATTACHED,
	LDB	T1, DDPTYB
	JUMPE	T1, YELLW1	;AND IT'S TRAPPING YELLOW BALLS,
	PUSHJ	P, TAKTRJ	;  TAKE THE TRAP
	MOVSI	T1, LXLOOK
	IORM	T1, LDBDCX(U)	;  AND ALLOW JOB TO SEND 1 ORANGE BALL
	POPJ	P,		;OTHERWISE,
YELLW1:	MOVEI	T1, 1
	DPB	T1, LOPSOG	;  SET SEND-ORANGE
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
	POPJ	P,

ZAPDFR:	AOSA	DFRZAP		;RECORD NUMBER
ZAPLOG:	AOS	LOGZAP		; NOTE THE ZAP
	MOVEM	U,ZAPLPT	; SAVE PORT LDB ADDRESS
	PUSHJ	P,ZAPBG0	;Save info, but use different stopcode
	 STOPCD (.+1,DEBUG,TTYZNE,PRTIRG,<Zapper not echoed for port>)
	PJRST	SIMRZP		; Simulate/force a zap (increment P4)
	
SUBTTL	BLKIBF - HERE WHEN A TYPE 47 (INPUT BUFFER FULL) IS RECEIVED
;	   FROM THE BASE.

BLKIBF:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCIBF:	PUSHJ	P,BLKICK	; EVERYTHING OK?
TTYBNP:: STOPCD (FRCZAP,INFO,TTYBNP,,<Block mode io Not in Progress>) ;;FRCIBF+1
	JUMPE	F, FREBUF	; DETACHED: GIVE UP

    ;STORE THE CHARACTER COUNT INTO THE USER'S BUFFER

BLKIB1:	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDR
	HRRZM	T4, BIOCHR(T1)	; STORE THE COUNT

    ;WAKE/INTERRUPT THE JOB

BLKIB2:	PUSHJ	P, BIOWAK	; WAKE UP JOB
	MOVEI	T1, LXRBRK
	IORM	T1, LDBDCX(U)	; SET BIT FOR POLPRT
	LDB	T1, DDPTLN	; IF INTERRUPT-ON-BREAK ENABLED
	PUSHJ	P, TAKTRJ	; TAKE IT

    ;FREE THE BUFFER (AND, IF NO OUTPUT PENDING, THE BASE PORT)
    ;IF THE PORT HAS LEFT BLOCK MODE

BLKIB3:	MOVSI	T2, LMLBIO
	TDNN	T2, LDBMOD(U)	; BLOCK I/O ENABLED?
	PJRST	FREBUF		; NO: FREE THE BUFFER
	POPJ	P,

;BLKEOT - HERE WHEN A "INPUT TERMINATED - END OF TRANSMISSION"
; (TYPE 50) IS RECEIVED FROM THE BASE.

BLKEOT:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCEOT:	PUSHJ	P, BLKICK	; EVERYTHING OK?
	 STOPCD (,XCT,TTYBNP)	;Block mode io Not in Progress ;;FRCEOT+1
	PJUMPE	F, FREBUF	; DETACHED: GIVE UP
	LDB	T1, DDPMOD	; T1/ DATA MODE
	CAIN	T1, B
	JRST	BLKIB1		; BINARY: JUST RETURN THE DATA
IMGITM:	PUSHJ	P, BLKTRQ	; REQUEST INPUT TERMINATION
IMGIT2:	MOVSI	S, IOEND
	IORB	S, DEVIOS(F)	; SET IOEND
	JUMPN	T4, BLKIB1	; COUNT .gt. 0: RETURN THE DATA
	PUSHJ	P, RELBI	; COUNT = 0: DONE WITH BLOCK INPUT
	JRST	BLKIB2		; WAKE THE JOB AND RETURN
SUBTTL	BLKITM - HERE WHEN AN "INPUT TERMINATED - TIMEOUT BY BASE"
; (TYPE 51) MESSAGE IS RECEIVED FROM THE BASE.

BLKITM:	LDB	T4,INPDL2	; T4/ COUNT
	AOJ	P4,
FRCITM:	PUSHJ	P,BLKICK	; EVERYTHING OK?
	  POPJ	P,		; NO: IGNORE THE MESSAGE
	PJUMPE	F, FREBUF	; DETACHED: GIVE UP
	MOVEI	S, IOBKTL
	IORB	S, DEVIOS(F)	; SET IO.BKT
	LDB	T1, DDPMOD	; T1/ DATA MODE
	CAIN	T1, I
	JRST	IMGITM		; IMAGE: REQ TRM, RETURN DATA
	JUMPN	T4, BLKIB1	; COUNT.gt.0: WAKE JOB, RETURN DATA

    ;HERE WHEN NOT IN IMAGE MODE, TO REPEAT THE REQUEST

	MOVE	T1, LDBMOD(U)
	TLNE	T1, LMLTBI	; TERMINATE PENDING?
	 POPJ	P,		; YES: DON'T REREQUEST INPUT
	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	HRRZ	T2, BIOCHR(T1)	; T2/ SAME COUNT AS BEFORE
	PJRST	BLKIRQ		; REQUEST INPUT

;FREBUF - CALLED WHEN A PORT WITH LMLBIO CLEAR RECEIVES
;	   A BLOCK INPUT TERMINATED MESSAGE

FREBUF:	PUSHJ	P, RELBI	; DONE WITH BLOCK INPUT
	JUMPN	T1, CPOPJ	; IF NO PENDING OUTPUT,
	PJRST	DECBC		;   FLAG 1 FEWER BLOCK PORT

; BLKICK - COMMON SUBROUTINE FOR BLOCK-INPUT-TERMINATED
;	    MESSAGES.

BLKICK:	HRRZ	T1,LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	SKIPE	T1		; IF NO BUFFER
	SKIPL	BIOCHR(T1)	; OR NO REQUEST PENDING
	 POPJ	P,		; FAIL-RETURN
	HRRZ	F,LDBDDB(U)	; F/ DDB
	AOS	(P)
	POPJ	P,
SUBTTL	BLKIHR - HERE WHEN "INPUT TERMINATED - BY HOST REQUEST"
; (TYPE 52)MESSAGE IS RECEIVED FROM THE BASE.

BLKIHR:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCIHR:	MOVSI	T1, LMLTBI
	ANDCAM	T1, LDBMOD(U)	; CLEAR TERMINATE-PENDING FLAG
	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	SKIPN	T1		; IF THERE'S NONE THERE,
	POPJ	P,		;   NOTHING MORE TO DO
	MOVE	T2, BIOCHR(T1)	; T2/ IN-PROGRESS FLAG,,COUNT
	JUMPGE	T2, BLKIB3	; NO BLOCK INPUT IN PROGRESS
	HRRZ	F, LDBDDB(U)	; F/ DDB
	PJUMPE	F, FREBUF	; DETACHED: FREE THE BUFFER
	JRST	IMGIT2		; SET IOEND, RETURN DATA

;BLKOHR - HERE WHEN AN "OUTPUT TERMINATED" (TYPE 52)
;	   OR AN "OUTPUT TERMINATED BY HOST REQUEST" (TYPE 53)
;	   MESSAGE IS RECEIVED FROM THE BASE

BLKOHR:	AOJ	P4,
	MOVSI T1,LDLNOP
	ANDCAM T1,LDBDCH(U)	;CLEAR OUTPUT BACKPRESSURE
	MOVEI T1,1
	DPB T1,LDBOPB(U)	;AND SET NEED-OUTPUT BIT
FRCOHR:	HLRZ T1,LDBBIO(U)	;T1/ OUTPUT BUFFER
	JUMPE T1,BLKOH1		;IF NONE, DO (ALMOST) NOTHING
	PUSHJ P,RELBO		;DONE WITH BLOCK OUTPUT
	JUMPN T1,BLKOH1		;IF NO ACTIVE BLOCK I/O
	MOVE T2,LDBMOD(U)
	TLNN T2,LMLBIO		;AND PORT WANTS OUT OF BLOCK MODE,
	PUSHJ P,DECBC		;  GET IT OUT
BLKOH1:	HRRZ F,LDBDDB(U)
	JUMPE F, CPOPJ		;IF ATTACHED,
	PJRST XMTWAK		;WAKE THE JOB
IFNCPU (<KI,KL>), <
BLKNEG:	 STOPCD (,XCT,TTYBMT)	;56 NEGOTIATE FOR # BLOCK I/O PORTS NOT USED
>; END IFNCPU (<KI,KL>)

IFCPU (<KI,KL>), <
;SNDBIO - HERE AT CHANNEL 7 LEVEL FROM SCNINT WHEN THERE ARE
;ANY BLOCK I/O PORT REQUESTS (EITHER INCREASE OR DECREASE)
;PENDING.

SNDBIO:	PUSHJ	P,CLSCHR	;FINISH PREVIOUS MESSAGE AND
	  POPJ	P,		; RETURN IF NO MORE SPACE.
	MOVSI	P3,TYPI TYPNEG	;PORT REQUEST TYPE FOR
;Following code commented out since there are no KMC's on
; KI's and KL's.
;IFKMC<	PUSHJ	P,MDRUP		;GET UP DRs
;	JUMPE	T1,CPOPJ	;IF NO NODES ARE UP THEN GIVEUP
;	SKIPA			;Don't shift the first time
;SNDBI1: LSH	T1,-3
;	TRNN	T1,7		;NO SKIP IF LOW 3 BITS ARE ALL 0s
;	  JRST	SNDBI1		;Go try the next one
;	SUBI	T1,1
;	ANDI	T1,3
;	LSH	T1,6
;	DPB	T1,WRPLIN	;STUFF THE UP DR NUMBER IN PORT
;>;IFKMC.END
	HRRZS	T1,BIOCNT+0	;GET THE NEW REQUEST COUNT
	DPB	T1,WRPCHR	;AND WRITE INTO 1ST DATA CHAR
	AOS	BIOANS		;INC RESP COUNT EXPECTED OF BASE
	JRST	WRDOUT		;SEND THE REQUEST AND SKIP RETURN.

;BLKNEG - AT SNDBIO, WE SENT A TYPE 54, ASKING FOR <BIOCNT+0>
;BLOCK I/O PORTS. WE GET HERE WHEN WE GET A TYPE 54 BACK FROM
;THE BASE, TELLING US HOW MANY WE CAN HAVE.

BLKNEG:	SKIPG	BIOANS		;IF WE DIDN'T SEND A REQUEST
	JRST	[
		AOS ERRBNG
		AOJA P4, SCNIN1	;  IGNORE THE "RESPONSE"
	]
	SOSG	BIOANS		;IF THERE'RE MORE RESPONSES COMING
	SKIPGE	T2,BIOCNT+0	;OR THERE'S ANOTHER REQUEST PENDING,
	AOJA	P4,SCNIN1	;  IGNORE THE RESPONSE
	LDB	T4,INPCHR	;T4/ # OF PORTS WE CAN HAVE
	MOVN	T1,T4
	ADD	T1,BIOPRT	;T1/ #PORTS BEFORE - #PORTS NOW
	JUMPE	T1,BLKNG4
	JUMPLE	T1,BLKNG2
	CAML	T2,BIOPRT	;IF NOW .LT. BEFORE .LE. #JOBS
	 STOPCD 		;  SOMEONE'S GOING THE WRONG WAY
BLKNG2:	MOVE	T2,BPREQ	;T2/ OLD BLOCK-PORT-REQ
	ADDM	T1,BPREQ	;UPDATE BPREQ
	JUMPLE	T2,BLKNG3	;IF SOMEONE WAS IN BLOCK-PORT WAIT
	SKIPG	T1		;AND THERE'RE MORE PORTS NOW,
	SETOM	BPAVAL		;  TELL THE SCHEDULER
BLKNG3:	MOVEM	T4,BIOPRT	;SET THE NEW # OF PORTS
BLKNG4:	SKIPN	J,BIOJOB	;IF THERE'S A JOB IN AX WAIT,
	AOJA	P4,SCNIN1
	SETZM	BIOJOB
	MOVEI	T1,RNQ
	DPB	T1,PJBSTS##
	PUSHJ	P,SETRUN	;  WAKE IT UP
	AOJA	P4,SCNIN1
> ;END IFCPU (<KI,KL>)
SUBTTL	HERE WHEN A "CHARACTERS LOST" MESSAGE (BUFFER ZAP) IS
;RECEIVED: IF THE DATA BYTE IS 0, OUTPUT CHARACTERS WERE
;LOST; OTHERWISE, INPUT CHARACTERS WERE LOST

RCVLOS:	AOJ	P4,
	AOS	TTYLOS		;RECORD CHARACTER LOST BY TYMNET
	LDB	T1,INPCHR	;T1/ DIRECTION
FRCLOS:	SKIPN	T1
	TROA	T1,LXROCL	; 0 = OUTPUT LOST
	MOVEI	T1,LXRICL	; 1 = INPUT LOST
	IORM	T1,LDBDCX(U)
	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ		;NOTHING TO DO IF NO DDB
	MOVEI	T1,IOBKTL
	IORM	T1,DEVIOS(F)	;SET ERROR FLAG
	LDB	T1,DDPTLC
	PJRST	TAKTRJ		;SET TO INTERRUPT

;HERE WHEN A TERMINAL CHARACTERISTICS VALUE IS RECEIVED

RCVTMC:	LDB	T1,INPCH2	;VALUE
	LDB	T2,INPCHR	;AND TYPE NUMBER
	CAILE	T2,MAXTMC	;CHECK RANGE
	 JRST	RCVTCX		;(BAD)
	DPB	T1,TABTMR(T2)
	AOJA	P4,SCNIN1	;FINISHED

RCVTCX:
;*;	CAILE	T2,<MAXTMC+TMCSLP>
;*;	 STOPCD			;AMAZINGLY BAD
	AOS	TMCOOR		;SLIGHTLY BAD - BUMP OUT-OF-RANGE COUNT
	AOJA	P4,SCNIN1
SUBTTL	HERE WHEN THE TIME AND DATE ARE RECEIVED

CLKRSP:	LDB	T2,INPDL2	;GET HIGH ORDER BITS OF TIME
	ADDI	P4,1
	ANDI	P4,MSKIRG
	LDB	T1,INPDL1	;GET LOW ORDER BITS
	DPB	T2,[POINT 16,T1,19]
	IDIVI	T1,^D<24*60*60>	;DAYS IN T1, SEC IN T2
	ADDI	T1,^D3653	;Convert 1-JAN-74 to 1-JAN-64
	IMUL	T2,JFYSEC
	EXCH	T1,T2		;Time in T1, Date in T2
	PUSHJ	P,COMGMS##	;Set GMT time (in UUOCON)
	MOVE	T1,DATE##	;Remember the date/time of when
	MOVEM	T1,SUPTIM##	; the Supervisor saw us
	AOJA	P4,SCNIN1

;HERE WHEN A PORT STATUS MESSAGE IS RECEIVED (see comment at ACPSM)

RCVPS:	LDB	T1,INPCHR	; GET THE 4 BITS
	DPB	T1,LDPPSM	; STORE PORT STATUS MSG
	MOVEI	T1,LXRPSS
	IORM	T1,LDBDCX(U)	; AND NOTE THAT IT'S BEEN SEEN
	MOVSI	T1,LMLPSP
	IORM	T1,LDBMOD(U)
	HRRZ	F,LDBDDB(U)
	JUMPE	F,PSDONE	; NO TRAP IF NO DDB
	LDB	T1,DDPTPS
	PUSHJ	P,TAKTRJ	; SET TO INTERRUPT
PSDONE:	AOJA	P4,SCNIN1	; DONE
SUBTTL	HERE WHEN A CIRCUIT ZAPPER IS RECEIVED

RCVZAP:	AOS	NZAPIN		;# REAL, TRUE ZAPPERS IN
	MOVE	T1,LDBLIN(U)	;Mark as zapper coming from TYMNET
	TLOE	T1,LNLZIN	;If there's one already in,
	 JRST	[MOVEI	T1,NZAPN2
		 PUSHJ	P,ZAPBUG  ;NOTE IT
		 JRST	SIMRZP	]
	MOVEM	T1,LDBLIN(U)
SIMRZP:	ADDI	P4,1		;Skip past the zap command in IRING

;Enter at FRCZAP to pretend we received a zapper from the base

FRCZAP:	SETZM	LDBOUT(U)		;Cancel any pending output bits
	MOVSI	T1,L2LOWT
	ANDCAM	T1,LDBBYT(U)		;Cancel wait for orange ball
	SKIPL	LDBLOG(U)		;If port's not logged-in,
	 JRST	[SETZB	T1,LDBLOG(U)	; cancel "login in progress"
		 DPB	T1,LDPHST	;Clear host number
		 MOVEI	T1,1
		 DPB	T1,LOPZAP	;Set send-zapper
		 DPB	T1,LDBOPB(U)	; and need-output
		 MOVSI	T1,LDLNOP
		 ANDCAM	T1,LDBDCH(U)	;Ignore backpressure
		 POPJ	P,	]
	MOVSI	T1,LLLNLN!LLLZAP	;Line not there (TYMNET has zapped it)
	IORM	T1,LDBLOG(U)		;Mark port as externally zapped
	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO		;IF BLOCK-MODE SET,
	SKIPE	LDBBIO(U)		;OR BLOCK I/O'S STILL IN PROGRESS,
	 PUSHJ	P,BIOZAP		;  RELEASE BUFFERS & CLEAR BLOCK-MODE
	TLNE	U,LDLAUX		;IF IT'S AN AUX PORT
	 PJRST	ZAPAUX
	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)		;OR AT ANY RATE NOT A COMMAND PORT,
	 PJRST	ZAPAUX			;  DETACH & TRY TO FREE DDB

    ;HERE WHEN A ZAPPER IS RECEIVED ON A JOB'S COMMAND PORT

	LDB	J,PJOBN			;J/ DON't FORCE,,JOB#
	PUSHJ	P,HNGTTY		;Force hangup for job/frame
	POPJ	P,
SUBTTL INPUT CHARACTER HANDLER

CHRMLT:	SKIPN	LDBLOG(U)		;MIGHT BE LINE WE HAVE JUST
	 JRST	MLTNDB			; SENT ZAPPER ON, FIX INPUT RING
	MOVEI	T1,IRING(P4)
	HRLI	T1,(POINT 8,0,BYP2)	;SET UP A BYTE POINTER
	MOVEM	T1,CHRRDP
CHRML1:	UUILDB	T3,CHRRDP
	PUSHJ	P,MOVCHR
	 SOJG	P1,CHRML1		;CONTINUE
	JUMPG	P1,CHRML3		;HERE AT END OR DEF ECHO MODE
CLRMLT:
;;;;;;;; MORE KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKMC<	MOVE	P1,IRPMSG
	CAME	P1,IRING(P4)
	 STOPCD 		;CRASH ON KMC IRING OVERWRITE or bad P4
>;END_IFKMC
;;;;;;;; END KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	LDB	P1,INPTYP		;NOW CLEAR OUT THE INPUT RING
	TRZ	P1,200			;GET COUNT BACK
	HRRZ	F,LDBDDB(U)		;CHARGE
	JUMPE	F,MLTNDB
	LDB	T1,PJOBN
	ADDM	P1,JBTCIN(T1)
	ADDM	P1,JBTCIN		;System-wide # of characters input
MLTNDB:	ADDI	P1,5	;GET NUMBER OF WORDS USED (2 BYTES FOR COUNT AND PORT)
	LSH	P1,-2
	ADD	P4,P1			;INCREMENT POINTER BY NUMBER USED
	JRST	SCNIN1

CHRML2:	UUILDB	T3,CHRRDP
	PUSHJ	P,MOVCHR		;THIS IS THE DEFERED ECHO LOOP
	 JFCL				;SHOULD NOT BE GETTING HERE
CHRML3:	SOJG	P1,CHRML2
	MOVEI	T1, 1
	DPB	T1, LOPECO		;SET SEND-ECHO
	DPB	T1, LDBOPB(U)		;AND NEED-OUTPUT
	JRST	CLRMLT
SUBTTL	CALLED WITH CHARACTER IN T3. DISPATCH ON CHARACTER TYPE AND LINE MODE

MOVCHR:	LDB	P2,LDPMIN	;Get the input mode
	TRNN	T3,200
MOVCH2:	SKIPA	P3,CHRTAB(T3)	;Get character bits
	MOVE	P3,CHRTAB-200(T3)
	LDB	T2,CHPINP	;GET INPUT TYPE
MOVCH1:	XCT	CIMTAB(P2)	;DO THE RIGHT THING FOR THE LINE MODE
	JRST	(T1)		;THIS WILL USUALLY LOAD AN ADDRESS IN T1

;LINE MODE DISPATCH TABLE

CIMTAB:	JRST	LOGCHR		;LOGIN
	JRST	IMGDEF		;IMAGE,DEF ECHO
	JRST	IMGRMA		;IMAGE,REM ECHO,BKA=1
	JRST	IMGRMT		;IMAGE,REM ECHO,BKA=0
	HLRZ	T1,MD0405(T2)	;NORMAL,DEF ECHO,BK2=0
	HRRZ	T1,MD0405(T2)	;NORMAL,DEF ECHO,BK2=1
	HLRZ	T1,MD0607(T2)	;NORMAL,REM ECHO,BKA=1,BK2=0
	HRRZ	T1,MD0607(T2)	;NORMAL,REM ECHO,BKA=1,BK2=1
	HLRZ	T1,MD1011(T2)	;NORMAL,REM ECHO,BKA=0,BK2=1
	HRRZ	T1,MD1011(T2)	;NORMAL,REM ECHO,BKA=0,BK2=0
	HLRZ	T1,MD1213(T2)	;COMMAND,REM ECHO
	HRRZ	T1,MD1213(T2)	;COMMAND,DEF ECHO

;CHARACTER TYPE DISPATCH TABLES

; CHARACTER TYPES FOR INPUT
;
; 0 - SPECIAL ACTION
; 1 - NORMAL CHARACTER
; 2 - BREAK (CONTROL) CHARACTER
; 3 - BREAK2 (PUNCTUATION) CHARACTER

MD0405:	IACT0,,IACT0	; 0,, 0
	IACT1,,IACT1	; 1,, 1
	IACT2,,IACT2	; 2,, 2
	IACT3,,IACT4	; 3,, 4

MD0607:	IACT0,,IACT0	; 0,, 0
	IACT5,,IACT5	; 5,, 5
	IACT6,,IACT6	; 6,, 6
	IACT7,,IACT10	; 7,,10

MD1011:	IACT0,,IACT0	; 0,, 0
	IACT11,,IACT11	;11,,11
	IACT6,,IACT6	; 6,, 6
	IACT10,,IACT12	;10,,12

MD1213:	IACT0,,IACT0	; 0,, 0
	IACT13,,IACT21	;13,,21
	IACT14,,IACT22	;14,,22
	IACT15,,IACT17	;15,,17
SUBTTL	THIS ROUTINE IS CALLED BY ALMOST EVERYONE TO PUT A CHR INTO
;THE INPUT BUFFER

RCVCHR:	MOVE	T4,TTFREN
	CAIG	T4,TIRSVD
	 JRST	RECHLT		;OUT OF BUFFERLETS. GIVE HIM BELL
	MOVE	T4,LDBTIC(U)
	ADD	T4,LDBECC(U)
	CAML	T4,TIWRNN	;OVER SMALL QUOTA?
	 JRST	RWARN		;TRY TO STOP HIS INPUT
RCVCH1:	PUSHJ	P,CHRTRP	;TAKE A CHARACTER TRAP
	SKIPN	T2,LDBTIP(U)
	 PUSHJ	P,RECVRG	;MUST SET UP THE INPUT POINTERS
	PUSHJ	P,TTPUTC	;PUT THE CHR IN THE BUFFER
	MOVEM	T2,LDBTIP(U)
	AOS	LDBBKI(U)
	MOVSI	T1,L2LDEL	;SHOULD WE RESET THE \ FLAG?
	TDNN	T1,LDBBYT(U)
	 JRST	RCVCH2		;NOT ON
	PUSH	P,T2
	MOVEI	T3,"\"
	PUSHJ	P,ENTRUB
	MOVEI	T1,1
	DPB	T1,LOPRUB	;SET SEND-RUBOUT
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POP	P,T2
RCVCH2:	MOVSI	T1,L2LDEL!L2LCCS
	ANDCAM	T1,LDBBYT(U)
	AOS	(P)
	POPJ	P,

RECVRG:	PUSHJ	P,GETCHK
	MOVEM	T2,LDBTIP(U)	;SET UP INPUT POINTERS
	MOVEM	T2,LDBTIT(U)
	MOVEM	T2,LDBECT(U)
	SETZM	LDBBKI(U)
	SETZM	LDBBKP(U)
	SETZM	LDBTIC(U)
	SETZM	LDBECC(U)
	SETZM	LDBBKC(U)
	SETZM	LDBBK2(U)
	POPJ	P,
RWARN:	CAML	T4,TIHLTN	;OVER LARGE QUOTA?
	 JRST	RWARN1		;YES: GO SEE HOW BADLY WE LOST
	MOVEI	T1,1
	DPB	T1,LOPBPN	;NO: SET BACKPRESSURE-ON
	DPB	T1,LDBOPB(U)	;    AND NEED-OUTPUT
	JRST	RCVCH1

RWARN1:	LDB	T1,LOPBPN	;STILL WAITING TO SEND BACKPRESSURE?
	SKIPE	T1
	 AOSA	LOSPDP		;YES: WE'RE TOO SLOW
	AOS	LOS620		;NO: BACKPRESSURE BROKEN
	PFALL	RECHLT		;SEND BELL AND DROP CHARACTERS

RECHLT:	AOS	TTYRHT		;RECORD CHARACTER LOST
	MOVEI	T1,LXRICL
	IORM	T1,LDBDCX(U)	;NOTE THE DIRECTION
	HRRZ	F,LDBDDB(U)
	JUMPE	F,RECHT1
	MOVEI	T1,IOBKTL	;SET IO.BKT
	IORM	T1,DEVIOS(F)
	LDB	T1,DDPTLC	;IF CHARACTERS-LOST ENABLED
	PUSHJ	P,TAKTRJ	;TAKE IT
RECHT1:	MOVEI	T1,1
	DPB	T1,LOPSBL	;SET SEND-BELL
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,
SUBTTL	HERE ON A LOGIN CHARACTER (ONE OF FIRST 4 ON LINE)

LOGCHR:	SKIPG	T4,LDBLOG(U)	;Are we really logging him in?
	 POPJ	P,		;No, return from MOVCHR
	LSH	T4,^D8		;Put login char
	IOR	T4,T3		; into
	MOVEM	T4,LDBLOG(U)	;  LDBLOG
	JUMPGE	T4,CPOPJ	;More to come

;WE'VE RECEIVED THE 32 BITS OF LOGIN DATA FROM TYMNET - NOW LOG THE LINE IN

	AOS	INTERM		;COUNT 1 MORE LINE LOGGED-IN
	LDB	T1,TRMBYP	;T1/ TERMINAL ID CODE
	MOVE	T1,TRMTAB(T1)	;T1/ IBM,FAST,FC1,FC2,WIDTH CODES
	TLNN	T1,200000	;FAST TERMINAL?
	 TDZA	T3,T3		;NO
	MOVSI	T3,LXL120	;YES
	MOVEM	T3,LDBDCX(U)	;SET LDBDCX (0 EXCEPT FOR FAST BIT)
	MOVSI	T3,LDLDEF!LDLLCT!LDLCOM
	SKIPG	T1		;IS IT A 2741?
	 TLO	T3,LDLLCP	;YES: SET LOCAL-COPY FLAG
	SETZM	LDBBYT(U)	;MOST FIELDS ARE 0
	DPB	T1,LDPFC1	;SET FC1
	LSH	T1,-2
	DPB	T1,LDPFC2	;AND FC2
	LSH	T1,-2
	DPB	T1,LDPWID	;AND LINE WIDTH
	MOVSI	T1,LLLHDX
	TDNN	T1,LDBLOG(U)	;HALF-DUPLEX?
	 TDZA	T1,T1		;NO
	MOVEI	T1,1		;YES
	DPB	T1,LDPHDX	;SET THE CHARACTERISTIC
	SKIPN	T1		;IF IT'S HALF DUPLEX
	TLNE	T3,LDLLCP	;OR LOCAL-COPY (2741)
	TLZ	T3,LDLDEF	;DON'T SET DEFERRED ECHO
	MOVEM	T3,LDBDCH(U)
	SETZM	LDBCLA(U)	;[dws] clear terminal type
	MOVSI	T1,'TTY'
	MOVEM	T1,LDBTYP(U)	;Terminal type
	SETZM	LDBSTR(U)	;  CLEAR PREVIOUS CIRCUIT NAME
	HRRZI	T1,LDBSTR+1(U)	;  GET ADDRESS
	HRLI	T1,-1(T1)	;    STR,,STR+1
	BLT	T1,LDBSTR+AUXSTL-1(U)

	HLL	U,T3		;Make sure this matches LH<LDBDCH>
				; or aux cir test on next page fails

	;CLEAR RECEIVED CHARACTERISTICS

	ZZN==0
	REPEAT TMCSIZ,<
	SETZM	LDBTMR+ZZN(U)
	ZZN==ZZN+1>
	;SET TO ECHO CR AS CRLF, NOT ECHO CTRL-I,
	;NOT ECHO LF AS CRLF

	MOVEI	T1,0
	DPB	T1,LDSELF
	DPB	T1,LDSCIE
	MOVEI	T1,1
	DPB	T1,LDSECR
	MOVE	T1,[LTSELF!LTSCIE!LTSECR]
	MOVEM	T1,LDBTMT(U)

	SETZM	LDBOUT(U)	;CLEAR ALL SEND BITS BUT...
	MOVEI	T1,1
	DPB	T1,LOPSTC	;SET SEND-CHARACTERISTICS
	DPB	T1,LOPSTP	;AND SEND-PROBE
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	HRRZS	LDBDDB(U)	;CLEAR KJOB ETC. BITS
	MOVEI	T1,STSUPR	;200000
	TDNE	T1,STATES
	 JRST	LOGCH1		;System is super-shut, zap always
	TLNE	U,LDLAUX	;Is this an AUX circuit ?
	SKIPL	STATES		;Yes, is system plain shut ?
	 JRST	LOGCH2		;No, o.k. to log in
LOGCH1:	MOVEM	T1,LDBLOG(U)	;Must be non-zero and non-negative
	SOS	INTERM		;Leave INTERM alone in case
	JRST	TTYZAP		; of Auto-Restart

LOGCH2:	PUSHJ	P,SETLMD	;Set the line mode
;;
;; Here (finally!) to assign a frame for this port and initiate
;; LOGIN.
;;
	SETZ	F,		;Indicate no DDB assigned yet
	PUSHJ	P,FRMASN##	;Assign a free frame number
	  JRST	NEWJER		;No free frames...
	PUSHJ	P,TTYATI	;Attach a TTY DDB to this LDB
	  JRST	NEWTER		;No free TTY DDB's
	MOVEI	T1,CMFCXN##	;Forced command index for LOGIN
	PJRST	TTFORC		;Force a LOGIN command on this port

NEWJER:	MOVEI	T1,[ASCIZ /
frame capacity exceeded
/]
	PUSHJ	P,CONMES##	;Type out error message
	PJRST	TTYZAP		;Kill off TTY

NEWTER:	MOVEI	T1,[ASCIZ /
port capacity exceeded
/]
	PUSHJ	P,CONMES##	;Type out error message
	PJRST	FRMKJF##	;Free up frame slot and kill off TTY
;TERMINAL ID CODE = INITIAL TERMINAL CHARACTERISTICS TABLE

DEFINE TERCH (IBM,FAST,F1,F2,WIDTH)
	<BYTE (1) IBM,FAST (22) 0 (8) WIDTH (2) F2,F1>

TRMTAB:	TERCH (0,1,0,0,^D80)	;0    AUX circuit
	TERCH (0,0,0,0,^D80)	;1  A 300 baud
	TERCH (0,0,3,2,^D120)	;2  C 300 baud printer, wide carriage, delay
	TERCH (0,0,1,1,^D72)	;3  E 300 baud thermal printer, small delay
	TERCH (0,0,3,0,^D120)	;4  G 300 baud belt printer (GE Terminet), delay
	TERCH (0,0,1,1,^D72)	;5  B 150 baud Teletype 37, no parity
	TERCH (0,0,3,2,^D120)	;6  F 150 in, 300 out, Syner-Data Beta terminal
	TERCH (0,0,1,1,^D72)	;7  J 150 baud Teletype 37, even parity
	TERCH (0,0,1,1,^D72)	;8 CR 300 baud IBM 3767 in 2471 mode 32.4 cps
	TERCH (1,0,2,1,^D80)	;9 CR 134.5 baud IBM 2471 EBCDIC
	TERCH (0,0,1,1,^D72)	;10 D 110 baud Teletype ASR-33
	TERCH (0,0,1,1,^D80)	;11 I (was dot-matrix printer) SYNC - HSA
	TERCH (0,1,3,0,^D80)	;12 A,G,I 1200 baud (GOUGING=1, 120 cps)
	TERCH (0,1,0,0,^D80)	;13 Burroughs 1200 polled terminal
	TERCH (0,1,0,0,^D80)	;14 AUX through gateway
	TERCH (0,0,0,0,^D72)	;15 BAUDOT, 50 or 75 baud
	TERCH (0,1,3,0,^D80)	;16 A,G,I 2400 baud (GOUGING=2, 240 cps)
	TERCH (0,1,0,0,^D80)	;17   SYNC - Polled Terminals
	TERCH (0,1,0,0,^D80)	;18   SYNC - Point-to-Point
	TERCH (0,1,3,0,^D80)	;19 A,G,I 4800 baud (GOUGING=2, 240 cps)
	TERCH (0,1,3,0,^D80)	;20 A,G,I 9600 baud (GOUGING=3, 960 cps)
	TERCH (0,1,3,0,^D80)	;21 multiplexed PVC
	TERCH (0,1,3,0,^D80)	;22 audio response on T-1 carrier (56000 bps)
	TERCH (0,1,3,0,^D80)	;23 75 baud in 1200 out (VideoText)
	TERCH (0,1,3,0,^D80)	;24   SYNC - SDLC
	TERCH (0,1,3,0,^D80)	;25 Transaction Terminals
	TERCH (0,1,3,0,^D80)	;26 Host originated
	TERCH (0,1,3,0,^D80)	;27     unused
	TERCH (0,1,3,0,^D80)	;28     unused
	TERCH (0,1,3,0,^D80)	;29     unused
	TERCH (0,1,3,0,^D80)	;30     unused
	TERCH (0,1,3,0,^D80)	;31     unused
				;32-63   HDX same as 0-31 but with Half Duplex

TRMAUX==0	;CODE FOR AUX CIRCUIT
SUBTTL	HERE ON IMAGE MODE IN DEFERRED ECHO

IMGDEF:	TRO T3,400	;FLAG AS IMAGE CHARACTER
	MOVEI T1,IMGDIM
	DPB T1,LDPTIM	;RESET INPUT TIMER
	PUSHJ P,RCVCHR	;GET CHR INTO BUFFER
	 POPJ P,
	PUSHJ P,IMGCNT	;COUNT. IF T3 = IMAGE BREAK, T4 := TIWKC
DEFCHR:	CAIL T4,TIWKC	;IF IT'S A LINE'S WORTH,
DEFBRK:	PUSHJ P,LINTRP	;SET LINE TRAP BITS
DEFNBK:	AOS LDBECC(U)
	AOS (P)
	POPJ P,		;SKIP-RETURN TO START ECHOING

;HERE ON IMAGE MODE, REMOTE ECHO, BREAK ON ALL CHRS

IMGRMA:	TRO T3,400
	MOVEI T1,IMGDIM
	DPB T1,LDPTIM
	PUSHJ P,RCVCHR
	 POPJ P,
	PUSHJ P,IMGCHG	;CHARGE FOR AN IMAGE BREAK CHR
	PUSHJ P,USRWAK	;WAKE JOB IF ASLEEP
	LDB T1,LDPIMB
	CAME T1,T3	;IF IT'S THE IMAGE BREAK CHARACTER,
	CAIL T4,TIWKC	;OR IF THERE'S A LINEFULL,
	 PUSHJ P,LINTRP	;  SET TRAP BITS
	JRST IMGRM1

;HERE ON IMAGE MODE, REMOTE ECHO, NOT BREAK ON ALL

IMGRMT:	TRO T3,400
	MOVEI T1,IMGDIM
	DPB T1,LDPTIM
	PUSHJ P,RCVCHR
	 POPJ P,
	PUSHJ P,IMGCNT	;COUNT. IF T3 = IMAGE BREAK CHAR, T4 := TIWKC
	CAIGE T4,TIWKC	;IF IMAGE BREAK OR A LINE'S WORTH,
	 JRST IMGRM1
	PUSHJ P,USRWAK	;  WAKE UP JOB IF ASLEEP
	PUSHJ P,LINTRP	;  SET TRAP BITS
IMGRM1:	MOVEM T2,LDBECT(U)	;FIX ECHO POINTER
	AOS LDBTIC(U)
	POPJ P,
SUBTTL	NORMAL CHR DEF ECHO

IACT1:	PUSHJ P,RCVCHR
	 POPJ P,
	JRST DEFCHR

;BREAK CHR DEF ECHO

IACT2:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKC(U)	;RECODR BREAK CHR
IACT2A:	SETZM LDBBKI(U)		;RESET ^U POINTERS
	MOVEM T2,LDBBKP(U)
	JRST DEFBRK

;BREAK2 CHR DEF ECHO, NOT BREAK2 MODE

IACT3:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)
	ADDM T1,LDBBK2(U)	;COUNT BREAK2 AND IN ^U INFO
	JRST DEFCHR

;BREAK2 CHR DEF ECHO, BREAK2 MODE OR BREAK ON ALL AND BREAK2

IACT4:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBK2(U)	;RECORD BREAK2
	JRST IACT2A		;GO RESET ^U POINTER

;NORMAL CHR, RMT ECHO, BREAK ON ALL

IACT5:	PUSHJ P,RCVCHR
	 POPJ P,
IACT5A:	CAIL T4,TIWKC
	 JRST IAC11B
	JRST IAC11C

;BREAK CHR, RMT ECHO, ANY BREAK MODE

IACT6:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBKC(U)	;COUNT BREAK
	JRST IAC10A
SUBTTL	BREAK2 CHR, RMT ECHO, BREAK ON ALL, NOT BREAK2

IACT7:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBK2(U)	;COUNT BREAK2
	MOVSI T1,1
	ADDM T1,LDBBKI(U)	;AND IN ^U INFO
	JRST IACT5A

;BREAK2 CHR, RMT ECHO, BREAK2 OR BREAK ALL AND BREAK2

IACT10:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBK2(U)
IAC10A:	SETZM LDBBKI(U)
	MOVEM T2,LDBBKP(U)
	JRST IAC11B

;BREAK CHR, RMT ECHO, BREAK OR BREAK2 MODE

IACT11:	PUSHJ P,RCVCHR
	 POPJ P,
IAC11A:	CAIGE T4,TIWKC	;COUNT BIG ENOUGH?
	 JRST IAC11D	;NO
IAC11B:	PUSHJ P,LINTRP
IAC11C:	PUSHJ P,USRWAK
IAC11D:	MOVEM T2,LDBECT(U)
	AOS LDBTIC(U)
	LDB T1,CHPECH	;GET THE ECHO TYPE FIELD
	XCT RMTECT(T1)
	PFALL RMTCNT	;NOW FALL INTO THE REMOTE ECHO CODE
SUBTTL	REMOTE ECHO CODE

RMTCNT:	ADDI T4,1	;SEVERAL JUST LDB T4,LDPPOS
	TRNN T4,400	;TOO BIG?
	 DPB T4,LDPPOS	;NO RESET
	TLNE U,LDLLCP!LDLPTP ;LOCAL COPY OR TAPE
	 POPJ P,	;NEVER A FREE RETURN FOR THEM
	LDB T1,LDPWID
	TLNN U,LDLNFC	;IF NO FREE RETURN WANTED
	CAMG T4,T1	;OR NOT ENOUGH CHRS
	 POPJ P,		;FINISHED
RMTECR:	MOVEI T1,0
	DPB T1,LDPPOS	;RESET POSITION TO 0
	MOVE T4,CRPTR
	PJRST RUBSTR	;PUT INTO "RUBOUT" STRING

RMTECT:	JRST RMTSPA	;0 SPECIAL ACTION FOR THESE
	LDB T4,LDPPOS	;1 COUNT
	POPJ P,		;2 DO NOT COUNT THIS ONE
	POPJ P,		;3 "
	LDB T4,LDPPOS	;4 COUNT

RMTSPA:	LDB T1,LDPMOD	;GET THE MODE WE ARE IN
	LDB T2,CHPSPE	;ECHO SPECIAL ACTION TYPE
	XCT @RMTSPT(T1)

RMTSPT:	XCT RMTS10(T2)
	XCT RMTS94(T2)
	XCT RMTS94(T2)
	XCT RMTS10(T2)	;10 AND SUDS SAME

RMTS10:	JRST RMTEXC	;^C ECHO ^C RETURN
	JRST RMTCR	;RETURN
	JRST RMTEXU	;^U  ECHO ^U
	JRST RMTTAB	;TAB
	JRST RMTALT	;ALTMODE POSSIBLE $ ECHO
	JRST RMTVT	;V. TAB
	JRST RMTFF	;FF
	JRST RMTEXC	;^Z  ECHO ^Z RETURN
	JRST RMTAL1	;175-176 POSSIBLE ALTMODE
	JRST RMTBSP	;BACKSPACE
RMTS94:	POPJ P,		;^C
	JRST RMTCR	;RETURN
	POPJ P,		;^U
	JRST RMTTAB	;TAB
	POPJ P,		;ALTMODE
	JRST RMTVT	;V. TAB
	JRST RMTFF	;F.F.
	POPJ P,		;^Z
	JRST RMTPAT	;175-176 POSSIBLE ALTMODE
	JRST RMTBSP	;BACKSPACE
RMTPAT:	TLNE U,LDLLCT
	POPJ P,		;ALTMODE, IGNORE
RMTCN1:	LDB T4,LDPPOS
	JRST RMTCNT	;ASSUME PRINTING CHR

RMTAL1:	TLNN U,LDLLCT
	JRST RMTCN1	;ASSUME PRINTING CHR
RMTALT:	TLNE U,LDLPTP!LDLLCP	;NOTHING FOR THESE NUTS
	POPJ P,
	MOVSI T3,LXLDLR
	TDNE T3,LDBDCX(U) ;IF USER SUPPRESSING $ ECHO
	TLNE U,LDLCOM	;OR WE'RE AT COMMAND LEVEL
	SKIPA		;ECHO A $
	POPJ P,
	MOVEI T3,"$"
	JRST RMTRUB	;PUT IN RBS STRING

RMTCR:	MOVEI T1,0
	DPB T1,LDPPOS
	POPJ P,		;RETURN, JUST SET POSITION TO 0

RMTEXC:	TLNE U,LDLLCP!LDLPTP	;NOTHING FOR THESE NUTS
	POPJ P,		;NOTHING WE CN DO
	PUSHJ P,RMTEU1	;ECHO THE ^X
	JRST RMTECR	;AND THE RETURN
RMTEXU:	TLNE	U,LDLLCP!LDLPTP	;NOTHING FOR THESE NUTS
	POPJ	P,
RMTEU1:	MOVEI	T3,"^"
	PUSHJ	P,ENTRUB
	LDB	T3,LDBECT(U)	;GET BACK CHR
	TRO	T3,100
RMTRUB:	PUSHJ	P,ENTRUB
	MOVEI	T1,1
	DPB	T1,LOPRUB	;SET SEND-RUBOUT-CHARACTERS
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,

RMTVT:	MOVSI	T4,L2LNTB
	TDNN	T4,LDBBYT(U)		; NO VT ECHO??
	TLNE	U,LDLLCP!LDLPTP!LDLFRM	; DONE BY TERMINAL?
	POPJ	P,			; THEN NO FILLERS
	MOVE	T4,VTFLP
	PJRST	RUBSTR			;GO

RMTFF:	MOVSI	T4,L2LNTB
	TDNN	T4,LDBBYT(U)		; NO FF ECHO??
	TLNE	U,LDLLCP!LDLPTP!LDLFRM	; DONE BY TERMINAL?
	 POPJ	P,			; THEN NO FILLERS
	MOVE	T4,FFFLP
	PJRST	RUBSTR

RMTTAB:	MOVSI	T4,L2LNTB	;SEE IF WE SHOULD JUST IGNORE
	TDNE	T4,LDBBYT(U)
	TLNE	U,LDLCOM
	 SKIPA			;TABS AS USUAL IN COMMAND MODE
	  POPJ	P,		;YES, DO NOTHING
	LDB	T4,LDPPOS
	TLNE	U,LDLLCP!LDLTAB!LDLPTP
	 JRST	RMTTB1		;MUST ADJUST POSITION BUT NO SPACES
	ANDI	T4,7
	MOVE	T4,TABPTR(T4)
	PJRST	RUBSTR		;OUT OF SPACES ADJUSTS POS

RMTTB1:	MOVE	T1,T4		;SAVE SIZE
	TRO	T4,7
	ADDI	T4,1
	TRNN	T4,400
	 DPB	T4,LDPPOS	;PUT BACK IF NOT OUT OF RANGE
	POPJ	P,		;FINISHED

RMTBSP:	PJRST	SPOBSP	;UPDATE CHAR COLUMN COUNTER
SUBTTL	SOME ROUTINES TO HANDLE PUTTING THINGS IN THE RUBOUT STRING

ENTRUB:	SKIPN	TTFREE##	;GIVE UP IF NO FREE BUFFERLETS
	 POPJ	P,
	SKIPN	T2,LDBRBI(U)
	 JRST	STRUB		;MUST SET THINGS UP
STRUB1:	PUSHJ	P,TTPUTC
	MOVEM	T2,LDBRBI(U)
	AOS	LDBRBC(U)
	POPJ	P,

STRUB:	PUSHJ	P,GETCHK
	MOVEM	T2,LDBRBI(U)
	MOVEM	T2,LDBRBO(U)
	SETZM	LDBRBC(U)
	JRST	STRUB1

;PUT IN A WHOLE STRING, BYTE POINTER IN T4

RUBSTR:	ILDB	T3,T4
	JUMPE	T3, [		;IF WE'RE DONE WITH THE STRING,
		MOVEI	T1,1
		DPB	T1,LOPRUB	;SET SEND-RUBOUT-CHARACTERS
		DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
		POPJ	P,
	]
	PUSHJ	P,ENTRUB
	JRST	RUBSTR
SUBTTL	BREAK2 CHR, RMT ECHO, BREAK MODE

IACT12:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)	;COUNT BREAK2
	AOS LDBBK2(U)
	JRST IAC11A

;NORMAL CHARACTER, COMMAND MODE, REMOTE ECHO

IACT13:	PUSHJ P,RCVCHR
	 POPJ P,
	JRST IAC16B

;BREAK CHR, COMMAND MODE, REMOTE ECHO

IACT14:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBKC(U)
	MOVEM T2,LDBBKP(U)
	SETZM LDBBKI(U)	;RESET ^U POINTER
	JRST IAC16C

;BREAK2 CHR, COMMAND MODE, REMOTE ECHO, NOT BREAK2 MODE

IACT15:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)
	AOS LDBBK2(U)
IAC16B:	CAIL T4,TIWKC
IAC16C:	 PUSHJ P,CMDWAK
	JRST IAC11D
SUBTTL	BREAK2 CHR, COMMAND MODE, DEF ECHO, NOT BREAK2 MODE

IACT17:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)
	ADDM T1,LDBBK2(U)	;COUNT BREAK2
	JRST DEFNBK

;BREAK2 CHR, COMMAND MODE, DEF ECHO, BREAK2 MODE


;NORMAL CHR, COMMAND MODE, DEF ECHO

IACT21:	PUSHJ P,RCVCHR
	 POPJ P,
	JRST DEFNBK

;BREAK CHR, COMMAND MODE, DEF ECHO

IACT22:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKC(U)
	SETZM LDBBKI(U)
	MOVEM T2,LDBBKP(U)
	JRST DEFNBK
SUBTTL	SPECIAL ACTION CHRACTER, ALMOST ANY MODE

IACT0:	LDB T1,LDPMOD
	LDB T2,CHPSPI	;GET SPECIAL ACTION CODE
	XCT @INPACT(T1)

INPACT:	XCT INPA10(T2)
	XCT INPA94(T2)
	XCT INPA94(T2)
	XCT INPA10(T2)

INPA10:	POPJ P,		;NULL, IGNORE
	JRST INPESC	;ESCAPE (^C)
	JRST INPRET	;RETURN
	JRST INPGOB	;OUTPUT SUPPRESS (^O)
	JRST INPBRK	;PUT IN AS A BREAK CHR (^Q)
	JRST INPDLN	;DELETE LINE (^U)
	JRST INPTAB	;TAB (DECIDE IF BREAK OR BREAK2)
	JRST INPBRK	;ALTMODE
	JRST INPBRK	;JUST A BREAK CHR ^^
	JRST INPBRK	;^_
	JRST INPRUB	;RUBOUT
	JRST INPBRK	;^A
	JRST INPBRK	;POSSIBLE ALTMODE
	JRST INPBK2	;_
	JRST INPBRK	;^\
	JRST INPBSP	;BACKSPACE
	JRST INPSTA	;^T

INPA94:	POPJ P,		;NULL, IGNORE
	JRST INPBRK	;^C
	JRST INPRET	;RETURN
	JRST INPBRK	;^O, BREAK CHR
	JRST INPDLN	;DELETE LINE (^Q)
	JRST INPBRK	;^U
	JRST INPTAB	;TAB
	JRST INPESC	;ALTMODE (ESCAPE CHR)
	JRST INPCLD	;CONVERT TO ^D (^^)
	JRST INPESC	;^_
	POPJ P,		;RUBOUT, IGNORE
	JRST INPRB1	;^A, DELETE CHR
	JRST INPAL1	;POSSIBLE ALTMODE
	JRST INPBK2	;_
	JRST INPGOB	;^\
	JRST INPBS1	;BACKSPACE
	JRST INPBRK	;^T
SUBTTL	JUST SET AS A BREAK CHARACTER (MODE 2) AND GO

INPBRK:	MOVEI T2,2
	JRST MOVCH1	;P2 (LINE MODE) STILL SETUP

;DECIDE IF TAB IS A BREAK OR BREAK2 CHARACTER

INPTAB:	MOVEI T2,3	;NORMALLY BREAK2
	MOVSI T1,L2LTBK
	TDNE T1,LDBBYT(U)
	MOVEI T2,2	;BIT IS ON, AS A BREAK CHARACTER
	JRST MOVCH1

;DECIDE IF BACKSPACE IS A BREAK OR BREAK2 CHARACTER

INPBSP:	MOVEI T2,INPRUB
	SKIPA
INPBS1:	MOVEI T2,INPRB1
	MOVE T1,LDBDCX(U)
	TLNE T1,LXLBSD	;DELETE ON BACKSPACE?
	  JRST	(T2)	; YES
	MOVEI T2,2	;NORMALLY BREAK
	MOVSI T1,L2LBBP
	TDNE T1,LDBBYT(U)
	MOVEI T2,3	;BIT IS ON, AS A BREAK2 CHARACTER
	JRST MOVCH1

;CONVERT ^A INTO _ FOR TYMEX2 MDDE

INPTCA:	MOVEI T3,"_"
	JRST INPBK2

;RETURN HANDLER

INPRET:	MOVEI T2,1	;GET SET TO TREAT AS TYPE 1(NORMAL) CHR
	TLNE U,LDLPTP	;IF IN PAPER TAPE MODE
	JRST MOVCH1	;JUST PUT IN THE CHR
	PUSHJ P,MOVCH1	;ELSE PUT IT IN
	 JFCL		;IGNORE SKIP-NON SKIP
	MOVEI T3,12
	JRST MOVCHR	;AND THEN PUT IN A LINE FEED

;HANDLE ^^ IN 940 MODE (CONVERT TO ^D)

INPCLD:	MOVEI T3,4
	JRST MOVCH2

INPBK2:	MOVEI T2,3
	JRST MOVCH1
SUBTTL	POSSIBLE ALTMODE (175-176) IN 940 MODE

INPAL1:	TLNN U,LDLLCT
	JRST INPBRK	;IN LOWER CASE MODE, JUST CALL BREAK
	JRST INPESC

;^O IN PDP-10 MDDE

INPGOB:	MOVSI T1,LDLOSU
	XORM T1,LDBDCH(U)	;CHANGE FLAG
	PUSHJ P,TSETBO		;CLEAR OUTPUT BUFFER, set flag to send TYPGOB
	LDB T4,LDPMOD
	MOVE T4,@IGOBEC(T4)
INPOTP:	TLNE U,LDLLCP
	POPJ P,			;BUT NEVER ANYTHING TO 2741
	MOVSI T1,L2LDEL
	TDNN T1,LDBBYT(U)	;ALREADY IN \'S
	IBP T4			;NO, SKIP \ IN OUTPUT STRING
	ANDCAM T1,LDBBYT(U)	;NOT THERE NOW IN ANY CASE
	PJRST RUBSTR

;^U IN PDP-10 OR ^Q IN 940

INPDLN:	PUSHJ P,FULLCQ		;COMMAND OR FULL CHARACTER SET?
	 JRST INPBRK		;YES, BREAK CHARACTER
	PUSHJ P,RIDLIN		;THIS DOES ALL THE WORK
	 POPJ P,		;NOTHING TO ECHO
	LDB T1,LDPMOD		;GET MODE WE ARE IN
	MOVE T4,@IDLNEC(T1)	;AND GET APPROPRIATE ECHO STRING
	PJRST INPOTP

IDLNEC:	CUPTR
	UPARPT
	UPARPT
	CUPTR

IGOBEC:	COPTR
	FLLBSC
	FLLBSC
	COPTR
SUBTTL	GET RID OF A LINE OF TEXT. ADJUST ALL POINTERS

RIDLIN:	SKIPN T1,LDBBKP(U)	;IS THERE A ^U POINTER
	PJRST RIDLN3		;NO, DELETE ALL FROM BUFFER
	MOVEM T1,LDBTIP(U)
	HRRZ T2,LDBBKI(U)	;NUMBER OF CHRS SINCE ^U POINTER
	MOVNS T2
	ADD T2,LDBECC(U)
	JUMPGE T2,RIDLN1	;NONE ECHOED
	ADDM T2,LDBTIC(U)	;REMOVE SOME FROM INPUT
	MOVEI T2,0
	MOVEM T1,LDBECT(U)	;RESET ECHO POINTER
	AOS (P)			;SKIP RETURN FOR ECHO ^U
RIDLN1:	MOVEM T2,LDBECC(U)
	HLRZ T2,LDBBKI(U)	;GET NUMBER OF BREAK2 CHRS
	SETZM LDBBKI(U)		;AND GET RID OF OLD COUNTS
	MOVNS T2
	HRLZS T2
	ADD T2,LDBBK2(U)	;FIX NUMBER NOT ECHOED
	JUMPGE T2,RIDLN2	;ALL IN NOT ECHOED
	HLROS T2
	ADD T2,LDBBK2(U)	;FIX NUMBER ECHOED
	HRRZM T2,LDBBK2(U)
	POPJ P,

RIDLN2:	MOVEM T2,LDBBK2(U)
	POPJ P,

RIDLN3:	SKIPE LDBECC(U)		;ALSO ECHO IF NOT CHRS AT ALL
	SKIPE LDBTIC(U)		;ANY CHARACTERS ECHOED?
	AOS (P)			;SET SKIP RETURN
	PJRST TSETBI
SUBTTL	RUBOUT FROM PDP-10 MODE. 940 ^A JUST DOES NOT CHECK XON

INPRUB:	TLNE U,LDLPTP
	POPJ P,			;IGNORE RUBOUTS IN XON MODE
INPRB1:	PUSHJ P,FULLCQ
	 JRST INPBRK		;JUST CALL IT A BREAK CHR
	PUSHJ P,INPRBC		;COMMON RUBOUT ROUTINE
	 JRST INPRB2	;NO CHRS, GIVE RETURN
	 POPJ P,		;NOT ECHOED
	MOVEI T3,"\"
	MOVE	T4, LDBBYT(U)
	TLNN	T4, L2LBSP	;BACKSPACE FOR CHAR DELETE?
	JRST	INPRB7		;NO
	MOVE	T1,INPCH
	CAIE	T1, 10		;IS IT BACKSPACE?
	CAIN	T1, 210
	JRST	INPRB9		;YES
	MOVE	T4, LDBDCX(U)
	TLNN	T4, LXLERA	;<BS><SP><BS> OR JUST <BS>?
	JRST	INPRB6
	MOVEI	T3, 10		;<BS>
	PUSHJ	P, ENTRUB
	MOVEI	T3, 40		;<SP>
	PUSHJ	P, ENTRUB
INPRB6:	MOVEI	T3, 10		;<BS>
	JRST	INPRB8
INPRB7:	TLON T4,L2LDEL
	PUSHJ P,ENTRUB		;NO, ENTER
	MOVEM T4,LDBBYT(U)	;AND MAKE SURE WE REMEMBER IT
	MOVE T3,INPCH
	ANDI	T3, 177		;STRIP OFF PARITY BIT
	CAIE	T3, 10		;IS IT BACKSPACE?
	JRST	INPRB8		;NO
INPRB9:	MOVEI	T3,40		;YES, SUBSTITUTE <SP> FOR <BS>
	LDB	T1, LDPECH
	SKIPE	T1		;PRINT NOTHING IF NO REM BS ECHO
INPRB8:	PUSHJ P,ENTRUB
	MOVEI	T1,1
	DPB	T1,LOPRUB	;SET SEND-RUBOUT-CHARACTERS
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,

;HERE FROM _ IN TYMEX2 MODE

INPRT2:	PUSHJ P,FULLCQ
	 JRST INPBK2	;JUST TREAT AS A CHR
	PUSHJ P,INPRBC
	 POPJ P,
	 POPJ P,
	POPJ P,		;NEVER ANY ECHO
INPRBC:	HRRZ T1,LDBBKI(U)
	JUMPE T1,CPOPJ		;JUST GIVE RETURN
	AOS (P)
	LDB T3,LDBTIP(U)	;GET LAST CHARACTER INPUT
	MOVEM T3,INPCH	;AND SAVE
	SOS LDBBKI(U)
	SOS T2,LDBTIP(U)	;NOW REALLY BACK UP
	REPEAT 2,<IBP T2>	;NOW GET READY TO ADVANCE ON PREV.
	PUSHJ P,TTGETC
	 JFCL			;DO NOT CARE IF PASS OVER LINK
	MOVEM T2,LDBTIP(U)	;THAT WAS JUST IN CASE WE BACKED OVER LINK
	SOSL LDBECC(U)
	JRST [MOVSI T4,-1	;WAITING TO BE ECHOED, FORGET IT
		JRST INPRB4]
	SETZM LDBECC(U)
	SOS LDBTIC(U)
	MOVEM T2,LDBECT(U)	;RESET ECHO POINTER TO INPUT
	TLNN U,LDLCOM	;IF AT COMMAND IGNORE ECHO
	TLNN U,LDLNEC	;IF NOT ECHOING, NO ECHO
	TLNE U,LDLLCP	;BUT NEVER ECHO LOCAL COPY
	JRST INPRB3		;DUMP CHR
	AOS (P)
INPRB3:	MOVNI T4,1		;T4 WILL HAVE THING TO ADD TO BK2
INPRB4:	MOVE T3,INPCH
	TRZ T3,200
	TRNE T3,400
	POPJ P,		;IMAGE MODE CHRS NEVER COUNT
	MOVE P3,CHRTAB(T3)
	LDB T1,CHPINP
	XCT INPRTB(T1)		;WANT ONLY BREAK2 CHRS
INPRB5:	MOVSI T1,-1		;WILL HAV SOS'ED CORRECT HALF OF LDBBK2
	ADDM T1,LDBBKI(U)
	POPJ P,

INPRTB:	JRST INPRAC	;MUST WORRY ABOUT TAB
	POPJ P,		;NORMAL CHR
	POPJ P,		;BREAK CHR
	ADDM T4,LDBBK2(U) ;BREAK 2
INPRAC:	LDB T1,CHPSPI
	XCT INPRTA(T1)
	TDNE T1,LDBBYT(U)	;HERE ONLY FOR TAB WITH T1=L2LTBK
	POPJ P,			;TREAT AS BREAK
INPRA1:	ADDM T4,LDBBK2(U)
	JRST INPRB5

INPRTA:	REPEAT 6,<POPJ P,>
	MOVSI T1,L2LTBK
	REPEAT 6,<POPJ P,>
	MOVEI T1,0	;_ ALWAYS BREAK2
	POPJ P,		;^\
	JRST	[MOVSI T1,L2LBBP
		 TDNN T1,LDBBYT(U)	;TEST BACKSPACE BREAK FLAG
		 POPJ P,		;TREAT AS BREAK
		 JRST INPRA1]		;TREAT AS BREAK2

INPRB2:	MOVE T4,FLLBSC
	JRST INPOTP

;;
;; Here on ^T in PDP-10 mode, to see if it should be interpreted as
;; a .USESTAT command.
;;
INPSTA:	MOVSI	T1,LXLRTC
	TDNN	T1,LDBDCX(U)	;Special ^T mode set?
	  JRST	INPBRK		;No, just treat as break
	MOVEI	T1,CMFSTA##	;Forced command code for .USESTAT
	PJRST	TTFORC
SUBTTL	ESCAPE CHARACTER 940 IS ^_ OR POSSIBLY ALTMODE, PDP-10 IS ^C

INPESC:	PUSHJ P,ESCTRP		;CHECK ESCAPE TRAP
				;DOES DOUBLE RETURN
				;(OUT OF INPESC) IF TRAP TAKEN
	SKIPE LDBBKI(U)
	PUSHJ P,RIDLIN		;REMOVE LINE IF ANY
	 JFCL			;NEVER ECHO ANYTHING
	MOVSI T1,L2LCCS
	TDNN T1,LDBBYT(U)	;SECOND?
	JRST INPES1		;NO, JUST STORE IT
	PUSHJ P,CNCCHK		;SEE IF CMD LEVEL, SLAVED, ETC.
	 JRST INPES0		;JUST STORE IT
	PUSHJ P,TSETBI		;CLEAR INPUT
	PUSHJ P,TSETBO		;AND OUTPUT BUFFERS (send TYPGOB)
	MOVSI T1,LDLOSU	;SUPRESS OUTPUT (UNTIL WE HAVE HALTED)
	IORM T1,LDBDCH(U)
	HLL U,LDBDCH(U)	;MAKE SURE LINE KNOWS ABOUT IT
	LDB T1,LDPMOD
	MOVE T4,@INPEST(T1)	;GET CORRECT THING TO PRINT
	PJRST INPOTP

INPEST:	CCPTR
	FLLBSC
	FLLBSC
	CCPTR

INPES0:	TLNE U,LDLCOM	;IF COMMAND MODE
	PUSHJ P,TSETBO	;CLEAR OUTPUT BUFFER
INPES1:	PUSHJ P,INPBRK	;PUT IT IN AS A BREAK CHR
	 SKIPA
	AOS (P)		;TRANSFER SKIP RETURN TO US
	MOVSI T1,L2LCCS
	IORM T1,LDBBYT(U)	;SET FLAG
	POPJ P,
SUBTTL MODE CONVERSION TABLE

	DEFINE LMOD (ECH,INP)
	<BYTE (29)0(3)ECH(4)INP>

MDFLMD:	LMOD 2,11
	LMOD 2,4
	LMOD 2,3
	LMOD 2,1
	LMOD 3,10
	LMOD 3,5
	LMOD 3,3
	LMOD 3,1
	LMOD 1,6
	LMOD 1,4
	LMOD 1,2
	LMOD 1,1
	LMOD 1,7
	LMOD 1,5
	LMOD 1,2
	LMOD 1,1
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
SUBTTL OUTPUT DISPATCHER

;HERE AT CH7 TO SCAN LINTAB FOR PORTS NEEDING OUTPUT, SCAN
;LDBOUT FOR THOSE PORTS, AND DISPATCH TO THE APPROPRIATE
;OUTPUT ROUTINES

SCNOUT:	PUSHJ	P,SETOUT	;PREPARE FOR TYMNET OUTPUT, skip if room
	  SKIPLE MULCNT+1	;ORING is full, how about PTYs
	 JRST	.+2		;Room in either ORING or PTY count
	JRST	FINOUT		;  DO NOTHING THIS CYCLE

    ;FIND THE NEXT PORT (IN A ROUND-ROBIN FASHION) THAT WANTS
    ;TO DO OUTPUT

	SKIPL	T1,LINPTR	;IF NO ROUND-ROBIN PTR EXISTS,
	 MOVSI	T1,NMXFLG	;  SET TO START AT PORT 0
SCOLP1:	MOVEM	T1,LINPTR
	SKIPN	U,LINFLG(T1)	;IF NO NEED-OUTPUT BITS IN THIS WORD,
	 JRST	NOLIN2		;  GO ON TO THE NEXT ONE
	MOVE	T4,BITNTB(T1)	;T4/ PORT# CORRESPONDING TO BIT 0
SCOLP:	JFFO	U,.+2		;T1/ BIT# OF FIRST. IF NONE,
	 JRST	NOLIN2		;  GO ON TO THE NEXT WORD
	LSH	U,1(T1)		;GET RID OF THE BIT WE JUST FOUND
	MOVEM	U,LINFSV	;SAVE THE REST OF THE WORD
	ADD	T1,T4		;T1/ PORT# FOR THE BIT WE JUST FOUND
	MOVEM	T1,LINPNM	;SAVE THAT TOO
	MOVE	U,LINTAB(T1)	;U/ LDB ADDR
	HLL	U,LDBDCH(U)	;U/ DCH BITS,,LDB ADDR
	CAIGE	T1,RPORTN	;Is it one of the real ports?
	 JRST	SCORTY		;Yes
	PFALL	SCOPTY		;No
   ;PREPARE TO DO OUTPUT ON A PSEUDO-PORT

;P035/C06 17-Nov-87 - Complain if LDLPTY is wrong and fix it.
;This bug is triggered by an incoming zap during login and prevented the
;outgoing zap from reaching the base, causing "slot out of ports".

SCOPTY:	TLON	U,LDLPTY	;P(SEUDO)TY OR R(EAL)TY?
	 STOPCD (.+1,INFO,TTYPTY,PRTUT1,<PTY bit wrong for TTY>) ;;SCOPTY+1
	HLLM	U,LDBDCH(U)	;Reset it if LDLPTY was wrong
	MOVE	T1,TTFREN
	CAILE	T1,TIRSVD	;IF NO SYSTEM BUFFERLETS
	SKIPG	MULCNT+1	;OR PTY "FLOW" QUOTA EXCEEDED,
	 JRST	NOLIN		;  MAYBE THE NEXT PORT'S A REAL TTY
	PUSHJ	P,SETPTL	;T1/ MAX CHARS TO XFER
	MOVEI	W,1		;W = 1 = PTY
	JRST	SCOTTY

;Typeout routine for STOPCD(TTYPTY)
PRTUT1:	PUSH	P,T1		;Routine to output the contents of U and T1
	PUSH	P,U
	PUSHJ	P,INLMES
	 ASCIZ /Bits,,Line = /
	POP	P,T1		;Contents of U
	PUSHJ	P,HWDPNT
	PUSHJ	P,INLMES
	 ASCIZ /  Contents of T1 = /
	POP	P,T1		;Get saved value
	PUSHJ	P,HWDPNT	;Print as halfwords
	PJRST	CRLF##

    ;PREPARE TO DO OUTPUT ON A REAL PORT

SCORTY:	TLZE	U,LDLPTY	;P(SEUDO)TY OR R(EAL)TY?
	 STOPCD (,XCT,TTYPTY) ;;SCORTY+1
	HLLM	U,LDBDCH(U)	;Reset it if LDLPTY was wrong
	SKIPG	MULCNT+0	;IF NO ROOM FOR REAL TTY OUTPUT,
	 JRST	NOLIN		;  MAYBE THE NEXT PORT'S A PTY
	MOVEI	T1,%CHRMX	;T1/ MAX CHRS TO XMIT (EBUS02.J01 uses ^D30)
	SETZ	W,		;W = 0 = REAL TTY
	PFALL	SCOTTY

    ;LOOK FOR THE HIGHEST-PRIORITY OUTPUT REQUEST ON THE LINE

SCOTTY:	MOVEM	T1,CHQTA
	MOVEM	T1,CHCNT
	MOVE	T1,LDBOUT(U)	;T1/ OUTPUT BITS
	JFFO	T1,GOLIN
	 JRST	MORLN2		;NOTHING (THAT'S FUNNY...)
GOLIN:	JUMPGE	U,GOLIN1	;IF PORT'S BACKPRESSURED
	CAIG	T2,BPOKBN	; AND OUTPUT TYPE IS HIGH ENOUGH PRI
	 JRST	GOLIN1		; THEN OUTPUT IS OK
	CAILE   T2,LAPBIT       ;BEYOND LAST LEGAL PRIORITY BIT?
	 JRST   MORLN2          ;YES.  ASSUME NO OUTPUT
	LDB	T1,LOPECO
	JUMPN	T1,GOLIN2	;ATTEMPT ECHO EVEN IF BACKPRESSURE ON
Golin3:	SETZ	T1,		;PORT IS BACKPRESSURED
	DPB	T1,LDBOPB(U)	;  CLEAR NEED-OUTPUT
	JRST	FULLIN		;  AND SAY WE'RE THROUGH

GOLIN2:	MOVEI	T2,NUMECO	;ECHO BIT NUMBER
GOLIN1:	MOVEM	T2,SVOJFF	;SAVE THE BIT NUMBER
	JUMPE	W,@OUTTRN(T2)	;REAL TTY DISPATCH
	JRST	@PTYTRN(T2)	;PSEUDO-TTY DISPATCH
    ;OUTPUT SUCCESSFUL, ROOM FOR MORE

MORLIN:	MOVN	T2, SVOJFF	;T2/ -(BIT# WE DISPATCHED FOR)
	MOVSI	T1, (1B0)
	LSH	T1, (T2)	;T1/ BIT WE DISPATCHED FOR
	ANDCAB	T1, LDBOUT(U)	;CLEAR IT AND PICK UP THE REST
	JFFO	T1, GOLIN	;IF THERE'S MORE TO DO, DO IT

    ;FINISHED WITH THE LAST OUTPUT REQUEST FOR THIS PORT

MORLN2:	DPB	T1, LDBOPB(U)	;CLEAR NEED-OUTPUT BIT
	PUSHJ	P, XMTWAK	;WAKE UP THE JOB FOR GOOD MEASURE
	JRST	FULLIN

    ;OUTPUT SUCCESSFUL, NO ROOM FOR MORE

FINLIN:	MOVN	T2, SVOJFF
	MOVSI	T1, (1B0)
	LSH	T1, (T2)
	ANDCAB	T1, LDBOUT(U)
	JUMPE	T1, MORLN2
	JRST	FULLIN

    ;OUTPUT NOT DONE BECAUSE WE'RE WAITING FOR SOMETHING
    ;(E.G., CAN'T OUTPUT ECHO CHARACTERS IF THE PORT'S NOT
    ;IN INPUT WAIT). CODE FOR "SOMETHING"S MUST TURN
    ;THE NEED-OUTPUT BIT BACK ON

WATLIN:	MOVEI	T1, 0
	DPB	T1, LDBOPB(U)
	PUSHJ	P, XMTWAK
	JRST	FULLIN
    ;OUTPUT NOT DONE AND/OR FINISHED WITH THIS PORT

FULLIN:	HRRZ	F, LDBDDB(U)
	JUMPE	F, FULLN2
	LDB	T1, PJOBN
	MOVE	T4, CHQTA
	SUB	T4, CHCNT
	ADDM	T4, JBTCOT(T1)
	ADDM	T4, JBTCOT	;System-wide # of characters output
FULLN2:	JUMPN	W, FULLN3

    ;DONE WITH A REAL TTY

	PUSHJ	P, CLSCHR	;FINISH CHARACTER-OUTPUT MESSAGE
	  SKIPLE MULCNT+1	;No room in ORING.  Any PTY room?
	 JRST	NOLIN		;Room in ORING or room for PTY I/O
	JRST	FINOUT		;  QUIT

    ;DONE WITH A PTY

FULLN3:	CAIE	W, 1
	 STOPCD
	PUSHJ	P, CLSPTL	;FINISH CHARACTER OUTPUT
	SKIPG	MULCNT+0	;IF THERE'S ROOM FOR REAL PORTS
	SKIPLE	MULCNT+1	;OR PTYS,
	 JRST	NOLIN		;  GO ON
	JRST	FINOUT		;ELSE QUIT

    ;GO ON TO THE NEXT PORT

NOLIN:	AOS	T4, LINPNM
	MOVE	U, LINFSV
	JUMPN	U, SCOLP	;TRY TO FIND ANOTHER IN GROUP
NOLIN2:	MOVE	T1, LINPTR
	AOBJN	T1, SCOLP1	;TRY ANOTHER GROUP
	SETZM	LINPTR		;(START FROM BEGINNING NEXT TIME)
FINOUT:	AOSG	FSCN	;(IF IT WAS 0 (NOW 1), THERE WAS NO I/O)
	 JRST	SCNIN	;IF I/O DONE THIS CYCLE, GO CHECK INPUT AGAIN
	SETZM	FSCN	;OTHERWISE, CLEAR FSCN
	POPJ	P,	;AND RETURN (FROM SCNINT) TO THE TICK LOGIC
SUBTTL	OUTPUT DISPATCH TABLES

DEFINE ZZZ(NAME), <GO'NAME>
OUTTRN:	OUTBIT

DEFINE ZZZ(NAME), <PG'NAME>
PTYTRN:	OUTBIT
SUBTTL PTY "OUTPUT" ROUTINES

PTBSIZ==^D120

;SETPTL - CALLED WITH U/ PTY LDB TO SET UP FOR OUTPUT THENCE
;	IF THE OTHER END IS IN BLOCK INPUT WAIT, IT SETS
;	CHRWRP+1 TO POINT TO THE NEXT FREE BYTE IN THE
;	BLOCK INPUT BUFFER
;	OTHERWISE, IT SETS CHRWRP+1 TO POINT TO THE
;	PTY BUFFER
;	SETS T1/ MAX # CHARS TO MOVE

SETPTL:	SETZM	PBDISC		;CHARIO DISCOUNT FOR BLOCK OUTPUT
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNE	T1, LDBDCH(U)	;IF BLOCK INPUT IS IN PROGRESS,
	 JRST	SETPTB		;  DO THINGS DIFFERENTLY

    ;HERE WHEN OTHER END IS NOT IN BLOCK INPUT WAIT

	SETZM	DIDPBI
	MOVE	T1, [POINT 8, PTYBUF]
	MOVEM	T1, CHRWRP+1
	MOVE	T1, TIWRNN	;T1/ # CHARS ALLOWED BEFORE BACKPRESSURE
	SUB	T1, LDBTIC(U)
	SUB	T1, LDBECC(U)	;T1/ # MORE CHARS THAT WILL FIT
	SKIPGE	T1		;IF WE'LL BE BACKPRESSURED,
	 MOVEI	T1,%CHRMX	;  T1/ NORMAL (REAL TTY) LIMIT
	CAILE	T1, PTBSIZ
	MOVEI	T1, PTBSIZ	;MUSTN'T BE .gt. THAN THE PTY BUFFER SIZE
	POP	P, U
	POPJ	P,

    ;HERE WHEN THE OTHER END IS IN BLOCK INPUT WAIT

SETPTB:	SETOM	DIDPBI
	HRRZ	T1, LDBBIO(U)	;T1/ BLOCK INPUT BUFFER ADDR
	SKIPE	T1		;IF NONE,
	SKIPL	BIOCHR(T1)	;OR IF NO INPUT PENDING,
	 STOPCD 		;  DIE
	MOVE	T2, BIOPBP(T1)	;T2/ BLOCK IDPB POINTER
	MOVEM	T2, CHRWRP+1
	MOVE	T1, BIOPBC(T1)	;T1/ # BYTES LEFT THERE
	POP	P, U
	POPJ	P,
SUBTTL	CLSPTL - CALLED WITH U/ PTY LDB TO FINISH UP OUTPUT THITHER
;	IF OTHER END WAS DOING BLOCK INPUT, THE CHARACTERS ARE
;	ALREADY MOVED - WE JUST NEED TO UPDATE THE BUFFER
;	POINTER&COUNT AND SEE IF WE'VE FILLED IT YET
;	OTHERWISE WE NEED TO MOVE THE CHARACTERS TO THE
;	OTHER END

CLSPTL:	MOVE	T1, PBDISC
	ADDM	T1, CHCNT	;ADJUST CHARIO COUNT FOR BLOCK OUTPUT
	SKIPE	DIDPBI		;IF OTHER END WAS DOING BLOCK INPUT,
	JRST	CLSPTB		;  HANDLE THINGS DIFFERENTLY

	MOVE	T1, CHRWRP+1	;T1/ BYTE POINTER
	CAMN	T1, [POINT 8, PTYBUF]
	POPJ	P,		;(NOTHING TO OUTPUT)

	PUSH	P, U
	PUSH	P, [0]
	PUSH	P, T1
	PUSH	P, [POINT 8, PTYBUF]

    ;-2(P) = 0 IF REM. ECHO, -1 IF DEFERRED
    ;-1(P) IS ORIGINAL ENDING BYTE POINTER
    ;  (P) IS SOURCE BYTE POINTER

	PUSHJ	P, PTYBUD	;U/ BUDDY'S LDB
CLSLP1:	UUILDB	T3, (P)		;T3/ CHAR
	PUSHJ	P, MOVCHR	;DEPOSIT IT
	  JRST	.+2
	SETOM	-2(P)		;(ENTERED DEFERRED ECHO MODE)
	MOVE	T1, (P)
	CAME	T1, -1(P)
	JRST	CLSLP1

	SKIPN	T1, -2(P)	;IF IT ENTERED DEFERRED ECHO MODE,
	JRST	CLSLP2
	DPB	T1, LOPECO	;  SET NEED-ECHO
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
CLSLP2:	SUB	P, [3,,3]	;DISCARD THE THREE LOCALS
	POP	P, U		;RESTORE U
	POPJ	P,
    ;HERE WHEN THE OTHER END WAS DOING BLOCK INPUT

CLSPTB:	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IF BLKI NO LONGER IN PROGRESS,
	 JRST	UPOPJ		;  NOTHING TO DO
	HRRZ	T1, LDBBIO(U)	;T1/ BLOCK INPUT BUFFER ADDRESS
	SKIPN	T1
	 STOPCD
	MOVE	T3, CHRWRP+1
	MOVEM	T3, BIOPBP(T1)	;UPDATE BYTE POINTER
	MOVE	T3, CHCNT
	SUB	T3, CHQTA	;T3/ - # OF CHARACTERS MOVED
	ADDB	T3, BIOPBC(T1)	;UPDATE BYTES-LEFT COUNT
	JUMPE	T3, CLSPBF	;(BUFFER FILLED)

    ;HERE WHEN WE HAVEN'T FINISHED FILLING THE BUFFER YET

	SKIPG	T3
	 STOPCD 		;(WENT TOO FAR)
	MOVEI	T1, %PBTIM
	DPB	T1, LDPTIM	;RESET BLOCK-INPUT TIMER
UPOPJ:	POP	P,U
	POPJ	P,

    ;HERE WHEN WE'VE JUST FILLED A BLOCK INPUT BUFFER

CLSPBF:	HRRZ	T4, BIOCHR(T1)	;T4/ (PRESUMABLY) # CHARS MOVED
	PUSHJ	P, FRCIBF	;SIMULATE BUFFER-FULL MESSAGE
	SETZ	T1,
	DPB	T1, LDPTIM	;CLEAR BLOCK-INPUT TIMER
	MOVEI	T1, LDRBIP
	ANDCAM	T1, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	POP	P, U
	PUSHJ	P, FRCNOO	;BACKPRESSURE OURSELVES
	POPJ	P,
    ;IMPOSSIBLE OUTPUT BITS

PGSRD:	;RED BALL
PGSGR:	;GREEN BALL
	 STOPCD

    ;IGNORED OUTPUT BITS

PGSEC:	;SET ECHO MODE (SHOULD ALWAYS BE OFF)
PGSTP:	;TERMINAL CHARACTERISTICS PROBE
PGHNG:	;HANG UP DATA SET
	JRST	MORLIN

    ;NOT IMPLEMENTED YET - IGNORE

PGSTC:	;SET TERMINAL CHARACTERISTICS
	JRST	MORLIN
SUBTTL	MSGSIM - SIMULATE INPUT-MESSAGE ARRIVAL
;	CALLED WITH T1/ ADDR OF A FRC--- ROUTINE
;	CALLS <T1> WITH U/ THE CURRENT PTY'S "BUDDY"

MSGSIM:	PUSH	P, U		;SAVE U
	PUSHJ	P, PTYBUD	;U/ "BUDDY" LDB
	HLL	U, LDBDCH(U)
	PUSHJ	P, (T1)		;SIMULATE A <T1>-ARRIVAL
	POP	P, U
	JRST	MORLIN

;CHARACTER GOBBLER

PGCGB:	MOVEI	T1, FRCCGB
	PJRST	MSGSIM


;ORANGE BALL

PGSOG:	MOVSI	T2, L2LDEL
	TDNN	T2, LDBBYT(U)	;IF WE'RE IN \...
	 PUSHJ	P, WTCHK	;OR WE'RE IN INPUT WAIT,
	  JRST	WATLIN		;  WAIT
	MOVEI	T1, FRCORG
	PJRST	MSGSIM

;BACKPRESSURE ON

PGBPN:	MOVEI	T1, LDRXOS
	TDNE	T1, LDBDCH(U)	;IF WE'VE ALREADY SENT AN XOFF,
	 JRST	MORLIN		;  DON'T SEND ANOTHER
	IORM	T1, LDBDCH(U)
	MOVEI	T1, FRCNOO
	PJRST	MSGSIM

;BACKPRESSURE OFF

PGBPF:	MOVEI	T1, LDRXOS
	ANDCAM	T1, LDBDCH(U)	;CLEAR BACKPRESSURE-SEND FLAG
	MOVEI	T1, FRCDOO
	PJRST	MSGSIM
SUBTTL	YELLOW BALL

PGSYL:	PUSH	P, U
	PUSHJ	P, PTYBUD
	HLL	U, LDBDCH(U)
	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IS OTHER END DOING BLOCK INPUT?
	 JRST	PGSYLN		;(NO)

    ;HERE WHEN THE OTHER END'S DOING BLOCK INPUT

	ANDCAM	T1, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	HRRZ	T1, LDBBIO(U)
	SKIPE	T1
	SKIPL	T2, BIOCHR(T1)
	 STOPCD
	HRRZ	T4, T2		;T4/ # CHARS TO TRANSFER
	SUB	T4, BIOPBC(T1)	;T4/ # CHARS TRANSFERRED
	PUSHJ	P, FRCEOT	;FAKE A BLKI-EOT
	POP	P, U
	PUSHJ	P, FRCNOO	;BACKPRESSURE OURSELVES
	JRST	WATLIN		;(SEND YLB WHEN BKP RELIEVED)

    ;HERE IN THE NORMAL CASE

PGSYLN:	MOVSI	T1, L2LOWT
	IORM	T1, LDBBYT(U)	;SAY WE'RE WAITING
	MOVSI	T1, L2LOWS
	ANDCAM	T1, LDBBYT(U)	;AND THAT WE HAVEN'T SEEN ONE
	PUSHJ	P, FRCYEL
	POP	P, U
	JRST	MORLIN
SUBTTL	WHEN THE PTY OUTPUT CODE FILLS UP A BLOCK INPUT BUFFER, IT
;FORCES BACKPRESSURE ON THE LINE DOING THE OUTPUT - THE
;REQUEST-BLOCK-INPUT AND REQUEST-BLOCK-INPUT-TERMINATION
;OUTPUT ROUTINES CLEAR THE BACKPRESSURE

;TERMINATE BLOCK INPUT

PGTRI:	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IF BLOCK INPUT'S IN PROGRESS,
	 JRST	PGTRI1
	ANDCAM	T1, LDBDCH(U)	;  CLEAR IN-PROGRESS FLAG
	HRRZ	T1, LDBBIO(U)	;  T1/ BLOCK INPUT BUFFER ADDR
	SKIPE	T1
	SKIPL	T2, BIOCNT(T1)
	 STOPCD (,XCT,TTYNPB)	;No PTY Buffer for block IO  ;;PGTRI+7
	HRRZ	T4, T2		;  T4/ # OF CHARS TO TRANSFER
	SUB	T4, BIOPBC(T1)	;  T4/ # OF CHARS TRANFERRED
	JRST	.+2		;OTHERWISE
PGTRI1:	SETZ	T4,		;  T4/ 0 CHARS
	PUSHJ	P, FRCIHR	;FAKE A TERMINATED-BY-REQUEST
	JRST	PGBIN1		;CLEAR BACKPRESSURE ON THE OTHER END

;REQUEST BLOCK INPUT

PGBIN:	MOVEI	T1, LDRBIP
	IORM	T1, LDBDCH(U)	;MARK INPUT IN PROGRESS
	MOVEI	T1, %PBTIM
	DPB	T1, LDPTIM	;SET BLOCK-INPUT TIMEOUT
	HRRZ	T1, LDBBIO(U)	;T1/ INPUT BUFFER ADDRESS
	SKIPN	T1
TTYNPB:: STOPCD (.,JOB,TTYNPB,,<No PTY Buffer for block IO>) ;;PGBIN+6
	HRRZ	T2, BIOCHR(T1)	;T2/ # CHARS TO TRANSFER
	MOVEM	T2, BIOPBC(T1)	;STORE PTY COUNT
	MOVE	T2, [POINT 8,BIODAT]
	ADD	T2, T1
	MOVEM	T2, BIOPBP(T1)	;STORE PTY BYTE POINTER

    ;HERE FROM ABOVE AND FROM PGTRI TO CLEAR BACKPRESSURE

PGBIN1:	PUSH	P, U
	PUSHJ	P, PTYBUD
	HLL	U, LDBDCH(U)
	PUSHJ	P, FRCDOO	;CLEAR BACKPRESSURE ON OTHER END
	POP	P, U
	JRST	MORLIN
SUBTTL	PBTIMO - CALLED BY SCNSEC WHEN A PORT DOING BLOCK INPUT
;	   TIMES OUT.
;	   SAVES P1-P4.
;	   ASSUMES THAT FRCITM PRESERVES U AND F.

PBTIMO:	PUSH	P, P1
	PUSH	P, P2
	PUSH	P, P3
	PUSH	P, P4

	HRRZ	T1, LDBBIO(U)
	SKIPE	T1
	SKIPL	T4, BIOCHR(T1)
	 STOPCD 		;NO BUFFER OR NO INPUT PENDING
	MOVEI	T2, LDRBIP
	ANDCAM	T2, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	HRRZ	T4, T4		;T4/ # BYTES REQUESTED
	SUB	T4, BIOPBC(T1)	;T4/ # BYTES TRANSFERRED
	PUSHJ	P, FRCITM	;FAKE A TIMEOUT MESSAGE
	PUSH	P, U
	PUSHJ	P, PTYBUD
	PUSHJ	P, FRCNOO	;BACKPRESSURE OTHER END
	POP	P, U

	POP	P, P4
	POP	P, P3
	POP	P, P2
	POP	P, P1
	POPJ	P,
SUBTTL	BLOCK OUTPUT

PGBOT:	SKIPN	DIDPBI		;IF THE OTHER END WAS DOING BLOCK INPUT,
	 JRST	PGBOTC
	MOVE	T1, CHCNT
	CAME	T1, CHQTA	;AND IT HASN'T GOTTEN ANY CHARS YET,
	 JRST	PGBOTC
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNE	T1, LDBDCH(U)	;AND IT'S STILL IN BLOCK INPUT WAIT,
	 JRST	PGBOT1
	POP	P, U
	JRST	PGBOTC

PGBOT1:	HRRZ	T1, LDBBIO(U)	;  T1/ ITS BLOCK INPUT BUFFER
	SKIPN	T1
	 STOPCD
	HRRZ	T2, (P)		;  T2/ OUR LDB ADDR
	HLRZ	T3, LDBBIO(T2)	;  T3/ OUR BLOCK OUTPUT BUFFER
	SKIPN	T3
	 STOPCD
	HRRM	T3, LDBBIO(U)	;  OUR OUTPUT = ITS INPUT
	HRLM	T1, LDBBIO(T2)	;  ITS INPUT = OUR OUTPUT
	MOVE	T4, BIOREQ(T1)
	EXCH	T4, BIOREQ(T3)
	MOVEM	T4, BIOREQ(T1)	;  BUT KEEP THE OLD BIOREQ'S
	SKIPL	T1, BIOCHR(T1)	;  T1/ -1,,# CHARS "TRANSMITTED"
	 STOPCD
	MOVEM	T1, BIOCHR(T3)	;  INPUT SIDE WANTS THE -1 FLAG
	HRRZS	BIOCHR(T1)	;  OUTPUT SIDE DOESN'T
	HRRZM	T1, PBDISC	;  ALREADY CHARGED (JBTBIO), SO DISCOUNT
	POP	P, U
	SETZM	CHCNT		;  WE'VE FILLED ITS BUFFER
	PUSHJ	P, FRCOHR	;  WE'VE DONE OUR BLOCK OUTPUT
	JRST	FINLIN		;  NO MORE THIS CYCLE

    ;HERE WHEN THE OTHER END'S NOT COOPERATING BY DOING BLOCK INPUT

PGBOTC:	HLRZ	T1, LDBBIO(U)	;T1/ BLOCK OUTPUT BUFFER
	SKIPN	T1
	 STOPCD
	HRRZ	T2, BIOCHR(T1)	;T2/ TOTAL CHARS TO TRANSFER
	MOVEM	T2, BIOPBC(T1)	;STORE IT
	MOVE	T3, [POINT 8,BIODAT]
	ADD	T3, T1		;T3/ BYTE POINTER
	MOVEM	T3, BIOPBP(T1)	;STORE IT
	MOVEI	T1, 1
	DPB	T1, LOPBOP	;SET BLOCK-OUTPUT-IN-PROGRESS
	JRST	MORLIN		;(DISPATCH WILL GO DO IT)
;BLOCK OUTPUT IN PROGRESS

PGBOP:	HLRZ	T1, LDBBIO(U)
	SKIPN	T1
	 STOPCD
	MOVE	T2, BIOPBC(T1)	;T2/ COUNT
	MOVE	T3, BIOPBP(T1)	;T3/ POINTER
	MOVE	T4, MULCNT+1
	CAMLE	T4, CHCNT
	MOVE	T4, CHCNT	;T4/ MIN(MULCNT+1,CHCNT)
	PUSH	P, T4		;SAVE IT
	CAMLE	T2, T4
	MOVE 	T2, T4		;T4/ MIN(# TO XFER,# THAT'LL FIT)
	PUSH	P, T2		;SAVE IT

	JUMPE	T2, PGBOP2
PGBOP1:	UUILDB	T4, T3
	UUIDPB	T4, CHRWRP+1
	SOJG	T2, PGBOP1

PGBOP2:	POP	P, T2
	ADDM	T2, PBDISC	;(TO BE DISCOUNTED FROM CHARIO CHARGE)
	MOVN	T4, T2
	ADDM	T4, MULCNT+1	;DECREMENT MULCNT
	ADDM	T4, CHCNT	;AND CHCNT
	ADDM	T4, (P)		;AND SAVED # THAT'LL FIT
	ADDB	T4, BIOPBC(T1)	;AND BLOCK-BUFFER COUNT
	JUMPG	T4, PGBOP3	;IF WE'RE DONE
	PUSHJ	P, FRCOHR	;  FAKE AN OUTPUT-TERMINATED
	POP	P, T1
	JUMPLE	T1, FINLIN
	JRST	MORLIN
				;OTHERWISE,
PGBOP3:	MOVEM	T3, BIOPBP(T1)	;  UPDATE CHARACTER POINTER
	POP	P, T1
	JRST	FULLIN
SUBTTL	TERMINATE BLOCK OUTPUT

PGTRO:	SETZ	T1,
	DPB	T1, LOPBOP	;CLEAR BLKO-IN-PROGRESS
	PUSHJ	P, FRCOHR	;FAKE AN OUTPUT-TERMINATED
	JRST	MORLIN


SUBTTL	CIRCUIT ZAPPER

PGZAP:	MOVSI	T1,L2LOWT	;ZAP PTY
	TDNN	T1,LDBBYT(U)	;IF WAITING FOR ORANGE BALL,
	SKIPE	LDBBIO(U)	;OR IF BLOCK I/O NEEDS CLEANING-UP,
	 JRST	WATLIN		;  WAIT
	SETZB	T1,LDBLOG(U)	;MARK THIS PORT GONE
	DPB	T1,LDPHST	;Clear origination host
	SETZM	LDBMOD(U)
	PUSHJ	P,TSETBO
	PUSHJ	P,TSETBI
	SETZ	T1,
	DPB	T1,LDBOPB(U)	;CLEAR NEED-OUTPUT
	PUSH	P,U
	PUSHJ	P,PTYBUD	;U/ "BUDDY" LDB
	SKIPN	LDBLOG(U)	;IF IT'S ALREADY GONE,
	 JRST	PGZAP1		;  THERE'S NOTHING MORE TO DO
	HLL	U,LDBDCH(U)
	PUSHJ	P,FRCZAP	;FAKE A ZAPPER THERE
PGZAP1:	POP	P,U
	JRST	FINLIN

;BELL (SHOULDN'T REALLY HAPPEN) - SIMULATE BLACK BALLS

PGSBL:	AOS	PTYLOS		;COUNT CHARACTER LOST BY US
	MOVEI	T1, 1
	PUSHJ	P, FRCLOS	;"INPUT LOST" TO BELL SENDER
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, 0
	PUSHJ	P, FRCLOS	;"OUTPUT LOST" TO OTHER END
	POP	P, U
	HRRZ	F,LDBDDB(U)	;Point to TTY DDB (for stopcode processor)
	 STOPCD	(.+1,INFO,PTYSBL,,<PTY saw a Black Ball>)  ;;PGSBL+10
	JRST	MORLIN		;(Fixed in P035/C07 - was a POPJ)
SUBTTL TYMNET OUTPUT ROUTINES

;THIS ROUTINE IS CALLED TO FINISH UP OUTPUT. IT NONSKIP-RETURNS
;IF THERE IS NO BUFFER SPACE NOW.

CLSCHR:	SKIPGE	T1,MXMCNT
	 JRST	SETOUT		;WE REALLY DON'T THINK ANY CHRS THERE
	SUB	T1,MULCNT+0	;COMPUTE NUMBER OUTPUT
	JUMPE	T1,CPOPJ1	;NONE SO MUST STILL BE SPACE
	SKIPG	MULCNT+0	;DID WE RUN OUT OF ROOM IN RING
	 SOS	CHCNT+0		;YES, ACTUALLY 1 MORE CHR OUT
	SETOM	FSCN		;FLAG AS SOME OUTPUT
	TRO	T1,200		;SET BIT TO FLAG AS DATA TYPE
	DPB	T1,OUPTYP	;SET IN TYPE FIELD
	LDB	T3,LDPLNO
	DPB	T3,OUPLIN	;AND THE PORT NUMBER
	PUSH	P,P3		; SAVE P3, THEN SETUP AS USUAL
	MOVE	P3,ORING(P4)	;  ORING(P4) contains data
	PUSHJ	P,ORPLOG	; Log the transmission
	POP	P,P3		; Restore saved P3 (someone want it)
	SUBI	T1,200-5	;COMPUT NUMBER OF WORDS USED
	LSH	T1,-2
	ADD	P4,T1
ADVPTR:	ANDI	P4,MSKORG
	MOVEM	P4,ORPPDP	;SET FOR 620 TO FIND
	SETZM	ORPTIM##	;Reset ORING timer
	PFALL	SETOUT		;AND FIND OUT ABOUT MORE SPACE


;THIS ROUTINE IS CALLED TO SET THINGS UP FOR CHARACTER
;OUTPUT. NON-SKIP RETURN MEANS NO ROOM IN OUTPUT BUFFER

SETOUT:	SETOM	MXMCNT		;FLAG THAT NO ROOM THERE
	SETOM	MULCNT+0	;Flag that we've been here (no room?)
	MOVE	P4,ORP620
	SUB	P4,ORPPDP	;SIZE OF SPACE IN OUTPUT RING
	SOJL	P4,[MOVEI P4,MSKORG+1
		SKIPN	ORP620	  ;IF 620 AT 0 CAN NOT
		 MOVEI	P4,MSKORG ;USE LAST WORD
		SUB	P4,ORPPDP ;FIND SPACE TO END OF BUFFER
		JUMPN	P4,.+2	  ;SOME REALLY THERE
		POPJ	P,]	  ;NOT REALLY ANY THERE
	JUMPE	P4,CPOPJ	;REALLY NO ROOM
	LSH	P4,2		;CONVERT TO NUMBER OF CHARACTERS
	SUBI	P4,2		;TAKES TWO FOR COUNT AND PORT
	CAILE	P4,177		;COUNT MUST FIT IN BYTE SIZE-1
	 MOVEI	P4,177
	MOVEM	P4,MULCNT+0	;SAVE COUNT
	MOVEM	P4,MXMCNT	;AND ORIGINAL (SO KNOW HOW MANY SENT)
	MOVE	P4,ORPPDP
	MOVEI	T1,ORING(P4)
	HRLI	T1,(POINT 8,0,BYP2);SET TO PUT FIRST IN 3RD BYTE
	MOVEM	T1,CHRWRP+0	;SET BYTE POINTER
	JRST	CPOPJ1
COMMENT !
TO OUTPUT A CHARACTER INTO THE RING (OR TO A PTY), USE THE CODE:
	UUIDPB T3,CHRWRP(W)	;CHR. IN T3
	SOSLE MULCNT(W)		;SEE IF OUT OF ROOM
	SOSG CHCNT		;OR TIME TO STOP AND CHECK INPUT RING
	 HERE IF WE SHOULD STOP
	 HERE IF WE SHOULD NOT STOP
!

;OUTPUT A FULL WORD FOR SPECIAL TYPES

WRDOUT:	JUMPE	W, .+2		;IF IT'S A PTY,
	 STOPCD 		;  THERE SHOULD BE ONLY CHAR. OUTPUT
	MOVEM	P3,ORING(P4)	;PUT THE WORD IN THE OUTPUT BUFFER
	PUSHJ	P,ORPLOG	;Put message into ORING log
	SETOM	FSCN
	MOVNI	P3,4
	ADDM	P3,MULCNT+0	;UPDATE REAMAINING COUNTS
	ADDB	P3,MXMCNT	;IN CASE WE GO TO CHR OUTPUT
	JUMPL	P3,[AOJA P4,ADVPTR]	;WILL GET TO SETOUT, NONSKIP RETURN
	AOS	CHRWRP+0
	ADDI	P4,1		;JUST ADVANCE OUTPUT POINTER
	ANDI	P4,MSKORG
	MOVEM	P4,ORPPDP	;SET FOR 620 TO FIND
	JRST	CPOPJ1

;OUTPUT 2 WORDS FOR SPECIAL TYPES.

WRDOT2:	JUMPE	W,.+2		;IF IT'S A PTY,
	 STOPCD 		;  THERE SHOULD BE ONLY CHARACTER OUTPUT
	MOVEM	P3,ORING(P4)	;PUT 2ND WORD IN THE OUTPUT BUFFER.
;** No LOG HERE **;
;**;	PUSHJ	P,ORPLOG	;Put message into ORING log
	SETOM	FSCN		;FLAG THAT THERE'S SOMETHING TO DO.
	MOVNI	P3,8		;2 WDS (8 CHARS) TO OUTPUT.
	ADDM	P3,MULCNT+0	;UPDATE REMAINING COUNTS
	ADDB	P3,MXMCNT	;IN CASE WE GO TO CHR OUTPUT
	JUMPL	P3,[AOJA P4,ADVPTR]	;WILL GET TO SETOUT.
	AOS	CHRWRP+0	;INCREMENT CHAR BYTE POINTER.
	AOS	CHRWRP+0	;INCREMENT IT AGAIN (PAST 2 WORDS).
	ADDI	P4,1		;INCREMENT ORING OFFSET
	ANDI	P4,MSKORG
	MOVEM	P4,ORPPDP	;AND INFORM THE BASE.
	JRST	CPOPJ1		;SKIP RETURN.
SUBTTL NON-CHARACTER OUTPUT MESSAGE HANDLERS

;DON'T SEND ANY MESSAGES FROM THIS LINE

PGHSH:	 STOPCD			;HSH NOT USED ON PTYs
GOHSH:	LDB	T1,LOPZAP	;SEE IF ZAP SET
	SKIPN	T1
	 JRST	[AOS BADGUY	;COUNT BADGUYS THAT TRY TO SEND MESSAGES
		JRST WATLIN]	; FROM THIS PORT
	PUSHJ	P,CLRTTY	;DO FALSE ZAP STUFF
	JRST	FINLIN

;SEND TERMINAL CHARACTERISTIC(S)

GOSTC:	PUSHJ	P,CLSCHR
	  JRST	FULLIN		;NO ROOM
GOSTC1:	MOVE	T3,LDBTMT(U)	;T3/TRANSMIT BITS
	JFFO	T3,.+2		;T4/T.C # TO SEND THIS TIME
	JRST	MORLIN		;NONE OR NO MORE
	MOVSI	P3,TYPI TYPTCS	;MESSAGE TYPE
	DPB	T4,WRPCHR	;CHARACTERISTIC NUMBER
	LDB	T1,TABTMS(T4)
	DPB	T1,WRPCH2	;CHARACTERISTIC VALUE
	MOVSI	T1,(1B0)
	MOVNS	T4
	LSH	T1,(T4)
	ANDCAM	T1,LDBTMT(U)	;CLEAR THE TRANSMIT BIT
	LDB	T3,LDPLNO
	DPB	T3,WRPLIN	;SET PORT NUMBER IN OUTPUT WORD
	PUSHJ	P,WRDOUT	;SEND IT. IF THERE'S ROOM FOR MORE,
	  JRST	.+2
	JRST	GOSTC1		;  GO SEE IF THERE'S MORE TO SEND.
	SKIPE	LDBTMT(U)	;(NO ROOM) IF THERE WERE MORE TO DO,
	  JRST	FULLIN		;  SAY WE'RE NOT DONE
	JRST	FINLIN
SUBTTL	SEND A RED BALL

GOSRD:	MOVSI	P3,TYPI TYPRED
	JRST	FMTB

;SEND A CHARACTER GOBBLER

GOCGB:	MOVSI	P3,TYPI TYPGOB
	JRST	FMTB

;SEND A TERMINAL CHARACTERISTICS PROBE

GOSTP:	MOVSI	P3,TYPI TYPTCP	;PROBE
	MOVEI	T3,TMCALL	;FOR ALL
	DPB	T3,WRPCHR
	JRST	FMTB

;SET ECHO MODE

GOSEC:	MOVSI	P3,TYPI TYPECN	;ECHO ON
	MOVE	T1,LDBDCH(U)	;GET BOTH HALVES OF DCH
	TDNE	T1,[LDLNEC,,LDRDEM];DO WE WANT IT OFF INSTEAD?
	MOVSI 	P3,TYPI TYPECF	;(YES)
	JRST	FMTB

;SEND SOFT ZAP (HANG UP PHONE, KEEP CIRCUIT)

GOHNG:	MOVSI	P3,TYPI TYPHNG
	PFALL	FMTB

;FMTB -- CALLED WITH P3/ BYTE (8) TYPE, 0, XXX, XXX
;	 CLOSES CHARACTER MODE, RETURNING TO FULLIN IF NO ROOM,
;	 DEPOSITS PORT# INTO SECOND BYTE, TRANSMITS THE
;	 1-WORD MESSAGE, AND RETURNS TO THE OUTPUT DISPATCH
;FMTB1 -- ASSUMES CALLER HAS ALREADY DONE A CLSCHR

FMTB:	PUSHJ	P,CLSCHR	;LEAVE CHARACTER MODE. IF NO MORE ROOM,
	  JRST	FULLIN		;  RETURN TO OUTPUT DISPATCH
FMTB1:	LDB	T3,LDPLNO	;T3/ PORT #
	DPB	T3,WRPLIN	;DEPOSIT IT
	PUSHJ	P,WRDOUT	;SEND IT. ROOM FOR MORE?
	  JRST	FINLIN		;NO
	JRST	MORLIN		;YES
SUBTTL	SEND BELL

GOSBL:	MOVE	T2,LDBDCH(U)
	TLNN	U,LDLIMI	;IF IN IMAGE STATE,
	TRNE	T2,LDRNXO	;OR USER SAYS NO XOFF/XON,
	JRST	MORLIN		;  AVOID SENDING BELLS
	MOVEI	T3,7		;T3/ ASCII BELL
	PFALL	COMXON

;COMXON - CALLED WITH T3/ A CHARACTER AND THE PORT OPEN FOR
;	   CHARACTER OUTPUT. DEPOSIT THE CHARACTER IN THE BUFFER
;	   RING AND RETURN TO THE OUTPUT DISPATCH

COMXON:	UUIDPB	T3,CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	 JRST	FINLIN		;NO ROOM FOR MORE
	JRST	MORLIN		;ROOM FOR MORE

;BACKPRESSURE OFF

GOBPF:	MOVEI	T2,LDRXOS
	TDNE	T2,LDBDCH(U)	;IF WE SENT AN XOFF,
	  JRST	GOXON		;  GO SEND AN XON
	PUSHJ	P,CLSCHR
	  JRST	FULLIN		;NO ROOM FOR MESSAGE
	MOVEI	T2,LDRBPS
	ANDCAM	T2,LDBDCH(U)	;TURN OFF BACKPRESSURE-SENT FLAG
	MOVSI	P3,TYPI TYPOUP	;P3/ MESSAGE TYPE
	JRST	FMTB1

    ;HERE TO SEND AN XON

GOXON:	ANDCAM	T2,LDBDCH(U)	;CLEAR BACKPRESSURE-SENT FLAG
	MOVEI	T3,21		;T3/ ASCII XON
	JRST	COMXON		;GO SEND IT

;BACKPRESSURE ON

GOBPN:	LDB	T1,TRMBYP	;T1/ TERMINAL ID #
	JUMPE	T1,GOBPN1	;IF AUX CIRCUIT (0), BACKPRESSURE
	TLNN	U,LDLIMI	;OTHERWISE, IF NOT IMAGE STATE,
	  JRST	GOXOFF		;  SEND AN XOFF
GOBPN1:	PUSHJ	P,CLSCHR
	  JRST	FULLIN		;NO ROOM FOR MESSAGE
	MOVEI	T2,LDRBPS
	IORM	T2,LDBDCH(U)	;SET BACKPRESSURE-SENT FLAG
	MOVSI	P3,TYPI TYPNOP	;P3/ MESSAGE TYPE
	JRST	FMTB1

   ;HERE TO SEND AN XOFF

GOXOFF:	MOVEI	T1,LDRNXO
	MOVEI	T3,LDRXOS
	TDNN	T3,LDBDCH(U)	;IF WE'VE ALREADY SENT ONE XOFF
	TDNE	T1,LDBDCH(U)	;OR IF WE MUSTN'T SEND ANY,
	  JRST	MORLIN		;  JUST SAY WE'VE DONE IT
	IORM	T3,LDBDCH(U)	;SET XOFF-SENT FLAG
	MOVEI	T3,23		;T3/ ASCII XOFF
	JRST	COMXON		;GO SEND IT
SUBTTL	SEND CIRCUIT ZAPPER

GOZAP:	MOVSI	T1,L2LOWT
	TDNN	T1,LDBBYT(U)	;IF SOMEONE'S WAITING FOR ORANGE BALL
	SKIPE	LDBBIO(U)	;OR IF BLOCK I/O NEEDS CLEANING-UP,
	 JRST	WATLIN		;  WAIT
	PUSHJ	P,CLSCHR	;LEAVE CHAR MODE. SKIP IF ROOM.
	  JRST	FULLIN		;  MUST WAIT OR NO ROOM
	HRRZ	T1,U
	CAME	T1,OPRLDB	;Check if zapping OPR terminal
	 JRST	NOTOPR
	SETZM	OPRLDB
	SETZM	DEVOPR
	PUSHJ	P,OPRFRE	;No more OPR
	MOVEI	T1,STSHUT	;400000
	TDNE	T1,STATES	;IS SYSTEM SHUT?
	 JRST	NOTOPR		;YES
	MOVEI	T1,^D90
	MOVEM	T1,OPRTIM	;NO, SET TIMER FOR UNHAPPY MSG
NOTOPR:	TLNN	U,LDLAUX!LDLPTY	;THIS ONE WAS NOT COUNTED ANYWAY
	SKIPL	LDBLOG(U)
	 JRST	NOTLIN		;NOT REALLY IN
	MOVEI	T1,STSUPR	;200000
	SOSG	INTERM
	SKIPE	DWNFLG
	 SKIPA			;DO NOT RESET IF COMING DOWN
	ANDCAM T1,STATES	;CAN'T BE SUPER SHUT WITH EVERYONE GONE
NOTLIN:
	;Here to put ZAP message in the ORING

	SETZB	T1,LDBLOG(U)	;CLEAR LOGGED IN INFO
	DPB	T1,LDPHST	;Clear origination host
	SETZM	LDBMOD(U)	;RESET MODE TO LOGIN MODE
	PUSHJ	P,TSETBO	;Flush output buffer (free TTY chunks)
	PUSHJ	P,TSETBI	;ALSO CLEAR INPUT BUFFER
	MOVE	T1,LDBLIN(U)
	TLZE	T1,LNLZIN
	 AOS	NZAPOT		;AN IN-ZAP WAS RESPONDED TO
	MOVEM	T1,LDBLIN(U)
	SETZB	T1,LDBOUT(U)	;Cancel LOPCGB that was set by TSETBO
	DPB	T1,LDBOPB(U)	;NOTHING MORE TO DO ON OUTPUT
	MOVSI	P3,TYPI TYPZAP
	LDB	T2,LDPLNO
	DPB	T2,WRPLIN	;Port # in 2nd byte
	CAIL	T2,RPORTN##	;(if RPORTN=200, then only 0-177 are legal)
	 STOPCD 		;CRASH- ZAPPING BEYOND HIGHEST REAL PORT
	PUSHJ	P,WRDOUT	;Store in ORING
	  JFCL			;Don't care if ORING is now full
	JRST	FINLIN		;NOBODY LEFT TO TALK TO

CLRTTY:	HRRZ	T1,U		;FALSE ZAP STUFF FOR REAL TTYs
	CAME	T1,OPRLDB
	 JRST	NTTOPR
	SETZM	OPRLDB		;OPR terminal has been zapped
	SETZM	DEVOPR
	PUSHJ	P,OPRFRE
	MOVEI	T1,STSHUT	;400000
	TDNE	T1,STATES	;IS SYSTEM SHUT?
	 JRST	NTTOPR		;YES
	MOVEI	T1,^D90
	MOVEM	T1,OPRTIM	;NO, SET TIMER FOR UNHAPPY MSG
NTTOPR:	TLNN	U,LDLAUX	;THIS ONE WAS NOT COUNTED ANYWAY
	SKIPL	LDBLOG(U)
	 JRST	CLRPTY		;NOT REALLY IN
	MOVEI	T1,STSUPR	;200000
	SOSG	INTERM
	SKIPE	DWNFLG
	 SKIPA			;DO NOT RESET IF COMING DOWN
	  ANDCAM T1,STATES	;CAN'T BE SUPER SHUT WITH EVERYONE GONE
CLRPTY:				;FALSE ZAP ENTRY FOR PTYs
	SETZB	T1,LDBLOG(U)	;CLEAR LOGGED IN INFO
	DPB	T1,LDPHST	;Clear origination host number
	SETZM	LDBMOD(U)	;RESET MODE TO LOGIN MODE
	PUSHJ	P,TSETBO
	PUSHJ	P,TSETBI	;ALSO CLEAR INPUT
	MOVE	T1,LDBLIN(U)
	TLZE	T1,LNLZIN
	 AOS	NZAPOT		;AN IN-ZAP WAS RESPONDED TO
	MOVEM	T1,LDBLIN(U)
	SETZB	T1,LDBOUT(U)	;CLEAR 'SEND SPECIAL MESSAGE' FLAGS
	DPB	T1,LDBOPB(U)	;NOTHING MORE TO DO ON OUTPUT
	POPJ	P,
SUBTTL	HERE ON A DETECTED ZAPPER ANOMALY TO STORE STUFF ABOUT THE PORT

ZBGBUG:	0	;ADDRESS OF THE COUNT INCREMENTED
ZBGPC:	0	;Where problem was detected
ZBGLIN:	0	;LDBLIN OF THE OFFENDING PORT
ZBGDCH:	0	;LDBDCH
ZBGDDB:	0	;LDBDDB
ZBGOUT:	0	;LDBOUT
ZBGBIT:	0	;OUTPUT BIT
ZBGBYT:	0	;LDBBYT
ZBGMOD:	0	;LDBMOD
ZBGDCX:	0	;LDBDCX
ZBGLOG:	0	;LDBLOG
	0
	0
	0
	0

ZAPBUG:	 STOPCD (.+1,INFO,ZAPBUG,,<Port not Zapped - *BUG*>)
ZAPBG0:	PUSH	P,T2
	HRRZI	T2,ZBGBUG-1	;(PDL POINTER)
	PUSH	T2,T1		;STORE THE COUNTER'S ADDRESS
	AOS	(T1)		;INCREMENT THE COUNTER
	PUSH	T2,-1(P)	;RETURN PC
	PUSH	T2,LDBLIN(U)
	PUSH	T2,LDBDCH(U)
	PUSH	T2,LDBDDB(U)
	PUSH	T2,LDBOUT(U)
	LDB	T1,LDBOPB(U)
	PUSH	T2,T1
	PUSH	T2,LDBBYT(U)
	PUSH	T2,LDBMOD(U)
	PUSH	T2,LDBLOG(U)
ZAPBG1:	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	POP	P,T2
	POPJ	P,
SUBTTL BLOCK I/O MESSAGE ROUTINES

;BLOCK INPUT

GOBIN:	PUSHJ	P, GOBIO1	;INITIAL SETUP
	  JRST	FULLIN		;NO ROOM
	HRRZ	T3, LDBBIO(U)	;T3/ INPUT BUFFER ADDR
IFCPU (KL),<
	MOVE	T1, BIOCSH(T3)	;T1/ SWEEP NUMBER
	CAME	T1, CSUCNT##	;UNLOAD ALREADY DONE?
	JRST	[
		AOS CSHSAV##	;PAT OURSELVES ON THE BACK
		JRST GOBIN1
	]
	CSHUNL			;UNLOAD THE CACHE
	CAMN	T1, CSUCNT##
	 JRST	.-1		;WAIT 'TIL IT'S DONE
GOBIN1:>;END IFCPU (KL)
IFCPU (KS),<CSHIVL>		;INVALIDATE 2020 CACHE
	MOVSI	P3, TYPI TYPBIN	;P3/ MESSAGE TYPE
	PUSHJ	P, GOBIO2	;OUTPUT THE MESSAGE
	  JRST	FINLIN		;(NO ROOM FOR MORE)
	JRST	MORLIN		;(ROOM FOR MORE)

;BLOCK OUTPUT

GOBOP:	 STOPCD		;(PTYS ONLY)
GOBOT:	PUSHJ	P, GOBIO1	;INITIAL SETUP
	  JRST	FULLIN		;NO ROOM
;"/Patch to check for prior circuit zap on BIO port before output/
	HLRZ	T3, LDBBIO(U)	;T3/ OUTPUT BUFFER ADDR
	JUMPN	T3,GOBOT3	;Must be nonzero
	MOVSI	T3,LNLZIN	;Has a zapper been seen in the IRING?
	TDNN	T3,LDBLIN(U)	; ...
	 STOPCD (.+1,INFO,BIOZAD,,<Block I/O with Zero Address>);GOBOT+3
	JRST	FINLIN		;Say "no room", so zapper can be processed
GOBOT3:
IFCPU (KL),<
	MOVE	T1, BIOCSH(T3)	;T1/ SWEEP NUMBER
	CAME	T1, CSVCNT##	;IF A SWEEP'S ALREADY BEEN DONE,
	 JRST	[
		AOS CSHSAV##	;PAT OURSELVES ON THE BACK
		JRST GOBOT1
	]
	CSHVAL			;START VALIDATE
	CAMN	T1, CSVCNT##
	JRST	.-1		;AND WAIT 'TIL IT'S DONE
GOBOT1:>;END IFCPU (KL)
	MOVSI	T1, LDLNOP
	IORM	T1, LDBDCH(U)	;PREVENT FUTURE OUTPUT UNTIL
				;BLOCK OUTPUT IS COMPLETE
	MOVSI	P3, TYPI TYPBKO	;P3/ MESSAGE TYPE
	PUSHJ	P, GOBIO2	;OUTPUT THE MESSAGE
	  JRST	FINLIN		;(NO ROOM FOR MORE)
	JRST	FINLIN		;(ROOM FOR MORE BUT CLAIM THERE ISN'T)
SUBTTL	GOBIO1 - CLOSE CHARACTER OUTPUT, THEN SKIP IF THERE ARE
;	   AT LEAST 2 FREE WORDS IN THE OUTPUT RING

GOBIO1:	PUSHJ	P,CLSCHR	;CLOSE CHARACTER MODE
	  POPJ	P,		;NO ROOM
	MOVE	T1,ORPPDP
	ADDI	T1,2
	ANDI	T1,MSKORG	;T1/ (PDP PTR + 2) MOD RING SIZE
	CAME	T1,ORP620
	AOS	(P)		;ENOUGH ROOM
	POPJ	P,

;GOBIO2 - CALLED WITH T3/ BUFFER ADDR
;		       P3/ BYTE (8) TYPE, 0, 0, 0
;	   DEPOSIT THE PORT# AND BUFFER ADDRESS APPROPRIATELY,
;	   OUTPUT THE BLOCK INPUT/OUTPUT MESSAGE,
;	   SKIP-RETURN IF THERE'S ROOM FOR MORE

GOBIO2:	LDB	T1,LDPLNO	;T1/ PORT#
	DPB	T1,WRPLIN	;DEPOSIT IT
	HRRZ	T1,BIOCHR(T3)	;T1/ CHARACTER COUNT
	DPB	T1,[POINT ^D16, P3, BYP4]
	MOVEM	P3,ORING(P4)
	PUSHJ	P,ORPLOG	;Put message into ORING log
	ADDI	P4,1
	ANDI	P4,MSKORG
	SETZ	P3,
IFKMC<
	EXTERNAL UBANXT,UBAEND	;OUR UBA SPACE IS BETWEEN THESE TWO
	UBABIO==<763000!<<UBANXT+1>&776>>;START UBA's BLOCK I/O PAGING RAM
	MOVEI	T1,(T3)		;T1/ BUFFER ADDRESS
	PUSHJ	P,SCANBB	;FIND UBA PAGE MATCHING T1
		 STOPCD		;THERE HAS TO BE ONE AT THIS POINT
	ADDI	T2,UBABIO&77	;UBAPAG# + Low 6 BITS OF UBA ADDRESS
	DPB	T2,[POINT 11,T1,26]	;PAGE # OVERLAYS HIGH 11 BITS
	ADDI	T1,BIODAT		;Offset to first Char address
	DPB	T1,[POINT 8,P3,BYP3]	;LOW 8 BITS TO 3RD BYTE POS.
	LSH	T1,-8			;SHIFT TO HIGH 10 BITS
	DPB	T1,[POINT 10,P3,BYP2]	;THE REST IN BYTES 1 & 2
	>;END IFKMC
IFNKMC<
	MOVEI	T1,BIODAT(T3)	;T1/ FIRST-CHARACTER ADDR
IFNCPU (KI),<
	MAP	T1,(T1)	;GET PHYSICAL ADDRESS
	DPB	T1,[POINT 18,P3,23] ;PUT IT IN
>;END IFNCPU (KI)
>;END IFNKMC
IFCPU (KI),<
	DPB	T1,[POINT 9,P3,23] ;PUT IN LOW 9 BITS, MAP SMASHES THEM
	MAP	T1,(T1)		;GET PAGE NUMBER
	DPB	T1,[POINT 9,P3,14] ;PUT IN HIGH 9 BITS.
>;END IFCPU (KI)
	PJRST	WRDOT2

;TERMINATE BLOCK OUTPUT

GOTRO:	PUSHJ	P,CLSCHR	;LEAVE CHARACTER MODE. IF NO ROOM,
	JRST	FULLIN		;  RETURN TO OUTPUT DISPATCH
	MOVSI	T1,LDLNOP
	IORM	T1,LDBDCH(U)	;SET BACKPRESSURE
	MOVSI	P3,TYPI TYPORQ	;SEND OUTPUT TERMINATION REQUEST
	JRST	FMTB1

;TERMINATE BLOCK INPUT

GOTRI:	MOVSI	P3,TYPI TYPIRQ	;SET UP BLOCK TERMINATION REQ
	JRST	FMTB
SUBTTL RUBOUT STRING/OUTPUT CHARACTER HANDLERS

;SEND RUBOUT CHARACTERS

PGRUB:
GORUB:	SKIPN	LDBRBC(U)
	 JRST	MORLIN		;NO RUBOUT CHARACTERS
	TDZA	P1,P1		;P1 := -1 IF PRCOUT RUNS OUT OF ROOM
	 JRST	FULLIN		;OUT OF ROOM
CNTRUB:	MOVE	T2,LDBRBO(U)
	PUSHJ	P,TTGETC	;GET A CHAR. IF DONE WITH THE CHUNK,
	  PUSHJ	P,FRECHK	;  FREE IT
	MOVEM	T2,LDBRBO(U)
	PUSHJ	P,PRCOUT	;PRINT THE CHARACTER
	  JRST	[		;NO ROOM
		ADDM	T3,LDBRBO(U)
		JRST	FULLIN
	  ]
	SOSLE	LDBRBC(U)	;IF THERE'RE MORE CHARACTERS,
	 JRST	CNTRUB(P1)	;  KEEP GOING IF THERE'S ROOM

    ;HERE WHEN THERE'RE NO MORE RUBOUT CHARACTERS

	SETZM	LDBRBI(U)
	SKIPE	T2,LDBRBO(U)	;Pointer to last chunk used in rubout string
	 PUSHJ	P,FREUP
	SETZM	LDBRBO(U)	;CLEAN UP THE BUFFERLETS
	JUMPL	P1,FINLIN	;NO ROOM
	JRST	MORLIN		;MORE ROOM
SUBTTL	SEND OUTPUT CHARACTERS

PGOUT:
GOOUT:	SKIPN	LDBTOC(U)
	 JRST	MORLIN
	TDZA	P1,P1		;P1 := -1 IF PRCOUT RUNS OUT OF ROOM
	 JRST	CLNOC
CNTOUT:	MOVE	T2,LDBTOT(U)
	PUSHJ	P,TTGETC	;GET A CHAR. IF DONE WITH BUFFERLET,
	  PUSHJ	P,FRECHK	;  FREE IT
	MOVEM	T2,LDBTOT(U)
	PUSHJ	P,PRCOUT	;PRINT THE CHARACTER
	 JRST	[		;OUT OF ROOM
		ADDM T3,LDBTOT(U)
		JRST CLNOCP
	 ]
	SOSLE	T2,LDBTOC(U)	;IF THERE'RE MORE CHARACTERS,
	 JRST	CNTOUT(P1)	;  CONTINUE IF THERE'S ROOM

    ;HERE WHEN THERE'RE NO MORE OUTPUT CHARACTERS

	PUSHJ	P,XMTWAK	;WAKE THE JOB UP
	HRRZ	T2,U
	CAMN	T2,OPRLDB	;IS THIS OPR?
	 PUSHJ	P,OPRFRE	;RESTART WAITERS FOR SETUUO
	JUMPL	P1,FINLIN	;NO MORE ROOM
	JRST	MORLIN		;MORE ROOM

    ;HERE WHEN CHARACTER OUTPUT RUNS OUT OF ROOM TO DECIDE
    ;WHETHER TO WAKE THE JOB UP NOW

CLNOCP:	MOVE	T2,LDBTOC(U)
CLNOC:	SKIPGE	LDBDCX(U)	;IF IT'S A FAST LINE,
	CAML	T2,OWK120	;AND UNDER THE FAST MINIMUM,
	CAMGE	T2,OWK30	;OR IF IT'S UNDER THE SLOW MINIMUM,
	 PUSHJ	P,XMTWAK	;  WAKE THE JOB UP
	JRST	FULLIN
SUBTTL ECHO LOGIC

;YELLOW BALL

GOSYL:	PUSHJ	P,CLSCHR	;LEAVE CHARACTER MODE
	  JRST	FULLIN		;NO ROOM
	MOVSI	T1,L2LOWT
	IORM	T1,LDBBYT(U)	;SAY WE'RE WAITING
	MOVSI	T1,L2LOWS
	ANDCAM	T1,LDBBYT(U)	;AND THAT WE HAVEN'T SEEN ONE
	MOVSI	P3,TYPI TYPYEL
	JRST	FMTB1

;GREEN (GOSGR) AND ORANGE (GOSOG) BALLS

GOSGR:	MOVSI	P3,TYPI TYPGRN
	SKIPA
GOSOG:	MOVSI	P3,TYPI TYPORG
	MOVSI	T2,L2LDEL
	TDNN	T2,LDBBYT(U)	;IF WE'RE IN \...
	 PUSHJ	P,WTCHK		;OR IF WE'RE NOT IN INPUT WAIT,
	  JRST	WATLIN		;  WAIT
	JRST	FMTB		;GO SEND IT

;WTCHK - SKIP IF TTY IN INPUT WAIT

WTCHK:	TLNE	U,LDLCOM
	 JRST	CMDCKW##	;SPECIAL CHECK IF AT COMMAND LEVEL
;	HRRZ	T1,LDBBIO(U)
;	JUMPN	T1,CPOPJ
	MOVSI	F,L2LLDF
	TDNE	F,LDBBYT(U)	;IF LEAVE DEF ECHO BIT ON
	 JRST	CPOPJ1		;ALWAYS GET OUT
	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ1	;NO JOB, TAKE A CHANCE
	MOVE	S,DEVIOS(F)
	TRNE	S,IOACT
	TLNE	S,TTYOUW
	 POPJ	P,		;NOT IN WAIT OR IN OUTPUT WAIT
	JRST	CPOPJ1
SUBTTL	ECHO CHARACTER OUTPUT

PGECO:
GOECO:	SKIPN	LDBECC(U)
	 JRST	MORLIN		;NO CHARACTERS
	PUSHJ	P,WTCHK		;IF WE AREN'T IN INPUT WAIT,
	  JRST	[JUMPL	U,GOLIN3	;Don't wake if backpressured
		 JRST WATLIN]		;  WAIT UNTIL WE ARE
	TDZA	P1,P1		;THIS USED THE SAME TRICK AS OUTPUT
	 JRST	FULLIN		;WILL GET HERE WHEN OUT OF ROOM
CNTECO:	MOVE	T2,LDBECT(U)
	PUSHJ	P,TTGETC
	 JFCL			;DON'T CARE ABOUT BOUNDARIES
	MOVEM	T2,LDBECT(U)
	TRNE	T3,400
	 JRST	[MOVEI T1,5	;SET MODE 5 FOR IMAGE CHR
		JRST ECHRPT]
	TRNE	T3,200
	 SKIPA	P3,CHRTAB-200(T3)
	MOVE	P3,CHRTAB(T3)
	LDB	T1,CHPECH	;GET ECHO TYPE
ECHRPT:	LDB	T2,LDPMEC	;AND LINE MODE
	XCT	ECHTAB(T1)	;USUALLY LOADS T1 WITH ADDRESS
	JRST	(T1)		;GO THERE

;HERE WHEN THERE'S NOT ENOUGH OUTPUT RING SPACE: BACK UP
;THE ECHO POINTER AND REPORT NON-COMPLETION TO THE DISPATCHER

ECHBAK:	ADDM	T3,LDBECT(U)	;BACK UP POINTER
	JRST	FULLIN

;HERE TO SEE IF THERE ARE MORE CHARACTERS TO BE ECHOED

ECHLST:	SOSLE	LDBECC(U)	;IF THERE ARE MORE TO ECHO,
	 JRST	CNTECO(P1)	;  CONTINUE
	JUMPL	P1,FINLIN	;OTHERWISE, IF THERE'S OUTPUT RING SPACE,
	PUSHJ	P,BPXOFF	;  CLEAR BACKPRESSURE (WHY NOW?)
	JRST	MORLIN		;  AND RETURN TO OUTPUT DISPATCH
SUBTTL	ECHO DISPATCH TABLES

ECHTAB:	JRST ECHSPA		; 0 - SPECIAL ACTION
	HLRZ T1,ECHT12(T2)	; 1 - NONBREAK: PRINT & COUNT
	HRRZ T1,ECHT12(T2)	; 2 - BREAK: NO PRINT, NO COUNT
	HLRZ T1,ECHT34(T2)	; 3 - BREAK: PRINT, NO COUNT
	HRRZ T1,ECHT34(T2)	; 4 - BREAK2: PRINT & COUNT
	HLRZ T1,ECHT56(T2)	; 5 - IMAGE MODE CHARACTER
	HRRZ T1,ECHT56(T2)	; 6 - BREAK: PRINT & COUNT
	HRRZ T1,ECHT7(T2)	; 7 - BREAK2: NO PRINT, NO COUNT

ECHT12:	EACT1,,EACT2	; 0 - COMMAND MODE
	EACT6,,EACT12	; 1 - BREAK-ON-ALL
	EACT10,,EACT12	; 2 - BREAK NORMALLY
	EACT10,,EACT12	; 3 - BREAK-ON-PUNCTUATION

ECHT34:	EACT3,,EACT4
	EACT13,,EACT14
	EACT13,,EACT15
	EACT13,,EACT14

ECHT56:	EACT5,,EACT16
	EACT7,,EACT17
	EACT11,,EACT17
	EACT11,,EACT17

ECHT7:	EAC4A
	EAC14A
	EAC15A
	EAC14A
SUBTTL	COMMAND MODE

;NONBREAK: PRINT & COUNT

EACT1:	PUSHJ P,EPCOUT	;DO THE NORMAL OUTPUT THING
	 JRST ECHBAK	;MUST BACK UP
EACT1B:	AOS T4,LDBTIC(U)
	CAIGE T4,TIWKC	;ENOUGH TO WAKE UP
	 JRST ECHLST	;NO, CHECK MORE CHRS
EACT1A:	PUSHJ P,CMDWAK	;WAKE COMMAND
	SOS LDBECC(U)	;DECREASE COUNT
	JRST WATLIN	;NO MORE ECHO UNTIL WE'RE IN WAIT AGAIN

;BREAK: PRINT & COUNT

EACT16:	PUSHJ P,EPCOUT
	 JRST ECHBAK

;BREAK: NO PRINT, NO COUNT

EACT2:	HRROI T1,1	;-1 FOR LEFT HALF 1 FOR RIGHT HALF
	ADDM T1,LDBBKC(U)
	AOS LDBTIC(U)
	JRST EACT1A	;GO WAKE UP

;BREAK: PRINT, NO COUNT

EACT3:	PUSHJ	P,E1IDPB	;OUTPUT IF NOT BACKPRESSURED
	JRST EACT2

;(EACT4)  BREAK2: PRINT & COUNT
;(EACT4A) BREAK2: NO PRINT, NO COUNT

EACT4:	PUSHJ P,EPCOUT
	 JRST ECHBAK
EAC4A:	HRROI T1,1
	ADDM T1,LDBBK2(U)
	JRST EACT1B

;IMAGE

EACT5:	PUSHJ	P,E2IDPB	;OUTPUT IF NOT BACKPRESSURED
	MOVNI P1,1	;OUT OF ROOM
	JRST EACT1B
SUBTTL	NONBREAK: PRINT & COUNT; NORMAL OR BREAK2 MODE

EACT10:	TLNE U,LDLNEC		;WORRY ABOUT ECHO
	 JRST EAC10A		;NO ECHO
	PUSHJ P,EPCOUT
	  JRST ECHBAK
EAC10A:	AOS T4,LDBTIC(U)
	CAIG T4,TIWKC
	 JRST ECHLST	;DO NOT WAKE UP
EAC10B:	PUSHJ P,USRWAK
	SOS LDBECC(U)
	JRST WATLIN	;NO MORE ECHO UNTIL WE'RE IN WAIT AGAIN

;NONBREAK: PRINT & COUNT; BREAK-ON-ALL MODE

EACT6:	TLNE U,LDLNEC
	JRST EACT6A
	PUSHJ P,EPCOUT
	 JRST ECHBAK
EACT6A:	AOS LDBTIC(U)
	JRST EAC10B

;IMAGE; NORMAL OR BREAK2 MODE

EACT11:	TLNE U,LDLNEC
	JRST EAC11A
	PUSHJ	P,E2IDPB	;OUTPUT IF NOT BACKPRESSURED
	MOVNI P1,1
EAC11A:	LDB T1,LDPIMB
	CAME T1,T3
	JRST EAC10A	;WAK IF COUNT BIG ENOUGH
	JRST EACT6A	;SPECIAL BREAK, WAKE

;IMAGE; BREAK-ON-ALL MODE

EACT7:	TLNE U,LDLNEC
	JRST EACT6A
	PUSHJ	P,E1IDPB	;OUTPUT IF NOT BACKPRESSURED
	JRST EACT6A
SUBTTL	BREAK: PRINT & COUNT; NOT COMMAND MODE

EACT17:	TLNE U,LDLNEC
	JRST EACT12	;DO NOT ECHO
	PUSHJ P,EPCOUT
	 JRST ECHBAK

;BREAK: NO PRINT, NO COUNT; NOT COMMAND MODE

EACT12:	HRROI T1,1
	ADDM T1,LDBBKC(U)
	JRST EACT6A

;BREAK: PRINT, NO COUNT; NOT COMMAND MODE

EACT13:	TLNE U,LDLNEC
	JRST EACT12
	PUSHJ	P,E1IDPB	;OUTPUT IF NOT BACKPRESSURED
	JRST EACT12

;(EACT14)  BREAK2: PRINT & COUNT; BREAK-ON-ALL OR BREAK2 MODE
;(EACT14A) BREAK2: NO PRINT, NO COUNT; BREAK-ON-ALL OR BREAK2 MODE

EACT14:	TLNE U,LDLNEC
	JRST EAC14A
	PUSHJ P,EPCOUT
	 JRST ECHBAK
EAC14A:	HRROI T1,1
	ADDM T1,LDBBK2(U)
	JRST EACT6A

;(EACT15)  BREAK2: PRINT & COUNT; NORMAL MODE
;(EACT15A) BREAK2: NO PRINT, NO COUNT; NORMAL MODE

EACT15:	TLNE U,LDLNEC
	JRST EAC15A
	PUSHJ P,EPCOUT
	JRST ECHBAK
EAC15A:	HRROI T1,1
	ADDM T1,LDBBK2(U)
	JRST EAC10A
SUBTTL	SPECIAL ACTION

ECHSPA:	LDB T1,LDPMOD
	LDB T2,CHPSPE
	XCT @ECHSPT(T1)

ECHSPT:	XCT SPEPDP(T2)
	XCT SPE940(T2)
	XCT SPE940(T2)
	XCT SPEPDP(T2)

SPEPDP:	JRST SPEUXC	;ECHO ^X RETURN (^C)
	JRST SPECR	;RETURN
	JRST SPEUX	;ECHO ^X (^U)
	JRST SPETAB	;TAB
	JRST SPEALT	;33
	JRST SPEVM	;V. TAB
	JRST SPEVM	;FF
	JRST SPEUXC	;ECHO ^X RETURN (^Z)
	JRST SPEALP	;175-176
	JRST SPEBS	;BACKSPACE

SPE940:	JRST SPEBRK	;TYPE 2
	JRST SPECR	;RETURN
	JRST SPEBRK
	JRST SPETAB	;TAB
	JRST SPEBRK	;33
	JRST SPEVM	;V. TAB
	JRST SPEVM	;FF
	JRST SPEBRK	;TYPE 2
	JRST SPEAP1	;175-176
	JRST SPEBS	;BACKSPACE
SUBTTL	TREAT AS NONBREAK: PRINT & COUNT

SPECR:	MOVEI T1,1
	JRST ECHRPT	;JUST TURN INTO TYPE 1

;TREAT AS BREAK: NO PRINT, NO COUNT

SPEBRK:	MOVEI T1,2
	JRST ECHRPT	;TYPE 2

;TREAT AS BREAK: PRINT, NO COUNT

SPEBK3:	MOVEI T1,3
	JRST ECHRPT	;TYPE 3

;TREAT AS BREAK: PRINT & COUNT

SPEBK6:	MOVEI T1,6
	JRST ECHRPT	;TYPE 6

;RIGHT BRACE OR TILDE IN 940 MODE

SPEAP1:	TLNN U,LDLLCT	;175-176
	JRST SPEBK6	;TTY LC, BREAK: PRINT & COUNT
	JRST SPEBRK	;TTY NO LC, BREAK: NO PRINT, NO COUNT

;RIGHT BRACE OR TILDE IN PDP10 MODE

SPEALP:	TLNN U,LDLLCT
	 JRST SPEBK6	;TTY LC, BREAK: PRINT & COUNT
	PFALL SPEALT	;TTY NO LC, EQUIVALENT TO ESC

;ESCAPE IN PDP10 MODE

SPEALT:	MOVSI T3,LXLDLR
	TDNE T3,LDBDCX(U) ;IF USER SUPPRESSING $ ECHO
	TLNE U,LDLCOM	;OR WE'RE AT COMMAND LEVEL
	SKIPA		;ECHO A $
	JRST SPEBRK
	MOVEI T3,"$"
	JRST SPEBK6	;YES, SAY IT WAS A $
SUBTTL	HORIZONTAL TAB

SPETAB:	MOVE	T1, LDBBYT(U)
	TLNE	T1, L2LNTB	; NO ECHO?
	JRST	SPETB1
	TLNE	T1, L2LTBK	; BREAK ?
	JRST	SPEBK6		; BREAK & ECHO
	MOVEI	T1, 4
	JRST	ECHRPT		; BREAK2 & ECHO

SPETB1:	TLNE	T1, L2LTBK	; BREAK ?
	JRST	SPEBRK		; BREAK & NO ECHO
	MOVEI	T1, 7
	JRST	ECHRPT		; BREAK2 & NO ECHO

;VERTICAL TAB OR FORMFEED

SPEVM:	MOVSI	T1, L2LNTB
	TDNN	T1, LDBBYT(U)	; ECHO?
	JRST	SPEBK6		; YES
	JRST	SPEBRK		; NO

;BACKSPACE

SPEBS:	MOVE	T1,LDBBYT(U)
	LDB	T2,LDPECH	;REMOTE BS ECHO SET
	JUMPE	T2,SPEBS1	;NO, DON'T ECHO
	TLNN	T1,L2LBBP	;BREAK
	JRST	SPEBK6		;BREAK & ECHO
	MOVEI	T1,4
	JRST	ECHRPT		;BREAK2 & ECHO

SPEBS1:	TLNN	T1,L2LBBP	;BREAK
	JRST	SPEBRK		;BREAK & NO ECHO
	MOVEI	T1,7
	JRST	ECHRPT		;BREAK2 & NO ECHO
SUBTTL	ECHO <CONTROL CHAR> AS ^<CONTROL CHAR + 100>

SPEUX:	TLNN U,LDLCOM
	TLNN U,LDLNEC	;ALWAYS DO IT IN COMMAND MODE
	SKIPA
	JRST SPEBRK	;OTHERWISE NOT IF NO ECHO
	PUSHJ P,SPEUCM	;COMMON ^X ECHO CODE
	 JRST ECHBAK
	JRST SPEBRK

;ECHO <CONTROL CHAR> AS ^<CONTROL CHAR + 100><CR><LF>

SPEUXC:	TLNN U,LDLCOM	;SAME AS SPEUX BUT ADD RETURN
	TLNN U,LDLNEC
	SKIPA
	JRST SPEBRK
	PUSHJ P,SPEUCM	;ECHO THE ^X
	 JRST ECHBAK	;DID NOT MAKE IT
	MOVE T4,CRPTR	;GET READY FOR THE RETURN LF
	JUMPL P1,SPEUX1	;OUT OF ROOM, MUST USE RUBOUT STRING
	MOVEI T3,0
	DPB T3,LDPPOS	;RESET POSITION
	PUSHJ P,SPOFIL
	 JRST SPEBRK	;HAVE PUT OUT THE CRLF (OR TO FILLER)
	JRST SPEBRK	;SAME

SPEUX1:	PUSHJ P,RUBSTR
	JRST SPEBRK

;COMMON CODE FOR SPEUX AND SPEUXC

SPEUCM:	JUMPL	U,EPCOU1	;CAN'T OUTPUT NOW
	LDB T4,LDPPOS
	ADDI T4,2	;MAKE SURE BOTH FIT ON SAME LINE
	MOVEI T3,"^"	;THE ^
	PUSHJ P,PRCCR	;THIS WILL PUT IN A CRLF IF NEEDED
	 POPJ P,	;^ NOT SENT, OUT OF ROOM, BACK UP
	CAIN T4,1	;^ SEND, T4 IS LDPPOS, IF 1 CRLF SENT
	AOJA T4,[DPB T4,LDPPOS	;MUST SET TO 2
		JRST .+1]
	LDB T3,LDBECT(U)	;GET BACK CHARACTER
	TRO T3,100
	JUMPL P1,SPEUC1	;ALREADY OUT OF ROOM, INTO RUBOUT STRING
	PUSHJ	P,E2IDPB	;OUTPUT IF NOT BACKPRESSURED
	MOVNI P1,1
	JRST CPOPJ1	;FINISHED

SPEUC1:	PUSHJ P,ENTRUB
	MOVEI T1,1
	DPB T1,LOPRUB	;SET TO SEND RUBOUT STRING
	JRST CPOPJ1	;P1 IS NEG SO WILL FINISH
SUBTTL	DON'T ECHO IF PORT BACKPRESSURED

EPCOUT:	JUMPGE	U,PRCOUT	;DO OUTPUT IF NOT BACKPRESSURED
EPCOU1:	POP	P,T1		;FLUSH RETURN ADDR
	SETZ	T1,
	DPB	T1,LDBOPB(U)	;TURN OFF NEED OUTPUT
	MOVSI	T3,110000
	ADDM	T3,LDBECT(U)	;BACK UP BYTE POINTER
	JRST	FULLIN		;GO ON TO NEXT LINE

E1IDPB:	JUMPL	U,EPCOU1	;CAN'T ECHO NOW
	UUIDPB	T3,CHRWRP(W)
	SOSLE	MULCNT(W)
	SOS	CHCNT
	POPJ	P,

E2IDPB:	JUMPL	U,EPCOU1	;CAN'T ECHO NOW
	UUIDPB	T3,CHRWRP(W)
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	POPJ	P,
	JRST	CPOPJ1
SUBTTL OUTPUT FILLER LOGIC

;SEND FILLER CHARACTERS

PGFIL:
GOFIL:	ILDB	T3, LDBFLP(U)	;T3/ NEXT CHAR, OR 0 IF LDBFLP=0
	JUMPE	T3, [		;IF NO (MORE) CHARACTERS,
		SETZM	LDBFLP(U)	;CLEAR THE POINTER
		JRST	MORLIN
	]
	TRZ	T3, 200		;WHAT IS THIS FOR???
	UUIDPB	T3, CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	JRST	FULLIN		;NO MORE ROOM
	JRST	GOFIL		;BACK FOR MORE
SUBTTL	PRCOUT - CALLED WITH T3/ THE CHARACTER TO PRINT,
;	   PRINTS THE CHARACTER (MAPPING UPPER CASE TO LOWER
;	   CASE IF SO ENABLED), INSERTS FREE CRLFS AND
;	   HT/VT/FF PADDING/SIMULATION CHARACTERS IF NECESSARY.
;	   IF IT CAN'T PRINT THE CHARACTER, IT NONSKIP-RETURNS
;	   WITH T3/ 110000,,0 (WITH WHICH THE CALLER CAN BACK UP
;	   A BYTE POINTER). OTHERWISE, IT SKIP-RETURNS. IT MAY
;	   SET THE NEED-FILLER BIT, AND IT WILL SET P1 = -1 IF
;	   THERE'S NO CHARACTER SPACE LEFT.

PRCOUT:	TRNN	T3, 400		;IF IT'S AN IMAGE CHARACTER
	TLNE	U, LDLSOX	;OR SUPPRESSING OUTPUT TRANSLATION,
	JRST	PRCOT3		;  JUST SEND IT
	TRNE	T3, 200
	SKIPA	P3, CHRTAB-200(T3)
	MOVE	P3, CHRTAB(T3)	;P3/ CHARACTER-TYPE BITS
	LDB	T1, CHPOUT	;T1/ CHARACTER PRINT MODE
	XCT	[
		JRST PROACT	;0 SPECIAL ACTION
		LDB T4, LDPPOS	;1 PRINT AND COUNT 1 CHARACTER-WIDTH
		JRST PRCOT3	;2 PRINT BUT DON'T COUNT
		JRST PROUCC	;3 UPPER CASE ACTION
	](T1)

    ;HERE ON 1-CHARACTER-WIDE CHARACTERS

PRCOCW:	AOJ	T4,		;T4/ POSITION ON LINE

    ;HERE WITH T4/ POSITION, FROM ABOVE AND FROM ECHO CODE,
    ;TO PRINT A FREE CR IF ONE IS NEEDED, THEN THE CHAR IN T3

PRCCR:	LDB	T1,LDPWID	;T1/ LINE WIDTH
	CAMLE	T4,T1		;IF THE LINE ISN'T FULL
	TLNE	U,LDLNFC!LDLSOX	;OR THE USER DOESN'T WANT FREE CRLFS
	 JRST	PRCOT1		;  JUST PRINT THE CHARACTER
    ;HERE TO PRINT A CRLF

	MOVE	T4, CRPTR
PRCFIL:	ILDB	T2, T4		;T2/ NEXT CHARACTER
	JUMPE	T2, [		;IF WE'RE DONE,
		MOVEI	T4, 1		;LINE POSITION WILL BE 1
		JRST	PRCOT2		;GO PRINT THE CHARACTER
	]
	UUIDPB	T2, CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	JRST	.+2		;(NO MORE ROOM)
	JRST	PRCFIL		;BACK FOR MORE
	MOVE	T3, T4
	ILDB	T3, T3		;T3/ THE NEXT CHAR
	JUMPE	T3, PRCFL1	;IF IT WASN'T THE TERMINATING NUL,
	MOVEM	T4, LDBFLP(U)	;  SET THE REST AS FILLER
	MOVEI	T4, 1
	DPB	T4, LOPFIL	;  SET THE NEED-FILLER BIT
PRCFL1:	MOVSI	T3, 110000	;(MAGIC SO CALLER CAN BACKUP BYTE PTR)
	DPB	T3, LDPPOS	;LINE POSITION := 0
	POPJ	P,

PRCOT1:	CAIG	T4, 377
PRCOT2:	DPB	T4, LDPPOS
PRCOT3:	UUIDPB	T3, CHRWRP(W)
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	SETO	P1,
	JRST	CPOPJ1
SUBTTL	HERE ON SPECIAL-ACTION CHARACTERS

PROACT:	LDB T2,CHPSPO
	XCT SPOTBL(T2)	;DO CORRECT OUTPUT THING FOR CHR

SPOTBL:	JRST SPOCR	;RETURN
	JRST SPOTAB	;TAB
	JRST SPOVT	;VERTICAL TAB
	JRST SPOFF	;FORM FEED
	JRST SPOBS2	;BACKSPACE

;CARRIAGE RETURN

SPOCR:	MOVEI T4,0
	JRST PRCOT2	;OUTPUT BUT SET POS TO 0

;HORIZONTAL TAB

SPOTAB:	LDB T1,LDPPOS	;GET CURRENT POSITION
	TRO T1,7
	ADDI T1,1	;WHERE IT WILL BE
	LDB T4,LDPWID
	TLNN U,LDLNFC
	CAMGE T1,T4	;WILL WE OVERFLOW?
	 JRST SPOTB0	;NO OR NO CR WANTED
	MOVEI T1,0
	DPB T1,LDPPOS	;SET TO 0 POSITION
	MOVE T4,CRPTR
	JRST SPOFIL

SPOTB0:	LDB T4,LDPPOS	;NO CR, GET CURRENT POSITION
	TRNN T1,400
	DPB T1,LDPPOS	;SAVE NEW
	TLNE U,LDLTAB
	JRST SPOTB1	;TTY DOES TABS, JUST FILL
	ANDI T4,7
	MOVE T4,TABPTR(T4)	;GET CORRECT NUMBER
	JRST SPOFIL	;AND SEND

SPOTB1:	LDB T1,LDPFC2
	TRNN T4,4
	SKIPA T4,TBFL2(T1)	;USE LONG FILL
	MOVE T4,TBFL(T1)	;OR SHORT FILL
	JRST SPOFL1
SUBTTL	FORM FEED

SPOFF:	TLNE U,LDLFRM	;IF TTY DOESN'T DO FORMS,
	JRST SPOFF1
	MOVE T4,FFFLP
	JRST SPOFIL	;  SEND LINEFEEDS
SPOFF1:	LDB T1,LDPFC1	;IF IT DOES,
	MOVE T4,FLLFFS(T1)
	JRST SPOFL1	;  SEND PAD CHARACTERS

;VERTICAL TAB

SPOVT:	TLNE U,LDLFRM	;IF TTY DOESN'T DO VERTICAL TABS,
	JRST SPOVT1
	MOVE T4,VTFLP
	JRST SPOFIL	;  SEND LINEFEEDS
SPOVT1:	LDB T1,LDPFC1	;IF IT DOES,
	MOVE T4,FLLVTS(T1)
	JRST SPOFL1	;  SEND PAD CHARACTERS

;BACKSPACE

SPOBS2:	PUSHJ	P, SPOBSP	;UPDATE CHAR COLUMN COUNTER
	JRST	PRCOT3

SPOBSP:	MOVSI	T1, L2LBSP	;IF NEITHER BS FOR CHAR DELETE
	TDNE	T1, LDBBYT(U)
	JRST	SPOBS1
	LDB	T1, LDPECH	;NOR REMOTE BS ECHO
	JUMPE	T1, CPOPJ	;THEN DON'T COUNT IT
SPOBS1:	LDB	T1, LDPPOS
	SOSL	T1
	DPB	T1, LDPPOS	;IF POS-1 .ge. 0, POS:=POS-1
	POPJ	P,

;SPOFIL -- CALLED WITH T4/ FILL POINTER. OUTPUT THE FILL CHARACTERS.
;	   IF THERE'S NOT ENOUGH OUTPUT RING SPACE, SET UP LDPFLP
;	   TO POINT TO WHAT'S LEFT, SET P1 = -1, AND LET GOFIL
;	   DO THE REST. SKIP-RETURNS ALWAYS.
;SPOFL1 -- OUTPUT THE CHAR IN T3, THEN THE T4 STRING

SPOFIL:	ILDB	T3, T4		;T3/ NEXT CHAR
	JUMPE	T3, CPOPJ1	;DONE
SPOFL1:	UUIDPB	T3, CHRWRP(W)	;DEPOSIT IT
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	JRST	.+2		;(NO ROOM)
	JRST	SPOFIL		;BACK FOR MORE
	SETO	P1,		;SET NO-MORE-ROOM FLAG
	MOVE	T3, T4
	ILDB	T3, T3		;T3/ NEXT CHAR
	JUMPE	T3, CPOPJ1	;IF IT WASN'T THE TERMINATING NUL,
	MOVEM	T4, LDBFLP(U)	;  SET THE REST AS FILLER
	MOVEI	T3, 1
	DPB	T3, LOPFIL	;  AND SET NEED-FILLER
	JRST	CPOPJ1
SUBTTL	FILLER	POINTERS AND VARIOUS ECHO POINTERS

CCPTR:	POINT 7,CCASC
CCASC:	ASCIZ /\^C
/

CRPTR:	POINT 7,CCASC,20	;JUST THE RETURN FROM ABOVE

CUPTR:	POINT 7,CUASC
CUASC:	ASCIZ /\^U
/

UPARPT:	POINT 7,UPASC
UPASC:	ASCIZ /\^
/

COPTR:	POINT 7,COASC
COASC:	ASCIZ /\^O
/

FLLBSC:	POINT 7,BSLASC
BSLASC:	ASCIZ /\
/

FFFLP:	POINT 7,FFLP0		;FILLER FOR SIMULATING FORM FEED
FFLP0:	BYTE (7) 12,12,12,12,12,12,12,12,0

VTFLP:	POINT 7,FFLP0,27	;FILLER FOR SIMULATING VERTICAL TAB

	DEFINE FILLP(N)
<IF1,<IFG N-FLMX,<FLMX==N>
	0>
IF2,< XXXQ==<FLMX-N>/5
XXXR==FLMX-N-<XXXQ*5>

IFE XXXR,<POINT 7,FILERS+XXXQ>
IFN XXXR,<POINT 7,FILERS+XXXQ,<7*XXXR>-1>>>

;THE ABOVE MACRO DEFINES POINTERS INTO A LIST OF FILLERS (377)
IF1,<FLMX==0>

FLLFFS:	0
	FILLP ^D12
	FILLP ^D15
	FILLP ^D40

FLLVTS:	0
	FILLP 6
	FILLP 5
	FILLP ^D20

TBFL:	0
	FILLP 1
	FILLP 3
	FILLP 3

TBFL2:	0
	FILLP 2
	FILLP 5
	FILLP 5

;NOW GENERATE FILLERS

	DEFINE GENFL(X)
<XXQ==X/5
	REPEAT XXQ,<BYTE (7) 177,177,177,177,177>
XXQ==X-<XXQ*5>
IFE XXQ,<0>
IFE XXQ-1,<BYTE (7) 177>
IFE XXQ-2,<BYTE (7) 177,177>
IFE XXQ-3,<BYTE (7) 177,177,177>
IFE XXQ-4,<BYTE (7) 177,177,177,177>
>

FILERS:	GENFL (FLMX)
TABPTR:	POINT 7,SSPT
	POINT 7,SSPT,6		;FILLERS TO SIMULATE TABS WITH SPACES
	POINT 7,SSPT,13
	POINT 7,SSPT,20
	POINT 7,SSPT,27
	POINT 7,SSPT+1
	POINT 7,SSPT+1,6
	POINT 7,SSPT+1,13

SSPT:	BYTE (7) 40,40,40,40,40,40,40,40,0

;HERE IF CHARACTER IS UPPER CASE

PROUCC:	HLRZ	T1,LDBDCX(U)	;GET LEFT HALF OF DEV CHR EXT WORD
	TRNE	T1,LXLLCO	;SKIP IF U TO L CASE CONV NOT DESIRED
	ADDI	T3,40		;CONVERT CHAR TO LOWER CASE
	LDB	T4,LDPPOS
	JRST	PRCOCW		;PRINT AND COUNT 1 CHARACTER-WIDTH

SUBTTL ONCE A SECOND LOGIC

;THIS ROUTINE IS CALLED EVERY SECOND TO WORRY ABOUT IMAGE MODE
;TIME OUTS AND TO MAKE SURE THAT SOMEONE WHO IS JUST WAITING
;FOR SOME SPACE TO FILL HIS OUTPUT BUFFER GETS RESTARTED

SCNSEC::MOVSI	T3,(BV.DBG)	;Get base version and debugging flag
	TDNN	T3,BASVER	;Is base being debugged?
	SKIPE	CTYDO##		; or running in CONSOLE mode?
	 JRST	SCNSC0		;Yes, ignore timeouts
	MOVE	T1,KEYTIM##	;Ticks since key was updated
	MOVE	T2,IRPTIM##	;Ticks since last input
	CAML	T1,T2		;Get smaller in T1
	 MOVE	T1,T2
	IDIV	T1,JFYSEC##	;Seconds since last input
IFCPU(KS),<ND BASTIM,777777>	;Wait a long time on the 2020
	   ND BASTIM,^D90	;1.5 minutes on KI, KL, F3
	SKIPL	IRPTIM##	;Only output this message once
	CAIGE	T1,BASTIM	;Has it been too long?
	 JRST	SCNSC0		;No message
	 STOPCD (.+1,EVENT,NOBASE,PRTBTM,<No response from BASE>)
	SETOM	BASDWN##	;Set flag to mark base down
	POPJ	P,		;Do something about it next tic

PRTBTM:	PUSHJ	P,INLMES##	;Called from STOPCD(NOBASE)
	 ASCIZ /No response from base.  Please reload it.  PDP-10 is still up.
/
	MOVSI	T1,(1B0)	;Set flag saying NOBASE message output done
	IORM	T1,IRPTIM##
	POPJ	P,

SCNSC0:
IFKMC<	SKIPE	CRSHWD##	;If location 30 is nonzero,
	 PUSHJ	P,HNGALL	; hang all jobs before halting 2020
	MOVEI	P4,MXLIN##	;FOR EACH LINE
	AOS	DRMTIM		;INC MESSAGE TIMER
	SOSGE	TIMMIN		;KMC MINUTE COUNTER
	 JRST 	[MOVEI T1,^D60
		MOVEM T1,TIMMIN	;SET FOR ONE MINUTE
		PUSHJ P,SCNMIN	;CALLED EVERY MINUTE
		JRST	.+1]
	SOSGE	TIMDRD		;COUNTER FOR SERVICING DOWN DRs
	 JRST 	[MOVEI T1,^D60
		MOVEM T1,TIMDRD	;SET FOR ONE MINUTE
		PUSHJ P,SCNDRD	;TIMING VARIES BUT IS USUALLY 60
		JRST	.+1]
>;END IFKMC
	MOVE	T1,PTYFLO
	MOVEM	T1,MULCNT+1	;LET PTYS OUTPUT SOME MORE
	SKIPLE	OPRTIM
	SOSLE	OPRTIM		;IF OPER TIMEOUT HAS GONE OFF,
	 JRST	SCNSC1
	MOVEI	T1,ALROPR
	IORM	T1,ALR620	;  SET THE ALARM CELL
SCNSC1:	SOSL	TIMOW		;IF ORANGE-BALL-WAIT HAS GONE OFF,
	 JRST	SCNSC2
	MOVEI	T1,OWTIM
	MOVEM	T1,TIMOW	;  RESET IT
SCNSC2:	MOVEI	P4,MXLIN##	;(LOOP THROUGH ALL PORTS)

SECLOP:	MOVE	U,LINTAB(P4)
	HLL	U,LDBDCH(U)	;U/ DCH BITS,,LDB ADDR
	HRRZ	F,LDBDDB(U)	;F/ DDB ADDR
	MOVE	T1,LDBMOD(U)
	TLNE	T1,LMLBIO	;IF PORT'S IN BLOCK MODE,
	 JRST	[
		PUSHJ	P,BIOCHG	;CHARGE FOR ELAPSED TIME
		MOVEI	T1,LDRBIP	;CHECK TIMEOUT IF PTY BLKI
		JRST	SECLP1
	]
	MOVSI	T1,LDLIMI	;ELSE CHECK TIMEOUT IF IN IMAGE STATE
SECLP1:	TDNN	T1,LDBDCH(U)	;IF WE DON'T CARE ABOUT TIMEOUTS,
	 JRST	SECLP2		;  SKIP THIS STUFF
    ;CODE TO CHECK THE PER-PORT TIMEOUT FIELD

	LDB	T3,LDPTIM	;T3/ SECONDS REMAINING, OR 0
	SOSL	T3		;IF IT WASN'T 0,
	DPB	T3,LDPTIM	;  DECREMENT IT
	JUMPN	T3,SECLP2	;IF IT JUST RAN OUT,
	MOVEI	T1,LDRBIP
	TDNN	T1,LDBDCH(U)	;  IF PTY BLOCK INPUT IS IN PROGRESS,
	 JRST	SECTM1
	PUSHJ	P,PBTIMO	;    TIME IT OUT
	JRST	SECLP2

SECTM1:	JUMPE	F,SECTM3	;  IF NO DDB, FORCE OUT OF IMAGE STATE
	LDB	T1,LDPIMB	;  T1/ 0, OR IMAGE BREAK CHAR
	JUMPN	T1,SECTM2	;  IF THERE'S NO BREAK CHAR,
	PUSHJ	P,IMGCHG	;    CHARGE FOR A WAKEUP
	PUSHJ	P,LINTRP	;    SIGNAL A BREAK
	PUSHJ	P,USRWAK	;    WAKE THE JOB
SECTM2:	TLNE	U,LDLAUX	;  IF IT'S NOT AN AUX CIRCUIT,
	 JRST	SECLP2
	SKIPN	LDBTIC(U)
	SKIPE	LDBECC(U)	;    IF THERE'RE NO CHARACTERS,
	 JRST	SECLP2
	MOVSI	S,IOEND
	IORB	S,DEVIOS(F)	;      SET EOF
	TRNE	S,10
	TRNE	S,7
	 JRST	SECLP2		;      IF IMAGE MODE,
SECTM3:	MOVSI	T1,LDLIMI
	ANDCAM	T1,LDBDCH(U)	;        FORCE OUT OF IMAGE STATE
	PUSHJ	P,BPOFF		;        CLEAR BACKPRESSURE
	PUSHJ	P,SETLMD	;        FIX LINE MODE
    ;THE REST OF THE PER-PORT ONCE-A-SECOND CODE

SECLP2:	MOVSI	T1,L2LOWT
	SKIPN	TIMOW		;IF ORANGE-BALL-WAIT TIMER'S GONE OFF
	TDNN	T1,LDBBYT(U)	;AND PORT'S WAITING FOR ORANGE BALL,
	 JRST	SECLP3
	MOVSI	T1,L2LOWS
	TDNN	T1,LDBBYT(U)	;  IF WE HAVEN'T BEEN HERE BEFORE,
	 JRST	[
		IORM	T1,LDBBYT(U)	;SET THE ONCE-BEFORE FLAG
		JRST	SECLP3
	]
	PUSHJ	P,OBFND		;  IF WE HAVE, FAKE AN ORANGE BALL

;P035/C06 17-Nov-87 - Watch for lost zappers.
	..==LNLZIN		;CREF this reference to sign bit
SECLP3:	SKIPGE	LDBLIN(U)	;Is there an in-zap seen?
	 JRST	[MOVEI  T1,1	    ;Yes
		 LDB    T2,LDBOPB(U);See if it is scheduled to go out
		 DPB    T1,LOPZAP   ;Make sure the "send zap" bit is on
		 DPB    T1,LDBOPB(U); and "need output" is on
		 MOVSI  T1,L2LOWT   ; and orange-ball wait
		 ANDCAM T1,LDBBYT(U); is off
		 SKIPN  T2          ;If it wasn't scheduled,
		  AOS    NZAPRS	   ;Count number of zaps resent
		 JRST  .+1]
	JUMPE	F,SECLP4	;IF THERE'S A DDB
	MOVSI	S,TWTSPC
	TDNN	S,DEVIOS(F)	;AND IT'S WAITING FOR BUFFERLETS
	 JRST	SECLP4
	MOVE	T1,TTFREN
	CAIG	T1,TIRSVD	;AND THERE'RE ENOUGH NOW,
	 JRST	SECLP4
	ANDCAM	S,DEVIOS(F)	;  CLEAR BUFFERLET-WAIT BIT
	PUSHJ	P,XMTWAK	;  AND AWAKEN JOB
SECLP4:	SOJG	P4,SECLOP	;(CONTINUE WITH NEXT PORT)
	POPJ	P,


BIOCHG:	JUMPE	F,CPOPJ		;CHECK FOR DETACHED JOB.
	LDB	T1,PJOBN	;PICK UP HIS JOB NUMBER.
	AOS	JBTBET(T1)	;INCREMENT HIS ELAPSED BIO TIME.
	AOS	JBTBET		;INCR TOTAL ELAPSED BIO TIME.
	POPJ	P,		;AND RETURN.
SUBTTL MISC STUFF FOR INPUT AND OUTPUT
;SUBROUTINE TO WAKE UP JOB IF IT IS IN TTY INPUT WAIT. CALL WITH
;U SET UP. IT WILL SET F AND S AS NEEDED.

USRWAK:	HRRZ	T1,LDBBIO(U)	; DOING BLOCK INPUT ?
	JUMPE	T1,USRWK1	; NO
	SKIPGE	BIOCHR(T1)	; YES. REQUEST IN PROGRESS ?
	 POPJ	P,		; YES. LEAVE IT ALONE.
BIOWAK:
IFCPU (KL),<
	TLNE	S,IO		;IF BLOCK INPUT,
	 JRST	USRWK1		;(OUTPUT, FORGET IT)
	HRRZ	T1,LDBBIO(U)	;THEN MUST MAKE SURE EDGES OF DATA NOT IN CACHE
	JUMPE	T1,USRWK1
	ADDI	T1,BIODAT	;GET ADDRESS OF 1ST DATA WORD
	CSHREF			;TAKE THAT 4 WD CHUNK OUT OF THE CACHE
	HRRZ	T1,LDBBIO(U)	;GET ADDRESS AGAIN
	ADDI	T1,BIOCOR*4-1	;ADDRESS OF LAST WORD
	CSHREF			;THAT TAKES CARE OF ADJACENT REFS DURING I/O
>;END IFCPU (KL)
USRWK1:	MOVSI	T1,L2LLDF
	ANDCAM	T1,LDBBYT(U)	;TURN OFF WHEN USER IS AWAKENED
	HRRZ	F,LDBDDB(U)	;GET ADDRESS OF ATTACHED F
	JUMPE	F,RCVWK1	;IF NONE,SKIP THIS CODE
	MOVE	S,DEVIOS(F)	;GET STATUS OF TTY FROM F
	TRNE	S,IOACT		;SINCE IOW MAY NOT BE SET YET
	TLNE	S,TTYOUW	;YES. FOR INPUT WAIT?
	 JRST	RCVWK1		;NO. DONT WAKE JOB.
TIWAKE:	TLNN	S,IOW		;IS IOW REALLY SET
	 JRST	TIWAKN		;NO
	MOVE	S,[XWD IOW,IOACT];YES. CLEAR WAIT BITS
	ANDCAB	S,DEVIOS(F)	;IN F FOR THIS JOB
	PUSH	P,T1		;SAVE VOLATILE AC'S
	PUSH	P,T2		; ..
	PUSHJ	P,STTIOD	;SET JOB TO TS STATE
	POP	P,T2		;RESTORE AC'S
	POP	P,T1		; ..
RCVWK1:	POPJ	P,0		;RETURN FROM RCVWAK

TIWAKN:	MOVEI	S,IOACT
	ANDCAB	S,DEVIOS(F)	;JUST RESET IOACT
	POPJ	P,

FULLCQ:	MOVE	T1,LDBDCH(U)
	TLNN	T1,LDLCOM	;IF NOT CMND MODE
	TDNN	T1,[LDLBKA,,LDRFCS];AND HE WANTS TO SEE EDIT CHARS,
	 AOS	(P)
	POPJ	P,		;  NONSKIP-RETURN
SUBTTL	SUBROUTINE TO SEE IF A CONTROL C SHOULD BE ACTED ON OR STORED.
;NON-SKIP MEANS STORE IT.
;SKIP MEANS DO IT.

CNCCHK:	TLNE	U,LDLCOM	;SHOULD ^C BE RETURNED?
	 POPJ	P,0		;YES.
	PUSH	P,T1		;MAYBE NOT. SAVE TAC.
	HRRZ	F,LDBDDB(U)	;GET U'S JOB
	JUMPE	F,CNCCK1	;IF NO F ATTACHED, ASSUME SHOULD DO ^C
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	 JRST	TPOPJ		;THIS IS A SLAVED TTY
	LDB	T1,PJOBN	; ..
	MOVE	T1,JBTSTS(T1)	;GET JOB STATUS WORD
	TDNE	T1,[XWD JACCT,JACCT2] ;IS ^C LEGAL?
	 JRST	TPOPJ		;NO. GIVE IT TO CUSP
CNCCK1:	PUSHJ	P,CNCMOD	;FORCE LINE TO BE AT COMMAND LEVEL
	MOVEI	T1,CMFCHT##
	PUSHJ	P,TTFORC	;FORCE HALT COMMAND
	JRST	TPOPJ1		;RESTORE T1, SKIP RETURN

SUBTTL	THIS ROUTINE TRACES BACKWARDS DOWN A LINKED LIST TO THE START
;AND THEN ADDS THE WHOLE LIST TO THE FREE LIST.
;Called from GORUB/PGRUB after outputing rubout characters.
;Called from TSETBI/TSETBO to clear input/output buffers.
;Uses T1 and T2 only.

FREUP:	PUSHJ	P,CHECKU	;Check on address in U
	ANDI	T2,777774	;GET BASE ADDRESS
FREST:	CAML	T2,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T2,RCC.HI	; to the TTY chunks
	 STOPCD (RCC.T3,INFO,RCCDBG,RCC.T1,<Range Checked Chunk, continuing>)
	HLRZ	T1,(T2)		;LOOK FOR BACK LINKS
	JUMPE	T1,STLST	;FOUND START
	MOVE	T2,T1		;TRY SOME MORE
	JRST	FREST

;JMS 7-May-86 - X95(KS) has a nasty habit of looping here.  Added TTYFLM.

STLST:	SKIPE	T1,TTFREE##	;Pointer to current free list (0 is OK)
	 CAML	T1,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T1,RCC.HI	; to the TTY chunks
	 SETZB	T1,TTFREE##	;Was bad, start with a new free list
	EXCH	T1,(T2)		;Make current chunk point to the old free list
	HRRZM	T2,TTFREE##	;Put current chunk at start of free list
	AOS	TTFREN		;Mark one more free
	TRNE	T1,777777	;If there is a next pointer,
	 HLRZ	T2,(T1)		; get its back pointer
	TLZ	T2,777777	;Clear LH for compare
	CAME	T2,TTFREE##	;Does next point back to current?
	 STOPCD (RCC.T3,INFO,TTYFLM,RCC.T1,<TTY Free List Messed Up>) ;;STLST+7
	HRRZ	T2,T1		;Did current chunk have a next one?
	JUMPN	T2,STLST	;Yes, continue until all are freed up
	POPJ	P,		;All done

;Check on U.  Uses T1.
CHECKU:	HRRZ	T1,U		;Make sure U is pointing to a legal LDB
	CAIN	T1,CTYLDB
	 POPJ	P,		;CTYLDB is outside the range of LDB.LO-LDB.HI
	CAML	T1,LDB.LO
	CAMLE	T1,LDB.HI
	 STOPCD (RCC.T3,DEBUG,RCCBAD,RCC.T1,<Range Checked Chunk, bad U>)
	POPJ	P,

;Resume address from RCC stopcodes - Set T1,T2,T3 to reasonable values
RCC.T3:	SETZB	T1,T2
	MOVEI	T3,'C'-'@'	;Return Control-C
	POPJ	P,

;Output contents of T1,T2, and U on STOPCD(TTYFLM) and STOPCD(RCCDGB)
RCC.T1:	HRRZ	F,LDBDDB(U)
	PUSHJ	P,PRTDDB##	;Output TTY name
	JSP	T1,BGCTYP##	;Output contents of T1, T2, and U
	  EXP	'T1    ',T1,'T2    ',T2,'LDB   ',U,0


XMTWAK:	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ		;NO JOB HOOKED TO IT
	MOVSI	S,L2LOWT	;IF WAITING FOR ORANGE BALL
	TDNE	S,LDBBYT(U)
	 POPJ	P,		;DON'T WAKE UP OUTPUT
	MOVE	S,DEVIOS(F)
	TLNN	S,TINFIO
	 JRST	XMTWK1
	LDB	T1,DDPTTS	;NOW TRAP ON READY FOR MORE OUTPUT
	PUSH	P,J
	PUSHJ	P,TAKTRJ
	MOVSI	S,TINFIO
	ANDCAB	S,DEVIOS(F)
	MOVEI	J,LXRIOS
	IORM	J,LDBDCX(U)
	POP	P,J
XMTWK1:	TRNE	S,IOACT		;SINCE IOW MAY NOT BE SET YET
	TLNN	S,TTYOUW
	 POPJ	P,		;NOT WAITING SO DONE
	PJRST	TIWAKE		;WAKE HIM UP
SUBTTL CHUNK HANDLERS

;SUBROUTINE TO READ A CHARACTER FROM A TELETYPE BUFFER
;CALL WITH T2 CONTAINING A BYTE POINTER TO THE LIST
;THIS ROUTINE WILL IBP T2 WHICH MAY POINT IT INTO A LINK WORD
;ALSO WE MAY BE CALLED WITH THE POINTER DECREMENTED SO THAT
;IBP WILL POINT TO THE CURRENT CHUNKS LINK WORD
;THIS ROUTINE WILL CORRECTLY FOLLOW THE LINKS. THE ROUTINE
;WILL NORMALLY SKIP RETURN. THE NON-SKIP RETURN IS TAKEN IF
;IT WAS NECESSARY TO FOLLOW A LINK. IN THIS CASE, T1
;CONTAINS THE BASE ADDRESS OF THE NEW CHUNK.
;ON RETURN, T2 CONAINS THE BYTE POINTER TO THE CHARACTER
;JUST OBTAINED, AND T3 THE CHARACTER

TTGETC:	PUSHJ	P,CHECKU	;Make sure U is pointing to a legal LDB
	ILDB	T3,T2		;IF WE GET INTO A LINK WORD, T3 WILL NOT
				;BE WHAT WE WANT BUT NOTHING WILL HAVE
				;BEEN CLOBBERED
	TRNE	T2,3		;ALL LINK WORDS ARE IN WORDS AT AN ADDRESS
				;WHICH IS A MULTIPLE OF 4
	 JRST	CPOPJ1		;ALL OK, JUST RETURN
	HRRZ	T1,-4(T2)	;THIS WILL BE THE FORWARD LINK TO NEXT CHUNK
	TLNN	T2,770000	;IF WE ARE AT THE RIGHT END OF THE WORD
				;WE MUST HAVE BACKED UP
	 HLRZ	T1,(T2)		;SO GET BACK LINK (T2 POINTS TO FIRST WORD OF CHUNK)
	JUMPE	T1,TTGC1	;NO LINK THERE
	CAML	T1,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T1,RCC.HI	; to the TTY chunks
	 STOPCD (,XCT,RCCDBG)	;Forward/back pointer is bad
	HRR	T2,T1		;NOW POINT TO CORRECT WORD
	TLNE	T2,770000
	 AOSA	T2		;IF FORWARD, POINT TO FIRST CHR
	ADDI	T2,TTCHKS-1	;IF BACKWARD, TO LAST
	LDB	T3,T2		;NOW GET THE CHARACTER
	POPJ	P,		;AND RETURN SAYING PASSED A LINK

;Stop at TTYNNC may be related to ZAP (or nonzap) at LDEC

TTGC1:	TLNE	T2,770000	;IS THIS A BACKUP
	 STOPCD (TSETBI,INFO,TTYNNC,,<TTY - No Next Chunk>) ;;TTGC1+1
	MOVEI	T3,0		;GIVE BACK 0
	JRST	CPOPJ1
SUBTTL	SUBROUTINE TO PLACE A CHARACTER IN A BUFFER.
;CHARACTER IS IN T3. T2 CONTAINS A BYTE POINTER TO LAST
;CHARACTER PLACED IN BUFFER. WE WANT TO DO AN IDPB T3,T2 BUT
;MUST WATCH FOR LINKS. WILL FOLLOW A FORWARD LIST IF IT
;EXISTS OR GET A NEW CHUNK IF NECESSARY

TTPUTC:	IBP	T2		;MUST NOT IDPB SINCE MIGHT CLOBBER SOMETHING
	TRNE	T2,3		;ARE WE IN A LINK?
	 JRST	TTPC1		;NO, ALL OK
	HRRZ	T1,-4(T2)	;GET LINK
	TLNN	T2,770000
	 STOPCD			;SOMEONE CALLED US AFTER BACKING UP
	JUMPN	T1,TTPC2	;HAVE A FORWARD LINK ALREADY
	MOVE	T1,TTFREE##	;GET A NEW CHUNK
	CAML	T1,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T1,RCC.HI	; to the TTY chunks
	 STOPCD (.,STOP,RCCSTP,RCC.T1,<Range Checked Chunk - TTFREE is bad, stop>)
	PUSH	P,P1		;GET A REGISTER TO WORK WITH
	HRRZ	P1,(T1)		;Current points to new first free chunk
	SKIPE	P1		;Zero if T1 points to very last chunk on system
	 CAML	P1,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	P1,RCC.HI	; to the TTY chunks
	 STOPCD (,XCT,RCCSTP)	;Die - TTFREE is bad
	MOVEM	P1,TTFREE##	;UPDATE FREE POINTER
	SKIPE	P1
	 HRRZS	(P1)		;MAKE SURE NO BACK LINE IF A CHUNK LEFT
	SOS	TTFREN		;COUNT CHUNK TAKEN
	HRLZI	P1,-4(T2)	;GET A BACK LINK
	MOVEM	P1,(T1)		;TO PUT IN NEW CHUNK
	HRRM	T1,-4(T2)	;AND PUT IN FORWARD LINK
	POP	P,P1
TTPC2:	HRRI	T2,1(T1)	;NOW RESET BYTE POINTER
TTPC1:	DPB	T3,T2		;STORE AWAY CHARACTER
	POPJ	P,		;ALL DONE
SUBTTL	ROUTINE TO FREE UP A CHUNK OF THE CHARACTER LIST BY LINKING IT
;ONTO THE FRONT OF THE FREE-LIST. ASSUMES THAT TTGETC HAS JUST BEEN
;CALLED SO T1 CONTAINS THE ADDRESS OF THE CHUNK AFTER THE ONE
;TO RETURN TO THE FREE LIST.
;T1 has already been verified to be between RCC.LO and RCC.HI by TTGETC

FRECHK:	PUSH	P,T2
	HLRZ	T2,(T1)		;RETRIEVE THE LINK TO THE ONE TO PUT BACK
	HRRZS	(T1)		;NO BACK LINK IN THIS CHUNK NOW
	EXCH	T2,TTFREE##	;PUT OLD ON FREE LIST
	HRRZM	T2,@TTFREE##	;RELINK REST OF FREE LIST AFTER THIS ONE
	AOS	TTFREN
	POP	P,T2
	POPJ	P,

;ROUTINE TO GET A FREE CHUNK FROM THE FREELIST. SETS UP
;A BYTE POINTER IN T2. CLOBBERS T1

GETCHK:	MOVE	T2,TTFREE##	;This should have been checked for 0 earlier
	CAML	T2,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T2,RCC.HI	; to the TTY chunks
	 STOPCD (,XCT,RCCSTP)	;Die - TTFREE is bad (or all chunks in use)
	HRRZ	T1,(T2)		;THE NEXT ELEMENT
	MOVEM	T1,TTFREE##	;RESET FREE LIST
;P035/D08 when getting first chunk on list, make sure second chunk does
; not have a back pointer to the first chunk.  /JMS 12-Jul-88
	SKIPE	T1		;As long as free list is not empty,
	 HRRZS	(T1)		; make sure it doesn't point to this one
	SETZM	(T2)		;NO LINKS IN THIS NEW ONE
	HRLI	T2,(POINT 9,0,35) ;POINT SO THAT IBP POINT TO 1ST CHR
	SOS	TTFREN		;ONE LESS
	POPJ	P,
SUBTTL	TSETBI - CLEAR INPUT BUFFER

TSETBI::	;P035/D08 - commented out code to special case zapped lines
;*;	MOVSI	T1,LLLZAP
;*;	TDNE	T1,LDBLOG(U)	;DO NOT ZAP IF TRYING TO GET RID OF HIM
;*;	 POPJ	P,
	SKIPE	T2,LDBTIP(U)	;CLEAR THIS LIST
	 PUSHJ	P,FREUP		;BUT ONLY IF ONE IS THERE
	SKIPE	T2,LDBRBI(U)	;AND THIS ONE TOO
	 PUSHJ	P,FREUP
	SETZM	LDBTIP(U)
	SETZM	LDBTIT(U)
	SETZM	LDBTIC(U)
	SETZM	LDBBKC(U)
	SETZM	LDBBK2(U)
	SETZM	LDBBKI(U)
	SETZM	LDBBKP(U)
	SETZM	LDBECT(U)
	SETZM	LDBECC(U)
	SETZM	LDBRBC(U)
	SETZM	LDBRBO(U)
	SETZM	LDBRBI(U)
	MOVSI	T2,LDLECS
	ANDCAM	T2,LDBDCH(U)	;MUST CLEAR COMMAND SYNC BIT
	HLL	U,LDBDCH(U)	;LET PEOPLE KNOW ABOUT IT
	MOVSI	T2,L2LDEL!L2LCCS
	ANDCAM	T2,LDBBYT(U)
	PJRST	BPXOFF		;GET OUT OF BACKPRESSURE OR XOFF

;TSETBO - CLEAR OUTPUT BUFFER
;Uses T1 and T2 only

TSETBO:	SKIPE	T2,LDBTOP(U)
	 PUSHJ	P,FREUP
TSTBO1:	SETZM	LDBTOP(U)	;OUTPUT PUTTER
	SETZM	LDBTOC(U)	;OUTPUT COUNT
	SETZM	LDBTOT(U)	;OUTPUT TAKER
	SETZM	LDBFLP(U)	;AND FILLERS CURRENTLY GOING
	HRRZ	T1,U
	CAMN	T1,OPRLDB	;IS THIS OPR
	 PUSHJ	P,OPRFRE	;YES, MAY NEED TO RESTART JOBS
	MOVEI	T2,1
	MOVSI	T1,L2LOWT
	TDNN	T1,LDBBYT(U)	;IF WE'RE WAITING FOR AN ORANGE BALL,
	 JRST	TSTBO2
	ANDCAM	T1,LDBBYT(U)	;  STOP WAITING
	DPB	T2,LOPSYL	;  SEND YELLOW BALL
TSTBO2:	DPB	T2,LOPCGB	;SEND GOBBLER
	MOVSI	T1,LDLNOP	;SEND EVEN IF SAYS SHOULD NOT
	ANDCAM	T1,LDBDCH(U)
	DPB	T2,LDBOPB(U)
	POPJ	P,
SUBTTL BUFFERED I/O UUO-LEVEL ROUTINES

;DISPATCH TABLE FOR MUUO'S AND INITIALIZATION

SCNDSP:	PHASE 0
DDXZ:	DSPSIZ
DDINT:	POPJ P,
DBYT:	1000,,1000
DVSIZ:	MOVEI T1,SCNDDS
DINI:	JRST TTYINI
DHNG:	JRST CPOPJ1
DRL:	POPJ P,
DCL:	JRST OUT
DOU:	JRST TTYOUT
DIN:	JRST TTYIN
DZAP:	JRST AUXZAP
	DSPSIZ==.-1
	DEPHASE
SUBTTL	INPUT UUO PROCESSOR - CALLED FROM UUOCON ON INPUT M, F SET UP

TTYIN:	PUSHJ	P,CKATTI	;MAKE SURE ATTACHED. SET S.
	  JRST	ABTUUO		;WAITING FOR AN INTERRUPT. ABORT
	JUMPE	U,[MOVSI S,IOEND
		JRST TTYINX]	;ZAPPED AUX CIRCUIT GIVE EOF
	NOCHARGE
	PUSHJ	P,FIXIMI	;SET IMAGE STATE FROM DATA MODE
	PUSHJ	P,TWAITL	;BECOME ATTACHED, WAIT FOR U
				; OR FULL BUFFER CONDITION
	TLNN	U,LDLIMI	;IMAGE HAS ALREADY CHARGED
	PUSHJ	P,SETBRK	;CHARGE FOR A BREAK CHR
TTYIN5:	HRRZ	T1,DEVIAD(F)		;PREPARE AND ADDR CHECK THE
	PUSHJ	P,BUFCLR		; USER'S BUFFER
	  JRST	ADRERR			;OUT OF BOUNDS. STOP JOB.
	HRRZ	P1,DEVIAD(F)		;PREPARE BYTE POINTER TO STORE
					; THE CHARACTERS IN HIS BUFFER
	XCTFU <LDB P2,[POINT 17,(P1),17]>	;BUFFER SIZE IN WORDS
	SUBI	P2,1			;MINUS LINK
	HRRZ	U,DDBLDB(F)		;RESTORE U, CLOBBERED IN UUOCON
	HLL	U,LDBDCH(U)	;ALSO GET BITS
	HRRZ	T1,DEVBUF(F)	;BUFFER POINTER FOR SIZE
	PUSHJ	P,TTYSZS		;SET SIZES
					;FALL INTO MAIN PART OF ROUTINE

TTYIN1:	PUSHJ	P,TYI			;GET A CHARACTER
	  JRST	TTYIN3			; END OF BUFFER.
	ANDI	T3,377
	XCTFU <IDPB T3,P1>			;AND STORE IN USER AREA
	CAIE	T2,%CHBRK		;A BREAK?
	SOJG	P2,TTYIN1			;NO. LOOP FOR MORE, IF ROOM.
TTYIN3:	MOVE	P2,DEVIAD(F)		;COMPUTE WORD COUNT FOR UUOCON
	SUBI	P1,1(P2)			; TO PUT IN BUFFER HEADER.
	XCTFU <HRRM P1,1(P2)>			;STORE WITH THE DATA IN RING
	PUSHJ	P,ADVBFF			;ON TO NEXT BUFFER
	  SKIPA				;NO MORE THERE.
	JRST	TTYIN6			;MORE TO GO. USE IF IMAGE.
TTYIN8:	MOVSI	S,IOFST			;SET VIRGIN BUFFER BIT
TTYINX:	IORB	S,DEVIOS(F)		;IN DEV S WORD IN F
	PJRST	NOCTRO			;CLEAR CONTROL O. END OF Muuo

TTYIN6:	TRNE	S,I			;IMAGE MODE?
	SKIPG	LDBTIC(U)		;AND MORE CHARACTERS TO READ?
	 JRST	TTYIN8			;NO. QUIT.
	JRST	TTYIN5			;YES. GO PASS SOME MORE

SETBRK:	TLNE	U,LDLIMI
	 POPJ	P,			;IMAGE IS ALREADY CHARGED FOR
	LDB	J,PJOBN
	PUSHJ	P,GTCGSZ	;GET THE JOB'S CHARGING SIZE.
	ADDM	T1,JBTBCS(J)	;ONE BREAK CHR
	ADDM	T1,JBTBCS
	POPJ	P,

IMGCNT:	LDB	T1,LDPIMB	;GET IMAGE BREAK CHR
	CAMN	T1,T3	;IS IT THIS ONE?
	 JRST	IMGCH1	;YES, GO CHARGE
	LDB	T1,LDPCHG
	ADDI	T1,1
	CAIL	T1,TIWKC	;ENOUGH GONE BY TO CHARGE?
	 JRST	IMGCHG	;YES
	DPB	T1,LDPCHG	;NO, JUST RECORD
	POPJ	P,

IMGCH1:	MOVEI	T4,TIWKC	;SO CALLER WILL THINK MANY CHRS
IMGCHG:	MOVEI	T1,0
	DPB	T1,LDPCHG	;SET CHARGE COUNTER TO 0
	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ	;NO LINE
	JRST	SETBRK	;GO CHARGE FOR 1 BCS

TTYSZS:	XCTBU <LDB T2,[POINT 6,1(T1),11]>	;GET POINTER SIZE
	DPB	T2,[POINT 6,P1,11]	;SET IN P1 POINTER
	MOVEI	T1,^D36
	IDIV	T1,T2		;NUMBER OF CHRS/WORD
	IMUL	P2,T1		;NUMBER OF CHRS IN BUFFER
	AOJA	P1,CPOPJ	;ADD 1 TO POINT TO FIRST DATA WORD
SUBTTL	OUTPUT UUO
;CALLED ON OUTPUT OR OUTPUT CLOSE, FROM UUOCON, WITH F SET UP.

TTYOUT:	PUSHJ	P,CKATTO	;FIRST, MAKE SURE THERE'S A LINE
	  JRST	ABTUUO		;WAITING FOR AN INTERRUPT
	JUMPE	U,TTYOUS	;ZAPPED AUX CIRCUIT
	PUSHJ	P,CHKROM	;MAKE SURE ROOM FOR THIS CHR
	  JRST	TTYOUT		;NO ROOM.
	NOCHARGE
	PUSHJ	P,CLRIMI	;CLEAR IMAGE INPUT STATE
	MOVSI	S,IOBEG		;IS THIS THE FIRST BUFFER AFTER INIT?
	MOVSI	T1,LDLOSU	;IF SO, WILL KILL ^O ACTION
	TDNN	S,DEVIOS(F)	;CHECK F
	 JRST	TTOUT1		;NO.
	ANDCAM	S,DEVIOS(F)	;YES. CLEAR BEG BIT,
	ANDCAM	T1,LDBDCH(U)	; AND CONTROL O BIT
TTOUT1:	TDNE	T1,LDBDCH(U)	;IS CONTROL O ON NOW?
	 JRST	TTOUT5		;YES. SKIP THIS WHOLE BUFFER.
	MOVSI	S,IO+IOFST	;MARK OUTPUT, AND FIRST OF BUFFER
	IORB	S,DEVIOS(F)	;IN DEVICE DATA BLOCK
	HRRZ	P1,DEVOAD(F)	;CHECK ADDRESSES OF OUTPUT BLOCK
	XCTFU <HRRZ P2,1(P1)>	;GET WORD COUNT
	HLRZ	T1,DEVBUF(F)	;GET POINTER TO BUFFER HEADER
	PUSHJ	P,TTYSZS
TTOUT2:	TRNE	P2,777		;TIME TO LET SOMEONE ELSE RUN?
	 JRST	TTOUT3		;NO
	PUSHJ	P,WSCHED	;YES -- RESCHEDULE
	HRRZ	U,DDBLDB(F)	;STILL ATTACHED?
	JUMPN	U,TTOUT3	;YES -- GO AHEAD
	PUSHJ	P,CKATTF	;NO -- WAIT FOR REATTACH
TTOUT3:	XCTFU <ILDB T3,P1>	;GET A USER'S CHARACTER
	TRNE	S,I		;SEE IF IMAGE MODE
	 TROA	T3,400		;YES. SET BIT FOR SUPPRESSING FILLERS
	  TRZ	T3,400		;ELSE CLEAR IN CASE EXTENDED
	JUMPE	T3,TTOUT4	;DON'T OUTPUT NULLS
	PUSHJ	P,TYO		;OUTPUT THIS CHARACTER (WAIT IF NEEDED)
	  JRST	XPNOUT		;TYO WANTS AN INTERRUPT (SEE TYO)
TTOUT4:	SOJG	P2,TTOUT2		;COUNT USER'S ITEMS.
TTOUT5:	PUSHJ	P,ADVBFE		;ADVANCE HIS BUFFERS
	  JFCL			;JUST SINGLE BUFFER FOR NOW
	MOVEI	S,IOACT		;CLEAR ACTIVE BIT.
	ANDCAB	S,DEVIOS(F)	;IN DEVICE DATA BLOCK FOR THE JOB
	MOVEI	T1,1
	DPB	T1,LOPOUT
	DPB	T1,LDBOPB(U)
	POPJ	P,
SUBTTL	TYO GAVE ERROR RETURN - NO MORE ROOM IN TTY CHUNCKS
XPNOUT:	PUSHJ	P,CKATTF		;HE MUST BE ATTCHED
	MOVSI	T1,L2LOEX
	IORM	T1,LDBBYT(U)	;SET FOR EXPANDED OUTPUT
	MOVE	T1,LDBTOC(U)
	CAML	T1,TOEMAX		;ALREADY TOO MANY FOR EXPANDED?
	AOS	(P)			;YES SKIP RETURN (TO TYO)
				;WILL GET US INTO OUTPUT WAIT
	POPJ	P,			;NON-SKIP RETURN (TO TYO) GO NOW

TTYOUS:	PUSHJ	P,ADVBFE	;SKIP THIS BUFFER
	  JFCL
	MOVEI	S,IOACT
	ANDCAB	S,DEVIOS(F)	;JUST TO MAKE SURE
	POPJ	P,
SUBTTL DDT MODE CALLI'S

;INPUT TO DDT	- CALL AC,[SIXBIT /DDTIN/]  WHERE AC/ ADDR
;ADDR GETS UP TO 21 WORDS OF ASCIZ, BREAKING ON ANY CHARACTER

DDTIN::	PUSHJ	P,TTYFNU		;SET U AND F FOR THIS TTY
	PUSHJ	P,CKATTI		;CHECK FOR ATTACHED
	  JRST	ABTUUO			;INTERRUPT, GET OUT OF UUO
	NOCHARGE
	XCTFU <HRRZ P2,(M)>
	HRLI	P2,440700		;SEVEN BIT BYTES, RELOCATED.
	MOVEI	P1,<21*5>-1		;NUMBER OF BYTES ALLOWED
	PUSHJ	P,TWAITC		;GET AT LEAST ONE CHARACTER
	PUSHJ	P,SETBRK		;ONE BREAK CHR
DDTINL:	SKIPG	LDBTIC(U)		;ANY MORE TO COME?
	 JRST	DDTINX			;NO.
	PUSHJ	P,TYI			;YES. GO GET ONE
	  JRST	DDTINX			;WASNT ANY. I'M CONFUSED.
	TRNE	T3,177			;NULL?
	XCTFU <IDPB T3,P2>		;NO. STORE IN USER AREA
	SOJG	P1,DDTINL		;IF MORE SPACE, GET ANOTHER CHARACTER
DDTINX:	MOVEI	T3,0			;FLAG END OF STRING
	XCTFU <IDPB T3,P2>		; IN USER AREA
	PJRST	NOCTRO			;AND RETURN TO USER, CLEARING ^O FLAG

;DDTOUT - CALL AC,[SIXBIT /DDTOUT/], AC/ ADDR, ADDR/ ASCIZ /XXX/

DDTOUT::UMOVE	M,(M)	;GET ADDRESS
	MOVEI	W,3
	JRST	TTYUUO	;HANDLE LIKE OUTSTR
SUBTTL HANG UUO

COMMENT @

HANG UUO - HANG A PORT, A JOB, OR ALL JOBS

	T1/	BITS,,PORT OR JOB #

	<BITS>  = 1B13 SAME AS 1B16 EXCEPT DON'T DETACH CMD PORT (LET
		       LOGOUT DO IT)
		  1B14 TO HANG A PORT OSTENSIBLY NOT TIED TO
		       A CIRCUIT
		  1B15 TO HANG ALL JOBS THEN GO TO BOOTS LOADED
		  1B16 TO FORCE A LOGOUT EVEN FOR JOBS WITH
		       DETACH OR TIMEOUT SET
		  1B17 IF SPECIFYING A JOB RATHER THAN A PORT
@

HNGUUO::TLNN	T1,(1B15)	;IF HANGING THE SYSTEM
	TLNN	T1,(1B17)	;OR SPECIFYING A PORT,
	 JRST	HNGUUL		;  NEED LICENSE

    ;HANGING A SPECIFIC FRAME - CHECK ACCESS RIGHTS

	HRR	P1,J		;SAVE CALLER JOB#
	HLL	P1,T1		;SAVE <BITS>
	HRRZ	P4,T1		;P4/ FRAME DESC
	HRRZI	P3,.ARHNG	;P3/ HANG-FRAME ACCESS
	PUSHJ	P,FDRUPX##	;J/ TARGET JOB#
	  POPJ	P,		;(NO JOB OR INSUFFICIENT ACCESS)
	HLL	T1,P1		;T1/ <BITS>,,
	HRR	T1,J		;T1/ <BITS>,,TARGET JOB#
	HRRZ	J,P1		;J/ CALLER JOB#
	JRST	HNGMON

    ;HANGING A PORT OR HANGING SYSTEM - NEED WC LICENSE

HNGUUL:	MOVSI	T2,LICWCR
	TDNN	T2,JBTLIC(J)
	 POPJ	P,

    ;HERE WHEN ACCESS IS OK, TO DO THE ACTUAL STUFF

HNGMON::HRRZ	T2,T1		;GET JOB OR PORT NUMBER
	TLNE	T1,(1B15)
	 JRST	HNGALL		;HANG ALL JOBS
	TLNE	T1,(1B17)
	 JRST	HNGJOB		;HANG A JOB
	CAIL	T2,RPORTN##
	 POPJ	P,		;BAD PORT
	HRR	U,LINTAB(T2)

	SKIPN	LDBLOG(U)	;THERE?
	 TLCE	T1,(1B14)	;SKIP IF DESIRE TO HANG ACTIVE PORTS
	TLNE	T1,(1B14)	;SKIP IF WANT TO HANG INACTIVE PORTS
	 POPJ	P,		;ERROR RETURN
	AOS	(P)		;SET TO SKIP RETURN
    ;HERE FROM ABOVE AND FROM ZAPCIR UUO
    ;U/ ---,,LDB ADDR
    ;T1/1B16 if ignoring continue-on-disconnect

HNGPRT:	PUSH	P,T1		;Save the "kill flag"
	MOVSI	T2,LMLBIO
	TDNE	T2,LDBMOD(U)
	 PUSHJ	P,BIOREL	;RESET BIO ON THIS PORT
	POP	P,T1		;Restore "kill flag"

;HERE WITH U/ LDB ADDR TO HANG THAT PORT

	HLL	U,LDBDCH(U)
	MOVSI	T2,LLLZAP
	IORM	T2,LDBLOG(U)	;MARK PORT INTERNALLY "ZAPPED"
	TLNE	U,LDLAUX	;IS IT AN AUX CIRCUIT?
	 JRST	HNGAUX		;YES, SO IT'S NOT A COMMAND PORT
	HRRZ	F,LDBDDB(U)	;F/ DDB ADDR
	JUMPE	F,TTYZAP	;Detached, just zap the port
	MOVSI	T2,TTYATC
	TDNN	T2,DEVMOD(F)	;IS IT A COMMAND PORT?
	 JRST	HNGAUX		;NO
	LDB	J,PJOBN		;Get number of controlling job/frame
	HLL	J,T1		;Set up J for general hang code
	PFALL	HNGTTY
SUBTTL	 Here from above or by PUSHJ.  At entry, F=DDB address, U=LDB
; address (if any), J=job/frame # in RH, LH has bit 16 set if
; continue-on-disconnect is to be ignored.

HNGTTY:	TLNE	J,(1B13)	;WANT TO DETACH?
	 JRST	HNGTT1		;NO, LET LOGOUT HANDLE IT
	HLLZS	DDBLDB(F)	;Clear DDB-to-LDB pointer
	HRRZS	DEVNAM(F)	;Clear "TTY" from device name
	JUMPE	U,HNGTT1	;Skip port code if no port
	HLLZS	LDBDDB(U)	;Clear LDB-to-DDB pointer
	PUSHJ	P,TTYZAP	;ZAP the port
	LDB	T1,LDPCOM	;Command mode from LDB
	DPB	T1,DDPCOM	;Copy into DDB

; Here job/frame is detached and TTY is gone

HNGTT1:	TLZE	J,(1B13!1B16)	;"Really kill"?
	 JRST	HNGTT2		;Yes, kill him good
	LDB	T1,PVYHNG##	;HANG/ZAP action field
	CAIE	T1,.PVHCN	;Continue-on-disconnect?
	 JRST	HNGTT3		;No, go kill it dead

; Here for continue-on-disconnect

	LDB	T1,DDPTZP
	PUSHJ	P,TAKTRP	;Cause "TTY ZAP" interrupt (if enabled)
	MOVE	S,DEVIOS(F)
	TLNE	S,TIOUSE	;If the DDB is in use,
	 PUSHJ	P,TIWAKE	; wake the job
	POPJ	P,

; Here to kill job dead

HNGTT2:	PUSHJ	P,TTKJOB##	;"Really kill" (no questions)

; Here to stop on disconnect or logout on disconnect

HNGTT3:	MOVSI	T1,DCLCOM
	IORM	T1,DDBDCH(F)	;In command mode at detach time
	PUSHJ	P,COMKJB##	;The MAGIC INVOCATION which kills jobs
	POPJ	P,		;Less magical, returns to caller
SUBTTL	HERE TO HANG A JOB
;T1/ BITS,,JOB#  T2/ 0,,JOB#

HNGJOB:	CAIL	T2,JOBN
	 POPJ	P,		;BAD JOB NUMBER
	HRRZ	F,TTYTAB(T2)
	JUMPE	F,CPOPJ		;NO JOB THERE
	HRRZ	U,DDBLDB(F)
	MOVE	J,T1		;Copy BITS,,JOB#
	PUSHJ	P,HNGTTY	;Force hang for this job/frame
	JRST	CPOPJ1

;HERE TO HANG EVERYONE AND BRING DOWN THE SYSTEM

HNGALL::SETZM	CRSHWD##	; THIS KEEPS US FROM NESTING
	SETOM	DWNFLG
	MOVEI	T1,600000
	IORM	T1,STATES	;SET SUPER SHUT
	PUSHJ	P,SETSHT	;LET SUPERVISOR KNOW
	MOVE	T1,HIGHJB
	PUSH	P,T1
HNGAL1:	HRLI	T1,(1B16!1B17)	;HANG JOB AND FORCE LOGOUT
	HRRZ	T2,T1		;Copy job #
	PUSHJ	P,HNGJOB
	  JFCL
	SOSLE	T1,(P)
	JRST	HNGAL1
	JRST	TPOPJ1
SUBTTL RESET UUO

TTYRES::HRRZ	F,TTYTAB(J)	;CALLED AT RESET TIME
	JUMPE	F,CPOPJ		;NO DDB
	MOVE	S,[XWD TWTSPC!IOSBKA,BK2IOS!DLRSUP!NOECHO!FCS!17]
	ANDCAB	S,DEVIOS(F)	;RESET TTY TO NORMAL STATE
	HRRZ	U,DDBLDB(F)
	JUMPE	U,TTYRS1	;NO LINE
	MOVE	T1,LDBMOD(U)	;CHECK FOR BLOCK I/O MODE SET
	TLNE	T1,LMLBIO	;FOR THE PORT AND RELEASE
	 PUSHJ	P,BIOREL	;BUFFERS AND RESET, IF SO.
	MOVSI	T1,L2LNTB
	ANDCAM	T1,LDBBYT(U)	;RESET THE NO TAB FUNCTION
	HRRZI	T1,L2LTBK
	PUSHJ	P,SETTBK	;NOW MAKE SURE TABS ARE BREAK2
	HRRZI	T1,L2LBBP
	PUSHJ	P,SETTBK	;MAKE SURE THAT BACKSPACES ARE BREAK
	PUSHJ	P,UUOLDB	;MAKE LINE AGREE WITH S
TTYRS1:	PUSHJ	P,NXTTTY	;GET NEXT DDB
	  POPJ	P,		;NONE
	MOVSI	T2,DVNZP
	TDNE	T2,DEVMOD(F)	;SHOULD WE ZAP ON RESET?
	 JRST	TTYRS1		;NO
	MOVEI	T2,ASSCON
	PUSHJ	P,RELEA6	;YES
	JRST	TTYRS1
SUBTTL .STTLK SETUUO FUNCTION

COMMENT @

CALLED BY SETUUO TO DO THE .STTLK FUNCTION (TALK COMMAND CLONE):

	MOVE	J,[TALKER JOB #]
	MOVE	T1,[TALKEE JOB #] (0 for OPR+CTY, 400000 for CTY only)
	MOVE	T2,[ILDB POINTER TO MESSAGE IN USER SPACE]
	MOVE	T4,[BYTE COUNT, 0 IF MESSAGE IS ASCIZ]
	PUSHJ	P, STTLK
	  ERROR RETURN	;T1/ ERROR CODE (SEE DEFINITIONS BELOW)
	NORMAL RETURN

ADVANCES T2 AS IT GOES, SO T2 IS CORRECTLY UPDATED IF THE MESSAGE
CAN ONLY BE PARTIALLY OUTPUT.  T4 updated if it started nonzero.

DESTROYS T1 T3.

@

TKROM%==:0	;NO ROOM FOR MORE OUTPUT CHARACTERS
TKEXS%==:1	;JOB DOESN'T EXIST
TKATT%==:2	;JOB NOT ATTACHED
TKBSY%==:3	;JOB BUSY (NO OPER LICENSE & NOT AT CMND LEVEL)

PRINTF(<[STTLK to job -1 does not SEND ALL]>)

STTLK::	TRNE	T1,377777	;Zero or 400000?
	 JRST	STTLK0		;No, T1 has job number
	CAIN	T1,400000	;Is 1B18 and nothing else set?
	 TRCA	T1,400001	;Yes, change T1 to 1 and output to CTY only
	  MOVEI	T1,2		;No, change T1 to 2 for both OPR and CTY
	PUSHJ	P,OPROUT	;Set up to go to right LDB
	MOVEI	T3,CTYLDB	;Fake it
	JRST	STTLK1

STTLK0:	MOVSI	T3,JNA
;*;	JUMPL	T1,#SEND#ALL#	;***    NOT IMPLEMENTED   ****
	CAIGE	T1,JOBN		;IF BAD JOB #
	TDNN	T3,JBTSTS(T1)	;OR JOB NOT ASSIGNED,
	 JRST	[MOVEI	T1,TKEXS%
		 POPJ	P,]	;Error return - non existant job
	HRRZ	T3,TTYTAB(T1)	;T3/ TALKEE DDB
	SKIPN	T3
	 STOPCD
	HRRZ	T3,DDBLDB(T3)	;T3/ TALKEE LDB
	JUMPE	T3,[		;IF JOB NOT ATTACHED,
		MOVEI	T1,TKATT%
		POPJ	P,	;  ERROR-RETURN
	]

	CAIN	T3,OPRLDB	;No license required to send to OPR or CTY
	 JRST	STTLK1
	HLL	T4,JBTLIC(J)	;Get caller's license
	TLNE	T4,LICOPR	;OPER can talk to anyone
	 JRST	STTLK1
	HLL	T4,LDBDCH(T3)	;Get talkee's status
	TLNE	T4,LDLCOM	;Receive messages if port is at command level
	 JRST	STTLK1
	MOVEI	T1,TKBSY%	;Port is busy
	POPJ	P,		;Error return
    ;HERE WITH T2/ ILDB POINTER, T3/ TALKEE LDB TO SEND A MESSAGE

STTLK1:	TLZ	T4,-1		;Keep only byte count
	PUSH	P,U		;SAVE U
	HRRZ	U,T3
	TLZ	T2,37		;CLEAR INDEX AND INDIRECT FIELDS
	PUSH	P,T2		;AND SAVE BYTE POINTER

STTLK2:	PUSHJ	P,IFROOM	;Check for room in destination output buffer
	 JRST	[
		MOVEI	T1,TKROM%
		POP	P,T2
		POP	P,U
		POPJ	P,	;  RESTORE T2 AND U AND ERROR-RETURN
	]
	XCTFU	<ILDB T3,(P)>	;GET NEXT BYTE OF MESSAGE
	SKIPN	T4		;If count started at 0, then
	 JUMPE	T3,STTLK3	; end at null in ASCIZ
	PUSHJ	P,COMTYO	;PRINT THE CHARACTER
	SKIPE	T4		;If byte count supplied,
	 SOJE	T4,STTLK3	; count it down
	JRST	STTLK2

STTLK3:	POP	P,T2
	POP	P,U
	JRST	CPOPJ1		;RESTORE T2 AND U AND SUCCESS-RETURN
SUBTTL TTCALL UUO
;TTCALL AC,E - VALUE OF AC DETERMINES ACTION OF UUO (051)

;W has a number from 0 to 17 if called from TTCALL uuo,
;negative numbers in W if fake call from UUOCON.

TTYUUO::PUSHJ	P,TTYFNU	;SET F AND U
	AOS	TTCCNT(W)	;Count each TTCALL by function
	MOVE	T3,TTUUOT(W)	;GET DIPACTH ADRS AND BITS
	TLNN	T3,TUUATO	;DOES UUO NEED ATTACH FOR OUTPUT?
	 JRST	TTYUU1
	PUSHJ	P,CKATTO	;YES, CHECK IF ATTACHED FOR OUTPUT
	  JRST	ABTUUO		;ABORT THE UUO FOR INTERRUPT
	JUMPN	U,TTYUU1
	PUSHJ	P,CKATO2	;FORCE ATTACH EVEN IF "SPECIAL"
	  JRST	ABTUUO
	JUMPE	U,.-2		;JUST TO MAKE SURE
TTYUU1:	TLNN	T3, TUUATI	;ATTACH FOR INPUT ?
	 JRST	TTYUU2
	PUSHJ	P,CKATTI	;YES, CHECK IF ATTACHED
	  JRST	ABTUUO		;ABORT FOR INTERRUPT
TTYUU2:	TLNE  T3,TUUATR!TUUAIR	;RETURN IF DETACHED ?
	JUMPE	U,CPOPJ		;YES
	TLNN	T3,TUUATO!TUUATI;IF DOING INPUT OR OUTPUT
	 PUSHJ	P,UUOLDB	;MUST GET THROUGH UUOLDB
	TLNN	T3,TUUROM	;NEED ROOM FOR OUTPUT?
	 JRST	TTYUU3
	PUSHJ	P,CHKROM	;SEE IF WILL GO INTO IOW FOR INTERRUPT
	 JRST	TTYUUO
TTYUU3:	TLNE	T3,TUUAIR	;MUST IT BE AT USER LEVEL TOO?
	TLNN	U,LDLCOM
	 SKIPA			;NEED NOT BE OR IS
	  POPJ	P,
	TLNE	T3,TUUEAT	;EAT RESCAN BUFFER?
	 PUSHJ	P,TYIEAT	;MUST EAT COMMAND BEFORE INPUT
IFE OPCRET,<	; KLUDGE TIL OPERATIONS CAN WRITE 10 CODE
	TLNE	T3,TUUFXI
	 PUSHJ	P,FIXIMI	;SET IMAGE STATE FROM DATA MODE
>;OPCRET=1 IF PROGRAMS THINK TTCALLS IGNORE IMAGE
	JRST	(T3)
SUBTTL	BITS FOR THE TTY UUOS

TUUATI==400000	;NEED TO BE ATTACHED - INPUT
TUUATO==200000	;NEED TO BE ATTACHED - OUTPUT
TUUATR==100000	;RETURN IF NOT ATTACHED
TUUAIR==040000	;RETURN IF NOT AT USER LEVEL
TUUROM==020000	;CHECK FOR ROOM FOR AT LEAST 1 CHR BEFORE OUTPUT
TUUEAT==010000	;EAT COMMAND
TUUFXI==004000	;SET IMAGE STATE FROM DATA MODE
TUUIMI==002000	;TURN ON IMAGE STATE (REGARDLESS OF DATA MODE)

;THERE ARE SOME NEGATIVE DISPATCHES FAKED BY UUOCON

TTUNEG:	XWD TUUAIR,LEVDEF		;-5 LEAVE DEFERED ECHO MODE
	XWD TUUAIR!TUUEAT!TUUFXI,RDNXT	;-4 READ NEXT CHR AND SKIP
	XWD 0,CPOPJ			;   NO LONGER IMPLEMENTED
	XWD 0,GETMC			;-2 GET LINE CHRS
	XWD TUUATI!TUUEAT!TUUFXI,TWAITC	;-1 WAIT FOR CHR
TTUUOT:	XWD TUUATI!TUUEAT!TUUFXI,INCHRW	;00 INPUT CHR AND WAIT
	XWD TUUATO!TUUROM,ONEOUT	;01 OUTPUT 1 CHR
	XWD TUUAIR!TUUEAT!TUUFXI,INCHRS	;02 INPUT CHR AND SKIP
	XWD TUUATO!TUUROM,OUTSTR	;03 OUTPUT STRING
	XWD TUUATI!TUUEAT!TUUFXI,INCHWL	;04 INPUT CHR AND WAIT LINE MODE
	XWD TUUAIR!TUUEAT!TUUFXI,INCHSL	;05 INPUT CHR AND SKIP LINE MODE
	XWD 0,GETLIN			;06 GET LINE CHRS.
	XWD TUUATO,SETLIN		;07 SET LINE CHRS.
	XWD TUUATR,TRESCU		;10 INHIBIT COMMAND LINE EATING
	XWD TUUATR,TSETBI		;11 CLEAR INPUT BUFFER
	XWD TUUATR,TSETBO		;12 CLEAR OUTPUT BUFFER
	XWD TUUAIR!TUUEAT!TUUFXI,SKPINC	;13 SKIP IF CHR TO BE INPUT
	XWD TUUAIR!TUUEAT!TUUFXI,SKPINL	;14 SKIP IF LINE TO BE INPUT
	XWD TUUATO!TUUROM,IONEOU	;15 IMAGE ONE-CHAR OUTPUT
	XWD TUUATO!TUUROM,OUTCHI	;16 OUTPUT CHR IMMEDIATE
	XWD TUUATO!TUUROM,OUTPTR	;17 OUTPUT FROM POINTER
SUBTTL	SUBROUTINES FOR TTCALL

;ONEOUT OUTPUTS ONE CHARACTER FROM C(E)

OUTCHI:	SKIPA T3,M	;GET THE CHARACTER FROM ADDRESS FILED
ONEOUT:	UMOVE T3,(M)	;GET CHR FROM ADDRESS
	NOCHARGE
	PUSHJ P,CLRIMI			;CLEAR IMAGE INPUT STATE
	TRNN S,10		;IF MODES 10,13,14
	TRNN S,2		;OR 0,1
	TRZA T3,600		;SAME AS ANDI 177 SINCE TTGETC GETS 9 BIT BYTE
	ANDI T3,377		;8 BITS IN MODE 2
	JUMPE T3,CPOPJ			;IF NOT NULL,
ONEOU2:	PUSHJ P,TYO
	 JRST XPNOUT		;SET BIGGER OUTPUT AND GO TO TYO
ONEOU3:	MOVEI T1,1
	DPB T1,LOPOUT
	DPB T1,LDBOPB(U)
	POPJ P,

;IONEOU OUTPUTS ONE CHARACTER FROM LOW 8 BITS OF C(E)
ACOTCI:	SKIPA T3,M	;GET CHR IMMEDIATE (AUXCAL)
IONEOU:	UMOVE T3,(M)	;GET CHR
	NOCHARGE
	PUSHJ P,CLRIMI			;NOT IN INPUT WAIT ANY MORE
	JUMPE F,ONEOUT		;IF NO F, SEND 7 BITS
	TRO T3,400			;FLAG AS IMAGE CHARACTER (NO FILLER)
	PJRST ONEOU2		;OUTPUT CHARACTER

;OUTSTR OUTPUTS A STRING OF ASCIZ CHARACTERS


OUTSTR:	PUSHJ P,CLRIMI			;CLEAR IMAGE INPUT STATE
	NOCHARGE
	HRLI M,(POINT 7,0)			;POINT TO USER AREA
OUTST1:	XCTFU <ILDB T3,M>	;GET CHR
	JUMPE T3,ONEOU3			;NULL MARKS END OF STRING, START PTY
	PUSHJ P,TYO			;TYPE OUT CHARACTER WITH PARITY
	 JRST XPNOUT		;TRY BIGGER OUTPUT BUFFER
	JRST OUTST1			;AND GO BACK FOR MORE.

;TRESCU IS FOR COMPIL TO READ COMMAND WHICH STARTED IT

TRESCU:	MOVSI T1,LDLECS		;CLEAR BIT IN LINE DATA BLOCK WHICH
	ANDCAM T1,LDBDCH(U)		; WOULD CAUSE COMMAND TO BE SKIPPED
	POPJ P,0			;AND RETURN TO USER
SUBTTL	SKPINC - SKIP IF INCHRW WOULDN'T WAIT (TOO LONG)

SKPINC:	SKIPG	LDBECC(U)	;If anything to be echoed
	SKIPLE	LDBTIC(U)	;Or characters have been input
	 AOS	(P)		;Skip return
TTYSET::		;OLD CLOCK1 FUNCTION
NOCTRO:	MOVSI	T1,L2LLDF
	ANDCAM	T1,LDBBYT(U)	;TURN OFF LEVDEF FLAG TOO
	MOVSI	T1,LDLOSU	;TURN OFF CONTROL O BIT
	ANDCAM	T1,LDBDCH(U)
	POPJ	P,

;SKPINL - SKIP IF INCHWL WOULDN'T WAIT

SKPINL:	MOVE	T1,LDBTIC(U)	;T1/ # READABLE CHARACTERS
	TLNE	U,LDLIMI	;IF IMAGE MODE
	 SKIPG	T1		;AND THERE'RE ANY,
	CAIL	T1,TIWKC	;OR OF THERE'S A LINEFULL,
	 JRST	SKPIN1		;  SKIP
	TLNE	U,LDLBK2	;IF BREAK-ON-PUNCTUATION
	 SKIPG	LDBBK2(U)	;AND THERE'RE PUNCTUATION CHARS,
	SKIPLE	LDBBKC(U)	;OR IF THERE'RE BREAK CHARACTERS,
SKPIN1:	 AOS (P)		;  SKIP
	PJRST	NOCTRO
SUBTTL	OUTPTR - OUTPUT FROM BYTE POINTER

OUTPTR:	PUSHJ P,CLRIMI
	NOCHARGE
	XCTFU <MOVE W,(M)>	;GET BYTE POINTER
	TLZ W,37		;GET RID OF INDEX AND INDIRECT
OUTPT1:	XCTFU <ILDB T3,W>	;GET NEXT CHARACTER
	JUMPE T3,ONEOU3		;DONE - SET OUTPUT BITS&RETURN
	PUSHJ P,TYO
	 SKIPA			;TYO WANTS TO TAKE INTERRUPT
	JRST OUTPT1		;TYO DONE, NEXT CHR
	LDB T3,[POINT 6,W,11]	;GET SIZE FIELD
	ROT T3,-6		;MOVE TO POSITION FILED
	ADDM T3,W		;BACK UP POINTER 1 POSITION
	XCTTU <MOVEM W,(M)>	;PUT IT BACK
	MOVEI T1,1
	DPB T1,LOPOUT
	DPB T1,LDBOPB(U)
	JRST ABTUUO		;AND DUMP THIS UUO

;OUTPTC - OUTPUT FROM BYTE POINTER + COUNT

OUTPTC:	PUSHJ	P, CLRIMI
	NOCHARGE
	XCTFU	<HRRZ P1, 0(M)>	;P1/ COUNT
	JUMPE	P1, CPOPJ	;IF 0, DONE
	XCTFU	<MOVE W, 1(M)>	;W/ BYTE POINTER
	TLZ	W, 37		;W/ BYTE POINTER - INDEX&INDIRECT BITS
OUTPC1:	XCTFU	<ILDB T3, W>	;T3/ NEXT CHARACTER
	PUSHJ	P, TYO		;OUTPUT IT
	  JRST	OUTPC2		;(TYO WANTS AN INTERRUPT)
	SOJG	P1, OUTPC1	;IF MORE CHARACTERS, CONTINUE
	PJRST	OUTPCF		;FINISH UP

OUTPC2:	LDB	T3, [POINT 6,W,11]
	ROT	T3, -6		;POSITION FIELD := SIZE FIELD
	ADDM	T3, W		;DECREMENT BYTE POINTER BY 1 BYTE
	PUSHJ	P, OUTPCF	;FINISH UP
	JRST	ABTUUO		;AND DUMP THIS UUO

	;OUTPCF ALSO USED BY OUTSNW...BELOW
OUTPCF:	XCTBU	<HRRM P1, 0(M)>	;STORE THE UPDATED COUNT
	XCTTU	<MOVEM W, 1(M)>	;AND BYTE POINTER
	MOVEI	T1, 1
	DPB	T1, LOPOUT
	DPB	T1, LDBOPB(U)
	POPJ	P,

;OUTSNW - OUTPUT STRING, NEVER WAIT

OUTSNW:	PUSHJ	P,CLRIMI
	NOCHARGE
	HLRZ	T1,LDBBIO(U)	;BLOCK OUTPUT IN PROGRESS?
	JUMPN	T1,CPOPJ	;IF SO, CAN'T DO ANYTHING
	XCTFU	<HRRZ P1,(M)>	;P1/ COUNT
	JUMPE	P1,CPOPJ1	;NOTHING TO DO
	XCTFU	<MOVE W,1(M)>	;W/ BYTE POINTER
	TLZ	W,37		;W/ BYTE POINTER - INDEX & IND BITS
OUTSN1:	PUSHJ	P,IFROOM	;IS THERE ROOM FOR A CHARACTER?
	 JRST	OUTSN2		;NO ROOM - SET FIO GO AWAY
	XCTFU	<ILDB T3,W>	;YES ROOM - GET CHARACTER
	PUSHJ	P,CMDTYO	;AND OUTPUT IT
	SOJG	P1,OUTSN1	;DO IT AGAIN, IF MORE
	AOS	(P)		;RAN OUT - SKIP RETURN
	JRST	OUTPCF		;GO AWAY
OUTSN2:	PUSHJ	P,SETFIO	;SO HE'LL GET ROOM AVAILABLE TRAP
	JRST	OUTPCF		;NO ROOM - GO AWAY

SUBTTL	GETLCH - READ LINE CHARACTERISTICS

GETLIN:	XCTFU <MOVE T1,(M)>
	PUSHJ P,CHKLN2	;SEE IF THIS USER CAN HAVE THIS INFO
	 JRST GETLNZ	;NO
	LDB T1,LDPLNO		;GET NUMBER
	HLL	T1,LDBDCH(U)	; GET BITS FROM LH WHICH ARE SAME
	TLZ	T1,-1-GTLMSK	; CLEAR ALL BITS IN LH WHICH ARN'T
	LDB T3,LDPHDX	;GET HALF DUPLEX BIT FROM CHRS READ
	SKIPE T3	;SEE IF ON
	TLO T1,GTLHDX
	MOVE	T3, LDBDCX(U)
	TRZE	T3, LXRESC	;READ AND CLEAR "ESCAPE SEEN"
	TLO	T1, GTLESC	;RETURN ITS OLD VALUE
	TRZE	T3, LXROBS	;READ AND CLEAR "ORANGE BALL SEEN"
	TLO	T1, GTLOBS	;RETURN ITS OLD VALUE
	MOVEM	T3, LDBDCX(U)
	MOVSI	T3, LMLPSP
	TDNE	T3, LDBMOD(U)	;CHECK FOR UNREAD PORT-STATUS MSG
	TLO	T1, GTLPSP	;AND SET IF THERE IS ONE
	LDB T3,LDPCRD	;GET RETURN DELAY BIT
	SKIPE T3
	TLO T1,GTLCRD
	HLL U,LDBDCH(U)	;THE OTHERS FROM NORMAL BITS
	MOVE T3,LDBBKC(U)	;GET BREAK COUNTER
	TLNE U,LDLBK2	;IF IN BREAK 2 MODE
	ADD T3,LDBBK2(U)	;ADD IN THESE
	TRNE T3,-1
	TLOA T1,GTLLRD		;SET LINE READY BIT
	TLZ T1,GTLLRD		;OR TURN IT OFF
	TLC T1,GTLLCT		;SENSE OF THIS BIT IS WRONG
	XCTTU <MOVEM T1,(M)>
	POPJ P,

GETLNZ:	XCTBU <SETZM (M)>
	POPJ P,

; THE FOLLOWING BITS ARE IN THE SAME PLACE IN LDBDCH AS IN GETLCH...
GTLMSK==LDLNOP!LDLDEF!LDLECS!LDLOSU!LDLNFC!LDLNEC!LDLAUX!LDLLCT!LDLTAB!LDLLCP!LDLPTP!LDLFRM

GTLECS==100000	;EAT COMMAND SYNCH (CMD AVAIL FOR RESCAN)
GTLPSP==40000	;PORT STATUS PENDING (UNREAD, see comment at ACPSM)
GTLOBS==20000	;ORANGE BALL SEEN
GTLHDX==10000	;HALF DUPLEX
GTLESC==4000	;ESCAPE SEEN
GTLCRD==2000	;CARRIAGE-RETURN(NOT LF) PADDING
GTLDEF==1000	;DEFERRED ECHO MODE
GTLNFC==200	;NO FREE CRLF (ON LONG LINES)
GTLLRD==100	;LINE (BREAK) IN BUFFER
GTLLCT==20	;NO CASE MAPPING
GTLTAB==10	;HARDWARE HT
GTLPTP==2	;PAPER TAPE MODE
GTLFRM==1	;HARDWARE FF/VT
SUBTTL	SETLCH - SET LINE CHARACTERISTICS

SLCTAB:	GTLHDX,,TCNHDX
	GTLCRD,,TCNCRD
	GTLNFC,,TCNNFC
	GTLLCT,,TCNLCT
	GTLTAB,,TCNTAB
	GTLPTP,,TCNPTP
	GTLFRM,,TCNFRM
SLCTBN==.-SLCTAB

SETLIN:	XCTFU	<HLRZ P1,(M)>	;P1/ 0,,USER BITS
	TRC	P1, GTLLCT	;INVERT SENSE OF CASE-MAP BIT
	MOVE	P2, [-SLCTBN,,SLCTAB]
SETLN1:	HLL	T3, (P2)	;T3/ THE BIT
	TLNN	T3, (P1)	;SET IT OR CLEAR IT?
	TDZA	T2, T2		;(CLEAR)
	MOVEI	T2, 1		;(SET)
	HRRZ	T1, (P2)	;T1/ THE TC#
	PUSHJ	P, SETTCN
	 STOPCD 		;WHAT ERROR?
	AOBJN	P2, SETLN1
	POPJ	P,
SUBTTL	CHARACTER INPUT TTCALLS

INCHRS:	NOCHARGE
	PUSHJ P,SKPINC			;CAN I GET A CHARACTER (CLEAR ^O)
ICS1:	  JRST NOCTRO			;NO. GIVE NON-SKIP RETURN
	PUSHJ P,TWAITS
	  POPJ	P,			;DETACHED
	PUSHJ P,TYI			;GET A CHARACTER
	  JRST ICS1			;NONE THERE. SKPINC LIED?
	AOS 0(P)			;GIVE SKIP RETURN
	JRST ICW1A			;AND RETURN THE CHARACTER
INCHSL:	NOCHARGE
	PUSHJ P,SKPINL			;IS THERE A LINE AVAILABLE?
	  POPJ P,0			;NO. NON-SKIP RETURN TO USER
	PUSHJ P,TWAITL
	PUSHJ P,TYI		;GET THE CRH.
	 JRST ICS1		;REALLY NONE THERE
	AOS (P)			;SET FOR SKIP RETURN
	JRST ICW1B		;GO (REMEMBER TO CHARGE

I1CHWL:	AOS (P)		;FROM AUXCAL
INCHWL:	NOCHARGE
INWL1:	TLNE U,LDLIMI	;CHECK IMAGE MODE
	TLNN S,IOEND
	SKIPA
	JRST ICH0		;SEND A 0 CHRACTER
	PUSHJ P,TWAITL			;WAIT FOR A LINE TO APPEAR
	PUSHJ P,TYI			;GO GET A CHARACTER
	  JRST INWL1			;IMPOSSIBLE. NO CHARACTERS.
ICW1B:	CAIN T2,%CHBRK		;A BREAK?
ICW1A:	PUSHJ P,SETBRK		;YES, CHARGE
ICW1:	TRNN S,10		;IF MODES 10,13,14
	TRNN S,2		;OR 0,1
	TRZA T3,600		;SAME AS ANDI 177 SINCE TTGETC GETS 9 BIT BYTE
	ANDI T3,377		;8 BITS IN MODE 2
	XCTTU <MOVEM T3,(M)>			;GIVE HIM THE CHARACTER
	JRST NOCTRO			;AND NON-SKIP RETURN

ICH0:	MOVEI T3,0
	JRST ICW1

I1CHRW:	AOS (P)		;FROM AUXCAL
INCHRW:	NOCHARGE
INRW1:	PUSHJ P,TWAITC			;WAIT FOR A CHARACTER TO APPEAR
	PUSHJ P,TYI			;GO GET THE CHARACTER
	  JRST INRW1			;IMPOSSIBLE. NONE THERE
	JRST ICW1A			;GIVE HIM T3 AND RETURN
;Get LDBLOG for GETTAB uuo
GETLOG::PUSHJ	P,CHKLIN	;GETTAB to return LDBLOG.  Check if OK
	  POPJ	P,		;Error, can not have info
	SKIPA	T1,LDBLOG(U)
RETZRO:	MOVEI	T1,0		;NO LINE THERE, RETURN 0
STOTC1:	UMOVEM	T1,(M)		;RETURN ARGUMENT TO USER'S AREA.
	JRST	CPOPJ1		;AND SKIP RETURN.

CHKLN2:	SKIPA	U,T1		;Line # in RH
CHKLIN:	HLRE	U,T1		;Line # in LH
	JUMPL	U,CKLN1		;-1 for own line
	CAILE	U,MXLIN##
	 POPJ	P,		;Illegal line number
	SKIPA	U,LINTAB(U)	;Get addr of LDB
CKLN1:	 PUSHJ	P,TTYFNU	;Find LDB for job
	JUMPE	U,CPOPJ		;NO LINE NUMBER THERE
	HRRZ	F,LDBDDB(U)	;GET THE DDB
	JUMPE	F,CPOPJ		;IF NONE, NO ONE CONNECTED
	LDB	J,PJOBN		;GET THE JOB NUMBER
	JRST	CHKSEG		;AND GO CHECK

LINJOB::PUSHJ	P,CHKLIN	;Return job which owns a specific line
	  POPJ	P,
	HRRZ	F,LDBDDB(U)
	JUMPE	F,RETZRO
	LDB	T1,PJOBN	;GET THE JOB NUMBER
	JRST	STOTC1

GETLPS::PUSHJ	P,CHKLIN	;Return horizontal position of line
	  POPJ	P,
	LDB	T1,LDPPOS
	JRST	STOTC1

GETMOD::PUSHJ	P,CHKLIN	;Return status (DEVIOS)
	  POPJ	P,
	HRRZ	F,LDBDDB(U)
	JUMPE	F,RETZRO
	MOVE	T1,DEVIOS(F)
	JRST STOTC1
RDNXT:	NOCHARGE
	SKIPG LDBECC(U)	;MAKE SURE A CHR IS THERE
	SKIPLE LDBTIC(U)
	AOSA (P)
	POPJ P,			;NO, RETURN
	MOVE T2,LDBTIT(U)
	PUSHJ P,TTGETC
	 JFCL
	TRNN S,10		;IF MODES 10,13,14
	TRNN S,2		;OR 0,1
	TRZA T3,600		;SAME AS ANDI 177 SINCE TTGETC GETS 9 BIT BYTE
	ANDI T3,377		;8 BITS IN MODE 2
	XCTTU <MOVEM T3,(M)>	;GIVE IT TO HIM
	POPJ P,

LEVDEF:	MOVSI T1,L2LLDF
	IORM T1,LDBBYT(U)
	PUSHJ P,BPLVD	;TURN OFF BACKPRESSURE IF APPROPRIATE
	MOVEI T1,1
	DPB T1,LOPECO
	DPB T1,LDBOPB(U)
	POPJ P,
SUBTTL	READ TERMINAL CHARACTERISTICS

GETMC:	UMOVE T1,(M)	;GET THE LINE HE WANTS THESE FOR
	PUSHJ P,CHKLN2
	 JRST GETLNZ	;CAN NOT HAVE THEM
	SETZM	T1	;MAKE UNFILLED FIELDS 0 (ARE THERE ANY?)
	LDB T3,LDPFC1	;FILLER CLASS 1
	DPB T3,GEPMC1
	LDB T3,LDPFC2	;FILLER CLASS 2
	DPB T3,GEPMC2
	LDB T3,LDPWID	;WIDTH
	DPB T3,GEPMC3
	LDB T3,GEPMC4	;NO XON, NO TAB, TAB AS BREAK BITS
	DPB T3,GEPMC5
	LDB T3,LDPIR
	DPB T3,GEPMC6
	LDB T3,LDPOR
	DPB T3,GEPMC7
	LDB T3,LDPPAR
	DPB T3,GEPMC8
	LDB T3,LDPPA
	DPB T3,GEPMC9
	LDB T3,LDPHDX
	DPB T3,GEPM10
	LDB T3,LDPPB
	DPB T3,GEPM11
	LDB T3,LDPPC
	DPB T3,GEPM12
	UMOVEM T1,(M)
	POPJ P,

GEPMC1:	POINT 2,T1,16	;FILLER CLASS 1
GEPMC2:	POINT 2,T1,14	;FILLER CLASS 2
GEPMC3:	POINT 8,T1,12	;WIDTH
GEPMC4:	POINT 3,LDBBYT(U),4	;GET NO XON, NO TAB, TAB AS BRK
GEPMC5:	POINT 3,T1,4	;LOCATION OF ABOVE IN GETTMC WORD
GEPMC6:	POINT 3,T1,19	;IR
GEPMC7:	POINT 3,T1,22	;OR
GEPMC8:	POINT 1,T1,23	;PAR
GEPMC9:	POINT 3,T1,26	;PA
GEPM10:	POINT 1,T1,27	;HDX
GEPM11:	POINT 3,T1,30	;PB
GEPM12:	POINT 5,T1,35	;0 BIT + PC
SUBTTL	FIXIMI CALLED ON INPUT UUOS OTHER THAN AUXCALS 0,1,2 TO SET
;IMAGE STATE FROM DATA MODE

FIXIMI:	MOVE	T1,LDBDCH(U)
	TLNN	T1,LDLAUX	;AUX CIRCUIT?
	TRNE	S,I		;OR DATA MODE = I, IB, B?
	 TLOA	T1,LDLIMI	;YES: SET IMAGE STATE
	TLZ	T1,LDLIMI	;NO: CLEAR IMAGE STATE
	CAMN	T1,LDBDCH(U)	;DID IT CHANGE?
	 POPJ	P,		;NO
	MOVEM	T1,LDBDCH(U)	;YES
	PJRST	SETLMD

;CLRIMI CALLED ON OUTPUT UUOS TO CLEAR IMAGE STATE IF DATA
;MODE IS NOT IMAGE AND TO TURN OFF BACKPRESSURE (IN GENERAL,
;TO NOTE THAT THE LINE IS NO LONGER SIMPLY IN INPUT WAIT)

CLRIMI:	HRRZ	F,LDBDDB(U)		;GET ATTACHED JOB, IF ANY
	JUMPE	F,CLRIM1		;IF NONE, SKIP PART OF THIS
	MOVE	S,DEVIOS(F)		;JOB'S IO STATUS FOR TTY
	TRNE	S,I			;IS IT STILL IN IMAGE MODE?
	 POPJ	P,0			;YES. FORGET IT.
CLRIM1:	MOVSI	T1,LDLIMI		;NO. CLEAR IMAGE BIT AND TIME
	TLNN	U,LDLAUX		;AUX ALWAYS IN IMAGE MODE
	TDNN	T1,LDBDCH(U)		;IS IT ON?
	 POPJ	P,			;NO
	ANDCAM	T1,LDBDCH(U)		; ..
	PUSHJ	P,BPTEST		;WANT TO TURN OFF BACKPRESSURE?
	  PUSHJ	P,BPOFF			;YES, NOW TURN OFF BACKPRESSURE
	PFALL	SETLMD

SETLMD:	LDB	T1,LDPMDF		;GET LINE MODE FLAGS
	MOVE	T1,MDFLMD(T1)		;DO TRANSLATION INTO MODE
	DPB	T1,LDPLMD		;AND SET INPUT AND ECHO MODES
	POPJ	P,0			; AND RETURN
	
SUBTTL	SETTBK - SET TABS AS BREAK
;SETTBK - CALLED WITH
;	T1/ L2LTBK,,L2LTBK	SET TAB-AS-BREAK
;	T1/	 0,,L2LTBK	SET TAB-AS-PUNCTUATION
;	T1/ L2LBBP,,L2LBBP	SET BS-AS-PUNCTUATION
;	T1/	 0,,L2LBBP	SET BS-AS-BREAK
;BREAKS T1-T4

SETTBK:	MOVE	T2, T1
	XOR	T1, LDBBYT(U)
	TLNN	T1, 0(T2)	;IF THE BIT DIDN'T CHANGE,
	POPJ	P,		;  JUST RETURN
	HRLZ	T1, T2
	XORM	T1, LDBBYT(U)	;INVERT THE LDB BIT
	MOVEI	T1, 11		;(ASSUME IT'S TAB-AS-BREAK)
	TRNN	T2, L2LBBP	;IF IT'S BS-AS-PUNCTUATION,
	JRST	SETTB1
	MOVEI	T1, 10		;  CHAR := 10
	TLC	T2, L2LBBP	;  INVERT SENSE (TO BS-AS-BREAK)
SETTB1:	TLNE	T2, -1		;WHICH WAY?
	PJRST	PNTOBK		;(PUNCTUATION = BREAK)
	PJRST	BKTOPN		;(BREAK = PUNCTUATION)
SUBTTL	BKTOPN - CALLED WITH U/ LDB ADDR, T1/ <CHAR>
;	   MAKE <CHAR> GO FROM A BREAK TO A PUNCTUATION CHARACTER
;	   BY ADJUSTING COUNTS
;	   DESTROYS T1 T2 T3 T4

BKTOPN:	PUSHJ	P, CHRCNT	;T1/ #UNECHOED,,#ECHOED
	ADDM	T1, LDBBK2(U)	;ADD TO PUNCTUATION COUNT
	MOVNS	T1
	ADDM	T1, LDBBKC(U)	;SUBTRACT FROM BREAK COUNT
	POPJ	P,

;PNTOBK - CALLED WITH U/ LDB ADDR, T1/ <CHAR>
;	   MAKE <CHAR> GO FROM A PUNCTUATION TO A BREAK CHARACTER
;	   BY ADJUSTING COUNTS, LINE DELETE POINTER
;	   DESTROYS T1 T2 T3 T4

PNTOBK:	PUSHJ	P, CHRCNT	;P2/ #UNECHOED,,#ECHOED
	ADDM	T1, LDBBKC(U)	;ADD TO BREAK COUNT
	MOVNS	T1
	ADDM	T1, LDBBK2(U)	;SUBTRACT FROM PUNCTUATION COUNT
	JUMPE	T1, PNTOB1	;IF THERE ARE ANY NEW BREAK CHARACTERS,
	MOVE	T2, LDBTIP(U)
	MOVEM	T2, LDBBKP(U)	;  SET LINE-DELETE POINTER TO NOW
	SETZM	LDBBKI(U)	;  (NO DELETABLE CHARACTERS)
PNTOB1:	POPJ	P,
SUBTTL	CHRCNT - CALLED WITH U/ LDB ADDR, T1/ CHAR
;	   RETURNS T1/ #UNECHOED,,#ECHOED <CHAR>S IN THE INPUT BUFFER
;	   DESTROYS T1 T2 T3 T4

CHRCNT:	PUSH	P, P1
	PUSH	P, P2
	MOVE	P1, T1		;P1/ CHAR
	SETZ	P2,		;P2/ COUNT
	MOVE	T2, LDBECT(U)	;T2/ ECHO-TAKER BYTE POINTER
	SKIPE	T4, LDBECC(U)	;T4/ #UNECHOED,UNREAD CHARACTERS
	PUSHJ	P, CNTCHR	;IF ANY, COUNT #<CHAR>S
	HRLZS	P2		;P2/ UNECHOED,,ECHOED
	MOVE	T2, LDBTIT(U)	;T2/ CHAR-TAKER BYTE POINTER
	SKIPE	T4, LDBTIC(U)	;T4/ #ECHOED,UNREAD CHARACTERS
	PUSHJ	P, CNTCHR	;IF ANY, COUNT #<CHAR>S
	MOVE	T1, P2		;T1/ COUNT
	POP	P, P2
	POP	P, P1
	POPJ	P,

    ;T2/ BUFFERLET BYTE POINTER, T4/ COUNT
    ;P1/ <CHAR> TO LOOK FOR, P2/ COUNT TO INCREMENT

CNTCHR:	PUSHJ	P, TTGETC	;T3/ NEXT CHAR
	  JFCL			;(EH?)
	ANDI	T3, 177		;T3/ ASCII PART OF THE CHAR
	CAMN	T3, P1		;IF IT'S THE <CHAR>,
	AOS	P2		;  COUNT IT
	SOJG	T4, CNTCHR
	POPJ	P,
SUBTTL	SETPTP - SETS PAPER-TAPE-MODE BIT (SIMILAR CODE IN SETLIN)
;	   T1/ 0 TO CLEAR PTP, LDLPTP,,0 TO SET PTP MODE
;	   (DESTROYS T1)

SETPTP:	XOR	T1, LDBDCH(U)
	TLNN	T1, LDLPTP	;IF IT'S NOT CHANGING,
	POPJ	P,		;  JUST RETURN
	XORB	T1, LDBDCH(U)	;SET DCH BIT
	TLNE	T1, LDLPTP	;IN PTP MODE?
	TDZA	T1, T1		;YES: ECHO CR AS CR
	MOVEI	T1, 1		;NO: ECHO CR AS CRLF
	DPB	T1, LDSECR
	MOVE	T1, [LTSECR]
	IORM	T1, LDBTMT(U)
	MOVEI	T1, 1
	DPB	T1, LOPSTC	;SET SEND-CHARACTERISTICS
	DPB	T1, LDBOPB(U)	;SET WANT-OUTPUT
	POPJ	P,
SUBTTL PSEUDO-TTYS

;CREPTY UUO - CREATE A PTY
;
;	CREPTY	AC,
;	  ERROR RETURN	;AC/ ERROR CODE
;	NORMAL RETURN	;AC/ PORT1#,,PORT2#

CPNPT%==1	;OUT OF PTYS (OR THERE NEVER WERE ANY)
CPNRM%==2	;NO ROOM FOR PTYS (OUT OF DDBS)

CREPTY::PUSHJ	P, GETPP	;GET A PORT# PAIR. T1/ EVEN SIDE #
	  JRST	[MOVEI	T1,CPNPT%
		 JRST	CPERR	]
	MOVEM	T1, P1
	PUSHJ	P, PTYLDB	;SET UP ITS LDB. U/ LDB ADDR
	HRLM	U, P2		;P2/ EVEN-SIDE LDB,,---
	PUSHJ	P, PTYDDB	;SET UP ITS DDB. F/ DDB ADDR
	  JRST	[MOVEI	T1, CPNRM%
		 JRST	CPERR	]
	HRRM	F, P2		;P2/ EVEN-SIDE LDB,,DDB
	MOVEI	T1, 1(P1)	;T1/ ODD-SIDE PORT#
	PUSHJ	P, PTYLDB	;SET UP ITS LDB. U/ LDB ADDR
	PUSHJ	P, PTYDDB	;SET UP ITS DDB. F/ DDB ADDR
	  JRST	[HRRZ	F, P2
		 PUSHJ	P, TTYKDB	;FREE EVEN DDB
		 HLRZ	U, P2
		 HLLZS	LDBDDB(U)	;DETACH EVEN LDB
		 SETZM	LDBLOG(U)	;FREE EVEN LDB (leave LDPHST)
		 MOVEI	T1,CPNRM%
		 JRST	CPERR	]
	HRLS	P1		;P1/ EVEN PORT#,,EVEN PORT#
	TRO	P1, 1		;P1/ EVEN PORT#,,ODD PORT#
	UMOVEM	P1, (M)		;GIVE USER THE PORT #S
	JRST	CPOPJ1		;SUCCESS!

CPERR:	UMOVEM	T1, (M)		;GIVE USER THE ERROR CODE
	POPJ	P,		;FAILURE!
SUBTTL	GETPP - GET AN EVEN/ODD PTY PORT # PAIR
;	  NONSKIP-RETURN IF NONE
;	  SKIP-RETURN WITH T1/ THE EVEN # ON SUCCESS
;DESTROYS T2 U

GETPP:	SKIPA	T1,[<<PORTN##-PPORTN##+1>&<-1-1>>]
GETPP1:	ADDI	T1,2		;GO ON TO THE NEXT PAIR
	CAILE	T1,PORTN##-2	;IF WE'RE PAST THE TOP PAIR,
	 POPJ	P,		;  FAIL
	HRRZ	T2,LINTAB(T1)	;T2/ EVEN-SIDE LDB ADDR
	SKIPE	LDBLOG(T2)	;IF IT'S LOGGED-IN,
	 JRST	GETPP1		;  TRY THE NEXT PAIR
	HRRZ	T2,LINTAB+1(T1)	;T2/ ODD-SIDE LDB ADDR
	SKIPE	LDBLOG(T2)	;IF IT'S LOGGED-IN,
	 JRST	GETPP1		;  TRY THE NEXT PAIR
	JRST	CPOPJ1		;SUCCESS!

;PTYBUD - GET PTY BUDDY
;	CALLED WITH U/ PTY LDB
;	RETURNS U/ PTY LDB OF ITS OTHER END

PTYBUD:	LDB	U,LDPLNO
	TRC	U,1
	HRRZ	U,LINTAB(U)	;U/ "BUDDY" LDB ADDR
	POPJ	P,
SUBTTL	PTYLDB - SET UP A PTY LDB
;	   CALLED WITH T1/ PTY PORT #
;	   RETURN WITH U/ THE LDB

PTYLDB:	HRRZ	U,LINTAB(T1)	;U/ LDB ADDR
	SKIPN	U
	 STOPCD
	LDB	T2,LDPLNO	;T2/ LDB'S IDEA OF ITS PORT #
	CAME	T1,T2
	 STOPCD

    ;NOW THAT WE'VE GOT THE LDB, INITIALIZE IT
    ;THIS CODE SHOULD REMAIN ALMOST IDENTICAL WITH
    ;THE CODE AT AUXINP FOR NEW AUX CIRCUITS

	MOVSI	T1,(1B0)	;"Logged-in" bit (term id of 0)
	LDB	T2,LDPLNO	;This line's number
	TRC	T2,1		;Circuit came from its buddy
	DPB	T2,[POINT 8,T1,35] ;Origination line number
	MOVEM	T1,LDBLOG(U)	;Node number gets set by LOGLDB routine
	MOVE	T1,SYSNUM##	;System number is
	DPB	T1,LDPHST	; origination host number for PTY
	SETZM	LDBOUT(U)
	SETZM	LDBBYT(U)
	SETZM	LDBMOD(U)
	MOVEI	T1,^D80		;"SET TTY WIDTH 80"
	DPB	T1,LDPWID
	SETZM	LDBTMT(U)
	ZZN==0
	REPEAT TMCSIZ, <SETZM LDBTMR+ZZN(U)
	ZZN==ZZN+1>
	MOVSI	T1,LDLDEF!LDLPTY
	MOVEM	T1,LDBDCH(U)	;DIFFERENT FROM AUX CIRCUITS!
	MOVSI	T1,LXL120
	MOVEM	T1,LDBDCX(U)	;BUFFER AS A FAST LINE
	SETZM	LDBTCB(U)	;NO CHANGED TERMINAL CHARACTERISTICS
	PUSHJ	P,SETLMD	;SET THE LINE MODE
	POPJ	P,
SUBTTL	PTYDDB - ALLOCATE, LINK IN, ATTACH, INITIALIZE A PTY DDB
;	   CALLED WITH U/ LDB ADDRESS, J/ ATTACHEE JOB #
;	   NONSKIP-RETURNS IF THERE ARE NO FREE DDBS
;	   SKIP-RETURNS WITH F/ DDB ADDR ON SUCCESS

PTYDDB:	HRRZ	T1, TTYTAB(J)	;T1/ CMND PORT DDB
	SKIPN	T1
	 STOPCD 		;(THERE MUST BE ONE)
	PUSHJ	P, DDBSR1	;F/ NEW DDB, LINKED AFTER CMND PORT
	  POPJ	P,		;FAIL-RETURN

	DPB	J, PJOBN	;SET JOB # OF OWNER
	PUSHJ	P, SCNNAM	;SET PHYSICAL NAME
	MOVEI	T1, ASSCON
	IORM	T1, DEVMOD(F)	;MARK IT ASSIGNED-BY-CONSOLE
	MOVEI	T1, TTYATC
	ANDCAM	T1, DEVMOD(F)	;AND NOT THE COMMAND PORT

	AOS	(P)		;SET TO SKIP-RETURN
	PJRST	COMATT		;AND ATTACH IT
SUBTTL AUXCAL UUO

;AUXCAL UUO

AUXTUU::XCTFU	<HLRE F,(W)>	;F/ PORT DESCRIPTOR
	MOVE	J,JOB		;J/ JOB #
	PUSHJ	P,FNDPRT	;F := DDB ADDR.
	  POPJ	P,		;(NO PORT OR NOT THIS JOB'S PORT)
	HRRZ	U,DDBLDB(F)	;U/ LDB ADDR
	JUMPE	U,CPOPJ		;IF DETACHED, JUST RETURN
	XCTFU	<HRRZ T1,(W)>	;T1/ FUNCTION CODE
	CAIL	T1,AXCLEN	;IF IT'S OUT OF RANGE,
	 POPJ	P,		;  JUST RETURN
	AOS	AXCCNT(T1)	;Count AUXCALs by function
	MOVE	T3,AXCTAB(T1)
	MOVE	S,DEVIOS(F)	;S/ FILE STATUS BITS
	PUSHJ	P,UUOLDB	;SET UP LDB
	TLNN	T3,TUUROM
	 JRST	AUXTU0
	PUSHJ	P,CHKROM
	JRST	AUXTUU
AUXTU0:	TLNE	T3,TUUAIR
	TLNN	U,LDLCOM	;INPUT NOT ALLOWED IF AT COMMAND LEVEL
	 SKIPA
	  POPJ	P,
	TLNE	T3,TUUEAT
	 PUSHJ	P,TYIEAT
IFE OPCRET,<	; KLUDGE TIL OPERATIONS CAN WRITE 10 CODE
	TLNE	T3,TUUFXI
	PUSHJ	P,FIXIMI	;SET IMAGE STATE FROM DATA MODE
>;OPCRET=1 IF PROGRAMS THINK TTCALLS IGNORE IMAGE

	TLNN	T3,TUUIMI
	 JRST	AUXTU1
	MOVSI	T1,LDLIMI
	IORM	T1,LDBDCH(U)	;SET IMAGE STATE ALWAYS
	PUSHJ	P,SETLMD
AUXTU1:	JRST	(T3)
SUBTTL	AUXCAL dispatch table

AXCTAB:	TUUAIR!TUUEAT!TUUIMI,,ACINWC	;0 INPUT CHRS AND WAIT
	TUUAIR!TUUEAT!TUUIMI,,ACINSC	;1 INPUT CHRS AND SKIP
	TUUAIR!TUUEAT!TUUIMI,,ACINWB	;2 INPUT CHRS ELSE AWAIT BREAK
		      TUUROM,,IONEOU	;3 OUTPUT CHARACTER
		      TUUROM,,ACOTCI	;4 OUTPUT CHARACTER IMMEDIATE
		      TUUROM,,OUTPTR	;5 OUTPUT FROM POINTER
			      TSETBI	;6 CLEAR INPUT BUFFER
			      TSETBO	;7 CLEAR OUTPUT BUFFER
	TUUAIR!TUUEAT!TUUFXI,,SKPINC	;10 SKIP IF CHRS PRESENT
		      TUUFXI,,LEVDEF	;11 LEAVE DEFERRED ECHO MODE
			      ACSYL	;12 SEND YELLOW BALL
			      ACBRKC	;13 SET BREAK CHARACTER
		      TCNCRD,,ACTMC	;14 CR DELAY (NOT LF)
		       TCNIR,,ACTMC	;15 INPUT RATE
		       TCNOR,,ACTMC	;16 OUTPUT RATE
		      TCNPAR,,ACTMC	;17 PARITY
		      TCNHDX,,ACTMC	;20 HALF DUPLEX
		       TCNPA,,ACTMC	;21 PARAMETER A
		       TCNPB,,ACTMC	;22 PARAMTER B
		       TCNPC,,ACTMC	;23 PARAMETER C
		      TCNNXO,,ACTMC	;24 SET NO XON-XOFF
			      ACNTB	;25 SET NO SPECIAL TAB HANDLING
			      ACTBK	;26 SET TABS AS BREAKS
		      TCNWID,,ACTMC	;27 SET WIDTH
		      TCNFC1,,ACTMC	;30 SET FILLER CLASS 1
		      TCNFC2,,ACTMC	;31 SET FILLER CLASS 2
			      SETIO2	;32 SET FILE STATUS, DON'T FIXIMI
			      FRCINP	;33 FORCE INPUT
			      BLKIO	;34 ENABLE BLOCK INPUT/OUTPUT
	       TUUAIR!TUUEAT,,BLKINP	;35 INPUT A BLOCK
	       TUUAIR!TUUEAT,,BLKINS	;36 INPUT BLOCK &SKIP IF DATA
			      BLKOUT	;37 OUTPUT A BLOCK
			      BLKXIN	;40 REQUEST BLOCK INPUT TERMINATION
			      BLKXOT	;41 REQUEST BLOCK OUTPUT TERMINATION.
			      BLKXIO	;42 TERMINATE BLOCK I/O MODE
			      MAKDET	;43 TURN COMMAND PORT TO "AUX"PORT
	       TUUEAT!TUUFXI,,I1CHRW	;44 INPUT CHRS AND WAIT
	TUUAIR!TUUEAT!TUUFXI,,INCHRS	;45 INPUT CHRS AND SKIP
	       TUUEAT!TUUFXI,,I1CHWL	;46 INPUT CHRS AND WAIT LINE
	TUUAIR!TUUEAT!TUUFXI,,INCHSL	;47 INPUT CHRS AND SKIP LINE
	TUUAIR!TUUEAT!TUUFXI,,SKPINL	;50 SKIP IF LINE PRESENT
		      TUUROM,,OUTCHI	;51 OUTPUT CHR IMMEDIATE (NOT IMAGE
		      TUUROM,,OUTSTR	;52 OUTPUT STRING
		      TCNXON,,ACTMC	;53 SET XON-XOFF PARAMETER
		      TCNECH,,ACTMC	;54 SET ECHO CONTROL H PARAMETER
		      TCNRXE,,ACTMC	;55 SET REVERSE XON-XOFF PARAMTER
		       TCNPD,,ACTMC	;56 SET PARM D (was TCNTYP/TCNKAT)
		      TCNBSP,,ACTMC	;57 SEND BACKSPACE FOR RUBOUT SEQ
			      ACHNG	;60 SEND HANGUP
			      ACPSM	;61 READ PORT STATUS MESSAGE
		      TCNERA,,ACTMC	;62 ERASE FOR CHAR DELETE
		      TCNDEF,,ACTMC	;63 DEFERRED-ECHO MODE
			      ACSFS	;64 SET FILE STATUS, THEN FIXIMI
		      TCNLCO,,ACTMC	;65 SET/CLEAR LOWER CASE ONLY OUTPUT FLAG
			      ACBBP	;66 SET BACKSPACE AS BREAK2
		      TUUROM,,OUTPTC	;67 OUTPUT FROM POINTER+COUNT
			      ACSOB	;70 SEND ORANGE BALL
			      ACSOX	;71 SET/CLEAR SUPPRESS-OUTPUT-TRANSLATION
			      FRCRSC	;72 FORCE A RESCAN LINE (COUNT/POINTER
			      ACTCN	;73 SET TERMINAL CHARACTERISTIC BY NUMBER
			      ACTCP	;74 READ CHANGED TC #,,VAL FOR A PTY
			      ACNZP	;75 NO-ZAP-ON-RESET BIT
			      OUTSNW	;76 OUTPUT STRING, NEVER WAIT
		      TCNBSD,,ACTMC	;77 BACKSPACE == RUBOUT/^A
		      TCNCLA,,ACTMC	;100 Set/Read Terminal Class
		      TCNRTC,,ACTMC	;101 Set/Read LXLRTC (Special ^T Mode)
		      TCNKAT,,ACTMC	;102 Set/Read Katakana bit
		      TCNTYP,,ACTMC	;103 Set/Read Terminal Type
AXCLEN==.-AXCTAB

  TTNEGL==TTUUOT-TTUNEG		;Number of negative TTCALLS
TTCNEG:	BLOCK	TTNEGL+20	;Negative TTCALLs and positive TTCALLs
TTCCNT=:TTCNEG+TTNEGL		;Define address for TTCALL 0 count
AXCCNT::BLOCK	AXCLEN		;Count of AUXCALs by function
	SYDVF	(<<TTCNEG,TTNEGL>,<TTCCNT,20>,<AXCCNT,AXCLEN>>)	;3 items for SYSDVF
SUBTTL	READ/SET TERMINAL CHARACTERISTICS BY NUMBER

ACTCN:	XCTFU	<HLRZ T1,(M)>	;T1/ CHAR #
	XCTFU	<HRRE T2,(M)>	;T2/ NEW VALUE OR -1 TO READ
	PUSHJ	P,SETTCN	;TRY TO DO IT
	  POPJ	P,		;(BAD TC# OR BAD NEW VALUE)
	XCTBU	<HRRM T3,(M)>	;GIVE USER THE OLD VALUE
	AOS	(P)
	POPJ	P,

;READ CHANGED TERMINAL CHARACTERISTIC FROM PTY

ACTCP:	HLL	U,LDBDCH(U)
	TLNN	U,LDLPTY	;IF IT'S NOT A PTY,
	 POPJ	P,		;  ERROR-RETURN
	PUSH	P,U
	PUSHJ	P,PTYBUD
	MOVE	T1,LDBTCB(U)	;T1/ CHANGED-TC BITS
	JFFO	T1,ACTCP1	;IF NONE,
	XCTTU	<SETOM (M)>	;  GIVE CALLER A -1 WORD
	JRST	ACTCP2
ACTCP1:	MOVN	T1,T2
	MOVSI	T4,(1B0)
	LSH	T4,(T1)
	ANDCAM	T4,LDBTCB(U)	;CLEAR THE "UNREAD" BIT
	MOVE	T1,T2		;T1/ TC#
	XCTBU	<HRLM T1,(M)>	;GIVE CALLER THE TC#
	SETO	T2,		;-1 = READ TC
	PUSHJ	P,SETTCN
	 STOPCD
	XCTBU	<HRRM T3,(M)>	;GIVE CALLER THE TC VALUE
ACTCP2:	POP	P,U
	JRST	CPOPJ1
SUBTTL	SETTCN - READ/SET TERMINAL CHARACTERISTICS BY NUMBER
;	   CALLED WITH T1/ CHARACTERISTIC # (TCNxxx)
;		       T2/ NEW VALUE (-1 TO JUST READ)
;		       U/ LDB ADDR
;	   NONSKIP-RETURNS IF TC# OR NEW VALUE IS OUT OF BOUNDS
;	   SKIP-RETURNS WITH T3/ OLD VALUE OTHERWISE
;
;SETTC1 - ASSUMES TC# IS IN BOUNDS

SETTCN:	CAIGE	T1,TCNN		;IF TCNxxx OUT OF BOUNDS
SETTC1:	CAMLE	T2,TCVMAX(T1)	;OR NEW VALUE TOO BIG,
	 POPJ	P,		;  ERROR-RETURN
	HRRZ	T3,TCNDSP(T1)	;TYPE, one of TYMTC, BYTTC, or ACxxxC
	PUSH	P,T1
	HRLM	T2,(P)		;(P)/ (NEW VALUE OR -1),,TC#
	PUSHJ	P,(T3)		;DISPATCH
	  JRST	TPOPJ		;  ERROR-RETURN
	MOVSI	T1,LDLPTY
	SKIPL	(P)		;IF WE WERE JUST READING
	TDNN	T1,LDBDCH(U)	;OR IT'S NOT A PTY,
	 JRST	TPOPJ1		;  JUST SKIP-RETURN
	HRRZ	T1,(P)
	MOVN	T1,T1		;T1/ - TC#
	MOVSI	T2,(1B0)
	LSH	T2,(T1)		;T2/ LDBTCB BIT FOR THE TC
	IORM	T2,LDBTCB(U)	;SET IT
	MOVEM	T3,(P)
	PUSH	P,U
	PUSH	P,F
	PUSH	P,J
	PUSHJ	P,PTYBUD	;U/ BUDDY LDB ADDR
	MOVEI	T1,LXRTCC
	IORM	T1,LDBDCX(U)	;NOTE THAT A TC WAS CHANGED
	HRRZ	F,LDBDDB(U)
	JUMPE	F,SETTC2	;IF THE OTHER END IS ATTACHED
	LDB	T1,DDPTTC
	JUMPE	T1,SETTC2	;AND TRAPPING TC CHANGES
	PUSHJ	P,TAKTRJ	;  SIGNAL THE CHANGE
SETTC2:	POP	P,J
	POP	P,F
	POP	P,U
	POP	P,T3
	JRST	CPOPJ1

;If TYPE=BYTTC, then ARG = name of byte pointer (LDPxxx)
;If TYPE=TYMTC, then ARG = name of host-to-base # (TMCxxx)

DEFINE Z(NAME,MAXVAL,TYPE,ARG) = <ARG,,TYPE>
TCNDSP:	TCHARS

DEFINE Z(NAME,MAXVAL,TYPE,ARG) = <MAXVAL>
TCVMAX:	TCHARS

;BYTTC - update byte in LDB, for things the TYMSAT does not do for us

BYTTC:	HLRZ	T1,TCNDSP(T1)	;T1/ BYTE POINTER ADDR
	LDB	T3,(T1)		;Get old value from LDB
	SKIPL	T2		;If not -1, then
	 DPB	T2,(T1)		; set new value in the LDB
	JRST	CPOPJ1
SUBTTL	SETTCN ROUTINES

;TYMTC - READ/SET TYMNET TERMINAL CHARACTERISTICS
;	 CALLED WITH T1/ CHARACTERISTIC # (TCNxxx)
;		      T2/ -1 (TO JUST READ) OR NEW VALUE
;	  SKIP-RETURNS WITH T3/ THE OLD VALUE
;TYMTC1 - CALLED WITH T1/ TYMNET'S TC# (TMCxxx)

TYMTC:	HLRZ	T1,TCNDSP(T1)	;USER TC# = TYMNET TC#
TYMTC1:	CAILE	T1,MAXTMC	;IF OUT-OF-RANGE,
	 STOPCD 		;  CRASH
	LDB	T3,TABTMR(T1)	;T3/ old received value
	JUMPL	T2,CPOPJ1	;IF JUST LOOKING, SUCCESS-RETURN
	DPB	T2,TABTMS(T1)	;Store new value to be sent to the TYMSAT
;Japanese customers use the command "TTY TYPE 1" and expect it to do both
;"SET TTY D 15" and "SET TTY KATAKANA".  MAGNUM expects Katakana terminals
;to have parameter D set to octal 17, ASCII terminals have D set to 0.
;NOTE: The old BASEs translated TYMNET terminal characteristic #15 (PARM-D)
;from to host to TYMNET terminal characteristic #16 (KATAKANA) before
;passing the command to the TYMSAT.  As an interim measure, set both when
;either is changed.
	CAIE	T1,TMCPD	;"SET TTY D 1"?
	CAIN	T1,TMCKAT	; or "SET TTY KATAKANA"?
	 SKIPA			;Yes, set both
	  JRST	TYMTC2		;No
PRINTF	(<[EBUS02.J01 translates PARM-D(15.) to KATAKANA(16.) for ISIS]>)
	DPB	T2,TABTMS+TMCKAT;Set KATAKANA bit if parm D is odd
	DPB	T2,TABTMR+TMCKAT;EBUS02.J01 does not return KATAKANA bit to us
	DPB	T2,TABTMS+TMCPD	;Set parm D if KATAKANA bit is set
	TRNN	T2,1		;Simulate TYMNET-I's one-bit field
	TDZA	T2,T2		; Even = 0
	 MOVEI	T2,17		; Odd = 17
	DPB	T2,TABTMR+TMCPD	;Store this value to be overwritten if the node
				; does understand "parameter D"
	MOVE	T2,[1B<TMCPD>!1B<TMCKAT>]
	IORM	T2,LDBTMT(U)	;Mark them both as being changed

TYMTC2:	MOVNS	T1		;Negative of TYMNET's TC
	MOVSI	T2,(1B0)
	LSH	T2,(T1)		;Position to bit (B0 thru B20)
	IORM	T2,LDBTMT(U)	;SET TRANSMIT BIT
	MOVEI	T1,1
	DPB	T1,LOPSTC	;SET SEND-CHARACTERISTICS
	AOS	(P)		;skip return
SETOPB:	DPB	T1,LDBOPB(U)	;SET NEED-OUTPUT
	POPJ	P,
SUBTTL	SETTCN ROUTINES

;WIDTH

ACWIDC:	LDB	T3,LDPWID
	JUMPL	T2,CPOPJ1
	CAIL	T2,^D20		;IF IT'S TOO SMALL
	CAILE	T2,^D199	;OR TOO LARGE,
	 POPJ	P,		;  ERROR-RETURN
	DPB	T2,LDPWID	;ELSE SET IT
	JRST	CPOPJ1

;BACKSPACE FOR DELETE

ACBSPC:	LDB	T3,LDPERA
	TRZN	T3,1		;IF ERASE IS SET, SAY BS ISN'T
	 LDB	T3,LDPBSP
	JUMPL	T2,CPOPJ1
	DPB	T2,LDPBSP
	SETZ	T2,
	DPB	T2,LDPERA	;ALWAYS CLEAR ERASE
	JRST	CPOPJ1

;ERASE FOR DELETE

ACERAC:	LDB	T3,LDPERA
	JUMPL	T2,CPOPJ1
	DPB	T2,LDPERA
	DPB	T2,LDPBSP	;EITHER SET BOTH OR CLEAR BOTH
	JRST	CPOPJ1

;DEFERRED ECHO

ACDEFC:	LDB	T3,LDPDEM
	JUMPL	T2,CPOPJ1
	MOVE	T1,LDBDCH(U)
	TRNE	T2,1
	 TROA	T1,LDRDEM
	  TRZ	T1,LDRDEM
	EXCH	T1,LDBDCH(U)
	CAME	T1,LDBDCH(U)	;IF THE BIT CHANGED
	TLNE	T1,LDLNEC	;AND NO ECHO NOT SET,
	 JRST	CPOPJ1
	MOVEI	T1,1
	DPB	T1,LOPSEC	;  SET SEND-ECHO
	DPB	T1,LDBOPB(U)	;  AND NEED-OUTPUT
	JRST	CPOPJ1
SUBTTL	SETTCN ROUTINES

;PAPER TAPE MODE

ACPTPC:	LDB	T3,LDPPTP
	JUMPL	T2,CPOPJ1
	DPB	T2,LDPPTP	;SET PAPER-TAPE BIT TO USER VALUE
	PUSH	P,T3
	TRC	T2,1
	MOVEI	T1,TMCECR
	PUSHJ	P,TYMTC1	;AND CR-AS-CRLF TO ITS COMPLEMENT
	 STOPCD
	POP	P,T3
	JRST	CPOPJ1

;[JMS] Terminal Type - Must be a valid type

ACTTYP:	LDB	T3,LDPTYP	;T3 := old value
	CAMN	T2,[-1]		;Setting or reading?
	 JRST	CPOPJ1		;Just reading
	DPB	T2,LDPCLA	;Set TTY CLASS to this value
;Need to verify that this type is valid (such as VT100, HP2621, TYM444, etc)
	DPB	T2,LDPTYP	;Valid type, set it
PRINTF (<[Need to set WIDTH, ERASE, etc at ACTTYP]>)
	JRST	CPOPJ1

;[dws] Terminal Class - can be any SIXBIT value

ACTCLA:	LDB	T3,LDPCLA	; T3 := old value
	CAME	T2,[-1]		; Don't store if only reading
	 DPB	T2,LDPCLA	;  new valued := T2
	JRST	CPOPJ1
SUBTTL	NO SPECIAL TAB HANDLING

ACNTB:	LDB	T2, LDPNTB
	XCTBU	<EXCH T2,(M)>
	JUMPL	T2, CPOPJ
	DPB	T2, DDPNTB
	DPB	T2, LDPNTB
	POPJ	P,

;TABS AS BREAKS

ACTBK:	LDB	T2, LDPTBK
	XCTBU	<EXCH T2,(M)>
	JUMPL	T2, CPOPJ
	DPB	T2, DDPTBK
	MOVEI	T1, L2LTBK
	TRNE	T2, 1		;CHECK LOW ORDER BIT
	HRLI	T1, L2LTBK
	PJRST	SETTBK		;GO SET IT

;BACKSPACE AS PUNCTUATION

ACBBP:	LDB	T2, LDPBBP
	XCTBU	<EXCH T2,(M)>
	JUMPL	T2, CPOPJ
	DPB	T2, DDPBBP
	MOVEI	T1, L2LBBP
	TRNE	T2, 1		;CHECK LOW ORDER BIT
	HRLI	T1, L2LBBP
	PJRST	SETTBK		;GO SET IT

;SUPPRESS-OUTPUT-TRANSLATION (FOR PTYS ONLY)

ACSOX:	HLL	U, LDBDCH(U)
	TLNN	U, LDLPTY	;IF IT'S NOT A PTY,
	POPJ	P,		;  JUST RETURN
	PUSH	P, U
	PUSHJ	P, PTYBUD	;U/ "BUDDY" LDB ADDR
	LDB	T1, LDPSOX	;T1/ CURRENT SOX VALUE
	XCTBU	<EXCH T1,(M)>	;SWAP WITH ARGUMENT
	JUMPL	T1, .+2		;IF USER SUPPLIED A NEW VALUE,
	DPB	T1, LDPSOX	;  SET IT
	POP	P, U
	POPJ	P,

;READ/SET DVNZP BIT

ACNZP:	LDB	T1, DDPNZP	;T1/ CURRENT VALUE
	XCTBU	<EXCH T1, (M)>	;SWAP WITH USER'S
	JUMPL	T1, CPOPJ	;(JUST READING)
	DPB	T1, DDPNZP	;SET IT
	POPJ	P,
SUBTTL	OLD AUXCAL TERMINAL-CHARACTERISTICS DISPATCH

ACTMC:	HLRZ	T1,T3		;T1/ CHARACTERISTIC #  (TCNxxx)
	XCTFU	<MOVE T2,(M)>	;T2/ USER'S ARGUMENT
	PUSHJ	P,SETTC1	;T3 := OLD VALUE
	  JFCL			;(NEW VALUE WAS BAD)
	XCTTU	<MOVEM T3,(M)>	;STORE IT
	POPJ	P,

;SET FILE STATUS BITS, THEN FIX IMAGE STATE

ACSFS:	PUSHJ	P,SETIO2
	HRR	U,DDBLDB(F)
	MOVE	S,DEVIOS(F)
	PJRST	FIXIMI

;SEND YELLOW BALL

ACSYL:	MOVEI T1,1
	DPB T1,LOPSYL		;SET SEND-YELLOW
	PJRST SETOPB

;SEND ORANGE BALL

ACSOB:	MOVE	T1, LDBDCX(U)
	TLZN	T1, LXLOOK	;IF IT'S OK TO SEND 1,
	  POPJ	P,
	MOVEM	T1, LDBDCX(U)	;  (NOT 2, JUST 1)
	MOVSI	T1, L2LLDF
	IORM	T1, LDBBYT(U)	;  FAKE INPUT WAIT SO BALL'LL GO
	MOVEI	T1, 1
	DPB	T1, LOPSOG	;  SET SEND-ORANGE
	PJRST	SETOPB

;SEND HANGUP (SOFT ZAPPER)

ACHNG:	MOVEI	T1, 1
	DPB	T1, LOPHNG	;SET SEND-HANG
	PJRST	SETOPB

;Read last PORT STATUS message (AUXCAL function .AXPSM=61)
;From the YAMM dated July 1980: "The port status returned is 4 bits for
;which there is no documentation.  This operation was implemented for the
;initial TYMNET-I Dial-Out facility."  The current code in the base,
;EBUS02.J01, does not have any code for passing this message to the PDP-10.

ACPSM:	LDB	T1, LDPPSM	; GET LAST PORT STATUS MSG
	UMOVEM	T1, (M)		; GIVE IT TO HIM
	MOVSI	T1, LMLPSP
	ANDCAM	T1, LDBMOD(U)	; AND NOTE IT'S BEEN READ
	POPJ	P,
SUBTTL	SET IMAGE BREAK CHARACTER

ACBRKC:	UMOVE	T1, (M)
	TRNN	T1, 400		;IF IMAGE BIT NOT ON,
	SETZ	T1,		;  CLEAR THE CHARACTER
	DPB	T1, LDPIMB
	DPB	T1, DDPIMB
	POPJ	P,
SUBTTL	IMAGE-STATE INPUT AUXCALS

ACINWC:	NOCHARGE
ACIN1:	PUSHJ P,TWAITC	;THIS WILL SET MODE TO IMAGE
	PUSHJ P,TYI
	 JRST ACIN1	;TRY AGAIN
ACIN2:	ANDI T3,377
	UMOVEM T3,(M)
	AOS (P)		;SKIP RETURN (AS OPPOSED TO NO PORT)
	JRST NOCTRO

ACINSC:	NOCHARGE
	SKIPG LDBECC(U)	;ANY CHRS?
	SKIPLE LDBTIC(U)
	SKIPA		;YES
	JRST SETLMD	;NO, SET TO IMAGE ANYWAY
	PUSHJ P,TWAITS
	  POPJ	P,	;DETACHED
	PUSHJ P,TYI
	 JRST NOCTRO	;NONE THERE
	JRST ACIN2	;GIVE IT TO HIM

ACINWB:	NOCHARGE
	PUSHJ P,TWAITL	;WAIT FOR IMAGE-MODE BREAK CHARACTER OR TIMEOUT
	PUSHJ P,TYI
	 POPJ P,	;PROBABLY END OF FILE SET
	JRST ACIN2	;GIVE HIM CHR
SUBTTL	AUXCAL -- .AXSI=33 - Simulate input

FRCINP:	UMOVE	M,(M)		;GET BYTE POINTER
	TLZ	M,37		;GET RID OF INDEX AND INDIRECT
	MOVE	T1,M		;Check the string before forcing input
	MOVEI	T2,0
FRCLP0:	XCTFU <ILDB T3,T1>	;Get char
	ANDI	T3,377		;Watch out for strange byte sizes
	SKIPE	T3
	 AOJA	T2,FRCLP0	;Loop until null
	ADD	T2,LDBTIC(U)	;Add to count of chars already input
	ADD	T2,LDBECC(U)	; and chars not yet echoed
	CAML	T2,TIHLTN	;If it would exceed the limit
	 POPJ	P,		; then do nothing and give error return

FRCLP1:	XCTFU <ILDB T3,M>
	ANDI	T3,377		; USE ONLY THE RIGHT 8 BITS
	JUMPE	T3,CPOPJ1	;FINISHED
	PUSHJ	P,MOVCHR	;PUT CHR IN INPUT BUFFER
	  JRST	FRCLP1		;NO ECHO REQUIRED
	MOVEI	T1,1		;LAST CHAR SWITCHED TO DEFERED ECHO
	DPB	T1,LOPECO	;SET NEED-ECHO
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
FRCLP2:	XCTFU <ILDB T3,M>	;LOOP HERE FOR DEFERED ECHO MODE
	ANDI	T3,377		; USE ONLY THE RIGHT 8 BITS
	JUMPE	T3,CPOPJ1	;FINISHED
	PUSHJ	P,MOVCHR	;PUT CHAR IN OTHER INPUT BUFFER
	  JFCL			;SHOULD ALWAYS SKIP NOW
	JRST	FRCLP2		;LOOP IN EITHER CASE
SUBTTL	FORCE A RESCAN LINE

%FROK==0	;NO ERROR
%FRAUX==1	;PORT IS AN AUX CIRCUIT
%FRBIG==2	;COMMAND STRING IS TOO BIG
%FRCMD==3	;PORT IS IN COMMAND STATE
%FRBRK==4	;BREAK BEFORE END OF COMMAND STRING (BYTE PTR UPDATED)
%FRNBK==5	;NO BREAK ENCOUNTERED IN STRING
%FRFUL==6	;RESCAN COMMAND ALREADY PRESENT

FRCRSC:	HLL	U, LDBDCH(U)
	TLNE	U, LDLAUX	;IF PORT IS AN AUX CIRCUIT,
	 JRST	[
		MOVEI	P1, %FRAUX
		JRST	FRCRSX	;  ERROR-RETURN
	]
	TLNE	U, LDLCOM	;IF PORT IS IN COMMAND STATE,
	 JRST	[
		MOVEI	P1, %FRCMD
		JRST	FRCRSX	;  ERROR-RETURN
	]
	XCTFU	<MOVE P1, 0(M)>	;P1/ COUNT
	CAIL	P1, TIWKC	;IF IT'S TOO BIG,
	 JRST	[
		MOVEI	P1, %FRBIG
		JRST	FRCRSX	;  ERROR-RETURN
	]
FRCRS1:	MOVE	T1, P1
	ADDI	T1, <<<TTCHKS-1>*4>-1>
	IDIVI	T1, <<TTCHKS-1>*4>	;T1/ # CHUNKS NEEDED
	MOVE	T2, TTFREN
	SUBI	T2, TIRSVD	;T2/ # CHUNKS AVAILABLE
	CAMG	T1, T2		;IF THERE AREN'T ENOUGH,
	 JRST	FRCRS2
	MOVSI	S, TWTSPC
	IORB	S, DEVIOS(F)	;  NOTE THAT WE NEED MORE ROOM
	LDB	T1, DDPTTI	;  T1/ IOW-INTERRUPT ASSIGNMENT
	PUSHJ	P, TSTKTJ	;  IF HE TRAPPED IT,
	JRST	[
		PUSHJ	P, SETFIO	;SET TO GIVE I/O DONE TRAP
		PJRST	ABTUUO		;AND GET OUT
	]
	PUSH	P, P1
	PUSHJ	P, TOWAT1	;  GO INTO OUTPUT WAIT
	POP	P, P1
	JRST	FRCRS1		;  THEN TRY AGAIN
FRCRS2:	PUSHJ	P, TSETBI	;CLEAR THE INPUT BUFFER (!)
	HLL	U, LDBDCH(U)
	SKIPE	FRSFLG
	 STOPCD
	SETOM	FRSFLG		;SET FLAG FOR CMDPGAK
	TLO	U, LDLCOM	;SET COMMAND STATE
	SETZM	FRSDEF
	TLZE	U, LDLDEF	;CLEAR DEFERRED-ECHO
	SETOM	FRSDEF		;(REMEMBER PGHAT IT PGAS)
	HLLM	U, LDBDCH(U)
	PUSHJ	P, SETLMD	;FIX LINE-MODE FIELD

    ;HERE TO ACTUALLY FORCE THE INPUT
    ;P1/ COUNT

	XCTFU	<MOVE PG, 1(M)>	;PG/ BYTE POINTER
	TLZ	PG, 37		;CLEAR INDEX AND INDIRECT BITS
	PUSH	P, P1		;0(P)/ COUNT

FRCRS3:	SOSGE	0(P)		;DONE?
	JRST	FRCRS4		;(YES)
	XCTFU	<ILDB T3, PG>	;T3/ NEXT CHARACTER
	ANDI	T3, 377		;(ONLY 8 BITS)
	PUSHJ	P, MOVCHR	;DEPOSIT IT
	JRST	.+1		;(REMOTE-ECHO RETURN)
	SKIPE	FRSFLG		;IF CMDPGAK NOT CALLED YET,
	JRST	FRCRS3		;  TRY THE NEXT CHARACTER

    ;HERE WHEN A "COMMAND LINE" HAS BEEN FORCED

	POP	P, T1		;T1/ COUNT LEFT
	JUMPE	T1, FRCRS5	;IF THERE'RE CHARS AFTER THE BREAK,
	XCTTU	<MOVEM PG, 1(M)>;  STORE BACK THE MODIFIED BYTE POINTER
	MOVEI	P1, %FRBRK	;  ERROR-RETURN
	JRST	FRCRS6

    ;HERE WHEN WE RAN OUT OF CHARACTERS BEFORE A "COMMAND LINE"
    ;WAS FINISHED

FRCRS4:	POP	P, T1
	SETZM	FRSFLG		;CLEAR FLAG
	MOVEI	P1, %FRNBK	;ERROR-RETURN
	JRST	FRCRS6

    ;HERE WHEN THINGS WERE JUST RIGHT

FRCRS5:	MOVEI	P1, %FROK
	PFALL	FRCRS6
    ;CLEAN THINGS UP

FRCRS6:	SKIPN	FRSDEF		;IF PORT WAS IN DEFERRED ECHO MODE,
	JRST	FRCRS7
	MOVSI	T1, LDLDEF
	IORM	T1, LDBDCH(U)	;  SET DEFERRED-ECHO AGAIN
FRCRS7:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	;CLEAR COMMAND MODE
	MOVSI	T1, LDLECS
	IORM	T1, LDBDCH(U)	;SET EAT-COMMAND-SYNC
	PUSHJ	P, SETLMD	;FIX LINE-MODE FIELD

FRCRSX:	SKIPN	P1		;IF NO ERROR OCCURRED,
	AOSA	(P)		;  PREPARE FOR SKIP-RETURN, ELSE
	XCTTU	<MOVEM P1, (W)>	;  USER AC := RETURN CODE
	POPJ	P,
SUBTTL AUXILIARY CIRCUITS

;ONLY ONE AUXILIARY CIRCUIT IS IN THE PROCESS OF BEING BUILT
;AT ANY ONE TIME. JOBS WANTING TO BUILD AN AUX.
;CIRCUIT ARE QUEUED ON THE AX QUE. ONCE A CIRCUIT IS READY TO
;BE BUILT, THE COMMUNICATION WITH THE SUPERVISOR IS
;CONTROLED BY A STATE CELL (AUXSTA). THE FOLLOWING ARE THE STATES

.ASIDL==0	;NOT BUILDING A CIRCUIT
.ASRQ1==1	;READY TO SEND SUPERVISOR REQUEST
.ASWR1==2	;WAITING FOR SUPERVISOR RESOPNSE
.ASRQ2==3	;READY TO RE-SEND SUPERVISOR REQUEST
		;(BECAUSE OF ERROR ON FIRST TRY - PROBABLY
		;COMMUNICATION IS OUT OF SYNC)
.ASWR2==4	;WAITING FOR SUPERVISOR RESPONSE TO RE-SEND
.ASLOG==5	;SENDING LOGIN STRING TO SUPERVISOR
.ASWPT==6	;WAITING FOR A PORT AND A SUPERVISOR RESPONSE
.ASWTP==7	;RECEIVED AN AUX CIRCUIT (MSG TYPE 7) FOR A PORT PENDING A
		; ZAPPER, SO NOW WAITING FOR SUPERVISOR RESPONSE SO WE CAN
		; RE-SEND A SUPERVISOR REQUEST WITHOUT GETTING OUT OF SYNC
		;( ** NOT SUPPOSED TO HAPPEN ** SEE TTYZNE & ZAPBUG ** )

;ERROR NUMBERS FROM THE PDP-10

CX2AX%==1	;TOO MANY AUX CIRCUITS FOR THIS JOB AND NO AC LICENSE
CXLOG%==2	;USER NAMES DO NOT MATCH AND NO AC LICENSE
CXDCB%==3	;NO DDB'S AVAILABLE
CXNRR%==4	;NO RESPONSE TO FIRST REQUEST
CXNRL%==5	;NO RESPONSE AFTER STRING SENT
CXNCH%==6	;NO PORT RECEIVED
CXERR%==7	;ERROR FROM FIRST RESPONSE

;SPECIAL ROUTINE WHEN COMMING OUT OF IO WAIT FINDS
;AN AUX CIRCUIT ZAPPED

AUXRID:	MOVEI	T1,ASSCON!ASSPRG
	TDNN	T1,DEVMOD(F)		;STILL ASSIGNED?
	 PUSHJ	P,TTYKDB		;NO, REMOVE DDB
	JRST	ABTUUO			;IN ANY CASE, ABORT
SUBTTL	TURN THE COMMAND PORT INTO SOMETHING LIKE AN "AUX" PORT

MAKDET:	MOVSI	T1,TTYATC	;MUST BE COMMAND PORT
	TDNN	T1,DEVMOD(F)
	 POPJ	P,
	JUMPE	U,CPOPJ		;DO NOT ALLOW IF NOT COMMAND OR DET
	MOVSI	T1,LLLZAP
	TDNE	T1,LDBLOG(U)
	 POPJ	P,		;OR IF WAITING TO LOG OUT
	MOVSI	T1,LICAC
	TDNE	T1,JBTLIC(J)
	 JRST	MAKDLC		;MUST HAVE LIC OR ONLY ONE OTHER PORT
	PUSHJ	P,FRSTTY
	  JRST	MAKDLC
	PUSHJ	P,NXTTTY
	  JRST	MAKDLC
	PUSHJ	P,NXTTTY
	  JRST	MAKDLC
	POPJ	P,		;ERROR, ALREADY HAVE TWO PORTS
MAKDLC:	HRRZ	F,TTYTAB(J)
	HLRZ	T1,DDBBLK(F)
	PUSHJ	P,DDBSR1	;GET ONE AND LINK IT IN
	  POPJ	P,		;CAN NOT
	HRRZ	T2,TTYTAB(J)
	HRRM	F,TTYTAB(J)	;MAKE A NEW COMMAND PORT
	MOVSI	T1,DVNZP
	IORM	T1,DEVMOD(T2)	;DO NOT ALLOW TTY TO BE ZAPPED
	MOVSI	T1,TTYATC
	ANDCAM	T1,DEVMOD(T2)	;NO LONGER THE COMMAND PORT
	HRRI	T1,ASSCON
	IORM	T1,DEVMOD(F)	;MARK AS ASSIGNED BY CONSOLE (FOR RESET)
	DPB	J,PJOBN
	PUSHJ	P,SCNNAM	;THAT SHOULD BE ENOUGH
	  HRRZS	DEVNAM(F)	;SO LOOKS DETACHED
	HRRZ	F,T2
	MOVE	S,DEVIOS(F)
	HRRZ	U,DDBLDB(F)
	MOVSI	T2,LDLCOM
	ANDCAM	T2,LDBDCH(U)
	AOS	(P)
	LDB	T1,LDPLNO
	UMOVEM	T1,(M)
	PJRST	UUOLDB
SUBTTL	HERE FROM HANG UUO WHEN HANGING AN AUX CIRCUIT

HNGAUX:	HRRZ	F,LDBDDB(U)
	JUMPE	F,HNGAXD	;IF IT'S ATTACHED,
HNGAX1:	LDB	T1,DDPTZP
	PUSHJ	P,TAKTRJ	;  INTERRUPT ITS OWNER
	MOVEI	T2,ASSCON
	PJRST	RELEA6		;  AND CLEAR ASSIGNED-BY-CONSOLE

    ;HERE WHEN PORT IS ALREADY DETACHED

HNGAXD:	PUSHJ	P,TTYZAP	;SET TO SEND A ZAPPER BACK
	HRRZS	U		;CLEAR LDBDCH BITS
	CAME	U,AUXRCP	;IF IT'S THE RECEIVED AUX PORT,
	 JRST	HNGAX4
	SETOM	AUXRCP		;  SAY WE HAVEN'T RECEIVED ONE
	AOS	ZRPCNT		;  AND NOTE THAT WE DID SO
HNGAX4:	POPJ	P,

;HERE WHEN A ZAPPER IS RECEIVED ON AN AUX PORT

ZAPAUX:	HRRZ	F,LDBDDB(U)	;F/ DDB ADDR
	JUMPE	F,HNGAXD	;IF DETACHED, JUST CHECK "RECEIVED" PORT
	PUSHJ	P,TTYZAP	;SET TO SEND ZAPPER
	HLLZS	DDBLDB(F)	;DETACH IT
	HLLZS	LDBDDB(U)
	JRST	HNGAX1		;INTERRUPT JOB, CLEAR ASSCON

;HERE FROM RELEA6 WHEN BOTH ASSCON AND ASSPRG GO OFF

AUXZAP:	HRRZ	U,DDBLDB(F)
	JUMPE	U,AXZP1		;IF DDB HAS A PORT ATTACHED,
	PUSHJ	P,TTYZAP	;  SET TO SEND ZAPPER
	HLLZS	DDBLDB(F)
	HLLZS	LDBDDB(U)	;  DETACH IT
	SETZM	LDBSTR(U)	;  CLEAR PREVIOUS CIRCUIT NAME
	HRRZI	T1,LDBSTR+1(U)	;  GET ADDRESS
	HRLI	T1,-1(T1)	;    STR,,STR+1
	BLT	T1,LDBSTR+AUXSTL-1(U)
AXZP1:	HRRZS	DEVNAM(F)	;MARK NAME AS DETACHED
	MOVSI	T1,TIOUSE
	TDNN	T1,DEVIOS(F)	;IF NO UUO IS IN PROGRESS,
	 PJRST	TTYKDB		;  KILL THE DDB
	MOVE	S,DEVIOS(F)	;OTHERWISE,
	PJRST	TIWAKE		;  JUST WAKE THE JOB
SUBTTL	ON RECEIPT OF A TAKEOVER MESSAGE, RESET AND TRY AGAIN

RCVNSP:	MOVE	T1,DATE##	;Remember the date/time of when
	MOVEM	T1,SUPTIM##	; the new Supervisor took over
	SKIPN	AUXSTA
	 AOJA	P4,SCNIN1	;IN IDLE STATE, JUST IGNORE
	SKIPL	U,AUXRCP	;PORT RECEIVED?
	 PUSHJ	P,TTYZAP	;YES, ZAP IT
	MOVEI	T1,.ASRQ1
	MOVEM	T1,AUXSTA
	AOJA	P4,SCNIN1	;READY TO SEND FIRST REQUEST
SUBTTL	SUPERVISOR RESPONSE RECIVED

RCVSUR:	MOVE	T1,AUXSTA
	XCT	ARSTAB(T1)

ARSTAB:	AOJA	P4,SCNIN1	;.ASIDL IGNORE
	AOJA	P4,SCNIN1	;.ASRQ1 IGNORE
	JRST	RCVS2		;.ASWR1 RESPONSE TO 1ST REQUEST
	AOJA	P4,SCNIN1	;.ASRQ2 IGNORE
	JRST	RCVS4		;.ASWR2 RESPONSE TO 2ND REQUEST
	AOJA	P4,SCNIN1	;.ASLOG IGNORE
	JRST	RCVS6		;.ASWPT RESPONSE TO LOGIN
	JRST	RCVSP		;.ASWTP RESPONSE TO LOGIN (BAD RCVAUX)

    ;SUPERVISOR RESPONSE TO FIRST REQUEST

RCVS2:	LDB	T1,INPCHR	;GET ERROR CODE
	JUMPN	T1,[AOS AUXSTA	;ON ERROR, STATE:=.AXRQ2 (RETRY)
		AOJA P4,SCNIN1]
RCVS2A:	MOVE	T1,[POINT 7,AUXSTR]
	MOVEM	T1,AUXSTP
	MOVEI	T1,.ASLOG
	MOVEM	T1,AUXSTA	;SUCCESSFUL RESPONSE: SEND LOGIN STRING
	AOJA	P4,SCNIN1

  ;SUPERVISOR RESPONSE TO RE-REQUEST

RCVS4:	LDB	T1,INPCHR	;LIKE 1ST REQUEST BUT ERROR IS FATAL
	JUMPE	T1,RCVS2A	;NO ERROR
	HRLI	T1,CXERR%	;SET ERROR TYPE
	PUSHJ	P,ERRXIT	;AND CLEAN UP
	AOJA	P4,SCNIN1

    ;SUPERVISOR RESPONSE TO LOGIN STRING

RCVS6:	LDB	T1,INPCHR
	JUMPN	T1,[PUSHJ P,ERRXIT	;ERROR, TELL USER
		AOJA P4,SCNIN1]	;AND CLEAN UP
	PUSHJ	P,AUXWAK	;WAKE UP THE USER
	AOJA	P4,SCNIN1

RCVSP:	LDB	T1,INPCHR
	JUMPN	T1,[PUSHJ P,ERRXIT	;ERROR, TELL USER
		AOJA P4,SCNIN1]	;AND CLEAN UP
	MOVEI	T1,.ASRQ1	;SHOULDN'T GIVE ERROR TO USER,
	MOVEM	T1,AUXSTA	;SO SETUP FOR RETRY
	AOJA	P4,SCNIN1

ERRXIT:	MOVEM	T1,AUXERR	;SAVE ERROR
	SKIPL	U,AUXRCP	;IS THERE A PORT
	 PUSHJ	P,TTYZAP	;YES, ZAP IT
AUXWAK:	SETZM	AUXSTA		;STATE:=.ASIDL (IDLE)
	MOVE	J,AUXJOB	;JOB WAITING
	MOVEI	T1,RNQ
	DPB	T1,PJBSTS##
	PJRST	SETRUN		;RESTART HIM FOM MLOWQ
SUBTTL	 MESSAGE 7 - AN AUX CIRCUIT HAS BEEN BUILT TO <U> FOR
;	       THE JOB WHOSE COMMAND PORT IS <INPCHR>

RCVAUX:	MOVE	T1,LDBLIN(U)
	TLNE	T1,LNLZIN		;IF THERE'S AN UNECHOED ZAPPER,
	 JRST	[MOVEI	T1,NZAPAX
		 PUSHJ	P,ZAPBUG	;NOTE IT
		 JRST	.+1]
	SKIPE	LDBLOG(U)		; LOGGING OR LOGGED IN?
					;  TREAT AS CIRCUIT ZAPPER
	  JRST	[PUSHJ	P,ZAPLOG	; NOTE THE ZAP (increment P4)
		 MOVE	T1,AUXSTA	; Make sure that we were
		 CAIE	T1,.ASWPT	;  expecting a type 7 msg.
		  SOJA	P4,AUXWST	; No? decrement & handle error
		 AOS	AUXSTA		; Yes, State:= .ASWTP, keep waiting!
		 JRST	SCNIN1]		; Return to loop

	MOVE	T1,AUXSTA		; T1/ STATE
	CAIN	T1,.ASWPT		; IF WE'RE NOT EXPECTING A TYPE 7,
	 JRST	AUXINP
	PFALL	AUXWST			;   NOTE THE ERROR

AUXWST:	; MESSAGE RECEIVED IN WRONG STATE
	AOS	AUXWSC			; NOTE THE FACT
	JRST	AUXZPT			; TREAT MSG AS A ZAPPER

AUXWPN:	; MESSAGE RECEIVED BUT WITH THE WRONG PORT NUMBER
	AOS	AUXWPC			; NOTE THE FACT
	MOVEM	T1,AUXWPT		; SAVE THE (BAD) PORT'S LDB ADDR
	PFALL	AUXZPT			; TREAT MSG AS A ZAPPER

AUXZPT:	PUSHJ	P,TTYZAP		; ARRANGE TO SEND ZAPPER
	AOJA	P4,SCNIN1

AUXINP:	LDB	T1,INPCHR		; T1/ CREATING JOB'S PORT #
	HRRZ	T2,AUXPRT
	CAME	T1,T2			; IS IT CORRECT?
	 JRST	AUXWPN			; NO
	HRRZM	U,AUXRCP		; SAVE THE LINE POINTER
	MOVSI	T1,(1B0)
	MOVEM	T1,LDBLOG(U)		; SET LOGGED-IN BIT

	; INITIALIZE THE LINE
	SETZM	LDBOUT(U)
	SETZM	LDBBYT(U)
	SETZM	LDBMOD(U)
	SETZM	LDBTMT(U)
	ZZN==0
REPEAT TMCSIZ,<
	SETZM LDBTMR+ZZN(U)
	ZZN==ZZN+1
> ; End REPEAT TMCSIZ
	MOVSI	T1,LDLDEF!LDLIMI!LDLAUX!LDLNEC!LDLNFC
	MOVEM	T1,LDBDCH(U)
	MOVSI	T1,LXL120
	MOVEM	T1,LDBDCX(U)
	HRLI	T1,AUXSTR		; Copy string sent to
	HRRI	T1,LDBSTR(U)		;  supervisor for tracking
	BLT	T1,LDBSTR+AUXSTL-1(U)

	PUSHJ	P,SETLMD		; SET THE INPUT MODE
	AOJA	P4,SCNIN1
SUBTTL	CALLED ONCE A TICK FROM SCNINT TO PROCESS AUX CIRCUIT BUILDS

SNDAUX:	MOVE	T1,AUXSTA	;SEE WHAT WE SHOULD DO
	XCT	AXSNTB(T1)
	 JRST	AUXTOV		;TIME OUT
	JRST	CPOPJ1		;JUST RETURN

AXSNTB:	JRST	CPOPJ1		;.ASIDL  DO NOTHING
	JRST	SNDSRQ		;.ASRQ1  SEND 1ST REQUEST
	SOSG	AUXTIM		;.ASWR1  TIME THE RESPONSE
	JRST	SNDSRQ		;.ASRQ2  SEND 2ND REQUEST
	SOSG	AUXTIM		;.ASWR2  TIME THE RESPONSE
	JRST	AUXCHR		;.ASLOG  SEND LOGIN STRING
	SOSG	AUXTIM		;.ASWPT  TIME THE RESPONSE
	SOSG	AUXTIM		;.ASWTP  TIME THE RESPONSE

AUXTMR:	^D150*^D60		;REQUEST RESPONSE TIMEOUT
AUXTMP:	^D150*^D60		;PORT RESPONSE TIMEOUT

    ;HERE TO SEND A SUPERVISOR REQUEST

SNDSRQ:	PUSHJ	P,CLSCHR
	  POPJ	P,		;NOT REALLY ANY ROOM
	MOVSI	P3,TYPI TYPSUP	;SEND REQUEST
	MOVE	T1,AUXPRT	;GET THE PORT NUMBER
	DPB	T1,WRPLIN
	HLRZ	T1,AUXPRT	;Get NETID number
	DPB	T1,WRP3N4	;Store 16 bits
	MOVE	T1,AUXTMR	;SET TIMER
	MOVEM	T1,AUXTIM
	AOS	AUXSTA		;ADVANCE STATE (.ASRQX = .ASWTX)
	JRST	WRDOUT		;AND SEND REQUEST
SUBTTL	HERE TO SEND CHARACTERS FROM THE LOGIN STRING

AUXCHR:	PUSHJ	P,CLSCHR
	  POPJ	P,		;NO ROOM
	MOVSI	P3,TYPI TYPAXC
	MOVE	T1,AUXPRT
	DPB	T1,WRPLIN	;SET UP TO SEND
AXCLP1:	MOVE	T2,MXMCNT	;SPACE LEFT
	ADDI	T2,2
	LSH	T2,-2
AUXCLP:	ILDB	T1,AUXSTP
	JUMPE	T1,AXCDON	;FINISHED
	DPB	T1,WRPCHR
	MOVEM	P3,ORING(P4)	;PUT IN RING
	PUSHJ	P,ORPLOG	;Put message into ORING log
	SOJLE	T2,AXCLP2	;RAN OUT OF ROOM
	 AOJA	P4,AUXCLP	;ADVANCE POINTER AND CONTINUE

AXCLP2:	ADDI	P4,1		;ADVANCE POINTER
	ANDI	P4,MSKORG
	MOVE	T1,AUXSTP
	ILDB	T1,T1		;GET NEXT CHARACTER
	JUMPE	T1,AXCDON	;HAVE REALLY SENT THEM ALL
	MOVEM	P4,ORPPDP	;SAVE POINTER FOR 620
	PUSHJ P,SETOUT
	  POPJ	P,		;OUT OF ROOM
	JRST	AXCLP1		;MORE ROOM, SEND MORE

AXCDON:	MOVEM	P4,ORPPDP
	MOVE	T1,AUXTMP
	MOVEM	T1,AUXTIM	;SET TIMER
	AOS	AUXSTA		;STATE:=.ASWPT (WAIT FOR PORT RESPONSE)
	PJRST	SETOUT		;RESET ROOM COUNTERS AND EXIT

;HERE ON ANY TIMEOUT

AUXTOV:	AOS	(P)		;SET FOR SKIP RETURN
	MOVE	T1,AUXSTA
	XCT	AXTOTB(T1)	;RESPOND ACCORDING TO WHAT GOT TIMED-OUT

AXTOTB:	 STOPCD			;.ASIDL  CAN'T TIME OUT
	 STOPCD			;.ASRQ1  CAN'T TIME OUT
	JRST	AXNRR		;.ASWT1  1ST REQUEST TIMED OUT
	 STOPCD			;.ASRQ2  CAN'T TIME OUT
	JRST	AXNRR		;.ASWT2  2ND RESPONSE TIMED OUT
	 STOPCD			;.ASLOG  CAN'T TIME OUT
	JRST	AXNRL		;.ASWPT  PORT RESPONSE TIMED OUT
	JRST	AXNRL		;.ASWTP  PORT RESPONSE TIMED OUT (BAD RCVAUX)

AXNRR:	MOVSI	T1,CXNRR%	;SET ERROR CODE
	PJRST	ERRXIT

AXNRL:	MOVSI	T1,CXNRL%
	PJRST	ERRXIT
SUBTTL	CODE TO HANDLE THE CREAT AUX CIR UUO
;Call:	MOVEI	AC,[ASCIZ/USERNAME:HOST/]
;	HRLI	AC,FLAGS	;Bits 1-2 are DR # on KS, Bit 17 is NOZAP,
;				;Bits 1-16 are for NETID (new in P035/D07)
;	CREAUX	AC,		;CALLI AC,-144
;	  error return

IFCPU(<KI,KL>),<CXDTP==0>	;Use port 0 for detached jobs
IFCPU(<KS,F3>),<CXDTP==1>	;Always user port 001 (or 101 or 201 or 301)

CREAUX::AOSE	AXREQ
	 PUSHJ	P,AXWAIT	;WAIT FOR RESOURCE
	SETZM	AXSWT
	MOVEI	T2,AXGIV
	MOVEM	T2,JBTABT(J)	;SET ERROR LOCATION
	SETZM	AUXERR		;NO ERROR YET
	SETOM	AUXRCP		;AND NO PORT
	HRRZ	F,TTYTAB(J)
	JUMPE	F,AUXDET	;IF NO JOB (!)
	HRRZ	U,DDBLDB(F)
	JUMPE	U,AUXDET	;OR NOT ATTACHED
	MOVSI	T2,LDLPTY
	TDNE	T2,LDBDCH(U)	;OR CONTROLLED BY A PTY,
	 JRST	AUXDET
IFNKMC<
	LDB	U,LDPLNO	; Use CMD port as index!!
	SKIPA			;  ** not done if KMC **
> ; End IFNKMC
AUXDET:	MOVEI	U,CXDTP		;  FAKE A PORT NUMBER
	MOVEM	U,AUXPRT	;Send to SUP on this port number
	MOVEM	J,AUXJOB	;SET JOB NUMBER
	MOVE	P1,T1		;SAVE ARGUMENT
	HRLI	T1,(POINT 7,0)	;GET POINTER TO THE STRING
	MOVE	P4,[POINT 7,AUXSTR]	;SET TO SAVE IT
	MOVEI	P3,AUXSTM	;MAX WE CAN HAVE
	MOVE	T4,[POINT 6,AUXUNM]	;SET TO ACCUMULATE A USER NAME
	MOVEI	P2,^D12		;MAX CHRS IN USER NAME
	SETZM	AUXUNM
	SETZM	AUXUNM+1
	SETZM	AUXSTR		;Clear out accumulated string
	MOVE	T2,[AUXSTR,,AUXSTR+1]
	BLT	T2,AUXSTR+AUXSTL-1

AUXSLP:	XCTFU	<ILDB	T2,T1>	;GET 7-BIT CHAR FROM USER
	JUMPE	T2,AXSFN1	;END OF STRING
	IDPB	T2,P4		;PUT IT AWAY
	CAIE	T2,15
	CAIN	T2,";"		;TERMINATE ON RETURN OR ;
	 JRST	AXSFIN
	CAIN	T2,":"		;TERMINATE USER NAME ON :
	 SETZ	P2,0		;BY ZAPPING COUNT
	SUBI	T2,40		;CONVERT TO SIXBIT
	JUMPL	T2,AUXNSB	;Don't put control chars in username
	SOJL	P2,AUXNSB	;ALREADY TOO MANY CHRS IN USER NAME
	IDPB	T2,T4		;AND SAVE IT
AUXNSB:	SOJG	P3,AUXSLP	;SEE IF ROOM FOR MORE

AXSFN1:	MOVEI	T2,15
	IDPB	T2,P4		;TOO MANY, FINISH WITH RETURN
AXSFIN:	MOVEI	T2,0
	IDPB	T2,P4		;TERMINATE STRING WITH 0
	HRRZM   P4,AUXEND	;SAVE POINTER TO LAST WORD OF LOGIN STRING
	HRRZ    T3,P4           ;ZERO OUT LAST WORD OF LOGIN
	IDPB    T2,P4           ; STRING TO RIGHT OF NULL
	CAIN    T3,(P4)         ; SO THAT CREAUX STREAM
	 JRST	.-2             ; RECORDS LOOK GOOD
	MOVSI	T2,LICAC
	TDNE	T2,JBTLIC(J)	;SEE IF HE HAS LICENSE
	 JRST	AUXLIC		;YES
	MOVE	T2,AUXUNM
	MOVE	T3,AUXUNM+1
	CAMN	T2,JBTUNM(J)	;CHECK USER NAME MATCH
	CAME	T3,JBTUN1(J)
	 JRST	[MOVSI T2,CXLOG%
		JRST AXERGV]	;ERROR
	PUSHJ	P,FRSTTY	;NOW SEE HOW MANY CIRCUITS
	  JRST	AUXLIC
	PUSHJ	P,NXTTTY
	  JRST	AUXLIC		;NONE
	PUSHJ	P,NXTTTY
	  JRST	AUXLIC		;ONE
	MOVSI	T2,CX2AX%
	JRST	AXERGV		;ERROR, already have 2 circuits in use
AUXLIC:
IFKMC<
	LDB	T3,[POINT 2,P1,2]	;GET TYMBASE NUMBER
	PUSHJ	P,KMCGUP	;T1/ TYMBASE "UP" BITS
	MOVSI	T2,^D8		;TYMBASE DOWN MESSAGE
	XCT	TSTDRU(T3)	;SKIP IF IT'S UP
	  JRST	AXERGV		;ELSE RETURN TYMBASE DOWN MESSAGE
	JRST	AUXDRU

TSTDRU:	TRZN	T1,DR1BIT
	TRZN	T1,DR2BIT
	TRZN	T1,DR3BIT
	TRZN	T1,DR4BIT

AUXDRU:	LSH	T3,6		;Request circuit on DR# * 64.
	IORM	T3,AUXPRT
> ; END IFKMC
IFNKMC<	LDB	T1,[POINT 16,P1,16]	;All but 1B0 and 1B17
	HRLM	T1,AUXPRT	;Store NETID number
	JUMPE	T1,AUXDRU	;OK if asking for default
	MOVSI	T2,^D8		;TYMBASE DOWN = illegal NETID
	MOVSI	T1,LICWCR	;Must have WRITE CORE to build an
	TDNN	T1,JBTLIC(J)	; aux circuit to other net
	 JRST	AXERGV		;(error code 8 means problems with LH of AC)
AUXDRU: > ;END IFNKMC
	MOVEI	T1,MLOWQ
	DPB	T1,PJBSTS##
	AOS	AUXSTA		;SET STATE TO 1
	PUSHJ	P,WSCHED	;AND RESCHEDULE
	SKIPE	T2,AUXERR	;ANY ERRORS
	 JRST	AXERGV
	SKIPGE	AUXRCP	;PORT THERE?
	 JRST	[
		AOS	NRPCNT	;BUMP COUNT
		MOVSI	T2, CXNCH%
		JRST	AXERGV	;ERROR-RETURN
	]
	HRRZ	T1,TTYTAB(J)	;WHERE TO LINK. REALLY SHOULD BE A DDB
	SKIPE	T1
	 PUSHJ	P,DDBSR1
	  JRST	[MOVSI T2,CXDCB%	;NO DDB SPACE
		JRST AXERGV]
	DPB	J,PJOBN
	MOVEI	T1,ASSCON
	TLNE	P1,(1B17)
	 TLO	T1,DVNZP	;SET NO ZAP BIT
	IORM	T1,DEVMOD(F)
	MOVE	U,AUXRCP
	LDB	T1,LDPLNO	;GET LINE NUMBER
	UMOVEM	T1,(W)
	HRRM	U,DDBLDB(F)
	HRRM	F,LDBDDB(U)
	PUSHJ	P,SCNNAM
	MOVEI	T1,22		;WRITE CREAUX
	PUSHJ	P,ACTWRT##	; STREAM RECORD
	AOS	(P)
	JRST	AUXGV1		;FINISHED
AXERGV:	UMOVEM	T2,(W)
AXELOG:	JRST	AXGIV		;JFCL IF WANT ACT REC FOR ERRS
	MOVEM	T2,AUXERR	;SAVE ERR TYPE FOR ACTSER
	MOVEI	T1,22		;CREAUX REC TYPE
	HLRZS	T2		;WRITE REC ONLY
	SKIPE	T2		; FOR EXTRA
	CAIN	T2,CXNCH%	; HOST ERRORS
	 PUSHJ	P,ACTWRT##
AXGIV:	SKIPL	U,AUXRCP
	 PUSHJ	P,TTYZAP
AUXGV1:	SETZM	JBTABT(J)
	SETZM	AUXSTA
	SOSL	AXREQ
	 SETOM	AXAVAL
	POPJ	P,
SUBTTL	READ INFO ON PORTS IN USE

AUXRED::MOVEI	T2,0		;NUMBER OF PORTS SO FAR
	JUMPGE	T1,[XCTTU <SETOM (W)>
		POPJ P,]	;FLAG ERROR
	AOBJN	T1,.+1
	PUSHJ	P,FRSTTY	;THIS WILL GET COMMAND PORT
	  JRST	AUXRN1		;OH WELL
	MOVSI	T4,DVTTY	;TO TEST FOR TTY
AUXRL1:	PUSHJ	P,NXTTTY	;NEXT IN CHAIN
	   JRST	AUXRN1		;FINISHED
	TDNN	T4,DEVMOD(F)
	 JRST	AUXRL1		;IGNORE ALL BUT TTYS
	HRRZ	U,DDBLDB(F)	;GET LINE
	JUMPE	U,AUXRL1	;IGNORE IF NO LINE
	JUMPGE	T1,AUXRL2	;NO ROOM TO PUT IT
	LDB	T3,LDPLNO
	UMOVEM	T3,-1(T1)
	AOBJN	T1,.+1
AUXRL2:	AOJA	T2,AUXRL1	;COUNT 1
AUXRN1:	XCTTU	<SETOM -1(T1)>	;FLAG END OF LIST
	UMOVEM	T2,(W)
	JRST	CPOPJ1		;FINISHED

;ZAP AUX CIRCUITS

ZAPCIR::JUMPL	T1,ZAPALL	;ALL OF THEM
	MOVE	F,T1
	PUSHJ	P,FNDPRT	;FIND THE PORT
	  POPJ	P,		;NOT THERE
	HRRZ	U,DDBLDB(F)
	JUMPE	U,CPOPJ		;NO LINE, IGNORE
	SETZ	T1,		;Don't cause any confusion
	JRST	HNGPRT		;GO HANG HIM

ZAPALL:	PUSHJ	P,FRSTTY
	  POPJ	P,		;NOT COMMAND
ZAPAL1:	PUSHJ	P,NXTTTY
	  POPJ	P,		;DONE
	MOVSI	T1,DVTTY
	TDNN	T1,DEVMOD(F)
	 JRST	ZAPAL1		;NOT A TTY
	HRRZ	U,DDBLDB(F)
	JUMPE	U,ZAPAL1
	SETZ	T1,
	PUSHJ	P,HNGPRT
	JRST	ZAPAL1		;ON TO NEXT
SUBTTL  POLL PORTS UUO

; POLPRT - POLL PORTS FOR INTERRUPT-CAUSING EVENTS
;
;	MOVE	AC, [BITS,,ADDR]
;	POLPRT	AC,
;	  ERROR RETURN (TABLE TOO SMALL)
;	NORMAL RETURN
;
;	(AC/ # OF PORTS RETURNED ON EITHER RETURN)
;
; ADDR:	WORD COUNT (# WORDS, INCLUDING THIS ONE)
;	BITS,,PORT (SET BY UUO)
;	...
;
; WHERE <BITS> IS A MASK FOR THE EVENT BITS IN RH(LDBDCX)

POLPRT::XCTFU	<MOVN T2, (T1)>
	MOVSS	T2
	HRR	T2, T1		; T2/ AOBJN POINTER
	SETZ	T4,		; T4/ COUNT OF PORTS RETURNED
	PUSHJ	P, FRSTTY
	  JRST POLPT4

	; GOT A PORT
POLPT1:	MOVE	T3, DEVMOD(F)
	TLNE	T3, DVTTY
	SKIPN	U, DDBLDB(F)
	JRST	POLPT3		; NOT TTY OR NO LDB

	; CHECK THE EVENTS FOR THIS PORT
	HLRZ	T3, T1		; T3/ 0,,MASK BITS
	AND	T3, LDBDCX(U)	; T3/ 0,,MASKED EVENTS
	ANDCAM	T3, LDBDCX(U)	; TURN OFF WHAT WE'VE READ
	JUMPE	T3, POLPT3	; NOTHING HAPPENED: TRY NEXT PT
	AOBJP	T2, POLPT5	; NO ROOM: ERROR-RETURN
	AOS	T4		; T4/ COUNT OF PORTS RETURNED
	XCTBU	<HRLM T3, (T2)>	; STORE THE EVENT BITS
	LDB	T3, LDPLNO
	XCTBU	<HRRM T3, (T2)>	; AND THE PORT NUMBER

	; GET ANOTHER PORT
POLPT3:	PUSHJ	P, NXTTTY
	  JRST POLPT4
	JRST	POLPT1
POLPT4:	AOS	(P)		; NORMAL RETURN: PORTS EXHAUSTED
POLPT5:	UMOVEM	T4, (W)		; AC := COUNT OF PORTS RETURNED
	POPJ	P,
SUBTTL BLOCK INPUT/OUTPUT (BIO) ROUTINES

;THE FORMAT OF A BLOCK I/O BUFFER IS:

BIOLNK==0	;PTR TO LINKED LIST OF BIO BUFFERS.
BIOCSH==1	;CACHE SWEEP NUMBER AT TIME REQUEST WAS QUEUED.
BIOPBP==2	;PTY BLOCK I/O: ILDB/IDPB POINTER FOR NEXT BYTE
BIOPBC==3	;PTY BLOCK I/O: # BYTES LEFT TO TRANSFER
BIOREQ==4	;CHAR COUNT OF LAST INPUT REQUEST BY THIS PORT.
BIOCHR==5	;COUNT OF CHARACTERS TO TRANSFER. (IN OR OUT).
BIODAT==6	;BEGINNING OF USER DATA.

;HERE FROM ENABLE BLOCK I/O AUXCAL

BLKIO:	MOVSI	T1,LMLBIO
	TDNE	T1,LDBMOD(U)	;IF ALREADY IN BLOCK MODE,
	 POPJ	P,		;  ERROR-RETURN
	SKIPN	T3,LDBBIO(U)	;DOES THE BIO PORT HAVE ANY
	 JRST	BLKIO2		;ACTIVE BUFFERS?
	HLRZ	T1,T3		;YES.  OUTPUT ACTIVE?
	JUMPE	T1,BLKIO1	;NO - GO CHECK FOR INPUT.
	PUSHJ	P,OQUEUE	;YES. QUEUE JOB UNTIL DONE.
	  POPJ	P,		;LINE IS GONE.  HE LOSES.
	JRST BLKIO

BLKIO1:	HRRZ	T1,T3		;INPUT BUFFER ACTIVE?
	SKIPE	T1		;
	 PUSHJ	P,IQUEUE	;YES. WAIT FOR CH7 TO RELEASE IT
	  POPJ P,		;NO.  DON'T WORRY ABOUT IT.
	JRST BLKIO

;HERE IF NO ACTIVE BUFFERS
BLKIO2:	PUSHJ	P,INCBC		;SET UP FOR 1 MORE JOB. IF CAN'T,
	  POPJ	P,		;  NONSKIP-RETURN
	MOVSI	T1,LMLBIO	;SET FLAG IN THE LDB INDICATING
	IORM	T1,LDBMOD(U)	;PORT IS IN BIO MODE.
	AOS	(P)		;MADE IT!  SKIP RETURN TO USER
	POPJ	P,
SUBTTL	BLKXIO - HERE FROM THE LEAVE BLOCK MODE AUXCAL

BLKXIO:	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO	;IF PORT'S NOT IN BLOCK MODE,
	 POPJ	P,		;  JUST RETURN
	SKIPN	T3,LDBBIO(U)	;IF THERE'S NOTHING IN PROGRESS,
	 JRST	BIORES		;  GET OUT NOW
	HLRZ	T1,T3
	JUMPE	T1,BLKX1	;IF THERE'S OUTPUT IN PROGRESS,
	PUSHJ	P,OQUEUE	;  WAIT FOR IT. IF ZAPPED,
	  POPJ	P,		;    JUST RETURN
	JRST	BLKXIO

    ;HERE FROM BLKXIO AND BIOREL - TERMINATE/DISCARD CURRENT BLK INPUT

BLKX1:	HRRZ	T1,T3
	JUMPE	T1,BLKX2	;IF THERE'S INPUT IN PROGRESS,
	PUSHJ	P,BLKXIN	;  REQUEST INPUT TERMINATION
	HRRZ	T1,LDBBIO(U)
	SKIPL	BIOCHR(T1)	;  IF THE BASE IS DONE WITH THE BUFFER,
	 PUSHJ	P,RELBI		;    THROW IT AWAY NOW
BLKX2:	SKIPN	LDBBIO(U)	;IF NO BUFFERS,
	 PJRST	BIORES		;  GET OUT NOW
	MOVSI	T1,LMLBIO
	ANDCAM	T1,LDBMOD(U)	;ELSE, CLEAR THE BLOCK MODE BIT
	POPJ	P,		;  CH7 WILL DO THE REST

;BIOREL - HERE FROM RESET UUO FOR EACH PORT IN BLOCK MODE
;	   TERMINATE BLOCK INPUT AND OUTPUT

BIOREL:	SKIPN	T3,LDBBIO(U)	;IF NO ACTIVE I OR O,
	 PJRST	BIORES		;  GET OUT NOW
	HLRZ	T1,T3
	JUMPE	T1,BLKX1	;IF OUTPUT ACTIVE,
	PUSHJ	P,BLKXOT	;  REQUEST OUTPUT TERMINATION
	JRST	BLKX1
SUBTTL	BIOZAP - CALLED WHEN A CIRCUIT IN BLOCK MODE IS ZAPPED

BIOZAP:	MOVSI	T1,LMLTBI
	ANDCAM	T1,LDBMOD(U)	;CLEAR "TERMINATE PENDING" FLAG
	DPB	T1,LOPBOP	;Clear PTY "Block-output-in-progress"
	PUSHJ	P,RELBI		;MUST BE DONE WITH INPUT
	PUSHJ	P,RELBO		;MUST BE DONE WITH OUTPUT
	PFALL	BIORES		;MUST BE DONE WITH BLOCK I/O

;BIORES - CLEAR BLKIO BIT AND FLAG NEGOTIATOR THAT WE'RE DONE

BIORES:	MOVSI	T1,LMLBIO	;TAKE PORT OUT OF BLKIO MODE
	ANDCAM	T1,LDBMOD(U)	;
	PJRST	DECBC		;ONE FEWER PORT DOING BLOCK I/O
SUBTTL	 BLKINP - BLOCK INPUT-AND-WAIT AUXCAL

BLKINP:	PUSHJ	P,BIOCHK	; EVERYTHING OK?
	  POPJ	P,		; NO
	HRRZ	T1,LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	JUMPE	T1,[		; NO INPUT BUFFER
		TLNE	S,IOEND		; IOEND SET?
		 JRST	BLKEOF		; RETURN EOF
		MOVE	T2,LDBMOD(U)
		TLNE	T2,LMLTBI	; TERMINATE PENDING?
		 JRST	BLKIP1		; WAIT FOR IT
		PUSHJ	P,REQBUF	; GET BUF & REQ. INPUT
		  POPJ	P,		; FAILED (PORT ZAPPED)
		JRST	BLKIP1		; MADE REQ.: NOW WAIT
	]
	MOVE	T2,BIOCHR(T1)	; T2/ IN-PROGRESS FLAG,,COUNT
	JUMPL	T2,BLKIP1	; IN-PROGRESS: WAIT FOR IT
	PUSHJ	P,GOTBUF	; COMPLETE: TRANSFER DATA
	  JFCL			; COUNT=0
	JRST	CPOPJ1		; OR COUNT .gt. 0: SKIP-RETURN

    ; HERE TO WAIT FOR "BLOCK INPUT TERMINATED" MESSAGE
    ; OF SOME SORT

BLKIP1:	PUSHJ	P,IQUEUE
	  POPJ	P,		; PORT GONE
	JRST	BLKINP		; RETRY
SUBTTL	 BLKINS - BLOCK INPUT-AND-SKIP AUXCAL

BLKINS:	PUSHJ	P,BIOCHK	; EVERYTHING OK?
	  POPJ	P,		; NO
	HRRZ	T1,LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	JUMPE	T1,[		; NO INPUT BUFFER
		TLNE	S,IOEND		; IOEND SET?
		 JRST	BLKEOF		; RETURN EOF
		MOVE	T2,LDBMOD(U)
		TLNE	T2,LMLTBI	; TERMINATE PENDING?
		 POPJ	P,		; NONSKIP-RETURN
		PUSHJ	P,REQBUF	; GET BUF & REQ. INPUT
		  POPJ	P,		; FAILED (PORT ZAPPED)
		POPJ	P,		; MADE REQ.: NOW RETURN
	]
	MOVE	T2,BIOCHR(T1)	; T2/ IN-PROGRESS FLAG,,COUNT
	JUMPL	T2,CPOPJ	; IN-PROGRESS: NONSKIP-RETURN
	PUSHJ	P,GOTBUF	; INPUT COMPLETE: TRANSFER DATA
	  POPJ	P,		; COUNT=0: NONSKIP-RETURN
	JRST	CPOPJ1		; COUNT.gt.0: SKIP-RETURN

; BLKEOF - COMMON CODE TO SET IO.END
;	    FOR BLOCK INPUT AUXCALS

BLKEOF:	XOR	S,[IOEND,,IODEND]
	MOVEM	S,DEVIOS(F)	; SET IO.EOF, CLEAR IOEND
	AOS	(P)
	PJRST	RELBI		; DONE WITH INPUT BUFFER
SUBTTL	 BIOCHK - COMMON SETUP CODE FOR BLOCK INPUT AUXCALS

BIOCHK:	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO	; BLOCK I/O ENABLED?
	 POPJ	P,		; NO -- FAIL
	TRNE	S,IODEND	; IO.EOF SET?
	 POPJ	P,		; YES -- FAIL
	PUSHJ	P,BPXOFF	; IS THIS NECESSARY?
	NOCHARGE		; TURN OFF THE CLOCK
	JRST	CPOPJ1		; SUCCEED

; GOTBUF - COMMON BUFFER-TRANSFER CODE FOR BLOCK INPUT AUXCALS
;	    ENTER WITH T1/ INPUT BUFFER ADDRESS
;		       T2/ CHARACTER COUNT

GOTBUF:
	PUSH	P,P1		;Needed in one irritating place
	PUSH	P,T2		; SAVE CHARACTER COUNT
	ADDM	T2,JBTBIO(J)	; CHARGE JOB FOR CHARACTERS
	ADDM	T2,JBTBIO	; RECORD TOTAL CHARACTERS
	ADDI	T2,3
	LSH	T2,-2		; T2/ # OF WORDS
	HRLI	T3,BIOCHR(T1)	; T3/ START OF MON DATA,,
	HRR	T3,M		; T3/ ",,START OF USER BUFFER
IFNKMC<
	ADDI	T2,(T3)		; T2/ STOP LOCATION
	XCTTU <BLT T3,(T2)>	; TRANSFER THE COUNT&DATA
>;END IFNKMC
IFKMC<
	;T2/# OF WORDS
	;T3/MONITOR BUFFER,,USER BUFFER
	PUSH	P,T1		;SAVE T1
	PUSH	P,T4		;TO HOLD DESTINATION BYTEPOINTER
	LSH	T2,1		;T2/# OF HALF WORDS
	HRRZ	T4,T3		;T4/0,,USER BUFFER
	HLRZ	T3,T3		;T3/0,,MONITOR BUFFER
	MOVE	T1,(T3)		;GET FIRST WORD FOR USER BUFFER
	XCT 4,[MOVEM T1,(T4)]	;PUT IT IN USER BUF
	ADDI	T4,1
	ADDI	T3,1
	HRLI	T3,(POINT 18,0)	;PACK HALFWORD BYTES INTO
	HRLI	T4,(POINT 16,0)	;	FULLWORD BYTES
GBXLUP:	ILDB	T1,T3		;GET MONITOR HALF WORD
	XCT	1,[IDPB T1,T4]	;PUT TWO BYTES IN USER BUF
	SOJG	T2,GBXLUP
	POP	P,T4		;RESTORE THEM REGISTERS
	POP	P,T1		;RESTORE T1
>;END IFKMC
	MOVE	T2,LDBMOD(U)
	TLNN	T2,LMLTBI	; TERMINATE-INPUT PENDING?
	TLNE	S,IOEND		; IOEND SET?
	 JRST	[
		PUSHJ	P,RELBI		; DONE WITH INPUT BUFFER
		JRST	GOTBF1		; GO FINISH UP
	]
	PUSHJ	P,KEPBI		; IF SOMEONE ELSE WANTS A BUFFER,
	  SKIPA			;By all means let 'em have it
	 JRST	GOTBF0		;No competition
	MOVE	P1,BIOREQ(T1)	;Save count in a safe place (!)
	PUSHJ	P,RELBI		;Give up the buffer/port
	PUSHJ	P,GETBI		;Get a new one
	  JRST	GOTBF1		;Not needed...
	MOVEM	P1,BIOREQ(T1)	;Set count in new buffer
GOTBF0:
	MOVE	T2,BIOREQ(T1)	; T2/ OLD REQUEST COUNT
	PUSHJ	P,BLKIRQ	; REQUEST INPUT
GOTBF1:	POP	P,T1		; T1/ COUNT BLT'ED
	POP	P,P1		;Remember him?
	JUMPN	T1,CPOPJ1	; SKIP IF .GT. 0
	POPJ	P,
SUBTTL	 REQBUF - ALLOCATE A BUFFER FOR BLOCK INPUT
;	    STORE ITS ADDRESS IN RH(LDBBIO(U))
;	    SAVE THE USER'S BYTE COUNT IN BIOREQ(RH(LDBBIO(U)))
;	    AND SEND AN INPUT REQUEST
;	    SKIP-RETURN NORMALLY
;	    NONSKIP-RETURN IF ZAPPED WHILE IN "EXTRA" WAIT

REQBUF:	PUSHJ	P,GETBI		; SET UP FOR BLOCK INPUT
	  POPJ	P,		; FAILED (ZAPPED)

	; SUCCEEDED: T1/ INPUT BUFFER ADDRESS

	XCTFU <HRRZ T2, (M)>	; T2/ USER'S BYTE COUNT
	CAILE	T2, ^D400
	MOVEI	T2, ^D400	; T2/ USER'S COUNT .MIN. 400
	MOVEM	T2, BIOREQ(T1)	; SAVE FOR READAHEAD CODE
	AOS	(P)		; PREPARE FOR SKIP-RETURN
	PJRST	BLKIRQ		; REQUEST INPUT

; BLKIRQ - REQUEST BLOCK INPUT
;	    ENTER WITH T1/ BUFFER ADDRESS
;		       T2/ CHARACTER COUNT

BLKIRQ:
IFCPU (KL),<
	MOVE	T3,CSUCNT##	;WHEN I/O STARTS, SWEEP NUMBER
				;MUST BE DIFFERENT THAN THIS.
	MOVEM	T3,BIOCSH(T1)>
	MOVE	T3,LDBMOD(U)
	TLNE	T3,LMLTBI	; TERMINATE PENDING?
	 STOPCD			; IMPOSSIBLE!
	HRROM	T2,BIOCHR(T1)	; IN-PROG := -1, COUNT := T2.RH
	MOVEI	T1,1
	DPB	T1,LOPBIN	;SET BLOCK INPUT
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,
SUBTTL	BLKOUT - HERE FROM BLOCK OUTPUT AUXCAL.  SKIPS ON SUCCESS.

BLKOUT:	MOVE T1,LDBMOD(U)	;TEST TO SEE IF BLOCK I/O
	TLNN T1,LMLBIO		;MODE HAS BEEN SET.
	 POPJ P,		;ERROR RETURN IF NOT.
	NOCHARGE		;TURN OFF THE CLOCK.
	HLRZ T1,LDBBIO(U)	;IS THERE A BLOCK OUTPUT
	JUMPE T1,BLKOT1		; ALREADY IN PROGRESS?
	PUSHJ P,OQUEUE		;I/O WAIT OR INTERRUPT
	 POPJ P,		;NO.  ERROR RETURN TO THE USER.
	JRST BLKOUT		;MAKE SURE BUFFER WAS RELEASED.
BLKOT1:	PUSHJ	P, GETBO	;SET UP FOR BLOCK OUTPUT
	  POPJ	P,		;  ZAPPED
	XCTBU <HRRZ T2,(M)>	;GET USER'S WORD COUNT
	CAIG	T2,^D400	;IF < 0 OR > 400
	SKIPN	T2		;OR = 0
	 PJRST	RELBO		;  GET OUT AND ERROR-RETURN
	CAILE T2,^D80		;MIN. NO. OF CHARS FOR CHARGING
	 SKIPA T3,T2		;PURPOSES IS EIGHTY.
	MOVEI T3,^D80
	ADDM T3,JBTBIO(J)	;ADD TO BIO CHRS XFER'D FOR JOB.
	ADDM T3,JBTBIO		;ADD TO TOTAL BIO CHARS XFERRED.
	ADDI T2,3
	LSH T2,-2
	XCTBU <MOVSI T3,(M)>	;GET ADDRESS OF USER BUFFER
	HRRI T3,BIOCHR(T1)	;PREPARE FOR BLT TO MONITOR
IFNKMC<
	ADDI T2,BIOCHR(T1)	;ADD IN BASE LOC FOR XFER
	XCTFU <BLT T3,(T2)>	;BUFFER.
IFCPU (KL),<
	MOVE	T2,CSVCNT##	;MUST DO ONE VALIDATE BEFORE CAN START
	MOVEM	T2,BIOCSH(T1)>	;I/O.
>;END IFNKMC
IFKMC<
	;T2/# OF WORDS
	;T3/USER BUFFER,,MONITOR BUFFER
	PUSH	P,T4		;TO HOLD DESTINATION BYTEPOINTER
	LSH	T2,1		;T2/# OF HALF WORDS
	HRRZ	T4,T3		;T4/0,,MONITOR BUFFER
	HLRZ	T3,T3		;T3/0,,USER BUFFER
	XCT	4,[MOVE T1,(T3)]	;GET FIRST WORD OF USER BUFFER
	MOVEM	T1,(T4)		;PUT IT IN MON BUF
	ADDI T4,1
	ADDI T3,1
	HRLI	T3,(POINT 16,0)	;UNPACK FULLWORD BYTES INTO
	HRLI	T4,(POINT 18,0)	;		HALFWORD BYTES
XCTLUP:	XCT 1,[ILDB T1,T3]	;GET TW0 USER BYTES
	IDPB	T1,T4
	SOJG	T2,XCTLUP
	POP	P,T4		;RESTORE THEM REGISTERS
>;END IFKMC
	MOVEI T1,1
	DPB T1,LOPBOT		;SET BLOCK OUTPUT
	DPB T1,LDBOPB(U)	;AND NEED-OUTPUT
	JRST CPOPJ1		;AND SUCCESS-RETURN
COMMENT %

There are (presently) three block i/o mechanisms, one for
620 bases, one for PTYs, and one, as yet uncoded, for Nexilis
bases. For the sake of everyone's sanity, there must be a
level in the block i/o code at which the distinction between
these three becomes invisible.

In particular, the UUOs should use only the following routines,
which will acquire and release the appropriate resources
regardless of the mechanism being used:

	GETBI	sets up a port to do block input
	RELBI	called when a port's done with block input
	KEPBI	skips if it's ok for this port to keep
		its block-input resources; if it nonskips,
		caller should do a RELBI/GETBI sequence
	GETBO	sets up a port for block output
	RELBO	called when a port's done with block output
	INCBC	enables the block i/o mechanism for 1 more
		job (1 more PDP10 port), and skip-returns
		if 1 more is ok
	DECBC	called when a port is disabled for block i/o

%
SUBTTL	INCBC - CALLED WHEN 1 MORE PORT IS TO BE ENABLED FOR BLOCK I/O
;	  SKIP-RETURNS IF 1 MORE IS OK
;	  CALLED WITH U/ LDB ADDR, J/ JOB #

INCBC:	HLL	U, LDBDCH(U)
	TLNE	U, LDLPTY	;IF IT'S A PTY,
	JRST	INCPBC		;  THINGS ARE SIMPLER

    ;HERE FOR REAL TTYS

	NOCHARGE		;TURN OFF THE CLOCK.
IFCPU (<KI,KL>), <
	AOSE	AXREQ		;INC REQUEST COUNT FOR AUX QUEUE
	 PUSHJ	P,AXWAIT	;QUEUE JOB IF REQ IN PROGRESS
	AOS	BIOCNT+0	;INCREMENT COUNT OF BIO JOBS
	HRROS	BIOCNT+0	;FLAG FOR CH7 TO SEND REQUEST.
	MOVEM	J,BIOJOB	;BIOJOB_JOB NO W REQ IN PROGRESS
	MOVEI	T1,MLOWQ	;PLACE THIS JOB IN THE ML QUEUE
	DPB	T1,PJBSTS##	;AND WAIT UNTIL AN ANSWER IS
	PUSHJ	P,WSCHED	;RECEIVED FROM THE BASE.
	SKIPLE	BIOPRT		;IF THERE'S AT LEAST ONE SLOT,
	 AOS	(P)		;  SET TO SKIP-RETURN
	SOSL	AXREQ
	 SETOM	AXAVAL
	POPJ	P,
> ;END IFCPU (<KI,KL>)
IFNCPU (<KI,KL>), <
	AOS	BIOCNT		;ONE MORE BIO JOB
	SOSL	BPREQ		;AND ONE MORE BUFFER
	 SETOM	BPAVAL		;ACTIVATE JOB WAITING FOR A BUFFER
	JRST	CPOPJ1
> ;END IFNCPU (<KI,KL>)

    ;HERE FOR PTYS

INCPBC:	AOS	BIOCNT+1	;1 MORE BLOCK-MODE PTY
	JRST	CPOPJ1		;SKIP-RETURN
SUBTTL	DECBC - CALLED WHEN A PORT HAS BEEN DISABLED FOR BLOCK I/O
;	  AND ALL BLOCK I/O ACTIVITY FOR IT HAS STOPPED
;	  CALLED WITH U/ LDB ADDR

DECBC:	HLL	U,LDBDCH(U)
	TLNE	U,LDLPTY	;IF IT'S A PTY,
	 JRST	DECPBC		;  THINGS ARE A BIT EASIER

    ;HERE FOR A REAL TTY

	HRRE	T1,BIOCNT+0	;T1/ REAL TTY BLOCK I/O USER COUNT
	SOJGE	T1,.+2
	 STOPCD (CPOPJ,INFO,TTYBCN,,<Block I/O count negative>);;DECBC+5
IFCPU (<KI,KL>), <
	HRROM	T1,BIOCNT+0	;BIOCNT+0/ "CHANGED",,NEW COUNT
> ;END IFCPU (<KI,KL>)
IFNCPU (<KI,KL>), <
	MOVEM	T1,BIOCNT+0	;ONE LESS BIO JOB
	AOS	BPREQ		;ONE LESS BUFFER
> ;END IFNCPU (<KI,KL>)
	ADD	T1,BIOCNT+1	;T1/ TOTAL BLOCK USER COUNT
	JRST	DECBC1

    ;HERE FOR A PTY

DECPBC:	SOSGE	T1,BIOCNT+1	;T1/ PTY BLOCK USER COUNT
	 STOPCD (,XCT,TTYBCN)
	HRRE	T2,BIOCNT+0
	ADD	T1,T2		;T1/ TOTAL BLOCK USER COUNT
	PFALL	DECBC1

    ;HERE FOR EITHER - FREE UP UNNECESSARY BUFFERS

DECBC1:	ASH	T1,1		;T1/ MAX # OF BUFFERS NEEDED (2*PORTS)
	SUB	T1,BIOBUF	;T1/ -# OF UNNEEDED BUFFERS IN POOL
	PUSH	P,T1
DECBC2:	AOSLE	(P)
	JRST	DECBC3
	PUSHJ	P,GETBBP	;GET A BUFFER FROM THE BLOCK I/O POOL
	PUSHJ	P,RELBBF	;RELEASE IT TO FREECORE
	JRST	DECBC2
DECBC3:	POP	P,T1
	POPJ	P,
SUBTTL	GETBI - SET UP A PORT FOR BLOCK INPUT
;	  NONSKIP IF LEFT BLOCK MODE
;	  ELSE SKIP WITH T1 AND LDBBIO(U).RH SET TO BUFFER

GETBI:	PUSHJ	P,GETBIO
	  POPJ	P,
	HRRM	T1,LDBBIO(U)
	JRST	CPOPJ1

;GETBO - SET UP A PORT FOR BLOCK OUTPUT

GETBO:	PUSHJ	P,GETBIO
	  POPJ	P,
	HRLM	T1,LDBBIO(U)
	JRST	CPOPJ1

;RELBI - CALLED WHEN A PORT'S DONE WITH BLOCK INPUT
;	  RETURNS T1/ LDBBIO(U)

RELBI:	HRRZ	T1,LDBBIO(U)
	JUMPE	T1,RELB0
	HLLZS	LDBBIO(U)
	PJRST	RELBIO

;RELBO - CALLED WHEN A PORT'S DONE WITH BLOCK OUTPUT
;	  RETURNS T1/ LDBBIO(U)

RELBO:	HLRZ	T1,LDBBIO(U)
	JUMPE	T1,RELB0
	HRRZS	LDBBIO(U)
	PJRST	RELBIO

RELB0:	MOVE	T1,LDBBIO(U)
	POPJ	P,
SUBTTL	KEPBI - SKIP-RETURNS IF IT'S OK FOR THIS PORT (U/ LDB ADDRESS)
;	  TO KEEP ITS BLOCK INPUT RESOURCES, NONSKIPS IF
;	  SOMEBODY ELSE WANTS THEM

KEPBI:	PUSH	P,T1
	MOVSI	T1,LDLPTY
	TDNE	T1,LDBDCH(U)	;IF IT'S NOT A PTY
	 JRST	KEPBI1
	MOVE	T1,LDBBIO(U)
	SKIPLE	BPREQ		;AND SOMEONE'S WAITING FOR PORTS
	 TLNE	T1,777777	;AND WE CAN FREE ONE,
KEPBI1:	SKIPLE	FCREQ		;OR IF SOMEONE'S WAITING FOR FREECORE,
	 JRST	.+2		;  DON'T SKIP
	AOS	-1(P)
	POP	P,T1
	POPJ	P,
SUBTTL	GETBIO - GET A BLOCK I/O BUFFER FOR LINE
;	   NONSKIP-RETURN IF PORT LEFT BIO MODE WHILE WAITING
;	   SKIP-RETURN WITH T1/ THE BUFFER ADDRESS OTHERWISE

GETBIO:	MOVSI	T1,LNLZIN	;Was a zapper seen on this line?
	TDNE	T1,LDBLIN(U)	; ...
	 POPJ	P,		;Pretend there are no more buffers for now
	MOVSI	T1,LDLPTY
	TDNN	T1,LDBDCH(U)	;IF IT'S NOT A PTY
	SKIPE	LDBBIO(U)	;AND THERE'S NO BLOCK I/O IN PROGRESS,
	 JRST	GTBIO1
	AOSLE	BPREQ
	PUSHJ	P,BPWAIT	;  GET A BASE PORT
GTBIO1:	PUSHJ	P,GETBB		;T1/ BUFFER ADDRESS
IFCPU (KL),<;P035/D05 - make sure page containing buffer is uncached.
	PUSH	P,T1		;Save pointer
	HRLI	T1,BIOCOR	;Size of buffer in LH
	PUSHJ	P,CSHCLR##	;Clear cache bit in EPT
	POP	P,T1
>
	MOVE	T2,LDBMOD(U)
	TLNE	T2,LMLBIO	;IF PORT'S STILL IN BLOCK MODE,
	 JRST	CPOPJ1		;  SKIP-RETURN
	PFALL	RELBIO

;RELBIO - RELEASE A BLOCK I/O BUFFER FOR U
;	   CALLED WITH T1/ THE BUFFER ADDRESS
;	   FREES THE PORT IF NO BUFFERS REMAIN
;	   RETURNS T1/ LDBBIO(U)

RELBIO:	PUSHJ	P,RELBB		;FREE THE BUFFER
	MOVSI	T1,LDLPTY
	TDNE	T1,LDBDCH(U)	;IF IT'S NOT A PTY
	 JRST	RLBIO1
	SKIPN	T1,LDBBIO(U)	;AND NO BLOCK I OR O IN PROGRESS,
	SOSL	BPREQ		;  FREE THE BASE PORT
	 SETOM	BPAVAL
	POPJ	P,

RLBIO1:	MOVE	T1, LDBBIO(U)	;T1/ LDBBIO
	POPJ	P,
SUBTTL	GETBB - GET A BLOCK I/O BUFFER AND RETURN ITS ADDRESS IN T1
;GETBBP - GET ONE FROM THE POOL (NOT FREECORE) OR CRASH

GETBB:	SKIPE	BBFREE		;IF NO FREE BLOCK BUFFERS,
	 JRST	GETBB1
	MOVEI	T2,BIOCOR
	SKIPGE	FCREQ		;  GET ANOTHER. IF OTHER JOBS IN FC WAIT
	 PUSHJ	P,GET4WD	;  OR NO FREE CORE,
	  JRST	[
		AOS  FCREQ
		PUSHJ P,FCWAIT
		SOS  FCREQ
		JRST GETBB	;    WAIT, THEN TRY AGAIN
	]
IFKMC<
	PUSH	P,T1		;SAVE UNMAPPED T1
	PUSHJ	P,SCANBB	;RETURNS T2 WITH UBA PAGE # OF T1
	  JRST [CAILE T2,UBAEND-<UBABIO&777> ;GUESS WE DIDN'T MATCH. ANY ROOM LEFT?
		 STOPCD 	;GIVE UP IF NO ROOM.
		HRLI T2,3	;T2/3,,AVAILABLE PAGE #
		LSH T1,-9	;T1/HIGH 11 BITS OF MAPPED ADDRESS
		TRO T1,1B21	;SET VALID BIT
		WRIO T1,UBABIO(T2)
		MOVEM T1,BBPAGE(T2)
		ADDI T1,1	;ALSO INIT NEXT PAGE
		WRIO T1,UBABIO+1(T2)
		MOVEM T1,BBPAGE+1(T2)
		HRRZ T2,T2	;T2/0,,PAGE #
		AOS  BBCRE	;;;COUNT BIO BUFFERS CREATED
		JRST .+1]	;CONTINUE
	LSH	T2,-1		;T2/PAGE PAIR #
	AOS	BBCNTS(T2)	;BUMP THE USE COUNT
	POP	P,T1		;RESTORE UNMAPPED T1
>;END IFKMC
	AOS	BIOBUF		;  1 MORE BUFFER IN POOL
	POPJ	P,		;  RETURN THE BUFFER

    ;HERE IF THERE ARE FREE BUFFERS IN THE BLOCK I/O POOL

GETBBP:	SKIPN	BBFREE
TTYNFB:: STOPCD (.,STOP,TTYNFB,,<No Free Buffrers>)     ;;GETBBP+1
GETBB1:	SOS	BBFREE
	AOS	BBPOOL		;COUNT USE OF FREE BIO BUFFERS
	HRRZ	T1,BUFLST
	SKIPN	T1
	 STOPCD (,XCT,TTYNFB)   ;No Free Buffers        ;;GETBB1+5
	HRRZ	T2,(T1)
	HRRM	T2,BUFLST	;MAKE NEXT-LINK THE NEW HEADER
	POPJ	P,

;RELBB - RELEASE THE BLOCK I/O BUFFER POINTED TO BY T1
;RELBBF - ALWAYS RETURN IT TO FREECORE

RELBB:	SKIPGE	FCREQ		;IF OTHER JOBS ARE WAITING FOR FREECORE,
	 JRST	RELBB1
RELBBF:	SKIPN	T2,T1
	 STOPCD
	SOS	BIOBUF
	MOVEI	T1, BIOCOR
IFKMC<	PUSHJ P,RELKMC>		;RELEASE UBA SLOT
	PJRST	GIV4WD		;  JUST RELEASE THE BUFFER

    ;HERE TO ADD THE BUFFER TO THE BLOCK I/O POOL

RELBB1:	SKIPN	T1
	 STOPCD
	HRRZ	T2,BUFLST	;T2/ HEAD OF FREE CHAIN
	MOVEM	T2,(T1)
	MOVEM	T1,BUFLST	;MAKE T1 THE NEW HEAD
	AOS	BBFREE
	POPJ	P,

IFKMC<
RELKMC:	PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;SAVE UNMAPPED T2
	MOVE	T1,T2		;T1/BUFFER ADDRESS
	PUSHJ	P,SCANBB	;RETURNS T2 WITH UBA PAGE # OF T1
	  STOPCD		;NO MATCH IS BAD NEWS!
	LSH	T2,-1		;T2/PAGE PAIR NUMBER
	SOSN	BBCNTS(T2)	;DEC PAGE PAIR USE COUNT
	 JRST  [LSH T2,1	;;IF COUNT WENT TO 0 RESTORE T2 &
		SETZ T1,	;;INVALIDATE THE PAGE PAIR
		HRLI T2,3	;;UBA #3,,EVEN PAGE #
		WRIO T1,UBABIO(T2)
		WRIO T1,UBABIO+1(T2)
		HRROS BBPAGE(T2)	;;;;DEBUG
		HRROS BBPAGE+1(T2)	;;;;DEBUG CODE
		AOS BBREL		;;;;INFO
		JRST .+1]
	POP	P,T2		;RESTORE UNMAPPED T2
	POP	P,T1		;RESTORE T1
	POPJ	P,		;RETURN


;RETURNS T1 MAPPED
;SKIP RETURNS WHEN T2/0,,MATCHED UBA PAGE
;NON-SKIP RETURNS WITH T2/0,,-1 OR T2/0,,AVAILABLE UBA PAGE #
SCANBB:	MAP	T1,(T1)
	PUSH	P,T1		;SAVE MAPPED T1 FOR RETURN
	PUSH	P,T3
	PUSH	P,T4
	AND	T1,[3777B26]	;MASK OUT ALL BUT HIGH 11 BITS
	TLO	T1,(1B8)	;SET VALID BIT
	MOVEI	T4,-1		;T4/0,,-1
	HRLZI	T2,3		;T2/3,,0
SBBLUP:	RDIO	T3,UBABIO(T2)	;T3/EVEN PAGE # CONTENTS
	AND T3,[<1B8!3777B26>]	;MASK OUT ALL BUT VALID BIT & HIGH 11
	CAMN	T1,T3		;DOES IT MATCH?
	 JRST  [POP P,T4	;IF IT DOES THEN SKIP RETURN
		POP P,T3
		POP P,T1	;RESTORE MAPPED T1
		HRRZ T2,T2	;T2/0,,MATCHED PAGE #
		JRST CPOPJ1	;DO SKIP RETURN
		]
	TLZN	T3,(1B8)	;IS THE VALID BIT ON?
	 MOVEI	T4,(T2)		;T4/0,,LATEST AVAILABLE PAGE #
	ADDI	T2,2		;T2/3,,NEXT PAGE PAIR
	CAMGE	T2,[3,,UBAEND-<UBABIO&777>]	;ARE WE STILL LESS THAN 30?
	 JRST	SBBLUP		;IF SO GO BACK TO SBB LOOP
	MOVE	T2,T4		;T2/0,,-1 OR 0,,AVAILABLE SLOT NUMBER
	POP	P,T4
	POP	P,T3
	POP	P,T1		;RESTORE MAPPED T1
	POPJ	P,		;NON-SKIP RETURN


;MISC KMC RELATED ROUTINES


SCNMIN: PUSHJ	P,MDRUP		;T1/ FLAG DRs WE THINK ARE UP
	MOVEM	T1,DRMBRK	;FLAG TO SEND DR PILLS
	POPJ	P,

SCNDRD:			;WILL SKIP A MINUTE WHEN KMCRES IS CALLED
	SKIPE	T1,DRDOW
	 JRST	SCNMI2		;SET DRMHSI ON 2ND MINUTE
	PUSHJ	P,KMCRST##	;T1/ DOWN DR BITS
	PUSHJ	P,DRFLAG	;T1/ 3-BIT DR NUMBERS NEEDING TYPHSI MSG
	MOVEM	T1,DRDOW	;START DELAY FOR 41 TO NODE(S)
	MOVEI	T1,^D60
	MOVEM	T1,TIMDRD
	POPJ	P,
SCNMI2:	MOVEM	T1,DRMHSI	;SET DRMHSI FLAG WITH DOWN DR NUMBERS
	SETZM	DRDOW		;CLEAR DRDOW
	POPJ	P,		;ACTUAL MESSAGES GET SENT FROM SNDHSI

SNDHSI:	SKIPN	T1,DRMHSI	;T1/DOWN DR NUMBERS
	 JRST	MDRSHT		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMHSI
	MOVSI	P3,TYPI TYPHSI
	PUSHJ	P,MDRMSG	;SEND TO ALL DR NUMs IN T1
	JUMPN	T1,[		;IF NO ROOM IN THE RING TO FINISH THEN
		MOVEM T1,DRMHSI ; SET DRMHSI TO DO THE REST NEXT TIME
		POPJ	P,]   	; AND NON-SKIP RETURN
MDRSHT:	SKIPN	T1,DRMSHT	;T1/DRs THAT NEED A SHUT MESSAGE
	  JRST	MDRBRK		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMSHT
	MOVSI	P3,TYPI TYPSHT
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMSHT	; SET DRMSHT TO DO THE REST NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRBRK:	SKIPN	T1,DRMBRK	;T1/DRs THAT NEED A 57 PILL
	  JRST	MDRCLP		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMBRK
	MOVSI	P3,TYPI TYPBRK	;WE USE A 51 "BRK" MSG FOR THE PILL
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMBRK	; SET DRMBRK TO DO THE REST NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRCLP:	SKIPN	T1,DRMCLP	;T1/DRs THAT NEED A CLOCK REQ MSG
	  JRST	MDRANS		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMCLP
	MOVSI	P3,TYPI TYPCLP
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMCLP	; SET DRMCLP TO DO THE REST NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRANS:	SKIPN	T1,DRMANS	;T1/DRs TO SEND AN ANSWERED MSG TO
	  JRST	MDRNXT		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMANS
	MOVSI	P3,TYPI TYPANS
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMANS	; SET UP FOR NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRNXT:	
	MOVE	T1,DRMTIM	;;;;;;;START KMC DEBUG CODE
	SUBI	T1,1
	JUMPE	T1,CPOPJ1	;IGNORE FOR THE FIRST SECOND
	PUSHJ	P,KMCGAV##
	MOVE	T2,T1
	ANDI	T2,377
	LSH	T2,8
	PUSHJ	P,KMCGAC##
	ANDI	T1,377
	IOR	T1,T2
	CAMN	T1,KMCLAS	;SAME AS LAST TIME?
	 JRST	CPOPJ1		;YES, BYE...
	MOVEM	T1,KMCLAS
	HRL	T1,DRMTIM
	MOVE	T2,KMCPDP
	MOVEM	T1,KMCFLG(T2)
	ADDI	T2,1
	ANDI	T2,77
	MOVEM	T2,KMCPDP	;;;;;;;;END KMC DEBUG CODE
	JRST	CPOPJ1	;END OF MDR CHAIN FOR NOW. SKIP RET

MDRMSG:	;MSG TO ALL UP DRs	;P3/ MOVSI P3,TYPI TYPmsg
	;T1/ 3-BIT UP DR NUMBERS;RET:T1/0 or DRs NOT SENT TO
;;;;;;;	MOVE	T2,SYSNUM##	;PUT THE SYSNUM IN THE MESSAGES JUST
	MOVE	T2,DRMTIM	;USE UP TIME FOR NOW
;;;;;;;	ANDI	T2,377		;INCASE THE NODE WANTS IT IN THE FUTURE
	ANDI	T2,1777		;SHOW 10 BITS FOR NOW
	LSH	T2,8		; OFCOURSE WE CAN ONLY SEND 8 BITS OF IT
	ANDCM	P3,[377,,-1]	;LEAVE ONLY MESSAGE TYPE IN BITS 2-9
	IOR	T2,P3		;T2 HOLDS THE MESSAGE
MDRLUP:	SKIPN	P3,T1
	 JRST	CPOPJ		;RETURN WHEN T1=0
	ANDI	P3,3		;ISOLATE A DR NUMBER
	JUMPE	P3,MDRL1	;IF IT'S 0 GO TRY THE NEXT ONE
	SUBI	P3,1		;1-4 GOES TO 0-3
	CAILE	P3,MAXDR	;P3 MUST BE .LE. PORTS/LINES PER DR
	 JRST	MDRL1
	LSH	P3,6		;MAKE IT A PORT NUMBER
	IORI	P3,LPERDR&77	;P3/(DRNUM*100) ! LINES PER DR
	CAILE	P3,<MAXDR*100>!<RPORTN##-<MAXDR*LPERDR>>
	 JRST	[ANDCMI P3,77
		IORI	P3,RPORTN##-<MAXDR*LPERDR>
		JRST	.+1]
	ANDCMI	P3,3		;MUST BE A MULTIPLE OF 4
	HRL	P3,P3		;P3/MAX PORT NUM,,MAX PORT NUM
	ANDCMI	P3,77		;P3/MAX PORT NUM,,DR NUM
	HLRZ	T3,T2		;TEST FOR TYPHSI
	CAIE	T3,TYPI TYPHSI	;TYPHSI USES MAX PORT,,DRNUM
	 HRLZ	P3,P3		;TYPE A MESSAGES DON'T USE MAX PORT
	IOR	P3,T2		;OR IN THE MESSAGE AND SYS NUMBER
	PUSH	P,T1
	PUSH	P,T2
	PUSHJ	P,CLSCHR	;MAKE SURE THE RING IS READY
	  JRST MDRRET		;IF NOT DO A NON-SKIP RETURN
	PUSHJ	P,WRDOUT	;PUT THE MESSAGE IN THE RING
	  JRST MDRRET		;THIS SHOULDN'T HAPPEN!
	POP	P,T2
	POP	P,T1
	HLRZ	T3,T2		;TEST FOR TYPHSI
	CAIE	T3,TYPI TYPHSI
	 JRST	MDRL1		;IF NOT HSI THEN SKIP TO MDRL1
	MOVE	T3,T1
	ANDI	T3,3
	SUBI	T3,1
	SETOM	SENT41(T3)	;FLAG THAT WE SENT A 41 TO THAT DR
MDRL1:	LSH	T1,-3		;THROW OUT 3-BIT DR NUM JUST PROCESSED
	JRST	MDRLUP		;GO DO THE NEXT ONE
MDRRET:	POP	P,T2
	POP	P,T1
	JRST	CPOPJ

DR1BIT==1B35
DR2BIT==1B34
DR3BIT==1B31
DR4BIT==1B28

MDRUP:	PUSHJ	P,KMCGUP##
DRFLAG: HRLZ	T1,T1		;MOVE FLAGS TO LEFT HALF
	TLZE	T1,DR1BIT	;TEST AND CLEAR THE FIRST FLAG
	 IORI	T1,0001		;IF A DRs FLAG IS SET PUT ONE PLUS IT'S
	TLZE	T1,DR2BIT	;    NUMBER IN A 3-BIT OCTAL DIGIT SLOT
	 IORI	T1,0020
	TLZE	T1,DR3BIT
	 IORI	T1,0300
	TLZE	T1,DR4BIT
	 IORI	T1,4000
	HRRZ	T1,T1		;T1/ 0,,3-BIT DR NUMBERS FLAGGED
	POPJ	P,		;RETURN
>;END IFKMC

;BASVER definitions: BYTE(8)TYPE,FLAGS,VERSION,RELEASE
	BV.DBG==<BYTE(8)0,001,0,0>	;Debugging if lsb of 2nd byte set
	BV.HDN==<BYTE(8)0,200,0,0>	;EBUS says host was down (we went away)
RCVRAK:	MOVE	T1,IRING(P4)	;TYPRAK=4 - Reset Acknowlege
	MOVEM	T1,BASVER##	;Store BYTE(8)CODE,DEBUG,VERSION,RELEASE
BASEOK:: STOPCD (.+1,EVENT,BASEOK,PRTBVR,<Base is up>)
	AOJA	P4,SCNIN1

IFCPU (<KI,KL>),<
PRTBVR:	PUSHJ	P,INLMES##	;Called from STOPCD(BASEOK)
	 ASCIZ /Code in base is version /
	LDB	T1,[POINT 8,BASVER,23]
	PUSHJ	P,PRTDEC##
	PUSHJ	P,PRPER##	;Period
	LDB	T1,[POINT 8,BASVER,31]
	PUSHJ	P,PRT2##	;2 decimal digits
;	PUSHJ	P,INLMES##
;	 ASCIZ / - debug flag is /
;	MOVEI	T1,[ASCIZ /OFF/]
;	MOVSI	T2,(BV.DBG)
;	TDNE	T2,BASVER	;Is it set?
;	 MOVEI	T1,[ASCIZ /ON/]	;Yes
;	PUSHJ	P,CONMES##	;STOPCD processor will provide CRLF
	POPJ	P,
>
IFNCPU(<KI,KL>),<PRTBVR==CPOPJ##> ;PDP-11 bases do not report version #

IFNKMC<				;TYPRES=3 - Reset interface
RCVRES:	SETOM	BASDWN##	;Set flag to call DETALL and send TYPRAK
	MOVE	T1,IRING(P4)	;Get the message
	EXCH	T1,BASVER##	;Store BYTE(8)CODE,DEBUG,VERSION,RELEASE
	CAME	T1,BASVER##	;Don't mumble about 2 in a row
	 STOPCD	(,XCT,BASEOK)	;Print "base is up" message
	PUSHJ	P,DETALL	;Detach all ports
	LDB	T1,[POINT 16,BASVER,31];Get 3rd and 4th bytes
	CAILE	T1,<02_^D8>+00	;Is it version 02.00 ?
	 AOJA	P4,SCNIN1	;No, done
	SETZM	IRPPDP		;Yes, EBUS has set IRP620 to zero
	SETZM	ORPPDP		; and ORP620 to zero
	POPJ	P,		;Return from SCNTIC - no more to do
>  ;End IFNKMC

IFKMC<		;Here when KMC detects problem with a DR11C
RCVRES:	SETZM	BASVER##	;Store BYTE(8)0,0,0,0 instead of EBUS version
	MOVEI	T1,^D60
	MOVEM	T1,TIMDRD	;RESET KMC CHECKUP TIMER
	MOVE	T1,DRMTIM ;;;;;;;TEMP STUFF UP TIME IN IRING 3 MSG
	DPB	T1,INPDL2 ;;;;;;;  "    "    "   "   "   "   "  "
	LDB	U,INPLIN
	ANDI	U,300		;U/FIRST PORT NUMBER OF FAILING DR
	CAIL	U,RPORTN##	;THIS TEST WORKS ONLY WHEN LPERDR=^D64
	 AOJA	P4,SCNIN1	;IGNORE BAD PORT NUMBERS
	MOVE	T1,U		;(if RPORTN=200, then only 0-177 are legal)
	LSH	T1,-6		;T1/DR NUMBER
	SETZM	SENT41(T1)	;RESET "WAITING FOR RESPONSE TO 41"
	PUSHJ	P,KMCCAC##	;CLEAR DR'S ACTIVE BIT & UP BIT
DRZAP:	PUSHJ	P,DETONE	;Detach one port on this particular DR11
	ADDI	U,1
	MOVE	T1,U
IFN LPERDR-^D64,<?Logic at DRZAP needs to be modified>
	ANDI	T1,LPERDR-1	;ONE OF 77, 37, or 17
	CAIGE	U,RPORTN##	;THIS TEST ONLY WORKS FOR LPERDR=64.
	 JUMPN	T1,DRZAP	;GO DO THE NEXT PORT
	AOJA	P4,SCNIN1	;EXIT
>;END IFKMC

;DETALL - Mark all lines as being detached

DETALL:	MOVEI	U,RPORTN##-1	;Do all real ports (not PTY ports)
	PUSHJ	P,DETONE	;Detach one
	SOJGE	U,.-1		;Loop for all
	PJRST	SETSHT		;Set UPSHUT to the right value

;DETONE - Mark one line as being detached, port number in U preserved

DETONE:	PUSH	P,U		;SAVE U
	MOVE	U,LINTAB(U)	;U/ PORT LDB
	HLL	U,LDBDCH(U)	;U/DEVICE CHARARTERISTICS,,PORT LDB
	SKIPL	LDBLOG(U)	;SKIP IF PORT NOT LOGGED IN
	 JRST	DETON1
	PUSHJ	P,FRCZAP	;ZAP THE PORT
	PUSHJ	P,CLRTTY	;CANCEL THE "SEND ZAPPER" FLAG
DETON1:	POP	P,U		;RESTORE PORT NUMBER
	POPJ	P,

RCVANS:				;CALLED WHEN KMC/DR RESPONDS TO A 41 WE SENT IT
IFNKMC<	MOVE	T1,IRING(P4)	;Get the message
	EXCH	T1,BASVER##	;Store BYTE(8)CODE,DEBUG,VERSION,RELEASE
	CAME	T1,BASVER##	;Don't mumble about 2 in a row
	 STOPCD	(,XCT,BASEOK)	;Print "base is up" message
	AOJA	P4,SCNIN1>	;IGNORE ANS MESSAGE ON KI/KL/F3
IFKMC<	MOVE	T1,DRMTIM ;;;;;;;TEMP PUT TIME IN IRING 1 MSG
	DPB	T1,INPDL2 ;;;;;;;  "   "    "   "   "   "  "
	LDB	T1,INPLIN	;T1/ PORT LDB
	LSH	T1,-6		;T1/DR NUMBER
	SKIPN	SENT41(T1)	;DON'T SET ANSWERED BIT UNLESS WE SENT 41
	 AOJA	P4,SCNIN1
	SETZM	SENT41(T1)	;RESET "WAITING FOR RESPONSE TO 41"
	PUSH	P,T1
	PUSHJ	P,KMCSUP##	;SET DR'S ANSWERED BIT
	POP	P,T1
	ANDI	T1,3
	ADDI	T1,1
	MOVE	T2,DRMCLP
	LSH	T2,3
	IOR	T2,T1
	MOVEM	T2,DRMCLP
	MOVEI	T2,STSHUT	;400000
	TDNE	T2,STATES	;ARE WE SHUT?
	 JRST	KMCSHT		;YES, GO SET UP DRMSHT
	MOVE	T2,DRMANS	;NO, SET UP DRMANS INSTEAD
	LSH	T2,3
	IOR	T2,T1
	MOVEM	T2,DRMANS
	AOJA	P4,SCNIN1	;EXIT
KMCSHT:	MOVE	T2,DRMSHT
	LSH	T2,3
	IOR	T2,T1
	MOVEM	T2,DRMSHT
	AOJA	P4,SCNIN1
>;END IFKMC
SUBTTL	IQUEUE - TAKES AN INPUT WAIT TRAP IF SET, OTHERWISE PLACES
; THE JOB IN TTY INPUT WAIT.

IQUEUE:	LDB T1,DDPTTI		;CHECK FOR TRAP WANTED.
	PUSHJ	P, TSTKTJ	;IF INPUT WAIT INTERRUPT WANTED
	 JRST ABTUUO		;YES, ABORT.
	SKIPGE	JBTAWQ(J)	;IF INTERRUPT PENDING
	 JRST ABTUUO		; ABORT
	PUSHJ P,TIWAIT		;NO.  QUEUE JOB FOR TIO WAIT.
	PJRST BIOATT

;OQUEUE - TAKES AN OUTPUT WAIT TRAP IF SET, OTHERWISE PLACES
; THE JOB IN TTY OUTPUT WAIT.

OQUEUE:	LDB T1,DDPTTI		;CHECK FOR TRAP WANTED.
	PUSHJ P,TSTKTJ		;SEE IF INTERRUPT ON IOW
	 PUSHJ P,SETFIO		;NEEDS WAKUP LATER
	SKIPGE JBTAWQ(J)	;CHECK FOR TRAPS WAITING
	 JRST ABTUUO		;AND ABORT IF ANY.
	PUSHJ P,TOWAT1		;NO.  QUEUE JOB FOR TIO WAIT.

;HERE TO CHECK IF LINE FOR THIS PORT IS STILL ATTACHED.

BIOATT:	SKIPE JBTAWQ(J)
	JRST ABTUUO
	HRRZ U,DDBLDB(F)	;IS LINE STILL ATTACHED?
	JUMPN U,CPOPJ1		;YES.  HE WINS.
	MOVSI T1,TTYATC		;IS THIS THE CONTROLLING TTY
	TDNN T1,DEVMOD(F)	;OR AN AUXILIARY CIRCUIT?
	 JRST AUXRID		;AN AUXCIR ... HE LOSES.
	POPJ P,			;CONTROLLING TTY: HE STILL LOSES
SUBTTL	 BLKXIN - TERMINATE BLOCK INPUT AUXCAL

BLKXIN:	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO	; BLOCK I/O ENABLED?
	 POPJ	P,
	HRRZ	T1,LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	JUMPE	T1,BLKXI1	; NO BUFFER
	PUSHJ	P,BLKTRQ	; REQUEST INPUT TERMINATION
	HRRZ	T1,LDBBIO(U)
	SKIPGE	BIOCHR(T1)	; CHECK IN-PROGRESS FLAG
	 POPJ	P,		; IN-PROGRESS: DO NOTHING NOW
	MOVSI	S,IOEND		; COMPLETE: SET IOEND
	SKIPA
BLKXI1:	MOVEI	S,IODEND	; NO BUFFER: SET IO.EOF
	IORB	S,DEVIOS(F)
	POPJ	P,

; BLKTRQ - ROUTINE TO REQUEST BLOCK INPUT TERMINATION

BLKTRQ:	MOVSI	T1,LMLTBI
	TDNE	T1,LDBMOD(U)	; TERMINATION PENDING?
	 POPJ	P,		; YES: DO NOTHING
	IORM	T1,LDBMOD(U)	; NO: SET THE FLAG
	MOVEI	T1,1
	DPB	T1,LOPTRI	;    SET TERMINATE-INPUT
	DPB	T1,LDBOPB(U)	;    AND NEED-OUTPUT
	POPJ	P,

;BLKXOT - HERE TO TERMINATE BLOCK OUTPUT FOR A PORT IN BIO MODE

BLKXOT:	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO	;IF BLKIO NOT ENABLED,
	 POPJ	P,		;  JUST RETURN
	HLLZ	T1,LDBBIO(U)
	JUMPE	T1,CPOPJ	;IF NO BLK OUTPUT IN PROGRESS, RETURN
	MOVSI	T1,LDLNOP
	ANDCAM	T1,LDBDCH(U)	;IGNORE BACKPRESSURE
	LDB	T1,LOPBOT
	SOJL	T1,BLKXT1	;IF WE'RE ABOUT TO REQUEST BLK OUTPUT,
	DPB	T1,LOPBOT	;  FORGET IT (T1/ 0)
	PJRST	FRCOHR		;  BUT SIMULATE THE OUTPUT-COMPLETE
				;ELSE
BLKXT1:	DPB	T1,LOPTRO	;  SET TO SEND BLKO-TERMINATE (T1/ -1)
	DPB	T1,LDBOPB(U)	;  AND NEED-OUTPUT
	POPJ	P,
SUBTTL INPUT AND OUTPUT SUBROUTINES

TYI:	PUSHJ	P,TYIEAT	;GET RID OF COMMAND LINE (CAN'T RESCAN ANYMORE)
	SOSGE LDBTIC(U)	;ANY INPUT CHRS LEFT?
	JRST	[SETZM LDBTIC(U)
		POPJ P,]	;NO, NON-SKIP RETURN
	PUSHJ P,BPFTYI		;RESET BACKPREASURE
	MOVE T2,LDBTIT(U)
	PUSHJ P,TTGETC
	 PUSHJ P,FRECHK
	MOVEM T2,LDBTIT(U)
	SKIPN T1,LDBBKP(U)	;ANYTHING IN ^U POINTER
	SOS LDBBKI(U)		;YES, 1 FEWER CHRS
	CAMN T1,T2		;IS THIS THE POINTER NOW
	SETZM LDBBKP(U)		;YES, NOTHING THERE NOW
	TRNE T3,400
	JRST CPOPJ1		;IMAGE CHR
	TRNN T3,200
	SKIPA P3,CHRTAB(T3)
	MOVE P3,CHRTAB-200(T3)	;GET INFORMATION BITS
	LDB T2,CHPRED	;GET READ CODE
TYIRPT:	XCT TYIATB(T2)		;AND DO IT
	SUBI T3,40		;HERE IN LOWER CASE, CONVERT TO UPPER
	JRST CPOPJ1		;DONE

TYIATB:	PHASE 0
	JRST SPRTYI	;SPECIAL ACTION NEEDED
	JRST CPOPJ1	;NORMAL CHR
%CHBRK:! SOSA LDBBKC(U)	;BREAK, FLAGGED SO CALLERS KNOW
	JRST TYIC	;BREAK2
	TLNE U,LDLLCT	;LOWER CASE, SHOULD WE CONVERT?
	DEPHASE

TYIC:	TLNE U,LDLBK2	;IN BREAK2 MODE?
	MOVE T2,%CHBRK	;YES, FLAG AS BREAK FOR CALLERS
	AOS (P)
TYID:	SOS LDBBK2(U)
	JUMPN T1,CPOPJ	;DON'T WORRY IF NO ^U POINTER
	MOVSI T1,-1
	ADDM T1,LDBBKI(U)
	POPJ P,

SPRTYI:	LDB T2,CHPSPR	;GET ACTION CODE
	LDB P3,LDPMOD	;AND LINE MODE
	XCT @SPRTTB(P3)

SPRTTB:	XCT TYIPDP(T2)
	XCT TYI940(T2)
	XCT TYI940(T2)
	XCT TYIPDP(T2)
TYIPDP:	JRST TYICC	;^C
	JRST TYIALT	;33
	JRST TYIBRK	;^_
	JRST TYICZ	;^Z
	JRST TYIPAL	;175-176
	JRST TYITAB	;TAB
	JRST TYIBSP	;BACKSPACE

TYI940:	JRST TYIBRK	;^C
	JRST TYICC	;33 POSSIBLE ESCAPE
	JRST TYICC	;^_
	JRST TYIBRK	;^Z
	JRST TYICCP	;175-176
	JRST TYITAB	;TAB
	JRST TYIBSP	;BACKSPACE

TYITAB:	MOVSI T2,L2LTBK
	TDNN T2,LDBBYT(U)	;TREAT TAB AS BREAK?
	JRST TYIC	;NO AS BREAK2
TYIBRK:	MOVEI T2,%CHBRK	;YES, TREAT AS BREAK
	JRST TYIRPT

TYIBSP:	MOVSI T2,L2LBBP
	TDNE T2,LDBBYT(U)	;TREAT BSP AS BREAK
	JRST TYIC	;NO, AS BREAK2
	JRST TYIBRK	;YES

TYIPAL:	TLNN U,LDLLCT	;IN TTY LC
	JRST TYIBRK	;YES, JUST A BREAK CHARACTER
TYIALT:	MOVEI T2,LDRFCS	;ALTMODE. IN FULL CHR SET MODE?
	TDNN T2,LDBDCH(U)
	MOVEI T3,STDALT	;NO, STANDARD
	JRST TYIBRK

TYICZ:	HRRZ F,LDBDDB(U)
	JUMPE F,TYIBRK	;NO DDB, JUST BREAK CHR
	MOVSI T4,IOEND
	IORM T4,DEVIOS(F)	;SET END OF FILE
	JRST TYIBRK
TYICCP:	TLNN U,LDLLCT	;IN TTY LC
	JRST TYIBRK	;YES, TRAT AS BREAK
TYICC:	SOS LDBBKC(U)
	MOVE J,JOB	;ALSO FALL HERE FROM ABOVE
	PUSHJ P,ESCTR1	;TRY TRAPPING
	PUSHJ P,CNCCHK	;CHECK SPECAIL CONDITIONS
	JRST [
		LDB	P3, LDPMOD	; GET MONITOR MODE
		MOVEI	T3, 3		; ^C FOR 10'S
		CAIE	P3, 1		; GE MODE?
		CAIN	P3, 2		; TYMEX MODE?
		MOVEI	T3, 33		; ESC FOR 940'S
		AOS	LDBBKC(U)	; SOS'D IN TYIBRK
		JRST	TYIBRK		; PASS TO PROGRAM
	]
	PUSHJ P,TIWAIT	;HALT COMMAND ALREADY SET
	PUSHJ	P, CKATTI	;MAKE SURE IT'S STILL ATTACHED
	JRST	ABTUUO		;(S)HE WANTS AN INTERRUPT
	JUMPN	U, TYI		;TRY AGAIN (FOR CONTINUE)
	 STOPCD 		;HORRORS! NOT A COMMAND PORT!
SUBTTL	GET RID OF COMMAND LINE

TYIEAT:	TLNN U,LDLECS	;ALREADY DONE THIS?
	 POPJ P,		;YES
	PUSH P,T3
	PUSH P,P3	;ALSO SAVE THIS (TTYSTR AND FRIENDS)
TYIL:	SOSGE LDBTIC(U)
	JRST [SETZM LDBTIC(U)
		JRST TYIET2]
	MOVE T2,LDBTIT(U)
	PUSHJ P,TTGETC
	 PUSHJ P,FRECHK
	MOVEM T2,LDBTIT(U)
	SKIPN T1,LDBBKP(U)
	SOS LDBBKI(U)	;SAME AS IN TYI
	CAMN T1,T2
	SETZM LDBBKP(U)
	TRNE T3,400
	JRST TYIL	;IMAGE, TRY NEXT
	TRNN T3,200
	SKIPA P3,CHRTAB(T3)
	MOVE P3,CHRTAB-200(T3)
	LDB T2,CHPRED
	XCT EATTAB(T2)
	JRST TYIL	;TRY NEXT

EATTAB:	JRST SPREAT	;SPECIAL ACTION
	JRST TYIL	;NOMAL CHR
	JRST TYIET3	;BREAK CHR, FINISHED
	PUSHJ P,TYID	;BREAK2
	JRST TYIL	;LOWER CASE, JUST LIKE NORMAL

SPREAT:	LDB T2,CHPSPR
	XCT SPRETB(T2)	;SAME IN ALL MODES
	XCT -5+[TDNE T3,LDBBYT(U)	;FROM TAB
	        TDNN T3,LDBBYT(U)](T2)	;FROM BACKSPACE
	JRST TYIET3	;TREAT AS BREAK
	PUSHJ P,TYID	;TREAT AS BREAK2
	JRST TYIL

SPRETB:	JRST TYIET3	;^C
	JRST TYIET3	;33
	JRST TYIET3	;^_
	JRST TYIET3	;^Z
	JRST TYIET3	;175-176
	MOVSI T3,L2LTBK	;TAB, CHECK BREAK OR BREAK2
	MOVSI T3,L2LBBP	;BACKSPACE, CHECK BREAK OR BREAK2

TYIET3:	SOS LDBBKC(U)	;A BREAK CHR FINISHED
TYIET2:	MOVSI T1,LDLECS	;FINISHED BECAUSE OUT OF CHRS
	ANDCAM T1,LDBDCH(U)	;TURN OFF FLAG IN ANY CASE
	POP P,P3
	POP P,T3
	HLL U,LDBDCH(U)
	POPJ P,
SUBTTL	TYO, CMDTYO - Put characters in TTY output buffer
COMMENT %
@@SUBROUTINE TYO, CMDTYO
@@PURPOSE TYO -- CHECK FOR SPACE, PLACE CHAR IN OUTPUT BUFFER
	  CMDTYO -- ASSUME SPACE, PLACE CHAR IN OUTPUT BUFFER
@@ENTRY	T3/ CHAR, F/ DDB ADDR, U/ (NONZERO) LDB ADDR
@@ACCUM	T1-T2 DESTROYED
@@EXIT	ON A SKIP-RETURN, THE CHARACTER HAS BEEN DEPOSITED.
THE NONSKIP-RETURN IS NOT ACTUALLY A RETURN BUT RATHER A
PUSHJ TO ITS CALLER. IT IS TAKEN WHEN THERE IS NO ROOM FOR
THE CHARACTER AND THE JOB WANTS A TRAP. THE CALLER HAS
THREE CHOICES:
	1) ABORT THE UUO, GIVING THE JOB ITS TRAP
	2) MAKING ROOM FOR THE CHARACTER, THEN POPJ-ING,
	   CAUSING TYO TO RETRY THE DEPOSIT
	3) AOS (P) / POPJ -ING, CAUSING TYO TO GO INTO
	   OUTPUT WAIT
%

TYO:	MOVE	T1,TTFREN	;T1/ # FREE CHUNKS
	CAIL	T1,TIRSVD	;IF #FREE .lt. #SAVED,
	 JRST	TYO1
	MOVSI	T1,TWTSPC
	IORM	T1,DEVIOS(F)	;  MARK NO-CHUNKS WAIT
	JRST	TYOW2		;  AND GO WAIT

TYO1:	MOVE	T1,LDBTOC(U)	;T1/ # CHARS LEFT TO OUTPUT
	SKIPGE	LDBDCX(U)	;IF IT'S FAST
	CAML	T1,OMX120	;AND UNDER THE FAST MAXIMUM,
	CAMGE	T1,OMX30	;OR IF IT'S UNDER THE SLOW MAXIMUM,
	 JRST	TYO2		;  CONTINUE OUTPUT.
	SKIPGE	LDBBYT(U)	;IF IT'S NOT EXTENDED-MODE
	CAML	T1,TOEMAX	;OR IT'S OVER THAT LIMIT,
	 JRST	TYOW		;  GO TRAP OR WAIT
TYO2:	AOS	(P)		;PREPARE FOR SKIP-RETURN
	HLL	U,LDBDCH(U)
	TLNE	U,LDLOSU	;IF SUPPRESSING OUTPUT,
	 POPJ	P,		;  JUST (SKIP-)RETURN

;CMDTYO - put character in output chunk.  Caller must check for room

CMDTYO:	SKIPE	T2,LDBTOP(U)	;IF NO CHUNK ALLOCATED,
	 JRST	TYO3
	PUSHJ	P,GETCHK	;  T2/ CHUNK BYTE POINTER
	MOVEM	T2,LDBTOP(U)	;  SET OUTPUT PUTTER
	MOVEM	T2,LDBTOT(U)	;  SET OUTPUT TAKER
	SETZM	LDBTOC(U)	;  SET OUTPUT COUNT
TYO3:	PUSHJ	P,TTPUTC	;STORE CHAR.; T2 := NEW PUTTER
	MOVEM	T2,LDBTOP(U)	;STORE NEW PUTTER
	AOS	LDBTOC(U)	;UPDATE COUNT
	POPJ	P,
TYOW:	LDB	T1,DDPTTI	;T1/ IOW TRAP CHANNEL
	PUSHJ	P,TSTKTJ	;SETUP TRAP IF ENABLED. IF IT WAS,
	  PUSHJ	P,SETFIO	;  MARK DDB FOR OUTPUT-DONE TRAP
	LDB	T1,PJOBN
	SKIPL	JBTAWQ(J)	;IF AWAITING A TRAP,
	 JRST	TYOW1
	PUSHJ	P,@(P)		;  RETURN TO CALLER AS COROUTINE
	JRST	TYO		;  (NONSKIP FROM RECALLED CALLER)

TYOW1:	JUMPE	U,TYOW3		;IF ATTACHED,
TYOW2:	MOVEI	T1,1
	DPB	T1,LOPOUT	;  SET CHARACTER-OUTPUT
	DPB	T1,LDBOPB(U)	;  AND NEED-OUTPUT
TYOW3:	PUSHJ	P,TOWAT1	;GO INTO OUTPUT WAIT
TYOW4:	HRRZ	U,DDBLDB(F)
	JUMPN	U,TYO		;IF STILL ATTACHED, TRY AGAIN
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)	;IF IT'S NOT THE COMMAND PORT,
	PJRST	AUXRID		;  DISCARD DDB AND ABORT UUO
	JRST	TYOW		;OTHERWISE, WAIT FOR ATTACH
SUBTTL	MAKE SURE TTY IS ATTACHED, NO CHANCE FOR INTERRUPT

CKATTF:	MOVE	S,DEVIOS(F)
	HRRZ	U,DDBLDB(F)
	JUMPN	U,UUOLDB
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	 JRST	AUXRID		;CAN GET RID OF DDB FOR AUX CIRCUIT
	PUSHJ	P,TOWATA
	JRST	CKATTF		;TRY AGAIN

;CHECK TO SEE THAT THERE IS ROOM FOR AT LEAST ONE CHARACTER TO BE OUTPUT

CHKROM:	HLRZ	T1,LDBBIO(U)	;BLOCK OUTPUT NOW IN PROGRESS?
	JUMPN	T1,CHKRM1	;YES. QUEUE JOB FOR OUTPUT WAIT.
	MOVE	T1,TTFREN
	CAIGE	T1,TIRSVD	;IS THERE BUFFER SPACE?
	 JRST	CHKRM3
	MOVE	T1,LDBTOC(U)	;NUMBER NOW IN OUTPUT BUFFER
	SKIPGE	LDBDCX(U)	;IF IT'S FAST
	CAML	T1,OMX120	;AND UNDER THE FAST MAXIMUM,
	 CAMGE	T1,OMX30	;OR IF IT'S UNDER THE SLOW MAXIMUM,
	  JRST	CPOPJ1		;  SAY THERE'S ROOM
CHKRM1:	LDB	J,PJOBN
	SKIPGE	JBTAWQ(J)	;ABORT UUO IF TRAP IS PENDING
	 JRST	ABTUUO
	LDB	T1,DDPTTI
	PUSHJ	P,TSTKTP	;SEE IF WE CAN TAKE AN INTERRUPT
	  SKIPA			;YES, MUST MAKE SURE WE SET OUTPUT ROOM FLAG
	JRST	TOWAT1		;QUEUE JOB FOR OUTPUT WAIT.

CHKRM2:	PUSHJ	P,SETFIO
	JRST	ABTUUO		;NOW GET OUT OF UUO

;HERE WHEN THERE'RE NO BUFFERLETS AVAILABLE FOR THE OUTPUT

CHKRM3:	LDB	T1,DDPTTI
	PUSHJ	P,TSTKTJ	;DOES HE GET AN I/O WAIT TRAP?
	  JRST	CHKRM2		;YES: DO IT
	MOVSI	T1,TWTSPC
	IORM	T1,DEVIOS(F)	;NO: MARK REASON FOR WAIT
	PJRST	TOWAT1		;    AND DO IT


; CALL TO SEE IF ROOM FOR A CHARACTER
; U/LDB
; PUSHJ P,IFROOM
;  <NO ROOM>
; <ROOM>

IFROOM:	MOVE	T1,TTFREN	;Number of buffer chunks
	CAIGE	T1,TIRSVD	;Is there buffer space?
	 POPJ	P,		;No, last 3 chunks reserved for emergencies
	HRRZ	T1,U		;Get LDB address
	CAIN	T1,CTYLDB	;Sending to the CTY?
	 JRST	[MOVE	T1,TTFREN
		 CAIL	T1,TIRSVD+5
		  AOS	(P)	;CTY can use all but the last 10 chunks
		 POPJ	P,]	
	MOVE	T1,LDBTOC(U)	;Number of characters currently in buffer
	SKIPGE	LDBDCX(U)	;If it's fast
	CAML	T1,OMX120	; and under the fast maximum,
	 CAMGE	T1,OMX30	; or if it's under the slow maximum,
	  AOS	(P)		;  say there's room
	POPJ	P,
SUBTTL	SUBROUTINES TO SET UP LINE AND MAKE SURE ATTACHED.
;CALL WITH F SET UP, FROM M LEVEL ONLY.
;RETURN WHEN ATTACHED AND AT USER LEVEL, WITH U SET UP.

;ONE ROUTINE FOR INPUT, ONE FOR OUTPUT.

CKATTI:	MOVE	S,DEVIOS(F)	;SET UP STATUS WORD
	HRRZ	U,DDBLDB(F)	;GET LINE BLOCK ADDR
	JUMPN	U,CKATI2	;IF THERE, GO ON
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	 JRST	CPOPJ1		;AUX CIRCUIT, SPECIAL
CKATI2:	LDB	T1,PJOBN	;NOW CHECK IF JOB WAITING FOR
	SKIPGE	JBTAWQ(T1)	;AN INTERRUPT
	 POPJ	P,		;YES
	JUMPN	U,CKATI1
CKATIW:	SKIPE	SKPFLG		;DON'T WAIT FOR ATTACH IF INC AND SKP AUXCAL
	 POPJ	P,
	LDB	T1,DDPTTI
	PUSHJ	P,TSTKTJ	;IS THIS AN IOW INTERRUPT
	 POPJ P,		;YES
	MOVSI	S,IO+TTYOUW	;MUST WAIT FOR ATTACH
	ANDCAM	S,DEVIOS(F)	;CLEAR DIRECTION BIT
	MOVEI	S,IOACT		;AND SET WAIT BIT FOR INPUT
	IORB	S,DEVIOS(F)	; ..
	PUSHJ	P,WSYNCS	;WAIT FOR ATTACH
	JRST	CKATTI		;GET U SET UP AND RETURN.

CKATI1:	HLL	U,LDBDCH(U)		;GET DEVICE BITS
	TLNE	U,LDLCOM		;AT COMMAND LEVEL?
	 JRST	CKATIW			;YES. CAN'T1 DO INPUT.
	PUSHJ	P,TYIEAT		;NO. SKIP ANY COMMANDS
	AOS	(P)
	PJRST	UUOLDB			;AND GO ADJUST LINE BITS.

CKATTO:	MOVE	S,DEVIOS(F)		;SET UP STATUS WORD
	HRRZ	U,DDBLDB(F)		;GET LINE ADDR IF ANY
	JUMPN	U,CKATO2		;IF HAVE ONE, SEE IF TOP LEVEL
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	 JRST	CPOPJ1
CKATO2:	LDB	T1,PJOBN
	SKIPGE	JBTAWQ(T1)
	 POPJ	P,			;WAITING FOR INTERRUPT
	JUMPN	U,CKATO1
	LDB	T1,DDPTTI
	PUSHJ	P,TSTKTJ
	  PJRST	SETFIO			; INTERRUPT ON IOW
	PUSHJ	P,TOWATA		;WAIT FOR OUTPUT DONE. (WHICH
					; IS FORCED ON ATTACH)
	JRST	CKATTO			;AND SET UP U, TO RETURN.
CKATO1:	AOS	(P)
	MOVSI	T1,L2LOEX
	ANDCAM	T1,LDBBYT(U)		;TURN OFF EXTENDED OUTPUT
	PFALL	UUOLDB			;FALL INTO UUOLDB
SUBTTL	UUOLDB - MAKE LDB (ADDR IN U) AGREE WITH FILE STATUS BITS (IN S)

UUOLDB:	JUMPE	U,CPOPJ		;JUST IN CASE
	HLL	U,LDBDCH(U)	;MAKE SURE LEFT HALF SET
	TLNE	U,LDLAUX
	 POPJ	P,		;DO NOTHING FOR AN AUX CIRCUIT

    ;SET MONITOR MODE BITS

	PUSH	P,J
	LDB	J,PJOBN
	LDB	T4,PVYMOD
	DPB	T4,LDPMOD
	POP	P,J		;SET MODE

    ;SET LDBDCX BITS

	MOVE	T1,LDBDCX(U)
	TRNE	S,DLRSUP
	TLOA	T1,LXLDLR	;SUPPRESS-$
	 TLZ	T1,LXLDLR	;DON'T SUPPRESS $
	MOVEM	T1,LDBDCX(U)

    ;GET LDB BITS FROM FILE STATUS BITS

	SETZ	T1,
	TRNE	S,FCS
	 TRO	T1,LDRFCS
	TRNE	S,NOECHO
	 TLO	T1,LDLNEC
	TLNE	S,IOSBKA
	 TLO	T1,LDLBKA
	TRNE	S,BK2IOS
	 TLO	T1,LDLBK2

    ;SET THE LDBDCH BITS

	MOVE	T4,T1
	XOR	T4,LDBDCH(U)	;T4/ THE BITS THAT CHANGED
	IORM	T1,LDBDCH(U)
	TDC	T1,[LDLNEC!LDLBKA!LDLBK2,,LDRFCS]
	ANDCAB	T1,LDBDCH(U)
	HLL	U,T1		;UPDATE LH(U)

    ;FINISH UP

	MOVE	S,DEVIOS(F)	;UPDATE S
	TLNE	T4,LDLNEC	;IF WE'RE CHANGING ECHO MODE
	TRNE	T1,LDRDEM	;AND LDRDEM NOT SET,
	 PJRST	SETLMD
	MOVEI	T1,1		;  SET TO CHANGE ECHO MODE
	DPB	T1,LOPSEC
	DPB	T1,LDBOPB(U)
	PJRST	SETLMD		;AND GO SET LINE MODE
TWAITL:	MOVSI S,IOSBKA
	ANDCAB S,DEVIOS(F)
	MOVSI T1,LDLBKA
	ANDCAM T1,LDBDCH(U)	;SET FOR LINE MODE INPUT
	PUSHJ P,SETLMD
	MOVE T1,LDBTIC(U)
	HLL U,LDBDCH(U)	;MAKE SURE LINE IS OK
	MOVE T4,LDBBKC(U)	;GET BREAK COUNT
	TLNE U,LDLBK2	;IF IN BREAK2 MODE
	 ADD T4,LDBBK2(U)	;NUMBER IS SUM
	CAIGE T1,TIWKC
	TRNE T4,-1		;IF A BREAK OR ENOUGH CHRS
	 POPJ P,			;GO NOW
	TLNN U,LDLIMI	;IN IMAGE MODE?
	 JRST TWTL1		;NO, MUST WAIT
	SKIPN LDBTIC(U)	;YES, ANY CHRS?
	TLNE S,IOEND		;OR END OF FILE SET
	 POPJ P,			;IF END FLAGGED, THEN DONE
	SKIPE LDBECC(U)	;ARE THERE ANY CHRS THERE AT ALL?
	 JRST TWTL2	;YES, I/O WAIT BUT NO TRAP
	JRST TWTL3	;NO, I/O WAIT WITH POSSIBLE TRAP
TWTL1:	JUMPN T4,TWTL2	;IF UNECHOED BREAK CHRS, I/O WAIT NO TRAP
	ADD T1,LDBECC(U)
	CAIL T1,TIWKC	;OR POSSIBLEY TOO MANY TOTAL
	 JRST TWTL2	;I/O WAIT NO TRAP
TWTL3:	LDB T1,DDPTTI	;CHECK FOR TRAP WANTED
	PUSHJ P,TSTKTJ		;SEE IF INTERRUPT ON IOW
	 JRST ABTUUO		;YES, ABORT
TWTL2:	PUSHJ P,TIWAIT
	PUSHJ P,CKATTI
	 JRST ABTUUO
	JUMPN U,TWAITL
	JRST AUXRID	;ZAPPED AUX CIRCUIT

TWAITS:	;AOS	SKPFLG	;CALLED BY AN INPUT AND SKIP AUXCAL
	JFCL		;FOR NOW UNTIL CAN FIND OUT WHY SKPFLG STAYS SET
			;WHEN SHOULDN'T
	AOS	(P)	;SET TO SKIP RETURN
TWAITC:	MOVSI S,IOSBKA
	IORB S,DEVIOS(F)
	MOVSI T1,LDLBKA
	IORM T1,LDBDCH(U)
	PUSHJ P,SETLMD
	HLL U,LDBDCH(U)	;MAKE SURE LINE OK FOR CALLERS
	SKIPLE LDBTIC(U)	;ANY CHARACTERS PRESENT?
	POPJ P,
	SKIPE LDBECC(U)
	JRST TWTC1	;SOME CHRS SO NO I/O TRAP
	LDB T1,DDPTTI
	PUSHJ P,TSTKTJ		;CHECK IOW WAIT INTERRUPT
	 JRST 	TWABT		;GET OUT
TWTC1:	PUSHJ P,TIWAIT
	PUSHJ P,CKATTI
	 JRST 	TWABT	;WAITING FOR INTERRUPT
	MOVE	T1,SKPFLG
	SETZM	SKPFLG
	JUMPN	U,TWTC2		;JUMP IF LINE ATTACHED
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	JRST	AUXRID		;ZAPPED AUX CIRCUIT
	SOS	(P)		;ZAPPED CMD PORT FROM INC AND SKP AUXCAL
	POPJ	P,
TWTC2:	JUMPGE	T1,TWAITC	;GET ENOUGH INPUT CHARS?
	POPJ	P,		;NO

TWABT:	SETZM	SKPFLG
	JRST	ABTUUO
TIWAIT:	MOVSI S,IO!TTYOUW
	ANDCAM S,DEVIOS(F)	;SET DIRECTION
	MOVEI S,IOACT
	IORB S,DEVIOS(F)	;SET WAIT BIT
	MOVEI T1,IMGTIM
	TLNE U,LDLIMI
	DPB T1,LDPTIM		;SET TIMER IF IN IMAGE MODE
	MOVEI T1,1
	DPB T1,LOPECO		;SET ECHO-NEEDED
	DPB T1,LDBOPB(U)	;AND NEED-OUTPUT
	JRST WSYNCS

;ROUTINE TO WAIT FOR NEARLY EMPTY OUTPUT BUFFER. CALL ONLY AT UUO LEVEL
TOWAIT:	MOVE T1,LDBTOC(U)		;GET COUNT OF TYPE-OUT CHARACTERS WAITING.
	CAIGE T1,10			;OVER 7?
	POPJ P,0			;NO. JUST RETURN.
TOWAT1:	MOVE S,[XWD TTYOUW+IO,IOACT]	;FLAG OUTPUT WAIT ACTIVITY
	IORM S,DEVIOS(F)		;IN THE DEVICE DATA BLOCK
WSYNCS:	MOVSI S,TIOUSE
	IORB S,DEVIOS(F)
	PUSH P,P1			;HAVE TO SAVE AC'S TO WAIT
	PUSH P,P2			; BECAUSE WSYNC USES THESE
	PUSH P,T3
	PUSH P,F
	PUSH P,W
	PUSHJ P,SCNINT		;GIVE HIM A CHANCE TO ECHO BEFORE PUTTING HIM IN WAIT
	POP P,W
	POP P,F
	POP P,T3
	MOVE	S,DEVIOS(F)	
	TRNN	S,IOACT		;DO WE NEED TO GO INTO WAIT?
	JRST	WSYNC1		;NO
	SKIPN	SKPFLG		;INPUT AND SKIP CALL IN PROGRESS?
	JRST	WSYNC2		;NO
	SETOM	SKPFLG		;COULDN'T GET ENOUGH INPUT CHARS
	PUSHJ	P,TIWAKN	;DON'T BLOCK
	SKIPA
WSYNC2:	PUSHJ P,WSYNC			;WAIT
WSYNC1:	POP P,P2			;RESTORE AC'S
	POP P,P1			; ..
	MOVSI S,TIOUSE
	ANDCAB S,DEVIOS(F)
	POPJ P,0			;AND RETURN FROM TOWAIT
SUBTTL BACKPRESSURE ADJUSTERS

;BPLVD - CALLED BY LEVDEF UUO

BPLVD:	MOVEI	T1, LDRXOS!LDRBPS
	TDNE	T1, LDBDCH(U)	;IF WE'VE SENT BACKPRESSURE OR AN XOFF
	 JRST	BPLVD1
	LDB	T1, LOPBPN
	JUMPE	T1, CPOPJ	;OR WE'RE PLANNING TO,
BPLVD1:	MOVE	T1, LDBECC(U)
	ADD	T1, LDBTIC(U)
	CAIL	T1, TIWKC	;AND WE DON'T HAVE GOBS OF CHARACTERS,
	 POPJ	P,
	JRST	BPFCOM		;  SET TO CLEAR BACKPRESSURE

;BPFTYI - CALLED AT THE START OF TYI

BPFTYI:	MOVEI	T1, LDRXOS!LDRBPS
	TDNE	T1, LDBDCH(U)	;IF WE'VE SENT BACKPRESSURE OR AN XOFF
	 JRST	.+3
	LDB	T1, LOPBPN
	JUMPE	T1, CPOPJ	;OR WE'RE PLANNING TO,
	MOVE	T1, LDBECC(U)
	ADD	T1, LDBTIC(U)
	CAIL	T1, 10		;AND WE HAVE HARDLY ANY CHARACTERS,
	 POPJ	P,
	JRST	BPFCOM		;  SET TO CLEAR BACKPRESSURE

;BPXOFF - CALLED WHEN DONE ECHOING, ON CLRBFI, BEFORE DOING
;	   BLOCK INPUT, AFTER READING COMMAND LINE
;BPOFF - CALLED WHEN ENTERING COMMAND LEVEL, WHEN FORCED
;	  OUT OF IMAGE STATE BY SCNSEC OR CLRIMI

BPXOFF:	SKIPA	T1, [LDRBPS!LDRXOS]
BPOFF:	MOVEI	T1, LDRBPS
	TDNE	T1, LDBDCH(U)	;IF WE'VE SEND BACKPRESSURE (OR XOFF)
	JRST	BPFCOM
	LDB	T1, LOPBPN	;OR WE'RE ABOUT TO,
	JUMPE	T1, CPOPJ
	PFALL	BPFCOM		;  SET TO CLEAR BACKPRESSURE

BPFCOM:	MOVEI	T1, 1
	DPB	T1, LOPBPF	;SET BACKPRESSURE-OFF
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,

;ROUTINE TO CHECK TO SEE IF BACKPRESSURE SHOULD BE TURNED OFF.  SKIP RETURNS
;IF SHOULD NOT BE TURNED OFF ELSE NON-SKIP RETURNS
;
BPTEST:	PUSH	P,T1
	MOVE	T1,LDBTIC(U)	;COMPUTE TOTAL NUMBER
	ADD	T1,LDBECC(U)	; OF CHARACTERS WAITING
	CAMG	T1,TIWRNN	;GREATER THAN BACKPRESSURE ON THRESHOLD?
	 JRST	TPOPJ		;NO, TURN OFF BACKPRESSURE
	JRST	TPOPJ1		;YES, LEAVE BACKPRESSURE ON
SUBTTL COMMAND ROUTINES

;ROUTINE TO MAKE THIS TTY VISIBLE TO COMMAND DECODER, IF AT COM LEVEL
;CALL WITH U SET UP

CMDWAK:	SKIPN	FRSFLG		;IF IT'S JUST THE RESCAN-STUFFER,
	 JRST	CMDWK1
	SETZM	FRSFLG		;  TELL IT WE GOT HERE
	POPJ	P,
CMDWK1:	TLNN	U,LDLCOM	;IS LINE AT COMMAND LEVEL?
	 POPJ	P,0		;NO. JUST RETURN
	MOVSI	T1,L2LLDF
	ANDCAM	T1,LDBBYT(U)	;RESET FLAG, USER AWAKE
	SETZ	T1,		;Indicate to COMWCM that command comes
				;from terminal
; Enter here with command index in T1 (or 0 if not forced command)
TTFORC:	PUSH	P,F		;Preserve
	LDB	F,LOPZAP	;If we're going to ZAP it,
	JUMPN	F,FPOPJ		; ignore the command
	HRRZ	F,LDBDDB(U)	;Set up DDB pointer
	JUMPE	F,FPOPJ		;None there, just exit
	PUSH	P,J
	LDB	J,PJOBN		;Find job/frame number
	SKIPE	J		;None there...
	PUSHJ	P,COMWCM##	;Set command request for this job/frame
	POP	P,J
FPOPJ:	POP	P,F
	POPJ	P,

;;
;; Routine to set up command input pointer to accept command
;;  input from TTY.  Clobbers T2.
;;
TRESCN::MOVE	T2,LDBTIT(U)	;TTY input buffer pointer
	MOVEM	T2,TTCMCA	;Copy into command input pointer
	MOVEI	T3,40		;Delimiter
	MOVEM	T3,TTCMCH
	POPJ	P,

;COMTYO - Output character in T3, preserving T2, uses T1

COMTYO::PUSH	P,T2		;Save T2 as advertised
	PUSHJ	P,@.CPTOA##	;Call CCTYO or routine in ONCE
	JRST	T2POPJ##	;Restore T2 and return

;CCTYO - usual output routine for .CPTOA

CCTYO::	HRRZ	T1,U		;Just the LDB address
	JUMPE	T1,CPOPJ	;Ignore if line not set up
	CAIN	T1,CTYLDB	;If output is going to the CTY,
	 PUSHJ	P,MSGLOG	;Log char in MSGBUF (high phys mem)
	PUSHJ	P,IFROOM	;Space in this guy's area?
	  POPJ	P,		;No, ignore further attempts at output
	PUSHJ	P,CMDTYO	;Put character in output chunks
	PJRST	ONEOU3		;And start output


CCTYI::	SKIPE T2,TTCMCA		;REAL INPUT ROUTINE FOR COMMAND
	CAMN T2,LDBTIP(U)	;NOTHING OR AT END OF BUFFER
	 JRST CCTYI1		;GO FAKE A BREAK
	PUSHJ P,TTGETC
	  JFCL
	MOVEM T2,TTCMCA
	POPJ P,

CCTYI1:	MOVEI T3,12
	POPJ P,
SUBTTL	COMMAND INPUT ROUTINE

COMTYI::PUSHJ P,COMTYT	;FETCH A CHARACTER
	 SUBI T3,40	;UPSHIFT LOWER CASE
	POPJ P,

COMTYT::MOVE T3,TTCMCH
	CAIE T3,3
	CAIN T3,12	;THESE ARE FINISHED FLAGS
	 JRST CPOPJ1	;DO NOT TRY TO READ FURTHER
	PUSH P,T2
	PUSH P,P3	;SAVE REGISTERS FOR CALLERS
	HLL U,LDBDCH(U)
COMTI1:	PUSHJ P,@.CPTIA	;GET A CHR
	ANDI T3,177	;NOT INTERESTED IN EXTRA BITS
	MOVE P3,CHRTAB(T3)
	LDB T1,CHPRED
	XCT COMATB(T1)
	CAIN T3,15	;RETURN IS SPECAIL
	 JRST COMTI1	;GO GET LF AND SAY NOTHING ABOUT RETURN
COMTI2:	MOVEM T3,TTCMCH	;REMEMBER CHR FOR REREAD
	POP P,P3
	POP P,T2
	JRST CPOPJ1

COMATB:	JRST SPRCOM	;SPECIAL ACTION
	JFCL		;NORMAL CHR
	MOVEI T3,12	;TURN ALL BREAKS TO LINE FEEDS
	JFCL		;BREAK2
	SOS -2(P)	;NON-SKIP RETURN ON LOWER CASE CHAR

SPRCOM:	LDB T1,CHPSPR	;GET CHR TYPE
	LDB T2,LDPMOD	;AND LINE MODE
	XCT @SPRCTB(T2)
	JRST COMTI2	;FINISH UP
SPRCTB:	XCT COMPDP(T1)
	XCT COM940(T1)
	XCT COM940(T1)
	XCT COMPDP(T1)

COMPDP:	MOVEI T3,3	;^C
	MOVEI T3,12	;33
	MOVEI T3,12	;^_
	MOVEI T3,12	;^Z
	MOVEI T3,12	;175-176
	JRST COMTAB	;TAB
	JRST COMBSP	;BACKSPACE

COM940:	MOVEI T3,12	;^C
	MOVEI T3,3	;33
	MOVEI T3,3	;^_
	MOVEI T3,12	;^Z
	JRST COMPA	;175-176
	JRST COMTAB	;TAB
	JRST COMBSP	;BACKSPACE

COMTAB:	MOVSI T1,L2LTBK
	TDNE T1,LDBBYT(U)
	MOVEI T3,12	;TREAT AS BREAK
	JRST COMTI2	;TREAT AS BREAK2

COMBSP:	MOVSI T1,L2LBBP
	TDNN T1,LDBBYT(U)
	MOVEI T3,12	;TREAT AS BREAK
	JRST COMTI2	;TREAT AS BREAK2

COMPA:	MOVEI T3,3
	TLNN U,LDLLCT
	MOVEI T3,12
	JRST COMTI2	;EITHER AN ESCAPE OR JUST A BREAK CHR
SUBTTL	ROUTINE TO SWITCH TTY TO USER PROGRAM LEVEL AND START USER RUNNING

TTYUSW::TDZA S,S			;DON'T1 CLEAR WAIT BITS
TTYUSR:: MOVE S,[XWD IOW,IOACT]		;CLEAR WAIT BITS
	PUSHJ P,TTYUS0			;PUT TTY IN USER
	PJRST SETRUN			;MAKE HIM RUN AND RETURN

;CALL TTYUSM TO SIMPLY PUT TERM IN USER MODE

TTYUSM::SETZ S,				;DON'T CLEAR WAIT BITS
TTYUS0:	JUMPE	U,CPOPJ			;Exit if no LDB
	HRRZ F,LDBDDB(U)		;GET ATTACHED F IF ANY
	JUMPE F,TTYUS1			;JUMP IF NOT ATTACHED
	ANDCAB S,DEVIOS(F)		; ..
	PUSHJ P,UUOLDB			;MAKE U AND DEVIOS AGREE
TTYUS1:	MOVSI T1,LDLCOM			;PUT TTY IN USER MODE
	ANDCAM T1,LDBDCH(U)		;MAY BE DETACHED, BUT WILL WAIT
					; AT UUO LEVEL IF NEEDED
	PUSHJ P,SETLMD
	POPJ P,

;; Here when terminal-originated command has completed

TTYCMR::MOVSI	T1,LDLECS		;Set EAT-COMMAND-SYNC bit
	IORM	T1,LDBDCH(U)		; in Line Data Block
	POPJ	P,

TTYSTC::JUMPE	U,CPOPJ
	MOVSI	T1,LDLIMI		;FORCE OUT OF IMAGE MODE
	PUSHJ	P,CNCMD1		;WILL ALSO SET COMMAND BIT

TTYSTR::JUMPE	U,CPOPJ			;Exit if no LDB
	HLL	U,LDBDCH(U)
	TLNN	U,LDLCOM		;AT COMMAND LEVEL?
	 PJRST	NOCTRO			;NO. JUST CLEAR ^O BIT
	PUSHJ	P,TYIEAT		;CLEAR THE COMMAND IN CASE MORE
	HRRZ	T1,LDBBKC(U)		;NUMBER OF DEF ECHO BREAK CHARS
	JUMPE	T1,CKSXON		;NO BREAKS WAITING
	PUSHJ	P,CMDWAK		;SET FOR COMMAND
	PJRST	NOCTRO			;AND GO CLEAR BIT

MONHNG::HRLI	T1,3
	PUSHJ	P,HNGMON
	  JFCL
	POPJ	P,

TTYHLT::		;Global entry point to put TTY in cmd mode
CNCMOD:	MOVSI T1,LDLIMI!LDLECS
CNCMD1:	ANDCAM T1,LDBDCH(U)	;FORCE USER TO COMMAND LEVEL, RESET
	PUSHJ	P,BPTEST	;WANT TO TURN OFF BACKPRESSURE?
	  PUSHJ P,BPOFF		;YES, MAKE SURE BACKPRESSURE OFF
	MOVSI T1,LDLCOM
	IORM T1,LDBDCH(U)
	PJRST SETLMD

CKSXON:	PUSHJ	P,BPTEST	;WANT TO TURN BACKPRESSURE OFF?
	  PUSHJ P,BPXOFF	;YES
	JRST NOCTRO
SUBTTL	OPRCTY - Remove chars from CTY's LDB and send to CTY

CTYBLF::EXP 0	;0,,-1 to ding next minute, -1,,-1 to ding this tick
OPRTIC::EXP 0	;Number of ticks before OPRCTY is allowed to continue

OPRCTY:	MOVEI	U,CTYLDB	;Called by once-per-tick code
	SKIPGE	OPRTIC		;If CTYSIM is not doing anything,
	 SETOM	OPRTIC		; make sure this doesn't overflow to positive
		SOSG  OPRTIC	;Don't output if CTYSIM output recently
IFCPU(<KI,F3>),<CONSZ TTY,TT.OB>;Skip if output is done
IFCPU (KS),<	SKIPE CTYOWD##>	;Skip if output is done
IFCPU(KL),<	SKIPN EPT##+SPCMTD>; "     "         "
		 POPJ P,	;Output in progress - try again later
;*;	MOVEI	T3,ALRCTY	;SET ALARM
;*;	IORM	T3,ALR620	;11 NODES DON'T CARE TO KNOW ABOUT ALRCTY
	SKIPL	CTYBLF		;AAA. IF -1 RING BELL THIS TIME
	 JRST	OPRCT2
	HRRZS	CTYBLF		;RESET TO 0,,-1
	MOVEI	T3,7
	PJRST	CTYCHR		;RING BELL (not sent to CTYBUF nor MSGBUF)

OPRCT2:	SKIPLE	CTYFLN		;ARE THERE FILLS NEEDED
	 JRST	OPRFIL		;YES
	MOVE	T2,LDBTOT(U)
	PUSHJ	P,TTGETC	;Get character from CTY's LDB
	  PUSHJ	P,FRECHK
	MOVEM	T2,LDBTOT(U)
	PUSHJ	P,CTYLOG	;Log it in CTYBUF (MSGLOG called already)
	PUSHJ	P,PEVEN8	;Generate parity (smashes T1)
	PUSHJ	P,CTYCHR	;Send it to the CTY
	ANDI	T3,177
	CAIE	T3,14
	CAIN	T3,13		;HANDLE FF AND VTB
	 JRST	CTYFRM
	CAIN	T3,15
	SKIPN	T3,CTYFIL	;CR AND NEED FILLS?
	 JRST	CTYNFL		;NO
CTYSFL:	MOVEM	T3,CTYFLN	;YES, SET COUNT (DO NOT DEC CHR CNT)
	POPJ	P,

CTYFRM:	MOVEI	T3,^D40
	JRST	CTYSFL		;SET LARGE NUMBER OF FILLS

OPRFIL:	MOVEI	T3,377		;Filler is RUBOUT with even parity
	PUSHJ	P,CTYCHR	;Go to CTY (not CTYLOG, not MSGLOG)
	SOSLE	CTYFLN
	 POPJ	P,		;Come back next tick
CTYNFL:	SOSLE	LDBTOC(U)
	 POPJ	P,		;NOT ALL OUTPUT YET
	PUSHJ	P,OPRFRE	;RESTART SETUUO WAITERS
	PUSHJ	P,TSETBO	;RESET OUTPUT BUFFER
	POPJ	P,		;DONE
SUBTTL	CTYTYP, CTYTYO - output character to the CTY (no interrupts)

;OPROUT - co-routine to set output to the CTY or the OPR terminal.
;Call with T1/0 = No LDB - Use CTYTYO to go directly to the CTY, no interrupts
;          T1/1 = One LDB - Use CTYLDB to put in the TTY chunks, CTY only
;          T1/2 = Two LDBs - Use both CTYLDB and OPRLDB, put in chunks
;Preserves all ACs but T1.  Note that U is not changed.

OPROUT::MOVE	T1,[EXP OP0TYO,OP1TYO,OP2TYO](T1) ;Get new address
	EXCH	T1,.CPTOA##	;Set new typout address for COMTYO
	EXCH	T1,(P)		;Save old address, get resume PC
	PUSHJ	P,(T1)		;Call caller as coroutine
	  SOS	-1(P)		;Propagate non-skip return
	POP	P,.CPTOA##	;Restore typeout routine when caller POPJs
	JRST	CPOPJ1

;Here during INFO or EVENT stopcodes - use normal buffered output to OPR+CTY

OP2TYO:	HRLM	T3,(P)		;Save char
	PUSH	P,U
	SKIPE	U,OPRLDB	;If there is an OPR terminal
	 PUSHJ	P,CCTYO		;Output to it
	POP	P,U
	HLRZ	T3,(P)		;Do same character to the CTY
	PFALL	OP1TYO

;Here to output to the CTY's LDB only (buffer emptied at clock level)

OP1TYO:	PUSH	P,U		;Routine to output to the CTY's LDB
	MOVEI	U,CTYLDB	;Point to the CTY
	PUSHJ	P,CCTYO		;Put char in CTY's LDB (this calls MSGLOG)
	JRST	UPOPJ	 	;Restore U and continue

;OP0TYO updates the key, then calls CTYTYO (called from continuable STOPCD).

OP0TYO::PUSH	P,T1		;Routine to output char in T3 to the CTY
	MOVE	T1,KEY10	;Magic number for the base
	SKIPL	.CPDWD##	;STOPCD in progress?
	 XCT	KEYSET		;Yes, update KEY620 if not in CONSOLE mode
	POP	P,T1
	PFALL	CTYTYO
;Output character directly to the CTY.  Called via PUSHJ P,@COMTYO from DIE.
;CTYTYO outputs to CTY, logs output, generates even parity, and does fillers.
;  This routine will wait in a loop if output is busy, which may mean a delay
;  of several milliseconds (more if CTYFIL is nonzero).
;Call with 7-bit character in T3 (8 data bits if 9th bit it set).
;Caller is expected to create free CRLF at column 80 (for now).

CTYTYO::PUSH	P,T1		;Called from ONCE, CTYSIM, ERRCON, etc
	PUSHJ	P,MSGLOG	;Log it in MSGBUF (high phys mem)
	PUSHJ	P,CTYLOG	;Log it in CTYBUF (T3 has 7-bit character)
	TRZN	T3,400		;If image flag set, char is 8 bits
	 PUSHJ	P,PEVEN8	;Generate even parity (smashes T1)
	PUSHJ	P,CTYCHR	;Output it to the CTY, loop if busy
PRINTF(<[CTYTYO should to free CRLF at column 80]>)
	CAIE	T3,015		;Carriage return?
	CAIN	T3,215		;(with or without parity)
	 SKIPN	CTYFIL		;Yes, have to do fillers?
	  JRST	TPOPJ		;No, return
	PUSH	P,T3		;Save the character
	MOVE	T1,CTYFIL	;Number of rubouts to do
CTYTY1:	MOVEI	T3,377		;Fill character is rubout
	PUSHJ	P,CTYCHR	;CTYCHR loops waiting for output done
	SOJG	T1,CTYTY1	;Do multiple fillers
	POP	P,T3		;Get 8-bit character back
	JRST	TPOPJ		;End of CTYTYO


;Output string to CTY.  Called from MONBTS and COMMON when loading BOOTS
;	MOVEI	T1,[ASCIZ /string/]
;	PUSHJ	P,CTYTYP
;	 <only return>

CTYTYP::HRLI	T1,440700	;POINTER FOR ASCIZ
CTYTYL:	ILDB	T3,T1		;GET CHARACTER
	JUMPE	T3,CPOPJ	;RETURN
	PUSHJ	P,CTYTYO
	JRST	CTYTYL

;Routine to log all CTY output in CTYBUF.  Preserves all ACs

CTYLOG::CAIE	T3,007		;Ignore bells
	CAIN	T3,207
	 POPJ	P,
	PUSH	P,T1
	IBP	CTYPTR##	;Increment byte pointer
	MOVE	T1,CTYPTR##	;Get it
	TRZ	T1,-1-CTYMSK##	;Use only 9 bits of offset within CTYBUF
	ADDI	T1,CTYBUF##	;Full address
	DPB	T3,T1		;Store all CTY output in CTYBUF
	POP	P,T1
	POPJ	P,

	MSGLG.=:%MS0+0	;SIXBIT /MSGLOG/
	MSGLGS=:%MS0+1	;EXP <1777-4>*5 = size of MSGBUF in bytes = 11747
	MSGLGI=:%MS0+2	;EXP 0          = number of bytes put in by MSGLOG
	MSGLGO=:%MS0+3	;EXP 0          = number of bytes removed by SYSDAT
	MSGBUF=:%MS0+4	;ASCII text     = message log buffer
	MSG777=:%MS1+777;ASCIZ /<><>/   = end of buffer marker

;Programs need a 2004 word buffer to read MSGLG.+MSGBUF with SYSDVF function 6
	SYDVF (<<MSGLG.,MSGBUF-MSGLG.>,<MSGBUF,MSG777+1-MSGBUF>>)
;Set up MSGBUF in high memory.  ONCE has made %MS0 and %MS1 addressable

MSGINI::MOVE	T1,['MSGBUF']	;Name of buffer in SIXBIT
	MOVEI	T2,<MSG777-MSGBUF>*5 ;Size in bytes (^D5095)
	MOVE	T3,[ASCIZ/<><>/];End of buffer marker
	CAMN	T1,MSGLG.	;Check 1st and 2nd words
	CAME	T2,MSGLGS	; for valid data from previous load
	 JRST	MSGIN1		;Bad
	CAME	T3,MSG777	;Check last word
	 JRST	MSGIN1		;Bad
IFCPU (<KI,F3>),<		;OK, calculate offset into buffer
	MOVE	T1,MSGLGI	;Count of bytes already logged to buffer
	IDIV	T1,MSGLGS	;Modulo buffer size
	MOVE	T3,[POINT 7,MSGBUF,6
		    POINT 7,MSGBUF,13
		    POINT 7,MSGBUF,20
		    POINT 7,MSGBUF,27
		    POINT 7,MSGBUF,34](T2)
	ADD	T1,T3		;Combine byte pointer with address
>  ;End KI,F3
IFNCPU(<KI,F3>),<MOVE T1,[POINT 7,MSGBUF,6]> ;Prototype for ADJBP
	MOVEM	T1,MSGLGP	;Byte pointer will be incremented before use
	POPJ	P,		;Buffer has valid data from previous crash

MSGIN1:	SETZM	MSGBUF		;Zero out both pages
	MOVE	T4,[MSGBUF,,MSGBUF+1]
	BLT	T4,MSG777
	MOVEM	T1,MSGLG.	;Make header valid
	MOVEM	T2,MSGLGS
	MOVEM	T3,MSG777	;And end marker
	SETOM	MSGLGI		;These will be inc'ed to 0 for 1st char
	SETOM	MSGLGO
	MOVE	T1,[POINT 7,MSGBUF,6] ;Prototype for ADJBP
	MOVEM	T1,MSGLGP	;Byte pointer will be incremented before use
	POPJ	P,

;Routine to log all CTY output in MSGBUF.  Preserves all ACs
;Called when characters go into the CTYLDB chunks (INFO and EVENT stopcodes)
; and when CTYTYO is bypassing the CTYLDB (ONCE dialog, serious stopcodes).

MSGLOG::SKIPN	MSGLGP		;If byte pointer is not set up yet,
	 POPJ	P,		; ignore until MSGINI sets it
	CAIE	T3,007		;Ignore bells
	CAIN	T3,207
	 POPJ	P,
	PUSH	P,T1
	PUSH	P,T2
	AOSGE	T1,MSGLGI	;Increment to new byte position
	 SETZB	T1,MSGLGI	;(should never exceed 35 bits)
IFCPU(<KL,KS>),<
	IDIV	T1,MSGLGS	;Modulo MSGBUF size (remainder in T2)
	ADJBP	T2,MSGLGP	;Convert to byte pointer
	DPB	T3,T2		;Store byte in MSGBUF
>  ;End if KL,KS
IFCPU(<KI,F3>),<
	IBP	MSGLGP		;Increment byte pointer
	HRRZ	T2,MSGLGP
	CAIL	T2,MSG777	;If EA has hit end of MSGBUF
	 MOVEI	T2,MSGBUF	; wrap to beginning
	HRRM	T2,MSGLGP
	DPB	T3,MSGLGP	;Store byte in MSGBUF
>  ;End if KI,F3
	POP	P,T2
	POP	P,T1
	POPJ	P,

SUBTTL	CTYCHR - Output 8-bit character to the console teletype
;Caller is responsible for parity generation and free CRLF at column 80.
;Returns immediately if caller has waited for output-done to be true.
ENTRY	CTYCHR			;Called from CTYSIM

IFCPU (<KI,F3>),< ;Output to KI/F3 console
CTYCHR:	CONSZ	TTY,TT.OB	;Wait for Output Busy to go off
	 JRST	.-1		;(no timeout for this hardware flag)
	DATAO	TTY,T3		;Send character as it (all 8 bits)
	POPJ	P,		;The DATAO sets TT.OB in hardware

SVPPC::	POPJ	P,	;There is no other processor to do Keep-Alive on KI,F3
>;END IFCPU (<KI,F3>)
PRINTF([Need to make SVPPC work on KS])

IFCPU (KS),<	;Output to the KS console via the 8080
CTYCHR:	HRLM	T3,(P)		;Save character in T3
	MOVSI	T3,1		;Number of times to try
	SKIPE	CTYOWD##	;Previous CTY output done?
	 SOJG	T3,.-1		;No, wait for it
	HLRZ	T3,(P)	
	ANDI	T3,CTYOCH	;Get just the character
	TRO	T3,CTYOVL	;Add the Output Valid flag
	MOVEM	T3,CTYOWD##	;Store in location 33 in low memory
	RDAPR	T3		;Get program states
	ANDI	T3,LP.PIA	;Leave only the PIA
	WRAPR	LP.SSF+LP.I8C(T3);Whap the 8080
	HLRZ	T3,(P)		;Restore char in T3
	POPJ	P,

SVPPC::	JFCL			;Determine if Keep-Alive is active
	PUSH	P,T1		;Save flag on stack
	JFCL			;Disable Keep-Alive checking
	PUSHJ	P,@-1(P)	;Return to caller (co-routine)
	POP	P,T1		;Get flag back
	JFCL			;Resume Keep-Alive if needed
	POP	P,(P)		;Clean up stack
	POPJ	P,		;End of SVPPC
>  ;End of IFCPU(KS)

IFCPU (KL),<	;Output to the KL console via the PDP-11 on the master DTE
CTYCHR:	HRLM	T3,(P)		;Save character in T3
	MOVSI	T3,1		;Number of times to try
	SKIPN	EPT##+SPCMTD	;Previous CTY output done?
	 SOJG	T3,.-1		;No, wait for it
	HLRZ	T3,(P)	
	ANDI	T3,377		;Just 8 bits of character
	MOVEI	T3,.DTCTO(T3)	;Make DTE command word
	MOVEM	T3,EPT##+SPCCMW	;Store in command word
	SETZM	EPT##+SPCMTD	;Zero to indicate output not done
	CONO	DTE,TO11DB	;Ring doorbell
	HLRZ	T3,(P)		;Restore char in T3
	POPJ	P,		;SPCMTD will be set nonzero when output done

;Routine to save Primary Protocol Condition (See DTESER.703)
;Called by DIE when processing a STOPCODE.

SVPPC::	JFCL			;Determine if running primary or secondary protocol
	PUSH	P,T1		;Save flag on stack
;*;	JSR	SPCINI		;Set to secondary protocol
	PUSHJ	P,@-1(P)	;Return to caller (co-routine)
	POP	P,T1		;Get flag back
	JFCL			;Restart primary protocol if needed
	POP	P,(P)		;Clean up stack
	POPJ	P,		;End of SVPPC
;KL CTY output, continued

SPHNGI:	0	;INSTRUCTION TO XCT IF DTE HANGS UP
SPCST1:	0	;FOR SAVING T1
SPCTRY:	0	;# OF REMAINING TRIES
SPCTRN==10	;# TO INIT SPCTRY TO

SPCINI::0			;ENTER SECONDARY PROTOCOL
	MOVEM	T1,SPCST1	;SAVE T1
	MOVE	T1,[EPT##+SPCDBG,,EPT##+SPCDBG+1]
	SETZM	EPT##+SPCDBG
	BLT	T1,EPT##+SPCDND	;INIT COMM AREA TO ZEROES
	RDPI	SPCCMD		;SAVE PI STATE
	WRPI	LI.PIF
	MOVE	T1,[JSR DTEHLT]
	MOVEM	T1,EPT##+EPTDT0+DTEDII
	MOVEM	T1,SPHNGI
	MOVE	T1,[EPT##+EPTDT0+DTEEPW,,EPT##+EPTDT0+DTEEPW+1]
	SETZM	EPT##+EPTDT0+DTEEPW
	BLT	T1,EPT##+EPTDT0+DTEDRW
	CONO	DTE,CL11PT	;CLEAR INTERRUPT JUST IN CASE
	MOVE	T1,SPCCMD	;RESTORE PI
	TRNE	T1,LI.PIN
	 WRPI	LI.PIN
	MOVEI	T1,.DTESP
	JSR	SPCCMD
	MOVE	T1,SPCST1
	JRST	@SPCINI

;READ SWITCHES.
SPCGSW::MOVEI	T1,.DTRSW
	JSR	SPCCMD
	MOVE	T1,EPT##+SPCF11
	POPJ	P,

;SEND SECONDARY PROTOCOL COMMAND
SPCCMD:	0			;JSR HERE
	SETZM	EPT##+SPCFLG	;CLEAR FLAG FIRST.
	MOVEM	T1,EPT##+SPCCMW	;STUFF COMMAND
	MOVEI	T1,SPCTRN	;GET # OF TIMES TO TRY
	MOVEM	T1,SPCTRY
SPCCM1:	CONO	DTE,TO11DB	;RING DOORBELL
	MOVEI	T1,40000
	SKIPN	EPT##+SPCFLG
	 SOJG	T1,.-1
	JUMPG	T1,@SPCCMD	;WORKED, RETURN.
	SOSL	SPCTRY
	JRST	SPCCM1
	XCT	SPHNGI

DTEHLT:	0
	 STOPCD		;;DTEHLT+1
>;END IFCPU (KL)
SUBTTL	SETUUO TO SET INITIA ON LINES MARKED

NOXEXE::0			;Set nonzero by ONCE to not run XEXEC

INISET::MOVSI	T1,(STAUTO)	;Enter here from UUOCON (DSKCLN does this)
	TDNN	T1,STATES	;Check if still in auto-restart mode
	 POPJ	P,		;Don't do this more than once
	MOVEI	U,CTYLDB	;Output to the CTY
	SKIPE	NOXEXE		;If set to not run XEXEC,
	 JRST	[MOVEI T1,STSUPR   ;Change super-shut (600000)
		 ANDCAM T1,STATES  ; to shut (400000) so OPER can login
		 SETZM NOXEXE	   ;Allow INITIA to be run later
		 MOVEI T1,[ASCIZ /INITIALIZATION complete
please log in: /]
		 PJRST CONMES##]
	MOVEI	T1,[ASCIZ /SETUUO forcing INITIA on TTY1,TTY2,TTY3,TTY4,TTY5
/]
	PUSHJ	P,CONMES##	;TELL OPERATOR WHAT IS HAPPENING
	MOVSI	P3,-PORTN##	;CHECK ALL LINES
INISLP:	MOVE	U,LINTAB(P3)
	SKIPN	LDBLOG(U)	;NOT IF LOGGED IN
	TLNN	U,TTVIN2	;OR NOT MARKED
	 JRST	INISL2
	MOVE	T2,[LLLNLN,,LDLCOM]	;FOR LDBLOG AND LDBDCH
	HLLZM	T2,LDBLOG(U)	;MARK IN (BUT UNKNOWN TO THE BASE)
	HRLZM	T2,LDBDCH(U)	;AND COMMAND MODE
	MOVE	T1,SYSNUM##	;Our host number
	DPB	T1,LDPHST	; for job running INITIA part 2 (XEXEC)
	SETZM	LDBDCX(U)	;NO EXTENDED BITS ON
	PUSHJ	P,SETLMD
	PUSHJ	P,FRMASN##	;Assign a frame slot
	  POPJ	P,		;None there? Quit loop now, why bother?
	PUSHJ	P,TTYATI	;Attach TTY DDB to this LDB
	  PJRST	FRMKJF##	;No DDB's - free up frame slot,kill TTY
	MOVEI	T1,CMFCXI##
	PUSHJ	P,TTFORC	;MARK FORCED COMMAND
INISL2:	AOBJN	P3,INISLP
	JRST	CPOPJ1
SUBTTL	SOME ROUTINES TO FIND TELETYPES FOR VARIOUS PURPOSES

;SUBROUTINE TO FIND TTY FOR A JOB IN J (TTYFND) OR FOR
; CURRENT JOB (TTYFNU)
;RETURN WITH F AND U SET UP.
;GOES TO ERROR IF NO TTY F FOR THE JOB.

TTYFNU::MOVE	J,JOB		;GET CURRENT UUO LEVEL JOB NUMBER
TTYFND::PUSHJ	P,TTYSRC	;FIND THE JOB'S TTY F, ALSO U AND S
	 STOPCD 		;JOB ZERO, OR OTHERWISE NO DDB. COMPLAIN.
	POPJ	P,0		;SUCCESS. RETURN.

;ROUTINE TO FIND A TTY F WHICH IS ATTACHED TO, I.E.
;CONTROLLING, A PARTICULAR JOB NUMBER.

;CALLED AT COMMAND LEVEL BY ATTACH COMMAND, AND AT M LEVEL
;BY REFERENCES TO DEVICE "TTY" OR TTCALLS, ETC.

;CALL:	MOVE J,JOB NUMBER DESIRED
;	PUSHJ P,TTYSRC
;	  ERROR RETURN.	;NOT FOUND. AC'S U,F,S NOT GUARANTEED
;	NORMAL RETURN	;U, S AND F SET UP. NOTE THAT THIS DOES
;			;!NOT! IMPLY THAT ANYONE IS ATTACHED. THAT IS,
;			; U MAY CONTAIN A ZERO


TTYSRC::JUMPE	J,CPOPJ		;NOBODY CONTROLS JOB ZERO. YOU ARE CONFUSED.
	HRRZ	F,TTYTAB(J)	;REALLY MUST BE HERE
	JUMPE	F,CPOPJ
	HRRZ	U,DDBLDB(F)
	MOVE	S,DEVIOS(F)	;SET UP I/O STATUS AND LINE
	JRST	CPOPJ1
SUBTTL	SUBROUTINE TTYERP TO FIND TTY DDB FOR A MONITOR ERROR MSG
;CALL WITH J SET TO JOB NUMBER. IF JOB IS ZERO OR JOB
;IS DETACHED USER OPRLDB. IF NOT EVEN THAT IS THERE,
;GIVE RETURN. NORMAL RETURN IS SKIP.  (called from ERRCON)

TTYERP::PUSHJ	P,TTYSRC	;FIND DDB OF JOB'S TTY (SET F, U, AND S)
	  JRST	GETCTY		;CAN'T FIND IT
	JUMPN	U,CPOPJ1	;SKIP RETURN IF ATTACHED
				;Nonskip means should use OPROUT with 2

;GETCTY USED BY PICON TO REPORT PARITY ERROR IN USER CORE
;Output buffer flushed if too many messages queued up.
;Changes U and F only.

GETCTY::MOVEI	U,CTYLDB	;GET CTY'S LDB
	PUSH	P,T1
	PUSH	P,T2
	MOVE	T1,LDBTOC(U)	;CHECK CURRENT COUNT
	CAILE	T1,^D140
	 PUSHJ	P,TSETBO	;TOO BIG, CLEAR
	POP	P,T2
	POP	P,T1
	HRRZ	F,LDBDDB(U)
	POPJ	P,
SUBTTL	FIND A USER AND WAIT FOR ATTACH OR OUTPUT WAIT TO FINISH

TTYFUW::PUSHJ P,TTYFNU
TTYFW1:	PUSHJ P,CKATTF		;WAIT FOR ATTACH
	MOVE T1,LDBTOC(U)	;HAVE TO PUT IT IN HERE SO
	CAIG T1,10		;DOES OT CALL SCNINT
	POPJ P,
TOWATA:	MOVE S,[XWD TTYOUW+IO+TIOUSE,IOACT]
	IORB S,DEVIOS(F)
	PUSH P,P1
	PUSH P,P2
	PUSHJ P,WSYNC
	POP P,P2
	POP P,P1
	MOVSI S,TIOUSE
	ANDCAB S,DEVIOS(F)
	POPJ P,

TTYSOW::MOVE S,[XWD TTYOUW+IO,IOACT]
	IORB S,DEVIOS(F)
	POPJ P,
SUBTTL	SUBROUTINE TO FIND LDB FOR A PHYSICAL NAME, IF ITS A TTY
;AND LOAD F WITH LINKED DATA BLOCK, IF ANY, BUT DONT MAKE ONE IF NONE YET
;SKIP RETURN IF ITS A TTY

TTYPHY::CAMN	T1,[SIXBIT /OPR/]	;TALK TO OPERATOR?
	 MOVE	T1,DEVOPR		;YES. GET REAL DEVICE NAME
	HLLZ	U,T1			;GET FIRST THREE CHARACTERS
	CAMN	U,[SIXBIT /TTY/]	;ARE THEY TTY?
	TRNN	T1,770000		;AND ALSO IS FOURTH CHAR NON-BLANK?
	 POPJ	P,			;NO. NOT A LEGAL NAME.
	PUSH	P,T1			;YES. MAY BE LEGAL.
	HRLZS	0(P)			;PUT THE RIGHT THREE CHARS ON STACK
	PUSH	P,[POINT 6,-1(P)]	;POINTER TO READ CHARS
	MOVEI	U,0			;INITIALIZE U TO 0
TTYPH4:	ILDB	T1,0(P)			;GET A SIXBIT CHARACTER FROM NAME
	JUMPE	T1,TTYPH2		;JUMP IF END OF NAME.
	TRC	T1,'0'			;CONVERT SIXBIT TO BINARY
	CAILE	T1,7			;IS IT AN OCTAL DIGIT?
	 JRST	TTYPH3			;NO. BAD CHAR IN NAME
	ASH	U,3			;MULTIPLY BY 8
	ADDI	U,0(T1)			;ADD IN THIS DIGIT
	JRST	TTYPH4			;LOOP FOR MORE DIGITS

TTYPH3:	POP	P,T1			;HERE ON BAD CHAR. CLEAR OUT STACK
	JRST	TPOPJ			;AND RETURN TO ERR RET

TTYPH2:	POP	P,T1			;HAVE AN OCTAL NUMBER. DISCARD
	POP	P,T1			; TWO ITEMS FROM STACK
	CAIL	U,PORTN##		;IS IT A LEGAL HARDWARE LINE #
	 POPJ	P,			;NO. TOO BAD.
	HRRZ	U,LINTAB(U)		;GET LINE DATA BLOCK ADDRESS
	HRRZ	F,LDBDDB(U)		;GET ATTACHED F, IF ANY.
	JRST	CPOPJ1			;GOOD RETURN

;ROUTINE TO GET A DDB. CALLED IN DEVSRCH ROUTINES

GETDDB::PUSHJ	P,TTYPHY	;FIND THE TELETYPE BY NUMBER
	  POPJ	P,		;NOT A REAL TTY
	JUMPE	F,CPOPJ		;NOT REALLY THERE YET
	MOVE	T1,DEVNAM(F)	;IF SOMEONE ELSES WILL BE
	JRST	CPOPJ1		;ASSIGNED BY CONSOLE SO CAN'T HAVE IT ANYWAY
SUBTTL	SUBROUTINE TO PUT PHYSICAL NAME INTO T2 FOR LINE WHOSE LDB IS IN U
;EVEN THOUGH THERE MAY BE NOTHING IN F OR LDBDDB

TTYNAM::LDB	T1,LDPLNO		;GET LINE NUMBER
	PUSH	P,[SIXBIT /TTY/]	;PUT NAME ON STACK
	MOVEI	T3,0(P)			;PREPARE ARG FOR SCNNMR
	HRLI	T3,220600		;POINT 6,0,17
	PUSHJ	P,SCNNMR		;AND CALL SAME ROUTINE AS SCNNAM DOES
	POP	P,T2			;PUT ANSWER IN T2
	POPJ	P,			;AND RETURN FROM TTYNAM

;SUBSIDIARY ROUTINE TO DO RADIX PRINT TO CORE.

SCNNMR:	IDIVI	T1,10			;DEVICE NAMES ARE OCTAL
	HRLM	T1+1,0(P)		;STORE A DIGIT ON STACK
	SKIPE	T1			;NEED MORE DIGITS?
	 PUSHJ	P,SCNNMR		;YES. GO MAKE THEM.
	HLRZ	T1,0(P)			;RETRIEVE A DIGIT FROM STACK
	ADDI	T1,'0'			;CONVERT TO SIXBIT
	IDPB	T1,T3			;STORE IN OBJECT WORD (DEVNAM)
	POPJ	P,0			;POP UP TO SCNNMR OR BACK TO SCNNAM
SUBTTL	SETUUO OUTPUT MESSAGE TO OPR TTY & CTY *BOTH*, IF POSSIBLE.
;OTHERWISE JUST TO CTY.

OPRSND::HRRZ	M,T1
	HRLI	M,(POINT 7,0)
OPRSN2:	SKIPN	U,OPRLDB	;GET OPR
	 MOVEI	U,CTYLDB	;NONE, GO TO CTY ONLY
	MOVE	T1,LDBTOC(U)
	IOR	T1,CTYLDB+LDBTOC;WAIT IF EITHER OPR TTY OR CTY
	JUMPN	T1,OPRWAT	;IS BUSY (OUTPUT BUFF NOT-EMPTY)
				;UNWAIT WHEN ONE OR THE OTHER
				;BECOMES EMPTY
OPSND1:	XCTFU	<ILDB T3,M>
	JUMPE	T3,CPOPJ1	;DONE
	PUSHJ	P,CCTYO		;SAME OUTPUT RESTRICTIONS AS COMMAND
	SKIPN	OPRLDB		;SKIP IF GOING TO BOTH
	 JRST	OPSND1		;JUST TO CTY, ALREADY DONE
	MOVEI	U,CTYLDB
	XCTFU	<LDB T3,M>	;GET SAME CHAR JUST SENT,
	PUSHJ	P,CCTYO		;& PUT IT ON CTY
	MOVE	U,OPRLDB	;RESTORE U
	JRST	OPSND1

OPRWAT:	MOVEI	T1,MLOWQ	;WAIT FOR OPR BUFFER TO EMPTY
	DPB	T1,PJBSTS##	;SET TO MON WAIT QUE
	HRRZ	T1,OPRWJB	;GET WAITING JOB IF ANY
	MOVEM	T1,QUEPCB(J)	;PUT ON QUE
	HRRZM	J,OPRWJB	;AND SET CURRENT
	PUSHJ	P,WSCHED
	JRST	OPRSN2		;RESTARTED. ONE OF THEM JUST BECAME
				;FREE. GO CHECK AGAIN MAKE SURE BOTH FREE.

;Here when the OPR terminal is free to do more output
;Uses T1 and T2 only

OPRFRE::SKIPN	T2,OPRWJB
	 POPJ	P,		;NONE WAITING
	SETZM	OPRWJB		;RESTART ALL WAITERS
	PUSH	P,J
OPRFR1:	MOVE	J,T2
	MOVEI	T1,RNQ
	DPB	T1,PJBSTS##
	PUSHJ	P,SETRUN
	HRRZ	T2,QUEPCB(J)
	SETZM	QUEPCB(J)	;ZERO OLD ENTRY
	JUMPN	T2,OPRFR1	;ANY MORE?
	POP	P,J
	POPJ	P,		;DONE
SUBTTL	SUBROUTINE FOR THE TTY COMMAND

;ON ENTRY P1 HAS LDB TO DO THINGS FOR, T2 HAS COMMAND

SCNTCD::MOVSI	T1,-TTCWDN	;GET LENGTH OF COMMAND TABLE
	CAME	T2,TTCWDT(T1)
	 AOBJN	T1,.-1
	JUMPG	T1,CPOPJ1	;NOT FOUND, TAKE ERROR RETURN
	HRRZ	T2,TTCWDD(T1)	;GET DISPATCH
	JRST	(T2)		;AND GO


TTCWDT:	SIXBIT /NO/
TTYTBL::SIXBIT /TAB/
	SIXBIT /FORM/
	SIXBIT /LC/
	SIXBIT /FILL/
	SIXBIT /ECHO/
	SIXBIT /CRLF/
	SIXBIT /WIDTH/
	SIXBIT /XON/
	SIXBIT /TAPE/
	SIXBIT /FILL1/
	SIXBIT /FILL2/
	SIXBIT /IN/
	SIXBIT /OUT/
	SIXBIT /A/
	SIXBIT /B/
	SIXBIT /C/
	SIXBIT /D/		;Was /TYPE/
	<SIXBIT /BACKSPACE/>
	SIXBIT /ERASE/
	SIXBIT /RXE/
	SIXBIT /DEF/
	SIXBIT /UCO/
	SIXBIT /BSD/
	SIXBIT /RBS/
	SIXBIT /CLASS/		; [dws]
	SIXBIT /RTCOMP/		;[Darren]
	SIXBIT /KATAKA/		;KATAKANA (JIS-8 ASCII) mode
	SIXBIT /TYPE/		;Type of terminal
TTCWDN==.-TTCWDT
TTYMXL==:<TTCWDN-1-1>_^D9

TTCWDD:	XWD 0,TTCNO		;LH MAY HAVE A BIT TO SET/RESET
	XWD TCNTAB,TTCSET
	XWD TCNFRM,TTCSET
	XWD TCNLCT,TTCCLR
	XWD 0,TTCFIL
	XWD TCNHDX,TTCCLR
	XWD TCNNFC,TTCCLR
	XWD TCNWID,TTCVAL
	XWD TCNPTP,TTCSET
	XWD TCNPTP,TTCSET
	XWD TCNFC1,TTCVAL
	XWD TCNFC2,TTCVAL
	XWD TCNIR,TTCVAL
	XWD TCNOR,TTCVAL
	XWD TCNPA,TTCVAL
	XWD TCNPB,TTCVAL
	XWD TCNPC,TTCVAL
	XWD TCNPD,TTCVAL	;Parameter D (formerly TCNTYP)
	XWD TCNBSP,TTCSET
	XWD TCNERA,TTCSET
	XWD TCNRXE,TTCSET
	XWD TCNDEF,TTCSET
	XWD TCNLCO,TTCCLR
	XWD TCNBSD,TTCSET
	XWD TCNECH,TTCSET
	XWD TCNCLA,TTCSIX	;Class
	XWD TCNRTC,TTCSET	;RTcompatibility
	XWD TCNKAT,TTCSET	;Katakana mode
	XWD TCNTYP,TTCTYP	;TYPE is a number or a sixbit value
SUBTTL	SET TTY routines

TTCNO:	TLC	P1, -1		;COMPLEMENT YES-NO FLAG
	POPJ	P,

;BIT-VALUED CHARACTERISTICS

TTCCLR:	TLC	P1,-1		;OPPOSITE OF SET
TTCSET:	HLRZ	T1,TTCWDD(T1)	;T1/ TC# FOR SETTCN
	JUMPL	P1,TTCDO1	;RESETTING THE BIT
	MOVEI	T2,1
	PUSHJ	P,TTCGO
	  AOS	(P)
	POPJ	P,
TTCDO1:	SETZ	T2,
	PUSHJ	P,TTCGO
	  AOS (P)
TTCFIN:	HRRZS	P1		;Clear "NO" flag
	POPJ	P,

;DECIMAL-VALUED CHARACTERISTICS

TTCVAL:	PUSH	P,T1
	JUMPL	P1,TTCVL0	;"NO" = 0
	PUSHJ	P,DECIN1##	;T2 := DECIMAL NUMBER
	  JRST	TPOPJ1	
	  JRST	TPOPJ1		;NO NUMBER OR BAD NUMBER
	JRST	TTCVL1
TTCVL0:	SETZ	T2,
TTCVL1:	POP	P,T1		;T1/ VALUE FROM DISPATCH
TTCVL2:	HLRZ	T1,TTCWDD(T1)	;T1/ TC# FOR SETTCN
TTCVL3:	PUSHJ	P,TTCGO
	  AOS	(P)
	POPJ	P,

;[dws] Sixbit-valued characteristics

TTCSIX:	PUSH	P,T1		; save T1
	SKIPGE	P1		; skip if "No" not seen
	 TDZA	T2,T2		;  "No" = blanks
	PUSHJ	P,CTEXT1##	; T2 := sixbit text
	POP	P,T1		; T1/ value from dispatch
	JRST	TTCVL2		; Go set it

;Treat SET TTY TYPE specially for Japanese customers

TTCTYP:	PUSH	P,T1		; save T1
	SKIPGE	P1		; skip if "No" not seen
	 TDZA	T2,T2		;  "No" = blanks
	PUSHJ	P,CTEXT1##	; T2 := sixbit text
	POP	P,T1		; T1/ value from dispatch
	CAME	T2,[SIXBIT /0/]	;Old "TTY TYPE 0" command?
	CAMN	T2,[SIXBIT /1/]	;Old "TTY TYPE 1" command?
	 SKIPA			;Yes
	  JRST	TTCVL2		;No, just store value
	LSH	T2,^D<5-35>	;Yes, right justify number
	ANDI	T2,7		;Keep as 0 or 1
	MOVEI	T1,TCNPD	;Act like "SET TTY D 1" command
	JRST	TTCVL3		;Go set parameter "D" for KATAKANA

TTCGO:	PUSH	P,U		;T1/ TCNxxx (PDP-10 TC number)
	HRR	U,P1		;U/ LDB ADDR
	HLL	U,LDBDCH(U)
	PUSHJ	P,SETTC1	;GO SET THE TC
	  JRST	.+2
	AOS	-1(P)		;TRANSFER THE SKIP-RETURN
	POP	P,U
	POPJ	P,
SUBTTL	FOR OLD TIME'S SAKE (SET FC1 AND FC2 FROM THE SAME VALUE)

TTCFIL:	JUMPL	P1,TTCFL0
	PUSHJ	P,DECIN1##
	  JRST	CPOPJ1
	  JRST	CPOPJ1
	JRST	TTCFL1
TTCFL0:	SETZ	T2,
TTCFL1:	MOVEI	T1, TCNFC1
	PUSHJ	P, TTCGO
	  JRST	CPOPJ1
	MOVEI	T1, TCNFC2
	PUSHJ	P, TTCGO
	  AOS	(P)
	POPJ	P,
SUBTTL	CALLED FROM COMCON TO SET TO SEND SHUT OR ANSWERED MESSAGE

SETSHT::MOVSI	T1,TYPI TYPSHT	;SET TO SAY SHUT
	MOVEI	T2,STSHUT	;400000
	TDNN	T2,STATES	;IS THAT THE STATE
	 MOVSI	T1,TYPI TYPANS	;YES, SO SAY ANSWERED
	MOVEM	T1,UPSHUT
	TDNN	T2,STATES	;UP OR DOWN?
	 JRST	CKOPR		;UP, SEE IF DEVOPR SET
	SETZM	OPRTIM		;DOWN, TURN OFF TIMER
	MOVEI	T2,ALROPR
	ANDCAM	T2,ALR620	;AND ALARM
	POPJ	P,

CKOPR:	SKIPE	DEVOPR
	 POPJ	P,		;DEVOPR SET, ALL OK
	MOVEI	T2,^D90		;SET FOR 90 SEC TILL ALARM
	MOVEM	T2,OPRTIM
	POPJ	P,

;CALLED TO SEE IF WAITING FOR LOGOUT SO CAN NOT SET JACCT2

CKLGO::	HRRZ F,TTYTAB(J)
	JUMPE F,CPOPJ1		;NO DDB, SAY OK TO SET
	HRRZ U,DDBLDB(F)
	JUMPE U,CPOPJ1		;NO LINE, CAN NOT BE WAITING
	MOVSI T4,LLLZAP
	TDNN T4,LDBLOG(U)	;SEE IF ZAPPER RECEIVED FLAG SET
	 AOS (P)		;NO, OK
	POPJ P,
SUBTTL	SEND A SAD MESSGE

SNDSAD:	MOVE	T1,ALR620
	CAMN	T1,ALRSNT
	  JRST	CPOPJ1		;NOT SENT
	PUSH	P,T1		;SAVE T1 FROM BEING CLOBBERED.
	PUSHJ	P,CLSCHR	;FINISH UP CHARACTER OUTPUT.
	 JRST	TPOPJ		;NO MORE ROOM.
	MOVE	T2,ORPPDP	;PICK UP THE OUTPUT RING POINTER.
	ADDI	T2,2		;THIS OPERATION REQUIRES 2 WORDS.
	ANDI	T2,MSKORG	;MASK FOR WRAP AROUND.
	CAMN	T2,ORP620	;MAKE SURE THERE'S ROOM.
	  JRST	TPOPJ		;NO MORE ROOM.  FINISH SCANNING LINE.
	POP	P,T1		;RESTORE T1
	MOVEM	T1,ALRSNT	;SAY WE SENT THAT ONE
	MOVSI	P3,TYPI TYPSAD
	LDB	T1,[POINT 16,ALR620,15]
	DPB	T1,[POINT 16,P3,BYP4]
	MOVEM	P3,ORING(P4)
	PUSHJ	P,ORPLOG	;Put message into ORING log
	ADDI	P4,1
	ANDI	P4,MSKORG	;POINT TO CORRECT LOCATION (POSSIBLE WRAP)
	LDB	T1,[POINT 16,ALR620,31]
	DPB	T1,[POINT 16,P3,BYP2]
	PUSHJ	P,WRDOT2	;WRITE 2ND WORD AND CLEAN UP
	  POPJ	P,		;NO MORE ROOM.  CALL FINOUT.
	JRST	CPOPJ1		;CONTINUE SCAN.
SUBTTL ATTACH/DETACH

;TTYKIL - ACTUALLY TWO ROUTINES
;
;1)	CALLED WITH F/ 0, U/ LDB ADDR TO ZAP LINE WHENEVER A
;	COMMAND HAS JUST BEEN FORCED ON A NON-JOB (E.G.,
;	WHEN JOB CAPACITY IS EXCEEDED), AND, BY SOME QUIRK
;	OF FATE, AFTER EVERY DETACH COMMAND (BECAUSE COMCON
;	RELOADS F FROM LDBDDB(U) AND INCORRECTLY THINKS
;	F/ 0 = NO JOB)
;
;2)	CALLED WITH F/ DDB ADDR, U/ ANYTHING TO ZAP THE
;	ATTACHED PORT, IF ANY, AND FREE THE COMMAND PORT DDB
;	OF A JOB BEING KILLED.

TTYKIL::JUMPE	F,TTYZAP	;IF THERE'S NO JOB (CASE 1): ZAP IT

;(CASE 2) FREE THE DDB, THEN ZAP THE CIRCUIT

	SETZM	DEVNAM(F)
	SETZM	DEVLOG(F)
	LDB	T1,PJOBN
	SKIPE	T1
	SETZM	TTYTAB(T1)	;MAKE SURE MARKED AS NO DDB
	MOVSI	T1,IOFST
	MOVEM	T1,DEVIOS(F)
	DPB	T1,PJOBN	;THIS WILL SET TO JOB 0
	HRRZ	U,DDBLDB(F)	;CHECK FOR A LINE ATTACHED
	JUMPE	U,TTYKDB	;DETACHED ALREADY?

    ; U/ 0,,LDB ADDR
    ;HERE WHEN WE'RE TTYKILLING AN ATTACHED DDB

	HLLZS	LDBDDB(U)	;DISCONNECT LINE FROM F
	PUSHJ	P,TTYZAP	;ELSE ZAP THE CIRCUIT
	PFALL	TTYKDB
SUBTTL	TTYKDB - CLEAR LDB PTR AND ASSIGNMENT & USE BITS FOR A TTY DDB
;	   (ADDR IN F), AND RETURN IT TO THE FREE POOL

TTYKDB:	JUMPE	F,CPOPJ
	HLLZS	DDBLDB(F)	;NO F FROM U
	MOVE	T1,[XWD TTYATC,ASSCON!ASSPRG]
	ANDCAM	T1,DEVMOD(F)	;CLEAR OUT ALL USE AND ASSIGN BITS
	HLRZ	T2,DDBBLK(F)	;GET BACK LINK
	HLRZ	T1,DEVSER(F)	;AND FORWARD LINK
;;Start of debug code;;
	MOVEM	F,XXCDDB	;Current DDB pointer
	MOVEM	T1,XXNDDB	;Next DDB pointer
	MOVEM	T2,XXPDDB	;Previous DDB pointer
	PUSH	P,DEVSER(F)	;Current forward link
	POP	P,XXCSER
	PUSH	P,DDBBLK(F)	;Current backward link
	POP	P,XXCBLK
	PUSH	P,DEVSER(T1)	;Next forward link
	POP	P,XXNSER
	PUSH	P,DDBBLK(T1)	;Next backward link
	POP	P,XXNBLK
	PUSH	P,DEVSER(T2)	;Previous forward link
	POP	P,XXPSER
	PUSH	P,DDBBLK(T2)	;Previous backward link
	POP	P,XXPBLK
;;End of debug code;;
	HRLM	T1,DEVSER(T2)	;LINK AROUND DDB
	PUSH	P,T3
	MOVE	T3,DEVMOD(T1)	;IS NEW DEST. ALSO A TTY?
	TLNE	T3,DVTTY!DVRMT
	 HRLM	T2,DDBBLK(T1)	;YES, SET ITS BACK POINTER
	POP	P,T3
	MOVE	T1,FRETTY
	HRLM	T1,DEVSER(F)	;AND LINK INTO FREE POOL
	HRRZM	F,FRETTY
	HRRZ	F,T2		;POINT TO PRED FOR LINKING
;Check that the DDB chain ends properly
	HLRZ	T1,DEVLST##	;Beginning of DDB chain
	MOVEI	T2,^D10000	;Paranoid loop counter
TTYKD1:	JUMPE	T1,CPOPJ	;Quit when end of chain is found
	HLRZ	T1,DEVSER(T1)	;Point to next DDB
	SOJG	T2,TTYKD1	;Look for end
DDBCNE:: STOPCD (.,STOP,DDBCNE,,<DDB chain has no end>) ;;TTYKDB+many
	POPJ	P,

XXCDDB:	0			;Current DDB pointer
XXCSER:	0			;DEVSER word with forward pointer
XXCBLK:	0			;DDBBLK word with backward pointer
XXNDDB:	0
XXNSER:	0			;Ditto for next DDB
XXNBLK:	0
XXPDDB:	0
XXPSER:	0			;Ditto for previous DDB
XXPBLK:	0
SUBTTL	TDTUUO - HERE FROM ATTACH UUO WHEN DETACHING THE COMMAND PORT
;	   (J/ JOB NUMBER)

TDTUUO::PUSHJ	P,TTYSRC	;FIND F
	 POPJ	P,		;NONE THERE
	JUMPE	U,CPOPJ		;MUST NOT BE WAITING FOR LOGOUT
	MOVSI	T1,LLLZAP
	TDNE	T1,LDBLOG(U)
	 POPJ	P,
	PFALL	TTYDET

;TTYDET - DETACH A TTY DDB (ADDR IN F)

TTYDET::HRRZ U,DDBLDB(F)	;GET LDB ADDR
	HLLZS DDBLDB(F)		;AND CLEAR LINK
	HRRZS DEVNAM(F)		;SAVE PORT # BUT CLEAR "TTY"
				;SO DEVICE SEARCH DOESN'T FIND IT
	MOVEI	T1, 1
	DPB	T1, DDPCOM	;SHOULD RE-ATTACH IN CMND MODE
	JUMPE U,CPOPJ		;NO LINE TO SEND ZAPPER ON
	HLLZS LDBDDB(U)		;CLEAR LDB TO DDB LINK
	PJRST TTYZAP		;  SEND A ZAPPER ON IT

;TYCIOS - called by CLOCK1 to clear ALL tty's IOS

TYCIOS::PUSHJ P,FRSTTY
	  POPJ P,	
	JRST TYIOS2		;include command port

TYIOS1:	PUSHJ P,NXTTTY	;THIS WILL BE AUX CIR OR RMT
	  POPJ P,	;FINISHED, NONE THERE
TYIOS2:	MOVSI T1,DVRMT
	TDNE T1,DEVMOD(F)
	JRST	[MOVE S,[IOW,,IOACT]	;RESET BITS FOR RMT
		ANDCAM S,DEVIOS(F)
		JRST TYIOS1]	;NEXT
	MOVE S,[IOW+TIOUSE,,IOACT]
	ANDCAM S,DEVIOS(F)	;RESET ALL BITS INCLUDING USE
	MOVE T1,[TTYATC,,ASSCON+ASSPRG]
	TDNN T1,DEVMOD(F)	;ANY REASON TO KEEP IT
	PUSHJ P,TTYKDB		;NO, GET RID OF IT
	JRST TYIOS1

;IFDET - CALLED FROM EXIT UUO: IF DETACHED, SKIP, ELSE DO A
;	  TTYFUW AND NONSKIP-RETURN

IFDET::	PUSHJ P,TTYFND
	JUMPE U,CPOPJ1	;IS DETACHED
	JRST TTYFW1	;FINISH THE TTYFUW
SUBTTL	TTYZAP - ZAP A CIRCUIT (U/ LDB ADDR).

;Whenever a zapper originates from the PDP-10, then a yellow ball is
;sent out first to make sure that the zapper does not gobble any of the
;logout messages.  In this case, a 20-second timer is started and the
;zapper is not sent until an orange ball is reflected by the TYMSAT.
;
;Whenever a zapper originates from TYMNET, the base has already given up
;on the port and marks is as being "in clean up" until we return the zapper.
;
;In either case, the line is marked as "not in use" when we send a zapper.
;We must respond to incoming zappers, but the base sends no response to
;an outgoing zapper.

;Change in P035/D05 - don't send yellow ball if line is not marked in use,
;because base will ignore it and we will be waiting 20 seconds for an orange
;ball that will never come in.  However, if a login just happens to come in
;while we are waiting, it used to cause TTYZNE and/or a base crash.
;Also: EBUS version 2.0 did not range-check zappers.  When B39 was configured
;for 128 ports and its base for 127, the base would crash when a zapper
;was sent out on TTY177.

TTYZAP:	MOVEI	T2,1
	MOVE	T1,LDBLOG(U)	;Get TYMNET status of line
	JUMPGE	T1,TTYZP1	;No yellow/orange if port not in use
	TLNN	T1,LLLNLN	;Send yellow ball and wait for orange to be
	 DPB	T2,LOPSYL	; reflected (unless zap came from base)
TTYZP1:	DPB	T2,LOPZAP	;Set flag to send zapper
	DPB	T2,LDBOPB(U)	;Mark line as needing output
	MOVSI	T1,LDLNOP
	ANDCAM	T1,LDBDCH(U)	;Ignore backpressure
	MOVSI	T1,LMLBIO
	TDNE	T1,LDBMOD(U)	;If it's in block I/O mode,
	 PUSHJ	P,BIOREL	; get it out
	POPJ	P,
SUBTTL	TTYATT - ATTACH LDB TO JOB
;	   U/ LDB  J/ JOB#
;	   SKIP-RETURNS ON SUCCESS WITH F/ CMND PORT DDB
;	   NONSKIP-RETURNS ON FAILURE WITH F/ 0

TTYATT::PUSH	P,U
	MOVEI	F,0		;RET 0 IN CASE DONT FIND TTY DDB
	PUSHJ	P,TTYSRC	;FIND THE F FOR THAT JOB
	  JRST	LPOPJ		;NONE, SHOULD NOT HAVE GOTTEN HERE
	JUMPE	U,TTYAT1	;WAS THERE ANYONE ATTACHED
LPOPJ:	POP	P,U		;YES, NOONE CAN DO THIS FOR NOW
	POPJ	P,

COMMENT ! TTYATI - CALLED TO DO INITIAL ATTACH WHEN
	PROCESSING LOGIN.
EXPECTS:  U/ LDB ON WHICH LOGIN APPEARED
	  J/ JOB SLOT TO WHICH WE WANT TO ATTACH IT
CLOBBERS: T1 - T4
RETURNS: CPOPJ IF CANNOT ATTACH. F/0 IF NO TTYDDB'S, F/DDB IF
		BECAUSE ALREADY ATTACHED
	 CPOPJ1 IF SUCCESS, F/DDB
!


TTYATI:	PUSH P,U
	PUSHJ P,TTYSRC	;CHECK FOR A F FOR THIS JOB
	 PUSHJ P,DDBSRC	;NONE, FIND A FREE ONE
	  JRST LPOPJ	;NO FREE F OR JOB ALREADY HAS ONE, GIVE ERROR RETURN
TTYAT1:	MOVE U,0(P)	;RESTORE LINE USER IS NOW ON
	PUSH P,F
	HRRZ F,LDBDDB(U)	;DOES IT HAVE A F?
	JUMPE F,TTYAT2	;NO, JUST DO THE ATTACH
	HLLZS DDBLDB(F)	;GET RID OF LINK TO LINE SO
	HRRZS DEVNAM(F)	;MAKE SURE LEFT OF NAME ZEROED
TTYAT2:	POP P,F		;NOW RESTORE F HE GOES TO
	POP P,U
	MOVE T1,[XWD TTYATC,ASSCON]	;ASSIGN IT
	IORM T1,DEVMOD(F)
	DPB J,PJOBN		;SET JOB ASSIGNED TO
	MOVE T1,TIMRST##	;RESET ANY WAITING HANG
	DPB J,CLKJOB##		;WHICH MAY EXIST IN CLOCK QUEUE
	PUSHJ P,CHGCLK		;FOR PREVIOUS OWNERS OF THIS JOB SLOT
	HRRZM F,TTYTAB(J)	;SET TTYTAB UP
	PUSHJ P,SCNNAM		;FILL IN NAME OF TTY F
	PUSHJ	P, COMATT	;JOIN F AND U
	JRST CPOPJ1		;AND TAKE GOOD RETURN
SUBTTL	 HERE FROM THE ATTACH UUO IF IT'S ATTACHING
; T1/ USERMODE,,JOB# WHERE USERMODE IS 1 TO
; ATTACH THE PORT IN USER MODE AND 0 TO ATTACH
; IT IN COMMAND MODE

TATUUO::PUSH	P,T1
	PUSHJ	P,TTYSRC	;FIND F FOR THIS JOB
	  JRST	TPOPJ		;CAN NOT ATTACH, NO F
	HRRZ	U,DDBLDB(F)
	JUMPE	U,TPOPJ		;GIVE UP
	MOVSI	T1,LLLZAP
	TDNE	T1,LDBLOG(U)
	 JRST	TPOPJ		;DO NOT ALLOW IF WAITING FOR LOGUT
	HRRZ	J,0(P)		; J/ 0,,TARGET JOB#
	PUSHJ	P,TTYATT	;Attach our old line to new job
	  JRST	TPOPJ		;CANNOT ATTACH
	POP	P,T1		;T1/USERMODE,,TARGET JOB#
	AOS	(P)
	PUSH	P,T1
	TLNE	T1,(1B15)	;does user want frame continued?
	 PUSHJ	P,RTCONT	;yes - do it
	POP	P,T1
	TLNE	T1,(1B17)	;WANTS USER MODE?
	 JRST	TATUU1		;YES.
	PUSHJ	P,PRPRMT##	;GIVE HIM A PERIOD OR HYPHEN
	PUSHJ	P,CNCMOD	;FORCE TO COMMAND LEVEL
	JRST	TTYSTC		;AND GO

TATUU1:	MOVSI	T1,LDLCOM
	ANDCAM	T1,LDBDCH(U)	; PUT INTO USER MODE
	PUSHJ	P,SETLMD
	POPJ	P,		; SKIP-RETURN ((P) AOS'D ABOVE)


; RTCONT - call here to make sure target frame is running.
; Called in response to user request by ATTACH UUO and RETACH UUO.
; Expects J/ target JOB #.
; Clobbers T1 alot.

RTCONT:	SKIPGE	T1,JBTSTS(J)	;check if its already running
	 POPJ	P,		;yep! nothing to do
	TLNE	T1,JERR		;can't continue if JERR set
	 POPJ	P,
	PJRST	SETRUN		;resume execution in target and return

COMMENT @

RETACH UUO - MOVE A TTY SOMEWHERE ELSE

	MOVEI	AC, [
		SOURCE FRAME,,TARGET FRAME
		BITS,,PORT
	]
	RETACH	AC,
	  ERROR RETURN	;AC/ ERROR CODE
	NORMAL RETURN	;AC/ PORT# OF PORT MOVED (FROM RH(DEVNAM))

	<BITS> = 1B0 TO ATTACH AS AUX/SLAVE PORT RATHER THAN
		     AS CMND PORT (MUST BE SIGN BIT)
	       + 0B2 TO ATTACH ACCORDING TO SAVED CMND MODE STATE
		 1B2 TO ATTACH IN CURRENT COMMAND MODE STATE
		 2B2 TO FORCE COMMAND MODE
		 3B2 TO FORCE USER MODE
	       + 1B3 TO SIGNAL A HANGUP ON THE SOURCE FRAME

	<ERROR CODE> = (SEE DEFINITIONS BELOW)
@

RT.SLV==400000
RT.MOD==300000
  DEFINE RTYMOD(X) = <[POINT 2,X,2]>
  .RTMSV==0
  .RTMCU==1
  .RTMCO==2
  .RTMUS==3
RT.SIG==040000
RT.CON==020000

RTSAC%==1	;INSUFFICIENT ACCESS TO SOURCE FRAME
RTSNX%==2	;SOURCE FRAME DOES NOT EXIST
RTTAC%==3	;INSUFFICIENT ACCESS TO TARGET FRAME
RTTNX%==4	;TARGET FRAME DOESN'T EXIST
RTSNA%==5	;PORT NOT ATTACHED TO SOURCE FRAME
RTTAT%==6	;PORT ALREADY ATTACHED TO TARGET FRAME
RTSCP%==7	;FORCED COMMAND PENDING ON PORT
RTAUX%==10	;ATTACHING AUX CIRCUIT AS CMND PORT
RTNRM%==11	;NO ROOM FOR NEW DDB
SUBTTL	RETACH uuo

RETACH::XCTFU <MOVE P1,0(T1)>	;P1/ SOURCE,,TARGET
	XCTFU <MOVE P2,1(T1)>	;P2/ BITS,,PORT

    ;CHECK ACCESS TO SOURCE FRAME

	HLRZ	P4, P1		;P4/ SOURCE FRAME DESC
	HRRZI	P3, .ARDET
	PUSHJ	P, FARCHK##	;MAY WE DETACH FROM THE SOURCE?
	  JRST	[
		MOVEI	T1, RTSAC%
		JRST	RTERR
	]
	MOVSI	T1, JNA
	TDNN	T1, JBTSTS(J)	;IS THE SOURCE JOB THERE?
	 JRST	[
		MOVEI	T1, RTSNX%
		JRST	RTERR
	]
	HRLM	J, P1

    ;CHECK ACCESS TO TARGET FRAME

	HRRZ	P4, P1		;P4/ TARGET FRAME DESC
	HRRZI	P3, .ARATT
	PUSHJ	P, FARCHK##	;MAY WE ATTACH TO THE TARGET?
	  JRST	[
		MOVEI	T1, RTTAC%
		JRST	RTERR
	]
	MOVSI	T1, JNA
	TDNN	T1, JBTSTS(J)	;IS THE TARGET JOB THERE?
	 JRST	[
		MOVEI	T1, RTTNX%
		JRST	RTERR
	]
	HRRM	J, P1
    ;SAVE THE CALLER'S JOB #

	PUSH	P, J

    ;GET THE PORT BEING MOVED

	HLRZ	J, P1		;J/ SOURCE FRAME #
	HRRE	F, P2		;F/ SOURCE PORT DESCRIPTOR
	PUSHJ	P, FNDPRT	;SET F/ DDB ADDR. IF NO DDB
	  JRST	RETCH1
	HRRZ	U, DDBLDB(F)
	JUMPN	U, RETCH2	;OR IF IT IS DETACHED
RETCH1:	MOVEI	T1, RTSNA%
	JRST	RTERJ		;  RESTORE J AND ERROR-RETURN

    ;J/ SOURCE FRAME#  F/ SOURCE DDB  U/ LDB

RETCH2:	SKIPGE	LDBDDB(U)	;IF LINE HAS PENDING COMMANDS,
	 JRST	[
		MOVEI	T1, RTSCP%
		JRST	RTERJ	;  RESTORE J AND ERROR-RETURN
	]
	LDB	T1, LDPCOM
	DPB	T1, DDPCOM	;SAVE CMND MODE STATE
	PUSHJ	P, NAMSCN	;T1 := PORT # FROM RH(DEVNAM)
	UMOVEM	T1, (M)		;GIVE IT TO CALLER
	HRRZ	J, P1		;J/ TARGET FRAME #
	HRRM	F, P2		;P2/ BITS,,SOURCE DDB
	JUMPL	P2, RTATS	;Negative TO ATTACH AS AUX/SLAVE PORT
    ;HERE TO ATTACH AS TARGET'S COMMAND PORT
    ;J/ TARGET JOB #  U/ LDB ADDR

RTATC:	HRRZ	J, P1		;J/ TARGET FRAME #
	HRRZ	F, TTYTAB(J)	;F/ 0,,DDB ADDR
	SKIPN	F		;IF THERE'S NO DDB,
	 STOPCD 		;  CRASH
	HLL	U, LDBDCH(U)
	TLNE	U, LDLAUX	;IF IT'S AN AUX CIRCUIT,
	 JRST	[
		MOVEI T1, RTAUX%
		JRST RTERJ	;  RESTORE J AND ERROR-RETURN
	]
	HRRZ	T1, DDBLDB(F)
	JUMPN	T1, [		;IF JOB'S ATTACHED ALREADY,
		MOVEI	T1, RTTAT%
		JRST	RTERJ	;  RESTORE J AND ERROR-RETURN
	]

	MOVE	T1,TIMRST##
	DPB	J,CLKJOB##
	PUSHJ	P,CHGCLK	;RESET TIMEOUT-ON-DISCONNECT TIMER
	PUSHJ	P,SCNNAM	;DEVNAM(F) := "TTY" & CVOS(LINE#)
	PUSHJ	P,LOGLDB##	;Set LDBLOG from UPTLOG if LDBLOG is zero
	PUSHJ	P,COMATT	;JOIN F AND U

	TLNE	P2,RT.CON	;User want us to force CONTINUE on target?
	 PUSHJ	P,RTCONT	;yes - go do it

	LDB	T1, RTYMOD<P2>	;T1/ LDLCOM "MODE"
	JRST	@[
		RTCSV		;0  .RTCSV  FORCE SAVED MODE
		RTFIN		;1  .RTCCU  RETAIN CURRENT MODE
		RTCCO		;2  .RTCCO  FORCE COMMAND MODE
		RTCUS		;3  .RTCUS  FORCE USER MODE
	](T1)

RTCSV:	MOVSI	T1, DCLCOM
	TDNN	T1, DDBDCH(F)	;CHECK SAVED LDLCOM SETTING
	JRST	RTCUS		;WAS 0 -- FORCE USER MODE
	JRST	RTCCO		;WAS 1 -- FORCE CMND MODE

RTCUS:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	;CLEAR COMMAND MODE
	PUSHJ	P, SETLMD	;FIX LINE MODE FIELD
	JRST	RTFIN

RTCCO:	MOVSI	T1,LDLCOM
	TDNE	T1,LDBDCH(U)	;IF NOT ALREADY AT CMND MODE,
	JRST	RTFIN
	PUSHJ	P,PRPRMT##	;  PRINT A PROMPT
	PUSHJ	P,CNCMOD	;  FORCE TO CMND MODE
	JRST	RTFIN

    ;HERE TO ATTACH AS A SLAVE PORT TO TARGET
    ;J/ TARGET JOB #  U/ LDB ADDR

RTATS:	LDB	F, LDPLNO	;F/ PORT #
	PUSHJ	P, FNDPRT	;F/ DDB FOR PORT. IF THERE ISN'T ONE,
	JRST	RTATS1		;  GO ALLOCATE A DDB
	HRRZ	T1, P2		;T1/ SOURCE DDB
	CAIN	T1, (F)		;IF IT'S THE SAME AS THE TARGET,
	JRST	RTATS1		;  ALWAYS ALLOCATE A NEW ONE

    ;USING EXISTING DDB

	HRRZ	T1, DDBLDB(F)
	JUMPN	T1, [		;IF ALREADY ATTACHED,
		MOVEI	T1, RTTAT%
		JRST	RTERJ	;RESTORE J AND ERROR-RETURN
	]
	MOVEI	T1, (SIXBIT/TTY/)
	HRLM	T1, DEVNAM(F)
	JRST	RTATS2

    ;ALLOCATING NEW DDB

RTATS1:	HRRZ	T1, TTYTAB(J)	;T1/ TARGET CMND PORT DDB
	SKIPN	T1		;IF THERE IS NONE,
	 STOPCD 		;  CRASH
	PUSHJ	P, DDBSR1	;F/ NEW DDB, LINKED AFTER CMND PORT.
	  JRST	[		;IF THERE'S NO ROOM FOR ONE,
		MOVEI T1, RTNRM%
		JRST RTERJ	;  RESTORE J AND ERROR-RETURN
	]
	DPB	J, PJOBN	;SET JOB #
	PUSHJ	P, SCNNAM	;AND PHYSICAL NAME
	MOVEI	T1, ASSCON
	IORM	T1, DEVMOD(F)	;MARK IT ASSIGNED-BY-CONSOLE

    ;ATTACH IT

RTATS2:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	;MAKE SURE IT'S NOT IN COMMAND MODE
	MOVSI	T1, TTYATC
	ANDCAM	T1, DEVMOD(F)	;MARK IT AS A NONCOMMAND PORT
	PUSHJ	P, COMATT	;JOIN F AND U
	PFALL	RTFIN
    ;DETACH THE SOURCE END

RTFIN:	HLRZ	J, P1		;J/ SOURCE FRAME #
	HRRZ	F, P2		;F/ SOURCE DDB
	HLLZS	DDBLDB(F)	;DETACH SOURCE
	HRRZS	DEVNAM(F)	;MAKE IT LOOK DETACHED
	MOVSI	T1, TTYATC
	TDNN	T1, DEVMOD(F)	;WAS SOURCE A COMMAND OR A SLAVE PORT?
	 JRST	RTFIN1		;(AUX/SLAVE)

    ;HERE WHEN WE'VE DETACHED SOURCE'S COMMAND PORT

	TLNN	P2, RT.SIG	;IF WE'RE SIGNALLING A HANGUP,
	 JRST	IPOPJ1
	PUSHJ	P, HNGTTY	;  FORCE A DETACHED-JOB HANGUP
				; J has job #
	JRST	IPOPJ1

    ;HERE WHEN WE'VE DETACHED AN AUX/SLAVE PORT

RTFIN1:	TLNN	P2, RT.SIG	;IF WE'RE SIGNALLING A HANGUP,
	 JRST	RTFIN2
	LDB	T1, DDPTZP
	PUSHJ	P, TAKTRJ	;  CAUSE A ZAPPED INTERRUPT
RTFIN2:	MOVEI	T2, ASSCON
	PUSHJ	P, RELEA6	;TRY TO FREE THE DDB
	JRST	IPOPJ1
	
    ;ERROR-RETURNS

RTERJ:	POP	P, J		;RESTORE J
RTERR:	UMOVEM	T1, (M)		;STORE ERROR CODE
	POPJ	P,
SUBTTL	COMATT - PERFORMS THE FUNCTIONS COMMON TO ALL ATTACH FUNCTIONS:
;	     LINKS LDBDDB(U) AND DDBLDB(F)
;	     SETS NEED-OUTPUT BIT OF LDB SO ATTACHEE WILL BE AWAKENED
;	     SETS NON-DEVIOS LDB DEVICE CHARACTERISTIC BITS
;	     CALLS UUOLDB TO SET DEVIOS DEVICE CHARACTERISTIC BITS
;	   F/ DDB ADDR  U/ LDB ADDR
;	   DESTROYS T1-T4

COMATT:	TRNE	F, -1
	TRNN	U, -1
	 STOPCD 		;MUST HAVE A DDB AND AN LDB
	HRRM	U, DDBLDB(F)
	HRRM	F, LDBDDB(U)	;DO THE ATTACH
	MOVEI	T1, 1
	DPB	T1, LDBOPB(U)	;SET NEED-OUTPUT
	LDB	T1, DDPIMB
	DPB	T1, LDPIMB	;SET IMAGE-MODE BREAK CHARACTER
	MOVE	T3, DDBDCH(F)
	MOVE	T1, LDBBYT(U)
	TLNN	T3, DCLNTB	;NO HT/VT/FF ECHO
	TLZA	T1, L2LNTB
	TLO	T1, L2LNTB
	MOVEM	T1, LDBBYT(U)
	MOVEI	T1, L2LTBK	;TABS-AS-BREAKS
	TLNE	T3, DCLTBK
	HRLI	T1, L2LTBK
	PUSHJ	P, SETTBK
	MOVEI	T1, L2LBBP	;BACKSPACE-AS-NONBREAK
	TLNE	T3, DCLBBP
	HRLI	T1, L2LBBP
	PUSHJ	P, SETTBK
	MOVE	S, DEVIOS(F)
	PJRST	UUOLDB		;SET DEVIOS-DEPENDENT LDB BITS
SUBTTL	ROUTINE TO FIND A FREE TTY DEVICE DATA BLOCK

;CALL FROM CLOCK LEVEL TO DO AN ATTACH ON A NEW JOB, OR
;FROM UUO LEVEL ON AN INIT OF A NEW LINE.

;CALL:	NO ARGUMENTS
;	PUSHJ P,DDBSRC
;	  ERROR RETURN		;NONE AVAILABLE. F=0. T1 CLOBBERED
;	OK RETURN		;ADDRESS IN F, TTYUSE SET IN DEVMOD
;				;RESPECTS J,U,CH.
;				;IF YOU DECIDE NOT TO USE F, YOU BETTER
;				;FREE IT UP AGAIN.

DDBSRC:	MOVE T1,TTYFLK	;WHERE TO LINK IN
DDBSR1:	HRRZ F,FRETTY	;HERE IF TO LINK AT SPECIAL SPOT WITH T1 SET
	JUMPE F,CPOPJ		;NO DDB'S AVAILABLE
	HLRZ F,DEVSER(F)	;GET NEXT FREE
	EXCH F,FRETTY		;RESTORE F AND UPDATE FREE LIST
	PUSH P,DEVSER(T1)
	HRLM F,DEVSER(T1)	;LINK INTO DDB CHAIN
	HRLM T1,DDBBLK(F)	;PUT IN THE BACK LINK
	POP P,T1
	HLLM T1,DEVSER(F)	;NOW LINK IT IN
	MOVSS T1
	PUSH P,T3
	MOVE T3,DEVMOD(T1)	;IS THE NEXT ONE DOWN
	TLNE T3,DVTTY		;ALSO A TTY?
	HRLM F,DDBBLK(T1)	;YES, RESET ITS BACK LINK
	POP P,T3
	MOVE T1,[XWD TTYATC,ASSCON+ASSPRG]
	ANDCAM T1,DEVMOD(F)	;TURN OFF USE BITS
	SETZM DEVLOG(F)		;NO LOGICAL NAME

ZZ0==0
REPEAT <TRPLEN+5>/6,<
	SETZM	DDBTRP+ZZ0(F)
ZZ0==ZZ0+1>

	MOVSI T1,IOFST
	DPB T1,PJOBN		;SET JOB TO 0 (GO FOR IT, BILL!)
	MOVEM T1,DEVIOS(F)
	SETZM	DDBDCH(F)	;CLEAR NONDEVIOS DEVICE CHARACTERISTICS
	JRST CPOPJ1
SUBTTL	TTYNFR - CALLED WITH J/ FRAME # TO ALLOCATE A NEW
;	   (DETACHED) TTY DDB FOR THE FRAME AND STORE A
;	   POINTER TO IT IN TTYTAB(J)
;	   (DEVNAM WILL BE 0,,SIXBIT /TTY/)
;	   NONSKIP-RETURNS IF NO DDB FREECORE, OTHERWISE SKIP-RETURNS

TTYNFR::PUSHJ	P, TTYSRC	;IF IT ALREADY HAS A COMMAND PORT DDB,
	  PUSHJ	P, DDBSRC	;OR THERE'S NO ROOM TO ALLOCATE ONE,
	    POPJ P,		;  ERROR-RETURN
	HLLZS	DDBLDB(F)	;MAKE SURE IT KNOWS IT'S DETACHED
	MOVEI	T1, (SIXBIT /TTY/)
	MOVEM	T1, DEVNAM(F)	;SET ITS NAME
	MOVE	T1, [TTYATC,,ASSCON]
	IORM	T1, DEVMOD(F)	;MARK IT AS A COMMAND PORT
	DPB	J, PJOBN	;SET ITS OWNER
	HRRZM	F, TTYTAB(J)
	JRST	CPOPJ1
SUBTTL	SCNNAM - SET DEVNAM(F) TO "TTYNNN" WHERE NNN IS
;	   LDPLNO (FETCHED THROUGH U) IN OCTAL
;	   BREAKS T1 T3

SCNNAM:	LDB T1,LDPLNO
	DPB T1,PUNIT
	MOVSI T3,(SIXBIT /TTY/)
	MOVEM T3,DEVNAM(F)
	MOVE T3,[POINT 6,DEVNAM(F),17]
	PUSH P,T2		;SCNNMR CLOBBERS THIS ONE
	PUSHJ P,SCNNMR		;RADIX PRINT TO CORE
	POP P,T2
	POPJ P,

;NAMSCN - CALLED WITH F/ TTY DDB
;	   RETURNS WITH T1/ PORT# FROM RH(DEVNAM)

NAMSCN:	PUSH	P, T2
	SETZ	T1,
	HRLZ	T2, DEVNAM(F)
NAMSC1:	CAML	T2, [200000,,000000]
	CAMLE	T2, [272727,,000000]
	JRST	NAMSC2
	LSH	T2, 3
	LSHC	T1, 3
	JRST	NAMSC1
NAMSC2:	POP	P, T2
	POPJ	P,
SUBTTL TRAP CODE

;CHECK FOR CHARACTER TRAP

CHRTRP:	TLNE U,LDLCOM
	POPJ P,		;NEVER AT COMMAND MODE
	MOVEI T1,LXRCHR
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ	;NO TRAP IF NO DDB
	LDB T1,DDPTCH
	MOVEI T2,FLGCHR	;AND SET THE FLAG IN CASE OLD TYPE
	PJRST TAKOTJ

;NOW FOR A LINE TRAP

LINTRP:	HRRZ F,LDBDDB(U)	;NEVER CALLED AT COMMAND LEVEL
	JUMPE F,CPOPJ
	MOVEI T1,LXRBRK
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	PUSH P,T2	;MUST PRESERVE T2
	LDB T1,DDPTLN
	MOVEI T2,FLGLIN
	PUSHJ P,TAKOTJ
	POP P,T2
	POPJ P,
SUBTTL	CALLED ON AN ESCAPE TO SEE IF WE SHOULD SET TRAP

ESCTRP:	TLNE U,LDLCOM
	POPJ P,		;NEVER IN COMMAND MODE
	MOVEI T1,LXRESC
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ
	PUSH P,T1		;JUST LIKE CODE ABOVE
	LDB T1,DDPTSC
	MOVSI T2,FLGESC
	PUSHJ P,TAKNZJ		;TAKE THIS TRAP IF REALLY ENABLED
	 JRST TPOPJ		;NOT ENABLED
	POP P,T1		;ENABLED
	JRST TPOPJ		;RETURN UP A LEVEL TO IGNORE CHR

;CALLED FROM TYI WHEN AN ESCAPE IS READ TO CHECK ABOUT TRAPPING

ESCTR1:	PUSH P,T1		;FOUND ESCAPE READING CHRS
	MOVEI T1,LXRESC
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	LDB T1,DDPTSC
	MOVSI T2,FLGESC
	PUSHJ P,TAKNZJ		;TRY THE TRAP
	 JRST TPOPJ	;NOT ENEABLED
	JRST ABTUUO		;ABORT THE UUO. IF ALREADY IN
			;HIGHER TRAP WE WILL JUST DO THE INPUT
			;AGAIN

;CALLED WHEN AN ORANGE BALL IS RECEIVED TO CHECK ON TRAPS

OBREC:	MOVEI	T1, LXROBS
	IORM	T1, LDBDCX(U)	; SET "ORANGE BALL SEEN" BIT
	HRRZ F,LDBDDB(U)	;GOT AN ORANGE BALL. DDB THERE?
	JUMPE F,CPOPJ		;NO
	LDB T1,DDPTOB		;GET THE CHANNEL NUMBER
	JRST TAKNZJ		;AND SET UP TO TRAP
SUBTTL	ROUTINE TO TAKE A JOB OUT OF TIOW FOR A TRAP

TTYWAK::PUSH P,F
	PUSH P,S
	PUSHJ P,FRSTTY	;FIND THE FIRST TTY FOR THIS JOB
	 JRST TTYWK1	;NONE THERE, MUST NOT RALLY BE IN IOW
TTYWK2:	MOVE S,DEVIOS(F)
	PUSHJ P,TIWAKE	;WAKE HIM UP IF IN IOW
	PUSH P,U
	HRRZ U,DDBLDB(F)
	JUMPE U,TTYWK3	;NOT ATTACHED, NOTHING WE CAN DO
	MOVSI S,L2LOEX	;SET EXTENDED OUTPUT BUFFER ING SO
	IORM S,LDBBYT(U)	;JOB CAN FINISH UUO
TTYWK3:	POP P,U
	PUSHJ P,NXTTTY
	 SKIPA		;NEXT TTY NOT THERE
	JRST TTYWK2	;TRY THE NEXT ONE
TTYWK1:	POP P,S		;FINISHED
	POP P,F
	POPJ P,
SUBTTL	ROUTINES TO FIND A JOB'S TTY DDBS

FRSTTY:	HRRZ F,TTYTAB(J)	;FIRST ONE SHOULD BE THE CONTROLING TTY
	SKIPA
NXTTTY:	HLRZ F,DEVSER(F)	;IF WANT THE NEXT, FOLLOW CHAIN
	JUMPE F,CPOPJ		;DONE
	MOVE S,DEVMOD(F)
	TLNN S,DVTTY!DVRMT	;IS IT STILL A TTY OR RMT
	POPJ P,			;NO
	LDB S,PJOBN
	CAMN S,J		;FOR THIS JOB?
	AOS (P)		;YES, SKIP RETURN
	POPJ P,			;NO, FOUND THEM ALL
SUBTTL	ROUTINE TO CLEAR SLEEP CONDITIONS FOR ALL TTYS

TTSCLR::PUSH	P,F
	PUSH	P,S
	MOVEI	T2,0
	LDB	S,JBYWAK##	;GET WAKE CHANNEL
	CAIN	S,^D36		;HIBER CODE?
	 DPB	T2,JBYWAK##	;YES, CLEAR IT
	LDB	S,JBYEXC##	;GET EXIT IN CHILD CHANNEL
	CAIN	S,^D36		;HIBER CODE?
	 DPB	T2,JBYEXC##	;YES, CLEAR IT
	PUSHJ	P,FRSTTY
	  JRST	TTYWK1		;ALL DONE, (NO TTYS)
TTSCL2:	MOVSI	S,DVRMT
	TDNE	S,DEVMOD(F)
	 JRST	TTSCL3		;DO NOT CLEAR FOR RMTS
	LDB	S,DDPTCH
	CAIN	S,^D36		;IS THIS A SLEEP CODE?
	 DPB	T2,DDPTCH	;YES, CLEAR IT
	LDB	S,DDPTLN
	CAIN	S,^D36
	 DPB	T2,DDPTLN	;NOW FOR LINE
	PUSH	P,U
	HRRZ	U,DDBLDB(F)	;GET LINK TO LDB
	JUMPE	U,TTSCL1	;NONE THERE, FINISHED THIS TTY
	LDB	S,DDPTOB	;WAITING FOR ORANGE BALL
	CAIN	S,^D36
	 DPB	T2,DDPTOB	;CCLEAR SLEEP
	LDB	S,DDPTLN	;LINE
	CAIN	S,^D36
	 DPB	T2,DDPTLN
	LDB	S,DDPTCH	;CHARACTER
	CAIN	S,^D36
	 DPB	T2,DDPTCH
TTSCL1:	POP	P,U
TTSCL3:	PUSHJ	P,NXTTTY
	  JRST	TTYWK1		;FINISHED, GET F AND S BACK AND GO
	JRST	TTSCL2		;MORE TO CLEAR
SUBTTL	ROUTINE TO CLEAR ALL TRAP CONDITIONS FOR ALL TTYS

TTTCLR::PUSH P,F
	PUSH P,S
	PUSHJ P,FRSTTY
	 JRST TTYWK1	;NO MORE TTYS THERE
TTTCL1:
;*;	MOVSI S,DVRMT
;*;	TDNE S,DEVMOD(F)
;*;	 JRST	[PUSHJ P,RMTRSI	;RESET FOR REMOTE
;*;		JRST TTTCL2]

ZZ0==0
REPEAT <TRPLEN+5>/6,<
	SETZM	DDBTRP+ZZ0(F)
ZZ0==ZZ0+1>

TTTCL2:	PUSHJ P,NXTTTY		;FIND THE NEXT ONE FOR THIS JOB
	 JRST TTYWK1		;DONE
	JRST TTTCL1		;CLEAR IT ALSO
SUBTTL	THIS ROUTINE ASSIGNES TRAP CHANNELS TO TTY TRAP CONDS
;CALLED WITH T3 CHANNEL NUMBER
;	T2 TRAP NUMBER
;	F TTY DDB
;	SKIP RETURN IF TRAP CONDITION NOW SATISFIED

TINAS1::LDB T1,DDPTAB(T2)	;GET CURRENT
	CAILE T3,^D35		;REAL INTERRUPT CHANNEL?
	 JUMPN T1,CPOPJ		;NO, SLEEP. DON'T CLEAR IF INT. THERE
	DPB T3,DDPTAB(T2)	;SET TRAP CONDITION IN DDB
	JUMPE T3,CPOPJ		;IF ENABLING, NOT DISABLING,
	HRRZ U, DDBLDB(F)	;  GET LDB IF THERE IS ONE
	XCT INTSET(T2)		;  AND CHECK IF IT'S ALREADY TRUE
	POPJ P,			;IN CASE WE DO NOT TRANSFER

;INTERRUPT TEST TABLE - MUST BE IN THE SAME ORDER AS DDPTAB

INTSET:	POPJ P,		;ESCAPE, WILL GET IT LATER
	JUMPN U,CHKCHR	;IF LINE PRESENT, CHECK FOR CHARACTERS
	JUMPN U,CKLNTR	;IF LINE PRESENT, CHECK FOR BREAKS
	POPJ P,		;IOW, NEVER PRESET
	POPJ P,		;FINISH IO
	JRST CHKLOS	;LOST CHARACTERS
	POPJ P,		;ORANGE BALL, NEVER KNOW
	POPJ P,		;CIRCUIT ZAPPED
	JUMPN U,CHKPSP	;IF LINE PRESENT, CHECK FOR UNREAD PORT-STATUS
	JUMPN U,CHKYEL	;YELLOW BALL, PERHAPS ONE IS PENDING
	POPJ P,		;CHARACTER GOBBLER, NOT BUFFERED
	JUMPN U,CHKTCC	;IF LINE PRESENT, CHECK FOR CHANGED TC'S
SUBTTL	ROUTINES TO CHECK IF TRAP CONDITION ALREADY SATISFIED

; CHECK IF CHARACTERS LOST (BY READING IO.BKT)

CHKLOS:	MOVE S,DEVIOS(F)
	TRNE S,IOBKTL
	AOS (P)		;BIT ALREADY SET CAN TRAP NOW
	POPJ P,

; CHECK IF CHARACTERS PRESENT (BY READING LDB COUNTS)

CHKCHR:	HLL U,LDBDCH(U)
	TLNE U,LDLCOM
	POPJ P,		;NOT SAT AT INTERRUPT LEVEL
	SKIPG LDBECC(U)	;CHRS TO BE ECHOED
	SKIPLE LDBTIC(U)	;OR ALREDY ECHOED
	AOS (P)		;YES
	POPJ P,

; CHECK IF A BREAK CHARACTER IS PRESENT (BY READING LDB COUNTS)

CKLNTR:	HLL U,LDBDCH(U)
	TLNE U,LDLCOM
	 POPJ P,
	MOVE T1,LDBTIC(U)
	ADD T1,LDBECC(U)	;ENOUGH?
	CAIL T1,TIWKC
	 JRST CPOPJ1		;YES
	TLNE U,LDLBK2	;WHICH BREAK SET
	 SKIPG LDBBK2(U)
	SKIPLE LDBBKC(U)	;TEST CORRECT ONE(S)
	 AOS (P)
	POPJ P,

; CHECK IF A PORT STATUS MESSAGE IS WAITING TO BE READ
;See comment at ACPSM

CHKPSP:	MOVSI	T1, LMLPSP
	TLNE	T1, LDBMOD(U)	; IS THERE A MESSAGE WAITING?
	 AOS	(P)		; YES
	POPJ	P,

; CHECK IF ANY TERMINAL CHARACTERISTICS HAVE CHANGED

CHKTCC:	HLL	U, LDBDCH(U)
	TDNN	U, LDLPTY	;IF IT'S NOT A PTY,
	 POPJ	P,		;  OF COURSE NOT
	PUSH	P, U
	PUSHJ	P, PTYBUD
	SKIPE	LDBTCB(U)	;ANY UNREAD CHANGES?
	AOS	-1(P)		;(YES)
	POP	P, U
	POPJ	P,


; Test for Yellow ball interrupt condition satisfied:
;   Skip return if a Yellow ball has been received and no Orange ball
;   has yet been sent.  If an Orange ball is waiting to be output, it
;   must be due to a Yellow ball being received while the interrupt
;   was not enabled.  If the interrupt was enabled, the user will have
;   already taken the trap.

CHKYEL:	LDB	T1,LOPSOG	;is OB waiting to be output?
	TRZN	T1,1		;if so, recall it...
	 POPJ	P,
	DPB	T1,LOPSOG	;its now the user's responsibility
	MOVSI	T1,LXLOOK	
	IORM	T1,LDBDCX(U)	;okay for user to send an orange ball
	AOS	(P)		
	POPJ	P,

SUBTTL	SEND A YELLOW BALL

TTYYLS::HRRZ	U, DDBLDB(F)
	JUMPE	U, CPOPJ
	PUSH	P, T1		;SAVE T1
	MOVEI	T1, 1
	DPB	T1, LOPSYL	;SET SEND-YELLOW
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	JRST	TPOPJ		;RESTORE T1 AND RETURN

SETFIO:	MOVSI S,TINFIO
	IORB S,DEVIOS(F)	;SET A FLAG SO WE KNOW WE TRAPPED
				;INSTEAD OF GOING INTO IOW
	POPJ P,
SUBTTL	FNDPRT - CALLED WITH J/ JOB #, F/ -1 OR PORT #
;	   LOOKS FOR A DDB FOR THAT PORT/JOB (-1 IS CMND PORT)
;	   NONSKIP-RETURNS IF THERE IS NONE
;	   SKIP-RETURNS WITH F/ DDB ADDR IF THERE IS

FNDPRT::JUMPL	F,[HRRZ F,TTYTAB(J)	;COMMAND PORT
		   JRST FNDPT1]
	CAIL	F,PORTN##
	 POPJ	P,		;MUST NOT BE THERE
	MOVE	F,LINTAB(F)
	HRRZ	F,LDBDDB(F)
FNDPT1:	JUMPE	F,CPOPJ		;NO DDB ATTACHED
	PUSH	P,T1
	LDB	T1,PJOBN
	CAME	T1,J		;THIS JOB?
	 JRST	TPOPJ		;NO
	JRST	TPOPJ1		;YES
SUBTTL	TINASS UUO - ASSIGN TTY INTERRUPTS
;(MOST OF THE WORK IS DONE IN TINAS1)

TINASS::LDB T3,[POINT 9,T1,17]	;GET THE CHANNEL NUMBER
	CAIG T3,^D35
	SKIPGE JBTPIP(J)	;IF TOO LARGE OR NO INTADR
	POPJ P,			;TAKE ERROR RETURR
	HRRZ F,TTYTAB(J)
	HRRZ F,DDBLDB(F)
	JUMPE F,TINDET		;DETACHED, OK
	MOVSI T2,LLLZAP
	TDNE T2,LDBLOG(F)
	 POPJ P,		;CAN NOT SET IF WAITING FOR LOGUT
TINDET:	HRRE F,T1
	PUSHJ P,FNDPRT
	 POPJ P,		;BAD PORT NUMBER
	LDB T2,[POINT 9,T1,8]	;GET INTERRUPT NUMBER
	CAIL T2,TRPLEN		;TOO LARGE?
	POPJ P,		;YES
	PUSHJ P,TINAS1		;GO ASSIGN
	 JRST STOTC1		;GOT IT, GIVE BACK OLD
	PUSH P,T1		;CONDITION SAT, SAVE OLD CHANNEL
	MOVE T1,T3
	PUSHJ P,TAKTRP	;TAKE THE TRAP
	POP P,T1
	JRST STOTC1		;AND RETURN THE ANSWER
SUBTTL	INITIALIZE
;INITIALIZE THE WORLD. THIS ROUTINE DOES NOT MAKE PROPER
;PROVISION FOR 140 RESTART SINCE THAT ABILITY IS NO LONGER
;OF ANY IMPORTANCE

;Beware, this routine (between TTYINI and TTIEND) is overwritten by
;hackers to patch running monitors on the assumption that the
;code is never reentered after system initialization.  Beware
;if this ever changes!  The CONFIG gettab points to TTYINI as
;the dynamic patch area.
PATCH2=:TTYINI+1	;Make it obvious

TTYINI::SETZM	INTERM
	SETZM	BPREQ		;INITIALLY NO BLOCK PORTS
	SETZM	OPRTIM		;START WITH NO ALARM FLAGS SET
	SETOM	THSTIM##	;TIMER FLAGS
	SETZM	MXTIM##
	MOVEI	T1,CCTYI
	MOVEM	T1,.CPTIA##	;SET UP COMMAND READ AND WRITE
	MOVEI	T1,CCTYO
	MOVEM	T1,.CPTOA##
	HRRZ	U,LINTAB
	HRRZM	U,LDB.LO	;Address of first LDB on systems
	MOVE	P1,[POINT 1,LINFLG]	;READY TO SET BYTE PTRS
	MOVSI	P2,NMXLIN##-1	;NOW ALL LINES
TTINI2:	HRRZ	U,LINTAB(P2)	;POINT TO LDB
	MOVSI	T1,LDICLR(U)	;CLEAR IT OUT
	HRRI	T1,LDICLR+1(U)
	SETZM	LDICLR(U)
	BLT	T1,LDICLE(U)
	DPB	P2,LDPLNO	;RESTORE LINE NUMBER
	IBP	P1		;TO POINT TO NEXT BIT
	MOVEM	P1,LDBOPB(U)
	SETZM	(P1)		;MAKE SURE FLAG WORD IS 0
	MOVE	T3,LINTAB(P2)	;CHECK INITIALIZE BITS
	SKIPN	REFLAG		;BUT NOT IF REFRESING
	TLNN	T3,TTVINI
	 JRST	TTINI3		;NOT RUN INITIA
	MOVSI	T1,(STAUTO)
	TDNN	T1,STATES
	 JRST	TTINI3		;DO NOT RUN IF NOT AUTO-RESTART
	MOVE	T1,[LLLNLN,,LDLCOM]
	HLLZM	T1,LDBLOG(U)	;MARK IN (BUT UNKNOWN TO TYMNET)
	HRLZM	T1,LDBDCH(U)	;SET LOGGED IN AND COMMAND MODE
	MOVE	T1,SYSNUM##	;Our host number
	DPB	T1,LDPHST	; for job running INITIA (DSKCLN)
	MOVEI	T1,1
	DPB	T1,LOPHSH	;SET HUSH BIT TO SUPRESS OUT MESSAGES
	SETZM	LDBDCX(U)	;NO EXTENDED BITS ON
	PUSHJ	P,SETLMD
	PUSHJ	P,FRMASN##	;Assign a Job/frame slot
	 STOPCD			;Strictly Fatal
;;***NOTE*** Can't call TTYATI here since it calls DDBSRC, which
;;***NOTE*** uses TTYFLK, which points at DEVLST-DEVSER.  This
;;***NOTE*** in turn means that DEVLST gets smashed when DDB is
;;***NOTE*** allocated, thus causing TTYINI to get called twice.
;;***NOTE*** Go please the world.
	MOVEI	T1,TTYLST	;Start DDB search from here
	PUSHJ	P,DDBSR1	;Get a TTY DDB
	 STOPCD 		;No errors allowed here
	PUSHJ	P,[PUSH P,U
		   JRST TTYAT1]	;IT'S NOT SUCH A BAD HACK...
	 STOPCD 		;Last chance for fatal error...
	MOVEI T1,CMFCXI##	;Forced command index for INITIA
IFKMC<
	SKIPGE KMCDO##		;GREATER OR EQUAL 0 NOT KMC MANUAL MODE
	 MOVEI T1,CMFCKM##	;DO FORCE KMC LOAD
>;END IFKMC
	PUSHJ P,TTFORC

TTINI3:	AOBJN	P2,TTINI2
	HRRZM	U,LDB.HI	;Address of highest LDB on system
	SETZM	DEVOPR		;NO OPER YET
	SETZM	OPRLDB		;AND HAS NOLDB
	HRRZ	T1,TTCLST##	;SET UP FREE LIST
	MOVEM	T1,RCC.LO	;Lowest chunk address
	MOVEI	J,TTCHKS(T1)	;SET FREE POINTER TO FIRST
	MOVEM	J,TTFREE##
	HLRZ	T3,TTCLST##	;GET SIZE (number of chunks in list)
	MOVEM	T3,TTFREN
	SOS	TTFREN		;ONE LESS SINCE NO CHUNK 0
	IMULI	T3,TTCHKS
	ADDI	T3,(T1)
	MOVEM	T3,RCC.HI	;One greater than highest chunk address
	SETZM	(T1)		;ZERO OUT FREE LIST
	MOVEI	J,1(T1)		;Build BLT pointer
	HRL	J,T1
	BLT	J,-1(T3)	;ZERO ALL OF IT
	MOVEI	T3,TT2CHK(T1)	;NOW LINK UP
	MOVE	J,TTFREN	;NUMBER TO LINK
TTINI4:	MOVEM	T3,TTCHKS(T1)
	ADDI	T1,TTCHKS	;MOVE FORWARD
	HRLI	T3,(T1)		;SET BACK LINK
	HRRI	T3,TT2CHK(T1)	;AND FORWARD
	SOJG	J,TTINI4	;STORE IF NOT DONE
	HLLZS	(T1)		;ZERO FORWARD LINK OF LAST ONE
	POPJ	P,

TTIEND=:.-1  ;end of area used for dynamic patches, see comment at TTYINI:

IFCPU(F3),<
;ROUTINE TO RESYNC WITH NEXILIS BASE.
; CALLED FROM AT SYSTEM STARTUP AND WHEN BASE CRASHES.

INTEGER	MWAIT,MZEROS

OPDEF TNCONO [744000,,0]
OPDEF TNOUT [745000,,0]
OPDEF TNIN [746000,,0]

	NZEROS==300		;Number of zeroes to send to PDP-11
	NWAIT==^D60*^D24	;Number of clock ticks max per zero


FNSYNC:	SKIPE	CTYDO##		;If using CTYSIM instead of TYMNET,
	 JRST	CPOPJ1		; say all done
	SKIPG	MZEROS		;Waiting for acceptance?
	 JRST	FNSYN0		; No, try this again -- reset
	TNIN	T1		;Yes, read something
	TLNE	T1,(1B5)	;Skip if not accepted
	 JRST	FNSYN2		; Got a zero, go decrement counter
	SOSLE	MWAIT		;Are we waiting for acceptance?
	 POPJ	P,		;Yes, so wait another tick
FNSYN0:	TNCONO	0		;Reset the interface.
				;Turn off input and output to the 11-base
	MOVEI	T1,NZEROS	;Set number of zeroes to TRY to send.
	MOVEM	T1,MZEROS	;Store in counter field
FNSYN1:	TNOUT	0		;Send a zero
	MOVEI	T1,NWAIT	;Get timeout period in clock tics
	MOVEM	T1,MWAIT	; and store in timeout counter
	POPJ	P,		;Return and wait for another tick

FNSYN2:	SOSLE	MZEROS		;Are we waiting for more zeroes?
	 JRST	FNSYN1		;Yes, send one and read it next tick
	TNCONO	1B34!1B35	;No, all here -- turn on PDP-11 interrupts
	SETZM	BASVER##	;Clear base version number
	JRST	CPOPJ1		; and skip return this time.
>;END IFCPU(F3)

SUBTTL	ROUTINES TO LOG IRING AND ORING ACTIVITY

;IRPLOG - routine to keep a log of iring messages
;
;  Assumes P1 and U may be clobbered since they will be
;  reused immediately upon return.  If this changes, the
;  appropriate registers should be saved.

IRPLOG:	MOVE	U,IRING(P4)		; Get IRING message
	AOS	P1,SCNPTR##		; Increment to next position
	ANDI	P1,SCNMSK##		; Keep offset
	JUMPN	P1,IRPLO1		; Not first - just log it
	MOVE	P1,DATE##		; Get current daytime
	MOVEM	P1,SCNUDT##		; And remember...
	SETZ	P1,			; Clear counter
IRPLO1:	MOVEM	U,SCNBUF##(P1)		; Store
	POPJ	P,			; Return

;ORPLOG - routine to keep a log of oring messages
;
;  Assumes P3 already setup containing data to store
;  (If not, ORING(P4) does contain the correct data)

ORPLOG:	PUSH	P,P1			; Save P1
	AOS	P1,SCNPTR##		; Increment to next position
	ANDI	P1,SCNMSK##		; Keep offset
	JUMPN	P1,ORPLO1		; Not first - just log it
	MOVE	P1,DATE##		; Get current daytime
	MOVEM	P1,SCNUDT##		; And remember...
	SETZ	P1,			; Clear counter
ORPLO1:	MOVEM	P3,SCNBUF##(P1)		; Log it
	POP	P,P1			; Restore P1
	POPJ	P,

SUBTTL	 VARIABLES

IFKMC<
BBCNTS:	EXP	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	;16 WORDS
BBPAGE:	EXP	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       	EXP	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	;32 WORDS
TIMMIN:	EXP ^D60
TIMDRD:	EXP ^D60
DRMHSI:	0
DRMSHT:	0
DRMBRK:	0
DRMANS:	0
DRMCLP:	0
DRMTIM::0 ;SECONDS OF UP TIME
DRDOW:	0
SENT41:	EXP 0,0,0,0	;SET ON SENDING 41, RESET ON RECIEVING 3 OR 1
KMCLAS:	0	;LAST KMCGAV,KMCGAC
KMCPDP::	0
KMCFLG::	REPEAT ^D64,<EXP 0>;KMC ACTIVE FLAG HISTORY
IRPMSG::	0
IRPMS2::	0
IRPMS3::	0
IRPMP1::	0
IRPMP2::	0
IRPMP3::	0
IRPMB1::	0
IRPMB2::	0
IRPMB3::	0
	>;END IFKMC
BADGUY:	0	;COUNTER INCREMENTED IN GOHSH:
FSCN:	0
TTFREN:	0	;NUMBER OF FREE CHUNKS LEFT
INPCH:	0
LINPTR:	0	;OUTPUT SCAN POINTER
CHCNT:	0	;# REMAINING CHARS TO OUTPUT AT A TIME ON A PORT
CHQTA:	0	;VALUE THAT CHCNT WAS SET TO AT START OF CYCLE
SVSPC:	0
TTCMCH::0	;HERE IS CHARACTER FOR COMMAND DECODER
TTCMCA::0	;INPUT POINTER FOR COMMAND BEING DECODED
OPRLDB::0	;LDB FOR OPER CONSOLE FOR MSGS ETC
UPSHUT:	0	;PLACE FOR UP-SHUT COMMAND TO BE STORED

LINPNM:	0	;SAVE LINE NUMBER FROM JFFO
LINFSV:	0	;SAVE FLAG WORD
SVOJFF: 0	;SAVE OUTPUT BIT NO FROM LDBOUT
INTERM::0	;Count of active terminals
OPRTIM::0
FRETTY::0	;POINTER TO FREE TTY DDBS
TTYFLK::0	;POINTER TO WHERE TO LINK IN TTY BLOCKS
CHRRDP:	0	;BYTE POINTER TO INPUT RING FOR CHARACTER INPUT
CHRWRP:	0	;REAL TTY: BYTE POINTER TO OUTPUT RING
	0	;PTY: BYTE POINTER TO PTY BUFFER
MULCNT:	0	;REAL TTYS: # CHARS MORE WILL FIT IN OUTPUT RECORD
	0	;PTYS: # CHARS MORE PTY OUTPUT THIS SECOND
MXMCNT:	0	;REAL TTYS: ORIGINAL VALUE OF MULCNT
TIMOW:	0	;TIMER FOR ORANGE-BALL WAIT ON CIRCUIT ZAPS
ALRSNT:	0
AUXRCP:: -1	;RECEIVED AUX PORT
AUXSTA:	0	;AUX CIRCUIT STATE
AUXSTR::BLOCK AUXSTL	;SPACE FOR STRING
AUXEND:: 0	;Pointer to last word used in AUXSTR
AUXSTP:	0	;STRING POINTER
AUXERR:: 0	;ERROR FROM AUX CIRCUIT BUILD
AUXJOB:	0	;JOB BUILDING AUX CIRCUIT
AUXWSC: 0	;# OF AUX-BUILTS RECEIVED IN WRONG STATE
AUXWPC: 0	;# OF AUX-BUILTS RECEIVED GIVING WRONG PORT
AUXWPT:	-1	;PORT LDB ADDRESS OF THE LAST ONE
NRPCNT: 0	;# TIMES WE GAVE "NO PORT RECEIVED" ERROR
ZRPCNT: 0	;# TIMES WE ZAPPED THE RECEIVED PORT
BIOJOB:	0	;JOB INITIATING BLOCK I/O FOR PORT.
AUXPRT:	0	;PORT BEING BUILT FROM
AUXTIM:	0	;AUX CIRCUIT TIMER
AUXUNM:	BLOCK 2	;SPACE TO BUILD UP A USER NAME
BUFLST:	0	;HEADER FOR LIST OF BLOCK INPUT/OUTPUT BUFFERS
BIOCNT:	0	;REAL TTYS: # OF JOBS ENABLED TO DO BLOCK I/O
		;	    LH := -1 AS A FLAG TO BLKNEG CODE
	0	;PTYS: # OF JOBS ENABLED TO DO PSEUDO-BLOCK I/O
BIOPRT: 0	;# OF BLOCK I/O PORTS, I.E., THE LAST RESPONSE
		;FROM THE BASE TO A NEGOTIATE MESSAGE
BIOBUF: 0	;# OF MONITOR BLOCK I/O BUFFERS
BBFREE:	0	;# OF FREE MONITOR BLOCK I/O BUFFERS
BBCRE:	0	;# OF BIO BUFFERS CREATED SINCE MONITOR LOADED (KS ONLY)
BBREL:	0	;# OF BIO BUFFERS RELEASED (KS ONLY)
BBPOOL:	0	;COUNT OF BIO BUFFER RE-USE SINCE MONITOR LOADED
BIOANS: 0	;# OF BLOCK I/O NEGOTIATE MESSAGES SENT BUT NOT
		;YET REPLIED-TO
ERRBNG: 0	;# OF UNSOLICITED BLOCK I/O NEGOTIATE MESSAGES
DWNFLG::0	;WANT TO TAKE SYSTEM DOWN
CTYFIL::0	;NUMBER OF FILLS NEEDED BY CTY
CTYFLN:	0	;COUNTER WHEN SENDING FILLS TO CTY
OPRWJB:	0	;JOB WAITING FOR SETUUO OPR MSG
TIWRNN: TILOW	;SMALL QUOTA FOR UNREAD INPUT CHARACTERS (^D80)
		;(BACKPRESSURE WHEN IT'S EXCEEDED)
TIHLTN:		;LARGE QUOTA FOR UNREAD INPUT CHARACTERS
		; MUST BE AT LEAST AS LARGE AS THE MAX NUMBER OF CHARS THE
		; INPUT RING CAN HOLD * 2 + TIWRNN,
		;  OTHERWISE CHARS COULD BE LOST
  IFDEF  SIZIRG, <<1_SIZIRG>*4*2+TILOW> ;^D1104 for normal sized rings
  IFNDEF SIZIRG, <^D512*2+TILOW>
  ;IFNKMC	<^D500>	;LARGE QUOTA FOR UNREAD INPUT CHARACTERS
  ;IFKMC	<^D2000>;(LOSE CHARACTERS WHEN IT'S EXCEEDED)
TTYRHT: 0	;# TIMES MONITOR OUT OF BUFFERLETS AT RCVCHR
		;+ LOSPDP + LOS620
LOSPDP: 0	;# TIMES A PORT EXCEEDED ITS LARGE QUOTA
		;BEFORE WE COULD GET BACKPRESSURE SENT
LOS620: 0	;# TIMES A PORT EXCEEDED ITS LARGE QUOTA
		;AFTER WE HAD SENT BACKPRESSURE
OMX30:	^D120	;TTY OUTPUT HIGH-WATER MARK FOR SLOW DEVICES
OWK30:	^D60	;TTY OUTPUT LOW-WATER MARK FOR SLOW DEVICES
OMX120:	^D480	;TTY OUTPUT HIGH-WATER MARK FOR FAST DEVICES
OWK120:	^D240	;TTY OUTPUT LOW-WATER MARK FOR FAST DEVICES
TOEMAX:	^D500	;EXPANDED-MODE TTY OUTPUT LIMIT
	GTLNK (TTYLOS)	;.LINK for .GTLNK
TTYLOS: 0	;COUNT OF CHARACTERS LOST BY TYMNET
		;(BLACK BALLS - BUFFER ZAPS)
PTYLOS:	0	;COUNT OF CHARACTERS LOST BY PTYS
LOGZAP:	0	;# OF LOGINS TO LOGGED-IN PORTS
ZAPLPT:	-1	;PORT LDB ADDRESS OF LAST LOGZAP OR DFRZAP
DFRZAP:	0	;# OF LDECS RECEIVED WHILE STILL ECHOING
NZAPIN: 0	;# ZAPPERS IN FROM TYMNET
NZAPN2: 0	;# TIMES WE GOT A ZAPPER ON A PORT W/ AN UNECHOED ZAP
NZAPLG: 0	;# TIMES WE GOT A LOGIN ON A PORT W/ AN UNECHOED ZAP
NZAPAX: 0	;# TIMES WE GOT AN AUX PORT FOR A PORT W/ AN UNECHOED ZAP
NZAPRS: 0	;# of times zapper had to be resent (based on LNLZIN)
NZAPOT: 0	;# ZAPPERS OUT IN RESPONSE TO ZAPPERS IN
TMCOOR: 0	;# OF UNKNOWN TERMINAL CHARACTERISTICS SET BY TYMNET
PTYFLO:	^D1000	;CHARS/SEC TOTAL MAXIMUM PTY FLOW
PTYBUF:	BLOCK	<PTBSIZ+4>/5
PBDISC:	0
DIDPBI:	0
FRSFLG:	0	;FLAG FOR CMDWAK (SO IT'LL KNOW IT'S NOT A REAL CMND)
FRSDEF:	0	;FLAG TO REMEMBER DEFERRED-ECHO STATE
SKPFLG:	0	;SET TO INDICATE INPUT AND SKIP AUXCAL IN PROGRESS
IRPSTP:	0	;Stopping place for SCNIN
BADKEY:	0	;Copy of KEY620 when base wants to crash us
IRPOLD:	0	;Old copy of IRP620 when base is declared down
ORPOLD:	0	;            ORP620
RCC.LO:: 0	;Lowest legal chunk address
RCC.HI:: 0	;One greater than highest legal chunk address
LDB.LO:	0	;Lowest legal LDB address
LDB.HI:	0	;Address of beginning of highest LDB
MSGLGP:	0	;Byte pointer into MSGBUF (must be 0 until MSGINI is called)

	$END	(SCN)		;End of SCNSER (SCNLIT: SCNEND:)

      y -