TITLE FILFND  HANDLE CORE TABLES FOR FILE OPERATIONS

	STOPCD(,ENTRY,FILFND)

;EXTERNALS FROM OTHER PARTS OF THE MONITOR

EXTERNAL CBAVAL,CBREQ,CBSWT,CBWAIT,CPOPJ1,CPOPJ2,JBTFPN
EXTERNAL JBTLIC,JBTPPN,JBYRPT,JBYWPT,JOB,PJOBN,SAVE4,TPOPJ,JBTAUN
EXTERNAL TPOPJ1,CPOPJ

COMMENT ;@@MODULE FILFNX
@@PURPOSE HANDLE ALL MANIPULATION OF IN-CORE TABLES AND
DIRECTORY MANIPULATION FOR
FILE ROUTINES. HANDLES LOOKUP, ENTER, RENAME PROCESSES WHICH
DO NOT INVOLVE THE FORMAT OF THE UUO ITSELF
@@;

INTERNAL FREATB,CHKACC,RMVATB,SRCNAM,RELLOK,LOKPPB,NLKPPB
INTERNAL GIVCB1,GIVCBR,GUFBT,SRCFIL,LKDATB,GETCBR,DIRSRC,CHKPRV
INTERNAL TSTWRT,FNDDRB
;EXTERNALS IN COMMOD.MAC

EXTERNAL ACTPPN,MFDPPN,SYSPPN,SPLPPN,INDPPN
EXTERNAL CBADR,CBUSER

EXTERNAL ATBALP,ATBCNT,ATBDOR,ATBFNB,ATBLCW,ATBLNK,ATBMSC
EXTERNAL ATBPVW,ATBRIB,ATBSIZ,ATBSTS,ATBPID
EXTERNAL ATMCNT,ATPCRE,ATPDEL,ATPDIR,ATPNDL,ATPREN,ATPSUP,ATPUPD
EXTERNAL ATPALC
EXTERNAL ATYPRV

EXTERNAL CMBLNK,CMBNAM

EXTERNAL DEVDBL,DEVATB,DEVDRB,DEVRIB
EXTERNAL PIDACC
EXTERN DEVREL,DEVBLK ;*************

EXTERNAL DRBALC,DRBCNT,DRBFNB,DRBLNK,DRBLOG,DRBMXA,DRBNX
EXTERNAL DRBRIB,DRBSTS,DRBLOK,DRBNAM,DRBUNM
EXTERNAL DRMCNT,DRPLOG,DRPLOK,DRPNX,DRPMXC
EXTERNAL DRYPRV

EXTERNAL FNBATB,FNBDBL,FNBDRB,FNBEXT,FNBLNK,FNBLOK,FNBALT,FNBNX
EXTERNAL FNBRIB
EXTERNAL FNPLOK,FNPNX
EXTERNAL FNYUFP

EXTERNAL FNCAPP,FNCCPR,FNCCRE,FNCDEL,FNCEXC,FNCLOK,FNCRED,FNCUPD
EXTERNAL UFRXLK,UFRXRD,UFRXCR

EXTERNAL PTRLEN

EXTERNAL RIBALP,RIBLCW,RIBMSC,RIBMXA,RIBPVW,RIBQTF,RIBSIZ,RIBSLF
EXTERNAL RIBSTS,RIBUSD,RIBUNM,RIBPID,RIBALT
EXTERNAL RIPDIR,RIPNDL
EXTERNAL RIYPRV,RIBPFS,RIBLST,RBMASK,RBREAL,RELRB2,RELRIB

EXTERNAL SYSCOR,SYSDOR,SYSDRB

EXTERNAL UFDRIB,UFDNAM,UFDEXT,UFDSIZ,UFDLNK

EXTERNAL SAVE2,ATBMWC,ATMMWC,ATPMXU,ATPDUM,LM3SPT,LMPMXW
EXT(<%UPT>)
EXTERNAL LMPSUP,UPTPID
EXTERNAL PCDTIM
COMMENT ;
THE FOLLOWING INDICATIONS ARE USED IN COMMENTS:
% THE JOB HAS CB RESOURCE AT THIS POINT
+ THE JOB HAS DRBCNT INCREMENTED AT THIS POINT
! THE JOB HAS A BLOCK LOCKED AT THIS POINT
;

;EXTERNALS IN OTHER PARTS OF FILSER

EXTERNAL IOSRIB,%RIB.C,MAPRDL,UUOLUK,UUOREN,UUOENT,UUOUFD
EXTERN GIVPAG,FALAQA
EXTERNAL UUOMLK,MAPWTL,MAPRLS,%RB2.C,IOSRBE,MAPWLN
EXTERNAL GETER1,DIRFST,PRMCHK,DIRNXT,NCSERR,SNFERR
EXTERNAL RIBDIR,DIRBLK,MAPXCH,RIBCKD,%RB2.C,GETAPG,MAPWTL,IOSALC
EXTERNAL UFDATB		;FROM FILUUO, FILLS IN ATB FROM UFD ENTRY
EXTERNAL UUOIRE		;IGNORE RIB ERROR BIT SET BY RENAME CODE THAT CALLS SRCFIL
COMMENT ;@@SUBROUTINE LOKPPB
@@PURPOSE TEST AND SET DRPLOK BIT IN DIRECTORY BLOCK (DRB)
FOR LOGINN AND LOGOUT. USED TO AVOID HAVING TWO USERS MANIPULATING
THE DIRECTORY AT THE SAME TIME.
@@ENTRY P1 CONTAINS THE STRUCTURE NAME (MUST BE DSKB)
P2 CONTAINS THE PPN
@@ACCUM P1,T2,T3,P2,T1
@@TABLES DRB TABLES IN CORE (MAY CREATE NEW DRB BLOCK)
@@GLOBAL SYSDRB
@@ERRORS MAY EXIT TO SNFERR OR NCSERR IF WRONG FILE
STRUCTURE OR NO CORE TO CREATE NEW DRB RESPECTIVELY.
@@CALLS PPBBIT (SETS CB INTERLOCK)
GIVCBR,GIVCB1
@@EXIT NON-SKIP RETURN IF DPRLOK ALREADY SET
SKIP RETURN IF DRPLOK WAS NOT SET, IT IS SET NOW.
@@FUNCTION IF PPBBIT() NON-SKIP [TAKE ERROR EXIT SET BY PPBBIT]
	IF DRPLOK IS ON GO TO GIVCBR
	SET DRPLOK AND GO TO GIVCB1@@;

LOKPPB:	PUSHJ	P,PPBBIT	;GET L(UFB), BIT TO TEST
	 PJRST (P1)		;P1 SET FOR CORRECT ERROR RETURN
	TDNE	P2,DRBLOK(T2)	;% LOCKED?
	  PJRST	GIVCBR		;% YES - NON SKIP RETURN
	ORM	P2,DRBLOK(T2)	;% NO. NOW IT IS
	  PJRST	GIVCB1		;% GIVE UP CB AND SKIP-RETURN

COMMENT ;@@SUBROUTINE NLKPPB
@@PURPOSE RESET DRPLOK BIT IN DIRECTORY BLOCK (DRB)
@@ENTRY P1 CONTAINS THE STRUCTURE NAME P2 THE PPN
@@ACCUM P1,T2,T3,P2,T1
@@TABLES DRB TABLES
@@GLOBAL SYSDRB
@@ERRORS NONE, INCORRECT STR NAME OR NO FREE CORE IS NOT CONSIDERED
AN ERROR
@@CALLS PPBBIT,GIVCBR
@@EXIT NON-SKIP ONLY
@@FUNCTION IF PPBBIT() NON-SKIP [RETURN]
	CLEAR DRPLOK AND GO TO GIVCBR
@@;

NLKPPB:	PUSHJ	P,PPBBIT	;GET UFB, BIT TO CLEAR
	  POPJ	P,		;NOT AN STR NAME
	ANDCAM	P2,DRBLOK(T2)	;% CLEAR THE BIT
	PJRST	GIVCBR		;% GIVE UP CB AND RETURN

COMMENT ;@@SUBROUTINE PPBBIT
@@PURPOSE FIND A DRB AND RETURN A POINTER TO IT FOR LOKPPB AND NLKPPB
@@ENTRY P1 HAS STR NAME, P2 PPN
@@ACCUM P1,P2,T2,T3,T1
@@TABLES DRB TABLES
@@GLOBAL SYSDRB (NOT MODIFIED)
@@EXIT NON-SKIP RETURN IF NO CORE TO CREATE DRB OR STR NAME
INCORRECT. P1 SET TO ADDRESS OF APPROPRIATE ROUTINE
SKIP RETURN WITH T2 THE ADDRESS OF THE DRB AND P2 DRPLOK
@@ERRORS NOT ENOUGH CORE FOR DRB OR STR NAME NOT DSKB
@@CALLS SRCNAM,GETCBR,GIVCBR
@@FUNCTION  P1_@SNFERR
	IF STR#'DSKB' RETURN
	CALL GETCBR
	P1_@NCSERR
	IF SRCNAM(SYSDRB) NON-SKIP RETURN AND T2<0 (NO CORE)
		GO TO GIVCBR
	P2_DRPLOK
	SKIP-RETURN
@@;

PRINTF(<[PPBBIT Why must the STR name be DSKB here?  If DRBSTR setup?]>)
PPBBIT:	MOVE	T1,P1			;STR NAME
	MOVEI	P1,SNFERR		;ERROR RETURN, NOT F/S NAME
	CAME	T1,[SIXBIT /DSKB/]	;ONLY ONE PERMITTED
	  POPJ	P,			;NOT AN STR
	MOVE	T1,P2			;PRJ-PRG
	PUSHJ	P,GETCBR
	MOVEI	P1,NCSERR		;% ERROR RETURN, NOT ENOUGH CORE
	HLRZ	T2,SYSDRB		;% 1ST PPB IN SYSTEM
	MOVEI	T3,SYSDRB-CMBLNK	;% IN CASE THIS CREATES 1ST PPB BLOCK
	PUSHJ	P,SRCNAM		;% FIND PPB FOR THIS USER (MAY CREATE ONE)
	 JUMPLE T2,GIVCBR		;% CREATED ONE IF ENOUGH CORE
	MOVEI	P2,DRPLOK		;% THE BIT TO USE
	PJRST	CPOPJ1			;% RETURN
COMMENT ;@@SUBROUTINE GUFBT
@@PURPOSE DETERMINE NUMBER OF BLOCKS LEFT IN QUOTA FOR A GIVEN
UFD
@@ENTRY NONE
@@ACCUM T2,T4
@@TABLES DRB TABLES,JBTPPN
@@GLOBAL SYSDRB,JOB
@@EXIT T2 CONTAINS THE REMAINING QUOTA. IF QUOTA IS UNKNOWN
(BECAUSE DRB BLOCK NOT FOUND) T2 CONTAINS 1B0
@@RESTRICTIONS MUST BE CALLED AT UUO LEVEL FOR THE CURRENT JOB
@@CALLS NONE
@@FUNCTION SEARCH DRB TABLE FOR DRB WITH NAM=JBTPPN(JOB)
	IF NOT FOUND RETURN (1B0)
	RETURN (DRBALC(DRB TABLE))
@@ ;

GUFBT:	MOVE	T2,JOB			;% T2=JOB NUMBER
	MOVE	T4,JBTPPN(T2)		;% GET PROJ-R # FOR THIS JOB
	MOVEI	T2,SYSDRB-DRBLNK	;%READ TO LOOK AT FIRST DRB IN SYS
GUFBT1:	HLRZ	T2,DRBLNK(T2)		;% GET ADR. OF NEXT PPB
	JUMPE	T2,GUFBT3		;% NONE LEFT - RETURN WITH T2=0
	CAME	T4,DRBNAM(T2)		;% IS THIS PPB # SAME AS JOB'S?
	  JRST	GUFBT1			;% NO - REPEAT
	SKIPA	T2,DRBALC(T2)		;% YES - GET # FREE + RESERVED BLOCKS LEFT IN THIS UFB
GUFBT3:	  MOVSI	T2,400000		;% RETURN MOST NEGATIVE NUMBER IF NO UFB BLOCK
	POPJ	P,			;% GO DEPOSIT IT IN TABLE
SUBTTL	SRCFIL - MANIPULATE DIRECTORIES, ACCESS TABLES
;IN THIS MODULE P3=LOC OF FNB, P4=LOC OF DRB, P2=LOC OF ATB

COMMENT ;@@SUBROUTINE SRCFIL
@@PURPOSE DOES MANIPULATION OF CORE TABLES AND EXAMINATION
OF DIRECTORIES FOR LOOKUP, ENTER, AND RENAME.
@@ENTRY F POINTS TO DSK DDB, DEVFIL(F),DEVEXT(F), AND DEVPPN(F)
CONTAIN THE FILE NAME, EXTENSION, AND PPN DESIREC.
M HAS UUOLUK FOR LOOKUP, UUOENT OF ENTER OR UUOREN FOR RENAME.
ONLY ONE OF THESE MAY BE ON. M MAY HAVE UUOMLK FOR MULTIPLE LOOKUP.
@@ACCUM T1,T2,T3,T4
@@TABLES ALL IN-CORE TABLES (DRB, FNB, ATB) ARE USED AND POSSIBLY
MODIFIED.
@@GLOBAL SYSDRB,SYSCOR,SYSDOR
@@EXIT NON-SKIP RETURN ON ERROR, T1 CONTAINS ERROR CODE
SKIP RETURN IF OK, DEVACC(F) POINTS TO THE ATB. IOSRIB IN S
IS ON IF AND ONLY IF %RIB HAS THE FILE RIB IN IT (LOOKUP ONLY)
repeat 0,<FOR MULTIPLE LOOKUP, DEVEXT(F) IS SET TO THE CORRECT EXTENION.>
ERROR BITS MAY BE SET IF THERE WERE RIB ERRORS
@@ERRORS SEE EXIT CONDITIONS
@@RESTRICTIONS CALLED AT UUO LEVEL ONLY MAY WAIT FOR RESOURCES
@@CALLS GETCBR,GIVCBR,GIVCB1,SRCNAM,RELLOK,DIRSRC,LOKDIR
SETDDB,MAPRDL,PRMCHK,SRCAT,ULDATB,FREATB,GETCOR
@@ ;


SRCFIL:	JSP	T4,SAVE4
	TLZ	S,IOSRIB!IOSRBE!IO ;DO NOT HAVE RIB IN %RIB
	PUSHJ	P,GETCBR	;FOR THE INITIAL DRB SEARCH
	HLRZ	T2,SYSDRB	;%SEARCH FOR THIS DRB, FIRST IN T2
	MOVEI	T3,SYSDRB-DRBLNK
	MOVE	T1,DEVPPN(F)
	PUSHJ	P,SRCNAM	;%SEARCH FOR THE APPROPRIATE NAME
	  JUMPLE T2,ERRNEC	;%COULD NOT GET FREE CORE TO CREATE
	MOVEI	T3,DRPNX
	TDNE	T3,DRBNX(T2)	;% DO WE KNOW ITS NOT THERE?
	 JRST	ERRIPP		;% YES, NO UFD
	MOVE	P4,T2
	AOS	T1,DRBCNT(P4)	;%+ NOW ANOTHER USING IT
	TRNE	T1,DRPMXC	;%+ IS COUNT NOW TOO BIG (OVERFLOW)
FILDMO:: STOPCD (.,DISK,FILDMO,,<DRB Max count overflow>) ;;SRCFIL+16
	SKIPE	DRBRIB(P4)	;%+ DO WE KNOW WHERE IT IS?
	 JRST	DRBFND		;%+ YES, READY TO LOOK FOR FILE
	PUSHJ	P,GIVCBR
	PUSH	P,DEVFIL(F)	;+ SAVE NAME TO SET FOR DIR
	MOVE	T1,DEVEXT(F)
	TLZN	M,UUOMLK	;+ USE RH TO SAVE MLK BIT
	 TRZA	T1,-1
	  TRO	T1,-1
	PUSH	P,T1
	MOVE	T1,DEVPPN(F)
	MOVEM	T1,DEVFIL(F)
	MOVE	T1,MFDPPN
	MOVEM	T1,DEVPPN(F)
	MOVSI	T1,'UFD'
	HLLM	T1,DEVEXT(F)
	MOVE	T1,MFDRIB##	;+ GET RIB POINTER FOR MFD
	PUSHJ	P,DIRFST	;+ GET THE FIRST DIRECTORY BLOCK
	  JRST	SRCNUF		;+ NONE THERE
SRCULP:	PUSHJ	P,GETCBR	;+! NEED TO LOOK AT DRB IN CASE COMPLETED BY ANOTHER JOB
	MOVEI	T1,DRPNX
	TDNE	T1,DRBNX(P4)
	 JRST	SRCNU2		;%+! NOW KNOW ITS NOT THERE
	SKIPE	DRBRIB(P4)
	 JRST	DRBFN1		;%+! SOMEONE ELSE FOUND IT
	PUSHJ	P,GIVCBR
	PUSHJ	P,DIRSRC	;+! NOW SEARCH. MUST GIVE UP CB IN CASE PAGE FAULT
	  JRST	DRBFN2		;+! FOUND
	PUSHJ	P,DIRNXT	;+! GO ON TO THE NEXT DIR BLOCK
	  JRST	SRCNUF		;+! THAT WAS THE LAST
	JRST	SRCULP		;+! FOLLOWS LINKED HASH FORMAT
;+ HERE ON END OF FILE FOR THE MFD

SRCNUF:	PUSHJ	P,GETCBR
	SKIPE	DRBRIB(P4)	;%+ WAS IT REALLY FOUND BY SOMEONE ELSE (OR CREATED)
	 JRST	DRBFN3		;%+ YES
	MOVEI	T1,DRPNX
	IORM	T1,DRBNX(P4)	;%+ MARK NON-EXISTANT
SRCNU1:	SOS	DRBCNT(P4)
	POP	P,T1
	HLLM	T1,DEVEXT(F)
	TRNE	T1,-1
	 TLO	M,UUOMLK	;%+ RESET BIT
	POP	P,T1
	EXCH	T1,DEVFIL(F)
	MOVEM	T1,DEVPPN(F)
	JRST	ERRIPP		;% NO UFD

SRCNU3:	PUSHJ	P,GETCBR	;+! HERE ON A RIB ERROR
SRCNU2:	PUSHJ	P,RELLOK	;%+! NOW KNOWN NX
	JRST	SRCNU1		;%+ CLEAN UP AND GIVE IPP ERROR

DRBFN2:	MOVE	T1,%RIB+UFDRIB(T2)	;+! GET POINTER
	MOVEM	T1,DEVRIB(F)	;+! SAVE IT
	PUSHJ	P,RELLOK	;+! RELEASE CURRENT BLOCK
	MOVE	T1,DEVRIB(F)	;+ MAP IN RIB FOR DIRECTORY
	PUSHJ	P,MAPRDL
	PUSHJ	P,PRMCHK	;+! DO A PRIME RIB CHECK
	  JRST	SRCNU3		;+! RIB ERROR, SAY NO UFD
	PUSHJ	P,GETCBR
	SKIPE	DRBRIB(P4)	;%+! SOMEONE ELSE GOT IT
	 JRST	DRBFN1
	MOVE	T1,%RIB+RIBSLF
	MOVEM	T1,DRBRIB(P4)
	MOVE	T1,%RIB+RIBQTF
	SUB	T1,%RIB+RIBUSD
	MOVEM	T1,DRBALC(P4)
	MOVE	T1,%RIB+RIBQTF
	SUB	T1,%RIB+RIBMXA
	MOVEM	T1,DRBMXA(P4)
	DMOVE	T1,%RIB+RIBUNM
	DMOVEM	T1,DRBUNM(P4)
	LDB	T1,RIYPRV
	DPB	T1,DRYPRV
DRBFN1:	PUSHJ	P,RELLOK	;%+! ALL SET UP NOW
DRBFN3:	POP	P,T1		;%+
	HLLM	T1,DEVEXT(F)
	TRNE	T1,-1
	  TLO	M,UUOMLK	;%+ RESET BIT
	POP	P,T1
	EXCH	T1,DEVFIL(F)
	MOVEM	T1,DEVPPN(F)
	TLZ	S,IOSRBE	;FORGET ERROR FLAG
;%+ HERE WHEN WE HAVE A DRB ALL SET UP

DRBFND:	MOVEI	T1,DRPLOG	;%+ GET READY TO MARK LOGGED IN (DO NOT GARBAGE COLLECT)
	MOVE	T2,DEVPPN(F)
	MOVE	T3,JOB
	CAME	T2,JBTPPN(T3)
	CAMN	T2,MFDPPN
	  IORM	T1,DRBLOG(P4)
	CAME	T2,SYSPPN	;%+ SYS, MFD, SPOOLING ALWAYS SAVED
	CAMN	T2,SPLPPN
	  IORM	T1,DRBLOG(P4)
	MOVE	T1,DEVFIL(F)	;%+ SEARCH FOR THE FNB
	MOVEI	T3,DRBFNB-FNBLNK(P4)	;%+ DOWN POINTER
	HLRZ	T2,DRBFNB(P4)
	HLRZ	T4,DEVEXT(F)	;%+ USE T4 FOR EXT
	PUSHJ	P,SRCNAM	;%+ GO LOOK FOR IT
	  JRST	CREFNB		;%+ NOT FOUND, SHOULD HAVE BEEN CREATED
SRCFNB:	HRRZ	T3,FNBEXT(T2)	;%+ SAME EXT? (T3 NOT NEEDED NOW)
	TLNE	M,UUOMLK	;%+ FOO MULTIPLE LOOKUP
	  JRST	SRCMFB		;%+ SPECIAL CODE REQUIRED
	CAMN	T4,T3
	JRST	FNDFNB		;%+ YES FOUND
SRCFN0:	PUSHJ	P,SRCNM0	;%+ NO CONTINUE
	  JRST	CREFNB
	JRST	SRCFNB		;%+ CHECK NEXT

CREFNB:	JUMPLE	T2,ERRNC1	;%+ NOT ENOUGH CORE TO CREATE FNB
	HRRM	P4,FNBDRB(T2)	;%+ ALSO NEED DRB POINTER
	TLNE	M,UUOMLK
	  JRST	CREMFB		;%+ NEED MULTIPLE FNB BLOCKS
	HRRM	T4,FNBEXT(T2)	;%+ SAVE EXT
FNDFNB:	MOVE	P3,T2		;%+ GET POINTER WHERE IT BELONGS
	TLNN	M,UUOLUK	;%+ IS IT LOOKUP?
	  JRST	SRCENT		;%+ NO, DO ENTER CODE
	MOVSI	T1,FNPNX
	TDNE	T1,FNBNX(P3)	;%+ IS THE FNB FOR NX FILE?
	  JRST	ERRFNM		;%+ YES
	MOVEI	T1,ATPDEL!ATPSUP
	MOVEI	T3,ATPCRE!ATPREN ;%+ IGNORE DEL SUP, STOP ON CRE OR REN
	PUSHJ	P,SRCAT		;%+ LOOK FOR ACCESS TABLE
	  JRST	ERRFNM		;%+ ONE OF THE PROHIBITED AT ENTRIES
	  JRST	ERRNC1		;%+ NO ROOM
	AOS	ATBCNT(P2)	;%+ SET READ COUNT UP
	SKIPE	ATBDOR(P2)	;%+ IF IT IS DORMANT
	  PUSHJ	P,ULDATB	;%+ REMOVE FROM DORMANT LIST
	TLNN	M,UUOMLK
	  JRST	SRCLU1		;%+ NORMAL
	HRRM	P3,1(T4)	;%+ SAVE P2 AND P3 IN CORE BLOCK
	HRLM	P2,1(T4)
	HLRZ	T4,DEVEXT(F)	;%+ RELOAD
	SOS	(T4)		;%+ AND MARK ONE MORE FOUND
SRCLU1:	SKIPE	ATBRIB(P2)	;%+ DO WE KNOW WHERE THE RIB IS
	  PJRST	SRCLK1		;%+ YES, DONE, GIVE UP CB AND SKIP
	SKIPE	T1,FNBRIB(P3)	;%+ RIB KNOW IN FNB?
	  JRST	FILRB2		;%+ YES, MUST READ RIB TO SET AT
	TLNN	M,UUOMLK
	  JRST	SRCLU2
	HRRZ	T1,(T4)		;%+ SEE IF ANY WITH NO FNB
	JUMPE	T1,SRCLU2
	MOVE	T2,P3		;%+ YES, CONTINUE SEARCH
	MOVE	T1,DEVFIL(F)
	JRST	SRCFN0
CREMFB:	HLL	T4,(T4)		;%+ NEED TO CREATE ANOTHER, GET COUNT
CREMF0:	MOVS	P1,1(T4)
	TLNE	P1,-1		;%+ RH (NO LH) 0 IF NO FNB YET
	  JRST	[AOBJN T4,CREMF0 ;%+ MORE
	 STOPCD (SLO)]	;%+ ERROR IF OUT ;;CREFM0+5
	HRRM	P1,FNBEXT(T2)	;%+ SAVE EXTENSION
	JRST	FNDFNB		;%+ AND GO

SRCMFB:	HLL	T4,(T4)		;%+ GET COOUNT TO SEARCH EXT
SRCMF0:	MOVS	P1,1(T4)
	TLNN	P1,-1
	  CAIE	T3,(P1)
	 SKIPA			;%+ ALREADY FNB OR NO MATCH
	  JRST	FNDFNB		;%+ FOUND IT
	AOBJN	T4,SRCMF0
	HLRZ	T4,DEVEXT(F)	;%+ RELOAD
	JRST	SRCFN0		;%+ NONE MATCH, CONTINUE SEARCH

SRCDLM:	HLRZ	T4,DEVEXT(F)	;%+! NEED TO CHECK ALL FNB'S
SRCDL0:	HLL	T4,(T4)
SRCDM1:	MOVE	T2,1(T4)	;%+! GET ATB FNB PNTR
	TDNE	T1,FNBNX(T2)	;%+! NOW NX?
	  JRST	SRCDMD		;%+! YES, REMOVE
	SKIPE	FNBRIB(T2)
	  JRST	SRCDMC		;%+! FOUND ONE
	AOBJN	T4,SRCDM1
	JRST	SRCDMR		;%+! JUST CONTINUE

SRCDMC:	HRRZ	P3,T2
	HLRZ	P2,T2		;%+! JUST LOAD POINTERS
	JRST	SRCCFP		;%!+ AND GO

SRCDMD:	HRRZ	P3,T2
	HLRZ	P2,T2		;%+! LOAD POINTERS
	HLRZ	T1,DEVEXT(F)
	HLRO	T2,(T1)		;%!+ GET SET TO REMOVE
	MOVNS	T2
	ADD	T2,T1
	MOVE	T3,(T2)
	MOVEM	T3,1(T4)	;%+! REPLACE CURRENT WITH END
	MOVSI	T2,1
	ADDM	T2,(T1)		;%+! AND REDUCE COUNT
	SOS	T1,ATBCNT(P2)	;%+! DEC COUNT ON DELETED ONE
	TDNN	T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
	  PUSHJ	P,FREATB	;%+! MAY FREE IT
	HLRZ	T4,DEVEXT(F)
	SKIPL	(T4)
	  JRST	ERRFNF		;%+! RAN OUT, NO FILE
	MOVSI	T1,FNPNX
	JRST	SRCDL0		;%+! CONTINUE THE SEARCH

ERRFNM:	TLNN	M,UUOMLK	;%+ IF NOT MULTIPLE LOOKUP, NO FILE
	  JRST	ERRFNF
	HLRZ	T1,DEVEXT(F)
	HLRO	T2,(T1)
	MOVNS	T2
	ADD	T2,T1
	MOVE	T3,(T2)
	MOVEM	T3,1(T4)	;%+ REPLACE CURENT WITH LAST
	MOVSI	T2,1
	ADDB	T2,(T1)
	JUMPGE	T2,ERRFNF	;%+ ALL OUT, FORGET IT
	SOS	T2,(T1)		;%+ DECREMNT UNFOUND COUNT
	TRNN	T2,-1
	  JRST	SRCLU2		;%+ ALL FOUND, GO
	MOVE	T4,T1
	MOVE	T2,P3
	MOVE	T1,DEVFIL(F)
	JRST	SRCFN0		;%+ GO ON

MULCLN:	TLZN	M,UUOMLK	;% (AND POSSIBLY MORE)
	  POPJ	P,		;% NOTHING EXCEPT FOR MULTIPLE
	HLRZ	T4,DEVEXT(F)	;% POINTER TO EXTENSION LIST
	HLL	T4,(T4)		;% REMOVE ALL ATBS
	JUMPGE	T4,CPOPJ	;% IN CASE ALL GONE ALREADY
	PUSH	P,P3
	HRLM	P2,(P)		;% SAVE FNB AND ATB PNTRS
SRCLL0:	MOVE	T1,1(T4)
	TRNE	T1,-1		;% NOTHING THERE
	CAIN	P3,(T1)		;% OR SAME AS CURRENT
	  JRST	[HRRZ  T1,FNBEXT(P3)	;SET EXTENSION FROM THIS
		 HRLM  T1,DEVEXT(F)
		 JRST  SRCLL1]
	HRRZ	P3,T1
	HLRZ	P2,T1
	SOS	T1,ATBCNT(P2)
	TDNN	T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
	  PUSHJ	P,FREATB	;% GET RID OF ATB
	HRRZ	P3,(P)		;% FOR ABOVE CHECK
SRCLL1:	AOBJN	T4,SRCLL0
	POP	P,P3
	HLRZ	P2,P3
	HRRS	P3			;% JUST IN CASE
	POPJ	P,
;%+ NOW SEARCH THE UFD FOR THIS FILE

SRCLU2:	MOVE	T1,DRBRIB(P4)	;%+ GET POINTER TO UFD RIB
	PUSHJ	P,GIVCBR
	PUSHJ	P,DIRFST	;+ NOW GET FIRST DIRECTORY BLOCK
	  JRST	SRCDEF
SRCDLP:	PUSHJ	P,GETCBR
	MOVSI	T1,FNPNX
	TLNE	M,UUOMLK
	  JRST	SRCDLM
	TDNE	T1,FNBNX(P3)	;%+! IS FILE NOW KNOWN NX?
	  JRST	SRCFNX		;%+! YES
	SKIPE	FNBRIB(P3)	;%+! OR DO WE NOW KNOW RIB LOC?
	  JRST	SRCCFP		;%+! YES
SRCDMR:	PUSHJ	P,GIVCBR	;%+! GIVE UP CB BEFORE FAULT ON PAGE
	PUSHJ	P,DIRSRC	;+! LOOK FOR THE FILE NAME
	  JRST	SRCDFD		;+! FOUND
	PUSHJ	P,DIRNXT	;+! CONTINUE TO NEXT LINKED BLOCK
	  JRST	SRCDEF		;+ EOF (BLOCK UNLOCKED)
	JRST	SRCDLP		;+ TRY NEXT BLOCK

SRCFNX:	PUSHJ	P,RELLOK	;%+! KNOWN NX, DON'T NEED DIR
	TLZ	S,IOSRBE	;%+! FORGET ABOUT ANY ERROS SO FAR
SRCFN1:	SOS	T1,ATBCNT(P2)	;%+ NOT GOING TO WANT ATB ANY MORE
	TLNN	M,UUOLUK	;%+ LOOKUP DIFFERENT THAN ENTER-RENAME
	  JRST	SRCNX0		;%+ HANDLE ENTER AND RENAME
	TDNN	T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
				;%+ ANY ONE ELSE USING THIS
	  PUSHJ	P,FREATB	;%+ NO, RETURN TO FREE STORAGE
	JRST	ERRFNF		;%+ AND SAY NOT FOUND

SRCNX0:	MOVEI	T1,ATPUPD	;%+ MUST RESET UPD ON ENTER-RENAME
	ANDCAM	T1,ATBSTS(P2)
SRCENX:	TLNE	S,IOSRBE
	  JRST	ERRTR1		;%+ SAY BAD TRANSFER
	MOVE	T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
	TDNN	T1,ATBCNT(P2)	;%+ ANYONE ELSE USING IT?
	  JRST	SRCNX1		;%+ NO, CAN USE THIS ATB
	PUSHJ	P,GETCOR	;%+ YES, MAKE A NEW ATB
	JUMPLE	T2,ERRNC1	;%+ IF THERE IS ROOM
	MOVE	P2,T2
	PUSHJ	P,LNKATB	;%+ LINK IT IN
SRCNX1:	MOVEI	T1,ATPCRE	;%+ SET TO CRE
	TLNE	M,UUOREN
	  MOVEI	T1,ATPREN	;%+ OR RENAME
	IORM	T1,ATBSTS(P2)
	JRST	SRCFNI		;%+ SET DEVATB AND DRB

SRCDEF:	PUSHJ	P,GETCBR	;+ COME HERE ON EOF FOR UFD
	SKIPE	FNBRIB(P3)	;%+ HAS SOMEONE ELSE FOUND IT
	  JRST	SRCCF1		;%+ YES, FINISH UP
	MOVSI	T1,FNPNX
	TLNN	S,IOSRBE	;%+ MAY HAVE JUST BEN ERROR. NOT NX
	  IORM	T1,FNBNX(P3)	;%+ NO MARK NX
	JRST	SRCFN1		;%+ AND TREAT AS IF WE FOUND NX SET
SRCCFP:	PUSHJ	P,RELLOK	;%+! HERE IF SOMEONE ELSE FOUND IT
SRCCF1:	TLNE	M,UUOLUK
	  JRST	SRCLU1		;%+ FINISH LOOKUP
SRCSUP:	TLNE	M,UUOREN
	  JRST	ERRFB1		;%+ RENAME NOT PERMITTED, GIVE ERR
	SKIPN	ATBRIB(P2)	;%+ DO WE ALREADY HAVE RIB DATA?
	  JRST	FILRB1		;%+ NO, NEED PROTECTION ETC.
SRCSP0:	MOVEI	T1,ATPUPD	;%+ HAVE RIB, RESET
	ANDCAM	T1,ATBSTS(P2)
	SOS	T1,ATBCNT(P2)	;%+ ANYONE ELSE STILL USING IT?
	TDNN	T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
	  JRST	SRCSP1		;%+ NO, WE CAN USE IT
	PUSHJ	P,GETCOR	;%+ MUST GEN A NEW ONE
	JUMPLE	T2,ERRNC1
	MOVE	T1,ATBPVW(P2)
	MOVEM	T1,ATBPVW(T2)	;%+ KEEP OLD PROTECTION
	MOVE	T1,ATBLCW(P2)	;%+ IN CASE WE WANT TO PRESERVE LIC
	MOVEM	T1,ATBLCW(T2)
	MOVE	P2,T2
	PUSHJ	P,LNKATB
SRCSP1:	MOVEI	T1,ATPSUP
	IORM	T1,ATBSTS(P2)
	JRST	SRCFNI

SRCDFD:	PUSHJ	P,GETCBR	;+! FOUND FILE IN DIR
	SKIPE	FNBRIB(P3)
	  JRST	SRCCFP		;%+! SOMEONE ELSE DID TOO
	MOVE	T1,%RIB+UFDRIB(T2)
	MOVEM	T1,FNBRIB(P3)
	MOVE	T1,DEVREL(F)	;%+! GET POSITION FOUND IN
	DPB	T1,FNYUFP	;%+! AND SAVE PAGE NUMBER IN UFD
	PUSHJ	P,UFDATB	;%+! FILL IN ATB FROM UFD ENTRY
				;%+!  IN CASE THERE IS A RIB ERROR, WILL KNOW WHETHER OR NOT OK TO DELETE.
				;%+! (UNFORTUNATELY WE WILL LOSE RIPN RIB ERROR)
	JRST	SRCCFP		;%+! GO AFTER SETTING RIB PTR

SRCENT:	MOVEI	T1,ATPDEL
	MOVEI	T3,ATPMXU!ATPCRE!ATPSUP!ATPUPD!ATPREN
	PUSHJ	P,SRCAT		;%+ ANY UPDATE ETC ILL FOR REN OR ENT
	  JRST	ERRFBM		;%+ FOUND PROHIBITED ATB
	  JRST	ERRNC1		;%+ NO ROOM FOR ATB
	SKIPE	ATBDOR(P2)
	  PUSHJ	P,ULDATB	;MAKE UN-DORMANT
	MOVSI	T1,FNPNX
	TDNE	T1,FNBNX(P3)	;%+ IS FILE KNOWN NX
	  JRST	SRCENX		;%+ YES, THIS IS A CREATE
	AOS	ATBCNT(P2)
	MOVEI	T1,ATPUPD
	IORM	T1,ATBSTS(P2)	;%+ SET COUNT AND UPD AND GO
	SKIPE	FNBRIB(P3)	;%+ IF RIB POSITION KNOWN
	  JRST	SRCSUP		;%+ ITS A SUPERCEDE
	JRST	SRCLU2
;%+ HERE WHEN WE NEED TO READ IN THE RIB FOR THIS FILE

FILRB1:	MOVE	T1,FNBRIB(P3)
FILRB2:	MOVEM	T1,DEVRIB(F)	;STORE IT (MULCLN MAY DESTRY)
	PUSHJ	P,MULCLN	;GETS DEVEXT SET RIGHT
	PUSHJ	P,GIVCBR	;%+ TO GET READY FOR A MAP OP
	MOVEI	PG,%RIB.C
	MOVE	T1,DEVRIB(F)	;+ RESTORE RIB PNTR
	PUSHJ	P,MAPRDL
	PUSHJ	P,PRMCHK
	  JRST	[TLNN M,UUOIRE	;+! SOMETHING WRONG WITH RIB.
		JRST  ERRTRN	;+! GIVE RIB ERROR RETURN IF NOT IGNORING
		PUSHJ P,GETCBR	;+! NEED CB SO NO ONE WILL FILL IT IN BEHIND OUR BACKS
		JRST  FILRBD]	;+! GO WITH INFO FROM UFD COLLECTED EARLIER, CALLER KNOWS
				;+! WHAT HE'S DOING WE HOPE.
	PUSHJ	P,GETCBR
	SKIPE	ATBRIB(P2)	;%+! DID SOMEONE BEAT US TO IT
	  JRST	FILRBD
	MOVE	T1,%RIB+RIBSLF	;%+! NOW MOVE THE STUFF TO ATB
	MOVEM	T1,ATBRIB(P2)
	MOVE	T1,%RIB+RIBPVW
	MOVEM	T1,ATBPVW(P2)
	MOVE	T1,%RIB+RIBLCW
	MOVEM	T1,ATBLCW(P2)
	MOVE	T1,%RIB+RIBPID
	MOVEM	T1,ATBPID(P2)
	MOVE	T1,%RIB+RIBMSC
	HRLM	T1,ATBMSC(P2)
	MOVE	T1,%RIB+RIBALP
	MOVEM	T1,ATBALP(P2)
	MOVE	T1,%RIB+RIBALT	;GET DIRTY TIMER
	MOVEM	T1,FNBALT(P3)	;SETUP IN FNB.
	MOVE	T1,%RIB+RIBSIZ
	TRNE	T1,177
	  ADDI	T1,200		;%+! INC BLOCK COUNT IF EXTRA WDS IN LAST BLOCK
	MOVEM	T1,ATBSIZ(P2)
	MOVEI	T1,0
	MOVE	T2,%RIB+RIBSTS	;%+! GET STATUS WORD
	TRNE	T2,RIPDIR
	  TRO	T1,ATPDIR
	TRNE	T2,RIPNDL
	  TRO	T1,ATPNDL	;%+! AND SET A COUPLE OF STATUS BITS
	IORM	T1,ATBSTS(P2)
FILRBD:	TLNN	M,UUOLUK	;%+! IS THIS A LOOKUP?
	  JRST	[PUSHJ P,RELLOK	;%+! ENTER, RELEASE BLOCK
		JRST   SRCSP0]	;%+ AND GO
	TLO	S,IOSRIB	;%+! HAVE RIB
SRCLK1:	PUSHJ	P,MULCLN	;%+! GET RID OF EXTRA ATBS
SRCFNI:	HRRM	P2,DEVATB(F)	;%+! (OR %+ IF IOSRIB=0)
	HRLM	P4,DEVDRB(F)
	TLNE	M,UUOREN
	  PJRST	GIVCB1		;DON'T FIDDLE IF RENAME
	HRRZ	T1,FNBDBL(P3)
	HRRM	F,FNBDBL(P3)
        CAIE	T1,(F)		;PREVENT LINK FROM POINTING TO ITSELF
	  HRRM	T1,DEVDBL(F)	;%+! SET DDB LINK (FOR INSERT AND DELETE)
	PJRST	GIVCB1
;ERROR ROUTINES FOR SRCFIL

ERRNC1:	PUSHJ	P,MULCLN	;%+ REMOVE EXTRA ATBS IF ANY
	SOS	T1,DRBCNT(P4)	;%+ NOT ENOUGH CORE
	TRNE	T1,DRPMXC	;% UNDERFLOW?
FILDMU:: STOPCD (.,DISK,FILDMU,,<DRB Max count underflow>)    ;;ERRNC1+3
ERRNEC:	MOVEI	T1,NECERR	;% F still points to DDB
	PJRST	GIVCBR

ERRIPP:	MOVEI	T1,IPPERR	;% CAN NOT FIND UFD
	PJRST	GIVCBR

ERRTRN:	PUSHJ	P,GETCBR	;
	PUSHJ	P,MULCLN
	PUSHJ	P,RELLOK	;%+! (ACTUALLY RIB ERROR)
	MOVEI	T1,ATPUPD	;%+ UPD SET IF ENTER OR RENAME
	TLNN	M,UUOLUK
	 ANDCAM	T1,ATBSTS(P2)	;%+ SO RESET
	SOSA	T1,ATBCNT(P2)
ERRTR1:	MOVE	T1,ATBCNT(P2)	;%+ SOME RIB OR UFD ERROR
	TDNN	T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
				;%+ STILL HAVE USERS?
	  PUSHJ	P,FREATB	;%+ NO, RETURN TO FREE CORE
	SOS	T1,DRBCNT(P4)	;%+
	TRNE	T1,DRPMXC
	 STOPCD (,XCT,FILDMU)	;% UNDEFLOW     ;;ERRTR1+5
	MOVEI	T1,TRNERR	;% FINALLY THE ERROR
	PJRST	GIVCBR

ERRFB1:	MOVEI	T1,ATPUPD	;%+ FILE IN USE ON RENAME
	ANDCAM	T1,ATBSTS(P2)
	SOS	T1,ATBCNT(P2)
	TDNN	T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
	  PUSHJ	P,FREATB	;%+ RETURN ATB IF NO OTHER USERS
ERRFBM:	SOS	T1,DRBCNT(P4)	;%+ FBM ON ENTER OR RENAME
	TRNE	T1,DRPMXC
	 STOPCD (,XCT,FILDMU)	;% UNDEFLOW     ;;ERRFBM+2
	MOVEI	T1,FBMERR
	TLNE	M,UUOREN
	  MOVEI	T1,AEFERR	;% DIFFERENT FOR ENTER
	PJRST	GIVCBR

ERRFNF:	PUSHJ	P,MULCLN
	SOS	T1,DRBCNT(P4)	;%+ CAN NOT FIND FILE
	TRNE	T1,DRPMXC	;% UNDERFLOW?
	 STOPCD (,XCT,FILDMU)   ;;ERRFNF+3
	MOVEI	T1,FNFERR	;% FINALLY THE ERROR
	PJRST	GIVCBR
;THIS ROUTINE RELEASES A LOCKED BLOCK (%RIB)

RELLOK:	MOVEI PG,%RIB.C
	PJRST MAPRLS

;SEARCH A DIRECTORY BLOCK IN %RIB. USE DEVNAM AND DEVEXT
; TO DECIDE WHAT TO LOOK FORR

; NON-SKIP RETURN IF FOUND. T2 POINTS TO UFD ENTRY
;SKIP RETURN - NOT FOUND

DIRSRC:	MOVSI T2,-<^D512/UFDSIZ>	;NUMBER OF ENTRIES
	MOVE T1,DEVFIL(F)
	HLL T3,DEVEXT(F)
DIRSR1:	CAMN T1,%RIB+UFDNAM(T2)
	JRST DIRSC1
DIRSR2:	ADDI T2,UFDSIZ-1
	AOBJN T2,DIRSR1
	PUSHJ P,GETER1
	JUMPN T1,DIRSCE		;SOME ERROR THERE
	JRST CPOPJ1		;NOT FOUND

DIRSC1:	HRR T3,%RIB+UFDEXT(T2)
	CAME T3,%RIB+UFDEXT(T2)
	JRST DIRSR2	;NOT THIS ONE
DIRSC5:	PUSHJ P,GETER1	;LOAD THE ERROR BITS
	JUMPE T1,CPOPJ	;FOUND NO ERROR
DIRSCE:	TLO S,IOSRBE	;SET ERROR BIT
	JRST CPOPJ1	;AND GO
COMMENT ;@@SUBROUTINE DRRSRC
@@PURPOSE SEARCH UFD PAGE FOR A FILE'S
PRIME RIB POINTER.
@@ENTRY ATB ADDRESS IN P2, UFD PAGE IN %RIB.
@@ACCUM T1-T4.
@@EXIT SKIP RETURN WITH INDEX INTO %RIB IN T2
FOR UFD ENTRY IF FOUND, ELSE NON-SKIP RETURN.
@@;

DRRSRC::MOVSI	T2,<-^D512/UFDSIZ> ;NUMBER TO SEARCH
	PUSHJ	P,GETER1	;ERRORS?
	JUMPN	T1,CPOPJ	;JUMP IF YES.
	SKIPN	T1,ATBRIB(P2)	;HAS FILE'S RIB DISAPPEARED?
	POPJ	P,		;YES, GO HOME.

DRRSR1:	SKIPN	%RIB+UFDNAM(T2)	;THIS THE END?
	POPJ	P,		;YES NOT FOUND
	CAMN	T1,%RIB+UFDRIB(T2) ;CORRECT POINTER?
	JRST	CPOPJ1		;YES, GIVE INDEX BACK IN T2
	ADDI	T2,UFDSIZ-1	;ADD ALL BUT ONE AND
	AOBJN	T2,DRRSR1	;AOBJN AROUND.
	POPJ	P,		;OUT OF ENTRIES, ITS NOT THERE.
;REMOVE A NAME FROM THE DIRECTORY

INTERNAL DLTNAM

UFDLST==<1000/UFDSIZ-1>*UFDSIZ

DLTNAM:	TLO S,IO
	PUSHJ P,RIBDIR	;GET DIRECTORY RIB
	 JRST RELLOK	;ERROR, CAN NOT GET IT
	LDB T1,FNYUFP
	PUSHJ P,DIRBLK
	 POPJ P,	;ALSO FAILED TO GET IT
	TLZ M,UUOMLK	;MAKE SURE
	PUSHJ P,DIRSRC
	 SKIPA
	JRST RELLOK	;NOT THERE
	HRRZS T2
	CAIN T2,UFDLST	;JUST IN CASE LAST NAME
	JRST DLTNM1
	HRLI T1,%RIB+UFDSIZ(T2)
	HRRI T1,%RIB(T2)
	BLT T1,%RIB+UFDLST-1
DLTNM1:	SETZM %RIB+UFDLST
	MOVE T1,[%RIB+UFDLST,,%RIB+UFDLST+1]
	BLT T1,%RIB+UFDLST+UFDSIZ-1
	PJRST RELLOK	;FINISHED ZEROING, RELEASE BLOCK
;NOW INSERT A NAME IN THE DIRECTORY.   NAME IN DDB POINTED TO BY F.
;EXPECTS T2/ 0 OR RET PNTR SUPPLIED BY CALLER IN CASE WE HAVE TO
;EXTEND THE DIRECTORY.
;SKIP RETURNS ON SUCCESS, WITH T2/ POINTER TO THE EMPTY ENTRY
;WE FOUND.
;NON-SKIP RETURNS ON FAILURE, WITH T1/ FALAQA IF WE RAN OUT
;OF ROOM, ELSE T1/ 0.

INSNAM::JUMPE	T2,INSNM0	;CHECK THE FORM OF
	TLNN	T2,RBMASK-RBREAL ;THE RETRIEVAL
	TLNN	T2,RBREAL	;PNTR.
	 STOPCD (SLO)           ;;INSNAM+3
INSNM0:	PUSH	P,T2		;SAVE RET PNTR.
	TLO	S,IO		;MAKE SURE WE WRITE LOCK
	MOVE	T1,DRBRIB(P4)
	PUSHJ	P,DIRFST
	  JRST	INSNML		;MIGHT BE A NX BLOCK HERE
INSNLP:	PUSHJ	P,FNDFRE
	  JRST	INSNM1		;HERE WE HAVE A SPOT TO PUT IT
	PUSHJ	P,DIRNXT
	  JRST	INSNML		;TRY AGAIN TO INSERT A BLOCK
	JRST	INSNLP		;KEEP LOOKING FOR A FREE SPOT

    ;TINY SUBR TO SEE IF THERE IS AN EMPTY ENTRY IN THIS PAGE OF
    ;THE DIRECTORY.

FNDFRE:	SKIPE	%RIB+UFDLST	;ANY FREE ENTRIES IN PAGE
	 JRST	CPOPJ1		;NONE FREE IF LAST NOT FREE
	MOVSI	T2,-1000/UFDSIZ	;YES, AT LEAST ONE
FNDFR1:	SKIPN	%RIB(T2)
	 POPJ	P,		;FOUND THE FIRST EMPTY ONE
	ADDI	T2,UFDSIZ-1
	AOBJN	T2,FNDFR1
	 STOPCD (SLO)		;THERE WAS ONE FREE (@FNDFRE+2) ;;FNDFR1+4

INSNML:	MOVE	T1,DRBRIB(P4)	;NEED TO ADD A BLOCK
	MOVEI	PG,%RB2.C
	PUSHJ	P,MAPWTL
	PUSHJ	P,MAPXCH	;FOR CHECKING
	PUSHJ	P,RIBCKD
	  JRST	[PUSHJ  P,MAPXCH
		PJRST   INSFER]	;REL RB2, DISK PAGE, FAIL EXIT.
	PUSHJ	P,MAPXCH
	TLO	S,IOSRIB	;NEED TO SEARCH AGAIN WITH RIB LCCKED
	MOVE	T1,DRBRIB(P4)
	PUSHJ	P,DIRFST
	  JRST	INSFAK		;THIS MUST BE A NX PNTR
INSNL2:	PUSHJ	P,FNDFRE	;THERE MAY NOW BE FREE SPACE
	  JRST	INSGOT		;YES, OR NEW BLOCK OR SOMETHING
	PUSHJ	P,DIRNXT
	  JRST	INSLNK		;INSERT A NEW LINK
	JRST	INSNL2		;KEEP LOOKING

INSGOT:	PUSH	P,T2		;SAVE DIRECTORY SLOT FOUND THIS TIME
	PUSHJ	P,RELRB2	;RELEASE %RB2.
	POP	P,T2

INSNM1:	MOVE	T1,DEVBLK(F)
	DPB	T1,FNYUFP	;REMEMBER WHERE IT IS IN UFD
	EXCH	T2,(P)		;SAVE FOUND SLOT, GET DISK PAGE.
	JUMPE	T2,INSNM4	;IF HAVE A DISK PAGE,
	PUSH	P,PG		; WE HAVE
	PUSH	P,GIVPAG	; TO GIVE IT
	POP	P,PG		; BACK.
INSNM4:	POP	P,T2		;RESTORE PNTR TO SLOT FOUND.
	JRST	CPOPJ1

INSFAK:	TLNE	S,IOSRBE	;WAS THERE REALLY AN ERROR?
	 JRST	INSFER		;YES.
INSFK2:	POP	P,T2		;
	JUMPN	T2,INSFK4	;
	TLO	S,IOSALC	;NO, NEED TO ADD A NEW BLOCK
	MOVEI	T1,FBIT##
	HRRZ	T3,DEVATB(F)	;T3/ ATB ADDR OR ZERO.
	PUSHJ	P,GETAPG
	  JRST	INSFQ2		;
	TLZ	S,IOSALC
INSFK4:	MOVE	T1,DEVBLK(F)
	DPB	T1,FNYUFP
	MOVEM	T2,%RB2+RIBPFS(T1)	;DEVBLK IS POINTER
	MOVE	T1,T2
	MOVEI	PG,%RIB.C
	PUSHJ	P,MAPWLN	;A NEW BLOCK
	AOS	%RB2+RIBALP	;COUNT A NEW DIRECTORY PAGE
	SETZM	%RIB
	MOVE	T1,[%RIB,,%RIB+1]
	BLT	T1,%RIB+777
	PUSHJ	P,RELRB2	;RELEASE %RB2.
	MOVEI	T2,0
	JRST	CPOPJ1		;HAVE IT ALL DONE

    ;HERE ON A HOLE, EOF, OR RIB ERROR FOR THE DIRECTORY.
INSLNK:	TLNE	S,IOSRBE
	  JRST	INSFER		;ERROR.
	TLNN	S,IOSRIB
	  JRST	INSFK2		;REALLY A NX PNTR
	SKIPE	T2,(P)		;MAKE SURE WE HAVE A DISK
	  JRST	INSL00		;PAGE BEFORE WE GO TO THE
	MOVEI	T1,FBIT		;TROUBLE OF
	HRRZ	T3,DEVATB(F)	;UPDATING THE
	PUSHJ	P,GETAPG	;COUNTS.
	JRST	INSFQO		;
	MOVEM	T2,(P)		;
INSL00:	MOVSI	T1,RIBPFS-RIBLST-1
INSLK0:	SKIPN	%RB2+RIBPFS(T1)	;LOOK FOR A PLACE TO PUT ONE
	  JRST	INSEOF
	AOBJN	T1,INSLK0
	JRST	INSFER		;DIRECTORY FULL.

INSEOF:	HRRZM	T1,DEVBLK(F)	;STORE AS POINTER
	HRRZM	T1,%RIB+UFDLNK
	DPB	T1,FNYUFP	;SLOT ALSO
	PUSHJ	P,RELRIB	;RELEASE %RIB.
	MOVEI	T1,1000
	ADDM	T1,%RB2+RIBSIZ
	PUSHJ	P,GETCBR	;MAY BE BEING READ AS A FILE
	HLRZ	T2,SYSDRB
	MOVNI	T3,1
	MOVE	T1,MFDPPN
	PUSHJ	P,SRCNAM
	  JRST	INSNAT
	HLRZ	T2,DRBFNB(T2)
	MOVE	T1,DEVPPN(F)
	PUSHJ	P,SRCNAM
	  JRST	INSNAT
	HLRZ	T2,FNBATB(T2)
INSXAT:	MOVE	T1,ATBSTS(T2)
	TRNE	T1,ATPREN!ATPCRE!ATPUPD!ATPSUP!ATPDEL
	  JRST	INSIAT		;IGNORE THIS
	MOVEI	T1,1000
	ADDM	T1,ATBSIZ(T2)
INSIAT:	HLRZ	T2,ATBLNK(T2)
	JUMPN	T2,INSXAT
INSNAT:	PUSHJ	P,GIVCBR
	JRST	INSFK2		;NOW TREAT LIKE OTHER

    ;ERROR EXITS.
INSFER:	TDZA	T2,T2		;HERE ON RIB ERROR.
INSFQO:	  MOVEI	T2,FALAQA	;HERE ON ALLOCATION ERROR.
	EXCH	T2,(P)		;SAVE ERR CODE, GET RET PNTR.
	PUSH	P,T2		;SAVE RET PNTR.
	PUSHJ	P,RELRB2	;RELEASE RIB FIRST, TO SPEED
	POP	P,T2		;UP SYSTEM. GET RET PNTR AGAIN.
	JUMPE	T2,INSFR4	;GIVE BACK THE DISK PAGE, IF
	PUSH	P,PG		;WE
	PUSHJ	P,GIVPAG	;HAVE
	POP	P,PG		;IT.
INSFR4:	POP	P,T1		;RESTORE T1/ ERROR CODE.
	POPJ	P,

INSFQ2:	PUSHJ	P,RELRB2	;
	MOVEI	T1,FALAQA	;
	POPJ	P,		;
;TWO ROUTINES TO SEARCH CORE TABLES

;SRCNAM SEARCHES FOR FNB AND DRB BLOCKS
;	ALWAYS CALL WITH CB RESOURCE
;	T1 NAME TO SEARCH FOR
;	T2 CURRENT POINTER (POSSIBLY 0)
;	T3 PRVIOUS POINTER
;	T3 LH NEG IF DO NOT CREATE NEW TABLE
;
;	WILL CONSTRUCT A NEW ENTRY AND LINK TO END OF LIST IF NOT FOUND

; NON-SKIP RETURN IF NOT FOUND T2<=0 IF NO CORE FOR NEW TABLE
;	T2>0 POINTS TO NEW TABLE
; SKIP RETURN, FOUND, T2 HAS POINTER

SRCNAM:	JUMPE T2,SRCNMC	;NEED A NEW ONE
SRCNM1:	CAMN T1,CMBNAM(T2)
	JRST CPOPJ1	;FOUND
SRCNM0:	HRR T3,T2	;CONTINUE BY PUSHJ TO HERE
	HLRZ T2,CMBLNK(T2)	;NEXT
	JUMPN T2,SRCNM1	;THERE IS ONE
SRCNMC:	JUMPL T3,CPOPJ	;DO NOT CREATE NEW TABLE
	PUSHJ P,GETCRL	;GET SPACE FOR IT (DON'T GC T3)
	 POPJ P,	;NO ROOM, T2=0
	MOVEM T1,CMBNAM(T2)	;STORE NAME
	HRLM T2,CMBLNK(T3)	;LINK TO END OF CHAIN
	POPJ P,

;SRCAT SEARCHES FOR ACCESS TABLES
;	ALWAYS CALL WITH CB RESOURCE
;	P3 HAS POINTER TO FNB
;	T1 HAS BITS TO BE CHECKED IN ATBSTS, IF ON IGNORE AT
;	T3 HAS BITS TO BE CHECK IN ATBSTS, IF ON, ERROR
;
; NON-SKIP RETURN IF ANY ERROR BITS ON
; SKINGLE SKIP RETURN IF NO CORE TO CREATE NEW AT
; DOUBLE SKIP RETURN IF ALL OK, P2 HAS ATB POINTER

SRCAT:	HLRZ T2,FNBATB(P3)
	JUMPE T2,SRCATC	;NONE THERE, NEED A NEW ONE
	MOVEI P2,0	;NONE FOUND YET
SRCAT0:	TDNE T3,ATBSTS(T2)	;ANY PROHIBITED BITS?
	POPJ P,		;YES
	TDNN T1,ATBSTS(T2)	;IGNORE THIS ONE?
	MOVE P2,T2	;NO, SAVE IT
	HLRZ T2,ATBLNK(T2)	;NEXT
	JUMPN T2,SRCAT0	;CONTINUE IF MORE
	JUMPN P2,CPOPJ2		;DID WE FIND ONE, YES GOOD
SRCATC:	MOVSI T1,FNPLOK
	IORM T1,FNBLOK(P3)	;LOCK FNB SO NO GARBAGE COLLECT
	PUSHJ P,GETCOR
	 JFCL	;IGNORE ERROR (T2 WILL BE 0)
	MOVSI T1,FNPLOK
	ANDCAM T1,FNBLOK(P3)	;UNLOCK
	SKIPN P2,T2
	JRST CPOPJ1	;ERROR
	AOS (P)
	AOS (P)
	JRST LNKATB	;LINK INTO RING
;ROUTINES TO DO LINKING AND UNLINKING

;LNKATB LINKS AN ACCESS ATBLE TO THE FNB RING
;	P3 POINTER TO FNB
;	P2 POINTER TO ATB

;WILL SET FNBATB,ATBLNK,ATBFNB
;	SHOULD BE CALLED WITH CB RESOURCE

LNKATB:	HRRM	P3,ATBFNB(P2)
	HLLZ	T1,FNBATB(P3)	;GET OLD LINK
	HLLM	T1,ATBLNK(P2)	;POINT NEW ONE TO IT
	HRLM	P2,FNBATB(P3)	;AND POINT FNB TO NEW ONE
	POPJ	P,

;RMVATB RETURNS AN ATB TO FREE CORE
;IF THE ATB IS DORMANT, IT UNLINKS IT FROM THE DORMANT LIST
;	P2 POINTER TO ATB
;	P3 POINTER TO FNB

;SHOULD BE CALLED WITH CB RESOURCE

RMVATB:	SKIPE	ATBDOR(P2)
	  PUSHJ	P,ULDATB		;UNLIK ATB FROM DORMANT LIST

;FREATB IS LIKE RMVATB BUT ATB IS KNOWN NOT TO BE DORMANT

FREATB:	MOVEI	T1,FNBATB-ATBLNK(P3)	;SET PRED.
FREAT1:	HLRZ	T2,ATBLNK(T1)
	SKIPN	T2		;SHOULD NOT REACH END OF LIST
	 STOPCD (.,DISK,FILANF,,<ATB not found in list>)      ;;FREAT1+2
	CAME	T2,P2
	 SKIPA	T1,T2		;NOT SAME, GET PRED=THIS
	 SKIPA	T2,ATBLNK(T2)	;SAME, GET LINK
	  JRST	FREAT1		;NO SAME, CONTINUE SEARCH
	HLLM	T2,ATBLNK(T1)	;LINK AROUND THIS ONE
	MOVE	T1,SYSCOR
	HLLM	T1,CMBLNK(P2)	;LINK TO FREE CORE LIST
	HRLZM	P2,SYSCOR
	POPJ	P,

;ROUTINE TO REMOVE DDB FROM FNBDBL LINK

INTERNAL ULKDBL

ULKDBL:	MOVEI	T2,FNBDBL-DEVDBL(P3)	;FOR A START
ULKDB0:	HRRZ	T1,DEVDBL(T2)
	CAIN	T1,(F)		;HAVE WE FOUND THIS ONE YET?
	  JRST	ULKDB1		;YES
	SKIPN	T2,T1		;NO, BETTER NOT BE AT END
	 STOPCD (.,DISK,FILBNF,,<DDB Not found in FNB device block list>);;ULKDB0+4
	JRST	ULKDB0

ULKDB1:	HRRZ	T1,DEVDBL(F)	;ONE WE POINT TO
	HRRM	T1,DEVDBL(T2)	;LINK AROUND THIS DDB
	HLLZS	DEVDBL(F)		;JUST TO MAKE SURE
	POPJ	P,
;ULDATB REMOVES AN ATB FROM THE DORMANT LIST.. SEE COMMOD
;FOR A DESCRIPTION OF THE DORMANT LIST.
;	P2=POINTER TO ATB

;SHOULD BE CALLED WITH THE CB RESOURCE

ULDATB:	MOVE	T1,ATBDOR(P2)
	HLLM	T1,ATBDOR(T1)	;RESET FORWARD POINTER OF PREVIOUS
	CAIN	T1,SYSDOR-ATBDOR
	  JRST	ULDAT1		;THIS IS THE ONLY DORMAT AT IF SO
	MOVSS	T1		;NO RH IS NEXT IN CHAIN
	TRNN	T1,-1		;MIGHT BE LAST
	  HRRI	T1,SYSDOR-ATBDOR ;IF SO, POINT BACK TO START
ULDAT1:	HLRM	T1,ATBDOR(T1)	;RESET PREVIOS PNTR OF NEXT
	SETZM	ATBDOR(P2)	;NOT DORMANT ANY MORE
	POPJ	P,

;LKDATB PUTS AN ATB ON THE DORMANT LIST
;	P2=POINTER TO ATB

;SHOULD BE CALLED WITH CB RESOURCE

LKDATB:	SKIPE	ATBDOR(P2)	;MUST NOT ALREADY BE DORMANT
	 STOPCD (SLO)           ;;LKDATB+1
	HLRZ	T1,SYSDOR
	HRLM	P2,SYSDOR	;PUT ON END OF LIST
	HRLI	T1,SYSDOR-ATBDOR
	MOVSM	T1,ATBDOR(P2)	;SET BACK LINK TO OLD LAST
	TRNN	T1,-1
	  MOVSS	T1		;THIS WILL HAPPEN ONLY IF NO PREVIOUS ENTRIES
	HRRM	P2,ATBDOR(T1)	;STORE AS FORWARD LINK FOR OLD LAST ENTRY
	POPJ	P,

;HERE WITH CB TO FIND A DRB IF IT EXISTS
;T1 HAS PPN

FNDDRB:	HLRZ	T2,SYSDRB
	MOVNI	T3,1		;DO NOT CREATE
	PJRST	SRCNAM		;THAT WAS EASY

;ROUTINE TO TEST TO SEE IF THERE IS SOMEONE WRITING THIS FILE
;T3 HAS ATBSTS IN IT
; ENTER AT TSTWRS TO CHECK FOR NON-SIMULTANEOUS WRITERS.

TSTWRS::SKIPA	T3,[ATPUPD!ATPCRE!ATPSUP!ATPREN]
TSTWRT:	  MOVEI	T3,ATPMXU!ATPUPD!ATPCRE!ATPSUP!ATPREN
	HRRZ	T2,ATBFNB(P2)
	HLRZ	T2,FNBATB(T2)
TSTWRL:	TDNE	T3,ATBSTS(T2)
	  POPJ	P,
	HLRZ	T2,ATBLNK(T2)
	JUMPN	T2,TSTWRL
	JRST	CPOPJ1

GETCBR:	PUSH	P,T1
	MOVE	T1,JOB
	CAMN	T1,CBUSER	;MAKE SURE WE DO NOT ALREADY HAVE IT
	 STOPCD (SLO)		;YES WE DO      ;;GETCBR+3
	AOSE	CBREQ
	  PUSHJ	P,CBWAIT
	SETZM	CBSWT
	MOVEM	T1,CBUSER
	HRRZ	T1,-1(P)
	HRL	T1,F
	MOVEM	T1,CBADR
	PJRST	TPOPJ

GIVCB1:	AOS	(P)		;SKIP RETURN
GIVCBR:	PUSH	P,T1		;HE MUST BE THE ONE WHO HAS IT
	MOVE	T1,JOB
	CAME	T1,CBUSER
	 STOPCD (SLO)           ;;GIVCBR+3
	SOSL	CBREQ
	SETOM	CBAVAL
	SETZM	CBUSER
	PJRST	TPOPJ
;% SUBROUTINE TO GET FREE CORE BLOCK
; NON-SKIP RETURN, NONE AVAILABLE T2=0
; SKIP RETURN, BLOCK FOUND T2 IS POINTER
;% JOB MUST HAVE CB RESOURCE WHEN ROUTINE IS CALLED
;% T1 RESPECTED
;%GETCOR ZEROS T3, GETCRL T3 IS SOMETHING TO NOT GARBAGE COLLECT
;% EITHER A DRB OR AN FNB
GETCOR:	MOVEI	T3,0		;NOTHING TO SAVE
GETCRL:	PUSH	P,T1		;SAVE FOR A WORK REGISTER
GTCOR0:	HLRZ	T2,SYSCOR	;% 1ST FREE BLOCK ON LIST
	JUMPN	T2,GTCOR2	;% THERE IS FREE CORE IF NON-0
	HRRZ	T2,SYSDOR
	JUMPE	T2,CORGR4	;NO DORMANT ATB'S
	PUSH	P,P2
	PUSH	P,P3
	HRRZ	P2,T2
	HRRZ	P3,ATBFNB(P2)	;NEED TO GET IT OUT OF FNB LIST ALSO
	PUSHJ	P,RMVATB
	POP	P,P3
	POP	P,P2
	JRST	GTCOR0
	JRST	GTCOR3		;JUST GET THE BLOCK ZEROED OUT

CORGR4:	PUSH	P,P3		;ANOTHER REGISTER TO WORK IN
	HRRZ	P3,SYSDRB	;THE ONE TO SEARCH
	SKIPN	P3		;MAY BE NONE, SO...
	  HLRZ	P3,SYSDRB	;THE FIRST TIME THROUGH, USE FIRST IN SYSTEM
	JUMPE	P3,CORGR9	;THERE IS NO FREE CORE
	HRRM	P3,SYSDRB	;SAVE IT HERE IN CASE IT WAS 0
CORGR5:	HLRZ	T2,DRBFNB(P3)	;DOES DRB HAVE ANY FNB'S
	JUMPN	T2,CORGR6	;YES, SEE ABOUT ONE OF THEM
	MOVEI	T1,DRMCNT
	CAME	P3,T3		;DON'T TAKE SPECIAL ONE
	  TDNE	T1,DRBCNT(P3)
	  JRST	CORG5A		;THIS DRB IS IN USE, FORGET IT
	MOVEI	T1,DRPLOG!DRPLOK
	TDNE	T1,DRBSTS(P3)
	  JRST	CORG5A		;ALSO FORGET THAT ONE
	MOVEI	T1,SYSDRB-DRBLNK ;NOW NEED TO RECLAIM THIS DRB
CORG5B:	HLRZ	T2,DRBLNK(T1)
	CAMN	T2,P3		;FIND THE ONE WE CURRENTLY POINT TO
	  JRST	CORG5C		;FOUND IT
	SKIPN	T1,T2		;NOT THIS ONE, SET PREDECESSOR
	 STOPCD (SLO)		;END AND NOT FOUND, SOMETHING IS WRONG;;CORGB5+4
	JRST	CORG5B	;CONTINUE

CORG5C:	MOVE	T2,P3	;THIS IS THE ONE TO GRAB
	HLL	P3,DRBLNK(P3)	;THIS IS THE NEXT ONE
	HLLM	P3,DRBLNK(T1)	;RELINK
CORG5D:	HLRM	P3,SYSDRB	;LOOK HERE NEXT TIME
	POP	P,P3
	JRST	GTCOR3	;GO ZERO BLOCK
CORG5A:	HLRZ P3,DRBLNK(P3)	;NEED TO LOOK AT NEXT DRB
	SKIPN P3	;AT END?
	HLRZ P3,SYSDRB	;START OVER (MAY HAVE STARTED IN MIDDLE)
	HRRZ T2,SYSDRB	;THIS WAS WHERE WE STARTED
	CAME T2,P3
	JRST CORGR5	;MORE TO LOOK AT
CORGR9:	POP P,P3
	MOVEI T2,0
	JRST TPOPJ	;NONE FOUND, GIVE ERROR RETURN

;HERE TO LOOK AT FNBS ON A DRB

CORGR6:	HRLI P3,DRBFNB-FNBLNK(P3)	;REMEMBER PRED.. FNB
	PUSH P,T4	;ANOTHER REGISTER TO WORK IN
	MOVEI T4,0	;THIS IS THE FIRST FNB FOUND WITH NO ATBS BUT WITHOUT NX
CORG6B:	HLRZ T1,FNBATB(T2)
	JUMPN T1,CORG6A	;CAN NOT TAKE ONE WITH ATBS
	MOVSI T1,FNPLOK
	CAME T2,T3	;NOT SPECIAL ONE
	TDNE T1,FNBLOK(T2)	;CAN NOT TAKE IT IF LOCKED
	JRST CORG6A
	MOVSI T1,FNPNX
	TDNN T1,FNBNX(T2)	;JUST NX
	JRST CORG6C	;NO, WILL TAKE IF HAVE TO, BUT RATHER FIND AN NX
	HLRZ T4,P3	;GET PRED
CORG6D:	HLRZ T1,FNBLNK(T2)
	HRLM T1,FNBLNK(T4)	;LINK AROUND THIS ONE
	POP P,T4
	HLL P3,DRBLNK(P3)	;GET READY TO SET TO LOOK AT NEXT
	JRST CORG5D

CORG6C:	SKIPN T4	;HAVE WE ALREADY FOUND FNB NOT NX?
	HLR T4,P3	;NO, SAVE THE PRED TO THE ONE TO GRAB
CORG6A:	HRL P3,T2	;SAVE THIS AS PRED
	HLRZ T2,FNBLNK(T2)	;NEXT FNB
	JUMPN T2,CORG6B	;NOT OUT YET
	JUMPN T4,[HLRZ T2,FNBLNK(T4)	;GET THE ONE NO NX BUT GRABABLE
		JRST CORG6D]	;AND GO GRAB IT
	POP P,T4
	JRST CORG5A	;MUST GO TO NEXT DRB

GTCOR2:	MOVE T1,CMBLNK(T2)	;FOUND ONE IN CORE LIST, UNLINK
	HLLM T1,SYSCOR
GTCOR3:	SETZM (T2)	;ZERO OUT NEWLY FOUND BLOCK
	HRL T1,T2
	HRRI T1,1(T2)
	BLT T1,CMBSIZ-1(T2)
	JRST TPOPJ1	;TAKE GOOD RETURN

;SUBROUTINE TO CHECK ACCESS PRIVILIGES
;ENTER WITH T1=DESIRED FUNCTION
; F=DDB ADDRESS
; P2=ATB ADDRESS
;EXIT CPOPJ IF PRIVS DON'T1 ALLOW OPERATION
;EXIT CPOPJ1 IF OK, T1=FUNCTION

CHKPRV:	PUSH	P,J			;CHECK, MAY NOT HAVE STORED HIGHEST
	LDB	J,PJOBN
	HLRZ	T3,DEVEXT(F)
	CAIE	T3,'UFD'		;IS IT UFD??
	  JRST	CKNUFD			;NO
	MOVE	T3,DEVPPN(F)
	CAME	T3,MFDPPN
	  JRST	CKNUFD
	TLO	M,UUOUFD		;MARK AS A UFD
	LDB	T4,ATYPRV
	IOR	T4,[XWD 400000,700]	;SET ALL FOR OWN AND MARK UFD
	MOVE	T2,DEVFIL(F)		;UFD NAME
	PUSHJ	P,CHKPRJ		;CHECK FOR LICENSED JOB
	  JRST	CPOPK1			;IS SPECIAL
	PUSHJ	P,GETPTR		;NOT SPECIAL
	LDB	T2,T3
	CAIG	T1,FNCLOK		;WANT TO DO MORE THAN READ??
	  TRNN	T2,UFRXRD		;CAN WE READ
	 JRST	CPOPK			;NO TO ONE. CHG PROT CAUGHT IN CHKPRJ
	JRST	CPOPK1

CKNUFD:	MOVE	T2,DEVPPN(F)		;USE FILE PPN NOT NAME FOR CHECK
	LDB	T4,ATYPRV
	TRC	T4,700			;IF OWNER FIELD IS 7
	TRCN	T4,700
	TRZ	T4,100			;MAKE IT 6
	PUSHJ	P,CHKPRJ
	  JRST	CPOPK1
	PUSHJ 	P,GETPTR
	LDB	T4,DRYPRV
	IORI	T4,700			;CAN ALWAYS USE OWN
	LDB	T2,T3			;GET IT
	CAIE	T1,FNCCRE		;CREATE IS SPECIAL
	  JRST	CKNCRE
	TRNE	T2,UFRXCR
CPOPK1:	  AOS	-1(P)			;GOOD RETURN
CPOPK:	POP	P,J
	POPJ	P,			;ALL DONE

CKNCRE:	TRNN	T2,UFRXLK		;IS UFD TRANSPARENT??
	  JRST	CPOPK			;NO
	LDB	T4,ATYPRV		;GET BACK FILE PROT
	TRC	T4,700
	TRCN	T4,700
	  TRZ	T4,100
	LDB	T2,T3			;STILL HAVE POINTER IN T3
	MOVE	T2,TRNSTB(T2)		;TRANSLATE TO INTERNAL FORM
	CAMGE	T2,T1
	  JRST	CPOPK			;NO GOOD
	JRST	CPOPK1

TRNSTB:	EXP	FNCDEL,FNCCPR,FNCUPD,FNCAPP,FNCRED,FNCEXC,FNCLOK,0

;THIS SUBROUTINE CHECKS THE LICENSE BITS TO SEE IF A JOB
;HAS SPECIAL ACCESS TO A FILE. ENTER WITH
;T1=FUNCTION DESIRED
;T2=PPN OF FILE (NAME IF UFD)
;T4=PROTECTION BITS. BIT 0=1 IF UFD
;J=JOB NUMBER
;P2=ATB ADDRESS
;RETURNS CALL+1 IF OK
;RETURNS CALL+2 IF NOT OK
;CHECKS ALL CHANGE PROTECTION OPERATIONS

CHKPRJ::CAME	T2,ACTPPN	;IS IT FOR AN ACCOUNTING FILE??
	  JRST	CHKNAC		;NO
	MOVSI	T3,LICJAL
	TDNN	T3,JBTLIC(J)
	  JRST	CHKNAC		;JACCT NOT ON
	POPJ	P,		;YES, ALL OPS OK (KLUDGE)

CHKNAC:	CAILE	T1,FNCRED
	  JRST	CHKNRD		;NOT A READ
	LDB	T3,JBYRPT
	CAILE	T3,1		;CAN HE READ ALL FILES??
	  POPJ	P,
	CAIE	T3,1		;READ IN PROJ??
	  JRST	CHKHRF		;NO, CHECK HOME READ FILES
	MOVE	T3,JBTAUN(J)
	XOR	T3,T2
	TLNE	T3,-1
	  JRST	CHKWRT		;NOT IN PROJECT
	POPJ	P,

CHKHRF:	MOVE	T3,JBTLIC(J)	;GET CURRENT LICENSE
	TLNN	T3,LICHR	;CHECK HOME READ
	  JRST	CHKWRT		;NONE, CHECK WRITE ABILITIES (IMPLY READ)
	MOVE	T3,JBTFPN(J)	;YES, WHAT DIRECTORY RUN FROM?
	CAME	T3,T2		;DOES IT MATCH
	  JRST	CHKWRT		;NO, CHECK WRITE ABILITIES (IMPLY READ)
	POPJ	P,		;OK!

CHKWRT:	JUMPGE	T4,CHKWR1	;WRITE OF UFDS IS SPECIAL
	MOVE	T3,JBTLIC(J)
	TLNE	T3,LICJAL
	  POPJ	P,		;OK SINCE HAS JL
	CAIN	T1,FNCCPR	;IF RENAME(CH PROT)	;- UFD WPJ RENAME
	  JRST	CHKWR1		;SEE ABOUT WF,WPJ
	TLC    T3,LICWFL+LICWPJ	;WRITE ABSOLUTE
	TLCE   T3,LICWFL+LICWPJ	;SUPER USETO MAKE IT OK TOO
	  AOS	(P)
	POPJ	P,
CHKWR1:	LDB	T3,JBYWPT	;GET HIS WRITE LICENSES WFL, WPJ
	CAILE	T3,1
	  POPJ	P,		;HAS WF
	CAIE	T3,1
	  JRST	CHRMT		;TRY FOR A REMOTE BIT
	MOVE	T3,JBTAUN(J)
	XOR	T3,T2
	TLNE	T3,-1
	  JRST	CHRMT		;NOT FORM HERE, TRY REMOTE
	POPJ	P,		;ALL FUNCTIONS ARE OK

CHKNRD:	CAIE	T1,FNCCPR	;IS IT CHANGE PROTECTION??
	  JRST	CHKWRT		;NO
			;OWNER CAN ALWAYS CHANGE PROTECTION EXCEPT WHEN
			; FILE HAS PID - THEN NO ONE EXCEPT PROCESSOR CAN.
	SKIPN	T3,ATBPID(P2)	;THIS FILE HAVE A PID?
	  JRST	CHKNR1		;NO.
	CAME	T3,%UPT+UPTPID	;YES. PUNT IF DOESN'T MATCH REQUESTOR'S PID
	  JRST	CHKWRT		;TREAT HF PROGRAM JUST LIKE OWNER - ELSE
				; OWNER COULD WRITE HF PROG TO CHANGE PROTECTION
				; ON FILES WITH PIDS IN HIS AREA.
	MOVSI	T3,PIDACC	;ALSO PUNT IF JOB DIDN'T REQUEST PID ACCESS
	TDNN	T3,DEVIAD(F)	;SKIP IF ASKED FOR PID ACCESS
	  JRST	CHKWRT		;DID NOT.
CHKNR1:	MOVE	T3,JBTPPN(J)
	XOR	T3,T2
	TDNN	T3,[XWD INDPPN,-1]
	  POPJ	P,		;OK, BUT STORE NOTHING
	PUSHJ	P,RMTCHK	;IS IT A REMOTE PROGRAM
	  JRST	CHKWRT		;NO, CHECK WRITE
	POPJ	P,		;YES, TREAT LIKE OWNER

CHRMT:	PUSHJ	P,RMTCHK	;IS IT A REMOTE PROGRAM??
	  JRST	CHKPID		;NO, SEE IF THIS IS A PROCESSOR FOR FILE'S PID
	LDB	T3,[POINT 3,T4,29]	;GET OWNERS PROTECTION
	SKIPL	T4		;IS IT UFD??
	 SKIPA	T3,TRNSTB(T3)	;NO, TRANSLATE
	 MOVEI	T3,FNCRED	;YES, READ (PROTECTION CH. CAUGHT ABOVE)
	CAML	T3,T1
	  POPJ	P,		;YES, HE DID

;HERE TO SEE IF THIS IS THE PROCESSOR FOR FILE'S PID

CHKPID:	SKIPE	T3,ATBPID(P2)	;IF FILE DOES NOT HAVE A PID,
	CAME	T3,%UPT+UPTPID	;OR IF NOT THE PROCESSOR
	  JRST	CPOPJ1		;THEN NO ACCESS TO BE GIVEN.
	MOVSI	T3,PIDACC	;IS THE PROCESSOR, DID HE ASK FOR PID ACCESS?
	TDNN	T3,DEVIAD(F)	;SKIP IF HE DID.
	  AOS	(P)		;THEN NO ACCESS TO BE GIVEN.
	POPJ	P,		;ELSE ALL FUNCTIONS ARE OK.

;SUBROUTINE TO SET T3 AS A BYTE POINTER TO T4 DEPENDING ON
;WHETHER THIS IS OWNER, SAME PROJ, OTHER
;T2 HAS PPN OF FILE (OR UFD). CHANGES T2

GETPTR:	CAMN	T2,JBTAUN(J)
	  TDZA	T2,T2		;ALLOW ACCESS TO HOME DIR IF GFD'D
	 XOR	T2,JBTPPN(J)
	MOVE	T3,[POINT 3,T4,29]
	TDNN	T2,[XWD INDPPN,-1]	;OWNER??
	  POPJ	P,		;YES
	TLNE	T2,-1		;SAME PROJ??
	  IBP	T3		;NO 2 IBPS
	IBP	T3		;YES 1 IBP
	POPJ	P,

;CHECK TO SEE IF REMOTE BIT ON AND PROGRAM CAME FROM
;CORRECT FILE DIRECTORY. WORKS ONLY ON SHR SEG FOR NOW
;SKIP RETURN IF REMOTE SO TREAT AS OWNER

RMTCHK:	MOVSI	T3,LICRMT	;RMT == (Home File)
	TDNN	T3,JBTLIC(J)
	  POPJ	P,		;BIT NOT EVEN ON
	MOVE	T3,JBTFPN(J)	;WHERE HE CAME FROM
	CAMN	T3,T2		;SAME AS T2
	  AOS	(P)		;YES SKIP
	POPJ	P,

COMMENT ! ROUTINE CHKACC
PURPOSE: CHECK PROTECTION VS. DESIRED FUNCTION IN GET/RUN CODE.
FUNCTION: SKIP IF THE T1/FUNCTION IS ALLOWED ON THE FILE
EXPECTS: F/DDB  T1/FUNCTION J/JOB T2/DEVPPN(F)
	T4/PROT FIELD RETURNED BY LOOKUP ON THE FILE
DESTROYS: T2,T3
!

CHKACC:	PUSH	P,P2		;SAVE P2, AND SETUP ATB ADDRESS
	HRRZ	P2,DEVATB(F)
	PUSHJ	P,CHKPRJ	;SEE IF LICENSES ALLOW T1/FUNC
	JRST	[POP   P,P2	;YES, RESTORE P2 AND RETURN
		 JRST  CPOPJ1]
	POP	P,P2		;GET OLD P2 BACK.
	PUSHJ	P,GETPTR
	LDB	T2,T3
	MOVE	T2,TRNSTB(T2)
	CAMG	T1,T2
	  JRST	CPOPJ1
	POPJ	P,
SUBTTL ATB ADDRESS AND POINTER MANIPULATION

;ROUTINES TO HANDLE ATB POINTERS AND ADDRESSES
;ROUTINE TO CONVERT ATB POINTER TO ATB ADDRESS. CALLED WITH
; ATB POINTER IN T1

EXTERNAL CMBSIZ,CORBAS,DABSIZ,JBTDAB,DABOFS

XP DABBIT,10000		;THE THIRTEENTH BIT FLAGS A DUMMY POINTER
XP OFSATP,1		;OFFSET SO THAT NO ATB POINTER IS ZERO

CNVATP::SKIPN	T1		;MUST BE NON-ZERO, ELSE BAD POINTER
	 STOPCD (.,DISK,FILATB,,<Bad ATB pointer>) ;;CNVATP+1
	TRZE	T1,DABBIT	;IS THIS A DUMMY ATB POINTER
	 PJRST	JB1ATB		;YES, GO GET THE DUMMY ADDRESS
	SUBI	T1,OFSATP	;OFFSET BY SOME AMOUNT
	IMULI	T1,CMBSIZ	;GET OFFSET FROM START OF FILSER CORE
	ADD	T1,CORBAS	;GET ACTUAL ATB ADDRESS
	POPJ	P,		;AND RETURN WITH IT IN T1.

;ROUTINE TO RETURN JOB'S ATB ADDRESS IN T1

JOBATB::MOVE	T1,J		;GET JOB NUMBER IN T1
JB1ATB:	SUBI	T1,1		;NONE FOR JOB 0
	IMULI	T1,DABSIZ	;SIZE OF ONE DUMMY ATB
	ADDI	T1,JBTDAB-DABOFS ;ADD ADDRESS OF JOB TABLE, SUBTRACT
				; FUDGE FACTOR SO IT LOOKS LIKE REAL ADDRESS
	POPJ	P,		;RETURN WITH ADDRESS IN T1

;ROUTINE TO CONVERT A REAL ATB ADDRESS INTO ATB POINTER

INTERN CNVATB

CNVATB:	SUB	T1,CORBAS	;RELATIVE TO START
	IDIVI	T1,CMBSIZ	;MAKE CORE BLOCK NUMBER
	ADDI	T1,OFSATP	;MUST BE OFFSET FROM ZERO
	POPJ	P,		;RETURN.

;TO CONVERT DUMMY ATB ADDRESS TO POINTER, JUST
; DO MOVEI T1,DABBIT(J).
COMMENT ;@@SUBROUTINE DECRMV
@@PURPOSE MANIPULATE THE ATB/SPT/DRB DATA WHEN A PAGE IS BEING VREMOVED.
IF NECESSARY:
  DECREMENTS ATB UNSHARED MAP COUNT AND MAX WRITE COUNT (ATBUMC AND ATBMXW)
  GETS RID OF ATB, REMOVES SPT ENTRY FOR THE PAGE
@ENTRY P3,P4 CONTAIN LMAP SLOT DATA.  MUST BE INACTIVE.
  CALLER HAS THE SAT FOR THE SLOT'S DP LOCKED.  NOT NECESSARY FOR THIS
  ROUTINE, BUT NECESSARY FOR CALLER.
@ACCUM USES T1-T4, PRESERVES ALL OTHERS.
@@EXIT P3 AND P4 UNCHANGED.
  SKIP RETURN IF THIS IS THE LAST SLOT USING THE DP, OTHERWISE NON-SKIP.
@@CALLS SRCSPT, REMSPT, DECUMC, GETCBR,GIVCB?
@@FUNCTION IF LMAP SLOT IS ACTIVE OR SUPER, CRASH.
  GET THE ATB ADDRESS IN P2.
  DECREMENT MAX WRITE COUNT.  IF IT GOES TO ZERO, CLEAR ATPMXU IN ATBSTS.
  IF SLOT IS UNSHARED, SEARCH SPT FOR THE DP.  IF NOT IN THE SPT,
  DECREMENT ATBUMC (DECUMC) AND GIVE THE SKIP RETURN (LAST USER).
  IF IN THE SPT, DECREMENT THE USE COUNT. IF IT GOES TO ZERO,
  REMOVE THE SPT ENTRY AND GIVE THE SKIP RETURN.
  IF SPT COUNT STILL NON-ZERO, GIVE NON-SKIP RETURN.
@@;

EXTERNAL LMPACT,GETATB,LM3SPB,LM3SPO,SPTEN1,GETDPA,SPTUSC
EXTERNAL SPMUSC

DECRMV::JSP	T4,SAVE2	;! SAVE P1 AND P2
	TLNE	P3,LMPACT!LMPSUP ;! SLOT MUST BE INACTIVE, BECAUSE
				;! WE'RE DECREMENTING UMC OR SPTUSC
	 STOPCD (.,DISK,FILLAS,,<LMAP slot active/super>) ;;DECRMV+2
	PUSHJ	P,GETCBR	;! Get CB now so ATB won't disappear
	PUSHJ	P,GETATB	;%! GET ATB ADDRESS IN T1
	MOVE	P2,T1		;%! SAVE IT IN P2 FOR LATER
	TLZN	P3,LMPMXW	;%! MAX WRITE ON FOR THIS SLOT?
	 JRST	DECRM4		;%! NO, LEAVE ATB MWC ALONE.
	SOS	T2,ATBMWC(P2)	;%! YES, DECREMENT COUNT, ONE LESS WRITER
	TRC	T2,ATMMWC	;%! HAS IT OVERFLOWED?
	TRCN	T2,ATMMWC	;%! IF (ALL BITS GO TO 1) THEN CRASH
FILAMO:: STOPCD (.,DISK,FILAMO,PRTATB,<ATB Max write count overflow>) ;;DECRMV+13
	MOVEI	T3,ATPMXU	;%! GET READY TO CLEAR THE UP BIT
	TRNN	T2,ATMMWC	;%! IF COUNT WENT TO ZERO,
	ANDCAM	T3,ATBSTS(P2)	;%! CLEAR THE UP BIT IN ATBSTS
DECRM4:	JUMPGE	P3,DECRM1	;%! JUMP IF SLOT IS UNSHARED
	LDB	T1,LM3SPB	;%! SLOT SHARED, GET SPT TABLE BASE
	LDB	T2,LM3SPO	;%! AND OFFSET
	ADDI	T1,SPTEN1(T2)	;%! GET ADDRESS OF ENTRY
	LDB	T4,LM3SPT	;%! REMSPT NEEDS POINTER IN T4
	JRST	DECRM2		;%! AND GO DECREMENT SPT COUNT

DECRM1:	PUSHJ	P,GETDPA	;%! GET DP ADDRESS TO SEARCH SPT FOR
	PUSHJ	P,SRCSPT	;%! SEE IF ITS THERE
	  JRST	DECRM3		;%! NO, GO DECREMENT ATBUMC
DECRM2:	SOS	T2,SPTUSC(T1)	;%! ONE LESS USER,
	TRNE	T2,SPMUSC	;%! SKIP IF ITS THE LAST
	PJRST	GIVCBR		;%! NOT THE LAST, JUST RETURN
	PUSHJ	P,REMSPT	;%! LAST USER, DELETE ENTRY
	PJRST	GIVCB1		;%! AND TELL CALLER THIS WAS LAST.

DECRM3:	PUSHJ	P,DECUMC	;%! WASN'T IN SPT, UMC WAS UP FOR IT
	PJRST	GIVCB1		;%! SO DECREMENT AND RETURN.
SUBTTL SPT HANDLING ROUTINES

COMMENT ;@@SUBROUTINE INSSPT
@@PURPOSE CREATE AN SPT ENTRY. ONLY HAPPENS WHEN
A USER DOES A MAP AND FINDS THE "M" BIT IN THE SAT ON.
@@ENTRY T1/ATB ADDRESS
T2/ DISK PAGE ADDRESS (RBMASK OFF)
@@ACCUM PRESERVES T2, SMASHES T1,T3,T4.
@@EXIT T1/SPT ENTRY ADDRESS
T4/SPT ENTRY POINTER (BASE AND OFFSET)
NON-SKIP RETURN WHEN ENTRY IS INSERTEC SUCCESSFULLY.
@@CALLS GETWDS
@@RESTRICTIONS CALLER MUST BE SURE THAT AN SPT ENTRY DOES NOT
ALREADY EXIST FOR DP. UMC MUST BE INCREMENTED FOR DP DUE
TO OTHER USER OF DP. MAY RESCHEDULE TO GET FREE CORE.
@@FUNCTION TRY TO FIND AN SPT TABLE WITH A FREE ENTRY SLOT.
IF FIND ONE, STORE DISK ADDRESS IN SPT ENTRY, SET USE COUNT
TO 2 (ONE FOR THE CALLER, ONE FOR THE USER WHO CAUSED THE M
BIT TO BE SET). DECREMENT ATBUMC (CALL DECUMC) SO THAT
THE UNSHARED USER WILL NOT HAVE TO DECREMENT IT. RETURN
THE ENTRY ADDRESS AND POINTER, GIVE SKIP RETURN.
IF NO FREE SPT SLOTS, ALLOCATE A NEW SPT TABLE, INITIALIZE IT,
AND USE THE FIRST FREE SPT ENTRY IN IT. IF THIS NEW
SPT TABLE IS THE ONLY ONE LINKED TO THE ATB, LEAVE ATBUMC INCREMENTED,
SINCE MUST DECREMENT IT FOR THE ORIGINAL USER AND THEN INCREMENT
IT BECAUSE AN SPT CAME INTO EXISTENCE. ELSE, DECREMENT
ATBUMC WITH DECUMC. GIVE SKIP RETURN WITH ENTRY ADDRESS IN T1
AND POINTER IN T4. (ERROR RETURN IS GIVEN IF COULD NOT
CREATE ANOTHER SECTION OF SPT).
@@;

EXTERNAL ATBSPT,SPTLNK,SPYNFE,SPTEN1,SPTNME,SPTUSC,SPTPNO
EXTERNAL SPTNFE,SPTEN1,SPNBAS,SPTSIZ,GETWDS,SPTATB,SPTNMM
EXTERNAL SPNNFE,SPTBLN
EXTERNAL FCWAIT,FCREQ,RBMASK

INSSPT::TLNE	T2,RBMASK	;BAD BITS OFF?
	 STOPCD (SLO)		;NO     ;;INSSPT+1
	PUSHJ	P,GETCBR	;GET CB
	MOVEI	T4,ATBSPT-SPTLNK(T1) ;% GET FAKE PREDECESSOR ADDR.

INSSP1:	HLRZ	T4,SPTLNK(T4)	;% GET NEXT SPT SECTION ADDRESS
	JUMPE	T4,CRESPT	;% COULDN'T FIND FREE ENTRY, GO CREATE NEW SECTION
	LDB	T3,SPYNFE	;% GET NUMBER OF FREE ENTRIES IN THIS SECTION
	JUMPE	T3,INSSP1	;% NONE FREE, THEN LOOK AT NEXT SECTION

;FOUND A SECTION WITH A FREE ENTRY IN IT. DECREMENT ATBUMC BY
; CALLING DECUMC AND FIND THE FREE ENTRY

INSSP2:	PUSH	P,P2		;% SAVE P2
	MOVE	P2,T1		;% GET ATB ADDRESS INTO P2 FOR DECUMC
	PUSHJ	P,DECUMC	;% DECREMENT ATBUMC. ATB WILL NOT GO AWAY
				;%  BECAUSE UMC IS UP FOR THE SPT
	POP	P,P2		;% P2 COMES BACK

	MOVEI	T1,SPTEN1(T4)	;% GET ADDRESS OF FIRST ENTRY
	HRLI	T1,-SPTNME	;% HAVE TO LOOK AT ALL ENTRIES

INSSP3:	SKIPN	SPTUSC(T1)	;% IS THIS A FREE ONE?
	  JRST	INSSP4		;% YES, GO STUFF DATA INTO IT
	AOBJN	T1,INSSP3	;% NO, KEEP GOING
	 STOPCD (SLO)		;% BUT THE COUNT SAID THERE WAS A FREE ONE!

;HERE WHEN WE HAVE FOUND BOTH SECTION AND THE FREE ENTRY

INSSP4:	MOVEM	T2,SPTPNO(T1)	;% PUT IN THE DP
	MOVEI	T3,2		;% USE COUNT SET TO 2 ONE FOR US,
	MOVEM	T3,SPTUSC(T1)	;% AND ONE FOR ORIGINAL MAPPER.
	SOS	SPTNFE(T4)	;% ONE LESS FREE ENTRY IN HERE
	AOS	(P)		;% SKIP RETURN
	PUSHJ	P,GIVCBR	;GIVE BACK CB

;HERE ALSO FROM SRCSPT TO RETURN SPT ENTRY ADDR AND POINTER IN
; T1 AND T4, RESPECTIVELY, AND GIVE SKIP OR NON-SKIP RETURN

SPTRET:	HRRZS	T1		;GET RID OF -VE COUNT
	MOVEI	T3,SPTEN1(T4)	;GET ADDRESS OF FIRST ENTRY
	LSH	T4,^D35-SPNBAS	;POSTION SECTION ADDRESS PROPERLY
	SUBM	T1,T3		;GET OFFSET FROM FIRST ENTRY
	ADD	T4,T3		;T4 IS POINTER, HAS BASE AND OFFSET
	POPJ	P,		;RETURN TO CALLER.
;MORE OF INSSPT

;HERE WHEN ALL SPT SECTIONS ARE FULL. CREATE A NEW SPT
; SECTION. SPT SECTIONS COME FROM THE SAME FREE CORE
; THAT DDBS COME FROM, NOT FROM FILSER FREE CORE.

;T1 HAS ATB ADDRESS

CRESPT:	PUSH	P,T1		;SAVE ATB ADDRESS
	PUSH	P,T2		;AND CALLER'S DP ADDRESS
CRESP0:	MOVEI	T2,SPTSIZ	;HOW BIG AN SPT IS
	SKIPGE	FCREQ		;NEED TO WAIT? IF SO, SKIP AND WAIT
	PUSHJ	P,GETWDS	;GET THE CORE
	 JRST	[POP	P,T2
		POP	P,T1
		JRST	GIVCBR]
	POP	P,T2		;GET T2 BACK OFF STACK
	POP	P,T4		;GET ATB ADDRESS IN T4
	EXCH	T1,T4		;ATB IN T1, BASE OF SECTION IN T4

	HLRZ	T3,ATBSPT(T1)	;GET OLD FIRST SPT SECTION
	JUMPE	T3,CRESP1	;GO IF WE'RE CREATING FIRST ONE
				; LEAVE ATBUSC INCREMENTED TO REPRESENT
				; THE SPT'S EXISTENCE.
	PUSH	P,P2		;ALREADY AN SPT, DECREMENT
	MOVE	P2,T1		;ATB IN P2 FOR DECUMC
	PUSHJ	P,DECUMC	;DECREMENT THE COUNT THAT ORIGINAL
	MOVE	T1,P2		;GET ATB ADDRESS BACK IN T1
	HLRZ	T3,ATBSPT(T1)	;AND SPT OLD FIRST IN T3
	POP	P,P2		; MAPPER INCREMENTED IN ATB
CRESP1:	HRL	T3,T1		;T3/ ATB ADDR,,OLD FIRST SECTION
	MOVSM	T3,SPTLNK&SPTATB(T4) ;SET FORWARD LINK AND ATB BACK POINTER
	TRNE	T3,-1		;IF THERE IS AN OLD FIRST,
	HRLM	T4,SPTBLN(T3)	;IT SHOULD POINT BACK TO NEW FIRST.
	MOVSI	T3,ATBSPT-SPTLNK(T1) ;GET PHONEY BACK POINTER
	HRRI	T3,SPTNMM	;MAKE ALL ENTRIES FREE (SPTNME<B>SPNNFE)
	MOVEM	T3,SPTNFE&SPTBLN(T4)     ;SET NO. FREE ENTRIES AND BACK LINK
	HRLM	T4,ATBSPT(T1)	;AND FINALLY POINT THE ATB TO IT.

;NOW CLEAR THE ENTRIES

	HRLI	T3,SPTEN1(T4)	;FIRST ADDRESS
	HRRI	T3,SPTEN1+1(T4)	;1ST,,2ND
	SETZM	-1(T3)		;CLEAR 1ST (2ND-1)
	BLT	T3,SPTEN1+SPTNME*2-1(T4) ;ZERO ALL
	MOVEI	T1,SPTEN1(T4)	;GET ENTRY ADDRESS (BASE IS IN T4)
	JRST	INSSP4		;AND GO STICK DATA INTO ENTRY.
COMMENT ;@@SUBROUTINE REMSPT
@@PURPOSE DELETE AN SPT ENTRY
@@ENTRY T4 CONTAINS SPT POINTER (BASE AND OFFSET)
@@ACCUM PRESERVES T2, SMASHES T1,T3,T4.
@@EXIT ALWAYS NON-SKIP
@@CALLS DECUMC
@@RESTRICTIONS CALLER MUST HAVE CB
@@FUNCTION CLEAR USE COUNT WORD OF ENTRY, MAKING IT FREE.
INCREMENT COUNT OF FREE ENTRIES. IF ALL ENTRIES IN THIS
SPT SECTION ARE NOW FREE, SO UNLINK THIS SECTION AND GIVE
THE FREE CORE BACK.
@@;

EXTERNAL SP4BAS,SP4OFS,SPTEN1,SPTUSC,SPTVIR,SPTPNO
EXTERNAL SPMNFE,SPTBLN,SPTLNK,SPTATB,ATBSPT,SPTSIZ,GIVWDS

REMSPT::LDB	T1,SP4BAS	;% GET SECTION ADDRESS
	LDB	T3,SP4OFS	;% AND OFFSET
	MOVE	T4,T1		;% T4 HAS SECTION ADDRESS NOW
	ADDI	T1,SPTEN1(T3)	;% T1 GETS ADDRESS OF ENTRY

	SETZM	SPTUSC&SPTVIR(T1) ;% CLEAR OUT WHOLE COUNT WORD
	SETZM	SPTPNO(T1)	;% MAKE SURE DP IS ZERO FOR SRCSPT
	AOS	T3,SPTNFE(T4)	;% INCREMENT NUMBER OF FREE ENTRIES
	TRCN	T3,SPMNFE	;% IF FIELD WENT TO 0, WE HAVE AN OVERFLOW
	 STOPCD (.,DISK,FILSEO,,<SPT Free entry count overflow>);;REMSPT+10
	TRCE	T3,SPMNFE	;% OK. ALL BITS SET? (ZERO)
	  POPJ	P,		;% NO, STILL SOME ENTRIES HERE.

;HERE WHEN THE SPT SECTION IS NOW DEVOID OF ANY ENTRIES.

	HLRZ	T3,SPTBLN(T4)	;% GET PRED. ADDR (MAY POINT TO ATBSPT)
REMSP1:	HLL	T3,SPTLNK(T4)	;% T3/NEXT(MAYBE 0),,LAST(MAY BE ATBSPT)
	HLLM	T3,SPTLNK(T3)	;% PRED. FORWARD LINK TO NEXT
	MOVSS	T3		;% T3/LAST,,NEXT
	TRNE	T3,-1		;% IS THERE REALLY A NEXT?
	HLLM	T3,SPTBLN(T3)	;% YES, POINTS BACK TO LAST

;NOW SEE IF THIS WAS THE LAST SPT SECTION ON THE ATB. IF SO,
; MUST DECREMENT ATBUMC BECAUSE THERE IS NO MORE SPT.

	HRRZ	T1,SPTATB(T4)	;% GET ATB ADDRESS FROM OLD SECTION
	HLRZ	T3,ATBSPT(T1)	;% ALL THE SPT SECTIONS GONE?
	JUMPN	T3,REMSP2	;% JUMP IF NOT
	PUSH	P,P2		;% ALL GONE, CAL DECUMC
	MOVE	P2,T1		;% IT WANTS ATB IN P2
	PUSHJ	P,DECUMC	;% MAYBE ATB WILL GO AWAY.
	POP	P,P2		;% BURMA SHAVE

REMSP2:	PUSH	P,T2		;% SAVE T2 FROM GIVWDS, WHICH DESTOROYS EVERYTHINK
	MOVEI	T1,SPTSIZ	;% NUMBER OF WORDS TO GIVE BACK
	MOVE	T2,T4		;% GET ADDRESS IN T2
	PUSHJ	P,GIVWDS	;% GIVE BACK CORE
	POP	P,T2		;% RESTORE PRECIOUS DISK ADDRESS
	POPJ	P,		;% AND RETURN.
COMMENT ;@@SUBROUTINE SRCSPT
@@PURPOSE SEE IF A DP HAS AN SPT ENTRY.
@@ENTRY T1/ATB ADDRESS
T2/ DP ADDRESS TO SEARCH FOR (RBMASK OFF)
@@ACCUM PRESERVES T2, USES T1,T3,T4.
@@EXIT NON-SKIP IF DP IS NOT IN SPT. SKIP RETURN IF DP IS IN SPT,
WITH T1 CONTAINING ENTRY ADDRESS AND T4 CONTAINING ENTRY POINTER.
@@FUNCTION SEARCH EACH SPT SECTION FOR AN ENTRY THAT HAS
A MATCHING DISK ADDRESS. DON'T FORGET THAT SPTS ARE SPARSE.
SEARCH ASSUMES THAT SEARCH WILL FAIL WITHIN MOST SPT
SECTIONS, SO THAT WE WILL HAVE TO LOOK AT SPTNME WORDS
AT LEAST, MOST OF THE TIME. ASSUME TABLE ENTRIES ARE NOT
GROUPED TOGETHER, BUT ARE SEPERATED, SO THAT IT WOULD
NOT HELP BY CUTTING OFF SEARCH AFTER WE HAVE FOUND
<NUMBER OF ENTRIES> VALID ENTRIES.
@@;

EXTERNAL ATBSPT,SPTLNK,SPYNFE,SPTEN1,SPTPNO,RBMASK

SRCSPT::TLNE	T2,RBMASK	;BAD BITS OFF?
	 STOPCD (SLO)		;NO     ;;SRCSPT+1
	MOVEI	T4,ATBSPT-SPTLNK(T1) ;START OFF WITH THIS THING
SRCSPA:	HLRZ	T4,SPTLNK(T4)	;GET NEXT SECTION ADDRESS
	JUMPE	T4,CPOPJ	;NOT IN SPT.
	MOVSI	T1,-SPTNME	;SEARCH WHOLE TABLE, ASSUMING ITS
				; USUALLY BEEN FILLED, MAYBE MADE SPARSE
	HRRI	T1,SPTEN1(T4)	;GET FIRST ENTRY ADDRESS
SRCSP2:	CAMN	T2,SPTPNO(T1)	;ONE WE'RE LOOKING FOR?
	JRST	SRCSP4		;GO MAKE SURE ITS A REAL ENTRY
SRCSP3:	AOBJN	T1,SRCSP2	;NO, LOOK SOME MORE.
	JRST	SRCSPA		;NOT IN THIS SECTION, CHECK NEXT SECTION

;HERE WHEN DISK ADDRESS AND SPT ENTRY DISK ADDRESS MATCH.
; IF THE PAGE IS PAGE 0, MAKE SURE USE COUNT IS
; NON-ZERO (A REAL ENTRY)

SRCSP4:	JUMPN	T2,SRCSP5	;NON-ZERO, ITS REAL
	SKIPN	SPTUSC(T1)	;IS THE ENTRY REAL?
	JRST	SRCSP3		;NO, KEEP LOOKING
SRCSP5:	AOS	(P)		;GIVE SKIP RETURN, WE FOUND IT.
	PJRST	SPTRET		;YES, RETURN WITH IT.
SUBTTL UNSHARED MAP COUNT HANDLING

COMMENT ;@@SUBROUTINE INCUMC
@@PURPOSE INCREMENT ATBUMC, AND IF IT WAS ZERO INCREMENT
DRBCNT.
@@ENTRY T1/ATB ADDRESS
@@ACCUM PRESERVES T1,T2,T4 SMASHES T3
@@EXIT NON-SKIP RETURN.
@@FUNCTION INCREMENT ATBUMC, CRASH IF OVERFLOW. IF
ATBUMC WENT FROM 0 TO 1 AND ATB IS FOR A FILE,
INCREMENT DRBCNT. RETURN.
@@;

EXTERNAL ATPUMC,ATBUMC,ATMUMC,ATBFNB,FNBDRB,DRBCNT,DRPMXC
EXTERNAL ATBDUM

INCUMC::MOVSI	T3,ATPUMC	;GET COUNT BIT
	ADDB	T3,ATBUMC&ATBDUM(T1);INCREMENT UMC
	PUSH	P,P2
	MOVE	P2,T1		;For PRTATB
	TLNN	T3,ATMUMC	;IF ALL WENT TO 0, ITS AN OVERFLOW
	 STOPCD (.,DISK,FILAUO,PRTATB,<ATB Unshared map count overflow>) ;;INCUMC+3
	POP	P,P2
	TLNE	T3,ATPDUM!ATMUMC-1 ;COUNT NOW = 1 AND FILE ATB?
	 POPJ	P,		;NO, JUST RETURN
	HRRZ	T3,ATBFNB(T1)	;YES, GET DRB ADDRESS
	HRRZ	T3,FNBDRB(T3)
	AOS	T3,DRBCNT(T3)	;INCREMENT DRB COUNT
	TRNE	T3,DRPMXC	;OVERFLOW?
	 STOPCD (,XCT,FILDMO)   ;;INCUMC+12
	POPJ	P,		;NO, RETURN.
COMMENT ;@@SUBROUTINE DECUMC
@@PURPOSE DECREMENT ATBUMC WHEN AN SPT IS DESTROYED,
WHEN SPT ENTRY IS CREATED AND SPT ALREADY EXISTED, OR
WHEN A PAGE IS REMOVED THAT IS NOT IN AN ATB'S SPT.
@@ENTRY P2/ ATB ADDRESS
CALLER GOT CB RESOURCE. CALLER ALSO HAS SAT FOR THE DP
HE IS REMOVING LOCKED, ALTHOUGHT THIS IS NOT NECESSARY
FOR DECUMC.
@@ACCUM USES T1,T3. PRESERVES T2,T4.
@@EXIT ATB ADDRESS STILL IN P2
STILL HAVE CB
@@CALLS FREATB OR LKDATB
@@FUNCTION DECREMENT ATBUMC, CRASH IF IT UNDERFLOWS.
IF ATB IS A DUMMY ATB OR COUNT IS NOT ZERO, RETURN.
OTHERWISE DECREMENT DRB COUNT, CRASH IF UNDERFLOW.
IF ATB IS MARKED FOR DELETION AND THERE ARE NO MORE
USERS OF ATB, GIVE IT BACK TO FREE CORE. ELSE IF NO
MORE USERS OF ATB, PUT ATB ON DORMANT LIST.
@@;

DECUMC::MOVSI	T1,-ATPUMC	;%! GET DECREMENTING VALUE
	ADDB	T1,ATBUMC&ATBSTS&ATBDUM(P2)
				;%! (WILL USE THIS AS ATBSTS LATER,
				;%! SO GET ATBSTS INTO CREF)
				;%! DECREMENT THE COUNT
	TLC	T1,ATMUMC	;%! SEE IF ALL BITS WENT TO 1
	TLCN	T1,ATMUMC	;%! IF YES, UNDERFLOW
	 STOPCD (.,DISK,FILAUU,PRTATB,<ATB Unshared map count underflow>);;DECUMC+4
	HLRZ	T3,ATBSPT(P2)	;%! GET POSSIBLE SPT SECTION ADDRESS
	JUMPE	T3,DECUM0	;%! IF NONE, OK
	TLNN	T1,ATMUMC	;%! IF STILL AN SPT AND COUNT IS 0, CRASH.
	 STOPCD (.,DISK,FILAUS,PRTATB,<ATB Unshared map count zero with SPT>);;DECUMC+10
DECUM0:	TLNE	T1,ATPDUM!ATMUMC ;%! IF THIS IS DUMMY ATB OR COUNT STILL UP
	 POPJ	P,		;%! JUST RETURN.
	HRRZ	T3,ATBFNB(P2)	;%! GET DRB ADDRESS
	HRRZ	T3,FNBDRB(T3)	;%! HAVE IT NOW
	SOS	T3,DRBCNT(T3)	;%! DECREMENT IT, SINCE UMC WENT TO ZERO
	TRNE	T3,DRPMXC	;%! UNDERFLOW?
	 STOPCD (,XCT,FILDMU)	;%! YES, CRASH  ;;DECUM0+6
	TRNE	T1,ATPMXU!ATMCNT!ATPUPD!ATPREN!ATPSUP!ATPCRE
				;%! ANY USERS OF ATB LEFT?
	  POPJ	P,		;%! YES, DON'T TOUCH ATB
	PUSH	P,T2		;%! SAVE T2 AND P3
	PUSH	P,P3		;%! AS WE SAY WE PRESERVE THEM
	HRRZ	P3,ATBFNB(P2)	;%! P3 GETS FNB ADDR IN CASE CALL FREATB
	MOVEI	T2,LKDATB	;%! ASSUME IT GOES ON DORMANT LIST
	TRNE	T1,ATPDEL	;%! MARKED FOR DELETION?
	  MOVEI	T2,FREATB	;YES, GOES BACK TO FREE CORE
	PUSHJ	P,(T2)		;%! PUT ON DORMANT OR FREE LIST
	POP	P,P3		;%! RESTORE THESE AND
	POP	P,T2		;%!
	POPJ	P,		;%! RETURN.
COMMENT ;@@SUBROUTINE DECUNS
@@PURPOSE TO DECREMENT ATBUMC,MXW, AND REMOVE SPT ENTRY FOR AN
UNSHARED DP SO THAT IT CAN BE MOVED TO ANOTHER FILE.
@@ENTRY P3,P4 CONTAIN LMAP SLOT DATA, ACTIVE OR INACTIVE.
T2/ DP
P2/ ATB OF OLD FILE (OR DUMMY ATB ADDRESS IF PRIVATE PAGE)
@@ACCUM USES T1-T4.
@@EXIT P3,P4 STILL CONTAINLMAP SLOT DATA - STATUS SET TO UNSHARED IF
ENTERED AS SHARED. LMYATB NO LONGER VALID.
SKIP IF PAGE WAS NOT BEING SHARED BY ANYONE. NON-SKIP IF PAGE WAS BEING
SHARED.
@@FUNCTION IF SLOT IS UNSHARED, SEARCH SPT FOR DP. IF DP IS IN SPT OR SLOT
IS SHARED, AND SPT SHARE COUNT IS NOT 1, GIVE NON-SKIP RETURN (MUST BE
GREATER THAN 1). ELSE DELETE SPT ENTRY (CALL REMSPT).
IF DP IS NOT IN SPT, DECREMENT ATBUMC.
DECREMENT ATBMXW IF MAX WRITE IS ON FOR SLOT.
(NOTE %=CB, !=SAT)
@@;
EXTERNAL ATBSTS,ATPMXU,ATMMWC,ATBMWC
EXTERNAL LMPMXW,LMPSHR,GETSPT


DECUNS::PUSHJ	P,GETCBR	;! GET CB WHILE MESSING WITH ATB AND SPT
	JUMPGE	P3,DECUN1	;%! IF SHARED, DON'T HAVE TO CHECK FOR SPT
				;%! EVEN IF ITS ACTIVE UNSHARED CAN'T GUARANTEE
				;%!  THAT IT DOESN'T HAVE AN SPT ENTRY,
				;%!  ACTLMA DOESN'T CHECK - ONLY PAGE FAULT.
	PUSHJ	P,GETSPT	;%! GET SPT ENTRY ADDRESS IN T1 FOR SHARED SLOT.
	JRST	DECUN2		;%! AND GO SEE IF ANYONE ELSE IS REALLY USING IT.
DECUN1:	MOVE	T1,P2		;%! GET ATB ADDRESS IN T1 FOR SRCSPT
	PUSHJ	P,SRCSPT	;%! SEE IF IT HAS AN SPT ENTRY
	  JRST	DECUN3		;%! NO SPT ENTRY, JUST DECREMENT COUNTS
DECUN2:	MOVE	T3,SPTUSC(T1)	;%! GET USE COUNT
	TRNE	T3,SPMUSC-1	;%! EQUAL TO 1? (CAN'T BE ZERO)
	PJRST	GIVCBR		;%! NO, JUST GIVE BACK CB AND GIVE NON SKIP RETURN.
	PUSHJ	P,REMSPT	;%! YES, GET RID OF ENTRY (MAYBE WHOLE SPT TABLE)
	TLNE	P3,LMPMXW	;%! MAX WRITABLE ON FOR THIS SLOT?
	PUSHJ	P,DECMXW	;%! YES, DECREMENT MAX WRITE COUNT
	TLZ	P3,LMPSHR	;%! SLOT NO LONGER SHARED (IF WAS AND WAS INACTIVE,
				;%!  LMYSPT IS NOW GARBAGE.
	JRST	GIVCB1		;%! GIVE SKIP RETURN.

DECUN3:	TLNE	P3,LMPMXW	;%! MAX WRITE ON?
	PUSHJ	P,DECMXW	;%! YES, DECREMENT MAX WRITE COUNT
	PUSHJ	P,DECUMC	;%! WASN'T IN SPT, DECREMENT ATBUMC, DRBCNT
				;%! ETC.
	PJRST	GIVCB1		;%! AND RETURN.

DECMXW:	SOS	T3,ATBMWC(P2)	;%! YES, DECREMENT IT
	TRC	T3,ATMMWC	;%! HAS IT OVERFLOWED?
	TRCN	T3,ATMMWC	;%!  (ALL BITS GO TO 1)
	 STOPCD (,XCT,FILAMO);;;%! YES, CRASH   ;;DECMXW+3
	MOVEI	T4,ATPMXU	;%! GET READY TO CLEAR MAX WRITE UP BIT
	TRNN	T3,ATMMWC	;%! COUNT STILL NON-ZERO?
	ANDCAM	T4,ATBSTS(P2)	;%! NOT ANYMORE, CLEAR THE BIT.
	POPJ	P,		;%! RETURN.

;PRTATB - Print ATB that P2 points to for STOPCD typeout
;Modifies F and T1-T4

PRTATB::PUSHJ	P,INLMES##
	 ASCIZ	/ATB: /
	SKIPGE	ATBDUM(P2)	;Dummy ATB?
	 JRST	PRTAT1		;Yes
	HRRZ	F,ATBFNB(P2)	;Point to FNB
	HRRZ	F,FNBDBL(F)	;Get first open DDB for this file
	PJRST	PRTDDB##	;Print DEV:FILE.EXT[P,Pn]

PRTAT1:	MOVEI	T1,DABOFS-JBTDAB(P2)
	IDIVI	T1,DABSIZ	;Determine how far into JBTDAB it is
	MOVEI	J,1(T1)		;Job number
	PUSHJ	P,INLMES##
	 ASCIZ	/Private pages for frame /
	PJRST	PJOB##		;Output job number and CRLF

	$END	(FND)		;End of FILFND (FNDLIT: FNDEND:)
      y;'#h