; This file is LDBSER.MAC - routines called from interrupt and UUO level

SUBTTL	CTYLDB - Line Data Block definition for the CTY

CTYLDB:: LDBDEF		;Define LDB for the CTY
LDBLEN==:.-CTYLDB

;Pointers for "output needed" bits

DEFINE ZZZ(NAME), <
	LOP'NAME:POINT 1,LDBOUT(U),ZZN
	ZZN==ZZN+1>

ZZN==0
	OUTBIT
IFE <ZZN-36>,<	PRINTX ?MORE THAN 36 OUTPUT BITS
		QQQQQQ> ;Force error (undefined symbol)

BPOKBN==LOPBPF-LOPHSH	;BIT# OF LOWEST-PRIORITY MESSAGE
			;THAT CAN BE SENT ON A BACKPRESSURED PORT
NUMECO==LOPECO-LOPHSH	;BIT # OF ECHO
LAPBIT==LOPSOG-LOPHSH   ;LAST LEGAL PRIORITY BIT


;TTY DDB INTERRUPT-TO-CHANNEL BYTE POINTERS

ZZWORD==0
ZZBIT==-1
DEFINE ZZZ(N),<IFG <ZZBIT+6>-^D35,<ZZBIT==-1
		ZZWORD==ZZWORD+1>
	ZZBIT==ZZBIT+6
DDPT'N:	POINT 6,DDBTRP+ZZWORD(F),ZZBIT>

DDPTAB:		;These definitions need to be before the DDB definition

ZZZ(SC)	;ESCAPE/^C RECEIVED
ZZZ(CH)	;CHARACTER RECEIVED
ZZZ(LN)	;BREAK RECEIVED
ZZZ(TI)	;I/O WAIT
ZZZ(TS)	;I/O WAIT SATISFIED
ZZZ(LC)	;LOST CHARACTERS
ZZZ(OB)	;ORANGE BALL RECEIVED
ZZZ(ZP)	;ZAPPER RECEIVED
ZZZ(PS)	;PORT STATUS MESSAGE RECEIVED   (See comment at ACPSM)
ZZZ(YB)	;YELLOW BALL RECEIVED
ZZZ(CG)	;CHARACTER GOBBLER RECEIVED
ZZZ(TC)	;TERMINAL CHARACTERISTIC CHANGED AT OTHER END OF PTY

TRPLEN==.-DDPTAB

;TRAP NUMBER INTERNALS

TTNESC==:DDPTSC-DDPTAB
TTNCHR==:DDPTCH-DDPTAB
TTNLIN==:DDPTLN-DDPTAB
TTNYLB==:DDPTOB-DDPTAB

SUBTTL CHUNK HANDLERS

;SUBROUTINE TO READ A CHARACTER FROM A TELETYPE BUFFER
;CALL WITH T2 CONTAINING A BYTE POINTER TO THE LIST
;THIS ROUTINE WILL IBP T2 WHICH MAY POINT IT INTO A LINK WORD
;ALSO WE MAY BE CALLED WITH THE POINTER DECREMENTED SO THAT
;IBP WILL POINT TO THE CURRENT CHUNKS LINK WORD
;THIS ROUTINE WILL CORRECTLY FOLLOW THE LINKS. THE ROUTINE
;WILL NORMALLY SKIP RETURN. THE NON-SKIP RETURN IS TAKEN IF
;IT WAS NECESSARY TO FOLLOW A LINK. IN THIS CASE, T1
;CONTAINS THE BASE ADDRESS OF THE NEW CHUNK.
;ON RETURN, T2 CONAINS THE BYTE POINTER TO THE CHARACTER
;JUST OBTAINED, AND T3 THE CHARACTER

TTGETC:	ILDB	T3,T2		;IF WE GET INTO A LINK WORD, T3 WILL NOT
				;BE WHAT WE WANT BUT NOTHING WILL HAVE
				;BEEN CLOBBERED
	TRNE	T2,3		;ALL LINK WORDS ARE IN WORDS AT AN ADDRESS
				;WHICH IS A MULTIPLE OF 4
	 JRST	CPOPJ1		;ALL OK, JUST RETURN
	HRRZ	T1,-4(T2)	;THIS WILL BE THE FORWARD LINK TO NEXT CHUNK
	TLNN	T2,770000	;IF WE ARE AT THE RIGHT END OF THE WORD
				;WE MUST HAVE BACKED UP
	 HLRZ	T1,(T2)		;SO GET BACK LINK (T2 POINTS TO FIRST WORD OF CHUNK)
	JUMPE	T1,TTGC1	;NO LINK THERE
	CAML	T1,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T1,RCC.HI	; to the TTY chunks
	 STOPCD (,XCT,RCCDBG)	;Forward/back pointer is bad
	HRR	T2,T1		;NOW POINT TO CORRECT WORD
	TLNE	T2,770000
	 AOSA	T2		;IF FORWARD, POINT TO FIRST CHR
	ADDI	T2,TTCHKS-1	;IF BACKWARD, TO LAST
	LDB	T3,T2		;NOW GET THE CHARACTER
	POPJ	P,		;AND RETURN SAYING PASSED A LINK

;Stop at TTYNNC may be related to ZAP (or nonzap) at LDEC

TTGC1:	TLNE	T2,770000	;IS THIS A BACKUP
	 STOPCD (TSETBI,INFO,TTYNNC,,<TTY - No Next Chunk>) ;;TTGC1+1
	MOVEI	T3,0		;GIVE BACK 0
	JRST	CPOPJ1
SUBTTL	SUBROUTINE TO PLACE A CHARACTER IN A BUFFER.
;CHARACTER IS IN T3. T2 CONTAINS A BYTE POINTER TO LAST
;CHARACTER PLACED IN BUFFER. WE WANT TO DO AN IDPB T3,T2 BUT
;MUST WATCH FOR LINKS. WILL FOLLOW A FORWARD LIST IF IT
;EXISTS OR GET A NEW CHUNK IF NECESSARY

TTPUTC:	IBP	T2		;MUST NOT IDPB SINCE MIGHT CLOBBER SOMETHING
	TRNE	T2,3		;ARE WE IN A LINK?
	 JRST	TTPC1		;NO, ALL OK
	HRRZ	T1,-4(T2)	;GET LINK
	TLNN	T2,770000
	 STOPCD			;SOMEONE CALLED US AFTER BACKING UP
	JUMPN	T1,TTPC2	;HAVE A FORWARD LINK ALREADY
	MOVE	T1,TTFREE##	;GET A NEW CHUNK
	CAML	T1,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T1,RCC.HI	; to the TTY chunks
	 STOPCD (.,STOP,RCCSTP,,<Range Checked Chunk - TTFREE is bad, stop>)
	PUSH	P,P1		;GET A REGISTER TO WORK WITH
	HRRZ	P1,(T1)		;Current points to new first free chunk
	SKIPE	P1		;Zero if T1 points to very last chunk on system
	 CAML	P1,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	P1,RCC.HI	; to the TTY chunks
	 STOPCD (,XCT,RCCSTP)	;Die - TTFREE is bad
	MOVEM	P1,TTFREE##	;UPDATE FREE POINTER
	SKIPE	P1
	 HRRZS	(P1)		;MAKE SURE NO BACK LINE IF A CHUNK LEFT
	SOS	TTFREN		;COUNT CHUNK TAKEN
	HRLZI	P1,-4(T2)	;GET A BACK LINK
	MOVEM	P1,(T1)		;TO PUT IN NEW CHUNK
	HRRM	T1,-4(T2)	;AND PUT IN FORWARD LINK
	POP	P,P1
TTPC2:	HRRI	T2,1(T1)	;NOW RESET BYTE POINTER
TTPC1:	DPB	T3,T2		;STORE AWAY CHARACTER
	POPJ	P,		;ALL DONE
SUBTTL	ROUTINE TO FREE UP A CHUNK OF THE CHARACTER LIST BY LINKING IT
;ONTO THE FRONT OF THE FREE-LIST. ASSUMES THAT TTGETC HAS JUST BEEN
;CALLED SO T1 CONTAINS THE ADDRESS OF THE CHUNK AFTER THE ONE
;TO RETURN TO THE FREE LIST.
;T1 has already been verified to be between RCC.LO and RCC.HI by TTGETC

FRECHK:	PUSH	P,T2
	HLRZ	T2,(T1)		;RETRIEVE THE LINK TO THE ONE TO PUT BACK
	HRRZS	(T1)		;NO BACK LINK IN THIS CHUNK NOW
	EXCH	T2,TTFREE##	;PUT OLD ON FREE LIST
	HRRZM	T2,@TTFREE##	;RELINK REST OF FREE LIST AFTER THIS ONE
	AOS	TTFREN
	POP	P,T2
	POPJ	P,

;ROUTINE TO GET A FREE CHUNK FROM THE FREELIST. SETS UP
;A BYTE POINTER IN T2. CLOBBERS T1

GETCHK:	MOVE	T2,TTFREE##	;This should have been checked for 0 earlier
	CAML	T2,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T2,RCC.HI	; to the TTY chunks
	 STOPCD (,XCT,RCCSTP)	;Die - TTFREE is bad (or all chunks in use)
	HRRZ	T1,(T2)		;THE NEXT ELEMENT
	MOVEM	T1,TTFREE##	;RESET FREE LIST
;P035/D08 when getting first chunk on list, make sure second chunk does
; not have a back pointer to the first chunk.  /JMS 12-Jul-88
	SKIPE	T1		;As long as free list is not empty,
	 HRRZS	(T1)		; make sure it doesn't point to this one
	SETZM	(T2)		;NO LINKS IN THIS NEW ONE
	HRLI	T2,(POINT 9,0,35) ;POINT SO THAT IBP POINT TO 1ST CHR
	SOS	TTFREN		;ONE LESS
	POPJ	P,
SUBTTL	TSETBI - CLEAR INPUT BUFFER

TSETBI::	;P035/D08 - commented out code to special case zapped lines
;*;	MOVSI	T1,LLLZAP
;*;	TDNE	T1,LDBLOG(U)	;DO NOT ZAP IF TRYING TO GET RID OF HIM
;*;	 POPJ	P,
	SKIPE	T2,LDBTIP(U)	;CLEAR THIS LIST
	 PUSHJ	P,FREUP		;BUT ONLY IF ONE IS THERE
	SKIPE	T2,LDBRBI(U)	;AND THIS ONE TOO
	 PUSHJ	P,FREUP
	SETZM	LDBTIP(U)
	SETZM	LDBTIT(U)
	SETZM	LDBTIC(U)
	SETZM	LDBBKC(U)
	SETZM	LDBBK2(U)
	SETZM	LDBBKI(U)
	SETZM	LDBBKP(U)
	SETZM	LDBECT(U)
	SETZM	LDBECC(U)
	SETZM	LDBRBC(U)
	SETZM	LDBRBO(U)
	SETZM	LDBRBI(U)
	MOVSI	T2,LDLECS
	ANDCAM	T2,LDBDCH(U)	;MUST CLEAR COMMAND SYNC BIT
	HLL	U,LDBDCH(U)	;LET PEOPLE KNOW ABOUT IT
	MOVSI	T2,L2LDEL!L2LCCS
	ANDCAM	T2,LDBBYT(U)
	PJRST	BPXOFF		;GET OUT OF BACKPRESSURE OR XOFF

;TSETBO - CLEAR OUTPUT BUFFER

TSETBO:	SKIPE	T2,LDBTOP(U)
	 PUSHJ	P,FREUP
TSTBO1:	SETZM	LDBTOP(U)	;OUTPUT PUTTER
	SETZM	LDBTOC(U)	;OUTPUT COUNT
	SETZM	LDBTOT(U)	;OUTPUT TAKER
	SETZM	LDBFLP(U)	;AND FILLERS CURRENTLY GOING
	HRRZ	T1,U
	CAMN	T1,OPRLDB	;IS THIS OPR
	 PUSHJ	P,OPRFRE	;YES, MAY NEED TO RESTART JOBS
	MOVEI	T2,1
	MOVSI	T1,L2LOWT
	TDNN	T1,LDBBYT(U)	;IF WE'RE WAITING FOR AN ORANGE BALL,
	 JRST	TSTBO2
	ANDCAM	T1,LDBBYT(U)	;  STOP WAITING
	DPB	T2,LOPSYL	;  SEND YELLOW BALL
TSTBO2:	DPB	T2,LOPCGB	;SEND GOBBLER
	MOVSI	T1,LDLNOP	;SEND EVEN IF SAYS SHOULD NOT
	ANDCAM	T1,LDBDCH(U)
	DPB	T2,LDBOPB(U)
	POPJ	P,
SUBTTL	THIS ROUTINE TRACES BACKWARDS DOWN A LINKED LIST TO THE START
;AND THEN ADDS THE WHOLE LIST TO THE FREE LIST.
;Called from GORUB/PGRUB after outputing rubout characters.
;Called from TSETBI/TSETBO to clear input/output buffers.

FREUP:	ANDI	T2,777774	;GET BASE ADDRESS
FREST:	CAML	T2,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T2,RCC.HI	; to the TTY chunks
	 STOPCD (RCC.T3,INFO,RCCDBG,,<Range Checked Chunk, continuing>)
	HLRZ	T1,(T2)		;LOOK FOR BACK LINKS
	JUMPE	T1,STLST	;FOUND START
	MOVE	T2,T1		;TRY SOME MORE
	JRST	FREST

;JMS 7-May-86 - X95(KS) has a nasty habit of looping here.  Added TTYFLM.

STLST:	SKIPE	T1,TTFREE##	;Pointer to current free list (0 is OK)
	 CAML	T1,RCC.LO	;Check if this is a reasonable pointer
	CAMLE	T1,RCC.HI	; to the TTY chunks
	 SETZB	T1,TTFREE##	;Was bad, start with a new free list
	EXCH	T1,(T2)		;Make current chunk point to the old free list
	HRRZM	T2,TTFREE##	;Put current chunk at start of free list
	AOS	TTFREN		;Mark one more free
	TRNE	T1,777777	;If there is a next pointer,
	 HLRZ	T2,(T1)		; get its back pointer
	TLZ	T2,777777	;Clear LH for compare
	CAME	T2,TTFREE##	;Does next point back to current?
	 STOPCD (RCC.T3,INFO,TTYFLM,,<TTY Free List Messed Up>) ;;STLST+7
	HRRZ	T2,T1		;Did current chunk have a next one?
	JUMPN	T2,STLST	;Yes, continue until all are freed up
	POPJ	P,		;All done

;Resume address from RCC stopcodes - Set T1,T2,T3 to reasonable values
RCC.T3:	SETZB	T1,T2
	MOVEI	T3,'C'-'@'	;Return Control-C
	POPJ	P,

SUBTTL	Variables used by both TYMSER and SCNUUO

OPRLDB::0	;LDB FOR OPER CONSOLE FOR MSGS ETC
UPSHUT:	0	;PLACE FOR UP-SHUT COMMAND TO BE STORED

     