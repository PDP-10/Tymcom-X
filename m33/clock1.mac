TITLE	CLOCK1 - CLOCK, CONTEXT SWITCHING, AND JOB STARTUP AND STOP ROUTINES

	STOPCD(,ENTRY,CLOCK1)

EXTERNAL UPSCLK,UPTSTS,UPTABK
EXTERNAL UPTLDC,UPTJOB
EXT(<%UPT,%UPS,%UPX>)
EXTERNAL RELEA9,JBTUPM,JBYUWS
EXTERNAL USRCLK,CURUPT,UPT,EPT
EXTERNAL UPTPC,UPTPDL,UPTXAC,UPTACP
EXTERNAL CIPWTM
EXTERNAL JOBOPC,UPTUAC
EXTERNAL ERRTLE

CLKSAV:	0		;SAVE CLK CONI HERE
NULSAV:	0		;NULL TIME LAST TICK
CLOCK::	POINT 36,CIPWTM,35	;BYTE POINTER TO CLOCK REQ QUEUE
CLKNEW::0		;Nonzero when something was put into the queue
DEFINE CALMAP,<>
SUBTTL	CLOCK - LOW PRIORITY CLOCK SERVICE(CLK)

;THIS ROUTINE RUNS ON THE LOWEST PRIORITY PI CHANNEL AND AT UUO LEVEL.

;TO CAUSE AN INTERRUPT ON CLK CHANNEL:
;	SETOM CLKFLG	;FLAG THAT INTERRUPT HAS BEEN REQUESTED
;	WRPI CLKREQ	;REQUEST PI INTERUPT ON LOWEST PI CHANNEL
;THE FOLLOWING OTHER FLAGS MUST ALSO BE SET
;SCHEDF - RESCHEDULING MUST TAKE PLACE (EVEN THOUGH PC IN EXEC MODE)
;TIMEF  - APR CLOCK HAS TICKED ON HIGH PRIORITY CHANNEL
;SEE PICON AND ERRCON TO SEE HOW THIS ROUTINE IS CALLED

;CLK SERVICE PERFORMS THE FOLLOWING ON A REGULAR BASIS:
;PROCESSES CLOCK QUEUE REQUESTS
;CALLS CONSOLE MONITOR COMMAND DECODER
;CALLS CORE SHUFFLER
;THEN CALLS SCHEDULER
;IF THE CURRENT JOB IS IN EXEC MODE THE ABOVE 4 TASKS ARE
;DELAYED UNTIL THE CURRENT JOB ENTERS A STOPPABLE STATE: I.E., UNTIL
;	1. JOB STARTS TO WAIT FOR A BUSY SHARABLE DEVICE
;	2. JOB STARTS TO WAIT FOR IO TO COMPLETE
;	3. CONTROL ABOUT TO RETURN TO USER MODE
;THEN CLK SERVICE IS ENTERED AT UUO LEVEL

;THE CLOCK REQUEST QUEUE PROVIDES THE REST OF THE MONITOR
;WITH THE ABILITY TO BE TRAPPED TO AFTER A NUMBER OF CLOCK TICKS
;HAVE OCCURRED.
;
;TO MAKE A REQUEST:
;	WRPI LI.PIF
;	IDPB AC,CLOCK		;STORE CLOCK REQUEST IN QUEUE
;	WRPI LI.PIN		;TURN PI BACK ON
;Format of word in AC for TOPS-10 5.02 (precursor of TYMCOM-X):
; BYTE (18)ADDRESS(6)DATA(12)TIME
;Format of words in ACs for TOPS-10 7.02:
; BYTE (18)ADDRESS(18)TIME(36)DATA ;note - requires 2 IDPBs
;Format of word in AC for TYMCOM-X (see code at CIP2)
; BYTE (1)NONJIFFY(6)ADDR.INDEX(5)TYPE(7)JOB(1)MINUTE(16)TIME

CLKINI::MOVEI T1,CIPWTM		;SETUP CLOCK QUEUE BYTE POINTER
	HRRM T1,CLOCK		;LH NEVER CHANGES(36 BIT BYTE)
	POPJ P,
SUBTTL	WSCHED/USCHED - call scheduler and let someone else run

;Here at UUO level when current job is about to return to user mode from
; a UUO and either:
;	1. Current job typed Control-C while in Exec mode
;	2. Clock flag (TIMEF) went off while current job was in Exec mode

;CALL:	MOVE T1,JBTSTS(J)
;	PUSHJ P,USCHD1		;From UUOCON (MUUO handler return to user)
;	  return here when runnabel

USCHD1::TLNE	T1,CNTRLC	;Did user type Control-C while in Exec mode?
	 PUSHJ	P,TRHALT##	;Yes, stop job and turn off RUN bit, store halt INFO IN CONTEXT PAGES

;Here at UUO level from MONRET MUUO
;Same call as USCHD1, except no test for ^C.

USCHED::POP	P,%UPT+UPTPC	;Save PC in user's UPT
	MOVEM	P,%UPT+UPTXAC+P	;Save P in UPT dump AC area
	SETOM	STPFLG##	;Set a flag to say OK to stop job in Exec mode
	JRST	WSCHD2		;Go reschedule

;Here at UUO level when job goes into IO wait or sharable device wait.
;Also get here when a UUO routine voluntarily gives up control of the CPU
; to let other jobs run when it notices that TIMEF is nonzero.
;CALL:	PUSHJ P,WSCHED
;	  return here when runnable again

WSCHED::MOVEM	17,%UPT+UPTXAC+17 ;SAVE AC17 IN DUMP ACS (P4 IN NEW ACS)
WSCHD1:	POP	P,%UPT+UPTPC	;SAVE PC IN USER'S UPT.
	MOVEI	17,%UPT+UPTXAC	;SAVE ACS 0-16 IN DUMP ACS
	BLT	17,%UPT+UPTXAC+16 ;IN CURRENT UPT JOB DATA AREA
PRINTF(<[Need to locate calls to WSCHED and set LH of JBTPC there]>)
;*;	MOVE	J,JOB		;Make sure J is right
;*;	HRLM	F,JBTPC##(J)	;DDB of device job is waiting for
WSCHD2:	MOVE	P,NULPDL##	;NULL JOB PD LIST.  USED TO CALL SCHEDULER
				;AND COMMAND DECODER.
	CHGSTS	CLKSAV		;THIS IS ZERO AT INTERRUPT LEVEL
				; ELSE CHARGING CLOCK STATUS.
	NOCHARGE		;DON'T CHARGE FOR CONTEXT SWITCHING
	MOVE	J,JOB		;/WRS
	PUSHJ	P,WRSMAP##	;/WRS - ignore if no state change
	JRSTF	@[PC.UIO,,RSCHED] ;GO RESCHEDULE
SUBTTL	CLKINT - Clock interrupt (channel 7)
;CLKFLG        = Go to clock level if in User mode and reschedule
;CLKFLG+STPFLG = Go to clock level even if in Exec mode and reschedule
;CLKFLG+TIMEF  = Do time-of-day and accounting (because jiffy clock ticked)

CLKINT::SKIPA			;No CONSZO, always skip
	 JRST	.-.		;Check other devices on channel 7
	WRPI	CLKBIT##+1B22	;Clear program request on this channel
	SKIPN	CLKFLG##	;Time to go to clock level?
	 JRST	CLKINT+1	;No, someone else caused channel 7 interrupt
	EXCH	17,CLKCHL##	;Get PC at time interrupt was noticed
	TLNN	17,PC.USR	;In user mode?
	SKIPE	SCHEDF##	;Or is this a forced rescheduling interrupt?
	 JRSTF	@[XWD PC.UIO,SAVPC] ;Yes, it is OK to reschedule now
	EXCH	17,CLKCHL##	;No, go back to UUO level routine
	JEN	@CLKCHL##	; and wait for it to notice TIMEF is set

;Here if PC was in user node, or PC was in exec mode and SCHEDF nonzero

SAVPC:	SETZM	CLKSAV		;Clear CONI save flags
	MOVEM	17,%UPT+UPTPC	;Save PC for user (may be in Exec mode)
	TLNE	17,PC.USR	;Were we in User mode?
	 JRST	CLKUSM		;Yes, EXECAC will preserve user's ACs
	EXCH	17,CLKCHL##	;No, get Exec ACs in use by this UUO
	MOVEM	17,%UPT+UPTXAC+17; and store them in the right place
	MOVEI	17,%UPT+UPTXAC
	BLT	17,%UPT+UPTXAC+16
	JRST	CLKEXM		;Skip over the EXECAC instruction

CLKUSM:	EXCH	17,CLKCHL##	;Put user PC back for CRSHID
IFNCPU(KI),<EXECAC>		;Switch to Exec AC block, with users as previous.
	SETOM	STPFLG##	;OK to stop job
	MOVE	J,JOB		;Get this user's job number
	HRL	J,CLKCHL##	;Get user's PC
	HLRZM	J,JBTPC##(J)	;Store for Control-T

CLKEXM:	MOVE	P,NULPDL##	;Set up stack in null job's UPT
IFCPU (KS),<NOCHARGE>		;Freeze time base for charging
	SKIPGE	%UPT+UPTJOB	;Is job going way?
	 SETOM	JOB##		;Yes, set special flag
	PFALL	RSCHED
SUBTTL	RSCHED - Reschedule job, run another

RSCHED:	SKIPE	%UPT+UPTLDC	;Is job's UPT in an unstable state?
	 STOPCD (.,JOB,PAGP3R,,<Pager - P3 and P4 in use at RSCHED>) ;;RSCHED+1
	SKIPGE	J,JOB##
	 JRST	RSCH1		;Don't TIMADJ if job is going away
	SKIPE	JBTLIM(J)
	 PUSHJ	P,TIMADJ	;Check for TRU limit exceeded
RSCH1:	SKIPN	TIMEF##		;Had clock ticked since we were here last?
	 JRST	CIP6		;No, just reschedule

;Account for null time

	SKIPN	J,JOB##		;Was last job the null job?
	SKIPN	POTLST##	;Yes, was it a lost tick?
	 JRST	INCTIM		;No, usefull work was accomplished
	AOS	LSTWRD##	;Yes, increment lost time count
	SETZM	POTLST##	;Clear flag for next time
INCTIM:	SKIPN	J		;Did null job run?
	 AOS	NULTIM##	;Yes

;Increment time of day stuff

	SKIPN	T1,DTMADJ##	;Need to adjust date/time?
	 JRST	INCTM2		;No
	JUMPL	T1,INCTM1	;Slow down if negative
	AOS	TIME##		;Double tick as long as DTMADJ is positive
	SOSG	DTMADJ##	;One less tick to adjust
	 PUSHJ	P,OPRDTM##	;Tell OPR when adjustment is complete
	JRST	INCTM2

INCTM1:	MOVE	T1,UPTIME##	;Check if UPTIME is odd or even
	TRNE	T1,1		;Is it an even tick?
	 JRST	INCTM2		;No, leave this one alone
	SOS	TIME##		;Yes, clock runs half as fast
	AOSL	DTMADJ##	; as long as DTMADJ remains negative
	 PUSHJ	P,OPRDTM##	;Tell OPR when adjustment is complete

;Midnight check

INCTM2:	MOVE	T2,TIME##	;Time of day is incremented in PICON
	MOVEM	T2,SYSUPT##	;System uptime, CONFIG table item 136
	CAMGE	T2,MIDNIT##	;Gone past midnite?
	 JRST	CIP2		;No
	MOVN	T2,MIDNIT##	;Reset time
	ADDM	T2,TIME##
	AOS	THSDAT##	;And increment date
	PFALL	CIP2
SUBTTL	Handle requests in the clock queue

;Format of word in clock request for TYMCOM-X
; BYTE (1)NONJIFFY(6)ADDR.INDEX(5)TYPE(7)JOB(1)MINUTE(16)TIME
;BITS 1-6 ARE A TABLE INDEX TO THE FUNCTION TO CALL
;BITS 7-11 ARE A TYPE FIELD. ONLY 1 REQ/JOB/TYPE
;BITS 12-18 ARE THE JOB NUMBER
;IF BIT 0=0 THEN BITS 19-35 ARE THE TIME COUNT IN JIFFIES (max of 72 minutes)
;IF BIT 0=1 & BIT 19=0 THEN BITS 20-35 ARE THE TIME COUNT IN SECONDS
;IF BIT 0=1 & BIT 19=1 THEN BITS 20-35 ARE THE TIME COUNT IN MINUTES

CIP2:	SKIPGE	DWNFLG##	;Go to TAKDWN when all job and all SATs gone
	SKIPLE	HIGHJB##
	 JRST	CIP2A
	SKIPN	INTERM##	;DO NOT GO DOWN IF LAST TERMINAL NOT OFF
	 PUSHJ	P,HANGRB##	;ALL THE RIBS OUT OF CORE?
	  JRST	CIP2A
	SKIPGE	SATWRT##	;DO NOT GO DOWN UNLESS ALL SATS OUT.
	 JSR	TAKDWN##	;ORDERLY SHUTDOWN, ALL JOBS GONE

CIP2A:	HRRZ	U,CLOCK		;GET ADDRESS OF NEXT CLOCK REQUEST
CIP4:	CAIN	U,CIPWTM	;FINISHED YET?
	 JRST	CIP5		;YES
	SOSGE	T2,(U)		;DECREMENT TIME COUNT
	 JRST	CIP4S		;BIT 0 ON, SEC. OR MIN.
CIP4T:	TRNE	T2,377777	;IS TIME FIELD NOW ZERO JIFFIES?
	 SOJA	U,CIP4		;NO, CHECK NEXT REQUEST
	WRPI	LI.PIF		;U POINTS TO EXPIRED ITEM
	MOVE	T1,@CLOCK	;GET REQUEST PLACED IN QUEUE LAST
	SOS	CLOCK		;BACK UP IDBP POINTER
	MOVEM	T1,(U)		;STORE LAST INPLACE OF EXPIRED REQUEST
	WRPI	LI.PIN
	LDB	T1,[POINT 7,T2,18];GET JOB NUMBER
	LDB	T2,[POINT 6,T2,6];AND DISPATCH NUMBER
	PUSH	P,U		;SAVE POINTER
	PUSHJ	P,@CLKDSP(T2)	;DISPATCH
	POP	P,U
	SOJA	U,CIP4		;FINISH UP

;HERE FOR A SECONDS OR A MINUTES REQUEST

CIP4S:	SKIPN	HNGTIM##	;IS THIS AN EVEN SECOND?
	 JRST	CIP4M		;YES, SEE IF WANT SECONDS OR MINUTES
CIP4S1:	AOS	(U)		;NO, RESET REMAINING TIME
	SOJA	U,CIP4		;AND GO ON

CIP4M:	TRZE	T2,1B19		;SECONDS?
	 SKIPN	HNGMIN##	;NO MINUTES, EVEN MINUTE?
	  JRST	CIP4T		;WANTED SECONDS OR EVEN MINUTE, TAKE TRAP
	JRST	CIP4S1		;FORGET IT

CLKDSP:				;DISPATCH ROUTINES
	PHASE 0
.SLWAK::! EXP WAKE		;WAKE JOB
.SLDSC::! EXP DECSCC##		;Decrement stopcodes per minute
.SLTIM::! EXP TIMWAK		;WAKE UP THE TRU-LIMIT TIMER
.SLHNG::! EXP MONHNG##		;HANG ON DETACHED TIMOUT
	DEPHASE
SUBTTL	Finished all requests in the clock queue, update time of day

CIP5:	SKIPLE	J,JOB##
	 PUSHJ	P,USRCLK	;See if user wants a clock trap

;Once-a-tick time keeping

CIP5A:	PUSHJ	P,ADJUDT##	;Adjust Universal Date/Time every tick
	SOSGE	HNGTIM##	;This counts from 59 to 0 inclusive
	 PUSHJ	P,SECOND	;Do once-a-second stuff when HNGTIM=-1
	SKIPE	COMCNT##	;Any commands to process?
	 PUSHJ	P,COMMAND##	;Yes, call command decoder in COMCON
	SKIPN	PCDCNT##	;Anything to do with PCBs?
	 PUSHJ	P,TIMPCD##	;Yes, go to it.
	PUSHJ	P,SCNINT##	;Do SCNSER stuff at clock level

; ** maybe move to 1/sec or 1/minute ???
	SKIPL	J,JOB
	SKIPN	JBTLIM(J)
	 JRST	CIP6		;NO LIMIT DESIRED
	PUSHJ	P,CLKTRU##	;CALC CURRENT TRU FIGURE
	CAMGE	T1,JBTLIM(J)	;IS IT OVER?
	 JRST	CIP6		;NO
	MOVE	T1,[XWD JACCT,KJP]	;(JACCT or KJob Pending?)
	TDNN	T1,JBTSTS##(J)	;OR IS THIS ONE UNSTOPABLE
	SKIPN	STPFLG##
	 JRST	CIP6		;DO NOT STOP IN A DANGEROUS PLACE

	LDB	T1,JBYLIM##	; See if we have the interrupt enabled?
	JUMPE	T1,CIP5B	; If not, then go and stop the frame
	SETZM	JBTLIM(J)	;  else clear the limit
	PUSHJ	P,TAKTRP	;  and fire the interrupt.
	JRST	CIP6		;  and go on.

CIP5B:	PUSHJ	P,ERRTLE	;Go do proper thing, return after calling STOP1.
INTERN	CIP6	;ERRTLE jumps back here to CIP6 when done.
PRINTF(<[CIP5B: Check out ERRTLE, cause may want 1/sec or 1/minute]>)

CIP6:	PUSHJ	P,NXTJOB##	;Call SCHEDULER
	SETZM	CLKFLG##	;Clear clock-level request flag
	SETZM	TIMEF##		;Clear "jiffy clock has ticked" flag
	SETZM	SCHEDF##	;Clear forced scheduling flag
	SETZM	STPFLG##	;Clear "Ok to stop in exec-mode" flag
	CAMN	J,JOB		;Did NXTJOB select same job as previous?
	 JRST	CIP8		;Yes, just restore ACs and dismiss
	PUSH	P,J
	SKIPL	J,JOB		;No TIMADJ if old job is going away
	 PUSHJ	P,TIMADJ	;Update time accounting before switching UPT
	POP	P,J
;DIFFERENT JOB, SAVE SOFTWARE STATE(HARDWARE ALREADY SAVED)

	SKIPN	T2,JOB		;IF NULL JOB,
	 JRST	CIP6C		;DON'T SAVE ACS.
	JUMPL	T2,CIP7		;IF LAST JOB LOGGED OUT,
				; DON'T TOUCH UPT AT ALL, ITS GONE.
IFNCPU (KI),<
	MOVE	T1,%UPT+UPTACP	;IS "REAL" PREVIOUS AC BLOCK USER?
	TLNE	T1,(LG.PAC)	;IF NOT, MUST SAVE PREVIOUS AC BLOCK IN STACK.
	 JRST	CIP6D		;YES, HAVE TO SAVE PREVIOUS.
CIP6E:
>;END IFNCPU (KI)
	MOVEI	T1,%UPT+UPTUAC	;READY TO STORE USERS ACS (FROM AC BLOCK)
	XCTFU	<BLT T1,%UPT+UPTUAC+17>
CIP6C:	SKIPN	T1,CLKSAV	;EITHER FROM SAVE (WSCHED ETC)
	 CHGSTS	T1		;FOR FROM CLOCK
	MOVSI	T2,UPSCLK
	ANDCAM	T2,%UPT+UPTSTS	;RESET SAVED BIT
	TRNE	T1,CHGON
	IORM	T2,%UPT+UPTSTS	;AND SET IF CLOCK IS ON

;RESTORE SOFTWARE STATE OF NEW JOB,THEN HARDWARE STATE

NULJOB::			;TRANSFER HERE FROM SYSINI WITH J=0
CIP7:	HRRZ	T1,JBTUPM(J)	;GET ITS UPT ADDRESS
	TRNN	T1,17777	; Make sure it's NON-ZERO (1-17777)
	 STOPCD (.,STOP,PAGZER,PRTJOB##,<Pager - UPT is zero>) ;;CIP7+3
	MOVEM	J,JOB		;STORE NEW CURRENT JOB NUMBER

IFNCPU (KI),<
	MOVEM	T1,CURUPT	;POINT TO THE UPT FOR THE NEW JOB
	JUMPE	J,NULJB		;
	HRLI	T1,(LG.LUB!LG.LAB!<EX0ACB>B8+<USRACB>B11)
	WRUBR	T1		;MAKE USER ACS ACCESSABLE FOR RESTORE.
>;END IFNCPU(KI)
IFCPU (<KL,F3>),<
ABKSET::WRADB	%UPT+UPTABK	;Patch to JFCL for system-wide address break
>;END IFCPU(KL,F3)
IFCPU (KS),<
ABKSET::JFCL			;KS does not have hardware for Address Break
>;END IFCPU(KS)

IFCPU (KI),<
	HRLM	T1,CURUPT	;WRUBR with LH
	DATAO	PAG,CURUPT	;RESET THE PAGING HARDWARE TOO
	JUMPE	J,NULJB		;
ABKSET::JFCL	%UPT+UPTABK	;Operations does not want addr break on KI
>;END IFCPU (KI)

	MOVSI	17,%UPT+UPTUAC
	XCTTU	<BLT 17,17>	;RESTORE USERS ACS
IFNCPU (KI),<
	MOVE	T1,%UPT+UPTACP	;GET AC STATUS STUFF
	TLNN	T1,(LG.PAC)	;PREVIOUS ACS ALREADY USER?
	 JRST	CIP7A		;YES, NOTHING MORE TO DO.
	WRUBR	T1		;NO, GET REAL AC STUFF.
	MOVE	T1,%UPT+UPTACP	;IN CASE IT DISAPPEARED
	MOVSI	T2,-16(T1)	;POINTER TO RESTORE PREVIOUS ACS
	XCTTU	<BLT T2,17>	;RESTORE THEM.
	MOVE	T2,%UPT+UPTPC	;GET PC
	TLNN	T2,PC.UIO	;IF USER IOT IS OFF,
	 JRST	CIP7A		;EVERYTHING IS NOW SET.
	TLZ	T1,(LG.PAC)	;NO, MUST ACCESS USER ACS IN XCTS
	WRUBR	T1		;SO SET IT UP.
>;END IFNCPU (KI)
CIP7A:
IFCPU (KI),<
	HLRZ	T1,%UPT+UPTACP	;GET STACKED AC POINTER
	CONI	PAG,T2		;TO PRESERVE PAGE TABLE RELOAD COUNTER
	TRZ	T2,760000	;CLEAR THIS FIELD
	IOR	T2,T1		;SET EXECUTIVE AC STACK POINTER BITS
	CONO	PAG,(T2)	;SET IT
>;END IFCPU (KI)

;RESTORE HARDWARE STATE OF CURRENT JOB

IFNCPU(KS),<NOCHARGE>		;MAKE SURE CLOCK IS OFF (IN CASE IRP LEVEL)
IFCPU (KS),<
	SKIPE	TBON		;TEST IF CLOCK OFF
	 JRST	[RDTIME TBVALUE	;ELSE TURN OFF
		 SETZM	TBON
		 JRST .+1]
>;END IFCPU (KS)
	MOVE	T1,%UPT+UPTSTS	;IS CLOCK SUPPOSED TO BE ON?
	TLNE	T1,UPSCLK
IFNCPU(KS),<CHARGE>		;YES, TURN IT ON
IFCPU (KS),<SKIPA>		;TEST KS CHARGING STATE
	JRST	CIP9		;GO RETURN TO THE PROGRAM.
IFCPU (KS),<
	SKIPN	TBON	;SKIP IF ALREADY ON
	 JRST	[WRTIME TBVALUE
		 SETOM TBON
		 JRST .+1]
	JRST	CIP9>

CIP8:	SKIPN	T1,CLKSAV	;FROM INTERUPT LEVEL?
	 JRST	CIP9		;YES
	TRNE	T1,CHGON	;WAS CLOCK ON WHEN USER CAME IN?
IFNCPU(KS),<CHARGE>		;YES, RESTORE STATE OF THE CLOCK.
IFCPU (KS),<SKIPA>
	JRST	CIP7B
IFCPU (KS),<
	SKIPN	TBON		;SKIP IF CLOCK ALREADY ON
	 JRST	[WRTIME TBVALUE
		 SETOM  TBON
		 JRST   .+1]>

CIP7B:	CALMAP
	PFALL	CIP9
CIP9:	MOVSI	17,%UPT+UPTXAC	;RESTORE DUMP ACS
	MOVE	T3,%UPT+UPTPC
	TLNN	T3,PC.USR
	 JRST	[BLT 17,17	;RESTORE ACS FOR EXEC MODE
		 JEN @%UPT+UPTPC]
	MOVE	P,[IOWD EPLLEN,%UPT+UPTPDL] ;Big stack in real UPT
	JRST	USRXT7##	;AND GO THROUGH USRXIT FOR TRAPS

;THE NULL JOB
;RUNS IN USER MODE WITH PC=1 AND COUNTS IN AC 0

NULJB:
IFNCPU(KS),<CHARGE>
IFCPU (KS),<
	SKIPN	TBVALUE	;SKIP IF CLOCK ALREADY ON
	 JRST	[WRTIME TBVALUE
		 SETOM TBON
		 JRST .+1]
>;END IFCPU (KS)
IFCPU (<KL,F3>),<
	MOVE	T2,ABKSET	;GET SETTING INSTRUCTION
	CAMN	T2,[DATAO APR,%UPT+UPTABK] ;LEAVE ALONE IF NOT NORMAL MODE.
	 DATAO	APR,[0]		;NO NULL JOB ADDRESS BREAK.
>; END IFCPU (<KL,F3>)
IFNCPU(KI),<
	HRLI	T1,(LG.LUB!LG.LAB!<USRACB>B8+<USRACB>B11)
	WRUBR	T1		;SET USER AC BLOCKS, UBR OF NULL JOB.
IFNCPU(F3),<
	SETZ	0,
	MOVE	1,[AOJA 1]	;THIS IS KL AND KS NULL JOB
>;END IFNCPU (F3)
IFCPU(F3),<
	MOVSI	17,F3NULJ
	BLT	17,17
>;END IFCPU (F3)
	JEN	@[PC.USR+PC.PUB+PC.UIO,,1] ;START IT.
>; END IFNCPU (KI)
IFCPU (F3),<;DO LIGHTS SHOW ON AN F3

F3NULJ:	0		;0/
	MOVEI	0,100000;1/ Delay loop
	SOJG	0,2	;2/  ...
	ROT	16,-3	;3/ Shift 4 bits right 3 places
	ROT	17,2	;4/ Shift 4 bits left 2 places
	MOVE	15,17	;5/
	IOR	15,16	;6/ Combine them
	DATAO	PI,15	;7/ Display in lights
	JRST	1	;10/
	0		;11/
	0		;12/
	0		;13/
	0		;14/
	0		;15/ Combined bits
	17		;16/ Right bits
	17		;17/ Left bits
>;END IFCPU (F3)

IFCPU (KI),<
	JEN @%UPT+UPTPC ;ALSO DISMISS IF IN INT
>;END IFCPU (KI)

IFNCPU(KI),<
;HERE IF "REAL" PREVIOUS AC BLOCK IS NOT USER - MUST SAVE
; IT IN AC STACK. T1 CONTAINS UPTACP WORD.

CIP6D:	MOVE	T2,%UPT+UPTPC	;IF USER IOT IS CLEAR, ALREADY SET CORRECTLY
	TLNE	T2,PC.UIO
	 WRUBR	T1		;SETUP "REAL" PREVIOUS ACS.
	HRRI	T1,-16(T1)	;GET FIRST ADDRESS IN RH OF T1, AC DATAO IN LH T1
	HRRZ	T2,T1		;0,,FIRST ADDRESS IN T2.
	TRNE	T1,17		;HOPE THERE'S ROOM LEFT
	 STOPCD (.,JOB,PAGSAC,,<Pager - Cannot Stack ACs>) ;;CIP6D+6
	XCTFU	<BLT T2,17(T1)> ;SAVE PREVIOUS AC BLOCK
	TLZ	T1,(LG.PAC)	;SET TO SAVE USER ACS
	WRUBR	T1		;DON'T TRUST USER IOT
	JRST	CIP6E
>;END IFNCPU (KI)
SUBTTL	SECOND - Called once per second at clock level

SECOND::MOVE	T1,UPTIME##	;If channel 7 was not delayed, then T2 gets 0
	IDIV	T1,JFYSEC##	; otherwise it gets # of ticks of delay
	MOVNI	T1,1(T2)	;Set to -1 or -2
	ADD	T1,JFYSEC##	;Set to 59 (or 58) ticks until next time
	MOVEM	T1,HNGTIM##	;Number of jiffies until next second

	PUSH	P,LOCSEC##	;Save this for compare later
	PUSHJ	P,UDTFIX	;Reset LOCMIN and LOCSEC from TIME
	PUSHJ	P,UPELP		;Update elapsed time in JBT tables
	PUSHJ	P,UNISEC##	;Check for hung disks
	PUSHJ	P,SWPSEC##	;Write out dirty pages (swapper)
	PUSHJ	P,DEVCHK##	;Check for hung devices (other than DSK)
	SKIPE	CTYBLF##	;If RH is nonzero (meaning do once per second),
	 HRROS	CTYBLF##	; set LH to go ding this time
IFCPU (KS),<
	PUSHJ	P,KSSEC##	;Do Keep-Alive and KMC once-per-second stuff
>; END IFCPU (KS)
	PUSHJ	P,SCNSEC##	;Go handle teletype timing
	SOSGE	HNGMIN##	;Count down once-a-minute hung timer
	 JRST	[MOVEI	T1,^D59		;Reset counter for hung devices
		MOVEM	T1,HNGMIN##	;This MUST occur every 3600 ticks
		MOVE	T1,NULTIM##	; (even when clock is being adjusted)
		EXCH	T1,NULSAV	;Save # of ticks the null job ran
		SUB	T1,NULSAV	;Calculate difference from last minute
		MOVNM	T1,NULMNT##	;Store it as a positive number
		JRST	.+1]		;HNGMIN is not synchronized with LOCSEC
	POP	P,T1		previous LOCSEC (in case it is 59)
	CAMG	T1,LOCSEC##	;Did UDTFIX reset LOCSEC back to 0 (or 1)?
	 POPJ	P,		;End of SECOND routine
	PFALL	MINUTE
SUBTTL	ONCE A MINUTE CODE

MINUTE::SKIPE	KSYS##		;Is the KSYS timer set?
	 JRST	[SOSN	KSYS##	  ;Yes, count down minutes until KSYS is over
		  SETOM	KSYS##	  ;Set to -1 when it hits zero
		 JRST	.+1]	  ;Negative means "TIMESHARING IS OVER!"
	AOS	T1,BGBENF	;# of minutes since last Big Ben message
	ANDI	T1,777777
	HLRE	T2,BGBENF	;# of minutes between messages
	CAML	T1,T2		;Time to do the "Big Ben" message?
	 PUSHJ	P,BIGBEN	;Yes, output message to CTY
	PUSHJ	P,RPTSAT##	;REPORT ANY NEWLY BAD SATS.

;INACTIVITY TIMEOUT

	HRRZ	J,HIGHJB	;Loop from HIGHJB to zero
MINUT1:	LDB	T3,JBYINA##
	JUMPE	T3,INACT1	;JUMP IF INACTIVITY HANG DISABLED
	MOVE	T1,JBTINA##(J)
	CAILE	T3,(T1)		;Have we reached the limit?
	 JRST	INACT1		;  No!
	TLOE	T1,INAHIT##	;RECORD FACT THAT INACTIVITY HIT OCCURED
	 JRST	INACT1		;ALREADY OCCURED
	MOVEM	T1,JBTINA##(J)
	LDB	T1,JBYNIC##	;Is parent watching NTQ for me?
	JUMPE	T1,INTKI0	;  No, just check for NTQ below
	PUSH	P,J		;Yes, save current job
	LDB	J,PRNTBP(J)	;Get parent
	SKIPE	J		;If we still have a parent,
	 PUSHJ	P,TAKTRP	; notify it
	POP	P,J		;Restore job
	JRST	INACT1		;Head for next job

INTKI0:	SKIPL	JBTSTS##(J)	;Is job runable (not halted or ^C)?
	 JRST	INTKIL		;  No, ignore NTQ and just kill it
	LDB	T1,JBYNTQ##	;GET NTQ CHANNEL
	JUMPE	T1,INTKIL	;NTQ NOT ENABLED, GO KILL JOB
	PUSHJ	P,TAKTRP	;FIRE NTQ
	JRST	INACT1
INTKIL:	PUSH	P,J
	MOVE	T1,J		;HANG JOB J
	HRLI	T1,(1B13!1B17)	; EVEN IF DETACH
	PUSHJ	P,HNGMON##	; OR TIMEOUT SET
	  JFCL			;ALREADY HUNG
	POP	P,J
INACT1:	AOS	JBTINA(J)	;INCREMENT INACTIVE COUNT
	MOVE	T1,JBTSTS##(J)
	TLNN	T1,JERR		;CAN NOT CONTINUE
	TRNN	T1,JDCON
	 JRST	MINUT2
	MOVE	T1,J
	PUSHJ	P,FCONRQ	;TRY TO FORCE A CONTINUE
	  JFCL			;CAN NOT, IGNORE IT
MINUT2:	SOJG	J,MINUT1

	PUSHJ	P,WDOG		;Call watch-dog routine
	SKIPE	DTMADJ##	;Is date/time being adjusted?
	 PUSHJ	P,FIXWEK	;Yes, recalculate GMTDIF and LOCWEK every minute
	SKIPE	LOCMIN##	;Check if it is the top of the hour
	 POPJ	P,		;End of MINUTE routine
	PFALL	HOUR

SUBTTL	Once-an-hour code

;Check if daylight savings time is in effect, and adjust GMTDIF

HOUR::	PUSHJ	P,FIXWEK	;Change GMTDIF if daylight savings boundry
	SKIPN	LOCHOR##	;Check if 00:00 hours
	 POPJ	P,		;End of HOUR routine
	PFALL	DAY

SUBTTL	Once-a-day code

DAY::				;More code can be added here
	POPJ	P,		;End of DAY routine

;FIXWEK - Routine to update GMTDIF (difference between local and GMT) and
;         to update LOCWEK (address of ASCIZ string for day of week)
;	Called when time-of-day is changed and once an hour
;Uses T1,T2,T3,T4

FIXWEK::MOVE	T1,TIME##	;Time of day in ticks
	MOVE	T2,THSDAT##	;Date
	PUSH	P,J		;Save J and P4 in case called from UUOCON
	PUSH	P,P4
	MOVEI	J,0		;Local to job 0's time zone
	MOVE	P4,[400020,,100000]
	PUSHJ	P,DATCOM##	;Convert to UDT local time, with daylight
	  JRST	FIXWK0		;Date not set
	HLRZ	T1,T2		;Keep date portion of UDT
	SUB	T2,DATE##	;Compare with UDT in GMT
	MOVEM	T2,GMTDIF##	;This will be different if daylight started
	IDIVI	T1,7		;Get remainder when LH(UDT) is divided by 7
	MOVE	T1,WEKDAY(T2)	;Get pointer to ASCIZ string
	MOVEM	T1,LOCWEK##	; that has name of day of week
FIXWK0:	POP	P,P4
	POP	P,J
	POPJ	P,

;By a remarkable coincidence, TYMSHARE's day 0 (1-Jan-1984) and Greenwich
;day 0 (17-Nov-1858) were both on a Wednesday.  To determine day of week, take
;the LH of either format, divide by it 7, and use the remainder.

WEKDAY:	[ASCIZ	/Wednesday/]	;0
	[ASCIZ	/Thursday/]	;1
	[ASCIZ	/Friday/]	;2
	[ASCIZ	/Saturday/]	;3
	[ASCIZ	/Sunday/]	;4
	[ASCIZ	/Monday/]	;5
	[ASCIZ	/Tuesday/]	;6
SUBTTL	Update the other time-of-day locations

;Reset LOCSEC,LOCMIN,LOCHOR,LOCDAY,LOCMON,LOCYER from THSDAT and TIME
;Called once per second, or when the date/time is changed
;Returns with T1/Hour, T2/Minute, T3/Second, T4/Ticks

UDTFIX::HRROS	LOCDAY##	;LOCDAY is invalid until THSDAT gets set
	SKIPG	THSDAT##	;Don't do this until date/time comes
	 POPJ	P,		; in from the supervisor
	PUSH	P,J		;Preserve J and P4 in case
	PUSH	P,P4		; called from SCNSER
	SKIPN	LOCWEK##	;If first time after date received,
	 PUSHJ	P,FIXWEK	; calculate day of week
	MOVE	T1,TIME##	;Ticks since midnight
	MOVE	T2,THSDAT##	;Days since 1-Jan-1964
	MOVEI	J,0		;Job 0 has time zone of CTY
	MOVSI	P4,400020	;Convert from TYMSHARE format to DEC local time
	PUSHJ	P,DATCOM##	; ... ticks since midnight in T1, date in T2
	  SETZB	T1,T2		;Should never happen
	POP	P,P4
	POP	P,J
	IDIVI	T2,^D31		;Get days-1 (T1 has time)
	ADDI	T3,1
	MOVEM	T3,LOCDAY##	;Set local day of month
	IDIVI	T2,^D12		;Get months-1
	ADDI	T3,1
	MOVEM	T3,LOCMON##	;Set local month
	ADDI	T2,^D1964
	MOVEM	T2,LOCYER##	;Set local year
	IDIV	T1,JFYHR##
	MOVEM	T1,LOCHOR##	;Set local hour
	IDIV	T2,JFYMIN##
	MOVEM	T2,LOCMIN##	;Set local minute
	IDIV	T3,JFYSEC##
	MOVEM	T3,LOCSEC##	;Set local seconds
	POPJ	P,		;T4 has ticks since last second
SUBTTL	BIGBEN - Output periodic message to the CTY
;Output disk space whenever RH of BGBENF is greater or equal to LH.
;(LH is inteval between messages, 1B0 can be poked to output it now)

BIGBEN::SKIPG	LOCDAY##	;Wait for date to be set
	 POPJ	P,
;Reset the timer (OPR can change interval via SET BIGBEN 480 command)
	HLRZ	T1,BGBENF##	;Number of minutes between messages
	TRZ	T1,400000	;Sign bit set if anyone wants to do it now
	CAIG	T1,^D<24*60>	;Max interval is every 24 hours
	CAIGE	T1,^D<10>	;Min interval is every 10 minutes
	 MOVEI	T1,^D<4*60>	;Default is every 4 hours
	HRLZM	T1,BGBENF##	;Reset timer
	MOVE	T2,LOCHOR##	;Current time of day
	IMULI	T2,^D60		;Minutes
	ADD	T2,LOCMIN##	;Time of day in minutes
	IDIV	T2,T1		;If interval is every 60 minutes,
	HRRM	T3,BGBENF##	; make it go off every hour on the hour
;First part of message
	MOVEI	T1,1		;Tell OPROUT to output to the CTY only
	PUSHJ	P,OPROUT##	;Set COMTOA for INLMES and such
	MOVEI	T1,CONFIG##	;System name (ASCIZ)
	PUSHJ	P,CONMES##	;Space over so LA36 printhead does not
	PUSHJ	P,PRSPC##	; obscure message
	PUSHJ	P,LOCTIM##	;Output time of day and a blank
	PUSHJ	P,INLMES##
	 ASCIZ /- Total of /
PRINTF(<[BIGBEN Check DRBSTR instead of STRDDB?]>)
	MOVEI	T4,STRDDB##	; Check right structure
	MOVE	T1,STRTAL##(T4)	;(see also the CORE command in COMCON)
	HLRZ	T2,BGBENF##	;Interval
	SUBI	T2,^D10		; minus 10 minutes
	CAIG	T1,^D1000	;If less than 1000 pages
	 HRRM	T2,BGBENF##	; go off again in 10 minutes
	PUSHJ	P,PRTDEC##	;Number of pages free
	PUSHJ	P,INLMES##
	 ASCIZ / pages free on /
	MOVE	T2,STRNAM##(T4)
	PUSHJ	P,PRNAME##	;Output "DSKB"
;Do the same for DSKA and any other STR
	PJRST	CRLF##		;End of BIGBEN
SUBTTL	WDOG - Once-a-minute watch dog routines
COMMENT #	** THE CHKPNT WATCHDOG **

ONCE A MINUTE THIS CODE EXAMINES THE SITUATION WITH THE STREAM
ACCOUNTING MECHANISM.
1. IF THE SYSTEM IS UN-SHUT (NOT IN AUTORESTRART,SHUT OR
   SUPERSHUT) AND NO ACT OWNER (PJOBN) EXISTS, A MESSAGE GOES TO
   BOTH OPR & CTY (OR JUST CTY IF NO OPR) AND THE BELL IS SET
   TO RING ONCE A SECOND.
2. IF SYSTEM IS IN ANY SHUT STATE, IT'S OK FOR ACTOWNER = 0
3. IF ACTOWNER HAS JERR ON (ILL INS,ILL MEM REF, EXIT..)
	THEN A REQUEST TO RESTART CHKPNT IS PUT OUT ON
	OPR & CTY AND THE CTY BELL IS SET TO RINGING.

4. A FAKE "SCHED 400000" IS DONE. THE ACTDED BIT IS SET,
   ALLOWING OPERATORS TO GET ONTO SYS AND FIX THINGS UP WITHOUT
   THEIR JOBS GOING INTO AC WAIT. SEE GETABS IN ACTSER.

CTY BELL FLAG CTYBLF WORKS AS FOLLOWS
0,,0	QUIET. MINUTE,SECOND & OPRCTY CODE DO NOTHING
0,,N	THE BELL SHOULD RING.  N has 18 bits for different causes
-1,,N	BELL SHOULD RING NEXT TICK (SET BY SECOND CODE, RESET BY OPRCTY)

#

WDOG:	MOVEI	T1,2		;Output to both OPR and CTY
	PUSHJ	P,OPROUT##
	SETZ	T2,		;Nothing to start with
	MOVEI	T1,STRDDB##	; Begin at first structure
WDOG0:	ADD	T2,STRTAL##(T1)	;GET ADVERTISED DISK SPACE REMAINING
PRINTF(<[Need to use STRNXT at WDOG]>)
;*;	HLRZ	T1,STRNXT(T1)	; All STRs (ACTUALLY A LITTLE MORE)
;*;	JUMPN	T1,WDOG0	; Check all structures
	CAILE	T2,^D100	;IF MORE THAN 100 PAGES LEFT, OK
	 JRST	WDOG1
	MOVEI	T1,[ASCIZ/
Disk space is less than 100 pages
/]
	SKIPG	T2		;PRINT THAT UNLESS ITS ACTUALLY EMPTY
	 MOVEI	T1,[ASCIZ/
Disk full, please take corrective action
/]
	PUSHJ	P,CONMES##	;PRINT ON CTY AND ON OPR TERM IF IT EXISTS

WDOG1:		;CLOBBER F,T1,T2,..,J
	MOVEI	F,ACTDDB##
	LDB	J,PJOBN##		;J:=ACT OWNER JOB IF INITTED
	MOVEI	T3,1			;PREPARE FOR SET CTYBLF BELL FLAG
	MOVE	T2,[STAUTO!STSUPR!STSHUT];AUTO-RESTART,SHUT,SUPER-SHUT
	TDNN	T2,STATES##		;IF ANY OF THESE ON, OK FOR ACT TO BE UN-INITTED
	 JUMPE	J,[HRRZM T3,CTYBLF##	;BELL FLAG GOES ON
		   MOVEI T1,[ASCIZ/
System UNSHUT without accounting.
Log in to 'OPER' and 'R CHKPNT'
/]
		   PUSHJ P,CONMES##	;SEND TO 2 PLACES IF POSSIBLE
		   MOVEI T2,ALRACT
		   IORM  T2,ALR620##
		   JRST  WDOG2]
	JUMPE	J,WDOG2		;SOME KIND OF SHUT STATE WITH NO CHKPNT
	MOVE	T1,JBTSTS##(J)
	TLNN	T1,JERR		;HAS ACT JOB DIED?
	 JRST	WDOG2		;NO
PRINTF(<[Need to define other bits for RH of CTYBLF, SET HAPPY]>)
	HRRZM	T3,CTYBLF##	;BELL FLAG GOES ON
	MOVEI	T2,ALRACT
	IORM	T2,ALR620##
	MOVSI	T2,ACTDED##	;DECLARE THE STREAM DEAD. SEE MGETABS (ACTSER)
	IORM	T2,DEVSTS(F)	;THIS LETS SOME JOBS GO W/O STREAM RECORDS
	MOVEI	T1,FATMSG	;FATAL CHKPNT ERROR MSG
	PUSHJ	P,CONMES##	;PRINT 2 PLACES IF POSS.
	PUSHJ	P,PJOBX##	;Output job number (in J)
	MOVEI	T2,STSHUT
	PUSHJ	P,SKDCOM##	;FAKE "SCHED 440000" & EXIT. DECLARE STREAM DEAD & SHUT SYS
	  JRST	.+1
WDOG2:	POPJ	P,		;End of WDOG

FATMSG:	ASCII /CHKPNT program fatal error
'R CHKPNT' after attaching to /		;PJOBX provides job number

; DBLMSG..TAKE MSG ADDR IN T1, TYPE IT OUT ON BOTH CTY AND OPR TTY IF
;THERE IS AN OPR TTY, ELSE JUST TO CTY. CLOB F,U,T1-T4. ALL
;OTHER ACS ARE NOT DESTROYED.   CALLED FROM SWAMP AND ACTSER

DBLMSG::MOVE	T4,T1		;Save addr of string
	MOVEI	T1,2		;Want to use 2 LDBs
	PUSHJ	P,OPROUT##	;Set COMTOA appropriatly
	MOVE	T1,T4		;Get addr of message back
	PJRST	CONMES##	;Output it then reset COMTOA
SUBTTL	Once-a-tick accounting
;UPDATE ELAPSED AND CONNECT TIME COUNTERS

UPELP:	MOVE	J,HIGHJB
	MOVE	T1,UPTIME##		;SEE HOW MANY SECONDS HAVE ELAPSED
	PUSH	P,T1			;SAVE UPTIME
	IDIV	T1,JFYSEC##		;TO SECONDS
	EXCH	T1,(P)			;UPTIME BACK
	EXCH	T1,SAVUPT		;GET UPTIME LAST TIME CALLED
	IDIV	T1,JFYSEC##		;SECONDS FOR THAT
	POP	P,T2
	SUB	T2,T1			;NUMBER OF SECONDS SINCE LAST CALL
SECTIM:	MOVE	T1,JBTSTS##(J)
	TLNN	T1,JNA
	 JRST	NXTSEC
	PUSHJ	P,GTCGSZ		;GET JOB'S CHARGING SIZE TO T1.
	IMUL	T1,T2			;GET SIZE*ELAPSED SECONDS
	ADDM	T1,JBTELP(J)
	ADDM	T1,JBTELP
	HRRZ	T1,TTYTAB(J)
	JUMPE	T1,NXTSEC		;IGNORE IF NOT TTY
	HRRZ	T1,DDBLDB(T1)		;SEE IF A U ATTACHED
	JUMPE	T1,NXTSEC		;NO, IGNORE
	ADDM	T2,JBTCNK(J)		;YES, N SEC. MORE OF CONNECT
	ADDM	T2,JBTCNK
NXTSEC:	SOJG	J,SECTIM
	POPJ	P,

SAVUPT:	0			;SAVE UPTIME FOR CALULATING CONNECT AND ELAPSED TIMES

EXTERNAL JBTELP,JBTCNK,TTYTAB,DDBLDB

;GET THE SIZE OF A PARTICULAR JOB

GETSIZ::EXCH	T2,(P)			;SIZE WILL BE ON TOP OF PDL ON RETURN
	PUSH	P,T2
	LDB	T2,JBYUWS		;GET USER WORKING SET SIZE
	LSH	T2,-1			;NEEDS TO BE IN K
	EXCH	T2,-1(P)
	POPJ	P,

COMMENT #
@@SUBROUTINE GTCGSZ
@@PURPOSE
GET INTO T1 THE CHARGING SIZE OF THE JOB IN K.
@@ENTRY
EXPECTS J/ JOB NUMBER.
@@ACCUM
DESTROYS T1.
@@EXIT
RETURNS SIZE IN T1.
@@#

EXTERN	JBYSC3,JBYSC4

GTCGSZ::LDB	T1,JBYSC4	;See if there is a size-dependent scale
				; factor (XCHARG TRU-scale UUO)
	JUMPE	T1,[LDB	T1,JBYSC3
		   JUMPE T1,GTCGS1
		   POPJ	P,]
	PUSH	P,T2		;Get a scratch register
	PUSH	P,T1		;Save denominator of fraction
	PUSHJ	P,GTCGS1	;Get internal size to T1
	LDB	T2,JBYSC3	;Get numerator
	IMULI	T1,(T2)		;T1 gets size*numerator
	POP	P,T2		;Get back denominator
	IDIVI	T1,(T2)		;T1 gets quotient
	POP	P,T2		;Restore work register
	POPJ	P,

GTCGS1:	LDB	T1,JBYUWS	;
	ADDI	T1,1		;ROUND UP.
	LSH	T1,-1		;
	POPJ	P,

;INTERRUPT HANDLERS FOR THE DK10 REAL TIME CLOCK

IFCPU (KI),<
;INITIALIZE

TIMINI::SETZM TIMCNT		;COUNT OF OVERFLOWS
	DATAO CLK,[0]		;SET STOP COUNT TO 0
	CONO CLK,CLKCDN+CLKCOV+CLKON+CLKUSR+CLKCLR+TIMCHN##
	SETZM TM2CNT
	DATAO CLK2,[0]		;MAKE SURE SECOND CLOCK IS RESET
	POPJ P,

TIMINT::CONSO CLK,CLKCDN+CLKCOV	;IS IT THE DK10?
	 JRST .-.		;NO
	DATAO CLK,[0]		;JUST TO MAKE SURE
	AOS TIMCNT
	CONO CLK,CLKCDN+CLKCOV+CLKON+CLKUSR+TIMCHN##
	JEN @TIMCHL##
TIMCNT:	0

TM2INT::CONSO CLK2,CLKCDN+CLKCOV ;2ND DK10 CLOCK ON KI-10
	 JRST .-.
	DATAO CLK2,[0]
	AOS TM2CNT
	CONO CLK2,CLKCDN+CLKCOV+CLKON+TM2CHN##
	JEN @TM2CHL##
TM2CNT:	0

STSTIM::CONO CLK2,CLKSTP
	DATAI CLK2,T1
	HRL T1,TM2CNT		;GET HIGH ORDER PART OF CLOCK
	DATAO CLK2,[0]
	CONO CLK2,CLKON+TM2CHN##
	POPJ P,
>;END IFCPU (KI)
;ROUTINES TO SIMULATE TURNING ON AND OFF THE CLOCK FOR THE KS

;  TO TURN ON THE CLOCK FOR THE USER THE TIME BASE IS SET
;    TO THE VALUE IN TBVALUE, INITIALLY SET TO 0
;  TO TURN OFF THE CLOCK THE CURRENT VALUE OF THE TIME BASE
;    IS SAVED IN TBVALUE AND USED TO RESET THE TIME BASE
;    WHEN THE CLOCK IS TURNED BACK ON

IFCPU (KS),<

;TURN ON CHARGING
KSCHRG::SKIPE	TBON		;TEST IF OFF
	 POPJ	P,		;RETURN IF ALREADY ON
	WRTIME	TBVALUE		;SET THE TIME BASE
	SETOM	TBON		;FLAG THE CHARGING ON
	POPJ	P,

;TURN CHARGING OFF IF ON
KSNOCH::SKIPN	TBON		;TEST IF CHARGING ON
	 POPJ	P,		;  IF NOT JUST RETURN
	RDTIME	TBVALUE		;ELSE SAVE CURRENT VALUE OF TIME BASE
	SETZM	TBON		;FLAG THE CHARGING OFF
	POPJ	P,

TBVALUE::0			;CURRENT VALUE OF THE TIME BASE
	 0			;LOWER HALF OF TIME BASE
TBON::	 0			;CHARGING FLAG, #0=ON, 0=OFF
>;END IFCPU (KS)
;TIMADJ ADJUSTS IN CORE COUNTS FOR A JOB.
;DESTROYS NO ACS.

DEFINE	DADDMT	(AC,HM,LM) 	; DOUBLE ADD TO MEMORY TABLE
<	ADDM AC,HM
	PUSH P,AC+1
	ADD AC+1,LM
	TLZE AC+1,400000
	 AOS HM
	MOVEM AC+1,LM
	POP P,AC+1>

TIMADJ::CAME J,JOB
	 POPJ P,		;NOT THE ONE RUNNING
	PUSH P,T1
	PUSH P,T2
	CHGSTS	T2		;SO WE CAN REMEMBER IF IT WAS ON
	NOCHARGE		;TURN CLOCK OFF.
IFCPU (KI),<
	DATAI CLK,T1
	HRL T1,TIMCNT		;AND THE OVERFLOWS
	SETZM TIMCNT		;RESET OVERFLOW COUNT
	DATAO CLK,[0]		;JUST TO MAKE SURE INTEVAL IS 2^18
	CONO CLK,CLKCDN+CLKCOV+CLKCLR ;START FRESH.
>;END IFCPU (KI)
IFCPU (F3),<
IF2, <PRINTX [What do we do on FOONLY for accounting?]>
	SETZ	T1,		;ZERO FOR NOW
>;END IFCPU (F3)
IFCPU (KL),<
	PUSH	P,T2		;SAVE CLOCK STATE
	RDMACT	T1		;MBOX (UPDATE %UPT+UPTHMC,LMC)
	RDEACT	T1		;EBOX (UPDATE %UPT+UPTHEC,LEC)
MAGIC1:	ASHC	T1,-^D3		; EBOX DIVIDER (8)
	DADD	T1,%UPT+UPTHMC	;GET EBOX COUNTS PLUS MBOX COUNTS
MAGIC:	ASHC	T1,-^D15	; EBOX+MBOX DIVIDER (2^15)
		; MCY = EBOX/2^18 + MBOX/2^15
	SETZM %UPT+UPTHEC
	SETZM %UPT+UPTLEC
	SETZM %UPT+UPTHMC
	SETZM %UPT+UPTLMC
	MOVE T1,T2		;SAVE LOW ORDER FOR LATER
	POP	P,T2		;GET CLOCK STATE BACK FROM STACK.
>;END IFCPU (KL)
IFCPU (KS),<
	PUSH	P,T2		;SAVE T2
	DMOVE	T1,TBVALUE	;GET ELAPSED TIME
	SETZM	TBVALUE		;CLEAR UPPER HALF OF TIME BASE
	SETZM	TBVALUE+1	;CLEAR LOWER HALF OF TIME BASE
MAGIC:	ASHC	T1,-^D12	;LEFT ADJUST TIME BASE
	MOVE	T1,T2		;MOVE ELAPSED TIME TO T1
	POP	P,T2		;RESTORE CHGSTS TO T2
>;END IFCPU (KS)
	TRNE	T2,CHGON	;WAS CLOCK ON?
	 CHARGE			;YES, TURN IT BACK ON.
	JUMPE J,NULTAJ		;DO NOT ACCUMULATE FOR NULJOB
	PUSH P,T1
	ADD T1,JBTCMP		;ACCUMULATE TOTAL
	TLZE T1,400000
	AOS JBTCP2
	MOVEM T1,JBTCMP
	MOVE T1,(P)
	ADD T1,JBTCMP(J)
	TLZE T1,400000
	AOS JBTCP2(J)
	MOVEM T1,JBTCMP(J)
	POP	P,T2		;
	PUSHJ	P,CHKMTM	;Adjust micro-cycle timer
	PUSHJ	P,GTCGSZ	;GET JOB CHARGING SIZE TO T1.
	PUSH	P,T1		;
	PUSH	P,T2		;
	MOVE	T1,T2		;
	MUL T1,-1(P)		;GET KILOCORE-MICROCYCLES
	ADD T2,JBTKCT
	TLZE T2,400000
	ADDI T1,1
	MOVEM T2,JBTKCT
	ADDM T1,JBTCPU
	POP P,T1
	POP P,T2		;GET SIZE OFF PDL
	MUL T1,T2		;THIS IS LIKE JBTKCT ONLY MORE SO
	ADD T2,JBTKCT(J)	;LOW ORDER PART
	TLZE T2,400000		;OVERFLOW?
	ADDI T1,1		;YES, ADD 1 TO HIGH ORDR
	MOVEM T2,JBTKCT(J)
	ADDM T1,JBTCPU(J)
NULTAJ:	POP P,T2
	POP P,T1
	POPJ P,

EXTERNAL JBTKCT,JBTCPU,JBTCMP,JBTCP2


; Here with incremental micro-cycles in T2 to update micro-cycle
; timer if one is set up, and to take trap if requested and
; timer runs out.
; Clobbers T1, preserves all other AC's.

	EXTERNAL UPTMTM
CHKMTM:	SKIPN	%UPT+UPTMTM	;Is there a micro-cycle timer set up?
	  POPJ	P,		;No, just return
	ADDM	T2,%UPT+UPTMTM	;Decrement timer by elapsed u-cycles
	SKIPGE	%UPT+UPTMTM	;See if timer ran out
	  POPJ	P,		;No, return
	SETZM	%UPT+UPTMTM	;Yes, turn it off before trapping
	LDB	T1,JBYMCY##	;Get u-cycle interrupt channel, if any
	PUSHJ	P,TAKTRP##	;If channel set up, take trap
	POPJ	P,		;Else just return
SUBTTL	RUNCSS - RUN CONTROL(STARTING AND STOPPING OF JOBS)

;RUN CONTROL IS A COLLECTION OF ROUTINES WHICH
;SET AND CLEAR BITS IN THE JOB STATUS WORDS OF
;ALL JOBS SO THAT THE SCHEDULER WILL START AND STOP
;THEM ACCORDINGLY

;COMMON ERROR STOPPING ROUTINES
;CALLED AT ANY LEVEL(M,CLK, OR INTERRUPT)
;CALL:	MOVE J,JOB CAUSING ERROR OR BEING STOPPED
;	MOVE F,ADRRESS OF THAT JOB TTY DEVICE DATA BLOCK
;	MOVE U,BYTE POINTER TO LAST CHAR. ALREADY MOVED
;			;TO TTY OUTPUT BUFFER
;	PUSHJ P,KSTOP,PHOLD,HOLD,OR ESTOP
;	NEVER RETURN IF CALLED AT UUO LEVEL

;ROUTINE TO STOP JOB AFTER KJOB COMMAND
;CALLED AT UUO LEVEL IF JOB HAD CORE, CLOCK LEVEL IF NOT

KSTOP::	PUSHJ	P,FRMDSN##	;Do frame deassign stuff
	SETOM	%UPT+UPTJOB	;Special KJOB flag
	PUSHJ	P,CLRJBT	;Clear job tables
	PUSHJ	P,DECHJB	;Update HIGHJB
	JRST	ESTOP

; IF THIS IS THE LARGEST JOB IN USE,FIND NEXT HIGHEST AND SET HIGHJB

DECHJB::CAMGE	J,HIGHJB##	;IS THIS THE BIGGEST JOB NUMBER ASSIGNED?
	 POPJ	P,
	MOVSI	T2,JNA+CMWB+JRQ	;YES, LOOK FOR LAST JOB WITH
				;JOB NUMBER ASSIGNED BIT OR COMMAND WAIT BIT
	HRRZ	T1,J		;SCAN DOWNWARD
	TDNN	T2,JBTSTS##(T1)	;ARE BITS SET FOR THIS JOB?
	 SOJG	T1,.-1		;NO,KEEP LOOKING,FINISHED(TRUE IF THIS THE ONLY JOB
	MOVEM	T1,HIGHJB##	;YES,STORE NEW HIGHEST JOB NUMBER ASSIGNED
	POPJ P,


CLRJBT::			;First clear non GETTABable items
	SETZM	JBTINT##(J)	;CLEAR INTERRUPT CHANNELS
	SETZM	JBTFNT##(J)	;Frame interrupt assignments (but not JBTPNT)
	SETZM	RTIME##(J)	;CLEAR INCREMENTAL JOB RUNNING TIME
	SETZM	JBTPWH##(J)
	SETZM	JBTPWL##(J)
	SETZM	JBTAJF##(J)
	SETOM	JBTSPN##(J)	;SETUP SO NEVER MATCHES ANYTHING. (set to ones)
	SETZM	JBTS2P##(J)	;OUR RIGHTS OVER PARENT INITIALLY ZERO.
	SETZM	JBTSTA##(J)	;Clear .USESTAT command word
	SETZM	JBTSLC##(J)	;Clear saved license, (+SETLIC -SETE UUOs)
	;----------------------- Now the GETTABable stuff
	SETZM	JBTSLM##(J)	;(-56)MAXIMUM TRU LIMIT
	SETZM	JBTINA##(J)	;(-55)INACTIVITY TIMEOUT
	SETZM	JBTFTR##(J)	;(-54)PARENT, BROTHER, CHILD
	SETZM	JBTUID##(J)	;(-53)UNIVERSAL ID NUMBER FOR FRAME
	SETZM	JBTPNO##(J)	;(-52)PROGRAM NUMBER FOR FRAME
	SETZM	JBTPWS##(J)	;(-50) NO. PAGES TO UWS.
	SETZM	JBTMPC##(J)	;(-47) NO. PAGES MAPPED.
	SETZM	JBTCP2##(J)	;(-42) HIGH PART OF MICRO-CYCLES
	SETZM	JBTBIO##(J)	;(-41) BIO CHAR CHARGE
	SETZM	JBTBET##(J)	;(-40) BIO TIME CHARGE
	SETZM	JBTSOK##(J)	;(-37) SOAKEM ARG
	SETZM	JBTERN##(J)	;(-33) ENTERS+RENAMES
	SETZM	JBTLIM##(J)	;(-30) TIME (TRU) LIMIT
	SETZM	JBTFPN##(J)	;(-25) FILE PPN (FOR HOME-FILES LICENSE)
	SETZM	JBTAUN##(J)	;(-23) ACCOUNT USER NUM
	SETZM	JBTUNM##(J)	;(-22) FIRST PART OF USER NAME
	SETZM	JBTUN1##(J)	;(-21) SECOND PART
	SETZM	JBTLIC##(J)	;(-20) LICENSE (NEEDS READ PROCESS DATE TO PROTECT PROCESS LICENSE)
	SETZM	JBTCMP##(J)	;(-15) CLOCK TIM
	SETZM	JBTCPU##(J)	;(-14) HIGH PART OF KCT
	SETZM	JBTBCS##(J)	;(-13) BREAK CHRS*SIZE
	SETZM	JBTCNK##(J)	;(-12) CONNECT TIME
	SETZM	JBTELP##(J)	;(-11) ELAPSED TIME*SIZE
	SETZM	JBTCOT##(J)	;(-10) CHRS OUT
	SETZM	JBTCIN##(J)	;(-7) CHRS IN
	SETZM	JBTSOT##(J)	;(-6) DISK BLOCKS OUT*SIZE
	SETZM	JBTSIN##(J)	;(-5) DISK BLOCKS IN*SIZE
	SETZM	JBTSER##(J)	;(-4) ENTER+RENAME*SIZE
	SETZM	JBTSLK##(J)	;(-3) LOOKUPS*SIZE
	SETZM	JBTDLK##(J)	;(-2) LOOKUPS
;*;	MOVES	JBTSTS##(J)	;(0) - JOB STATUS BITS (not cleared here)
	SETZM	JBTPPN##(J)	;(2) - PROJECT,PROGRAMMER NUMBER
;*;	MOVES	JBTNAM##(J)	;(3) - PROGRAM BEING RUN (not cleared ever)
	SETZM	JBTKCT##(J)	;(5) - KILO-CORE TICKS(JIFFIES*SIZE IN J)
	SETZM	JBTPRV##(J)	;(6) - PRIVILEGE BITS SET BY LOGIN
	SETZM	JBTRCT##(J)	;(17) - DISK BLOCKS READ BY JOB
	SETZM	JBTWCT##(J)	;(20) - DISK BLOCKS WRITTEN BY JOB
	SETZM	JBTNM1##(J)	;(31) - SIXBIT Username [1 for 6]
	SETZM	JBTNM2##(J)	;(32) - SIXBIT Username [7 for 6]
	SETZM	JBTAUN##(J)	;(33) - DEC: Job charge number [AUN]
	SETZM	JBTWCH##(J)	;(35) - FRAME WATCH BITS
	SETZM	JBTUPM##(J)	;(100)- User pages,Physical UPT page#
	SETZM	JBTST2##(J)	;(117)- Second job status word
;*;	JFCL	JBTFPN##(J)	;(136)- program run directory = (-25)
;*;	JFCL	JBTPRG##(J)	;(137)- program run filename  = (+03)
	SETZM	JBTPC##(J)	;(152)- I/O wait DDB/PC
	POPJ P,

EXTERNAL JOBN,FCONRQ,TPOPJ,TIMWAK
;SUBROUTINE TO STOP JOB, BUT NOT SET ERROR BIT, PUT TTY IN COMMAND MODE
;AND START TTY

HOLD0::	PUSHJ	P,CRLF		;PRINT EXTRA CRLF AFTER EXIT MESSAGE
HOLD1::	PUSHJ P,PRRSP3		;PRINT CRLF, [XXX], CRLF, CRLF, DOT
	PUSHJ P,TTYSTC		;START TTY AND LEAVE IN MONITOR MODE
	PJRST STOP1		;STOP JOB BUT DO NOT SET ERROR BIT
				;SO JOB CAN CONTINUE
;ROUTINE TO STOP JOB, SET ERROR BIT AND PRINT MESSAGE
;THEN ADD ^C<CRLF><CRLF><PERIOD>
;CALL:	MOVEI T1,ADR. OF MESSAGE
;	PUSHJ P,PHOLD

PHOLD::	PUSHJ P,CONMES##	;MOVE MESSAGE TO TTY OUTPUT BUFFER
	PFALL	HOLD
;ROUTINE TO STOP JOB, SET ERROR BIT,
;AND ADD "^C<CRLF><CRLF><PERIOD>

EXTERNAL TTYSTC,PRRSP3,TTKJOB,CRLF,PRRSP1

HOLD::	PUSHJ P,PRRSP1		;PRINT CRLF, [XXX], CRLF, CRLF, DOT
	PUSHJ P,TTYSTC		;MAKE SURE TTY STAYS IN MONITOR MODE
KJSTOP::MOVSI T1,JLOG
	TDNN T1,JBTSTS##(J)	;IS JOB LOGGED IN
	PUSHJ P,TTKJOB		;NO, MUST KILL JOB
				; AND START TTY TYPING OUT MESSAGE
				; FALL INTO ESTOP


;ROUTINE TO STOP USER AND FLAG AS ERROR STOP

ESTOP::	JUMPE J,CPOPJ##		;IS THIS ERROR IN JOB 0?
	MOVSI T1,JACCT		;NO, CLEAR ACCOUNTING BIT(IN CASE LOGGING
	HRRI T1,JACCT2		;ALSO USER SETABLE BIT
	ANDCAM T1,JBTSTS##(J)	;IN OR OUT) SO USER CAN USE CONTROL C
				; TO RECOVER
	MOVSI T1,JERR		;SET ERROR BIT IN JOB STATUS WORD
	IORM T1,JBTSTS(J)	;SO JOB CAN NOT CONTINUE(CONT COM.)
	PUSHJ	P,CBJERR##	;RELEASE INTERLOCK IF IN A CLUB.
				;FALL INTO STOP1
;ROUTINE TO STOP ANY JOB FROM BEING SCHEDULED
;CALL:
;	MOVE J,<JOB NUMBER>
;	PUSHJ P,STOP1
;	EXIT	;RETURN HERE IMMEDIATELY, IF CALLED FROM HIGHER PRIORITY PI
		;CHANNEL THAN CLK(LOWEST), OTHERWISE WHEN JOB IS RUNABLE
;CALLED FROM COMMAND DECODER ON CONTROL-C OR OTHER JOB STOPPING ERROR.

EXTERNAL PJBSTS,REQTAB,MAXQ,AVALTB,EPLLEN

STOP1::	MOVSI T1, RUN
	WRPI  LI.PIF		;DONE AT INTERUPT LEVEL HIGHER THAN DT LEVEL
	TDNN T1,JBTSTS(J)	;NO, IS RUN BIT OFF IN JOB STATUS WORD
	 JRST STOP1A		;YES
	TLO T1,CNTRLC		;TURN OFF. "USER HAS TYPED ^C WHILE STILL IN EXEC MODE."
	ANDCAM T1,JBTSTS(J)	;NO, SO CLEAR IT
	WRPI  LI.PIN
	LDB T1,PJBSTS		;GET JOB WAIT QUEUE CODE(IF ANY)
	CAIG T1,MAXQ		;DOES STATE HAVE Q ?
	SOSL REQTAB(T1)		;YES. REDUCE IT.
	 JRST STOP1A		;NO
	SOSGE AVALTB(T1)	;YES REDUCE  COUNT
	 SETZM AVALTB(T1)	;CLEAR AVAL FLAG IF NO ONE WAITING
STOP1A:	WRPI  LI.PIN		;MAKE SURE PI ON
	SKIPGE	JBTPRV(J)	;check for LogoutOnStop (PV.LOS)
	 PUSHJ	P,TTKJOB	; if set, kill frame
	CAME J,JOB		;NO, IS THIS JOB CURRENT USER
	 JRST REQUE		;NO, SET REQUE JOB FLAG
	SKIPL T1,JBTSTS(J)	;YES, RUN FLAG OFF?
	TLNN	T1,JERR		;YES. ERROR FLAG ON?
	 JRST	STOP2		;NO
	SETOM	SCHEDF##	;YES, FORCE RESCHEDULING EVEN IF JOB IN EXEC MODE
	JRST STOP2		;YES, MAKE CLK RESCHEDULE ANOTHER JOB
;ROUTINE TO REQUE JOB WHICH HAS HAD A COMMAND TYPED
;WHICH NEEDS CORE AND THE CORE IMAGE IS ON THE DISK.
;OR IS IN CORE AND HAS ACTIVE DEVICES.
;CALLED FROM COMMAND DECODER
;CALL:	MOVE J,JOB NO.
;	PUSHJ P,DLYCOM

DLYCOM::MOVSI	T1,CMWB		;SET COMMAND WAIT BIT
	TDNE	T1,JBTSTS(J)	;IS JOB ALREDY IN COMMAND WAIT?
	 POPJ	P,		;YES,JUST EXIT
	IORM	T1,JBTSTS(J)	;IN JOB STATUS WORD
	PJRST	REQUE

;ROUTINE TO PUT JOB IN NO CORE QUEUE

NOCORQ::MOVEI T1,NULQ##		;NO JOB NO. OR NO CORE QUEUE
	DPB T1,PJBSTS
	JRST REQUE
;ROUTINE TO SETUP MONITOR JOB TO RUN LATER AT UUO LEVEL
;CALLED BY COMMANDS WHICH MAY OR MAY NOT NEED TO
;RUN MONITOR JOB DEPENDING ON WHETHER JOB HAS CORE(KJOB,IJOB)
;TTY WILL REMAIN IN MONITOR MODE
;JOB MUST HAVE CORE ASSIGNED
;CALL:	MOVE J, JOB NUMBER
;	MOVEI T2,ADDR. OF MONITOR JOB TO BE RUN
;	PUSHJ P,MONJOB
;WHEN SCHEDULED TO RUN, MONITOR JOB MUST SET UP ITS OWN ACS

MONJOB::PUSHJ P,MSTART		;START WITH PC IN MONITOR
	JRST SETRUN		;SET TTY TO START JOB WHEN COMMAND RESPONSE
				; IS FINISHED AND KEEP TTY IN MONITOR MODE

;ROUTINE CALLED BY ONE FRAME TO SET UP A MONITOR JOB IN ANOTHER FRAME.
; CALL WITH T2 SET TO NEW PC, J CONTAINS FRAME NUMBER,
; %UPX CONTAINS C(J)'S CONTEXT PAGES.
; CALLER IS RESPONSIBLE FOR CHECKING
; THAT THE FRAME IS NOT ALREADY RUNNING.

MONJBX::PUSHJ	P,MXSTRT	;START WITH PC IN MONITOR
	PJRST	SETRUN		;AND MAKE SCHEDULER RUN HIM.

;ROUTINE TO SETUP ACS FOR MONITOR JOB STARTING AT UUO LEVEL
;SETS UP J, WITH JOB NO. AND P
;WITH PUSH DOWN LIST ADR. IN JOB DATA AREA
;USED BY KJOB,CORE 0,SAVE,GET,RUN,R,REASSIGN AND FINISH COMMANDS
;CALL:	MOVEI T2,MONITOR JOB STOP ADDRESS
;	JSP T1,MONSTR
;	RETURN WITH ACS P AND J SETUP

MONSTR::MOVE J,JOB		;CURRENT JOB NUMBER
	MOVSI P,-EPLLEN		;MINUS LENGTH OF SYSTEM PD LIST
	HRRI P,%UPT+UPTPDL-1	;FIRST LOC.-1 OF PD LIST
	TLZ	T2,PC.USR+PC.PUB ;MAKE SURE THESE ARE OFF (ONLY FOR
				; SAKE OF THE SIMULATOR, WHICH RUNS IN USER MODE)
				; AND RUNJOB DOES JSP T2,
	PUSH P,T2		;SAVE STOP ADRRESS
	PUSH P,T1		;SAVE RETURN ADDRESS
	JRST CLRINT		;AND GO CLEAR INTERUPT SYSTEM
;ROUTINE TO SET JOB STATE TO BE SCHEDULED TO RUN
;WITH SPECIFIED STARTING ADDRESS INCLUDING PC FLAGS
;CALLED ONLY WHEN JOB IN CORE AND AFTER JOB HAS BEEN
;SAFELY STOPPED IN ONE OF 3 STATES:
;1) PC IN USER MODE
;2) JOB IN A WAIT FOR SHARABLE DEVICE, OR IO WAIT
;3) JOB JUST ABOUT TO RETURN TO USER MODE FROM A UUO CALL
;CALL:	MOVE T2,STARTING PC
;	MOVE T1,OLD PC
;	MOVE J, JOB NUMBER
;	MOVE R,ADR. OF JOB DATA AREA WHICH MUST BE IN CORE
;	PUSHJ P,USTART(PC TO USER MODE),MSTART(PC TO MONITOR MODE)
;	RETURN HERE IMMEDIATELY

EXTERNAL TTYSET,TYCIOS,UPTACP,USRXIT,MAPUPS,CLRINT

USTART::TLNE T1,PC.USR		;IS IT IN USER MODE TOO?
	 JRST USTRT1		;YES.
	MOVE T1,%UPT+UPTPDL	;MUUO PC HAS LAST PC
	HRRI T1,-1(T1)		;SUBTRACT 1 FROM RIGHT HALF AND
				; PRESERVE LH PC FLAGS.
				; (RH=0 ON HALT 0 OR FIRST START)
USTRT1:	UMOVEM T1,JOBOPC	;STORE OLD PC FOR USER TO LOOK AT
	HLL T2,T1		;PRESERVE USER APR FLAGS
	TLO T2,PC.USR!PC.PUB	;MAKE SURE NEW PC IN USER MODE
	TLZ T2,37!PC.UIO	;MAKE SURE NO INDIRECT BITS OR INDEX FIELD
	PUSH P,T2		;STARTING PC
	JRST USRXIT

MSTART::PUSHJ	P,MAPUPS	;SET UP EXEC MAP.
	HRLI	T2,PC.UIO	;MAKE SURE PC IS EXEC MODE, IOT USER.
	MOVEM	T2,%UPS+UPTPC	;SAVE NEW PC
	MOVE T1,UPT+UPTACP	;RESET AC POINTER ON START
	MOVEM T1,%UPS+UPTACP
	MOVSI T1,UPSCLK		;CLOCK MUST RUN DURING MONJOB
	IORM T1,%UPS+UPTSTS
	MOVEI T1,UTRP		;CLEAR "TRAP" BIT FOR REE, DDT, ETC. AND
	HRLI T1,JERR+WTMASK+CNTRLC;CLEAR JOB ERR,WAIT CODE, TYPED ^C FLAG
	ANDCAM T1,JBTSTS(J)	;CLEAR ERROR AND WAIT STATUS BITS
	PUSHJ P,TYCIOS		;CLEAR IOW ON ALL TTY AND RMT DEVICES
	JRST TTYSET		;SET TTY STATE TO INITIAL COND.
				; TTYUSR OR TTYURC SHOULD BE CALLED
				; TO INDICATE WHETHER TTY TO USER OR EXEC MODE
				; AND THAT JOB IS TO RUN(RUN BIT =1) WHEN
				; MONITOR COMMAND RESPONSE FINISHES.
				; SEE SETRUN BELOW

MXSTRT:	HRLI	T2,PC.UIO	;MAKE SURE PC IS EXEC MODE, IOT USER.
	MOVEM	T2,%UPX+UPTPC	;SET THE PC
	MOVE	T1,UPT+UPTACP	;SETUP AC STACK POINTER AGAIN
	MOVEM	T1,%UPX+UPTACP
	MOVSI	T1,UPSCLK	;INITIAL STATE IS CLOCK RUNNING
	IORM	T1,%UPX+UPTSTS
	MOVE	T1,[JERR+WTMASK+CNTRLC,,UTRP]
	ANDCAM	T1,JBTSTS(J)
	PJRST	TYCIOS		;DON'T CALL TTYSET, MAY NOT BE A LINE


;ROUTINE TO SET JOB STATUS RUN BIT(RUN)
;CALLED BY SCANNER SERVICE WHEN TTY MONITOR COMMAND
;RESPONSE FINISHES.  THIS ACTION IS ENABLED BY CALLING
;TTYUSR, OR TTYURC IN SCNSER
;CALL:	MOVE J,JOB NUMBER
;	PUSHJ P,SETRUN

EXTERNAL RNQUNT,JBYQNT,CBCONT,ILWQ

SETRUN::LDB T1,PJBSTS		;GET JOB STATUS WAIT QUEUE CODE
	CAIN	T1,ILWQ		;SPECIAL CHECK
	PUSHJ	P,CBCONT	;FOR CLUBS.
	CAILE T1,MAXQ		;DOES JOB STATUS CODE HAVE A QUEUE?
	JRST SETR1		;NO
	AOSLE REQTAB(T1)	;ADD TO REQUEST COUNT
	JRST SETR1		;OTHERS WAITING?
	AOSG AVALTB(T1)		;MAKE AVAILABLE
	SETOM AVALTB(T1)	;FLAG AS JUST AVAILABLE, BECAUSE
				; NO JOB WAS USING DEVICE. SCHEDULER
				; WILL SCAN THIS QUEUE
SETR1:	MOVSI T1,RUN		;SET RUN BIT IN JOB STATUS WORD
	IORM T1,JBTSTS(J)
SETR2::	MOVE T1,@RNQUNT		;SET QUANTUM TIME TO RUN QUEUE QUANTUM
	DPB T1,JBYQNT		;RUN QUEUE QUANTUM

EXTERNAL QJOB
;PRESERVES ALL BUT T1

REQUE::	PUSHJ	P,WRSMAP##	;/WRS
	MOVSI	T1,JRQ		;MARK JOB TO BE REQUEUED WITH JRQ BIT
	TDNN	T1,JBTSTS(J)	;INCREMENT COUNT ONLY ONCE FOR EACH JOB
	 AOS	QJOB		;INCREMENT COUNT OF NO. OF JOBS WAITING TO BE REQUEUED
	IORM	T1,JBTSTS(J)	;SET REQUE BIT FOR SCHEDULER
	POPJ	P,
;ROUTINE TO PUT A JOB TO SLEEP AND WAKE UP AGAIN LATER
;CALLED AFTER CLOCK QUEUE REQUEST PUT IN BY UUO ROUTINE

SETSLP::MOVEI 16,SLPQ##		;SLEEP STATE CODE
	JRST SETSTT		;SET STATUS AND RESCHEDULE

;HERE AT CLOCK LEVEL WHEN CLOCK REQUEST TIMES OUT FOR SLEEP
;JOB NO. IN AC T1

WAKE::	MOVE J,T1		;JOB NO.
	PUSHJ P,TTSCLR##	;CLEAR TTY SLEEP CONDITIONS
	LDB T1,PJBSTS		;GET QUEUE CODE
	CAIE T1,SLPQ##		;IS JOB STILL SLEEPING?
	POPJ P,			;NO. RETURN TO CLOCK ROUTINE
	MOVEI T2,RNQ##		;READY TO SET IN RUN Q
	DPB T2,PJBSTS		;YES, STORE RUN QUEUE CODE
				; (CONTROL C, START CAN GET JOB OUT OF SLEEP)
	JRST SETR2

;ROUTINE TO CHANGE A CLOCK REQUEST. SEARCH FOR ONE WITH SAME
;JOB AND TYPE. IF FOUND CHANGE IT (IF TIME=0 DELETE). IF NOT FOUND
;INSERT ONE

CHGCLK::LDB T3,[POINT 12,T1,18]	;GET JOB NUMBER AND TYPE
	PUSH P,T1
	HRRZ T2,CLOCK
CHGCK1:	CAIN T2,CIPWTM
	JRST CLKADD		;NOT THERE, INSERT
	LDB T1,[POINT 12,(T2),18]
	CAME T1,T3
	SOJA T2,CHGCK1		;NOT CORRECT JOB OR TYPE
	POP P,T1
	TRNN T1,377777		;IS TIME 0?
	JRST CLKDEL		;YES, DELETE OLD REQ
	MOVEM T1,(T2)		;JUST CHANGE REQUEST
	POPJ P,

CLKDEL:	WRPI LI.PIF
	MOVE T1,@CLOCK
	SOS CLOCK
	MOVEM T1,(T2)
	WRPI LI.PIN
	POPJ P,

CLKADD:	POP P,T1
	TRNN T1,377777
	POPJ P,			;TIME=0, DO NOT ADD
	WRPI LI.PIF
	IDPB T1,CLOCK
	WRPI LI.PIN
	POPJ P,

CLKJOB::POINT	7,T1,18		;Byte pointer to set job/frame # into
				; arg for CHGCLK call
;; Clock queue args for setting/resetting hung DDB timer (SCNSER/COMCON)
TIMSET::BYTE (1) 1 (6) .SLHNG (5) 3 (7) 0 (1) 0 (16) ^D900
TIMRST::BYTE (1) 0 (6) 0      (5) 3 (7) 0 (1) 0 (16) 0
;ROUTINE TO WAIT FOR A SHARABLE DEVICE
;CALLED AT UUO LEVEL ONLY BY DEVICE SERVICE ROUTINES
;CALL:	AOSLE XXREQ		;ADD 1 TO SHARABLE DEVICE REQUEST COUNT
;				;IS DEVICE AVAILABLE?
;	PUSHJ P,XXWAIT	;NO, PUT JOB IN WAIT QUEUE
;	RETURN WHEN DEVICE AVAILABLE

;INITIALLY THE REQUEST COUNT IS -N, WHERE N IS THE
;NUMBER OF JOBS WHICH CAN USE THE SHARABLE DEVICE AT THE SAME TIME
;A REQUEST COUNT OF 0 MEANS THE MAXIMUM NO. OF JOBS ARE
;USING THE DEVICE, A POSITIVE NUMBER IS THE
;NUMBER OF JOBS WAITING IN THE SHARABLE DEVICE WAIT QUEUE
;NUMERIC ACS  16 AND 17 ARE PRESERVED SINCE THE NEW AC CONVENTION DEPENDS
;ON THEM BEING SAVED. NUMERIC ACS ARE USED RATHER THAN SYMBOLIC SO THAT
;THE PROPER ACS WILL BE SAVED IN THE DUMP ACS EVEN IF THE SYMBOLIC AC
;VALUES ARE CHANGED

PRINTF (<[Should HRLM F,JBTPC(J) for wait states that set up F to DDB]>)

SIWAIT::RIWAIT::MTWAIT::DAWAIT::PRWAIT::PSWAIT::
M2WAIT::CBWAIT::CAWAIT::AXWAIT::BPWAIT::
FCWAIT::ACWAIT::
DVWAIT:	MOVEM 16,%UPT+UPTXAC+16	;SAVE AC16 (SINCE IT IS A PRESERVED AC)
	MOVE 16,(P)		;GET ADR. OF CALLER
	MOVE 16,-2(16)		;GET AOSLE XXREQ INSTRUCTION
	SUBI 16,REQTAB		;COMPUTE WAIT-STATE QUEUE CODE
	AOS CNTTAB##(16)	;COUNT TIMES WAITED FOR QUE
	MOVEM 17,%UPT+UPTXAC+17	;SAVE AC17
SETSTT:	MOVE 17,JOB		;CURRENT JOB NO.
	DPB 16,PJBS3		;STORE IN JOB STATUS WORD
	MOVE 16,%UPT+UPTXAC+16	;RESTORE AC16
	JRST WSCHD1		;GO SCHEDULE ANOTHER AND RETURN TO CALLER
				; WHEN SHARABLE DEVICE BECOMES AVAILABLE
				; SEE CLOCK AND CLKCSS

PJBS1:	POINT JWSIZ,JBTSTS(P3),JWPOS ;BYTE POINTER TO JOB STATUS
				; WORD WAIT QUEUE CODE
PJBS3:	POINT JWSIZ,JBTSTS(17),JWPOS

;ROUTINE TO SET JOB TO RUN AFTER IT HAS BEEN STOPPED
;BECAUSE IT HAD TO WAIT FOR IO TO COMPLETE FOR SOME DEVICE
;EACH SERVICE ROUTINE AT INTERRUPT LEVEL
;CHECK EACH TIME IT FINISHED A TASK(BUFFERFUL)
;TO SEE IF THE JOB USING THE DEVICE HAS
;PREVIOUSLY CAUGHT UP WITH DEVICE AND HAS BEEN STOPPED
;CALL:	MOVE F,ADR. OF DEVICE DATA BLOCK
;	MOVE S,DEVIOS(F)	;GET DEVICE IO STATUS WORD FROM DDB
;	TLZE S,IOW	;IS JOB IN AN IO WAIT FOR THIS DEVICE?
;	PUSHJ P,SETIOD	;YES, GO FLAG JOB TO START UP AGAIN
;	RETURN
;SETS THE JOB QUEUE WAIT CODE TO WSQ IN JOB STATUS WORD.
;THE SCHEDULER THEN SEES THAT THIS JOB HAS ITS
;IO WAIT SATISFIED AND IS WAITING TO BE RUN AGAIN

PJBS2:	POINT JWSIZ,JBTSTS(T1),JWPOS ;LIKE PJBSTS BUT USES T1,NOT J

STTIOD::LDB T1,PJOBN##
	LDB T2,PJBS2
	CAIN T2,SWQ##
CLKNSQ:: STOPCD (.,JOB,CLKNSQ,,<Job not in SW queue>) ;;STTIOD+4
	MOVEI T2,TSQ##	;PUT IN TTY IOWAIT SATISFIED QUEUE
	AOS TSAVAL##
	JRST SETID1

SETIOD::LDB T1,PJOBN##
	LDB T2,PJBS2	;HIS CURRENT WAIT CODE
	CAIN T2,SWQ##
	 STOPCD (,XCT,CLKNSQ)	;Job not in SW queue  ;;SETIOD+4
	MOVEI T2,WSQ##	;PUT IN IO WAIT SATISFIED QUEUE
	AOS WSAVAL##		;INCR. NO. OF JOBS WITH IO WAIT!
				; SATISFIED. NON-ZERO WSAVAL WILL
				; CAUSE SCHED. TO SCAN FOR IO
				; SATISFIED JOB.
SETID1:	
	DPB T2,PJBS2		;IN JOB STATUS WORD
	EXTERN	WRSMP1		;/WRS
	PUSH	P,J		;/WRS
	MOVE	J,T1		;/WRS
	PUSHJ	P,WRSMP1	;/WRS - include even if no change
	POP	P,J		;/WRS
	MOVSI T2,JRQ		;SET JOB TO BE REQUEUED AT NEXT CLOCK TICK
	TDNN T2,JBTSTS(T1)	;IS REQUE BIT ALREADY ON?
	AOS QJOB		;NO, INCREMENT COUNT ONCE FOR EACH JOB
	IORM T2,JBTSTS(T1)	;SET REQUEUEING BIT FOR SCHEDULER
	SKIPE JOB		;IS NULL JOB RUNNING?
	POPJ P,			;NO LET OTHER JOB RUN TILL SCHEDULER IS TRAPPPED TO
;ROUTINE TO CAUSE CLK ROUTINE TO RESCHEDULE
;CALLED AT ANY LEVEL
;CALL:	PUSHJ P,STOP2	
;	RETURN IMMEDIATELY EXCEPT IF AT UUO LEVEL
;	IF AT UUO LEVEL, RETURN WHEN JOB IS RUNABLE AGAIN

STOP2:	WRPI LI.PIF		;PREVENT CLOCK INTERRUPT DURING STOP2 CODE
	SETOM CLKFLG##		;SET FLAG TO INDICATE CLK INTERRUPT
				; EVEN THOUGH CLK INTERRUPT IS NOT A TIME INTERRUPT
	WRPI PICLK##		;TURN PI BACK ON AND REQUEST INTERRUPT TO
				; CLK PI CHANNEL(LOWEST PRIORITY CHANNEL)
	CONSZ PI,177B27		;ANY INTERUPTS IN PROGRESS?
	 POPJ P,		;YES, EXIT IMMEDIATELY
	PUSH P,T1
STOP3:	RDPI T1			;READ STATUS OF PI
	TLNE T1,CLKBIT		;IS THERE A REQUEST WAITING ON CH7?
	 JRST STOP3		;YES, WAIT FOR IT TO HAPPEN
	JRST TPOPJ		;NO, EXIT
;ROUTINE TO WAIT TILL DEVICE CATCHES UP WITH USER AND BECOMES INACTIVE
;CALLING SEQUENCE
;     PUSHJ P, WAIT1
;     EXIT	  ALWAYS RETURNS HERE

;IF THE DEVICE IS INACTIVE (IOACT=0), RETURNS TO EXIT. OTHERWISE, SETS
;IOW:=1 AND ENTERS WAIT UNLESS IOACT BECOMES ZERO BEFORE THE
;JUMP IS MADE, IN WHICH CASE IT SETS IOW:=0 AND RETURNS TO EXIT.
;ON LEAVING THE WAIT STATE, RETURNS TO EXIT.
;WAIT1 DESTROYS S, P1, P2, AND P3.  ALL OTHER ACS ARE SAFE.
;THIS ROUTINE PREVENTS THE STATE IOACT=0 AND IOW=1 FROM OCCURING
;CALLING SEQUENCE
;     PUSHJ P, WSYNC
;     EXIT             ALWAYS RETURNS HERE
;SETS IOW:=1 AND ENTERS WAIT ROUTINE. RETURNS TO EXIT WHEN IOACT=0.

WAIT1::	MOVE S,DEVIOS(F)
	TRNN S, IOACT		;IS DEVICE ACTIVE? (IOACT=1?)
	POPJ P,			;RETURN
	PUSHJ P,WSYNC		;WAIT
	JRST WAIT1
;WSYNC IS CALLED TO WAIT UNTIL SETIOD IS CALLED BY INTERRUPT SERVICE ROUTINE
;IE  UNTIL CURRENT BUFFER ACTIVITY IS COMPLETED
;CALLED ONLY FROM UUO LEVEL
;CALL:	MOVE F,ADR. OF DEVICE DATA BLOCK
;	PUSHJ P,WSYNC
;	RETURN IMMEDIATELY IF DEVICE IS INACTIVE
;	RETURN WHEN DEVICE FINISHES NEXT BUFFER IF IT IS ACTIVE
;WSYNC DESTROYS S, P1, P2, AND P3.  ALL OTHER ACS ARE SAFE.

EXTERNAL IOWQ,TIOWQ,MBWQ,DEYCLS,ERRHDV

WSYNC::	MOVSI S,IOW		;SETUP DEVICE IO WAIT BIT
	LDB P3,DEYCLS		;DEVICE CLASS CODE
	MOVE P1,CLSQUE(P3)	;GET QUE FOR THIS CLASS

	MOVE P3,JOB		;CURRENT JOB NO.
	MOVEI P2,IOACT		;DEVICE ACTIVE BIT
	WRPI  LI.PIF		;TURN PI OFF
	TDNN P2,DEVIOS(F)	;IS THE DEVICE ACTIVE?
	JRST WSYNC1		;NO
	IORM S,DEVIOS(F)	;YES, SET DEVICE IO-WAIT BIT
				; AND SETUP S FOR RETURN WHEN WAIT SATISFIED
	MOVSI P2,IOHNG		;CLEAR HUNG BIT
	ANDCAM	P2,DEVIOS(F)
	DPB P1,PJBS1		;SET JOB WAIT STATE CODE
				; IN JOB STATUS WORD
	WRPI  LI.PIN		;TURN PI ON
	PUSHJ P,WSCHED		;CALL SCHEDULER TO FIN ANOTHER JOB TO RUN
				; RETURN WHEN NEXT BUFFERFUL IS FINISHED
				; WITH ACS 0-14 OCTAL RESTORED
				; RETURN WHEN IO-WAIT FINISHED
WSYNC1:	WRPI  LI.PIN
	ANDCAB S, DEVIOS(F)	;CLEAR DEVICE IO-WAIT BIT
	TLZN	S,IOHNG		;DID DEVICE TIME OUT?
	POPJ P,
	ANDCAM P2,DEVIOS(F)	;CLEAR HUNG BIT AND
	JRST	ERRHDV		;CALL ERRCON TO EXIT THE JOB.

CLSQUE:	EXP 	MBWQ,TIOWQ,0,IOWQ

	$END	(CLK)		;End of CLOCK1 (CLKLIT: CLKEND:)

      @