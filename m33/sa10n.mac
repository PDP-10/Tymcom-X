TYMVER=1
SUBVER=A

DEFINE	NAME (X,Y)<
TITLE SA10 - DIAGNOSTIC FOR SYSTEMS CONCEPTS SA-10 IBM-TO-DEC SUBSYSTEM ADAPTOR	VER X,Y>

LALL

NAME	\TYMVER,\SUBVER

LOC	137
TYMVER,,SUBVER
SALL

BASE==0	;DEFAULT START OF STATUS BLOCK
IDEV==0	;DEFAULT ADDRESS OF DISK CONTROLLER
IFNDEF NPACKS,NPACKS==^D32	;MAX # OF DRIVES ON DISK CONTROLLER
TUNIT==0	;DEFAULT ADDRESS OF TAPE CONTROLLER
SA0==274	;DEFAULT DEVICE NUMBER OF SA-10
EPT==0
UPT==0
LPDL==100	;LENGTH OF PDL
MAPPG==777	;EXEC PAGE FOR MAPPED ADDRESSING
LNKBUG==-1	;NONZERO TO KLUDGE AROUND LINK'S INABILITY TO LOAD
		;ABSOLUTE ASSEMBLIES CORRECTLY
IFN LNKBUG,<LNKORG==140	;LINK'S INITIAL L.C.>
LNPAKS==^D36-^L<NPACKS-1>

A=1
B=2
C=3
D=4
E=5
F=6
G=7
H=10
I=11
J=12
K=13
L=14
DD=15
BF=16		; BUSY FLAGS, FOR LIGHT WATCHERS. B0-7 MEAN DRIVE
		;  0-7 WAITING FOR DEVICE END. RH IS MOST RECENT INT DV
P=17		; PUSHDOWN POINTER

IFNDEF CV,<
CV==1>		; 0 FOR B, 1 FOR C (HARDWARE POINTER LAYOUTS)
IFLE CV,<
CNTSFT==2>	;SHIFT IN LH FOR COUNT
IFG CV,<
CNTSFT==6>	; ..
APRCH==1	;PI CH FOR TIME, PAR ERR, AND NXM
SA0CH==2	;PI CHANNEL IN DISK ROUTINE
NBF==20		; # OF BYTES IN RING BUFFER (FIFO) IN EACH CHANNEL
NRETRY==^D8	; TIMES TO REREAD A CORRECTABLE DATA CHECK
NBADSP==100	; NUMBER OF BADSPOTS TO REMEMBER

EXTERN CONFIG	;CONFIG IS WITH UC
INTERN CV	;CHECK AGREEMENT WITH MICROCODE
;MACROS FOR WORD POINERS DEPENDING ON WHICH KIND OF SA10 (B OR C)

IFLE CV,<
	DEFINE IOW(CT,ADR)
	<-CT*4,,ADR>
	DEFINE IOWC(CT,ADR)
	<400000-CT*4,,ADR>>
IFG CV,<
	DEFINE IOW(CT,ADR)
	<-CT*100,,ADR>
	DEFINE IOWC(CT,ADR)
	<400000-CT*100,,ADR>>

;BITS FOR CONO
RSTSA==400000	;RESET WHOLE SCHMEER, START CLOCK
CLMERR==200000	;CLEAR MEMORY ERROR FLAGS
SASTEP==1000	;STOP CLOCK IF RUNNING; STEP IT IF STOPPED
SACGO==1040	;START CLOCK
RSTCH==300	;RESET CHANNEL SPECIFIED BY 10 AND 20 BITS
CLBSY==400	;CLEAR BUSY FLAG OF CHANNEL . . .
STBSY==440	;SET BUSY FLAG OF CHANNEL . . .
CLSRQ==500	;CLEAR STATUS REQUEST FLAG OF CHANNEL . . .
STSRQ==540	;SET STATUS REQUEST FLAG OF CHANNEL . . .
CLSTF==600	;CLEAR STATUS FLAG OF CHANNEL . . .
STSTF==640	;SET STATUS FLAG OF CHANNEL . . .
CLPIE==700	;CLEAR PI ENABLE OF CHANNEL . . .
STPIE==740	;SET PI ENABLE OF CHANNEL . . .

;CERTAIN OF ABOVE BITS ALSO SELECT WHAT DIAGNOSTIC WORD WILL
;BE READ BY THE NEXT DATAI TO BE EXECUTED, AS FOLLOWS:

RDCCI==0	;READ CHANNEL SELECTED (BITS 16, 17); CON-
		;TENTS OF CBUS (BITS 18-25); MICRO-PROGRAM
		;COUNTER (BITS 26-35)
RDMA==10	;READ MEMORY ADDRESS REGISTER (BITS 16-35)
RDMBL==20	;READ CHANNEL REFERENCING MEMORY (BITS 16,
		;17); LEFT HALF OF MEMORY BUFFER (BITS 18-
		;35).
RDMBR==30	;READ PARITY BIT OF MEMORY BUFFER (BIT 17);
		;RIGHT HALF OF MEMORY BUFFER (BITS 18-35)
RDCONI==40	;READ THE "CLOCK RUNNING" BIT (BIT 16); THE
		;"MEMORY SUBROUTINE BUSY" BIT (BIT 17); AND
		;THE SAME DATA SENSED BY CONI (BITS 18-35)
;CONTINUED ON NEXT PAGE

RDBITS==50	;READ SOME MISCELLANEOUS BITS:
		;BITS 16 AND 17 SPECIFY WHICH CHANNEL IS
		;USING THE MEMORY
	WRRQ==400000	;CURRENT MEM CYCLE IS A WRITE
	MUXACK==200000	;ACKNOWLEDGE FROM MEMORY PORT
	MEMACK==100000	;ACKNOWLEDGE FROM MEMORY
	MBUSDN==40000	;MEMORY BUS FINISHED
	MDNSYN==20000	;MEMORY DONE SYNC
	RDDIAG==10000
	IOFWR==4000
	CHRST==2000
	RESET==1000
	BRANCH==400	;THE MICRO-INSTRUCTION WHICH IS
			;ABOUT TO BE EXECUTED IS GOING TO BRANCH
;LOW 3 BITS ARE PI CHANNEL ASSIGNMENT

;BITS FOR CONI, CONSZ, CONSO
PIRQ==400000	;THIS SA-10 IS REQUESTING AN INTERRUPT
PARERR==200000	;PARITY ERROR IN SOME WORD (COMMAND OR
		;DATA) READ FROM MEMORY
NXM==100000	;SA-10 TRIED TO REFERENCE NON-EX MEMORY
PIE0==40000	;PI ENABLE FLAG FOR CHANNEL 0
PIE1==20000	; . . . CHANNEL 1
PIE2==10000	; . . . CHANNEL 2
PIE3==4000	; . . . CHANNEL 3
BSY0==2000	;BUSY FLAG FOR CHANNEL 0
BSY1==1000	; . . . CHANNEL 1
BSY2==400	; . . . CHANNEL 2
BSY3==200	; . . . CHANNEL 3
STF0==100	;STATUS FLAG FOR CHANNEL 0
STF1==40	; . . . CHANNEL 1
STF2==20	; . . . CHANNEL 2
STF3==10	; . . . CHANNEL 3
;LOW 3 BITS ARE PI CHANNEL ASSIGNMENT

;DEFS FOR TAPE
TRECL==2000	; RECORD LENGTH ON TAPE

DEFINE LOOP(LOC)
<	XCT	RDSWS		;GO GET SWITCHES
	TLNN	DD,40000
	JRST .+4
	PUSHJ P,CHKCNC
	JRST CI0
	JRST LOC
>

DEFINE SLOOP
<	PUSHJ P,CHKCNC
	JRST CI0
>
DEFINE MCONO(DEV,DAT)
<	MOVEI DD,DAT
	XCT DCONO
>

DEFINE MCONSZ(DEV,DAT)
<	XCT DCONI
	TRNE DD,DAT
>
DEFINE MCONSO(DEV,DAT)
<	XCT DCONI
	TRNN DD,DAT
>
DEFINE MDATSZ(DEV,DAT)
<	XCT DDATAI
	TRNE DD,DAT
>
DEFINE MDATSO(DEV,DAT)
<	XCT DDATAI
	TRNN DD,DAT
>
DEFINE MDATAO(DEV,DAT)
<	MOVE DD,DAT
	XCT DDATAO
>

DEFINE MDATAI(DEV,DAT)
<	XCT DDATAI
	MOVEM DD,DAT
>

DEFINE MCONI(DEV,DAT)
<	XCT DCONI
	MOVEM DD,DAT
>

DEFINE PIRP(A,B,C)<IRP B,<A'B'C>>

;SOME 3330 COMMANDS
SEEK==7
SCHIDE==61
RDDATA==6
WRDATA==5

;V CODE PARAMETERS
VRWL==1461	;RECORD LENGTH (WDS) FOR RELIABILITY TEST

;TESTER COMMANDS
SENSE==4
NOP==3
RFIX==2
DSCI==11
PARE==12
WAIT==7
REST==17
RETRYR==16
WPAT==1
RPAT==6
CPAT==5
CPATS==15
SETCT==13
;PROCESSOR AND BASIC I/O DEFS

;LINEPRINTER DEFS.
LPT==124		;DEVICE CODE

;KI10 DEFS
IP.50H==(1B6)	;POWER LINE IS 50 HERTZ
IP.MNM==(1B7)	;MARGIN ENABLE SWITCH IS ON

;KL10 DEFS
OPDEF SWPUA[701540,,]	;SWEEP CACHE, UNLOADING ALL PAGES
OPDEF APRID[BLKI APR,]	;READ APR SERIAL #, MICROCODE VERSION, ETC.

;DTE AND KL10 CONSOLE PROG DEFS
DTE==200	;DEVICE CODE OF DTE
 TO11DB==1B22	;DOORBELL TO KICK 11
DTEEPW=144	;EXAMINE PROTECTION WD
DTEFLG=444	;DONE FLAG FOR CMDS TO 11
DTEF11=450	;DATA FROM 11
DTECMD=451	;COMMAND TO 11
 .DTMTO==10B27	;"MONITOR" TYPEOUT
 .DTMMC==11B27	;SET "MONITOR CONSOLE MODE" (WHATEVER THAT IS)
 .DTRSW==7B27	;TELL PDP11 WE WANT THE SWITCHES
DTEMTD=455	;FLAG FOR TYPEOUT COMPLETED
DTEMTI=456	;FLAG FOR TYPEIN PRESENT (IN DTEF11)

;KL10 INTERVAL TIMER DEFS
TIM==20		;INTERVAL TIMER DEV CODE
 ;CONO BITS
 TO.CIT==1B18	;CLEAR TIMER (DOESN'T CLEAR DONE)
 TO.SIT==1B21	;START TIMER (STOP IF 0)
 TO.CTD==1B22	;CLEAR TIMER DONE
 TO.PRF==7777	;PERIOD REGISTER
 ;CONI BITS
 TI.INF==7777B17;TIMER REGISTER (COUNTS @ 100KHZ MOD PERIOD)
 TI.TIO==1B21	;TIMER ON
 TI.ITD==1B22	;TIMER DONE (SET EACH PERIOD)
 TI.TOV==1B23	;TIMER OVERFLOW (????)
 TI.PRF==7777	;PERIOD REGISTER
MTR==24		;ACCOUNTING METER DEV CODE
 ;NOTE THIS CONTAINS PIA FOR INTERVAL TIMER, OTHER BITS FOR ACCOUNTING
.EPTII==514	;INTERRUPTS ALWAYS USE EPT LOC 514 REGARDLESS OF CHANNEL
;TOPS-10 FILE SYSTEM DEFS
BLKSIZ==200	;SIZE OF DATA RECORD (WDS)

;HOME BLOCK DEFS
LBNHOM==1	;LOGICAL BLK # OF FIRST HOME BLOCK
LB2HOM==^D10	;SAME FOR SECOND

;BAT BLOCK DEFS
LBOBAT==1	;OFFSET FROM HOME BLOCKS TO BAT BLOCKS
BATBK0==LBNHOM+LBOBAT
BATBK1==LB2HOM+LBOBAT
 ;WORDS IN BAT BLOCKS
 BAFNAM==0	;SHOULD HAVE SIXBIT /BAT/
 BAFFIR==1	;AOBJN PNTR TO AREA FOR ENTRIES
 BAFNBS==2	;<# BAD BLKS (DIAG)>B8+<# BAD REGIONS (DIAG)>B17+<DEV CODE>B26
 BAFCNT==3	;# NEW REGIONS ADDED BY MONITOR
 BAFREG==4	;BEGINNING OF BAD REGION TABLE
  ;BAT ENTRY DEFS
  BAFNBB==0	;<# BAD BLKS-1>B8+<1_UNIT #>B17+<KONT #>B20+<APR SERIAL>B35+
   ;BITS IN WD 0
   BAPNTP==1B21	;ON FOR NEW TYPE ENTRY
  BAFELB==1	;OLD FORMAT (BAPNTP=0): LH ERROR "CONI", RH FIRST LBN
		;NEW FORMAT (BAPNTP=1): BITS 0-2 FORMAT VERSION
   BAFVUN==0	;INTERNAL CODE FOR UNKNOWN VERSION
   BAFVOL==1	;INTERNAL CODE FOR OLD FORMAT
   BAFVOF==2	;OFFSET BETWEEN NEW FORMAT VERSION & INTERNAL VERSION CODE
   BAFVMX==2	;HIGHEST (INTERNAL) VERSION IMPLEMENTED
		;VERSION 0: BITS 3-5 ERROR TYPE FLAGS, BITS 6-35 FIRST LBN
   BAPOTR==(1B3)	;ERROR OTHER THAN DATA OR HEADER
   BAPDTR==(1B4)	;DATA ERROR
   BAPHDR==(1B5)	;HEADER ERROR
 BAFCOD==BLKSIZ-2	;WORD WITH CODE FOR CONSISTENCY CHECK
  CODBAT==606060	;PROPER CONTENTS OF BAFCOD
 BAFSLF==BLKSIZ-1	;SHOULD CONTAIN LBN OF THIS BAT BLK
 MBRMAX==BAFREG-BAFCOD	;- MAX # WDS FOR ENTRIES

BLKSKP==BATBK1+1	;BLOCKS TO AVOID CLOBBERING
LOC 30000		;ABS ASSEMBLY FOR NICER LISTING

;LOW CORE TRANSFER VECTOR
	JRST BEGIN	;NORMAL ENTRY
	JRST DDTQ
	JRST CI0	;REENTER COMMAND INTERPRETER

;HERE TO RUN DATA RELIABILITY TEST UNTIL KEY STRUCK
VREL:	MOVE P,[-LPDL,,PDL-1]
VREL1:	PUSHJ P,VR	;DO THE TEST ONCE
	PUSHJ P,CHKCNC
	JRST DDT	;STOP WHEN CHAR STRUCK
	JRST VREL1	;AND AGAIN

;CHECK DATA TRANSFER TIMING
VTIME:	SETZM VTIMEC
	MOVE P,[-LPDL,,PDL-1]
	MOVNI A,12
	MOVEM A,BEGINC
VTIM1:	PUSHJ P,VR
	AOSGE BEGINC
	JRST VTIM1
	MOVE E,VTIMEC
	MOVEI C,[ASCIZ /
COUNT=%E
/]
	PUSHJ P,STYO
	JRST DDT

VTIMEC:	0
;HERE TO RUN THROUGH THE TESTS
V0:	MOVE P,[-LPDL,,PDL-1]
V1:	MOVEI A,[ASCIZ /*SYSTEM RESET /]
	MOVEM A,VTTPTR
	MCONO SA0,RSTSA
	PUSHJ P,VSTAT1	;STATUS WD 1 TO D
	CAMN D,[400526,,520000]
	JRST V2	;OK
V1X:	MOVEI C,[ASCIZ /STATUS=%D/]
	JRST VEPNT

V2:	MOVEI A,[ASCIZ /*ADR COMPL /]
	MOVEM A,VTTPTR
	MOVEI E,0	;WILL RUN THROUGH ADDRESSES
V2A:	DPB E,[141000,,V2P]
	DPB E,[141000,,V2V]
	SETCM D,E	;COMPLEMENT OF ADDRESS EXPECTED
	DPB D,[241000,,V2V]
	MOVEI A,V2P
	PUSHJ P,VRUN	;RUN CHAN PGM
	CAMN D,V2V	;CHECK RESULTING STATUS WD 1
	JRST V2B	;IF OK
	MOVEI C,[ASCIZ /SENT %E, STATUS %D/]
	JRST VEPNT
V2B:	XORI E,377	;CHANGE LOTS OF BITS
	TRNE E,200
	JRST V2A
	CAIN E,124	;AVOID ADDRESSES HEX 55 AND AA
	ADDI E,1
	CAIE E,177
	AOJA E,V2A
V3:	MOVEI A,[ASCIZ /*SELECT ERR /]
	MOVEM A,VTTPTR
	MOVEI E,252	;AA
	DPB E,[141000,,V2P]	;INTO THE NOP CHAN PGM
	MOVEI A,V2P
	PUSHJ P,VRUN
	CAME D,[300002,,520000]	;SEL ERR?
	JRST V1X	;IF NOT
V4:	MOVEI A,[ASCIZ /*RFIX /]
	MOVEM A,VTTPTR
	MOVEI A,V4P
	PUSHJ P,VRUN
	CAME D,[61250000]
	JRST V1X
	MOVEI F,0
V41:	MOVE D,V4DAT(F)
	MOVE E,V4TAB(F)
	CAMN D,E
	JRST V42
	MOVEI C,[ASCIZ /WORD INDEX %F SHOULD BE %D, READ %E/]
	JRST VEPNT
V42:	CAIE F,77
	AOJA F,V41
V5:	PUSHJ P,VR	;ONE PASS OF DATA RELIABILITY
V6:	MOVEI A,[ASCIZ /*DSCI /]
	MOVEM A,VTTPTR
	MOVEI A,V6P
	PUSHJ P,VRUN
	MOVE E,[220001,,250000]
	PUSHJ P,VV6	;CHECK TWO SUCCESSIVE STATUSES
	MOVEI A,[ASCIZ /*SEL RES /]
	MOVEM A,VTTPTR
	MCONO SA0,@SELRSC
	PUSHJ P,VSTAT1
	MOVE E,[220526,,520000]
	PUSHJ P,VV6	;CHECK TWO STATUSES AGAIN
V7:	MOVEI A,[ASCIZ /*PARE /]
	MOVEM A,VTTPTR
	MOVEI A,V7P
	PUSHJ P,VRUN
	CAME D,[40061,,250000]	;BUS IN PAR ERR
	JRST V1X
V8:	MOVEI A,[ASCIZ /*SHORT COUNT /]
	MOVEM A,VTTPTR
	MOVEI A,V8P1
	PUSHJ P,VRUN
	CAME D,[4061,,250000]	;LENGTH ERROR
	JRST V1X
	MOVE D,@CBASE+2	;SECOND STATUS WORD
	TLNN D,777700
	JRST V85
	MOVEI F,0
V84:	MOVEI C,[ASCIZ /RESIDUAL CT=%D, SHOULD BE %F/]
	JRST VEPNT
V85:	MOVEI A,[ASCIZ /*LONG COUNT /]
	MOVEM A,VTTPTR
	MOVEI A,V8P2
	PUSHJ P,VRUN
	CAME D,[4061,,250000]	;LENGTH ERR
	JRST V1X
	MOVE D,@CBASE+2
	LDB E,[301400,,D]
	MOVEI F,7777
	CAME E,F
	JRST V84	;IF ERROR
V9:	MOVEI A,[ASCIZ /*METERING UP /]
	MOVEM A,VTTPTR
	MOVEI A,VRUNSP
	PUSHJ P,VRUNA
	MOVE A,VSENSE
	TLNN A,4	;METERING BIT
	JRST VEPNT0	;COMPLAIN
	MOVEI A,[ASCIZ /*METERING DOWN /]
	MOVEM A,VTTPTR
	MOVEI D,50000
	SOJG D,.	;30 MS DELAY
	SETZM VSENSF
	MOVEI A,@CBASE
	SETOM VRUNDF
	PUSHJ P,VRUN2
	MOVE A,VSENSE
	TLNE A,4	;SHOULD BE OFF
	JRST VEPNT0	;IF FAILED TO GO DOWN
V10:	MOVEI A,[ASCIZ /*BLOCK MUX START /]
	MOVEM A,VTTPTR
	MOVE A,[V10PP,,V10P]
	BLT A,V10P1-1
	MOVE A,[400000,,V10P]
	PUSHJ P,VRUN
	CAME D,[300002,,520000]	;SEL ERR ON AA
	JRST V1X
	MOVE D,V10P+1
	CAMN D,[BYTE (8)125(4)16(24)V10P1+1]
	JRST V105
	MOVEI C,[ASCIZ /WAIT STATE %D/]
	JRST VEPNT
V105:	MOVE D,V10P+2
	CAMN D,[BYTE (8)252(4)17(24)V10P2+1]
	JRST V11
	MOVEI C,[ASCIZ /STOP STATE %D/]
	JRST VEPNT

V11:	MOVEI A,[ASCIZ /*BLOCK MUX RESTART /]
	MOVEM A,VTTPTR
	MOVEI G,0	;DEV ADDR
V110:	DPB G,[341000,,V11PAD]
	MOVE A,[V11PBP,,V11PB]
	BLT A,V11PBZ-1
	DPB G,[341000,,V11PB+10]
	DPB G,[341000,,V111W]
	DPB G,[141000,,V11PBN]
	MOVSI A,60	;CHAN END ,DEV END
	DPB G,[141000,,A]
	MOVEM A,V111V
	MOVEI C,1
	MOVEI B,V11PB
V111:	MOVE F,G
	XOR F,C
	DPB F,[341000,,0(B)]
	LSH C,1
	CAIGE C,400
	AOJA B,V111
	MOVEI A,V11PA
	PUSHJ P,VRUNA
	MOVE A,[400000,,V11PB]
	MOVEM A,@CBASE
	SETZM VSENSF
	MCONO SA0,@CLSTFC	;CLEAR STATUS FLAG
	PUSHJ P,VSTAT1	;WAIT FOR STATUS
	CAME D,V111V
	JRST V1X
	MOVE D,V11PB+10
	CAMN D,V111W
	JRST V118
	MOVEI C,[ASCIZ /DEV LIST WD %D/]
	JRST VEPNT
V118:	CAIGE G,377
	AOJA G,V110
V12:	MOVEI A,[ASCIZ /*RETRY READ /]
	MOVEM A,VTTPTR
	SETZM V12PD
	MOVE A,V12PP
	MOVEM A,V12PT
	MOVE A,[400000,,V12PT]
	PUSHJ P,VRUNA
	MOVE D,V12PD
	CAMN D,[BYTE (8)247]
	JRST V13
	MOVEI C,[ASCIZ /%D/]
	JRST VEPNT
V13:	JRST DDT
;HERE TO SET UP TABLES FOR DATA RELIABILITY TEST (DO ONCE)
VPAT:	MOVE P,[-LPDL,,PDL-1]
	MOVEI A,4
	MOVEM A,VPATC1
	MOVEM A,VPATC2
	MOVE C,[441000,,VDT]
	MOVE D,[441000,,VDBT]
	MOVE E,[441000,,VDWT]
	MOVE F,[441000,,VDNT]
	MOVE G,[441000,,VDCT]
	MOVEI A,VRWL*5	;# OF BYTES TO GENERATE
	MOVEM A,VPATC0
VPAT1:	CAMN C,[41000,,VDTE-1]
	HRRI C,VDT-1	;LOOP THROUGH VDT REPEATEDLY
	ILDB A,C	;GET BYTE
	IDPB A,D	;PUT IN BYTE-MODE TABLE
	SOSGE VPATC1
	JRST VPAT10	;FOR BYTE #4
	IDPB A,E	;PUT IN WORD-MODE TABLE
	IDPB A,F	;PUT IN NATURAL-MODE TABLE
VPAT2:	SOSGE VPATC2
	JRST VPAT20	;FOR BYTES #4, #9
	IDPB A,G	;PUT IN TAPE-MODE TABLE
VPAT3:	SOSLE VPATC0
	JRST VPAT1	;ON TO NEXT BYTE
	SETCM A,VDNT-VDCT(G)
	MOVEM A,VDNT-VDCT+1(G)
	JRST DDT

VPAT10:	MOVEI B,1(E)	;NEXT ADDR IN WORD-MODE TABLE
	HRLI B,400
	DPB A,B	;SECOND HALF OF BYTE
	SUBI B,1
	LSH A,-4
	DPB A,B	;1ST HALF OF BYTE
	HRLI F,400
	DPB A,F	;1ST HALF TO NATURAL-MODE TABLE
	ADDI F,1
	HRLI F,400400
	LDB A,C	;GET BYTE BACK
	DPB A,F	;2ND HALF, NATURAL MODE
	HRLI F,401000
	MOVEI B,10
	MOVEM B,VPATC1
	JRST VPAT2
VPAT20:	HRLI G,400
	DPB A,G
	HRLI G,1000
	MOVEI B,4
	MOVEM B,VPATC2
	JRST VPAT3

VDT:	BYTE (8)200,100,40,20
	BYTE (8)10,4,2,1
	BYTE (8)200,100,40,20
	BYTE (8)10,4,2,1
	BYTE (8)177,277,237,257
	BYTE (8)267,274,275,276
	BYTE (8)177,277,237,257
	BYTE (8)267,274,275,276
	REPEAT 4,<BYTE (8)0,377,0,377>
	REPEAT 4,<BYTE (8)252,125,252,125>
	VQ==0
	VQS==2
	REPEAT 2,<
		REPEAT 2,<
			REPEAT 4,<
				BYTE (8)VQ,<377-VQ>,<VQ+1>,<376-VQ>
				VQ==VQ+VQS
				>
			VQ==VQ+VQS+VQS+VQS
			VQS==-VQS
			>
		VQ==20
		>

VDTE:
VDWT:	BLOCK 2001
VDBT:	BLOCK 2001
VDNT:	BLOCK 2001
VDCT:	BLOCK 2001
VDAT:	BLOCK 2001
;SUBROUTINE FOR DATA RELIABILITY TEST
VR:	MOVEI A,[ASCIZ /DATA PATTERN WRITE /]
	MOVEM A,VTTPTR
	MOVEI A,VRP1
	PUSHJ P,VRUNA
	MOVEI A,[ASCIZ /DATA PATTERN READ /]
	MOVEM A,VTTPTR
	MOVEI A,VRP2
	PUSHJ P,VRUNA
	MOVSI E,-40
	HRRI E,VDT
	MOVEI C,[ASCIZ /INITIAL BYTE MODE /]
	PUSHJ P,VRV	;VERIFY THE TABLE
VR1:	MOVEI G,0	;MODE #
VR2:	MOVEI A,[ASCIZ /DATA PATTERN READ /]
	MOVEM A,VTTPTR	;NEEDED IN LOOP
	MOVE A,VR1TR(G)	;RPAT CHAN PGM ADDR
	PUSHJ P,VRUNA	;DO THE RPAT
	MOVSI E,-VRWL
	HRR E,VR1TA(G)	;TABLE PTR
	MOVE C,VR1TT(G)	;TEXT PTR
	PUSHJ P,VRV	;VERIFY DATA
	MOVE A,VR1TX(G)	;TEXT PTR
	MOVEM A,VTTPTR
	MOVE A,VR1TC(G)	;CPAT CHAN PGM ADDR
	PUSHJ P,VRUNA	;DO THE CPAT
	CAMGE G,VGMODE
	AOJA G,VR2
	POPJ P,	;DONE ALL MODES

VRV:	MOVEI D,0
	MOVEM C,VRVT	;TEXT PTR
VRV1:	MOVE F,VDAT(D)	;DATA AS READ
	CAME F,(E)
	JRST VRV4
VRV3:	ADDI D,1
	AOBJN E,VRV1
	POPJ P,

VRV4:	MOVE H,(E)
	MOVE C,VRVT
	JRST VEPNT
VR1TR:	VR1P0
	VR1P1
	VR1P2
	VR1P3
VR1TA:	VDWT
	VDBT
	VDNT
	VDCT
VR1TT:	[ASCIZ /WORD MODE, WORD INDEX %D SHOULD BE %H, READ %F/]
	[ASCIZ /BYTE MODE, WORD INDEX %D SHOULD BE %H, READ %F/]
	[ASCIZ /NATURAL MODE, WORD INDEX %D SHOULD BE %H, READ %F/]
	[ASCIZ /TAPE MODE, WORD INDEX %D SHOULD BE %H, READ %F/]
VR1TX:	[ASCIZ /WORD MODE DATA PATTERN CHECK /]
	[ASCIZ /BYTE MODE DATA PATTERN CHECK /]
	[ASCIZ /NATURAL MODE DATA PATTERN CHECK /]
	[ASCIZ /TAPE MODE DATA PATTERN CHECK /]
VR1TC:	VR1P4
	VR1P5
	VR1P6
	VR1P7
VRP1:	BYTE (8)50,WPAT,125
	IOW 200,VDT
	0
VRP2:	BYTE (8)50,SETCT,125
	IOW 2,VRV0
	BYTE (8)50,RPAT,125
	IOW 200,VDAT
	0
VR1P0:	BYTE (8)50,SETCT,125
	IOW 2,VR1V0
	BYTE (8)40,RPAT,125
	IOW VRWL,VDAT
	0
VR1P1:	BYTE (8)50,SETCT,125
	IOW 2,VR1V1
	BYTE (8)50,RPAT,125
	IOWC 1000*4,VDAT
	IOW <<VRWL-1000>*4>,VDAT+1000
	0
VR1P2:	BYTE (8)50,SETCT,125
	IOW 2,VR1V2
	BYTE (8)140,RPAT,125
	IOW VRWL,VDAT
	0
VR1P3:	BYTE (8)50,SETCT,125
	IOW 2,VR1V3
	BYTE (8)150,RPAT,125
	IOW VRWL,VDAT
	0
VR1P4:	BYTE (8)50,SETCT,125
	IOW 2,VR1V0
	BYTE (8)40,CPATS,125
	IOW VRWL,VDWT
	0
VR1P5:	BYTE (8)50,SETCT,125
	IOW 2,VR1V1
	BYTE (8)50,CPAT,125
	IOWC 1000*4,VDBT
	IOW <<VRWL-1000>*4>,VDBT+1000
	0
VR1P6:	BYTE (8)50,SETCT,125
	IOW 2,VR1V2
	BYTE (8)140,CPATS,125
	IOW VRWL,VDNT
	0
VR1P7:	BYTE (8)70,SETCT,125
	IOW 2,VR1V3
	BYTE (8)150,CPAT,125
	IOW VRWL,VDCT
	0

VRV0:	BYTE (16)200
VR1V0:	BYTE (16)<VRWL_<-1>>*11+5
VR1V1:	BYTE (16)VRWL*4	;4 BYTES PER WORD IN BYTE MODE
VR1V2:	BYTE (16)<VRWL_<-1>>*11+5
VR1V3:	BYTE (16)VRWL*5	;5 BYTES PER WORD IN TAPE MODE
;SUBROUTINE TO RUN CHAN PGM AND VERIFY GOOD ENDING STATUS
VRUNA:	PUSHJ P,VRUN
	CAMN D,[61,,250000]	;CHAN END AND DEV END
	POPJ P,
	JRST V1X	;COMPLAIN

;SUBROUTINE TO RUN CHAN PGM AND RETURN STATUS
VRUN:	SETZM VSENSF
VRUN1:	MOVEM A,@CBASE
	SETZM VRUNDF
VRUN2:	MCONO SA0,@CLSTFC	;CLEAR STATUS FLAG
	MCONO SA0,@STBSYC	;SET GO FLAG
	SKIPL VRUNDF
	JRST VSTAT1
	MOVEI D,1400
	SOJG D,.	;1 MS DELAY
VSTAT1:	MOVEI D,3000
VSTAT3:	XCT DCONI
	AOS VTIMEC	;USED BY VTIME
	TRNN DD,170
	SOJG D,VSTAT3
	JUMPLE D,VSTAT7
	MOVE D,@CBASE+1	;GET STATUS WORD # 1
	CAIE A,V2P	;IGNORE UNIT CHECK DURING TEST2
	TLNN D,10	;UNIT CHECK?
	POPJ P,	;ALL OK
	SKIPE VSENSF
	JRST VSTAT6
	MOVEM D,VOSTAT	;SAVE IN VOSTAT BLOCK
	MOVE D,@CBASE+2
	MOVEM D,VOSTAT+1
	SETOM VSENSF
	MOVEI A,VRUNSP
	PUSHJ P,VRUN1	;RUN SENSE PGM
	MOVEI C,[ASCIZ /UNIT CHECK /]
	JRST VEPNT	;SENSE DATA IN VSENSE BLOCK
VSTAT6:	MOVEI C,[ASCIZ /CAN'T READ SENSE DATA /]
	JRST VEPNT
VSTAT7:	MOVEI C,[ASCIZ /TIMED OUT /]
	JRST VEPNT

VEPNT0:	MOVEI C,[ASCIZ /FAILED/]
VEPNT:	MOVEM C,VEPNTV
	MOVE C,VTTPTR
	PUSHJ P,STYO
	MOVE C,VEPNTV
VEPNT8:	PUSHJ P,STYO
	PUSHJ P,CR
	JRST DDT

VOSTAT:	BLOCK 2

VRUNSP:	BYTE (8)50,SENSE,125
	IOW 30,VSENSE
	0
VSENSE:	BLOCK 6
V2P:	BYTE (8)240,NOP
	0
V2V:	200000,,0

V4P:	BYTE (8)50,RFIX,125
	IOW 400,V4TAB
	0
V4TAB:	BLOCK 102
V4DAT:	VQ==0
	SALL
	REPEAT 100,<
		BYTE (8)VQ,377-VQ,VQ+1,376-VQ
		VQ==VQ+2
		>
	XALL

V6P:	BYTE (8)240,DSCI,125
	0

V7P:	BYTE (8)50,PARE,125
	IOW 1,V7DAT
	0
V7DAT:	0

V8P1:	BYTE0,RFIX,125
	IOW 377,V4TAB
	0
V8P2:	BYTE (8)50,RFIX,125
	IOW 401,V4TAB
	0

V10PP:	BYTE (8)0(4)17
	BYTE (8)125(4)15(24)V10P1
	BYTE (8)252(4)15(24)V10P2
	0
V10P:	BLOCK 4
V10P1:	BYTE (8)260,WAIT,125
	0
V10P2:	BYTE (8)260,NOP,252
	0
V11PA:	BYTE (8)50,REST,125
	IOW 1,V11PAD
	0
V11PAD:	0
V11PBP:	REPEAT 10,<BYTE (8)0(4)16(24)V11PBZ>
	BYTE (8)0(4)16(24)V11PBN
V11PB:	BLOCK 11
V11PBZ:	0
V11PBN:	BYTE (8)260,NOP
	0
V111W:	BYTE (8)0(4)17(24)V11PBN+2

V12PP:	BYTE (8)125(4)15(24)V12P
V12PT:	BLOCK 1
	0
V12P:	BYTE (8)50,RETRYR,125
	IOW 1,V12PD
	0
V12PD:	0

;SUBROUTINE USED BY V6
VV6:	CAMN D,E
	JRST VV62
	MOVEI C,[ASCIZ /FIRST STATUS=%D/]
	JRST VEPNT
VV62:	MCONO SA0,@CLSTFC	;CLEAR STATUS FLAG
	PUSHJ P,VSTAT1	;WAIT FOR MORE STATUS
	CAMN D,[400526,,520000]
	POPJ P,
	MOVEI C,[ASCIZ /SECOND STATUS=%D/]
	JRST VEPNT

VPATC1:	0
VPATC2:	0
VPATC0:	0
VTTPTR:	0
VRVC:	0
VRVT:	0
VSENSF:	0
VRUNDF:	0
VEPNTV:	0
V111V:	0
VGMODE:	3	;SET TO 1 FOR SA-10A, 3 FOR SA-10B

;WIGGLE ADDDRESS BITS AD DIFFERING RATES FOR SCOPING
AWIG:	MOVE P,[-LPDL,,PDL-1]
	PUSHJ P,STEP0
AWIG0:	MOVEI E,0
AWIG1:	MOVE C,E
	PUSHJ P,LC0CW
	MOVEI A,62260
	PUSHJ P,C0XCT
	TRCN E,1
	JRST AWIG1	;WITH BIT 35 ON
	ADDI E,40000
	TRNE E,740000
	JRST AWIG1	;WITH 1 OR MORE BITS 18-21 ON
	PUSHJ P,CHKCNC
	JRST DDT
	JRST AWIG0

VPATCH:	BLOCK 1000
;NORMAL ENTRY
BEGIN:	MOVE P,[-LPDL,,PDL-1]
	PUSHJ P,SETCPU	;DETERMINE TYPE OF CPU
	PUSHJ P,SETHI	;FIND HOW MUCH MEMORY
	MOVNI A,4
	MOVEM A,BEGINC
	SKIPN ADRLO
	JRST BEGING	;IF FIRST ENTRY, SET UP SYM TAB AND ADRLO
BEGIN1:	PUSHJ P,STATIC	;TRY STATIC TEST...
	PUSHJ P,CHKCNC
	JRST CI
	AOSGE BEGINC	;...TEN TIMES
	JRST BEGIN1

;COMMAND LEVEL ENTRY (RESETS PSEUDO DATA SWITCHES)
CI:	MOVEI	C,[ASCIZ/
TYPE H AND "CR" FOR HELP
/]
	PUSHJ	P,PROMPT	;GO PRINT IT ON TTY
GG:!
CI0:	MOVE P,[-LPDL,,PDL-1]
	SKIPN CPUTAB
	PUSHJ P,SETCPU	;MAKE SURE PROC STUFF IS SET UP
	XCT PIRST	;KILL PI
	SETZM PIE	;NO INTERRUPTS EXPECTED
	PUSHJ P,IORST
	MOVEI	C,[ASCIZ/
=/]
	PUSHJ	P,PROMPT
	SETOM PREARG	;NO PRELIMINARY ARGUMENT IF NEGATIVE
	SETOM P2ARG
	SETZM MPERF
CI1:	PUSHJ P,NUMG	;GET # IN A, TERM CHAR IN B
	JFCL
	MOVEM A,CIN	;NUMERIC ARGUMENT
	SUBI B,40
	JUMPL B,CIE	;ERROR
	CAIL B,100
	SUBI B,40	;CONVERT LOWER TO UPPER CASE
	MOVE D,B	;SIXBIT CHAR
	PUSHJ P,CR	;CR, LF
	MOVE A,CIN	;NUMERIC ARG
	MOVE G,A
	XCT CIT(D)	;DO 1-INST COMMAND OR DISPATCH OR SKIP
	JRST CI0
	MOVEM E,CIP	;ADDR OF TEST TO RUN
	XCT IORST	;ABOUT TO DO A TEST, RESET THE WORLD
CI5:	PUSHJ P,@CIP	;PERFORM THE TEST ONCE
	PUSHJ P,CHKTYI
	JRST CI0	;CHAR STRUCK - STOP TEST
	JRST CI5	;KEEP GOING

CIE:	MOVEI C,[ASCIZ /?/]
	PUSHJ P,PROMPT
	JRST CI0

CIN:	0
CIP:	0
BEGINC:	0
CIDDT:	MOVEI A,^D200000
	XCT TYOSKP
	SOJG A,.-1	;WAIT FOR TYPEOUT TO FINISH
	MOVE A,SAVA	;RESTORE AC'S FROM ERROR ROUTINE
	MOVE B,SAVB
	MOVE C,SAVC
	MOVE D,SAVD
	JRST DDT	;AND EXIT TO DDT

CITCM:	MOVE B,PREARG
	MOVEM B,P2ARG
	MOVEM A,PREARG	;HERE ON COMMA
	JRST CI1

PREARG:	0		;STORAGE LOC FOR DEVICE ADDRESS
P2ARG:	0

BEGING:	MOVE A,116	;SYM TAB PTR
	MOVEM A,36
	AOBJN A,.
	ADDI A,100	;PATCH SPACE
	MOVEM A,ADRLO	;1ST LOCATION USABLE FOR TABLES
	MOVE A,117	;UNDEF SYMS
	MOVEM A,32
	JRST BEGIN1
CIT:	JRST CIE	;SPACE
	JRST CIE	;!
	JRST CIE	;"
	JRST CIE	;#
	JRST CIE	;$
	JRST CIE	;%
	JRST CIE	;&
	JRST CIE	;'
	JRST CIE	;(
	JRST CIE	;)
	JRST CIE	;*
	JRST CIE	;+
	JRST CITCM	;,
	JRST CIE	;-
	JRST CIE	;.
	JRST CIE	;/
	JRST CIE	;0
	JRST CIE	;1
	JRST CIE	;2
	JRST CIE	;3
	JRST CIE	;4
	JRST CIE	;5
	JRST CIE	;6
	JRST CIE	;7
	JRST CIE	;8
	JRST CIE	;9
	JRST CIE	;:
	JRST CIE	;;
	JRST CIE	;.LT.
	JRST CIE	;=
	JRST CIE	;.GT.
	JRST CIE	;?

	JRST CIE	;AT SIGN
	JRST CIE	;A
	JRST BAFGO	;B
	JRST CIE	;C
	SKIPA E,[DSKT]	;D
	JRST	CIE	;E
	JRST FMT	;F
	JRST CIE	;G
	JRST CIE	;H
	JRST CIE	;I
	JRST CIE	;J
	JRST CIE	;K
	JRST	CIE	;L
	SKIPA E,[CMT]	;M
	JRST CIE	;N
	JRST CIE	;O
	SKIPA E,[PTST]	;P
	PUSHJ P,TIMET	;Q
	PUSHJ P,PWORLD	;R
	SKIPA E,[STATIC];S
	SKIPA E,[QTT]	;T
	JRST CIE	;U
	SKIPA E,[DSKTV]	;V
	JRST CIE	;W
	JRST CIDDT	;X
	JRST CIE	;Y
	JRST ZRRBL	;Z
	JRST CIE	;.LB.
	JRST CIE	;\
	JRST CIE	;.RB.
	JRST CIE	;^
	JRST CIE	;_
GOGO:	JRST DDTE
DDTG:	MOVE P,[-LPDL,,PDL-1]
	JSP A,.+1
	TLNE A,10000
	JRST DDTG1	;IN CASE OF "RU SA10"
	HRLOI A,-2
	AOBJP A,DDTG1
	MOVEI A,0
	BLT A,0
	JUMPN A,DDTG0
	DATAO PAG,[400000]	;AVOID AROV TRAPS IN DDT
	JRST DDTG1
DDTG0:	CONO PAG,400000
DDTG1:	MOVE A,116
	MOVEM A,36
	AOBJN A,.
	ADDI A,100	;PATCH SPACE
	MOVEM A,ADRLO	;BOTTOM OF FREE STORAGE
	MOVE A,117
	MOVEM A,32
	JRST DDT
DDTE:	SKIPN SUPER0
	JRST DDT
	MOVE A,SUPER0
	MOVEM A,36
	MOVE A,SUPER1
	MOVEM A,32
	SETZM SUPER0
	JRST DDT

DDTQ:	SKIPN ADRLO
	JRST DDTG	;FIRST INITIALIZE STUFF
	JRST DDT
STATIC:	XCT IORST	;CLEAR OUT THE WORLD
	CLEARM PIE	;NO INTERRUPTS ARE EXPECTED
	XCT PIRST
	PUSHJ P,PISET	;SET UP PI LOCS
	PUSHJ P,SETSAA	;SET UP SA-10 DEVICE ADDRESS
BTE:	XCT IORST	;I O RESET
	MOVEI A,^D300
	SOJG A,.	;DELAY A BIT
BTE0:	MCONI SA0,A
	TLNE A,1	;CONI SHOULD GIVE 1 IN L.H.
	JRST BTE2	;IF IT DID, OK
	MOVE A,DCONI
	TLC A,400
	XCT A
	TLNN DD,1	;IS THIS AN SA-10?
	JRST BTE1	;IF NOT
	MOVEI A,4
	XORM A,SADEVA	;IT IS (AND SA0 WASN'T) CHANGE DEV ADDR
	PUSHJ P,SETSAA
	MOVE A,SADEVA
	MOVEI C,[ASCIZ /SA10 DEVICE CODE IS %A
/]
	PUSHJ P,STYO
	JRST BTE0
BTE1:	MCONO SA0,7	;OTHERWISE LOOK DEEPER
	MCONI SA0,A
	TDNE A,[1,,7]	;ANY PIA BITS GET SET?
	JRST ERR50	;IF YES
	MOVEI A,5
	MOVEM A,PIE	;WE'LL TRY AN INTERRUPT
	CONO PI,2377	;TURN ON ALL CHANNELS
	MCONO SA0,STSTF+6	;SHOULD NOT INTERRUPT YET
	MOVEI A,10
	MCONO SA0,STPIE+5	;THIS SHOULD CAUSE INTERRUPT
	SOJG A,.	;GIVE IT A CHANCE
	MCONO SA0,400000	;RESET SA-10
	XCT PIRST	;CHANNELS OFF AGAIN
	SKIPN PIE
	JRST ERR51	;INTERRUPT OCCURRED
	CLEARM PIE	;INTERRUPT DIDN'T OCCUR
	JRST ERR52

BTE2:	CAME A,[1,,0]
	JRST ERR53	;SOME BAD BITS ON
	MOVEI A,10
	CONO PI,2377	;ENABLE ALL PI CHANNELS
	SOJG A,.	;WAIT NERVOUSLY
	MCONO SA0,7	;SET PIA BITS
	MCONI SA0,A
	CAME A,[1,,7]
	JRST ERR55	;IF PIA DOESN'T READ IN
	MOVSI C,40000	;WILL SWEEP THRU DEVICE CODE BITS
BTE2A:	MOVE B,DCONI
	XOR B,C	;CREATE CODE OF SIMILAR DEVICE
	XCT B	;CONI IT
	CAMN DD,[1,,7]	;NO OTHER DEVICE CAN MAKE THIS STATEMENT
	JRST ERR54	;IF ONE TRIED
	LSH C,-1
	CAME C,[200,,0]
	JRST BTE2A	;IF MORE DEV ADDR BITS TO CHECK
	XCT IORST	;I O RESET SHOULD CLEAR PIA
	MCONI SA0,A
	XCT PIRST	;RESET PI
	CAME A,[1,,0]
	JRST ERR56	;PIA DIDN'T CLEAR
BTE4:	MCONO SA0,RDCONI+7	;CAN WE DO A DATAI?
	MDATAI SA0,A
	CAME A,[2,,7]	;CLEN, PIA
	JRST ERR57	;IF WRONG
	MCONO SA0,SASTEP	;STOP THE CLOCK
	MCONO SA0,RDCONI
	MDATAI SA0,A
	JUMPN A,ERR58	;IF WE DIDN'T BEAT THE CLOCK
	MCONO SA0,RSTSA!CLMERR
;SEE IF CHANNEL COUNTER COUNTS WHEN CLOCK IS STEPPED
BEG1:	PUSHJ P,RDSEQ
	PUSHJ P,RDSQ1
	MOVE D,CURSEQ
	CAME B,D
	JRST ERR3	;DIFF SEQ SECOND TIME
	MOVE D,C	;SAVE UNNORMALIZED VERSION
	MOVEI H,100
BEG1A:	PUSHJ P,RDSQ0
	CAME C,D
	JRST ERR3	;SEQ CHANGED
	SOJG H,BEG1A
;MAKE SURE ALL BITS OF MICRO-P.C. CAN BE SET
	PUSHJ P,STEPC0
	MOVEI A,^D10
	JSR PTN	;TRY VALUES FOR 10 BITS
IARL:	ANDI A,1777
	MOVE B,A
	MDATAO SA0,B
	PUSHJ P,STEP0
	ANDI A,1777
	CAME A,B
	JRST ERR4	;MICRO-P.C. NOT BEING SET PROPERLY
IARL1:	LOOP  PTN9
	MDATAO SA0,[040000]	;CBUS_IARB
	MDATAI SA0,A
	LDB A,[121000,,A]
	MOVE C,B
	ANDI C,377
	CAME A,C
	JRST ERR5	;CBUS_IARB LOSING
IARL2:	LOOP  PTN9
	JSR PTN0	;ON TO NEXT DATA VALUE
;SEE IF SOURCE OF ZEROES WORKS
SZER:	MOVEI A,176320	;REG. 3_0
	PUSHJ P,C0XCT
	MOVEI A,072260	;START DUMMY WRITE FROM REG. 3
	PUSHJ P,C0XCT
	MCONO SA0,RDMBL
	MDATAI SA0,A	;SHOULD GIVE US 0 IN THE R.H. OF A
	TRNE A,-1
	JRST ERR40	;FAILS HERE IF NO ROMS INSTALLED YET
SZER1:	LOOP  SZER
MAMB:	MOVEI A,^D36
	JSR PTN	;TRY ALL 36 BITS OF WORD
MAMB1:	PUSH P,A
	TLZ A,777774
	MOVEM A,MAMBTA
	TLO A,200000
	MOVE C,A
	PUSHJ P,LC0CW
	POP P,C
	HLRZM C,MAMBTL
	HRRZM C,MAMBTR
	PUSHJ P,LC0R2
	MOVEI A,062260	;START DUMMY WRITE FROM REG. 2
	PUSHJ P,C0XCT
;FALLS THROUGH TO NEXT PAGE

;FALLEN INTO FROM PREVIOUS PAGE
	MCONO SA0,RDMA
	MDATAI SA0,C
	MOVE A,C
	AND A,[3,,-1]
	CAME A,MAMBTA
	JRST ERR11	;MEM ADDR REG HAS WRONG THING IN IT
MAMB1A:	LOOP  PTN9
	MCONO SA0,RDMBL
	MDATAI SA0,A
	HRRZ B,A
	CAME B,MAMBTL
	JRST ERR6	;MB LEFT LOSING
MAMB2:	LOOP  PTN9
	TLNE A,-1
	JRST ERR7	;WRONG CHANNEL HAS MEMORY SUBROUTINE
MAMB3:	LOOP  PTN9
	MCONO SA0,RDMBR
	MDATAI SA0,A
	CAME A,MAMBTR
	JRST ERR12	;MB RIGHT LOSING
MAMB4:	LOOP  PTN9
	JSR PTN0	;ON TO NEXT DATA VALUE
CWTST0:	LDB G,NCHNP	;TRY OUT WC, CA, PC PATHS
	SUBI G,1
CWTST:	PUSHJ P,STEPCX	;STEP CLOCK TO APPROPRIATE CHANNEL
CWTST1:	MOVEI A,^D36	;CHECK 36 BIT POSITIONS
	JSR PTN
	MOVEM A,CWTA	;DATA WORD
	SETCM B,A	;ITS COMPLEMENT
	LSH B,1
	MOVEM B,CWTB	;A SLIGHTLY DIFFERENT DATA WORD
	MOVE J,[441100,,CWTD]
	MOVE D,[441000,,A]
	ILDB C,D	;GET A BYTE OF 1ST DATA WORD
	TRO C,200
	IDPB C,J	;PUT MUNGED BYTE INTO CWTD
	ILDB C,D	;GET ANOTHER BYTE
IFG CV,<	TRO C,17>	;DIDDLE IT IF NEED BE
	IDPB C,J	;PUT IT AWAY
	MOVEI C,340	;MAGIC BYTE
	IDPB C,J	;INTO TABLE
	ILDB C,D
	IDPB C,J	;ANOTHER BYTE FROM 1ST WD
	ILDB C,D
	IDPB C,J	;AND ANOTHER
	LDB C,[400,,A]	;REMAINING NIBBLE OF 1ST WORD
	ASH C,4
IFG CV,<	LDB D,[240200,,A]	;EXTRA BITS IN C VERSION
	ADD C,D>
	IDPB C,J	;INTO TABLE
	LDB C,[141000,,B]	;RIGHT BITS FROM 2ND WORD
	IDPB C,J	;INTO TABLE
	LDB C,[41000,,B]	;RIGHTER BITS
	IDPB C,J	;INTO TABLE
	LDB C,[400,,B]	;RIGHTEST BITS
	ASH C,4
IFG CV,<	LDB D,[240200,,B]
	ADD C,D>
	IDPB C,J	;LAST TABLE ENTRY
CWTST2:	MOVE C,CWTA
	MOVE J,[441100,,CWTD]
	PUSHJ P,LCXCW	;PUT INTO WC, CA REGISTERS
	MOVE C,CWTB
	PUSHJ P,LCXR2
	MOVEI A,065300	;PC_ADR FILED OF REG. 2
	PUSHJ P,CXXCT
	MOVEI C,040400	;CBUS_BYTE 1 OF WC
	MOVEI F,3	;DO STUFF FOR EACH OF 3 REGISTERS
CWT1:	MOVEI B,3	;DO THIS STUFF FOR EACH OF 3 BYTES
CWT2:	MDATAO SA0,C	;GET DATA ONTO CBUS
	MCONO SA0,RDCCI
	MDATAI SA0,A
	LDB A,[121000,,A]	;GET CONTENTS OF CBUS
	ILDB D,J	;GET EXPECTED ANSWER
	CAIN B,1	;CHECK FOR 3RD BYTE
	ANDI A,360	;IGNORE EXTRANEOUS BITS
	CAIN B,1
	ANDI D,360
	CAME D,A	;ARE THEY THE SAME?
	JRST ERR28	;NOPE
CWT2A:	ADDI C,400	;ADVANCE TO NEXT BYTE OF REGISTER
	SOJG B,CWT2	;THAT'S ALL FOR THAT REGISTER
	ADDI C,400	;ADVANCE TO NEXT REGISTER
	SOJG F,CWT1	;WE'VE TESTED ALL THREE REGISTERS
	JSR PTN0	;TRY NEXT DATA VALUE
	SOJGE G,CWTST	;TRY ALL CHANNELS
	LOOP  CWTST0
INCT:	MOVEI J,0	;0 OR -1
INCT0:	HRLOI F,17	;SHIFTS
INCT1:	MOVE C,F	;DATA WORD
	XOR C,J	;COMPLEMENTED SECOND TIME THROUGH
	MOVEM C,INCTW	;REAL DATA WORD
	ADDM J,INCTW
	JUMPL J,INCT1A
	AOS INCTW	;SIMULATE THE INCREMENTER
INCT1A:	PUSHJ P,LC0CW	;LOAD CA, WC
	MOVEI A,42300
	JUMPGE J,INCT2
	MOVEI A,42660
INCT2:	PUSHJ P,C0XCT	;DO THE INCREMENT/DECREMENT
	MOVEI A,62260
	PUSHJ P,C0XCT
	MCONO SA0,RDMA	;TO READ THE MA BACK
	MDATAI SA0,A
	MCONO SA0,RDBITS	;TO READ THE EXTRA ADDR BITS
	MDATAI SA0,B
	DPB B,[240200,,A]	;PUT EXTRA BITS WHERE THEY BELONG
	XOR A,INCTW	;COMPARE
IFG CV,	TDNE A,[17,,777777]	;WHERE WORDS SHOULD MATCH
IFLE CV,TDNE A,[3,,-1]
	JRST ERR39	;IF ERROR
INCT4:	LOOP  INCT1		;USE SAME DATA IF LOOPING
	JUMPE F,INCT5	;IF ALL BIT POSITIONS TRIED
	ASH F,-1
	JRST INCT1	;OTHERWISE TRY NEXT ONE

INCT5:	SETCA J,0	;COMPLEMENT J
	JUMPL J,INCT0	;AND DO OTHER PASS IF NEEDED
;FALLS THROUGH TO NEXT PAGE




;FALLEN INTO FROM PREVIOUS PAGE
STCL:	LDB G,NCHNP	;HANG ALL CHANNELS
	SUBI G,1
STCLH:	PUSHJ P,STEPCX	;GET TO RIGHT CHANNEL
	MOVEI A,HANGPC##;FEED IT MAGIC PC WHICH WILL HANG IT
	PUSHJ P,CXXCT
	SOJGE G,STCLH	;DO SAME FOR ALL CHANNELS
	MCONO SA0,SACGO	;START THE CLOCK SO CONO'S WILL WORK
STCL0:	LDB C,NCHNP
	SUBI C,1
	MOVE E,C
	ASH E,3
	MOVN A,C
	MOVEI D,PIE0
	LSH D,(A)
STCL1:	MCONO SA0,STPIE(E)
	MCONSO SA0,(D)
	JRST ERR13
STCL1A:	MCONO SA0,CLPIE(E)
	MCONSZ SA0,(D)
	JRST ERR14
STCL1B:	LSH D,-4
	MCONO SA0,STBSY(E)
	MCONSO SA0,(D)
	JRST ERR15
STCL1C:	MCONO SA0,CLBSY(E)
	MCONSZ SA0,(D)
	JRST ERR16
STCL1D:	LSH D,-4
	MCONO SA0,STSTF(E)
	MCONSO SA0,(D)
	JRST ERR17
STCL1E:	MCONO SA0,CLSTF(E)
	MCONSZ SA0,(D)
	JRST ERR18
STCL1F:	LSH D,10+1
	LOOP  STCL0
	SUBI C,1
	SUBI E,10
	JUMPGE E,STCL1
	MOVSI B,-3
	MCONO SA0,SASTEP
	PUSHJ P,STEPC0
STCLM2:	MOVE A,STCLM(B)
	PUSHJ P,C0XCT
	MCONSO SA0,@STCLM1(B)
	JRST ERR19
STCLM3:	MOVE A,STCLM(B)
	SUBI A,4000
	PUSHJ P,C0XCT
	MCONSZ SA0,@STCLM1(B)
	JRST ERR20
STCLM4:	LOOP  STCLM2
	AOBJN B,STCLM2
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
QFIFO:	LDB G,NCHNP	;FILL UP THE RING BUFFERS
	SUBI G,1	;OF ALL CHANNELS
FIFO1:	PUSHJ P,CHKNHC	;SELECT CHAN, SKIP IF REAL CHAN
	 JRST FIFO2D	;ISN'T - SKIP FILL
	MOVEI A,002000	;CLEAR TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,027000	;SET WRITE BIT IN TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,027400	;SET BUFFER ENABLE BIT IN TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,145000	;TEST BUFFER EMPTY BIT
	PUSHJ P,CXTST
	TRNN A,40_12	;CHECK RESULTS OF TEST
	JRST ERR21	;BUFFER WASN'T EMPTY
FIFO1A:	LOOP  FIFO1
	MOVEI C,0
	PUSHJ P,LCXCW	;CAUSE AN APPARENT W.C. OVERFLOW
	MOVEI D,NBF	;SET UP COUNT OF # BYTES TO SEND
FIFO2:	MOVE A,G
	LSH A,5
	ADD A,D		;SYNTHESIZE A UNIQUE BYTE OF DATA
	PUSHJ P,CXXCT	;PUT IT INTO MICRO-P.C.
	MOVEI A,040140	;PUT "FIFO_MICRO-P.C." IN MICROIN-
	PUSHJ P,CXTST	;STRUCTION REGISTER TO SEE IF IT
			;WILL BRANCH
	PUSHJ P,STEPX	;NOW EXECUTE THE MICROINSTRUCTION
	MOVEI A,145000	;TEST BUFFER EMPTY BIT
	PUSHJ P,CXTST
	TRNE A,40_12
	JRST ERR22	;BUFFER WAS EMPTY
FIFO2A:	LOOP  FIFO2
	SOJG D,FIFO2	;KEEP DOING IT UNTIL FIFO SHOULD BE FULL
FIFO2C:	MOVEI A,040140	;TRY TO PUT ANOTHER WORD INTO FIFO
	PUSHJ P,CXXCT
	TRNN A,1	;OUGHT TO COMPLAIN THIS TIME
	JRST ERR24	;DIDN'T
FIFO2B:	LOOP  FIFO2C
FIFO2D:	SOJGE G,FIFO1	;FILL UP FIFOS OF OTHER CHANNELS
;O.K., FOLKS, NOW WE SEE IF WE CAN GET THE DATA BACK
;FALLS THROUGH TO NEXT PAGE
;FALLEN INTO FROM PREVIOUS PAGE
	LDB G,NCHNP	;START UNLOADING HIGHEST CHANNEL
	SUBI G,1
FIFO3:	PUSHJ P,CHKNHC	;SELECT CHAN, SKIP IF REAL
	 JRST FIFO4D	;NO, DON'T CHECK IT
	MOVEI A,023400	;CLEAR BUFFER ENABLE
	PUSHJ P,CXXCT
	MOVEI A,027400	;SET BUFFER ENABLE
	PUSHJ P,CXXCT
	MOVEI A,145000	;TEST BUFFER EMPTY (SHOULD BE)
	PUSHJ P,CXTST
	TRNN A,40_12
	JRST ERR25	;WASN'T
FIFO3A:	LOOP  FIFO3
	MOVEI A,023000	;CLEAR WRITE
	PUSHJ P,CXXCT
FIFO3Z:	MOVEI D,NBF
FIFO4:	MOVEI A,145000	;TEST BUFFER EMPTY
	PUSHJ P,CXTST
	TRNE A,40_12
	JRST ERR26	;OOPS, IT WAS
FIFO4A:	LOOP  FIFO4
	MOVEI A,147000	;R0B0_FIFO
	PUSHJ P,CXTST
	PUSHJ P,STEPX
	MOVE H,G
	LSH H,5
	ADD H,D
	MOVEI A,140000	;CBUS_R0B0
	PUSHJ P,CXTST
	LDB A,[121000,,A]
	CAME A,H
	JRST ERR27	;WRONG DATA READ BACK FROM FIFO
FIFO4B:	SOJG D,FIFO4	;READ BACK THE REST
	LOOP  FIFO3Z
	MOVEI A,145000	;BUFFER SHOULD NOW BE EMPTY
	PUSHJ P,CXTST
	TRNN A,40_12
	JRST ERR23	;OOPS, IT ISN'T
FIFO4C:	LOOP  FIFO3
FIFO4D:	SOJGE G,FIFO3	;READ BACK FIFOS OF OTHER CHANNELS
;FALL THRU
;TRY OUT P.I. REQUEST LOGIC
PITST0:	MCONO SA0,SACGO
	LDB G,NCHNP
	SUBI G,1
	LSH G,3
PITST:	MCONO SA0,CLSRQ(G)	;CLEAR STATUS REQUEST FLAG
	MCONO SA0,CLSTF(G)	;AND STATUS FLAG
	MCONO SA0,STPIE(G)	;AND SET P.I. ENABLE FLAG
	SUBI G,10
	JUMPGE G,PITST	;FOR ALL CHANNELS
	MCONSZ SA0,PIRQ	;SHOULD NOT BE REQUESTING AN INTERRUPT
	JRST ERR29	;OOPS, WAS
PITST1:	LOOP  PITST0
	CLEARM PIE	;NOT EXPECTING ANY INTERRUPTS
	CONO PI,12377	;ENABLE ALL P.I. CHANNELS
	MOVEI B,7
PIT1:	MCONO SA0,(B)
	SOJG B,.-1	;SHOULD NEVER INTERRUPT
	LDB G,NCHNP
	SUBI G,1
	LSH G,3
PIT2:	MOVEI B,7
PIT3:	MOVEM B,PIE
	ADD B,G
	MCONO SA0,STSTF(B)	;SHOULD CAUSE AN INTERRUPT
	MOVEI 10
	SOJG .		;WASTE SOME TIME FOR KI/KL
	SKIPE PIE	;DID IT?
	JRST ERR38	;NO, COMPLAIN
PIT3A:	LOOP  PIT3
	SUB B,G
	SOJG B,PIT3	;TRY ALL P.I. CHANNELS
	SUBI G,10
	JUMPGE G,PIT2	;TRY ALL SA-10 CHANNELS
UCT:	MOVEI B,0	;ADDRESS
UCT00:	PUSHJ P,STEP0	;DO GOTO
UCT0:	HRRZ C,MCBEG0##(B)	;WHAT UINST SHOULD BE
	TRNE C,140000
	JRST UCT8	;IF NOT GOTO OR OFF/ON
	MOVE A,B
	PUSHJ P,C0XCT	;IT'S HARMLESS, DO IT
	PUSHJ P,STEP0
	HLRZ C,MCBEG0##(B)	;FULL JUMP ADR
	ANDI A,1777
	CAME A,C
	JRST ERR41
UCT7:	LOOP  UCT00
UCT8:	MOVSI C,$CNOB##
	TDZN C,CONFIG	;TEST CONFIG WORD
	SKIPA C,[1377]
	MOVEI C,777	;HOW MUCH MICROCODE
	CAMGE B,C
	AOJA B,UCT0
;TEST MEM READ, WRITE
TAT:	MOVE E,ADRLO
TAT1:	MOVE A,E
	PUSHJ P,MAPAL
	MOVEM E,(A)	;FILL MEMORY WITH .
	ADDI E,1
	AOBJN A,.-2
	CAMG E,ADRHI
	JRST TAT1
	SUBI E,1	;HIGHEST USED ADDRESS
	MOVSI H,200000
TAT2:	MOVE D,ADRHI
	ROT H,1		;MOVE THE FLOATING BIT
	TRNE H,1
	JRST .-2
	TLNE H,377740
	JRST TBT	;IF TRIED ALL VALID BIT POSITIONS
	XOR D,H		;TURN OFF A BIT
	TLZ D,777740	;RESTRICT TO ADDRESS SIZE
	CAMG D,ADRHI	;SKIP IF TOO BIG
	CAMGE D,ADRLO	;DON'T SKIP IF TOO LOW
	JRST TAT2	;DON'T TRY THIS LOCATION
	MOVEI A,^D36
	JSR PTN	;36-BIT DATA PATTERNS
	MOVEM A,TBTV	;TEST DATA VALUE
	MOVE E,A
	PUSHJ P,MAPAD
	MOVEM E,(A)	;TO PROPER LOCATION
	MOVEI G,0	;USE CHAN 0
	MOVE C,D
	PUSHJ P,MEMRD	;HAVE THE SA-10 READ THE LOCATION
	JRST ERR8	;MEM READ TOOK TOO MANY TICKS
	LOOP  PTN9
	MCONO SA0,RDMBL
	MDATAI SA0,A
	MCONO SA0,RDMBR
	MDATAI SA0,E
	HRL E,A	;ASSEMBLE MB REGISTER CONTENTS IN E
	CAME E,TBTV	;LOCATION SHOULD CONTAIN PROPER DATA
	JRST ERR65	;DATA WRONG IN MB
	PUSHJ P,STEPCX
		MOVEI A,146720	;LOAD R REG FROM MRB
	PUSHJ P,CXXCT
	MOVEI J,0	;REG # BEING USED
	PUSHJ P,TCTR	;CHECK R REG CONTENTS
	PUSHJ P,MAPAD
	MOVE F,(A)
	CAME F,TBTV
	JRST ERR66	;WORD IN MEMORY CLOBBERED
	MOVE E,TCTV
	CAME E,F
	JRST ERR67	;DATA WRONG IN R REG
	MOVE E,[525252,,252525]	;IMPROBABLE NUMBER
	PUSHJ P,MAPAD
	MOVEM E,(A)	;TO LOCATION WHERE SA-10 WILL WRITE
	MOVEI A,63300
	PUSHJ P,CXXCT
TAT5:	MOVEI A,42240
	PUSHJ P,MEMXCT
	JRST ERR9	;WRITE CYC TOOK TOO LONG
	LOOP  TAT5
	MOVE F,TBTV	;CORRECT VALUE
	PUSHJ P,MAPAD
	MOVE E,(A)
	CAME E,F
	JRST ERR10	;DATA NOT WRITTEN PROPERLY
TAT7:	LOOP  PTN9
	JSR PTN0	;TRY ANOTHER DATA VALUE
	PUSHJ P,MAPAD
	MOVEM D,(A)	;RESTORE CONTENTS TO .
	JRST TAT2	;TRY ANOTHER ADDRESS
;TEST UNIQUENESS OF MRB REGS
TBT:	LDB I,NCHNP
	SUBI I,1	;# CHANS - 1
	MOVEI A,^D36
	JSR PTN	;TEST 36-BIT DATA PATH
	MOVEM A,TBTV	;TEST VALUE
	MOVEI H,0	;TEST CHAN #
TBT1:	MOVE G,H	;TEST CHAN #
	MOVEI C,TBTV	;WHERE TO GET DATA
	PUSHJ P,MEMRD	;CAUSE SA-10 TO READ THE WORD
	JRST ERR8	;IF HUNG
	MCONO SA0,RDMBL
	MDATAI SA0,E
	LDB E,[220200,,E]	;MEM USER BITS
	CAME E,G
	JRST ERR68	;WRONG CHAN HAS MEM
TBT1B:	LOOP  TBT1A
	SETCMM TBTV	;COMPLEMENT OF DATA
	MOVEI G,0	;INTERFERENCE CHAN #
TBT2:	MOVEI C,TBTV
	CAMN G,H
	JRST .+3
	PUSHJ P,MEMRD	;READ THE COMPLEMENTED DATA IF NOT TEST CHAN
	JRST ERR8	;IF HUNG
	CAMGE G,I
	AOJA G,TBT2	;IF OTHER CHANS
	MOVE G,H	;TEST CHAN #
	PUSHJ P,STEPCX
	MOVEI A,146720
	PUSHJ P,CXXCT	;MRB TO R0
	MOVEI J,0	;R # IN USE
	PUSHJ P,TCTR	;READ R REG
	MOVE E,TCTV
	SETCMM TBTV
	CAME E,TBTV
	JRST ERR70	;WRONG IN R REG
TBT4:	LOOP  TBT1A
	CAMGE H,I
	AOJA H,TBT1	;TRY ANOTHER TEST CHAN
	JSR PTN0	;TRY ANOTHER DATA VALUE
	;TO TCT
;TEST UNIQUENESS OF R AND A REGS
TCT:	LDB I,NCHNP
	SUBI I,1
	MOVEI A,^D36
	JSR PTN	;36-BIT PATTERNS
	MOVEM A,TBTV	;TEST DATA
TCT0:	MOVEI H,0	;TEST CHAN #
TCT1:	MOVEI J,0	;TEST REG #
TCT2:	MOVE G,H	;TEST CHAN #
	MOVE E,J	;TEST R #
	MOVE C,TBTV	;TEST DATA
	PUSHJ P,TCTS	;WRITE R, A REGS
	MOVEI K,0	;INTERF CHAN #
TCT3:	MOVEI L,0	;INTERF REG #
TCT4:	MOVE G,K	;INTERF CHAN #
	MOVE E,L	;INTERF REG #
	SETCM C,TBTV	;COMPLEMENT OF DATA
	SKIPE TBTV
	JUMPN C,TCT4C
	CAMN G,H	;SKIP IF NOT ON TEST CHAN
	CAME E,J	;DON'T SKIP IF NOT ON TEST R #
	PUSHJ P,TCTS	;WRITE IT
	CAIGE L,3
	AOJA L,TCT4	;ANOTHER INTERF R #
	CAMGE K,I
	AOJA K,TCT3	;ANOTHER INTERF CHAN
TCT4C:	MOVE G,H	;TEST CHAN #
	PUSHJ P,TCTR	;READ R REG #J
	MOVE E,TCTV	;VALUE READ
	CAME E,TBTV	;PROPER VALUE
	JRST ERR71	;ERROR IN R
TCT4A:	LOOP  PTN9
	SETZM TCTV
	MOVEI B,40760
	DPB J,[120200,,B]	;REG #
	MOVE A,B
	PUSHJ P,CXTST	;A TO CBUS
	ROT A,-12	;SHIFT CBUS TO RIGHT
	DPB A,[141000,,TCTV]	;LEFT BITS
	MOVEI A,400(B)
	PUSHJ P,CXTST
	ROT A,-12
	DPB A,[41000,,TCTV]	;MID BITS
	MOVEI A,1000(B)
	PUSHJ P,CXTST
	ROT A,-12
	DPB A,[240200,,TCTV]	;RIGHT BITS
	ROT A,-4
	DPB A,[400,,TCTV]
	MOVE E,TBTV	;RIGHT VALUE
IFG CV,	TLZ E,777760	;BITS THAT DON'T GET TO A REGS
IFLE CV,TLZ E,-4
	CAME E,TCTV
	JRST ERR72	;ERROR IN A
TCT4B:	LOOP  PTN9
	CAIGE J,3
	AOJA J,TCT2	;ANOTHER TEST R #
	CAMGE H,I
	AOJA H,TCT1	;ANOTHER TEST CHAN
	JSR PTN0	;ANOTHER DATA VALUE
	JRST MUXREQ	;ON TO NEXT TEST
TBTV:	0
TCTV:	0

TCTS:	PUSH P,H
	PUSHJ P,STEPCX
	PUSHJ P,LCXRE
	MOVEI A,41300
	DPB E,[140200,,A]
	DPB E,[120200,,A]
	PUSHJ P,CXXCT
	POP P,H
	POPJ P,

LCXRE:	MOVEI D,40000
	DPB E,[140200,,D]
	JRST LCXR2B

TCTR:	PUSH P,D
	PUSH P,H
	PUSHJ P,STEPCX
	MOVEI D,4
	MOVEI B,140360	;XFER R REG NOWHERE
	DPB J,[140200,,B]	;TEST R #
	MOVE C,[441000,,TCTV]	;BYTE PTR
TCT5:	MOVE A,B
	PUSHJ P,CXTST	;BYTE OF R TO A
	ROT A,-12
	IDPB A,C
	ADDI B,400	;NEXT BYTE
	SOJG D,TCT5
	MOVE A,B
	PUSHJ P,CXTST
	ROT A,-16
	DPB A,[400,,TCTV]
	POP P,H
	POP P,D
	POPJ P,

TBT1A:	MOVE A,TBTV
	JRST TBT1

;ROUTINE TO SELECT CHAN (G) AND SKIP IF REAL CHAN
CHKNHC:	PUSHJ P,STEPCX	;STEP TO CHAN
	MOVE A,CONFIG
	TLNN A,$NHCHAN##	;DO WE HAVE THE NON-HARDWARE CHANNEL FEATURE?
	JRST CPOPJ1	;NO, DON'T BOTHER TO CHECK
	MOVEI A,102460
	PUSHJ P,CXTST
	TRNN A,20B25	;IS THE MAGIC BIT ON?
	JRST CPOPJ1	;NO,THIS CHAN IS REAL
	LDB A,SEQCNT(G)	;GET ITS ALLOTMENT
	LDB SEQLNP	;AND THE TOTAL
	IDIVM A		;COMPUTE RECIPROCAL OF ITS SHARE
	CAIL A,20	;DOES IT HAVE MORE THAN 1/16?
	POPJ P,		;NO, JUST NON-SKIP
	JRST ERR44	;YES, GIVE ERROR
;TEST SA-10 CLOCK TIMING
TIMET:	MCONO SA0,400000
	MOVEI A,0
	PUSHJ P,CSET
	MOVEI A,[200127,,-1]
	MOVEM A,@CBASE
	LDB A,[POINT 7,DCONO,9]
	DPB A,[POINT 7,TMLP1,9]
	DPB A,[POINT 7,TMLP3,9]
	DPB A,[POINT 7,TMLP4,9]
	MOVE A,CLKSKP
	MOVEM A,TMLP2
	MOVE A,CLKCF
	MOVEM A,TMLP5
	MCONO SA0,@STBSYC
	MCONSO SA0,400000
	JRST .-2
	SETZB E,C
	MOVEI B,^D60
	XCT CLKCF
	XCT CLKSKP
	JRST .-1
	XCT CLKCF
	MCONO SA0,200000
TMLP1:	CONSO SA0,400000
	AOJA C,TMLP2
TMLP3:	CONO SA0,200000
	MOVE D,C
	MOVEI C,0
	AOJA E,TMLP1
TMLP2:	XCT CLKSKP
	JRST TMLP1
TMLP4:	CONSZ SA0,400000
	JRST TMLP3
TMLP5:	XCT CLKCF
	SOJG B,TMLP1
	IMULI E,^D8192
	IMULI C,^D8192
	IDIV C,D
	ADD E,C
	MOVEI A,^D50*^D60*^D20
	IDIV A,PWRHZ
	IDIV E,A
	SUB A,F
	CAML F,A
	ADDI E,1	;ROUND
	MOVEI C,[ASCIZ /
CLOCK OSC = $E KHZ/]
	JRST STYO
;CHECK OUT PORT MUX LOGIC USING SPECIAL CARD
MUXREQ:	MOVE A,CONFIG
	TRNN A,%MUXCRD##
	JRST MPET	;CAN'T TEST IT
	JSP SPTN	;IN CASE WE LOOP FROM ERR8
	PUSHJ P,MXT1
	MOVE C,ADRHI
	PUSHJ P,MEMRD
	JRST ERR8
	MCONO SA0,RDBITS
	MDATAI SA0,A
	TRNN A,200000
	JRST ERR60	;ACKN DIDN'T SET
MUXRQ1:	PUSHJ P,MXT1
	LOOP  MUXREQ
	JRST MPET

MXT1:	MCONO SA0,400000
	MCONO SA0,RDBITS
	MDATAI SA0,A
	TRNE A,200000
	JRST ERR61	;ACKN DIDN'T CLEAR
MXT2:	JRST STEP0

;HERE TO SET UP PTN FOR LOOPING NON-PATTERN ERRS
SPTN:	MOVEM PTN
	JRST @0
;PAR ERR TEST
MPET:	JSP SPTN	;IN CASE WE LOOP FROM ERR8
	SKIPL CPU
	JRST MPEIL
	SETOM MPERF
	DATAO APR,[376400,,400]
	JRST 2,@[14000,,.+1]
	CONO PI,200000
	MOVSI A,-20
MPEL:	MOVE B,400000(A)
	CONSO PI,200000
	AOBJN A,MPEL
	110000,,0
	JRST 4,.
MPE1:	0
	SKIPL MPERF
	JRST MPEP
	JUMPGE A,MPEN	;NO PARERR FOUND
	MOVEI C,(A)
MPE2:	SETZM MPEFG	;NO PROBLEMS GETTING BAD PAR
	MCONO SA0,RSTSA
	PUSHJ P,STEP0
	PUSHJ P,MEMRD
	JRST [	SETZM MPE1	;DON'T LEAVE BAD PAR AROUND
		JRST ERR8]
	SETZM MPE1
	MCONSO SA0,200000
	JRST ERR62	;PAR ERR NOT DETECTED
MPE3:	SETZM MPERF
	JRST NXMT

MPEIL:	SKIPE CPU
	JRST MPEKL
	CONI APR,A
	TLNN A,IP.MNM
	JRST MPEIE	;CAN'T WRT BAD PAR
	DATAO APR,[1B22]
	SETZM MPE1
	DATAO APR,[0]
MPEIL2:	MOVEI C,MPE1
	JRST MPE2

MPEKL:	CONO PI,1B19
	SETZM MPE1
	CONO PI,0
	JRST MPEIL2

MEMRD:	PUSH P,D
	PUSHJ P,STEPCX
	TLZ C,777760
	TLO C,200000
	PUSHJ P,LCXCW
	MOVEI A,42200
	PUSHJ P,MEMXCT
	CAIA
	AOS -1(P)
	POP P,D
	POPJ P,

MPEIE:	SKIPA C,[[ASCIZ /
NEED MARGIN ENB SW FOR PAR ERR TEST.
/]]
MPEN:	MOVEI C,[ASCIZ /
NO BAD PARITY IN MEM
/]
MPEE:	CAMN C,MPEFG	;ALREADY GIVEN THIS COMPLAINT?
	JRST NXMT	;YES, DON'T BE OBNOXIOUS
	MOVEM C,MPEFG
	PUSHJ P,STYO
	JRST MPE3

MPERF:	0
MPEFG:	0

MPEP:	MOVEI C,[ASCIZ /
TRAP TO 61 FROM %E-1
/]
	PUSHJ P,STYO
	JRST CI0
;NXM TEST
NXMT:	MOVE E,ADRHI
	JFFO E,.+1
	MOVEI E,1
	MOVNS F
	LSH E,^D36(F)
	MOVE F,CONFIG
NXMT1:	TLNN F,$N18BA##
	TLNN E,1
	TLNE E,20
	JRST NXMTX
	TLNN F,$EADR##
	TLNN E,4
	JRST NXMT2
NXMTX:	POPJ P,	;O.K., IT ALL WORKS

NXMT2:	MCONO SA0,RSTSA
	PUSHJ P,STEP0
	MOVE C,E
	PUSHJ P,MEMRD
	CAIA
	JRST ERR63	;MEM CYC COMPLETED
	MCONO SA0,RDBITS
	MDATAI SA0,A
	TRNE A,MUXACK
	TRNE A,MEMACK
	JRST ERR64	;CYC INCOMPLETE BUT OTHER ERROR THAN NXM
NXMT3:	LSH E,1
	JRST NXMT1

MAMBTA:	0
;HERE


BEGS:	MCONO SA0,SASTEP!RDCCI
	MDATAI SA0,A
	MDATAO SA0,[0]
	MDATAI SA0,C
	HLRZ A,C
	TRNE A,777774
	JRST ERR30
	POPJ P,


STEPC0:	MOVEI G,0
STEPCX:	MCONO SA0,RDCCI
STPC0A:	MDATAI SA0,A
	LDB DD,[220200,,A]	;CHANNEL SELECTION.
	CAMN DD,G		;DESIRED CHANNEL?
	POPJ P,			;YES.
	ANDI A,1777	;NO, MAKE IT DO A NO-OP (GOTO .)
	JRST CXXCT
STEPX:
STEPX1:	MCONO SA0,SASTEP!RDCCI
	JRST STPC0A

LC0CW:	MOVEI G,0
LCXCW:	PUSHJ P,LCXR2
	MOVEI A,060700	;WC_WC FIELD OF REG. 2
	PUSHJ P,CXXCT
	MOVEI A,063300	;CA_CA FIELD OF REG. 2
CXXCT:	MDATAO SA0,A
	JRST STEPX

C0XCT:	MDATAO SA0,A
STEP0:	MOVEI G,0
	JRST STEPX1

CXTST:	MDATAO SA0,A
	MCONO SA0,RDCCI
	MDATAI SA0,A
	POPJ P,

LC0R2:	MOVEI G,0
LCXR2:	MOVEI D,060000-20	;IARB TO BYTE OF REG. 2
LCXR2A:	ADDI D,20	;ADVANCE TO NEXT BYTE OF REGISTER
LCXR2B:	MOVEI B,0
	LSHC B,10
	MDATAO SA0,B	;PUT A BYTE OF DATA INTO MICRO-P.C.
	PUSHJ P,STEPX
	MDATAO SA0,D	;TRANSFER IT TO BYTE OF REG. 2
	PUSHJ P,STEPX
	TRNN D,100	;WAS THAT THE LAST BYTE?
	JRST LCXR2A	;NO
	POPJ P,	;I CAN'T BELIEVE WE FILLED THE WHOLE WORD

;VERSION OF CXXCT FOR MEM OPS (TIMES OUT IN ACS)
;SKIPS IF DOESN'T HANG
MEMXCT:	PUSH P,A
	PUSHJ P,STEPCX	;MAKE SURE CHAN IS SELECTED
	POP P,A
	MCONO SA0,RDBITS
	MDATSZ SA0,100000	;IS MC-ADR-ACK-IN STUCK ON?
	POPJ P,			;YES, GIVE ERR
	MDATAO SA0,A	;SET UP MEM GO INST
	MOVEI MXACS
	BLT MXACS+MXPRGL-1	;SAVE ACS
	MOVSI MXPRGL-1,MXPRG
	BLT MXPRGL-1,MXPRGL-1	;LOAD WAIT PROG
	HLL MXCO1,DCONO	;SET UP PROPER DEV CODE
	TLZ MXCO1,37
	HLL MXCO2,MXCO1
	HLL MXCO3,MXCO1
	HLL MXDI1,DDATAI
	HLL MXDI2,MXDI1
	HLL MXDO1,DDATAO
	JRST MXWTL	;RUN SA10 FROM ACS

;WAIT PROG
MXPRG:	PHASE 0
MXWT0:!	HRRO CNT,TEM	;SAVE STATUS BEFORE RESET
MXCO3:!	CONO SA0,RSTSA	;RESET TO MAKE SURE MEM NOT HUNG
MXWTL:!
MXCO1:!	CONO SA0,SASTEP!RDCCI
MXDI1:!	DATAI SA0,TEM
	ANDI TEM,1777
MXDO1:!	DATAO SA0,TEM	;MAKE NEXT STEP A NO-OP
MXCO2:!	CONO SA0,RDBITS
MXDI2:!	DATAI SA0,TEM
	TRNE TEM,100000	;DID WE GET ADR ACK YET?
	JRST MXDON	;YES, RETURN
	SOJG CNT,MXWTL	;WAIT A WHILE
	JUMPGE CNT,MXWT0	;RESET & WAIT A BIT ON INITIAL TIMEOUT
	JRST MXDON	;THEN RETURN
TEM:!	0
CNT:!	^D100
MXPRGL:!DEPHASE

MXACS:	BLOCK MXPRGL

MXDON:	TRNN TEM,100000
	ADDI CNT,1	;COMPENSATE FOR SOJG
	MOVEM CNT,MXACS	;KEEP COUNT AFTER
	MOVSI MXPRGL-1,MXACS
	BLT MXPRGL-1,MXPRGL-1	;RESTORING ACS
	HRRZM MEMSTS#
	JUMPLE STEPX	;NON-SKIP IF TIMED OUT
	MOVEI A,10
MXWT2:	MCONO SA0,SASTEP	;STEP UNTIL MEM CTRL FINISHED
	MCONO SA0,RDCONI
	MDATSZ SA0,PARERR	;PAR ERR?
	JRST MXOKX		;YES, CALL THAT A SUCCESS
	TLNE DD,1		;FINISHED?
	SOJG A,MXWT2		;NO, WAIT SOME MORE
	JUMPLE A,STEPCX		;NON-SKIP IF TIMED OUT
MXOKX:	AOS (P)
	JRST STEPCX		;MAKE SURE CLOCK STOPPED ON THIS CHAN
;CHANNEL-MEMORY TEST
CMT:	MOVE A,CIN	;NUMERIC ARGUMENT
	PUSHJ P,CSET
	MOVE E,ADRLO
CMTA:	MOVE A,E
	PUSHJ P,MAPAL
	MOVEM E,(A)	;FILL MEMORY WITH .
	ADDI E,1
	AOBJN A,.-2
	CAMG E,ADRHI
	JRST CMTA
CMT0:	MOVE E,ADRLO
	MOVEI A,0	;MAKE SURE WE MAP FIRST TIME
CMT1:	PUSHJ P,RND
	AOBJN A,CMT1A
	PUSHJ P,CHKCNC
	JRST CI0
	MOVE A,E
	PUSHJ P,MAPAL
CMT1A:	MOVEM B,(A)
	DPB E,[2600,,CMTP0]
	MOVE C,[MOVE CMTP0]
	PUSHJ P,CMTG
	CAME B,CMTPT
	JRST CMT1E0
	SETCAM B,CMTPT
	MOVE C,[MOVE CMTP1]
	DPB E,[2600,,CMTP1A]
	PUSHJ P,CMTG
	MOVE F,(A)
	EQV B,F
	JUMPN B,CMT1E1
	ADDI E,1
	CAMG E,ADRHI
	JRST CMT1
	MOVEI B,"."
	JRST TYO

CMTG:	MOVEM C,@CBASE
	MCONO SA0,@STBSYC
CMTG0:	MCONSO SA0,600170
	JRST CMTG0
	MCONSZ SA0,600000
	JRST CMTGE
	MCONO SA0,@CLSTFC
	POPJ P,
CMTGE:	PUSHJ P,DSPE1
	JRST CI0

CMTP0:	40000,,0	;LAC X (X FILLED IN ABOVE)
	440000,,CMTPT	;DAC CMTPT
	0

CMTP1:	40000,,CMTPT	;LAC CMTPT
CMTP1A:	440000,,0	;DAC XX (XX FILLED IN ABOVE)
	0

CMTPT:	0
CMT1E0:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#101-/]
	[ASCIZ /CPU WROTE /]
	SAVB
	[ASCIZ /, SA-10 READ /]
	CMTPT
	[ASCIZ / AT ADDR /]
	E
	0
	CI0

CMT1E1:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#102-/]
	[ASCIZ /SA-10 WROTE /]
	CMTPT
	[ASCIZ /, CPU READ /]
	F
	[ASCIZ / AT ADDR /]
	E
	0
	CI0
;DISK TEST INTERRUPT CODE FOR DSKT BELOW
;JSR HERE ON CH 1 INT, SET UP AT START OF DSKT
DSKI:	0
	MOVEM 17,ACS+17
	MOVEI 17,ACS
	BLT 17,ACS+16
IFE P-17,<	MOVE P,ACS+P		;USE SAME PDL AT PI LEVEL>
IFE BF-17,<	MOVE BF,ACS+BF>
	MCONI SA0,A
	TRNN A,PIRQ
	JRST DSKIE
	TRNE A,PARERR+NXM
	JRST DSPE
	TRNE A,170
	JRST DSI0
DSKIE:	MOVEI C,[ASCIZ /UNKNOWN INT. CONI=%A
/]				;INT ON CH 1, NOT FROM SA10
	PUSHJ P,STYO
	JRST DSKXX

DSKX1:	MCONO SA0,@STBSYC
DSKX1A:	MOVE B,ICHAN
	LSH B,3
	MCONO SA0,CLSTF+SA0CH(B)
DSKEX:	MOVEM BF,ACS+BF
	MOVSI 17,ACS
	BLT 17,17
	JRST 12,@DSKI

DSPE1:	MCONO SA0,10
	MDATAI SA0,D		;ADDR
	MCONO SA0,20
	MDATAI SA0,A
	HLRZM A,E		;CH
	MCONO SA0,30
	MDATAI SA0,F
	HRLM A,F		;WORD
	MOVE G,(D)		;WORD IN MEM
	MOVEI C,[ASCIZ /NON EX MEM ON CH %E
ADDR=%D MEM HAS %G CHNL GOT %F
/]
	MCONSZ SA0,PARERR	;SELECT PARITY ERR OR NXM MSG
	MOVEI C,[ASCIZ /MEM PAR ERR ON CH %E
ADDR=%D MEM HAS %G CHNL GOT %F
/]
	JRST STYO

DSPE:	PUSHJ P,DSPE1
	LSH E,3			; CHANNEL NUMBER CAUSING INTERRUPT

	MCONO SA0,RSTCH+40(E)
	MCONO SA0,CLMERR+SA0CH
	JRST DSKEX

DSKXX:	SKIPE SERR
	JSR GOPR
	JRST DSKT0
;HERE ON SA10 INT

DSI0:	ROT A,-3-4	;STAT FLAGS TO HIGH A
	JFFO A,.+1	;CHAN # TO B
	MOVEM B,ICHAN#	;SAVE FOR EXIT CONO
	MOVE A,B
	LSH A,2
	ADD A,BASEA	;COMPUTE BASE ADR
	LDB D,[DEVFLD,,1(A)]
	LDB E,[241000,,1(A)]
	MOVE G,D
	SUB G,IDEVA
	JUMPL G,DSI0E
	CAMN B,CHAN
	CAILE G,NPACKS-1
	JRST DSI0E	;BAD CHAN OR UNIT #
	MOVE A,@CBASE+1
	TLNE A,163014		;SELECT ERR,BIPERR,CONTROL ERR,PROG INT,
				; ATTN, UNIT CK, UNIT EXCEPTION
	JRST DSE1		;BAD BITS IN STATUS
	TLNE A,100
	JRST DSIBSY		;POSS CU BUSY
	TLNE A,200
	JRST DSKX2		;CU END, RESTART CHAN
	TLNN A,20		;DEV END
	JRST DSI5		; NO.
	MOVE B,TIME		; OK. UPDATE TIME OF RECENT INTERRUPT.
	EXCH B,HUNGT(G)		; FOR THIS DRIVE
	SKIPN OFFLIN(G)		; IF IT HAD BEEN OFF LINE, OR
	AOJN B,DSI0A		; IF IT HAD BEEN HUNG,
	MOVSI B,10		; SET FLAG TO COMMENT ON ITS REVIVAL
	IORM B,CHCW(G)		; AT MAIN PROGRAM LEVEL
	SETZM	OFFLINE(G)		;AND CLEAR THE OFFLINE FLAG.
DSI0A:	TLNE A,4000		; LENGTH ERROR HERE IS BAD
	JRST DSE1		; ..
	MOVE B,CHCW(G)
	TLNE B,(1B10)
	JRST DSKX2		;WAITING ON DEV BUSY - RESTART
	TLNN A,40
	JRST DSKRX		;NO CHN END - RESTART
	MOVSI B,1		; YES. CLEAR BIT IN STATUS WORD FOR DRV
	TDZ BF,BITS(G)		; AND IN LIGHT-WATCHER WORD.
	ANDCAB B,CHCW(G)
	TLNE B,(1B10)
	JRST DSKX2	;WAITING ON DEV BUSY - RESTART
DSI5:	MOVE A,CHCW(G)
	TLNN A,10
	JRST DSI5A
	MOVE A,D
	PUSHJ P,SENSEX
	XCT GPHADR
	MOVEM A,PHADR(G)
	MOVE A,CHCW(G)
DSI5A:	TLNE A,7		; MAIN PROG WAIT OR DEV END WAIT?
	JRST DSKX1		; YES, DISMISS
	MOVE B,G		; NO, PROCESS THIS INT.
	ADD B,IDEVA
	HRR BF,B		; FOR LIGHT WATCHERS
	HRRZM B,DEVN
	JRST (A)		;DISMISS VIA FINITE STATE MACHINE

DSIBSY:	TLNN A,400		; STATUS MODIFIER?
	JRST DSIB1		;NO STATUS MOD, DEVICE BUSY
	MOVSI B,(1B11)
DSFLGX:	IORM B,CHCW(G)		;MARK CU BUSY
	JRST DSKX1		;& LEAVE IT

DSKX2:	MOVSI A,-NPACKS
	MOVSI B,(1B10!1B11)
DSKRL:	TDNN B,CHCW(A)		;RESTART ALL DRIVES WITH CU OR DEV BUSY
	JRST DSKRS2
	ANDCAM B,CHCW(A)
	MOVE C,CPGP(A)
	MOVEM C,DEVL(A)
DSKRS2:	AOBJN A,DSKRL
	JRST DSKX1		;CLEAR STATUS FLAG, RESTORE AC'S, DISMISS INT.

DSIB1:	MOVSI B,(1B10)
	TLNN A,260		; DEVICE BUSY. WITH OTHER STATUS?
	JRST DSFLGX		;NO, MARK DEV BUSY
DSKRX:	MOVE B,CPGP(G)		; YES. PREVIOUS CU BUSY IS NOW OVER
	MOVEM B,DEVL(G)
	JRST DSKX2		;TRY CMD AGAIN IF CU END IN INIT STAT

DSI0E:	MOVE G,B	;STYO CLOBBERS B
	MOVEI C,[ASCIZ /SA-10 CHAN %G STATUS %E FROM DEV %D
/]
	PUSHJ P,STYO
	JRST DSKX1A
;CALLED AT THESE TAGS FROM INT ROUTINE WITH CHCW(DRIVE) IN A.
; BITS IN LH MEAN:
;B1: RANDOM TRACK AND HEAD
;B2: DO WRITES
;B3: DO READS
;B4: RE-FILL DATA, CHECK DATA
;B5: RANDOM CORE ADDR ON RD AND WRITE
;B6: TEST THIS DRIVE AT ALL.
;B7-8 - COUNT THRU SURFACE VERIFIER PATTERNS: 00=ZEROES, 01=ONES,
;	1X=WORST CASE PATTERN.
;B9 - USE VERIFIER, NOT RANDOM TRK AND DATA
;B17: WAITING FOR DEVICE END
;B16: REQUESTS MAIN PROG TO FILL WITH NEW DATA
;B15: REQUESTS MAIN PROG TO CHECK DATA
;B14: DRIVE CAME BACK UP AFTER HANG.
;B13: RETRYING CORRECTABLE DATA CHECK
;B12: COMPLEMENT PATTERN
;B11: CU BUSY RECEIVED
;B10: DEVICE BUSY RECEIVED

DIP0:	TLNN A,(1B9)		; NOT RANDOM IF SURFACE VERIFYING
	TLNN A,200000		; OK, RANDOM IF REQUESTED BY B1
	JRST DIP1
	PUSHJ P,RNDTK
	MOVEM C,TRK(G)
DIP1:	TLNN A,(1B9)		; DON'T RANDOMIZE IN SURFACE VERIFIER
	TLNN A,10000		; RANDOM CORE ADDR REQUESTED? (WRITE)
	JRST DIP1A
	PUSHJ P,RNDAD
	MOVEM C,ADDR(G)
DIP1A:	TLNN A,20000		; RE-FILL DATA AREA?
	JRST DIP1B
	MOVSI B,2
	JSP F,DIMP		; REQUEST MAIN PROG TO FILL DATA
DIP1B:	TLNN A,100000		; WRITE THE DATA?
	JRST DIP2
	MOVEI C,5		; WRITE DATA OPCODE
	PUSHJ P,DIRW		; DISK INT, READ/WRITE RTN
	MOVE A,NWTRAK(G)
	ADDM A,NWRITE(G)	; COUNT WORDS WRITTEN
	JSP F,DIGO
DIP2:	TLNN A,(1B9)		; DON'T RANDOMIZE ADR IN SURF VERIFY
	TLNN A,10000		; RANDOM CORE ADDR? (READ)
	JRST DIP2A
	PUSHJ P,RNDAD
	MOVEM C,ADDR(G)
DIP2A:	TLNN A,40000		; DO READS?
	JRST DIP3
	MOVEI C,6		; READ DATA OPCODE
	PUSHJ P,DIRW
	MOVE A,NWTRAK(G)
	ADDM A,NREAD(G)		; COUNT WORDS READ
	JSP F,DIGO
DIP3:	TLNE A,40000		; READING?
	TLNN A,20000		; YES. WANT DATA CHECKED?
	JRST DIP0		; NO TO ONE OF THOSE. DON'T CHECK
	MOVSI B,4		; REQUEST MAIN PROG TO CHECK DATA
	JSP F,DIMP
	JRST DIP0
DIGO:	HLL F,CHCW(G)
	TLO F,1
	MOVEM F,CHCW(G)
	IOR BF,BITS(G)		; FLAG BUSY FOR LIGHTS WATCHERS
	JRST DSKX2

DIMP:	HRRM F,CHCW(G)
	IORM B,CHCW(G)
	JRST DSKX1

RNDTK:	PUSHJ P,RND
	TLNE B,7
	JRST RNDT1		;MAKE CYL RANDOM ONLY 1/8 OF THE TIME
RNDTK0:	SKIPL UWP(G)
	JRST RNDT3
	MOVE C,NTRAKS(G)	;CYLS * SURFS
	SUB C,NSTRAK(G)		;- # TO AVOID
	IDIV B,C
	ADD C,NSTRAK(G)		;OFFSET
	JRST RNDT2		; MAKE SURE NOT A BADSPOT

RNDT1:	MOVE D,TRK(G)
	CAMGE D,NSTRAK(G)
	JRST RNDTK0		;POINTING AT PROTECTED TRACK - MAKE NEW
	IDIV B,DSETSU(G)		;RANDOM HEAD ONLY
	IDIV D,DSETSU(G)		;GET OLD HEAD
	SUB C,E	;NEW-OLD
	ADD C,TRK(G)
	SKIPGE UWP(G)
	JRST RNDT2
	CAMGE C,NUTRAK(G)	;UCYLS * SURFS
	JRST RNDT3
RNDT2:	MOVE D,C		; TRACK*19+HEAD
	HRL D,G			; DRIVE
	MOVSI E,-NBADSP		; COUNT THRU BAD SPOTS TABLE
RNDT2L:	SKIPGE SPOTTB(E)	;A SPOT IN TABLE?
	POPJ P,0		;NO, SO SELECTED ONE IS OK
	CAMN D,SPOTTB(E)	;YES. SAME AS SELECTED ONE?
	JRST RNDTK		;YES. DON'T USE IT. PICK ANOTHER
	AOBJN E,RNDT2L		;NO, SEE IF ANY MORE
	POPJ P,

RNDT3:	IDIV B,NXTRAK(G)	;(CYLS - UCYLS) * SURFS
	ADD C,NUTRAK(G)
	JRST RNDT2
RND:	MOVEI B,105
	FMPB B,RNDM
	POPJ P,
RNDM:	123456,,654321

RNDAD:	MOVE D,ADRHI
	SUB D,ADRLO		;SIZE OF BUFFER AREA
	SUB D,NWTRAK(G)	;SUBTRACT BUFFER SIZE
	PUSHJ P,RND
	IDIV B,D
	ADD C,ADRLO	;CREATE CANDIDATE BUFFER ADDRESS
	MOVE D,C
	ADD D,NWTRAK(G)	;ADDRESS JUST PAST PROPOSED BUFFER
	MOVE E,C
	SUB E,NWTRAK(G)
	MOVSI B,-NPACKS
RNDAD3:	SKIPE OFFLIN(B)
	JRST RNDAD5	;IGNORE OFFLINE DRIVE
	CAMGE E,ADDR(B)	;SKIPS IF BELOW CANDIDATEE BUFFER
	CAMG D,ADDR(B)	;DOESN'T SKIP IF ABOVE CANDIDATE BUFFER
	JRST RNDAD5	;NO CONFLICT
	JRST RNDAD	;CONFLICT, TRY ANOTHER CANDIDATE

RNDAD5:	AOBJN B,RNDAD3
	POPJ P,	;ADDR IN C
PBITS:	JUMPE E,CPOPJ
	TRNN E,1
	JRST PBIT1
	TLON D,400000
	JRST PBIT2
	MOVEI B,"+"
	PUSHJ P,TYO
PBIT2:	MOVE C,(D)
	PUSHJ P,STYO
PBIT1:	LSH E,-1
	AOJA D,PBITS

SNSMSG:	[ASCIZ /STATISTICS/]
	[ASCIZ /2-2/]
	[ASCIZ /CORRECTABLE/]
	[ASCIZ /2-0/]
	[ASCIZ /INCOMPLETE/]
	[ASCIZ /WRITE INHIBIT/]
	[ASCIZ /FILE PROTECT/]
	[ASCIZ /NO RECORD FOUND/]
	[ASCIZ /1-3/]
	[ASCIZ /CYLINDER END/]
	[ASCIZ /TRACK OVERRUN/]
	[ASCIZ /PERMANENT ERROR/]
SNS2MS:	[ASCIZ /0-7/]
	[ASCIZ /0-6/]
	[ASCIZ /OVERRUN/]
	[ASCIZ /DATA CHECK/]
	[ASCIZ /EQUIPMENT CHECK/]
	[ASCIZ /BUS OUT PARITY CHECK/]
	[ASCIZ /INTERVENTION REQUIRED/]
	[ASCIZ /COMMAND REJECT/]
STAMSG:	[ASCIZ /UNIT EXCEPTION/]
	[ASCIZ /UNIT CHECK/]
	[ASCIZ /DEVICE END/]
	[ASCIZ /CHANNEL END/]
	[ASCIZ /BUSY/]
	[ASCIZ /CONTROL UNIT END/]
	[ASCIZ /STATUS MODIFIER/]
	[ASCIZ /ATTENTION/]
	[ASCIZ /PROG INT FLAG/]
	[ASCIZ /LENGTH ERROR/]
	[ASCIZ /BIT 5?/]
	[ASCIZ /SA10 CONTROL SEQ CHECK/]
	[ASCIZ /BUS IN PARITY CHECK/]
	[ASCIZ /SELECT ERROR/]
;DISK INTERRUPT, READ OR WRITE TO BE DONE. OPCODE IN C.

DIRW:	MOVSI A,2000
	MOVE B,CPGP(G)
	MOVEM B,DEVL(G)
	HRLI B,200000		;TCH
	LSH C,^D20		; TO OPCODE FIELD (RD OR WRT)
	MOVE D,DEVN		; DEVICE WHICH CAUSED THIS INTERRUPT
	LSH D,^D12
	TLC D,162034		;SEEK, CHAINED
	MOVE E,TRK(G)
	IDIV E,DSETSU(G)
	LSH E,^D20
	LSH F,4
	IOR E,F
	ADDI B,4
	MOVEM D,-4(B)		;STORE SEEK
	MOVSI F,<-6>_CNTSFT
	HRRI F,177(B)
	MOVEM F,-3(B)		;PTR TO SEEK ARG
	SETZM 177(B)		;BB
	TLC D,2220		;MAKE SET SECTOR
	MOVEM D,-2(B)
	MOVE F,[<<-1>_CNTSFT>,,[0]]	; ONE BYTE OF ZERO FOR SECTOR NUMBER
	MOVEM F,-1(B)		;PTR TO SECTOR
	TLC D,110		;MAKE SRCH ID =
DIRW1:	MOVEM D,(B)		;STORE SRCH
	MOVSI F,<<-5>_CNTSFT>
	ADDI F,200(B)
	MOVEM F,1(B)		;STORE DCW FOR SEARCH
	MOVEM B,2(B)		;STORE TCH *-1 WHILE SRCH FAILS
	TLZ D,21774		; THEN DO THE RD OR WRT
	XOR D,C			; PUT RD OR WRT OPCODE INTO CMD
	ADD D,NATRAL	;USE NATURAL MODE IF AVAILABLE
	MOVEM D,3(B)		;STORE CMD
	MOVN F,CRECL	;RECORD LENGTH
	LSH F,CNTSFT+22
	ADDI F,(A)
	ADD F,ADDR(G)		; BASE ADDR OF DATA AREA FOR THIS PACK
	MOVEM F,4(B)		;STORE DCW
	TLZ D,221774
	TLC D,20304		; CONVERT BACK TO "SEARCH ID EQUAL"
	MOVEM E,200(B)		;STORE CCHH
	MOVEM A,201(B)		;STORE REC #
	ADDI B,5		; COMMAND WORDS PER RECORD
	ADD A,[2000,,0]
	ADD A,CRECL
	CAMGE A,DIRW1V(G)	; RECORDS PER TRK. FILLED TRACK?
	JRST DIRW1			; NO. GO DO ANOTHER RECORD
	SETZM (B)		; YES. DONE. STORE HALT
	MOVSI F,40000
	ANDCAM F,-2(B)		;UNCHAIN LAST CMD
	POPJ P,

NATRAL:	0
;HERE IF BUSY, NOT STATUS MOD, NOT CU END.
;HERE IF WRONG DEVICE INTERRUPTS.
;HERE IF "BAD BITS" IN CONI OR STATUS WORD (CHANNEL ERRORS)
DSE1:	SETOM SENSED		; IN CASE NO SENSE DONE
	HRLZ A,CBASE		; COPY THE 4 WORDS FROM LOW CORE
	HRRI A,DSTAT		; FORM BLT POINTER
	BLT A,DSTAT+3		; BEFORE DOING SENSE
	LDB A,[141000,,DSTAT+1]	; DEV CAUSING INT
	HLL A,DSTAT+1		; SEE IF UNIT CHECK
	TLNE A,10		; ..
	PUSHJ P,SENSEX		; YES. DO A SENSE.
	MOVE E,SENSED
	TLNE E,200010
	JRST DSEOFL	;DROPPED OFF LINE OR WRT PROT
	LDB E,[POINT 4,SENSED+1,27]	; SUPPRESS ERROR TYPEOUT ON SOME OF
	CAIE E,5		; THE CORRECTABLES, IN REPEATS.
	JRST DSE4		; NOT A CORRECTABLE
	MOVE E,SENSED
	TRNE E,200000
	JRST DSKT0		;FILTER OUT DUPLICATE REPORTS IN FORCED-LOGGING  MODE
	MOVE E,RETRYC(G)	; CORRECTABLE. FIRST OR LAST?
	CAIE E,NRETRY
	CAIN E,0		; ..
	SKIPA			; YES.
	JRST DSKCDC		; NO. DON'T TYPE THE SENSE STUFF
DSE4:	PUSHJ P,PTIME		; TIME-STAMP THE ERROR
	LDB A,[420200,,DSTAT+1] ; GET 0=END,1=INIT,2=ASYNC,3=DUMMY
	MOVE C,STTT(A)		; WHAT KIND OF STATUS STORED
	PUSHJ P,STYO
	LDB D,[141000,,DSTAT+1]	; DEVICE NUMBER
	MOVEI C,[ASCIZ / STATUS, DEVICE %D =
/]
	PUSHJ P,STYO
	LDB E,[241600,,DSTAT+1] ;FOURTEEN STATUS BITS FRM 1ST WD
	MOVEI D,STAMSG
	PUSHJ P,PBITS
	MOVE D,DSTAT+2
	MOVE E,TRK(G)		; WHERE SHOULD IT HAVE BEEN?
	IDIV E,DSETSU(G)		; CYL TO E, HD TO F
	MOVEI C,[ASCIZ /
SW2=%D , CYLINDER %E, HEAD %F
/]
	PUSHJ P,STYO
	MOVE A,DSTAT+1
	TLNN A,10		; UNIT CHECK?
	JRST DSKXX		; NO, RESTART
DSE2:	MOVEI C,[ASCIZ /SENSE: /]
	PUSHJ P,STYO
	MOVE E,SENSED
	AOJE E,[HRROI C,[ASCIZ \MISSING
\]
		PUSHJ P,STYO
		JRST DSKXX]
	LDB E,[202400,,SENSED]
	LDB A,[POINT 6,SENSED+1,7]	;BYTE 4 TELLS WHAT DRIVE
	PUSHJ P,DPHADR		; PRINT PHYS ADR LETTER OR "?"
	PUSHJ P,CR
	MOVEI D,SNSMSG
	PUSHJ P,PBITS
	PUSHJ P,PSB
	MOVE E,SENSED		; SEE IF OFF LINE
	TLNE E,(1B1)		; ..
	SETOM OFFLIN(G)		; YES, FLAG NOT TO RUN IT.
	LDB E,[202400,,SENSED]	; FIRST TWENTY BITS OF SENSE DATA
	CAIN E,1		;STATISTICS?
	JRST DSKT0		;YES. NOT A FATAL ERROR, DON'T GET OPR
	CAIN E,100004		;SKIP UNLESS CORRECTABLE DATA CHECK
	JRST DSKCDC		;PRINT WHERE THE ERROR WAS
	AOS A,ERRCT(G)		; COUNT "OTHER" ERRORS
	CAMGE A,MAXBER		; MORE THAN MAX BAD ERRORS?
	JRST DSE5		; NO
	SETOM OFFLIN(G)		; YES. SHUT IT DOWN.
	MOVEI D,(G)		; TELL THE WORLD
	MOVEI C,[ASCIZ /
*** DRIVE %D EXCESSIVE ERRORS. MARKED OFF LINE, /]
	PUSHJ P,STYO
	PUSHJ P,PTIME
DSE5:	JRST DSKXX		; GET OPR OR RESTART.

DSEOFL:	MOVEM E,OFFLIN(G)	;MAKE OFF-LINE & SAVE REASON
	SETOM HUNGT(G)	;DISABLE TIMEOUT
	MOVE B,CHCW(G)
	TLZ B,127	;CLEAR WAITING STATES
	TLO B,10	;GET MESSAGE FROM PROG
	HRRI B,DIP0	;START FROM FRONT IF IT COMES BACK
	MOVEM B,CHCW(G)
	TDZ BF,BITS(G)	;CAN'T BE BUSY NOW
	JRST DSKX1	;DISMISS INT

MAXBER:	EXP ^D50
; CALL WITH DRIVE CODE IN A

DPHADR:	PUSH P,A
	MOVEI C,[ASCIZ /DRIVE /]
	PUSHJ P,STYO
	POP P,A
DPHAD0:	PUSHJ P,DPHLOK
	SKIPA B,["?"]
	MOVEI B,"A"(B)
	JRST TYO

DPHLOK:	ANDI A,377
	MOVE B,A
	PUSHJ P,CNTBB
	CAIN 4
	JRST DPHBIN
	CAIN 1
	JRST DPHUN
	MOVE B,A
	ANDI B,77
	PUSHJ P,CNTBB
	CAIE 3
	POPJ P,
DPHBIN:	MOVE B,A
	ANDI B,7
	JRST CPOPJ1

DPHUN:	ROT A,-10
	JFFO A,CPOPJ1

CNTBB:	ROT B,-4
	MOVE BCTAB(B)
	HRRI B,0
	ROT B,4
	ADD BCTAB(B)
	POPJ	P,

BCTAB:	EXP 0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4

GPHADR:!
DRVTYP:	LDB A,[POINT 8,SENSED+1,7]
DRVTY0:	PUSH P,C
	PUSHJ P,DRVTY1
	POP P,C
	JRST STYO

DRVTY1:	MOVEI D,(G)
	MOVEI C,[ASCIZ /UNIT %D(/]
	PUSH P,A
	PUSHJ P,STYO
	POP P,A
	PUSHJ P,DPHAD0
	MOVEI B,")"
	JRST TYO
DSENS1:	DPB D,[141000,,PNOP]	; SAME SUBR BUT DO NOP FIRST
	MOVEI A,PNOP		;TO GET UP-TO-DATE SENSE DATA
SARNX0:	PUSHJ P,SARUNX		;RUN PROG, NEVER SKIP
	POPJ P,
	POPJ P,

PNOP:	BYTE (8) 240,3,IDEV,0
	0

STTT:	[ASCIZ /ENDING/]
	[ASCIZ /INITIAL/]
	[ASCIZ /ASYNC/]
	[ASCIZ /DUMMY/]

DSKCDC:	AOS NCORDC(G)		; COUNT CORRECTABLE DATA CHECKS
	MOVSI A,(1B13)		; FLAG CORRECTABLE CHECK
	IORB A,CHCW(G)		; IN DRIVE STATUS WORD
	SOS D,RETRYC(G)		; COUNT DOWN RETRIES
	CAIN D,NRETRY-1		; IF THIS IS FIRST ERROR,
	JRST DSKWHR		; GO REPORT ITS LOCATION
	JUMPGE D,DSKWHX		; IF NOT COUNTED OUT, QUIT HERE.
	MOVEI D,NRETRY		; CALL IT PERMANENT
	MOVEI C,[ASCIZ /*** DATA CHECK AFTER $D RE-READS.
/]
	PUSHJ P,STYO		; COMPLAIN, FALL INTO FULL REPORTER
DSKWHR:	LDB D,[POINT 4,SENSED+1,27]	; SENSE FORMAT DESCRIPTOR
	CAIE D,4		;IF 4 OR 5, GIVES POSITIONS.
	CAIN D,5		; ..
	JRST DSKWH1		; GOOD
	MOVEI C,[ASCIZ /SENSE BYTE FORMAT IS %D, SHOULD BE 4 OR 5.
/]
	PUSHJ P,STYO
	JRST DSKWHX		;GIVE UP
DSKWH1:	LDB D,[POINT 16,SENSED+2,15]	; CYL
	LDB E,[POINT 16,SENSED+2,31]	; HEAD
	MOVEI C,[ASCIZ /ERROR REPORT: DRIVE %G, CYLINDER %D, HEAD %E/]
	PUSHJ P,STYO
	LDB D,[POINT 8,SENSED+3,7]	; RECORD
	LDB E,[POINT 8,SENSED+3,15]	; SECTOR
	LDB F,[POINT 8,SENSED+3,23]	; OFFSET
	MOVEI C,[ASCIZ /
   RECORD %D, SECTOR %E, OFFSET %F
/]
	PUSHJ P,STYO
DSKWHX:	JRST DSKT0

PHADRT:	EXP 70,61,52,43,34,25,16,07	;WIERD NAMES OF DRIVES

WRTPP:	BYTE (8)70,SEEK,IDEV
	IOW 6,WRTPPD
WRTPP1:	BYTE (8)70,SCHIDE,IDEV
	IOW 5,WRTPPD
	MOVE WRTPP1	;TIC
WRTPP2:	BYTE (8)50,WRDATA,IDEV
	IOW 10,WRTPPD
WRTPPD:	0
	0
; ROUTINE TO PRINT ERROR STUFF FOR TAPE TEST

TSPE1:	SETOM TAPF		; FLAG TAPE, NOT DISK
	MOVE A,@CBASE+1
	PUSHJ P,PSTAT
	MOVE D,@CBASE+2
	MOVEI C,[ASCIZ /
SW2=%D
/]
	PUSHJ P,STYO
	LDB A,[DEVFLD,,@CBASE+1]
	PUSHJ P,SENSEX
	MOVEI C,[ASCIZ /SENSE: /]
	PUSHJ P,STYO
	MOVE E,SENSED
	AOJE E,[HRROI C,[ASCIZ \MISSING
\]
		PUSHJ P,STYO
		JRST QTT0]
	LDB E,[202400,,SENSED]
	MOVEI D,SNSMSG
	LDB E,[242000,,SENSED]	;SIXTEEN BITS OF SENSE DATA
	MOVEI D,TAPSNS
	PUSHJ P,PBITS
	PUSHJ P,PSB
	POPJ P,0
SETHI:	CONO APR,@NXMCLR
	MOVEI D,40000
SETH0:	SKIPL CPU
	JRST SETHIL
	MOVE A,(D)
	TLNN D,1
SETH1:	CONSZ APR,@NXMBIT
	JRST SETHX
	ADDI D,40000
	TLNN D,20
	JRST SETH0

SETHX:	CONO APR,@NXMCLR
	SUBI D,1
	CAMN D,ADRHI
	POPJ P,
	MOVEM D,ADRHI
	MOVEI C,[ASCIZ /LAST WORD OF MEMORY IS %D
/]
	JRST STYO

SETHIL:	PUSHJ P,MAPAD
	MOVE A,(A)
	JRST SETH1

MAPAD:	MOVE A,D
MAPA:	SKIPGE CPU
	POPJ P,	;NO MAPPING NEEDED FOR KA
	ROT A,-^D9
	IORI A,700000
IFE MAPPG&1,<HRLM A,EPT+MAPPG/2>
IFN MAPPG&1,<HRRM A,EPT+MAPPG/2>
	XCT CLRPGT
	HRRI A,MAPPG
	ROT A,^D9
	POPJ P,

MAPADL:	MOVE A,D
MAPAL:	PUSHJ P,MAPA
	HRL A,A
	TLO A,-1000
	POPJ P,
;FIGURE OUT WHICH KIND OF CPU AND INITIALIZE
SETCPU:	MOVNI A,1
	HRLOI -2
	AOBJP SETCP2
	SETZB A
	BLT
	JUMPE SETCP2
	MOVEI A,1
SETCP2:	MOVEM A,CPU#	;-1 KA, 0 KI, 1 KL
	MOVE CPUTBL+1(A)
	BLT ECPUTB-1
	PUSHJ P,TRPINI
	JRST CPUINI

;SET UP TRAP AND INTERRUPT LOCS
TRPINI:	XCT APRST
	XCT PIRST	;MAKE SURE NOTHING HAPPENING
	MOVSI A,-NPTBS	;PREPARE NULL MAP FOR ALL 3 EXEC REGIONS
TRPI1:	MOVE B,PTWRD(A)
	MOVE C,PTPNT(A)
TRPI2:	MOVEM B,(C)
	ADD B,[2,,2]
	AOBJN C,TRPI2
	AOBJN A,TRPI1
	MOVE A,[JSR UUOH]
	MOVEM A,41	;INITIALIZE MAGIC MEMORY LOCATIONS
	MOVEI A,MUUOH
	MOVSI B,-10
	MOVEM A,UPT+430(B)	;ADDRESS FOR MUUO'S
	AOBJN B,.-1
	MOVSI B,-4
	MOVSI A,(<JFCL>)
	MOVEM A,EPT+420(B)	;IGNORE TRAPS (MUST SET TRP ENB FOR MAP)
	AOBJN B,.-1
	MOVE A,[JSR MPE1]
	MOVEM A,61
	SETZM MPERF
	MOVE A,[JSR PAGEH]
	MOVEM A,UPT+420	;FOR PAGE FAULTS
	MOVE A,[JSR PDLH]
	MOVEM A,UPT+422	;FOR PDL OVERFLOW
	MOVEI A,PAGEKL
	MOVEM A,UPT+502
	MOVE A,[JSR KLCLK]
	MOVEM A,EPT+.EPTII
PISET:	MOVE A,[JSR INT1]
	MOVEI B,42	;ALL INTERRUPT ROUTINES ARE SAME LENGTH
PISETL:	MOVEM A,(B)
	ADDI A,INT2-INT1
	ADDI B,2
	CAIE B,60
	JRST PISETL
	POPJ P,

PTWRD:	500400,,500401
	500340,,500341
	500000,,500001
NPTBS==.-PTWRD

PTPNT:	-200,,EPT+200
	-20,,UPT+400
	-160,,EPT+600
CPUTBL:	KATBL,,CPUTAB
	KITBL,,CPUTAB
	KLTBL,,CPUTAB

CPUTAB:!
APRST:	0
PIRST:	0
NXMBIT:	0
NXMCLR:	0
PETST:	0
MEENB:	0
PDLTST:	0
CLKCF:	0
CLKSKP:	0
CLKENB:	0
CLRPGT:	0
IORST:	0
CPUINI:	0
CKTYI0:	0
TYOSKP:	0
TYOGO:	0
RDSWS:	0
ECPUTB:!

KATBL:	CONO APR,675550
	CONO PI,711577
	10000
	10000
	CONSZ PI,200000
	CONO PI,40000
	CONSZ APR,200000
	CONO APR,1000
	CONSO APR,1000
	CONO APR,2000+APRCH
	JFCL
	PUSHJ P,RSTAI
	JRST KAINI
	JRST CKTIAI
	CONSZ TTY,20
	DATAO TTY,B
	DATAI	APR,DD

KITBL:	CONO APR,725300
	CONO PI,731577
	100
	100
	CONSZ APR,200000
	CONO PI,40000
	CAIA
	CONO APR,1000
	CONSO APR,1000
	CONO APR,2000+APRCH*11
	DATAO PAG,[400000+UPT/1000,,420000+EPT/1000]
	PUSHJ P,RSTAI
	JRST KIINI
	JRST CKTIAI
	CONSZ TTY,20
	DATAO TTY,B
	DATAI	APR,DD

KLTBL:	CONO APR,267760
	CONO PI,31577
	2000
	22400
	CONSZ APR,4700
	CONO APR,106700+APRCH
	CAIA
	CONO TIM,TO.SIT!TO.CTD!^D2000
	CONSO TIM,TI.ITD
	CONO MTR,APRCH
	CONO PAG,420000+EPT/1000
	PUSHJ P,RSTKL
	JRST KLINI
	JRST CKTIL
	SKIPN DTEMTD
	PUSHJ P,KLTYO
	PUSHJ	P,KLSWS
KAINI:	MOVSI KATME,KATIM
	BLT KATME,KATME
	CONO APR,1000
	CONSO APR,1000
	JRST .-1
	JRST KATGO

KATTM==^D1000000*^D100/^D523	;# OF CONSO-AOJA'S IN 1 SEC (5.23 US EACH)
KATIM:	PHASE 0
	6+1
A:!	0
KATLP:!	CONSO APR,1000
	AOJA A,.-1
KATGO:!	CONO APR,1000
	SOJG KATLP
KATME:!	JRST KATMX
	DEPHASE

KATMX:	SUBI A,KATTM/^D10
	MOVEI B,^D60
	MOVM A
	CAIG KATTM/^D500
	JRST SETFRQ
	SUBI A,KATTM/^D50
	MOVEI B,^D50
	MOVM A
	CAIG KATTM/^D500
	JRST SETFRQ
	ADDI A,KATTM/^D10+KATTM/^D50
	IMULI A,^D60
	IDIVI A,KATTM/^D10
	MOVEI C,[ASCIZ /
UNKNOWN POWER FREQ $A HZ.
/]
	JRST STYO

KIINI:	CONI PAG,A
	LSH A,-^D26
	MOVEM A,APRSN
	CONI APR,A
	TLNE A,IP.50H
	SKIPA B,[^D50]
	MOVEI B,^D60
SETFRQ:	MOVEM B,PWRHZ
	POPJ P,

KLINI:	DATAO PAG,[1B2+UPT/1000]	;SET UP UPT ADR BEFORE ENABLING TRAPS
	CONO PAG,420000+EPT/1000	;TURN OFF FURTHER CACHE LOADS
	CONO APR,20020
	SWPUA		;START UNLOADING CACHE
	CONSO APR,20
	JRST .-1	;WAIT FOR SWEEP TO FINISH
	CONO APR,20020
	MOVEI .DTMMC
	SETZM DTEFLG
	MOVEM DTECMD	;SET "MONITOR MODE"
	CONO DTE,TO11DB
	SKIPN DTEFLG
	JRST .-1
	SETZM DTEMTI	;NO TYPEIN YET
	SETOM DTEMTD	;FLAG TYPEOUT AS "DONE"
	CONO TIM,TO.CIT!TO.CTD
	CONO MTR,0
	APRID A
	ANDI A,7777
	MOVEM A,APRSN
	MOVEI B,^D50	;WILL RUN TIMER AT 50 HZ
	JRST SETFRQ

RSTAI:	CONSZ TTY,20
	JRST .-1
	XCT APRST
	POPJ P,

RSTKL:	XCT APRST
	CONO MTR,0
	POPJ P,

KLTYO:	SETZM DTEMTD	;TELL 11 WE'RE COMING
	ANDI B,177
	TRO B,.DTMTO
	MOVEM B,DTECMD
	ANDI B,177
	CONO DTE,TO11DB	;TELL 11 WE'RE HERE
	POPJ P,

KLSWS:	SETZM	DTEFLG
	MOVEI	A,.DTRSW
	MOVEM	A,DTECMD		;TELL PDP11 WE WANT SWITCHES
	CONO	DTE,TO11DB		;WAKEUP PDP11
	SKIPN	DTEFLG			;HAVE WE GOT 'EM YET?
	JRST	.-1			;NO,KEEEP LOOKING
	SETZM	DTEFLG
	POPJ	P,
DSKT:	TDZA A,A		;ENTRY FOR RANDOM TRANSFERS
DSKTV:	SETO A,			;ENTRY FOR VERIFYING SURFACES
	MOVEM A,DSVFLG		;DISK SURFACE VERIFY FLAG
	XCT	RDSWS			;GET SWITCHES
	HLRZS	DD,			;PUT SITCHES IN RIGHT HALF
	ANDI	DD,400000		;RETURN TO COMMAND LEVEL ON ERROR
	MOVEM A,SERR
	MOVE A,CIN	;NUMERIC ARG
	PUSHJ P,CSET		;SET UP TO USE SA-10 CHAN
	SETZM TIME
	SETZM TIMEC		; CLEAR RUNNING TIME COUNTERS.
	XCT IORST
	MOVEI A,10000
	SOJG A,.
	PUSHJ P,SETHI
	LDB A,[330300,,CONFIG]	;B,C,CE
	TRZE A,7
	TLO A,200000	;NATURAL-MODE BIT IN CHAN COMMAND
	MOVEM A,NATRAL	;WHETHER NATURAL MODE AVAILABLE
	MOVE A,IDEVA
	MOVEM A,IDEVT
	SETOM OFFLIN
	MOVE A,[OFFLIN,,OFFLIN+1]
	BLT A,OFFLIN+NPACKS-1
DSKTL0:	MOVSI G,-NPACKS
	SETZM DRVGO#
	SETZM CUONL#
DSKTL1:	MOVE D,G		; SEE IF IT IS ON LINE
	ADD D,IDEVA
	PUSHJ P,DSENS1		; DISK SENSE ROUTINE
	TLNE A,10000
	JRST DSKTLE
	TLNE A,100000
	JRST DTSET	;IF SELECT ERROR
	AOS CUONL#
	DPB D,[141000,,WRTPP]
	DPB D,[141000,,WRTPP1]
	DPB D,[141000,,WRTPP2]
	MOVEI A,WRTPP
	PUSHJ P,SARNX0	;TRY WRITING REC 0, HEAD 0, CYL 0
	XCT GPHADR
	MOVEM A,PHADR(G)
	MOVE A,SENSED		; GET OFF-LINE BIT
	SETZM OFFLIN(G)
	TLNE A,-1	;OFFL OR WRT PROT?
	JRST DSKTS3
	AOS DRVGO	;COUNT A DRIVE STARTED
	SKIPN DSVFLG
	JRST .+3
	SKIPN UWP(G)
	JRST DSKTL2	;TRYING TO VERIFY WITHOUT UWP
	MOVEI C,[ASCIZ / RUNNING.
/]
	PUSHJ P,DRVTYP
	JRST DSKTS5

DSKTL2:	MOVEI C,[ASCIZ / UWP=0 - SKIPPING VERIFY PASS.
/]
	JRST DSKTS4
DSKTS3:	SETOM OFFLIN(G)	;MARK IT OFFLINE
	TLNE A,200000
	JRST DSKTS6	;IF NOT WRITE PROTECT
	MOVEI C,[ASCIZ / WRT LOCK.
/]
	TLNE A,^-10
	MOVEI C,[ASCIZ / ERROR.
/]
DSKTS4:	PUSHJ P,DRVTYP

DSKTS5:	MOVE A,IDEVA
	ADDI A,(G)
	PUSHJ P,DSET	;DETERMINE KIND OF DISK PACK
DSKTS6:	PUSHJ P,RNDAD		; SET UP ADDRESS TABLE
	MOVEM C,ADDR(G)		; IN CASE NOT RANDOM DURING TEST
	SETZM RETRYC(G)		; CLEAR RETRY COUNTER
	SETZM NREAD(G)		; CLEAR SUMMARY COUNTERS OF READS,
	SETZM LNREAD(G)
	SETZM NWRITE(G)		; WRITES,
	SETZM NCORDC(G)		; AND CORRECTABLE DATA CHECKS
	SETZM ERRCT(G)		; AND OTHER ERRORS
	SETZM TRK(G)		; START AT TRACK 0 IN CASE VERIFIER
	MOVSI A,(37B17!1B9!3B8)	; CLEAR WAITING STATES, VERIFIER FLAG,
	ANDCAB A,CHCW(G)	; AND VERIFIER STATE FIELD
	SKIPE A,UWP(G)		;NO VERIFY IF PROTECTED
	MOVSI A,(1B9)		; SET VERIFIER BIT IF
	SKIPE DSVFLG		; STARTED AT DSKVT
	IORM A,CHCW(G)		; ..
	AOBJN G,DSKTL1
DSKTS7:	MOVE A,IDEVA
	MOVEI C,[ASCIZ /
CONTROLLER ADDRESS IS %A /]
	CAME A,IDEVT
	PUSHJ P,STYO
	MOVSI A,-NPACKS
	MOVE B,IDEVA
	LSH B,-LNPAKS
IFLE CV,DPB B,[POINT 8-LNPAKS,CPGP(A),15-LNPAKS]
IFG CV,	DPB B,[POINT 8-LNPAKS,CPGP(A),7-LNPAKS]
	AOBJN A,.-1
;FALL THRU
;FALL THRU, ALSO BACK HERE AFTER ERRORS.
DSKT0:	XCT IORST
	XCT PIRST
	MOVE P,[-LPDL,,PDL-1]
	MOVE A,[JSR DSKI]
	MOVEM A,40+SA0CH+SA0CH
	MOVE A,[JSR APRI]
	MOVEM A,40+APRCH*2
	MOVEI C,[BYTE (7)15,12,0]
	PUSHJ P,STYO
	XCT CLKCF	;INIT CLK ON KL
	XCT CLKENB
	XCT MEENB
	CONO PI,2377
	MOVEI BF,0		; LIGHT-WATCHER CELL
	MOVSI G,-NPACKS
DSKT1:	MOVSI A,117		; CLEAR WAITING STATES
	ANDCAM A,CHCW(G)	; IN CONTROL WORD
	SETOM DEVL(G)
	SETZM HUNGT(G)		; NEVER STARTED DRIVE YET
DSKT1A:	MOVEI B,DIP0		; INITIAL FSM FOR DRIVE
	MOVE A,CHCW(G)
	TLNN A,(1B13)		; RETRYING?
	JRST DSKT1B		; NO.
	MOVEI B,DIP2A		; YES. START AT THE READ
	SKIPL RETRYC(G)		; UNLESS ALL COUNTED OUT
	JRST DSKT1B		; STILL TRIES LEFT. GO READ.
	MOVSI A,(1B13)		; TOO MANY. CLEAR RETRY FLAG
	ANDCAB A,CHCW(G)	; SET TO RUN CHECKER
	MOVE C,TRK(G)		; PUT IT IN THE BADSPOT TABLE
	HRL C,G			; PUT DRIVE IN LH
	MOVSI B,-NBADSP		; AND PUT RESULT IN TABLE
	SKIPL SPOTTB(B)		; FREE SLOT? (NEGATIVE)
	AOBJN B,.-1		; NO, FIND ONE
	SKIPGE B		; ONE FOUND?
	MOVEM C,SPOTTB(B)	; YES. STORE THE BAD SPOT
	MOVEI B,DIP3		; CHECKER WILL MOVE PAST THE ERROR
DSKT1B:	HRRM B,CHCW(G)
	MOVE B,CPGP(G)
	HRRI B,[0]
	TLNE A,4000
	SKIPE OFFLIN(G)
	SKIPA			; DON'T START DRIVE
	MOVEM B,DEVL(G)		; GIVE IT EMPTY CMD LIST TO GET INT
	AOBJN G,DSKT1
	SKIPN NOINTF#
	PUSHJ P,INTFRN	;START UP INTERFERENCE ON ADJACENT CHANNEL
	MOVE A,[600000,,DEVL]
	MOVEM A,@CBASE
	MCONO SA0,@STPIEC
	MCONO SA0,@STBSYC
DSKT2:	SETZM INFPB+1	;TO SEE IF INTERF CHAN PGM RUNNING
	PUSHJ P,CHKCNC
	JRST CI0	;QUIT WHEN KEY STRUCK
	MOVSI G,-NPACKS
DSKT3:	MOVE A,CHCW(G)
	TLNE A,2
	JRST FILLIT
	TLNE A,4
	JRST CHKIT
	SKIPG B,HUNGT(G)	; SEE IF DRIVE IS HUNG
	JRST DSKT4		; NEGATIVE MEANS IDLE
	MOVE D,PWRHZ
	IMULI D,^D30		;TIME TILL DRIVE HUNG (SECS)
	ADDI B,(D)
	CAMG B,TIME		; THAT LONG SINCE INT?
	JRST HUNG		; YUP
DSKT4:	MOVSI B,10		; DRIVE JUST COME ON LINE?
	TDNN B,CHCW(G)		; ..
	JRST DSKT5		; NOPE.
	ANDCAB B,CHCW(G)	; YES. CLEAR THE FLAG AND COMMENT.
	SKIPE C,OFFLIN(G)
	JRST DSKTOF	;WENT OFF-LINE
	TLNE B,(1B9)
	SKIPA C,[[ASCIZ / RUNNING VERIFY, /]]
	MOVEI C,[ASCIZ / RUNNING, /]
DSKT5A:	MOVE A,PHADR(G)
	PUSHJ P,DRVTY0
	PUSHJ P,PTIME
DSKT5:	AOBJN G,DSKT3
	MOVE A,PWRHZ
	IMULI A,^D60*^D15
	CAML A,TIMEC
	JRST DSKT8
	SETZM TIMEC
	MOVEI C,[ASCIZ /
TIME CHECK:  /]
	PUSHJ P,STYO
	PUSHJ P,PTIME		; REPORT TOTAL TIME
	MOVEI C,[ASCIZ /SUMMARY:

DRIVE, BYTES READ, BYTES WRITTEN, CORR'BLE DATA CKS, OTHER ERRS

/]
	PUSHJ P,STYO
	MOVEI G,0
DSKSML:	MOVE D,NREAD(G)
	CAMN D,LNREAD(G)
	JRST DSKSM2
	ASH D,-1
	IMULI D,11		; CONVERT TO BYTES (8 BITS)
	MOVE E,NWRITE(G)
	ASH E,-1
	IMULI E,11		; CONVERT TO BYTES
	MOVE F,NCORDC(G)
	MOVE H,ERRCT(G)
	MOVEI C,[ASCIZ /  %G,    $D,    $E,    $F,   $H
/]
	PUSHJ P,STYO
DSKSM2:	CAIGE G,NPACKS-1
	AOJA G,DSKSML
	PUSHJ P,CR
	MOVE A,[NREAD,,LNREAD]
	BLT A,LNREAD+NPACKS-1
DSKT8:	SKIPN NOINTF#
	SKIPGE INFPB+1	;IF CHAN PGM DIDN'T WRITE HERE
	JRST DSKT2
	MOVEI C,[ASCIZ /INTERFERENCE CHAN PGM DIED
/]
	PUSHJ P,STYO
	JRST DSKXX

DSKTOF:	TLNN C,200000
	SKIPA C,[[ASCIZ / WRT LOCKED, /]]
	MOVEI C,[ASCIZ / OFF LINE, /]
	JRST DSKT5A

FILLIT:	MOVEI A,NRETRY		; SET UP MAX COUNT IN CASE OF ERRORS
	MOVEM A,RETRYC(G)	; ..
	MOVE D,ADDR(G)
	MOVN E,NWTRAK(G)
	MOVE C,CHCW(G)		; WANT RANDOM, OR SURFACE VERIFIER
	MOVE B,TRK(G)
	TLNE C,(1B9)		; ..
	JRST FILLV		; VERIFIER
	TLNE C,(1B12)
	SETCM B,B
FILI1:	AOBJN A,.+2
	PUSHJ P,MAPADL
	MOVEM B,(A)
	ADDI D,1
	AOBJN A,.+2
	PUSHJ P,MAPADL
	SETCAM B,(A)
	AOJGE E,FILX
	ROT B,1
	ADDI D,1
	AOJL E,FILI1
FILX:	MOVSI A,6
	ANDCAM A,CHCW(G)
	MOVE A,CPGP(G)
	HRRI A,[0]
	MOVEM A,DEVL(G)
	MCONO SA0,@STBSYC
	JRST DSKT4
;SUBROUTINE TO RUN INTERFERENCE CHAN PGM
INTFRN:	MOVE A,CHAN
	XORI A,1	;ADJACENT TO CHANNEL USED FOR MAIN TEST
	LDB NCHNP
	CAMG A		;IS THIS OUT OF RANGE?
	XORI A,3	;YES, TRY A DIFFERENT ONE
	LSH A,2
	MOVE B,BASEA	;BASE ADDRESS
	ADD B,A
	MOVEI C,INFP	;CHAN  PGM ADDR
	MOVEM C,(B)	;TO BASE ADDR FOR CHANNEL
	LSH A,3-2
	MCONO SA0,STPIE+SA0CH(A)	;ENABLE PI FOR CHANNEL
	MCONO SA0,STBSY+SA0CH(A)	;SET GO BIT FOR CHANNEL
	POPJ P,

INFP:	40000,,INFPA	;LOAD
	440000,,INFPB	;STORE
	40000,,INFPA+1
	440000,,INFPB+1
	40000,,INFPA+2
	440000,,INFPB+2
	40000,,INFPA+3
	440000,,INFPB+3
	200000,,INFP	;LOOP BACK

INFPA:	0
	-1
	252525,,252525
	525252,,525252

INFPB:	BLOCK 4
FILLV:	TLNE C,(2B8)		; WORST CASE?
	JRST FILLVW		; YES
	MOVEI B,0		; NO. ZEROES OR ONES
	TLNE C,(1B8)		; ..
	SETO B,			; ONES.
FILLV1:	PUSHJ P,MAPAD
	MOVEM B,(A)
	ADDI D,1
	AOJL E,FILLV1
	JRST FILX

FILLVW:	MOVSI C,-NWCPDT		; GENERATE BUFFER FULL OF WORSTCASE PAT
FILVW1:	MOVE B,WCPDAT(C)
	SKIPN NATRAL
	MOVE B,WCWDAT(C)	;WORD MODE IF NO B FEATURES
	AOBJN A,.+2
	PUSHJ P,MAPADL
	MOVEM B,(A)		; A WORD OF THE PATTERN
	AOBJN C,.+2		; COUNT THE SOURCE
	MOVSI C,-NWCPDT		; WRAPAROUND
	ADDI D,1
	AOJL E,FILVW1
	JRST FILX

WCPDAT:	; 28-BIT REPEATING PATTERN

	; HERE IT IS EXCEPT FOR SA10 ROTATING/SPLITTING A BYTE
	BYTE (4) 17,13,6,15,13,6,0,17,13
	BYTE (4) 6,15,13,6,0,17,13,6,15
	BYTE (4) 13,6,0,17,13,6,15,13,6
	BYTE (4) 0,17,13,6,15,13,6,0,17
	BYTE (4) 13,6,15,13,6,0,17,13,6
	BYTE (4) 15,13,6,0,17,13,6,15,13
	BYTE (4) 6,0,17,13,6,15,13,6,0
	BYTE (4) 17,13,6,15,13,6,0,17,13
	BYTE (4) 6,15,13,6,0,17,13,6,15
	BYTE (4) 13,6,0,17,13,6,15,13,6
	BYTE (4) 0,17,13,6,15,13,6,0,17
	BYTE (4) 13,6,15,13,6,0,17,13,6
	BYTE (4) 15,13,6,0,17,13,6,15,13
	BYTE (4) 6,0,17,13,6,15,13,6,0
WCWDAT:
	;AND THIS IS SAME WITH ODD WORDS SHUFFLED AS NEEDED
	BYTE (4) 17,13,6,15,13,6,0,17,13
	BYTE (4) 15,13,6,0,17,13,6,15,6
	BYTE (4) 13,6,0,17,13,6,15,13,6
	BYTE (4) 17,13,6,15,13,6,0,17,0
	BYTE (4) 13,6,15,13,6,0,17,13,6
	BYTE (4) 13,6,0,17,13,6,15,13,15
	BYTE (4) 6,0,17,13,6,15,13,6,0
	BYTE (4) 13,6,15,13,6,0,17,13,17
	BYTE (4) 6,15,13,6,0,17,13,6,15
	BYTE (4) 6,0,17,13,6,15,13,6,13
	BYTE (4) 0,17,13,6,15,13,6,0,17
	BYTE (4) 6,15,13,6,0,17,13,6,13
	BYTE (4) 15,13,6,0,17,13,6,15,13
	BYTE (4) 0,17,13,6,15,13,6,0,6
NWCPDT==.-WCWDAT		;LENGTH OF REPEATED BLOCK
CHKIT:	MOVE C,CHCW(G)		; SEE IF IN RETRY SEQUENCE
	TLNN C,(1B13)		; ..
	JRST CHK0		; NO.
	MOVNI D,NRETRY+1	; YES. BUT READ OK NOW, SAY SO.
	ADD D,RETRYC(G)		; COMPUT READS NEEDED
	MOVMS D			; ..
	MOVEI E,(G)		; RH DRIVE NUMBER
	MOVEI C,[ASCIZ /DRIVE %E READ OK ON PASS $D.

/]
	PUSHJ P,STYO
	MOVSI A,(1B13)		; CLEAR RETRYING FLAG
	ANDCAM A,CHCW(G)
CHK0:	MOVE D,ADDR(G)
	MOVN E,NWTRAK(G)
	MOVEI A,0	;MAKE SURE WE MAP FIRST TIME
	MOVE C,CHCW(G)		; RANDOM OR FIXED PATTERN?
	TLNE C,(1B9)		; ..
	JRST CHKV		; FIXED. VERIFY SURFACE
	SKIPGE RETRYC(G)	; PERMANENT ERROR?
	JRST CHKX		; YES. DON'T TEST DATA
	MOVE B,TRK(G)
	TLNE C,(1B12)
	SETCM B,B
CHK1:	AOBJN A,.+2
	PUSHJ P,MAPADL
	CAME B,(A)
	PUSHJ P,UNDET		; UNDETECTED ERROR!!
	ADDI D,1
	AOBJN A,.+2
	PUSHJ P,MAPADL
	SETCM C,(A)
	CAME B,C
	JRST [	SETCA B,	; UNDETECTED ERROR. MAKE AC'S LIKE 
		PUSHJ P,UNDET	; IN OTHER CALLS TO ERR ROUTINE
		SETCA B,
		JRST .+1]
	AOJGE E,CHKX
	ROT B,1
	ADDI D,1
	AOJL E,CHK1
CHKX:	SETZM RETRYC(G)		; START FRESH
	MOVSI A,(1B12)
	XORM A,CHCW(G)
	JRST FILX
CHKV:	SKIPGE RETRYC(G)	; END OF PERMANENT ERROR?
	JRST CHKVX		; YES.
	TLNE C,(2B8)		; WORST CASE PATTERN?
	JRST CHKVW		; YES
	MOVEI B,0		; NO. ZEROES, OR ONES
	TLNE C,(1B8)		; ..
	SETO B,			; ONES.
CHKV1:	AOBJN A,.+1
	PUSHJ P,MAPADL
	CAME B,(A)		; IS WORD CORRECT?
	PUSHJ P,UNDET		; NO. UNDETECTED ERROR.
	ADDI D,1
	AOJL E,CHKV1	;CHECK WHOLE BUFFER
	JRST CHKVX		; DONE

CHKVW:	MOVSI C,-NWCPDT		; COUNT THRU CORRECT DATA
CHKVW1:	MOVE B,WCPDAT(C)	; GET CORRECT DATUM
	SKIPN NATRAL
	MOVE B,WCWDAT(C)	;IF WORD MODE
	AOBJN A,.+2
	PUSHJ P,MAPADL
	CAME B,(A)		; IS THIS WHAT WE READ?
	PUSHJ P,UNDET		; NO. UNDETECTED ERROR
	AOBJN C,.+2		; OK, COUNT THRU GOOD DATA
	MOVSI C,-NWCPDT		; WRAP AROUND
	ADDI D,1
	AOJL E,CHKVW1
CHKVX:	AOS A,TRK(G)		; ON TO NEXT HEAD
	CAMGE A,NTRAKS(G)	; ALL DONE?
	JRST CHKVXX		; NO
	SETZM TRK(G)		; YES. ON TO NEXT PATTERN, BACK TO CYL 0
	LDB A,[POINT 2,CHCW(G),8]
	ADDI A,1
	CAIL A,3
	MOVEI A,0		; RECYCLE AFTER ALL DONE
	DPB A,[POINT 2,CHCW(G),8]
	JUMPN A,CHKVXX
	MOVEI D,(G)
	MOVEI C,[ASCIZ /FINISHED VERIFY PASS ON DRIVE %D.
/]
	PUSHJ P,STYO
CHKVXX:	JRST CHKX

DSKTLE:	MOVE A,CHAN
	MOVEI C,[ASCIZ /
ERROR EXECUTING NO-OP ON CHANNEL %A /]
	PUSHJ P,STYO
	JRST CI0

DTSET:	SETOM OFFLIN(G)		;MAKE SURE OFF-LINE IF WE RAN OFF END
	AOBJN G,DSKTL1		;JUST KEEP TRYING IF MORE UNITS
	SKIPE CUONL
	JRST DSKTS7		;CU IS ALIVE SOMEWHERE
	MOVE A,IDEVA
	IORI A,<1_LNPAKS>-1
	ADDI A,1
	ANDI A,377
	MOVEM A,IDEVA
	CAME A,IDEVT
	JRST DSKTL0	;TRY THIS ADDRESS
	MOVE A,CHAN
	MOVEI C,[ASCIZ /
NO CONTROLLER RESPONDS ON CHANNEL %A /]
	PUSHJ P,STYO
	JRST CI0
PTIME:	MOVE A,TIME		; REPORT TOTAL TIME
	IDIV A,PWRHZ
	IDIVI A,^D60*^D60	; HOURS TO A
	MOVE D,A
	IDIVI B,^D60		;MINUTES TO B
	MOVE E,B
	MOVEI C,[ASCIZ /TIME $D HOURS, $E MINUTES
/]
	PUSHJ P,STYO
	POPJ P,0

HUNG:	SETOM HUNGT(G)		;SO DOESN'T REPEAT
	MOVEI C,[ASCIZ / HUNG, /]
	PUSHJ P,DRVTYP
	PUSHJ P,PTIME
	JRST DSKT4

APRI:	0
	XCT PDLTST
	JRST PDLINT
	CONSZ APR,@NXMBIT
	JSR BAD	;NXM
	XCT PETST
	JSR BAD	;PAR ERR
APRCLK:	XCT CLKSKP
	JRST 12,@APRI
	AOS TIME
	AOS TIMEC
	XCT CLKCF
	XCT CLKENB
	JRST 12,@APRI

KLCLK:	0
	EXCH KLCLK
	MOVEM APRI
	EXCH KLCLK
	JRST APRCLK

UNDET:	PUSH P,E
	PUSH P,C		; HERE ON UNDETECTED READ ERROR
	PUSH P,D		; OR CATASTROPHE CAUSING CHECK ROUTINE
	PUSH P,B		; TO FAIL. SAVE AC'S
	MOVEI D,(G)		; DRIVE NUMBER
	MOVE E,TRK(G)		; CYL AND HEAD
	IDIV E,DSETSU(G)		; CYL TO E, HD TO F
	MOVEI C,[ASCIZ /
*** UNDETECTED ERROR, DRIVE %D, CYLINDER %E, HEAD %F
/]
	PUSHJ P,STYO
	MOVE D,0(P)
	MOVE A,-1(P)
	PUSHJ P,MAPA
	MOVE E,0(A)
	MOVEI C,[ASCIZ /    WORD SHOULD BE %D, BUT WAS %E
/]
	PUSHJ P,STYO
	PUSHJ P,PTIME
	PUSHJ P,CR2
	POP P,B
	POP P,D
	POP P,C
	POP P,E
	SKIPE SERR		; STOP ON ERROR?
	JSR GOPR		; YES. RING FOR HUMAN OPERATOR
	POPJ P,0
BAD:	0
	CONO PI,400
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	HRRZ D,BAD
	MOVEI C,[ASCIZ /BAD ERROR FROM %D
/]
	PUSHJ P,STYO
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	SKIPN SERR
	JRST DSKT0
	JSR GOPR

GOPR:	0
	XCT PIRST
	PUSHJ P,CHKTYI
	JFCL
GOPR1:	MOVEI B,7
REPEAT 3,<	PUSHJ P,TYOI	;TYPE 3 BELLS
	JRST CI0
>
	MOVE A,PWRHZ
	IMULI A,5	;EVERY 5 SECONDS
GOPR2:	XCT CLKCF
GOPR2A:	XCT CLKSKP
	JRST GOPR3
	SOJG A,GOPR2
	JRST GOPR1

GOPR3:	PUSHJ P,CHKTYI
	JRST CI0
	JRST GOPR2A

TYOI:	PUSHJ P,TYO0
	JRST CHKTYI


DEFINE CPG(N)<CPG'N>

CPGP:
ZZ==0
IFLE CV,<
REPEAT NPACKS,<BYTE (8)320,IDEV+ZZ(20)CPG(\<.-CPGP>)
ZZ==ZZ+1>
>
IFG CV,<
REPEAT NPACKS,<BYTE (8)IDEV+ZZ,320(20)CPG(\<.-CPGP>)
ZZ==ZZ+1>
>

; CONTROL WORDS FOR DRIVE. DISPATCH IN RH, BITS IN LH.
; SEE COMMENTS ON BIT USAGE AT DIP0
CHCW:	REPEAT NPACKS,<374000,,>
ADRLO:	0		;FIRST AREA FREE FOR BUFFERS
			; SPACE TO LOAD PROG AT 1000, DDT, SYMS.
ADRHI:	777000		;FIRST NON-EX ADDR
ADDR:	BLOCK NPACKS		; DATA AREAS PER DRIVE
OFFLIN:	BLOCK NPACKS		; NON-ZERO IF DRIVE OFF LINE
NREAD:	BLOCK NPACKS
LNREAD:	BLOCK NPACKS
NWRITE:	BLOCK NPACKS
NCORDC:	BLOCK NPACKS
ERRCT:	BLOCK NPACKS		; NUMBER OF ERRORS OTHER THAN CORR-
				; ECTABLE DATA CHECKS AND STATISTICS
TRK:	BLOCK NPACKS		; CYL*19 + HEAD OF CURRENT TRANSFER
UWP:	BLOCK NPACKS		;USE WHOLE PACK IF NON ZERO
RETRYC:	BLOCK NPACKS		; COUNTER FOR CORRECTABLE DATA CK'S

HUNGT:	BLOCK NPACKS		;VALUE OF TIME WHEN INT OCCURRED.
				; MINUS ONE IF HUNG OR NOT STARTED.
PHADR:	BLOCK NPACKS

DEVN:	0
ACS:	BLOCK 20
SERR:	0
DSVFLG:	0			; DSK SURFACE VERIFIER FLAG

SPOTTB:	REPEAT NBADSP,<-1>	; SPACE FOR BAD SPOTS. -1 IS FREE
	-1			; AND ONE FOR END TEST

DEVL:	BLOCK NPACKS
	0

TIME:	0
TIMEC:	0
PWRHZ:	^D60			;LINE FREQ
SENSCT:	0
DSTAT:	BLOCK 4			; COPY OF 4 WORDS FROM LOW CORE
				; ON CHANNEL COMPLETION
TYIM:	PUSHJ P,STYO
TYI:	SETZM TYIFLG#
	PUSHJ P,CKTYI0
	CAIA
	JRST .-2
	PUSHJ P,TYO
	CAIE B,15
	POPJ P,
	MOVEI B,12
	PUSHJ P,TYO
	MOVEI B,15
	POPJ P,

CKTIAI:	CONSO TTY,40
	JRST CPOPJ1
	DATAI TTY,B
	ANDI B,177
	POPJ P,

CKTIL:	SKIPN DTEMTI
	JRST CPOPJ1
	LDB B,[POINT 7,DTEF11,35]
	SETZM DTEMTI
	POPJ P,

CHKTYI:	AOSE TYIFLG#	;IN CASE CHAR GOT EATEN BY CHKCNC
	PUSHJ P,CKTYI0
	 POPJ P,
	JRST CPOPJ1

CHKCNC:	PUSH P,B
	PUSHJ P,CKTYI0
	 JRST CHKCC2
BPOPJ1:	AOSA -1(P)
TYOBJ:	PUSHJ P,TYO	;ECHO IT FOR THE RECORD
	POP P,B
	POPJ P,

CHKCC2:	SETZM TYIFLG#
	CAIN B,"C"&77
	JRST TYOBJ
	SETOM TYIFLG#	;TELL CHKTYI WE SAW SOMETHING
	JRST BPOPJ1

NUMGM:	PUSHJ P,STYO
NUMG:	SKIPA B,[10]
DNUMG:	MOVEI B,^D10
	MOVEM B,IRADX#
	MOVEI A,0
	PUSHJ P,NTYI
	POPJ P,
NUMG1:	IMUL A,IRADX
	ADDI A,-"0"(B)
	PUSHJ P,NTYI
	JRST CPOPJ1
	JRST NUMG1

NTYI:	PUSHJ P,TYI
	CAIG B,"9"
	CAIGE B,"0"
	POPJ P,
	JRST CPOPJ1
;READ OR WRITE A RECORD (CALLED FROM DDT)
RDTST:	SKIPA A,[RDDATA]
WRTST:	MOVEI A,WRDATA
	DPB A,[241000,,RWTSP2]
	MOVE A,TSTADR	;CORE ADDRESS
	MOVN B,CRECL	;RECORD LENGTH
IFLE CV,<
	DPB B,[242000,,A]
	>
IFG CV,<
	DPB B,[301400,,A]
	>
	MOVEM A,RWTSP3	;WORD COUNT, ADDRESS FOR READ OR WRITE
	LDB A,[330300,,CONFIG]	;B,C,CE
	TRZE A,7
	TROA A,140
	TRO A,40
	DPB A,[341000,,RWTSP2]
	MOVE A,TSTDEV	;DEVICE ADDR
	DPB A,[141000,,RWTSTP]
	DPB A,[141000,,RWTSP1]
	DPB A,[141000,,RWTSP2]
	MOVE A,TSTCYL	;CYLINDER
	DPB A,[42000,,RWTSTD]
	MOVE A,TSTHED
	DPB A,[42000,,RWTSTD+1]
	MOVE A,TSTREC
	DPB A,[42000,,RWTSTD+1]
	MOVEI A,RWTSTP	;CHAN PGM
	PUSHJ P,SARNX0	;RUN IT
	JRST DDT	;EXIT

TSTDEV:	IDEV	;DEVICE ADDR
TSTCYL:	0	;CYLINDER
TSTHED:	0	;HEAD
TSTREC:	1	;RECORD #
TSTADR:	ADRLO	;CORE ADDRESS

RWTSTP:	BYTE (8)70,SEEK,IDEV
	IOW 6,RWTSTD
RWTSP1:	BYTE (8)71,SCHIDE,IDEV
	IOW 5,RWTSTD
	MOVE RWTSP1	;TIC
RWTSP2:	BYTE (8)40,0,IDEV	;READ DATA OR WRITE DATA
RWTSP3:	IOW 200,ADRLO	;CLOBBERED
	0
RWTSTD:	0	;00CC
	0	;HH0R
;DETERMINE TYPE OF DISK PACK -- DEVICE ADDR IN A
DSET:	PUSHJ P,DSET0
	JRST DSETE
	POPJ P,
	POPJ P,

DSET0:	DPB A,[141000,,DSETP]	;INTO SEEK COMMAND
	DPB A,[141000,,DSETP2]	;AND INTO NOP
	MOVEM A,DSETD
	ANDI A,<1_LNPAKS>-1
	CAIL A,NPACKS
	JRST ILLDRV
	HRR G,A
	MOVSI C,DSETT0-DSETT1	;- # POSSIBILITIES
DSET1:	MOVE A,DSETT0(C)	;1ST NONEXISTENT CYL
	DPB A,[42000,,DSETPD]	;CC
	MOVEI A,DSETP	;CHAN PGM ADDR
	PUSHJ P,SARNX0	;TRY THE SEEK
	SKIPGE A,SENSED	;LOOK AT COMMAND REJECT BIT
	AOBJN C,DSET1	;IF COMMAND REJECT
	TLNE A,376000
	JRST CPOPJ1	;DON'T CLOBBER DATA ON OTHER ERRS
	SOJGE C,CPOPJ1	;ERR IF NONE GOOD - BACK UP TO WORKING ONE
	MOVE A,DSETT0(C)
	MOVEM A,DSETCY(G)	;TOTAL # CYLS
	MOVE A,DSETT1(C)
	MOVEM A,DSETUC(G)	;USER CYLS
	MOVE A,DSETT2(C)
	MOVEM A,DSETSU(G)	;# SURFS
	IMUL A,DSETUC(G)
	MOVEM A,NUTRAK(G)
	MOVE A,DSETSU(G)
	IMUL A,DSETCY(G)
	MOVEM A,NTRAKS(G)
	SUB A,NUTRAK(G)
	MOVEM A,NXTRAK(G)
	MOVE B,CRECL	;RECORD LENGTH IN WORDS
	ASH B,-1
	IMULI B,11	;9 BYTES PER 2 WORDS
	ADD B,DSETT3(C)	;# OVERHEAD BYTES PER RECORD
	MOVE A,DSETT4(C)	;TOTAL # BYTES PER TRACK
	IDIV A,B
	MOVEM A,DSETNR(G)	;# RECORDS PER TRACK
	ASH A,^D28
	MOVEM A,DSETR2(G)
	MOVE A,DSETNR(G)
	ADDI A,1
	ASH A,^D28
	MOVEM A,DIRW1V(G)
	MOVE A,CRECL
	IMUL A,DSETNR(G)
	MOVEM A,NWTRAK(G)	;# WORDS PER TRACK
	MOVEI A,BLKSKP
	IDIV A,DSETNR(G)
	JUMPN B,[AOJA A,.+1]
	MOVEM A,NSTRAK(G)	;# TRACKS TO AVOID AT BEGINNING
	HRRZM C,DSETTY(G)	;TYPE CODE
	AOS (P)
	JRST CPOPJ1

ILLDRV:	MOVEI C,[ASCIZ /
DRIVE #%A TOO BIG.
/]
	JRST STYOXT
DSETP:	BYTE (8)70,SEEK,IDEV
	IOW 6,DSETPD
DSETP2:	BYTE (8)240,3,IDEV	;CHAIN TO NOP TO WAIT FOR COMPLETION
	0
DSETPD:	0
	0

;TOTAL # CYLS -- 1ST INVALID CYL #
DSETT0:	^D815	;3330-11
	^D704	;3340-70
	^D560	;3350
	^D411	;3330-1
	^D356	;3340-35

;# CYLS FOR USER
DSETT1:	^D808
	^D696
	^D555
	^D404
	^D348

;# SURFS
DSETT2:	^D19
	^D12
	^D30
	^D19
	^D12

;# OVERHEAD BYTES PER RECORD
DSETT3:	^D135
	^D185
	^D185
	^D135
	^D185

;# BYTES PER TRACK
DSETT4:	^D13165
	^D8553
	^D19254
	^D13165
	^D8553

DSETE:	MOVEI C,[ASCIZ /
SEEK TO CYL 348. REJECTED.
/]
	PUSHJ P,STYO
	JRST CI0	;ABORT

DSETD:	0
DSETCY:	BLOCK NPACKS	;TOTAL # CYLINDERS
DSETUC:	BLOCK NPACKS	;# CYLINDERS FOR USER
DSETSU:	BLOCK NPACKS	;# SURFACES
DSETNR:	BLOCK NPACKS	;# RECORDS PER TRACK
DSETR2:	BLOCK NPACKS	;# RECORDS PER TRACK * 2000,,0
DSETTY:	BLOCK NPACKS	;DISK DRIVE TYPE # (E.G. INDEX ON DSETT0)
NWTRAK:	BLOCK NPACKS	;# WDS PER TRACK
NTRAKS:	BLOCK NPACKS	;TOTAL # CYLS * SURFS
NUTRAK:	BLOCK NPACKS	;# UCYLS * SURFS
NXTRAK:	BLOCK NPACKS	;NTRAKS - NUTRAK
NSTRAK:	BLOCK NPACKS	;# TRACKS PROTECTED FROM DSKT, BAFGO
DIRW1V:	BLOCK NPACKS
;FORMAT A PACK. ASSUMES REC 0 EXISTS, WRITES 1-5

FMT:	MCONO SA0,400000
	PUSHJ P,CSET	;SET UP FOR PROPER SA-10 CHANNL
	SKIPL A,PREARG
	MOVEM A,FMTD
	LDB G,[POINT LNPAKS,FMTD,35]
	MOVEI C,[ASCIZ /
UWP NOT SET FOR DRIVE %G.
/]
	SKIPN UWP(G)
	JRST STYOXT
	MOVEI C,[ASCIZ /
FORMATTER READY, C TO CONTINUE:
/]
	PUSHJ P,ABORTQ
	SETZM FMZBF
	MOVE A,[FMZBF,,FMZBF+1]
	BLT A,FMZBF+BLKSIZ*11/10-1
	MOVE A,FMTD	;DEVICE ADDRESS
	PUSHJ P,DSET	;DETERMINE DISK DRIVE SIZE
	MOVE A,DSETNR(G)
	ADDI A,1
	IMULI A,^D40
	MOVEM A,FMT1T
	MOVE D,FMTD		; DEVICE TO FORMAT
	MOVE P,[-LPDL,,PDL-1]
	XCT IORST
	XCT PIRST
FMT0:	LSH D,^D12
	MOVE I,FMTM	;0=HA, R0 ARE GOOD; 1=WRT R0; -1=WRT HA AND R0
	;PUT IN DEV FLD
	MOVE J,CRECL	;RECORD LENGTH
	IMULI J,^D9
	ADDI J,1
	ASH J,-1	;J HAS SIZE IN BYTES
	LSH J,4
	MOVEI E,0
FMT1:	TRZ E,7760		; CLEAR HEAD FIELD
	MOVE H,ADRLO	;PLACE TO PUT C C H H # KL DL DL
	MOVSI C,200000	;A TIC CMD
	ADD C,H
	ADD C,FMT1T	;LEAVE ROOM FOR DATA
	MOVEM C,FWP0
	JUMPE I,FMT1A	;IF NO SET FM NEEDED
	MOVE K,[BYTE (8)70,37]	;SET FM
	PUSHJ P,FMTS0
	MOVE K,[-1,,[BYTE (8)300]]	;ALLOW ALL
	PUSHJ P,FMTS1
FMT1A:	TRNE E,7760	;ALWAYS SEEK IF HEAD 0
	JUMPGE I,FMT1B	;OR IF WRITING HA'S
	MOVE K,[BYTE (8)70,7]	;SEEK
	PUSHJ P,FMTS0
	MOVE K,[400000-2,,[0]]	;2 BYTES OF BB
	PUSHJ P,FMTS1
	MOVSI K,-4
	PUSHJ P,FMTS1A
FMT1B:	JUMPL I,FMT1C
	JUMPG I,FMT1D
	MOVE K,[BYTE (8)70,61]	;SRCH ID EQ
	TRNE E,7760
	TLO K,1000	;SET M-T IF NOT 1ST REC
	PUSHJ P,FMTS0
	MOVSI K,-5
FMT1BR:	PUSHJ P,FMTS1A
	PUSHJ P,FMTS2
;FALLS THRU
;FALLS IN
FMT1E:	TLZ J,776000	;SET RN TO 0
FMT2:	MOVEM E,(H)
	MOVEM J,1(H)
	MOVEI A,200
	TLNN J,776000
	HRRM A,1(H)	;R0 HAS DL OF 8
	ADDI H,2
	CAML J,DSETR2(G)
	JRST FMT2A	;NO MORE RECS ON TRK
	ADD J,[2000,,0]
	MOVE K,[BYTE (8)70,35]	;WRT CKD
	PUSHJ P,FMTS0
	MOVSI K,400000-^D8
	PUSHJ P,FMTS1A
	MOVN K,J
	LSH K,^D18-4
	HRRI K,FMZBF
	PUSHJ P,FMTS1A
	JRST FMT2
FMT2A:	ADDI E,20
	LDB A,[41000,,E]
	CAMGE A,DSETSU(G)
	JRST FMT1A	;MORE TRKS ON CYL
	MOVE K,[BYTE (8)240,3]	;NOP
	PUSHJ P,FMTS0
	SETZM (C)
	MOVE A,FWP0
	PUSHJ P,SCHNX	;FORMATS ONE CYL
	JRST CI0	;IF ERROR
	ADD E,[4,,0]		; COUNT A CYLINDER
	LDB A,[242000,,E]	; WHAT CYLINDER ARE WE UP TO?
	CAMGE A,DSETCY(G)
	JRST FMT1		; NOT DONE YET.
	MOVEI C,[ASCIZ /
FORMATTER DONE.
/]
STYOXT:	PUSHJ P,STYO
	JRST CI0

FMT1D:	MOVE K,[BYTE (8)70,71]	;SRCH HA EQ
	TRNE E,7760
	TLO K,1000	;SET M-T IF NOT 1ST TRK
	PUSHJ P,FMTS0
	MOVSI K,-4
	PUSHJ P,FMTS1A
	PUSHJ P,FMTS2
	JRST FMT1CR

ABORTQ:	PUSHJ P,STYO	;TYPE MESSAGE
	PUSHJ P,TYI	;ACCEPT CHAR
	CAIN B,"C"
	POPJ P,	;CHAR WAS C, CONTINUE
FMTAX:	MOVEI C,[ASCIZ /
ABORTED.
/]
	PUSHJ P,STYO
	JRST CI0
FMT1C:	MOVE K,[BYTE (8)70,31]	;WRT HA
	PUSHJ P,FMTS0
	MOVE K,[400000-1,,[0]]
	PUSHJ P,FMTS1	;PUT OUT A ZERO FLAG BYTE
	MOVSI K,-4
	PUSHJ P,FMTS1A
FMT1CR:	MOVE K,[BYTE (8)70,25]	;WRITE R0
	PUSHJ P,FMTS0
	MOVSI K,400000-^D8
	PUSHJ P,FMTS1A
	MOVE K,[-^D8,,FMZBF]
	PUSHJ P,FMTS1A
	JRST FMT1E

FMTS0:	ADD K,D
FMTS3:	MOVEM K,(C)
	ADDI C,1
	POPJ P,

FMTS2:	MOVE K,C
	SUBI K,2
	JRST FMTS3

FMTS1A:	HRR K,H
FMTS1:	HLLZ A,K
		LSH A,CNTSFT
	SKIPL K
	TLZ A,400000
	HLL K,A
	JRST FMTS3

CRECL:	BLKSIZ

MXRECT=40			; MAX RECORDS PER TRACK
DEVFLD=141000
; FOLLOWING 4 ARE TABLES, OF LENGTH 1 NOW, DEFINING A FORMAT OF
; A PACK. INDEXED BY F IN FMT ABOVE

FWP0:	0	;PTR TO CHNL PRGM
FMTM:	0	;FORMATTING MODE
FMTD:	IDEV	;DEV ADDR

FMT1T:	0
;# RECORDS PER TRACK (TOPS-10)
IFNDEF NRPT,NRPT==^D18
;BAFGO -- WRITES OR UPDATES BAT BLOCKS AND OPTIONALLY FORMATS DISKS
BAFGO:	MCONO SA0,400000
	PUSHJ P,CSET	;SET UP FOR PROPER SA-10 CHAN
	SKIPL A,PREARG
	MOVEM A,IDEVA
	MOVEI C,[ASCIZ /
BAD BLOCK PROGRAM READY.  TYPE C TO CONTINUE, A TO ABORT.
/]
	PUSHJ P,ABORTQ
BAFGOA:	MOVEI C,[ASCIZ /
HOW MANY PATTERNS TO TRY? /]
	PUSHJ P,NUMGM
	JRST BAFGOA
	JUMPLE A,BAFGOA	;CHECK FOR PLAUSIBILITY
	CAIE B,15	;END WITH CR
	JRST BAFGOA	;OR ELSE
	MOVEM A,BAFMAX
	SETZM BAFF		;FORMAT-ALL FLAG
	MOVEI C,[ASCIZ /
FORMAT ALL UNITS (Y OR N)? /]
	PUSHJ P,NUMGM
	CAIA
	JRST BAFW
	CAIN B,"Y"
	JRST BAFW0		;YES
BAFW:	MOVEI C,[ASCIZ /
WHAT UNITS TO HAVE BAT BLOCKS REINITIALIZED? (TYPE #,#,...CR)
/]
	PUSHJ P,STYO
	SETZM BAFWT
	MOVE A,[BAFWT,,BAFWT+1]
	BLT A,BAFWT+NPACKS-1	;CLEAN OUT TABLE
BAFW1:	PUSHJ P,NUMG
	JRST BAFW2A	;NO MORE NUMBERS
	CAIE B,","
	CAIN B,15	;CR
	CAIL A,NPACKS
	JRST BAFW	;TYPED SOMETHING WRONG, TRY AGAIN
	AOS BAFWT(A)
	CAIN B,15
	JRST BAFW2
	JRST BAFW1
BAFW0:	MOVEI C,[ASCIZ /
/]
	PUSHJ P,STYO
	SETOM BAFF	;SET FORMAT-ALL FLAG
BAFW2:	MOVEI G,0	;START WITH DRIVE 0
BAFW2N:	CAIL G,NPACKS
	JRST BAFDN	;IF DONE ALL DRIVES
	PUSHJ P,DRAVL	;IS DRIVE AVAILABLE?
BAFW3:	AOJA G,BAFW2N	;NO, TRY NEXT ONE
	SKIPN UWP(G)
	JRST BAFX99
	MOVE A,IDEVA
	ADDI A,(G)
	PUSHJ P,DSET	;DETERMINE SIZE OF DISK
	MOVE E,DSETNR(G)
	CAIE E,NRPT
	JRST BAFWE1	;NRPT NOT RUN-TIME VARIABLE YET
	SETZM BAFPAT	;PATTERN 0
	PUSHJ P,BAFP	;SET UP DATA
	MOVEI B,BAFTP
	PUSHJ P,BAFT	;PUT DEV ADDR IN FORMATTING CHAN PGM
	MOVEI B,BAFWP
	PUSHJ P,BAFT	;PUT DEV ADDR IN NORMAL CHAN PGM
	SETZM BAFCYL	;CYLINDER 0
	SETZM BAFHED	;HEAD 0
BAFW9:	SKIPN BAFF	;ARE WE FORMATTING?
	JRST BAFW8	;IF NOT
	MOVEI A,BAFTP
	PUSHJ P,BAFO	;RUN FORMATTING CHAN PGM
	JRST BAFW9E	;IF IT FAILS
	JRST BAFW6	;IF TRACK 0 FORMATTED OK

BAFW8:	SKIPN BAFWT(G)
	JRST BAFW4	;DON'T WRITE INITIAL BAT BLOCKS
BAFW6:	SETZM BAFWT(G)	;NO NEED TO RE-REINITIALIZE
	PUSHJ P,IBAF
	PUSHJ P,WBAT	;WRITE OUT INITIAL BAT BLOCKS
	MOVEI C,[ASCIZ /DRIVE %G BAT BLOCKS INITIALIZED
/]
	PUSHJ P,STYO
BAFW4:	PUSHJ P,RBAF	;TRY TO READ IN BAT BLOCK (EITHER ONE IF OK)
	JRST BAFW3	;LOSE, TRY ANOTHER DRIVE
	JRST BAFX1	;OK, NOW TRY ALL OTHER TRACKS

BAFW9E:	MOVEI C,[ASCIZ /CAN'T FORMAT TRACK 0 ON DRIVE %G
/]
	PUSHJ P,STYO
	JRST BAFW3	;ON TO NEXT DRIVE

BAFW2A:	MOVEI C,[ASCIZ /
/]
	PUSHJ P,STYO
	JRST BAFW2
BAFX2:	AOS B,BAFHED	;TRY NEXT HEAD
	MOVE A,BAFCYL
	CAMGE B,DSETSU(G)
	JRST BAFX3	;OK, TRY THIS TRACK
	MOVEI B,0	;NEED TO GO TO START OF NEXT CYLINDER
	AOS A,BAFCYL	;TRY NEXT CYLINDER
	CAMGE A,DSETUC(G)	;IS IT IN NORMAL AREA OF DISK?
	JRST BAFX5	;IF YES, OK
	SKIPN BAFPAT
	SKIPN BAFF
	JRST .+3
	CAMGE A,DSETCY(G)	;FORMATTING - CONTINUE INTO MAINT CYLS
	JRST BAFX5
	MOVE D,BAFPAT	;IF NO, TIME FOR NEXT PATTERN
	MOVE F,BAFCT
	MOVEI C,[ASCIZ /DONE PATTERN %D ON DRIVE %G, MARKED $F REGIONS BAD
/]
	PUSHJ P,STYO	;GIVE PROGRESS MESSAGE
	AOS A,BAFPAT	;STEP TO NEXT PATTERN
	CAML A,BAFMAX
	JRST BAFW3	;IF DONE ALL PATTERNS, ON TO NEXT DRIVE
	PUSHJ P,BAFP	;SET UP DATA FOR THIS PATTERN
BAFX1:	MOVE A,NSTRAK(G)	;START AT THIS TRACK
	IDIV A,DSETSU(G)
	MOVEM A,BAFCYL
BAFX5:	MOVEM B,BAFHED	;HEAD 1 (AVOID TRACK 0)
BAFX3:	PUSHJ P,CHKCNC
	JRST CI0
	MOVEI A,BAFTP	;FORMATTING CHAN PGM
	SKIPN BAFPAT	;IF PATTERN NONZERO, TRACK IS ALREADY FORMATTED
	SKIPN BAFF	;IF FORMAT-ALL MODE
	MOVEI A,BAFWP	;NORMAL WRITE-READ CHAN PGM
	PUSHJ P,BAFO	;RUN CHAN PGM
	JRST BAFY	;IF TROUBLE
	JRST BAFX2	;IF TRACK OK, ON TO NEXT TRACK

BAFX99:	MOVEI C,[ASCIZ /SKIPPING /]
	PUSHJ P,STYO
	MOVEI C,[ASCIZ /, UWP=0.
/]
	PUSHJ P,DRVTYP
	JRST BAFW3

BAFWE1:	MOVEI C,[ASCIZ /
MUST REASSEMBLE WITH NRPT=^D$E TO RUN ON DRIVE %G
/]
	PUSHJ P,STYO
	JRST BAFW3
;BAT ENTRY MANIPULATION ROUTINES

;SET UP TO SCAN BAT ENTRIES (C=AOBJN PNTR, D=#ENTRIES IN USE)
BATSU:	SKIPL C,BAF+BAFFIR
	JRST BATSUE
	ADDI C,BAF
	LDB D,[POINT 9,BAF+BAFNBS,17]
	ADD D,BAF+BAFCNT
	POPJ P,

BATSUE:	HLLZ C,C
	MOVN C,C	;CORRECT OLD BUG
	HLLM C,BAF+BAFFIR
	PUSH P,A
	PUSH P,B
	PUSHJ P,WBAT
	POP P,B
	POP P,A
	JRST BATSU

;GET NEXT BAT ENTRY, SET UP ACS:
;E,F= FIRST,LAST BLOCKS OF REGION
;H=0 (# BLOCKS ADDED), J=0 (# REGIONS ADDED (LH))
;I= FORMAT VERSION IN INTERNAL FORM
BATGET:	JUMPE D,CPOPJ	;NONE LEFT
	JUMPGE C,BAFY2E	;SOME LEFT BUT END OF TABLE - SICKNESS
	MOVE I,BAFNBB(C)
	TRNN I,BAPNTP	;NEW TYPE ENTRY?
	SKIPA I,[BAFVOL-BAFVOF]	;NO, SET FOR OLD
	LDB I,[POINT 3,BAFELB(C),2]	;YES, GET VERSION
	CAILE I,BAFVMX-BAFVOF
	JRST BATGER	;A VERSION WE DON'T HANDLE
	ADDI I,BAFVOF	;OFFSET VERSION TO INTERNAL FORM
	CAMLE I,BAFVHI
	MOVEM I,BAFVHI	;REMEMBER LATEST VERSION SEEN
	LDB E,BAYELB(I)	;STARTING BLK #
	LDB F,[POINT 9,BAFNBB(C),8]	;LENGHT-1
	ADD F,E
	LDB BAYAPN(I)	;GET APR SERIAL #
	PUSHJ P,ASNGUE	;USE AS GUESS FOR OURS
	SETZB H,J	;NOTHING ADDED YET
	ADD C,[2,,2]	;ADVANCE PNTRS & EXIT
	SOJA D,CPOPJ1

BATGER:	MOVEI C,[ASCIZ /UNKNOWN ENTRY FORMAT %I
/]
	JRST STYO

BAYELB:	0
	POINT 18,BAFELB(C),35
	POINT 30,BAFELB(C),35

BAYAPN:	0
	0
	POINT 14,BAFNBB(C),35

BATEMX:	0
	1B18
	1B5
;STORE UPDATED BAT ENTRY
BATSTO:	LDB A,[POINT 9,BAF+BAFNBS,8]
	ADD A,H
	JUMPN J,[AOJA A,.+1]	;H IS 1 LESS IF NEW ENTRY
	CAIL A,1000
	JRST BAFY2F	;TOO MANY BAD BLKS
	LDB B,[POINT 9,BAFNBB(C),8]
	ADD B,H
	CAIL B,1000
	JRST BAFY2E	;TOO MANY FOR ENTRY BUT NOT TOTAL ???
	CAML E,BATEMX(I)
	PUSHJ P,BATSNV	;BLOCK # WON'T FIT FORMAT - TRY TO USE ANOTHER
	CAML E,BATEMX(I)
	JRST BATSTE	;STILL DOESN'T MAKE IT
	DPB A,[POINT 9,BAF+BAFNBS,8]
	DPB B,[POINT 9,BAFNBB(C),8]
	DPB E,BAYELB(I)
	ADDM J,BAF+BAFNBS
	MOVEI A,BAPNTP
	CAIG I,BAFVOL
	JRST [	ANDCAM A,BAFNBB(C)	;MARK OLD FORMAT
		JRST CPOPJ1]
	IORM A,BAFNBB(C)
	MOVEI A,-BAFVOF(I)
	DPB A,[POINT 3,BAFELB(C),2]
	LDB A,[POINT 8,SENSED+1,31]	;SENSE BYTE 7
	CAIE A,103
	CAIN A,123
	SKIPA A,[BAPDTR,,]	;ERR IN DATA FIELD
	MOVSI A,BAPHDR	;NO, MARK AS HEADER ERR
	IORM A,BAFELB(C)
	LDB A,[POINT 8,SENSED+1,7]
	PUSHJ P,DPHLOK	;GET PHYS DRIVE #
	JRST CPOPJ1
	MOVSI A,1
	LSH A,(B)
	IORM A,BAFNBB(C)
	JRST CPOPJ1

BATSTE:	JUMPE J,BAFY2E
	SETZM BAFNBB(C)
	SETZM BAFELB(C)
	MOVEI C,[ASCIZ /1ST LBN TOO HIGH, DISCARDING ENTRY.
/]
	JRST STYO
;SET UP NEW BAT SLOT, READY FOR BATSTO
BATNEW:	JUMPGE C,CPOPJ	;NO ROOM
	SETZM BAFNBB(C)
	SETZM BAFELB(C)
	MOVE H,F
	SUB H,E
	MOVSI J,1
	PUSHJ P,BATSNV	;SET UP VERSION
	CAIG I,BAFVOL
	JRST CPOPJ1	;DONE IF OLD
	SKIPGE A,APRSN
	PUSHJ P,GETASN	;GET SERIAL #
	DPB A,BAYAPN(I)
	JRST CPOPJ1

;ASSIGN NEW FORMAT VERSION FOR ENTRY
BATSNV:	SKIPE I,BAFCVR
	POPJ P,		;USE ESTABLISHED DEFAULT
	MOVE I,BAFVHI
	CAIL I,BAFVMX
	POPJ P,		;USE NEWEST SEEN IF ALSO NEWEST POSSIBLE
	PUSH P,A
	PUSH P,B
	PUSH P,C
	MOVEI A,BAFVMX-BAFVOF
	MOVEI C,[ASCIZ /
ENTRY VERSION # TO USE, CR FOR OLD (5.07) FMT, NEWEST=%A:/]
BATSV3:	PUSHJ P,NUMGM
	SOJA A,BATSV2	;-1 FOR OLD BEFORE OFFSET
	CAIG A,BAFVMX-BAFVOF
	JUMPGE A,BATSV2
	MOVEI C,[ASCIZ /ILLEGAL. FMT:/]
	JRST BATSV3

BATSV2:	MOVEI I,BAFVOF(A)
	MOVEM I,BAFCVR#	;SAVE FOR FUTURE REFERENCE
	POP P,C
	POP P,B
	JRST POPAJ
;GET APR SERIAL # IF KA (KNOWN IF KI OR KL)
GETASN:	SKIPLE A,ASNTRY	;DO WE HAVE A GUESS?
	SKIPA C,[ASCIZ /
TYPE APR SERIAL # (DEC), CR IF = $A:/]
	MOVEI C,[ASCIZ /
TYPE APR SERIAL #:/]
	PUSHJ P,STYO
	PUSHJ P,DNUMG
	SKIPLE A,ASNTRY	;IF NOTHING TYPED
	MOVEM A,APRSN
	MOVE A,APRSN
	POPJ P,

ASNGUE:	JUMPE CPOPJ
	SKIPN ASNTRY
	MOVEM ASNTRY
	CAME ASNTRY
	SETOM ASNTRY
	POPJ P,

APRSN:	-1
ASNTRY:	0
BAFY:	LDB A,[POINT 8,SENSED,7]
	CAIE A,10
	JRST BAFYE	;NOT DATA CHECK, SOMETHING AMISS
	MOVE A,BAFCYL
	CAML A,DSETUC(G)
	JRST BAFYE2	;NOT USER CYL
	IMUL A,DSETSU(G)
	ADD A,BAFHED	;RESULT IS TRACK # WITH TROUBLE
	IMULI A,NRPT	;GET 1ST LBN IN TRACK
	MOVEM A,BAFYV
	MOVE E,BAFCYL	;CYLINDER #
	MOVE F,BAFHED	;HEAD #
	MOVE D,BAFYV	;LBN
	MOVEI C,[ASCIZ /DRIVE %G, CYL $E, HEAD $F (1ST LBN $D)
/]
	PUSHJ P,STYO
	MOVE A,BAFYV
	MOVE B,A
	ADDI B,NRPT-1	;LAST LBN IN TRACK
	PUSHJ P,BATSU
BAFY0:	PUSHJ P,BATGET
	JRST BAFY7	;NO MATCH, MAKE NEW ENTRY
	MOVE E
	SUBI 1
	CAMLE B
	JRST BAFY0	;NO OVERLAP OR ADJOINMENT
	MOVE A
	SUBI 1
	CAMLE F
	JRST BAFY0	;DITTO OTHER WAY
	CAMN E,A
	CAME F,B
	JRST BAFY2	;IF DIFFERENT FROM OLD REGION
	JRST BAFY1X	;IF SAME AS OLD REGION

BAFYE:	MOVEI C,[ASCIZ /
RETRYING NON-DATA ERROR ON DRIVE %G
/]
	PUSHJ P,STYO
	JRST BAFX3

BAFYE2:	MOVEI C,[ASCIZ /MAINT CYL - NO BAT ENTRY MADE.
/]
	PUSHJ	P,STYO
	JRST BAFX2
BAFY2:	CAMG E,A
	JRST BAFY2A	;NO EXTENSION AT BEGINNING
	ADD H,E
	SUB H,A
	MOVE E,A
BAFY2A:	CAML F,B
	JRST BAFY2B	;NO EXTENSION AT END
	ADD H,B
	SUB H,F
	MOVE F,B
BAFY2B:	JUMPE H,BAFY1X	;DON'T DIDDLE FOR SUBSET
	PUSHJ P,BATSTO
	JRST BAFW3	;COULDN'T UPDATE IT
	MOVEI C,[ASCIZ /EXPANDED EXISTING REGION
/]
	PUSHJ P,STYO
	JRST BAFY8	;ALL DONE, WRITE IT OUT
;HERE IF NO RELEVANT ENTRY FOUND
BAFY7:	MOVE E,A
	MOVE F,B
	PUSHJ P,BATNEW
	JRST BAFY7X	;COULDN'T ASSIGN NEW SLOT
	PUSHJ P,BATSTO
	JRST BAFW3	;COULDN'T UPDATE ENTRY
BAFY8:	PUSHJ P,WBAT	;WRITE OUT MODIFIED BAT BLOCKS
	AOS BAFCT	;COUNT A NEW REGION FOUND BY THIS PATTERN
	JRST BAFX2	;ON TO NEXT TRACK
BAFY2E:	MOVEI C,[ASCIZ /BAT TABLE SCREWED UP!!!
/]
	JRST STYO

BAFY7X:	MOVEI C,[ASCIZ /BAT TABLE FULL!!
/]
	PUSHJ P,STYO
	JRST BAFW3	;TRY ANOTHER DRIVE

BAFY1X:	MOVEI C,[ASCIZ /REGION ALREADY IN BAT TABLE
/]
	PUSHJ P,STYO
	JRST BAFX2	;ON TO ANOTHER TRACK

BAFY2F:	MOVEI C,[ASCIZ /TOO MANY BLOCKS IN BAD REGIONS ON DRIVE %G
/]
	JRST STYO
BAFDN:	MOVEI C,[ASCIZ /BAT PROGRAM DONE!
/]
	PUSHJ P,STYO
	JRST CI0


;SUBROUTINE TO PUT PATTERN OF DATA INTO BAFDAT
BAFP:	MOVE A,BAFPAT	;PATTERN #
	ANDI A,3	;ALLOW ANY NUMBER OF PATTERNS BUT CHOOSE FROM 4
	MOVE B,BAFPT0(A)
	MOVEM B,BAFDAT	;1ST WORD
	MOVE B,BAFPT1(A)
	MOVEM B,BAFDAT+1	;2ND WORD
	MOVE B,BAFPT2(A)
	MOVEM B,BAFDAT+2	;3RD AND FINAL WORD
	MOVE B,[BAFDAT,,BAFDAT+3]
	BLT B,BAFDAT+177
	SETZM BAFCT	;NO ERRORS FOR THIS PATTERN
	POPJ P,

BAFPT0:	BYTE (9)666,666,666,660
	BYTE (9)111,111,111,100
	BYTE (8)314,314,314,314
	-20
BAFPT1:	BYTE (9)333,333,333,320
	BYTE (9)444,444,444,440
	BYTE (8)314,314,314,314
	-20
BAFPT2:	BYTE (9)555,555,555,540
	BYTE (9)222,222,222,220
	BYTE (8)314,314,314,314
	-20
;SUBROUTINE TO PUT DEV ADDR INTO A CHAN PGM (ADDR IN B)
BAFT:	MOVE A,IDEVA	;CONTROLLER PART OF DEVICE ADDRESS
	ADDI A,(G)	;DRIVE PART
BAFT1:	LDB C,[POINT 8,(B),7]	;FLAG BYTE OF COMMAND
	JUMPE C,CPOPJ	;IF END OF CHAN PGM
	CAIN C,70
	DPB A,[POINT 8,(B),23]	;IF DEV COMMAND, PUT IN DEV ADDR
	AOJA B,BAFT1	;AND LOOK AT NEXT WORD

;SUBROUTINE TO RUN CHAN PGM -- ADDR IN A -- SKIP RETURNS IF OK
BAFO:	MOVE BF,G	;DRIVE #
	LSH BF,^D9
	ADD BF,BAFPAT	;PATTERN #
	LSH BF,^D12
	ADD BF,BAFCYL	;CYLINDER #
	LSH BF,6
	ADD BF,BAFHED	;HEAD #
	MOVE B,BAFCYL	;CYLINDER #
	DPB B,[POINT 16,BAFTD,15]
	MOVE B,BAFHED	;HEAD #
	DPB B,[POINT 16,BAFTD,31]
	JRST SCHNX	;RUN IT

SALL
;CHAN PGM TO FORMAT A TRACK, READ IT BACK
BAFTP:	BYTE (8)70,37	;SET FILE MASK
	IOW 1,[BYTE (8)300]	;PERMIT ALL
BAFTP1:	BYTE (8)70,SEEK
	IOWC 2,[0]	;2 BYTES OF ZEROS
	IOW 4,BAFTD	;THEN 4 BYTES OF CCHH
BAFTP2:	BYTE (8)70,31	;WRITE HA
	IOWC 1,[0]	;ANOTHER ZERO BYTE
	IOW 4,BAFTD		;CCHH
BAFTP3:	BYTE (8)70,25	;WRITE R0
	IOWC 10,BAFTD	;CCHH0008
	IOW 10,ZEROS	;0
BAFTP4:	ZZ==1
REPEAT NRPT,<
	BYTE (8)70,35	;WRITE CKD
	IOWC 4,BAFTD	;CCHH
	IOWC 4,[ZZ_34+1100_4]	;R, KL, DL DL
	IOW 1100,BAFDAT	;FINALLY THE DATA PATTERN
	ZZ==ZZ+1
	>
	ZZ==1
REPEAT NRPT,<
	BYTE (8)70,61	;SEARCH ID EQUAL
	IOWC 4,BAFTD	;CCHH
	IOW 1,[ZZ_34]	;R
	MOVE .-3	;TRANSFER IN CHANNEL
	BYTE (8)70,6	;READ DATA
	IOW 1100,BAFXBF	;INTO SCRATCH BUFFER
	ZZ==ZZ+1
	>
ZEROS:	REPEAT 10,<0>
;CHAN PGM TO WRITE A TRACK AND READ IT BACK
BAFWP:	BYTE (8)70,SEEK
	IOWC 2,[0]	;00
	IOW 4,BAFTD		;CCHH
	ZZ==1
REPEAT NRPT,<
	BYTE (8)70,61		;SEARCH ID EQUAL
	IOWC 4,BAFTD	;CCHH
	IOW 1,[ZZ_34]		;R
	MOVE .-3
	BYTE (8)70,WRDATA
	IOW 1100,BAFDAT
	ZZ==ZZ+1
	>
	ZZ==1
REPEAT NRPT,<
	BYTE (8)70,61
	IOWC 4,BAFTD
	IOW 1,[ZZ_34]
	MOVE .-3
	BYTE (8)70,6	;READ DATA
	IOW 1100,BAFXBF
	ZZ==ZZ+1
	>
	0
XALL
WBAT:	PUSHJ P,IBAF0	;INITIALIZE BAF TABLE FOR 1ST BAT BLOCK
	PUSHJ P,WBAF	;WRITE IT OUT
	PUSHJ P,IBAF1	;INITIALIZE FOR 2ND BAT BLOCK
WBAF:	MOVEI B,WRDATA	;WRITE DATA COMMAND
	PUSHJ P,RWBAF	;DO THE WRITE
	JRST WBAFE	;IF FAILED
	POPJ P,		;IF OK

WBAFE:	MOVEI C,[ASCIZ /CAN'T WRITE BAT BLOCKS ON DRIVE %G
/]
	PUSHJ P,STYO
	JRST CI0	;REALLY BAD NEWS

RBAF:	MOVEI A,BATBK0	;LBN OF 1ST BAT BLOCK
RBAF0:	MOVEI B,RDDATA	;READ DATA COMMAND
	MOVEM A,RBAFV	;SAVE LBN
	SETZM BAF	;WIPE OUT KEY WORDS..
	MOVE [BAF,,BAF+1]
	BLT BAF+BLKSIZ-1
	PUSHJ P,RWBAF	;READ IN 1ST BAT BLOCK
	JRST RBAF3	;IF ERROR
	MOVE A,[SIXBIT /BAT/]
	MOVEI B,CODBAT
	CAMN A,BAF+BAFNAM
	CAME B,BAF+BAFCOD
	JRST RBAF3	;IF ERROR
	MOVE A,BAF+BAFSLF
	CAME A,RBAFV
	JRST RBAF3	;SELF POINTER WRONG
	SETZM BAFVHI#
	PUSHJ P,BATSU
	PUSHJ P,BATGET	;SCAN TABLE TO SET UP BAFVHI
	CAIA
	JRST .-2
CPOPJ1:	AOS (P)		;SKIP RETURN
	POPJ P,

RBAF3:	MOVEI A,BATBK1	;LBN OF 2ND BAT BLOCK
	CAME A,RBAFV	;HAVE WE TRIED IT ALREADY?
	JRST RBAF0	;NO, GIVE IT A CHANCE
	MOVEI C,[ASCIZ /CAN'T READ GOOD BAT BLOCK ON DRIVE %G
/]
	JRST STYO	;NON-SKIP RETURN
;SUBROUTINE TO INITIALIZE BAF TABLE
IBAF:	SETZM BAF	;FIRST CLEAR
	MOVE A,[BAF,,BAF+1]
	BLT A,BAF+BLKSIZ-1	;ENTIRE BLK
	MOVE A,[SIXBIT /BAT/]
	MOVEM A,BAF+BAFNAM
	MOVE A,[MBRMAX,,BAFREG]
	MOVEM A,BAF+BAFFIR
	MOVE A,SADEVA	;SA-10 DEVICE CODE
	LSH A,^D9
	MOVEM A,BAF+BAFNBS
	SETZM BAF+BAFCNT
	MOVEI A,CODBAT
	MOVEM A,BAF+BAFCOD
IBAF0:	SKIPA A,[BATBK0]	;LBN OF 1ST BAT BLOCK
IBAF1:	MOVEI A,BATBK1		;LBN OF 2ND BAT BLOCK
	MOVEM A,BAF+BAFSLF
	POPJ P,

;SUBROUTINE TO READ OR WRITE BAT BLOCK
RWBAF:	ADDI A,1	;CONVERT BLOCK # TO RECORD #
	DPB A,[POINT 8,BAFPD2,23]
	DPB B,[POINT 8,BAFPG5,15]	;READ DATA OR WRITE DATA COMMAND
	MOVE A,IDEVA		;CONTROLLER ADDR
	ADDI A,(G)		;DRIVE #
	DPB A,[POINT 8,BAFPG1,23]
	DPB A,[POINT 8,BAFPG3,23]
	DPB A,[POINT 8,BAFPG5,23]
	MOVEI A,BAFPG1
	JRST SCHNX		;WILL SKIP FOR GOOD RETURN
;SUBROUTINE TO DETERMINE IF DRIVE AVAILABLE -- SKIP-RETURNS IF IT IS
DRAVL:	MOVE A,IDEVA
	ADDI A,(G)		;DRIVE DEVICE ADDRESS
	DPB A,[POINT 8,DRAVLP,23]
	DPB A,[POINT 8,DRAVLQ,23]
	DPB A,[POINT 8,DRAVLR,23]
	DPB A,[POINT 8,DRAVLS,23]
	MOVEI A,DRAVLP
	JRST SARUNX

DRAVLP:	BYTE (8)70,SEEK
	IOW 6,ZEROS
DRAVLS:	BYTE (8)70,26
	IOW 20,DRVLD0
DRAVLQ:	BYTE (8)70,SCHIDE
	IOW 5,DRVLD0
	200000,,DRAVLQ
DRAVLR:	BYTE (8)50,WRDATA
	IOW 10,DRAVLD
	0

DRVLD0:	BLOCK 2
DRAVLD:	BLOCK 2
;CHAN PGM FOR RWBAF
BAFPG1:	BYTE (8)70,SEEK
	IOW 6,BAFPD1
BAFPG3:	BYTE (8)71,SCHIDE
	IOW 5,BAFPD1
	200000,,BAFPG3
BAFPG5:	BYTE (8)40
	IOW 200,BAF
	0

BAFPD1:	0	;00CC
BAFPD2:	0	;HHR0
BAFWT:	BLOCK NPACKS
BAFPAT:	0
BAFCYL:	0
BAFHED:	0
BAFCT:	0
BAFF:	0
RBAFV:	0
BAFMAX:	0
BAFYV:	0
BAF:	BLOCK BLKSIZ
BAFDAT:	BLOCK 220
FMZBF:
BAFXBF:	BLOCK 220
BAFTD:	0	;CCHH
	200
;HERE TO DO SENSE, DEV ADR IN A
SENSEX:	JSP SAGPSH
	PUSHJ P,SNSX0
	MOVEM A,STBUFS		;SAVE SENSE STATUS
	JSP SAGPOP
	POPJ P,

ZRRBL:	PUSH P,[CI0]
	PUSHJ P,CSET
	SKIPGE A,PREARG
	LDB A,[DEVFLD,,SENSEP]
	PUSHJ P,RRBL
	JRST SCHNE
	JRST PSB

RRBL:	DPB A,[DEVFLD,,RRBLP]
	MOVEI A,RRBLP
	JRST SARUN

SNSX0:	DPB A,[DEVFLD,,SENSEP]	;STORE DEV ADR IN SENSE
	SETOM SENSED	;INIT SENSE BUFFER
ZZ==1
REPEAT 5,<
	SETZM SENSED+ZZ
ZZ==ZZ+1
>
	MOVEI A,SENSEP	;GET PROG ADR & FALL INTO SAGO

;RUN PROG UNTIL EXECUTED OR REJECTED
SAGO:	HRRM A,@CBASE
	MOVEI 100000	;# STATUSES TO WADE THRU
	MCONO SA0,CLMERR	;CLEAR PREV MEM ERR
SAGO1:	MCONO SA0,@STBSYC	;START PROG
	PUSHJ P,SAGSTS		;WAIT FOR STATUS
	POPJ P,		;BAD ERROR
	TLNN A,121054	;PROG EXECUTED OR UNEXECUTABLE?
	SOJG SAGO1	;NO - KEEP TRYING A WHILE
	POPJ P,

;WAIT FOR STATUS
SAGSTS:	PUSHJ P,SACLST
	XCT DCONI
	TLNN DD,1
	JRST SAGSTE	;NO SA10
	MOVSI A,1	;SET UP TIMEOUT
SAGST1:	MCONSZ SA0,PARERR!NXM
	JRST SAGSTE	;MEM ERR - GIVE ERR RET
	MCONSO SA0,@STFLG
	SOJG A,SAGST1
	MCONSO SA0,PARERR!NXM	;GOT STAT - CHECK ONCE MORE FOR MEM ERR
	JUMPN A,SAGST2
SAGSTE:	MCONI SA0,A	;ERR - GET CONI
	ANDI A,-10	;CLEAR USELESS BITS
	HRLI A,10000	;FLAG PSEUDO-STATUS
	POPJ P,

SAGST2:	MOVE A,@CBASE+1	;NO MEM ERR, NO TIMEOUT - GET STAT
	TRZ A,7777	;MAKE SURE NO GARBAGE HERE
	JRST CPOPJ1

SACLST:	SETZM @CBASE+1	;CLEAR OLD STATUS
	SETZM @CBASE+2
	MCONO SA0,@CLSTFC	;CLEAR STATUS FLAG (EXPECTED ON HERE)
	POPJ P,
;RUN PROG, DO SENSE IF ERR, FILTER OUT STATISTICS IF A0=1
SARUNX:	HRLI A,600000	;SET "IGNORE STAT" & "FORCE SENSE"
SARUN:	MOVEM A,SARPA#	;SAVE PROG ADR
	JSP SAGPSH
SARUN0:	PUSHJ P,SAGO	;RUN PROG
	MOVEM A,STBUF	;SAVE STAT
	MOVE @CBASE+2
	MOVEM STBUF2	;& SECOND STAT
	TLNN A,10040
	JRST SARUNS	;REAL STAT W/O CHN END - DO SENSE
	TLNE A,10000
	JRST SARNLZ	;DON'T SENSE IF MEM ERR OR TIMEOUT
	MOVE SARPA
	TLNE A,10
	JRST SARUNS
	TLNN 200000
	JRST SARNOK	;NO SENSE DESIRED
SARUNS:	LSH A,-14	;ADJUST DEV ADR
	PUSHJ P,SNSX0	;DO SENSE
	MOVEM A,STBUFS	;SAVE SENSE STAT
	HLRZ A
	ANDI 177774	;GET STAT BITS
	MOVE A,STBUF	;GET STAT FROM OP
	TRO A,1		;FLAG SENSE DONE
	SKIPGE SARPA	;IF NOT IGNORE STATISTICS MODE
	CAIE 60		;OR BAD STAT FROM SENSE
	JRST SARXIT	;GIVE ERR RET
	HLRZ A
	ANDI 173774	;GET OLD STAT BITS
	CAIE 10
	JRST SARXIT	;NOT SIMPLE INIT UNIT CHK, GIVE ERR RET
	LDB [POINT 24,SENSED,23]	;GET SENSE BYTES 0-2
	CAIN 20		;IF JUST ENVIRONMENTAL DATA
	JRST SARUNR	;RETRY PROG
SARXIT:	TLNN A,173314	;IF NO ERRS
	AOS -3(P)	;GIVE GOOD RET
	JSP SAGPOP
	POPJ P,		;& EXIT

SARNOK:	SETZM SENSED
	TLNE A,173314	;IF ANY ERRS
SARNLZ:	SETOM SENSED	;MAKE SENSE LOOK BAD
	JRST SARXIT	;GO RESTORE THINGS

SARUNR:	MOVE A,SARPA	;ENVIRONMENTAL DATA - GET START ADR
	JRST SARUN0	;& TRY AGAIN

SAGPSH:	PUSH P,@CBASE
	PUSH P,0
	MOVSI 200000
	MOVEM @CBASE
	MCONO SA0,@STSRQC
	MOVEI 1000
SAGPS1:	MCONSO SA0,@STFLG
	SOJG SAGPS1
	MOVE @CBASE+1
	EXCH (P)
	PUSH P,@CBASE+2
	JRST @0

SAGPOP:	POP P,@CBASE+2
	EXCH (P)
	TLC 600000
	TLCE 600000
	JRST SAGPP2
	SETZM @CBASE+1
	SETZM @CBASE+2
	POP P,0
	POP P,@CBASE
	MCONO SA0,@CLSTFC
	JRST @0

	MCONO SA0,@CLSTFC
SAGPP2:	MOVEM @CBASE+1
	POP P,0
	POP P,@CBASE
	JRST @0
;RUN PROG, PRINT SENSE DATA IF ERR
SCHNX:	HRLI A,600000	;ENTER HERE TO IGNORE STATS & FORCE SENSE
SCHN:	PUSHJ P,SARUN	;RUN PROG
	CAIA
	JRST CPOPJ1	;NO ERR - GIVE GOOD RET
SCHNE:	MOVEI C,[ASCIZ /
 !!! ERROR !!!
/]
	PUSHJ P,STYO
	PUSHJ P,PSTAT	;PRINT STATUS
	MOVE D,STBUF2
	MOVEI C,[ASCIZ /SW2=%D
/]
	TRNN A,1
	JRST STYO
	PUSHJ P,STYO
	JRST PSD	;PRINT SENSE DATA ALSO

;PRINT STATUS (A), PRESERVES A
PSTAT:	PUSH P,A
	LSH A,-42
	MOVE C,STTT(A)
	PUSHJ P,STYO
	MOVE A,(P)
	MOVEI C,[ASCIZ / STATUS/]
	PUSHJ P,STYO
	MOVE A,(P)
	TLNE A,10000
	JRST PSMER
	LDB D,[DEVFLD,,A]
	MOVEI C,[ASCIZ /, DEVICE %D =/]
	PUSHJ P,STYO
	HLRZ E,(P)
	ANDI E,177774
	MOVEI D,STAMSG-2
PSTAT2:	PUSHJ P,PBITS
	PUSHJ P,CR
POPAJ:	POP P,A
	POPJ P,

PSMER:	MOVEI B,"="
	PUSHJ P,TYO
	ANDI A,PARERR!NXM
	MOVE E,A
	MOVEI D,MEBITS-17
	JRST PSTAT2

MEBITS:	[ASCIZ /NXM/]
	[ASCIZ /PARERR/]
PSD:	PUSHJ P,PSB
	MOVE E,SENSED
	AOJE E,CR
	LSH E,-34
	MOVEI D,SNS2MS
	PUSHJ P,PBITS
	JRST CR

PSB:	PUSHJ P,CR
	MOVE	F,SENSED
	AOJE	F,[HRROI C,[ASCIZ \MISSING
\]
	 	JRST	STYO]
	PUSHJ	P,CR
	MOVE F,[440400,,SENSED]
	MOVEI D,6
PS0:	MOVEI E,^D8
PS1:	ILDB B,F
	CAILE B,^D9
	ADDI B,"A"-"0"-^D10
	ADDI B,"0"
	PUSHJ P,TYO
	MOVEI B,40
	TLNE F,40000
	PUSHJ P,TYO
	SOJG E,PS1
	PUSHJ P,TYO
	IBP F
	TRNE D,1
	PUSHJ P,CR
	SOJG D,PS0
	POPJ P,

PS:	PUSHJ P,PSB
	JRST DDT
PDEV==16	;DEFAULT PRINTER DEVICE CODE
PBUFLB==^D132	;NUMBER CHARS PER LINE
PBUFL==PBUFLB/4	;WORDS OF PRINT BUFFER
UCBLB==^D240	;NUMBER OF LOGICAL CHARS ON CHAIN
UCBL==UCBLB/4	;WORDS FOR UCB BUFFER

DEFINE UCS2 (A,B,C,D)
<BYTE (8)"A","B","C","D">

DEFINE UCS1 (AA,BB,CC)
<UCS2 1,2,3,4
UCS2 5,6,7,8
UCS2 9,0,X,Y
UCS2 /,S,T,U
BYTE (8)"V","W",AA,BB
BYTE (8)CC,"*",",","="
UCS2 J,K,L,M
UCS2 N,O,P,Q
UCS2 R,-,Z,<(>
UCS2 A,B,C,D
UCS2 E,F,G,H
UCS2 I,+,.,<)>
>

	SALL
UCB:	UCS1 137,42,"$"
	UCS1 74,73,"#"
	UCS1 "?",76,40
	UCS1 "]","'","&"
	UCS1 "[",":","%"
UCBE:	UCS1 137,42,"$"


PAT0:	UCS2 A,B,C,D
	UCS2 E,F,G,H
	UCS2 I,J,K,L
	UCS2 M,N,O,P
	UCS2 Q,R,S,T
	UCS2 U,V,W,X
	UCS2 Y,Z,0,1
	UCS2 2,3,4,5
	UCS2 6,7,8,9
	BYTE (8)"/","*",",","="
	BYTE (8)"-","(","+","."
	BYTE (8)")",137,42,"$"
	BYTE (8)74,73,"#","?"
	BYTE (8)76,40,"]","'"
	BYTE (8)"&","[",":","%"

;48 HN
PAT1:	BYTE (8)301,302,303,304
	BYTE (8)305,306,307,310
	BYTE (8)311,321,322,323
	BYTE (8)324,325,326,327
	BYTE (8)330,331,342,343
	BYTE (8)344,345,346,347
	BYTE (8)350,351,360,361
	BYTE (8)362,363,364,365
	BYTE (8)366,367,370,371
	BYTE (8)141,134,153,176
	BYTE (8)140,115,116,113
	BYTE (8)135,175,120,133
	XALL
PBUF:	BLOCK PBUFL
PBUFE:

RIP0:	MOVE G,PTSTV	;MODE
	AOS C,PPOS
	MOVE B,[441000,,PBUF]
	MOVE A,PTSTV	;MODE
	ANDI A,377
	CAIL A,3
	JRST RIP2
	SOJG A,RIP3
	MOVEI D,^D48
	TRNE G,400
	JRST RIP1	;IF 48-CHAR CHAIN
	MOVEI D,^D45
	SKIPL A
	MOVEI D,^D60
RIP1:	AOS E,C
	IDIV E,D
	ROT F,-2
	MOVE E,PAT0(F)
	TRNE G,400
	MOVE E,PAT1(F)	;IF 48-CHAR CHAIN
	LSH F,-^D31
	LSH E,-^D28(F)
	IDPB E,B
	CAME B,[041000,,PBUFE-1]
	JRST RIP1
	POPJ P,

RIP2:	IDPB A,B
	CAME B,[041000,,PBUFE-1]
	JRST RIP2
	POPJ P,

RIP3:	IMULI C,43
RIP3A:	MOVEI G,3
RIP4:	AOS E,C
	IDIVI E,^D288
	ROT F,-2
	MOVE E,UCB(F)
	LSH F,-^D31
	LSH E,-^D28(F)
	IDPB E,B
	SOJG G,RIP4
	CAME B,[041000,,PBUFE-1]
	SOJA C,RIP3A
	POPJ P,
PTST:	PUSHJ P,CSET	;CHAN # IN A
	SKIPL A,PREARG
	MOVEM A,PDEVA	;DEV ADDR
	SKIPL A,P2ARG	;1ST OF 3 ARGS
	MOVEM A,PTSTV	;IS MODE
	MOVE A,PDEVA
	DPB A,[141000,,PRTI]	;PUT IN CHAN PGM
	DPB A,[141000,,PRTI2]
	DPB A,[141000,,PRTI3]
	DPB A,[141000,,PRGO]
	DPB A,[141000,,PRGO1]
	MOVEI A,400
	TDNE A,PTSTV
	JRST PTST1	;IF NOT UCS
	MOVEI A,PRTI
	PUSHJ P,SCHN
	JRST DDT
PTST1:	PUSHJ P,RIP0
	MOVEI A,PRGO
	PUSHJ P,SCHN
	JRST DDT
	PUSHJ P,CHKCNC
	POPJ P,
	JRST PTST1	;KEEP GOING UNTIL CHAR STRUCK

PRTI:	BYTE (8)260,353,PDEV
PRTI2:	BYTE (8)70,373,PDEV
	IOW (360,UCB)
PRTI3:	BYTE (8)240,3,PDEV
PRTIE:	0
PRGO:	BYTE (8)70,11,PDEV
	IOW (PBUFLB,PBUF)
PRGO1:	BYTE (8)240,3,PDEV
PRGOE:	0
PPOS:	0
PDEVA:	PDEV
PTSTV:	0
QTT:	SETOM TAPF		;FOR ERROR ROUTINE
	SETZM RECDNO		;CLEAR COUNTERS
	SETZM REWNO		; OF RECORDS, REWINDS, WRITE ERRS
	SETZM WERRNO		; ..
	PUSHJ P,CSET	;CHAN # IN A
	SKIPL A,PREARG
	MOVEM A,TDEV	;DEV ADDR
QTT0:	MCONO SA0,RSTSA	;RESET, START CLOCK
	MOVNI A,^D10000
	AOJL A,.	;DELAY A BIT AFTER RESET
	SETZB I,K	;START AT REC 0
	MOVE A,TDEV	;SET DEVICE NUMBER OF TAPE ON IBM BUS
	DPB A,[DEVFLD,,TREW]
	DPB A,[DEVFLD,,TERG]
	DPB A,[DEVFLD,,TCP0]	;SET CHANNEL PGM FOR PROPER DEV
	DPB A,[DEVFLD,,TCP0W]
	DPB A,[DEVFLD,,TCP1]
	DPB A,[DEVFLD,,TCP2]
	MOVN A,KTRECL		;MINUS LENGTH OF RECORD
	ADDI A,7
IFLE CV,<
	ASH A,2>		;SIXTEEN BIT WD CT
IFG CV,<
	ASH A,6>
	HRLM A,TCP0B		;SET CHANNEL PROGRAM LENGTHS
	MOVN A,KTRECL
	ADDI A,13
IFLE CV,<
	ASH A,2>
IFG CV,<
	ASH A,6>
	HRLM A,TCP2B		; ..
	SETZM F7TK	;ASSUME NINE TRACK DRIVE
	PUSHJ P,TSENSE	;GET THE DRIVE SENSE DATA
	PUSHJ P,SACLST	;CLEAR FLAG
	MOVEI A,323	;6250 GCR 9 TK
	MOVE J,SENSED+1
	TRNE J,100000	;6250 BIT
	JRST QTT07
	MOVE A,SENSED+0	;7 TRACK BIT
	TLNE A,100	; ..
	SETOM F7TK	;IT IS A 7 TRACK DRIVE
	MOVEI A,303	;MODE SET FOR 1600 PE 9 TK
	SKIPGE F7TK	;UNLESS 7 TRACK,
	MOVEI A,223	;MAKE IT 800 BPI, ODD, NO XLATORS
QTT07:	DPB A,[241000,,TCP0]
	PUSHJ P,TGB	;FILL FIRST BUFFER (REC 0)
	MOVEI A,7	;SET UP INIT REWIND
	DPB A,[241000,,TREW]
	MOVEI A,3	;CHAINED TO NOP
	DPB A,[241000,,TERG]
	MOVE A,[MOVE TREW]	;DO REWIND THIS TIME
	PUSHJ P,TGO0	;START FIRST OPER
	SKIPN NOINTF#
	PUSHJ P,INTFRN	;RUN INTERFERENCE  ON ADJACENT CHAN
	;FALLS THROUGH
;FALLS IN
QTT1:	SETZM INFPB+1	;FOR INTERFERENCE CHECK
	MOVEI I,1(K)	;GENERATE DATA FOR REC N+1
	PUSHJ P,TGB
	PUSHJ P,TWT	;WAIT FOR COMPLETION ON REC N
	ADDI K,1	;NOW ON NEXT REC
	PUSHJ P,TGO	;START IT
	MOVEI I,-1(K)	;SET TO CHECK DATA ON N-1
	PUSHJ P,TCB	;CHECK IT
	MOVEI C,[ASCIZ /INTERFERENCE CHAN PGM DIED
/]
	SKIPE NOINTF#
	JRST .+3
	SKIPL INFPB+1	;IF INTF PGM RUNNING OK
	JRST QTT1E
	PUSHJ P,CHKCNC
	CAIA
	JRST QTT1	;KEEP GOING IF KEY NOT STRUCK
	PUSHJ P,TWT	;IF SO, WAIT FOR TERMINATION
	JRST CI0	;AND EXIT TO COMMAND LEVEL

TGB:	TDZA J,J	;J=0 FOR GENERATE
TCB:	MOVEI J,1	;J=1 FOR CHECK
	MOVN H,KTRECL		;LENGTH OF RECORD
	MOVE G,ADRLO	;SETUP FOR BUF 0
	TRNN I,1	;SKIP IF ODD REC
	JRST TCB1	;EVEN. DON'T OFFSET
	JUMPN J,TCB3	;DON'T USE NEW RANDOM ADR FOR CHECK
	ADD G,KTRECL	;STEP UP TWO BUFFERS
	ADD G,KTRECL	; ..
	PUSHJ P,RND	;RANDOM #
	MOVE A,ADRHI	;TOP OF MEM
	SUB A,KTRECL	;LEAVE ROOM...
	SUB A,KTRECL	;...FOR 2 BUFFERS
	SUB A,G	;SPACE REMAINING
	IDIV B,A	;GET RANDOM REMAINDER
	ADD G,C	;OFFSET INTO SPACE
	MOVEM G,TGOBUF	;ADDR OF BUFFER PAIR
TCB1:	MOVE D,I	;USE REC # FOR SEED WORD
	MOVE C,KTRECL	;POINTER TO SECOND BUFFER OF PAIR (READ)
	IMUL D,[175*175*175*175]
TGB1:	MOVE A,G
	PUSHJ P,MAPA
TCB2:	XCT TGB3(J)	;STORE OR CHECK DATA (MOVEM OR CAMN)
	JRST TGB2	;OK
	MOVE E,(A)	;ERROR, GET BAD WORD
	MOVE F,H	;- REMAINING COUNT
	ADD F,KTRECL	;GET INDEX TO READ WORD
	MOVEI C,[ASCIZ /DATA ERR, REC=%I, WD=%F, WROTE=%D, GOT=%E
/]
QTT1E:	PUSHJ P,STYO
	JRST CI0	;RETURN TO COMMAND LEVEL
;I.E., TOTAL ABORT ON ANY DATA FAILURE

TGB2:	TLNN D,200000
	TLC D,400000	;FEEDBACK SHIFT REGISTER TYPE RANDOMIZER
	ROT D,1
	ADDI G,1
	AOJL H,TGB1	;LOOP FOR EACH WD OF REC
	POPJ P,

TGB3:	MOVEM D,(A)		;XCT'ED FOR DATA GENERATE
	CAMN D,(A)		;XCT'ED FOR DATA CHECK

TCB3:	MOVE G,TGOBUF	;MAKE SURE WE GET SAME RANDOM ADR
	JRST TCB1	;AS WE USED FOR WRITE
TGO:	MOVE A,[MOVE TCP0]	;I.E., TCH TCP0. SKIP REWIND
TGO0:	AOS RECDNO		;STARTING ANOTHER RECORD
	MOVEM A,@CBASE	;SET UP PTR TO CHAN PGM, BASE FOR THIS CHAN
	LDB A,[200,,K]		;DECIDE PACKING MODE FROM RECD NO.
	MOVE A,TGOT(A)		;TOP BYTE FOR READ COMMAND
	DPB A,[341000,,TCP2]	;PUT IN READ COMMAND
	ADDI A,22		;ADD CHAIN AND SLI BITS
	DPB A,[341000,,TCP0W]	;PUT IN WRITE COMMAND, MATCHING FORMAT.
	MOVE A,ADRLO
	TRNN K,1		;WHICH BUFFER? (ODD/EVEN REC)
	JRST TGO1		;EVEN. FIRST PAIR
	MOVE A,TGOBUF	;ODD
TGO1:	DPB A,[2600,,TCP0A]	;PUT IN CHAN PGM
	ADDI A,7
	DPB A,[2600,,TCP0B]	; SECOND OF TWO WRITE  POINTERS
	SUBI A,7
	ADD A,KTRECL		;AND SECOND OF PAIR IS FOR READING
	DPB A,[2600,,TCP2A]	;SETUP READ ADDR
	ADDI A,13
	DPB A,[2600,,TCP2B]	; SECOND READ POINTER
	MCONO SA0,@STBSYC	; SPIN!
	POPJ P,

TGOT:	EXP 40,140,150,140	;WORD, NAT, TCOMPAT, NAT.
; NON-PI WAIT LOOP

TWT:	MOVSI A,1
TWT0:	MCONSZ SA0,PARERR+NXM
	JRST TWME	;MEM ERR, BAD NEWS
	MCONSO SA0,@STFLG
	SOJG A,TWT0
	JUMPLE A,TWE	;IF TIMED OUT
	MOVE A,@CBASE+1	;GET STATUS
TWT1:	TLNE A,163010
	JRST TWE	;BAD BITS ON
	TLNE A,200
	JRST TWRST	;CU END, RESTART
	LDB DD,[DEVFLD,,A]
	CAME DD,TDEV
	JRST TWE
	TLNE A,4
	JRST TWUX	;UNIT EXCEPTION, PROBABLY EOT
	TLNE A,100
	JRST TWBSY	;CONTROL BUSY OR STATUS PENDING
	TLNN A,20
	JRST TWE	;NO DEVICE END IN STATUS
	TLNN A,40
	JRST TWRST	;DEVICE END ALONE
	HRRZ A,@CBASE+2	;LOOKS OK. CHECK THAT WHOLE PGM WAS DONE
	CAIE A,TCPE+1
	JRST TWE	;WASN'T
;HERE IF ALL IS WELL
TWTX:	PUSHJ P,SACLST
	PUSHJ P,CHKCNC
	JRST CI0	;QUIT IF CHAR TYPED IN
	POPJ P,

TDEV:	TUNIT		;THIS GOES INTO CHAN CMDS BELOW
KTRECL:	TRECL		;LENGTH OF RECORDS IN TAPE TEST
TREW:	BYTE (8)260	;NO MEM XFER, GO, CHAIN, REWIND OR BACKSPACE
TERG:	BYTE (8)260	;NO MEM XFER, GO, CHAIN, NOP OR ERG
TCP0:	BYTE (8)260	;NO MEM XFER, GO, CHAIN, SET MODE
TCP0W:	BYTE (8)162,1	;GO, CHAIN, SLI, WRITE
TCP0A:	IOWC (7,0)	;BFR ADDR PLUGGED IN RH THIS WD
TCP0B:	IOW (TRECL-7,0)
TCP1:	BYTE (8)260,47	;NO MEM XFER, GO, CHAIN, BACKSPACE BLOCK
TCP2:	BYTE (8)140,2	;GO, READ
TCP2A:	IOWC (13,0)
TCP2B:	IOW (TRECL-13,0)
TCPE:	0		;HALT
TGOBUF:	0
TWRST:	PUSHJ P,SACLST
	MCONO SA0,@STBSYC	; TRY OPERATION AGAIN
	JRST TWT	;AND WAIT FOR RESULTS

TWBSY:	TLNE A,260
	JRST TWRST	;JUST PENDING STATUS, TRY AGAIN
	PUSHJ P,SACLST
	JRST TWT	;REALLY BUSY, WAIT FOR COMPLETION

TWUX:	HRRZ A,@CBASE+2
	CAIN A,TCP0
	JRST TWUX0		;ALSO OK IF FAILURE ON ERASE
	CAIE A,TCP1		; PC POINTING AFTER THE WRITE?
	JRST TWE	;BOMBED IN WRONG PLACE, ERROR
TWUX0:	AOS D,REWNO	;COUNT REWINDS
	MOVE E,RECDNO	;TYPE SUMMARY FOR PASS
	MOVEI C,[ASCIZ /END OF TAPE, PASS $D, $E RECORDS.
/]
	PUSHJ P,STYO
	MOVEI A,7	;REWIND CMD
	MOVEI B,3	;NOP CMD
TWUX1:	DPB A,[241000,,TREW]	;BACK HERE ON WRITE ERR TOO
	DPB B,[241000,,TERG]
	MOVEI A,TREW
	HRRM A,@CBASE	;SET TO REWIND OR ERASE TAPE, IF
			; WRITE ERROR,  AND TRY AGAIN
	JRST TWRST

TWME:	PUSHJ P,TSPE1	;TYPE MESSAGE
	JRST CI0	;AND ABORT THE TEST
TWE:	MOVE A,@CBASE+1
	TLNN A,10
	JRST TWEX	;OTHER THAN UNIT CHECK, GIVE UP
	HRRZ A,@CBASE+2	;WHAT WAS CHANNEL PC AT FAILURE?
	CAIE A,TCP1	;WRITE ERROR?
	JRST TWEX	;FAILURE NOT ON WRITE CMD, GIVE UP
	PUSH P,@CBASE+1	;YES. TRY TO RECOVER
	PUSH P,@CBASE+2
	PUSHJ P,TSENSE	;GET SENSE BYTES FROM TAPE UNIT
	LSH A,-24	;ISOLATE SENSE STATUS
	TRZ A,4000/4	;WITHOUT LENGTH ERR
	CAIE A,14
	JRST TWEX1	;NOT CHEND+DEVEND, GIVE UP
	LDB A,[341000,,SENSED]	;FIRST BYTE OF SENSE DATA
	CAIE A,10
	JRST TWEX1	;NOT JUST A DATA CHK
	POP P,@CBASE+2	;DATA ERROR ON WRITE. TRY TO
			; ERASE GAP, RE-WRITE.
	POP P,@CBASE+1	;MOSTLY JUST TO RESTORE PDL
	MOVE E,RECDNO	;REPORT THE WRITE ERROR.
	AOS D,WERRNO
	LDB F,[141000,,SENSED]	;GET SENSE BYTE 2 (T.I.E.)
	MOVEI C,[ASCIZ /WRITE ERROR # $D, RECORD $E, TIE=%F
/]
	PUSHJ P,STYO
	MOVEI A,47	;BACKSPACE
	MOVEI B,27	;ERASE GAP
	JRST TWUX1	;GO TRY TO RECOVER

TSENSE:	MOVE A,TDEV
	JRST SENSEX
TWEX1:	POP P,@CBASE+2	;RESET STATUS FOR MESSAGE
	POP P,@CBASE+1
TWEX:	SETOM TAPF	;TELL ERR ROUTINE ITS TAPE
	PUSHJ P,TSPE1	;TYPE MESSAGE
	JRST CI0	;ABORT TEST

TAPF:	0
TAPSNS:	[ASCIZ /NOT CAP/]
	[ASCIZ /FILE PROT/]
	[ASCIZ /WRT STAT/]
	[ASCIZ /LD POINT/]
	[ASCIZ /7 TRK/]
	[ASCIZ /TU ST B/]
	[ASCIZ /TU ST A/]
	[ASCIZ /NOISE/]
	[ASCIZ /DATA CONV CHK/]
	[ASCIZ /WC ZERO/]
	[ASCIZ /OVERRUN/]
	[ASCIZ /DATA CHK/]
	[ASCIZ /EQUIP CHK/]
	[ASCIZ /BUS OUT CHK/]
	[ASCIZ /INTERVENTION REQ/]
	[ASCIZ /COMMAND REJECT/]

RECDNO:	BLOCK 1
REWNO:	BLOCK 1
WERRNO:	BLOCK 1
F7TK:	BLOCK 1
LSTBUF==1
PSEEK:	120034000000+<IDEV_14>	;SEEK, BYTE MODE
	IOW 6,SEEKD
	0
SEEKD:	0
	0
SENSEP:	BYTE (8)50,SENSE
	IOW 30,SENSED
	0

RRBLP:	BYTE (8)50,244
	IOW 30,SENSED
	0

SENSED:	BLOCK 6
STBUF:	BLOCK LSTBUF
STBUF2:	BLOCK LSTBUF
STBUFS:	BLOCK LSTBUF
IAR:	0
BPLOC:	-1

	EXTERN .JBREL
IOLIST:	EXP 0,0

SUPER:	OPEN 1,[EXP 17,SIXBIT /SUPER/,0]
	HALT .
	MTAPE 1,1
	MTAPE 1,0
	MOVN A,.JBREL
	MOVSI A,GOGO(A)
	HRRI A,GOGO-1
	MOVEM A,IOLIST
	OUT 1,IOLIST
	SKIPA
	HALT .
	RELEAS 1,
	EXIT
SUPER0:	0
SUPER1:	0

PPP=PUSHJ P,PWORLD

DEFINE PPPN(N)<
PP'N=PUSHJ P,PWLD'N
PWLD'N:	PUSH P,G
	MOVEI G,N
	PPP
	POP P,G
	POPJ P,
>
ZZ==0
REPEAT 4,<
PPPN \ZZ
ZZ==ZZ+1
>

PWORLD:	PUSH P,A
	MOVE A,G
	PUSHJ P,CHNCHK
	JRST POPAJ
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSH P,E
	PUSH P,DD
	CONI PI,B
	CONO PI,400
	MCONI SA0,A
	HRL A,B
	PUSH P,A
	MOVNI B,1	;NO SUBCHANNEL SEL YET
	MCONO SA0,RDCONI
	MDATAI SA0,A
	TLNE A,2
	JRST PW00	;CLOCK RUNNING - OK
	MCONO SA0,RDCCI
	MDATAI SA0,B	;CLOCK STOPPED, REMEMBER WHICH SUBCHANNEL
PW00:	PUSH P,B	;SAVE SUBCHANNEL SELECTION
	JUMPGE B,PW00A
	MCONO SA0,SASTEP
PW00A:	PUSHJ P,STEPCX
	MOVSI D,-6
PW0:	MCONO SA0,@PW0T1(D)
	MOVE C,PW0T2(D)
	PUSHJ P,STYO
	MDATAI SA0,A
	TRNN D,-1
	PUSH P,A	;SAVE THIS CHAN'S IAR
	TRNN D,-1
	ANDI A,1777
	PUSHJ P,OPT
	AOBJN D,PW0
	MCONO SA0,RDCCI
	MOVSI D,-4
PW1:	MOVE C,BTIMT(D)
	PUSHJ P,STYO1
	MDATAO SA0,BTIMD(D)
	MDATAI SA0,A
	LDB A,[121000,,A]
	PUSHJ P,OPT
	AOBJN D,PW1
	MOVSI D,-4
	MOVEI E,040000
PW2:	MOVE C,PCWT(D)
	PUSHJ P,STYO1
	MOVE C,[301000,,A]
	ADDI E,400
PW2A:	MDATAO SA0,E
	MDATAI SA0,B
	LSH B,-12
	IDPB B,C
	ADDI E,400
	TRNE E,1400
	JRST PW2A
	LSH A,-4
	PUSHJ P,OPT
	AOBJN D,PW2
	MOVSI D,-4
	MOVEI E,140002
PW3:	MOVE C,REGT(D)
	PUSHJ P,STYO1
	MOVE C,[441000,,A]
PW3A:	MDATAO SA0,E
	MDATAI SA0,B
	LSH B,-12
	IDPB B,C
	TRNE E,2000
	JRST PW3B
	ADDI E,400
	JRST PW3A
PW3B:	LSH A,-4
	LSHC A,4
	PUSHJ P,OPT
	ADDI E,6000
	AOBJN D,PW3
	MOVEI C,[ASCIZ \
TDS0=\]
	PUSHJ P,STYO
	MDATAI SA0,A
	LDB A,[100400,,A]
	PUSHJ P,OPT
	POP P,A		;GET SAVED IAR
	ANDI A,1777	;MAKE INTO GOTO
	PUSHJ P,CXXCT	;RESTORE IAR
	POP P,B
	JUMPL B,[MCONO SA0,SACGO	;CLOCK WAS RUNNING - RESTART IT
		JRST PWLDX]
	PUSH P,G
	LDB G,[POINT 2,B,17]	;CLOCK WAS STOPPED - GET OLD CHAN
	PUSHJ P,STEPCX	;GET BACK TO IT
	POP P,G
PWLDX:	POP P,A
	TRZ A,-10
	MCONO SA0,(A)	;RESTORE PIA
	TLNE A,200
	CONO PI,200
	POP P,DD
	POP P,E
	POP P,D
	POP P,C
	POP P,B
	POP P,A
;*****			;FALLS THRU TO CR
CR:	MOVEI C,[ASCIZ \
\]
STYO:	JRST	PNTCHK
	HRLI C,440700
STYO1:	ILDB B,C
	CAIN B,"%"
	JRST STYO2
	CAIN B,"$"
	JRST STYO3		;DECIMAL TYPEOUT
	CAIN B,"\"
	JRST STYO4		;HEX TYPEOUT
	JUMPE B,CPOPJ
	PUSHJ P,TYO
	JRST STYO1

STYO2:	ILDB B,C
	CAIGE B,"A"
	JRST STYO5
	MOVE A,A-"A"(B)
	PUSHJ P,OPT
	JRST STYO1
STYO3:	ILDB B,C
	CAIGE B,"A"
	JRST STYO5A
	MOVE A,A-"A"(B)
	PUSHJ P,DPT
	JRST STYO1
STYO4:	ILDB B,C
	MOVE A,A-"A"(B)
	PUSHJ P,HPT
	JRST STYO1

STYO5A:	TLO B,(1B0)	;USE $ FOR SIGNED VERSION
STYO5:	SUBI B,"0"	;CHAR AFTER % IS DIGIT - USE AS RADIX (@ FOR HEX)
	ILDB A,C
	CAIL A,"A"	;ANOTHER DIGIT?
	JRST STYO6
	TLO B,-"0"(A)	;YES, SET MIN FIELD WIDTH
	ILDB A,C
STYO6:	MOVE A,A-"A"(A)
	PUSHJ P,RDXPRT	;PRINT NUM WITH SPECIFIED PARAMS
	JRST STYO1

CR4:	PUSHJ P,CR2
CR2:	PUSHJ P,CR
	JRST CR

TYO:	CAIL B,40			;PRINTABLE CHAR.?
	JRST LPTTST			;YES GO PRINT IT
	JUMPE B,CPOPJ
	CAILE B,15
	JRST .+3
	CAIL B,7			;IS THIS A CONTROL CHAR?
	JRST LPTTST			;NO
	PUSH P,B
	MOVEI B,"^"			;TYPE CTRL CHARS AS ^X
	PUSHJ P,TYO0			;ALWAYS PRINT CONTROL CHAR'S ON TTY
	MOVE B,(P)
	ADDI B,100
	PUSHJ P,TYO0
	POP P,B
	POPJ P,

PROMPT:	HRLI	C,440700		;USED BY NEXT INSTRUCTION
	ILDB	B,C
	JUMPE	B,.+3			;JUMP IF END OF CHAR STRING
	PUSHJ	P,TYO0			;GO PRINT ON TTY
	JRST	PROMPT+1
	POPJ	P,			;ALL DONE

PNTCHK:	XCT	RDSWS
	TLNN	DD,40000		;INHIBIT PRINTOUT?
	JRST	STYO+1			;NO,KEEP GOING
	PUSHJ	P,CHKCNC		;YES,GO SEE IF KEY STRUCK ON TTY
	JRST	CI0			;YES,GO BACK TO COMMAND TO SEE WHAT THEY WANT
	POPJ	P,			;NO,KEEP GOING

LPTTST:	TLNN	DD,20000		;PRINT ON LINEPRINTER?
	JRST	TYO0			;NO,GO PRINT IT ON TTY
LPTOUT:	CONSO	LPT,1000		;LPT DONE?
	JRST	.-1			;NO,KEEPLOOKING
	DATAO	LPT,B
	CAIE	B,12			;WAS CHAR A LINEFEED?
	POPJ	P,			;NO
	PUSHJ	P,CHKCNC		;YES,GO SEE IF OPER WANTS TO STOP
	JRST	CI0			;YES,GO TO COMMAND LEVEL
	POPJ	P,			;NO,KEEP GOING

OPT:	TLNN A,-1
	JRST OPT1
	PUSH P,A
	HLRZS A
	PUSHJ P,OPT2
	POP P,A
	MOVEI B,54
	PUSHJ P,TYO
	PUSHJ P,TYO
OPT1:	HRRZS A
OPT2:	IDIVI A,10
	JUMPE A,OPT3
	HRLM B,(P)
	PUSHJ P,OPT2
OPT3A:	HLRZ B,(P)
OPT3:	ADDI B,"0"
	CAILE B,"9"
	ADDI B,"A"-"9"-1
TYO0:	XCT TYOSKP
	JRST .-1
	XCT TYOGO
	CAIE B,12
CPOPJ:	POPJ P,
	PUSHJ P,CHKCNC	;CHECK FOR ^C AFTER EACH LINE
	 JRST CI0
	MOVNI B,^D10000
TYOF0:	XCT TYOSKP
	AOJL B,TYOF0
	JUMPGE B,TYOF9
	SETCM B,TYOFIL
	MOVEM B,TYOFCT
	MOVEI B,0
TYOF1:	AOSL TYOFCT
	JRST TYOF9
	PUSHJ P,TYO0	;A NULL AS FILLER
	JRST TYOF1

TYOF9:	MOVEI B,12
	POPJ P,

TYOFIL:	4	;# OF FILL CHARACTERS TO DO AFTER L.F.
TYOFCT:	0
DPT:	SKIPA B,[SETZ 12]	;SIGNED DECIMAL PRINTOUT
HPT:	MOVEI B,20	;UNSIGNED HEX
;*****			;FALLS THRU

;ROUTINE TO PRINT NUM (A) IN RADIX (B18-35) PADDED TO AT LEAST (B1-17)
;DIGITS, SIGNED IF B0=1

RDXPRT:	JUMPL A,.+2
	TLZ B,(1B0)	;IGNORE SIGNED MODE IF NON-NEG ARG
	HRRZM B,ORADX#
	HLRZM B,OWID#
	TLZN B,(1B0)	;DO WE NEED A - ?
	JRST RDXPR0
	HLRZM B,OWID#	;YES, FIX WIDTH (WAS STORED WITH B18 ON)
	MOVEI B,"-"
	PUSHJ P,TYO	;PRINT A -
	MOVNS A		;MAKE ARG POS (UNLESS SETZ)
RDXPR0:	LSHC A,-^D35
	LSH B,-1
	DIV A,ORADX	;DO DIVIDE IN DOUBLE PRECISION SO UNSIGNED WORKS
	SOSG OWID
	JUMPE A,OPT3	;UNWIND IF NO MORE DIGITS & ADEQUATE WIDTH
	HRLM B,(P)
	PUSHJ P,RDXPR0	;ELSE RECURSE
	JRST OPT3A

SETSAA:	MOVE DD,SADEVA
	CAMN DD,DDEVA
	POPJ P,
	MOVEM DD,DDEVA
	LSH DD,-2
	DPB DD,[320700,,DCONO]
	DPB DD,[320700,,DCONI]
	DPB DD,[320700,,DDATAO]
	DPB DD,[320700,,DDATAI]
	MOVSI DD,(1B0)
	IORM DD,CURSEQ	;RECHECK SEQUENCE ON NEW SA10
	POPJ P,

DCONO:	CONO SA0,(DD)
DCONI:	CONI SA0,DD
DDATAO:	DATAO SA0,DD
DDATAI:	DATAI SA0,DD
DDEVA:	-1

IDEVA:	IDEV	;CONTROLLER ADDRESS FOR DISK TEST
BASEA:	BASE	;BASE ADDRESS FOR SA-10 FIXED DATA BLOCK
SADEVA:	SA0	;SA-10 DEVICE ADDRESS

STATCT:	0
IDEVT:	0
BTIMT:	440700,,[ASCIZ \
BUS= \]
	440700,,[ASCIZ \
TAG= \]
	440700,,[ASCIZ \
INS= \]
	440700,,[ASCIZ \
MISC=\]

BTIMD:	144000
	145000
	145400
	142400

PCWT:	440700,,[ASCIZ \
WC=  \]
	440700,,[ASCIZ \
CA=  \]
	440700,,[ASCIZ \
PC=  \]
	440700,,[ASCIZ \
A3=  \]

REGT:	440700,,[ASCIZ \
R0=  \]
	440700,,[ASCIZ \
R1=  \]
	440700,,[ASCIZ \
R2=  \]
	440700,,[ASCIZ \
R3=  \]

PW0T1:	RDCCI
	RDMA
	RDMBL
	RDMBR
	RDCONI
	RDBITS

PW0T2:	[ASCIZ /
IARB=/]
	[ASCIZ /
MA=  /]
	[ASCIZ /
MBLT=/]
	[ASCIZ /
MBRT=/]
	[ASCIZ /
CONI=/]
	[ASCIZ /
BITS=/]
CSET:	PUSHJ P,CHNCHK
	CAIA
	MOVEM A,CHAN
	PUSHJ P,STEP0	;STOP CLOCK
	MOVEI A,43700	;XANC CA,MAGIC,0,LOAD
	PUSHJ P,C0XCT	;LOAD BASE ADR INTO CA
	MOVEI A,42260	;XANC CA,INCR,0,STWRD
	PUSHJ P,C0XCT	;LOAD CA INTO MA
	MCONO SA0,RDMA
	MDATAI SA0,A	;READ IN BASE ADDRESS SWITCHES
	MCONO SA0,400000	;START CLOCK
	CAMN A,BASEA
	JRST CSET3	;IF BASE ADDRESS IS AS EXPECTED
	MOVEM A,BASEA	;OTHERWISE CHANGE IT
	MOVEI C,[ASCIZ /BASE ADDR SW = %A
/]
	PUSHJ P,STYO	;AND INFORM OPERATOR
CSET3:	MOVE A,CHAN
	LSH A,2
	ADD A,BASEA
	MOVEM A,CBASE
	ADDI A,1
	MOVEM A,CBASE+1
	ADDI A,1
	MOVEM A,CBASE+2
	MOVE A,CHAN
	DPB A,[030200,,STBSYC]
	DPB A,[030200,,CLSTFC]
	DPB A,[030200,,STPIEC]
	DPB A,[030200,,STSRQC]
	DPB A,[030200,,SELRSC]
	MOVE A,STBTB(A)
	MOVEM A,STFLG
	LSH A,4
	MOVEM A,GOBIT
	LSH A,4
	MOVEM A,PIEBIT
	POPJ P,0

CHAN:	0
CBASE:	BLOCK 3
STBSYC:	STBSY+SA0CH
CLSTFC:	CLSTF+SA0CH
STPIEC:	STPIE+SA0CH
STSRQC:	STSRQ+SA0CH
SELRSC:	340+SA0CH
STFLG:	0
GOBIT:	0
PIEBIT:	0

STBTB:	EXP STF0,STF1,STF2,STF3
;SUBCHANNEL SEQUENCE CHECK

RDSEQ:	XCT DCONI
	TLNN DD,1
	JRST ERR1	;NO SA10
	PUSHJ P,RDSQ1	;GET SEQUENCE
	CAMN B,CURSEQ
	POPJ P,		;SAME AS BEFORE
	MOVEM B,CURSEQ
	MOVE C,B
	DPB C,[POINT 2,C,3]
	LSH C,-2
	EQV B,C
	MOVE A,B
	LSH A,-1
	AND A,B
	TDNE A,[12525252525]
	JRST SEQERR	;SAME CHAN SERVED TWICE IN A ROW
	MOVEI A,2
RDSQL3:	DPB C,[POINT 2,C,3]
	LSH C,-2
	CAME C,CURSEQ	;FIND LENGTH OF SEQUENCE
	AOJA A,RDSQL3
	MOVEM A,SEQLEN
	MOVE B,[POINT 2,CURSEQ,3]
	MOVEI D,0
RDSQL4:	ILDB C,B
	MOVE C,SQITAB(C)
	ADDM C,SEQLEN	;COUNT SHARE FOR EACH CHAN
	TDON D,C
	ADDI D,1	;COUNT CHANS ACTIVE
	SOJG A,RDSQL4
	DPB D,NCHNP
	MOVE C,D
	ANDI D,7
	CAME C,LSQTAB(D)
	JRST SEQERR	;ILLEG COMB OF CHANS
	MOVEI C,[ASCIZ /%D-CH SA10/]
	PUSHJ P,STYO
	MOVE D,SEQCTI
RDSQL5:	ILDB A,D
	JUMPE A,CR
	LDB B,SEQLNP
	PUSHJ P,GCD
	LDB E,D
	IDIV E,A	;REDUCE USAGE FRACTION
	LDB F,[POINT 6,SEQLEN,35]
	IDIV F,A
	MOVEI C,[ASCIZ !, $E/$F!]
	PUSHJ P,STYO	;PRINT ITS SHARE
	TLNE D,600000
	JRST RDSQL5
	JRST CR
;GET SUBCHANNEL SEQUENCE
RDSQ0:	MOVE B,[POINT 2,C,3]
	MOVEI C,0
RDSQL1:	MCONO SA0,SASTEP!RDCCI
	MDATAI SA0,A
	HLRZ A,A
	IDPB A,B	;STORE 16 TICKS WORTH OF SEQUENCE
	TLNE B,770000
	JRST RDSQL1
	POPJ P,

;GET SEQUENCE IN NORMALIZED FORM
RDSQ1:	PUSHJ P,RDSQ0
	MOVE B,C
	MOVEI A,20
RDSQL2:	DPB C,[POINT 2,C,3]
	LSH C,-2
	CAMGE C,B
	MOVE B,C	;FIND LOWEST-VALUED ROTATION OF SEQUENCE
	SOJG A,RDSQL2
	POPJ P,

SEQERR:	MOVNI D,1
	EXCH D,CURSEQ
	JRST ERR2

CURSEQ:	-1
SEQLEN:	0
SEQCTI:	POINT 6,SEQLEN
SEQCNT:	POINT 6,SEQLEN,5
	POINT 6,SEQLEN,11
	POINT 6,SEQLEN,17
	POINT 6,SEQLEN,23
NCHNP:	POINT 6,SEQLEN,29
SEQLNP:	POINT 6,SEQLEN,35

SQITAB:	EXP 1B5,1B11,1B17,1B23
LSQTAB:	EXP -1,1B5+1,1B5+1B11+2,1B5+1B11+1B17+3,1B5+1B11+1B17+1B23+4

CHNCHK:	PUSHJ P,SETSAA	;MAKE SURE WE HAVE THE RIGHT SA10
	SKIPL CURSEQ
	JRST CHNCK2
	PIRP <	PUSH P,>,<A,B,C,D,E,F,G>
	MOVSI A,(1B0)
	ANDCAM A,CURSEQ
	PUSHJ P,RDSEQ
	PIRP <	POP P,>,<G,F,E,D,C,B,A>
CHNCK2:	LDB NCHNP
	JUMPL A,CPOPJ
	CAMLE A
	AOS (P)
	POPJ P,

GCD:	CAMLE A,B
GCD1:	EXCH A,B
	IDIV B,A
	JUMPE C,CPOPJ
	MOVE B,C
	JRST GCD1
INT1:	0
	MOVEI I,1
	CAME I,PIE	;ARE WE EXPECTING AN INTERRUPT ON THIS CHANNEL?
	JRST ERR31	;NO
	MCONO SA0,CLSTF(B)	;REMOVE THE CAUSE FOR THIS INTERRUPT
			;(MAIN PROGRAM HAS SET B UP)
	CLEARM PIE	;NOTE THAT NO FURTHER INTERRUPTS ARE EX-
			;PECTED, ALSO TELL MAIN PROGRAM THAT ONE
			;INTERRUPT DID OCCUR
	JRST 12,@INT1

INT2:	0
	MOVEI I,2
	CAME I,PIE
	JRST ERR32
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT2

INT3:	0
	MOVEI I,3
	CAME I,PIE
	JRST ERR33
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT3

INT4:	0
	MOVEI I,4
	CAME I,PIE
	JRST ERR34
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT4

INT5:	0
	MOVEI I,5
	CAME I,PIE
	JRST ERR35
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT5


INT6:	0
	MOVEI I,6
	CAME I,PIE
	JRST ERR36
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT6

INT7:	0
	MOVEI I,7
	CAME I,PIE
	JRST ERR37
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT7

PIE:	0	;CHANNEL ON WHICH INTERRUPT IS EXPECTED
UUOH:	0
UUOH1:	SOS UUOH
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#100-/]
	[ASCIZ /
UUO AT /]
	UUOH
	0
	DDT

MUUOH:	EXCH A,UPT+425	;MUUO ADDRESS
	MOVEM A,UUOH
	EXCH A,UPT+425
	JRST UUOH1

PAGEH:	0
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#101-/]
	[ASCIZ /
PAGE FAULT AT /]
	PAGEH
	0
	DDT

PAGEKL:	CONSZ APR,@NXMBIT
	JRST PAGNXM
PAGKL2:	EXCH A,EPT+501
	MOVEM A,PAGEH
	EXCH A,EPT+501
	JRST PAGEH+1

PAGNXM:	MOVEM A,PAGEH
	LDB A,[POINT 5,500,5]	;NXM ON - SEE WHAT KIND OF FAULT
	CAIE A,36
	JRST PAGKL2
	MOVE A,PAGEH	;AR DATA PAR ERR FROM NXM - IGNORE FAULT
	AOS 501
	JRSTF @501	;RETURN PAST NXM INSTR

PDLH:	0
	MOVE P,[-LPDL,,PDL-1]
	SOS PDLH
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#102-/]
	[ASCIZ /
PDL OVERFLOW AT /]
	PDLH
	0
	DDT

PDLINT:	EXCH A,APRI
	MOVEM A,PDLH
	EXCH A,APRI
	JRST PDLH+1
;WRAPAROUND TESTS;  PUT SPECIAL JUMPER CABLE BETWEEN BUS-IN AND BUS-OUT OF CHANNEL N
;  THEN GO TO WRAPN

WRAP0:	MOVEI G,0
	JRST WRP

WRAP1:	MOVEI G,1
	JRST WRP

WRAP2:	MOVEI G,2
	JRST WRP
WRAP3:	MOVEI G,3

WRP:	MOVEI A,^D8	;8 BIT POSITIONS TO CHECK
	PUSHJ P,PTN
	LDB D,[1000,,A]	;RIGHT 8 BITS
WRP2:	MOVEI A,2400	;PULSE 01
	PUSHJ P,CXXCT	;RESET OP STATUS BITS
	MOVE A,D	;DATA BYTE
	PUSHJ P,PARITY	;COMPUTE ODD PARITY
	MOVE A,D
	DPB B,[100100,,A]	;PUT PAR BIT LEFT OF DATA BITS
	LSH A,-1	;AND SHIFT RIGHT 1 BIT
	MOVEM A,WRAPV	;EXPECTED DATA BYTE
	MOVE A,D
	PUSHJ P,CXXCT	;DO GOTO WITH INITIAL BYTE
	MOVEI A,40120
	PUSHJ P,CXXCT	;DO IARB TO BUS OUT
	MOVEI A,144000
	MDATAO SA0,A	;ROUTE BUS IN TO C BUS
	MCONO SA0,RDCCI
	MDATAI SA0,B	;READ IN CBUS, ETC.
	LDB B,[121000,,B]	;EXTRACT C BUS
	CAME B,WRAPV	;THE MOMENT OF TRUTH
	JRST ERR42
WRP4:	LOOP ^D42,WRP2	;IF LOOPING TEST, USE SAME DATA
	PUSHJ P,STEPX	;DO THE BUSIN TO CBUS
	MOVEI A,145400
	MDATAO SA0,A	;ROUTE OP STATUS BITS TO CBUS
	MCONO SA0,RDCCI
	MDATAI SA0,C	;READ IN CBUS, ETC.
	TRNE C,40000	;BUS IN PAR ERR?
	JRST ERR43	;YES
WRP6:	LOOP ^D43,WRP2	;TRY AGAIN IF LOOPING
	JSR PTN0	;DO NEXT DATA VALUE
	JRST DDT	;WHEN ALL DONE
;GENERATE ODD PARITY OF WORD IN A
;  LEAVES 0 IN A, 0 OR 1 IN B
PARITY:	MOVEI B,0
PARIT1:	TRNE A,1
	TRC B,1
	LSH A,-1
	JUMPN A,PARIT1
	POPJ P,
EXTERN DDT

RRR:	0
	MOVEM A,SAVA
	MOVEM B,SAVB
	MOVEM C,SAVC
	MOVEM D,SAVD
	XCT	@RRR			;DO THE INSRTUCTION FOLLOWING JSR
	PUSHJ P,RRRT
	JRST RRR2	;IF TYPEOUT SUPPRESSED
	PUSHJ P,STYO
	MOVE D,SAVD
RRR2:	AOS C,RRR
	SKIPN C,(C)
	JRST RRR8
	PUSHJ P,RRRT
	JRST RRR3	;IF NO PRINTOUT
	PUSHJ P,STYO
RRR3:	AOS C,RRR
	SKIPN C,(C)
	JRST RRR8
	PUSHJ P,RRRT
	JRST RRR2	;IF NO PRINTOUT
	TLNN C,777777
	JRST RRR4
	PUSH P,E	;SAVE E
	HLRZ D,C
	MOVE E,(C)
	PUSHJ P,PBITS	;PRINT TEXT FOR EACH BIT ON
	POP P,E	;RESTORE E
	JRST RRR2

RRR4:	MOVE A,(C)
	PUSHJ P,OPT
	JRST RRR2

RRR8:	AOS C,RRR
	MOVE C,(C)
	HRRM C,RRR
	MOVEI C,[ASCIZ /
/]
	XCT	RDSWS
	TLNN	DD,40000		;INHIBIT PRINT?
	PUSHJ P,STYO
RRR9:	MOVE D,SAVD
	MOVE C,SAVC
	MOVE B,SAVB
	TLNN	DD,400000		;RETURN TO COMMAND LEVEL?
	PUSHJ P,CHKCNC			;ALWAYS STOP ON CTRL-C
	 JRST CI0
	JRST RRR95
	MOVE A,SAVA
	JRST @RRR

RRR95:	MOVE A,SAVA
RRRB:	JRST DDT
	JRST @RRR
RRRT:	XCT	RDSWS
	MOVEI	B,207			;BELL CHAR.
	TLNN	DD,10000		;RING BELL ON ERROR
	XCT	TYOSKP
	JRST RRRT3	;IF TTY BUSY
	XCT TYOGO
RRRT3:	TLNN	DD,40000	;INHIBIT PRINTOUT?
	AOS (P)				;NO
	POPJ P,
SAVA:	0
SAVB:	0
SAVC:	0
SAVD:	0
TESTWD:	10

ERR8:	MCONI SA0,A
	LSH A,-17	;SOME BITS
	DPB A,[50200,,ERR8P2]
	MCONO SA0,RDMA
	MDATAI SA0,ERR8PA
	MOVE A,MEMSTS
IFG CV,	DPB A,[POINT 2,ERR8PA,15]	;HIGH ADR BITS
	LSH A,-15	;MORE BITS
	DPB A,[500,,ERR8P2]
	MCONO SA0,RDMBL+CLMERR
	MDATAI SA0,ERR8P0
	MCONO SA0,RDMBR
	MDATAI SA0,ERR8P1
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#8-/]
	[ASCIZ /MEM READ TIMEOUT: ADR=/]
	ERR8PA
	[ASCIZ /, MBL=/]
	ERR8P0
	[ASCIZ /, MBR=/]
	ERR8P1
	[ASCIZ /;
/]
	ERR8T,,ERR8P2
	0
	PTN9

ERR8T:	[ASCIZ /MEM DONE SYNC/]
	[ASCIZ /MEM BUS DONE/]
	[ASCIZ /MEM ACK/]
	[ASCIZ /MUX ACK/]
	[ASCIZ /WR RQ/]
	[ASCIZ /NXM/]
	[ASCIZ /PAR ERR/]
ERR8PA:	0
ERR8P0:	0
ERR8P1:	0
ERR8P2:	0
ERR30:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#30-/]
	[ASCIZ /DATAI /]
	SAVC
	0
	BEGS

ERR1:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#1-/]
	[ASCIZ /SA10 OFF-LINE/]
	0
	RDSEQ

ERR2:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#2-/]
	[ASCIZ /ILLEGAL CHANNEL SEQUENCE: %4@D/]
	0
	RDSEQ

ERR3:	MOVE E,C
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#3-/]
	[ASCIZ /CHANNEL SEQUENCE TOO LONG, %4@D BECAME %4@E/]
	0
	BEG1

ERR4:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#4-/]
	[ASCIZ /IAR WROTE /]
	SAVB
	[ASCIZ /, READ /]
	SAVA
	0
	IARL1

ERR5:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#5-/]
	[ASCIZ /WROTE IAR /]
	SAVB
	[ASCIZ /, READ CBUS /]
	SAVA
	0
	IARL2

ERR40:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#40-/]
	[ASCIZ /WROTE 0 IN R3 TO MBL, READ /]
	SAVA
	0
	SZER1
ERR11:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#11-/]
	[ASCIZ /WROTE /]
	MAMBTA
	[ASCIZ / IN R2 TO MA, READ /]
	SAVC
	0
	MAMB1A

ERR6:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#6-/]
	[ASCIZ /WROTE /]
	MAMBTL
	[ASCIZ / IN R2 TO MBL, READ /]
	SAVB
	0
	MAMB2

MAMBTL:	0
MAMBTR:	0
INCTW:	0
WRAPV:	0
ERR28V:	0
CWTA:	0
CWTB:	0
ERR7:	HLRZ B,A
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#7-/]
	[ASCIZ /CHAN /]
	SAVB
	[ASCIZ / HAS MEM/]
	0
	MAMB3

ERR12:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#12-/]
	[ASCIZ /WROTE /]
	MAMBTR
	[ASCIZ / IN R2 TO MBR, READ /]
	SAVA
	0
	MAMB4

ERR9:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#9-/]
	[ASCIZ /MEM WRITE TOOK TOO MANY TICKS/]
	0
	TAT5

ERR10:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#10-/]
	[ASCIZ /TRIED TO WRITE %F IN /]
	SAVD
	[ASCIZ /, WHICH CONTAINS %E/]
	0
	TAT7
ERR28:	MOVEI E,3
	SUB E,F
	MOVEM E,ERR28V
	MOVEI E,3
	SUB E,B
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#28-/]
	[ASCIZ /CHAN /]
	G
	[ASCIZ /, WORD /]
	ERR28V
	[ASCIZ /, BYTE /]
	E
	[ASCIZ / WROTE /]
	SAVD
	[ASCIZ /, READ /]
	SAVA
	0
	CWT2A

ERR13:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#13-/]
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T SET PIE/]
	0
	STCL1A

ERR14:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#14-/]
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T CLEAR PIE/]
	0
	STCL1B

ERR15:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#15-/]
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T SET BUSY/]
	0
	STCL1C

ERR16:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#16-/]
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T CLEAR BUSY/]
	0
	STCL1D
ERR17:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#17-/]
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T SET STATUS FLAG/]
	0
	STCL1E

ERR18:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#18-/]
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T CLEAR STATUS FLAG/]
	0
	STCL1F

ERR19:	MOVE C,STCLM(B)
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#19-/]
	[ASCIZ /CAN'T DO /]
	SAVC
	0
	STCLM3

ERR20:	MOVE C,STCLM(B)
	SUBI C,4000
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#20-/]
	[ASCIZ /CAN'T DO /]
	SAVC
	0
	STCLM4

ERR21:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#21-/]
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO NOT EMPTY/]
	0
	FIFO1A

ERR22:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#22-/]
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO EMPTY/]
	0
	FIFO2A

ERR24:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#24-/]
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO NOT FULL/]
	0
	FIFO2B

ERR25:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#25-/]
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO NOT EMPTY/]
	0
	FIFO3A

ERR26:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#26-/]
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO EMPTY/]
	0
	FIFO4A
ERR27:	MOVEI C,NBF
	SUB C,D
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#27-/]
	[ASCIZ /CHAN /]
	G
	[ASCIZ /, WORD /]
	SAVC
	[ASCIZ / WROTE /]
	H
	[ASCIZ /, READ /]
	SAVA
	0
	FIFO4B

ERR23:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#23-/]
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO NOT EMPTY/]
	0
	FIFO4C

ERR29:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#29-/]
	[ASCIZ /INTERRUPT REQ/]
	0
	PITST1

ERR38:	MOVE C,B
	DPB B,[300,,ERR38B]
	ROT C,-3
	DPB C,[200,,ERR38A]
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#38-/]
	[ASCIZ /SA-10 CHAN /]
	ERR38A
	[ASCIZ /, PI CHAN /]
	ERR38B
	[ASCIZ / DOESN'T INTERRUPT/]
	0
	PIT3A

ERR38A:	0
ERR38B:	0

ERR31:
ERR32:
ERR33:
ERR34:
ERR35:
ERR36:
ERR37:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#31-37-/]
	[ASCIZ /PIA /]
	I
	[ASCIZ / INTERRUPTED, /]
	PIE
	[ASCIZ / EXPECTED/]
	0
	CI0
ERR39:	XOR A,INCTW
	MOVE C,INCTW
	TLZ C,777760
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#39-/]
	[ASCIZ ?INC/DEC EXPECTED ?]
	SAVC
	[ASCIZ /, READ /]
	SAVA
	0
	INCT4

ERR41:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#41-/]
	[ASCIZ /UCODE LOC /]
	SAVB
	[ASCIZ / ADDR /]
	SAVC
	[ASCIZ / JUMPED TO /]
	SAVA
	0
	UCT7

ERR42:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#42-/]
	[ASCIZ /EXPECTED /]
	WRAPV
	[ASCIZ /, READ/]
	SAVB
	0
	WRP4

ERR43:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#43-/]
	[ASCIZ /BUS IN PAR ERR/]
	0
	WRP6

ERR44:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#44-/]
	[ASCIZ \CHAN %G NON-HARDWARE BUT MORE THAN 1/16\]
	0
	CPOPJ

ERR50:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#50-/]
	[ASCIZ /CONI SHOULD BE /]
	[1,,7]
	[ASCIZ /, IS /]
	SAVA
	0
	BTECI

BTECI:	SLOOP
BTECI1:	MCONI SA0,A
	JRST BTECI
ERR51:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#51-/]
	[ASCIZ /CONI FAILING/]
	0
	BTECI

ERR52:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#52-/]
	[ASCIZ /SA-10 INACCESSIBLE/]
	0
	BTECI

ERR53:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#53-/]
	[ASCIZ /CONI SHOULD BE /]
	[1,,0]
	[ASCIZ /, IS /]
	SAVA
	0
	BTECR

BTECR:	SLOOP
	XCT APRST
	MCONI SA0,A
	JRST BTECR

ERR54:	LDB D,[301100,,B]
	TRZ D,3
	JSR RRR
	MOVEI	C,[ASCIZ/ERR#54-/]
	[ASCIZ /DEVICE /]
	SAVD
	[ASCIZ / CONI GIVES /]
	[1,,0]
	0
	BTECW

BTECW:	SLOOP
	XCT SAVB
	JRST BTECW

ERR55:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#55-/]
	[ASCIZ /CONO 7 GIVES CONI /]
	SAVA
	0
	BTECC

BTECC:	SLOOP
	MCONO SA0,7
	MCONI SA0,A
	JRST BTECC
ERR56:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#56-/]
	[ASCIZ /RESET GIVES CONI /]
	SAVA
	0
	BTERC

BTERC:	SLOOP
	MCONO SA0,7
	XCT APRST
	JRST BTERC

ERR57:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#57-/]
	[ASCIZ /CONO RDCONI+7 GIVES DATAI /]
	SAVA
	[ASCIZ /, SHOULD BE /]
	[2,,7]
	0
	BTEDI

BTEDI:	SLOOP
	MDATAI SA0,A
	JRST BTEDI

ERR58:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#58-/]
	[ASCIZ /CONO RDCONI+SASTEP GIVES DATAI /]
	SAVA
	0
	BTESD
ERR60:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#60-/]
	[ASCIZ /PORT MUX ACKN DOESN'T SET/]
	0
	MUXRQ1

ERR61:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#61-/]
	[ASCIZ /PORT MUX ACKN DOESN'T CLEAR/]
	0
	MXT2

ERR62:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#62-/]
	[ASCIZ /MEM PAR ERR NOT DETECTED/]
	0
	MPE3

ERR63:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#63-/]
	[ASCIZ /NXM CYCLE COMPLETED AT /]
	E
	0
	NXMT3

ERR64:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#64-/]
	[ASCIZ /NON-NXM ERR DATAI /]
	SAVA
	[ASCIZ / DOING READ FROM /]
	E
	0
	NXMT3

BTESD:	SLOOP
	MCONO SA0,SASTEP
	MCONO SA0,RDCONI
	MDATAI SA0,A
	JRST BTESD
ERR65:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#65-/]
	[ASCIZ /READ DATA /]
	TBTV
	[ASCIZ / FROM LOC /]
	SAVD
	[ASCIZ / AS %E/]
	0
	PTN9

ERR66:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#66-/]
	[ASCIZ /READ CLOBBERS LOC /]
	SAVD
	[ASCIZ / TO %F/]
	0
	PTN9

ERR67:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#67-/]
	[ASCIZ /READ DATA %F IN R0 AS %E/]
	0
	PTN9

ERR68:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#68-/]
	[ASCIZ /MEM USER IS %E, EXPECTED %G/]
	0
	TBT1B

ERR70:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#70-/]
	[ASCIZ /CHAN %G MRB=%E, SHOULD BE /]
	TBTV
	0
	TBT4

ERR71:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#71-/]
	[ASCIZ /CHAN %G R REG %J = %E, SHOULD BE /]
	TBTV
	0
	TCT4A

ERR72:	JSR RRR
	MOVEI	C,[ASCIZ/ERR#72-/]
	[ASCIZ /CHAN %G A REG %J= /]
	TCTV
	[ASCIZ /, SHOULD BE %E/]
	0
	TCT4B
PTN0:	0	;CALLED BY JSR
	JRST PTN1	;ON TO NEXT VALUE

PTN:	0
	ADDI A,PTNTX	;BEG OF SINGLE BITS IN TABLE
	MOVEM A,PTNA	;WHERE IN TABLE TO STOP
	MOVEI A,PTNT-1
	MOVEM A,PTNP	;INITIALIZE POINTER
PTN1:	AOS A,PTNP
	CAML A,PTNA	;AT END OF DATA?
	JRST PTN5	;YES, MAKE 1 RANDOM #
	MOVE A,(A)	;NO, TAKE ENTRY FROM TABLE
	MOVEM A,PTNV	;SAVE VALUE
	JRST @PTN	;EXIT TO TOP OF LOOP

PTN5:	CAME A,PTNA	;GIVEN RANDOM VALUE YET?
	JRST @PTN0	;YES, EXIT TO BOTTOM OF LOOP
	MOVEI A,105	;NO, MAKE IT NOW
	FMPB A,RNDM
	JRST @PTN	;AND EXIT TO TOP OF LOOP

PTN9:	MOVE A,PTNV	;DO LAST VALUE AGAIN
	JRST @PTN

PTNT:	0
	-1
	252525,,252525
	525252,,525252
PTNTX:	REPEAT ^D36,<	EXP 1B<PTNTX-.+^D35>>

PTNA:	0
PTNP:	0
PTNV:	0

TEST:	0
	-1
	252525,,252525
	525252,,525252	;PSEUDO-RANDOM TEST DATA
TEST1:	BLOCK 4	;PLACE TO READ STUFF BACK INTO

CWTD:
IFLE CV,<325125,,340125>
IFG CV,<325137,,340125>
	125120,,252252
	240000,,

STCLM:	014000	;SET BUSY FLAG
	015000	;SET STATUS FLAG
	015400	;SET P.I. ENABLE FLAG

STCLM1:	BSY0
	STF0
	PIE0

BITS:	REPEAT ^D36,<	EXP 1B<.-BITS>>


	BLOCK 10
ZZ==0
REPEAT NPACKS,<
CPG(\ZZ):	BLOCK 400
ZZ==ZZ+1>

	REPEAT 5,<[JSR PDLH]>	;CATCH OVER-POPJ'S
PDL:	BLOCK LPDL	;PUSHDOWN LIST

PATCH:
PAT:	BLOCK 1000

IFN LNKBUG,<
	VAR	;GET EVERYTHING OUT
XLIST	;SAVE LOTS OF PAPER
	LIT
LIST
RELOC .-LNKORG	;NOW PUT OUT A RELOC PROG BREAK TO MAKE LINK HAPPY
>

	END DDTG
   a*f/%