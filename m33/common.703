TITLE COMMON - MONITOR COMMON DATA AREA AND CONFIGURATION DEFINITION -V2120
SUBTTL PART 6 COMMON.MAC - T. HASTINGS/PH/TWE/DAL/EVS/JBS/EGF 5 MAR 86
	SEARCH	F,S
IFN FTNET,<
	SEARCH	NETPRM		;GET NETWORK PARAMETER FILE
	>
IFN FTKL10,<
	SEARCH	ICHPRM
>; END IFN FTKL10
	
	$RELOC
	$ABS

;COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986 BY
;DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.


;
;
XP VCOMMN,2120
				;PUT VERSION NUMBER IN GLOB AND LOADER STORAGE MAP



REPEAT 0, <
;THE COMMON SUBPROGRAM CONSISTS OF 6 FILES ASSEMBLED TOGETHER AS ONE SUBPROGRAM
	1. F.MAC -- FEATURE TESTS (OUTPUT OF MONGEN).
	2. S.MAC -- THE USUAL SYSTEM SYMBOL DEFINITIONS ASSEMBLED WITH
		    EVERY MONITOR SUBPROGRAM
	3. HDWCNF.MAC -- HARDWARE CONFIGURATION
	4. COMMON.MAC - THE REST OF THIS PROGRAM WHICH IS THE SAME SOURCE FOR
	ALL	CONFIGURATIONS.  HOWEVER, THE ASSEMBLIES ARE CONDITIONED BY
	SYMBOLS	AND MACROS DEFINED IN 2.

	THE	FOLLOWING SYMBOLS AND TABLES ARE GENERATED BELOW:

	A. MONITOR STARTUP LOCATIONS (400-407), HENCE LOAD THIS FIRST.
	B. JOB TABLES - LENGTH DEPENDENT ON MAXIMUM NUMBER OF JOBS ALLOWED
	C. ALL VARIABLE STORAGE NOT ASSOCIATED WITH A PARTICULAR DEVICE
	D. COMMON SUBROUTETURNS
	E. COMMON BYTE POINTERS
	F. TABLE OF SERVICE ROUTINE INTERRUPT LOCS TO BE LINKED BY ONCE ONLY CODE
	G. TABLE OF DEVICE DATA BLOCK ADDRESSES AND NUMBER TO BE USED BY ONCE TO
		LINK THEM TOGETHER AND GENERATE MULTIPLE COPIES.
	H. ASSIGNMENT OF PI CHANNELS
	I. PI CHANNEL SAVE AND RESTORE ROUTINES
	J. UUO TRAP LOCATIONS 40/41, 60/61
	K. APR INTERRUPT LOCATIONS CPU0,1, KA10/KI10
	L. SYSTEM CRASH STOP CONI'S.
	NOTE:  SEE COMDEV FOR DEVICE DEPENDENT CODE, DATA, AND SYMBOLS


LEVEL D DISK SERVICE PARAMETERS:

	ALL	SYMBOLS ANAS ONATIONS ARE IN A SEPARATE FILE CALLED
	COMMOD.MAC WHICH IS ALSO ASSEMBLED WITH S AND CONFIG (BUT NOT WITH FEATURS FILES).
	THE	SEPARATE FILE IS FOR TWO REASONS:	1.  ANTICIPATING MULTIPROCESSING SYSTEMS WHICH SHARE DISKS AND 1 16K MEMORY
	(THE DATA MUST BE IN THE COMMON MEMORY)
	2.  ELIMINATE THE NEED TO ASSEMBLE COMMOD IF NOT A DISK SYSTEM
	(COMMOD.MAC TAKES LOTS OF CORE FOR ITS COMPLICATED MACROS)


THE FOLLOWING EQUATES ARE GENERATED FOR REMOTE
COMMUNICATIONS PROGRAM SETUP:	LOCSTA	- THE STATION NUMBER OF THE (PDP10) CENTRAL SITE

		COMMUNICATIONS SOFTWARE
>
IFE FTNET,<IFN M.NET,<PRINTX ?ASSEMBLE SOURCES WITH FTNET=-1
			M.NET==0>>
IFN M.NET,<
	XP	LOCSTA,OURNNM	;DEFINE THE LOCAL NODE NUMBER
>;END OF IFN M.NET

IFE M.NET,<
IFNDEF LOCSTA,<	XP	LOCSTA,0>	;NO, NETWORK DEFINE LOCAL NODE=0
>;END OF IFN M.NET

;Verify that the correct version of MONGEN was used in making the ???CNF
;files (only checks HDWCNF really, but that should be close enough).
;
;Every time that MONGEN is edited, the following check "M.GEN-nnn" should
;also be updated to reflect the new MONGEN edit level (symbol 'EDITNO' in
;MONGEN.MAC).

IFN	M.GEN-306,<
	PRINTX	? Wrong version of MONGEN was used in HDW dialog
	PASS2
	END
>
IFN FTEMRT,<IFE M.KL10,<PRINTX ? CPU MUST BE A KL10 TO SELECT EBOX/MBOX RUNTIME>>
IFN FTCIDSK!FTCITAP,<IFE FTSCA,<PRINTX ?ASSEMBLE SOURCES WITH FTSCA=-1
				XP FTCIDSK,0	;FORCE MULTIPLY DEFINED GLOBALS
				XP FTCITAP,0>>
IFN M.ENET,<IFE FTENET,<PRINTX ?ASSEMBLE SOURCES WITH FTENET=-1
			XP M.ENET,0>>
SUBTTL CONVERT MONGEN SYMBOLS
REPEAT 0,<

;THIS SECTION CONVERTS NEW MONGEN SYMBOLS TO OLD MONGEN SYMBOLS
;SO THAT THE REST OF COMMON AND MONITOR CAN STILL USE THE OLD
;SYMBOLS.  THIS WAS DONE RATHER THAN CONVERTING ALL OF THE
;MONITOR TO NEW SYMBOLS FOR TWO REASONS:
; 1.  IT IS EASIER AND FASTER AND LESS LIKELY TO INTRODUCE BUGS, AND
; 2.  IT ALLOWS CUSTOMERS TO USE OLD MONGEN WITH A MINIMUM
;OF TROUBLE: ONLY A FEW EXTRA SYMBOLS MUST BE DEFINED.
;THE MONITOR WILL PROBABLY BE CONVERTED TO THE NEW MONGEN SYMBOLS
;AFTER THE 5.04 RELEASE.  THE ORDER HERE PARALLELS THE OLD
;MONGEN ORDER.

>

XP SYS40N,0		;NEW MONGEN MAKES SWAPPING SYSTEMS ONLY
XP SYS50N,1
XP DSKN,1
XP LOGINN,1

XP APRSN,M.C0SN		;APR SERIAL NUMBER (REALLY PROCESSOR 0)
XP APR0SN,M.C0SN	;PROCESSOR 0 SERIAL NUMBER
XP APR1SN,M.C1SN	;PROCESSOR 1 SERIAL NUMBER
XP CP0KLN,M.KL10	;PROCESSOR 0 MAY BE A KL10
XP CP1KLN,M.KL10	;PROCESSOR 1 MAY BE A KL10
XP CP0KSN,M.KS10	;PROCESSOR 0 MAY BE A KS10
XP CPUN,M.CPU		;NUMBER OF PROCESSORS

XP LEVDN,1		;NEW MONGEN MAKES ONLY LEVEL D DISK SERVICE
XP LEVCN,0

XP RD10N,M.RC10
XP RH10NS,M.RH1S
XP RH10NP,M.RHP4
XP RP10N,M.RP10
XP RN10N,M.RP20		;RP20
XP RA10N,0		;NO MDF
XP RH11NP,M.R11D

	DEFINE	SYSDEV,<
	SIXBIT	/DSK/
>
XP JOBN,M.JOB+1

IFG	JOBN-^D512,<XP JOBN,^D512
		PRINTX %NUMBER OF JOBS REDUCED TO MAX=511>
XP COREN,M.CORE
XP PDP10N,1
XP KT10AN,MD.2RR
XP SEGN,MD.SEG
XP DDTN,MD.DDT

XP EDITN,0

XP PTRN,M.PTR
XP PTPN,M.PTP
XP PLTN,M.PLT
XP LPTN,M.LPT
IFNDEF M.DLP,<M.DLP==:0>
IFNDEF M.DCR,<M.DCR==:0>
XP DLPTN,M.DLP
XP DCDRN,M.DCR
XP MOVIEN,MD.MOV
XP CDRN,M.CDR
XP CR10N,MD.C10
XP CPFN,M.CDP
XP CDPN,M.CDP
XP VBCN,M.VBXC
IFN	FTXTC,<
XP XTCN,M.XTC
>
IFE	FTXTC,<
IFN	M.XTC,<
PRINTX	?NO DA28 SUPPORT WITH FTXTC=0
PRINTX	?PROCEEDING ASSUMING NO DA28
XP M.XTC,0
XP M.XTL,0
>
XP XTCN,0
>
IFE	M.XTC,<
XP M.XTL,0
XP XTTDSP,CPOPJ
XP XTKLDB,CPOPJ
XP XTUUO,CPOPJ
XP XTCTTY,CPOPJ2
XP XTCIOS,CPOPJ
XP XTCSEC,CPOPJ
>

IFE M.DAS78,<			;IF NO DAS78 SUPPORT
	CALL78==:CPOPJ		;CAL78. UUO IS A NOOP
	D78SEC==:CPOPJ		;NO ONCE-A-SECOND CODE
	D78MIN==:CPOPJ		;NO ONCE-A-MINUTE CODE
> ;END IFE M.DAS78
IFN M.DAS78,<			;IF DAS78 SUPPORT
	M.D78L==:M0D78L		;HACK FOR D78INT
	M78LM==:-M.D78L		;MINUS NUMBER OF LINES
> ;END IFN M.DAS78


XP DISN,M.DIS
XP PENN,M.DIS
XP T340N,M.340
XP TVP10N,M.VP10
XP T30N,0		;NO TYPE 30
;DEFINE ALL DL10 SYMBOLS

	DLX.CK(1)		;MACRO DEFINED IN S.MAC

IFN FTDAS78!DLX.78,<
IFE FTDAS78,<
	PRINTX	?DEFINING A DAS78 REQUIRES FTDAS78 TO BE ON
PDP11N==PDP11N-DLX.78
DLX.78=0			;ACTUAL NUMBER
>
> ;END IFN FTDAS78!DLX.78

IFN FTDN60!DLX.60,<
IFE FTDN60,<
	PRINTX	?DEFINING A DN60 REQUIRES FTDN60 TO BE ON
PDP11N==PDP11N-DLX.60
DLX.60=0			;ACTUAL NUMBER
>
> ;END OF IFN FTDN60!DLX.60
IFN DLX.76,<EXTERN D76INT>
IFE PDP11N,<
	XP	D76MIN,CPOPJ
	XP	D76SIL,CPOPJ
>
IFE PDP11N!M.KL10!M.DN60!M.KDUP!M.DMRN,<
	XP	CALL11,CPOPJ
	XP	DLXSEC,CPOPJ
	XP	DLXWIN,0
> ; END IFE PDP11N!M.DN60!M.KDUP!M.DMRN
IFE DL10XI,<
 IFN PDP11N,<
	XP	DLXDWN,0	;;IF NO PDP-11S ON DL10'S
>>; END OF IFE DL10XI AND IFN PDP11N
DEFINE TDMAC(X),<
	XP	DT'X'N,M.DT'X
M.DTXN==M.DTXN+M.DT'X
>
ZZ=="A"
M.DTXN==0
REPEAT	M.TD10,<
	TDMAC(\"ZZ)
ZZ==ZZ+1
>
IFN FTKS10,<
    DEFINE RX2MAC(X),<
	XP	RX'X'N,M.RX'X
    M.RXXN==M.RXXN+M.RX'X
    >
    ZZ=="A"
    M.RXXN==0
    REPEAT M.RX20,<
	RX2MAC(\"ZZ)
    ZZ==ZZ+1
    >
>;End FTKS10
IFNDEF M.TM10,<XP M.TM10,0>
IFNDEF M.TC10,<XP M.TC10,0>
IFNDEF M.TX01,<XP M.TX01,0>
IFNDEF M.TM02,<XP M.TM02,0>
IFNDEF M.DX20,<XP M.DX20,0>
XP TAPN,M.TM10+M.TC10+M.TX01+M.TM02+M.DX20+M.TM78
IFNDEF MTCN,<MTCN==0>

IFG TAPN,<
DEFINE KONMAC <		;MACRO FOR LOOPING THROU TAPE CONTROLLERS
	..KON==0
	REPEAT	TAPN,<
	  TAPMAC(\..KON)
	  ..KON==..KON+1>
>

DEFINE TAPMAC (X) <
IFE FTAUTC,<
IFE	M.MT'X'T,<TM10A==TM10A+1>	;COUNT TM10A CONTROLLERS
	IFE	<M.MT'X'T-K.TMB>,<TM10B==TM10B+1>	;COUNT TM10B CONTROLLERS
	IFE	<M.MT'X'T-K.TC1>,<TC10C==TC10C+1>
	IFE	<M.MT'X'T-K.TX1>,<DX10N==DX10N+1>	;COUNT OF DX10 CHLS
	IFE	<M.MT'X'T-K.TM2>,<TM02N==TM02N+1>
	IFE	<M.MT'X'T-K.DX2>,<DX20N==DX20N+1>
	XP	MT'X'N,M.MT'X	;# OF UNITS / CONTROLLER
>
IFN FTAUTC,<
DX10N==1
DX20N==1
TM02N==1
>
>
TC10C==0
TM10A==0	;INIT VALUES
TM10B==0
DX10N==0
TM02N==0
DX20N==0

	KONMAC			;PERFORM GOOD STUFF

>	;;; END IFG TAPN

IFNDEF TM10A,<TM10A==0>
IFNDEF TM10B,<TM10B==0>
IFNDEF DX10N,<DX10N==0>
IFNDEF TC10C,<TC10C==0>
IFNDEF TM02N,<TM02N==0>
IFNDEF DX20N,<DX20N==0>
XP PTYN,M.PTY

XP SYSCN,M.SYSC
XP LOKN,M.LOK
XP CMNN,M.MGC
XP RTTRPN,M.RTD
XP HPQN,M.HPQ

IFNDEF M.TTDN,<M.TTDN==:0>
XP M.TLTL,M.TLTL+M.TTDN		;REDEFINE FOR RSX-20F LINES
XP M.TLTL,M.TLTL+M.XTL		;REDEFINE FOR XTC LINES
XP TTD28N,M.XTL
IFN M.KS10,<
XP	KLILIN,M.TLTL+M.RMCR	;LINE NO. FOR KS10 KLINIK
XP	M.TLTL,M.TLTL+1		;ADD ONE FOR KLINIK LINE
>
XP TCONLN,M.TLTL+M.RMCR+M.CPU	;LINE NUMBER FOR CTY (NOT ON SCANNER)

XP CTYLIN,TCONLN

	DEFINE	OPRL(LINE),<
IFIDN <LINE> <CTY>,<SIXBIT /CTY/>
IFDIF <LINE> <CTY>,<
	SIXBIT	/TTY'LINE/
	IFG LINE-M.TLTL,<PRINTX %OPR LINE NOT DEFINED TO BE A LOCAL TTY>
>;END IFDIF <LINE><CTY>
>
SUBTTL	NON-MONGEN'ABLE SYMBOL VALUES

	XP	PAGSIZ,1000	;BASIC MEMORY-UNIT SIZE, IN WORDS

	XP	PG.BDY,PAGSIZ-1	;MASK TO MAKE CORE REQUEST AN EVEN MULTIPLE
				;OF THE BASIC UNIT MINUS ONE
	XP	MPGSIZ,-PAGSIZ

	XP	P2WLSH,11	;PAGES-TO-WORDS "LSH" COUNT
	XP	W2PLSH,-P2WLSH	;WORDS-TO-PAGES "LSH" COUNT
	XP	K2WLSH,12	;SHIFT AMOUNT TO CONVERT # OF K TO # OF WORDS
	XP	W2KLSH,-12	;SHIFT AMOUNT TO CONVERT # OF WORDS TO # OF K
	XP	S2PLSH,11	;SHIFT TO CONVERT SECTION # TO PAGE #
	XP	P2SLSH,-S2PLSH	;OR BACK
	XP	CRPOS,7		;POSITION OF BYTE
	XP	CRSIZ,9
	XP	CRPOS,8
	XP	P2KLSH,-1
	XP	K2PLSH,1
XP BLKSPP,BLKSPK-K2PLSH		;SHIFT AMOUNT TO CALCULATE # OF BLOCKS/PAGE
XP PP256K,^D512/<<PAGSIZ>_-^D9>
SUBTTL DEFAULT SYMBOLS
;THE FOLLOWING STANDARD SYMBOLS CAN BE SUPERSEDED BY A CUSTOMER HAVING
; PREVIOUSLY DEFINED THEM ON THE HDWGEN.MAC FILE USING THE MONGEN PROGRAM....
;**********************************************************************
;ADD NEW SYMBOLS AT END SO EASY TO UPDATE MONGEN APPENDIX	      *
;SYMBOLS SHOULD APPEAR HERE IN COMMON (AND NOT IN COMDEV, OR COMMOD)  *
; UNLESS THEY REFER TO NON-DISK DEVICES OR DISKS RESPECTIVELY.        *
; IF A SYMBOL IS IN COMDEV OR COMMOD, IT SHOULD NOT APPEAR HERE.      *
;**********************************************************************
IFNDEF XPANDN,<XP XPANDN,0>	;FORCE NO EXPANSION OF MACROS
				; UNLESS XPANDN IS DEFINED NON-ZERO WITH MONGEN

IFNDEF APRSN, <XP APRSN,0>	;SERIAL NUMBER OF ARITHMETIC PROCESSOR

				;STANDARD MAG TAPE DENSITY
IFNDEF STDENS, <XP STDENS,5>	;STANDARD = 6250 BPI
				;STDENS,D
				;D=1 (200 BPI), OR D=2 (556 BPI), OR D=3 (800 BPI)

				;NUMBER OF CLOCK TICKS (JIFFIES) PER SECOND
IFNDEF JIFSEC, <XP JIFSEC,M.TPS> ;STANDARD == 60 JIFFIES PER SECOND

XP JIFSC2,JIFSEC/2		;NUMBER OF JIFFIES IN A HALF SECOND (FOR ROUNDING)
XP JIFMIN,JIFSEC*^D60		;NUMBER OF JIFFIES PER MINUTE
JIF2SC==^D2*JIFSEC
IFN FTKL10,<

QQTTY1==:M.TPS/^D7		;SEVENTH SECOND FOR TTIOWS & PQ1(NON-CALASS SCHED)
>
IFN FTKS10,<
QQTTY1==:M.TPS/5		;FIFTH SECOND ON KS10
>
QQRUN1==:QQTTY1

				;NUMBER OF TIMES TO TRY ON DECTAPE ERRORS
IFNDEF DTTRY, <XP DTTRY,4>	;STANDARD == 4 TRIES

				;NUMBER OF NANO-SECONDS PER MEMORY CYCLE
IFNDEF NSPMEM, <XP NSPMEM,^D1000>	;STANDARD == 1000 NANO-SECONDS PER MEMORY CYCLE

IFNDEF TTXTRA <TTXTRA==0>	;NUMBER OF EXTRA TTY DDBS FOR SLAVE LINES
				; AND THE LIKE
IF2,<
IFN M.KL10,<
	DEFINE	TTXTRD(N),<TTXTRA==TTXTRA+M'N'DTEN>
	ZZ==0
	REPEAT	CPUN,<
	TTXTRD(\ZZ)
	ZZ==ZZ+1>
>>				;DEFINE ENOUGH SLAVE DDBS FOR ALL DTES
IFNDEF	M.CRSH,<M.CRSH==<SIXBIT/CRSCPY/>> ;NAME OF PROGRAM TO COPY CRASHES
	EXTERN	MONBTS
;EXTENSIBLE BITMAP MEMORY REQUIREMENTS FOR DECNET

IFN M.DECN,<
ND M.DNCS,4			;CHUNK SIZE IN WORDS
ND M.DNSZ,30000			;INITIAL ALLOCATION AMOUNT IN WORDS
ND M.DNTH,4000			;THRESHOLD ALLOCATION AMOUNT IN WORDS
ND M.DNIN,4000			;INCREMENTAL ALLOCATION AMOUNT IN WORDS
ND M.DNMN,10000			;MINIMUM ALLOCATION AMOUNT IN WORDS
ND M.DNMX,100000		;MAXIMUM ALLOCATION AMOUNT IN WORDS

XP DCNSIZ,<PAGSIZ*<<M.DNSZ+PAGSIZ-1>/PAGSIZ>>
XP DCNMAX,<PAGSIZ*<<M.DNMX+PAGSIZ-1>/PAGSIZ>>
>; END IFN M.DECN

;FREE CORE ALLOCATION REQUIREMENTS FOR SCA'S RANDOM SIZED POOL.

IFE M.SCA,<			;IF NO SCA SUPPORT
XP SCASIZ,0			;NO SCA FREE POOL
>; END IFE M.SCA
IFN M.SCA,<			;IF SCA SUPPORT
ND M.SCSZ,4000			;CAN BE REDEFINED AT MONGEN TIME
XP SCASIZ,<^D144*<<M.SCSZ+^D143>/^D144>>
>; END IFN M.SCA

;FREE CORE ALLOCATION FOR ETHERNET POOL

IFE M.ENET,<
XP ETHSIZ,0
XP KNISIZ,0
>; END IFE M.ENET

IFN M.ENET,<
ND M.ETSZ,3000			;CAN BE REDEFINED AT MONGEN TIME
ETHSIZ==M.ETSZ			;SIZE OF POOL WITHOUT LAT

IFN M.LATN,<
ND M.LASZ,15000			;CAN BE REDEFINED AT MONGEN TIME
ETHSIZ==M.ETSZ+M.LASZ		;SIZE OF POOL WITH LAT
>; END IFN M.LATN

XP ETHSIZ,<^D144*<<ETHSIZ+^D143>/^D144>>

;FREE CORE ALLOCATION FOR KLNI POOL

IFE M.KL10,<
XP KNISIZ,0
>; END IFE M.KL10

IFN M.KL10,<
ND M.KNSZ,3000			;CAN BE REDEFINED AT MONGEN TIME
XP KNISIZ,<^D144*<<M.KNSZ+^D143>/^D144>>
>; END IFN M.KL10

>; END IFN M.ENET
;FREE CORE ALLOCATION REQUIREMENTS FOR DISK
; DEVICE DATA BLOCKS AND ACCESS TABLE ENTRIES.

XP CORSIZ,4		;NO. OF WORDS IN MONITOR FREE CORE BLOCKS
IFN DSKN,<
IFNDEF MINCOR, <XP MINCOR,JOBN*^D300> ;ASSUME 300 WORDS PER JOB
IFL MINCOR-6*^D300,<XP MINCOR,6*^D300>>  ; BUT PUT FLOOR UNDER MINCOR

ND	EXTRAW,0		;MONGEN'ABLE "EXTRA" WORDS OF FREE CORE

IFNDEF LOGSIZ, <XP LOGSIZ,^D34>	;STANDARD == 17K (CURRENT SIZE OF LOGIN CUSP)
				;MINIMUM AMOUNT OF VIRTUAL CORE WHICH CAN REMAIN AND
				; STILL LET THE SYSTEM PERMIT LOG-INS.  MUST BE
				; AT LEAST AS BIG AS LOGIN CUSP IN K.
XP BLKSPK,^D3			;# OF PLACES TO SHIFT LEFT TO CONVERT BLOCKS TO K
XP MBKSPK,-BLKSPK		;# OF PLACES TO SHIFT RIGHT TO CONVERT K TO BLOCKS
XP MAXLVL,5			;ABSOLUTE MAX LEVEL OF NESTED SFD'S

IFNDEF INDPPN,<XP INDPPN,0>	;NON-ZERO IF CUSTOMER WANTS PROGRAMMER NOS
				; IN PROJECT X TO BE INDEPENDENT OF THOSE IN PROJECT Y

IF1,<
IFNDEF SYSSEG,<XP SYSSEG,-1>	;MINUS ONE FOR FAST GETSEG FROM SYS
				; WITH SOMEWHAT DIFFERENT BEHAVIOR
				; WHEN SHR FILES ARE SUPERCEDED
IFDEF	SYSSEG,<IFN	<SYSSEG+1>,<XP SYSSEG,0>>
XP SYSSEG,SS.SYS&SYSSEG		;SYSSEG=:0 OR SS.SYS
>
IFNDEF CTYDCR,<XP CTYDCR,0>	;DELAY FOR CR ON LA36 CTY DURING ONCE
IFNDEF CTYDLF,<XP CTYDLF,0>	;DELAY FOR LF ON LA36 CTY DURING ONCE
IFNDEF RLDTIM,<XP RLDTIM,^D112>  ;TIME TO AUTO-RELOAD
IFNDEF M.STOF,<XP M.STOF,0>	;FREQUENCY TO CALL START TERMINAL OUTPUT (SHOULD BE2**N-1)
IFNDEF M.RCMP,<XP M.RCMP,0>	;DEFAULT TO PERMISSIVE ACCESS
				;SET TO 1 FOR MORE SECURE ACCESS
IFNDEF M.NPPC,<XP M.NPPC,0>	;DEFAULT TO PRIMARY PROTOCOL ON DTE'S
				;SET TO 1 TO DISABLE PRIMARY PROTOCOL
IFNDEF	MINMAX,<XP MINMAX,^D1024*^D12> ;SMALLEST LEGAL CORMAX
;NOTE--IN ORDER TO RESERVE PI-CHANNELS FOR
;NON-STANDARD USAGE, FOR EACH CHANNEL (SAY N)
;DEFINE SYMBOL UNIQN==1 VIA MONGEN.  FOR
;EXAMPLE, TO RESERVE CHANNEL 4, DEFINE
;UNIQ4==1.

;MOST OF THE SLAVE PROCESSOR CHANNELS ARE BUSIED OUT TO PREVENT CORE
;FROM BEING WASTED FOR CHANNEL SAVE ROUTINES

IFNDEF CPTOS,<XP CPTOS,0>	;CPTOS EQUAL TO ZERO MAKES CPU0 TRAP TO 40-61, CPU1 TO 140-161
				;CPTOS NON-ZERO MAKES CPU0 TRAP TO 140-161, CPU1 TO 40-61

IFNDEF SFC0,<XP	SFC0,^D20>	;CPU0 SCHEDULER FAIRNESS COUNT.  PICK A JOB OUT OF
				;PQ2 INSTEAD OF PQ1 IF 'SFC0' PICKS IN A ROW HAVE COME FROM PQ1 AND NULL JOB DID NOT RUN.

IFNDEF SFC1,<XP	SFC1,^D20>	;CPU1 SCHEDULER FAIRNESS COUNT
				;PICK THIS MANY JOBS TO RUN ON CPU0.  WHICH
				; CAME FROM CPU1 UUOS BEFORE PICKING OTHER JOBS

IFNDEF IFC0,<XP IFC0,^D5>	;SWAPPER FAIRNESS COUNT MAXIMUM


IFNDEF UFC0,<XP	UFC0,^D10>	;UUO FAIRNESS COUNTER MAXIMUM

IFNDEF UFC1,<XP	UFC1,^D10>	;UUO FAIRNESS COUNTER FOR SLAVE
				;PICK UFC1 JOBS TO RUN ON CPU1
				;WHICH CAME FROM CPU0 AND JUST FINISHED
				;A UUO
IFNDEF MEMITL,<XP MEMITL,^D4>	;NUMBER OF WAYS MEMORY CAN BE INTERLEAVED
IFNDEF	MLACTS,<XP MLACTS,^D39>  ;MAXIMUM LENGTH OF THE ACCOUNT STRING
				; IF NOT DEFINED, 39 CHARACTERS
IFNDEF SCHEDN,<SCHEDN==0>	;SCHEDULE VALUE
SCHEDN==SCHEDN&777777		;ONLY A RIGHT HALF NUMBER
IFNDEF	PAVJSP,<XP PAVJSP,^D20>	;PREDICTED AVERAGE JOB SIZE
IFG	MLACTS-^D39,<XP MLACTS,^D39>  ;MAXIMUM LENGTH IS 39 CHARACTERS
IFL	MLACTS,<XP MLACTS,0>
IFG	MLACTS,<XP ACTSTL, MLACTS/^D5+1> ;LENGTH OF ACCOUNT STRING IN WORDS
IFE	MLACTS,<XP ACTSTL,0>
XP MACTSL,-ACTSTL
XP MAXACS,^D8		;MAX LENGTH OF ACCOUNT STRING
IFNDEF M.CBAT,<XP M.CBAT,^D10>	;NO. OF BAD ADDRESSES IN PER CPU BAD
				; ADDRESS TABLE FOR MEMORY PARITY RECORDING
IFNDEF M.BMAX,<XP M.BMAX,^D13>	;MAX. NO. OF SIMULTANEOUS BATCH JOB STREAM'S
				; INITIATES LOC BATMAX, CHECKED BY BATCON
IFNDEF M.BMIN,<XP M.BMIN,0>	;MIN. NO. OF GUARRANTEED BATCH JOBS
IFNDEF M.EXE,<XP M.EXE,1>	;SYMBOL WHICH DETERMINES TYPE OF FILE
				; CREATED ON "SAVE".  IF OFF, NORMAL (SAV,HGH,
				; LOW,..), IF ON AN EXE FILE IS CREATED
IFNDEF M.JMAX,<XP M.JMAX,M.JOB-M.BMIN>	;MAX. NO. OF SIMULTANEOUS INTERACTIVE JOBS
IFNDEF M.WCH,<XP M.WCH,JW.WMT>	;WATCH BITS USED TO SET INITIAL
				; WATCHING. SINCE LOGIN SETS JBTWCH
				; THIS IS USEFUL ONLY FOR LINES WHICH
				; DON'T NEED LOGIN - INITIA.
				;200000 = TIME OF DAY STARTED TO WAIT
				;100000 = RUN TIME
				;40000 = WAIT TIME
				;20000 = BLOCKS READ
				;10000 = BLOCKS WRITTEN
				;4000 = VERSION NOS.
				;2000 = MTA STATISTICS
IFNDEF M.CMCT,<XP M.CMCT,^D32>	;NO. OF CALLS TO CHKTAL ROUTINE
				; BEFORE DOING 5 M.S. OF OVERHEAD
				; CHECKING CORE TABLES. I.E. ONLY
				; EVERY 32 TIME IS OVERHEAD PERFORMED
				;THIS REDUCES CPU TIME FOR
				; CORE, GETSEG, RUN UUOS
				; SYMBOL CANNOT EXCEED 262,000.
IFNDEF M.EBPS,<XP M.EBPS,^D12500000> ;DEFAULT # EBOX TICKS PER SECOND
					  ; (ACCT METER COUNTS AT 1/2 SYSTEM CLOCK RATE)
					  ; SYSTEM CLOCK RATE IS 25MHZ

IFNDEF M.MBPS,<XP M.MBPS,^D9750000> ;DEFAULT MBOX REFS/SECOND
				     ; THIS NUMBER WAS EXPERIMENTALLY
				     ; DETERMINED AT A CPU CLOCK RATE
				     ; OF 25MHZ SUCH THAT THE CPU TIME
				     ; OF A JRST . MATCHED ELAPSED TIME.
				     ; JRST . WAS ASSUMED TO BE A BEST CASE CONDITION.

				     ; THIS TERM MAKES EBOX/MBOX ME
				     ; PER REAL TIME UNIT DEPENDENT ON
				     ; CACHE HIT RATE, ALTHOUGH INSTRUCTIONS
				     ; PER E/MBOX RUNTIME UNIT SHOULD REMAIN CONSTANT.

IFNDEF M.EMRT,<XP M.EMRT,0>		;DEFAULT IS REGULAR RUNTIME
IFNDEF M.XPI,<XP M.XPI,0>		;AND INCLUDE PI TIME IN USER RUNTIME
IFNDEF M.ITA,<XP M.ITA,0>		;DEFAULT IS TO USE INTERVAL TIMER
IFE	LOKN,<XP EVBN,^D256-RHWEVM-PAGTBL-MEMTBL>	;NUMBER OF HALF WORDS IN THE EXEC MAP
IFN	LOKN,<IFNDEF EVBN,<XP EVBN,^D128>>	; AVAILABLE FOR MAPPING BUFFERS AND IOWDS
IFL EVBN-PAGTBL-MEMTBL,<XP EVBN,PAGTBL+MEMTBL>
IFL ^D512-EVBN-RHWEVM,<PRINTX<EVBN DEFINE TOO LARGE>
	XP	EVBN,^D512-RHWEVM
>
XP EVLN,^D512-RHWEVM-EVBN		;NUMBER OF HALF WORDS IN THE EXEC MAP AVAILABLE
				; FOR LOCKING IN EVM
IFNDEF M.XFFA,<XP M.XFFA,0>	;DO FILE ACCESS PROTACTION CHECKING ON [1,2] AND JACCT

IFN FTNSCHED,<
	ND	M.CLSN,^D16	;DEFAULT NUMBER OF CPU CLASSES FOR SCHEDULER
	ND	M.CLSS,1	;DEFAULT SCHEDULER IS CLASS SYSTEM SCHEDULER.
				; IF THIS MONGEN SYMBOL IS DEFINED
				; TO BE ZERO, THEN THE SCHEDULER WILL
				; RUN IN WMU MODE.

	ND	M.DCLS,0	;DEFAULT SCHEDULER CLASS FOR NEW JOBS.
				; CAN OBTAIN THIS FROM GETTAB OR SCHED UUO
IFG M.DCLS-M.CLSN,<PRINTX VALUE OF M.DCLS EXCEEDS M.CLSN.
			M.DCLS==M.CLSN-1>

>;END IFN FTNSCHED
IFE FTNSCHED,<
	ND	M.CLSN,1
	ND	M.CLSS,0
	ND	M.DCLS,0
	XP	SCHED.,CPOPJ	;NO SCHED. UUO
>;END IFE FTNSCHED

IFN FTKL10,<
IFNDEF TTDMOS,< XP TTDMOS,^D16>	;MAXIMUM OUTPUT STRING
				; DEFINES THE NUMBER OF CHARACTERS THAT CAN
				; BE SENT TO -20F IN A SINGLE BUFFER
>  ;END OF FTKL10

IFNDEF HIGHXC,<XP HIGHXC,^D80>	;HIGHEST EXTENDED CHANNEL
IFG HIGHXC-^D512,<PRINTX HIGHEST EXTENDED CHANNEL IS GREATER THAN 512
	PRINTX	REDUCING IT TO 512
	XP	HIGHXC,^D512>

IFNDEF MAXNBP,<XP MAXNBP,^D64>	;MAXIMUM NUMBER OF SNOOP UUO
				; BREAK POINTS ALLOWED
IFNDEF M.OMSM,<XP M.OMSM,^D60>	;NUMBER OF MINUTES BETWEEN CALLS
				; TO BIGBEN TO TYPEOUT MONITOR NAME,
				; UPTIME, AND DATE/TIME
				;SET TO <-1>_-1 TO NEVER PRINT
IFNDEF	M.DTLS,<XP M.DTLS,^D90>	;CPU TIME LIMIT (SECONDS) TO SET
				; ON A FORCED DETACH (.BYE) COMMAND
IFNDEF	LIM1MS,<XP LIM1MS,4>	;LIMIT OF STOPCD'S IN ANY 1 MINUTE PERIOD
IFNDEF	LIM8MS,<XP LIM8MS,7>	;LIMIT OF STOPCD'S IN ANY 8 MINUTE PERIOD
IFNDEF	LIM1HS,<XP LIM1HS,^D30>	;LIMIT OF STOPCD'S IN ANY 1 HOUR PERIOD
IFN M.EQDQ,<
IFNDEF	M.ENQD,<XP M.ENQD,EQDFEQ##>;DEFAULT ENQ QUOTA
IFNDEF	M.ENQM,<XP M.ENQM,EQMXAQ##>;MAXIMUM NUMBER OF ACTIVE QUEUES
> ;END IFN M.EQDQ
;THESE SYMBOLS DEFINE THE VALUES OF VERSION FROM MONGEN

AXXWHO==2
IFNDEF	A00CVN,<IFNDEF A00CLH,<AXXWHO=0>>
ND	A00CVN,0		;CUSTOMER VERSION NUMBER (36-BITS)
ND	A00MVN,703		;MAJOR VERSION OF MONITOR--UPDATED AT
				;  START OF DEVELOPMENT CYCLE (9-BITS)
ND	A00SVN,0		;SOUP NUMBER--UPDATED AT START
				;  OF EACH SOUP DEVELOPMENT CYCLE (6-BITS)
ND	A00MCO,^D12834   	;HIGHEST MCO IN THIS LOAD (26-BITS)
ND	A00CLH,0		;CUSTOMER LH (%CNVER) (18-BITS)
ND	A00DLN,0		;DEC LOAD NUMBER (6-BITS)
				; SET TO ZERO FOR ANY RELEASE, ELSE
				; 1-7 IF SOUP, 10-77 IF DEVELOPMENT
ND	A00WHO,AXXWHO		;DEC LAST EDITED (3-BITS)

AXXVER==< BYTE (18) A00CLH (12) A00MVN-IFE A00SVN,<IFN A00DLN,<1>> (6) IFE A00SVN,<A00DLN>>

ND	A00VER,AXXVER		;DEFINES %CNVER

AXXDVN== BYTE (3) A00WHO (9) A00MVN (6) A00SVN (18) A00MCO

;DEFINE CNFDAE TO BE THE SIXBIT NAME OF THE MONITOR VERSION
;IN THE LEFT HALF, AND THE BINARY MONITOR VERISON IN THE RIGHT
;HALF. THE SYMBOL BECOMES THE VALUE OF THE %CNDAE GETTAB WHICH
;DAEMON (AND OTHER PROGRAMS) USES TO DETERMINE IF IT IS COMPATIBLE
;WITH THIS MONITOR. IF THE PROGRAM DECIDES IT ISN'T COMPATIBLE
;BY RANGE CHECKING THE RIGHT HALF, IT WILL USE THE LEFT HALF TO
;DETERMINE THE NAME OF THE PROGRAM TO RUN.
DEFINE ..CNFD(VERSION),<XWD SIXBIT \   VERSION\,VERSION>
CNFDAE==..CNFD(\A00MVN)

;DEFINE CTHR TO BE THE CTERM HOST REVISION STRING FOR NRTSER (AND GETTABS).
;THIS STRING IS ALWAYS EIGHT (8-BIT) BYTES IN LENGTH, AND IS OF THE FOLLOWING
;FORM:
;
;	7.03BK42
;
;WHERE THE "7.03" BYTES ARE TAKEN FROM A00MVN, THE "BK" BYTES ARE THE TRANSLATED
;FORM OF A00SVN, AND THE "42" BYTES ARE FROM A00DLN.  THE A00SVN AND A00DLN
;FIELDS WILL BE BLANKS IF THEIR VALUES ARE ZERO.

IFN M.DECN,<
CCLEAR (CTHR)			;CLEAR OUT THE STRING ACCUMULATION
CONCAT (CTHR,<BYTE (8) ">)	;START OFF THE STRING
CONCAT (CTHR,\<A00MVN/100>)	;GET FIRST DIGIT
CONCAT (CTHR,<",".",">)		;ADD THE DOT FILLER
CONCAT (CTHR,\<<A00MVN/10>&7>)	;GET THE SECOND DIGIT
CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE FIELD
CONCAT (CTHR,\<A00MVN&7>)	;GET THE THIRD DIGIT
CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE
IFN A00SVN,<
 IFG A00SVN-^D26,<
  CONCAT (CTHR,\"<<A00SVN/^D26>+"A">)	;ADD IN FIRST OF 2-CHAR MINOR VERSION
  CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE
 >
 CONCAT (CTHR,\"<A00SVN-1-<<A00SVN-1>/^D26>*^D26+"A">)	;ADD MINOR VERSION
 IFLE A00SVN,<CONCAT (CTHR,<"," >)>	;PAD IF SHORT MINOR VERSION
 CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE
> ;END OF IFN A00SVN
IFE A00SVN,<CONCAT (CTHR,< "," ",">)>	;PAD WITH SPACES IF NO MINOR VERSION
IFN A00DLN,<
CONCAT (CTHR,\<A00DLN/10>)	;ADD FIRST DIGIT OF LOAD NUMBER
CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE
CONCAT (CTHR,\<A00DLN&7>)	;ADD LAST DIGIT OF LOAD NUMBER
CONCAT (CTHR,<">)		;CLOSE THE STRING
>
IFE A00DLN,<
CONCAT (CTHR,< "," ">)		;PAD WITH SPACES IF NO LOAD NUMBER
>
				;"CTHR" STRING COMPLETE

;DEFINE THE VALUE OF THE HIGH-AVAILABILITY OPTION FOR CTERM AS WELL

IFG M.CPU-1,<XP CTHOPT,1>	;ON IF MULTI-CPU
IFLE M.CPU-1,<XP CTHOPT,0>	;OFF IF SINGLE

> ;END OF IFN M.DECN


;DEFINE DEFAULT VALUE OF DEBUGF TO STOP ON STOPCD'S DURING FIELD-TEST,
; BUT NOT TO STOP IN RELEASED VERSIONS OF MONITOR.
IFNDEF DEFDEB,<DEFDEB==0>

; DEFINE DEFAULT CPU MASK FOR EDDT.  THIS MASK INDICATES WHICH CPUS
; MAY ENTER EDDT VIA THE UNSOLICITED BREAKPOINT FACILITY.
	ZZ==<1+<ZZZ==-1>>
	REPEAT CPUN,<ZZ==<ZZ!<DF.BP0_-<ZZZ==ZZZ+1>>>>
IFNDEF DEFBPT,<DEFBPT==ZZ>

IFNDEF BPTBIT,<XP BPTBIT,0>	;VALUE OF JS.BPT FOR NEW JOBS
;ADD NEW MONGEN SYMBOLS HERE (SEE ALSO COMDEV FOR MONGEN SYMBOLS)
; CONTEXT SYMBOLS
IFNDEF	M.CTX,<M.CTX==:1>	;LOAD CONTEXT SERVICE BY DEFAULT


; CONSTANTS USED TO MANIPULATE CONTEXT AND JOB NUMBERS IN A JOB/CONTEXT
; HANDLE (JCH).  THE CONTEXT AND JOB MASKS MUST BE ADJACENT BYTES.

CTXMAX==:777			;ABSOLUTE MAXIMUM CONTEXTS PER JOB

CTXMSK==:<CTXMAX>B26		;MASK OF CTX #
JOBMSK==:777B35			;MASK OF JOB #
JCHMSK==:CTXMSK!JOBMSK		;MASK OF JCH #

CTXWID==<^L<-<<CTXMSK>_<^L<CTXMSK>>>-1>> ;WIDTH OF CTX # MASK
JOBWID==<^L<-<<JOBMSK>_<^L<JOBMSK>>>-1>> ;WIDTH OF JOB # MASK
JCHWID==<^L<-<<JCHMSK>_<^L<JCHMSK>>>-1>> ;WIDTH OF JCH # MASK

CTXPOS==<^L<<CTXMSK>&<-<CTXMSK>>>> ;RIGHT MOST BIT IN CTX # MASK
JOBPOS==<^L<<JOBMSK>&<-<JOBMSK>>>> ;RIGHT MOST BIT IN JOB # MASK
JCHPOS==<^L<<JCHMSK>&<-<JCHMSK>>>> ;RIGHT MOST BIT IN JCH # MASK

CTXLSH==:^D36-CTXPOS-1		;BITS TO SHIFT CTX # INTO POSITION
JOBLSH==:^D36-JOBPOS-1		;BITS TO SHIFT JOB # INTO POSITION
JCHLSH==:^D36-JCHPOS-1		;BITS TO SHIFT JCH # INTO POSITION

CTXPTR==:POINT CTXWID,,CTXPOS	;BYTE POINTER TO CTX # (OR WITH ADDR)
JOBPTR==:POINT JOBWID,,JOBPOS	;BYTE POINTER TO JOB # (OR WITH ADDR)
JCHPTR==:POINT JCHWID,,JCHPOS	;BYTE POINTER TO JCH # (OR WITH ADDR)

CTXCBP==:POINT CTXWID,,35	;BYTE POINTER TO A CONTEXT QUOTA
CTXPBP==:POINT <^D36-CTXWID>,,<^D35-CTXWID> ;BYTE POINTER TO PAGE QUOTA

CTXBPW==:^D36/CTXWID		;BYTE PER WORD IN DIRECTORY MAP
CTXMAP==:<CTXMAX/CTXBPW>+1	;SIZE OF A DIRECTORY MAP + TERMINATING NULL
CTXDIR==:POINT CTXWID,,<^D36-<^L<CTXMAX>>-1> ;BYTE POINTER TO A DIRECTORY MAP
IFN M.CTX,<

IFNDEF	M.CTXC,<M.CTXC==:^D4>	;DEFAULT CONTEXT QUOTA
IFNDEF	M.CTXP,<M.CTXP==:^D1000>;DEFAULT SAVED PAGE QUOTA
IFNDEF	M.CTXR,<M.CTXR==:M.JOB/4> ;DEFAULT RESERVED CONTEXT BLOCK COUNT
	EXTERN CTXSER		;FORCE LOADING OF CONTEXT SERVICE

> ;END IFN M.CTX

IFE M.CTX,<			;DEFINE DUMMY GLOBALS IF NOT LOADING CTXSER

CTXTAB==:0			;GETTAB TABLE
CTXMXL==:0			;GETTAB TABLE LENGTH
CTXINI==:CPOPJ			;INITIALIZATION AT SYSINI TIME
CTXBLK==:CPOPJ1			;CONTEXT BLOCK CREATION
CTXPRT==:CPOPJ			;CONTROL-T DISPLAY
CTXLGO==:CPOPJ			;DELETE CONTEXT BLOCKS ON LOGOUT
CTXATO==:CPOPJ			;AUTO-SAVE
CTXSCD==:KCORE1##		;SCHEDULER CALL ON SWAP OUT
CTXPOP==:CPOPJ			;AUTO-RESTORE
CTXRUE==:CPOPJ			;RUN UUO ERROR RECOVERY
CTXUUO==:CPOPJ			;CTX. UUO
CTXMIG==:CPOPJ			;NO IDLE CONTEXTS TO MIGRATE
CTXMGN==:CPOPJ			;NO MORE CONTEXTS TO MIGRATE
CTXWKJ==:WAKEJ##		;LET CLOCK1 EXPIRE SLEEP REQUESTS

	$HIGH

CTXJCJ::SKIPA	T1,J		;SET TO CONTEXT 0 FOR THIS JOB
CTXNUM::TDZA	T1,T1		;CURRENT CTX IS ZERO
CTXJCH::JUMPLE	T1,CPOPJ	;NO SUCH JOB
	CAMG	T1,HIGHJB	;IN RANGE?
	AOS	(P)		;YES, RETURN GOODNESS
	POPJ	P,		;RETURN

CTXPSI::PUSHJ	P,CTXVAL	;VALIDITY CHECK
	  POPJ	P,		;NO SUCH JCH
	MOVE	T1,J		;SET TO CONTEXT 0 FOR THIS JOB
	MOVE	T2,JBTPIA(J)	;GET PIT FOR JOB
	JRST	CPOPJ1		;RETURN

CTXVAL::JUMPLE	J,CPOPJ		;NO SUCH JOB
	CAMG	J,HIGHJB	;IN RANGE?
	AOS	(P)		;YES, RETURN CURRENT
	POPJ	P,		;NO, RETURN NONESUCH

CTXIPC::MOVE	J,T1		;SET TO CONTEXT 0 FOR THIS JOB
	PUSHJ	P,FNDPDB##	;FIND THE PDB
	  POPJ	P,		;NO SUCH JOB
	XMOVEI	W,.PDIPC(W)	;POINT TO IPCF DATA BLOCK
	JRST	CPOPJ1		;RETURN

CTXENQ::MOVE	J,T1		;SET TO CONTEXT 0 FOR THIS JOB
	PUSHJ	P,FNDPDB##	;FIND THE PDB
	  POPJ	P,		;NO SUCH JOB
	MOVE	T2,.PDEQJ(W)	;GET ADDR OF QUEUE CHAIN
	JRST	CPOPJ1		;RETURN

CTXJPK::PUSHJ	P,CTXVAL	;VALIDITY CHECK
	  POPJ	P,		;NO SUCH JCH
	MOVE	T1,J		;SET TO CONTEXT 0 FOR THIS JOB
	MOVE	T2,JBTSWP(J)	;GET DISK ADDRESS
	JRST	CPOPJ1		;RETURN

CTXSGN::PUSHJ	P,CTXJCH	;VALIDITY CHECK
	  POPJ	P,		;NO SUCH JCH
	MOVE	T2,JBTSGN(T1)	;GET JBTSGN
	LDB	T1,[PSG2LH+JBTSG2(T1)] ;GET JBYSG2
	JRST	CPOPJ1		;RETURN

CTXWAK::PUSHJ	P,WAKJOB##	;WAKE JOB UP
	JRST	CPOPJ1		;RETURN

CTXCMD::
PSHCMD::
POPCMD::JSP	T1,ERRMES##	;CAN'T DO THESE IF CONTEXT SERVICE NOT LOADED
	ASCIZ	/Job contexts not supported/

	$ABS

> ;END IFE M.CTX
SUBTTL COMPUTE SPECIAL SYMBOLS
;DEFINE PARAMETERS THAT SPECIFY SIZE OF CORTAB, NUMBER OF BITS PER
;ENTRY, AND BYTE POINTERS FOR CORE ALLOCATION ROUTINES


CTNBPE==1	;NUMBER OF BITS PER ENTRY IN CORTAB
		;MUST EVENLY DIVIDE 36 AND BE 1 OR A POWER OF TWO
CTNMCI==:1	;PUT THIS IN CORTAB TO INDICATE A BLOCK IN USE BY MONITOR
CTNXMI==:3	;PUT THIS IN CORTAB TO INDICATE A BLOCK OF NON-EXISTANT MEMORY


IFN FTLOCK,<IFN LOKN,<
CTNBPE==2	;NEED TWO BITS PER ENTRY TO MINIMIZE FRAGMENTATION IF LOCK UUO
CTNMCI==:2	;INDICATES CORE IN USE BY MONITOR,LOCKED JOB OR NON-EXISTANT
>
>
CTNBPW==:^D36/CTNBPE
		;NUMBER OF BYTES/WORD
CTNBPE==0	;0 BITS PER ENTRY IF KI10 (SINCE TABLE DOESN'T EXIST)
CTNBPW==:0

Z1==0
Z2==CTNBPE

;	XLIST
REPEAT Z2/2,<
Z2==Z2/2
IFN Z2,<Z1==Z1+1>
>
;	LIST

CTNBSA==:Z1	;THE LARGEST POWER OF TWO IN CTNBPE
;PERFORM TRANSLATION FROM HARDWARE TO SOFTWARE DESIGNATION
; FOR ALL DISK SYMBOLS

IFN DSKN,<
	FHDN==RD10N
	FSDN==RH10NS
	RPXN==RH10NP
	RNXN==RN10N
	DPCN==RP10N
	MDFN==RA10N
	RHXN==RH11NP
>
IFE DSKN, <
	FHDN==0
	FSDN==0
	RPXN==0
	RNXN==0
	DPCN==0
	MDFN==0
	RHXN==0
>

;ALLKON IS THE TOTAL # OF KONTROLLERS IN THE SYSTEM.  IF YOU ADD ANOTHER
; KONTROLLER TYPE YOU MUST INCLUDE THE NUMBER OF KONTROLLERS OF THAT TYPE
; HERE
ALLKON==:FHDN+FSDN+RPXN+RNXN+DPCN+MDFN+TM10B+TC10C+DX10N+TM02N


;DEFINE THE PARAMETERS WHICH CONTROL THE TYPE OF SYSTEM

XP FTDISK,-DSKN			;10/40D OR 10/50S
XP FTSWAP,-SYS50N		;10/50S
XP FTLOGIN,-DSKN		;PUT FTLOGIN IN SO LOADER WILL COMPLAIN
				; IF DIFFERENT IN OTHER FILES
SEGN=JOBN+SEGN

IFN M.KL10,<
	;SYMBOLS SPECIAL TO KL10

XP EBCPT,10000		;KL10 EBOX CLOCK DOES THIS MANY COUNTS PER EBOX TICK
XP MBCPT,10000		; MBOX CLOCK DOES THIS MANY COUNTS PER MBOX TICK
>;END IFN M.KL10
SUBTTL ABSOLUTE LOCATIONS IN LOWER MEMORY

	BOOTPA=:20		;PHYSICAL LOCATION OF BOOTSTRAP
	CLKDDT=:21		;JUMP TO EDDT IF DEBUG SET AND THIS NON-ZERO
	BOOTWD=:22		;APR SERIAL NUMBER STORED BY BOOT
				;LOCATIONS 22 & 23 USED BY BOOT FOR RH10 CCW
	CRSDTM=:24		;CRASH DATE,,TIME(SECS)
	CRSWHY=:25		;CRASH NAME (REASON)
	CRSCHK=:26		;CRASH CHECKSUM (24+25)
	CPNDDT=:27		;SET NON-ZERO IF WE HIT A DDT BREAKPOINT.
				;CAUSES ALL OTHER CPU'S TO LOOP IN THE AC'S
				;UNTIL THIS WORD IS CLEARED AGAIN.
	CRSHWD=:30		;NORMALLY THIS WORD WILL BE 0.  IF IT IS ACCIDENTALLY
				; OR PURPOSEFULLY OVERWRITTEN THE MONITOR WILL
				; ATTEMPT TO SAVE THE AC'S AND THE STATE OF
				; ALL DEVICES, THEN HALT.   [A LA 407 RESTART]

	;WORDS 31-35 ARE SPECIAL LOCATIONS FOR THE KS10 SYSTEM
	;SEE S.MAC FOR DEFINITIONS

	CRSSTS=:36		;RH = CONTENTS OF THE STATES WORD AS
				; SET BY THE OPR. RESTORED UPON AUTO-RELOAD
				; AFTER A CRASH.
	SYSSNP=:37		;WHEN DEPOSITED NON-ZERO, PRINTS SNAP SHOT OF SYSTEM
				; ON LPT (SEE MOVIE SUBPROGRAM)
	FORTY=:40		;PLACE WHERE UUOS ARE STORED ON TRAP
	FLTINL=:50		;50-57 RESERVED FOR FAULT INSERTION
	SIXTY=:60		;PLACE WHERE UNIMPLEMENTED INSTRUCTIONS ARE
				; STORED ON TRAP (PDP10 ONLY)
	ARSLOC=:70		;POWER FAIL RESTART LOCATION

	KAFLOC=:71		;KEEP ALIVE FAILURE RESTART LOCATION
	WRSINS=:WRSINS		;WARM RESTART LOCATION
	LIGHTS=:77		;DUMP PERFORMANCE DATA HERE (METER UUO)
				; FOR SAMPLING WITH PROBES
;DATA STARTING AT 140:

	LOC	41
	JSR	LUUOPC
	LOC	ARSLOC
	HALT	.
	LOC	KAFLOC
	HALT	.
IFN M.KL10,<
	LOC	WRSINS
	HALT	.
>

;SET JOBVER TO SYSTEM VERSION

	LOC	136
	A00CVN			;(136) CUSTOMER
	AXXDVN			;(137) DEC


	COMORG=140		;ORIGIN OF COMMON IS 140
	LOC	COMORG		;MAKE LISTING BE SAME AS LOADING SO IT WILL BE EASY
				; TO EXAMINE SYSTEM LOCATIONS WITH CONSOLE SWITCHES
				; WITHOUT NEEDING A STORAGE MAP

	SYSDSP=:400		;FIRST STARTING LOCATION OF MONITOR

;LOWER CORE FROM 140 UP THRU 410 (START LOCATIONS):
ASCIZ /
THIS SOFTWARE IS FURNISHED UNDER LICENSE AND MAY ONLY BE USED
OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

COPYRIGHT (C) 1969,1986 DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
ALL RIGHTS RESERVED.
/
SUBTTL	EXECUTIVE PROCESS TABLE(S)

	DEFINE	EPT(X,N,M,CPUN)<

.E'N'MP==:X
.E'N'OFS==:.E'N'MP-.EPMP
.E'N'2OF==:2*.E'N'OFS

	LOC	.E'N'MP+0	;WHERE EXEC PROCESS TABLE (FORMERLY
				; EXEC PAGE MAP PAGE) IS

IFN M.KL10,<
	BLOCK	40		;LOGOUT AREAS FOR INTERNAL CHANNELS
>;END IFN M.KL10

	LOC	.E'N'MP+40
.E'N'IL::
IFE M.KL10,<
	BLOCK	1	;WHERE LOCAL UUO'S GO
>
IFN M.KL10,<
	IOP		;CAUSE AN IOP STOPCD IF A DEVICE INTERRUPTS TO 40
>
IFDIF <N><P>,<
	JSR	LUUOPC		;LUUO HANDLER
ZZ==10*CPUN
REPEAT 7,<
ZZ==ZZ+1
	INTINS	\ZZ		;NON-VECTORED INTERRUPT LOCATIONS
>
>;END IFDIF

IFN M.KL10,<
	LOC	.E'N'MP+60
;RH2ZRO::
	0			;LOCS USED BY RH20 FOR ZERO-FILL
	0
	0
	0
>;END IFN M.KL10

IFN M.KS10,<
	LOC	.E'N'MP+101
.E'N'VIT::			;POINTERS TO UBA INTERRUPT VECTOR TABLES
	VECTB1
	0
	VECTB3
	0
>;END IFN M.KS10

IFN M.KL10,<
	LOC	.E'N'MP+135	;SCRATCH BUFFER FOR GET DATE/TIME
    .EPDTM==:.-.E'N'MP	;EPT OFFSET OF START OF BUFFER
DT'N'DTM::BLOCK	3		;CAN BE ANYWHERE IN EPT

	LOC	.E'N'MP+140	;START OF DTE0 HARDWARE LOCATIONS
DT'M'EBP::BLOCK	1		;TO 11 BYTE POINTER
DT'M'TBP::BLOCK	1		;TO 10 BYTE POINTER
DT'M'II::BLOCK	1		;DTE0 INTERRUPT INSTRUCTION
DT'M'UNS::BLOCK	1		;UNUSED LOCATION
DT'M'EPW::BLOCK	1		;EXAMINE PROTECTION WORD
DT'M'ERW::BLOCK	1		;EXAMINE RELOCATION WORD
DT'M'DPW::BLOCK	1		;DEPOSIT PROTECTION WORD
DT'M'DRW::BLOCK	1		;DEPOSIT RELOCATION WORD
>;END IFN M.KL10

	LOC	.E'N'MP+200
.E'N'PM::			;EXEC PAGE MAP FOR EXEC VIRTUAL ADDRESSES
				; 400000 AND UP

.EPRPM==:200
;GENERATE 1:1 MAP FOR UPPER EXEC 128K

	XLIST
	REPEAT	^D128,<0>	;ZEROS SO WILL IME IF USED BEFORE SET UP
	LIST


	LOC	.E'N'MP+421	;EXEC TRAPS

.E'N'AOV:	JFCL		;ARITHMETIC TRAP
IFDIF <N><P>,<
	EXP	SEPDLO##	;PUSH DOWN OVERFLOW TRAP
>
	LOC	.E'N'MP+423
	JSR	TRP3PC		;TRAP 3 TRAP
IFN M.KS10,<
.E'N'HSB:	BLOCK	^D18	;HALT STATUS BLOCK AREA
>
IFN M.KL10,<
.E'N'RH1:	BLOCK	4	;HALT STATUS AREA (OBSOLETE?)


	LOC	.E'N'MP+440	;DTE AREA

.E'N'STD:
IFDIF <N><P>,<
	JRST	DEBUG##	;DIAGNOSTIC START
>
	LOC	.E'N'MP+441
.E'N'DDT:	XCT	SYSDDT	;DDT START
.E'N'STL:	XCT	SYSCRH	;LOADER START ADDRESS (BOOTS)
.E'N'STM:	XCT	SYSDSP	;START MONITOR

DT'M'DBG::			;START OF DTE COMMUNICATIONS AREA
DT'M'FLG::	0
DT'M'CLK::	0
DT'M'CI::	0
DT'M'T11::	0
DT'M'F11::	0
DT'M'CMD::	0
DT'M'SEQ::	0
DT'M'OPR::	0
DT'M'CC::	0
DT'M'MTD::	0
DT'M'MTI::
DT'M'DND::	0		;END OF DTE DATA CLEARED AT SYSINI


	LOC	.E'N'MP+507
.E'N'R1E:	BLOCK	1	;LAST WORD OF FIRST HARDWARE RESERVED REGION
.E'N'HTB::BLOCK	1		;HIGH ORDER TIME BASE WORD
.E'N'LTB::BLOCK	1		;LOW ORDER TIME BASE WORD
.E'N'HPA::BLOCK	1		;HIGH ORDER PERFORMANCE COUNTER WORD
.E'N'LPA::BLOCK	1		;LOW ORDER PERFORMANCE COUNTER WORD
.E'N'TII::
	XPCW	TM'M'INT

.E'N'RH2:			;START OF 2ND RESERVED FOR HARDWARE AREA

	LOC	.E'N'MP+577
.E'N'R2E:	BLOCK	1	;LAST LOC OF 2ND RESERVED FOR HARDWARE AREA
>;END IFN M.KL10

	LOC	.E'N'MP+600
.E'N'LM::			;PAGE MAP FOR LOWER 112K OF EXEC SPACE

;GENERATE 1:1 MAP FOR LOWER EXEC 112K

	ZZ==0
IFE <M.CPU-1>,<
	ZZ=ZZ+PM.CSH
>
IFN M.KS10,<
	ZZ==0			;UNCACHE PAGE ZERO ON KS
>
DEFINE	ONE41,<
	EXP	0
>

	ONE41
IFN M.KS10,<
	ZZ==ZZ+PM.CSH
>
	XLIST
	REPEAT	^D111,<ONE41>
	LIST
	LOC	.E'N'MP+540
.E'N'STB::
	EXP	<PM.DCD>B2+PM.WRT+PM.CSH+.E'N'MAP/PAGSIZ
IFN M.KS10,<
.E'N'RMP::			;KS NORMAL CONTEXT MAP POINTER
>
	EXP	<PM.DCD>B2+PM.WRT+PM.CSH+.E'N'MAP/PAGSIZ
IFN M.KS10,<
.E'N'DMP::			;KS DECNET CONTEXT MAP POINTER
>
IFN <M.DECN!FTXMON>,<
	EXP	<PM.DCD>B2+PM.WRT+PM.SWB+PM.CSH+<.E'N'MP1/PAGSIZ>
>
IFE <M.DECN!FTXMON>,<
	EXP	<PM.DCD>B2+PM.WRT+PM.CSH+.E'N'MAP/PAGSIZ
>
	BLOCK	^D31-<.-.E'N'STB>
	EXP	<PM.DCD>B2+PM.WRT+PM.CSH+<.C'N'CDB+PAGSIZ>/PAGSIZ

;GENERATE TABLE OF CONSTANTS USED BY MICROCODE FOR OWGBP
IFN M.KL10,<
	LOC	.E'N'MP+700
.E'N'OWGP:
	EXP	440606360607
	EXP	300610220611
	EXP	140612060613
	EXP	000646441015
	EXP	341016241017
	EXP	141020041055
	EXP	440722350723
	EXP	260724170725
	EXP	100726010762
	EXP	441130331131
	EXP	221132111133
	EXP	001170442235
	EXP	222236002275
	EXP	000000000000
	EXP	464750515253
	EXP	626364656600
	EXP	555657600000
	EXP	707172730000
	EXP	757600000000

	LOC	.E'N'MP+760
.E'N'RCU:			;RESERVED FOR CHANNEL USE
>;END IFN M.KL10
	LOC	.E'N'MP+777

.E'N'MPE::			;LAST LOCATION IN EPT
.E'N'ND==.
E'N'MPA==<.E'N'MP/1000>
	LOC	.E'N'MP+1000
.E'N'MAP::
DEFINE ONE41,<
	EXP	<PM.DCD>B2+PM.WRT+PM.PUB+<IFE <M.CPU-1>,<ZZCSH>>+ZZ
	ZZCSH==PM.CSH
	ZZ==ZZ+1
>
	ZZ==0
IFN M.KS10,<ZZCSH==0>		;ON KS10, DON'T CACHE PAGE 0
IFE M.KS10,<ZZCSH==PM.CSH>	;OTHERWISE, DO
	XLIST
	REPEAT	<HIORG/PAGSIZ>-1,<ONE41>	;TRADITION HASN'T IT

	LIST
DEFINE	ONE41,<
	EXP	<PM.ICD>B2+PM.WRT+PM.PUB+PM.CSH+<ZZ+.UMORG>B17+N
	ZZ==ZZ+1
>
	LOC	.E'N'MAP+FYSORG/1000
	ZZ==0
	XLIST
	REPEAT	^D32,<ONE41>
	LIST
	LOC	.E'N'MAP+777
IFN FTXMON!M.DECN,<		;IF EXTENDED MONITOR OR DECNET ON KS
E'N'M1A==<.E'N'MP/1000+1000>
	LOC	.E'N'MP+2000
.E'N'MP1::
DEFINE ONE41,<
	EXP	<PM.DCD>B2+PM.WRT+<IFE <M.CPU-1>,<ZZCSH>>+ZZ
	ZZCSH==PM.CSH
	ZZ==ZZ+1
>
IFE FTXMON,<ZZ==0>		;DUPLICATE REGULAR MAP ON KS
IFN FTXMON,<ZZ==MS.HGH/PAGSIZ>	;BOOT READ THIS 1:1
IFN M.KS10,<ZZCSH==0>		;ON KS10, DON'T CACHE PAGE 0
IFE M.KS10,<ZZCSH==PM.CSH>	;OTHERWISE, DO
	XLIST
IFE FTXMON,<			;DUPLICATE REGULAR MAP ON KS
	REPEAT	<HIORG/PAGSIZ>-1,<ONE41>	;TRADITION HASN'T IT
>; END IFE FTXMON
IFN FTXMON,<
	REPEAT	^D512,<ONE41>	;MAKE SECTION MAP 1:1
>; END IFN FTXMON
	LIST

IFE FTXMON,<			;DECNET ON KS NEEDS TO MAP FUNNY SPACE ALSO
DEFINE	ONE41,<
	EXP	<PM.ICD>B2+PM.WRT+PM.CSH+<ZZ+.UMORG>B17+N
	ZZ==ZZ+1
>
	LOC	.E'N'MAP+FYSORG/1000+1000
	ZZ==0
	XLIST
	REPEAT	^D32,<ONE41>
	LIST
>; END IFE FTXMON
	LOC	.E'N'MAP+1777
>; END IFN FTXMON!M.DECN
>;END DEFINE EPT
DEFINE	INTINS(X)<
	XPCW	CH'X

IFE FTKL10,<
	JSR	PIERR##
>
IFN FTKL10,<
	IOP
>>

IFN FTKL10,<
XP TMEINT,TM0INT
>

;NOW GENERATE EPT'S

IFN M.KS10,<
	.EPMP==:0
>

IFN M.KL10,<
	.EPMP==:1000
>
IFN XPANDN,<LALL>

	EPT(.EPMP,P,E,0)	;GENERATE TRADITIONAL SYMBOLS

ZZ1==0
ZZ2==.EPMP
NLUPMP==:.EPMP

REPEAT M.CPU,<
	NLUPMP==:NLUPMP+1000
IFN M.KS10,<NLUPMP==:NLUPMP+1000>	;RESERVE PAGE 1 FOR FE
	EPT(ZZ2,\ZZ1,\ZZ1,ZZ1)
	ZZ1==ZZ1+1
	ZZ2==ZZ2+2000+IFN FTXMON,<1000>
	NLUPMP==:NLUPMP+1000+IFN FTXMON,<1000>

>

;REDEFINE ONE41 FOR GENERATION OF THE NULL JOB'S MAP

DEFINE ONE41,<
	EXP	<PM.DCD>B2+PM.WRT+PM.PUB+ZZ
	ZZ==ZZ+1
>
SUBTTL INITIALIZATION DISPATCH TABLE, STARTING AT LOCATION 400
;ROUTINE "ONCE" IS ONCE ONLY CODE. IT CONVERTS THE DATE
;AND SETS UP I/O SERVICE CHAIN,


	LOC	SYSDSP		;ORIGIN START LOCATIONS TO 400

SYSDSP::

	XJRST	[MCSEC0+SYSTRT]	;(400) INITIALIZE SYSTEM VARIABLES IF CPU0
SYSDDT::IFG	DDTN, <		;IF EXEC DDT IS LOADED.....
	XJRST	[MCSEC0+ENTDDT]	;(401) ENTER EXEC DDT
>
IFE	DDTN, <
	JFCL
>
	HALT	.		;(402)
	HALT	.		;(403)
	XJRST	[MCSEC0+STPALL]	;(404) SET CRSHWD TO -1 AND DO A 406
				;  START TO STOP ALL OTHER CPU'S AND
				;  GET TO BOOTS.  MOSTLY FOR DEBUGGING.
	XJRST	[MCSEC0+STPCPU]	;(405) STARTING THE BOOT CPU AT 405 IS THE SAME
				;  AS A 407 START.  ON ALL OTHER CPUS, A 405
				;  START WILL CAUSE THE CPU TO SAVE THE
				;  MACHINE STATE AND JUMP INTO THE AC'S UNTIL
				;  MANUALLY RESTARTED THROUGH 400.
	XJRST	[MCSEC0+STPLDB]	;(406) SET SR.LBH IN .CPSBR AND DO A 407
				;  START TO FORCE BOOTS TO BE LOADED ON
				;  THIS CPU REGARDLESS OF WHO IS THE BOOT
				;  CPU NOW
SYSCRH:	XJRST	[MCSEC0+SYSTOP]	;(407) MONITOR CRASH AND RELOAD LOCATION

;START ABSOLUTE LOCATIONS HER TO BE PUBLISHED FOR USERS( UP TO 417)


ABSTAB::EXP	NUMTAB##	;(410) ABSOLUTE LOCATION OF GETAB TABLE TABLE.
				; USED TO BE LOC 151. NEEDED TO DO GETTAB UUO
				; SIMULATION ON A CRASHED MONITOR.
MBTCOM::EXP	0		;(411) ABSOLUTE LOCATION USED FOR MONBTS COMMUNICATION
				;(417) CUSTOMER WORD
	LOC	420		;SKIP RESERVED SPACE
SUBTTL	(NULL JOB AND) USER PROCESS TABLE(S)

	LOC	NLUPMP

NUPPPM==:NLUPMP+.UMORG
	LOC	NUPPPM
	ZZ==FYSORG/PAGSIZ
	XLIST
	REPEAT	^D32,<ONE41>
	LIST


NUPPMT==:NLUPMP+420

	LOC	NUPPMT
;USER TRAPS
	EXP	0		;PAGE FAIL WORD (USER OR EXEC)
	JFCL	SAROVF##	;ARITHMETIC TRAP
	EXP	SEPDLO##	;PUSH DOWN LIST OVERFLOW TRAP
	JFCL			;TRAP 3 TRAP

EXP	0			;MUUO STORED HERE
EXP	0			;MUUO PC STORED HERE
EXP	0			;PROCESS CONTEXT WORD
EXP	0			;UNUSED
EXP	MUUO			;KERNAL NO TRAP MUUO NEW PC
EXP	KTUUO			;KERNAL TRAP MUUO NEW PC
EXP	SNTUUO			;SUPERVISOR NO TRAP MUUO NEW PC
EXP	STUUO			;SUPERVISOR TRAP MUUO NEW PC
EXP	MUUO			;CONCEALED NO TRAP MUUO NEW PC
EXP	CTUUO			;CONCEALED TRAP MUUO NEW PC
EXP	MUUO			;PUBLIC NO TRAP MUUO NEW PC
EXP	PTUUO			;PUBLIC TRAP MUUO NEW PC
	LOC	NLUPMP+.UPPFW	;GET TO PAGE FAIL WORD

EXP	0			;PAGE FAIL WORD
EXP	0			;PAGE FAIL OLD PC
EXP	SEILM##			;PAGE FAIL NEW PC
EXP	SEILM##			;PAGE FAIL NEW PC
NUPMPL==:.-NLUPMP
;HARDWARE LOCATIONS
;504 - 507 EBOX/MBOX METERS
;510 - 577 RESERVED
NULSTB==NLUPMP+540		;SECTION TABLE ORIGIN
	LOC	NULSTB
	EXP	<PM.DCD>B2+PM.PUB+PM.WRT+NLUPMP/PAGSIZ
	BLOCK	^D31		;RESERVE THE REST

NULASW==NLUPMP+1000		;FIRST LOC AVAIL TO SOFTWARE
LOC	NULASW
SUBTTL	EXECUTIVE UUO DISPATCHERS
$HIGH
KTUUO:
	JRST	@.USMUE		;E FIELD OF THE MUUO IS TRAP HANDLER ADDRESS
				; N.B., USRIOT ISN'T ON

SNTUUO:	HALT	.		;NOT IMPLEMENTED
STUUO:	HALT	.		;NOT IMPLEMENTED
CTUUO:PTUUO:
	EXECAC
	HRLZ	T1,.USMUO
	IOR	T1,.USMUE
	JUMPL	T1,ILLTIN##

	CAILE	T1,UP.MLT
	JRST	ILLTIN##
	JRSTF	@UUTDSP(T1)
UUTDSP:	IC.UOU+SEILM##		;PAGE FAULT
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+SEPDLO##		;PUSH DOWN LIST OVERFLOW
	IC.UOU+ILLTIN##		;TRAP 3
	IC.UOU+SUILM##		;USER ENABLED PAGE FAULT
	IC.UOU+SAROVF##		;USER ENABLED ARITHMETIC OVERFLOW
	IC.UOU+SUPDLO##		;USER ENABLED PDL OVERFLOW
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+PSIAPR		;PSI ENABLED ARITHMETIC OVERFLOW
	$ABS
LUUOPC::0			;JSR HERE ON A LUUO IN EXEC MODE
	EXCH	T1,LUUOPC
	MOVEM	T1,.USMUP
	JRST	UUOERR##
TRP3PC:	0			;JSR HERE ON A TRAP 3 IN EXEC MODE
	HALT	.
SUBTTL	SOME DEFINITIONS FOR KL10'S
IFN M.KL10,<
KLRELC==.
	LOC	420
	IFN	./2*2-.,<0>	;MAKE SURE THEY START ON EVEN LOCATION
FREORG:	BLOCK	ALLKON*4	;ICCW BLOCKS
	BLOCK	13*4
FRE4LN==<.-FREORG>/4		;NUMBER OF 4-WORD BLOCKS

	LOC	KLRELC
>;END IFN M.KL10
SUBTTL	KS10 UBA INTERRUPT VECTOR TABLES

IFN M.KS10,<
;TABLES FOR DISPATCHING 11-STYLE VECTORED INTERRUPTS FROM THE
;KS10'S UNIBUS ADAPTORS. INITIALLY SET TO ZEROS.
;APPROPRIATE LOCATIONS WILL BE SET UP BY THE DEVICE SERVICE ROUTINES.

VECTB1::			;UBA 1 VECTOR TABLE
;REPEAT ^D128,<0>		;THIS IS WHAT'S ASSEMBLED
XLIST
REPEAT ^D128,<0>
LIST
VECTB3::			;UBA 3 VECTOR TABLE
XLIST
REPEAT ^D128,<0>
LIST
>;END IFN M.KS10
SUBTTL	VIRTUAL MEMORY DATA
.EPMPP==:.EPMP/PAGSIZ
MONORG==:MONORG
EVTABL==^D512/^D36+1
EVMPTR::XWD	-EVTABL,EVBTAB
PAGPTR::0
PAGINQ::0			;HEAD OF THE "IN" PAGE QUEUE
PAGINC::0			;COUNT OF THE NUMBER OF PAGES IN THE "IN" QUEUE
PAGSNQ::0			;HEAD OF THE SLOW SWAPPING "IN" PAGE QUEUE
PAGSNC::0			;COUNT OF THE NUMBER OF PAGES IN THE SLOW SWAPPING
				; "IN" QUEUE
PAGIPQ::0			;HEAD OF THE "IN PROGRESS" PAGING QUEUE
PAGIPC::0			;COUNT OF THE NUMBER OF PAGES IN "IP" QUEUE
PAGOUQ::0			;HEAD OF THE "OUT" PAGE QUEUE
PAGOUC::0			;COUNT OF THE NUMBER OF PAGES IN THE "OUT" QUEUE
LOKPTR::0			;HEAD OF LOKCON'S QUEUE
LOKHOL::0			;COUNT OF PAGES IN LOKCON'S QUEUE
LOKTAL::0			;LOKCON'S VERSION OF CORTAL
ALPHA==1			;FRACTIONAL PART OF TIME CONSTANT
EXPON==^D10			;NEGATIVE EXPONENT OF TIME CONSTANT
.GTVM::
SWPCNT::0			;(0)
SCNCNT::-1			;(1)
SPRCNT::0			;(2) COUNT OF SWAPS + PAGE OPERATIONS IN PROGRESS
				;  (SQREQ IS ONLY SWAPS)
SLECNT::0			;(3) TOTAL NUMBER OF SWPLST ENTRIES
VMTOTL::0			;(4) TOTAL AMOUNT OF VM CURRENTLY IN USE
VMCMAX::0			;(5) MAX ALLOWABLE VALUE OF VMTOTL
VMRMAX::1			;(6) OBSOLETE
VMCNST::ALPHA			;(7) CONSTANT USED TO COMPUTE SWAPPING RATE
VMQJOB::0			;(10) OBSOLETE
JBRMAX::RTUPS/^D10		;(11) OBSOLETE
LSFTIM::0			;(12) TIME OF LAST FAULT
SYSVCT::0			;(13) TOTAL NUMBER OF PAGE FAULTS (SYSTEM WIDE)
				;LH=NUMBER OF FAULTS WHEN PAGE NOT IN WS
				;RH=NUMBER WHEN PAGE IS IN WORKING SET, PM.ACC=0
	EXP	SWPLST		;(14) LCTN OF SWAP TABLE #1
	EXP	SW2LST		;(15) LCTN OF SWAP TABLE #2
	EXP	SW3LST		;(16) LCTN OF SWAP TABLE #3
VMCEXP::EXPON			;(17) TIME CONSTANT EXPONENT
VMCDIF::EXPON-ALPHA		;(20)
MAXINT::777777			;(21) MAX INTERVAL FOR FAULT-RATE CALCULATION (ABOUT 8 SEC. BETWEEN FAULTS)
IPCCNT::0			;(22) COUNT OF IPCF PAGES BEING SWAPPED OUT
	EXP	.UPJOB	 	;(23) OFFSET OF JOB NUMBER IN UPMP
	EXP	.UPREL		;(24) OFFSET OF END OF LOW SEG IN UPMP
	EXP	.UPLST		;(25) OFFSET OF POINTER TO SWAPABLE
	EXP	.UPMP		;(26) VIRTUAL ADDRESS OF PAGE MAP
	EXP	.UPLNM		;(27) OFFSET OF POINTER TO LOGICAL NAMES
SINCNT::0			;(30) NUMBER OF SWAP INPUT REQUESTS IN SWPLST
	EXP	.EAHUA		;(31) HIGHEST "UNMAPPED" EXEC ADDRESS
	EXP	.FPPP		;(32) START OF "PER PROCESS" ADDRESS SPACE
	EXP	.LPPP		;(33) END (+1) OF "PER PROCESS" ADDRESS SPACE
	EXP	.JDAT		;(34) "PER PROCESS" ADDRESS OF USER JOBDAT
	EXP	.UPFCC		;(35) OFFSET IN UPMP FOR TMPCOR POINTERS
	EXP	.UPCTA		;(36) OFFSET IN UPMP FOR EXTENDED CHANNEL TABLE POINTER
	EXP	USRJDA		;(37) OFFSET IN UPMP FOR USRJDA
RMCMAX::0			;(40) "REAL" MAXIMUM VALUE OF CORMAX
				;(ADJUSTED FOR FUNNY SPACE)
GTVMXL==:<.-.GTVM-1>B26		;MAXIMUM ENTRY IN GETTAB


EVBMAX::EVBN
EVBTAB::BLOCK	EVTABL
NUPMPP==:NLUPMP/1000
NUPMPA==<NUPMPP>B17
EPMPA==<.EPMP/1000>
.UPMPE==.
SUBTTL	IOWD SPACE ALLOCATION

IFN M.KL10,<
NPAGUC==^D512
IFL <2*M.NKC-^D512>,<NPAGUC==2*M.NKC>
IFNDEF XTR4WD,<IFE FTAUTC,<IFL <M.CHN-2>,<XTR4WD=0>>>
IFNDEF XTR4WD,<XTR4WD==<<NPAGUC+3>/4-<FRE4LN>>>
LTINIT::
IFG FRE4LN,<XWD	FRE4LN,FREORG>
IFG XTR4WD,<XWD	XTR4WD,X4WORG>
	0		;END OF LTINIT XWD'S

XP X4WORG,<<.-1>/4*4+4>
	LOC	X4WORG
IFG XTR4WD,<BLOCK 4*XTR4WD>
IOWNUM==.-FREORG

NOIOWD::EXP	FRE4LN+XTR4WD ;NUMBER OF FREE IOWD BLOCKS

>;END IFN M.KL10

IFN M.TM10,<
DF10ZR::	0	;GUARANTEED ZERO FOR TERMINATING DF10C CCLS
>

XP CHKSHF,CPOPJ
XP UPMPSZ,1
XP BLTINS,0

XP UPMSZW,PAGSIZ*UPMPSZ
FLG256::0
	SUBTTL	COMMON MEMORY FOR KDP (KMC-11/COM-IOP/DUP-11) & DMR11

;NOTE: TO AVOID WASTING SPACE THE VALUE OF "XTR4WD" ON
;  THE LAST PAGE CAN BE ADJUSTED.

;NOTE: KDL PAGES ARE BOTH AS BUFFERS AND COMM REGIONS.  SINCE THEY
;  ARE MAPPED BY THE UBA, IT IS ASSUMED THAT THEY CAN BE TRASHED
;  BY AN ERRANT UNIBUS DEVICE.  FOR THIS REASON, THEY ARE NOT STATICALY
;  INITIALIZED.  INSTEAD, THERE IS CODE IN THE KDP UUO SERVICE
;  TO CLEAR OUT AND INITIALIZE A KDL PAGE.

IFNDEF M.KDUP,<M.KDUP==0>	;MAKE SURE M.KDUP IS DEFINED
IFNDEF M.DMRN,<M.DMRN==0>	;Do the same for DMRs
IFE M.KDUP+M.DMRN,<		;IF NO KMC/DUP-11S THEN
	KDLFST==:0		;  DEFINE THESE TWO SYMBOLS
	KDLLST==:0		;  TO KEEP SYSINI HAPPY
>
IFN M.KDUP+M.DMRN,<		;ONLY ALLOCATE PAGES IF WE HAVE KDP'S or DMRs
	BLOCK	<1000-<.&777>>	;GO TO A PAGE BOUNDARY
	KDLFST=:.		;DEFINE SYMBOL = TO FIRST LOC OF FIRST PAGE
	BLOCK	KDLLEN * M.KDUP	;ALLOCATE SPACE FOR THE I/O BUFFERS
	BLOCK	1000 * M.DMRN * DMRPPL	;Allocate space for DMR11 comm region
	KDLLST=:.-1		;REMEMBER LAST ADDRESS USED.
>				;END M.KDUP

	DEFINE KDLDEF(N,V),<	;;MACRO TO DEFINE KDL'N'PG SYMBOLS
	KDL'N'PG=:KDLFST+V
	  ZZZ==.
	  LOC KDL'N'PG+KDLUSR
	  EXP M.'N'KDP
	  LOC ZZZ
>

ZZ=0
Z=0

REPEAT M.KDUP,<
	KDLDEF(\Z,\ZZ)		;DEFINE THE NEXT SYMBOL
	Z=Z+1			;STEP THE KDL INDEX
	ZZ=ZZ+KDLLEN		;STEP THE PAGE ADDRESS
>;END REPEAT

;Do DMRs too
	DEFINE DMRDEF(N,V),<	;;MACRO TO DEFINE DMR'N'PG SYMBOLS
	DMR'N'PG=:KDLFST+V>

Z=0
REPEAT M.DMRN,<
	DMRDEF(\Z,\ZZ)
	Z=Z+1
	ZZ=ZZ+<DMRPPL*1K>
>;End REPEAT (Note the DMRs start after KDPs)
	SUBTTL	COMMON MEMORY FOR PDP10/PDP11

;NOTE: TO AVOID WASTING SPACE BEFORE THE FIRST DL10 WINDOW
;  THE VALUE OF "XTR4WD" ON THE LAST PAGE CAN BE ADJUSTED.

IFN	PDP11N,<
;;THIS MACRO BUILDS THE DL10 MAP FOR A GIVEN PORT.
DEFINE	BLDM76(CPU,PORT),<

;;COMPUTE THE SIZE OF THE MAP
	DEFINE	WORD(A,B),<A==ZZ	;;DEFINE THE OFFSET
	XP	DLX'A,ZZ	;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+1>
	DEFINE	DATA(A,B),<A==ZZ	;;DEFINE THE OFFSET
	XP	DLX'A,ZZ	;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+1>
	DEFINE	PNTR(A,B),<A==ZZ	;;DEFINE THE OFFSET
	XP	DLX'A,ZZ	;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+1>
	DEFINE	BLK(A,B),<
	XP DLX'A,ZZ			;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+B>

;;SIZE OF TO -10 AND TO -11 QUEUES
	TTBS'PORT==:<<M.D7'PORT'N!7>+1>*2
	TEBS'PORT==:<<M.D7'PORT'N*2>!17>+21

;;EXPAND MAP76 TO SEE HOW BIG IT IS
	ZZ==0
	MAP76(CPU,PORT)
REPEAT ^D18,<ZZ==ZZ!<ZZ_<-1>>>

	ZZ==ZZ!<<DLX8K*777>!77>  ;MUST BE BIG ENOUGH
IFN M.DC75,<ZZ=ZZ!177>		;MIN OF 128 WORDS IF MAY BE DC75

	LOC	<<.-1>!ZZ>+1	;LOC TO BEGINNING OF WINDOW
	ZZ==ZZ_<-<6+<3*DLX8K>>>	;SIZE OF BLOCK
	M7'PORT'END==<<<<ZZ+1>_<DLX8K*3>>*^D64>+.-1>
IFN ZZ&777760 <PRINTX ?DL10 MAPPED AREA IS TOO LARGE.>
	XP	M7'PORT'BAM,ZZ	;DL10 WINDOW MASK
	ZZ=ZZ*4			;SHIFT TO PROPER PLACE
	ZZ=ZZ+<PORT&3>		;MASK OUT OVEERFLOW IN PORT

;;NOW LAY OUT THE MAP FOR REAL
DEFINE	WORD(SYM),<
M7'PORT''SYM::	0
>

DEFINE	DATA(SYM,THING),<
IF2,< IFNDEF THING,<EXTERNAL THING>>
M7'PORT''SYM::	THING
>

DEFINE PNTR(SYM,PLACE),<
IF2,< IFNDEF PLACE,<EXTERNAL PLACE>>
M7'PORT''SYM::	<61B5>+PLACE
>

DEFINE BLK(SYM,SIZE),<
M7'PORT''SYM::	BLOCK	SIZE
>

IFNDEF DLXFST,<DLXFST==:.>		;START OF DL10 UNCACHED SPACE

.DL'CPU'PORT'B::	;;FIRST ADDRESS IN COMMON MEMORY
	MAP76(CPU,PORT)
> ;END DEFINITION OF BLDM76
IFN	XPANDN,<LALL>			;EXPAND LISTING IF WANTED FROM MONGEN
	ZZD78L==0			;LINE NUMBER CONCATENATOR

;THIS MACRO USES THE "MAP78" MACRO TO ACTUALLY BUILD THE
;THE WINDOW.  IT CALLS "MAP78" TO FIRST CALCULATE THE WINDOW
;SIZE AND THEN IT CALLS "MAP78" AGAIN TO ACTUALLY BUILD THE
;THE DAS78 WINDOW.
;
DEFINE	BLD78	(CPU,PORT),<

IFN <M'CPU'PORT'D78>,<			;ONLY BUILD IF THERE IS LINES ON PORT

;THESE MACRO'S ARE USED FOR COMPUTING THE SIZE OF THE MAP
;
DEFINE	Q78BLK(A),<
	ZZD78A==ZZD78A+A>
;
DEFINE Q78WRD(A),<
	ZZD78A==ZZD78A+1>
;
DEFINE	Q78DAT(A,B),<
	ZZD78A==ZZD78A+1>
;
DEFINE	Q78SYM(A,B),<
	;A>
DEFINE	Q78INC(A,B),<
	;A==A+B>
;END OF MACRO'S THAT DETERMINE MAP SIZE

	ZZD78A==0			;START WITH 0

IFNDEF	M78FPO,<M78FPO==:PORT>		;FIRST PORT INUSE BY DAS78.
	M78HPO==:PORT			;FIGURE HIGHEST DAS78 PORT.

;CALL MAP78 TO CALCULATE WINDOW SIZE
;
	MAP78	(CPU,PORT)

	ZZD78A==<ZZD78A-1>		;ADJUST TO LAST USED LOCATION

REPEAT ^D18,<ZZD78A==ZZD78A!<ZZD78A_<-1>>>

	ZZD78A==<ZZD78A!<<M78M8K*777>!77>>	;MAKE BIGGER IF 8K DL10

IFN	<.&ZZD78A>,<
	LOC	<.!ZZD78A>+1
>;END IFN <.&ZZD78A>

	ZZD78A==<ZZD78A_<-<6+<3*M78M8K>>>>	;SIZE OF BLOCK
	M8'PORT'END==<<<<ZZD78A+1>_<M78M8K*3>>*^D64>+.-1>

IFN	<ZZD78A&777760>,<PRINTX ?DAS78 DL10 MAPPED AREA TOO LARGE.>
	M8'PORT'BAM==<ZZD78A*4>		;SHIFT TO CORRECT PLACE FOR BASE ADR MASK
DEFINE	Q78BLK(A),<
	BLOCK	A>

DEFINE	Q78WRD(A),<
	A::!Z>

DEFINE	Q78DAT(A,B),<
	A::!B>

DEFINE	Q78SYM(A,B),<
	A'B::>
DEFINE	Q78INC(A,B),<
	A==A+B>
;CALL MAP78 NOW TO ACTUALLY BUILD THE WINDOW
;
.DL'CPU'PORT'B::
	MAP78	(CPU,PORT)

	M78NUM==:<-<M78HPO-M78FPO+1>>	;MINUS NUMBER OF POSSIBLE PDP11'S


	LOC	<M8'PORT'END>+1

>;END OF IFN M'CPU'PORT'D78
>;END OF DEFINITION OF BLD78
; CALCULATE WINDOW SIZE AND BUILD THE PDP11 WINDOW
;
DEFINE	MAPIT	(P),<
	IFN TP.DL'P,<
		IFE M0'P'D78,<BLDM76(0,P)>
		IFN M0'P'D78,<BLD78(0,P)>
	> ;;END IFN TP.DL'P
> ;END MAPIT


ZZZ=0			;FIRST PORT
	REPEAT	10,<
	IFLE	<ZZZ-3>,<
IFNDEF	DLX08K,<DLX08K==0	;;ASSUME JUMPERED FOR 1K MAXIMAL>
IFN	DLX08K,<DLX08K==1	;;FORCE TO 1 IF NOT ZERO>
DLX8K==DLX08K			;;USED BY BLDM76
M78M8K==DLX08K			;;USED BY BLD78
>
	IFG	<ZZZ-3>,<
IFNDEF	DLX18K,<DLX18K==0	;;ASSUME JUMPERED FOR 1K MAXIMAL>
IFN	DLX18K,<DLX18K==1	;;FORCE TO 1 IF NOT ZERO>
DLX8K==DLX18K			;;USED BY BLDM76
M78M8K==DLX18K			;;USED BY BLD78
>
	MAPIT(\ZZZ)	;GET THE RIGHT MAP OR NOTHING
ZZZ=ZZZ+1
>
SUBTTL	DL10 INTERRUPT HANDLING


;INTERRUPT ROUTINE FOR EACH DL10 BASED DAS78
DEFINE	EACH78(PORTN),<
IFN	M0'PORTN'D78,<

IFLE	PORTN-3,<DLBD78=60
	DLCD78=64>			;FIRST DL10
IFG	PORTN-3,<DLBD78=160
	DLCD78=164>			;SECOND DL10

	$ABS

D80'PORTN'KI:				;DL10 FORCES JSR HERE
	EXP	0,0,IC.UOU,<D80'PORTN'IN>

	$HIGH

DEFINE	D8.CH(A,B),<IF2,<A'B>>
IFNDEF	DLXSCC,<DLXSCC:>
D80'PORTN'KA:
	CONSO	DLCD78,1B<32-<3*<PORTN&3>>> ;IS THIS PDP11 INTERRUPTING?
	JRST	DLX'PORTN'NX		;TRY THE NEXT ONE
	CONSO	DLCD78,1B31_<<PORTN&3>*3> ;PORT PORTN ENABLED?
	JRST	.-2			;NO, IGNORE.
	JRST	D80'PORTN'CM		;ENTER COMMON CODE

D80'PORTN'IN:
	CONO	DLCD78,1B19+1B<32-<3*<PORTN&3>>>+XXICHN	;TURN OFF INTERRUPT
	DMOVEM	0,D8.CH(SVAC,\XXICHN)	;SAVE ACS 0 AND 1
	DMOVE	0,D80'PORTN'KI		;GET INPTERRUPT PC DOUBLE WORD
	DMOVEM	0,D8.CH(CH,\XXICHN)	;STORE SO WE CAN USE CHN SAVE ROUTINES
	DMOVE	0,D8.CH(SVAC,\XXICHN)	;RESTORE ACS 0 AND 1

D80'PORTN'CM:
	CONO	DLCD78,1B19+1B<32-<3*<PORTN&3>>>+XXICHN	;TURN OFF INTERRUPT
	JSR	D8.CH(SAV,\XXICHN)	;SAVE THE ACS AND SET UP P
	SKIPE	J,M78BT+PORTN		;J TO POINT TO WINDOW FOR PORT PORTN
	  PUSHJ	P,D78KII##		;GO TO DAS78 INTERRUPT SERVICE ROUTINE
	POPJ	P,			;DISMISS INTERRUPT


;BASE TABLE FOR DAS78 DL10
;
M80'PORTN'BT:
	PHASE	0
M78CPE::!CONO	DLCD78,XXICHN+<1B31_<<PORTN&3>*3>>	;CLEAR PORT ENABLE FOR PORT PORTN
M78I10::!CONSO	DLCD78,1B32_<<PORTN&3>*3>		;SEE IF PDP11 PORTN SET 10 INT
M78I11::!CONO	DLCD78,1B19+1B20+XXICHN+<1B30_<<PORTN&3>*3>>	;SET PDP11 INTERRUPT ON PORTN
M78SWA::!CONO	DLBD78,M8'PORTN'KII!M8'PORTN'BAM!<PORTN&3>	;LOAD ADDRESS FOR PORT PORTN
M78ENP::!CONO	DLCD78,1B20+XXICHN+<1B31_<<PORTN&3>*3>>	;ENABLE PORT PORTN
M78CPI::!CONSO	DLCD78,7			;SEE IF PIA ASSIGNED
M78SPI::!CONO	DLCD78,XXICHN			;GIVE PI CHN ASSIGNMENT
M78PNO::!PORTN,,.DL0'PORTN'B			;;PORT##,,WINDOW
IFN M.PSI,<
M78PSI::!DATAO	DLCD78,[200001,,0]	;KA STYLE INTERRUPTS
>					; SO PSISER CAN FIND THE PC
IFE M.PSI,<
M78PSI::!JFCL
>
M78SER::!DATAO	DLBD78,[<PORTN&3>_^D<35-5>]  ;PUT PORT NUMBER IN THE "R" REGISTER
M78GWA::!CONI	DLBD78,T1	;GET BASE ADDRESS
	DEPHASE

DLX'PORTN'NX::
	$ABS

>;END IFN M0'PORTN'D78
>;END DEFINE EACH78
;INTERRUPT ROUTINE FOR EACH DL10 BASED ANF10 PDP11
DEFINE	EACH76(N)<
IFN TP.DL'N,<			;IF PORT DEFINED
IFE M0'N'D78,<			;AND NOT A DAS78
IFLE N-3,<DLX=DLC
	DLBX=DLB>		;FIRST DL10
IFG N-3,<DLX=DLC2
	DLBX=DLB2>		;SECOND DL10
	$ABS
D70'N'KI:Z			;DL10 FORCES JSR TO HERE
	Z
	IC.UOU
	D70'N'IN

	$HIGH
DEFINE	D7.CH(A,B),<IF2,<A'B>>
IFNDEF	DLXSCC,<DLXSCC==.>	;DEFINE START OF KA SYTLE DL10 CONSO CHAIN
D70'N'KA:CONSZ	DLX,1B32_<<N&3>*3> ;IS THIS -11 INTERRUPTING
	CONSO	DLX,1B31_<<N&3>*3> ;YES, PORT ENABLED ?
	JRST	DLX'N'NX	;NO, TRY THE NEXT -11
	JRST	D70'N'CM	;JOIN COMMON CODE WITH VECTORED STYLE
D70'N'IN:
	DMOVEM	0,D7.CH(SVAC,\SCNCHN)
	DMOVE	0,D70'N'KI
	DMOVEM	0,D7.CH(CH,\SCNCHN)
	DMOVE	0,D7.CH(SVAC,\SCNCHN)

D70'N'CM:CONO	DLX,1B19+<1B32_<<N&3>*3>>+SCNCHN ;TURN OFF INTERRUPT
	JSR	D7.CH(SAV,\SCNCHN) ;SAVE AC'S AND STUFF
	SKIPE	W,DLXBAT+N	;SET UP BASE ADDRESS
	XCT	DLXINI(W)	;TAKE ACTION FOR THIS INTERRUPT
	POPJ	P,		;DISMISS INTERRUPT

	IFE	TP.DL'N-TP.D76,<	;THIS IS A DC76 PORT
DC76'N'D::JRST	[PUSHJ P,SETJ'N	;SET UP J AS BASE ADDRESS
		 PJRST D76TYP##];CALL TYPEOUT ROUTINE
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76DSC##];MODEM CONTROL
	POPJ	P,		;NO PI CHANNEL TO CHECK ON
	POPJ	P,0		;NO INIT
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76CHP##];CHANGE HARDWARE PARAMETERS
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76LPC##];LINE PARAMETER CONTROL
	JFCL
	JFCL
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76OFL##]

SETJ'N:	EXCH	J,(P)		;SAVE J
	MOVEM	J,1(P)		;SAVE RETURN ADDRESS
	MOVE	J,DLXBAT+N	;POINT TO BASE OF MAP
	MOVE	J,DLXWIN(J)	; ..
	PUSHJ	P,@1(P)		;DO FUNCTION
	  PJRST	IPOPJ		;RETURN
	PJRST	IPOPJ1		;ALLOW CPOPJ1
> ;END OF IFE TP.DL'N-TP.D76
DLX'N'NX:
> ;END IFE M0'N'D78
> ;IFN TP.DL'N
> ;END OF DEFINITION OF EACH76
> ;END IFN PDP11N
; PDP11 BASE TABLE OFFSETS
	  PHASE	0		;START BASE TABLE
DLXWIN::! BLOCK	1		;STANDARD XWD CPU#,DTE#
DLXNMT::! BLOCK	1		;FRONT END NAME
DLXSTA::! BLOCK	1		;DTE KNOW'S WHEN THE -10'S ALIVE
DLXINI::! BLOCK	1		;DO THIS ON INTERRUPT
DLXCAL::! BLOCK	1		;POINTER TO CAL11. UUO TABLE
DLXCEU::! BLOCK	1		;CAL11. USER'S JOB NUMBER
DLXPRG::! BLOCK	1		;DO THIS WHEN PDP11 GOES DOWN
DLXTYP::! BLOCK	1		;TYPE OF PDP11 (FOR CALL11)
DLXTIM::! BLOCK	1		;CONTAINS UPTIME OF TIMEOUT, OR 0
DLXPRE::! BLOCK	1		;
DLXCEV::! BLOCK	1		;CAL11. UUO ENTRY VECTOR
DLXFEK::! BLOCK	1		;ADDRESS OF ASSOCIATED FEK
DLXLEN::!			;LENGTH OF COMMON BASE TABLE AREA
	  DEPHASE

IFN FTKL10,<		;DL10 SPECIFIC BASE TABLE OFFSETS
	  PHASE	DLXLEN
DLXMSK::! BLOCK	1		;MASK OF FRONT END BITS
DLXKAX::! BLOCK	1		;INSTRUCTION FOR NON-KA10 STYLE INTERRUPTS
DLXSWA::! BLOCK	1		;WINDOW ADDRESS
DLXENB::! BLOCK	1		;INSTRUCTION TO ENABLE WINDOW AND INTERRUPTS
DLXCLR::! BLOCK	1		;INSTRUCTION TO CLEAR PORT ENABLE
DLXCNI::! BLOCK	1		;INSTRUCTION TO READ DL10 CONDITIONS
DLXI11::! BLOCK	1		;
DLXDBL::!			;LENGTH OF DL10 BASE TABLE
	  DEPHASE
> ;END IFN FTKL10

IFN FTKL10,<			;DTE SPECIFIC BASE TABLE OFFSETS
	  PHASE	DLXLEN
DLXEVM::! BLOCK	1		;REMEMBER NUMBER OF PAGES OF EVM AND THE EXEC
				; VIRTUAL ADDR FOR RETURNING EVM
DLXOCN::! BLOCK	1		;COUNT OF BYTES IN DIRECT OUT MSG
DLXODA::! BLOCK	2		;BYTES TO BE PUT IN THE DIRECT MSG
DLXICI::! BLOCK	1		;# BYTES EXPECTING IN THE INDIRECT INPUT MSG
DLXIBP::! BLOCK	1		;BYTE PTR TO USER BUFFER PASSED TO DTESER
DLXICN::! BLOCK	1		;COUNT OF BYTES RECEIVED IN INPUT DIRECT MSG
DLXIDA::! BLOCK	2		;BYTES FROM THE INPUT DIRECT MSG
DLXSBL::!			;DTE BASE TABLE LENGTH
	  DEPHASE
> ;END IFN FTKL10

IFN FTKS10,<			;KMC/DUP SPECIFIC BASE TABLE OFFSETS
				;D6RINT USES THE SAME OFFSETS...
	  PHASE	DLXLEN
DLXFLG::! BLOCK	1		;GENERAL PURPOSE FLAGS WORD (SEE D6KINT)
DLXICI::! BLOCK	1		;# BYTES EXPECTING IN THE INDIRECT INPUT MSG
DLXIBP::! BLOCK	1		;BYTE POINTER TO USER BUFFER PASSED TO KDPINT
DLXIMQ::! BLOCK	1		;INPUT MESSAGE QUEUE (0 OR 1 LONG)
DLXKBL::!			;KMC/DUP (AND DMR) BASE TABLE LENGTH
	  DEPHASE
> ;END IFN FTKS10
SUBTTL	BASE TABLE GENERATION -- DL10


DEFINE	BASE11	(CPX,N),<	;;CPX = CPU NUMBER, N = PORT NUMBER
IFN TP.DL'N,<			;;IF A PDP11
IFE M'CPX'N'D78,<		;; BUT NOT A DAS78
DL'CPX'N'BS:
	BLOCK	DLXDBL		;;RESERVE SPACE FOR ONE DL10 BASE TABLE

IFLE N-3,<			;;DL10 #0
	DLX=DLC			;;CONTROL REGISTER
	DLBX=DLB		;;BASE ADDRESS REGISTER
>
IFG N-3,<			;;DL10 #1
	DLX=DLC2		;;CONTROL REGISTER
	DLBX=DLB2		;;BASE ADDRESS REGISTER
>

;; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DL'CPX'N'BS+OFS
	DAT
>

;; DATA COMMON TO ALL DL10 BASE TABLES
X	DLXWIN,<.DL'CPX'N'B>	;;WINDOW ADDRESS
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXMSK,<777777700007!<70_<<N&3>*3>>>
				;;"AND" OUT OTHER PDP11 BITS
X	DLXKAX,<DATAO	DLX,[XWD 400001,0]>
				;;NON-KA10 STYLE INTERRUPTS
X	DLXSWA,<CONO	DLBX,.DL'CPX'N'B+<M7'N'BAM>_2+<N&3>>
				;;WINDOW ADDRESS
X	DLXENB,<CONO	DLX,1B19+1B20+<1B31_<<N&3>*3>>+SCNCHN>
				;;ENABLE WINDOW AND INTERRUPTS.
X	DLXCLR,<CONO	DLX,1B19+<70_<<N&3>*3>>+SCNCHN>
				;;CLEAR PORT ENABLE
X	DLXCNI,<CONI	DLX,T1>	;;READ DL10 CONDITIONS
X	DLXI11,<CONO	DLX,1B19+1B20+<1B30_<<N&3>*3>>+SCNCHN>
				;;INTERRUPT THE PDP11

IFN M'CPX'N'D85,<		;;ANF10 DC75/DN87 FRONT ENDS
X	DLXSTA,<SETOM DLXTA(P1)>;;MARK -10 AS BEING ALIVE
X	DLXTYP,.C1D75		;;TYPE OF PDP11
X	DLXPRE,<PUSHJ P,D85PRE##>;;
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<D8'N'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

IFN    M'CPX'N'D60,<		;;DN60 FRONT ENDS
X	DLXSTA,<SETOM DLXTA(P1)>;;MARK -10 AS BEING ALIVE
X	DLXTYP,.C1D60		;;TYPE OF PDP11
X	DLXPRE,<JFCL>		;;
X	DLXCEV,<JRST D60CEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<D8'N'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DL'CPX'N'BS+DLXDBL
> ;END IFE M'CPX'N'D78
> ;END IFN TP.DL'N
> ;END BASE11 MACRO
SUBTTL	BASE TABLE GENERATION -- DTE


DEFINE	BASDTE	(CPX,DTX),<
DS'CPX'DTX'BS:
	BLOCK	DLXSBL		;;RESERVE SPACE FOR ONE DTE BASE TABLE

; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DS'CPX'DTX'BS+OFS
	DAT
>

;; DATA COMMON TO ALL DTE BASE TABLES
X	DLXWIN,<XWD CPX,DTX>	;;CPU#,,DTE#
X	DLXSTA,<JFCL>		;;DTE KNOWS WHEN THE -10'S ALIVE
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXPRE,<JFCL>		;;


IFE <M'CPX'DTX'DTE-DT.RSX>,<	;;RSX20F FRONT ENDS
X	DLXNMT,<SIXBIT /RSX20F/>;;NAME
X	DLXTYP,.C1CFE		;;FRONT END TYPE
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M'CPX'DTX'DTE-DT.ANF>,<	;;ANF10 FRONT ENDS
X	DLXNMT,<SIXBIT /ANF10/>	;;NAME
X	DLXTYP,.C1D8S		;;FRONT END TYPE
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<S'CPX'DTX'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M'CPX'DTX'DTE-DT.IBM>,<	;;DN60 FRONT ENDS
X	DLXNMT,<SIXBIT /DN60/>	;;NAME
X	DLXTYP,.C1D60		;;FRONT END TYPE
X	DLXCEV,<JRST D6SCEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<S'CPX'DTX'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M'CPX'DTX'DTE-DT.DNT>,<	;;DECNET FRONT ENDS
X	DLXNMT,<SIXBIT /DECNET/>;;NAME
X	DLXTYP,.C1MCB		;;FRONT END TYPE
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DS'CPX'DTX'BS+DLXSBL
> ;END BASDTE MACRO
SUBTTL	BASE TABLE GENERATION -- KMC/DUP


DEFINE BASKDP	(KMX,KLX),<	;;KMX = KMC #, KLX = DUP # (KMX == 0)
DK'KMX'KLX'BS:
	BLOCK	DLXKBL		;;RESERVE SPACE FOR ONE KMC/DUP BASE TABLE

; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DK'KMX'KLX'BS+OFS
	DAT
>
;; DATA COMMON TO ALL KMC/DUP BASE TABLES
X	DLXWIN,<KDL'KLX'PG>	;;KDL BASE TABLE
X	DLXSTA,<JFCL>		;;KDP KNOWS WHEN THE -10 IS ALIVE
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXPRE,<JFCL>		;;


IFE <M.'KLX'KDP-KD.ANF>,<	;;ANF10 FRONT ENDS
X	DLXNMT,<SIXBIT /ANF10/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,DK'KLX'FEK	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'KLX'KDP-KD.DNT>,<	;;DECNET FRONT ENDS
X	DLXNMT,<SIXBIT /DECNET/>;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'KLX'KDP-KD.USR>,<	;;USER FRONT ENDS
X	DLXNMT,<SIXBIT /USER/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'KLX'KDP-KD.IBM>,<	;;DN60 FRONT ENDS
X	DLXNMT,<SIXBIT /DN60/>	;;NAME
X	DLXTYP,.C1D60		;;TYPE
X	DLXCEV,<JRST D6KCEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DK'KMX'KLX'BS+DLXKBL
> ;END BASKDP MACRO
SUBTTL	BASE TABLE GENERATION -- DMR


DEFINE BASDMR	(DRX),<	;;DRX = DMR #
DMR'DRX'BS:
	BLOCK	DLXKBL		;;RESERVE SPACE FOR ONE DMR BASE TABLE

; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DMR'DRX'BS+OFS
	DAT
>
;; DATA COMMON TO ALL DMR BASE TABLES
X	DLXWIN,<DMR'DRX>	;;DMR BASE TABLE
X	DLXSTA,<JFCL>		;;DMR KNOWS WHEN THE -10 IS ALIVE
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXPRE,<JFCL>		;;


IFE <M.'DRX'DMR-RD.ANF>,<	;;ANF10 FRONT ENDS
X	DLXNMT,<SIXBIT /ANF10/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,DR'DRX'FEK	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'DRX'DMR-RD.DNT>,<	;;DECNET FRONT ENDS
X	DLXNMT,<SIXBIT /DECNET/>;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'DRX'DMR-RD.USR>,<	;;USER FRONT ENDS
X	DLXNMT,<SIXBIT /USER/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'DRX'DMR-RD.IBM>,<	;;DN60 FRONT ENDS
X	DLXNMT,<SIXBIT /DN60/>	;;NAME
X	DLXTYP,.C1D60		;;TYPE
X	DLXCEV,<JRST D6RCEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DMR'DRX'BS+DLXKBL
> ;END BASDMR MACRO
IFN PDP11N,<	;IF DL10 BASED PDP11S

	$HIGH
IFN M.DAS78,<XXIINT:>		;DAS78 XXI INTERRUPTS HERE
DLXINT:	JRST	DLXSCC		;START OF KA STYLE INTERRUPT CHAIN
	JRST	.-1		;MAKE SYSINI HAPPY

IFN M.DAS78,<
DEFINE	B78BT	(CPU,PORT),<
	IFNDEF	M8'CPU'PORT'BT,<EXP	Z>
	IFDEF	M8'CPU'PORT'BT,<EXP	M8'CPU'PORT'BT>>
	$HIGH
M78BT::
ZZZ=0
	REPEAT	10,<
	B78BT	(0,\ZZZ)
	ZZZ=ZZZ+1>
>;END IFN M.DAS78
	$ABS


ZZZ==0				;GENEATE INTERRUPT ROUTINE FOR EACH
	REPEAT	10,<		; DL10 BASED DAS78
	EACH78	(\ZZZ)
	ZZZ==ZZZ+1
>
ZZZ=0				;GENERATE INTERRUPT ROUTINE FOR EACH
	REPEAT	10,<		; DL10 BASED ANF10 PDP11
	EACH76(\ZZZ)
	ZZZ==ZZZ+1
>
	$HIGH
	JRST	DLXINT+1	;CONSO CHAIN FALLS OUT HERE

	$ABS
;
; GENERATE THE BASE TABLES.  ONE FOR EACH DL10 PDP11 AND ONE
;  FOR EACH PDP11 ON A DTE20 (EXCEPT FOR THE CONSOLE AND
;  DN87S'S)

;FIRST THE DL-10 BASED FRONT ENDS
ZZZ==0				;START WITH #0
    REPEAT 8,<
	BASE11(0,\ZZZ)		;BUILD THE NEXT BASE TABLE
	ZZZ==ZZZ+1>		;STEP TO THE NEXT DL-10 PORT
> ;END OF IFN PDP11N

;NOW THE DTE-20 BASED FRONT ENDS
IFN FTKL10,<
ZZ==0				;CPU #
    REPEAT M.CPU,<		;FOR ALL CPU'S
	ZZZ==0			;DTE NUMBER
	REPEAT 4,<		;FOR ALL DTE'S ON THIS CPU
	    BASDTE(\ZZ,\ZZZ)	;BUILD A BASE TABLE
	ZZZ==ZZZ+1>		;STEP TO THE NEXT DTE
    ZZ==ZZ+1>			;STEP TO THE NEXT CPU
> ;END FTKL10
	$ABS

;BASE TABLES FOR KDP'S (IF USING IBM COMM)
IFN FTKS10,<
    ZZ==0			;START OUT ON LINE ZERO
    REPEAT M.KDUP,<		;FOR ALL LINES
	BASKDP(0,\ZZ)		;BUILD A BASE TABLE
	ZZ==ZZ+1>		; AND STEP TO THE NEXT
    ZZ==0			;START OUT ON LINE ZERO
    REPEAT M.DMRN,<		;FOR THE DMRS TOO
	BASDMR(\ZZ)		;BUILD A BASE TABLE
	ZZ=ZZ+1>		;AND STEP TO THE NEXT
>; END FTKS10
IFN PDP11N,<
	$HIGH
; BUILD THE BASE TABLES FOR ANF10 AND DAS78 FRONT ENDS

DEFINE	B78BAT	(CPU,PORT),<
IFE	TP.DL'PORT,<EXP	0>
IFN	TP.DL'PORT,<
	IFE	M'CPU'PORT'D78,<EXP	0>
	IFN	M'CPU'PORT'D78,<XWD	M8'PORT'DDB,.DL'CPU'PORT'B>
> ;;END IFN TP.DL'PORT
> ;END B78BAT

DEFINE	BLXBAT	(CPU,PORT),<
IFE	TP.DL'PORT,<EXP	0>
IFN	TP.DL'PORT,<
	IFE	M'CPU'PORT'D78,<EXP	DL'CPU'PORT'BS>
	IFN	M'CPU'PORT'D78,<EXP	0>
> ;;END IFN TP.DL'PORT
> ;END BLXBAT

DLXBAT::			;START OF THE ANF10 MAPPING TABLE
ZZZ==0				;PORT COUNTER
    REPEAT 8,<			;FOR ALL POSSIBLE PORTS
	BLXBAT	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT


IFN M.DAS78,<
M78BAT::			;START OF THE DAS78 MAPPING TABLE
ZZZ==0				;PORT COUNTER
	REPEAT 8,<		;FOR ALL POSSIBLE PORTS
	B78BAT	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT


	$ABS
; MACRO TO BUILD A TABLE CONTAINING DDB ADDRESSES FOR EACH DAS78
DEFINE	B78DDB	(CPU,PORT),<
IFDEF	M8'PORT'KII,<M8'PORT'DDB::BLOCK	M'CPU'PORT'D78>
> ;END B78DDB
M78DDB::
ZZZ==0
	REPEAT	8,<		;FOR ALL POSSIBLE PORTS
	B78DDB	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT

	$HIGH
; MACRO TO BUILD A TABLE WHICH CONTAINS THE LAST USED LOCATION IN
; THE DAS78 WINDOW FOR EACH PORT.
DEFINE	B78END	(CPU,PORT),<
	IFNDEF	M'CPU'PORT'END,<EXP	0>
	IFDEF	M'CPU'PORT'END,<EXP	M'CPU'PORT'END>
> ;END B78END

M78END::
ZZZ==0
	REPEAT	8,<
	B78END	(0,\ZZZ)
	ZZZ==ZZZ+1>

; MACRO TO BUILD A TABLE WHICH CONTAINS THE NUMBER OF LINES
; ON EACH DAS78
DEFINE	B78LIN	(CPU,PORT),<EXP	M'CPU'PORT'D78>

M78LIN::
ZZZ==0
	REPEAT	8,<		;FOR ALL POSSIBLE PORTS
	B78LIN	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT

	$ABS
D78NAM::BLOCK	10		;TABLE OF NAMES FILLED IN BY THE PDP11
				; THROUGH A POINTER IN THE DAS78 WINDOW
> ;END IFN M.DAS78
> ;END OF IFN PDP11N

	$HIGH


;HELPER MACRO FOR SETTING UP THE DTE -- BASE TABLE CORRISPONDENCE MAP
DEFINE	BLXBAT	(CPX,DTX),<
	IFE	M'CPX'DTX'DTE,<EXP	0>
	IFN	M'CPX'DTX'DTE,<EXP	DS'CPX'DTX'BS>
>

DTEBAS::			;START OF THE DTE TO BASE TABLE MAPPING
IFN FTKL10,<
ZZ==0				;CPU COUNTER
    REPEAT M.CPU,<		;FOR ALL CPU'S
	ZZZ==0			;ZERO THE DTE COUNTER
	REPEAT 4,<		;FOR ALL DTE-20S
	    BLXBAT(\ZZ,\ZZZ)	;MAKE THE MAP ENTRY
	    ZZZ==ZZZ+1>		; STEP TO THE NEXT DTE
	ZZ==ZZ+1>		; STEP TO THE NEXT CPU
>


DEFINE BLXBAT(KMX,KLX),<EXP DK'KMX'KLX'BS>	;BASE TABLE ADDRESS

KDPBAS::			;START OF THE KDP BASE TABLES
IFN M.DN60&M.DN6K,<		;IF WE HAVE IBM
    ZZ==0			;START AT THE FIRST LINE
    REPEAT M.KDUP,<		;FOR ALL LINES
	BLXBAT(0,\ZZ)		;EXPAND A POINTER TO THEM
	ZZ==ZZ+1>		;STEP TO THE NEXT
>; END IFN M.DN60&M.DN6K

DEFINE BLXBAT(DRX),<EXP DMR'DRX'BS>	;BASE TABLE ADDRESS

DMRBAS::			;START OF THE DMR BASE TABLES
IFN M.DN60&M.DN6R,<		;IF WE HAVE IBM
    ZZ==0			;START AT THE FIRST LINE
    REPEAT M.DMR,<		;FOR ALL LINES
	BLXBAT(\ZZ)		;EXPAND A POINTER TO THEM
	ZZ==ZZ+1>		;STEP TO THE NEXT
>; END M.DN60&M.DN6R


	$ABS
IFNDEF DLXFST,<DLXFST==:.>		;START OF DL10 UNCACHED SPACE
DLXLST::	;END OF UN-CACHED AREA
IFN FTMP&M.KL10,<
OUCHTB::IFIW	MONORG+0*PAGSIZ(T1)	;IFIW'S
	IFIW	MONORG+1*PAGSIZ(T1)
	IFIW	MONORG+2*PAGSIZ(T1)
	IFIW	MONORG+3*PAGSIZ(T1)
	IFIW	MONORG+4*PAGSIZ(T1)
	IFIW	MONORG+5*PAGSIZ(T1)
	IFIW	MONORG+6*PAGSIZ(T1)
	IFIW	MONORG+7*PAGSIZ(T1)
>

	LIT		;FORCE ANY INITIALIZATION LITERALS INTO LOW SEGMENT
SUBTTL	BACKGROUND PERFORMANCE ANALYSIS SELECTION TABLE

IFN	M.KL10&FTRSP,<

	$HIGH		;THE TABLE IS "PURE"

;BPATAB  --  TABLE OF BACKGROUND PERFORMANCE ANALYSIS CONDITIONS
;
;THIS TABLE CONTAINS THE ORDERED LIST OF "ASPECTS" OF THE SYSTEM
;TO WATCH VIA THE PERFORMANCE ANALYSIS METER OF THE KL-10 CPU.
;
;EACH ITEM IN THE BPATAB TABLE HAS A CORRESPONDING 4-WORD BLOCK IN
;THE CDB VARIABLES AREA (SUBTABLE .CPBPV). THE FIRST TWO WORDS ARE
;THE RDTIME TOTAL FOR WHICH THE CONDITION(S) WAS(WERE) WATCHED, AND
;THE SECOND TWO WORDS ARE THE PERFORMANCE METER COUNT FOR THE ENABLED
;CONDITION(S) - EITHER AN INTEGER COUNT IF IN EVENT MODE OR ELAPSED
;TIME IF IN DURATION MODE. THE ORDER OF THE TABLE IS IMPORTANT SINCE
;THE NUMBERS ARE GETTAB'ED OUT OF THE .CPBPV SUBTABLE.
;
;ALTHOUGH THIS TABLE REALLY BELONGS IN KLSER IT MUST APPEAR IN COMMON
;BEFORE THE CDB DEFINITIONS AS THE LENGTH OF THE TABLE IS NEEDED TO
;DEFINE THE CDB VARIABLES SUBTABLE.

BPATAB::PE.CP0!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 0
	PE.CP1!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 1
	PE.CP2!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 2
	PE.CP3!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 3
	PE.CP4!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 4
	PE.CP5!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 5
	PE.CP6!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 6
	PE.CP7!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 7
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP0!PE.PCI!PE.CLR	;PI 0
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP1!PE.PCI!PE.CLR	;PI 1
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP2!PE.PCI!PE.CLR	;PI 2
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP3!PE.PCI!PE.CLR	;PI 3
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP4!PE.PCI!PE.CLR	;PI 4
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP5!PE.PCI!PE.CLR	;PI 5
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP6!PE.PCI!PE.CLR	;PI 6
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP7!PE.PCI!PE.CLR	;PI 7

	BPATLN==:.-BPATAB

	$ABS		;BACK TO "IMPURE"
> ;END OF IFN M.KL10&FTRSP
SUBTTL CPU DATA BLOCK(S):

REPEAT 0,<

EACH CPU HAS ITS OWN DATA BLOCK, KNOWN AS A CDB.
THE REST OF THE MONITOR ONLY REFERENCES THE CDB FOR THE MASTER CPU.
IN THESE CASES IT WILL USUALLY USE THE OLD 6 CHAR NAME.
MANY LOCATION IN THE CDB PERTAIN ONLY TO THE MASTER CPU. HOWEVER,
FOR GENERALITY AND FUTURE EXPANSION TO A MASTER/MASTER SYSTEM, INSTEAD
OF MASTER/SLAVE, THEY ARE INCLUDED IN CDB(WITH OLD NAMES
AND NO P4).  A FEW LOCATIONS ARE REALLY SYSTEM PARAMETERS(EG CORTAL),
RATHER THAN CPU PARAMETERS.  HOWEVER, THEY WERE IN THE MIDDLE OF A
GETTAB(NSWTBL) AND SO COULD NOT BE SEPARATED OUT WITHOUT INVALIDATING
SOME PROGRAMS.

ALL .CP??? SYMBOLS ARE DEFINED RELATIVE TO THE (MAPPED) CDB,
.CN??? SYMBOLS ARE ABSOLUTE LOCATIONS.
NOTE THAT .CP??? SYMBOLS ARE (AS OF 701) NOT REFERENCED WITH
P4 AS AN INDEX REGISTER

ACTUALLY USED.  THIS MINIMIZES THE NO. OF SYMBOLS AND IS A USEFUL
DOCUMENTATION TOOL.  IN OTHER WORDS A LOCATION WILL ONLY HAVE AN OLD
SYMBOL, OR A NEW .CP??? SYMBOLS, OR .CP??? AND .C0??? AS NEEDED.
FOR DEBUGGING WITH DDT, THE ABSOLUTE SYMBOLS FOR CPU0 AND CPU1 ARE
ALWAYS GENERATED AT LEAST AS LOCAL SYMBOLS.
>

REPEAT 0,<

PRINCIPLE:	WHEN ADDING CONSTANTS OR VARIABLES TO COMMON,
GREAT CARE MUST BE EXERCISED IN DECIDING WHETHER TO PUT IT
IN THE CDB OR IN A SYSTEM DEPENDENT TABLE(.SYTBL).
IF THE CONTENTS COULD EVER BECOME CPU DEPENDENT IN THE FUTURE, BE
SURE TO PUT IT IN THE CDB INSTEAD OF .SYTBL.  IF A MISTAKE IS MADE,
THE LOCATION WILL HAVE TO APPEAR IN THE CDBS AS WELL AS
.SYTBL IN ORDER TO INSURE COMPATIBLITY.

;DEFINE CONSTANTS AREA IN CDB
;EACH 'C' MACRO GENERATES A CONSTANT FOR CPU0
;AND A CONSTANT FOR CPU1.
;THE CALL IF OF FORM:
;	C <XXX,CP0,CP1,CONST0,CONST1>
;WHERE:	XXX IS THREE LETTER SUFFICE FOR LOC.SYMBOL
;	CP0 IS EITHER NULL (IE ,,) OR "CPO"
;	CP1 IS EITHER NULL (IE ,,) OR "CP1"
;	CONST0 IS THE CONSTANT VALUE FOR CDB 0
;	CONST1 IS THE CONSTANT VALUE FOR CDB 1
>
;DEFINE C MACRO TO GENERATE CONSTANTS IN CPU DATA BLOCK
;ALWAYS DEFINE .C'N'XX SYMBOLS AS EITHER INTERN OR LOCAL,
;LOCAL IF USED ONLY FOR DEBUGGING WITH DDT.

	DEFINE C(NAM,N,YESNO,VALUE)<
IFDIF <YESNO><Y>,<.C'N'NAM:>
IFIDN <YESNO><Y>,<.C'N'NAM::>
.CP'NAM=:.-.C'N'CDB+.EPCDB
VALUE
>


;DEFINE V MACRO TO GENERATE VARIABLES FOR END OF CDB
;THESE VARIABLES ARE CLEARED AT SYSTEM STARTUP AND 403 RESTART

	DEFINE V(NAM,N,YESNO,TRAD,LENGTH)<
   IFNB <NAM>,<.CP'NAM=:.-.C'N'CDB+.EPCDB
   IFDIF <YESNO><Y>,<.C'N'NAM:>
   IFIDN <YESNO><Y>,<.C'N'NAM::>>
   IFNB <TRAD>,<IFNDEF TRAD,<TRAD::>>
   IFB <LENGTH>,<LOC .+1>
   IFNB <LENGTH>,<LOC .+LENGTH>
>

;DEFINE MACRO TO DETERMINE WHICH KIND OF CPU
	DEFINE KILS<
  IFN M.KL10,<KL>
  IFN M.KS10,<KS>
>

;DEFINE XPC MACRO TO DEFINE A CONSTANT IFF THIS IS THE CPU0 CDB
	DEFINE XPC(A,B,N),<
   IFE N,<XP A,B>
>
;DEFINE ENTIRE CDB DATA AREA AS ONE MACRO (CDB) WHICH CALLS
;C MACRO FOR EACH CONSTANT AND V MACRO FOR EACH VARIABLE

;NOTE: ; MUST APPEAR IMMEDIATELY AFTER ) IN MACRO CALL, ELSE NO COMMENT.

DEFINE	CDB (N)	<

;CONSTANTS IN GETTAB UUO.(NOT CLEARED AT STARTUP OR 143 RESTART)

DEFINE NXTCPU(L)<
IFG <M.CPU-N-1>,<XWD .C'L'CDB,0>
IFE <M.CPU-N-1>,<0>>
C	(CDB,N,Y,<NXTCPU(\<N+1>)>);	;(0) LH=ADR OF NEXT CDB, RH=0
C	(ASN,N,Y,M.C'N'SN);		;(1) APR SERIAL NO.
C	(OK,N,Y,1);			;(2) THIS CPU RUNNING OK.
					;IF GREATER THAN 0, THIS CPU HAS STOPPED
					;RUNNING CORRECTLY.  CONTENTS ARE NO. OF
					;JIFFIES CPU HAS BEEN STOPPED.
C	(EPT,N,Y,.E'N'MP);		;(3)CONTAINS TRAP OFFSET
					; NEEDED FOR TWO CPUS INTERRUPT LOCATIONS
					; DEFAULT VALUES FOR .C0TOS==0,.C1TOS==100.
					; MONGEN ALLOWS CHANGE.

DEFINE CPUNAM<
SIXBIT	/CPU'N/>

C	(LOG,N,Y,<CPUNAM>);		;(4) LOGICAL CPU NAME (CPUN)
DEFINE KL<
	SIXBIT	/CPL'N/>
DEFINE KS<
	SIXBIT	/CPS'N/>
C	(PHY,N,Y,<KILS>);		;(5) PHYSICAL CPU NAME (CPXN)
IFN M.KL10,<CPTYP==CT.KL>
IFN M.KS10,<CPTYP==CT.KS>
C	(TYP,N,Y,CPTYP);	;(6) TYPE OF PROCESSOR RH DEC, LH CUSTOMERS
.XX==<M.CBAT-1>B8+.CPBAT-.CPVBG	;DEFINE BITS 0-8 = MAX. REL. ENTRY
				; RH=REL ADR IN VAR CDB GETTAB
C	(MPT,N,,<.XX>)
				;(7) POINTER TO BAD ADR SUB-TABLE.
				; BITS 0-8 LENGTH OF SUB-TABLE
				; RH=REL. ADR. OF SUB-TABLE (IN CDB VARIABLE AREA)
				; (SEE .CPBAT)

C	(RTC,N,,C'N'RTC##);	;(10) REAL TIME CLOCK (DK10) DDB

C	(RTD,N,,C'N'RTD##);	;(11) DK10 DDB IF HI PREC TIME ACCT.
				;   0 IF LOW PREC. (APR CLOCK)

.XX==<.CPPRL-1>B8+.CPLPA-.CPVBG	;DEFINE BITS 0-8 = MAX. REL. ENTRY
				; RH = REL ADR IN VAR CDB GETTAB
C	(PAR,N,,<.XX>)
				;(12) REL PTR AND LENGTH TO PARITY
				; SUB-TABLE IN VARIABLE GETTAB. 0 IF FEATURE
				; NOT PRESENT

IFE FTRSP,<XP .CPAOR,.CPVBG>	;NO SUB-TABLE IF NO RESPONSE STUFF
IFE FTRSP,<XP .CPRSL,1>		;MAX IS 0
.XX==<.CPRSL-1>B8+.CPAOR-.CPVBG	;DEFINE BITS 0-8 = MAX REL. ENTRY,
				; RH = REL ADR IN VAR. CDB. GETTAB
C	(RSP,N,,<.XX>)
				;(13) REL PTR AND LENGTH TO RESPONSE
				; SUB-TABLE IN VARIABLE GETTAB.
				; 0 IF FEATURE NOT PRESENT
C	(DKX,N,,M.RT'N);	;(14) NUMBER OF DK10'S ON THIS CPU

IFN M.KL10,<.XX==M.EBPS>
IFN M.KS10,<.XX==0>

C	(EBS,N,,<.XX>);		;(15)EBOX TICKS PER SECOND

IFN M.KL10,<.XX==M.MBPS>
IFN M.KS10,<.XX==0>

C	(MBS,N,,<.XX>);		;(16)MBOX TICKS PER SECOND
.XX==<.CPNML-1>B8+.CPLNA-.CPVBG	;DEFINE BITS 0-8 LENGTH.
C	(NMT,N,,<.XX>);		;(17)POINTER TO NXM SUBTABLE
.XX==<.CPCSL-1>B8+.CPAPD-.CPVBG	;LENGTH OF CPU STATUS BLOCK
C	(CSB,N,,<.XX>);		;(20)POINTER TO CPU STATUS BLOCK
.XX==<.CPDVL-1>B8+.CPDVS-.CPVBG ;LENGTH OF DEVICE STATUS BLOCK
C	(DSB,N,,<.XX>);		;(21)POINTER TO DEVICE STATUS BLOCK
IFE M.KL10,<.XX==0>		;NO SUBTABLE IF NOT A KL
IFN M.KL10,<
.XX==<.CPSDL-1>B8+.CPSBD-.CPVBG ;LENGTH OF SBDIAG SUBTABLE
>
C	(SDP,N,,<.XX>);		;(22) POINTER TO SBDIAG SUBTABLE (KL ONLY)
IFE	M.KL10&FTRSP,<.XX==0>	;ONLY KL-10'S HAVE PERF METER
IFN	M.KL10&FTRSP,<
.XX==<BPATLN*4>B8+.CPBPV-.CPVBG>;SIZE FOR PERF BACKGROUND TABLE
C	(BPA,N,,<.XX>);		;(23) PERF ANAL NUMBERS SUBTABLE POINTER
C	(PCB,N,Y,0)		;(24) ADDRESS OF CI PORT CONTROL BLOCK
C	(NPB,N,Y,0)		;(25) ADDRESS OF NI PORT CONTROL BLOCK

;ADD CONSTANTS TO BE PUBLISHED ABOVE HERE:
;UNPUBLISHED CONSTANTS:

C	(MAP,N,Y,.E'N'MAP);		;ADDRESS OF THIS CPU'S EXEC MAP
C	(SPT,N,Y,<EXP SPTTAB+N>);	;SPECIAL PAGES TABLE

IFN FTMP,<
C	(CHX,N,Y,<EXP TKSCHX##_<^D18+'N>>)
>
C	(CPN,N,Y,<EXP N>);		;CPU NUMBER
DEFINE CPUDEF(M)<
	IFE N,<
		IFE M,<CAIA>
		IFN M,<CAI>>
	IFN N,<
		IFN M,<CAIA>
		IFE M,<CAI>>
	>
C	(SK0,N,Y,CPUDEF(0));		;GENERATE SKIP FOR "SKPCPU(0)"
C	(SK1,N,Y,CPUDEF(1));		;AND FOR "SKPCPU(1)" **MAINTAIN ORDER**
C	(OK1,N,Y,.C0OK);		;CONTAINS ADR OF OTHER CPU
					; OK WORD. SEE .CPOK ABOVE.
C	(SLF,N,Y,.C'N'CDB);		;POINTER TO START OF CDB

DEFINE SCNLOC<
IFE N,<SSCAN>
IFN N,<SSCAN1>>
C	(SCN,N,Y,<SCNLOC>);		;CONTAINS ADR OF SCHEDULER RUN QUEUE SCAN LIST
IFN FTNSCHED,<
DEFINE SCN<
IFE N,<SSSCAN>
IFN N,<SSSCN1>
>
C	(SST,N,Y,<SCN>);
>
DEFINE PDLDEF(LEN)<
IFE N,<XWD LEN,NULPDL>
IFN N,<XWD LEN,NU'N'PDL>>
C	(NPD,N,Y,<PDLDEF(MNULPD)>);	;CONTAINS NULL PDL PTR
DEFINE PDLDEF(LEN)<
IFE N,<XWD LEN,ERRPDL>
IFN N,<XWD LEN,ER'N'PDL>>
C	(EPD,N,,<PDLDEF(ERRPLL)>);	;CONTAINS ERR PDL PTR
					; ERROR IN NULL JOB
C	(NJD,N,Y,NU'N'DAT);		;CONTAINS ADR OF NULL JOB DATA AREA. OFFSET BY 20
					; USED TO SAVE ACS IN 20-37.
C	(STO,N,,SC'N'TIC##)		;SCANNER ONCE A TICK ROUTINE FOR THIS CPU
C	(ISR,N,,SC'N'SEC##)		;SCANNER ONCE A SECOND
IFN FTMP,<
C	(DLK,N,,-1)			;USED FOR CALLING DSKLOK WHEN ALREADY HAVE IT
C	(SCD,N,Y,-1)			;PER CPU SCHEDULER INTERLOCK FLAG
C	(RES,N,,<HALT AP'N'RES>)	;RESTORE AFTER POWER FAIL
C	(NBI,N,,0)			;NUMBER OF INTERLOCKS THAT WERE OWNED
					; BY THIS CPU AND BROKEN BY BRKLOK
IFG <CPUN-1>,<
C	(ABK,N,,AP'N'BCK)		;RETURN ADDRESS FOR CPNBPT
>
>
C	(KAF,N,,AP'N'KAF)		;CPU DEPENDANT KEEP-ALIVE FAILURE
					;DISPATCH ADDRESS
C	(EPL,N,,EP'N'PDL)		;PDL FOR PROCESSING PDL OVF

;APR DEPENDENT CONSO AND CONO BITS

C	(NAP,N,Y,A'N'.NOT);		;CONTAINS ALL PIS IN PROGRESS EXCEPT APR PI
					; ON THIS CPU. (NOT APR PI)
C	(APP,N,,A'N'.APP);		;APR PI IN PROGRESS
A'N'.XXX==AP'N'CHN
C	(API,N,Y,<A'N'.XXX>);		;APR PI CHANNEL FOR THIS CPU
C	(ACO,N,,A'N'.ACO);		;APR PI CHANNEL ON
C	(CHL,N,,<EXP AP'N'CHL>);	;ADDRESS OF INTERRUPT PC FOR APR LEVEL
C	(CKL,N,Y,<EXP CK'N'CHL>);	;ADDRESS OF INTERRUPT PC FOR CLOCK LEVEL
IFN M.KL10,<
AN.XXX==LP.PAR+LP.PWF+LP.SBE+LP.NXM+LP.IOF+LP.CDP+LP.ADP
>
IFN M.KS10,<
AN.XXX==SP.PWF+SP.ITI+SP.FEI
>
C	(CON,N,,AN.XXX);		;APR CONSO MASK

IFN M.KL10,<AN.XXX=LP.NXM+LP.SBE+LP.PAR+LP.PWF+LP.IOF+LP.CDP+LP.ADP+LP.CSD>
IFN M.KS10,<AN.XXX==SP.PWF+SP.ITI+SP.FEI>

C	(EEB,N,,AN.XXX);		;EXEC ENABLED BITS

IFN CP0KLN,<A0.XXX==LP.CSF+LP.NXM+LP.PAR+LP.IOF+LP.PWF+LP.SBE+LP.CDP+LP.ADP>
IFN CP1KLN,<A1.XXX==LP.CSF+LP.NXM+LP.PAR+LP.IOF+LP.PWF+LP.SBE+LP.CDP+LP.ADP>
IFN CP0KSN,<A0.XXX==SP.CSF+SP.PWF+SP.HMP+SP.NXM>

C	(IEF,N,,A'N'.XXX);		;MASK TO CLEAR ALL APR ERROR BITS

DEFINE KL,<SETZM .CPTIM>
DEFINE KS,<SETZM .CPTIM>

C	(CCF,N,,<KILS>);		;CLEAR CLOCK FLAG INSTRUCTION

DEFINE KL,<SKIPN .CPTIM>
DEFINE KS,<SKIPN .CPTIM>

C	(HCT,N,,<KILS>);		;HAS CLOCK TICKED? (SKIP IF YES)
DEFINE KL<EXP CPLMPI##>
DEFINE KS<EXP CPSMPI##>

C	(MPI,N,,<KILS>);	;LH=0, RH=ADDRESS OF CPUN
				; PARITY SWEEP LOOP INSTRUCTION WHICH PICKS
				; UP MEMORY. USED BY APR PI INTERRUPT TO
				; CHECK FOR EXPECTED BAD PARITY IN SWEEP

DEFINE KL<EXP CP.PXX+CP.PS'N'+CPLMPS##>
DEFINE KS<EXP CP.PXX+CP.PS'N'+CPSMPS##>

C	(MPS,N,,<KILS>);	;RH=ADR OF MEMORY PARITY/NXM SCAN ROUTINE
				;LH=BITS TO REQUEST SCAN BY THIS CPU
DEFINE KL<EXP LP.CSF+LP.NXM>
DEFINE KS<EXP SP.CSF+SP.NXM>

C	(NXM,N,,<KILS>);		;MASK TO TEST/CLEAR APR NXM ERROR

DEFINE KL<EXP LP.CSF!LP.PAR>
DEFINE KS<EXP SP.CSF!SP.HMP>

C	(MPE,N,,<KILS>);		;MASK TO TEST/CLEAR APR PARITY ERROR
	DEFINE	EVENTM(LIST),<
	NARGS==0
	IRP LIST,<NARGS==NARGS+1>
	IFG NARGS*M.CPU-^D36,<PRINTX ?DOORBELL BIT OVERFLOW>
	ZZ==0
	XX2==0
	IRP LIST,<
	XX1==1_<<ZZ*M.CPU>+N>
	XX2==XX2+XX1
.C'N''LIST'S:	<<<1_M.CPU>-1>_<ZZ*M.CPU>>-XX1
IFE ZZ,<		;QUEUE NUMBER ZERO
.C'N'BIT:		;CPU BIT NUMBER (.CPBIT=.CPSCC)
.CPBIT==:.C0BIT-.C0CDB+.EPCDB
>
.C'N''LIST'C:	XX1
.CP'LIST'S==:.C0'LIST'S-.C0CDB+.EPCDB
.CP'LIST'C==:.C0'LIST'C-.C0CDB+.EPCDB
	ZZ==ZZ+1
	>
.C'N'DBM:	XX2
.CPDBM==:.C0DBM-.C0CDB+.EPCDB
>
	EVENTM (<SC,QP>)
INTERN .C0QPC

DEFINE EPMDEF,<

IFN M.KL10,<
IFE N,<LG.TEN+EPMPA+LG.KLP>	;TRAP ENABLE, PAGE# OF EPT, & KL-PAGING
IFN N,<LG.TEN+E'N'MPA+LG.KLP>
> ;END IFN M.KL10

IFN M.KS10,<
IFE N,<SG.TEN+EPMPA+SG.KLP>	;TRAP ENABLE, PAGE# OF EPT, & KL-PAGING
IFN N,<SG.TEN+E'N'MPA+SG.KLP>
> ;END IFN M.KS10

> ;END EPMDEF

C	(EBR,N,Y,<EPMDEF>);	;EXEC BASE REGISTER ON THIS CPU
IFN M.KS10,<
C	(FEF,N,,0);		;FRONT END FLAG-SET NON-ZERO WHEN FE INTERRUPTS
>
C	(CTN,N,Y,CT'N'LIN);	;RH = CTY NUMBER FOR THIS CPU
				;LH = DLS LINE NUMBER ON DTE
IFN M.KL10,<
C	(DTN,N,Y,M'N'DTEN);	;NUMBER OF DTES ON THIS CPU
IFN FTSCA,<
C	(SCA,N,Y,-1)		;SCA INTERLOCK NESTING
C	(SCP,N,Y,0)		;SCA CHANNEL ENABLE STATES
>; END IFN FTSCA
>; END IFN M.KL10
IFN FTENET,<
C	(ETH,N,Y,-1)		;ETHERNET INTERLOCK NESTING
IFN M.KL10,<
IFE M.ENET,<
C	(NPS,N,Y,0)		;NO PI SAVE ROUTINE IF NO KLNI
>; END IFE M.ENET
IFN M.ENET,<
DEFINE KNISAV(C,X),<
	IFN C,<SAV'C'X>
	IFE C,<SAV'X>
>; END DEFINE KNISAV
IF1,<C	(NPS,N,Y,0)>		;ADDRESS OF KLNI PI SAVE ROUTINE
IF2,<C	(NPS,N,Y,KNISAV(N,\KNICHN))>
>; END IFN M.ENET
>; END IFN M.KL10
>; END IFN FTENET
C	(CAC,N,Y,0);		;DEFINE CRASH AC'S IN CPU DATA BLOCK
.C'N'CA0=.C'N'CAC
BLOCK	17
C	(STT,N,Y,0)		;TEMP USED BY K?SER FOR TRAP PROCESSING
;THE FOLLOWING TWO ENTRIES (.CPST1 & .CPST2) MUST BE CONTIGUOUS
C	(ST1,N,Y,0)		;PLACE TO SAVE T1 ON PAGE TRAPS
C	(ST2,N,Y,0)		;PLACE TO SAVE T2 ON PAGE TRAPS
;THE FOLLOWING FOUR ENTRIES (.CPEJ1 TO .CPEJ4) MUST BE CONTIGUOUS
C	(EJ1,N,Y,0)		;TEMP USED BY K?SER FOR IME PROCESSING
C	(EJ2,N,Y,0)		;TEMP USED BY K?SER FOR IME PROCESSING
C	(EJ3,N,Y,0)		;TEMP USED BY K?SER FOR IME PROCESSING
C	(EJ4,N,Y,0)		;TEMP USED BY K?SER FOR IME PROCESSING
IFN FTRTTRP,<
IF1,<
C	(RCT,N,Y,0)		;REAL TIME PI CHANNEL TABLE
BLOCK	5
C	(RDT,N,N,0)		;REAL TIME DISMISS TABLE
BLOCK	5
>
IF2,<
	ZZ==10*N+1

	DEFINE	BLDTB1(ZZ)
	<IFNDEF UNIQ'ZZ,<BLDTB2(ZZ)>
	IFDEF	UNIQ'ZZ,<IFE UNIQ'ZZ,<BLDTB2(ZZ)>
				IFN UNIQ'ZZ,<EXP 0>>>

	DEFINE	BLDTB2(ZZ)
	<IFN CUSD'ZZ,<EXP CH'ZZ>
	IFE	CUSD'ZZ,<XWD 400001,CH'ZZ>>

	DEFINE	BLDTB3(ZZ)
	<IFDEF CHND'ZZ,<XWD RTSV'ZZ,CHND'ZZ>
	IFNDEF	CHND'ZZ,<EXP 0>>

REPEAT 6,<
	BLDTB1(\ZZ)
	ZZ==ZZ+1>

	ZZ==10*N+1


REPEAT 6,<
	BLDTB3(\ZZ)
	ZZ==ZZ+1>
>>
C	(CPI,N,Y,0);		;PI STATUS
;**** KEEP THE FOLLOWING TWO LOCATIONS TOGETHER
C	(SVA,N,,0)		;JSR HERE TO SAVE ALL AC SETS
C	(SVB,N,,<JRST SVSETS>)	;WHERE TO GO TO DO THE WORK
;**** END OF KEEP TOGETHER
C	(TRP,N,Y,0);		;MUUO DURING CRASH
C	(RTS,N,,0)		;TEMP USED DURING RTTRP ERROR PROCESSING
C	(RTT,N,Y,0);		;RTTRP IN PROGRESS FLAG (DEFINED
				; HERE BECAUSE IT MUST BE 0 DURING ONCE-ONLY)
C	(TML,N,,0)		;VALUE OF "TIME" AT LAST CLOCK TIC
				; USED FOR TIMING FUNCTION, E.G.,
				; MAINTAINING CLOCK QUEUE AND SMITHSONIAN DATE
				; MUST BE DEFINED HERE SINCE INITIALIZED BY SYSINI
C	(OCB,N,,0)		;0 IF THIS CDB ISN'T OWNED BY ANY CPU
C	(AID,N,,0)		;-1 IF RESTART AS OPPOSED TO INITIAL STARTUP
C	(DWD,N,,-1)		;RECURSION INTERLOCK FOR DIE
IFE FTKS10,<
DEFINE SAVPIS(C,A,B)<
	IFN C,<	XWD SAV'C'A,SAV'C'B>
	IFE C,<XWD SAV'A,SAV'B>
>
IF1,<C	(SAV,N,,0)>
IF2,<
C	(SAV,N,,SAVPIS(N,\TAPCHN,\DSKCHN)) ;PI SAVE ROUTINES.
>
C	(ACD,N,,<-1>)	;AUTCON HAS RUN ON THIS CPU. ZEROED
IFN FTMP,<
DEFINE INTLTP(C,A)<
	IFN C,<EXP INTL'C'A>
	IFE C,<EXP INTL'A>
>
IF1,<C	(TIL,N,,0)>
IF2,<
C	(TIL,N,,INTLTP(N,\TAPCHN))
>
>
>
IFN FTAUTC,<
C	(ASC,N,,-1)		;NUMBER OF AUTO-CONFIGURED SOFTWARE CHANNELS
IFNDEF CP'N'NRP,<CP'N'NRP==7*N>	;RESERVE 7 CHANNELS PER CPU FOR RP04 CHANNELS
IFNDEF CP'N'NRN,<CP'N'NRN==7*N>	;RESERVE 7 CHANNELS PER CPU FOR RP20 CHANNELS
IFNDEF CP'N'NTP,<CP'N'NTP==7*N>	;RESERVE 7 CHANNELS PER CPU FOR TAPES
DEFINE NUM(C)<	BYTE (12)	CP'C'NRP,CP'C'NRN,CP'C'NTP>
C	(NUM,N,,NUM(N))		;STARTING RP, RN, MT LETTER (0=A, 1=B,...)
>	;END IFN FTAUTC
C	(CML,N,,0)		;LDB ADDRESS OF LINE ON WHICH COMMAND IS BEING
				; PROCESSED ON THIS CPU
DEFINE TAPCHL(C,A)<
	IFN C,<EXP CH'C'A>
	IFE C,<EXP CH'A>
>
IF1,<C	(TCH,N,,0)>
IF2,<
C	(TCH,N,,TAPCHL(N,\TAPCHN))	;CH'N USED FOR VECTORED TAPE INTERRUPTS
>
;CDB CONSTANTS FOR KL10 ERROR REPORTING/RECOVERY
IFN M.KL10,<
C	(SPR,N,,<CONO APR,LP.SSF+LP.PAR+AP'N'CHN>);
	;INSTRUCTION TO CAUSE PARITY ERROR INTERRUPT
C	(CPR,N,,<CONO APR,LP.CSF+LP.PAR+LP.SBE+AP'N'CHN>);
	;INSTRUCTION TO CLEAR PARITY ERROR FLAG(ALSO CLEARS SBUS ERROR-ON FOR SOME PARITY)
C	(SB0,N,,<100000,,0>)	;DO SBDIAG 0 HERE ON ERRORS
C	(S0A,N,,<0>)		;ANSWER RETURNED HERE
C	(SB1,N,,<100000,,1>)	;SBDIAG FN 1 DONE HERE
C	(S1A,N,,<0>)		;ANSWER RETURNED HERE


>;END IFN M.KL10


C	(TOA,N,,CCTYO##)	;TYPE OUT ADDRESS FOR THIS CPU (OLD COMTOA)
C	(TIV,N,,0)		;ADDRESS OF VECTOR OF INPUT ROUTINES
C	(LFC,N,,0)		;LAST FORCED COMMAND INDEX FOR JOB IN COMCON
IFN M.KL10,<
C	(NLD,N,,0)		;FLAG THAT SAYS WHETHER OR NOT TO DO AUTO
				;  RELOAD OF DX20'S.  0 TO ENABLE RELOADS,
				;  NON-ZERO TO DISABLE RELOADS
>
;EXEC DDT WORDS
C	(DDT,N,Y,<BPTNOP>)	;NOOP OR INSTRUCTION TO ENTER EDDT
				; THIS WORD MAY BE EXECUTED ANYTIME ANY
				; ROUTINE WANTS TO ENTER EDDT VIA THE
				; THE UNSOLICITED BREAKPOINT FACILITY.
				; SETUP BY CPUDDT.

;EXEC DATA VECTOR FOR EDDT SYMBOL TABLE HIDING

C	(EDV,N,Y,<XWD 'EDV',.EDLEN>);CODE,,LENGTH OF EXEC DATA VECTOR
C	(ED1,N,N,<.C'N'SYB>)	;ADDRESS OF THE ADDRESS SWAPPING BLOCK
C	(ED2,N,N,<0>)		;RELOCATED CONTENTS OF .JBSYM
C	(ED3,N,N,<0>)		;RELOCATED CONTENTS OF .JBUSY
C	(ED4,N,N,<.C'N'HSF>)	;ADDRESS OF A WORD FOR DDT TO PLAY WITH
	.XX==CPTYP!ED.KLP	;ALL SUPPORT KL PAGING
IFN FTKL10,<.XX==.XX!ED.XKL>	;AND KL MUST BE EXTENDED
C	(ED5,N,N,<.XX>)		;CPU/PAGING/HARDWARE DATA
C	(ED6,N,N,<.E'N'MP>)	;PHYSICAL ADDRESS OF THE EPT
C	(ED7,N,N,<SPTTAB+N>)	;PHYSICAL ADDRESS OF THE SPT
C	(ED0,N,N,<0>)		;PHYSICAL ADDRESS OF THE CST

C	(HSF,N,N,<0>)		;THE WORD ITSELF (DDT REMEMBERS CONTEXT HERE)
				;HIDDEN SYMBOL CONTROL BLOCK
C	(SYB,N,Y,<1+4+IFE FTXMON,<IFN M.DECN,<4>>>);# WORDS (INC THIS) IN BLOCK
				;***FIRST SUB BLOCK, ALWAYS PRESENT
C	(SY1,N,N,<SYMSIZ>)	;(0) NUMBER OF WORDS TO SWAP
C	(SY2,N,N,<.E'N'MAP+<MONORG/1000>>) ;(1) FIRST WORD TO SWAP

C	(SY3,N,N,SYMBK1)	;(2) PLACE WHERE NEW MAP MAY BE FOUND
C	(SY4,N,N,SYMBK2)	;(3) PLACE TO SAVE OLD CONTENTS
				;***END OF FIRST SUB BLOCK
IFE FTXMON,<IFN M.DECN,<	;***SECOND SUB BLOCK, MAKES REGULAR MAP CURRENT
C	(SY5,N,N,<1>)		;(0) 1 WORD TO SWAP
C	(SY6,N,N,<.E'N'STB+0>)	;(1) ADDRESS - SECTION ZERO POINTER
C	(SY7,N,N,<.E'N'RMP>)	;(2) NEW CONTENTS - NORMAL CONTEXT
C	(SY8,N,N,<.C'N'SY9>)	;(3) ADDRESS OF SAVE AREA
				;***END OF SECOND SUB BLOCK
				;END OF HIDDEN SYMBOL BLOCK FOR DDT
C	(SY9,N,N,<0>)		;DDT STORES "CURRENT" MAP PTR HERE
>>
;**** KEEP FOLLOWING FOUR LOCATIONS TOGETHER
C	(SPC,N,Y,0)		;STOPCD PC FLAGS STORED HERE DURING DIE
C	(SP1,N,N,0)		;STOPCD PC
C	(SP2,N,N,IC.UOU)	;NEW FLAGS
C	(SP3,N,N,PERISH)	;JSR ENTRY POINT INTO DIE
;**** END KEEP TOGETHER



CRSHAC==:.C0CAC
CRSHPI=.C0CPI
.CPCLN==.-.C0CDB		;LENGTH OF CONSTANTS AREA
XP .CPPCL,<<.C0CPN-.C0CDB>B26>	;PUBLISHED CPU DEPENDANT CONSTATNS LENGTH
				;SHIFTED LEFT 9 BITS FOR GETTAB TABLE
CROAK=:.CPSPC			;XPCW ENTRY TO DIE
;VARIABLES AREA FOR CPU 0 CDB (ALSO DEFINED SYMBOLS FOR CPU 1)

;OLD NSWTBL GETTAB
;HAS SOME VARIABLES WHICH ARE SYSTEM RATHER THAN CPU DEPENDENT.
;HOWEVER FOR COMPATIBILITY, THEY ARE KEPT TOGETHER.
;.SYTBL HAS NEW SYSTEM VARIABLES DEFINED AFTER 5.03 RELEASE
IFE N,<
XP NSWTBL,.-10		;GETTAB TABLE NO 12. VARIABLES PERTAINING
			; TO SWAPPING AND NON-SWAPPING SYSTEMS.
			; FIRST 10 LOCATION NO LONGER USED.
			;THE NUMBERS IN () ARE FOR NEW CPU DEPENDENT
			; GETTAB TABLE .GTC0V.
>

LOC==.			;START LOC AT ABS. BEG OF VARIABLE AREA
			; LOC USED IN V MACRO AS A LOCATION COUNTER
V	(VBG,N,Y,,0) ;BEGINNING OF VARIABLE AREA FOR CPU 0

V	(,N,,CORMAX);	;(0)(REALLY SYSTEM VAR.) MAXIMUM CORE REQUEST+1 (IE LARGEST REL. ADR,+1)
			; CAN BE RESTRICTED TO LESS THAN ALL OF USER CORE
			; BY BUILD AND/OR ONCE
V	(,N,,CORLST);	;(1)(REALLY SYSTEM VAR.) 1 BIT BYTE POINTER TO LAST FREE
			; BLOCK POSSIBLE SET BY SYSINI ON 143 STARTUP
V	(,N,,CORTAL);	;(2)(REALLY SYSTEM VAR.) TOTAL NUMBER OF
			; FREE+DORMANT+IDLE CORE BLKS LEFT
V	(,N,,SHFWAT);	;(3)(REALLY SYSTEM VAR.) JOB NUMBER SHUFFLER
			 ;HAS TEMPORARILY STOPPED FOR ITS I/O DEVICES TO
			; BECOME INACTIVE BEFORE SHUFFLING
V	(,N,,HOLEF);	;(4)(REALLY SYSTEM VAR.) ABSOLUTE ADDRESS OF
			; LOWEST HOLE IN CORE, 0=NONE
V	(UPT,N,Y)	; ;(5) UPTIME FOR THIS CPU. NO OF CLOCK TICKS
			; SINCE SYSTEM LOADED OR RESTARTED AT 143
V	(,N,,SHFWRD);	;(6)(REALLY SYSTEM VAR.) TOTAL NUMBER OF WORDS
			; SHUFFLED BY SYSTEM
V	(,N,,STUSER);	;(7)(REALLY SYSTEM VAR.) JOB CURRENTLY USING THE
			; SYSTEM TAPE NEEDED SO CONTROL C WILL NOT TIE
			; UP SYSTEM TAPE
V	(,N,,HIGHJB);	;(10)(REALLY SYSTEM VAR.) HIGHEST JOB NUMBER
			; CURRENTLY ASSIGNED
V	(,N,,CLRWRD);	;(11)(REALLY SYSTEM VAR.) TOTAL NUMBER OF WORDS
			; CLEARED BY 'CLRCOR' RTN.
V	(LST,N,,LSTWRD);	;(12)LOST TIME ON THIS CPU.  TOTAL NUMBER OF
			; CLOCK TICKS WHEN NULL JOB RAN BUT OTHER JOBS
			; WANTED TO RUN AND COULD NOT DO SO BECAUSE: ---
			;  1. SWAPPED OUT OR ON WAY IN OR OUT
			;  2. MONITOR WAITING FOR I/O TO STOP SO IT
			;     CAN SHUFFLE OR SWAP
			;  3. JOB BEING SWAPPED OUT BECAUSE IT IS
			;     EXPANDING CORE
V	(,N,,MEMSIZ);	;(13)(REALLY SYSTEM VAR.) SIZE OF PHYSICAL MEMORY
			; IN WORDS (=FIRST NON EXIST WORD) SET BY SYSINI ON
			; 143 RESTARTS UNLESS SYMBOLS SAVED BY PATCHING
			; SYSLIM SMALLER.
V	(TPE,N);	;(14)TOTAL PARITY ERROR WORDS IN MEMORY DETECTED ON
			; DURING ALL CPU SWEEP WHILE PROCESSOR WAS IN EXEC OR USER MODE.  IF
			; SYSTEM HALTS,N, THIS LOC IS ALREADY UPDATED
V	(SPE,N);	;(15)TOTAL NON-REPRODUCING PARITY ERRORS IN MEMORY.
			; DETECTED ON THIS CPU.  IE ONES WHICH DID NOT
			; REOCCUR WHEN SAME CPU SWEPT THRU CORE.
			; CAN BE READ-PAUSE-WRITE WHICH REWRITES MEMORY
			; SO STILL A PARITY ERROR
			; OR CHANNEL DETECTED PARITY WHICH APR SWEEP DID
			; NOT FIND - SEE .CPPCS
V	(MPC,N,Y);	;(16)MEMORY PARITY CONTINUES FOR THIS CPU.
			; COUNT OF NUMBER OF TIMES OPERATOR PUSHED CONTINUE
			; AFTER SERIOUS MEMORY PARITY HALT
			; LH = -1 IF SERIOUS ERROR ON THIS BAD PARITY (MUST HALT)
			; LH CLEARED ON CONTINUE OR STARTUP.
V	(MPA,N,Y);	;(17)MEMORY PARITY ADDRESS FOR THIS CPU.
			; FIRST BAD PHYSICAL MEMORY ADDRESS FOUND WHEN
			; WHEN MONITOR SWEPT THRU CORE AFTER PROCESSOR
			; DETECTED FIRST BAD PARITY
V	(MPW,N,Y);	;(20)MEMORY PARITY WORD FOR THIS CPU.
			; CONTENTS OF FIRST BAD WORD FOUND BY MONITOR WHEN
			; MONITOR SWEPT THRU CORE AFTER FIRST PARITY
V	(MPP,N,Y);	;(21)MEMORY PARITY PC FOR THIS CPU.
			; PC OF LAST MEM PARITY (NOT COUNTING SWEEP THRU CORE)
V	(,N,,EPOCNT);	;(22)(REALLY SYSTEM VAR)
			; # OF PDL OVF'S AT UUO LEVEL IN EXEC MODE NOT
			; RECOVERED
V	(,N,,EPOREC);	;(23)(REALLY SYSTEM VAR) # OF PDL OVF'S AT
			; UUO LEVEL IN EXEC MODE RECOVERED
V	(,N,,MAXMAX);	;(24)(REALLY SYSTEM VAR) HIGHEST LEGAL VALUE OF CORMAX
V	(,N,,SYSKTM);	;(25)(REALLY SYSTEM VAR) COUNT-DOWN TIMER FOR SET
			; KSYS COMMAND
V	(,N,,CORMIN);	;(26)(REALLY SYSTEM VAR) LOWER BOUND ON CORMAX,
			; LOKCON WILL NEVER ALLOW CORMAX TO BECOME
			; SMALLER THAN THE CONTENTS OF THIS LOCATION
V	(ABC,N,Y);	;(27)ADDRESS BREAK COUNT ON THIS CPU.
V	(ABA,N,Y);	;(30)ADDRESS BREAK ADDRESS ON THIS CPU.
			; STORAGE FOR DATA SWITCHES ON ADDRESS BREAK
			; INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
			; TO USERS IN NON-SWAP AND SWAP SYSTEMS
V	(LJR,N);	;(31)LAST JOB RUN ON THIS CPU.  JOB IS COPIED
			; TO .CPLJR WHENEVER JOB IS CHANGED (INCLUDING TO
			; NULL JOB) - FTTRACK COND.
V	(ODA,N,,,3)	; OBSOLETE (MOVED TO RESPONSE SUBTABLE)
IFE N,<
XP NSWMXL,<<.-NSWTBL-1>B26>	;MAX. NSWTBL ENTRY SHIFTED LEFT 9 BITS.
>
			; NEW ENTRIES ARE ADDED BEYOND END OF NSWTBL END.
			; SO NSWTBL IS NO LONGER ACTIVE.  INSTEAD
			; CPU DEPENDENT GETTAB .GTC0V SHOULD BE USED.
V	(STS,N,Y);	;(35)STOP TIME SHARING ON THIS CPU.
			; CONTAINS JOB NO. WHICH DID TRPSET UUO.
V	(RUN,N,Y);	;(36)OPERATOR CONTROLLED SCHEDULING FOR THIS CPU
			; AS SET BY PRIVILEGED .STRUN
			; FUNCTION OF SETUUO.  (SEE OPSER :SET RUN COMMAND).
			; SIGN BIT=0 MEANS RUN JOBS ON THIS CPU.
			; SIGN BIT=1 MEANS DO NOT RUN JOBS ON THIS CPU.
			; EXCEPT UUOS ON MASTER.  REST OF BITS
			; RESERVED FOR FUTURE SCHEDULING PARAMETERS.
			; RESET TO 0 ON 143 RESTART
V	(NUL,N);	;(37) CONTAINS THE NULL TIME FOR THIS CPU
			;IN JIFFIES
V	(EDI,N);	;(40) NO. OF EXEC. DON'T CARE
			; INTERRUPTS. IE USER ENABLED APR
			; INTERRUPTS WHICH MONITORS CAUSES (AOV,N,FOV)
			; LH = EXEC PC SO WE CAN FIX
			; INEFFICIENT CODE
V	(JOB,N,Y);	;(41) CURRENT JOB ON THIS CPU. REFERENCED
			; AS BOTH .CPJOB AND JUST JOB THROUGHOUT MONITOR.
			;MAKE AVAILABLE FOR SNOOPY
V	(OHT,N);	;(42) CONTAINS THE OVERHEAD TIME
			; FOR THIS CPU IN JIFFIES.
			; INCLUDES CLOCK QUEUE PROCESSING,N, SHORT COMMAND PROCESSING,
			; SWAPPING & SCHEDULING DECISIONS, SOFTWARE CONTEXT SWITCHING
			; DOES NOT INCLUDE UUO EXECUTION
			; SINCE THAT IS NOT REALLY OVERHEAD
V	(EVM,N,Y);	;(43) THE MAXIMUM AMOUNT OF EXEC VIRTUAL
			; ADDRESS SPACE ALLOWED TO BE USED FOR
			; MAPPING USER SEGMENTS IN EXEC MODE
			; BY THE LOCK UUO.

V	(EVU,N,Y);	;(44) THE TOTAL AMOUNT OF EXEC VIRTUAL
			; ADDRESS SPACE CURRENTLY BEING USED
			; TO MAP USER SEGMENTS.
V	(LLC,N,Y);	;(45) LOCK LOOP COUNT. NO. OF TIMES
			; THIS CPU HAS LOOPED
			; WAITING FOR OTHER CPU
V	(TUC,N,Y);	;(46) TOTAL NO. OF UUOS FROM
			; EXEC AND USER MODE ON THIS CPU
			; SINCE SYSTEM WAS STARTED.
			; INCLUDES TRAPS TO 60 EXCEPT UJEN.
			; (DO NOT COUNT TRAPS ON CPU1 ON CPU0 ALSO)
V	(TJC,N);	;(47) TOTAL JOB CONTEXT-SWITCHES
			; COUNT FOR THIS CPU INCLUDING
			; NULLJOB SINCE SYSTEM WAS
			; STARTED. COUNT ONE EACH TIME
			; NEW JOB IS DIFFERENT FROM OLD ONE
V	(TNE,N);	;(50) TOTAL NXM'S THIS CPU
V	(SNE,N);	;(51) TOTAL NON-REPRODUCIBLE NXM'S THIS CPU
V	(NJA,N);	;(52) TOTAL JOBS CRASHED THIS NXM
V	(MNA,N,Y);	;(53) FIRST ADDRESS FOUND WITH NXM
V	(EBJ,N,Y);	;(54)EBOX TICKS/JIFFY (ONCE COMPUTED)
V	(MBJ,N,Y);	;(55)MBOX TICK/JIFFY
V	(PBA,N,Y);	;(56)PHYSICAL ADDR WITH BAD PARITY ON LAST AR/ARX
			;  PARITY TRAP
V	(TBD,N,Y);	;(57)CONTENTS OF BAD WORD ON LAST AR/ARX
			;  PARITY TRAP
V	(TGD,N,Y);	;(60)GOOD CONTENTS OF WORD AFTER WE RECOVERED
			; AR/ARX PARITY TRAP
V	(NPT,N,Y);	;(61)TOTAL NUMBER OF AR/ARX PARITY TRAPS
V	(AER,N,Y);	;(62)RESULTS OF RDERA ON PARITY/NXM INTERRUPT
V	(PEF,N,Y);	;(63)RESULTS OF CONI APR, ON PARITY/NXM INTERRUPT
V	(PSB,N,Y,,4);	;(64-67)OBSOLETE
V	(PPC,N,Y);	;(70)PC ON LAST AR/ARX PARITY TRAP
V	(PFW,N,Y);	;(71)PAGE FAIL WORD ON LAST AR/ARX PARITY TRAP
V	(HPT,N);	;(72)NUMBER OF HARD AR/ARX PARITY TRAPS
V	(SAR,N);	;(73)NUMBER OF SOFT AR/ARX TRAPS
V	(PTP,N);	;(74)NUMBER OF PAGE TABLE PARITY TRAPS
V	(CSN,N,Y);	;(75)NUMBER OF CACHE SWEEPS STARTED (CACHE SWEEP SERIAL NUMBER)
V	(CLN,N);	;(76)NUMBER OF TIMES SCHEDULER SKIPPED OVER A JOB BECAUSE CACHE
			; SWEEP HAD TO BE DONE FIRST
V	(CLT,N);	;(77)AMOUNT OF TIME IN JIFFIES THAT CPU RAN NULL JOB BECAUSE OF STATE OF CACHE
V	(CSD,N);	;(100)CACHE - SWAPPER DELAY COUNT-INCREMENT ON 1088
			; SYSTEMS IF SWAPPER HAS TO WAIT FOR ANOTHER CPU
			; TO SWEEP ITS CACHE BEFORE IT CAN START I/O
V	(CRN,N);	;(101)CACHE SWEEP REQUEST SWEEP COUNT (SIC)
			; COMMANDING THIS VALUE TO .CPCSD+.CPCLN (NUMBER
			; OF SWEEP REQUESTS MADE) WILL INDICATE TO WHAT EXTENT
			; THE REQUEST SCHEME IS A BOTTLENECK

V	(CEC,N,Y);	;(102)COUNT OF NON-RECOVERABLE AR/ARX
			; PARITY ERRORS WHICH INVOLVED CACHE.  AFTER 3
			; SUCH FAILURES CACHE IS TURNED OFF IN TRAP
			; ROUTINE WITH APPROPRIATE MESSAGE TO OPERATOR.
V	(PTR,N,Y);	;(103)RETRY WORD FOR AR/ARX PARITY TRAP
			; ROUTINE.  INCLUDES STATUS FLAGS IN LH AND
			; RETRY COUNT IN RH.
V	(TSD,N,Y);	;(104)AR/ARX TRAP ROUTINE HAS ALREADY
			; SAVED APR.ERA.SB DIAGS ETC FOR ERROR REPORTING.
			; WON'T BE DONE AGAIN AT APR INTERRUPT
V	(REP,N,Y);	;(105)USED BY PARITY/NXM RECOVERY ROUTINES
			; TO DETERMINE WHICH TYPE ERRORS SHOULD BE LISTED.
V	(NDB,N)		;(106)NUMBER OF TIMES THIS CPU'S DOORBELL WAS RUNG
V	(SBR,N)		;(107) CPU/DEVICE STATUS BLOCKS READ ON THIS CPU
			;LH=UNUSED
			;RH=BITS TELLING WHICH STATUS BLOCKS HAVE BEEN
			;READ ON THIS CPU.  SEE DEFINITIONS FOR SR.XXX IN S.
V	(BPF,N,Y);	;(110) BACKGROUND PERFORMANCE ANALYSIS FLAG
			;.LT. 0 IF METER ENABLED (SINCE COUNTED UP AT
			; CLOCK LEVEL INDEPENDENTLY ON EACH CPU PROGRAMS
			; SHOULD CHECK FOR .LE. 0)
V	(FBI,N)		;(111) FILE BLOCKS INPUT (READ)
V	(FBO,N)		;(112) FILE BLOCKS OUTPUT (WRITTEN)
V	(SBI,N,Y)	;(113) SWAPPING BLOCKS INPUT (READ)
V	(SBO,N,Y)	;(114) SWAPPING BLOCKS OUTPUT (WRITTEN)
V	(SNC,N)		;(115) NUMBER OF CPU STOPCDS
V	(SND,N)		;(116) NUMBER OF DEBUG STOPCDS
V	(SNJ,N)		;(117) NUMBER OF JOB STOPCDS
V	(SJN,N)		;(120) JOB NUMBER OF LAST STOPCD
V	(SNM,N)		;(121) NAME OF LAST STOPCD
V	(SPN,N)		;(122) PROGRAM RUNNING AT LAST STOPCD
V	(SPP,N)		;(123) PPN RUNNING AT LAST STOPCD
V	(STN,N)		;(124) TTY NAME AT LAST STOPCD
V	(SUP,N)		;(125) USER PC AT TIME OF LAST STOPCD
V	(SUU,N)		;(126) UUO AT TIME OF LAST STOPCD
V	(EJN,N)		;(127) JOB NUMBER AT LAST PARITY/NXM ERROR
V	(EPN,N)		;(130) PROGRAM NAME AT LAST PARITY/NXM ERROR
V	(PPI,N)		;(131) RESULTS OF CONI PI, ON PARITY/NXM INTERRUPT
V	(TPI,N)		;(132) RESULTS OF CONI PI, ON PARITY/NXM TRAP
			; IF SWEEP IS AT APR LEVEL, CH7 LEVEL ALWAYS
			; REPORTED NXM ERROR REGARDLESS OF WHY THE SWEEP WAS DONE.
V	(RSI,N)		;(133) NUMBER OF TIMES SCHEDULER INTERLOCK WAS
			; REQUESTED WHEN NOT OWNED.
V	(TFI,N)		;(134)NO OF TAPE FRAMES READ ON THIS CPU
V	(TFO,N)		;(135)NO OF TAPE FRAMES WRITTEN ON THIS CPU
V	(SNI,N)		;(136)NO OF NODUMP STOPCDS (BUGINFs) ON THIS CPU
V	(STY,N)		;(137) TYPE OF LAST STOPCODE ON THIS CPU
V	(SDT,N)		;(140) UDT OF LAST STOPCODE ON THIS CPU

;**********************************************************************
;PUT NEW PUBLISHED VARIABLES ABOVE HERE
;**********************************************************************
;PUT NEW PUBLISHED SUB-TABLES BELOW HERE (SO LAST BUT STILL
;**********************************************************************
; INSIDE LEGAL RANGE OF VARIABLE GETTAB FOR THIS CDB
;**********************************************************************

;MORE RESPONSE DATA IN 4 WORD BLOCKS: SUM, NO. OF RESPONSES, SUM OF SQUARES
;THIS IS A CDB SUB-TABLE. IT IS CONDITIONALLY ASSEMBLED.
;USER PROGRAMS CAN ACCESS AFTER GETTING REL. POSITION FROM .CPRSP IN
; CPU CONSTANTS TABLE
IFN FTRSP,<			;RESPONSE FEATURE?
;INDICIES INTO 3 WORD BLOCKS:
XP RSPAXR,0			;ACCUMULATE SUM OF RESPONSE
XP RSPNXR,1			;NO. OF RESPONSES
XP RSPHXR,2			;SUM OF SQUARES OF RESPONSE(HIGH ORDER HALF)
XP RSPLXR,3			;SUM OF SQUARES OF RESPONSE(LOW ORDER HALF)
V	(AOR,N,Y)		;(R0) ACCUMULATED TTY OUTPUT UUO RESPONSE.
				; TOTAL NO. OF JIFFIES USERS HAVE SPENT WAITING
				; FOR THEIR JOBS TO DO A TTY OUTPUT UUO
				; AFTER TYPING INPUT (COMMAND OR USER TTY)
				; SEE JBTRSP, RSPTOR - CPU0 ONLY
V	(NOR,N);		;(R1) NO. OF TTY OUTPUT UUO RESPONSES
V	(HOR,N);		;(R2) SUM OF SQUARES OF TTY OUTPUT UUO RESPONSES
				; HIGH ORDER WORD
V	(LOR,N);		;(R3) SUM OF SQUARES OF TTY OUTPUT UUO RESPONSES
				; LOW ORDER WORD
V	(AIR,N,Y);		;(R4) ACCUMMULATED TTY INPUT UUO RESPONSES.
				; TOTAL NO. OF JIFFIES USERS SPENT WAITING
				; FOR THEIR JOBS TO DO A TTY INPUT UUO
				; AFTER TYPING INPUT (COMMAND OR USER TTY)
				; SEE JBTRSP, RSPTIR - CPU0 ONLY
V	(NIR,N);		;(R5) NO. OF TTY INPUT UUO RESPONSES
V	(HIR,N);		;(R6) SUM OF SQUARES OF TTY INPUT UUO RSPS
				; HIGH ORDER WORD
V	(LIR,N);		;(R7) SUM OF SQUARES OF TTY INPUT UUO RSPS
				; LOW ORDER WORD
V	(ARR,N);		;(R10) ACCUMMULATED CPU QUANTUM REQUE RESPONSES
				; TOTAL NO. OF JIFFIES USERS SPENT WAITING
				; FOR THEIR JOBS TO EXCEED CPU QUANTUM
				; AFTER TYPING INPUT (COMMAND OR USER TTY)
				; SEE JBTRSP,N, RSPREC - EITHER CPU
V	(NRR,N);		;(R11) NO. OF CPU QUANTUM REQUEUE RESPONSES
V	(HRR,N);		;(R12) SUM OF SQUARES OF CPU QUANT. REQUEUE RSPS
				; HIGH ORDER WORD
V	(LRR,N);		;(R13) SUM OF SQUARES OF CPU QUANT. REQUEUE RSPS
				; LOW ORDER WORD
V	(AXR,N);		;(R14) ACCUMMULATED RESPONSE TERMINATED BY
				; FIRST OF ABOVE 3 EVENTS (TTY OUTPUT
				; UUO,N, TTY INPUT UUO, OR CPU QUANTUM REQUE)
				; SEE JBTRSP, RSPREC
V	(NXR,N);		;(R15) NO. OF SUCH RESPONSES
V	(HXR,N);		;(R16) SUM OF SQUARES OF ANY OF ABOVE
				; HIGH ORDER WORD
V	(LXR,N);		;(R17) SUM OF SQUARES OF ANY OF ABOVE
				; LOW ORDER WORD
V	(ACR,N);		;(R20) ACCUMMULATED CPU RESPONSE
				; ON THIS CPU.  TOTAL # OF JIFFIES
				; USERS HAVE SPENT WAITING FOR THIS CPU
V	(NCR,N);		;(R21) NUMBER OF CPU RESPONSES ON THIS CPU.
V	(SCR,N);		;(R22) HIGH ORDER WORD OF SQUARE OF
				; CPU RESPONSES
V	(SCL,N);		;(R23) LOW ORDER WORD
V	(FADL,N)		;(R24) NUMBER OF FADL'S SIMULATED
V	(FSBL,N)		;(R25) NUMBER OF FSBL'S SIMULATED
V	(FMPL,N)		;(R26) NUMBER OF FMPL'S SIMULATED
V	(FDVL,N)		;(R27) NUMBER OF FDVL'S SIMULATED
V	(UFA,N)			;(R30) NUMBER OF UFA'S SIMULATED
V	(DFN,N)			;(R31) NUMBER OF DFN'S SIMULATED
V	(NRI,N)			;(R32)NUMBER OF CHARS (EXCLUDING MIC)RECEIVED
V	(NXI,N)			;(R33)NUMBER OF CHARS(INCLUDING FILL)XMITTED
V	(NEI,N)			;(R34)NUMBER OF CHARS ECHOED
XPC	.CPRSL,<.-.C0AOR>,N	;SUB-TABLE LENGTH
>				;END FTRSP

;THIS IS A CDB SUB-TABLE.
;USER PROG CAN BE ACCESS AFTER GETTING REL. POSITION FROM .CPPAR
; IN CPU CONSTANTS TABLE.

;MORE MEMORY PARITY ANALYSIS LOCATIONS
V	(LPA,N);		;(R0) LAST (HIGHEST) BAD MEM PARITY ADDRESS ON LAST
				; SWEEP OF MEMORY. USED TO TELL OPERATOR RANGE OF BAD
V	(MPR,N);		;(R1) REL. ADR (NOT VIRTUAL) IN HIGH OR LOW SEG OF
				; LAST MEM PAR ERROR
V	(PTS,N);		;(R2) NO. OF PARITY ERROR THIS (LAST) SWEEP OF CORE
				; SET TO 0 AT BEG OF SWEEP
V	(PSC,N);		;(R3) NO. OF PARITY SWEEPS BY MONITOR
				; (CP.TPE HAS TOTAL NO. OF BAD WORDS ON ALL SWEEPS)
V	(UEP,N);		;(R4) NO. OF USER ENABLED PARITY ERRORS
V	(PAA,N);		;(R5) AND OF BAD ADDRESSES THIS (LAST) MEM PAR SWEEP
V	(PAC,N);		;(R6) AND OF BAD CONTENTS THIS (LAST) MEM PAR SWEEP
V	(POA,N);		;(R7) OR OF BAD ADDRESSES THIS (LAST) MEM PAR SWEEP
V	(POC,N);		;(R10) OR OF BAD CONTENTS THIS (LAST) MEM PAR SWEEP
V	(PCS,N);		;(R11) NO. OF SPURIOUS PARITY ERRORS (APR SWEEP
				; FOUND NO BAD PARITY BUT CHANNEL HAD REQUESTED
				; SWEEP RATHER THAN PROCESSOR. THIS INDICATES A
				; CHANNEL MEMORY PORT PROBLEM
V	(MET,N);		;(R12) MOS ERROR TIMER
V	(MEC,N);		;(R13) MOS ERROR COUNTER
V	(TME,N);		;(R14) TOTAL MOS ERRORS
	XPC	.CPPRL,<.-.C0LPA>,N	;SUB-TABLE LENGTH

;THIS IS A CDB SUB-TABLE.
;USER PROG CAN ACCESS AFTER GETTING REL. POSITION FROM .CPPAR
; IN CPU CONSTANTS TABLE.

V	(BAT,N,,,M.CBAT)	;;(R0) TABLE OF BAD ADDRESSES ON LAST
				; MEMORY PARITY SWEEP. NOT
				; CLEARED, SO NUMBER OF VALID ENTRIES
				; KEPT IN .CPPTS (# PARITIES THIS SWEEP)
;MEMORY NXM SUBTABLE, POINTED
; TO BY .CPNMT
V	(LNA,N);		;(R0) LAST NXM ADDRESS
V	(MNR,N);		;(R1) LAST NXM RELATIVE ADDRESS
V	(NTS,N);		;(R2) NUMBER OF NXM'S FOUND THIS SWEEP
V	(NSC,N);		;(R3) NUMBER OF NXM SWEEPS DONE
V	(UEN,N);		;(R4) NUMBER OF USER ENABLED NXM'S
V	(NAA,N);		;(R5) LOGICAL AND OF BAD ADDRESSES
V	(NOA,N);		;(R6) INCLOSIVE OR OF BAD ADDRESSES
V	(NCS,N);		;(R7) NUMBER OF SPURIOUS CHANNEL NXM'S
XPC	.CPNML,<.-.C0LNA>,N		;NXM SUBTABLE LENGTH
;CPU STATUS BLOCK ENTRY GENERATED ON VARIOUS ERRORS

;THIS IS A CDB SUBTABLE
;WORDS FROM APRSTS(.C0ACN) THROUGH UPTSTS(.C0PGD) ARE ALSO
;AVAILABLE VIA GETTAB TABLE 44
V	(APD,N,,VERSTS);	;(R0) APRID
V	(ACN,N,,APRSTS);	;(R1) CONI APR,
V	(PIC,N,,PISTS);		;(R2) CONI PI,
V	(PGD,N,,UPTSTS);	;(R3) DATAI PAG,
LENSTS==:<UPTSTS-VERSTS>B26
V	(PGC,N,,EPTSTS);	;(R4) CONI PAG,
V	(UP0,N,,,4);		;(R5-R10) UPT LOCS 424-427
V	(ERA,N,,ERASTS)		;(R11) RDERA
V	(RHC,N,,,8);		;(R12-R21) CONI RH20, FOR ALL RH20'S
V	(DTC,N,,,4);		;(R22-R25) CONI DTEN,
V	(EP0,N,,,40);		;(R26-R65) EPT LOCATIONS 0-37
V	(EP1,N,,,40);		;(R66-R125) EPT LOCATIONS 140-177
V	(UP1,N,,,4);		;(R126-R131) UPT LOCS 500-503
V	(6,N,,,5);		;(R132-R136) AC BLOCK 6 REGS 0-3 AND 12
V	(7,N,,,3);		;(R137-R141) AC BLOCK 7 REGS 0 THROUGH 2
IFN M.KL10,<
;IN ADDITION TO BEING A PART OF THE CPU STATUS BLOCK SUBTABLE, THE
;SBDIAG BLOCK IS A CDB SUBTABLE IN ITS OWN RIGHT.  POINTER IS .CPSDP.
V	(SBD,N,,,50)		;(R142-R211) SBDIAG DATA
	XPC	.CPSDL,<.-.C0SBD>,N ;SBDIAG SUBTABLE LENGTH
>;END IFN M.KL10
	XPC	.CPCSL,<.-.C0APD>,N ;SUB-TABLE LENGTH
;DEVICE STATUS BLOCK ENTRY FOR DEVICES ON THIS CPU.
; THIS IS A CDB SUBTABLE.  THE ORDER OF THESE ENTRIES MUST
; EXACTLY MATCH THE ORDER OF THE INSTRUCTIONS IN DVSXCT
; THAT FILL THE ENTRIES.

V	(DVS,N,,,0)
IFN M.KL10,<
V	(TMR,N,Y)
V	(MTR,N,Y)
V	(TTY,N,Y)
V	(PRA,N,Y)
V	(PPA,N,Y)
V	(DLS,N,Y)
V	(DAC,N,Y)
V	(DAS,N,Y)
V	(CRA,N,Y)
V	(LPT,N,Y)
V	(PLA,N,Y)
V	(TMS,N,Y)
V	(TMC,N,Y)
V	(DX1,N,Y)
V	(DSK,N,Y)
V	(FH2,N,Y)
V	(FSD,N,Y)
V	(FS2,N,Y)
V	(FS3,N,Y)
V	(DPC,N,Y)
V	(DP2,N,Y)
V	(DP3,N,Y)
V	(DP4,N,Y)
V	(2DS,N,Y)
V	(2DC,N,Y)
V	(DLC,N,Y)
V	(DLB,N,Y)
V	(DC2,N,Y)
V	(DB2,N,Y)
V	(CDP,N,Y)
V	(CRB,N,Y)
V	(LPB,N,Y)
V	(LPC,N,Y)
V	(PLB,N,Y)
V	(DAK,N,Y)
V	(DDK,N,Y)
V	(DH2,N,Y)
V	(DFS,N,Y)
V	(DS2,N,Y)
V	(DS3,N,Y)
V	(DDP,N,Y)
V	(DD2,N,Y)
V	(DD3,N,Y)
V	(DD4,N,Y)
V	(DDC,N,Y)
V	(DDB,N,Y)
V	(D2C,N,Y)
V	(D2B,N,Y)
V	(IVI,N,Y,,10)
>;END IFN M.KL10
IFN M.KS10,<
V	(TMR,N,Y)
V	(TMB,N,Y,,2)
V	(UB1,N,Y)
V	(UB3,N,Y)
V	(RH1,N,Y,,2)
V	(RH3,N,Y,,2)
V	(LPT,N,Y,,2)
V	(CDR,N,Y)
V	(PRA,N,Y)
V	(PPA,N,Y)
V	(RXA,N,Y)
>;END IFN M.KS10

	XPC	.CPDVL,<.-.C0DVS>,N ;SUB-TABLE LENGTH

IFN	M.KL10&FTRSP,<
V	(BPV,N,Y,,<<BPATLN*4>>);KL10 BACKGROUND PERFORMANCE NUMBERS
			; EACH ENTRY IS 4 WORDS LONG
			;  0'1 := RDTIME TOTAL ELAPSED TIME
			;  2'3 := TOTAL PERF METER COUNT
> ;END IFN M.KL10&FTRSP


;***********************************************************************
;INSERT NEW SUB TABLES JUST ABOVE HERE - SO AT END OF VARIABLE TABLE
;INSERT NEW VARIABLES A FEW PAGES BACK - SO NEXT TO OTHER VARIABLES
;***********************************************************************
IFE N,<
XP .CPPVL,<<.-.C0VBG>B26>	;PUBLISHED CPU DEPENDANT VARIABLE LENGTH
				;SHIFTED LEFT 9 BITS FOR GETTAB TABLE ENTRIES
>
;UNPUBLISHED CPU DEPENDENT VARIABLES:
;PROTECTED JOB INFORMATION.  COPIED FROM JOB DATA AREA INTO MONITOR
; EACH TIME A JOB RUNS.
V	(ADR,N,Y,JOBADR);	;XWD PROTECTION, RELOCATION FOR CURRENT
			; JOB SAME AS JBTADR(JOB) AND AC R
V	(REL,N,Y);		;LH==0, RH CONTAINS CONTENTS OF PROTECTION REGISTER
			; LOW ORDER BITS==1777,IE THIS IS HIGHEST REL.
			; LOC IN CURRENT USER AREA (USED FOR ADDRESS
			; CHECKING)
V	(PC,N,Y,,2)	;;JOB PC WHEN SCHEDULER IS CALLED
XP USRPRT,JOBPRO
XP USRPR1,,USRPRT+1
XP USRHCU,USRPRT
XP USRPC,USRHCU+1
IFN FTMP,<IFE USRHCU&777770-USRPC&777770,<PRINTX ?USRHCU AND USRPC FALL IN THE SAME CACHE LINE (SEE PDLLEN IN S)>>
XP USRDDT,USRPC+2	;THIS DEPENDS ON JOBDDT-JOBPC=1
XP USRJDA,USRDDT+1
XP USRLO,USRJDA		;FIRST LOC CLEARED BY SETUSR ROUTINE
			; ON A CALL RESET. - ALSO CLEARS USRHCU
XP USRLO1,USRLO+1	;FIRST LOC+1
XP USRHI,USRJDA+17	;LAST LOC CLEARED BY SETUSR ROUTINE
V	(XTM,N)		;TIME OF LAST SWITCH FROM MONITOR CYCLE TO USER JOB
			; OR VICE VERSA IN (SECONDS*RTCSEC)
V	(LS2,N)		;ADDITIONAL LOST TIME,N, IN JIFFIES*RTCSEC, BEYOND LAST JIFFY
V	(NL2,N)		;ADDITIONAL NULL TIME,N, IN JIFFIES*RTCSEC, BEYOND LAST JIFFY
V	(OH2,N)		;ADDITIONAL OVERHEAD TIME,N, IN JIFFIES*RTCSEC,
			; BEYOND LAST JIFFY--SEE OHT ABOVE (53)
V	(TNT,N)		;TIME INTERVAL IN TICS SINCE LAST AT CLOCK LEVEL
V	(HTM,N)		;HUNG DEVICE TIME CHECK FOR HUNG IO
V	(SEC,N)		;NUMBER OF SECONDS LEFT BEFORE DOING
			; ONCE-A-MINUTE CODE ON THIS CPU. SEE CPUMIN
			; IN CLOCK1
IFN FTRTTRP,<
V	(RCU,N,N,,6)	;COUNT OF REAL TIME CONSO'S ON SKIP CHAIN
V	(RIT,N,Y,,6)	;REAL TIME INITIALIZATION TABLE
V	(DMI,N)		;REAL TIME DISMISS INSTRUCTION FOR CURRENT INTERRUPT
>
;SCHEDULER FLAGS:
V	(CKF,N,Y,CLKFLG);;NON-ZERO WHEN CLK INTERRUPT (PI7) REQUESTED
			; FOR ANY REASON ON THIS CPU.  THIS LOCATION
			; TAKES THE PLACE OF A HARDWARE INTERRUPT
			; FLAG ON PDP-6 AND KA10S.
V	(TMF,N,Y,TIMEF);;NON-ZERO WHEN APR CLOCK TICKED ON THIS CPU.
			; SET SO CLK INTERRUPT ROUTINES WILL KNOW
			; ANOTHER JIFFY HAS PASTED.  SET BY APRINT,
			; TESTED AND CLEARED BY CLKINT MODULE.
V	(SCF,N,Y);	;NON-ZERO AS A FLAG TO CLK ROUTINE TO FORCE
			; RESCHEDULING, ON THIS CPU, EVEN THOUGH
			; ITS CURRENT JOB IS IN EXEC MODE.  CAN HAPPEN
			; ON MONITOR DETECTED ERRORS.

V	(CHT,N);	;CLOCK HAS TICKED, START QUEUED I/O.

V	(RTF,N,N,SCDRTF); ;NON-ZERO ON REAL TIME RESCHEDULE REQUIRED
			; REALLY A SYSTEM VARIABLE
V	(ISF,N,Y)	;NON-ZERO IF IN THE SCHEDULAR
			; WHEN IN COMCON CONTAINS THE STACK POINTER
			; JUST BEFORE COMMAND DISPATCH

V	(SUD,N);	;SCAN USED FOR THIS SCHEDULING SCAN
IFN FTHPQ!FTNSCHED,<
V	(HQU,N,Y)	;NON-ZERO IF CURRENT JOB ON THIS CPU DID A HPQ UUO
			; TO FORCE RESCHEDULING TO THE NEW HPQ
>
V	(PLT,N);	;POTENTIALLY LOST (WASTED) CLOCK TICK ON
			; THIS CPU IF NON-ZERO.
			;NON-ZERO WHEN SCHEDULER SEES THAT THERE ARE
			; JOBS WHICH ARE POTENTIALLY RUNABLE ON THIS CPU
			; BUT HAS TO RUN NULL JOB.
			;0 WHEN IT FINDS A REAL JOB TO RUN OR
			; NULL JOB IS ONLY JOB WHICH WANTS TO RUN ON THIS CPU.
			; .CPLST INCREMENTED EVERY JIFFY IF THIS FLAG
			; IS NON-ZERO AND PREVIOUS JOB WAS NULL JOB.
IFN FTKL10,<
IFN FTMP,<
V	(CLF,N);	;POTENTIAL CACHE LOST TIME FLAG (SEE .CPCLN)
V	(CL2,N);	;LOW ORDER CACHE LOST TIME IN RTUPS UNITS
V	(SDA,N);	;NUMBER OF TIMES CACHE WAS SWEPT BECAUSE OF
			; CORE DEALLOCATION
>; IFN FTMP
V	(CSR,N,Y);	;CACHE SWEEP REQUEST FLAG FOR THISCPU
			; IF IT IS .GE. CURRENT SWEEP SERIAL NUMBER FOR
			; THIS CPU,N, MUST SWEEP AT CH7 LEVEL FOR ANOTHER CPU
V	(CSW,N,Y)	;SWEEP SERIAL NUMBER TO WAIT FOR
>;END IFN FTKL10&FTMP
V	(AEF,N,Y);	;APR ERROR FLAG ON THIS CPU.  CONTAINS APR
			; CONI IF NULL JOB WAS CURRENT JOB ON THIS
			; CPU WHEN APR ERROR OCCURRED SO COULD NOT
			; STORE IN JOB DATA AREA.
			; LEFT HALF USED FOR MEMORY PARITY CONTROL
			; TO REQUEST PARITY SWEEPS AND PRINTING. SEE .CPMPS FOR
			; BIT DEFINITIONS.
V	(SAC,N);	;SAVED COPY OF .CPAEF
V	(APC,N,Y,,2);	;APR ERROR PC ON THIS CPU WHEN ERROR WHILE
			; NULL JOB WAS CURRENT JOB ON THIS CPU.
V	(MDP,N,Y,,2);	;MEMORY PARITY ERROR DOUBLE WORD PC
V	(PPD,N,Y,,2);	;AR/ARX TRAP DOUBLE WORD PC
V	(NJE,N,Y);	;ERROR IN NULL JOB HAS OCCURRED IF NON-ZERO
V	(SFC,N);	;SCHEDULER FAIRNESS COUNT. COUNT OF THE NUMBER
			;OF SCANS OF THE PRIMARY SCAN TABLE WITHOUT GETTING
			;TO THE LOWER QUEUES IN THE TABLE.  IF THE COUNT
			;EXCEEDS THE MAXIMUM,N, THE SCAN USES THE SECONDARY TABLE

V	(SQF,N);	;NON-ZERO IF CURRENT JOB WAS TAKEN FROM SUBQUEUES
V	(APR,N,Y)	;CONI APR INTO THIS LOCATION TO READ
			; THE STATE OF MI PROG DIS SWITCH

IFN FTKL10,<
V	(IPI,N,Y);	;INTERVAL TIMER PI ASSIGNMENT ON KL10
V	(DTT,N,Y);	;MINUTES TILL NEXT SEND DATE/TIME TO -20F
>
;PROCESSOR DEPENDENT VARIABLES FOR APR INTERRUPTS

V	(CN1,N,Y);	;CONTAINS CONSO MASK FOR APR INTERRUPTS,
			; THE USER WANTS TO HANDLE HIMSELF.  MOVE TO
			; PDB IN FUTURE.
V	(DTO,N,Y);	;LAST DATAO OUT TO SET HARDWARE RELOCATION
			; AND PROTECTION FOR THIS CPU.
V	(SP,N,Y,,2);	;PLACE TO SAVE P ON APR INTERRUPT FOR THIS CPU.
V	(S17,N,Y,,2);	;PLACE TO SAVE AC 17 ON CLK INTERRUPT

;MEMORY PARITY ANALYSIS VARIABLES
V	(A00,N,,,17);		;FIRST WORD TO STORE AC0 ON
				; PAR SWEEP ON APR PI (USUALLY NOT
				; DONE EXCEPT FOR SERIOUS ERROR)
V	(A17,N);		;LAST WORD TO STORE AC17 ON
				; PAR SWEEP AT APR PI.
V	(LPP,N);		;LAST MEM PARITY PC - USED TO DETECT
				; PI DISMISS LOOPS. CLEARED AT END
				; OF PI 7 SWEEP OF MEMORY
V	(LSB,N,Y);		;LAST SEG (HI OR LOW) WHICH IS (WAS) BLTED
				; USED TO DETECT BAD PARITY DURING BLT
V	(LCI,N);		;TIME OF LAST PAR/NXM INTERRUPT CAUSED
				; BY A CHANNEL REFERENCE
V	(PIP,N);		;POINTER TO  REAL INTERRUPT PC
V	(PSP,N,Y);		;PARITY/NXM SWEEP IN PROGRESS ON THIS CPU
V	(CHE,N);		;CHANNEL ERROR REPORTING IN PROGRESS ON THIS CPU
V	(TCX,N);		;RESULTS OF DATAI PAG, ON ERROR TRAP

IFN M.KL10,<
V	(TCT,N,Y);		;TRIAD COUNTER FOR 60HZ LEAP JIFFIES
V	(PJB,N,Y);		;# OF JOB WHO OWNS PERFORMANCE METER
				; 0 IF FREE
V	(MJB,N,Y);		;MEASURED JOB (JOB ENABLE OF PERF. UUO)
				; -2 = NULL JOB, 0 = DON'T CARE
V	(MJ1,N,Y);		;JOB ENABLE CONDITION SET ONLY WHEN
				; METER IS RUNNING. (SEE KLSER)
V	(PMR,N,Y);		;NONZERO MEANS PERFORMANCE METER IS
				; RUNNING.
V	(PAE,N,Y);		;USED TO STORE PERFORMANCE ANALYSIS
				; ENABLES
V	(PRQ,N,Y);		;SEMAPHORE USED IN TESTING AND GIVING
				; METER AWAY
V	(APS,N,Y);		;NON ZERO MEANS ACCT + PERF METERS SHOULD BE KEPT IN SYNC
V	(MM0,N);		;"VIRTUAL PERF METER'S" HIGH ORDER MEM REF COUNT
V	(MM1,N);		;LOW ORDER
V	(BPC,N,Y);		;BACKGROUND PERF ANAL SAMPLE INTERVAL (TICKS)
V	(BPI,N,Y);		;B.P.A. SAVED PACTAB INDEX
V	(BPT,N,Y,,2);		;B.P.A. SAVED RDTIME AT START OF CURRENT SAMPLE
V	(TIM,N,Y);		;CLOCK INTERRUPT FLAG FOR KL10S
V	(ETM,N);		;SOSN DONE ON THIS LOCATION EVERY MINUTE TO
				; MAKE SURE CHUNKS DON'T STAY ALLOCATED FOREVER
				; IN THE CASE THAT DAEMON IS SICK, WRONG VERSION, ETC.
V	(EAD,N);		;LH=ADDRESS OF LAST KL ERROR CHUNK
				;RH=ADDRESS OF FIRST CHUNK
V	(KPB,N,N,,<<KPSLEN+3>/4>); ;KLINIK PARAMETER BUFFER
V	(20F,N);		;LH = FLAGS ABOUT RSX-20F FRONT END
				;RH = COUNT OF CHARACTERS CURRENTLY BEING OUTPUT
V	(20S,N,,,2)		;SPACE FOR INCOMING LINE SPEEDS
V	(20B,N,,,<<TTDMOS+3>/4>);;BUFFER FOR 16BIT DATA TO 20F
;LOCATIONS USED BY CPU HARDWARE ERROR RECOVERY
V	(PTH,N,Y);		;AR/ARX TRAP HAPPENED DURING PARITY SWEEP
V	(STE,N,Y);		;ERA CONTENTS ON SWEEP TRAP
V	(PTF,N,Y);		;COUNT OF PAGE TABLE PARITY TRAPS BETWEEN CLOCK
				;  TICKS--USED TO CRASH SYSTEM IF TO HIGH
				;  REINITIALIZED EVERY JIFFY
V	(CA1,N,,,20);		;POWER FAIL AC BLOCK SAVE AREA
				; ALSO AC BLOCK 1 ON A CRASH
V	(CA2,N,,,20);		;AC BLOCK 2
V	(CA3,N,,,20);		;AC BLOCK 3
V	(CA4,N,,,20);		;AC BLOCK 4
>;END IFN M.KL10
IFN M.KS10,<
V	(TCT,N,Y);		;TRIAD COUNTER FOR 60HZ LEAP JIFFIES
V	(TIM,N,Y);		;CLOCK INTERRUPT FLAG FOR KS10S
V	(PTH,N,Y);		;HARD PARITY TRAP HAPPENED DURING PARITY SWEEP
V	(PTF,N,Y);		;COUNT OF PAGE TABLE PARITY TRAPS BETWEEN CLOCK
				;  TICKS--USED TO CRASH SYSTEM IF TO HIGH
				;  REINITIALIZED EVERY JIFFY
V	(LMC,N);		;LEAP MILLISECOND COUNTER FOR 4.1 MHZ CLOCK RATE
V	(CA1,N,,,20);		;POWER FAIL AC BLOCK SAVE AREA
				; ALSO AC BLOCK 1 ON A CRASH
V	(CA2,N,,,20);		;AC BLOCK 2
V	(CA3,N,,,20);		;AC BLOCK 3
V	(CA4,N,,,20);		;AC BLOCK 4
>;END IFN M.KS10
V	(CTQ,N,Y,,2);	;SCNSER OUTPUT QUEUE HEADER FOR CTY ON THIS CPU
				;FOR KL10, IS HEADER FOR ALL RSX-20F LINES
V	(SWP,N,Y)	;NON-0 IF SWAP REQUEST TO BE CHECKED FOR AT CLOCK LEVEL
IFN FTMP,<
V	(QUE,N)		;QUEUE FOR IO REGS ON OTHER CPUS
			; EMPTIED INTO CPUDSQ ONCE A TICK
V	(QND,N)		;END OF QUEUE ABOVE
V	(SWD,N)		;FLAG FOR FILIO CACHE SWEEPS
V	(DRQ,N)		;DISKS ON CPU NEED RECUING
V	(TAP,N)		;0 IF NO TAPE IO WAITING FOR SWEEP
			;-1 IF TAPE IO WAITING, NEEDS SWEEP
			;0,,-1 IF TAPE WAITING, DSKTIC DID SWEEP
IFN FTKL10,<
V	(PIB,N);	;SAVE PI STATE FOR NBFOFF
>
V	(PIS,N);	;SAVE PI STATE FOR SYSPIN
V	(DPI,N);	;SAVE PI STATE FOR DEVPIN
V	(BTI,N);	;SAVE PI STATE FOR BTSOFF
>
V	(IUT,N);	;UPTIME A SECOND AGO
IFN FTNET,<
V	(NTF,N,Y);	;DEFINE THE ONE SOFTWARE INTERRUPT FLAG
>			; ON EACH CPU FOR NETSER TO USE
IFN FTEQDQ,<
QDBLEN==:23		;LENGTH OF QUESER DATABASE
V	(QTS,N,,,QDBLEN) ;QUESER VARIABLES
>
V	(CPG,N)		;RESULT OF DATAI PAG, DONE BY SVSETS WITH BITS
			;SET SO THAT DATAO WILL RESTORE CURRENT AC SET
V	(ACA,N)		;ADDRESS OF 20 WORD BLOCK IN WHICH SVSETS SAVED
			;THE CURRENT AC SET
V	(KPM,N);	;CONTAINS PM.KPM IF CPU HAS AN MCA25 INSTALLED
V	(JCH,N)		;JOB/CONTEXT HANDLE FOR JOB ON THIS CPU
IFN M.CTX,<
V	(CXJ,N)		;JOB OWNING CX ON THIS CPU
> ;END IFN M.CTX
IFN M.KL10,<
V	(CHN,N,,,10)	;ADDRESS OF CHANNEL DATA BLOCK FOR INTERNAL CHANNELS
>; END IFN M.KL10

IFN FTPATT,<
V	(PAT,N,,,10)	;PATCH SPACE
>
;END OF VARIABLES FOR CDBS.  ADD MORE HERE
.C'N'END==.
;BEGINNING OF PER-PROCESS PER-CPU MAPPINGS. THESE VIRTUAL ADDRESSES APPEAR
; IN SECTION 37 AND MUST BE LOCATED CORRESPONDING TO THEIR VIRTUAL ADDRESSES. ADD
; NEW MAPPINGS ABOVE THIS ADJUSTING THE LOC STATEMENTS APPROPRIATELY.
	LOC	<.+777>&777000-1000+UMAPS/1000
V	(UMA,N,,,<MXSECN+1>)	;MAPPING TO REFERENCE ALL USER SECTION MAPS
>;END OF CDB MACRO

IFN XPANDN,<LALL>
ZZZ==0
REPEAT M.CPU,<
	LOC	<.+777>&777000
	CDB(\ZZZ)
IFE ZZZ,<
.CPLEN==.-.C0CDB		;LENGTH OF CDB FOR CPU 0
IFN <<.CPLEN+777>/1000>-<RHWEVM-^D2>,<PRINTX ?RHWEVM DOES NOT MATCH CDB SIZE>
>
ZZZ==ZZZ+1
>
.CPSOF==:^D36-^L<<.CPLEN+777>&777000>-1 ;INVALID IF CPU DATA BLOCK
				; IS MORE THAN TWO PAGES LONG
.CPVLN==.-.C0VBG		;LENGTH OF VARIABLE AREA
.C0EVA==:.C0CDB+.CPLEN		;END OF CPU 0 VARIABLE AREA
IFG <.C0END-.C0UMA>,<PRINTX ?CPU VARIABLES OVERLAP PER-PROCESS, PER-CPU MAPPINGS>

	$LIT			;ANY LITERALS IN CDB CAN GET CACHED IN HIGH SEG
	$ABS			;BACK TO ABS CODE
	LOC	<.+777>&777000
SYSBEG::			;START OF THE ONCE ONLY
				;OVERLAY CODE. IT OVERLAYS
				;VARIABLES AND CLOBBERS THE REAL
				;ONCE ONLY. IT IS IN TURN
				;ZEROED AFTER SYSINI IS MOVED
;NOW GENERATE REFERENCES FOR GETTAB TABLES 55 THRU 70
;WILL GENERATE A ZERO WORD FOR INDIRECT REFERENCES TO NON EXISTANT CDB'S
DEFINE CPUGTB(A,B)<
IFG <CPUN-A>,<XP ITMC'B'C,.CPPCL
	XP	ITMC'B'V,.CPPVL>
IFLE <CPUN-A>,<XP ITMC'B'C,0	;MAKE LENGTH 0 SO ERROR RETURN
	XP	ITMC'B'V,0	;MAKE LENGTH 0 SO ERROR RETURN
	.C'B'CDB::		;DEFINE ADR TO BE A WORD CONTAINING 0.
	.C'B'VBG::
>>
ZZ==0
REPEAT 6,<
	CPUGTB(ZZ,\ZZ)
ZZ==ZZ+1
>
IFLE <CPUN-5>,<EXP 0>		;GETTABS FOR NON-EXISTANT CDB'S GET THEIR DATA HERE
IFN FTNSCHED,<
;TABLES INDEXED BY CLASS NUMBER

CLSSTS::BLOCK	M.CLSN		;BITS IN LH, QUOTA (NUMBER FROM 0 TO 100) IN RH

CLSQTA::BLOCK	M.CLSN		;COMPUTED QUOTA IN JIFFIES, FIGURED OUT
				;FROM CLSSTS, RECOMPUTED AT THE
				;BEGINNING OF EVERY SCHEDULING INTERVAL.
				;DECREMENTED WHENEVER A CLASS USES A JIFFY
				;OF RUNTIME.


CLSRTM::BLOCK	M.CLSN		;RUNTIME FOR CLASSES SINCE ANY CHANGE IN CLSSTS
				;MINUS ANY TIME LEFT OVER AFTER ALL QUOTAS
				;WERE SATISFIED WITHIN AN INTERVAL

CLSMXL==:<M.CLSN-1>B26		;MAXIMUM LENGTH OF PER CLASS TABLES FOR GETTAB
>;END IFN FTNSCHED
SUBTTL MONITOR TABLES WITH ONE ENTRY PER JOB

	JOBMAX==:JOBN-1		;MAXIMUM LEGAL JOB NUMBER
	JOBMXL==:<JOBMAX>B26	;HIGHEST JOB NUMBERSHIFTED LEFT 9 (FOR GETTAB UUO)
	MJOBN==:-JOBN		;NEGATIVE NUMBERS OF JOBS (COUNTING NULL JOB)
	JBTMAX==:JOBN+SEGN-1	;HIGHEST INDEX IN JBT TABLES
	MJBTMX==:-JBTMAX		;MINUS JBTMAX FOR AOBJN POINTER
	JBTMXL==:<JBTMAX>B26	;HIGHEST JBT ENTRY SHIFTED LEFT 9 (FOR GETTAB UUO)
JBTSTS::BLOCK	JOBN+SEGN	;JOB AND HIGH SEG STATUS WORD
				;THIS IS DOCEMENTED AS GETTAB TABLE NUMBER 0
				;LH==STATUS BITS (SEE S.MAC FOR DESCRIPTION)
				;BITS 18-23=EXTENDED JOB STATUS BITS
	JBSSPR==^D9			;SIZE OF ACCES PRIV FOR HIGH SEG
	JBNSPR==^D17			;BYTE PTR. POS.
				;RH=IN CORE COUNT FOR HIGH SEGS

JBTST2::BLOCK	JOBN		;SECOND WORD OF JOB STATUS. USED BY SCHEDULER
				;  AND EVENT WAIT INFO

IFN M.KL10*<CPUN-1>,<;IF KL10 SYSTEM WITH MORE THAN ONE CPU
JBTST3::BLOCK	JOBN		;18-35 = CPU DATA BLOCK ADDR OF LAST
				; CPU JOB RAN ON.  CLEARED WHEN
				; JOB GIVES UP ALL PHYSICAL CORE, OR
				; DOES RUN, GET, ETC.

JBTCSN::BLOCK	JOBN		;36 BIT SWEEP SERIAL NUMBER, TAKEN FROM
				; CPU WHOSE CDB ADDRESS IS IN JBTST3
>;END IFN M.KL10*<CPUN-1>

IFN FTNSCHED,<
JBTSCD::BLOCK	JOBN		;SCHEDULER WORD CONTAINING EACH JOB'S
				;CLASS AND TYPE.
>;END IFN FTNSCHED

JBTSPS::IFG	<CPUN-1>,<	;MULTI-PROCESSING SYSTEM?
	BLOCK	JOBN		;SECOND PROCESSOR STATUS BITS BOTH HALVES (PREFIX=.SP)
				;RH=GETTAB BITS FOR 6 CPU'S.
				;LH=UNPUBLISHED BITS
				;SEE S.MAC FOR DEFINITIONS.
	XP	ITMSPS,JOBMXL	;LH SYMBOL FOR GETTAB UUO
>
	IFLE	<CPUN-1>,<	;SINGLE-PROCESSOR SYSTEM?
	0			;DUMMY ENTRY
	XP	ITMSPS,0	;DON'T ALLOW ANY REFERENCE IF NOT 2 CPU SYSTEM
>

JBTADR::BLOCK	JOBN+SEGN	;JOB AND HIGH SEG CORE ASSIGNMENT
				; LH==PROTECTION (LENGTH-1)
				; RH==RELOCATION (ABSOLUTE LOCATION IN CORE)
				; DURING BLT OF LOW OR HIGH SEG, THIS WORD
				; CONTAINS THE SOURCE RELOCATION
				;THIS IS DOCUMENTED AS GETTAB TABLE NUMBER 1
	JBTAD1==:JBTADR+1	;ADDRESS OF JOB 1 (USED BY SYSMAK)
	JBTDAT==:JBTADR		;RH==ADDRESS OF JOB DATA AREA
				;SAME AS JBTADR (R==R)
JBTSG2::BLOCK	JOBN		;CURRENTLY 37B4=SECTION NUMBER FOR HIGH SEG USER
JBTSWI::
JBTSGN::IFG	SEGN, <
	BLOCK	JOBN+SEGN	;RH=SEGMENT NUMBER OF HIGH SEGMENT THIS JOB
				; IS USING IN CORE OR ON DISK
				; 0 MEANS JOB DOES NOT HAVE HIGH SEG
				;LH=USER DEPENDENT HIGH SEG STATUS BITS (SEE S.MAC)
				;THIS IS DOCUMENTED AS GETTAB TABLE NUMBER 14
				;INDEXED BY HIGH SEGMENT NUMBER THE TABLE (JBTSWI)
				; CONTAINS THE LOW SEGMENT NUMBER OF THE SEGMENT
				; WHICH THIS HIGH SEGMENT IS BEING SWAPPED IN FOR
>
	IFE	SEGN, <
	0			;SINGLE-ENTRY NULL JBTSGN TABLE....
	XP	ITMSGN,JOBMXL	;LH SYMBOL FOR GETTAB UUO SO THAT JBTSGN IS
				; UNDEFINED, I.E., MAKE INDEXING BY J BE 0, BUT
				; ALLOW REFERENCES UP TO JOBMXL.
>


	IFG	DSKN, <		;DISK SYSTEM ?
JBTPPN::			;HIGH SEGMENT DIRECTORY NAME IF , 0 IF DTA,MTA
JBTPPN::BLOCK	JOBN+SEGN	;XWD PROJECT NUMBER, PROGRAMMER NUMBER
				;THIS IS DOCUMENTED AT GETTAB TABLE NUMBER 2
>
	IFG	SEGN, <		;REENTRANT MONITOR CAPABILITY?
JBTDEV==:.-JOBN		;JUST HIGH HALF (NO ENTRIES FOR LOW SEGS)
	BLOCK	SEGN		;HIGH SEGMENT PHYSICAL DEVICE NAME
			; OR FILE STRUCTURE NUMBER(DSKA,DSKB,DTAN,MTAN)
>
IFE	SEGN,<
JBTDEV==:JBTSGN-JOBN		;USE THE DUMMY ENTRY IN JBTSGN
	XP	ITMDEV,JBTMXL	;LH SYMBOL FOR GETTAB UUO SO THAT JBTDEV IS
				;UNDEFINED, IE. MAKE INDEXING BYITEM BE 0
>

IFN SEGN,<			;
JBTIDT==:.-JOBN			;MAKE FIRST HIGHSEG NUMBER POINT TO TABLE
	BLOCK	SEGN		;STORAGE FOR TIME SEGMENT LAST WENT DORMANT/IDLE
>				;
JBTVIR::BLOCK	JOBN		;JOB'S VIRTUAL SIZE (SEE LOVSIZ/HIVSIZ)
SWPLST::BLOCK	JOBN+SEGN
SW2LST::BLOCK	JOBN+SEGN	;PARALLEL SWPLST TABLE FOR USE BY FILSER
SW3LST::BLOCK	JOBN+SEGN	;PARALLEL SWPLST TABLE FOR ADDITIONAL INFO
				; LH=C(SWPOUT) FOR SCHED1, RH=JOB NUMBER

	IFG	SYS50N, <	;SWAPPING SYSTEM ?
JBTSWP::BLOCK	JOBN+SEGN	; DISK ADDRESS WHILE SWAPPED OUT
				;BIT 0=1 IF SEGMENT IS FRAGMENTED
				;BITS 1-35 DISK ADDRESS IF NOT FRAGMENTED
				;FOR LEVEL D,
				;  BITS 2-4=INDEX OF UNIT IN SWPTAB (JBYSUN)
				;  BITS 5-17=1ST LOGICAL K ON UNIT (JBYLKN)
				;  BITS 18-35 CORE ADR OF FRAGMENT TABLE IF FRAGMENTED
JBTIMI::BLOCK	JOBN+SEGN	;IMAGE-IN SIZE (SEE IMGIN; SEE ALSO NZS?CN)
JBTIMO::BLOCK	JOBN+SEGN	;IMAGE-OUT SIZE (SEE IMGOUT)
JBTCHK::BLOCK	JOBN+SEGN	;CHECK SUM FOR SWAPPED OUT JOB DATA AREA OR
				; SAME AREA FOR HIGH SEG

>
JBTNAM::			;NAME OF HIGH SEGMENT (FILE IT WAS INITIALIZED FROM)
JBTPRG::BLOCK	JOBN+SEGN	;NAME OF FILE USED IN LAST R,RUN,GET, ETC
				; USED BY SYSTAT PROGRAM, AND AS DEFAULT FOR
				;  THESE COMMANDS

JBTWCH::BLOCK	JOBN		;BITS 1-5 = ENABLE BITS - SEE S.MAC
				;BITS 13-35 = TIME OF DAY IN JIFFIES USER
				;STARTED TO WAIT FOR RESPONSE FROM SYSTEM
				;REST UNUSED

IFN	FTRSP,<		;USER TTY INPUT RESPONSE TIMES
JBTRSP::BLOCK	JOBN		;UP TIME AT WHICH USER BEGAN TO WAIT
			; FOR SYSTEM RESPONSE.
			; SET WHEN USER JOB COMES OUT OF TTY INPUT WAIT
			; OR TYPES A COMMAND WHICH RUNS A JOB.
			;HIGH ORDER BITS SET TO 0 WHEN USER STARTS TO WAIT
			; SET TO ONE AS EACH OF SEVERAL TYPES OF RESPONSE
			; TERMINATION CONDITIONS OCCUR.
			; SEE S.MAC FOR BITS OF FORM JR.R??
			; SEE CPU DATA BLOCK (ACR, ADR, AIR, ARR, AXR)
			; FOR DESCRIPTION OF TYPES OF RESPONSES GATHERED
JBTRQT::BLOCK	JOBN	;'RUN QUEUE TIME' ACCUM. TIME (JIFFIES) THAT JOB
			; HAS SPENT IN ONE OF THE RUN QUEUES (INCLUDING SWAPPED)
>
IFNDEF	FTSPL,<FTSPL==:-DSKN>	;BY DEFAULT, COMES WITH DISKS

IFN FTSPL!FTDPRI,<
JBTSPL::BLOCK	JOBN		;LH=INPUT FILE NAME COUNTER
				;BITS 27-35 - WHAT DEVICES BEING SPOOLED
				; (SEE S.MAC FOR DEF'NS)
				;BITS 24-26 = DSK PRIORITY FOR JOB
				; (SEE JBXPRI IN COMMOD)
>
JBTLIM::BLOCK	JOBN		;TIME LIMIT, ETC. FOR JOB
				; (SEE S.MAC FOR LAYOUT)


JBTPDB::BLOCK	JOBN		;ADDRESS OF PDB

SPTTAB::
REPEAT CPUN,<
	EXP	NUPMPP>		;SPT ENTRIES FOR CURRENT CONTEXT
				; MUST IMMEDIATELY PRECEDE JBTUPM
JBTHSA::
JBTUPM::BLOCK	JOBN+SEGN	;ADDRESS OF THE UPMP
SPTLOW::
	DEFINE	HGHSPT(N),<	;SPT SLOTS FOR MAPPING HIGH HIGH SEGMENT
	EXP	.E'N'MAP/PAGSIZ
>
	ZZ==0
REPEAT CPUN,<
	HGHSPT	(\ZZ)		;GENERATE THEM
	ZZ==ZZ+1
>
SPTHGH::			;SPT SLOTS FOR SPYING ON HIGH HIGH SEGMENT
REPEAT M.CPU,< XWD 1,0 >	;GENERATE THEM
IFN FTXMON,<
SPTCOM::			;SPT SLOTS FOR SPYING ON COMMON DATA SECTIONS
REPEAT <HLGSNO-<(MS.FMD)>>,<
	XWD	1,0		;GENERATE THEM
>
> ;END OF IFN FTXMON

IFE CPUN-1,<
EPTDIF==:0
>
IFG CPUN-1,<
EPTDIF==:.E1MAP-.E0MAP
>
;PC TABLE
JBTPC::	BLOCK	JOBN		;USER MODE PC
JBTCLM::			;LH=CORE LIMIT (FORMERLY IN JBTLIM)
JBTDDB::BLOCK	JOBN		;RH=DDB JOB IS IN I/O WAIT FOR
JBTDAU::BLOCK	JOBN		;LH=UDB FOR WHICH JOB OWNS DA
				;RH=PPB FOR WHICH JOB OWNS AU

	IFG	SEGN, <		;REENTRANT MONITOR CAPABILITY?
JBTSHR==:.-JOBN		;JUST HIGH HALF (NO ENTRIES FOR LOW SEGS)
	BLOCK	SEGN		;HIGH SEGMENT TOTAL SHARER COUNT
>
IFE	SEGN,<
JBTSHR==:JBTSGN-JOBN		;USE THE DUMMY ENTRY IN JBTSGN
	XP	ITMSHR,JBTMXL	;LH SYMBOL FOR GETTAB UUO SO THAT JBTSHR IS
				;UNDEFINED, IE. MAKE INDEXING BYITEM BE 0
>

JBTIPC::			;RH=JCH WHOM WE WANT IPCF INTERLOCK  FOR
JBTDTC::BLOCK	JOBN		;LH=MASTER DECTAPE DDB JOB WANTS
IFN M.CTX,<
JBTCX::BLOCK	JOBN		;LH=JOB # WHOSE CX RESOURCE OWNED BY INDEX
				;RH=JOB # WHO OWNS CX RESOURCE OF INDEX
> ;END IFN M.CTX
IFN FTNET,<
JBTLOC::BLOCK	JOBN		;JOB LOCATION TABLE
				;JBTLOC+0 IS CENTRAL SITE STATION NUMBER
>	;IFN FTNET

IFN M.PSI,<
JBTPIA::BLOCK	JOBN		;LH HOLDS FLAGS (BITS 13-17 =0)
				;RH IS POINTER TO PROGRAM INTERRUPT
				;   TABLE.
>
IFE M.PSI,<
XP JBTPIA,777000		;CAUSE NXM IF REFERENCED
>
JBTJLT::BLOCK	JOBN		;JOB "LOGIN" TIME IN INTERNAL FORMAT

JBTAD2::BLOCK	JOBN		;BIT 0 FREE
				;BITS 1-21 DISK ADDR OF S0 MAP FOR JOB
				;BITS 22-35 PHYSICAL PAGE ZERO OF JOBS LOW SEG
JBTJRQ::BLOCK	JOBN		;LINKED LIST OF JOBS WAITING FOR REQUEUE
JBTPRV::BLOCK	JOBN		;PRIVILEGE BITS FOR JOB SET BY LOGIN

	IFG	SYS50N, <
;THE FOLLOWING ARE USED TO CREATE MXQUE
;THE MAXIMUM QUEUE SIZE, USED BY SWAPPING SCHEDULER (SCHED)
	FTDISK=:-DSKN		;DEFINE FEATURE SWITCH FTDISK, SINCE IT APPEARS
				; IN THE QUEUES MACRO (WHICH IS DEFINED IN S.MAC)
	XP	MXQUE,0

	DEFINE	X	<MXQUE==MXQUE+1;>
	QUEUES
	RWAITS
DEFINE	X	(A)

		<A'Z==MXQUE
		MXQUE==MXQUE+1;>
	CODES
		MXQUE==MXQUE+3	;LEAVE SPACE FOR PQ1,PQ2, AND CMMQ


	IFG	HPQN,<MXQUE=MXQUE+HPQN>
			;LEAVE SPACE FOR HIGH PRIORITY QUEUES

XP MXQUE2,<2*MXQUE>
	BLOCK	MXQUE2		;NUMBER OF QUEUES FOR SWAPPING SCHEDULER
QQQMXL==:<MXQUE-1>B26		;NUMBER QUEUES FOR GETTAB
JBTCQ::	BLOCK	JOBN		;ONE ENTRY PER JOB,
				; LH=PREVIOUS JOB, RH=NEXT JOB IN QUEUE
				; NEGATIVE MEANS THIS IS FIRST (LH) OR LAST (RH)
				; JOB IN QUEUE
JBCQM1==:JBTCQ-1		;
JBCQP1==:JBTCQ+1
NCNULQ==:NULZ+MXQUE		;NUMBER OF NULQ IN NO-CORE HEADER
JBCQMN==:JBTCQ-NCNULQ		;NUL QUEUE HEADER
JBCQOH==:JBTCQ-MXQUE		;WHAT TO INDEX TO GET SWAPPED OUT QUEUE HEADER
IFN FTNSCHED,<
	BLOCK	2*M.CLSN	;HEADER FOR PQ2 SUBQUEUES
JBTCSQ::BLOCK	JOBN		;SAME AS JBTCQ FOR SUBQUEUES
	JBCSOH==:JBTCSQ-M.CLSN	;SWAPPED OUT SUB-QUE HEADER
>;END OF IFN FTNSCHED
JBTHSQ::BLOCK	1		;HEADER FOR JOBS WAITING FOR A HIGH SEG
JBTBBQ::BLOCK	1		;HEADER FOR BB JUST INPUT QUEUE
JBTJIQ::BLOCK	1		;HEADER FOR PQ2 JUST INPUT QUEUE
JBTJIL::BLOCK	JOBN		;LIST OF PQ2 JOBS JUST INPUT
	HSQ==:JBTJIL-JBTHSQ
	BBQ==:JBTJIL-JBTBBQ	;OFFSET FOR JBTBBQ
	MBBQ==:-BBQ		;NEGATIVE OFFSET
	JIQ==:JBTJIL-JBTJIQ	;OFFSET FOR JBTJIQ

JBTDIH::BLOCK	1		;HEADER FOR QUEUE OF DORMANT/IDLE HISEGS
JBTOBQ::BLOCK	1		;HEADER FOR BB OUTPUT SCAN LIST
JBTOLQ::BLOCK	1		;HEADER FOR PQ2 OUTPUT SCAN LIST
JBTOLS::BLOCK	JOBN		;LIST OF PQ2 IN ORDER TO BE SCANNED FOR OUTPUT
	BLOCK	SEGN		;ALSO, PUT QUEUE OF IDLE/DORMANT SEGMENTS HERE
JBTDIQ==:JBTOLS		;GIVE IT A DIFFERENT NAME
	DISQ==:JBTDIQ-JBTDIH	;DORMANT/IDLE QUEUE HEAD
	OBQ==:JBTOLS-JBTOBQ	;OFFSET FOR JBTOBQ
	MOBQ==:-OBQ
	OLQ==:JBTOLS-JBTOLQ	;OFFSET FOR JBTOLQ
>;END OF IFG SYS50N
;DATA STRUCTURE CLEARED ON SYSTEM STARTUP AND ON 143 RESTART


;TTYTAB IS A TABLE OF CONTROLLING (ATTACHED) TTY'S FOR EACH JOB,
;INDEXED BY JOB NUMBER. IF C(TTYTAB)=0 THEN THERE IS NO SUCH JOB.
;OTHERWISE, RH(TTYTAB(N)) IS CONTROLLING DDB FOR JOB N.

;THERE IS ALWAYS A TTY DDB FOR EVERY JOB, EVEN THOUGH NO TTY
; NEED BE ATTACHED.  THUS UUOS LOOK THROUGH TTYTAB(N) FOR A DDB,
; SINCE UUO'S COME FROM JOBS.  COMMANDS LOOK THROUGH LINTAB(LINENUMBER)
; TO THE LDB, SINCE COMMANDS COME FROM TTY'S (LINES).
; IF THE JOB IS DETACHED, THE LINKS FROM LDB TO DDB AND VICE VERSA
; ARE ZEROED (RH OF DDBLDB AND LDBDDB).
TTYTAB::BLOCK	JOBN

PTYTAB::BLOCK	PTYN		;ADDRESSES OF THE DDBS OF
				;DEVICES PTYN (NOT TTYN LINKED BY PTY)

TTYDDL::BLOCK	1		;DIALLER INTERLOCK
TTYDDA::BLOCK	1		;TTY DIALLER DATA ADDRESS, 4 WORD BLOCK
DSDUNI::BLOCK	1		;TTY NUMBER USING DIALLER CODE


XPNMSZ==<JOBN/^D32>+1		;SIZE OF BIT MAP
XPNMAP::BLOCK	XPNMSZ		;BIT MAP OF EXPANDING JOBS
XP XPNMPT,-XPNMSZ		;FOR MAKING AOBJN POINTER
SUBTTL	SYSTEM WIDE VARIABLES

;SYSTEM WIDE VARIABLES:
; CLEARED AT SYSTEM STARTUP

;GETTAB FOR SYSTEM WIDE VARIABLES (AS OPPOSED TO PER CPU DATA)
; GETTAB TABLE NO(RH) IS .GTSYS=51


SYSTBL::		;GETTAB TABLE NO. 51.  ( .GTSYS = 51
SYSERR::0		;(0) TOTAL NUMBER OF HARDWARE AND SOFTWARE ERRORS
			; DETECTED BY THE MONITOR AND ENTERED IN DAEMON
			; ERROR LOG FILE INCLUDING DAEMON ERRORS.
			; INCLUDES HARD AND SOFT ERRORS
			; HARD ERROR WITH 80 RETRIES ONLY COUNTS AS 1 ERROR IN SYSERR.
CMNOTF::0		;(1) NUMBER OF TIMES SCNSER WAS CALLED TO
			; FIND A COMMAND BECAUSE COMCNT WAS
			; NON-ZERO AND NO COMMAND WAS FOUND
DELCNT::0		; (2) DISABLED ERROR LOGGING COUNT
			; INCREMENT INSTEAD OF SYSERR IF USER HAS DISABLED
			; ERROR LOGGING IN OPEN UUO
%SYSPC::0		;(3) FULLWORD PC OF LAST STOPCODE
%SYNDS::0		;(4) NUMBER OF DEBUG STOPCD'S.
%SYNJS::0		;(5) NUMBER OF STOPCD'S WHICH CAUSED A JOB TO BE
			;    STOPED.
COMTOT::0		;(6) NUMBER OF COMMANDS PROCESSED
			; (DELAYED COMMANDS ARE COUNTED ONCE WHEN PROCESSED)

%SYSJN::0		;(7)JOB# OF JOB ON LAST STOPCD
%SYSTN::0		;(10)TTY NAME FOR LAST STOPCD
%SYSPN::0		;(11)PROGRAM NAME FOR LAST STOPCD
%SYSUU::0		;(12)UUO ON LAST STOPCD
%SYSUP::0		;(13)USER'S PC ON LAST STOPCD
%SYSPP::0		;(14)USER'S PPN ON LAST STOPCD
%SYSCD::0		;(15)NAME OF LAST STOPCODE
%SYNCS::0		;(16)TOTAL NUMBER OF CPU STOPCODES
%SYNIS::0		;(17)NUMBER OF NODUMP STOPCDS (BUGINFS)
%SYSTY::0		;(20)TYPE OF LAST STOPCODE
%SYSDT::0		;(21)UDT OF LAST STOPCODE
%SYSCP::-1		;(22)CPU NUMBER OF LAST STOPCD
XP SYSMXL,<<.-SYSTBL-1>B26>	;MAX. ENTRY
;UNPUBLISHED SYSTEM VARIABLES:

;OTHER SYSTEM DATA STORAGE


COMCNT::0			;NUMBER OF COMMANDS TYPED-IN BUT NOT DECODED
				;SET BY SCNSER, DECREMENTED BY COMCON
IFN FTMP,<
COMJOB::0			;JOB NUMBER OF JOB CURRENTLY EXECUTING
				; A COMMAND USED TO AVOID JOBSTS UUO RACE
>
NFCNT::	0			;COUNT OF TIMES COMCNT NON-ZERO,
				;BUT NO WAITING COMMANDS
HNGMIN::0			;DO ONCE PER MINUTE FUNCTIONS WHEN THIS
				;FLAG COUNTS NEGATIVE
				; SCHEDULER SCANS ALL JOBS EVERY
				; MINUTE TO SEE IF QJOB HAS BEEN COUNTED
				; DOWN TOO FAR.  MORE LIKELY IN DUAL CPU SYS.

CHKCNT::0			;NO. OF CALLS TO CHKTAL TO CHECK CORE
				; BEFORE ACTUALLY DOING THE OVERHEAD.
				; RESET TO M.CMCT WHEN COUNTS TO 0.


DATREM::0			;LAST REMAINDER IN UPDATING "DATE" (SMITHSONIAN DATE)

SCDTIM::0			;DECREMENTED EVERY JIFFY, END OF MEDIUM
				;TERM SCHED INTERVAL WHEN THIS REACHES ZERO.
;STORAGE FOR VARIOUS CORE ALLOCATION FUNCTIONS AND OTHER NON-SWAPPING DATA
;CORE ALLOCATION DATA NOT AVAILABLE VIA GETTAB

;CALCULATE MOD(CORBLK,CTNBPW)

	XP	CORBLK,<^D256*^D1024>/PAGSIZ	;NUMBER OF BYTES IN CORTAB
	XP	COR256,CORBLK	;NUMBER OF PAGES (K) IN 256K

IFN M.KL10,<
	XP CORBLK,<^D16*CORBLK>	;22 BIT PHYSICAL ADDRESSES (4 MW)
>
IFN M.KS10,<
	XP CORBLK,<4*CORBLK>	;20 BIT PHYSICAL ADDRESSES (1MW)
;	XP CORBLK,<2*CORBLK>	;19 BITS IS ALL THE MEMORY WE SELL (512K)

>

CORTAB::BLOCK	0
CTBMXL==:<.-CORTAB-1>B26		;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9

HOLES::	0			;SIZE OF THE LOWEST HOLE IN MEMORY

IFN FTLOCK,<
LOCK::	0			;JOB#,,HIGH SEGMENT# OR
				;0,,JOB# IF NO HIGH SEGMENT
				;OF JOB CURRENTLY BEING LOCKED IN CORE

LOKREL::0			;DESIRED PROTECTION,,RELOCATION
				;FOR JOB CURRENTLY BEING LOCKED
LASLOK::0			;JOB # OF LAST JOB LOCKED

IFN SYS50N,<
HOLEF1::0			;ADDRESS OF THE BOTTOM OF THE LARGEST CONTIGIOUS HOLE
				;THAT CAN BE MADE IN CORE IF EVERYTHING
				;SWAPPABLE IS SWAPPED
				;(INITIALIZED TO SYSSIZ ON 143 RESTART)

IFN LOKN,<
HOLTOP::0			;ADDRESS+1 OF THE TOP OF THE ABOVE HOLE
				;(INITIALIZED TO MEMSIZ ON 143 RESTART)
>
IFE LOKN,<HOLTOP==:MAXMAX>
>
>

MOFLPG::0			;FLAG FOR SETTING MEMORY ON OR OFF LINE
LMPAG::0			;LAST PAGE IN MONITOR'S PAGTAB CHAIN

DOORBL::0			;SYSTEM DOORBELL
IFN FTKL10&FTMP,<
SAVCTL::0			;VALUE OF CORTAL WHEN MM RESOURCE WAS OBTAINED
>
ONCHDR::0			;HEAD OF ONCE-ONLY LIST
IFN FTXMON,<
NZSFCU::0			;HEAD OF NON-ZERO SECTION FREE CORE LIST
NZSFC7::0			;HEAD OF SECTION-7 FREE CORE LIST
>
IFE FTXMON,<
DNCHDR::0			;HEAD OF DECNET-CONTEXT CORE
>
	$HIGH
NZSFCH::
	400000,,ONCHDR		;SECTION ZERO IS ONCE-ONLY CORE
IFN FTXMON,<
	Z			;NO SECTION-1
	Z			;NO SECTION-2
	400000,,NZSFCU		;POINTER TO UNCACHED (SECTION 3) LIST
	Z			;NO SECTION-4
	Z			;NO SECTION-5
	Z			;NO SECTION-6
	400000,,NZSFC7		;POINTER TO SECTION 7 (SWAP SAT) LIST
>
IFE FTXMON,<
	400000,,ONCHDR		;REGULAR-CONTEXT HEADER
	400000,,DNCHDR		;DECNET-CONTEXT HEADER
>
	NZSFCL==:.-NZSFCH
	$ABS
NZSFCE::			;TAIL POINTERS FOR NZS FREE CORE
	BLOCK	NZSFCL		;ACTUALLY FILLED IN BY SYSINI
;DATA LOCATIONS PRESENT ONLY IN SWAPPING SYSTEMS

	IFG	SYS50N, <	;SWAPPING SYSTEM ?

SWPTBL::!			;FIRST LOCATION OF MONITOR DATA STORAGE
				; RETURNED BY GETTAB UUO (THESE LOCATIONS
				; PRESENT ONLY IN SWAP SYSTEMS)
				; OCTAL NUMBERS IN () CORRESPOND TO GETTAB ARG
				;THIS IS DOCUMENTED AS GETTAB TABLE NUMBER 13
BIGHOL::0			;(0) CURRENT BIGGEST HOLE IN CORE (1K BLOCKS)
FINISH::0			;(1) IF +, THEN JOB NUMBER OF JOB BEING SWAPPED IN,
				;IF -, THEN JOB NUMBER OF JOB BEING SWAPPED OUT
FORCE::	0			;(2) JOB NUMBER BEING FORCED TO SWAP OUT
FIT::	0			;(3) JOB NUMBER WAITING TO BE FITTED INTO CORE
VIRTAL::0			;(4) NUMBER OF FREE 1K BLOCKS OF SWAPPING SPACE LEFT
				; (COUNTING DORMANT SEGMENTS AS IF FREE).
				; PRINTED WITH CORE COMMAND (NO ARG) OR ERROR
				; USUALLY THE SAME AS THE AMOUNT OF VIRTUAL CORE
				; LEFT IN SYSTEM, EXCEPT WHILE R,RUN,KJOB,GET
				; COMMAND ARE WAITING TO BE SWAPPED IN, BECAUSE
				; THE OLD DISK SPACE HAS NOT BEEN RETURNED YET,
				; BUT VIRTUAL CORE IS ONLY 140 WORDS FOR SWAPIN
SWPERC::0			;(5) LH= NUMBER OF SWAPPER READ OR WRITE FAILURES
				; RH= ERROR BITS (BITS 18-23) + NUMBER OF K OF
				; IOCHNX=IO CHANNEL SWAP NON-EX MEM - BIT 23
				; IOCHMP=IO CHANNEL SWAP OUT MEMORY PARITY - BIT 22
				; BITS 18-22 = IOIMPM (SOFTWARE CHECKSUM),
				; IODERR, IODTER, IOBKTL
				; DISCARDED SWAPPING SPACE
SWAPIN::0			;(6) IF THE SYSTEM HAS FTPDBS TURNED ON,
				;     THIS WORD IS -1 WHEN A SWAPIN IS
				;     IN PROGRESS AND ZERO WHEN A SWAP OUT
				;     IS IN PROGRESS. IF FINISH IS ZERO
				;     THEN NO SWAP IS IN PROGRESS. IF FTPDBS
				;     IS OFF THIS WORD IS ALWAYS ZERO.



				;INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
				; TO USER PROGS IN SWAPPING SYSTEMS
SWPEUJ::0			;(7)LH=J FOR JOB OR SEGMENT WHICH GOT A SWAP
				; READ/WRITE ERROR, RH=UNIT THAT THE
				; SWAPPING I/O WHICH RESULTED IN THE ERROR
				; WAS DONE TO
SWPMXL==:<.-SWPTBL-1>B26	;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9
;MORE SWAPPING SYSTEM LOCATIONS (NOT RETURNED BY GETTAB)

MAXJBN::0			;NUMBER OF JOB TO SWAP OUT
SUMCOR::0			;TEMPORARY STORAGE CELL USED BY SWAPPER FOR SUM OF
				; CORE NEEDED FOR SWAP IN
FITLOW::0			;NUMBER OF JOB BEING FIT (NEVER HI-SEG)
SWPIN::	0			;JOB NUMBER BEING SWAPPED IN IF IT HAS A HIGH SEG
SWPOUT::0			;JOB NUMBER BEING SWAPPED OUT IF IT HAS A HIGH SEG
				; (USED TO REMEMBER THE JOB NUMBER DURING HIGH SEG SWAP)



IFN FTRSP,<
SWPNU2::0			;JIFFY REMAINDER FOR SWAP NULL TIME
SWPLS2::0			;JIFFY REMAINDER FOR SWAP LOST TIME
SWPPLT::0			;POTENTIAL LOST TIME FLAG FOR SWAPPER
				;TO TELL CLOCK1 TO COUNT SOME LOST TIME
				;(HAVE JOB TO SWAP IN BUT SWAPPER IDLE)
SWPNUF::0			;NULL CYCLE FOR SWAPPER (AGAIN, SO CLOCK1
				;CAN COUNT NULL TIME FOR SWAPPER)
>;END IFN FTRSP

IFN FTNSCHED,<
SCDSTS::0			;TIME OF LAST SETTING OF PRIMARY PERCENTAGES
CNTSTS::0			;COUNT OF CPU CLASSES WITH NON-ZERO QUOTA
TOTSTS::0			;TOTAL OF ALL SUBCLASS PERCENTAGES
				; (MUST BE 100 OR ZERO)
MAXQTA::0			;NUMBER OF HIGHEST CLASS WITH SECONDARY QUOTA
CNTQTA::0			;COUNT OF CLASSES WITH NON-ZERO SECONDARY QUOTA
TOTQTA::0			;TOTAL OF ALL SECONDARY SUBCLASS PERCENTAGES
				; NORMALLY 100%, BUT CAN BE ANY NON-NEGATIVE

>;END OF IFN FTNSCHED
>;END OF IFN SYS50N
	SYSEND==:.-1		;END OF CLEARED STORAGE ON RESTART
SUBTTL ONCE ONLY CODE TO CREATE DEVICE DATA BLOCKS

	LOC	SYSBEG		;PUT IN SYSTEM DATA AREA SO NOT TO TAKE
				; VALUABLE SPACE.  THIS AREA IS CLEARED
				; BY SYSINI AFTER IT HAS BEEN EXECUTED
IFN FTAUTC,<
	EXTERN	AUTCON
>

;CNTDB- ROUTINE TO INCREASE SIZE OF MONITOR FOR MULTIPLE DEVICE DATA BLOCKS
; BOTH DISK AND OTHER DEVICES (DTA,MTA,SCN,PTY)
; CALL:  JSP T1,CNTDB  (FROM LONG ONCE DIALOG)
;
;LINKDB- ROUTINE TO CREATE MULTIPLE DEVICE DATA BLOCKS (EXCEPT DISK)
; AND LINK THEM. THESE ARE STORED ON TOP OF ONCE ONLY CODE
;CALL:  JRST LINKDB (FROM LINKSR)
;BOTH ROUTINES UPDATE  SYSSIZ AS MORE DDB SPACE IS CONSUMED


LINKDB::!SETOM	DESONC		;PERMIT DESTRUCTION OF ONCE ONLY CODE
	SKIPA	T1,LINKSR##	;GET JSR PC OF CALLER OF LINKSR IN ONCE
CNTDB::!SETZM DESONC		;PREVENT DESTRUCTION OF ONCE ONLY CODE
				;SO THAT E.G. SAT TABLES MAY BE SCANNED
	HRRM	T1, LINKED	;STORE EXIT FROM THIS ROUTINE (ONCE ONLY CODE WILL
				; BE OVERLAYED BY MULTIPLE DEVICE DATA
				; BLOCK GENERATION)
IFN LEVDN,<;THIS CODE COMPUTES WHERE THE STR DATA BLOCKS ETC. MUST GO & HOW MUCH CORE THEY TAKE UP

	MOVEI	T1,SYSINI##	;BEGINNING OF SYSINI
	SKIPE	DESONC		;SKIP IF NOT DESTROYING ONCE
	CAMG	T1,SYSSIZ	;SKIP IF SYSINI WILL BE CLOBBERED
	JRST	NOMOVE		;NO, SYSINI IS SAFE, NO NEED TO MOVE IT
	HRRZ	T2,INIFRE	;DESTINATION=FIRST FREE LOCATION ABOVE MONITOR
	CAMGE	T2,HICORE##	;SKIP IF END OF MONITOR PAST DISK STUFF
	MOVE	T2,HICORE##	;NO, USE THAT INSTEAD
	MOVE	T1,T2
	HRLI	T1,SYSINI##	;SOURCE=BEGINNING OF SYSINI
	BLT	T1,ENDSYL##(T2)	;MOVE SYSINI TO SAFE PLACE
	SUBI	T2,SYSINI##	;T2=NEW SYSINI - OLD=CHANGE
	MOVEI	T3,SYSKON##-KONNXT## ;OFFSET FOR FIRST KDB IN SYSTEM
NXKUPA:!HLRZ	T3,KONNXT##(T3)	;STEP TO NEXT KDB IN SYSTEM
	JUMPE	T3,EFUPA	;GO IF AT END OF CHAIN
	ADDM	T2,KONUPA##(T3)	;PATCH LOCATION OF UPA ROUTINE (IN SYSINI)
	JRST	NXKUPA		;LOOP FOR NEXT KDB
EFUPA:!	HRRZ	T1,LINKED	;EXIT FROM RUN SUBROUTINE
	CAIL	T1,SYSINI##	;SKIP IF NOT TO SYSINI
	CAILE	T1,ENDSYS##
	JRST	NOMOVE
	ADDM	T2,LINKED	;NEW RETURN IN SYSINI

NOMOVE:!
	MOVE	T1,SYSSIZ	;SIZE OF MONITOR SO FAR (SYSMAK, EXEC DDT OR NOT)
	MOVE	T2,T1		;GET A COPY OF SYSSIZ FOR MAKING THE BLT PTR.
	HRL	T2,DDSTAR	;SETUP THE SOURCE ADR.
	ADD	T1,HICORE##	;NOW COMPUTE THE FINAL DESTINATION ADR. +1
	SUB	T1,DDSTAR
	MOVEM	T1,SYSSIZ
	SKIPE	DESONC		;DON'T BLT HIGH CORE STUFF IF NOT OK TO DESTROY ONCE
	BLT	T2,-1(T1)	;OVERLAY ONCE STUFF WITH STR DATA BLOCKS ETC.
	SKIPN	T1,QUESTR##	;GET PRESET STR NAME
	JRST	NOQSTR		;NONE SELECTED
	MOVE	T2,STRAOB##	;SEE IF IT EXISTS
	CAME	T1,@TABSTR##(T2)	;STRNAM IS FIRST WORD
	AOBJN	T2,.-1		;LOOK AT ALL STRS
	JUMPL	T2,QSTROK	;JUMP IF MATCH
NOQSTR:!MOVE	T1,TABST0##	;ADR. OF FASTEST FILE STRUCTURE
	MOVE	T1,STRNAM##(T1)	;FILE STRUCTURE NAME
	MOVEM	T1,QUESTR##	;STORE FOR QUEUEING CUSPS GETTAB UUO
>
QSTROK:!MOVSI	T1,INTNUM	;NEG NUMBER OF ENTRIES IN TABLE
	MOVEI	F,DEVLST-DEVSER	;MAKE DEVLST LOOK LIKE DEVSER IN A DDB
	SETZB	U,S		;START WITH NO PROTOTYPE DDB
				;S FOR FLAGS
LOOP:!	LDB	T2,PINTDB	;GET DDB ENTRY
	JUMPE	T2,NEXT		;0 MEANS NO DOB FOR DEVICE
	HLRZ	M,DEVNAM(T2)	;GET NEW GENERIC
	HLRZ	J,DEVNAM(U)	;GET PREVIOUS GENERIC
	CAME	T2,U		;IS NEW DDB BEING USED
	TRO	S,1		;YES - SET NO-COPY FLAG SO THAT
				;THIS DDB WILL BE USED ONCE
	CAME	M,J		;SAME DDB AS LAST ENTRY
	MOVEI	P3,0		;NO- RESET DEVICE NUMBER
IFN FTMP,<
	LDB	P2,PINTCH	;GET CHAN NUMBER
	EXCH	T2,F
	LDB	U,DEYCPF	;GET (1ST) CPU NUMBER
	CAIN	U,CPFBOO	;TTY (NET) QUEUED PROTOCOL
	TDZA	U,U		;YES, USE "CPU0" INTERLOCKS
	LSH	U,3
	ADDI	U,INTL0(P2)	;CPU *10+CHAN IS INTERLOCK OFFSET
	SKIPE	DESONC
	HRRM	U,DEVCPU(F)	;SAVE LOC OF INTERLOCK IN DDB
	EXCH	F,T2
>
	HRRZ	U,T2		;UPDATE PROTO PTR
	PUSHJ	P,DDBLNK	;GO LINK DDB'S,ETC. FOR ONE INTTAB ENTRY


NEXT:!	AOBJN	T1,.+1		;MOVE BY TWOS
	AOBJN	T1,LOOP		;ANY MORE DEVICES
	MOVEI	T1,0		;NO, FLAG END OF DEVICE DATA BLOCK CHAIN WITH 0 LINK
	SKIPE	DESONC		;OK TO DESTROY ONCE ?
	HRLM	T1,DEVSER(F)	;YES, STORE 0 IN CASE LAST DDB IS MULTIPLE
IFG	XTCN,<
	MOVEI	F,XKB0##	;GET LOC OF FIRST KDB
XKBLP:	MOVEI	T1,1B33		;WANT TO READ
	XCT	XTCCNO##(F)	;  DA28 FEATURE REG
	XCT	XTSDTI##(F)	;READ FEATURES
	JUMPE	T1,XKBNUL	;NOT THERE
	ANDI	T1,17		;WANT ONLY NUMBER OF UNITS
	MOVEI	T2,XKBUDB##(F)	;GET ADDRESS OF UDB TABLE
	MOVE	T3,SYSSIZ	;GET CURRENT CORE ALLOCATION
XUBLP:	SKIPN	DESONC		;WRITING OVER ONCE?
	JRST	XUBALC		;NO, ONLY ALLOCATE
	MOVEM	T3,0(T2)	;SAVE UDB ADDRESS
	HRL	T4,T3		;BUILD BLT WORD
	HRRI	T4,1(T3)	;  TO ZERO UDB
	SETZM	0(T3)
	BLT	T4,XUBSIZ##-1(T3)	;ZERO IT
	MOVEM	F,XUBKDB##(T3)	;LINK UDB TO KDB
	MOVE	T4,T2
	SUBI	T4,XKBUDB##(F)	;CALCULATE UNIT NUMBER
	MOVEM	T4,XUBUNO##(T3)	;STORE IN XUB
	ADDI	T4,2120		;CONVERT TO SIXBIT
	TRZN	T4,10
	LSH	T4,6
	LSH	T4,6		;POSITION IN WORD
	MOVEM	T4,XUBNAM##(T3)	;MOVE INTO UNIT NAME
	MOVE	T4,XKBNAM##(F)	;PICK UP KNOTROLLER NAME
	HLLM	T4,XUBNAM##(T3)	;FILL IN REST OF UNIT NAME
XUBALC:	ADDI	T3,XUBSIZ##	;BUMP ALLOCATION
	MOVEM	T3,SYSSIZ	;AND SAVE IT
	AOS	T2		;BUMP UDB TABLE POINTER
	SOJGE	T1,XUBLP	;LOOP IF MORE UNITS
XKBNUL:	HRRZ	F,XKBKDB##(F)	;NO, GET ADDR OF NEXT KDB
	JUMPN	F,XKBLP		;LOOP IF IT IS THERE
	MOVEI	T1,1000		;SPACE FOR DDB'S
	ADDB	T1,SYSSIZ	; ..
>
;FOLLOWING CODE ALLOCATES SPACE FOR THE LINE DATA BLOCKS AND FOR CHARACTER LISTS

IFNDEF TTCHKS,<EXTERN TTCHKS>

IFE FTXMON,<
	MOVE	T1,SYSSIZ	;GET CURRENT SIZE
	TRZ	T1,CK.BDY##	;NEAREST EVEN CHUNK BOUNDRY +1
	TRO	T1,1
	CAMGE	T1,SYSSIZ	;SMALLER THAN SYSSIZ?
	ADDI	T1,TTCHKS	;YES, THEN MUST USE NEXT ONE
	MOVEM	T1,SYSSIZ	;& REMEMBER
	HRRM	T1,TTCLST	;SAVE AS FIRST CHARACTER CHUNK ADDR
	HLRZ	T1,TTCLST	;COMPUTE SPACE NEEDED
	IMULI	T1,TTCHKS	;FOR CHARACTER LIST
	ADDM	T1,SYSSIZ	;AND UPDATE SYSTEM SIZE
>
LNKTT0:!SKIPE	DESONC		;FIRST TIME?
	JRST	LNKTTA		;NO, GO BUILD THE LDBS
	SKIPE	LDBVRG		;ALREADY HAVE STARTING ADDRESS
	JRST	LNKTT3		;YES, MUST BE RESTART AT ONCE
IFE FTXMON,<
	MOVE	T1,MONVFF	;FIRST FREE MONITOR VIRTUAL ADDRESS
	MOVEM	T1,LDBVRG	;SAVE AS THE ORIGIN OF THE LDB SPACE
	MOVEI	T1,TTPLEN##*LDBLEN## ;NUMBER OF WORDS REQUIRED BY LDBS
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.PUB+PM.SWB)

	PUSHJ	P,ONCMAP##	;SETUP THE MAP SO THAT LDB SPACE IS ADDRESSABLE
>
IFN FTXMON,<
	MOVE	T1,[MS.SCN+MONORG] ;WHERE TO START CHUNK ALLOCATION
	HRRM	T1,TTCLST	;SAVE AS FIRST CHARACTER CHUNK ADDRESS
	AOS	TTCLST		;THE RCC CHECKER WANTS IT THIS WAY
	HLRZ	T2,TTCLST	;NUMBER OF CHUNKS
	IMULI	T2,TTCHKS	;NUMBER OF WORDS FOR CHUNKS
	ADD	T2,T1		;HIGHEST CHUNK ADDRESS
	ADDI	T2,TTPLEN##*LDBLEN##+1 ;MAKE ROOM FOR LDBS TOO (HIGHEST + 1)
	PUSHJ	P,NZSCGT##	;ALLOCATE THE CORE
	MOVEM	T2,MDS3FF	;SAVE HIGHEST ADDRESS + 1 FOR LATER ALLOCATORS
	SUBI	T2,TTPLEN##*LDBLEN## ;BACK OFF TO LDB ORIGIN
	MOVEM	T2,LDBVRG	;MAKE CHUNKS & LDBS OVERLAP MONITOR FOR NOW,
				; IN CASE CODE FALLS INTO SECTION 0, IME WILL
				; RESULT FROM ATTEMPTS TO WRITE (DEBUGGING AID)
>
	JRST	LNKTT3		;SKIP ON
LNKTTA:!MOVEI	J,0		;MAKE THE LDB'S
IFN FTXMON,<
	XJRST	[MCSEC1+.+1]	;ENTER SECTION 1
	MOVE	T3,LDBVRG	;WHERE TO START
>
IFE FTXMON,<
	SKIPA	U,LDBVRG	;WHERE TO ORIGIN THE LDBS
>
LNKTTL:!
IFE FTXMON,<
	ADDI	U,LDBLEN##	;LENGTH OF AN LDB
	MOVEI	T1,LDBLEN##-IFDEF M.LCST,<M.LCST>(U)	;WHERE TO BLT TO
	HRLI	U,SCNLDB##	;GET THE ADR OF THE PROTO LDB
	PUSH	P,U
	BLT	U,-1(T1)	;COPY THE LDB
IFDEF M.LCST,<IFG M.LCST,<
	MOVE	U,(P)		;GET LDB ADDRESS
	MOVEI	U,LDBCST##+1(U)	;DESTINATION
	SETZM	-1(U)		;ZAP
IFG M.LCST-1,<
	HRLI	U,-1(U)		;SOURCE
	MOVEI	T1,LDBLEN##(U)	;END
	BLT	U,-1(T1)	;CLEAR THE CUSTOMER WORDS
>;IFG M.LCST-1
>>;IFDEF
	POP	P,U
	HRRM	U,LINTAB##(J)	;AND SAVE ITS ADDRESS
>
IFN FTXMON,<
	MOVEI	T1,LDBLEN##-IFDEF M.LCST,<M.LCST>;NUMBER OF WORDS TO MOVE
	MOVEI	T2,SCNLDB##	;STARTING HERE
	MOVEM	T3,LINTAB##(J)	;SAVE ITS ADDRESS
	MOVE	U,T3		;FOR BYTE POINTERS, ETC.
	EXTEND	T1,[XBLT]	;COPY THE PROTOTYPE LDB
IFDEF M.LCST,<IFG M.LCST,<
	XMOVEI	T2,LDBCST##(U)	;START OF CUSTOMER AREA
	SETZM	0(T2)		;CLEAR FIRST WORD
IFG M.LCST-1,<			;ONLY IF MORE THAN ONE
	XMOVEI	T3,LDBCST##+1(U);DESTINATION FOR BLT
	MOVEI	T1,M.LCST-1	;NUMBER OF WORDS TO CLEAR WITH BLT
	EXTEND	T1,[XBLT]	;DO SO
>;IFG M.LCST-1
>>;IFDEF M.LCST
>;FTXMON
	DPB	J,LDPLNO##	;STORE PHYSICAL LINE NUMBER IN LDB
DEFINE	CXDEF(SYM)<
IRP SYM,<
IFNDEF M0'SYM,<M0'SYM==M.'SYM>
IFNDEF M1'SYM,<M1'SYM==0>
IFNDEF M2'SYM,<M2'SYM==0>
IFNDEF M3'SYM,<M3'SYM==0>
IFNDEF M4'SYM,<M4'SYM==0>
IFNDEF M5'SYM,<M5'SYM==0>
>>
CXDEF(<TTG0,TTG1,68L0,68L1,D70N,D71N>)
CXDEF(<D72N,D73N,D74N,D75N,D76N,D77N>)
DEFINE	TTDSPX(DSP,ADDON,CLEVER,STA,QUEUE,CPU,ACTY,X),<
	LINENO==LINENO+ADDON
IFN	ADDON,<
IF2,< IFNDEF QUEUE,<EXTERN QUEUE>>
	MOVSI	T4,QUEUE
	HRRI	T4,CPU
IF2,< IFNDEF DSP,<EXTERN DSP>>
	MOVEI	T1,DSP	;ASSUME THIS FRONT END
IFIDN <CLEVER>,<Y>,<
	TLO	T1,LILCFE##	;SET THE BIT FOR DC76
>
IFN STA-37777,<MOVSI T2,LTLUSE##>  ;NOT A REMOTE (ALLOCATABLE) LDB
IFE STA-37777,<MOVSI T2,0>	;ALLOCATABLE (E.G., ANF) LDB
	CAIG	J,LINENO-1	;IS IT THIS LINE?
	JRST	LNKTT2		;YES--SET LDBISR AND LDBREM
>>
	LINENO==0
DEFINE	TTSPCP(CPU),<
	DC10N0==10*M'CPU'TTG0
	DC10N1==10*M'CPU'TTG1
	TTDSPX(DL0DSP,DC10N0,N,\LOCSTA,DL0TQ'CPU,CPU,)
	TTDSPX(DL1DSP,DC10N1,N,\LOCSTA,DL1TQ'CPU,CPU,)
	TTDSPX(CC0DSP,M'CPU'68L0,N,\LOCSTA,CC0TQ'CPU,CPU,)
	TTDSPX(CC1DSP,M'CPU'68L1,N,\LOCSTA,CC1TQ'CPU,CPU,)
	TTDSPX(DC760D,M'CPU'D70N,Y,\LOCSTA,D70TQ'CPU,CPU,)
	TTDSPX(DC761D,M'CPU'D71N,Y,\LOCSTA,D71TQ'CPU,CPU,)
	TTDSPX(DC762D,M'CPU'D72N,Y,\LOCSTA,D72TQ'CPU,CPU,)
	TTDSPX(DC763D,M'CPU'D73N,Y,\LOCSTA,D73TQ'CPU,CPU,)
	TTDSPX(DC764D,M'CPU'D74N,Y,\LOCSTA,D74TQ'CPU,CPU,)
	TTDSPX(DC765D,M'CPU'D75N,Y,\LOCSTA,D75TQ'CPU,CPU,)
	TTDSPX(DC766D,M'CPU'D76N,Y,\LOCSTA,D76TQ'CPU,CPU,)
	TTDSPX(DC767D,M'CPU'D77N,Y,\LOCSTA,D77TQ'CPU,CPU,)
IFN FTKS10,<
	TTDSPX(DZDSP,M'CPU'DZNL,Y,\LOCSTA,DZTQ'CPU,CPU,)
>
IFN FTKL10,<
	TTDSPX(TTDDSP,M'CPU'TTDN,N,\LOCSTA,.C'CPU'CTQ,CPU,)
>; END IFN FTKL10
IFN	FTXTC,<
IFN	M.XTL,<
	TTDSPX(XTTDSP,M.XTL,N,\LOCSTA,XTTQUE,)
>>		;END OF FTXTC & M.XTL
>
;GENERATE LDB'S FOR LOCAL LINES
ZZ==0
REPEAT	CPUN,<
	TTSPCP(\ZZ)
ZZ==ZZ+1
>
;NOW GENERATE A POOL OF LDB'S FOR NETWORK TTYS
;ASSUME ALL ARE ON CPU0 SINCE NETWORK LDB'S ARE DYNAMICALLY ALLOCATED
; FROM THE POOL AND THE CORRECT OUTPUT QUEUE AND CPU NUMBER ARE FILLED
; IN BY NETSER WHEN THE LDB IS USED

	TTDSPX(MCRDSP,M.RMCR,N,37777,MCRRTQ,)

;KS10 KLINIK LINE
IFN M.KS10,<
DEFINE TTSPCP(CPU),<
	TTDSPX(CTYDSP,1,N,\LOCSTA,.C'CPU'CTQ,CPU,)
>
ZZ==CPUN-1
REPEAT CPUN,<
	TTSPCP(\ZZ)
ZZ==ZZ-1
>
>;END IFN M.KS10

;NOW GENERATE AN LDB FOR INTERNAL FORCED COMMANDS

FRCLIN==:LINENO
	TTDSPX(ERRDSP,1,N,\LOCSTA,FRCQUE,7,)

;NOW GENERATE LDB'S FOR THE CTYS

DEFINE	TTSPCP(CPU),<
CT'CPU'LIN==:LINENO
	TTDSPX(CTYDSP,1,N,\LOCSTA,.C'CPU'CTQ,CPU,)
>
ZZ==CPUN-1
REPEAT	CPUN,<
	TTSPCP(\ZZ)
ZZ==ZZ-1
>
IFN TCONLN-CT0LIN,<PRINTX ?TTDSPX IS IN ERROR>

	MOVEI	T1,ERRDSP##	;PTY LINE
	MOVSI	T2,LTLUSE##	;PTY'S LDBS ARE IN USE
	MOVEI	T4,7		;FAKE CPU NUMBER
	HRLI	T4,FRCQUE##	;AND FAKE QUEUE HEADER
LNKTT2:!HLLZM	T1,LDBISB##(U)	;SET CLEVER BIT AS REQUESTED
IFE FTXMON,<HRLI T1,T1>		;SET UP INDEX FOR @LDBISR(U)
IFN FTXMON,<HRLI T1,(<T1>B5+MCSEC1)> ;POSITION TO INDEX FIELD FOR EFIW
	MOVEM	T1,LDBISR##(U)	;STORE AWAY
	HLLZM	T4,LDBQUH##(U)
	DPB	T4,LDPCPU##
	IORM	T2,LDBTTW##(U)	;MARK LDB NOT/IN USE AS APPROPRIATE
LNKTT1:!CAIGE	J,TTPLEN##-1	;MADE ENOUGH LDB'S?
	AOJA	J,LNKTTL	;NO. MAKE ANOTHER ONE
IFN FTXMON,<
	XJRST	[0+.+1]		;BACK TO SECTION 0
>
LNKTT3:!
ACBMEM:!
IFN M.DECN,<
	XMOVEI	P4,DCNACB	;GET ADDRESS OF DECNET ALLOCATION CONTROL BLOCK
	XMOVEI	P3,DCNAHB	;AND ADDRESS OF ALLOCATION HEADER BLOCK
	XMOVEI	P2,DCNAEB	;AND ADDRESS OF ALLOCATION EXTENT BLOCK
	MOVEM	P3,ACBAHB(P4)	;LINK BLOCKS TOGETHER
	SETZM	AHBNXT(P3)	;...
	MOVEM	P2,AHBAEB(P3)	;...
	SETZM	AEBNXT(P2)	;...
	MOVE	T1,ACBCSZ(P4)	;GET CHUNK SIZE IN WORDS
	MOVEM	T1,AHBCSZ(P3)	;INITIALIZE ALLOCATION HEADER BLOCK
	MOVE	T1,ACBSEC(P4)	;GET SECTION NUMBER OF ALLOCATION
	MOVEM	T1,AHBSEC(P3)	;INITIALIZE ALLOCATION HEADER BLOCK
	MOVE	T1,ACBINI(P4)	;GET INITIAL ALLOCATION AMOUNT IN WORDS
	MOVEM	T1,AHBFRE(P3)	;INITIALIZE ALLOCATION HEADER BLOCK
	MOVEM	T1,AHBLWM(P3)	;...
	MOVEM	T1,AHBINI(P3)	;...
	MOVEM	T1,AHBCUR(P3)	;...
	MOVEM	T1,AEBFRE(P2)	;INITIALIZE ALLOCATION EXTENT BLOCK
	MOVEM	T1,AEBLWM(P2)	;...
	MOVEM	T1,AEBSIZ(P2)	;...
	MOVE	T1,ACBTHR(P4)	;GET THRESHOLD ALLOCATION AMOUNT IN WORDS
	MOVEM	T1,AHBTHR(P3)	;INITIALIZE ALLOCATION HEADER BLOCK
	MOVE	T1,ACBINC(P4)	;GET INCREMENTAL ALLOCATION AMOUNT IN WORDS
	MOVEM	T1,AHBINC(P3)	;INITIALIZE ALLOCATION HEADER BLOCK
	MOVE	T1,ACBMIN(P4)	;GET MINIMUM ALLOCATION AMOUNT IN WORDS
	MOVEM	T1,AHBMIN(P3)	;INITIALIZE ALLOCATION HEADER BLOCK
	MOVE	T1,ACBMAX(P4)	;GET MAXIMUM ALLOCATION AMOUNT IN WORDS
	MOVEM	T1,AHBMAX(P3)	;INITIALIZE ALLOCATION HEADER BLOCK
	SETZM	AHBPND(P3)	;CLEAR PENDING ALLOCATION AMOUNT
	MOVE	T1,AEBSIZ(P2)	;GET SIZE OF ALLOCATION EXTENT
	IDIV	T1,AHBCSZ(P3)	;COMPUTE NUMBER OF CHUNKS
	ADDI	T1,^D35		;COMPUTE SIZE OF BITMAP
	IDIVI	T1,^D36		; (REMAINDER IN T2)
	MOVN	T3,T1		;CREATE AOBJN POINTER TO BITMAP
	HRLS	T3		;...
	HRR	T3,SYSSIZ	;GET ADDRESS OF NEXT FREE LOCATION
	MOVEM	T3,AEBBMP(P2)	;SAVE AOBJN POINTER TO BITMAP
	SKIPE	DESONC		;OK TO ZERO ONCE NOW?
	SETZM	(T3)		;YES, ZERO THE BITMAP
	AOBJN	T3,.-2		;LOOP FOR ENTIRE BITMAP
	SUBI	T2,^D35		;CALCULATE NUMBER OF BITS TO MARK OFF
	MOVNS	T2		; IN LAST WORD OF BITMAP
	SETO	T4,		;START WITH A COMPLETE MASK
	LSH	T4,(T2)		;COMPUTE MASK OF BITS TO KEEP
	SKIPE	DESONC		;OK TO ZERO ONCE NOW?
	SETCAM	T4,-1(T3)	;YES, MARK OFF APPROPRIATE BITS IN LAST WORD
	ADDB	T1,SYSSIZ	;UPDATE SYSSIZ
>;END IFN M.DECN
	MOVE	T1,SYSSIZ	;GET SYSTEM SIZE INTO T1
	ADDI	T1,CRWDM1##	;MAKE SURE 4 WORD BLOCKS HAVE BOTTOM 2 BITS = 0
	TRZ	T1,CRWDM1##
	HRLZM	T1,SYSCOR##	;SAVE ADR. OF 1ST. PERMANENT 4 WORD BLOCK IN SYSCOR
	MOVE	T2,CORNUM##	;GET # OF BLOCKS TO BE GENERATED
	ADDI	T1,CORWDS##	;COMPUTE ADR. OF NEXT BLOCK
	SKIPE	DESONC		;OK TO DESTROY ONCE ONLY CODE?
	HRLZM	T1,DIFLNK##(T1)	;YES - SAVE ADR. OF NEXT BLOCK IN THIS BLOCK
	SOJG	T2,.-3		;FINISHED YET?
	SKIPE	DESONC		;OK TO DESTROY ONCE ONLY CODE?
	SETZM	DIFLNK##(T1)	;YES - ZERO LINK IN LAST BLOCK TO SIGNAL END OF LIST
	HRRM	T1,FREPTR	;SAVE ADR. OF BIT TABLE OF ALLOCATABLE 4 WORD BLOCKS
	MOVEM	T1,LOCORE	;SAVE POINTER TO 1ST. 4 WORD BLOCK
	MOVEI	T2,<<3*JOBN+3>/4>*4	;3/4 TIMES NUMBER OF JOB
	IMULI	T2,PDB4WD	;TIMES CORE FOR A PDB
	ADDI	T2,CSHMEM##	;PLUS CORE FOR DISK CACHE DIRECTORY
IFE FTXMON,<ADDI T2,CBHSHS##*200>;PLUS CORE FOR DISK CACHE DATA
	ADDI	T1,MINCOR+EXTRAW(T2)	;MIN REQUIRED FOR DISK DDBS OR 10/40 EXTENDED PD LIST
	IORI	T1,PG.BDY	;FORCE PAGE BOUNDARY
	ADDI	T1,1
	MOVEM	T1,SYSSIZ	;STORE SIZE OF MONITOR (FIRST FREE LOC)
	SKIPE	INIFRE		;FIRST TIME THROUGH
	JRST	LNKTT6		;NO, PAGTAB AND MEMTAB ARE ALREADY SET UP
	MOVE	T1,NWCORE
	CAMG	T1,FLG256
	MOVE	T1,FLG256
	MOVEM	T1,NWCORE
	MOVSS	T1

	SKIPE	T1		;IF ZERO, MACHINE HAS .LE. 256K OF CORE
	TLZE	T1,-1		;CHECK IF EXACTLY A MULTIPLE OF 256K
	ADDI	T1,1		;NO, 1 MORE PAGE REQUIRED FOR PAGTAB
	LSH	T1,P2WLSH	;NUMBER OF WORDS FOR EACH OF PAGTAB AND MEMTAB
IFE FTXMON,<
	PUSH	P,MONVFF	;SAVE HIGHEST VIRTUAL ADDRESS USED
	PUSH	P,T1		;AND NUMBER OF WORDS REQUIRED
	MOVEI	T2,PAGTAB
	MOVEM	T2,MONVFF	;MAP PAGES TO PAGTAB
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.PUB+PM.SWB+IFE M.CPU-1,<PM.CSH>)
	PUSHJ	P,ONCMAP##	;ALLOCATE AND MAP IN PAGTAB
	MOVEI	T2,PT2TAB
	MOVE	T1,(P)
	MOVEM	T2,MONVFF	;MAP PAGES TO PAGTAB
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.PUB+PM.SWB+IFE M.CPU-1,<PM.CSH>)
	PUSHJ	P,ONCMAP##	;ALLOCATE AND MAP IN PAGTAB
	MOVEI	T2,MEMTAB	;NOW DO IT FOR MEMTAB
	MOVEM	T2,MONVFF
	POP	P,T1		;RESTORE NUMBER OF WORDS
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.PUB+PM.SWB+IFE M.CPU-1,<PM.CSH>)
	PUSHJ	P,ONCMAP##	;ALLOCATE AND MAP IN MEMTAB
	POP	P,MONVFF	;PUT THINGS BACK
>
IFN FTXMON,<
	PUSH	P,T1		;SAVE NUMBER OF WORDS
	MOVE	T1,[EXP MS.MEM+PAGTAB]
	MOVE	T2,T1
	ADD	T2,(P)
	PUSHJ	P,NZSCGT##
	MOVE	T1,[EXP MS.MEM+PT2TAB]
	MOVE	T2,T1
	ADD	T2,(P)
	PUSHJ	P,NZSCGT##
	MOVE	T1,[EXP MS.MEM+MEMTAB]
	POP	P,T2
	ADD	T2,T1
	PUSHJ	P,NZSCGT##
>
IFN M.DECN,<
;FOLLOWING CODE ALLOCATES SPACE FOR DECnet BUFFERS
D36MEM:!
IFE FTXMON,<
	PUSH	P,MONVFF	;SAVE CURRENT MONVFF
	MOVE	T1,.E0DMP	;DECNET SECTION 0 POINTER
	ANDI	T1,17777	;ISOLATE PAGE NUMBER
	LSH	T1,P2WLSH	;CONVERT TO ADDRESS
	MOVE	T2,T1		;COPY TO T2
	HRL	T1,.CPMAP	;SET TO COPY NORMAL EXEC MAP
	BLT	T1,PAGSIZ-1(T2)	;ZAP
	PUSHJ	P,DCNCCR##	;GET TOTAL DECnet WORDS REQ'D IN T1
	ADD	T1,DCNAEB+AEBSIZ ;ADD AMOUNT FOR BITMAP POOL
	TRZE	T1,PG.BDY	;ROUND UP TO A PAGE BOUNDARY
	ADDI	T1,PAGSIZ
	MOVEI	T2,.LPMC	;WHERE ALLOCATING IS TO END
	SUB	T2,T1		;WHERE ALLOCATION IS TO BEGIN
	MOVEM	T2,MONVFF	;FOR THE ALLOCATOR
	MOVEM	T2,DCNAEB+AEBADR ;SET UP ADDRESS OF BITMAP POOL
	ADD	T2,DCNAEB+AEBSIZ ;OFFSET PAST BITMAP POOL
	MOVEM	T2,DCNCOR##	;SET UP ADDRESS OF DECNET CORE
	PUSHJ	P,DNMAP##	;NOW POINT THE EPT AT THE DECNET MAP
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.PUB+PM.SWB+IFE M.CPU-1,<PM.CSH>)
	PUSHJ	P,ONCMAP##	;GO CREATE THE CORE
	MOVEI	T1,SYSINI##	;WHERE SYSINI IS
	CAMG	T1,SYSSIZ	;CAN IT BE CLOBBERED?
	TDZA	T1,T1		;NO, NOT TO WORRY
	MOVEI	T1,ENDSYL##	;LENGTH OF SYSINI
	ADD	T1,SYSSIZ	;CAN'T CLOBBER ANYTHING BELOW THIS WITH DECNET SPACE
	CAMLE	T1,DCNCOR##	;OVERLAP?
	STOPCD	.,STOP,DMO,	;++DECNET CORE AND MONITOR OVERLAP
	POP	P,MONVFF	;NOW ALLOCATE IN REGULAR MAP
	PUSHJ	P,RGMAP##	;  ..
> ;END IFE FTXMON
IFN FTXMON,<
	PUSHJ	P,DCNCCR##	;GET TOTAL DECnet WORDS REQ'D IN T1
	ADD	T1,DCNAEB+AEBSIZ ;ADD AMOUNT FOR BITMAP POOL
	MOVEI	T2,PG.BDY(T1)	;ROUND UP TO PAGE BOUNDARY
	TRZ	T2,PG.BDY	;...
	MOVE	T1,[MS.DCN+MONORG] ;WHERE TO ALLOCATE THE CORE
	ADD	T2,T1		;END OF WHERE TO ALLOCATE THE CORE
	PUSHJ	P,NZSCGT##	;ASK ONCMOD FOR THE CORE
	MOVEM	T1,DCNAEB+AEBADR ;SAVE AS ADDRESS OF BITMAP POOL
	ADD	T1,DCNAEB+AEBSIZ ;OFFSET PAST BITMAP POOL
	MOVEM	T1,DCNCOR##	;SAVE AS STARTING ADDRESS OF DECNET CORE
> ;END IFN FTXMON
> ;END IFN M.DECN
IFN M.ENET,<
ETHMEM:!
IFE FTXMON,<
	MOVE	T1,MONVFF	;START OF CORE WE ARE GOING TO ALLOCATE
	MOVEM	T1,ETHLOC	;SAVE AS START OF ETHERNET FREE CORE
	MOVEI	T1,ETHSIZ	;SIZE OF FREECORE WE'LL NEED
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.PUB+PM.SWB+IFE M.CPU-1,<PM.CSH>)
	PUSHJ	P,ONCMAP##	;GO CREATE THE CORE
IFN M.KL10,<
	MOVE	T1,MONVFF	;START OF CORE WE ARE GOING TO ALLOCATE
	MOVEM	T1,KNILOC	;SAVE AS START OF KLNI FREE CORE
	MOVEI	T1,KNISIZ	;SIZE OF FREECORE WE'LL NEED
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.PUB+PM.SWB+IFE M.CPU-1,<PM.CSH>)
	PUSHJ	P,ONCMAP##	;GO CREATE THE CORE
>; END IFN M.KL10
IFN M.LATN,<
	MOVE	T1,MONVFF	;START OF CORE WE ARE GOING TO ALLOCATE
	MOVEM	T1,LATLOC##	;PUT IT WHERE LATSRV CAN FIND IT.
	PUSHJ	P,LAGTCR##	;ASK LATSRV HOW MUCH CORE IT NEEDS
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.PUB+PM.SWB+IFE M.CPU-1,<PM.CSH>)
	PUSHJ	P,ONCMAP##	;GO CREATE THE CORE
>; END IFN M.LATN
>; END IFE FTXMON
IFN FTXMON,<
IFE M.DECN,<
	MOVE	T2,[MS.DCN+MONORG] ;WHERE TO ALLOCATE THE CORE IF NO DECNET
>; END IFE M.DECN
	MOVE	T1,T2		;GET NEXT FREE ADDRESS (FROM ABOVE)
	ADDI	T1,PG.BDY	;ROUND TO PAGE BOUNDARY
	TRZ	T1,PG.BDY	;...
	MOVEI	T2,ETHSIZ	;SIZE OF FREECORE
	ADD	T2,T1		;END OF WHERE TO ALLOCATE THE CORE
	PUSHJ	P,NZSCGT##	;ASK ONCMOD FOR NON-ZERO SECTION CORE
	MOVEM	T1,ETHLOC	;SAVE AS LOWEST ADDRESS IN FREECORE
IFN M.KL10,<
	MOVE	T1,T2		;GET NEXT FREE ADDRESS
	ADDI	T1,PG.BDY	;ROUND TO PAGE BOUNDARY
	TRZ	T1,PG.BDY	;...
	MOVEI	T2,KNISIZ	;SIZE OF FREECORE
	ADD	T2,T1		;END OF WHERE TO ALLOCATE THE CORE
	PUSHJ	P,NZSCGT##	;ASK ONCMOD FOR NON-ZERO SECTION CORE
	MOVEM	T1,KNILOC	;SAVE AS LOWEST ADDRESS IN FREECORE
>; END IFN M.KL10
IFN M.LATN,<
				;T2 STILL HAS HIGHEST ADDRESS+1 FROM ABOVE
	TRZE	T2,PG.BDY	;AND IF WE NEED TO,
	ADDI	T2,PAGSIZ	;ROUND UP...
	PUSHJ	P,LAGTCR##	;ASK LATSRV HOW MUCH HE NEEDS
	TRZE	T1,PG.BDY	;AND IF WE NEED TO,
	ADDI	T1,PAGSIZ	;ROUND UP...
	ADD	T1,T2		;END OF WHERE TO ALLOCATE THE CORE
	EXCH	T1,T2		;GET THEM IN THE RIGHT REGISTERS
	PUSHJ	P,NZSCGT##	;ASK ONCMOD FOR NON-ZERO SECTION CORE
	MOVEM	T1,LATLOC##	;SAVE AS LOWEST ADDRESS IN FREECORE
>; END IFN M.LATN
>; END IFN FTXMON
>; END IFN M.ENET
LNKTT6:!MOVE	T3,SYSSIZ
	MOVEM	T3,INIFRE	;STORE THAT AS WHERE TO MOVE SYSINI
	SUBI	T3,FYSORG-ENDSYL## ;BELOW 112K + ROOM FOR SYSINI?
	JUMPLE	T3,LNKTT4	;JUMP IF SO
	IORI	T3,PG.BDY	;ROUND UP
	MOVNI	T1,1(T3)	;AMOUNT TO REDUCE THINGS BY
	ADDM	T1,INIFRE	;WHERE TO PUT SYSINI
	ADDM	T1,SYSSIZ
LNKTT4:!MOVE	T1,SYSSIZ	;FIND HOW MUCH IS LEFT OVER AT THE END OF THE PAGE
	SUB	T1,LOCORE	;FORM LENGTH OF EXCESS CORE
	IDIVI	T1,^D144	;MUST BE MULTIPLE OF 144. WORDS (LEVEL C:SEE DDBTAB)
				;SIZE OF BIT TABLE IS NOW IN T1
LNKTT5:!MOVE	T2,T1		;COPY NUMBER OF WORDS FOR BIT MAP
	IMULI	T2,^D145	;NUMBER OF WORDS DESCRIBED
				;  INCLUDING THE BIT MAP
	ADD	T2,LOCORE	;SEE WHERE IT TAKES US
	CAMLE	T2,SYSSIZ	;HOPEFULLY, NOT OFF THE END
	SOJA	T1,LNKTT5	;IT DOES, TRY A SMALLER NUMBER
	ADDM	T1,LOCORE	;MAKE LOCORE POINT TO 1ST. 4 WORD BLOCK
	MOVN	T1,T1		; -N
	HRLM	T1,FREPTR	;STORE USEABLE LENGTH OF DDBTAB

LINKED:!JRST .			;RETURN TO SYSINI
INIFRE:!EXP	0		;CONTAINS ADDR OF FREE SPACE FOR SYSINI
;DDB LINK AND CREATION SUBROUTINES

DDBLNK:!CAIN	M,(SIXBIT/DSK/)	;IS THIS A DSK DDB?
	JRST	DDBLDS		;YES - DO EXTRA SPECIAL STUFF
IFN FTAUTC,<
	CAIE	M,(SIXBIT /MTA/) ;MAGTAPE?
	JRST	DDBLN1		;NO
	HLRZ	T3,DEVSER(T2)	;YES. GET LINK (SET UP BY AUTCON)
	JUMPE	T3,CPOPJ	;NOTHING WE CAN DO IF NO MAGTAPES FOUND YET
	MOVE	T2,T3		;PATCH MT0DDB OUT OF CHAIN
DDBLN1:>
	LDB	P2,PINTNO	;NUMBER OF DDB'S TO CREATE
	TRZN	S,1		;SKIP COPY IF NO-COPY FLAG SET ON CALL
MULDDB:!PUSHJ	P,DDBCOP	;GO COPY A DDB
MULDD1:!SKIPE	DESONC		;SKIP IF UNABLE TO WRITE
	HRLM	T2,DEVSER(F)	;CHAIN TO PREVIOUS DDB
	HRRZ	F,T2		;UPDATE DDB PTR

	SKIPN	P3		;IF THIS IS DEV 0
	LDB	P1,PUNIT	;RESET UNIT NUMBER FROM DDB
				;(PTY'S, FOR EXAMPLE, START AT #1)
	SKIPE	DESONC		;SKIP IF UNABLE TO WRITE
	SKIPN	DEVNAM(F)	;DO NOT MAKE FUNNY NAMES
	SKIPA			;CON NOT WRITE OR NULL NAME
	PUSHJ	P,DDBFIX	;MAKE DDB UNIQUE
	AOS	P3		;INCREMENT # OF DEVNAM
	AOS	P1		;INCREMENT UNIT #
	SOJG	P2,MULDDB	;DO NEXT DDB TILL DONE
IFN FTAUTC,<
	CAIE	M,(SIXBIT /MTA/) ;IS THIS THE MAGTAPE DDB?
	POPJ	P,		;NO, WE'RE DONE
	HLRZ	T2,DEVSER(F)	;YES, PICK UP ITS LINK (SET BY AUTCON)
	JUMPE	T2,CPOPJ	;GO IF IT IS THE END
	EXCH	T2,F
	LDB	P1,PUNIT	;GET THE UNIT NAME
	EXCH	T2,F
	MOVE	P3,P1
	JRST	MULDD1		;GO FIX UP THIS NAME
>
IFE FTAUTC,<
	POPJ	P,0		;THEN RETURN
>

DDBLDS:!TRNE S,2		;HAVE WE BEEN HERE BEFORE
	POPJ	P,0		;YES - RETURN WITHOUT DOING ANYTHING
	TRO	S,2		;SET TRAP FOR ONCE ONLY
IFN SYS50N,<
	MOVEI	T3,SWPDDB##	;ADR. OF SWAPPING DDB
	SKIPE	DESONC		;SKIP IF NOT ABLE TO DESTROY ONCE ONLY
	HRLM	T3,DEVSER(F)	;LINK PREVIOUS DDB TO SWPDDB
	MOVEI	F,SWPDDB##	;UPDATE DDB PTR TO SWPDDB
				; THUS SWPDDB COMES BEFORE DSKDDB
				; IN DEVICE CHAIN.  NEED IN CHAIN FOR
				; HUNG TIMEOUT.
>
	SKIPE	DESONC		;SKIP IF UNABLE TO WRITE
	HRLM	T2,DEVSER(F)	;LINK DDB TO LAST
	HRRZ	F,T2		;UPDATE DDB PTR
	POPJ	P,0		;AND RETURN

;SUBROUTINE TO COPY DDB PROTOTYPE AND UPDATE SYSSIZ

DDBCOP:!HRRZ	T2,SYSSIZ	;IS PTR TO NEW DDB
	HRL	T2,U		;SOURCE OF COPY IS PROTOTYPE
	LDB	M,PINTSZ	;GET SIZE OF DDB
	ADDB	M,SYSSIZ	;UPDATE SYSSIZ AND GET END OF DDB+1
	PUSH	P,T2		;SAVE BLT AC
	SKIPE	DESONC		;SKIP IF UNABLE TO WRITE
	BLT	T2,-1(M)	;COPY DDB
	JRST	T2POPJ		;RESTORE T2 AND RETURN
;SUBROUTINE TO FIX UP EACH DDB TO BE UNIQUE
;THIS ROUTINE (1) UPDATES PUNIT
;		(2) UPDATES THE DEVNAM FIELD TO BE UNIQUE
;		(3) PUTS IN THE CORRECT STATION NUMBER
;		(4) DOES ODDS AND ENDS ON A DEVICE DEPENDANT BASIS
;			SUCH AS:
;				FOR DTA - PUTS IN DIR PTR

DDBFIX:!DPB	P1,PUNIT	;PUT IN UNIT NUMBER
IFE FTNET,<
	LDB	W,PINTNO	;NUMBER OF DDB'S BEING CREATED
	SOJLE	W,DDBFI1	;JUMP IF ONLY 1, DON'T CHANGE ITS NAME
>
	MOVE	W,PHYNAM	;BYTE POINTER TO NEWLY CREATED
				; DDB PHYSICAL NAME
	LDB	T2,PDVTYP	;GET THE DEVICE TYPE
	CAIE	T2,.TYTTY/.TYEST	;IS IT A TTY
	CAIN	T2,.TYPTY/.TYEST	; OR PTY
	JRST	DDBFI0		;YES, IGNORE STATION NUMBER IN DEV NAME
IFN FTAUTC,<
	CAIE	T2,.TYMTA/.TYEST ;MAGTAPE?
	JRST	DDBFI5		;NO
	MOVE	T2,(F)		;YES, GET ITS NAME
	TLNN	T2,40		;3RD CHARACTER ALPHABETIC?
	JRST	DDBFI1		;NO (EG MT110). DON'T CHANGE ITS NAME
DDBFI5:>
	LDB	J,PINTST	;GET THE STATION NUMBER
	LSH	J,3		;SHIFT FOR THE UNIT
	IORM	P1,J		;INSERT THE STATION NUMBER
	JRST	DDBFI4		;CONVERT THE NAME
DDBFI0:!MOVE	J,P3		;MAKE COPY OF UNIT NUMBER
	TRNN	J,700		;UNIT NUMBER 100 OR MORE?
	JRST	DDBFI2		;NO
DDBFI4:!LDB	T2,[POINT 3,J,29]
	ADDI	T2,20
	IDPB	T2,W		;PUY IN 00B NAM
	TRZ	J,700		;CLEAR HIGH ORDER
	JRST	DDBFI3		;AND PROCEED
DDBFI2:!TRNN	J,70		;IS IT 10 OR MORE ?
	JRST	SMALL		;NO
DDBFI3:!ROT	J,-3		;YES, CONVERT HIGH ORDER OCTAL DIGIT TO
	ADDI	J,20		;SIXBIT
	IDPB	J,W		;AND STORE
	TRZ	J,-1		;CLEAR OUT HIGH ORDER DIGIT
	ROT	J,3		;MOVE LOW ORDER DIGIT BACK
SMALL:!	ADDI	J,20		;CONVERT LOW ORDER DIGIT IN SIXBIT
	IDPB	J,W		;AND STORE IN PHYSICAL NAME
DDBFI1:!LDB	T2,PINTST	;GET STATION NUMBER
	DPB	T2,PDVSTA	;AND PUT IN DDB
IFN M.DTXN,<
	CAIE	T2,LOCSTA	;IS THIS FOR LOCAL STATION
>
	POPJ	P,0		;AND RETURN

IFN M.DTXN,<
FIXLOC:!MOVE	T2,DEVMOD(F)	;GET DEV CHR
	MOVEI	J,DTADIR##(F)	;ADDRESS OF DIR BLOCK ID DTA
	TLNE	T2,DVDTA	;IS IT A DTA
	MOVEM	J,DLOC##(F)	;YES -  PUT IN PTR TO DIR
	POPJ	P,0		;AND RETURN
>

;XCT'D FROM ONCE TO SEE IF ALL CPUS HAVE DK10S
;	XCT	CKDK10##
;	---			;HERE IF NO
;	---			;HERE IF YES

CKDK==SKIPA			;ASSUME YES
IFE M.RT0,<CKDK==JFCL>		;NO IF NONE ON CPU0
IFG CPUN-1,<IFE M.RT1,<CKDK==JFCL>>	;NO IF NONE ON CPU1
CKDK10::CKDK
DESONC:!0			;FLAG =0 IF CALLED BY JSP T1,CNTDB
				; (DO NOT DESTROY ONCE)
				; FLAG NON-ZERO IF CALLED BY JRST LINKDB
				; (OK TO DESTROY ONCE CODE)
DDBNUM::!POINT 11,INTTAB(T1),11	;POINTER TO DDB NUMBER
PHYNAM:!POINT 6,DEVNAM(F),17	;BYTE POINTER TO DB PHYSICAL NAME
PINTNO=DDBNUM
PINTIN:!POINT 18,INTTAB(T1),35	;PTR TO INTERUPT FIELD
PINTCP::!POINT 3,INTTAB(T1),CPUPOS	;POINTER TO CPU NUMBER
CPUPOS==^D14	;PLACE IN INTTAB WHERE CPU NUMBER IS STORED
PINTCH::!POINT 3,INTTAB(T1),PIAPOS	;PTR TO CHANNEL FIELD
PIAPOS==^D17	;PLACE IN INTTAB ENTRY WHERE PIA IS HELD
PINTDB:!POINT 18,INTTAB+1(T1),35	;PTR TO DDB ADDR FIELD
PINTST:!POINT 6,INTTAB+1(T1),8	;PTR TO STATION NUMBER FIELD -- SEE ALSO SYCHK: %IDB2
PINTSZ:!POINT 9,INTTAB+1(T1),17	;PTR TO DDB SIZE FIELD


IFN LEVDN,<DDSTAR::!Z		;STARTING ADDR OF STR DATA BLOCKS ETC. IN HIGH CORE
			;(USED BY ONCMOD AND REFSTR)
>
SYSCKI::
IFE SYSCN,<JFCL>		;"XCT"ED BY SYSINI
IFN SYSCN,<	JSR	SYSCHK## ;"XCT"ED BY SYSINI
>

IFN M.FPS,<
	EXTERN	KASER		;CAUSE KA10 FP SIMULATION MODULE TO BE LOADED
>
IFE M.FPS,<
XP KALFPS,CPOPJ
XP SETFPS,CPOPJ
XP SETFPC,COMERA##
>
SUBTTL MACROS TO DEFINE PI CHANNELS
;;MACROS TO DEFINE PI CHANNEL NUMBER AND GENERATE INTERRUPT CHAINING
;; INFORMATION FOR ONCE SO IT CAN LINK THE DEVICE INTERRUPT SERVICE
;; ROUTINES AND THE DEVICE DATA BLOCKS


;;TABLE INTTAB IS GENERATED WITH PAIRS OF ENTRIES FOR EACH DEVICE
;;FIRST WORD: BIT 0==1 IF DECTAPE, BITS 1-11==NUMBER OF DDBS
;;	RH IS ADDRESS OF CONSO FOR SKIP CHAIN
;;SECOND WORD: BIT 0, FLAG SAYING DEVICE IS ON CPU1, BITS 1-3 PIA,
;;	BITS 4-8 STATION #,9-17 DDB SIZE AND RH IS DDB ADDRESS
;;
;;MACRO FOR DEVICES WHICH ARE ALWAYS PRESENT (AND WHICH DO NOT USE A
;; CHANNEL SAVE ROUTINE AND HAVE NO DDB)  EXAMPLES ARE APR, CTY, PEN, CLK...

DEFINE SPAXGINT (DEV,PI) <
	DEV'N==1
	ASGINT	DEV,PI
>


DEFINE ASGIN1 (DEV,PI) <
		DEV'CHL==:CH'PI
>

DEFINE SPASGINT (DEV,PI) <
	DEV'N==1
	ASGINT	DEV,PI
>

DEFINE ASGINT (DEV,PI) <
	IFG	DEV'N, <IFG PI, <
	IFE	<PI-.CH>, <.CHAS==1	;;CHANNEL PI IN USE.
>
		IF2,<IFNDEF DEV'INT,<EXTERN DEV'INT>>
		DEV'CHN==:PI&7
		DEV'CH1==PI		;DEFINE THIS FOR USE AFTER CHAN DEFINITIONS
		XWD PI,DEV'INT		;;GENERATE INTERRUPT ENTRY POINT FOR ONCE
		XWD 0,0
	ASGIN1	DEV,\PI
>>
>


;;MACRO FOR OPTIONAL DEVICES WHICH ALWAYS USE A CHANNEL SAVE ROUTINE
;; (EXAMPLES: CDR, DSK, PTR, ETC.  ALSO PTY WITH 0 PI)

DEFINE SPASGDDB (DEV,PI,NUM) <
	DEV'N==NUM
	NOSAV==1
	ASGSAV	DEV,PI
>
;MACRO TO GENERATE INTTAB ENTRY FOR SAVE ROUTINE BUT NO DDB
;  ASGSVE & ASGSVI
DEFINE ASGSVE (DEV,PI) <

	.CHAS==1
	DEV'CHN==:PI&7
	DEV'CH1==PI
	DEV'HAC==:13

	ASGSV2	DEV,\PI;
IFDIF	<DEV><SCN><
IF2 < IFNDEF DEV'INT,<EXTERNAL DEV'INT>> ;DEFINE AS EXTERN IF NOT IN COMMON
		XWD PI,DEV'INT
		XWD 0,0

>>
DEFINE ASGSAV (DEV,PI) <
	IFG	DEV'N, <
	ASGSV1	DEV,\PI
	>>

;;MACRO FOR:	1. COMPLETION OF THE DEFINITION REQUIRED FOR THOSE
;;		   DEVICES INVOKING THE ASGSAV MACRO
;;		2. DEFINE SYMBOLS FOR DISK (DEV'N=0)

DEFINE ASGSV1 (DEV,PI) <
IF2, < IFNDEF DEV'DDB, <EXTERNAL DEV'DDB>>	;;DEVICE DATA BLOCK ADDRESS
	IFG	PI, <
	IFE	<PI-.CH>, <.CHAS==1	;;CHANNEL PI IN USE.
>
		DEV'CHN==:PI&7		;;DEFINE DEVICE CHANNEL NUMBER
		DEV'CH1==PI		;;USED AFTER CH'PI DEFINITIONS
IFE NOSAV,<
	ASGSV2	DEV,PI
>
>

IFIDN <DEV><SCN><	SCNN*100,,0
	LOCSTA*1000+SCNDDS##,,SCNDDB##>
IFDIF <DEV><SCN><
IFG PI, <
IF2, < IFNDEF DEV'INT, <EXTERNAL DEV'INT>>	;;INTERRUPT SERVICE CONSO INSTRUCTION
>

	IFE	PI, <
		XWD DEV'N*100+0,0	;;NO PI CHANNEL FOR THIS DEVICE
	>
	IFG	PI, <
		XWD DEV'N*100+PI,DEV'INT	;;FIRST WORD OF INTTAB ENTRY
		IFE DEV'N,<IFNDEF FTCMBTH,<EXTERNAL DEV'INT>> ;;LEVEL D DISK IN COMMOD
	>

	IFG	DEV'N-1,<
		XWD <LOCSTA*1000>+DEV'DDS##,DEV'DDB	;;MULTIPLE DEVICE SECOND WORD OF INTTAB ENTRY
	>
	IFE	DEV'N-1, <
		XWD <LOCSTA*1000>,DEV'DDB		;;SINGLE DEVICE SECOND WORD OF INTTAB ENTRY
	>
> ;;END IFDIF ABOVE
>		;;END ASGSV1 DEFINITION

DEFINE ASGSVN (DEV,X,PI) <
	IFG	PI, <
	IFE	<PI-.CH>, <.CHAS==1	;;CHANNEL PI IN USE.
>
		DEV'X'CHN==:PI&7	;;DEFINE DEVICE CHANNEL NUMBER
		DEV'X'CH1==PI		;;USED AFTER CH'PI DEFINITIONS
	ASGSV2	DEV'X,\PI
>

IFG PI, <
IF2, < IFNDEF DEV'X'INT, <EXTERNAL DEV'X'INT>> ;;INTERRUPT SERVICE CONSO INSTRUCTION
>

	IFG	PI, <
	IFE ISDSK,<
	IFNDEF DEV'X'N,<DEV'X'N==1>
		EXP <DEV'X'N>B11!<PI>B17!DEV'X'INT
	IF2,<IFNDEF DEV'X'DDB,<EXTERN DEV'X'DDB>>
	IFE DEV'X'N-1,<
		EXP <LOCSTA>B8!DEV'X'DDB
	>
	IFN DEV'X'N-1,<
	IF2,<IFNDEF DEV'X'DDS,<EXTERN DEV'X'DDS>>
		EXP <LOCSTA>B8!<DEV'X'DDS>B17!DEV'X'DDB
	>
	>
	IFN ISDSK,<
		EXP <PI>B17!DEV'X'INT##
		EXP <LOCSTA>B8!DSKDDB## ;;SECOND WORD
		IF1,<IFNDEF DSKCHN,<DSKCHN==:DEV'X'CHN>>
		DEFBIT DEV'X
		DSKPIF==:DSKPIF!DEV'X'BIT ;;KEEP LOG. OR OF PI OFF BIT FOR DSK CONTROLLERS
		DSKPIN==:DSKPIN!DEV'X'BIT ;;AND FOR PI ON
	>
	>
>		;;END ASGSVN DEFINITION

DEFINE MLUASG (DEV,DE,PI,X)<
	PI1==PI
	ZZ==0
	CPN==0
	ISDSK==0
	IFNB <X>,<ISDSK==1>
	REPEAT	M.CPU,<
	DVNASG	\CPN,DEV,DE,PI1
	CPN==CPN+1
	PI1=PI1+10
	>
>

DEFINE DVNASG (CPU,DEV,DE,PI)<
	REPEAT	M'CPU'DEV,<
	ASGSVN	DE,\ZZ,PI
	ZZ==ZZ+1
	>
>
;;MACRO'S TO ALLOW GENERATION OF MULTIPLE INTTAB ENTRIES FOR MULTIPLE
;; DEVICES SUCH AS LINE-PRINTERS

DEFINE MULASG (DEV,DE,PI,DSKFL) <
	IFG	DEV'N, <
		ZZ==0
		REPEAT DEV'N, <
			DEVASG DE,\ZZ,PI,DSKFL
			ZZ==ZZ+1
		>
	>
>

DEFINE DEVASG (DE,X,PI,DSKFL) <
	IFE	DSKFL,<DE'X'N==1>	;;DSKFL=1 IF NOT LEVEL D DISK
	IFN	DSKFL,<DE'X'N==0>	;;DSKFL=ZERO IF LEVEL D DISK
	ASGSV1	DE'X,\PI
>


;;MACROS TO CONTROL ASSIGNMENT OF PI CHANNELS TO DEVICES

DEFINE NEXTCH <	.CH==.CH+1	;;START ASSIGNING TO NEXT LOWER CHANNEL
.CHAS==0
NEXTCU \.CH
>
DEFINE NEXTCQ <	IFN .CHAS, <NEXTCH>>	;;START ASSIGNING TO NEXT LOWER CHANNEL IF
					;; CURRENT CHANNEL HAS BEEN USED.
DEFINE NEXTCU (N) < IFDEF UNIQ'N, < IFN UNIQ'N, <NEXTCH>>	;;TO SKIP OVER ANY
					;; SPECIALLY SPECIFIED CHANNELS (RECURSIVELY!)
		IFDEF RTCH'N,<IFN RTCH'N,<NEXTCH>>>	;IF RTCH'N IS DEFINED
					;DURING MONGEN, THAT CHANNEL WILL BE FREE FOR RT DEVICES

DEFINE DEFBIT (DEV) <
	DEV'BIT==1
	REPEAT	7-DEV'CHN, <DEV'BIT==DEV'BIT*2>
>

DEFINE UNIQDEF(N)
<	UNIQ'N==1
IFDEF	RTCH'N,<IFN RTCH'N,<
	PRINTX	?PI CHAN N CAN NOT BE RESERVED FOR REAL-TIME
	PRINTX	?IT IS NEEDED FOR BLKI/BLKO
>>>
DEFINE	MULINT,	(DEV,DE,PI) <
	ZZ==0
	PI1==PI
	CPN==0
	REPEAT M.CPU,<
		MULIN1 \CPN,DEV,DE,\PI1
	CPN==CPN+1
	PI1==PI1+10
	>
>

DEFINE	MULIN1(CPU,DEV,DE,PI)<
	REPEAT	M'CPU'DEV,<
	MULFLG	DE,\ZZ,\PI
	ZZ==ZZ+1
	>
>

DEFINE	MULFLG,	(DE,X,PI) <
	ASGSVE	DE'X,\PI
>

;;INITIALLY ASSUME NO PI CHANNEL SAVE ROUTINES NEEDED

DEFINE	USED(PI),<
	USED'PI==0
>
ZZ==0
REPEAT	M.CPU,<
ZZ==ZZ+1
REPEAT	7,<
	USED	\ZZ
ZZ==ZZ+1
>>
;MACRO TO ALLOW GENERATION OF CHANNEL SAVE ROUTINES ONLY

DEFINE SPASGSAV (DEV,PI,%ACNUM) <
	HIAC'PI==:%ACNUM
	DEV'HAC==:%ACNUM

	ASGSV2	DEV,PI
>

DEFINE ASGSV2 (DEV,PI) <
		USED'PI==:1		;SET FLAG SO THAT A CHANNEL SAVE
					; ROUTINE WILL BE GENERATED FOR
					; THIS PI CHANNEL

	IFNDEF	SAV'PI, <		;DUMMIES FOR PASS 1
		DEV'PDP==0		;APR INTERRUPT STUFF WON'T ASSEMBLE IN
		DEV'PD1==0		; A PSECT'D MONITOR WITHOUT THESE
	>; END IFNDEF
	IFDEF	SAV'PI, <		;WAIT TILL CHANNEL SAVE ROUTINES
					; ARE DEFINED BELOW (IN PASS 2)

		DEV'SAV==:SAV'PI	;CHANNEL AC SAVE ROUTINE LOCATION
	IFN <M.KS10&M.DECN>,<
		DEV'SVD==:SAV'PI'D
		>
		DEV'SV==:SAV'PI		;USED BY DISKS
		DEV'RET==:RET'PI	;CHANNEL AC RESTORE ROUTINE LOCATION
					; (USUALLY POPJ USED)
		DEV'CHL==:CH'PI		;LOCATION WHERE INTERRUPT PC IS STORED
		DEV'SAC==:SVAC'PI	;STARTING CHANNEL SAVE LOCATION FOR AC'S
		DEV'PDP==:C'PI'PDP	;LOCATION WHERE P STORED
		DEV'PD1==:C'PI'PD1	;PUSHDOWN LIST
		DEV'JEN==:C'PI'JEN	;LOCATION WHERE INT. IS DISMISSED
>>
;NOW GENERATE THE TABLE FOR ONCE AND DEFINE PI CHANNEL ASSIGNMENTS


		CTYN==:1		;ALWAYS ONE CTY
IFN M.NET,<
		NETN==1		;ONLY ONE DDB
>
		SCNN==:JOBN+TTXTRA	;NUMBER OF SCN DDB
				; ONE FOR EACH JOB + NULL JOB (EXTRA ONE)
		AP0N==1		;ALWAYS AN APR
		CK0N==1		;ALWAYS LOWEST PRIORITY CLOCK

IFG <CPUN-1>,<	AP1N==1		;SLAVE PROCESSOR EXISTS
		CK1N==1	;SO DOES ITS CLOCK OR SCHEDULER CHANNEL
>
IFE <CPUN-1>,<	AP1N==0	;SLAVE DOES NOT EXIST
		CK1N==0	;NOR DOES ITS CLOCK LEVEL
>

	DSKPIN==:2000	;SET PI ON BIT - WILL ALSO HAVE PI ON FOR DISK CONTOLLERS
	DSKPIF==:1000	;AND FOR PI OFF


INTTAB::!		;TABLE OF DATA FOR DEFINING PI CHAN AND NUMBER OF DOB
	NOSAV==0	;DO NOT SUPPRESS GENERATION OF SAVE ROUTINES
	INTTB1==:INTTAB+1
;PTY AND SCN MUST BE THE FIRST TWO ENTRIES IN INTTAB
	ASGSAV	PTY,0		;NO PI CHANNEL FOR PTY
	ASGSAV	SCN,0
IFN M.MSG,<			;IF WE WANT MSGSER
IFE FTMSGSER,<
PRINTX	?PLEASE ASSEMBLE WITH FTMSGSER =-1
>
	EXTERN	MSGSER
	XWD	0,0		;NO DDB ON NO PI CHANNELS
	XWD	0,MPXDDB##	;BUT WE WOULD LIKE TO BE PUT ON THE CHAIN
>
IFN M.KDUP,<
	XWD	0,0		;IF A KS, LINK IN THE PROTOTYPE KDP DDB
	XWD	0,KDPDDB##	; NO PI CHANNELS
IF2,<
	ASGSV2	KDP,\SCNCHN
>>

IFN M.DMRN,<
	XWD	0,0		;IF A KS, LINK IN THE PROTOTYPE DMR DDB
	XWD	0,DMRDDB##	; NO PI CHANNELS
IF2,<
	ASGSV2	DMR,\SCNCHN
>>

IFN	FTKL10,<
	XWD	0,0		;IF A KL, LINK IN THE PROTOTYPE DTE DDB
	XWD	0,DTEDDB##	;NO PI CHANNELS
>
.CHAS==0
.CH==0
NEXTCH		;BEGIN AT CHANNEL 1

;THE FOLLOWING DEVICES MUST HAVE A UNIQUE, HIGH PRIORITY
; CHANNEL FOR BLOCK I/O TRANSFERS.

;PDP10 MAGTAPE BLKI/BLKO PI CHANNEL:

IFNDEF MTDCHN,< IFG TM10A,<
	XP	MTDCHN,.CH
	UNIQDEF(\.CH)
	NEXTCH>>

IFNDEF BLKMXC, <BLKMXC==.CH>	;REMEMBER THIS CHANNEL ON PASS 1
.CH==BLKMXC			;ON PASS 2, SKIP OVER BLKI CHANNELS
;THE FOLLOWING ARE GROUPED ON A HIGH PRIORITY CHANNEL, BUT DO NOT
; WRITE INTO THE INTERRUPT LOCATIONS

IFE M.KS10,<
	MLUASG	CDR,CR,.CH
>
	MULASG	DCDR,FC,0	;TAKE CARE RSX-20F CARD READERS
DEFINE DTADF1(X),<
ASGSVE	D'X'D,PI1
>

DEFINE DTADEF(CPU),<
REPEAT M'CPU'TD10,<
	DTADF1(\"ZZZ)
	ZZZ==ZZZ+1
>
>

DEFINE GENDTA,<
ZZ==0
ZZZ=="A"
PI1==.CH
ISDSK==0
REPEAT M.CPU,<
	DTADEF(\ZZ)
ZZ==ZZ+1
PI1==PI1+10
>
>
	GENDTA

NEXTCQ

;THE FOLLOWING ARE GROUPED ON A CHANNEL FOR HIGH-PRIORITY DEVICES
DEFINE RTCDEF(X)<
IFG M.RT'X,<
	ASGSVE	RT'X,PI1
>>

ZZ==0
PI1==.CH
REPEAT M.CPU,<
	RTCDEF	\ZZ
ZZ==ZZ+1
PI1==PI1+10
>
	MLUASG	CDP,CP,.CH

ZZ==0
PI1==.CH
REPEAT M.CPU,<
	MULFLG	AP,\ZZ,\PI1
ZZ==ZZ+1
PI1==PI1+10
>
NEXTCQ

;THE FOLLOWING ARE MEDIUM-PRIORITY DEVICES, AS A GROUP
	ASGSVE	SCN,.CH

	XP	SCNBIT,1_<7-SCNCHN>

IFN	M.TTG0,<
	ASGSVE	DL0,.CH
>
IFN	M.TTG1,<
	ASGSVE	DL1,.CH
>
IFN	M.68L0,<
	ASGSVE	CC0,.CH
>
IFN	M.68L1,<
	ASGSVE	CC1,.CH
>


	MLUASG	PTR,PR,.CH
IFE M.KS10,<
	MULINT	CDR,CF,.CH
>
IFN M.KS10,<
	MLUASG	PTP,PP,.CH
	MLUASG	CDR,CR,.CH
DEFINE RX2DF1(x),<
	ASGSVN	RX,x,PI1
>;RX2DF1
DEFINE RX2DEF(CPU),<
    REPEAT M'CPU'RX20,<
	RX2DF1(\"ZZZ)
	ZZZ==ZZZ+1
    >;;REPEAT
>;RX2DEF
DEFINE GENRX2,<
    ZZ==0
    ZZZ=="A"
    PI1==.CH
    ISDSK==0
    REPEAT M.CPU,<
	RX2DEF(\ZZ)
	ZZ==ZZ+1
	PI1==PI1+10
    >;;REPEAT
>;GENRX2
	GENRX2
>;M.KS10
	MLUASG	LPT,LP,.CH
	MULASG	DLPT,FL,0	;TAKE CARE OF RSX-20F LINEPRINTER
DEFINE DTADF1(X),<
ASGSVN	DT,X,PI1
>
	GENDTA
	MLUASG	TAPN,MT,.CH

	ASGSAV	MTC,.CH
IFN M.KS10,<
DEFINE	CTYDEF(X),<
	SPAXGINT CT'X,PI1
>
	PI1==.CH
	ZZ==0
	REPEAT M.CPU,<
		CTYDEF	\ZZ
	ZZ==ZZ+1
	PI1==PI1+10
	>
>;END IFN M.KS10

IFN M.KL10,<

IFN M.ENET,<
;DEFINITIONS FOR THE KLNI

	XP	KNICHN,.CH	;KLNI PI ASSIGNMENT
DEFINE KNIDEF(CPU,PI),<
	ASGSV2	KN'CPU,PI
>; END DEFINE KNIDEF
	PI1==.CH
	ZZ==0
REPEAT M.CPU,<
	KNIDEF(\ZZ,\PI1)
	PI1==PI1+10
	ZZ==ZZ+1
>; END REPEAT M.CPU
>; END IFN M.ENET

; DEFINITIONS FOR THE DTE

	XP	SPCPI,.CH	;SECONDARY PROTOCOL PI ASSIGNMENT
	XP	PPCPI,.CH	;PRIMARY PROTOCOL PI ASSIGNMENT
DEFINE	DTEDEF(X,Y,PI)<
	ASGSV2	D'X'Y,PI
>
	ZZ==0
PI1==.CH
REPEAT	M.CPU,<
ZZZ==1
REPEAT	4,<
	DTEDEF(\ZZ,\ZZZ,\PI1)
ZZZ==ZZZ+1
>
PI1==PI1+10
ZZ==ZZ+1
>
>;END IFN M.KL10

IFN DL10XI,<
;ADD THE DL10 AT THE END OF THE SCANNER CHANNEL.  NOW YOU WOULD THINK THAT
;	SINCE THE DL10 IS RUN IN VECTORED INTERRUPT MODE, YOU WOULDN'T NEED
;	TO LOOK AT THE DL10 AT 40+2*N CONSO TIME BUT IT TURNS OUT THAT YOU
;	DO.  IT SEEMS THAT SOME (BUT NOT ALL) DL10'S LIKE TO IGNORE THE VECTOR
;	ADDRESS AND CAUSE OLD STYLE INTERRUPTS AND EVEN THEN, NOT ALL THE TIME.
;	THE DL10 ON OUR DEVELOPMENT SYSTEM ACTS LIKE THIS MOST OF THE TIME.
;	IF YOUR DL10 ALWAYS (OR ALMOST ALWAYS) TAKES THE VECTORED INTERRUPT
;	THIS CODE IS IN THE RIGHT PLACE (WILL HARDLY EVER GET THIS FAR ON THE
;	CONSO SKIP CHAIN).  IF IT LIKES TO ACT LIKE A KA-10 DEVICE, MOVE THIS
;	UP (BEFORE "PTR" ASSIGNMENTS) TO SERVICE THEM A LITTLE FASTER.

	ASGSVE	DLX,.CH

IFN M.DAS78,<			;IF WE HAVE DAS78 SUPPORT
	XXIN==	M.D78L		;NUMBER OF LINES
	ASGSAV	XXI,.CH

	XXON==	M.D78L		;NUMBER OF LINES
	ASGSAV	XXO,0		;JUST GENERATE DDB'S
> ;END IFN M.DAS78
> ;END IFN DL10XI

IFN M.NET,<
;DEFINE THE SYMBOLS FOR THE "NETWORK FRONT END" CHANNEL
;  NOTE THAT BOTH THE DTE-20 AND THE DL-10 MUST BE ON THE
;  SAME CHANNEL

	XP	NTFCHN,.CH	;THE NETWORK FRONT END CHANNEL
	XP	NTFBIT,1_<7-NTFCHN>
	XP	NTFIIP,1_<7-NTFCHN+^D8> ;INTERRUPT IN PROGRESS
>

NEXTCQ
;THE FOLLOWING ARE LOWER-PRIORITY DEVICES, AS A GROUP
;FIRST ARE THE VARIOUS TYPES OF DISK CONTROLLERS....

IFN LEVDN,<
	MLUASG	FHD,FH,.CH,1
	MLUASG	FSD,FS,.CH,1
	MLUASG	RPX,RP,.CH,1
	MLUASG	RNX,RN,.CH,1
	MLUASG	DPC,DP,.CH,1
	MLUASG	MDF,MD,.CH,1
IFN M.KS10,<
	MLUASG	RHX,RH,.CH,1
>
>	;END CONDITIONAL ON LEVDN

IFN	FTXTC,<
IFN	M.XTC,<
	MULASG	XTC,XT,.CH,0
	XP	XTCBIT,1_<7-XT0CHN>
>>
	ASGSAV	PEN,.CH
IFE M.KS10,<
	MLUASG	PTP,PP,.CH
>
IFN CDPN,<
	MULINT	CDP,CG,.CH
>;END IFN CDPN
	MLUASG	PLT,PL,.CH



	ASGSAV	VBC,.CH

NEXTCQ


;THE DISPLAY GETS ITS OWN LOW-PRIORITY CHANNEL
	ASGSAV	DIS,.CH

NEXTCQ
;THE NETWORK WANT'S TO RUN ON ANY CHANNEL BETWEEN CLOCK(7) AND DISK
IFN M.NET,<

;DEFINE THE NETWORK SOFTWARE INTERRUPTS.  LINK CHAIN ON ALL CPU'S
DEFINE	NETDEF(CPU),<
	ASGSVE	NT'CPU,\<.CH+<CPU_3>>
>

ZZ==0
REPEAT	CPUN,<
	NETDEF	\ZZ
	ZZ==ZZ+1
>
	XP	NETCHN,NT0CHN
	XP	NETBIT,1_<7-NT0CHN>
	XP	NETIIP,1_<7-NT0CHN+^D8>	;INTERRUPT IN PROCESS
	XP	REQNET,PI.IIO+NETBIT	;CONO PI,REQDXX REQUEST INTERRUPT
	XP	CLRNET,II.CPP+NETBIT	;CONO PI,CLRDXX CLEAR INTERRUPT

	ASGSAV	NET,0		;TO GENERATE A DDB AT THE END OF THE LIST
				;NOTE!! THIS MUST BE THE LAST DDB.
>

NEXTCQ
;LAST IS THE SCHEDULER, ON CHANNEL 7 BY ITSELF

IFG <.CH-7>, <	PRINTX ?NOT ENOUGH PI'S TO SERVICE THIS CONFIGURATION.
		PRINTX ?SUGGEST EDITING COMMON TO PUT MORE DEVICES ON
		PRINTX ? A SINGLE CHANNEL
>

.CH==7

DEFINE CLKDEF(X)<
	CK'X'N==1
	ASGINT	CK'X,\PI1
>
ZZ==0
PI1==.CH
REPEAT M.CPU,<
	CLKDEF(\ZZ)
ZZ==ZZ+1
PI1==PI1+10
>


;NOW FOR SOME PI SYSTEM MASKS FOR DISK, SCANNER, AND NETWORK INTERLOCKS

IFE M.NET,<			;IF NO NETWORKS
	NTFBIT==0		; DON'T FOOL WITH ANY
	NETBIT==0		; PI CHANNELS
	NTFCHN==0		; ..
	NETCHN==0		; ..
>

IFG CPUN-1,<			;FOR MULTI-PROCESSORS

	XP	DSKPIN,DSKPIN!NTFBIT!NETBIT!SCNBIT	;INCLUDE SCANNER AND NETWORKS
	XP	DSKPIF,DSKPIF!NTFBIT!NETBIT!SCNBIT
	XP	SCNPIN,DSKPIN!1			;INCLUDE DISKS, NETWORKS, CH7
	XP	SCNPIF,DSKPIF!1
	XP	NETPIN,DSKPIN!1			;INCLUDE DISKS, SCANNER, CH7
	XP	NETPIF,DSKPIF!1
>
IFE CPUN-1,<			;FOR SINGLE PROCESSORS

	XP	SCNPIN,2000!SCNBIT!NTFBIT!NETBIT!1 ;ONLY SCANNER, NETWORKS, CH7
	XP	SCNPIF,1000!SCNBIT!NTFBIT!NETBIT!1
IFN M.NET,<
	XP	NETPIN,2000!SCNBIT!NTFBIT!NETBIT!1 ;ONLY NETWORKS, SCANNER, CH7
	XP	NETPIF,1000!SCNBIT!NTFBIT!NETBIT!1
>
IFE M.NET,<
	XP	NETPIN,2000!SCNBIT!1			;INCLIDE SCANNER
	XP	NETPIF,1000!SCNBIT!1			;AND CH7
>>
IFG TAPN,<
;IF THE PROCESSOR DOES A TAPOFF AT UUO LEVEL,
;THE TAPE CH IS TURNED OFF, BUT AN INTERRUPT
;ON THE DSK CH MIGHT STILL BE POSSIBLE (AND OTHERS).
;IF THE INTERRUPT DOES A DSKOFF/DSKON, THE
;TAPE CH MAY BE TURNED BACK ON.
;CURE:  MAKE TAPOFF DISABLE DISK INTERRUPTS ETC.

DEFINE XX(AA,BB),<
IFN  BB&TAPBIT,<XP AA,AA!BB>>
	XP	TPION,PI.TNP!TAPBIT
	XX	TPION,DSKPIN
	XX	TPION,SCNPIN
	XP	TPIOFF,PI.TFP!TAPBIT
	XX	TPIOFF,DSKPIF
	XX	TPIOFF,SCNPIF
IFN M.NET,<
	XX	TPION,NETPIN
	XX	TPIOFF,NETPIF
>
> ;END IFG TAPN
	SPCINT
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NOT USE A CHANNEL SAVE ROUTINE AND HAVE
				; NO DEVICE DATA BLOCK
	SPCDDB
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				;WHICH HAVE MULTIPLE DEVICE DATA BLOCKS (0 MEANS NONE)
	SPCSAV
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NEED A CHANNEL SAVE ROUTINE

;END OF THE ASSIGNMENT TABLE

	INTNUM==:INTTAB-.	;-LENGTH OF INTERRUPT CHANNEL ASSIGNMENT TABLE
SUBTTL NON-ZEROED DATA BASE
	IFLE	.-SYSEND, <LOC SYSEND+1>
				; SET LOC UP TO SYSEND+1, UNLESS ONCE ONLY CODE
				; IS BIGGER

; THE FOLLOWING DATA MUST NOT RESIDE WITHIN THE RANGE SYSBEG-SYSEND.
; IT CAN'T BE ZEROED WHEN SYSGED-SYSEND IS ZEROED BECAUSE A STOPCODE
; MIGHT HAVE OCCURED EARLY ON IN THE SYSTEM STARTUP CODE, AND THESE
; BLOCKS MAY HAVE BEEN WRITTEN INTO.  THERE'S REALLY NO REASON TO
; ZERO THIS STUFF ANYWAY, SYSTEM RESTARTS (OF THE 143 TYPE) DON'T WORK.

CLKNEW::0			;FLAG TO FORCE RECOMP OF CLKMIN
CLKMIN::BLOCK	M.CPU		;MIN TIME TO EXPIRE FOR THIS CPU
IFNDEF M.PWQC,<			;NUMBER OF EXTRA ENTRIES
	IFE FTMP,<M.PWQC==1>
	IFN FTMP,<M.PWQC==11>
>
	SLJOBN=JOBN+M.PWQC	;NUMBER OF CLOCK ENTRIES
CIPWT::	BLOCK	2*<SLJOBN>	;CLOCK REQUEST QUEUE
				;WORD 0 - RH=COUNT DOWN JIFFY TIMER
				;	- LH=ROUTINE TO CALL
				;
				;WORD 1 - RH=DATA MEM RETURNED
				;	- BIT 0=REQUEST IS CPU SPECIFIC
				;	- BITS 1-3=CPU#
				;	- BIT 4=SCANNED BY CLOCK1
CIPWTE::!			;FIRST WORD AFTER CIPWT. USED TO CHECK OVERFLOW
	CIPWTM==:CIPWT-1	;FIRST LOC-1 OF CLOCK QUEUE


DIECDB::0			;POINTER (IN PHYSICAL MEMORY) TO CDB IN USE AT
				;STOPCODE TIME. USED TO FACILITATE LOOKING AT
				;DUMPS.
;SPECIAL DEVICE SYMBOLS WHICH INVOLVE PI ASSIGNMENTS
; GOAL: MINIMIZE NO. OF SYMBOLS DEFINED HERE:
;
;    MAGTAPE PI SYMBOLS
IFG TAPN,<		;ANY MAGTAPES?

IFG TM10A+TM10B,<
	IFNDEF	MTDCHN,<XP MTDCHN,0>
	XP	MTAFLG,MT0CHN*10
	XP	MTBOTH,MTAFLG
IFG TM10A,<
	XP	MTBOTH,MTBOTH+MTDCHN
	XP	MTALOC,.EPMP+2*MTDCHN+40
>>

	XP	TAPCHN,MT0CHN
	XP	TAPBIT,<1_<7-MT0CHN>>
> ;END IFG TAPN

;    DECTAPE PI SYMBOLS

IFN M.DTXN,<
	XP	DTBOTH,DADCHN*10+DTACHN	;2ND DECTAPE PI
	XP	DTTURN,300200+DTBOTH
>

;	CDR PI ASSIGNMENTS
IFG M.CDR,<
IFE M.KS10,<
	XP	CRFCHN,CF0CHN
>
	XP	CDRCHN,CR0CHN
>
;    LINE PRINTER PI SYMBOLS
DEFINE	FLAGS(N)<
	XP	LP'N'BTH,LP'N'CHN*11
>
ZZ==0

REPEAT M.LPT,<
	FLAGS	\ZZ
ZZ==ZZ+1
>


;    DISPLAY PI SYMBOLS
IFG M.DIS,<			;DISPLAY
	XP	DISBLK,.EPMP+40+2*DISCHN	;BLKI/BLKO LOCATION
	XP	PENPIA,PENCHN*10	;PEN PI ASSIGNMENT FOR CONO
	XP	DISBTH,DISCHN+PENPIA	;BOTH DIS AND PEN PIS FOR CONO
XP DISBIT,1
REPEAT	7-DISCHN,<XP DISBIT,DISBIT*2>
>
IFN M.KS10,<
;UBA PI SYMBOLS
	XP UBA1PI,DSKCHN*10		;DISK PI
	XP UBA3PI,TAPCHN*10+SCNCHN	;TAPE, COMM & UNIT RCD PI'S
>
;BLOCKS FOR SAVE/RESTORE OF MAPPING FOR EDDT

SYMSIZ==:270
SYMBK1:: BLOCK	SYMSIZ		;FILLED IN BY ONCE WITH NEW MAPPING INFO
SYMBK2:: BLOCK	SYMSIZ		;WHERE DDT SAVES OLD CONTENTS OF MAP


;SYSTEM CONSTANTS AND PARAMETERS



CNFTBL::			;FIRST LOCATION OF MONITOR DATA STORAGE
				; RETURNED BE GETTAB UUO (THESE LOCATIONS
				; NOT CLEARED BY SYSINI)
				; CNFTBL IS GETTAB TABLE 11 (RH OF AC)
				; OCTAL NUMBERS IN () CORRESPOND TO GETTAB UUO AC'S LH
CONFIG::SYSNAM
				;(0-4) NAME OF SYSTEM, IN ASCII
	LOC	CONFIG+5	;ALWAYS LEAVE 5 WORDS (24 CHARS)
				; SO GETTAB UUO WILL BE CONSTANT
SYSDAT::SYSDAT
				;(5,6) GENERATE SYSTEM DATE
	LOC	SYSDAT+2	;ALWAYS LEAVE 2 WORDS SO GETTAB CONSTANT
SYSTAP::SYSDEV
				;(7) NAME OF SYSTEM DEVICE, IN SIXBIT

;LOCATIONS SETUP BY ONCE ONLY OPERATOR DIALOGUE AND NEVER RESET ON RESTARTS


TIME::	0			;(10) TIME OF DAY IN JIFFIES (60TH OR 50THS OF A SEC)
THSDAT::0			;(11) TODAY'S DATE ((Y-1964)*12+(M-1))*31+(D-1)
SYSSIZ::EXP	PAT##		;(12) SIZE OF MONITOR (FIRST LOC NOT USED)
DEVOPR::			;(13) SIXBIT PHYSICAL NAME OF OPERATORS CONSOLE
IFNDEF OPRLIN,<SIXBIT /CTY/>	;AT THE CENTRAL (PDP10) SITE
IFDEF OPRLIN,<OPRLIN;>;		; (IF THIS LOCATION CONTAINS 0, NONE HAS
				;  BEEN DESIGNATED)
				;PUBLIC LOGICAL NAME "OPR" WILL BE THIS DEVICE.
				; ALSO UNEXPLAINED MONITOR ERROR MESSAGES
				; WILL BE TYPED ON TTY OPR
DEVLST::XWD	0,0		;(14) LH CONTAINS ADDRESS OF FIRST DEVICE DATA BLOCK
				; ONCE ONLY CODE LINKS DEVICE DATA BLOCKS
SEGPTR::XWD	-SEGN,JOBN	;(15) AOBJN POINTER TO 1ST HIGH SEG IN JBTXXX TABLES
				; LH= - NUMBER OF HIGH SEGS,  RH= 1ST HIGH SEG NUMBER
	EXP	-1		;(16) FLAG TO INDICATE WHETHER BOTH HARDWARE AND
				; SOFTWARE HAVE 2 RELOC REG CAPACITY
				; NON-ZERO IF BOTH DO, 0 IF EITHER OR BOTH DO NOT
				; SET BY ONCE ONLY CODE

;STATES WORD LH BITS:
	ZZ==0
	IFG	DSKN, <ZZ==ZZ!ST.DSK>	;1 IF DISK SYSTEM (ANALOGOUS TO FTDISK)
	IFG	SYS50N, <ZZ==ZZ!ST.SWP>	;1 IF SWAPPING SYSTEM (ANALOGOUS TO FTSWAP)
	IFG	LOGINN, <ZZ==ZZ!ST.LOG>	;1 IF LOGIN (ANALOGOUS TO FTLOGIN)
	ZZ==ZZ!ST.FTT			;1 FOR TTCALL, FULL DUPLEX
	ZZ==ZZ!ST.PRV			;1 FOR PRIVILEGE CHECKING
	ZZ==ZZ!ST.TWR			;1 IF REENTRANT SOFTWARE
	IFN	LEVDN,<ZZ==ZZ!2B9>	;1 IF LEVEL D DISK SOFTWARE (ST.TDS)
	IFN	INDPPN,<ZZ==ZZ!ST.IND>	;1 IF INDEPENDENT PROJ-PROG NUMBERS
	ZZ==ZZ!ST.IMG			;1 FOR IMAGE, 8-BIT SCNSER
	IFG	CPUN-1,<ZZ==ZZ!ST.DUL>	;1 IF DUAL CPU SYSTEM
	ZZ==ZZ!ST.MRB			;1 IF MULTIPLE RIBS
IFG	M.RTCA,<ZZ==ZZ!ST.HPT>		;1 IF HIGH PREC.TIME ATTC.
IFG	M.RTCO,<ZZ==ZZ!ST.EMO>		;1 IF EXCLUDE MON.OVERHEAD FROM USER RUN TIME
IFG	M.RTX,<ZZ==ZZ!ST.RTC>		;1 IF MONITOR HAS REAL TIME CLOCK
	ZZ==ZZ!ST.MBF			;1 IF MONITOR BUILT TO HANDLE FOROTS

;STATES WORD RH BITS(INDICATE OPERATIONAL STATE OF SYSTEM):
;PATCHED BY SCHED COMMAND

		;1B35(ST.NLG) = NO LOGIN(EXCEPT FROM OPR)
		;1B34(ST.NRL) = NO LOGINS FROM REMOTE TTYS. DONT
		; ANSWER RINGING DATA SETS. "REMOTE" BIT IN
		; LINTAB IS SET BY MONGEN
		;1B33(ST.BON) = NO LOGINS EXCEPT BATCH JOBS EXCEPT FROM OPR
		;1B29(ST.ASS)=1 NO ASSIGN/INIT DEVICES
		;1B28(ST.NSP)=1 IF ANY JOB CAN UNSPOOL DEVICES
		;1B27(ST.NOP)=1 NO OPERATOR
		;1B26(ST.DDL)=1 NO DOWN LINE LOAD OF REMOTE DC71,DC72,DAS80'S

STATES::EXP	ZZ!SCHEDN	;(17) BITS WHICH DEFINE TYPE OF SYSTEM IN LH
				; RH PATCHED BY MONITOR COMMAND TO
				; INDICATE OPERATIONAL STATE OF SYSTEM
SERIAL::EXP	APRSN		;(20) SERIAL NUMBER OF CENTRAL PROCESSOR (APR)
MEMNSP::EXP	NSPMEM		;(21) NANO-SEC PER MEMORY CYCLE
PTYCNF:	XWD	PTYOFS##,PTYN	;(22) PTY PARAMETERS FOR BATCH
FREPTR::0			;(23) AOBJN WORD POINTING TO USE BIT MAP OF
				; MONITOR 4-WORD CORE BLOCKS. SET BY ONCE ONLY CODE
				; NEVER CHANGED WHILE MONITOR RUNS.
LOCORE::0			;(24) LH=0, RH=ABS. ADR. IN MONITOR OF FIRST WORD OF
				; MONITOR TO BE ALLOCATED IN 4-WORD CHUNKS.
				; SET BY ONCE ONLY CODE AND NEVER CHANGED WHILE
				; MONITOR RUNS.
STBPTR::EXP	0		;(25) POINTER NOT USED WITH NETWORKS
OPRLDB::0			;(26) LDB OF OPR TELETYPE
TTFREE::0			;(27) FILLED IN AT ONCE TIME BY FREE LIST ADR
IFNDEF TTCHKN,<EXTERNAL TTCHKN>
TTCLST::XWD	TTCHKN,0	;(30) NUMBER OF TTY CHUNKS, ADDRESS OF FIRST ONE
TTFREN::0			;(31) NUMBER OF FREE TTY CHUNKS AT THE MOMENT
LINSAV::0			;(32) POINTER TO CURRENT TTY SEEN BY COMMAND DECODER
LINPTR::XWD MTTYLN##,LINTAB##	;(33) POINTER TO EXAMINE TTY LINE TABLE,
				; INCLUDING REMOTES
MONVER::EXP	A00VER		;(34) VERSION OF MONITOR (LH FOR CUSTOMER)
DSCPTR::XWD MDSLN##,DSCTAB##	;(35) POINTER TO DATASET CONTROL TABLE

DLSRWD::0			;(36) LAST RECEIVE INTERRUPT FROM DC10
CCIRWD::0			;(37) LAST RECEIVE INTERRUPT FROM 680
SEGPT1::EXP	JOBN		;(40) LAST DORMANT SEG NUMBER THROWN AWAY
				; TO FREE UP A SEG NUMBER.
LASPOK::0			;(41) CONTAINS ADR. OF LAST LOCATION CHANGED
				; IN MONITOR BY A SUCCESSFUL POKE UUO.  (NOT CLEARED
				; ON 403 RESTART SINCE CHANGE IS STILL VALID
LASPUC::0			;(42) RH=COUNT OF NUMBER OF SUCCESSFUL POKE UUOS
				; SINCE SYSTEM WAS LOADED.
				; LH=JOB NO. OF LAST JOB WHICH
				; SUCCEEDED IN CHANGING MONITOR VIA POKE
				; THE TWO ABOVE LOCATIONS ARE USEFUL
				; IN CRASH ANALYSIS AND FOR DAEMON LOGGING
WHYCOD::0			;(43) CONTAINS SIXBIT UNABBREVIATED OPERATOR ANSWER
				; FOR WHY RELOAD ONCE ONLY QUESTION.  SEE ONCE (WHYTAB)
				; FOR A LIST OF POSSIBLE CODES.  0 MEANS FTWHY=0 SO NO
				; QUESTION
TICSEC::JIFSEC			;(44) CONTAINS NUMBER OF TICKS PER SECOND
				; SET AT ONCE ONLY TIME BY MEASURING LINE
				; FREQUENCY (50 OR 60 HERTZ)
PDBPTR:	XWD	0,JBTPDB	;(45) RH=POINTER TO TABLE OF PDB'S FOR JOBS
				; LH=0 FOR FUTURE EXPANSION

RTCUPS::0			;(46) RESOLUTION (UNITS/SEC.) OF CLOCK
				; USED FOR RUN TIME ACCT.
				; SET & CHANGED BY SETIME
SYSCHN::
IFE FTAUTC,<
	XWD	CHN0CB##,0	;(47) LH=ADR OF FIRST CHANNEL (DF10) DATA BLOCK, RH=UNUSED
>
IFN FTAUTC,<0>			;AUTCON WILL FILL THIS IN
			;LOGMAX...BATMIN CHANGED WITH SETUUO
			;  ENFORCED BY LOGIN (MONITOR ONLY STORES THESE
			;  NUMBERS FOR LOGIN)
LOGMAX::M.JMAX			;(50) MAX.# JOBS ALLOWED TO BE LOGGED IN
BATMAX::M.BMAX			;(51) MAX.# BATCH JOBS ALLOWED
BATMIN::M.BMIN			;(52) MIN.# BATCH JOBS GARENTEED (RESERVED)
IFN FTMDA,<
UDATEX::
> ;END IFN FTMDA
DATE::	0			;(53) DATE TIME IN NEW FORMAT
				; LH = DAYS SINCE NOV. 17, 1858,
				; RH = FRACTION OF A DAY (GMT)
LOGNUM::0			;(54) NUMBER JOBS CURRENTLY LOGGED IN
BATNUM::0			;(55) NUMBER BATCH JOBS CURRENTLY LOGGED IN.
LOCYER::0		;(56) LOCAL YEAR
LOCMON::0		;(57) LOCAL MONTH (1,2,...,12)
LOCDAY::0		;(60) LOCAL DAY OF MONTH (1,2,3,...)
LOCHOR::0		;(61) LOCAL HOUR (MIDNIGHT=0)
LOCMIN::0		;(62) LOCAL MINUTE (0,1,...,59)
LOCSEC::0		;(63) LOCAL SECOND (0,1,...,59)

GMTDIF::0		;(64) DIFFERENCE BETWEEN LOCAL AND GMT TIME.
			; IN SAME UNITS AS DATE --
			; E.G. DATE + GMTDIF = LOCAL DATE-TIME
			; (LH = DAY, RH = FRACT. OF DAY)
DEBUGF::DEFDEB!DEFBPT	;(65) DEBUGGING STATES WORD - SIGN BIT=1 IF SYSTEM PROG IS
			; DEBUGGING MONITOR (SPEED UP ONCE ONLY)
			; BIT1=1 TO RELOAD ON DEBUG STOPCD'S
			; BIT2=1 TO RELOAD ON STOPCD'S WHICH ONLY
			; AFFECT 1 JOB
			; BIT3=1 TO DISABLE AUTO-RELOADS
			; BIT4=1 TO STOP SYSTEM IF ANY CPU GETS A CPU STOPCD
FRUSED::0		;(66) AMOUNT OF FREE CORE IN USE
			; (FTRSP CONDITIONAL)
RCCMAX::0		;(67) HIGHEST ADDRESS USED BY TTY CHUNKS
CNFCVN:	A00CVN		;(70) CUSTOMER VERSION (=C(136))
CNFDVN:	AXXDVN		;(71) DEC VERSION (=C(137))
CNFCHN::IFE FTAUTC,<EXP M.CHN>	;(72) NUMBER OF DATA CHANNELS
IFN FTAUTC,<EXP 0>	;(72) AUTCON WILL COMPUTE IT
CNFRTD::EXP	M.RTD	;(73) NUMBER OF REAL TIME DEVICES
CNFHPQ::EXP	M.HPQ	;(74) NUMBER OF HPQ'S
CNFLDB::EXP	DDBLDB##  ;(75) WORD IN TTY DDB WHICH POINTS TO LDB
CNFMVO::EXP	PSIMVO	  ;(76)MAX. VECTOR OFFSET FOR PISYS. UUO
CNFMIP::EXP	PSIMPI	;(77)MAX. PRIORITY FOR PSISER
IFG TAPN,<
CNFMTA::XWD	TUBRID##,MT0DDB##  ;(100) POINTER TO FIRST MTA DDB AND INDEX
				   ; OF START OF DAEMON INFORMATION
>
IFE TAPN,<
CNFMTA::0
>

CNFET1:	EXP	JOBDAC##+T1	;(101) EXEC AC1 IN USER'S ADDRESS SPACE
CNFLSD:	EXP	DEVLSD		;(102) LENGTH OF SHORT DDB
CNFLLD:	EXP	DEVLLD		;(103) LENGTH OF LONG DDB
CNFLDD:	EXP	DDBLEN##	;(104) LENGTH OF DISK DDB
CNFEXM:	EXP	JOBEXM##	;(105) WORD IN JOBDAT WHICH HOLDS ADDRESS OF
				;      LAST EXAMINE OR DEPOSIT.

	ZZ==0
	ZZ==ZZ!1B35		;BIT 35=1 IF SWAP SPACE ALLOCATED IN PAGES
IFN M.TM10,<ZZ==ZZ!1B34>	;BIT 34=1 IF MTA ERROR REPORTING
	ZZ==ZZ!1B33		;BIT 33=1 IF VM MONITOR
IFN M.IPCF,<ZZ==ZZ!1B32>	;BIT 32=1 IF IPCSER IS LOADED
IFN M.PSI,<ZZ==ZZ!1B31>		;BIT 31=1 IF PSISER IS LOADED
IFN M.MSG,<ZZ==ZZ!1B30>		;BIT 30=1 IF MSGSER IS LOADED
ZZ==ZZ!1B29			;BIT 29=1 IF NON-SUPER ENTER
				; IS SUPPORTED
IFN FTNSCHED,<ZZ==ZZ!1B28>	;BIT 28=1 IF NEW SCHEDULER IS PRESENT
IFN M.EQDQ,<ZZ==ZZ!1B27>	;BIT 27 IF ENQ/DEQ IS LOADED
IF2, <ZZ==ZZ!<<ZGAL>B26>>	;BIT 26=1 IF MONITOR CONTAINS GALAXY-10 FEATURES
ZZ==ZZ!1B25			;BIT 25=1 MONITOR SUPPORTS MASSBUS ERROR REPORTING
ZZ==ZZ!1B24			;BIT 24=1 IF NEW TAPSER
ZZ==ZZ!1B23			;BIT 23=1 IF NEW ERROR REPORTING
ZZ==ZZ!1B22			;BIT 22=1 IF MONITOR SUPPORT MORE THAN 127 JOBS.
IFN  M.EXE,<ZZ==ZZ!1B21>	;BIT 21=1 IF "SAVE" COMMAND PRODUCES EXE FILE
IFN M.EMRT,<ZZ==ZZ!ST%EMR>	;BIT 20=1 IF EBOX/MBOX RUNTIME IS IN EFFECT (KL ONLY)
IFN M.XPI,<ZZ==ZZ!ST%XPI>	;BIT 19=1 IF PI TIME IS EXCLUDED FROM USER
				; RUNTIME (KL ONLY)
ZZ==ZZ!1B18			;BIT 18=1 IF FULL 6CHAR DEVICE NAMES
IFN M.ITA,<ZZ==ZZ!ST%ITA>	;BIT 17=1 IF INTERVAL TIMER ON KL10 IS AVAILABLE
IFE M.CLSS,<ZZ==ZZ!ST%NCS>	;BIT 16=1 IF NOT CLASS SYSTEM SCHED.
ZZ==ZZ!ST%NER			;BIT 15=1 MONITOR SUPPORTS 6.03 ERROR REPORTING
IFN M.ACV,<ZZ==ZZ!ST%ACV>	;BIT 14=1 IF ACCOUNT VERIFICATION SHOULD BE DONE
ZZ==ZZ!ST%LSC			;BIT 13=1 IF LOW SEGMENT OF MONITOR IS CACHED

IFN FTMDA,<ZZ==ZZ!ST%MDA>	;BIT 12=1 IF ALLOCATOR WILL RUN
ZZ==ZZ!1B11			;BIT 11=1 ALWAYS KL PAGING
IFN M.DECN,<ZZ==ZZ!1B10>	;BIT 10=1 IF DECNET LOADED
IFN FTXMON,<ZZ==ZZ!1B9>		;BIT 9=1 IF EXTENDED ADDRESSING MONITOR
IFN M.RCMP,<ZZ==ZZ!1B8>		;BIT 8=1 IF RESTRICTED COMMAND SET FOR REMOTES
IFN M.NPPC,<ZZ==ZZ!ST%NPP>	;BIT 7=1 IF DISABLING PRIMARY PROTOCOL
IFN M.DECN,<ZZ==ZZ!0B6>		;BIT 6=1 IF RUNNING AS DECNET ENDNODE
				; (SET BY DECNET INITIALIZATION CODE)
CNFST2::EXP	ZZ		;(106) FLAG BITS DEFINED ABOVE
PISYMN:EXP	M.PSI*C$MIN	;(107) MINIMUM CONDITION FOR PISYS.UUO
PITLEN:EXP	PITSIZ		;(110)LENGTH OF PI TABLE
CNFPIA::EXP	JBTPIA		;(111)ADDRESS OF JBTPIA
%CNMNT:	BYTE	(1)0(17)0(6)1(6)0(6)0	;(112) TYPE OF MONITOR
					;    (1)=STRANGE
					;    (17)=RESERVED TO DEC
					;    (6)=TYPE:	1=TOPS-10
					;		2=I.T.S.
					;		3=TENEX
					;		REST RESERVED TO DEC
					;    (6)=SUBTYPE (RESERVED TO DEC)
					;    (6)=RESERVED TO CUSTOMERS

IFN M.CDR,<
CR0DDB,,CDRCNT##		;(113)OFFSET TO CARD COUNT FOR CDR
>
IFE M.CDR,<
	EXP	0
>
IFN M.CDP,<
CP0DDB##,,CDPCTO##		;(114)OFFSET TO CARD COUNT FOR CDP
>
IFE M.CDP,<
	EXP	0
>
EXP	PAGSIZ			;(115)BASIC UNIT OF CORE ALLOCATION
EXP	MINMAX			;(116)MIN VALUE FOR CORMAX
EXP	M.CLSN			;(117)NUMBER OF SCHEDULER CLASSES
EXP	0			;(120)EXPONENTIAL FACTOR USED IN COMPUTING USER TIME
SYSORG::	0		;(121)
SYSLEN::	0		;(122)
NWCORE::2000*M.NKC		;(123)NUMBER OF WORDS OF CORE
NXMPTR::0			;(124)AOBJN POINTER TO NXMTAB USED TO SCAN FOR ZEROES
IFN M.NET,<
	EXP	NETNDB##	;(125)POINTER TO THE FIRST NODE BLOCK
>
IFE M.NET,<
	EXP	0		;(125)NO POINTER IF NO NETWORKS
>
IFG TAPN,<
CNFTKB:	EXP	TKBCDB##	;(126)POINTER FROM KDB TO CDB FOR MAGTAPES
>
IFLE TAPN,<
CNFTKB:	EXP	0		;(126)IF NO MAGTAPES
>
	EXP	0		;(127) OBSOLETE
HNGLST::XWD	0,0		;(130)LH IS ADDRESS OF FIRST DEVICE WHICH
				; SHOULD BE CHECK TO SEE IF IT IS HUNG
	EXP	BOOTXT		;(131) ADDRESS OF RELOAD CCL TEXT
IFG TAPN,<
	EXP	TUBDDB##	;(132) OFFSET OF DDB PTR'S IN TUB
CNFMTK::
IFN FTAUTC,<	0>		;AUTCON WILL FILL IT IN
IFE FTAUTC,<
	EXP	MT0KDB##	;(133) 1ST MTA KDB IN SYS
>
>
IFE TAPN,<
	Z
CNFMTK::EXP	0
>
NOCPUS::EXP	M.CPU		;(134) NO OF CPUS MONITOR WAS BUILT FOR
CNFDJB:	XWD	PJBNLH,DEVJOB	;(135) GETTABLE PJOBN (SANS INDEX FIELD)
UPTIME::
SYSUPT::EXP	0		;(136) SYSTEM UPTIME
BOOTCP::EXP	-1		;(137) BOOT CPU NUMBER
BOOTCT::EXP	CT0LIN		;(140) BOOT CPU CTY LINE NUMBER
NCPRUN::EXP	M.CPU		;(141) NUMBER OF CPUS ALLOWED TO RUN
STRMON::SIXBIT	/SYS/		;(142) FILE STRUCTURE MONITOR WAS BOOTED FROM
FILMON::SIXBIT	/SYSTEM/	;(143) FILE NAME
EXTMON::SIXBIT	/EXE/		;(144) EXTENSION
PPNMON::XWD	1,4		;(145) PPN
SYSNBP::EXP	MAXNBP		;(146) MAXIMUM NUMBER OF BREAK POINTS
				; SETTABLE BY THE SNOOP. UUO
MONVFF::EXP	MONORG		;(147) FIRST FREE VIRTUAL ADDRESS ABOVE MONITOR
LDBVRG::EXP	0		;(150) VIRTUAL ADDRESS OF THE ORGIN OF LDBS
FOPHXC::EXP	HIGHXC-20	;(151) NUMBER OF EXTENDED CHANNELS AVAILABLE VIA FILOP.
MONHSO:	EXP	MONORG		;(152) VIRTUAL ADDRESS OF START OF MONITOR HIGHSEG
RSDTTM::EXP	0		;(153) UNIVERSAL DATE/TIME OF LAST ROLE
				;      SWITCH ON MULTIPLE CPU SYSTEMS

CNFDCH:	EXP	LDBDCH##	;(154) OFFSET OF LDBDCH IN LDB'S
SFDMON::EXP	0		;(155) 1ST SFD MONITOR WAS BOOTED FROM
	EXP	0		;(156) 2ND SFD MONITOR WAS BOOTED FROM
	EXP	0		;(157) 3RD SFD MONITOR WAS BOOTED FROM
	EXP	0		;(160) 4TH SFD MONITOR WAS BOOTED FROM
	EXP	0		;(161) 5TH SFD MONITOR WAS BOOTED FROM
	EXP	FRCLIN		;(162) TTY LINE NUMBER OF FRCLIN
PTYPTR:	XWD	-PTYN,PTYTAB	;(163) POINTER TO PTY TABLE
IFN M.NET<
	XWD	-LATLEN##,NETLAT## ;(164)-LENGTH,,LOCATION LINK ADDRESS TABLE
>
IFE M.NET<
	EXP	0
>
CNFLPD:	EXP	.PDLEN		;(165) LENGTH OF A PDB
	XWD	0,PAGSIZ	;(166) XWD FLAG, SIZE OF LARGEST JOBPEK TRANSFER
				; WHERE FLAG=0 IF SWAP SPACE JOBPEK'S MAY NOT
				; CROSS A PAGE BOUNDARY, FLAG=1 IF THEY MAY
	EXP	CNFDAE		;(167) XWD OLD DAEMON NAME,CURRENT MONITOR
				; VERSION. OLD DAEMON NAME IS THE SIXBIT NAME
				; OF THE PREVIOUS MONITOR, E.G. 701.
CNFHSH::XWD	-HSHLEN,HSHTAB	;(170) AOBJN POINTER TO HSHTAB
	EXP	<.PDACS-.PDBEG>	;(171) OFFSET IN PDB FOR ACCOUNT STRING
	XWD	TOPLN1##,TOPTB1## ;(172) POINTER TO TOPTB1, TRMOP DISPATCH
	EXP	JBTSFD##	;(173) POINTER TO JBTSFD
	EXP	CIPWT		;(174) POINTER TO CLOCK QUEUE
	ND	PRVPRV,<-1,,0>	;DEFINE DEFAULT PRIVS
CNFPRV::EXP	PRVPRV		;(175) DEFINE PRIVED JOB PRIVS
IFN M.DECN,<
CTHREV::CTHR			;(176,177) CTERM HOST REVISION STRING
>
IFE M.DECN,<
CTHREV::EXP	0,0		;(176,177) NO CTERM SUPPORT
>
LAHNDB::0			;(200) LAT HOST NODE DATA BASE ADDRESS
	EXP	OUTMSK		;(201) 'AND' MASK FOR JBTIMI/JBTIMO/JBTVIR TO
				;      REDUCE TO ACTUAL PAGE COUNT
	.LNKEND	.LKACB,SYSACB
SYSACB::0			;(202) FIRST ALLOCATION CONTROL BLOCK ADDRESS
	.LNKEND	.LKAHB,SYSAHB
SYSAHB::0			;(203) FIRST ALLOCATION HEADER BLOCK ADDRESS
CNFMXL==:<.-CNFTBL-1>B26	;MAXIMUM ENTRY IN CNFTBL FOR GETTAB UUO
USRCOR::0			;TOTAL AMOUNT OF USER CORE AVAILABLE
				;^NOT CURRENTLY UPDATED BY SET MEMORY OFF
MDS3FF:	0		;NEXT FIRST FREE LOCATION FOR SECTION 4 ALLOCATION

;----------------------------------
;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY ONCE ONLY CODE.
; OR ARE CONSTANTS WHICH ARE NOT CLEARED AT STARTUP
;-------------------------------------
DEBCPU::EXP	-1		;CPU NUMBER OF BOOT CPU FOR DEBUGGING SMP
IFE M.NET,<IFN FTNET+FTCMSR,<
	.NTMXL==:0		;THIS LETS UUOCON'S GETTABS
NETGTT::0			; LOAD WITHOUT UNDEFINED GLOBALS
>>

TICMIN::JIFMIN			;NUMBER OF TICKS PER MINUTE (CALCULATED BY ONCE)
TIMLST::0			;VALUE OF "TIME" LAST TIME AT CLOCK LEVEL
				; USED FOR ALL TIMING FUNCTIONS, E.G.,
				; MAINTAINING CLOCK QUEUE AND SMITHSONIAN DATE
IFN M.KL10,<
NULJPC::EXP	XC.USR+IC.LIP+1	;PC FOR THE NULL JOB
NULDOP::EXP	LG.LUB+LG.IAM+NLUPMP/PAGSIZ
>
IFN M.KS10,<
NULJPC::EXP	XC.USR+IC.LIP+1
NULDOP::EXP	SG.LUB+NLUPMP/PAGSIZ
>
SYSBPJ::0			;SNOOP.ING JOB
SYSBPP::0			;ADDRESS OF BREAK POINT TABLE,, NUMBER OF BREAK POINTS
MSTCKS::0			;MONITOR SYMBOL TABLE CHECKSUM
LOWLOC::0
ONCCOM::0
MONPFF::0			;TO KEEP TRACK OF ALLOCATED PHYSICAL PAGES
				; (NOT IN ANY MAP)
IFN M.KL10,<
LOWLEN==<IOWNUM+^D143>/^D144
LOWPTR::XWD	-LOWLEN,LOWTAB
LOWTAB:	BLOCK	LOWLEN
>
NXMTBL==:<CORBLK+^D35>/^D36
NXMTAB::BLOCK	NXMTBL		;TABLE USED TO RECORD WHICH PAGES OF MEMORY EXIST
CORLIM::EXP	USRLIM
SYSINA::EXP	SYSINI##		;LOCATION AT WHICH SYSINI WAS LOADED
OMSMIN::EXP	M.OMSM		;# MINUTES REMAINING BEFORE NEXT CALL
				; TO BIGBEN
OMSINI::EXP	M.OMSM		;TIME BETWEEN CALLS
SEGPT2::EXP	JOBN		;ROUND ROBIN OVER IN-CORE DORMANT SEGMENTS
IFNDEF		MFRHPQ,<MFRHPQ==2>;DEFAULT IS 2
FRSHPQ::EXP	MFRHPQ		;MINIMUM HPQ FORCING SCHED
IFNDEF		STHLOG,<STHLOG==0>
STHFLG::EXP	STHLOG		;IF NON-ZERO,NRT CAN RUN W/O LOGIN
CLPTOP::0			;POINTER TO BEGINNING OF CLP LIST
CLPBOT::CLPTOP			;POINTER TO END OF CLP LIST
IFN FTKL10&FTAUTC,<
IPAMSK::0			;BIT MASK TO SKIP STARTING IPA DEVICE (CI,,NI)
				; 1B<CPU#> SET IF SHOULDN'T START DEVICE
>; END IFN FTKL10&FTAUTC
;EXTENSIBLE BITMAP MEMORY ALLOCATION CONTROL BLOCKS

IFN M.DECN,<

;DECNET ALLOCATION CONTROL BLOCK

	.LINK	.LKACB,DCNACB	;ADD TO SYSTEM-WIDE LINKED LIST
DCNACB::EXP	0		;ADDRESS OF NEXT ALLOCATION CONTROL BLOCK
	SIXBIT	/DECNET/	;ALLOCATION USER
	EXP	M.DNCS		;CHUNK SIZE IN WORDS
	Z	(MS.DCN)	;SECTION NUMBER OF ALLOCATION
	EXP	0		;CURRENT USED AMOUNT IN WORDS
	EXP	0		;HIGH WATER MARK IN WORDS
	EXP	DCNSIZ		;INITIAL ALLOCATION AMOUNT IN WORDS
	EXP	M.DNTH		;THRESHOLD ALLOCATION AMOUNT IN WORDS
	EXP	M.DNIN		;INCREMENTAL ALLOCATION AMOUNT IN WORDS
	EXP	M.DNMN		;MINIMUM ALLOCATION AMOUNT IN WORDS
	EXP	DCNMAX		;MAXIMUM ALLOCATION AMOUNT IN WORDS
	EXP	0		;ADDRESS OF ALLOCATION HEADER BLOCK


;DECNET ALLOCATION HEADER BLOCK

	.LINK	.LKAHB,DCNAHB	;ADD TO SYSTEM-WIDE LINKED LIST
DCNAHB::BLOCK	AHBLEN		;FILLED IN BY ACBMEM


;DECNET ALLOCATION EXTENT BLOCK

DCNAEB::BLOCK	AEBLEN		;FILLED IN BY ACBMEM
>; END IFN M.DECN
;BITMAP MEMORY DEFINITIONS

IFN FTSCA,<
SCALOC::EXP	0		;STARTING ADDRESS OF SCA FREE CORE
SCAFRE::EXP	0		;FIRST FREE ADDRESS IN SCA SECTION
	SCABTL==<SCASIZ+^D143>/^D144 ;SIZE OF THE BIT MAP FOR SCA FREE CORE
SCAPTR::XWD -SCABTL, .+1	;AOBJN POINTER TO SCA FREE CORE BIT MAP
	BLOCK	SCABTL		;THE MAP ITSELF
>; END IFN FTSCA

IFN FTENET,<
ETHLOC::EXP	0		;STARTING ADDRESS OF ETHERNET FREE CORE
	ETHBTL==<ETHSIZ+^D143>/^D144 ;SIZE OF THE BIT MAP
ETHPTR::XWD	-ETHBTL,.+1	;AOBJN POINTER TO ETHERNET FREE CORE BIT MAP
	XLIST			;THE MAP ITSELF (ALL ZEROES)
	REPEAT	ETHBTL,<0>
	LIST
IFN FTKL10,<
KNILOC::EXP	0		;STARTING ADDRESS OF KLNI FREE CORE
	KNIBTL==<KNISIZ+^D143>/^D144 ;SIZE OF THE BIT MAP
KNIPTR::XWD	-KNIBTL,.+1	;AOBJN POINTER TO KLNI FREE CORE BIT MAP
	XLIST			;THE MAP ITSELF (ALL ZEROES)
	REPEAT	KNIBTL,<0>
	LIST
LLMACT::BLOCK	1		;LLMOP IDENTIFY-SELF TIMER WORD
>; END IFN FTKL10
>; END IFN FTENET
;INTERLOCK WORDS AND OWNER WORDS MUST BE IN THE SAME ORDER
; "INTRLK" MUST BE FIRST

IFN FTMP,<
	INTERN	INTL0,INTO0
INTRLK::-1			;CPU PI SYSTEM INTERLOCK
SCDLOK::-1			;SCHEDULER INTERLOCK
SCNLOK::-1			;SCNSER INTERLOCK
INTRDD::-1			;DDB-SCAN INTERLOCK
INTRST:	-1			;CPU START-UP INTERLOCK
INTRUU::-1			;GENERAL UUO-LEVEL LOCK
INTRDC::-1			;DISK CACHE INTERLOCK
INTRDS::-1			;DSKOFF INTERLOCK
NETLOK::-1			;USED IN NETOFF,NETOM MACROS
NTLOCK::-1			;THE NETSER INTERLOCK
INTLBT::-1			;BIT DIDDLER INTERLOCK (SETOS,CLRBTS)
IFN FTKL10,<
INTLNB::-1			;BUFFER (CACHE) MANAGEMENT INTERLOCK
>
IFN FTDECNET,<
SCTLOK::-1			;DECNET'S SESSION CONTROL INTERLOCK
NSPLOK::-1			;DECNET'S NSP INTERLOCK
>
IFN FTSCA,<
INTLSC::-1			;SCA BUFFER MANAGEMENT INTERLOCK
>; END IFN FTSCA
IFN FTENET,<
ETHLOK::-1			;ETHERNET INTERLOCK
>; END IFN FTENET
IFN FTPATT,<			;FOR PATCHING
INTRP1::-1
INTRP2::-1
>
INTRCL::-1			;CLOCK QUEUE PROCESSING
DEFINE	INTLK(A,B)<
IFE A,<INTL'B: -1>		;PI LEVEL B ON CPU A PI INTERLOCK
IFN A,<INTL'A'B: -1>>

ZZ==0
REPEAT M.CPU,<
ZZZ==0
REPEAT 10,<
INTLK(\ZZ,\ZZZ)
ZZZ==ZZZ+1>
ZZ==ZZ+1>
;OWNING CPU OF INTERLOCKS (CONI PAG OR APRID)
INTOLK::-1			;CPU PI-SYSTEM
INOSCD::-1			;SCHEDULER
INOSCN::-1			;SCNSER
INTODD::-1			;DDB-SCAN
INTOST::-1			;CPU START-UP
INTOUU::-1			;GENERAL  UUO-LEVEL
INTODC::-1			;DISK CACHE
INTODS::-1			;DSKOFF
INONET::-1			;NETOFF
INONT::	-1			;NETSER
INTOBT::-1			;BIT DIDDLERS
IFN FTKL10,<
INTONB::-1			;BUFFER (CACHE) MANAGEMENT
>
IFN FTDECNET,<
SCTLKO::-1			;DECNET'S SESSION CONTROL
NSPLKO::-1			;DECNET'S NSP INTERLOCK
>
IFN FTSCA,<
INTOSC::-1			;SCA BUFFER MANAGEMENT OWNER
>; END IFN FTSCA
IFN FTENET,<
INOETH::-1			;ETHERNET
>; END IFN FTENET
IFN FTPATT,<			;FOR PATCHING
INTOP1::-1
INTOP2::-1
>
INTOCL::-1			;CLOCK QUEUE PROCESSING
DEFINE INTLKO(A,B)<
IFE A,<INTO'B:-1>
IFN A,<INTO'A'B:-1>>
ZZ==0
REPEAT M.CPU,<
ZZZ==0
REPEAT 10,<
INTLKO(\ZZ,\ZZZ)
ZZZ==ZZZ+1>
ZZ==ZZ+1>
;NOT CORRESPONDING TO ABOVE INTERLOCKS
SCNOWN::-1			;OWNER OF SCNCNT (.CPCPU)
INTLMO::-1			;OWNER OF THE MEMORY MANAGEMENT RESOURCE (APRID)
>;END FTMP
IFE FTMP,<
NTLOCK::-1			;NTLOCK EXISTS ON SINGLE CPU'S TOO
SCTLOK::-1			;DECNET INTERLOCKS EXIST ON SINGLE CPU's TOO
NSPLOK::-1
RTRLOK::-1
SCTLKO::-1
NSPLKO::-1
INTRDC::-1
RTRLKO::-1
>
INTDIE::-1			;DIE INTERLOCK
INODIE::-1			;DIE OWNER
DIEFLG::0			;DIE TYPE (-1=STOPCD, +1=EVENT, 0=UNKNOWN)
;GETTAB TABLE OF QUEUE CODES FOR JOBS - TABLE(RH)=25
;MUST BE A SEPARATE TABLE SINCE THE NUMBER OF ENTRIES VARIES ACCORDING
;TO THE CONFIGURATION

;ENTRIES ARE 2 SIXBIT CHARACTERS, THREE PER WORD
;STATE CODE 0 IS LEFT THIRD, 1 IS MIDDLE THIRD, 2 IS RIGHT THIRD OF FIRST WORD
;STATE CODE 3 IS LEFT THIRD OF SECOND WORD, ETC.


STSTBL::

DEFINE X(A,B,C)
<	IFE ZZ-ZZ/3*3-0,
	<	  XX==   <SIXBIT /A/&7777B11>B35>
	IFE	ZZ-ZZ/3*3-1,
	<	  XX==XX!<SIXBIT /A/&7777B11>B47>
	IFE	ZZ-ZZ/3*3-2,
	<	  XX==XX!<SIXBIT /A/&7777B11>B59
	  EXP XX>
ZZ==ZZ+1
>

ZZ==0
	QUEUES
	RWAITS
	CODES
	IFN	ZZ-ZZ/3*3-0,<
	  EXP XX>

STSMXL==:<.-STSTBL-1>B26		;MAX ENTRY IN STSTBL FOR GETTAB UUO
IFG DSKN, <


ODPTBL::!			;FIRST LOCATION IN MONITOR DATA AREA FOR DISK-
				; RELATED LOCATIONS WHICH ARE NOT SET TO 0 WHEN
				; THE SYSTEM IS STARTED UP.
				; ODPTBL IS GETTAB UUO TABLE NUMBER 15.

SWPHGH::0			;(0) HIGHEST LOGICAL BLOCK # ASSIGNED FOR SWAPPING.
				; SPACE IS ASSIGNED FROM HIGHEST BLOCK # DOWNWARDS.
K4SWAP::0			;(1) # OF K OF DISK WORDS SET ASIDE FOR SWAPPING.
				; ASSIGNED AT ONCE ONLY REFRESH TIME.

IFE SYS50N, <KXFTIM==0
SEEKTM==0			;DEFAULT VALUES FOR 10/40 DISK SYSTEM.>
IFN LEVDN,<KXFTIM==0		;SET PROTECT TIMES TO 0
SEEKTM==0			;ONCE ONLY CODE MUST SET PROT,PROT0
				;DEPENDING ON FASTEST UNIT USED FOR SWAPPING
>
PROT::	EXP	0		;(2) IN-CORE PROTECT TIME PARAMETER TO BE
				; MULTIPLIED BY <K-1> OF CORE IN JOB.
PROT0::	EXP	0		;(3) IN-CORE PROTECT TIME PARAMETER TO
				; BE ADDED TO ABOVE RESULT.
PROT1::	EXP	0		;(4) SWAPPABLE CYCLING TIME
PROTM::	EXP	0		;(5) MAXIMUM IN-CORE PROTECT TIME

	;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY
	; ONCE ONLY CODE AND WHICH PERTAIN ONLY TO DISK SYSTEMS.

ODPMXL==:<.-ODPTBL-1>B26		;MAXIMUM ENTRY IN ODPTBL FOR GETTAB UUO

;DISK LOCATIONS NOT IN GETTAB


REFLAG::Z			;FLAG LOCATION TO INDICATE WHETHER ANY REFRESHING
				; OCCURRED AND TO CONTAIN THE [PROJ,PROG]
				; NUMBERS FOR AUTOMATIC LOG-IN FOLLOWING REFRESH.

>	;END IFG DISKN CONDITIONAL
;MORE DATA LOCATIONS SETUP AT ASSEMBLY TIME OR ONCE ONLY TIME
; BUT NOT OF INTEREST TO USER PROGRAMS



	$HIGH
XJBPFI::XWD	JOBPFI##,0	; JOBPFI==HIGHEST LOC, IN USER JOB DATA AREA
				; PROTECTED FROM I/O
;MONTH TABLE FOR DAYTIME COMMAND PRINTING

PMONTB::POINT	6,MONTAB(T1),5	;POINTER TO NUMBER OF DAYS IN MONTH
MONTAB::EXP	^D30B5+"Jan"
	EXP	^D27B5+"Feb"
	EXP	^D30B5+"Mar"
	EXP	^D29B5+"Apr"
	EXP	^D30B5+"May"
	EXP	^D29B5+"Jun"
	EXP	^D30B5+"Jul"
	EXP	^D30B5+"Aug"
	EXP	^D29B5+"Sep"
	EXP	^D30B5+"Oct"
	EXP	^D29B5+"Nov"
	EXP	^D30B5+"Dec"

IFN FTDTCK,<
;DAY TABLE FOR DAYTIME COMMAND AND ONCE
DAYTAB::[ASCIZ/Wednesday/]	;INDEXED BY UDT REMAINDER
	[ASCIZ/Thursday/]	;
	[ASCIZ/Friday/]		;
	[ASCIZ/Saturday/]	;
	[ASCIZ/Sunday/]		;
	[ASCIZ/Monday/]		;
	[ASCIZ/Tuesday/]	;
>;FTDTCK

MIDNIT::EXP	0		;NO OF JIFFIES TILL MIDNIGHT (CALCULATED BY ONCE)
IFN FTMP,<
COKTAB:: -JIFSEC		;TABLE TO SET THE POLICY CPU'S OK WORD TO
	ZZ==1			;(INDEXED BY THE NUMBER OF RUNNING CPUS-1)
	REPEAT	M.CPU-1,<
	-ZZ*JIFSEC
	ZZ==ZZ+1
	>
>
	$ABS
;TABLE OF SCHEDULER STATISTICS (CAN BE USED TO HELP TUNE SYSTEM)

.GTSST::!			;SCHEDULER STATISTICS TABLE - #115


FORCFC::0			;(0)COUNT OF TIMES SCHEDULER RAN A JOB
				;OUT OF ORDER SO THAT IT WOULD RELEASE
				;A SHARABLE RESOURCE IN ORDER THAT IT
				;COULD BE SWAPPED OUT.

UNWNDC::0			;(1)COUNT OF TIMES SCHEDULER RAN A JOB
				;OUT OF ORDER BECAUSE ANOTHER JOB HAS BEEN
				;SELECTED THAT NEEDS A SHARABLE DISK
				;RESOURCE THE FIRST JOB OWNED

SWPNUL::0			;(2)SWAPPER NULL TIME (TIME WHEN SWAPPING
				;LOGIC COULD NOT FIND ANYTHING TO DO.)

SWPLOS::0			;(3)SWAPPER LOST TIME (TIME THAT SWAPPER
				;WANTED TO SWAP A JOB IN BUT COULDN'T

RQCNT::0			;(4)NUMBER OF PHYSICAL REQUEUES SINCE
				;SYSTEM STARTUP

MCUINT::0			;(5)INTERVAL AT WHICH MINIMUM CORE
				;USAGE FUNCTION IS CALCULATED.
				;ZERO MEANS DO NOT CALCULATE

SCDINT::0			;(6)MICRO SCHEDULING INTERVAL. ZERO
				;MEANS RUN ROUND ROBIN IGNORING CLASSES.

AVJSIZ::0			;(7)AVERAGE JOB SIZE COMPUTED ONCE A MINUTE

TOTRTC::0			;(10)TOTAL RUNTIME GIVEN TO ALL SUBCLASSES
				;DOES NOT INCLUDE ANY PQ1 OR HPQ TIME

SCDEXF::0			;(11)EXPONENTIAL FACTOR USED FOR COMPUTING
				;EXPONENTIALLY AVERAGED RUNTIME FOR
				;CPU CLASSES

UTMEAR::0			;(12)EXPONENTIALLY AVERAGED USER TIME USED
				;FOR THE ENFORCEMENT OF QUOTAS

RTCTOT::0			;(13)TOTAL USER RUNTIME SINCE LAST
				;SCHED UUO SET CLASS PARAMETERS

DEFCLS::M.DCLS			;(14)DEFAULT CLASS FOR NEW JOBS

SCDJIL::0			;(15)PERCENT OF TIME SCHEDULER SCANS
				;JUST SWAPPED IN QUEUE BEFORE SUBQUEUES

SCDSWP::0			;(16)MINIMUM NUMBER OF TICKS
				;SWAPPER SCANS THE SAME PRIMARY SUBQUEUE

BBSUBQ::0			;(17)BACKGROUND BATCH SUBQUEUE

SCDBBS::0			;(20)NUMBER OF TICKS BETWEEN
				;BACKGROUND BATCH SWAPS

SCDIOF::0			;(21)PERCENT OF TIME THAT SWAPPER SCANS PQ2
				;INCORE CHAIN BEFORE OUTCORE CHAIN
SCDSET::0			;(22)FLAG = 0 IF RUNNING ROUND ROBIN
				;= DATE/TIME WHEN CLASS RUNTIME TABLE
				;INITIALIZED IF RUNNING IN CLASS MODE
RRFLAG::0			;(23)FLAG = 0 IF RUNNING ROUND ROBIN SCHEDULER
				;= CNTSTS IF CLASS SCHEDULING
SCDCOR::0			;(24) TIME TO WAIT AFTER SWAPPING OUT
				;A RUNNABLE JOB BEFORE SETTING CORSCD
				;FLAG
SSDMXL==:<.-.GTSST-1>B26	;MAXIMUM LENGTH OF TABLE FOR GETTABS
;IPCF COMMON DATA

IFN FTIPCF,<
IFN M.IPCF,<

IFNDEF	M.PKTL,<M.PKTL==12>
%IPMPL==:M.PKTL			;MAXIMUM PACKET LENGTH

IFNDEF M.PIDN,<XP M.PIDN,JOBN*2>
XP MIDMXL,<<M.PIDN>B26>		;FOR GETTAB

ND M.IPCR,5			;DEFAULT RECEIVE QUOTA
ND M.IPCS,2			;DEFAULT SEND QUOTA
ND M.IPCP,2			;DEFAULT PID QUOTA

PIDMSK==JOBN
IFG <M.PIDN-JOBN>,<PIDMSK==M.PIDN>  ;MAX (JOBN,M.PIDN)
PIDMSK==<1B<^L<PIDMSK>-1>>-1	;MAKE INTO MASK

; MACRO TO DEFINE EXEC PROCESS PIDS
DEFINE	PIDS,<

	ZZ==0			;;INIT COUNTER

X	(IPC)			;;[SYSTEM]IPCC
X	(GFR)			;;[SYSTEM]GOPHER

> ;END PID MACRO

DEFINE	X	(NAM),<XWD	<NAM'PID==<ZZ==ZZ+1>>,0>
PIDTAB::PIDS			;GENERATE EXEC PROCESS PID ENTRIES
%IPCNS==:.-PIDTAB		;NUMBER OF SYSTEM PROCESSES
	XLIST
	REPEAT	<M.PIDN-%IPCNS>,<Z>	;REMAINDER OF TABLE ZERO
	LIST

DEFINE	X	(NAM),<EXP	NAM'ADR>
EXPROC::PIDS			;GENERATE POINTERS TO EXEC PROCESS IPCF DATA

; EXEC PROCESS CONTROL BLOCK FOR [SYSTEM]IPCC
IPCADR:	Z			;.EPIPC
	Z			;.EPIPA
	XWD	200000,-1	;.EPIPQ
	Z			;.EPIPL
	Z			;.EPPID
	Z			;.EPIPI
	Z			;.EPIPN
	Z			;.EPQSN
	Z			;.EPEPA
	IFIW	IPCFPR##	;.EPADR

; EXEC PROCESS CONTROL BLOCK FOR [SYSTEM]GOPHER
GFRADR:	Z			;.EPIPC
	Z			;.EPIPA
	XWD	200000,-1	;.EPIPQ
	Z			;.EPIPL
	Z			;.EPPID
	Z			;.EPIPI
	Z			;.EPIPN
	Z			;.EPQSN
	Z			;.EPEPA
	IFIW	IPCSPR##	;.EPADR

	EXTERN	IPCSER


IPCTAB::			;MISCELLANEOUS IPCF DATA
%CNIPL::	%IPMPL		;(0) MAX PACKET LENGTH
%CNIPI::	Z		;(1) PID OF SYS:INFO (0=NONE)
%CNIPQ::BYTE (2)1(16)(9)M.IPCS,M.IPCR	;(2) DEFAULT QUOTAS + IP.HBS BIT
%CNIPS::	Z		;(3) TOTAL PACKETS SENT
%CNIIP::	Z		;(4) NUMBER OF PACKETS OUTSTANDING
%IPCFP::	IPCPID,,0	;(5) PID OF [SYSTEM]IPCC
%IPCPM::	PIDMSK		;(6) MASK FOR PID
%IPCMP::	M.PIDN		;(7) LENGTH OF PID TABLE
%IPCNP::	%IPCNS		;(10) CURRENT NUMBER OF PID'S
%IPCTP::	%IPCNS		;(11) TOTAL PID'S SINCE RELOAD
%CNPIC::	Z		;(12) NUMBER OF IPCF PAGES CURRENTLY IN CORE
%IPCSP::	GFRPID,,1	;(13) PID OF [SYSTEM]GOPHER
%IPTWT::	Z		;(14) TOTAL WORDS PASSED (NON-PAGE MODE)
%IPTPT::	Z		;(15) TOTAL PAGES PASSED
%IPOPP::	.IPCFD##	;(16) OVERHEAD PER PACKET
%CNIPD::	M.IPCP		;(17) DEFAULT PID QUOTA
IPCMXL==:<.-IPCTAB-1>B26	;FOR GETTAB

	$HIGH
.GTQFC::			;CUSTOMER SPECIAL QUEUE. FUNCTIONS GO HERE
IFN FTPATT,<
	EXP	0
	EXP	0
>

;INSERT REAL CUSTOMER FUNCTIONS HERE

.GTQFT::0			;QUEUE. UUO FUNCTION TABLE (ZERO IS ILLEGAL)
%QPRNT::%SIQSR			;(1) PRINT A FILE
%QPCRD::%SIQSR			;(2) PUNCH A FILE ON CARDS
%QPTAP::%SIQSR			;(3) PUNCH A FILE ON PAPER TAPE
%QPLOT::%SIQSR			;(4) PLOT A FILE
%QSUBM::%SIQSR			;(5) SUBMIT A FILE
%QALLC::%SIQSR			;(6) ALLOCATE A VOLUME SET
%QDEAL::%SIQSR			;(7) DEALLOCATE A VOLUME SET
%QMOUN::%SIQSR			;(10) MOUNT A VOLUME
%QDMNT::%SIQSR			;(11) DISMOUNT A VOLUME
%QWTO::	%SIOPR			;(12) WRITE TO OPERATOR
%QWTOR::%SIOPR			;(13) WRITE TO OPERATOR WITH RESPONSE
%QVALA::%SIACT			;(14) VALIDATE AN ACCOUNT
%QMAUE::%SIACT			;(15) MAKE A USAGE ENTRY
%QCATV::%SICAT			;(16) CATALOG VALIDATION REQUEST
%QMAIL::%SIMAI			;(17) MAIL REQUEST
%QEVNT::%SIQSR			;(20) EVENT QUEUE REQUEST

;ADD NEW DEC FUNCTIONS HERE

IFN FTPATT,<
	EXP	0
	EXP	0
>
QUTBLN==:.-.GTQFT-1
	$ABS

.GTCSD::			;CUSTOMER SPECIAL PID'S GO HERE
.GTSID::			;SPECIAL PID TABLE
%SIIPC::XWD	IPCPID,0	;(0) IPCC
%SIINF::Z			;(1) [SYSTEM] INFO
%SIQSR::Z			;(2) [SYSTEM] QUASAR
%SIMDA::Z			;(3) MOUNT DEV ALLOCOTOR
%SITLP::Z			;(4) MAGTAPE LABELING PROCESS
%SIFDA::Z			;(5) FILE DAEMON
%SITOL::Z			;(6) TAPE AVR PROCESS
%SIACT::Z			;(7) [SYSTEM] ACCOUNTING
%SIOPR::Z			;(10) OPERATOR INTERFACE PROCESS
%SISEL::Z			;(11) SYSTEM ERROR LOGGER
%SIDOL::Z			;(12) DISK AVR PROCESS
%SITGH::Z			;(13) [SYSTEM] TGHA
%SINML::Z			;(14) DECNET NETWORK MANAGEMENT LAYER
%SIGFR::XWD	GFRPID,1	;(15) PID OF [SYSTEM]GOPHER
%SICAT::Z			;(16) PID FOR [SYSTEM]CATALOG
%SIMAI::Z			;(17) PID FOR [SYSTEM]MAILER
SDTBLN==:.-.GTSID-1
SIDJOB==:.+<.GTSID-.GTCSD>	;ZERO 'TH SYSTEM JOB #
	BLOCK	<.-.GTCSD>	;SPACE FOR PARALLEL JOB
MDAJOB=:SIDJOB+<%SIMDA-.GTSID>
FDAJOB=:SIDJOB+<%SIFDA-.GTSID>
TLPJOB=:SIDJOB+<%SITLP-.GTSID>
ACTJOB=:SIDJOB+<%SIACT-.GTSID>
NMLJOB=:SIDJOB+<%SINML-.GTSID>
CATJOB=:SIDJOB+<%SICAT-.GTSID>
MAIJOB=:SIDJOB+<%SIMAI-.GTSID>
>>
IFE FTIPCF,<
IFN M.IPCF,<

PRINTX ? PLEASE ASSEMBLE SOURCES WITH FTIPCF=-1
>>

IFE M.IPCF,<

XP UIPCFR,CPOPJ			;MAKE IPCF UUOS LOOK UNIMPLEMENTED
XP UIPCFS,CPOPJ
XP UIPCFQ,CPOPJ
XP IPCFRC,CPOPJ			;DO NOTHING ON RESET UUO
XP LOKIPC,CPOPJ
XP FNDIPC,CPOPJ
XP GLXINF,CPOPJ			;NO QUEUE. UUO
XP IPMCHK,CPOPJ			;NO IPCF QUEUE TO INTERLOCK
XP IPCULK,CPOPJ			;NO IPCF QUEUE TO UNLOCK
XP SNDFFC,CPOPJ			;SEND MESSAGE TO SPECIAL PID


XP IPCLGO,CPOPJ			;DO NOTHING ON LOGOUT UUO
XP SNDMDR,CPOPJ			;LOCKED STRUCTURE MESSAGE TO MDA
XP SNDMDN,CPOPJ			;SEARCH LIST CHANGE MESSAGE TO MDA
XP SNDFIN,CPOPJ			;DEVICE DEASSIGN MESSAGE TO MDA
XP SNDMDX,CPOPJ			;SEND MESSAGE TO SPECIAL SYSTEM PID
XP ATTMPA,CPOPJ			;DISK UNIT ATTACH MESSAGE TO MDA
XP DETMPA,CPOPJ			;DISK UNIT DETACH MESSAGE TO MDA
XP XCHMPA,CPOPJ			;DISK UNIT EXCHANGE MESSAGE TO MDA
XP REMMPA,CPOPJ			;STRUCTURE REMOVAL MESSAGE TO MDA
XP MTAMPA,CPOPJ			;MAGTAPE ACCESSIBLE MESSAGE TO MDA

XP MIDMXL,0			;MAKE GETTABS FAIL
XP IPCMXL,0
XP PIDTAB,0
XP IPCTAB,0
XP .GTCSD,0			;NO CUSTOMER PID TABLE
XP .GTSID,0			;NO SPECIAL PID TABLE
XP .GTQFT,0			;NO QUEUE. TABLE
XP %QWTO,0			;NO QUEUE. TABLE OFFSET FOR WTO

XP SDTBLN,0
XP .IPCTL,0			;NO MESSAGE CODE FOR TAPE LABELING
XP .IPCSC,0			;NO CSHIFT MESSAGE TO ACCOUNTING DAEMON
XP .IPCGM,0			;NO QUEUE. UUO MESSAGE TO GALAXY COMPONENTS
XP .IPCME,0			;NO MOS MEMORY ERROR MESSAGE TO TGHA
XP FILMSG,0
XP .IPCFP,0
XP .IPCFD,0
XP SPBMAX,0
XP SPBCOR,0

%CNIPS::			;NUMBER OF PACKETS SENT
%CNPIC::			;NUMBER OF PIDS IN CORE

MDAJOB::			;MDA
FDAJOB::			;FILE DAEMON
TLPJOB::			;TAPE LABELER
ACTJOB::			;ACCCOUNTING DAEMON
NMLJOB::			;DECNET NETWORK MANAGEMENT LAYER

%SIIPC::			;(0) IPCC
%SIINF::			;(1) [SYSTEM] INFO
%SIQSR::			;(2) [SYSTEM] QUASAR
%SIMDA::			;(3) MOUNT DEV ALLOCOTOR
%SITLP::			;(4) MAGTAPE LABELING PROCESS
%SIFDA::			;(5) FILE DAEMON
%SITOL::			;(6) TAPE AVR PROCESS
%SIACT::			;(7) [SYSTEM] ACCOUNTING
%SIOPR::			;(10) OPERATOR INTERFACE PROCESS
%SISEL::			;(11) SYSTEM ERROR LOGGER
%SIDOL::			;(12) DISK AVR PROCESS
%SITGH::			;(13) [SYSTEM] TGHA
%SINML::			;(14) DECNET NETWORK MANAGEMENT LAYER
%SIGFR::			;(15) PID OF [SYSTEM]GOPHER
%SICAT::			;(16) PID OF [SYSTEM]CATALOG
%SIMAI::			;(17) PID OF [SYSTEM]MAILER
	EXP	0		;ALL THOSE WHO DO SKIPE %SIXXX

XP STRSIG,CPOPJ			;MAKE IPCF CALL FOR PSISER
XP QSRSPL,CPOPJ			;MAKE IPCF CALL FOR FILUUO
XP SENDSP,CPOPJ
XP SNDMDC,CPOPJ
XP QSRLGI,CPOPJ
>
;36 BITS 1 PER WORD
	$HIGH
BITTBL::
SALL
	ZZ==1B0
REPEAT ^D36,<
	EXP	ZZ
	ZZ==ZZ_<-1>
>
	$ABS
;ENQUEUE/DEQUEUE COMMON DATA


IFE FTEQDQ,<
HSHTAB==:0			;DEFINE FOR SYSINI
HSHLEN==:0
>
IFN FTEQDQ,<
IFN M.EQDQ,<
HSHLEN==:2*JOBMAX		;SIZE OF HASH TABLE
HSHTAB::	BLOCK HSHLEN

	EXTERN	QUESER



.EQTAB::
%ENQML:: EXP EQMXCH##		;MAXIMUM WORD SIZE OF STRING
%ENQNQ:: Z			;NUMBER OF ACTIVE QUEUES
%ENQTE:: Z			;TOTAL NUMBER OF ENQ'S SINCE RELOAD
%ENQTD:: Z			;TOTAL NUMBER OF DEQ'S SINCE RELOAD
%ENQNP:: Z			;NUMBER OF ACTIVE POOLED RESOURCES
%ENQDF:: EXP M.ENQD		;DEFAULT ENQ QUOTA
%ENQMM:: EXP EQMXMW##		;PIE-SLICE-LOCK MAX BLOCK SIZE
%ENQMT:: EXP EQMXTB##		;LOCK-ASSOCIATED TABLE MAX SIZE
%ENQLT:: EXP EQMLTL##		;MINUTES LONG TERM LOCKS STAY AROUND
%ENQDD:: Z			;NUMBER OF DEADLOCKS DETECTED
%ENQTO:: Z			;NUMBER OF TIMEOUTS
%ENQMQ:: EXP M.ENQM		;MAXIMUM NUMBER OF ACTIVE QUEUES


ENQMXL==:<.-.EQTAB-1>B26	;FOR GETTAB

>>;END OF IFN FTEQDQ CONDITIONAL


IFE M.EQDQ,<
XP	ENQ,CPOPJ
XP	DEQ,CPOPJ
XP	ENQC,CPOPJ		;MAKE ALL OF THESE GIVE ERROR RETURNS
XP	ENQRST,CPOPJ		;RESET
XP	ENQLGO,CPOPJ		;LOGOUT
XP	ENQPOP,CPOPJ		;POP
XP	ENQCLS,CPOPJ1		;CLOSE
XP	ENQMIN,CPOPJ		;ENQ/DEQ ONCE A MINUTE
XP	ENQMXL,0
XP	ENQTAB,0
XP	.EQTAB,0
XP	HSHTAB,0
XP	HSHLEN,0
XP	ENQSDT,CPOPJ		;ENQ/DEQ SET DAYTIME FIX UP
XP	ENQNDR,CPOPJ1		;ENQ/DEQ NO DELETE ON RESET CHECK
XP	ENQINI,CPOPJ		;ENQ/DEQ INITIALIZATION
XP	ENQJBI,CPOPJ		;ENQ/DEQ JOB INITIALIZATION
>;END OF IFE M.EQDQ CONDITIONAL


IFE FTEQDQ,<
IFN M.EQDQ,<

PRINTX	?PLEASE ASSEMBLE SOURCES WITH FTEQDQ=-1

>>
;PSISER SYMBOLS

	$HIGH

IFN M.PSI,<
IFE FTPI,<PRINTX ?ASSEMBLE WITH FTPI==-1>
IFN FTPI,<EXTERN PSIAPR,PSISER,PSIMVO,PSIMPI,PITSIZ>
IFE M.CTX,<		;ONLY IF SINGLE-CONTEXT MONITOR
NOPISK::SKIPE	JBTPIA(J)	;SKIP IF USER IS NOT ENABLED FOR TRAPS
OKSGNL::SKIPN	JBTPIA(J)	;SKIP IF USER IS ENABLED FOR TRAPS
>
IFN M.CTX,<		;ELSE NO WAY TO AVOID OVERHEAD
NOPISK::TRN		;ALWAYS TRY
OKSGNL::TRNA		;DITTO
>
PINOJN::SKIPGE	JBTPIA(J)	;SKIP IF CANNOT GRANT AN INTERRUPT
> ;END M.PSI
IFE M.PSI,<
	XP	PSIMVO,0
	XP	PSIMPI,0
	XP	PITSIZ,0	;DUMMY CODE
PSIIVR::
PSIIVA::SETZ	T1,		;NOTHING TO TELL PFH
	POPJ	P,
PINOJN::			;CAN NEVER GRANT AN INTERRUPT
NOPISK::CAIA			;NOBODY EVER ENABLED
OKSGNL::CAI			;...
PSITST==:CPOPJ			;...
PSIERR==:CPOPJ2			;ALWAYS STOP THE JOB
USREIJ==:CPOPJ1			;...
PSIJBI==:CPOPJ1			;...
PSIIOD==:CPOPJ			;NO DEVICE INTERRUPTS
PSIIDN==:CPOPJ			;...
PSIONL==:CPOPJ			;...
PSIODN==:CPOPJ			;...
PSIDWN==:CPOPJ			;...
PSIEDN==:CPOPJ			;...
PSIDVB==:CPOPJ			;...
PISYS==:CPOPJ			;UUOS FAIL
PIINI==:CPOPJ			;...
PIRST==:CPOPJ			;...
PISAVE==:CPOPJ			;...
DEBRK==:CPOPJ			;...
PIJOB==:CPOPJ			;...
PITMR==:CPOPJ			;...
PIBLK==:CPOPJ			;...
PSINTC==:CPOPJ			;NO NETWORK INTERRUPTS
PSIDVT==:CPOPJ			;NO DECNET EVENTS
APPSI==:CPOPJ			;NO APR TRAPS
PSIAPR==:ILLTIN##		;...
ANYUUO==:CPOPJ			;NO UUO TRAPS
CLRPSI==:CPOPJ			;NOTHING TO CLEAR
PSIRMV==:CPOPJ			;NOTHING TO REMOVE
PSIGEN==:CPOPJ			;NOTHING TO GRANT
PSICND==:CPOPJ			;NOTHING TO SIGNAL
PSIKSY==:CPOPJ			;NO KSYS INTERRUPTS
PSISDT==:CPOPJ			;NO DATE/TIME INTERRUPTS
> ;END M.PSI

	$ABS
;TABLE OF MAPPINGS FROM 2-CHARACTER DEVICE NAMES
; TO 3-CHARACTER NAMES. EACH 2-CHAR NAME IS IN
; RIGHT OF WORD AND 3-CHAR EQUIVALENT IS
; IN LEFT HALF.
;

	$HIGH
SPCTAB::XWD	'LPT','LP '	;LINE PRINTER
	XWD	'CDP','CP '	;CARD PUNCH
	XWD	'CDR','CR '	;CARD READER
	XWD	'PTP','PP '	;PAPER-TAPE PUNCH
	XWD	'PTR','PR '	;PAPER-TAPE READER
	XWD	'SYS','SY '	;SYSTEM DEVICE
	XWD	'TTY','TT '	;TELETYPE

STEND==:.
STLEN==:STEND-SPCTAB
;TABLE OF GENERIC DEVICE NAMES USED TO SPEED UP
; GENERIC DEVICE SEARCH
;
;THE LEFT HALF OF EACH WORD IS THE SIXBIT GENERIC DEVICE NAME.
;THE RIGHT HALF IS A PTR TO THE 1ST DDB OF THAT TYPE OF DEVICE.
;SINCE THE DDB'S ARE SORTED BY SYSINI, THIS REDUCES THE AMOUNT
; OF TIME NEEDED TO SEARCH FOR A PARTICULAR DEVICE NAME.

DEFINE GNRIC(DEV,SYM),<
	IFNDEF	M.R'DEV,<M.R'DEV==0>	;DEFINE REMOTE DEVICES
IFN	M.'DEV+M.R'DEV+SYM,<
;	XLIST
	SIXBIT	/DEV/
;	LIST
	>>

DEFINE TGNRIC (X),<<SIXBIT /MTA/>+X_^D18>

DEFINE	DGNRIC(X),<
	GNRIC	DT'X
>

	$ABS

GENTAB::
IFN TAPN,<
	IFE FTAUTC,<TAPCNT==TAPN>
	IFN FTAUTC,<TAPCNT==<<TAPN*2>*M.CPU>>
	ZZ==0
	REPEAT	TAPCNT,<
		TGNRIC (\ZZ)
		ZZ==ZZ+1
	> ;END REPEAT TAPCNT
> ;END IFN TAPN

ZZ=="A"
REPEAT M.TD10,<
	DGNRIC(\"ZZ)
ZZ==ZZ+1
>
DEFINE RGNRIC(Y),<
	GNRIC	RX'Y
>
ZZ=="A"
REPEAT M.RX20,<
	RGNRIC(\"ZZ)
	ZZ==ZZ+1
>
	GNRIC(LPT,M.DLP) ;LINE PRINTER
	GNRIC(PTP)	;PAPER-TAPE PUNCH
	GNRIC(PTR)	;  "     "  READER
	GNRIC(PLT)	;PLOTTER
	GNRIC(PTY)	;PSEUDO-TTY
	GNRIC(CDP)	;CARD PUNCH
	GNRIC(CDR,M.DCR) ;CARD READER
IFN M.DAS78,<		;IF DAS78 SUPPORT
	GNRIC(XXI)	;XXI DEVICE
	GNRIC(XXO)	;XXO DEVICE
> ;END IFN M.DAS78

GTLEN==:GTEND-GENTAB
GTEND::
;DATA BASE TO LIMIT THE NUMBER OF STOPCD'S PER UNIT TIME SO THAT
;WE DON'T KEEP GETTING "CONTINUABLE" STOPCD'S THAT REALLY AREN'T.
;THE DATA BASE CONSISTS OF TWO TABLES, SCCTAB AND SCLTAB.  SCCTAB
;IS THE COUNT OF THE NUMBER OF STOPCD'S PROCESSED DURING THE PERIOD
;INDICATED BY THE OFFSET IT THE TABLE.  SCLTAB CONTAINS, IN THE
;LEFT HALF, THE PERIOD FOR THIS ENTRY AND, IN THE RIGHT HALF, THE
;LIMIT FOR THE NUMBER OF STOPCD'S DURING THE PERIOD.  BOTH TABLES
;MUST BE ORDERED SUCH THAT THE PERIOD OF EACH ENTRY IS MONOTONICALLY
;INCREASING.  THE LIMITS FOR EACH PERIOD ARE CHANGABLE VIA THE MONGEN
;DIALOG AND MAY BE CHANGED BY THE CUSTOMER.  WHEN A STOPCD IS PROCESSED
;BY DIE, STCLIM INCREMENTS THE COUNTS OF STOPCD'S FOR EACH ENTRY
;AND COMPARES EACH WITH THE LIMIT FOR THE ENTRY.  IF A LIMIT HAS BEEN
;EXCEEDED, DIE TURNS THE CONTINUABLE STOPCD INTO A STOP STOPCD.  IF
;NO LIMIT HAS BEEN EXCEEDED, STCLIM PUTS IN A CLOCK REQUEST TO CALL
;DECSCC AFTER THE PERIOD OF THE LOWEST ENTRY IN THE TABLE.  DECSCC
;DECREMENTS THE COUNT OF STOPCDS FOR THIS ENTRY AND PUTS IN A CLOCK
;REQUEST TO DECREMENT THE NEXT HIGHER COUNT.  THIS CONTINUES UNTIL ALL
;HAVE BEEN DECREMENTED. NOTE, THAT SINCE THE CLOCK QUEUE IS USED TO
;DECREMENT THE STOPCD COUNTS, THE PERIOD OF THE LARGEST ENTRY CANNOT
;BE LARGER THAN 2**18-1 TICKS.


SCCTAB::EXP	0		;1 MINUTE COUNT OF STOPCD'S
	EXP	0		;8 MINUTE COUNT OF STOPCD'S
	EXP	0		;1 HOUR COUNT OF STOPCD'S
SCCTBL==:.-SCCTAB		;LENGTH OF TABLE


SCLTAB::XWD	^D60,  LIM1MS	;PERIOD:=1 MINUTE, LIMIT:=LIM1MS
	XWD	^D480, LIM8MS	;PERIOD:=8 MINUTES, LIMIT:=LIM8MS
	XWD	^D3600,LIM1HS	;PERIOD:=1 HOUR, LIMIT:=LIM1HS
;GALAXY-10 PARAMETERS

DEFINE GPARM(Z1),<
IFE Z1,<
ZGAL==0
>>

ZGAL==1
GPARM(M.IPCF)
GPARM(M.PSI)
GPARM(M.PTY)
GPARM(FTSPL)
IFN	FTIPCF,<
IFN	M.IPCF,<
IFG ^D10-%IPMPL,<ZGAL==0>
>>

;DEFINE IPCF SYMBOLS IF NOT AROUND
IFE FTIPCF,<
	XP	QSRSPL,CPOPJ
>
	$HIGH
IFN FTSPL,<
;TABLE FOR SPOOLING DEVICES
SPLNAM==:0			;NAME OF SPOOLING DEVICE
SPLBIT==:2			;SPOOLING BIT
SPLLEN==:DEVMOD+1		;LENGTH OF EACH ENTRY
;NOTE THAT WORD 1 (DEVCHR) MUST BE 0
SPLTAB::SIXBIT	.LPT.
	0
	XWD	.TYLPT/.TYEST,.SPLPT
	0			;NO REAL DEVSER
LPTMOD==1_A+1_AL+1_I
	XWD	DVOUT+DVLPT,ASSCON!ASSPRG!LPTMOD
	SIXBIT	.PLT.
	0
	XWD	.TYPLT/.TYEST,.SPPLT
	0
	XWD	DVOUT,ASSCON!ASSPRG!14403
	SIXBIT	.CDP.
	0
	XWD	.TYCDP/.TYEST,.SPCDP
	0
	XWD	DVOUT+DVCDR,ASSCON!ASSPRG!14403
	SIXBIT	.PTP.
	0
	XWD	.TYPTP/.TYEST,.SPPTP
	0
	XWD	DVOUT+DVPTP,ASSCON!ASSPRG!14403
	SIXBIT	.CDR.
	0
	XWD	.TYCDR/.TYEST,.SPCDR
	0
SPLTOP::XWD	DVIN+DVCDR,ASSCON!ASSPRG!14403
>
	$ABS
SUBTTL	CPU START-UP CODE

;NOTE: CODE AT ENTDDT SHOULD MATCH CODE FROM SYSTRT THROUGH CALL TO SYSTR0

SYSTRT::EXECAC			;GET AC SET RIGHT
	CONO	APR,200000	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JRST	SYSINI##	;BOOT CPU
IFG <CPUN-1>,<
	JRST	SPRINI		;NON-BOOT CPU
>
IFLE <CPUN-1>,<
	HALT	.		;ATTEMPT TO START NON-BOOT CPU WITH A SINGLE CPU MONITOR
>
;SUBROUTINE TO SEE WHICH CPU THIS IS (CALLED ON SYSTEM
; STARTUP AND POWER FAIL AUTO-RESTART)
;CALLING SEQUENCE:
;	JSP	T4,SYSTR0
;	RETURN HERE IF BOOT CPU
;	RETURN HERE IF NON-BOOT CPU
SYSTR0::TLO	T4,(IC.UOU)	;TURN ON USRIOT FOR RETURN
IFN M.KL10,<
	CONO	APR,LP.CSF!LP.CSD
	DATAI	CCA,		;INVALIDATE CACHE, NOT VALIDATING CORE
	CONSO	APR,LP.CSD
	JRST	.-1
	CONO	APR,LP.CSF!LP.CSD
>
IFN M.KS10,<
	RDUBR	T2		;INVALIDATE CACHE
	WRUBR	T2
>
SYSTR1::APRID	T1		;READ CPU SERIAL #
	MOVE	T3,T1		;COPY
	ANDI	T1,ID.PSN	;JUST SERIAL # BITS
IFN FTMP,<
	SKIPGE	INTRST
	AOSE	INTRST
	JRST	.-2
>
	MOVEI	T2,.C0CDB
SYSTR2:	CAME	T1,.CPASN-.CPCDB(T2)
	JRST	SYSTR6
SYSTR3:	MOVEM	T3,.CPAPD-.CPCDB(T2)
	MOVE	T3,.CPMAP-.CPCDB(T2)
	SETOM	.CPOCB-.CPCDB(T2)

;MAP THE FIRST (AND POSSIBLY ONLY) PAGE OF THE CDB AT .ESKPC

IFN M.KL10,<
	APRID	T1		;GET OPTION BITS
	TRNN	T1,ID.MCA	;MCA25 INSTALLED?
	TDZA	T1,T1		;NO
	MOVSI	T1,(PM.KPM)	;YES
	MOVEM	T1,.CPKPM-.CPCDB(T2)
>
	MOVE	T1,T2
	LSH	T1,W2PLSH
	TLO	T1,(<PM.DCD>B2+PM.WRT+PM.PUB)
IFN M.KL10,<
	IOR	T1,.CPKPM-.CPCDB(T2)
>
	MOVEM	T1,.ESKPC/PAGSIZ(T3)


IFN <RHWEVM-^D3>,<IFN <RHWEVM-^D4>,<PRINTX ?RHWEVM IS SET TO AN UNKNOWN VALUE>>
;CODE BELOW IS TO MAP SECOND PAGE OF CDB IN THE .CP AREA
;RHWEVM IS CURRENTLY ONLY 3 OR 4, MEANING 1 OR 2 PAGE CDB. WHENEVER
;A CBD GOES OVER 2 PAGES, MORE CODE WILL HAVE TO BE ADDED HERE.

IFG <RHWEVM-^D3>,<
	AOS	T1
	MOVEM	T1,.ESKPC/PAGSIZ+1(T3)
> ;END IFG RHWEVM-^D3
IFN FTKL10,<
	MOVE	T1,.CPKPM-.CPCDB(T2)
	MOVE	T3,.CPEPT-.CPCDB(T2)
	IORM	T1,SECTAB+0(T3)		;TURN ON "KEEP ME" IN SECTION 0 AND 1 MAP POINTERS
	IORM	T1,SECTAB+1(T3)
	XJRSTF	[EXP XC.UOU,.+1]	;SET PRVIOUS CONTEXT USER, PCS =0
	DATAI	PAG,P3			;SET PREVIOUS CONTEXT AC SET TO 6
	AND	P3,[7B8]
	TLO	P3,(1B0+6B11)
	DATAO	PAG,P3
	MOVSI	T1,[EXP -1,0,0]		;NO CST UPDATE(AND MASK,OR MASK,BASE ADDR 0=NONE)
	EXCTXU	<BLT T1,2>		;SET LOCATIONS IN AC SET 6, FOR CSTS
	MOVEI	T1,SPTTAB		;MAKE A POINTER TO THE SPT FOR THIS CPU
	EXCTXU	<MOVEM T1,3>		;SET IT UP IN AC SET 6 LOCATION 3
	TLC	P3,(7B11)		;PREVIOUS AC SET TO 1
	DATAO	PAG,P3
>
IFN FTKS10,<
	CONO	PAG,0			;OTHERWISE THE UCODE GETS HUNG
	WRCSTM	[-1]			;KEEP ALL CST BITS (AND MASK)
	WRPUR	[0]			;SET NOTHING FOR REF'D PAGES (OR MASK)
	WRCSB	[0]			;NO CST PRESENT REQUIRES UCODE 124 
					;WITH INHCST OR NOCST TURNED ON
	APRID	0			;READ OUR ID
	TLNE	0,(ID.KLP)		;BETTER SAY KLP IS AVAIL
	TLNN	0,(ID.NCU)		;AND SOME WAY TO TURN OFF CST
	STOPCD	.+1,HALT,WNGUCV		;++WRONG UCODE VERSION
	MOVEI	0,@.CPSPT-.CPCDB(T2)	;POINT TO OUR SMALL SPT
	WRSPB	0			;TELL THE MICROCODE
>
	MOVE	P3,@.CPSPT-.CPCDB(T2)	;SAVE ORIGINAL CONTENTS
	MOVEI	T1,NLUPMP/PAGSIZ	;ESTABLISH AN SPT
	MOVEM	T1,@.CPSPT-.CPCDB(T2)

IFN M.KL10,<
IFN FTXMON,<
;NOW SETUP THE MAPPING TO MAKE ALL OF THE USER SECTION MAPS ADDRESSABLE IN EXEC MODE
; THE MAPS START AT VIRTUAL ADDRESS UMAPS IN SECTION 37.
	MOVEI	T1,<SECTAB+(<PM.ICD>B2+PM.WRT+IFE FTMP,<PM.CSH>)>
	HRL	T1,.CPCPN-.CPCDB(T2) ;@THRU CURRENT CPU'S ASSIGNED SPT SLOT
	MOVEI	T3,.CPUMA-.CPCDB(T2)
SYSTR4:	MOVSM	T1,(T3)		;POINTER FOR NEXT USER SECTION MAP
	ADDI	T1,1		;NEXT SECTION
	CAIE	T3,.CPUMA-.CPCDB+MXSECN(T2) ;MAPPED ALL SECTIONS?
	AOJA	T3,SYSTR4	;NO, LOOP OVER ALL SECTIONS
> ;END IFN FTXMON
	CONO	PAG,@.CPEBR-.CPCDB(T2)
	DATAO	PAG,NULDOP	;SETUP UBR TO
				; NULL JOB'S UPT SO THAT MUUO'S, ACCOUNTING
				; METERS, EXEC PAGE FAILS DURING ONCE ONLY
				; WORK CORRECTLY. INHIBIT ACCOUNTING STORE
>
IFN M.KS10,<
	WREBR	0		;DO THIS IN CASE POWER UP. KS10 MICRO-CODE V111
				; HAS BUG THAT WILL CAUSE BOGUS PAR ERR
				; IF THIS ISN'T DONE
	WREBR	@.CPEBR-.CPCDB(T2) ;SET UP EXEC BASE REGISTER
	WRUBR	NULDOP		;SET UP USER BASE REGISTER TO NULL JOB
				; SO THAT MUUO'S & PAGE FAILS WORK DURING ONCE
	MOVEI	T1,.EPHSB	;SET UP HALT STATUS BLOCK
	WRHSB	T1		; DUMP ADDRESS
>
IFG <CPUN-1>,<
	MOVE	T2,BOOTWD
IFN M.KL10,<
	ANDI	T2,7777
>
	SKIPGE	BOOTCP		;IS THERE ALREADY SOMEBODY AS THE BOOT CPU
	CAME	T2,.CPASN	;SAME AS THE CURRENT CPU?
	AOJA	T4,SYSTR5	;NO, THIS MUST BE CPU1
>
IFE <CPUN-1>,<
	MOVE	T2,.CPASN
>
	MOVEM	T2,SERIAL	;STORE FOR SECOND GETTAB
	MOVE	T1,.CPCPN	;OUR CPU NUMBER
	MOVEM	T1,BOOTCP	;NOBODY ELSE DURING SYSTEM STARTUP
	MOVE	T1,[<PM.DCD>B2+PM.WRT+NUPMPP]
	MOVEM	T1,NLUPMP+.UMUPT

SYSTR5:
IFN FTMP,<
	SETOM	INTRST
>
	JRSTF	@T4		;DO CPU1 INITIALIZATION
SYSTR6:	HLRZ	T2,.CPCDB-.CPCDB(T2)
	JUMPN	T2,SYSTR2
	MOVEI	T2,.C0CDB
SYSTR7:	SKIPE	.CPOCB-.CPCDB(T2)
	JRST	SYSTR8
	MOVEM	T1,.CPASN-.CPCDB(T2)
	JRST	SYSTR3
SYSTR8:	HLRZ	T2,.CPCDB-.CPCDB(T2)
	JUMPN	T2,SYSTR7
IFN FTMP,<
	SETOM	INTRST
>
	HALT	.



APRRES::				;HERE ON TO RESTART
IFE FTMP,<
	EXECAC
	JSP	T4,SYSTR0		;THIS DOES THAT (AND TURNS PAGING ON)
;IFG CPUN-1,<				;SORTA HARD IFE FTMP, EH?
;	 JFCL
;>
	JRSTF	@[IC.UOU+AP0RES]
>;END IFE FTMP
IFN FTMP,<
	EXECAC
	JSP	T4,SYSTR0
IFG CPUN-1,<
	  JFCL
>
	XCT	.CPRES
>;END IFN FTMP
;HERE ON A RESTART AFTER SYSTEM SLEEP, REBOOT

SYSRST::EXECAC			;GET AC SET RIGHT
	CONO	APR,200000	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JFCL			;ALWAYS RESTART VIA SPRINI
	SETZM	MBTCOM		;MAKE SURE THAT DUMPED CRASHES DON'T LOOK REBOOTABLE
	SETZM	CLKDDT		;ZERO CLKDDT SO WE DON'T JUMP TO EDDT
IFN FTKL10,<
	JSP	T4,ZAPICH	;MAKE SURE INT CHANS ARE IN A REASONABLE STATE
>;END IFN FTKL10
	MOVSI	T1,(CR.TSS)	;SUCCESSFUL DUMP BIT
	ANDCAB	T1,.CPRUN	;CLEAR THAT BECAUSE IT MUST HAVE BEEN OR WE WOULDN'T BE HERE
IFG <CPUN-1>,<
	TLNN	T1,(CR.RMV!CR.DET)	;REMOVED OR DETACHED CPU?
	JRST	SPRINI		;NO, REINITIALIZE
	MOVE	P,.CPNPD	;ANY OLD PUSH DOWN LIST WILL DO
	MOVEI	T1,[ASCIZ/?Cannot REBOOT on a CPU which has been removed or DETACHed
/]
	PUSHJ	P,CTYTYP##	;EXPLAIN THE ERROR
	PUSHJ	P,RMVCPU##	;AND GO AWAY
>
;FALL INTO SPRINI ON SINGLE CPU SYSTEMS
SUBTTL INITIALIZATION ON STARTUP/RESTART AFTER SYSTEM SLEEP
;NON-BOOT PROCESSOR INITIALIZATION. REINITIALZATION FOR ALL CPUS
; AFTER SYSTEM SLEEP

SPRINI::CONO	PI,CLRPIS	;CLEAR PI AND PARITY ERROR FLAG
	CONO	APR,APRRST	;RESET EVERYTHING AND ENABLE CLOCK
IFN FTKL10,<
	EXECAC			;MAKE SURE AC BLOCKS ARE OK
>
	MOVSI	P,(CR.RMV!CR.DET) ;"CPU IS DOWN" OR "DETACHED" BITS
	TDNE	P,.CPRUN	;CAN THIS CPU RUN YET
	JRST	.-1		;NO, WAIT UNTIL IT CAN
	MOVE	P,.CPNPD	;SET UP PUSH DOWN POINTER
IFN FTKL10,<
	MOVE	T1,.CPCPN
	PUSHJ	P,DTEINI##
	PUSHJ	P,ENTSPC##	;ENTER SECONDARY PROTOCOL
>;END IFN FTKL10
IFG <CPUN-1>,<
	PUSHJ	P,PRTCPU##	;TELL OPR WHO WE ARE
	MOVSI	T1,(CR.SPD)	;SUSPENDED BIT
	TDNE	T1,.CPRUN	;RESTART AFTER REBOOT RATHER THAT START OR RESTART?
	JRST	SPRIN1		;YES, DON'T WAIT FOR A BOOT CPU TO COME TO LIFE
	MOVE	12,[ACLOOP##,,2];LOAD AC'S WITH WAIT LOOP
	BLT	12,12		;CPU1 WILL WAIT UNTIL CPU0 IS GOING
	MOVE	12,[JRST SPRIN1];TO EXIT LOOP
	SJSP	0,3		;ENTER LOOP

;INITIALIZE PD LIST
SPRIN1:	MOVE	P,.CPNPD	;SET UP PUSH DOWN POINTER
	PUSHJ	P,MAPINI##	;COPY THE BOOT CPU'S MAP INTO THE CURRENT CPU'S MAP
	JRSTF	@[EXP IC.UOU+.+1] ;TURN ON USER IOT SO EXECUTE PAGED WORKS
				; CORRECTLY AND PROCEED WITH INITIALIZATION
	CLRPGT	(0)
	CONO	PI,10000	;AND CLEAR PI SYSTEM
	MOVSI	T1,(CR.SPD)	;SUSPENDED BIT
	TDNE	T1,.CPRUN	;RESTART AFTER REBOOT?
	JRST	SPRIN5		;YES, DISKS ARE INITIALIZED
IFN FTAUTC,<
	PUSHJ	P,AUTCON##	;GO SEE WHAT DISKS, TAPES WE CAN TALK TO
>
SPRIN2:	MOVE	17,[ONCLOP##,,1] ;WAIT IN ACS FOR CPU0 TO REQUEST IO
	BLT	17,16		; DO IT (AT SPRIN3) WHEN REQUESTED
	SJSP	0,3
;HERE FROM LOOP IN THE ACS TO DO DISK I/O DURING ONCE-ONLY ON NON-BOOT CPUS
SPROIO::
SPRIN3:	MOVE	P,.CPNPD	;SET UP A PDL
	SKIPN	T1,ONCCOM	;WHAT CPU0 WANTS US TO DO
	JRST	SPRIN2		;NOTHING TO DO
	AOJE	T1,SPRIN2	;RESTARTED IF -1
	SOS	F,T1		;COMM WORD INTO F
	SOJE	T1,SPRIN5	;DONE IF +1
	PUSHJ	P,MAPINI##	;SOME OTHER NON BOOT CPU MAY
				; HAVE CHANGED MAPS
	PUSHJ	P,CPUDSP##	;GO DO SOME WORK
	JRST	SPRIN2		;AND WAIT SOME MORE

;HERE TO SET UP TO RUN NULL JOB, & SETUP PI
SPRIN5:	PUSHJ	P,MAPINI##
IFN FTSCA,<
IFN M.SCA,<
	CONO	PI,PI.ON+DSKPIN	;TURN ON THE PI SYSTEM AND THE DISK PI'S
	MOVSI	T1,(CR.SPD!CR.IIP)	;SUSPENDED OR INITIALIZE PENDING BITS
	TDNE	T1,.CPRUN	;RESTART AFTER REBOOT OR CPU STARTED LATE?
	PUSHJ	P,SPRIPX	;YES, RE-INITIALIZE THE PHYSICAL PORT DRIVERS
>; END IFN M.SCA
>; END IFN FTSCA
IFN FTKL10,<
	PUSHJ	P,CSDMP##	;ONCE ONLY/FILSER MAY HAVE DRAGGED
				; SOMETHING INTO THE CACHE
>
>
	MOVEI	T1,CCTYO##	;GET ADDRESS OF TYPEOUT ROUTINE
	MOVEM	T1,.CPTOA	; AND TELL SCNSER
	MOVEI	T1,COMTIV##	;GET ADDRESS OF COMMAND INPUT ROUTINES
	MOVEM	T1,.CPTIV	; AND TELL SCNSER TO USE LDB'S NOW.
	SETZM	.CPTNT		;JUST STARTING
	MOVE	J,.CPCPN	; FOR THIS CPU
	SETZM	CLKMIN(J)	;CLEAR MIN REQUEST
IFN FTMP,<
	SETOM	.CPSCD		;CLEAR SCHED NESTING
	SETZM	.CPNBI		;CLEAR NUMBER OF BROKEN INTERLOCKS
	SETOM	.CPDLK		;CLEAR DSKOFF NESTING
IFN FTSCA,<
	SETOM	.CPSCA		;CLEAR SCA BUFFER MANAGEMENT NESTING
>; END IFN FTSCA
IFN FTENET,<
	SETOM	.CPETH		;CLEAR ETHERNET NESTING
>; END IFN FTENET
>;END IFN FTMP
	SETOM	.CPDWD		;GIVE UP DIE RECURSION INTERLOCK
	SETZM	.CPAEF		;CLEAR CPU ERROR/SWEEP FLAGS
	HRRZS	.CPMPC		;CLEAR SERIOUS MEMORY PARITY HALT FLAG
				; HALT AFTER PRINTING ON CPU0 CTY
	MOVE	T1,TIME		;GET CURRENT TIME
	MOVEM	T1,.CPTML	;STORE FOR TICKS GONE BY
	MOVE	T2,TICSEC	;TICK PER SECOND
	LSH	T2,-1		;DIVIDE BY 2
	ADD	T1,T2		;AND ROUND
	IDIV	T1,TICMIN	;T2 = PARTIAL MINUTE (IN TICKS)
	IDIV	T2,TICSEC	;T2 = SECONDS, T3 = REMAINDER IN TICKS
	SUBI	T2,^D60		;COMPUTE TIME TO NEXT MINUTE
	MOVNM	T2,.CPSEC	;STORE FOR ONCE-A-MINUTE UPDATE
	SUB	T3,TICSEC	;TIME TO NEXT SECOND
	MOVNM	T3,.CPHTM	;STORE FOR ONCE-A-SECOND UPDATE
	MOVEI	T1,SR.STS!SR.DIE!SR.ACL ;CLEAR THESE BITS WHEN WE
	ANDCAM	T1,.CPSBR	; RESTART THE PROCESSOR
IFG <CPUN-1>,<
	MOVEI	J,JOBMAX	;MAX JOB NO.
	MOVSI	T1,(SP.CJ0)	;JOB RUNNING ON CPU1 BIT
	LSH	T1,@.CPCPN
SPRLP1:	ANDCAM	T1,JBTSPS(J)	;CLEAR FOR ALL JOB IN SYSTEM
				; (IN CASE THIS IS A 450 RESTART ON CPU1)
	SOJGE	J,SPRLP1	;MORE?
>
IFN FTKL10,<
	APRID	T3		;PROCESSOR HARDWARE OPTIONS
	DMOVE	T1,[M.EBPS	;ASSUME A MODEL A PROCESSOR
		M.MBPS]
	TRNE	T3,ID.XKL	;IS IT A MODEL B PROCESSOR?
	DMOVE	T1,[^D30*M.EBPS/^D25 ;YES, USE DIFFERENT EBOX/MBOX CALABRATION CONSTANTS
		^D30*M.MBPS/^D25]
	MOVEM	T1,.CPEBS	;STORE AS EBOX TICS/SEC
	MOVEM	T2,.CPMBS	;STORE AS MBOX TICS/SEC
	IDIV	T1,TICSEC	;AND NOW GET EBOX COUNTS/JIFFY
	IMULI	T1,.EBCPT	;MULTIPLY BY EBOX COUNTS/TICK
	MOVEM	T1,.CPEBJ	;STORE IN CDB VARIABLE
	MOVE	T1,.CPMBS	;GET MBOX TICKS/SECOND
	IDIV	T1,TICSEC	;GET MBOX COUNTS/JIFFY
	IMULI	T1,.MBCPT	;MULTIPLY BY MBOX COUNTS/TICK
	MOVEM	T1,.CPMBJ	;SAVE
	PUSHJ	P,SETCLK	;SETUP CLOCKS, PI, APR
>
IFN FTKS10,<
	PUSHJ	P,UBAPIS	;MAKE SURE UBA'S HAVE A PIA
>
IFN FTKL10,<
	PUSHJ	P,RNXSAK##	;INSURE ALL RP20 DX20'S ARE RUNNING
>
	HLRZ	U,SYSUNI##	;FIRST UNIT IN THE SYSTEM
	MOVN	J,TICSEC	;AVOID BRKLOK
	MOVEM	J,.CPOK		;CALLS BY THE BOOT CPU
IFN FTMP,<
IFG	M.CPU-1,<
	CPLOCK	(SCD)	;CROCK TO INSURE MC AVAILABLE
>
	SKIPL	MCREQ##	; BEFORE CALL TO ATTCPD
IFG	M.CPU-1,<
	JRST	[CPUNLK (SCD)
                 JRST .-2]
>
IFLE	M.CPU-1,<
	  JRST	.-1
>
SPRIN7:	HRRZ	J,UNIKON##(U)	;KONTROLLER DATA BLOCK
	MOVE	T1,KONCAM##(J)	;CPU THIS CONTROLLER LIVES ON
	TDNN	T1,.CPBIT	;CURRENT CPU?
	JRST	SPRIN8		;NO, ONWARD AND UPWARD
	PUSHJ	P,ATTCPD##	;YES, ATTACH THE UNIT
	  JFCL			;DON'T CARE
	  JFCL			;THIS ONE EITHER
SPRIN8:	HLRZ	U,UNISYS##(U)	;NEXT UNIT IN THE SYSTEM
	JUMPN	U,SPRIN7	;GO IF NOT THE LAST
IFG	M.CPU-1,<
	CPUNLK	(SCD)
>
>
	SETZB	S,P1		;ALWAYS CALL INI ROUTINE ONCE
	HLRZ	P3,HNGLST	;LOOK ONLY AT REAL HARDWARE
SPRIN9:	MOVE	F,P3		;SETUP F FOR INI CODE
	MOVE	P3,DEVSER(P3)	;ADDRESS OF DEVICE DISPATCH VECTOR
IFN FTMP,<
	LDB	T1,DEYCPF	;CPU OWNING THE DEVICE
	CAMN	T1,.CPCPN	;CURRENT CPU?
>;END IFN FTMP
	CAIN	P1,(P3)		;YES, ALREADY CALLED INI ROUTINE?
	JRST	SPRI10		;YES, SKIP ON
	MOVSI	T1,DVMTA	;SPECIAL CHECK FOR MAGTAPE
	TDNN	T1,DEVMOD(F)	;ALWAYS DO INITIALIZATION FOR MAGTAPE
	SKIPN	.CPAID		; (SEE TPMINI) OR IF OTHER DEVICES
	CAIA			; HAVEN'T BEEN INITIALIZED YET
	JRST	SPRI10		; OTHERWISE SKIP ON
	PUSHJ	P,DINI(P3)	;NO, CALL INI ROUTINE
	  HRRZ	P1,P3		;NEEDN'T CALL IT AGAIN
SPRI10:	HLRZS	P3		;NEXT DDB
	JUMPN	P3,SPRIN9	;LOOP IF THERE IS ONE
IFN FTAUTC&FTMP,<
	PUSHJ	P,T1CINI##	;MARK PAGTAB SO DX10 DATA BASE WILL NEVER BE UNCACHED
>
IFN FTKL10,<
	PUSHJ	P,SETCSH##	;SET CACHE STRATEGY AS ESTABLISHED BY KLI
	PUSHJ	P,STAPPC##	;PATCH TO JFCL TO INHIBIT STARTING PRIMARY PROTOCOL
>; END IFN FTKL10
IFN FTKS10,<
	PUSHJ	P,ENAKAL##	;ENABLE KEEP ALIVE
>
	SETOM	.CPAID		;INDICATE DEVICES HAVE ALREADY BEEN INITIALIZED
	MOVSI	T1,(CR.SPD)	;SUPPENDED BIT
	TDNE	T1,.CPRUN	;RESTARTING AFTER SYSTEM SLEEP?
	PUSHJ	P,DSKRCL	;YES, GENERATE A FREE INTERRUPT FROM ALL DSKS
				; SO FILIO WILL REREAD THE HOME BLOCK AND
				; VERIFY THAT PACKS WEREN'T MOVED WHILE ASLEEP
	MOVSI	T1,(CR.SPD)	;SUPPENDED BIT
IFN FTNET,<
	TDNE	T1,.CPRUN	;IF RESTARTING,
	PUSHJ	P,FEKCPW##	; TELL THE FEK'S
>
	ANDCAM	T1,.CPRUN	;CLEAR IT SINCE RESUMING
IFG <CPUN-1>,<
	SKIPE	J,.CPJOB	;IF A RESTART AND A JOB WAS RUNNING,
	PUSHJ	P,CPUZAP##	; ZAP IT AND INFORM THE USER
	SETZM	.CPJOB		;NO PREVIOUS JOB
	SETZM	.CPDRQ		;NO MORE DISKS TO RESCUE
>
	CLRPGT	(0)
	SJSP	U,NULJB1	;GO START NULL JOB

SYSINH::MOVEI	T1,DF.BPT	;GET MASK OF ALL CPU BREAKPOINT ENABLE BITS
	MOVEI	T2,JS.BPT	;GET THE "SET EDDT BREAKPOINT" ON BIT
	TDNE	T1,DEBUGF	;ANY CPUS SET TO BREAKPOINT?
	IORM	T2,JBTSTS	;YES--ALLOW ^D TO DO IT'S THING
	PUSHJ	P,CSHINI##	;INIT MONITOR DISK CACHE
				;(WE HAVE TO BE OUT OF LOW SEG, AS CSHINI
				;ALLOCATES FRECOR AND BLOWS US AWAY)
IFN FTMP,<
	MOVEI	T1,1
	MOVEM	T1,ONCCOM	;TELL ALL CPUS TO START
>
	SJSP	U,NULJB1	;START THE NULL JOB (J ZERO, U NON-ZERO)
;ROUTINE CALLED ON EACH CPU TO INIT IPA DEVICES

SPRIPX::MOVSI	T1,(CR.IIP)	;IPA INITIALIZE PENDING
	ANDCAM	T1,.CPRUN	;NO LONGER PENDING, THIS CPU IS RUNNING
IFN FTSCA,<
IFN M.SCA,<
	CONO	PI,PI.ON+DSKPIN	;TURN ON THE PI SYSTEM AND THE DISK PI'S
	PUSHJ	P,PPDINX	;INITIALIZE THE PHYSICAL PORT DRIVER
>; END IFN M.SCA
>; END IFN FTSCA

IFN FTENET,<
	PUSHJ	P,KNIINI##	;INITIALIZE THE KLNI PORT DRIVER
>; END IFN FTENET

	POPJ	P,		;DONE
SETCLK:
IFN FTEMRT,<
	PUSHJ	P,ACCMON##	;START UP ACCOUNTING METERS
	PUSHJ	P,CLREMB##	;CLEAR OUT E AND MBOX ACCOUNTING METERS
>;END IFN FTEMRT
	PUSHJ	P,SETIME	;TO INITILIZE 'GGTIME' CLOCK (IN SYSINI)
IFN FTKL10,<
	CONI	MTR,T1		;PRESERVE TIME BASE INFO
	CONO	MTR,APRCHN(T1)	;SETUP INTERVAL TIMER PI
IFG <CPUN-1>,<
	MOVE	T1,BOOTCP	;BOOT CPU
	MOVSI	T2,40000	;SUPPENDED BIT
	TDNN	T2,.CPRUN	;THERE MIGHT NOT BE A BOOT CPU AFTER A REBOOT
	CAMN	T1,.CPCPN	;ALSO COULD BE THE BOOT - WARM RESTART
	JRST	SETCL1		; SO DON'T WAIT ON IT
	LSH	T1,.CPSOF	;OFFSET TO ITS CDB
	SKIPE	T2,.C0TMF(T1)	;WAIT UNTIL CLOCK FLAG CLEARS, ZERO T2
	JRST	.-1
	SKIPN	.C0TMF(T1)	;TIME FROM SET UNTIL SET
	JRST	.-1
	SKIPE	.C0TMF(T1)
	AOJA	T2,.-1
	SKIPN	.C0TMF(T1)
	AOJA	T2,.-1
	MOVE	T3,.CPCPN	;OUR CPU NUMBER
	SUB	T3,BOOTCP	; MINUS THE BOOT CPU NUMBER
	SKIPG	T3		;IF NEGATIVE, (NEVER EQUALS ZERO)
	ADDI	T3,CPUN		; MODULO THE NUMBER OF CPU'S
	IMULI	T2,(T3)
	IDIVI	T2,CPUN		;FRACTION OF A TIC TO WAIT
	SOJG	T2,.		; BEFORE STARTING THE CLOCK
>
SETCL1:	MOVEI	T1,^D1666	;ASSUME 60HZ
	MOVE	T2,STATES
	TLNE	T2,(ST.CYC)	;IS OUR ASSUMPTION CORRECT?
	MOVEI	T1,^D2000	;NO, 2000 IS INTERVAL
	CONO	TIM,TO.CTD!TO.CIT!TO.SIT(T1)	;START TIMER GOING
>
	CONO	APR,APRNUL
	CONO	PI,PI.CPI!PI.TNP!PI.ON!II.ACO!IFE FTKS10,<PI.EPE>
				;TURN ON ALL PI, ENABLE MEMORY PARITY
	POPJ	P,
;SUBROUTINE TO DO A RECAL ON EVERY DISK THAT THE SYSTEM KNOWS ABOUT
; THIS WILL CAUSE A FREE INTERRUPT TO BE GENERATED BY EACH DISK WHICH
; WILL CAUSE FILIO TO REREAD AND VERIFY HOME BLOCKS ON EVERY PACK
; CURRENTLY SPINNING. THUS IF SOME PACKS WERE REMOVED OR MOVED DURING
; THE SYSTEM SLEEP OR POWER FAIL, THE OPERATOR WILL BE COMPLAINED AT
; AND THERE WILL BE NO CHANCE OF COMPROMISING DATA INTEGRITY.

DSKRCL:	MOVEI	U,SYSUNI##-UNISYS## ;START AT FIRST UNIT ON SYSTEM
DSKRC1:	HLRZ	U,UNISYS##(U)	;NEXT UNIT
	JUMPE	U,CPOPJ		;DONE IF LAST UNIT
	HRRZ	J,UNIKON##(U)	;KONTROLLER THIS UNIT IS CONNECTED TO
	MOVSI	T1,U2PNRM##	;FIXED MEDIA BIT
IFG <CPUN-1>,<
	MOVE	T2,KONCAM##(J)	;CPU THAT THIS KONTROLLER IS ON
	TDNE	T2,.CPBIT	;THIS CPU?
>
	TDNE	T1,UNIDS2##(U)	;AND NOT FIXED MEDIA (THAT BETTER NOT MOVE)
	JRST	DSKRC1		;NEXT UNIT IF NOT THE RIGHT CPU OR FIXED MEDIA
	SKIPN	UNISTS##(U)	;DON'T RECAL IF NOT IDLE (POWER FAIL)
	PUSHJ	P,@KONRCL##(J)	;RECALIBRATE SO WE WILL GET A FREE INTERRUPT AND
				; REREAD THE HOME BLOCKS IN CASE A PACK WAS MOVED
	  JFCL			;DON'T CARE IF OFF-LINE
	JRST	DSKRC1		;LOOK AT NEXT UNIT
SUBTTL	EXEC DATA VECTOR SETUP


; HERE TO SET UP SOME EXEC DATA VECTOR QUANTITIES.  THESE VARIABLES
; ARE REQUIRED TO SET UP PAGING SO THAT GETTAB AND JOBPEK UUOS MAY
; BE SIMULATED ON A MONITOR CRASH FILE.  THESE WORDS CONTAIN CPU
; DEPENDANT INFORMATION.  THE EXEC DATA VECTOR FOR THE BOOT CPU, NOT
; THE CRASHING CPU, WILL BE POINTED TO BY .JBEDV IN JOBDAT.  ON ALL
; SYSTEMS, .JBEDV IS SET UP AT SYSTEM STARTUP.  ON MULTI-CPU SYSTEMS,
; .JBEDV IS RESET ON EVERY ROLE SWITCH.  .JBEDV (AND THE CPU DEPENDANT
; EDVS) WILL REQUIRE ADDRESS FIXUPS IF A "SET MEMORY OFFLINE" COMMAND
; IS EXECUTED.  THIS BE BECAUSE THE EDVS CONTAIN PHYSICAL ADDRESSES.
;
SETEDV::PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;SAVE T2
	MOVEI	T1,EDVSET	;POINT TO SUBROUTINE
	PUSHJ	P,CPUAPP	;EXECUTE IT OVER ALL CPUS
IFN FTMP,<
	SKPCPU	(0)		;ARE WE THE BOOT CPU?
	JRST	TTPOPJ		;NO--JUST RETURN
>
	MOVEI	T1,.CPEDV	;POINT TO OUR EDV BLOCK
	PUSHJ	P,EDVMAP	;MAP THE ADDRESS
	MOVEM	T2,.JBEDV##	;STASH IT AWAY FOR CURIOUS PROGRAMS
	JRST	TTPOPJ		;RESTORE ACS AND RETURN

EDVSET:	HRRZ	T2,.CPTYP-.CPCDB(P1) ;GET DEC CPU TYPE CODE
	APRID	T1		;READ SERIAL NUMBER
	TLO	T2,(ED.KLP)	;ONLY KL-PAGING IS SUPPORTED
IFN FTKL10,<
	TRNE	T1,ID.XKL	;EXTENDED KL10?
	TLO	T2,(ED.XKL)	;YES
>
	MOVEM	T2,.CPEDV-.CPCDB+.EDDAT(P1) ;SAVE IT
	MOVE	T1,.CPEPT-.CPCDB(P1) ;GET VIRTUAL ADDRESS OF OUR EPT
	PUSHJ	P,EDVMAP	;MAP PHYSICAL
	MOVEM	T2,.CPEDV-.CPCDB+.EDEPT(P1) ;SAVE IT

	MOVEI	T1,@.CPSPT-.CPCDB(P1) ;GET VIRTUAL ADDRESS OF OUR SPT
	PUSHJ	P,EDVMAP	;MAP PHYSICAL

	MOVEM	T2,.CPEDV-.CPCDB+.EDSPT(P1) ;SAVE IT
	SETZM	.CPEDV-.CPCDB+.EDCST(P1) ;NO CST NONSENSE ON TOPS-10
	POPJ	P,		;RETURN

EDVMAP:	MAP	T2,(T1)		;CONVERT VIRTUAL ADDRESS TO PHYSICAL
	TLZ	T2,(777B8)	;STRIP OFF PAGE MAP FLAGS
	POPJ	P,		;RETURN
;DTE20 DEVICE CODES FROM DTEPRM.MAC

	DTE0==200
	DTE1==204
	DTE2==210
	DTE3==214

;RH20 DEVICE CODES

	RH2==540
	RH21==544
	RH22==550
	RH23==554
	RH24==560
	RH25==564
	RH26==570
	RH27==574

;OTHER DEVICES

	FHD2==174	;DEVICE CODE FOR SECOND FIXED HEAD CONTROLLER
	DPC==250	;DISK PACK CONTROL - NOT IN MACRO.SVE FOR SPMON
	DPC2==254	;DEVICE CODE FOR SECOND DISK PACK CONTROLLER
	DPC3==260
	DPC4==264
	DAS==324
	FSD==270
	FSD2==274
	FSD3==360
	DAC==320
	DBS==334
	DBC==330
	DLC==64
	DLC2==164
	DLB==60
	DLB2==160
	CDR2==154
	LPT2==234
	LPT3==230
	LPT3==230
	PLT2==144
	DX10==220
;SUBROUTINE TO STORE INFORMATION IN THE CPU STATUS BLOCK

CPUSTS::APRID	.CPAPD		;(0) APRID
	CONI	APR,.CPACN	;(1) CONI APR,
	CONI	PI,.CPPIC	;(2) CONI PI,
	DATAI	PAG,.CPPGD	;(3) DATAI PAG,
	CONI	PAG,.CPPGC	;(4) CONI PAG,
	MOVE	T1,[.USMUO,,.CPUP0] ;(5) UPT LOCS 424-427
	BLT	T1,.CPUP0+3
IFN M.KL10,<
	RDERA	.CPERA		;(11) RDERA
	CONI	RH2,.CPRHC	;(12) CONI RH20, FOR ALL 8 RH'S
	CONI	RH21,.CPRHC+1
	CONI	RH22,.CPRHC+2
	CONI	RH23,.CPRHC+3
	CONI	RH24,.CPRHC+4
	CONI	RH25,.CPRHC+5
	CONI	RH26,.CPRHC+6
	CONI	RH27,.CPRHC+7
	CONI	DTE0,.CPDTC	;(22) CONI DTEn
	CONI	DTE1,.CPDTC+1
	CONI	DTE2,.CPDTC+2
	CONI	DTE3,.CPDTC+3
	HRLZ	T1,.CPEPT	;(26) EPT LOCS 0-37
	HRRI	T1,.CPEP0
	BLT	T1,.CPEP0+37
	MOVE	T1,.CPEPT	;(66) EPT LOCS 140-147
	HRLI	T1,140(T1)
	HRRI	T1,.CPEP1
	BLT	T1,.CPEP1+37
>
	MOVE	T1,[.UPMP+500,,.CPUP1] ;(126) UPT LOCS 500-503
	BLT	T1,.CPUP1+3
IFN M.KL10,<
	EXECAC	(6)		;(132) AC BLOCK 6, REGS 0-3 AND 12
	MOVEM	0,.CP6
	MOVEM	1,.CP6+1
	MOVEM	2,.CP6+2
	MOVEM	3,.CP6+3
	MOVEM	12,.CP6+4
>
IFN M.KS10,<
	RDCSTM	.CP6
	RDPUR	.CP6+1
	RDCSB	.CP6+2
	RDSPB	.CP6+3
>
	EXECAC	(7)		;(136) AC BLOCK 7, REGS 0-2
	MOVEM	0,.CP7
	MOVEM	1,.CP7+1
	MOVEM	2,.CP7+2
	DATAO	PAG,.CPPGD	;RESTORE ORIGIONAL AC BLOCK
IFN M.KL10,<
	PUSHJ	P,REDSBD	;READ SBDIAG INFO
>
REPEAT 0,<
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	LSH	T1,1		;MULTIPLY BY 2
	MOVE	T2,.CPSLF	;ADDRESS OF THIS CPU'S CDB
	ADDI	T2,.CPAPD-.CPCDB ;OFFSET OF CPU STATUS BLOCK IN CDB
	MOVEM	T2,110(T1)	;STORE ADDRESS OF CPU STATUS BLOCK FOR F/S
	MAP	T2,(T2)		;ABSOLUTE ADDRESS OF CPU STATUS BLOCK
	MOVEM	T2,111(T1)	;STORE IT FOR FIELD SERVICE
>;END REPEAT 0
	MOVEI	T1,SR.CSB	;SET FLAG TO INDICATE CPU
	IORM	T1,.CPSBR	;STATUS BLOCK READ ON THIS CPU
	POPJ	P,
IFN M.KL10,<
;ROUTINE TO CLEAR SBUS ERRORS IN EACH MEMORY CONTROLLER.  RETURNS
;CPOPJ ALWAYS AND PRESERVES ALL AC'S.

CLRSBD::PUSHJ	P,SAVE3		;SAVE P1-P3
	MOVSI	P1,-.SBNMC	;MAKE AOBJN POINTER TO ALL MEM CONTROLLERS
	MOVSI	P2,SB.CLR	;BIT TO CLEAR ALL ERRORS
CLRSB1:	DPB	P1,[POINT 5,P2,4] ;STORE MEMORY CONTROLLER NUMBER
	SBDIAG	P2		;CLEAR THE ERROR BITS
	AOBJN	P1,CLRSB1	;LOOP FOR ALL CONTROLLERS
	POPJ	P,		;RETURN


;ROUTINES TO PERFORM SBDIAG FUNCTIONS 0 AND 1 FOR EACH MEMORY CONTROLLER.
;CALL REDSBD TO JUST READ THE DATA.  CALL REDSBC TO READ THE DATA AND
;CLEAR THE ERRORS.  THE FORMAT OF THE SBDIAG STATUS BLOCK IS AS FOLLOWS:
;	WORD 0: -NUMBER OF DATA BLOCKS,,OFFSET TO FIRST BLOCK
;EACH DATA BLOCK HAS THE FOLLOWING FORMAT:
;	WORD 0: -NUMBER OF WORDS FOLLOWING,,CONTROLLER NUMBER
;	WORD 1: SBDIAG FUNCTION 0 FROM-MEMORY WORD
;	WORD 2: SBDIAG FUNCTION 1 FROM-MEMORY WORD
;DESTROYS T1, PRESERVES ALL OTHERS

REDSBD::TDZA	T1,T1		;CLEAR T1 AND SKIP
REDSBC::MOVSI	T1,SB.CLR	;BIT TO CLEAR ERRORS
	PUSHJ	P,SAVE4		;SAVE P1-P4
	SETZM	.CPSBD		;CLEAR FIRST WORD OF BLOCK FOR COUNT
	MOVSI	P1,-.SBNMC	;AOBJN POINTER TO MEMORY CONTROLLERS
	MOVEI	P2,.CPSBD+1	;START FIRST BLOCK HERE
	HRLI	P2,-.SBFNC	;-FUNCTIONS TO LH
REDSB1:	MOVEI	P3,0		;SET TO BUILD TO-MEMORY WORD
	DPB	P1,[POINT 5,P3,4] ;STORE MEMORY CONTROLLER
	SBDIAG	P3		;DO FUNCTION 0
	PUSH	P,P4		;SAVE FUNCTION 0 FROM-MEMORY WORD
	JUMPE	T1,REDSB2	;AVOID 2ND SBDIAG IF NOT CLEARING CONTROLLER
	IOR	P3,T1		;SET SB.CLR
	SBDIAG	P3		;DO FUNCTION 0 TO CLEAR CONTROLLER
REDSB2:	TRO	P3,1		;MAKE IT FUNCTION 1
	SBDIAG	P3		;DO FUNCTION 1
	POP	P,P3		;RESTORE FUNCTION 0 FROM-MEMORY WORD
	SKIPN	P3		;ANYTHING THERE?
	JUMPE	P4,REDSB3	;NO, NO MEMORY CONTROLLER IF BOTH ZERO
	MOVEM	P3,1(P2)	;SAVE FUNCTION 0 WORD IN THE BLOCK
	MOVEM	P4,2(P2)	;  ALONG WITH FUNCTION 1 WORD
	HRRZM	P1,0(P2)	;SAVE CONTROLLER NUMBER AS WORD 0
	HLLM	P2,0(P2)	;MAKE IT -WORDS,,CONTROLLER
	AOS	.CPSBD		;COUNT THIS CONTROLLER
	ADDI	P2,.SBFNC+1	;INCREMENT TO NEXT BLOCK
REDSB3:	AOBJN	P1,REDSB1	;LOOP FOR NEXT CONTROLLER
	MOVN	P1,.CPSBD	;GET NUMBER OF BLOCKS WE STORED
	JUMPE	P1,CPOPJ	;LEAVE IT ZERO IF NONE
	HRLI	P1,1		;MAKE SWAPPED HEADER WORD
	MOVSM	P1,.CPSBD	;SAVE IN WORD 0
	POPJ	P,		;RETURN
>;END IFN M.KL10
;SUBROUTINE TO READ AND STORE DEVICE STATUS

DVCSTS::MOVSI	T1,-DVSLEN	;LENGTH OF DEVICE STATUS TABLE
	XCT	DVSXCT(T1)	;DO THE I/O INSTRUCTION
	AOBJN	T1,.-1		;LOOP FOR ALL OF THEM
IFN M.KL10,<
	HRLI	T1,-10		;NOW DO THE EIGHT RH20'S
DVCST1:	LDB	T2,[POINT 7,DVSXCT(T1),9] ;GET THE DEVICE CODE
	MOVE	T3,[CONI RH2,T3] ;LOAD CONI INSTRUCTION
	DPB	T2,[POINT 7,T3,9] ;MAKE IT SPECIFIC TO THIS RH20
	XCT	T3		;DO THE CONI
	JUMPL	T3,DVCST2	;JUMP IF NOT AN RH20 (CI/NI)
	MOVE	T3,[DATAO RH2,RH2IVI] ;LOAD DATAO INSTRUCTION
	DPB	T2,[POINT 7,T3,9] ;MAKE IT SPECIFIC TO THIS RH20
	XCT	T3		;DO THE DATAO TO SELECT IVI REGISTER
	XCT	DVSXCT(T1)	;NOW DO THE DATAI TO READ THE IVI
DVCST2:	AOBJN	T1,DVCST1	;LOOP FOR ALL EIGHT RH20'S
>; END IFN M.KL10
IFN M.KS10,<
	PUSH	P,.USPFP
	PUSH	P,.USPFP+1	;SAVE PREVIOUS PC
	PUSH	P,.USPFW
	MOVSI	T1,-KSRTBL	;POINTER TO DEVICE ADDRESS TABLE
	MOVEI	T2,DVCST2	;TRAP ADDRESS FOR NX DEVICES
	EXCH	T2,.USPFN+1	;SET IT AND SAVE CURRENT ONE
DVCST1:	RDIO	T4,@KSRTAB(T1)	;READ SOME REGISTER
	MOVEM	T4,.CPUB1(T1)	;SAVE IT IN RIGHT SLOT
				;*** HERE ON NX DEVICE TRAP
DVCST2:	AOBJN	T1,DVCST1	;DO NEXT
	EXCH	T2,.USPFN+1	;RESTORE TRAP ADDRESS
	POP	P,.USPFW
	POP	P,.USPFP+1
	POP	P,.USPFP
>;END IFN M.KS10
	MOVEI	T1,SR.DSB	;SET FLAG TO INDICATE
	IORM	T1,.CPSBR	;DEVICE STATUS BLOCK READ
	POPJ	P,

IFN M.KL10,<
RH2IVI:	.DOIVI			;DATAO TO SELECT IVI
>
;TABLE OF INSTRUCTIONS TO EXECUTE TO FILL IN CDB ENTRIES BEGINNING
;AT CDB VARIABLE .CPDVS.  THE ORDER OF THIS TABLE MUST MATCH THE
;ORDERING OF ENTRIES IN THE CDB AT CDB VARIABLE .CPDVS.

;FOR THE KS10 THIS TABLE IS USED A LITTLE DIFFERENTLY.  THE FIRST
;PART OF THE TABLE CONTAINS I/O INSTRUCTIONS JUST LIKE FOR THE
;KL10.  THE SECOND PART OF THE TABLE CONTAINS THE DEVICE REGISTER
;ADDRESS FOR UNIBUS DEVICES.

DVSXCT::
IFN M.KL10,<
	CONI	TIM,.CPTMR		;INTERVAL TIMER STATUS
	CONI	MTR,.CPMTR		;METER STATUS
	CONI	TTY,.CPTTY
	CONI	PTR,.CPPRA
	CONI	PTP,.CPPPA
	CONI	DLS,.CPDLS
	CONI	DAC,.CPDAC
	CONI	DAS,.CPDAS
	CONI	CR,.CPCRA
	CONI	LPT,.CPLPT
	CONI	PLT,.CPPLA
	CONI	TMS,.CPTMS
	CONI	TMC,.CPTMC
	CONI	DX10,.CPDX1
	CONI	DSK,.CPDSK
	CONI	FHD2,.CPFH2
	CONI	FSD,.CPFSD
	CONI	FSD2,.CPFS2
	CONI	FSD3,.CPFS3
	CONI	DPC,.CPDPC
	CONI	DPC2,.CPDP2
	CONI	DPC3,.CPDP3
	CONI	DPC4,.CPDP4
	CONI	DBS,.CP2DS		;2ND TD10
	CONI	DBC,.CP2DC
	CONI	DLC,.CPDLC
	CONI	DLB,.CPDLB
	CONI	DLC2,.CPDC2
	CONI	DLB2,.CPDB2
	CONI	CDP,.CPCDP
	CONI	CDR2,.CPCRB		;CDR1
	CONI	LPT2,.CPLPB		;LPT1
	CONI	LPT3,.CPLPC		;LPT2
	CONI	PLT2,.CPPLB		;PLT1
	DATAI	APR,.CPDAK		;ADDRESS BREAK CONDITIONS
	DATAI	DSK,.CPDDK
	DATAI	FHD2,.CPDH2
	DATAI	FSD,.CPDFS
	DATAI	FSD2,.CPDS2
	DATAI	FSD3,.CPDS3
	DATAI	DPC,.CPDDP
	DATAI	DPC2,.CPDD2
	DATAI	DPC3,.CPDD3
	DATAI	DPC4,.CPDD4
	DATAI	DLC,.CPDDC
	DATAI	DLB,.CPDDB
	DATAI	DLC2,.CPD2C
	DATAI	DLB2,.CPD2B
DVSLEN==.-DVSXCT		;LENGTH OF (NON-RH20) I/O INSTRUCTION TABLE
	DATAI	RH2,.CPIVI
	DATAI	RH21,.CPIVI+1
	DATAI	RH22,.CPIVI+2
	DATAI	RH23,.CPIVI+3
	DATAI	RH24,.CPIVI+4
	DATAI	RH25,.CPIVI+5
	DATAI	RH26,.CPIVI+6
	DATAI	RH27,.CPIVI+7
>;END IFN M.KL10
IFN M.KS10,<
	RDINT	.CPTMR
	RDTIME	.CPTMB
DVSLEN==.-DVSXCT		;LENGTH OF I/O INSTRUCTION TABLE
	RDTIME	.CPTMB+1	;THIS IS A DUMMY AS RDTIME RETURNS 2 WORDS
KSRTAB:	XWD	1,UNBSTW	;UBA1 STATUS REGISTER
	XWD	3,UNBSTW	;UBA3 STATUS REGISTER
	RH11CA			;RPCS1
	RH11CA+10		;RPCS2
	RH21CA			;MTCS1
	RH21CA+10		;MTCS2
	LP11CA			;LPT CSRA
	LP11CA+2		;LPT CSRB
	CD11BA			;CDR CDST
	PR11CA			;PTR CSR
	PP11CA			;PTP CSR
	RX21BA			;RXA CSR
KSRTBL==.-KSRTAB		;LENGTH OF REGISTER TABLE
>; END IFN M.KS10
IF1,<IFN <.-DVSXCT>-.CPDVL,<PRINTX ?DVSXCT TABLE IS INCORRECT>>
LENDVS==:<.-DVSXCT-1>B26	;LENGTH OF TABLE OF INSTRUCTIONS FOR GETTAB
;HERE FROM THE DIAG. UUO IN FILIO (FUNCTION 10) TO READ THE CPU STATUS
;BLOCK.
DIACSB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	MOVEI	T1,.ERCSB	;DAEMON ERROR CODE
	JRST	DIADS1		;JOIN COMMON CODE


;HERE FROM THE DIAG. UUO IN FILIO (FUNCTION 11) TO READ THE DEVICE
;STATUS BLOCK.
DIADSB::PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
	MOVEI	T1,.ERDSB	;DAEMON ERROR CODE
DIADS1:	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEEIM##	;PLACE IN DAEMON ERROR QUEUE
	JRST	CPOPJ1		;GIVE SUCCESS RETURN FROM UUO
;ROUTINE TO TYPE RELEVANT PARTS OF THE CPU STATUS BLOCK ON THE CTY
;WHEN A CRASH OCCURS.

TYPCSB::PUSHJ	P,INLMES##
	ASCIZ/

CPU Status Block
/
	PUSHJ	P,INLMES##
	ASCIZ/
APRID = /
	MOVE	T1,.CPAPD	;GET APRID
	PUSHJ	P,HWDPNT##	;TYPE IT
IFN M.KL10,<
	PUSHJ	P,INLMES##
	ASCIZ/
ERA = /
	SKIPN	T1,.CPAER
	MOVE	T1,.CPERA	;GET ERA
	PUSHJ	P,HWDPNT##	;TYPE IT
>;END IFN M.KL10
	PUSHJ	P,INLMES##
	ASCIZ/
CONI APR, = /
	MOVE	T1,.CPACN	;GET CONI APR
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PI, = /
	SKIPN	T1,.CPCPI
	MOVE	T1,.CPPIC	;GET CONI PI
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PAG, = /
	MOVE 	T1,.CPPGC	;GET CONI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
DATAI PAG, = /
	MOVE	T1,.CPPGD	;GET DATAI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
IFN M.KL10,<
	PUSHJ	P,INLMES##
	ASCIZ/
AR ARX Data Word = /
	MOVE	T1,.CP7		;GET AC BLOCK 7 LOC 0
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
IO Page Fail Word = /
	MOVE 	T1,.CP7+2	;GET AC BLOCK 7 LOC 2
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/

SBUS Diags:

CNTRLR FNC 0          FNC 1
/
	PUSHJ	P,TYPSBD	;TYPE SBDIAG INFORMATION
>;END IFN M.KL10
	PJRST	CRLF##		;END WITH CRLF AND RETURN
;ROUTINE TO TYPE THE SBDIAG FUNCTIONS AND VALUES ON THE CTY WHEN
;A CRASH OCCURS.

IFN M.KL10,<
TYPSBD::PUSH	P,P1		;SAVE P1
	PUSH	P,P2		;  AND P2
	MOVE	P1,.CPSBD	;GET -# BLOCKS,, OFFSET TO FIRST
	HRRZI	P2,.CPSBD(P1)	;POINT AT FIRST BLOCK
TYPSB1:	HLL	P2,0(P2)	;MAKE P2 BE AOBJN POINTER TO THIS BLOCK
	HRRZ	T1,0(P2)	;GET CONTROLLER LOGICAL ADDRESS
	PUSHJ	P,OCTPNT##	;PRINT IT
	HRRI	P2,1(P2)	;ADVANCE TO FIRST OF FUNCTION WORDS
TYPSB2:	PUSHJ	P,PRSPC##	;SEPARATE FIELDS WITH A SPACE
	MOVE	T1,0(P2)	;GET NEXT FUNCTION WORD
	PUSHJ	P,HWDPNT##	;TYPE IT
	AOBJN	P2,TYPSB2	;LOOP FOR ALL WORDS IN THIS BLOCK
	PUSHJ	P,CRLF##	;TYPE CRLF AT END OF LINE
	AOBJN	P1,TYPSB1	;LOOP FOR ALL BLOCKS
	POP	P,P2		;RESTORE P2
	POP	P,P1		;  AND P1
	POPJ	P,		;RETURN
>;END IFN M.KL10



;ROUTINE TO READ THE CPU AND DEVICE STATUS BLOCKS.
;CALL:	PUSHJ	P,RCDSTB
;	RETURN

RCDSTB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
RCDSTD::MOVEI	T1,.ERCSB	;CPU STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY FOR DAEMON
	MOVEI	T1,.ERDSB	;DEVICE STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY
	POPJ	P,		;RETURN
SUBTTL STOP PROCEDURE WHEN SHUTTING DOWN SYSTEM
;TRANSFER HERE ON 404, 405, 406, OR 407 START OR LOCATION 30 BEING
;SET NON-ZERO.
;PROCEDURE TO SAVE CRASHED MONITOR ON DISK FOR LATER DEBUGGING UNDER
;TIMESHARING.  OPERATOR SHOULD:
;	1. TRY TO FORCE THE SYSTEM TO TAKE A DUMP BY CAUSING LOCATION
;	   30 TO BE SET NON-ZERO.  THIS CAN BE DONE FROM THE KEYS ON
;	   A KI10 OR THROUGH COMMANDS TO THE FRONT-END ON KL10 OR KS10
;	   SYSTEMS.
;	2. IF THIS DOESN'T WORK, TRY STARTING THE MACHINE AT 406 OR
;	   407 (FOR SINGLE CPU SYSTEMS).  THIS SHOULD GET US HERE.
;	3. IF ALL ELSE FAILS, LOAD BOOT WITH READ-IN OR VIA THE
;	   FRONT-END.  THIS HAS THE DISADVANTAGE THAT SOME MACHINE
;	   STATE, THE AC SETS, ETC. ARE LOST.

;HERE ON A 405 START TO SAVE THE MACHINE STATE AND JUMP INTO THE AC'S
STPCPU:	DMOVEM	P1,RBTSVA	;SAVE P1,P2 IN A VERY TEMPORARY PLACE
	JSP	P1,PAGENB	;MAKE SURE PAGING IS ON
	MOVEI	P1,SR.DIE	;SET BIT TO FORCE CPNSER TO LOOP
	IORB	P1,.CPSBR	; IN THE AC'S UNTIL EXPLICITLY RESTARTED
	JRST	SYSTO1		;JOIN COMMON CODE

;HERE ON A 404 START TO SET 30 TO -1 TO FORCE ALL OTHER CPU'S INTO
;THEIR AC'S
STPALL:	SETOM	CRSHWD		;FORCE ALL OTHER CPU'S INTO THE AC'S

;HERE ON A 406 START TO GET TO MONBTS ON THIS CPU REGARDLESS OF WHO
;THE BOOT CPU IS.
STPLDB:	DMOVEM	P1,RBTSVA	;SAVE P1,P2 IN A VERY TEMPORARY PLACE
	JSP	P1,PAGENB	;MAKE SURE PAGING IS ON
	MOVEI	P1,SR.LBH	;SET BIT TO GET TO MONBTS ON THIS CPU
	IORB	P1,.CPSBR	; REGARDLESS OF WHO THE BOOT CPU IS
	JRST	SYSTO1		;JOIN COMMON CODE

;HERE ON A 407 START OR 30 NON-ZERO AT APR INTERRUPT LEVEL
SYSTOP::DMOVEM	P1,RBTSVA	;SAVE P1, P2 IN A VERY TEMPORARY AREA
	JSP	P1,PAGENB	;MAKE SURE PAGING IS TURNED ON
	MOVE	P1,.CPSBR	;GET STATUS BITS
SYSTO1:	TRNE	P1,SR.ACL	;THIS CPU LOOPING IN THE AC'S?
	JRST	[DMOVE	P1,RBTSVA ;YES, AC'S SAVED BY AC LOOP SETUP
		 JRST SYSTO2]	;SO DON'T SAVE THEM AGAIN
	DMOVE	P1,RBTSVA	;RESTORE P1 AND P2
	JSR	.CPSVA		;SAVE ALL AC SETS

SYSTO2:	MOVE	P,.CPEPD	;SETUP P TO ERRPDL
	MOVEI	P1,SR.STS	;BIT SET IF MACHINE STATE ALREADY SAVED
	TDNN	P1,.CPSBR	;ALREADY SAVE MACHINE STATE?
	SKIPGE	BOOTCP		;NO, MAP SETUP YET?
	CAIA			;NO, CAN'T READ DATA BLOCKS
	PUSHJ	P,RCDSTB	;READ CPU AND DEVICE STATUS BLOCKS
	IORM	P1,.CPSBR	;SET THE BIT FOR THE NEXT TIME


				;FALL INTO REBOOT
;HERE ON ANY CPU FROM DIE OR FALL INTO FROM ABOVE TO RELOAD THE MONITOR.
;IN MULTIPROCESSOR SYSTEMS, ALL BUT THE BOOT CPU ARE DISPATCHED TO
;CP1CRS IN CPNSER.  IT IS THE CALLERS RESPONSIBILITY TO SAVE ALL AC
;SETS (WITH .CPSVA) BEFORE GETTING HERE.

REBOOT::EXECAC
	MOVE	P1,BOOTCP	;SAVE CURRENT VALUE OF BOOTCP
	SETZM	BOOTCP		;CAUSE SYSTR1 TO NOT CHANGE SERIAL, BOOTCP
	JSP	T4,SYSTR1	;TURN ON PAGING FOR THIS CPU
	  JFCL			;IGNORE RETURN
	MOVEM	P1,BOOTCP	;RESTORE BOOTCP
	MOVEM	P3,@.CPSPT	;RESTORE FROM VALUE SYSTR1 SAVE FOR US
IFN M.KL10,<
	DATAO	DLB,[0]
	DATAO	DLB2,[0]
>
IFN M.KL10,<
	CONO	PI,PI.OFF	;TURN OFF PI
	SWPUA			;SWEEP CACHE
	CONSZ	APR,LP.CSB	;WAIT UNTIL DONE
	JRST	.-1		; ..
	CONI	PAG,T1		;GET PAGING STATE
	TRZ	T1,LG.CSL!LG.CSW ;TURN OFF, LOOK AND LOAD
	CONO	PAG,(T1)	;MAINTAIN PAGING BUT WITHOUT CACHE
	JSP	T4,ZAPICH	;FIX UP INTERNAL CHANNELS
>
IFN M.KS10,<
	CONO	PI,PI.OFF	;TURN OFF PI
	WRUBR	NULDOP		;SWEEP CACHE
>
	CONO	APR,AP0RST	;RESET SYSTEM
	CONO	PI,011577	;WIPEOUT PI-SYSTEM

IFN FTMP,<
IFG <CPUN-1>,<
	MOVEI	T1,SR.LBH	;DO WE WANT TO GET TO MONBTS ON THIS
	TDNE	T1,.CPSBR	;  CPU REGARDLESS OF WHO THE BOOT CPU IS?
	JRST	REBOO1		;YES, SKIP THE REST OF THE CHECKS
	SKIPL	BOOTCP		;MAP SETUP YET?
	SKPCPU(1)		;YES, ON ANY BUT THE BOOT CPU?
	CAIA			;NO, LOAD BOOTS AND RELOAD
	PJRST	CP1CRS##	;GO TO CPNSER AND LOOP IN THE AC'S
REBOO1:>>

;CALL TO METINI REMOVED SO METER POINTS WILL BE PRESERVED IN
;THE CRASH DUMP--THIS REQUIRES THAT NONE OF THE ROUTINES
;CALLED BELOW (E.G. GETZ) SHOULD CONTAIN METER POINTS.
	MOVE	P,.CPEPD	;SETUP P TO SPARE AREA
	MOVE	T1,[<PM.DCD>B2+PM.WRT+NUPMPP]
;*********
	MOVEM	T1,NLUPMP+.UMUPT

BNXMTS::PUSHJ	P,SUNXMT##	;SETUP NXMTAB PATCHED OUT IF SYSTEM HAS
				; BEEN STARTED (PATCHED TO JFCL AFTER START)
	MOVE	T1,LOCYER	;GET YEAR
	SUBI	T1,^D1970	;SUBTRACT BASE
	JUMPL	T1,RLDMON##	;DON'T STORE IF BAD
	LSH	T1,5		;SHIFT OVER
	IOR	T1,LOCDAY	;ADD IN DAY
	LSH	T1,4		;AND
	IOR	T1,LOCMON	;MONTH
	HRLZM	T1,CRSDTM	;SAVE FOR ONCE AFTER RELOAD
	MOVE	T2,TIME		;GET TIME IN JIFFIES
	IDIV	T2,TICSEC	;CONVERT TO SECONDS TO FIT
	ADDI	T2,RLDTIM
	HRRM	T2,CRSDTM	;SAVE FOR ONCE AFTER RELOAD
	ADD	T1,T2		;ADD DATE AND TIME TOGETHER
	HLRZ	T2,CRSWHY	;GET LEFT THREE CHARACTERS OF STOPCODE NAME
	ADD	T1,T2		;PLUS STOPCD NAME
	HRRZ	T2,STATES	;GET SCHED SETTING
	HRRM	T2,CRSSTS	;SAVE FOR RELOAD
	ADD	T1,T2		;AND ADD INTO CHECKSUM
	ADDI	T1,507601	;ADD IN THE MAGIC CONSTANT
	HRRZM	T1,CRSCHK	;SAVE CHECKSUM FOR ONCE AFTER
				; RELOAD SO IT CAN DEFEND AGAINST
				; JUNK OR NON-MONITOR PREDECESSORS.
	PJRST	RLDMON##	;GO RELOAD MONITOR
	SUBTTL	FATAL SYSTEM HALT

;THE STOPCODE MACRO DISPATCHES HERE FOR "HALT" TYPE STOPCODES.  ONLY
;ESSENTIAL HALT ACTIONS SHOULD BE TAKEN BEFORE EXECUTING THE HALT
;INSTRUCTION AT THE END OF THIS ROUTINE.

DOHALT::EXP	0,0		;XPCW HERE
	EXP	IC.UOU,.+1
	MOVEM	17,.CPCAC+17	;SAVE AC 17
	MOVEI	17,.CPCAC	;SET UP BLT
	BLT	17,.CPCAC+16	;SAVE ACS 0-16
IFN FTKL10,<JSP	T4,ZAPICH>	;ZAP INTERNAL CHANNELS


;HERE TO FORCE A RELOAD BY THE FRONT END
DOLOAD::
IFN FTKL10,<PUSHJ  P,LOAD10##>	;TELL MASTER-11 TO RELOAD US
IFN FTKS10,<
	MOVSI	T1,(KSRLD)	;RELOAD REQUEST BIT
	IORM	T1,RLWORD	;SET IT FOR THE 8080
	WRAPR	SP.SSF+SP.IFE	;BANG ON THE 8080'S BELL (POINTLESS TRADITION)
> ;END IFN FTKS10
	HALT	.		;TERMINATE THIS NONSENSE
IFN FTKL10,<
;SUBROUTINE TO GET THE INTERNAL CHANNELS BACK INTO A KNOWN STATE
;FOR RH20'S DOES A MASSBUS INIT, THEN STOPS RH20 AND CLEARS DONE
;FOR IPA'S (NIA-20 OR CI-20) DOES A PORT CLEAR

ZAPICH::MOVEI	T1,FSTICD/4	;GET FIRST INTERNAL CHANNEL NUMBER
ZPICH1:	MOVE	T2,[CONI FSTICD,T3] ;GET CONI INSTRUCTION
	DPB	T1,[POINT 7,T2,9] ;MAKE IT SPECIFIC TO THIS CHANNEL
	XCT	T2		;READ CONI
	JUMPE	T3,ZPICH3	;JUMP IF NOTHING OUT THERE
	MOVE	T2,[CONO FSTICD,(T3)] ;GET CONO INSTRUCTION
	DPB	T1,[POINT 7,T2,9] ;MAKE IT SPECIFIC TO THIS CHANNEL
	.CREF	CI.PPT		;BIT WE'RE TESTING
	JUMPL	T3,ZPICH2	;IF SIGN BIT SET THIS IS A KLNI OR KLIPA
	MOVEI	T3,CO.MBI	;MASSBUS INIT
	XCT	T2
	MOVEI	T3,CO.STP	;STOP
	XCT	T2
	MOVEI	T3,CO.CCD	;CLEAR DONE
	XCT	T2
	JRST	ZPICH3		;SKIP IPA STUFF

ZPICH2:	MOVEI	T3,CO.CPT	;CLEAR PORT
	XCT	T2
ZPICH3:	CAIGE	T1,LSTICD/4
	AOJA	T1,ZPICH1	;LOOP FOR ALL INTERNAL CHANNELS
	JRSTF	@T4		;RETURN
>
;SUBROUTINE TO INSURE THAT PAGING IS ON WHEN WE COME THROUGH
;SYSTOP.
;CALL:	JSP	P1,PAGENB
;	RETURN HERE ALWAYS

PAGENB:	DMOVEM	T1,RBTSVA+2	;SAVE AC'S WHICH WILL BE
	DMOVEM	T3,RBTSVA+4	; DESTROYED BY SYSTR1
IFN FTKL10,<
	CONI	PAG,T1		;GET CURRENT MAPPING
	TRNE	T1,LG.TEN	;PAGING ALREADY ON?
>
IFN FTKS10,<
	RDEBR	T1		;GET CURRENT MAPPING
	TRNE	T1,SG.TEN	;PAGING ALREADY ON?
>
	JRST	PAGEN1		;YES, DON'T ALTER CURRENT STATE
	MOVE	P2,BOOTCP	;GET CURRENT VALUE OF BOOTCP
	SETZM	BOOTCP		;MAKE SURE SYSTR1 WILL NOT CHANGE SERIAL, BOOTCP
	JSP	T4,SYSTR1	;TURN ON PAGING FOR THIS CPU
	  JFCL			;IGNORE RETURN
	MOVEM	P2,BOOTCP	;RESTORE BOOTCP
PAGEN1:	DMOVE	T1,RBTSVA+2	;RESTORE T1,T2
	DMOVE	T3,RBTSVA+4	; AND T3,T4
	JRSTF	@P1		;RETURN

RBTSVA:	BLOCK	6		;STORE P1-P2 AND T1-T4 HERE
ARFLAG::-5			;TESTED TO SEE IF AUTO RELOAD NEEDED
				; COUNTED UP ONE EVERY 60 SEC.

BTXLEN==:^D16			;MAX LENGTH OF BOOTXT
;THIS BLOCK MAY BE OVERWRITTEN BY ONCE
ZZ1==.
	ASCIZ	"/D SYSTEM.EXE[1,4] "

	BLOCK	ZZ1+BTXLEN-.
ZZZ==.-1
IFN	<ZZ1&MPGSIZ-ZZZ&MPGSIZ>,<
	LOC	ZZZ&MPGSIZ
BOOTXT::
	ASCIZ	"/D SYSTEM.EXE[1,4] "

	BLOCK	BOOTXT+BTXLEN-.
>
IFE	<ZZ1&MPGSIZ-ZZZ&MPGSIZ>,<BOOTXT==:ZZ1>

	$ABS
	LIT		;FORCE INITIALIZATION AND READ BOOTS LITERALS
			; INTO THE LOW SEGMENT
SUBTTL	COMMON SUBROUTINES


; SET UP AN INSTUCTION TO ENTER DDT VIA THE UNSOLICITED BREAKPOINT.
; THE CDBS ARE INITIALLY BUILT WITH .CPDDT CONTAINING A NOOP.  THE
; NOOP MUST BE A TRN.  THIS ALLOWS ANY ROUTINE TO DETERMINE IF IT'S
; CPU MAY ENTER EDDT BY DOING A SKIPL .CPDDT (TRN HAS THE SIGN BIT ON).
;
; DEBUGF CONTAINS A MASK OF THE CPUS WHICH MAY ENTER EDDT VIA THE
; UNSOLICITED BREAKPOINT.  INITIALLY, THIS MASK IS SET TO ALLOW
; BREAKPOINTS ON ALL CPUS, BUT MAY BE CHANGED AT ANY TIME.
;
	$HIGH

CPUDDT::MOVE	T1,DEBUGF	;GET DEBUGGING FLAGS
	ANDI	T1,DF.BPT	;KEEP JUST THE CPU BREAKPOINT MASK
	MOVE	T2,T1		;COPY MASK
	XOR	T1,BPTMSK	;COMPARE
	JUMPE	T1,CPOPJ	;RETURN IF NO CHANGE
	MOVEM	T2,BPTMSK	;SAVE NEW MASK
	MOVEI	T1,.C0CDB	;POINT TO START OF CDB CHAIN

CPUDD1:	MOVEI	T3,DF.BP0	;GET BIT FOR CPU0
	MOVN	T4,.CPCPN-.CPCDB(T1) ;GET A CPU NUMBER
	LSH	T3,(T4)		;SHIFT TO FIND THIS CPU'S BIT IN MASK
	TDNE	T3,DEBUGF	;WANT TO ALLOW BREAKPOINTS ON THIS CPU?
	SKIPA	T2,BPTXCT	;YES--GET INSTRUCTION TO ENTER DDT
	MOVE	T2,[BPTNOP]	;NO--GET SPECIAL NOOP
	MOVEM	T2,.CPDDT-.CPCDB(T1) ;SAVE INSTRUCTION
	HLRZ	T1,.CPCDB-.CPCDB(T1) ;GET ADDRESS OF NEXT CDB
	JUMPN	T1,CPUDD1	;LOOP FOR ALL CPUS
	POPJ	P,		;RETURN

BPTXCT::JSR	$0BPT##		;INSTRUCTION TO ENTER DDT
BPTNOP==<TRN	0,0>		;NOOP

	$ABS
BPTMSK:	EXP	-1		;MASK OF OLD CPU BREAKPOINT BITS
	$HIGH
SUBTTL	COMMON SUBROUTINES  --  STOPCODE PROCESSING

;ROUTINE TO RECOVER/RELOAD AFTER AN INTERNAL
; SYSTEM ERROR.  CALLED ONLY BY STOPCD MACRO
; (SEE S.MAC) WITH:
;	PUSHJ	P,DIE
;
;SEE ALSO ROUTINE PERISH
;DISPATCHES TO DIE0 IN ERRCON

DIE::	AOSE	.CPDWD		;INTERLOCK STOPCD CODE
	STOPCD	.,HALT,REH,	;++RECURSION IN ERROR HANDLER
	POP	P,.CPSPC+1	;GET PC OF STOPCD
	XSFM	.CPSPC		; AND FLAGS
	JRST	@[0,,DIE0##]	;JOIN COMMON CODE

;ANOTHER ROUTINE TO RECOVER/RELOAD AFTER AN INTERNAL SYSTEM ERROR.
;  CALLED ONLY BY STOPCD MACRO (SEE S.MAC) WITH:
;
;	XPCW	CROAK		;(CROAK IS PSUEDONYM FOR .CPSPC)
;
;SEE ALSO ROUTINE DIE

PERISH::AOSE	.CPDWD		;INTERLOCK STOPCD CODE
	STOPCD	.,HALT,RID,	;++RECURSION IN DIE
	JRST	@[0,,DIE0##]	;JOIN COMMON CODE [ALREADY IN SECTION 0]

;ROUTINE TO TYPE OUT ADDITIONAL DATA DURING BUGINF (OR BUGCHK OR ...)
;
;CALLED VIA JSP T1,BGCTYP
;DATA TO BE TYPED FOLLOWS
;DISPATCHES TO ROUTINE BUGTY1 IN ERRCON

BGCTYP::MOVE	P1,T1		;COPY POINTER TO DATA
IFN FTXMON,<
	TLNE	T1,MXSECN	;CALLED FROM NON-ZERO SECTION?
	XJRST	[MCSEC1+BUGTY1##] ;YES, ENTER SECTION 1 FOR OUTPUT ROUTINES
>; END IFN FTXMON
	JRST	BUGTY1##	;NO, STAY IN SECTION 0
SUBTTL	COMMON SUBROUTINES - EXTENDED ADDRESSING

IFN FTXMON,<

	$HIGH

;COROUTINE TO SAVE AND RESTORE THE CALLER'S PC SECTION NUMBER AND
; CALL THE CALLER AS A COROUTINE IN SECTION 1.
;CALLING SEQUENCE:
;	PUSHJ	P,SSEC1
;	ALWAYS RETURNS HERE IN SECTION 1
;RESTORES PC SECTION ON RETURN

SSEC1::	PUSH	P,T1		;SAVE A TEMP
	XMOVEI	T1,.		;CURRENT SECTION
	TLNE	T1,37		;ARE WE ALREADY EXTENDED?
	JRST	TPOPJ		;YES, GO HOME
	HRRZS	-2(P)		;MAKE CALLER RETURN TO SECTION 0
	MOVSI	T1,(MCSEC1)	;A SECTION 1 PC
	HLLM	T1,-1(P)	; FOR OUR POPJ
	XJRST	[MCSEC1+TPOPJ]	;ENTER SECTION 1 AND RETURN

;COROUTINE TO SAVE AND RESTORE THE CALLER'S PC SECTION NUMBER AND
; CALL THE SUBROUTINE SPECIFIED IN THE ARGUMENT LIST IN THE SECTION
; SPECIFIED IN THE ARGUMENT LIST
;CALLING SEQUENCE:
;	XCT	[PUSHJ P,SENCAL
;		 SN,,ADDR]	;CALL SUBROUTINE AT ADDR IN SECTION SN
;	RETURNS AS SUBROUTINE RETURNS
;RESTORES CALLER'S PC SECTION ON RETURN

SENCAL::PUSH	P,T1		;SAVE A TEMP
	MOVE	T1,-1(P)	;CALLER'S PC
	TLNN	T1,37		;ADDRESS OF THE XCT, SKIP IF NOT IN SECTION 0
	HRRZS	T1,-1(P)	;ADDRESS OF THE XCT, ZERO SECTION NUMBER FOR RETURN
	HRRZ	T1,-1(T1)	;TARGET OF THE XCT
	MOVE	T1,1(T1)	;SN,,ADDR
	MOVEM	T1,1(P)		;SAVE FOR CALL
	TLNN	T1,37		;CALL TO SECTION 0?
	JRST	SSEC0C		;YES, DO REST OF SSEC0
	POP	P,T1		;NO, RESTORE T1
	XJRST	2(P)		;AND CALL THE SUBROUTINE IN SN SECTION

;COROUTINE TO SAVE AND RESTORE THE CALLER'S PC SECTION NUMBER AND
; CALL THE CALLER AS A COROUTINE IN SECTION 0
;CALLING SEQUENCE:
;	PUSHJ	P,SSEC0
;	ALWAYS RETURN HERE IN SECTION 0.
;RESTORES PC SECTION ON RETURN.

SSEC0::	EXCH	T1,(P)		;GET PC WE WERE CALLED AT
	TLZN	T1,37		;MAKE SURE IT IS AN EXTENDED PC
	JRST	[EXCH	T1,(P)	;RESTORE T1
		POPJ	P,]	;AND RETURN IN SECTION 0 (ROUTINE IS A NOOP).
SSEC0C:	PUSH	P,T1		;SAVE AS A SECTION 0 PC.
	HRRZI	T1,SSEC0E	;NOTE SECTION 0 PC.
	EXCH	T1,-1(P)	;RESTORE T1, LEAVE A RETURN PATH TO US.
	POPJ	P,		;"RETURN" TO CALLER.

;RETURN HERE IN SECTION 0 ON RETURN FROM ROUTINE WHICH CALLED SSEC0.
SSEC0E:	SKIPA			;RETURNED NON-SKIP, LEAVE EVERYTHING ALONE
	AOS	(P)		;SKIP RETURN, BUMP CALLERS PC
	EXCH	T1,(P)		;GET RETURN PC TO HIGHER LEVEL ROUTINE.
	TLZ	T1,-1-MXSECN	;WIPE FLAGS IN CASE SECTION 0 PC
	MOVEM	T1,1(P)		;SAVE AS PC PART OF XJRSTF DUO-WORD
	POP	P,T1		;RESTORE T1
	XJRST	2(P)		;RETURN IN PROPER SECTION
>; END IFN FTXMON
IFE FTXMON,<
SSEC0==:CPOPJ			;THESE ARE NO-OPS
SSEC1==:CPOPJ			; ON THE KS
>; END IFE FTXMON
SUBTTL COMMON SUBROUTINES


;ERROR RECOVERY - TRY TO START NULL JOB

NULJB1::SETZB	J,.CPJOB	;ZERO J AND JOB NUMBER FOR NULJOB
	JRST	NULJOB##	;GO RESTORE NULL JOB




;COMMON SUBROUTINE RETURNS

CPOPJ2::AOS	(P)		;DOUBLE SKIP SUBROUTINE RETURN
RSKP::!				;FOR MACSYM USERS
CPOPJ1::AOSA	(P)		;SKIP SUBROUTINE RETURN
DPOPJ::	MOVEM	S,DEVIOS(F)	;DEPOSIT I/O STATUS WORD IN DDB
RTN::!
CPOPJ::	POPJ	P,

TPOPJ1::AOSA	-1(P)		;RESTORE T1 THEN SKIP RETURN
TTPOPJ::POP	P,T2
TPOPJ::	POP	P,T1		;RESTORE T1
	POPJ	P,		;AND RETURN
JPOPJ1::			;DUPLICATE NAME (PREFERRED)
IPOPJ1::AOS	-1(P)		;SET FOR SKIP RETURN
JPOPJ::				;DUPLICATE NAME (PREFERRED)
IPOPJ::	POP	P,J		;RESTORE J (USUALLY JOB OR HIGH SEG NUMBER)
	POPJ	P,
	POP	P,
T2POJ1::AOS	-1(P)
T2POPJ::POP	P,T2		;RESTORE T2
	POPJ	P,
MPOPJ::	POP	P,M
	POPJ	P,
WPOPJX::CAIA			;NETSER PUSHES THIS ADDR ON THE STACK THEN
WPOPJ1::AOS	-1(P)		; EVENTUALLY DOES A CPOPJ1 RETURN
WPOPJ::	POP	P,W
	POPJ	P,
T3POPJ::POP	P,T3
	POPJ	P,
P3POPJ::POP	P,P3
	POPJ	P,


FUPOJ1::POP	P,F
UPOPJ1::
LPOPJ1::AOSA	-1(P)		;SKIP AND RESTORE LINE
FUPOPJ::POP	P,F
UPOPJ::
LPOPJ::	POP	P,U		;RESTORE LINE AND RETURN
	POPJ	P,0		;RETURN
FPOPJ1::AOS	-1(P)
FPOPJ::	POP	P,F		;RESTORE F
	POPJ	P,0		;RETURN
ZPOPJ::	TDZA	T1,T1
M1POPJ::SETOM	T1
	POPJ	P,

;GENERATE AND/OR STORE UUO ERROR CODES
	ERCALC(ECDMAX)
	ERCALX(ECDMAX)
	$ABS
IFE M.MSG,<
	XP	MPXACT,CPOPJ1
	XP	CHKMPX,CPOPJ1
LGLMPX::
MPXIOS::
TSTMPX::
CLRST::
ERLST::
SENSE::
CONECT::
DEVUDX::
MOVHDR::
MSGBFE::
MSGOUT::
ZAPMPX::
MPXIOD::
MPXDIS::
MPXWAT::
MPXWAI::
>
	POPJ	P,		;THE NULL UUO
;ROUTINE TO SAVE ALL AC SETS IN .CPCAC AND .CPCAn.  RETURNS WITH
;NO AC'S IN ANY SET CHANGED AND THE FOLLOWING LOCATIONS SETUP:
;
;	.CPCPG - ARGUMENT TO DATAO PAG, TO RESTORE CURRENT AC SET
;	.CPACA - ADDRESS OF SAVED VALUES FOR CURRENT AC SET.
;
;CALL:
;		JSR	.CPSVA
;		RETURN HERE ALWAYS

SVSETS:	DATAI	PAG,.CPCPG	;SAVE CURRENT STATE OF AC BLOCKS
	SAVE	(1,.CPCA1)	;SAVE ALL AC SETS
	SAVE	(2,.CPCA2)	;...
	SAVE	(3,.CPCA3)	;...
	SAVE	(4,.CPCA4)	;...
	SAVE	(0,.CPCAC)	;AND LEAVE AC SET 0 AC THE CURRENT ONE
	LDB	17,[POINT 3,.CPCPG,8] ;GET NUMBER OF CURRENT AC SET
	JUMPN	17,SVSET1	;GO IF NOT AC SET 0
	MOVEI	17,.CPCAC	;AC SET 0 IS SAVED AT .CPCAC
	JRST	SVSET2		;CONTINUE
SVSET1:	IMULI	17,20		;COMPUTE OFFSET INTO .CPCA1 OF THIS SET
	ADDI	17,.CPCA1-20	;COMPUTE ADDRESS OF THIS SET
SVSET2:	MOVEM	17,.CPACA	;SAVE ADDRESS OF WHERE AC SET WAS SAVED
	MOVE	17,.CPCAC+17	;RESTORE AC 17 OF SET 0
	DATAO	PAG,.CPCPG	;RESTORE CURRENT AC SET
	JRSTF	@.CPSVA		;RETURN TO CALLER
	$ABS
	LIT
;SUBROUTINES TO SAVE AND RESTORE PRESERVED ACS
;SAVEN IS CALLED AT THE BEGINNING OF A SUBROUTINE
;FOR CONVENIENCE NO MATCHING SUB IS NEEDED TO BE CALLED
;TO RESTORE THIS ACS.
;INSTEAD AN EXTRA RETURN IS PUT ON STACK
;5 CHAR NAME INDICATES IT VIOLATES
;SUBROUTINE CALLING CONVENTIONS
;CALL:	PUSHJ	P,SAVEN
;	RETURN	HERE IMMEDIATELY WITH EXTRA RETURN ON STACK
;	RESPECTS ALL ACS

;NOTE:	THIS CODE USES 1 LOC BEYOND END OF STACK BUT THEN PUSHES ON TOP OF IT
;SO GET OVERFLOW INTERUPT IF TOO FULL.  OK TO DO 1(P) SINCE THIS WORD WRITTEN ON OVERFLOW

	$HIGH
SAVE1::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,(P)		;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES1
	AOS	-1(P)
	JRST	RES1

SAVE2::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-1(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES2
	AOS	-2(P)
	JRST	RES2

SAVE3::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	PUSH	P,P3
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-2(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES3
	AOS	-3(P)
	JRST	RES3
SAVE4::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-3(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES4
	AOS	-4(P)
RES4:	POP	P,P4
RES3:	POP	P,P3
RES2:	POP	P,P2
P1POPJ::
RES1:	POP	P,P1
	POPJ	P,

;COROUTINE TO SAVE AND RESTORE P2

SAVP2::	EXCH	P2,(P)		;SAVE P2, GET CALLER PC
	MOVEM	P2,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P2,(P)		;RESTORE P2
	PUSHJ	P,@1(P)		;CALL OUR CALLER, OVERWRITE CALLER PC WITH .+1
	  SKIPA			;PROPOGATE SKIP/NON-SKIP RETURN
	AOS	-1(P)		;...
	POP	P,P2		;RESTORE P2
	POPJ	P,		;AND RETURN

;COROUTINE TO SAVE AND RESTORE P3

SAVP3::	EXCH	P3,(P)		;SAVE P3, GET CALLER PC
	MOVEM	P3,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P3,(P)		;RESTORE P3
	PUSHJ	P,@1(P)		;CALL OUR CALLER, OVERWRITE CALLER PC WITH .+1
	  SKIPA			;PROPOGATE SKIP/NON-SKIP RETURN
	AOS	-1(P)		;...
	POP	P,P3		;RESTORE P3
	POPJ	P,		;AND RETURN

;SUBROUTINE TO SAVE AND RESTORE TEMP ACS
;CALLED BY PUSHJ P,SAVT   RETURN EITHER CPOPJ OR CPOPJ1 WHEN THROUGH
SAVT::	EXCH	T4,(P)		;SAVE T4, GET RETURN ADR.
	PUSH	P,T3		;SAVE T3
	PUSH	P,T2		;AND T2
	PUSH	P,T1		;AND T1
	MOVEM	T4,1(P)		;STORE PC
	MOVE	T4,-3(P)	;RESTORE T4
	PUSHJ	P,@1(P)		;RETURN TO CALLER
	  SKIPA			;POPJ RETURN
	AOS	-4(P)		;CPOPJ1 - SET SKIP RETURN
	POP	P,T1		;RESTORE T1
	POP	P,T2		;RESTORE T3 ACS
	POP	P,T3
T4POPJ::POP	P,T4
	POPJ	P,		;AND RETURN

;SUBROUTINE TO SAVE AND RESTORE AC'S J AND W
SAVJW::	EXCH	J,(P)		;SAVE J AND GET THE RETURN
	PUSH	P,W		;SAVE W
	MOVEM	J,1(P)		;SAVE THE RETURN
	MOVE	J,-1(P)		;RESTORE J
	PUSHJ	P,@1(P)		;RETURN
	  SKIPA			;SKIP RETURN NO
	AOS	-2(P)		;SKIP RETURN YES
	POP	P,W		;RESTORE W
	PJRST	JPOPJ		;RESTORE J AND EXIT

;SUBROUTINE TO SAVE U.
SAVU::	EXCH	U,(P)		;SAVE U AND GET THE RETURN
	MOVEM	U,1(P)		;SAVE THE RETURN TO CALLER
	MOVE	U,(P)		;RESET CALLER'S VALUE OF U
	PUSHJ	P,@1(P)		;CO-RETURN
	  JRST	UPOPJ		;NON-SKIP, RESTORE U
	JRST	UPOPJ1		;SKIP & RESTORE U

;SUBROUTINE TO SAVE U,M, and W. USED MAINLY BY DECNET.
SAVUM::	EXCH	U,(P)		;SAVE U AND GET THE RETURN
	PUSH	P,M		;SAVE M
	PUSH	P,W		;SAVE W
	MOVEM	U,1(P)		;SAVE THE RETURN TO USER
	MOVE	U,-2(P)		;GET ORIGINAL VALUE OF U
	PUSHJ	P,@1(P)		;RETURN TO CALLING ROUTINE.
	 SKIPA			;NON-SKIP RETURN
	AOS	-3(P)		;SKIP RETURN, BUMP RETURN PC
	POP	P,W		;GET BACK VALUE OF W
	POP	P,M		;GET BACK VALUE OF M
	POP	P,U		;GET BACK VALUE OF U
	POPJ	P,		;RETURN TO TOP-LEVEL ROUTINE...

;COROUTINE TO SAVE AND RESTORE R
SAVR::	EXCH	R,(P)		;SAVE R, GET CALLER PC
	MOVEM	R,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	R,(P)		;RESTORE R
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RPOPJ
RPOPJ1::AOS	-1(P)
RPOPJ::	POP	P,R
	POPJ	P,

SAVP4::	EXCH	P4,(P)		;SAVE P4, GET CALLER PC
	MOVEM	P4,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P4,(P)		;GET BACK P4
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	 JRST	P4POPJ		;NON-SKIP RETURN
P4PPJ1:	AOS	-1(P)		;INCREMENT RETURN PC
P4POPJ::POP	P,P4		;RESTORE OLD VALUE OF P4
	POPJ	P,
;TOPS-20 AC SAVE ROUTINES

	T20SYM			;SWITCH TO TOPS-20 AC NAMES

IFN FTSCA!FTENET,<

;SAVE Q1 - Q3
SAVQ::	ADJSP	P,3		;ADJUST STACK
	DMOVEM	Q1,-2(P)	;SAVE Q1 AND Q2
	MOVEM	Q3,0(P)		;SAVE Q3
	PUSHJ	P,@-3(P)	;CALL THE CALLER
	  SKIPA			;NON-SKIP RETURN
	AOS	-4(P)		;ADJUST RETURN PC
	DMOVE	Q1,-2(P)	;RESTORE Q1 AND Q2
	MOVE	Q3,0(P)		;RESTORE Q3
	ADJSP	P,-4		;ADJUST STACK
	POPJ	P,		;RETURN

;SAVE Q1
SAVQ1::	PUSH	P,Q1		;SAVE Q1
	PUSHJ	P,@-1(P)	;CALL THE CALLER
	  SKIPA			;NON-SKIP RETURN
	AOS	-2(P)		;ADJUST RETURN PC
	POP	P,Q1		;RESTORE Q1
	ADJSP	P,-1		;ADJUST STACK
	POPJ	P,		;RETURN

> ;END IFN FTSCA!FTENET
IFN FTSCA,<

;SAVE P1 - P6

SAVP::	ADJSP	P,6		;ADJUST STACK
	DMOVEM	P1,-5(P)	;SAVE P1 AND P2
	DMOVEM	P3,-3(P)	;SAVE P3 AND P4
	DMOVEM	P5,-1(P)	;SAVE P5 AND P6
	PUSHJ	P,@-6(P)	;CALL THE CALLER
	  SKIPA			;NON-SKIP RETURN
	AOS	-7(P)		;ADJUST RETURN PC
	DMOVE	P1,-5(P)	;RESTORE P1 AND P2
	DMOVE	P3,-3(P)	;RESTORE P3 AND P4
	DMOVE	P5,-1(P)	;RESTORE P5 AND P6
	ADJSP	P,-7		;ADJUST STACK
	POPJ	P,		;RETURN

;SAVE P1 - P6 AND Q1 - Q3

SAVPQ::	ADJSP	P,^D9		;ADJUST STACK
	DMOVEM	P1,-^D8(P)	;SAVE P1 AND P2
	DMOVEM	P3,-6(P)	;SAVE P3 AND P4
	DMOVEM	P5,-4(P)	;SAVE P5 AND P6
	DMOVEM	Q1,-2(P)	;SAVE Q1 AND Q2
	MOVEM	Q3,0(P)		;SAVE Q3
	PUSHJ	P,@-^D9(P)	;CALL THE CALLER
	  SKIPA			;NON-SKIP RETURN
	AOS	-^D10(P)	;ADJUST RETURN PC
	DMOVE	P1,-^D8(P)	;RESTORE P1 AND P2
	DMOVE	P3,-6(P)	;RESTORE P3 AND P4
	DMOVE	P5,-4(P)	;RESTORE P5 AND P6
	DMOVE	Q1,-2(P)	;RESTORE Q1 AND Q2
	MOVE	Q3,0(P)		;RESTORE Q3
	ADJSP	P,-^D10		;ADJUST STACK
	POPJ	P,		;RETURN

> ;END FTSCA
IFN FTSCA,<
;SUBROUTINE TO SUPPORT BLSUB.  USES .A16 AS A TRASH AC,
; AND .FP AS A FRAME POINTER.

.ENTER::PUSH	P,.FP		;SAVE THE OLD FRAME POINTER
	MOVE	.FP,P		;MAKE A NEW FRAME POINTER
	ADD	P,0(.A16)	;ALLOCATE LOCAL STORAGE
	JUMPGE	P,ENTOV		;JUMP IF OVERFLOW
ENTOV1:	PUSHJ	P,1(.A16)	;AND RETURN TO USER
	  SKIPA			;NON-SKIP RETURN
	AOS	-1(.FP)		;SKIP RETURN, BUMP RETURN PC
	MOVE	P,.FP		;RESTORE OLD STACK POINTER
	POP	P,.FP		;RESTORE SAVED FRAME POINTER
	MOVN	.A16,-1(P)	;GET -<N,,N>
	HRRZM	.A16,-1(P)	;STORE 0,,-N
	POP	P,.A16		;RECOVER RETURN ADDRESS
	ADJSP	P,@0(P)		;CLEAN UP THE STACK
	JRST	0(.A16)		;RETURN

ENTOV:	MOVE	P,.FP		;STACK OVERFLOW, UNDO ADD
	PUSH	P,.A16		;SAVE LOCAL RETURN IN 1(.FP)
	HRRZ	.A16,0(.A16)	;GET COUNT
	ADJSP	P,-1(.A16)	;ALLOCATE SPACE, GET TRAP HERE OR ON PUSH
	MOVE	.A16,1(.FP)	;RESTORE LOCAL RETURN
	JRST	ENTOV1		;CHARGE AHEAD
> ;END IFN FTSCA

;SUBROUTINE TO HANDLE "TRVAR" FOR DECNET. USES R AS A TRASH AC,
; AND P4 AS A FRAME POINTER.
	T20SYM

.XTRST::
.TRSET::PUSH	P,.FP		;SAVE THE OLD FRAME POINTER
	MOVE	.FP,P		;MAKE A NEW FRAME POINTER
	ADJSP	P,@(CX)		;ALLOCATE SIZE OFF OF STACK
	PUSHJ	P,1(CX)		;AND RETURN TO USER
.TRRET:	 TRNA			;NON SKIP RETURN.
	 AOS	-1(.FP)		;SKIP RETURN, BUMP RETURN PC
	MOVE	P,.FP		;RESTORE STACK POINTER TO OLD POINTER
	POP	P,.FP		;RESTORE OLD FRAME POINTER
	POPJ	P,		;AND RETURN
;SUBROUTINE TO HANDLE "STKVAR" FOR DECNET. USES R AS A TRASH AC

.XSTKS::
.STKST::ADJSP	P,@(CX)		;ADD SOME WORDS ONTO THE STACK
	PUSH	P,(CX)		;SAVE NUMBER OF WORDS ON STACK
	PUSHJ	P,1(CX)		;AND RETURN TO CALLER
.STKRT:	JRST	.STKVT		;NON SKIP RETURN
	MOVN	CX,(P)		;GET NEGATIVE WORDS SAVED
	ADJSP	P,-1(CX)	;RETURN THEM, INCLUDING COUNT WORD
	AOS	(P)		;SKIP RETURN
	POPJ	P,		;RETURN
.STKVT:	MOVN	CX,(P)		;GET NEGATIVE WORDS SAVED
	ADJSP	P,-1(CX)	;RETURN THEM
	POPJ	P,		;RETURN

	PURGEACS
	T10SYM

;Extended BLT routine. Used mostly by DECnet.
XBLTAT::
XBLTA::
IFN FTXMON,<
	EXTEND T1,[XBLT]	;COPY FROM LAST MSD TO NEW USER DATA
>;END IFN FTXMON
IFE FTXMON,<
	HRLZS T2		;SOURCE IN LEFT HALF
	HRRI T2,(T3)		;DESTINATION IN RIGHT HALF
	ADDI T3,(T1)		;LAST WORD BEYOND DESTINATION
	BLT T2,-1(T3)		;COPY THE WORDS
	SETZ T1,		;CLEAR NUMBER OF WORDS COPIED
	HLRZS	T2		;AND LEAVE LAST SOURCE WORD COPIED HERE
>;END IFE FTXMON
	POPJ P,			;RETURN (IMPORTANT!)

;PXCT'ED XBLT SIMULATORS.  FOR USE BY UUOS WHICH ALLOW GLOBAL ADDRESSES.
;USED ONLY WHEN FTXMON IS OFF.

IFE FTXMON,<
PBLTXU::HRLZS	T2		;SOURCE IN LEFT HALF
	HRRI	T2,(T3)		;DESTINATION IN RIGHT HALF
	ADDI	T3,(T1)		;LAST WORD BEYOND DESTINATION
	EXCTXU	<BLT T2,-1(T3)>	;DO THE APPROPRIATE FLAVOR OF PXCT
	SETZ	T1,		;CLEAR NUMBER OF WORDS COPIED
	HLRZS	T2		;AND LEAVE LAST SOURCE WORD COPIED HERE
	POPJ	P,		;RETURN TO CALLER

PBLTUX::HRLZS	T2		;SOURCE IN LEFT HALF
	HRRI	T2,(T3)		;DESTINATION IN RIGHT HALF
	ADDI	T3,(T1)		;LAST WORD BEYOND DESTINATION
	EXCTUX	<BLT T2,-1(T3)>	;DO THE APPROPRIATE FLAVOR OF PXCT
	SETZ	T1,		;CLEAR NUMBER OF WORDS COPIED
	HLRZS	T2		;AND LEAVE LAST SOURCE WORD COPIED HERE
	POPJ	P,		;RETURN TO CALLER
>;END IF IFE FTXMON
IFN M.KL10,<
;ROUTINE TO COMPUTE THE NUMBER OF WORDS DESCRIBED IN AN IOLIST
;ENTER WITH T1=ADDR OF THE INITIAL CONTROL WORD
; AND WITH P1=LOC OF CHANNEL DATA BLOCK
;EXIT WITH T1=NUMBER OF GOOD WORDS TRNSFERRED
; T2=CORRECTIVE DATA FOR IOWD
; T3= N,,LOC OF FAILING IOWD   WHERE N=0 IF RH10, N=-1 FOR RH20
WRDCNT::TDZA	T2,T2
WRDCNX::MOVSI	T2,200000
	PUSHJ	P,SAVE4		;SAVE P1,P2
	MOVEI	P3,-1		;SET UP MASK
	HLLZ	P2,T2		;ASSUME 18 BIT CHAN
	SKIPGE	T2,CHB22B##(P1)	;IS IT?
	HRRI	P2,1		;NO, SET FOR 22-BIT
IFN FTKL10,<
	TLNE	T2,CP.RH2##	;RH20?
	HRROI	P2,2		;YES, SPECIAL STUFF
>
	ASH	P3,@ASH22B(P2)	;SHIFT MASK

	SETZ	P1,		;P1 WILL ACCUMULATE WRDCNT
	LDB	T3,CNTPT1(P2)	;L(IOWD)+1

	CAILE	T3,20		;IS IOWD LOC LEGAL?
	CAMLE	T3,SYSSIZ
	JRST	WRDCN5		;NO, WORD-COUNT=0
	LDB	T2,CNTPT2(P2)
	JUMPN	T2,WRDCN0

	MOVE	T3,T1		;YES, GET START OF LIST
WRDCNA:
	LDB	T2,CNTPT3(P2)
	JUMPN	T2,WRDCNB
	SKIPN	(T3)
	JRST	WRDCNC

	MOVE	T3,(T3)		;YES, GET ITS ADDRESS
	JRST	WRDCNA		;  AND TEST IT
WRDCNB:
	MOVE	T4,T3		;YES, SAVE LOC OF REAL IOWD IN T4
	AOJA	T3,WRDCNA	; AND TEST NEXT
WRDCNC:	AOS	T3,T4		;END - T3=L(LAST IOWD)+1
WRDCN0:
	LDB	T4,ADRPT2(P2)
	LDB	T2,ADRPT1(P2)	;LOC+1 OF GOOD DATA WRD
IFN FTKL10,<
	JUMPL	P2,[CAMLE T4,T2	;RH20 ADR IS 1 HIGHER
		    JRST WRDCN5	; SO EQUALS IS OK
		    MOVE P4,2(T1)  ;SAVE ENDING CHAN DATA FOR TEST
		    LDB T3,CNTPT2(P2)  ;WORDCOUNT
		    ADD T4,T3	;TOP ADDR +1 OF IOWD
		    JRST WRDCND]  ;CARRY ON
>

	CAML	T4,T2		;IS LAST DATA WRD IN BOUNDS?
	JRST	WRDCN5		;NO, ASSUME THAT IOWD IS NG
	HLRO	T3,-1(T3)	;MAYBE
	ASH	T3,@ASH22B(P2)	;WORD COUNT

	SUB	T4,T3		;LAST GOOD ADR IN IOWD+1
WRDCND:	CAMGE	T4,T2		;IS WORD IN BOUNDS?
	JRST	WRDCN5		;NO
	LDB	T1,ADRPT3(P2)

WRDCN1:	SKIPN	(T1)		;IS THERE AN IOWD?
	JRST	WRDCN5		;NO, THE DF10 LIED!
IFN FTKL10,<
	JUMPL	P2,[CAMN P4,(T1)	;THIS IOWD WHAT THE RH20 STORED?
		    JRST WRDCNF	;YES. THE LAST IOWD IS LAST IT DID
		    LDB T4,[POINT 11,(T1),13]
		    MOVNS	T4	;11 BITS OF NEGATIVE WDCNT
		    JRST	WRDCNE]
>
	HLRO	T4,(T1)		;WDCNT OF IOWD
	ASH	T4,@ASH22B(P2)	;WORD COUNT
WRDCNE:	LDB	T3,ADRPT3(P2)	;1ST ADDR OF IOWD -1

	TRNN	T4,(P3)		;IF RH 14 BITS=0
	JRST	WRDCN3		; ITS A CHAN JUMP
	CAMG	T2,T3		;GOOD DATA WD IN THIS IOWD?
	JUMPN	T3,WRDCN2	;YES, COUNT THE DATA AND STEP TO NEXT
	SUB	T3,T4		;MAYBE. ADR OF TOP WD IN IOWD
	CAMG	T2,T3		;LAST GOOD DATA IN IOWD?
	JRST	WRDCN4		;YES
WRDCN2:	SUB	P1,T4		;THIS IOWD IS GOOD. COUNT # OF WDS
	HRLS	T1		;SAVE LOC OF GOOD IOWD
	AOJA	T1,WRDCN1	;AND GO TEST NEXT IOWD
WRDCN3:	JUMPE	T3,WRDCN5	;DF10 BLEW IT IF THIS THE END OF THE LIST
	MOVE	T1,T3		;CHAN JUMP - SET T1 TO ADR
	JRST	WRDCN1		;OF IOWD AND TEST IT


;HERE WITH T1=LOC OF FAILING IOWD,  P1=NO OF WDS IN PREVIOUS IOWDS
;T2=TERMINATION WORD, T3=ADDR+COUNT
;I.E. ON RH10 T3=<LAST WORD>, ON RH20 T3=<LAST WORD>+1
WRDCN4:
;IF THE ERROR IS IN THE MIDDLE OF AN IOWD,
;THE RH10 STORES <LAST WORD XFERED>+1 IN THE
;TERMINATION WORD. BUT IF THE ERROR IS IN THE LAST
;SECTOR OF THE LAST IOWD, THEN THE RH10 MERELY
;STORES <LAST WORD XFERED>
	CAMN	T2,T3		;LAST SECTOR OF IOWD?
	TLNE	P2,600000	;AND RH10?
	CAIA			;NO, RH20 OR NOT LAST
	ADDI	T2,1		;YES, ADD FUDGE FACTOR
	LDB	T3,ADRPT3(P2)
	TLNN	P2,600000
	ADDI	T3,1
	SUB	T2,T3		;NO OF GOOD DATA WDS IN IOWD
	ADD	P1,T2		;P1=TOTAL GOOD WORDCOUNT
	JUMPE	P1,WRDCN6	;NO CORRECTION IF NO DATA
	CAIG	T2,1		;IF ONLY 1 WORD
	TRNE	P1,BLKSIZ##-1	;OR NOT AN EVEN MULTIPLE OF 200 WORDS
	JRST	WRDCN6		;NO CORRECTION DATA (CHANNEL BLEW IT)
	SUB	P1,T2		;NUMBER OF REMAINING WORDS
WRDCNF:	HLRZS	T3,T1		;ADDRESS OF IOWD
	LDB	T2,CNTPT3(P2)	;GET ORIGINAL COUNT OF THIS IOWD
	JUMPL	P2,WRDCN6	;GO IF RH20
	HLRO	T2,(T3)		;RH10, MUST GET +COUNT
	ASH	T2,@ASH22B(P2)
	MOVNS	T2
WRDCN6:	MOVEI	T3,T2		;T2 WILL GET THE ANSWER
	SKIPL	P2		;RH10?
	SKIPA	T4,T2		;YES, GET - COUNT
	MOVN	T4,T2		;NO, ALREADY HAVE -COUNT
	DPB	T4,CNTPT3(P2)	;SAVE LH CORRECTION DATA
	SKIPGE	T3,P2		;RH20?
	TLO	T2,700000	;YES, ALLOW FOR CARRY INTO BIT 2
	HRR	T3,T1		;RH OF CORRECTION DATA
	SKIPA	T1,P1		;TOTAL NO OF GOOD WORDS
WRDCN5:	SETZB	T1,T3		;WE LOSE, ZERO MEANINGFUL ACS
	POPJ	P,		;RETURN WITH ANSWER
ADRPT1::POINT	18,1(T1),35
	POINT	22,1(T1),35
	POINT	22,2(T1),35
ADRPT2::POINT	18,-1(T3),35
	POINT	22,-1(T3),35
	POINT	22,-1(T3),35
ADRPT3::POINT	18,(T1),35
	POINT	22,(T1),35
	POINT	22,(T1),35
CNTPT1::POINT	18,1(T1),17
	POINT	14,1(T1),13
	POINT	22,1(T1),35
MSK22B::XWD	0,-1
	XWD	17,-1
	XWD	17,-1
WDCPNT::POINT	18,0(P1),17
	POINT	14,0(P1),13
	POINT	14,0(P1),13
	POINT	14,0(P1),13
CNTPT2::POINT	18,-1(T3),17
	POINT	14,-1(T3),13
	POINT	11,-1(T3),13
CNTPT3::POINT	18,(T3),17
	POINT	14,(T3),13
	POINT	11,(T3),13
CNTPP2::POINT	11,P2,13
ADRPT4::POINT	18,T1,17
	POINT	14,T1,13
ASH22B::0
	0,,-4
	0,,-7
JMPRH2==:077760		;THESE (LH) BITS ARE 0 FOR AN RH20 JUMP-WORD
CNTFIL::0
	XWD	-1,740000

>;END IFN M.KL10
;SUBROUTINE TO EXECUTE A SUBROUTINE OVER ALL CPU'S
;CALLING SEQUENCE:
;	MOVEI	T1,SUBROUTINE TO BE EXECUTED, OR
;	HRROI	T1,IF SUBROUTINE SHOULDN'T BE EXECUTED ON THIS CPU
;	PUSHJ	P,CPUAPP
;SUBROUTINE IS CALLED WITH P1 POINTING AT A CPU CDB
; FOR WHICH THE DESIRED ACTION IS TO BE APPLIED

CPUAPP::PUSHJ	P,SAVE1		;SAVE P1
IFE CPUN-1,<
	JUMPL	T1,CPOPJ	;RETURN IF NOT TO BE APPLIED TO .CPSLF
	MOVEI	P1,.C0CDB	;ONLY CPU0
	TLO	T1,(IFIW)	;STAY IN CALLER'S SECTION
	JRST	(T1)		;DO IT
>
IFN CPUN-1,<
	PUSH	P,T1		;SAVE ADDRESS OF SUB
	SKIPL	T1		;CALL SUB ON SELF CPU?
	TDZA	T1,T1		;YES, CLEAR T1 AND SKIP
	MOVE	T1,.CPSLF	;NO, GET ADDRESS OF SELF CDB
	PUSH	P,T1		;SAVE ON STACK
	HLLZ	T1,-2(P)	;GET RETURN PC OF SAVE1 CALL
	TLZ	T1,-1-MXSECN	;STAY IN CALLER'S SECTION
	HRR	T1,-1(P)	;CALLER'S SECTION NUMBER + PC
	EXCH	T1,-1(P)	;RESTORE T1, SAVE CALLER'S PC
	MOVEI	P1,.C0CDB	;START WITH CPU0
CPUAP1:	CAME	P1,(P)		;POSSIBLY SKIP CALL ON SELF CPU
	PUSHJ	P,@-1(P)	;CALL THE SUBROUTINE
	  JFCL			;ALLOW FOR A SKIP RETURN
	HLRZ	P1,.CPCDB-.CPCDB(P1) ;NEXT CDB
	JUMPN	P1,CPUAP1	;NEXT CPU
	ADJSP	P,-2		;SO CALLED ROUTINE CAN RETURN AN ANSWER IN T1
	POPJ	P,		;RETURN
>
	$ABS			;MUST BE IN LOW SEG FOR ONCE REFERENCES

;SUBROUTINE TO REFERENCE A MEMORY LOCATION IN PHYSICAL MEMORY
;CALLING SEQUENCE:
;	MOVE	U,ABSOLUTE ADDRESS TO REFERENCE
;	PUSHJ	P,REFMEM
;	...	RETURN HERE
;T1 CONTAINS THE CONTENTS OF THE LOCATION SPECIFIED BY U

REFMEM::PUSH	P,P1		;CAN'T USE SAVE1
	MOVE	P1,U
	LSH	P1,W2PLSH
	HRLI	P1,(<PM.DCD>B2+PM.WRT)
	PUSH	P,P3
	MOVE	P3,.CPMAP
	MOVEM	P1,.EUPMP/PAGSIZ(P3)
	CLRPGT	(0,.EUPMP)
	MOVE	P1,U
	ANDI	P1,PG.BDY
	IORI	P1,.EUPMP
	MOVEI	P3,REFME2
	PUSH	P,.USPFN+1
	MOVEM	P3,.USPFN+1
	EXCH	P3,.USPFN
	SETZ	T1,
	MOVES	T1,(P1)
REFME2:	MOVEM	P3,.USPFN
	POP	P,.USPFN+1
	POP	P,P3
	POP	P,P1
	POPJ	P,

	$HIGH
IFN M.KS10,<
;ROUTINE TO COMPUTE THE NUMBER OF WORDS TRANSFERRED IN THE LAST I/O OPERATION
;THROUGH THE UNIBUS ADAPTER LINKED TO THE CHANNEL DATA BLOCK POINTER TO BY
;P1. FINAL ADDRESS IS IN T1.
;RETURNS CPOPJ ALWAYS WITH THE NUMBER OF GOOD WORDS TRANSFERRED IN T1.

WRDCNT::HRRZ	T2,CHNIEA##(P1)	;GET INITIAL ELEVEN STYLE ADDRESS
	SUB	T1,T2		;SUBTRACT FROM FINAL ADDRESS
	LSH	T1,-2		;GET INTO TEN STYLE WORDS
	POPJ	P,		;AND RETURN

>;END IFN M.KS10
SUBTTL	DAEMON ERROR REPORT BLOCK

	$ABS
IFNDEF	ERPTMX,<ERPTMX==:^D80>	;LENGTH OF BLOCK FOR ERRORS

ERPTBK::BLOCK	ERPTMX		;BLOCK FOR ERRPT. UUO
ESVIDX::EXP	0		;POINTER FOR STORING IN ERPTBK
EPKIDX::EXP	0		;POINTER FOR PICKING UP FROM ERPTBK
ERRLAP::EXP	0		;COUNTER FOR OVERFLOWS OF ERPTBK (LOST ERRORS)
SUBTTL SYSTEM BYTE POINTERS

$HIGH

PUUOAC::POINT	4,M,12		;UUO AC FIELD
PIOMOD::POINT	4,S,35		;MODE BITS
XP PJBNLH,001100		;LEFT HALF OF "POINT 9,XXX,35"

PUNIT::	POINT	 9,DEVJOB(F),17	;DEVICE UNIT NUMBER
PCTXN::	POINT	 9,DEVJOB(F),26	;DEVICE CONTEXT ASSIGNMENT
PJOBN::	POINT	 9,DEVJOB(F),35	;DEVICE JOB ASSIGNMENT
PJCHN::	POINT	18,DEVJOB(F),35	;DEVICE JOB/CONTEXT HANDLE ASSIGNMENT

PJBSTS::POINT	JWSIZ,JBTSTS(J),JWPOS	;JOB WAIT STATE (QUEUE) CODE
				;IN JOB STATUS WORD
PJBST2::POINT	JS.SIZ,JBTST2(J),JS.POS	; JOB QUEUE NUMBER (NOT STATE CODE)
PJ2ST1::POINT	JS.SIZ,JBTST2(T1),JS.POS ;SAME AS PJBST2 FOR IDX T1
JBYEWT::POINT	ESLPSZ,JBTST2(J),ESLPBP	;EVENT WAIT REASON
JBYICC::POINT ICCSIZ,JBTSTS(J),ICCPOS  ;POINTER TO HIGH
				; SEGMENT IN CORE COUNT
PDVSTA::POINT	6,DEVSTA(F),35	;STATION NUMBER OF DEVICE
PBUFSZ::POINT	17,DEVCHR(F),35	;BUFFER SIZE
PDVTIM::POINT	3,DEVCHR(F),9	;CODE FOR TIME DEVICE MAY
					;BE ACTIVE BEFORE BEING DECLARED
					;HUNG. N MEANS 2^N-1 SECONDS
PDVCNT::POINT	7,DEVCHR(F),16	;COUNTED DOWN EACH SECOND,
				;1 TO 0 TRANSITION MEANS HUNG DEVICE
IADPTR::POINT	2,DEVIAD(F),2	;COUNT OF NUMBER OF USER CHANNELS INITED
				; ON THIS DEVICE (DECTAPE ONLY)
IFN FTSPL,<
DEYSPL::POINT	8,DEVSPL(F),17	;SPOOL BIT ASSOCIATED WITH DEVICE
>
DEYISN::POINT	5,DEVISN(F),17	;POINTER TO SECTION OFFSET FOR MULTI-SECTION I/O
DEYTYP::POINT	8,DEVTYP(F),9	;POINTER TO DEVICE-TYPE BIT (+.TYVAR & .TYRAS)

PDVTYP::POINT	6,DEVTYP(F),9	;JUST DEVICE TYPE
PCORSZ::POINT	CRSIZ,JBTADR(J),CRPOS	;BYTE POINTER TO LOW OR HIGH SEG CORE SIZE-1
PCORSR::POINT	CRSIZ,R,CRPOS	;SAME FROM R

	$ABS
CORE2P::POINT	CTNBPE,CORTAB	;BYTE POINTER TO CORE ALLOCATION TABLE
	$HIGH

COREP::	POINT	CTNBPE,CORTAB	;CTNBPE BIT POINTER TO CORE ALLOCATION TABLE
PDYQT2::POINT	PDSQNT,.PDQNT(T2),PDNQNT
PDYQNT::POINT	PDSQNT,.PDQNT(W),PDNQNT ;POINTER TO QUANTUM RUN TIME FOR JOB
PDYIPT::POINT	PDSIPT,.PDIPT(W),PDNIPT ;POINTER TO INCORE PROTECT TIME
PDYIP2::POINT	PDSIPT,.PDIPT(T1),PDNIPT ;POINTER TO INCORE PROTECT TIME
PDYDPT::POINT	9,.PDDFL(W),8	;DEFAULT PROTECTION
PDYBFN::POINT	9,.PDDFL(W),35	;DEFAULT NUMBER OF DISK BUFFERS
IFN FTFDAE,<
PDYFSP::POINT	9,.PDDFL(W),26	;FILE DAEMON SUPPLIED PROTECTION
>
PDYBSN::JBPBSN+.PDOBI(W)	;POINTER TO BATCH STREAM NUMBER
PDYOPP::JBPOPP+.PDOBI(W)	;POINTER TO OPERATOR PRIVILEGES BYTE
PDYWTO::JBPWTO+.PDOBI(W)	;POINTER TO WRITE-TO-OPR TYPE
PIEVM::	POINT	9,DEVEVM(F),8	;VIRTUAL PAGE NUMBER OF STARTING PAGE IN THE
				; EXEC MAP ALLOCATED TO THIS DEVICE FOR BUFFERED INPUT
PIEVMS::POINT	9,DEVEVM(F),17	;NUMBER OF PAGES IN THE EXEC MAP ALLOCATED TO
				; THIS DEVICE FOR BUFFERED INPUT
POEVM::	POINT	9,DEVEVM(F),26	;VIRTUAL PAGE NUMBER OF STARTING PAGE IN THE
				; EXEC MAP ALLOCATED TO THIS DEVICE FOR BUFFERED OUTPUT
POEVMS::POINT	9,DEVEVM(F),35	;NUMBER OF PAGES IN THE EXEC MAP ALLOCATED TO
				; THIS DEVICE FOR BUFFERED OUTPUT
	XP	PDEVM,POEVM	;VIRTUAL PAGE NUMBER OF STARTING PAGE IN THE EXEC
				; MAP ALLOCATED TO THIS DEVICE FOR DUMP I/O
	XP	PDEVMS,POEVMS	;NUMBER OF PAGES IN THE EXEC MAP ALLOCATED TO
				; THIS DEVICE FOR DUMP I/O
PDVESE::POINT	9,DEVESE(F),35	;EXTENDED ERROR STATUS
IFN FTMP,<
DEYCPF::POINT	3,DEVCPU(F),2	;1ST CPU OWNING DEVICE
	CPFBOO==:7		;CODE NUMBER FOR BOOT CPU
	CPFBIT==:6		;CODE NUMBER FOR CI DEVICE
				;MUST USE BIT MASK FOR ALL CI DEVICES
DEYCPS::POINT	3,DEVCPU(F),5	;2ND CPU OWNING DEVICE
				;THIS FIELD IS NO LONGER USED
				;FOR HISTORICAL PURPOSES THE CODE HAS
				;BEEN REPEAT ZEROED. SEE CHKCPI AND CPUDDB
DEYPCL::POINT	3,DEVCPU(F),8	;0 FOR NON-Q PROTOCOL, CPU DOING IO FOR QUEUED
	PCLCP0==:7		;CODE NUMBER FOR CPU0
	PCLDKY==:6		;CODE NUMBER FOR "I DON'T KNOW YET"
DEYCPU::POINT	3,DEVCPU(F),11	;CPU WHICH LAST DID INPUT OR OUTPUT UUO
MPYNRN::POINT	6,JBTSPS(J),5	;NOT RUNNABLE ON CPUN FIELD
>
NFYPGS::POINT	MCPSIZ,JBTPDB(J),MCPBPP ;POINTER TO NUMBER OF FUNNY PAGES
IFYPGS::POINT	MCPSIZ,JBTPDB(J),IMCPBP ;NUMBER OF FUNNY PAGES TO SWAP IN

IMGIN::POINT 21,JBTIMI(J),35	;SIZE OF USER JOB IN P IN CORE
IMGOUT::POINT 21,JBTIMO(J),35	;SIZE OF USER JOB IN P ON DISK
	OUTMSK==:7,,777777	;MASK OF IMAGE SIZE IN JBTIMI/JBTIMO/JBTVIR

NZSICN::POINT	6,JBTIMI(J),8	;NUMBER OF NZS MAPS FOR SWAPIN
NZSSCN::POINT	6,JBTIMI(J),14	;NUMBER OF NZS MAPS
NZSXCN::POINT 12,JBTIMI(J),14	;ALL NZS MAP COUNT

LOVSIZ::POINT 21,JBTVIR(J),35	;VIRTUAL LOW SEG SIZE
HIVSIZ::POINT 9,JBTVIR(J),14	;VIRTUAL HI SEG SIZE
JBYSPR::POINT	JBSSPR,JBTSTS(J),JBNSPR	;HIGH SEG ACCESS PRIVILEGES


IFG SYS50N,<			;SWAPPING SYSTEM?
IFN LEVDN,<
JBYSUN::POINT	3,JBTSWP(J),17
JBYLKN::POINT	18,JBTSWP(J),35
>	;END CONDITIONAL ON LEVDN
>	;END OF CONDITIONAL ON 10/50S
SSUNT1::POINT	3,T1,17		;SWAPPING UNIT FROM ADDRESS IN T1
SSUNT4::POINT	3,T4,17		;ALSO FROM T4
SLKNT1::POINT 18,T1,35	;SWAPPING ADDRESS ON UNIT FROM T1

JBYWCH::POINT	23,JBTWCH(J),35	;BYTE POINTER TO TIME OF DAY STARTED WAITING
				;END FT WATCH

	JBYLCR::POINT	18,JBTCLM(J),17 ;CORE LIMIT POINTER
JBYLTM::POINT	36-^L<JB.LTM>,JBTLIM(J),35 ;TIME LIMIT POINTER

IFN FTNSCHED,<
JBYCLS::POINT 5,JBTSCD(J),17	;POINTER TO CLASS FOR JOB.
JBYCL1::POINT 5,JBTSCD(T1),17	;DITTO FOR IDX T1
JBYCL4::POINT 5,JBTSCD(T4),17	;DITTO FOR IDX T4
>;END IFN FTNSCHED

PDVIAD::POINT 22,DEVIAD(F),35	;POINTER FOR STORING EVA OF CURRENT INPUT BUFFER
PDVOAD::POINT 22,DEVOAD(F),35	;POINTER FOR STORING EVA OF CURRENT
				; OUTPUT BUFFER

JBYLSA::POINT 14,JBTAD2(J),35	;POINTER TO PHYSICAL PAGE NO. OF FIRST PAGE
				; OF THIS LOW SEGMENT
JBYMAP::POINT 21,JBTAD2(J),21	;SWAPPED OUT LOCATION OF .UPMAP
JBYMT4::POINT 21,JBTAD2(T4),21	;FOR VMSER

JBYHSA::POINT 13,JBTHSA(J),35	;POINTER TO PHYSICAL PAGE NO. OF FIRST PAGE
				; OF THIS HIGH SEGMENT
JBYHSO::POINT 9,JBTUPM(J),8	;VIRTUAL PAGE NUMBER OF HIGH SEGMENT ORIGIN
JBYHSS::POINT 9,JBTUPM(J),8	;NO. OF PAGES-1 IN THE HIGH SEGMENT THE
				; LAST TIME THE MAP WAS SET UP
JBYSG2::POINT 5,JBTSG2(J),4	;SECTION # OF HIGH SEG
XP PSG2LH,<POINT 5,,4>		;SKELETON B.P. FOR ABOVE

LSTBAS::POINT 7,.PDACS+ACTSTL-1(W),34 ;LAST BYTE IN ACCOUNT STRING

JBYDEB::POINT 2,JBTST2(J),2	;DEFERRED ECHO BITS


FRGAP3::POINT 21,(P3),35	;DISK ADDR IN FRAGMENT TABLE (P3)
FRGUP3::POINT 3,(P3),17		;DISK UNIT IN FRAGMENT TABLE (P3)
FRGCP3::POINT 9,(P3),14		;FRAGMENT SIZE IN FRAGMENT TABLE (P3)
FRGAP1::POINT 21,(P1),35	;SAMAE AS ABOVE CORRESPONDING FOR (P1)
FRGUP1::POINT 3,(P1),17
FRGCP1::POINT 9,(P1),14

FRGUT1::POINT 3,T1,17		;BYTE POINTER FOR UNIT IN FRAG PTR IN T1
FRGCT4::POINT 9,T4,14		;BYTE POINTER FOR COUNT IN FRAG PTR IN T4
	$ABS
SUBTTL PI CHANNEL SAVE/RESTORE
;DEFINE PI CHANNEL SAVE AND RESTORE ROUTINES IF A DEVICE IS ON THE CHANNEL

	PDL==201		;LENGTH OF INTERRUPT PI PUSH DOWN LIST

DEFINE CHAN (PI)<
;	XLIST
	HIGHAC==17
	HIACBL==17
CH'PI::	0		;PC STORED HERE BY JSR ON INTERRUPT TO CHANNEL PI
	0
	EXP	IC.UOU
	EXP	.+1
	XJEN	CH'PI


DEFINE FSTCHN,<
ZZS==0
IFE <PI&7-SCNCHN>,<ZZS==2>	;USE EXEC AC BLOCK 2 ON SCANNER CHANNEL
IFE <PI&7-DSKCHN>,<ZZS==3>	;USE EXEC AC BLOCK 3 ON DSK CHANNEL
IFE <PI&7-NETCHN>,<ZZS==4>	;USE EXEC AC BLOCK 4 ON NETWORK
>

DEFINE INTL.(X)<INTL'X>

DEFINE INTL<
	<IFN <PI&7>-DSKCHN,<INTL'PI>>
	+<IFE <PI&7>-DSKCHN,<INTL.(\DSKCHN)>>
>

DEFINE INTO.(X)<INTO'X>
DEFINE INTO<
	<IFN <PI&7>-DSKCHN,<INTO'PI>>
	+<IFE <PI&7>-DSKCHN,<INTO.(\DSKCHN)>>
>
;CHAN DEFINITION CON'T ON NEXT PAGE
;CONTINUE CHAN DEFINITION

;HERE FROM AN INTERRUPT ROUTINE WHICH HAS FOUND ITS DEVICE NEEDS SERVICE
;SAVE ACS 0 THRU HIGHAC, CALLED BY JSR, SETS UP P TO PUSH DOWN LIST FOR THIS PI
	FSTCHN		;ZZS NON-ZERO IF SCANNER OR DSK PI SAVE ROUTINE

SAV'PI::
IFN M.KS10,<
SAV'PI'R::
IFN M.DECN,<
	0		;CALLED BY JSR
	JSR	SAV'PI'X
	EXP	RGMAP##
>
SAV'PI'D::
IFN M.DECN,<
	0		;CALLED BY JSR
	JSR	SAV'PI'X
	EXP	DNMAP##
> ;END M.DECN
SAV'PI'X::
> ;END OF M.KS10
	0		;CALLED BY JSR
IFN M.KL10,<
	DATAI	PAG,SVPG'PI	;REMEMBER OLD AC BLOCK #
	EXECAC	(ZZS)		;SET EXEC AC BLOCK
;	XLIST
>
IFN M.KS10,<
	RDUBR	SVPG'PI		;REMEMBER OLD AC BLOCK #
	EXECAC	(ZZS)
	XLIST
>
IFE ZZS,<
	MOVEM	HIGHAC,SVAC'PI+HIGHAC	;SAVE AC HIGHAC
IFG RTTRPN,<
	SKIPN	HIGHAC,.CPRTT	;ALWAYS SAVE ACS IF RTTRP IS IN PROGRESS
>
	MOVE	HIGHAC,CH'PI	;GET INTERRUPT PC
	TLNE	HIGHAC,(XC.USR)	;WAS THE INTERRUPT OUT OF EXEC MODE
	JRST	SAV'PI'A	;NO, DON'T NEED TO SAVE AC'S
	MOVEI	HIGHAC,SVAC'PI	;SETUP TO SAVE 0 THRU HIGHAC-1
	BLT	HIGHAC,SVAC'PI+HIGHAC-1	;SAVE ACS
>
SAV'PI'A:MOVE	P,C'PI'PDP	;SETUP PUSH DOWN POINTER
IFE <M.KS10&M.DECN>,<
	MOVSI	(IC.UOU)	;TURN ON USER IOT SO XCT PAGED WILL
	HLLM	SAV'PI		; REFERENCE USER RATHER THAN EXEC VIRTUAL MEMORY
>				;(DO THIS LATER IFN M.KS10&M.DECN)
IFN M.KL10,<
	MOVE	[LG.LPC!LG.LUB!LG.IAM]
	XORM	SVPG'PI
>
IFN FTMP,<
	SKIPGE	INTL		;DON'T TRY UNLESS ITS POSSIBLE TO GET IT
	AOSE	INTL		;WAIT FOR INTERLOCK
	JRST	.-2
	APRID	INTO

>
IFN <M.KS10&M.DECN>,<
	MOVE	T1,.CPEPT	;ADDRESS OF THIS CPU'S EPT
	MOVE	T1,SECTAB+0(T1)	;GET SECTION 0 POINTER
	MOVEM	T1,SVMP'PI	;SAVE IT
	MOVE	T1,SAV'PI'X	;ARG
	PUSH	P,-2(T1)
	POP	P,SAV'PI'X	;REAL CALLER OF SAV ROUTINE
	MOVSI	(IC.UOU)	;TURN ON USER IOT SO XCT PAGED WILL
	HLLM	SAV'PI'X	; REFERENCE USER RATHER THAN EXEC VIRTUAL MEMORY
	PUSHJ	P,@(T1)		;CALL RGMAP OR DNMAP
	JRST	2,@SAV'PI'X
>
IFE <M.KS10&M.DECN>,<
	JRST	2,@SAV'PI	;RETURN TO CALLER AND PROCESS INTERRUPT
>
;HERE FROM INTERRUPT ROUTINE WHEN IT HAS FINISHED SERVICING INTERRUPT
;RESTORE ACS AND DISMISS INTERRUPT
;USUALLY TRANSFERRED TO BY POPJ P,

	$HIGH
RET'PI::
IFN FTMP,<
	SETOM	INTO		;NO LONGER OWN
	SETOM	INTL		;GIVE UP INTERLOCK
> ;END IFN FTMP
IFE ZZS,<
IFN M.KL10,<
IFG RTTRPN,<
	SKIPN	HIGHAC,.CPRTT	;RESTORE SAVED ACS IF RTTRP IS IN PROGRESS
> ;END IFG RTTRPN
	MOVE	HIGHAC,CH'PI	;GET INTERRUPT PC
	TLNE	HIGHAC,(XC.USR)	;WAS THE INTERRUPT OUT OF USER MODE?
	JRST	CH'PI'XIT	;YES--AC'S WERE NOT SAVED
> ;END IFN M.KL10
> ;END IFE ZZS

IFN <M.KS10&M.DECN>,<
	MOVE	P,C'PI'PDP	;MAKE SURE PDL IS RIGHT (PROBABLY EXTRANEOUS)
	ADJSP	P,1		;POINT AHEAD
	MOVE	T1,SVMP'PI	;CONTENTS OF SECTION 0 MAP POINTER AT ENTRY
	PUSHJ	P,ETRMAP##	;RESTORE REGULAR/DECNET MAPPING
>
IFE ZZS,<
	MOVSI	HIGHAC,SVAC'PI	;RESTORE ACS 0 THRU HIGHAC
	BLT	HIGHAC,HIGHAC
> ;END IFE ZZS
IFN M.KL10,<
CH'PI'XIT:
	DATAO	PAG,SVPG'PI	;RESTORE OLD AC BLOCK #
> ;END IFN M.KL10
IFN M.KS10,<
IFE ZZS,<
	WRUBR	SVPG'PI		;RESTORE OLD AC BLOCK #
> ;END IFE ZZS
IFN ZZS,<
	MOVE	17,SVPG'PI	;CONTENTS OF THE UBR AT THE INTERRUPT
IFE M.DECN,<
	TLZ	17,(SG.LUB)	;ONLY RESTORE AC SETS
> ;END IFE M.DECN
	WRUBR	17		;RESTORE ACS AT INTERRUPT TIME
> ;END IFN ZZS
> ;END IFN M.KS10
C'PI'JEN::
	XJEN	CH'PI

	$ABS

IFG RTTRPN,<
IFN M.KL10,<
	RTPOPN==30
>	;END IFN M.KL10
IFN M.KS10,<
	RTPOPN==0
>
		RETPD'PI==:C'PI'PD1+RTPOPN
		RTOFST==:CHD'PI-CHND'PI

CHND'PI::	HRROI P,RETPD'PI
		IFLE PI-AP0CHN,<JSP J,DSMAPR>
		IFG  PI-AP0CHN,<JSP J,DISMIS>
RTRT'PI::	MOVSI 17,SVAC'PI	;RESTORE ALL OF THE AC'S
		BLT 17,17
IFN M.KL10,<
		DATAO PAG,SVPG'PI	;RESTORE AC BLOCK
>	;END IFN M.KL10
IFN M.KS10,<
		WRUBR	SVPG'PI		;RESTORE AC BLOCK
>
		XJEN	CH'PI


RTSV'PI::	0			;COME HERE TO SAVE ALL AC'S
IFN M.KL10,<
		DATAI PAG,SVPG'PI	;SAVE AC BLOCK
		EXECAC			;SET EXEC AC BLOCK
>	;END IFN M.KL10
IFN M.KS10,<
		RDUBR	SVPG'PI		;SAVE AC BLOCK
		EXECAC			;SET EXEC AC BLOCK
>
		MOVEM 17,SVAC'PI+17	;SAVE 17
		MOVEI 17,SVAC'PI	;SET UP BLT POINTER
		BLT 17,SVAC'PI+16	;SAVE THE AC'S
		MOVE P,C'PI'PDP		;SET UP P POINTER
		MOVSI (IC.UOU)		;TURN ON USER IOT SO PAGED XCT
		HLLM RTSV'PI		; WILL REFERENCE USER VIRTUAL
		JRST 2,@RTSV'PI		;RETURN TO CALLER

CHD'PI::		EXP ENBSTD
		Z	;STORAGE LOCATION FOR PROTECTION-RELOCATION VALUE.
		Z	;STORAGE LOCATION FOR APR ENABLE BITS.
>	;IFG RTTRPN

IFN M.KS10,<IFN M.DECN,<
SVMP'PI::	BLOCK	1
>>
SVPG'PI::	BLOCK	1
SVAC'PI::	BLOCK HIACBL+1	;PLACE TO SAVE ACS 0 THRU HIGHAC
C'PI'PDP::	XWD -PDL+1,.+1	;INITIAL PUSH DOWN POINTER
C'PI'PD1::	EXP RET'PI	;FIRST WORD ON LIST,
				; POPJ WILL RETURN TO DISMISS INTERRUPT
	BLOCK	PDL-1		;PUSHDOWN LIST SPACE
	LIST
>	;END OF CHAN DEFINITION
;SET USED'N TO BE NON-ZERO FOR ALL CHANNELS
;THAT NEED CHANNEL SAVE ROUTINES
;THIS INCLUDES ALL CHANNELS WHICH RTTRP MAY USE
IFN FTRTTRP,<
	DEFINE	SETUSED(PI)
	<CUSD'PI==:USED'PI
	IFE	USED'PI,<IFDEF UNIQ'PI,<IFE UNIQ'PI,<USED'PI=:-1>>
IFN M.TD10,<
IFE PI-DADCHN,<CUSD'PI==:1	;DON'T ALLOW FAST BLOCK MODE ON DTA DATA CHN
>>
					IFNDEF UNIQ'PI,<USED'PI=:-1>>
>	;DEFINE SETUSED

	ZZ==-1
	REPEAT M.CPU,<
	ZZ==ZZ+2
	REPEAT 6,<
	SETUSED(\ZZ)
	ZZ==ZZ+1
>>
>	;IFN FTRTTRP
IFG CPUN-1,<LOC	<.+777>&777000>
CSHFIR==:.
;NULL JOB DUMP AC AREA:

DEFINE NULDAC(N)<
NU'N'DAC::BLOCK	20
	XP NU'N'DAT,NU'N'DAC-20
>
ZZ==0
REPEAT M.CPU,<
	NULDAC(\ZZ)
ZZ==ZZ+1
>
ERPDLL==43
ERRPLL==:-ERPDLL+1
DEFINE PDLDEF(N)<
IFE N,<
ERRPDL::
>
ER'N'PDL::
	BLOCK	ERPDLL
>
ZZ==0
REPEAT M.CPU,<
PDLDEF (\ZZ)
ZZ==ZZ+1
>

MNULPD=:-205+1			;LENGTH OF NULL PDL

DEFINE PDLDEF(N)<
IFE N,<
NULPDL::
>
NU'N'PDL::
MNU'N'PD==MNULPD
	BLOCK	-MNULPD+2
>
ZZ==0
REPEAT M.CPU,<
PDLDEF (\ZZ)
ZZ==ZZ+1
>
IFLE <CPUN-1>,<NU1PDL==:NULPDL>
;GENERATE THE CHANNEL SAVE ROUTINE ONLY FOR PI WHICH NEED THEM (ASGSAV MACRO USED)

;GENERATE NULL CHANNEL SAVE ROUTINES FOR THOSE CHANNELS NOT USED

DEFINE NULL (PI)<
CH'PI::	0
	0
	EXP	0
	EXP	.+1
	XJEN	CH'PI

>

	DEFINE	USED(PI)<
		IFN USED'PI, <CHAN PI>
		IFE USED'PI, <NULL PI>
	>;END DEFINE USED
	ZZ==0
	REPEAT M.CPU,<
	ZZ==ZZ+1
	REPEAT 7,<
		USED \ZZ
	ZZ==ZZ+1
	>
	>
;NOW DEFINE DURING PASS 1 A FEW NECESSARY SYMBOLS

	DEFINE	DEFCHL(A,B)
<	A'CHL==:CH'B>

	DEFINE CALCHL(A,B)<
		DEFCHL (<A'B>,\A'B'CH1)
	>;END DEFINE CALCHL
	ZZ==0
	REPEAT M.CPU,<
		CALCHL(AP,\ZZ)
		CALCHL(CK,\ZZ)
	ZZ==ZZ+1
	>;END REPEAT M.CPU
SUBTTL	GENERATE COMMON INTERRUPT ROUTINES FOR ALL PROCESSORS

;MACRO TO MAKE THE INTERRUPT SKIP CHAIN ENTRY'S FOR THE NETSER
; SOFTWARE INTERRUPT. (ONE ENTRY PER CPU)

DEFINE	GCNET(CPU,CHN),<
IFN M.NET,<
NT'CPU'INT::SKIPN	.CPNTF
	JRST	.-1
	JSR	SAV'CHN
	PJRST	NETINT##
>> ;END M.NET AND DEFINE GCNET

;MACRO TO GENERATE CLOCK (CH7) INTERRUPT CHAIN

DEFINE	GCCLK(CPU),<
CK'CPU'INT:SKIPN	.CPCKF
	JRST	.-1
	JRST	CLKINT##
> ;END GCCLK MACRO



;NOW EXPAND ALL THE ABOVE MACROS FOR EACH CPU IN THE CONFIG.
	$HIGH

ZZ==0
REPEAT CPUN,<
	GCNET(\ZZ,\<ZZ*10+NETCHN>)
	GCCLK(\ZZ)
ZZ==ZZ+1
> ;END REPEAT CPUN
	$ABS


	SUBTTL	COMMAND TABLE

;THE NEW FORMAT OF THE COMMAND TABLES IS AS FOLLOWS:
;CMDTAB - CONTAINS SIXBIT COMMAND NAME
;	- CONTAINS THE DISPATCH ADDRESS
;	- CONTAINS THE DISPATCH BITS AS WELL AS THE UNIQUENESS BITS IN
;		THE RIGHTMOST BITS. THE LEFT HALF OF THIS WORD ARE POST
;		DISPATCH BITS, THE RIGHT HALF PREDISPATCH.

;BITS CHECKED BEFORE DISPATCHING TO COMMAND SETUP ROUTINE

NOCORE==:1B18	;NO CORE NEEDED FOR COMMAND
NOJOBN==:1B19	;NO JOB NUMBER NEEDED FOR COMMAND
NOLOGIN==:1B20	;JOB DOES NOT NEED TO BE ALREADY LOGGED IN.
NOACT==:1B21	;COMMAND MUST BE DELAYED IF JOB HAS ACTIVE DEVICES.
NORUN==:1B22	;AN EXPLICIT ^C MUST BE TYPED BY USER BEFORE COMMAND
		; IS EXECUTED IF JOB IS RUNNING
		; JOB MUST BE SWAPPED IN IF IT HAS LOGICAL CORE
INCORE==:1B23	;COMMAND MUST BE DELAYED IF JOB HAS LOGICAL CORE
		; WHICH IS ON DISK OR ON ITS WAY IN OR OUT.
		; JOB WILL BE SWAPPED IN (SEE DLYCOM)
		; AND IS NOT SITTING QUIETLY IN CORE(IE NO SWAPPING TRANSFER)
NXONLY==:1B24	;NOT LEGAL IF EXECUTE ONLY PROGRAM
NBATCH==:1B25	;NOT LEGAL FROM BATCH JOB
CMDERR==:1B26	;ERROR ENCOUNTERED IN COMMAND PARSING (FOR COMCON, NOT TABLES)
NORCMP==:1B27	;ALLOWED LOGGED OUT ON REMOTE TERMINAL DESPITE M.RCMP

CUSTMR==:1B29	;RESERVED TO CUSTOMERS

;UNIQUENESS BITS IN RH OF SIXBIT NAME
;NOTE:	THESE BITS MUST BE DEFINED AS THE LEAST MOST SIGNIFICANT
;	BITS TO INSURE COMPATIBILITY WITH THE USER DEFINED LOGICAL
;	NAME BITS.

UNIQ.1==:1B32	;UNIQUE TO 1 CHAR.
UNIQ.2==:1B33	;UNIQUE TO 2 CHARS.
UNIQ.3==:1B34	;UNIQUE TO 3 CHARS.
UNIQ.4==:1B35	;UNIQUE TO 4 CHARS.

;BITS PLACED IN LH(M) AND CHECKED AFTER RETURN FROM COMMAND SETUP ROUTINE
;NOTE:	THESE BITS MUST BE SHIFTED BY 18 BITS WHEN GENERATING
;	TABLES OR VALUES. THEY ARE DEFINED TO BE RIGHT HALF QUANTITIES ONLY
;	TO ALLOW FOR EASIER TESTING.

NOINCK==:1B18	;NO CHECK FOR JOB INITIALIZATION (JNA=0)
NOCRLF==:1B19	;NO PRINTING OF CRLF
NOPER==:1B20	;NO PRINTING OF PERIOD
TTYRNU==:1B21	;SET TTY TO USER MODE AND START JOB
		; WHEN COMMAND RESPONSE STOPS TYPING
TTYRNC==:1B22	;KEEP TTY IN COMMAND MODE AND START JOB
		; WHEN COMMAND RESPONSE STOPS TYPING
TTYRNW==:1B23	;SET TTY TO USER LEVEL AND IO WAIT IF IT WAS IN IOW BEFORE
CMWRQ==:1B24	;REQUEUE JOB AFTER COMMAND WAIT
NOMESS==:1B25	;NO COMMAND RESPONSE EVER, DO NOT CALL TTYSTR OR TYPE WATCH BEGIN.
NOCRLP==:<NOCRLF!NOPER>		;NEEDED FOR INTERNAL
TTYRNM==:<TTYRNW!NOMESS>	;TTY TO USER MODE AND NO MESSAGE
ERRFLG==:1B26	;COMMAND ERROR
SACFLG==:1B27	;COMMAND EXECUTED IN AN ALTERNATE CONTEXT
NOFLM==:1B28	;SUPER-NOCRLF:  CALL PRPER NOT PRDOTC
PSTCST==:1B29	;POST DISPATCH RESERVED FOR CUSTOMER

LHRUNF==:NOPER!TTYRNU!NOCRLF	;HANDY LEFT HALF OF RUNFLG QUANTITY
RUNFLG==:NOCORE!NOACT!NORUN!INCORE!<LHRUNF_^D18>
ECMFLG==:<NOCRLF!NOPER!NOMESS!TTYRNC>_^D18
APPFLG==:SACFLG,,0		;FULLWORD BIT VALUE FOR MONGEN COMMANDS


;FLAG BITS IN LH(M)

FLMCOM==:1B34	;1=COMMAND, 0=UUO
FLMCLV==:1B35	;COMMAND RUNNING AT COMMAND LEVEL
DEFINE UCMDNM(NM,PR,AD,FL,UN,PV),<
  IFNB <AD>,<C  NM,AD,FL,UN>
  IFB  <AD>,<
    IFB  <PR>,<C  NM,RUNAME,FL,UN>
    IFNB <PR>,<
      IFIDN <NM>,<PR>,<C  NM,RUNAME,FL,UN>
      IFDIF <NM>,<PR>,<C  NM,%'PR,FL,UN>
    >
  >
>


DEFINE NAMES<
	C	<>,CBLANK,<<NOFLM!NOINCK!NOCRLF>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
	C	START,START,<<NOPER!TTYRNU>_^D18>!INCORE!NOACT!NORUN!NOLOGIN!NOJOBN,UNIQ.2
	C	.HALT,STOPF,<<NOINCK!CMWRQ>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
	C	HALT,STOP,<<NOINCK!CMWRQ>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP,,HALTXT
	C	KJOB,KJOB,<<NOINCK!NOCRLF!NOPER!NOMESS>_^D18>!NOCORE!NOJOBN!NOLOGIN!NOACT!INCORE!NORUN!NORCMP
	C	R,RCOM,<<NOPER!TTYRNU>_^D18>!NOCORE!NOACT!NORUN!INCORE
	C	RUN,RUNCOM,<<NOPER!TTYRNU>_^D18>!NOCORE!NOACT!NORUN!INCORE,UNIQ.2
	C	CORE,CORE,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
	C	GET,GET,RUNFLG,UNIQ.1!UNIQ.2
	C	SAVE,CSAVE,<<NOCRLF!NOPER!TTYRNU>_^D18>!INCORE!NOACT!NORUN!NXONLY
	C	SSAVE,SSAVE,<<NOCRLF!NOPER!TTYRNU>_^D18>!INCORE!NOACT!NORUN!NXONLY
	C	MERGE,CMERGE,<<NOCRLF!NOPER!TTYRNU>_^D18>!INCORE!NOACT!NORUN!NXONLY
	C	CONTINUE,CONT,<<NOINCK!NOPER!TTYRNW>_^D18>!INCORE!NORUN!NOJOBN!NOLOGIN,UNIQ.1!UNIQ.3!UNIQ.4,CONTXT
	C	JCONTINUE,JCONT,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
	C	.FCONT,FCONT,<<NOINCK!NOCRLF!NOPER!CMWRQ!NOMESS>_^D18>!NORUN!INCORE!NOJOBN!NOLOGIN!NORCMP,,FCOTXT
	C	D,DCOM,<<CMWRQ>_^D18>!INCORE!NXONLY
	C	E,ECOM,<<NOFLM!CMWRQ>_^D18>!INCORE!NXONLY
	C	PJOB,PJOBX,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
	C	.HELLO,HELLO,RUNFLG!NOLOGIN!NORCMP
	C	.BYE,BYECOM,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NOJOBN!NORCMP
	C	DEASSI,DEASSIG,<<NOINCK!CMWRQ>_^D18>!NOCORE!INCORE,UNIQ.3
	C	ASSIGN,ASSIGN,<<CMWRQ>_^D18>!NOCORE!INCORE
IFN FTNET,<
	C	.NETLD,RUNNET,RUNFLG!NOLOGIN!NORCMP
	C	NODE,NODE.C,<<NOCRLF!NOPER!CMWRQ>_^D18>!INCORE!NOCORE!NOLOGIN!NORCMP,UNIQ.2
>	;END FTNET
	C	DDT,DDTGO,<<NOPER!TTYRNU>_^D18>!INCORE!NORUN!NOLOGIN!NOJOBN
	C	.BPT,CDBPT,<<NOINCK!CMWRQ!NOMESS>_^D18>!INCORE!NOCORE!NOJOBN!NOLOGI!NOCRLP!NORCMP
	C	FINISH,CFINI,<<NOCRLF!NOPER!TTYRNU>_^D18>!NOACT!INCORE!NORUN
	C	CLOSE,CLSCOM,<<NOCRLF!NOPER!TTYRNU>_^D18>!NOACT!INCORE!NORUN
	C	REENTER,REENTER,<<NOPER!TTYRNU>_^D18>!INCORE!NORUN!NOLOGIN!NOJOBN
	C	CSTART,STARTC,<<TTYRNC>_^D18>!INCORE!NOACT!NORUN!NBATCH
	C	CCONTINUE,CONTC,<<TTYRNC>_^D18>!INCORE!NORUN!NBATCH
	C	DETACH,DETACH,<<NOINCK>_^D18>!NOCORE!NBATCH!NOLOGIN
	C	ATTACH,ATTACH,<<NOINCK>_^D18>!NOCORE!INCORE!NOLOGIN!NBATCH!NORCMP
	C	XCHNGE,XCHDSK,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NBATCH
	C	ENABLE,ENABLE,NOCORE
	C	DISABL,DISABL,NOCORE
	C	DAYTIME,DAYTIM,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
	C	.RESTA,RESTRT,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
	C	TIME,RUNTIM,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NOJOBN
	C	RESOURCES,FREDEV,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
	C	USESTAT,USECOM,<<NOINCK!NOPER!NOMESS>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
	C	VERSION,VERCOM,<<CMWRQ>_^D18>!INCORE,,VERTXT

	C	DSK,DSKCOM,<<NOINCK>_^D18>!NOCORE

	C	MOUNT,MNTCOM,RUNFLG,UNIQ.2
	C	DISMOUNT,MNTCOM,RUNFLG,UNIQ.3!UNIQ.4
IFN FTMDA,<
	C	ALLOCA,RUNMDA,RUNFLG
	C	DEALLO,RUNMDA,RUNFLG
	C	SHOW,RUNMDA,RUNFLG
	C	CANCEL,RUNMDA,RUNFLG
	C	MODIFY,RUNMDA,RUNFLG
>
	C	QUEUE,RUNQUE,RUNFLG!NOLOGIN,,QUEUE
	C	CPUNCH,RUNQUE,RUNFLG!NOLOGIN
	C	PLOT,RUNQUE,RUNFLG!NOLOGIN
	C	PRINT,RUNQUE,RUNFLG!NOLOGIN
	C	PUNCH,RUNQUE,RUNFLG!NOLOGIN
	C	SUBMIT,RUNQUE,RUNFLG!NOLOGIN
	C	TPUNCH,RUNQUE,RUNFLG!NOLOGIN

	C	SEND,SEND,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NBATCH

	C	.TYPE,RETYPE,<<NOINCK!NOCRLF!NOPER!NOMESS>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
IFN	FTMIC,<
	C	COJOB,RUNMIC,RUNFLG
	C	WHENEVER,RUNMIC,RUNFLG
	C	ON,RUNMIC,RUNFLG
	C	LET,RUNMIC,RUNFLG
	C	IF,RUNMIC,RUNFLG
	C	GOTO,RUNMIC,RUNFLG
	C	BACKTO,RUNMIC,RUNFLG
	C	OPERATOR,RUNMIC,RUNFLG
	C	NOOPERATOR,RUNMIC,RUNFLG
	C	ERROR,RUNMIC,RUNFLG
	C	NOERROR,RUNMIC,RUNFLG
	C	SILENCE,RUNMIC,RUNFLG
	C	PLEASE,RUNPLS,RUNFLG
	C	REVIVE,RUNMIC,RUNFLG
	C	MIC,RUNMIC,RUNFLG
	C	DO,RUNMIC,RUNFLG
>		;END OF FTMIC STUFF
	C	SCHEDULE,SKEDUL,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
	C	LOGIN,CLOGIN,RUNFLG!NOLOGIN!NORCMP,,LOGTXT
	C	PASSWORD,RUNLGN,RUNFLG,,
	C	REATTA,RUNLGN,<<SACFLG>_^D18>!RUNFLG,,
	C	REASSI,REASS,<<CMWRQ>_^D18>!NOCORE!NOACT!INCORE!NORUN

	C	SET,SET,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP

	C	TTY,TTYCMD,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NOJOBN!NORCMP
	C	TERMINAL,TTYCMD,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NOJOBN!NORCMP
IFN FTNET,<
	C	LOCATE,CLOCATE,NOCORE!INCORE
	C	WHERE,CWHERE,<<CMWRQ>_^D18>!INCORE!NOCORE!NOLOGIN
	C	NETWORK,RUNAME,RUNFLG!NOLOGIN!NORCMP,,NETTXT
>
	C	INITIA,RUNAME,RUNFLG!NOLOGIN!NORCMP,UNIQ.1!UNIQ.2!UNIQ.3!UNIQ.4,INITIA
	C	DIRECT,RUNAME,RUNFLG,UNIQ.2!UNIQ.3!UNIQ.4
	C	HELP,RUNAME,<<NOCRLF!NOPER!TTYRNU!SACFLG>_^D18>!NOCORE!NOLOGIN!NOACT!NORUN!INCORE!NORCMP
	C	SYSTAT,RUNAME,RUNFLG!NOLOGIN,,SYSTXT
	C	FILE,RECALL,RUNFLG
IFE FTMIC,<
	C	PLEASE,RUNAME,<<NOCRLF!NOPER!TTYRNU>_^D18>!NOCORE!INCORE!NOACT!NORUN!NBATCH
>
	C	FUDGE,RUNPIC,RUNFLG
	C	CREF,RUNAMC,RUNFLG
	C	SOS,RUNAME,RUNFLG
	C	ACCOUNT,CACCT,NOCORE
	C	SESSION,RUNLGN,RUNFLG

	C	DECLARE,RUNAME,RUNFLG

	C	.RUN,RUNAME,RUNFLG!NOLOGIN,,.RNTXT

	C	CONTEXT,CTXCMD,<<NOCRLF!NOPER!NOINCK>_^D18>!NOCORE!INCORE,UNIQ.2
	C	PUSH,PSHCMD,<<NOCRLF!NOPER!NOMESS>_^D18>!NOCORE!NORUN!INCORE
	C	POP,POPCMD,<<NOCRLF!NOPER!NOMESS>_^D18>!NORUN!INCORE

IFN FTPATT,<
	C	.PATCH,CPOPJ,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
>
	C	.PLRUN,PLNCOM,RUNFLG,,PLNTXT
	C	COMPILE,CCLRUN,RUNFLG,,COMPIL
	C	DEBUG,CCLRUN,RUNFLG
	C	EXECUTE,CCLRUN,RUNFLG
	C	LOAD,CCLRUN,RUNFLG

	C	CREATE,CCLRUN,RUNFLG
	C	DELETE,CCLRUN,RUNFLG
	C	EDIT,CCLRUN,RUNFLG
	C	LIST,CCLRUN,RUNFLG
	C	MAKE,CCLRUN,RUNFLG,UNIQ.2
	C	RENAME,CCLRUN,RUNFLG
	C	TECO,CCLRUN,RUNFLG,UNIQ.2!UNIQ.3
	C	TYPE,CCLRUN,RUNFLG
	C	COPY,CCLRUN,RUNFLG
	C	PRESERVE,CCLRUN,RUNFLG
	C	REWIND,CCLRUN,RUNFLG
	C	UNLOAD,CCLRUN,RUNFLG
	C	ZERO,CCLRUN,RUNFLG
	C	SKIP,CCLRUN,RUNFLG
	C	BACKSPACE,CCLRUN,RUNFLG,UNIQ.2!UNIQ.3!UNIQ.4
	C	EOF,CCLRUN,RUNFLG
	C	PROTECT,CCLRUN,RUNFLG
	C	LABEL,CCLRUN,RUNFLG

	C	CTEST,CCLRUN,RUNFLG	;ALWAYS LAST CCLRUN

>
DEFINE SNAMES,<
	C	WATCH,SETWAT,NOCORE

	C	TIME,SETRTM,NOCORE

IFN FTSPL,<
	C	SPOOL,SETSPL,NOCORE
	C	CDR,SETCDR,NOCORE
>
	C	SCHEDULE,SETSCD,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
	C	CORMAX,SETMAX,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
IFN FTLOCK,<
	C	CORMIN,SETMIN,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
>
	C	DAYTIM,SETDAY,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
	C	DATE,SETDAT,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN

	C	OPR,SETOPR,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
	C	TTY,TTYCMD,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
	C	TERMINAL,TTYCMD,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
IFN FTHPQ,<
	C	HPQ,HPQCMD,NOCORE
>
	C	DENSITY,MTADEN,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
	C	BLOCKSIZE,MTABLK,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
	C	FORMAT,MTAMOD,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
IFN FTDX10,<
	C	RETRY,MTARTY,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
>

IFN FTMP,<
	C	CPU,CPUCMD,NOCORE
>
	C	NOMESS,DSKSIL,<<NOINCK!NOCORE>_^D18>!NOJOBN!NOLOGIN
IFN FTDPRI,<
	C	DSKPRI,DSKPRI,NOCORE
>
	C	DSKFUL,FULSTP,NOCORE
	C	BREAK,SETBRK,NOCORE
	C	VMMAX,SETVMX,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
	C	VIRTUAL,SETUVC,NOCORE
	C	PHYSICAL,SETUPC,NOCORE

IFN FTNET!FTDECNET,<
	C	HOSTESS,DAASTH,RUNFLG!NOLOGIN!NORCMP
>
	C	MEMORY,SETMEM,<<CMWRQ>_^D18>!NOCORE!NOLOGIN!INCORE

	C	DEFER,SETDFC,NOCORE
	C	NODEFER,SETNDC,NOCORE
	C	DEFAULT,SETDFL,NOCORE!NOLOGIN
	C	FLOATING,SETFPC,NOCORE
	C	DDT,SETBPT,NOCORE
	C	EDDT,SETEBP,NOCORE!NOLOGIN!NOJOBN!NBATCH
;	C	PASSWORD,RUNLGN,RUNFLG
IFN FTPATT,<
	C	CTEST,CPOPJ,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN	;ALWAYS LAST
>
>	;CLOSE DEFINITION OF SNAMES


;DEFINE CUSTOMER DEFINED COMMAND MACRO

	DEFINE CNAMES<
	SPCCMD			;;EXPAND USER DEFINED COMMANDS

>
;GENERATE TABLE OF SIXBIT COMMAND NAMES
DEFINE C(A,B,D,E,F)<
IFNB<F>,<F::>
	<SIXBIT /A/>
>
XALL

COMTB2::SNAMES
DISPL2==:.-COMTB2	;LENGTH
COMMX2==:<DISPL2-1>B26
CSTTAB::CNAMES		;CUSTOMER DEFINED NAMES
DISPLC==:.-CSTTAB	;LENGHT OF TABLE
COMMXC==:<DISPLC-1>B26
COMTAB::NAMES
LASCCL==:.
DISPL==:.-COMTAB	;LENGTH OF TABLE
COMMXL==:<DISPL-1>B26
	$HIGH
;GENERATE THE DISPATCH TABLE PLUS SPECIAL BITS

DEFINE C(A,B,D,E,F) <
 IF2,<IFNDEF B,<EXTERN B>>
	EXP	B		;A
>


DISP2::	SNAMES
DISPC::	CNAMES		;CUSTOMER TABLE
DEFINE C(A,B,D,E,F) <
 IF2,<IFNDEF B,<EXTERN B>>
  IFG .-DISP-COMPIL+COMTAB,<
    IFDIF <B><CCLRUN>,<PRINTX ? B DOES NOT PRECEDE CCLRUN IN COMTAB>>
  IFLE .-DISP-COMPIL+COMTAB,<
	EXP	B		;A
>>


DISP::	NAMES


;AND ONE MORE FOR AN UNKNOWN COMMAND DISPATCH

COMERD::EXP	NOCOM##
;GENERATE TABLE OF UNIQUENESS BITS FOR SIXBIT COMMAND NAMES
DEFINE C(A,B,D,E,F)<
	EXP	D!E		;A
>

UNQTAB::NAMES
	EXP	NOCORE+NOJOBN+NOLOGIN+NOINCK ;UNKNOWN COMMAND DISPATCH

UNQTB2::SNAMES

UNQTBC::CNAMES
;GENERATE COMMAND DISPATCHES FOR USER DEFINED COMMANDS

DEFINE UCMDNM(NM,PR,AD,FL,UN,PV),<
  IFB  <AD>,<
    IFNB <PR>,<
      IFDIF <NM>,<PR>,<
        IFNDEF %'PR,<
%'PR:	MOVE	P2,[SIXBIT/PR/]
	JRST	RUNAME##
        >
	IFDEF	%'PR,<
          IFE	%'PR-.,<
%'PR:	MOVE	P2,[SIXBIT/PR/]
	JRST	RUNAME##
          >
        >
      >
    >
  >
>


	SPCCMD


	SALL
;TABLE OF PRIVILEGED CUSPS
;USED TO TURN ON JACCT WHEN R OR RUN COMMAND OR RUN UUO

PRVTAB::
LGONAM::SIXBIT	/LOGOUT/	;NAME FOR "LOGOUT" (TURN OFF JLOG TOO)
	SIXBIT	/LOGIN/
	SIXBIT	/REATTA/



	SIXBIT	/UMOUNT/
	SIXBIT	/DAEMON/

	SIXBIT	/SYSTAT/	;FOR PEEK UUO PRIVILEGE

IFN FTNET,<
				;FOR REMOTE SPOOLERS TO
	SIXBIT	/NETLDR/	;PREVENT ABUSE OF THIS CAPABILITY.
IFN FTKS10,<
	SIXBIT	/KDPLDR/	;KMC-11 MICRO-CODE LOADER TO RUN ON FRCLIN
>
>
IFN FTDN60,<			;IF WE HAVE A DN60...
	SIXBIT	/D60RTV/	; RETRIEVAL PGM MUST HAVE FULL FILE ACCESS
>
CCPNAM::EXP	M.CRSH		;AUTO CRASH COPY PROGRAM. (MAY BE CHANGED
				;WITH MONGEN BY DEFINING THE SYMBOL M.CRSH IN
				;THE SIXBIT DEFINITION SECTION TO BE THE NAME
				;OF THE PROGRAM TO RUN)
IFN M.ENET&M.KL10,<
	SIXBIT/KNILDR/		;KLNI MICROCODE LOADER
>

DEFINE UCMDNM(NM,PR,AD,FL,UN,PV),<
  IFNB <PV>,<EXP SIXBIT/PV/>
>

	SPCCMD			;GENERATE PRVTAB ENTRIES FOR USER

				;  DEFINED COMMANDS
IFN FTPATT,<0>			;SAVE A WORD FOR PATCHING OVER
PRVTBL==:.-PRVTAB			;NO.  OF PRIVILEGED CUSPS

DAASTH::
IFE M.NET!M.DECN,<		;IF NO NETWORK SUPPORT
	JSP	T1,ERRMES##	;CAN'T DO THESE IF NO NETWORK
	ASCIZ	|No network software|
> ;END IFN M.NET!M.DECN

IFN M.NET!M.DECN,<		;IF NETWORKS
	PUSHJ	P,SAVE4		;SAVE P1-P4
	PUSHJ	P,CTEXT1##	;GET NEXT ARGUMENT
	JUMPE	T2,NOTENF##	;IF NO ARGUMENT
	MOVE	T1,T2		;T1=NAME
	PUSHJ	P,CVTOCT##	;CONVERT IF NUMBER
	  JFCL			;MUST BE A NUMBER
IFN M.NET,<IFN M.DECN,<
	NETOFF			;INTERLOCK
	PUSHJ	P,SRCND0##	;SEARCH ANF TABLE
	  PJRST	HOST.D		;IF NOT FOUND
	NETON			;FREE INTERLOCK
>;END IFN M.DECN
	PJRST	HOST.A##	;ANF HOST
>;END IFN M.NET

IFN M.DECN,<
HOST.D:IFN M.NET,<NETON>
HOSTD0:
IFN FTXMON,<
	SNCALL	(SCTN2A##,MS.HGH) ;CONVERT NODE NAME TO NODE ADDRESS
>
IFE FTXMON,<
	DNCALL	SCTN2A##	;CONVERT NODE NAME TO NODE ADDRESS
>
	  JRST	[MOVE T1,NRTUNN## ;GET POINTER TO ERROR MESSAGE SAYING
		PJRST ERRMES##]	;NO SUCH NODE.
	MOVSI	T1,LTLNRT##	;LETS SEE IF WE ARE ALREADY NRTED IN
	SE1XCT	<TDNE T1,LDBTTW##(U)> ;AND DON'T ALLOW IT IF SO
	 JRST	[MOVEI T1,[	;NRTED IN, DON'T LET HIM NRT OUT
		ASCIZ \Cannot SET HOST to a DECnet node from a NRT line\]
		PJRST ERRMES##]	;&&ADD CODE HERE TO DISCONNECT LINE&&
	PUSHJ	P,FNDPDS##	;RESTORE W
	MOVE	P2,[SIXBIT /CTHNRT/] ;PROGRAM NAME
	MOVE	T1,JBTSTS(J)	;JOB STATUS WORD
	TLNN	T1,JLOG		;LOGGED IN
	SKIPE	STHFLG		; OR NOT REQUIRED
	PJRST	RUNAME##	;RUN NRT PROGRAM
	MOVEI	T1,LOGPLM##	;ELSE TYPE
	PJRST	ERRMES##	; "LOGIN PLEASE"
>
>

	$ABS
IFN FTKL10,<IFG CPUN-1,<
	LOC <.+777>&777000
>
CSHLAS==:.-1			;CACHE FROM CSHFIR TO HERE
>
	SUBTTL	UBA MAPPING REGISTER ASSIGNMENTS
IFN M.KS10,<

DEFINE XX (UBA,DEV,ADR,NUM),<
    IFNDEF UB'UBA'IMR,<UB'UBA'IMR==<7000000&ADR>+UBAEXP>
	DEV'IMR==:UB'UBA'IMR	;INITIAL MAPPING REGISTER
	DEV'IEA==:<DEV'IMR&77>*UBAMUL	;INITIAL PDP-11 ADDRESS
	DEV'MRC==:NUM	;NUMBER OF MAPPING REGISTERS
    IFG <<UB'UBA'IMR&77>+DEV'MRC-UBAPGS>,<
	DEV'MRC==:UBAPGS-<UB'UBA'IMR&77>
    >;IFG
	UB'UBA'IMR==UB'UBA'IMR+DEV'MRC
>;DEFINE XX

DEFINE X (DEV,ADR,NUM),<
IFN NUM,<
	Z=ADR/1000000
    IFLE Z,<PRINTX NONEXISTENT UBA FOR ADR>
	XX (\Z,DEV,ADR,NUM)
>;IFN NUM
>;DEFINE X

    IF1,<
	X RH1,RH11CA,UBAPGS	;DISK RH11
	X LP0,LP11CA,<2*LPTN>	;LP20
	X CD0,CD11BA,<2*CDRN>	;CD20
	X RH2,RH21CA,20		;TAPE RH11
	X KMC,KMC1BA,<KDLPPL*M.KDUP>	;KMC-11S DRIVING DUP-11S
	X DMR,DMR1BA,<DMRPPL*M.DMRN>	;DMR11 lines
	X RX2,RX21BA,<2*M.RX20>	;RX02s - 2 buffers per controller

	PURGE UB1IMR,UB3IMR
    >;IF1
>;IFN M.KS10
SUBTTL	COMMON -- CODE IN COMMON TO BUILD FEK'S

	FEKFST==:0		;START CHAIN OF FEKS BY ASSUMING
				;  THAT NO FEK'S WILL BE DEFINED

DEFINE FEKGEN(NAM,NM,TYPE,CPU,UNIT),<	;;MACRO TO LAY OUT FEK BLOCKS

;;ARGUMENTS ARE:
;;	NAM	3 CHARACTER GENERIC FEK TYPE (IE D8S)
;;	NM	3 CHARACTER "PARTICULAR" NAME FOR THIS FEK (IE "S01")
;;	TYPE	LEGAL NAME OF FEK (IE. NULL, KMCDUP DTE20 ...)
;;	CPU	NUMBER OF THE CPU THAT THIS FEK IS ON

;;FIRST VERIFY THAT THE FEK IS ONE OF A VALID TYPE
IFDIF <TYPE>,<NULL>,<
  IFDIF <TYPE>,<DL10>,<
    IFDIF <TYPE>,<DTE20>,<
      IFDIF <TYPE>,<KMCDUP>,<
	IFDIF <TYPE>,<DMR11>,<
	  IFDIF <TYPE>,<ENET>,<
	    PRINTX ? Illegal third argument TYPE to FEKGEN macro.?
	  >;DMR11
	>;DMR11
      >;KMCDUP
    >;DTE20
  >;DL10
>;NULL

DEFINE X(OFFSET,EXPR)<		;;MACRO TO SET SELECTED LOCATIONS IN THE BLOCK
	LOC NM'FEK+OFFSET	;;GO TO THE RIGHT WORD
	EXPR			;;ASSEMBLE IN THE EXPRESSION
>

  IFNDEF NAM'DSP,<EXTERNAL NAM'DSP> ;;RESOLVE DISPATCH VECTOR ADDRESS

  Q==0				;;DEFINE DEFAULT FEKBLK BITS
IFIDN <TYPE>,<NULL>,<
  Q==<FK.NUL!FK.ONL!FK.NID>	;;STATUS BITS FOR NULL FEK
>;NULL

NM'FEK::BLOCK	0		;;RESERVE STORAGE FOR THIS FEK

	X	FEKBLK,<XWD Q,FEKFST>	;;STATUS BITS AND LINK TO LAST FEK
	X	FEKDSP,<PUSHJ P,NAM'DSP>;;ONCE-ONLY CODE
	X	FEKUNI,<XWD CPU,UNIT>	;;XWD CPU,UNIT
	X	FEKHTM,<EXP 0>		;;INITIALIZE WITH HUNG TIME OF ZERO
	X	FEKIAD,<EXP 0>		;;NO INPUT BUFFERS (ADDRESS)
	X	FEKIDN,<EXP 0>		;;NO INPUT BUFFERS FILLED
	X	FEKBSI,<EXP -1>		;;INPUT IS IDLE
	X	FEKOAD,<EXP 0>		;;NO OUTPUT BUFFERS (ADDRESS)
	X	FEKOCT,<EXP 0>		;;NO OUTPUT BUFFERS (COUNT)
	X	FEKODN,<EXP 0>		;;NO EMPTY OUTPUT BUFFERS EITHER
	X	FEKBSO,<EXP -1>		;;OUTPUT IS IDLE

IFIDN <TYPE>,<DTE20>,<			;;IF THIS IS A DTE 20
	X	FEKIBP,<EXP 0>		;;WE HAVE NO INPUT BYTE POINTER
	X	FEKAKC,<EXP 0>		;;THE "ACK" INTERLOCK IS FREE
>

IFIDN <TYPE>,<ENET>,<
	X	FEKNIA,<EXP 0,0>	;;REMOTE ETHERNET ADDRESS
	X	FEKNIC,<EXP 0>		;;ETHERNET "CHANNEL" ID
	X	FEKNID,<EXP 0>		;;ETHERNET "PORTAL" ID
	X	FEKNIF,<EXP 0>		;;ETHERNET MASTER FEK ADDRESS
	X	FEKNIQ,<EXP 0>		;;ETHERNET INPUT PCBS QUEUED COUNT
	X	FEKNIS,<EXP 0>		;;ETHERNET NODEID SERIAL NUMBER
	X	FEKNIT,<EXP 0>		;;ETHERNET TIMERS
>

	LOC	NM'FEK+FEKLEN	;;GO TO THE END OF THE BLOCK
	FEKFST==:NM'FEK		;;REDEFINE THE "FIRST" FEK TO KEEP CHAIN ALIVE
	PURGE	X		;;UNDEFINE THE "X" MACRO
>;FEKGEN
SUBTTL	DN87 (ANF-10) AND DN60 (IBM) FEKS
	$ABS

;NOW DEFINE 4 HELPER MACROS.  ONE EACH FOR DN87(85), DC76, DN60 AND DN6S
;NOTE -- THESE FEKS MAY ONLY GO ON CPU #0.

DEFINE	FEK85(P),<		;;MACRO TO BUILD DN85 FEKS
  IRP P,<			;;FOR EACH ARGUMENT,
    IFE <TP.DL'P-TP.D85>,<	;;  IF THE -11 IS A DN85 (DN87),
      FEKGEN (D85,D8'P,DL10,0,0)	;;  THEN BUILD THE FEK, AND
      EXTERN D85INT>>>		;;  MAKE SURE THE SERVICE ROUTINE IS LOADED

DEFINE	FEK76(P),<		;;MACRO TO BUILD DC76 FEKS
  IRP P,<			;;FOR EACH ARGUMENT,
    IFE <TP.DL'P-TP.D76>,<	;;  IF THIS -11 IS SUPPOSED TO BE A DC76
      FEKGEN (D76,D8'P,DL10,0,0)	;;  THEN BUILD THE FEK, AND
      EXTERN D76INT>>>		;;  MAKE SURE THE SERVICE ROUTINE IS LOADED


DEFINE FEK60(P),<		;;MACRO FOR DN60 FEKS (DL-10 BASED IBM COMM)
  IRP P,<			;;FOR EACH POSSIBLE -11,
    IFE <TP.DL'P-TP.D60>,<	;;IF THIS -11 IS TO BE A DN60,
      FEKGEN (D60,D8'P,DL10,0,0)	;;  THEN BUILD IT'S FEK, AND
      EXTERN D60SER,D6DINT>>>	;;  MAKE SURE THE SERVICE ROUTINES ARE IN

;NOW ACTUALLY BUILD THE FEKS.

	FEK85 <0,1,2,3,4,5,6,7>	;;LEGAL FRONT ENDS FOR DN87(85) FEKS
	FEK76 <0,1,2,3,4,5,6,7>	;;LEGAL FRONT ENDS FOR DC76 FEKS
	FEK60 <0,1,2,3,4,5,6,7>	;;LEGAL FRONT ENDS FOR DN60 FEKS
IFN FTKL10,<
;NOW BUILD THE DN87S AND DN60S FEKS (DTE-20 BASED ANF AND IBM FRONT ENDS)
;NOTE -- THESE FEKS MAY BE ON ANY CPU.

DEFINE	FEK8S(CPX,DTX),<		;;MACRO TO BUILD DTE-BASED FEKS
  IFE <M'CPX'DTX'DTE-DT.ANF>,<		;;IF THIS IS AN ANF-10 DTE
    FEKGEN(D8S,S'CPX'DTX,DTE20,CPX,0)	;;  BUILD THE FEK (UNI SETUP LATER)
    EXTERN D8SINT>>			;;  AND FORCE LOADING OF D8SINT

DEFINE	FEK6S(CPX,DTX),<		;;MACRO TO BUILD DTE-BASED FEKS
  IFE <M'CPX'DTX'DTE-DT.IBM>,<		;;IF THIS IS AN IBM DTE
    FEKGEN(D6S,S'CPX'DTX,DTE20,0,0)	;;  BUILD THE FEK (UNI SETUP LATER)
    EXTERN D60SER,D6SINT>>		;;  AND FORCE LOADING OF IBM CODE

;NOW FOR ALL CPUS, FOR ALL DTES, BUILD THEIR FEKS

ZZ==0
REPEAT CPUN,<Z=0			;;FOR ALL CPUS,
    REPEAT 4,<				;;  FOR EACH DTE ON THIS CPU
	FEK6S(\ZZ,\Z)			;;  BUILD A FEK IF THERE IS AN -11
	FEK8S(\ZZ,\Z)			;;  BUILD A FEK IF THERE IS AN -11
	Z==Z+1>				;;STEP TO THE NEXT DTE
    ZZ=ZZ+1>				;;  AND STEP TO THE NEXT CPU
> ;IFN FTKL10
;Define the DMR11 FEKs
;Put them so they will be after the KDPs for FEK2LN
IFN M.DMRN,<
	EXTERN	D8RINT,DMRINT,DMRSER	;;  Load the service routines
 IFN M.DN6R,<
	EXTERN	D6RINT>			;; Load service routine for IBM

DEFINE FEK8R(N),<
	FEKGEN(D8R,DR'N,DMR11,0,DMR'N)>
ZZ==0

REPEAT M.DMRN,<
	FEK8R(\ZZ)
	ZZ==ZZ+1>
>;IFN M.DMRN

;DEFINE THE KMC/DUP-11 FEK'S
;FOR NOW, THE NAMES ARE JUST DK<NNM>FEK

IFN M.KDUP,<				;;IF THERE ARE KMC/DUP-11 FEK'S

DEFINE FEK8K(N),<			;;DEFINE A HELPER MACRO TO DEFINE FEK'S
    FEKGEN(D8K,DK'N,KMCDUP,0,KDL'N'PG)	;;  BUILD THE D8K FEK
    EXTERNAL D8KINT,KDPINT,KDPSER>	;;  AND FORCE LOADING

ZZ==0					;;COUNTER FOR FEK NUMBER
REPEAT M.KDUP,<				;;FOR ALL KMCDUP FEK'S
	FEK8K(\ZZ)			;;  BUILD THE FEK
	ZZ==ZZ+1>			;;  AND STEP TO THE NEXT

>;M.KDUP
;NOW THE ETHERNET PROTOTYPE (AND ETH-0 MASTER) FEK

IFN FTENET,<				;IF ETHERNET SERVICE AVAILABLE
  IFG M.ENET,<				;AND IT IS LOADED
    IFDEF ANFNIP,<			;AND USER HAS DEFINED ANF NI SERVICE
	FEKGEN(D8E,ET0,ENET,-1,0)	;THEN BUILD A PROTOTYPE ETHERNET FEK
	EXTERN D8EINT			;AND LOAD ANF'S ETHERNET FEK SERVICE
    > ;IFDEF ANFNIP
  > ;IFG M.ENET
> ;IFN FTENET




;BUILD THE "NULL" FEK.

IFN M.NET,<
	FEKGEN(NLF,NL0,NULL,-1,0)		;;GENERATE THE NULL FEK'S FEK
	EXTERN NULFEK			;;  AND LOAD THE SERVICE ROUTINE
>;M.NET
IFN FTNET!FTDN60,<
	$HIGH

IFN FTKL10,<
;GENERATE TABLE TO MAP FROM DTE AND CPU # TO FEK ADDRESS

DEFINE	FEKPNT(DTX,CPX),<
    ZZQ==0
    IFE	<M'CPX'DTX'DTE-DT.ANF>,<ZZQ==S'CPX'DTX'FEK>
    IFE	<M'CPX'DTX'DTE-DT.IBM>,<ZZQ==S'CPX'DTX'FEK>
    EXP ZZQ
>

DTEFEK::
Z==-4
REPEAT	CPUN,<
	CONC(<DTEFEX+>,\<Z==Z+4>,<(P1)>)
>

DTEFEX:
ZZ==0				;CPU INDEX
REPEAT	CPUN,<			;FOR ALL CPUS
    ZZZ==0			;DTE INDEX
    REPEAT 4,<			;FOR ALL DTE'S
	FEKPNT(\ZZZ,\ZZ)	;BUILD THE NEXT POINTER
	ZZZ==ZZZ+1>		;STEP TO THE NEXT DTE
    ZZ==ZZ+1>			;STEP TO THE NEXT CPU
>;END IFN FTKL10
>;END IFN FTNET!FTDN60
	SUBTTL	KDP BLOCKS FOR THE KMC-11/DUP-11
	$ABS

IFN M.KDUP,<			;ONLY ASSEMBLE IF WE HAVE KMC-DUPS

;SINCE THE KS-10 MAY HAVE AT MOST ONE KMC-11, THIS CODE DOES NOT
;  EASILY PROVIDE FOR MORE THAN ONE "KDP" BLOCK.

KDPTBL::EXP	KDP0		;WE ONLY HAVE ONE KDP(KMC)
KDPMAX==:0			;THE HIGHEST ONE IS "0"

DEFINE	X(OFFSET,VALUE),<	;;HELPER MACRO FOR FILLING IN KDP BLOCK
	LOC	KDP0+OFFSET	;;GO TO THE APPROIATE LOCATION IN THE BLOCK
	VALUE			;;AND ASSEMBLE IN THIS "VALUE"
>
DEFINE	XX(DUPN),<		;;HELPER MACRO FOR FILLING IN KDPKDL SUB-TABLE
	X(KDPKDL+DUPN,<XWD DK'DUPN'FEK,KDL'DUPN'PG>) ;; FILL IN FEK AND PAGE
>
;NOW LAY OUT THE KDP BLOCK
KDP0::	X(KDPCSR,<EXP KMC1BA>)	;CSR ADDRESS OF THE KMC-11
	X(KDPVEC,<EXP KMC1IV>)	;INTERRUPT VECTOR ADDRESS
	X(KDPIMR,<EXP KMCIMR>)	;ADDRESS OF INITIAL MAPPING REGISTER
	X(KDPIEA,<EXP KMCIEA>)	;INITIAL ELEVEN ADDRESS
	X(KDPDPN,<EXP M.KDUP>)	;NUMBER OF DUP-11'S ON THIS KMC
	X(KDP1DP,<EXP DUP1BA>)	;BASE ADDRESS OF THE FIRST DUP-11
	X(KDPNUM,<EXP 0>)	;NUMBER OF THIS KDP

Q==0				;NOW LOOP OVER ALL KDL(DUPS) START WITH ZERO
REPEAT M.KDUP,<
	XX(\Q)			;BUILD THE NEXT KDL ENTRY (XWD FEK,KDL)
	Q==Q+1			;STEP TO THE NEXT KDL
>				;LOOP UNTIL DONE
;NOW LAY OUT THE INTERRUPT ROUTINES (THEY LIVE IN THE KDP BLOCK)
	X(KDPIVA,<EXP 0>)	;VECTOR A.  JSR COMES HERE
	EXP	0		;SECOND WORD OF OLD PC
	EXP IC.UOU,EXP .+1	;NEW PC

	EXCH	T1,KDP0+KDPIVA	;SAVE T1, GET ADDR WE INTERRUPED OUT OF
	MOVEM	T1,KDPCHL	;PUT IT BACK WHER A POPJ WILL RETURN
	MOVE	T1,KDP0+KDPIVA+1;TWO WORD PC
	MOVEM	T1,KDPCHL+1	;SAVE FOR XJEN

	MOVE	T1,KDP0+KDPIVA	;GET T1 BACK
	JSR	KDPSVD		;GO SAVE THE AC'S
	MOVEI	W,KDP0		;LOAD W FOR D8KINT
	JRST	KDPAIV##	;GO TO THE INTERRUPT VECTOR "A" ROUTINE

	X(KDPIVB,<EXP 0>)	;VECTOR B.  JSR COMES HERE
	EXP	0		;SECOND WORD OF OLD PC
	EXP IC.UOU,EXP .+1	;NEW PC

	EXCH	T1,KDP0+KDPIVB	;SAVE T1, GET ADDR WE CAME FROM
	MOVEM	T1,KDPCHL	;SAVE ADDR FOR WHEN WE EXIT INTERRUPT
	MOVE	T1,KDP0+KDPIVB+1;TWO WORD PC
	MOVEM	T1,KDPCHL+1	;SAVE FOR XJEN

	MOVE	T1,KDP0+KDPIVB	;GET T1 BACK
	JSR	KDPSVD		;SAVE THE AC'S
	MOVEI	W,KDP0		;LOAD W FOR D8KINT
	JRST	KDPBIV##	;GO TO INTERRUPT VECTOR "B" CODE

	LOC	KDP0+KDPLEN	;SKIP OVER THE BLOCK
	PURGE	X,XX		;UNDEFINE THE "HELPER" MACROS
>;M.KDUP
IFE M.KDUP,<			;IF NO KDP'S
	TSTKDP==:CPOPJ		;DEFAULT KDP CHECK ROUTINE
	KDPSEC==:CPOPJ		;KDP ONCE/SECOND ROUTINE
	ZAPKDP==:CPOPJ		; KDP KILL ROUTINE
>
	SUBTTL	DMR Blocks for the DMR11 lines

IFE M.DMRN,<			;IF NO DMR'S
	TSTDMR==:CPOPJ		;DEFAULT DMR CHECK ROUTINE
	DMRSEC==:CPOPJ		;DMR ONCE/SECOND ROUTINE
	ZAPDMR==:CPOPJ		;DMR KILL ROUTINE
>
IFN M.DMRN,<
	DEFINE	X(N),<EXP	DMR'N>
ZZ==0
DMRTBL::REPEAT	M.DMRN,<
	X(\ZZ)
	ZZ==ZZ+1>

	DEFINE	X(N,OFFSET,VALUE),<;;Standard macro
	LOC	DMR'N+OFFSET
	VALUE>

	DEFINE	XX(N,FT,DEF),<
IFNDEF DMR'N'FT,<DMR'N'FT==<DEF>>
IFN DMR'N'FT,<ZZZ==ZZZ+DMRS'FT>>

	DEFINE $DMR(N),<
DMR'N::	X(N,DMRUSR,<EXP	M.'N'DMR>)	;;Initial use of this line
	X(N,DMRCSR,<EXP	DMR1BA+<N*10>>)	;;CSR address of this DMR
	X(N,DMRVEC,<EXP	DMR1IV+<N*10>>)	;;Vector
	X(N,DMRMAP,<EXP DMRIMR+<N*DMRPPL>>)	;;UBA mapping register address
	X(N,DMREAD,<EXP	DMRIEA+<N*UBAMUL*DMRPPL>>) ;;11 address of this DMR's com region
	X(N,DMRTAD,<EXP	DMR'N'PG>)	;;10 address of this DMR's com region
	X(N,DMRLIN,<XWD	M.KDUP+N,N>)	;;Line # on node,,DMR #
	X(N,DMRIVA,<EXP 0>)		;;Vector "A" Interrupt header
		EXP	0,IC.UOU,.+1	;;This is an XPCW block
		EXCH	T1,DMR'N+DMRIVA	;;GET INTERRUPT PC
		MOVEM	T1,DMRCHL	;;SAVE FOR DMRSVD
		MOVE	T1,DMR'N+DMRIVA+1;;GET SECOND WORD OF PC
		MOVEM	T1,DMRCHL+1	;;SAVE IT TOO

		MOVE	T1,DMR'N+DMRIVA	;;Restore T1
		JSR	DMRSVD		;;Get our AC block
		MOVEI	W,DMR'N		;;Point to this DMR block
		MOVE	F,DMRTAD(W)	;; and communications page
		JRST	DMRAIV##	;;Process interrupt
	X(N,DMRIVB,<EXP 0>)		;;Vector "B" Interrupt header
		EXP	0,IC.UOU,.+1	;;This is an XPCW block
		EXCH	T1,DMR'N+DMRIVB	;;GET INTERRUPT PC
		MOVEM	T1,DMRCHL	;;SAVE FOR DMRSVD
		MOVE	T1,DMR'N+DMRIVB+1;;GET SECOND WORD OF PC
		MOVEM	T1,DMRCHL+1	;;SAVE IT TOO

		MOVE	T1,DMR'N+DMRIVB	;;Restore T1
		JSR	DMRSVD		;;Get our AC block
		MOVEI	W,DMR'N		;;Point to this DMR block
		MOVE	F,DMRTAD(W)	;; and communications page
		JRST	DMRBIV##	;;Process interrupt
	ZZZ==0
	XX(N,HD,0);;Default HDX setting
	XX(N,SW,0);;Default switched line setting
	XX(N,LS,1);;Default Long start select
	XX(N,MT,0);;Default maintenance mode
	X(N,DMRSTS,<EXP	ZZZ>)		;;Initial status
	X(N,DMRFEK,<EXP	DR'N'FEK>)	;;Address of our FEK
	X(N,DMRLEN,<BLOCK 0>)
	>;Define $DMR

ZZ==0
REPEAT M.DMRN,<
	$DMR(\ZZ)
	ZZ==ZZ+1>
	PURGE	X,$DMR,XX,ZZZ
>;IFN M.DMRN
SUBTTL	MUUO PROCESSING

	$HIGH
MUUO:	EXECAC			;EXEC ACS
	JRSTF	@[XWD XC.UOU,.+1];HAVE TO DO THIS BY HAND
	MOVE	T1,.USMUO	;GET THE MUUO PC FLAGS
	MOVE	R,.CPADR
	TLNN	T1,(XC.USR)	;WAS THE MUUO DONE IN USER MODE?
	JRST	UUOSY1##	;NO, DISPATCH TO EXEC MODE MUUO HANDLER
	JUMPE	R,MUUO1		;IS THERE A JOB DATA AREA FOR THE JOB DOING THE UUO?
				;NO, MUST BE THE DOORBELL OR ERROR IN THE
				; NULL JOB
	AOS	.CPTUC		;ACCUMULATE THE NUMBER OF UUOS ON THIS CPU
	SKIPN	P,.USEPL	;USE EXTENDED PDL IF THERE IS ONE
	MOVE	P,[XWD MJOBPD##,.JDAT+JOBPDL##]
	MOVEI	F,0		;FLAG NO DDB IN CASE ILLEGAL UUO
	MOVE	J,.CPJOB	;JOB NUMBER OF CURRENT JOB
	JRST	UUOSY1##	;DISPATCH TO MUUO HANDLER
MUUO1:	HRLZ	T1,.USMUO
	IOR	T1,.USMUE
	CAME	T1,WAKINS##	;DOORBELL CALLI
	STOPCD	.+1,STOP,UNJ,	;NO, ILLEGAL NULL JOB UUO
MUUO1A:
IFN FTMP,<
	AOS	.CPNDB		;COUNT NUMBER OF DOORBELLS
	MOVE	P,.CPNPD
	JRSTF	@[IC.UOU+.+1]
	MOVE	T1,.CPQPC
	TDNN	T1,DOORBL
	JRST	MUUO1B
	ANDCAM	T1,DOORBL
	PUSHJ	P,DSKTIC##
	PUSHJ	P,TAPTIC##
IFN FTKL10,<
	PUSHJ	P,KNITIC##	;KLNI QUEUED I/O
>; END IFN FTKL10
IFN FTSCA,<
	PUSHJ	P,PPDTIC	;KLIPA QUEUED I/O
>; END IFN FTSCA
MUUO1B:	MOVE	T1,.CPSCC
	TDNN	T1,DOORBL
	JRST	[USERAC
	 	XJEN	.USMUO]
	ANDCAM	T1,DOORBL
>
	DMOVE	T1,.USMUO
	DMOVEM	T1,.CPPC
	JRST	CLKSPD##	;DISPATCH TO THE SCHEDULAR SINCE SOME
				; JOB IS POSSIBLY NOW RUNNABLE ON THIS CPU
UMPRET::			;HERE ON RETURN FROM MUUO PROCESSING
	POP	P,.USMUP	;RESTORE THE MUUO PC
	POP	P,.USMUO	;RESTORE FLAGS

IFN	FTHPQ,<
	SKIPGE	SCDRTF		;HPQ JOB WAKE UP AND IN CORE?
	  PUSHJ	P,USCHD1##	;YES
>
	USERAC			;RESET USER AC BLOCK
	XJEN	.USMUO

	$LIT			;FORCE LITERALS INTO THE HIGH SEGMENT
SUBTTL	APR INTERRUPTS
;DEFINE MACRO TO CALL KL OR KI OR KS CODE FOR EACH CPU
DEFINE KILS(N)<
IFN	M.KL10,<KL(N)>
IFN	M.KS10,<KS(N)>
>				;END KILS MACRO DEF

	$ABS
;HERE TO TRY TO CONTINUE THE SYSTEM AFTER A CLOCK ERROR STOP
IFN M.KL10,<
APRWRS::EXECAC			;GET CORRECT AC SET
	CONO	APR,200000	;CLEAR THE WORLD (ACTUALLY, RSX20F ALREADY DID)
	CONO	PI,CLRPIS
	CONO	PAG,0
	JSP	T4,SYSTR0	;SETUP PAGING, FIND OUT WHAT CPU WE ARE
	  JFCL			;DON'T CARE WHETHER BOOT OR NOT
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	MOVEI	P,WRSPTB-1(T1)	;SETUP A VERY SHORT STACK
	LSH	T1,1		;DOUBLE WORD PC
	LDB	T2,[POINT 18,WRSLOC(T1),35] ;CODE FOR RESTART
	DMOVE	T3,WRSLOC(T1)	;GET DOUBLE WORD PC
	DMOVEM	T3,@.CPKAF	;STORE IN KAF LOC

	CAIN	T2,.WRKAC	;IF KAF, REPORT AS SUCH
	JRST	KAFSTP
	CAIE	T2,.WRPTO	;IF PROTOCOL TIMED OUT, CAN'T RECOVER
	TLNN	T3,(XC.USR)	;PC IN USER MODE?
	STOPCD	.,CPU,WRF,WRSF	;++WARM RESTART FAILED
	SKIPN	J,.CPJOB	;NULL JOB RUNNING?
	JRST	SPRINI		;YES, JUST RESTART IT
	HRRZ	T1,JBTUPM(J)	;USER PROCESS TABLE
	HRRM	T1,@.CPSPT	;SETUP SPT

	TLO	T1,(LG.LUB)	;LOAD USER BASE REGISTER
	DATAO	PAG,T1		;ZAP, ADDRESSABLE
	MOVE	P,[MJOBPD##,,.JDAT+JOBPDL##] ;ESTABLISH A USER CONTEXT STACK
	PUSH	P,T3		;SAVE FLAGS

	PUSH	P,T4		;AND PC
IFN FTMP,<
	SETZM	.CPNBI		;SINCE ESSENTIALLY STARTING OVER, NO BROKEN INTERLOCKS
>;END IFN FTMP
	PUSHJ	P,SETCLK	;SETUP CLOCKS, APR, AND PI
	PUSHJ	P,ENTSPC##	;ENTER SECONDARY PROTOCOL, MAKE SURE 20F IN SAME STATE
	PUSHJ	P,STAPPC##	;NOW, START PRIMARY PROTOCAL
	STOPCD	.,JOB,WRJ,WRSF	;++WARM RESTART GOT JOB

;HERE TO PRINT WARM RESTART CODE

WRSF:	PUSHJ	P,INLMES##	;TELL WHAT'S BEING REPORTED
	ASCIZ	/code = /
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	LSH	T1,1		;TIMES 2
	LDB	T1,[POINT 18,WRSLOC(T1),35] ;WARM RESTART CODE
	PJRST	PRTDI8##	;REPORT IT

WRSPTB:	REPEAT	CPUN,<
	BLOCK	1		;VERY SHORT PDL TO USE DURING WARM RESTART
>
	LIT
>	;END IFN M.KL10

KAFSTP:	STOPCD	.,CPU,KAF,		;++KEEP ALIVE FAILURE

IFN M.KL10,<
IOPSTP:	STOPCD	.,CPU,IOP,		;++I/O PAGE FAILURE
>
	$HIGH
;DEFINE KL10 APR INTERRUPT HANDLER
; IT CALLS CPU INDEPENDENT CODE AS SOON AS POSSIBLE

DEFINE	KL(N)<

;HERE ON OPERATOR CONTINUE AFTER POWER FAILURE, IO PAGE FAIL, WATCH DOG TIMER RUNOUT,
AP'N'CPF: CONO	APR,LP.CSF+LP.SBE+LP.NXM+LP.PAR+LP.IOF+LP.PWF
				;CLEAR AUTO RESTART ENABLE, ENABLE CLOCK INT., CLEAR
				; IO PAGE FAIL, CLEAR NON EX MEM

;HERE ON APR CHANNEL INTERRUPT
AP'N'INT: CONSO	APR,@.C'N'CON	;INTERRUPT FOR APR (MONITOR OR USER ENABLED)
	JRST	.-1		;NO, TRY NEXT DEVICE ON THIS PI CHANNEL
	CONSO	APR,LP.CSD
	JRST	AP'N'IN1
	CONO	APR,LP.CSF+LP.CSD+AP'N'CHN
	AOS	.CPCSN
	EXCH	T1,.CPSCS
	IORM	T1,DOORBL
	EXCH	T1,.CPSCS
	XJEN	AP'N'CHL

AP'N'IN1: CONSZ	APR,LP.NXM!LP.CDP!LP.ADP!LP.SBE!LP.PAR!LP.PWF!LP.IOF	;TIMER TIMEOUT,
				; MEM PAR, POWER FAIL, ADDRESS BREAK, IO PAGE FAIL?
	JRST	AP'N'UNS	;YES, GO PROCESS UNUSUAL INTERRUPTS
AP'N'IN2::
	DMOVEM	P,.C'N'SP	;SAVE AC P

AP'N'CLK:
IFE N,<	SKIPN	CLKDDT		;IS 21 NON-ZERO
	JRST	CLKDDR		;NO--PRECEED
	SETZM	CLKDDT		;CLEAR FLAG
	XCT	SYSDDT		;GO TO EDDT IF POSSIBLE
CLKDDR::>
	MOVE	P,AP'N'PDP	;SET TO PD LIST FOR THIS CPU
	PUSH	P,P4		;SAVE P4
	PUSHJ	P,APRSUB##	;GO PROCESS INTERRUPT
	MOVE	P4,(P)		;RESTORE P4
AP'N'EPF:
	DMOVE	P,.C'N'SP	;RESTORE P

AP'N'EXT: CONO	APR,AP'N'CHN  ;SET APR PI
	XJEN	AP'N'CHL


;HERE TO PROCESS UNUSUAL INTERRUPTS
AP'N'UNS: CONSZ	APR,LP.PWF	;POWER FAIL?
	JRST	AP'N'PWF	;YES, GO SETUP FOR AUTO-RESTART
	CONSZ	APR,LP.ADP!LP.CDP!LP.IOF ;ADDRESS OR CACHE DIRECTORY PARITY?
	JRST	AP'N'NHT	;GO DO DIAG INST'S AND HALT
	CONSZ	APR,LP.NXM	;NXM?
	JRST	AP'N'NXM	;YES, DO SPECIAL STUFF ON KL
	CONSZ	APR,LP.PAR	;NO--MB PARITY ERROR?
	JRST	AP'N'IN2	;YES, GO PROCESS
	CONSZ	APR,LP.SBE	;SBUS ERROR?
IFE M.MOS,<
	JRST	AP'N'NHT	;YES, JUST DO DIAG INST'S AND HALT
	JRST	AP'N'EXT	;DISMISS INTERRUPT
>
IFN M.MOS,<
	JRST	[CONO APR,LP.CSF+LP.SBE ;CLEAR SBUS ERROR EARLY IN CASE OF SINGLE BIT
		 MOVEM P,.CPSP	; ERROR IN ERROR ANALYSIS CODE
		 MOVE P,AP'N'PDP;SETUP A PUSH DOWN LIST
		 PUSHJ P,SBERR##;DO ERROR ANALYSIS AND RECORD ERRORS FOR THGA
		 MOVE P,.CPSP	;RESTORE P
		 JRST AP'N'EXT]	;EXIT INTERRUPT
>
;HERE ON NXM - CLEAR MB PARITY ERROR AND SBUS ERROR, SWEEP CACHE
AP'N'NXM:: CONO	APR,LP.CSF!LP.PAR!LP.SBE  ;CLEAR ALL BUT INTERESTING STUFF
	SWPUA			;SWEEP THE CACHE SINCE NXM LEAVES
				; BAD PARITY IN CACHE
	CONSZ	APR,LP.CSB	;WAIT FOR FINISH
	JRST	.-1
	JRST	AP'N'IN2	;GO DO A NXM THING

;HERE TO HALT ON APR ERROR CONDITION--DO SBDIAG AND RDERA FIRST
AP'N'NHT:MOVEM	P,.C'N'SP	;GET A VALID PDL
	MOVE	P,AP'N'PDP
	CONSZ	APR,LP.IOF	;IO PAGE FAILURE?
	JRST	IOPSTP		;YES, GO HALT
	RDERA	.C'N'AER	;READ ERA INTO CPU DATA BLOCK
	CONI	APR,.C'N'AEF	;SAVE CONI APR,
	SBDIAG	.C'N'SB0	;GET SBDIAG FUNCTIONS 1+2
	SBDIAG	.C'N'SB1	;
	SWPUA			;CACHE SWEEPS SO WE CAN SEE DATA
	CONSZ	APR,LP.CSB
	JRST	.-1
	CONSZ	APR,LP.SBE	;SBUS ERROR?
	STOPCD	.,CPU,SB'N,	;++SBUS ERROR ALONE
	CONSZ	APR,LP.CDP	;CACHE DIR. PAR.?
	STOPCD	.,CPU,CD'N,	;++CACHE DIRECTORY PARITY ERROR
				;MUST BE ADDR PARITY ERROR
	STOPCD	.,CPU,AD'N,	;++ADDR. PARITY ERROR

;KL10 INTERVAL TIMER INTERRUPT HANDLER
	$ABS

TM'N'INT::0
	0
	EXP	IC.UOU
	EXP	TM'N'IN0


;KL10 KEEP-ALIVE FAILURE TRAP HANDLER

AP'N'KAF:0
	0
	EXP	IC.UOU
	EXP	AP'N'KA0
AP'N'KA0:
	MOVEM	P,KF'N'SVP	;;SAVE P
	MOVEI	P,KF'N'PDL-1	;;SETUP NEW P
	JRST	KAFSTP		;;GIVE STOPCD
KF'N'PDL:BLOCK	1
KF'N'SVP:BLOCK	1		;;SAVE P HERE


	EPLLEN==:20
EP'N'PDL::
	BLOCK	EPLLEN		;;FIRST WORD IS "P" OF OVERFLOW
	$HIGH
TM'N'IN0:
	SKIPE	CRSHWD		;OPR DEPOSIT 30 NON-ZERO?
	JRST	SYSCRH		;YES, TAKE CRASH DUMP
IFN FTMP,<
IFG <CPUN-1>,<
	SKIPE	CPNDDT		;ANY CPU HIT A BREAKPOINT?
	JRST	CPNBPT##	;YES, WAIT FOR IT
>>
AP'N'BCK::
	DMOVEM	P,.C'N'SP	;SAVE P
	DMOVE	P,TM'N'INT	;STORE PC
	DMOVEM	P,@.C'N'CHL	;SAVE AT APR PI CHANNEL JSR ADDRESS

	MOVSI	P,(ST.CYC)	;50 HZ POWER?
	TDNE	P,STATES	;SKIP IF NO
	JRST	[MOVEI	P,^D2000 ;50HZ, SO SETUP 20000 USECS
		 JRST	TM'N'IN1] ;AND SET THAT AS NEW INTERVAL
	MOVEI	P,^D1666	;60HZ, SO ASSUME LEAP JIFFY
	AOSG	.C'N'TCT	;COUNT TRIAD COUNTER (-1,0,1)
	AOJA	P,TM'N'IN1	;NOT LEAP TICK UNLESS TRIAD COUNT IS 1
	SETCMM	.C'N'TCT	;COUNT REACHED 1, SET BACK TO -2
TM'N'IN1:CONO	TIM,TO.CTD!TO.SIT(P)	;SET INTERVAL OF TIMER AGAIN
	SETOM	.C'N'TIM	;SOFTWARE CLOCK FLAG FOR KL'S
	JRST	AP'N'CLK	;GO JOIN MAIN STREAM OF EVENTS
AP'N'PWF:CONI	PI,AP'N'PD1+1	;SAVE STATE OF PI SYS
	CONO	PI,PI.OFF	;TURN OFF INTERRUPTS
	MOVEM	P,.C'N'SP	;SAVE P
	MOVE	P,.CPEBR	;GET CURRENT EBR
	ANDI	P,-1-<LG.CSL!LG.CSW> ;TURN OFF CACHE
	CONO	PAG,(P)		;...
	SWPUA			;SWEEP CACHE
	CONSZ	APR,LP.CSB
	JRST	.-1
	DATAI	PAG,AP'N'PD1+2	;SAVE UBR, CURRENT, PREVIOUS AC BLKS
	CONI	MTR,AP'N'PD1+3
	MOVE	P,.C'N'SP
	JSR	.CPSVA		;SAVE ALL AC SETS
	MOVSI	P,(JRST)
IFN FTMP,<
	HLLM	P,.CPRES
>
IFE FTMP,<
	HLLM	P,ARSLOC
>
	MOVE	P,AP'N'PDP	;GET A STACK
	ADJSP	P,4		;SKIP WORDS WE STORE JUNK IN
	PUSHJ	P,DTEPWF##	;TELL F.E. WE HAVE A POWER FAILURE
	MOVEI	17,700000
	SOJG	17,.		;MAKE SURE POWER HAS FAILED
	JRST	APRRES		;IT HASN'T
AP'N'RES:SWPIA			;CLEAR OUT CACHE
	CONSZ	APR,LP.CSB
	JRST	.-1
	CONO	PAG,@.CPEBR	;TURN ON CACHE, TRAP ENABLE
	MOVEM	P3,@.CPSPT	;RESTORE SPT
	MOVE	P,AP'N'PD1+1	;GET CONI PI WORD
	ANDI	P,377		;JUST SYS ON, OFF AND CHANNELS ON, OFF
	CONO	PI,PI.TNP(P)	;TURN ON CHANNELS AND SYS, IF IT WAS ON BEFORE
	MOVE	P,AP'N'PD1+2	;GET UPT INFO
	TRO	P,LG.IAM	;INHIBIT UPDATING OF ACCOUNTING METERS
	DATAO	PAG,P		;RESTORE UBR FOR METERS
	MOVE	P,AP'N'PD1+3	;GET CONI MTR,
	CONO	MTR,MO.LAC(P)	;LOAD ACCOUNTING CONTROL, PI
	MOVSI	P,(HALT)
IFN FTMP,<
	HLLM	P,.CPRES
>
IFE FTMP,<
	HLLM	P,ARSLOC
>
	MOVE	P,AP'N'PDP	;GET A STACK
	ADJSP	P,4		;SKIP WORDS WE STORE JUNK IN
	PUSHJ	P,DTEPFC##	;RE-ESTABLISH PRIMARY PROTOCOL
	JSP	T4,ZAPICH	;PUT INTERNAL CHANNELS BACK TOGETHER
	PUSHJ	P,DSKRCL	;CAUSE HOME BLOCKS TO BE REREAD
	RESTOR	(0,.CPCAC)
	RESTOR	(1,.CPCA1)
	RESTOR	(2,.CPCA2)
	RESTOR	(3,.CPCA3)
	RESTOR	(4,.CPCA4)
	CONO	TIM,TO.CTD!TO.CIT!TO.SIT!^D1667
	DATAO	PAG,AP'N'PD1+2
	CONO	APR,AP'N'NUL	;CLEAR POWER FAIL, ENABLE FOR GOOD STUFF
	JRST	AP'N'EXT	;BYE.
> ;END KL10 MACRO
;DEFINE KS10 APR INTERRUPT HANDLER
; IT CALLS CPU INDEPENDENT CODE AS SOON AS POSSIBLE

DEFINE	KS(N)<

;HERE ON OPERATOR CONTINUE AFTER POWER FAILURE, IO PAGE FAIL, WATCH DOG TIMER RUNOUT,
AP'N'CPF: WRAPR	SP.CSF+SP.NXM+SP.HMP+SP.SMP+SP.PWF
				;CLEAR NXM, HARD & SOFT PARITY, POWER FAILURE

;HERE ON APR CHANNEL INTERRUPT
AP'N'INT::CONSO	APR,@.C'N'CON	;INTERRUPT FOR APR (MONITOR OR USER ENABLED)
	JRST	.-1		;NO, TRY NEXT DEVICE ON THIS PI CHANNEL
	SKIPE	CRSHWD		;OPR DEPOSIT 30 NON-ZERO?
	JRST	SYSCRH		;YES, TAKE CRASH DUMP
AP'N'BCK::CONSZ	APR,SP.NXM!SP.HMP!SP.PWF ;NXM, HARD PARITY OR POWER FAIL?
	JRST	AP'N'UNS	;YES, GO PROCESS UNUSUAL INTERRUPTS
AP'N'IN2::MOVEM	P,.C'N'SP	;SAVE AC P
	CONSO	APR,SP.ITI	;CLOCK TICK?
	JRST	AP'N'IN3	;NO, PROCEED
	MOVSI	P,(ST.CYC)	;50 HZ POWER?
	TDNE	P,STATES	;SKIP IF NO
	JRST	[MOVEI	P,<^D20> ;50HZ, SO SETUP 20 MILLISECS
		 JRST	TM'N'IN1] ;AND SET THAT AS NEW INTERVAL
	MOVEI	P,<^D16>	;60HZ, SO ASSUME LEAP JIFFY
	AOSG	.C'N'TCT	;COUNT TRIAD COUNTER (-1,0,1)
	SKIPA	P,[<^D17>] 	;NOT LEAP TICK UNLESS TRIAD COUNT IS 1
	SETCMM	.C'N'TCT	;COUNT REACHED 1, SET BACK TO -2
TM'N'IN1:ADDM	P,.C'N'LMC	;ADD THIS INTERVAL TO LEAP MSEC COUNT
	SKIPL	.C'N'LMC	;IS IT STILL NEGATIVE?
	ADDI	P,1		;NO--IT'S TIME FOR A LEAP MSEC
	LSH	P,<^D12>	;SHIFT TO LOAD INTO TIMER REGISTER
	WRINT	P		;SET INTERVAL OF TIMER AGAIN
	WRAPR	SP.CSF!SP.ITI	;CLEAR INTERVAL TIMER INTERRUPT FLAG
	SETOM	.C'N'TIM	;SET SOFTWARE CLOCK TICK FLAG
	SKIPGE	P,.C'N'LMC	;IS THIS A LEAP MSEC?
	JRST	TM'N'IN2	;NO--GO ON
	ADD	P,[-^D1024]	;YES--COMPUTE NEXT LEAP MSEC COUNT
	MOVEM	P,.C'N'LMC	;RESET IT
TM'N'IN2:SKIPN	CLKDDT		;IS 21 NON-ZERO
	JRST	CLKDDR		;NO--PROCEED
	SETZM	CLKDDT		;CLEAR FLAG
	XCT	SYSDDT		;GO TO EDDT IF POSSIBLE
CLKDDR::
AP'N'IN3::MOVE	P,AP'N'PDP	;SET TO PD LIST FOR THIS CPU
	PUSHJ	P,APRSUB##	;GO PROCESS INTERRUPT
	MOVE	P,.C'N'SP	;RESTORE P
AP'N'EXT:WRAPR	AP'N'CHN	;SET APR PI
	XJEN	AP'N'CHL	;DISMISS INTERRUPT
;HERE TO PROCESS UNUSUAL INTERRUPTS
AP'N'UNS: CONSZ	APR,SP.PWF	;POWER FAIL?
	JRST	AP'N'PWF	;YES, GO SETUP FOR AUTO-RESTART
	CONSZ	APR,SP.NXM!SP.HMP ;NXM OR PARITY ERROR?
	JRST	AP'N'IN2	;YES--GO PROCESS IT
	JRST	AP'N'EXT	;DISMISS INTERRUPT

	DEFINE ZERO(X),<
	EXECAC	(X)
	SETZ	0,
	MOVEI	17,1
	BLT	17,17
>
AP'N'PWF:RDPI	AP'N'PD1+1	;SAVE STATE OF PI SYS
	WRPI	PI.OFF		;TURN OFF PI'S
	RDUBR	AP'N'PD1+2	;SAVE UBR, CURRENT, PREVIOUS AC BLKS
	RDTIME	AP'N'PD1+3	;SAVE TIME BASE
	JSR	.CPSVA		;SAVE ALL AC SETS
	MOVE	P,[JRST APRRES]	;POWER FAIL AUTO RESTART INTSTRUCTION
	MOVEM	P,ARSLOC	;SET IT UP
	HALT			;STOP
				;FE RESTARTS US AT 70 WHICH EVENTUALLY
				; GETS US HERE
AP'N'RES:WRUBR	AP'N'PD1+2	;RESTORE UBR AND AC BLOCKS IN USE
	SETZ	0,		;CLEAR CURRENT AC BLOCK FOR USE
	MOVEI	17,1		;...
	BLT	17,17		;...
	MOVEI	P,AP'N'PD1+5	;GET A STACK
	PUSHJ	P,UBAPIS	;RESET UBA'S
	MOVE	T1,AP'N'PD1+1	;GET CONI PI WORD
	ANDI	T1,377		;JUST SYS ON, OFF AND CHANNELS
	WRPI	PI.TNP(T1)	;RESTORE PI SYSTEM
	MOVEI	T1,<^D16>B23	;RESTART INTERVAL TIMER
	WRINT	T1		;SET IT
	MOVE	T1,[HALT ARSLOC];HALT AT 70 INSTRUCTION
	MOVEM	T1,ARSLOC	;DISABLE 70 RESTART
	MOVE	U,OPRLDB	;OPR'S LDB
	MOVEI	T1,[ASCIZ /
%Power fail restart
/]
	PUSHJ	P,CONMES##	;ANNOUNCE RESTART
	PUSHJ	P,ENAKAL##	;ENABLE KEEP ALIVE FUNCTION
	PUSHJ	P,DSKRCL	;CAUSE HOME BLOCKS TO BE REREAD
	RESTOR	(0,.CPCAC)	;RESTORE AC'S
	RESTOR	(1,.CPCA1)
	RESTOR	(2,.CPCA2)
	RESTOR	(3,.CPCA3)
	RESTOR	(4,.CPCA4)
	ZERO	(5)		;CLEAN OUT REST OF AC BLOCKS
	ZERO	(6)
	ZERO	(7)
	WRUBR	AP'N'PD1+2	;RESTORE UBR AND AC BLOCKS IN USE
	WRTIME	AP'N'PD1+3	;RESTORE TIME BASE
	WRAPR	AP'N'NUL	;CLEAR POWER FAIL, ENABLE FOR GOOD STUFF
	JRST	AP'N'EXT	;BYE.

;KS10 KEEP-ALIVE FAILURE TRAP CODE
	$ABS
AP'N'KAF:EXP	0,0,IC.UOU,AP'N'KA0
AP'N'KA0:MOVEM	P,KF'N'SVP
	MOVEI	P,KF'N'PDL-1
	JRST	KAFSTP
KF'N'PDL:BLOCK	1
KF'N'SVP:BLOCK	1

	EPLLEN==:10
EP'N'PDL::
	BLOCK	EPLLEN		;;FIRST WORD IS "P" OF OVERFLOW

	$HIGH


;ROUTINE TO SET UP PI ASSIGNMENTS ON UBA'S
UBAPIS::PUSHJ	P,SAVT		;SAVE T REGS
	MOVE	T1,[1,,UNBSTW]	;UBA #1 STATUS REGISTER
	PUSHJ	P,UBGOOD##	;IS UBA #1 THERE?
	  JRST	UBAPI0		;NO--SO DON'T TRY TO INIT IT
	MOVSI	T2,1		;UBA #1
	MOVEI	T1,UBINIT	;UNIBUS INIT
	WRIO	T1,UNBSTW(T2)	;DO IT
	MOVEI	T1,UBA1PI	;UBA #1 PI
	IORI	T1,UNBDTR	;SET DISABLE XFER BIT
	WRIO	T1,UNBSTW(T2)	;SET UP AND INIT UBA #1
UBAPI0:	MOVE	T1,[3,,UNBSTW]	;UBA #3 STATUS REGISTER
	PUSHJ	P,UBGOOD##	;IS UBA #3 THERE?
	  POPJ	P,		;NO--SO DON'T TRY TO INIT IT
	MOVSI	T2,3		;UBA #3
	MOVEI	T1,UBINIT	;UNIBUS INIT
	WRIO	T1,UNBSTW(T2)	;DO IT
	MOVEI	T1,UBA3PI	;UBA #3 PI'S
	IORI	T1,UNBDTR	;SET DISABLE XFER BIT
	WRIO	T1,UNBSTW(T2)	;SET UP AND INIT UBA #3
	POPJ	P,		;RETURN
>;END KS10 MACRO
;GENERATE APR INTERRUPT CODE DEPENDING ON CPUN AND KI VS KL VS KS
ZZ==0
REPEAT CPUN,<				;NO OF CPUS IN SYSTEM
	KILS(\ZZ)			;GENERATE INTERRUPT CODE
	ZZ==ZZ+1			;STEP TO NEXT CPU NUMBER
>
	$ABS
SUBTTL EXTERNS TO FORCE LIBRARY LOADING

	$HIGH

;GENERATE EXTERNAL GLOBALS TO CAUSE LOADING OF PROPER ROUTINES FROM
; MONITOR LIBRARY TAPE IF THERE IS ONE


;ALWAYS LOAD CLOCK1,COMCON,CORE1,ERRCON,JOBDAT,ONCE,PATCH,UUOCON,DATMAN,TMPUUO,
; AND EITHER KLSER OR KISER

IFN FTMPFH,<
EXTERNAL PFH
>
EXTERNAL VMSER,VMDTJB
IFE M.KL10,<
	XP	DTE.,CPOPJ	;NO DTE. UUO
>
IFN M.KL10,<
EXTERNAL KLSER,DTESER,TTDINT,FEDSER
IFN M.MOS,<
EXTERNAL MOSSER
>
>
IFN FTMOS,<
IFE  M.MOS & FTKL10,<
	XP	MOSMIN,CPOPJ	;NO MOS TO CHECK 
>
>
IFN M.KS10,<
EXTERNAL KSSER
>
IFE FTSCA,<
	XP	SCSRST,CPOPJ
SCSPSI::SETZ	T2,
	POPJ	P,
>; END IFE FTSCA
IFN FTSCA,<
IFE M.SCA,<			;IF NO SCA SUPPORT
	XP	BHDINI,CPOPJ	;SOME DUMMY GLOBALS
	XP	SC.INI,CPOPJ
	XP	SC.TIC,CPOPJ
	XP	SC.SEC,CPOPJ
	XP	PPDTIC,CPOPJ
	XP	PPDSEC,CPOPJ
	XP	PPDMFL,CPOPJ
	XP	PPDMON,CPOPJ
	XP	PPDRMV,CPOPJ
	XP	PPDRHD,CPOPJ
	XP	REVFUL,CPOPJ
	XP	SCS,CPOPJ
	XP	SCSCLK,CPOPJ
	XP	SCSPOP,CPOPJ
	XP	SCSLGO,CPOPJ
	XP	SCSRST,CPOPJ
	XP	PPDDIA,ILLKON##
	XP	PPDCLR,CPOPJ
	XP	PPDINX,CPOPJ
	XP	DIARRS,DIANPC##
	XP	DIASRS,DIANPC##
	XP	DIACTR,DIANPC##
	XP	DIAEDP,DIANPC##
	XP	DIAWMD,DIANPC##
	XP	DIARMD,DIANPC##
	XP	KLPCFG,CPOPJ
	XP	KLPINT,CPOPJ
	XP	KLPPCB,0
	XP	KLPBTS,0
	XP	BHDADR,[0]
	XP	BSDADR,[0]
	XP	BHDPGS,0
	XP	BSDPGS,0
SCSPSI::SETZ	T2,
	POPJ	P,
>; END IFE M.SCA
IFN M.SCA,<			;IF SCA SUPPORT
EXTERN	SCASER, KLPSER, SCSUUO, PPDTIC, PPDINX
>; END IFN M.SCA
>; END IFN FTSCA
EXTERNAL CLOCK1,COMCON,CORE1,ERRCON,ONCE,PATCH,UUOCON,DATMAN,TMPUUO,MONEND

;LOAD FILE SERVICE ROUTINES, REFRESHER & ONCMOD (EXTRA ONCE ONLY CODE) FOR LEVEL D
;LEVEL D ALSO REQUIRES COMMOD, WHICH IS A SEPARATE FILE OF DISK PARAMETERS
;UNLESS SYMBOL FTCMBTH IS DEFINED, IN WHICH CASE THEY ARE HERE IN COMMON
	IFN	LEVDN,<EXTERNAL FILFND,FILIO,FILUUO,ONCMOD,REFSTR
		IFNDEF FTCMBTH,<EXTERN COMMOD>>

	$ABS

;ENTER DDT

ENTDDT:	JFCL	DDTX		;FIRST ENTRY PATCHES THIS TO JRST
	EXECAC			;GET AC SET RIGHT
	CONO	APR,200000	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JFCL			;REALLY SHOULD BE THE BOOT CPU
	MOVSI	T1,(JRST)	;ONLY NEED (WANT) TO DO THIS ONCE
	HLLM	T1,ENTDDT	; AS MONITOR WILL TURN ON PAGING FOR US
	JRST	DDTX		;ENTER DDT

	IFG	DDTN, <EXTERNAL DDTX>
	IFE	DDTN, <
		XP DDTEND,0	;ONCE REFERENCES END OF DDT
		XP DDTX,0	; AND ALSO ITS ENTRY POINT.
		XP $1B,0	; AND ALSO BREAKPOINTS
		>

;LOAD SCHEDULER FOR NON-SWAPPING OR SWAPPING SYSTEM
	EXTERNAL SCHED	;SCHED
		IFN LEVDN,<EXTERNAL SWPSER	;IO HANDLER FOR LEVEL D SWAPPER>


	EXTERNAL SEGCON
;SATISFY GLOBAL NEEDED FOR USER MODE ONCE ONLY - NEVER CALLED BY EXEC MONITOR
	XP	USRCPY,CPOPJ
SUBTTL	KL10 SYSTEM TIME BASE ROUTINES
IFN M.KL10,<

;THESE ROUTINES PERFORM THE SAME FUNCTIONS AS THE DK10 ROUTINES DO
; FOR THE KI10. THEY ALSO INITIALIZE THE ACCOUNTING METERS.

;ROUTINE TO SETUP INITIAL TIME BASE VALUE, CALLED BY SYSINI AFTER ONCE
; COMPUTES DATE BY CALLING SUDATE

SETIME::MOVE	T1,DATE		;GET UNIVERSAL DATE/TIME
	MULI	T1,^D86400	;GET SECONDS SINCE NOV 17,1858
	ASHC	T1,^D17		;PUT BINARY POINT AFTER BIT
				; 35 OF T1 YIELDING
				; SECONDS SINCE NOV 17, 1858
				; IN T1
	MUL	T1,[RTUPS*^D10]	;CONVERT TO 1 USEC UNITS FOR TIME BASE
	ASHC	T1,<^D35-TB.LTP>;ACCOUNT FOR COUNTS/TICK
	CONO	MTR,MO.TOF!MO.CTB ;TURN OFF TIME BASE, CLEAR IT.
	MOVE	T3,.CPEPT	;ADDRESS OF THIS PROCESSOR'S EPT
	DMOVEM	T1,.E0HTB-.E0MP(T3) ;STORE UNIVERSAL DATE TIME BASE (RUNS OUT IN 5028
	MOVEI	T2,MO.LAC!MO.AO!MO.AEN!MO.AIP	;INITIALIZE ACCOUNTING
	MOVEI	T1,ST%XPI	;CHECK IF PI TIME IS EXCLUDED
	TDNE	T1,CNFST2	;SKIP IF IT IS NOT EXCLUDED
	TRZ	T2,MO.AIP	;IT IS, DO NOT INCLUDE
	CONO	MTR,MO.TON(T2)	;TURN TIME BASE ON, DO GOOD STUFF
	PUSHJ	P,GETIME	;GET TIME SO WE CAN
	MOVEM	T1,.CPXTM	;SET UP THE FIRST LAST TIME
	POPJ	P,


RTUPS==:^D100000	;RESOLUTION OF ACCOUNTING
RTUPS3==:RTUPS/^D1000		;FOR USE IN JOBTIM: ROUTINE
RTUPS5==:RTUPS/^D100000

;GET TIME OF DAY IN RTUPS UNITS/SECOND
; USES ACS T1-T4

GETIME::SETZB	T1,T2		;CLEAR T1,T2 FOR DDIV
	RDTIME	T3		;GET UNIVERSAL TIME IN TIME BASE UNITS
	ASHC	T3,<TB.LTP-^D35>	;ACCOUNT FOR COUNT/TIME BASE TICK
	DDIV	T1,RTCMTT	;DIVIDE BY RTCMAX*10, YIELDING UNIVERSAL
				; DATE IN T1,T2 AND USECS SINCE MIDNITE IN T3,T4
	DIVI	T3,^D10		;CONVERT TO RTUPS UNITS (10 USECS)
	MOVE	T1,T3		;AND GET FINAL ANSWER IN T1
	POPJ	P,		;RETURN

RTCMAX::RTUPS*^D3600*^D24	;RTUPS UNITS/DAY
RTCMTT:	EXP	2,203565660000	;RTUPS*^D3600*^D24*^D10 (MICROSECS/DAY)
RTCDAY==:CPOPJ


>;END IFN M.KL10
SUBTTL	KS10 SYSTEM TIME BASE ROUTINES
IFN M.KS10,<

;THESE ROUTINES PERFORM THE SAME FUNCTIONS AS THE DK10 ROUTINES DO
; FOR THE KA10 AND KI10.

;ROUTINE TO SETUP INITIAL TIME BASE VALUE, CALLED BY SYSINI AFTER ONCE
; COMPUTES DATE BY CALLING SUDATE

SETIME::MOVE	T1,DATE		;GET UNIVERSAL DATE/TIME
	MULI	T1,^D86400	;GET SECONDS SINCE NOV 17,1858
	ASHC	T1,^D17		;PUT BINARY POINT AFTER BIT
				; 35 OF T1 YIELDING
				; SECONDS SINCE NOV 17, 1858
				; IN T1
	MULI	T1,^D1000	;MILLISECOND RESOLUTION
	ASHC	T1,^D12		;ACCOUNT FOR COUNTS/TICK
	WRTIME	T1		;LOAD TIME BASE
	MOVEI	T1,<^D17>B23	;INTERVAL FOR TIMER
	WRINT	T1		;LOAD INVERVAL FOR TIMER
	WRAPR	SP.CSF+SP.ESF+SP.ITI+AP0CHN ;TURN INTERVAL TIMER ON
	PUSHJ	P,GETIME	;GET TIME SO WE CAN
	MOVEM	T1,.CPXTM	;SET UP THE FIRST LAST TIME
	POPJ	P,		;END RETURN


RTUPS==:^D100000	;RESOLUTION OF ACCOUNTING
RTUPS3==:RTUPS/^D1000		;FOR USE IN JOBTIM: ROUTINE
RTUPS5==:RTUPS/^D100000

;GET TIME OF DAY IN RTUPS UNITS/SECOND
; USES ACS T1-T4

GETIME::SETZB	T1,T2		;CLEAR T1,T2 FOR DDIV
	RDTIME	T3		;GET UNIVERSAL TIME IN TIME BASE UNITS
	DDIV	T1,RTCMTT	;DIVIDE BY TICS/DAY, YIELDING UNIVERSAL
				; DATE IN T1,T2 AND TICS SINCE MIDNITE IN T3,T4
	DIVI	T3,^D41		;CONVERT TO RTWPS UNITS
	MOVE	T1,T3		;GET INTO T1 (IN 10 USEC UNITS)
	POPJ	P,		;RETURN

RTCMAX::RTUPS*^D3600*^D24	;RTUPS UNITS/DAY
RTCMTT:	EXP	12,117226200000	;CLOCK TICS PER DAY AT 4.1 MHZ
RTCDAY==:CPOPJ


>;END IFN M.KS10
;DEFINE GLOBALS IF NO MOS MEMORY SUPPORT
IFN M.KL10,<IFE M.MOS,<
	XP	DIAGTM,CPOPJ
	XP	DIAGVM,CPOPJ
>>

;DEFINE GLOBALS IF NO EXTENDED ADDRESSING SUPPORT
IFE FTXMON,<
	XP	SSPCS,CPOPJ
	XP	SVPCS,CPOPJ
	XP	STPCS,CPOPJ
	XP	SPCS,CPOPJ
>


SUBTTL PROCESSOR STUFF

;MAKE SURE THAT PROPER VERSION OF FEATURE SWITCH FILES WERE USED TO ASSEMBLE
;THE REST OF THE MONITOR
;THE LOADER WILL PRINT MUL. DEF. GLOBAL IF A MISTAKE HAS BEEN MADE

;DUAL PROCESSOR SYSTEM ROUTINE GETS LOADED HERE

IFG <CPUN-1>,<
	EXTERN	CPNSER
>

	IFE	COREN, <IFE FTXMON,<COREN==^D256_K2PLSH>
			IFN FTXMON,<COREN==<<MXSECN+1>*^D256>_K2PLSH> ;NO RESTRICTION IF 0 TYPED>
	XP	USRLIM,COREN	;DEFINE GLOBAL RESTRICTING MAXIMUM SIZE OF
					; CORE FOR ANY SINGLE USER
					; ONCE ONLY CODE CAN ALTER THIS VALUE
					; (PATCH RH CORLIM IN SYSINI)


	$ABS

;NOTE: THESE SYMBOLS WILL GO AWAY SOON SO THAT AP.??? SYMBOLS
; WILL BE USED INSTEAD AS DEFINED IN S.MAC
;APR AND PI BITS

;APR BITS FOR BOTH PDP-6 AND KA10


	CLKBIT==:1
	REPEAT	7-CK0CHN, <CLKBIT==:CLKBIT*2>
	REQCLK==:PI.IIO+CLKBIT	;REQUEST INTERRUPT ON LOW PRIORITY CLK CHANNEL
	ZZ==1
	REPEAT	7-SCNCHN,<ZZ==ZZ*2>
	REQCTY==:PI.IIO+ZZ	;FOR KL10 CTY, MUST INTERRUPT ON SCANNER PI BY HAND
	CLRCTY==:II.CPP+ZZ	;CLEAR PSEUDO-CTY INTERRUPT (KL10)

	CLRPIS==:11577		;CLEAR THE PI SYSTEM

IFN CP0KLN,<AP0NUL==:LP.ESF!LP.CSF+LP.SBE+LP.NXM+LP.PAR+LP.IOF+LP.PWF+LP.CDP+LP.ADP+LP.CSD+AP0CHN>
				;RESET APR FOR NULL JOB
				; CLEAR EVERYTHING BUT DON'T I/O RESET
IFN CP0KSN,<AP0NUL==:SP.ESF!SP.CSF!SP.PWF!SP.ITI!SP.FEI+AP0CHN>
	AP0RST==:AP0NUL+200000	;RESET APR FOR SYSINI (I/O RESET TOO)
IFN M.KL10,<NXM==:LP.NXM>	;NON-EX MEM (APR STATUS WORD)
IFN M.KS10,<NXM==:SP.NXM>
;NOW HARDWARE BITS WHICH DEPEND ON SOFTWARE CONFIGURATION:

	XP	XI.RQC,REQCLK	;CONO PI.XI.RQC REQUESTS CLK INTERRUPT
	XP	II.CCI,II.CPP+CLKBIT
XP XC.UOU,UIOMOD

;DEFINE APR SYMBOLS FOR PDP-6 VS KA10 FOR CPU 0

	XP	PIPROG,77400	;PI STATUS REGISTER
				;ONES IF ANY PI'S IN PROGRESS
				;DO NOT DEFINE IF PDP-6 SO UNDEFINED
				;GLOBAL WILL BE CLUE TO PDP-6 USER
				;TO CHANGE CODE
	A0.NOT==PIPROG-<400_<7-AP0CHN>>	;DEFINE ALL PI IN PROGRESS FLAGS EXCEPT
				; APR FOR HALT TEST IN APRINT.
	A0.APP==1_<7-AP0CHN+10>	;CPU0 APR PI IN PROGRESS
	A0.NOC==:PIPROG-<400_<7-CK0CHN>> ;PI-IN-PROG EXCEPT CLOCK
	A0.ACO==1_<7-AP0CHN>	;CPU0 APR CHANNEL ON
	XP	SYSOFF,<177_-AP0CHN>+PI.TFP ;TURNS OFF ALL PI CHANNELS BELOW
				; THE APR CHANNEL.  USED BY INTERLOCK
				; MACROS AND DEPENDS ON NOONE ATTEMPTING
				; TO OBTAIN OR WAITING FOR AN INTERLOCK
				; AT OR ABOVE THE APR CHANNEL
	XP	SYSON,<177_-AP0CHN>+PI.TNP

IFN CP0KLN!CP0KSN, <A0.FOV==000	;PC CHANGE CANNOT BE ENABLED ON PDP-6, BECAUSE
				; IT MAKES MONITOR TRAP ALSO>
;DEFINE APR SYMBOLS FOR CPU'S GREATER THAN 1

DEFINE APRDEF(X)<
	A'X'.NOT==PIPROG-<400_<7-AP'X'CHN>>
	A'X'.APP==1_<7-AP'X'CHN+10>
	A'X'.FOV==0
	A'X'.ACO==1_<7-AP'X'CHN>
IFN M.KL10,<AP'X'NUL==:LP.ESF!LP.CSF!LP.SBE!LP.NXM!LP.PAR!LP.IOF!LP.PWF+LP.CDP+LP.ADP+LP.CSD+AP'X'CHN>
	AP'X'RST==:AP'X'NUL+200000
>;END DEFINE APRDEF

ZZ==1
REPEAT <M.CPU-1>,<
	APRDEF	(\ZZ)
ZZ==ZZ+1
>

APRNUL==:AP0NUL
APRRST==:AP0RST
APRCHN==:AP0CHN
;IF THERE IS ONLY ONE CPU IN THIS SYSTEM DEFINE ALL NECESSARY GLOBALS

IFE <CPUN-1>,<			;NO SECOND CPU?
	$HIGH
STMPEC::MOVE	P4,.C0EPT
	DPB	P3,P2
	CLRPGT	(0)
	POPJ	P,
IFN FTMP,<

	XP	MSCHED,SCHEDJ##
	XP	CP1CRS,SAVPC2##
	XP	BECOM0,CPOPJ
	XP	BRKLOK,CPOPJ
	XP	BRKSIW,CPOPJ
	XP	UXITMP,CPOPJ1
	XP	MSTUUO,CPOPJ
	XP	CP0RC,CPOPJ1
	XP	CP1AC,CPOPJ1
	XP	SPSTOP,CPOPJ1
	XP	DPXST,CPOPJ
	XP	CLRJSP,CPOPJ
	XP	SETJSP,CPOPJ
	XP	ALLJSP,CPOPJ
	XP	CLRSJ0,CPOPJ
	XP	DXRUN,CPOPJ1
	XP	CPUOFS,CPOPJ
	XP	CPUFND,CPOPJ
	XP	CPUDET,CPOPJ
	XP	CPUDTU,CPOPJ
	XP	CPUATT,CPOPJ
	XP	CPUATU,CPOPJ
	XP	GETMM,CPOPJ1
	XP	GIVMM,CPOPJ
	XP	SCDMM,CPOPJ1
	XP	MMOWN,CPOPJ1
	XP	DIFMM,CPOPJ
	XP	UIFMM,CPOPJ
	XP	REMMM,CPOPJ
	XP	GGVMM,CPOPJ
	XP	UPMM,CPOPJ
	XP	TGVMM,CPOPJ
	XP	DWNMM,CPOPJ
	XP	UPMC,CPOPJ
	XP	DWNMC,CPOPJ
	XP	LOKSCD,CPOPJ
	XP	ULKSCD,CPOPJ
	XP	SBSCD,CPOPJ
	XP	CLRCCB,CPOPJ
	XP	CPUCMD,CPOPJ
	XP	CPLCK,CPOPJ1
	XP	MAPUEC,CPOPJ
	XP	MAPUC,CPOPJ
	XP	CP1MFL,SAVPC2##
	XP	CHKDIE,CPOPJ
	XP	ONCPU0,CPOPJ
	XP	CP1STP,CPOPJ1
	XP	SETCPF,CPOPJ
	XP	SETCPP,CPOPJ
	XP	SCDSS1,CPOPJ
	XP	SETQPB,CPOPJ
	XP	ONCPUL,CPOPJ
	XP	ONCPUD,CPOPJ
	XP	ONCPUS,CPOPJ1
	XP	ONCPUN,CPOPJ
	XP	SETCPN,CPOPJ
	XP	CP1CHK,CPOPJ
	XP	BUFSSN,CPOPJ1
	XP	RWRTCH,CPOPJ
	XP	MAPINI,CPOPJ
;LOCATIONS IN SLAVE CDB WHICH ARE CHECKED INDIVIDUALLY BY MASTER:
;FOLLOWING LOC ALWAYS ZERO (SINCE NO CPU1)
.E1MP==:0
JBTST3==:0

IFN M.KL10,<
	XP	CLCSN,CPOPJ	;IF CPNSER NOT LOADED AND KL10
	XP	SETCSN,CPOPJ
	XP	SETCSJ,CPOPJ
	XP	SCDCSH,CPOPJ1
	XP	SWPCSH,CPOPJ1
	XP	CTXSWP,CPOPJ
	XP	CSREQS,CPOPJ
	XP	CLRCSH,CPOPJ
	XP	CKCP1C,CPOPJ
	XP	CHKSWS,CPOPJ
	XP	CHKCSH,CPOPJ
	XP	CHKCSH,CPOPJ
	XP	SETCSB,CPOPJ
	XP	UNCACH,CPOPJ
	XP	MLSCSH,CPOPJ1
CKNBF::
CHKNB::	HRLZ	T1,DEVNBF(F)
	HRRZS	DEVNBF(F)
	ADDM	T1,DEVNBF(F)
STONBF::POPJ	P,
	$ABS
DT1CMD::
DT1MTD::0
	$HIGH
>;END IFN M.KL10

CHKCPI::AOS	(P)
GETCAM::MOVE	T1,.CPBIT
	POPJ	P,
CPUOK::	AOS	(P)
CAMCPU::SETZ	T4,
	POPJ	P,
CHKCPU::SETZ	T1,
	JRST	CPOPJ1
LOKDPI::CONO	PI,SYSOFF
	POPJ	P,
IFN FTENET,<
LOKETH::AOSE	.CPETH
	POPJ	P,
>; END IFN FTENET
LOKBTI::
LOKSPI::CONO	PI,PI.OFF
UNLSPT::POPJ	P,
IFN M.NET,<
LOKNPI::CONO	PI,NETPIF
	POPJ	P,
UNLNPI::CONO	PI,NETPIN
	POPJ	P,
> ;END M.NET
LOKSCI::CONO	PI,SCNPIF
	POPJ	P,
UNLSCI::CONO	PI,SCNPIN
	POPJ	P,


CRESET::
IFN FTTRPSET,<
	SETZM	.C0STS
>
	POPJ	P,
>	;END IFN FTMP
	XP	LSTCPU,CPOPJ1
	XP	ANYRUN,CPOPJ1
	XP	SETCPU,CPOPJ1
	XP	SETCRN,CPOPJ1
	XP	SETCDN,CPOPJ
	XP	CPSCHK,CPOPJ1
	XP	SCDOWN,CPOPJ1
ANYCPU::CAME	J,.CPJOB
	AOS	(P)
	POPJ	P,		;TURN ON DEVICE PI LEVEL
UNLDPI::
ONPOPD::CONO	PI,SYSON
	POPJ	P,
IFN FTENET,<
UNLETH::SOSL	.CPETH
	POPJ	P,
>; END IFN FTENET
ONPOPB::
UNLBTI::
ONPOPJ::
UNLSPI::CONO	PI,PI.ON
	POPJ	P,
GIVLOK::NTGIVE
	POPJ	P,
	$ABS
BCOM0::	POPJ	P,
>	;END IFE CPUN-1
;INTERNAL HERE FOR 10/40N, MUST BE SAME AS IN COMMOD

	FNCEXC==:1		;EXECUTE ONLY
	FNCRED==:2		;READ
	FNCALL==:3		;ALLOCATE
	FNCDLL==:4		;DEALLOCATE
	FNCAPP==:5		;APPEND
	FNCUPD==:6		;UPDATE
	FNCCRE==:7		;CREATE
	FNCSUP==:10		;SUPERSEDE
	FNCTRN==:11		;TRUNCATE
	FNCCAT==:12		;CHANGE ATTRIBUTES(EXCEPT PRIVILEGE,NAME,DIR)
	FNCDEL==:13		;DELETE
	FNCCNM==:14		;CHANGE NAME
	FNCCPR==:15		;CHANGE PRIVILEGE
	SUBTTL	REAL TIME TRAPPING
IFN FTRTTRP,<
IFG RTTRPN,<
	EXTERN	RTTRP
	$HIGH

RTMCAN==:.USMUE
RTMUAC::POINT	4,.USMUO,30	;UUO AC FIELD
RTMUOC::POINT	9,.USMUO,26	;UUO OPCODE FIELD


;TRPGO IS ENTERED FROM THE CHANNEL SAVE ROUTINE DURING A REAL TIME DEVICE
; INTERRUPT. RELAVENT LOCATIONS FROM THE USER PAGE MAP PAGE, TRPFLG, AND
; LOCATION 61 ARE SAVED. THE REAL TIME USER'S UPMP AND TRAP LOCATIONS ARE
; SETUP AND CONTROL IS TRANSFERRED TO THE USER'S INTERRUPT ROUTINE IN USER
; MODE.

TRPGO::
	MOVE	T1,@.CPSPT	;SPT
	MOVEM	T1,1(P)		;SAVE THAT
	MOVE	T1,RELTB1##(J)	;REAL TIME PROGRAM'S PROCESS TABLE
	HRRM	T1,@.CPSPT	;PART OF MAKING THE JOB ADDRESSABLE

	DATAO	PAG,RELTB1##(J)	;SETUP THE INTERRUPT LEVEL USER'S BASE REGISTER
	ADD	P,[XWD 22,22]	;OFFSET THE STACK FOR SAVING BACKGROUND
				; CONTEXT OF THE INTERRUPT LEVEL USER
	MOVSI	T1,.USPFT	;STARTING AT THE PAGE FAULT TRAP INSTRUCTION
	HRRI	T1,-20(P)	; THROUGH THE PUBLIC TRAP NEW MUUO PC
	BLT	T1,(P)		; SAVE THE BACKGROUNG UPMP
	MOVE	T1,[XWD RTTUPM,.USPFT]
	BLT	T1,.UPMP+437	;SETUP THE INTERRUPT LEVEL UPMP
IFN M.KL10,<
	PUSH	P,.USPFW	;SAVE PAGE FAIL WORD
	PUSH	P,.USPFP	; AND OLD P.F. PC
	PUSH	P,.USPFN	; AND NEW P.F. PC
	PUSH	P,.USPFN+1	; ..

	MOVEI	T1,RTTILM	;WHERE TO GO ON ILM
	MOVEM	T1,.USPFN+1	;STORE THAT
>
	HRRI	T1,RTTAOF	;ADDRESS OF INTERRUPT LEVEL ARITHMETIC
				; EXCEPTION PROCESSING ROUTINE
IFN M.KL10,<HLL T1,-22(P)>
	MOVEM	T1,.USAOT	;ENABLE OR DISABLE INTERRUPT LEVEL ARITHMETIC
				; TRAPPING
	PUSH	P,.CPDMI	;SAVE 61
	PUSH	P,.CPRTT	;AND LOWER LEVEL TRPFLG
	HRLI	J,400000	;MAKE TRPFLG NEGATIVE, USER MODE OFF
				; FOR CHN TEST ON WHETHER TO SAVE ACS
	MOVEM	J,.CPRTT	;SETUP TRPFLG FOR THIS INTERRUPT LEVEL USER
	MOVE	T1,DISMT1##(J)	;GET THE DISMISS INSTRUCTION FOR THIS INTERRUPT
				; LEVEL
	MOVEM	T1,.CPDMI	;STORE IT IN 61
	JRST	2,@TRPTB1##(J)	;ENTER THE USER'S INTERRUPT ROUTINE IN USER MODE
;DISMIS IS ENTERED FROM THE CHANNEL DISMISS ROUTINE BY A JSP J,DISMIS.
; THE STATE OF THE MACHINE IS RESTORED AND THE ROUTINE RETURNS TO THE
; CHANNEL DISMISS ROUTINE TO RESTORE THE AC'S AND DISMISS THE INTERRUPT.

DSMAPR:
DISMIS:	POP	P,.CPRTT	;RESTORE LOWER LEVEL TRPFLG
	POP	P,.CPDMI	;RESTORE 61
IFN M.KL10,<
	POP	P,.USPFN+1

	POP	P,.USPFN	;RESTORE NEW P.F. PC
	POP	P,.USPFP	;RESTORE OLD P.F. PC
	POP	P,.USPFW	;RESTORE P.F. WORD
>
	SUB	P,[XWD 20,20]	;SET STACK OFFSET FOR RESTORING BACKGROUND
				; UPMP
	MOVSI	T1,(P)		; ..
	HRRI	T1,.USPFT	;STARTING AT PAGE FAULT TRAP INSTRUCTION
	BLT	T1,.UPMP+437	; RESTORE UPMP THROUGH PUBLIC TRAP NEW MUUO PC
	MOVE	T1,-1(P)	;SPT AT INTERRUPT
	HRRM	T1,@.CPSPT	;RESTORE THAT

	JRST	(J)		;RESTORE AC'S AND DISMISS THE INTERRUPT

;INTERRUPT LEVEL USER PAGE MAP PAGE

RTTUPM:	RTTILM
	RTTAOF
	RTTPOF
	JFCL
	0
	0
	IC.UOU+RTTILM
	RTTILM
	EXP	MUUO
	EXP	KTUUO
	EXP	SNTUUO
	EXP	STUUO
	EXP	RTCNTU
	EXP	KTUUO
	EXP	RTPNTU
	EXP	KTUUO
;HERE ON A UUO AT INTERRUPT LEVEL

RTCNTU:RTPNTU:
	MOVE	17,.USMUP	;30 BIT PC, NOT REALLY, MUST BE IN SECTION 0
	HLL	17,.USMUO	;UUO FLAGS
	JRSTF	@[IC.UOU+UUOHND##] ;TURN ON USRIOT BY HAND AND DISPATCH TO UUO HANDLER



;HERE ON AN ARITHMETIC EXCEPTION AT INTERRUPT LEVEL

RTTAOF:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
	MOVEI	T1,AP.AOV+AP.FOV;REASON FOR THE TRAP
	JRST	ERRGO		;JOIN COMMON CODE

;HERE ON A PUSH DOWN LIST OVERFLOW AT INTERRUPT LEVEL

RTTPOF:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
	MOVEI	T1,AP.POV	;TELL USER THE REASON FOR THE TRAP
	JRST	ERRGO		;JOIN COMMON CODE

;HERE ON AN ILLEGAL MEMORY REFERENCE (PAGE FAULT) AT INTERRUPT LEVEL

RTTILM:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
IFN M.KL10,<
	MOVE	T1,.USPFP
	MOVEM	T1,.USMUO
	MOVE	T1,.USPFP+1
	MOVEM	T1,.USMUP

>
	MOVEI	T1,AP.ILM	;TELL USER THE REASON FOR THE TRAP
ERRGO:	MOVEM	J,.CPRTS	;SAVE AN AC
	MOVE	J,.CPRTT	;GET INDEX INTO REAL TIME BLOCK
	EXCH	T1,.JDAT+.JBCNI##
	EXCH	T1,.USMUP	;GET THE TRAP PC
	HLL	T1,.USMUO	;FLAGS

	EXCTXU	<MOVEM T1,@APRTB1##(J)>
	HRR	T1,APRTB1##(J)	;ADDRESS OF THE USER'S TRAP HANDLING ROUTINE
	HRRI	T1,1(T1)	;CLEAR ALL FLAGS WHICH COULD CAUSE A TRAP
	TLZ	T1,(XC.OVF+XC.FOV+XC.TRP+XC.FUF+XC.NDV)
	EXCH	T1,.USMUP	;RESTORE T1 AND STORE PC
	MOVE	J,.CPRTS	;RESTORE J
	JRSTF	@.USMUP	;AND ENTER USER'S TRAP HANDLING ROUTINE

	$ABS
	RTINIC==:1			;FLAG SYSINI TO CALL INITIALIZATION ROUTINE

ENBSTD==470550+AP0CHN

MRTRPN==:-RTTRPN
RTBSIZ==:23

RTBLK::	BLOCK	RTTRPN*RTBSIZ
>>
IFE FTRTTRP,<IFN RTTRPN,<
PRINTX ;PLEASE ASSEMBLE SOURCES WITH FTRTTRP=-1
>>
IFN FTRTTRP,<IFE RTTRPN,<
CHAINT==:CPOPJ
RTBLK==:CPOPJ
RTLINK==:CPOPJ
SAV41==:CPOPJ
SAV61==:CPOPJ
CHNTAB==:CPOPJ
RTBSIZ==:CPOPJ
BLKENB==:CPOPJ
RTINIC==:0			;FLAG SYSINI NOT TO CALL INITIALIZATION ROUTINE
>>
	;CREATE JBTRTD TABLE ONLY IF THERE ARE REAL TIME DEVICES OR
	;HIGH PRIORITY QUEUES OR THE HIBERNATE-WAKE FEATURE.
	;LH(JBTRTD) = REAL TIME STATUS BITS FOR HPQ AND HIBERNATE-WAKE
	;RH(JBTRTD) = COUNT OF REAL TIME DEVICES OWNED BY EACH JOB

ZZ=0
IFN FTRTTRP,<IFG RTTRPN,<ZZ==ZZ+1>>
IFN SYS50N,<IFN FTHPQ,<IFG HPQN,<ZZ==ZZ+1>>>
	ZZ==ZZ+1

IFG ZZ,<JBTRTD:: BLOCK JOBN
ITMRTD==:JOBMXL
CLRRTD::SETZM	JBTRTD(J)
>

IFLE ZZ,<JBTRTD::0		;FOR GETTAB
ITMRTD==:JOBMXL
CLRRTD::JFCL
>


;JBTRTD BIT DEFINITIONS

;BITS 27-35	ARE THE COUNT OF THE NUMBER OF REAL TIME DEVICES OWNED BY THIS JOB

;BITS 23-26	ARE TEMPORARY HPQ (SHARABLE DEVICE OWNER)

;BITS 15-17	ARE THE HIBERNATE PROTECTION CODE FOR THIS JOB

;BIT 14		IS TTY INPUT ACTIVITY ENABLE - CHARACTER MODE
;BIT 13		IS TTY INPUT ACTIVITY ENABLE - LINE MODE

;BIT 12		IS PTY ACTIVITY ENABLE

;BIT 11		IS I/O ACTIVITY ENABLE

;BIT 10 IF HIBER UUO AC IS AN ALIAS FOR IPCACE IN JBTRTD
;BIT 10		IS THE WAKE BIT - THIS BIT IS SET TO WAKE THE JOB UP BY HIBER

;BITS 6-9	ARE THE CURRENT HIGH PRIORITY QUEUE POSITION OF THIS JOB

;BITS 2-5	ARE THE CONSOLE COMMAND SETTING OF HPQ FOR THIS JOB

;BIT 1 IS IPCF EVENT ENABLE
;BIT 0 IS ONLY AN EXEC PROCESS CAN WAKE THE JOB
;BIT 0 OF HIBER UUO AC ARG IS 1 IF JOB IS TO BE SWAPPED IMMEDIATELY
;BUT NEVER STORED IN JBTRTD
	$HIGH
TTIALE==:20		;TTY INPUT ACTIVITY - LINE MODE
TTIACE==:10		;TTYINPUT ACTIVITY - CHARACTER MODE
TTILCE==:TTIALE!TTIACE	;TTY INPUT - LINE AND CHARACTER MODE ENABLE
PTYWUE==:40		;PTY WAKE UP ENABLE BIT
IOACE==:100		;I/O ACTIVITY ENABLE BIT
WAKEB==:200		;WAKE UP BIT

IFN FTIPCF,<
	IPCACE==:200000	;IPC EVENT ENABLE
	IPCUUB==:200	;USERS ARG FOR IPC ACTIVITY
>

TTIUDI==:1B18		;BATCON/MIC ENABLE FLAG
UDIUUB==:(1B9)		;USERS ARG FOR DEMANDING INPUT

MONHBR==:400000		;ONLY THE MONITOR CAN WAKE THIS JOB
			; (STORED IN JBTRTD)
HBRSWP==:400000		;SWAP ME OUT IMMEDIATELY
			; (NOT STORED IN JBTRTD)
HBRSEC==:200000		;TIME IS IN SECONDS

HIBPRT::POINT	7,JBTRTD(J),17	;HIBERNATE PROTECTION CODE


IFN FTHPQ,<
HPQPNT::POINT	4,JBTRTD(J),9	;CURRENT HIGH PRIORITY QUEUE
HPQPT1::POINT	4,JBTRTD(T1),9
HPQPT2::POINT	4,JBTRTD(T2),9
HPQSPT::POINT	4,JBTRTD(J),5	;HIGH PRIORITY QUEUE SET BY CONSOLE COMMAND
HPQPN3::POINT	4,JBTRTD(T3),9
HPQMSK==:170000			;BIT FIELD OF CONSOLE COMMAND HPQ
HPUMSK==:(17B9)		;CURRENT HPQ MASK
>
IFE FTHPQ,<
XP HPQMSK,0			;NO MASK IF NO HIGH PRIORITY QUEUE
>
IFE RTTRPN,<
RTREL==:CPOPJ
RTTRP==:CPOPJ
>

IFE FTLOCK,<
LOKJOB==:CPOPJ
UNLOK.==:CPOPJ
IFN LOKN,<
PRINTX ;PLEASE ASSEMBLE SOURCES WITH FTLOCK=-1
>>

IFN LOKN,<
	EXTERN	LOKCON
PDLPNO==:.UUPMP/PAGSIZ

LOKINC==:1			;FLAG SYSINI TO CALL INITIALIZATION ROUTINE
>
IFN FTLOCK,<

	IFE	LOKN,<

LOKJOB::MOVEI	T1,0		;ERROR CODE 0 MEANS NOT IMPLEMENTED
	JRST	STOTAC##
UNLOCK::MOVSI	T1,NSHF!NSWP
	ANDCAM	T1,JBTSTS(J)
	UNLOK.::
LOCK0::!
CKMOL::
NEWCMX::
CKLJB::
MEMOFL::
MEMOFU::

UNLOKH::POPJ	P,
LOKCHK==:CPOPJ1
LOKEVC==:CPOPJ
SETLPR==:CPOPJ1
LOKHGH==:CPOPJ1
LOKSWP==:CPOPJ1
LOKINC==:0			;FLAG SYSINI NOT TO CALL INITIALIZATION ROUTINE
EVLPTR==:0
LOKINS==:0			;EXEC PC ON MEM TRAP IF NO LOCK BLT
>
IFNDEF CMNN,<CMNN==0>
LOKASK==:LOKN
LOKMAX==:CMNN

IFE CMNN,<LOKMAX==:-1>
>
SUBTTL HIGH PRIORITY QUEUE UUO

IFN SYS40N,<HPQN==0>		;NO HIGH-PRIORITY QUEUE IN 10/40 SYSTEMS.
IFNDEF HPQN,<HPQN==5>		;DEFAULT VALUE IS 5 HP QUEUES

IFN SYS50N,<
IFN FTHPQ,<
IFG HPQN,<

HPQ::	PUSHJ	P,HPQST1	;CHECK HPQ LEGALITY
	JRST	RTM1##		;NO, GIVE ERROR RETURN
	JUMPE	T2,CPOPJ1	;IF NO PRIVILEGES DONT RESCHEDULE
	SYSPIF
	SKIPN	SCDRTF		;IS THERE A FORCED SCHEDULE BEING DONE
	SETOM	SCDRTF		;NO, SO START ONE
	SYSPIN
	SETOM	.CPHQU		;FLAG HPQ UUO DONE SO SCHEDULER WILL
				; REQUEUE CURRENT JOB TO NEW HPQ
	JRST	CPOPJ1		;SKIP RETURN TO USER


HPQPRV:	POINT	4,JBTPRV(J),3+^L<PVHPQ>-^D18	;MAXIMUM HPQ ATTAINABLE BY THIS JOB


HPQSET:	TDZA	T2,T2		;SKIP JACCT TEST
HPQST1:	MOVSI	T2,JACCT	;SET FOR JACCT TEST
	MOVE	T3,JBTPPN(J)	;GET JOB'S ACCOUNT
	CAME	T3,FFAPPN##	;IF OPERATOR ("FULL FILE ACCESS"), OR
	TDNE	T2,JBTSTS(J)	;IF JACCT
	SKIPA	T2,[HPQN]	;ASSUME HIGH
	LDB	T2,HPQPRV	;GET HPQ PRIVILEGES FOR THIS JOB
	CAMLE	T1,T2		;IS THIS JOB PRIVILEGED ENOUGH?
	POPJ	P,		;NO, GIVE ERROR RETURN

	SKIPL	T1		;CORRECT FORMAT?
	CAILE	T1,HPQN		;LEGAL QUEUE?
	POPJ	P,		;NO
	DPB	T1,HPQPNT	;YES, STORE NEW HPQ VALUE
	JRST	CPOPJ1		;GIVE SUCCESSFUL RETURN

HPQCMD::PUSHJ	P,DECIN1##	;PICK UP HPQ VALUE IN T2
	JRST	.+2		;NO ARGUMENT, ASSUME 0
	PJRST	COMERA##	;ILLEGAL ARGUMENT
	MOVE	T1,T2		;
	PUSHJ	P,HPQSET	;GO CHECK HPQ LEGALITY
	PJRST	PRIERR##	;NOT LEGAL!
	DPB	T1,HPQSPT	;STORE THIS NEW VALUE
	POPJ	P,		;RETURN

> ;IFG HPQN
> ;IFN FTHPQ
> ;IFN SYS50N
IFE HPQN,<
	HPQ==:CPOPJ

HPQCMD::PJRST	COMERA##
>

IFN SYS50N,<
IFE FTHPQ,<IFG HPQN,<
PRINTX? ;PLEASE ASSEMBLE SOURCES WITH FTHPQ = -1
>>>
SUBTTL	PROCESS DATA BLOCK
;PDB
;PROTOTYPE PROCESS DATA BLOCK
;THIS DESCRIBES THE FORMAT OF A PDB, AND IS THE PDB FOR THE NULL JOB
; IF PDBS ARE SWAPPED. IT IS THE PROTOTYPE PDB IF PDBS ARE BUILT
; IN CORE.


PDBPRO::PHASE	0
.PDBEG:!BLOCK	1
XP	.PDIPT,.PDBEG		;IN CORE PROTECT TIME -- NUMBER OF
				; JIFFIES BEFORE JOB CAN BE SWAPPED OUT.

XP	.PDQNT,.PDBEG		;QUANTUM RUN TIME -- JIFFIES UNTIL
				; JOB SHOULD GO TO DIFFERENT RUN QUEUE

.PDCNO::!BLOCK	1		;USER'S CHARGE NUMBER


.PDKCT::!BLOCK	1		;PRODUCT OF CORE LENGTH (IN K) * NUMBER OF CLOCK TICKS
				; PROGRAM USED CPU.  USED FOR TIME ACCOUNTING.


.PDNM1::!BLOCK	1		;FIRST HALF OF USER'S NAME IN SIXBIT
.PDNM2::!BLOCK	1		;SECOND HALF OF USER'S NAME


.PDRTM::!BLOCK	1		;TOTAL RUNTIME SINCE LAST RUNTIME OR KJOB
				;NULL TIME FOR TOTAL SYSTEM IS KEPT FOR JOB 0
				;COUNTED BY BOTH CPU'S
				;SEE .CPNUL FOR INDIVIDUAL NULL TIME
.PDTTM::!BLOCK	1		;TOTAL RUNTIME SINCE LAST KJOB IN JIFFIES
.PDTT2::!BLOCK	1		;ADDITIONAL RUNTIME IN JIFFIES *10^-5
IFN FTKL10,<
.PDEBT::!BLOCK	1		;(KL10) TOTAL EBOX TIME USED IN JIFFIES
.PDEB2::!BLOCK	1		;REMAINDER IN EBOX COUNTS
.PDMBT::!BLOCK	1		;(KL10) TOTAL MBOX TIME USED IN JIFFIES
.PDMB2::!BLOCK	1		;REMAINDER IN MBOX COUNTS

>;END IFN FTKL10

.PDPGM::!BLOCK	1		;PROGRAM TO RUN ON CONTROL-C OR

				; RUN COMMAND

.PDABS::!BLOCK	1		;ADDRESS BREAK SETTINGS (ZERO IF USER IS
				; NOT ENABLED FOR ADDRESS BREAK).  1B0=1
				; IF BREAKING ON INSTRUCTION FETCH, 1B1=1
				; IF BREAKING ON DATA FETCH, 1B2=1 IF
				; BREAKING ON A WRITE, 1B6 (USER PAGING)
				; ALWAYS A 1, BIT 18-35=BREAK
				; ADDRESS

.PDCVL::!BLOCK	1		;CVPL,,CPPL
.PDMVL::!BLOCK	1		;MVPL,,MPPL

.PDDVL::!BLOCK	1		;POINTER TO TABLE OF POINTERS TO DDBS
				;  OWNED BY THIS JOB AND HAVING
				;  LOGICAL NAMES, OR ZERO IF NO
				;  SUCH DDBS, OR -1 IF TOO MANY TO
				;  FIT IN THE TABLE.

IFN FTIPCF,<
; NOTE THAT THE FOLLOWING ITEMS MUST REMAIN IN THE ORDER AND THAT .EPADR
; MUST BE LAST.
;
; .PDIPC, .PDIPA, .PDIPQ, .PDIPL, .PDPID, .PDIPI, .PDIPN, .PDQSN, .PDEPA
; .EPIPC, .EPIPA, .EPIPQ, .EPIPL, .EPPID, .EPIPI, .EPIPN, .EPQSN, .EPEPA .EPADR

.PDIPC::!BLOCK	1		;LH=POINTER TO FIRST PACKET
				;RH=SEND AND RECEIVE COUNTERS
.PDIPA::!BLOCK	1		;IPCF STATISTICS
.PDIPQ::!BLOCK	1		;FLAGS AND QUOTAS
.PDIPL::!BLOCK	1		;IPCF QUEUE INTERLOCK WORD
				;LH = JCH WHOSE QUEUE WE HAVE INTERLOCKED
				;RH = JCH WHO INTERLOCKED OUR QUEUE
.PDPID::!BLOCK	1		;PID FOR PID SPECIFIC RECEIVES
.PDIPI::!BLOCK	1		;PID OF THIS JOB'S SYS:INFO
.PDIPN::!BLOCK	1		;LH=POINTER TO LAST IN QUEUE
				;RH=0
.PDQSN::!BLOCK	1		;LH=FILE DAEMON SEQUENCE NUMBER
				;RH=QUEUE.  UUO SEQUENCE NUMBER
.PDEPA::!BLOCK	1		;RH=ADDRESS OF PACKET SENT IN RESPONSE TO AN
				;   EXEC PSUEDO-PROCESS IPCF MESSAGE
				;LH=0
>
IFN FTEQDQ,<
.PDEQJ::!BLOCK	1		;LH=0
				;RH=POINTER TO JOB QUEUE
.PDEQQ::!BLOCK	1		;LH=FLAGS
				;RH=ENQ QUOTA
;FLAGS IN LEFT HALF OF PDEQQ:
EQ.HBS==:(1B0)			;THE QUOTA HAS BEEN SET
>
.PDJSL::!BLOCK	<.SLWDJ>	;JOB SEARCH LIST
.PDJSE==:.			;FIRST WORD PAST SEARCH LIST

.PDNET==:.			;LEFT HALF IS THE ADDRESS OF A DDB WHICH
				; HAS AN ACTIVE CONNECT/DISCONNECT IN PROCESS.
.PDSCX::!BLOCK	1		;RIGHT HALF WORD IS ADDRESS OF JOB'S SAVED CONTEXT
.PDDIA::!BLOCK	1		;LOC OF DIAG. DDB FOR JOB

.PDSTR::!BLOCK	1		;STR PROGRAM CAME FROM
.PDNAM::!BLOCK	1		;NAME OF THE PROGRAM
.PDDIR::!BLOCK	1		;DIRECTORY PROGRAM CAME FROM
.PDSFD::!BLOCK	MAXLVL		;PATH TO PROGRAM
.PDDFL::!BLOCK	1		;WORD CONTAINING USER DEFINED DEFAULTS
				; 0-8 = DEFAULT FILE PROTECTION (MUST BE HIGH 9 BITS)
				; 1B9 IS NON-ZERO IF DEFAULT PROTECTION WAS SPECIFIED
				; 1B10 IS NON-ZERO IF FILE DAEMON SPECIFIED PROTECTION
				; 1B11 USE DEFAULT FILE SPEC ON RUN,GET
				; 1B12 DON'T ASK ABOUT DETACHED JOBS ON "LOGIN"
				; 1B13 PD.LGN
				; 1B14 .STPGM RUN IN PROGRESS
				; 18-26 = FILE DAEMON SUPPLIED PROTECTION
				; (MUST BE HIGH 9 BIT OF RH)
				; 27-35 DEFAULT NUMBER OF DISK BUFFERS

.PDCAP::!BLOCK	1		;MAXIMUM PRIVILEGES ALLOWED

.PDACS::!BLOCK	ACTSTL		;ACCOUNT STRING
.PDVKC::!BLOCK	1		;VIRTUAL TIME-CORE INTEGRAL

.PDUUC::!BLOCK	1		;COUNT OF UUOS DONE BY THIS JOB

IFN FTHPQ,<
.PDHZF::BLOCK	1		;ORIGINAL VALUE OF TIME IF FIT WAS
				; ZEROED BY HPQ JOB
>
IFN FTPSCD,<
.PDPST::BLOCK	1		;NEGATIVE OF SWAPOUT TIME
>
.PDOBI::BLOCK	1		;OPERATOR/BATCH INFO
IFN FTMDA,<
.PDSTM::BLOCK	1		;TIME OF LAST RESET
>
.PDLBS::BLOCK	1		;DEFAULT SIZE OF LARGE DISK BUFFER
				;LH=SET BY UUO, RH=SET BY COMMAND
.PDOSL::BLOCK	1		;OLD-STYLE LIB PPN
.PDSJB::BLOCK	1		;PTR TO DECNET SESSION CONTROL JOB BLOCK
.PDCMN::BLOCK	1		;AOBJN POINTER TO USER-DEFINABLE COMMAND NAMES
.PDUNQ::BLOCK	1		;POINTER TO LOCAL UNQTAB,,TABLE OF UDC BLOCKS

IFN M.CTX,<
.PDSAC::BLOCK	1		;ADDRESS OF FIRST CONTEXT BLOCK
.PDCTC::BLOCK	1		;ADDRESS OF CURRENT CONTEXT BLOCK
.PDCTQ::BLOCK	1		;CONTEXT QUOTA WORD
.PDCTU::BLOCK	1		;CONTEXT USE WORD
> ;END IFN M.CTX
.PDCTX::BLOCK	1		;CONTEXT FLAG WORD (MUST ALWAYS BE ASSEMBLED)
.PDTMI::BLOCK	1		;VIRTUAL TIMER TRAP INITIAL VALUE
.PDTMC::BLOCK	1		;COUNTDOWN FOR VIRTUAL TIMER TRAPS OR OLD PC
.PDVRT::BLOCK	1		;JOB PAGING RATE

IFN FTSCA,<
.PDSCS::BLOCK	1		;ADDRESS OF PROCESS QUEUE BLOCK FOR SCS. UUO
>; END IFN FTSCA

IFN FTENET,<
.PDEJB::BLOCK	1		;ADDRESS OF ETHERNET JOB BLOCK
>; END IFN FTENET

;	***   ADD NEW PDB ENTRIES BEFORE HERE   ***

IFDEF M.PCST,<IFN M.PCST,<	;DEFINE PDB SPACE FOR CUSTOMER USE
.PDCST::BLOCK	M.PCST		;CUSTOMER-SPECIFIC PDB STORAGE
>> ;END IFDEF/IFN M.PCST

.PDLEN==:.-.PDBEG		;LENGTH OF A PDB IN WORDS
PDBWDS==:.PDLEN!1777		;SIZE OF PDB IN WORDS ROUNDED UP TO
				; A PAGE BOUNDARY. THE WHOLE PROTO
				; PDB WILL MOVE TO COMMON FOR KI-10
				; NEEDS.
PDBPGS==:PDBWDS/1777		;SIZE OF PDB IN PAGES.
PDB4WD==:<.PDLEN+3>/4		;NUMBER OF 4 WORD BLOCKS REQUIRED FOR A PDB
.PDLE4==:4*PDB4WD		;LENGTH INCLUDING SPARE WORDS AT END OF LAST BLOCK

	BLOCK	.PDLE4-.PDLEN	;DEFINE UNUSED WORDS FOR PATCHING
	DEPHASE
	$ABS
	SUBTTL	SCHEDULER QUEUE DEFINITIONS
	;(10/40 SCHEDULER QUEUES ARE LOCATED IN CLKCSS)

IFN SYS50N,<

;SHARABLE DEVICE JUST BECOME AVAILABLE
;APPROPRIATE ENTRY IS SET NON-ZERO WHEN SCHEDULER SHOULD LOOK
;AT THAT QUEUE TO FIND A JOB TO RUN

DEFINE X(A,B,C)
<A'Q==:ZZ
ZZ==ZZ+1>
ZZ==0
QUEUES
DEFINE X(A,B,C)
<A'Q==:.-AVALTB+ZZ
A'AVAL::0
>


AVALTB::RWAITS	;GENERATE THE AVAL FLAGS
LOC=.-AVALTB+ZZ

XP AVTBMQ,AVALTB-ZZ
;TABLE CONTAINING JOB NUMBER OF THE OWNER OF A
; SHARABLE RESOURCE.  THE RIGHT HALF WORD CONTAINS
; THE JOB NUMBER OF THE JOB THAT CURRENTLY
; OWNS THE RESOURCE OR ZERO IF THE RESOURCE IS
; AVAILABLE.  THE LEFT HALF WORD CONTAINS THE JOB
; NUMBER OF THE LAST JOB WHICH GAVE UP THE RESOURCE.
; THIS TABLE IS USEFUL FOR DEBUGGING AND REQUIRED
; SO THAT IN THE EVENT OF CATASTROPIC ERROR, E.G.,
; SWAP READ ERROR, THE RESOURCE MAY BE FREED UP.

DEFINE X(A,B,C)
<	ZZ==ZZ+1>

ZZ==0
	QUEUES

DEFINE X(A,B,C)
<A'USER::	0
>
USRTAB::RWAITS
XP USTBMQ,USRTAB-ZZ

;DEFINE STATE CODES WHICH DO NOT HAVE AVAL AND REQ FLAGS


DEFINE X(A,B,C)
<A'Q==:LOC
LOC==LOC+1
>
	CODES

XP MXCODE,LOC-1	;MAX. JOB STATE CODE
;ANY QUEUES GREATER THAN CMQ MUST BE PROCESSOR QUEUES
CMQ==:LOC		;COMMAND DELAY QUEUE
LOC=LOC+1
PQ1==:LOC
LOC=LOC+1
PQ2==:LOC
LOC=LOC+1

DEFINE HPQCOD(A)
<	HPQ'A==LOC
	LOC==LOC+1>
IFG HPQN,<ZZ==1
	REPEAT	HPQN,<HPQCOD(\ZZ)
		ZZ==ZZ+1
			>
			>

;DEFINE SYMBOLS FOR PQ2 SUBQUEUES. SQ0=-1, SQ1=-2, ETC.
; USED FOR NEGATIVE INDICES TO JBTSQ.

	DEFINE	CLSGEN(A)
	<SQ'A==:A+1>

	ZZ==0
	REPEAT	M.CLSN,<
	CLSGEN(\ZZ)
	ZZ==ZZ+1>
	$HIGH
;PUT JOB DOWN A Q IF EXCEEDS QUANT. TIME
QRQTAB::XWD	PQ2,-PQ2	;FROM PQ1
	XWD	PQ2,-PQ2	;FROM PQ2
QTTAB::
DEFINE HPQTTB(A)
<	XWD HPQ'A,-HPQ'A>
IFG HPQN,<ZZ==1
	REPEAT	HPQN,<HPQTTB(\ZZ)
		ZZ==ZZ+1
			>
			>
XP QRQTBL,QRQTAB-PQ1		;TABLE MINUS OFFSET

	$ABS
; BASE QUANTA FOR QUEUES
QADTAB::QQRUN1			;PQ1
RNQUNT::<3*JIFSEC>/4		;PQ2
QQSTAB::
DEFINE HPQJIF(A)
<	EXP JIFY'A>
IFG HPQN,<ZZ==0
	REPEAT	HPQN,<ZZZ==HPQN-ZZ
	HPQJIF(\ZZZ)
		ZZ==ZZ+1
			>
			>

DEFINE JIFDEF(A)
	<JIFY'A==A*2>
	ZZ==1
REPEAT HPQN,<JIFDEF(\ZZ)
	ZZ==ZZ+1>
XP QADTBL,QADTAB-PQ1		;TABLE MINUS PQ1
; MULTIPLIER TABLE FOR RUN QUANTA BY QUEUES
QRANGE:: ^D45		;RANGE IN K BETWEEN SMALLEST AND LARGEST QUANTUM
			;  RUN TIME ASSIGNMENT

; ENTRIES ARE RANGE IN TICKS BETWEEN SMALLEST QUANTUM TO ASSIGN (QADTAB)
;  AND LARGEST QUANTUM TO ASSIGN (QMXTAB)
QMLTAB::0			;PQ1
	<3*JIFSEC>/4		;PQ2
REPEAT	HPQN,<	0			;NO MULTIPLIER FOR HPQS
>
XP QMLTBL,QMLTAB-PQ1		;TABLE MINUS PQ1

;MAXIMUM ALLOWABLE RUN QUANTO FOR QUEUES
QMXTAB::QQRUN1			;PQ1
	<JIFSEC*3>/2		;PQ2
IFG HPQN,<ZZ==0
	REPEAT	HPQN,<ZZZ==HPQN-ZZ
	HPQJIF(\ZZZ)
		ZZ==ZZ+1
			>
			>
XP QMXTBL,QMXTAB-PQ1		;TABLE MINUS PQ1
	$HIGH
ISCAN::	;SCAN FOR INPUT - GETTAB TABLE 45

DEFINE HPQSCN(A)
<	XWD -HPQ'A,QFOR##>
IFG HPQN,<ZZ==0
	REPEAT	HPQN,<ZZZ=HPQN-ZZ
		HPQSCN(\ZZZ)
		ZZ==ZZ+1
		>
		>

	XWD	-CMQ,QFOR##	;MONITOR COMMAND WHICH NEEDS CORE IMAGE IN CORE
	XWD	-PQ1,IQFOR##	;GET PEOPLE WHO GETSEGED FIRST
	XWD	-PQ2,IGFOR##	;BUT JUST THOSE WITH QUANTA LEFT
FISCAN::XWD	-PQ1,OQFOR##
IFE FTNSCHED,<
	XWD	-PQ2,FOQFOR##	;FAIRNESS HERE
>
IFN FTNSCHED,<
	XWD	-PQ2,FSQFOR##	;FAIRNESS HERE
>
	XWD	-PQ2,IQFOR##
IFN FTNSCHED,<
	XWD	-PQ2,BQFOR##
>
ISTMXL==:<.-ISCAN-1>B26	;MAKE ENTRY IN GETTAB FOR INPUT SWAP SCAN LIST
IFN FTPATT,<
	Z		;PATCH SPACE
	Z
>
	Z		;FINAL ZERO TO FLAG END

ISCAN1::		;ALTERNATE INPUT SCAN
IFG HPQN,<ZZ==0
	REPEAT	HPQN,<ZZZ=HPQN-ZZ
		HPQSCN(\ZZZ)
		ZZ==ZZ+1
		>
		>

	XWD	-CMQ,QFOR##	;MONITOR COMMAND WHICH NEEDS CORE IN
IFE FTNSCHED,<
	XWD	-PQ2,FOQFOR##
>
IFN FTNSCHED,<
	XWD	-PQ2,FSQFOR##
>
	XWD	-PQ1,OQFOR##
	XWD	-PQ2,IGFOR##
	XWD	-PQ1,IQFOR##
	XWD	-PQ2,IQFOR##
IFN FTNSCHED,<
	XWD	-PQ2,BQFOR##
>
IFN FTPATT,<
	Z		;PATCH SPACE
	Z
>
	Z		;FINAL ZERO TO FLAG END

;TABLE FOR SCHED. FUNCTION 30 (SELECT ON A /CPU BASIS ORDER OF Q SCAN
CPSCAN::SSCAN		;SUBFUNCTION 0,SCAN USING SSCAN,(P01,PQ2)
	SSCAN1		;SUBFUNCTION 1,SCAN USING SSCAN1,(PQ2,PQ1)
IFN FTPATT,<
	Z		;PATCH SPACE
	Z
>
CPSTBL==:.-CPSCAN-1	;LENGTH
	$ABS
	SSCN=:-3		;SECONDARY SCAN TABLE ADDRESS
	EXP	SSCAN1
	MFC=:-2		;MAXIMUM FAIRNESS COUNT
	EXP	SFC0
	FSCN=:-1		;ENTRY IN SCAN TABLE OF FIRST FAIR LOCATION
	EXP	FSCAN
SSCAN::			;SCHEDULER SCAN LIST - GETTAB TABLE 47
DEFINE HPQSCN(A)
<	XWD -HPQ'A,IQFOR##>
IFG HPQN,<ZZ=0
	REPEAT	HPQN,<ZZZ=HPQN-ZZ
		HPQSCN(\ZZZ)
		ZZ=ZZ+1
		>
		>

	XWD	-PQ1,IQFOR##	;SCHEDULER'S SCAN FOR NEXT JOB TO RUN
FSCAN:
IFE FTNSCHED,<
	XWD	-PQ2,IRRFOR
>
IFN FTNSCHED,<
	XWD	-PQ2,ISSFOR##
	XWD	-PQ2,IBBFOR##
>
SSTMXL==:<.-SSCAN-1>B26	;MAX ENTRY FOR GETTAB
IFN FTPATT,<
	Z		;FOR PATCHING
	Z
>
	Z		;FINAL ZERO TO FLAG END
;SLAVE PROCESSOR SCAN TABLE FOR CPU SCHEDULING


	EXP	SSCAN		;SECONDARY SCAN TABLE FOR SLAVE
	EXP	SFC1		;MAXIMUM FAIRNESS COUNT
	EXP	FSCAN1		;ENTRY POINT IN SCAN TABLE OF FIRST FAIR TABLE
SSCAN1:

	IFG	HPQN,<
		ZZ==0
		REPEAT HPQN,<ZZZ=HPQN-ZZ
			HPQSCN(\ZZZ)
			ZZ==ZZ+1
			>
			>

IFE FTNSCHED,<
	XWD	-PQ2,IRRFOR
>
IFN FTNSCHED,<
	XWD	-PQ2,ISSFOR##
>
FSCAN1:	XWD	-PQ1,IQFOR##	;IF NO JOBS TRY PQ1
IFN FTNSCHED,<
	XWD	-PQ2,IBBFOR##
>
IFN FTPATT,<
	Z		;FOR PATCHING
	Z
>
	0
	$HIGH
LSCAN::			;SCAN FOR LOST TIME
DEFINE HPQSCN(A)
<	XWD -HPQ'A,OQFOR##>
IFG HPQN,<
	ZZ==0
	REPEAT HPQN,<ZZZ=HPQN-ZZ
		HPQSCN(\ZZZ)
		ZZ==ZZ+1
			>
		>
	XWD	-PQ1,OQFOR##	;PQ1 NO CORE FORWARD
IFE FTNSCHED,<
	XWD	-PQ2,OQFOR##	;PQ2 NO CORE FORWARD
>
IFN FTNSCHED,<
	XWD	-PQ2,OSSFOR##	;PQ2 NO CORE SUB QUEUES FORWARD
				;INCLUDES NO CORE BACKGROUND BATCH
>
	0
;NOTE - FOR BEST RESULTS OSCAN SHOULD BE IN
; REVERSE ORDER OF ISCAN, ELSE SCHEDULER BINDS

OSCAN::	;SCAN FOR OUTPUT - GETTAB TABLE 46
	XWD	-STOPQ,IQFOR##	;UNRUNABLE JOBS FIRST
	XWD	-SLPQ,IQFOR##
	XWD	-EWQ,IQFOR##	;EVENT WAITERS
	XWD	-JDCQ,IQBAK1##
	XWD	-TIOWQ,IQFOR##	;TTY IOW
	XWD	-JDCQ,IQFOR1##
	XWD	-PQIOQ,IQFOR##	;PAGE QUEUE WAIT
OTHQUE==.-1
PQ2QUE:	XWD	-PQ2,OLFOR##	;INCLUDES -PQ2,IQBAK AS SUBCASE
PQ1QUE:	XWD	-PQ1,IQBAK##
CMQUE:	XWD	-CMQ,IQBAK##

DEFINE HPQSCN(A)
<HPQU'A:	XWD -HPQ'A,IQBAK##>
IFG HPQN,<ZZ=1
	REPEAT	HPQN,<HPQSCN(\ZZ)
		ZZ=ZZ+1
		>
		>

OSTMXL==:<.-OSCAN-1>B26		;MAX. ENTRY IN GETTABS
IFN FTPATT,<
	Z			;PATCH SPACE
	Z
>
	Z			;FINAL ZERO TO FLAG END
; TABLE OF WHAT QUE ENTRY IS LAST TO SCAN FOR SWAP OUT
OSCANT::OTHQUE			;WHERE TO STOP IF NOT CMQ OR PROCESSOR QUEUE
	CMQUE			;WHERE TO STOP IF CMQ
	PQ1QUE			;WHERE TO STOP IF PQ1
	PQ2QUE			;WHERE TO STOP IF PQ2
	DEFINE HPQSTP(A)
<	HPQU'A>
IFG HPQN,<
	ZZ=1
	REPEAT HPQN,<HPQSTP(\ZZ)
		ZZ=ZZ+1
>
>
OSCNTQ=:OSCANT+1-CMQ		;MAKE AN INDEX INTO STOP TABLE
>				;END 10/50 QUEUE DEFINITIONS
; SPECIAL SCAN TABLE FOR DECREMENTING IN CORE PROTECT TIMES
; PROCESSOR QUEUES MUST BE IN REVERSE ORDER SO THAT REQUEING
; DUE TO EXPIRATION OF ICPT DOES NOT PUT JOB WHERE WE WILL SEE
; IT AGAIN (QUEUES ARE ALSO SCANNED IN REVERSE)
; MUST ALSO CONTAIN ANY OTHER PHYSICAL QUEUE WHICH IS ALLOWED TO
;  RETAIN ICPT. CURRENTLY THIS IS ONLY SLP AND EW.

DCSCAN::EXP	-EWQ		;EVENT WAIT QUEUE
	EXP	-SLPQ		;SLEEP QUEUE
	EXP	-PQ2		;PQ2
	EXP	-PQ1		;PQ1
	DEFINE HPQSCN(A)
<	EXP	-HPQ'A>
IFG HPQN,<
ZZ==1
	REPEAT HPQN,<HPQSCN(\ZZ)
		ZZ==ZZ+1
>
>
IFN FTPATT,<
	0
	0
>
	0
IFN FTNSCHED,<
$ABS
;SUBQUEUE INPUT SCAN TABLE
;
;FOR GENERATING PRIMARY SCAN TABLE, ENTRIES CONTAIN:
; PRIORITY COUNTER IN LEFT HALF,
; SUBCLASS NUMBER IN RIGHT HALF.
;
;FOR GENERATING SECONDARY INPUT SCAN, ENTRIES CONTAIN:
; MINUS SUBQUEUE NUMBER IN LEFT HALF,
; SECONDARY QUOTA IN RIGHT HALF.

SQSCAN::BLOCK	M.CLSN

SQCNT::	0			;COUNTER OF LOCATIONS LEFT IN PRIMARY SCAN TABLE
SQPNT::	0			;POINTER TO CURRENT LOC IN PRIMARY SCAN TABLE
SQSUM::	0			;SUM OF SECONDARY PERCENTS
SQSAVJ::0			;NUMBER OF CLASS ALREADY SCANNED
SCNJIL::0			;TIME TO STOP SCANNING JBTJIL
SCNSWP::0			;# TICS SAME PRIMARY SUBQUEUE HAS BEEN SCANNED
SCNBBS::0			;TIME TO SWAP NEXT BB JOB
BBFIT::	0			;NON-ZERO IF BACKGROUND BATCH JOB BEING FIT
BBFLAG::0			;NON-ZERO IF BACKGROUND BATCH QUEUE BEING SCANNED

>;END IFN FTNSCHED
$ABS
SEED::	377775			;SEED FOR RANDOM NUMBER
$HIGH
IFN FTNSCHED,<
$ABS
;SUBQUEUE SCAN TABLE FOR CPU0
;
;ENTRIES CONTAIN:
; MINUS SUBQUEUE NUMBER.
; TABLE TERMINATES WITH A ZERO.

SSSCAN::BLOCK	M.CLSN
	0			;ZERO TERMINATES TABLE
SSCNT::	0			;COUNTER OF ENTRIES LEFT IN PRIMARY SCAN TABLE
SSPNT::	0			;POINTER TO PRIMARY SCAN TABLE FOR CPU0
SSSUM::	0			;SUM OF SECONDARY PERCENTS
IFN FTMP,<
;SUBQUEUE SCAN TABLE FOR CPU1
SSSCN1::BLOCK	M.CLSN
	0			;ZERO TERMINATES TABLE
SSPNT1::0			;POINTER TO PRIMARY SCAN TABLE FOR CPU1
>
;PRIMARY SCAN TABLE
;STORED AS 101 5-BIT ENTRIES, ONE FOR EACH PERCENT OF THE SYSTEM RESOURCES
; ENTRY 101 IS A DUPLICATE OF ENTRY 1.
PSQTAB::BLOCK	^D15		;ROOM FOR 101 ENTRIES
$HIGH
>;END IFN FTNSCHED
SUBTTL MINIMUM CORE USAGE DATA TABLES

;TABLE OF INDICES TO FIRST POSITION ON TABLES BELOW FOR VARIOUS KONTROLLER TYPES
TYPTAB::EXP	FRSTDR##	;TYPE 0 (DR) FUTURE DRUM, IF ANY
	EXP	FRSTFH##	;TYPE 1 (FH) BURROUGHS DISK OR BRYANT DRUM
	EXP	FRSTDP##	;TYPE 2 (DP) RP10 KONTROLLER RP01, RP02, RP03 DRIVES
	EXP	FRSTMD##	;TYPE 3 (MD) BRYANT MASS DISK
	EXP	FRSTFS##	;TYPE 4 (FS) RH10/RS04
	EXP	FRSTRP##	;TYPE 5 (RP) RH10/RP04
	EXP	FRSTRN##	;TYPE 6 (RN) RP20
	EXP	FRSTRA##	;TYPE 7 (RA) RA80/81/60

;TABLES COMPUTED BY ONCMOD
;UNITS ARE MICROSECONDS

;AVERAGE TIME PER PAGE (K) TABLE COMPUTED BY ONCMOD

MCUATP:: Z			;FUTURE DRUM
	Z			;DITTO
	Z			;RD10
	Z			;RM10B
	Z			;RP01
	Z			;RP02
	Z			;RP03
	Z			;DUAL POSITIONER MD10
	Z			;SINGLE POSITIONER MD10
	Z			;RS04
	Z			;RP04
	Z			;RP06
	Z			;RM03
	Z			;RP07
	Z			;RP20
	Z			;RA80
	Z			;RA81
	Z			;RA60

;AVERAGE LATENCY TIME TABLE COMPUTED BY ONCMOD

MCUALT:: Z			;FUTURE DRUM
	Z			;DITTO
	Z			;RD10
	Z			;RM10B
	Z			;RP01
	Z			;RP02
	Z			;RP03
	Z			;DUAL POSITIONER MD10
	Z			;SINGLE POS. MD10
	Z			;RS04
	Z			;RP04
	Z			;RP06
	Z			;RM03
	Z			;RP07
	Z			;RP20
	Z			;RA80
	Z			;RA81
	Z			;RA60
	$LIT			;GENERATE ALL LITERALS BEFORE RELOC
	LOLOC==ABSLOC-COMORG	;HIGHEST ABSOLUTE ADDRESS USED
	$LOW
	RELOC	LOLOC		;MAKE SURE .LOW. INCLUDES ALL ABSOLUTE CODE

;DEFINE LIMIT FOR PSECT .LOW. SO SYMBOLS DON'T OVERLAP PSECT HIGH (OR .HIGH.)
;AND SO THE SYMBOLS FOLLOW PSECT .LOW.

DEFINE	LIMIT(MAX),<
	.TEXT	"/LIMIT:.LOW.:'MAX'"
>; END DEFINE

	LIMIT	(\<MONORG-1>)

;DEFINE PSECT FOR SYMBOLS.  FOR SINGLE SECTION MONITOR USE .LOW., FOR
;MULTI SECTION USE A SEPARATE PSECT BEGINNING IN SECTION 2.
;NOTE:  UNTIL EDDT/FILDDT UNDERSTAND EXTENDED SYMBOL TABLES USE THE
;IFE FTXMON CASE FOR ALL MONITORS.

IFE FTXMON,<
	.TEXT	"/SYMSEG:PSECT:.LOW."
>; END IFE FTXMON
IFN FTXMON,<
DEFINE	SYMSEG(ORIGIN),<
	.TEXT	"/SET:SYMSEG:'ORIGIN'/SYMSEG:PSECT:SYMSEG"
>; END DEFINE

	SYMSEG	(\<MS.HGH>)
>; END IFN FTXMON

IFNDEF	FTCMBTH,<END	SYSTRT>	;END UNLESS ASSEMBLING COMMONS TOGETHER
   5{,U7