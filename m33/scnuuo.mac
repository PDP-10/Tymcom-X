TITLE	SCNSER - UUO interface to terminals (via TYMNET)
;This file must be assembled with TYMSER.MAC+TTYSYM.MAC+SCNSER.MAC

	 STOPCD (,ENTRY,SCNSER)

;DISPATCH TABLE FOR MUUO'S AND INITIALIZATION

SCNDSP:	PHASE 0
DDXZ:	DSPSIZ
DDINT:	POPJ P,
DBYT:	1000,,1000
DVSIZ:	MOVEI T1,SCNDDS
DINI:	JRST TTYINI
DHNG:	JRST CPOPJ1
DRL:	POPJ P,
DCL:	JRST OUT
DOU:	JRST TTYOUT
DIN:	JRST TTYIN
DZAP:	JRST AUXZAP
	DSPSIZ==.-1
	DEPHASE
SUBTTL DEVICE DATA BLOCK

;TTY DDB. ONCE CREATES ONE OF THESE PER JOB FOR TTYTAB TO POINT TO.

TTYLST:		;LABEL FOR FIRST TTY DDB IN CHAIN
SCNDDB::PHASE	0	;GLOBAL LABEL
	SIXBIT /TTY0/		;DEVNAM (PHYSICAL NAME)
	XWD 0,STTYBF+1		;DEVCHR. SIZE OF USER BUFFER
	0			;DEVIOS
	XWD 0,SCNDSP		;DEVSER (LH points to next in list)
	XWD DVTTY+DVIN+DVOUT,<<1_B>+<1_A>+<1_AL>+<1_I>+<1_IB>+<1_XA>>
				;DEVMOD
	0			;DEVLOG (LOGICAL NAME)
	0			;DEVBUF
	0			;DEVIAD
	0			;DEVOAD
DEVCLS:! XWD 200000,0		;CLASS
DDBDCH:! 0	;PROCESS-RELATED DEVICE CHARACTERISTICS NOT IN DEVIOS
	DCLBBP==400000	;0	BACKSPACE IS PUNCTATION (DDPBBP)
	DCLTBK==200000	;1	TABS ARE BREAKS (DDPTBK)
	DCLNTB==100000	;2	DON'T ECHO HT/VT/FF (DDPNTB)
	DCLCOM==040000	;3	SAVED STATE OF LDLCOM (DDPCOM)
			;27-35	IMAGE MODE BREAK CHARACTER (DDPIMB)
DDBBLK::!			;(LH) BACK LINK (PREVIOUS TTY DDB)
DDBLDB::!0			;(RH) LDB ADDR
DDBTRP:! BLOCK <TRPLEN+5>/6	;INTERRUPT-TO-CHANNEL ASSIGNMENTS
	DEPHASE
SCNDDS==:.-SCNDDB

;OTHER DDB BYTE POINTERS

DDPBBP:	POINT 1,DDBDCH(F),0	;BACKSPACE AS PUNCTUATION
DDPTBK:	POINT 1,DDBDCH(F),1	;TABS ARE BREAKS
DDPNTB:	POINT 1,DDBDCH(F),2	;NO SPECIAL TAB ACTION
DDPIMB: POINT 9,DDBDCH(F),35	;IMAGE MODE BREAK CHARACTER
DDPMOD: POINT 4,DEVIOS(F),35	;DATA MODE
DDPCOM: POINT 1,DDBDCH(F),3	;SAVED STATE OF LDLCOM
DDPNZP:	POINT 1,DEVMOD(F),5	;NO-ZAP BIT
SUBTTL	TTY FILE STATUS BITS

;LEFT HALF

TTYOUW==:400000	;0	TI MEANS OUTPUT WAIT, NOT INPUT WAIT
TWTSPC== 200000	;1	TI BECAUSE SYSTEM OUT OF BUFFERLETS
IOSBKA== 100000	;2	BREAK ON ALL CHARACTERS
TINFIO== 040000	;3	CAUSE AN OUTPUT-DONE INTERRUPT WHEN OUTPUT DONE
TIOUSE== 020000	;4	UUO IN PROGRESS, DON'T ZAP DDB

;RIGHT HALF

BK2IOS== 001000	;26	BREAK ON PUNCTUATION
DLRSUP== 000400	;27	NO ESCAPE ECHO
NOECHO== 000200	;28	NO ECHO
FCS==    000100	;29	FULL CHARACTER SET
SUBTTL	RANDOM LDB BYTE POINTERS

TRMBYP:	POINT  5,LDBLOG(U),11	;Terminal ID code (see also LLLHDX)

LDPLNO::POINT  9,LDBLIN(U),35	;Port number (TTY0 thru TTY777)
LDPHST:	POINT 16,LDBLIN(U),17	;Origination host number (new in EBUS 2.01)

LDPTBK:	POINT 1,LDBBYT(U),2	;TABS-AS-BREAKS
LDPBBP:	POINT 1,LDBBYT(U),3	;BACKSPACE-AS-PUNCTUATION
LDPNTB:	POINT 1,LDBBYT(U),4	;NO SPECIAL TAB HANDLING
LDPBSP:	POINT 1,LDBBYT(U),8	;BS OR ERASE FOR CHAR DELETE
LDPMOD:	POINT 2,LDBBYT(U),11	;MONITOR MODE
LDPFC2:	POINT 2,LDBBYT(U),13	;FILLER CLASS 2
LDPFA2:	POINT 2,LDBBYT(P1),13
LDPWID:	POINT 8,LDBBYT(U),21	;LINE WIDTH
LDPWDA:	POINT 8,LDBBYT(P1),21
LDPFC1:	POINT 2,LDBBYT(U),23	;FILLER CLASS 1
LDPFA1:	POINT 2,LDBBYT(P1),23
LDPTIM:	POINT 4,LDBBYT(U),27	;IMAGE INPUT TIMEOUT TIMER
LDPPOS:	POINT 8,LDBBYT(U),35	;ESTIMATED POSITION ON LINE

LDPPSM:	POINT 4,LDBMOD(U),5	;LAST PORT-STATUS MSG
LDPCHG:	POINT 7,LDBMOD(U),15	;IMAGE COUNT FOR CHARGING
LDPLMD:	POINT 7,LDBMOD(U),22	;ALL THE LINE MODE (INPUT AND ECHO)
LDPMEC:	POINT 3,LDBMOD(U),18	;ECHO LINE MODE
LDPMIN:	POINT 4,LDBMOD(U),22	;INPUT LINE MODE
LDPIMB:	POINT 9,LDBMOD(U),31	;IMAGE MODE BREAK CHARACTER
LDPMOU:	POINT 4,LDBMOD(U),35	;OUTPUT LINE MODE

LDPSOX:	POINT 1,LDBDCH(U),1	;SUPPRESS OUTPUT TRANSLATION
LDPCOM:	POINT 1,LDBDCH(U),4	;COMMAND MODE BIT
LDPMDF:	POINT 5,LDBDCH(U),8	;SOURCE OF LINE MODE INFO
LDPNFC:	POINT 1,LDBDCH(U),10	;NO FREE CRLFS
LDPLCT:	POINT 1,LDBDCH(U),13	;LOWER CASE TRANSLATION (TO UPPER)
LDPTAB:	POINT 1,LDBDCH(U),14	;HARDWARE TABS
LDPPTP:	POINT 1,LDBDCH(U),16	;PAPER TAPE MODE
LDPFRM:	POINT 1,LDBDCH(U),17	;HARDWARE FF/VT
LDPNXO:	POINT 1,LDBDCH(U),20	;DON'T SEND XON/XOFF
LDPDEM:	POINT 1,LDBDCH(U),21	;PERPETUAL DEFERRED ECHO MODE

LDPBSD:	POINT 1,LDBDCX(U),2	;BACKSPACE == RUBOUT/^A
LDPERA:	POINT 1,LDBDCX(U),3	;ERASE ON CHAR DEL
LDPLCO:	POINT 1,LDBDCX(U),5	;LOWER CASE OUTPUT ONLY
LDPRTC:	POINT 1,LDBDCX(U),7	;[Darren] special ^T mode
LDPCLA:	POINT 36,LDBCLA(U),35	;Terminal CLASS
LDPTYP:	POINT 36,LDBTYP(U),35	;Terminal TYPE
SUBTTL	INPUT UUO PROCESSOR - CALLED FROM UUOCON ON INPUT M, F SET UP

TTYIN:	PUSHJ	P,CKATTI	;MAKE SURE ATTACHED. SET S.
	  JRST	ABTUUO		;WAITING FOR AN INTERRUPT. ABORT
	JUMPE	U,[MOVSI S,IOEND
		JRST TTYINX]	;ZAPPED AUX CIRCUIT GIVE EOF
	NOCHARGE
	PUSHJ	P,FIXIMI	;SET IMAGE STATE FROM DATA MODE
	PUSHJ	P,TWAITL	;BECOME ATTACHED, WAIT FOR U
				; OR FULL BUFFER CONDITION
	TLNN	U,LDLIMI	;IMAGE HAS ALREADY CHARGED
	PUSHJ	P,SETBRK	;CHARGE FOR A BREAK CHR
TTYIN5:	HRRZ	T1,DEVIAD(F)		;PREPARE AND ADDR CHECK THE
	PUSHJ	P,BUFCLR		; USER'S BUFFER
	  JRST	ADRERR			;OUT OF BOUNDS. STOP JOB.
	HRRZ	P1,DEVIAD(F)		;PREPARE BYTE POINTER TO STORE
					; THE CHARACTERS IN HIS BUFFER
	XCTFU <LDB P2,[POINT 17,(P1),17]>	;BUFFER SIZE IN WORDS
	SUBI	P2,1			;MINUS LINK
	HRRZ	U,DDBLDB(F)		;RESTORE U, CLOBBERED IN UUOCON
	HLL	U,LDBDCH(U)	;ALSO GET BITS
	HRRZ	T1,DEVBUF(F)	;BUFFER POINTER FOR SIZE
	PUSHJ	P,TTYSZS		;SET SIZES
					;FALL INTO MAIN PART OF ROUTINE

TTYIN1:	PUSHJ	P,TYI			;GET A CHARACTER
	  JRST	TTYIN3			; END OF BUFFER.
	ANDI	T3,377
	XCTFU <IDPB T3,P1>			;AND STORE IN USER AREA
	CAIE	T2,%CHBRK		;A BREAK?
	SOJG	P2,TTYIN1			;NO. LOOP FOR MORE, IF ROOM.
TTYIN3:	MOVE	P2,DEVIAD(F)		;COMPUTE WORD COUNT FOR UUOCON
	SUBI	P1,1(P2)			; TO PUT IN BUFFER HEADER.
	XCTFU <HRRM P1,1(P2)>			;STORE WITH THE DATA IN RING
	PUSHJ	P,ADVBFF			;ON TO NEXT BUFFER
	  SKIPA				;NO MORE THERE.
	JRST	TTYIN6			;MORE TO GO. USE IF IMAGE.
TTYIN8:	MOVSI	S,IOFST			;SET VIRGIN BUFFER BIT
TTYINX:	IORB	S,DEVIOS(F)		;IN DEV S WORD IN F
	PJRST	NOCTRO			;CLEAR CONTROL O. END OF Muuo

TTYIN6:	TRNE	S,I			;IMAGE MODE?
	SKIPG	LDBTIC(U)		;AND MORE CHARACTERS TO READ?
	 JRST	TTYIN8			;NO. QUIT.
	JRST	TTYIN5			;YES. GO PASS SOME MORE

SETBRK:	TLNE	U,LDLIMI
	 POPJ	P,			;IMAGE IS ALREADY CHARGED FOR
	LDB	J,PJOBN
	PUSHJ	P,GTCGSZ	;GET THE JOB'S CHARGING SIZE.
	ADDM	T1,JBTBCS(J)	;ONE BREAK CHR
	ADDM	T1,JBTBCS
	POPJ	P,

IMGCNT:	LDB	T1,LDPIMB	;GET IMAGE BREAK CHR
	CAMN	T1,T3	;IS IT THIS ONE?
	 JRST	IMGCH1	;YES, GO CHARGE
	LDB	T1,LDPCHG
	ADDI	T1,1
	CAIL	T1,TIWKC	;ENOUGH GONE BY TO CHARGE?
	 JRST	IMGCHG	;YES
	DPB	T1,LDPCHG	;NO, JUST RECORD
	POPJ	P,

IMGCH1:	MOVEI	T4,TIWKC	;SO CALLER WILL THINK MANY CHRS
IMGCHG:	MOVEI	T1,0
	DPB	T1,LDPCHG	;SET CHARGE COUNTER TO 0
	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ	;NO LINE
	JRST	SETBRK	;GO CHARGE FOR 1 BCS

TTYSZS:	XCTBU <LDB T2,[POINT 6,1(T1),11]>	;GET POINTER SIZE
	DPB	T2,[POINT 6,P1,11]	;SET IN P1 POINTER
	MOVEI	T1,^D36
	IDIV	T1,T2		;NUMBER OF CHRS/WORD
	IMUL	P2,T1		;NUMBER OF CHRS IN BUFFER
	AOJA	P1,CPOPJ	;ADD 1 TO POINT TO FIRST DATA WORD
SUBTTL	OUTPUT UUO
;CALLED ON OUTPUT OR OUTPUT CLOSE, FROM UUOCON, WITH F SET UP.

TTYOUT:	PUSHJ	P,CKATTO	;FIRST, MAKE SURE THERE'S A LINE
	  JRST	ABTUUO		;WAITING FOR AN INTERRUPT
	JUMPE	U,TTYOUS	;ZAPPED AUX CIRCUIT
	PUSHJ	P,CHKROM	;MAKE SURE ROOM FOR THIS CHR
	  JRST	TTYOUT		;NO ROOM.
	NOCHARGE
	PUSHJ	P,CLRIMI	;CLEAR IMAGE INPUT STATE
	MOVSI	S,IOBEG		;IS THIS THE FIRST BUFFER AFTER INIT?
	MOVSI	T1,LDLOSU	;IF SO, WILL KILL ^O ACTION
	TDNN	S,DEVIOS(F)	;CHECK F
	 JRST	TTOUT1		;NO.
	ANDCAM	S,DEVIOS(F)	;YES. CLEAR BEG BIT,
	ANDCAM	T1,LDBDCH(U)	; AND CONTROL O BIT
TTOUT1:	TDNE	T1,LDBDCH(U)	;IS CONTROL O ON NOW?
	 JRST	TTOUT5		;YES. SKIP THIS WHOLE BUFFER.
	MOVSI	S,IO+IOFST	;MARK OUTPUT, AND FIRST OF BUFFER
	IORB	S,DEVIOS(F)	;IN DEVICE DATA BLOCK
	HRRZ	P1,DEVOAD(F)	;CHECK ADDRESSES OF OUTPUT BLOCK
	XCTFU <HRRZ P2,1(P1)>	;GET WORD COUNT
	HLRZ	T1,DEVBUF(F)	;GET POINTER TO BUFFER HEADER
	PUSHJ	P,TTYSZS
TTOUT2:	TRNE	P2,777		;TIME TO LET SOMEONE ELSE RUN?
	 JRST	TTOUT3		;NO
	PUSHJ	P,WSCHED	;YES -- RESCHEDULE
	HRRZ	U,DDBLDB(F)	;STILL ATTACHED?
	JUMPN	U,TTOUT3	;YES -- GO AHEAD
	PUSHJ	P,CKATTF	;NO -- WAIT FOR REATTACH
TTOUT3:	XCTFU <ILDB T3,P1>	;GET A USER'S CHARACTER
	TRNE	S,I		;SEE IF IMAGE MODE
	 TROA	T3,400		;YES. SET BIT FOR SUPPRESSING FILLERS
	  TRZ	T3,400		;ELSE CLEAR IN CASE EXTENDED
	JUMPE	T3,TTOUT4	;DON'T OUTPUT NULLS
	PUSHJ	P,TYO		;OUTPUT THIS CHARACTER (WAIT IF NEEDED)
	  JRST	XPNOUT		;TYO WANTS AN INTERRUPT (SEE TYO)
TTOUT4:	SOJG	P2,TTOUT2		;COUNT USER'S ITEMS.
TTOUT5:	PUSHJ	P,ADVBFE		;ADVANCE HIS BUFFERS
	  JFCL			;JUST SINGLE BUFFER FOR NOW
	MOVEI	S,IOACT		;CLEAR ACTIVE BIT.
	ANDCAB	S,DEVIOS(F)	;IN DEVICE DATA BLOCK FOR THE JOB
	MOVEI	T1,1
	DPB	T1,LOPOUT
	DPB	T1,LDBOPB(U)
	POPJ	P,
SUBTTL	TYO GAVE ERROR RETURN - NO MORE ROOM IN TTY CHUNCKS
XPNOUT:	PUSHJ	P,CKATTF		;HE MUST BE ATTCHED
	MOVSI	T1,L2LOEX
	IORM	T1,LDBBYT(U)	;SET FOR EXPANDED OUTPUT
	MOVE	T1,LDBTOC(U)
	CAML	T1,TOEMAX		;ALREADY TOO MANY FOR EXPANDED?
	AOS	(P)			;YES SKIP RETURN (TO TYO)
				;WILL GET US INTO OUTPUT WAIT
	POPJ	P,			;NON-SKIP RETURN (TO TYO) GO NOW

TTYOUS:	PUSHJ	P,ADVBFE	;SKIP THIS BUFFER
	  JFCL
	MOVEI	S,IOACT
	ANDCAB	S,DEVIOS(F)	;JUST TO MAKE SURE
	POPJ	P,
SUBTTL DDT MODE CALLI'S

;INPUT TO DDT	- CALL AC,[SIXBIT /DDTIN/]  WHERE AC/ ADDR
;ADDR GETS UP TO 21 WORDS OF ASCIZ, BREAKING ON ANY CHARACTER

DDTIN::	PUSHJ	P,TTYFNU		;SET U AND F FOR THIS TTY
	PUSHJ	P,CKATTI		;CHECK FOR ATTACHED
	  JRST	ABTUUO			;INTERRUPT, GET OUT OF UUO
	NOCHARGE
	XCTFU <HRRZ P2,(M)>
	HRLI	P2,440700		;SEVEN BIT BYTES, RELOCATED.
	MOVEI	P1,<21*5>-1		;NUMBER OF BYTES ALLOWED
	PUSHJ	P,TWAITC		;GET AT LEAST ONE CHARACTER
	PUSHJ	P,SETBRK		;ONE BREAK CHR
DDTINL:	SKIPG	LDBTIC(U)		;ANY MORE TO COME?
	 JRST	DDTINX			;NO.
	PUSHJ	P,TYI			;YES. GO GET ONE
	  JRST	DDTINX			;WASNT ANY. I'M CONFUSED.
	TRNE	T3,177			;NULL?
	XCTFU <IDPB T3,P2>		;NO. STORE IN USER AREA
	SOJG	P1,DDTINL		;IF MORE SPACE, GET ANOTHER CHARACTER
DDTINX:	MOVEI	T3,0			;FLAG END OF STRING
	XCTFU <IDPB T3,P2>		; IN USER AREA
	PJRST	NOCTRO			;AND RETURN TO USER, CLEARING ^O FLAG

;DDTOUT - CALL AC,[SIXBIT /DDTOUT/], AC/ ADDR, ADDR/ ASCIZ /XXX/

DDTOUT::UMOVE	M,(M)	;GET ADDRESS
	MOVEI	W,3
	JRST	TTYUUO	;HANDLE LIKE OUTSTR
SUBTTL HANG UUO

COMMENT @

HANG UUO - HANG A PORT, A JOB, OR ALL JOBS

	T1/	BITS,,PORT OR JOB #

	<BITS>  = 1B13 SAME AS 1B16 EXCEPT DON'T DETACH CMD PORT (LET
		       LOGOUT DO IT)
		  1B14 TO HANG A PORT OSTENSIBLY NOT TIED TO
		       A CIRCUIT
		  1B15 TO HANG ALL JOBS THEN GO TO BOOTS LOADED
		  1B16 TO FORCE A LOGOUT EVEN FOR JOBS WITH
		       DETACH OR TIMEOUT SET
		  1B17 IF SPECIFYING A JOB RATHER THAN A PORT
@

HNGUUO::TLNN	T1,(1B15)	;IF HANGING THE SYSTEM
	TLNN	T1,(1B17)	;OR SPECIFYING A PORT,
	 JRST	HNGUUL		;  NEED LICENSE

    ;HANGING A SPECIFIC FRAME - CHECK ACCESS RIGHTS

	HRR	P1,J		;SAVE CALLER JOB#
	HLL	P1,T1		;SAVE <BITS>
	HRRZ	P4,T1		;P4/ FRAME DESC
	HRRZI	P3,.ARHNG	;P3/ HANG-FRAME ACCESS
	PUSHJ	P,FDRUPX##	;J/ TARGET JOB#
	  POPJ	P,		;(NO JOB OR INSUFFICIENT ACCESS)
	HLL	T1,P1		;T1/ <BITS>,,
	HRR	T1,J		;T1/ <BITS>,,TARGET JOB#
	HRRZ	J,P1		;J/ CALLER JOB#
	JRST	HNGMON

    ;HANGING A PORT OR HANGING SYSTEM - NEED WC LICENSE

HNGUUL:	MOVSI	T2,LICWCR
	TDNN	T2,JBTLIC(J)
	 POPJ	P,

    ;HERE WHEN ACCESS IS OK, TO DO THE ACTUAL STUFF

HNGMON::HRRZ	T2,T1		;GET JOB OR PORT NUMBER
	TLNE	T1,(1B15)
	 JRST	HNGALL		;HANG ALL JOBS
	TLNE	T1,(1B17)
	 JRST	HNGJOB		;HANG A JOB
	CAIL	T2,RPORTN##
	 POPJ	P,		;BAD PORT
	HRR	U,LINTAB(T2)

	SKIPN	LDBLOG(U)	;THERE?
	 TLCE	T1,(1B14)	;SKIP IF DESIRE TO HANG ACTIVE PORTS
	TLNE	T1,(1B14)	;SKIP IF WANT TO HANG INACTIVE PORTS
	 POPJ	P,		;ERROR RETURN
	AOS	(P)		;SET TO SKIP RETURN
    ;HERE FROM ABOVE AND FROM ZAPCIR UUO
    ;U/ ---,,LDB ADDR
    ;T1/1B16 if ignoring continue-on-disconnect

HNGPRT:	PUSH	P,T1		;Save the "kill flag"
	MOVSI	T2,LMLBIO
	TDNE	T2,LDBMOD(U)
	 PUSHJ	P,BIOREL	;RESET BIO ON THIS PORT
	POP	P,T1		;Restore "kill flag"

;HERE WITH U/ LDB ADDR TO HANG THAT PORT

	HLL	U,LDBDCH(U)
	MOVSI	T2,LLLZAP
	IORM	T2,LDBLOG(U)	;MARK PORT INTERNALLY "ZAPPED"
	TLNE	U,LDLAUX	;IS IT AN AUX CIRCUIT?
	 JRST	HNGAUX		;YES, SO IT'S NOT A COMMAND PORT
	HRRZ	F,LDBDDB(U)	;F/ DDB ADDR
	JUMPE	F,TTYZAP	;Detached, just zap the port
	MOVSI	T2,TTYATC
	TDNN	T2,DEVMOD(F)	;IS IT A COMMAND PORT?
	 JRST	HNGAUX		;NO
	LDB	J,PJOBN		;Get number of controlling job/frame
	HLL	J,T1		;Set up J for general hang code
	PFALL	HNGTTY
SUBTTL	 Here from above or by PUSHJ.  At entry, F=DDB address, U=LDB
; address (if any), J=job/frame # in RH, LH has bit 16 set if
; continue-on-disconnect is to be ignored.

HNGTTY:	TLNE	J,(1B13)	;WANT TO DETACH?
	 JRST	HNGTT1		;NO, LET LOGOUT HANDLE IT
	HLLZS	DDBLDB(F)	;Clear DDB-to-LDB pointer
	HRRZS	DEVNAM(F)	;Clear "TTY" from device name
	JUMPE	U,HNGTT1	;Skip port code if no port
	HLLZS	LDBDDB(U)	;Clear LDB-to-DDB pointer
	PUSHJ	P,TTYZAP	;ZAP the port
	LDB	T1,LDPCOM	;Command mode from LDB
	DPB	T1,DDPCOM	;Copy into DDB

; Here job/frame is detached and TTY is gone

HNGTT1:	TLZE	J,(1B13!1B16)	;"Really kill"?
	 JRST	HNGTT2		;Yes, kill him good
	LDB	T1,PVYHNG##	;HANG/ZAP action field
	CAIE	T1,.PVHCN	;Continue-on-disconnect?
	 JRST	HNGTT3		;No, go kill it dead

; Here for continue-on-disconnect

	LDB	T1,DDPTZP
	PUSHJ	P,TAKTRP	;Cause "TTY ZAP" interrupt (if enabled)
	MOVE	S,DEVIOS(F)
	TLNE	S,TIOUSE	;If the DDB is in use,
	 PUSHJ	P,TIWAKE	; wake the job
	POPJ	P,

; Here to kill job dead

HNGTT2:	PUSHJ	P,TTKJOB##	;"Really kill" (no questions)

; Here to stop on disconnect or logout on disconnect

HNGTT3:	MOVSI	T1,DCLCOM
	IORM	T1,DDBDCH(F)	;In command mode at detach time
	PUSHJ	P,COMKJB##	;The MAGIC INVOCATION which kills jobs
	POPJ	P,		;Less magical, returns to caller
SUBTTL	HERE TO HANG A JOB
;T1/ BITS,,JOB#  T2/ 0,,JOB#

HNGJOB:	CAIL	T2,JOBN
	 POPJ	P,		;BAD JOB NUMBER
	HRRZ	F,TTYTAB(T2)
	JUMPE	F,CPOPJ		;NO JOB THERE
	HRRZ	U,DDBLDB(F)
	MOVE	J,T1		;Copy BITS,,JOB#
	PUSHJ	P,HNGTTY	;Force hang for this job/frame
	JRST	CPOPJ1

;HERE TO HANG EVERYONE AND BRING DOWN THE SYSTEM

HNGALL::SETZM	CRSHWD##	; THIS KEEPS US FROM NESTING
	SETOM	DWNFLG
	MOVEI	T1,600000
	IORM	T1,STATES	;SET SUPER SHUT
	PUSHJ	P,SETSHT	;LET SUPERVISOR KNOW
	MOVE	T1,HIGHJB
	PUSH	P,T1
HNGAL1:	HRLI	T1,(1B16!1B17)	;HANG JOB AND FORCE LOGOUT
	HRRZ	T2,T1		;Copy job #
	PUSHJ	P,HNGJOB
	  JFCL
	SOSLE	T1,(P)
	JRST	HNGAL1
	JRST	TPOPJ1
SUBTTL RESET UUO

TTYRES::HRRZ	F,TTYTAB(J)	;CALLED AT RESET TIME
	JUMPE	F,CPOPJ		;NO DDB
	MOVE	S,[XWD TWTSPC!IOSBKA,BK2IOS!DLRSUP!NOECHO!FCS!17]
	ANDCAB	S,DEVIOS(F)	;RESET TTY TO NORMAL STATE
	HRRZ	U,DDBLDB(F)
	JUMPE	U,TTYRS1	;NO LINE
	MOVE	T1,LDBMOD(U)	;CHECK FOR BLOCK I/O MODE SET
	TLNE	T1,LMLBIO	;FOR THE PORT AND RELEASE
	 PUSHJ	P,BIOREL	;BUFFERS AND RESET, IF SO.
	MOVSI	T1,L2LNTB
	ANDCAM	T1,LDBBYT(U)	;RESET THE NO TAB FUNCTION
	HRRZI	T1,L2LTBK
	PUSHJ	P,SETTBK	;NOW MAKE SURE TABS ARE BREAK2
	HRRZI	T1,L2LBBP
	PUSHJ	P,SETTBK	;MAKE SURE THAT BACKSPACES ARE BREAK
	PUSHJ	P,UUOLDB	;MAKE LINE AGREE WITH S
TTYRS1:	PUSHJ	P,NXTTTY	;GET NEXT DDB
	  POPJ	P,		;NONE
	MOVSI	T2,DVNZP
	TDNE	T2,DEVMOD(F)	;SHOULD WE ZAP ON RESET?
	 JRST	TTYRS1		;NO
	MOVEI	T2,ASSCON
	PUSHJ	P,RELEA6	;YES
	JRST	TTYRS1
SUBTTL .STTLK SETUUO FUNCTION

COMMENT @

CALLED BY SETUUO TO DO THE .STTLK FUNCTION (TALK COMMAND CLONE):

	MOVE	J,[TALKER JOB #]
	MOVE	T1,[TALKEE JOB #] (0 for OPR+CTY, 400000 for CTY only)
	MOVE	T2,[ILDB POINTER TO MESSAGE IN USER SPACE]
	MOVE	T4,[BYTE COUNT, 0 IF MESSAGE IS ASCIZ]
	PUSHJ	P, STTLK
	  ERROR RETURN	;T1/ ERROR CODE (SEE DEFINITIONS BELOW)
	NORMAL RETURN

ADVANCES T2 AS IT GOES, SO T2 IS CORRECTLY UPDATED IF THE MESSAGE
CAN ONLY BE PARTIALLY OUTPUT.  T4 updated if it started nonzero.

DESTROYS T1 T3.

@

TKROM%==:0	;NO ROOM FOR MORE OUTPUT CHARACTERS
TKEXS%==:1	;JOB DOESN'T EXIST
TKATT%==:2	;JOB NOT ATTACHED
TKBSY%==:3	;JOB BUSY (NO OPER LICENSE & NOT AT CMND LEVEL)

PRINTF(<[STTLK to job -1 does not SEND ALL]>)

STTLK::	TRNE	T1,377777	;Zero or 400000?
	 JRST	STTLK0		;No, T1 has job number
	CAIN	T1,400000	;Is 1B18 and nothing else set?
	 TRCA	T1,400001	;Yes, change T1 to 1 and output to CTY only
	  MOVEI	T1,2		;No, change T1 to 2 for both OPR and CTY
	PUSHJ	P,OPROUT	;Set up to go to right LDB
	MOVEI	T3,CTYLDB	;Fake it
	JRST	STTLK1

STTLK0:	MOVSI	T3,JNA
;*;	JUMPL	T1,#SEND#ALL#	;***    NOT IMPLEMENTED   ****
	CAIGE	T1,JOBN		;IF BAD JOB #
	TDNN	T3,JBTSTS(T1)	;OR JOB NOT ASSIGNED,
	 JRST	[MOVEI	T1,TKEXS%
		 POPJ	P,]	;Error return - non existant job
	HRRZ	T3,TTYTAB(T1)	;T3/ TALKEE DDB
	SKIPN	T3
	 STOPCD
	HRRZ	T3,DDBLDB(T3)	;T3/ TALKEE LDB
	JUMPE	T3,[		;IF JOB NOT ATTACHED,
		MOVEI	T1,TKATT%
		POPJ	P,	;  ERROR-RETURN
	]

	CAIN	T3,OPRLDB	;No license required to send to OPR or CTY
	 JRST	STTLK1
	HLL	T4,JBTLIC(J)	;Get caller's license
	TLNE	T4,LICOPR	;OPER can talk to anyone
	 JRST	STTLK1
	HLL	T4,LDBDCH(T3)	;Get talkee's status
	TLNE	T4,LDLCOM	;Receive messages if port is at command level
	 JRST	STTLK1
	MOVEI	T1,TKBSY%	;Port is busy
	POPJ	P,		;Error return
    ;HERE WITH T2/ ILDB POINTER, T3/ TALKEE LDB TO SEND A MESSAGE

STTLK1:	TLZ	T4,-1		;Keep only byte count
	PUSH	P,U		;SAVE U
	HRRZ	U,T3
	TLZ	T2,37		;CLEAR INDEX AND INDIRECT FIELDS
	PUSH	P,T2		;AND SAVE BYTE POINTER

STTLK2:	PUSHJ	P,IFROOM	;Check for room in destination output buffer
	 JRST	[
		MOVEI	T1,TKROM%
		POP	P,T2
		POP	P,U
		POPJ	P,	;  RESTORE T2 AND U AND ERROR-RETURN
	]
	XCTFU	<ILDB T3,(P)>	;GET NEXT BYTE OF MESSAGE
	SKIPN	T4		;If count started at 0, then
	 JUMPE	T3,STTLK3	; end at null in ASCIZ
	PUSHJ	P,COMTYO	;PRINT THE CHARACTER
	SKIPE	T4		;If byte count supplied,
	 SOJE	T4,STTLK3	; count it down
	JRST	STTLK2

STTLK3:	POP	P,T2
	POP	P,U
	JRST	CPOPJ1		;RESTORE T2 AND U AND SUCCESS-RETURN
SUBTTL TTCALL UUO
;TTCALL AC,E - VALUE OF AC DETERMINES ACTION OF UUO (051)

;W has a number from 0 to 17 if called from TTCALL uuo,
;negative numbers in W if fake call from UUOCON.

TTYUUO::PUSHJ	P,TTYFNU	;SET F AND U
	AOS	TTCCNT(W)	;Count each TTCALL by function
	MOVE	T3,TTUUOT(W)	;GET DIPACTH ADRS AND BITS
	TLNN	T3,TUUATO	;DOES UUO NEED ATTACH FOR OUTPUT?
	 JRST	TTYUU1
	PUSHJ	P,CKATTO	;YES, CHECK IF ATTACHED FOR OUTPUT
	  JRST	ABTUUO		;ABORT TH FOR INTERRUPT
	JUMPN	U,TTYUU1
	PUSHJ	P,CKATO2	;FORCE ATTACH EVEN IF "SPECIAL"
	  JRST	ABTUUO
	JUMPE	U,.-2		;JUST TO MAKE SURE
TTYUU1:	TLNN	T3, TUUATI	;ATTACH FOR INPUT ?
	 JRST	TTYUU2
	PUSHJ	P,CKATTI	;YES, CHECK IF ATTACHED
	  JRST	ABTUUO		;ABORT FOR INTERRUPT
TTYUU2:	TLNE  T3,TUUATR!TUUAIR	;RETURN IF DETACHED ?
	JUMPE	U,CPOPJ		;YES
	TLNN	T3,TUUATO!TUUATI;IF DOING INPUT OR OUTPUT
	 PUSHJ	P,UUOLDB	;MUST GET THROUGH UUOLDB
	TLNN	T3,TUUROM	;NEED ROOM FOR OUTPUT?
	 JRST	TTYUU3
	PUSHJ	P,CHKROM	;SEE IF WILL GO INTO IOW FOR INTERRUPT
	 JRST	TTYUUO
TTYUU3:	TLNE	T3,TUUAIR	;MUST IT BE AT USER LEVEL TOO?
	TLNN	U,LDLCOM
	 SKIPA			;NEED NOT BE OR IS
	  POPJ	P,
	TLNE	T3,TUUEAT	;EAT RESCAN BUFFER?
	 PUSHJ	P,TYIEAT	;MUST EAT COMMAND BEFORE INPUT
IFE OPCRET,<	; KLUDGE TIL OPERATIONS CAN WRITE 10 CODE
	TLNE	T3,TUUFXI
	 PUSHJ	P,FIXIMI	;SET IMAGE STATE FROM DATA MODE
>;OPCRET=1 IF PROGRAMS THINK TTCALLS IGNORE IMAGE
	JRST	(T3)
SUBTTL	BITS FOR THE TTY UUOS

TUUATI==400000	;NEED TO BE ATTACHED - INPUT
TUUATO==200000	;NEED TO BE ATTACHED - OUTPUT
TUUATR==100000	;RETURN IF NOT ATTACHED
TUUAIR==040000	;RETURN IF NOT AT USER LEVEL
TUUROM==020000	;CHECK FOR ROOM FOR AT LEAST 1 CHR BEFORE OUTPUT
TUUEAT==010000	;EAT COMMAND
TUUFXI==004000	;SET IMAGE STATE FROM DATA MODE
TUUIMI==002000	;TURN ON IMAGE STATE (REGARDLESS OF DATA MODE)

;THERE ARE SOME NEGATIVE DISPATCHES FAKED BY UUOCON

TTUNEG:	XWD TUUAIR,LEVDEF		;-5 LEAVE DEFERED ECHO MODE
	XWD TUUAIR!TUUEAT!TUUFXI,RDNXT	;-4 READ NEXT CHR AND SKIP
	XWD 0,CPOPJ			;   NO LONGER IMPLEMENTED
	XWD 0,GETMC			;-2 GET LINE CHRS
	XWD TUUATI!TUUEAT!TUUFXI,TWAITC	;-1 WAIT FOR CHR
TTUUOT:	XWD TUUATI!TUUEAT!TUUFXI,INCHRW	;00 INPUT CHR AND WAIT
	XWD TUUATO!TUUROM,ONEOUT	;01 OUTPUT 1 CHR
	XWD TUUAIR!TUUEAT!TUUFXI,INCHRS	;02 INPUT CHR AND SKIP
	XWD TUUATO!TUUROM,OUTSTR	;03 OUTPUT STRING
	XWD TUUATI!TUUEAT!TUUFXI,INCHWL	;04 INPUT CHR AND WAIT LINE MODE
	XWD TUUAIR!TUUEAT!TUUFXI,INCHSL	;05 INPUT CHR AND SKIP LINE MODE
	XWD 0,GETLIN			;06 GET LINE CHRS.
	XWD TUUATO,SETLIN		;07 SET LINE CHRS.
	XWD TUUATR,TRESCU		;10 INHIBIT COMMAND LINE EATING
	XWD TUUATR,TSETBI		;11 CLEAR INPUT BUFFER
	XWD TUUATR,TSETBO		;12 CLEAR OUTPUT BUFFER
	XWD TUUAIR!TUUEAT!TUUFXI,SKPINC	;13 SKIP IF CHR TO BE INPUT
	XWD TUUAIR!TUUEAT!TUUFXI,SKPINL	;14 SKIP IF LINE TO BE INPUT
	XWD TUUATO!TUUROM,IONEOU	;15 IMAGE ONE-CHAR OUTPUT
	XWD TUUATO!TUUROM,OUTCHI	;16 OUTPUT CHR IMMEDIATE
	XWD TUUATO!TUUROM,OUTPTR	;17 OUTPUT FROM POINTER
SUBTTL	SUBROUTINES FOR TTCALL

;ONEOUT OUTPUTS ONE CHARACTER FROM C(E)

OUTCHI:	SKIPA T3,M	;GET THE CHARACTER FROM ADDRESS FILED
ONEOUT:	UMOVE T3,(M)	;GET CHR FROM ADDRESS
	NOCHARGE
	PUSHJ P,CLRIMI			;CLEAR IMAGE INPUT STATE
	TRNN S,10		;IF MODES 10,13,14
	TRNN S,2		;OR 0,1
	TRZA T3,600		;SAME AS ANDI 177 SINCE TTGETC GETS 9 BIT BYTE
	ANDI T3,377		;8 BITS IN MODE 2
	JUMPE T3,CPOPJ			;IF NOT NULL,
ONEOU2:	PUSHJ P,TYO
	 JRST XPNOUT		;SET BIGGER OUTPUT AND GO TO TYO
ONEOU3:	MOVEI T1,1
	DPB T1,LOPOUT
	DPB T1,LDBOPB(U)
	POPJ P,

;IONEOU OUTPUTS ONE CHARACTER FROM LOW 8 BITS OF C(E)
ACOTCI:	SKIPA T3,M	;GET CHR IMMEDIATE (AUXCAL)
IONEOU:	UMOVE T3,(M)	;GET CHR
	NOCHARGE
	PUSHJ P,CLRIMI			;NOT IN INPUT WAIT ANY MORE
	JUMPE F,ONEOUT		;IF NO F, SEND 7 BITS
	TRO T3,400			;FLAG AS IMAGE CHARACTER (NO FILLER)
	PJRST ONEOU2		;OUTPUT CHARACTER

;OUTSTR OUTPUTS A STRING OF ASCIZ CHARACTERS


OUTSTR:	PUSHJ P,CLRIMI			;CLEAR IMAGE INPUT STATE
	NOCHARGE
	HRLI M,(POINT 7,0)			;POINT TO USER AREA
OUTST1:	XCTFU <ILDB T3,M>	;GET CHR
	JUMPE T3,ONEOU3			;NULL MARKS END OF STRING, START PTY
	PUSHJ P,TYO			;TYPE OUT CHARACTER WITH PARITY
	 JRST XPNOUT		;TRY BIGGER OUTPUT BUFFER
	JRST OUTST1			;AND GO BACK FOR MORE.

;TRESCU IS FOR COMPIL TO READ COMMAND WHICH STARTED IT

TRESCU:	MOVSI T1,LDLECS		;CLEAR BIT IN LINE DATA BLOCK WHICH
	ANDCAM T1,LDBDCH(U)		; WOULD CAUSE COMMAND TO BE SKIPPED
	POPJ P,0			;AND RETURN TO USER
SUBTTL	SKPINC - SKIP IF INCHRW WOULDN'T WAIT (TOO LONG)

SKPINC:	SKIPG	LDBECC(U)	;If anything to be echoed
	SKIPLE	LDBTIC(U)	;Or characters have been input
	 AOS	(P)		;Skip return
TTYSET::		;OLD CLOCK1 FUNCTION
NOCTRO:	MOVSI	T1,L2LLDF
	ANDCAM	T1,LDBBYT(U)	;TURN OFF LEVDEF FLAG TOO
	MOVSI	T1,LDLOSU	;TURN OFF CONTROL O BIT
	ANDCAM	T1,LDBDCH(U)
	POPJ	P,

;SKPINL - SKIP IF INCHWL WOULDN'T WAIT

SKPINL:	MOVE	T1,LDBTIC(U)	;T1/ # READABLE CHARACTERS
	TLNE	U,LDLIMI	;IF IMAGE MODE
	 SKIPG	T1		;AND THERE'RE ANY,
	CAIL	T1,TIWKC	;OR OF THERE'S A LINEFULL,
	 JRST	SKPIN1		;  SKIP
	TLNE	U,LDLBK2	;IF BREAK-ON-PUNCTUATION
	 SKIPG	LDBBK2(U)	;AND THERE'RE PUNCTUATION CHARS,
	SKIPLE	LDBBKC(U)	;OR IF THERE'RE BREAK CHARACTERS,
SKPIN1:	 AOS (P)		;  SKIP
	PJRST	NOCTRO
SUBTTL	OUTPTR - OUTPUT FROM BYTE POINTER

OUTPTR:	PUSHJ P,CLRIMI
	NOCHARGE
	XCTFU <MOVE W,(M)>	;GET BYTE POINTER
	TLZ W,37		;GET RID OF INDEX AND INDIRECT
OUTPT1:	XCTFU <ILDB T3,W>	;GET NEXT CHARACTER
	JUMPE T3,ONEOU3		;DONE - SET OUTPUT BITS&RETURN
	PUSHJ P,TYO
	 SKIPA			;TYO WANTS TO TAKE INTERRUPT
	JRST OUTPT1		;TYO DONE, NEXT CHR
	LDB T3,[POINT 6,W,11]	;GET SIZE FIELD
	ROT T3,-6		;MOVE TO POSITION FILED
	ADDM T3,W		;BACK UP POINTER 1 POSITION
	XCTTU <MOVEM W,(M)>	;PUT IT BACK
	MOVEI T1,1
	DPB T1,LOPOUT
	DPB T1,LDBOPB(U)
	JRST ABTUUO		;AND DUMP THIS UUO

;OUTPTC - OUTPUT FROM BYTE POINTER + COUNT

OUTPTC:	PUSHJ	P, CLRIMI
	NOCHARGE
	XCTFU	<HRRZ P1, 0(M)>	;P1/ COUNT
	JUMPE	P1, CPOPJ	;IF 0, DONE
	XCTFU	<MOVE W, 1(M)>	;W/ BYTE POINTER
	TLZ	W, 37		;W/ BYTE POINTER - INDEX&INDIRECT BITS
OUTPC1:	XCTFU	<ILDB T3, W>	;T3/ NEXT CHARACTER
	PUSHJ	P, TYO		;OUTPUT IT
	  JRST	OUTPC2		;(TYO WANTS AN INTERRUPT)
	SOJG	P1, OUTPC1	;IF MORE CHARACTERS, CONTINUE
	PJRST	OUTPCF		;FINISH UP

OUTPC2:	LDB	T3, [POINT 6,W,11]
	ROT	T3, -6		;POSITION FIELD := SIZE FIELD
	ADDM	T3, W		;DECREMENT BYTE POINTER BY 1 BYTE
	PUSHJ	P, OUTPCF	;FINISH UP
	JRST	ABTUUO		;AND DUMP THIS UUO

	;OUTPCF ALSO USED BY OUTSNW...BELOW
OUTPCF:	XCTBU	<HRRM P1, 0(M)>	;STORE THE UPDATED COUNT
	XCTTU	<MOVEM W, 1(M)>	;AND BYTE POINTER
	MOVEI	T1, 1
	DPB	T1, LOPOUT
	DPB	T1, LDBOPB(U)
	POPJ	P,

;OUTSNW - OUTPUT STRING, NEVER WAIT

OUTSNW:	PUSHJ	P,CLRIMI
	NOCHARGE
	HLRZ	T1,LDBBIO(U)	;BLOCK OUTPUT IN PROGRESS?
	JUMPN	T1,CPOPJ	;IF SO, CAN'T DO ANYTHING
	XCTFU	<HRRZ P1,(M)>	;P1/ COUNT
	JUMPE	P1,CPOPJ1	;NOTHING TO DO
	XCTFU	<MOVE W,1(M)>	;W/ BYTE POINTER
	TLZ	W,37		;W/ BYTE POINTER - INDEX & IND BITS
OUTSN1:	PUSHJ	P,IFROOM	;IS THERE ROOM FOR A CHARACTER?
	 JRST	OUTSN2		;NO ROOM - SET FIO GO AWAY
	XCTFU	<ILDB T3,W>	;YES ROOM - GET CHARACTER
	PUSHJ	P,CMDTYO	;AND OUTPUT IT
	SOJG	P1,OUTSN1	;DO IT AGAIN, IF MORE
	AOS	(P)		;RAN OUT - SKIP RETURN
	JRST	OUTPCF		;GO AWAY
OUTSN2:	PUSHJ	P,SETFIO	;SO HE'LL GET ROOM AVAILABLE TRAP
	JRST	OUTPCF		;NO ROOM - GO AWAY

SUBTTL	GETLCH - READ LINE CHARACTERISTICS

GETLIN:	XCTFU <MOVE T1,(M)>
	PUSHJ P,CHKLN2	;SEE IF THIS USER CAN HAVE THIS INFO
	 JRST GETLNZ	;NO
	LDB T1,LDPLNO		;GET NUMBER
	HLL	T1,LDBDCH(U)	; GET BITS FROM LH WHICH ARE SAME
	TLZ	T1,-1-GTLMSK	; CLEAR ALL BITS IN LH WHICH ARN'T
	LDB T3,LDPHDX	;GET HALF DUPLEX BIT FROM CHRS READ
	SKIPE T3	;SEE IF ON
	TLO T1,GTLHDX
	MOVE	T3, LDBDCX(U)
	TRZE	T3, LXRESC	;READ AND CLEAR "ESCAPE SEEN"
	TLO	T1, GTLESC	;RETURN ITS OLD VALUE
	TRZE	T3, LXROBS	;READ AND CLEAR "ORANGE BALL SEEN"
	TLO	T1, GTLOBS	;RETURN ITS OLD VALUE
	MOVEM	T3, LDBDCX(U)
	MOVSI	T3, LMLPSP
	TDNE	T3, LDBMOD(U)	;CHECK FOR UNREAD PORT-STATUS MSG
	TLO	T1, GTLPSP	;AND SET IF THERE IS ONE
	LDB T3,LDPCRD	;GET RETURN DELAY BIT
	SKIPE T3
	TLO T1,GTLCRD
	HLL U,LDBDCH(U)	;THE OTHERS FROM NORMAL BITS
	MOVE T3,LDBBKC(U)	;GET BREAK COUNTER
	TLNE U,LDLBK2	;IF IN BREAK 2 MODE
	ADD T3,LDBBK2(U)	;ADD IN THESE
	TRNE T3,-1
	TLOA T1,GTLLRD		;SET LINE READY BIT
	TLZ T1,GTLLRD		;OR TURN IT OFF
	TLC T1,GTLLCT		;SENSE OF THIS BIT IS WRONG
	XCTTU <MOVEM T1,(M)>
	POPJ P,

GETLNZ:	XCTBU <SETZM (M)>
	POPJ P,

; THE FOLLOWING BITS ARE IN THE SAME PLACE IN LDBDCH AS IN GETLCH...
GTLMSK==LDLNOP!LDLDEF!LDLECS!LDLOSU!LDLNFC!LDLNEC!LDLAUX!LDLLCT!LDLTAB!LDLLCP!LDLPTP!LDLFRM

GTLECS==100000	;EAT COMMAND SYNCH (CMD AVAIL FOR RESCAN)
GTLPSP==40000	;PORT STATUS PENDING (UNREAD, see comment at ACPSM)
GTLOBS==20000	;ORANGE BALL SEEN
GTLHDX==10000	;HALF DUPLEX
GTLESC==4000	;ESCAPE SEEN
GTLCRD==2000	;CARRIAGE-RETURN(NOT LF) PADDING
GTLDEF==1000	;DEFERRED ECHO MODE
GTLNFC==200	;NO FREE CRLF (ON LONG LINES)
GTLLRD==100	;LINE (BREAK) IN BUFFER
GTLLCT==20	;NO CASE MAPPING
GTLTAB==10	;HARDWARE HT
GTLPTP==2	;PAPER TAPE MODE
GTLFRM==1	;HARDWARE FF/VT
SUBTTL	SETLCH - SET LINE CHARACTERISTICS

SLCTAB:	GTLHDX,,TCNHDX
	GTLCRD,,TCNCRD
	GTLNFC,,TCNNFC
	GTLLCT,,TCNLCT
	GTLTAB,,TCNTAB
	GTLPTP,,TCNPTP
	GTLFRM,,TCNFRM
SLCTBN==.-SLCTAB

SETLIN:	XCTFU	<HLRZ P1,(M)>	;P1/ 0,,USER BITS
	TRC	P1, GTLLCT	;INVERT SENSE OF CASE-MAP BIT
	MOVE	P2, [-SLCTBN,,SLCTAB]
SETLN1:	HLL	T3, (P2)	;T3/ THE BIT
	TLNN	T3, (P1)	;SET IT OR CLEAR IT?
	TDZA	T2, T2		;(CLEAR)
	MOVEI	T2, 1		;(SET)
	HRRZ	T1, (P2)	;T1/ THE TC#
	PUSHJ	P, SETTCN
	 STOPCD 		;WHAT ERROR?
	AOBJN	P2, SETLN1
	POPJ	P,
SUBTTL	CHARACTER INPUT TTCALLS

INCHRS:	NOCHARGE
	PUSHJ P,SKPINC			;CAN I GET A CHARACTER (CLEAR ^O)
ICS1:	  JRST NOCTRO			;NO. GIVE NON-SKIP RETURN
	PUSHJ P,TWAITS
	  POPJ	P,			;DETACHED
	PUSHJ P,TYI			;GET A CHARACTER
	  JRST ICS1			;NONE THERE. SKPINC LIED?
	AOS 0(P)			;GIVE SKIP RETURN
	JRST ICW1A			;AND RETURN THE CHARACTER
INCHSL:	NOCHARGE
	PUSHJ P,SKPINL			;IS THERE A LINE AVAILABLE?
	  POPJ P,0			;NO. NON-SKIP RETURN TO USER
	PUSHJ P,TWAITL
	PUSHJ P,TYI		;GET THE CRH.
	 JRST ICS1		;REALLY NONE THERE
	AOS (P)			;SET FOR SKIP RETURN
	JRST ICW1B		;GO (REMEMBER TO CHARGE

I1CHWL:	AOS (P)		;FROM AUXCAL
INCHWL:	NOCHARGE
INWL1:	TLNE U,LDLIMI	;CHECK IMAGE MODE
	TLNN S,IOEND
	SKIPA
	JRST ICH0		;SEND A 0 CHRACTER
	PUSHJ P,TWAITL			;WAIT FOR A LINE TO APPEAR
	PUSHJ P,TYI			;GO GET A CHARACTER
	  JRST INWL1			;IMPOSSIBLE. NO CHARACTERS.
ICW1B:	CAIN T2,%CHBRK		;A BREAK?
ICW1A:	PUSHJ P,SETBRK		;YES, CHARGE
ICW1:	TRNN S,10		;IF MODES 10,13,14
	TRNN S,2		;OR 0,1
	TRZA T3,600		;SAME AS ANDI 177 SINCE TTGETC GETS 9 BIT BYTE
	ANDI T3,377		;8 BITS IN MODE 2
	XCTTU <MOVEM T3,(M)>			;GIVE HIM THE CHARACTER
	JRST NOCTRO			;AND NON-SKIP RETURN

ICH0:	MOVEI T3,0
	JRST ICW1

I1CHRW:	AOS (P)		;FROM AUXCAL
INCHRW:	NOCHARGE
INRW1:	PUSHJ P,TWAITC			;WAIT FOR A CHARACTER TO APPEAR
	PUSHJ P,TYI			;GO GET THE CHARACTER
	  JRST INRW1			;IMPOSSIBLE. NONE THERE
	JRST ICW1A			;GIVE HIM T3 AND RETURN
;Get LDBLOG for GETTAB uuo
GETLOG::PUSHJ	P,CHKLIN	;GETTAB to return LDBLOG.  Check if OK
	  POPJ	P,		;Error, can not have info
	SKIPA	T1,LDBLOG(U)
RETZRO:	MOVEI	T1,0		;NO LINE THERE, RETURN 0
STOTC1:	UMOVEM	T1,(M)		;RETURN ARGUMENT TO USER'S AREA.
	JRST	CPOPJ1		;AND SKIP RETURN.

CHKLN2:	SKIPA	U,T1		;Line # in RH
CHKLIN:	HLRE	U,T1		;Line # in LH
	JUMPL	U,CKLN1		;-1 for own line
	CAILE	U,MXLIN##
	 POPJ	P,		;Illegal line number
	SKIPA	U,LINTAB(U)	;Get addr of LDB
CKLN1:	 PUSHJ	P,TTYFNU	;Find LDB for job
	JUMPE	U,CPOPJ		;NO LINE NUMBER THERE
	HRRZ	F,LDBDDB(U)	;GET THE DDB
	JUMPE	F,CPOPJ		;IF NONE, NO ONE CONNECTED
	LDB	J,PJOBN		;GET THE JOB NUMBER
	JRST	CHKSEG		;AND GO CHECK

LINJOB::PUSHJ	P,CHKLIN	;Return job which owns a specific line
	  POPJ	P,
	HRRZ	F,LDBDDB(U)
	JUMPE	F,RETZRO
	LDB	T1,PJOBN	;GET THE JOB NUMBER
	JRST	STOTC1

GETLPS::PUSHJ	P,CHKLIN	;Return horizontal position of line
	  POPJ	P,
	LDB	T1,LDPPOS
	JRST	STOTC1

GETMOD::PUSHJ	P,CHKLIN	;Return status (DEVIOS)
	  POPJ	P,
	HRRZ	F,LDBDDB(U)
	JUMPE	F,RETZRO
	MOVE	T1,DEVIOS(F)
	JRST STOTC1
RDNXT:	NOCHARGE
	SKIPG LDBECC(U)	;MAKE SURE A CHR IS THERE
	SKIPLE LDBTIC(U)
	AOSA (P)
	POPJ P,			;NO, RETURN
	MOVE T2,LDBTIT(U)
	PUSHJ P,TTGETC
	 JFCL
	TRNN S,10		;IF MODES 10,13,14
	TRNN S,2		;OR 0,1
	TRZA T3,600		;SAME AS ANDI 177 SINCE TTGETC GETS 9 BIT BYTE
	ANDI T3,377		;8 BITS IN MODE 2
	XCTTU <MOVEM T3,(M)>	;GIVE IT TO HIM
	POPJ P,

LEVDEF:	MOVSI T1,L2LLDF
	IORM T1,LDBBYT(U)
	PUSHJ P,BPLVD	;TURN OFF BACKPRESSURE IF APPROPRIATE
	MOVEI T1,1
	DPB T1,LOPECO
	DPB T1,LDBOPB(U)
	POPJ P,
SUBTTL	READ TERMINAL CHARACTERISTICS

GETMC:	UMOVE T1,(M)	;GET THE LINE HE WANTS THESE FOR
	PUSHJ P,CHKLN2
	 JRST GETLNZ	;CAN NOT HAVE THEM
	SETZM	T1	;MAKE UNFILLED FIELDS 0 (ARE THERE ANY?)
	LDB T3,LDPFC1	;FILLER CLASS 1
	DPB T3,GEPMC1
	LDB T3,LDPFC2	;FILLER CLASS 2
	DPB T3,GEPMC2
	LDB T3,LDPWID	;WIDTH
	DPB T3,GEPMC3
	LDB T3,GEPMC4	;NO XON, NO TAB, TAB AS BREAK BITS
	DPB T3,GEPMC5
	LDB T3,LDPIR
	DPB T3,GEPMC6
	LDB T3,LDPOR
	DPB T3,GEPMC7
	LDB T3,LDPPAR
	DPB T3,GEPMC8
	LDB T3,LDPPA
	DPB T3,GEPMC9
	LDB T3,LDPHDX
	DPB T3,GEPM10
	LDB T3,LDPPB
	DPB T3,GEPM11
	LDB T3,LDPPC
	DPB T3,GEPM12
	UMOVEM T1,(M)
	POPJ P,

GEPMC1:	POINT 2,T1,16	;FILLER CLASS 1
GEPMC2:	POINT 2,T1,14	;FILLER CLASS 2
GEPMC3:	POINT 8,T1,12	;WIDTH
GEPMC4:	POINT 3,LDBBYT(U),4	;GET NO XON, NO TAB, TAB AS BRK
GEPMC5:	POINT 3,T1,4	;LOCATION OF ABOVE IN GETTMC WORD
GEPMC6:	POINT 3,T1,19	;IR
GEPMC7:	POINT 3,T1,22	;OR
GEPMC8:	POINT 1,T1,23	;PAR
GEPMC9:	POINT 3,T1,26	;PA
GEPM10:	POINT 1,T1,27	;HDX
GEPM11:	POINT 3,T1,30	;PB
GEPM12:	POINT 5,T1,35	;0 BIT + PC
SUBTTL	FIXIMI CALLED ON INPUT UUOS OTHER THAN AUXCALS 0,1,2 TO SET
;IMAGE STATE FROM DATA MODE

FIXIMI:	MOVE	T1,LDBDCH(U)
	TLNN	T1,LDLAUX	;AUX CIRCUIT?
	TRNE	S,I		;OR DATA MODE = I, IB, B?
	 TLOA	T1,LDLIMI	;YES: SET IMAGE STATE
	TLZ	T1,LDLIMI	;NO: CLEAR IMAGE STATE
	CAMN	T1,LDBDCH(U)	;DID IT CHANGE?
	 POPJ	P,		;NO
	MOVEM	T1,LDBDCH(U)	;YES
	PJRST	SETLMD

;CLRIMI CALLED ON OUTPUT UUOS TO CLEAR IMAGE STATE IF DATA
;MODE IS NOT IMAGE AND TO TURN OFF BACKPRESSURE (IN GENERAL,
;TO NOTE THAT THE LINE IS NO LONGER SIMPLY IN INPUT WAIT)

CLRIMI:	HRRZ	F,LDBDDB(U)		;GET ATTACHED JOB, IF ANY
	JUMPE	F,CLRIM1		;IF NONE, SKIP PART OF THIS
	MOVE	S,DEVIOS(F)		;JOB'S IO STATUS FOR TTY
	TRNE	S,I			;IS IT STILL IN IMAGE MODE?
	 POPJ	P,0			;YES. FORGET IT.
CLRIM1:	MOVSI	T1,LDLIMI		;NO. CLEAR IMAGE BIT AND TIME
	TLNN	U,LDLAUX		;AUX ALWAYS IN IMAGE MODE
	TDNN	T1,LDBDCH(U)		;IS IT ON?
	 POPJ	P,			;NO
	ANDCAM	T1,LDBDCH(U)		; ..
	PUSHJ	P,BPTEST		;WANT TO TURN OFF BACKPRESSURE?
	  PUSHJ	P,BPOFF			;YES, NOW TURN OFF BACKPRESSURE
	PFALL	SETLMD

SETLMD:	LDB	T1,LDPMDF		;GET LINE MODE FLAGS
	MOVE	T1,MDFLMD(T1)		;DO TRANSLATION INTO MODE
	DPB	T1,LDPLMD		;AND SET INPUT AND ECHO MODES
	POPJ	P,0			; AND RETURN
	
SUBTTL	SETTBK - SET TABS AS BREAK
;SETTBK - CALLED WITH
;	T1/ L2LTBK,,L2LTBK	SET TAB-AS-BREAK
;	T1/	 0,,L2LTBK	SET TAB-AS-PUNCTUATION
;	T1/ L2LBBP,,L2LBBP	SET BS-AS-PUNCTUATION
;	T1/	 0,,L2LBBP	SET BS-AS-BREAK
;BREAKS T1-T4

SETTBK:	MOVE	T2, T1
	XOR	T1, LDBBYT(U)
	TLNN	T1, 0(T2)	;IF THE BIT DIDN'T CHANGE,
	POPJ	P,		;  JUST RETURN
	HRLZ	T1, T2
	XORM	T1, LDBBYT(U)	;INVERT THE LDB BIT
	MOVEI	T1, 11		;(ASSUME IT'S TAB-AS-BREAK)
	TRNN	T2, L2LBBP	;IF IT'S BS-AS-PUNCTUATION,
	JRST	SETTB1
	MOVEI	T1, 10		;  CHAR := 10
	TLC	T2, L2LBBP	;  INVERT SENSE (TO BS-AS-BREAK)
SETTB1:	TLNE	T2, -1		;WHICH WAY?
	PJRST	PNTOBK		;(PUNCTUATION = BREAK)
	PJRST	BKTOPN		;(BREAK = PUNCTUATION)
SUBTTL	BKTOPN - CALLED WITH U/ LDB ADDR, T1/ <CHAR>
;	   MAKE <CHAR> GO FROM A BREAK TO A PUNCTUATION CHARACTER
;	   BY ADJUSTING COUNTS
;	   DESTROYS T1 T2 T3 T4

BKTOPN:	PUSHJ	P, CHRCNT	;T1/ #UNECHOED,,#ECHOED
	ADDM	T1, LDBBK2(U)	;ADD TO PUNCTUATION COUNT
	MOVNS	T1
	ADDM	T1, LDBBKC(U)	;SUBTRACT FROM BREAK COUNT
	POPJ	P,

;PNTOBK - CALLED WITH U/ LDB ADDR, T1/ <CHAR>
;	   MAKE <CHAR> GO FROM A PUNCTUATION TO A BREAK CHARACTER
;	   BY ADJUSTING COUNTS, LINE DELETE POINTER
;	   DESTROYS T1 T2 T3 T4

PNTOBK:	PUSHJ	P, CHRCNT	;P2/ #UNECHOED,,#ECHOED
	ADDM	T1, LDBBKC(U)	;ADD TO BREAK COUNT
	MOVNS	T1
	ADDM	T1, LDBBK2(U)	;SUBTRACT FROM PUNCTUATION COUNT
	JUMPE	T1, PNTOB1	;IF THERE ARE ANY NEW BREAK CHARACTERS,
	MOVE	T2, LDBTIP(U)
	MOVEM	T2, LDBBKP(U)	;  SET LINE-DELETE POINTER TO NOW
	SETZM	LDBBKI(U)	;  (NO DELETABLE CHARACTERS)
PNTOB1:	POPJ	P,
SUBTTL	CHRCNT - CALLED WITH U/ LDB ADDR, T1/ CHAR
;	   RETURNS T1/ #UNECHOED,,#ECHOED <CHAR>S IN THE INPUT BUFFER
;	   DESTROYS T1 T2 T3 T4

CHRCNT:	PUSH	P, P1
	PUSH	P, P2
	MOVE	P1, T1		;P1/ CHAR
	SETZ	P2,		;P2/ COUNT
	MOVE	T2, LDBECT(U)	;T2/ ECHO-TAKER BYTE POINTER
	SKIPE	T4, LDBECC(U)	;T4/ #UNECHOED,UNREAD CHARACTERS
	PUSHJ	P, CNTCHR	;IF ANY, COUNT #<CHAR>S
	HRLZS	P2		;P2/ UNECHOED,,ECHOED
	MOVE	T2, LDBTIT(U)	;T2/ CHAR-TAKER BYTE POINTER
	SKIPE	T4, LDBTIC(U)	;T4/ #ECHOED,UNREAD CHARACTERS
	PUSHJ	P, CNTCHR	;IF ANY, COUNT #<CHAR>S
	MOVE	T1, P2		;T1/ COUNT
	POP	P, P2
	POP	P, P1
	POPJ	P,

    ;T2/ BUFFERLET BYTE POINTER, T4/ COUNT
    ;P1/ <CHAR> TO LOOK FOR, P2/ COUNT TO INCREMENT

CNTCHR:	PUSHJ	P, TTGETC	;T3/ NEXT CHAR
	  JFCL			;(EH?)
	ANDI	T3, 177		;T3/ ASCII PART OF THE CHAR
	CAMN	T3, P1		;IF IT'S THE <CHAR>,
	AOS	P2		;  COUNT IT
	SOJG	T4, CNTCHR
	POPJ	P,
SUBTTL	SETPTP - SETS PAPER-TAPE-MODE BIT (SIMILAR CODE IN SETLIN)
;	   T1/ 0 TO CLEAR PTP, LDLPTP,,0 TO SET PTP MODE
;	   (DESTROYS T1)

SETPTP:	XOR	T1, LDBDCH(U)
	TLNN	T1, LDLPTP	;IF IT'S NOT CHANGING,
	POPJ	P,		;  JUST RETURN
	XORB	T1, LDBDCH(U)	;SET DCH BIT
	TLNE	T1, LDLPTP	;IN PTP MODE?
	TDZA	T1, T1		;YES: ECHO CR AS CR
	MOVEI	T1, 1		;NO: ECHO CR AS CRLF
	DPB	T1, LDSECR
	MOVE	T1, [LTSECR]
	IORM	T1, LDBTMT(U)
	MOVEI	T1, 1
	DPB	T1, LOPSTC	;SET SEND-CHARACTERISTICS
	DPB	T1, LDBOPB(U)	;SET WANT-OUTPUT
	POPJ	P,
SUBTTL PSEUDO-TTYS

;CREPTY UUO - CREATE A PTY
;
;	CREPTY	AC,
;	  ERROR RETURN	;AC/ ERROR CODE
;	NORMAL RETURN	;AC/ PORT1#,,PORT2#

CPNPT%==1	;OUT OF PTYS (OR THERE NEVER WERE ANY)
CPNRM%==2	;NO ROOM FOR PTYS (OUT OF DDBS)

CREPTY::PUSHJ	P, GETPP	;GET A PORT# PAIR. T1/ EVEN SIDE #
	  JRST	[MOVEI	T1,CPNPT%
		 JRST	CPERR	]
	MOVEM	T1, P1
	PUSHJ	P, PTYLDB	;SET UP ITS LDB. U/ LDB ADDR
	HRLM	U, P2		;P2/ EVEN-SIDE LDB,,---
	PUSHJ	P, PTYDDB	;SET UP ITS DDB. F/ DDB ADDR
	  JRST	[MOVEI	T1, CPNRM%
		 JRST	CPERR	]
	HRRM	F, P2		;P2/ EVEN-SIDE LDB,,DDB
	MOVEI	T1, 1(P1)	;T1/ ODD-SIDE PORT#
	PUSHJ	P, PTYLDB	;SET UP ITS LDB. U/ LDB ADDR
	PUSHJ	P, PTYDDB	;SET UP ITS DDB. F/ DDB ADDR
	  JRST	[HRRZ	F, P2
		 PUSHJ	P, TTYKDB	;FREE EVEN DDB
		 HLRZ	U, P2
		 HLLZS	LDBDDB(U)	;DETACH EVEN LDB
		 SETZM	LDBLOG(U)	;FREE EVEN LDB (leave LDPHST)
		 MOVEI	T1,CPNRM%
		 JRST	CPERR	]
	HRLS	P1		;P1/ EVEN PORT#,,EVEN PORT#
	TRO	P1, 1		;P1/ EVEN PORT#,,ODD PORT#
	UMOVEM	P1, (M)		;GIVE USER THE PORT #S
	JRST	CPOPJ1		;SUCCESS!

CPERR:	UMOVEM	T1, (M)		;GIVE USER THE ERROR CODE
	POPJ	P,		;FAILURE!
SUBTTL	GETPP - GET AN EVEN/ODD PTY PORT # PAIR
;	  NONSKIP-RETURN IF NONE
;	  SKIP-RETURN WITH T1/ THE EVEN # ON SUCCESS
;DESTROYS T2 U

GETPP:	SKIPA	T1,[<<PORTN##-PPORTN##+1>&<-1-1>>]
GETPP1:	ADDI	T1,2		;GO ON TO THE NEXT PAIR
	CAILE	T1,PORTN##-2	;IF WE'RE PAST THE TOP PAIR,
	 POPJ	P,		;  FAIL
	HRRZ	T2,LINTAB(T1)	;T2/ EVEN-SIDE LDB ADDR
	SKIPE	LDBLOG(T2)	;IF IT'S LOGGED-IN,
	 JRST	GETPP1		;  TRY THE NEXT PAIR
	HRRZ	T2,LINTAB+1(T1)	;T2/ ODD-SIDE LDB ADDR
	SKIPE	LDBLOG(T2)	;IF IT'S LOGGED-IN,
	 JRST	GETPP1		;  TRY THE NEXT PAIR
	JRST	CPOPJ1		;SUCCESS!

;PTYBUD - GET PTY BUDDY
;	CALLED WITH U/ PTY LDB
;	RETURNS U/ PTY LDB OF ITS OTHER END

PTYBUD:	LDB	U,LDPLNO
	TRC	U,1
	HRRZ	U,LINTAB(U)	;U/ "BUDDY" LDB ADDR
	POPJ	P,
SUBTTL	PTYLDB - SET UP A PTY LDB
;	   CALLED WITH T1/ PTY PORT #
;	   RETURN WITH U/ THE LDB

PTYLDB:	HRRZ	U,LINTAB(T1)	;U/ LDB ADDR
	SKIPN	U
	 STOPCD
	LDB	T2,LDPLNO	;T2/ LDB'S IDEA OF ITS PORT #
	CAME	T1,T2
	 STOPCD

    ;NOW THAT WE'VE GOT THE LDB, INITIALIZE IT
    ;THIS CODE SHOULD REMAIN ALMOST IDENTICAL WITH
    ;THE CODE AT AUXINP FOR NEW AUX CIRCUITS

	MOVSI	T1,(1B0)	;"Logged-in" bit (term id of 0)
	LDB	T2,LDPLNO	;This line's number
	TRC	T2,1		;Circuit came from its buddy
	DPB	T2,[POINT 8,T1,35] ;Origination line number
	MOVEM	T1,LDBLOG(U)	;Node number gets set by LOGLDB routine
	MOVE	T1,SYSNUM##	;System number is
	DPB	T1,LDPHST	; origination host number for PTY
	SETZM	LDBOUT(U)
	SETZM	LDBBYT(U)
	SETZM	LDBMOD(U)
	MOVEI	T1,^D80		;"SET TTY WIDTH 80"
	DPB	T1,LDPWID
	SETZM	LDBTMT(U)
	ZZN==0
	REPEAT TMCSIZ, <SETZM LDBTMR+ZZN(U)
	ZZN==ZZN+1>
	MOVSI	T1,LDLDEF!LDLPTY
	MOVEM	T1,LDBDCH(U)	;DIFFERENT FROM AUX CIRCUITS!
	MOVSI	T1,LXL120
	MOVEM	T1,LDBDCX(U)	;BUFFER AS A FAST LINE
	SETZM	LDBTCB(U)	;NO CHANGED TERMINAL CHARACTERISTICS
	PUSHJ	P,SETLMD	;SET THE LINE MODE
	POPJ	P,
SUBTTL	PTYDDB - ALLOCATE, LINK IN, ATTACH, INITIALIZE A PTY DDB
;	   CALLED WITH U/ LDB ADDRESS, J/ ATTACHEE JOB #
;	   NONSKIP-RETURNS IF THERE ARE NO FREE DDBS
;	   SKIP-RETURNS WITH F/ DDB ADDR ON SUCCESS

PTYDDB:	HRRZ	T1, TTYTAB(J)	;T1/ CMND PORT DDB
	SKIPN	T1
	 STOPCD 		;(THERE MUST BE ONE)
	PUSHJ	P, DDBSR1	;F/ NEW DDB, LINKED AFTER CMND PORT
	  POPJ	P,		;FAIL-RETURN

	DPB	J, PJOBN	;SET JOB # OF OWNER
	PUSHJ	P, SCNNAM	;SET PHYSICAL NAME
	MOVEI	T1, ASSCON
	IORM	T1, DEVMOD(F)	;MARK IT ASSIGNED-BY-CONSOLE
	MOVEI	T1, TTYATC
	ANDCAM	T1, DEVMOD(F)	;AND NOT THE COMMAND PORT

	AOS	(P)		;SET TO SKIP-RETURN
	PJRST	COMATT		;AND ATTACH IT
SUBTTL AUXCAL UUO

;AUXCAL UUO

AUXTUU::XCTFU	<HLRE F,(W)>	;F/ PORT DESCRIPTOR
	MOVE	J,JOB		;J/ JOB #
	PUSHJ	P,FNDPRT	;F := DDB ADDR.
	  POPJ	P,		;(NO PORT OR NOT THIS JOB'S PORT)
	HRRZ	U,DDBLDB(F)	;U/ LDB ADDR
	JUMPE	U,CPOPJ		;IF DETACHED, JUST RETURN
	XCTFU	<HRRZ T1,(W)>	;T1/ FUNCTION CODE
	CAIL	T1,AXCLEN	;IF IT'S OUT OF RANGE,
	 POPJ	P,		;  JUST RETURN
	AOS	AXCCNT(T1)	;Count AUXCALs by function
	MOVE	T3,AXCTAB(T1)
	MOVE	S,DEVIOS(F)	;S/ FILE STATUS BITS
	PUSHJ	P,UUOLDB	;SET UP LDB
	TLNN	T3,TUUROM
	 JRST	AUXTU0
	PUSHJ	P,CHKROM
	JRST	AUXTUU
AUXTU0:	TLNE	T3,TUUAIR
	TLNN	U,LDLCOM	;INPUT NOT ALLOWED IF AT COMMAND LEVEL
	 SKIPA
	  POPJ	P,
	TLNE	T3,TUUEAT
	 PUSHJ	P,TYIEAT
IFE OPCRET,<	; KLUDGE TIL OPERATIONS CAN WRITE 10 CODE
	TLNE	T3,TUUFXI
	PUSHJ	P,FIXIMI	;SET IMAGE STATE FROM DATA MODE
>;OPCRET=1 IF PROGRAMS THINK TTCALLS IGNORE IMAGE

	TLNN	T3,TUUIMI
	 JRST	AUXTU1
	MOVSI	T1,LDLIMI
	IORM	T1,LDBDCH(U)	;SET IMAGE STATE ALWAYS
	PUSHJ	P,SETLMD
AUXTU1:	JRST	(T3)
SUBTTL	AUXCAL dispatch table

AXCTAB:	TUUAIR!TUUEAT!TUUIMI,,ACINWC	;0 INPUT CHRS AND WAIT
	TUUAIR!TUUEAT!TUUIMI,,ACINSC	;1 INPUT CHRS AND SKIP
	TUUAIR!TUUEAT!TUUIMI,,ACINWB	;2 INPUT CHRS ELSE AWAIT BREAK
		      TUUROM,,IONEOU	;3 OUTPUT CHARACTER
		      TUUROM,,ACOTCI	;4 OUTPUT CHARACTER IMMEDIATE
		      TUUROM,,OUTPTR	;5 OUTPUT FROM POINTER
			      TSETBI	;6 CLEAR INPUT BUFFER
			      TSETBO	;7 CLEAR OUTPUT BUFFER
	TUUAIR!TUUEAT!TUUFXI,,SKPINC	;10 SKIP IF CHRS PRESENT
		      TUUFXI,,LEVDEF	;11 LEAVE DEFERRED ECHO MODE
			      ACSYL	;12 SEND YELLOW BALL
			      ACBRKC	;13 SET BREAK CHARACTER
		      TCNCRD,,ACTMC	;14 CR DELAY (NOT LF)
		       TCNIR,,ACTMC	;15 INPUT RATE
		       TCNOR,,ACTMC	;16 OUTPUT RATE
		      TCNPAR,,ACTMC	;17 PARITY
		      TCNHDX,,ACTMC	;20 HALF DUPLEX
		       TCNPA,,ACTMC	;21 PARAMETER A
		       TCNPB,,ACTMC	;22 PARAMTER B
		       TCNPC,,ACTMC	;23 PARAMETER C
		      TCNNXO,,ACTMC	;24 SET NO XON-XOFF
			      ACNTB	;25 SET NO SPECIAL TAB HANDLING
			      ACTBK	;26 SET TABS AS BREAKS
		      TCNWID,,ACTMC	;27 SET WIDTH
		      TCNFC1,,ACTMC	;30 SET FILLER CLASS 1
		      TCNFC2,,ACTMC	;31 SET FILLER CLASS 2
			      SETIO2	;32 SET FILE STATUS, DON'T FIXIMI
			      FRCINP	;33 FORCE INPUT
			      BLKIO	;34 ENABLE BLOCK INPUT/OUTPUT
	       TUUAIR!TUUEAT,,BLKINP	;35 INPUT A BLOCK
	       TUUAIR!TUUEAT,,BLKINS	;36 INPUT BLOCK &SKIP IF DATA
			      BLKOUT	;37 OUTPUT A BLOCK
			      BLKXIN	;40 REQUEST BLOCK INPUT TERMINATION
			      BLKXOT	;41 REQUEST BLOCK OUTPUT TERMINATION.
			      BLKXIO	;42 TERMINATE BLOCK I/O MODE
			      MAKDET	;43 TURN COMMAND PORT TO "AUX"PORT
	       TUUEAT!TUUFXI,,I1CHRW	;44 INPUT CHRS AND WAIT
	TUUAIR!TUUEAT!TUUFXI,,INCHRS	;45 INPUT CHRS AND SKIP
	       TUUEAT!TUUFXI,,I1CHWL	;46 INPUT CHRS AND WAIT LINE
	TUUAIR!TUUEAT!TUUFXI,,INCHSL	;47 INPUT CHRS AND SKIP LINE
	TUUAIR!TUUEAT!TUUFXI,,SKPINL	;50 SKIP IF LINE PRESENT
		      TUUROM,,OUTCHI	;51 OUTPUT CHR IMMEDIATE (NOT IMAGE
		      TUUROM,,OUTSTR	;52 OUTPUT STRING
		      TCNXON,,ACTMC	;53 SET XON-XOFF PARAMETER
		      TCNECH,,ACTMC	;54 SET ECHO CONTROL H PARAMETER
		      TCNRXE,,ACTMC	;55 SET REVERSE XON-XOFF PARAMTER
		       TCNPD,,ACTMC	;56 SET PARM D (was TCNTYP/TCNKAT)
		      TCNBSP,,ACTMC	;57 SEND BACKSPACE FOR RUBOUT SEQ
			      ACHNG	;60 SEND HANGUP
			      ACPSM	;61 READ PORT STATUS MESSAGE
		      TCNERA,,ACTMC	;62 ERASE FOR CHAR DELETE
		      TCNDEF,,ACTMC	;63 DEFERRED-ECHO MODE
			      ACSFS	;64 SET FILE STATUS, THEN FIXIMI
		      TCNLCO,,ACTMC	;65 SET/CLEAR LOWER CASE ONLY OUTPUT FLAG
			      ACBBP	;66 SET BACKSPACE AS BREAK2
		      TUUROM,,OUTPTC	;67 OUTPUT FROM POINTER+COUNT
			      ACSOB	;70 SEND ORANGE BALL
			      ACSOX	;71 SET/CLEAR SUPPRESS-OUTPUT-TRANSLATION
			      FRCRSC	;72 FORCE A RESCAN LINE (COUNT/POINTER
			      ACTCN	;73 SET TERMINAL CHARACTERISTIC BY NUMBER
			      ACTCP	;74 READ CHANGED TC #,,VAL FOR A PTY
			      ACNZP	;75 NO-ZAP-ON-RESET BIT
			      OUTSNW	;76 OUTPUT STRING, NEVER WAIT
		      TCNBSD,,ACTMC	;77 BACKSPACE == RUBOUT/^A
		      TCNCLA,,ACTMC	;100 Set/Read Terminal Class
		      TCNRTC,,ACTMC	;101 Set/Read LXLRTC (Special ^T Mode)
		      TCNKAT,,ACTMC	;102 Set/Read Katakana bit
		      TCNTYP,,ACTMC	;103 Set/Read Terminal Type
AXCLEN==.-AXCTAB

  TTNEGL==TTUUOT-TTUNEG		;Number of negative TTCALLS
TTCNEG:	BLOCK	TTNEGL+20	;Negative TTCALLs and positive TTCALLs
TTCCNT=:TTCNEG+TTNEGL		;Define address for TTCALL 0 count
AXCCNT::BLOCK	AXCLEN		;Count of AUXCALs by function
	SYDVF	(<<TTCNEG,TTNEGL>,<TTCCNT,20>,<AXCCNT,AXCLEN>>)	;3 items for SYSDVF
SUBTTL	READ/SET TERMINAL CHARACTERISTICS BY NUMBER

ACTCN:	XCTFU	<HLRZ T1,(M)>	;T1/ CHAR #
	XCTFU	<HRRE T2,(M)>	;T2/ NEW VALUE OR -1 TO READ
	PUSHJ	P,SETTCN	;TRY TO DO IT
	  POPJ	P,		;(BAD TC# OR BAD NEW VALUE)
	XCTBU	<HRRM T3,(M)>	;GIVE USER THE OLD VALUE
	AOS	(P)
	POPJ	P,

;READ CHANGED TERMINAL CHARACTERISTIC FROM PTY

ACTCP:	HLL	U,LDBDCH(U)
	TLNN	U,LDLPTY	;IF IT'S NOT A PTY,
	 POPJ	P,		;  ERROR-RETURN
	PUSH	P,U
	PUSHJ	P,PTYBUD
	MOVE	T1,LDBTCB(U)	;T1/ CHANGED-TC BITS
	JFFO	T1,ACTCP1	;IF NONE,
	XCTTU	<SETOM (M)>	;  GIVE CALLER A -1 WORD
	JRST	ACTCP2
ACTCP1:	MOVN	T1,T2
	MOVSI	T4,(1B0)
	LSH	T4,(T1)
	ANDCAM	T4,LDBTCB(U)	;CLEAR THE "UNREAD" BIT
	MOVE	T1,T2		;T1/ TC#
	XCTBU	<HRLM T1,(M)>	;GIVE CALLER THE TC#
	SETO	T2,		;-1 = READ TC
	PUSHJ	P,SETTCN
	 STOPCD
	XCTBU	<HRRM T3,(M)>	;GIVE CALLER THE TC VALUE
ACTCP2:	POP	P,U
	JRST	CPOPJ1
SUBTTL	SETTCN - READ/SET TERMINAL CHARACTERISTICS BY NUMBER
;	   CALLED WITH T1/ CHARACTERISTIC # (TCNxxx)
;		       T2/ NEW VALUE (-1 TO JUST READ)
;		       U/ LDB ADDR
;	   NONSKIP-RETURNS IF TC# OR NEW VALUE IS OUT OF BOUNDS
;	   SKIP-RETURNS WITH T3/ OLD VALUE OTHERWISE
;
;SETTC1 - ASSUMES TC# IS IN BOUNDS

SETTCN:	CAIGE	T1,TCNN		;IF TCNxxx OUT OF BOUNDS
SETTC1:	CAMLE	T2,TCVMAX(T1)	;OR NEW VALUE TOO BIG,
	 POPJ	P,		;  ERROR-RETURN
	HRRZ	T3,TCNDSP(T1)	;TYPE, one of TYMTC, BYTTC, or ACxxxC
	PUSH	P,T1
	HRLM	T2,(P)		;(P)/ (NEW VALUE OR -1),,TC#
	PUSHJ	P,(T3)		;DISPATCH
	  JRST	TPOPJ		;  ERROR-RETURN
	MOVSI	T1,LDLPTY
	SKIPL	(P)		;IF WE WERE JUST READING
	TDNN	T1,LDBDCH(U)	;OR IT'S NOT A PTY,
	 JRST	TPOPJ1		;  JUST SKIP-RETURN
	HRRZ	T1,(P)
	MOVN	T1,T1		;T1/ - TC#
	MOVSI	T2,(1B0)
	LSH	T2,(T1)		;T2/ LDBTCB BIT FOR THE TC
	IORM	T2,LDBTCB(U)	;SET IT
	MOVEM	T3,(P)
	PUSH	P,U
	PUSH	P,F
	PUSH	P,J
	PUSHJ	P,PTYBUD	;U/ BUDDY LDB ADDR
	MOVEI	T1,LXRTCC
	IORM	T1,LDBDCX(U)	;NOTE THAT A TC WAS CHANGED
	HRRZ	F,LDBDDB(U)
	JUMPE	F,SETTC2	;IF THE OTHER END IS ATTACHED
	LDB	T1,DDPTTC
	JUMPE	T1,SETTC2	;AND TRAPPING TC CHANGES
	PUSHJ	P,TAKTRJ	;  SIGNAL THE CHANGE
SETTC2:	POP	P,J
	POP	P,F
	POP	P,U
	POP	P,T3
	JRST	CPOPJ1

;If TYPE=BYTTC, then ARG = name of byte pointer (LDPxxx)
;If TYPE=TYMTC, then ARG = name of host-to-base # (TMCxxx)

DEFINE Z(NAME,MAXVAL,TYPE,ARG) = <ARG,,TYPE>
TCNDSP:	TCHARS

DEFINE Z(NAME,MAXVAL,TYPE,ARG) = <MAXVAL>
TCVMAX:	TCHARS

;BYTTC - update byte in LDB, for things the TYMSAT does not do for us

BYTTC:	HLRZ	T1,TCNDSP(T1)	;T1/ BYTE POINTER ADDR
	LDB	T3,(T1)		;Get old value from LDB
	SKIPL	T2		;If not -1, then
	 DPB	T2,(T1)		; set new value in the LDB
	JRST	CPOPJ1
SUBTTL	SETTCN ROUTINES

;TYMTC - READ/SET TYMNET TERMINAL CHARACTERISTICS
;	 CALLED WITH T1/ CHARACTERISTIC # (TCNxxx)
;		      T2/ -1 (TO JUST READ) OR NEW VALUE
;	  SKIP-RETURNS WITH T3/ THE OLD VALUE
;TYMTC1 - CALLED WITH T1/ TYMNET'S TC# (TMCxxx)

TYMTC:	HLRZ	T1,TCNDSP(T1)	;USER TC# = TYMNET TC#
TYMTC1:	CAILE	T1,MAXTMC	;IF OUT-OF-RANGE,
	 STOPCD 		;  CRASH
	LDB	T3,TABTMR(T1)	;T3/ old received value
	JUMPL	T2,CPOPJ1	;IF JUST LOOKING, SUCCESS-RETURN
	DPB	T2,TABTMS(T1)	;Store new value to be sent to the TYMSAT
;Japanese customers use the command "TTY TYPE 1" and expect it to do both
;"SET TTY D 15" and "SET TTY KATAKANA".  MAGNUM expects Katakana terminals
;to have parameter D set to octal 17, ASCII terminals have D set to 0.
;NOTE: The old BASEs translated TYMNET terminal characteristic #15 (PARM-D)
;from to host to TYMNET terminal characteristic #16 (KATAKANA) before
;passing the command to the TYMSAT.  As an interim measure, set both when
;either is changed.
	CAIE	T1,TMCPD	;"SET TTY D 1"?
	CAIN	T1,TMCKAT	; or "SET TTY KATAKANA"?
	 SKIPA			;Yes, set both
	  JRST	TYMTC2		;No
	DPB	T2,TABTMS+TMCKAT;Set KATAKANA bit if parm D is odd
	DPB	T2,TABTMR+TMCKAT;EBUS02.J01 does not return KATAKANA bit to us
	DPB	T2,TABTMS+TMCPD	;Set parm D if KATAKANA bit is set
	TRNN	T2,1		;Simulate TYMNET-I's one-bit field
	TDZA	T2,T2		; Even = 0
	 MOVEI	T2,17		; Odd = 17
	DPB	T2,TABTMR+TMCPD	;Store this value to be overwritten if the node
				; does understand "parameter D"
	MOVE	T2,[1B<TMCPD>!1B<TMCKAT>]
	IORM	T2,LDBTMT(U)	;Mark them both as being changed

TYMTC2:	MOVNS	T1		;Negative of TYMNET's TC
	MOVSI	T2,(1B0)
	LSH	T2,(T1)		;Position to bit (B0 thru B20)
	IORM	T2,LDBTMT(U)	;SET TRANSMIT BIT
	MOVEI	T1,1
	DPB	T1,LOPSTC	;SET SEND-CHARACTERISTICS
	AOS	(P)		;skip return
SETOPB:	DPB	T1,LDBOPB(U)	;SET NEED-OUTPUT
	POPJ	P,
SUBTTL	SETTCN ROUTINES

;WIDTH

ACWIDC:	LDB	T3,LDPWID
	JUMPL	T2,CPOPJ1
	CAIL	T2,^D20		;IF IT'S TOO SMALL
	CAILE	T2,^D199	;OR TOO LARGE,
	 POPJ	P,		;  ERROR-RETURN
	DPB	T2,LDPWID	;ELSE SET IT
	JRST	CPOPJ1

;BACKSPACE FOR DELETE

ACBSPC:	LDB	T3,LDPERA
	TRZN	T3,1		;IF ERASE IS SET, SAY BS ISN'T
	 LDB	T3,LDPBSP
	JUMPL	T2,CPOPJ1
	DPB	T2,LDPBSP
	SETZ	T2,
	DPB	T2,LDPERA	;ALWAYS CLEAR ERASE
	JRST	CPOPJ1

;ERASE FOR DELETE

ACERAC:	LDB	T3,LDPERA
	JUMPL	T2,CPOPJ1
	DPB	T2,LDPERA
	DPB	T2,LDPBSP	;EITHER SET BOTH OR CLEAR BOTH
	JRST	CPOPJ1

;DEFERRED ECHO

ACDEFC:	LDB	T3,LDPDEM
	JUMPL	T2,CPOPJ1
	MOVE	T1,LDBDCH(U)
	TRNE	T2,1
	 TROA	T1,LDRDEM
	  TRZ	T1,LDRDEM
	EXCH	T1,LDBDCH(U)
	CAME	T1,LDBDCH(U)	;IF THE BIT CHANGED
	TLNE	T1,LDLNEC	;AND NO ECHO NOT SET,
	 JRST	CPOPJ1
	MOVEI	T1,1
	DPB	T1,LOPSEC	;  SET SEND-ECHO
	DPB	T1,LDBOPB(U)	;  AND NEED-OUTPUT
	JRST	CPOPJ1
SUBTTL	SETTCN ROUTINES

;PAPER TAPE MODE

ACPTPC:	LDB	T3,LDPPTP
	JUMPL	T2,CPOPJ1
	DPB	T2,LDPPTP	;SET PAPER-TAPE BIT TO USER VALUE
	PUSH	P,T3
	TRC	T2,1
	MOVEI	T1,TMCECR
	PUSHJ	P,TYMTC1	;AND CR-AS-CRLF TO ITS COMPLEMENT
	 STOPCD
	POP	P,T3
	JRST	CPOPJ1

;[JMS] Terminal Type - Must be a valid type

ACTTYP:	LDB	T3,LDPTYP	;T3 := old value
	CAMN	T2,[-1]		;Setting or reading?
	 JRST	CPOPJ1		;Just reading
	DPB	T2,LDPCLA	;Set TTY CLASS to this value
;Need to verify that this type is valid (such as VT100, HP2621, TYM444, etc)
	DPB	T2,LDPTYP	;Valid type, set it
PRINTF (<[Need to set WIDTH, ERASE, etc at ACTTYP]>)
	JRST	CPOPJ1

;[dws] Terminal Class - can be any SIXBIT value

ACTCLA:	LDB	T3,LDPCLA	; T3 := old value
	CAME	T2,[-1]		; Don't store if only reading
	 DPB	T2,LDPCLA	;  new valued := T2
	JRST	CPOPJ1
SUBTTL	NO SPECIAL TAB HANDLING

ACNTB:	LDB	T2, LDPNTB
	XCTBU	<EXCH T2,(M)>
	JUMPL	T2, CPOPJ
	DPB	T2, DDPNTB
	DPB	T2, LDPNTB
	POPJ	P,

;TABS AS BREAKS

ACTBK:	LDB	T2, LDPTBK
	XCTBU	<EXCH T2,(M)>
	JUMPL	T2, CPOPJ
	DPB	T2, DDPTBK
	MOVEI	T1, L2LTBK
	TRNE	T2, 1		;CHECK LOW ORDER BIT
	HRLI	T1, L2LTBK
	PJRST	SETTBK		;GO SET IT

;BACKSPACE AS PUNCTUATION

ACBBP:	LDB	T2, LDPBBP
	XCTBU	<EXCH T2,(M)>
	JUMPL	T2, CPOPJ
	DPB	T2, DDPBBP
	MOVEI	T1, L2LBBP
	TRNE	T2, 1		;CHECK LOW ORDER BIT
	HRLI	T1, L2LBBP
	PJRST	SETTBK		;GO SET IT

;SUPPRESS-OUTPUT-TRANSLATION (FOR PTYS ONLY)

ACSOX:	HLL	U, LDBDCH(U)
	TLNN	U, LDLPTY	;IF IT'S NOT A PTY,
	POPJ	P,		;  JUST RETURN
	PUSH	P, U
	PUSHJ	P, PTYBUD	;U/ "BUDDY" LDB ADDR
	LDB	T1, LDPSOX	;T1/ CURRENT SOX VALUE
	XCTBU	<EXCH T1,(M)>	;SWAP WITH ARGUMENT
	JUMPL	T1, .+2		;IF USER SUPPLIED A NEW VALUE,
	DPB	T1, LDPSOX	;  SET IT
	POP	P, U
	POPJ	P,

;READ/SET DVNZP BIT

ACNZP:	LDB	T1, DDPNZP	;T1/ CURRENT VALUE
	XCTBU	<EXCH T1, (M)>	;SWAP WITH USER'S
	JUMPL	T1, CPOPJ	;(JUST READING)
	DPB	T1, DDPNZP	;SET IT
	POPJ	P,
SUBTTL	OLD AUXCAL TERMINAL-CHARACTERISTICS DISPATCH

ACTMC:	HLRZ	T1,T3		;T1/ CHARACTERISTIC #  (TCNxxx)
	XCTFU	<MOVE T2,(M)>	;T2/ USER'S ARGUMENT
	PUSHJ	P,SETTC1	;T3 := OLD VALUE
	  JFCL			;(NEW VALUE WAS BAD)
	XCTTU	<MOVEM T3,(M)>	;STORE IT
	POPJ	P,

;SET FILE STATUS BITS, THEN FIX IMAGE STATE

ACSFS:	PUSHJ	P,SETIO2
	HRR	U,DDBLDB(F)
	MOVE	S,DEVIOS(F)
	PJRST	FIXIMI

;SEND YELLOW BALL

ACSYL:	MOVEI T1,1
	DPB T1,LOPSYL		;SET SEND-YELLOW
	PJRST SETOPB

;SEND ORANGE BALL

ACSOB:	MOVE	T1, LDBDCX(U)
	TLZN	T1, LXLOOK	;IF IT'S OK TO SEND 1,
	  POPJ	P,
	MOVEM	T1, LDBDCX(U)	;  (NOT 2, JUST 1)
	MOVSI	T1, L2LLDF
	IORM	T1, LDBBYT(U)	;  FAKE INPUT WAIT SO BALL'LL GO
	MOVEI	T1, 1
	DPB	T1, LOPSOG	;  SET SEND-ORANGE
	PJRST	SETOPB

;SEND HANGUP (SOFT ZAPPER)

ACHNG:	MOVEI	T1, 1
	DPB	T1, LOPHNG	;SET SEND-HANG
	PJRST	SETOPB

;Read last PORT STATUS message (AUXCAL function .AXPSM=61)
;From the YAMM dated July 1980: "The port status returned is 4 bits for
;which there is no documentation.  This operation was implemented for the
;initial TYMNET-I Dial-Out facility."  The current code in the base,
;EBUS02.J01, does not have any code for passing this message to the PDP-10.

ACPSM:	LDB	T1, LDPPSM	; GET LAST PORT STATUS MSG
	UMOVEM	T1, (M)		; GIVE IT TO HIM
	MOVSI	T1, LMLPSP
	ANDCAM	T1, LDBMOD(U)	; AND NOTE IT'S BEEN READ
	POPJ	P,
SUBTTL	SET IMAGE BREAK CHARACTER

ACBRKC:	UMOVE	T1, (M)
	TRNN	T1, 400		;IF IMAGE BIT NOT ON,
	SETZ	T1,		;  CLEAR THE CHARACTER
	DPB	T1, LDPIMB
	DPB	T1, DDPIMB
	POPJ	P,
SUBTTL	IMAGE-STATE INPUT AUXCALS

ACINWC:	NOCHARGE
ACIN1:	PUSHJ P,TWAITC	;THIS WILL SET MODE TO IMAGE
	PUSHJ P,TYI
	 JRST ACIN1	;TRY AGAIN
ACIN2:	ANDI T3,377
	UMOVEM T3,(M)
	AOS (P)		;SKIP RETURN (AS OPPOSED TO NO PORT)
	JRST NOCTRO

ACINSC:	NOCHARGE
	SKIPG LDBECC(U)	;ANY CHRS?
	SKIPLE LDBTIC(U)
	SKIPA		;YES
	JRST SETLMD	;NO, SET TO IMAGE ANYWAY
	PUSHJ P,TWAITS
	  POPJ	P,	;DETACHED
	PUSHJ P,TYI
	 JRST NOCTRO	;NONE THERE
	JRST ACIN2	;GIVE IT TO HIM

ACINWB:	NOCHARGE
	PUSHJ P,TWAITL	;WAIT FOR IMAGE-MODE BREAK CHARACTER OR TIMEOUT
	PUSHJ P,TYI
	 POPJ P,	;PROBABLY END OF FILE SET
	JRST ACIN2	;GIVE HIM CHR
SUBTTL	AUXCAL -- .AXSI=33 - Simulate input

FRCINP:	UMOVE	M,(M)		;GET BYTE POINTER
	TLZ	M,37		;GET RID OF INDEX AND INDIRECT
	MOVE	T1,M		;Check the string before forcing input
	MOVEI	T2,0
FRCLP0:	XCTFU <ILDB T3,T1>	;Get char
	ANDI	T3,377		;Watch out for strange byte sizes
	SKIPE	T3
	 AOJA	T2,FRCLP0	;Loop until null
	ADD	T2,LDBTIC(U)	;Add to count of chars already input
	ADD	T2,LDBECC(U)	; and chars not yet echoed
	CAML	T2,TIHLTN	;If it would exceed the limit
	 POPJ	P,		; then do nothing and give error return

FRCLP1:	XCTFU <ILDB T3,M>
	ANDI	T3,377		; USE ONLY THE RIGHT 8 BITS
	JUMPE	T3,CPOPJ1	;FINISHED
	PUSHJ	P,MOVCHR	;PUT CHR IN INPUT BUFFER
	  JRST	FRCLP1		;NO ECHO REQUIRED
	MOVEI	T1,1		;LAST CHAR SWITCHED TO DEFERED ECHO
	DPB	T1,LOPECO	;SET NEED-ECHO
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
FRCLP2:	XCTFU <ILDB T3,M>	;LOOP HERE FOR DEFERED ECHO MODE
	ANDI	T3,377		; USE ONLY THE RIGHT 8 BITS
	JUMPE	T3,CPOPJ1	;FINISHED
	PUSHJ	P,MOVCHR	;PUT CHAR IN OTHER INPUT BUFFER
	  JFCL			;SHOULD ALWAYS SKIP NOW
	JRST	FRCLP2		;LOOP IN EITHER CASE
SUBTTL	FORCE A RESCAN LINE

%FROK==0	;NO ERROR
%FRAUX==1	;PORT IS AN AUX CIRCUIT
%FRBIG==2	;COMMAND STRING IS TOO BIG
%FRCMD==3	;PORT IS IN COMMAND STATE
%FRBRK==4	;BREAK BEFORE END OF COMMAND STRING (BYTE PTR UPDATED)
%FRNBK==5	;NO BREAK ENCOUNTERED IN STRING
%FRFUL==6	;RESCAN COMMAND ALREADY PRESENT

FRCRSC:	HLL	U, LDBDCH(U)
	TLNE	U, LDLAUX	;IF PORT IS AN AUX CIRCUIT,
	 JRST	[
		MOVEI	P1, %FRAUX
		JRST	FRCRSX	;  ERROR-RETURN
	]
	TLNE	U, LDLCOM	;IF PORT IS IN COMMAND STATE,
	 JRST	[
		MOVEI	P1, %FRCMD
		JRST	FRCRSX	;  ERROR-RETURN
	]
	XCTFU	<MOVE P1, 0(M)>	;P1/ COUNT
	CAIL	P1, TIWKC	;IF IT'S TOO BIG,
	 JRST	[
		MOVEI	P1, %FRBIG
		JRST	FRCRSX	;  ERROR-RETURN
	]
FRCRS1:	MOVE	T1, P1
	ADDI	T1, <<<TTCHKS-1>*4>-1>
	IDIVI	T1, <<TTCHKS-1>*4>	;T1/ # CHUNKS NEEDED
	MOVE	T2, TTFREN
	SUBI	T2, TIRSVD	;T2/ # CHUNKS AVAILABLE
	CAMG	T1, T2		;IF THERE AREN'T ENOUGH,
	 JRST	FRCRS2
	MOVSI	S, TWTSPC
	IORB	S, DEVIOS(F)	;  NOTE THAT WE NEED MORE ROOM
	LDB	T1, DDPTTI	;  T1/ IOW-INTERRUPT ASSIGNMENT
	PUSHJ	P, TSTKTJ	;  IF HE TRAPPED IT,
	JRST	[
		PUSHJ	P, SETFIO	;SET TO GIVE I/O DONE TRAP
		PJRST	ABTUUO		;AND GET OUT
	]
	PUSH	P, P1
	PUSHJ	P, TOWAT1	;  GO INTO OUTPUT WAIT
	POP	P, P1
	JRST	FRCRS1		;  THEN TRY AGAIN
FRCRS2:	PUSHJ	P, TSETBI	;CLEAR THE INPUT BUFFER (!)
	HLL	U, LDBDCH(U)
	SKIPE	FRSFLG
	 STOPCD
	SETOM	FRSFLG		;SET FLAG FOR CMDPGAK
	TLO	U, LDLCOM	;SET COMMAND STATE
	SETZM	FRSDEF
	TLZE	U, LDLDEF	;CLEAR DEFERRED-ECHO
	SETOM	FRSDEF		;(REMEMBER PGHAT IT PGAS)
	HLLM	U, LDBDCH(U)
	PUSHJ	P, SETLMD	;FIX LINE-MODE FIELD

    ;HERE TO ACTUALLY FORCE THE INPUT
    ;P1/ COUNT

	XCTFU	<MOVE PG, 1(M)>	;PG/ BYTE POINTER
	TLZ	PG, 37		;CLEAR INDEX AND INDIRECT BITS
	PUSH	P, P1		;0(P)/ COUNT

FRCRS3:	SOSGE	0(P)		;DONE?
	JRST	FRCRS4		;(YES)
	XCTFU	<ILDB T3, PG>	;T3/ NEXT CHARACTER
	ANDI	T3, 377		;(ONLY 8 BITS)
	PUSHJ	P, MOVCHR	;DEPOSIT IT
	JRST	.+1		;(REMOTE-ECHO RETURN)
	SKIPE	FRSFLG		;IF CMDPGAK NOT CALLED YET,
	JRST	FRCRS3		;  TRY THE NEXT CHARACTER

    ;HERE WHEN A "COMMAND LINE" HAS BEEN FORCED

	POP	P, T1		;T1/ COUNT LEFT
	JUMPE	T1, FRCRS5	;IF THERE'RE CHARS AFTER THE BREAK,
	XCTTU	<MOVEM PG, 1(M)>;  STORE BACK THE MODIFIED BYTE POINTER
	MOVEI	P1, %FRBRK	;  ERROR-RETURN
	JRST	FRCRS6

    ;HERE WHEN WE RAN OUT OF CHARACTERS BEFORE A "COMMAND LINE"
    ;WAS FINISHED

FRCRS4:	POP	P, T1
	SETZM	FRSFLG		;CLEAR FLAG
	MOVEI	P1, %FRNBK	;ERROR-RETURN
	JRST	FRCRS6

    ;HERE WHEN THINGS WERE JUST RIGHT

FRCRS5:	MOVEI	P1, %FROK
	PFALL	FRCRS6
    ;CLEAN THINGS UP

FRCRS6:	SKIPN	FRSDEF		;IF PORT WAS IN DEFERRED ECHO MODE,
	JRST	FRCRS7
	MOVSI	T1, LDLDEF
	IORM	T1, LDBDCH(U)	;  SET DEFERRED-ECHO AGAIN
FRCRS7:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	;CLEAR COMMAND MODE
	MOVSI	T1, LDLECS
	IORM	T1, LDBDCH(U)	;SET EAT-COMMAND-SYNC
	PUSHJ	P, SETLMD	;FIX LINE-MODE FIELD

FRCRSX:	SKIPN	P1		;IF NO ERROR OCCURRED,
	AOSA	(P)		;  PREPARE FOR SKIP-RETURN, ELSE
	XCTTU	<MOVEM P1, (W)>	;  USER AC := RETURN CODE
	POPJ	P,
SUBTTL AUXILIARY CIRCUITS

;ONLY ONE AUXILIARY CIRCUIT IS IN THE PROCESS OF BEING BUILT
;AT ANY ONE TIME. JOBS WANTING TO BUILD AN AUX.
;CIRCUIT ARE QUEUED ON THE AX QUE. ONCE A CIRCUIT IS READY TO
;BE BUILT, THE COMMUNICATION WITH THE SUPERVISOR IS
;CONTROLED BY A STATE CELL (AUXSTA). THE FOLLOWING ARE THE STATES

.ASIDL==0	;NOT BUILDING A CIRCUIT
.ASRQ1==1	;READY TO SEND SUPERVISOR REQUEST
.ASWR1==2	;WAITING FOR SUPERVISOR RESOPNSE
.ASRQ2==3	;READY TO RE-SEND SUPERVISOR REQUEST
		;(BECAUSE OF ERROR ON FIRST TRY - PROBABLY
		;COMMUNICATION IS OUT OF SYNC)
.ASWR2==4	;WAITING FOR SUPERVISOR RESPONSE TO RE-SEND
.ASLOG==5	;SENDING LOGIN STRING TO SUPERVISOR
.ASWPT==6	;WAITING FOR A PORT AND A SUPERVISOR RESPONSE
.ASWTP==7	;RECEIVED AN AUX CIRCUIT (MSG TYPE 7) FOR A PORT PENDING A
		; ZAPPER, SO NOW WAITING FOR SUPERVISOR RESPONSE SO WE CAN
		; RE-SEND A SUPERVISOR REQUEST WITHOUT GETTING OUT OF SYNC
		;( ** NOT SUPPOSED TO HAPPEN ** SEE TTYZNE & ZAPBUG ** )

;ERROR NUMBERS FROM THE PDP-10

CX2AX%==1	;TOO MANY AUX CIRCUITS FOR THIS JOB AND NO AC LICENSE
CXLOG%==2	;USER NAMES DO NOT MATCH AND NO AC LICENSE
CXDCB%==3	;NO DDB'S AVAILABLE
CXNRR%==4	;NO RESPONSE TO FIRST REQUEST
CXNRL%==5	;NO RESPONSE AFTER STRING SENT
CXNCH%==6	;NO PORT RECEIVED
CXERR%==7	;ERROR FROM FIRST RESPONSE

;SPECIAL ROUTINE WHEN COMMING OUT OF IO WAIT FINDS
;AN AUX CIRCUIT ZAPPED

AUXRID:	MOVEI	T1,ASSCON!ASSPRG
	TDNN	T1,DEVMOD(F)		;STILL ASSIGNED?
	 PUSHJ	P,TTYKDB		;NO, REMOVE DDB
	JRST	ABTUUO			;IN ANY CASE, ABORT
SUBTTL	TURN THE COMMAND PORT INTO SOMETHING LIKE AN "AUX" PORT

MAKDET:	MOVSI	T1,TTYATC	;MUST BE COMMAND PORT
	TDNN	T1,DEVMOD(F)
	 POPJ	P,
	JUMPE	U,CPOPJ		;DO NOT ALLOW IF NOT COMMAND OR DET
	MOVSI	T1,LLLZAP
	TDNE	T1,LDBLOG(U)
	 POPJ	P,		;OR IF WAITING TO LOG OUT
	MOVSI	T1,LICAC
	TDNE	T1,JBTLIC(J)
	 JRST	MAKDLC		;MUST HAVE LIC OR ONLY ONE OTHER PORT
	PUSHJ	P,FRSTTY
	  JRST	MAKDLC
	PUSHJ	P,NXTTTY
	  JRST	MAKDLC
	PUSHJ	P,NXTTTY
	  JRST	MAKDLC
	POPJ	P,		;ERROR, ALREADY HAVE TWO PORTS
MAKDLC:	HRRZ	F,TTYTAB(J)
	HLRZ	T1,DDBBLK(F)
	PUSHJ	P,DDBSR1	;GET ONE AND LINK IT IN
	  POPJ	P,		;CAN NOT
	HRRZ	T2,TTYTAB(J)
	HRRM	F,TTYTAB(J)	;MAKE A NEW COMMAND PORT
	MOVSI	T1,DVNZP
	IORM	T1,DEVMOD(T2)	;DO NOT ALLOW TTY TO BE ZAPPED
	MOVSI	T1,TTYATC
	ANDCAM	T1,DEVMOD(T2)	;NO LONGER THE COMMAND PORT
	HRRI	T1,ASSCON
	IORM	T1,DEVMOD(F)	;MARK AS ASSIGNED BY CONSOLE (FOR RESET)
	DPB	J,PJOBN
	PUSHJ	P,SCNNAM	;THAT SHOULD BE ENOUGH
	  HRRZS	DEVNAM(F)	;SO LOOKS DETACHED
	HRRZ	F,T2
	MOVE	S,DEVIOS(F)
	HRRZ	U,DDBLDB(F)
	MOVSI	T2,LDLCOM
	ANDCAM	T2,LDBDCH(U)
	AOS	(P)
	LDB	T1,LDPLNO
	UMOVEM	T1,(M)
	PJRST	UUOLDB
SUBTTL	HERE FROM HANG UUO WHEN HANGING AN AUX CIRCUIT

HNGAUX:	HRRZ	F,LDBDDB(U)
	JUMPE	F,HNGAXD	;IF IT'S ATTACHED,
HNGAX1:	LDB	T1,DDPTZP
	PUSHJ	P,TAKTRJ	;  INTERRUPT ITS OWNER
	MOVEI	T2,ASSCON
	PJRST	RELEA6		;  AND CLEAR ASSIGNED-BY-CONSOLE

    ;HERE WHEN PORT IS ALREADY DETACHED

HNGAXD:	PUSHJ	P,TTYZAP	;SET TO SEND A ZAPPER BACK
	HRRZS	U		;CLEAR LDBDCH BITS
	CAME	U,AUXRCP	;IF IT'S THE RECEIVED AUX PORT,
	 JRST	HNGAX4
	SETOM	AUXRCP		;  SAY WE HAVEN'T RECEIVED ONE
	AOS	ZRPCNT		;  AND NOTE THAT WE DID SO
HNGAX4:	POPJ	P,

;HERE WHEN A ZAPPER IS RECEIVED ON AN AUX PORT

ZAPAUX:	HRRZ	F,LDBDDB(U)	;F/ DDB ADDR
	JUMPE	F,HNGAXD	;IF DETACHED, JUST CHECK "RECEIVED" PORT
	PUSHJ	P,TTYZAP	;SET TO SEND ZAPPER
	HLLZS	DDBLDB(F)	;DETACH IT
	HLLZS	LDBDDB(U)
	JRST	HNGAX1		;INTERRUPT JOB, CLEAR ASSCON

;HERE FROM RELEA6 WHEN BOTH ASSCON AND ASSPRG GO OFF

AUXZAP:	HRRZ	U,DDBLDB(F)
	JUMPE	U,AXZP1		;IF DDB HAS A PORT ATTACHED,
	PUSHJ	P,TTYZAP	;  SET TO SEND ZAPPER
	HLLZS	DDBLDB(F)
	HLLZS	LDBDDB(U)	;  DETACH IT
	SETZM	LDBSTR(U)	;  CLEAR PREVIOUS CIRCUIT NAME
	HRRZI	T1,LDBSTR+1(U)	;  GET ADDRESS
	HRLI	T1,-1(T1)	;    STR,,STR+1
	BLT	T1,LDBSTR+AUXSTL-1(U)
AXZP1:	HRRZS	DEVNAM(F)	;MARK NAME AS DETACHED
	MOVSI	T1,TIOUSE
	TDNN	T1,DEVIOS(F)	;IF NO UUO IS IN PROGRESS,
	 PJRST	TTYKDB		;  KILL THE DDB
	MOVE	S,DEVIOS(F)	;OTHERWISE,
	PJRST	TIWAKE		;  JUST WAKE THE JOB
SUBTTL	IQUEUE - TAKES AN INPUT WAIT TRAP IF SET, OTHERWISE PLACES
; THE JOB IN TTY INPUT WAIT.

IQUEUE:	LDB T1,DDPTTI		;CHECK FOR TRAP WANTED.
	PUSHJ	P, TSTKTJ	;IF INPUT WAIT INTERRUPT WANTED
	 JRST ABTUUO		;YES, ABORT.
	SKIPGE	JBTAWQ(J)	;IF INTERRUPT PENDING
	 JRST ABTUUO		; ABORT
	PUSHJ P,TIWAIT		;NO.  QUEUE JOB FOR TIO WAIT.
	PJRST BIOATT

;OQUEUE - TAKES AN OUTPUT WAIT TRAP IF SET, OTHERWISE PLACES
; THE JOB IN TTY OUTPUT WAIT.

OQUEUE:	LDB T1,DDPTTI		;CHECK FOR TRAP WANTED.
	PUSHJ P,TSTKTJ		;SEE IF INTERRUPT ON IOW
	 PUSHJ P,SETFIO		;NEEDS WAKUP LATER
	SKIPGE JBTAWQ(J)	;CHECK FOR TRAPS WAITING
	 JRST ABTUUO		;AND ABORT IF ANY.
	PUSHJ P,TOWAT1		;NO.  QUEUE JOB FOR TIO WAIT.

;HERE TO CHECK IF LINE FOR THIS PORT IS STILL ATTACHED.

BIOATT:	SKIPE JBTAWQ(J)
	JRST ABTUUO
	HRRZ U,DDBLDB(F)	;IS LINE STILL ATTACHED?
	JUMPN U,CPOPJ1		;YES.  HE WINS.
	MOVSI T1,TTYATC		;IS THIS THE CONTROLLING TTY
	TDNN T1,DEVMOD(F)	;OR AN AUXILIARY CIRCUIT?
	 JRST AUXRID		;AN AUXCIR ... HE LOSES.
	POPJ P,			;CONTROLLING TTY: HE STILL LOSES
SUBTTL	 BLKXIN - TERMINATE BLOCK INPUT AUXCAL

BLKXIN:	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO	; BLOCK I/O ENABLED?
	 POPJ	P,
	HRRZ	T1,LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	JUMPE	T1,BLKXI1	; NO BUFFER
	PUSHJ	P,BLKTRQ	; REQUEST INPUT TERMINATION
	HRRZ	T1,LDBBIO(U)
	SKIPGE	BIOCHR(T1)	; CHECK IN-PROGRESS FLAG
	 POPJ	P,		; IN-PROGRESS: DO NOTHING NOW
	MOVSI	S,IOEND		; COMPLETE: SET IOEND
	SKIPA
BLKXI1:	MOVEI	S,IODEND	; NO BUFFER: SET IO.EOF
	IORB	S,DEVIOS(F)
	POPJ	P,

; BLKTRQ - ROUTINE TO REQUEST BLOCK INPUT TERMINATION

BLKTRQ:	MOVSI	T1,LMLTBI
	TDNE	T1,LDBMOD(U)	; TERMINATION PENDING?
	 POPJ	P,		; YES: DO NOTHING
	IORM	T1,LDBMOD(U)	; NO: SET THE FLAG
	MOVEI	T1,1
	DPB	T1,LOPTRI	;    SET TERMINATE-INPUT
	DPB	T1,LDBOPB(U)	;    AND NEED-OUTPUT
	POPJ	P,

;BLKXOT - HERE TO TERMINATE BLOCK OUTPUT FOR A PORT IN BIO MODE

BLKXOT:	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO	;IF BLKIO NOT ENABLED,
	 POPJ	P,		;  JUST RETURN
	HLLZ	T1,LDBBIO(U)
	JUMPE	T1,CPOPJ	;IF NO BLK OUTPUT IN PROGRESS, RETURN
	MOVSI	T1,LDLNOP
	ANDCAM	T1,LDBDCH(U)	;IGNORE BACKPRESSURE
	LDB	T1,LOPBOT
	SOJL	T1,BLKXT1	;IF WE'RE ABOUT TO REQUEST BLK OUTPUT,
	DPB	T1,LOPBOT	;  FORGET IT (T1/ 0)
	PJRST	FRCOHR		;  BUT SIMULATE THE OUTPUT-COMPLETE
				;ELSE
BLKXT1:	DPB	T1,LOPTRO	;  SET TO SEND BLKO-TERMINATE (T1/ -1)
	DPB	T1,LDBOPB(U)	;  AND NEED-OUTPUT
	POPJ	P,
SUBTTL INPUT AND OUTPUT SUBROUTINES

TYI:	PUSHJ	P,TYIEAT	;GET RID OF COMMAND LINE (CAN'T RESCAN ANYMORE)
	SOSGE LDBTIC(U)	;ANY INPUT CHRS LEFT?
	JRST	[SETZM LDBTIC(U)
		POPJ P,]	;NO, NON-SKIP RETURN
	PUSHJ P,BPFTYI		;RESET BACKPREASURE
	MOVE T2,LDBTIT(U)
	PUSHJ P,TTGETC
	 PUSHJ P,FRECHK
	MOVEM T2,LDBTIT(U)
	SKIPN T1,LDBBKP(U)	;ANYTHING IN ^U POINTER
	SOS LDBBKI(U)		;YES, 1 FEWER CHRS
	CAMN T1,T2		;IS THIS THE POINTER NOW
	SETZM LDBBKP(U)		;YES, NOTHING THERE NOW
	TRNE T3,400
	JRST CPOPJ1		;IMAGE CHR
	TRNN T3,200
	SKIPA P3,CHRTAB(T3)
	MOVE P3,CHRTAB-200(T3)	;GET INFORMATION BITS
	LDB T2,CHPRED	;GET READ CODE
TYIRPT:	XCT TYIATB(T2)		;AND DO IT
	SUBI T3,40		;HERE IN LOWER CASE, CONVERT TO UPPER
	JRST CPOPJ1		;DONE

TYIATB:	PHASE 0
	JRST SPRTYI	;SPECIAL ACTION NEEDED
	JRST CPOPJ1	;NORMAL CHR
%CHBRK:! SOSA LDBBKC(U)	;BREAK, FLAGGED SO CALLERS KNOW
	JRST TYIC	;BREAK2
	TLNE U,LDLLCT	;LOWER CASE, SHOULD WE CONVERT?
	DEPHASE

TYIC:	TLNE U,LDLBK2	;IN BREAK2 MODE?
	MOVE T2,%CHBRK	;YES, FLAG AS BREAK FOR CALLERS
	AOS (P)
TYID:	SOS LDBBK2(U)
	JUMPN T1,CPOPJ	;DON'T WORRY IF NO ^U POINTER
	MOVSI T1,-1
	ADDM T1,LDBBKI(U)
	POPJ P,

SPRTYI:	LDB T2,CHPSPR	;GET ACTION CODE
	LDB P3,LDPMOD	;AND LINE MODE
	XCT @SPRTTB(P3)

SPRTTB:	XCT TYIPDP(T2)
	XCT TYI940(T2)
	XCT TYI940(T2)
	XCT TYIPDP(T2)
TYIPDP:	JRST TYICC	;^C
	JRST TYIALT	;33
	JRST TYIBRK	;^_
	JRST TYICZ	;^Z
	JRST TYIPAL	;175-176
	JRST TYITAB	;TAB
	JRST TYIBSP	;BACKSPACE

TYI940:	JRST TYIBRK	;^C
	JRST TYICC	;33 POSSIBLE ESCAPE
	JRST TYICC	;^_
	JRST TYIBRK	;^Z
	JRST TYICCP	;175-176
	JRST TYITAB	;TAB
	JRST TYIBSP	;BACKSPACE

TYITAB:	MOVSI T2,L2LTBK
	TDNN T2,LDBBYT(U)	;TREAT TAB AS BREAK?
	JRST TYIC	;NO AS BREAK2
TYIBRK:	MOVEI T2,%CHBRK	;YES, TREAT AS BREAK
	JRST TYIRPT

TYIBSP:	MOVSI T2,L2LBBP
	TDNE T2,LDBBYT(U)	;TREAT BSP AS BREAK
	JRST TYIC	;NO, AS BREAK2
	JRST TYIBRK	;YES

TYIPAL:	TLNN U,LDLLCT	;IN TTY LC
	JRST TYIBRK	;YES, JUST A BREAK CHARACTER
TYIALT:	MOVEI T2,LDRFCS	;ALTMODE. IN FULL CHR SET MODE?
	TDNN T2,LDBDCH(U)
	MOVEI T3,STDALT	;NO, STANDARD
	JRST TYIBRK

TYICZ:	HRRZ F,LDBDDB(U)
	JUMPE F,TYIBRK	;NO DDB, JUST BREAK CHR
	MOVSI T4,IOEND
	IORM T4,DEVIOS(F)	;SET END OF FILE
	JRST TYIBRK
TYICCP:	TLNN U,LDLLCT	;IN TTY LC
	JRST TYIBRK	;YES, TRAT AS BREAK
TYICC:	SOS LDBBKC(U)
	MOVE J,JOB	;ALSO FALL HERE FROM ABOVE
	PUSHJ P,ESCTR1	;TRY TRAPPING
	PUSHJ P,CNCCHK	;CHECK SPECAIL CONDITIONS
	JRST [
		LDB	P3, LDPMOD	; GET MONITOR MODE
		MOVEI	T3, 3		; ^C FOR 10'S
		CAIE	P3, 1		; GE MODE?
		CAIN	P3, 2		; TYMEX MODE?
		MOVEI	T3, 33		; ESC FOR 940'S
		AOS	LDBBKC(U)	; SOS'D IN TYIBRK
		JRST	TYIBRK		; PASS TO PROGRAM
	]
	PUSHJ	P,TIWAIT	;HALT COMMAND ALREADY SET
	PUSHJ	P, CKATTI	;MAKE SURE IT'S STILL ATTACHED
	JRST	ABTUUO		;(S)HE WANTS AN INTERRUPT
	JUMPN	U, TYI		;TRY AGAIN (FOR CONTINUE)
	 STOPCD 		;HORRORS! NOT A COMMAND PORT!
SUBTTL	GET RID OF COMMAND LINE

TYIEAT:	TLNN U,LDLECS	;ALREADY DONE THIS?
	 POPJ P,		;YES
	PUSH P,T3
	PUSH P,P3	;ALSO SAVE THIS (TTYSTR AND FRIENDS)
TYIL:	SOSGE LDBTIC(U)
	JRST [SETZM LDBTIC(U)
		JRST TYIET2]
	MOVE T2,LDBTIT(U)
	PUSHJ P,TTGETC
	 PUSHJ P,FRECHK
	MOVEM T2,LDBTIT(U)
	SKIPN T1,LDBBKP(U)
	SOS LDBBKI(U)	;SAME AS IN TYI
	CAMN T1,T2
	SETZM LDBBKP(U)
	TRNE T3,400
	JRST TYIL	;IMAGE, TRY NEXT
	TRNN T3,200
	SKIPA P3,CHRTAB(T3)
	MOVE P3,CHRTAB-200(T3)
	LDB T2,CHPRED
	XCT EATTAB(T2)
	JRST TYIL	;TRY NEXT

EATTAB:	JRST SPREAT	;SPECIAL ACTION
	JRST TYIL	;NOMAL CHR
	JRST TYIET3	;BREAK CHR, FINISHED
	PUSHJ P,TYID	;BREAK2
	JRST TYIL	;LOWER CASE, JUST LIKE NORMAL

SPREAT:	LDB T2,CHPSPR
	XCT SPRETB(T2)	;SAME IN ALL MODES
	XCT -5+[TDNE T3,LDBBYT(U)	;FROM TAB
	        TDNN T3,LDBBYT(U)](T2)	;FROM BACKSPACE
	JRST TYIET3	;TREAT AS BREAK
	PUSHJ P,TYID	;TREAT AS BREAK2
	JRST TYIL

SPRETB:	JRST TYIET3	;^C
	JRST TYIET3	;33
	JRST TYIET3	;^_
	JRST TYIET3	;^Z
	JRST TYIET3	;175-176
	MOVSI T3,L2LTBK	;TAB, CHECK BREAK OR BREAK2
	MOVSI T3,L2LBBP	;BACKSPACE, CHECK BREAK OR BREAK2

TYIET3:	SOS LDBBKC(U)	;A BREAK CHR FINISHED
TYIET2:	MOVSI T1,LDLECS	;FINISHED BECAUSE OUT OF CHRS
	ANDCAM T1,LDBDCH(U)	;TURN OFF FLAG IN ANY CASE
	POP P,P3
	POP P,T3
	HLL U,LDBDCH(U)
	POPJ P,
SUBTTL	TYO, CMDTYO - Put characters in TTY output buffer
COMMENT %
@@SUBROUTINE TYO, CMDTYO
@@PURPOSE TYO -- CHECK FOR SPACE, PLACE CHAR IN OUTPUT BUFFER
	  CMDTYO -- ASSUME SPACE, PLACE CHAR IN OUTPUT BUFFER
@@ENTRY	T3/ CHAR, F/ DDB ADDR, U/ (NONZERO) LDB ADDR
@@ACCUM	T1-T2 DESTROYED
@@EXIT	ON A SKIP-RETURN, THE CHARACTER HAS BEEN DEPOSITED.
THE NONSKIP-RETURN IS NOT ACTUALLY A RETURN BUT RATHER A
PUSHJ TO ITS CALLER. IT IS TAKEN WHEN THERE IS NO ROOM FOR
THE CHARACTER AND THE JOB WANTS A TRAP. THE CALLER HAS
THREE CHOICES:
	1) ABORT THE UUO, GIVING THE JOB ITS TRAP
	2) MAKING ROOM FOR THE CHARACTER, THEN POPJ-ING,
	   CAUSING TYO TO RETRY THE DEPOSIT
	3) AOS (P) / POPJ -ING, CAUSING TYO TO GO INTO
	   OUTPUT WAIT
%

TYO:	MOVE	T1,TTFREN	;T1/ # FREE CHUNKS
	CAIL	T1,TIRSVD	;IF #FREE .lt. #SAVED,
	 JRST	TYO1
	MOVSI	T1,TWTSPC
	IORM	T1,DEVIOS(F)	;  MARK NO-CHUNKS WAIT
	JRST	TYOW2		;  AND GO WAIT

TYO1:	MOVE	T1,LDBTOC(U)	;T1/ # CHARS LEFT TO OUTPUT
	SKIPGE	LDBDCX(U)	;IF IT'S FAST
	CAML	T1,OMX120	;AND UNDER THE FAST MAXIMUM,
	CAMGE	T1,OMX30	;OR IF IT'S UNDER THE SLOW MAXIMUM,
	 JRST	TYO2		;  CONTINUE OUTPUT.
	SKIPGE	LDBBYT(U)	;IF IT'S NOT EXTENDED-MODE
	CAML	T1,TOEMAX	;OR IT'S OVER THAT LIMIT,
	 JRST	TYOW		;  GO TRAP OR WAIT
TYO2:	AOS	(P)		;PREPARE FOR SKIP-RETURN
	HLL	U,LDBDCH(U)
	TLNE	U,LDLOSU	;IF SUPPRESSING OUTPUT,
	 POPJ	P,		;  JUST (SKIP-)RETURN

;CMDTYO - put character in output chunk.  Caller must check for room

CMDTYO:	SKIPE	T2,LDBTOP(U)	;IF NO CHUNK ALLOCATED,
	 JRST	TYO3
	PUSHJ	P,GETCHK	;  T2/ CHUNK BYTE POINTER
	MOVEM	T2,LDBTOP(U)	;  SET OUTPUT PUTTER
	MOVEM	T2,LDBTOT(U)	;  SET OUTPUT TAKER
	SETZM	LDBTOC(U)	;  SET OUTPUT COUNT
TYO3:	PUSHJ	P,TTPUTC	;STORE CHAR.; T2 := NEW PUTTER
	MOVEM	T2,LDBTOP(U)	;STORE NEW PUTTER
	AOS	LDBTOC(U)	;UPDATE COUNT
	POPJ	P,
TYOW:	LDB	T1,DDPTTI	;T1/ IOW TRAP CHANNEL
	PUSHJ	P,TSTKTJ	;SETUP TRAP IF ENABLED. IF IT WAS,
	  PUSHJ	P,SETFIO	;  MARK DDB FOR OUTPUT-DONE TRAP
	LDB	T1,PJOBN
	SKIPL	JBTAWQ(J)	;IF AWAITING A TRAP,
	 JRST	TYOW1
	PUSHJ	P,@(P)		;  RETURN TO CALLER AS COROUTINE
	JRST	TYO		;  (NONSKIP FROM RECALLED CALLER)

TYOW1:	JUMPE	U,TYOW3		;IF ATTACHED,
TYOW2:	MOVEI	T1,1
	DPB	T1,LOPOUT	;  SET CHARACTER-OUTPUT
	DPB	T1,LDBOPB(U)	;  AND NEED-OUTPUT
TYOW3:	PUSHJ	P,TOWAT1	;GO INTO OUTPUT WAIT
TYOW4:	HRRZ	U,DDBLDB(F)
	JUMPN	U,TYO		;IF STILL ATTACHED, TRY AGAIN
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)	;IF IT'S NOT THE COMMAND PORT,
	PJRST	AUXRID		;  DISCARD DDB AND ABORT UUO
	JRST	TYOW		;OTHERWISE, WAIT FOR ATTACH
SUBTTL	MAKE SURE TTY IS ATTACHED, NO CHANCE FOR INTERRUPT

CKATTF:	MOVE	S,DEVIOS(F)
	HRRZ	U,DDBLDB(F)
	JUMPN	U,UUOLDB
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	 JRST	AUXRID		;CAN GET RID OF DDB FOR AUX CIRCUIT
	PUSHJ	P,TOWATA
	JRST	CKATTF		;TRY AGAIN

;CHECK TO SEE THAT THERE IS ROOM FOR AT LEAST ONE CHARACTER TO BE OUTPUT

CHKROM:	HLRZ	T1,LDBBIO(U)	;BLOCK OUTPUT NOW IN PROGRESS?
	JUMPN	T1,CHKRM1	;YES. QUEUE JOB FOR OUTPUT WAIT.
	MOVE	T1,TTFREN
	CAIGE	T1,TIRSVD	;IS THERE BUFFER SPACE?
	 JRST	CHKRM3
	MOVE	T1,LDBTOC(U)	;NUMBER NOW IN OUTPUT BUFFER
	SKIPGE	LDBDCX(U)	;IF IT'S FAST
	CAML	T1,OMX120	;AND UNDER THE FAST MAXIMUM,
	 CAMGE	T1,OMX30	;OR IF IT'S UNDER THE SLOW MAXIMUM,
	  JRST	CPOPJ1		;  SAY THERE'S ROOM
CHKRM1:	LDB	J,PJOBN
	SKIPGE	JBTAWQ(J)	;ABORT UUO IF TRAP IS PENDING
	 JRST	ABTUUO
	LDB	T1,DDPTTI
	PUSHJ	P,TSTKTP	;SEE IF WE CAN TAKE AN INTERRUPT
	  SKIPA			;YES, MUST MAKE SURE WE SET OUTPUT ROOM FLAG
	JRST	TOWAT1		;QUEUE JOB FOR OUTPUT WAIT.

CHKRM2:	PUSHJ	P,SETFIO
	JRST	ABTUUO		;NOW GET OUT OF UUO

;HERE WHEN THERE'RE NO BUFFERLETS AVAILABLE FOR THE OUTPUT

CHKRM3:	LDB	T1,DDPTTI
	PUSHJ	P,TSTKTJ	;DOES HE GET AN I/O WAIT TRAP?
	  JRST	CHKRM2		;YES: DO IT
	MOVSI	T1,TWTSPC
	IORM	T1,DEVIOS(F)	;NO: MARK REASON FOR WAIT
	PJRST	TOWAT1		;    AND DO IT


; CALL TO SEE IF ROOM FOR A CHARACTER
; U/LDB
; PUSHJ P,IFROOM
;  <NO ROOM>
; <ROOM>

IFROOM:	MOVE	T1,TTFREN	;Number of buffer chunks
	CAIGE	T1,TIRSVD	;Is there buffer space?
	 POPJ	P,		;No, last 3 chunks reserved for emergencies
	HRRZ	T1,U		;Get LDB address
	CAIN	T1,CTYLDB	;Sending to the CTY?
	 JRST	[MOVE	T1,TTFREN
		 CAIL	T1,TIRSVD+5
		  AOS	(P)	;CTY can use all but the last 10 chunks
		 POPJ	P,]	
	MOVE	T1,LDBTOC(U)	;Number of characters currently in buffer
	SKIPGE	LDBDCX(U)	;If it's fast
	CAML	T1,OMX120	; and under the fast maximum,
	 CAMGE	T1,OMX30	; or if it's under the slow maximum,
	  AOS	(P)		;  say there's room
	POPJ	P,
SUBTTL	SUBROUTINES TO SET UP LINE AND MAKE SURE ATTACHED.
;CALL WITH F SET UP, FROM M LEVEL ONLY.
;RETURN WHEN ATTACHED AND AT USER LEVEL, WITH U SET UP.

;ONE ROUTINE FOR INPUT, ONE FOR OUTPUT.

CKATTI:	MOVE	S,DEVIOS(F)	;SET UP STATUS WORD
	HRRZ	U,DDBLDB(F)	;GET LINE BLOCK ADDR
	JUMPN	U,CKATI2	;IF THERE, GO ON
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	 JRST	CPOPJ1		;AUX CIRCUIT, SPECIAL
CKATI2:	LDB	T1,PJOBN	;NOW CHECK IF JOB WAITING FOR
	SKIPGE	JBTAWQ(T1)	;AN INTERRUPT
	 POPJ	P,		;YES
	JUMPN	U,CKATI1
CKATIW:	SKIPE	SKPFLG		;DON'T WAIT FOR ATTACH IF INC AND SKP AUXCAL
	 POPJ	P,
	LDB	T1,DDPTTI
	PUSHJ	P,TSTKTJ	;IS THIS AN IOW INTERRUPT
	 POPJ P,		;YES
	MOVSI	S,IO+TTYOUW	;MUST WAIT FOR ATTACH
	ANDCAM	S,DEVIOS(F)	;CLEAR DIRECTION BIT
	MOVEI	S,IOACT		;AND SET WAIT BIT FOR INPUT
	IORB	S,DEVIOS(F)	; ..
	PUSHJ	P,WSYNCS	;WAIT FOR ATTACH
	JRST	CKATTI		;GET U SET UP AND RETURN.

CKATI1:	HLL	U,LDBDCH(U)		;GET DEVICE BITS
	TLNE	U,LDLCOM		;AT COMMAND LEVEL?
	 JRST	CKATIW			;YES. CAN'T1 DO INPUT.
	PUSHJ	P,TYIEAT		;NO. SKIP ANY COMMANDS
	AOS	(P)
	PJRST	UUOLDB			;AND GO ADJUST LINE BITS.

CKATTO:	MOVE	S,DEVIOS(F)		;SET UP STATUS WORD
	HRRZ	U,DDBLDB(F)		;GET LINE ADDR IF ANY
	JUMPN	U,CKATO2		;IF HAVE ONE, SEE IF TOP LEVEL
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	 JRST	CPOPJ1
CKATO2:	LDB	T1,PJOBN
	SKIPGE	JBTAWQ(T1)
	 POPJ	P,			;WAITING FOR INTERRUPT
	JUMPN	U,CKATO1
	LDB	T1,DDPTTI
	PUSHJ	P,TSTKTJ
	  PJRST	SETFIO			; INTERRUPT ON IOW
	PUSHJ	P,TOWATA		;WAIT FOR OUTPUT DONE. (WHICH
					; IS FORCED ON ATTACH)
	JRST	CKATTO			;AND SET UP U, TO RETURN.
CKATO1:	AOS	(P)
	MOVSI	T1,L2LOEX
	ANDCAM	T1,LDBBYT(U)		;TURN OFF EXTENDED OUTPUT
	PFALL	UUOLDB			;FALL INTO UUOLDB
SUBTTL	UUOLDB - MAKE LDB (ADDR IN U) AGREE WITH FILE STATUS BITS (IN S)

UUOLDB:	JUMPE	U,CPOPJ		;JUST IN CASE
	HLL	U,LDBDCH(U)	;MAKE SURE LEFT HALF SET
	TLNE	U,LDLAUX
	 POPJ	P,		;DO NOTHING FOR AN AUX CIRCUIT

    ;SET MONITOR MODE BITS

	PUSH	P,J
	LDB	J,PJOBN
	LDB	T4,PVYMOD
	DPB	T4,LDPMOD
	POP	P,J		;SET MODE

    ;SET LDBDCX BITS

	MOVE	T1,LDBDCX(U)
	TRNE	S,DLRSUP
	TLOA	T1,LXLDLR	;SUPPRESS-$
	 TLZ	T1,LXLDLR	;DON'T SUPPRESS $
	MOVEM	T1,LDBDCX(U)

    ;GET LDB BITS FROM FILE STATUS BITS

	SETZ	T1,
	TRNE	S,FCS
	 TRO	T1,LDRFCS
	TRNE	S,NOECHO
	 TLO	T1,LDLNEC
	TLNE	S,IOSBKA
	 TLO	T1,LDLBKA
	TRNE	S,BK2IOS
	 TLO	T1,LDLBK2

    ;SET THE LDBDCH BITS

	MOVE	T4,T1
	XOR	T4,LDBDCH(U)	;T4/ THE BITS THAT CHANGED
	IORM	T1,LDBDCH(U)
	TDC	T1,[LDLNEC!LDLBKA!LDLBK2,,LDRFCS]
	ANDCAB	T1,LDBDCH(U)
	HLL	U,T1		;UPDATE LH(U)

    ;FINISH UP

	MOVE	S,DEVIOS(F)	;UPDATE S
	TLNE	T4,LDLNEC	;IF WE'RE CHANGING ECHO MODE
	TRNE	T1,LDRDEM	;AND LDRDEM NOT SET,
	 PJRST	SETLMD
	MOVEI	T1,1		;  SET TO CHANGE ECHO MODE
	DPB	T1,LOPSEC
	DPB	T1,LDBOPB(U)
	PJRST	SETLMD		;AND GO SET LINE MODE
TWAITL:	MOVSI S,IOSBKA
	ANDCAB S,DEVIOS(F)
	MOVSI T1,LDLBKA
	ANDCAM T1,LDBDCH(U)	;SET FOR LINE MODE INPUT
	PUSHJ P,SETLMD
	MOVE T1,LDBTIC(U)
	HLL U,LDBDCH(U)	;MAKE SURE LINE IS OK
	MOVE T4,LDBBKC(U)	;GET BREAK COUNT
	TLNE U,LDLBK2	;IF IN BREAK2 MODE
	 ADD T4,LDBBK2(U)	;NUMBER IS SUM
	CAIGE T1,TIWKC
	TRNE T4,-1		;IF A BREAK OR ENOUGH CHRS
	 POPJ P,			;GO NOW
	TLNN U,LDLIMI	;IN IMAGE MODE?
	 JRST TWTL1		;NO, MUST WAIT
	SKIPN LDBTIC(U)	;YES, ANY CHRS?
	TLNE S,IOEND		;OR END OF FILE SET
	 POPJ P,			;IF END FLAGGED, THEN DONE
	SKIPE LDBECC(U)	;ARE THERE ANY CHRS THERE AT ALL?
	 JRST TWTL2	;YES, I/O WAIT BUT NO TRAP
	JRST TWTL3	;NO, I/O WAIT WITH POSSIBLE TRAP
TWTL1:	JUMPN T4,TWTL2	;IF UNECHOED BREAK CHRS, I/O WAIT NO TRAP
	ADD T1,LDBECC(U)
	CAIL T1,TIWKC	;OR POSSIBLEY TOO MANY TOTAL
	 JRST TWTL2	;I/O WAIT NO TRAP
TWTL3:	LDB T1,DDPTTI	;CHECK FOR TRAP WANTED
	PUSHJ P,TSTKTJ		;SEE IF INTERRUPT ON IOW
	 JRST ABTUUO		;YES, ABORT
TWTL2:	PUSHJ P,TIWAIT
	PUSHJ P,CKATTI
	 JRST ABTUUO
	JUMPN U,TWAITL
	JRST AUXRID	;ZAPPED AUX CIRCUIT

TWAITS:	;AOS	SKPFLG	;CALLED BY AN INPUT AND SKIP AUXCAL
	JFCL		;FOR NOW UNTIL CAN FIND OUT WHY SKPFLG STAYS SET
			;WHEN SHOULDN'T
	AOS	(P)	;SET TO SKIP RETURN
TWAITC:	MOVSI S,IOSBKA
	IORB S,DEVIOS(F)
	MOVSI T1,LDLBKA
	IORM T1,LDBDCH(U)
	PUSHJ P,SETLMD
	HLL U,LDBDCH(U)	;MAKE SURE LINE OK FOR CALLERS
	SKIPLE LDBTIC(U)	;ANY CHARACTERS PRESENT?
	POPJ P,
	SKIPE LDBECC(U)
	JRST TWTC1	;SOME CHRS SO NO I/O TRAP
	LDB T1,DDPTTI
	PUSHJ P,TSTKTJ		;CHECK IOW WAIT INTERRUPT
	 JRST 	TWABT		;GET OUT
TWTC1:	PUSHJ P,TIWAIT
	PUSHJ P,CKATTI
	 JRST 	TWABT	;WAITING FOR INTERRUPT
	MOVE	T1,SKPFLG
	SETZM	SKPFLG
	JUMPN	U,TWTC2		;JUMP IF LINE ATTACHED
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	JRST	AUXRID		;ZAPPED AUX CIRCUIT
	SOS	(P)		;ZAPPED CMD PORT FROM INC AND SKP AUXCAL
	POPJ	P,
TWTC2:	JUMPGE	T1,TWAITC	;GET ENOUGH INPUT CHARS?
	POPJ	P,		;NO

TWABT:	SETZM	SKPFLG
	JRST	ABTUUO
TIWAIT:	MOVSI S,IO!TTYOUW
	ANDCAM S,DEVIOS(F)	;SET DIRECTION
	MOVEI S,IOACT
	IORB S,DEVIOS(F)	;SET WAIT BIT
	MOVEI T1,IMGTIM
	TLNE U,LDLIMI
	DPB T1,LDPTIM		;SET TIMER IF IN IMAGE MODE
	MOVEI T1,1
	DPB T1,LOPECO		;SET ECHO-NEEDED
	DPB T1,LDBOPB(U)	;AND NEED-OUTPUT
	JRST WSYNCS

;ROUTINE TO WAIT FOR NEARLY EMPTY OUTPUT BUFFER. CALL ONLY AT UUO LEVEL
TOWAIT:	MOVE T1,LDBTOC(U)		;GET COUNT OF TYPE-OUT CHARACTERS WAITING.
	CAIGE T1,10			;OVER 7?
	POPJ P,0			;NO. JUST RETURN.
TOWAT1:	MOVE S,[XWD TTYOUW+IO,IOACT]	;FLAG OUTPUT WAIT ACTIVITY
	IORM S,DEVIOS(F)		;IN THE DEVICE DATA BLOCK
WSYNCS:	MOVSI S,TIOUSE
	IORB S,DEVIOS(F)
	PUSH P,P1			;HAVE TO SAVE AC'S TO WAIT
	PUSH P,P2			; BECAUSE WSYNC USES THESE
	PUSH P,T3
	PUSH P,F
	PUSH P,W
	PUSHJ P,SCNINT		;GIVE HIM A CHANCE TO ECHO BEFORE PUTTING HIM IN WAIT
	POP P,W
	POP P,F
	POP P,T3
	MOVE	S,DEVIOS(F)	
	TRNN	S,IOACT		;DO WE NEED TO GO INTO WAIT?
	JRST	WSYNC1		;NO
	SKIPN	SKPFLG		;INPUT AND SKIP CALL IN PROGRESS?
	JRST	WSYNC2		;NO
	SETOM	SKPFLG		;COULDN'T GET ENOUGH INPUT CHARS
	PUSHJ	P,TIWAKN	;DON'T BLOCK
	SKIPA
WSYNC2:	PUSHJ P,WSYNC			;WAIT
WSYNC1:	POP P,P2			;RESTORE AC'S
	POP P,P1			; ..
	MOVSI S,TIOUSE
	ANDCAB S,DEVIOS(F)
	POPJ P,0			;AND RETURN FROM TOWAIT
SUBTTL BACKPRESSURE ADJUSTERS

;BPLVD - CALLED BY LEVDEF UUO

BPLVD:	MOVEI	T1, LDRXOS!LDRBPS
	TDNE	T1, LDBDCH(U)	;IF WE'VE SENT BACKPRESSURE OR AN XOFF
	 JRST	BPLVD1
	LDB	T1, LOPBPN
	JUMPE	T1, CPOPJ	;OR WE'RE PLANNING TO,
BPLVD1:	MOVE	T1, LDBECC(U)
	ADD	T1, LDBTIC(U)
	CAIL	T1, TIWKC	;AND WE DON'T HAVE GOBS OF CHARACTERS,
	 POPJ	P,
	JRST	BPFCOM		;  SET TO CLEAR BACKPRESSURE

;BPFTYI - CALLED AT THE START OF TYI

BPFTYI:	MOVEI	T1, LDRXOS!LDRBPS
	TDNE	T1, LDBDCH(U)	;IF WE'VE SENT BACKPRESSURE OR AN XOFF
	 JRST	.+3
	LDB	T1, LOPBPN
	JUMPE	T1, CPOPJ	;OR WE'RE PLANNING TO,
	MOVE	T1, LDBECC(U)
	ADD	T1, LDBTIC(U)
	CAIL	T1, 10		;AND WE HAVE HARDLY ANY CHARACTERS,
	 POPJ	P,
	JRST	BPFCOM		;  SET TO CLEAR BACKPRESSURE

;BPXOFF - CALLED WHEN DONE ECHOING, ON CLRBFI, BEFORE DOING
;	   BLOCK INPUT, AFTER READING COMMAND LINE
;BPOFF - CALLED WHEN ENTERING COMMAND LEVEL, WHEN FORCED
;	  OUT OF IMAGE STATE BY SCNSEC OR CLRIMI

BPXOFF:	SKIPA	T1, [LDRBPS!LDRXOS]
BPOFF:	MOVEI	T1, LDRBPS
	TDNE	T1, LDBDCH(U)	;IF WE'VE SEND BACKPRESSURE (OR XOFF)
	JRST	BPFCOM
	LDB	T1, LOPBPN	;OR WE'RE ABOUT TO,
	JUMPE	T1, CPOPJ
	PFALL	BPFCOM		;  SET TO CLEAR BACKPRESSURE

BPFCOM:	MOVEI	T1, 1
	DPB	T1, LOPBPF	;SET BACKPRESSURE-OFF
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,

;ROUTINE TO CHECK TO SEE IF BACKPRESSURE SHOULD BE TURNED OFF.  SKIP RETURNS
;IF SHOULD NOT BE TURNED OFF ELSE NON-SKIP RETURNS
;
BPTEST:	PUSH	P,T1
	MOVE	T1,LDBTIC(U)	;COMPUTE TOTAL NUMBER
	ADD	T1,LDBECC(U)	; OF CHARACTERS WAITING
	CAMG	T1,TIWRNN	;GREATER THAN BACKPRESSURE ON THRESHOLD?
	 JRST	TPOPJ		;NO, TURN OFF BACKPRESSURE
	JRST	TPOPJ1		;YES, LEAVE BACKPRESSURE ON
SUBTTL MISC STUFF FOR INPUT AND OUTPUT
;SUBROUTINE TO WAKE UP JOB IF IT IS IN TTY INPUT WAIT. CALL WITH
;U SET UP. IT WILL SET F AND S AS NEEDED.

USRWAK:	HRRZ	T1,LDBBIO(U)	; DOING BLOCK INPUT ?
	JUMPE	T1,USRWK1	; NO
	SKIPGE	BIOCHR(T1)	; YES. REQUEST IN PROGRESS ?
	 POPJ	P,		; YES. LEAVE IT ALONE.
BIOWAK:
IFCPU (KL),<
	TLNE	S,IO		;IF BLOCK INPUT,
	 JRST	USRWK1		;(OUTPUT, FORGET IT)
	HRRZ	T1,LDBBIO(U)	;THEN MUST MAKE SURE EDGES OF DATA NOT IN CACHE
	JUMPE	T1,USRWK1
	ADDI	T1,BIODAT	;GET ADDRESS OF 1ST DATA WORD
	CSHREF			;TAKE THAT 4 WD CHUNK OUT OF THE CACHE
	HRRZ	T1,LDBBIO(U)	;GET ADDRESS AGAIN
	ADDI	T1,BIOCOR*4-1	;ADDRESS OF LAST WORD
	CSHREF			;THAT TAKES CARE OF ADJACENT REFS DURING I/O
>;END IFCPU (KL)
USRWK1:	MOVSI	T1,L2LLDF
	ANDCAM	T1,LDBBYT(U)	;TURN OFF WHEN USER IS AWAKENED
	HRRZ	F,LDBDDB(U)	;GET ADDRESS OF ATTACHED F
	JUMPE	F,RCVWK1	;IF NONE,SKIP THIS CODE
	MOVE	S,DEVIOS(F)	;GET STATUS OF TTY FROM F
	TRNE	S,IOACT		;SINCE IOW MAY NOT BE SET YET
	TLNE	S,TTYOUW	;YES. FOR INPUT WAIT?
	 JRST	RCVWK1		;NO. DONT WAKE JOB.
TIWAKE:	TLNN	S,IOW		;IS IOW REALLY SET
	 JRST	TIWAKN		;NO
	MOVE	S,[XWD IOW,IOACT];YES. CLEAR WAIT BITS
	ANDCAB	S,DEVIOS(F)	;IN F FOR THIS JOB
	PUSH	P,T1		;SAVE VOLATILE AC'S
	PUSH	P,T2		; ..
	PUSHJ	P,STTIOD	;SET JOB TO TS STATE
	POP	P,T2		;RESTORE AC'S
	POP	P,T1		; ..
RCVWK1:	POPJ	P,0		;RETURN FROM RCVWAK

TIWAKN:	MOVEI	S,IOACT
	ANDCAB	S,DEVIOS(F)	;JUST RESET IOACT
	POPJ	P,

FULLCQ:	MOVE	T1,LDBDCH(U)
	TLNN	T1,LDLCOM	;IF NOT CMND MODE
	TDNN	T1,[LDLBKA,,LDRFCS];AND HE WANTS TO SEE EDIT CHARS,
	 AOS	(P)
	POPJ	P,		;  NONSKIP-RETURN
SUBTTL	SUBROUTINE TO SEE IF A CONTROL C SHOULD BE ACTED ON OR STORED.
;NON-SKIP MEANS STORE IT.
;SKIP MEANS DO IT.

CNCCHK:	TLNE	U,LDLCOM	;SHOULD ^C BE RETURNED?
	 POPJ	P,0		;YES.
	PUSH	P,T1		;MAYBE NOT. SAVE TAC.
	HRRZ	F,LDBDDB(U)	;GET U'S JOB
	JUMPE	F,CNCCK1	;IF NO F ATTACHED, ASSUME SHOULD DO ^C
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	 JRST	TPOPJ		;THIS IS A SLAVED TTY
	LDB	T1,PJOBN	; ..
	MOVE	T1,JBTSTS(T1)	;GET JOB STATUS WORD
	TDNE	T1,[XWD JACCT,JACCT2] ;IS ^C LEGAL?
	 JRST	TPOPJ		;NO. GIVE IT TO CUSP
CNCCK1:	PUSHJ	P,CNCMOD	;FORCE LINE TO BE AT COMMAND LEVEL
	MOVEI	T1,CMFCHT##
	PUSHJ	P,TTFORC	;FORCE HALT COMMAND
	JRST	TPOPJ1		;RESTORE T1, SKIP RETURN

XMTWAK:	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ		;NO JOB HOOKED TO IT
	MOVSI	S,L2LOWT	;IF WAITING FOR ORANGE BALL
	TDNE	S,LDBBYT(U)
	 POPJ	P,		;DON'T WAKE UP OUTPUT
	MOVE	S,DEVIOS(F)
	TLNN	S,TINFIO
	 JRST	XMTWK1
	LDB	T1,DDPTTS	;NOW TRAP ON READY FOR MORE OUTPUT
	PUSH	P,J
	PUSHJ	P,TAKTRJ
	MOVSI	S,TINFIO
	ANDCAB	S,DEVIOS(F)
	MOVEI	J,LXRIOS
	IORM	J,LDBDCX(U)
	POP	P,J
XMTWK1:	TRNE	S,IOACT		;SINCE IOW MAY NOT BE SET YET
	TLNN	S,TTYOUW
	 POPJ	P,		;NOT WAITING SO DONE
	PJRST	TIWAKE		;WAKE HIM UP
SUBTTL COMMAND ROUTINES

;ROUTINE TO MAKE THIS TTY VISIBLE TO COMMAND DECODER, IF AT COM LEVEL
;CALL WITH U SET UP

CMDWAK:	SKIPN	FRSFLG		;IF IT'S JUST THE RESCAN-STUFFER,
	 JRST	CMDWK1
	SETZM	FRSFLG		;  TELL IT WE GOT HERE
	POPJ	P,
CMDWK1:	TLNN	U,LDLCOM	;IS LINE AT COMMAND LEVEL?
	 POPJ	P,0		;NO. JUST RETURN
	MOVSI	T1,L2LLDF
	ANDCAM	T1,LDBBYT(U)	;RESET FLAG, USER AWAKE
	SETZ	T1,		;Indicate to COMWCM that command comes
				;from terminal
; Enter here with command index in T1 (or 0 if not forced command)
TTFORC:	PUSH	P,F		;Preserve
	LDB	F,LOPZAP	;If we're going to ZAP it,
	JUMPN	F,FPOPJ		; ignore the command
	HRRZ	F,LDBDDB(U)	;Set up DDB pointer
	JUMPE	F,FPOPJ		;None there, just exit
	PUSH	P,J
	LDB	J,PJOBN		;Find job/frame number
	SKIPE	J		;None there...
	PUSHJ	P,COMWCM##	;Set command request for this job/frame
	POP	P,J
FPOPJ:	POP	P,F
	POPJ	P,

;;
;; Routine to set up command input pointer to accept command
;;  input from TTY.  Clobbers T2.
;;
TRESCN::MOVE	T2,LDBTIT(U)	;TTY input buffer pointer
	MOVEM	T2,TTCMCA	;Copy into command input pointer
	MOVEI	T3,40		;Delimiter
	MOVEM	T3,TTCMCH
	POPJ	P,

;COMTYO - Output character in T3, preserving T2, uses T1

COMTYO::PUSH	P,T2		;Save T2 as advertised
	PUSHJ	P,@.CPTOA##	;Call CCTYO or routine in ONCE
	JRST	T2POPJ##	;Restore T2 and return

;CCTYO - usual output routine for .CPTOA

CCTYO::	JUMPE	U,CPOPJ		;Ignore if line not set up
	PUSHJ	P,IFROOM	;Space in this guy's area?
	  POPJ	P,		;No, ignore further attempts at output
	PUSHJ	P,CMDTYO	;Put character in output chunks
	PJRST	ONEOU3		;And start output


CCTYI::	SKIPE T2,TTCMCA		;REAL INPUT ROUTINE FOR COMMAND
	CAMN T2,LDBTIP(U)	;NOTHING OR AT END OF BUFFER
	 JRST CCTYI1		;GO FAKE A BREAK
	PUSHJ P,TTGETC
	  JFCL
	MOVEM T2,TTCMCA
	POPJ P,

CCTYI1:	MOVEI T3,12
	POPJ P,
SUBTTL	COMMAND INPUT ROUTINE

COMTYI::PUSHJ P,COMTYT	;FETCH A CHARACTER
	 SUBI T3,40	;UPSHIFT LOWER CASE
	POPJ P,

COMTYT::MOVE T3,TTCMCH
	CAIE T3,3
	CAIN T3,12	;THESE ARE FINISHED FLAGS
	 JRST CPOPJ1	;DO NOT TRY TO READ FURTHER
	PUSH P,T2
	PUSH P,P3	;SAVE REGISTERS FOR CALLERS
	HLL U,LDBDCH(U)
COMTI1:	PUSHJ P,@.CPTIA	;GET A CHR
	ANDI T3,177	;NOT INTERESTED IN EXTRA BITS
	MOVE P3,CHRTAB(T3)
	LDB T1,CHPRED
	XCT COMATB(T1)
	CAIN T3,15	;RETURN IS SPECAIL
	 JRST COMTI1	;GO GET LF AND SAY NOTHING ABOUT RETURN
COMTI2:	MOVEM T3,TTCMCH	;REMEMBER CHR FOR REREAD
	POP P,P3
	POP P,T2
	JRST CPOPJ1

COMATB:	JRST SPRCOM	;SPECIAL ACTION
	JFCL		;NORMAL CHR
	MOVEI T3,12	;TURN ALL BREAKS TO LINE FEEDS
	JFCL		;BREAK2
	SOS -2(P)	;NON-SKIP RETURN ON LOWER CASE CHAR

SPRCOM:	LDB T1,CHPSPR	;GET CHR TYPE
	LDB T2,LDPMOD	;AND LINE MODE
	XCT @SPRCTB(T2)
	JRST COMTI2	;FINISH UP
SPRCTB:	XCT COMPDP(T1)
	XCT COM940(T1)
	XCT COM940(T1)
	XCT COMPDP(T1)

COMPDP:	MOVEI T3,3	;^C
	MOVEI T3,12	;33
	MOVEI T3,12	;^_
	MOVEI T3,12	;^Z
	MOVEI T3,12	;175-176
	JRST COMTAB	;TAB
	JRST COMBSP	;BACKSPACE

COM940:	MOVEI T3,12	;^C
	MOVEI T3,3	;33
	MOVEI T3,3	;^_
	MOVEI T3,12	;^Z
	JRST COMPA	;175-176
	JRST COMTAB	;TAB
	JRST COMBSP	;BACKSPACE

COMTAB:	MOVSI T1,L2LTBK
	TDNE T1,LDBBYT(U)
	MOVEI T3,12	;TREAT AS BREAK
	JRST COMTI2	;TREAT AS BREAK2

COMBSP:	MOVSI T1,L2LBBP
	TDNN T1,LDBBYT(U)
	MOVEI T3,12	;TREAT AS BREAK
	JRST COMTI2	;TREAT AS BREAK2

COMPA:	MOVEI T3,3
	TLNN U,LDLLCT
	MOVEI T3,12
	JRST COMTI2	;EITHER AN ESCAPE OR JUST A BREAK CHR
SUBTTL	ROUTINE TO SWITCH TTY TO USER PROGRAM LEVEL AND START USER RUNNING

TTYUSW::TDZA S,S			;DON'T1 CLEAR WAIT BITS
TTYUSR:: MOVE S,[XWD IOW,IOACT]		;CLEAR WAIT BITS
	PUSHJ P,TTYUS0			;PUT TTY IN USER
	PJRST SETRUN			;MAKE HIM RUN AND RETURN

;CALL TTYUSM TO SIMPLY PUT TERM IN USER MODE

TTYUSM::SETZ S,				;DON'T CLEAR WAIT BITS
TTYUS0:	JUMPE	U,CPOPJ			;Exit if no LDB
	HRRZ F,LDBDDB(U)		;GET ATTACHED F IF ANY
	JUMPE F,TTYUS1			;JUMP IF NOT ATTACHED
	ANDCAB S,DEVIOS(F)		; ..
	PUSHJ P,UUOLDB			;MAKE U AND DEVIOS AGREE
TTYUS1:	MOVSI T1,LDLCOM			;PUT TTY IN USER MODE
	ANDCAM T1,LDBDCH(U)		;MAY BE DETACHED, BUT WILL WAIT
					; AT UUO LEVEL IF NEEDED
	PUSHJ P,SETLMD
	POPJ P,

;; Here when terminal-originated command has completed

TTYCMR::MOVSI	T1,LDLECS		;Set EAT-COMMAND-SYNC bit
	IORM	T1,LDBDCH(U)		; in Line Data Block
	POPJ	P,

TTYSTC::JUMPE	U,CPOPJ
	MOVSI	T1,LDLIMI		;FORCE OUT OF IMAGE MODE
	PUSHJ	P,CNCMD1		;WILL ALSO SET COMMAND BIT

TTYSTR::JUMPE	U,CPOPJ			;Exit if no LDB
	HLL	U,LDBDCH(U)
	TLNN	U,LDLCOM		;AT COMMAND LEVEL?
	 PJRST	NOCTRO			;NO. JUST CLEAR ^O BIT
	PUSHJ	P,TYIEAT		;CLEAR THE COMMAND IN CASE MORE
	HRRZ	T1,LDBBKC(U)		;NUMBER OF DEF ECHO BREAK CHARS
	JUMPE	T1,CKSXON		;NO BREAKS WAITING
	PUSHJ	P,CMDWAK		;SET FOR COMMAND
	PJRST	NOCTRO			;AND GO CLEAR BIT

MONHNG::HRLI	T1,3
	PUSHJ	P,HNGMON
	  JFCL
	POPJ	P,

TTYHLT::		;Global entry point to put TTY in cmd mode
CNCMOD:	MOVSI T1,LDLIMI!LDLECS
CNCMD1:	ANDCAM T1,LDBDCH(U)	;FORCE USER TO COMMAND LEVEL, RESET
	PUSHJ	P,BPTEST	;WANT TO TURN OFF BACKPRESSURE?
	  PUSHJ P,BPOFF		;YES, MAKE SURE BACKPRESSURE OFF
	MOVSI T1,LDLCOM
	IORM T1,LDBDCH(U)
	PJRST SETLMD

CKSXON:	PUSHJ	P,BPTEST	;WANT TO TURN BACKPRESSURE OFF?
	  PUSHJ P,BPXOFF	;YES
	JRST NOCTRO
SUBTTL	CTYTYP, CTYTYO - output character to the CTY (no interrupts)

;OPROUT - co-routine to set output to the CTY or the OPR terminal.
;Call with T1/0 = No LDB - Use CTYTYO to go directly to the CTY, no interrupts
;          T1/1 = One LDB - Use CTYLDB to put in the TTY chunks, CTY only
;          T1/2 = Two LDBs - Use both CTYLDB and OPRLDB, put in chunks

OPROUT::MOVE	T1,[EXP OP0TYO,OP1TYO,OP2TYO](T1) ;Get new address
	EXCH	T1,.CPTOA##	;Set new typout address for COMTYO
	EXCH	T1,(P)		;Save old address, get resume PC
;*;	PUSH	P,U
;*;	PUSH	P,T1	
;*;	MOVEI	U,CTYLDB	;Point to CTY LDB
;*;	LDB	T1,LDPPOS	;Check current position
;*;	CAIE	T1,0		;At left margin already?
;*;	 PUSHJ	P,CRLF		;No, put it there
;*;	POP	P,T1
;*;	POP	P,U
	PUSHJ	P,(T1)		;Call caller as coroutine
	  SOS	-1(P)		;Error return
	POP	P,.CPTOA##	;Restore typeout routine when caller POPJs
	JRST	CPOPJ1

;Here during INFO or EVENT stopcodes - use normal buffered output to OPR+CTY

OP2TYO:	HRLM	T3,(P)		;Save char
	PUSH	P,U
	SKIPE	U,OPRLDB	;If there is an OPR terminal
	 PUSHJ	P,CCTYO		;Output to it
	POP	P,U
	HLRZ	T3,(P)		;Do same character to the CTY
	PFALL	OP1TYO

;Here to output to the CTY's LDB only (buffer emptied at clock level)

OP1TYO:	PUSH	P,U		;Routine to output to the CTY's LDB
	MOVEI	U,CTYLDB	;Point to the CTY
	PUSHJ	P,CCTYO		;Put char in CTY's LDB
	JRST	UPOPJ	 	;Restore U and continue

;OP0TYO updates the key, then calls CTYTYO (called from continuable STOPCD).

OP0TYO::PUSH	P,T1		;Routine to output char in T3 to the CTY
	MOVE	T1,KEY10	;Magic number for the base
	SKIPL	.CPDWD##	;STOPCD in progress?
	 XCT	KEYSET		;Yes, update KEY620 if not in CONSOLE mode
	POP	P,T1
	PFALL	CTYTYO
;Output character directly to the CTY.  Called via PUSHJ P,@COMTYO from DIE.
;CTYTYO outputs to CTY, logs output, generates even parity, and does fillers.
;  This routine will wait in a loop if output is busy, which may mean a delay
;  of several milliseconds (more if CTYFIL is nonzero).
;Call with 7-bit character in T3 (8 data bits if 9th bit it set).
;Caller is expected to create free CRLF at column 80 (for now).

CTYTYO::PUSH	P,T1		;Called from ONCE, CTYSIM, ERRCON, etc
	PUSHJ	P,CTYLOG	;Log it in CTYBUF (T3 has 7-bit character)
	TRZN	T3,400		;If image flag set, char is 8 bits
	 PUSHJ	P,PEVEN8	;Generate even parity (smashes T1)
	PUSHJ	P,CTYCHR	;Output it to the CTY, loop if busy
PRINTF(<[CTYTYO should to free CRLF at column 80]>)
	CAIE	T3,015		;Carriage return?
	CAIN	T3,215		;(with or without parity)
	 SKIPN	CTYFIL		;Yes, have to do fillers?
	  JRST	TPOPJ		;No, return
	PUSH	P,T3		;Save the character
	MOVE	T1,CTYFIL	;Number of rubouts to do
CTYTY1:	MOVEI	T3,377		;Fill character is rubout
	PUSHJ	P,CTYCHR	;CTYCHR loops waiting for output done
	SOJG	T1,CTYTY1	;Do multiple fillers
	POP	P,T3		;Get 8-bit character back
	JRST	TPOPJ		;End of CTYTYO


;Output string to CTY.  Called from MONBTS and COMMON when loading BOOTS
;	MOVEI	T1,[ASCIZ /string/]
;	PUSHJ	P,CTYTYP
;	 <only return>

CTYTYP::HRLI	T1,440700	;POINTER FOR ASCIZ
CTYTYL:	ILDB	T3,T1		;GET CHARACTER
	JUMPE	T3,CPOPJ	;RETURN
	PUSHJ	P,CTYTYO
	JRST	CTYTYL

;Routine to log all CTY output in CTYBUF.  Preserves all ACs

CTYLOG::CAIE	T3,007		;Ignore bells
	CAIN	T3,207
	 POPJ	P,
	PUSH	P,T1
	IBP	CTYPTR##	;Increment byte pointer
	MOVE	T1,CTYPTR##	;Get it
	TRZ	T1,-1-CTYMSK##	;Use only 9 bits of offset within CTYBUF
	ADDI	T1,CTYBUF##	;Full address
	DPB	T3,T1		;Store all CTY output in CTYBUF
	POP	P,T1
	POPJ	P,

SUBTTL	CTYCHR - Output 8-bit character to the console teletype
;Caller is responsible for parity generation and free CRLF at column 80.
;Returns immediately if caller has waited for output-done to be true.
ENTRY	CTYCHR			;Called from CTYSIM

IFCPU (<KI,F3>),< ;Output to KI/F3 console
CTYCHR:	CONSZ	TTY,TT.OB	;Wait for Output Busy to go off
	 JRST	.-1		;(no timeout for this hardware flag)
	DATAO	TTY,T3		;Send character as it (all 8 bits)
	POPJ	P,		;The DATAO sets TT.OB in hardware

SVPPC::	POPJ	P,	;There is no other processor to do Keep-Alive on KI,F3
>;END IFCPU (<KI,F3>)
PRINTF([Need to make SVPPC work on KS])

IFCPU (KS),<	;Output to the KS console via the 8080
CTYCHR:	HRLM	T3,(P)		;Save character in T3
	MOVSI	T3,1		;Number of times to try
	SKIPE	CTYOWD##	;Previous CTY output done?
	 SOJG	T3,.-1		;No, wait for it
	HLRZ	T3,(P)	
	ANDI	T3,CTYOCH	;Get just the character
	TRO	T3,CTYOVL	;Add the Output Valid flag
	MOVEM	T3,CTYOWD##	;Store in location 33 in low memory
	RDAPR	T3		;Get program states
	ANDI	T3,LP.PIA	;Leave only the PIA
	WRAPR	LP.SSF+LP.I8C(T3);Whap the 8080
	HLRZ	T3,(P)		;Restore char in T3
	POPJ	P,

SVPPC::	JFCL			;Determine if Keep-Alive is active
	PUSH	P,T1		;Save flag on stack
	JFCL			;Disable Keep-Alive checking
	PUSHJ	P,@-1(P)	;Return to caller (co-routine)
	POP	P,T1		;Get flag back
	JFCL			;Resume Keep-Alive if needed
	POP	P,(P)		;Clean up stack
	POPJ	P,		;End of SVPPC
>  ;End of IFCPU(KS)

IFCPU (KL),<	;Output to the KL console via the PDP-11 on the master DTE
CTYCHR:	HRLM	T3,(P)		;Save character in T3
	MOVSI	T3,1		;Number of times to try
	SKIPN	EPT##+SPCMTD	;Previous CTY output done?
	 SOJG	T3,.-1		;No, wait for it
	HLRZ	T3,(P)	
	ANDI	T3,377		;Just 8 bits of character
	MOVEI	T3,.DTCTO(T3)	;Make DTE command word
	MOVEM	T3,EPT##+SPCCMW	;Store in command word
	SETZM	EPT##+SPCMTD	;Zero to indicate output not done
	CONO	DTE,TO11DB	;Ring doorbell
	HLRZ	T3,(P)		;Restore char in T3
	POPJ	P,		;SPCMTD will be set nonzero when output done

;Routine to save Primary Protocol Condition (See DTESER.703)
;Called by DIE when processing a STOPCODE.

SVPPC::	JFCL			;Determine if running primary or secondary protocol
	PUSH	P,T1		;Save flag on stack
;*;	JSR	SPCINI		;Set to secondary protocol
	PUSHJ	P,@-1(P)	;Return to caller (co-routine)
	POP	P,T1		;Get flag back
	JFCL			;Restart primary protocol if needed
	POP	P,(P)		;Clean up stack
	POPJ	P,		;End of SVPPC
;KL CTY output, continued

SPHNGI:	0	;INSTRUCTION TO XCT IF DTE HANGS UP
SPCST1:	0	;FOR SAVING T1
SPCTRY:	0	;# OF REMAINING TRIES
SPCTRN==10	;# TO INIT SPCTRY TO

SPCINI::0			;ENTER SECONDARY PROTOCOL
	MOVEM	T1,SPCST1	;SAVE T1
	MOVE	T1,[EPT##+SPCDBG,,EPT##+SPCDBG+1]
	SETZM	EPT##+SPCDBG
	BLT	T1,EPT##+SPCDND	;INIT COMM AREA TO ZEROES
	RDPI	SPCCMD		;SAVE PI STATE
	WRPI	LI.PIF
	MOVE	T1,[JSR DTEHLT]
	MOVEM	T1,EPT##+EPTDT0+DTEDII
	MOVEM	T1,SPHNGI
	MOVE	T1,[EPT##+EPTDT0+DTEEPW,,EPT##+EPTDT0+DTEEPW+1]
	SETZM	EPT##+EPTDT0+DTEEPW
	BLT	T1,EPT##+EPTDT0+DTEDRW
	CONO	DTE,CL11PT	;CLEAR INTERRUPT JUST IN CASE
	MOVE	T1,SPCCMD	;RESTORE PI
	TRNE	T1,LI.PIN
	 WRPI	LI.PIN
	MOVEI	T1,.DTESP
	JSR	SPCCMD
	MOVE	T1,SPCST1
	JRST	@SPCINI

;READ SWITCHES.
SPCGSW::MOVEI	T1,.DTRSW
	JSR	SPCCMD
	MOVE	T1,EPT##+SPCF11
	POPJ	P,

;SEND SECONDARY PROTOCOL COMMAND
SPCCMD:	0			;JSR HERE
	SETZM	EPT##+SPCFLG	;CLEAR FLAG FIRST.
	MOVEM	T1,EPT##+SPCCMW	;STUFF COMMAND
	MOVEI	T1,SPCTRN	;GET # OF TIMES TO TRY
	MOVEM	T1,SPCTRY
SPCCM1:	CONO	DTE,TO11DB	;RING DOORBELL
	MOVEI	T1,40000
	SKIPN	EPT##+SPCFLG
	 SOJG	T1,.-1
	JUMPG	T1,@SPCCMD	;WORKED, RETURN.
	SOSL	SPCTRY
	JRST	SPCCM1
	XCT	SPHNGI

DTEHLT:	0
	 STOPCD		;;DTEHLT+1
>;END IFCPU (KL)
SUBTTL	SETUUO TO SET INITIA ON LINES MARKED

NOXEXE::0			;Set nonzero by ONCE to not run XEXEC

INISET::MOVSI	T1,(STAUTO)	;Enter here from UUOCON (DSKCLN does this)
	TDNN	T1,STATES	;Check if still in auto-restart mode
	 POPJ	P,		;Don't do this more than once
	MOVEI	U,CTYLDB	;Output to the CTY
	SKIPE	NOXEXE		;If set to not run XEXEC,
	 JRST	[MOVEI T1,STSUPR   ;Change super-shut (600000)
		 ANDCAM T1,STATES  ; to shut (400000) so OPER can login
		 SETZM NOXEXE	   ;Allow INITIA to be run later
		 MOVEI T1,[ASCIZ /INITIALIZATION complete
please log in: /]
		 PJRST CONMES##]
	MOVEI	T1,[ASCIZ /SETUUO forcing INITIA on TTY1,TTY2,TTY3,TTY4,TTY5
/]
	PUSHJ	P,CONMES##	;TELL OPERATOR WHAT IS HAPPENING
	MOVSI	P3,-PORTN##	;CHECK ALL LINES
INISLP:	MOVE	U,LINTAB(P3)
	SKIPN	LDBLOG(U)	;NOT IF LOGGED IN
	TLNN	U,TTVIN2	;OR NOT MARKED
	 JRST	INISL2
	MOVE	T2,[LLLNLN,,LDLCOM]	;FOR LDBLOG AND LDBDCH
	HLLZM	T2,LDBLOG(U)	;MARK IN (BUT UNKNOWN TO THE BASE)
	HRLZM	T2,LDBDCH(U)	;AND COMMAND MODE
	MOVE	T1,SYSNUM##	;Our host number
	DPB	T1,LDPHST	; for job running INITIA part 2 (XEXEC)
	SETZM	LDBDCX(U)	;NO EXTENDED BITS ON
	PUSHJ	P,SETLMD
	PUSHJ	P,FRMASN##	;Assign a frame slot
	  POPJ	P,		;None there? Quit loop now, why bother?
	PUSHJ	P,TTYATI	;Attach TTY DDB to this LDB
	  PJRST	FRMKJF##	;No DDB's - free up frame slot,kill TTY
	MOVEI	T1,CMFCXI##
	PUSHJ	P,TTFORC	;MARK FORCED COMMAND
INISL2:	AOBJN	P3,INISLP
	JRST	CPOPJ1
SUBTTL	SOME ROUTINES TO FIND TELETYPES FOR VARIOUS PURPOSES

;SUBROUTINE TO FIND TTY FOR A JOB IN J (TTYFND) OR FOR
; CURRENT JOB (TTYFNU)
;RETURN WITH F AND U SET UP.
;GOES TO ERROR IF NO TTY F FOR THE JOB.

TTYFNU::MOVE	J,JOB		;GET CURRENT UUO LEVEL JOB NUMBER
TTYFND::PUSHJ	P,TTYSRC	;FIND THE JOB'S TTY F, ALSO U AND S
	 STOPCD 		;JOB ZERO, OR OTHERWISE NO DDB. COMPLAIN.
	POPJ	P,0		;SUCCESS. RETURN.

;ROUTINE TO FIND A TTY F WHICH IS ATTACHED TO, I.E.
;CONTROLLING, A PARTICULAR JOB NUMBER.

;CALLED AT COMMAND LEVEL BY ATTACH COMMAND, AND AT M LEVEL
;BY REFERENCES TO DEVICE "TTY" OR TTCALLS, ETC.

;CALL:	MOVE J,JOB NUMBER DESIRED
;	PUSHJ P,TTYSRC
;	  ERROR RETURN.	;NOT FOUND. AC'S U,F,S NOT GUARANTEED
;	NORMAL RETURN	;U, S AND F SET UP. NOTE THAT THIS DOES
;			;!NOT! IMPLY THAT ANYONE IS ATTACHED. THAT IS,
;			; U MAY CONTAIN A ZERO


TTYSRC::JUMPE	J,CPOPJ		;NOBODY CONTROLS JOB ZERO. YOU ARE CONFUSED.
	HRRZ	F,TTYTAB(J)	;REALLY MUST BE HERE
	JUMPE	F,CPOPJ
	HRRZ	U,DDBLDB(F)
	MOVE	S,DEVIOS(F)	;SET UP I/O STATUS AND LINE
	JRST	CPOPJ1
SUBTTL	SUBROUTINE TTYERP TO FIND TTY F FOR A MONITOR ERROR MSG
;CALL WITH J SET TO JOB NUMBER. IF JOB IS ZERO OR JOB
;IS DETACHED USER OPRLDB. IF NOT EVEN THAT IS THERE,
;GIVE RETURN. NORMAL RETURN IS SKIP

TTYERP::PUSHJ	P,TTYSRC	;FIND F
	  JRST	GETOPR		;NO, USE OPER
	JUMPN	U,CPOPJ1	;RETURN IF ATTACHED

;GETOPR DESTROYS U,F, T1-T4. ALL OTHER ACS ARE SAVED.
GETOPR::HRRZ	U,OPRLDB	;IS OPER THERE
	JUMPN	U,GETOP1	;YES, GET F SET UP

;GETCTY USED BY CHKPNT WATCHDOG TO FORCE MSG TO CTY
;GETOPR DESTROYS U,F, T1-T4. ALL OTHER ACS ARE SAVED.

GETCTY::MOVEI	U,CTYLDB	;GET CTY'S LDB
	PUSH	P,T1
	PUSH	P,T2
	MOVE	T1,LDBTOC(U)	;CHECK CURRENT COUNT
	CAILE	T1,^D140
	 PUSHJ	P,TSETBO	;TOO BIG, CLEAR
	POP	P,T2
	POP	P,T1
GETOP1:	HRRZ	F,LDBDDB(U)
	POPJ	P,
SUBTTL	FIND A USER AND WAIT FOR ATTACH OR OUTPUT WAIT TO FINISH

TTYFUW::PUSHJ P,TTYFNU
TTYFW1:	PUSHJ P,CKATTF		;WAIT FOR ATTACH
	MOVE T1,LDBTOC(U)	;HAVE TO PUT IT IN HERE SO
	CAIG T1,10		;DOES OT CALL SCNINT
	POPJ P,
TOWATA:	MOVE S,[XWD TTYOUW+IO+TIOUSE,IOACT]
	IORB S,DEVIOS(F)
	PUSH P,P1
	PUSH P,P2
	PUSHJ P,WSYNC
	POP P,P2
	POP P,P1
	MOVSI S,TIOUSE
	ANDCAB S,DEVIOS(F)
	POPJ P,

TTYSOW::MOVE S,[XWD TTYOUW+IO,IOACT]
	IORB S,DEVIOS(F)
	POPJ P,

;AAA JAN 77 ROUTINE TO GET OPER TTY & SKIP RETURN WITH U,F.
; & RETURN NON-SKIP WITH CTY LDB DDB IN U,F IF NO OPR TTY EXISTS

GTOPER::PUSHJ	P,GETOPR
	CAIE	U,CTYLDB
	 JRST	CPOPJ1	;SKIP, GOT OPR
	POPJ	P,
;(GTOPER USED BY CHKPNT WATCHDOG TO SEND MSGS TO BOTH CTY & OPR)
SUBTTL	SUBROUTINE TO FIND LDB FOR A PHYSICAL NAME, IF ITS A TTY
;AND LOAD F WITH LINKED DATA BLOCK, IF ANY, BUT DONT MAKE ONE IF NONE YET
;SKIP RETURN IF ITS A TTY

TTYPHY::CAMN	T1,[SIXBIT /OPR/]	;TALK TO OPERATOR?
	 MOVE	T1,DEVOPR		;YES. GET REAL DEVICE NAME
	HLLZ	U,T1			;GET FIRST THREE CHARACTERS
	CAMN	U,[SIXBIT /TTY/]	;ARE THEY TTY?
	TRNN	T1,770000		;AND ALSO IS FOURTH CHAR NON-BLANK?
	 POPJ	P,			;NO. NOT A LEGAL NAME.
	PUSH	P,T1			;YES. MAY BE LEGAL.
	HRLZS	0(P)			;PUT THE RIGHT THREE CHARS ON STACK
	PUSH	P,[POINT 6,-1(P)]	;POINTER TO READ CHARS
	MOVEI	U,0			;INITIALIZE U TO 0
TTYPH4:	ILDB	T1,0(P)			;GET A SIXBIT CHARACTER FROM NAME
	JUMPE	T1,TTYPH2		;JUMP IF END OF NAME.
	TRC	T1,'0'			;CONVERT SIXBIT TO BINARY
	CAILE	T1,7			;IS IT AN OCTAL DIGIT?
	 JRST	TTYPH3			;NO. BAD CHAR IN NAME
	ASH	U,3			;MULTIPLY BY 8
	ADDI	U,0(T1)			;ADD IN THIS DIGIT
	JRST	TTYPH4			;LOOP FOR MORE DIGITS

TTYPH3:	POP	P,T1			;HERE ON BAD CHAR. CLEAR OUT STACK
	JRST	TPOPJ			;AND RETURN TO ERR RET

TTYPH2:	POP	P,T1			;HAVE AN OCTAL NUMBER. DISCARD
	POP	P,T1			; TWO ITEMS FROM STACK
	CAIL	U,PORTN##		;IS IT A LEGAL HARDWARE LINE #
	 POPJ	P,			;NO. TOO BAD.
	HRRZ	U,LINTAB(U)		;GET LINE DATA BLOCK ADDRESS
	HRRZ	F,LDBDDB(U)		;GET ATTACHED F, IF ANY.
	JRST	CPOPJ1			;GOOD RETURN

;ROUTINE TO GET A DDB. CALLED IN DEVSRCH ROUTINES

GETDDB::PUSHJ	P,TTYPHY	;FIND THE TELETYPE BY NUMBER
	  POPJ	P,		;NOT A REAL TTY
	JUMPE	F,CPOPJ		;NOT REALLY THERE YET
	MOVE	T1,DEVNAM(F)	;IF SOMEONE ELSES WILL BE
	JRST	CPOPJ1		;ASSIGNED BY CONSOLE SO CAN'T HAVE IT ANYWAY
SUBTTL	SUBROUTINE TO PUT PHYSICAL NAME INTO T2 FOR LINE WHOSE LDB IS IN U
;EVEN THOUGH THERE MAY BE NOTHING IN F OR LDBDDB

TTYNAM::LDB	T1,LDPLNO		;GET LINE NUMBER
	PUSH	P,[SIXBIT /TTY/]	;PUT NAME ON STACK
	MOVEI	T3,0(P)			;PREPARE ARG FOR SCNNMR
	HRLI	T3,220600		;POINT 6,0,17
	PUSHJ	P,SCNNMR		;AND CALL SAME ROUTINE AS SCNNAM DOES
	POP	P,T2			;PUT ANSWER IN T2
	POPJ	P,			;AND RETURN FROM TTYNAM

;SUBSIDIARY ROUTINE TO DO RADIX PRINT TO CORE.

SCNNMR:	IDIVI	T1,10			;DEVICE NAMES ARE OCTAL
	HRLM	T1+1,0(P)		;STORE A DIGIT ON STACK
	SKIPE	T1			;NEED MORE DIGITS?
	 PUSHJ	P,SCNNMR		;YES. GO MAKE THEM.
	HLRZ	T1,0(P)			;RETRIEVE A DIGIT FROM STACK
	ADDI	T1,'0'			;CONVERT TO SIXBIT
	IDPB	T1,T3			;STORE IN OBJECT WORD (DEVNAM)
	POPJ	P,0			;POP UP TO SCNNMR OR BACK TO SCNNAM
SUBTTL	SETUUO OUTPUT MESSAGE TO OPR TTY & CTY *BOTH*, IF POSSIBLE.
;OTHERWISE JUST TO CTY.

OPRSND::HRRZ	M,T1
	HRLI	M,(POINT 7,0)
OPRSN2:	SKIPN	U,OPRLDB	;GET OPR
	 MOVEI	U,CTYLDB	;NONE, GO TO CTY ONLY
	MOVE	T1,LDBTOC(U)
	IOR	T1,CTYLDB+LDBTOC;WAIT IF EITHER OPR TTY OR CTY
	JUMPN	T1,OPRWAT	;IS BUSY (OUTPUT BUFF NOT-EMPTY)
				;UNWAIT WHEN ONE OR THE OTHER
				;BECOMES EMPTY
OPSND1:	XCTFU	<ILDB T3,M>
	JUMPE	T3,CPOPJ1	;DONE
	PUSHJ	P,CCTYO		;SAME OUTPUT RESTRICTIONS AS COMMAND
	SKIPN	OPRLDB		;SKIP IF GOING TO BOTH
	 JRST	OPSND1		;JUST TO CTY, ALREADY DONE
	MOVEI	U,CTYLDB
	XCTFU	<LDB T3,M>	;GET SAME CHAR JUST SENT,
	PUSHJ	P,CCTYO		;& PUT IT ON CTY
	MOVE	U,OPRLDB	;RESTORE U
	JRST	OPSND1

OPRWAT:	MOVEI	T1,MLOWQ	;WAIT FOR OPR BUFFER TO EMPTY
	DPB	T1,PJBSTS##	;SET TO MON WAIT QUE
	HRRZ	T1,OPRWJB	;GET WAITING JOB IF ANY
	MOVEM	T1,QUEPCB(J)	;PUT ON QUE
	HRRZM	J,OPRWJB	;AND SET CURRENT
	PUSHJ	P,WSCHED
	JRST	OPRSN2		;RESTARTED. ONE OF THEM JUST BECAME
				;FREE. GO CHECK AGAIN MAKE SURE BOTH FREE.

;Here when the OPR terminal is free to do more output

OPRFRE::SKIPN	T2,OPRWJB
	 POPJ	P,		;NONE WAITING
	SETZM	OPRWJB		;RESTART ALL WAITERS
	PUSH	P,J
OPRFR1:	MOVE	J,T2
	MOVEI	T1,RNQ
	DPB	T1,PJBSTS##
	PUSHJ	P,SETRUN
	HRRZ	T2,QUEPCB(J)
	SETZM	QUEPCB(J)	;ZERO OLD ENTRY
	JUMPN	T2,OPRFR1	;ANY MORE?
	POP	P,J
	POPJ	P,		;DONE
SUBTTL	SUBROUTINE FOR THE TTY COMMAND

;ON ENTRY P1 HAS LDB TO DO THINGS FOR, T2 HAS COMMAND

SCNTCD::MOVSI	T1,-TTCWDN	;GET LENGTH OF COMMAND TABLE
	CAME	T2,TTCWDT(T1)
	 AOBJN	T1,.-1
	JUMPG	T1,CPOPJ1	;NOT FOUND, TAKE ERROR RETURN
	HRRZ	T2,TTCWDD(T1)	;GET DISPATCH
	JRST	(T2)		;AND GO


TTCWDT:	SIXBIT /NO/
TTYTBL::SIXBIT /TAB/
	SIXBIT /FORM/
	SIXBIT /LC/
	SIXBIT /FILL/
	SIXBIT /ECHO/
	SIXBIT /CRLF/
	SIXBIT /WIDTH/
	SIXBIT /XON/
	SIXBIT /TAPE/
	SIXBIT /FILL1/
	SIXBIT /FILL2/
	SIXBIT /IN/
	SIXBIT /OUT/
	SIXBIT /A/
	SIXBIT /B/
	SIXBIT /C/
	SIXBIT /D/		;Was /TYPE/
	<SIXBIT /BACKSPACE/>
	SIXBIT /ERASE/
	SIXBIT /RXE/
	SIXBIT /DEF/
	SIXBIT /UCO/
	SIXBIT /BSD/
	SIXBIT /RBS/
	SIXBIT /CLASS/		; [dws]
	SIXBIT /RTCOMP/		;[Darren]
	SIXBIT /KATAKA/		;KATAKANA (JIS-8 ASCII) mode
	SIXBIT /TYPE/		;Type of terminal
TTCWDN==.-TTCWDT
TTYMXL==:<TTCWDN-1-1>_^D9

TTCWDD:	XWD 0,TTCNO		;LH MAY HAVE A BIT TO SET/RESET
	XWD TCNTAB,TTCSET
	XWD TCNFRM,TTCSET
	XWD TCNLCT,TTCCLR
	XWD 0,TTCFIL
	XWD TCNHDX,TTCCLR
	XWD TCNNFC,TTCCLR
	XWD TCNWID,TTCVAL
	XWD TCNPTP,TTCSET
	XWD TCNPTP,TTCSET
	XWD TCNFC1,TTCVAL
	XWD TCNFC2,TTCVAL
	XWD TCNIR,TTCVAL
	XWD TCNOR,TTCVAL
	XWD TCNPA,TTCVAL
	XWD TCNPB,TTCVAL
	XWD TCNPC,TTCVAL
	XWD TCNPD,TTCVAL	;Parameter D (formerly TCNTYP)
	XWD TCNBSP,TTCSET
	XWD TCNERA,TTCSET
	XWD TCNRXE,TTCSET
	XWD TCNDEF,TTCSET
	XWD TCNLCO,TTCCLR
	XWD TCNBSD,TTCSET
	XWD TCNECH,TTCSET
	XWD TCNCLA,TTCSIX	;Class
	XWD TCNRTC,TTCSET	;RTcompatibility
	XWD TCNKAT,TTCSET	;Katakana mode
	XWD TCNTYP,TTCTYP	;TYPE is a number or a sixbit value
SUBTTL	SET TTY routines

TTCNO:	TLC	P1, -1		;COMPLEMENT YES-NO FLAG
	POPJ	P,

;BIT-VALUED CHARACTERISTICS

TTCCLR:	TLC	P1,-1		;OPPOSITE OF SET
TTCSET:	HLRZ	T1,TTCWDD(T1)	;T1/ TC# FOR SETTCN
	JUMPL	P1,TTCDO1	;RESETTING THE BIT
	MOVEI	T2,1
	PUSHJ	P,TTCGO
	  AOS	(P)
	POPJ	P,
TTCDO1:	SETZ	T2,
	PUSHJ	P,TTCGO
	  AOS (P)
TTCFIN:	HRRZS	P1		;Clear "NO" flag
	POPJ	P,

;DECIMAL-VALUED CHARACTERISTICS

TTCVAL:	PUSH	P,T1
	JUMPL	P1,TTCVL0	;"NO" = 0
	PUSHJ	P,DECIN1##	;T2 := DECIMAL NUMBER
	  JRST	TPOPJ1	
	  JRST	TPOPJ1		;NO NUMBER OR BAD NUMBER
	JRST	TTCVL1
TTCVL0:	SETZ	T2,
TTCVL1:	POP	P,T1		;T1/ VALUE FROM DISPATCH
TTCVL2:	HLRZ	T1,TTCWDD(T1)	;T1/ TC# FOR SETTCN
TTCVL3:	PUSHJ	P,TTCGO
	  AOS	(P)
	POPJ	P,

;[dws] Sixbit-valued characteristics

TTCSIX:	PUSH	P,T1		; save T1
	SKIPGE	P1		; skip if "No" not seen
	 TDZA	T2,T2		;  "No" = blanks
	PUSHJ	P,CTEXT1##	; T2 := sixbit text
	POP	P,T1		; T1/ value from dispatch
	JRST	TTCVL2		; Go set it

;Treat SET TTY TYPE specially for Japanese customers

TTCTYP:	PUSH	P,T1		; save T1
	SKIPGE	P1		; skip if "No" not seen
	 TDZA	T2,T2		;  "No" = blanks
	PUSHJ	P,CTEXT1##	; T2 := sixbit text
	POP	P,T1		; T1/ value from dispatch
	CAME	T2,[SIXBIT /0/]	;Old "TTY TYPE 0" command?
	CAMN	T2,[SIXBIT /1/]	;Old "TTY TYPE 1" command?
	 SKIPA			;Yes
	  JRST	TTCVL2		;No, just store value
	LSH	T2,^D<5-35>	;Yes, right justify number
	ANDI	T2,7		;Keep as 0 or 1
	MOVEI	T1,TCNPD	;Act like "SET TTY D 1" command
	JRST	TTCVL3		;Go set parameter "D" for KATAKANA

TTCGO:	PUSH	P,U		;T1/ TCNxxx (PDP-10 TC number)
	HRR	U,P1		;U/ LDB ADDR
	HLL	U,LDBDCH(U)
	PUSHJ	P,SETTC1	;GO SET THE TC
	  JRST	.+2
	AOS	-1(P)		;TRANSFER THE SKIP-RETURN
	POP	P,U
	POPJ	P,
SUBTTL	FOR OLD TIME'S SAKE (SET FC1 AND FC2 FROM THE SAME VALUE)

TTCFIL:	JUMPL	P1,TTCFL0
	PUSHJ	P,DECIN1##
	  JRST	CPOPJ1
	  JRST	CPOPJ1
	JRST	TTCFL1
TTCFL0:	SETZ	T2,
TTCFL1:	MOVEI	T1, TCNFC1
	PUSHJ	P, TTCGO
	  JRST	CPOPJ1
	MOVEI	T1, TCNFC2
	PUSHJ	P, TTCGO
	  AOS	(P)
	POPJ	P,
SUBTTL	CALLED FROM COMCON TO SET TO SEND SHUT OR ANSWERED MESSAGE

SETSHT::MOVSI	T1,TYPI TYPSHT	;SET TO SAY SHUT
	MOVEI	T2,STSHUT	;400000
	TDNN	T2,STATES	;IS THAT THE STATE
	 MOVSI	T1,TYPI TYPANS	;YES, SO SAY ANSWERED
	MOVEM	T1,UPSHUT
	TDNN	T2,STATES	;UP OR DOWN?
	 JRST	CKOPR		;UP, SEE IF DEVOPR SET
	SETZM	OPRTIM		;DOWN, TURN OFF TIMER
	MOVEI	T2,ALROPR
	ANDCAM	T2,ALR620	;AND ALARM
	POPJ	P,

CKOPR:	SKIPE	DEVOPR
	 POPJ	P,		;DEVOPR SET, ALL OK
	MOVEI	T2,^D90		;SET FOR 90 SEC TILL ALARM
	MOVEM	T2,OPRTIM
	POPJ	P,

;CALLED TO SEE IF WAITING FOR LOGOUT SO CAN NOT SET JACCT2

CKLGO::	HRRZ F,TTYTAB(J)
	JUMPE F,CPOPJ1		;NO DDB, SAY OK TO SET
	HRRZ U,DDBLDB(F)
	JUMPE U,CPOPJ1		;NO LINE, CAN NOT BE WAITING
	MOVSI T4,LLLZAP
	TDNN T4,LDBLOG(U)	;SEE IF ZAPPER RECEIVED FLAG SET
	 AOS (P)		;NO, OK
	POPJ P,
SUBTTL ATTACH/DETACH

;TTYKIL - ACTUALLY TWO ROUTINES
;
;1)	CALLED WITH F/ 0, U/ LDB ADDR TO ZAP LINE WHENEVER A
;	COMMAND HAS JUST BEEN FORCED ON A NON-JOB (E.G.,
;	WHEN JOB CAPACITY IS EXCEEDED), AND, BY SOME QUIRK
;	OF FATE, AFTER EVERY DETACH COMMAND (BECAUSE COMCON
;	RELOADS F FROM LDBDDB(U) AND INCORRECTLY THINKS
;	F/ 0 = NO JOB)
;
;2)	CALLED WITH F/ DDB ADDR, U/ ANYTHING TO ZAP THE
;	ATTACHED PORT, IF ANY, AND FREE THE COMMAND PORT DDB
;	OF A JOB BEING KILLED.

TTYKIL::JUMPE	F,TTYZAP	;IF THERE'S NO JOB (CASE 1): ZAP IT

;(CASE 2) FREE THE DDB, THEN ZAP THE CIRCUIT

	SETZM	DEVNAM(F)
	SETZM	DEVLOG(F)
	LDB	T1,PJOBN
	SKIPE	T1
	SETZM	TTYTAB(T1)	;MAKE SURE MARKED AS NO DDB
	MOVSI	T1,IOFST
	MOVEM	T1,DEVIOS(F)
	DPB	T1,PJOBN	;THIS WILL SET TO JOB 0
	HRRZ	U,DDBLDB(F)	;CHECK FOR A LINE ATTACHED
	JUMPE	U,TTYKDB	;DETACHED ALREADY?

    ; U/ 0,,LDB ADDR
    ;HERE WHEN WE'RE TTYKILLING AN ATTACHED DDB

	HLLZS	LDBDDB(U)	;DISCONNECT LINE FROM F
	PUSHJ	P,TTYZAP	;ELSE ZAP THE CIRCUIT
	PFALL	TTYKDB
SUBTTL	TTYKDB - CLEAR LDB PTR AND ASSIGNMENT & USE BITS FOR A TTY DDB
;	   (ADDR IN F), AND RETURN IT TO THE FREE POOL

TTYKDB:	JUMPE	F,CPOPJ
	HLLZS	DDBLDB(F)	;NO F FROM U
	MOVE	T1,[XWD TTYATC,ASSCON!ASSPRG]
	ANDCAM	T1,DEVMOD(F)	;CLEAR OUT ALL USE AND ASSIGN BITS
	HLRZ	T2,DDBBLK(F)	;GET BACK LINK
	HLRZ	T1,DEVSER(F)	;AND FORWARD LINK
;;Start of debug code;;
	MOVEM	F,XXCDDB	;Current DDB pointer
	MOVEM	T1,XXNDDB	;Next DDB pointer
	MOVEM	T2,XXPDDB	;Previous DDB pointer
	PUSH	P,DEVSER(F)	;Current forward link
	POP	P,XXCSER
	PUSH	P,DDBBLK(F)	;Current backward link
	POP	P,XXCBLK
	PUSH	P,DEVSER(T1)	;Next forward link
	POP	P,XXNSER
	PUSH	P,DDBBLK(T1)	;Next backward link
	POP	P,XXNBLK
	PUSH	P,DEVSER(T2)	;Previous forward link
	POP	P,XXPSER
	PUSH	P,DDBBLK(T2)	;Previous backward link
	POP	P,XXPBLK
;;End of debug code;;
	HRLM	T1,DEVSER(T2)	;LINK AROUND DDB
	PUSH	P,T3
	MOVE	T3,DEVMOD(T1)	;IS NEW DEST. ALSO A TTY?
	TLNE	T3,DVTTY!DVRMT
	 HRLM	T2,DDBBLK(T1)	;YES, SET ITS BACK POINTER
	POP	P,T3
	MOVE	T1,FRETTY
	HRLM	T1,DEVSER(F)	;AND LINK INTO FREE POOL
	HRRZM	F,FRETTY
	HRRZ	F,T2		;POINT TO PRED FOR LINKING
;Check that the DDB chain ends properly
	HLRZ	T1,DEVLST##	;Beginning of DDB chain
	MOVEI	T2,^D10000	;Paranoid loop counter
TTYKD1:	JUMPE	T1,CPOPJ	;Quit when end of chain is found
	HLRZ	T1,DEVSER(T1)	;Point to next DDB
	SOJG	T2,TTYKD1	;Look for end
DDBCNE:: STOPCD (.,STOP,DDBCNE,,<DDB chain has no end>) ;;TTYKDB+many
	POPJ	P,

XXCDDB:	0			;Current DDB pointer
XXCSER:	0			;DEVSER word with forward pointer
XXCBLK:	0			;DDBBLK word with backward pointer
XXNDDB:	0
XXNSER:	0			;Ditto for next DDB
XXNBLK:	0
XXPDDB:	0
XXPSER:	0			;Ditto for previous DDB
XXPBLK:	0
SUBTTL	TDTUUO - HERE FROM ATTACH UUO WHEN DETACHING THE COMMAND PORT
;	   (J/ JOB NUMBER)

TDTUUO::PUSHJ	P,TTYSRC	;FIND F
	 POPJ	P,		;NONE THERE
	JUMPE	U,CPOPJ		;MUST NOT BE WAITING FOR LOGOUT
	MOVSI	T1,LLLZAP
	TDNE	T1,LDBLOG(U)
	 POPJ	P,
	PFALL	TTYDET

;TTYDET - DETACH A TTY DDB (ADDR IN F)

TTYDET::HRRZ U,DDBLDB(F)	;GET LDB ADDR
	HLLZS DDBLDB(F)		;AND CLEAR LINK
	HRRZS DEVNAM(F)		;SAVE PORT # BUT CLEAR "TTY"
				;SO DEVICE SEARCH DOESN'T FIND IT
	MOVEI	T1, 1
	DPB	T1, DDPCOM	;SHOULD RE-ATTACH IN CMND MODE
	JUMPE U,CPOPJ		;NO LINE TO SEND ZAPPER ON
	HLLZS LDBDDB(U)		;CLEAR LDB TO DDB LINK
	PJRST TTYZAP		;  SEND A ZAPPER ON IT

;TYCIOS - called by CLOCK1 to clear ALL tty's IOS

TYCIOS::PUSHJ P,FRSTTY
	  POPJ P,	
	JRST TYIOS2		;include command port

TYIOS1:	PUSHJ P,NXTTTY	;THIS WILL BE AUX CIR OR RMT
	  POPJ P,	;FINISHED, NONE THERE
TYIOS2:	MOVSI T1,DVRMT
	TDNE T1,DEVMOD(F)
	JRST	[MOVE S,[IOW,,IOACT]	;RESET BITS FOR RMT
		ANDCAM S,DEVIOS(F)
		JRST TYIOS1]	;NEXT
	MOVE S,[IOW+TIOUSE,,IOACT]
	ANDCAM S,DEVIOS(F)	;RESET ALL BITS INCLUDING USE
	MOVE T1,[TTYATC,,ASSCON+ASSPRG]
	TDNN T1,DEVMOD(F)	;ANY REASON TO KEEP IT
	PUSHJ P,TTYKDB		;NO, GET RID OF IT
	JRST TYIOS1

;IFDET - CALLED FROM EXIT UUO: IF DETACHED, SKIP, ELSE DO A
;	  TTYFUW AND NONSKIP-RETURN

IFDET::	PUSHJ P,TTYFND
	JUMPE U,CPOPJ1	;IS DETACHED
	JRST TTYFW1	;FINISH THE TTYFUW
SUBTTL	TTYZAP - ZAP A CIRCUIT (U/ LDB ADDR).

;Whenever a zapper originates from the PDP-10, then a yellow ball is
;sent out first to make sure that the zapper does not gobble any of the
;logout messages.  In this case, a 20-second timer is started and the
;zapper is not sent until an orange ball is reflected by the TYMSAT.
;
;Whenever a zapper originates from TYMNET, the base has already given up
;on the port and marks is as being "in clean up" until we return the zapper.
;
;In either case, the line is marked as "not in use" when we send a zapper.
;We must respond to incoming zappers, but the base sends no response to
;an outgoing zapper.

;Change in P035/D05 - don't send yellow ball if line is not marked in use,
;because base will ignore it and we will be waiting 20 seconds for an orange
;ball that will never come in.  However, if a login just happens to come in
;while we are waiting, it used to cause TTYZNE and/or a base crash.
;Also: EBUS version 2.0 did not range-check zappers.  When B39 was configured
;for 128 ports and its base for 127, the base would crash when a zapper
;was sent out on TTY177.

TTYZAP:	MOVEI	T2,1
	MOVE	T1,LDBLOG(U)	;Get TYMNET status of line
	JUMPGE	T1,TTYZP1	;No yellow/orange if port not in use
	TLNN	T1,LLLNLN	;Send yellow ball and wait for orange to be
	 DPB	T2,LOPSYL	; reflected (unless zap came from base)
TTYZP1:	DPB	T2,LOPZAP	;Set flag to send zapper
	DPB	T2,LDBOPB(U)	;Mark line as needing output
	MOVSI	T1,LDLNOP
	ANDCAM	T1,LDBDCH(U)	;Ignore backpressure
	MOVSI	T1,LMLBIO
	TDNE	T1,LDBMOD(U)	;If it's in block I/O mode,
	 PUSHJ	P,BIOREL	; get it out
	POPJ	P,
SUBTTL	TTYATT - ATTACH LDB TO JOB
;	   U/ LDB  J/ JOB#
;	   SKIP-RETURNS ON SUCCESS WITH F/ CMND PORT DDB
;	   NONSKIP-RETURNS ON FAILURE WITH F/ 0

TTYATT::PUSH	P,U
	MOVEI	F,0		;RET 0 IN CASE DONT FIND TTY DDB
	PUSHJ	P,TTYSRC	;FIND THE F FOR THAT JOB
	  JRST	LPOPJ		;NONE, SHOULD NOT HAVE GOTTEN HERE
	JUMPE	U,TTYAT1	;WAS THERE ANYONE ATTACHED
LPOPJ:	POP	P,U		;YES, NOONE CAN DO THIS FOR NOW
	POPJ	P,

COMMENT ! TTYATI - CALLED TO DO INITIAL ATTACH WHEN
	PROCESSING LOGIN.
EXPECTS:  U/ LDB ON WHICH LOGIN APPEARED
	  J/ JOB SLOT TO WHICH WE WANT TO ATTACH IT
CLOBBERS: T1 - T4
RETURNS: CPOPJ IF CANNOT ATTACH. F/0 IF NO TTYDDB'S, F/DDB IF
		BECAUSE ALREADY ATTACHED
	 CPOPJ1 IF SUCCESS, F/DDB
!


TTYATI:	PUSH P,U
	PUSHJ P,TTYSRC	;CHECK FOR A F FOR THIS JOB
	 PUSHJ P,DDBSRC	;NONE, FIND A FREE ONE
	  JRST LPOPJ	;NO FREE F OR JOB ALREADY HAS ONE, GIVE ERROR RETURN
TTYAT1:	MOVE U,0(P)	;RESTORE LINE USER IS NOW ON
	PUSH P,F
	HRRZ F,LDBDDB(U)	;DOES IT HAVE A F?
	JUMPE F,TTYAT2	;NO, JUST DO THE ATTACH
	HLLZS DDBLDB(F)	;GET RID OF LINK TO LINE SO
	HRRZS DEVNAM(F)	;MAKE SURE LEFT OF NAME ZEROED
TTYAT2:	POP P,F		;NOW RESTORE F HE GOES TO
	POP P,U
	MOVE T1,[XWD TTYATC,ASSCON]	;ASSIGN IT
	IORM T1,DEVMOD(F)
	DPB J,PJOBN		;SET JOB ASSIGNED TO
	MOVE T1,TIMRST##	;RESET ANY WAITING HANG
	DPB J,CLKJOB##		;WHICH MAY EXIST IN CLOCK QUEUE
	PUSHJ P,CHGCLK		;FOR PREVIOUS OWNERS OF THIS JOB SLOT
	HRRZM F,TTYTAB(J)	;SET TTYTAB UP
	PUSHJ P,SCNNAM		;FILL IN NAME OF TTY F
	PUSHJ	P, COMATT	;JOIN F AND U
	JRST CPOPJ1		;AND TAKE GOOD RETURN
SUBTTL	 HERE FROM THE ATTACH UUO IF IT'S ATTACHING
; T1/ USERMODE,,JOB# WHERE USERMODE IS 1 TO
; ATTACH THE PORT IN USER MODE AND 0 TO ATTACH
; IT IN COMMAND MODE

TATUUO::PUSH	P,T1
	PUSHJ	P,TTYSRC	;FIND F FOR THIS JOB
	  JRST	TPOPJ		;CAN NOT ATTACH, NO F
	HRRZ	U,DDBLDB(F)
	JUMPE	U,TPOPJ		;GIVE UP
	MOVSI	T1,LLLZAP
	TDNE	T1,LDBLOG(U)
	 JRST	TPOPJ		;DO NOT ALLOW IF WAITING FOR LOGUT
	HRRZ	J,0(P)		; J/ 0,,TARGET JOB#
	PUSHJ	P,TTYATT	;Attach our old line to new job
	  JRST	TPOPJ		;CANNOT ATTACH
	POP	P,T1		;T1/USERMODE,,TARGET JOB#
	AOS	(P)
	PUSH	P,T1
	TLNE	T1,(1B15)	;does user want frame continued?
	 PUSHJ	P,RTCONT	;yes - do it
	POP	P,T1
	TLNE	T1,(1B17)	;WANTS USER MODE?
	 JRST	TATUU1		;YES.
	PUSHJ	P,PRPRMT##	;GIVE HIM A PERIOD OR HYPHEN
	PUSHJ	P,CNCMOD	;FORCE TO COMMAND LEVEL
	JRST	TTYSTC		;AND GO

TATUU1:	MOVSI	T1,LDLCOM
	ANDCAM	T1,LDBDCH(U)	; PUT INTO USER MODE
	PUSHJ	P,SETLMD
	POPJ	P,		; SKIP-RETURN ((P) AOS'D ABOVE)


; RTCONT - call here to make sure target frame is running.
; Called in response to user request by ATTACH UUO and RETACH UUO.
; Expects J/ target JOB #.
; Clobbers T1 alot.

RTCONT:	SKIPGE	T1,JBTSTS(J)	;check if its already running
	 POPJ	P,		;yep! nothing to do
	TLNE	T1,JERR		;can't continue if JERR set
	 POPJ	P,
	PJRST	SETRUN		;resume execution in target and return

COMMENT @

RETACH UUO - MOVE A TTY SOMEWHERE ELSE

	MOVEI	AC, [
		SOURCE FRAME,,TARGET FRAME
		BITS,,PORT
	]
	RETACH	AC,
	  ERROR RETURN	;AC/ ERROR CODE
	NORMAL RETURN	;AC/ PORT# OF PORT MOVED (FROM RH(DEVNAM))

	<BITS> = 1B0 TO ATTACH AS AUX/SLAVE PORT RATHER THAN
		     AS CMND PORT (MUST BE SIGN BIT)
	       + 0B2 TO ATTACH ACCORDING TO SAVED CMND MODE STATE
		 1B2 TO ATTACH IN CURRENT COMMAND MODE STATE
		 2B2 TO FORCE COMMAND MODE
		 3B2 TO FORCE USER MODE
	       + 1B3 TO SIGNAL A HANGUP ON THE SOURCE FRAME

	<ERROR CODE> = (SEE DEFINITIONS BELOW)
@

RT.SLV==400000
RT.MOD==300000
  DEFINE RTYMOD(X) = <[POINT 2,X,2]>
  .RTMSV==0
  .RTMCU==1
  .RTMCO==2
  .RTMUS==3
RT.SIG==040000
RT.CON==020000

RTSAC%==1	;INSUFFICIENT ACCESS TO SOURCE FRAME
RTSNX%==2	;SOURCE FRAME DOES NOT EXIST
RTTAC%==3	;INSUFFICIENT ACCESS TO TARGET FRAME
RTTNX%==4	;TARGET FRAME DOESN'T EXIST
RTSNA%==5	;PORT NOT ATTACHED TO SOURCE FRAME
RTTAT%==6	;PORT ALREADY ATTACHED TO TARGET FRAME
RTSCP%==7	;FORCED COMMAND PENDING ON PORT
RTAUX%==10	;ATTACHING AUX CIRCUIT AS CMND PORT
RTNRM%==11	;NO ROOM FOR NEW DDB
SUBTTL	RETACH uuo

RETACH::XCTFU <MOVE P1,0(T1)>	;P1/ SOURCE,,TARGET
	XCTFU <MOVE P2,1(T1)>	;P2/ BITS,,PORT

    ;CHECK ACCESS TO SOURCE FRAME

	HLRZ	P4, P1		;P4/ SOURCE FRAME DESC
	HRRZI	P3, .ARDET
	PUSHJ	P, FARCHK##	;MAY WE DETACH FROM THE SOURCE?
	  JRST	[
		MOVEI	T1, RTSAC%
		JRST	RTERR
	]
	MOVSI	T1, JNA
	TDNN	T1, JBTSTS(J)	;IS THE SOURCE JOB THERE?
	 JRST	[
		MOVEI	T1, RTSNX%
		JRST	RTERR
	]
	HRLM	J, P1

    ;CHECK ACCESS TO TARGET FRAME

	HRRZ	P4, P1		;P4/ TARGET FRAME DESC
	HRRZI	P3, .ARATT
	PUSHJ	P, FARCHK##	;MAY WE ATTACH TO THE TARGET?
	  JRST	[
		MOVEI	T1, RTTAC%
		JRST	RTERR
	]
	MOVSI	T1, JNA
	TDNN	T1, JBTSTS(J)	;IS THE TARGET JOB THERE?
	 JRST	[
		MOVEI	T1, RTTNX%
		JRST	RTERR
	]
	HRRM	J, P1
    ;SAVE THE CALLER'S JOB #

	PUSH	P, J

    ;GET THE PORT BEING MOVED

	HLRZ	J, P1		;J/ SOURCE FRAME #
	HRRE	F, P2		;F/ SOURCE PORT DESCRIPTOR
	PUSHJ	P, FNDPRT	;SET F/ DDB ADDR. IF NO DDB
	  JRST	RETCH1
	HRRZ	U, DDBLDB(F)
	JUMPN	U, RETCH2	;OR IF IT IS DETACHED
RETCH1:	MOVEI	T1, RTSNA%
	JRST	RTERJ		;  RESTORE J AND ERROR-RETURN

    ;J/ SOURCE FRAME#  F/ SOURCE DDB  U/ LDB

RETCH2:	SKIPGE	LDBDDB(U)	;IF LINE HAS PENDING COMMANDS,
	 JRST	[
		MOVEI	T1, RTSCP%
		JRST	RTERJ	;  RESTORE J AND ERROR-RETURN
	]
	LDB	T1, LDPCOM
	DPB	T1, DDPCOM	;SAVE CMND MODE STATE
	PUSHJ	P, NAMSCN	;T1 := PORT # FROM RH(DEVNAM)
	UMOVEM	T1, (M)		;GIVE IT TO CALLER
	HRRZ	J, P1		;J/ TARGET FRAME #
	HRRM	F, P2		;P2/ BITS,,SOURCE DDB
	JUMPL	P2, RTATS	;Negative TO ATTACH AS AUX/SLAVE PORT
    ;HERE TO ATTACH AS TARGET'S COMMAND PORT
    ;J/ TARGET JOB #  U/ LDB ADDR

RTATC:	HRRZ	J, P1		;J/ TARGET FRAME #
	HRRZ	F, TTYTAB(J)	;F/ 0,,DDB ADDR
	SKIPN	F		;IF THERE'S NO DDB,
	 STOPCD 		;  CRASH
	HLL	U, LDBDCH(U)
	TLNE	U, LDLAUX	;IF IT'S AN AUX CIRCUIT,
	 JRST	[
		MOVEI T1, RTAUX%
		JRST RTERJ	;  RESTORE J AND ERROR-RETURN
	]
	HRRZ	T1, DDBLDB(F)
	JUMPN	T1, [		;IF JOB'S ATTACHED ALREADY,
		MOVEI	T1, RTTAT%
		JRST	RTERJ	;  RESTORE J AND ERROR-RETURN
	]

	MOVE	T1,TIMRST##
	DPB	J,CLKJOB##
	PUSHJ	P,CHGCLK	;RESET TIMEOUT-ON-DISCONNECT TIMER
	PUSHJ	P,SCNNAM	;DEVNAM(F) := "TTY" & CVOS(LINE#)
	PUSHJ	P,LOGLDB##	;Set LDBLOG from UPTLOG if LDBLOG is zero
	PUSHJ	P,COMATT	;JOIN F AND U

	TLNE	P2,RT.CON	;User want us to force CONTINUE on target?
	 PUSHJ	P,RTCONT	;yes - go do it

	LDB	T1, RTYMOD<P2>	;T1/ LDLCOM "MODE"
	JRST	@[
		RTCSV		;0  .RTCSV  FORCE SAVED MODE
		RTFIN		;1  .RTCCU  RETAIN CURRENT MODE
		RTCCO		;2  .RTCCO  FORCE COMMAND MODE
		RTCUS		;3  .RTCUS  FORCE USER MODE
	](T1)

RTCSV:	MOVSI	T1, DCLCOM
	TDNN	T1, DDBDCH(F)	;CHECK SAVED LDLCOM SETTING
	JRST	RTCUS		;WAS 0 -- FORCE USER MODE
	JRST	RTCCO		;WAS 1 -- FORCE CMND MODE

RTCUS:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	;CLEAR COMMAND MODE
	PUSHJ	P, SETLMD	;FIX LINE MODE FIELD
	JRST	RTFIN

RTCCO:	MOVSI	T1,LDLCOM
	TDNE	T1,LDBDCH(U)	;IF NOT ALREADY AT CMND MODE,
	JRST	RTFIN
	PUSHJ	P,PRPRMT##	;  PRINT A PROMPT
	PUSHJ	P,CNCMOD	;  FORCE TO CMND MODE
	JRST	RTFIN

    ;HERE TO ATTACH AS A SLAVE PORT TO TARGET
    ;J/ TARGET JOB #  U/ LDB ADDR

RTATS:	LDB	F, LDPLNO	;F/ PORT #
	PUSHJ	P, FNDPRT	;F/ DDB FOR PORT. IF THERE ISN'T ONE,
	JRST	RTATS1		;  GO ALLOCATE A DDB
	HRRZ	T1, P2		;T1/ SOURCE DDB
	CAIN	T1, (F)		;IF IT'S THE SAME AS THE TARGET,
	JRST	RTATS1		;  ALWAYS ALLOCATE A NEW ONE

    ;USING EXISTING DDB

	HRRZ	T1, DDBLDB(F)
	JUMPN	T1, [		;IF ALREADY ATTACHED,
		MOVEI	T1, RTTAT%
		JRST	RTERJ	;RESTORE J AND ERROR-RETURN
	]
	MOVEI	T1, (SIXBIT/TTY/)
	HRLM	T1, DEVNAM(F)
	JRST	RTATS2

    ;ALLOCATING NEW DDB

RTATS1:	HRRZ	T1, TTYTAB(J)	;T1/ TARGET CMND PORT DDB
	SKIPN	T1		;IF THERE IS NONE,
	 STOPCD 		;  CRASH
	PUSHJ	P, DDBSR1	;F/ NEW DDB, LINKED AFTER CMND PORT.
	  JRST	[		;IF THERE'S NO ROOM FOR ONE,
		MOVEI T1, RTNRM%
		JRST RTERJ	;  RESTORE J AND ERROR-RETURN
	]
	DPB	J, PJOBN	;SET JOB #
	PUSHJ	P, SCNNAM	;AND PHYSICAL NAME
	MOVEI	T1, ASSCON
	IORM	T1, DEVMOD(F)	;MARK IT ASSIGNED-BY-CONSOLE

    ;ATTACH IT

RTATS2:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	;MAKE SURE IT'S NOT IN COMMAND MODE
	MOVSI	T1, TTYATC
	ANDCAM	T1, DEVMOD(F)	;MARK IT AS A NONCOMMAND PORT
	PUSHJ	P, COMATT	;JOIN F AND U
	PFALL	RTFIN
    ;DETACH THE SOURCE END

RTFIN:	HLRZ	J, P1		;J/ SOURCE FRAME #
	HRRZ	F, P2		;F/ SOURCE DDB
	HLLZS	DDBLDB(F)	;DETACH SOURCE
	HRRZS	DEVNAM(F)	;MAKE IT LOOK DETACHED
	MOVSI	T1, TTYATC
	TDNN	T1, DEVMOD(F)	;WAS SOURCE A COMMAND OR A SLAVE PORT?
	 JRST	RTFIN1		;(AUX/SLAVE)

    ;HERE WHEN WE'VE DETACHED SOURCE'S COMMAND PORT

	TLNN	P2, RT.SIG	;IF WE'RE SIGNALLING A HANGUP,
	 JRST	IPOPJ1
	PUSHJ	P, HNGTTY	;  FORCE A DETACHED-JOB HANGUP
				; J has job #
	JRST	IPOPJ1

    ;HERE WHEN WE'VE DETACHED AN AUX/SLAVE PORT

RTFIN1:	TLNN	P2, RT.SIG	;IF WE'RE SIGNALLING A HANGUP,
	 JRST	RTFIN2
	LDB	T1, DDPTZP
	PUSHJ	P, TAKTRJ	;  CAUSE A ZAPPED INTERRUPT
RTFIN2:	MOVEI	T2, ASSCON
	PUSHJ	P, RELEA6	;TRY TO FREE THE DDB
	JRST	IPOPJ1
	
    ;ERROR-RETURNS

RTERJ:	POP	P, J		;RESTORE J
RTERR:	UMOVEM	T1, (M)		;STORE ERROR CODE
	POPJ	P,
SUBTTL	COMATT - PERFORMS THE FUNCTIONS COMMON TO ALL ATTACH FUNCTIONS:
;	     LINKS LDBDDB(U) AND DDBLDB(F)
;	     SETS NEED-OUTPUT BIT OF LDB SO ATTACHEE WILL BE AWAKENED
;	     SETS NON-DEVIOS LDB DEVICE CHARACTERISTIC BITS
;	     CALLS UUOLDB TO SET DEVIOS DEVICE CHARACTERISTIC BITS
;	   F/ DDB ADDR  U/ LDB ADDR
;	   DESTROYS T1-T4

COMATT:	TRNE	F, -1
	TRNN	U, -1
	 STOPCD 		;MUST HAVE A DDB AND AN LDB
	HRRM	U, DDBLDB(F)
	HRRM	F, LDBDDB(U)	;DO THE ATTACH
	MOVEI	T1, 1
	DPB	T1, LDBOPB(U)	;SET NEED-OUTPUT
	LDB	T1, DDPIMB
	DPB	T1, LDPIMB	;SET IMAGE-MODE BREAK CHARACTER
	MOVE	T3, DDBDCH(F)
	MOVE	T1, LDBBYT(U)
	TLNN	T3, DCLNTB	;NO HT/VT/FF ECHO
	TLZA	T1, L2LNTB
	TLO	T1, L2LNTB
	MOVEM	T1, LDBBYT(U)
	MOVEI	T1, L2LTBK	;TABS-AS-BREAKS
	TLNE	T3, DCLTBK
	HRLI	T1, L2LTBK
	PUSHJ	P, SETTBK
	MOVEI	T1, L2LBBP	;BACKSPACE-AS-NONBREAK
	TLNE	T3, DCLBBP
	HRLI	T1, L2LBBP
	PUSHJ	P, SETTBK
	MOVE	S, DEVIOS(F)
	PJRST	UUOLDB		;SET DEVIOS-DEPENDENT LDB BITS
SUBTTL	ROUTINE TO FIND A FREE TTY DEVICE DATA BLOCK

;CALL FROM CLOCK LEVEL TO DO AN ATTACH ON A NEW JOB, OR
;FROM UUO LEVEL ON AN INIT OF A NEW LINE.

;CALL:	NO ARGUMENTS
;	PUSHJ P,DDBSRC
;	  ERROR RETURN		;NONE AVAILABLE. F=0. T1 CLOBBERED
;	OK RETURN		;ADDRESS IN F, TTYUSE SET IN DEVMOD
;				;RESPECTS J,U,CH.
;				;IF YOU DECIDE NOT TO USE F, YOU BETTER
;				;FREE IT UP AGAIN.

DDBSRC:	MOVE T1,TTYFLK	;WHERE TO LINK IN
DDBSR1:	HRRZ F,FRETTY	;HERE IF TO LINK AT SPECIAL SPOT WITH T1 SET
	JUMPE F,CPOPJ		;NO DDB'S AVAILABLE
	HLRZ F,DEVSER(F)	;GET NEXT FREE
	EXCH F,FRETTY		;RESTORE F AND UPDATE FREE LIST
	PUSH P,DEVSER(T1)
	HRLM F,DEVSER(T1)	;LINK INTO DDB CHAIN
	HRLM T1,DDBBLK(F)	;PUT IN THE BACK LINK
	POP P,T1
	HLLM T1,DEVSER(F)	;NOW LINK IT IN
	MOVSS T1
	PUSH P,T3
	MOVE T3,DEVMOD(T1)	;IS THE NEXT ONE DOWN
	TLNE T3,DVTTY		;ALSO A TTY?
	HRLM F,DDBBLK(T1)	;YES, RESET ITS BACK LINK
	POP P,T3
	MOVE T1,[XWD TTYATC,ASSCON+ASSPRG]
	ANDCAM T1,DEVMOD(F)	;TURN OFF USE BITS
	SETZM DEVLOG(F)		;NO LOGICAL NAME

ZZ0==0
REPEAT <TRPLEN+5>/6,<
	SETZM	DDBTRP+ZZ0(F)
ZZ0==ZZ0+1>

	MOVSI T1,IOFST
	DPB T1,PJOBN		;SET JOB TO 0 (GO FOR IT, BILL!)
	MOVEM T1,DEVIOS(F)
	SETZM	DDBDCH(F)	;CLEAR NONDEVIOS DEVICE CHARACTERISTICS
	JRST CPOPJ1
SUBTTL	TTYNFR - CALLED WITH J/ FRAME # TO ALLOCATE A NEW
;	   (DETACHED) TTY DDB FOR THE FRAME AND STORE A
;	   POINTER TO IT IN TTYTAB(J)
;	   (DEVNAM WILL BE 0,,SIXBIT /TTY/)
;	   NONSKIP-RETURNS IF NO DDB FREECORE, OTHERWISE SKIP-RETURNS

TTYNFR::PUSHJ	P, TTYSRC	;IF IT ALREADY HAS A COMMAND PORT DDB,
	  PUSHJ	P, DDBSRC	;OR THERE'S NO ROOM TO ALLOCATE ONE,
	    POPJ P,		;  ERROR-RETURN
	HLLZS	DDBLDB(F)	;MAKE SURE IT KNOWS IT'S DETACHED
	MOVEI	T1, (SIXBIT /TTY/)
	MOVEM	T1, DEVNAM(F)	;SET ITS NAME
	MOVE	T1, [TTYATC,,ASSCON]
	IORM	T1, DEVMOD(F)	;MARK IT AS A COMMAND PORT
	DPB	J, PJOBN	;SET ITS OWNER
	HRRZM	F, TTYTAB(J)
	JRST	CPOPJ1
SUBTTL	SCNNAM - SET DEVNAM(F) TO "TTYNNN" WHERE NNN IS
;	   LDPLNO (FETCHED THROUGH U) IN OCTAL
;	   BREAKS T1 T3

SCNNAM:	LDB T1,LDPLNO
	DPB T1,PUNIT
	MOVSI T3,(SIXBIT /TTY/)
	MOVEM T3,DEVNAM(F)
	MOVE T3,[POINT 6,DEVNAM(F),17]
	PUSH P,T2		;SCNNMR CLOBBERS THIS ONE
	PUSHJ P,SCNNMR		;RADIX PRINT TO CORE
	POP P,T2
	POPJ P,

;NAMSCN - CALLED WITH F/ TTY DDB
;	   RETURNS WITH T1/ PORT# FROM RH(DEVNAM)

NAMSCN:	PUSH	P, T2
	SETZ	T1,
	HRLZ	T2, DEVNAM(F)
NAMSC1:	CAML	T2, [200000,,000000]
	CAMLE	T2, [272727,,000000]
	JRST	NAMSC2
	LSH	T2, 3
	LSHC	T1, 3
	JRST	NAMSC1
NAMSC2:	POP	P, T2
	POPJ	P,
SUBTTL TRAP CODE

;CHECK FOR CHARACTER TRAP

CHRTRP:	TLNE U,LDLCOM
	POPJ P,		;NEVER AT COMMAND MODE
	MOVEI T1,LXRCHR
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ	;NO TRAP IF NO DDB
	LDB T1,DDPTCH
	MOVEI T2,FLGCHR	;AND SET THE FLAG IN CASE OLD TYPE
	PJRST TAKOTJ

;NOW FOR A LINE TRAP

LINTRP:	HRRZ F,LDBDDB(U)	;NEVER CALLED AT COMMAND LEVEL
	JUMPE F,CPOPJ
	MOVEI T1,LXRBRK
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	PUSH P,T2	;MUST PRESERVE T2
	LDB T1,DDPTLN
	MOVEI T2,FLGLIN
	PUSHJ P,TAKOTJ
	POP P,T2
	POPJ P,
SUBTTL	CALLED ON AN ESCAPE TO SEE IF WE SHOULD SET TRAP

ESCTRP:	TLNE U,LDLCOM
	POPJ P,		;NEVER IN COMMAND MODE
	MOVEI T1,LXRESC
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ
	PUSH P,T1		;JUST LIKE CODE ABOVE
	LDB T1,DDPTSC
	MOVSI T2,FLGESC
	PUSHJ P,TAKNZJ		;TAKE THIS TRAP IF REALLY ENABLED
	 JRST TPOPJ		;NOT ENABLED
	POP P,T1		;ENABLED
	JRST TPOPJ		;RETURN UP A LEVEL TO IGNORE CHR

;CALLED FROM TYI WHEN AN ESCAPE IS READ TO CHECK ABOUT TRAPPING

ESCTR1:	PUSH P,T1		;FOUND ESCAPE READING CHRS
	MOVEI T1,LXRESC
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	LDB T1,DDPTSC
	MOVSI T2,FLGESC
	PUSHJ P,TAKNZJ		;TRY THE TRAP
	 JRST TPOPJ	;NOT ENEABLED
	JRST ABTUUO		;ABORT THE UUO. IF ALREADY IN
			;HIGHER TRAP WE WILL JUST DO THE INPUT
			;AGAIN

;CALLED WHEN AN ORANGE BALL IS RECEIVED TO CHECK ON TRAPS

OBREC:	MOVEI	T1, LXROBS
	IORM	T1, LDBDCX(U)	; SET "ORANGE BALL SEEN" BIT
	HRRZ F,LDBDDB(U)	;GOT AN ORANGE BALL. DDB THERE?
	JUMPE F,CPOPJ		;NO
	LDB T1,DDPTOB		;GET THE CHANNEL NUMBER
	JRST TAKNZJ		;AND SET UP TO TRAP
SUBTTL	ROUTINE TO TAKE A JOB OUT OF TIOW FOR A TRAP

TTYWAK::PUSH P,F
	PUSH P,S
	PUSHJ P,FRSTTY	;FIND THE FIRST TTY FOR THIS JOB
	 JRST TTYWK1	;NONE THERE, MUST NOT RALLY BE IN IOW
TTYWK2:	MOVE S,DEVIOS(F)
	PUSHJ P,TIWAKE	;WAKE HIM UP IF IN IOW
	PUSH P,U
	HRRZ U,DDBLDB(F)
	JUMPE U,TTYWK3	;NOT ATTACHED, NOTHING WE CAN DO
	MOVSI S,L2LOEX	;SET EXTENDED OUTPUT BUFFER ING SO
	IORM S,LDBBYT(U)	;JOB CAN FINISH UUO
TTYWK3:	POP P,U
	PUSHJ P,NXTTTY
	 SKIPA		;NEXT TTY NOT THERE
	JRST TTYWK2	;TRY THE NEXT ONE
TTYWK1:	POP P,S		;FINISHED
	POP P,F
	POPJ P,
SUBTTL	ROUTINES TO FIND A JOB'S TTY DDBS

FRSTTY:	HRRZ F,TTYTAB(J)	;FIRST ONE SHOULD BE THE CONTROLING TTY
	SKIPA
NXTTTY:	HLRZ F,DEVSER(F)	;IF WANT THE NEXT, FOLLOW CHAIN
	JUMPE F,CPOPJ		;DONE
	MOVE S,DEVMOD(F)
	TLNN S,DVTTY!DVRMT	;IS IT STILL A TTY OR RMT
	POPJ P,			;NO
	LDB S,PJOBN
	CAMN S,J		;FOR THIS JOB?
	AOS (P)		;YES, SKIP RETURN
	POPJ P,			;NO, FOUND THEM ALL
SUBTTL	ROUTINE TO CLEAR SLEEP CONDITIONS FOR ALL TTYS

TTSCLR::PUSH	P,F
	PUSH	P,S
	MOVEI	T2,0
	LDB	S,JBYWAK##	;GET WAKE CHANNEL
	CAIN	S,^D36		;HIBER CODE?
	 DPB	T2,JBYWAK##	;YES, CLEAR IT
	LDB	S,JBYEXC##	;GET EXIT IN CHILD CHANNEL
	CAIN	S,^D36		;HIBER CODE?
	 DPB	T2,JBYEXC##	;YES, CLEAR IT
	PUSHJ	P,FRSTTY
	  JRST	TTYWK1		;ALL DONE, (NO TTYS)
TTSCL2:	MOVSI	S,DVRMT
	TDNE	S,DEVMOD(F)
	 JRST	TTSCL3		;DO NOT CLEAR FOR RMTS
	LDB	S,DDPTCH
	CAIN	S,^D36		;IS THIS A SLEEP CODE?
	 DPB	T2,DDPTCH	;YES, CLEAR IT
	LDB	S,DDPTLN
	CAIN	S,^D36
	 DPB	T2,DDPTLN	;NOW FOR LINE
	PUSH	P,U
	HRRZ	U,DDBLDB(F)	;GET LINK TO LDB
	JUMPE	U,TTSCL1	;NONE THERE, FINISHED THIS TTY
	LDB	S,DDPTOB	;WAITING FOR ORANGE BALL
	CAIN	S,^D36
	 DPB	T2,DDPTOB	;CCLEAR SLEEP
	LDB	S,DDPTLN	;LINE
	CAIN	S,^D36
	 DPB	T2,DDPTLN
	LDB	S,DDPTCH	;CHARACTER
	CAIN	S,^D36
	 DPB	T2,DDPTCH
TTSCL1:	POP	P,U
TTSCL3:	PUSHJ	P,NXTTTY
	  JRST	TTYWK1		;FINISHED, GET F AND S BACK AND GO
	JRST	TTSCL2		;MORE TO CLEAR
SUBTTL	ROUTINE TO CLEAR ALL TRAP CONDITIONS FOR ALL TTYS

TTTCLR::PUSH P,F
	PUSH P,S
	PUSHJ P,FRSTTY
	 JRST TTYWK1	;NO MORE TTYS THERE
TTTCL1:
;*;	MOVSI S,DVRMT
;*;	TDNE S,DEVMOD(F)
;*;	 JRST	[PUSHJ P,RMTRSI	;RESET FOR REMOTE
;*;		JRST TTTCL2]

ZZ0==0
REPEAT <TRPLEN+5>/6,<
	SETZM	DDBTRP+ZZ0(F)
ZZ0==ZZ0+1>

TTTCL2:	PUSHJ P,NXTTTY		;FIND THE NEXT ONE FOR THIS JOB
	 JRST TTYWK1		;DONE
	JRST TTTCL1		;CLEAR IT ALSO
SUBTTL	THIS ROUTINE ASSIGNES TRAP CHANNELS TO TTY TRAP CONDS
;CALLED WITH T3 CHANNEL NUMBER
;	T2 TRAP NUMBER
;	F TTY DDB
;	SKIP RETURN IF TRAP CONDITION NOW SATISFIED

TINAS1::LDB T1,DDPTAB(T2)	;GET CURRENT
	CAILE T3,^D35		;REAL INTERRUPT CHANNEL?
	 JUMPN T1,CPOPJ		;NO, SLEEP. DON'T CLEAR IF INT. THERE
	DPB T3,DDPTAB(T2)	;SET TRAP CONDITION IN DDB
	JUMPE T3,CPOPJ		;IF ENABLING, NOT DISABLING,
	HRRZ U, DDBLDB(F)	;  GET LDB IF THERE IS ONE
	XCT INTSET(T2)		;  AND CHECK IF IT'S ALREADY TRUE
	POPJ P,			;IN CASE WE DO NOT TRANSFER

;INTERRUPT TEST TABLE - MUST BE IN THE SAME ORDER AS DDPTAB

INTSET:	POPJ P,		;ESCAPE, WILL GET IT LATER
	JUMPN U,CHKCHR	;IF LINE PRESENT, CHECK FOR CHARACTERS
	JUMPN U,CKLNTR	;IF LINE PRESENT, CHECK FOR BREAKS
	POPJ P,		;IOW, NEVER PRESET
	POPJ P,		;FINISH IO
	JRST CHKLOS	;LOST CHARACTERS
	POPJ P,		;ORANGE BALL, NEVER KNOW
	POPJ P,		;CIRCUIT ZAPPED
	JUMPN U,CHKPSP	;IF LINE PRESENT, CHECK FOR UNREAD PORT-STATUS
	JUMPN U,CHKYEL	;YELLOW BALL, PERHAPS ONE IS PENDING
	POPJ P,		;CHARACTER GOBBLER, NOT BUFFERED
	JUMPN U,CHKTCC	;IF LINE PRESENT, CHECK FOR CHANGED TC'S
SUBTTL	ROUTINES TO CHECK IF TRAP CONDITION ALREADY SATISFIED

; CHECK IF CHARACTERS LOST (BY READING IO.BKT)

CHKLOS:	MOVE S,DEVIOS(F)
	TRNE S,IOBKTL
	AOS (P)		;BIT ALREADY SET CAN TRAP NOW
	POPJ P,

; CHECK IF CHARACTERS PRESENT (BY READING LDB COUNTS)

CHKCHR:	HLL U,LDBDCH(U)
	TLNE U,LDLCOM
	POPJ P,		;NOT SAT AT INTERRUPT LEVEL
	SKIPG LDBECC(U)	;CHRS TO BE ECHOED
	SKIPLE LDBTIC(U)	;OR ALREDY ECHOED
	AOS (P)		;YES
	POPJ P,

; CHECK IF A BREAK CHARACTER IS PRESENT (BY READING LDB COUNTS)

CKLNTR:	HLL U,LDBDCH(U)
	TLNE U,LDLCOM
	 POPJ P,
	MOVE T1,LDBTIC(U)
	ADD T1,LDBECC(U)	;ENOUGH?
	CAIL T1,TIWKC
	 JRST CPOPJ1		;YES
	TLNE U,LDLBK2	;WHICH BREAK SET
	 SKIPG LDBBK2(U)
	SKIPLE LDBBKC(U)	;TEST CORRECT ONE(S)
	 AOS (P)
	POPJ P,

; CHECK IF A PORT STATUS MESSAGE IS WAITING TO BE READ
;See comment at ACPSM

CHKPSP:	MOVSI	T1, LMLPSP
	TLNE	T1, LDBMOD(U)	; IS THERE A MESSAGE WAITING?
	 AOS	(P)		; YES
	POPJ	P,

; CHECK IF ANY TERMINAL CHARACTERISTICS HAVE CHANGED

CHKTCC:	HLL	U, LDBDCH(U)
	TDNN	U, LDLPTY	;IF IT'S NOT A PTY,
	 POPJ	P,		;  OF COURSE NOT
	PUSH	P, U
	PUSHJ	P, PTYBUD
	SKIPE	LDBTCB(U)	;ANY UNREAD CHANGES?
	AOS	-1(P)		;(YES)
	POP	P, U
	POPJ	P,


; Test for Yellow ball interrupt condition satisfied:
;   Skip return if a Yellow ball has been received and no Orange ball
;   has yet been sent.  If an Orange ball is waiting to be output, it
;   must be due to a Yellow ball being received while the interrupt
;   was not enabled.  If the interrupt was enabled, the user will have
;   already taken the trap.

CHKYEL:	LDB	T1,LOPSOG	;is OB waiting to be output?
	TRZN	T1,1		;if so, recall it...
	 POPJ	P,
	DPB	T1,LOPSOG	;its now the user's responsibility
	MOVSI	T1,LXLOOK	
	IORM	T1,LDBDCX(U)	;okay for user to send an orange ball
	AOS	(P)		
	POPJ	P,

SUBTTL	SEND A YELLOW BALL

TTYYLS::HRRZ	U, DDBLDB(F)
	JUMPE	U, CPOPJ
	PUSH	P, T1		;SAVE T1
	MOVEI	T1, 1
	DPB	T1, LOPSYL	;SET SEND-YELLOW
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	JRST	TPOPJ		;RESTORE T1 AND RETURN

SETFIO:	MOVSI S,TINFIO
	IORB S,DEVIOS(F)	;SET A FLAG SO WE KNOW WE TRAPPED
				;INSTEAD OF GOING INTO IOW
	POPJ P,
SUBTTL	FNDPRT - CALLED WITH J/ JOB #, F/ -1 OR PORT #
;	   LOOKS FOR A DDB FOR THAT PORT/JOB (-1 IS CMND PORT)
;	   NONSKIP-RETURNS IF THERE IS NONE
;	   SKIP-RETURNS WITH F/ DDB ADDR IF THERE IS

FNDPRT::JUMPL	F,[HRRZ F,TTYTAB(J)	;COMMAND PORT
		   JRST FNDPT1]
	CAIL	F,PORTN##
	 POPJ	P,		;MUST NOT BE THERE
	MOVE	F,LINTAB(F)
	HRRZ	F,LDBDDB(F)
FNDPT1:	JUMPE	F,CPOPJ		;NO DDB ATTACHED
	PUSH	P,T1
	LDB	T1,PJOBN
	CAME	T1,J		;THIS JOB?
	 JRST	TPOPJ		;NO
	JRST	TPOPJ1		;YES
SUBTTL	TINASS UUO - ASSIGN TTY INTERRUPTS
;(MOST OF THE WORK IS DONE IN TINAS1)

TINASS::LDB T3,[POINT 9,T1,17]	;GET THE CHANNEL NUMBER
	CAIG T3,^D35
	SKIPGE JBTPIP(J)	;IF TOO LARGE OR NO INTADR
	POPJ P,			;TAKE ERROR RETURR
	HRRZ F,TTYTAB(J)
	HRRZ F,DDBLDB(F)
	JUMPE F,TINDET		;DETACHED, OK
	MOVSI T2,LLLZAP
	TDNE T2,LDBLOG(F)
	 POPJ P,		;CAN NOT SET IF WAITING FOR LOGUT
TINDET:	HRRE F,T1
	PUSHJ P,FNDPRT
	 POPJ P,		;BAD PORT NUMBER
	LDB T2,[POINT 9,T1,8]	;GET INTERRUPT NUMBER
	CAIL T2,TRPLEN		;TOO LARGE?
	POPJ P,		;YES
	PUSHJ P,TINAS1		;GO ASSIGN
	 JRST STOTC1		;GOT IT, GIVE BACK OLD
	PUSH P,T1		;CONDITION SAT, SAVE OLD CHANNEL
	MOVE T1,T3
	PUSHJ P,TAKTRP	;TAKE THE TRAP
	POP P,T1
	JRST STOTC1		;AND RETURN THE ANSWER
SUBTTL	INITIALIZE
;INITIALIZE THE WORLD. THIS ROUTINE DOES NOT MAKE PROPER
;PROVISION FOR 140 RESTART SINCE THAT ABILITY IS NO LONGER
;OF ANY IMPORTANCE

;Beware, this routine (between TTYINI and TTIEND) is overwritten by
;hackers to patch running monitors on the assumption that the
;code is never reentered after system initialization.  Beware
;if this ever changes!  The CONFIG gettab points to TTYINI as
;the dynamic patch area.
PATCH2=:TTYINI+1	;Make it obvious

TTYINI::SETZM	INTERM
	SETZM	BPREQ		;INITIALLY NO BLOCK PORTS
	SETZM	OPRTIM		;START WITH NO ALARM FLAGS SET
	SETOM	THSTIM##	;TIMER FLAGS
	SETZM	MXTIM##
	MOVEI	T1,CCTYI
	MOVEM	T1,.CPTIA##	;SET UP COMMAND READ AND WRITE
	MOVEI	T1,CCTYO
	MOVEM	T1,.CPTOA##
	MOVE	P1,[POINT 1,LINFLG]	;READY TO SET BYTE PTRS
	MOVSI	P2,NMXLIN##-1	;NOW ALL LINES
TTINI2:	HRRZ	U,LINTAB(P2)	;POINT TO LDB
	MOVSI	T1,LDICLR(U)	;CLEAR IT OUT
	HRRI	T1,LDICLR+1(U)
	SETZM	LDICLR(U)
	BLT	T1,LDICLE(U)
	DPB	P2,LDPLNO	;RESTORE LINE NUMBER
	IBP	P1		;TO POINT TO NEXT BIT
	MOVEM	P1,LDBOPB(U)
	SETZM	(P1)		;MAKE SURE FLAG WORD IS 0
	MOVE	T3,LINTAB(P2)	;CHECK INITIALIZE BITS
	SKIPN	REFLAG		;BUT NOT IF REFRESING
	TLNN	T3,TTVINI
	 JRST	TTINI3		;NOT RUN INITIA
	MOVSI	T1,(STAUTO)
	TDNN	T1,STATES
	 JRST	TTINI3		;DO NOT RUN IF NOT AUTO-RESTART
	MOVE	T1,[LLLNLN,,LDLCOM]
	HLLZM	T1,LDBLOG(U)	;MARK IN (BUT UNKNOWN TO TYMNET)
	HRLZM	T1,LDBDCH(U)	;SET LOGGED IN AND COMMAND MODE
	MOVE	T1,SYSNUM##	;Our host number
	DPB	T1,LDPHST	; for job running INITIA (DSKCLN)
	MOVEI	T1,1
	DPB	T1,LOPHSH	;SET HUSH BIT TO SUPRESS OUT MESSAGES
	SETZM	LDBDCX(U)	;NO EXTENDED BITS ON
	PUSHJ	P,SETLMD
	PUSHJ	P,FRMASN##	;Assign a Job/frame slot
	 STOPCD			;Strictly Fatal
;;***NOTE*** Can't call TTYATI here since it calls DDBSRC, which
;;***NOTE*** uses TTYFLK, which points at DEVLST-DEVSER.  This
;;***NOTE*** in turn means that DEVLST gets smashed when DDB is
;;***NOTE*** allocated, thus causing TTYINI to get called twice.
;;***NOTE*** Go please the world.
	MOVEI	T1,TTYLST	;Start DDB search from here
	PUSHJ	P,DDBSR1	;Get a TTY DDB
	 STOPCD 		;No errors allowed here
	PUSHJ	P,[PUSH P,U
		   JRST TTYAT1]	;IT'S NOT SUCH A BAD HACK...
	 STOPCD 		;Last chance for fatal error...
	MOVEI T1,CMFCXI##	;Forced command index for INITIA
IFKMC<
	SKIPGE KMCDO##		;GREATER OR EQUAL 0 NOT KMC MANUAL MODE
	 MOVEI T1,CMFCKM##	;DO FORCE KMC LOAD
>;END IFKMC
	PUSHJ P,TTFORC

TTINI3:	AOBJN	P2,TTINI2
	SETZM	DEVOPR		;NO OPER YET
	SETZM	OPRLDB		;AND HAS NOLDB
	HRRZ	T1,TTCLST##	;SET UP FREE LIST
	MOVEM	T1,RCC.LO	;Lowest chunk address
	MOVEI	J,TTCHKS(T1)	;SET FREE POINTER TO FIRST
	MOVEM	J,TTFREE##
	HLRZ	T3,TTCLST##	;GET SIZE (number of chunks in list)
	MOVEM	T3,TTFREN
	SOS	TTFREN		;ONE LESS SINCE NO CHUNK 0
	IMULI	T3,TTCHKS
	ADDI	T3,(T1)
	MOVEM	T3,RCC.HI	;One greater than highest chunk address
	SETZM	(T1)		;ZERO OUT FREE LIST
	MOVEI	J,1(T1)		;Build BLT pointer
	HRL	J,T1
	BLT	J,-1(T3)	;ZERO ALL OF IT
	MOVEI	T3,TT2CHK(T1)	;NOW LINK UP
	MOVE	J,TTFREN	;NUMBER TO LINK
TTINI4:	MOVEM	T3,TTCHKS(T1)
	ADDI	T1,TTCHKS	;MOVE FORWARD
	HRLI	T3,(T1)		;SET BACK LINK
	HRRI	T3,TT2CHK(T1)	;AND FORWARD
	SOJG	J,TTINI4	;STORE IF NOT DONE
	HLLZS	(T1)		;ZERO FORWARD LINK OF LAST ONE
	POPJ	P,

TTIEND=:.-1  ;end of area used for dynamic patches, see comment at TTYINI:

IFCPU(F3),<
;ROUTINE TO RESYNC WITH NEXILIS BASE.
; CALLED FROM AT SYSTEM STARTUP AND WHEN BASE CRASHES.

INTEGER	MWAIT,MZEROS

OPDEF TNCONO [744000,,0]
OPDEF TNOUT [745000,,0]
OPDEF TNIN [746000,,0]

	NZEROS==300		;Number of zeroes to send to PDP-11
	NWAIT==^D60*^D24	;Number of clock ticks max per zero


FNSYNC:	SKIPE	CTYDO##		;If using CTYSIM instead of TYMNET,
	 JRST	CPOPJ1		; say all done
	SKIPG	MZEROS		;Waiting for acceptance?
	 JRST	FNSYN0		; No, try this again -- reset
	TNIN	T1		;Yes, read something
	TLNE	T1,(1B5)	;Skip if not accepted
	 JRST	FNSYN2		; Got a zero, go decrement counter
	SOSLE	MWAIT		;Are we waiting for acceptance?
	 POPJ	P,		;Yes, so wait another tick
FNSYN0:	TNCONO	0		;Reset the interface.
				;Turn off input and output to the 11-base
	MOVEI	T1,NZEROS	;Set number of zeroes to TRY to send.
	MOVEM	T1,MZEROS	;Store in counter field
FNSYN1:	TNOUT	0		;Send a zero
	MOVEI	T1,NWAIT	;Get timeout period in clock tics
	MOVEM	T1,MWAIT	; and store in timeout counter
	POPJ	P,		;Return and wait for another tick

FNSYN2:	SOSLE	MZEROS		;Are we waiting for more zeroes?
	 JRST	FNSYN1		;Yes, send one and read it next tick
	TNCONO	1B34!1B35	;No, all here -- turn on PDP-11 interrupts
	SETZM	BASVER##	;Clear base version number
	JRST	CPOPJ1		; and skip return this time.
>;END IFCPU(F3)

SUBTTL	ROUTINES TO LOG IRING AND ORING ACTIVITY

;IRPLOG - routine to keep a log of iring messages
;
;  Assumes P1 and U may be clobbered since they will be
;  reused immediately upon return.  If this changes, the
;  appropriate registers should be saved.

IRPLOG:	MOVE	U,IRING(P4)		; Get IRING message
	AOS	P1,SCNPTR##		; Increment to next position
	ANDI	P1,SCNMSK##		; Keep offset
	JUMPN	P1,IRPLO1		; Not first - just log it
	MOVE	P1,DATE##		; Get current daytime
	MOVEM	P1,SCNUDT##		; And remember...
	SETZ	P1,			; Clear counter
IRPLO1:	MOVEM	U,SCNBUF##(P1)		; Store
	POPJ	P,			; Return

;ORPLOG - routine to keep a log of oring messages
;
;  Assumes P3 already setup containing data to store
;  (If not, ORING(P4) does contain the correct data)

ORPLOG:	PUSH	P,P1			; Save P1
	AOS	P1,SCNPTR##		; Increment to next position
	ANDI	P1,SCNMSK##		; Keep offset
	JUMPN	P1,ORPLO1		; Not first - just log it
	MOVE	P1,DATE##		; Get current daytime
	MOVEM	P1,SCNUDT##		; And remember...
	SETZ	P1,			; Clear counter
ORPLO1:	MOVEM	P3,SCNBUF##(P1)		; Log it
	POP	P,P1			; Restore P1
	POPJ	P,

SUBTTL	 VARIABLES

IFKMC<
BBCNTS:	EXP	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	;16 WORDS
BBPAGE:	EXP	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       	EXP	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	;32 WORDS
TIMMIN:	EXP ^D60
TIMDRD:	EXP ^D60
DRMHSI:	0
DRMSHT:	0
DRMBRK:	0
DRMANS:	0
DRMCLP:	0
DRMTIM::0 ;SECONDS OF UP TIME
DRDOW:	0
SENT41:	EXP 0,0,0,0	;SET ON SENDING 41, RESET ON RECIEVING 3 OR 1
KMCLAS:	0	;LAST KMCGAV,KMCGAC
KMCPDP::	0
KMCFLG::	REPEAT ^D64,<EXP 0>;KMC ACTIVE FLAG HISTORY
IRPMSG::	0
IRPMS2::	0
IRPMS3::	0
IRPMP1::	0
IRPMP2::	0
IRPMP3::	0
IRPMB1::	0
IRPMB2::	0
IRPMB3::	0
	>;END IFKMC
BADGUY:	0	;COUNTER INCREMENTED IN GOHSH:
FSCN:	0
TTFREN:	0	;NUMBER OF FREE CHUNKS LEFT
INPCH:	0
LINPTR:	0	;OUTPUT SCAN POINTER
CHCNT:	0	;# REMAINING CHARS TO OUTPUT AT A TIME ON A PORT
CHQTA:	0	;VALUE THAT CHCNT WAS SET TO AT START OF CYCLE
SVSPC:	0
TTCMCH::0	;HERE IS CHARACTER FOR COMMAND DECODER
TTCMCA::0	;INPUT POINTER FOR COMMAND BEING DECODED

LINPNM:	0	;SAVE LINE NUMBER FROM JFFO
LINFSV:	0	;SAVE FLAG WORD
SVOJFF: 0	;SAVE OUTPUT BIT NO FROM LDBOUT
INTERM::0	;Count of active terminals
OPRTIM::0
FRETTY::0	;POINTER TO FREE TTY DDBS
TTYFLK::0	;POINTER TO WHERE TO LINK IN TTY BLOCKS
CHRRDP:	0	;BYTE POINTER TO INPUT RING FOR CHARACTER INPUT
CHRWRP:	0	;REAL TTY: BYTE POINTER TO OUTPUT RING
	0	;PTY: BYTE POINTER TO PTY BUFFER
MULCNT:	0	;REAL TTYS: # CHARS MORE WILL FIT IN OUTPUT RECORD
	0	;PTYS: # CHARS MORE PTY OUTPUT THIS SECOND
MXMCNT:	0	;REAL TTYS: ORIGINAL VALUE OF MULCNT
TIMOW:	0	;TIMER FOR ORANGE-BALL WAIT ON CIRCUIT ZAPS
ALRSNT:	0
AUXRCP:: -1	;RECEIVED AUX PORT
AUXSTA:	0	;AUX CIRCUIT STATE
AUXSTR::BLOCK AUXSTL	;SPACE FOR STRING
AUXEND:: 0	;Pointer to last word used in AUXSTR
AUXSTP:	0	;STRING POINTER
AUXERR:: 0	;ERROR FROM AUX CIRCUIT BUILD
AUXJOB:	0	;JOB BUILDING AUX CIRCUIT
AUXWSC: 0	;# OF AUX-BUILTS RECEIVED IN WRONG STATE
AUXWPC: 0	;# OF AUX-BUILTS RECEIVED GIVING WRONG PORT
AUXWPT:	-1	;PORT LDB ADDRESS OF THE LAST ONE
NRPCNT: 0	;# TIMES WE GAVE "NO PORT RECEIVED" ERROR
ZRPCNT: 0	;# TIMES WE ZAPPED THE RECEIVED PORT
BIOJOB:	0	;JOB INITIATING BLOCK I/O FOR PORT.
AUXPRT:	0	;PORT BEING BUILT FROM
AUXTIM:	0	;AUX CIRCUIT TIMER
AUXUNM:	BLOCK 2	;SPACE TO BUILD UP A USER NAME
DWNFLG::0	;WANT TO TAKE SYSTEM DOWN
CTYFIL::0	;NUMBER OF FILLS NEEDED BY CTY
CTYFLN:	0	;COUNTER WHEN SENDING FILLS TO CTY
OPRWJB:	0	;JOB WAITING FOR SETUUO OPR MSG
TIWRNN: TILOW	;SMALL QUOTA FOR UNREAD INPUT CHARACTERS (^D80)
		;(BACKPRESSURE WHEN IT'S EXCEEDED)
TIHLTN:		;LARGE QUOTA FOR UNREAD INPUT CHARACTERS
		; MUST BE AT LEAST AS LARGE AS THE MAX NUMBER OF CHARS THE
		; INPUT RING CAN HOLD * 2 + TIWRNN,
		;  OTHERWISE CHARS COULD BE LOST
  IFDEF  SIZIRG, <<1_SIZIRG>*4*2+TILOW> ;^D1104 for normal sized rings
  IFNDEF SIZIRG, <^D512*2+TILOW>
  ;IFNKMC	<^D500>	;LARGE QUOTA FOR UNREAD INPUT CHARACTERS
  ;IFKMC	<^D2000>;(LOSE CHARACTERS WHEN IT'S EXCEEDED)
TTYRHT: 0	;# TIMES MONITOR OUT OF BUFFERLETS AT RCVCHR
		;+ LOSPDP + LOS620
LOSPDP: 0	;# TIMES A PORT EXCEEDED ITS LARGE QUOTA
		;BEFORE WE COULD GET BACKPRESSURE SENT
LOS620: 0	;# TIMES A PORT EXCEEDED ITS LARGE QUOTA
		;AFTER WE HAD SENT BACKPRESSURE
OMX30:	^D120	;TTY OUTPUT HIGH-WATER MARK FOR SLOW DEVICES
OWK30:	^D60	;TTY OUTPUT LOW-WATER MARK FOR SLOW DEVICES
OMX120:	^D480	;TTY OUTPUT HIGH-WATER MARK FOR FAST DEVICES
OWK120:	^D240	;TTY OUTPUT LOW-WATER MARK FOR FAST DEVICES
TOEMAX:	^D500	;EXPANDED-MODE TTY OUTPUT LIMIT
	GTLNK (TTYLOS)	;.LINK for .GTLNK
PTYFLO:	^D1000	;CHARS/SEC TOTAL MAXIMUM PTY FLOW
PTYBUF:	BLOCK	<PTBSIZ+4>/5
PBDISC:	0
DIDPBI:	0
FRSFLG:	0	;FLAG FOR CMDWAK (SO IT'LL KNOW IT'S NOT A REAL CMND)
FRSDEF:	0	;FLAG TO REMEMBER DEFERRED-ECHO STATE
SKPFLG:	0	;SET TO INDICATE INPUT AND SKIP AUXCAL IN PROGRESS

	$END	(SCN)		;End of SCNSER (SCNLIT: SCNEND:)

    #@K