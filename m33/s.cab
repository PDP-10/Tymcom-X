UNIVERSAL S System parameter definitions for PDP-10 Timesharing monitors
SUBTTL	SYSTEM PARAMETER DEFINITIONS/TH/TNM/AF/CHW/RCC/PH  15-OCT-70  V447

;THIS SUB-PROGRAM IS SYSTEM PARAMETER FILE - S.MAC
;THIS FILE IS ASSEMBLED IN FRONT OF EACH SUBPROGRAM IN THE MONITOR

DEFINE	XPP(A,B)		;SYSTEM PARAMETER
<A=:B>
DEFINE XP(A,B)		;NON-PRINTING PARAMETER
<A==:B>
;ACCUMULATOR ASSIGNMENTS
;*** ON JUNE 1,1971 ALL ACCUMULATOR NAMES WERE CHANGED TO REDUCE TO
;*** SIXTEEN NAMES.  THE OLD ASSIGNMENTS WILL BE FOUND AFTER THE
;*** CURRENT ASSIGNMENTS, UNDER REPEAT 0.

;SEE FILSER.FLO FOR SUBROUTINE CALLING CONVENTIONS

;* MEANS LOADED BY UUO HANDLER ON ALL UUOS

XPP S,0		;*I/O DEVICE STATUS WORD (SEE BELOW FOR BITS)
XPP P,1		;*PUSH DOWN POINTER (SEPARATE LIST FOR EACH PI
		; CHANNEL AND EACH USER JOB)
XPP J,2		;BUFFER ITEM COUNT, OR JOB NUMBER
		;IN LEVEL D FILSER ADR OF CONTROLLER DATA BLOCK - ONE PER CONTROLLER
		;IN REMOTE COMMUNICATIONS HANDLER ADR OF STATION DATA BLOCK
XPP PG,3	;THIS DOES REPLACE R. IN GENERAL A PAGE NUMBER
		;UNTIL PAGING IS COMPLETE, PARENTAL GUIDENCE
		;IS SUGGESTED IN USING PG
XPP F,4		;*LH=UUOS DONE SO FAR FOR THIS DEVICE (SEE BELOW)
		; RH=ADDRESS OF DEVICE DATA BLOCK - ONE PER FILE
XPP U,5		;TTY OUTPUT BUFFER POINTER FOR COMMANDS, ERROR
		; MESSAGES, ETC.	;OR TEMPORARY
		;ADDRESS OF 3 WORD BUFFER HEADER IN USER AREA
		;IN LEVEL D FILSER ADR OF UNIT DATA BLOCK - ONE FOR EACH DISK UNIT
		; (POSITIONER) EVEN IF SAME TYPE
		;IN TERMINAL HANDLER ADR OF LINE DATA BLOCK OF THIS TTY
XPP T1,6	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
XPP T2,T1+1	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
		;IN TERMINAL HANDLER CHARACTER ADDRESS IN CHARACTER POOL
XPP T3,T2+1	;TEMPORARY
		;IN TERMINAL HANDLER CHARACTER (SEVEN BIT ASCII)

;ONLY 0 THRU 10 SAVED FOR INTERRUPT SERVICE - LEVEL C AND BEFORE

XPP T4,T3+1	;*ADDRESS OF DEVICE SERVICE ROUTINE'S DISPATCH TABLE

;0 THRU 11 SAVED FOR LEVEL D

XPP W,12	;CONTENTS OF FIRST WORD OF 3 WORD USER BUFFER HEADER
		;*USER I/O CHANNEL NUMBER
XPP M,13	;*CURRENT UUO IN PROGRESS
		; R IN INDEX FIELD FOR RELOCATION
XPP P1,14	;PERMANENT AC'S
XPP P2,P1+1	;
XPP P3,P2+1	;
XPP P4,P3+1	;CONTENTS OF 2ND WORD OF USER BUFFER
;ACCUMULATOR ASSIGNMENTS
REPEAT 0,<
;*** THESE TWO PAGES ARE INCLUDED FOR HISTORICAL REASONS AS
;*** A REFERENCE. NOTE THAT THEY ARE NOT ASSEMBLED.

;* MEANS LOADED BY UUO HANDLER ON ALL UUOS

XP IOS,0	;*I/O DEVICE STATUS WORD (SEE BELOW FOR BITS)
XP TAC,6	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
XP TAC1,7	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
XP PDP,1	;*PUSH DOWN POINTER (SEPARATE LIST FOR EACH PI
		; CHANNEL AND EACH USER JOB)
XP ITEM,2	;BUFFER ITEM COUNT, OR JOB NUMBER
XP DAT,5	;TTY OUTPUT BUFFER POINTER FOR COMMANDS, ERROR
		; MESSAGES, ETC.	;OR TEMPORARY
XP JBUF,DAT	;ADDRESS OF 3 WORD BUFFER HEADER IN USER AREA
XP DEVDAT,4	;*LH=UUOS DONE SO FAR FOR THIS DEVICE (SEE BELOW)
		; RH=ADDRESS OF DEVICE DATA BLOCK
XP PROG,3	;*LH=HIGHEST RELATIVE LOCATION IN USER AREA
		; RH=ABSOLUTE ADDRESS OF USER AREA
XP JDAT,PROG	;*RH=ADDRESS OF JOB DATA AREA
		; LH=HIGHEST RELATIVE LOCATION IN USER AREA
XP TEM,10	;TEMPORARY USED ONLY IN SCNSER I/O ROUTINE

;ONLY 0 THRU 10 SAVED FOR INTERRUPT SERVICE - LEVEL C AND BEFORE

XP DSER,11	;*ADDRESS OF DEVICE SERVICE ROUTINE'S DISPATCH TABLE

;0 THRU 11 SAVED FOR LEVEL D

XP BUFPNT,12	;CONTENTS OF FIRST WORD OF 3 WORD USER BUFFER HEADER
XP UCHN,BUFPNT	;*USER I/O CHANNEL NUMBER
XP BUFWRD,17	;CONTENTS OF 2ND WORD OF USER BUFFER
XP UUO,13	;*CURRENT UUO IN PROGRESS
		; PROG IN INDEX FIELD FOR RELOCATION
XP AC1,14	;TEMPORARY AC'S (MORE TEMPORARY THAN TAC,TAC1)
XP AC2,15	;
XP AC3,16	;
;ACCUMULATOR ASSIGNMENTS (LEVEL D)
;SEE FILSER.FLO FOR SUBROUTINE CALLING CONVENTIONS

;GLOBAL - INTERRUPT AND UUO LEVELS

XP S,IOS	;DEVICE IO STATUS
XP P,PDP	;PUSH DOWN POINTER
XP K,ITEM	;ADR. OF CONTROLLER DATA BLOCK - ONE FOR EACH CONTROLLER
XP R,PROG	;JOB RELOCATION (RH) PROTECTION(LH)
XP F,DEVDAT	;ADR. OF DEVICE DATA BLOCK - ONE FOR EACH FILE - USER PAIR
XP U,DAT	;ADR. OF UNIT DAT BLOCK - ONE FOR EACH DISK UNIT (POSITIONER)
		;EVEN IF SAME TYPE

;TEMPORARY - INTERRUPT AND UUO LEVELS - NEED NEVER BE PUSHED BEFORE USE

XP T,TAC	;FIRST OF 4 CONSECUTIVE TEMP ACS
XP T1,TAC1	;SECOND OF 4 CONSECUTIVE TEMP ACS
XP T2,TEM	;THIRD OF 4 CONSECUTIVE TEMP ACS
XP T3,DSER	;FOURTH OF 4 CONSECUTIVE TEMP ACS

;GLOBAL - UUO LEVEL ONLY

XP UCHN,UCHN	;
XP UUO,UUO	;

;PRESERVED - INTERRUPT AND UUO LEVELS - MUST BE PUSHED BEFORE BEING USED

XP P1,AC1	;4 CONSECUTIVE ACS
XP P2,AC2	;
XP P3,AC3	;
XP P4,BUFWRD	;

;DEFINITIONS FOR TERMINAL HANDLERS - SCNSER,BTHINT(ETC),COMCON,ERRCON,ONCE

XP LINE,U	;ADDRESS OF LINE DATA BLOCK OF THIS TTY
XP CH,TEM	;CHARACTER (SEVEN BIT ASCII)
XP CA,T1	;CHARACTER ADDRESS IN CHARACTER POOL

>	;::: END OF REPEAT 0
; DEVICE DATA BLOCK NAMES
	XP DEVNAM,0		;NAME IN SIXBIT ASCII
				; C(LH)=DEVICE MNEMONIC
				; C(RH)=DEVICE NUMBER, LEFT JUSTIFIED
	XP DEVCHR,1		;CHARACTERISTIC
				; BITS 0-6=JOB NUMBER (BYTE POINTER=PJOBN)
				; ZERO VALUE IMPLIES NOT ASSIGNED
				;BITS 12-16=HUNG DEVICE COUNT. SET WHEN
				; DEVICE BECOMES ACTIVE. DECREMENTED EVERY SECOND.
	XP HUNGST,400		;BITS 7-9 ARE A CODE FOR HUNG DEVICE
				; TIMEOUT. 0 MEANS DEVICE CANNOT BE HUNG
				; 1-7 MEANS HUNG TIME IS 2**N-1 SECONDS
				; POINTER = PDVTIM
				;BITS 10-16 ARE THE COUNTDOWN TIMER
				; FOR HUNG DEVICE. POINTER = PDVCNT
				; TRANSITION TO ZERO MEANS DEVICE HUNG
				; BITS 17-23=DEVICE NUMBER, BINARY (BYTE PNTR=PUNIT)
				; BITS 24-35=BUFFER SIZE
	XP DEVIOS,2		;STATUS WORD.  SEE BELOW
	XP DEVSER,3		;C(LH)=NEXT DEVICE DATA BLOCK
				; C(RH)=DEVICE SERVICE DISPATCH TABLE
;  DEVICE SERVICE DISPATCH TABLE ASSIGNMENTS
	XP DDO,-2	;DUMP OUTPUT
	XP DDI,-1	;DUMP INPUT
	XP DDXZ,0	;SIZE OF DISPATCH TABLE FOR CHANIO
	XP DDINT,1	;INTERUPT SETUP
	XP DBYT,2	;BYTE SIZES FOR IMAGE,IMAGE BINARY
	XP DVSIZ,3	;BUFFER SIZES
	XP DINI,4	;INITIALIZE
	XP DHNG,5	;HUNG DEVICE
	XP DRL,6	;RELEASE
	XP DCL,7	;CLOSE
	XP DCLO,DCL	;CLOSE OUPTU=CLOSE
	;IMMEDIATE ADDRESS PART OF CLOSE UUO
		XP CLSOUT,1	;INHIBIT CLOSING OUTPUT
		XP CLSIN,2	;INHIBIT CLOSING INPUT
		XP CLSDLL,4	;INHIBIT DEALLOCATION ON CLOSE OUTPUT
		XP CLSACC,10	;INHIBIT UPDATE OF ACCESS DATE ON READS (AND BAT BLOCK ON ERR)
		XP CLSNMB,20	;INHIBIT DELETING NMB ON CLOSE WITH ONLY LOOKUP
		XP CLSRST,40		;RESET (INHIBIT SUPERSEDE/CREATE)
		XP CLSDAT,100		;DELETE ACCESS TABLE ON CLOSE
		XP CLSDMP,100000	;SET DUMPED BIT
	XP DOU,10	;OUTPUT
	XP DIN,11	;INPUT
	XP DXFR,12	;TRANSFER ROUTINE
	XP DZAP,DXFR	;ZAP ROUTINE
	XP DGTRD,13	;GET READY (WAIT NOW)
	XP DMT,14	;MTAPE
	XP DGF,15	;UGETF
	XP DEN,16	;ENTER
	XP DLK,17	;LOOKUP	
	XP DRN,20	;RENAME
	XP DSI,21	;USETI
	XP DSO,22	;USETO
	XP DCLI,23	;CLOSE INPUT
	XP DUFD,24	;DISK UFD
	XP DSEK,25	;SEEK
	XP DVMAP,26	;MAP.
	XP DFDEL,27	;FILE PAGE DELETE.
	XP DFCRE,30	;FILE PAGE CREATE.
	XP DFEXC,31	;FILE PAGES EXCHANGE.
	XP DSIM,32	;SIMULTANEOUS UPDATE (DISK ONLY)
	XP DFVLR,33	;VALIDATE A FILE'S RIBS.
	XP DVSMAP,34	;SUPER MAP.
	XP DFFIF,35	;FIND INTERESTING RETRIEVAL PNTR.
	XP DFTRN,36	;TRUNCATE FILE WITHIN LAST PAGE.
	XP DMOVPG,37	;MAKE VP MAPPABLE FROM FILE
	XP DEVMOD,4		;BIT 35-J=1 IF MODE J IS LEGAL FOR THIS DEVICE
				; BIT 18 DEVICE ASSIGNED BY CONSOLE COMMAND
				; BIT 19 DEVICE ASSIGNED BY PROGRAM (INIT)

;RIGHT HALF OF DEVICE CHARACTERISTICS WORD (DEVCHR UUO)
	XP ASSCON,400000	;ASSIGNED BY CONSOLE COMMAND ASSIGN
	XP ASSPRG,200000	;ASSIGNED BY PROGRAM (INIT UUO)
;LEFT HALF DEVICE CHARACTERISTICS (DEVCHR UUO)
	XP DVOUT,1		;OUTPUT DEVICE
	XP DVIN,2		;INPUT DEVICE
	XP DVDIR,4		;HAS A DIRECTORY
	XP DVTTY,10		;IS A TTY
	XP DVMTA,20		;IS A MAG TAPE (REWIND)
	XP DVAVAL,40		;1 IF DEVICE IS AVAILABLE TO THIS JOB
				; SET BY DEVCHR UUO
	XP DVDTA,100		;IT IS A DECTAPE
	XP DVPTR,200		;IS A PAPER TAPE READER
	XP DVPTP,400		;IS A PAPER TAPE PUNCH
				; (OTHER UUOS BESIDES INPUT,OUTPUT,CLOSE,RELEASE)
	XP DVDIS,2000		;IS A DISPLAY
	XP DVRMT,4000		;DEVICE IS A REMOTE TERMINAL
	XP DVNZP,10000	;DO NOT ZAP ON RESET (DVRMT OR DVTTY)
	XP TTYATC,20000		;TTY IS CONTROLING TTY FOR JOB
	XP DVLPT,40000		;IS A LPT (CARRIAGE CONTROL IN FORTRAN)
	XP DVCDR,100000		;IS A CARD READER (TRAILING SPACES FOR MACRO)
	XP DVDSK,200000		;IS A DISK
	XP DVDIRIN,400000	;DECTAPE DIRECTORY IN CORE IF 1 (MUST BE SIGN BIT)

	XP DEVLOG,5		;LOGICAL NAME FOR JOB DEVICE
	XP DEVBUF,6		;C(LH)=REL. ADDRESS OF 3 WORD OUTPUT BUFFER HEADER
				; C(RH)=REL. ADDRESS OF 3 WORD INPUT BUFFER HEADER
	XP DEVIAD,7		;C(LH)=PROG IN INDEX FIELD
				;BITS 1 AND 2 CONTAIN THE COUNT OF NUMBER OF USER
				; CHANNELS INIT'ED ON THIS DEVICE (DECTAPE ONLY)
				; IADPTR-COMMON BYTE POINTER TO 2 BIT COUNT
				;C(RH)=RELATIVE ADDRESS OF INPUT BUFFER THE
				; SERVICE ROUTINE IS FILLING.
	XP DEVADR,DEVIAD
	XP DEVOAD,10		;C(LH)=PROG IN INDEX FIELD
				;C(RH)=RELATIVE ADDRESS OF OUTPUT BUFFER THE
				; SERVICE ROUTINE IS EMPTYING.
	XP DEVPTR,DEVOAD
	XP DEVCLS,11		;CLASS AND BUFFER POINTER
	XP DEVSTS,12		;WORD FOR DEVICE CONI
	XP DEVPWC,13		;PARTIAL WORD COUNT
	XP DEVWUC,14		;ACTIVE PARTIAL WORD COUNT

LENFXL=^D35		;LENGTH OF FIXED LIST AREA IN DSK AND MTA DDBS

	XP DEVABC,13		;ADVANCE BUFFER COUNT (DSK,MTA)
	XP DEVBWC,14		;BUFFR WORD COUNT (DSK,MTA)
	XP DEVCTR,15
	XP DEVINT,16
;FOR LONG DISPATCH TABLE DEVICES ONLY:
	XP DEVFIL,15		;FILE NAME IN SIXBIT
	XP DEVEXT,16		;LH=EXTENSION, RH=UNUSED
	XP DEVPPN,17		;PROJECT,PROGRAMMER NUMBER (DISK ONLY)
				; OTHER DEVICES NEED NOT HAVE THIS LOCATION IN THEM.
; I/O STATUS WORD ASSIGNMENTS
;DATA MODES: BITS 32-35 (BYTE POINTER=PIOMOD)
	XP A,0			;ASCII
	XP AL,1			;ASCII LINE
	XP XA,2			;EXTENDED ASCII
	XP I,10			;IMAGE
	XP IB,13		;IMAGE BINARY
	XP B,14			;BINARY
	XP SD,15		;SCOPE DUMP MODE
	XP DR,16		;DUMP BY RECORDS
	XP D,17			;DUMP ACROSS RECORDS
; STATUS BITS
;RIGHT HALF (USER)
	XP IOWC,20		;DON'T COMPUTE WORD COUNT
	XP IOCON,40		;CONTINUOUS (CONT=0)
	XP IONRCK,100		;READ WITH NO REREAD CHECK
	XP IONDX,200		;READ INDEX BLOCKS.
;BITS 27,28	DENSITY OF MAG TAPE
;		00=INSTALLATION STANDARD
;		01=200 BPI
;		10=556 BPI
;		11=800 BPI
	XP IOPAR,1000		;WRITE EVEN PARITY (BCD) IF 1 ON MAG TAPE
	XP IOTEND,2000		;END OF MAG TAPE
	XP IOBOT,4000		;BEGINNING OF MAG TAPE
	XP IOACT,10000		;DEVICE ACTIVE
	XP IODEND,20000		;DATA END ENCOUNTERED
	XP IOBKTL,40000		;BLOCK TOO LARGE
	XP IODTER,100000	;DATA ERROR-IE HARDWARE OR SOFTWARE PARITY AND/OR CHECKSUM
				; INDICATES DATA MAY BE BAD
	XP IODERR,200000	;DEVICE ERROR-IE THE DEVICE IS BAD
				; THE DATA IS PROBABLY INTACT ON THE MEDIUM
				; IF READING (USUAL)
				; THE DATA IS PROBABLY INCORRECTLY WRITTEN
				; ON THE MEDIUM
				;  IF WRITING (UNUSUAL)
	XP IOIMPM,400000	;IMPROPER MODE DETECTED BY UUOCON OR DEVICE
				; SERVICE ROUTINE
; LEFT HALF (SYSTEM)
	XP IOW,1		;I/O WAIT
	XP IOBEG,2		;VIRGIN DEVICE
	XP IOFST,4		;NEXT ITEM WILL BE THE FIRST ITEM OF A BUFFER
	XP IOSTBL,10		;RECOVERABLE DEVICE ERROR FLAG
	XP IO,20		;OUT=1, IN=0
	XP IOEND,40		;SERVICE ROUTINE HAS TRANSMITTED LAST DATA
	XP IOHNG,100		;DEVCHK SETS, WSYNC SEES AND CALLS ERRCON.

;DEVICE DEPENDENT BITS ARE ALLOCATED FROM BIT 0 TO HIGHER BIT NUMBERS.

;COMMAND DECODER USE OF AC IOS:

;RH=DISPATCH ADDRESS - SAVJOB,GETJOB,RUNJOB
;LH:
	XP NSRBIT,400000	;HIGH SEG TO BE FLAGGED NON-SHARABLE (SAVE VS SSAVE
				; COMMAND) DO NOT CONFUSE WITH SIGN BIT OF JBTSTS
				; WHICH SAYS SEG IS SHARABLE

;SPECIAL BITS FOR PHYSICAL ONLY CODE

	XP UPHNLY,200000	;IN CALLI'S
	XP PHONLY,400000	;IN W FOR UUOS
;LEFT HALF USRJDA (JOB DEVICE ASSIGNMENTS) UUO'S FOR THIS CHANNEL SINCE LAST INIT
;SET IN LH OF DEVDAT AT BEGINNING OF UUO,STORED IN MEMORY(USRJDA) IF UUO IS SUCCESSFUL
	XP	INITB,400000		;INIT-SAVEGET DEPENDS ON THIS BEING SIGN BIT
	XP IBUFB,200000		;INIT WITH INPUT BUFFER SPECIFIED
	XP OBUFB,100000		;INIT WITH OUTPUT BUFFER SPECIFIED
	XP LOOKB,40000		;LOOKUP
	XP ENTRB,20000		;ENTER
	XP INPB,10000		;INPUT
	XP OUTPB,4000		;OUTPUT
	XP ICLOSB,2000		;INPUT CLOSE
	XP OCLOSB,1000		;OUTPUT CLOSE
	XP INBFB,400		;INBUF
	XP OUTBFB,200		;OUTBUF
	XP SYSDEV,100		;THIS DEVICE IS SYSTEM TAPE
				; PROJ.PROG. NO 1,1 ON DSK
	XP RENMB,40		;RENAME UUO IN PROGRESS (NEVER STORED IN MEMORY)
	XP DSKRLB,20		;TO DISTINGUISH RELEASE FROM RESET UUO IN DSKSER.
				; RELEASE CLEARS THEM ALL - LEVEL C
	XP RESETB,20		;RESET UUO IN PROGRESS - LEVEL D (NEVER STORED IN MEMORY)
	XP GETB,10		;GET IN PROGRESS USE EX PROT INSTEAD OF RD
	XP MAPB,4		;

;MTAPE UUO BITS
	XP SLICE,40		;SET SLICE LEVEL IF A 1 ACCORDING TO SLEVEL
	XP SLEVEL,20		;VALUE OF SLICE LEVEL IF SLICE A 1
;MACROS TO MOVE DATA BETWEEN THE USER AND THE OPERATING SYSTEM.

DEFINE UHRRZ (A,B)
	<XCTBU	<HRRZ A,B>>

DEFINE UHRLZ(A,B)
	<XCTBU	<HRLZ A,B>>

DEFINE UHLLZ(A,B)
	<XCTBU	<HLLZ A,B>>

DEFINE UHLRZ(A,B)
	<XCTBU	<HLRZ A,B>>

;CONDITIONAL ASSEMBLY CONTROL FOR DIFFERENT PROCESSORS

CPUKI==1		;FOR KI10
CPUKL==2		;FOR KL10
CPUKS==3		;FOR KS10
CPUF3==4		;FOR FOONLY

DEFINE IFCPU(CP)<
CPZZ==0
IRP CP,<
IFE CPUTYP-CPU'CP,<CPZZ==1>
>;END IRP
REPEAT CPZZ>

DEFINE IFNCPU(CP)<
CPZZ==1
IRP CP,<
IFE CPUTYP-CPU'CP,<CPZZ==0>
>;END IRP
REPEAT CPZZ>

DEFINE CPUSYM<
IFCPU (F3),<SEARCH F3SYM>
IFCPU (KI),<SEARCH KISYM>
IFCPU (KL),<SEARCH KLSYM>
IFCPU (KS),<SEARCH KSSYM>
>

;ERROR CODES RETURNED TO USERS ON LOOKUP AND ENTER AND RENAME FAILURES  (DISK ONLY)
; IN RH OF 2ND WORD OF 4 WORD ARGUMENT BLOCK
;THE SAME ERROR CODES ARE RETURNED ON RUN AND GETSEG UUOS FOR ALL DEVICES

	XP FNFERR,0	;FILE NOT FOUND OR 0 FILE NAME
	XP IPPERR,1	;INCORRECT PROJECT,PROGRAMMER NUMBERS
	XP PRTERR,2	;PROTECTION FAILURE (OR DIRECTORY FULL ON DTA)
	XP FBMERR,3	;FILE BEING MODIFIED
	XP AEFERR,4	;ALREADY EXISTING FILE (OR RENAME) OR DIFFERENT FILE NAME ON UPDATE ENTER
	XP ISUERR,5	;ILLEGAL SEQUENCING OF UUOS
			; (RENAME WITHOUT LOOKUP OR ENTER; LOOKUP AFTER ENTER)
	XP TRNERR,6	;TRANSMISSION ERROR OR BAD UFD
	XP NSFERR,7	;NOT A SAVE FILE (RUN,GETSEG UUO ONLY)
	XP NECERR,10	;NOT ENOUGH CORE (RUN,GETSEG UUO ONLY)
	XP DNAERR,11	;DEVICE NOT AVAILABLE (RUN,GETSEG UUO ONLY)
	XP NSDERR,12	;NO SUCH DEVICE (RUN,GETSEG UUO ONLY)
	XP ILUERR,13	;ILLEGAL UUO (GETSEG ONLY) NOT TWO RELOC REG. CAPABILITY

;MORE LOOKUP/ENTER/RENAME ERROR CODES

	XP NRMERR,14	;NO ROOM ON THIS FILE STRUCTURE ON ENTER OR ALLOCATION
			; OR USER QUOTA EXCEEDED(OVERDRAW DOES NOT COUNT ON ENTER)
	XP WLKERR,15	;WRITE LOCK ERROR - CAN'T WRITE
			; ON FILE STRUCTURE. EITHER HARDWARE
			; OR SOFTWARE WRITE PROTECTED.
	XP NETERR,16	;NOT ENOUGH MONITOR TABLE SPACE
	XP PAOERR,17	;PARTIAL ALLOCATION ONLY
	XP BNFERR,20	;BLOCK NOT FREE ERROR ON ALLOCATION WHERE STARTING
			; LOGICAL BLOCK NUMBER OF FILE STRUCUTRE SPECIFIED.
	XP NTRERR,21	;PRIVS WILL NOT ALLOW BUT OP COMPLETED
	XP LKMERR,22	;MULTIPLE LOOKUP ERROR, TOO MANY SPEC
; JOB BUFFER AREA HEADER
	XP JBFADR,0		;BIT 0=1 IF THIS BUFFER RING HAS NEVER BEEN
				; REFERENCED FROM THE USER'S PROGRAM BY
				; AN INPUT OR OUTPUT COMMAND.
				; BITS 1-17=UNUSED
				; BITS 18-35=CURRENT BUFFER ADDRESS
	XP JBFPTR,1		;BYTE POINTER TO NEXT BYTE -1
	XP JBFCTR,2		;POSITIVE ITEM COUNT
; JOB BUFFER HEADER
	XP IOUSE,400000		;1 IF BUFFER IS FULL (OR BEING EMPTIED)
				; 0 IF BUFFER IS EMPTY (OR BEING FILLED)
				; BITS 1-17=BUFFER SIZE
				; BITS 18-35=NEXT BUFFER ADDRESS
	XP IOADVB,200000	;1 IF BUFFER HAS ALREADY BEEN
				;ADVANCED. CAN HAPPEN IF INTERUPT
				;FROM MIDDLE OF I/O. BIT IS IN
				;BUFFER HEADER
;SYMBOLS FOR MAKING PARTS OF WORDS BE A CONSTANT OF ZERO
; SO THAT FUTURE PROGRAMMERS WILL KNOW THAT THAT BYTE MUST BE ZERO.

	XP ZERO36,0	;36 BITS OF ALWAYS ZERO
	XP ZERO18,0	;18 BITS (LH OR RH DEPENDING ON WHICH FIELD OF XWD.
	XP ZERO13,0	;INDIRECT BIT
	XP ZERO5,0	;5 BITS (USUALLY LH BITS 13 THRU 17, I.E., @ AND INDEX FIELD
			; OF POINTERS WHICH WANT TO BE REFERENCED USING INDIRECTION

	XP UUNNAM,0
	XP UUNEXT,1
	XP UUNATT,2
	XP UUNPPN,3
	XP UUXNUM,0
	XP UUXPPN,1
	XP UUXNAM,2
	XP UUXEXT,3
	XP UUXPRV,4
	XP UUXSIZ,5
	XP UUXVER,6
	XP UUXFUT,7
	XP UUXEST,10
	XP UUXALC,11
	XP UUXPOS,12
	XP UUXFT1,13
	XP UUXLCW,14
	XP UUXMTA,15
	XP UUXDEV,16
	XP UUXSTS,17
	XP UUXELB,20
	XP UUXEUN,21
	XP UUXQTF,22
	XP UUXQTO,23
	XP UUXMXA,24
	XP UUXUSD,25
	XP UUXAUT,26
	XP UUXUNM,27
	XP UUXUN1,30
	XP UUXTRU,31
	XP UUXXT2,32
	XP UUXALP,33
	XP UUXSNM,34
	XP UUXPJC,35
	XP UUXPJ1,36
	XP UUXPJ2,37
	XP UUXPID,40
	XP UUXENT,UUXPID	;LAST ARG OR VALUE FOR EXTENDED UUOS

OPDEF PJRST [JRST]	;PJRST IS USED IN PLACE OF THE LAST PAIR OF
		; INSTRUCTIONS IN A SUBROUTINE WHEN THEY ARE PUSHJ
		; FOLLOWED BY A POPJ.  PJRST IS USED INSTEAD OF JRST, SO
		; THAT SOMEONE READING THE CODE WILL INDERSTAND THAT A
		; SUBROUTINE IS BEING CALLED.

OPDEF PJSP	[JSP]	;PJSP IS USED IN PLACE OF MOVEI .+2, PJRST SUB
OPDEF PJUMPL	[JUMPL]
OPDEF PJUMPLE	[JUMPLE]
OPDEF PJUMPE	[JUMPE]
OPDEF PJUMPG	[JUMPG]
OPDEF PJUMPGE	[JUMPGE]
OPDEF PJUMPN	[JUMPN]

XP DC.SIZ,3	;; BECAUSE THERE IS NO BETTER WAY NEEDED by COMMON/ONCDSK

repeat 0,<
DEFINE STOPCD (A) <sall
IFB <A> <IF2,<IFNDEF SYSCRS,<EXTERNAL SYSCRS>>
	JSR	SYSCRS>
IFIDN <A> <SLO> <IF2,<IFNDEF SLOCRS,<EXTERNAL SLOCRS>>
	JSR	SLOCRS>

IFIDN <A> <NO> <IF2,<IFNDEF NOCRS,<EXTERNAL NOCRS>>
	JSR	NOCRS>	;;DON'T RUN DSKCLN
IFNB <A> <IFDIF <A> <SLO> <IFDIF <A> <NO> <IF2,<IFNDEF SYSCRS,<EXTERNAL SYSCRS>>
JSR SYSCRS>>>
>
>  ;end of repeat 0

SUBTTL	SYSTEM MACROS -- STOPCD

;Macro to generate code for fatal error conditions
;Call with:
;	STOPCD	(CONT,TYPE,NAME,TYPOUT,<Description>)
;Where
;CONT = The continue address for HALT, DEBUG, INFO, and EVENT stopcodes.
;	May be ".", ".+1", ".+2", "CPOPJ", etc.
;TYPE = The type of error.  One of the following:
;	HALT   - Generate a "JRST 4," instruction (for recursion in DIE routine)
;	STOP   - Stop the system, dump and reload Monitor
;	JOB    - Stop one job, snapshot dump and continue
;	DEBUG  - Snapshot dump and continue
;	CPU    - Output CPU hardware status, stop system (unless SMP)
;	INFO   - Output message to CTY, continue with no dump
;	EVENT  - Output message with no bells (such as "NODE BACK ON LINE")
;	DSKCLN - Reload the monitor and do a full D to rebuild the SATs
;	XCT    - Generate XCT NAME where NAME has already been defined.
;NAME = Six letter name, defaults to S$NAME='?STOP?' if not specified.
;	If nonblank, it will be used as global label and must be unique.
;TYPOUT = Optional routine to call to output more info after ACs are restored.
;	This can be 36-bit quantity, the LH is copied to LH of .CPCPC .
;DESC = Description of stopcode (currently not used, should be in <>).

;Define the various stopcode action types
	S$XCT==:  -1	;Generate XCT NAME for previously defined stopcode
	S$HALT==:  0	;Halt CPU (no output, no dump, no reload)
	S$STOP==:  1	;RELOAD (output DDB, dump, reload system)
	S$JOB==:   2	;ZAPJOB (output DDB, snapshot dump, stop job, continue)
	S$DEBUG==: 3	;BUGCHK (output DDB, snapshot dump, continue)
	S$CPU==:   4	;CPUSTP (output CPU status, dump, reload)
	S$INFO==:  5	;INFSTP (output stopcode name, call TYPOUT, no dump)
	S$EVENT==: 6	;INFSTP (output message only, no dump, no bells)
	S$DSKCLN==:7	;DSKSTP (same as S$STOP but with full DSKCLN)
	S$NAME==SIXBIT /?STOP?/	;Default SIXBIT name output by DIE routine

;IF2,<PRINTX [Need to change STOPCD definition when all sources are updated]>
;Change "TYPE<STOP>" to just "TYPE", and move "NAME::" out of IFNB conditional

DEFINE	STOPCD(CONT<0>,TYPE<STOP>,NAME,TYPOUT,TEXT),<
IFNDEF S$'TYPE,<STOPI>	;Cause MACRO to output "Error in macro at LABEL:+offset"
		    S$TEMP==-1
IFIDN <CONT>,<.>,  <S$TEMP==0>;;	;Same as ".+1"
IFIDN <CONT>,<.+1>,<S$TEMP==0>;;	;Resume at saved PC  (nonskip return)
IFIDN <CONT>,<.+2>,<S$TEMP==1>;;	;Resume at saved PC + 1 (skip return)
IFIDN <CONT>,<SLO>,<S$TEMP==2>;;	;Resume at SLOCRS+1
IFIDN <CONT>,<NO>, <S$TEMP==3>;;	;Resume at NOCRS+1
     IFL   S$TEMP, <S$TEMP==CONT	;Continuation address >
     IFNB <TYPOUT>,<S$TEMP==S$TEMP+1B0>
		    S$TEMP==S$TEMP+<S$'TYPE>B17 ;;Stopcode type in LH
IFE S$'TYPE,<
NAME::	JRST	4,CONT		;**** NAME stop "TEXT" ****>
IFL S$'TYPE,< XCT NAME ;"TEXT" >
IFG S$'TYPE,<	IF2,<IFNDEF DIE,<EXTERN DIE>>
IFNB <NAME>,<NAME::	;Global label for this stopcode>
	XCT	[PUSHJ	P,DIE	;**** NAME stop "TEXT" ****
IFNB <NAME>,<	SIXBIT /NAME/;>S$NAME;;Use S$NAME if NAME is blank
		 S$TEMP		;<Flag+S$'TYPE>,,<CONT>
		 TYPOUT	]	;Optional RH is routine to call, LH for data >
>  ;End of STOPCD definition
SUBTTL	Bits in DEBUGF - Debugging flags

DF.SBD==1B0		;SYSTEM BEING DEBUGGED
DF.RDC==1B1		;RELOAD ON DEBUG STOPCD'S
DF.RJE==1B2		;RELOAD ON JOB ERRORS
DF.NAR==1B3		;NO AUTO RELOADS
DF.CP1==1B4		;STOP SYSTEM ON CPU STOPCD ON ANY CPU
DF.DDC==1B5		;DON'T DO CONTINUABLE STOPCD DUMP ON DEBUG STOPCDS
DF.DJE==1B6		;DON'T DO CONTINUABLE STOPCD DUMP ON JOB STOPCDS
DF.DCP==1B7		;DON'T DO CONTINUABLE STOPCD DUMP ON CPU STOPCDS
DF.RQC==1B8		;CALL CRSCPY ON NEXT CLOCK TICK ON BOOT CPU
DF.RQK==1B9		;CALL KDPLDR ON NEXT CLOCK TICK
DF.WFL==1B10		;COPY OUTPUT TO FRCLIN TO SYSTEM CTY
DF.DCC==1B11		;DISABLE NEXT CRSCPY REQUEST
DF.RIP==1B12		;RELOAD IN PROGRESS (RECON. FUNCTION .RCRLD)
       ;1B13-1B17 not used
DF.BP0==1B18		;CAN ENTER EDDT ON CPU0 USING XCT .C0DDT
DF.BP1==1B19		;CAN ENTER EDDT ON CPU1 USING XCT .C1DDT
DF.BP2==1B20		;CAN ENTER EDDT ON CPU2 USING XCT .C2DDT
DF.BP3==1B21		;CAN ENTER EDDT ON CPU3 USING XCT .C3DDT
DF.BP4==1B22		;CAN ENTER EDDT ON CPU4 USING XCT .C4DDT
DF.BP5==1B23		;CAN ENTER EDDT ON CPU5 USING XCT .C5DDT
DF.BPT==DF.BP0!DF.BP1!DF.BP2!DF.BP3!DF.BP4!DF.BP5 ;MASK OF CPU BPT BITS
       ;1B24-1B35 not used
SUBTTL	Common PI system defintions
;Extracted from S.MAC for 7.02

  ;PI CONI bits for KA,KI,KL,KS,F3
PI.PR1==1B11		;Program PI request for channel 1
PI.PR2==1B12
PI.PR3==1B13
PI.PR4==1B14
PI.PR5==1B15
PI.PR6==1B16
PI.PR7==1B17
;1B18-1B20 are different for each CPU
PI.IP1==1B21		;Interrupt in Progress on channel 1
PI.IP2==1B22
PI.IP3==1B23
PI.IP4==1B24
PI.IP5==1B25
PI.IP6==1B26
PI.IP7==1B27
PI.IPA==PI.IP1+PI.IP2+PI.IP3+PI.IP4+PI.IP5+PI.IP6+PI.IP7 ;INTERRUPTING PROG ON ALL
PI.PIA==1B28		;PI system is active
PI.CO1==1B29		;Channel on 1 (this channel is enabled)
PI.CO2==1B30
PI.CO3==1B31
PI.CO4==1B32
PI.CO5==1B33
PI.CO6==1B34
PI.CO7==1B35

  ;PI CONO bits for KA,KI,KL,KS,F3
PI.CPP==1B22		;Clear program PI request on specified channels
PI.CPI==1B23		;Clear PI system
PI.IIO==1B24		;Initiate interrupt on specified channels
PI.TNP==1B25		;Turn on specified channels
PI.TFP==1B26		;Turn off specified channels
PI.OFF==1B27		;Turn off interrupt system
PI.ON==1B28		;Turn on interrupt system
PI.SC1==1B29		;Select channel 1
PI.SC2==1B30
PI.SC3==1B31
PI.SC4==1B32
PI.SC5==1B33
PI.SC6==1B34
PI.SC7==1B35

;CPU TYPE CODES (RH OF .CPTYP)(LH FOR CUSTOMERS)
CT.P6==1		;PDP-6 TYPE PROCESSOR
CT.KA==2		;KA-10 TYPE PROCESSOR
CT.KI==3		;KI-10 TYPE PROCESSOR
CT.KL==4		;KL-10 TYPE PROCESSOR
CT.KS==5		;KS-10 TYPE PROCESSOR
CT.KC==6		;KC-10 type processor
CT.F3==7	;Foonly F3

;Macro to prevent interrupts from other CPUs
DEFINE	SYSPIF,<;;Disable APR timer and console PDP-11 interrupts
	CONO	PI,PI.OFF	;PUSHJ P,LOKSPI for SMP>

;MACRO to reenable interrupts from other CPUs
DEFINE	SYSPIN(A)<;;Optionally start a program-requested interrupt
	CONO	PI,PI.ON+A	;PUSHJ P,UNLSPI or UNLSPT for SMP>

;MACRO to prevent interrupts from devices (leave APR timer enabled)
DEFINE	PIOFF<IF2,<IFNDEF SYSOFF,<EXTERN SYSOFF>>
	CONO	PI,SYSOFF	;PUSHJ P,LOKDPI for SMP>

;MACRO to reenable interrupts from devices
DEFINE PION<IF2,<IFNDEF SYSON,<EXTERN SYSON>>
	CONO	PI,SYSON	;PUSHJ P,UNLDPI for SMP>

;MACRO to prevent interrupts for bit diddlers (SETOS,CLRBTS)
DEFINE	BTSOFF,<;;Disable interrupts from devices or APR timer
	CONO	PI,PI.OFF	;PUSHJ P,LOKBTI for SMP>

;MACRO to reenable interrupts for bit diddlers
DEFINE	BTSON,<;;Enable previously enabled interrupts
	CONO	PI,PI.ON	;PUSHJ P,UNLBTI for SMP>
;JOB STATUS WORD (JBTSTS TABLE), ONE WORD FOR EACH JOB

	XP RUN,400000		;USER WANTS JOB TO RUN (MUST BE SIGN BIT)
	XP CMWB,200000		;JOB TYPED A COMMAND WHICH NEEDS CORE
				; WHICH IS ON DISK.  SET BY COMMAND DECODER
				; CLEARED WHEN JOB IN CORE AGAIN.
	XP MRQ,100000		;1) JOB HAS PAGE FAULTED AND NEEDS
				; THE SWAPPER TO SWAP SOMETHING IN
				; 2) SWAPPER HAS STOLEN PAGES FROM
				; JOB AND TAKEN AWAY CONTEXT PGES AS WELL
	XP JNA,40000		;THIS JOB NUMBER IS ASSIGNED (JOB INITIALIZED)
	XP JERR,20000		;A MONITOR DETECTED ERROR HAS OCCURRED
				; JOB CAN NOT CONTINUE
	XP CNTRLC,400		;^C WAS TYPED WHILE JOB WAS IN MONITOR MODE
				; AND NOT IN TTY WAIT - DELAY STOPPING JOB
	;BITS 10-14 USED TO INDICATE JOB IN WAIT FOR A SHARABLE DEVICE
	;0 MEANS JOB NOT WAITING FOR SHARABLE DEVICE
	;SEE SCHEDULER (CLKCSS) FOR DEFINITION OF WAIT CODES

	XP JWSIZ,5		;SIZE OF WAIT CODE
	XP JWPOS,^D14		;RIGHT MOST BIT POS. OF WAIT CODE
	XP WTMASK,370		;MASK FOR CLEARING WAIT CODES

	XP JLOG,4		;JOB SUCCESSFULLY LOGGED IN
	XP JRQ,2		;JOB HAS CHANGED STATE AND MUST BE REQUEUED AT CLOCK
				; LEVEL BEFORE RESCHEDULING CAN TAKE PLACE
	XP JACCT,1		;PRIVILEGED SYSTEM CUSP IS BEING RUN WHICH CANNOT
				; BE STOPPED (E.G., LOGIN
				; OR LOGOUT).  PROTECT IT FROM CURIOUS EYES.
				; DISABLE CONTROL C, MADE IT ACT LIKE ALT-MODE

;BITS IN RIGHT HALF OF JBTSTS

	XP JWSADJ, 400000	;1 TO DO MWS ADJUSTMENT FOR JOB --
				;SET/CLEARED BY RESET ACCORDING TO
				;ADJMWS, CLEARED BY WSCTL UUO
	XP WAKFLG,200000	;WAKE UUO PENDING FOR JOB
	XP JACCT2,100000	;LIKE JACCT BUT SETTABLE
	XP UTRP,040000		;TRAP TO USER ON UUO EXIT (REE, DDT)
	XP JDCON,020000		;JOB IN ^C STATE FOR DEVICE
	XP SCHPRV,10000		;PRIVILEGED SCHEDUALING FLAG
	XP PRF,4000		;PRE-REFERENCE REQUEST. SAME AS MRQ
				; IN THAT IT MAKES SWAPPER DO THE JOB,
				; BUT DOESN'T MAKE JOB UNRUNNABLE
	XP SWPINP,2000		;SWAP IN PROGRESS. IN RH BECAUSE JOB
				; IS STILL RUNNABLE IF ITS ON.
	XP SETICP,1000		;SET IF JOB HAS BEEN SCANNED TO BE
				; SWAPPED OUT. CLEARED WHEN ICPT IS
				;RESET.
	XP EXCFLG,400		;EXIT IN CHILD PENDING
	XP KJP, 100		;KJOB PENDING
;MASKS USED TO TEST STATUS CONDITIONS:

	XP RUNABLE,RUN+JNA	;STATUS BIT PATTERN FOR JOB TO BE RUNABLE
	XP RUNMSK,JLOG+JACCT+CNTRLC
				; BITS WHICH DO NOT MATTER FOR RUNABILITY

;BITS IN LH JBTPPN TABLE

	XP JBPWLK,400000	;LEFTMOST BIT OF WRITELOCK FIELD (STR # 0)
	XP JBPNCR,400		;LEFTMOST BIT OF NO-CREATE FIELD (STR # 0)
	XP JBLWLK,1000		;RIGHTMOST BIT OF WRITELOCK FIELD (STR # 8)
	XP JBLNCR,1		;RIGHTMOST BIT OF NO-CREATE FILED (STR # 8)
	XP NCRMSK,777		;ALL NO-CREATE BITS

;PARAMETER FOR TEMPORARY FILE STORAGE UUO FOR SHORT (CCL) FILES THAT LIVE IN CORE...
; DEFINE NUMBER OF DATA WORDS IN EACH BLOCK OF LINKED LIST IN CORE.  ACTUAL
; BLOCK LENGTH IS ONE GREATER TO ACCOMODATE FILE NAME AND CHAIN TO NEXT BLOCK.

XP TMPBL,4

;TELETYPE PARAMETERS....

	XP STTYBF,20		;SIZE OF TTY BUFFER
	XP STTYB1,STTYBF+1	;LENGTH+1
;JOB PRIVILEGE BITS - JBTPRV TABLE
;SET BY LOGINN FROM LUD.SYS FILE AS MODIFIED BY CUSTOMER FOR
; HIS PARTICULAR INSTALLATION

;LH BITS -- MOSTLY DIGITAL STANDARD STUFF

	XP PVLOS, 400000	;LogoutOnStop - must be sign bit
	XP PVNOAT,200000	;DON'T ATTACH ON LOGIN
	XP PVSTIM,6		;BITS IN TIME ZONE FIELD
	XP PVNTIM,7		;LOC OF TIME ZONE FIELD
	XP PVMTIM,176000	;MASK FOR TIME ZONE FILED
	XP PVNMAI,001000	;[dws] (new) mail waiting bit
	XP PVDINA,000400	;DEFAULT INACTIVITY HANG TIMEOUT
	XP PVSCMD,000200	;special command mode
	XP PVSCOR,7		;NUMBER OF BITS IN FIELD FOR CORE
	XP PVNCOR,^D17		;A USER IS ALLOWED TO HAVE
	XP PVMCOR,177		;MASK FOR CORE BITS

;RH BITS -- SOME DIGITAL STANDARD, SOME TYMSHARE-DEFINED

	XP PVEXO,400000		;PROGRAM IS RUN ONLY
	XP PVSHNG,2		;SIZE OF HANGUP/ZAP ACTION FIELD
	XP PVNHNG,^D20		;POS. OF HANGUP/ZAP ACTION FIELD
	XP PVMHNG,300000	;MASK FOR HANG/ZAP ACTION FIELD
	    XP .PVHKJ,0		;0  KJOB ON HANG/ZAP
	    XP .PVHDT,1		;1  DETACH ON HANG/ZAP
	    XP .PVHCN,2		;2  DETACH-CONTINUE ON HANG/ZAP
	    XP .PVHTM,3		;3  DETACH-TIMEOUT-KJOB ON HANG/ZAP
	XP PVTYMP,040000	;TYMSHARE PROPRIETARY
	XP PVACTS,020000	;ACCOUNT SUPERVISOR
	XP PVMAIL,010000	;MAIL WAITING BIT
	XP PVEXOG,004000	;EX ONLY GET IN PROGRESS
	XP PVBUD,002000		;TRU BUDGET BEING USED
	XP PVRCMD,001000	;RESTRICTED COMMAND MODE
	XP PVSMOD,2		;MODE (TYMEX, PDP, ETC.)
	XP PVNMOD,^D28		;POSITION FOR MODE BITS
	XP PVMMOD,000600	;MASK FOR MODE
	XP PVSCRM,7		;SIZE,MAX PERMITTED CORE FIELD
	XP PVNCRM,^D35		;POSITION

;BITS IN JBTWCH    -	WATCH SYSTEM RESPONSE COMMAND
;LH BITS:	(BITS 13-35 = TIME OF DAY IN JIFFIES USER STARTS TO WAIT)
;MUST BE IN FOLLOWING ORDER WITH JBPWDY AS LEFT MOST BIT OF ALL OF THEM
	XP	JBPWDY,200000	;WATCH TIME OF DAY STARTED TO WAIT
	XP	JBPWRN,100000	;WATCH RUN TIME WHEN RETURN TO COMMAND LEVEL
	XP	JBPWWT,40000	;WATCH WAITING TIME RETURN TO COMMAND LEVEL
	XP	JBPWDR,20000	;WATCH NO. 128 WORD DISK BLOCKS READ
	XP	JBPWDW,10000	;WATCH NO. 128 WORD DISK BLOCKS WRITTEN
		;ADD NEW DATA HERE (ALSO INCLUDE IN WCHALL)
	XP	WCHALL,JBPWDY!JBPWRN!JBPWWT!JBPWDR!JBPWDW	;ALL WATCH BITS

;BITS IN JBTCTX - CONTEXT PAGE CONTROL JOB TABLE
; (JBTCTX IS NCTXPG * JOBN WORDS LONG.)
; ALL BITS ARE IN LH.

; BITS APPEARING ONLY IN FIRST JOBN LOCATIONS OF JBTCTX

	XP CTXCIN,400000	;CONTEXT PAGES ARE IN CORE AND ACTIVE
				; IN OWNERS MAP SLOTS (%UPT)
				; (MUST BE SIGN BIT)
	XP CTXCEX,200000	;IF 1, DISK PAGES ARE ALLOCATED.
	XP CTXVIR,100000	;IF 1, DISK PAGES HAVE JUST BEEN
				; ALLOCATED BUT CONTEXT PAGES HAVE
				; NOT BEEN SETUP YET.
	XP JSTCTX,40000		;TELLS SWAPPER TO JUST BRING IN CONTEXT PAGES
	XP CTXSWE,20000		;CONTEXT PAGES HAVE SWAP ERROR.

; BITS APPEARING IN EACH JOBN SIZE BLOCK OF JBTCTX, I.E.
; FOR EACH CONTEXT PAGE

	XP CTXUCU,10000		;1 IF USE COUNT IS INCREMENTED FOR
				; CORE PAGE, BUT CONTEXT PAGES NOT
				; ACTIVE YET.
;LICENSE BITS AND FIELDS AND SO ON (AND ON)

	XP LICWCR,400000	;WRITE CORE
	XP LICSPY,200000	;READ CORE (SPY AND PEEK)
	XP LICOPR,100000	;OPER LICENSE
	XP LICSYS,40000		;SYSTAT GET ARGS FOR OTHER JOBS
	XP LICGDV,20000		;GET DEVICES FROM JOB 0
	XP LICTDV,10000		;TRANSFER (REASSIGN) DEVICES
	XP LICSTR,4000		;FIDDLE WITH STRUCTURES
	XP LICRMT,2000		;REMOTE
	XP LICJAL,1000		;SET JACCT AND JLOG (WRITE UFDS)
	XP LICAC,400		;CREATE SPECIAL AUX. CIRCUITS
	XP LICXC,200		;FIDDLE WITH CHARGES

	XP LICFMK,17		;MASK FOR FILE PRIVS
	XP LICWPS,^D17		;POSITION FOR WRITE PRVS
	XP LICRPS,^D15		;AND FOR READ
	XP LICWFL,2		;WRITE ON DSK (MAYBE S-USETO)
	XP LICWPJ,1		;WRITE IN PROJECT
	XP LICRFL,10		;AND FOR READ
	XP LICRPJ,4

	XP LICUNU,160		;BITS NOT YET USED

;BITS FOR TRAP ENABLE (BY APRENB UUO)

	XP ENBUUO,100000	;TRAP ON UUO EXECUTED
	XP ENBESC,002000	;TRAP ON ESCAPE (OR ^C)
	XP ENBLIN,040000	;TRAP ON BREAK CHARACTER
	XP ENBCHR,004000	;TRAP ON CHR RECIEVED
	XP ENBCLK,1000		;TRAP ON CLOCK TICK
	XP ENBHMS,000040	;TRAP ON HUNG DEV, NO MSG
	XP ENBHNG,000020	;TRAP ON HUNG DEV
	XP ENBRPT,400000	;REPETITIVE ENABLE
	XP ENBOV,1B32		;ENABLE FOR OVERFLOW
	XP ENBFOV,1B29		;ENABLE FOR FLOATING OVERFLOW
	XP ENBMPT,1B22		;ENABLE FOR MEM. PROT (ILL MEM REF
	XP ENBPDL,1B19		;ENABLE FOR PDLOV

;THE BITS REURNED IN JOBCNI FOR THE ABOVE

	XP FLGUUO,400000
	XP FLGESC,000001	;IN LH
	XP FLGLIN,004000
	XP FLGCHR,000400
	XP FLGHNG,000002	;IN LH, HUNG DEV
	XP FLGOV,1B32		;OVERFLOW
	XP FLGFOV,1B29		;FLOATING OVERFLOW
	XP FLGMPT,1B22		;ILL MEM REF
	XP FLGPDL,1B19		;PDL OV

;BITS FOR HIBERNATE UUO

	XP HIBCHR,10		;IN HIBERNATE UUO FOR CHR
	XP HIBLIN,20		;FOR LINE
	XP HIBYLB,40		;HIBERNATE ON YELLOW BALL
	XP HIBPRT,100		;PORT NUMBER PRESENT
	XP HIBWKU,200		;ALLOW WAKE UUO
	XP HIBFEX,400		;ENABLE FOR FRAME EXITS
	XP HINTIM,^D17	;LOCATION OF SEC. MIN, ETC. FIELD
	XP HISTIM,2		;SIZE
	XP HINPRT,^D8	;POSITION OF PORT FIELD
	XP HISPRT,^D9	;SIZE
;VARIOUS ALARM BITS FOR CELL ALR620

XP ALROPR,20	;GIVES REASON 1. NO SET OPR
XP ALRACT,40	;GIVES REASON 2. OPR ACTION NEEDED
XP ALRUSR,100	;GIVES REASON 4. MESSAGE TO DET JOB
XP ALRRMT,200	;GIVES REASON 10. REMOTE PERIPHERAL 620 HAS CRASHED
XP ALRCTY,400	;GIVES REASON 20. MESSAGE OUTPUT ON CTY FOR OPER
XP ALRSCH,1000	;GIVES REASON 40. SYSTEM HAS FINISHED AUTO-RELOAD
XP ALRDEV,2000	;GIVES REASON 100. ERROR FOR DEVICE OPR ACTION NEEDED


;BITS IN THE "STATES" WORD, INDICATE OPERATIONAL STATE OF SYSTEM

XP STAUTO,1B17	;1 IF IN AUTO-RESTART CONDITION
XP STSHUT,1B18	;1 IF SYSTEM SHUT
XP STSUPR,1B19	;1 IF SYSTEM SUPER-SHUT
XP STRLB,1B20	;1 IF RESTRICTED LOGINS. SEE LOGINN,NONRES:-7  AAA
;DEVICE CODES

XP SAX0,274
XP SAX1,400
;FRAME ACCESS RIGHTS DEFINITIONS

COMMENT \
ARGUMENTS TO THE "X" MACRO:
1) USER ACCESS RIGHT NUMBER. ONCE ASSIGNED, MUST NOT CHANGE.
   MUST BE ASSIGNED IN CONSECUTIVE ASCENDING ORDER.
   OPEN MODULE FRMSER AND TYPEOUT VALUE OF .UAMAX
   TO FIND OUT LAST VALUE ASSIGNED.

2) ABBRIEVIATION. USED TO DEFINE SYMBOLS .AR???

3) ACCESS LEVEL: LEGAL VALUES X=EXECUTE ONLY,R=READ ACCESS,
   W=WRITE ACCESS.
   DETERMINES WHAT MINIMUM FILE ACCESS IS NEEDED TO OBTAIN THAT RIGHT.

4) LICENSE. DETERMINES WHAT MINIMUM LICENSE NEEDED TO OBTAIN
   THE RIGHT VIA LICENSE. LEGAL VALUES IN DESCENDING ORDER:
   WC = WRITE CORE, RC = READ CORE,
   SY = SYSTAT (OR MATCHING AUN OR MATCHING GAN AND ACCT SUPER)
   TP = TYMSHARE PROPRIETARY. A LICENSE DESIGNATOR OF A CERTAIN LEVEL
   IMPLIES ALL RIGHTS ASSOCIATED WITH THAT LEVEL AND BELOW.

5) FAST. IF NON-BLANK, THE RIGHT IS A "FAST" ACCESS RIGHT WHICH
   WILL BE KEPT IN CORE. OTHERWISE, THE RIGHT IS "SLOW", AND
   ALL BIT MAPS IT APPEARS IN ARE IN THE CONTEXT PAGES.

THE MONITOR'S ACCESS RIGHT CODE FOR EACH RIGHT IS DETERMINED
BY THE RELATIVE POSITION OF THE PARTICULAR "X" MACRO THAT
DEFINES THE RIGHT, E.G. THE FIFTH RIGHT DEFINED WITHIN
THE ARMAC MACRO IS MONITOR ACCESS RIGHT NUMBER 4, AND
THE .AR??? SYMBOL FOR THAT RIGHT WILL BE DEFINED TO 4.
\

DEFINE ARMAC <
;;MAP MANIPULATION

X (0,RDM,R,RC)	;;RIGHT TO FIND OUT THINGS ABOUT A FRAME'S MAP
		;; (VPGSTS, WSCTL TO READ WS, ETC.)
X (1,CHM,W,WC)	;;RIGHT TO CHANGE MAP (REMOVE, MAP, VCREAT)
		;; (ALSO REPLICATE TO OTHER FRAME)

;;VIRTUAL ADDRESS SPACE DATA MANIPULATION

X (2,RAC,R,RC)	;;READ ACS
X (3,WAC,W,WC)	;;WRITE ACS
X (4,VAR,R,RC)	;;READ VIRTUAL ADDRESS SPACE DATA (REPLICATE READ ONLY, ETC)
X (5,VAW,W,WC)	;;WRITE VIRTUAL ADDRESS SPACE DATA (REPLICATE MAX WRITE, ETC.)
		;;(MUST BE SEPERATE FROM CHANGE MAP BECAUSE TARGET FRAME
		;;MIGHT HAVE FILE ACCESS THAT CALLER DOES NOT).

;;CONTROL

X (6,HLT,W,WC)	;;HALT
X (7,STP,X,WC)	;;STOP (LIKE CONTROL-C, TRAPPABLE BY SUBJECT FRAME)
X (10,HNG,W,WC)	;;HANG
X (11,CLR,X,WC)	;;CLEAR (MUST BE STOPPED FIRST)
X (12,SVA,X,WC,F)	;;START AT ENTRY VECTOR ADDRESS
X (13,SAA,W,WC,F)	;;START ANYWHERE
X (14,RVA,W,WC)	;;RESTART AT ENTRY VECTOR ADDRESS
X (15,RAA,W,WC)	;;RESTART AT ARBITRARY ADDRESS

;;READING FRAME STATUS

X (16,RUN,X,<TP,SY,AUN>,F)	;;READ USERNAME (AND JBTSTS TO SEE IF LOGGED IN)
X (17,RDS,R,<SY,AUN>,F)	;;READ FRAME STATE (PC, HALT BLOCK)
X (20,RAD,R,<SY,AUN>,F)	;;READ ACCOUNTING DATA
X (21,RFI,R,<SY,AUN>,F)	;;READ FRAME INFORMATION (AUN, PPN, UID, ETC.)
X (22,RPI,R,<SY,AUN>,F)	;;READ PROCESS INFORMATION (FPN, PROCESS NAME, PNO)

;ACCESS RIGHTS

X (23,SMF,W,WC)		;;SET MAX FRAME RIGHTS. NEED TO HAVE WRITE ACCESS
			;; TO FILE, OR ELSE CAN OVERRIDE THE FRAME'S OWN SETTING.

;WAKEUP

X (24,WAK,W,WC)		;;DO WAKE UUO FOR FRAME


;TTY ATTACHING AND DETACHING

X (25,ATT,W,<AUN,JL>,F)	;;ATTACH A PORT TO TARGET FRAME IF IT HAS NONE
X (26,DET,X,<WC>,F)	;;TAKE PORT AWAY FROM TARGET FRAME


;GRAFTING

X (27,TKP,W,<WC>,F)	;;TAKE PARENT AWAY FROM A FRAME
X (30,GVP,W,<JL>,F)	;;GIVE PARENT TO A FRAME
			;; (CAN'T BE AUN, OR ELSE USERS COULD GET CONTROL OVER OTHER JOBS WITH SAME USERNAME9
X (31,GVC,W,<WC>,F)	;;GIVE CHILD TO A FRAME.

;License

X (32,PLC,W,<WC>,F)	;;Pass license to a frame

>;END ARMAC MACRO DEFINITION
;MACRO TO CALL A SPECIFIED MACRO FOR EACH FAST ACCESS RIGHT,
; AN EXECUTION MACRO, THE SPECIFIED MACRO FOR
; EACH SLOW ACCESS RIGHT, AND THEN THE EXECUTION MACRO AGAIN.
; USED TO GENERATE TABLES OF ACCESS RIGHTS ACCORDING
; TO THE ARGUMENTS IN THE "X" MACRO IN MACRO DEFINITION
; ARMAC.
DEFINE ARCALL(CALL,DO)<
DEFINE X(NUM,NAM,RWX,LIC,FAST)<
IFNB <FAST> <
'CALL
>;END IFNB FAST
>;END X MACRO DEFINITION

	DO		;;FIRST CALL FOR EACH FAST RIGHT

DEFINE X(NUM,NAM,RWX,LIC,FAST)<
IFB <FAST> <
'CALL
>;END IFNB FAST
>;END X MACRO DEFINITION

	DO		;;NOW CALL FOR SLOW ONES
>;END ARCALL MACRO DEFINITION
;GENERATE DEFINITIONS .AR???, EQUAL TO BIT NUMBER IN MONITOR
; ACCESS BIT MAP. FIRST 36 ARE "FAST" ACCESS RIGHTS, THOSE
; KEPT IN JBT TABLES FOR FAST ACCESS. THOSE ABOVE FIRST
; 36 ARE "SLOW", KEPT IN CONTEXT PAGES.


DEFINE ARDEF(NAME)<XP .AR'NAME,ZZ
ZZ==ZZ+1
>;END ARDEF MACRO DEFINITION
DEFINE ARDO<IFNDEF FARMAX,<ZZ==0>
IFDEF FARMAX,<ZZ==^D36>

ARMAC
IFNDEF FARMAX,<XP FARMAX,ZZ-1>
IFDEF FARMAX,<XP .ARMAX,ZZ-1		;;HIGHEST ACCESS RIGHTS CODE FOR CHECKING BOUNDS
XP FARSIZ,<<FARMAX+1+^D35>/^D36>	;NUMBER OF WORDS IN FAST RIGHTS JBT TABLES
XP .ARSIZ,<<.ARMAX+1+^D35>/^D36>-FARSIZ ;NUMBER OF WORDS FOR SLOW ACCESS RIGHTS BITS
IFN FARSIZ-1,<PRINTX *** TOO MANY FAST ACCESS RIGHTS BITS ***
QQQQQQ>
>;END IFDEF FARMAX
>;END ARDO MACRO DEFINITION

ARCALL(<ARDEF('NAM)>,ARDO)
;FRAME DESCRIPTOR DEFINITIONS

;A FRAME DESCRIPTOR CONSISTS OF AN 18 BIT QUANTITY. 18-20
; ARE THE FRAME DESCRIPTOR TYPE, AND 21-35 ARE THE DATA
; FOR THE TYPE.

;FRAME DESCRIPTOR TYPES
;THE FRAME DESCRIPTOR TYPES FOR OWN FRAME AND ABSOLUTE FRAME
; WERE CHOSEN TO BE 0 AND 7 RESPECTIVELY, TO BE COMPATIBLE WITH
; THE OLD JOB NUMBER CONVENTIONS.

XP FDFMSK,7777		;MASK TO EXTRACT FRAME NUMBER FROM 18 BIT QUANTITY.
XP FDDMSK,77777		;DATA FIELD MASK FOR FRAME DESCRIPTOR.


XP .FDABS,<0*100000>		;ABSOLUTE FRAME NUMBER
XP .FDFAM,<1*100000>		;FAMILY DESCRIPTOR. 21-23 HAVE SUBTYPE
   XP .FMCHL,<0*10000>		  ;CHILD
   XP .FMPAR,<1*10000>		  ;PARENT FRAME.
   XP .FMMAX,<1*10000>		  ;MAXIMUM LEGAL VALUE.

XP .FDOTF,<2*100000>		;OTHER FRAME.
XP .FDFRH,<3*100000>		;FRAME HANDLE
XP .FDSLF,<7*100000>		;OWN FRAME. DATA IS USUALLY 77777.

;DEFINE GLOBAL MACRO HERE TO GENERATE BYTE POINTER TO
; SUB ERROR CODE LOCATION IN VUUOS.

DEFINE FDEERP(LOC)<[POINT 6,'LOC,5]>

;GLOBAL MACROS TO SCAN JBTFTR

DEFINE PRNTBP(AC)<[POINT 12,JBTFTR('AC),11]>
DEFINE NEIGBP(AC)<[POINT 12,JBTFTR('AC),11+12]>
DEFINE CHLDBP(AC)<[POINT 12,JBTFTR('AC),11+2*12]>
;HANDLE DEFINITIONS

;A HANDLE IS A BLOCK OF FREE CORE CONTAINING DATA DESCRIBING
; A FRAME AND WHAT ACCESS RIGHTS THE HOLDER HAS OVER THAT FRAME.

XP .FHFNO,0		;ABSOLUTE FRAME NUMBER THIS HANDLE DESCRIBES
 XP .FHTYP,0		;ANOTHER NAME
    XP FH.TYP,(7B17)	;MASK FOR HANDLE TYPES.
	XP .FHFRM,0	;FRAME HANDLE
	XP .FHPRC,1	;PROCESS HANDLE
	XP .FHLIC,2	;LICENSE HANDLE.
	XP .FHMAX,2 	;MAX VALUE FOR CHECKING.
;	XP .FHCLB,?	;WHEN CLUB HANDLES ARE IMPLEMENTED

    DEFINE HTPPTR(LOC)<POINT 3,'LOC,17> ;GENERATE BYTE POINTER
XP .FHUID,1		;36 BIT UNIVERSAL ID NUMBER
XP .FHPNO,2		;"PROGRAM NUMBER" OF GRANTING PROGRAM.
XP .FHART,3		;ACCESS RIGHTS BITS
XP .FHEND,.FHART+<.ARSIZ+FARSIZ>-1	;LAST WORD IN HANDLE

XP .FHSIZ,.FHEND+1	;SIZE OF A HANDLE.
;UPT AND EPT ASSEMBLY TIME DEFINITIONS

DEFINE MAPALC(NAM,SIZ)
<
IFB <SIZ>,<ZZPAG==ZZPAG-1>
IFNB <SIZ>,<ZZPAG==ZZPAG-<SIZ>>
XP %'NAM'.N,ZZPAG
XP %'NAM',%'NAM'.N_^D9
>;END MAPALC MACRO DEFINITION

;DEFINE CONSTANT UPT ADDRESS SPACE SLOTS
; (HAVE NO LMAP ENTRIES, JUST USED FOR MAPPING BY PCB CODE)

ZZPAG==377+1		;HIGHEST EXEC VIRTUAL ADDRESS IN UPT + 1

MAPALC(SAT)
MAPALC(RIB)
MAPALC(RB2)

XP CNVVPN,1000-340	;ADD THIS TO REAL PAGE NUMBER IN EXEC PER PROCESS
			; SPACE TO GET VIRTUAL PAGE NUMBER

XP VPMAX,CNVVPN+ZZPAG-1	;MAXIMUM NON-SPECIAL UPT VP NUMBER (1000 = 340)

;GENERATE CONSTANT EPT ADDRESS SPACE SLOTS

ZZPAG==777+1		;HIGHEST PAGE DESCRIBED IN EPT + 1

MAPALC(ERR)
MAPALC(SWP)
MAPALC(DRI)		;DR11C BLOCK INPUT PAGE
MAPALC(DRO)		;DR11C BLOCK OUTPUT PAGE

XP EVPMAX,ZZPAG-1	;MAXIMUM EXEC VIRTUAL PAGE THAT OTHER MODULES
			; CAN ALLOCATE

;MACRO TO ALLOCATE VIRTUAL PAGES FOR ONCE MODULES

DEFINE MAPONC(NAM,SIZE)<
XP SIZ'NAM,SIZE
MAPALC(NAM,SIZE)
>

MAPONC(CTX,3)	;RESERVED FOR OTHER MODULES (CONTEXT PAGES - %UPS)

;; MAPONC(DUM,1)           ;PADDING FOR ONCE DATA BASE ?? not needed ??
MAPONC(REF,3)		;MAX SIZE OF REFSTR
MAPONC(OND,7)		;MAX SIZE OF ONCDSK
MAPONC(ONC,5)		;MAX SIZE OF ONCE

;MACRO TO CKECK THAT ENOUGH PAGES HAVE BEEN ALLOCATED FOR ONCE
;MODULES AND PRINT AN ERROR MESSAGE IF NOT

DEFINE ONSZCK(NAME,NAM,NM)<
DEFINE X(RSIZ,DSIZ)<
PRINTX *** NAME REQUIRES AT LEAST RSIZ PAGES, ONLY DSIZ ARE ALLOCATED. ***
>
IF2, <IFIDN <NM><>, <
IFG NAM'LNP-SIZ'NAM*1000,<X(\<NAM'LNP/1000>,\SIZ'NAM)>
>>
IF2, <IFDIF <NM><>, <
IFG NAM-SIZ'NM,<X(\NAM,\SIZ'NM)>
>>
>

;THE ONCE TIME PCB MAP SLOTS

;MACRO TO GENERATE THE SLOT NAMES, USED IN ONCE MACROS

DEFINE OPCNAM<
X HOM
X HMR
X STA
X STR
X BAT
X TMP
X T2P
>


NMOCPC==0		;COUNT NUMBER OF PAGES
DEFINE X(A)<NMOCPC==NMOCPC+1>
OPCNAM			;COUNT THE NUMBER OF ONCE PCB PAGES.


DEFINE X(A)
<MAPALC('A)
>
OPCNAM			;ALLOCATE THEM.

BOTTM==ZZPAG_^D9	;LOWEST ONCE TIME PAGE.

ZZPAG==400+1		;MINIMUM PAGE WE CAN ALLOCATE + 1
MAPALC(MIN)		;%MIN IS LOWEST ADDRESS.
;MACROS TO MANIPULATE PAGE MAP SLOTS.

DEFINE EPTPGS(PG,PGS)
<IFL PG-340,<PRINTX *** ERROR IN EPTPGP PAGE NUMBER PG ***
	QQQQQQ	;CAUSE ERROR>
IFGE PG-340,<
 IFL PG-400,<POINT 18,PGS+UPTEP0+<<PG-340>/2>,17+18*<<PG>&1>>
 IFGE PG-400,<POINT 18,EPT+EPTPG0+<<PG-400>/2>,17+18*<<PG>&1>>
>>

DEFINE EPTPGP (PG)
<	EPTPGS (<PG>,%UPS)>

;MACRO TO GENERATE A SLOT POINTER FOR AN EPT BASED VIRTUAL PAGE.
; PG IS THE VIRTUAL PAGE NUMBER. (MUST BE BETWEEN 400 AND
; 777. NO CHECK HERE BECAUSE SYMBOL MAY BE EXTERNAL)

DEFINE EPTPTR(PG) <
	POINT 18,EPT+EPTPG0+<<PG-400>/2>,17+18*<<PG>&1>
>


;MACRO TO GENERATE A SLOT POINTER FOR A UPT BASED VIRTUAL PAGE.
; PG IS THE VIRTUAL PAGE NUMBER, UPX IS WHERE THE UPT
; PAGE IS ADDRESSABLE.

DEFINE UPXPTR(PG,UPX)<
	POINT 18,UPX+UPTEP0+<<PG-340>/2>,17+18*<<PG>&1>>

;MACRO TO GENERATE A SLOT POINTER FOR VIRTUAL PAGE PG
; WHEN UPT IS KNOWN TO BE IN %UPS.

DEFINE UPSPTR(PG)<
	UPXPTR(PG,%UPS)>

DEFINE UPMPTR(PG)<POINT 18,%UPT+400+<PG-340>/2,17+18*<<PG>&1>>

;UXCTFU, UXCTTU, AND UXCTBU MACROS.
; USED TO EXECUTE AN INSTRUCTION THAT SPECIFICALLY REFERS
; TO USER ADDRESS SPACE (PREVIOUS CONTEXT CAN BE EXEC SPACE).

DEFINE X(A)<IRP A,<
DEFINE UXCT'A'U(INST)<SALL
	IF2,<IFNDEF DOXCT,<EXTERNAL DOXCT>>
	PUSHJ	P,DOXCT
	  XCT'A'U	<INST>
>;END DEFINE UXCT'A'U
>;END IRP A
>;END DEFINE X

X(<T,F,B>)	;GENERATE UXCTFU, UXCTTU, AND UXCTBU.
;SOFTWARE PAGE FAIL WORD
; EXISTS BECAUSE OF DISPARITY BETWEEN KI10 AND KL10 PAGE FAIL
; WORD FORMAT. CURRENTLY SETUP TO MAKE KL PAGE FAIL WORD CONVERT
; FASTER THAN KI PAGE FAIL WORD.

		;BIT 0 RESERVED FOR A COPY OF PC.USR
XP SPFW.U,1B18	;SET IF FAULT ADDRESS IS IN USER SPACE
XP SPFW.H,1B19	;ON FOR ADDRESS BREAK, PROPRIETARY VIOL, HARD PAGE ERRORS.
XP SPFW.A,1B20	;COPY OF A BIT FROM MAP
XP SPFW.W,1B21	;COPY OF W BIT
XP SPFW.S,1B22	;COPY OF S BIT
XP SPFW.T,1B23	;SET IF INSTRUCTION WILL EVENTUALLY TRY TO WRITE
; SYSTEM MACROS

;MACRO TO PREVENT SCHEDULING, USED AT UUO LEVEL WHEN A
;REENTRANT ROUTINE IS CHANGING COMMON DATA NOT YET
;ASSIGNED TO A PARTICULAR JOB

DEFINE NOSCHED
<>

;MACRO TO ALLOW SCHEDULING ONCE MORE

DEFINE SCHEDULE
<>

;MACRO TO PREVENT CORE SHUFFLING, USED AT UUO LEVEL WHEN
;A ROUTINE SETS UP AN ABSOLUTE USER ADDRESS IN AN AC
;OTHER THAN PDP,PROG, OR JDAT. THE MAIN EXAMPLE IS A BLT
;FROM EXEC TO USER OR USER TO EXEC.

DEFINE NOSHUFF
<>

;MACRO TO ALLOW SHUFFLING ONCE MORE

DEFINE SHUFFLE
<>
COMMENT #Rules for State code Type selection

The code putting a frame into an SJ state code must leave the
data base in the monitor consistent. The code should not have any
sharable resources when it puts the frame into the SJ state code.
The code must not have any pending interrupt conditions (e.g. DDBs
with IOW set so that SETIOD will be called for the frame) that could
unexpectedly wake the job out of some unrelated wait state.
The code doesn't have to leave either the monitor's or the user's data
base in a continuable state - all code that operates on frames that
doesn't want to disturb the current state of the frame (i.e. it can be started
at the address it stopped without any ill effects on the running
program) is responsible for delaying its action until the UUO
code it was stopped out of has completed. This is what the UTRP
bit is used for.
(Note - I believe that if a job was in an SJ state as a result
of a UUO which will stop the job rather than go through USRXIT,
such as EXIT, the UTRP bit would remain set and the command
that was deferred would not be performed. This is the same
problem that causes address breaks while in the monitor not
to get printed out if the program EXITs out of the breaking
UUO instead of returning to the user.)

Note that in general, I/O waits (IO, MB) cannot be SJ, since
they leave a DDB with IOW set.
TTY IO wait is an exception, since all frame stopping code will
take all TTY devices out of I/O wait, and the TTY code is written
soas to leave both the monitor and user data base in a continuable
and consistent state.

All I/O wait states must be prepared for the event of a hung
device. In this event, the DHNG routine for the device is called,
which is responsible for clearing any pending interrupt conditions
for the DDB (IOW bit) as well as cleaning up the device's data
base. ERRCON will clear IOACT for the device.
The monitor data base must be consistent after the DHNG call -
but neither the monitor or the user data base has to be
continuable, since hung device is a fatal condition which stops
the job.

All device drivers must make sure that the monitor data base
is consistent if DHNG is called, but in general they do not
have to leave it consistent at the time they call WSYNC.
If they do not, the corresponding satisfied state must be
a DJ rather than an SJ state. If the driver is setup so that
the data base is left consistent at WSYNC time and the only
thing that stops the I/O wait code from being SJ is the
IOW DDB, then the corresponding satisfied state can be SJ.
#;END COMMENT
;DEFINE THE QUEUES, QUANTUM RUNNING TIME IN JIFFIES, AND PRIORITY
;PRIORITY GOES BACKWARD FROM LOW TO HIGH
;THE QUEUE NUMBERS START AT 0 AND GO UP BY ONE READING DOWN THE PAGE
;THE THIRD ARG CAN BE "DJ" FOR DELAY JOB IF CONTOL C TYPED
; OR "SJ," FOR STOP JOB (WHEN IN EXEC MODE)

DEFINE QUEUES
<	X RN,7,DJ,	;;STRAIGHT RUN (LOWEST PRIORITY) (Q=0)
	X WS,6,DJ,	;;I/O WAIT SATISFIED
	X TS,6,SJ,	;;TTY I/O WAIT SATISFIED
	X SS,,DJ,	;;SWAPPER WAIT SATISFIED
	X SI,4,DJ,	;;SAT PRIMARY PCB IO OFF WAIT.
	X RI,4,DJ,	;;RIB PRIMARY PCB IO OFF WAIT.
	X PS,4,DJ,	;;SAT PRIMARY PCB WAIT.
	X PR,4,DJ,	;;RIB PRIMARY PCB WAIT.
	X M2,4,DJ,	;;2 PCBS WAIT.
	X DA,4,DJ,	;;DISK STORAGE ALLOCATION WAIT
	X CB,4,DJ,	;;DISK CORE-BLOCK SCAN WAIT
	X FC,4,DJ	;;FREE CORE WAIT FOR I/O LIST AREA
	X MT,4,SJ,	;;MAGTAPE CONTROL WAIT (UP TO 8 UNITS)
	X AX,4,SJ,	;;WAIT FOR AUX CIRCUIT RESOURCE
	X AC,4,SJ,      ;;WAIT FOR SPACE IN ACCOUNTING BUFFER
	X BP,4,SJ,	;;BLOCK I/O PORT WAIT
>

;;JOB STATUS CODES WHICH HAVE NO CORRESPONDING QUEUES
;;JOBS ARE UNRUNABLE WHEN IN THESE STATES

DEFINE CODES
<	X IOW,,DJ,	;;I/O WAIT
	X MBW,,DJ,	;;MONITOR BUFFER I/O WAIT
	X CW,,DJ,	;;CONTEXT PAGE WRITE LOCK QUEUE.
	X TIOW,,SJ,	;;TTY I/O WAIT
	X SW,,DJ,	;;SWAPPER OUTPUT WAIT (PGYPGO)
	X MLOW,,DJ,	;;PCB LOCK Q WAIT.
	X ILW,,SJ,	;;CLUB INTERLOCK WAIT.
	X FLW,,DJ,	;;ATOMIC FILE LOCKING WAIT.
	X SLP,,SJ,	;;JOB SLEEPING
	X NUL,,SJ,	;;JOB NUMBER NOT ASSIGNED
	X STOP,,SJ,	;;STOP (CONTROL C)
>

;;LAST PAGE SHOULD BE WRITTEN WITH 'HP' TECO COMMAND SO FORM-FEED IS
;; NOT APPENDED AFTER 'LIST' CAUSING EXTRA BLANK PAGE IN MONITOR LISTING.
;;HOWEVER, 2 CARRIAGE RETURN-LINE FEED'S FOLLOWING THE 'LIST' ARE DESIRABLE.

	END
     po$