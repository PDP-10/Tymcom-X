TITLE	MAPIO	MAPPED IO ROUTINES

	STOPCD(,ENTRY,MAPIO)

;EXTERNALS

EXTERN DEVRET,DEVATB,DEVRBN,DEVRIB,DEYRPS,DEVLOK,DEVBTS,DEPFLK
EXTERN DEVFLO,DEVRB1,DEVDBL,DEVSZS,DEVSUP,DEVDRB

EXTERN UNIPPU,UNTTBL,UNISTR,UNYLUN,UNTLEN

EXTERN STRDDB,STRPPU,STRUNI,STRNAM,STRUNM

EXTERN DRBRIB,DRBALC

EXTERN RBREAL,RBMASK,RIBLST,RBYPNO,RBYUNI,RIBSTS,RBLVSP,RIBSLF
EXTERN RIBPFS,RIBSFS,RIBRIB,RIBLCW,RIPBDR,RIPUFE,RBYUN1,RIBSIZ
EXTERN RIBALP

EXTERN ATYBSZ,ATBMWC,ATMMWC,ATBLOK,ATYWSZ,ATBDUM,ATBSIZ,ATSWRD
EXTERN ATSBLK,ATBFNB,ATBRIB,ATBSTS,ATPMXU,INCUMC,CNVATB,ATBLCW
EXTERN ATPUFE,ATPCRE,ATPDEL,ATPSUP,ATYALP,ATBALP

EXTERN PGYDIO,PGYSIO,PGYUSE,PGYDRT,DECUSE,INCUSE

EXTERN FNBDBL,FNYUFP

EXTERN SPTVIR,SPMUSC,SPTUSC,SPPVIR

EXTERN UUYCPR,UUYSVM,UUYCTG

EXTERN MAPRLS,%SAT.C,MAPWTU,GETSAT,RELRIB,RELSAT,RELRB2,UPDADS
EXTERN IOSUPR,CHKQTA,FBIT,KEPPAG,SMMPXC,MAPRDU,%CTSTS
EXTERN GIVPAG,MAPWTL,PCBPTR,%RIB.C,%CTUPT,MAPXCH,IOBDRB
EXTERN %RB2.C,MAPCML,GETM2,RELM2,WATPCB,STAWTU,STAWTL,STACML
EXTERN STAWLN

EXTERN USETST,PTROU0,PTRCHG,PTRINN,PTRLEN,RIBCON,PTROU2,NXTPT0

EXTERN RIBCKD

EXTERN SRCCHT,INSCHT,SRCSPT,INSSPT,DECRMV

EXTERN LMPSHR,LM3CUR,LMMEXS,LMPMXW,LMPREF,LMPVIR,LMPSUP,LMPNER
EXTERN LM3SPT,LM3ATB,LM3HDA,MAXCPR
EXTERN LMYSPT,LMPACT,LMMERR,LMMCUR,LMMMXW,LMMSUP,LMNCUR,LMMRDW

EXTERN STOLMA,GETDPA,GETATB,SETSHR,DEALMA,KREMOV

EXTERN UFDNAM,UFDEXT,UFDSIZ,UFPERR,UFDERR,UFDALP

EXTERN VPUMAX,CPOPJ1,NORED,NOWRT,STOP1,WSCHED,PUUOAC
EXTERN PJBSTS,PJOBN,RNQ,SETRUN,JOB,CPOPJ,JBTSTS,CURUPT,JBTWCT
EXTERN ALIASD,JBYRPT,JBYWPT,REMCHT,REMSPT,REMWAT,SRUNI,REMUWS
  %COW.N==:371	;Hack for new MACRO/LINK
EXT(<%COW,%COW.N,%UPT,%UPT.N,%UPX>)
EXTERN REMMWS,%UPLMA,JBTSOT,JBTUPM,PVYCOR,JBTMPC
EXTERN VLNVP%,VL.WAT,UPTLDC,VLIOE%,UPDAC2,GTCGSZ
EXTERN TIMADJ,FLWQ,JBTNAM,JBTUNM
EXTERN GETLMA,UPTJOB,LMASRP,REDLMA,SETLMA

EXTERN PS.DER,PS.DTE,PE.NER

EXTERN SETACH
;ERROR FLAGS:


FALCTG==:0	;CONTIG FIELD IN ARG BLOCK IS 0.
		;(MAP,SMAP,REMOVE,CLEAR,REPLIC)

FALDVR==:1	;DESTINATION VM PAGE NO. IN ARG BLOCK IS OR WILL
		;BE OUT OF ALLOWABLE RANGE.
		;(MAP,SMAP,REMOVE,CLEAR,REPLIC,VFSTAT)

FALCPU==:2	;CURRENT PROTECTION IN ARG BLOCK IS AN
		;UNDEFINED VALUE.
		;(MAP,SMAP,REPLIC)

FALVEX==:3	;A VM PAGE WHICH MUST BE NON-EXISTENT EXISTS.
		;(MAP,SMAP,REPLIC)

FALNEX==:4	;A VM PAGE WHICH MUST EXIST IS NON-EXISTENT.
		;(REMOVE,REPLIC,VFSTAT)

FALSVR==:5	;SOURCE VM PAGE NO. IN THE ARG BLOCK IS OR WILL
		;BE OUT OF ALLOWABLE RANGE.
		;(REPLIC)

FALPHP==:6	;A SPECIFIED FILE PAGE IS PAST THE EOF,
		;OR SUPER MAP AND PAST BOUNDS OF UNIT OR STR,
		;OR FTRNC AND REQ SIZE IS > CURRENT.
		;(MAP,SMAP,FDELETE,FEXCH,FTRNC)

FALFPZ==:7	;A SPECIFIED FILE PAGE IS <=0.
		;(MAP,SMAP(<0 ONLY),FCREATE,FDELETE,FEXCH,FTRNC)

FALCOR==:10	;USER'S ALLOWABLE AMOUNT OF CORE WILL BE
		;EXCEEDED.
		;(MAP,SMAP,REPLIC)

FALRBE==:11	;RIB ERROR.
		;(MAP,FCREATE,FDELETE,FEXCH,FTRNC)

FALBDS==:12	;BAD SAT.
		;(MAP,REPLIC,VFSAT)

FALCPL==:13	;THE CURRENT PROTECTION IN THE ARG BLOCK IS NOT
		;LEGAL, AS OPPOSED TO BEING UNDEFINED (FALCPU).
		;(MAP,SMAP,REPLIC)

FALLKO==:14	;TRYING TO MAP A LOOKUP ONLY FILE.
		;(MAP)

FALHOL==:15	;A FILE PAGE IS A HOLE.
		;(MAP,FDELETE)

FALNHL==:16	;A FILE PAGE WHICH MUST BE NON-EXISTENT(=A HOLE
		;OR PAST EOF) EXISTS.
		;(FCREATE)

FALSNM==:17	;SUPER MAP AND THE NAME INITED IS NEITHER STR
		;NOR UNIT.
		;(SMAP)

FALOPE==:20	;IO ERROR ON VALIDATION WRITE OF PAGE.
		;(REMOVE,CLEAR)

FALSAM==:21	;THE TWO PAGE NUMBER ARGS (FILE OR VM) ARE
		;IDENTICAL.
		;(FEXCH,REPLIC)

FALNML==:22	;SUPER MAP AND A FILE HAS BEEN LOOKED UP OR
		;ENTERED ON THIS CHANNEL.
		;(SMAP)

FALNOF==:23	;NO FILE HAS BEEN LOOKED UP/ ENTERED ON THIS
		;CHANNEL.
		;(MAP,FCREATE,FTRNC,
		;FDELETE,FEXCH,FVLRIB)

FALNWT==:24	;FILE NOT ENTERED, OR ENTERED BUT APPEND ONLY.
		;(FCREATE,FDELETE,FEXCH,FTRNC)

FALAQA==:25	;DISK FULL OR USER'S DISK QUOTA IS EXCEEDED.
		;(FCREATE)

FALCTL==:26	;CONTROL C HAPPENED AND WE WERE WATCHING FOR IT.
		;(USED ONLY INTERNALLY HERE.).

FALIPE==:27	;IO ERROR ON READ OF A PAGE.
		;(NOT RETURNED BY A UUO/KERNEL ROUTINE.)

FALNTF==:30	;A RET PNTR OF THE DESIRED TYPE IS NOT IN THE
		;FILE IN THE AREA WE WERE ASKED TO SEARCH.
		;(FFIFP AND FRIENDS).

FALNIM==:31	;A FUNCTION ASKED FOR IS NOT IMPLEMENTED.
		;(FFIFP AND FRIENDS).

FALLGE==:32	;ASKED TO NOT LOG IO ERRORS IN BAT PAGES, BUT
		;NOT PRIVILEDGED TO ASK THIS.
		;(REMOVE,CLEAR).

FALNSP==:33	;ASKED TO TRUNCATE FILE, BUT REQUESTED SIZE IS
		;NOT IN THE LAST PAGE.
		;(FTRNC).
FALOFF==:34	;"OTHER FRAME" FAILURE. GIVEN IF GET ACCESS
		; RIGHTS FAILURE, BAD SAT, ETC.
FALALF==:35	;VP ALREADY MAPPABLE FROM A FILE
FALNSE==:36	;TRYING TO INSERT SUPER MAPPED VP INTO FILE

DEFINE FALERR(ERR,GO)<JRST	[MOVEI T1,FAL'ERR
IFNB <GO>,<		  JRST 'GO]>
IFB <GO>,<		 JRST VUOOUT]>
>;END FALERR MACRO DEFINITION
COMMENT #
@@SUBROUTINE KMAPP
@@PURPOSE
KERNEL SUBROUTINE TO MAP FILE PAGES TO VIRTUAL PAGES.
@@ENTRY
EXPECTS USER ARGS IN T1 AND T2 AND F/ DDB AND S/ DEVIOS.
JOB NUMBER IN J, CORRECT CONTEXT PAGES SETUP IN %UPX.
SIGN BIT OF T1 IS ON IFF USER MODE CALLER.
@@ACCUM
DESTROYS P1-P4, T1-T4, U, AND PG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON NON-SKIP RETURN, THE LH OF T1 HAS THE NO. OF THE VM PAGE ON
WHICH THE FAILURE OCCURRED, AND THE RH OF T1 HAS THE ERROR
CODE AS FOLLOWS:  FALCTG,FALDVR,FALCPU,FALVEX,FALPHP,FALCOR,
FALRBE,FALBDS,FALCPL,FALLKO,FALHOL,FALNOF,FALFPZ.
@@#

;FLAGS THAT WIND UP IN P2 FOR CHGMAP AND END OF MAP

	MF.USR==(1B0)		;MUST BE SIGN BIT, SAYS USER CALLED MAP
	MF.GHP==(1B1)		;SAYS CALLER TRIED TO MAP OFF EOF, MAP
				; WILL MAP EVERYTHING UP TO EOF AND THEN GIVE ERROR RETURN.

EXTERNAL SETLMX,%UPLMX


INTERN KMAPP

    ;CONTIG, AND W/ 1ST DESTINATION VM PAGE NUMBER.
KMAPP:	NOCHARGE	;STOP THE CLOCK.
	PUSHJ	P,SETARG	;THE ARGS.
	  POPJ	P,		;ERROR CODE IS IN T1.
	PUSHJ	P,CHKPVY	;MAKE SURE NOT GOING OVER EXISTENCE LIMIT
	  POPJ	P,		;YES, ERROR CODE IN T1.
	JUMPLE	M,[MOVEI T1,FALFPZ ;BAD FILE PAGE ARG
		   JRST VUOOUT]	;IF LESS OR EQUAL TO ZERO.
	TLNN	F,LOOKB!ENTRB	;IS THERE A FILE OPEN ON THIS
	FALERR	(NOF)	;NO CHANNEL.
    ;HERE TO ACCESS A REAL FILE.

      ;CHECK FOR LOOKUP ONLY AND SOME OF REQUESTED CURRENT
      ;PROTECTION > ALLOWED.
MAPFIL:	TLNE	S,IOBDRB	;IS THIS A DEAD FILE?
	FALERR	(RBE)	;YES.
	HLLZ	T1,DEVIAD(F)	;CATCH
	TLNE	F,ENTRB		;LOOKUP ONLY FILES HERE.
	JRST	MAPFI2		;CAN'T BE LOOK ONLY IF ENTRB ON.
	TLNE	T1,NORED	;JUST LOKUP DONE, LOK ONLY FLG?
	FALERR	(LKO)	;YES, CAN'T MAP.
	TLZE	P3,LMPMXW	;SKIP IF PROTECTION NOT READ/WRITE
	FALERR	(CPL)		;IS ASKING FOR READ WRITE, BUT DOESN'T HAVE WRITE ACCESS TO FILE

      ;LOCK FILE, DETERMINE SIZE, AND CHECK REST OF CUR PROT.
MAPFI2:	MOVEM	S,DEVIOS(F)	;
	PUSHJ	P,LOKUNM	;LOCK FILE FOR READING.
	MOVE	S,DEVIOS(F)	;DID THE FILE DIE WHILE WE
	TLNE	S,IOBDRB	;WERE WAITING FOR THE LOCK?
	FALERR	(RBE,MPROU1)	;YES.
	HRRZ	T2,DEVATB(F)	;
	JUMPN	T2,.+2		;
	 STOPCD                         ;;MAPFI2+7
	LDB	T4,ATYBSZ	;CALC
	ADDI	T4,3		;T4/
	LSH	T4,B2PLSH	;HPW.
	TLNE	F,ENTRB		;IS THIS APPEND ONLY
	TLNN	T1,NOWRT	; (IF NOT OK TO HAVE LMPMXW ON FROM SETARG)
	 JRST	MAPF21		;NOT APPEND ONLY STATE.
	LDB	T3,LM3CUR	;GET DESIRED PROTECTION
	CAIE	T3,CPRRDW	;IS HE TRYING TO WRITE
	 JRST	MAPF21		;NOT TRYING TO WRITE, LMPMXW IS OFF, LEAVE IT THAT WAY.
	SKIPL	P1		;SPECIAL LAST PAGE OF
	TLNN	F,GETB		;APP
	 FALERR	(CPL,MPROU1)	;ONLY
	CAIN	P2,1		;FILE FOR
	CAME	M,T4		;SIM OF OLD STYLE IO?
	 FALERR	(CPL,MPROU1)
	TLO	P3,LMPMXW	;SET THIS SINCE IT WON'T BE SET BELOW.

;NOW SET P1 TO THE COUNT OF PAGES WE HAVE TO MAP
; AND SET FLAGS MF.GHP (MAPPING MORE THAN IS IN FILE) AND
; MF.USR (USER CALLED MAP, SET FOR CHGMAP) IN P2.

MAPF21:	MOVE	P4,P1		;SAVE USER FLAG IN P4
	CAMLE	M,T4		;1ST REQ PAGE > HPW
	FALERR	(PHP,MPROU1)	;YES.
	AOS	P1,T4		;HPW+1
	SUB	P1,M		;HPW+1-FIRST FP = NUMBER OF PAGES IN FILE PAST FIRST FP
	CAMLE	P2,P1		;IS USER'S COUNT LESS OR EQUAL COUNT HE CAN HAVE?
	JRST	[MOVSI P2,MF.GHP	;NO, GIVE ERROR WHEN THRU MAPPING
		 JRST MAPF22]	;AND LEAVE MAX COUNT IN P1
	MOVE	P1,P2		;YES, GET USER'S COUNT INTO P1
	SETZ	P2,		;AND CLEAR FLAGS IN P2.
MAPF22:	SKIPGE	P4		;USER BIT MOVED TO P4, MOVE IT AGAIN TO P2
	TLO	P2,MF.USR	;SO CHGMAP CAN CHECK IT.
      ;HERE TO DO THE ACTUAL MAPPING.

MAPFI3:	TLNN	F,ENTRB		;SET LMPMXW ACORDING TO ENTRB SETTING.
	JRST	.+3		;(APPEND ONLY SIMIO CASE HANDLED ABOVE.)
	TLNN	T1,NOWRT	;
	TLO	P3,LMPMXW	;
	PUSH	P,P1		;SAVE ORIGINAL COUNT FOR CHGING.
	PUSHJ	P,USETST	;SET @DEVRET TO 1ST PAGE WANTED.
	  JRST	MPROU2		;ERROR RETURN, BAD RIB.

MAPF34:	MOVE	S,DEVIOS(F)	;DID THE FILE GO BAD WHILE WE
	TLNE	S,IOBDRB	;WAITED IN MAPKRN?
	JRST	MPROU2		;YES.
	SKIPG	T2,@DEVRET(F)	;GET RET PNTR.
	 STOPCD (.,JOB,MPFBRP,,<MAPF error - Bad Retreival Pointer>);;MAPF34+4
	TLNN	T2,RBREAL	;A REAL PNTR?
	FALERR	(HOL,MPROU2)	;FELL INTO A HOLE.
	MOVE	T1,%UPLMX(W)	;GET OLD LMAP SLOT
	TLNE	T1,LMMEXS	;EXIST ALREADY?
	FALERR	(VEX,MPROU2)	;YES.
	TLNE	T1,LMPREF	;GET REF BIT FROM OLD SLOT
	TLO	P3,LMPREF
	HRRZ	T1,DEVATB(F)	;SET UP ARGS FOR MAPKRN, T1/
	PUSHJ	P,MAPKRN	;P3 HAS PROTOTYPE LMAP SLOT.
	  FALERR (BDS,MPROU2)	;ERROR RETURN, BAD SAT.
	TLO	P3,LMPVIR	;SET VIRGIN BIT, MEANS TRY TO GET FREE
				; CORE PAGE AND START WITHOUT SWAPPER.
	PUSHJ	P,SETLMX	;NEW SLOT, LEAVE LDC ZERO.
	ADDI	W,1		;DO THIS HERE FOR EXITS.
	SOJLE	P1,MAPFI5	;ANY MORE <= HPW?
	AND	P3,[(<LMMMXW>)]	;JUST THESE BITS
	PUSHJ	P,GETRET	;YES, GET NEXT DEVRET.
	JRST	MPORBR		;RIB ERROR.
	ADDI	M,1		;FOR USETSTING.
	SKIPL	T2,@DEVRET(F)	;POINTING TO A SPARE?
	JRST	MAPF36		;NO.
	PUSHJ	P,USETST	;YES, GET A REAL.
	JRST	MPORB0		;
MAPF36:	SKIPE	@%RIB.C+%CTUPT	;FAST CHECK INSTEAD OF
	PUSHJ	P,RELRIB	;WHOLE ROUTINE.
	JRST	MAPF34		;

      ;HERE ON END OF MAPPING.
MAPFI5:	TLNE	P2,MF.GHP	;NEED TO TELL USER HE TRIED TO MAP TOO MUCH?
	FALERR	(PHP,MPROU2)	;YES, RETURN WITH EVERYTHING UP TO EOF MAPPED.
	PUSHJ	P,CHGMAP	;CHARGE, ALSO ADJUST JBTUPM.
	PUSHJ	P,RELSAT	;
	PUSHJ	P,RELRIB	;
	PUSHJ	P,UNLFIL	;
	JRST	CPOPJ1		;
      ;ERROR EXITS.

MPORB0:	PUSHJ	P,RELSAT	;
	FALERR	(RBE,MPORB1)

MPORBR:	PUSHJ	P,RELSAT	;HERE ON RIB ERROR.
	PUSHJ	P,KILFIL	;
MPORB1:	PUSHJ	P,CHGMAP	;
	JRST	VUOOUT		;

MPROU2:	PUSHJ	P,CHGMAP	;CHG AND ADJUST JBTUPM.
	MOVEM	S,DEVIOS(F)
	PUSH	P,T1		;SAVE ERROR CODE.
	PUSHJ	P,RELSAT	;
	PUSHJ	P,RELRIB	;
	POP	P,T1		;RESTORE ERROR CODE.
MPROU1:	PUSHJ	P,UNLFIL	;
	JRST	VUOOUT



    ;SOME GENERAL ERROR EXITS.
VUOFL0:	PUSH	P,T1		;
	PUSHJ	P,RELSAT	;
	POP	P,T1		;
VUOOUT::HRLI	T1,(W)		;
	POPJ	P,
COMMENT #
@@SUBROUTINE CHGMAP
@@PURPOSE
SUBR TO CHARGE FOR MAPPING PAGES AND ALSO ADJUST JBTUPM.
@@ENTRY
EXPECTS ON THE PDL JUST AFTER THE CALLER, THE ORIGINAL COUNT
OF PAGES TO BE MAPPED.  ALSO EXPECTS P1/ CURRENT COUNT, J/ JOB
NO., W/ NO. OF VM PAGE AFTER THE LAST ONE SUCCESSFULLY MAPPED,
AND MF.USR = 1B0 SET TO 1 IN P2 IFF USER CALLED MAP.
@@ACCUM
DESTROYS T2, T3, AND T4.
#

CHGMAP:	POP	P,T3		;T3/ CALLER.
	EXCH	T3,(P)		;T3/ ORIGINAL CNT AND PDL OK.
	SUBI	T3,(P1)		;T3/ NO. OF PAGES MAPPED.
	JUMPGE	P2,CHGMP2	;NO CHARGE IF CALLED FROM EXEC.
	MOVEI	T2,(T3)		;CHARGE IN UNITS OF 4 SINCE VCRE
	LSH	T2,2		;IS 1/4 A MAP CHARGE.
	ADDM	T2,JBTMPC(J)	;CHARGE FOR
	ADDM	T2,JBTMPC	;THEM.
CHGMP2:	MOVEI	T2,(W)		;DON'T ADJUST UPM FOR >777.
	SUBI	T2,1000		;GET T2/ THE NO. OF PAGES
	JUMPLE	T2,CHGMP4	;MAPPED ABOVE 777.
	CAIL	T2,(T3)		;ANY PAGES BELOW OR AT 777?
	TDZA	T3,T3		;NO.
	SUBI	T3,(T2)		;YES.
CHGMP4:	HRLZI	T3,(T3)		;
	ADDM	T3,JBTUPM(J)	;
	POPJ	P,
COMMENT #
@@SUBROUTINE KSMAPP
@@PURPOSE
KERNEL SUBROUTINE TO SUPER MAP DISK PAGES TO VIRTUAL PAGES.
@@ENTRY
EXPECTS USER ARGS IN T1 AND T2 AND F/ DDB AND S/ DEVIOS.
JOB NUMBER IN J, CORRECT CONTEXT PAGES SETUP IN %UPX.
SIGN BIT OF T1 IS ON IFF USER MODE CALLER.
@@ACCUM
DESTROYS P1-P4, T1-T4, U, AND PG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON NON-SKIP RETURN, THE LH OF T1 HAS THE NO. OF THE VM PAGE ON
WHICH THE FAILURE OCCURRED, AND THE RH OF T1 HAS THE ERROR
CODE AS FOLLOWS:  FALCTG,FALDVR,FALCPU,FALVEX,FALPHP,FALCOR,
FALCPL,FALNML,FALFPZ.
@@#



KSMAPP::PUSHJ	P,SETARG	;THE ARGS.
	  POPJ	P,		;GIVE ERROR RETURN, CODE IN T1
	JUMPL	M,[MOVEI T1,FALFPZ
		   JRST VUOOUT]	;NEGATIVE ARG NO GOOD.
	TLNE	F,LOOKB!ENTRB	;IS THERE A FILE OPEN ON THIS
	FALERR	(NML)		;CHANNEL
    ;HERE TO ACCESS VIA SUPER USETI/O.

      ;CHECK PRIVILEDGES, FIND UNIT VS. STR, AND CHECK FIRST
      ;PAGE IN BOUNDS.
MAPUST:	TLNE	S,IOSUPR	;ALREADY SET UP?
	JRST	[HRRZ U,DEVSUP(F) ;YES.
		JRST MAPUS1]	;
	PUSHJ	P,SUPBEG	;CHK PRIV, FIND UNIT VS. STR.
	JRST	VUOOUT		;FAIL.
MAPUS1:	PUSHJ	P,SUPBND	;REQUESTED PAGE IN BOUNDS?
	  JRST	VUOOUT		;NO.
	JUMPN	U,MAPUS2	;YES.  HAVE TO PAW THRU STR?
	MOVE	T1,M		;YES,
	MOVEI	U,STRDDB	; Get structure data block
PRINTF(<[MAPUS1+5 Can't have different size units in structure?]>)
	IDIV	T1,STRPPU(U)	;FIND
	MOVE	M,T2		;U/ UNIT
	HLRZ	U,STRUNI(U)	;AND
	SOJL	T1,MAPUS2	;M/ PAGE
	HLRZ	U,UNISTR(U)	;NUMBER WRS
	JUMPN	U,.-2		;UNIT.
	 STOPCD                         ;;MAPUS1+12

      ;HERE TO BUILD PROTOTYPE NEW SLOTS IN P3.
MAPUS2:	HLLZ	T1,DEVIAD(F)	;LEGAL TO
	TLNN	T1,NOWRT	;WRITE?
	TLOA	P3,LMPMXW	;NOWRT NOT SET, LET CALLER WRITE, SKIP PRTECTION CHECK
	TLZN	P3,LMPMXW	;CALLER CAN'T WRITE, MAKE SURE HE'S NOT TRYING TO
	JRST	.+2		;ALLOWED TO WRITE OR NOT TRYING TO
	FALERR	(CPL)		;ILLEGAL CUR PROT.
	TLO	P3,LMPSUP	;SET SUPER PAGE.

      ;HERE WITH PROTOTYPE SLOT IN P3, U/ UNIT DB, AND T2/
      ;PAGE NO. WRS UNIT.
MAPUS4:	HLRZ	T1,%UPLMX(W)	;VM
	TRNE	T1,LMMEXS	;PAGE
	FALERR	(VEX)		;CAN'T ALREADY EXIST.
	TRNE	T1,LMPREF	;COPY REF BIT TO P3
	TLOA	P3,LMPREF+LMPVIR	 ;AND SET VIRGIN
	TLO	P3,LMPVIR	;NO REF BIT, JUST SET VIRGIN.
	MOVE	T2,M		;GET DESIRED PAGE INTO T2
	LDB	T1,UNYLUN	;TURN INTO RETRIEVAL POINTER
	DPB	T1,RBYUNI	;
	HRRZ	P4,T2		;GET LOW DISK ADDRESS
	TRZ	P4,PGE.A	;ONLY ACCESS BIT IS NOT USED.
	LSH	T2,-LMASRP	;GET HIGH DISK ADDRESS ADJUSTED
	DPB	T2,LM3HDA	;PUT IT INTO THE SLOT
	PUSHJ	P,SETLMX	;REAL SLOT NOW, STORE AND LEAVE LDC ZERO.
	PUSHJ	P,INCUPM	;INC LH OF JBTUPM.
	SOJLE	P2,CPOPJ1	;ANOTHER PAGE TO DO?
	AND	P3,[(<LMMSUP>)]	; YES, CLEAR ALL BUT RELEVANT BITS
	AOJA	M,.+1		;SEE IF WE WILL
	CAMGE	M,UNIPPU(U)	;GO OVER EO UNIT.
	AOJA	W,MAPUS4	;NO, OKAY.
	HRRZ	T1,DEVSUP(F)	;YES, ARE WE ON ONE
	JUMPN	T1,[MOVEI T1,FALPHP ;UNIT ONLY?
		JRST VUOOUT]	;
	HLRZ	U,UNISTR(U)	;NO, OKAY SO FAR, GO TO
	JUMPE	U,[MOVEI T1,FALPHP ;NEXT UNIT.
		JRST VUOOUT]	;
	SETZ	M,		;OKAY, CONTINUE.
	AOJA	W,MAPUS4	;






;TINY SUBR TO INC/DEC THE LH OF JBTUPM.

INTERN DECUPM

INCUPM:	MOVSI	T1,1		;
	JRST	.+2		;
DECUPM:	MOVSI	T1,-1		;
	TRNN	W,777000	;SKIP IF NOT FROM 0-777.
	ADDM	T1,JBTUPM(J)	;
	POPJ	P,
COMMENT #
@@SUBROUTINE SUPBND
@@PURPOSE
TINY SUBR TO CHECK BOUNDS OF REQ PAGE NUMBER FOR SUPER IO.
@@ENTRY
EXPECTS M/ REQ PAGE NO. AND U/ DEVSUP.
@@ACCUM
DESTROYS T1.
@@EXIT
SKIP UNLESS OUT OF BOUNDS, IN WHICH CASE IT NON-SKIP
RETURNS WITH FALPHP IN T1.
@@ #

SUPBND::JUMPE	U,SPRBNS	;JUMP ON STR INITED.

    ;HERE ON UNIT INITED.
SPRBNU:	MOVE	T1,UNIPPU(U)	;GET T1/ NO. OF PAGES
SPRBN2:	CAMGE	M,T1		;REQ PAGE WITHIN UNIT? or STR?
	  JRST	CPOPJ1		;YES.
	FALERR	(PHP,CPOPJ)

    ;HERE ON STR INITED.
PRINTF(<[SPRBNS STR inited? Does U already have a STR pointer?]>)
SPRBNS:	MOVEI	U,STRDDB	; Does U already contain pointer?
	HRRZ	T1,STRUNM(U)	;GET T1/ NO. OF
	IMUL	T1,STRPPU(U)	;PAGES ON THE STR.
	MOVEI	U,0		;*HACK*; Reset U back to 0 for STR inited
	JRST	SPRBN2		;
COMMENT #
@@SUBROUTINE SUPBEG
@@PURPOSE
SUBR TO INITIALIZE SUPER IO.  CHECKS PRIVILEDGES AND DETERMINES
IF STR OR UNIT IS INITED.
@@ENTRY
EXPECTS F/DDB, S/ DEVIOS.
@@ACCUM
DESTROYS T1-T4 AND U.
@@EXIT
1-SKIP RETURNS ON OKAY WITH IOSUPR TURNED ON AND DEVSUP AND
U SET AS FOLLOWS: FOR STR INITED, DEVSUP AND U BOTH =0;
FOR UNIT INITED, DEVSUP AND U BOTH =UNIT DB ADDR.
NON-SKIP RETURNS ON ERROR:  LACK OF PRIVILEDGE RETURNS
T1/ FALNOF,  NEITHER UNIT NOR STR RETURNS T1/ FALSNM.
@@ #

      ;SEE IF THE USER HAS THE PRIVILEDGE TO DO THIS.
SUPBEG::MOVSI	T2,NORED+NOWRT
	ANDCAM	T2,DEVIAD(F)	;RESET FLAGS.
	PUSH	P,J
	LDB	J,PJOBN
	LDB	T3,JBYRPT
	CAIN	T3,3
	  TLZ	T2,NORED	;HE CAN READ.
	LDB	T3,JBYWPT
	CAIN	T3,3
	  MOVEI	T2,0		;HE CAN DO BOTH.
	POP	P,J
	TLC	T2,NORED!NOWRT
	MOVEI	T1,FALNOF	;
	TLCN	T2,NORED!NOWRT	;BOTH STILL ON??
	  POPJ	P,		;YES, ERROR.
	IORM	T2,DEVIAD(F)	;SAVE IT.

      ;HERE TO DETERMINE THE UNIT TO USE.
	HLLZS	DEVSUP(F)	;ASSUME STR.
	MOVE	T1,DEVNAM(F)	;NAME USER INITED.
	SETZ	U,		;FLAG FOR STR INITED.
PRINTF(<[SUPBEG++ Check STRNAM - Why bother if DSKB is only STR]>)
	CAME	T1,STRNAM+STRDDB ;STR NAME?
	  PUSHJ	P,ALIASD	;NO, IS NAME ALIAS FOR "DSK"?
	 JRST	SUPOUT		;YES.  "DSK" OR STR.
	PUSHJ	P,SRUNI		;A UNIT NAME?
	 FALERR	(SNM,CPOPJ)	;NO, ERROR.
	 JFCL
	HRRM	U,DEVSUP(F)	;SAVE UNIT & SAY UNIT, NOT STR.
SUPOUT:	TLO	S,IOSUPR	;
	MOVEM	S,DEVIOS(F)	;
	JRST	CPOPJ1		;
COMMENT #
@@SUBROUTINE KREPLC
@@PURPOSE
KERNEL SUBROUTINE TO REPLICATE VM PAGES.
@@ENTRY
EXPECTS T1/ USER'S ARG, PLUS BIT 0 IS SET IFF CAME FROM
USER MODE.
CONTEXT PAGES FOR SOURCE AND DESTINATION MUST BE LOCKED.
OTFFLG SET IN T1 AND/OR T2 IFF THAT ARG REFERS TO A MAP OTHER THAN CALLER'S.
(CALLER MUST TURN OFF OTFFLG IF "OTHER" SPACE IS CALLER'S).
J NOT SETUP ON CALL TO KREPLC.
@@ACCUM
DESTROYS P1-P4, T1-T4, U, M, J, AND PG.
@@EXIT
ALWAYS GUARANTEED TO RETURN EXCEPT IF THERE IS A SWAP ERROR.
(SO CALLER CAN GIVE BACK CONTEXT PAGE LOCKS.)
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON NON-SKIP RETURN, LH(T1) CONTAINS THE NO. OF THE DESTINATION
VM PAGE ON WHICH THE FAILURE OCCURED, AND RH(T1) CONTAINS THE
ERROR CODE AS FOLLOWS:  FALCTG,FALDVR,FALCPU,FALVEX,FALNEX,
FALSVR,FALCOR,FALBDS,FALCPL,FALSAM.

@@ #

EXTERNAL OTFFLG,FD2FNO,%UPLMX,UPTOFD

    ;GET THE ARGS.
KREPLC::PUSHJ	P,SETARG	;SET THINGS UP.
	  POPJ	P,		;RETURN, T1 HAS ERROR CODE DATA
	MOVE	J,%UPT+UPTJOB	;ASSUME DESTINATION IS THIS FRAME
	TLNN	P1,OTFFLG	;IS IT?
	  JRST	KREPNO		;NOT OTHER.
	MOVE	P4,%UPT+UPTOFD	;GET "OTHER FRAME DESCRIPTOR"
	PUSHJ	P,FD2FNO	;DESCRIPTOR HAS ALREADY BEEN CHECKEDSTOPCD				;;KREPLC+7
				;J GETS DESTINATION FRAME NUMBER.
KREPNO:	PUSHJ	P,CHKPVY	;MAKE SURE NOT GOING OVER EXISTENCE LIMIT
	  POPJ	P,		;IS, ERROR CODE IS IN T1

;CHECK SOURCE RANGE FOR LEGALITY

	HRRZ	T1,M		;GET SOURCE VP START PAGE
	ADDI	T1,-1(P2)	;GET LAST PAGE TO REPLICATE FROM
	SKIPGE	P1		;SKIP IF EXEC
	  CAIG	T1,777		;USER, BOMB IF OVER 777.
	CAILE	T1,VPMAX	;MONITOR, ALLOWED TO TOUCH PER PROCESS PAGES
	 FALERR	(SVR)	;NO GOOD.
	TLNN	M,OTFFLG	;SEE IF SOURCE AND DEST ARE IN SAME ADDRESS SPACE
	TLNE	P1,OTFFLG
	  JRST	.+2		;NOT BOTH IN CALLER'S SPACE, CHECK FOR BOTH IN OTHER SPACE.
	 JRST	KREPL0		;BOTH IN CALLERS SPACE, MUST CHECK.
	TLNE	P1,OTFFLG
	TLNN	M,OTFFLG
	  JRST	KREPL1		;NOT BOTH IN OTHER SPACE
KREPL0:	HRRZ	T1,W		;BOTH IN SME SPACE, GET JUST VP
	CAIN	T1,(M)		;HAD BETTER BE DIFFERENT
	 FALERR	(SAM)		;NOT, ERROR.

KREPL1:	TLZ	P3,LMPMXW	;MUST CHECK LM3CUR DIRECTLY, LOOP BELOW
				; COPIES MAX WRITE FROM SLOT.
	TLNN	P1,OTFFLG	;SET J UP FOR DESTINATION
	  SKIPA	J,%UPT+UPTJOB
	 MOVE	J,%UPX+UPTJOB
REPLC1:	TLNN	P1,OTFFLG	;GET DESTINATION SLOT FROM PROPER MAP
	  SKIPA	T1,%UPLMA(W)
	 MOVE	T1,%UPLMX(W)
	TLNE	T1,LMMEXS	;DOES IT EXIST?
	 FALERR	(VEX,REPFAL)	;YES, CAN'T REPLICATE ON TOP OF IT
	TLNN	T1,LMPREF	;COPY OLD REF BIT TO P3
	  TLZA	P3,LMPREF
	 TLO	P3,LMPREF
	TLNN	M,OTFFLG	;NOW MAKE SURE SOURCE EXISTS
	  SKIPA	T4,%UPLMA(M)	;GET SOURCE SLOT FROM PROPER MAP
	 MOVE	T4,%UPLMX(M)
	TLNN	T4,LMMEXS
	 FALERR	(NEX,REPFAL)	;CAN'T REPLICATE FROM NON-EXISTENT
	AND	T4,[LMPMXW+LMPVIR+LMPNER+LMPSUP,,0] ;BITS NEEDED FROM SOURCE SLOT
	IOR	P3,T4		;PUT INTO PROTOTYPE DESTINATION SLOT.
	LDB	T1,LM3CUR	;GET DESIRED PROTECTION
	CAIN	T1,CPRRDW	;IF CALLER REQUESTING READ/WRITE
	  TLNE	T4,LMPMXW	;(IS) AND SOURCE SLOT NOT MAX WRITE,
	 JRST	REPLC2		;(SOURCE IS MAX WRITE OR CALLER NOT REQUESTING MAX WRITE)
	FALERR	(CPL,REPFAL)	;CALLER CAN'T HAVE THAT MUCH ACCESS

    ;FIND DISK ADDR FROM THE SOURCE PAGE.
REPLC2:	PUSH	P,P3		;SAVE LMAP ARG SETUP BY SETARG.
	PUSHJ	P,REDSRC	;GET SOURCE SLOT INTO P3 AND P4
	PUSHJ	P,GETDPA	;GET T2/ RETRIEVAL PNTR.
	TLZ	T2,RBMASK
	TLO	T2,RBREAL	;MAKE MAPKRN HAPPY.
	
	

    ;SPLIT HERE ON SUPER VS. NON-SUPER.
	TLNE	P3,LMPSUP	;IS SOURCE PAGE A NORMAL PAGE?
	  JRST	REPSUP		;NO, REPLICATE A SUPER PAGE.

    ;HERE ON NORMAL PAGE.  GET ATB ADDR FROM SOURCE PAGE.

	PUSHJ	P,GETATB	;GET ATB ADDRESS IN T1
				;DP ALREADY IN T2.
	POP	P,P3		;RESTORE PROTOTYPE LMAP SLOT FOR DESTINATION
	PUSHJ	P,MAPKRN	;TRY TO MAP THE SLOT.
	 FALERR	(BDS,REPFAL)	;BAD SAT ON MAP ATTEMPT.
	LDB	T4,LM3SPT	;IN CASE WE HAVE TO MAKE SOURCE SLOT SHARED.
	PUSHJ	P,SETDST	;STORE COMPLETED SLOT BACK.

    ;HERE TO UPDATE THE OTHER SLOT.
	PUSHJ	P,GETSRC	;GET SOURCE SLOT
	TLNE	P3,LMPSHR	;
	  JRST	[EXCH W,M	;EXCHANGE W AND M BACK, GETSRC SWITCHED THEM
		 SOS  %UPT+UPTLDC
		 JRST REPNXT]	;THROW DATA AWAY.
	PUSHJ	P,SETSHR	;MAKE THE SOURCE SLOT SHARED.
	PUSHJ	P,STOSRC	;BACK INTO CONTEXT PAGES.
REPNXT:	PUSHJ	P,INCUPM	;
	SOJLE	P2,REPOUT	;
	  HLLZ	P3,P1		;GET PROTECTION AND OTHER STUFF INTO P3
	LSH	P3,^D7-LMNCUR	;GET PROTECTION IN PLACE.
	TLZ	P3,-LMMCUR-1	;GET JUST PROTECTION.
				; REST WILL BE COPIED FROM SOURCE SLOT.
	AOS	M
	AOJA	W,REPLC1	;
REPOUT:	AOS	(P)
	PJRST	RELSAT

    ;HERE ON SUPER PAGE.
REPSUP:	POP	P,P3		;GET PROTO SLOT OFF STACK.
	HRRZ	P4,T2		;SET LOW DISK ADDRESS
	TRZ	P4,PGE.A	;ACCESS BIT CAN'T BE ON
	LSH	T2,-LMASRP
	DPB	T2,LM3HDA	;SET HI DISK ADDRESS
	PUSHJ	P,SETDST	;STORE DESTINATION SLOT IN P3 AND P4 BACK.
	JRST	REPNXT

REPFAL:	PUSH	P,T1
	PUSHJ	P,RELSAT	;SAVE ERROR CODE, RELEASE SAT IF HAVE IT,
	POP	P,T1		;RESTORE ERROR CODE
	JRST	VUOOUT		;PUT RH(W) IN LH(T1) AND RETURN.
;SUBROUTINES TO GET SOURCE AND DESTINATION SLOT IN P3 AND P4

EXTERNAL GETLMA,GETLMX,REDLMA,REDLMX,STOLMA,STOLMX,SETLMA,SETLMX
;REDSRC, GET SOURCE SLOT AND LEAVE W AND M ALONE.

REDSRC:	EXCH	W,M		;GET SOURCE IN W
	TLNN	W,OTFFLG	;IS SOURCE IN %UPX?
	  JRST	[PUSHJ P,REDLMA	;NO, GET FROM %UPT
		 EXCH  W,M
		 POPJ  P,]	;GET W AND M BACK AND RETURN.
	PUSHJ	P,REDLMX	;YES, GET FROM %UPX
	EXCH	W,M
	POPJ	P,

;GETSRC, GET SOURCE SLOT AND LEAVE W AND M EXCHANGED.

GETSRC:	EXCH	W,M
	TLNN	W,OTFFLG
	  PJRST	GETLMA
	PJRST	GETLMX

;STOSRC, STORE SOURCE SLOT AND EXCHANGE W AND M BACK.

STOSRC:	TLNN	W,OTFFLG
	  JRST	[PUSHJ P,STOLMA
		 EXCH  W,M
		 POPJ  P,]
	PUSHJ	P,STOLMX
	EXCH	W,M
	POPJ	P,


;ROUTINES TO STORE DESTINATION SLOT.

STODST:	TLNN	P1,OTFFLG
	  PJRST	STOLMA
	PJRST	STOLMX

SETDST:	TLNN	P1,OTFFLG
	  PJRST	SETLMA
	PJRST	SETLMX
COMMENT #
@@SUBROUTINE KFFIFP
@@PURPOSE
KERNEL ROUTINE FOR CHANIO TO FIND FIRST INTERESTING RET PNTR
IN A FILE.
@@ENTRY
EXPECTS USER ARGS IN T1 AND T2, F/ DDB, S/ DEVIOS, AND M/ ADDR
IN USER SPACE TO RETURN VALUE.
@@ACCUM
DESTROYS T1-T4, P1-P4, U, AND PG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON SKIP RETURN THE NUMBER OF THE FIRST RET PNTR OF THE DESIRED
TYPE HAS BEEN STORED THRU M.
ON NON-SKIP RETURN THE RH OF T1 HAS THE ERROR CODE AS FOLLOWS:
FALNOF, FALRBE, FALLKO, FALFPZ, FALNIM, FALPHP, FALNTF.
@@#

KFFIFP::TLNN	F,LOOKB!ENTRB	;BETTER BE A FILE ON THIS
	 FALERR	(NOF,CPOPJ)	;CHANNEL.
	TLNE	S,IOBDRB	;IS THIS A DEAD FILE?
	  JRST	[MOVEI T1,FALRBE ;YES.
		 POPJ  P,]
	TLNE	F,ENTRB		;CATCH LOOKUP ONLY FILES HERE.
	  JRST	KFFIF2		;CAN'T BE LOOK ONLY IF ENTRB ON.
	HLLZ	T3,DEVIAD(F)	;JUST LOOKUP DONE,
	TLNE	T3,NORED	;LOOK ONLY FLAG?
	 FALERR	(LKO,CPOPJ)	;YES.
KFFIF2:	JUMPLE	T1,[MOVEI T1,FALFPZ ;FILE PAGE ARG >0?
		POPJ P,]
	SKIPL	P1,T2		;SET UP P1/
	  CAILE	P1,MATLEN	;TYPE OF MATCH.
	 FALERR	(NIM,CPOPJ)

      ;LOCK FILE, DETERMINE SIZE, AND SET UP SOME ACS.
	MOVEM	S,DEVIOS(F)	;
	PUSHJ	P,LOKUNM	;LOCK FILE FOR READING.
	MOVE	S,DEVIOS(F)	;DID THE FILE DIE WHILE WE
	TLNE	S,IOBDRB	;WERE WAITING FOR THE LOCK?
	 FALERR	(RBE,UNLFIL)	;YES, RIB ERROR.
	HRRZ	T2,DEVATB(F)	;NO.
	JUMPN	T2,.+2		;CALC
	 STOPCD                         ;;KFFIF2+11
	LDB	P2,ATYBSZ	;
	ADDI	P2,3		;P2/
	LSH	P2,B2PLSH	;HPW.
	CAMLE	T1,P2		;REQUESTED STARTING PAGE
	 FALERR	(PHP,UNLFIL)	;PAST EOF.
	PUSH	P,M		;SAVE M.
	MOVE	M,T1		;

    ;HERE WITH M/ NO. OF FIRST RET PNTR TO LOOK AT, P1/ TYPE OF
    ;MATCH, AND P2/ HPW.
KFFIF4:	PUSHJ	P,USETST	;POINT @DEVRET TO REQ PAGE.
	  JRST	[POP  P,M	;RIB ERROR.  USETST HAS
		 POPJ P,]	;ALREADY KILLED THE FILE.
    ;SEARCH FOR A MATCH IN THIS DDB PNTR AREA.
	MOVE	T2,DEVRET(F)	;
KFFI42:	SKIPG	T1,(T2)		;GET RET PNTR.
	  JRST	KFFI44		;BETTER BE EXPECTING EOF.
	XCT	MATCH(P1)	;DOES C(T1) MATCH CONDITION?
	  JRST	KFFMTD		;YES.
	CAIGE	T2,DEVRBN(F)	;NO. ANOTHER PNTR IN THIS DDB?
	  AOJA	T2,KFFI42	;YES, GO LOOK AT IT.
	 JRST	KFFIF5
KFFI44:	SUB	T2,DEVRET(F)	;
	ADDI	M,(T2)		;
	SUBI	M,1		;
	CAME	M,P2		;
	 STOPCD                         ;;KFFI44+4
	JRST	KFFNTF		;

    ;NO MATCH IN OUR DDB.
KFFIF5:	MOVE	M,DEVFLO(F)	;SET
	ADDI	M,3		;M/
	LSH	M,-2		;NO. OF PAGE
	ADDI	M,PTRLEN	;JUST AFTER OUR DDB AREA.
	CAMLE	M,P2		;IS IT PAST EOF?
	  JRST	KFFNTF		;YES.
	SKIPN	@%RIB.C+%CTUPT	;NO.  IF WE DON'T HAVE A RIB,
	  JRST	KFFIF4		;MAYBE PAGE IS IN A DDB ALREADY.

    ;LOOK IN THE RIB WE HAVE.  (USETST HAS FLUSHED DDBS INTO
    ;IT, SO WE DON'T HAVE TO.).
	LDB	T2,DEYRPS	;OUT OF PNTRS IN
	CAIL	T2,RIBLST	;THIS RIB?
	  JRST	KFFI64		;YES.
	MOVE	T1,P2		;NO.  T1/ NO. OF PAGES BETWEEN
	SUB	T1,M		;NEXT AND
	ADDI	T1,1		;EOF INCLUSIVE.
	MOVEI	T3,RIBLST	;T3/ NO. OF PAGES BETWEEN NEXT
	SUBI	T3,(T2)		;AND EO RIB.
	CAMLE	T3,T1		;T3/ NO. OF RET PNTRS TO
	  MOVE	T3,T1		;LOOK AT.
	ADDI	T2,1		;
KFFIF6:	SKIPG	T1,%RIB(T2)	;
	 STOPCD                         ;;KFFIF6+1
	XCT	MATCH(P1)	;MATCH?
	  JRST	KFFMTR		;YES.
	ADDI	T2,1		;NO.
	SOJG	T3,KFFIF6	;
    ;HERE ON NO MATCH IN THIS RIB, OR PERHAPS EOF.
	CAIGE	T2,RIBLST	;STOPPED BEFORE EO RIB?
	  JRST	KFFNTF		;YES, MUST BE EO FILE.
	LDB	T2,DEYRPS	;NO.  MAYBE EOF, MAYBE
	MOVEI	T3,RIBLST	;NOT.  CHECK
	SUBI	T3,(T2)		;TO
	ADDI	M,(T3)		;SEE
	CAMLE	M,P2		;WHICH.
	  JRST	KFFNTF		;EOF.
KFFI64:	PUSHJ	P,RELRIB	;STILL RET PNTRS LEFT TO
	JRST	KFFIF4		;LOOK AT.
	
KFFNTF:	POP	P,M		;YES, FAIL
	PUSHJ	P,RELRIB	;RETURN
	 FALERR	(NTF,UNLFIL)	;WITH NOT FOUND FLAG.

    ;HERE ON A MATCH IN OUR DDB.
KFFMTD:	SUB	T2,DEVRET(F)	;GET T2/ NO. OF
	ADD	T2,M		;FOUND PAGE.
KFFMOT:	POP	P,M		;RESTORE M/ PLACE TO STORE.
	UMOVEM	T2,(M)		;STORE FOUND RET PNTR NO.
	PUSHJ	P,RELRIB	;MAYBE RELEASE THE RIB.
	PUSHJ	P,UNLFIL	;UNLOCK THE FILE.
	JRST	CPOPJ1		;SUCCESS RETURN.

    ;HERE ON A MATCH IN OUR RIB.
KFFMTR:	LDB	T1,DEYRPS	;SET DEYRPS JUST BEFORE
	SOS	T3,T2		;OUR FOUND
	DPB	T2,DEYRPS	;PLACE, AND SET T4/ NEW
	SUBI	T3,-1(T1)	;DEVFLO IN PAGES, BOTH FOR
	ADDI	M,-1(T3)	;PTRINN, WHICH WILL SET UP
	MOVE	T4,DEVFLO(F)	;THE DDB AREA STARTING
	ADDI	T4,3		;WITH OUR
	LSH	T4,-2		;FOUND
	ADDI	T4,PTRLEN-1(T3)	;PLACE.  ALSO CALC M/
	PUSHJ	P,PTRINN	;NO. OF FOUND RET PNTR.
	 STOPCD                         ;;KFFMTR+12
	MOVE	T2,M		;
	JRST	KFFMOT		;


MATCH:	TLNN	T1,RBREAL	;0 FFFFP.
	TLNE	T1,RBREAL	;1 FFUFP.
MATLEN==.-MATCH-1
COMMENT #
@@SUBROUTINE KFILCK
@@PURPOSE
KERNEL SUBROUTINE TO SEE IF A VM PAGE HAS ITS F BIT SET.
@@ENTRY
EXPECTS USER ARG IN T1 AND M/ ADDR IN USER SPACE TO RETURN
VALUE.
SIGN BIT OF T1 IS ON IFF USER MODE CALLER.
@@ACCUM
DESTROYS T1-T4, P1-P4, U, W, AND PG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON SKIP RETURN, M HAS BEEN USED TO RETURN 0 TO USER IF PAGE IS
NOT IN A FILE, ELSE 1.
ON NON-SKIP RETURN, THE RH OF T1 HAS THE ERROR CODE AS FOLLOWS:
FALDVR,FALNEX,FALBDS.
@@#

KFILCK::TLZN	T1,400000	;USER?
	 STOPCD                         ;;KFILCK+2
	CAILE	T1,^D511	;YES, VP NUMBER IN RANGE?
	  JRST	[MOVEI T1,FALDVR ;NO.
		 POPJ  P,]	;
	HRRZ	W,T1		;GET PAGE NUMBER IN W
	PUSHJ	P,REDLMA	;GET LMAP SLOT.
	TLNN	P3,LMMEXS	;EXISTS?
	 FALERR	(NEX,CPOPJ)
	SETZ	P1,		;P1/ 0 MEANS NOT IN A FILE.
	PUSH	P,J		;SET J/
	MOVE	J,JOB		;JOB NUMBER.
	TLNE	P3,LMPSUP	;IS SUPER?
	  JRST	KFILC4		;YES.
	PUSHJ	P,GETATB	;GET T1/ ATB ADDR.
	SKIPGE	ATBDUM(T1)	;FILE PAGE?
	  JRST	KFILC6		;NO.
KFILC4:	PUSHJ	P,GETDPA	;MAYBE.  GET T2/ RET PNTR.
	TLO	T2,RBREAL	;GET THE SAT FOR THIS
	MOVEI	T1,MAPRDU	;PAGE IN AND UNLOCKED
	PUSHJ	P,GETSAT	;GET T1/MASK,T3/OFFSET IN SAT
	  JRST	[PUSHJ P,RELSAT	;BAD SAT. RELEASE IN CASE READ
		 MOVEI T1,FALBDS ;TELL USER BAD SAT
		 POP   P,J	;
		 POPJ  P,]	;
	TDNN	T1,%SAT+FBITS(T3);IN A FILE?
	 MOVEI	P1,1		;YES.
	PUSHJ	P,RELSAT	;RELEASE THE SAT.
KFILC6:	UMOVEM	P1,(M)		;RETURN VALUE TO USER.
	POP	P,J		;
	JRST	CPOPJ1		;SUCCESS RETURN.
COMMENT #
@@SUBROUTINE KVLRIB
@@PURPOSE
KERNEL SUBROUTINE TO VALIDATE THE RIBS OF A FILE.
FIRST FLUSHES OUT OUR DDB AREA, AND ALSO UPDATES THE FILE SIZE
FIELD IN THE PRIME RIB.
@@ENTRY
EXPECTS F/ DDB AND S/ DEVIOS.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON NON-SKIP RETURN, THE RH OF T1 HAS THE ERROR CODE AS FOLLOWS:
FALNOF, FALRBE, FALNWT.
@@#


KVLRIB::TLNN	F,LOOKB!ENTRB	;A FILE ON THIS CHANNEL?
	 FALERR	(NOF,CPOPJ)
	TLNN	F,ENTRB		;IF WE AREN'T WRITING, WE
	 FALERR	(NWT,CPOPJ)	;HAVE NOTHING TO UPDATE.
	PUSHJ	P,LOKUNM	;LOCK THE FILE.
	MOVE	S,DEVIOS(F)	;IS THE
	TLNE	S,IOBDRB	;FILE BAD?
	 FALERR	(RBE,UNLFIL)	;YES, RIB ERROR.

     ;FIRST, HANDLE WRITING OUT OUR DDB AREA.
	SKIPG	DEVFLO(F)	;IS OUR DDB AREA VALID?
	  JRST	KVLRB4		;NO, FORGET IT.
	HLLZ	T1,DEVIAD(F)	;YES, IS IT
	TLNN	T1,PTRCHG	;DIRTY?
	  JRST	KVLRB4		;NO, FORGET IT.
	MOVE	T1,DEVRIB(F)	;YES.  GET THE RIB FOR THIS
	PUSHJ	P,MWLRIB	;DDB, AND CHECK IT.
	PJRST	KILFIL		;BAD RIB.
	PUSHJ	P,PTROU0	;DUMP OUT THE PNTRS.
	SETOM	DEVFLO(F)	;INVALIDATE THE POINTERS SO WE
				; CAN CHANGE DEVRIB WITHOUT WORRYING
				; ABOUT OTHER JOB SCANNING THEM AND
				; THINKING THEY ARE FROM WRONG RIB.

      ;GET THE PRIME RIB, TO UPDATE THE FILE SIZE.
KVLRB4:	HRRZ	T1,DEVATB(F)	;GET T1/ RET PNTR
	SKIPN	T1,ATBRIB(T1)	;TO PRIME RIB.
	 STOPCD                         ;;KVLRB4+2
	PUSHJ	P,MWLRIB	;GET THE PRIME RIB.
	PJRST	KILFIL		;BAD RIB.
	HRRZ	T2,DEVATB(F)	;FIX UP RIBSIZ AND
	MOVE	T1,ATBSIZ(T2)	;RIBALP, AND DON'T
	TRNE	T1,177		;WORRY ABOUT
	  SUBI	T1,200		;THE UFD, BECAUSE DSKCLN WILL
	MOVEM	T1,%RIB+RIBSIZ	;FIX THAT AND IT IS TOO MUCH
	MOVE	T1,ATBALP(T2)	;OVERHEAD FOR US
	MOVEM	T1,%RIB+RIBALP	;TO DO IT.
	PUSHJ	P,RELRIB	;RELEASE THE RIB.
	PUSHJ	P,UNLFIL	;UNLOCK THE FILE.

    ;WAIT FOR ALL THE RIBS IN CORE TO GO TO DISK.
	PUSHJ	P,WATPCB	;WAIT FOR ALL RIBS
	JRST	CPOPJ1		;TO GO OUT.
COMMENT ;@@SUBROUTINE SETARG/SETARR
@@PURPOSE GET AND CHECK ARGUMENTS FOR MAP, REPLICATE, AND REMOVE.
@@ENTRY ENTER AT SETARR FOR REMOVE, SKIPS PROTECTION CHECKS.
	ENTER AT SETARG FOR MAP AND REPLICATE.
	T1/VUUO POINTER
	  AND IF ENTER AT SETARG,
	T2/ FILE PAGE FOR MAP, SOURCE VP DESCRIPTOR FOR REPLICATE.
@@ACCUM T1-T4, P1-P4,W
@@EXIT	P1/VUUO DESTINATION DESCRIPTOR BITS,,0
	P2/COUNT
	W/FIRST DESTINATION PAGE
	AND IF CALLED AT SETARG,
	M/SOURCE DESCRIPTOR
	P3/LMYCUR SET TO CURRENT PROTECTION, LMPMXW IF PROTECTION IS READ/WRITE
	P4/0
	
ON SKIP/SUCCESS RETURN. ON FAIL/NON-SKIP RETURN, T1 CONTAINS
ONE OF THE FOLLOWING ERROR CODES:
  FALCTG	COUNT IS ZERO
  FALDVR	DESTINATION VP IS OR WILL BE OUT OF RANGE
  FALCPU	UNDEFINED CURRENT PROTECTION ARG

@@;

SETARR::HLLZ	P1,T1		;GET DESTINATION DESCRIPTOR
	LDB	W,UUYSVM	;GET FIRST DVP
	LDB	P2,UUYCTG	;GET COUNT
	JUMPE	P2,[MOVEI T1,FALCTG
		    JRST SETAFL] ;BAD COUNT OF 0

;CHECK DESTINATION VP RANGE TO SEE IF LEGAL. (CALLER RESPONSIBLE
; FOR CHECKING SOURCE.)

	MOVE	T3,W
	ADDI	T3,-1(P2)	;GET LAST DEST VP
	SKIPGE	P1		;ALLOW PER PROCESS VPS IF EXEC
	  CAIG	T3,777		;USER, BOMB IF OVER 777
	CAILE	T3,VPMAX	;EXEC, BOMB IF OVER VPMAX
	 FALERR	(DVR,SETAFL)	;BAD DESTINATION VP
	JRST	CPOPJ1

SETARG::PUSHJ	P,SETARR	;DO COMMON STUFF.
	  POPJ	P,		;ERROR.
	MOVE	M,T2		;GET SOURCE DESCRIPTOR
	SETZB	P3,P4		;CLEAR OUT EMBRYONIC LMAP SLOT
	HLLZ	T1,P1		;GET FLAGS INTO T1 FOR UUYCPR
	LDB	T2,UUYCPR	;GET SPECIFIED PROTECTION
	JUMPE	T2,[MOVEI T1,FALCPU
		    JRST SETAFL] ;ZERO IS BAD
	CAILE	T2,MAXCPR	;MAKE SURE NOT TOO BIG
	 FALERR	(CPU,SETAFL)
	DPB	T2,LM3CUR	;PUT IT IN WHERE IT GOES IN AN LMAP SLOT
	CAIN	T2,CPRRDW	;READ/WRITE?
	  TLO	P3,LMPMXW	;YES, MAX WRITE WANTS TO BE ON (MAYBE
				; CALLER WON'T ALLOW IT TO STAY ON.)
	JRST	CPOPJ1		;FINISHED.

;HERE ON FAILURE.

SETAFL:	HRLI	T1,(W)		;GET DEST VP,,ERROR CODE
	POPJ	P,		;RETURN.
COMMENT ;@@SUBROUTINE CHKPVY
@@PURPOSE SEE IF ADDING C(P2) PAGES WILL EXCEED PVYCOR LIMIT
@@ENTRY P2/NUMBER OF PAGES TO ADD
	W/FIRST VP NUMBER TO BE ADDED.
	J/JOB NUMBER TO ADD PAGES TO.
@@ACCUM T1,T2
@@EXIT NON-SKIP IF NOT OK, FALCOR ERROR CODE IN T1.
SKIP IF OK
@@;

CHKPVY:	MOVE	T2,P2		;T2 WILL HAVE NUMBER OF USER PAGES BY CHKPV1 TIME.
	HRRZ	T1,W		;GET START DP
	ADDI	T1,-1(P2)	;GET END DP
	CAIG	T1,777		;IF NO PAGES ABOVE 777,
	  JRST	CHKPV1		;GO
	MOVN	T2,T1		;GET NEGATIVE NUMBER OF PAGES OVER 777
	ADDI	T2,777(P2)	;GET NUMBER OF USER PAGES
	JUMPLE	T2,CPOPJ1	;NO USER PAGES AT ALL, RETURN.
CHKPV1:	HLRZ	T1,JBTUPM(J)	;GET CURRENT SIZE
	ADD	T2,T1		;T2 NOW HAS SIZE HE WILL BE IF WE DO THIS
	LDB	T1,PVYCOR	;GET MAGIC LIMIT
	ADDI	T1,1
	LSH	T1,2		;CONVERT TO PAGES.
	CAMG	T2,T1		;SKIP IF NO GOOD
	  AOS	(P)		;OK.
	MOVEI	T1,FALCOR	;IN CASE ITS ERROR.
	POPJ	P,
COMMENT #
@@SUBROUTINE SIMCRE
@@PURPOSE
SHELL SUBR TO SET UP FLAGS FOR KFCRE, SO IT KNOWS IT HAS BEEN
CALLED BY SIMIO, AND WILL DO SPECIAL FILE SIZE STUFF, AND
WON'T LET ARG OF -1 THRU.
@@ENTRY
EXPECTS T1/ USER ARG, F/ DDB, AND S/ DEVIOS.
@@ACCUM
DESTROYS T1-T4, U, AND PG.
@@EXIT
JUST LIKE KFCRE EXITS.
@@ #

INTERN SIMCRE

SIMCRE:	PUSH	P,P3		;SAVE P3 AND P4
	PUSH	P,P4		;FOR SIMIO.
	PUSH	P,P1		;
	SETZ	P3,		;FLAG EXEC MODE.
	SETO	P4,		;FLAG "FROM SIMIO".
	PUSHJ	P,KFCREE	;
	  JRST	.+2		;CREATE FAILED.
	AOS	-3(P)		;SET FOR SKIP RETURN.
	POP	P,P1		;
	POP	P,P4		;RESTORE
	POP	P,P3		;P3 AND P4.
	POPJ	P,
COMMENT #
@@SUBROUTINE KFCRE
@@PURPOSE
KERNEL SUBROUTINE TO CREATE A FILE PAGE.
@@ENTRY
EXPECTS T1/ USER ARG, T3/ BIT 0 SET IFF CALLED FROM USER MODE.
ALSO EXPECTS F/ DDB AND S/ DEVIOS.
EXPECTS M TO BE SET UP SO IT CAN STORE PAGE NUMBER FOR -1 CASE.
@@ACCUM
DESTROYS T1-T4, P1, P3-P4, U, AND PG.
@@EXIT
SKIP RETURNS FOR SUCCESS.
ON NON-SKIP RETURN, T1 CONTAINS THE ERROR FLAG AS FOLLOWS:
FALFPZ,FALRBE,FALNHL,FALNWT,FALAQA.
@@#

KFCRE::	TLNN	T3,400000	;SET P3 <>0 IF
	 TDZA	P3,P3		; USER
	  SETO	P3,		; MODE.
	SETZ	P4,		;FLAG NOT FROM SIMIO.
				;SIMIO enters here with P3=0, P4=-1
KFCREE:	MOVEI	T3,KFCREE	;CHK FILE FOR WRITING, AND GET
	PUSHJ	P,DELXCH	; T1/ FILE NO. ARG AND T4/ HPW.
	  POPJ	P,		;
	JUMPG	T1,KFCRE2	;JUMP IF OKAY ARG.
	JUMPE	T1,KFCRE1	;ARG OF ZERO ALWAYS ILLEGAL.
	MOVE	T2,T1		;
	AOJN	T2,KFCRE1	;DON'T ALLOW LESS THAN -1
	JUMPE	P4,KFCRE2	;-1 OKAY IF NOT FROM SIMIO.
KFCRE1:	FALERR	(FPZ,UNLFIL)
KFCRE2:	PUSH	P,M		;SAVE M.
	MOVE	M,T1		;SET UP M FOR USETST AND OTHERS.
	PUSHJ	P,SETACH	;SET UFPALC, ASSUMING WE ARE GOING TO
				; CHANGE SOMETHING (MAY NOT, BUT TOO
				; MUCH TROUBLE TO UNRAVEL STUFF AFTER
				; WE HAVE RIB - SETACH NEEDS CB AND %RIB)
	CAMG	M,T4		;USER WANTS PAGE PAST HPW?
	 JUMPGE	M,CREAT4	;JUMP IF WITHIN EXISTING FILE.

    ;HERE ON ASKING FOR A PAGE PAST HPW.
CREAT2:	HRRZ	T2,DEVATB(F)	;SAVE FILE SIZE
	LDB	T1,ATYBSZ	;FOR CHECK.
	PUSHJ	P,UNLFIL	;UNLOCK BEFORE LOCK MODIFY.
	MOVEM	S,DEVIOS(F)	;
	PUSHJ	P,LOKMOD	;GET LOCKED MODIFY.
	MOVE	S,DEVIOS(F)	;FILE DIED WHILE
	TLNE	S,IOBDRB	; WAITING?
	 JRST	DLXDR1		;YES.
	LDB	T3,ATYBSZ	;GET CURRENT FILE SIZE.
	JUMPGE	M,CREA24	;JUMP UNLESS LAST+1.
	HRRZ	M,(P)		;
	ADDI	T3,3		;CALC THE
	LSH	T3,B2PLSH	; LAST PAGE
	ADDI	T3,1		; +1.
	UMOVEM	T3,(M)		;TELL USER WHAT IT IS.
	MOVE	M,T3		;SET UP M FOR THIS.
	JRST	CREA28		;GO DO IT.

CREA24:	CAME	T1,T3		;CHANGED WHILE WE WAITED?
	 JRST	[ADDI T3,3	;YES.
		 LSH T3,B2PLSH	;
		 CAMLE	M,T3	;
		  JRST CREA28	;
		 PUSHJ P,LOKLES	;
		 JRST CREAT4]	;
CREA28:	MOVEI	T4,1		;CREATE 1 PAGE.
	SETO	T1,		;OKAY.  SWEEP DOES ALL
	PUSHJ	P,SWEPPG	; THE WORK.
	  JRST	[CAIE T1,FALAQA	;
		 CAIN T1,FALRBE	;
		  JRST DELDHO	;
		 STOPCD()]              ;;CREA28+3
	JUMPE	P4,CREOUT	;FINISH UP IF NOT FROM SIMIO.
	HRRZ	T2,DEVATB(F)	;FROM SIMIO.  ADJUST THE
	MOVE	T1,ATBSIZ(T2)	; FILE SIZE TO THE
	SUBI	T1,577		; FIRST WORD IN
	MOVEM	T1,ATBSIZ(T2)	; THIS PAGE.
	JRST	CREOUT		;FINISH UP.

    ;HERE ON ASKING FOR A PAGE .LE. HPW.
CREAT4:	HLLZ	T3,DEVIAD(F)	;IS THE FILE
	TLNN	T3,NOWRT	;APPEND ONLY?
	 JRST	CREA44		;NO.
	JUMPE	P4,CREA42	;YES, FAIL IF NOT SIMIO
	TLNN	F,GETB		;IF NOT SPECIAL CASE
	 JRST	CREA42		; FAIL.
	CAMN	M,T4		;MAYBE.
	 JRST	CREA44		;WIN.
CREA42:	FALERR	(NWT,DELDHO)
CREA44:	PUSHJ	P,DELCRE	;GET DDB AND RIB SET UP.
	  JRST	DLXDR0		;
	TLNE	T2,RBREAL	;SLOT IS A HOLE?
	 FALERR	(NHL,DELDHO)
	LDB	T3,DEYRPS	;GET POSITION
	ADD	T3,DEVRET(F)	; OF SLOT IN
	SUBI	T3,DEVRBN(F)	; RIB, AND
	PUSH	P,T3		; SAVE IT.
	SETZ	T2,		;
	MOVEI	T4,RIBPFS	;CHECK TO SEE IF WE
	SKIPE	%RIB+RIBRIB	; CAN GET
	 MOVEI	T4,RIBSFS	; THE PREVIOUS
	CAMLE	T3,T4		; PNTR, SO
	 MOVE	T2,%RIB-1(T3)	; WE CAN BE CONTIGUOUS.
	TLZ	T2,RBMASK-RBREAL;T2 has retrieval pointer or zero
	MOVEI	P1,FLG.CC	;OK to stop on Control-C
	PUSHJ	P,CREPAG	;Create the page
	  JRST	[POP P,T3	;ERROR RETURN, CLR PDL.
		MOVEI T1,FALAQA	;FLAG CAN'T GET A PAGE.
		JRST DELDHO]	;ERROR EXIT.
	POP	P,T3		;RESTORE PLACE IN RIB.
	MOVE	S,DEVIOS(F)	;DID THE FILE GO BAD WHILE WE
	TLNE	S,IOBDRB	;WAITED IN CREPAG?
	 JRST	[MOVEI T1,FALRBE ;YES.
		 JRST  DELDHO]	;
	MOVEM	T2,%RIB(T3)	;NO.  STORE NEW PAGE IN RIB,
	MOVEM	T2,@DEVRET(F)	; OUR DDB, AND
	PUSHJ	P,ONESLT	; OTHER DDBS.
	JUMPN	P4,CREOUT	;IF THIS IS NOT SIMIO, THEN
	PUSHJ	P,RONDUP	;MAYBE ROUND UP THE FILE SIZE.
CREOUT:	PUSHJ	P,RELSAT	;RELEASE THE SAT.
	PUSHJ	P,UNLFIL	;RELEASE THE FILE.
	PUSHJ	P,RELRIB	;RELEASE THE RIB.
	POP	P,M		;RESTORE M.
	JRST	CPOPJ1		;SUCCESS RETURN.



COMMENT #
@@SUBROUTINE RONDUP
@@PURPOSE
TINY SUBR TO ROUND UP FILE SIZE TO A PAGE BOUNDARY, IF
WE JUST CREATED, EXCHANGED, OR DELETED THE LAST PAGE OF THE
FILE.
CALLED BY FCREATE, FEXCH, AND FDELETE.
@@ENTRY
EXPECTS M/ PAGE NO. JUST TOUCHED, AND F/ DDB.
@@ACCUM
DESTROYS T1 AND T2.
@@EXIT
ALWAYS POPJS.
@@ #

RONDUP:	HRRZ	T2,DEVATB(F)	;CALC T1/
	LDB	T1,ATYBSZ	;THE NUMBER OF
	ADDI	T1,3		;THE LAST
	LSH	T1,B2PLSH	;PAGE IN THE FILE.
	CAMLE	T1,M		;M LESS THAN LAST PAGE?
	 POPJ	P,		;YES.
	MOVE	T1,M		;NO, ROUND
	LSH	T1,ATSWRD+ATSBLK ;UP THE
	MOVEM	T1,ATBSIZ(T2)	;FILE SIZE TO THE EO THIS
	POPJ	P,		;PAGE.
SUBTTL KMOVPG

COMMENT #
@@SUBROUTINE KMOVPG
@@PURPOSE
KERNEL ROUTINE USED TO TAKE A PAGE WHICH IS MAPPED AND NOT CURRENTLY
PART OF A FILE AND CAUSE IT TO BE MAPPABLE FROM THE SPECIFIED POSITION
IN THE FILE OPEN ON THE CHANNEL.  USEFUL FOR MOVING PAGES FROM ONE FILE
TO ANOTHER, OR FOR MOVING A PRIVATE PAGE INTO A FILE.
@@ENTRY
T1/ USER'S VP SPECIFICATION, T2/FILE PAGE LOCATION TO BEGIN INSERTING
SIGN BIT OF T1 ON IFF USER MODE CALLER.
J/ TARGET FRAME NUMBER, CONTEXT PAGES IN %UPX
F/ DDB
@@ACCUM
DESTROYS P1-P4, T1-T4, U, AND PG.
@@EXIT
SKIP RETURNS IF SUCCESSFUL.
NON-SKIP RETURN IF ERROR, WITH LH(T1) CONTAINING THE VP NUMBER ON WHICH
THE FAILURE OCCURRED, AND RH(T1) CONTAINS THE ERROR CODE.
@@FUNCTION
FOR EACH VP
  IF VP IS NON-EXISTENT OR SUPER, GIVE ERROR RETURN.
  IF DP HAS OTHER USERS, CONVERT VP TO PRIVATE USING COPY-ON-WRITE AND
    GO UP TO TOP
  IF VP IS A PRIVATE VIRGIN PAGE, VIOLATE IT.
  IF VP IS PRIVATE (WAS NEVER IN A FILE) DO VALIDATE START.
    (HAVE TO MAKE SURE DISK DATA IS NOT LEFTOVER FROM LAST USER OF DP)
  GET ATOMIC FILE LOCK FOR WRITE (WILL BE CHANGING ALLOCATION OF FILE)
  IF FILE IS APPEND ONLY AND FIRST PAGE TO INSERT IS BELOW END OF FILE, GIVE
    ERROR RETURN.
  EXTEND FILE OUT TO LAST PAGE USER REQUESTED TO INSERT WITH HOLES.
FOR EACH VP
  IF PAGE IS PRIVATE, DO VALIDATE/WAIT.
  IF CALLER IS USER MODE AND DIRECTORY IS OVER QUOTA, GIVE ERROR RETURN.
  GET SAT COMPLETELY LOCKED FOR VP'S DP. IF F BIT ALREADY ON, GIVE ERROR RETURN.
  GET RIB CONTAINING SPECIFIED FP MAPPED WRITE LOCKED.
  IF SPECIFIED FP ALREADY EXISTS, GIVE ERROR RETURN.
  SET F BIT FOR DP.
  PUT RETRIEVAL POINTER IN RIB AND DDB.
  CHARGE DP AGAINST FILE'S DIRECTORY'S QUOTA.
  CALL DECUNS TO DISCONNECT VP FROM ITS OLD ATB IF ITS UNSHARED.
  INCREMENT UMC, MXW FOR NEW ATB.
  IF SLOT IS ACTIVE, SET PGYATB TO NEW ATB, CLEAR PGYSPT
  IF SLOT IS INACTIVE, SET DP AND ATB IN THE SLOT.
@@#
EXTERNAL ATBSTS,ATBMWC,ATPMXU,ATMMWC,ATYBSZ,CNVATB,DABBIT
EXTERNAL DECUMC,DEVATB,DEVRBN,DEVRET,DEYRPS,DECUNS
EXTERNAL GETATB,GETCPA,GETDPA,GETLMA,GETSAT,GETSPT
EXTERNAL INCUMC,IOBDRB
EXTERNAL LM3ATB,LM3CUR,LMMEXS,LMPACT,LMPMXW,LMPSHR,LMPSUP
EXTERNAL MAPCML,NOWRT,PGYATB,PGYSPT,RBREAL,SETACH
EXTERNAL REDLMA,REMSPT,SPMUSC,SPTUSC,STOLMA,TSTVIR
EXTERNAL UPDAC0,VALID,VL.VPP,VL.WAT,VLIOE%,UPTJOB

KMOVPG::PUSHJ	P,SETARR	;W/PGE, P2/COUNT, P1/BITS
	  POPJ	P,		;BAD ARG FROM USER, GIVE ERROR RETURN
	MOVE	M,T2		;GET FP NUMBER IN T2
	JUMPE	M,KMOVBF	;IF ARG EQ 0, ITS BAD, GIVE ERROR.
	CAMGE	M,[-1]		;-1 MEANS AT END OF FILE
	  JRST	KMOVBF		;NO GOOD.
	PUSH	P,W		;SAVE ARGS FOR LOOP LATER
	PUSH	P,M
	PUSH	P,P1
	PUSH	P,P2
	PUSH	P,F		;SAVE DDB ADDRESS
	PUSH	P,W
	PUSH	P,P2		;FIRST LOOP DEALS ONLY WITH VPS
KMOVP1:	PUSHJ	P,REDLMA	;GET LMAP SLOT
	TLNN	P3,LMMEXS	;DOES PAGE EXIST?
	 JRST	KMOVEE		;NO, GO GIVE NON-EXIST ERROR.
	TLNE	P3,LMPSUP	;IF SUPER PAGE, GIVE ERROR RETURN.
	 JRST	KMOVSE
	PUSHJ	P,GETATB	;GET ATB ADDRESS
	SKIPL	ATBSTS(T1)	;SKIP IF ITS PRIVATE
	 JRST	KMOVP2		;NOT PRIVATE, DONT'T HAVE TO VIOLATE IT
	PUSHJ	P,TSTVIR	;IS SLOT VIRGIN?
	  JRST	KMOVNV		;NO.
	PUSHJ	P,VPADR		;TAKE PAGE IN W AND MAKE ADDR OUT OF IT IN T1,
				; AND WET PC.UIO PROPERLY FOR A REFERENCE.
	UMOVE	T1,(T1)		;AND CAUSE VIRGIN PAGE TO BE VIOLATED.
			;NOTE CANNOT ASSUME PAGE NOT DIRTY WHEN WE COME BACK.

;STILL HAVE CONTEXT PAGE LOCK AND DOING UMOVE

KMOVNV:	HRRZ	T1,W		;GET PAGE
	HRLI	T1,VL.VPP+1	;SETUP ARG
	PUSHJ	P,VALID		;MAKE SURE PAGE NO LONGER DIRTY
	  JRST	KMOVVE		;VALIDATE ERROR.
KMOVP2:	AOS	W,-1(P)		;STEP TO NEXT VP NUMBER
	SOSLE	(P)		;DECREMENT COUNT, AND JUMP IF
	 JRST	KMOVP1		;MORE TO GO
	POP	P,T1
	POP	P,T1		;GET USED JUNK OFF THE STACK.
;NOW ALL PRIVATE PAGES THAT WERE DIRTY HAVE BEEN STARTED OUT, NO SUPER
; PAGES FOUND IN RANGE, THEY ALL EXIST, NO VIRGIN PRIVATE PAGES ANYMORE.

	MOVE	F,(P)		;GET F BACK
	MOVE	W,-4(P)		;IN CASE OF ERROR RETURN.
	MOVEI	T3,KMOVPG	;STUPID CODE FOR DELXCH.
	PUSHJ	P,DELXCH	;RETURN T4 HPW, FILE LOCKED UNMODIFIED
	  JRST	KMOVXE		;ERROR CODE ALREADY IN T1.
	PUSHJ	P,SETACH	;ASSUME FILE'S ALLOCATION WILL CHANGE.
	SKIPGE	M,-3(P)		;Get back first FP to do (may be -1)
	 MOVEI	M,1(T4)		;If -1, set up HPW+1
	MOVEM	M,-3(P)		;In case -1, save correct first FP
	ADD	M,-1(P)		;GET LAST FP + 1
	SUBI	M,1		;CONVERT TO LAST FP WANT TO CREATE.
	CAMLE	M,T4		;SKIP IF LAST PAGE WE WANT TO INSERT
				; TO FILE IS NOT BEYOND HPW
	  JRST	KMOVPH		;IS BEYOND, MUST CREATE HOLES FOR NEW PAGES
	HLLZ	T1,DEVIAD(F)	;IS TOTALLY WITHIN FILE, CHECK FOR APPEND ONLY
	TLNE	T1,NOWRT	;SKIP IF NOT APPEND ONLY
	 JRST	KMOVNA		;SORRY, CANT TOUCH BELOW HPW
	JRST	KMOVNH		;OK, LET IT THROUGH.

KMOVPH:	PUSHJ	P,LOKHPW	;GET FILE LOCKED PROPERLY.
	  JRST	KMOVBR		;BAD RIB, TAKE CARE OF IT
;IF T1 IS NEGATIVE, MEANS FILE SIZE CHANGED SUCH THAT REQUESTED FP NO LONGER
; ABOVE HIGHEST EXISTING FILE PAGE.
	JUMPL	T1,KMOVNH	
; Upon return from LOKHPW, T4 still has HPW, and M contains highest FP
; to be inserted.
	EXCH	T4,M		;T4 gets highest FP to insert
	ADDI	M,1		;M gets first FP to insert

	HRRZ	T2,DEVATB(F)	;GET ATB ADDRESS IN T2
	LDB	T3,ATYBSZ
	ADDI	T3,3
	LSH	T3,B2PLSH	;T3/HPW AGAIN.
	HLLZ	T1,DEVIAD(F)	;GET NOWRT BIT
	TLNE	T1,NOWRT	;IF FILE IS APPEND ONLY AND
	CAMLE	M,T3		;FIRST PAGE TO INSERT IS BELOW HPW,
	 JRST	.+2		;(OK, INSERTING ABOVE CURRENT EOF)
	  JRST	KMOVNA		;APPEND ONLY AND THIS IS NOT APPEND
	AOS	M,T3		;FIRST PAGE TO CREATE IS HPW+1
	SUB	T4,M		;NUMBER OF HOLES TO DO IS LAST FP TO INSERT
	ADDI	T4,1		;-(HPW+1)+1. (CREATE HOLES FROM HPW+1 TO LAST FP)
	SETO	T1,		;DON'T STOP ON CONTROL C (TOO BAD)
	PUSHJ	P,SWEPRH	;CREATE HOLES SO WE CAN INSERT DPS LATER.
	  JRST	[CAIE T1,FALAQA	;DISK FULL OR QUOTA EXCEEDED OR
		 CAIN T1,FALRBE	;RIB ERROR?
		   JRST KMOVXE	;YES, GO GIVE PROPER ERROR RETURN.
		 STOPCD (SLO)]	;;KMOVPH+23
	PUSHJ	P,RELRIB	;GET RID OF RIB IN CASE USETST HAS TO GET IT BELOW.
;NOW WE ARE GUARANTEED THAT THERE ARE RIB SLOTS FOR ALL PAGES WE WISH TO INSERT.

KMOVNH:	MOVE	W,-4(P)		;RESTORE ORIGINAL W AND
	MOVE	M,-3(P)		;M
KMOVP3:	PUSHJ	P,REDLMA	;GET LMAP SLOT
	PUSHJ	P,GETATB
	SKIPL	ATBSTS(T1)	;SKIP IF ITS PRIVATE
	 JRST	KMOV2N		;NOT PRIVATE.
	PUSH	P,W
	PUSH	P,M
	HRRZ	T1,W
	HRLI	T1,VL.WAT+VL.VPP+1 ;WAIT, DO IT FOR PRIVATE PAGE, COUNT OF 1.
	PUSHJ	P,VALID		;DO IT
	  JRST	KMOVVE		;VALIDATE ERROR
	POP	P,M
	POP	P,W
	MOVE	F,(P)		;RESTORE F
KMOV2N:	TLNE	F,GETB		;IF GETB ON, DON'T CHECK FOR QUOTA
	 JRST	KMOV3N
	PUSHJ	P,CHKQTA	;SEE IF CAN ALLOCATE IN C(F)'S DIRECTORY
	  JRST	KMOVOQ		;OVER QUOTA IN THIS DIRECTORY.
	PUSHJ	P,USETST	;GET DDB SETUP TO SLOT POINTED TO BY M
	  JRST	KMOVBR		;BAD RIB.
	MOVE	T2,@DEVRET(F)	;GET CONTENTS OF THAT SLOT
	TLNE	T2,RBREAL	;IS SLOT A HOLE?
	 JRST	KMVNHO		;NO
	PUSHJ	P,REDLMA	;GET LMAP SLOT IN P3 AND P4 AGAIN, DELCRE RESCHEDULES

	PUSHJ	P,GETDPA	;GET DISK ADDRESS IN T2
	TLO	T2,RBREAL	;MAKE ACCEPTABLE TO GETSAT
	PUSH	P,T2		;SAVE RETRIEVAL POINTER FOR LATER.
	MOVEI	T1,MAPCML	;MAP COMPLETELY LOCKED - THE SAT PCB LOCK IS WHAT
				; KEEPS DP FROM CHANGING STATUS (KEEPS MAPPERS
				; FROM SNEAKING IN AND CHANGING STATUS TO SHARED, ETC)
	PUSHJ	P,GETSAT	;GET SAT, SETUP T1 AND T3
	  JRST	KMOVBS		;GIVE SAT ERROR RETURN.
	TDNE	T1,%SAT+MBITS(T3);M BIT SHOULD BE ON (ZERO)
	 STOPCD (SLO)           ;;KMOV2N+21
	TDNN	T1,%SAT+FBITS(T3);HAS USER SPECIFIED PAGE STILL PART OF A FILE?
	 JRST	KMOVPF		;YES, GIVE HIM THE ERROR RETURN.
	PUSH	P,T1		;REMEMBER WHERE IN SAT TO DIDLE
	PUSH	P,T3		;BECAUSE WE CAN'T SET IT IN CASE PAGE IS SHARED.

;NOW WE KNOW PAGE IS NOT IN A FILE. MAKE SURE ITS NOT SHARED. IF IT IS,
;MUST GET RID OF SAT, TURN PAGE INTO PRIVATE PAGE WITH COPY-ON-WRITE,
;AND TRY AGAIN.  SAT LOCK IS ENOUGH TO MAKE SURE SPT COUNT DOESN'T CHANGE,
;ONLY NEED CB TO MESS WITH ENTIRE SPT STRUCTURE.

KMOV3N:	PUSHJ	P,REDLMA	;GET LMAP SLOT AGAIN
	MOVE	T2,(P)
	TLZ	T2,RBREAL	;GET RID OF IT SO SRCSPT WONT BARF.
	JUMPL	P3,KMOV3A	;IF SLOT IS SHARED, JUST GET SPT ADDRESS FROM SLOT.
	PUSHJ	P,GETATB	;UNSHARED, GET ATB ADDR FROM SLOT
	PUSHJ	P,SRCSPT	;GET SPT ENTRY POINTER IN T1
	  JRST	KMOV3C		;NOT SHARED, NO SPT ENTRY.
	JRST	KMOV3B		;AND CHECK TO SEE IF STILL SHARED.

KMOV3A:	PUSHJ	P,GETSPT	;GET SPT ENTRY ADDRESS IN T1
KMOV3B:	HRRZ	T3,SPTUSC(T1)	;GET USE COUNT IN T3
	CAILE	T3,1		;ITS REALLY UNSHARED IF COUNT IS 1.
	 JRST	KMVMKP		;SHARED, GO MAKE IT PRIVATE.

KMOV3C:	POP	P,T3		;GET SAT BIT AND POS BACK
	POP	P,T1
	ANDCAM	T1,%SAT+FBITS(T3);SET (MAKE 0) F BIT, ITS GOING TO BE IN A FILE NOW.
	POP	P,T2		;(M BIT STILL SET)
	MOVSI	T1,PTRCHG
	IORM	T1,DEVIAD(F)	;MARK OUR DDB AS HAVING CHANGED
	MOVEM	T2,@DEVRET(F)	;SET IN DDB
	PUSHJ	P,ONESLT	;UPDATE OTHER DDBS THAT HAVE THIS FILE POSITION
				;FILE SIZE ALREADY SETUP CORRECTLY FROM SWEPRH.
	PUSHJ	P,RELRIB	;DON'T GIVE UP SAT TILL EVERYTHING IS FIXED.
	HRRZ	T2,DEVATB(F)	;GET ATB ADDRESS IN T2 FOR UPDAC0
	MOVEI	T1,1		;ALLOCATE 1 MORE PAGE TO THIS DIRECTORY
	MOVN	T3,T1		;UPDAC0 NEEDS THIS
	PUSHJ	P,UPDAC0	;ADJUST ATPALP, DRBALC, DRBMXA
	PUSHJ	P,GETLMA	;NOW GET LMAP SLOT FOR C(W)
	PUSHJ	P,GETATB	;GET ATB ADDRESS FOR OLD SLOT
	MOVE	P2,T1		;GET INTO P2 FOR DECUNS
	MOVE	T2,@DEVRET(F)	;GET POINTER BACK, UPDAC0 SMASHED IT
	TLZ	T2,RBREAL	;T2 HAD PTR, CLEAR RBREAL TO GET JUST DP
	PUSHJ	P,DECUNS	;DISCONNECT THAT DP FROM OLD ATB
	 STOPCD			;NOT SUPPOSED TO BE SHARED ANYMORE. ;;KMOV3C+23
	HRRZ	T1,DEVATB(F)	;GET ATB FOR FILE
	PUSHJ	P,INCUMC	;INCREMENT ATBUMC, DRBCNT, ETC. FOR FILE
	HRRZ	T1,DEVATB(F)	;GET NEW ATB ADDRESS AGAIN.
	TLNN	P3,LMPMXW	;MAX WRITE ON?
	 JRST	KMOVP4		;NO
	AOS	T4,ATBMWC(T1)
	TRNN	T4,ATMMWC	;MAKE SURE IT DIDN'T OVERFLOW
	 STOPCD                         ;;KMOV3C+33
	MOVEI	T4,ATPMXU	;SET BIT THAT COVERS ATBMWC NON-ZERO
	IORM	T4,ATBSTS(T1)
KMOVP4:	PUSHJ	P,CNVATB	;CONVERT ATB ADDR IN T1 TO ATB POINTER.
	TLNN	P3,LMPACT	;IS THIS AN ACTIVE SLOT?
	 JRST	KMOVP5		;NO
	PUSHJ	P,GETCPA	;GET CP IN PG
	DPB	T1,PGYATB	;SET IT IN PGY TABLE
	SETZ	T1,		;MAKE SURE PGYSPT IS ZERO, THIS PAGE ISN'T SHARED
	DPB	T1,PGYSPT
	JRST	KMOVP6		;AND GO RELEASE SAT, LOOP

KMOVP5:	DPB	T1,LM3ATB	;SET ATB POINTER IN SLOT
KMOVP6:	PUSHJ	P,STOLMA	;STORE NEW SLOT BACK.
	PUSHJ	P,RELSAT	;NOW GIVE UP SAT SO OTHERS CAN MAP IT AGAIN.
				; (HAD TO WAIT UNTIL PGY STUFF, ETC, FIXED UP SO
				; IT IS SAFE TO MAP IT AGAIN)
				;KEEP ATOMIC FILE LOCK SO FILE SIZE DOESNT CHANGE

	AOS	M,-3(P)		;STEP TO NEXT M AND
	AOS	W,-4(P)		;W
	SOSLE	-1(P)		;DECREMENT REPEAT COUNT AND
	 JRST	KMOVP3		;JUMP IF ANOTHER TO DO.
KMOVEX:	PUSHJ	P,UNLFIL	;UNLOCK FILE NOW.
	POP	P,F
	POP	P,P2
	POP	P,P1
	POP	P,M
	POP	P,W		;GET RID OF ALL JUNK ON STACK
	JRST	CPOPJ1		;AND GIVE SKIP RETURN.
;HERE IF DISCOVERED THAT PAGE WAS SHARED AFTER GETTING SAT. USE TRICK
; OF MAKING PAGE COPY-ON-WRITE AND WRITING INTO IT TO MAKE IT
; UNSHARED AGAIN, AND START AT TOP OF THE SECOND FOR EACH VP LOOP.
;VP NUMBERT IN W.

KMVMKP:	POP	P,T3		;GET SAT BIT AND POS BACK OFF
	POP	P,T1		;WE WONT USE THEM ANYMORE.
	POP	P,T2		;GET DP OFF STACK, THROW IT AWAY.
	PUSHJ	P,RELSAT
	PUSHJ	P,RELRIB	;GET RID OF EVERYTHING.
	PUSHJ	P,UNLFIL	;GET RID OF FILE LOCK (NOW WE HAVE TO GO THRU
				; STUFF ABOUT HPW, SINCE ALLOCATION/DEALLOCATION
				; CAN HAPPEN NOW.
	PUSHJ	P,GETLMA	;GET SLOT OFFICIALLY.
	LDB	P1,LM3CUR	;GET PROTECTION IT HAS NOW
	MOVEI	T2,CPRCOW	;SET CURRENT PROTECTION TO COPY ON WRITE
	DPB	T2,LM3CUR
	TLNE	P3,LMPACT	;IF ACTIVE,
	 TRZ	P4,PGE.W	;RESET WRITE BIT SO IT WILL FAULT.
	PUSHJ	P,STOLMA	;SET IT BACK IN SLOT.
	PUSHJ	P,VPADR		;GET ADDR TO REF VP IN T1
	XCTBU	<SETMM (T1)>	;WRITE INTO THE PAGE, MAKING IT PRIVATE.
	PUSHJ	P,GETLMA	;GET SLOT AGAIN
	DPB	P1,LM3CUR	;RESTORE OLD PROTECTION
	TLNE	P3,LMPACT	;AND IF ACTIVE,
	 TRZ	P4,PGE.W	;CLEAR WRITE BIT IN CASE OLD PROT WASN'T R/W
	PUSHJ	P,STOLMA	;SET SLOT BACK.
	JRST	KMOVP3		;NOW TO TOP OF FOR EACH VP LOOP TO DO CHECKS ON
				; FILE AGAIN, VALIDATE.

;LITTLE ROUTINE TO TAKE PAGE NUMBER IN W, CONVERT TO REFERENCE ADDRESS AND SET USER IOT
; BIT PROPERLY.

VPADR:	HRRZ	T1,W		;GET PAGE NUMBER
	CAIGE	T1,1000		;IF USER PAGE
	 JRSTF	@[PC.UIO,,.+2]	;SET USER IOT AND SKIP
	SUBI	T1,CNVVPN	;ELSE CONVERT TO HARDWARE PAGE NUMBER
				; (USER IOT SET BECAUSE CALLER WAS EXEC MODE)
	LSH	T1,^D9		;TURN INTO ADDRESS.
	POPJ	P,		;AND RETURN.

;VARIOUS ERROR RETURNS, NEED TO GET STUFF OFF STACK AND UNLOCK.
; ERROR CODE ALWAYS IN RH(T1), VP IN W.

;HERE ON ERROR RETURN FROM VALIDATE.

KMOVVE:	MOVEI	T1,(T1)		;GET ERROR CODE
	CAIE	T1,VLIOE%	;IS IT I/O ERROR?
	 STOPCD			;NO, SOMETHING ELSE WENT WRONG. ;;KMOVVE+2
KMOVPE:	POP	P,T2
	POP	P,T2		;ALWAYS 2 EXTRA THINGS ON THE STACK.
KMOVXE:	PUSHJ	P,UNLFIL	;IN CASE WE HAVE FILE LOCK. (F BETTER BE SETUP)
	POP	P,F
	POP	P,P2
	POP	P,P1
	POP	P,M
	HRLI	T1,(W)		;GET FAILING VP IN LH T1
	POP	P,W
	POPJ	P,		;AND GIVE ERROR RETURN.

;NON-EXISTENT PAGE
KMOVSE:	SKIPA	T1,[FALNSE]	;TRYING TO STICK SUPERMAPPED PAGE INTO FILE.
				;(MAYBE SOMEDAY ALLOW THIS UNDER PROPER CONDITIONS)
KMOVEE:	MOVEI	T1,FALNEX
	JRST	KMOVPE		;POP 2 THINGS OFF STACK AND GIVE ERROR.
;BAD RIB
KMOVBR:	MOVEI	T1,FALRBE
	JRST	KMOVXE

KMOVOQ:	MOVEI	T1,FALAQA
	JRST	KMOVXE

KMVNHO:	PUSHJ	P,RELRIB	;GET RID OF RIB
	MOVEI	T1,FALNHL
	JRST	KMOVXE		;GET T1 AND T3 OFF STACK TOO.

KMOVBF:	MOVEI	T1,FALFPZ
	HRLI	T1,(W)
	POPJ	P,

KMOVPF:	POP	P,T2		;GET RID OF DP ON STACK
	PUSHJ	P,RELRIB
	PUSHJ	P,RELSAT	;GET RID OF RIB AND SAT
	MOVEI	T1,FALALF	;ALREADY IN A FILE
	JRST	KMOVXE

KMOVBS:	POP	P,T2
	PUSHJ	P,RELRIB
	MOVEI	T1,FALBDS
	JRST	KMOVXE

KMVELK:	PUSH	P,T1
	PUSHJ	P,RELRIB	;GET RID OF RIB AND SAT IF HAVE THEM
	PUSHJ	P,RELSAT
	POP	P,T1		;RESTORE ERROR CODE
	POP	P,T2		;GET T2 OFF STACK
	JRST	KMOVPE		;POP T1 AND T3 OFF STACK AND RETURN.

KMOVNA:	MOVEI	T1,FALNWT
	JRST	KMOVXE
COMMENT #
@@SUBROUTINE LOKHPW
@@PURPOSE
COMMON ROUTINE USED BY KFCRE AND KMOVPG. WHEN THESE KERNEL ROUTINES DISCOVER
 THAT A SLOT PAST HIGHEST PAGE WRITTEN (HPW) IS NEEDED, THEY ONLY HAVE THE
 ATOMIC FILE LOCK IN READ MODE. SINCE MIGHT BE CHANGING RIB STRUCTURE,
 HAVE TO GET FILE WRITE LOCKED, MAKING SURE SIZE DIDN'T CHANGE OR FILE
 DIDN'T GO BAD WHILE WAITING.
@@ENTRY
M/-1 TO INDICATE HPW+1 OR HIGHEST FP THAT WILL BE CREATED/INSERTED INTO FILE.
@@ACCUM T1-T3
@@EXIT NON-SKIP IF FILE GOT RIB ERROR WHILE WAITING FOR ATOMIC LOCK
SKIP RETURN WITH T1<0 IFF HIGHEST FP IS NOW BELOW HIGHEST PAGE THAT EXISTS
IN THE FILE. IF M/-1 ON ENTRY, CHANGE TO CURRENT HPW+1 OF FILE, ELSE
RETURN VALUE OF M UNCHANGED (HIGHEST FP TO BE INSERTED INTO FILE)
@@FUNCTION
SAVE OLD FILE SIZE (IN BLOCKS). RELEASE FILE READ LOCK, GET FILE WRITE LOCKED.
GIVE NON-SKIP IF RIB IS BAD NOW. ELSE IF M/-1, SET M TO BE THE HIGHEST PAGE
EXISTING IN THE FILE NOW + 1, T1/>=0, AND SKIP RETURN.
IF M/>=0, IF SIZE HASNT CHANGED JUST GIVE SKIP RETURN AND
FILE WRITE LOCKED. IF SIZE HAS CHANGED AND FP IN M IS NO LONGER ABOVE HIGHEST
EXISTING PAGE IN FILE, CHANGE LOCK BACK TO READ, SET T1/-1, AND SKIP RETURN.
IF FP IN M IS STILL ABOVE HIGHEST EXISTING PAGE, SKIP RETURN WITH
T1/NOT -1.
@@#

PRINTF([Need to convert KCREAT code at CREAT2 to use LOKHPW routine.])

LOKHPW:	HRRZ	T2,DEVATB(F)	;SAVE FILE SIZE
	LDB	T1,ATYBSZ	;FOR CHECK.
	PUSHJ	P,UNLFIL	;UNLOCK BEFORE LOCK MODIFY.
	MOVEM	S,DEVIOS(F)	;
	PUSHJ	P,LOKMOD	;GET LOCKED MODIFY.
	MOVE	S,DEVIOS(F)	;FILE DIED WHILE
	TLNE	S,IOBDRB	; WAITING?
	 POPJ	P,		;YES, GIVE ERROR RETURN.
	LDB	T3,ATYBSZ	;GET CURRENT FILE SIZE.
	JUMPGE	M,LOKHP1	;JUMP UNLESS LAST+1.
	ADDI	T3,3		;CALC THE
	LSH	T3,B2PLSH	; LAST PAGE
	ADDI	T3,1		; +1.
	MOVE	M,T3		;AND PUT INTO M.
	JRST	CPOPJ1		;GIVE SKIP RETURN

LOKHP1:	CAMN	T1,T3		;CHANGED WHILE WE WAITED?
	JRST	CPOPJ1		;NO, JUST GIVE SKIP, T1 NOT -1.
	ADDI	T3,3		;YES.
	LSH	T3,B2PLSH	;
	CAMLE	M,T3		;REQUESTED FP NOW BELOW HIGHEST EXISTING PAGE?
	 JRST	CPOPJ1		;NO, JUST GIVE SKIP WITH T1/NOT -1
	PUSHJ	P,LOKLES	;
	SETO	T1,		;MAKE T1 NEGATIVE AS SIGN FOR CALLER TO NOT EXTEND
	JRST	CPOPJ1		;FILE AND RETURN.
COMMENT #
@@SUBROUTINE KFTRN
@@PURPOSE
KERNEL SUBROUTINE TO TRUNCATE A FILE'S SIZE.
DOES NOT CLEAR OUT THE END OF THE LAST PAGE.
CALLS DLTTCI TO DELETE PAGES AFTER PAGE CONTAINING NEW EOF (IF ANY).
(USED TO ONLY ALLOW WITHIN THE LAST PAGE, NOW ALLOWS WITHIN ANY
EXISTING PAGE OR HOLE)
@@ENTRY
EXPECTS T1/ USER ARG (THE NEW FILE SIZE IN WORDS.).
ALSO EXPECTS F/ DDB AND S/ DEVIOS.
@@ACCUM
DESTROYS T1-T4, P1-P4, U, AND PG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON NON-SKIP RETURN, T1 CONTAINS THE ERROR FLAG AS FOLLOWS:
FALNOF, FALRBE, FALNWT, FALFPZ, FALPHP, FALNSP.
@@#

EXTERN	RELLOK,DLTTCI

KFTRN::	MOVE	T2,T1		;GET T1/
	LSH	T1,W2PLSH	; THE
	TRNE	T2,777		; REQUESTED
	 ADDI	T1,1		; HPW.
	MOVEI	T3,KFTRN	;CHECK FILE FOR WRITING
	PUSHJ	P,DELXCH	;MODIFY IT, GET T1/ USER ARG
	  POPJ	P,		;IN WORDS, T4/ HPW.
	HRRZ	P2,DEVATB(F)	;GET ATB POINTER
	CAMN	T1,T4		;MUST BE IN THE SAME PAGE.
	 JRST	KFTRN1		;SAME PAGE - DON'T CALL DLTTCI
	PUSH	P,T2		;SAVE T2 FROM DLTTCI
	MOVE	T2,T1		;POSITION ARG
	LSH	T2,11		;SETUP # WORDS TO KEEP
	PUSHJ	P,DLTTCI	;TRUNCATE!
	  JRST	[POP P,T1	;FIXUP STACK
		MOVEI T1,FALRBE	;ERROR CODE
		POPJ P,]
	PUSHJ	P,RELLOK	;GET RID OF THE RIB (IN %RIB)
	POP	P,T2
KFTRN1:	TRNE	T2,177		;OKAY, STORE
	 ADDI	T2,200		;THE NEW
	MOVEM	T2,ATBSIZ(P2)	;SIZE, AND
	PUSHJ	P,UNLFIL	;UNLOCK THE FILE.
	JRST	CPOPJ1		;SUCCESS RETURN.
COMMENT #
@@SUBROUTINE KFDEL
@@PURPOSE
KERNEL SUBR TO TURN A FILE PAGE INTO A HOLE.
@@ENTRY
EXPECTS T1/ USER ARG, T3/ BIT 0 SET IFF CALLED FROM USER MODE,
AND ALSO F/ DDB AND S/ DEVIOS.
@@ACCUM
DESTROYS T1 THRU T4, U, AND PG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON NON-SKIP RETURN, T1 CONTAINS THE ERROR FLAG AS FOLLOWS:
FALFPZ,FALPHP,FALRBE,FALHOL,FALNOF,FALNWT.
@@ #


KFDEL::	MOVEI	T3,KFDEL	;
	PUSHJ	P,DELXCH	;CHK & LOCK FILE, GET
	  POPJ	P,		;T1/ 1ST ARG.
	PUSH	P,M		;SAVE M.
	MOVE	M,T1		;GET DDB AND RIB
	PUSHJ	P,SETACH	;MARK FILE AS ALLOCATION CHANGED
	PUSHJ	P,DELCRE	;SET UP AND UPDATED.
	  JRST	DLXDR0		;
	TLNN	T2,RBREAL	;ALREADY A HOLE?
	 JRST	[MOVEI T1,FALHOL ;YES.
		JRST DELDHO]	;
	PUSH	P,@DEVRET(F)	;SAVE PAGE WE ARE THROWING AWAY.
	MOVEI	T2,'CAT'	;PUT
	LDB	T1,DEYRPS	; HOLE
	ADD	T1,DEVRET(F)	; IN
	SUBI	T1,DEVRBN(F)	; THE
	MOVEM	T2,%RIB(T1)	; RIB,
	MOVEM	T2,@DEVRET(F)	; OUR DDB, AND
	PUSHJ	P,ONESLT 	; OTHER DDBS.
	PUSHJ	P,RONDUP	;MAYBE ROUND UP THE FILE SIZE.
	PUSHJ	P,UNLFIL	;UNLOCK THE FILE.
	PUSHJ	P,RELRIB	;RELEASE THE RIB.
	POP	P,T2		;RESTORE THE GIVEN AWAY PAGE.
	PUSHJ	P,GIVPAG	;DEALLOCATE IT.
	POP	P,M		;
	JRST	CPOPJ1		;SUCCESS RETURN.


    ;HERE ON SOME ERROR EXITS.
DLXDR1:	PUSHJ	P,UNLFIL	;
DLXDR0:	POP	P,M		;
	PUSHJ	P,RELSAT	;
	MOVEI	T1,FALRBE	;
	POPJ	P,

DELDHO:	POP	P,M		;
	PUSH	P,T1		;
	PUSHJ	P,UNLFIL	;
	PUSHJ	P,RELRIB	;
	PUSHJ	P,RELRB2	;
	PUSHJ	P,RELSAT	;
	POP	P,T1		;
	POPJ	P,




COMMENT #
@@SUBROUTINE DELCRE
@@PURPOSE
LITTLE COMMON SUBR FOR HANDLING ONE SLOT IN AN ISOLATED RIB.
@@ENTRY
EXPECTS F/ DDB AND M/ FILE PAGE NUMBER OF INTEREST (<=HPW).
@@ACCUM
DESTROYS T1-T4, U, AND PG.
@@EXIT
ON SUCCESS, SKIP RETURNS WITH DDB
SET UP, RIB LOCKED IN CORE, ALL DDBS FLUSHED INTO RIB, AND
T2/ RETRIEVAL PNTR.
NON-SKIP RETURNS ON RIB ERROR AND HAS KILLED THE FILE.
@@ #

DELCRE:	PUSHJ	P,USETST	;POINT TO PAGE M IN THE DDB.
	  POPJ	P,		;
	MOVE	T1,DEVRIB(F)	;GET THE RIB FOR PAGE M
	PUSHJ	P,MWLRIB	;WRITE LOCKED.
	  PJRST	KILFIL		;
	SKIPG	T2,@DEVRET(F)	;LEGAL POINTER?
	 STOPCD                         ;;DELCRE+6
	SETZ	T1,		;WRITE OUT THE OTHER DDBS WITH
	PUSHJ	P,FLUSH		;PTRCHG ON, AND THEN
	PUSHJ	P,PTROU0	;WRITE US OUT, TOO.
	MOVE	T2,@DEVRET(F)	;
	JRST	CPOPJ1		;


COMMENT #
@@SUBROUTINE DELXCH
@@PURPOSE
SMALL SUBR CALLED AT START OF FDEL, FEXCH, FTRNC, AND FCREATE
TO BE SURE THE FILE IS WRITEABLE AND TO SET SOME STUFF UP.
@@ENTRY
EXPECTS F/ DDB AND T3/ KFDEL, KFCREE, KFEXC, OR KFTRN.
@@ACCUM
SUCCESS RETURN DESTROYS ONLY T3 AND T4.
FAIL RETURN DESTROYS ALSO T1.
@@EXIT
NON-SKIP RETURNS ON ERROR, WITH ERROR FLAG IN T1.
SKIP RETURNS IF OKAY, WITH T4/ NUMBER OF HPW.
@@ #


DELXCH:	TLNN	F,ENTRB!LOOKB	;IS THERE A FILE ON THIS CHANNEL?
	 JRST	[MOVEI T1,FALNOF ;NO.
		POPJ P,]	;
	TLNE	S,IOBDRB	;DEAD RIB?
	 JRST	[MOVEI T1,FALRBE ;
		POPJ P,]	;
	HLLZ	T4,DEVIAD(F)
	TLNN	F,ENTRB		;HAS IT BEEN ENTERED?
	 JRST	[MOVEI T1,FALNWT ;NO.
		POPJ P,]
	TLNN	T4,NOWRT	;YES.  IS IT APPEND ONLY?
	 JRST	DELXC4		;NO.
	CAIN	T3,KFTRN	;YES, NOT CORRECTLY
	 JRST	DELXC2		; WRITEABLE IF
	CAIE	T3,KFDEL	; DELETE,
	CAIN	T3,KFEXC	; EXCH, OR TRUNCATE.
				;KMOVPG CHECKS FOR ITSELF.
DELXC2:	JRST	[MOVEI T1,FALNWT ;
		POPJ P,]	;
DELXC4:	CAIN	T3,KFTRN	;DON'T LOCK IF TRUNCATE
	 JRST	[PUSHJ P,LOKMOD ;KFTRN NEEDS THE MODIFY LOCK
		 JRST DELXC5]
	PUSHJ	P,LOKUNM	;LOCK FOR UNMODIFYING.
DELXC5:	MOVE	S,DEVIOS(F)	;
	TLNE	S,IOBDRB	;CHECK IF FILE DIED WHILE WAITING
	 JRST	[PUSHJ P,UNLFIL	;
		MOVEI T1,FALRBE ;
		POPJ P,]	;
	PUSH	P,T2		;SAVE T2.
	HRRZ	T2,DEVATB(F)	;GET
	JUMPN	T2,.+2		;T4/
	 STOPCD                         ;;DELXC4+11
	LDB	T4,ATYBSZ	; THE
	ADDI	T4,3		; NUMBER OF THE
	LSH	T4,B2PLSH	; HPW.
	POP	P,T2		;RESTORE T2.
	CAIE	T3,KMOVPG	;DON'T CHECK THIS IF ITS KMOVPG.
	CAIN	T3,KFCREE	;CHECK FILE NO. ARG?
	 JRST	CPOPJ1		;NO.
	JUMPLE	T1,[MOVEI T1,FALFPZ ;YES.  BETTER NOT BE <= 0
		JRST UNLFIL]	;
	CAMG	T1,T4		;OR > HPW
	 JRST	CPOPJ1		;SUCCESS RETURN.
	MOVEI	T1,FALPHP	;
	JRST	UNLFIL		;
COMMENT #
@@SUBROUTINE KFEXC
@@PURPOSE
KERNEL SUBR TO EXCH TWO FILE PAGES.
@@ENTRY
EXPECTS USER'S ARGS IN T1 AND T2, AND T3/ BIT 0 ON IFF CALLED
FROM USER MODE,
AND ALSO F/ DDB AND S/ DEVIOS.
@@ACCUM
DESTROYS T1-T4, P1-P4, U, M, AND PG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON NON-SKIP RETURN, T1 CONTAINS THE ERROR FLAG AS FOLLOWS:
FALFPZ,FALPHP,FALRBE,FALSAM,FALNOF,FALNWT.
@@ #

KFEXC::	MOVEI	T3,KFEXC	;
	PUSHJ	P,DELXCH	;CHK & LOCK FILE, GET T4/ HPW
	  POPJ	P,		;AND CHK T1/ 1ST ARG.
	JUMPLE	T2,[MOVEI T1,FALFPZ ;2ND ARG MUST ALSO BE >0
		JRST UNLFIL]	;AND
	CAMLE	T2,T4		;<= HPW.
	 JRST	[MOVEI T1,FALPHP ;
		JRST UNLFIL]	;
	CAMN	T1,T2		;REQ PAGES THE SAME PAGE?
	 JRST	[MOVEI T1,FALSAM ;YES.
		JRST UNLFIL]	;

    ;DO WE NEED ONE RIB, OR TWO?
	PUSH	P,M		;SAVE M.
	MOVE	M,T1		;CARRY FILE PAGE NOS. IN
	MOVE	P1,T2		;SAFE ACS.
	SUBI	T1,1		;ARE THE PAGES
	SUBI	T2,1		;IN
	IDIVI	T2,RBLVSP	;THE
	MOVE	T3,T2		;
	IDIVI	T1,RBLVSP	;SAME
	CAMN	T1,T3		;RIB?
	 TDZA	P2,P2		;YES, P2=0 IS FLAG FOR ONLY
	  SETO	P2,		;NEED 1 RIB, ELSE NEED 2 RIBS.

    ;ORDER FILE PAGE NUMBRS TO AVOID DEADLOCK.
	CAMLE	M,P1		;
	 EXCH	M,P1		;

    ;HERE TO GET MIN RIB.  FILE PAGE NOS. ARE IN M AND P1.
EXCHH3:	JUMPE	P2,EXCH35	;IF NEED TWO RIBS IN CORE
	PUSHJ	P,SETACH	;AND SET UFPALC, WAIT FOR UFD TO GO OUT
	PUSH	P,J		;SIMULTANEOUSLY,
	MOVE	J,JOB		;THEN
	PUSHJ	P,GETM2		;FIRST GET
	POP	P,J		;M2 RESOURCE.
EXCH35:	PUSHJ	P,USETST	;SET OUR DDB AND %RIB
	  JRST	EXCDR4		;TO MIN PAGE.
	JUMPN	P2,EXCHH6	;JUMP IF NEED TWO RIBS.

    ;HERE ON NEED ONLY ONE RIB.  MIN RIB WILL BE IN %RIB.
      ;MAKE THE ONE RIB CURRENT AND GET THE "DEYRPSES" INTO
      ;M AND P1.
	MOVE	T1,DEVRIB(F)	;BE SURE THE
	PUSHJ	P,MWLRIB	;RIB IS IN
	  JRST	EXCDRB		;%RIB.
	SETZ	T1,		;UPDATE THE RIB
	PUSHJ	P,FLUSH		;FROM THE DDB AREAS,
	PUSHJ	P,PTROU0	;INCLUDING MAYBE OUR OWN.
	PUSH	P,P1		;SAVE FILE PAGE NOS. FOR
	PUSH	P,M		;ONESLTS BELOW.
	SUB	P1,M		;GET
	LDB	M,DEYRPS	;M/
	SUBI	M,DEVRBN-%RIB(F) ;"DEYRPS" OF
	ADD	M,DEVRET(F)	;MIN OF THE PAGES AND
	ADD	P1,M		;P1/ "DEYRPS" OF MAX PAGE.
	JRST	EXCHH7		;

    ;HERE ON NEED TWO RIBS.  GET THEM BOTH LOCKED INTO CORE
      ;SO WE CAN MAKE THEM CURRENT AND THEN CHANGE THE SLOTS.
EXCHH6:	LDB	T1,DEYRPS	;SAVE
	SUBI	T1,DEVRBN-%RIB(F) ;"DEYRPS"
	ADD	T1,DEVRET(F)	;OF
	PUSH	P,T1		;MIN.
	PUSH	P,DEVRIB(F)	;SAVE DEVRIB OF MIN.
	PUSHJ	P,RELRIB	;DON'T BLOCK USETST.
	EXCH	M,P1		;GET
	PUSHJ	P,USETST	; THE
	  JRST	EXCDR3		; MAX FILE
	SETOM	DEVFLO(F)	; PAGE
	MOVE	T1,DEVRIB(F)	; NO.
	PUSHJ	P,MWLRIB	; RIB
	  JRST	EXCDR1		; INTO
	PUSHJ	P,SMMPXC	; %RB2.
	LDB	T1,DEYRPS	;SAVE AWAY "DEYRPS" OF MAX
	SUBI	T1,DEVRBN-%RB2(F) ;WHILE WE HAVE
	ADD	T1,DEVRET(F)	;THE
	EXCH	T1,(P)		;INFO.
	MOVEM	T1,DEVRIB(F)	;GET THE MIN RIB INTO
	PUSHJ	P,MWLRIB	;%RIB.
	  JRST	EXCDR3		;
	SETZ	T1,		;NOW THAT WE
	PUSHJ	P,FLUSH		;HAVE BOTH
	PUSHJ	P,SMMPXC	;THE RIBS LOCKED
	MOVE	T1,%RIB+RIBSLF	;INTO CORE, WE
	MOVEM	T1,DEVRIB(F)	;CAN
	SETZ	T1,		;UPDATE THEM
	PUSHJ	P,FLUSH		;BOTH.
	EXCH	M,-1(P)		;SAVE FILE PAGE NOS. FOR
	EXCH	P1,(P)		;ONESLTS AND GET DEYRPSES.
	PUSHJ	P,SMMPXC	;GET THE
	HRRZI	T4,(M)		;MIN SLOT
	SUBI	T4,%RIB+1	;PNTR BACK
	DPB	T4,DEYRPS	;INTO
	MOVE	T4,(P)		;%RIB.
	MOVE	T1,%RIB+RIBSLF	;
	MOVEM	T1,DEVRIB(F)	;
	PUSHJ	P,PTRINN	;
	 STOPCD                         ;;EXCHH6+many


    ;HERE WITH 1 OR 2 RIBS, TO EXCHANGE THE PNTRS EVERYWHERE,
      ;AND THEN FINISH UP.  PDL HAS MIN FPN ON TOP, MAX
      ;FPN JUST BELOW.  %RIB AND DDB PNTR AREA HOLD MIN FPN.
      ;M/ "DEYRPS" OF MIN, P1/ "DEYRPS" OF MAX.
EXCHH7:	SKIPLE	P3,(M)		;BOTH RET PNTRS
	SKIPG	P4,(P1)		;LEGAL?
	 STOPCD                         ;;EXCCH7+2
	HRLZI	T2,PTRCHG	;
	IORM	T2,DEVIAD(F)	;
	MOVEM	P4,(M)		;2ND PNTR TO 1ST SLOT IN RIB.
	MOVE	T2,P4		;UPDATE
	POP	P,M		; THE
	PUSHJ	P,ONESLT	; OTHER DDBS.
	MOVEM	P3,(P1)		;STORE 1ST PNTR INTO 2ND
	POP	P,M		;SLOT IN %RIB AND
	PUSHJ	P,RONDUP	;UPDATE THE
	MOVE	T2,P3		;
	JUMPE	P2,EXCH73	;
	MOVE	T1,%RB2+RIBSLF	;
	PUSH	P,DEVRIB(F)	;
	MOVEM	T1,DEVRIB(F)	;
EXCH73:	PUSHJ	P,ONESLT	;OTHER DDBS.
	MOVEM	P4,@DEVRET(F)	;OLD MAX TO MIN DDB SLOT.
	JUMPE	P2,EXCH7A	;
	POP	P,DEVRIB(F)	;
	JRST	EXCHOT		;

EXCH7A:	MOVE	T1,F		;IF ONLY ONE RIB,
	MOVE	T3,DEVFLO(F)	; POSSIBLY WE HAVE
	PUSHJ	P,FINDM		; TO
	JRST	EXCHOT		; UPDATE THE OTHER
	JUMPN	T2,EXCHOT	; SLOT IN
	MOVEM	P3,(T3)		; OUR DDB.
EXCHOT:	PUSHJ	P,RELRIB	;JUST ABOUT DONE. REL THE RIB,
	PUSHJ	P,RELRB2	;MAYBE ALSO RELEASE %RB2,
	PUSHJ	P,UNLFIL	;RELEASE THE FILE,
	POP	P,M		;CLR PDL, AND THEN
	JRST	CPOPJ1		;TAKE THE SUCCESS RETURN.



EXCDR1:	POP	P,T1
	POP	P,T1
EXCDRB:	JUMPE	P2,+2		;
	PUSHJ	P,RELM2		;
	POP	P,M		;
	PUSHJ	P,RELSAT	;
	PJRST	KILFIL

EXCDR3:	POP	P,T1
	POP	P,T1
EXCDR4:	JUMPE	P2,DLXDR0	;
	PUSHJ	P,RELM2		;
	PJRST	DLXDR0
COMMENT #
@@SUBROUTINE SWEEP/SWEPHO/SWEPPG
@@PURPOSE
SUBR TO SWEEP A FILE PAST ITS CURRENT EOF.
@@ENTRY
EXPECTS F/ DDB, S/ DEVIOS, M/ NO. OF FIRST PAGE TO CREATE,
T4/ TOTAL NUMBER OF PAGES TO CREATE (INCLUDING M).
SWEEP WILL EXTEND THE FILE OUT TO M-1, IF NECESSARY, WITH
HOLES.  THEN FROM M TO M+T4-1 IT WILL CREATE (A) HOLES OR
(B) ZERO DISK PAGES, DEPENDING ON WHETHER IT WAS CALLED AT
SWEPHO OR SWEPPG RESPECTIVELY.
SWEEP EXPECTS THE FILE TO BE MODIFIED LOCKED ON ENTRY.
THERE MAY BE A RIB IN %RIB AND A SAT IN %SAT ON ENTRY.
THE FILE SIZE IS ALWAYS SET TO THE NEW EOF ON EITHER SUCCESS
OR ERROR RETURN.
THIS ROUTINE DOES NOT SET DEVPOS AND FRIENDS AS IT IS CALLED BY
BOTH OLD AND NEW STYLE IO ROUTINES.
IF T1/0 (-1) SWEEP WILL STOP (NOT STOP) ON CONTROL C.
@@ACCUM
DESTROYS T1-T4, PG, U,
@@EXIT
ON A SUCCESS RETURN OR A FAIL RETURN OTHER THAN FOR A BAD RIB,
THERE MAY BE A RIB IN %RIB AND A SAT IN %SAT, AND THE FILE IS
NOT UNLOCKED.  ON A FAIL RETURN DUE TO A BAD RIB, THE FILE IS
MARKED BAD, UNLOCKED, AND THE RIBS ARE GIVEN AWAY.
SUCCESS RETURN IS A SKIP RETURN.  ERROR RETURN IS A NON-SKIP
RETURN.  ERROR CODE RETURNED IN T1 IS:
	FALCTL    CONTROL C IS WAITING
	FALAQA    QUOTA EXCEEDED (NOTE THAT IT IS THE CALLER'S
		    RESPONSIBILITY TO TYPE OUT THE EXCEEDING
		    QUOTA MSG.).
	FALRBE    RIB ERROR
ON AN ERROR RETURN, T4 HAS BEEN DECREMENTED BY THE NO. OF PAGES
AT AND FOLLOWING M THAT HAVE BEEN SUCCESSFULLY CREATED;
EVEN IF T4 IS UNCHANGED, PAGES MAY
STILL HAVE ALLOCATED IF M WAS ORIGINALLY >HPW+1;  (IN THIS
CASE THE FILE SIZE REFLECTS THESE PAGES.).
@@ #

FLG.PG==1
FLG.ER==4
FLG.CC==10
;ENTER AT SWEPRH TO DO HOLES IN SPITE OF TITO CROCK.
	TITO==1	;WHEN =1, TITO CROCK IS IN EFFECT.
IFE TITO,<SWEPHO::>
SWEPRH::TDZA	T2,T2		;
IFN TITO,<SWEPHO::>
SWEPPG::MOVEI	T2,FLG.PG	;

SWEEP:	PUSH	P,P1		;SAVE SOME
	PUSH	P,P2		;ACS WE
	PUSH	P,P3		;WILL BE USING.
	MOVE	P1,T2		;THIS WILL BE OUR FLAG WORD.
	JUMPE	T1,SWEEP0	;WANT TO STOP ON CONTROL C?
	TRO	P1,FLG.CC	;NO.
	AOJE	T1,SWEEP0	;T1 HAD TO BE 0 OR -1.
	 STOPCD                         ;;SWEEP+7
SWEEP0:	MOVE	P2,T4		;COUNTER OF PAGES.

    ;MUST WE EXTEND THE FILE BEFORE WE SWEEP?
	HRRZ	T2,DEVATB(F)	;
	JUMPN	T2,.+2		;
	 STOPCD                         ;;SWEEP0+3
	LDB	T4,ATYBSZ	;
	ADDI	T4,3		;
	LSH	T4,-2		;
	ADDI	T4,1		;T4/ OLD HPW+1.
	CAMG	M,T4		;MUST EXTEND FILE BEFORE SWEEP?
	 JRST	SWEEP2		;NO.
      ;HERE TO EXTEND THE FILE OUT TO REQUESTED STARTING PAGE.
	PUSH	P,M		;YES.
	EXCH	M,T4		;
	SUB	T4,M		;
	SETZ	T1,		;
	TRNE	P1,FLG.CC	;
	 SETO	T1,		;
	PUSHJ	P,SWEPHO
	  JRST	[POP P,M	;ERROR.  RESTORE M.
		TRO P1,FLG.ER	;TAKE THE SWEPD4 ERROR
		JRST SWEPD4]	;RETURN.
	POP	P,M		;SUCCESS RETURN.
SWEEP2:	TRNE	P1,FLG.PG	;IF DOING HOLES OR
	CAIE	P2,1		;MORE THAN 1 PAGE,
	 JRST	SWEP2A		;GO DO IT THE NORMAL WAY.
;Using VMOVPG causes the COW page to be allocated at random, which means
; the file pages will be scattered all over the place, and FILIO will
; have to do a SEEK for every single page read in.  Setting CONTIG
; nonzero in COMMON will make new file pages be contiguous as possible
; with the previous pages.
	SKIPE	CONTIG##	;If CONTIG= 0, use VMOVPG
	 JRST	SWEP2A		;If CONTIG=-1, use CREPAG

;WE ARE DOING 1 REAL PAGE. USE VMOVPG TO SAVE ON I/O
	PUSHJ	P,RELRIB
	PUSHJ	P,RELSAT
	PUSHJ	P,UNLFIL	;GET RID OF ALL THE LOCKS
	PUSH	P,P4
	PUSH	P,M
	PUSH	P,W
	MOVE	T1,[6001,,%COW.N+CNVVPN]
	VCREAT	T1,		;CREATE PRIVATE PAGE (at random position)
	  JRST	SWEP3E
	MOVE	T1,[1,,%COW.N+CNVVPN]
	MOVE	T2,M		;MAKE PRIVATE PAGE PART OF THE FILE
	PUSHJ	P,DOMVPG	;DO VMOVPG AND FIX PC.UIO
	  HRL	P1,T1		;SORRY, IT FAILED.
	MOVE	T1,[2001,,%COW.N+CNVVPN]
	VCLEAR	T1,		;NOW GET RID OF THE PAGE
	  STOPCD                         ;;SWEEP2+22
	JRST	.+2

SWEP3E:	HRRZ	T1,T1
	SKIPA
	HLRZ	T1,P1		;GET ERROR CODE (IF ANY) INTO T1
	MOVEI	P2,1		;HAD TO BE 1 OR ELSE WE WOULDNT BE HERE
	POP	P,W
	POP	P,M
	POP	P,P4		;RESTORE ESSENTIAL ACS
	JRST	SWEPD4

DOMVPG:	JRSTF	@[.+1]		;CLEAR PC.UIO
	PUSHJ	P,KMOVPG
	  SKIPA
	AOS	(P)		;SKIP RETURN
	POP	P,T2		;GET PC OFF STACK
	JRSTF	(T2)		;AND RETURN, RESTORING STATE OF PC,UIO.
;End of VMOVPG kludge

;Here to add a new page to the file, contiguous to previous page

SWEP2A:	SUBI	M,1		;POINT @DEVRET TO
	PUSHJ	P,USETST	; M-1 PAGE.
	  JRST	[TRO P1,FLG.ER
		AOJA M,SWEPD4]	;
	ADDI	M,1		;Back to requested page

    ;HERE WITH EOF JUST BEFORE M, AND DEVRET POINTING TO
    ;M-1 PAGE.  P2/ NO. OF PAGES TO DO, P1/ VARIOUS FLAGS.

SWEEP3:	PUSH	P,P2		;SAVE FOR FILE SIZE CALC.
	MOVEI	T1,DEVRBN(F)	;T1/ NO. OF PAGES LEFT IN
	SUB	T1,DEVRET(F)	;THIS DDB.
	CAIG	P2,(T1)		;ROOM ENOUGH IN THIS DDB?
	 JRST	SWEEP4		;YES.
	PUSH	P,T1		;NO, WILL NEED AT LEAST OUR RIB.
	MOVE	T1,DEVRIB(F)	;
	PUSHJ	P,MWLRIB	;
	  JRST	[TRO P1,FLG.ER	;RIB ERROR.
		HRLI P1,FALRBE
		POP P,T1
		JRST SWEPDN]
	POP	P,T1		;
	LDB	T3,DEYRPS	;FIND OUT IF NEED >THIS
	MOVNS	T3		;RIB.  CALC T1/ TOTAL
	ADDI	T3,RIBLST	;NO. OF
	ADDI	T1,(T3)		;PAGES LEFT IN THIS DDB + RIB.
	CAIG	P2,(T1)		;ENOUGH?
	 JRST	SWEEP5		;YES, IN THIS RIB.
	JRST	SWEEP6		;IN >1 RIB.

    ;HERE WHEN NO NEED TO GET RIB, ALL NEW PNTRS WILL FIT IN
    ;OUR DDB.
SWEEP4:	PUSH	P,DEVRET(F)	;SAVE M-1 LOC ADDR FOR BELOW.
	MOVSI	T1,PTRCHG	;
	IORM	T1,DEVIAD(F)	;Pointers have changed
	MOVEI	T2,'CAT'
	TRNN	P1,FLG.PG	;
	 JRST	SWEP44		;<0,,'CAT'> marks a hole (RBREAL is off)
	SETZ	T2,		;Zero means get page anywhere
	MOVE	T3,DEVRET(F)	;
	CAIL	T3,DEVRB1(F)	;
	 MOVE	T2,(T3)		;If previous page known, contig with it
      ;SET UP INFO IN OUR DDB.
SWEP42:	TRNN	P1,FLG.PG	;DOING HOLES?
	 JRST	SWEP44		;YES.
	PUSHJ	P,CREPAG	;NO. ALLOC, 0, CHRG, IN T2.
	  JRST	SWEP46		;ERR, DIDN'T ALLOC.
SWEP44:	AOS	DEVRET(F)	;
	MOVEM	T2,@DEVRET(F)	;Store new pointer (or hole)
	SOJG	P2,SWEP42	;

      ;NOW UPDATE OTHER DDBS.
SWEP46:	MOVE	S,DEVIOS(F)	;DID THE FILE GO BAD WHILE
	TLNN	S,IOBDRB	; WE WERE IN CREPAG?
	 JRST	SWEP47		;NO, OKAY.
	HRLI	P1,FALRBE	;YES, OVERRIDE OTHER
	TRO	P1,FLG.ER	; ERRORS.
SWEP47:	POP	P,P3		;SET UP ARGS FOR UPDDDB.
	ADDI	P3,1		;P3/ DEVRET TO
	SUB	P2,(P)		;PAGE M.
	MOVMS	P2		;P2/ NO. OF
	JUMPE	P2,.+2		;PAGES WE DID.
	PUSHJ	P,UPDDDB	;UPDATE OTHER DDBS.
	SUB	P2,(P)		;SET UP P2/ NO. PAGES NOT DONE
	MOVMS	P2		;FOR SWEPDN.
	JRST	SWEPDN		;

    ;HERE WHEN NEED OUR RIB, AND ALL POINTERS WILL BE WITHIN IT.
      ;OUTPUT ALL INTERESTING DDBS WITH PTRCHG ON.
SWEEP5:	SETZ	T1,		;T1= DON'T INVALIDATE DDBS WHEN
	PUSHJ	P,FLUSH		;WRITE THEM INTO %RIB.
	PUSHJ	P,PTROU0	;MAYBE OUTPUT US TOO.
      ;GET PNTR TO PLACE IN RIB.
	MOVEI	T1,DEVRBN(F)	;GET P3/
	SUB	T1,DEVRET(F)	;PNTR TO
	LDB	P3,DEYRPS	;FIRST NEW LOC IN THE
	SUBI	P3,-1(T1)	;RIB.
	TRNN	P1,FLG.PG	;DOING HOLES?
	 JRST	SWEP55		;YES, GO TO EASY BLT.
	SETZ	T2,		;Zero means get page anywhere
	MOVE	T3,DEVRET(F)	;
	CAIL	T3,DEVRB1(F)	;
	 MOVE	T2,(T3)		;If previous page known, contig with it
SWEP54:	PUSHJ	P,CREPAG	;NO, GO ONE BY ONE.
	  JRST	SWEP56		;ERROR, DIDN'T ALLOCATE.
	MOVEM	T2,%RIB(P3)	;
	ADDI	P3,1		;
	SOJG	P2,SWEP54	;
	MOVE	S,DEVIOS(F)	;DID THE FILE GO BAD WHILE WE
	TLNN	S,IOBDRB	; WERE IN CREPAG?
	 JRST	SWEP56		;NO.
	HRLI	P1,FALRBE	;YES.
	TRO	P1,FLG.ER	;
	JRST	SWEP56		;

      ;HERE TO BLT HOLES INTO RIB.
SWEP55:	MOVEI	T2,'CAT'	;SETUP T2, WE'RE DOING HOLES
	MOVEM	T2,%RIB(P3)	;STORE FIRST HOLE.
	MOVEI	T4,%RIB+1(P3)	;T4 IS THE
	HRLI	T4,-1(T4)	;BLT AC.
	ADDI	P3,(P2)		;POINT P3 TO
	CAIE	P2,1		;If just one, we've done it
	 BLT	T4,%RIB-1(P3)	;More than 1 hole
	MOVEI	P2,0		;No hole pages left undone
      ;HERE TO FIX UP THE DDBS FOR THIS RIB.
SWEP56:	PUSH	P,F		;SAVE F.
	SETZ	T1,		;GET THE NEXT DDB ADDR
SWEP57:	PUSHJ	P,FNDDDB	;INTO T1.
	 JRST	SWEP58		;NO MORE DDBS.
	MOVE	F,T1		;GET
	LDB	T2,DEYRPS	;DEYRPS.
	HRLZI	T2,%RIB-PTRLEN+1(T2) ;COPY THE (NEW?) PNTRS
	HRRI	T2,DEVRB1(T1)	;FROM THE AREA IN THE RIB TO THE
	BLT	T2,DEVRBN(T1)	;DDB AREA.
	JRST	SWEP57		;GO TO NEXT DDB.

SWEP58:	POP	P,F		;RESTORE F.
	SUBI	P3,2		;NOW, UPDATE
	DPB	P3,DEYRPS	;OUR DDB AREA TOO:
	MOVE	T4,(P)		;(CALC
	SUB	T4,P2		; T4/
	ADD	T4,M		; DEVFLO
	SUBI	T4,1		; FOR PTRINN)
	PUSHJ	P,PTRINN	;
	  STOPCD                         ;;SWEP58+10
	JRST	SWEPDN		;

    ;HERE WHEN WE NEED MORE THAN 1 RIB.
      ;OUTPUT ALL INTERESTING DDBS WITH PTRCHG ON.
SWEEP6:	SETO	T1,		;INVALIDATE DDBS AND WRITE THEM
	PUSHJ	P,FLUSH		;INTO %RIB.
SWEP63:	MOVEI	T2,'CAT'
	MOVSI	P3,PTRCHG	;
	TRNN	P1,FLG.PG	;DOING HOLES?
	 JRST	SWEP64		;
	SETZ	T2,		;Zero means get page anywhere
	MOVE	T3,DEVRET(F)	;
	CAIL	T3,DEVRB1(F)	;
	 MOVE	T2,(T3)		;If previous page known, contig with it
SWEP64:	PUSHJ	P,GETRET	;Get right RIB for storing pointer
	  JRST	[TRO P1,FLG.ER	;
		HRLI P1,(T1)	;
		JRST SWEPDN]	;
	TRNN	P1,FLG.PG	;DOING HOLES?
	 JRST	SWEP65		;YES.
	PUSHJ	P,CREPAG	;
	  JRST	SWEPDN		;ERROR, DIDN'T ALLOCATE.
SWEP65:	MOVEM	T2,@DEVRET(F)	;
	IORM	P3,DEVIAD(F)	;
	SOJG	P2,SWEP64	;
	PFALL	SWEPDN		;Sweep done

    ;HERE TO FINISH UP.  (ENTER WITH P2/NO. OF PAGES NOT DONE.).
SWEPDN:	POP	P,T1		;T1/ NO. PAGES REQUESTED TO DO.
	SUB	T1,P2		;SUBTRACT NUMBER NOT DONE.
	ADD	T1,M		;ADD NO. DONE TO FIRST-1
	SUBI	T1,1		;TO GET NEW HPW.
	LSH	T1,2		;CONVERT TO HBW.
	HRRZ	T2,DEVATB(F)	;SET
	DPB	T1,ATYBSZ	; THE
	SETZ	T1,		; ATBSIZ
	DPB	T1,ATYWSZ	; FIELDS.
	HLRZ	T1,P1		;DITTO T1.  (MAY BE ERROR FLAG.).
	CAIN	T1,FALRBE	;WAS THERE A RIB
	TRNN	P1,FLG.ER	; ERROR?
	 JRST	SWEPD4		;NO.
	PUSHJ	P,KILFIL	;YES, KILL THE FILE.
SWEPD4:	MOVE	T4,P2		;SET T4 UP FOR CALLER.
	POP	P,P3		;
	POP	P,P2		;
	TRNN	P1,FLG.ER	;
	 AOS	-1(P)		;
	POP	P,P1		;
	POPJ	P,		;
COMMENT #
@@SUBROUTINE UPDDDB
@@PURPOSE
SUBR TO UPDATE DDBS OTHER THAN OUR OWN, FROM THE NEW POINTERS
ADDED TO THE EOF IN OUR DDB.
@@ENTRY
EXPECTS F/ DDB, M/ LOGICAL NO. IN FILE OF 1ST NEW PAGE, P3/ OUR
DEVRET TO PAGE M, AND P2/ NO. OF NEW PAGES.
@@ACCUM
DESTROYS T1-T4 AND P3.
@@ #

UPDDDB:	HRLZI	P3,(P3)		;P3 WILL BE BLT AC.
	SETZ	T1,		;GET A DDB OF
UPDDLP:	PUSHJ	P,FNDDDB	;INTEREST.
	  POPJ	P,		;NONE LEFT.
    ;SEE IF ANY OF OUR NEW PNTRS BELONG ALSO IN THIS DDB.
	PUSHJ	P,FINDM		;IS M IN THIS DDB?
	  JRST	UPDDLP		;NO.
	JUMPN	T2,UPDDLP	;NOR IF IN SPARE RIB PNTR.
    ;COPY SOME OF OUR NEW PNTRS TO THIS DDB.
	MOVEI	T4,DEVRBN(T1)	;T3/ ADDR OF PAGE M RET PNTR.
	SUBI	T4,-1(T3)	;GET T4/ ROOM LEFT IN THIS DDB.
	CAMLE	T4,P2		;CALC T4/ MAX NO.
	MOVEI	T4,(P2)		;OF PNTRS TO TRANSFER.
	ADDI	T4,-1(T3)	;T4/ BLT DESTINATION AC.
	HLL	T3,P3		;T3/ BLT AC.
	BLT	T3,(T4)		;COPY SOME PNTRS.
	JRST	UPDDLP		;
COMMENT #
@@SUBROUTINE ONESLT
@@PURPOSE
SUBR TO UPDATE OTHER DDBS WHEN WE HAVE FILLED OR MADE A HOLE
<= HPW.
@@ENTRY
EXPECTS T2/ NEW RETRIEVAL PNTR, M/ PAGE NUMBER OF INTEREST,
AND F/ DDB.
EXPECTS RIB WRITE LOCKED IN %RIB.
@@ACCUM
DESTROYS T1, T3, AND T4.  DOES NOT DESTROY T2.
@@ #


ONESLT:	PUSH	P,P1		;SAVE P1.
	MOVE	P1,T2		;P1 CARRIES NEW RETRIEVAL PNTR.
	SETZ	T1,		;T1 CARRIES DDB BEING UPDATED.
ONESL2:	PUSHJ	P,FNDDDB	;GET ANOTHER DDB TO T1.
	  JRST	[MOVE T2,P1	;NONE LEFT.  RESTORE T2 FOR
		POP P,P1	;CALLER. RESTORE P1.
		POPJ P,]	;RETURN.
	PUSHJ	P,FINDM		;IS OUR SLOT IN THIS DDB?
	  JRST	ONESL2		;NO, GO TO NEXT.
	JUMPN	T2,ONESL2	;NOT IF ONLY SPARE, EITHER.
	MOVEM	P1,(T3)		;FOUND ONE.
	JRST	ONESL2		;GO TO NEXT.
COMMENT #
@@SUBROUTINE FINDM
@@PURPOSE
SUBR TO FIND OUT IF PAGE M IS IN THE DDB WHOSE ADDR IS IN T1,
AND, IF SO, TO RETURN SOME INFO ABOUT WHERE IT IS.  (DOES NOT
CHECK ANYTHING ABOUT THE LEGALITY OF M'S RETRIEVAL PNTR.).
@@ENTRY
EXPECTS M/ NO. OF FILE PAGE OF INTEREST,  T1/ DDB ADDR, AND
T3/ DEVFLO(T1).  EXPECTS THE DDB TO BE VALID.
@@ACCUM
DESTROYS T2 THRU T4. MUST NOT DESTROY T1.
@@EXIT
NON-SKIP RETURNS IF M IS NOT IN THE DDB.  ELSE, SKIP RETURNS
WITH EITHER (A) T2/ 0 AND T3/ ADDR OF REAL RET PNTR, OR (B)
T2/ DEVSZS(T1) AND T3/ ADDR OF SPARE RIB PNTR.
@@ #

FINDM::	ADDI	T3,3		;CONVERT DEVFLO
	LSH	T3,B2PLSH	;TO PAGES.
	CAMGE	M,T3		;M BELOW 1ST PAGE IN THIS DDB?
	 POPJ	P,		;YES.
	MOVEI	T4,PTRLEN	;NO.  T3 HAS DEVFLO.  LOOK
	MOVEI	T2,DEVRB1-1(T1)	;FIRST AT THE LEADING SPARE
FINDM1:	ADDI	T2,1		;
	SKIPL	(T2)		;RIB PNTRS, IF ANY.
	 JRST	FINDM4		;FOUND FIRST NON-SPARE PNTR.
	ADD	T3,DEVSZS(T1)	;INC T3 BY ONE SPARE RIB SIZE.
	CAML	M,T3		;M DOWN WITHIN THIS SPARE RIB?
	 JRST	FINDM2		;NO, GO TO NEXT.
	MOVEI	T3,(T2)		;YES, RETURN T2/ DEVSZS(T1) AND
	MOVE	T2,DEVSZS(T1)	;T3/ ADDR OF SPARE RIB PNTR.
	JRST	CPOPJ1		;SUCCESS RETURN.

FINDM2:	SOJG	T4,FINDM1	;CONTINUE LOOKING AT PNTRS?
	 STOPCD                         ;;FINDM2+1
FINDM4:	ADDI	T3,-1(T4)	;HERE ON 1ST NON-SPARE RIB PNTR.
	CAMLE	M,T3		;M WITHIN THIS DDB?
	 POPJ	P,		;NO.
	SETZ	T2,		;YES, RETURN T2/ 0 AND
	SUB	T3,M		;T3/ ADDR OF RET PNTR FOR
	MOVNS	T3		;PAGE
	ADDI	T3,DEVRBN(T1)	;M.
	JRST	CPOPJ1		;SUCCESS RETURN.
COMMENT #
@@SUBROUTINE FNDDDB
@@PURPOSE
SUBR TO GET THE NEXT VALID DDB ON THIS FNB WITH OUR DEVRIB.
(DOES NOT RETURN OUR DDB.).
@@ENTRY
EXPECTS F/ DDB AND T1/ ADDR OF PREVIOUS DDB (0 IF NO PREVIOUS).
@@ACCUM
DESTROYS T1, T2, AND T3.  MUST NOT DESTROY T4.
@@EXIT
ON SUCCESS, SKIP RETURNS WITH T1/ ADDR OF REQUESTED DDB AND
T3/ THAT DDB'S DEVFLO.  ON NO NEXT DDB, NON-SKIP RETURNS.
@@ #

FNDDDB::MOVE	T2,DEVRIB(F)	;(FOR COMPARE BELOW.).
	JUMPN	T1,FNDDD4	;WANT FIRST DDB?
	HRRZ	T1,DEVATB(F)	;YES.
	JUMPN	T1,.+2		;
	 STOPCD                         ;;FNDDDB+4
	HRRZ	T1,ATBFNB(T1)	;
	HRRZ	T1,FNBDBL(T1)	;T1/ FIRST DDB ON THIS FNB.
FNDDD2:	SKIPLE	T3,DEVFLO(T1)	;VALID?
	CAME	T2,DEVRIB(T1)	;YES.  HAS OUR DEVRIB?
	 JRST	FNDDD4		;NOT INTERESTING DDB.
	CAIE	T1,(F)		;DON'T WANT OUR PRIME DDB.
	 JRST	CPOPJ1		;FOUND ONE.
FNDDD4:	HRRZ	T1,DEVDBL(T1)	;TRY NEXT DDB.
	JUMPN	T1,FNDDD2	;
	POPJ	P,
COMMENT #
@@SUBROUTINE FNDADB
@@PURPOSE
SUBR TO GET THE NEXT VALID DDB ON THIS FNB WITH OUR ATB.
(DOES NOT RETURN OUR DDB.).
@@ENTRY
EXPECTS F/ DDB AND T1/ ADDR OF PREVIOUS DDB (0 IF NO PREVIOUS).
@@ACCUM
DESTROYS T1, T2, AND T3.  MUST NOT DESTROY T4.
@@EXIT
ON SUCCESS, SKIP RETURNS WITH T1/ ADDR OF REQUESTED DDB AND
T3/ THAT DDB'S DEVFLO.  ON NO NEXT DDB, NON-SKIP RETURNS.
@@ #

FNDADB::HRRZ	T2,DEVATB(F)	;(FOR COMPARE BELOW.).
	JUMPN	T1,FNDAD4	;WANT FIRST DDB?
	HRRZ	T1,DEVATB(F)	;YES.
	JUMPN	T1,.+2		;
	 STOPCD                         ;;FNDADB+4
	HRRZ	T1,ATBFNB(T1)	;
	HRRZ	T1,FNBDBL(T1)	;T1/ FIRST DDB ON THIS FNB.
FNDAD2:	CAIN	T1,(F)		;DON'T WANT OUR PRIME DDB.
	 JRST	FNDAD4		;NOT INTERESTING DDB.
	HRRZ	T3,DEVATB(T1)	;HAS OUR ATB?
	CAIE	T3,(T2)		;
	 JRST	FNDAD4		;
	SKIPLE	T3,DEVFLO(T1)	;
	 JRST	CPOPJ1		;FOUND ONE.
FNDAD4:	HRRZ	T1,DEVDBL(T1)	;TRY NEXT DDB.
	JUMPN	T1,FNDAD2	;
	POPJ	P,
COMMENT #
@@SUBROUTINE FLUSH
@@PURPOSE
SUBR TO WRITE OUT ANY DDB PNTR AREAS THAT NEED WRITING OUT
FOR THE RIB THAT WE PRESENTLY HAVE IN %RIB.  ASSUMES DEVRIB(F)
IS THE ADDRESS OF THIS RIB.  OPTIONALLY INVALIDATES ALL THE
DDBS FOR THIS RIB.  DOES NOT FLUSH OR TOUCH OUR OWN DDB.
@@ENTRY
EXPECTS F/ OUR DDB AND DEVRIB(F) TO BE THE RIB IN %RIB.
INVALIDATES ALL THE DDBS FOR THIS RIB IFF T1/-1; ELSE T1 MUST
BE 0.
@@ACCUM
DESTROYS T1-T4.
@@ #

FLUSH::	SKIPG	T4,T1		;CHECK THAT T1 IS -1 OR 0 AND
	AOJGE	T1,.+2		;GET IT INTO SEMI-SAFE T4.
	 STOPCD                         ;;FLUSH+2
	SETZ	T1,		;GET T1/ ADDR OF NEXT
FLUSH2:	PUSHJ	P,FNDDDB	;INTERESTING DDB.
	  POPJ	P,		;NONE LEFT.
	EXCH	F,T1		;WRITE THE DDB PNTRS INTO
	PUSHJ	P,PTROU0	;%RIB, IFF PTRCHG IS ON (TURN
	EXCH	F,T1		;PTRCHG OFF.).
	IORM	T4,DEVFLO(T1)	;POSSIBLY INVALIDATE THIS DDB.
	JRST	FLUSH2		;GO TO NEXT DDB.
COMMENT #
@@SUBROUTINE FLUSHA
@@PURPOSE
SUBR TO WRITE OUT ALL DDB PNTR AREAS THAT NEED WRITING OUT
FOR THIS VERSION OF A FILE.  INVALIDATES ALL THE DDBS FOR
THIS RIB.  OUR OWN DDB DOES NOT NEED TO BE FLUSHED, SO IT IS
JUST MARKED INVALID.
@@ENTRY
EXPECTS F/ OUR DDB.
@@ACCUM
DESTROYS T1-T4, U, AND PG.
@@EXIT
SKIP RETURNS ON SUCCESS.
NON-SKIP RETURNS ON BAD RIB.
@@ #

FLUSHA::SETOM	DEVFLO(F)	;INVALIDATE US.
	PUSH	P,P1		;SAVE P1.
	PUSH	P,F		;SAVE F.

    ;FIND THE NEXT VALID DDB FOR THIS FILE, WITH PTRCHG ON.
	HRRZ	P1,DEVATB(F)	;GET P1/ OUR
	JUMPN	P1,.+2		;ATB.
	 STOPCD                         ;;FLUSHA+5
	HRRZ	F,ATBFNB(P1)	;
	HRRZ	F,FNBDBL(F)	;
FLSHA2:	SKIPG	DEVFLO(F)	;VALID?
	 JRST	FLSHA4		;NO, DON'T BOTHER WITH IT.
	HRRZ	T1,DEVATB(F)	;YES, ON OUR
	CAIE	T1,(P1)		;VERSION OF THE FILE?
	 JRST	FLSHA4		;NO, IGNORE IT.
	HLLZ	T1,DEVIAD(F)	;YES, NEED TO
	TLNE	T1,PTRCHG	;WRITE IT OUT?
	 JRST	FLSHA5		;YES.
FLSHA3:	SETOM	DEVFLO(F)	;NO.  JUST INVALIDATE.
FLSHA4:	HRRZ	F,DEVDBL(F)	;GET THE NEXT DDB
	JUMPN	F,FLSHA2	;ON THE FILE.
	POP	P,F		;
	POP	P,P1		;
	JRST	CPOPJ1		;

    ;HERE WITH A DDB THAT NEEDS WRITING.  WRITE IT AND ANY
    ;OTHER DDBS FOR THE SAME RIB.
FLSHA5:	MOVE	T1,DEVRIB(F)	;
	PUSHJ	P,MWLRIB	;
	  JRST	[POP P,F	;ERROR IN RIB.
		POP P,P1	;
		POPJ P,]	;
	PUSHJ	P,PTROU0	;FLUSH THIS DDB.
	SETO	T1,		;THEN DO ANY
	PUSHJ	P,FLUSH		;OTHER DDBS FOR THIS RIB.
	PUSHJ	P,RELRIB	;RELEASE THE RIB.
	JRST	FLSHA3		;GO TO NEXT DDB.
COMMENT #
@@SUBROUTINE CREPAG
@@PURPOSE
SUBR TO ALLOCATE A DISK PAGE AND ZERO IT.
@@ENTRY
EXPECTS T2/ RETRIEVAL PNTR WITH WHICH TO TRY TO BE CONTIGUOUS,
F/ DDB, AND S/ DEVIOS.  T2 MAY BE A HOLE, REAL, OR 0.
CHECKS FOR CONTROL C WAITING UNLESS P1 HAS FLG.CC ON.
@@ACCUM
DESTROYS T1-T4 AND PG.
@@EXIT
ON SUCCESS, SKIP RETURNS WITH T2/ THE RETRIEVAL PNTR OBTAINED.
NON-SKIP RETURNS IF CNTRL C WAITING OR ON ALLOCATION ERROR.
NON SKIP RETURN TURNS ON FLG.ER IN THE RH OF P1 AND STORES
THE ERROR CODE IN LH OF P1.  (ERROR CODES ARE FALCTL (CONTROL
C WAITING) AND FALAQA(CAN'T ALLOCATE DISK PAGE).
@@ #


CREPAG:	TRNE	P1,FLG.CC	;USER WANTS CNTRL C CHECK?
	 JRST	CREPG1		;NO.
	MOVE	T1,JOB		;FIRST CHECK
	MOVE	T1,JBTSTS(T1)	;FOR CONTROL
	TLNE	T1,CNTRLC	;C WAITING.
	 JRST	[HRLI P1,FALCTL	;YES, WAITING.
		JRST CREFL4]	;

CREPG1:	PUSH	P,P2		;COUNT OF TIMES TO TRY
	MOVEI	P2,^D10		;DESPITE BAD DISK PAGES.
	PUSH	P,T2		;SAVE OLD RET PNTR.
CREPG2:	PUSHJ	P,CHKQTA	;OKAY TO ALLOC A DISK PAGE?
	  JRST	CREFAL		;NO.
	POP	P,T2		;YES, RESTORE OLD RET PNTR.
	PUSHJ	P,ISCYLB##	;If cyl boundry, skip (to change units)
	 TLNN	T2,RBREAL	;A REAL PAGE?
	  SETZ	T2,		;NO, TAKE CARE OF HOLES.
	TLZ	T2,RBMASK-RBREAL
	MOVEI	T1,FBIT		;SET ARG IN T1 FOR KEPPAG.
	HRRZ	T3,DEVATB(F)	;T3/ ATB ADDR OR ZERO.
	PUSHJ	P,KEPPAG	;TRY TO GET A PAGE AND ITS SAT.
	  JRST	[TRO S,IOBKTL	;ERROR RETURN, DON'T HAVE SAT.
		MOVEM S,DEVIOS(F)	;
		JRST CREFL1]	;
	PUSH	P,T2		;SAVE GOTTEN RETRIEVAL PNTR.
	SETZ	T1,		;Do the entire page
	MOVEI	T3,777		; "        "
	PUSHJ	P,CLRCOW	;CLEAR A PAGE.
	  SKIPA			;FAIL.
	 JRST	CREPDN		;SUCCESS.
	HRRZI	T1,(T1)		;ANYTHING BUT IN OR OUT
	CAIE	T1,FALIPE	; I/O ERROR
	CAIN	T1,FALOPE	; IS
	 SKIPA			; A BUG.
	  STOPCD		;;CREPG2+25
	SETO	T1,		;ADJUST THE USER'S
	MOVEI	T3,1		;COUNTS TO REFLECT THAT HE
	HRRZ	T2,DEVATB(F)	;DOESN'T OWN THIS PAGE
	PUSHJ	P,UPDAC2	;ANYMORE.  LEAVE DSK CNTS ALONE.
	SETZM	(P)		;ZERO PNTR FOR NEXT CONTIG TRY.
	SOJG	P2,CREPG2	;TRY AGAIN.
	JRST	CREFAL		;

CREPDN:	MOVEI	T1,4		;CHARGE FOR THE
	PUSHJ	P,WRTCHG	;FOUR BLOCKS WRITTEN.
	POP	P,T2		;RETURN T2/ RETRIEVAL PNTR.
	POP	P,P2		;
	JRST	CPOPJ1		;


    ;SOME ERROR EXITS.
CREFAL:	POP	P,T2
CREFL1:	POP	P,P2		;
	HRLI	P1,FALAQA 	;
CREFL4:	TRO	P1,FLG.ER
	POPJ	P,
COMMENT #
@@SUBROUTINE CLRCOW
@@PURPOSE
SUBR TO MAP A DISK PAGE INTO %COW, CLEAR PART OF IT, AND THEN
REMOVE IT.
@@ENTRY
EXPECTS T1/ REL NO. OF 1ST WORD TO CLEAR, T3/ REL NO. OF LAST
WORD TO CLEAR, T2/ RET PNTR, F/ DDB, AND S/ DEVIOS.
@@ACCUM
DESTROYS T1-T4 AND PG.
@@EXIT
SKIP RETURNS IF ALL SUCCESSFUL, ELSE NON-SKIP RETURNS WITH
RH OF T1 THE ERROR CODE AS FOLLOWS: FALBDS, FALIPE, OR FALOPE.
@@ #


CLRCOW::JSP	T4,SAVE4##	;SAVE P3 AND P4 (P1&P2 go along for the ride)
	PUSH	P,T1		;SAVE START OF CLEARING.
	PUSH	P,T3		;SAVE LAST TO CLEAR.
	CAIL	T1,0		;Range check T1 and T3
	CAILE	T1,777
	 STOPCD				;;CLRCOW+5
	CAIL	T3,0
	CAILE	T3,777
	 STOPCD				;;CLRCOW+10
	CAMLE	T1,T3		;T1=first, T3=last word to clear
	 STOPCD				;;CLRCOW+12
	MOVSI	P3,LMMRDW!LMPVIR;Set virgin bit if clearing entire page
	CAIN	T1,0		;If not start of page
	CAIE	T3,777		; and not end of page
	 TLZ	P3,LMPVIR	;Then must read from disk first
	HRRZ	T1,DEVATB(F)	;SET UP
	PUSH	P,W		;SAVE W.
	MOVEI	W,%COW.N+CNVVPN	;FOR MAPKRN.
	PUSHJ	P,MAPKRN	;MAP THE PAGE INTO %COW (use bits in P3)
	  JRST	[POP P,W	;RESTORE W.
		PUSHJ P,RELSAT	;WE DON'T WANT THE SAT.
		POP P,T3	;CLEAR JUNK
		POP P,T1	; FROM PDL.
		MOVEI T1,FALBDS	;SAY SAW A
		POPJ P,]	; BAD SAT.
	PUSHJ	P,SETLMA	;STORE BACK INTO THE SLOT.
	POP	P,W		;RESTORE W.
	PUSHJ	P,RELSAT	;DON'T WANT THE SAT.
	MOVE	T1,[PE.NER+1,,%COW.N+CNVVPN] ;SET IGNORE
	PERSET	T1,		;ERROR BIT.
	 STOPCD                         ;;CLRCOW+many
	SWAPIN	T1,%COW		;Reference %COW, get a page fault
	MOVEI	T1,%COW.N+CNVVPN
	PAGSTS	T1,		;GET PAGE STATUS
	 STOPCD                         ;;CLRCOW + many
	TLNN	T1,PS.DER!PS.DTE ;DEVICE OR DATA ERROR?
	 JRST	CLRCW4		;NO.
	POP	P,T3		;YES, CLEAR FROM
	POP	P,T1		;PDL.
	JUMPE	T1,.+2		;IF WE WERE CLEARING THE WHOLE
	 TDZA	T1,T1		; PAGE, FORGET ABOUT LOGGING
	HRLZI	T1,004000	; ERRORS.
	IOR	T1,[XWD 1,%COW.N+CNVVPN] ;REMOVE
	VREMOV	T1,		;THE COW PAGE, NOT SUPPOSED TO FAIL
	 STOPCD				;;CLRCFL-1
CLRCFL:	HRRZI	T1,FALIPE	;
	POPJ	P,

CLRCW4:	POP	P,T3		;RESTORE REL LAST TO CLEAR.
	MOVE	T1,(P)		;GET 1ST TO CLEAR.
	SETZM	%COW(T1)	;CLEAR 1ST.
	CAIN	T1,777		;DON'T BLT IF ONLY
	 JRST	CLRCW6		;ONE WORD TO CLEAR.
	ADDI	T1,%COW+1	;MAKE A BLT
	HRLI	T1,-1(T1)	;AC.
	BLT	T1,%COW(T3)	;CLEAR.
CLRCW6:	POP	P,T1		;IF WE WANTED A WHOLE 0 PAGE,
	JUMPE	T1,.+2		;DON'T LOG ERRORS IN THE BATS
	 TDZA	T1,T1		;SINCE WE STILL HAVE THE RIB AND
	HRLZI	T1,004000	;NO ONE WILL GET THIS PAGE AGAIN.
	IOR	T1,[XWD  1,%COW.N+CNVVPN] ;REMOVE THE PAGE.
	VREMOV	T1,		;(REALLY OUGHT TO DETECT IO ERRORS)
	 STOPCD				;;CLRCW6+6
	JRST	CPOPJ1		;SUCCESS.
COMMENT #
@@SUBROUTINE WRTCHG
@@PURPOSE
SUBR TO CHARGE FOR WRITING BLOCKS.
@@ENTRY
EXPECTS T1/ NO. OF BLOCKS TO CHARGE FOR.
@@ACCUM
DESTROYS T1 AND T2.
@@ #

INTERN WRTCHG

WRTCHG:	PUSH	P,J		;
	LDB	J,PJOBN		;
	ADDM	T1,JBTWCT(J)	;INCREMENT COUNT OF
	ADDM	T1,JBTWCT	;BLOCKS WRITTEN.
	PUSH	P,T1		;
	PUSHJ	P,GTCGSZ	;GET T1/ CHARGING SIZE OF JOB IN K.
	POP	P,T2		;
	IMUL	T2,T1		;INCREMENT NO. OF
	ADDM	T2,JBTSOT(J)	;BLOCKS TIMES
	ADDM	T2,JBTSOT	;SIZE IN K.
	POP	P,J		;
	POPJ	P,




COMMENT #
@@SUBROUTINE WRTCHP
@@PURPOSE
SUBR TO CHARGE FOR WRITING ONE PAGE.
@@ENTRY
EXPECTS J/ JOB NUMBER.
@@ACCUM
DESTROYS T1.
@@ #

INTERN WRTCHP

WRTCHP:	MOVEI	T1,4		;
	ADDM	T1,JBTWCT(J)	;INCREMENT COUNT OF
	ADDM	T1,JBTWCT	;BLOCKS WRITTEN.
	PUSHJ	P,GTCGSZ	;GET CHARGING SIZE IN
	LSH	T1,2		;K TIMES 4 BLOCKS.
	ADDM	T1,JBTSOT(J)	;
	ADDM	T1,JBTSOT	;
	POPJ	P,
COMMENT #
@@SUBROUTINE GETRET
@@PURPOSE
SUBR TO GET A PLACE FOR THE NEXT RETRIEVAL PNTR.
@@ENTRY
EXPECTS DEVRET(F) TO POINT TO THE PREVIOUS RETRIEVAL PNTR,
(POSSIBLY "IN" DEVRB1-1).
@@ACCUM
DESTROYS T1, T4, AND PG.  MUST NOT DESTROY T2 OR T3.
@@EXIT
NON-SKIP RETURNS ON RIB ERROR OR ALLOCATION (OF RIB) ERROR,
WITH FLAG SET IN T1 ACCORDINGLY (FALRBE OR FALAQA).  DOES NOT
OUTPUT THE EXCEEDING QUOTA MSG.  SUCCESS RETURN IS A SKIP
RETURN WITH DEVRET(F) POINTING TO THE NEW PLACE.
@@ #


GETRET:	AOS	T1,DEVRET(F)	;ROOM LEFT IN THE
	CAIG	T1,DEVRBN(F)	;CURRENT DDB?
	JRST	CPOPJ1		;YES.  SUCCESS RETURN.
	PUSH	P,T2		;NO.  SAVE T2 AND
	PUSH	P,T3		;T3 FOR CALLERS.
	PUSH	P,U		;SAVE U.
	MOVE	T1,DEVRIB(F)	;MAKE SURE WE HAVE THE
	PUSHJ	P,MWLRIB	;CORRECT RIB.
	JRST	[POP P,U	;RIB ERROR.
		POP P,T3	;
		POP P,T2	;
		MOVEI T1,FALRBE	;
		POPJ P,]	;
	POP	P,U		;RESTORE U.
	MOVE	T1,DEVIAD(F)	;SEE IF WE HAVE TO
	TLNE	T1,PTRCHG	;OUTPUT THE CURRENT PNTRS.
	PUSHJ	P,PTROU2	;OUTPUT THE PNTRS.
	PUSHJ	P,NXTPT0	;TRY TO GET MORE PNTRS.
	SOS	-2(P)		;FAIL RETURN.
	POP	P,T3		;SUCCESS, RESTORE T2
	POP	P,T2		;AND T3 FOR CALLERS.
	JRST	CPOPJ1		;
COMMENT #
@@SUBROUTINE MWLRIB
@@PURPOSE
SUBR TO GET THE DISK PAGE WHOSE RETRIEVAL PNTR IS IN T1 INTO
%RIB, WRITE LOCKED.  (TAKES CARE OF ALREADY HAVING A RIB.).
CHECKS THE NEW RIB FOR CONSISTENCY, ALSO.
@@ENTRY
EXPECTS T1/ RET PNTR TO DESIRED PAGE.
@@ACCUM
DESTROYS T1-T4, PG, AND U.
@@EXIT
NON-SKIP RETURNS ON CONSISTENCY CHECK(HAS RELEASED RIB); ELSE,
SKIP RETURNS WITH RIB IN %RIB.
@@ #

INTERN MWLRIB

MWLRIB:	MOVEI	PG,%RIB.C	;
	SKIPN	T2,@%RIB.C+%CTUPT ;ALREADY HAVE A RIB?
	JRST	MWLRB3		;NO.
	CAMN	T1,PCBPTR(T2)	;YES, IS IT THE ONE WE WANT?
	JRST	CPOPJ1		;YES, SUCCESS RETURN.
	PUSH	P,T1		;NO, SO
	PUSHJ	P,MAPRLS	;RELEASE IT
	SKIPA	T1,(P)		;KEEP POINTER ON STACK, RESTORE IT TO T1.
MWLRB3:	PUSH	P,T1		;SAVE POINTER TO PRIME RIB FOR RIBCON
	PUSHJ	P,MAPWTL	;GET THE NEW RIB.
	SWAPIN	T1,%RIB		;PREREFERENCE RIB SO NO RESCHEDULING
				; (OTHERWISE SOMEONE COULD GET FILE LOKMOD
				; AND BELIEVE DEVFLO AND DEVRIB TOGETHER)
	MOVE	T1,DEVRIB(F)	;GET CURRENT POINTER
	EXCH	T1,(P)		;SAVE IT ON STACK, GET ONE WE NEED TO CHECK
	MOVEM	T1,DEVRIB(F)	;SAVE IN DEVRIB SO CAN CHECK AGAINST RIBSLF
	PUSHJ	P,RIBCON	;RIB OKAY?
	  PJRST	[POP P,DEVRIB(F) ;NO, BAD. RESTORE DEVRIB
		 PJRST RELRIB]	;RELEASE RIB AND RETURN.
	POP	P,DEVRIB(F)	;RESTORE GOOD DEVRIB.
	MOVE	S,DEVIOS(F)	;FILE WENT BAD WHILE
	TLNN	S,IOBDRB	;WE WAITED FOR THIS RIB?
	JRST	CPOPJ1		;NO, RETURN WITH RIB.
	PJRST	RELRIB		;YES, REL RIB AND FAIL RETURN.
COMMENT #
@@SUBROUTINE KILFIL
@@PURPOSE
SUBR TO FLAG A FILE WITH A BAD RIB AND INVALIDATE THE FILE
FOR EVERYBODY.
@@ENTRY
EXPECTS F/ DDB AND S/ DEVIOS.
EXPECTS THE FILE TO BE LOCKED.
EXPECTS A LOOKUP OR ENTER TO BE IN FORCE.
@@ACCUM
DESTROYS T1-T4, AND PG.
@@EXIT
RETURNS T1/FALRBE.
RELEASES BOTH RIBS BEFORE RETURN.
ALSO UNLOCKS THE FILE.
@@ #


INTERN KILFIL

    ;GET THE FILE LOCKED DOWN.
KILFIL:	TLNN	F,LOOKB!ENTRB	;DEBUGGING CHECK.
	 STOPCD                         ;;KILFIL+1
	PUSHJ	P,RELRB2	;DUMP M2, SINCE WON'T NEED IT.
	TLNE	S,IOBDRB	;FILE ALREADY MARKED BAD?
	JRST	KILOUT		;YES, LITTLE FOR US TO DO.
	SKIPN	DEVLOK(F)	;ARE WE LOCKED ON THE FILE?
	 STOPCD                         ;;KILFIL+5
	HLLZ	T1,DEVBTS(F)	;IS THIS FILE ALREADY
	TLNE	T1,DEPFLK	;LOCKED MODIFY BY US?
	JRST	KILFL2		;YES.
	PUSHJ	P,RELRIB	;NO, CAN'T
	PUSHJ	P,UNLFIL	;LOCK WHEN HAVE RIB.
	MOVEM	S,DEVIOS(F)	;
	PUSHJ	P,LOKMOD	;
	MOVE	S,DEVIOS(F)	;HAS SOMEBODY ELSE SET THE
	TLNE	S,IOBDRB	;ERROR BIT WHILE WE WAITED?
	JRST	KILOT4		;YES, CLEAN UP AND EXIT.

    ;TRY TO LOG THIS FILE.
KILFL2:	MOVEI	T1,KILBUF	;MAYBE LOG IT.
	SKIPN	(T1)		;
	JRST	KILF24		;ROOM TO LOG FIRST.
	ADDI	T1,LOGLEN	;
	SKIPE	(T1)		;ROOM TO LOG 2ND?
	JRST	KILFL4		;NO.
KILF24:	MOVE	T2,DEVPPN(F)	;
	MOVEM	T2,(T1)		;
	MOVE	T2,DEVFIL(F)	;
	MOVEM	T2,1(T1)	;
	HLLZ	T2,DEVEXT(F)	;
	HLLZM	T2,2(T1)	;
	MOVE	T2,DEVRIB(F)	;
	MOVEM	T2,3(T1)	;
	HRRZ	T2,DEVATB(F)	;
	MOVE	T2,ATBRIB(T2)	;
	MOVEM	T2,4(T1)	;
	MOVE	T3,JOB		;
	MOVE	T2,JBTNAM(T3)	;
	MOVEM	T2,5(T1)	;
	MOVE	T2,JBTUNM(T3)	;
	MOVEM	T2,6(T1)	;

    ;HERE TO MARK THE FILE AS BAD.
      ;SET RIPUFE IN RIBLCW AND RIPBDR IN RIBSTS.
KILFL4:	HRRZ	T1,DEVATB(F)	;GET THE PRIME RIB
	MOVE	T1,ATBRIB(T1)	;(WITHOUT CHECKING
	MOVEI	PG,%RIB.C	;CONSISTENCY.).
	SKIPN	T2,@%RIB.C+%CTUPT ;ALREADY HAVE A RIB?
	JRST	KILF42		;NO.
	CAME	T1,PCBPTR(T2)	;YES.  IS IT THE ONE WE WANT?
	JRST	KILF41		;NO.
	MOVE	T1,JOB		;YES.  IS IT
	LDB	T1,%CTSTS(PG)	;WRITEABLE?
	CAIE	T1,STAWTU	;
	CAIN	T1,STAWTL	;
	JRST	KILF43		;YES.
	CAIE	T1,STACML	;
	CAIN	T1,STAWLN	;
	JRST	KILF43		;YES.
KILF41:	PUSHJ	P,MAPRLS	;HERE TO RELEASE CURRENT RIB,
	HRRZ	T1,DEVATB(F)	;AND GET
	MOVE	T1,ATBRIB(T1)	;THE
KILF42:	PUSHJ	P,MAPWTL	;PRIME RIB WRITEABLE.
KILF43:	HRRZI	T1,RIPBDR	;SET RIPBDR
	IORM	T1,%RIB+RIBSTS	;AND
	MOVSI	T1,RIPUFE	;RIPUFE.
	IORM	T1,%RIB+RIBLCW	;
	PUSHJ	P,RELRIB	;
      ;SET ATPUFE IN ATBLCW.
	HRRZ	T2,DEVATB(F)	;
	MOVSI	T1,ATPUFE	;
	IORM	T1,ATBLCW(T2)	;
      ;ZERO ATBSIZ AND ATBALP, ADJUST DRBALC.
	LDB	T1,ATYALP	;
	HLRZ	T4,DEVDRB(F)	;
	ADDM	T1,DRBALC(T4)	;
	SETZ	T1,		;
	DPB	T1,ATYALP	;
	SETZM	ATBSIZ(T2)	;
      ;MARK ALL OF THE DDBS ON THIS VERSION OF THE FILE BAD.
	HRLZI	T1,IOBDRB	;T1/ BAD BIT.
	HRRZ	T4,ATBFNB(T2)	;T4/
	HRRZ	T4,FNBDBL(T4)	;DDB.
KILF44:	HRRZ	T3,DEVATB(T4)	;IS THIS DDB ON THE SAME
	CAIE	T3,(T2)		;VERSION OF THE FILE?
	JRST	KILF45		;NO, FORGET IT.
	SETOM	DEVFLO(T4)	;YES, MARK IT INVALID AND
	IORM	T1,DEVIOS(T4)	;BAD.
KILF45:	HRRZ	T4,DEVDBL(T4)	;GET T4/ NEXT DDB.
	JUMPN	T4,KILF44	;JUMP IF ONE THERE.
      ;SET RIPBDR IN LH OF UFD'S RIBSTS, AND UFPERR IN UFDERR.
	HRRZ	T2,ATBSTS(T2)	;MAKE SURE THIS
	TRNN	T2,ATPSUP!ATPCRE ;HAS
	TRNE	T2,ATPDEL	;A UFD ENTRY.
	JRST	KILF49		;IT DOESN'T.
	HLRZ	T1,DEVDRB(F)	;GET THE RETRIEVAL
	MOVE	T1,DRBRIB(T1)	;PNTR TO THE UFD.
	MOVEI	PG,%RIB.C	;GET THE PRIME
	PUSHJ	P,MAPWTL	;RIB OF THE UFD.
	MOVSI	T1,RIPBDR	;MARK "A FILE IN THIS
	IORM	T1,%RIB+RIBSTS	;UFD IS BAD.
	HRRZ	T2,DEVATB(F)	;GET T1/
	HRRZ	T2,ATBFNB(T2)	;THE
	EXCH	T2,P3		;NUMBER OF
	LDB	T1,FNYUFP	;THE PAGE THIS
	MOVE	P3,T2		;ENTRY IS IN.
	SKIPLE	T1,%RIB+RIBPFS(T1) ;GET RET PNTR
	TLNN	T1,RBREAL	;TO THAT PAGE.
	JRST	KILF49		;THIS RIB BAD, TOO.
	LDB	T2,RBYUN1	;PROTECT FILIO
	CAIGE	T2,UNTLEN	;A LITTLE.
	SKIPN	UNTTBL(T2)	;
	JRST	KILF49		;
	PUSH	P,T1		;
	PUSHJ	P,RELRIB	;DUMP UFD RIB.
	POP	P,T1		;RESTORE T1/ RET PNTR.
	MOVEI	PG,%RIB.C	;GET THAT
	PUSHJ	P,MAPWTL	;PAGE INTO %RIB.
	MOVEI	T2,<^D512/UFDSIZ> ;T2/ NO. OF ENTRIES.
	MOVE	T1,DEVFIL(F)	;T1/ FILENAME.
	HLL	T3,DEVEXT(F)	;T3/ EXTENSION.
	SETZ	T4,		;INDEX INTO PAGE.
KILF46:	CAMN	T1,%RIB+UFDNAM(T4) ;MATCH ON FILENAME?
	JRST	KILF48		;YES.
KILF47:	ADDI	T4,UFDSIZ	;NO, NO MATCH, TRY
	SOJG	T2,KILF46	;NEXT.
	JRST	KILF49		;NONE LEFT, ERROR OF SOME TYPE.
KILF48:	HRR	T3,%RIB+UFDEXT(T4) ;EXT MATCHES
	CAME	T3,%RIB+UFDEXT(T4) ;ALSO?
	JRST	KILF47		;NO, TRY NEXT.
	MOVEI	T1,UFPERR	;YES.  SET
	IORM	T1,%RIB+UFDERR(T4) ;UFPERR IN OUR ENTRY.
	HRRZS	%RIB+UFDALP(T4)	;ZERO UFDALP.

KILF49:	MOVE	S,DEVIOS(F)	;RESTORE S FOR US.
KILOUT:	PUSHJ	P,RELRIB	;
KILOT4:	PUSHJ	P,UNLFIL	;
	MOVEI	T1,FALRBE	;
	POPJ	P,		;


;LOGGING AREA.
; ROOM FOR TWO ENTRIES.
LOGLEN==7
KILBUF: REPEAT LOGLEN*2,<Z>
COMMENT #
@@SUBROUTINE MAPKRN
@@PURPOSE
KERNEL SUBROUTINE TO MAP ANY DISK FILE PAGE TO A VM PAGE, GIVEN
THE RETRIEVAL PNTR TO THE DISK PAGE.  DOES NOT ALLOCATE.
ASSUMES CALLER HAS INSURED THAT VP IS NON-EXISTENT.
@@ENTRY
MAPKRN EXPECTS T1/ ATB ADDRESS, T2/ RETRIEVAL PNTR
	P3 CONTAINS PROTOTYPE LMAP SLOT (PROTECTION, LMPMXW)
W/ VP NO.
THERE MAY OR MAY NOT BE A SAT IN %SAT ON ENTRY.
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@EXIT
SKIP RETURNS WHEN SUCCESSFUL
NON-SKIP RETURNS WHEN SAT FOR REQUESTED PAGE IS BAD AND IT IS
NOT THE ONE BAD SAT WE CAN USE.
IN EITHER TYPE OF RETURN, MAY OR MAY NOT HAVE A SAT IN
%SAT-- CALL RELSAT TO CLEAN UP.
ON SUCCESS RETURN, LMAP SLOT IS IN P3 AND P4, READY TO STORE INTO DESTINATION
@@#


INTERN SATBAD,SATBRD
SATBAD: Z	;RETRIEVAL PNTR TO 1ST BAD SAT FOUND ON SYSTEM.
SATBRD:	Z	;NUMBER OF BAD SATS DUE TO READ ERRORS.
SATBCT:	-1	;Abort when count of bad SATs goes positive.


  ;BUILD SOME OF THE LMAP SLOT.
MAPKRN::TLNN	P3,LMPMXW	;MAX WRITE SET?
	 JRST	MAPKN2		;NO, DON'T INCREMENT UMC.
	AOS	T4,ATBMWC(T1)	;YES, INC THE ATB WRITE COUNT.
	TRNN	T4,ATMMWC	;IF WE OVRFLWD, FIELD GOES TO 0.
	 STOPCD                         ;;MAPKRN+4
	HRRZI	T4,ATPMXU	;MAKE SURE OTHERS KNOW THAT THE
	IORM	T4,ATBSTS(T1)	;COUNT IS >=1.

  ;FIND OUT IF THIS DP IS SHARED OR UNSHARED.
MAPKN2:	PUSH	P,T1		;SAVE ATB ADDR FROM GETSAT.
MAPK21:	MOVEI	T1,MAPCML	;GET THE SAT FOR T2 COMPLETELY
	TLZ	T2,RBMASK-RBREAL ;
	PUSHJ	P,GETSAT	;LOCKED.
	  JRST	MAPK24		;BAD SAT.
	JRST	MAPK26		;OKAY.

MAPK24:	CAME	T4,SATBAD	;IS THIS THE BAD SAT WE CAN USE?
	 JRST	MAPFAL		;NO, MAP FAILURE.
	TLZ	T2,RBREAL	;CLEAR FLGS FOR SRCSPT AND OTHERS.
	MOVE	T1,(P)		;T1/ ATB ADDRESS.
	PUSHJ	P,SRCSPT	;ALREADY IN SPT?
	  JRST	[MOVE T1,(P)	;NO, TREAT LIKE MAPPED.
		PUSHJ P,INCUMC	;
		JRST MAPKN7]	;
	POP	P,T3		;YES, CLEAR PDL.
	JRST	MAPKN3		;

;HERE IF SAT IS GOOD.

MAPK26:	PUSH	P,T1		;SAVE MASK FOR AND POSITION
	PUSH	P,T3		;OF F BIT IN SAT.
	MOVE	T1,-2(P)	;GET ATB FOR & SAVE FROM SRCSPT.
	TLZ	T2,RBMASK	;CLEAR FLGS FOR SRCSPT AND OTHERS.
	PUSHJ	P,SRCSPT	;T2 IN THE SPT ALREADY?
	JRST	MAPKN6		;NO.
	SUB	P,[XWD 3,3]	;YES, CLEAR JUNK FROM PDL.

  ;HERE WHEN ALREADY IN THE SPT.
MAPKN3:	DPB	T4,LM3SPT	;SET SPT ENTRY PNTR IN LMAP.
	AOS	T3,SPTUSC(T1)	;INC THE SPT USE
	TRNN	T3,SPMUSC	;COUNT.
	 STOPCD                         ;;MAPKN3+3

MAPKN4:	TLO	P3,LMPSHR	;SET LMAP SLOT STATUS TO SHRD.
	SETZ	P4,
	JRST	CPOPJ1

  ;Here when GETSAT gave error return and more than 1 SAT is bad
MAPFAL:	AOSE	SATBCT		;Increment bad SAT count
	 STOPCD (.+1,DEBUG,SAT2ND,,<2nd bad SAT detected>);;MAPFAL+1
	POP	P,T1		;
	TLNN	P3,LMPMXW	;DID WE INC THE ATB WRITE COUNT?
	 POPJ	P,		;NO.
	MOVEI	T4,ATMMWC	;YES.  FIRST CHECK THAT DECING
	TDNN	T4,ATBMWC(T1)	;IT WONT MAKE IT LESS THAN ZERO.
	 STOPCD                         ;;MAPFAL+5
	SOS	ATBMWC(T1)	;OKAY, DEC IT, AND IF IT WENT TO
	TDNE	T4,ATBMWC(T1)	;ZERO, CLEAR
	 POPJ	P,		;HASN'T GONE TO ZERO.
	HRRZI	T4,ATPMXU	;ATPMXU.
	ANDCAM	T4,ATBSTS(T1)	;
	POPJ	P,

  ;HERE WHEN NOT IN SPT.  (MAY BE BECOMING SHARED.).
MAPKN6:	POP	P,T3		;RESTORE MASK FOR AND POSITION
	POP	P,T1		;OF F BIT IN SAT.
	TDNN	T1,%SAT+MBITS(T3);IS THE MAPPED BIT ON?
	 JRST	MAPKN7		;YES.

  ;HERE WHEN UNSHARED.
	ANDCAM	T1,%SAT+MBITS(T3);SET THE MAPPED BIT IN THE SAT.
;*; Need to verify if OK to call DNDADS here.  P034/B02
;*;	TDNE	T1,%SAT+FBITS(T3);F bit should already be in use.  Is it?
;*;	 PUSHJ	P,DNDADS##	;No, one less page
	POP	P,T1		;GET T1/ ATB ADDRESS.
	PUSH	P,T2		;SAVE RET PNTR.
	PUSHJ	P,INCUMC	;INC THE ATB USC COUNT, ETC.
	PUSHJ	P,CNVATB	;SET
	DPB	T1,LM3ATB	;LM3ATB.
	POP	P,T2		;RESTORE RET PNTR.
	MOVE	P4,T2		;GET LOW ORDER DISK ADDRESS
	TRZ	P4,PGE.A	;USES ALL BITS BUT PGE.A
	LSH	T2,-LMASRP	;GET HI ORDER RIGHT JUSTIFIED
	DPB	T2,LM3HDA
	JRST	CPOPJ1		;GIVE GOOD RETURN.

  ;HERE WHEN BECOMING SHARED.
MAPKN7:	MOVE	T1,(P)		;GET T1/ ATB ADDRESS.
	PUSHJ	P,INSSPT	;MAKE AN SPT ENTRY.
	 JRST	MAPKN8		;LOSE, GO WAIT FOR FREECORE.
	DPB	T4,LM3SPT	;SET LM3SPT.
	MOVSI	T3,SPPVIR	;VIRGIN
	TLNE	P3,LMPVIR	;BIT?
	IORM	T3,SPTVIR(T1)	;YES.
	POP	P,T2		;GET T2/ATB ADDR.
	JRST	MAPKN4

MAPKN8:	PUSH	P,T2
	PUSHJ	P,RELSAT
	POP	P,T2
	AOS	FCREQ##
	PUSHJ	P,FCWAIT##
	SOS	FCREQ##
	TLO	T2,RBREAL
	JRST	MAPK21
COMMENT #
@@SUBROUTINE UNLFIL
@@PURPOSE
SUBR TO UNLINK A FILE FROM THE ATOMIC FILE LOCKING QUEUE.
MUST BE CALLED FOR THE RUNNING JOB.  DOES NOT CARE IF THE
FILE IS NOT IN THE QUEUE.
@@ENTRY
EXPECTS F/ DDB.
@@ACCUM
DESTROYS NO ACS.
@@ #
INTERN UNLFIL

UNLFIL:	SKIPN	DEVLOK(F)	;NOTHING TO DO IF WE ARE
	POPJ	P,		;NOT IN THE QUEUE AT ALL.
	PUSH	P,T1		;
	PUSH	P,T3		;
	HLRE	T1,DEVLOK(F)	;T1/ PREVIOUS.
	HRRZ	T3,DEVLOK(F)	;T3/ NEXT.
	SETZM	DEVLOK(F)	;
	CAMN	T1,[-1]		;JUMP IF WE ARE
	JRST	UNLFL4		;FIRST IN THE QUEUE.

    ;HERE WHEN WE ARE NOT 1ST IN THE QUEUE.
	HRRM	T3,DEVLOK(T1)	;JUST
	JUMPE	T3,UNLOT6	;HAVE
	HRLM	T1,DEVLOK(T3)	;TO
	JRST	UNLOT6		;RELINK.

    ;HERE WHEN WE ARE FIRST IN QUEUE.
UNLFL4:	HRRZ	T1,DEVATB(F)	;
	HRRM	T3,ATBLOK(T1)	;POINT ATB TO NEXT.
	JUMPE	T3,UNLOT6	;DONE IF NO ONE IN QUEUE.
	HRRZI	T1,-1		;
	HRLM	T1,DEVLOK(T3)	;POINT NEXT TO ATB.
	HLLZ	T1,DEVBTS(F)	;UNLESS BOTH WE
	TLNE	T1,DEPFLK	;AND THE NEXT
	JRST	UNLFL6		;ARE READERS, WE
	HLLZ	T1,DEVBTS(T3)	;HAVE TO START SOME
	TLNN	T1,DEPFLK	;JOBS.
	JRST	UNLOT6		;NO NEED TO START ANY.
UNLFL6:	PUSH	P,J		;
	PUSH	P,F		;
	MOVE	F,T3		;START
	LDB	J,PJOBN		;THIS
	MOVEI	T1,RNQ		;NEXT
	DPB	T1,PJBSTS	;JOB.
	PUSHJ	P,SETRUN	;
	HLLZ	T1,DEVBTS(T3)	;
	TLNE	T1,DEPFLK	;IS IT A READER?
	JRST	UNLOUT		;NO, DONE.
	HRRZ	T3,DEVLOK(T3)	;YES, GET NEXT IN QUEUE.
	JUMPE	T3,UNLOUT	;JUMP ON NO MORE IN QUEUE.
	PUSHJ	P,STRSOM	;

UNLOUT:	POP	P,F		;
	POP	P,J		;
UNLOT6:	POP	P,T3		;
	POP	P,T1		;
	POPJ	P,


COMMENT #
@@SUBROUTINE LOKLES
@@PURPOSE
SUBR TO CHANGE A FILE WHICH IS QUEUED LOCK MODIFIED TO LOCK
UNMODIFIED, AND TO START UP ANYBODY AFTER IT IN THE QUEUE THAT
WE CAN.
MUST BE CALLED FOR THE RUNNING JOB.
@@ENTRY
EXPECTS F/ DDB.
@@ACCUM
DESTROYS NO ACS.
@@ #


LOKLES:	SKIPN	DEVLOK(F)	;WE BETTER BE
	 STOPCD                         ;;LOKLES+1
	PUSH	P,T3		;LOCK
	MOVSI	T3,DEPFLK	;MODIFIED WHEN WE
	TDNN	T3,DEVBTS(F)	;ENTER HERE.
	 STOPCD                         ;;LOKLES+5
	ANDCAM	T3,DEVBTS(F)	;NOW WE ARE LOCK UNMODIFIED.
	HRRZ	T3,DEVLOK(F)	;IS THERE A JOB BEHIND US
	JUMPE	T3,[POP P,T3	;TO START, MAYBE?
		POPJ P,]	;
	PUSH	P,T1		;
	PUSH	P,J		;
	PUSH	P,F		;
	PUSHJ	P,STRSOM	;
	POP	P,F		;
	POP	P,J		;
	POP	P,T1		;
	POP	P,T3		;
	POPJ	P,


;TINY SUBR FOR USE BY BOTH UNLFIL AND LOKLES, USED TO START UP
;JOBS AFTER US IN THE QUEUE.  DESTROYS T1, F, J, AND USES T3.
STRSOM:	HLLZ	T1,DEVBTS(T3)	;IS THIS A
	TLNE	T1,DEPFLK	;READER, TOO?
	POPJ	P,		;NO, DONE.
	MOVE	F,T3		;START
	LDB	J,PJOBN		;THIS
	MOVEI	T1,RNQ		;NEXT
	DPB	T1,PJBSTS	;JOB.
	PUSHJ	P,SETRUN	;
	HRRZ	T3,DEVLOK(T3)	;
	JUMPN	T3,STRSOM	;
	POPJ	P,
COMMENT #
@@SUBROUTINE LOKUNM/LOKMOD
@@PURPOSE
LOKUNM(LOKMOD) ARE SUBRS TO GET OUR DDB LOCK UNMODIFIED
(MODIFIED) ONTO THE ATOMIC FILE LOCKING QUEUE.  MUST BE CALLED
FROM THE RUNNING JOB.
THE ATOMIC FILE LOCKING QUEUE PREVENTS DDB POINTERS FROM CHANGING
OR BEING BELIEVED ERRONEOUSLY WHEN THE RIB STRUCTURE IS CHANGING,
SINCE PCB LOCKING IS NOT SUFFICIENT WHEN THE ALLOCATION CODE
IS JUGGLING MORE THAN TWO RIBS. ALL ROUTINES THAT ACCESS
THE DDB POINTER AREA ARE REQUIRED TO GET THE FILE LOCK
UNMODIFIED. ALL ROUTINES THAT CHANGE THINGS IN SUCH A WAY
THAT PCB LOCKING IS NOT SUFFICIENT GET THE FILE LOCK MODIFIED.
IT IS NOT PERMISSIBLE TO JUST GET A RIB LOCKED DOWN AND THEN READ OR MESS
WITH THE DDB POINTERS - IT IS ABSOLUTELY REQUIRED THAT THE FILE
BE LOCKED.
@@ENTRY
EXPECTS F/ DDB.
@@ACCUM
DESTROYS NO ACS.
@@ #

INTERN LOKMOD,LOKUNM

LOKUNM:	PUSH	P,P1
	SETZ	P1,
	JRST	LOKUM2

LOKMOD:	PUSH	P,P1
	MOVSI	P1,DEPFLK

LOKUM2:	SKIPE	DEVLOK(F)	;BETTER NOT BE LOCKED ALREADY.
	 STOPCD                         ;;LOKUM2+1
	PUSH	P,T3		;
	PUSH	P,T2		;
	MOVSI	T3,DEPFLK	;SET THE
	ANDCAM	T3,DEVBTS(F)	;STATUS
	JUMPE	P1,.+2		;FLAG
	IORM	T3,DEVBTS(F)	;APPROPRIATELY.
	HRRZ	T2,DEVATB(F)	;T2/ ATB ADDRESS.
	HRRZ	T3,ATBLOK(T2)	;T3/ 1ST IN QUEUE.
	JUMPN	T3,LOKUM4	;JUMP IF SOMEBODY IS IN QUEUE.

    ;HERE ON NO ONE IN QUEUE.
LOKUM3:	HRRM	F,ATBLOK(T2)	;POINT ATB TO US.
	HRRZI	T3,-1		;POINT US TO ATB
	HRLZM	T3,DEVLOK(F)	;AND AHEAD TO EOQ.
	JRST	LOKUT4		;DONE.

    ;HERE ON OTHERS IN THE QUEUE ALREADY.
LOKUM4:	JUMPN	P1,LOKUM6	;JUMP IF MODIFYING.
	PUSH	P,T1		;(UNMOD CAN START IF NO MODI-
	PUSH	P,T4		;FIERS AHEAD OF IT IN Q.).
	SETZ	T1,		;T1/ FLG IF SOMEBODY IN
LOKUM5:	HLLZ	T4,DEVBTS(T3)	;QUEUE
	TLNE	T4,DEPFLK	;IS A
	SETO	T1,		;MODIFIER.
LOKUM6:	HRRZ	T2,DEVLOK(T3)	;T2/ NEXT IN QUEUE.
	JUMPE	T2,LOKUM7	;ANYONE THERE?
	HRRZI	T3,(T2)		;YES.
	JUMPN	P1,LOKUM6	;
	JRST	LOKUM5		;
LOKUM7:	HRRM	F,DEVLOK(T3)	;FOUND EOQ. POINT PREV LAST
	HRLZM	T3,DEVLOK(F)	;TO US, AND WE TO IT AND EOQ.
	JUMPN	P1,.+2		;CAN'T START IF MODIFIER, OR IF
	JUMPE	T1,LOKUOT	;UNMOD & A PRECEEDING MODIFIER.
	PUSH	P,J		;PUT THIS JOB INTO
	MOVE	J,JOB		;THE ATOMIC
	MOVEI	T2,FLWQ		;FILE
	DPB	T2,PJBSTS	;WAITING
	POP	P,J		;QUEUE.
	PUSHJ	P,WSCHED	;
	JUMPN	P1,LOKUT4	;
LOKUOT:	POP	P,T4		;
	POP	P,T1		;
LOKUT4:	POP	P,T2		;
	POP	P,T3		;
	POP	P,P1
	POPJ	P,

	$END	(MAP)		;End of MAPIO  (MAPLIT: MAPEND:)
      5!}$)