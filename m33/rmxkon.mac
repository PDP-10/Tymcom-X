TITLE RMXKON - Driver for RM03 or RP06 disks on KS-2020
SUBTTL RM03 DRIVER

	STOPCD(,ENTRY,RMXKON)
	ND	FTDPAG,0	;Use UNIBLK instead of UNIPAG

;THIS HACK WRITTEN BY DANIEL S. BLOM
;ASSEMBLE WITH KSSYM.MAC, WHICH SHOULD CONTAIN KS-10 I/O INSTRUCTION OPDEFS.

;DEPENDENCIES:
;IN ORDER TO CLEAR THE RH11C CONTROLLER, A DRIVE WHICH DEFINATELY EXISTS
; MUST BE SELECTED.  THIS CODE ASSUMES UNIT 0 ALWAYS EXIST.

EXTERN BITTBL,PIHIGH,PILOW,RMACB
EXTERN UNIPPU,UNYPPY,UNYPUN,UNISVA,UNITWC,UNIOFS,UNIONC
IFE FTDPAG,<EXTERN UNIBLK>		;Used to be UNIBLK
IFN FTDPAG,<EXTERN UNIPAG>
EXTERN UNYBPT,UNYBPY,UNICHR	;Blocks per track, blocks per cylinder
EXTERN UNISBH,UNISB,UNISBS,SBSIZ
EXTERN KCMOFL,%OFLER,%OFLRS,KONCUA
EXTERN KCMDTA,KONPTR
EXTERN KCMFUS,KCMERR,KCMRER
EXTERN UNIRCT,UNPDEV,EPT,UNIDES,UNYUTP
EXTERN UNYOCV,UNYRTO,UNYRCO,UNYOS,UNIRC1,UNISB

;BIT TABLE, LSB=INDEX 0
ZOT==1
TIBTBL::
REPEAT 44,<ZOT
ZOT==ZOT+ZOT>

OPDEF CALL [PUSHJ P,]		;SUBROUTINE ENTRY/EXIT
OPDEF RET [POPJ P,]

DEFINE FOO(BAR,ZORP,BAZ,S)
<BAR'AD1: UA1,,BAR'ADR
BAR'LOC=BAR'ADR
>

;DEVICE REGISTER BIT ASSIGNMENTS.  SEE USER MANUAL FOR SEMANTICS.  NOTE
; THAT THESE VALUES ARE ACTUALLY DEFINED IN KSSYM, REPEATED HERE FOR CLARITY.
FOO (CS1,776700,<SC,TRE,MCPE,,DVA,PSEL,A17,A16,RDY,IE,F4,F3,F2,F1,F0,GO>)
    ;FUNCTION CODES + GO BIT.
	F.NO==   1	;No operation
	;        3	;Unload
	F.SEEK== 5	;Seek
	F.RECA== 7	;Recalibrate
	F.DC==  11	;Drive clear
	;       13	;Release
	F.OFFS==15	;Offset
	;       17	;Return to centerline
	F.RIP== 21	;Read-in preset
	F.PA==  23	;Pack acknowledge
	;       31	;Search
	;	51	;Write check data
	;	53	;Write check header and data
	F.WD==  61	;Write data
	;	63	;Write header and data
	F.RD==  71	;Read Data
	;	73	;Read header and data
FOO (CS2,776710,<DLT,WOE,UPE,NED,NEM,PGE,MXF,MDPE,OR,IR,CLR,PAT,BAI,U2,U1,U0>)
FOO (DS,776712,<ATA,ERR,PIP,MOL,WRL,LBT,PGM,DPR,DRY,VV,,,,,,OM>)
FOO (WC,776702)
FOO (AS,776716)
FOO (ER1,776714,<DCK,UNS,OPI,DTE,WLE,IAE,AOE,HCRC,HCE,ECH,WCF,FER,PAR,RMR,ILR,ILF>)
FOO (ER2,776742,<BSE,SKI,OPE,IVC,LSC,LBC,,,DVC,,,DPE>)
FOO (EC1,776744)
FOO (EC2,776746)
FOO (BA,776704)
FOO (OF,776732,<OFD>,200)
FOO (LA,776720)
FOO (DA,776706)
FOO (DC,776734)
FOO (DT,776726)
FOO (PGR,763000,<REV,DIS,FST,VAL>,400000)
UA1AD1:	UA1,,UBAADR

;DISK PARAMETER ARRAYS.  0=RM03, 1=RP06
BPT:	EXP ^D30,	^D20		;BLOCKS PER TRACK
PPC:	EXP ^D37,	^D95		;PAGES PER CYLINDER
PPU:	EXP ^D37*^D823,	^D95*^D815	;PAGES PER UNIT
USPR=^D17300	;MICROSECONDS PER REVOLUTION.
;INTERFACE TO FILIO AND FRIENDS.

;INITIALIZE UNIT AND SET CAPACITY PARAMETERS IN UDB.
RMXCPY::MOVSI	T1,(1B8)	;1 block per record
	MOVEM	T1,UNICHR(U)	;Sign bit off = formatted in blocks
	RDIO	T3,@DTAD1	;Get drive type
	ANDI	T3,2
	LSH	T3,-1
	DPB	T3,UNYUTP	;0=RM03, 1=RP06
	MOVE	T1,PPC(T3)
	DPB	T1,UNYPPY	;Pages per cylinder
	MOVE	T1,PPU(T3)
	MOVEM	T1,UNIPPU(U)	;Pages per unit
	MOVE	T1,BPT(T3)
	DPB	T1,UNYBPT	;Blocks per track
	MOVEI	T4,3		;TRY TO GET DRIVE 3 TIMES
CPY0:	MOVEI	T3,CS2CLR	;CLEAR CONTROLLER.  SELECTS UNIT 0.
	WRIO	T3,@CS2AD1
	LDB	T1,UNYPUN	;SELECT DRIVE
	WRIO	T1,@CS2AD1
	RDIO	T2,@DSAD1
	RDIO	T1,@CS2AD1	;CHECK CONTROLLER
	MOVEI	T3,CS2CLR	;CLEAR CONTROLLER. NOTE SELECTS UNIT 0.
	WRIO	T3,@CS2AD1
	TRNN	T1,CS2NED	;DRIVE THERE?
	 JRST	CPY1		;YES
	SKIPA	T1,[%OFLRS]	;Offline - no response
CPYERR:	 MOVEI	T1,%OFLER	;Offline - error
	MOVEM	T1,UNIONC(U)	;Store %OFLRS or %OFLER
CPYER1:	MOVSI	T1,KCMOFL
	JRST	FILINT##	;Tell FILIO drive is off line

CPY1:	TRNN	T2,DSMOL	;DRIVE ON LINE?
	 JRST	[SETZM UNIONC(U) ;Drive responds but is offline
		 JRST  CPYER1]
	LDB	T1,UNYPUN	;SELECT UNIT AGAIN.
	WRIO	T1,@CS2AD1
	MOVEI	T1,F.PA		;TRY TO SET DSVV
	WRIO	T1,@CS1AD1
	RDIO	T2,@DSAD1
	TRNE	T2,DSVV		;VOLUME VALID?
	 JRST	CPY2
	MOVEI	T1,F.DC		;DRIVE CLEAR
	WRIO	T1,@CS1AD1
	SOJG	T4,CPY0
	JRST	CPYERR		;GIVE UP IF STILL BAD

CPY2:	MOVSI	T1,(1B1)
	TRNE	T2,DSWRL	;WRITE LOCKED?
	 MOVEM	T1,UNIONC(U)	;YES, SET BIT
	TRNE	T2,DSERR	;ANY RANDOM ERRORS LEFT?
	 JRST	CPYERR		;YES, SAY OFFLINE.
	LDB	T1,UNYPUN
	MOVE	T1,BITTBL(T1)
	JRST	FILINT##	;Tell FILIO about interrupt done
;SKIP IF CONTROLLER UP, SINGLE RETURN IF NOT.
RMXUPA::MOVEI T1,UBAINI		;CLEAR UBA
	WRIO T1,@UA1AD1
	MOVEI T1,PIHIGH*10+PILOW	;RESET PIA.  SILLY HARDWARE CLEARS IT.
	WRIO T1,@UA1AD1
	RDIO T1,@CS1AD1
CPOPJ1:	AOS (P)
CPOPJ:	RET

;STOP HUNG CONTROLLER.  SINGLE RETURN IF OPERATION COULDN'T
; BE RESTARTED, SKIP IF IT COULD.  CURRENTLY, ALWAYS SINGLE RETURNS.
RMXSTP::LDB T1,UNYPUN
	WRIO T1,@CS2AD1
	MOVEI T1,F.DC+CS1IE
	WRIO T1,@CS1AD1
	RET

;ISSUE RECALIBRATE (SAME EFFECT AS SEEK TO
; CYLINDER 0, BUT DOESN'T USE SEEK CIRCUITRY).  SKIP IF COULD (ALWAYS SKIPS).
RMXRCL::LDB T1,UNYPUN
	WRIO T1,@CS2AD1
	MOVEI T1,F.RECA+CS1IE
	WRIO T1,@CS1AD1
	POPJ P,0			;JRST CPOPJ1 /GL 6-11-80

;Perform latency calculation for disk page number specified in T1.
; The latency is the time required for the disk to rotate until the requested
; page is under the heads.  The number of microseconds is returned in T1.

RMXLTM::
IFN FTDPAG,<;T1 is page # to check for latency time
	LSH	T1,P2BLSH	;Convert page number to block number
>
	SETO	T4,
	MOVEI	T3,3		;Try twice for constant
LTM1:	MOVE	T2,T4
	RDIO	T4,@LAAD1	;Read Look-Ahead register
	CAME	T2,T4
	 SOJG	T3,LTM1
	LSH	T4,-6		;Keep only the block number
	LDB	T3,UNYBPY
	IDIV	T1,T3		;Block within cylinder
	LDB	T1,UNYBPT
	IDIV	T2,T1		;Block within track
	SUBI	T3,(T4)		;Delta blocks
	SKIPGE	T3
	 ADD	T3,T1		;Have to go around again
	IMULI	T3,USPR		;Microseconds per revolution
	MOVE	T1,T3
	RET			;Return time in T1
;ENTER OFFSET MODE.  NOT YET IMPLEMENTED.
RMXOFS::SETZ T1,		;ALWAYS CLEAR OFFSET MODE FOR NOW.
	JRST RMXOF1
	LDB T1,UNYPUN		;SELECT UNIT.
	WRIO T1,@CS2AD1
	LDB T1,UNYOCV
	JUMPE T1,RMXOF1		;J-CLEAR OFFSET MODE.
	ANDI T1,1		;SET OFFSET DIRECTION.
	IMULI T1,OFOFD
	WRIO T1,@OFAD1
	MOVEI T1,1		;SET OFFSET MODE.
RMXOF1:	DPB T1,UNYOS
	RET

;HERE FROM FILIO TO COPY REGISTERS INTO PERMANENT PLACE FOR HARD ERRORS

RMXHRD::HRLI	T1,UNISB(U)	;GET SOURCE ADDRESS
	HRRI	T1,UNISBH(U)	;GET WHERE THE REG DATA GOES
	BLT	T1,UNISBH+SBSIZ-1 ;XFER THE DATA.
	POPJ	P,		;DONE.

;HERE TO COPY REGISTERS TO UNISBS FOR SOFT DATA, CALL FROM FILIO
RMXSFT::MOVSI	T2,UNISB(U)	;SOURCE
	HRRI	T2,UNISBS(U)	;DEST
	BLT	T2,UNISBS+SBSIZ-1 ;BLT THERE
	POPJ	P,		;AND RETURN.
;THE NEXT THREE ROUTINES FORM THE BODY OF THE TRANSFER CODE.
;RMXRED,RMXWRT INITIALIZE; RMXADD ATTEMPTS TO CONSOLIDATE MULTIPLE
; TRANSFERS IN THE SAME DIRECTION TO OR FROM THE DISK;
; RMXFIN STARTS THE TRANSFER UP.
;THE TRANSFER WILL NOT CROSS A CYLINDER BOUNDARY.
;THE ACS P1-P4 ARE PRESERVED BY FILIO OVER THE PSEUDO CO-ROUTINE CALLS,
; AND ARE USED AS FOLLOWS:
;   P1/ READ OR WRITE COMMAND AS APPROPRIATE
;   P2/ RH: NUMBER OF PDP-10 WORDS ALREADY DECIDED TO TRANSFER.
;           THIS IS USUALLY ALSO THE VIRTUAL ADDRESS OF THE START OF THE XFR.
;       LH: PDP-10 PAGE OFFSET OF FIRST WORD TO BE TRANSFERRED. (USUALLY 0)
;   P3/ NUMBER OF WORDS BEFORE END OF CYLINDER.
;       THE ADD ROUTINE WILL NOT WRITE MORE THAN THIS NUMBER OF
;       WORDS AT ONCE.

RMXRED::SKIPA	P1,[F.RD+CS1IE]
RMXWRT:: MOVEI	P1,F.WD+CS1IE	;WRITE instruction
	SETZ	P2,		;No offset from start of page
IFE FTDPAG,<
	MOVE	T1,UNIBLK(U)	;Disk block address for start of transfer
>
IFN FTDPAG,<
	MOVE	T1,UNIPAG(U)	;Disk page address for start of transfer
	LSH	T1,P2BLSH	;Convert to block number
>
	LDB	P3,UNYBPY	;Blocks per cylinder
	IDIV	T1,P3		;T1: CYLINDER, T2: FRACTION OF CYLINDER
	SUBI	P3,(T2)		;Blocks to end of cylinder
	LSH	P3,7		;P3: NUMBER OF WORDS TO END OF CYLINDER.
	CAILE	P3,37000	;31P MAX. BECAUSE OF WC REGISTER.
	 MOVEI	P3,37000
	LDB	T3,UNYPUN	;UNIT USED FOR TRANSFER
	WRIO	T3,@CS2AD1	;Select it
	LDB	T4,UNYBPT	;Blocks per track
	IDIV	T2,T4		;T2: TRACK, T3: BLOCK
	DPB	T2,[POINT 8,T3,27] ;8-bits track, 8-bits sector
	WRIO	T3,@DAAD1	;Tell RH11 track and sector
	RET

;RMXADD can be called repeatedly to transfer contiguous disk pages to
;scattered memory pages.  RMXFIN is called start this contiguous transfer
;by giving the RH11 a single command.

;ADD TRANSFER OF T1 WORDS TO/FROM CORE ADDRESS IN T2.
;TRANSFERS WHICH AREN'T EVEN MULTIPLES OF PAGES GOING TO
; PAGE BOUNDARIES WILL BE DONE ONE AT A TIME.
IFE FTDPAG,<;T1 and T2 both have words
RMXADD::TRNN T1,777
	TRNE T2,777
	 JRST ADDNPA		;NOT EVEN TRANSFER
>
IFN FTDPAG,<;Add transfer of T1 pages to/from memory page in T2.
RMXADD::LSH	T1,P2WLSH	;# of words to transfer
>
;P2 has offset from start of page if not starting at a page boundry
ADDEVN:	CAMGE	P3,T1		;More space than is actually left?
	 SKIPA	T1,P3		;No, only to end of cylinder
	  AOS	(P)		;Yes, set for skip return
	SUB	P3,T1		;Update # words to EOC
	LDB	T3,[POINT 9,P2,26] ;Page number of offset (starts at 0)
	ADD	P2,T1		;Total words added so far
	LSH	T1,W2PLSH	;Convert back to # of pages to transfer
IFE FTDPAG,<
	SKIPN	T1		;If ADDNPA is doing less than 1 page
	 MOVEI	T1,1		; map just that partial page
	MOVE	T4,T2		;PDP-10 ADR OF START OF THIS TRANSFER
	LSH	T2,W2PLSH	;KS10 physical memory page number
>
IFN FTDPAG,<
	MOVE	T4,T2		;PDP-10 ADR OF START OF THIS TRANSFER
	LSH	T4,P2WLSH	;Make word address (Why? T4 is not used)
>
	MOVNS	T1		;Make AOBJN pointer
	HRL	T2,T1		; in T2
	ADD	T3,[UA1,,PGRLOC];UNIBUS address of 1st paging RAM register
ADDPLP:	MOVEI	T1,PGRFST+PGRVAL(T2)	;Set FAST+VALID+physical page #
	WRIO	T1,@T3		;So RH11 can address KS10 memory
	ADDI	T3,1		;Next paging RAM register
	ADDI	T4,1000
	AOBJN	T2,ADDPLP
	RET			;Skip return if not at end of cylinder

IFE FTDPAG,<;Here if T1 or T2 is not at a page boundry
ADDNPA:	MOVE	P2,T2		;Get the bits that will be lost via LSH -9
	ANDI	P2,777		; ...
	MOVSS	P2		;Put them in LH of P2
	CALL	ADDEVN		;Do partial page transfer
	 STOPCD			;End-of-Cylinder return - impossible
	RET			;Give non-skip return on partial page xfer
>

;End of additions, start disk transfer

RMXFIN::HLRZ	T1,P2		;PDP-10 page offset of transfer (always 0)
	LSH	T1,2		;Convert to -11 offset
	ANDI	T1,3777		;Offset within -11 page (always 0)
	WRIO	T1,@BAAD1	;Set base address
	MOVEM	T1,UNISVA(U)	;Save starting virtual addr in case of error
	MOVNI	P2,(P2)		;Negative PDP-10 word count from RH of P2
	LSH	P2,1		;Negative PDP-11 word count (18-bit words)
	MOVEM	P2,UNITWC(U)	;Save total word count in case of soft error
	WRIO	P2,@WCAD1
	HRRZM	U,KONCUA(J)	;Set UDB of transferring unit
	LDB	T2,UNYOS	;Get bit for offset mode
	RDIO	T1,@DSAD1
	TRO	T1,(T2)
	WRIO	T1,@DSAD1	;Set or clear offset mode
	WRIO	P1,@CS1AD1	;Start transfer (RD or WD)
	RET

;Position to cylinder

RMXPOS::LDB	T1,UNYPUN	;Select unit
	WRIO	T1,@CS2AD1
IFE FTDPAG,<;FILIO gave us block #
	MOVE	T1,UNIBLK(U)	;Disk block address
	LDB	T2,UNYBPY	;Get blocks per cylinder
>
IFN FTDPAG,<;FILIO gave us page #
	MOVE	T1,UNIPAG(U)	;Disk page address
	LDB	T2,UNYPPY	;Get pages per cylinder
>
	IDIV	T1,T2		;Get cylinder number
	WRIO	T1,@DCAD1	;Set desired cylinder
	MOVEI	T1,F.SEEK+CS1IE
	WRIO	T1,@CS1AD1	;Start seek
	RET

;INTERRUPT HANDLER.
;ON ENTRY, ASSUMES J=KDB.  SETS U TO UDB OF TRANSFERRING
; UNIT IF IT INTERRUPTED.

;ASSUMES:
; INTR REQ <=> CS1.(SC & RDY) + (RDY 0-1 TRANSITION)
; CS1.SC <=> CS1.(TRE + MCPE) + ATTN
; CS1.TRE <=> ANY ERROR DURING TRANSFER
; ATTN <=> (DS.ERR SET FOR ANY DRIVE) +
;	 (POSITIONING DONE IN ANY DRIVE) +
;	 (DS.MOL CHANGES STATE FOR ANY DRIVE)
; DS.MOL STATE CHANGE <=> DS.VV=0

RM0INT::
RMXINT::0			;JSR HERE ON DISK INTERRUPT
	TBSAVE TBVRMX		;SAVE THE CURRENT VALUE OF THE TIME BASE
	MOVEM 17,RMXSAV+17
	MOVEI 17,RMXSAV
	BLT 17,RMXSAV+16
	MOVE P,RMXPDP
	MOVEI J,RMACB
	SETZB T1,P4		;START WITH NO ERROR BITS SET IN T1
	SKIPN U,KONCUA(J)
	 SETO P4,
	RDIO T4,@CS1AD1
	TRNE T4,CS1SC		;SPECIAL CONDITION?
	 CALL SCINT		;YES, PROCESS
	JUMPL P4,INTDIS
;HERE TO ACCOUNT FOR TRANSFER
	RDIO T4,@BAAD1		;Unibus byte address
	SUB T4,UNISVA(U)	;# of bytes transferred
IFE FTDPAG,<;Tell FILINT number of blocks transfered
	TRZE T4,777		;Round up to 512 bytes (128 PDP-10 words)
	 ADDI T4,1000
	LSH T4,W2BLSH-2		;Convert bytes to blocks
>
IFN FTDPAG,<;Tell FILINT number of pages transfered
	TRZE T4,3777		;Round up to 2K bytes (512 PDP-10 words)
	 ADDI T4,4000
	LSH T4,W2PLSH-2		;Convert bytes to pages
>
	HRRI T1,(T4)		;Set amount (block or page) in RH of T1
	TLC T1,KCMDTA		;Tell FILINT this is a data transfer
	SETZM KONCUA(J)		;REMEMBER CONTROLLER NO LONGER BUSY
INTDIS:	RDIO T4,@CS1AD1		;MAKE SURE IE SET AND ERRORS CLEAR
	SETZ P1,
	TRNN T4,CS1IE
	 HRRZI P1,CS1IE
	TRNN T4,CS1TRE+CS1MCPE
	 IORI P1,CS1TRE
	SKIPE P1
	 WRIO P1,@CS1AD1
	SKIPE T1
	 CALL FILINT##		;Tell FILIO how many pages transferred
	MOVSI 17,RMXSAV
	BLT 17,17
	TBSET TBVRMX		;RESET THE TIME BASE FOR CHARGING
	JEN @RMXINT

SCINT:	TRNN T4,CS1MCPE
	 TRNE T4,CS1TRE
	  CALL CONERR		;CONTROLLER OR TRANSFER ERROR
	SETZ T3,		;ATA BITS TO CLEAR
	RDIO P2,@ASAD1
ATA1:	JUMPE P2,SCRET
ATA2:	JFFO P2,.+1
	MOVNI P3,-43(P3)	;RH=UNIT NUMBER
	SKIPN @KONPTR(J)	;SYSTEM CONFIGURED TO HANDLE THIS UNIT?
	 JRST ATADIS		;NO, SPURIOUS INTERRUPT
	WRIO P3,@CS2AD1
	RDIO P1,@DSAD1
	TRNE P1,DSERR		;DRIVE ERRORS?
	 CALL DRVERR		;YES, JUST CLEAR THEM
	TRNN P1,DSVV		;DS.MOL STATE CHANGE?
	 CALL CHKONL		;YES, CHECK ONLINE STATUS
ATADIS:	MOVE P1,TIBTBL(P3)
	TRZN P2,(P1)		;CLEAR ATA TOO
	 JRST ATA3
	IOR T3,P1
	IOR T3,BITTBL(P3)
ATA3:	JUMPN P2,ATA2
SCRET:	WRIO T3,@ASAD1
	HLRZS T3
	TLO T1,(T3)		;SEEK DONE, SET FLAG FOR FILINT
	RET

CHKONL:	TRNN P1,DSMOL		;ONLINE?
	 JRST CHKON1		;NO
	MOVEI T4,F.RIP		;READ IN PRESET
	WRIO T4,@CS1AD1
	MOVEI T4,F.DC		;DRIVE CLEAR
	WRIO T4,@CS1AD1
	TDO T1,BITTBL(P3)	;SET FILIO FLAG
	RET

CHKON1:	JUMPN U,ONLRET		;FILIO INTERFACE LOSSAGE
	MOVE U,@KONPTR(J)
	TLOA T1,KCMOFL
ONLRET:	 TDZ P1,TIBTBL(P3)	;DON'T CLEAR BIT IF CAN'T REPORT
DRVERR:	SKIPE U
	 CALL SAVSTS		;READ RH11 AND DRIVE STATUS INTO UDB.
	RDIO T4,@ER1AD1
	TRNE T4,ER1UNS		;FILE UNSAFE?
	 JRST [	JUMPN U,DERET
		MOVE U,@KONPTR(J)
		TLO T1,KCMFUS+KCMOFL
		JRST .+1]
	MOVEI T4,F.DC		;CLEAR DRIVE ERRORS+ATA
	WRIO T4,@CS1AD1
DERET:	TDZ P1,TIBTBL(P3)	;DON'T CLEAR ATA BIT
	RET

;CONTOLLER ERROR OR ERROR DURING TRANSFER
CONERR:	CALL SAVSTS		;SAVE RH11 AND DRIVE STATUS IN UDB.
	JUMPL P4,CPOPJ		;RETURN IF NOT XFR
	LDB T4,UNYPUN
	WRIO T4,@CS2AD1
	MOVEI T4,DSMOL
	TDNN T4,UNISB+2(U)
	 JRST [	TLO T1,KCMOFL+KCMDTA
		JRST CONRET]
	MOVSI T4,-NERPAT
FNDERR:	MOVE T3,UNISB(U)
	MOVE T2,UNISB+1(U)
	TDNN T2,ERPAT(T4)
	TDNE T3,CSPAT(T4)
	 CALL @XFRDSP(T4)	;PROCESS ERROR (ROUTINE MUST SKIP RETURN)
	  AOBJN T4,FNDERR
	TLC T1,KCMERR
	MOVEI T4,F.DC		;CLEAR DRIVE
	WRIO T4,@CS1AD1
CONRET:	MOVEI T4,CS1TRE
	WRIO T4,@CS1AD1
	RET

;ERROR PATTERNS
;TYPE,DEVICE,RETRY BEFORE RECAL,RECAL,
; RETRY AFTER RECAL,CS1,CS2,ER1,ER2,W,X,Y
; HERE W= NUMBER OF OFFSET STATES TO CYCLE THROUGH AFTER RECALS FINISHED.
;      X= NUMBER OF TIMES TO RETRY TRANSFER AFTER OFFSETING.
;      Y= NUMBER OF TIMES TO RECAL IF RETIRES AFTER OFFSET FAIL.
DEFINE ERRS <
X DEV,1,12,0,0,,<DLT,NEM,MXF>,<WCF>,,4,3,1
X PAR,0,12,0,0,<MCPE>,<MDPE,UPE>,<PAR>,<DPE>,0,0,0
X FMT,0,12,12,12,,,<HCRC,HCE,FER,ECH,DTE>,<BSE>,4,3,1
X PGM,1,1,0,0,,<PGE>,<WLE,RMR,IAE,AOE,ILR,ILF>,<IVC>,0,0,0
X SEK,1,0,12,12,,,<OPI>,<SKI>,4,1,1
X DAT,0,0,0,0,,,<DCK>,,0,0,0
X UNS,0,0,0,0,,<NED>,,<LSC,LBC,DVC,OPE>,0,0,0
>

;COMPLEXITY OF MACROS IS DUE TO THE LOSING ASSEMBLER BEING USED.
DEFINE BAZ(A,B,C,D) <
BAR A,<B>,ZZ
BAR C,<D>,ZZ1
ZZ,,ZZ1
>

DEFINE BAR(Y,X,Z) <
IFB <X>,<Z==0>
IFNB <X>,<
Z==0
IRP X,<Z==Z+Y'X>
>
>

DEFINE X(A,R1,R2,R3,R4,B,C,D,E,W,X,Y) <
A'ERR
>
XFRDSP:	ERRS
NERPAT==.-XFRDSP

DEFINE X(A,R1,R2,R3,R4,B,C,D,E,W,X,Y) <
BAZ CS1,<B>,CS2,<C>
>
CSPAT:	ERRS

DEFINE X(A,R1,R2,R3,R4,B,C,D,E,W,X,Y) <
BAZ ER1,<D>,ER2,<E>
>
ERPAT:	ERRS

DEFINE X(A,R1,R2,R3,R4,B,C,D,E,W,X,Y) <
R4+200000+UNPDEV*R1,,R3*1000+R2
Y,,X*1000+W
>
RCVPAT:	ERRS

;READ ALL REGISTERS INTO UDB.
SAVSTS:	PUSH P,T3
	LDB T3,UNYUTP
	MOVE T4,REGPTR(T3)
	MOVE T2,[POINT 18,UNISB(U)]
SAVST1:	ILDB T3,T4
	JUMPE T3,PT3J
	ADD T3,[UA1,,CS1ADR-1]
	RDIO T3,@T3
	IDPB T3,T2
	JRST SAVST1
PT3J:	POP P,T3
	RET

REGPTR:	POINT 6,RM03RG
	POINT 6,RP06RG
RM03RG:	BYTE (6) 1,11,15,43,3,13
	BYTE (6) 5,17,21,47,25,27
	BYTE (6) 31,33,35,41,7,45
	0
RP06RG:	BYTE (6) 1,11,15,43,3,13
	BYTE (6) 5,7,17,21,25,33
	BYTE (6) 31,35,37,41,45,47
	0

;HERE ON VARIOUS ERRORS WHICH OCCURRED DURING TRANSFER.
; T2/ ER1,,ER2   T3/ CS1,,CS2

;RECOVERABLE DATA ERROR
DATERR:	RDIO P2,@BAAD1		;FIRST -11 ADR AFTER ERROR BLOCK.
	SUBI P2,200*4		;-11 ADR OF ERROR BLOCK.
	LSH P2,W2PLSH-2		;-11 PAGE NUMBER OF ERROR BLOCK.
	ADD P2,PGRAD1
	RDIO P2,@P2		;-10 PAGE # OF ERROR BLOCK.
	LDB P2,[POINT 11,P2,26]
	TRO P2,PGE.A+PGE.W
	DPB P2,[EPTPGP(%ERR.N)]	;MAP %ERR TO PAGE CONTAINING ERROR BLOCK..
	CLRPT %ERR		;INVALIDATE THIS ENTRY IN THE PAGING CACHE.
	RDIO P2,@EC1AD1		;BIT NUMBER OF BURST.
	CAILE P2,^D18*^D256
	 JRST BADECC
	SOJL P2,BADECC
	IDIVI P2,44
	RDIO T2,@WCAD1		;-# 18. BIT WORDS LEFT IN TRANSFER.
	HRRZ T3,UNITWC(U)	;-# 18. BIT WORDS SUPPOSED TO DO.
	SUBM T2,T3		;+# 18. BIT WORDS TRANSFERRED.
	LSH T3,-1		;+# 36. BIT WORDS TRANSFERRED.
				;Also relative offset within transfer
				; of first block after error block.
	JUMPE	T3,BADECC	;Hdw is only supposed to report error
				; after >=1 physical transfer.
	SUBI	T3,200		;Relative offset of error block
	ANDI	T3,777		;Relative offset within error page
	TRNE T3,177		;DEVICE IS SUPPOSED TO INDICATE ECC TYPE ERRORS
	 JRST BADECC		; ONLY ON A SECTOR BOUNDARY.
	ADDI P2,(T3)		;FIRST WORD IN ERROR.
	RDIO T2,@EC2AD1		;ERROR BURST.
	SETZ T3,
	ROTC T2,(P3)
	MOVSS T2
	MOVSS T3
	TRC P2,177		;FIX SECOND WORD IF IN BLOCK.
	TRCE P2,177
	 XORM T3,%ERR+1(P2)
	XORM T2,%ERR(P2)
	TLCA T1,KCMRER+KCMERR	;RECOVERABLE
BADECC:	 TLC T1,KCMERR
	RET
;NOT A DATA ERROR, SET INITIAL ERROR RECOVERY VARIABLES AND PARAMETERS
; IF NOT ALREADY IN THE MIDDLE OF AN E.R. PROCEDURE.
DEVERR:PARERR:FMTERR:PGMERR:SEKERR:
	SKIPE UNIRCT(U)
	 RET
	LSH T4,1
	DMOVE T1,RCVPAT(T4)
	MOVEM T1,UNIRCT(U)
	MOVEM T2,UNIRC1(U)
	ASH T4,-1
	RET

UNSERR:	SETZM UNIRCT(U)
	SETZM UNIRC1(U)
	TLO T1,KCMERRTA+KCMOFL	;TAKE UNIT OFFLINE
	TLNE T2,ER1UNS		;UNSAFE?
	 TLO T1,KCMFUS
	RET

TBVRMX:	BLOCK 2			;2 WORDS TO SAVE THE TIME BASE VALUE
RMXSAV:	BLOCK 20
RMXPDP:	-60,,.
	BLOCK 60

	$END	(RMX)		;End of RMXKON (RMXLIT: RMXEND:)
   F Z¦