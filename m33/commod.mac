TITLE	COMMOD - COMMON DATA LOCATIONS USED BY DISK SERVICE
;ALL DATA LOCATIONS USED BY FILSER ARE HERE INSTEAD OF COMMON.

	STOPCD(,ENTRY,COMMOD)

	DEFINE GENMSK(SIZE,POS)<<1B<35-SIZE>-1>B<POS>>
	ND	FTDPAG,0	;Use UNIBLK instead of UNIPAG

IFCPU (<KI,KL>),<;Define other symbols based on DISKS and TAPES
ND TAPES,^D4		;Default is 4 tape drives
ND DISKS,^D<2*8>	;Default is 2 strings of disks
ND DSKTYP,'3675B'	;Default to 3675 formatted in blocks
  XP SAXN,1		;One SA10 on KI or KL
  XP SAXC0N,2		;Two channels on SA-10 #0 (not 4 channels)
    XP BP00,0		;SA 0, Channel 0 does not have disk controller
    XP FT00,1		;SA 0, Channel 0 has a tape controller
    XP BP01,1		;SA 0, Channel 1 has disk controllers (redefined below)
    XP FT01,0		;SA 0, Channel 1 does not have tape controller
    BPAMX=<BPBMX=<BPCMX=<BPDMX=20>>>	;16 units per "Kontroller"
IFE <DSKTYP-'3652P'>*<DSKTYP-'3652B'>,<	;3652 uses logical volumes
  IFE DISKS-^D<2*8>,< ND BPAUN,^D8	;1 physical string is logical BPA0-7
		      ND BPBUN,^D0>	; and BPC0-7 (nothing on BPB or BPD)
  IFE DISKS-^D<4*8>,< ND BPAUN,^D16	;2 physical strings are logical BPA0-17
		      ND BPBUN,^D0>	; and BPC0-17 (nothing on BPB or BPD)
  IFE DISKS-^D<6*8>,< ND BPAUN,^D16	;3 physical strings are logical BPA0-17,
		      ND BPBUN,^D8>	; BPC0-17, BPB0-7, BPD0-7
  IFE DISKS-^D<8*8>,< ;Normal case>	;4 physical strings = 8 logical strings
	BPXKON==:0			;Cannot use BPXKON with 3652 disks
	EXTERN CPXKON			;Must use CPXKON with 3652 disks
>  ;End 3652 special definitions    (See also UNIOLV definition)
IFE <DSKTYP-'3650P'>*<DSKTYP-'3650B'>*<DSKTYP-'3675P'>,<
			BPXKON==:0	;Must use CPXKON
			EXTERN	CPXKON>
IFE <DSKTYP-'3675B'>,<	CPXKON==:0	;Must use BPXKON
			EXTERN	BPXKON>
ND  BPAUN,DISKS			;Number of disks on first controller
IFG BPAUN-BPAMX,<BPAUN==BPAMX>	;Max of 16
ND  BPBUN,DISKS-BPAUN		;Number of disks on second controller
IFG BPBUN-BPBMX,<BPBUN==BPBMX>	;Max of 16
ND  BPCUN,DISKS-BPAUN-BPBUN	;Number of disks on third controller
IFG BPCUN-BPCMX,<BPCUN==BPCMX>	;Max of 16
ND  BPDUN,DISKS-BPAUN-BPBUN-BPCUN;Remainder on fourth controller
IFG BPDUN-BPDMX,<BPDUN==BPDMX>	;Max of 16
IFN DISKS-BPAUN-BPBUN-BPCUN-BPDUN,<PRINTX ?Cannot define more than 64 disks>
IFG BPAUN,<BP01==1>	;At least 1 controller if any BPA units defined
IFG BPBUN,<BP01==2>	;At least 2 controllers if any BPB units defined
IFG BPCUN,<BP01==3>	;At least 3 controllers if any BPC units defined
IFG BPDUN,<BP01==4>	;All four controllers if any BPD units defined
IFGE BP01-3,<IFN BPCUN-BPAUN,<PRINTX ?BPCUN must equal BPAUN for UNIOLV>>
IFE  BP01-4,<IFN BPDUN-BPBUN,<PRINTX ?BPDUN must equal BPBUN for UNIOLV>>
      BPA==300		;First disk on 1st kontroller = 'C0' hex = 300 octal
      BPB==BPA+BPAMX	;First disk on 2nd kontroller = 'D0' hex = 320 octal
      BPC==BPB+BPBMX	;First disk on 3rd kontroller = 'E0' hex = 340 octal
      BPD==BPC+BPCMX	;First disk on 4th kontroller = 'F0' hex = 360 octal
  XP FTAUN,TAPES	;All tapes are on STC controller
      FTA==200		;First unit on tape Kontroller = '80' hex
      FTATYP==2
  ND MAGUN,0		;No tapes on the I/O bus (MTASER)
>  ;End KI,KL

IFNCPU(<KI,KL>),<
  ND DISKS,4		;Default 4 disks on F3 and KS
  ND TAPES,1		;Default 1 tape on F3 and KS
  XP SAXN,0		;No SA10 on F3 or KS
  XP FTAUN,0		;No FTA on F3 or KS
  XP MAGUN,TAPES	;Tapes for MAGSER or F3TSER
  ND DSKTYP,0		;Disk type not applicable to KS,F3
>

IFCPU(KS),<
  XP RMXN,1		;RMXKON for RM03 or RP06 disks
  XP RMAUN,DISKS	;Disk units on RMA
  XP C0RMN,1		;RMA is on "channel 0"
> ; End IFCPU(KS)

IFCPU(F3),<
  XP APXN,1		;APXKON for Ampex or CDC disks
  XP APAUN,DISKS	;Disk units on APA
  XP C0APN,1		;APA is on "channel 0"
> ; End IFCPU(F3)

	ND C0DPN,0	;No DP on channel 0
	ND C1DPN,0	;No DP on channel 1
	ND C0FHN,0	;No FH on channel 0
	ND C1FHN,0	;No FH on channel 1
	ND C0MDN,0	;No MD on channel 0
	ND C1MDN,0	;No MD on channel 1
	ND C0APN,0	;No AP on KS, 1 AP on F3
	ND C0RMN,0	;No RM on F3, 1 RM on KS

IFN C0DPN!C0FHN!C0MDN!C0APN!C0RMN,<CHNN==1>
IFN C1DPN!C1FHN!C1MDN,<		   CHNN==2>
	ND CHNN,0		;No DF10 channels on KI or KL

	ND RPCBN,JOBS/3		;Number of RIB PCBs
	ND SPCBN,DISKS*3	;Number of SAT PCBs
IFG RPCBN-20,<RPCBN==20>	;Not more than 16
IFG SPCBN-20,<SPCBN==20>	;Causes NAILI3 crashes if too big
; ALL IN LEFT HALF

;BITS IN SAME POSITION AS IN RIB STATUS, FOR ERRORS
IOSHRE==RIPHRE	;HARD READ ERR,HARD WRITE ERR,
IOSHWE==RIPHWE
IOBDRB==RIPBDR	;FILE IS BAD(DEAD),DONT LET ANYONE AT IT.
IOSERR==IOSHRE!IOSHWE!IOBDRB

IOSRIB==400000	;RIB IS CURRENT IN (IN %RIB)
IOSRBE==200000	;SOME KIND OF ERROR READING RIB OR UFD
IOSUPR==100000	;SUPER USETI/USETO MODE
IOSALC==040000	;ALLOCATION FOR SOMETHING OTHER THAN FILE (UFD)
IOSSAE==020000	;SAT IS BAD.

INTERNAL IOSHRE,IOSHWE,IOSERR,IOSRBE,IOSRIB,IOSALC,IOSUPR
INTERN IOBDRB,IOSSAE

;SYMBOLS WHICH MAY BE DEFINED IN CONFIG IF A USER DOES NOT LIKE
;STANDARD DEFNS.  HOWEVER MOST CUSTOMERS WILL BE HAPPY WITH THE STANDARD
;VALUES.

	INTERN CCWMAX,PRVFIL,PRVUFD,PTRLEN

IFNDEF CCWMAX,<XP CCWMAX,^D10>	;MAX. NO OF DATA CHANNEL COMMAND WORDS. CUSTOMER MAY
			; CHANGE TO BIGGER OR SMALLER VALUE TO INCREASE THRUPUT
			; OR DECREASE SPACE.
IFNDEF PRVFIL,<PRVFIL==047>	;STANDARD FILE PRIVILEGE
				;OWNER=EVERYTHING,PROJ=READ,REST=NO ACCESS
IFNDEF PRVUFD,<PRVUFD==754>	;STANDARD UFD PRIVILEGE
				;OWNER=ALL,PROJ=ALL,REST=READ+LOOKUPS
IFNDEF PTRLEN,<PTRLEN==^D10>	;NO. OF IN CORE RETRIEVAL POINTERS PER FILE
				; LENGTH AFFECTS SIZE OF DEVICE DATA BLOCK
IFNDEF UNVRSF,<XP UNVRSF,^D500>	;RECIPROCAL SAFETY FACTOR FOR EACH UNIT
				; IE NO. BLKS ON UNIT/UNVRSF
				; IS SUBTRACTED FROM NO OF FREE BLOCKS
				; SEE STRTAL,UNITAL


IFNDEF OPNFPF,<OPNFPF==^D10>	;OPEN FIL/FRAME ESTIMATE. MUST BE SAME
				;VALUE AS IFNDEF'D IN COMMON. MAY
				;BE DEF'D IN CONFIG FOR SOME SYSTEMS. /AA

IFNDEF SYRDPR,<XP SYRDPR,444000>	;NON-PRIVILEGED FILES IN SYS
				; HOME.SYS,SAT.SYS
IFNDEF SYNRPR,<XP SYNRPR,447000>	;PRIVILEGED FILES IN SYS
			; CRASH.SAV, SNAP.SYS,RECOV.SYS,BADBLK.SYS
IFNDEF MFDPRV,<XP MFDPRV,544000>	;MFD PRIVILEGES(ALL CAN READ,LOOKUP)
			; BUT NOT CREATE
IFNDEF SYSPRV,<XP SYSPRV,754000>	;SYS UFD PRIVILEGES(PROJ 1 READ,CREATE
			;LOOKUP, OTHERS READ
			; LOOKUP ONLY


;LIMITS OF VARIOUS FIELD WIDTHS IN FILE STRUCTURES

;B2WLSH and P2WLSH now defined in S.MAC
;*;  XP BLKSPK,^D3	;# OF PLACES TO SHIFT LEFT TO CONVERT BLOCKS TO K
;*;  XP BLKSPP,^D2	;# OF PLACES TO SHIFT LEFT TO CONVERT BLOCKS TO PAGES
;*;  BLKSIZ==1_B2WLSH	;# OF WORDS IN A DISK BLOCK (MUST BE POWER OF 2)
;*;  XP WRDSPP,^D9	;# OF PLACES TO SHIFT LEFT TO CONVERT PAGES TO WORDS
;*;  BLKBPK==^D1024/BLKSIZ	;# OF BLOCKS PER J WORDS

;COMMON LOCATIONS (FOR COMMON SEARCH ROUTINES)
INTERNAL CMBLNK,CMBNAM

CMBNAM==0	;NAME DRBNAM AND FNBNAM MUST BE THE SAME AS THIS

CMBLNK==1	;LINK (LH) DRBLNK AND FNBLNK MUST BE SAME

CMBDWN==2	;DOWN POINTER (LH) DRBFNB AND FNBATB MUST BE SAME
XP CMBSIZ,ATBSPT+1	;SIZE OF A CORE BLOCK


;PAG - PARAMETERS WHICH APPEAR IN MORE THAN ONE DISK PAGE.
INTERN PAGNAM,PAGCOD,PAGSLF

PAGNAM==0		;SIXBIT NAME OF LPAGE (HOM OR BAT).
PAGCOD==776		;SELF INDENTIFYING CODE FOR PAGE RH ONLY, LH=0.
PAGSLF==777		;RETRIEVAL POINTER TO THIS PAGE.
COMMENT ; ATB (ACCESS TABLE BLOCK ) DEFINITIONS

THERE IS ONE ATB FOR EACH ACTUAL FILE ON THE DISK THAT IS
IN USE. THE 'FILE' THE ATB CORRESPONDS TO MAY NOT APPEAR
IN THE DIRECTORY, IT MAY HAVE BEEN SUPERCEDED OR NOT YET
ENTERED. IN THIS CASE, THE ATB WILL BE IN THE MARKED FOR
DELETION, OR IN THE CREATE STATE. THE FOLLOWING ARE THE ATB
STATES

CREATE
SUPERCEDE
READ
UPDATE
RENAME
MARKED FOR DELETION.

THERE MAY BE ANY NUMBER OF ATB'S MARKED FOR DELETETION FOR A FILE NAME.
THESE ATBS CANNOT HAVE ANY "WRITE" FIELDS ON (UPD, CRE, SUP, MXU)
THE REMAINING ATBS FOR A GIVEN FILE NAME CAN ONLY OCCUR IN THE
FOLLOWING CONFIGURATIONS:
1) EXACTLY ONE SUPERCEDE ATB, WHOSE UMC,CNT,MWC FIELDS MAY
   BE NON-ZERO, PLUS A POSSIBLE ATB WHICH HAS ALL "WRITE"
   FIELDS AND BITS ZERO, AND ATBCNT AND/OR ATBUMC NON-ZERO.
   SOMETIMES THIS SUPERCEDE ATB HAS ATPUPD
   ON INSTEAD OF ATPSUP SO THAT USERS WHO LOOKUP THE
   FILE WHILE THE NEW VERSION IS BEING CLOSED WILL GET
   THE NEW VERSION.  THUS, THE SUPERCEDE ATB CAN ONLY HAVE
   ATBCNT NON-ZERO AFTER ATPUPD IS SET. ATBUMC AND MWC
   CAN BE NON-ZERO DUE TO EITHER THE SUPERCEDER OR TO LOOKUPS
   DONE AFTER ATPUPD IS SET.
2) EXACLY ONE ATB WITH ATPUPD OR ATPMXU ON (SINGLE OR SIMULTANEOUS
   UPDATE).  ATBCNT, ATBMWC, AND ATBUMC MAY BE INCREMENTED.
3) EXACTLY ONE ATB WITH ATPCRE ON. ATMUMC MAY BE NON-ZERO,
   BUT ONLY THE CREATOR HAS ANYTHING MAPPED FROM THE FILE
   BEING CREATED. ATBCNT MUST BE ZERO, SINCE NO CHANNEL
   INCLUDING THE OWNER CAN HAVE A FILE BEING CREATED
   OPEN FOR READ OR UPDATE.
4) EXACLY ONE ATB WITH ATPREN ON. ATBUMC AND ATBCNT MAY
   BE NON-ZERO, REPRESENTING READERS OF THE FILE WHEN
   THE RENAME IS BEING DONE, BUT ATPMXU, ATPCRE, ATPSUP,
   AND ATPUPD MUST BE ZERO, I.E. NO WRITERS OF THE FILE
   CAN EXIST.
;
INTERNAL ATPCNT,ATPUFE,ATPPID,ATPALC,ATBRIB,ATMCSC,ATBSTS,ATMUFU,ATYCNT
INTERNAL ATBPVW,ATPDMP,ATYADT,ATYBLK,ATYCDT,ATYCSC,ATYCTD
INTERNAL ATYCTM,ATYPRV,ATYUF1,ATYUF2,ATYXCD
INTERN ATYBSZ,ATYWSZ,ATYALP,ATPSUP,ATPUPD,ATPCRE,ATPREN
INTERN ATPDEL,ATPNDL,ATPDIR,ATBDOR,ATBLNK,ATBSIZ,ATBPRV
INTERN ATBMSC,ATBLIC,ATBLCW,ATBFNB,ATBCNT,ATBALP,ATMUFP,ATMCNT
INTERN ATPDUM,ATPUMC,ATMUMC,ATBUMC,ATBSPT,ATPMWC,ATPMWC,ATMMWC
INTERN ATBMWC,ATPMXU,ATBDUM,ATBLOK,ATSWRD,ATSBLK,ATBPID

ATBRIB==0	;RETRIEVAL POINTER FOR THE FILE'S RIB
ATBFNB==1	;RH POINTER TO THE NAME BLOCK FOR THIS FILE
ATBLNK==1	;LH LINK TO NEXT ATB FOR THIS FILE
ATBSIZ==2	;NUMBER OF WORDS IN THIS FILE (IN 3 FIELDS)
		;(THAT IS, NUMBER OF HIGHEST WORD WRITTEN.).
 ATSWRD==7	;7 BITS OF WORDS
 ATNWRD==^D35	;RIGHT 7 BITS
 ATBWRD==ATBSIZ

 ATSBLK==2	;2 BITS OF BLOCKS
 ATNBLK==^D28
 ATBBLK==ATBSIZ

 ATSPGS==^D26
 ATNPGS==^D26
 ATBPGS==ATBSIZ	;PAGES IN FILE (FULL PAGES)

 ATYBSZ: POINT ATSBLK+ATSPGS,ATBSIZ(T2),ATNBLK ;POINTER TO NO.
		;OF BLOCKS (ROUNDED UP) IN FILE.

ATYWSZ: POINT ATSWRD,ATBSIZ(T2),ATNWRD ;POINTER TO NO. OF WORDS
		;IN LAST BLOCK OF FILE.

ATBPVW==3	;PRIV WORD FOR LOOKUP (DATE, MODE, ETC)
 ATSPRV==^D9	;PRIV FIELD
 ATNPRV==^D8
 ATBPRV==ATBPVW

 ATSMOD==4	;MODE
 ATNMOD==^D12
 ATBMOD==ATBPRV

 ATSCTM==^D11	;CREATION TIME IN MIN
 ATNCTM==^D23
 ATBCTM==ATBPVW

 ATSCDT==^D12	;CREATION DATE (LOW 12 BITS)
 ATNCDT==^D35
 ATBCDT==ATBPVW


ATBLCW==4	;LIC ETC, GOES IN RIBCNA

ATSUF1==4	;FIRST 4 UFD BITS
 ATNUF1==3
 ATBUF1==ATBLCW

 ATSUF2==^D8	;NEXT 8 BITS
 ATNUF2==^D11
 ATBUF2==ATBLCW

 ATPDMP==(1B4)	;IF ON SAYS FILE DUMPED SINCE LAST CAHNGE
 ATPUFE==(1B5)	;A BIT SO AN ERROR GETS RECORDED IN THE UFD
		;NOTE THAT ATPUFE MUST=RIPUFE.
 ATPPID==(1B6)	;FOR UFDS, MEANS THIS UFD SHOULD HAVE SPECIAL PID
		; STORAGE ACCOUNTING (NOT USED BY MONITOR).
		;FOR FILES, MEANS THIS FILE HAS A NON-ZERO PID
		; (KEPT BY THE MONITOR).
 ATPALC==(1B7)	;BIT THAT SAYS ALLOCATION HAS CHANGED ON THIS FILE.
		; BIT APPEARS IN UFD SO DSKCLN CAN SCAN IN FAST MODE
		; AND ONLY OR IN THE BITS IN THE SATS FOR FILES WITH
		; THIS BIT ON.

 ATMUFP==(GENMSK(2,\<ATNUF1-ATSUF1+2>)+GENMSK(4,\<ATNUF2-ATSUF2+4>))
 ATMUFU==(GENMSK(ATSUF1,ATNUF1)+GENMSK(ATSUF2,ATNUF2))
ATMUFU==ATMUFU-ATMUFP
 ATSCSC==^D6	;CREATION TIME SECONDS
 ATNCSC==^D17
 ATBCSC==ATBLCW

 ATMCSC==(GENMSK(ATSCSC,ATNCSC))

 ATSLIC==^D18
 ATNLIC==^D35
 ATBLIC==ATBLCW	;LIC IN RH

ATBMSC==5	;MISC STUFF
 ATSXCD==2	;EXTENDED DATE INFO
 ATNXCD==^D3	;HIGH ORDER 2 BITS UNUSED
 ATBXCD==ATBMSC

 ATSADT==^D14	;ACCESS DATE
 ATNADT==^D17
 ATBADT==ATBMSC

ATBLOK==ATBMSC	;FIRST DDB ON ATOMIC FILE LOCKING QUEUE.

ATBDOR==6	;DORMANT POINTER
ATBALP==7	;NUMBER OF ALLOCATED PAGES (RIGHT 26 BITS ONLY)
		;BIT 0 MUST BE 0.
		;INCLUDES RIBS.
		;DOES NOT INCLUDE HOLES.
  ATYALP: POINT ^D26,ATBALP(T2),^D35

ATBPID==10	;PROCESSOR ID OF THE FILE. IN ATB FOR ACCESS CHECKING.

;THE FOLLOWING LOCATIONS ARE CONTAINED IN BOTH A REAL
; ATB AND DUMMY ATBS.

XP DABOFS,11	;HOW MUCH TO SUBTRACT FROM ADDRESS IN JBTDAB
		; TO GET SOMETHING THAT CAN BE INDEXED BY THE
		; FOLLOWING WORD VALUES.

ATBSTS==11	;GENERAL STATUS INFORMATION
 ATBDUM==ATBSTS	;WORD WITH "THIS IS A DUMMY ATB BIT" IN IT
 ATPDUM==400000	;THIS IS A DUMMY ATB (MUST BE SIGN BIT)

 ATSUMC==^D17	;COUNT OF NUMBER OF SLOTS MAPPING
		; A PAGE FROM THIS FILE WHOSE DP IS NOT IN SPT,
		; PLUS ONE IF AN SPT EXISTS.
 ATNUMC==^D17	;ALL BUT SIGN BIT
 ATPUMC==(1B<ATNUMC>) ;FOR INCREMENTING
 ATMUMC==(GENMSK(ATSUMC,ATNUMC))
 ATBUMC==ATBSTS

 ATSCNT==^D8	;COUNT OF NUMBER OF I/O CHANNELS OPEN FOR READ.
 ATNCNT==^D35	;RIGHT JUSTIFIED
 ATBCNT==ATBSTS
 ATPCNT==1B<ATNCNT>
 ATMCNT==GENMSK(ATSCNT,ATNCNT)

 ATPCRE==000400	;CREATE
 ATPSUP==001000	;SUPERCEDE
 ATPREN==002000	;RENAME
 ATPUPD==004000	;SINGLE UPDATE (ALSO USED TO LOCK THE FILE)
 ATPDEL==010000	;MARKED FOR DELETEION
 ATPNDL==020000	;DO NOT ALLOW DELETE, RENAME, SUPERCEDE, ETC
 ATPDIR==040000	;THIS IS A DIRECTORY
 ATPMXU==100000	;THE MAX WRITE COUNT IS UP. (SO DON'T HAVE TO CHECK ANOTHER WORD
		; TO SEE IF ATB IS UNUSED.

ATBSPT==12	;SPT AND MAX WRITE WORD
		;LH IS SPT POINTER TO FIRST SPT TABLE, RH
		; IS MAX WRITE COUNT

 ATSMWC==^D18	;COUNT OF 1) NUMBER OF I/O CHANNELS OPEN FOR UPDATE (BOTH FLAVORS)
		; 2) NUMBER OF SLOTS MAPPING A PAGE OF THIS FILE
		;THAT HAVE MAX WRITE BIT SET.
 ATNMWC==^D35	;POSITION RIGHT JUSTIFIED SO CAN AOS
 ATPMWC==1B<ATNMWC>
 ATMMWC==GENMSK(ATSMWC,ATNMWC)
 ATBMWC==ATBSPT

XP DABSIZ,ATBSPT-DABOFS+1	;NUMBER OF WORDS PER DUMMY ATB.

ATYADT:	POINT ATSADT,ATBADT(P2),ATNADT
ATYCDT:	POINT ATSCDT,ATBCDT(P2),ATNCDT
ATYCSC:	POINT ATSCSC,ATBCSC(P2),ATNCSC
ATYCTM:	POINT ATSCTM,ATBCTM(P2),ATNCTM
ATYPRV:	POINT ATSPRV,ATBPRV(P2),ATNPRV
ATYUF1:	POINT ATSUF1,ATBUF1(P2),ATNUF1
ATYUF2:	POINT ATSUF2,ATBUF2(P2),ATNUF2
ATYXCD:	POINT ATSXCD,ATBXCD(P2),ATNXCD
ATYCTD:	POINT ATSCTM+ATSCDT,ATBCTM(P2),ATNCDT
ATYBLK:	POINT ATSBLK+ATSPGS,ATBBLK(P2),ATNBLK
ATYCNT:	POINT ATSCNT,ATBCNT(P2),ATNCNT


COMMENT ; FNB - THE FILE NAME BLOCK, THERE IS ONE OF THESE FOR
EACH FILE IN USE OR DORMANT. THERE MAY BE SEVERAL ATB'S FFOR
EACH FNB IF SOME ARE MARKED FOR DELETION OR THERE IS A SUPERCEDE
AND A READ BLOCK ;

INTERN FNBNAM,FNBLNK,FNBEXT,FNBATB,FNBDRB,FNBRIB,FNBAPD
INTERN FNBSTS,FNBDBL,FNPLOK,FNBLOK,FNYUFP,FNPNX,FNBNX,FNBUPD,FNBALT
FNBNAM==0	;FILE NAME IN SIXBIT
FNBLNK==1	;LH POINTER TO NEXT FNB FOR THIS USER
FNBEXT==1	;RH EXTENSION OF FILE IN SIXBIT
FNBATB==2	;LH POINTER TO ATB'S FOR THIS FILE
FNBDRB==2	;RH POINTER TO DIRECTORY BLOCK (DRB)
FNBRIB==3	;RETRIEVAL POINTER TO FILE RIB
FNBAPD==4	;APPEND WORD (IF UPDATE APPEND MODE)

FNBSTS==5	;A STATUS WORD

 FNSNX==1	;DOES NOT EXIST BIT
 FNNNX==0
 FNBNX==FNBSTS
 FNPNX==400000

 FNSLOK==1	;LOCKED, USED SO FNB NOT TAKEN TO MAKE ATB
 FNNLOK==1
 FNPLOK==200000
 FNBLOK==FNBSTS

 FNSUFP==^D26	;PAGE OF UFD IN WHICH FILE NAME EXISTS (0 IF CRE)
 FNNUFP==^D35
 FNBUFP==FNBSTS

FNBDBL==6	;RH POINTER TO DDB CHAIN OF READERS (FOR INSERT DELETE BLOCK)

FNBUPD==7		;COUNT OF UPDATERS FOR THIS FILE.
FNBALT==10		;PCB DIRTY MONITOR CLOCK FOR FILE. KEEP HERE
			; INSTEAD OF ATB SINCE ONLY ONE PER UFD ENTRY, NOT
			; ONE PER VERSION OF FILE.

IFN <FNBNAM-CMBNAM>,<PRINTX ERROR IN FNBNAM DEF
	QQQQQ>
IFN <FNBLNK-CMBLNK>,<PRINTX ERROR IN FNBLNK DEF
	QQQQQ>
IFN <FNBATB-CMBDWN>,<PRINTX ERROR IN FNBATB DEF
	QQQQQ>
FNYUFP:	POINT FNSUFP,FNBUFP(P3),FNNUFP


COMMENT ; DRB - THE DIRECTORY BLOCK. ONE PER USER NAME WITH FILES
OPEN ;

INTERN DRBNAM,DRBLNK,DRBCNT,DRBSTS,DRBRIB,DRBMXA,DRBLOK
INTERN DRBLOG,DRBFNB,DRPLOK,DRBUNM,DRBUN1,DRBALC,DRPLOG

INTERNAL DRYPRV,DRYCNT,DRPNX,DRPMXC,DRMCNT,DRBNX
DRBNAM==0	;NAME OF DIRECTORY (PPN)
DRBLNK==1	;LH NEXT DRB IN SYSTEM

 DRSCNT==^D15	;COUNT OF PEOPLE USING THIS DRB
 DRNCNT==^D35
 DRBCNT==DRBLNK	;RH
 DRPMXC==1B<DRNCNT-DRSCNT>
 DRMCNT==GENMSK(DRSCNT,DRNCNT)

DRBSTS==DRBLNK	;STATUS BITS IN HIGH 3 BITS OF COUUNT

 DRSNX==1	;NX BIT
 DRNNX==^D20
 DRPNX==100000
 DRBNX==DRBSTS

 DRSLOK==1	;INTERLOCK BIT
 DRNLOK==^D19
 DRPLOK==200000
 DRBLOK==DRBSTS

 DRSLOG==1	;USER LOGGED IN BIT, KEEP DRB AROUND
 DRNLOG==^D18
 DRPLOG==400000
 DRBLOG==DRBSTS

DRBFNB==2	;LH FIRST FNB FOR THIS USER
DRBPRV==DRBFNB	;STATUS WORD

 DRSPRV==^D9	;PROTECTION CODE
 DRNPRV==^D35

 DRBSLT==DRBFNB	;SLOT NUMBER OF UFD BLOCK WITH KNOWN HOLE
 DRSSLT==^D9
 DRNSLT==^D26
DRBALC==3	;ALLOCATION LEFT IN THIS DIR (FROM QUOTA IN)
DRBMXA==4	;MAX ALLOCATION HAS EVER BIN (FOR ACCOUNTING)
DRBRIB==5	;RETRIEVAL POINTER TO RIB
DRBUNM==6	;USER NAME (IF KNOWN 0 IF NOT)
DRBUN1==7	;SECOND HALF OF USER NAME (IF KNOWN)

IFN <DRBNAM-CMBNAM>,<PRINTX ERROR IN DRBNAM DEF
	QQQQQ>
IFN <DRBLNK-CMBLNK>,<PRINTX ERROR IN DRBLNK DEF
	QQQQQ>
IFN <DRBFNB-CMBDWN>,<PRINTX ERROR IN DRBFNB DEF
	QQQQQ>

DRYPRV:	POINT DRSPRV,DRBPRV(P4),DRNPRV
DRYCNT:	POINT DRSCNT,DRBCNT(P4),DRNCNT


COMMENT ; SPT (SHARED PAGE TABLE) DEFINITIONS

THE SHARED PAGE TABLE CONSISTS OF ONE OR MORE SPT SECTIONS,
THE FIRST OF WHICH IS POINTED TO BY AN ATB THROUGH
ATBSPT.  EACH SECTION CONSISTS OF A HEADER, CONTAINING
FORWARD AND BACKWARD LINKS TO OTHER SPT SECTIONS, AND
A BACK LINK TO THE ORIGINATING ATB. ALSO CONTAINED
IN THE HEADER IS A COUNT OF FREE ENTRY SLOTS IN THE SPT
SECTION, FOR FAST INSERTION OF NEW ENTRIES IN THE
SPT.

THE SPT ENTRIES THEMSELVES ARE FOUND AFTER THE HEADER. EACH
ENTRY CONSISTS OF TWO WORDS. ENTRY WORDS OF THE SAME TYPE
APPEAR CONSECUTIVELY, RATHER THAN HAVING EACH TWO WORD ENTRY
CONTIGUOUS IN MEMORY, TO MAKE LOOPS SHORTER. DATA IN THE
ENTRIES CAN BE ACCESS EITHER DIRECTLY OR THROUGH THE BYTE
POINTERS PROVIDED.

SPTS DO NOT COME FROM FILSER CORE. THEY COME FROM DDB FREE CORE.
;

XP SPTBEG,0		;FIRST WORD

 XP SPTBLN,SPTBEG	;LH = BACK LINK TO LAST SPT. SET TO
			; ATB+ATBSPT-SPTLNK FOR FIRST
			; SPT SECTION SO THAT SPTLNK(AC) CAN STORE
			; INTO FORWARD POINTER OF ATB. NOTE THAT
			; SPTLNK AND ATBSPT MUST BE IN SAME HALF
			; OF A WORD.

 XP SPTNFE,SPTBEG	;RH = NUMBER OF FREE ENTRIES
  XP SPSNFE,^D4		;FIELD IS 4 BITS WIDE (15 ENTRIES)
  XP SPNNFE,^D35	;RIGHT JUSTIFIR AOS AND SOSING.
  XP SPPNFE,1B<SPNNFE>	;RIGHTMOST BIT
  XP SPMNFE,<GENMSK(SPSNFE,SPNNFE)> ;MASK

  SPYNFE::POINT SPSNFE,SPTNFE(T4),SPNNFE	;BYTE POINTER TO FIELD

 XP SPTNME,1_SPSNFE-1	;NUMBER OF ENTRIES IS THIS.
 XP SPTNMM,<<SPTNME>B<SPNNFE>>	;# entries justified.

XP SPTLNK,SPTBEG+1	;NEXT WORD OF HEADER IS LINK IN LH,
 XP SPTATB,SPTBEG+1	;AND ATB BACK POINTER IN RH, JUST LIKE IN
			; OTHER FILSER CORE BLOCKS.

XP SPTEN1,SPTBEG+2	;FIRST ENTRY WORD

;SPT ENTRY DEFINITIONS, RELATIVE TO SPT ENTRY ADDRESS.
; FIRST SPT ENTRY ADDRESS IS SPT SECTION BASE ADDRESS
; PLUS SPTEN1.

XP SPTUSC,0*SPTNME	;USE COUNT. RIGHT JUSTIFIED SO CAN AOS AND SOS
 XP SPSUSC,^D18		;18 BITS WIDE
 XP SPNUSC,^D35		;RIGHT JUSTIFIED IN WORD
 XP SPPUSC,1B<SPNUSC>	;RIGHTMOST BIT
 XP SPMUSC,<GENMSK(SPSUSC,SPNUSC)> ;MASK

XP SPTVIR,0*SPTNME	;WORD WITH VIRGIN BIT IN IT
 XP SPPVIR,400000	;ITS THE SIGN BIT. CAN DO SKIPL SPTVIR(T1)

XP SPTPNO,1*SPTNME	;THE NEXT SPTNME WORDS ARE THE DISK PAGE NUMBER
			; ALL BY ITSELF FOR QUICK COMPARES IN SRCSPT.

XP SPHSIZ,SPTEN1-SPTBEG	;SIZE OF SPT SECTION HEADER
XP SPTSIZ,<2*SPTNME>+SPHSIZ ;NUMBER OF WORDS IN AN SPT SECTION


;MORE OF SPT DEFINITIONS

;SPT POINTER FORMAT. AN SPT POINTER IS JUST THE SPT SECTION ADDRESS
; CONCATENATED WITH A RIGHT JUSTIFIED SPT ENTRY OFFSET.

XP SPSOFS,SPSNFE	;SIZE OF OFFSET FIELD SAME AS SIZE OF
			; FREE ENTRY FIELD. ONE VALUE IS UNUSED.
XP SPNOFS,^D35		;OFFSET IS RIGHT JUSTIFIED.
XP SPMOFS,<GENMSK(SPSOFS,SPNOFS)> ;THE MASK

SP4OFS::POINT SPSOFS,T4,SPNOFS	;POINTER TO POINTER IN T4

XP SPSBAS,^D18	;ITS AN 18 BIT ADDRESS
XP SPNBAS,^D35-SPSOFS	;STARTS WHERE OFFSET ENDED
XP SPMBAS,<GENMSK(SPSBAS,SPNBAS)> ;A MASK FOR THE BASE

SP4BAS::POINT SPSBAS,T4,SPNBAS	;BYTE POINTER TO SPT POINTER IN T4


;DEV:	DEVICE DATA BLOCK (ONE FOR EACH ACTIVE SOFTWARE USER CHANNEL)

EXTERN	DSKDSP
INTERN DEVNAM,DEVCHR,DEVIOS,DEVSER,DEVMOD,DEVLOG,DEVBUF,DEVIAD,DEPMGN,DEVBTS
INTERN DEVOAD,DEVRET,DEVPOS,DEVRIB,DEYRPS,NORED,NOWRT,PIDACC
INTERN DEVFLO,DEVSZS,DEVATB,DEVDRB,PTRCHG,DEYSTC,DEV1UN,DEVFUF
INTERN PTRLEN,DEVRB1,DEVRBN,DEVSUP,DEPFLK,DEVLOK
INTERN DDBCOR,DSKDDB,DDBLEN,DEVELB,DEVDBL
INTERN DEVBLK

DSKDDB:			;ADDRESS OF PROTOTYPE DISK DDB FOR SYSTEM.
			; LINKED TO DDB LIST BUT NEVER USED.

PHASE	0

DEVNAM:!SIXBIT	/DSK/	;DEVICE NAME IN SIXBIT OF STR OR MORE USUALLY GENERIC DSK
DEVCHR:!XWD 0*HUNGST,201 ;HUNG TIME COUNT, BUFFER SIZE
DEVIOS:!0		;LH=MONITOR, RH=USER IO STATUS
DEVSER:!EXP DSKDSP	;LH=LINK TO NEXT DDB, RH=DISPATCH TABLE ADDRESS
			; IN FILSER SAME FOR ALL DISKS
DEVMOD:!XWD DVIN+DVOUT+DVDSK+DVDIR,154407 ;LH=CHARACTERISTICS, RH=MODES
DEVLOG:!0		;LOGICAL NAME IN SIXBIT
DEVBUF:!0		;LH=OUTPUT BUFFER HEADER, RH=INPUT BUFFER HEADER
DEVIAD:!0		;BIT 13=0, RH=POINTER TO USER INPUT BUFFER
  NORED==400000		;
  NOWRT==200000		;
  PTRCHG==100000	;ON IF RETRIEVAL PNTRS IN DDB HAVE BEEN
			;MODIFIED (AND CONSEQUENTLY HAVE TO BE
			;WRITTEN OUT TO THE RIB.).
  PIDACC==40000		;SET IF DDB IS SUBJECT TO PID ACCESS RULES.
			; (IF LAST UUO HAS UUPPID ON ON EXTENDED BLOCK)

DEVOAD:!0
			;BIT 13=0,BITS 14-17=R, RH=POINTER TO USER OUTPUT BUFFER
DEVCLS:!BYTE (2) 2 (8)0 (4) 0!;CLASS 2, 0 BLKS FOR IO LIST
DEVSTS:!0		;WORD FOR DEVICE CONI
DEVBLK:!0		;THIS REMAINS HERE FOR USE BY
			;DIRECTORY-MANIPULATION ROUTINES
			;(INSNAM,INSFAK,INSEOF), AND
			;GETBLK ROUTINE FILRIB, WHEN THERE
			;ARE SPARE RIB PNTRS.
DEVABC==DEVBLK		;(NO LONGER USED FOR DSK, VM SYSTEM)
DEVBWC:!0		;(NO LONGER USED FOR DSK, VM SYSTEM).
DEVFIL:!0		;OLD FILE NAME (LAST LOOKUP OR ENTER) - ARG TO FNDFIL
DEVEXT:!XWD 0,0		;LH=OLD FILE EXTENSION (LAST LOOKUP OR ENTER) -ARG TO FNDFIL
DEVSUP==DEVEXT		;RH=LOC FOR USE BY SUPER IO. WHEN IOSUPR
			;IS ON, THIS LOC=0 IF STR IS INITED,
			;ELSE IT IS DDB OF UNIT THAT IS INITED.
DEVPPN:!0		;OLD DIRECTORY NAME (PROJ,R) -NOT ARG TO FNDFIL
DEVPOS:!0		;BLK POSITION IN FILE, TO BE
DEVREL==DEVPOS ;TEMP DEBUGGING AID.
INTERN DEVREL ;TEMP DEBUGGING AID.
			;READ/WRITTEN NEXT INPUT/OUTPUT UUO.
			;SIGN BIT SET IF USETI/O SET IT AND
			;SIMIO HAS NOT YET ADJUSTED UPTPOS
DEVRET:!XWD ZERO18,0	;RH=CORE  ADR IN DDB OF CURRENT RETRIEVAL POINTER


DEVLOK:!0		;BOTH HALVES USED BY THE RIB STRUCTURE
			;LOCKING ROUTINES.
DEV1UN:!0		;UNIT DB ADDRESS IF THIS IS SPECIAL
			;UNIT IN STR STUFF (ELSE ZERO).
DEVFLO:!0		;DEVREL ASSOCIATED WITH THE FIRST
			;RETRIEVAL POINTER IN THE DDB, OR
			;-1 IF NO RET PNTRS IN THE DDB.
			;(IF 1ST RET PNTR IS A SPARE RIB PNTR,
			;FLO=DEVREL OF THE 1ST REAL RET PNTR
			;AT THE BOTTOM OF ITS CHAIN.).
DEVFUF:!0		;DEVFLO TYPE LOCATION FOR USE BY THE
			;ROUTINES IN FILFNX, ETC. THAT READ THE UFD, ETC.
DEVSZS:!0		;RIBSZS OF THE RIB FROM WHICH THE DDB
			;RET PNTRS CAME.  (OR IF = 0, FLAG
			;THAT JUST THE PRIME RIB RET
			;PNTR IS IN THE DDB.).
DEVRIB:!0		;DISK POINTER TO THE RIB FROM WHICH
			;THE DDB RET PNTRS CAME.
DEVELB:!0		;TO STORE BLOCK (REALLY PAGE) NUMBER OF ERR
DEVRPS:!0		;BITS 0 TO 8 ARE THE REL ADDR IN
			;RIB OF LAST OF THE DDB RETRIEVAL PNTRS.
  DESRPS==^D9
  DENRPS==^D8
DEVSTC==DEVRPS		;CODE IN CASE SWPCLN NEEDED
  DESSTC==3
  DENSTC==^D11
DEVBTS==DEVRPS		;PLACE FOR SOME STATUS BITS.
  DEPMGN==000040	;BIT 12.
  DEPFLK==000020	;BIT 13. FILE IS LOCKED FOR MODIFYING.
			;BITS 14 TO 17 ARE UNDEFINED
DEVDBL==DEVRPS		;RH IS LINK FOR DDBS ON FNB

DEVRB1:!0		;FIRST RETRIEVAL POINTER GOES HERE IN DDB
			;FOR NORMAL IO.  FOR SUPER USETI/O RH
			;HAS UNIT DB ADDR.
	BLOCK PTRLEN-2	;IN-CORE RET. PTRS HERE 3,4,...RBN-1
DEVRBN:!0		;LAST RETRIEVAL PTR IN CORE

DEVATB:!0		;RH=ADDRESS OF ATB.
DEVDRB==DEVATB		;LH=ADDRESS OF DRB.

CORSIZ==4		;NO OF WORDS IN MONITOR FREE CORE BLOCKS
DDBCOR==<.-DEVNAM+CORSIZ-1>/CORSIZ ;NO OF MONITOR FREE CORE BLOCKS FOR DDB
DDBLEN==.-DEVNAM	;LENGTH OF DSK DDB IN WORDS

DEPHASE

DEYRPS: POINT DESRPS,DEVRPS(F),DENRPS ;REL POSITION OF LAST DDB
			;PNTR IN ITS RIB.
DEYSTC:	POINT DESSTC,DEVSTC(F),DENSTC	;STATUS CODE FOR SWPCLN

;EACH FILE STRUCTURE HAS ONE HOME FILE: HOME.SYS.  (PREFIX "HOM")

;DATA LOCATIONS IN HOME BLOCK:  (WRITTEN BY PAKCOP PROGRAM)
HOMNAM==:0	;"HOM" IN SIXBIT (WRITTEN BY PAKCOP PROGRAM)
HOMHID==:1	;SIXBIT UNIT ID (WRITTEN BY PAKCOP PROGRAM)

;WRITTEN BY OPTIONAL ONCE ONLY DIALOG:
HOMSNM==:2	;SIXBIT FILE STRUCTURE NAME THIS UNIT BELONGS TO
		; 0 INDICATES NOT IN A FILE STRUCTURE
		; [IGNORED BY MONITOR WHEN A PACK IS MOUNTED
		; FILE STRLST.SYS IS FINAL AUTHORITY FOR THE STR NAME]
HOMNXT==:3	;SIXBIT UNIT ID OF NEXT UNIT IN THIS FILE STRUCTURE.
		; 0 IF THIS UNIT IS LAST OR ONLY UNIT IN FILE STRUCTURE.
		; [CHECKED BY MONITOR AND OMOUNT CUSP WHENEVER PACK IS MOUNTED]
HOMPRV==:4	;SIXBIT UNIT ID OF PREVIOUS UNIT IN THIS FILE STRUCTURE.
		; 0 IF THIS UNIT IS ONLY UNIT IN FILE STRUCTURE.
		; [CHECKED BY MONITOR & OMOUNT CUSP WHENEVER PACK IS MOUNTED]
HOMLOG==:5	;SIXBIT LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT
		; (E.G. DSKA0,DSKC12)
HOMLUN==:6	;LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT
		; [CHECKED BY MONITOR AND OMOUNT CUSP WHENEVER PACK MOUNTED]
HOMSPS==:7	;System pack-set serial number.  e.g. C24 set 3
		; LH= System pack-set Id number.  (as above, = ^D 3)
		; RH= System number.              (as above, = ^D24)
HOMREF==:10	;NON-ZERO IF FILE STRUCTURE MUST BE REFRESHED
		; BECAUSE SOME PARAMETER FOR THIS UNIT HAS BEEN CHANGED
		; SET BY DISK ONCE ONLY CODE,CHECKED WHEN SYSTEM IS STARTED
		; AND BY OMOUNT WHEN PACK MOUNTED
;HOMSID==:11	;(obsolete) Swap ID - sixbit /UNITID/ of next unit in swap list
;HOMSUN==:12	;(obsolete) Logical unit number in swap list, -1 if not in list
;HOMSLB==:13	;(obsolete) First logical block for swapping
;HOMCFS==:14	;(obsolete) Class for swapping, 0, 1, 2, etc
HOMFEP==:14	;# FE FILE PAGES PER UNIT,,FIRST FE FILE PAGE ON THIS UNIT
HOMSPU==:15	;# SAT PAGES PER UNIT.
HOMOVR==:16	;-# OF PAGES OF OVERDRAW ALLOWED A USER ON THIS STR
  ;WORDS WRITTEN BY REFRESHER:
HOMTAB==:17	;FIRST LOC OF TABLE OF LOG. PAGE NOS OF SYSTEM FILES
HOMSAT==:17	;LOGICAL PAGE NO. WITHIN STR(NOT UNIT) OF 1ST RIB FOR SAT.SYS
HOMHMS==:20	; " FOR HOME.SYS
HOMSPG==:21	; " FOR SPAGES.SYS
HOMCRS==:22	; " FOR CRASH.SAV
HOMSUF==:23	; " SYS UFD
HOMPUF==:24	; " PRINTR UFD
HOMMFD==:25	; " FOR MFD [1,1].UFD
HOMP4C==:26	;PAGES FOR CRASH.SAV FILE..
HOMHSH==:27	;LH IS HASH CONSTANT.
HOMRAN==:27	;RH IS PACK SET IDENTIFIER.
HOMEND==:27	;LAST WORD NOT TO ZERO BY ONCDSK.
HOMDCV==:(SIXBIT/DCV/)	;DSKCLN TYPE VALIDATOR
HOMDCT==:30	;DSKCLN TYPE
HOMSER==:174	;SERIAL NUMBER INCREMENTED ON SYSTEM UP
HOMDAT==:774	;CONTAINS DATE OF LAST PACK COPY
HOMCOD==:PAGCOD	;CONTAINS UNLIKELY CODE, LH=0
CODHOM==:070717  ;THE UNLIKELY CODE FOR THE HOME BLOCK
HOMSLF==:PAGSLF	;LH=0, RH=THIS PAGE ADDR WITHIN UNIT (SELF).
;WORD POSITIONS FOR RETRIEVAL INFORMATION BLOCK
;PREFIX "RIB"
;THE FIRST "RIBDDB" LOCATIONS OF THE RIB ARE KEPT IN CORE IN THE
; DDB WHILE THE FILE IS ACTIVE, THEY ARE FLAGGED (DDB).
;SOME OF THE SAME INFORMATION ALSO APPEARS IN THE ACCESS TABLE ENTRY
; THEY ARE FLAGGED (ACT).
;THE ORDER OF THESE ARGUMENTS CORRESPONDS EXACTLY TO THE EXTENDED LOOKUP,
; ENTER, RENAME BLOCKS.  WORDS APPEARING IN EXTENDED LOOKUP, ENTER, RENAME
; ARE FLAGGED WITH (ENT). SEE LEVEL D PROJECT SPECIFICATION FOR MORE
; INFORMATION ON LOOKUP/ENTRY/RENAME ARGUMENTS AND VALUES.
;A FEW EXTRA WORDS WHICH HAVE MEANING FOR UFD'S ONLY HAVE BEEN ADDED
; TO ALL FILES.  THEY HAVE NO MEANING FOR DATA FILES.  THESE WORDS ARE
; FLAGGED (UFD-ONLY).
;ALL QUANTITIES ARE IN BLOCKS EXCEPT THE FILE SIZE (RIBSIZ), WHERE
;USER MAY WANT TO KNOW NO. OF DATA WORDS IN LAST BLOCK

	INTERN RIBPPN,RIBNAM,RIBEXT,RIBPRV,RIYPRV,RIBUNM,RIBUN1
	INTERN PRTEXC,PRTRED,PRTAPP,PRTUPD,PRTWRT,PRTREN,PRTCPR,RIRXLK,RIRXCR,RIRXRD
	INTERN RIBSIZ,RIBVER,RIBSFS,RIBPFS,RIBLST,RIBALP,RIBMXA
	INTERN RIBMTA,RIBQTF,RIBQTO,RIBUSD,RIPDIR,RIPPID,RIPALC
	INTERN RIBSTS,RIPLOG,RIPHRE,RIPHWE,RIPBDA,RIPBFS,RIPBDR
	INTERN RIBRIB,RIBSZS,RIBSNM,RIBRPS,RIBLCW,RIBMSC,RIBPVW
	INTERN RIBCOD,CODRIB,RIBSLF,RIBELB,RIBFUT,RIBFT1,RIPUFE
	INTERN RIPNDL,RIPNFS,RIBAUT,RIBDEV,RIBPOS,RIBEST,RIBALC
	INTERN RBSPAR,RBREAL,RBINDX,RBDLTA,RBLVSP,RBLVPR
	INTERN PTSUNI,PTNUNI,PTSPNO,PTNPNO,RIBTRU,RIBXT1,RIBXT2
	INTERN RBYUNI,RBYPNO,RBMASK,RBYUN1,RBYUN4,RBYPN1,RB1PNO
	INTERN RBYUNA,RBYUNR,RBYUNV
	INTERN RIBPJC,RIBPJ1,RIBPJ2,RIBPID,RIBALT	;-

RIBRIB==0	;POINTER TO THE NEXT UPPER RIB, 0 IN PRIME RIB
RIBRPS==1	;LOCATION (WORD) OF POINTER TO THIS RIB IN NEXT UPPER RIB
RIBSZS==2	;NUMBER OF BLOCKS REPRESENTED BY EACH SUBRIB POINTER
		;IN THIS RIB
RIBSNM==3	;NUMBER OF SUBRIBS THIS RIB HAS (FIRST LEVEL ONLY)

RIBSFS==4	;FIRST RIB POINTER LOCATION IN A SUBRIB

RIBPPN==4	;(ACT)(DDB) (ENT) PROJECT,PROGRAMMER # IN OCTAL OR PROJECT
		; NAME (3 CHAR SIXBIT LEFT JUSTIFIED IN LH) OR PROGRAMMER
		; INITIALS (3 CHAR SIXBIT LEFT JUSTIFIED IN RH) (AS LOOKUP ENTER
		; RENAME ARG APPEARS AT RIBSIZ POSITION) OF UFD IN WHICH
		; THIS FILE APPEARS.  NEVER CONVERTED TO DECIMAL BY MAN OR MACHINE.
RIBNAM==RIBPPN+1;(ACT)(DDB) (ENT) 6 CHAR FILE NAME IN SIXBIT (OR OCTAL PROJECT
		; PROGRAMMER NO. OR SIXBIT IF THIS FILE IS MDF OR UFD).
RIBEXT==RIBNAM+1;(ACT)(DDB) (ENT) LH 3 CHAR FILE EXTENSION IN SIXBIT; BITS 24-35
RIBMSC==RIBEXT	; ACCESS DATE. BYTE=RIBACD.
RIBPVW==7	;(ACT)(DDB) (ENT)FILE ATTRIBUTES 0-8 ACCESS CODE, 9-12 MODE, 13-23
		; CREATION TIME IN MINUTES SINCE MIDNIGHT, 24-35 CREATION DATE
RIBPRV==RIBPVW	;ANOTHER SYMBOL FOR SAME LOCATION
  RISPRV==^D9
  RINPRV==^D8



RIYPRV:	POINT RISPRV,RIBPRV+%RIB,RINPRV  ;BYTE POINTER TO ACCESS PRIVILEGES
		;ACCESS PRIVILEGES DEFINED IN INCREASING ORDER OF POWER FOR
		; DATA FILES (IE NON-DIRECTORY)
		; BITS 0-2 FOR ANY JOB WITH MATCHING PROGRAMMER NO.
		; (NO MATTER WHAT THE PROJECT)
		; BITS 3-5 FOR ANY JOB WITH MATCHING PROJECT NO.
		; (NO MATTER WHAT THE R NO.
		; BITS 6-8 NEITHER PROJ NOR R MATCH
  PRTEXC==1	;EXECUTE ONLY-IE GET, R,RUN ACCESS
  PRTRED==2	;READ ONLY
  PRTAPP==3	;APPEND (ALLOCATE, DEALLOCATE, APPEND)
  PRTUPD==4	;UPDATE
  PRTWRT==5	;WRITE (SUPERSEDE,TRUNCATE)
  PRTREN==6	;RENAME (CHANGE ATTRIBUTES, NAME, EXT, DIR)
  PRTCPR==7	;CHANGE PRIVILEGE
		;ACCESS PROVILEGES FOR DIRECTIORY FILES (RIPDIR SET IN RIBSTS)
		; 3 INDEPENDANT ACCESS PRIVILEGES
		; BITS 0-2 FOR ANY JOB WITH MATCHING PROG. NO, 3-5 MATCHING PROJ
		; 6-8 NEITHER MATCHING
  RIRXLK==4	;1 ALLOWS LOOKUPS IN DIRECTORY
  RIRXCR==2	;1 ALLOWS CREATES IN DIRECTORY
		; (IE ADD NAMES WHICH ARE NOT ALREADY THERE)
  RIRXRD==1	;1 ALLOWS DIRECTORY TO BE READ AS A DATA FILE
RIBSIZ==10	;(ACT)(DDB) (ENT) RIGHT ADJUSTED WRITTEN LENGTH
		;OF FILE IN WORDS (POSITIVE QUANTITY).
		; MAYBE LESS THAN NO. OF WORDS ALLOCATED
RIBVER==RIBSIZ+1;(ENT) VERSION NUMBER (LIKE JOBVER)
		; LH=PROGRAMMER NUMBER LAST MAKING CHANGE
		; RH=OCTAL VERSION NUMBER NEVER CONVERTED TO DECIMAL
		; BY MAN OR MACHINE.
RIBFUT==12	;RESERVED
RIBEST==13	;WAS ESTIMMATED SIZE. TREATED SPECIALLY TO
		;MAKE OLD PROGRAMS THAT LOOKED AT IT WORK
RIBALC==14	;SIMMILARY WAS AMMOUNT ALLOCATED
RIBPOS==15	;USED TO BE POSITION ALLOCATED. NOW AVAIL
RIBFT1==16	;ALSO RESERVED
RIBLCW==17	;LICENSE WORD   (this word exactly matches ATBLCW)
  RIPDMP==ATPDMP	;(LH)SET BY MONITOR IF FILE CHANGED, CLEARED
			; BY TAPE BACKUP PROGRAM.
  RIPUFE==ATPUFE	;(LH)THIS FILE HAS AN ERROR OF SOME SORT(RIPHWE,
			;RIPHRE,RIPBDR,RIPBFS,RIBBDA.).
			;NOTE THAT RIPUFE MUST=ATPUFE.
  RIPPID==ATPPID	;(LH)IF UFD, SET BY SYS ADMINISTRATOR TO FLAG
			; THAT THIS UFD NEEDS SPECIAL PID STORAGE ACCOUTNING.
			; IF FILE, SET/CLEARED BY MONITOR WHEN PID IS
			; SET/CLEARED.
  RIPALC==ATPALC	;(LH)FOR FILES, NOT UFDS, SAYS THAT
			; THIS FILE HAS HAD AN ALLOCATION CHANGE
			; AND THE MONITOR DOESN'T KNOW IF ALL RIBS
			; AND SATS AND UFDS HAVE BEEN WRITTEN OUT YET.
RIBMTA==20	;(ENT) 36 BIT TAPE LABEL IF FILE HAS BEEN PUT ON MAGTAPE
RIBDEV==21	;VALUE ONLY-FILE STRUCTURE NAME FILE STARTS ON

RIBSTS==22	;STATUS BITS FOR ALL FILES IN UFD(LH),
		; THIS FILE IN RH

  RIPLOG==400000;(LH) IF 1 SAYS USER IS LOGGED IN. SET BY LOGIN CUSP
		; RENAME UUO.  SET TO 0 BY LOGOUT CUSP RENAME UUO.
		; BIT CHECKED BY LOGIN IN ORDER TO DETERMINE IF
		; RIBTOT IS TO BE BELIEVED (IF RIBLOG==1) SYSTEM
		; MUST HAVE CRASHED OR BEEN RELOADED WITHOUT LOGGING
		; OUT ALL USERS.

  RIPBDA==1	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY DAMAGE
		; ASSESSMENT CUSP
  RIPBFS==10	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY FAILSAFE
		; WHEN READING MAGNETIC TAPE TO RESTORE TO DISK.
  RIPHRE==100	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
		; READ DATA ERROR DETECTED BY MONITOR.(IODTER)

  RIPHWE==200	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
		; WRITE DATA ERROR DETECTED BY MONITOR.(IODTER)

  RIPBDR==2000	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY OPERATING SYSTEM.


INTERN RIPSPP

  RIPDIR==400000;(RH) 1 IF THIS FILE IS A DIRECTORY FILE (UFD OR MFD)
		; RATHER THAN A DATA FILE. NEEDED TO PROTECT
		; THE SYSTEM FROM THE USER WHO MIGHT TRY
		; TO MODIFY A DIRECTORY AS A DATA FILE
  RIPNDL==200000	;(RH)[NO DELETE] 1 IF THIS FILE CANNOT BY
		; DELETED EVEN BY A PRIVILEGED PROGRAM.  THESE FILES ARE IN
		; SOME SENSE FAKE OR CRUCIAL TO FILE STRUCTURE.
		; EG. HOME.SYS, SAT.SYS, MAINT.SYS, BADBLK.SYS
		; NAME CHANGED FOR SAVE REASONS AS NO DELETES ABOVE.
  RIPNFS==40000	;(RH)[NO FAILSAFE] 1 IF THIS FILE SHOULD NOT
		; BE DUMPED BY FAILSAFE BECAUSE IT IS A FUNNY FILE AND
		; SHOULD NOT BE RESTORED OR IS PART OF THE SKELETON
		; FILE STRUCTURE.  (BADBLK.SYS,SAT.SYS,HOME.SYS,MAINT.SYS
		; RECOV.SYS).  (SNAP.SYS, CRASH.SAV, UFD'S AND MFD
		; DO NOT HAVE RIPNFS ON, SO THEY ARE ALL SAVED).
RIPSPP==1000	;FILE HAD DEVPPN=JBTPPN AT CREATION TIME


RIBELB==23	;ERROR BLOCK IN FILE
RIBXT1==24	;EXTRA ARGUMENT
RIBQTF==25	;(UFD ONLY) FIRST COME FIRST SERVE LOGGED IN QUOTA IN TOTAL
		; NUMBER OF DATA + RIB BLOCKS (I.E. ALL OVERHEAD BLOCKS TOO
		; EXCEPT NOT UFD + ITS RIB - THAT IS CHARGED TO 1,1) ALLOWED THIS
		; USER IN THIS DIRECTORY IN THIS FILE STRUCTURE WHILE
		; LOGGED-IN.  SET BY LOGINN. SEE THE DRB


RIBQTO==26	;(UFD-ONLY) LOGGED-OUT QUOTA IN TOTAL NUMBER OF DATA + RIB
		; BLOCKS ALLOWED THIS USER IN THIS DIRECTORY IN THIS STR
		; WHILE LOGGED-OUT.(I.E. ALL OVERHEAD BLOCKS TOO EXCEPT UFD
		; + ITS RIB -  THAT'S CHARGED TO 1,1).  SET BY LOGIN FROM ACCT.SYS
		; FILE (SO LOGOUT WILL NOT HAVE TO SEARCH ACCT.SYS).
		; LOGOUT WILL FORCE USER TO DELETE ENOUGH FILES SO AS TO BE
		; BELOW THIS LIMIT.  THIS QUANTITY IS NOT KEPT IN CORE

RIBMXA==27	;MAX USD HAS EVER BEEN. MAY BE USED FOR
		;ACOUNTING

RIBUSD==30	;(UFD-ONLY) COUNT OF BLOCKS USED (INCLUDING ALL OVERHEAD BLOCKS)
		; WHEN JOB WAS LOGGED OUT
		; (PROVIDED LOGBIT=0). WRITTEN BY LOGOUT, READ BY LOGIN.
RIBAUT==31	;PROJ-R # OF AUTHOR OF FILE, IE USER DOING
		; CREATE OR SUPERSEDE. (USUALLY THE SAME AS OWNER, IE
		; UFD IN WHICH FILE EXISTS, EXCEPT WHEN A FILE
		; IS CREATED OR SUPERSEDED IN SOMEONE ELSES UFD)
RIBUNM==32	;FOR UFDS ONLY, THIS AND RIBUN1 ARE THE
		;SIXBIT USER NAME.  FOR OTHERS, THESE WORDS
		;ARE 0.
RIBUN1==33	;SEE RIBUNM.
RIBTRU==34	;PRIVILEGED ARG FOR EACH CUSTOMER TO DEFINE
RIBXT2==35	;ANOTHER EXTRA ARGUMENT
RIBALP==36	;NUMBER OF PAGES ALLOCATED TO THIS FILE(REALLY)
RIBPJC==37	;FILE PROJECT CODE WORD 0
RIBPJ1==40
RIBPJ2==41
RIBPID==42
RIBALT==43
;(SEE RIBPFS, NEXT PAGE)




;THE NEXT LOCATIONS ARE USED FOR RIB POINTERS. THE RIB POINTERS
;HAVE THE FOLLOWING FORMAT
    RBSPAR==400000
;	BIT 0 POINTER TO A SPARE RIB NOT DATA
    RBREAL==200000
;	BIT 1 IS POINTER TO A REAL PAGE (AS OPPOSED TO JUST A PLACE HOLDER.).
    RBINDX==100000
;	BIT 2 SPECIAL BLOCK (INDEX) SKIP UNLESS MODE 200+N
    RBDLTA==40000
;	BIT 3 POINTER HAS BEEN CHANGED
;
    RBMASK==RBSPAR!RBREAL!RBINDX!RBDLTA

	PTSUNI==^D8
	PTNUNI==^D16
	PTSPNO==^D19
	PTNPNO==^D35
RBYUNI::POINT PTSUNI,T2,PTNUNI
RBYUN1::POINT PTSUNI,T1,PTNUNI
RB1UNI::POINT PTSUNI,P1,PTNUNI
RBYUN4::POINT PTSUNI,T4,PTNUNI
RBYUNA::POINT PTSUNI,ATBRIB(P2),PTNUNI
RBYUNR::POINT PTSUNI,DRBRIB(P1),PTNUNI
RBYUNV::POINT PTSUNI,DEVRIB(F),PTNUNI
;	BITS 9-16 UNIT NUMBER
RBYPNO::POINT PTSPNO,T2,PTNPNO
RBYPN1::POINT PTSPNO,T1,PTNPNO
RB1PNO::POINT PTSPNO,P1,PTNPNO
RBYPNV::POINT PTSPNO,DEVRIB(F),PTNPNO
;	BITS 17-35 PAGE NUMBER ON UNIT

RIBPFS==51		;FIRST SPOT WHICH CAN BE USED FOR RIB POINTERS


RIBCOD==PAGCOD	;CONTAINS UNLIKELY DATA WORD (I.E., NOT ASCII OR FLOATING POINT)
		;LH=0
  CODRIB==666666  ; THE UNLIKELY CODE
RIBLST==RIBCOD-1	;LAST LOCATION FOR POINTERS
  RBLVPR==RIBLST-RIBPFS+1  ;NO. OF PRIME RIB PNTRS.
  RBLVSP==RIBLST-RIBSFS+1  ;NO. OF SPARE RIB PNTRS.
ONELVL==:RBLVSP		;772 = 506. (RBLVPR = 725 = 469.)
TWOLVL==:RBLVSP*RBLVSP	;764044 = 256036.

RIBSLF==PAGSLF	;A POINTER TO THIS RIB ITSELF
SUBTTL	Prototype STR Data Block

STRDDB::	;Currently, this is the ONLY STR DDB
	PHASE	0	; ** Note some code expects STRNAM == STRDDB **

STRNAM::!0	; 0 SIXBIT name of file structure, nonzero if str exists
STRHSH::!	; 1 RH=hash constant (currently 7 on all structures)
STRUNI::!0	; 1 LH=addr of 1st unit data block, linked thru UNISTR
STRP4C::!	; 2 RH=pages for CRASH.SAV.
STRNXT::!0	; 2 LH=addr of next STR data block, zero for last STR
STRUNM::!	; 3 RH=# of units in this STR
STRREF::!0	; 3 LH=non-zero if this STR needs refreshing
STROVR::!0	; 4 -# of pages a user is allowed to go over quota (-125)
STRTAL::!0	; 5 # of FCFS free pages left in this STR minus safety factor
		;  (safety factor is STVSFC, a MONGEN symbol)
STRPPU::!0	; 6 # of pages per smallest unit on this STR
STRPID::!	; 7 LH=STR pack set ID  (See HOMRAN/RANNO in ONCDSK)
STRBTS::!0	; 7 RH=some status bits (bits 18 - 29 are unused)
  SRPRPT==:1B35  ;A SAT has been found bad since the last report
  SRPNDS==:7B34  ;DSKCLN needs to be run for this STR if nonzero
  SRPREF==:1B31  ;This structure has been refreshed
STRSID::!0	;STRucture Set IDentifier.  RH=SYSTEM NUMBER
		;LH=Logical pack set designation, eg. A, B, etc.
STRLEN==:.-STRNAM

DEPHASE

IFNDEF NUMSTR,<NUMSTR==:1>		; Default to a single structure
NXTSTR:	BLOCK	<NUMSTR-1>*STRLEN	; Additional structures
;WORD POSITIONS IN USER FILE DIRECTORIES
;PREFIX "UFD"
;THESE HAVE SAME FORMAT AS THE MFD.
;NEITHER THE MFD NOR THE UFD NAME APPEAR IN THE UFD.
;FILE ENTRIES OCCUR IN PAIRS.

INTERNAL UFDHSI,UFDLNK,UFDSIZ,UFDRIB,UFYUF1,UFYUF2,UFPERR,UFDERR
INTERNAL UFDCDT,UFDALP,UFYPRV,UFDNAM,UFDEXT,UFDLIC,UFYXCD
INTERNAL UFYCTM,UFYCDT
UFDNAM==0		;SIXBIT FILE NAME
UFDEXT==1		;LH=SIXBIT EXTENSION
UFDUF2==1
UFDERR==UFDUF2
  UFSUF2==^D8		;UFDEXT bits 19-26 set from .RBLIC bits 4-11
  UFNUF2==^D26		; (UFPDMP,UFPERR,UFPPID,UFDALC require JL or WC)
  ;;;;;;==1B18		;unused bit !!!
  UFPDMP==1B19		;File has been dumped by TITO
  UFPERR==1B20		;File has some sort of error
  UFPPID==1B21		;FOR UFD, MEANS SPECIAL PID STORAGE ACCOUNTING, NOT
			; SET BY MONITOR, SET BY USER.
			;FOR REGULAR FILE, SET/CLEARED BY MONITOR WHEN PID
			; IS SET/CLEARED.
  UFPALC==1B22		;NOT CURRENTLY USED FOR UFD, FOR FILE, MEANS ALLOCATION
			; HAS CHANGED (DSKCLN/FAST LOOKS FOR THIS BIT)
  UFPTMP==1B23		;SET BY USER TO SAY THAT THIS IS A TMP FILE,
			;EVEN THOUGH IT MAY NOT HAVE THE EXT TMP.
  ;;;;;;==1B24		;Used by MAGNUM to indicate JIS-8 Katakana file
  ;;;;;;==1B25		;Unprivileged bit (.RBLIC bit 10)
  ;;;;;;==1B26		;Unprivileged bit (.RBLIC bit 11)
UFDPRV==1		;PROTECTION IN UFD
  UFSPRV==^D9
  UFNPRV==^D35
UFDUF1==2
  UFSUF1==4		;2 privileged and 2 unprivileged bits for .RBLIC
  UFNUF1==4
UFDXCD==2		;EXTENDED DATE BITS
  UFSXCD==2
  UFNXCD==6
UFDCTM==2		;CREATION TIME
  UFSCTM==^D17
  UFNCTM==^D23
UFDCDT==2		;CREATION DATE
  UFSCDT==^D12
  UFNCDT==^D35
UFDALP==3		;SPACE ALLOCATED (# OF PAGES IN LH)
UFDLIC==3		;LICENSE BITS IN RH
UFDRIB==4	;RETRIEVAL PNTR TO PRIME RIB OF FILE.

UFDHSI==7	;THIS IS THE HASH CODE USED TO LOOKUP FILES
UFDLNK==^D511	;THIS IS WHERE THE LINK TO THE NEXT BLOCK IS
UFDSIZ==5	;NUMBER OF WORDS/ENTRY

;BYTE POINTERS

UFYUF2:	POINT UFSUF2,%RIB+UFDUF2(T2),UFNUF2
UFYUF1:	POINT UFSUF1,%RIB+UFDUF1(T2),UFNUF1
UFYPRV:	POINT UFSPRV,%RIB+UFDPRV(T2),UFNPRV
UFYXCD:	POINT UFSXCD,%RIB+UFDXCD(T2),UFNXCD
UFYCTM:	POINT UFSCTM,%RIB+UFDCTM(T2),UFNCTM
UFYCDT:	POINT UFSCDT,%RIB+UFDCDT(T2),UFNCDT

;JBTRCT: JBTWCT: JBTMPC: JBTPWS: JBTPWH: JBTPWL: JBTDAB: moved to COMMOD
;STT - SAT TABLE FOR SATS IN CORE AND DISK FOR A UNIT.
;THERE IS ONE ENTRY FOR EACH SAT ON THE UNIT, EVEN THOUGH NOT
;ALL SATS ARE KEPT IN CORE.
;THERE IS AN EXTRA ZERO WORD TO MARK THE END OF EACH STT.
;
;AN ENTRY CONSISTS OF:

INTERNAL STTFPC,STTPTR,STTAOB,STTSTS,STTLEN,STYINC,STYBAD,STYCHK
INTERNAL STPINC,STPBAD,STPCHK,STPRPT

STTPTR==0	;DISK POINTER TO THIS SAT.
STTFPC==1	;FREE PAGE COUNT.
STTAOB==2	;AOBJN WORD.  (NOT REALLY.  REALLY THE LH/
		;-BIT NO IN WORD AND RH/WORD WRS START OF SAT.).
STTSTS==3	;BITS OF INTEREST.
  STYINC: POINT 1,STTSTS(T2),1	;ON IF SAT IS IN CORE IN A PCB.
  STPINC==200000
  STYBAD: POINT 1,STTSTS(T2),2	;ON IF SAT IS BAD.
  STPBAD==100000
  STYCHK: POINT 1,STTSTS(T2),3	;ON IF SAT HAS BEEN CHECKED.
  STPCHK==40000
  STPRPT==20000	;ON IF THE SAT NEEDS TO BE REPORTED AS BAD.

STTLEN==STTSTS-STTPTR+1


;"SYS" - SYSTEM WIDE QUANTITIES
; NO SPECIAL PREFIX

INTERN	MFDPPN,SYSPP,FSFPPN,SPLPPN,SYSDRB
	INTERNAL ACTPPN,CBUSER,CBADR,CNTBLK
INTERN	SYSDOR,SYSCOR
INTERN	STNPRT,CUSPPP,DUMPPP,HELPPP,SYSPP,QUEPPN
INTERN  SYSUNI,LVDTBL,LVDMXL,UFDPRT,SYSPPN,CORNUM,QUESTR,CRUPPN
INTERN  ETSUNI,ETSGTI,ETSBDT,ETSDCO,ETSDCA,ETSBCN,ETSCCO,ETSCCA
INTERN  ETSTAB,METSLN

LVDTBL:!	;GETTAB TABLE NO. 16(OCTAL)-LEVEL D DISK PARAMTERS

MFDPPN:	XWD 1,1		;(0)PROJECT-PROGRAMMER NUMBER FOR STORING UFDS ONLY
			;  (ALL OTHER FILE STRUCTURE FILES ARE STORED IN DEVICE SYS
			;  (SEE SYSPPN))
CUSPPP:
SYSPP:
SYSPPN:	XWD 1,4		;(1)PROJ-R NO. FOR DEVICE 'SYS' (I.E. CUSPS,LIBRARY)
			;  DIRECTORIES ARE STORED IN MDFPPN
DUMPPP: OPRPPN::
FSFPPN:	XWD 1,21	;(2)PROJ-R NO. FOR FAILSAFE - ALL PRIVILEGED PROGRAM

HELPPP:	XWD 2,5		;(3)SYSTAT AND HELP RUN UNDER THIS NUMBER
			;  (IF NOT ALREADY LOGGED IN)
QUEPPN:
SPLPPN:	XWD 11653,115244;(4)PROJ-R NO. FOR PRINTR SPOOLING PROGRAM

SYSDRB:	XWD 0,0		;(5)LH=FIRST DRB IN FILSER FREECORE
			;  [THIS NEXT COMMENT LOOKS OBSOLETE.../AAA]
			;  RH=CORE ADDRESS OF NEXT PPB BLOCK TO SCAN
			;  NAME LIST TO RECLAIM GRABBABLE NMB BLOCK
			;  IF RH=0 CORE GRABBER SHOULD START OVER AT BEGINNING
			;  OF PPB LIST (I.E., LH OF SYSPPB)

	0		;(6) NOT USED

SYSUNI:	XWD FIRUNI,UNISYS;(7)LH=CORE ADDRESS(DOWNWARD POINTER)OF FIRST UNIT
			;  RH UNUSED
			;  DATA BLOCK IN SYSTEM
			;  RH=UNUSED.

	XWD	0,0	;(10) PLACE HOLDER FOR OBSOLETED ENTRY

			;CORNUM is set nonzero by LINKDB in COMMON
CORNUM:	EXP 0		;(11)# PERMANENT FILSER CORE BLOCKS GENERATED AT ONCE ONLY TIME

STNPRT:	XWD PRVFIL*1000,0;(12)STANDARD PRIVILEGE

UFDPRT:	XWD PRVUFD*1000,0;(13)STANDARD UFD PRIVILEGE
			;  SYMBOL PRVUFD SHOULD NOT BE USED. INSTEAD
			;  UFDPRT SHOULD BE USED, SO CAN PATCH STANDARD.
;RIB and SAT PCBs

IFNDEF RPCBN,<RPCBN==7>
IFLE <RPCBN-4>,<RPCBN==5>
NMRBPC::EXP RPCBN	;(14) NO. OF SYSTEM-TIME PCBS FOR RIBS (CAN
			;  BE CHANGED AT ONCE ONLY TIME.

IFNDEF SPCBN,<SPCBN==17>
IFLE <SPCBN-4>,<SPCBN==5>
NMSTPC::EXP SPCBN	;(15) NO. OF SYSTEM-TIME PCBS FOR SATS (CAN
			;  BE CHANGED AT ONCE ONLY TIME.

QUESTR:	0		;(16) SIXBIT NAME OF FILE STRUCTURE
			;  FOR QUEUEING PROGRAMS LIKE PRINT,UMOUNT, ETC
			;  SETUP BY MANDATORY ONCE ONLY CODE TO BE
			;  THE FIRST(FASTEST) STR WHICH IS UP(TABSTR(0)).

ACTPPN:	XWD 6,270	;(17)ACCOUNTING, JL ON CAN ACCESS THESE

CRUPPN:	XWD	10,1	;(20) UFD FOR DUMPING CRASHES

LKBSIZ:	EXP UUXENT	;(21) SIZE OF LARGEST MEANINGFUL
			;  EXTENDED LOOKUP BLOCK

LVDMXL==<.-LVDTBL-1>B26	;END OF GETTAB TABLE



IFG FTAUN,<EXTERN SYDFTA>	;Routine for SYSDVF function 4
IFE FTAUN,<XP SYDFTA,0>
IFG MAGUN,<EXTERN SYDTMX>	;Routine for SYSDVF function 5
IFE MAGUN,<XP SYDTMX,0>

;SYSTEM VARIABLES NOT IN GETTAB:

SYSDOR:	XWD 0,0		;BEGINNING OF DORMANT ACCESS BLOCK LIST FOR SYSTEM
			;LH=ADDRESS OF FIRST DORMANT ACCESS BLOCK IN SYSTEM
			;LH=0 IF NO DORMANT ACCESS BLOCKS
			;RH=ADDRESS OF LAST DORMANT ACCESS BLOCK IN SYSTEM
SYSCOR:	XWD .,ZERO18	;BEGINNING OF PERMANENT FILSER CORE BLOCK LIST
			;LH=ADDRESS OF FIRST FREE FILSER CORE BLOCK,RH=0 ALWAYS
			; IF NO FREE BLOCKS, WHOLE WORD=0.
			; BLOCKS ARE LINKED TOGETHER BY CORLNK WORD.

CORBAS::0		;CONTAINS BASE ADDRESS OF FILSER CORE BLOCKS
			; FOR ATB POINTER COMPUTATIONS.

MFDSZ==:1+7+7+7+7	;Largest MFD was 25 pages in December 1986
SYSSZ==:1+7+7		;Largest SYS.UFD was 15 pages in December 1986
SPUFDS::-MFDSZ,,MFDRIB	;Watch out for (UFD)=[1,1]
	-SYSSZ,,SYSRIB	;Watch out for (SYS)=[1,4]
	0		;End of SPecial UFDS list

MFDRIB::BLOCK MFDSZ	;RETRIEVAL POINTER TO PRIME RIB OF [1,1].UFD
SYSRIB::BLOCK SYSSZ	;RETRIEVAL POINTER TO PRIME RIB OF [1,4].UFD


;SOFTWARE ERROR TESTING - SET AND CLEAR SELECTED CONI OR DATAI ERROR BIT
; N TIMES AFTER M TIMES
; .FSETS M ARGS ARE IN SAME ORDER AS BELOW:
ETSUNI:	0		;(0) CONTAINS UNIT DATA BLOCK ADDRESS OF
			; A UNIT WHICH IS BEING ERRROR TESTED WITH
			; .FSETS UUO.  IF THIS LOC CONTAINS 0, NO
			; ERROR TESTING (FOLLOWING LOC ARE IGNORED)!
ETSTAB:			;0TH ENTRY FOR ARG PICKUP LOOP
ETSGTI:	0		;(1)NO, OF GOOD TRANSFER INTERRUPTS BEFORE BAD TIMES
ETSBDT:	0		;(2)NO. OF BAD DATAI BEFORE CLEARING ETSUNI
ETSDCO:	0		;(3)ERROR DATAI BITS ORED WITH DATAI BITS
ETSDCA:	0		;(4)ERROR DATAI BITS ANDCMED WITH DATAI BITS
ETSBCN:	0		;(5)NO. OF BAD CONI BEFORE CLEARING ETSUNI
ETSCCO:	0		;(6)ERROR CONI BITS ORED WITH CONI BITS
ETSCCA:	0		;(7)ERROR CONI BITS ANDCMED WITH CONI BITS
ETSLEN==.-ETSTAB	;LENGTH OF .FSETS ARGS
XP METSLN,-ETSLEN

CBUSER:	0		;USER OF CB QUE (FOR ERROR TRACING)
;ALL THE FOLLOWING HAVE F IN LH ADR OF CALL IN RH FOR ERROR TRACE
CBADR:	0
CNTBLK:	0

	GTLNK (CNTBLK)	;.LINK for .GTLNK

			; DEVICE SYS. (4 BIT BYTES ENDED WITH BYTE FSNEND
			; OR OFF THE END OF WORD, IE MAX OF 9 BYTES)
;BAD ALLOCATION FILE.

; A (DUPLICATED) PAGE IN HOME.SYS.
; PROGRAMS SEARCHING HOME.SYS SHOULD LOOK FOR SIXBIT IDENTIFICATION IN
; FIRST WORD OF EACH PAGE.

INTERNAL BATNBB,BAYNBB,BA1NBB,BATREG,BATFIR,BRMAX,BATPAT
INTERNAL CODBAT,BANNBB,BASNBB,BATNAM,BATSLF,BATCOD
INTERNAL BATCNT,BATELB,MAPBIT

;NOTE: The comments here apply to the MAP subroutine in DEC's disk
;      formatting program.  Tymshare's PAKCOP program is different.

BATNAM==PAGNAM	;CONTAINS SIXBIT /BAT/ FOR IDENTIFICATION
BATFIR==1	;LH=-MAX. POSSIBLE NO. OF WORDS FOR BAD REGIONS MAP PROGRAM
		; AND MONITOR CAN ADD BEFORE PAGE FILLS UP
		;RH=REL ADR. WITHIN THIS PAGE OF FIRST BAD REGION PAIR
		; MAP PROGRAM FORCES LH TO BE EVEN NUMBER.
		;ALL PROGRAMS SHOULD SCAN THE BAT PAGE BY STARTING WITH THIS WORD
		; RATHER THAN KNOWING WHERE DATA PAIRS START.  IN THIS WAY
		; ADDITIONAL HEADER WORDS CAN BE ADDED WITHOUT INVALIDATING ANY
		; PROGRAMS WHICH READ BAT PAGE.
		;BOTH HALVES WRITTEN BY MAP PROGRAM AND NEVER CHANGED BY MONITOR
BATPAT==2	;TOTAL NUMBER OF BAD PAGES

BATCNT==3	;NO. OF DISTINCT BAD REGION WORD PAIRS

BATREG==4	;FIRST BAD REGION WORD GOES HERE. THIS SYMBOL NEVER APPEARS IN
		; ANY CODE WHICH READS BAT PAGE - EXCEPT MAP PROGRAM OR OPTIONAL
		; ONCE ONLY CODE WHICH WRITES IT THE FIRST TIME.  INSTEAD SEE
		; RH OF BATFIR
		;NOTE: BATREG MUST BE AN EVEN NUMBER

;THE MAP PROGRAM IS NOT PART OF THE MONITOR - IT RUNS AS A STAND-ALONE PROGRAM
; WHICH WRITES AN INITIAL BAT PAGE WITH ALL THE BAD REGIONS IT FINDS.
;BOTH THE MAP PROGRAM AND THE MONITOR WRITE TWO WORD ENTRIES OF THE SAME FORMAT
;THE MONITOR ADDS TWO-WORD ENTRIES WHENEVER IT FINDS BAD REGIONS
;WHILE READING, WRITING, OR POSITIONING (READ OR WRITE)
;THE MAP PROGRAM AND MONITOR STORE LOGICAL RATHER THAN PHYSICAL ADDRESSES

BATNBB==0	;(1 OF 2 WORDS) NUMBER OF BAD SECTORS-1 IN THIS BAD REGION
  BATNUM==777	;MAX NUMBER OF BAD PAGES IN A REGION-1
  BASNBB==^D9	;BYTE SIZE
  BANNBB==^D8	;BYTE PTR. POS.
MAPBIT==1B9	;SET BY MAP PROGRAM IF DATE IS UNKNOWN TO MAKE NON-ZERO
		;BITS 18-35 ARE DATE OF ENTRY IN TYMCOM-X FORMAT
BAYNBB:	POINT BASNBB,BATNBB(T2),BANNBB		;BYTE PTR
BA1NBB:	POINT BASNBB,%RIB+BATNBB(T1),BANNBB	; Used in (CORE1)

BATELB==1	;(2 OF 2 WORDS) ERROR LOGICAL SECTOR ADR. WITHIN UNIT
		;BLOCK NUMBER IF FORMATTED IN BLOCKS, ELSE PAGE NUMBER

BATCOD==PAGCOD	;CONTAINS UNLIKELY CODE
		;LH=0
CODBAT==505050	;UNLIKELY CODE FOR BAT PAGE
BATSLF==PAGSLF	;LH=0, RH=THIS PAGE(NOT CLUSTER) AADR. WITHIN UNIT

BRMAX==BATCOD-BATREG	;MAX LENGTH OF AREA FOR APPENDING BAD REGIONS
;DEFINE PROTECTION LEVELS AND UFD PROTECTION BITS

;UFD

UFRXLK==4	;"TRANSPARENT" UFD
UFRXCR==2	;CAN CREATE NEW FILE
UFRXRD==1	;CAN READ UFD AS A FILE

INTERNAL UFRXLK,UFRXCR,UFRXRD

;PROTECTION FUNCTIONS. NESTED

FNCLOK==1	;LOKUP ONLY
FNCEXC==2	;EXECUTE
FNCRED==3	;READ
FNCAPP==4	;APPEND
FNCUPD==5	;UPDATE
FNCCRE==6	;CREATE
FNCCAT==7	;CHANGE ATRIBUTES
FNCCNM==10	;CHANGE NAME
FNCCPR==11	;CHANGE PROTECTION
FNCSUP==12	;SUPERCEDE
FNCTRN==13	;TRUNCATE
FNCDEL==14	;DELETE

INTERNAL FNCLOK,FNCEXC,FNCRED,FNCAPP,FNCUPD,FNCCRE
INTERNAL FNCCAT,FNCCNM,FNCCPR,FNCSUP,FNCTRN,FNCDEL
;CHN:	CHANNEL DATA BLOCK

;THESE LOCATIONS ARE SET, LOOKED AT AND CHANGED BY FILIO.
;DEVICE DEPENDENT MODULES DO NOT LOOK AT THEM.
;PARAMETERS FOR CHNCB:

INTERN CHNN	;Number of DF10-like channels, 1 for KS/F3, 0 for KI/KL

	DEFINE	CHNCB <

$CHUNN==0	;UNIT NUMBER WITHIN CHANEL
$KCHNN==0	;KONTROLER NUMBER WITHIN CHANNEL

	;Note: BP and FT use SACCB instead of CHNCB
REPEAT %KNCHN(\$CHN,FH),<KONTCB FH>
REPEAT %KNCHN(\$CHN,DP),<KONTCB DP>
REPEAT %KNCHN(\$CHN,MD),<KONTCB MD>
REPEAT %KNCHN(\$CHN,RM),<KONTCB RM>
REPEAT %KNCHN(\$CHN,AP),<KONTCB AP>

IFN $CHUNN,<NMCHUN(\$CHN,\$CHUNN)==NMCHUN(\$CHN,0)>

%NCH(INTERNAL,\$CHN)	;Define CHN0CB::
CHNBSY==:0	;;MAKE SURE FIRST ENTRY IN DATA BLOCK ELSE MACRO ERROR
NMCH(\$CHN):0	;;0 IS IDLE, NEGATIVE IS BUSY
		;; MUST BE WORD 0 OF CHN DATA BLOCK
		;; SO AOSG @KONCHN(J) WILL TEST BUSY AND SET
		;; BUSY IN ONE INSTRUCTION
NMKCN(\$CHN,\$KCHNN)==0
$CHN==$CHN+1
>	;END MACRO DEF OF CHNCB
;SA-10 DATA BLOCKS AND CHANNEL DATA BLOCKS

COMMENT ;

THE SA-10 STRUCTURE IS CONTROLLED BY THE FOLLOWING SYMBOLS:

	SAXN	- IS THE NUMBER OF SA-10'S CONNECTED TO THE SYSTEM.
		  FOR EACH SA-10, (#=THE NUMBER OF THE SA-10)
	SAX#	- IS THE DEVICE MNEMONIC
	SA#INT	- IS THE INTERUPT LOCATION
	SAXC#N	- IS THE NUMBER OF CHANNELS ON THIS SA-10
	BP<#1><#2> IS THE NUMBER OF 3330'S ON THE CHANNEL WHERE:
			<#1> IS THE SA-10 NUMBER
			<#2> IS THE CHANNEL NUMBER
	FT<#1><#2> IS THE NUMBER OF 3420'S (MAGTAPES)
;

SAX0==274		;DEVICE CODE FOR FIRST SA-10 IBM DISK/TAPE CONTROLLER
SAX1==400		;            FOR SECOND SA-10

DEFINE SAXCB(NUM)<LALL	;; GENERATE THE SA-10 CHANNEL BLOCKS
	$SAXCN==0
    REPEAT SAXC'NUM'N,<SACCB (NUM,\$SAXCN)>

SA'NUM'INT::CONSO SAX'NUM,1B18	;Is the SA10 requesting an interrupt?
	 JRST .-.
	JSR SAXSAV##		;Yes, save ACs
	JSP M,SAXINT		;Point to SAX0CB

SAX'NUM'CB::
	PHASE 0
SAXCNI::! CONI SAX'NUM,T1
SAXCNO::! CONO SAX'NUM,(T1)
SAXDTI::! DATAI SAX'NUM,T1
SAXCHL::!			;Pointers to channel blocks
	%%XXQ=0
    REPEAT SAXC'NUM'N,<
	NMSCH(NUM,\%%XXQ)
	%%XXQ==%%XXQ+1
    > ; End REPEAT SAXC'NUM'N

    REPEAT 4-SAXC'NUM'N,<0>	;Zero for unused channels
	DEPHASE

> ; End DEFINE SAXCB

DEFINE SACCB(XNUM,CNUM)<	;; NOW THE SA-10 CHANNEL BLOCK

IFE BP'XNUM'CNUM+FT'XNUM'CNUM,<SC'XNUM'CNUM'CB==:0>
IFN BP'XNUM'CNUM+FT'XNUM'CNUM,<
	$SAXUN==0	;NUMBER OF UNITS (MAX)
	$CHUNN==0	;NUMBER OF UNITS (ACTUAL)
	$KCHNN==0
    REPEAT BP'XNUM'CNUM,<KONTCB (BP)>
    REPEAT FT'XNUM'CNUM,<KONTCB (FT)>
    IFN BP'XNUM'CNUM,<NMCHUN(\$CHN,\$CHUNN)==NMCHUN(\$CHN,0)>
	NMKCN(\$CHN,\$KCHNN)==0

SC'XNUM'CNUM'CB::	;SC00CB is tapes (FTA), SC01CB is disks (BPA,BPB...)
NMCH(\$CHN)::
	PHASE 0
CHNBSY::! 0	;NORMALLY CHANNEL BUSY
CHNSTB::! SAXBAS##+XNUM*^D16+CNUM*4+1	;Address of status word in low core
CHNGO::!  CONO SAX'XNUM,4B29+1B30+<CNUM>B32+SAXCHN##	;Set GO (and PIA)
CHNCLR::! CONO SAX'XNUM,6B29+0B30+<CNUM>B32+SAXCHN##	;Dismiss interrupt
CHNIIE::! CONO SAX'XNUM,7B29+1B30+<CNUM>B32+SAXCHN##	;Enable interrupt
CHNMER::! 0			;Location of memory error
CHNACT::! 0			;Number of interrupts since reload
CHNKON::! NMKCN(\$CHN,0)	;Pointer to first KON on this CHN
CHNBMX::! REPEAT $SAXUN,<-1>	;Block MUX list
			0	;Zero at end of list
	DEPHASE
	$CHN==$CHN+1
> ; End IFN BP'XNUM'CNUM+FT'XNUM'CNUM
	$SAXCN==$SAXCN+1
> ; End DEFINE SACCB
;SA10 COMMON INTERUPT CODE
EXTERNAL EPT,CURUPT

IFN SAXN,<
SAXINT:	XCT	SAXCNI(M)	;Do <CONI SAX,T1>
	TRNE	T1,1B19!1B20	;Parity error or NXM?
	 JRST	SAXMEM		;Yes
	MOVE	T4,T1		;Save a copy of CONI bits
	ANDI	T1,170		;Keep only the "Status Available" flags
	JFFO	T1,SAXIN1	;Determine which channel caused interrupt
;P035/B09 - try to handle spurious SA10 interrupts better.  They should
; never happen if the hardware is working.  Failure to clear it causes
; looping at Channel 3 and KAF (Keep Alive Failure).
	MOVEI	T1,1B18		;Reset SA10 (clear PIA)
	XCT	SAXCNO(M)	; ...
	MOVEM	T4,SAXIN0	;Store CONI that has no bits set
	 STOPCD (.+1,INFO,SAXINX,PRTT4##,<Spurious SA-10 interrupt>) ;;SAXINT+5
	MOVEI	T1,SAXCHN	;Set PIA
	XCT	SAXCNO(M)	; ...
	POPJ	P,		;Wait for hung timer to restart things

SAXIN0:	BLOCK	1		;Spurious CONI bits

SAXIN1:	MOVE	T1,T2		;Get bit number (29 thru 32)
	ADDI	T1,SAXCHL-^D29(M);Convert to 0 thru 3 and add
	SKIPN	PG,(T1)		;Get pointer to channel
	 JRST	SAXIGN		;Unused channel, dismiss it
	AOS	CHNACT(PG)	;Count interrupts from active channel
	LDB	T2,[POINT 8,@CHNSTB(PG),23]	;Get unit address (8 bits)
	HRLI	T4,400000(T2)	;Copy unit for MOVEM T4,SAXIN0
	HRRZ	J,CHNKON(PG)	;Chain of channels on this controller
	JUMPE	J,SAXIGN	;J is never zero
SAXLP1:	HRRZ	T3,KONBSU(J)	;Get lowest unit addr this Kon handles
	CAMGE	T2,T3		;Within range?
	 JRST	SAXLP2		;No
	HRRZ	T3,KONUMX(J)	;Get highest unit addr this Kon handles
	CAMGE	T2,T3		;Within range?
	 JRST	@KONSNT(J)	;Yes, go to BPXINT or FTXINT
SAXLP2:	HLRZ	J,KONCHN(J)	;Next in chain
	JUMPN	J,SAXLP1	;Try next KON
;Change in P035/C02 - Assume BPA or FTA for unit address X'00'
	HRRZ	J,CHNKON(PG)	;Bad unit address (such as 0)
	JRST	@KONSNT(J)	;Let Kontroller "A" handle it

SAXIGN:	MOVEM	T4,SAXIN0	;Store CONI that has no bits set
	 STOPCD (.+1,INFO,SAXINY,PRTT4##,<SA-10 interrupt ignored>);;SAXIGN+0
	SUBI	T1,SAXCHL(M)	;Get channel number 0 thru 3
	LSH	T1,3		;Put in bits 31-32
	IORI	T1,0B30+6B29+SAXCHN ;Clear status for chan, set PIA
	XCT	SAXCNO(M)	;(this clears the interrupt request)
	POPJ	P,


;SA-10 detected memory error

SAXMEM:	MOVE	T2,T1
	MOVEI	T1,2B32+SAXCHN	;GET SET TO FIND CORRECT CHANNEL
	XCT	SAXCNO(M)
	XCT	SAXDTI(M)
	LDB	T1,[POINT 2,T1,17] ;GET NO. OF CHANNEL WITH BAD MEMORY REF.
	ADDI	T1,SAXCHL(M)
	SKIPN	PG,(T1)		;GET R=CHAN DDB ADDRESS.
	 STOPCD (.,CPU,SAXMM1,,<Spurious SA-10 memory error>) ;;SAXMEM+7
	ANDI	T2,7B20		;GET BITS
	HRLZS	T2
	IORM	T2,CHNSTB(PG)	;STORE IT HERE.
	HLLM	T2,CHNMER(PG)	;SET UP 1ST 3 BITS OF CHNMER.
	MOVEI	T1,1B32		;GET PART
	XCT	SAXCNO(M)	;OF
	XCT	SAXDTI(M)	;THE
	MOVE	T2,T1		;MEMORY
	TLZ	T2,777774	;ADDRESS INTO T2.
	MOVEI	T1,5B32		;GET THE REST OF
	XCT	SAXCNO(M)	;THE
	XCT	SAXDTI(M)	;MEMORY ADDRESS
	DPB	T1,[POINT 2,T2,15] ;INTO T2 AND ALSO TO PART OF
	DPB	T2,[POINT ^D22,CHNMER(PG),^D24] ;CHNMER.
	MOVE	T1,T2		;REFERENCE
	LSH	T1,-9		;THE
	TRO	T1,PGE.A!PGE.P!PGE.W ;"BAD"
	DPB	T1,[EPTPGP(%ERR.N)] ;LOC TO
	CLRPTO	%ERR		;CRASH THE SYSTEM IF
	ANDI	T2,777		;IT IS REALLY
	MOVE	T2,%ERR(T2)	;BAD.
	MOVEI	T1,3B32		;GET MEM
	XCT	SAXCNO(M)	;BUFFER
	XCT	SAXDTI(M)	;LH AND XOR IT
	XORI	T2,(T1)		;INTO WORD IN T2.
	MOVEI	T1,2B32		;GET MEM
	XCT	SAXCNO(M)	;BUFFER
	XCT	SAXDTI(M)	;RH AND
	HRLZS	T1		;XOR IT
	XOR	T1,T2		;INTO T2.
	JFFO	T1,.+2		;FIND NO. OF 1ST BAD BIT.
	 MOVEI	T2,^D36		;MARK NONE.
	DPB	T2,[POINT 6,CHNMER(PG),^D30] ;STORE NO.
	MOVE	T1,CHNGO(PG)	;CLEAR THE
	TRC	T1,7B29+1B19 	;MEM ERR AND
	XCT	SAXCNO(M)	;THE CHANNEL.
	POPJ	P,
> ; End IFN SAXN


REPEAT 0,<
A SERIES OF MACROS ARE INCLUDED HERE FOR GENERATING CHANNEL, KONTROLLER,
AND UNIT CORE BLOCKS.  THE VARIOUS CORE BLOCKS ARE LINKED TOGETHER
APPROPRIATELY; THE NUMBER OF EACH TYPE AND APPROPRIATE LINKAGE ARE
DETERMINED BY SYMBOLS GENERATED BY MONGEN.  SYMBOLS GENERATED ARE:

	CHNN	TOTAL NUMBER OF DATA CHANNELS (DF10) FOR DISKS
		CHANNELS ARE NUMBERED FROM 0 TO CHNN - 1

	CNFH	NUMBER OF FIXED HEAD KONTROLLERS ON CHANNEL N
	CNDP	NUMBER OF DISK PACK KONTROLLERS ON CHANNEL N
	CNMD	NUMBER OF MASS FILE (BRYANT DISK) KONTROLLERS ON CHANNEL N

		KONTROLLERS OF EACH TYPE ARE LETTERED A,B,C, ETC., SO
		THE FIRST DISK PACK KONTROLLER IS DPA, THE SECOND DPB, ETC.

	XXYUN	NUMBER OF UNITS ON KONTROLLER XXY

THE CHNCB MACRO GENERATES A CHANNEL CORE BLOCK, THEN CALLS MACROS TO
GENERATE KONTROLLER AND UNIT CORE BLOCKS.  ITS ARGUMENT IS THE CHANNEL NUMBER,
IN ASCII.  CHNCB CALLS MACRO KONTCB FOR EACH KONTROLLER ON THE CHANNEL.  THERE
IS A REPEAT LOOP FOR EACH KONTROLLER TYPE, REPEATED CNXX TIMES, WHERE N IS THE
CHANNEL NUMBER AND XX IS THE KONTROLLER TYPE, EACH LOOP CALLING KONTCB ONCE.
THE ARGUMENTS FOR KONTCB ARE THE KONTROLLER TYPE, A LIST CONTAINING THE LETTERS
TO IDENTIFY SUCCESSIVE KONTROLLERS, AND THE CHANNEL NUMBER, IN ASCII.

KONTCB FIRST CALLS MACRO XXKON TO GENERATE A KONTROLLER CORE BLOCK FOR THE
KONTROLLER, THEN REPEATS XXYUN TIMES CALLING UNITCB MACRO TO GENERATE UNIT CORE
BLOCKS FOR THE KONTROLLER.  ARGUMENTS FOR XXKON ARE KONTROLLER TYPE (XX),
KONTROLLER IDENTIFIER, AND THE ASCII VALUE OF SYMBOL XXNUM, WHICH IS INCREMENTED
FOR EACH KONTROLLER OF TYPE XX.  XXKON FORMS SYMBOL XX'XXNUM (XX0, XX1, ...),
WHICH IS USED AS THE DEVICE CODE FOR THE KONTROLLER.  ARGUMENTS FOR UNITCB
INCLUDE KONTROLLER TYPE, KONTROLLER IDENTIFIER, UNIT NUMBER, AND SYMBOLS TO USE
IN LINKING THE UNIT CORE BLOCKS TOGETHER (SEE UNITCB MACRO).

EACH XXKON MACRO SHOULD CALL THE KONKON MACRO FOR THE KONTROLLER INDEPENDENT
PART OF THE KONTROLLER CORE BLOCK.  ARGUMENTS FOR KONKON MACRO ARE KONTROLLER
TYPE (XX), KONTROLLER IDENTIFIER (Y), AND SYMBOL XX'NUM WHICH IS THE DEVICE CODE
FOR THE KONTROLLER.  NUM IS INCREMENTED FOR EACH KONTROLLER OF TYPE XX.

THE UNIT CORE BLOCKS ARE LINKED IN THREE DIFFERENT WAYS.  ALL UNIT CORE
BLOCKS ON A KONTROLLER ARE LINKED IN A RING (THE LAST POINTS TO THE FIRST),
ALL UNIT CORE BLOCKS ON A CHANNEL ARE LINKED IN A RING, AND ALL UNIT CORE
BLOCKS IN THE SYSTEM ARE LINKED IN A LIST (THE LAST LINK IS 0).  TO
COMPLETE THIS LINKAGE, KONTCB CALLS MACRO KONCLS TO CLOSE THE KONTROLLER
RING, AFTER ALL UNIT CORE BLOCKS FOR THAT KONTROLLER HAVE BEEN GENERATED; CHNCB
CALLS CHNCLS TO CLOSE THE CHANNEL RING; AND AFTER ALL SYSTEM UNIT CORE BLOCKS
HAVE BEEN GENERATED, SYSCLS IS CALLED TO TERMINATE THE SYSTEM LIST.

TO ADD ANOTHER KONTROLLER TYPE XY, YOU MUST ADD ANOTHER REPEAT LOOP IN CHNCB,
REPEATING CNXY TIMES AND PASSING ARGUMENT XY TO KONTCB MACRO.  KONTCB
CALLS MACRO XYKON FOR THE KONTROLLER DEPENDENT PART OF THE KONTROLLER CORE
BLOCK; THAT MUST ALSO BE SUPPLIED.  XYKON SHOULD CALL THE KONKON MACRO FOR
THE KONTROLLER INDEPENDENT PART OF THE KONTROLLER CORE BLOCK.
> ; End REPEAT 0


INTERN	KONERM,KOPOFL,KOPFUS

;DEVICE INDEPENDENT STUFF

KONERM==740000		;MASK FOR ERROR BITS RETURNED IN T1 ON NON-SKIP RETURNS
KOPOFL==400000		;'OFF-LINE' OR 'NOT-READY' OR 'FILE UNSAFE' BIT (LIGHTS UNPOFL IN UNIDES)
KOPFUS==200000		;FILE UNSAFE

DEFINE KONTCB(%TYP)<KONCB1 (%TYP,<A,B,C,D,E,F,G,H,I,J,K,L>)>

DEFINE PRINT2(A,B),<IF2,<PRINTX [A B]>>

DEFINE KONCB1(%TYP,TYPL)<
	$U==0
    IRP TYPL,<
	IFE $U-$'%TYP'NUM,<
	    STOPI
	    IFN %TYP'TYPL'UN,<	RADIX 5+5
		PRINT2(\%TYP'TYPL'UN,units on %TYP'TYPL)
				RADIX 8
		$KNUNN==0	;UNIT NUMBER IN KON
		REPEAT %TYP'TYPL'UN,<
			IFGE $SYUNN-4,<XLIST>;List only the first 4
			IFE  $KNUNN,<LIST>  ;Show first unit on each KON
			IFL  $SYUNN-4,<PAGE>;;Start UNITCB on a new page
			%TYP'ITCB (%TYP,TYPL,\$'%TYP'NUM)>
					LIST
		NMKNUN(%TYP'TYPL,\$KNUNN)==NMKNUN(%TYP'TYPL,0)
		IFIDN <%TYP> <FT>,<NMFTDB(TYPL,\$KNUNN)==>
				PAGE
		%TYP'KON(TYPL,\$'%TYP'NUM)
		$KCHNN==$KCHNN+1
	    > ; End IFN %TYP'TYPL'UN
	    IFE %TYP'TYPL'UN,<$'%TYP'NUM==$'%TYP'NUM+1>
	> ; End IFE $U-$'%TYP'NUM
	$U==$U+1
    > ; End IRP TYPL
> ; End DEFINE KONCB1


;KONTROLLER DATA BLOCK DISK PACKS (ONE DEFINITION NO MATTER
;HOW MANY DISK PACK KONTROLLERS)

;RP10 - CONTROLLER FOR RP01(MEMOREX) DISK PACK UNIT AND/OR RP02
;  (MEMOREX) DISK PACK UNIT:

XP TYPDP,2		;ALWAYS DEFINE CONTROLLER TYPE CODE - SEE UNIKTP

DEFINE DPKON (TYPL,N)<
	DPFIX==0		;;NOT A FIXED HEAD DEVICE (IF 0)
	KONMXU==10
	DPCHN==0
	INTCON (DP,TYPL,DP'N)
    EXTERNAL DP'N'CHN
	KONKON (DP,TYPL,DP'N'CHN)
	KONUNL (DP,TYPL)	;;GENERATE UNIT LIST
	DFCON(DP,TYPL,DP'N)

;;KONTROLLER TYPE DEPENDENT PART OF KONTROLLER DATA BLOCK
	DPC==250		;;DEF DISK PACK CONTROLLER DEVICE CODE
	DPC2==254		;;AND SECOND CONTROLLER(UNTIL ADDED TO MACRO)
	DPINF==10		;;INTERRUPT FLAGS FOR CONSO INSTR.
				;;(DONE FLAGS)

    IFNDEF DP0,<DP0==DPC>	;;DEFINE STANDARD MNEMONIC DEFINITIONS
    IFNDEF DP1,<DP1==DPC2>	;;BUT ALLOW FOR OVERRIDE

DPXCO1::! CONO	DP'N,(T2)
DPXDOT::! DATAO	DP'N,T1
DPXDO1::! DATAO	DP'N,T2
DPXDI1::! DATAI	DP'N,T2
DPXCIT::! CONI	DP'N,T1
	DEPHASE
	$DPNUM==$DPNUM+1
> ; End DEFINE DPKON

;RC10 CONTROLLER FOR RD10(BURROUGHS) FIXED HEAD DISK UNIT AND/OR
; RM10B(BRYANT) DRUM UNIT:

DEFINE	FHKON (TYPL,N)<

	FHFIX==400000		;BIT 0 = 1 IF FIXED HEAD DEVICE
	KONMXU==10		;MAX NUMBER OF UNITS THIS KONTROLER
	FHCHN==0		;DOES REQUIRE CHANNEL
	INTCON (FH,TYPL,FH'N)
    EXTERNAL FH'N'CHN
	KONKON (FH,TYPL,FH'N'CHN)
	KONUNL (FH,TYPL)
	DFCON (FH,TYPL,FH'N)

	FHD==170
	FHD2==174
	FHINF==10		;INTERRUPT FLAGS FOR CONSO INSTR.
				;;(DONE FLAG)

	IFNDEF FH0,<FH0==FHD>
	IFNDEF FH1,<FH1==FHD2>

FHXCI1::! CONI	FH'N,T2
FHXCOT::! CONO	FH'N,(T1)
FHXCO1::! CONO	FH'N,(T2)
FHXDI2::! DATAI	FH'N,T3
FHXDOT::! DATAO	FH'N,T1
FHXIWD::! 0			;INIT WORD STORAGE
	DEPHASE
	$FHNUM==$FHNUM+1
> ;End DEFINE FHKON



DEFINE BPKON(TYPL,N)<	;; 3330 CONTROLLER
	BPFIX==0
	BPCHN==400000
	KONMXU==BP'TYPL'MX
	KONKON(BP,TYPL,0)
	KONSAX(BP,TYPL,N)
BPXCUB::! 0		;KONTROL UNIT BUSY BITS
	KONUNL (BP,TYPL)
	DEPHASE

	$BPNUM==$BPNUM+1
> ; End DEFINE BPKON

DEFINE KONSAX(%TYP,TYPL,N)<
KONBSU::! XWD NMSCH(\$SAXN,\$SAXCN)+CHNBMX+$SAXUN,%TYP'TYPL
KONBMX==:KONBSU	;L.H. POINTER TO BLOCK MULTIPLEX AREA FOR KON
		;R.H. BASE UNIT ADDRESS
KONUMX:!  %TYP'TYPL+KONMXU
KONSNT::! %TYP'XINT	;POINTER TO INTERUPT ROUTINE
	$SAXUN==$SAXUN+KONMXU
    EXTERNAL %TYP'XINT
> ; End DEFINE KONSAX


DEFINE RMKON(TYPL,N)<	;Generate data blocks for the 2020 disk system.
	RMFIX==0		;Not fixed head.
	RMCHN==0		;Operations require channel to be idle
	KONMXU==8		;Maximum number of units on this controller
	KONKON(RM,TYPL,0)
	KONUNL(RM,TYPL)
KONCUA::!ZERO18,,0		;UDB of transferring unit
	DEPHASE
	$RMNUM==$RMNUM+1
> ; End DEFINE RMKON


DEFINE APKON(TYPL,N)<	;;FOR APX AMPEX F3 DISKS
	APFIX==0		;NOT FIXED HEAD
	APCHN==0		;CHANNEL MUST BE IDLE
	KONMXU==4		;MAXIMUM NUMBER OF UNITS IS 4
	KONKON(AP,TYPL,0)
	KONUNL(AP,TYPL)
KONCUA::!ZERO18,,0		;;UDB OF XFERRING UNIT
	XP BLMSIZ,<^D8*^D10>
KONBLM::!BLOCK BLMSIZ+1	;;LIST OF MEMORY ADDRESSES
			;; (IN FORMAT OF LMA DISK INSTRUCTION)
			;; MUST BE ENOUGH TO HOLD ENTIRE CYLINDER.
			;; ONE EXTRA SO THAT ZERO TERMINATES THE LIST.
KONNLM::!BLOCK 1	;PLACE TO STORE ADDRESS OF NEXT LMA TO DO AT IRP LEVEL
KONNLD::!BLOCK 1	;PLACE TO STORE LDA DATA FOR NEXT XFER TO START AT IRP LEVEL
KONNL1::!BLOCK 1	;;COPY OF KONNLD WITH SU SET TO MAKE STARTING XFER FASTER

KONXFR::!BLOCK	1	;;INSTRUCTION TO EXECUTE AFTER A TRANSFER
KONNRM::!BLOCK 1	;;PLACE TO STORE VALUE WE EXPECT ON RMA AT END OF XFER.
			;; (SO DON'T WASTE PRECIOUS INSTRUCTIONS BETWEEN
			;; TRANSFERS OF A CHAIN.
KONNCM::!BLOCK 1	;PLACE TO STORE LCMD DATA FOR NEXT XFER (USUALLY SAME)
KONLRC::!BLOCK 1	;;PLACE TO REMEMBER RCMD OF LAST XFER TO INTERRUPT
KONLRM::!BLOCK 1	;;LAST RMA FOR XFER TO INTERRUPT
KONLRD::!BLOCK 1	;;LAST RDA FOR LAST XFER TO INTERRUPT
	DEPHASE
	$APNUM==$APNUM+1
> ; End DEFINE APKON


DEFINE FTKCHN(XX)<	;;3803 KONTROLLER FOR 3420'S
	XX==1B32
    REPEAT 3-$SAXCN,<XX==XX*2>
> ; End DEFINE FTKCHN

DEFINE FTKON(TYPL,N)<
	FTFIX==0
	FTCHN==0
	KONMXU==10
	KONKON(FT,TYPL,0)
	KONSAX(FT,TYPL,N)
	$SAXUN==$SAXUN+1	;FOR SPECIAL SENSE LOC.
	KONUNL (FT,TYPL)
	DEPHASE

;OVERLAYING HERE.
    IFL KONLEN-FTXSMY+FTXMCH,<
PRINTX ?ERROR IN FTKON OVERLAY OF KONT. DB.  SEE COMMOD AT THIS PRINTX.
    > ; End IFL KONLEN-FTXSMY+FTXMCH
	STAR==.
	RELOC FT'TYPL'CB
	PHASE 0
	FTKCHN YY
FTXMCH::! XWD FT'TYPL'TYP,YY	;TYPE INFO,, CHN NO AS STAT FLG.
FTXBSY::! 0
FTXSNS::! BYTE(8)72,4,FT'TYPL	;SENSE.
FTXDAT:! BYTE(1)1(11)-^D24(24)FTXSTS+FT'TYPL'CB ;INFO TO FTXSTS.
FTXHLT:! Z			;HALT
FTXSS1::! Z
FTXSS2::! Z
FTXSM0::! Z
FTXSMY::! Z			;MEM ERR FLAG,, BUSY BITS
	DEPHASE
	RELOC STAR
	PHASE STAR-FT'TYPL'CB
FTXSTS::! Z
	Z
	Z
	Z
	Z
	Z
FTXSPR::! Z
FTXSP1::! Z
FTXSX1::! Z			;MOST RECENT SAXBAS+1(+5, ETC.)
	DEPHASE
	$FTMODE==1_D+1_DR+1_B+1_IB+1_I+1_AL+1_A
    EXTERNAL MTSIZ,FTADSP
	$FTNUM==$FTNUM+1
> ; End DEFINE FTKON


DEFINE INTCON (%TYP,TYPL,SYM)<	EXTERNAL %TYP'XINT,SYM'SAV
SYM'INT:: CONSO	SYM,%TYP'INF	;;(-4)SKIP IF INTERRUPT FOR THIS KONTROLLER
				;;ALWAYS HAVE INTERRUPT ROUTINE LOOKING FOR INTERRUPS
				;;THIS FLAG NEVER CLEARED (NEEDED FOR DISK PACKS
				;;OPERATOR MOUNTING AND REMOVING PACKS)
	JRST	.		;;(-3)GO TO NEXT SKIP CHAIN ELEMENT
	JSR	SYM'SAV		;;(-2) SAVE INTERRUPT ACS
	JSP	J,%TYP'XINT	;;(-1) SETUP ADDRESS OF KONTROLLER DATA BLOCK
				;; AND BRANCH INTO CODE WHICH IS COMMON
				;; TO ALL KONTROLLERS OF SAME TYPE
				;; (INTERRUPT DISMISSED BY EXTRA POPJ OR JRST XXRET)
KONINT==:SYM'INT-.		;;INDEX TO CLEAR AND SET INTERRUPT CONSO FLAGS
> ; End DEFINE INTCON

DEFINE KONUNL (%TYP,TYPL)<	;;GENERATE UNIT LIST FOR KONTROLLER
	%%KONUS==.
	DEPHASE
%TYP'TYPL'CU:
	$U1==0
    REPEAT %TYP'TYPL'UN,<
	NMUN(\$U1,%TYP'TYPL)
	$U1=$U1+1
    > ; End REPEAT %TYP'TYPL'UN
	BLOCK KONMXU-$U1	;UNIT ADDRESSES
	PHASE %%KONU+KONMXU
> ; End DEFINE KONUNL


;KON:	KONTROLLER DATA BLOCK
;DEFINE FIRST PART OF KONTROLLER DATA BLOCK
;WHICH IS THE SAME FOR ALL KONTROLLER DATA BLOCKS

;FOR EACH KONTROLLER IN SYSTEM:
; PARAMETERS FOR KONKON
; %TYP  - KONTROLLER TYPE (ASCIZ) EG. DP,FH,DR,MD
; TYPL   - KONTROLLER NUMBER SYMBOL (ASCIZ) EG. A,B,C
; SYM - KONTROLLER SYMBOL (ASCIZ) EG. DP0,DP1,FH0,FH1

DEFINE	KONKON (%TYP,TYPL,SYM)<
				;; FROM DEV. DEP. CODE
%TYP'TYPL'CB::	PHASE	0	;;CHANGE PHASE SO CAN DEFINE ALL SYMBOLS
				;; RELATIVE TO BEGINNING OF KONTROLLER
				;; DATA BLOCK. ALSO A CHECK TO BE SURE ALL
				;; KONTROLLER DATA BLOCKS ARE DEFINED THE
				;; SAME WAY.

NMKCN(\$CHN,\$KCHNN)==%TYP'TYPL'CB

		;;ENTRY POINTS INTO KONTROLLER TYPE DEPENDENT CODE:
		;;INDIRECT AND INDEX FIELDS MUST BE 0 SINCE PUSHJ P,@KONYYY(J)
		;; IS USED TO CALL

IFDIF <%TYP> <FT>,<
    EXTERN %TYP'XRED,%TYP'XWRT,%TYP'XADD
    EXTERN %TYP'XFIN,%TYP'XPOS,%TYP'XLTM,%TYP'XUPA,%TYP'XCPY
    EXTERN %TYP'XRCL,%TYP'XSTP,%TYP'XOFS,%TYP'XHRD,%TYP'XSFT
> ; End IFDIF <%TYP> <FT>

IFIDN <%TYP> <FT>,<
	%TYP'XRED==0
	%TYP'XWRT==0
	%TYP'XADD==0
	%TYP'XFIN==0
	%TYP'XPOS==0
	%TYP'XLTM==0
	%TYP'XUPA==0
	%TYP'XCPY==0
	%TYP'XRCL==0
	%TYP'XSTP==0
	%TYP'XOFS==0
	%TYP'XHRD==0
	%TYP'XSFT==0
> ; End IFIDN <%TYP> <FT>

KONRED::!XWD SYM_^D15,%TYP'XRED;;ENTRY POINT TO READ
KOBPI==KONRED			;;PI CHANNEL THIS KONTROLLER IS ASSIGNED TO-WORD ADR.
  KOSPI==^D3			;;BYTE SIZE
  KONPI==^D2			;;BYTE PTR POS.
KONWRT::!XWD ZERO5,%TYP'XWRT	;;ENTRY POINT TO WRITE
KONADD::!XWD ZERO5,%TYP'XADD	;;ENTRY POINT TO READ,STOP ON ERR
KONFIN::!XWD ZERO5,%TYP'XFIN	;;ENTRY POINT TO WRITE,STOP ON ERR
KONPOS::!XWD %TYP'FIX!ZERO5,%TYP'XPOS ;;ENTRY POINT TO POSITION-BIT 0=1 IF FIXED HEAD DEV.
KONLTM::!XWD %TYP'CHN,%TYP'XLTM	;;ENTRY POINT FOR LATENCY TIME (if 1B0 is off)
KONIBM==:<KONRBL==:KONLTM>	;;1B0 set if IBM disks, read buffered log
KONUPA::!XWD ZERO5,%TYP'XUPA	;;ENTRY POINT TO TEST IF KONTROLLER IS ON-LINE
KONDWN==:KONUPA			;;BIT0=1 IF KONTROLLER IS DOWN - WORD ADDRESS
  KOPDWN==:400000		;; THE BIT (SET BY KONCHK - NOT BY %TYP'XUPA)
				;;KONTROLLER WAS OFF-LINEWHEN SYSTEM STARTED
				;; AND OPERATOR COULD NOT PUT IT ON-LINE
				;; SKIP RETURN IF YES, NO SKIP IF NOT

KONCPY::!XWD ZERO5,%TYP'XCPY	;;ENTRY POINT TO DETERMINE TYPE & CAPACITY OF UNIT
KONRCL::!XWD ZERO18,%TYP'XRCL	;;ENTRY POINT TO RECALIBRATE THIS UNIT
				;; NO-SKIP IN UNIT DOES NOT RECALIBRATE OR IS BAD
				;; SKIP RETURN IF RECALIBRATE STARTED OK
KONSTP::!XWD ZERO5,%TYP'XSTP	;;ENTRY POINT TO STOP A HUNG DISK
				;; NO-SKIP IF CAN'T, SKIP IF CAN
KONOFS::!XWD ZERO5,%TYP'XOFS	;;ENTRY POINT TO SET UNIT IN OFFSET MODE
KONHRD::!XWD ZERO5,%TYP'XHRD	;;ROUTINE TO CALL FOR HARD ERRORS
KONSFT::!XWD ZERO5,%TYP'XSFT	;;ROUTINE TO CALL FOR SOFT ERRORS
KONLEN==KONSFT-KONRED	;;FTKON OVERLAYS UNNEEDED KONT. DB LOCS.
KONCHN::!XWD NMKCN(\$CHN,\<$KCHNN+1>),NMCH(\$CHN)	;;ADDRESS OF CHANNEL DATA BLOCK TO WHICH THIS KON
				;; CONNECTED (@USED TO TEST CHANNEL BUSY)
KONPTR::!XWD ZERO5,%TYP'TYPL'CU(P3) ;;USED TO PICKUP UNIT DATA BLOCK ADDRESS
				;; GIVEN PHYSICAL UNIT NUMBER IN AC P3. (@ USED)

> ; End DEFINE KONKON


DEFINE DFCON (%TYP,TYPL,SYM)<	EXTERNAL LOCOCW
KONSWC::! 0		;SAVE WORD COUNT FOR THIS OPERATION
KONCOM::! XWD -CCWMAX,%TYP'TYPL'CB+KONLST
KONLST:!  BLOCK CCWMAX
	  0
KONCUA::! XWD ZERO18,0		;;CURRENT UNIT DATA BLOCK ADDRESS DOING
				;; DATA TRANSFER (OR LAST ONE)
KONIOC::! XWD ZERO18,SYM'IOC	;;CONTAINS ADR. OF LOWER CORE CHANNEL
				;; PAIR FOR THIS PHYSICAL KONTROLLER
				;; (DIFF. PAIR FOR EACH KONTROLLER SO NO
				;;CHANNEL CONFLICT IF RECONFIGURE CHANNELS)
XP SYM'IOC,LOCOCW+$LOCW
$LOCW==$LOCW+2
KONINS:!			;;ADD IO INSTRUCTIONS AND ALL DATA LOCATIONS HERE:
> ; End DEFINE DFCON

;;BYTE POINTERS
KOYPI::	POINT KOSPI,KOBPI(J),KONPI     ;;PI CHANNEL THIS KONTROLLER ASSIGNED TO

;INTERUPT COMMUNICATION BITS

;Bits 0-7 are attention interrupt bits for non-IBM disks
KCMPOS==:(1B7)	;SPECIAL POSITION INTERRUPT (U already set up by BPXKON)
KCMRER==:(1B8)	;RECOVERED ERROR
KCMFUS==:(1B9)	;FILE UNSAFE
KCMERR==:(1B10)	;ERROR
KCMDTA==:(1B11)	;DATA TRANSFER
KCMIOS==:(1B12)	;I/O SELECT NEEDED (ONLY SET BY DEV-INDEP)
KCMOFL==:(1B13)	;OFF-LINE
		;RH is number of blocks transferred
;UNI:	UNIT DATA BLOCK

;PARAMETERS FOR UNITCB
;%TYP	- KONTROLLER TYPE (E.G. FH,DP,MD)
;TYPL	- KONTROLLER IDENTIFIER (STARTS AT A)

;UNI:	UNIT DATA BLOCK
;POINTED TO BY EACH STR (FANOUT)(STRTAB)
;POINTS TO NEXT UNI IN SYS (ACROSS POINTER)(LH UNISYS)
;POINTS TO NEXT UNI WITHIN CHANNEL (RING)(RH UNICHN)
;POINTE TO NEXT UNI WITHIN KONTROLLER(ACROSS POINTER)(LH UNIKON)
;POINTS TO ITS CHN (UPWARD PTR)(RH UNICHN)
;POINTS TO ITS KON (UPWARD PTR)(RH UNIKON)
;POINTS TO NEXT UNI IN STR(ACROSS PTR)(LH UNISTR)
;POINTS TO ITS STR DATA BLOCK(UPWARD POINTER)(RH UNISTR)

DEFINE UNITCB (%TYP,TYPL)<
%NUN (INTERNAL,\$KNUNN,%TYP'TYPL)
IFNDEF FIRUNI,<FIRUNI:>	;;DEFINE FIRST UNIT DATA BLOCK ADR. IN SYSTEM
NMUN(\$KNUNN,%TYP'TYPL):	%SUN(\$KNUNN,%TYP'TYPL)
UNINAM==:0	;;(0)SIXBIT PHYSICAL UNIT NAME WITHIN KONTROLLER
		;;LAST DIGIT IS 0 TO 7 -LEFT JUSTIFIED
		;; EXAMPLE:  DRA0,FHA0,MDA0,DPA0;;DPA1,DPB3
		;;[NEVER CHANGED BY MONITOR]

	PHASE	1
UNILOG::!0	;;(1)SIXBIT LOGICAL UNIT NAME WITHIN STR
		;; LAST DIGIT OR TWO IS 0 TO 77 LEFT JUSTIFIED
		;; EXAMPLE:  DSKA0,DSKB0,DSKC0;;DSKA17 [SET FROM HOMLOG BY HOMRED]
UNIHID::!0	;;(2)SIXBIT HOME BLOCK IDNAME - NEVER CHANGED IN HOME BLOCK
		;; SET WHEN SECTOR HEADERS ARE WRITTEN.  FOR DISK PACKS
		;; THE HOME BLOCK ID NAME IS THE PACK ID.
NMSYUN(\$SYUNN)==NMUN(\$KNUNN,%TYP'TYPL)
UNISYS::!XWD NMSYUN(\<$SYUNN+1>),0 ;;(3)LH=CORE ADDRESS(ACCROSS POINTER) OF NEXT
		;; UNIT DATA BLOCK IN SYSTEM, LH=0 IN LAST UNIT IN SYSTEM
UNILUN==UNISYS	;;RH. LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT-WORD ADR.
  UNSLUN==^D6	;;BYTE SIZE
  UNNLUN==^D35	;;BYTE PTR POS.

UNISTR::!0	;LH=ADDRESS OF NEXT UNIT DATA BLOCK IN STR
		;LH=0 IN LAST UNIT IN FILE STRUCTURE
		;RH=UPWARD POINTER TO FILE STR. DATA BLOCK.
		;WORD=0 IF THIS UNIT IS NOT IN A STR

NMCHUN(\$CHN,\$CHUNN)==NMUN(\$KNUNN,%TYP'TYPL)
UNICHN::!XWD NMCHUN(\$CHN,\<$CHUNN+1>),NMCH(\$CHN)	;;(5)LH=ADDRESS OF NEXT UNIT DATA BLOCK ON SAME CHANNEL
		;; LAST UNIT POINTS BACK TO FIRST UNIT (RING)
		;; RH=UPWARD POINTER TO CHANNEL DATA BLOCK.
NMKNUN(%TYP'TYPL,\$KNUNN)==NMUN(\$KNUNN,%TYP'TYPL)
UNIKON::!XWD NMKNUN(%TYP'TYPL,\<$KNUNN+1>),%TYP'TYPL'CB	;;(6)LH=ADDRESS OF NEXT UNIT DATA BLOCK ON SAME KON
		;; LAST UNIT POINTS BACK TO FIRST UNIT (RING)
		;; RH=UPWARD POINTER TO KONTROLLER DATA BLOCK
UNIFEP::!0	;; (7) Front-End File Pointer on this unit. LH=RH=0 if none.
		;; LH=No. of consecutive pages in front-end area on this unit.
		;; RH=First (directory) page of front-end area on this unit.

;ERROR STATISTICS:
UNIHCT::!0	;;(10)NO. OF HARD DISK ERRORS ON THIS UNIT (RETRYS FAILED TO CLEAR ERROR)
		;; LH=NO. DEVICE+SEARCH ERRORS(IODERR)(CHAN+CONTROL)(SEE UNIPCT)
		;; RH=NO. DATA ERRORS(IODTER)(HARDWARE PARITY AND SEARCH)
UNISCT::!0	;;(11)NO. OF SOFT + NO. OF HARD ERRORS - INCREMENTED ON EVERY ERROR
		;; INTERRUPT
		;;LH=NO. SOFT+HARD DEVICE+SEARCH ERRORS(SEE UNIPCT)
		;; RH=NO SOFT+HARD DATA ERRORS
UNIMCT::!0	;;(12)NO. OF MONITOR DETECTED ERRORS(3 12 BIT FIELDS)
		;; USER PROGRAM SEES IOIMPM ERROR BIT SET FOR ALL 3 TYPES OF ERRORS
  UNPSER==:100	;;NO. OF SAT FAILURES(NO. OF FREE BIT-PAIRS ON DISK SAT
		;; DISAGREE WITH EXPECTED NO AS STORED IN CORE)
  UNPRER==:10000;;NO. OF RIB REDUNDANT INFO FAILED TO COMPARE
  UNPCER==:1	;;NO. OF SOFTWARE FOLDED CHECKSUM FAILURES(SWAP+USER IO)
		;; (MUST BE RIGHT JUSTIFIED FOR AOS)
UNIERR::!0	;;(13)LAST HARD ERROR DEVICE STATUS(IE STYTRY TIMES FAILED IN A ROW)
		;; WHICH OCCURRED ON THIS UNIT. SET BY MOVEM T2,UNIERR(U)
		;; IN FILSER WHERE T2 IS SET DIRECTLY FROM
		;; KONTROLLER STATUS WORD IN KONTROLLER DEPENDENT ROUTINE.
UNISOF::!0	;;(14)LAST SOFT OR HARD ERROR DEVICE STATUS
UNIHBN::!0	;;(15)LAST LOGICAL BLOCK NUMBER ON HARD ERROR

;;PERFORMANCE MONITORING DATA LOCATIONS:
;;NOTE FOLLOWING 6 ENTRIES ARE MUTUALLY EXCLUSIVE AND ACCOUNT FOR ALL
;; TRANSFERS ON THIS UNIT(EXCEPT ERROR RETRYS)
;WRITE COUNT MUST BE READ COUNT+1
UNIBRC::!0	;;(16)NO. OF BUFFERED MODE 128 WORD BLOCKS READ
UNIBWC::!0	;;(17)NO. OF BUFFERRED MODE 128 WORD BLOCKS WRITTEN
UNIDRC::!0	;;(20)NO. OF DUMP MODE 128 WORD BLOCKS READ(INCLUDEING GETS)
UNIDWC::!0	;;(21)NO. OF DUMP MODE 128 WORD BLOCKS WRITTEN(INCLUDING SAVES)
UNIMRC::!0	;;(22)NO. OF MONITOR PAGES READ(SAT,UFD,MFD,BAT)
UNIMWC::!0	;;(23)NO. OF MONITOR PAGES WRITTEN(SAT,UFD,MFD,BAT)
UNIHNG::!0	; NO OF HUNG TIME OUTS WHICH COUNT NOT BE RECOVERED
		;LH HUNG FROM TRANSFER, RH OTHER (POSITION)

UNIICT::!0	;;(24)NO. OF 128 WORD BLOCKS SWAPPED IN(SET BY SWPINT)
UNIOCT::!0	;;(25)NO. OF 128 WORD BLOCKS SWAPPED OUT(SET BY SWPINT)
;;NOTE:!FOLLOWING 2 ENTRIES ARE MUTUALLY EXCLUSIVE AND ACCOUNT FOR ALL SEEKS
;; ON THIS UNIT EXCEPT END OF CYLINDER ADN RECALLIBRATION AND SEEK UUOS
UNIMSC::!0	;;(26)COUNT OF NO. OF MONITOR+SWAP SEEKS
UNIUSC::!0	;;(27)COUNT OF NO. OF USER(BUFFER+DUMP) SEEKS
		;; (INCLUDES GETS AND SAVES)
		;;(30)COUNT OF POSITIONING FAILURES
;;MORE ERROR STATISTICS:
	0	;;(31) (obsolete: Free K for swapping on this unit)
UNISDI::!0	;;(32)LAST SOFT OR HARD ERROR DATAI IN STATUS WORD
		;; DATA,DEVICE,SEARCH ERRORS
UNIHDI::!0	;;(33)LAST HARD ERROR DATAI IN STATUS WORD
		;; DATA,DEVICE,SEARCH ERRORS
UNIECT::!0	;;(34) NO. OF CONSECUTIVE TIMES AN ERROR STATUS WAS RETURNED
		;; FOR THE LAST OPERATION ON THIS UNIT. (IE, FIRST+RETRIES
		;; WITH ERRORS).  SET BACK TO 1 ON FIRST ERROR, RATHER THAN
		;; BEGINNING OF NEW OPERATION, SO USER PROGRAMS HAVE MORE
		;; TIME TO LOOK AT IT.
UNISBN::!0	;;(35) BLOCK NUMBER WITH LAST SOFT ERROR
UNISTS::!0	;;(36) STATUS WORD FOR UNIT - SET, CHANGED BY FILSER ONLY
		;;ONLY WHOLE WORD USED SO THAT EXCH TRICK CAN BE USED
		;;THESE SAME CODES ARE USED IN DEYCOD BYTE
  ;Here starts descrepency between TYMCOM-X and TOPS-10 "UDB" definitions
UNIQUE::!XWD 0,0;;LH=ADDRESS OF FIRST (LONGEST WAITING) DEVICE DATA BLOCK (FILE)
		;; IN POSITION WAIT FOR THIS UNIT (PW QUEUE)
		;;RH=ADDRESS OF LAST (SHORTEST WAITING) DEVICE DATA BLOCK (FILE)
		;; IN POSITION WAIT FOR THIS UNIT
		;;AS A FLAG, BOTH HALVES ARE SET TO 0 WHEN NO FILES IN
		;; POSITION WAIT QUEUE.
		;;NOTE:!THE FILE WHICH IS IN P STATE IS NOT IN QUEUE
		;; QUEUE SEARCH
UNICDA::!0	;;RH=current DDB address of file doing I/O on this unit
UNIPPU::!0	;;# of usable pages per unit (returned as word 6 by DSKCHR)
UNICHR::!0	;;Unit characteristics (returned as word 5 by DSKCHR muuo)
  ;;1B0		;;Sign bit set if formatted in pages, clear if in blocks
UNIBPR==:UNICHR	;;Bits 1-8  = # of blocks per record
  UNSBPR==^D8	;; UNYBPR = 1 if formatted in blocks
  UNNBPR==^D9	;; UNYBPR = 4 if formatted in pages
UNIBPT==:UNICHR	;;Bits 9-17 = # Blocks per track (9-15 = pages per track)
  UNSBPT==^D9	;; Used only by device drivers (APXKON,BPXKON,RMXKON)
  UNNBPT==^D17
UNIBPY==:UNICHR	;;Bits 18-35 = # blocks per cylinder (18-33 = # pages per cyl)
  UNSBPY==^D18	;; Must be a multiple of 4 for integral pages per cylinder
  UNNBPY==^D35	;; UNYPPY used by FILIO
UNIWPS::!0	;;# of words per SAT page, 0 means 512
  UNSWPS==^D9
  UNNWPS==^D8	;;BIT 9 UNUSED
UNISPU==:UNIWPS	;;# of SAT pages on unit
  UNSSPU==^D8
  UNNSPU==^D17
UNICYL::!-1	;;Physical cylinder unit is currently at or positioning towards.
		;; Checked by FILIO to see if seek is needed, set only by device
		;; driver.  Initialized to -1 to force positioning.
IFE FTDPAG,<
UNIBLK::!0	;;Logical block number for next transfer (replaced by UNIPAG)
UNIONC==:UNIBLK	;;Flag bits for ONCDSK (capacity test, off-line test)
>
IFN FTDPAG,<
UNIPAG::!0	;;Logical page number for next transfer  (formerly UNIBLK::)
UNIONC==:UNIPAG	;;Flag bits for ONCDSK (capacity test, off-line test)
>
UNISTT::!0	;;LH undefined, RH=addr of STT for this unit
UNITAL::!0	;;NO. OF FREE PAGES(RESERVED+FCFS) LEFT ON THIS UNIT
		;; [NO SAFETY FACTOR FOR UNIT, INSTEAD THERE IS ONE FOR THE STR]
UNIDES::!BYTE (10)0(8)%UNSZ(\$SYUNN)(3)$CHN(6)TYP'%TYP(3)$'%TYP'NUM(2)0(4)$KNUNN
		;;WORD RETURNED IN AC FOR DSKCHR MUUO DESCRIBES THIS DISK
		;; UNIT IN TERMS OF STR NUMBER, CHANNEL,
		;; KONTROLLER UNIT NUMBER. ETC.
		;; $K   = BINARY NUMBER OF NEXT UNIT ON KONTROLLER (STARTS AT 0)
		;; $CHN = BINARY CHANNEL NUMBER (STARTS AT 0)
		;; XX   = BINARY KONTROLLER NUMBER (STARTS 0 FOR EACH KONTROLLER TYPE)
		;;HENCE, UNIDES RH=(3)CHANNEL NUM(6)KONTROLLER TYPE
		;; (3)KONTROLLER NUM(3)UNIT TYPE(3)UNIT NUMBER
  ;;;RHB==:400000 ;;BIT 0=1 IF THE MONITOR MUST READ HOME BLOCK (PACK OFFLINE)
  UNPOFL==:200000 ;;BIT 1=1 IF THE UNIT IS OFF LINE
  UNPHWP==:100000 ;;BIT 2=1 IF THE UNIT IS HARDWARE WRITE PROTECTED
  ;;;SWP==: 40000 ;;BIT 3=1 IF STRUCTURE IS SOFTWARE WRITE PROTECTED
  UNPCHG==: 40000 ;;TIMESHARED BIT - A PARAMETER WAS CHANGED SO HOME BLOCK MUST
		  ;; BE WRITTEN.  USED AND CLEARED BY ONCE-ONLY CODE.
  UNPPRV==: 20000 ;;BIT 4=1 IF THIS IS A PRIVATE PACK/STRUCTURE.
  ;;;ZMT==: 10000 ;;BIT 5=1 IF ZERO MOUNT COUNT.
  UNPFUS==:  4000 ;;BIT 6=1 IF FILE UNSAFE.
  UNPRRS==:  2000 ;;BIT 7=1 IF UNIT NEEDS READ AND RESET BUFFERED LOG
  ;;;STS==:  1000 ;;BITS 7&8 USED FOR TOPS-10 STATUS
  UNPMSB==:   400 ;;BIT 9=1 IF THIS UNIT HAS MORE THAN ONE SAT PAGE
  ;;;NNA==:   200 ;;BIT 10=1 IF NO NEW ACCESSES, STRUCTURE IS LOCKED
  ;;;AWL==:   100 ;;BIT 11=1 IF WRITE-LOCKED FOR ALL JOBS
  ;;;CPU==:    60 ;;BITS 12&13 HAVE CPU NUMBER (TRI-SMP)
  ;;;ALT==:    10 ;;BIT 14=1 IF DUAL PORTED UNIT
  ;;;TYP==:     7 ;;BITS 15-17 TYPE OF ARGUMENT TO DSKCHR UUO

UNISIZ==:UNIDES	;;SIZE OF UNIT DATA BLOCK
  UNSSIZ==^D8	;;BYTE SIZE
  UNNSIZ==^D17	;;BYTE PTR POS.

		;;BITS 15 - 17 ARE A CODE WHICH TELLS WHETHER THE ARGUMENT PASSED TO
		;; MONITOR IN LOC WAS:(NEVER STORED IN UNIT DATA BLOCK)
		;; 0	GENERIC DEVICE DSK OR LOGICAL NAME FOR IT (E.G., DSK)
		;; 1	SUBSET OF STR BECAUSE OF AN STR ABBREVIATION
		;; 2	STR NAME OR LOGICAL NAME FOR IT (E.G., DSKA)
		;; 3	UNIT WITHIN A FILE STRUCTURE OR A LOGICAL NAME FOR IT
		;; 	(E.G., DSKA0)
		;; 4	A KONTROLLER CLASS NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DR,FH,DP,MD,BP,AP,RP)
		;; 5	A KONTROLLER NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DRA,FHA,DPA,MDA,DPB,BPA,APA,RPA)
		;; 6	A PHYSICAL DISK UNIT NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DRA0,DPA3)
		;;RH CONFIGURATION INFORMATION:
UNISCN==:UNIDES	;;BITS 18-20 DATA CHANNEL NUMBER SOFTWARE THINKS HARDWARE IS
  UNSSCN==^D3	;; CONNECTED TO.  STARTS AT 0 SO FIRST DATA CHANNEL IS 0.
  UNNSCN==^D20	;;BYTE PTR POS.
UNIKTP==:UNIDES	;;BITS 21-26 CONTROLLER TYPE
  UNSKTP==^D6	;;BYTE SIZE
  UNNKTP==^D26	;;BYTE PTR POS.
;*; TYPDR==0	;; 0	DR (DRUM THAT DEC NEVER BUILT)
    TYPFT==0	;; 0	FT 3380 KONTROLLER FOR IBM 3420'S
    TYPFH==1	;; 1	FH (BURROUGHS DISK OR BRYANT DRUM)
    TYPDP==2	;; 2	DP (MEMOREX RP01,RP02)
    TYPMD==3	;; 3	MD (BRYANT MASS DISK)
    TYPBP==4	;; 4	BP (BIG PACK, IBM 3330 DISK ON SA10 CONTROLLER)
    TYPRM==5	;; 5	RM (RH11C CONTROLLER FOR RM03, RP06 UNITS)
    TYPAP==6	;; 6	AP (AMPEX OR CDC DISKS FOUND ON F3)
		;; 7	-- unused

UNIKNM==:UNIDES	;;BITS 27-29 KONTROLLER NUMBER.  STARTS AT 0, SO FIRST KONTROLLER OF
  UNSKNM==^D3	;; EACH TYPE STARTS AT 0.  (E.G., DPA=0,DPB=1,ETC.)
  UNNKNM==^D29	;;BYTE PTR POS.
UNIUTP==:UNIDES	;;BITS 30-31 UNIT TYPE - A KONTROLLER DEPENDENT FIELD USED TO
  UNSUTP==^D2	;; DISTINGUISH VARIOUS OPTIONS OF A UNIT ON ITS KONTROLLER
  UNNUTP==^D31	;;BITS 21-26   BITS 30-31
		;;   DR 0	0
		;;   FT 0	1  IBM 3420 TAPE ON SA10
		;;   FH 1	0  BURROUGHS DISK ON RC10
		;;   FH 1	1  BRYANT DRUM ON RC10
		;;   DP 2	0  RP01
		;;   DP 2	1  RP02
		;;   MD 3	0  DUAL POSITIONER
		;;   MD 3	1  SINGLE POSITIONER
		;;   BP 4	0  3330-1  (100 MEGABYTE) IBM DISK ON SA10
		;;   BP 4   *	1  3330-11 (200 MEGABYTE) IBM DISK ON SA10
		;;   BP 4   *	2  3650/52 (300 MEGABYTE) Memorex disk on SA10
		;;   BP 4   *	3  reserved for other IBM disk on SA10
		;;   RM 5   *	0  RM03 UNIT ON 2020
		;;   RM 5   *	1  RP06 UNIT ON 2020
		;;   AP 6	0  AMPEX DISK FORMATTED IN BLOCKS
		;;   AP 6	1  CDC DISK FORMATTED IN BLOCKS
		;;   AP 6   *	2  CDC DISK FORMATTED IN PAGES
		;;          *   marks supported disk types in P034/P
  UNPUTP==:20	;;THE BIT WHICH DISTINGUISHES THE DISK TYPES (if only 2)
UNIPUN==:UNIDES	;;BITS 32-35 PHYSICAL UNIT NUMBER WITHIN KONTROLLER - STARTS AT
  UNSPUN==^D4	;; 0 FOR EACH KONTROLLER SO FIRST UNIT IS 0, MAX IS 17
  UNNPUN==^D35	;;BYTE PTR POS.
	0	; Place holder for obsolete entry (for SYSTAT and ERRCHK)
	0	;   "	  "	"	"	"
UNIRCT::!0	;;HOLDS RETRY COUNTS FROM DEVICE DEPENDENT CODE
UNIRTY==UNIRCT	;;NUMBER OF TIMES TO RETRY BEFORE RECAL
 UNSRTY==^D9
 UNNRTY==^D35	;POSITION OF FIELD
UNIRCL==UNIRCT	;;NUMBER OF TIMES TO RECALIBRATE
 UNSRCL==^D9
 UNNRCL==^D26
UNIRRT==UNIRCT	;;NUMBER OF TIMES TO RETRY BETWEEN RECALS
 UNSRRT==^D9
 UNNRRT==^D17

 UNPDEV==:1000	;;FLAG THAT THIS WAS A DEVICE ERROR NOT DATA ERROR

UNIFCT::!0	;;FAIRNESS COUNT (USED ON UNITS WHICH POSITION)
UNIDIR::!0	;;ON UNITS WHICH POSITION, BIT 0 IS DIRECTION OF
		;;LAST POSITION
UNITIM==UNIDIR	;;TIMER FOR HUNG DEVICE (AND OFF-LINE)
 UNSTIM==6	;;SIZE
 UNNTIM==6
UNIPAC==UNIDIR	;;ACTIVE PAGE POINTER FOR PAGE REQ'S
 UNSPAC==^D13	;;SIZE
 UNNPAC==^D19	;;LOCATION
UNIPGL==UNIDIR	;;LIST OF PAGES TO DO REQUESTS FOR (POINTER TO FIRST)
 UNSPGL==^D13	;;SIZE
 UNNPGL==^D32	;;LOCATION
UNIPPL==UNIDIR	;;NUMBER OF BLOCKS OF PAGE COMPLETED (IN CASE OF ERROR)
 UNSPPL==2	;;SIZE
 UNNPPL==^D34	;;LOCATION
		;;BIT 35 IS UNUSED

UNIRC1::!0	;;SECOND CELL USED BY E.R.
 UNIOCV==:UNIRC1;;STATE OF OFFSET E.R. 0 IMP FINISHED; ODD IMP AWAY,
  UNSOCV==^D9			;; EVEN IMP TOWARDS SPINDLE. (VARIABLE W)
  UNNOCV==^D35
 UNIRTO==:UNIRC1;;NUMBER OF TIMES TO RETRY AFTER OFFSET (PARAMETER X)
  UNSRTO==^D9
  UNNRTO==^D26
 UNIRCO==:UNIRC1;;NUMBER OF TIMES TO RECAL AFTER RETRIES AFTER OFFSET
  UNSRCO==^D9			;; (PARAMETER Y)
  UNNRCO==^D17
 UNIOS==:UNIRC1	;;1 IFF SHOULD ENTER OFFSET MODE BEFORE STARTING A TRANSFER
  UNSOS==^D1
  UNNOS==^D7

	$SYUNN==$SYUNN+1
	$KNUNN==$KNUNN+1
	$CHUNN==$CHUNN+1
> ; End DEFINE UNITCB


DEFINE DPITCB(%TYP,TYPL,N)<
	UNITCB (%TYP,TYPL)
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
> ; End DEFINE DPITCB

DEFINE RMITCB(%TYP,TYPL,N)<
	UNITCB(%TYP,TYPL)
UNISVA::!0		;Starting virtual address of transfer on unit.
UNITWC::!0
UNIOFS::!0
	XP SBSIZ,11	;NUMBER OF WORDS NEEDED TO SAVE RH11 REGISTERS.
UNISBH::!BLOCK SBSIZ	;RH11C/Rm03 registers of most recent hard error.
UNISBS::!BLOCK SBSIZ	; ditto for soft errors.
UNISB::!	BLOCK SBSIZ	;RH11C/RM03 registers saved here on error.
	; 0,10,14,42,2,12,4,16,20,22,24,26,30,32,34,40,6,44 saved in
	; that order (see SAVSTS in RM03), two per word, first in Lh.
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
> ; End DEFINE RMITCB

DEFINE APITCB(%TYP,TYPL,N)<
	UNITCB(%TYP,TYPL)
	XP SBSIZ,4	;NUMBER OF LOCATIONS NEEDED TO SAVE F3 DISK REGISTERS
UNISBH::!BLOCK SBSIZ	;CONTROL REGISTERS OF MOST RECENT HARD ERROR
UNISBS::!BLOCK SBSIZ	;SAME FOR SOFT ERRORS
UNISB::! BLOCK SBSIZ	;USED BY DEVICE DEPENDENT ROUTINE
UNITWC::! BLOCK 1	;TOTAL WORD COUNT, FOR INTERRUPT LEVEL CHECING
UNISVA::! BLOCK 1	;PLACE TO SAVE MEMORY ADDRESS
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
> ; End DEFINE APITCB

IFCPU (<KI,KL>),<
	UNISB==:0
	UNISBH==:0
	UNISBS==:0
>

DEFINE FHITCB(%TYP,TYPL,N)<
	UNITCB(%TYP,TYPL)
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
> ; End DEFINE FHITCB

DEFINE BPITCB(%TYP,TYPL,N)<
	UNITCB(%TYP,TYPL)
UNISWC::!0	;SAVE WORD COUNT FOR THIS OPERATION
UNICNA::!0	;CONTINUE ADDRESS FOR LARGE TRANSFERS
UNICNC::!0	;CONTINUE COUNT
UNICCC::!0	;CURRENT COUNT IF TRANSFER BROKEN
UNISNS::!BYTE (8) 72,4,$KNUNN+BP'TYPL-1	;SENSE COMMAND
	BYTE (12) -^D24 (24) UNISND+NMUN(\<$KNUNN-1>,%TYP'TYPL)
	BYTE (8) 200			;End of command list for SENSE
UNISSD==:.-1			;Bits 9-35 for set sector data
UNISND::!BLOCK ^D<24/4>		;READ SENSE INFORMATION HERE
UNISNC::!0	;NUMBER OF SENSES DONE
UNISVC::!0	;SAVE COUNT HERE ON SENSE
UNISCM::!0	;SAVE COMMAND HERE ON SENSE
UNIACT::!0	;SAVE CHANNEL ACTIVE COUNT FOR HUNG
UNICOM::!-BPCMSZ,,.+1+NMUN(\<$KNUNN-1>,%TYP'TYPL)
	BLOCK BPCMSZ		;Command list goes here
		;;If BPCUN is nonzero, it must be same as BPAUN (and D=B)
	OLV==0	;;Zero if 32 or less disk unit addresses
IFIDN <TYPL>,<A>,<IFN BPCUN,<OLV==NMUN(\<$KNUNN-1>,BPC)+UNISTS>>
IFIDN <TYPL>,<B>,<IFN BPDUN,<OLV==NMUN(\<$KNUNN-1>,BPD)+UNISTS>>
IFIDN <TYPL>,<C>,<IFN BPAUN,<OLV==NMUN(\<$KNUNN-1>,BPA)+UNISTS>>
IFIDN <TYPL>,<D>,<IFN BPBUN,<OLV==NMUN(\<$KNUNN-1>,BPB)+UNISTS>>
UNIOLV::!XWD ZERO18,OLV	;Pointer to other logical volume of 3652 disk
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
	LIST
> ; End DEFINE BPITCB

;Size of 3330/3675 command list is enough for 1 track of 18 blocks.
;This is 18*7 (7 per record = 2 data address words + 2 transfer command words +
; 3 search & TIC words) +1 for end of list +3 for SET SECTOR & its data +2 for
; seek +1 in case last transfer is in two parts (crosses a page boundry).
;A 3650 or 3652 disk formatted in blocks needs to handle 25 blocks per track.
;If formatted in pages, a single transfer spanning up to 4 tracks can be
;accommodated.  BPCMSZ = BPX command-list size.

;; BPCMSZ,<^D<18*7+1+3+2+1>>	;3330 in blocks = 18 records * 19 heads
ND BPCMSZ,<^D<25*7+1+3+2+1>>	;3650 in blocks = 25 records * 30 heads
DEFINE NMFTDB(TYPL,NUMM)<FT'TYPL'NUMM'DB>

DEFINE NMFTDI(TYPL,NUMM)<INTERNAL FT'TYPL'NUMM'DB>

DEFINE SYFTNM(NM)<%SYF'NM>

DEFINE FTDDB(TYPL,NUMM)<
NMFTDB(TYPL,\NUMM):
	PHASE 0
IFE NUMM,<
	FT'TYPL'DDB==NMFTDB(TYPL,\NUMM)
	NMFTDI(TYPL,D)
> ; End IFE NUMM
DEVNAM:!%SUN(\NUMM,FT'TYPL)
DEVCHR:!XWD 7*HUNGST,MTSIZ+1
DEVIOS:!Z
DEVSER:!XWD NMFTDB(TYPL,\<NUMM+1>),FTADSP
DEVMOD:!XWD DVIN+DVOUT+DVMTA,$FTMODE
DEVLOG:!Z
DEVBUF:!Z
DEVIAD:!0
DEVOAD:!0
DEVCLS:!XWD 600000,DEVLSA+NMFTDB(TYPL,\NUMM)
DEVSTS:!Z
DEVABC:!Z
DEVBWC:!Z
DEVLSA:!BLOCK LENFXL
DEVUDB::!NMUN(\NUMM,FT'TYPL)	;STORAGE FOR DR,, UNIT DB ADDR.
DEVCNT::!Z
DEVFNJ::!Z			;FN IN PROGRESS,,IBM 9 TRK ADJ.
DEVADD::!<FT'TYPL+$KNUNN>*10000
DEVDWC::!Z
DEVER1::!Z
DEVER2::!Z
DEVOUT::!Z
DEVINS::!Z
DEV40::! Z
DEVNOI::!Z
DEVACT::!Z
DEVDIO::!Z			;LH UNUSED, RH USED FOR PGYDIO
				;CALCULATIONS.

NMFTDI(TYPL,\NUMM)

XP FT'TYPL'DDS,.
INTERNAL FT'TYPL'DDS

	DEPHASE
> ; End DEFINE FTDDB

FTCMLN==:104

DEFINE FTITCB (%TYP,TYPL,%%N)<
	%NUN(INTERNAL,\$KNUNN,%TYP'TYPL)
NMUN(\$KNUNN,%TYP'TYPL):
SYFTNM(\$SYFTN)==.

	PHASE 0
UNIDDB::! NMFTDB(TYPL,\$KNUNN)	;ADDR OF ASSOCIATED DDB.
UNILNK::! SYFTNM(\<$SYFTN+1>)

;ERROR REPORTING.
FDHFUN::! Z		;FN IN PROGRESS WHEN DEVICE HUNG.
FDHCNT::! Z		;# OF TIMES UNIT HAS HUNG.
FDHCNI::! Z
FDCNI1::! Z
FDCNIE::! Z
FDNRE1::! Z		;# READS NOT SUCCEEDING ON 1ST TRY.
FDNWR1::! Z		;# WRITES NOT SUCCEEDING ON 1ST TRY.
FDNREE::! Z		;" READS     "       "   EVER.
FDNWRE::! Z		;" WRITES    "       "   EVER.
FDERBT::! Z
FDSENS::! Z
	Z
	Z
	Z
	Z
	Z
FDSCHR::! Z
	Z
	Z
	Z
	Z
	Z
FDMEMR::! Z		;INFORMATION ABOUT THE LAST MEM ERR
			;SEEN (CHNMER COPY).

;END OF ERROR REPORTING.

UNIKNT::! XWD NMCH(\$CHN),FT'TYPL'CB  ;CHAN DB,,KONT DB.
UNIERO::! BLOCK 7		;ERROR SPACE IS HERE TO UNICMD.
UNICMD::! BLOCK FTCMLN		;NORMAL COMMAND SPACE IS FROM
UNIDON::!			;UNICMD TO UNIDON.
UNIDCR::! BLOCK 1		;DURING DATA CHECK-READ RECOVERY
				;READ CMD SAVED HERE,
UNIDCN::! BLOCK 1		;NEXT CMD SAVED HERE,
UNIDC1::! BLOCK 1		;POINTER TO READ SAVED HERE.
UNITYP::! Z			;LH=7/9 TRK, DENS.
				;RH=FOR HUNG ROUTINE.(SIGN BIT MUST BE 0).
UNISX1::! Z			;MOST RECENT SAXBAS+1(+5, ETC.) FOR THIS UNIT
UNISX2::! Z			;SAXBAS+2, OR +6, ETC.
UNISX3::! Z			;SAXBAS+3, OR +7, ETC.
$SYFTN==$SYFTN+1		;NO. OF FT UNITS ON SYSTEM.

	FTULNH==:.-UNIDDB+1
	DEPHASE

	FTDDB(TYPL,$KNUNN)
	$KNUNN==$KNUNN+1
	%'%TYP'TYPL'0==0
> ; End DEFINE FTITCB

IFN MAGUN,<;IF ANY KS10 OR F3 STYLE TAPE CONTROLLERS
;Magtape data structures: KDB, UDBs, DDBs
;Note: the KS-10 allows only one TM03 and a maximum of 4 TU45s.

;UDB.   TU0CB::, TU1CB::
DEFINE MTUDB(NUMBER),<
TU'NUMBER'CB::
	PHASE 0
TUBDDB::!TU'NUMBER'DDB		;(0)Address of this unit's DDB
TUBDA::!NUMBER			;(1) 7*<TM03 #> + <TU45 #> (TM03 #=0)
TUBKDB::!TMX0CB			;(2)Pointer to KBD of this unit.
UNITYP::!0			;(3)Lh: <>0 if unit online, 0 ow. Rh:<>0 if
				; device has timed out once.
TUBHC::!0			;(4)Number of times this unit called, "hung."
TUBIWC::!0			;(5)WC register before transfer.
TUBIFC::!0			;(6)FC register before transfer.
TUBCNT::!0			;(7)DEVCNT copied b4 transfer
TUBCLS::!0			;(10)DEVCLS copied b4 transfer
TUBER1::!0			;(11)Error rec. coroutine adr or 0
TUBER2::!0			;(12)Error rec. # tries left.
TUBS::!	0			;(13)Lh: On line state. Rh: rewind state
TUBEC::!0			;(14)number of device errors
TUBSB::!BLOCK 7			;(15:23)device regs last error.
TUBICW::!0			;INITIAL COMMAND WORD FOR CHANNEL
LENFXL==44
TUBCOM::!BLOCK LENFXL		;SPACE FOR COMMAND LIST, ONE WORD FOR EVERY DDB IOWD
MTUDBL==.			;Length of magtape UDB.
INTERNAL MTUDBL
	DEPHASE
>
ZZ==0
REPEAT MAGUN,<
	MTUDB(\ZZ)		;Create TU0CB (and TU1CB for TRW)
ZZ==ZZ+1
>
TUYTMN::POINT 3,TUBDA(U),33	;Pointer to TM03 number (0-7, only 0 supported)
TUYTUN::POINT 2,TUBDA(U),35	;Pointer to TU45 number (0-3, only 0 & 1 used)

;KDB.
TMX0CB::  MT0KDB::
	PHASE 0
TKBCUN::!0			;(0)Address of UDB of currently active unit
IFCPU (KS),<
TKBCBA::!UA3,,772440		;(1)Base address of Rh11C
>;END IFCPU(KS)
TKBSPR::!0			;(2)Count of spurious interrupts received
TKBIUN::!-MAGUN,,TMX0CB+.+1	;Pointer to vector of addressess
				; of all UDBs on the TM03.
	DEPHASE

DEFINE TUCBNM(NUM)<
	TU'NUM'CB
>
ZZ==0
REPEAT MAGUN,<
TUCBNM(\ZZ)
ZZ==ZZ+1>

	BLOCK	<<-MAGUN>&3>	;Zero's for unused TU45 slaves
	0		;There must be one extra 0 at the end of the vector.

;DDB.		TU0DDB::SIXBIT/MTA0/, TU1DDB::SIXBIT/MTA1/
;This macro, given a unit number, returns the name of the DDB.  It is
; necessary because of MACRO's primative macro processor.
DEFINE MFOO1(X)<TU'X'DDB>
DEFINE MTDDB(NUMBER),<
TU'NUMBER'DDB::
	PHASE 0
DEVNAM::!<SIXBIT/MTA/>+<NUMBER+20>_14
DEVCHR::!XWD 7*HUNGST,MTSIZ##+1
DEVIOS::!0
DEVSER::!XWD MFOO1(\<NUMBER+1>),MAGDSP##
DEVMOD::!XWD DVIN+DVOUT+DVMTA,<1_D+1_DR+1_B+1_IB+1_I+1_AL+1_A>
DEVLOG::!0
DEVBUF::!0
DEVIAD::!0
DEVOAD::!0
DEVCLS::!XWD 600000,DEVLSA+TU'NUMBER'DDB
DEVSTS::!0
DEVABC::!0
DEVBWC::!0
LENFXL==44		;At least that's what it is in other systems.
DEVLSA::!BLOCK LENFXL
DEVUDB::!TU'NUMBER'CB
DEVDIO::!0
DEVFNJ::!0
DEVMD1::!0			;Rh: mode.
DEVER1::!0			;Rh: MTER after error
DEVDWC::!0
DEVCNT::!0
MAGDDS==.
INTERNAL MAGDDS
	DEPHASE
>
;This makes the last link 0.
MFOO1(\<MAGUN>)==0

MAGDDB:: MT0DDB::
ZZ==0
REPEAT MAGUN,<
	MTDDB(\ZZ)
ZZ==ZZ+1
>
>;END IFN MAGUN
;DEFINE NAME DEFINERS

	DEFINE %NCH (ARG,NUM)	;FUNCTION USING NAME OF CHANNEL
<ARG CHN'NUM'CB>

	DEFINE NMCH(NUM)	;NAME OF CHANNEL
<%NCH (,NUM)>

	DEFINE NMCHUN(CHN,UNIN)	;UNIT WITHIN CHANEL
<%CH'CHN'UNIN>

	DEFINE %KNCHN (CHN,TYP)	;NUMBER OF TYPES OF UNIT ON CHANNEL
<C'CHN'TYP'N>

	DEFINE NMKNUN (SYM,NUM)	;NAME OF UNIT ON KONTROLER
<%'SYM'NUM>

	DEFINE %NUN(ARG,NUM,TYP)	;FUNCTION OF UNIT
<ARG TYP'NUM'CB>

	DEFINE NMUN (NUM,TYP)	;NAME OF UNIT
<%NUN (,NUM,TYP)>

	DEFINE %SUN (NUM,TYP)	;SIXBIT NAME OF UNIT
<SIXBIT /TYP'NUM/>

	DEFINE NMSYUN (NUM)	;UNIT WITHIN SYSTEM
<%SY'NUM>

	DEFINE NMKCN(CHN,KON)	;NAME OF KON IN CHL
<%CK'CHN'KON>

	DEFINE NMSCH(SAN,CHN)	;NAME OF CHANNEL ON SA-10
<SC'SAN'CHN'CB>

	DEFINE %UNSZ(NUM)	;SIZE OF UNIT DATA BLOCK
<%SIZ'NUM>
SUBTTL	Byte pointers to UNI
IFE DSKTYP-'3675B',<DSKPPU::^D68680>	;BPXKON works only with 3675 blocks
IFN DSKTYP-'3675B',<DSKPPU::0>		;Pages per unit not critical on all others
UNYSIZ::POINT UNSSIZ,UNISIZ(U),UNNSIZ	;Unit data block size
UNYSCN::POINT UNSSCN,UNISCN(U),UNNSCN	;Channel #
UNYKTP::POINT UNSKTP,UNIKTP(U),UNNKTP	;Kontroller type unit is connected to
UNYKNM::POINT UNSKNM,UNIKNM(U),UNNKNM	;Kontroller number within type
UNYUTP::POINT UNSUTP,UNIUTP(U),UNNUTP	;Unit type (Kontroller dependent)
UNYPUN::POINT UNSPUN,UNIPUN(U),UNNPUN	;Physical unit # (0-17) within Kontroller
UNYLUN::POINT UNSLUN,UNILUN(U),UNNLUN	;Logical unit # (0-77) within STR
UNYLN1::POINT UNSLUN,UNILUN(T1),UNNLUN	;Logical unit # - for ONCE only
UNYWPS::POINT UNSWPS,UNIWPS(U),UNNWPS	;Words per SAT page (0 means 512)
UNYBPR::POINT UNSBPR,UNIBPR(U),UNNBPR	;Blocks per sector (1 or 4)
UNYBPT::POINT UNSBPT,UNIBPT(U),UNNBPT	;Blocks per track, for BPXKON,RMXKON
UNYPPT::POINT UNSBPT-2,UNIBPT(U),UNNBPT-2 ;Pages per track, for APXKON,CPXKON
UNYBPY::POINT UNSBPY,UNIBPY(U),UNNBPY	;Blocks per cylinder, for BPXKON,RMXKON
UNYPPY::POINT UNSBPY-2,UNIBPY(U),UNNBPY-2 ;Pages per cyl, for FILIO,APXKON,CPXKON,REFSTR
UNYSPU::POINT UNSSPU,UNISPU(U),UNNSPU	;# SAT pages per unit
UNYTIM::POINT UNSTIM,UNITIM(U),UNNTIM	;Timer for hung device
UNYPAC::POINT UNSPAC,UNIPAC(U),UNNPAC	;Active page pointer
UNYPGL::POINT UNSPGL,UNIPGL(U),UNNPGL	;Request list pointer
UNYRTY::POINT UNSRTY,UNIRTY(U),UNNRTY	;Retry count
UNYRCL::POINT UNSRCL,UNIRCL(U),UNNRCL	;RECAL count
UNYRRT::POINT UNSRRT,UNIRRT(U),UNNRRT	;Retry count between RECALs
UNYOCV::POINT UNSOCV,UNIOCV(U),UNNOCV	;Offset state (error recovery)
UNYRTO::POINT UNSRTO,UNIRTO(U),UNNRTO	;Retry this many times after offset
UNYRCO::POINT UNSRCO,UNIRCO(U),UNNRCO	;RECAL after retry after offset
UNYOS::	POINT UNSOS,UNIOS(U),UNNOS	;1 <=> Set offset mode before XFR
UNYPPL::POINT UNSPPL,UNIPPL(U),UNNPPL	;Partial page transfer byte, for FILIO
SUBTTL	Channel DB, SAX DB, unit DB
$FTNUM==0
$SYFTN==0	;NO. OF FTS ON SYSTEM (FOR ERROR REPORTING.)
$BPNUM==0
$FHNUM==0
$DPNUM==0
$MDNUM==0
$RMNUM==0
$APNUM==0
$SYUNN==0	;UNIT WITHIN SYSTEM
$CHN==0		;CHANNEL NUMBER
$LOCW==0	;USED FOR DEFINING LOW CORE CHANNEL KONTROL WORD

;*;IFCPU (KL),<BLOCK 1000> ;MAKE SURE NO IMPORTANT CODE IS UNCACHED.
; Replaced <BLOCK 1000> with CTYBUF
IF2,<IFG .-<CHNUNC-1000>,<   ;Do NOT move CTYBUF!
  PRINTX ?CHNUNC cannot be in same page as cached items in COMMON!>>

	SYDVF (<<CTYBUF,CTYMSK+1>,<CTYPTR,2>>)	;For SYSDVF function 6
  ND CTYMSK,777			;Index for CTYBUF, runs from 000 to 777
  IFN CTYMSK&<CTYMSK+1>,<PRINTX ? CTYMSK must be (2**n)-1>
CTYPTR:: POINT	7,<CTYBUF-CTYBUF>&CTYMSK	;Relative position in CTYBUF
	 BLOCK	1		;Previous CTYPTR stored at CTYPTR+1
	 ASCII	/<CTY>/		;This marks the start of CTYBUF in the SAV file
CTYBUF:: BLOCK	CTYMSK+1	;Buffer for copy of everything sent to CTY
	 ASCIZ	/<><>/		;Null at end so can use CTYBUF$0T in FILDDT

CHNUNC::!		;START OF UNCACHED AREA
	LALL		;MAKE SURE THE CONTROLLER BLOCKS SHOW UP
REPEAT CHNN,<CHNCB>
	$SAXN==0
REPEAT SAXN,<
	SAXCB (\$SAXN)
	$SAXN==$SAXN+1
> ; End REPEAT SAXN
XP CHNUNE,.-1		;END OF UNCACHED AREA.

IFG DISKS-^D<3*8>,<ND SAXMSK,7>	;This is to keep F33 from exceeding 112K core
IFN SAXN,<
  ND SAXMSK,777			;Mask for SAXBUF, runs from 000 to 777
  IFN SAXMSK&<SAXMSK+1>,<PRINTX ? SAXMSK must be (2**n)-1>
SAXPTR:: EXP	-1		;Relative position (AOS'ed before use)
SAXBUF:: BLOCK SAXMSK+1		;SA10 status (for tracking down 3652 problems)
	SYDVF (<<SAXBUF,SAXMSK+1>,<SAXPTR,1>>)	;For SYSDVF function 6
STPPTR:: EXP	-1		;Copy of SAXPTR at time of THUNG
STPBUF:: BLOCK SAXMSK+1		;Copy of SAXBUF at time of THUNG
	SYDVF (<<STPBUF,SAXMSK+1>,<STPPTR,1>>)	;For SYSDVF function 6
>  ;End IFN SAXN

  ND SCNMSK,777			;Mask for SCNBUF, runs from 000 to 777
  IFN SCNMSK&<SCNMSK+1>,<PRINTX ? SCNMSK must be (2**n)-1>
SCNPTR:: EXP	-1		;Pointer, AOSed before use
SCNBUF:: BLOCK	SCNMSK+1	;Buffer for tracking IRING/ORING bugs
SCNUDT:: EXP	-1		;Time buffer last wrapped
	SYDVF (<<SCNUDT,1>,<SCNPTR,1>,<SCNBUF,SCNMSK+1>>) ;3 things for SYSDVF

;*;IFCPU (KL),<BLOCK 1000> ;MAKE SURE NO IMPORTANT CODE IS UNCACHED
; Replaced <BLOCK 1000> with SAXBUF+SCNBUF
IF2,<IFL .-<CHNUNE+1000>,<   ;Do NOT move SAXBUF!
  PRINTX ?CHNUNE cannot have share the same page with cached data!>>


NMSYUN(\$SYUNN)==0		;Last disk unit has a zero pointer
SYFTNM(\$SYFTN)==0		;Last tape unit has a zero pointer

PRINTF (<[UNTTBL set up for DSKB only - need STROFS offset]>)
UNTTBL:: REPEAT <$SYUNN+2>,<Z>	;1 for SWAP?, 1 for SPARE?
UNTLEN==:.-UNTTBL		;Pointers to logical units of DSKB

IFCPU(<KI,KL>),<
	TUBDDB==:UNIDDB		;Pointer to DDB in Tape Unit Block
	MT0DDB==:FTA0DB		;First tape DDB on KI,KL
	MT0KDB==:FTACB		;First kontroller on KI,KL
>  ;End IFCPU(KI,KL)
	TKBCDB==:UNICHN		;Pointer to channel in TUB
	TUBRID==:0		;We don't have REELID's for our tapes

	$END	(CMD)		;End of COMMOD (CMDLIT: CMDEND:)
   C5Oh