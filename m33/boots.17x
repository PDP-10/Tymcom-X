TITLE BOOTS - V014 - LEVEL D DISK BOOTSTRAP (LOCATION INDEPENDENT)
SUBTTL R. CLEMENTS /TH
SALL

REPEAT 0,<
ASSEMBLY INSTRUCTIONS:
1. TO MAKE LOCATION INDEPENDENT VERSION FOR LOADING WITH WTBOOT PROGRAM
	ASSEMBLE WITH NO SPECIAL SYMBOL DEFINITIONS.
2. TO MAKE ABSOLUTE PAPER TAPE VERSION, DEFINE CORE TO BE:
	40000	FOR 16K
	100000	FOR 32K
	140000	FOR 48K
	200000	FOR 64K
	240000	FOR 80K
	300000	FOR 96K, ETC

	.MAKE FTBOOT.MAC
	ICORE=40000
	$$
	EX$$
	.R MACRO
	PTP:_FTBOOT,BOOTS
3. TO MAKE A KS10 BOOTS:  BOOTS=FTKS10+BOOTS.
   NOTE THAT IN THE KS10 VERSION BOOTS DOES NOT WRITE ITSELF DIRECTLY
   INTO THE HOME FILE.  INSTEAD IT WRITES A FILE BOOTS.DMP WHICH IS
   THEN WRITTEN INTO THE FRONT END FILE SYSTEM BY KSFEFS.
>

;SEE BOOTS.MEM FOR OPERATING INSTRUCTIONS
;NOTE THAT THE DISK PACK CODE IS AT BEST OUT OF DATE.

;AC'S

F=0	;FLAGS
	;BITS 29-35=CONTROLER DEVICE CODES
A=1	;GENERAL AC'S
B=2	; ..
C=3	; ..
X=4	;MEMORY ADDRESS COUNTER
W=5	;WORD RETURNED BY RWORD OR SIXBRD
NAME=6	;NAME OF FILE OR UFD BEING SEARCHED FOR
EXT=7	;EXTENSION OF FILE OR UFD BEING SEARCHED FOR
Q=10	;COUNTER TO STEP THROUGH BUFFER OF 1000 DATA WORDS
POSRET=11 ;CONTAINS ADDR OF CURREN/NEXT RETRIEVAL PNTR IN RBUF.
S=11	;BYTE POINTER AT START UP.
N=12	;NUMBER ASSEMBLER IN TYPEIN
M=13	;MEMORY AOBJN POINTER FOR READING THE DATA TO CORE
K=14	;INDEX OF KONTROLLER TYPE
R=15	;CONTAINS RELOCATION OF BOOTS TO MAKE IT LOCATION INDEPENDENT
	;R+1 MUST BE 17 OR LESS - SINCE JSR R USED TO SET R
RET=16	;RETRIEVAL PNTR OF PAGE TO READ
P=17	;STACK POINTER
;PARAMS FOR KL10 CPU (DTE)
IFCPU(KL)<
DTEFLG=444		;DTE OPERATION DONE FLAG
DTEF11=450		;DATA FROM 11
DTECMD=451		;10 TO 11 COMMAND WORD
DTEMTD=455		;CTY OUTPUT DONE FLAG
DTEMTI=456		;CTY INPUT PRESENT FLAG
.DTMMC==11
.DTMTO==10
DTE==200		;DEVICE CODE FOR DTE
TO11DB==1B22		;TO-11 DOORBELL
>;END IFCPU(KL)

;CORE ALLOCATION

DTASIZ==2400	;SIZE ALLOWED FOR DATA STORAGE.
CODSIZ==1600	;SIZE ALLOWED FOR CODE.  IF THIS IS CHANGED, YOU
		;MUST CHANGE BOTLOD AND COMMON (SYSCRS) ALSO.

IF1,<			;PASS 1?
WTBOOT==0		;ASSUME ABSOLUTE PAPER TAPE VERSION
IFNDEF CORE,<		;IS CORE UNDEFINED?
	WTBOOT==1	;YES, ASSUME LOCATION INDEPENDENT VERSION IS WANTED
>
>
IFN WTBOOT,<		;LOCATION INDEPENDENT?
	INTERN BOOTSA,MBOOTL

	CORE=.+DTASIZ+CODSIZ	;LAST LOC PLUS 1 FOR BOOTS
>

ZZ=CORE-DTASIZ-CODSIZ		;
BOOTDT=ZZ			;FIRST DATA LOC IN BOOTS

CLRTOP=ZZ-1			;WHEN CLEARING CORE, CLEAR TO HERE

DEFINE U(Z)<	UU(Z,1)>	;ONE WORD ALLOCATION
DEFINE UU(Z,N)<	Z=ZZ
ZZ=ZZ+N
IFGE <ZZ-CORE+CODSIZ>,<
PRINTX ALLOCATION ERROR
>>

IFE WTBOOT,<		;ABSOLUTE ASSEMBLY?
LOC CORE-CODSIZ			;ABSOLUTE ASSEMBLY

IFCPU(KI),<
RIM10B>				;PAPER TAPE FORMAT
>
IFN WTBOOT,<		;LOCATION INDEPENDENT ASSEMBLY?
BLOCK	DTASIZ	;SKIP OVER LOWER CORE STUFF
JOBVER==137
MAJVER==17		;MAJOR VERSION NUM
MINVER==0		;MINOR VERSION NUM
INTERNAL JOBVER
	LOC JOBVER
	XWD	MAJVER,MINVER
	RELOC
>


UU(RBUF,1000)
UU(DBUF,1000)
FIRSTW==20			;FIRST LOCATION CONSIDERED ON WRITE
IFCPU(<KI,KL>)<
BOOTWD=22			;DF-10 LOCS IN LOWER CORE
				; (LEVEL C RP-10 DF-10 LOCS)
LOWCMD=BOOTWD			;USE LOC 22 AND 23 FOR THE DF10

;I/O DEVICE PARAMETERS

DPC=250				;DEVICE KONTROLLER NUMBER FOR RP10
DPC2=254			;SECOND RP10
O.SEEK==4			;DISK OP FOR SEEK FOR RP10
O.READ==0			;DISK OP FOR READ FOR RP10
O.WRIT==1			;DISK OP FOR WRITE FOR RP10

FHD=170				;DEVICE NUMBER FOR RC10 KONTROLLER
FHD2=174			;SECOND RC10
FH.WRT==1000			;BIT IN DATAO FOR WRITE ON RC10
;FLAGS, LEFT HALF OF F
>;END IFCPU(<KI,KL>)

L.DOT=1				;DOT SEEN IN FILE SPEC
L.LBK=2				;LEFT BRACKET SEEN IN FILE SPEC
L.CMA=4				;COMMA SEEN IN FILE SPEC
L.SLA==10			;SLASH SEEN IN FILE SPEC
L.ALL==17			;ABOVE FLAGS TOGETHER.

;FLAGS, RIGHT HALF OF F

R.KDEV=177			;BITS 29-35=KONTROLLER DEVICE CODE
R.STRT==2000			;ON IF LOAD AND GO. OFF IF JUST LOAD

;SYSTEM PARAMETERS WHICH MUST AGREE WITH COMMOD

LPNHOM==1			;ADDRESSES OF HOME PAGES
LP2HOM==6			; ..
BOOTBK==14			;STARTING ADDRESS OF BOOTS.  (IN
				;BLOCKS.). KI, KL VERSION ONLY.
CODHOM=070717			;VERIFICATION CODE OF HOME PAGE
CODRIB=666666			;VERIF CODE OF A RIB PAGE
PAGCOD==776			;WORD ADDRESS OF VERIF CODE
PAGSLF==777			;WORD ADDRESS OF SELF POINTER

RIBRIB==0			;RET PNTR TO HIGHER RIB.
RIBRPS==1			;RIB'S POSITION IN HIGHER RIB.
RIBSFS==4			;1ST RET PNTR IN SPARE RIB.
RIBNAM==5			;W A OF NAME OF FILE IN THE RIB
RIBEXT==6			;W A OF EXT OF FILE IN THE RIB
RIBSIZ==10			;LENGTH OF FILE IN WORDS.
RIBPFS==51			;1ST RET PNTR IN PRIME RIB.
RIBLST==775			;LOC OF LAST RET PNTR.

RBSPAR==400000
RBREAL==200000
RBINDX==100000

UFDLNK==^D511			;ADDR OF LINK TO NEXT PAGE OF
				;THE UFD WITH THE SAME HASH.

HOMSNM==2			;STRUCTURE NAME IN SIXBIT
HOMLUN==6			;LOGICAL UNIT NO. (OCT) IN STR
HOMREF==10			;NEED TO REFRESH IF NON-ZERO
HOMMFD==25			;RETRIEVAL PNTR OF MFD RIB
HOMHSH==27			;LH IS HASH CONSTANT.

OPDEF PJRST [JRST]		;EQUIVALENT TO TWO INSTR. PUSHJ/POPJ
				; OR THREE INSTR. PUSHJ/POPJ/JRST CPOPJ1
OPDEF PJSP [JSP]		;EQUIVALENT TO TWO INSTR. MOVEI/PJRST
;START HERE

BOOTSA:
GO:	CONO 200000		;I/O BUS RESET(MONITOR CHECKS FIRST INSTR. TO
				;TO SEE IF IT IS CONO 200000
				; ON 147 RESTART OR DEPOSIT IN 30

	TDZA A,A	;NO STRING
	HRLI A,(POINT 7,0(R))	;STRING, SET BYTE PART
	HRRI A,CMDSTR		;DEFAULT COMMAND STRING
	SKIPA
	HRLI A,(POINT 7,)	;SET STRING BYTE PART, ADR ABSOLUTE
IFCPU(<KI,KL,F3>)<
	CONO 4,10400		;CLEAR PI SYSTEM
>;IFCPU(<KI,KL,F3>)
IFCPU(KS)<
	WRPI LI.CLR+LI.COF+LI.PIF+LI.ACO
	WRAPR 200000
	WREBR 0
	MOVEI F,40000
	WRUBR (F)
>;END IFCPU(KS)
	MOVSI R+1,(JRST (R))	;RETURN INSTR. FOR JSR
	JSR R			;SETUP RELOCATION OF BOOTS IN R
				; RETURN HERE
	SUBI R,.-GO+DTASIZ+BOOTDT	;ADJUST R TO BASE OF BOOTS DATA AREA
	MOVEM A,STRING(R)	;SET BYTE PART OR NO BYTE PART
IFCPU(<KI,KL>)< SETZM CHNFLG(R)	;NO NX- CHANNELS>
REGO:	MOVEI P,PDL-1(R)		;INITIAL STACK POINTER
IFCPU(<KI,KL>)< HRRZS DATAOW(R)	;CLEAR DISK UNIT FIELD>
	SETZB F,PPN(R)		;CLEAR FLAGS, PROJ-PROG NUMBER
	SETZM FNAME(R)		;CLEAR REQUESTED FILE NAME
	SETZM FEXT(R)		;CLEAR REQUESTED FILE EXTENSION
	SETZM SWITCH(R)		;CLEAR COMMAND SWITCHES
IFCPU(KL)<PUSHJ P,SPCINI(R)>	;SAY HELLO TO 11
IFCPU(KS)<SETZM CTYOWD		;ON KS, CLEAR RELOAD, CTY OUTPUT WORDS.
	SETZM CTYIWD
	SETZM 31>;END IFCPU(KS)
	MOVEI A,PROMPT(R)	;GET PROMPT MSG ADDRESS
	PUSHJ P,OUTMSG(R)		;TYPE PROMPT
GOL:	MOVE S,SIXPTR(R)		;POINTER TO THE WORD.
	SETZB N,W		;CLEAR ANSWERS.
SIXBRL:	PUSHJ P,TYI(R)
	CAIG C,"Z"		;LETTER?
	CAIGE C,"A"		; ..
	SKIPA			;NOT A LETTER.
	JRST SIXLTR(R)		;LETTER.
	CAIG C,"9"		;NUMBER?
	CAIGE C,"0"		; ..
	JRST GO0(R)		;NO. RETURN WITH BREAK CHAR.
	LSH N,3			;BUILD OCTAL NUMBER
	ADDI N,-60(C)		;ADD IN THIS DIGIT
SIXLTR:	TRC C,40		;MAKE SIXBIT
	TLNE S,770000		;ONLY 6 CHARS
	IDPB C,S		;STORE CHAR IN W
	JRST SIXBRL(R)		;LOOP FOR MORE.

TYI:	SKIPE STRING(R)
	JRST TYIS(R)	;READ FROM STRING
IFCPU(<KI,F3>)<
	CONSO TTY,40		;WAIT FOR A KEY TO BE ST(R)UCK
	JRST .-1(R)		; ..
	DATAI TTY,C		;GET THE CHAR
>;END IFCPU(<KI,F3>)
IFCPU(KL)<
	SETZ	C,
	EXCH	C,DTEMTI
	JUMPE	C,.-1(R)
	MOVE	C,DTEF11
>;END IFCPU(KL)
IFCPU(KS)<
	SKIPE C,CTYIWD		;CHARACTER READY?
	 TRZN C,CTYIV
	  JRST .-2(R)
	SETZM CTYIWD		;YES, SAY READY TO GET NEXT ONE
>;IFCPU(KS)
TYIC:	PUSHJ P,TYO(R)		;ECHO IT
	ANDI C,177		;ONLY 7 BITS
	CAIN C,177		;RUBOUT?
	JRST REGO(R)		;YES. QUIT.
	CAIL C,140
	SUBI C,40	;CONVERT LOWER CASE TO UPPER
	POPJ P,

TYIS:	ILDB C,STRING(R)
	JUMPN C,TYIC(R)
	SETZM STRING(R)		;OUT OF STRING
	JRST TYI(R)
GO0:	TLNN F,L.ALL		;ANY SYNTAX REQUESTS?
	JRST GO6(R)		;NO. SEE IF FILE NAME.
	TLZE F,L.DOT		;WAS THERE A DOT?
	HLLOM W,FEXT(R)		;YES. STORE EXT. RH IS FLAG IF BLANK.
	TLZE F,L.SLA		;SLASH SWITCH?
	MOVEM W,SWITCH(R)		;YES. SAVE SWITCH WORD
GO7:	CAIG C,40		;SPACE OR CONTROL CHAR?
	JRST DO(R)			;YES. GO PROCESS COMMAND
	CAIE C,"."		;FILE EXTENSION REQUEST?
	JRST GO3(R)		;NO.
	TLO F,L.DOT		;YES. REMEMBER THAT
	JRST GOL(R)		;AND READ ON.

GO3:	CAIE C,"("		;PPN REQUEST?
	JRST GO4(R)		;NO.
	MOVE S,SIXPTR(R)
	SETZB W,W+1
	MOVEI N,^D12
GONM0:	PUSHJ P,TYI(R)
	CAIN C,")"
	JRST GONM1(R)
	SOJL N,GONM0(R)		;READ IN USER NAME
	SUBI C,40
	IDPB C,S
	JRST GONM0(R)

GONM1:	MOVE A,CON1(R)
	MOVE B,CON2(R)
	MOVE C,CON3(R)
	MOVSI X,0
	REPEAT 4,<PUSHJ P,RND(R)>
	XOR C,B
	MOVE W,C
	TLZ W,400000
	IDIVI W,^D887
	XOR A,C
	PUSH P,A		;HASH
	PUSH P,W+1		;PAGE
	MOVSI A,'LUD'
	MOVEM A,FNAME(R)
	MOVSI A,'SYS'
	MOVEM A,FEXT(R)
	SETZM PPN(R)
	PUSHJ P,LOOK(R)
	JRST NOLUD(R)
SRUS2:	MOVE	Q,(P)	;
	LSH	Q,-2		;
	PUSHJ	P,GETRET(R)
	JRST NOUSR(R)
	SOJGE Q,.-2(R)
	MOVEI A,DBUF-1(R)
	PUSHJ P,RDPAG(R)
	JRST RDER(R)
	MOVEI A,DBUF(R)
	POP	P,Q		;
	ANDI	Q,3		;
	IMULI	Q,200		;
	ADDI	A,(Q)	;
	POP P,B
SRUSR:	CAME B,4(A)
	JRST GONM2(R)
	MOVE A,0(A)
	MOVEM A,PPN(R)
	SETZM FNAME(R)
	SETZM FEXT(R)
	JRST GOL(R)

GONM2:	SKIPG C,(A)
	JRST BLKLNK(R)
	MOVE C,2(A)
	ANDI C,177
	ADD A,C
	JRST SRUSR(R)

BLKLNK:	JUMPE C,NOUSR(R)
	PUSH P,B
	PUSH P,C
	MOVEI	POSRET,RBUF+RIBPFS(R) ;
	SKIPN	RBUF+RIBRIB(R)	;CURRENT RIB IS PRIME RIB?
	JRST	SRUS2		;YES.
	MOVE	RET,PRMRIB(R)	;NO, GET THE PRIME RIB.
	PUSHJ	P,GETRIB(R)	;
	JRST	NOUSR(R)
	JRST	SRUS2(R)	;

NOUSM:	ASCIZ /NO USER/
NOLUDM:	ASCIZ /NO LUD/

NOUSR:	MOVEI A,NOUSM(R)
	JRST ERROR(R)

NOLUD:	MOVEI A,NOLUDM(R)
	JRST ERROR(R)
RND:	ADD B,W
	ROTC W,-22
	MOVEI Q,5
RND1:	MOVE N,B(X)
	MUL N,CON4(R)
	ADDM N+1,C(X)
	AOJE X,RND2(R)
	MOVNI X,1
	TRNE B,1
	SKIPL C
	MOVEI X,0
	EXCH A,C
RND2:	SOJG Q,RND1(R)
	POPJ P,

CON1:	555555555555
CON2:	361275431652
CON3:	612754316523
CON4:	5*5*5*5*5*5*5*5*5*5*5*5*5*5*5
GO4:	CAIE C,"/"		;SLASH?
	JRST GOL(R)		;NO.
	TLO F,L.SLA		;YES. MARK SWITCH COMING
	JRST GOL(R)		;RETURN TO SCAN
GO6:	SKIPE W			;NO PUNCTUATION. NAME TYPED?
	MOVEM W,FNAME(R)		;YES. STORE NAME
	JRST GO7(R)		;GO CHECK PUNCTUATION
;HERE WHEN COMMAND STRING SUCCESSFULLY READ. DO THE JOB.

DO:	PUSHJ P,CRLF(R)		;SIGNAL STARTING I/O
	LDB A,[POINT 6,SWITCH(R),5](R)	;GET FIRST CHARACTER
	JUMPE A,RUN(R)		;NO SWITCH MEANS LOAD AND RUN
	CAIN A,"L"-40		;LOAD COMMAND?
	JRST LOAD(R)		;YES.
	CAIN A,"D"-40		;DUMP COMMAND?
	JRST DUMP(R)
IFCPU(KS)<
	CAIN	A,"S"-40	;SENSE SWITHCH COMMAND?
	JRST	SENSET(R)	;YES.
>;END IFCPU(KS)
	CAIN A,"G"-40		;GO COMMAND?
PROGSA:	JRST NOSA(R)	;YES, IF NOT SPECIFIED ADR, GIVE BELL
				; ***LH CHANGED TO JRST, RH TO ADR***
	CAIL A,"0"-40		;NUMERIC?
	CAILE A,"7"-40		; OCTAL, THAT IS,
	JRST BADSW(R)		;NO OTHERS IMPLEMENTED
	MOVE W,N		;MOVE STARTING ADDRESS TO W
STARTQ:	HRLI	A,GO+CODSIZ+100(R)	;END OF BOOTS
	HRRI	A,SAXBAS
	BLT	A,SAXBAS+37	;RESTORE SA-10 BASE WORDS
	HRLI W,(JRST)		;CHANGE OPCODE TO JRST
	MOVEM W,PROGSA(R)		;SAVE THE STARTING ADDRESS
	TRNE F,R.STRT		;LOAD OR START?
	JRST 0(W)		;START
	JRST REGO(R)		;JUST LOAD. GO GET ANOTHER COMMAND


;LOAD AND RUN COMMANDS

LOAD:	TRZA F,R.STRT		;LOAD BUT DON'T START PROGRAM
RUN:	TRO F,R.STRT		;LOAD AND START PROGRAM
	MOVE A,SYSTEM(R)	;DEFAULT READ-FILE NAME
	SKIPE FNAME(R)		;NAME SUPPLIED?
	JRST LDRN(R)		;YES.
	MOVEM A,FNAME(R)	;NO. PLUG IN DEFAULT.
	MOVEI A,DEFMON(R)	;GET ADR OF DEFAULT MON MSG
	PUSHJ P,OUTMSG(R)	;TYPE MSG
LDRN:	PUSHJ P,LOOK(R)		;TRY TO FIND FILE
	JRST NOFIL(R)		;NOT THERE. FAIL.
				;SUCCESS. FALL INTO RFILE
;HERE WHEN FILE FOUND. FIRST RIB FOR FILE IS IN CORE.

RFILE:	SETZB Q,40		;CLEAR CORE BEFORE READING FILE
				;AND INITIALLY NO WORDS IN DATA BUFFER
	MOVE A,BLTXWD(R)		; ..
	BLT A,CLRTOP(R)		;CLEAR UP TO BASE OF THIS PROGRAM
	SETZM	GO+CODSIZ+100(R)	;CLEAR SAXBAS SAVE AREA ABOVE BOOTS
	HRLI	A,GO+CODSIZ+100(R)	;START OF AREA
	HRRI	A,GO+CODSIZ+101(R)	
	BLT	A,GO+CODSIZ+137(R)
RFILL1:	PUSHJ P,RWORD(R)		;READ A POINTER OR JRST WORD
	SKIPL M,W		;WHICH IS IT?
	JRST STARTQ(R)		;TRANSFER WORD
RFILL2:	PUSHJ P,RWORD(R)		;READ A WORD OF DATA
	PUSHJ	P,CHKADR(R)	;IN SA-10 AREA?
	JRST	SPARRD(R)	;YES
	MOVEM W,1(M)		;STORE IT IN CORE
RFILL3:	AOBJN M,RFILL2(R)		;COUNT THE CORE POINTER.
	JRST RFILL1(R)		;IT RAN OUT. GET ANOTHER.

;SUBROUTINE TO READ A DATA WORD FROM THE FILE.

RWORD1:	MOVE Q,DBUFP(R)		;PREPARE TO COUNT DATA WORDS
	ADDI Q,(R)		;RELOCATE
RWORD:	JUMPGE Q,RWNXTB(R)		;NEED ANOTHER PAGE?
	MOVE W,0(Q)		;NO. GET A WORD.
	AOBJN Q,.+1(R)		;COUNT IT.
	POPJ	P,		;RETURN FROM RWORD
RWNXTB:	PUSHJ P,GTDATA(R)		;NO. READ NEXT DATA PAGE, IF ANY
	JRST RDER(R)		;ERROR RETURN FROM GTDATA
	JRST RWORD1(R)		;READ FROM THIS PAGE
SPARRD:	ADD	M,R
	MOVEM	W,GO+CODSIZ+101-SAXBAS(M); STORE IN SAVE AREA FOLLOWING BOOTS
	SUB	M,R	;RESTORE R
	JRST	RFILL3(R)

CHKADR:	PUSH	P,M		;SAVE M
	HRRZS	M
	CAIL	M,SAXBAS-1
	CAILE	M,SAXBAS+36
	AOS	-1(P)
	POP	P,M
	POPJ	P,
;HERE TO WRITE OUT CORE ON AN EXISTING FILE

DUMP:	MOVE A,CRASH(R)		;DEFAULT FILE NAME
	SKIPN FNAME(R)		;NAME ALREADY SET?
	MOVEM A,FNAME(R)	;NO. USE DEFAULT
	PUSHJ P,LOOK(R)		;TRY TO FIND THE FILE.
	JRST NOFIL(R)		;CANT FIND IT
	SKIPN STRING(R)		;FROM COMMAND?
	JRST DUMP0(R)		;NO
	HRRZ A,RBUF+RIBEXT(R)
	JUMPN A,DUMP0(R)	;HAS ACCESS DATE CHANGED?
	SETZM STRING(R)		;NO, ABORT AUTO RELOAD
	MOVEI A,NOTDMP(R)
	JRST ERROR(R)		;WITH AN ERROR MESSAGE
DUMP0:	SETZB Q,LENGTH(R)	;SET TO RECORD LENGTH WRITTEN
	MOVEI M,FIRSTW-1	;AND CORE ADDRESS COUNTER
DUMPL2:	HRRZS X,M		;START OF A PAGE
DUMPL1:
IFCPU (<KI,KL>)<
	CAIL	X,SAXBAS-1	;SA-10 BASE AREA?
	CAILE	X,SAXBAS+36
	JRST	DUMPL4(R)
	MOVE	A,X
	ADD	A,R
	SKIPN	GO+CODSIZ+101-SAXBAS(A)
	JRST	DUMP1(R)
	JRST	DUMPL5(R)
DUMPL4:	>;END IFCPU (<KI,KL>)
	SKIPN 1(X)		;THIS WORD ZERO IN CORE?
	JRST DUMP1(R)		;YES. SEE IF END OF A PAGE.
	CAIGE X,CLRTOP+2001(R)	;LOOKED AT ALL OF CORE?
DUMPL5:	AOJA X,DUMPL1(R)	;NO. COUNT PART OF THIS PAGE, LOOK ON.
DUMP1:	MOVEI W,0(M)		;END OF PAGE. IS PAGE EMPTY?
	SUBI W,0(X)		;START MINUS END OF BLK
	JUMPE W,DUMP2(R)	;JUMP IF PAGE EMPTY
	HRL M,W			;MAKE -COUNT,,START-1 FOR COUNTER
	MOVE W,M		;AND FOR DATA IN FILE
	PUSHJ P,WWORD(R)	;WRITE IT OUT AS DATA
DUMPL3:
IFCPU (<KI,KL>)<
	PUSHJ	P,CHKADR(R)
	JRST	SPARWT(R)
>;END IFCPU (<KI,KL>)
	MOVE W,1(M)		;GET THE WORD FROM CORE
DUMPL6:	PUSHJ P,WWORD(R)	;OUTPUT TO FILE
	AOBJN M,DUMPL3(R)	;OUTPUT ALL OF PAGE
DUMP2:	CAIGE X,CLRTOP+2001(R)	;CONSIDERED ALL OF CORE?
	AOJA M,DUMPL2(R)	;NO. MOVE ON.
	MOVSI	W,(HALT)	;YES, APPEND TERMINATOR
	PUSHJ P,WWORD(R)	;WRITE OUT THIS WORD
	JUMPL Q,.-1(R)		;IF MORE TO GO IN PAGE, WRITE AGAIN
	SKIPN	RBUF+RIBRIB(R)	;CURRENT RIB IS PRIME RIB?
	JRST	DUMP3(R)	;YES.
	MOVE	RET,PRMRIB(R)	;NO, GET THE
	PUSH	P,LENGTH(R)	;
	PUSHJ	P,GETRIB(R)	;PRIME RIB.
	JRST	WRTER(R)
	POP	P,LENGTH(R)	;
DUMP3:	MOVE A,LENGTH(R)	;NUMBER OF PAGES WRITTEN
	LSH	A,11		;CONVERT TO WORDS
	MOVEM A,RBUF+RIBSIZ(R)	;SAVE IN RIB
	HLLZS RBUF+RIBEXT(R)	;SET A 0 ACCESS DATE
	MOVE	RET,PRMRIB(R) ;GET LOCATION OF RIB
	PUSHJ P,UNISEL(R)	;SET FOR PROPER PAGE AND UNIT
	JRST REGO(R)		;GIVE UP ON ERROR
	MOVEI A,RBUF-1(R)
	PUSHJ P,WRPAG(R)	;WRITE IT OUT
	JFCL			;IGNORE ERROR
	JRST REGO(R)		;AND RESTART PROGRAM FOR NEXT COMMAND

;SUBROUTINE TO WRITE A WORD INTO THE FILE

WWORD:	JUMPL Q,WWORD1(R)	;NEED A NEW POINTER?
	MOVE Q,DBUFP(R)		;YES.  [-1000,,DBUF].
	ADDI Q,(R)		;RELOCATE
WWORD1:	MOVEM W,0(Q)		;PUT WORD INTO BUFFER
	AOBJN Q,CPOPJ(R)	;COUNT POINTER. DONE?
	PUSHJ P,WRDATA(R)	;YES. OUTPUT PAGE, IF POSSIBLE
	JRST WRTER(R)		;NO GOOD.
	AOS LENGTH(R)		;RECORD 1 PAGE WRITTEN
	POPJ	P,		;OK. RETURN.

SPARWT:	ADD	M,R
	MOVE	W,GO+CODSIZ+101-SAXBAS(M)	;GET DATA FROM SAVED AREA
	SUB	M,R
	JRST	DUMPL6(R)

;COMMAND TO SET SENSE SWITCHES

SENSET:
IFCPU(KS)< MOVEM N,KSSS4	;LOAD SENSE SWITCH WORD>
	JRST	REGO(R)		;PROCESS NEXT COMMAND
;SUBROUTINE TO LOOK FOR A FILE.
;EXPECTS PPN, FNAME, AND FEXT.

   ;FIRST TRY TO FIND THE FIRST UNIT IN THE STR.
LOOK:	SETZM	SLUNIT(R)	;START AT UNIT ZERO.
	PUSHJ	P,FNDUNI(R)	;TRY TO FIND FIRST UNIT.
	POPJ	P,		;COULDN'T FIND IT.

   ;FOUND A UNIT, NOW LOOK IN THE MFD FOR THE DESIRED UFD ENTRY.
	SKIPN	NAME,PPN(R)	;GET UFD NAME.
	MOVE	NAME,SYSPPN(R)	;IF NONE, ASSUME 1,4.
	MOVSI	EXT,(SIXBIT /UFD/);EXTENSION IS UFD.
	MOVE	RET,HMCMFD(R)	;RET PNTR OF MFD RIB.
	PUSHJ	P,SRCHFD(R)	;SEARCH FOR THE REQUESTED UFD
	POPJ	P,		;NOT THERE.

   ;FOUND THE UFD ENTRY, NOW LOOK IN THE UFD FOR THE FILE ENTRY.
	MOVE	NAME,FNAME(R)	;NAME OF FILE TO SEARCH FOR.
	MOVSI	EXT,(SIXBIT /SAV/) ;ASSUME SAV EXTENSION
	SKIPE	FEXT(R)		;UNLESS ONE SUPPLIED
	HLLZ	EXT,FEXT(R)	;IN WHICH CASE, USE IT.
	MOVE	RET,4(A)	;RET/ RET POINTER TO UFD.
	PUSHJ	P,SRCHFD(R)	;SEARCH FOR THE FILE IN THE UFD
	POPJ	P,		;NO SUCH FILE.
	MOVE	RET,4(A)	;RET/ RET PNTR TO FILE'S RIB.
	MOVEM	RET,PRMRIB(R)	;
	PUSHJ	P,GETRIB(R)	;GET THE RIB, CHECK IT.
	POPJ	P,		;NO LUCK. ASSUME FILE NOT THERE.
	HLLZ	A,RBUF+RIBEXT(R) ;GET THE EXTENSION FROM RIB.
	CAMN	A,EXT		;DESIRED EXTENSION?
	CAME	NAME,RBUF+RIBNAM(R) ;AND NAME?
	JRST	BADFIL(R)	;NO. QUIT, RIB BAD.
	JRST	CPOPJ1(R)	;SUCCESSFUL RETURN
;SUBROUTINE TO READ IN A RIB PAGE AND CHECK IT.
; EXPECTS RET/ RETRIEVAL PNTR TO RIB.
; SKIP RETURNS IF SUCCESSFUL, ELSE NON-SKIP RETURNS.

GETRIB:	PUSHJ	P,UNISEL(R)	;MAKE SURE ON RIGHT UNIT.
	POPJ	P,		;UNIT NOT THERE.
	MOVEI	A,RBUF-1(R)	;ADDRESS OF THE RIB BUFFER.
	PUSHJ	P,RDPAG(R)	;READ THE FILE'S RIB
	POPJ	P,		;COULDN'T READ IT
	MOVE	A,RBUF+PAGCOD(R) ;CHECK THE CODE WORD
	CAMN	RET,RBUF+PAGSLF(R) ;CHECK PHYSICAL ADDR OF RIB VS DATA
	CAIE	A,CODRIB	; ..
	JRST	BADFIL(R)	;NO GOOD.
	MOVEI	POSRET,RBUF+RIBSFS(R) ;PNTR TO RETRIEVAL PNTR.
	SKIPE	RBUF+RIBRIB(R)	;IS THIS A PRIME RIB?
	JRST	CPOPJ1(R)	;NO.
	MOVE	A,RBUF+RIBSIZ(R) ;YES.  LENGTH OF FILE.
	MOVEM	A,LENGTH(R)	;SAVE FOR EOF TEST
	MOVEI	POSRET,RBUF+RIBPFS(R)
	JRST	CPOPJ1(R)	;SUCCESSFUL RETURN
;SUBR TO SEARCH A UFD FOR FILE & EXT.
; EXPECTS RET/ RETRIEVAL PNTR TO RIB OF THE UFD.
; ON SUCCESS, SKIP RETURNS WITH A/ ADDR OF FILE ENTRY IN BUFFER.

SRCHFD:	LDB	A,RBYPNO(R)	;THE PAGE TO READ RIB FROM HAD
	JUMPE	A,BADDSK(R)	;BETTER NOT BE PAGE ZERO.
	PUSHJ	P,GETRIB(R)	;GET THE RIB.
	POPJ	P,		;CAN'T READ IT.
	PUSHJ	P,HASH(R)	;COMPUTE HASH NUMBER FOR FILE.
	ADDI	POSRET,-1(A)	;GET LOC OF RETRIEVAL PNTR.
SRCHF1:	PUSHJ	P,GTDATA(R)	;READ THIS PAGE OF THE UFD.
	POPJ	P,		;ERROR RETURN.
	MOVE	A,DBUFP(R)	;POINTER TO THE DATA BUFFER
	ADDI	A,(R)		;RELOCATE
SRCHF2:	SKIPN	(A)		;AT END OF DATA IN THIS PAGERST	SRCHF5(R)		;YES.
	CAME	NAME,0(A)	;NO.  GET A FILE NAME
	JRST	SRCHF3(R)	;NO MATCH. MOVE ON.
	HLLZ	B,1(A)		;CHECK THE EXTENSION
	CAMN	B,EXT		;IS IT RIGHT TOO?
	JRST	CPOPJ1(R)	;YES. GOOD RETURN, ANSWER AT (A)
SRCHF3:	ADD	A,[4,,4](R)
	AOBJN	A,SRCHF2(R)	;CHECK NEXT FILE IN UFD.

    ;HERE TO GO TO "NEXT" PAGE OF UFD.
SRCHF5:	SKIPN	POSRET,DBUF+UFDLNK(R)
	POPJ	P,		;NO "NEXT" PAGE.
	ADDI	POSRET,RBUF+RIBPFS(R) ;LOC OF NEXT PNTR TO POSRET.
	JRST	SRCHF1(R)		;(UFD RIBS ARE NOT EXTENDED.).




;SUBR TO RETURN THE HASH NUMBER IN A, GIVEN THE FILENNAME
;IN NAME.

HASH:	MOVE	A,NAME
	TLZ	A,(1B0)
	PUSH	P,B
	HLRZ	B,HMCHSH(R)
	IDIVI	A,(B)
	MOVEI	A,1(B)
	POP	P,B
	POPJ	P,
;SUBR TO GET CORRECT UNIT FROM RETRIEVAL POINTER IN RET.

UNISEL:	LDB	A,RBYUNI(R)	;A/ UNIT NUMBER.
	CAMN	A,HMCLUN(R)	;ALREADY AT THIS UNIT?
	JRST	CPOPJ1(R)	;YES. NO NEED TO CHANGE UNITS
	MOVEM	A,SLUNIT(R)	;NO. NEED TO FIND IT.
	PUSH	P,RET		;SAVE THE RETRIEVAL PNTR.
	PUSHJ	P,FNDUNI(R)	;FIND THE UNIT
	SOS	-1(P)		;NOT THERE. SET FOR NON-SKIP RETURN.
	POP	P,RET		;RESTORE RETRIEVAL POINTER.
	JRST	CPOPJ1(R)	;AND SKIP RETURN.




;SUBROUTINE TO READ NEXT PAGE OF DATA INTO DBUF.
; EXPECTS POSRET TO BE ADDR OF NEXT RETRIEVAL POINTER.

GTDATA:	SKIPGE	LENGTH(R)	;ANY DATA LEFT?
	POPJ	P,		;NO.
	MOVNI	A,1000		;SEE IF ANY LEFT
	ADDB	A,LENGTH(R)	;COUNT FILE SIZE DOWN
	PUSHJ	P,GETRET(R)	;SELECT NEXT DATA PAGE OF FILE
	POPJ	P,		;NONE LEFT.
	MOVEI	A,DBUF-1(R)	;SELECT DATA BUFFER
	PJRST	RDPAG(R)	;READ THE PAGE AND RETURN
				; SKIP RETURN IF NO ERROR
;SUBROUTINE TO GET NEXT RETRIEVAL POINTER.
; EXPECTS POSRET TO BE THE ADDRESS OF THE NEXT PNTR.
; NON-SKIP RETURNS IF ERROR, ELSE SKIP RETURNS WITH THE
; RETRIEVAL PNTR IN RET AND POSRET ADJUSTED TO THE NEXT PNTR
; LOCATION (MAY BE EO RIB).

GETRET: CAILE	POSRET,RBUF+RIBLST(R) ;AT END OF THIS RIB?
	JRST	GETRT4		;YES.
GETRT2:	SKIPE	RET,(POSRET)	;NO.  PNTR IS EOF?
	TLNE	RET,RBINDX	;NO, ALSO NO INDX PAGES ALLOWED.
	POPJ	P,		;FAIL.
	JUMPL	RET,GETRT3(R)	;JUMP IF SPARE RIB PNTR.
	TLNN	RET,RBREAL	;REAL BIT ON?
	POPJ	P,		;BAD PNTR.
	PUSHJ	P,UNISEL(R)	;
	POPJ	P,		;
	AOJA	POSRET,CPOPJ1(R)	;YES, GOOD POINTER.

    ;HERE IF SAW SPARE RIB PNTR.  GET THE SPARE RIB.
GETRT3:	TLZ	RET,RBSPAR	;
	PUSHJ	P,GETRIB(R)	;GET THE SPARE RIB.
	POPJ	P,		;BAD.
	JRST	GETRT2(R)	;CONTINUE.

    ;HERE FROM EO RIB.  BACK TO HIGHER LEVEL.
GETRT4:	SKIPN	RET,RIBRIB+RBUF(R) ;BAD RIB STR IF PRIME RIB.
	POPJ	P,		;
	PUSH	P,RIBRPS+RBUF(R) ;SAVE POSITION IN HIGHER RIB.
	PUSH	P,LENGTH(R)	;
	PUSHJ	P,GETRIB(R)	;TRY TO GET HIGHER RIB.
	POPJ	P,		;FAILED.
	POP	P,LENGTH(R)	;
	POP	P,POSRET	;GOT HIGHER RIB.
	ADDI	POSRET,RBUF(R)	;
	AOJA	POSRET,GETRET(R) ;GO LOOK AT IT.
;ROUTINE TO FIND A PARTICULAR LOGICAL UNIT IN THE STRUCTURE.
; EXPECTS UNIT NO. WRS STRUCTURE IN SLUNIT.
;SKIP RETURN IF FOUND.

FNDUNI:
	SETZM	TTYPE(R)	;CLEAR SEARCH TEMPS
	MOVEI	K,1
IFCPU(<KI,KL>)< MOVEM K,CHNMRK(R)	;BIT FLAG FOR CHAN, SET TO FIRST
>;END IFCPU(KI)
FNDUL3:	SETZM	TCHAN(R)
FNDUL1:	SETZM	TUNIT(R)	; ..
FNDUL2:	MOVE	K,TTYPE(R)	;GET KONTROLLER TYPE
	MOVE	N,TUNIT(R)	;AND UNIT NUMBER
	MOVE	C,TCHAN(R)	;CHANNEL NUMBER FOR SA-10
	PUSHJ	P,HOME(R)	;TRY TO READ ITS HOME PAGE
	JRST	FNDUNX(R)	;NO GOOD. ON TO NEXT.
	MOVE	A,HMCSNM(R)	;FOUND THIS UNIT. IS IT
	MOVE	B,HMCLUN(R)	;THE DESIRED ONE?
	CAMN	A,STRNAM(R)	;CHECK AGAINST DSKB AND
	CAME	B,SLUNIT(R)	;SUPPLIED UNIT NO.
	JRST	FNDUNX(R)	;NO GOOD. ON TO NEXT.
	JRST	CPOPJ1(R)	;CORRECT. SKIP RETURN.

FNDUNX:	AOS	A,TUNIT(R)	;COUNT TO NEXT UNIT ON KONTROLLER
IFCPU(<KI,KL>)<
	CAIL	K,SAXTYP	;SA-10 KONTROLLER?
	JRST	FNDUL4(R)	;YES. DIFFERENT THINGS TO CHECK
	CAIG	A,SAUNMX	;MAX NO. OF SA-10 UNITS?
	JRST	FNDUL2(R)	;NO
	MOVE	A,CHNMRK(R)
	LSH	A,1
	MOVEM	A,CHNMRK(R)	;NEXT CHANNEL
	AOS	A,TCHAN(R)	;ADVANCE CHANNEL
	CAIG	A,SACHMX	;LAST CHANNEL?
	JRST	FNDUL1(R)	;NO. TRY THIS ONE
	JRST 	FNDUL5(R)	;YES. TRY NEXT SA-10
>;END IFCPU(<KI,KL>)
FNDUL4:	CAIG	A,UNIMAX	;TOO BIG?
	JRST	FNDUL2(R)	;NO. GO CHECK THIS ONE
FNDUL5:	AOS	A,TTYPE(R)		;YES. COUNT TO NEXT TYPE OF KONTROLLER
	CAIG	A,TYPMAX	;ALL OF THOSE GONE BY?
	JRST	FNDUL3(R)	;NO. TRY THIS ONE.
	POPJ	P,		;ALL TRIED. GIVE FAIL RETURN.
;ROUTINE TO DETERMINE WHETHER A UNIT EXISTS, AND IF SO, TO READ
;ITS HOME PAGE INTO THE DATA BUFFER, CHECK IT, AND THEN SAVE
;THE LOCS OF INTEREST IN IT.

;CALLING SEQUENCE:
;K/	KONTROLLER TYPE INDEX
;N/	UNIT NUMBER, 0-7
;C/     SA-10 CHANNEL NUMBER
;	PUSHJ P,HOME
;	NOT THERE RETURN
;	OK RETURN

;AT THIS POINT, ANY NEEDED UNIT PARAMETERS ARE SAVED, SUCH AS R.TYPE
HOME:	MOVEM N,CUNIT(R)	;SAVE CURRENT UNIT NUMBER
	MOVEM K,CTYPE(R)	;AND KONTROLLER TYPE
	MOVEM	C,CCHAN(R)
	MOVEI C,UNIINI(R)	;ABS ADR OF INI TABLE BASE(ARG FOR SETCHN)
	TLO C,K			;SET INDEX FIELD FOR RELOCATION BY K(KONT. TYPE)
	LDB A,[POINT 7,@C,9](R)	;KONTROLLER DEVICE CODE FROM INI TABLE
	TRZ F,R.KDEV		;CLEAR KONTROLLER FIELD
	TRO F,(A)		;SET KONTROLLER FIELD
	MOVE	RET,HOME1(R)	;WANT TO READ FIRST HOME PAGE
	MOVEI A,DBUF-1(R)	;BUFFER FOR TEST I/O
	PUSHJ P,SETCHN(R)	;SET UP CHANNEL COMMAND LIST
				; AND CALL INITIALIZE KONT. ROUTINE
	POPJ	P,		;ERROR. NOT THERE.
HOM1:	MOVEI A,DBUF-1(R)	;GET HOME PAGE INTO DATA BUFFER.
	PUSHJ P,RDPAG(R)	;TRY TO READ THE HOME PAGE
	JRST HOM2(R)		;CAN'T READ THAT ONE
	MOVE A,DBUF+PAGCOD(R)	;GET THE CODE WORD
	CAIN A,CODHOM		;IS IT RIGHT?
	SKIPE DBUF+HOMREF(R)	;AND NOT NEEDING REFRESHING?
	JRST HOM2(R)		;NO GOOD.
	MOVE	A,DBUF+HOMMFD(R) ;GOOD, SAVE LOCS OF INTEREST.
	MOVEM	A,HMCMFD(R)	;
	MOVE	A,DBUF+HOMHSH(R) ;
	MOVEM	A,HMCHSH(R)	;
	MOVE	A,DBUF+HOMLUN(R) ;
	MOVEM	A,HMCLUN(R)	;
	MOVE	A,DBUF+HOMSNM(R) ;
	MOVEM	A,HMCSNM(R)	;
	JRST CPOPJ1(R)		;OK RETURN.

HOM2:	CAMN	RET,HOME2(R)	;TRIED BOTH PAGES?
	POPJ	P,		;YES. GIVE FAIL RETURN
	MOVE	RET,HOME2(R)	;NO, TRY ANOTHER ONE.
	JRST HOM1(R)		;READ SECOND HOME PAGE

;INITIALIZE KONTROLLER ROUTINES (CONSO IRRELEVANT - USED TO GET DEVICE CODE

IFCPU(<KI,KL>)<
UNIINI:	CONSO	SAX1,SAXINI(R)
	CONSO	SAX2,SAXINI(R)
	CONSO DPC,DPCINI(R)	;FIRST DPC
	CONSO DPC2,DPCINI(R)	;SECOND DPC
>;END IFCPU(<KI,KL>)
IFCPU(KS)<
UNIINI:	CONSO 0,RMINI(R)	;ONE AND ONLY RH11C, ONLY THING TRIED ON KS.
>;END IFCPU(KS)
IFCPU(F3)<
UNIINI:	CONSO 0,APINI(R)
>;END IFCPU(F3)
TYPMAX==.-UNIINI-1		;MAX NUMBER OF KONTROLLERS
IFCPU(<KI,KL,KS>)<
UNIMAX==7			;MAX NUMBER OF UNITS ON A KONTROLLER
>;END IFCPU(<KI,KL,KS>)
IFCPU(F3)<UNIMAX==3>		;ONLY 4 UNITS ON AN F3
SAUNMX==77
SACHMX==3
IFCPU(<KI,KL>)<
;INITIALIZATION FOR PACKS

DPCINI:	MOVEI C,LOWCMD
	MOVEM C,DATAOW(R)	;A RANDOM READ BUT SETS CONI BITS
	DPB N,PDRIVE(R)		;SAVE FOR IO
	MOVE C,[DATAO DATAOW(R)](R)	;SET UP A DATAO TO PACKS
	PUSHJ P,IOXCT(R)		;DATAO ON RIGHT DEVICE
	PUSHJ P,IOWAIT(R)		;TIMEOUT OR DONE FLAG
	JUMPLE B,CPOPJ(R)		;TIMED OUT?
	MOVEI A,2000		;DRIVE NOT THERE?
	PUSHJ P,IOCNSZ(R)		; ..
	POPJ	P,		;NOT THERE. ERROR RETURN.
	JRST CPOPJ1(R)		;SUCCESS RETURN

IOWAIT:	SETOB A,B		;LOOK FOR ALL FLAG BITS
	PUSHJ P,IOCNSO(R)		;ANYTHING THERE?
	POPJ	P,		;NO SUCH DEVICE AT ALL
	MOVEI B,^D50000		;TIMEOUT
	MOVEI A,10		;DONE FLAG, ALL KONTROLLERS
	PUSHJ P,IOCNSO(R)		;LOOK FOR DONE
	SOJG B,.-2(R)		;NOT YET. COUNT DOWN AND LOOP
	POPJ	P,		;DONE OR TIMED OUT.
>;IFCPU(<KI,KL>) (SAVE SPACE ON KS10)


IFCPU(F3)<
;AMPEX/CDC TYPE DRIVE HANDLER FOR F3 PROCESSOR

RTYCNT==20000

DRVTYP==CDC
CDC==1
AMPEX==0

IFE DRVTYP-CDC,<
SPT==^D8		;SECTORS PER TRACK (DEPENDS ON HOW FORMATTED)
TPC==^D10		;TRACKS PER CYLINDER (NUMBER OF HEADS)
CPU==^D823-^D10		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>
IFE DRVTYP-AMPEX,<
SPT==^D8		;SECTORS PER TRACK
TPC==^D5		;TRACKS PER CYL (NUMBER OF HEADS)
CPU==^D815-^D5		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>;END IFN AMPEX
PPC==SPT*TPC			;PAGES PER CYLINDER
BPC==PPC*4			;BLOCKS PER CYLINDER
PPU==PPC*CPU			;PAGES PER UNIT
SPT==^D8				;SECTORS PER TRACK
BPT==SPT*^D4			;BLOCKS PER TRACK
USPR==^D17300	;MICROSECONDS PER REVOLUTION.

;DISK IOTS AND REGISTER BIT NAMES.
OPDEF RCMD	[715000000000]	;READ COMMAND REGISTER
	SUNT==1B0		;SELECTED UNIT NOT THERE (SELECT ERROR)
	SUWP==1B1		;SELECTED UNIT WRITE PROTECT
	SUNR==1B2		;SELECTED UNIT NOT READY
;---
	SUOC==1B3		;SELECTED UNIT ON CYLINDER
				; SHOULD ALWAYS BE SET EXCEPT AFTER RECAL UNTIL HEADS ALIGN
	SUSE==1B4		;SELECTED UNIT SEEK ERROR (DETECTED BY DRIVE)
				; RECAL MANDATORY AFTER THIS ERROR, FAULT CLEAR WILL NOT TURN THIS OFF.
	SUF==1B5		;SELECTED UNIT FAULT (DETECTED BY DRIVE)
;---
	SUA==1B6		;SELECTED UNIT ATTENTION
				; SET BY LEADING EDGE OF ON CYLINDER (BIT 3)
	HDECC==1B7		;ECC ERROR ON HEADER
	CI==1B8			;CONTROL IDLE (ONLY IF NO DATA XFER AND NO SEEKS OR RECALS GOING)
;---
	SECC==1B9		;SOFT ECC ERROR (NOT YET IMPLEMENTED IN F3 MICROCODE)
	HECC==1B10		;ECC UNRECOVERABLE ERROR

;FOLLOWING BITS ARE DETECTED BY CONTROLLER:
	ROE==1B11		;READ OVERRUN ERROR
;---
	WOE==1B12		;WRITE OVERRUN ERROR
	SOE==1B13		;SECTOR OVERRUN ERROR
	IPE==1B14		;INTERNAL PARITY ERROR (ONLY VALID IF AE, BIT 28, IS ZERO)
;---

;FOLLOWING ARE FROM LAST LCMD

	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH FC AND CF)
;---
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
;	19 UNUSED
;	20 UNUSED
;---
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
;---
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
;---
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)

;END OF FROM RCMD BITS
	AE==1B28		;ANY  ERROR (EXCEPT IPE, BIT 14)
	AA==1B29		;ANY UNIT ATTENTION
;---

;FROM LCMD
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE

	NA==1B31		;NOT ACTIVE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
;---
;BITS 33, 34 NOT IMPLEMENTED.

	MPE==1B35		;MEMORY PARITY ERROR
;---
OPDEF RMA	[716000000000]	;READ MEMORY ADDRESS
OPDEF RDA	[717000000000]	;READ DISK ADDRESS (IN PAGES)
	AMSUNI==^D3		;SIZE OF UNIT BYTE
	AMPUNI==^D6		;RIGHTMOST BIT
	ROTUNI==-<AMPUNI+1>	;NUMBER OF PLACES TO ROTATE TO GET UNIT FIELD IN
	AMSCYL==^D12
	AMPCYL==^D19
	AMSTRK==^D8
	AMPTRK==^D27
	AMSSEC==^D8
	AMPSEC==^D35
	LDAMSK==034000,,177400	;MASK FOR $0% AND $0O IN DDT
OPDEF RECC	[720000000000]	;READ CONTROL REGISTER
OPDEF LCMD	[721000000000]	;LOAD COMMAND REGISTER
	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH FC AND CF)
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
OPDEF LMA	[722000000000]	;LOAD MEMORY ADDRESS
OPDEF LDA	[723000000000]	;LOAD DISK ADDRESS
	SU==1B7			;SELECT UNIT
				;MUST BE CLEARED AND SET TO SELECT A UNIT.
OPDEF LECC	[724000000000]	;CLEARS ECC LOGIC, STARTS AND INITS CONTROL.
	SC==1			;START CONTROL
	IC==2			;INIT CONTROL (SEND BEFORE STARTING CMD)
OPDEF DCONO	[740000000000]	;CONO TO DISK CONTROL TO SET PI ASSIGNMENT
OPDEF DCONI	[741000000000]	;CONI FROM DISK CONTROL OPCODE
	DIDLE==10		;SET IF CONTROL IS IDLE
	DPIA==7B35		;PI ASSIGNMENT.
				;NOTE THAT NONZERO PI ASSIGNMENT SETS DIE (SEE LCMD)
OPDEF DCONSO	[742000000000]
OPDEF DCONSZ	[743000000000]

;ROUTINE TO START A FUNCTION UP ON CONTROL

DOKON:	LECC	[IC](R)		;INIT CONTROL
	LCMD	A		;DO THE COMMAND
	LECC	[SC](R)		;START CONTROLLER
	POPJ	P,		;AND RETURN.

CLRKON:	MOVE	A,[CF+FC](R)	;COMMAND FUNCTION FAULT CLEAR
DOWKON:	PUSHJ	P,DOKON(R)		;DO THE COMMAND AND THEN
WATKON:	MOVEI	B,RTYCNT	;NUMBER OF TIMES TO WAIT
	RCMD	A
	TLNN	A,(CI)		;CONTLOL IDLE YET?
	SOJG	B,.-2(R)		;NO
	JUMPG	B,CPOPJ1(R)	;JUMP IF IT WENT IDLE
	POPJ	P,		;DIDN'T.

APINI:	HRRZ	A,CUNIT(R)	;GET UNIT SELECTED
	ROT	A,ROTUNI
	LDA	A
	TLO	A,(<SU>)
	LDA	A
	PUSHJ	P,CLRKON(R)	;CLEAR OUT CONTROL
	  JFCL			;IGNORE ERROR FOR NOW
	RCMD	A		;GET STATUS
	TLNE	A,(<SUNT!SUNR>) ;NON-SKIP IF NOT THERE OR NOT READY
	POPJ	P,
	MOVE	A,[CF+FC+RECAL](R)	;DO A RECAL
	PUSHJ	P,DOWKON(R)
	  POPJ	P,		;DO RECAL NOW.
	MOVSI	A,^D10		;WAIT A LONG TIME
	RCMD	B
	TRNN	B,NA		;WAIT TILL NOT ACTIVE
	SOJG	A,.-2(R)
	JUMPE	A,CPOPJ(R)	;GO IF TIMED OUT
	RCMD	A		;GET STATUS BITS AGAIN
	TRNN	A,AE		;ERROR RETURN IF ANY ERRORS
	AOS	(P)		;NO ERRORS
	POPJ	P,

;HERE TO READ OR WRITE ONE PAGE WITH A CONTAINING THE BLOCK NUMBER
; AND CHNCMD CONTAINING THE IOWD

APWRIT:	SKIPA	C,[WRITE](R)
APREAD:	MOVEI	C,READ
	ROT	A,-^D2		;CONVERT TO PAGES
	TLNE	A,600000	;MAKE SURE WAS REQUESTING AN EVEN PAGE BOUDARY
	HALT	.(R)
	PUSH	P,C		;SAVE COMMAND
	IDIVI	A,PPC		;GET A/CYL, B/PAGES INTO CYL
	IDIVI	B,SPT		;GET B/TRACK, C/SECTOR IN TRACK
	DPB	B,[POINT AMSTRK,C,AMPTRK](R)
	DPB	A,[POINT AMSCYL,C,AMPCYL](R)
	MOVE	A,CUNIT(R)
	ROT	A,ROTUNI	;GET UNIT NUMBER INTO POSITION
	TDO	C,A
	LDA	C
	TLO	C,(<SU>)
	LDA	C
	HRRZ	C,CHNCMD(R)
	ADDI	C,1		;GET ACTUAL ADDRESS
	LMA	C
	HLRE	C,CHNCMD(R)
	MOVMS	C
	CAIE	C,1000
	HALT	.(R)		;MAKE SURE REQUESTING EXACTLY A PAGE
	PUSHJ	P,CLRKON(R)	;CLEAR OUT CONTROL
	  JFCL			;IGNORE FOR NOW
	POP	P,A		;GET COMMAND INTO A
	PUSHJ	P,DOKON(R)	;START THE TRANSFER
	MOVSI	A,^D10		;TIMEOUT IS ABOUT 10 SECS.
	RCMD	B
	TRNN	B,NA		;WAIT TILL NOT ACTIVE
	SOJG	A,.-2(R)
	JUMPE	A,CPOPJ(R)	;TIMED OUT, ERROR
	RCMD	A		;OK, GET COMMAND
	TRNE	A,AE		;MAKE SURE NO ERROR BITS ON
	POPJ	P,		;SORRY.
	TLNE	A,(<IPE>)	;THIS IS ONLY VALID IF AE OFF
	POPJ	P,		;NO GOOD.
	HRRZ	B,CHNCMD(R)
	RMA	A
	TLZ	A,777774	;CLEAR UNUSED BITS
	SUBI	A,1(B)		;GET NUMBER OF WORDS XFERRED
	CAIE	A,1000
	POPJ	P,		;WRONG COUNT
	JRST	CPOPJ1(R)	;OK, SUCCESSFUL XFER.
>;END IFCPU (F3)
IFCPU(KS)<
;RM03 HANDLER.  INSERTED HERE BECAUSE PEOPLE WANT EDIT PAGE
; BOUNDARIED PRESERVED.
RMINI:	MOVEI A,CS2CLR		;CLEAR CONTROLLER
	WRIO A,@CS2ADR(R)
	MOVEI A,CS1TRE
	WRIO A,@CS1ADR(R)
	HRRZ A,CUNIT(R)		;SELECT UNIT
	WRIO A,@CS2ADR(R)
	RDIO A,@DSADR(R)
	RDIO B,@CS2ADR(R)	;EXISTS?
	TRNE A,DSMOL
	 TRNE B,CS2NED
	  POPJ P,
	MOVEI A,F.RIP		;YES, READ IN PRESET
	WRIO A,@CS1ADR(R)
	MOVEI A,DSDRY
	MOVEI C,^D100000
	TION A,@DSADR(R)
	 SOJG C,.-1(R)
	JUMPGE C,CPOPJ1(R)
	POPJ P,

RMREAD:	SKIPA C,[F.RD](R)
RMWRIT:	 MOVEI C,F.WD
	PUSH P,X
	RDIO X,@DTADR(R)
	ANDI X,2
	LSH X,-1		;0:RM03; 1:RP06.
	MOVEI B,^D148
	CAIE X,0
	 MOVEI B,^D380
	IDIVI A,(B)
	WRIO A,@DCADR(R)
	MOVE A,B
	MOVEI B,^D30
	CAIE X,0
	 MOVEI B,^D20
	IDIVI A,(B)
	DPB A,[100500,,B](R)
	WRIO B,@DAADR(R)
	HRRZ B,CHNCMD(R)	;SET VIRTUAL ADDRESS FROM IOWD
	AOJ B,
	SETZ A,
	ROTC A,-9
	ROT A,13
	WRIO A,@BAADR(R)
	TRO B,PGRFST+PGRVAL	;SET PHYSICAL ADDRESS
	WRIO B,@PGRADR(R)
	AOJ B,
	WRIO B,@PG1ADR(R)
	MOVNI A,2000		;SET WORD COUNT
	WRIO A,@WCADR(R)
	WRIO C,@CS1ADR(R)	;START TRANSFER
	MOVEI C,^D100000	;WAIT UNTIL DONE
	RDIO B,@CS1ADR(R)
	TRNN B,CS1RDY
	 SOJG C,.-2(R)
	POP P,X
	JUMPLE C,CPOPJ(R)
	TRNN B,CS1TRE		;ANY ERRORS?
	 JRST CPOPJ1(R)
	POPJ P,
>;END IFCPU(KS)
;ROUTINE TO READ A PAGE FROM THE DEVICE KONTROLLER AND UNIT IN
;CTYPE AND CUNIT INTO THE BUFFER AT (A)+1, FROM RETRIEVAL PNTR
;IN RET. SKIP RETURN IF SUCCESSFUL, NON-SKIP IF ANY HARDWARE ERRORS

RDPAG:	PJSP C,SETCHN(R)	;SETUP CHANNEL CONTROL WORD AND CALL
				; PROPER READ ROUTINE BELOW DEP. ON TYPE

IFCPU(<KI,KL>)<
	Z	SAXRED(R)	;SA-10
	Z	SAXRED(R)	;SECOND SA-10
 SAXTYP==.-RDPAG-1
	Z DPCRED(R)		;RP10
	Z DPCRED(R)		;SECOND RP10
>;END IFCPU(<KI,KL>)
IFCPU(KS)< Z RMREAD(R)		;RM03>
IFCPU(F3)< Z APREAD(R)>		;AMPEX/CDC

;ROUTINE TO WRITE A PAGE AT LOGICAL PAGE NUMBER IN RET,
; ON DEVICE IN CTYPE AND CUNIT, WRITING FROM BUFFER AT (A)+1
; SKIP RETURN IF SUCCESSFUL.

WRDATA:	PUSHJ	P,GETRET(R)	;GET NEXT PAGE OF FILE
	POPJ	P,		;NOT POSSIBLE
	MOVEI A,DBUF-1(R)	;SET TO WRITE FROM DATA BUFFER
				;FALL INTO WRPAG
WRPAG:	PJSP C,SETCHN(R)	;SETUP CHANNEL CONTROL WORD AND CALL
				; PROPER WRITE ROUTINE BELOW DEP. ON TYPE

IFCPU(<KI,KL>)<
	Z	SAXWRI(R)	;SA-10
	Z	SAXWRI(R)	;SECOND SA-10
	Z DPCWRI(R)		;RP10
	Z DPCWRI(R)		;SECOND RP10
>;END IFCPU(<KI,KL>)
IFCPU(KS)< Z RMWRIT(R)		;RM03>
IFCPU(F3)< Z APWRIT(R)>		;AMPEX/CDC

;SUBROUTINE TO SETUP CHANNEL, THEN DISPATCH TO DEVICE DEP ROUTINE
;CALL:	MOVEI A,ABS. ADR. OF FIRST DATA WORD-1
;	MOVE RET, RETRIEVAL PNTR
;	HRRI C,ABS. ADR. OF FIRST WORD IN DISPATCH TABLE
;	PUSHJ P,SETCHN
;	ERROR RETURN
;	OK RETURN

SETCHN:	HRLI A,-1000		;MAKE IOWD FOR THE CHANNEL
	MOVEM A,CHNCMD(R)	;STORE IT.
	ADDI A,1
IFCPU(<KI,KL>)<
	HRRM	A,SACADR(R)	;FOR SA-10S
;*HACK*	ADDI	A,200
	HRRM	A,SACADR+OFFONE(R)
;*HACK*	ADDI	A,200
	HRRM	A,SACADR+OFFTWO(R)
;*HACK*	ADDI	A,200
	HRRM	A,SACADR+OFFTRE(R)
	MOVEI A,CHNCMD(R)	;SET UP LOW CORE FOR CHANNEL
	MOVEM A,LOWCMD		; ..
>;END IFCPU(<KI,KL>)
	SETZM CHNCMD+1(R)	;END OF CHANNEL CMD LIST
	LDB	A,RBYPNO(R)	;GET A/ PAGE NO.
	JUMPE	A,BADDSK(R)	;NOT ZERO.
;*HACK*	LSH	A,2		;CONVERT TO BLOCK NUMBER.
	MOVE K,CTYPE(R)		;WHAT KONTROLLER?
	ADDI C,(K)		;FORM ABS. ADR. OF PROPER DISPATCH TABLE ENTRY
	PJRST @(C)		;CALL DISPATCH ENTRY AS A SUBROUTINE AND RETURN

IFCPU(<KI,KL>)<
;READ AND WRITE ROUTINES FOR THE DISK PACKS

DPCWRI:	PUSHJ P,DPCCNV(R)		;SET UP ADDRESSING, SEKK.
	POPJ	P,		;ERROR
	MOVEI A,O.WRIT		;SET FOR WRITE OPERATION
	JRST DPCOPR(R)		;AND GO DO IT.

DPCRED:	PUSHJ P,DPCCNV(R)		;CONVERT AND SEEK FOR PAGE
	POPJ	P,		;BAD PAGE NUMBER
	MOVEI A,O.READ		;SET OPERATION TO READ PAGE
	JRST DPCOPR(R)		;READ THE PAGE (CHANNEL ALL SET)

DPCCNV:	IDIVI A,^D10		;GET SECTOR NUMBER
	DPB B,PSEC(R)		;SAVE IT
	IDIVI A,^D20		;GET SURF AND CYL
	DPB B,PSURF(R)		;STORE SURFACE
	DPB A,PCYL(R)		;STORE CYLINDER
	MOVE N,CUNIT(R)		;CURRENT UNIT
	DPB N,PDRIVE(R)		;STORE THAT TOO.
	CAILE A,^D405		;MAKE SURE CYLINDER IS ON DISK
	JRST BADDSK(R)		;TOO BIG A RET
	LSH A,-^D8
	DPB A,PCYL2(R)		;EXTRA CYL BIT
	MOVEI A,O.SEEK		;MAKE DISK SEEK TO THE CYLINDER
DPCOPR:	DPB A,OPPNT(R)		;STORE THE OPERATION
	MOVE C,[DATAO CLRATN(R)](R)	;SET UP DATAO
	PUSHJ P,IOXCT(R)		;DO DATAO WITH RIGHT DEVICE
	HRRI C,DATAOW		;NEW ADDRESS(R IN INDEX FIELD ALREADY)
	XCT C			;SEND THIS WORD TOO

;SUBROUTINE TO WAIT FOR IO AND CHECK ERRORS

DPCWAT:	PUSHJ P,IOWAIT(R)		;WAIT FOR DONE FLAG OR TIMEOUT
	JUMPLE B,CPOPJ(R)		;IF TIMED OUT, GIVE UP.
	MOVEI A,177720		;ANY ERRORS?
				;FALL INTO IOCNSZ(SKIP RETURN IF GOOD)

IOCNSZ:	SKIPA C,[CONSZ 0(A)](R)	;SET UP I/O INSTR.
IOCNSO:	MOVSI C,(CONSO (A))	;SETUP IO INSTR.
IOXCT:	DPB F,[POINT 7,C,9](R)	;PUT IN I/O DEVICE FIELD
	XCT C			;DO THE IO
	POPJ P,			;NO SKIP RETURN
>;END IFCPU(<KI,KL>)
CPOPJ1:	AOS (P)			;SKIP RETURN
CPOPJ:	POPJ P,			;NO SKIP RETURN

IFCPU(<KI,KL>)<
IOCNI:	SKIPA C,[CONI X](R)	;FOR SA-10
IOCNO:	MOVSI C,(CONO (A))
	JRST IOXCT(R)
; READ AND WRITE TO 3330

SAXWRI:	MOVEI	B,SAXWCD
	SKIPA
SAXRED:	MOVEI	B,SAXRCD

    ;STORE READ OR WRITE CODE.
	DPB	B,[POINT 8,SACCMD(R),15](R);
	DPB	B,[POINT 8,SACCMD+OFFONE(R),15](R)
	DPB	B,[POINT 8,SACCMD+OFFTWO(R),15](R)
	DPB	B,[POINT 8,SACCMD+OFFTRE(R),15](R)

    ;SET HEAD, CYLINDER, AND RECORD NOS.
	PUSHJ	P,SETLOC(R)	;SET HEAD/CYLINDER/RECORD NOS.

    ;STORE DEVICE ADDRESS IN COMMANDS.
	MOVE	A,CUNIT(R)	;UNIT NUMBER
	ADDI	A,SAUN0		;COMPUTE DEVICE ADDRESS
	MOVE	B,[POINT 8,SACLST(R),23](R) ;B HOLDS PNTR.
	MOVEI	C,4		;4 LOOPS.
SETLC5:	DPB	A,B		;DEV ADDR TO SEEK.
	HRRI	B,2(B)		;
	DPB	A,B		;DEV ADDR TO SEARCH ID EQUAL.
	HRRI	B,3(B)		;
	DPB	A,B		;DEV ADDR TO READ/WRITE CMD.
	HRRI	B,2(B)		;
	SOJG	C,SETLC5(R)	;LOOP FOR 4 BLOCKS (=1 PAGE.).

    ;POINT SEARCHS AND SEEKS.
	MOVEI	B,SACLST+1(R)	;
	MOVEI	A,SACARG(R)
	HRRM	A,(B)		;SEEK ARG LIST ADDRESS
	HRRM	A,2(B)		;SRCH ARG LIST ADDRESS
	MOVEI	A,SACAR1(R)	;
	HRRM	A,OFFONE(B)	;
	HRRM	A,OFFONE+2(B)	;
	MOVEI	A,SACAR2(R)	;
	HRRM	A,OFFTWO(B)	;
	HRRM	A,OFFTWO+2(B)	;
	MOVEI	A,SACAR3(R)	;
	HRRM	A,OFFTRE(B)	;
	HRRM	A,OFFTRE+2(B)	;

    ;POINT THE TICS BACK TO THE SEARCH ID EQUALS.
	MOVEI	A,SACIDE(R)	;ADDR OF SEARCH COMMAND
	HRRM	A,SACTIC(R)	;TO TIC
	MOVEI	A,SACIDE+OFFONE(R) ;
	HRRM	A,SACTIC+OFFONE(R) ;
	MOVEI	A,SACIDE+OFFTWO(R) ;
	HRRM	A,SACTIC+OFFTWO(R) ;
	MOVEI	A,SACIDE+OFFTRE(R) ;
	HRRM	A,SACTIC+OFFTRE(R) ;

	MOVE	A,CCHAN(R)	;GET CHANNEL NUMBER
	LSH	A,2		;*4
	MOVE	B,CTYPE(R)	;WHICH SA-10?
	LSH	B,4
	ADDI B,SAXBAS(A)	;NOW HAVE BASE FOR THIS CHANNEL
	MOVEI	A,SACLST(R)
	HRLI	A,200000	;TIC COMMAND
	MOVEM	A,(B)		;STORE IN BASE AREA
	PUSH	P,X		;SAVE SOME MORE REGISTERS
	PUSH	P,W
	MOVE A,CHNMRK(R)	;GET FLAG FOR THIS CHANNEL
	TDNE A,CHNFLG(R)	;DO WE KNOW ITS NOT THERE
	JRST STRT4(R)		;YES, GIVE UP ON IT
	MOVEI	A,1
	MOVN	N,CCHAN(R)
	LSH	A,6(N)		;SET UP BIT FOR STATUS FLAG FOR THIS CHANNEL
	MOVNS	N		;RECOVER CHANNEL NUMBER
	LSH N,3		;CONVERT TO CORRECT POSITION FO CONO
	HRL N,A		;SAVE STATUS BIT IN LEFT HALF
RESTRT:	PUSHJ P,IOCNI(R)	;READ STATUS
	JUMPE	X,STRT4(R)	;JUMP IF SA-10 IS MISSING
	MOVEI A,640(N)
	PUSHJ P,IOCNO(R)	;SET STATUS BIT
	MOVEI A,440(N)
	PUSHJ P,IOCNO(R)	;AND GO FLAG
	MOVEI A,600(N)
	PUSHJ P,IOCNO(R)	;AND THEN CLEAR STATUS
	MOVEI	W,^D100000
	HLRZ A,N	;GET STATUS BIT
	PUSHJ P,IOCNSO(R)	;AND DO THE CONSO
	SOJG	W,.-1(R)
	JUMPE	W,STRT4(R)	;JUMP ON TIMEOUT
	MOVE	X,1(B)		;GET STATUS
	TLNE X,(1B2)
	JRST STRT4A(R)	;SELECT ERROR
	MOVEI A,400000	;IN CASE WE HAVE TO RESET
	TLNN	X,BSY
	JRST	STRT3(R)	;NOT BUSY
	TLNE	X,SM		;BUSY+STATUS MODIFIER?
	JRST	STRT2(R)	;YES
	TLNE	X,CUE
	JRST	RESTRT(R)	;JUMP ON BUSY+CU END
STRT3:	TLNN	X,CE+DE		;CHANNEL END AND DEVICE END?
	JRST	STRT5(R)	;NO. ERROR
	TLNN	X,175114	;OTHER ERRORS?
	AOSA	-2(P)		;NO. SKIP RETURN
STRT5:	PUSHJ P,IOCNO(R)	;A IS LOADED WITH BIT 18
	JRST	STRRET(R)
STRT4:	MOVE A,CHNMRK(R)
	IORM A,CHNFLG(R)	;MARK CHANNEL NOT THERE
STRT4A:	MOVE A,TUNIT(R)
	TRO A,7	;FORCE TO TOP OF MULT OF 10
	MOVEM	A,TUNIT(R)	;SET TO LAST UNIT
STRRET:	POP	P,W
	POP	P,X
	POPJ	P,
STRT2:	MOVEI A,600(N)
	PUSHJ P,IOCNO(R)	;CLEAR STATUS
	HLR A,N		;NO WAIT FOR STATUS BIT
	PUSHJ P,IOCNSO(R)
	JRST	.-1(R)
	MOVE	X,1(B)
	TLNE	X,CUE
	JRST	RESTRT(R)
	JRST	STRT2(R)

;LITTLE SUBR TO SET CYLINDER, HEAD, AND RECORD NUMBER.
SETLOC:	PUSH	P,N		;
	PUSH	P,A		;
	MOVEI	C,10		;
	MOVEI	N,SACARG(R)	;
	SETZM	(N)		;
	ADDI	N,1		;
	SOJG	C,.-2(R)	;
	MOVEI	N,SAYCC(R)	;
SETLC2:	IDIVI	A,SABPC		;COMPUTE CYLINDER NO. (A)
	IDIVI	B,SABPT		;HEAD NO. TO B, SECT NO. TO C
	ADDI	C,1		;COMPUTE RECORD NUMBER
	DPB	A,(N)		;STORE CYLINDER NUMBER
	DPB	B,1(N)		;STORE HEAD NUMBER
	DPB	C,2(N)		;STORE RECORD NUMBER
	ADDI	N,3		;
	CAIL	N,PTREND(R)	;DONE?
	JRST	SETLC4(R)	;YES.
	AOS	A,(P)		;NO, NOT YET.
	JRST	SETLC2(R)	;
SETLC4:	POP	P,A		;
	POP	P,N		;
	POPJ	P,		;RETURN.
; SA-10 COMMAND LIST AND DEFINITIONS

SACLST:
SACIDE==SACLST+2
SACTIC==SACIDE+2
SACCMD==SACTIC+1
SACADR==SACCMD+1

OFFONE==7
OFFTWO==16
OFFTRE==25
REPEAT 4,< BYTE	(8)72,7		;SEEK.
	BYTE	(12)-6
	BYTE	(8)73,61	;SEARCH ID EQUAL.
	BYTE	(12)-5
	XWD	200000,0	;TIC.
	BYTE	(8)160		;READ OR WRITE.
;*HACK*	BYTE (12) -200
	BYTE (12) -1000	;*HACK* FULL PAGE
	0		;*HACK* END OF COMMAND LIST
>
	0
SAYCC:	POINT	32,SACARG(R),31
	POINT	16,SACARG+1(R),15
	POINT	8,SACARG+1(R),23

	POINT	32,SACAR1(R),31
	POINT	16,SACAR1+1(R),15
	POINT	8,SACAR1+1(R),23

	POINT	32,SACAR2(R),31
	POINT	16,SACAR2+1(R),15
	POINT	8,SACAR2+1(R),23

	POINT	32,SACAR3(R),31
	POINT	16,SACAR3+1(R),15
	POINT	8,SACAR3+1(R),23
PTREND:

SABPT=^D18
SABPC=<^D18*^D19>&777774
 SABPT=^D7	;*HACK* 7 PAGES PER TRACK
 SABPC=^D7*^D30	;*HACK* 210 PAGES PER CYLINDER
SAXWCD=5
SAXRCD=6
SAUN0=300
SAX1=274
SAX2=400
BSY=(BYTE (8)0,20)
CUE=(BYTE (8)0,40)
SM=(BYTE (8)0,100)
CE=(BYTE (8)0,10)
DE=(BYTE (8)0,4)

SAXINI=CPOPJ1
>;END IFCPU(<KI,KL>)
SAXBAS=300

;TTY I/O SUBRS

CRLF:	MOVEI C,215		;CR, EVEN
	PUSHJ P,TYO(R)		;TYPE IT.
	MOVEI C,12		;LF, EVEN
IFCPU(<KI,F3>)<
TYO:	DATAO TTY,C		;SEND OUT CHAR
	CONSZ TTY,20		;WAIT FOR IDLE
	JRST .-1(R)		; ..
	POPJ	P,		;DONE.
>;END IFCPU(<KI,F3>)

IFCPU(KL)<
TYO:	ANDI	C,377
	MOVEI	C,<.DTMTO>B27(C)	;MAKE COMMAND	
	MOVEM	C,DTECMD
	CONO	DTE,TO11DB	;RING DOORBELL
	ANDI	C,377
	PUSH	P,C
	SETZ	C,
	EXCH	C,DTEMTD	;WAIT FOR OUTPUT DONE
	JUMPE	C,.-1(R)
	POP	P,C
	POPJ	P,

SPCINI:	CONO	PAG,		;EPT IN PAGE 0
	SETZM	DTEMTI
	SETZM	DTEMTD
	SETZM	DTEF11
	MOVEI	A,<.DTMMC>B27
	MOVEM	A,DTECMD	;GIVE "ENTER 2NDARY PROTOCOL" CMD
	MOVEI	A,10		;TRY 8 TIMES
SPCIN1:	CONO	DTE,TO11DB	;RING THE DOORBELL
	MOVSI	C,10		;WAIT FOR RESPONSE
	SKIPN	DTEFLG
	SOJG	C,.-1(R)
	SOJGE	C,SPCIN2(R)	;DONE
	SOJGE	A,SPCIN1(R)	;TRY AGAIN MAYBE
	HALT
SPCIN2:	SETZM	DTEFLG
	POPJ	P,
>;END IFCPU(KL)

IFCPU(KS)<
TYO:	TRO C,CTYOV
	MOVEM C,CTYOWD
	WRAPR LP.SSF+LP.CIN
	SKIPE CTYOWD
	 JRST .-1(R)
	TRZ C,CTYOV
	POPJ P,
>;IFCPU(KS)


PROMPT:	ASCIZ /BOOTS:/
DEFMON:	ASCIZ /LOADING (SYS)SYSTEM.SAV/
NOSAM:	ASCIZ /NO START ADRESS/
BADSWM:	ASCIZ /BAD SWITCH/
NOFILM:	ASCIZ /NO FILE/
RDERM:	ASCIZ /READ ERR OR EOF/
WRTERM:	ASCIZ /WRITE ERR OR EOF/
BADFLM:	ASCIZ /BAD FILE/
BADDKM:	ASCIZ /DISK SICK/

NOTDMP:	ASCIZ /PREVIOUS CRASH NOT SAVED/

NOSA:	MOVEI A,NOSAM(R)
	JRST ERROR (R)

BADSW:	MOVEI A,BADSWM(R)
	JRST ERROR(R)

NOFIL:	MOVEI A,NOFILM(R)
	JRST ERROR (R)

RDER:	MOVEI A,RDERM(R)
	JRST ERROR(R)

WRTER:	MOVEI A,WRTERM(R)
	JRST ERROR(R)

BADFIL:	MOVEI A,BADFLM(R)
	JRST ERROR(R)

BADDSK:	MOVEI A,BADDKM(R)
ERROR:	PUSHJ P,OUTMSG(R)
	JRST REGO(R)

OUTMSG:	HRLI A,(POINT 7,0)
	PUSHJ P,CRLF(R)
OUTMS1:	ILDB C,A
	JUMPE C,CPOPJ(R)
	PUSHJ P,TYO(R)
	JRST OUTMS1(R)

;KS10 PARAMETERS.
IFCPU(KS)<
;DEVICE REGISTER BIT ASSIGNMENTS.  SEE USER MANUAL FOR SEMANTICS.
DEFINE FOO(BAR,ZORP,BAZ,S)
<ZOT==100000
IFNB <S>,<ZOT==S>
BAR'ADR: 1,,ZORP
IRP BAZ,<BAR'BAZ==ZOT
ZOT==ZOT/2
>>

FOO (CS1,776700,<SC,TRE,MCPE,,DVA,PSEL,A17,A16,RDY,IE,F4,F3,F2,F1,F0,GO>)
    ;FUNCTION CODES + GO BIT.
	F.RIP==21
	F.DC==11
	F.RD==71
	F.WD==61
FOO (CS2,776710,<DLT,WOE,UPE,NED,NEM,PGE,MXF,MDPE,OR,IR,CLR,PAT,BAI,U2,U1,U0>)
FOO (DS,776712,<ATA,ERR,PIP,MOL,WRL,LBT,PGM,DPR,DRY,VV,,,,,,OM>)
FOO (WC,776702)
FOO (AS,776716)
FOO (BA,776704)
FOO (DA,776706)
FOO (DT,776726)
FOO (DC,776734)
FOO (PGR,763000,<REV,DIS,FST,VAL>,400000)
FOO (PG1,763001)
FOO (UA1,763100,<TO,BMD,PE,NED,HI,LI,PWR,DTR,INI>,400000)

CTYIWD==32	;CTY INPUT WORD
CTYIV==1B27	;ON IFF INPUT IS VALID
CTYOWD==33	;CTY OUTPUT
CTYOV==1B27	;ON IFF OUTPUT IS VALID

;KS10 I/O INSTRUCTIONS
OPDEF TION [711000000000]
OPDEF RDIO [712000000000]
OPDEF WRIO [713000000000]
OPDEF WRAPR [700200000000]
OPDEF WREBR [701200000000]
OPDEF WRUBR [701140000000]
OPDEF WRPI [700600000000]

LI.ACO==177
LI.CLR==1B23
LI.COF==1B26
LI.PIF==1B27
LP.CIN==1B25
LP.SSF==1B23

KSSS4==24	;ADDR OF SENSE SWITCH WORD
>;IFCPU(KS)


SYSPPN:	XWD 1,4			;DEFAULT PROJ-PROG
SYSTEM:	SIXBIT /SYSTEM/		;DEFAULT FILENAME
CRASH:	SIXBIT /CRASH/		;DEFAULT DUMP NAME
DBUFP:	XWD -1000,DBUF		;POINTER TO DATA PAGE
BLTXWD:	XWD 40,41		;FOR CORE-CLEARING
SIXPTR:	XWD 440600,W		;POINTER FOR SIXBIT NAME
STRING:	POINT 7,CMDSTR(R)
CMDSTR:	BYTE (7) "/","D",15,15,0

IFCPU(<KI,KL>)<
PDRIVE:	POINT 3,DATAOW(R),5	;DRIVE NUMBER FOR DATAO
PCYL:	POINT 8,DATAOW(R),13	;CYLINDER NUMBER FOR DATAO
PCYL2:	POINT 1,DATAOW(R),19
PSURF:	POINT 5,DATAOW(R),18	;SURFACE NUMBER FOR DATAO
PSEC:	POINT 4,DATAOW(R),23	;SECTOR NUMBER FOR DATAO
OPPNT:	POINT 3,DATAOW(R),2	;OPERATION FOR DATAO
CLRATN:	XWD 500000,776		;CLEAR ATTENTION FLAGS.
DATAOW:	EXP LOWCMD		;LOW CORE ADR FOR DF10
>;END IFCPU(<KI,KL>)
STRNAM: SIXBIT /DSKB/
RBYUNI:	POINT 8,RET,^D16
RBYPNO: POINT ^D19,RET,^D35
HOME1: XWD RBREAL,LPNHOM
HOME2: XWD RBREAL,LP2HOM
U(PRMRIB)
U(HMCHSH)
U(HMCLUN)
U(HMCMFD)
U(HMCSNM)
U(DEVICE)
U(FNAME)
U(FEXT)
U(PPN)
U(SWITCH)
U(CTYPE)
U(CCHAN)
U(CUNIT)
U(TTYPE)
U(TCHAN)
U(TUNIT)
U(SLUNIT)
U(LENGTH)
IFCPU(<KI,KL>)<
;KEEP THE FOLLOWING FOUR PAIRS OF WORDS TOGETHER.
UU(SACARG,2)
UU(SACAR1,2)
UU(SACAR2,2)
UU(SACAR3,2)
U(CHNFLG)
U(CHNMRK)
>;END IFCPU(<KI,KL>)

LIT

UU(PDL,30)
UU(CHNCMD,2)

UU(ZZMAX,0)
MBOOTL==BOOTSA-.	;MINUS LENGTH OF BOOTS CODE-WRITTEN BY WTBOOTS
IFE WTBOOT,<		;START ADR. IF ABSOLUTE PAPER TAPE
	END JRST GO
>
IFN WTBOOT,<		;NO START ADR. IF LOADED WITH WTBOOT
IFG <.-GO-CODSIZ>,<
PRINTX BOOTS TOO BIG
>
	BLOCK	CODSIZ-<.-GO>	;PAD TO PROPER SIZE
IFCPU(<KI,KL,F3>)<
;ROUTINE TO WRITE BOOTS ONTO THE FIRST SIXTEEN UNITS OF DSKB.

LICTAB==-20		;LICENSE GETTAB TABLE
LICOPR==100000		;OP LIC
.STTYO==0		;SETUUO FUNCTION TO WRITE TO OPR
CTYSTR:	IFCPU(KI) <ASCIZ /
KI/>
	IFCPU(KL) <ASCIZ /
KL/>
	IFCPU(F3) <ASCIZ /
F3/>

DMPIT:
;*;	MOVE	1,[BOOTSA,,335000]	;*HACK*
;*;	BLT	1,337000	;*HACK* RELOCATE TO HIGH CORE
;*;	JRST	335000		;*HACK* START THERE

	RESET
	HRROI	1,LICTAB
	GETTAB	1,
	 MOVEI	1,0
	TRNN	1,LICOPR	;DOES USER HAVE OP LIC?
	JRST	[OUTSTR [ASCIZ /
OP LIC REQUIRED/]
		 EXIT]
	MOVE	1,[.STTYO,,CTYSTR]	;TELL OPR THAT
	SETUUO	1,			; NEW BOOTS HAS BEEN
	 JFCL
	MOVE	1,[.STTYO,,[ASCIZ/ BOOTS WRITTEN TO HOME FILE
/]]					; WRITTEN TO DISK
	SETUUO	1,
	 JFCL

	MOVEI	5,17		;NUMBER OF UNITS.
WRTLP:	MOVE	1,[SIXBIT/DSKB/]
	MOVEM	1,INITLC
	MOVE	4,[POINT 6,INITLC,^D23]
	MOVE	2,5
	IDIVI	2,10
	JUMPE	2,WRTLP3
	ADDI	2,'0'
	IDPB	2,4
WRTLP3:	ADDI	3,'0'
	IDPB	3,4
	INIT	1,17
INITLC:	0
	0
	JRST	WRTLP4
	USETO	1,BOOTBK
	OUTPUT	1,COM
WRTLP4:	SOJGE	5,WRTLP
	EXIT
>;END IFCPU(<KI,KL,F3>)

COM:	IOWD	CODSIZ,GO
	0

IFCPU(KS)<
;ROUTINE TO BUILD BOOTS.DMP FILE.

DMPIT:	RESET
	OUTSTR	[ASCIZ /
KS BOOTS WRITTEN TO BOOTS.DMP/]
	OPEN [	17
		SIXBIT/DSK/
		0]
	 JRST 4,.
	ENTER [	SIXBIT/BOOTS DMP/
		0
		0]
	 JRST 4,.
	OUTPUT COM
	EXIT

>;END IFCPU(KS)

	END DMPIT
        ì