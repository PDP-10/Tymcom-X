TITLE	FILIO	DISK SERVICE ROUTINE

	STOPCD(,ENTRY,FILIO)	;All stopcodes in FILIO start with "SWP"

	ND	FTDPAG,0	;Must match COMMOD,RMXKON,APXKON,BPXKON
IF2,<IFE FTDPAG,<PRINTX :    FTDPAG set for blocks>
     IFN FTDPAG,<PRINTX :    FTDPAG set for pages>>
IFCPU (<KI,KL>),<SAXN==1>	;SA10 on KI and KL
IFNCPU(<KI,KL>),<SAXN==0>	;Not on KS or F3

IOSUPR==100000	;SUPER USETI/USETO DONE ON THIS CHAN


;THE FOLLOWING S BITS ARE DEFINED IN COMMON.MOD
;BECAUSE THEY WANT TO BE IN THE SAME POSITION IN S AS IN RIB STATUS WORD
;IOSHRE==100	;HARD READ ERROR ENCOUNTERED
;IOSHWE==200	;HARD WRITE ERROR ENCOUNTERED
;IOSSCE==400	;SOFTWARE CHECKSUM ERROR ENCOUNTERED
;IOSERR==IOSHRE+IOSHWE+IOSSCE
;IOSMER==-IOSERR
DEFINE DSKOFF <WRPI DSKPIF>
DEFINE DSKON  <WRPI DSKPIN>


EXTERN ALR620,CPOPJ,CPOPJ1,DEVBLK,DSKPIF,DSKPIN
EXTERN INLMES,IOSHRE,IOSHWE,PRNAME
EXTERN PTNUNI,PTSUNI,PWAIT1
EXTERN REMLST,SATONC,SYSUNI,UNTTBL,PIOMOD

EXTERN PGYPNO,PGYFPL,PGYBPL,PGYSTS,PGPDER,PGPDTE,PGYSIO,PGYADR
EXTERN PGYDRT,PGYUNI
IFCPU (KL),<EXTERN PGYCSH>

EXTERN RBYUNI,RBYPNO,RBREAL,RBINDX,RBSPAR


EXTERN KONPOS,KONRED,KONWRT,KONRCL,KONSTP,KONCPY
EXTERN KONCHN,KONLTM,KONPTR,KONADD,KONFIN,CHNBSY
EXTERN KONOFS,KONHRD,KONSFT,KONIBM,KONRBL

EXTERN UNISTS,UNICHN,UNPOFL
EXTERN UNISTT,UNIERR,UNYPGL,UNYPAC
EXTERN UNIKON,UNISTR,UNITAL,UNISYS
EXTERN UNIDES,UNINAM,UNYLUN,UNISOF,UNIHBN
EXTERN UNIBRC,UNIDRC,UNIMSC,UNIUSC,UNISBN,UNIICT,UNIBWC,UNIDWC
EXTERN UNIHCT,UNISCT,UNICYL,UNIONC
EXTERN UNIHNG,UNISDI,UNIECT,UNIRCT,UNIRC1
EXTERN UNIHDI,UNPFUS,UNIDIR,UNIFCT,UNYTIM
EXTERN UNICDA,UNYRCL,UNYRRT,UNYRTY,UNPDEV,UNYOCV,UNYRTO,UNYRCO
IFE FTDPAG,<EXTERN UNIBLK,UNYBPY,UNYPPL>
IFN FTDPAG,<EXTERN UNIPAG,UNYPPY>
IFN SAXN,<EXTERN UNIOLV,UNPRRS>

EXTERN KCMOFL,KCMFUS,KCMRER,KCMERR,KCMDTA,KCMIOS,KCMPOS

EXTERN LSTLST,PGYPNO,PGYLST,PGYSOP,SID.N,SOD.N,SPR.N
EXTERN MAXPCB,FINPCB,MINPCB,MEMSZP
EXTERN PICLK,JOB,CLKFLG

EXTERN ADRDUM
EXTERN CTLFND,PGYLMA,%SAT.C

IFCPU (KL),<EXTERN CSUCNT,CSVCNT,CSHSAV>
REPEAT	0,<
NOTE ABOUT STATES OF CHANNELS, KONTROLLERS, UNITS, FILES:

			C	J	U	F
IDLE		I	I	I	I	I
SEEK WAIT	SW			SW
SEEK		S			S
POSITION WAIT	PW			PW	PW
POSITION	P			P	P
TRANSFER WAIT	TW			TW	TW
TRANSFER(BUSY)	T1 OR B	B	B	T1	T1

NOTE ABOUT QUEUES:
THERE ARE 2 QUEUES OF FILES
	SW/PW QUEUE FOR EACH UNIT
	TW QUEUE FOR CHANNEL
A FILE IS ONE AND ONLY ONE OF THE FOLLOWING CONDITIONS:WITH RESPECT TO QUEUES
	A.THE ONLY FILE IN SW/PW QUEUE FOR A UNIT (UNIT IN SW STATE)
	B.ONE OF PERHAPS MANY FILES IN PW QUEUE FOR A UNIT(UNIT IN PW,P,TW,OR T1 STATE)
	C.ONE OF PERHAPS MANY IN TW QUEUE FOR CHANNEL(CHAN AND KONTROL IN B STATE)
	D.NONE OF THE ABOVE (FILE IN I,P, OR T1 STATE)

NOTE:	#MEANS INSTRUCTION IS EXECUTED WITH ALL DISK PI CHANNELS OFF
	%MEANS INSTRUCTION IS EXECUTED WHILE JOB HAS CB RESOURCE
	*MEANS INSTRUCTION MAY BE EXECUTED AT INTERRUPT LEVEL
	(TO SAVE TYPING USED ONLY FOR INSTRUCTIONS NOT IN INTERRUPT MODULE ITSELF)

THE FOLLOWING TECO MACRO WILL PRODUCE A LISTING OF ONLY THE SUBROUTINE
NAMES AND COMMENTS PRIOR TO THEM:
ERDEV1:FILIO.MAC$EWDEV2:FILIO.SUB$
<_;SUBROUT$;0L.U1  !NTST! :S:$"GA ONTST$'.U20L1A-59"E LONTST$' Q2JI

$Q1,.PW 0,.K>EF

>
SUBTTL	UUO interface -- SEEK uuo
;UUO LEVEL IO (F ALREADY SET TO DDB FOR FILE DOING IO)

;HERE TO START A SEEK  (CALLI 56)

UUOSEK::PUSHJ	P,SEKPTR	;GET POINTER TO NEXT BLOCK IN T2
	  POPJ	P,		;CAN'T DO IT
	SKIPL	KONPOS(J)	;DOES CONTROLLER POSITION?
	SKIPE	T1,UNISTS(U)	;YES. IS UNIT IDLE?
	 POPJ	P,		;NO. IGNORE SEEK REQUEST
	DSKOFF			;SINCE WE ARE DIDDLING QUEUES
	DPB	T1,UNYPAC	;ALSO PAGE POINTER (0 FROM ABOVE)
IFE FTDPAG,<
	MOVEM	T2,UNIBLK(U)	;Save desired block address
	LDB	T3,UNYBPY	;Convert to desired cylinder number
>
IFN FTDPAG,<
	LSH	T2,B2PLSH	;Convert blocks to pages
	MOVEM	T2,UNIPAG(U)	;Save desired page address
	LDB	T3,UNYPPY	;Convert to desired cylinder number
>
	IDIV	T2,T3		; (to see if SEEK needs to be done)
	CAMN	T2,UNICYL(U)	;ALREADY ON CYL?
	 PJRST	ONPOPJ		;YES, TURN ON PI AND GO
IFN SAXN,<
	SKIPE	UNIOLV(U)	;Is there an Other Logical Volume?
	SKIPN	@UNIOLV(U)	;Yes, is it busy?
	 JRST	ONPOPJ		;No, go ahead with this transfer
>  ;End IFN SAXN
	MOVEI	T1,SWCOD	;SET TO SEEK WAIT
	MOVEM	T1,UNISTS(U)
	SKIPL	KONIBM(J)	;Disks on an IBM block mux channel?
	 JRST	UUOSK1		;No, start seek and then select best unit
	MOVEI	T1,SCOD		;For IBM disks on an SA-10, just seek
	MOVEM	T1,UNISTS(U)	; (there is no DF10 to worry about)
	AOS	UNIUSC(U)	;Count user seek
	PUSHJ	P,@KONPOS(J)	;Start seek to page in UNIPAG/UNIBLK
ONPOPJ:	DSKON
	POPJ	P,

UUOSK1:	PUSH	P,F		;Save F from IOSEL
	PUSHJ	P,IOSEL		;Do seeks for any on this kontroller
	POP	P,F
	JRST	ONPOPJ		;Turn on PI and go
;ROUTINE TO GET NEXT BLOCK FOR SEEK.
; CALL WITH DEVPOS(F) POINTING TO NEXT BLOCK,
; RETURNS WITH T2 NEXT ABSOLUTE BLOCK ON DISK,
; U AND J SETUP WITH UDB AND KDB. SKIP IF SUCCESSFUL.

EXTERNAL USETST,ATYBSZ,RBMASK,RELRIB,UNLFIL,RBYUNI
EXTERNAL DEVSUP,DEVPOS,DEVATB,DEVRET
EXTERNAL STRDDB,STRPPU,STRUNI,STRBTS,SRPNDS
EXTERNAL LOKUNM

SEKPTR:	MOVE	M,DEVPOS(F)	;GET NEXT BLOCK
	TLZ	M,(1B0)		;CLEAR POSSIBLE CHANGE FLAG.
	TLNE	S,IOSUPR	;SUPER I/O?
	 JRST	SEKPTS		;YES, DO IT DIFFERENTLY

	HRRZ	T2,DEVATB(F)	;GET ATB
	JUMPE	T2,CPOPJ	;CAN'T DO IT IF NO FILE.
	LDB	T1,ATYBSZ	;GET SIZE IN BLOCKS
	CAMLE	M,T1		;EOF?
	 POPJ	P,		;YES, CAN'T DO IT.
	ADDI	M,3		;ROUND UP TO NEAREST PAGE.
	LSH	M,B2PLSH	;CONVERT TO PAGES FOR USETST
	JUMPE	M,CPOPJ		;BETTER NOT BE PAGE 0 OF FILE
	PUSHJ	P,LOKUNM	;LOCK FILE UNMODIFIED.
	PUSHJ	P,USETST	;SETUP DEVRET
	  JRST	[MOVEM S,DEVIOS(F) ;STORE STATUS
		POPJ P,]
	MOVE	T2,@DEVRET(F)	;GET POINTER WE WORKED SO HARD FOR
	PUSH	P,T2		;SAVE T2 FROM THESE GUYS
	PUSHJ	P,RELRIB
	PUSHJ	P,UNLFIL	;RELEASE RIB AND FILE
	POP	P,T2		;RESTORE T2.
	TLNN	T2,RBREAL	;IS NEXT THING A HOLE?
	 POPJ	P,		;YES, ALL THAT FOR NOTHING.
	LDB	U,RBYUNI	;GET UNIT NUMBER
	MOVE	U,UNTTBL(U)	;GET UDB ADDRESS
	TLZ	T2,RBMASK	;GET RID OF XTRA BITS
	LSH	T2,P2BLSH	;CONVERT TO BLOCK
				;(ALWAYS OK TO POSITION TO 1ST BLOCK OF PAGE.)
	JRST	SEKPT1		;RETURN U AND J SET UP, T2 HAS PAGE #

;HERE IF IT WAS SUPER I/O

SEKPTS:	MOVE	T2,M		;GET BLOCK # IN CASE ITS A UNIT
	HRRZ	U,DEVSUP(F)	;MAYBE HE INITED UNIT
	JUMPN	U,SEKPT1	;IF SO, JUST USE DEVPOS (BLOCK # IN T2)
	MOVE	T1,M		;NO, MUST COMPUTE BLOCK WITHIN UNIT
	LSH	T1,B2PLSH	;CONVERT TO PAGES
PRINTF(<[SEKPTS+5: Check need to use DRBSTR instead of STRDDB]>)
	MOVEI	U,STRDDB	;Get current structure
PRINTF(<[SEKPTS+6: Uses STRPPU as divisor - all units must be same size!!!]>)
	IDIV	T1,STRPPU(U)	;GET UNIT # IN T1, PAGE # IN T2
	LSH	T2,P2BLSH	;CONVERT BACK TO BLOCKS
	MOVEI	U,STRUNI-UNISTR(U) ;START WITH THIS
	HLRZ	U,UNISTR(U)	;GET NEXT UNIT IN STR
	SOJGE	T1,.-1		;KEEP GOING TILL GET THE RIGHT ONE

SEKPT1:	MOVE	J,UNIKON(U)	;GET KDB ADDRESS
	JRST	CPOPJ1		;RETURN FROM SEKPTR WITH BLOCK # IN T2


SUBTTL	UUO interface -- read buffered log

IFE SAXN,<RRSETB==:CPOPJ> ;There is no buffered log on F3 or KS
IFN SAXN,< ;Read error log from disk control unit via SA10
RRSETB::DSKOFF
	SKIPE	UNISTS(U)	;Is unit doing anything?
	 JRST	RRSETF		;Yes, just set a flag and catch it later
	MOVEI	T1,RSCOD	;No, mark unit as busy reading sense bytes
	MOVEM	T1,UNISTS(U)
	PUSHJ	P,SETTIM
	PUSHJ	P,@KONRBL(J)	;Read buffered log (instead of latency routine)
	DSKON
	JRST	CPOPJ1		;Back to UUOCON

RRSETF:	MOVSI	T1,UNPRRS	;Flag to do RDRST later
	IORM	T1,UNIDES(U)
	DSKON
	JRST	CPOPJ1		;Back to UUOCON

;Here when unit is idle and UNPPRS was set (in both T1 and UNIDES)

RDRST:	ANDCAM	T1,UNIDES(U)	;Reset UNPRRS bit
	MOVEI	T1,RSCOD	;Set to read status wait
	MOVEM	T1,UNISTS(U)
	HRRZ	J,UNIKON(U)	;Just to make sure
	PUSHJ	P,SETTIM
	PUSHJ	P,@KONRBL(J)	;Read buffered log (instead of latency routine)
	JRST	UXPOPJ		;Don't start anything else on this channel
>  ;End IFN SAXN
SUBTTL	FILINT -- Interrupt handling module

COMMENT !
Called from device dependent interrupt routine (disk drivers)
T3 contains the DATAI (or fake DATAI) from the device
T2 contains the CONI (or fake CONI) from the device
T1 is the Kontroller CoMmunications word
  Bits 0-7 are attention bits (for DPXKON,RMXKON,APXKON)
  KCMPOS (1B7)  IBM disk controller gets position interrupt (BPXKON)
  KCMRER (1B8)  Recovered data error (corrected using ECC)
  KCMFUS (1B9)  File unsafe
  KCMERR (1B10) Unrecoverable error in data transfer
  KCMDTA (1B11) Successful data transfer (RH must be nonzero)
  KCMIOS (1B12) I/O select needed (internal to FILIO only)
  KCMOFL (1B13) Unit is off-line
        (17B17) unused
IFE FTDPAG,<Bits 18-35 contain the number of blocks transfered>
IFN FTDPAG,<Bits 18-35 contain the number of pages transfered>
The device driver sets J to Kontroller DB and U to Unit DB
!

FILINT::PUSH	P,T3		;Software generated DATAI
	PUSH	P,T2		;Software generated CONI
	PUSH	P,T1		;LH=error bits, RH=blocks or pages
	TLNE	T1,KCMOFL!KCMFUS
	 PUSHJ	P,SETOFL	;Set unit off-line
	TLNE	T1,776000!KCMPOS
	 PUSHJ	P,POSSAT	;Position interrupt (set KCMIOS if needed)
	TLNE	T1,KCMRER
	 PUSHJ	P,ERRRCV	;Recovered error (set KCMIOS if more to do)
	TLNE	T1,KCMDTA
	 PUSHJ	P,DTASAT	;Data transfer completed (errors possible)
	TLNE	T1,KCMIOS
	 PUSHJ	P,IOSEL		;Find next unit that needs to start I/O
	POP	P,T1
	POP	P,T2
	POP	P,T3
	POPJ	P,		;Back to BPXKON,APXKON,RMXKON interrupt routine
;Set unit off line - called with KCMOFL or KCMFUS set in T1
SETOFL:	MOVE	T2,UNISTS(U)
	CAIN	T2,CCOD		;Doing capacity test?
	 JRST	CPYOFL
	CAIE	T2,TCOD		;Was this unit in the middle of a transfer?
	 JRST	SETOF1		;If not, do not free KON and CHN
	PUSHJ	P,SETID2	;Set KON and CHN idle
	MOVSI	T1,KCMIOS	;
	IORB	T1,-1(P)	;Set IOS bit to restart the transfer
SETOF1:	MOVEI	T2,OWCOD
	MOVEM	T2,UNISTS(U)	;Waiting for on-line interrupt
	MOVSI	T2,UNPOFL
	TLNE	T1,KCMFUS
	 TLO	T2,UNPFUS
	IORM	T2,UNIDES(U)	;Remember off-line and possible unsafe
	HLLM	T2,LSTBDU	;Save last bad status
	HRRM	U,LSTBDU	; and unit
	MOVEI	T2,1
	DPB	T2,UNYTIM	;Set timer to go off now
	MOVE	T1,-1(P)	;Go get KMCIOS again
	POPJ	P,

LSTBDU:	0			;Last bad status and unit (for crash analysis)

CPYOFL:	HRROS	UNIONC(U)	;Negative to signify off-line
CPYFIN:	SETZM	UNISTS(U)	;End of capacity test, make idle
	PJRST	ZERTIM		;Clear hung timer and return
;Positioning done interrupt - Bits 0-7 set for non-IBM, KMCPOS for IBM disks
POSSAT:	PUSH	P,U		;Save unit of data transfer if any
	MOVSI	P2,776000	;Get just the attention bits
	AND	P2,-2(P)	; from device CONI
IFN SAXN,<
	TLNE	T1,KCMPOS	;Position done on an IBM disk?
	 TDZA	P2,P2		;Yes, zero P2 and got to POSTS1
	  TDZA	P4,P4		;No, zero P4 and go to POSTST
	   JRST	POSTS1		;U is already set up for IBM disk
>  ;End IFN SAXN
IFE SAXN,<SETZ	P4,>		;Clear offset
POSTST:	JFFO	P2,.+2		;Any attention bits left on?
	 JRST	POSDON		;No, finished
	LSH	P2,1(P3)	;Get rid of bit
	ADDB	P4,P3		;Set unit index
	SKIPN	U,@KONPTR(J)	;Doing I/O?
	 AOJA	P4,POSTST	;Extraneous interrupt, check next unit
POSTS1:	MOVE	T1,UNISTS(U)	;Get wait code
	XCT	PSTTBL(T1)	;Process position done interrupt
	AOJA	P4,POSTST	;Go do next one

PSTTBL:	PHASE	0
ICOD:!	SETOM	UNICYL(U)	;JUST MARK SO FORCES SEEK
PWCOD:!	SETOM	UNICYL(U)
PCOD:!	PUSHJ	P,POSFIN	;FINISHED A POSITION OPERATION
SWCOD:!	SETOM	UNICYL(U)
SCOD:!	PUSHJ	P,SEKFIN	;FINISHED A SEEK
RSCOD:!	PUSHJ	P,SEKFIN	;READ AND RESET BUFFERED LOG, TREAT LIKE SEEK
CWCOD::!SETOM	UNICYL(U)
CCOD::!	PUSHJ	P,CPYFIN	;CAPACITY TEST FINISHED
TWCOD:!	 STOPCD			;ONLY FIXED HEAD DISKS ARE IN TW
TWFCOD:!PUSHJ	P,RESEK		;MUST BE OFF THEN ON, RESET FOR POS
TCOD:!	SETOM	UNICYL(U)	;SHOULD HAVE BEEN AN OFF-LINE INT FIRST
RCOD:!	PUSHJ	P,RCLFIN	;FINISHED RECAL, SET TO POS
OWCOD:!	PUSHJ	P,UNIONL	;UNIT BACK ONLINE
VWCOD:!	PUSHJ	P,POSFIN	;Go set KCMIOS and restart logical volume
	DEPHASE

POSDON:	POP	P,U		;Restore pointer to UCB
	MOVE	T1,-1(P)	;Reset COM word
	POPJ	P,		;End of position done interrupt

SEKFN1:	SETOM	UNICYL(U)
	TDZA	T1,T1		;GO TO IDLE
POSFIN:	MOVEI	T1,TWFCOD	;BUT IF POS FINISHED, TO TWF
COMFIN:	MOVEM	T1,UNISTS(U)	;SET STATUS
	PUSHJ	P,ZERTIM	;Zero hung timer
	MOVSI	T1,KCMIOS
	IORM	T1,-3(P)	;NEED I/O SELECTION
	SKIPN	-1(P)
	HRRM	U,-1(P)		;SAVE UNIT IN CASE ONLY POS INTERUPT
	POPJ	P,

RESEK:
RCLFIN:	SETOM	UNICYL(U)	;MUST HAVE BEEN OFF-LINE
RCLFN2:	MOVEI	T1,PWCOD	;OR FINISHED RECAL, FORCE SEEK
	SKIPGE	KONIBM(J)	;If on-line or RECAL done on an IBM disk,
	 MOVEI	T1,TWFCOD	; set TWF to go to T (no seek wait for SA10)
	JRST	COMFIN

UNIONL:	 STOPCD (.+1,EVENT,UNIONL,PRTUNI,<Unit came on-line>) ;;UNIONL+0
	MOVSI	T1,UNPOFL!UNPFUS
	ANDCAM	T1,UNIDES(U)	;Clear off-line and unsafe bits
	LDB	T1,UNYPAC	;OTHER KIND OF WAITER
	JUMPN	T1,RCLFIN
	JRST	SEKFN1		;ELSE NO ONE WAITING, JUST SET IDLE

PRTUNI:	PUSHJ	P,INLMES##	;Routine for STOPCD(UNIONL)
	 ASCIZ	/Unit came on-line: /
	MOVE	T2,UNINAM(U)
	PJRST	PRNAME##	;CRLF is provided by stopcode processor

SEKFIN:	PUSH	P,P2		;NEED TO SAVE THIS AC
	PUSHJ	P,PIKPOS	;SEE WHAT POSITION NEED DOING
	  JUMPE	PG,SEKFN2	;NO REQUESTS, GO TO IDLE
	JUMPE	P2,SEKFN3	;NO POSITION NEEDED, TO TWF
	POP	P,P2
	JRST	RCLFN2		;GO TO PW

SEKFN2:	TDZA	T1,T1		;NO REQUEST, GO IDLE
SEKFN3:	MOVEI	T1,TWFCOD	;NO POSITION NEEDED, TO TWF
	POP	P,P2
	JRST	COMFIN
;Recoverable error interrupt - KCMRER is set
ERRRCV:	AOS	UNISCT(U)	;Call it a soft error
	PUSHJ	P,@KONSFT(J)	;Save error status if necessary
	MOVE	T2,-2(P)	;Device CONI
	MOVEM	T2,UNISOF(U)
	MOVE	T2,-3(P)	;Device DATAI
	MOVEM	T2,UNISDI(U)
	HRRZ	T2,-1(P)	;Get number of blocks or pages
IFN FTDPAG,<
	LSH	T2,P2BLSH	;Convert to blocks for UNISBN
>
	SUBI	T2,1		;Last block did not transfer OK
	MOVEM	T2,UNISBN(U)	;PUT THIS IN SOFT BLOCK FOR NOW
	LDB	PG,UNYPAC	;GET PAGE INFO POINTER
	LDB	T2,PGYPNO	;AND ADDRESS
	LSH	T2,P2BLSH	;CONVERT TO BLOCKS
	ADDM	T2,UNISBN(U)	;Disk block address of error
IFE FTDPAG,<
	LDB	T2,UNYPPL	;ALSO GET OFFSET
	ADDM	T2,UNISBN(U)	;FINISH SETTING BLOCK NUMBER
>
IFN FTDPAG,<
	LSH	T2,B2PLSH	;Convert back to page number
>
	POPJ	P,

;Data transfered interrupt - KCMDTA is set, RH must nonzero if KCMERR off

DTASAT:	LDB	PG,UNYPAC	;GET ACTIVE PAGE NUMBER
	LDB	S,PGYSIO	;MAKE SURE PAGE HAS I/O GOING
	SKIPN	S		;NO?
	 STOPCD (CPOPJ1,INFO,SWPNIO,,<Swap done: No I/O in progress>) ;;DTASAT+3
	LDB	S,PGYSOP
	JUMPE	S,DTAST2	;IN
	MOVSI	S,IO		;OUT
DTAST2:	TLNN	T1,KCMERR	;IS THERE AN ERROR?
	 JRST	DTAOK		;NO, TRANSFER IS OK
	MOVSI	T2,UNPDEV
	MOVEI	P3,IODERR
	TDNN	T2,UNIRCT(U)
	 MOVEI	P3,IODTER	;SET DATA OR DEVICE ERROR
	TRNE	S,IONRCK
	 JRST	DTAOK1		;IGNORE ERROR IF NO RETRY REQUESTED
	HRRZ	P4,-1(P)	;Get number of blocks or pages
IFN FTDPAG,<
	LSH	P4,P2BLSH	;Convert pages to blocks
>
	LDB	T2,PGYPNO	;Disk page number
	LSH	T2,P2BLSH	;Convert to disk block address
	ADD	P4,T2		;Block address where error was detected
IFE FTDPAG,<
	LDB	T2,UNYPPL
	ADD	P4,T2		;PLUS BLOCK WITHIN PAGE
>
	SUBI	P4,1		;Last block successfully transferred
DTAST3:	SKIPG	UNIRCT(U)	;IS THE ERROR THE FIRST ONE?
	 JRST	DTRSEC		;NO
	MOVEM	P4,UNISBN(U)	;SAVE SOFT BLOCK NUMBER
	MOVE	T2,-2(P)	;Device CONI
	MOVEM	T2,UNISOF(U)	;STORE THE SOFT ERROR STATUS
	MOVE	T1,-3(P)	;Device DATAI
	MOVEM	T1,UNISDI(U)
	SETZM	UNIECT(U)	;RESET ERROR COUNT
	MOVSI	T1,(1B0)
	IORM	T1,UNIRCT(U)	;AND RESET BIT 0 (NOT FIRST)
DTRSEC:	LDB	T1,UNYRTY	;CHECK NUMBER OF RETRYS REMAINING
	SOJGE	T1,DTRRTY	;GO RETRY
	LDB	T1,UNYRCL	;OUT OF RETRYS, TRY RECAL
	SOJGE	T1,DTRRCL
	LDB	T1,UNYOCV	;TRY OFFSET NEXT.
	SOJGE	T1,DTROFS
	MOVEM	P4,UNIHBN(U)	;SET HARD DATA ERROR BLOCK NUMBER
	MOVE	T1,-2(P)	;Device CONI
	MOVEM	T1,UNIERR(U)	;STILL FAILS AFTER E.R.: CALL IT HARD ERROR.
	MOVE	T1,-3(P)	;Device DATAI
	MOVEM	T1,UNIHDI(U)
	MOVEI	T1,1		;READY TO COUNT ERROR
	TRNN	P3,IODTER
	 JRST	[MOVSS T1	;DEVICE ERROR
		JRST   DTRSC1]
	TLNE	S,IO
	 TLOA	P3,IOSHWE	;Hard write error
	  TLO	P3,IOSHRE	;Hard read error
DTRSC1:	ADDM	T1,UNIHCT(U)	;# of IODERRs ,, # of IODTERs
	MOVE	P4,UNIHBN(U)	;SAVE HARD BLOCK NUMBER
	PUSHJ	P,@KONHRD(J)	;CALL DEVICE DEPENDENT HARD ERROR DATA SAVER.
	JRST	DTAOK1
;Device retry
DTRRTY:	DPB	T1,UNYRTY	;REST COUNT
	AOS	UNIECT(U)	;COUNT 1 RECOVERY TRY
	MOVEI	T1,TWFCOD	;SET TRANSFER FIXED (RETRY)
	PUSHJ	P,IDL1		;SET IDLE AND STORE STATUS
KCIPOP:	MOVSI	T1,KCMIOS	;NEED TO DO I/O SELECT
	POPJ	P,

DTRRCL:	DPB	T1,UNYRCL	;RESET COUNT
	LDB	T1,UNYRRT	;SET RETRY COUNT AFTER RECAL
	DPB	T1,UNYRTY
	MOVEI	T1,RCOD
	PUSHJ	P,IDL1
	PUSHJ	P,SETTIM	;MAKE SURE IT HAPPENS EVENTUALLY
	PUSHJ	P,@KONRCL(J)	;ISSUE RECAL
	JRST	KCIPOP

DTROFS:	DPB	T1,UNYOCV	;STORE UPDATED COUNT.
	LDB	T1,UNYRTO	;RETRY COUNT AFTER OFFSET.
	DPB	T1,UNYRTY
	LDB	T1,UNYRCO	;RECAL COUNT AFTER OFFSET.
	DPB	T1,UNYRCL
	PUSHJ	P,@KONOFS(J)	;SETUP FOR OFFSET, STATE IN UNYOCV
	JRST	DTRSEC		;AND TRY AGAIN.


IDL1:	MOVEM	T1,UNISTS(U)
	PUSHJ	P,ZERTIM
SETID2:	LDB	PG,UNYPAC
	LDB	T1,PGYPNO	;Physical page number on disk
IFE FTDPAG,<
	LSH	T1,P2BLSH	;CONVERT TO BLOCKS
	LDB	T3,UNYPPL	;NUMBER OF BLOCKS IN PARTIAL PAGE TRANSFER
	ADD	T1,T3		;INCLUDE OFFSET IN ADDRESS
	MOVEM	T1,UNIBLK(U)
>
IFN FTDPAG,<
	MOVEM	T1,UNIPAG(U)	;Store for KONRED and KONWRT
>
SETIDL:	MOVSI	T1,(1B0)
	ANDCAM	T1,KONPTR(J)	;Clear busy flag for this kontroller
	HRRZ	T3,KONCHN(J)
	ANDCAM	T1,CHNBSY(T3)	;Clear busy flag for its channel
	POPJ	P,
SUBTTL	Data transfer OK
DTAOK:	MOVEI	P3,0		;NO ERRORS
	SKIPL	UNIRCT(U)	;WAS THERE AN ERROR?
	 JRST	DTAOK1		;NO
	MOVEI	T1,1
	MOVSI	T2,UNPDEV
	TDNE	T2,UNIRCT(U)	;DEVICE OR DATA?
	 MOVSS	T1		;DEVICE
	ADDM	T1,UNISCT(U)
	PUSHJ	P,@KONSFT(J)	;TELL DRIVER THAT SOFT ERROR HAS OCCURRED, MAYBE HAS TO SAVE SOME STATUS.
DTAOK1:	PUSHJ	P,ZERTIM	;Clear hung timer
	PUSHJ	P,SETIDL	;KON AND CHN ARE NOW IDLE
	SETZM	UNISTS(U)	;UNIT IS NOW IDLE
	SETZM	UNIRCT(U)	;ZERO THIS FOR NEXT TIME
	SETZM	UNIRC1(U)	;ZERO SECOND E.R. STORAGE CELL.

SWPFIN:	HRRZ	P4,-1(P)	;Get number of blocks or pages
IFN FTDPAG,<
	LSH	P4,P2BLSH	;Convert to number of blocks
>
	MOVEI	T1,UNIICT(U)	;GET POINTER TO BLOCKS TRANS
	PUSHJ	P,UPSTAT	;AND UPDATE
	JUMPE	P3,NOSWPR	;No swap errors (P4 has # of blocks xfer'd)

;   The following path was used to get here:
;1) Disk interrupt to BPXINT, APXINT, or RMXINT
;2) Disk driver jumps to FILINT with bits in T1
;3) KCMERRset in T1 when tested at DTASAT
;4) Jump to DTAOK1 at either DTRSEC+16 or DTAST2+7, which set P3 nonzero

	TLNN	S,IO		;INPUT OR OUTPUT ERROR?
	 JRST	SWPFIE		;INPUT
	LDB	T2,PGYADR	;OUTPUT, GET DISK ADDRESS
	CAMLE	PG,MAXPCB	;Is page a PCB?
	 JRST	SWPFNP		;No
	MOVEM	PG,SAVEPG
	LDB	T2,PGYLMA	;Yes, get address of page
	PUSHJ	P,CTLFND	;Determine PCB type
	CAIN	PG,%SAT.C	;Is it a SAT?
	 STOPCD (.+1,INFO,WRTSAT,WRTST1,<Disk output error writing SAT>);;SWPFIN+15
	MOVE	PG,SAVEPG
	JRST	SWPFNP		;Go put page in error hash table (INSOH3+1)

SAVEPG:	0			;Saved contents of PG

;This routine called by STOPCD processor (see also CPLSAT in SWAMP)
WRTST1:	PUSHJ	P,DSKCLN##	;Output "Requesting FULL DSKCLN" and continue
WRTST2:	MOVE	PG,SAVEPG
	PFALL	PRTPGY		;Output info from PGY table for this PG

PRTPGY::PUSHJ	P,INLMES##
	 ASCIZ /Core page /
	MOVE	T1,PG
	PUSHJ	P,OCTPNT##
	PUSHJ	P,INLMES##
	 ASCIZ / associated with disk unit /
	LDB	T1,PGYUNI	;Get disk unit part of PGYADR
	PUSHJ	P,OCTPNT##	;Print unit
	PUSHJ	P,INLMES##
	 ASCIZ	/ page /
	LDB	T1,PGYPNO	;Get disk page number part of PGYADR
	PUSHJ	P,PRT22A##	;Print page address (6 or 7 octal digits)
	PJRST	CRLF##

PRINTF(<[SWPFNP Checking DSKCLN done should use DRBSTR for file]>)
SWPFNP:	MOVEI	T1,SRPNDS	;If DSKCLN has not run to completion,
	TDNE	T1,STRDDB+STRBTS; then output message, don't put in OHT
	 STOPCD (NOSWPR,EVENT,WRTDSK,WRTST2,<Disk write error>);;SWPFNP+2
	PUSHJ	P,INSOHT	;PUT INTO OUTPUT ERROR HASH TABLE
	MOVE	T1,P3		;COPY ERROR BITS
	ANDI	T1,IODERR!IODTER ;JUST THESE
	LSH	T1,^L<IODTER>-^L<OHTDTE>+^D18	;POSITION IT FOR OHT IORM
	IORM	T1,OHTTAB(T4)	;PUT BITS INTO OHT
	JRST	NOSWPR		;REJOIN CODE.

;Disk read error

SWPFIE:	LDB	T1,PGYSTS	;GET STATUS BITS
	ADDI	P4,3		;FORCE TO END OF THIS PAGE
	TRZE	P3,IODERR
	 TRO	T1,PGPDER
	TRZE	P3,IODTER
	 TRO	T1,PGPDTE
	DPB	T1,PGYSTS	;SET ERROR BITS.

NOSWPR:		;Here with # of blocks transferred in P4 (even IFN FTDPAG)
IFE FTDPAG,<
	CAIGE	P4,4		;THIS MIGHT BE TRUE ON RECOVERABLE ERROR
	 JRST	SWPPPL		;YES, MUST TAKE SPECIAL PAINS
>
SWPPLD:	LDB	PG,UNYPAC	;GET FIRST PAGE DONE
	LSH	P4,B2PLSH	;Convert # of blocks done to pages
	SKIPG	P4		;MUST BE AT LEAST ONE
	 STOPCD (.,INFO,SWPZER,PRTPGY,<Swapped zero pages>) ;;SWPPLD+2 (PGEZER)
	ADDM	P4,DSKAPC	;UPDATE SYSTEM-WIDE COUNTER
	SKIPE	JOB		;IF NULL JOB RUNNING
	 JRST	SWPFI0		;NOT
	SETOM	CLKFLG		;GET TO SCHED EARLY SO
	WRPI	PICLK		;HE DOESN'T HAVE TO WAIT TILL NEXT TICK.
SWPFI0:	MOVEI	F,SOD.N		;ASSUME SWAP OUT DONE
	TLNN	S,IO		;IS IT?
	 MOVEI	F,SID.N		;NO, SWAP IN DONE
	CAIA			;SKIP OVER FIRST LDB
	 LDB	PG,PGYFPL	;GET NEXT PAGE
	SOJG	P4,.-1		;JUMP IF THIS IS NOT THE LAST

;HERE WITH LIST NUMBER IN F, FIRST PAGE DONE IN UNYPAC,
; LAST PAGE DONE IN PG.

;FIRST TAKE THE PAGES THAT HAVE BEEN COMPLETED OFF THE I/O LIST.

	LDB	P4,UNYPAC	;P4 GETS FIRST DONE.
	MOVE	P3,PG		;P3 GETS LAST DONE.
	LDB	T3,PGYFPL	;GET FIRST NOT DONE, IF ANY, IN T3
	MOVE	PG,P4		;ADDRESS FIRST DONE
	LDB	PG,PGYBPL	;GET PREVIOUS IN PG
	JUMPE	PG,[DPB T3,UNYPGL ;IN NO PREVIOUS, FIRST NOT DONE, IF ANY,
				; IS NEW FIRST ON I/O LIST
		    JRST .+2]	;SKIP OVER THE DPB
	DPB	T3,PGYFPL	;PREVIOUS POINTS FORWARD TO 1ST NOT DONE
	EXCH	PG,T3		;ADDRESS 1ST NOT DONE IF ANY, T3
				; HAS PREVIOUS
	SKIPE	PG		;IF NO 1ST NOT DONE, NOTHING TO POINT BACK
	 DPB	T3,PGYBPL	;1ST NOT DONE POINTS BACK TO PREVIOUS

;NOW TAKE PAGES THAT HAVE COMPLETED I/O AND PUT THEM ALL TOGETHER
; ONTO THE CORRECT DONE LIST.

	SKIPN	T3,LSTLST(F)	;ANYONE AT ALL ON DONE LIST?
	 JRST	NEWDON		;NO, JUST MAKE THIS THE DONE LIST
	HLRZ	PG,T3		;ADDRESS LAST IN DONE LIST
	DPB	P4,PGYFPL	;LAST IN LIST POINTS FORWARD TO FIRST DONE
	EXCH	P4,PG		;ADDR. FIRST DONE, P4/LAST IN DONE LIST
	DPB	P4,PGYBPL	;FIRST DONE POINTS BACK TO LAST IN DONE LIST
	EXCH	PG,P3		;ADDRESS LAST DONE, FIRST DONE IN P3.
	HRLM	PG,LSTLST(F)	;THIS IS THE NEW LAST IN DONE LIST
	SETZ	T1,		;LAST IN DONE LIST POINTS TO 0
	DPB	T1,PGYFPL
	JRST	SWPFI1		;RETURN

;HERE WHEN DONE LIST WAS EMPTY. T3 CONTAINS 0.

NEWDON:	HRL	P4,P3		;LAST DONE,,FIRST DONE
	MOVEM	P4,LSTLST(F)	;NEW DONE LIST
	HRRZ	PG,P4		;ADDRESS FIRST DONE
	DPB	T3,PGYBPL	;POINTS BACK TO A 0
	EXCH	PG,P3		;ADDRESS LAST DONE, FIRST DONE IN P3.
	DPB	T3,PGYFPL	;POINTS FORWARD TO A ZERO

;HERE AFTER PAGES ARE PUT ONTO THE DONE LIST. STORE NEW
; LIST NUMBER AND CALL FINPCB IF THIS IS A PCB, WHICH
; MAY CALL SWPENQ (SO PAGE HAS TO BE ON DONE LIST).
; P3 HAS FIRST PAGE DONE, LAST PAGE DONE IS LAST ON DONE LIST.

SWPFI1:	MOVE	PG,P3		;GET FIRST DONE IN PG.

SWPFI2:	DPB	F,PGYLST	;THIS PAGE NOW ON DONE LIST
	CAMGE	PG,MINPCB	;MUST BE AT LEAST FIRST PCB PAGE
	 STOPCD (,XCT,SWPOOR)	;PAGE NUMBER TOO LOW    ;;SWPFI2+2
	LDB	P3,PGYFPL	;SAVE NEXT MEMBER IN CASE FINPCB
				; CALLS SWPENQ TO START IT AGAIN.
	CAMG	PG,MAXPCB	;IS IT A PCB?
	 PUSHJ	P,FINPCB	;YES, DO SPECIAL STUFF
	SKIPE	PG,P3		;GET NEXT PAGE IF ANY
	 JRST	SWPFI2		;AND DO IT
	JRST	KCIPOP		;RETURN.

IFE FTDPAG,<;Here if less than a full page was transfered
SWPPPL:	LDB	T2,UNYPPL	;SEE IF ANY LEFT FROM BEFORE
	ADD	P4,T2		;TOTAL TRANSFERED SO FAR
	DPB	P4,UNYPPL	;SAVE AMOUNT DONE NOW
	CAIL	P4,4		;IF NOT, IT IS 4, WE SAVE THE 2 LOW 0 BITS
	 JRST	SWPPLD		;FINALLY FINISHED THAT PAGE
	LDB	PG,UNYPAC
	LDB	T2,PGYPNO	;RESET ADDRESS
	LSH	T2,P2BLSH	;CONVERT TO BLOCKS
	ADD	T2,P4
	MOVEM	T2,UNIBLK(U)	;RESTART I/O AT THIS BLOCK
	MOVEI	T2,PWCOD	;PW for positioning and need channel
	SKIPL	KONIBM(J)	;If IBM disk (no latency optimization)
	SKIPGE	KONPOS(J)	; or fixed head disk that does not position
	 MOVEI	T2,TWFCOD	;  then set to TWF to go to T
	MOVEM	T2,UNISTS(U)
	JRST	KCIPOP
>  ;End IFE FTDPAG
SUBTTL	FILIO SUBROUTINES
COMMENT ;@@SUBROUTINE SWPENQ
@@PURPOSE ADD ONE PAGE TO THE SWAP I/O REQUEST LIST
@@ENTRY PG CONTAINS CORE PAGE TO ADD TO LIST. PGYSOP IS 1
IF PAGE IS TO BE SWAPPED OUT, 0 OTHERWISE (PGYSIP IS ASSUMED
TO BE ON IF PGYSOP IS OFF). PGYADR CONTAINS UNIT
(PGYUNI) AND PAGE WITHIN UNIT (PGYPNO) THAT THE SWAP
I/O IS TO BE DONE TO/FROM.
@@ACCUM USES T1-T4, PG, F, U, J, P1-P4, S
@@EXIT PAGE NUMBER IS NOT RETURNED IN PG, CALLER MUST SAVE.
@@CALLS IOSEL, WHICH CALLS KONTROLLER DEPENDENT ROUTINES, STRTIO
@@RESTRICTIONS CORE PAGE MUST NOT HAVE SWAP I/O IN PROGRESS
ALREADY BEFORE CALLING. CALLER IS RESPONSIBLE FOR
HANDLING ALL INFO REGARDING THE PAGE'S TRANSITION TO THE
SWAP IN PROGRESS STATE (E.G. MARKING PAGE CLEAN, PUTTING
JOBS INTO WAIT FOR THE PAGE, ETC.)
CORE PAGE MUST BE GREATER THAN OR EQUAL TO THE FIRST PCB
CORE PAGE IN THE SYSTEM, AND MUST BE LESS THAN OR
EQUAL TO THE LAST CORE PAGE IN THE SYSTEM.
@@FUNCTION TAKE PAGE OFF LIST IT WAS ON.  INSERT REQUEST ON
UNIT'S I/O QUEUE SOAS TO KEEP I/O QUEUE SORTED
WITH RESPECT TO UNIT PAGE NUMBERS. CALL IOSEL TO START I/O
IF NOT ALREADY STARTED, AND RETURN.
@@;


SWPENQ::CAML	PG,MINPCB	;IS PAGE IN BOUNDS?
	CAML	PG,MEMSZP	;ONLY THESE PAGES CAN SWAP
SWPOOR:: STOPCD (.,STOP,SWPOOR,,<Swapper: Out of range>)   ;;SWPENQ+2
	LDB	T1,PGYADR	;GET ADDRESS
	CAMN	T1,ADRDUM	;THIS REALLY HAVE A DISK PAGE?
	 STOPCD (.,STOP,SWPNDP,,<Swapper: Not a disk page>);;SWPENQ+5
	DSKOFF			;LET NO ONE CHANGE THINGS. DO THIS
				; BEFORE REMLST, SINCE IF THIS IS
				; A PCB PAGE, COULD GO FROM SWAP DONE
				; LIST TO SPR LIST AT INTERRUPT LEVEL.
	PUSHJ	P,REMLST	;TAKE CORE PAGE OFF OLD LIST
	LDB	U,PGYUNI	;GET UNIT NUMBER FROM REQUEST
	CAILE	U,UNTLEN##	;Don't exceed size of UNTTBL
SWPUOR:: STOPCD (.,STOP,SWPUOR,PRTPGY,<Swapper: Unit out of range>)
	MOVE	U,UNTTBL(U)	;GET UNIT DATA BLOCK
	JUMPE	U,SWPUOR	;Cannot do I/O to off-line drive
	MOVEI	T1,SPR.N	;LIST PAGE WILL BE GOING ON
	DPB	T1,PGYLST	;PUT IT THERE.
IFCPU (KL),<LDB	T1,PGYSOP	;GET DIRECTION
	MOVE	T1,@[CSUCNT
		     CSVCNT](T1) ;GET PROPER COUNT
	MOVEM	T1,@PGYCSH	;REMEMBER SWEEP NUMBER
>;END IFCPU (KL)
	LDB	F,UNYPGL
	JUMPE	F,SWPEN0	;NO REQUEST WAITING, QUE THIS
	MOVEI	T3,0		;THIS IS THE 'PREVIOUS PAGE'
	LDB	T1,PGYPNO	;GET THE DESIRED ADDRESS
	EXCH	F,PG		;SAVE REQUEST PAGE IN F
SQLP:	LDB T2,PGYPNO		;GET ADDRESS OF REQUEST IN QUE
	CAMG	T1,T2		;SEARCH TILL ONE GREATER
	JRST	SWPQFD		;THIS IS IT
	MOVE	T3,PG
	LDB	PG,PGYFPL	;GET NEXT
	JUMPN	PG,SQLP		;CONTINUE SEARCH
SWPQFD:	SKIPE PG
	DPB	F,PGYBPL	;LINK IN BACK POINTER
	EXCH	F,PG
	DPB	F,PGYFPL	;AND FORWAR LINK
	DPB	T3,PGYBPL	;SET BACK LINK
	EXCH	PG,T3
	JUMPE	PG,[DPB T3,UNYPGL	;SET UP LIST IF PREVIOUS=0
		JRST .+2]
	DPB	T3,PGYFPL	;ELSE SET FORWARD LINK IN OLD
	MOVE	PG,T3		;RESTORE PG
SQENT:	SOS	DSKAPC		;NEW PG ON QUEUES
	HRRZ	J,UNIKON(U)	;J/ KONTROLLER ADDRESS
	PUSHJ	P,IOSEL
	DSKON
	POPJ	P,

SWPEN0:	DPB	F,PGYFPL	;REQUEST IS FIRST AND LAST
	DPB	F,PGYBPL	;ON THE UNIT'S SWAP IN PROGRESS LIST
	DPB	PG,UNYPGL	;REQUEST IS FIRST ON LIST
	JRST	SQENT		;AND GET THINGS STARTED

DSKAPC:: Z		;SYSTEM-WIDE ACTIVE-PAGE COUNT ON ALL UNITS
			;KEPT AS -(NUMBER OUTSTANDING PAGES)
;SWPSTR ACTUALLY STARTS THE I/O PROCESS FOR THE LIST IN UNYPAC

STRTIO:				;Start I/O - U point to unit
				;Called when there is at least 1 page to xfer
SWPSTR:	LDB	PG,UNYPAC	;First page in list for this unit
	LDB	S,PGYSOP	;Swap out flag
IFCPU (KL),<
	MOVE	T1,@PGYCSH	;Set highest cache sweep number seen so far
	MOVEM	T1,CSNSAV
>;END IFCPU (KL)
	SKIPN	S
	 SKIPA	T1,KONRED(J)	;IN  = APXRED,BPXRED,RMXRED
	MOVE	T1,KONWRT(J)	;OUT = APXWRT,BPXWRT,RMXWRT
	PUSHJ	P,(T1)		;Set up for I/O, UNIPAG has disk page address
				;P1 thru P4 get set up for use by KONADD
	PUSHJ	P,SETTIM	;Set 3 second timer
SWPGL1:
IFE FTDPAG,<
	LDB	T2,UNYPPL	;See if finishing up from error
	JUMPN	T2,SWPPST	;If so, do less than 4 blocks
>
	LDB	T3,PGYPNO	;Get the starting page number on disk
	MOVE	T2,PG		;First consecutive core page
	MOVE	T1,PG		; to both (T1 will increment if contiguous)

SWPGLP:		;Loop looking for consecutive blocks to contiguous core
IFCPU (KL),<
	MOVE	T4,@PGYCSH	;Get sweep number for this core page
	CAMLE	T4,CSNSAV	;Keep the highest
	 MOVEM	T4,CSNSAV
>;END IFCPU (KL)
	LDB	PG,PGYFPL	;Get next page in the list for this unit
	JUMPE	PG,SWPST1	;No more pages need I/O on this unit
	LDB	T4,PGYSOP	;Get page's direction (in or out)
	CAME	T4,S
	 JRST	SWPST1		;Different direction, start what we've got
	LDB	T4,PGYPNO	;Get disk page number
	ADDI	T3,1		;Increment current disk page number
	CAME	T3,T4		;Does next page follow previous disk page?
	 JRST	SWPST1		;Discontiguous disk address, start previous
;Here when 8 or more consecutive blocks are requested.  If going to
;scattered core pages, make several small requests to KONADD.  If going to
;consecutive core pages, make one big request to KONADD (because that is more
;efficient when using DF10 or RH11).  To avoid end-of-track or command list
;full hassles, request only 1 page at a time from BPXADD.
	SKIPGE	KONIBM(J)	;Disks on the SA-10?
	 JRST	SWPSTX		;Yes, only 1 page per call to KONADD
	CAIN	PG,1(T1)	;Does this new core page follow current?
	 AOJA	T1,SWPGLP	;Yes, count contiguous pages
SWPSTX:	SUBI	T1,-1(T2)	;Core is discontiguous, get number of pages
IFE FTDPAG,<
	LSH	T1,P2WLSH	;Conver to number of words
	LSH	T2,P2WLSH	;Convert to physical word address in core
>
;P034/P05 Changed to use pages instead of words.  UNIPAG has disk address.
IFN FTDPAG,<;T1 has number of pages to transfer, T2 has physical page number>
	PUSHJ	P,@KONADD(J)	;Add to current I/O command list
	  PJRST	SWPSTD		;Command list is full or hit end of cylinder
	JRST	SWPGL1		;Loop back to call KONADD again

SWPST1:	SUBI	T1,-1(T2)	;End of list or noncontiguous disk address
IFE FTDPAG,<
	LSH	T1,P2WLSH	;# of words to transfer
	LSH	T2,P2WLSH	;Word address of start
SWPST2:				;Here to retry a partial page transfer
            ;T1 has number of words to transfer, T2 has physical word address>
IFN FTDPAG,<;T1 has number of pages to transfer, T2 has physical page number>
	PUSHJ	P,@KONADD(J)	;Add transfer to the command list
	  JFCL			;No problem if command list is now full
	PFALL	SWPSTD		;Swap start done

SWPSTD:			;Here when contiguous disk transfer is set up
IFCPU (KL),<
	MOVE	T3,S		;GET DIRECTION OF IO
	MOVE	T4,CSNSAV	;GET LARGEST SWEEP NUMBER
	CAME	T4,@[CSUCNT
		     CSVCNT](T3) ;NEED A SWEEP?
	 PJRST	[AOS CSHSAV	;NO, COUNT A SAVED SWEEP
		 PJRST @KONFIN(J)] ;AND START TRANSFER UP.
	JUMPN	T3,SWPCSV	;DO VALIDATE IF ITS OUTPUT
	CSHUNL			;INPUT, START AN UNLOAD.
	CAMN	T1,CSUCNT	;SWEEP NUMBER CHANGE YET?
	 JRST	.-1		;NO, WAIT FOR APR INTERRUPT
	PJRST	@KONFIN(J)	;YES, CAN START I/O NOW.

SWPCSV:	CSHVAL			;IT WAS AN OUTPUT, DON'T UNLOAD CACHE
	CAMN	T1,CSVCNT	;WAIT UNTIL VALIDATE COMPLETES
	 JRST	.-1
>;END IFCPU (KL)
IFCPU (KS),<
	SKIPN	S		;SKIP IF OUTPUT
	 CSHIVL			;ON INPUT INVALIDATE CACHE
>;END IFCPU (KS)
	PJRST	@KONFIN(J)	;GO START UP I/O

IFCPU (KL),<
CSNSAV:	BLOCK	1	;HIGHEST SWEEP NUMBER SEEN IN CURRENT GROUP OF I/O REQUESTS
>;END IFCPU (KL)

IFE FTDPAG,<
SWPPST:	LSH	T2,B2WLSH	;FIND NUMBER OF WORDS ALREADY TRANSFERED
	MOVEI	T1,1000
	SUB	T1,T2		;THIS IS THE NUMBER LEFT TO DO
	LSH	PG,P2WLSH
	ADD	T2,PG		;THIS IS THE ADDRESS
	JRST	SWPST2		;GO
>  ;End IFE FTDPAG
;SELECT THE I/O TRANSFER TO BE STARTED. CALLED AT INTERUPT
;LEVEL OR AT UUO LEVEL WITH DSKOFF IN EFFECT

;I	Idle - UNISTS=0
;PW	Position wait - start monitor seek when kontroller is free
;P	Positioning - when seek done, select best XFR and go to TWF
;SW	Seek wait - user has issued a SEEK uuo, wait for kontroller
;S	Seek - when seek done, calculate best XFR and go to P or I
;RS	Read status - when done, return sense bytes to user
;CW	Capacity wait - determine size of disk when kontroller is free
;C	Capacity test in progress - when done, inform ONCDSK
;TW	Transfer wait - start XFR on fixed head disk when kontroller is free
;TWF	Transfer wait fixed - position done or retry needed, start current XFR
;T	Transfer - go to I if XFR OK, go to TWF if retry needed
;R	RECAL in progress - go to PW (go to TWF if SA10 which avoids PW and P)
;OW	Operator wait - human intervention required (drive off-line)
;VW	Volume wait - waiting for other half of 3652 disk to finish

;IOSEL is called from ONCDSK to start capacity test, from the SEEK uuo,
;from hung unit recovery, and when time to swap pages to/from core.

IOSEL::	PUSH	P,U		;Save starting unit at top of stack
	SKIPN	UNISTS(U)
	 JRST	IOIDLE		;The unit is currently idle
	SKIPGE	KONPOS(J)	;Positioner or fixed head unit?
	 JRST	IOCHN		;Fixed head, no seeks required on this KON
	SKIPGE	KONIBM(J)	;IBM disks?
	 JRST	IOINC1		;Yes, don't need DF10 channel with SA10

;Start multiple overlapping seeks on the units on this kontroller

IOKON:	SKIPGE	KONPTR(J)	;Is the kontroller busy?
	 JRST	UXPOPJ		;Cannot proceed until it is free
IOKON0:	MOVE	T1,UNISTS(U)
	CAIN	T1,CWCOD	;Part of the capacity test involves seeks
	 PUSHJ	P,CPYKON	;Start up capacity test if in CW
	CAIE	T1,SWCOD	;Seek wait
	CAIN	T1,PWCOD	;Position wait
	 SKIPA			;Start position of SW or PW
	  JRST	IOKON1		;See if next unit needs a position operation
	AOS	UNISTS(U)	;Set to S or P
	CAIN	T1,SWCOD	;Is this a user request (SEEK UUO)
USRSEK:	 AOSA	UNIUSC(U)	;Count user
MONSEK:	AOS	UNIMSC(U)	; or monitor seek
	PUSHJ	P,SETTIM	;Set 3 second timer
	PUSHJ	P,@KONPOS(J)	;Start the position
IOKON1:	HLRZ	U,UNIKON(U)	;Get next unit on kontroller
	CAME	U,(P)		;Is it the one we started with?
	 JRST	IOKON0		;No, check it

;All outstanding seeks taken care of.
;Search all units on this channel, look for best one to start a transfer.

IOCHN:	HRRZ	P1,KONCHN(J)	;Pointer to channel
	SKIPGE	CHNBSY(P1)	;Is channel idle?
	 JRST	UXPOPJ		;No, cannot proceed until it is free

	MOVEI	P1,0		;No "BEST" unit so far
	MOVEI	P2,1		;Found perfect unit if this goes to zero
IOCHN0:	MOVE	T1,UNISTS(U)
	CAIN	T1,CWCOD	;Part of the capacity test is a read transfer
	 PUSHJ	P,CPYKON	;Start capacity test
	CAIN	T1,TWFCOD	;TWF if already on cylinder or retry needed
	 PUSHJ	P,IOCHNF	;Set P1 and P2 if this is best unit
	CAIN	T1,TWCOD	;Only fixed head disks are ever in TW
	 PUSHJ	P,PIKTRN	;TW, pick best transfer for drum
IOCNH1:	HLRZ	U,UNICHN(U)	;Check next unit looped on this channel
	CAME	U,(P)		;Back where we started?
	 JUMPN	P2,IOCHN0	;If not ideal transfer found, try next one
	SKIPN	U,P1		;Found unit with 0 latency or checked all
	 JRST	UXPOPJ		;Give up if no units are in TW or TWF
	HRRZ	J,UNIKON(U)	;Point to correct kontroller (U may be changed)
	MOVEI	T1,TCOD
	MOVEM	T1,UNISTS(U)	;Mark transfer in progress on this unit
	HRRZ	P1,KONCHN(J)	;Pointer to channel
	MOVSI	T1,(1B0)
	IORM	T1,CHNBSY(P1)	;Mark channel busy
	IORM	T1,KONPTR(J)	;Mark kontroller busy
STRTIU:	PUSHJ	P,STRTIO	;Start I/O transfer (read or write)
UXPOPJ:	POP	P,U		;Back to UCB we started with
	HRRZ	J,UNIKON(U)	;Original kontroller
	POPJ	P,		;End of IOSEL

;IOCHNF - IO channel is free, find best unit to start

IOCHNF:	HRRZ	J,UNIKON(U)	;Here if was in TWF (happens on retry)
IFE FTDPAG,<MOVE T1,UNIBLK(U)>	;CHECK LATENCY FOR REQUESTED BLOCK
IFN FTDPAG,<MOVE T1,UNIPAG(U)>	;CHECK LATENCY FOR REQUESTED PAGE
	SKIPL	KONIBM(J)	;Don't call KONLTM for IBM disks
	 PUSHJ P,@KONLTM(J)	;Get # of microseconds until sector arrives
	SKIPE	P1		;FIRST ONE IS ALWAYS BEST
	CAMGE	T1,P2
	 PUSHJ	P,SAVBST	;BEST SO FAR
	MOVE	T1,UNISTS(U)	;Restore T1
	POPJ	P,		;Continue down skip chain

;CPYKON - Called to start capacity test when UNISTS=CWCOD

CPYKON:	AOS	UNISTS(U)	;Increment CW to C
	HRRZ	T1,KONCPY(J)	;NOTE: LH of KONCPY has 16 unit bits
	PUSHJ	P,(T1)		;Go to capacity test
	MOVE	T1,UNISTS(U)	;Set T1 back to current status
	POPJ	P,		;Continue down skip chain
;HERE IF THE UNIT IS IDLE

IOIDLE:	SKIPGE	KONPOS(J)	;Does unit have moving heads?
	 JRST	IOINPS		;No, fixed head disks do not seek
IFN SAXN,<
	SKIPGE	KONIBM(J)	;IBM disk?
	 JRST	IOINCH		;Yes, skip PW and TWF states, go to T
>  ;End IFE SAXN
	PUSHJ	P,PIKPOS	;Pick the best position
	  JUMPE	PG,IOKON	;No transfers waiting if zero in PG
	MOVEI	T1,PWCOD	;(lowest cylinder on unit if nonzero in PG)
	SKIPN	P2		;P2 has magnitude of difference in cylinders
	 MOVEI	T1,TWFCOD	;If already at right cylinder, use TWF not PW
	MOVEM	T1,UNISTS(U)
	JRST	IOKON		;Go see if KON is ready

;IOIDLE - No Position Seek required (for FH disks)

IOINPS:	MOVEI	T1,TWCOD	;Set TW (fixed head disks only)
	LDB	P1,UNYPGL	;Is there a transfer waiting?
	JUMPE	P1,IOCHN	;No, leave it idle, check others on channel
	MOVEM	T1,UNISTS(U)	;Yes, set to TW
	JRST	IOCHN		;And see if channel is ready

IFN SAXN,<
;IOIDLE - No Channel needed
;Don't check other units on this channel - that's what the block MUX is for.
;If this unit has something to do, start it as long as the other half of the
;3652 disk is not busy.  Switch to OLV at lowest requested cylinder.

IOINCH:	MOVSI	T1,UNPRRS	;Was RRSETB called while unit was busy?
	TDNE	T1,UNIDES(U)
	 JRST	RDRST		;Yes, do that and UXPOPJ
	PUSHJ	P,PIKPOS	;Pick best unit to start (IBM disks)
	  JRST	IOIOLV		;Time to start other logical volume
	SKIPE	UNIOLV(U)	;Is there an Other Logical Volume?
	SKIPN	@UNIOLV(U)	;Yes, is it busy?
	 JRST	IOINC2		;No, go ahead with this transfer
	MOVEI	T1,VWCOD	;Logical volume wait code
	CAMN	T1,@UNIOLV(U)	;Is other volume waiting for us?
	 JRST	IOINC2		;Yes, we have priority as long as PIKPOS skips
	MOVEM	T1,UNISTS(U)	;No, other logical volume is busy, we have to
	PUSHJ	P,SETTIM	; wait for elevator algorithm to hit bottom
	JRST	UXPOPJ		; (SETTIM gives it 3 seconds to do so)

;Hit lowest cylinder wanted on this unit, switch to OLV if it is waiting

IOIOLV:	MOVEI	T1,VWCOD	;Code for other unit waiting for us
	SKIPE	UNIOLV(U)	;Is there an other logical volume?
	CAME	T1,@UNIOLV(U)	;Yes, does it want to go?
	 JRST	[JUMPE PG,UXPOPJ  ;No, done if nothing to do
		 JRST  IOINC2]	  ;Else do transfer to cylinder 0
	JUMPE	PG,IOIOL1	;Yes, do we want to go?
	MOVEM	T1,UNISTS(U)	;No, put us in VW wait state
	PUSHJ	P,SETTIM	;Set timer for 3 seconds in case OLV gets hung
IOIOL1:	AOS	OVBUSY		;Count # of times switched to OLV
	HRRZ	U,UNIOLV(U)	;Get pointer to other unit's UNISTS
	SUBI	U,UNISTS	;Point to start of UCB
	HRRZ	J,UNIKON(U)	;Point to its KON
	JRST	IOINC2		;Start up this other logical volume
OVBUSY::0			;# of times switched from BPAn to BPCn
>  ;End IFN SAXN

;IOSEL called for a unit that does no latency (doesn't set channel busy)
;UNISTS checked to be nonzero, it can only be CW or TWF on SA10 disks

IOINC1:	MOVE	T1,UNISTS(U)	;Get current status
	CAIN	T1,CWCOD	;Did ONCDSK put unit in capacity wait?
	 PUSHJ	P,CPYKON	;Start capacity test
	CAIE	T1,TWFCOD	;Is it in TWF? (doing a retry)
	 JRST	UXPOPJ		;No, must be T or VW, wait for it to be idle

;Here to start I/O on a unit that does not use a DF10 data channel.
;It has already been determined that UNISTS is zero or TWF.

IOINC2:	MOVEI	T1,TCOD		;Go directly to Transfer status (bypass PW)
	MOVEM	T1,UNISTS(U)	;Put in block MUX list and start it
	JRST	STRTIU		;(do not mark channel or kontroller busy)
SUBTTL	Elevator algorithm
COMMENT ! PIKPOS & PIKCYL
PURPOSE: PICK THE BEST POSITION & CYLINDER TO DO NEXT
EXPECTS: U/UNIT
DESTROYS:  T1-T3,P1-P3,PG
RETURNS:
  NOSKIP: NO PAGES ON UNYPGL,NOTHING TO DO. T3/BLOCKS PER CYL
  SKIP: P1/ 1ST BLK OF NEXT CYL
	P2/ NUMBER OF CYLS TO MOVE
	P3/ PG/ OPTIMUM PG
	T3/ BLOCKS PER CYL
FUNCTION: CHAIN DOWN UNYPGL LOOKING FOR LARGEST DSK PAGE
 NUMBER .LE. UNICYL(U).  (IF ONE FOUND ON SAME CYL
 AS UNICYL(U), SOSLE FAIRNESS COUNT AND USE THIS ONE
 IF LARGER THAN LAST PAGE DONE ON THIS CYL AND FAIRNESS CNT
 NOT EXHAUSTED). AT THE POINT WE ENCOUNTER A DSK PAGE NUMBER
 WHOSE CYL IS > UNICYL, RESET FAIRNESS, CHECK
 WHICH DIRECTION WE'RE GOING. IF WE ARE GOING TOWARDS LARGER
 DISK PAGE NOS., EXIT WITH THIS AS THE OPTIMUM PAGE. IF
 WE WERE GOING TOWARDS SMALLER PAGES, USE THE LARGEST PAGE
 SMALLER THAN UNICYL WHICH WE ALREADY FOUND, IF ANY; OTHERWISE
 SET DIRECTION TOWARDS LARGER PAGES (="FORWARD") AND EXIT WITH THIS
 ONE AS OPTIMUM PAGE.

 IF ALL PAGES ON UNYPGL HAVE CYL < UNICYL, SET DIRECTION
 TOWARDS SMALLER (="BACKWARDS") AND USE LARGEST FOUND.

CAVEAT:  THIS IS A ROUGH DESCRIPTION OF THE DSK ALGORITHM,
 AND I DON'T GUARANTEE IT TO BE EXACT; MOREOVER, SOME
 BEING MAY CHANGE THE CODE WITHOUT CHANGING THIS COMMENT.
 IT IS INTENDED AS AN INTRODUCTORY GUIDE ONLY, TO THOSE WISHING
 TO PENETRATE THIS MYSTERIOUS REALM, AS I HAVE.
 GOOD LUCK.  MAGIC IS SAID TO WORK HERE. /AA
!
;THIS IS THE FAMOUS "ELEVATOR" ALGORITHM


PIKPOS:	MOVNI	P1,1		;INITIALIZE TO -1 FOR FIRST REQ SELECTED
	MOVEI	P3,0		;NONE SAVED
IFE FTDPAG,<LDB	T3,UNYBPY>	;BLOCKS PER CYLINDER (ELEVATOR ALGORIGTHM)
IFN FTDPAG,<LDB	T3,UNYPPY>	;PAGES PER CYLINDER (ELEVATOR ALGORIGTHM)
	LDB	PG,UNYPGL	;FIRST PAGE ON LIST TO TRANSFER
	JUMPE	PG,CPOPJ	;IF NO PAGES, EXIT WITH ZERO IN PG
	PUSH	P,UNIDIR(U)	;Save direction flag
PIKPSL:	LDB	T1,PGYPNO	;GET ADDRESS FOR PAGE
IFE FTDPAG,<LSH T1,P2BLSH>	;CONVERT TO BLOCKS
PKPSP:	CAML	T1,P1		;CHECK AT ALL?
	 JSP	P2,PIKCYL	;YES, DO THE WORK
	LDB	PG,PGYFPL	;NEXT
	JUMPN	PG,PIKPSL	;MORE PAGES, CONTINUE

;BACK HERE FROM PIKCYL TO USE SAVED BEST-SO-FAR PAGE.

PKPSB:	MOVE	PG,P3		;OUT OF PAGES. GET SAVED PAGE.
	MOVSI	T2,(1B0)	;CHANGE DIRECTION TO BACKWARDS.
	IORM	T2,UNIDIR(U)	;THIS IS A NORMAL WAY OUT IN BACKUP MODE
PIKPS2:	LDB	T1,PGYPNO	;FOR A PAGE, GET ADDRESS
IFE FTDPAG,<
	LSH	T1,P2BLSH	;CONVERT TO BLOCKS
	MOVEM	T1,UNIBLK(U)	;SET DESIRED BLOCK
>
IFN FTDPAG,<
	MOVEM	T1,UNIPAG(U)	;Tell BPXKON/APXKON/RMXKON the disk address
>
	IDIV	T1,T3		;FIND THE CYL
	SUB	T1,UNICYL(U)	;DIFF IS ENOUGH
	JUMPE	T1,PIKPC1	;SET UNICDA AND UNYPAC FOR SELECTED RQ
	PUSHJ	P,SETFCT	;DIFFERENT CYL, RESET FAIRNESS
PIKPC1:	MOVM	P2,T1		;GET MAGNITUDE OF CHANGE FOR CALLERS
	DPB	PG,UNYPAC	;AND PAGE NUMBER (F=0 FOR PAGE RQ)
	POP	P,T1		;Get old direction flag
	SKIPGE	T1		;Was it going forward?
	SKIPGE	UNIDIR(U)	;Or now going backward?
	 AOS	(P)		;Yes to either, skip return
	POPJ	P,		;Nonskip if at lowest cyl and now going forward
;PIKCYL DOES THE REAL WORK FOR EACH CYL FOUND
;THE CALL IS JSP P2,PIKCYL
;IS GOES TO PIKPS2 TO USE CURRENT REQUEST
;IT RETURNS TO CALL+1 TO CONTINUE SCAN
;IT RETURNS TO PKPSB TO USE SAVE  BEST REQUEST

PIKCYL:	IDIV	T1,T3		;GET CYL OF REQUEST
	CAML	T1,UNICYL(U)	;SMALLER THAN CURRENT?
	 JRST	PIKCY1		;NO
PIKCYH:	MOVE	P3,PG		;SAVE PG, CLOSEST REQUEST SO FAR BELOW UNICYL
PIKCYB:	MOVEI	P1,1(T1)	;SET BLOCK FOR NEXT CYL
	IMUL	P1,T3
	JRST	(P2)		;RETURN

;Found request for CYL .GE. UNICYL

PIKCY1:	SUB	T1,UNICYL(U)	;SAME?
	JUMPE	T1,PIKSMC	;YES, SPECIAL PROCESSING
	PUSHJ	P,SETFCT	;RESET FAIRNESS COUNT (DIFF CYL)
	SKIPL	UNIDIR(U)	;WHICH WAY?
	 JRST	PIKPS2		;FORWARD, USE THIS ONE
	JUMPN	P3,PKPSB	;BACKWARD, IF ONE SAVED, USE IT
	MOVSI	T2,(1B0)
	XORM	T2,UNIDIR(U)	;RESET DIRECTION TO FORWARD SCAN
	JRST	PIKPS2		;AND USE THIS ONE

;Found request for CYL = UNICYL

PIKCYS:	SOSLE	UNIFCT(U)	;SAME CYL, FAIRNESS EXAUSTED?
	 JRST	PIKPS2		;NO, USE THIS ONE
	JUMPE	P3,PIKCY0	;NONE SAVED, SET DIR=FORWARD
	SKIPL	UNIDIR(U)	;WHICH WAY
	 JRST	PIKCYB		;FORWARD, JUST SET FOR NEW SEARCH CYL
	PUSHJ	P,SETFCT	;BACKWARDS, USED HELD REQUEST
	JRST	PKPSB

PIKCY0:	MOVSI	T2,(1B0)
	ANDCAM	T2,UNIDIR(U)	;RESET DIR=FORWARD IN CASE ONE THERE
	JRST	PIKCYH		;AND REMEMBER THIS IN CASE NONE

SETFCT:	MOVEM	T3,UNIFCT(U)	;Set fairness count to max
	MOVEI	T2,STSHUT!STSUPR;Shut or super-shut bits
	TDNE	T2,STATES##	;System shut? (running ASP or standalone TITO)
	 POPJ	P,		;Yes, bypass cylinder fairness count
	MOVE	T2,T3		;Blocks per cylinder
	LSH	T2,-5		;Divide by 32
	MOVEM	T2,UNIFCT(U)	;Use that as fairness count
	POPJ	P,

PIKSMC:	LDB	T2,PGYPNO	;GET ADDRESS BACK
IFE FTDPAG,<
	LSH	T2,P2BLSH	;CONVERT TO BLOCKS
	CAMLE	T2,UNIBLK(U)
>
IFN FTDPAG,<
	CAMLE	T2,UNIPAG(U)	;Compare with requested disk page address
>
	 JRST	PIKCYS		;STILL GOING UP, CONTIMUE
	AOS	P1,T2		;JUST LOOK A LITTLE HIGHER
	JUMPN	P3,PKPSB	;ALREADY GOT ONE SAVED, GO
	MOVSI	T2,(1B0)
	ANDCAM	T2,UNIDIR(U)
	MOVE	P3,PG		;SAVE THIS
	SOS	UNIFCT(U)	;JUST IN CASE
	JRST	(P2)		;AND CONTINUE SCAN
;End of elevator algorithm
SUBTTL	UPDATE UNIT STATISTICS AFTER IO

;ENTER WITH P4=NUMBER OF BLOCKS,  T1=UNIXRC(U)   (X=M,B OR D)
UPSTAT:	TLNE	S,IO		;WRITING?
	 ADDI	T1,1		;YES. UNIXWC=UNIXRC+1
	ADDM	P4,(T1)		;UPDATE WORD IN UNIT BLOCK
	POPJ	P,		;AND RETURN

COMMENT;@@SUBROUTINE SMSTAT
@@PURPOSE UPDATE UNIT DATA BLOCK COUNTS (INCREMENT BY "N" BLOCKS)
@@ENTRY T1/ NUMBER OF BLOCKS DONE
	T2/ RETRIEVAL POINTER FOR BLOCKS
	S/  I/O STATUS (MODE AND IO BIT)
@@ACCUM USES T1-T3, U
@@EXIT ALWAYS NON-SKIP.
@@FUNCTION INCREMENT APPROPRIATE UNIT DATA BLOCK COUNT.
@@;

SMSTAT::LDB	U,RBYUNI	;GET UNIT NUMBER
	MOVE	U,UNTTBL(U)	;GET UNIT DATA BLOCK ADDRESS
	LDB	T3,PIOMOD	;GET MODE
	CAIL	T3,SD		;SKIP IF NOT DUMP MODE
	 JRST	SMSTA1		;DO DUMP MODE

	MOVEI	T3,UNIBRC(U)	;ASSUME READ
	TLNE	S,IO		;SKIP IF READ
	 MOVEI	T3,UNIBWC(U)	;NO, WRITE.
	ADDM	T1,(T3)		;BUMP COUNT AND
	POPJ	P,		;RETURN

SMSTA1:	MOVEI	T3,UNIDRC(U)	;ASSUME READ
	TLNE	S,IO		;SKIP IF READ
	 MOVEI	T3,UNIDWC(U)	;WRITE
	ADDM	T1,(T3)		;INCREMENT
	POPJ	P,		;AND RETURN.
SUBTTL	PICK THE BEST TRANSFER

;THIS ROUTINE IS CALLED FOR FIXED-HEAD DISKS ONLY
;P1 HAS BEST UNIT, P2 ITS LATENCY TIME

PIKTRN:	MOVEI	P3,0		;NO F FOUND
	HRRZ	J,UNIKON(U)	;GET CORRECT KON
	LDB	PG,UNYPGL	;START LOOKING FOR PAGE TRANSFERS
	JUMPE	PG,CPOPJ	;NONE
PIKTP1:	LDB	T1,PGYPNO
IFE FTDPAG,<LSH T1,P2BLSH>	;CONVERT TO BLOCKS
	SKIPL	KONIBM(J)	;If not a fixed-head IBM disk
	 PUSHJ	P,@KONLTM(J)	;CALCULATE TIME TO REACH THIS RECORD
	SKIPE	P1		;FIRST XFER IS ALWAYS BEST
	CAMGE	T1,P2		;BEST SO FAR?
	 PUSHJ	P,SAVBST
	JUMPE	P2,PIKTP0	;BEST POSSIBLE FOUND IF P2=0
	LDB	PG,PGYFPL	;GET NEXT PAGE
	JUMPN	PG,PIKTP1
	JUMPE	P3,CPOPJ	;NONE FOUND
	MOVE	PG,P3		;GET BEST BACK
PIKTP0:	DPB	PG,UNYPAC
	LDB	T1,PGYPNO
IFE FTDPAG,<
	LSH	T1,P2BLSH	;CONVERT TO BLOCKS
	MOVEM	T1,UNIBLK(U)
>
IFN FTDPAG,<
	MOVEM	T1,UNIPAG(U)	;Set physical page address
>
	POPJ	P,

SAVBST:	MOVE	P3,PG		;BEST PAGE
	MOVE	P1,U		;BEST UNIT
	MOVE	P2,T1		;MICROSECONDS LATENCY TIME
	POPJ	P,

ZERTIM:	TDZA	T1,T1		;TURN OFF TIMER
SETTIM:	 MOVEI	T1,3		;SET TIMER FOR 3 SECONDS
	DPB	T1,UNYTIM
	POPJ	P,
SUBTTL	ONCE A SECOND TO CHECK FOR UNITS THAT ARE HUNG

UNISEC::HLRZ	U,SYSUNI
	DSKOFF			;NO INTERUPTS WHILE CODE IN PROGRESS
USCLP:	LDB	T1,UNYTIM
	SOJE	T1,USCLP1	;ONLY IF COUNTS DOWN TO ZERO
	SKIPL	T1
	 DPB	T1,UNYTIM	;PUT BACK IF WAS NOT ZERO
USCLP2:	HLRZ	U,UNISYS(U)	;NEXT UNIT IN SYSTEM
	JUMPN	U,USCLP
	DSKON
	PUSHJ	P,SATONC	;DO ONCE-A-SECOND SAT STUFF
	POPJ	P,		;END OF UNISEC

USCLP1:	MOVE	T1,UNISTS(U)
	XCT	HNGCOD(T1)	;DO APPROPRIATE ACTION
	JRST	USCLP2		;AND GET BACK TO THE CHECK

HNGCOD:	PHASE 0
ICOD:!	PUSHJ P,ZERTIM
PWCOD:!	PUSHJ P,ZERTIM	;THESE ARE MISTAKES, TIMER SHOULD NOT BE SET
PCOD:!	PUSHJ P,HNGPS	;POSITION OR SEEK HUNG
SWCOD:!	PUSHJ P,ZERTIM
SCOD:!	PUSHJ P,HNGPS
RSCOD:!	PUSHJ P,HNGRS
CWCOD::	PUSHJ P,ZERTIM
CCOD::	PUSHJ P,ZERTIM
TWCOD:!	PUSHJ P,ZERTIM
TWFCOD:!PUSHJ P,HNGT	;IOSEL not called, go start unstarted transfer
TCOD:!	PUSHJ P,HNGT	;HUNG IN TRANSFER
RCOD:!	PUSHJ P,HNGR	;HUNG IN RECAL
OWCOD:!	PUSHJ P,OFLUNI	;UNIT IS OFF-LINE
VWCOD:!	PUSHJ P,HNGT	;Hung waiting for other volume, start transfer
	DEPHASE

HNGR:	MOVEI	T1,PCOD		;SET TO PCOD SO GET TO TRANSFER WAIT
HNGPS:	SUBI	T1,1		;SET TO PW OR SW
	HRRZ	J,UNIKON(U)
	PUSHJ	P,@KONSTP(J)	;TRY TO STOP IT
	  SKIPA			;STOPPED, NOW RESTART
	 JRST	SETTIM		;STOPPED AND RESTARTED, RETIME
	MOVEM	T1,UNISTS(U)
	AOS	UNIHNG(U)	;RECORD HUNG RECOV FROM POS
	PUSHJ	P,HNGUNI	;Tell OPR about hung unit
	PUSHJ	P,ZERTIM	;RESET TIMER
	PJRST	IOSEL		;AND START I/O IF POSSIBLE

;Hung in transfer

HNGT:	MOVSI	T1,1		;INCREMENT LH OF UNIHNG
	ADDM	T1,UNIHNG(U)	;RECORD HUNG RECOV FROM TRANS
	PUSHJ	P,HNGUNI	;Tell OPR about hung unit
	HRRZ	J,UNIKON(U)
	PUSHJ	P,@KONSTP(J)	;TRY TO STOP
	  SKIPA			;OK
	 JRST	SETTIM		;STOPPED AND RESTARTED, RETIME
	MOVEI	T1,TWFCOD
	PUSHJ	P,IDL1		;Set UNISTS, zero timer, reset UNIBLK, idle KON
	PJRST	IOSEL		;Restart unit

IFE SAXN,<HNGRS==ZERTIM>	;RS applies to SA10 only
IFN SAXN,<
HNGRS:	AOS	UNIHNG(U)	;Hung trying to read sense bytes
	PUSHJ	P,HNGUNI	;Tell OPR about hung unit
	HRRZ	J,UNIKON(U)
	PUSHJ	P,@KONSTP(J)
	  JFCL
	PUSHJ	P,SETTIM
	PJRST	@KONRBL(J)	;READ BUFFERRED LOG (instead of latency)
>  ;End IFN SAXN
SUBTTL	OFFLINE and HUNG messages

;Unit is off line
OFLUNI:	MOVEI	T1,ALRACT
	IORM	T1,ALR620	;SET ALARM CELL
	MOVEI	T1,2		;Output to OPR and CTY
	PUSHJ	P,OPROUT##
	PUSHJ	P,INLMES
	 BYTE (7) 7,7,7,7,7	;SOME BELLS
	 ASCIZ /
Unit /
	MOVE	T2,UNINAM(U)
	PUSHJ	P,PRNAME
	PUSHJ	P,INLMES
	 ASCIZ / went off-line/
	MOVE	T2,UNIDES(U)
	TLNN	T2,UNPFUS	;CHECK UNSAFE
	 JRST	TELOP4
	PUSHJ	P,INLMES
	 ASCIZ / (file unsafe)/
TELOP4:	PUSHJ	P,INLMES
	 BYTE (7)7,7,7,7,7
	 ASCIZ /
Please cycle it off-line, then back on-line again.
/
	MOVEI	T1,^D60		;RESET TIME TO 1 MINUTE
	DPB	T1,UNYTIM
	POPJ	P,

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	This routine is called to report the occurrence of	;;
;;	a true "hung" state to the system operator.  It does	;;
;;	not matter if the hung condition is immediately		;;
;;	corrected, only that it occurred at all.		;;
;;								;;
;;	Entered with U - Unit Data Block address (preserved)	;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

HNGUNI:	MOVEI	T1,ALRACT	;It's the Accounting flag, but who's perfect?
	IORM	T1,ALR620	;Irritate the operator
	MOVEI	T1,2		;Set to output to both OPR and CTY
	PUSHJ	P,OPROUT##	;Change typeout routine
	PUSHJ	P,INLMES	;In-line message
	 BYTE (7) 7,7,7,7,7	;Bells (Clangor and Alarum)
	 ASCIZ	/
Unit /
	MOVE	T2,UNINAM(U)	;Get this unit's SIXBIT name
	PUSHJ	P,PRNAME	;Type it out
	PUSHJ	P,INLMES	;In-line message
	 ASCIZ	/ hung
/
	POPJ	P,
SUBTTL OHT (OUTPUT ERROR HASH TABLE)
COMMENT;@@ SUBROUTINE INSOHT
@@PURPOSE INSERT A DP ADDRESS IN THE OUTPUT ERROR HASH TABLE (OHT)
@@ENTRY T2 HAS DP ADDRESS. 1B0-1B8 MUST BE ZERO.
@@ PG has Core Page Number of Disk Page in T2.
@@ACCUM PRESERVES DP ADDRESS IN T2, CLEARS 1B0-1B8 IN T2,
SMASHES T1,T3,T4.
@@EXIT T2 HAS DP ADDRESS. T4 HAS INDEX, SO CALLER CAN SET BITS. ALWAYS RETURN NON-SKIP.
@@RESTRICTIONS CALL AT DISK INTERRUPT LEVEL OR DSK PI OFF ONLY,
ELSE CAN'T LOOK AT HEADER DATA (MAY BE CHANGED BY INSOHT, AND
THIS ROUTINE IS NOT REENTRANT.)
@@FUNCTION IF DP IS ALREADY IN OHT, RETURN.
OTHERWISE PUT DP IN OHT, INCREMENT OHTNUM, RETURN.
@@;

INSOHT::PUSHJ	P,SRCOHT	;SEE IF ITS THERE ALREADY
	  AOSA	OHTNUM		;NO, GOING TO PUT IT IN, INCREMENT
	JRST	INSOH2		;Count multiple calls for same DP,
				; overwrite OHTCPN entry, exit w/T4=index
	MOVSI	T4,-OHTLEN	;SET TO SEARCH OHTTAB FOR FREE CELL
INSOH1:	SETCM	T1,OHTTAB(T4)	;GET COMPLEMENT OF DATA
	TRNN	T1,-1		;IF ALL ZERO, THEN ITS FREE.
	  TLNE	T1,777		;SKIP IF FREE
	  JRST	INSOH3		;NOT FREE.
	LDB	T1,T3		;FREE. GET OLD FIRST
	DPB	T4,T3		;HEADER GETS NEW FIRST
	DPB	T1,[POINT OHTLNS,T2,OHTLNP]
	MOVEM	T2,OHTTAB(T4)	;STORE NEW DATA OVER THE -1
	TLZA	T2,777000	;CLEAR ALL BUT DISK ADDRESS.
INSOH2:	  AOS	OHTREP		;# times called gtr once for same DP
	TLZ	T4,-1		;Clear out crap
	ROT	T4,-1		;Make low-order bit the sign bit
	SKIPGE	T4
	 JRST	.+3
	HRLM	PG,OHTCPN(T4)	;Write CPN into even-numbered table entry
	SKIPA
	  HRRM	PG,OHTCPN(T4)	;Or odd-numbered entry
	ROT	T4,1		;Restore OHTTAB index
	POPJ	P,		;AND RETURN.

INSOH3:	AOBJN	T4,INSOH1	;NOT FREE, LOOK FOR ANOTHER, CRASH WHEN FULL
	 STOPCD (.,STOP,OHTFUL,,<Output Hash Table Full - Too many DP errors>);;INSOH3+1
COMMENT;@@SUBROUTINE REMOHT
@@PURPOSE REMOVE DP ADDRESS FROM OHT. CALLED BY REMOVE VP.
@@ENTRY T2 CONTAINS DP ADDRESS
@@ACCUM PRESERVES T2, SMASHES T1,T3,T4
@@EXIT  ALWAYS NON-SKIP.  DSK PI CHANNEL STATE DESTROYED.
@@RESTRICTIONS DP MUST BE IN OHT. CALL ONLY AT UUO LEVEL,
REMOHT CAN HAVE ONLY ONE CALLER AT A TIME.
@@FUNCTION CALL SRCOHT TO FIND THE ENTRY TO BE REMOVED.
TURN DSK PI CHANNEL OFF. IF PREVIOUS POINTER IS NOT THE HEADER
POINTER, JUST REMOVE THE ENTRY BY POINTING PREVIOUS POINTER
TO NEXT ENTRY, SET REMOVED ENTRY DATA TO -1. IF PREVIOUS WAS THE
HEADER, MAY HAVE BEEN CHANGED AFTER RETURN FROM SRCOHT
AND BEFORE DSKPIF. CHECK TO SEE THAT PREVIOUS POINTER
STILL POINTS TO FOUND ENTRY. IF NOT (NEW ENTRY SNUCK IN AT HEADER)
CHAIN THRU HASH CHAIN UNTIL FIND THE POINTER THAT POINTS TO
ENTRY TO BE REMOVED. CRASH IF CANNOT FIND REMOVED ENTRY
AGAIN. THEN REMOVE ENTRY NORMALLY.
@@;


REMOHT::PUSHJ	P,SRCOHT	;FIND THE ENTRY, MUST BE HERE OR CRASH
OHTENF:: STOPCD (.,STOP,OHTENF,,<Output error Hash Table - Entry not found>);;REMOHT+1
	DSKOFF			;TURN OFF DSK PI
	CAME	T1,T3		;DID SRCOHT GIVE US HEADER PTR?
	  JRST	REMOH2		;NO, ITS SAFE, ENTRIES ONLY ADDED AT HEAD
				; OF CHAIN, AND ONLY REMOVED AT UUO LEVEL.
REMOH1:	LDB	T1,T3		;HEADER. GET WHAT IT POINTS TO.
	CAMN	T1,T4		;MOST OF THE TIME, ITS OK.
	  JRST	REMOH2		;THIS IS STILL THE FIRST ENTRY
	CAIN	T1,ENDOHT	;MAKE SURE ENTRY DIDN'T VANISH
	 STOPCD (,XCT,OHTENF)	;; It did!  So, CRASH   ;;REMOH1+4
	MOVEI	T3,OHTTAB(T1)	;GET ADDRESS OF ENTRY
	HRLI	T3,(POINT OHTLNS,0,OHTLNP)	;FRESH BYTE POINTER
	JRST	REMOH1		;AND GIVE THAT IF WHAT IT POINTS TO IS ENTRY
				; THAT IS GOING AWAY.

REMOH2:	SOS	OHTNUM		;ONE LESS NOW.
	LDB	T1,[POINT OHTLNS,OHTTAB(T4),OHTLNP] ;GET NEW NEXT MEMBER
	DPB	T1,T3		;PREVIOUS POINTER POINTS TO NEXT
	SETOM	OHTTAB(T4)	;THIS WORD NOW FREE.
	DSKON		;ALLOW INSERTIONS AGAIN.
	POPJ	P,		;RETURN.
COMMENT;@@SUBROUTINE SRCOHT
@@PURPOSE USED WHEN SEARCHING OHT OR WHEN INSERTING OR DELETING
AN ENTRY FROM OHT. CALLERS SHOULD DO SKIPN OHTNUM BEFORE
CALLING TO SAVE TIME.
@@ENTRY T2 CONTAINS DP ADDRESS TO SEARCH FOR.
CAN CALL BOTH AT INTERRUPT AND UUO LEVEL.
@@ACCUM USES T1,T3,T4. PRESERVES T2.
@@EXIT IF DP NOT FOUND, NON-SKIP RETURN WITH
	T3/ BYTE POINTER TO HEADER FIELD.
	     (USE ONLY IF CALLING AT DSK IRP LEVEL OR DSKPIF)
IF DP IS FOUND, SKIP RETURN WITH
	T1/ HEADER POINTER (FOR VALIDITY CHECK OF T3).
	T3/ BYTE POINTER TO LAST LINK FIELD (MUST BE CHECKED, SEE
	     RESTRICTIONS)
	T4/ INDEX OF DP'S CELL.
@@RESTRICTIONS CALLER MUST CHECK VALIDITY OF LAST LINK POINTER

IF IT POINTS TO THE HEADER BYTE BY TURNING OFF DSK PI CHANNEL

AND MAKING SURE A NEW ENTRY DID NOT SNEAK IN IF ENTRY IS FOUND.

IF ENTRY IS NOT FOUND, CALLER MUST NOT USE BYTE POINTER TO HEADER FIELD
UNLESS DSK PI IS OFF OR AT DSK PI LEVEL, ELSE DATA COULD CHANGE.
@@FUNCTION COMPUTE HASH INDEX FOR DP. GET BYTE POINTER TO PROPER
HEADER BYTE FOR HASH CODE. IF CONTENTS OF HEADER IS ENDOHT,
RETURN WITH THE BYTE POINTER TO THE HEADER. ELSE, SAVE THE
POINTER TO THE HEADER. LOOK FOR THE DP. IF FOUND, GIVE SKIP
RETURN WITH BYTE POINTER TO PREVIOUS MEMBER (OR HEADER)
IN T3, INDEX IN T4. IF NOT FOUND, RETURN WITH BYTE
POINTER TO HEADER BYTE IN T3.  NOTE THAT A NEW ENTRY CAN SNEAK IN
WHILE SEARCHING, BUT NEW ENTRIES ARE ADDED TO BEGINNING OF
CHAIN ONLY, SO WORST THAT CAN HAPPEN IS THAT SEARCH WILL FAIL
TO FIND ENTRY THAT SNUCK IN, BUT THIS IS NO WORSE
THAN IF ENTRY SNUCK IN AFTER RETURN FROM SRCOHT.
CHAIN IS ALWAYS INTACT, REMOHT ONLY CALLED AT UUO LEVEL.
@@;

SRCOHT::MOVE	T3,T2		;COPY SO DON'T DESTROY T2
	IDIVI	T3,OHTLEN	;GET DP'S HASH INDEX IN T4
	MOVE	T3,T4		;GET INTO T3 FOR IDIVI AGAIN
	IDIVI	T3,OHTHPW	;INDEX TO OHTBYT IN T4, TO OHTHED IN T3.
	ADD	T3,OHTBYT(T4)	;GET POINTER TO HEADER FIELD.
	LDB	T4,T3		;GET FIRST ENTRY INDEX
	CAIN	T4,ENDOHT	;CHAIN EMPTY?
	POPJ	P,		;YES, RETURN WITH T3 POINTER TO HEADER BYTE
	PUSH	P,T3		;REMEMBER POINTER TO HEADER IN CASE SEARCH FAILS
SRCOH1:	MOVE	T1,T2		;COPY DP ADDRESS
	XOR	T1,OHTTAB(T4)	;T1 HAS INDEX IN 1B0-8, XOR IN THE REST
	TRNN	T1,-1		;SKIP IF ANY DIFFERENT BITS IN RH
	TLNE	T1,ENDOHT	;SKIP IF ALL BITS THE SAME IN RH OF LH
	JRST	SRCOH2		;NO MATCH.
	TLNN	T3,-1		;IF NOT THE HEADER POINTER,
	ADD	T3,[POINT OHTLNS,OHTTAB,OHTLNP] ;TURN T3 INTO POINTER TO LINK.
	POP	P,T1		;THROW AWAY HEADER POINTER
	JRST	CPOPJ1		;MATCHING CELL IN T4. SKIP RETURN.

SRCOH2:	LDB	T1,[POINT OHTLNS,T1,OHTLNP] ;GET INDEX.
	CAIN	T1,ENDOHT	;THIS THE LAST CELL?
	JRST	[POP P,T3	;GET HEADER POINTER IN T3 TO RETURN
		 POPJ P,]	;AND GIVE FAIL RETURN.
	MOVE	T3,T4		;NOT DONE, REMEMBER LAST INDEX
	MOVE	T4,T1		;GET NEXT TO DO IN T4
	JRST	SRCOH1		;AND GO CHECK FOR A MATCH
;ROUTINE TO INIT OHT. PRESERVES T2-T4, SMASHES ONLY T1.

OHTINI::SETOM	OHTHED		;HEADER BYTES ALL ONES, ALL SLOTS -1.
	MOVE	T1,[OHTHED,,OHTHED+1]
	BLT	T1,OHTTAB+OHTMAX
	SETZM	OHTNUM
	POPJ	P,

IFNDEF OHTLEN,<OHTLEN==77>
IFGE <OHTLEN-100>,<PRINTX OHTLEN MUST BE LESS THAN 100 OCTAL>

OHTMAX==OHTLEN-1		;MAX INDEX POSSIBLE


	ENDOHT==1B<^L<OHTMAX>-1>-1	; ALL ONES IN FIELD IS END SIGNAL.

;BITS IN OHT

XP OHTDER,(1B0)		;DEVICE ERROR
XP OHTDTE,(1B1)		;DATA ERROR
XP OHTPAR,(1B2)		;PARITY ERROR ON DIRTY CORE PAGE.

OHTLNM==<ENDOHT>B8	;MASK FOR LINK FIELD
OHTLNP==^L<OHTLNM&-OHTLNM> ;RIGHTMOST BIT OF FIELD
OHTLNS==OHTLNP-^L<OHTLNM>+1

OHTDPM==777,,777777	;FOR THE RECORD, DISK PAGE MASK.

OHTHPW==^D36/OHTLNS	;NUMBER OF HEADER POINTERS PER WORD.
OHTNUM::0
OHTREP:	0		;Count of repeat calls for same DP

OHTBYT:

	ZZ==OHTLNS
REPEAT OHTHPW,<
	POINT OHTLNS,OHTHED,ZZ-1
	ZZ==ZZ+OHTLNS>
OHTHED:	BLOCK	<OHTLEN+OHTHPW-1>/OHTHPW ;HEADER BYTES.
OHTTAB::BLOCK	OHTLEN
OHTCPN:	BLOCK	<OHTLEN+1>/2	;Halfword Core Page Number entries

	$END	(FIO)		;End of FILIO  (FIOLIT: FIOEND:)
    w@c