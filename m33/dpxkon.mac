TITLE DPXKON - DEVICE DEPENDENT RP10(RP01/RP02/RP03) DRIVER V2045
SUBTTL  T WACHS/TH  7 JUL 71

	S$NAME='DPXKON'

XP VDPKON,2045		;DEFINE VERSION FOR GLOB AND MAP

;ASSEMBLY INSTRUCTIONS:  DPXKON,DPXKON/C_S,KONPAR,DPXKON

;ALL INTERN AND EXTERN DECLARATIONS:

ENTRY	DPXKON
INTERN	DPXPOS,DPXRED,DPXWRT,DPXADD,DPXFIN,DPXLTM,DPXINT
INTERNAL DPXUPA,DPXCPY,DPXRCL,DPXSTP,DPXSTS
EXTERN	DPXCO1,DPXCIT,DPXDI1,DPXDO1,DPXDOT
EXTERN	CPOPJ1,TPOPJ,DFCADD

BSYBIT==20		;DP KONTROL BUSY
STPBIT==20		;STOP DP(CLEAR BUSY, SET DONE
			; CAUSE INTERRUPT)
ALLERR==377720!DFCERR
CLEAR==175710
ATTNS==776
STATBT==176		;READY, ONLINE, UNSAFE,NO SUCH DEV, RD ONLY
STATB2==174		;ALL EXECPT READ ONLY
UNSAFE==10		;FILE UNSAFE
SEKINC==100
ENDCYL==200000
OFLRET==3	;NUMBER OF TIMES TO CHECK OFF-LINE BITS

CORPAR==12	;CHAN-DETECTED CORE PARITY ERROR BITS
NXMERR==10000	;CHAN-DETECTED NXM
DONE==10

PARDIS==5000		;DISABLE STOP ON PAR ERROR

;THESE LOCATIONS ARE DEFINED IN COMMON FOR EACH KONTROL
;THEY ARE INDEXED BY J:

REPEAT	0,<
DPXCO1:	CONO	DP'N,(T2)
DPXDOT:	DATAO	DP'N,T1
DPXDO1:	DATAO	DP'N,T2
DPXDI1:	DATAI	DP'N,T2
DPXCIT:	CONI	DP'N,T1
>

DPXKON:		;CAUSE LOADING ON LIBRARY SEARCH

DPXADD=DFCADD
;CONTROL CODES FOR DISK PACK (RP-10C)

REDCOD==0	;READ
WRTCOD==1	;WRITE
POSCOD==4	;POSITION (SEEK)
NOPCOD==5	;AT EASE, NO-OP, CLEAR ATTENS
SELCOD==6	;DRIVE SELECT
RCLCOD==7	;RECAL

EXTERNAL UNYPPY,KONCOM,UNYBPT,KONIOC,KOYPI,KCMOFL,KCMFUS
EXTERNAL FILINT,UNIKON,UNYPUN,UNIBLK,UNICYL
EXTERNAL UNPDEV,KONCUA,ETSGTI,ETSCCO,ETSCCA,ETSBCN,ETSUNI
EXTERNAL DFCCNT,KCMDTA,KCMERR,KONWRT,UNIRCT,KONSWC
EXTERNAL KONCPY,KONPTR,UNIPPU,UNYUTP

;ERROR AND OTHER STATUS BITS

CYLXTR==200000	;EXTRA CYLINER BIT FOR CYLS ABOVE 377

;CONI BITS

POWFAL==1B20	;POWER FAILURE
SRCERR==1B21	;EARCH ERROR
DLATE==1B22	;DATA LATE
NOTRDY==1B25	;NOT READY (NEED DATAI TO SEE WHY)
ILLWRT==1B26	;ILLEGAL WRITE
ILLDTO==1B27	;ILLEGAL DATAO
SECADR==1B28	;SECOR ADDRESS ERROR
SRFADR==1B29	;SURFACE ADDRESS AERROR

BIT22==(1B13)	;DF-10 IS 22-BIT
CWPAR==(1B14)	;COMMAND WORD PARITY ERROR FROM MEM
SECPAR==(1B15)	;SECTOR PARITY ERROR
CHLPAR==(1B16)	;CHANNEL PARITY ERROR
WRDPAR==(1B17)	;DISK WORD PARITY ERROR

;DATAI BITS

POSFL==(1B11)	;POSITION FAILURE
HINPS==(1B12)	;HEADS IN POSITION
DSKONL==(1B13)	;DISK ON-LINE
NDRV==(1B15)	;NO SUCH DRIVE

;SOFTWARE DETECTED ERROR BITS

DFCERR==1B18	;DATA CHANNEL WORD COUNT INCORRECT ON TERM
DPXRED:	MOVEI T4,REDCOD
	JRST DPXGO
DPXWRT:	MOVEI T4,WRTCOD
DPXGO:	PUSHJ P,SETINS	;SET UP A DATAO COMMAND
	LDB	P2,UNYPPY	;GET NUMBER OF BLOCKS PER CLY
	LSH	P2,2
	SUB P2,T3	;SUBTRACT POSITIN IN CYL (FROM SETINS)
	LSH P2,7	;CONVERT TO WORDS
	MOVE P1,KONCOM(J)	;WHERE TO PUT COMMANDS
	LDB T4,UNYBPT
	IDIV T3,T4
	DPB T3,[POINT 5,T1,18]	;SURFACE
	DPB T4,[POINT 4,T1,23]	;SECTOR
	IOR T1,KONIOC(J)	;INITIA;L CONTROL WORD
	MOVE P3,T1
	ANDI T1,776	;GET JUST THE ORIGINAL ADDRESS
	HRRZM P1,(T1)	;POINT TO THE COMMAND CHAIN( JUST IN CASE)
	SETZM 1(T1)	;AND ZERO THE CHANNEL STORE WORD
	SETZM KONSWC(J)	;SAVED WORD COUNT IS ZERO
	POPJ P,		;DONE WITH THIS

DPXPOS:	MOVEI T4,POSCOD
POS1:	PUSHJ P,SETINS
POS2:	LDB T2,KOYPI
	XCT DPXDOT(J)	;SEND THE SEEK
	XCT DPXCO1(J)	;AND MAKE SURE PI CHANNEL THERE
	XCT DPXDI1(J)	;READ STATUS
	TLC T2,DSKONL	;INVERT TO MAKE IT OFF-LINE
	TLNN T2,DSKONL!UNSAFE	;SEE IF NOT THERE
	POPJ P,		;NOT ON, CAN GO AHEAD
	LDB T3,UNYPUN
	MOVSI T1,(1B0)
	MOVNS T3
	LSH T1,(T3)
	ANDCAM T1,KONCPY(J)	;RESET CPY BITS IN CASE OFF-LINE
	MOVSI T1,KCMOFL	;SET FOR UNIT OFF LINE
	TLNE T2,UNSAFE
	TLO T1,KCMFUS	;SET UNSAFE
	PJRST FILINT	;AND SIMULATE INTERUPT

DPXRCL:	MOVEI T4,RCLCOD
	JRST POS1	;GO WITH RECAL

SETINS:	HRRZ T1,UNIKON(U)
	CAIE T1,(J)	;JUST TO MAKE SURE
	STOPCD
	LDB T1,UNYPUN
	ROT T1,-6	;GET UNIT IN CORRECT POS
	DPB T4,[POINT 3,T1,2]	;SET CODE
	MOVE T2,UNIBLK(U)
	LDB	T3,UNYPPY	;GET BLOCKS/CYL
	LSH	T3,2
	IDIV T2,T3
	DPB T2,[POINT 8,T1,13]	;SET CYL
	TRNE T2,400
	TRO T1,CYLXTR	;EXTRA CYLINDER BIT
	MOVEM T2,UNICYL(U)	;AND SAVE FOR REST OF WORLD
	POPJ P,

DPXFIN:	SETZM (P1)	;GENERATE AN END OF LIST
	LDB T2,KOYPI
	MOVE T1,P3	;GET THE COMMAND WE SAVED
	HRRZM U,KONCUA(J)	;SAVE UNIT FOR DATA INTERUPT
	XCT DPXDOT(J)	;SEND COMMAND
	XCT DPXCO1(J)	;AND SET CHANNEL
	POPJ P,
;ROUTINE TO COMPUTE LATENCY TIME FOR A UNIT LESS A SAFETY FACTOR
; TO INSURE THAT A COMPLETE REVOLUTION WILL NOT BE MISSED
; 0 FOR AN ANSWER MEANS CLOSEST POSSIBLE NEXT BLOCK

REPEAT 0,<
TABLE SHOWING INSTANEOUS TIME RELATION BETWEEN SECTOR COUNTER
AND ACTUAL SECTOR POSITION FOR RPO2 AND RP01 UNITS:

SECTOR COUNTER:
	20
!19!! 0! 1! 2! 3! 4! 5! 6! 7! 8! 9!10!11!12!13!14!15!16!17!18!19!
RP02:
	!  9  !  0  !  1  !  2  !  3  !  4  !  5  !  6  !  7  !  8  !
RP01:
	!     4     !     0     !     1     !     2     !     3     !
>

DPXLTM:	HRRZ T2,UNIKON(U)
	CAIE T2,(J)
	STOPCD
	LDB	T2,UNYPUN	;PHYSICAL UNIT NO. ON THIS CONTROLLER
	ROT	T2,-6		;SHIFT TO UNITS POSITION FOR DATAO
	TLO	T2,<SELCOD>B20	;SET OPERATION TO SELECT
	XCT	DPXDO1(J)	;DO A DATAO DPX,T2 TO SELECT UNIT
	XCT	DPXDI1(J)	;DO A DATAI DPX,T2 TO READ SECTOR COUNTER
	XCT	DPXDI1(J)	;READ A SECOND TIME SINCE COUNTER IS
				; STROBBED INTO BUFFER ON TRAILING EDGE OF DATAI
	LDB	T4,[POINT 5,T2,22]	;GET ACTUAL HALF SECTOR COUNTER
	LDB	T3,UNYBPT	;NO. OF BLOCKS PER TRACK(REVOLUTION)
	IDIVI	T1,(T3)		;T2 GETS DESIRED SECTOR NO.(RP02=0-9;RP01=0-4)
	LSH	T2,1		;CONVERT TO HALF SECTOR LIKE HARDWARE
	CAIE	T3,^D10		;IS THIS AN RP02?
	ADDI	T2,2(T2)	;NO, MUST BE RP01, CONVERT TO QUARTER SECTOR
				; PLUS 2
	SUB	T2,T4		;DESIRED HALF SECTOR - MOD20(ACTUAL HALF SECT+2)
				; GIVES NO. OF HALF(QUART) SECTORS TO WAIT
				; TO GET TO DESIRED HALF(QUART) SECTOR(-20 THRU +20)
	HRREI	T1,0(T2)	;MOVE NO. OF HALF SECTORS TO WAIT
				; SINCE HARDWARE CONVENIENTLY HAS A BUILT
				; IN SAFETY FACTOR, NO NEED TO SUBTRACT
				; ANYTHING HERE.
	JUMPGE	T1,DPXLT1	;IF DISTANCE IS NEGATIVE
	ADDI	T1,^D20		;ADD NO. OF HALF SECTORS IN ONE REVOLUTION
				; SINCE DISK SPINS IN ONE DIRECTION
DPXLT1:	IMULI	T1,^D1250	;CONVERT HALF SECTORS TO MICROSECONDS
	POPJ P,

;HERE WHEN A UNIT HANGS DURING A TRANSFER (IE DOES NOT INTERRUPT)
;ATTEMPT TO CLEAR CONTROL AND CAUSE AN INTERRUPT

DPXSTP:	HRRZ T2,UNIKON(U)
	CAIE T2,(J)
	STOPCD
	MOVEI	T2,STPBIT	;STOP THE UNIT BIT
	XCT	DPXCO1(J)	;STOP UNIT AND CLEAR PI (SO NO INT.)
	SETZM KONCUA(J)	;NOTHING ACTIVE
	LDB	T2,KOYPI	;PI FOR THIS KONTROLLER
	TRO T2,CLEAR	;CLEAR ALL STATUS BITS
	XCT	DPXCO1(J)	;RESTORE PI AND GET INTERRUPT (CONO DPX,T2)
	POPJ	P,		;OK OR ERROR RETURN
;HERE FROM COMMON ON AN INTERRUPT
;ACS HAVE BEEN SAVED, J AND P SET UP
DPXINT:	XCT DPXDI1(J)	;DATAI
	PUSH P,T2
	ANDI T2,ATTNS
	ROT T2,-11
	PUSH P,T2
	XCT DPXCIT(J)	;CONI WORD
	TRZ T1,DFCERR	;ELIMINATE THIS BIT TO USE FOR SOFTWARE
	PUSH P,T1
	TDNE T2,KONCPY(J)	;IS IT A CAPACITY WAITER?
	JRST DPXCPN	;YES, SEE WHATS GOING ON
CPYINT:	SKIPN U,KONCUA(J)	;NON-ZERO ONLY IF DATA INTERUPT
	JRST CLRATN		;NON-DATA
	MOVE T2,KONIOC(J)
	PUSHJ P,DFCCNT	;GET COUNT
	MOVEI T2,DFCERR
	CAME T1,KONSWC(J)	;IS IT THE SAME AS SAVED?
	IORM T2,(P)	;NO, SER SOFTWARE ERROR BIT
	MOVSI T2,SECPAR
	TDNE T2,(P)
	SUBI T1,1	;COUNT IS 1 TOO HIGH IN THIS CASE
	ADDI T1,177	;NOW CONVERT TO BLOCKS
	LSH T1,-7
	SKIPG T1
	MOVEI T1,1	;IN CASE ZERO WORDS TRANS ON LAST ERR
	HRRM T1,-1(P)
	MOVE T1,(P)	;GET CONI BACK
	CAMN U,ETSUNI
	PUSHJ P,ETSCN	;FAKE ERRORS
	TRNN T1,ALLERR	;ANY ERRORS?
	JRST DATFIN	;NO, FINISH UP
	TRNE T1,NOTRDY	;IS IT NOT-READY
	JRST DPXOFL	;OFF-LINE, UNSAFE, OR SEEK INCOMPLETE
	SKIPE UNIRCT(U)	;IS THIS THE FIRST ONE?
	JRST DATERF	;NO, JUST MARK ERROR FLAG
	TRNE T1,DFCERR
	MOVE T2,CHLRCV	;TREAT JUST LIKE A CHANNEL PROBLEM
	TRNE T1,ENDCYL	;NOW CHECK EACH ERROR CONDITION
	MOVE T2,ECYRCV	;AND LOAD THE RECOVERY CODE
	TLNE T1,SECPAR!WRDPAR	;DISP ARITY ERROR
	MOVE T2,DPRRCV
	TRNE T1,SRCERR	;SEARCH ERROR
	MOVE T2,SRCRCV
	TDNE T1,[CWPAR!CHLPAR,,NXMERR!DLATE]
	MOVE T2,CHLRCV	;SOME KIND OF CHANNEL-MEMORY ERROR
	TRNE T1,POWFAL!ILLDTO!ILLWRT!SECADR!SRFADR!BSYBIT
	MOVE T2,HWFRCV	;HARDWARE (OR PROGRAM) FAULT
DATRF1:	MOVEM T2,UNIRCT(U)	;SAVE RECOVERY PATTERN
DATERF:	MOVSI T1,KCMERR
	IORM T1,-1(P)	;SET ERROR STATUS
DATFIN:	MOVSI T1,KCMDTA	;SET DATA FLAG
	IORM T1,-1(P)
	LDB T1,[POINT 3,-2(P),2]	;GET UNIT FROM DATAI
	LDB T2,UNYPUN
	CAME T1,T2	;MUST BE THE SAME
	STOPCD
ERROFL:	SETZM KONCUA(J)	;NO MORE DATA INTERUPS EXPECTED
CLRATN:	MOVE T2,-2(P)
	ANDI T2,ATTNS
	JUMPE T2,INTXIT	;NOTHING TO CLEAR
	HRLI T2,<NOPCOD>B20
	XCT DPXDO1(J)	;CLEAR THE ATTENTION BITS
INTXIT:	LDB T2,KOYPI
	TRO T2,CLEAR
	XCT DPXCO1(J)
	POP P,T2
	POP P,T1
	POP P,T3
	JRST FILINT	;AND GO

DPXOFL:	MOVE T1,-2(P)	;GET DATAI
	TLNE T1,POSFL	;CHECK FOR POSITION FAILURE
	JRST DPXSIC	;SEEK INCOMPLETE
	MOVSI T2,KCMOFL
	TLNE T1,UNSAFE
	TLO T2,KCMFUS
	IORM T2,-1(P)	;SET BITS FOR FILSER
	JRST ERROFL

DPXSIC:	SKIPE UNIRCT(U)
	JRST DATERF	;ALREADY SEEN ONE ERROR
	MOVE T2,SEKRCV
	JRST DATRF1	;SET RECOVERY PATTERN AND GO

	DEFINE RCV(RTY,RCL,RRT,MOD)
<	XWD RRT+200000+UNPDEV*MOD,RCL_9+RTY>

;	MACRO HAS RETRY BEFORE RECAL,RECAL, RET AFTER RECAL,
;	1 FOR DEVICE ERROR, 0 FOR DATA ERROR

ECYRCV:	RCV(3,0,0,1)	;END OF CYLINDER
DPRRCV:	RCV(3,2,20,0)	;PARITY
SRCRCV:	RCV(1,5,5,0)	;SEARCH ERROR - TREAT AS DATA ERR
CHLRCV:	RCV(^D100,0,0,1)	;MEMORY PROBLEM
HWFRCV:	RCV(1,0,0,1)	;HARDWARE OR PROGRAMMING PROBABLY PERMANENT
SEKRCV:	RCV(0,10,2,1)	;SEEK INCOMPLETE
;ROUTINE TO FORCE A HARDWARE ERROR ON CONI AFTER TRANSFER INTERRUPT
;CALL:	MOVE	T1,CONI BITS AFTER DATA TRANSFER INTERRUPT
;	PUSH	P,T1		;PUT ON STACK TOO
;	CAMN	U,ETSUNI	;IS THIS UNIT BEING ERROR TESTED?
;	PUSHJ	P,ETSCN		;YES
;	RETURN WITH T1 MODIFIED

ETSCN:	SOSL	ETSGTI		;NO. OF GOOD TRANSFER INT FINISHED?
	POPJ	P,		;NO, DO NOT FAKE AN ERROR YET
	OR	T1,ETSCCO	;YES, SET SPECIFIED ERROR BITS
	ANDCM	T1,ETSCCA	;CLEAR OTHERS
	MOVEM	T1,-1(P)	;STORE ON STACK TOO
	SOSGE	ETSBCN		;HAD ENOUGH BAD CONI'S YET?
	SETZM	ETSUNI		;YES, STOP ALL FURTHER FAKE ERRORS
	POPJ	P,		;RETURN
;HERE TO SEE IF AN RP-10 KONTROLLER IS UP

DPXUPA:	LDB	T2,KOYPI	;PI CHANNEL FOR THIS KONTROLLER
	TRO	T2,CLEAR	;CLEAR ALL ERROR FLAGS
	SETZM KONCUA(J)	;JUST TO MAKE SURE
	XCT	DPXCO1(J)	;DO THE CONO
	MOVSI T2,(1B0)
	ANDCAM T2,KONWRT(J)	;RESET 22 BIT FLAG
	MOVE	T1,[<NOPCOD>B2+ATTNS]
	XCT	DPXDOT(J)
	XCT	DPXCIT(J)
	TLNE T1,BIT22	;TEST FOR 22BIT DF-10
	IORM T2,KONWRT(J)	;IT IS, SET A FLAG
	TRNE	T1,7		;CONTROLLER ON-LINE?
	TRNE	T1,ALLERR-ENDCYL-NOTRDY	;YES. TEST ALL BUT DISK NRDY
	POPJ	P,
	JRST	CPOPJ1

;SUBROUTINE TO GET STATUS OF A UNIT
; ENTER WITH U=UNIT DATA BLOCK ADR. J=KONTROLLER DATA BLOCK ADR.
; RETURN WITH T2=UNIT STATUS FROM DATAI, GOOD-BITS ARE COMPLEMENTED
; SO ERRORS CAN BE CHECKED EASILY

DPXSTS:	MOVEI	T2,CLEAR	;ENTRY TO CLEAR CONO
	XCT	DPXCO1(J)	;DO THE CONO TO RP10
CLRSET:	LDB	T1,UNYPUN	;UNIT NUMBER
	ROT	T1,-6		;POSITION TO DRIVE FIELD
	TLO	T1,<NOPCOD>B20	;SET OPERATION = NOP
	TLC	T1,10000	;FIRST CONNECT TO ANOTHER DRIVE
	XCT	DPXDOT(J)	;SO THAT RECONNECTING TO RIGHT
	TLC	T1,10000	;DRIVE WILL GIVE GOOD STATUS INFORMATION
	XCT	DPXDOT(J)	;DATAO DPN,T1
	XCT	DPXDI1(J)	;DATAI DPN,T2
	TLC	T2,DSKONL!HINPS		;INVERT BITS WHICH SHOULD BE 1
	POPJ	P,		;AND EXIT
;HERE TO CHECK CAPACITY & STATUS OF A UNIT

DPXCPY:	MOVEI T1,^D255
	MOVEM T1,UNICYL(U)	;SET CYL AS FLAG
	LDB T2,UNYPUN
	MOVN T3,T2
	MOVSI T1,(1B0)
	LSH T1,(T3)
	IORM T1,KONCPY(J)
	MOVSI T1,(BYTE (3) POSCOD,0 (8)^D255)
	DPB T2,[POINT 3,T1,5]	;ISSUE SEEK, UNIT MARKED
	SETZM UNIBLK(U)	;NO SPECIAL MESSAGE
	JRST POS2

DPXCPN:	AND T2,KONCPY(J)	;T2 HAS ATTENTION BITS IN LH
	ANDCAM T2,-1(P)	;RESET BITS FOR FILINT
	MOVE T1,T2
	ROT T1,11	;GET BITS IN CORRECT PLACE
	ANDCAM T1,-2(P)	;RESET BITS FOR ATTENTION CLEAR
	TLO T1,(<NOPCOD>B2)	;RESET ATTENSIONS FOR THESE
	XCT DPXDOT(J)
	MOVEI P3,0	;NO SWW WHO IS THERE
DPXCP1:	JFFO T2,.+2
	JRST CPYINT	;FINISHED, GO FINISH INTERUPT PROCESS
	LSH T2,1(T3)	;GET RID OF BITS
	ADD P3,T3
	SKIPN U,@KONPTR(J)
	AOJA P3,DPXCP1	;FORGET IT IF NOT REALLY THERE
	PUSH P,T2	;SAVE BITS
	PUSHJ P,DPXSTS	;GET STATUS
	MOVE T3,UNICYL(U)
	CAIE T3,^D255
	JRST DPXCP3	;EIRTHER RP03 OR RP07
	TLNN T2,SEKINC	;DID WE GET AN INCOMPLETE?
	JRST DPXCP2	;NO, SHOULD BE RP03 OR RP07, TRY ANOTHER SEEK
DPXRP2:	MOVEI T3,1	;RPPO2
DPXCPD:	TLNE T2,2	;IS THE STATUS WRITE PROTECT?
	TLO T3,(1B1)	;YES, SET BIT
	MOVEM T3,UNIBLK(U)	;SAVE IN UNIBLK
	DPB T3,UNYUTP	;SET UNIT TYPE
	LDB T1,BYTBPU
	LSH	T1,-2
	MOVEM	T1,UNIPPU(U)
	LDB T1,BYTBPY
	LSH	T1,-2
	DPB	T1,UNYPPY
	LDB T1,BYTBPT
	DPB T1,UNYBPT	;SSET PARAMETERS
	SETOM UNICYL(U)
	LDB T2,UNYPUN
	MOVN T3,T2
	MOVSI T1,(1B0)
	LSH T1,(T3)
	ANDCAM T1,KONCPY(J)	;RESET BIT
	ROT T2,-6
	TLO T2,<RCLCOD>B20
	XCT DPXDO1(J)
	POP P,T2
	AOJA P3,DPXCP1	;TRY SOME MORE UNITS
;HERE TO TEST IF RP03 OR RO07

DPXCP3:	TLNE T2,SEKINC
	JRST DPXRP2	;SEEK INCOMPLETE, TREAT AS RP02
	MOVEI T3,2	;RP07
	TRNE T2,010000
	MOVEI T3,3	;RP03
	JRST DPXCPD	;FINISHED, DO THE RECAL

;HERE IF CYL 255 IS OK, SEEK TO CYL 256

DPXCP2:	MOVEI T1,^D256
	MOVEM T1,UNICYL(U)
	MOVE T1,[<POSCOD>B2+CYLXTR]
	DPB P3,[POINT 3,T1,5]
	XCT DPXDOT(J)
	POP P,T2
	AOJA P3,DPXCP1	;AND GO

BYTBPU:	POINT 24,CAPDAT(T3),35
BYTBPY:	POINT 8,CAPDAT(T3),11	;BLOCKS/CYLINDER
BYTBPT:	POINT 4,CAPDAT(T3),3	;BLOCKS/TRACK

CAPDAT:	BYTE (4) 5 (8) 5 (24) ^D1000	;RP01 (NONE OF THESE)
	BYTE (4)^D10(8)^D200(24)^D40000	;RP02
	BYTE (4)^D10(8)^D200(24)^D51200	;RPO7
	BYTE (4)^D10(8)^D200(24)^D81200	;RP03

	END
  