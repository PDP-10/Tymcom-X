;This file must be assembled with TYMSER.MAC+TTYSYM.MAC+SCNSER.MAC
SUBTTL TYMSER - TYMNET VERSION OF SCNSER

	STOPCD(,ENTRY,TYMSER)

;Entry points:
ENTRY	UPDKEY	;Updates KEY620, called 60 times a second from CH1 interrupt
ENTRY	CHKBAS	;Checks if nonzero in 30 was caused by the base
ENTRY	SCNINT	;Called at clock level to read IRING and write to ORING
ENTRY	SCNSEC	;Once a second code

	TYMVER==1	;Version number reported to the base
	TYMREL==0	;Release number reported to the base

;THE 620 AND PDP-10 SHARE CORE AS A MEANS OF COMMUNICATION.
;THE 620 PUTS THINGS DESTINED FOR THE PDP-10 INTO A RING
;BUFFER AND VICE VERSA. THE PDP-10 EXAMINES THE STATE OF THE
;RING BUFFER EVERY CLOCK TICK. FOR OUTPUT, THE PDP-10 NEVER
;PUTS OUT MORE THAN 30 (=%CHRMX) CHARACTERS ON A GIVEN LINE
;WITHOUT CHECKING THE INPUT RINGS IN CASE THE 620 REQUESTS
;THE PDP-10 TO STOP DOING OUTPUT ON THAT LINE.

;NOTE VERY CAREFULLY THAT THESE ROUTINES DEPEND ON THE FACT THAT
;CLOCK LEVEL NEVER INTERRUPTS UUO LEVEL AND VICE VERSA.
;FOR THIS REASON THERE ARE NO INTERLOCKS BETWEEN THE TWO
;LEVELS. ANYONE WHO CHANGES THIS BEWARE!!!!!!!!!!

SUBTTL	TABLE OF CONTENTS
		;Insert table of contents here
SUBTTL	HOST TO BASE AND BASE TO HOST MESSAGE TYPES

;Buffer ring message formats

;Each logical record in the buffer ring is some number of 8-bit bytes.
;These start on a word boundry, the last 4 bits of each PDP-10 word are
;ignored, and records currently do not wrap around in the buffer.

;The first byte of each logical record is the message type, the next 8 bits
;is the port number.  If the high order bit is set in the message type, then
;the remaining 7 bits in the first byte specify the number of characters that
;follow.  Otherwise the first byte is a command code.

;BASE HOST    "{"=from host, "}"=to host, "#"=crash, "-"=ignore
;00##00	UNUSED, ERROR
;TYP.00,xxx,xxx,xxx

;01{-01	SYSTEM IS ANSWERED, IGNORED ON INPUT BY KI/KL/F3, CHECKED BY KS
TYPANS==01 ;xxx,xxx,xxx

;02{-01	SYSTEM IS SHUT, IGNORED ON INPUT
TYPSHT==02 ;xxx,xxx,xxx

;03{}03	RESET THE INTERFACE, QUIETLY ZAP ALL CIRCUITS (DR11 IS BAD ON KS)
TYPRES==03 ;DEBUGF,VER,REV      (used to be TYPCRS - sender has crashed)

;04#}04	RESET ACKNOWLEGE, TELL DEBUG STATUS, VERSION NUMBER, REVISION LEVEL
TYPRAK==04 ;DEBUGF,VER,REV      (used to be TYPDIE - recipient should crash)

;05#}05	THE NODE HAS BEEN TAKEN OVER BY A NEW SUPERVISOR
TYPNSP==05 ;000,xxx,xxx

;06#}06	EXTERNALLY INITIATED NEW CIRCUIT.  TREAT NEXT SET OF DATA BYTES SPECIAL
TYPLOG==06 ;PORT,xxx,xxx

;07#}07	SUPERVISOR RESPONSE TO ESTABLISHING AN AUX CIRCUIT
TYPAUX==07 ;NEWPORT,KEY,xxx

;08{}10	BACKPRESSURE ON
TYPNOP==10 ;PORT,xxx,xxx

;09{}11	BACKPRESSURE OFF
TYPOUP==11 ;PORT,xxx,xxx

;0A{}12	CHARACTER GOBBLER, IGNORED ON INPUT
TYPGOB==12 ;PORT,xxx,xxx

;0B{}13	CIRCUIT ZAPPER, RECIPIENT MUST ECHO ZAPPER ON SAME PORT
TYPZAP==13 ;PORT,xxx,xxx

;0C{}14	ENTER DEFERED ECHO MODE
TYPEDC==14 ;PORT,xxx,xxx

;0D{}15	LEAVE DEFERRED ECHO MODE
TYPLDC==15 ;PORT,xxx,xxx

;0E{}16	GREEN BALL
TYPGRN==16 ;PORT,xxx,xxx

;0F{}17	RED BALL
TYPRED==17 ;PORT,xxx,xxx

;10{}20	YELLOW BALL
TYPYEL==20 ;PORT,xxx,xxx

;11{}21	ORANGE BALL
TYPORG==21 ;PORT,xxx,xxx

;12{-22	HANG CHARACTER (DROP DTR, DON'T ZAP CIRCUIT, IGNORED ON INPUT)
TYPHNG==22 ;PORT,xxx,xxx

;13{-23	ENTER 2741 TRANSPARENT MODE (IGNORED ON INPUT)
TYPETM==23 ;PORT,xxx,xxx

;14{-24	LEAVE 2741 TRANSPARENT MODE (IGNORED ON INPUT)
TYPLTM==24 ;PORT,xxx,xxx

;15#}25	LOST BALL.  BLACK BALL IF DATA=FF, GRAY BALL IF DATA=00
TYPLOS==25 ;PORT,DATA,xxx

;16{#26	REQUEST NEW PORT NUMBER FOR BUILDING AUX CIRCUIT (KEY RETURNED BY 07)
TYPSUP==26 ;KEY,000,xxx

;17#}27	SUPERVISOR RESPONSE, 3RD BYTE IS ERROR CODE
TYPSUR==27 ;KEY,ERRCODE,xxx

;18{#30	SUPERVISOR LOGIN CHARACTER IN 3RD BYTE
TYPAXC==30 ;KEY,CHAR,xxx

;19{#31	TEST PATTERN PROBE (32 BITS OF TEST DATA)
TYPTSP==31 ;PORT,DATA1,DATA2,  DATA3,DATA4,xxx,xxx

;1A#}32	TEST PATTERN RESPONSE
TYPTSR==32 ;PORT,DATA1,DATA2,  DATA3,DATA4,xxx,xxx

;1B{#33	HOST SAD, 32 UNHAPPY BITS
TYPSAD==33 ;000,DATA1,DATA2,  DATA3,DATA4

;1C{#34	ECHO ON
TYPECN==34 ;PORT,xxx,xxx

;1D{#35	ECHO OFF
TYPECF==35 ;PORT,xxx,xxx

;1E{#36	SET TERMINAL CHARACTERISTICS, NUMBER AND VALUE
TYPTCS==36 ;PORT,TCHNUM,VALUE

;1F{#37	TERMINAL CHARACTERISTICS PROBE, FOR A PARTICULAR TCHNUM
TYPTCP==37 ;PORT,TCHNUM,xxx

;20#}40	TERMINAL CHARACTERISTICS RESPONSE, ANSWER TO PROBE
TYPTCR==40 ;PORT,TCHNUM,VALUE

;21{#41	TELL SUPERVISOR NUMBER OF PORTS AND HOST NUMBER
TYPHSI==41 ;MAXPORT,HOST#,xxx

;22{#42	REQUEST FOR SUPERVISOR CLOCK INFO (BASE IGNORES THIS)
TYPCLP==42 ;xxx,xxx,xxx

;23#}43	RESPONSE WITH SUPERVISOR CLOCK INFO IN SECONDS SINCE 1-JAN-1974
TYPCLR==43 ;000,DATA1,DATA2,  DATA3,DATA4,xxx,xxx

;24{#44	INITIATE BLOCK OUTPUT
TYPBKO==44 ;PORT,COUNT1,COUNT2,  ADDR1,ADDR2,ADDR3,xxxx

;25#}45	BLOCK OUTPUT COMPLETE
TYPBOC==45 ;PORT,xxx,xxx

;26{#46	INITIATE BLOCK INPUT
TYPBIN==46 ;PORT,COUNT1,COUNT2,  ADDR1,ADDR2,ADDR3,xxxx

;27#}47	BLOCK INPUT TERMINATED - OUT OF BUFFER
TYPINB==47 ;PORT,COUNT1,COUNT2

;28#}50	BLOCK INPUT TERMINATED - END OF TRANSMISSION
TYPINE==50 ;PORT,COUNT1,COUNT2

;29#}51	BLOCK INPUT TERMINATED - TIMEOUT BY BASE
TYPINT==51 ;PORT,COUNT1,COUNT2

;2A{#52	REQUEST BLOCK INPUT TERMINATION
TYPIRQ==52 ;PORT,xxx,xxx

;2B#}53	BLOCK INPUT TERMINATED - BY HOST REQUEST
TYPIHR==53 ;PORT,COUNT1,COUNT2

;2C{#54	REQUEST BLOCK OUTPUT TERMINATION
TYPORQ==54 ;PORT,xxx,xxx

;2D#}55	BLOCK OUTPUT TERMINATED - BY HOST REQUEST
TYPOHR==55 ;PORT,xxx,xxx

;2E{}56	NEGOTIATE FOR NUMBER OF BLOCK I/O PORTS
TYPNEG==56 ;PORT,DATA,xxx

;2F#}57	BREAK RECIEVED
TYPBRK==57 ;PORT,xxx,xxx

;30#}60	PORT STATUS RECEIVED  (Obsolete, not in EBUS, see comment at ACPSM)
TYPPSR==60 ;PORT,DATA,xxx

;31{-61	ENTER ALTERNATE DEVICE MODE (TURN ON PRINTER), IGNORED ON INPUT
TYPEAD==61 ;PORT,xxx,xxx

;32{-62	LEAVE ALTERNATE DEVICE MODE (TURN OFF PRINTER), IGNORED ON INPUT
TYPLAD==62 ;PORT,xxx,xxx

;33{#63	SET KEEP-ALIVE-FAILURE TIMER
TYPKAF==63 ;000,DATA1,DATA2
SUBTTL	Special KS2020 microcode for KMC

IFKMC<
	BYP1==^D9	;RIGHTMOST BIT POSITION OF FIRST BYTE
	BYP2==^D17	;      SECOND BYTE OF A BUFFER RING WORD
	BYP3==^D27	;      THIRD BYTE
	BYP4==^D35	;      LAST BYTE POSITION IN A BUF RING WORD
	OPDEF	UUILDB	[101000,,0]	;KMC ILDB
	OPDEF	UUIDPB	[102000,,0]	;KMC IDPB
	OPDEF	EXTEND	[123000,,0]	;EXTENDED INSTRUCTION OPCODE
	OPDEF	MOVSLJ	[016000,,0]	;MOVE STRING LEFT JUSTIFIED
	DEFINE	TYPI(TYPE)		;FOR LOADING TYPES WITH A
	<TYPE_^D8>			;	MOVSI INSTR
	>;END IFKMC
IFNKMC<
	BYP1==^D7	;RIGHTMOST BIT POSITION OF FIRST BYTE
	BYP2==^D15	;      SECOND BYTE OF A BUFFER RING WORD
	BYP3==^D23	;      THIRD BYTE
	BYP4==^D31	;      LAST BYTE POSITION IN A BUF RING WORD
	OPDEF	UUILDB	[ILDB 0]	;NORMAL ILDB
	OPDEF	UUIDPB	[IDPB 0]	;NORMAL IDPB
	DEFINE	TYPI(TYPE)		;FOR LOADING TYPES WITH A
	<TYPE_^D10>			;	MOVSI INSTR
	>;END IFNKMC
SUBTTL	IRING/ORING byte pointers

;Pointers for reading from the IRING

INPTYP:	POINT 8,IRING(P4),BYP1	;TYPE
INPLIN:	POINT 8,IRING(P4),BYP2	;LINE NUMBER
INPCHR:	POINT 8,IRING(P4),BYP3	;CHARACTER
INPCH2:	POINT 8,IRING(P4),BYP4	;SECOND DATA CHARACTER
INPDL1:	POINT 16,IRING(P4),BYP2	;FIRST TWO CHRS
INPDL2:	POINT 16,IRING(P4),BYP4	;SECOND TWO CHRS

;Pointers for writing to the ORING

OUPTYP:	POINT 8,ORING(P4),BYP1	;TYPE
OUPLIN:	POINT 8,ORING(P4),BYP2	;PORT NUMBER

;Pointers for building message in P3 for use with MOVEM P3,ORING(P4)

WRPLIN:	POINT 8,P3,BYP2		;PORT NUMBER (TYPE is set via TYPI macro)
WRPCHR:	POINT 8,P3,BYP3		;DATA CHARACTER
WRPCH2:	POINT 8,P3,BYP4		;SECOND DATA CHARACTER
WRP3N4:	POINT 16,P3,BYP4	;Bytes 3 and 4
SUBTTL	DEFINE RECEIVED CHARACTERISTICS BYTE POINTERS

ZZWORD==0
ZZPOS==-1
DEFINE TC(N,W) <IFG <ZZPOS+W>-^D35,<ZZPOS==-1
ZZWORD==ZZWORD+1>
ZZPOS==ZZPOS+W
LDP'N:	POINT W,LDBTMR+ZZWORD(U),ZZPOS>

TABTMR:	TERCHR
SUBTTL	DEFINE SENT CHARACTERISTICS BYTE POINTERS

ZZWORD==0
ZZPOS==-1
DEFINE TC(N,W) <IFG <ZZPOS+W>-^D35,<ZZPOS==-1
ZZWORD==ZZWORD+1>
ZZPOS==ZZPOS+W
LDS'N:	POINT W,LDBTMS+ZZWORD(U),ZZPOS>

TABTMS:	TERCHR
	MAXTMC==.-TABTMS-1
INTERN LDSRXE	;CTYSIM needs this pointer
TMCSLP==^D21	;IF MAXTMC .lt. TMC .ge. MAXTMC+TMCSLP, WE WILL
		;IGNORE TYMNET MESSAGES FOR THE <TMC> RATHER
		;THAN CRASHING (THIS LETS TYMNET GET AHEAD OF US)
TCBALL:	<-1 _ <^D36-TCNN>>
SUBTTL CHARACTER TABLES

;HERE IS THE CHARACTER TABLE. IT INCLUDES A CHARACTER MODE FOR
;EACH OF INPUT, OUTPUT, ECHO, AND READ (BY PROGRAM). IT ALSO
;INCLUDES A SPECIAL ACTION CODE FOR EACH OF THESE.

DEFINE CHRATR (INP,OUT,RED,ECH,SPAI,SPAO,SPAR,SPAE)
	<BYTE (2) INP,OUT (3) SPAO,RED,ECH,SPAR (5) SPAI (4) SPAE>

CHPINP:	POINT 2,P3,1	;POINTER TO THE INPUT FIELD
CHPOUT:	POINT 2,P3,3	;POINTER TO THE OUTPUT FIELD
CHPSPO:	POINT 3,P3,6	;POINTER TO THE OUTPUT SPECIAL ACTION FIELD
CHPRED:	POINT 3,P3,9	;POINTER TO THE READ FIELD
CHPECH:	POINT 3,P3,12	;POINTER TO THE ECHO FIELD
CHPSPR:	POINT 3,P3,15	;POINTER TO THE READ SPECIAL ACTION FIELD
CHPSPI:	POINT 5,P3,20	;POINTER TO THE INPUT SPECIAL ACTION FIELD
CHPSPE:	POINT 4,P3,24	;POINTER TO THE ECHO SPECIAL ACTION FIELD

SALL
CHRTAB:
SUBTTL	CONTROL CHARACTERS

CHRATR 0,2,2,2,0		;NULL
CHRATR 0,2,2,2,13		;^A
CHRATR 2,2,2,2			;^B
CHRATR 0,2,0,0,1,0,0,0		;^C
REPEAT 3,<
CHRATR 2,2,2,2>			;^D,^E,^F
CHRATR 2,2,2,3			;^G
CHRATR 0,0,0,0,17,4,6,11	;BACKSPACE
CHRATR 0,0,0,0,6,1,5,3		;^I
CHRATR 2,2,2,3			;LINE FEED
CHRATR 2,0,2,0,0,2,0,5		;VERTICAL TAB
CHRATR 2,0,2,0,0,3,0,6		;FORM FEED
CHRATR 0,0,1,0,2,0,0,1		;RETURN
CHRATR 2,2,2,2			;^N
CHRATR 0,2,2,2,3		;^O
CHRATR 2,2,2,2			;^P
CHRATR 0,2,2,2,4		;^Q
REPEAT 2,<
CHRATR 2,2,2,2>			;^R,^S
CHRATR 0,2,2,2,20		;^T
CHRATR 0,2,2,0,5,0,0,2		;^U
REPEAT 4,<
CHRATR 2,2,2,2>			;^V,^W,^X,^Y
CHRATR 2,2,0,0,0,0,3,7		;^Z
CHRATR 0,2,0,0,7,0,1,4		;ESCAPE (33)
CHRATR 0,2,2,2,16		;^\
CHRATR 2,2,2,2			;^]
CHRATR 0,2,2,2,10		;^^
CHRATR 0,2,0,2,11,0,2,0		;^_
SUBTTL	NUMBERS AND PUNCTUATION

REPEAT 20,<
CHRATR 3,1,3,4>			;PUNCTUATION
REPEAT 12,<
CHRATR 1,1,1,1>			;0-9
REPEAT 7,<
CHRATR 3,1,3,4>			;PUNCTUATION
SUBTTL	UPPER CASE

REPEAT 32,<
CHRATR 1,3,1,1>			;A-Z
REPEAT 4,<
CHRATR 3,1,3,4>			;PUNCTUATION
CHRATR 0,1,3,4,15		;_ (FOR TYMEX2 MODE)
CHRATR 3,1,3,4			;^
SUBTTL	LOWER CASE

REPEAT 32,<
CHRATR 1,1,4,1>			;a-z
REPEAT 2,<
CHRATR 3,1,3,4>			;PUNCTUATION
CHRATR 0,1,0,0,14,0,4,10	;ALTMODE (175) OR }
CHRATR 0,1,0,0,14,0,4,10	;ALTMODE (176) OR ~
CHRATR 0,2,2,2,12		;RUBOUT (177)
COMMENT ;
SUMMARY OF MEANING OF FIELDS

INPUT
	0-SPECIAL ACTION
	1-NORMAL CHARACTER
	2-BREAK CHARACTER
	3-CLASS 2 BREAK CHARACTER

OUTPUT
	0-SPECIAL ACTION
	1-OUTPUT AND COUNT FOR FREE RETURN
	2-OUTPUT BUT DO NOT COUNT
	3-UPPER CASE CHARACTER

REMOTE ECHO
	0-SPECIAL ACTION
	1-COUNT FOR FREE RETURN
	2-DO NOT COUNT FOR FREE RETURN
	3-SAME AS 2
	4-SAME AS 1

DEFERED ECHO
	0-SPECIAL ACTION
	1-PRINT CHARACTER AND COUNT FOR FREE RETURN
	2-BREAK CHARACTER, DO NOT PRINT, DO NOT COUNT
	3-BREAK CHARACTER, PRINT, DO NOT COUNT
	4-CLASS 2 BREAK CHARACTER, PRINT AND COUNT
	5-IMAGE CHARACTER
	6-BREAK CHARACTER, PRINT AND COUNT

READ
	0-SPECIAL ACTION
	1-NORMAL CHARACTER
	2-BREAK CHARACTER
	3-CLASS 2 BREAK CHARACTER
	4-LOWER CASE CHARACTER
;

;DEFINE STOP CHARACTERS (ESCAPES) FOR VARIOUS MODES

STOP10==3	;^C
STOP9==37	;^_
SUBTTL	Channel 1 interrupt processing

KEY10:	633751506262		;Magic value that TYMNET BASE wants to see

;UPDKEY - Update the KEY 60 times per second, at channel 1 level
;Called by JSP T1,UPDKEY    (T2 is scratch).

UPDKEY::MOVE	T2,KEY10		;Set key for TYMNET
KEYSET::EXCH	T2,KEY620##		;(JFCL if base is not being used)
	SKIPN	T2			;If it was zero,
	 SETZM	KEYTIM##		; reset KEY620 timer
	SKIPE	T2			;If zero,
	CAMN	T2,KEY10		; or the value we set,
	 SKIPA				;OK
	  MOVEM	T2,BADKEY		;Remember bad key for later
	MOVE	T2,UPTIME##		;Get current system uptime
	SKIPE	DINITF##		;Is ONCE initializing the disks?
	 MOVEM	T2,THSTIM##		;Yes, make THSTIM look current
	SUB	T2,THSTIM##		;Check on how long since SCNTIC ran
	CAML	T2,JFYMIN##		;More than one minute?
KAF1::	 STOPCD (,XCT,S..KAF)		;Keep alive failure
	JRST	(T1)			;Return to PICON

;CHKBAS - Check if the nonzero value in 30 came from the base.
;Called by JSP T1,CHKBAS whenever CRSHWD is nonzero.
;T2 is scratch, stack is not set up.
;Error return of PDP-10 should crash, skip return to continue.

CHKBAS::LDB	T2,[POINT 16,CRSHWD,15]	;Check if first 16 bits
	CAME	T2,ORP620		; match the base's ORING pointer
	CAMN	T2,ORPOLD
	 SKIPA				;OK
	  JRST	(T1)			;No match, don't blame it on base
	LDB	T2,[POINT 16,CRSHWD,31]	;Check if second 16 bits
	CAME	T2,IRP620		; match the base's IRING pointer
	CAMN	T2,IRPOLD
	 SKIPA
	  JRST	(T1)			;No match, don't blame it on base
	SETOM	BASDWN##		;Base problems.  Mark it as down
	MOVEI	T2,^D15000		;Delay for about 1/60th of a second
	SOJG	T2,.			; for base to write into KEY620
	MOVE	T2,KEY620##		;Get the key
	CAMN	T2,KEY10		;If we overwrote it,
	 MOVE	T2,BADKEY		; get previous value
	MOVEM	T2,KEY620##		;Reset it if necessary
	LSH	T2,^D<16-36>		;Get 16 bits of KEY620
	MOVEM	P,SCN1PD		;Need a stack for STOPCD
	MOVEI	P,SCN1PD
	CAIN	T2,04			;Did base complain about a bad message?
	 STOPCD (.,STOP,BASE04,PRTCRS,<Bad message type from host>)
	 STOPCD (.+1,INFO,BASE,PRTCRS,<BASE has crashed - bad KEY620>)
	MOVE	P,SCN1PD		;Restore AC
	SETZM	CRSHWD##		;Clear out location 30 to keep system up
	JRST	1(T1)			;Skip return back to PICON

SCN1PD:	BLOCK	2			;Dummy stack for PUSHJ P,DIE

;Here from PRTIRP to output SAV30, ORP620, IRP620, and KEY620

PRTCRS:	PUSHJ	P,INLMES##
	 ASCIZ /ORP620: /
	MOVE	T1,ORP620
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##
	 ASCIZ /  IRP620: /
	MOVE	T1,IRP620
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##		;Called from STOPCD(BASE),STOPCD(BASE04)
	 ASCIZ /   SAV30: /
	MOVE	T1,SAV30##		;Saved contents of CRSHWD
	PUSHJ	P,HWDPNT##
	PUSHJ	P,INLMES##
	 ASCIZ / = /
	LDB	T1,[POINT 16,SAV30,15]	; Get Base ORING pointer field
	PUSHJ	P,PRTOCT##
	PUSHJ	P,PRCOM##		;Comma
	LDB	T1,[POINT 16,SAV30,31]	; Get Base IRING pointer field
	PUSHJ	P,PRTOCT##
PRTKEY::PUSHJ	P,INLMES##		;Here from STOPCD(CRASH)
	 ASCIZ /   Key: /
	MOVE	T1,KEY620		;Get Key value
	CAMN	T1,KEY10
	 JRST	[JSP T1,CONMES##
		 ASCIZ /OK
/]
	LSH	T1,^D<16-36>		;Get high order 16 bits and
	PUSHJ	P,PRTOCT##		; print as an octal number.
	PJRST	CRLF##			;Finish the line.

COMMENT ~	Values stored in KEY620 when the Varian base goes down
* 00="Normal - host going down - key not refreshed.",
  01="Host crashing due to base crash.",
  02="MIC error or MIC reject tring to read key.",
* 03="Read bad key from host.",
* 04="Bad data type or port number from host.",  HOST MUST CRASH
  05="Illogical data type from host.",
  06="MIC busy trying to read host (IN10).",
  07="Input ring processing time-out.",
* 10="MIC time-out error (sen 337).",
* 11="Parity error from MIC (sen 237).",
* 12="MIC busy for 232 cycles in addr portion of 'look'.",
  13="Host told base to crash...this is a no-no!!",
  14="MIC busy (look) from prior operation in 'look'.",
  15="Overran block i/o table.",
  16="Terminate block input req. is invalid.",
  17="Base crash...power failure.",
  20="Base crash...manual restart.",
  21="Base crash....",
**22="Base crash...GCI crash.", BASE CRASHES ITSELF
  23="Base crash...WCD crash.",
**24="Base crash...WCI crash.", BASE CRASHES ITSELF
* 25="Base crash...GCOL crash.",
  26="Base crash...speed crash.",
  27="Base crash...unidentified crash.",
  30="Base crash....",
  31="Base crash...WWI crash.",
  32="Base crash...empty crash.",
  33="Base crash...parity error.",
  34="Base crash...bad 201 interrupt.",
  35="Base crash....",
  36="Base crash....",
  37="Base crash....";
**120="Bad ISIS message.", BASE CRASHES ITSELF
**140="Bad stack usage.", BASE CRASHES ITSELF
**202="Buss Error.", BASE CRASHES ITSELF
**203="Address Error", BASE CRASHES ITSELF
**204="Illegal Instruction.", BASE CRASHES ITSELF
**354="Engine told 68K to crash.", BASE CRASHES ITSELF
**355="Split Char Pair.", BASE CRASHES ITSELF
~  ;End of COMMENT
SUBTTL INPUT RING DISPATCHER

;HERE EVERY TICK FROM CHANNEL 7

    ;KEEP TRACK OF MAXIMUM INTER-CALL DELAY

SCNINT::MOVE	T4,UPTIME	;Check on how long it has been since SCNSER
	EXCH	T4,THSTIM##	; last had a chance to run
	JUMPL	T4,SCNNT0	;Don't check on the very first tick
	SUB	T4,THSTIM##
	MOVNS	T4
	CAMLE	T4,MXTIM##
	 MOVEM	T4,MXTIM##	;Save maximum so far
	AOS	KEYTIM##	;Increment # of ticks since key was reset
	AOS	IRPTIM##	;          # of ticks since last input message
	AOS	ORPTIM##	;          # of ticks since last output message

    ;CHECK FOR CTY OUTPUT

SCNNT0:	SKIPG	CTYLDB+LDBTOC	;If there are characters for the CTY
	SKIPGE	CTYBLF		; or if someone wants to ding its bell,
	 PUSHJ	P,OPRCTY	; go do it
	PUSHJ	P,CTYINP##	;Check for input on the CTY
	  JFCL			;No input (character in T3 if CTYINP skips)

    ;CHECK IF RING NEEDS TO BE RESET

	SKIPN	T1,BASDWN##	;Has base crashed or 10 in system restart?
	 JRST	SCNTIC		;No, rings are fine
;BASDWN=-1 means base has crashed or is not responding.
;BASDWN=+1 means system startup - ask for date/time from the supervisor.
	SKIPG	T1		;Startup?
	 PUSHJ	P,DETALL	;No, detach all jobs when base dies
	SETZB	T2,IRPPDP
	EXCH	T2,IRP620	;Reset IRING pointers
	SKIPE	T2
	 MOVEM	T2,IRPOLD	;Save old pointer for CHKBAS
	SETZB	T2,ORPPDP
	EXCH	T2,ORP620	;Reset ORING pointers
	SKIPE	T2
	 MOVEM	T2,ORPOLD	;Save old pointer for CHKBAS
IFCPU (F3),<
	PUSHJ	P,FNSYNC	;Synchronize with the PDP-11 base
	  POPJ	P,		;Not ready yet, try again next time
>;END IFCPU F3
	MOVE	P4,ORPPDP	;Get current ORING pointer (starts at zero)
	MOVE	P3,[<TYPRAK>B<BYP1>+<TYMVER>B<BYP3>+<TYMREL>B<BYP4>]
	SKIPL	BASDWN		;Send reset-ack if base died, CLK at startup
	 MOVE	P3,[<TYPCLP>B<BYP1>+<TYMVER>B<BYP3>+<TYMREL>B<BYP4>]
	SKIPGE	DEBUGF##	;System being debugged?
	 TLO	P3,(1B<BYP2>)	;Yes, set LSB of 2nd byte
	MOVEM	P3,ORING(P4)	;Put first message in ring
	PUSHJ	P,ORPLOG	;Put message into ORING log
	ADDI	P4,1
	MOVSI	P3,TYPI TYPHSI	;Message type 41
	MOVEI	T1,RPORTN##	;Number of real porFKMC<	LPERDR==<^D16>*4	;ONE OF 64. 32. or 16. LINES PER DR
	;LPERDR must match that defined in the KMC microcode
	MAXDR==RPORTN##/LPERDR	;HIGHEST DR = # OF PORTS/LINES PER DR
	TRZ	T1,3		;Must have a multiple of 4
	CAIL	T1,LPERDR	;Determine lines on 1st node
	 MOVEI	T1,<LPERDR-1>&74;Must be a multiple of 4 .LT. ^D64
>;END IFKMC
	DPB	T1,WRPLIN	;Highest port number we will accept
	MOVE	T1,SYSNUM##	;Our host number
	DPB	T1,WRPCHR	; in 3rd byte
	MOVEM	P3,ORING(P4)
	PUSHJ	P,ORPLOG	;Put message into ORING log
	ADDI	P4,1
	MOVEM	P4,ORPPDP	;Let base see those 2 messages
IFKMC<	MOVEI	T1,<4320000&<7777_<3*MAXDR>>>_-9
		;T1/4320 or 320 or 20 or 0 (SEE DRFLAG:) SO AS TO PUT
		;OUT 41 MESSAGES TO DRs 2,3 & 4 IF THEY ARE THERE
	SETZ	W,		;INITIALIZE W FOR NON-PTY OUTPUT
	MOVSI	P3,TYPI TYPHSI	;41 MESSAGES
	PUSHJ	P,MDRMSG
>;END IFKMC
	SETZM	BASDWN##	;Flag that we think the base is up
	SETZM	BASVER##	;Zero version number for BASEOK message
	SETZM	BADKEY		;Reset saved bad key
	POPJ	P,		;Come back next tick

    ;CHECK OTHER UNUSUAL OUTPUT REQUESTS

SCNTIC:	SETZ	W,		;LET OUTPUT CODE KNOW IT'S REAL NOT PTY OUTPUT
	PUSHJ	P,SETOUT
	  JRST	SCNIN		;NO ROOM FOR CHARACTERS
	SKIPN	P3,UPSHUT	;IS THERE A SHUT OR ANSWERED MESSAGE
	 JRST	SCNNT2
IFNKMC<	PUSHJ	P,CLSCHR	;JUST FOR THE SAKE OF GOOD FORM
	  JRST	SCNIN		;DON'T UNDERSTAND HOW WE GOT HERE BUT OK
	SETZM	UPSHUT		;WILL SEND NOW, MARK NO MORE MSG
	PUSHJ	P,WRDOUT	;SEND IT
	  JRST	SCNIN		;THE LAST OF THE SPACE
>;END IFNKMC
IFKMC<	PUSHJ	P,MDRUP		;GET 3-BIT UP FLAGS
	HLRZ	P3,P3
	CAIN	P3,TYPI TYPSHT
	 MOVEM	T1,DRMSHT
	CAIN	P3,TYPI TYPANS
	 MOVEM	T1,DRMANS
	SETZM	UPSHUT>;END IFKMC
SCNNT2:	PUSHJ	P,SNDSAD	;SEND A SAD MESSAGE IF APPROPRIATE
	  JRST	SCNIN
IFKMC<	PUSHJ	P,SNDHSI	;SEE IF ANY DRs NEED A TYPHSI MSG ETC.
	  JRST	SCNIN>;END IFKMC
	PUSHJ	P,SNDAUX	;Check progress on AUX circuit builds
	  JRST	SCNIN		;OUT OF ROOM NOW
IFCPU (<KI,KL>), <	;TYMNET BASES REQUIRE BIO PORT NEGOTIATION,
			; NEXILIS BASES DO NOT
	SKIPGE	BIOCNT+0	;ANY CHANGE IN THE NUMBER OF BIO PORTS?
	PUSHJ	P,SNDBIO	;REQUEST TO THE BASE.
	  JRST	SCNIN
> ;END IFCPU (<KI,KL>)
SUBTTL	HERE TO PROCESS ALL THE MESSAGES IN THE INPUT RING, THEN
;JUMP TO OUTPUT CODE. FSCN GETS SET TO -1 IF ANY MESSAGES
;WERE PROCESSED.

SCNIN:	MOVE	P4,IRPPDP
	CAMN	P4,IRP620	;Anything in the input ring?
	 JRST	SCNOUT		;No, try output ring
	SETOM	FSCN		;Yes, flag that we found something
IFCPU (<F3,KS>),<
	SKIPGE	IRPTIM##	;Is this the first message after base went down?
	 STOPCD (,XCT,BASEOK)	;Yes, output BASEOK message
>  ;End IFCPU(F3,KS)
	SETZM	IRPTIM##	;Reset IRING timer
	MOVE	T1,IRP620	;Remember current IRING pointer so that
	MOVEM	T1,IRPSTP	; we can tell when it is time to pause input
				; and send backpressure on lines that need it
SCNIN0:	CAMN	P4,IRPSTP	;Processed all data present at start of pass?
	 JRST	SCNOUT		;Yes, go do output
	PUSHJ	P,IRPLOG	;No, LOG current IRING data, P4=INDEX
;;;;;;;;BEGIN KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKMC<
	MOVE	P1,IRPMB2	;SAVE PREVIOUS BASE POINTER
	MOVEM	P1,IRPMB3
	MOVE	P1,IRPMB1	;SAVE PREVIOUS BASE POINTER
	MOVEM	P1,IRPMB2
	MOVE	P1,IRP620
	MOVEM	P1,IRPMB1	;SAVE CURRENT BASE POINTER TOO

	MOVE	P1,IRPMP2	;SAVE PREVIOUS MESSAGE POINTER
	MOVEM	P1,IRPMP3
	MOVE	P1,IRPMP1	;SAVE PREVIOUS MESSAGE POINTER
	MOVEM	P1,IRPMP2
	MOVEM	P4,IRPMP1	;SAVE MESSAGE POINTER TOO

	MOVE	P1,IRPMS2	;SAVE PREVIOUS MESSAGE
	MOVEM	P1,IRPMS3
	MOVE	P1,IRPMSG	;SAVE PREVIOUS MESSAGE
	MOVEM	P1,IRPMS2
	MOVE	P1,IRING(P4)	;SAVE FIRST WORD OF MESSAGE IN IRPMSG
	MOVEM	P1,IRPMSG
>;END IFKMC
;;;;;;;;END KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	LDB	P1,INPTYP	;P1/ MESSAGE TYPE
	LDB	U,INPLIN	;U/ PORT #
	CAILE	U,RMXLIN##
	 JRST	BADPRT		;Check if message does not use port number
BADPR1:	MOVE	U,LINTAB(U)	;U/ PORT LDB
	HLL	U,LDBDCH(U)
	TRZE	P1,200		;IF 200 BIT SET, IT'S DATA
	 JRST	CHRMLT		;P1 has count of characters to be input
	CAILE	P1,MXTYP	;Check if in range
TTYBMT:: STOPCD (SCNIN2,INFO,TTYBMT,PRTIRG,<Bad Message Type from Base>);;CNTPRT-1
CNTPRT:	XCT	TYPTRN(P1)	;DISPATCH TO IT
SCNIN1:	ANDI	P4,MSKIRG	;MASK FOR WRAP AROUND
	MOVEM	P4,IRPPDP	;PUT IT AWAY FOR 620
	JRST	SCNIN0		;GO SEE IF MORE INPUT

SCNIN2:	AOJA	P4,SCNIN1	;Ignore this word, go get next one

;Check for legal messages that do not have port number in 2nd byte

BADPRT:	CAIE	P1,TYPANS	;(1) Answered, port = 0
	CAIN	P1,TYPSHT	;(2) Shut, port = 0
	 JRST	CNTPRT
	CAIE	P1,TYPRES	;(3) Reset, port = flag bits (0,1,200,201)
	CAIN	P1,TYPRAK	;(4) Reset ack, port = flag bits
	 JRST	CNTPRT
	CAIE	P1,TYPNSP	;(5) New supervisor, port = 0
	CAIN	P1,TYPSUR	;(27) Supervisor Response, port = key
	 JRST	CNTPRT
	CAIE	P1,TYPTSR	;(32) Test pattern response, port = data
	CAIN	P1,TYPCLR	;(43) Clock Response, port = 0
	 JRST	CNTPRT
	MOVEI	U,0		;Use port 0 if out of range
	STOPCD (BADPR1,INFO,TTYBPN,PRTIRG,<Bad Port Number from Base>);;BADPRT+3
PRINTF([TTYBPN needs filter to skip multi-word IRING messages to continue])

;PRTIRG - Print PDP-10 ring pointers, and word at IRING+IRPPDP for STOPCD

PRTIRG::PUSHJ	P,INLMES##	;Called from stopcodes TTYBMT,TTYBPN,CTYBMT
	 ASCIZ /ORPPDP: /
	MOVE	T1,ORPPDP
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##
	 ASCIZ /  IRPPDP: /
	MOVE	T1,IRPPDP
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##	;Output word that IRPPDP points to
	 ASCIZ /   IRING+/
	MOVE	P4,IRPPDP	;In case called from CTYBMT in CTYSIM
	HRRZ	T1,P4
	PUSHJ	P,PRTOCT##
	PUSHJ	P,INLMES##
	 ASCIZ \/ \
	LDB	T1,INPTYP	;Message type
	PUSHJ	P,PRTOCT##
	PUSHJ	P,PRCOM##
	LDB	T1,INPLIN	;Get port number (U has LDB address)
	PUSHJ	P,PRTOCT##
	PUSHJ	P,PRCOM##
	LDB	T1,INPCHR	;Get first data byte
	PUSHJ	P,PRTOCT##
	PUSHJ	P,PRCOM##
	LDB	T1,INPCH2	;Get 2nd data byte
	PUSHJ	P,PRTOCT##
	PUSHJ	P,CRLF##
	PJRST	PRTCRS		;Output ORP620 and IRP620
SUBTTL	IRING message type dispatch table

TYPTRN:	PHASE	0		;Use XCT TYPTRN(P1)
TYP.00:	 STOPCD (,XCT,TTYBMT)	; 0 ILLEGAL
TYPANS:	JRST	RCVANS		; 1 KMC ANSWERED, IGNORED BY KL & KI
TYPSHT:	AOJA	P4,SCNIN1	; 2 SHUT, IGNORE
TYPRES:	JRST	RCVRES		; 3 BASE CRASHED AND RELOADED OR DR-11 DIED
TYPRAK:	JRST	RCVRAK		; 4 BASE ACK TO MESSAGE TYPE 3
TYPNSP:	JRST	RCVNSP		; 5 TAKEOVER OF BASE, RESET AUX CIRS
TYPLOG:	JRST	LOGIN		; 6 START LOGIN PROCESS ON THIS PORT
TYPAUX:	JRST	RCVAUX		; 7 AUX CIRCUIT PORT ESTABLISHED
TYPNOP:	PUSHJ	P,NOOUT		;10 BACKPRESSURE ON
TYPOUP:	PUSHJ	P,DOOUT		;11 BACKPRESSURE OFF
TYPGOB:	PUSHJ	P,GOBCHR	;12 CHR. GOBBLER, CLEAR INPUT BUFFER
TYPZAP:	PUSHJ	P,RCVZAP	;13 CIRCUIT ZAPPER
TYPEDC:	PUSHJ	P,EDEC		;14 ENTER DEFFERED ECHO MODE
TYPLDC:	PUSHJ	P,LDEC		;15 LEAVE DEFERRED ECHO MODE
TYPGRN:	JRST	GREEN		;16 GREEN BALL
TYPRED:	JRST	RED		;17 RED BALL
TYPYEL:	PUSHJ	P,YELLOW	;20 YELLOW BALL
TYPORG:	PUSHJ	P,ORANGE	;21 ORANGE BALL
TYPHNG:	AOJA	P4,SCNIN1	;22 HANG, IGNORE
TYPETM:	AOJA	P4,SCNIN1	;23 ENTER 2741 TRANSPARENT MODE
TYPLTM:	AOJA	P4,SCNIN1	;24 LEAVE 2741 TRANSPARENT MODE
TYPLOS:	PUSHJ	P,RCVLOS	;25 LOST BALL (CHARACTERS LOST ON INPT)
TYPSUP:	 STOPCD (,XCT,TTYBMT)	;26 SUPERVISOR REQUEST
TYPSUR:	JRST	RCVSUR		;27 SUPERVISOR RESPONSE
TYPAXC:	 STOPCD (,XCT,TTYBMT)	;30 AUX CIRCUIT CHARACTER
TYPTSP:	 STOPCD (,XCT,TTYBMT)	;31 TEST PROBE
TYPTSR:	AOJA	P4,SCNIN1	;32 TEST RESPONSE, IGNORE
TYPSAD:	 STOPCD (,XCT,TTYBMT)	;33 HOST SAD
TYPECN:	 STOPCD (,XCT,TTYBMT)	;34 ECHO ON, SHOULD NOT COME IN
TYPECF:	 STOPCD (,XCT,TTYBMT)	;35 ECHO OFF, SHOULD NOT COME IN
TYPTCS:	 STOPCD (,XCT,TTYBMT)	;36 SEND TERMINAL CHRS. SHOULD NOT COME IN
TYPTCP:	 STOPCD (,XCT,TTYBMT)	;37 TERM CHRS PROBE. SHOULD NOT COME IN
TYPTCR:	JRST	RCVTMC		;40 TERM CHRS RESPONSE
TYPHSI:	 STOPCD (,XCT,TTYBMT)	;41 PORT AND SYSTEM NUMBER
TYPCLP:	 STOPCD (,XCT,TTYBMT)	;42 REQUEST FOR SUPERVISOR TIME
TYPCLR:	JRST	CLKRSP		;43 CLOCK RESPONSE FROM SUP.
TYPBKO:	 STOPCD (,XCT,TTYBMT)	;44 INITIATE BLOCK OUTPUT
TYPBOC:	PUSHJ	P,BLKOHR	;45 BLOCK OUTPUT COMPLETE SAME AS TERMINATED
TYPBIN:	 STOPCD (,XCT,TTYBMT)	;46 INITIATE BLOCK INPUT
TYPINB:	PUSHJ	P,BLKIBF	;47 BLOCK INPUT TERMINATED: OUT OF BUFFER
TYPINE:	PUSHJ	P,BLKEOT	;50 BLOCK INPUT TERMINATED: END OF TRANSMISSION
TYPINT:	PUSHJ	P,BLKITM	;51 BLOCK INPUT TERMINATED: TIMEOUT BY BASE
TYPIRQ:	 STOPCD (,XCT,TTYBMT)	;52 REQUEST BLOCK INPUT TERMINATION
TYPIHR:	PUSHJ	P,BLKIHR	;53 BLOCK INPUT TERMINATED: BY HOST REQUEST
TYPORQ:	 STOPCD (,XCT,TTYBMT)	;54 REQUEST BLOCK OUTPUT TERMINATION.
TYPOHR:	PUSHJ	P,BLKOHR	;55 BLOCK OUTPUT TERMINATED: BY HOST REQUEST
TYPNEG:	JRST	BLKNEG		;56 NEGOTIATE FOR NUMBER OF BLOCK I/O PORTS
TYPBRK:	AOJA	P4,SCNIN1	;57 BREAK, IGNORE FOR NOW
TYPPSR:	JRST	RCVPS		;60 PORT STATUS RECEIVED (not used)
TYPEAD:	AOJA	P4,SCNIN1	;61 ENTER ALTERNATE DEVICE MODE, IGNORE
TYPLAD:	AOJA	P4,SCNIN1	;62 LEAVE ALTERNATE DEVICE MODE, IGNORE
TYPKAF:	 STOPCD (,XCT,TTYBMT)	;63 SET KEEP-ALIVE FAILURE TIMER
	DEPHASE

MXTYP==.-TYPTRN-1
SUBTTL NON-CHARACTER INPUT HANDLER ROUTINES

GOBCHR:	HRRZ	F, LDBDDB(U)
	JUMPE	F, SIMRZP		;IF NO JOB, TREAT AS ZAPPER
	LDB	J, PJOBN
	MOVE	T2, JBTSTS(J)
	TLNN	T2, JLOG		;IF NOT LOGGED-IN,
	 JRST	SIMRZP			;  TREAT AS ZAPPER
	AOJ	P4, GOBCH1
FRCCGB:	HRRZ	F, LDBDDB(U)
	JUMPE	F, GOBCH2		;IF IT'S ATTACHED
	LDB	J, PJOBN
GOBCH1:	LDB	T1, DDPTCG
	JUMPE	T1, GOBCH2		;AND IT'S TRAPPING GOBBLERS,
	PUSHJ	P, TAKTRP		;  TAKE THE TRAP
GOBCH2:	MOVEI	T1, LXRCGS
	IORM	T1, LDBDCX(U)		;SET CHARACTER-GOBBLER SEEN
	PJRST	TSETBI			;CLEAR THE INPUT BUFFERS

NOOUT:	AOJ	P4,
FRCNOO:	LDB	T1, LOPZAP
	JUMPN	T1, CPOPJ		;IF ABOUT TO SEND ZAPPER, DO NOTHING
	MOVSI	T1, LDLNOP
	IORM	T1, LDBDCH(U)		;SET BACKPRESSURE FLAG
	DPB	T1, LDBOPB(U)		;CLEAR NEED-OUTPUT
	POPJ	P,

DOOUT:	AOJ	P4,
FRCDOO:	MOVSI	T1, LDLNOP
	ANDCAM	T1, LDBDCH(U)		;CLEAR BACKPRESSURE FLAG
	MOVEI	T1, 1
	DPB	T1, LDBOPB(U)		;SET NEED-OUTPUT
	POPJ	P,

;Here for message 06 - externally initiated login request

LOGIN:	MOVE	T1,LDBLIN(U)
	TLNE	T1,LNLZIN		;IF THERE'S AN UNECHOED ZAPPER,
	 JRST	[MOVEI	T1,NZAPLG
		 PUSHJ	P,ZAPBUG	;NOTE IT
		 JRST	.+1	]
	SKIPE	LDBLOG(U)		;IF LOGGED-IN OR LOGGING IN,
					;  TREAT AS CIRCUIT ZAPPER
	  JRST	[PUSHJ	P,ZAPLOG	;NOTE THE ZAP (increment P4)
		 JRST	SCNIN1]		;  Return to loop

	MOVEI	T1,1B32			;This bit will be shifted to
	MOVEM	T1,LDBLOG(U)		; 1B0 after reading 4 characters
	LDB	T1,INPDL2		;Get 3rd+4th byte of login message
	LDB	T2,[POINT 16,BASVER,31]	;Check version of base code
	CAIL	T2,<02_^D8>+01		;If EBUS version 2.01 or later,
	 DPB	T1,LDPHST		; store originating host number
	SETZM	LDBMOD(U)		;NOTHING SO FAR
	AOJA	P4,SCNIN1

PRINTF (<[BUG at LDEC has not been completely fixed, causes TTYNNC]>)
LDEC:	SKIPE	LDBECC(U)		;ARE WE STILL ECHOING?
	 JFCL	ZAPDFR			;YES, TREAT AS CIRCUIT ZAPPER
	MOVSI	T1,LDLDEF
	TLNN	U,LDLAUX		;NOT FOR AUX CIRCUITS
	 ANDCAM	T1,LDBDCH(U)		;RESET DEFERED ECHO FLAG
	AOJA	P4,SETLMD		;AND RESET LINE MODE

EDEC:	MOVSI	T1,LDLDEF
	TLNN	U,LDLAUX
	 IORM	T1,LDBDCH(U)		;ENTER DEFFERED ECHO MODE
	AOJA	P4,SETLMD
GREEN:	MOVEI	T1, 1
	DPB	T1, LOPSGR	;SET SEND-GREEN-BALL FLAG
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT BIT
	AOJA	P4, SCNIN1

RED:	MOVEI	T1, 0
	DPB	T1, LOPSGR	;CLEAR SEND-GREEN-BALL FLAG
	MOVEI	T1, 1
	DPB	T1, LOPSRD	;SET SEND-RED
	DPB	T1, LDBOPB(U)	;AND WANNA-OUTPUT
	AOJA	P4, SCNIN1

ORANGE:	AOJ	P4,
FRCORG:	PUSHJ	P, OBREC	;HANDLE INTERRUPT OR HIBER
	  JFCL
OBFND:	MOVSI	T1, L2LOWT
OBFND1:	ANDCAM	T1, LDBBYT(U)	;CLEAR ORANGE-WAIT FLAG
	MOVEI	T1, 1
	DPB	T1, LDBOPB(U)	;SET NEED-OUTPUT (ZAP CODE MAY WAIT)
	POPJ	P,

YELLOW:	AOJ	P4,
FRCYEL:	IFN YLBUG, <
	PUSHJ	P, OBREC	;WAS JOB WAITING FOR AN ORANGE BALL?
	  JRST	.+2		;NO
	 JRST	OBFND		;YES, TREAT AS ORANGE BALL
	MOVSI	T1, L2LOWT
	TDNE	T1, LDBBYT(U)	;IS ZAP LOGIC WAITING FOR ORANGE?
	 JRST	OBFND1		;YES, TREAT AS ORANGE
	>
	MOVEI	T1, LXRYBS
	IORM	T1, LDBDCX(U)	;SET YELLOW-BALL-RECEIVED BIT
	HRRZ	F, LDBDDB(U)
	JUMPE	F, YELLW1	;IF IT'S ATTACHED,
	LDB	T1, DDPTYB
	JUMPE	T1, YELLW1	;AND IT'S TRAPPING YELLOW BALLS,
	PUSHJ	P, TAKTRJ	;  TAKE THE TRAP
	MOVSI	T1, LXLOOK
	IORM	T1, LDBDCX(U)	;  AND ALLOW JOB TO SEND 1 ORANGE BALL
	POPJ	P,		;OTHERWISE,
YELLW1:	MOVEI	T1, 1
	DPB	T1, LOPSOG	;  SET SEND-ORANGE
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
	POPJ	P,

ZAPDFR:	AOSA	DFRZAP		;RECORD NUMBER
ZAPLOG:	AOS	LOGZAP		; NOTE THE ZAP
	MOVEM	U,ZAPLPT	; SAVE PORT LDB ADDRESS
	PUSHJ	P,ZAPBG0	;Save info, but use different stopcode
	 STOPCD (.+1,DEBUG,TTYZNE,PRTIRG,<Zapper not echoed for port>)
	PJRST	SIMRZP		; Simulate/force a zap (increment P4)
	
SUBTTL	BLKIBF - HERE WHEN A TYPE 47 (INPUT BUFFER FULL) IS RECEIVED
;	   FROM THE BASE.

BLKIBF:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCIBF:	PUSHJ	P,BLKICK	; EVERYTHING OK?
TTYBNP:: STOPCD (FRCZAP,INFO,TTYBNP,,<Block mode io Not in Progress>) ;;FRCIBF+1
	JUMPE	F, FREBUF	; DETACHED: GIVE UP

    ;STORE THE CHARACTER COUNT INTO THE USER'S BUFFER

BLKIB1:	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDR
	HRRZM	T4, BIOCHR(T1)	; STORE THE COUNT

    ;WAKE/INTERRUPT THE JOB

BLKIB2:	PUSHJ	P, BIOWAK	; WAKE UP JOB
	MOVEI	T1, LXRBRK
	IORM	T1, LDBDCX(U)	; SET BIT FOR POLPRT
	LDB	T1, DDPTLN	; IF INTERRUPT-ON-BREAK ENABLED
	PUSHJ	P, TAKTRJ	; TAKE IT

    ;FREE THE BUFFER (AND, IF NO OUTPUT PENDING, THE BASE PORT)
    ;IF THE PORT HAS LEFT BLOCK MODE

BLKIB3:	MOVSI	T2, LMLBIO
	TDNN	T2, LDBMOD(U)	; BLOCK I/O ENABLED?
	PJRST	FREBUF		; NO: FREE THE BUFFER
	POPJ	P,

;BLKEOT - HERE WHEN A "INPUT TERMINATED - END OF TRANSMISSION"
; (TYPE 50) IS RECEIVED FROM THE BASE.

BLKEOT:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCEOT:	PUSHJ	P, BLKICK	; EVERYTHING OK?
	 STOPCD (,XCT,TTYBNP)	;Block mode io Not in Progress ;;FRCEOT+1
	PJUMPE	F, FREBUF	; DETACHED: GIVE UP
	LDB	T1, DDPMOD	; T1/ DATA MODE
	CAIN	T1, B
	JRST	BLKIB1		; BINARY: JUST RETURN THE DATA
IMGITM:	PUSHJ	P, BLKTRQ	; REQUEST INPUT TERMINATION
IMGIT2:	MOVSI	S, IOEND
	IORB	S, DEVIOS(F)	; SET IOEND
	JUMPN	T4, BLKIB1	; COUNT .gt. 0: RETURN THE DATA
	PUSHJ	P, RELBI	; COUNT = 0: DONE WITH BLOCK INPUT
	JRST	BLKIB2		; WAKE THE JOB AND RETURN
SUBTTL	BLKITM - HERE WHEN AN "INPUT TERMINATED - TIMEOUT BY BASE"
; (TYPE 51) MESSAGE IS RECEIVED FROM THE BASE.

BLKITM:	LDB	T4,INPDL2	; T4/ COUNT
	AOJ	P4,
FRCITM:	PUSHJ	P,BLKICK	; EVERYTHING OK?
	  POPJ	P,		; NO: IGNORE THE MESSAGE
	PJUMPE	F, FREBUF	; DETACHED: GIVE UP
	MOVEI	S, IOBKTL
	IORB	S, DEVIOS(F)	; SET IO.BKT
	LDB	T1, DDPMOD	; T1/ DATA MODE
	CAIN	T1, I
	JRST	IMGITM		; IMAGE: REQ TRM, RETURN DATA
	JUMPN	T4, BLKIB1	; COUNT.gt.0: WAKE JOB, RETURN DATA

    ;HERE WHEN NOT IN IMAGE MODE, TO REPEAT THE REQUEST

	MOVE	T1, LDBMOD(U)
	TLNE	T1, LMLTBI	; TERMINATE PENDING?
	 POPJ	P,		; YES: DON'T REREQUEST INPUT
	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	HRRZ	T2, BIOCHR(T1)	; T2/ SAME COUNT AS BEFORE
	PJRST	BLKIRQ		; REQUEST INPUT

;FREBUF - CALLED WHEN A PORT WITH LMLBIO CLEAR RECEIVES
;	   A BLOCK INPUT TERMINATED MESSAGE

FREBUF:	PUSHJ	P, RELBI	; DONE WITH BLOCK INPUT
	JUMPN	T1, CPOPJ	; IF NO PENDING OUTPUT,
	PJRST	DECBC		;   FLAG 1 FEWER BLOCK PORT

; BLKICK - COMMON SUBROUTINE FOR BLOCK-INPUT-TERMINATED
;	    MESSAGES.

BLKICK:	HRRZ	T1,LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	SKIPE	T1		; IF NO BUFFER
	SKIPL	BIOCHR(T1)	; OR NO REQUEST PENDING
	 POPJ	P,		; FAIL-RETURN
	HRRZ	F,LDBDDB(U)	; F/ DDB
	AOS	(P)
	POPJ	P,
SUBTTL	BLKIHR - HERE WHEN "INPUT TERMINATED - BY HOST REQUEST"
; (TYPE 52)MESSAGE IS RECEIVED FROM THE BASE.

BLKIHR:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCIHR:	MOVSI	T1, LMLTBI
	ANDCAM	T1, LDBMOD(U)	; CLEAR TERMINATE-PENDING FLAG
	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	SKIPN	T1		; IF THERE'S NONE THERE,
	POPJ	P,		;   NOTHING MORE TO DO
	MOVE	T2, BIOCHR(T1)	; T2/ IN-PROGRESS FLAG,,COUNT
	JUMPGE	T2, BLKIB3	; NO BLOCK INPUT IN PROGRESS
	HRRZ	F, LDBDDB(U)	; F/ DDB
	PJUMPE	F, FREBUF	; DETACHED: FREE THE BUFFER
	JRST	IMGIT2		; SET IOEND, RETURN DATA

;BLKOHR - HERE WHEN AN "OUTPUT TERMINATED" (TYPE 52)
;	   OR AN "OUTPUT TERMINATED BY HOST REQUEST" (TYPE 53)
;	   MESSAGE IS RECEIVED FROM THE BASE

BLKOHR:	AOJ	P4,
	MOVSI T1,LDLNOP
	ANDCAM T1,LDBDCH(U)	;CLEAR OUTPUT BACKPRESSURE
	MOVEI T1,1
	DPB T1,LDBOPB(U)	;AND SET NEED-OUTPUT BIT
FRCOHR:	HLRZ T1,LDBBIO(U)	;T1/ OUTPUT BUFFER
	JUMPE T1,BLKOH1		;IF NONE, DO (ALMOST) NOTHING
	PUSHJ P,RELBO		;DONE WITH BLOCK OUTPUT
	JUMPN T1,BLKOH1		;IF NO ACTIVE BLOCK I/O
	MOVE T2,LDBMOD(U)
	TLNN T2,LMLBIO		;AND PORT WANTS OUT OF BLOCK MODE,
	PUSHJ P,DECBC		;  GET IT OUT
BLKOH1:	HRRZ F,LDBDDB(U)
	JUMPE F, CPOPJ		;IF ATTACHED,
	PJRST XMTWAK		;WAKE THE JOB
IFNCPU (<KI,KL>), <
BLKNEG:	 STOPCD (,XCT,TTYBMT)	;56 NEGOTIATE FOR # BLOCK I/O PORTS NOT USED
>; END IFNCPU (<KI,KL>)

IFCPU (<KI,KL>), <
;SNDBIO - HERE AT CHANNEL 7 LEVEL FROM SCNINT WHEN THERE ARE
;ANY BLOCK I/O PORT REQUESTS (EITHER INCREASE OR DECREASE)
;PENDING.

SNDBIO:	PUSHJ	P,CLSCHR	;FINISH PREVIOUS MESSAGE AND
	  POPJ	P,		; RETURN IF NO MORE SPACE.
	MOVSI	P3,TYPI TYPNEG	;PORT REQUEST TYPE FOR
;Following code commented out since there are no KMC's on
; KI's and KL's.
;IFKMC<	PUSHJ	P,MDRUP		;GET UP DRs
;	JUMPE	T1,CPOPJ	;IF NO NODES ARE UP THEN GIVEUP
;	SKIPA			;Don't shift the first time
;SNDBI1: LSH	T1,-3
;	TRNN	T1,7		;NO SKIP IF LOW 3 BITS ARE ALL 0s
;	  JRST	SNDBI1		;Go try the next one
;	SUBI	T1,1
;	ANDI	T1,3
;	LSH	T1,6
;	DPB	T1,WRPLIN	;STUFF THE UP DR NUMBER IN PORT
;>;IFKMC.END
	HRRZS	T1,BIOCNT+0	;GET THE NEW REQUEST COUNT
	DPB	T1,WRPCHR	;AND WRITE INTO 1ST DATA CHAR
	AOS	BIOANS		;INC RESP COUNT EXPECTED OF BASE
	JRST	WRDOUT		;SEND THE REQUEST AND SKIP RETURN.

;BLKNEG - AT SNDBIO, WE SENT A TYPE 54, ASKING FOR <BIOCNT+0>
;BLOCK I/O PORTS. WE GET HERE WHEN WE GET A TYPE 54 BACK FROM
;THE BASE, TELLING US HOW MANY WE CAN HAVE.

BLKNEG:	SKIPG	BIOANS		;IF WE DIDN'T SEND A REQUEST
	JRST	[
		AOS ERRBNG
		AOJA P4, SCNIN1	;  IGNORE THE "RESPONSE"
	]
	SOSG	BIOANS		;IF THERE'RE MORE RESPONSES COMING
	SKIPGE	T2,BIOCNT+0	;OR THERE'S ANOTHER REQUEST PENDING,
	AOJA	P4,SCNIN1	;  IGNORE THE RESPONSE
	LDB	T4,INPCHR	;T4/ # OF PORTS WE CAN HAVE
	MOVN	T1,T4
	ADD	T1,BIOPRT	;T1/ #PORTS BEFORE - #PORTS NOW
	JUMPE	T1,BLKNG4
	JUMPLE	T1,BLKNG2
	CAML	T2,BIOPRT	;IF NOW .LT. BEFORE .LE. #JOBS
	 STOPCD 		;  SOMEONE'S GOING THE WRONG WAY
BLKNG2:	MOVE	T2,BPREQ	;T2/ OLD BLOCK-PORT-REQ
	ADDM	T1,BPREQ	;UPDATE BPREQ
	JUMPLE	T2,BLKNG3	;IF SOMEONE WAS IN BLOCK-PORT WAIT
	SKIPG	T1		;AND THERE'RE MORE PORTS NOW,
	SETOM	BPAVAL		;  TELL THE SCHEDULER
BLKNG3:	MOVEM	T4,BIOPRT	;SET THE NEW # OF PORTS
BLKNG4:	SKIPN	J,BIOJOB	;IF THERE'S A JOB IN AX WAIT,
	AOJA	P4,SCNIN1
	SETZM	BIOJOB
	MOVEI	T1,RNQ
	DPB	T1,PJBSTS##
	PUSHJ	P,SETRUN	;  WAKE IT UP
	AOJA	P4,SCNIN1
> ;END IFCPU (<KI,KL>)
SUBTTL	HERE WHEN A "CHARACTERS LOST" MESSAGE (BUFFER ZAP) IS
;RECEIVED: IF THE DATA BYTE IS 0, OUTPUT CHARACTERS WERE
;LOST; OTHERWISE, INPUT CHARACTERS WERE LOST

RCVLOS:	AOJ	P4,
	AOS	TTYLOS		;RECORD CHARACTER LOST BY TYMNET
	LDB	T1,INPCHR	;T1/ DIRECTION
FRCLOS:	SKIPN	T1
	TROA	T1,LXROCL	; 0 = OUTPUT LOST
	MOVEI	T1,LXRICL	; 1 = INPUT LOST
	IORM	T1,LDBDCX(U)
	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ		;NOTHING TO DO IF NO DDB
	MOVEI	T1,IOBKTL
	IORM	T1,DEVIOS(F)	;SET ERROR FLAG
	LDB	T1,DDPTLC
	PJRST	TAKTRJ		;SET TO INTERRUPT

;HERE WHEN A TERMINAL CHARACTERISTICS VALUE IS RECEIVED

RCVTMC:	LDB	T1,INPCH2	;VALUE
	LDB	T2,INPCHR	;AND TYPE NUMBER
	CAILE	T2,MAXTMC	;CHECK RANGE
	 JRST	RCVTCX		;(BAD)
	DPB	T1,TABTMR(T2)
	AOJA	P4,SCNIN1	;FINISHED

RCVTCX:
;*;	CAILE	T2,<MAXTMC+TMCSLP>
;*;	 STOPCD			;AMAZINGLY BAD
	AOS	TMCOOR		;SLIGHTLY BAD - BUMP OUT-OF-RANGE COUNT
	AOJA	P4,SCNIN1
SUBTTL	HERE WHEN THE TIME AND DATE ARE RECEIVED

CLKRSP:	LDB	T2,INPDL2	;GET HIGH ORDER BITS OF TIME
	ADDI	P4,1
	ANDI	P4,MSKIRG
	LDB	T1,INPDL1	;GET LOW ORDER BITS
	DPB	T2,[POINT 16,T1,19]
	IDIVI	T1,^D<24*60*60>	;DAYS IN T1, SEC IN T2
	ADDI	T1,^D3653	;Convert 1-JAN-74 to 1-JAN-64
	IMUL	T2,JFYSEC
	EXCH	T1,T2		;Time in T1, Date in T2
	PUSHJ	P,COMGMS##	;Set GMT time (in UUOCON)
	MOVE	T1,DATE##	;Remember the date/time of when
	MOVEM	T1,SUPTIM##	; the Supervisor saw us
	AOJA	P4,SCNIN1

;HERE WHEN A PORT STATUS MESSAGE IS RECEIVED (see comment at ACPSM)

RCVPS:	LDB	T1,INPCHR	; GET THE 4 BITS
	DPB	T1,LDPPSM	; STORE PORT STATUS MSG
	MOVEI	T1,LXRPSS
	IORM	T1,LDBDCX(U)	; AND NOTE THAT IT'S BEEN SEEN
	MOVSI	T1,LMLPSP
	IORM	T1,LDBMOD(U)
	HRRZ	F,LDBDDB(U)
	JUMPE	F,PSDONE	; NO TRAP IF NO DDB
	LDB	T1,DDPTPS
	PUSHJ	P,TAKTRJ	; SET TO INTERRUPT
PSDONE:	AOJA	P4,SCNIN1	; DONE
SUBTTL	HERE WHEN A CIRCUIT ZAPPER IS RECEIVED

RCVZAP:	AOS	NZAPIN		;# REAL, TRUE ZAPPERS IN
	MOVE	T1,LDBLIN(U)	;Mark as zapper coming from TYMNET
	TLOE	T1,LNLZIN	;If there's one already in,
	 JRST	[MOVEI	T1,NZAPN2
		 PUSHJ	P,ZAPBUG  ;NOTE IT
		 JRST	SIMRZP	]
	MOVEM	T1,LDBLIN(U)
SIMRZP:	ADDI	P4,1		;Skip past the zap command in IRING

;Enter at FRCZAP to pretend we received a zapper from the base

FRCZAP:	SETZM	LDBOUT(U)		;Cancel any pending output bits
	MOVSI	T1,L2LOWT
	ANDCAM	T1,LDBBYT(U)		;Cancel wait for orange ball
	SKIPL	LDBLOG(U)		;If port's not logged-in,
	 JRST	[SETZB	T1,LDBLOG(U)	; cancel "login in progress"
		 DPB	T1,LDPHST	;Clear host number
		 MOVEI	T1,1
		 DPB	T1,LOPZAP	;Set send-zapper
		 DPB	T1,LDBOPB(U)	; and need-output
		 MOVSI	T1,LDLNOP
		 ANDCAM	T1,LDBDCH(U)	;Ignore backpressure
		 POPJ	P,	]
	MOVSI	T1,LLLNLN!LLLZAP	;Line not there (TYMNET has zapped it)
	IORM	T1,LDBLOG(U)		;Mark port as externally zapped
	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO		;IF BLOCK-MODE SET,
	SKIPE	LDBBIO(U)		;OR BLOCK I/O'S STILL IN PROGRESS,
	 PUSHJ	P,BIOZAP		;  RELEASE BUFFERS & CLEAR BLOCK-MODE
	TLNE	U,LDLAUX		;IF IT'S AN AUX PORT
	 PJRST	ZAPAUX
	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)		;OR AT ANY RATE NOT A COMMAND PORT,
	 PJRST	ZAPAUX			;  DETACH & TRY TO FREE DDB

    ;HERE WHEN A ZAPPER IS RECEIVED ON A JOB'S COMMAND PORT

	LDB	J,PJOBN			;J/ DON't FORCE,,JOB#
	PUSHJ	P,HNGTTY		;Force hangup for job/frame
	POPJ	P,
SUBTTL INPUT CHARACTER HANDLER

CHRMLT:	SKIPN	LDBLOG(U)		;MIGHT BE LINE WE HAVE JUST
	 JRST	MLTNDB			; SENT ZAPPER ON, FIX INPUT RING
	MOVEI	T1,IRING(P4)
	HRLI	T1,(POINT 8,0,BYP2)	;SET UP A BYTE POINTER
	MOVEM	T1,CHRRDP
CHRML1:	UUILDB	T3,CHRRDP
	PUSHJ	P,MOVCHR
	 SOJG	P1,CHRML1		;CONTINUE
	JUMPG	P1,CHRML3		;HERE AT END OR DEF ECHO MODE
CLRMLT:
;;;;;;;; MORE KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKMC<	MOVE	P1,IRPMSG
	CAME	P1,IRING(P4)
	 STOPCD 		;CRASH ON KMC IRING OVERWRITE or bad P4
>;END_IFKMC
;;;;;;;; END KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	LDB	P1,INPTYP		;NOW CLEAR OUT THE INPUT RING
	TRZ	P1,200			;GET COUNT BACK
	HRRZ	F,LDBDDB(U)		;CHARGE
	JUMPE	F,MLTNDB
	LDB	T1,PJOBN
	ADDM	P1,JBTCIN(T1)
	ADDM	P1,JBTCIN		;System-wide # of characters input
MLTNDB:	ADDI	P1,5	;GET NUMBER OF WORDS USED (2 BYTES FOR COUNT AND PORT)
	LSH	P1,-2
	ADD	P4,P1			;INCREMENT POINTER BY NUMBER USED
	JRST	SCNIN1

CHRML2:	UUILDB	T3,CHRRDP
	PUSHJ	P,MOVCHR		;THIS IS THE DEFERED ECHO LOOP
	 JFCL				;SHOULD NOT BE GETTING HERE
CHRML3:	SOJG	P1,CHRML2
	MOVEI	T1, 1
	DPB	T1, LOPECO		;SET SEND-ECHO
	DPB	T1, LDBOPB(U)		;AND NEED-OUTPUT
	JRST	CLRMLT
SUBTTL	CALLED WITH CHARACTER IN T3. DISPATCH ON CHARACTER TYPE AND LINE MODE

MOVCHR:	LDB	P2,LDPMIN	;Get the input mode
	TRNN	T3,200
MOVCH2:	SKIPA	P3,CHRTAB(T3)	;Get character bits
	MOVE	P3,CHRTAB-200(T3)
	LDB	T2,CHPINP	;GET INPUT TYPE
MOVCH1:	XCT	CIMTAB(P2)	;DO THE RIGHT THING FOR THE LINE MODE
	JRST	(T1)		;THIS WILL USUALLY LOAD AN ADDRESS IN T1

;LINE MODE DISPATCH TABLE

CIMTAB:	JRST	LOGCHR		;LOGIN
	JRST	IMGDEF		;IMAGE,DEF ECHO
	JRST	IMGRMA		;IMAGE,REM ECHO,BKA=1
	JRST	IMGRMT		;IMAGE,REM ECHO,BKA=0
	HLRZ	T1,MD0405(T2)	;NORMAL,DEF ECHO,BK2=0
	HRRZ	T1,MD0405(T2)	;NORMAL,DEF ECHO,BK2=1
	HLRZ	T1,MD0607(T2)	;NORMAL,REM ECHO,BKA=1,BK2=0
	HRRZ	T1,MD0607(T2)	;NORMAL,REM ECHO,BKA=1,BK2=1
	HLRZ	T1,MD1011(T2)	;NORMAL,REM ECHO,BKA=0,BK2=1
	HRRZ	T1,MD1011(T2)	;NORMAL,REM ECHO,BKA=0,BK2=0
	HLRZ	T1,MD1213(T2)	;COMMAND,REM ECHO
	HRRZ	T1,MD1213(T2)	;COMMAND,DEF ECHO

;CHARACTER TYPE DISPATCH TABLES

; CHARACTER TYPES FOR INPUT
;
; 0 - SPECIAL ACTION
; 1 - NORMAL CHARACTER
; 2 - BREAK (CONTROL) CHARACTER
; 3 - BREAK2 (PUNCTUATION) CHARACTER

MD0405:	IACT0,,IACT0	; 0,, 0
	IACT1,,IACT1	; 1,, 1
	IACT2,,IACT2	; 2,, 2
	IACT3,,IACT4	; 3,, 4

MD0607:	IACT0,,IACT0	; 0,, 0
	IACT5,,IACT5	; 5,, 5
	IACT6,,IACT6	; 6,, 6
	IACT7,,IACT10	; 7,,10

MD1011:	IACT0,,IACT0	; 0,, 0
	IACT11,,IACT11	;11,,11
	IACT6,,IACT6	; 6,, 6
	IACT10,,IACT12	;10,,12

MD1213:	IACT0,,IACT0	; 0,, 0
	IACT13,,IACT21	;13,,21
	IACT14,,IACT22	;14,,22
	IACT15,,IACT17	;15,,17
SUBTTL	THIS ROUTINE IS CALLED BY ALMOST EVERYONE TO PUT A CHR INTO
;THE INPUT BUFFER

RCVCHR:	MOVE	T4,TTFREN
	CAIG	T4,TIRSVD
	 JRST	RECHLT		;OUT OF BUFFERLETS. GIVE HIM BELL
	MOVE	T4,LDBTIC(U)
	ADD	T4,LDBECC(U)
	CAML	T4,TIWRNN	;OVER SMALL QUOTA?
	 JRST	RWARN		;TRY TO STOP HIS INPUT
RCVCH1:	PUSHJ	P,CHRTRP	;TAKE A CHARACTER TRAP
	SKIPN	T2,LDBTIP(U)
	 PUSHJ	P,RECVRG	;MUST SET UP THE INPUT POINTERS
	PUSHJ	P,TTPUTC	;PUT THE CHR IN THE BUFFER
	MOVEM	T2,LDBTIP(U)
	AOS	LDBBKI(U)
	MOVSI	T1,L2LDEL	;SHOULD WE RESET THE \ FLAG?
	TDNN	T1,LDBBYT(U)
	 JRST	RCVCH2		;NOT ON
	PUSH	P,T2
	MOVEI	T3,"\"
	PUSHJ	P,ENTRUB
	MOVEI	T1,1
	DPB	T1,LOPRUB	;SET SEND-RUBOUT
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POP	P,T2
RCVCH2:	MOVSI	T1,L2LDEL!L2LCCS
	ANDCAM	T1,LDBBYT(U)
	AOS	(P)
	POPJ	P,

RECVRG:	PUSHJ	P,GETCHK
	MOVEM	T2,LDBTIP(U)	;SET UP INPUT POINTERS
	MOVEM	T2,LDBTIT(U)
	MOVEM	T2,LDBECT(U)
	SETZM	LDBBKI(U)
	SETZM	LDBBKP(U)
	SETZM	LDBTIC(U)
	SETZM	LDBECC(U)
	SETZM	LDBBKC(U)
	SETZM	LDBBK2(U)
	POPJ	P,
RWARN:	CAML	T4,TIHLTN	;OVER LARGE QUOTA?
	 JRST	RWARN1		;YES: GO SEE HOW BADLY WE LOST
	MOVEI	T1,1
	DPB	T1,LOPBPN	;NO: SET BACKPRESSURE-ON
	DPB	T1,LDBOPB(U)	;    AND NEED-OUTPUT
	JRST	RCVCH1

RWARN1:	LDB	T1,LOPBPN	;STILL WAITING TO SEND BACKPRESSURE?
	SKIPE	T1
	 AOSA	LOSPDP		;YES: WE'RE TOO SLOW
	AOS	LOS620		;NO: BACKPRESSURE BROKEN
	PFALL	RECHLT		;SEND BELL AND DROP CHARACTERS

RECHLT:	AOS	TTYRHT		;RECORD CHARACTER LOST
	MOVEI	T1,LXRICL
	IORM	T1,LDBDCX(U)	;NOTE THE DIRECTION
	HRRZ	F,LDBDDB(U)
	JUMPE	F,RECHT1
	MOVEI	T1,IOBKTL	;SET IO.BKT
	IORM	T1,DEVIOS(F)
	LDB	T1,DDPTLC	;IF CHARACTERS-LOST ENABLED
	PUSHJ	P,TAKTRJ	;TAKE IT
RECHT1:	MOVEI	T1,1
	DPB	T1,LOPSBL	;SET SEND-BELL
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,
SUBTTL	HERE ON A LOGIN CHARACTER (ONE OF FIRST 4 ON LINE)

LOGCHR:	SKIPG	T4,LDBLOG(U)	;Are we really logging him in?
	 POPJ	P,		;No, return from MOVCHR
	LSH	T4,^D8		;Put login char
	IOR	T4,T3		; into
	MOVEM	T4,LDBLOG(U)	;  LDBLOG
	JUMPGE	T4,CPOPJ	;More to come

;WE'VE RECEIVED THE 32 BITS OF LOGIN DATA FROM TYMNET - NOW LOG THE LINE IN

	AOS	INTERM		;COUNT 1 MORE LINE LOGGED-IN
	LDB	T1,TRMBYP	;T1/ TERMINAL ID CODE
	MOVE	T1,TRMTAB(T1)	;T1/ IBM,FAST,FC1,FC2,WIDTH CODES
	TLNN	T1,200000	;FAST TERMINAL?
	 TDZA	T3,T3		;NO
	MOVSI	T3,LXL120	;YES
	MOVEM	T3,LDBDCX(U)	;SET LDBDCX (0 EXCEPT FOR FAST BIT)
	MOVSI	T3,LDLDEF!LDLLCT!LDLCOM
	SKIPG	T1		;IS IT A 2741?
	 TLO	T3,LDLLCP	;YES: SET LOCAL-COPY FLAG
	SETZM	LDBBYT(U)	;MOST FIELDS ARE 0
	DPB	T1,LDPFC1	;SET FC1
	LSH	T1,-2
	DPB	T1,LDPFC2	;AND FC2
	LSH	T1,-2
	DPB	T1,LDPWID	;AND LINE WIDTH
	MOVSI	T1,LLLHDX
	TDNN	T1,LDBLOG(U)	;HALF-DUPLEX?
	 TDZA	T1,T1		;NO
	MOVEI	T1,1		;YES
	DPB	T1,LDPHDX	;SET THE CHARACTERISTIC
	SKIPN	T1		;IF IT'S HALF DUPLEX
	TLNE	T3,LDLLCP	;OR LOCAL-COPY (2741)
	TLZ	T3,LDLDEF	;DON'T SET DEFERRED ECHO
	MOVEM	T3,LDBDCH(U)
	SETZM	LDBCLA(U)	;[dws] clear terminal type
	MOVSI	T1,'TTY'
	MOVEM	T1,LDBTYP(U)	;Terminal type
	SETZM	LDBSTR(U)	;  CLEAR PREVIOUS CIRCUIT NAME
	HRRZI	T1,LDBSTR+1(U)	;  GET ADDRESS
	HRLI	T1,-1(T1)	;    STR,,STR+1
	BLT	T1,LDBSTR+AUXSTL-1(U)

	HLL	U,T3		;Make sure this matches LH<LDBDCH>
				; or aux cir test on next page fails

	;CLEAR RECEIVED CHARACTERISTICS

	ZZN==0
	REPEAT TMCSIZ,<
	SETZM	LDBTMR+ZZN(U)
	ZZN==ZZN+1>
	;SET TO ECHO CR AS CRLF, NOT ECHO CTRL-I,
	;NOT ECHO LF AS CRLF

	MOVEI	T1,0
	DPB	T1,LDSELF
	DPB	T1,LDSCIE
	MOVEI	T1,1
	DPB	T1,LDSECR
	MOVE	T1,[LTSELF!LTSCIE!LTSECR]
	MOVEM	T1,LDBTMT(U)

	SETZM	LDBOUT(U)	;CLEAR ALL SEND BITS BUT...
	MOVEI	T1,1
	DPB	T1,LOPSTC	;SET SEND-CHARACTERISTICS
	DPB	T1,LOPSTP	;AND SEND-PROBE
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	HRRZS	LDBDDB(U)	;CLEAR KJOB ETC. BITS
	MOVEI	T1,STSUPR	;200000
	TDNE	T1,STATES
	 JRST	LOGCH1		;System is super-shut, zap always
	TLNE	U,LDLAUX	;Is this an AUX circuit ?
	SKIPL	STATES		;Yes, is system plain shut ?
	 JRST	LOGCH2		;No, o.k. to log in
LOGCH1:	MOVEM	T1,LDBLOG(U)	;Must be non-zero and non-negative
	SOS	INTERM		;Leave INTERM alone in case
	JRST	TTYZAP		; of Auto-Restart

LOGCH2:	PUSHJ	P,SETLMD	;Set the line mode
;;
;; Here (finally!) to assign a frame for this port and initiate
;; LOGIN.
;;
	SETZ	F,		;Indicate no DDB assigned yet
	PUSHJ	P,FRMASN##	;Assign a free frame number
	  JRST	NEWJER		;No free frames...
	PUSHJ	P,TTYATI	;Attach a TTY DDB to this LDB
	  JRST	NEWTER		;No free TTY DDB's
	MOVEI	T1,CMFCXN##	;Forced command index for LOGIN
	PJRST	TTFORC		;Force a LOGIN command on this port

NEWJER:	MOVEI	T1,[ASCIZ /
frame capacity exceeded
/]
	PUSHJ	P,CONMES##	;Type out error message
	PJRST	TTYZAP		;Kill off TTY

NEWTER:	MOVEI	T1,[ASCIZ /
port capacity exceeded
/]
	PUSHJ	P,CONMES##	;Type out error message
	PJRST	FRMKJF##	;Free up frame slot and kill off TTY
;TERMINAL ID CODE = INITIAL TERMINAL CHARACTERISTICS TABLE

DEFINE TERCH (IBM,FAST,F1,F2,WIDTH)
	<BYTE (1) IBM,FAST (22) 0 (8) WIDTH (2) F2,F1>

TRMTAB:	TERCH (0,1,0,0,^D80)	;0    AUX circuit
	TERCH (0,0,0,0,^D80)	;1  A 300 baud
	TERCH (0,0,3,2,^D120)	;2  C 300 baud printer, wide carriage, delay
	TERCH (0,0,1,1,^D72)	;3  E 300 baud thermal printer, small delay
	TERCH (0,0,3,0,^D120)	;4  G 300 baud belt printer (GE Terminet), delay
	TERCH (0,0,1,1,^D72)	;5  B 150 baud Teletype 37, no parity
	TERCH (0,0,3,2,^D120)	;6  F 150 in, 300 out, Syner-Data Beta terminal
	TERCH (0,0,1,1,^D72)	;7  J 150 baud Teletype 37, even parity
	TERCH (0,0,1,1,^D72)	;8 CR 300 baud IBM 3767 in 2471 mode 32.4 cps
	TERCH (1,0,2,1,^D80)	;9 CR 134.5 baud IBM 2471 EBCDIC
	TERCH (0,0,1,1,^D72)	;10 D 110 baud Teletype ASR-33
	TERCH (0,0,1,1,^D80)	;11 I (was dot-matrix printer) SYNC - HSA
	TERCH (0,1,3,0,^D80)	;12 A,G,I 1200 baud (GOUGING=1, 120 cps)
	TERCH (0,1,0,0,^D80)	;13 Burroughs 1200 polled terminal
	TERCH (0,1,0,0,^D80)	;14 AUX through gateway
	TERCH (0,0,0,0,^D72)	;15 BAUDOT, 50 or 75 baud
	TERCH (0,1,3,0,^D80)	;16 A,G,I 2400 baud (GOUGING=2, 240 cps)
	TERCH (0,1,0,0,^D80)	;17   SYNC - Polled Terminals
	TERCH (0,1,0,0,^D80)	;18   SYNC - Point-to-Point
	TERCH (0,1,3,0,^D80)	;19 A,G,I 4800 baud (GOUGING=2, 240 cps)
	TERCH (0,1,3,0,^D80)	;20 A,G,I 9600 baud (GOUGING=3, 960 cps)
	TERCH (0,1,3,0,^D80)	;21 multiplexed PVC
	TERCH (0,1,3,0,^D80)	;22 audio response on T-1 carrier (56000 bps)
	TERCH (0,1,3,0,^D80)	;23 75 baud in 1200 out (VideoText)
	TERCH (0,1,3,0,^D80)	;24   SYNC - SDLC
	TERCH (0,1,3,0,^D80)	;25 Transaction Terminals
	TERCH (0,1,3,0,^D80)	;26 Host originated
	TERCH (0,1,3,0,^D80)	;27     unused
	TERCH (0,1,3,0,^D80)	;28     unused
	TERCH (0,1,3,0,^D80)	;29     unused
	TERCH (0,1,3,0,^D80)	;30     unused
	TERCH (0,1,3,0,^D80)	;31     unused
				;32-63   HDX same as 0-31 but with Half Duplex

TRMAUX==0	;CODE FOR AUX CIRCUIT
SUBTTL	HERE ON IMAGE MODE IN DEFERRED ECHO

IMGDEF:	TRO T3,400	;FLAG AS IMAGE CHARACTER
	MOVEI T1,IMGDIM
	DPB T1,LDPTIM	;RESET INPUT TIMER
	PUSHJ P,RCVCHR	;GET CHR INTO BUFFER
	 POPJ P,
	PUSHJ P,IMGCNT	;COUNT. IF T3 = IMAGE BREAK, T4 := TIWKC
DEFCHR:	CAIL T4,TIWKC	;IF IT'S A LINE'S WORTH,
DEFBRK:	PUSHJ P,LINTRP	;SET LINE TRAP BITS
DEFNBK:	AOS LDBECC(U)
	AOS (P)
	POPJ P,		;SKIP-RETURN TO START ECHOING

;HERE ON IMAGE MODE, REMOTE ECHO, BREAK ON ALL CHRS

IMGRMA:	TRO T3,400
	MOVEI T1,IMGDIM
	DPB T1,LDPTIM
	PUSHJ P,RCVCHR
	 POPJ P,
	PUSHJ P,IMGCHG	;CHARGE FOR AN IMAGE BREAK CHR
	PUSHJ P,USRWAK	;WAKE JOB IF ASLEEP
	LDB T1,LDPIMB
	CAME T1,T3	;IF IT'S THE IMAGE BREAK CHARACTER,
	CAIL T4,TIWKC	;OR IF THERE'S A LINEFULL,
	 PUSHJ P,LINTRP	;  SET TRAP BITS
	JRST IMGRM1

;HERE ON IMAGE MODE, REMOTE ECHO, NOT BREAK ON ALL

IMGRMT:	TRO T3,400
	MOVEI T1,IMGDIM
	DPB T1,LDPTIM
	PUSHJ P,RCVCHR
	 POPJ P,
	PUSHJ P,IMGCNT	;COUNT. IF T3 = IMAGE BREAK CHAR, T4 := TIWKC
	CAIGE T4,TIWKC	;IF IMAGE BREAK OR A LINE'S WORTH,
	 JRST IMGRM1
	PUSHJ P,USRWAK	;  WAKE UP JOB IF ASLEEP
	PUSHJ P,LINTRP	;  SET TRAP BITS
IMGRM1:	MOVEM T2,LDBECT(U)	;FIX ECHO POINTER
	AOS LDBTIC(U)
	POPJ P,
SUBTTL	NORMAL CHR DEF ECHO

IACT1:	PUSHJ P,RCVCHR
	 POPJ P,
	JRST DEFCHR

;BREAK CHR DEF ECHO

IACT2:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKC(U)	;RECODR BREAK CHR
IACT2A:	SETZM LDBBKI(U)		;RESET ^U POINTERS
	MOVEM T2,LDBBKP(U)
	JRST DEFBRK

;BREAK2 CHR DEF ECHO, NOT BREAK2 MODE

IACT3:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)
	ADDM T1,LDBBK2(U)	;COUNT BREAK2 AND IN ^U INFO
	JRST DEFCHR

;BREAK2 CHR DEF ECHO, BREAK2 MODE OR BREAK ON ALL AND BREAK2

IACT4:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBK2(U)	;RECORD BREAK2
	JRST IACT2A		;GO RESET ^U POINTER

;NORMAL CHR, RMT ECHO, BREAK ON ALL

IACT5:	PUSHJ P,RCVCHR
	 POPJ P,
IACT5A:	CAIL T4,TIWKC
	 JRST IAC11B
	JRST IAC11C

;BREAK CHR, RMT ECHO, ANY BREAK MODE

IACT6:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBKC(U)	;COUNT BREAK
	JRST IAC10A
SUBTTL	BREAK2 CHR, RMT ECHO, BREAK ON ALL, NOT BREAK2

IACT7:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBK2(U)	;COUNT BREAK2
	MOVSI T1,1
	ADDM T1,LDBBKI(U)	;AND IN ^U INFO
	JRST IACT5A

;BREAK2 CHR, RMT ECHO, BREAK2 OR BREAK ALL AND BREAK2

IACT10:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBK2(U)
IAC10A:	SETZM LDBBKI(U)
	MOVEM T2,LDBBKP(U)
	JRST IAC11B

;BREAK CHR, RMT ECHO, BREAK OR BREAK2 MODE

IACT11:	PUSHJ P,RCVCHR
	 POPJ P,
IAC11A:	CAIGE T4,TIWKC	;COUNT BIG ENOUGH?
	 JRST IAC11D	;NO
IAC11B:	PUSHJ P,LINTRP
IAC11C:	PUSHJ P,USRWAK
IAC11D:	MOVEM T2,LDBECT(U)
	AOS LDBTIC(U)
	LDB T1,CHPECH	;GET THE ECHO TYPE FIELD
	XCT RMTECT(T1)
	PFALL RMTCNT	;NOW FALL INTO THE REMOTE ECHO CODE
SUBTTL	REMOTE ECHO CODE

RMTCNT:	ADDI T4,1	;SEVERAL JUST LDB T4,LDPPOS
	TRNN T4,400	;TOO BIG?
	 DPB T4,LDPPOS	;NO RESET
	TLNE U,LDLLCP!LDLPTP ;LOCAL COPY OR TAPE
	 POPJ P,	;NEVER A FREE RETURN FOR THEM
	LDB T1,LDPWID
	TLNN U,LDLNFC	;IF NO FREE RETURN WANTED
	CAMG T4,T1	;OR NOT ENOUGH CHRS
	 POPJ P,		;FINISHED
RMTECR:	MOVEI T1,0
	DPB T1,LDPPOS	;RESET POSITION TO 0
	MOVE T4,CRPTR
	PJRST RUBSTR	;PUT INTO "RUBOUT" STRING

RMTECT:	JRST RMTSPA	;0 SPECIAL ACTION FOR THESE
	LDB T4,LDPPOS	;1 COUNT
	POPJ P,		;2 DO NOT COUNT THIS ONE
	POPJ P,		;3 "
	LDB T4,LDPPOS	;4 COUNT

RMTSPA:	LDB T1,LDPMOD	;GET THE MODE WE ARE IN
	LDB T2,CHPSPE	;ECHO SPECIAL ACTION TYPE
	XCT @RMTSPT(T1)

RMTSPT:	XCT RMTS10(T2)
	XCT RMTS94(T2)
	XCT RMTS94(T2)
	XCT RMTS10(T2)	;10 AND SUDS SAME

RMTS10:	JRST RMTEXC	;^C ECHO ^C RETURN
	JRST RMTCR	;RETURN
	JRST RMTEXU	;^U  ECHO ^U
	JRST RMTTAB	;TAB
	JRST RMTALT	;ALTMODE POSSIBLE $ ECHO
	JRST RMTVT	;V. TAB
	JRST RMTFF	;FF
	JRST RMTEXC	;^Z  ECHO ^Z RETURN
	JRST RMTAL1	;175-176 POSSIBLE ALTMODE
	JRST RMTBSP	;BACKSPACE
RMTS94:	POPJ P,		;^C
	JRST RMTCR	;RETURN
	POPJ P,		;^U
	JRST RMTTAB	;TAB
	POPJ P,		;ALTMODE
	JRST RMTVT	;V. TAB
	JRST RMTFF	;F.F.
	POPJ P,		;^Z
	JRST RMTPAT	;175-176 POSSIBLE ALTMODE
	JRST RMTBSP	;BACKSPACE
RMTPAT:	TLNE U,LDLLCT
	POPJ P,		;ALTMODE, IGNORE
RMTCN1:	LDB T4,LDPPOS
	JRST RMTCNT	;ASSUME PRINTING CHR

RMTAL1:	TLNN U,LDLLCT
	JRST RMTCN1	;ASSUME PRINTING CHR
RMTALT:	TLNE U,LDLPTP!LDLLCP	;NOTHING FOR THESE NUTS
	POPJ P,
	MOVSI T3,LXLDLR
	TDNE T3,LDBDCX(U) ;IF USER SUPPRESSING $ ECHO
	TLNE U,LDLCOM	;OR WE'RE AT COMMAND LEVEL
	SKIPA		;ECHO A $
	POPJ P,
	MOVEI T3,"$"
	JRST RMTRUB	;PUT IN RBS STRING

RMTCR:	MOVEI T1,0
	DPB T1,LDPPOS
	POPJ P,		;RETURN, JUST SET POSITION TO 0

RMTEXC:	TLNE U,LDLLCP!LDLPTP	;NOTHING FOR THESE NUTS
	POPJ P,		;NOTHING WE CN DO
	PUSHJ P,RMTEU1	;ECHO THE ^X
	JRST RMTECR	;AND THE RETURN
RMTEXU:	TLNE	U,LDLLCP!LDLPTP	;NOTHING FOR THESE NUTS
	POPJ	P,
RMTEU1:	MOVEI	T3,"^"
	PUSHJ	P,ENTRUB
	LDB	T3,LDBECT(U)	;GET BACK CHR
	TRO	T3,100
RMTRUB:	PUSHJ	P,ENTRUB
	MOVEI	T1,1
	DPB	T1,LOPRUB	;SET SEND-RUBOUT-CHARACTERS
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,

RMTVT:	MOVSI	T4,L2LNTB
	TDNN	T4,LDBBYT(U)		; NO VT ECHO??
	TLNE	U,LDLLCP!LDLPTP!LDLFRM	; DONE BY TERMINAL?
	POPJ	P,			; THEN NO FILLERS
	MOVE	T4,VTFLP
	PJRST	RUBSTR			;GO

RMTFF:	MOVSI	T4,L2LNTB
	TDNN	T4,LDBBYT(U)		; NO FF ECHO??
	TLNE	U,LDLLCP!LDLPTP!LDLFRM	; DONE BY TERMINAL?
	 POPJ	P,			; THEN NO FILLERS
	MOVE	T4,FFFLP
	PJRST	RUBSTR

RMTTAB:	MOVSI	T4,L2LNTB	;SEE IF WE SHOULD JUST IGNORE
	TDNE	T4,LDBBYT(U)
	TLNE	U,LDLCOM
	 SKIPA			;TABS AS USUAL IN COMMAND MODE
	  POPJ	P,		;YES, DO NOTHING
	LDB	T4,LDPPOS
	TLNE	U,LDLLCP!LDLTAB!LDLPTP
	 JRST	RMTTB1		;MUST ADJUST POSITION BUT NO SPACES
	ANDI	T4,7
	MOVE	T4,TABPTR(T4)
	PJRST	RUBSTR		;OUT OF SPACES ADJUSTS POS

RMTTB1:	MOVE	T1,T4		;SAVE SIZE
	TRO	T4,7
	ADDI	T4,1
	TRNN	T4,400
	 DPB	T4,LDPPOS	;PUT BACK IF NOT OUT OF RANGE
	POPJ	P,		;FINISHED

RMTBSP:	PJRST	SPOBSP	;UPDATE CHAR COLUMN COUNTER
SUBTTL	SOME ROUTINES TO HANDLE PUTTING THINGS IN THE RUBOUT STRING

ENTRUB:	SKIPN	TTFREE##	;GIVE UP IF NO FREE BUFFERLETS
	 POPJ	P,
	SKIPN	T2,LDBRBI(U)
	 JRST	STRUB		;MUST SET THINGS UP
STRUB1:	PUSHJ	P,TTPUTC
	MOVEM	T2,LDBRBI(U)
	AOS	LDBRBC(U)
	POPJ	P,

STRUB:	PUSHJ	P,GETCHK
	MOVEM	T2,LDBRBI(U)
	MOVEM	T2,LDBRBO(U)
	SETZM	LDBRBC(U)
	JRST	STRUB1

;PUT IN A WHOLE STRING, BYTE POINTER IN T4

RUBSTR:	ILDB	T3,T4
	JUMPE	T3, [		;IF WE'RE DONE WITH THE STRING,
		MOVEI	T1,1
		DPB	T1,LOPRUB	;SET SEND-RUBOUT-CHARACTERS
		DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
		POPJ	P,
	]
	PUSHJ	P,ENTRUB
	JRST	RUBSTR
SUBTTL	BREAK2 CHR, RMT ECHO, BREAK MODE

IACT12:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)	;COUNT BREAK2
	AOS LDBBK2(U)
	JRST IAC11A

;NORMAL CHARACTER, COMMAND MODE, REMOTE ECHO

IACT13:	PUSHJ P,RCVCHR
	 POPJ P,
	JRST IAC16B

;BREAK CHR, COMMAND MODE, REMOTE ECHO

IACT14:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBKC(U)
	MOVEM T2,LDBBKP(U)
	SETZM LDBBKI(U)	;RESET ^U POINTER
	JRST IAC16C

;BREAK2 CHR, COMMAND MODE, REMOTE ECHO, NOT BREAK2 MODE

IACT15:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)
	AOS LDBBK2(U)
IAC16B:	CAIL T4,TIWKC
IAC16C:	 PUSHJ P,CMDWAK
	JRST IAC11D
SUBTTL	BREAK2 CHR, COMMAND MODE, DEF ECHO, NOT BREAK2 MODE

IACT17:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)
	ADDM T1,LDBBK2(U)	;COUNT BREAK2
	JRST DEFNBK

;BREAK2 CHR, COMMAND MODE, DEF ECHO, BREAK2 MODE


;NORMAL CHR, COMMAND MODE, DEF ECHO

IACT21:	PUSHJ P,RCVCHR
	 POPJ P,
	JRST DEFNBK

;BREAK CHR, COMMAND MODE, DEF ECHO

IACT22:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKC(U)
	SETZM LDBBKI(U)
	MOVEM T2,LDBBKP(U)
	JRST DEFNBK
SUBTTL	SPECIAL ACTION CHRACTER, ALMOST ANY MODE

IACT0:	LDB T1,LDPMOD
	LDB T2,CHPSPI	;GET SPECIAL ACTION CODE
	XCT @INPACT(T1)

INPACT:	XCT INPA10(T2)
	XCT INPA94(T2)
	XCT INPA94(T2)
	XCT INPA10(T2)

INPA10:	POPJ P,		;NULL, IGNORE
	JRST INPESC	;ESCAPE (^C)
	JRST INPRET	;RETURN
	JRST INPGOB	;OUTPUT SUPPRESS (^O)
	JRST INPBRK	;PUT IN AS A BREAK CHR (^Q)
	JRST INPDLN	;DELETE LINE (^U)
	JRST INPTAB	;TAB (DECIDE IF BREAK OR BREAK2)
	JRST INPBRK	;ALTMODE
	JRST INPBRK	;JUST A BREAK CHR ^^
	JRST INPBRK	;^_
	JRST INPRUB	;RUBOUT
	JRST INPBRK	;^A
	JRST INPBRK	;POSSIBLE ALTMODE
	JRST INPBK2	;_
	JRST INPBRK	;^\
	JRST INPBSP	;BACKSPACE
	JRST INPSTA	;^T

INPA94:	POPJ P,		;NULL, IGNORE
	JRST INPBRK	;^C
	JRST INPRET	;RETURN
	JRST INPBRK	;^O, BREAK CHR
	JRST INPDLN	;DELETE LINE (^Q)
	JRST INPBRK	;^U
	JRST INPTAB	;TAB
	JRST INPESC	;ALTMODE (ESCAPE CHR)
	JRST INPCLD	;CONVERT TO ^D (^^)
	JRST INPESC	;^_
	POPJ P,		;RUBOUT, IGNORE
	JRST INPRB1	;^A, DELETE CHR
	JRST INPAL1	;POSSIBLE ALTMODE
	JRST INPBK2	;_
	JRST INPGOB	;^\
	JRST INPBS1	;BACKSPACE
	JRST INPBRK	;^T
SUBTTL	JUST SET AS A BREAK CHARACTER (MODE 2) AND GO

INPBRK:	MOVEI T2,2
	JRST MOVCH1	;P2 (LINE MODE) STILL SETUP

;DECIDE IF TAB IS A BREAK OR BREAK2 CHARACTER

INPTAB:	MOVEI T2,3	;NORMALLY BREAK2
	MOVSI T1,L2LTBK
	TDNE T1,LDBBYT(U)
	MOVEI T2,2	;BIT IS ON, AS A BREAK CHARACTER
	JRST MOVCH1

;DECIDE IF BACKSPACE IS A BREAK OR BREAK2 CHARACTER

INPBSP:	MOVEI T2,INPRUB
	SKIPA
INPBS1:	MOVEI T2,INPRB1
	MOVE T1,LDBDCX(U)
	TLNE T1,LXLBSD	;DELETE ON BACKSPACE?
	  JRST	(T2)	; YES
	MOVEI T2,2	;NORMALLY BREAK
	MOVSI T1,L2LBBP
	TDNE T1,LDBBYT(U)
	MOVEI T2,3	;BIT IS ON, AS A BREAK2 CHARACTER
	JRST MOVCH1

;CONVERT ^A INTO _ FOR TYMEX2 MDDE

INPTCA:	MOVEI T3,"_"
	JRST INPBK2

;RETURN HANDLER

INPRET:	MOVEI T2,1	;GET SET TO TREAT AS TYPE 1(NORMAL) CHR
	TLNE U,LDLPTP	;IF IN PAPER TAPE MODE
	JRST MOVCH1	;JUST PUT IN THE CHR
	PUSHJ P,MOVCH1	;ELSE PUT IT IN
	 JFCL		;IGNORE SKIP-NON SKIP
	MOVEI T3,12
	JRST MOVCHR	;AND THEN PUT IN A LINE FEED

;HANDLE ^^ IN 940 MODE (CONVERT TO ^D)

INPCLD:	MOVEI T3,4
	JRST MOVCH2

INPBK2:	MOVEI T2,3
	JRST MOVCH1
SUBTTL	POSSIBLE ALTMODE (175-176) IN 940 MODE

INPAL1:	TLNN U,LDLLCT
	JRST INPBRK	;IN LOWER CASE MODE, JUST CALL BREAK
	JRST INPESC

;^O IN PDP-10 MDDE

INPGOB:	MOVSI T1,LDLOSU
	XORM T1,LDBDCH(U)	;CHANGE FLAG
	PUSHJ P,TSETBO		;CLEAR OUTPUT BUFFER, set flag to send TYPGOB
	LDB T4,LDPMOD
	MOVE T4,@IGOBEC(T4)
INPOTP:	TLNE U,LDLLCP
	POPJ P,			;BUT NEVER ANYTHING TO 2741
	MOVSI T1,L2LDEL
	TDNN T1,LDBBYT(U)	;ALREADY IN \'S
	IBP T4			;NO, SKIP \ IN OUTPUT STRING
	ANDCAM T1,LDBBYT(U)	;NOT THERE NOW IN ANY CASE
	PJRST RUBSTR

;^U IN PDP-10 OR ^Q IN 940

INPDLN:	PUSHJ P,FULLCQ		;COMMAND OR FULL CHARACTER SET?
	 JRST INPBRK		;YES, BREAK CHARACTER
	PUSHJ P,RIDLIN		;THIS DOES ALL THE WORK
	 POPJ P,		;NOTHING TO ECHO
	LDB T1,LDPMOD		;GET MODE WE ARE IN
	MOVE T4,@IDLNEC(T1)	;AND GET APPROPRIATE ECHO STRING
	PJRST INPOTP

IDLNEC:	CUPTR
	UPARPT
	UPARPT
	CUPTR

IGOBEC:	COPTR
	FLLBSC
	FLLBSC
	COPTR
SUBTTL	GET RID OF A LINE OF TEXT. ADJUST ALL POINTERS

RIDLIN:	SKIPN T1,LDBBKP(U)	;IS THERE A ^U POINTER
	PJRST RIDLN3		;NO, DELETE ALL FROM BUFFER
	MOVEM T1,LDBTIP(U)
	HRRZ T2,LDBBKI(U)	;NUMBER OF CHRS SINCE ^U POINTER
	MOVNS T2
	ADD T2,LDBECC(U)
	JUMPGE T2,RIDLN1	;NONE ECHOED
	ADDM T2,LDBTIC(U)	;REMOVE SOME FROM INPUT
	MOVEI T2,0
	MOVEM T1,LDBECT(U)	;RESET ECHO POINTER
	AOS (P)			;SKIP RETURN FOR ECHO ^U
RIDLN1:	MOVEM T2,LDBECC(U)
	HLRZ T2,LDBBKI(U)	;GET NUMBER OF BREAK2 CHRS
	SETZM LDBBKI(U)		;AND GET RID OF OLD COUNTS
	MOVNS T2
	HRLZS T2
	ADD T2,LDBBK2(U)	;FIX NUMBER NOT ECHOED
	JUMPGE T2,RIDLN2	;ALL IN NOT ECHOED
	HLROS T2
	ADD T2,LDBBK2(U)	;FIX NUMBER ECHOED
	HRRZM T2,LDBBK2(U)
	POPJ P,

RIDLN2:	MOVEM T2,LDBBK2(U)
	POPJ P,

RIDLN3:	SKIPE LDBECC(U)		;ALSO ECHO IF NOT CHRS AT ALL
	SKIPE LDBTIC(U)		;ANY CHARACTERS ECHOED?
	AOS (P)			;SET SKIP RETURN
	PJRST TSETBI
SUBTTL	RUBOUT FROM PDP-10 MODE. 940 ^A JUST DOES NOT CHECK XON

INPRUB:	TLNE U,LDLPTP
	POPJ P,			;IGNORE RUBOUTS IN XON MODE
INPRB1:	PUSHJ P,FULLCQ
	 JRST INPBRK		;JUST CALL IT A BREAK CHR
	PUSHJ P,INPRBC		;COMMON RUBOUT ROUTINE
	 JRST INPRB2	;NO CHRS, GIVE RETURN
	 POPJ P,		;NOT ECHOED
	MOVEI T3,"\"
	MOVE	T4, LDBBYT(U)
	TLNN	T4, L2LBSP	;BACKSPACE FOR CHAR DELETE?
	JRST	INPRB7		;NO
	MOVE	T1,INPCH
	CAIE	T1, 10		;IS IT BACKSPACE?
	CAIN	T1, 210
	JRST	INPRB9		;YES
	MOVE	T4, LDBDCX(U)
	TLNN	T4, LXLERA	;<BS><SP><BS> OR JUST <BS>?
	JRST	INPRB6
	MOVEI	T3, 10		;<BS>
	PUSHJ	P, ENTRUB
	MOVEI	T3, 40		;<SP>
	PUSHJ	P, ENTRUB
INPRB6:	MOVEI	T3, 10		;<BS>
	JRST	INPRB8
INPRB7:	TLON T4,L2LDEL
	PUSHJ P,ENTRUB		;NO, ENTER
	MOVEM T4,LDBBYT(U)	;AND MAKE SURE WE REMEMBER IT
	MOVE T3,INPCH
	ANDI	T3, 177		;STRIP OFF PARITY BIT
	CAIE	T3, 10		;IS IT BACKSPACE?
	JRST	INPRB8		;NO
INPRB9:	MOVEI	T3,40		;YES, SUBSTITUTE <SP> FOR <BS>
	LDB	T1, LDPECH
	SKIPE	T1		;PRINT NOTHING IF NO REM BS ECHO
INPRB8:	PUSHJ P,ENTRUB
	MOVEI	T1,1
	DPB	T1,LOPRUB	;SET SEND-RUBOUT-CHARACTERS
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,

;HERE FROM _ IN TYMEX2 MODE

INPRT2:	PUSHJ P,FULLCQ
	 JRST INPBK2	;JUST TREAT AS A CHR
	PUSHJ P,INPRBC
	 POPJ P,
	 POPJ P,
	POPJ P,		;NEVER ANY ECHO
INPRBC:	HRRZ T1,LDBBKI(U)
	JUMPE T1,CPOPJ		;JUST GIVE RETURN
	AOS (P)
	LDB T3,LDBTIP(U)	;GET LAST CHARACTER INPUT
	MOVEM T3,INPCH	;AND SAVE
	SOS LDBBKI(U)
	SOS T2,LDBTIP(U)	;NOW REALLY BACK UP
	REPEAT 2,<IBP T2>	;NOW GET READY TO ADVANCE ON PREV.
	PUSHJ P,TTGETC
	 JFCL			;DO NOT CARE IF PASS OVER LINK
	MOVEM T2,LDBTIP(U)	;THAT WAS JUST IN CASE WE BACKED OVER LINK
	SOSL LDBECC(U)
	JRST [MOVSI T4,-1	;WAITING TO BE ECHOED, FORGET IT
		JRST INPRB4]
	SETZM LDBECC(U)
	SOS LDBTIC(U)
	MOVEM T2,LDBECT(U)	;RESET ECHO POINTER TO INPUT
	TLNN U,LDLCOM	;IF AT COMMAND IGNORE ECHO
	TLNN U,LDLNEC	;IF NOT ECHOING, NO ECHO
	TLNE U,LDLLCP	;BUT NEVER ECHO LOCAL COPY
	JRST INPRB3		;DUMP CHR
	AOS (P)
INPRB3:	MOVNI T4,1		;T4 WILL HAVE THING TO ADD TO BK2
INPRB4:	MOVE T3,INPCH
	TRZ T3,200
	TRNE T3,400
	POPJ P,		;IMAGE MODE CHRS NEVER COUNT
	MOVE P3,CHRTAB(T3)
	LDB T1,CHPINP
	XCT INPRTB(T1)		;WANT ONLY BREAK2 CHRS
INPRB5:	MOVSI T1,-1		;WILL HAV SOS'ED CORRECT HALF OF LDBBK2
	ADDM T1,LDBBKI(U)
	POPJ P,

INPRTB:	JRST INPRAC	;MUST WORRY ABOUT TAB
	POPJ P,		;NORMAL CHR
	POPJ P,		;BREAK CHR
	ADDM T4,LDBBK2(U) ;BREAK 2
INPRAC:	LDB T1,CHPSPI
	XCT INPRTA(T1)
	TDNE T1,LDBBYT(U)	;HERE ONLY FOR TAB WITH T1=L2LTBK
	POPJ P,			;TREAT AS BREAK
INPRA1:	ADDM T4,LDBBK2(U)
	JRST INPRB5

INPRTA:	REPEAT 6,<POPJ P,>
	MOVSI T1,L2LTBK
	REPEAT 6,<POPJ P,>
	MOVEI T1,0	;_ ALWAYS BREAK2
	POPJ P,		;^\
	JRST	[MOVSI T1,L2LBBP
		 TDNN T1,LDBBYT(U)	;TEST BACKSPACE BREAK FLAG
		 POPJ P,		;TREAT AS BREAK
		 JRST INPRA1]		;TREAT AS BREAK2

INPRB2:	MOVE T4,FLLBSC
	JRST INPOTP

;;
;; Here on ^T in PDP-10 mode, to see if it should be interpreted as
;; a .USESTAT command.
;;
INPSTA:	MOVSI	T1,LXLRTC
	TDNN	T1,LDBDCX(U)	;Special ^T mode set?
	  JRST	INPBRK		;No, just treat as break
	MOVEI	T1,CMFSTA##	;Forced command code for .USESTAT
	PJRST	TTFORC
SUBTTL	ESCAPE CHARACTER 940 IS ^_ OR POSSIBLY ALTMODE, PDP-10 IS ^C

INPESC:	PUSHJ P,ESCTRP		;CHECK ESCAPE TRAP
				;DOES DOUBLE RETURN
				;(OUT OF INPESC) IF TRAP TAKEN
	SKIPE LDBBKI(U)
	PUSHJ P,RIDLIN		;REMOVE LINE IF ANY
	 JFCL			;NEVER ECHO ANYTHING
	MOVSI T1,L2LCCS
	TDNN T1,LDBBYT(U)	;SECOND?
	JRST INPES1		;NO, JUST STORE IT
	PUSHJ P,CNCCHK		;SEE IF CMD LEVEL, SLAVED, ETC.
	 JRST INPES0		;JUST STORE IT
	PUSHJ P,TSETBI		;CLEAR INPUT
	PUSHJ P,TSETBO		;AND OUTPUT BUFFERS (send TYPGOB)
	MOVSI T1,LDLOSU	;SUPRESS OUTPUT (UNTIL WE HAVE HALTED)
	IORM T1,LDBDCH(U)
	HLL U,LDBDCH(U)	;MAKE SURE LINE KNOWS ABOUT IT
	LDB T1,LDPMOD
	MOVE T4,@INPEST(T1)	;GET CORRECT THING TO PRINT
	PJRST INPOTP

INPEST:	CCPTR
	FLLBSC
	FLLBSC
	CCPTR

INPES0:	TLNE U,LDLCOM	;IF COMMAND MODE
	PUSHJ P,TSETBO	;CLEAR OUTPUT BUFFER
INPES1:	PUSHJ P,INPBRK	;PUT IT IN AS A BREAK CHR
	 SKIPA
	AOS (P)		;TRANSFER SKIP RETURN TO US
	MOVSI T1,L2LCCS
	IORM T1,LDBBYT(U)	;SET FLAG
	POPJ P,
SUBTTL MODE CONVERSION TABLE

	DEFINE LMOD (ECH,INP)
	<BYTE (29)0(3)ECH(4)INP>

MDFLMD:	LMOD 2,11
	LMOD 2,4
	LMOD 2,3
	LMOD 2,1
	LMOD 3,10
	LMOD 3,5
	LMOD 3,3
	LMOD 3,1
	LMOD 1,6
	LMOD 1,4
	LMOD 1,2
	LMOD 1,1
	LMOD 1,7
	LMOD 1,5
	LMOD 1,2
	LMOD 1,1
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
SUBTTL OUTPUT DISPATCHER

;HERE AT CH7 TO SCAN LINTAB FOR PORTS NEEDING OUTPUT, SCAN
;LDBOUT FOR THOSE PORTS, AND DISPATCH TO THE APPROPRIATE
;OUTPUT ROUTINES

SCNOUT:	PUSHJ	P,SETOUT	;PREPARE FOR TYMNET OUTPUT, skip if room
	  SKIPLE MULCNT+1	;ORING is full, how about PTYs
	 JRST	.+2		;Room in either ORING or PTY count
	JRST	FINOUT		;  DO NOTHING THIS CYCLE

    ;FIND THE NEXT PORT (IN A ROUND-ROBIN FASHION) THAT WANTS
    ;TO DO OUTPUT

	SKIPL	T1,LINPTR	;IF NO ROUND-ROBIN PTR EXISTS,
	 MOVSI	T1,NMXFLG	;  SET TO START AT PORT 0
SCOLP1:	MOVEM	T1,LINPTR
	SKIPN	U,LINFLG(T1)	;IF NO NEED-OUTPUT BITS IN THIS WORD,
	 JRST	NOLIN2		;  GO ON TO THE NEXT ONE
	MOVE	T4,BITNTB(T1)	;T4/ PORT# CORRESPONDING TO BIT 0
SCOLP:	JFFO	U,.+2		;T1/ BIT# OF FIRST. IF NONE,
	 JRST	NOLIN2		;  GO ON TO THE NEXT WORD
	LSH	U,1(T1)		;GET RID OF THE BIT WE JUST FOUND
	MOVEM	U,LINFSV	;SAVE THE REST OF THE WORD
	ADD	T1,T4		;T1/ PORT# FOR THE BIT WE JUST FOUND
	MOVEM	T1,LINPNM	;SAVE THAT TOO
	MOVE	U,LINTAB(T1)	;U/ LDB ADDR
	HLL	U,LDBDCH(U)	;U/ DCH BITS,,LDB ADDR
	CAIGE	T1,RPORTN	;Is it one of the real ports?
	 JRST	SCORTY		;Yes
	PFALL	SCOPTY		;No
   ;PREPARE TO DO OUTPUT ON A PSEUDO-PORT

;P035/C06 17-Nov-87 - Complain if LDLPTY is wrong and fix it.
;This bug is triggered by an incoming zap during login and prevented the
;outgoing zap from reaching the base, causing "slot out of ports".

SCOPTY:	TLON	U,LDLPTY	;P(SEUDO)TY OR R(EAL)TY?
	 STOPCD (.+1,INFO,TTYPTY,PRTUT1,<PTY bit wrong for TTY>) ;;SCOPTY+1
	HLLM	U,LDBDCH(U)	;Reset it if LDLPTY was wrong
	MOVE	T1,TTFREN
	CAILE	T1,TIRSVD	;IF NO SYSTEM BUFFERLETS
	SKIPG	MULCNT+1	;OR PTY "FLOW" QUOTA EXCEEDED,
	 JRST	NOLIN		;  MAYBE THE NEXT PORT'S A REAL TTY
	PUSHJ	P,SETPTL	;T1/ MAX CHARS TO XFER
	MOVEI	W,1		;W = 1 = PTY
	JRST	SCOTTY

;Typeout routine for STOPCD(TTYPTY)
PRTUT1:	PUSH	P,T1		;Routine to output the contents of U and T1
	PUSH	P,U
	PUSHJ	P,INLMES
	 ASCIZ /Bits,,Line = /
	POP	P,T1		;Contents of U
	PUSHJ	P,HWDPNT
	PUSHJ	P,INLMES
	 ASCIZ /  Contents of T1 = /
	POP	P,T1		;Get saved value
	PUSHJ	P,HWDPNT	;Print as halfwords
	PJRST	CRLF##

    ;PREPARE TO DO OUTPUT ON A REAL PORT

SCORTY:	TLZE	U,LDLPTY	;P(SEUDO)TY OR R(EAL)TY?
	 STOPCD (,XCT,TTYPTY) ;;SCORTY+1
	HLLM	U,LDBDCH(U)	;Reset it if LDLPTY was wrong
	SKIPG	MULCNT+0	;IF NO ROOM FOR REAL TTY OUTPUT,
	 JRST	NOLIN		;  MAYBE THE NEXT PORT'S A PTY
	MOVEI	T1,%CHRMX	;T1/ MAX CHRS TO XMIT (EBUS02.J01 uses ^D30)
	SETZ	W,		;W = 0 = REAL TTY
	PFALL	SCOTTY

    ;LOOK FOR THE HIGHEST-PRIORITY OUTPUT REQUEST ON THE LINE

SCOTTY:	MOVEM	T1,CHQTA
	MOVEM	T1,CHCNT
	MOVE	T1,LDBOUT(U)	;T1/ OUTPUT BITS
	JFFO	T1,GOLIN
	 JRST	MORLN2		;NOTHING (THAT'S FUNNY...)
GOLIN:	JUMPGE	U,GOLIN1	;IF PORT'S BACKPRESSURED
	CAIG	T2,BPOKBN	; AND OUTPUT TYPE IS HIGH ENOUGH PRI
	 JRST	GOLIN1		; THEN OUTPUT IS OK
	CAILE   T2,LAPBIT       ;BEYOND LAST LEGAL PRIORITY BIT?
	 JRST   MORLN2          ;YES.  ASSUME NO OUTPUT
	LDB	T1,LOPECO
	JUMPN	T1,GOLIN2	;ATTEMPT ECHO EVEN IF BACKPRESSURE ON
Golin3:	SETZ	T1,		;PORT IS BACKPRESSURED
	DPB	T1,LDBOPB(U)	;  CLEAR NEED-OUTPUT
	JRST	FULLIN		;  AND SAY WE'RE THROUGH

GOLIN2:	MOVEI	T2,NUMECO	;ECHO BIT NUMBER
GOLIN1:	MOVEM	T2,SVOJFF	;SAVE THE BIT NUMBER
	JUMPE	W,@OUTTRN(T2)	;REAL TTY DISPATCH
	JRST	@PTYTRN(T2)	;PSEUDO-TTY DISPATCH
    ;OUTPUT SUCCESSFUL, ROOM FOR MORE

MORLIN:	MOVN	T2, SVOJFF	;T2/ -(BIT# WE DISPATCHED FOR)
	MOVSI	T1, (1B0)
	LSH	T1, (T2)	;T1/ BIT WE DISPATCHED FOR
	ANDCAB	T1, LDBOUT(U)	;CLEAR IT AND PICK UP THE REST
	JFFO	T1, GOLIN	;IF THERE'S MORE TO DO, DO IT

    ;FINISHED WITH THE LAST OUTPUT REQUEST FOR THIS PORT

MORLN2:	DPB	T1, LDBOPB(U)	;CLEAR NEED-OUTPUT BIT
	PUSHJ	P, XMTWAK	;WAKE UP THE JOB FOR GOOD MEASURE
	JRST	FULLIN

    ;OUTPUT SUCCESSFUL, NO ROOM FOR MORE

FINLIN:	MOVN	T2, SVOJFF
	MOVSI	T1, (1B0)
	LSH	T1, (T2)
	ANDCAB	T1, LDBOUT(U)
	JUMPE	T1, MORLN2
	JRST	FULLIN

    ;OUTPUT NOT DONE BECAUSE WE'RE WAITING FOR SOMETHING
    ;(E.G., CAN'T OUTPUT ECHO CHARACTERS IF THE PORT'S NOT
    ;IN INPUT WAIT). CODE FOR "SOMETHING"S MUST TURN
    ;THE NEED-OUTPUT BIT BACK ON

WATLIN:	MOVEI	T1, 0
	DPB	T1, LDBOPB(U)
	PUSHJ	P, XMTWAK
	JRST	FULLIN
    ;OUTPUT NOT DONE AND/OR FINISHED WITH THIS PORT

FULLIN:	HRRZ	F, LDBDDB(U)
	JUMPE	F, FULLN2
	LDB	T1, PJOBN
	MOVE	T4, CHQTA
	SUB	T4, CHCNT
	ADDM	T4, JBTCOT(T1)
	ADDM	T4, JBTCOT	;System-wide # of characters output
FULLN2:	JUMPN	W, FULLN3

    ;DONE WITH A REAL TTY

	PUSHJ	P, CLSCHR	;FINISH CHARACTER-OUTPUT MESSAGE
	  SKIPLE MULCNT+1	;No room in ORING.  Any PTY room?
	 JRST	NOLIN		;Room in ORING or room for PTY I/O
	JRST	FINOUT		;  QUIT

    ;DONE WITH A PTY

FULLN3:	CAIE	W, 1
	 STOPCD
	PUSHJ	P, CLSPTL	;FINISH CHARACTER OUTPUT
	SKIPG	MULCNT+0	;IF THERE'S ROOM FOR REAL PORTS
	SKIPLE	MULCNT+1	;OR PTYS,
	 JRST	NOLIN		;  GO ON
	JRST	FINOUT		;ELSE QUIT

    ;GO ON TO THE NEXT PORT

NOLIN:	AOS	T4, LINPNM
	MOVE	U, LINFSV
	JUMPN	U, SCOLP	;TRY TO FIND ANOTHER IN GROUP
NOLIN2:	MOVE	T1, LINPTR
	AOBJN	T1, SCOLP1	;TRY ANOTHER GROUP
	SETZM	LINPTR		;(START FROM BEGINNING NEXT TIME)
FINOUT:	AOSG	FSCN	;(IF IT WAS 0 (NOW 1), THERE WAS NO I/O)
	 JRST	SCNIN	;IF I/O DONE THIS CYCLE, GO CHECK INPUT AGAIN
	SETZM	FSCN	;OTHERWISE, CLEAR FSCN
	POPJ	P,	;AND RETURN (FROM SCNINT) TO THE TICK LOGIC
SUBTTL	OUTPUT DISPATCH TABLES

DEFINE ZZZ(NAME), <GO'NAME>
OUTTRN:	OUTBIT

DEFINE ZZZ(NAME), <PG'NAME>
PTYTRN:	OUTBIT
SUBTTL PTY "OUTPUT" ROUTINES

PTBSIZ==^D120

;SETPTL - CALLED WITH U/ PTY LDB TO SET UP FOR OUTPUT THENCE
;	IF THE OTHER END IS IN BLOCK INPUT WAIT, IT SETS
;	CHRWRP+1 TO POINT TO THE NEXT FREE BYTE IN THE
;	BLOCK INPUT BUFFER
;	OTHERWISE, IT SETS CHRWRP+1 TO POINT TO THE
;	PTY BUFFER
;	SETS T1/ MAX # CHARS TO MOVE

SETPTL:	SETZM	PBDISC		;CHARIO DISCOUNT FOR BLOCK OUTPUT
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNE	T1, LDBDCH(U)	;IF BLOCK INPUT IS IN PROGRESS,
	 JRST	SETPTB		;  DO THINGS DIFFERENTLY

    ;HERE WHEN OTHER END IS NOT IN BLOCK INPUT WAIT

	SETZM	DIDPBI
	MOVE	T1, [POINT 8, PTYBUF]
	MOVEM	T1, CHRWRP+1
	MOVE	T1, TIWRNN	;T1/ # CHARS ALLOWED BEFORE BACKPRESSURE
	SUB	T1, LDBTIC(U)
	SUB	T1, LDBECC(U)	;T1/ # MORE CHARS THAT WILL FIT
	SKIPGE	T1		;IF WE'LL BE BACKPRESSURED,
	 MOVEI	T1,%CHRMX	;  T1/ NORMAL (REAL TTY) LIMIT
	CAILE	T1, PTBSIZ
	MOVEI	T1, PTBSIZ	;MUSTN'T BE .gt. THAN THE PTY BUFFER SIZE
	POP	P, U
	POPJ	P,

    ;HERE WHEN THE OTHER END IS IN BLOCK INPUT WAIT

SETPTB:	SETOM	DIDPBI
	HRRZ	T1, LDBBIO(U)	;T1/ BLOCK INPUT BUFFER ADDR
	SKIPE	T1		;IF NONE,
	SKIPL	BIOCHR(T1)	;OR IF NO INPUT PENDING,
	 STOPCD 		;  DIE
	MOVE	T2, BIOPBP(T1)	;T2/ BLOCK IDPB POINTER
	MOVEM	T2, CHRWRP+1
	MOVE	T1, BIOPBC(T1)	;T1/ # BYTES LEFT THERE
	POP	P, U
	POPJ	P,
SUBTTL	CLSPTL - CALLED WITH U/ PTY LDB TO FINISH UP OUTPUT THITHER
;	IF OTHER END WAS DOING BLOCK INPUT, THE CHARACTERS ARE
;	ALREADY MOVED - WE JUST NEED TO UPDATE THE BUFFER
;	POINTER&COUNT AND SEE IF WE'VE FILLED IT YET
;	OTHERWISE WE NEED TO MOVE THE CHARACTERS TO THE
;	OTHER END

CLSPTL:	MOVE	T1, PBDISC
	ADDM	T1, CHCNT	;ADJUST CHARIO COUNT FOR BLOCK OUTPUT
	SKIPE	DIDPBI		;IF OTHER END WAS DOING BLOCK INPUT,
	JRST	CLSPTB		;  HANDLE THINGS DIFFERENTLY

	MOVE	T1, CHRWRP+1	;T1/ BYTE POINTER
	CAMN	T1, [POINT 8, PTYBUF]
	POPJ	P,		;(NOTHING TO OUTPUT)

	PUSH	P, U
	PUSH	P, [0]
	PUSH	P, T1
	PUSH	P, [POINT 8, PTYBUF]

    ;-2(P) = 0 IF REM. ECHO, -1 IF DEFERRED
    ;-1(P) IS ORIGINAL ENDING BYTE POINTER
    ;  (P) IS SOURCE BYTE POINTER

	PUSHJ	P, PTYBUD	;U/ BUDDY'S LDB
CLSLP1:	UUILDB	T3, (P)		;T3/ CHAR
	PUSHJ	P, MOVCHR	;DEPOSIT IT
	  JRST	.+2
	SETOM	-2(P)		;(ENTERED DEFERRED ECHO MODE)
	MOVE	T1, (P)
	CAME	T1, -1(P)
	JRST	CLSLP1

	SKIPN	T1, -2(P)	;IF IT ENTERED DEFERRED ECHO MODE,
	JRST	CLSLP2
	DPB	T1, LOPECO	;  SET NEED-ECHO
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
CLSLP2:	SUB	P, [3,,3]	;DISCARD THE THREE LOCALS
	POP	P, U		;RESTORE U
	POPJ	P,
    ;HERE WHEN THE OTHER END WAS DOING BLOCK INPUT

CLSPTB:	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IF BLKI NO LONGER IN PROGRESS,
	 JRST	UPOPJ		;  NOTHING TO DO
	HRRZ	T1, LDBBIO(U)	;T1/ BLOCK INPUT BUFFER ADDRESS
	SKIPN	T1
	 STOPCD
	MOVE	T3, CHRWRP+1
	MOVEM	T3, BIOPBP(T1)	;UPDATE BYTE POINTER
	MOVE	T3, CHCNT
	SUB	T3, CHQTA	;T3/ - # OF CHARACTERS MOVED
	ADDB	T3, BIOPBC(T1)	;UPDATE BYTES-LEFT COUNT
	JUMPE	T3, CLSPBF	;(BUFFER FILLED)

    ;HERE WHEN WE HAVEN'T FINISHED FILLING THE BUFFER YET

	SKIPG	T3
	 STOPCD 		;(WENT TOO FAR)
	MOVEI	T1, %PBTIM
	DPB	T1, LDPTIM	;RESET BLOCK-INPUT TIMER
UPOPJ:	POP	P,U
	POPJ	P,

    ;HERE WHEN WE'VE JUST FILLED A BLOCK INPUT BUFFER

CLSPBF:	HRRZ	T4, BIOCHR(T1)	;T4/ (PRESUMABLY) # CHARS MOVED
	PUSHJ	P, FRCIBF	;SIMULATE BUFFER-FULL MESSAGE
	SETZ	T1,
	DPB	T1, LDPTIM	;CLEAR BLOCK-INPUT TIMER
	MOVEI	T1, LDRBIP
	ANDCAM	T1, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	POP	P, U
	PUSHJ	P, FRCNOO	;BACKPRESSURE OURSELVES
	POPJ	P,
    ;IMPOSSIBLE OUTPUT BITS

PGSRD:	;RED BALL
PGSGR:	;GREEN BALL
	 STOPCD

    ;IGNORED OUTPUT BITS

PGSEC:	;SET ECHO MODE (SHOULD ALWAYS BE OFF)
PGSTP:	;TERMINAL CHARACTERISTICS PROBE
PGHNG:	;HANG UP DATA SET
	JRST	MORLIN

    ;NOT IMPLEMENTED YET - IGNORE

PGSTC:	;SET TERMINAL CHARACTERISTICS
	JRST	MORLIN
SUBTTL	MSGSIM - SIMULATE INPUT-MESSAGE ARRIVAL
;	CALLED WITH T1/ ADDR OF A FRC--- ROUTINE
;	CALLS <T1> WITH U/ THE CURRENT PTY'S "BUDDY"

MSGSIM:	PUSH	P, U		;SAVE U
	PUSHJ	P, PTYBUD	;U/ "BUDDY" LDB
	HLL	U, LDBDCH(U)
	PUSHJ	P, (T1)		;SIMULATE A <T1>-ARRIVAL
	POP	P, U
	JRST	MORLIN

;CHARACTER GOBBLER

PGCGB:	MOVEI	T1, FRCCGB
	PJRST	MSGSIM


;ORANGE BALL

PGSOG:	MOVSI	T2, L2LDEL
	TDNN	T2, LDBBYT(U)	;IF WE'RE IN \...
	 PUSHJ	P, WTCHK	;OR WE'RE IN INPUT WAIT,
	  JRST	WATLIN		;  WAIT
	MOVEI	T1, FRCORG
	PJRST	MSGSIM

;BACKPRESSURE ON

PGBPN:	MOVEI	T1, LDRXOS
	TDNE	T1, LDBDCH(U)	;IF WE'VE ALREADY SENT AN XOFF,
	 JRST	MORLIN		;  DON'T SEND ANOTHER
	IORM	T1, LDBDCH(U)
	MOVEI	T1, FRCNOO
	PJRST	MSGSIM

;BACKPRESSURE OFF

PGBPF:	MOVEI	T1, LDRXOS
	ANDCAM	T1, LDBDCH(U)	;CLEAR BACKPRESSURE-SEND FLAG
	MOVEI	T1, FRCDOO
	PJRST	MSGSIM
SUBTTL	YELLOW BALL

PGSYL:	PUSH	P, U
	PUSHJ	P, PTYBUD
	HLL	U, LDBDCH(U)
	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IS OTHER END DOING BLOCK INPUT?
	 JRST	PGSYLN		;(NO)

    ;HERE WHEN THE OTHER END'S DOING BLOCK INPUT

	ANDCAM	T1, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	HRRZ	T1, LDBBIO(U)
	SKIPE	T1
	SKIPL	T2, BIOCHR(T1)
	 STOPCD
	HRRZ	T4, T2		;T4/ # CHARS TO TRANSFER
	SUB	T4, BIOPBC(T1)	;T4/ # CHARS TRANSFERRED
	PUSHJ	P, FRCEOT	;FAKE A BLKI-EOT
	POP	P, U
	PUSHJ	P, FRCNOO	;BACKPRESSURE OURSELVES
	JRST	WATLIN		;(SEND YLB WHEN BKP RELIEVED)

    ;HERE IN THE NORMAL CASE

PGSYLN:	MOVSI	T1, L2LOWT
	IORM	T1, LDBBYT(U)	;SAY WE'RE WAITING
	MOVSI	T1, L2LOWS
	ANDCAM	T1, LDBBYT(U)	;AND THAT WE HAVEN'T SEEN ONE
	PUSHJ	P, FRCYEL
	POP	P, U
	JRST	MORLIN
SUBTTL	WHEN THE PTY OUTPUT CODE FILLS UP A BLOCK INPUT BUFFER, IT
;FORCES BACKPRESSURE ON THE LINE DOING THE OUTPUT - THE
;REQUEST-BLOCK-INPUT AND REQUEST-BLOCK-INPUT-TERMINATION
;OUTPUT ROUTINES CLEAR THE BACKPRESSURE

;TERMINATE BLOCK INPUT

PGTRI:	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IF BLOCK INPUT'S IN PROGRESS,
	 JRST	PGTRI1
	ANDCAM	T1, LDBDCH(U)	;  CLEAR IN-PROGRESS FLAG
	HRRZ	T1, LDBBIO(U)	;  T1/ BLOCK INPUT BUFFER ADDR
	SKIPE	T1
	SKIPL	T2, BIOCNT(T1)
	 STOPCD (,XCT,TTYNPB)	;No PTY Buffer for block IO  ;;PGTRI+7
	HRRZ	T4, T2		;  T4/ # OF CHARS TO TRANSFER
	SUB	T4, BIOPBC(T1)	;  T4/ # OF CHARS TRANFERRED
	JRST	.+2		;OTHERWISE
PGTRI1:	SETZ	T4,		;  T4/ 0 CHARS
	PUSHJ	P, FRCIHR	;FAKE A TERMINATED-BY-REQUEST
	JRST	PGBIN1		;CLEAR BACKPRESSURE ON THE OTHER END

;REQUEST BLOCK INPUT

PGBIN:	MOVEI	T1, LDRBIP
	IORM	T1, LDBDCH(U)	;MARK INPUT IN PROGRESS
	MOVEI	T1, %PBTIM
	DPB	T1, LDPTIM	;SET BLOCK-INPUT TIMEOUT
	HRRZ	T1, LDBBIO(U)	;T1/ INPUT BUFFER ADDRESS
	SKIPN	T1
TTYNPB:: STOPCD (.,JOB,TTYNPB,,<No PTY Buffer for block IO>) ;;PGBIN+6
	HRRZ	T2, BIOCHR(T1)	;T2/ # CHARS TO TRANSFER
	MOVEM	T2, BIOPBC(T1)	;STORE PTY COUNT
	MOVE	T2, [POINT 8,BIODAT]
	ADD	T2, T1
	MOVEM	T2, BIOPBP(T1)	;STORE PTY BYTE POINTER

    ;HERE FROM ABOVE AND FROM PGTRI TO CLEAR BACKPRESSURE

PGBIN1:	PUSH	P, U
	PUSHJ	P, PTYBUD
	HLL	U, LDBDCH(U)
	PUSHJ	P, FRCDOO	;CLEAR BACKPRESSURE ON OTHER END
	POP	P, U
	JRST	MORLIN
SUBTTL	PBTIMO - CALLED BY SCNSEC WHEN A PORT DOING BLOCK INPUT
;	   TIMES OUT.
;	   SAVES P1-P4.
;	   ASSUMES THAT FRCITM PRESERVES U AND F.

PBTIMO:	PUSH	P, P1
	PUSH	P, P2
	PUSH	P, P3
	PUSH	P, P4

	HRRZ	T1, LDBBIO(U)
	SKIPE	T1
	SKIPL	T4, BIOCHR(T1)
	 STOPCD 		;NO BUFFER OR NO INPUT PENDING
	MOVEI	T2, LDRBIP
	ANDCAM	T2, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	HRRZ	T4, T4		;T4/ # BYTES REQUESTED
	SUB	T4, BIOPBC(T1)	;T4/ # BYTES TRANSFERRED
	PUSHJ	P, FRCITM	;FAKE A TIMEOUT MESSAGE
	PUSH	P, U
	PUSHJ	P, PTYBUD
	PUSHJ	P, FRCNOO	;BACKPRESSURE OTHER END
	POP	P, U

	POP	P, P4
	POP	P, P3
	POP	P, P2
	POP	P, P1
	POPJ	P,
SUBTTL	BLOCK OUTPUT

PGBOT:	SKIPN	DIDPBI		;IF THE OTHER END WAS DOING BLOCK INPUT,
	 JRST	PGBOTC
	MOVE	T1, CHCNT
	CAME	T1, CHQTA	;AND IT HASN'T GOTTEN ANY CHARS YET,
	 JRST	PGBOTC
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNE	T1, LDBDCH(U)	;AND IT'S STILL IN BLOCK INPUT WAIT,
	 JRST	PGBOT1
	POP	P, U
	JRST	PGBOTC

PGBOT1:	HRRZ	T1, LDBBIO(U)	;  T1/ ITS BLOCK INPUT BUFFER
	SKIPN	T1
	 STOPCD
	HRRZ	T2, (P)		;  T2/ OUR LDB ADDR
	HLRZ	T3, LDBBIO(T2)	;  T3/ OUR BLOCK OUTPUT BUFFER
	SKIPN	T3
	 STOPCD
	HRRM	T3, LDBBIO(U)	;  OUR OUTPUT = ITS INPUT
	HRLM	T1, LDBBIO(T2)	;  ITS INPUT = OUR OUTPUT
	MOVE	T4, BIOREQ(T1)
	EXCH	T4, BIOREQ(T3)
	MOVEM	T4, BIOREQ(T1)	;  BUT KEEP THE OLD BIOREQ'S
	SKIPL	T1, BIOCHR(T1)	;  T1/ -1,,# CHARS "TRANSMITTED"
	 STOPCD
	MOVEM	T1, BIOCHR(T3)	;  INPUT SIDE WANTS THE -1 FLAG
	HRRZS	BIOCHR(T1)	;  OUTPUT SIDE DOESN'T
	HRRZM	T1, PBDISC	;  ALREADY CHARGED (JBTBIO), SO DISCOUNT
	POP	P, U
	SETZM	CHCNT		;  WE'VE FILLED ITS BUFFER
	PUSHJ	P, FRCOHR	;  WE'VE DONE OUR BLOCK OUTPUT
	JRST	FINLIN		;  NO MORE THIS CYCLE

    ;HERE WHEN THE OTHER END'S NOT COOPERATING BY DOING BLOCK INPUT

PGBOTC:	HLRZ	T1, LDBBIO(U)	;T1/ BLOCK OUTPUT BUFFER
	SKIPN	T1
	 STOPCD
	HRRZ	T2, BIOCHR(T1)	;T2/ TOTAL CHARS TO TRANSFER
	MOVEM	T2, BIOPBC(T1)	;STORE IT
	MOVE	T3, [POINT 8,BIODAT]
	ADD	T3, T1		;T3/ BYTE POINTER
	MOVEM	T3, BIOPBP(T1)	;STORE IT
	MOVEI	T1, 1
	DPB	T1, LOPBOP	;SET BLOCK-OUTPUT-IN-PROGRESS
	JRST	MORLIN		;(DISPATCH WILL GO DO IT)
;BLOCK OUTPUT IN PROGRESS

PGBOP:	HLRZ	T1, LDBBIO(U)
	SKIPN	T1
	 STOPCD
	MOVE	T2, BIOPBC(T1)	;T2/ COUNT
	MOVE	T3, BIOPBP(T1)	;T3/ POINTER
	MOVE	T4, MULCNT+1
	CAMLE	T4, CHCNT
	MOVE	T4, CHCNT	;T4/ MIN(MULCNT+1,CHCNT)
	PUSH	P, T4		;SAVE IT
	CAMLE	T2, T4
	MOVE 	T2, T4		;T4/ MIN(# TO XFER,# THAT'LL FIT)
	PUSH	P, T2		;SAVE IT

	JUMPE	T2, PGBOP2
PGBOP1:	UUILDB	T4, T3
	UUIDPB	T4, CHRWRP+1
	SOJG	T2, PGBOP1

PGBOP2:	POP	P, T2
	ADDM	T2, PBDISC	;(TO BE DISCOUNTED FROM CHARIO CHARGE)
	MOVN	T4, T2
	ADDM	T4, MULCNT+1	;DECREMENT MULCNT
	ADDM	T4, CHCNT	;AND CHCNT
	ADDM	T4, (P)		;AND SAVED # THAT'LL FIT
	ADDB	T4, BIOPBC(T1)	;AND BLOCK-BUFFER COUNT
	JUMPG	T4, PGBOP3	;IF WE'RE DONE
	PUSHJ	P, FRCOHR	;  FAKE AN OUTPUT-TERMINATED
	POP	P, T1
	JUMPLE	T1, FINLIN
	JRST	MORLIN
				;OTHERWISE,
PGBOP3:	MOVEM	T3, BIOPBP(T1)	;  UPDATE CHARACTER POINTER
	POP	P, T1
	JRST	FULLIN
SUBTTL	TERMINATE BLOCK OUTPUT

PGTRO:	SETZ	T1,
	DPB	T1, LOPBOP	;CLEAR BLKO-IN-PROGRESS
	PUSHJ	P, FRCOHR	;FAKE AN OUTPUT-TERMINATED
	JRST	MORLIN


SUBTTL	CIRCUIT ZAPPER

PGZAP:	MOVSI	T1,L2LOWT	;ZAP PTY
	TDNN	T1,LDBBYT(U)	;IF WAITING FOR ORANGE BALL,
	SKIPE	LDBBIO(U)	;OR IF BLOCK I/O NEEDS CLEANING-UP,
	 JRST	WATLIN		;  WAIT
	SETZB	T1,LDBLOG(U)	;MARK THIS PORT GONE
	DPB	T1,LDPHST	;Clear origination host
	SETZM	LDBMOD(U)
	PUSHJ	P,TSETBO
	PUSHJ	P,TSETBI
	SETZ	T1,
	DPB	T1,LDBOPB(U)	;CLEAR NEED-OUTPUT
	PUSH	P,U
	PUSHJ	P,PTYBUD	;U/ "BUDDY" LDB
	SKIPN	LDBLOG(U)	;IF IT'S ALREADY GONE,
	 JRST	PGZAP1		;  THERE'S NOTHING MORE TO DO
	HLL	U,LDBDCH(U)
	PUSHJ	P,FRCZAP	;FAKE A ZAPPER THERE
PGZAP1:	POP	P,U
	JRST	FINLIN

;BELL (SHOULDN'T REALLY HAPPEN) - SIMULATE BLACK BALLS

PGSBL:	AOS	PTYLOS		;COUNT CHARACTER LOST BY US
	MOVEI	T1, 1
	PUSHJ	P, FRCLOS	;"INPUT LOST" TO BELL SENDER
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, 0
	PUSHJ	P, FRCLOS	;"OUTPUT LOST" TO OTHER END
	POP	P, U
	HRRZ	F,LDBDDB(U)	;Point to TTY DDB (for stopcode processor)
	 STOPCD	(.+1,INFO,PTYSBL,,<PTY saw a Black Ball>)  ;;PGSBL+10
	JRST	MORLIN		;(Fixed in P035/C07 - was a POPJ)
SUBTTL TYMNET OUTPUT ROUTINES

;THIS ROUTINE IS CALLED TO FINISH UP OUTPUT. IT NONSKIP-RETURNS
;IF THERE IS NO BUFFER SPACE NOW.

CLSCHR:	SKIPGE	T1,MXMCNT
	 JRST	SETOUT		;WE REALLY DON'T THINK ANY CHRS THERE
	SUB	T1,MULCNT+0	;COMPUTE NUMBER OUTPUT
	JUMPE	T1,CPOPJ1	;NONE SO MUST STILL BE SPACE
	SKIPG	MULCNT+0	;DID WE RUN OUT OF ROOM IN RING
	 SOS	CHCNT+0		;YES, ACTUALLY 1 MORE CHR OUT
	SETOM	FSCN		;FLAG AS SOME OUTPUT
	TRO	T1,200		;SET BIT TO FLAG AS DATA TYPE
	DPB	T1,OUPTYP	;SET IN TYPE FIELD
	LDB	T3,LDPLNO
	DPB	T3,OUPLIN	;AND THE PORT NUMBER
	PUSH	P,P3		; SAVE P3, THEN SETUP AS USUAL
	MOVE	P3,ORING(P4)	;  ORING(P4) contains data
	PUSHJ	P,ORPLOG	; Log the transmission
	POP	P,P3		; Restore saved P3 (someone want it)
	SUBI	T1,200-5	;COMPUT NUMBER OF WORDS USED
	LSH	T1,-2
	ADD	P4,T1
ADVPTR:	ANDI	P4,MSKORG
	MOVEM	P4,ORPPDP	;SET FOR 620 TO FIND
	SETZM	ORPTIM##	;Reset ORING timer
	PFALL	SETOUT		;AND FIND OUT ABOUT MORE SPACE


;THIS ROUTINE IS CALLED TO SET THINGS UP FOR CHARACTER
;OUTPUT. NON-SKIP RETURN MEANS NO ROOM IN OUTPUT BUFFER

SETOUT:	SETOM	MXMCNT		;FLAG THAT NO ROOM THERE
	SETOM	MULCNT+0	;Flag that we've been here (no room?)
	MOVE	P4,ORP620
	SUB	P4,ORPPDP	;SIZE OF SPACE IN OUTPUT RING
	SOJL	P4,[MOVEI P4,MSKORG+1
		SKIPN	ORP620	  ;IF 620 AT 0 CAN NOT
		 MOVEI	P4,MSKORG ;USE LAST WORD
		SUB	P4,ORPPDP ;FIND SPACE TO END OF BUFFER
		JUMPN	P4,.+2	  ;SOME REALLY THERE
		POPJ	P,]	  ;NOT REALLY ANY THERE
	JUMPE	P4,CPOPJ	;REALLY NO ROOM
	LSH	P4,2		;CONVERT TO NUMBER OF CHARACTERS
	SUBI	P4,2		;TAKES TWO FOR COUNT AND PORT
	CAILE	P4,177		;COUNT MUST FIT IN BYTE SIZE-1
	 MOVEI	P4,177
	MOVEM	P4,MULCNT+0	;SAVE COUNT
	MOVEM	P4,MXMCNT	;AND ORIGINAL (SO KNOW HOW MANY SENT)
	MOVE	P4,ORPPDP
	MOVEI	T1,ORING(P4)
	HRLI	T1,(POINT 8,0,BYP2);SET TO PUT FIRST IN 3RD BYTE
	MOVEM	T1,CHRWRP+0	;SET BYTE POINTER
	JRST	CPOPJ1
COMMENT !
TO OUTPUT A CHARACTER INTO THE RING (OR TO A PTY), USE THE CODE:
	UUIDPB T3,CHRWRP(W)	;CHR. IN T3
	SOSLE MULCNT(W)		;SEE IF OUT OF ROOM
	SOSG CHCNT		;OR TIME TO STOP AND CHECK INPUT RING
	 HERE IF WE SHOULD STOP
	 HERE IF WE SHOULD NOT STOP
!

;OUTPUT A FULL WORD FOR SPECIAL TYPES

WRDOUT:	JUMPE	W, .+2		;IF IT'S A PTY,
	 STOPCD 		;  THERE SHOULD BE ONLY CHAR. OUTPUT
	MOVEM	P3,ORING(P4)	;PUT THE WORD IN THE OUTPUT BUFFER
	PUSHJ	P,ORPLOG	;Put message into ORING log
	SETOM	FSCN
	MOVNI	P3,4
	ADDM	P3,MULCNT+0	;UPDATE REAMAINING COUNTS
	ADDB	P3,MXMCNT	;IN CASE WE GO TO CHR OUTPUT
	JUMPL	P3,[AOJA P4,ADVPTR]	;WILL GET TO SETOUT, NONSKIP RETURN
	AOS	CHRWRP+0
	ADDI	P4,1		;JUST ADVANCE OUTPUT POINTER
	ANDI	P4,MSKORG
	MOVEM	P4,ORPPDP	;SET FOR 620 TO FIND
	JRST	CPOPJ1

;OUTPUT 2 WORDS FOR SPECIAL TYPES.

WRDOT2:	JUMPE	W,.+2		;IF IT'S A PTY,
	 STOPCD 		;  THERE SHOULD BE ONLY CHARACTER OUTPUT
	MOVEM	P3,ORING(P4)	;PUT 2ND WORD IN THE OUTPUT BUFFER.
;** No LOG HERE **;
;**;	PUSHJ	P,ORPLOG	;Put message into ORING log
	SETOM	FSCN		;FLAG THAT THERE'S SOMETHING TO DO.
	MOVNI	P3,8		;2 WDS (8 CHARS) TO OUTPUT.
	ADDM	P3,MULCNT+0	;UPDATE REMAINING COUNTS
	ADDB	P3,MXMCNT	;IN CASE WE GO TO CHR OUTPUT
	JUMPL	P3,[AOJA P4,ADVPTR]	;WILL GET TO SETOUT.
	AOS	CHRWRP+0	;INCREMENT CHAR BYTE POINTER.
	AOS	CHRWRP+0	;INCREMENT IT AGAIN (PAST 2 WORDS).
	ADDI	P4,1		;INCREMENT ORING OFFSET
	ANDI	P4,MSKORG
	MOVEM	P4,ORPPDP	;AND INFORM THE BASE.
	JRST	CPOPJ1		;SKIP RETURN.
SUBTTL NON-CHARACTER OUTPUT MESSAGE HANDLERS

;DON'T SEND ANY MESSAGES FROM THIS LINE

PGHSH:	 STOPCD			;HSH NOT USED ON PTYs
GOHSH:	LDB	T1,LOPZAP	;SEE IF ZAP SET
	SKIPN	T1
	 JRST	[AOS BADGUY	;COUNT BADGUYS THAT TRY TO SEND MESSAGES
		JRST WATLIN]	; FROM THIS PORT
	PUSHJ	P,CLRTTY	;DO FALSE ZAP STUFF
	JRST	FINLIN

;SEND TERMINAL CHARACTERISTIC(S)

GOSTC:	PUSHJ	P,CLSCHR
	  JRST	FULLIN		;NO ROOM
GOSTC1:	MOVE	T3,LDBTMT(U)	;T3/TRANSMIT BITS
	JFFO	T3,.+2		;T4/T.C # TO SEND THIS TIME
	JRST	MORLIN		;NONE OR NO MORE
	MOVSI	P3,TYPI TYPTCS	;MESSAGE TYPE
	DPB	T4,WRPCHR	;CHARACTERISTIC NUMBER
	LDB	T1,TABTMS(T4)
	DPB	T1,WRPCH2	;CHARACTERISTIC VALUE
	MOVSI	T1,(1B0)
	MOVNS	T4
	LSH	T1,(T4)
	ANDCAM	T1,LDBTMT(U)	;CLEAR THE TRANSMIT BIT
	LDB	T3,LDPLNO
	DPB	T3,WRPLIN	;SET PORT NUMBER IN OUTPUT WORD
	PUSHJ	P,WRDOUT	;SEND IT. IF THERE'S ROOM FOR MORE,
	  JRST	.+2
	JRST	GOSTC1		;  GO SEE IF THERE'S MORE TO SEND.
	SKIPE	LDBTMT(U)	;(NO ROOM) IF THERE WERE MORE TO DO,
	  JRST	FULLIN		;  SAY WE'RE NOT DONE
	JRST	FINLIN
SUBTTL	SEND A RED BALL

GOSRD:	MOVSI	P3,TYPI TYPRED
	JRST	FMTB

;SEND A CHARACTER GOBBLER

GOCGB:	MOVSI	P3,TYPI TYPGOB
	JRST	FMTB

;SEND A TERMINAL CHARACTERISTICS PROBE

GOSTP:	MOVSI	P3,TYPI TYPTCP	;PROBE
	MOVEI	T3,TMCALL	;FOR ALL
	DPB	T3,WRPCHR
	JRST	FMTB

;SET ECHO MODE

GOSEC:	MOVSI	P3,TYPI TYPECN	;ECHO ON
	MOVE	T1,LDBDCH(U)	;GET BOTH HALVES OF DCH
	TDNE	T1,[LDLNEC,,LDRDEM];DO WE WANT IT OFF INSTEAD?
	MOVSI 	P3,TYPI TYPECF	;(YES)
	JRST	FMTB

;SEND SOFT ZAP (HANG UP PHONE, KEEP CIRCUIT)

GOHNG:	MOVSI	P3,TYPI TYPHNG
	PFALL	FMTB

;FMTB -- CALLED WITH P3/ BYTE (8) TYPE, 0, XXX, XXX
;	 CLOSES CHARACTER MODE, RETURNING TO FULLIN IF NO ROOM,
;	 DEPOSITS PORT# INTO SECOND BYTE, TRANSMITS THE
;	 1-WORD MESSAGE, AND RETURNS TO THE OUTPUT DISPATCH
;FMTB1 -- ASSUMES CALLER HAS ALREADY DONE A CLSCHR

FMTB:	PUSHJ	P,CLSCHR	;LEAVE CHARACTER MODE. IF NO MORE ROOM,
	  JRST	FULLIN		;  RETURN TO OUTPUT DISPATCH
FMTB1:	LDB	T3,LDPLNO	;T3/ PORT #
	DPB	T3,WRPLIN	;DEPOSIT IT
	PUSHJ	P,WRDOUT	;SEND IT. ROOM FOR MORE?
	  JRST	FINLIN		;NO
	JRST	MORLIN		;YES
SUBTTL	SEND BELL

GOSBL:	MOVE	T2,LDBDCH(U)
	TLNN	U,LDLIMI	;IF IN IMAGE STATE,
	TRNE	T2,LDRNXO	;OR USER SAYS NO XOFF/XON,
	JRST	MORLIN		;  AVOID SENDING BELLS
	MOVEI	T3,7		;T3/ ASCII BELL
	PFALL	COMXON

;COMXON - CALLED WITH T3/ A CHARACTER AND THE PORT OPEN FOR
;	   CHARACTER OUTPUT. DEPOSIT THE CHARACTER IN THE BUFFER
;	   RING AND RETURN TO THE OUTPUT DISPATCH

COMXON:	UUIDPB	T3,CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	 JRST	FINLIN		;NO ROOM FOR MORE
	JRST	MORLIN		;ROOM FOR MORE

;BACKPRESSURE OFF

GOBPF:	MOVEI	T2,LDRXOS
	TDNE	T2,LDBDCH(U)	;IF WE SENT AN XOFF,
	  JRST	GOXON		;  GO SEND AN XON
	PUSHJ	P,CLSCHR
	  JRST	FULLIN		;NO ROOM FOR MESSAGE
	MOVEI	T2,LDRBPS
	ANDCAM	T2,LDBDCH(U)	;TURN OFF BACKPRESSURE-SENT FLAG
	MOVSI	P3,TYPI TYPOUP	;P3/ MESSAGE TYPE
	JRST	FMTB1

    ;HERE TO SEND AN XON

GOXON:	ANDCAM	T2,LDBDCH(U)	;CLEAR BACKPRESSURE-SENT FLAG
	MOVEI	T3,21		;T3/ ASCII XON
	JRST	COMXON		;GO SEND IT

;BACKPRESSURE ON

GOBPN:	LDB	T1,TRMBYP	;T1/ TERMINAL ID #
	JUMPE	T1,GOBPN1	;IF AUX CIRCUIT (0), BACKPRESSURE
	TLNN	U,LDLIMI	;OTHERWISE, IF NOT IMAGE STATE,
	  JRST	GOXOFF		;  SEND AN XOFF
GOBPN1:	PUSHJ	P,CLSCHR
	  JRST	FULLIN		;NO ROOM FOR MESSAGE
	MOVEI	T2,LDRBPS
	IORM	T2,LDBDCH(U)	;SET BACKPRESSURE-SENT FLAG
	MOVSI	P3,TYPI TYPNOP	;P3/ MESSAGE TYPE
	JRST	FMTB1

   ;HERE TO SEND AN XOFF

GOXOFF:	MOVEI	T1,LDRNXO
	MOVEI	T3,LDRXOS
	TDNN	T3,LDBDCH(U)	;IF WE'VE ALREADY SENT ONE XOFF
	TDNE	T1,LDBDCH(U)	;OR IF WE MUSTN'T SEND ANY,
	  JRST	MORLIN		;  JUST SAY WE'VE DONE IT
	IORM	T3,LDBDCH(U)	;SET XOFF-SENT FLAG
	MOVEI	T3,23		;T3/ ASCII XOFF
	JRST	COMXON		;GO SEND IT
SUBTTL	SEND CIRCUIT ZAPPER

GOZAP:	MOVSI	T1,L2LOWT
	TDNN	T1,LDBBYT(U)	;IF SOMEONE'S WAITING FOR ORANGE BALL
	SKIPE	LDBBIO(U)	;OR IF BLOCK I/O NEEDS CLEANING-UP,
	 JRST	WATLIN		;  WAIT
	PUSHJ	P,CLSCHR	;LEAVE CHAR MODE. SKIP IF ROOM.
	  JRST	FULLIN		;  MUST WAIT OR NO ROOM
	HRRZ	T1,U
	CAME	T1,OPRLDB	;Check if zapping OPR terminal
	 JRST	NOTOPR
	SETZM	OPRLDB
	SETZM	DEVOPR
	PUSHJ	P,OPRFRE	;No more OPR
	MOVEI	T1,STSHUT	;400000
	TDNE	T1,STATES	;IS SYSTEM SHUT?
	 JRST	NOTOPR		;YES
	MOVEI	T1,^D90
	MOVEM	T1,OPRTIM	;NO, SET TIMER FOR UNHAPPY MSG
NOTOPR:	TLNN	U,LDLAUX!LDLPTY	;THIS ONE WAS NOT COUNTED ANYWAY
	SKIPL	LDBLOG(U)
	 JRST	NOTLIN		;NOT REALLY IN
	MOVEI	T1,STSUPR	;200000
	SOSG	INTERM
	SKIPE	DWNFLG
	 SKIPA			;DO NOT RESET IF COMING DOWN
	ANDCAM T1,STATES	;CAN'T BE SUPER SHUT WITH EVERYONE GONE
NOTLIN:
	;Here to put ZAP message in the ORING

	SETZB	T1,LDBLOG(U)	;CLEAR LOGGED IN INFO
	DPB	T1,LDPHST	;Clear origination host
	SETZM	LDBMOD(U)	;RESET MODE TO LOGIN MODE
	PUSHJ	P,TSETBO	;Flush output buffer (free TTY chunks)
	PUSHJ	P,TSETBI	;ALSO CLEAR INPUT BUFFER
	MOVE	T1,LDBLIN(U)
	TLZE	T1,LNLZIN
	 AOS	NZAPOT		;AN IN-ZAP WAS RESPONDED TO
	MOVEM	T1,LDBLIN(U)
	SETZB	T1,LDBOUT(U)	;Cancel LOPCGB that was set by TSETBO
	DPB	T1,LDBOPB(U)	;NOTHING MORE TO DO ON OUTPUT
	MOVSI	P3,TYPI TYPZAP
	LDB	T2,LDPLNO
	DPB	T2,WRPLIN	;Port # in 2nd byte
	CAILE	T2,RPORTN##
	 STOPCD 		;CRASH- ZAPPING BEYOND HIGHEST REAL PORT
	PUSHJ	P,WRDOUT	;Store in ORING
	  JFCL			;Don't care if ORING is now full
	JRST	FINLIN		;NOBODY LEFT TO TALK TO

CLRTTY:	HRRZ	T1,U		;FALSE ZAP STUFF FOR REAL TTYs
	CAME	T1,OPRLDB
	 JRST	NTTOPR
	SETZM	OPRLDB		;OPR terminal has been zapped
	SETZM	DEVOPR
	PUSHJ	P,OPRFRE
	MOVEI	T1,STSHUT	;400000
	TDNE	T1,STATES	;IS SYSTEM SHUT?
	 JRST	NTTOPR		;YES
	MOVEI	T1,^D90
	MOVEM	T1,OPRTIM	;NO, SET TIMER FOR UNHAPPY MSG
NTTOPR:	TLNN	U,LDLAUX	;THIS ONE WAS NOT COUNTED ANYWAY
	SKIPL	LDBLOG(U)
	 JRST	CLRPTY		;NOT REALLY IN
	MOVEI	T1,STSUPR	;200000
	SOSG	INTERM
	SKIPE	DWNFLG
	 SKIPA			;DO NOT RESET IF COMING DOWN
	  ANDCAM T1,STATES	;CAN'T BE SUPER SHUT WITH EVERYONE GONE
CLRPTY:				;FALSE ZAP ENTRY FOR PTYs
	SETZB	T1,LDBLOG(U)	;CLEAR LOGGED IN INFO
	DPB	T1,LDPHST	;Clear origination host number
	SETZM	LDBMOD(U)	;RESET MODE TO LOGIN MODE
	PUSHJ	P,TSETBO
	PUSHJ	P,TSETBI	;ALSO CLEAR INPUT
	MOVE	T1,LDBLIN(U)
	TLZE	T1,LNLZIN
	 AOS	NZAPOT		;AN IN-ZAP WAS RESPONDED TO
	MOVEM	T1,LDBLIN(U)
	SETZB	T1,LDBOUT(U)	;CLEAR 'SEND SPECIAL MESSAGE' FLAGS
	DPB	T1,LDBOPB(U)	;NOTHING MORE TO DO ON OUTPUT
	POPJ	P,
SUBTTL	HERE ON A DETECTED ZAPPER ANOMALY TO STORE STUFF ABOUT THE PORT

ZBGBUG:	0	;ADDRESS OF THE COUNT INCREMENTED
ZBGPC:	0	;Where problem was detected
ZBGLIN:	0	;LDBLIN OF THE OFFENDING PORT
ZBGDCH:	0	;LDBDCH
ZBGDDB:	0	;LDBDDB
ZBGOUT:	0	;LDBOUT
ZBGBIT:	0	;OUTPUT BIT
ZBGBYT:	0	;LDBBYT
ZBGMOD:	0	;LDBMOD
ZBGDCX:	0	;LDBDCX
ZBGLOG:	0	;LDBLOG
	0
	0
	0
	0

ZAPBUG:	 STOPCD (.+1,INFO,ZAPBUG,,<Port not Zapped - *BUG*>)
ZAPBG0:	PUSH	P,T2
	HRRZI	T2,ZBGBUG-1	;(PDL POINTER)
	PUSH	T2,T1		;STORE THE COUNTER'S ADDRESS
	AOS	(T1)		;INCREMENT THE COUNTER
	PUSH	T2,-1(P)	;RETURN PC
	PUSH	T2,LDBLIN(U)
	PUSH	T2,LDBDCH(U)
	PUSH	T2,LDBDDB(U)
	PUSH	T2,LDBOUT(U)
	LDB	T1,LDBOPB(U)
	PUSH	T2,T1
	PUSH	T2,LDBBYT(U)
	PUSH	T2,LDBMOD(U)
	PUSH	T2,LDBLOG(U)
ZAPBG1:	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	POP	P,T2
	POPJ	P,
SUBTTL BLOCK I/O MESSAGE ROUTINES

;BLOCK INPUT

GOBIN:	PUSHJ	P, GOBIO1	;INITIAL SETUP
	  JRST	FULLIN		;NO ROOM
	HRRZ	T3, LDBBIO(U)	;T3/ INPUT BUFFER ADDR
IFCPU (KL),<
	MOVE	T1, BIOCSH(T3)	;T1/ SWEEP NUMBER
	CAME	T1, CSUCNT##	;UNLOAD ALREADY DONE?
	JRST	[
		AOS CSHSAV##	;PAT OURSELVES ON THE BACK
		JRST GOBIN1
	]
	CSHUNL			;UNLOAD THE CACHE
	CAMN	T1, CSUCNT##
	 JRST	.-1		;WAIT 'TIL IT'S DONE
GOBIN1:>;END IFCPU (KL)
IFCPU (KS),<CSHIVL>		;INVALIDATE 2020 CACHE
	MOVSI	P3, TYPI TYPBIN	;P3/ MESSAGE TYPE
	PUSHJ	P, GOBIO2	;OUTPUT THE MESSAGE
	  JRST	FINLIN		;(NO ROOM FOR MORE)
	JRST	MORLIN		;(ROOM FOR MORE)

;BLOCK OUTPUT

GOBOP:	 STOPCD		;(PTYS ONLY)
GOBOT:	PUSHJ	P, GOBIO1	;INITIAL SETUP
	  JRST	FULLIN		;NO ROOM
;"/Patch to check for prior circuit zap on BIO port before output/
	HLRZ	T3, LDBBIO(U)	;T3/ OUTPUT BUFFER ADDR
	JUMPN	T3,GOBOT3	;Must be nonzero
	MOVSI	T3,LNLZIN	;Has a zapper been seen in the IRING?
	TDNN	T3,LDBLIN(U)	; ...
	 STOPCD (.+1,INFO,BIOZAD,,<Block I/O with Zero Address>);GOBOT+3
	JRST	FINLIN		;Say "no room", so zapper can be processed
GOBOT3:
IFCPU (KL),<
	MOVE	T1, BIOCSH(T3)	;T1/ SWEEP NUMBER
	CAME	T1, CSVCNT##	;IF A SWEEP'S ALREADY BEEN DONE,
	 JRST	[
		AOS CSHSAV##	;PAT OURSELVES ON THE BACK
		JRST GOBOT1
	]
	CSHVAL			;START VALIDATE
	CAMN	T1, CSVCNT##
	JRST	.-1		;AND WAIT 'TIL IT'S DONE
GOBOT1:>;END IFCPU (KL)
	MOVSI	T1, LDLNOP
	IORM	T1, LDBDCH(U)	;PREVENT FUTURE OUTPUT UNTIL
				;BLOCK OUTPUT IS COMPLETE
	MOVSI	P3, TYPI TYPBKO	;P3/ MESSAGE TYPE
	PUSHJ	P, GOBIO2	;OUTPUT THE MESSAGE
	  JRST	FINLIN		;(NO ROOM FOR MORE)
	JRST	FINLIN		;(ROOM FOR MORE BUT CLAIM THERE ISN'T)
SUBTTL	GOBIO1 - CLOSE CHARACTER OUTPUT, THEN SKIP IF THERE ARE
;	   AT LEAST 2 FREE WORDS IN THE OUTPUT RING

GOBIO1:	PUSHJ	P,CLSCHR	;CLOSE CHARACTER MODE
	  POPJ	P,		;NO ROOM
	MOVE	T1,ORPPDP
	ADDI	T1,2
	ANDI	T1,MSKORG	;T1/ (PDP PTR + 2) MOD RING SIZE
	CAME	T1,ORP620
	AOS	(P)		;ENOUGH ROOM
	POPJ	P,

;GOBIO2 - CALLED WITH T3/ BUFFER ADDR
;		       P3/ BYTE (8) TYPE, 0, 0, 0
;	   DEPOSIT THE PORT# AND BUFFER ADDRESS APPROPRIATELY,
;	   OUTPUT THE BLOCK INPUT/OUTPUT MESSAGE,
;	   SKIP-RETURN IF THERE'S ROOM FOR MORE

GOBIO2:	LDB	T1,LDPLNO	;T1/ PORT#
	DPB	T1,WRPLIN	;DEPOSIT IT
	HRRZ	T1,BIOCHR(T3)	;T1/ CHARACTER COUNT
	DPB	T1,[POINT ^D16, P3, BYP4]
	MOVEM	P3,ORING(P4)
	PUSHJ	P,ORPLOG	;Put message into ORING log
	ADDI	P4,1
	ANDI	P4,MSKORG
	SETZ	P3,
IFKMC<
	EXTERNAL UBANXT,UBAEND	;OUR UBA SPACE IS BETWEEN THESE TWO
	UBABIO==<763000!<<UBANXT+1>&776>>;START UBA's BLOCK I/O PAGING RAM
	MOVEI	T1,(T3)		;T1/ BUFFER ADDRESS
	PUSHJ	P,SCANBB	;FIND UBA PAGE MATCHING T1
		 STOPCD		;THERE HAS TO BE ONE AT THIS POINT
	ADDI	T2,UBABIO&77	;UBAPAG# + Low 6 BITS OF UBA ADDRESS
	DPB	T2,[POINT 11,T1,26]	;PAGE # OVERLAYS HIGH 11 BITS
	ADDI	T1,BIODAT		;Offset to first Char address
	DPB	T1,[POINT 8,P3,BYP3]	;LOW 8 BITS TO 3RD BYTE POS.
	LSH	T1,-8			;SHIFT TO HIGH 10 BITS
	DPB	T1,[POINT 10,P3,BYP2]	;THE REST IN BYTES 1 & 2
	>;END IFKMC
IFNKMC<
	MOVEI	T1,BIODAT(T3)	;T1/ FIRST-CHARACTER ADDR
IFNCPU (KI),<
	MAP	T1,(T1)	;GET PHYSICAL ADDRESS
	DPB	T1,[POINT 18,P3,23] ;PUT IT IN
>;END IFNCPU (KI)
>;END IFNKMC
IFCPU (KI),<
	DPB	T1,[POINT 9,P3,23] ;PUT IN LOW 9 BITS, MAP SMASHES THEM
	MAP	T1,(T1)		;GET PAGE NUMBER
	DPB	T1,[POINT 9,P3,14] ;PUT IN HIGH 9 BITS.
>;END IFCPU (KI)
	PJRST	WRDOT2

;TERMINATE BLOCK OUTPUT

GOTRO:	PUSHJ	P,CLSCHR	;LEAVE CHARACTER MODE. IF NO ROOM,
	JRST	FULLIN		;  RETURN TO OUTPUT DISPATCH
	MOVSI	T1,LDLNOP
	IORM	T1,LDBDCH(U)	;SET BACKPRESSURE
	MOVSI	P3,TYPI TYPORQ	;SEND OUTPUT TERMINATION REQUEST
	JRST	FMTB1

;TERMINATE BLOCK INPUT

GOTRI:	MOVSI	P3,TYPI TYPIRQ	;SET UP BLOCK TERMINATION REQ
	JRST	FMTB
SUBTTL RUBOUT STRING/OUTPUT CHARACTER HANDLERS

;SEND RUBOUT CHARACTERS

PGRUB:
GORUB:	SKIPN	LDBRBC(U)
	 JRST	MORLIN		;NO RUBOUT CHARACTERS
	TDZA	P1,P1		;P1 := -1 IF PRCOUT RUNS OUT OF ROOM
	 JRST	FULLIN		;OUT OF ROOM
CNTRUB:	MOVE	T2,LDBRBO(U)
	PUSHJ	P,TTGETC	;GET A CHAR. IF DONE WITH THE CHUNK,
	  PUSHJ	P,FRECHK	;  FREE IT
	MOVEM	T2,LDBRBO(U)
	PUSHJ	P,PRCOUT	;PRINT THE CHARACTER
	  JRST	[		;NO ROOM
		ADDM	T3,LDBRBO(U)
		JRST	FULLIN
	  ]
	SOSLE	LDBRBC(U)	;IF THERE'RE MORE CHARACTERS,
	 JRST	CNTRUB(P1)	;  KEEP GOING IF THERE'S ROOM

    ;HERE WHEN THERE'RE NO MORE RUBOUT CHARACTERS

	SETZM	LDBRBI(U)
	SKIPE	T2,LDBRBO(U)	;Pointer to last chunk used in rubout string
	 PUSHJ	P,FREUP
	SETZM	LDBRBO(U)	;CLEAN UP THE BUFFERLETS
	JUMPL	P1,FINLIN	;NO ROOM
	JRST	MORLIN		;MORE ROOM
SUBTTL	SEND OUTPUT CHARACTERS

PGOUT:
GOOUT:	SKIPN	LDBTOC(U)
	 JRST	MORLIN
	TDZA	P1,P1		;P1 := -1 IF PRCOUT RUNS OUT OF ROOM
	 JRST	CLNOC
CNTOUT:	MOVE	T2,LDBTOT(U)
	PUSHJ	P,TTGETC	;GET A CHAR. IF DONE WITH BUFFERLET,
	  PUSHJ	P,FRECHK	;  FREE IT
	MOVEM	T2,LDBTOT(U)
	PUSHJ	P,PRCOUT	;PRINT THE CHARACTER
	 JRST	[		;OUT OF ROOM
		ADDM T3,LDBTOT(U)
		JRST CLNOCP
	 ]
	SOSLE	T2,LDBTOC(U)	;IF THERE'RE MORE CHARACTERS,
	 JRST	CNTOUT(P1)	;  CONTINUE IF THERE'S ROOM

    ;HERE WHEN THERE'RE NO MORE OUTPUT CHARACTERS

	PUSHJ	P,XMTWAK	;WAKE THE JOB UP
	HRRZ	T2,U
	CAMN	T2,OPRLDB	;IS THIS OPR?
	 PUSHJ	P,OPRFRE	;RESTART WAITERS FOR SETUUO
	JUMPL	P1,FINLIN	;NO MORE ROOM
	JRST	MORLIN		;MORE ROOM

    ;HERE WHEN CHARACTER OUTPUT RUNS OUT OF ROOM TO DECIDE
    ;WHETHER TO WAKE THE JOB UP NOW

CLNOCP:	MOVE	T2,LDBTOC(U)
CLNOC:	SKIPGE	LDBDCX(U)	;IF IT'S A FAST LINE,
	CAML	T2,OWK120	;AND UNDER THE FAST MINIMUM,
	CAMGE	T2,OWK30	;OR IF IT'S UNDER THE SLOW MINIMUM,
	 PUSHJ	P,XMTWAK	;  WAKE THE JOB UP
	JRST	FULLIN
SUBTTL ECHO LOGIC

;YELLOW BALL

GOSYL:	PUSHJ	P,CLSCHR	;LEAVE CHARACTER MODE
	  JRST	FULLIN		;NO ROOM
	MOVSI	T1,L2LOWT
	IORM	T1,LDBBYT(U)	;SAY WE'RE WAITING
	MOVSI	T1,L2LOWS
	ANDCAM	T1,LDBBYT(U)	;AND THAT WE HAVEN'T SEEN ONE
	MOVSI	P3,TYPI TYPYEL
	JRST	FMTB1

;GREEN (GOSGR) AND ORANGE (GOSOG) BALLS

GOSGR:	MOVSI	P3,TYPI TYPGRN
	SKIPA
GOSOG:	MOVSI	P3,TYPI TYPORG
	MOVSI	T2,L2LDEL
	TDNN	T2,LDBBYT(U)	;IF WE'RE IN \...
	 PUSHJ	P,WTCHK		;OR IF WE'RE NOT IN INPUT WAIT,
	  JRST	WATLIN		;  WAIT
	JRST	FMTB		;GO SEND IT

;WTCHK - SKIP IF TTY IN INPUT WAIT

WTCHK:	TLNE	U,LDLCOM
	 JRST	CMDCKW##	;SPECIAL CHECK IF AT COMMAND LEVEL
;	HRRZ	T1,LDBBIO(U)
;	JUMPN	T1,CPOPJ
	MOVSI	F,L2LLDF
	TDNE	F,LDBBYT(U)	;IF LEAVE DEF ECHO BIT ON
	 JRST	CPOPJ1		;ALWAYS GET OUT
	HRRZ	F,LDBDDB(U)
	JUMPE	F,CPOPJ1	;NO JOB, TAKE A CHANCE
	MOVE	S,DEVIOS(F)
	TRNE	S,IOACT
	TLNE	S,TTYOUW
	 POPJ	P,		;NOT IN WAIT OR IN OUTPUT WAIT
	JRST	CPOPJ1
SUBTTL	ECHO CHARACTER OUTPUT

PGECO:
GOECO:	SKIPN	LDBECC(U)
	 JRST	MORLIN		;NO CHARACTERS
	PUSHJ	P,WTCHK		;IF WE AREN'T IN INPUT WAIT,
	  JRST	[JUMPL	U,GOLIN3	;Don't wake if backpressured
		 JRST WATLIN]		;  WAIT UNTIL WE ARE
	TDZA	P1,P1		;THIS USED THE SAME TRICK AS OUTPUT
	 JRST	FULLIN		;WILL GET HERE WHEN OUT OF ROOM
CNTECO:	MOVE	T2,LDBECT(U)
	PUSHJ	P,TTGETC
	 JFCL			;DON'T CARE ABOUT BOUNDARIES
	MOVEM	T2,LDBECT(U)
	TRNE	T3,400
	 JRST	[MOVEI T1,5	;SET MODE 5 FOR IMAGE CHR
		JRST ECHRPT]
	TRNE	T3,200
	 SKIPA	P3,CHRTAB-200(T3)
	MOVE	P3,CHRTAB(T3)
	LDB	T1,CHPECH	;GET ECHO TYPE
ECHRPT:	LDB	T2,LDPMEC	;AND LINE MODE
	XCT	ECHTAB(T1)	;USUALLY LOADS T1 WITH ADDRESS
	JRST	(T1)		;GO THERE

;HERE WHEN THERE'S NOT ENOUGH OUTPUT RING SPACE: BACK UP
;THE ECHO POINTER AND REPORT NON-COMPLETION TO THE DISPATCHER

ECHBAK:	ADDM	T3,LDBECT(U)	;BACK UP POINTER
	JRST	FULLIN

;HERE TO SEE IF THERE ARE MORE CHARACTERS TO BE ECHOED

ECHLST:	SOSLE	LDBECC(U)	;IF THERE ARE MORE TO ECHO,
	 JRST	CNTECO(P1)	;  CONTINUE
	JUMPL	P1,FINLIN	;OTHERWISE, IF THERE'S OUTPUT RING SPACE,
	PUSHJ	P,BPXOFF	;  CLEAR BACKPRESSURE (WHY NOW?)
	JRST	MORLIN		;  AND RETURN TO OUTPUT DISPATCH
SUBTTL	ECHO DISPATCH TABLES

ECHTAB:	JRST ECHSPA		; 0 - SPECIAL ACTION
	HLRZ T1,ECHT12(T2)	; 1 - NONBREAK: PRINT & COUNT
	HRRZ T1,ECHT12(T2)	; 2 - BREAK: NO PRINT, NO COUNT
	HLRZ T1,ECHT34(T2)	; 3 - BREAK: PRINT, NO COUNT
	HRRZ T1,ECHT34(T2)	; 4 - BREAK2: PRINT & COUNT
	HLRZ T1,ECHT56(T2)	; 5 - IMAGE MODE CHARACTER
	HRRZ T1,ECHT56(T2)	; 6 - BREAK: PRINT & COUNT
	HRRZ T1,ECHT7(T2)	; 7 - BREAK2: NO PRINT, NO COUNT

ECHT12:	EACT1,,EACT2	; 0 - COMMAND MODE
	EACT6,,EACT12	; 1 - BREAK-ON-ALL
	EACT10,,EACT12	; 2 - BREAK NORMALLY
	EACT10,,EACT12	; 3 - BREAK-ON-PUNCTUATION

ECHT34:	EACT3,,EACT4
	EACT13,,EACT14
	EACT13,,EACT15
	EACT13,,EACT14

ECHT56:	EACT5,,EACT16
	EACT7,,EACT17
	EACT11,,EACT17
	EACT11,,EACT17

ECHT7:	EAC4A
	EAC14A
	EAC15A
	EAC14A
SUBTTL	COMMAND MODE

;NONBREAK: PRINT & COUNT

EACT1:	PUSHJ P,EPCOUT	;DO THE NORMAL OUTPUT THING
	 JRST ECHBAK	;MUST BACK UP
EACT1B:	AOS T4,LDBTIC(U)
	CAIGE T4,TIWKC	;ENOUGH TO WAKE UP
	 JRST ECHLST	;NO, CHECK MORE CHRS
EACT1A:	PUSHJ P,CMDWAK	;WAKE COMMAND
	SOS LDBECC(U)	;DECREASE COUNT
	JRST WATLIN	;NO MORE ECHO UNTIL WE'RE IN WAIT AGAIN

;BREAK: PRINT & COUNT

EACT16:	PUSHJ P,EPCOUT
	 JRST ECHBAK

;BREAK: NO PRINT, NO COUNT

EACT2:	HRROI T1,1	;-1 FOR LEFT HALF 1 FOR RIGHT HALF
	ADDM T1,LDBBKC(U)
	AOS LDBTIC(U)
	JRST EACT1A	;GO WAKE UP

;BREAK: PRINT, NO COUNT

EACT3:	PUSHJ	P,E1IDPB	;OUTPUT IF NOT BACKPRESSURED
	JRST EACT2

;(EACT4)  BREAK2: PRINT & COUNT
;(EACT4A) BREAK2: NO PRINT, NO COUNT

EACT4:	PUSHJ P,EPCOUT
	 JRST ECHBAK
EAC4A:	HRROI T1,1
	ADDM T1,LDBBK2(U)
	JRST EACT1B

;IMAGE

EACT5:	PUSHJ	P,E2IDPB	;OUTPUT IF NOT BACKPRESSURED
	MOVNI P1,1	;OUT OF ROOM
	JRST EACT1B
SUBTTL	NONBREAK: PRINT & COUNT; NORMAL OR BREAK2 MODE

EACT10:	TLNE U,LDLNEC		;WORRY ABOUT ECHO
	 JRST EAC10A		;NO ECHO
	PUSHJ P,EPCOUT
	  JRST ECHBAK
EAC10A:	AOS T4,LDBTIC(U)
	CAIG T4,TIWKC
	 JRST ECHLST	;DO NOT WAKE UP
EAC10B:	PUSHJ P,USRWAK
	SOS LDBECC(U)
	JRST WATLIN	;NO MORE ECHO UNTIL WE'RE IN WAIT AGAIN

;NONBREAK: PRINT & COUNT; BREAK-ON-ALL MODE

EACT6:	TLNE U,LDLNEC
	JRST EACT6A
	PUSHJ P,EPCOUT
	 JRST ECHBAK
EACT6A:	AOS LDBTIC(U)
	JRST EAC10B

;IMAGE; NORMAL OR BREAK2 MODE

EACT11:	TLNE U,LDLNEC
	JRST EAC11A
	PUSHJ	P,E2IDPB	;OUTPUT IF NOT BACKPRESSURED
	MOVNI P1,1
EAC11A:	LDB T1,LDPIMB
	CAME T1,T3
	JRST EAC10A	;WAK IF COUNT BIG ENOUGH
	JRST EACT6A	;SPECIAL BREAK, WAKE

;IMAGE; BREAK-ON-ALL MODE

EACT7:	TLNE U,LDLNEC
	JRST EACT6A
	PUSHJ	P,E1IDPB	;OUTPUT IF NOT BACKPRESSURED
	JRST EACT6A
SUBTTL	BREAK: PRINT & COUNT; NOT COMMAND MODE

EACT17:	TLNE U,LDLNEC
	JRST EACT12	;DO NOT ECHO
	PUSHJ P,EPCOUT
	 JRST ECHBAK

;BREAK: NO PRINT, NO COUNT; NOT COMMAND MODE

EACT12:	HRROI T1,1
	ADDM T1,LDBBKC(U)
	JRST EACT6A

;BREAK: PRINT, NO COUNT; NOT COMMAND MODE

EACT13:	TLNE U,LDLNEC
	JRST EACT12
	PUSHJ	P,E1IDPB	;OUTPUT IF NOT BACKPRESSURED
	JRST EACT12

;(EACT14)  BREAK2: PRINT & COUNT; BREAK-ON-ALL OR BREAK2 MODE
;(EACT14A) BREAK2: NO PRINT, NO COUNT; BREAK-ON-ALL OR BREAK2 MODE

EACT14:	TLNE U,LDLNEC
	JRST EAC14A
	PUSHJ P,EPCOUT
	 JRST ECHBAK
EAC14A:	HRROI T1,1
	ADDM T1,LDBBK2(U)
	JRST EACT6A

;(EACT15)  BREAK2: PRINT & COUNT; NORMAL MODE
;(EACT15A) BREAK2: NO PRINT, NO COUNT; NORMAL MODE

EACT15:	TLNE U,LDLNEC
	JRST EAC15A
	PUSHJ P,EPCOUT
	JRST ECHBAK
EAC15A:	HRROI T1,1
	ADDM T1,LDBBK2(U)
	JRST EAC10A
SUBTTL	SPECIAL ACTION

ECHSPA:	LDB T1,LDPMOD
	LDB T2,CHPSPE
	XCT @ECHSPT(T1)

ECHSPT:	XCT SPEPDP(T2)
	XCT SPE940(T2)
	XCT SPE940(T2)
	XCT SPEPDP(T2)

SPEPDP:	JRST SPEUXC	;ECHO ^X RETURN (^C)
	JRST SPECR	;RETURN
	JRST SPEUX	;ECHO ^X (^U)
	JRST SPETAB	;TAB
	JRST SPEALT	;33
	JRST SPEVM	;V. TAB
	JRST SPEVM	;FF
	JRST SPEUXC	;ECHO ^X RETURN (^Z)
	JRST SPEALP	;175-176
	JRST SPEBS	;BACKSPACE

SPE940:	JRST SPEBRK	;TYPE 2
	JRST SPECR	;RETURN
	JRST SPEBRK
	JRST SPETAB	;TAB
	JRST SPEBRK	;33
	JRST SPEVM	;V. TAB
	JRST SPEVM	;FF
	JRST SPEBRK	;TYPE 2
	JRST SPEAP1	;175-176
	JRST SPEBS	;BACKSPACE
SUBTTL	TREAT AS NONBREAK: PRINT & COUNT

SPECR:	MOVEI T1,1
	JRST ECHRPT	;JUST TURN INTO TYPE 1

;TREAT AS BREAK: NO PRINT, NO COUNT

SPEBRK:	MOVEI T1,2
	JRST ECHRPT	;TYPE 2

;TREAT AS BREAK: PRINT, NO COUNT

SPEBK3:	MOVEI T1,3
	JRST ECHRPT	;TYPE 3

;TREAT AS BREAK: PRINT & COUNT

SPEBK6:	MOVEI T1,6
	JRST ECHRPT	;TYPE 6

;RIGHT BRACE OR TILDE IN 940 MODE

SPEAP1:	TLNN U,LDLLCT	;175-176
	JRST SPEBK6	;TTY LC, BREAK: PRINT & COUNT
	JRST SPEBRK	;TTY NO LC, BREAK: NO PRINT, NO COUNT

;RIGHT BRACE OR TILDE IN PDP10 MODE

SPEALP:	TLNN U,LDLLCT
	 JRST SPEBK6	;TTY LC, BREAK: PRINT & COUNT
	PFALL SPEALT	;TTY NO LC, EQUIVALENT TO ESC

;ESCAPE IN PDP10 MODE

SPEALT:	MOVSI T3,LXLDLR
	TDNE T3,LDBDCX(U) ;IF USER SUPPRESSING $ ECHO
	TLNE U,LDLCOM	;OR WE'RE AT COMMAND LEVEL
	SKIPA		;ECHO A $
	JRST SPEBRK
	MOVEI T3,"$"
	JRST SPEBK6	;YES, SAY IT WAS A $
SUBTTL	HORIZONTAL TAB

SPETAB:	MOVE	T1, LDBBYT(U)
	TLNE	T1, L2LNTB	; NO ECHO?
	JRST	SPETB1
	TLNE	T1, L2LTBK	; BREAK ?
	JRST	SPEBK6		; BREAK & ECHO
	MOVEI	T1, 4
	JRST	ECHRPT		; BREAK2 & ECHO

SPETB1:	TLNE	T1, L2LTBK	; BREAK ?
	JRST	SPEBRK		; BREAK & NO ECHO
	MOVEI	T1, 7
	JRST	ECHRPT		; BREAK2 & NO ECHO

;VERTICAL TAB OR FORMFEED

SPEVM:	MOVSI	T1, L2LNTB
	TDNN	T1, LDBBYT(U)	; ECHO?
	JRST	SPEBK6		; YES
	JRST	SPEBRK		; NO

;BACKSPACE

SPEBS:	MOVE	T1,LDBBYT(U)
	LDB	T2,LDPECH	;REMOTE BS ECHO SET
	JUMPE	T2,SPEBS1	;NO, DON'T ECHO
	TLNN	T1,L2LBBP	;BREAK
	JRST	SPEBK6		;BREAK & ECHO
	MOVEI	T1,4
	JRST	ECHRPT		;BREAK2 & ECHO

SPEBS1:	TLNN	T1,L2LBBP	;BREAK
	JRST	SPEBRK		;BREAK & NO ECHO
	MOVEI	T1,7
	JRST	ECHRPT		;BREAK2 & NO ECHO
SUBTTL	ECHO <CONTROL CHAR> AS ^<CONTROL CHAR + 100>

SPEUX:	TLNN U,LDLCOM
	TLNN U,LDLNEC	;ALWAYS DO IT IN COMMAND MODE
	SKIPA
	JRST SPEBRK	;OTHERWISE NOT IF NO ECHO
	PUSHJ P,SPEUCM	;COMMON ^X ECHO CODE
	 JRST ECHBAK
	JRST SPEBRK

;ECHO <CONTROL CHAR> AS ^<CONTROL CHAR + 100><CR><LF>

SPEUXC:	TLNN U,LDLCOM	;SAME AS SPEUX BUT ADD RETURN
	TLNN U,LDLNEC
	SKIPA
	JRST SPEBRK
	PUSHJ P,SPEUCM	;ECHO THE ^X
	 JRST ECHBAK	;DID NOT MAKE IT
	MOVE T4,CRPTR	;GET READY FOR THE RETURN LF
	JUMPL P1,SPEUX1	;OUT OF ROOM, MUST USE RUBOUT STRING
	MOVEI T3,0
	DPB T3,LDPPOS	;RESET POSITION
	PUSHJ P,SPOFIL
	 JRST SPEBRK	;HAVE PUT OUT THE CRLF (OR TO FILLER)
	JRST SPEBRK	;SAME

SPEUX1:	PUSHJ P,RUBSTR
	JRST SPEBRK

;COMMON CODE FOR SPEUX AND SPEUXC

SPEUCM:	JUMPL	U,EPCOU1	;CAN'T OUTPUT NOW
	LDB T4,LDPPOS
	ADDI T4,2	;MAKE SURE BOTH FIT ON SAME LINE
	MOVEI T3,"^"	;THE ^
	PUSHJ P,PRCCR	;THIS WILL PUT IN A CRLF IF NEEDED
	 POPJ P,	;^ NOT SENT, OUT OF ROOM, BACK UP
	CAIN T4,1	;^ SEND, T4 IS LDPPOS, IF 1 CRLF SENT
	AOJA T4,[DPB T4,LDPPOS	;MUST SET TO 2
		JRST .+1]
	LDB T3,LDBECT(U)	;GET BACK CHARACTER
	TRO T3,100
	JUMPL P1,SPEUC1	;ALREADY OUT OF ROOM, INTO RUBOUT STRING
	PUSHJ	P,E2IDPB	;OUTPUT IF NOT BACKPRESSURED
	MOVNI P1,1
	JRST CPOPJ1	;FINISHED

SPEUC1:	PUSHJ P,ENTRUB
	MOVEI T1,1
	DPB T1,LOPRUB	;SET TO SEND RUBOUT STRING
	JRST CPOPJ1	;P1 IS NEG SO WILL FINISH
SUBTTL	DON'T ECHO IF PORT BACKPRESSURED

EPCOUT:	JUMPGE	U,PRCOUT	;DO OUTPUT IF NOT BACKPRESSURED
EPCOU1:	POP	P,T1		;FLUSH RETURN ADDR
	SETZ	T1,
	DPB	T1,LDBOPB(U)	;TURN OFF NEED OUTPUT
	MOVSI	T3,110000
	ADDM	T3,LDBECT(U)	;BACK UP BYTE POINTER
	JRST	FULLIN		;GO ON TO NEXT LINE

E1IDPB:	JUMPL	U,EPCOU1	;CAN'T ECHO NOW
	UUIDPB	T3,CHRWRP(W)
	SOSLE	MULCNT(W)
	SOS	CHCNT
	POPJ	P,

E2IDPB:	JUMPL	U,EPCOU1	;CAN'T ECHO NOW
	UUIDPB	T3,CHRWRP(W)
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	POPJ	P,
	JRST	CPOPJ1
SUBTTL OUTPUT FILLER LOGIC

;SEND FILLER CHARACTERS

PGFIL:
GOFIL:	ILDB	T3, LDBFLP(U)	;T3/ NEXT CHAR, OR 0 IF LDBFLP=0
	JUMPE	T3, [		;IF NO (MORE) CHARACTERS,
		SETZM	LDBFLP(U)	;CLEAR THE POINTER
		JRST	MORLIN
	]
	TRZ	T3, 200		;WHAT IS THIS FOR???
	UUIDPB	T3, CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	JRST	FULLIN		;NO MORE ROOM
	JRST	GOFIL		;BACK FOR MORE
SUBTTL	PRCOUT - CALLED WITH T3/ THE CHARACTER TO PRINT,
;	   PRINTS THE CHARACTER (MAPPING UPPER CASE TO LOWER
;	   CASE IF SO ENABLED), INSERTS FREE CRLFS AND
;	   HT/VT/FF PADDING/SIMULATION CHARACTERS IF NECESSARY.
;	   IF IT CAN'T PRINT THE CHARACTER, IT NONSKIP-RETURNS
;	   WITH T3/ 110000,,0 (WITH WHICH THE CALLER CAN BACK UP
;	   A BYTE POINTER). OTHERWISE, IT SKIP-RETURNS. IT MAY
;	   SET THE NEED-FILLER BIT, AND IT WILL SET P1 = -1 IF
;	   THERE'S NO CHARACTER SPACE LEFT.

PRCOUT:	TRNN	T3, 400		;IF IT'S AN IMAGE CHARACTER
	TLNE	U, LDLSOX	;OR SUPPRESSING OUTPUT TRANSLATION,
	JRST	PRCOT3		;  JUST SEND IT
	TRNE	T3, 200
	SKIPA	P3, CHRTAB-200(T3)
	MOVE	P3, CHRTAB(T3)	;P3/ CHARACTER-TYPE BITS
	LDB	T1, CHPOUT	;T1/ CHARACTER PRINT MODE
	XCT	[
		JRST PROACT	;0 SPECIAL ACTION
		LDB T4, LDPPOS	;1 PRINT AND COUNT 1 CHARACTER-WIDTH
		JRST PRCOT3	;2 PRINT BUT DON'T COUNT
		JRST PROUCC	;3 UPPER CASE ACTION
	](T1)

    ;HERE ON 1-CHARACTER-WIDE CHARACTERS

PRCOCW:	AOJ	T4,		;T4/ POSITION ON LINE

    ;HERE WITH T4/ POSITION, FROM ABOVE AND FROM ECHO CODE,
    ;TO PRINT A FREE CR IF ONE IS NEEDED, THEN THE CHAR IN T3

PRCCR:	LDB	T1,LDPWID	;T1/ LINE WIDTH
	CAMLE	T4,T1		;IF THE LINE ISN'T FULL
	TLNE	U,LDLNFC!LDLSOX	;OR THE USER DOESN'T WANT FREE CRLFS
	 JRST	PRCOT1		;  JUST PRINT THE CHARACTER
    ;HERE TO PRINT A CRLF

	MOVE	T4, CRPTR
PRCFIL:	ILDB	T2, T4		;T2/ NEXT CHARACTER
	JUMPE	T2, [		;IF WE'RE DONE,
		MOVEI	T4, 1		;LINE POSITION WILL BE 1
		JRST	PRCOT2		;GO PRINT THE CHARACTER
	]
	UUIDPB	T2, CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	JRST	.+2		;(NO MORE ROOM)
	JRST	PRCFIL		;BACK FOR MORE
	MOVE	T3, T4
	ILDB	T3, T3		;T3/ THE NEXT CHAR
	JUMPE	T3, PRCFL1	;IF IT WASN'T THE TERMINATING NUL,
	MOVEM	T4, LDBFLP(U)	;  SET THE REST AS FILLER
	MOVEI	T4, 1
	DPB	T4, LOPFIL	;  SET THE NEED-FILLER BIT
PRCFL1:	MOVSI	T3, 110000	;(MAGIC SO CALLER CAN BACKUP BYTE PTR)
	DPB	T3, LDPPOS	;LINE POSITION := 0
	POPJ	P,

PRCOT1:	CAIG	T4, 377
PRCOT2:	DPB	T4, LDPPOS
PRCOT3:	UUIDPB	T3, CHRWRP(W)
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	SETO	P1,
	JRST	CPOPJ1
SUBTTL	HERE ON SPECIAL-ACTION CHARACTERS

PROACT:	LDB T2,CHPSPO
	XCT SPOTBL(T2)	;DO CORRECT OUTPUT THING FOR CHR

SPOTBL:	JRST SPOCR	;RETURN
	JRST SPOTAB	;TAB
	JRST SPOVT	;VERTICAL TAB
	JRST SPOFF	;FORM FEED
	JRST SPOBS2	;BACKSPACE

;CARRIAGE RETURN

SPOCR:	MOVEI T4,0
	JRST PRCOT2	;OUTPUT BUT SET POS TO 0

;HORIZONTAL TAB

SPOTAB:	LDB T1,LDPPOS	;GET CURRENT POSITION
	TRO T1,7
	ADDI T1,1	;WHERE IT WILL BE
	LDB T4,LDPWID
	TLNN U,LDLNFC
	CAMGE T1,T4	;WILL WE OVERFLOW?
	 JRST SPOTB0	;NO OR NO CR WANTED
	MOVEI T1,0
	DPB T1,LDPPOS	;SET TO 0 POSITION
	MOVE T4,CRPTR
	JRST SPOFIL

SPOTB0:	LDB T4,LDPPOS	;NO CR, GET CURRENT POSITION
	TRNN T1,400
	DPB T1,LDPPOS	;SAVE NEW
	TLNE U,LDLTAB
	JRST SPOTB1	;TTY DOES TABS, JUST FILL
	ANDI T4,7
	MOVE T4,TABPTR(T4)	;GET CORRECT NUMBER
	JRST SPOFIL	;AND SEND

SPOTB1:	LDB T1,LDPFC2
	TRNN T4,4
	SKIPA T4,TBFL2(T1)	;USE LONG FILL
	MOVE T4,TBFL(T1)	;OR SHORT FILL
	JRST SPOFL1
SUBTTL	FORM FEED

SPOFF:	TLNE U,LDLFRM	;IF TTY DOESN'T DO FORMS,
	JRST SPOFF1
	MOVE T4,FFFLP
	JRST SPOFIL	;  SEND LINEFEEDS
SPOFF1:	LDB T1,LDPFC1	;IF IT DOES,
	MOVE T4,FLLFFS(T1)
	JRST SPOFL1	;  SEND PAD CHARACTERS

;VERTICAL TAB

SPOVT:	TLNE U,LDLFRM	;IF TTY DOESN'T DO VERTICAL TABS,
	JRST SPOVT1
	MOVE T4,VTFLP
	JRST SPOFIL	;  SEND LINEFEEDS
SPOVT1:	LDB T1,LDPFC1	;IF IT DOES,
	MOVE T4,FLLVTS(T1)
	JRST SPOFL1	;  SEND PAD CHARACTERS

;BACKSPACE

SPOBS2:	PUSHJ	P, SPOBSP	;UPDATE CHAR COLUMN COUNTER
	JRST	PRCOT3

SPOBSP:	MOVSI	T1, L2LBSP	;IF NEITHER BS FOR CHAR DELETE
	TDNE	T1, LDBBYT(U)
	JRST	SPOBS1
	LDB	T1, LDPECH	;NOR REMOTE BS ECHO
	JUMPE	T1, CPOPJ	;THEN DON'T COUNT IT
SPOBS1:	LDB	T1, LDPPOS
	SOSL	T1
	DPB	T1, LDPPOS	;IF POS-1 .ge. 0, POS:=POS-1
	POPJ	P,

;SPOFIL -- CALLED WITH T4/ FILL POINTER. OUTPUT THE FILL CHARACTERS.
;	   IF THERE'S NOT ENOUGH OUTPUT RING SPACE, SET UP LDPFLP
;	   TO POINT TO WHAT'S LEFT, SET P1 = -1, AND LET GOFIL
;	   DO THE REST. SKIP-RETURNS ALWAYS.
;SPOFL1 -- OUTPUT THE CHAR IN T3, THEN THE T4 STRING

SPOFIL:	ILDB	T3, T4		;T3/ NEXT CHAR
	JUMPE	T3, CPOPJ1	;DONE
SPOFL1:	UUIDPB	T3, CHRWRP(W)	;DEPOSIT IT
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	JRST	.+2		;(NO ROOM)
	JRST	SPOFIL		;BACK FOR MORE
	SETO	P1,		;SET NO-MORE-ROOM FLAG
	MOVE	T3, T4
	ILDB	T3, T3		;T3/ NEXT CHAR
	JUMPE	T3, CPOPJ1	;IF IT WASN'T THE TERMINATING NUL,
	MOVEM	T4, LDBFLP(U)	;  SET THE REST AS FILLER
	MOVEI	T3, 1
	DPB	T3, LOPFIL	;  AND SET NEED-FILLER
	JRST	CPOPJ1
SUBTTL	FILLER	POINTERS AND VARIOUS ECHO POINTERS

CCPTR:	POINT 7,CCASC
CCASC:	ASCIZ /\^C
/

CRPTR:	POINT 7,CCASC,20	;JUST THE RETURN FROM ABOVE

CUPTR:	POINT 7,CUASC
CUASC:	ASCIZ /\^U
/

UPARPT:	POINT 7,UPASC
UPASC:	ASCIZ /\^
/

COPTR:	POINT 7,COASC
COASC:	ASCIZ /\^O
/

FLLBSC:	POINT 7,BSLASC
BSLASC:	ASCIZ /\
/

FFFLP:	POINT 7,FFLP0		;FILLER FOR SIMULATING FORM FEED
FFLP0:	BYTE (7) 12,12,12,12,12,12,12,12,0

VTFLP:	POINT 7,FFLP0,27	;FILLER FOR SIMULATING VERTICAL TAB

	DEFINE FILLP(N)
<IF1,<IFG N-FLMX,<FLMX==N>
	0>
IF2,< XXXQ==<FLMX-N>/5
XXXR==FLMX-N-<XXXQ*5>

IFE XXXR,<POINT 7,FILERS+XXXQ>
IFN XXXR,<POINT 7,FILERS+XXXQ,<7*XXXR>-1>>>

;THE ABOVE MACRO DEFINES POINTERS INTO A LIST OF FILLERS (377)
IF1,<FLMX==0>

FLLFFS:	0
	FILLP ^D12
	FILLP ^D15
	FILLP ^D40

FLLVTS:	0
	FILLP 6
	FILLP 5
	FILLP ^D20

TBFL:	0
	FILLP 1
	FILLP 3
	FILLP 3

TBFL2:	0
	FILLP 2
	FILLP 5
	FILLP 5

;NOW GENERATE FILLERS

	DEFINE GENFL(X)
<XXQ==X/5
	REPEAT XXQ,<BYTE (7) 177,177,177,177,177>
XXQ==X-<XXQ*5>
IFE XXQ,<0>
IFE XXQ-1,<BYTE (7) 177>
IFE XXQ-2,<BYTE (7) 177,177>
IFE XXQ-3,<BYTE (7) 177,177,177>
IFE XXQ-4,<BYTE (7) 177,177,177,177>
>

FILERS:	GENFL (FLMX)
TABPTR:	POINT 7,SSPT
	POINT 7,SSPT,6		;FILLERS TO SIMULATE TABS WITH SPACES
	POINT 7,SSPT,13
	POINT 7,SSPT,20
	POINT 7,SSPT,27
	POINT 7,SSPT+1
	POINT 7,SSPT+1,6
	POINT 7,SSPT+1,13

SSPT:	BYTE (7) 40,40,40,40,40,40,40,40,0

;HERE IF CHARACTER IS UPPER CASE

PROUCC:	HLRZ	T1,LDBDCX(U)	;GET LEFT HALF OF DEV CHR EXT WORD
	TRNE	T1,LXLLCO	;SKIP IF U TO L CASE CONV NOT DESIRED
	ADDI	T3,40		;CONVERT CHAR TO LOWER CASE
	LDB	T4,LDPPOS
	JRST	PRCOCW		;PRINT AND COUNT 1 CHARACTER-WIDTH

SUBTTL ONCE A SECOND LOGIC

;THIS ROUTINE IS CALLED EVERY SECOND TO WORRY ABOUT IMAGE MODE
;TIME OUTS AND TO MAKE SURE THAT SOMEONE WHO IS JUST WAITING
;FOR SOME SPACE TO FILL HIS OUTPUT BUFFER GETS RESTARTED

SCNSEC::MOVSI	T3,(BV.DBG)	;Get base version and debugging flag
	TDNN	T3,BASVER	;Is base being debugged?
	SKIPE	CTYDO##		; or running in CONSOLE mode?
	 JRST	SCNSC0		;Yes, ignore timeouts
	MOVE	T1,KEYTIM##	;Ticks since key was updated
	MOVE	T2,IRPTIM##	;Ticks since last input
	CAML	T1,T2		;Get smaller in T1
	 MOVE	T1,T2
	IDIV	T1,JFYSEC##	;Seconds since last input
IFCPU(KS),<ND BASTIM,777777>	;Wait a long time on the 2020
	   ND BASTIM,^D90	;1.5 minutes on KI, KL, F3
	SKIPL	IRPTIM##	;Only output this message once
	CAIGE	T1,BASTIM	;Has it been too long?
	 JRST	SCNSC0		;No message
	 STOPCD (.+1,EVENT,NOBASE,PRTBTM,<No response from BASE>)
	SETOM	BASDWN##	;Set flag to mark base down
	POPJ	P,		;Do something about it next tic

PRTBTM:	PUSHJ	P,INLMES##	;Called from STOPCD(NOBASE)
	 ASCIZ /No response from base.  Please reload it.  PDP-10 is still up.
/
	MOVSI	T1,(1B0)	;Set flag saying NOBASE message output done
	IORM	T1,IRPTIM##
	POPJ	P,

SCNSC0:
IFKMC<	SKIPE	CRSHWD##	;If location 30 is nonzero,
	 PUSHJ	P,HNGALL	; hang all jobs before halting 2020
	MOVEI	P4,MXLIN##	;FOR EACH LINE
	AOS	DRMTIM		;INC MESSAGE TIMER
	SOSGE	TIMMIN		;KMC MINUTE COUNTER
	 JRST 	[MOVEI T1,^D60
		MOVEM T1,TIMMIN	;SET FOR ONE MINUTE
		PUSHJ P,SCNMIN	;CALLED EVERY MINUTE
		JRST	.+1]
	SOSGE	TIMDRD		;COUNTER FOR SERVICING DOWN DRs
	 JRST 	[MOVEI T1,^D60
		MOVEM T1,TIMDRD	;SET FOR ONE MINUTE
		PUSHJ P,SCNDRD	;TIMING VARIES BUT IS USUALLY 60
		JRST	.+1]
>;END IFKMC
	MOVE	T1,PTYFLO
	MOVEM	T1,MULCNT+1	;LET PTYS OUTPUT SOME MORE
	SKIPLE	OPRTIM
	SOSLE	OPRTIM		;IF OPER TIMEOUT HAS GONE OFF,
	 JRST	SCNSC1
	MOVEI	T1,ALROPR
	IORM	T1,ALR620	;  SET THE ALARM CELL
SCNSC1:	SOSL	TIMOW		;IF ORANGE-BALL-WAIT HAS GONE OFF,
	 JRST	SCNSC2
	MOVEI	T1,OWTIM
	MOVEM	T1,TIMOW	;  RESET IT
SCNSC2:	MOVEI	P4,MXLIN##	;(LOOP THROUGH ALL PORTS)

SECLOP:	MOVE	U,LINTAB(P4)
	HLL	U,LDBDCH(U)	;U/ DCH BITS,,LDB ADDR
	HRRZ	F,LDBDDB(U)	;F/ DDB ADDR
	MOVE	T1,LDBMOD(U)
	TLNE	T1,LMLBIO	;IF PORT'S IN BLOCK MODE,
	 JRST	[
		PUSHJ	P,BIOCHG	;CHARGE FOR ELAPSED TIME
		MOVEI	T1,LDRBIP	;CHECK TIMEOUT IF PTY BLKI
		JRST	SECLP1
	]
	MOVSI	T1,LDLIMI	;ELSE CHECK TIMEOUT IF IN IMAGE STATE
SECLP1:	TDNN	T1,LDBDCH(U)	;IF WE DON'T CARE ABOUT TIMEOUTS,
	 JRST	SECLP2		;  SKIP THIS STUFF
    ;CODE TO CHECK THE PER-PORT TIMEOUT FIELD

	LDB	T3,LDPTIM	;T3/ SECONDS REMAINING, OR 0
	SOSL	T3		;IF IT WASN'T 0,
	DPB	T3,LDPTIM	;  DECREMENT IT
	JUMPN	T3,SECLP2	;IF IT JUST RAN OUT,
	MOVEI	T1,LDRBIP
	TDNN	T1,LDBDCH(U)	;  IF PTY BLOCK INPUT IS IN PROGRESS,
	 JRST	SECTM1
	PUSHJ	P,PBTIMO	;    TIME IT OUT
	JRST	SECLP2

SECTM1:	JUMPE	F,SECTM3	;  IF NO DDB, FORCE OUT OF IMAGE STATE
	LDB	T1,LDPIMB	;  T1/ 0, OR IMAGE BREAK CHAR
	JUMPN	T1,SECTM2	;  IF THERE'S NO BREAK CHAR,
	PUSHJ	P,IMGCHG	;    CHARGE FOR A WAKEUP
	PUSHJ	P,LINTRP	;    SIGNAL A BREAK
	PUSHJ	P,USRWAK	;    WAKE THE JOB
SECTM2:	TLNE	U,LDLAUX	;  IF IT'S NOT AN AUX CIRCUIT,
	 JRST	SECLP2
	SKIPN	LDBTIC(U)
	SKIPE	LDBECC(U)	;    IF THERE'RE NO CHARACTERS,
	 JRST	SECLP2
	MOVSI	S,IOEND
	IORB	S,DEVIOS(F)	;      SET EOF
	TRNE	S,10
	TRNE	S,7
	 JRST	SECLP2		;      IF IMAGE MODE,
SECTM3:	MOVSI	T1,LDLIMI
	ANDCAM	T1,LDBDCH(U)	;        FORCE OUT OF IMAGE STATE
	PUSHJ	P,BPOFF		;        CLEAR BACKPRESSURE
	PUSHJ	P,SETLMD	;        FIX LINE MODE
    ;THE REST OF THE PER-PORT ONCE-A-SECOND CODE

SECLP2:	MOVSI	T1,L2LOWT
	SKIPN	TIMOW		;IF ORANGE-BALL-WAIT TIMER'S GONE OFF
	TDNN	T1,LDBBYT(U)	;AND PORT'S WAITING FOR ORANGE BALL,
	 JRST	SECLP3
	MOVSI	T1,L2LOWS
	TDNN	T1,LDBBYT(U)	;  IF WE HAVEN'T BEEN HERE BEFORE,
	 JRST	[
		IORM	T1,LDBBYT(U)	;SET THE ONCE-BEFORE FLAG
		JRST	SECLP3
	]
	PUSHJ	P,OBFND		;  IF WE HAVE, FAKE AN ORANGE BALL

;P035/C06 17-Nov-87 - Watch for lost zappers.
	..==LNLZIN		;CREF this reference to sign bit
SECLP3:	SKIPGE	LDBLIN(U)	;Is there an in-zap seen?
	 JRST	[MOVEI  T1,1	    ;Yes
		 LDB    T2,LDBOPB(U);See if it is scheduled to go out
		 DPB    T1,LOPZAP   ;Make sure the "send zap" bit is on
		 DPB    T1,LDBOPB(U); and "need output" is on
		 MOVSI  T1,L2LOWT   ; and orange-ball wait
		 ANDCAM T1,LDBBYT(U); is off
		 SKIPN  T2          ;If it wasn't scheduled,
		  AOS    NZAPRS	   ;Count number of zaps resent
		 JRST  .+1]
	JUMPE	F,SECLP4	;IF THERE'S A DDB
	MOVSI	S,TWTSPC
	TDNN	S,DEVIOS(F)	;AND IT'S WAITING FOR BUFFERLETS
	 JRST	SECLP4
	MOVE	T1,TTFREN
	CAIG	T1,TIRSVD	;AND THERE'RE ENOUGH NOW,
	 JRST	SECLP4
	ANDCAM	S,DEVIOS(F)	;  CLEAR BUFFERLET-WAIT BIT
	PUSHJ	P,XMTWAK	;  AND AWAKEN JOB
SECLP4:	SOJG	P4,SECLOP	;(CONTINUE WITH NEXT PORT)
	POPJ	P,


BIOCHG:	JUMPE	F,CPOPJ		;CHECK FOR DETACHED JOB.
	LDB	T1,PJOBN	;PICK UP HIS JOB NUMBER.
	AOS	JBTBET(T1)	;INCREMENT HIS ELAPSED BIO TIME.
	AOS	JBTBET		;INCR TOTAL ELAPSED BIO TIME.
	POPJ	P,		;AND RETURN.
SUBTTL	OPRCTY - Remove chars from CTY's LDB and send to CTY

OPRCTY:	MOVEI	U,CTYLDB	;Called by once-per-tick code
	SKIPGE	OPRTIC		;If CTYSIM is not doing anything,
	 SETOM	OPRTIC		; make sure this doesn't overflow to positive
		SOSG  OPRTIC	;Don't output if CTYSIM output recently
IFCPU(<KI,F3>),<CONSZ TTY,TT.OB>;Skip if output is done
IFCPU (KS),<	SKIPE CTYOWD##>	;Skip if output is done
IFCPU(KL),<	SKIPN EPT##+SPCMTD>; "     "         "
		 POPJ P,	;Output in progress - try again later
;*;	MOVEI	T3,ALRCTY	;SET ALARM
;*;	IORM	T3,ALR620	;11 NODES DON'T CARE TO KNOW ABOUT ALRCTY
	SKIPL	CTYBLF		;AAA. IF -1 RING BELL THIS TIME
	 JRST	OPRCT2
	HRRZS	CTYBLF		;RESET TO 0,,-1
	MOVEI	T3,7
	PJRST	CTYCHR		;RING BELL.

OPRCT2:	SKIPLE	CTYFLN		;ARE THERE FILLS NEEDED
	 JRST	OPRFIL		;YES
	MOVE	T2,LDBTOT(U)
	PUSHJ	P,TTGETC	;Get character from CTY's LDB
	  PUSHJ	P,FRECHK
	MOVEM	T2,LDBTOT(U)
	PUSHJ	P,CTYLOG	;Log it in CTYBUF
	PUSHJ	P,PEVEN8	;Generate parity (smashes T1)
	PUSHJ	P,CTYCHR	;Send it to the CTY
	ANDI	T3,177
	CAIE	T3,14
	CAIN	T3,13		;HANDLE FF AND VTB
	 JRST	CTYFRM
	CAIN	T3,15
	SKIPN	T3,CTYFIL	;CR AND NEED FILLS?
	 JRST	CTYNFL		;NO
CTYSFL:	MOVEM	T3,CTYFLN	;YES, SET COUNT (DO NOT DEC CHR CNT)
	POPJ	P,

CTYFRM:	MOVEI	T3,^D40
	JRST	CTYSFL		;SET LARGE NUMBER OF FILLS

OPRFIL:	MOVEI	T3,377		;Filler is RUBOUT with even parity
	PUSHJ	P,CTYCHR	;Go to CTY (not CTYLOG)
	SOSLE	CTYFLN
	 POPJ	P,		;Come back next tick
CTYNFL:	SOSLE	LDBTOC(U)
	 POPJ	P,		;NOT ALL OUTPUT YET
	PUSHJ	P,OPRFRE	;RESTART SETUUO WAITERS
	PUSHJ	P,TSETBO	;RESET OUTPUT BUFFER
	POPJ	P,		;DONE
SUBTTL	SEND A SAD MESSGE

SNDSAD:	MOVE	T1,ALR620
	CAMN	T1,ALRSNT
	  JRST	CPOPJ1		;NOT SENT
	PUSH	P,T1		;SAVE T1 FROM BEING CLOBBERED.
	PUSHJ	P,CLSCHR	;FINISH UP CHARACTER OUTPUT.
	 JRST	TPOPJ		;NO MORE ROOM.
	MOVE	T2,ORPPDP	;PICK UP THE OUTPUT RING POINTER.
	ADDI	T2,2		;THIS OPERATION REQUIRES 2 WORDS.
	ANDI	T2,MSKORG	;MASK FOR WRAP AROUND.
	CAMN	T2,ORP620	;MAKE SURE THERE'S ROOM.
	  JRST	TPOPJ		;NO MORE ROOM.  FINISH SCANNING LINE.
	POP	P,T1		;RESTORE T1
	MOVEM	T1,ALRSNT	;SAY WE SENT THAT ONE
	MOVSI	P3,TYPI TYPSAD
	LDB	T1,[POINT 16,ALR620,15]
	DPB	T1,[POINT 16,P3,BYP4]
	MOVEM	P3,ORING(P4)
	PUSHJ	P,ORPLOG	;Put message into ORING log
	ADDI	P4,1
	ANDI	P4,MSKORG	;POINT TO CORRECT LOCATION (POSSIBLE WRAP)
	LDB	T1,[POINT 16,ALR620,31]
	DPB	T1,[POINT 16,P3,BYP2]
	PUSHJ	P,WRDOT2	;WRITE 2ND WORD AND CLEAN UP
	  POPJ	P,		;NO MORE ROOM.  CALL FINOUT.
	JRST	CPOPJ1		;CONTINUE SCAN.
SUBTTL	ON RECEIPT OF A TAKEOVER MESSAGE, RESET AND TRY AGAIN

RCVNSP:	MOVE	T1,DATE##	;Remember the date/time of when
	MOVEM	T1,SUPTIM##	; the new Supervisor took over
	SKIPN	AUXSTA
	 AOJA	P4,SCNIN1	;IN IDLE STATE, JUST IGNORE
	SKIPL	U,AUXRCP	;PORT RECEIVED?
	 PUSHJ	P,TTYZAP	;YES, ZAP IT
	MOVEI	T1,.ASRQ1
	MOVEM	T1,AUXSTA
	AOJA	P4,SCNIN1	;READY TO SEND FIRST REQUEST
SUBTTL	SUPERVISOR RESPONSE RECIVED

RCVSUR:	MOVE	T1,AUXSTA
	XCT	ARSTAB(T1)

ARSTAB:	AOJA	P4,SCNIN1	;.ASIDL IGNORE
	AOJA	P4,SCNIN1	;.ASRQ1 IGNORE
	JRST	RCVS2		;.ASWR1 RESPONSE TO 1ST REQUEST
	AOJA	P4,SCNIN1	;.ASRQ2 IGNORE
	JRST	RCVS4		;.ASWR2 RESPONSE TO 2ND REQUEST
	AOJA	P4,SCNIN1	;.ASLOG IGNORE
	JRST	RCVS6		;.ASWPT RESPONSE TO LOGIN
	JRST	RCVSP		;.ASWTP RESPONSE TO LOGIN (BAD RCVAUX)

    ;SUPERVISOR RESPONSE TO FIRST REQUEST

RCVS2:	LDB	T1,INPCHR	;GET ERROR CODE
	JUMPN	T1,[AOS AUXSTA	;ON ERROR, STATE:=.AXRQ2 (RETRY)
		AOJA P4,SCNIN1]
RCVS2A:	MOVE	T1,[POINT 7,AUXSTR]
	MOVEM	T1,AUXSTP
	MOVEI	T1,.ASLOG
	MOVEM	T1,AUXSTA	;SUCCESSFUL RESPONSE: SEND LOGIN STRING
	AOJA	P4,SCNIN1

  ;SUPERVISOR RESPONSE TO RE-REQUEST

RCVS4:	LDB	T1,INPCHR	;LIKE 1ST REQUEST BUT ERROR IS FATAL
	JUMPE	T1,RCVS2A	;NO ERROR
	HRLI	T1,CXERR%	;SET ERROR TYPE
	PUSHJ	P,ERRXIT	;AND CLEAN UP
	AOJA	P4,SCNIN1

    ;SUPERVISOR RESPONSE TO LOGIN STRING

RCVS6:	LDB	T1,INPCHR
	JUMPN	T1,[PUSHJ P,ERRXIT	;ERROR, TELL USER
		AOJA P4,SCNIN1]	;AND CLEAN UP
	PUSHJ	P,AUXWAK	;WAKE UP THE USER
	AOJA	P4,SCNIN1

RCVSP:	LDB	T1,INPCHR
	JUMPN	T1,[PUSHJ P,ERRXIT	;ERROR, TELL USER
		AOJA P4,SCNIN1]	;AND CLEAN UP
	MOVEI	T1,.ASRQ1	;SHOULDN'T GIVE ERROR TO USER,
	MOVEM	T1,AUXSTA	;SO SETUP FOR RETRY
	AOJA	P4,SCNIN1

ERRXIT:	MOVEM	T1,AUXERR	;SAVE ERROR
	SKIPL	U,AUXRCP	;IS THERE A PORT
	 PUSHJ	P,TTYZAP	;YES, ZAP IT
AUXWAK:	SETZM	AUXSTA		;STATE:=.ASIDL (IDLE)
	MOVE	J,AUXJOB	;JOB WAITING
	MOVEI	T1,RNQ
	DPB	T1,PJBSTS##
	PJRST	SETRUN		;RESTART HIM FOM MLOWQ
SUBTTL	 MESSAGE 7 - AN AUX CIRCUIT HAS BEEN BUILT TO <U> FOR
;	       THE JOB WHOSE COMMAND PORT IS <INPCHR>

RCVAUX:	MOVE	T1,LDBLIN(U)
	TLNE	T1,LNLZIN		;IF THERE'S AN UNECHOED ZAPPER,
	 JRST	[MOVEI	T1,NZAPAX
		 PUSHJ	P,ZAPBUG	;NOTE IT
		 JRST	.+1]
	SKIPE	LDBLOG(U)		; LOGGING OR LOGGED IN?
					;  TREAT AS CIRCUIT ZAPPER
	  JRST	[PUSHJ	P,ZAPLOG	; NOTE THE ZAP (increment P4)
		 MOVE	T1,AUXSTA	; Make sure that we were
		 CAIE	T1,.ASWPT	;  expecting a type 7 msg.
		  SOJA	P4,AUXWST	; No? decrement & handle error
		 AOS	AUXSTA		; Yes, State:= .ASWTP, keep waiting!
		 JRST	SCNIN1]		; Return to loop

	MOVE	T1,AUXSTA		; T1/ STATE
	CAIN	T1,.ASWPT		; IF WE'RE NOT EXPECTING A TYPE 7,
	 JRST	AUXINP
	PFALL	AUXWST			;   NOTE THE ERROR

AUXWST:	; MESSAGE RECEIVED IN WRONG STATE
	AOS	AUXWSC			; NOTE THE FACT
	JRST	AUXZPT			; TREAT MSG AS A ZAPPER

AUXWPN:	; MESSAGE RECEIVED BUT WITH THE WRONG PORT NUMBER
	AOS	AUXWPC			; NOTE THE FACT
	MOVEM	T1,AUXWPT		; SAVE THE (BAD) PORT'S LDB ADDR
	PFALL	AUXZPT			; TREAT MSG AS A ZAPPER

AUXZPT:	PUSHJ	P,TTYZAP		; ARRANGE TO SEND ZAPPER
	AOJA	P4,SCNIN1

AUXINP:	LDB	T1,INPCHR		; T1/ CREATING JOB'S PORT #
	HRRZ	T2,AUXPRT
	CAME	T1,T2			; IS IT CORRECT?
	 JRST	AUXWPN			; NO
	HRRZM	U,AUXRCP		; SAVE THE LINE POINTER
	MOVSI	T1,(1B0)
	MOVEM	T1,LDBLOG(U)		; SET LOGGED-IN BIT

	; INITIALIZE THE LINE
	SETZM	LDBOUT(U)
	SETZM	LDBBYT(U)
	SETZM	LDBMOD(U)
	SETZM	LDBTMT(U)
	ZZN==0
REPEAT TMCSIZ,<
	SETZM LDBTMR+ZZN(U)
	ZZN==ZZN+1
> ; End REPEAT TMCSIZ
	MOVSI	T1,LDLDEF!LDLIMI!LDLAUX!LDLNEC!LDLNFC
	MOVEM	T1,LDBDCH(U)
	MOVSI	T1,LXL120
	MOVEM	T1,LDBDCX(U)
	HRLI	T1,AUXSTR		; Copy string sent to
	HRRI	T1,LDBSTR(U)		;  supervisor for tracking
	BLT	T1,LDBSTR+AUXSTL-1(U)

	PUSHJ	P,SETLMD		; SET THE INPUT MODE
	AOJA	P4,SCNIN1
SUBTTL	CALLED ONCE A TICK FROM SCNINT TO PROCESS AUX CIRCUIT BUILDS

SNDAUX:	MOVE	T1,AUXSTA	;SEE WHAT WE SHOULD DO
	XCT	AXSNTB(T1)
	 JRST	AUXTOV		;TIME OUT
	JRST	CPOPJ1		;JUST RETURN

AXSNTB:	JRST	CPOPJ1		;.ASIDL  DO NOTHING
	JRST	SNDSRQ		;.ASRQ1  SEND 1ST REQUEST
	SOSG	AUXTIM		;.ASWR1  TIME THE RESPONSE
	JRST	SNDSRQ		;.ASRQ2  SEND 2ND REQUEST
	SOSG	AUXTIM		;.ASWR2  TIME THE RESPONSE
	JRST	AUXCHR		;.ASLOG  SEND LOGIN STRING
	SOSG	AUXTIM		;.ASWPT  TIME THE RESPONSE
	SOSG	AUXTIM		;.ASWTP  TIME THE RESPONSE

AUXTMR:	^D150*^D60		;REQUEST RESPONSE TIMEOUT
AUXTMP:	^D150*^D60		;PORT RESPONSE TIMEOUT

    ;HERE TO SEND A SUPERVISOR REQUEST

SNDSRQ:	PUSHJ	P,CLSCHR
	  POPJ	P,		;NOT REALLY ANY ROOM
	MOVSI	P3,TYPI TYPSUP	;SEND REQUEST
	MOVE	T1,AUXPRT	;GET THE PORT NUMBER
	DPB	T1,WRPLIN
	HLRZ	T1,AUXPRT	;Get NETID number
	DPB	T1,WRP3N4	;Store 16 bits
	MOVE	T1,AUXTMR	;SET TIMER
	MOVEM	T1,AUXTIM
	AOS	AUXSTA		;ADVANCE STATE (.ASRQX = .ASWTX)
	JRST	WRDOUT		;AND SEND REQUEST
SUBTTL	HERE TO SEND CHARACTERS FROM THE LOGIN STRING

AUXCHR:	PUSHJ	P,CLSCHR
	  POPJ	P,		;NO ROOM
	MOVSI	P3,TYPI TYPAXC
	MOVE	T1,AUXPRT
	DPB	T1,WRPLIN	;SET UP TO SEND
AXCLP1:	MOVE	T2,MXMCNT	;SPACE LEFT
	ADDI	T2,2
	LSH	T2,-2
AUXCLP:	ILDB	T1,AUXSTP
	JUMPE	T1,AXCDON	;FINISHED
	DPB	T1,WRPCHR
	MOVEM	P3,ORING(P4)	;PUT IN RING
	PUSHJ	P,ORPLOG	;Put message into ORING log
	SOJLE	T2,AXCLP2	;RAN OUT OF ROOM
	 AOJA	P4,AUXCLP	;ADVANCE POINTER AND CONTINUE

AXCLP2:	ADDI	P4,1		;ADVANCE POINTER
	ANDI	P4,MSKORG
	MOVE	T1,AUXSTP
	ILDB	T1,T1		;GET NEXT CHARACTER
	JUMPE	T1,AXCDON	;HAVE REALLY SENT THEM ALL
	MOVEM	P4,ORPPDP	;SAVE POINTER FOR 620
	PUSHJ P,SETOUT
	  POPJ	P,		;OUT OF ROOM
	JRST	AXCLP1		;MORE ROOM, SEND MORE

AXCDON:	MOVEM	P4,ORPPDP
	MOVE	T1,AUXTMP
	MOVEM	T1,AUXTIM	;SET TIMER
	AOS	AUXSTA		;STATE:=.ASWPT (WAIT FOR PORT RESPONSE)
	PJRST	SETOUT		;RESET ROOM COUNTERS AND EXIT

;HERE ON ANY TIMEOUT

AUXTOV:	AOS	(P)		;SET FOR SKIP RETURN
	MOVE	T1,AUXSTA
	XCT	AXTOTB(T1)	;RESPOND ACCORDING TO WHAT GOT TIMED-OUT

AXTOTB:	 STOPCD			;.ASIDL  CAN'T TIME OUT
	 STOPCD			;.ASRQ1  CAN'T TIME OUT
	JRST	AXNRR		;.ASWT1  1ST REQUEST TIMED OUT
	 STOPCD			;.ASRQ2  CAN'T TIME OUT
	JRST	AXNRR		;.ASWT2  2ND RESPONSE TIMED OUT
	 STOPCD			;.ASLOG  CAN'T TIME OUT
	JRST	AXNRL		;.ASWPT  PORT RESPONSE TIMED OUT
	JRST	AXNRL		;.ASWTP  PORT RESPONSE TIMED OUT (BAD RCVAUX)

AXNRR:	MOVSI	T1,CXNRR%	;SET ERROR CODE
	PJRST	ERRXIT

AXNRL:	MOVSI	T1,CXNRL%
	PJRST	ERRXIT
SUBTTL	CODE TO HANDLE THE CREAT AUX CIR UUO
;Call:	MOVEI	AC,[ASCIZ/USERNAME:HOST/]
;	HRLI	AC,FLAGS	;Bits 1-2 are DR # on KS, Bit 17 is NOZAP,
;				;Bits 1-16 are for NETID (new in P035/D07)
;	CREAUX	AC,		;CALLI AC,-144
;	  error return

IFCPU(<KI,KL>),<CXDTP==0>	;Use port 0 for detached jobs
IFCPU(<KS,F3>),<CXDTP==1>	;Always user port 001 (or 101 or 201 or 301)

CREAUX::AOSE	AXREQ
	 PUSHJ	P,AXWAIT	;WAIT FOR RESOURCE
	SETZM	AXSWT
	MOVEI	T2,AXGIV
	MOVEM	T2,JBTABT(J)	;SET ERROR LOCATION
	SETZM	AUXERR		;NO ERROR YET
	SETOM	AUXRCP		;AND NO PORT
	HRRZ	F,TTYTAB(J)
	JUMPE	F,AUXDET	;IF NO JOB (!)
	HRRZ	U,DDBLDB(F)
	JUMPE	U,AUXDET	;OR NOT ATTACHED
	MOVSI	T2,LDLPTY
	TDNE	T2,LDBDCH(U)	;OR CONTROLLED BY A PTY,
	 JRST	AUXDET
IFNKMC<
	LDB	U,LDPLNO	; Use CMD port as index!!
	SKIPA			;  ** not done if KMC **
> ; End IFNKMC
AUXDET:	MOVEI	U,CXDTP		;  FAKE A PORT NUMBER
	MOVEM	U,AUXPRT	;Send to SUP on this port number
	MOVEM	J,AUXJOB	;SET JOB NUMBER
	MOVE	P1,T1		;SAVE ARGUMENT
	HRLI	T1,(POINT 7,0)	;GET POINTER TO THE STRING
	MOVE	P4,[POINT 7,AUXSTR]	;SET TO SAVE IT
	MOVEI	P3,AUXSTM	;MAX WE CAN HAVE
	MOVE	T4,[POINT 6,AUXUNM]	;SET TO ACCUMULATE A USER NAME
	MOVEI	P2,^D12		;MAX CHRS IN USER NAME
	SETZM	AUXUNM
	SETZM	AUXUNM+1
	SETZM	AUXSTR		;Clear out accumulated string
	MOVE	T2,[AUXSTR,,AUXSTR+1]
	BLT	T2,AUXSTR+AUXSTL-1

AUXSLP:	XCTFU	<ILDB	T2,T1>	;GET 7-BIT CHAR FROM USER
	JUMPE	T2,AXSFN1	;END OF STRING
	IDPB	T2,P4		;PUT IT AWAY
	CAIE	T2,15
	CAIN	T2,";"		;TERMINATE ON RETURN OR ;
	 JRST	AXSFIN
	CAIN	T2,":"		;TERMINATE USER NAME ON :
	 SETZ	P2,0		;BY ZAPPING COUNT
	SUBI	T2,40		;CONVERT TO SIXBIT
	JUMPL	T2,AUXNSB	;Don't put control chars in username
	SOJL	P2,AUXNSB	;ALREADY TOO MANY CHRS IN USER NAME
	IDPB	T2,T4		;AND SAVE IT
AUXNSB:	SOJG	P3,AUXSLP	;SEE IF ROOM FOR MORE

AXSFN1:	MOVEI	T2,15
	IDPB	T2,P4		;TOO MANY, FINISH WITH RETURN
AXSFIN:	MOVEI	T2,0
	IDPB	T2,P4		;TERMINATE STRING WITH 0
	HRRZM   P4,AUXEND	;SAVE POINTER TO LAST WORD OF LOGIN STRING
	HRRZ    T3,P4           ;ZERO OUT LAST WORD OF LOGIN
	IDPB    T2,P4           ; STRING TO RIGHT OF NULL
	CAIN    T3,(P4)         ; SO THAT CREAUX STREAM
	 JRST	.-2             ; RECORDS LOOK GOOD
	MOVSI	T2,LICAC
	TDNE	T2,JBTLIC(J)	;SEE IF HE HAS LICENSE
	 JRST	AUXLIC		;YES
	MOVE	T2,AUXUNM
	MOVE	T3,AUXUNM+1
	CAMN	T2,JBTUNM(J)	;CHECK USER NAME MATCH
	CAME	T3,JBTUN1(J)
	 JRST	[MOVSI T2,CXLOG%
		JRST AXERGV]	;ERROR
	PUSHJ	P,FRSTTY	;NOW SEE HOW MANY CIRCUITS
	  JRST	AUXLIC
	PUSHJ	P,NXTTTY
	  JRST	AUXLIC		;NONE
	PUSHJ	P,NXTTTY
	  JRST	AUXLIC		;ONE
	MOVSI	T2,CX2AX%
	JRST	AXERGV		;ERROR, already have 2 circuits in use
AUXLIC:
IFKMC<
	LDB	T3,[POINT 2,P1,2]	;GET TYMBASE NUMBER
	PUSHJ	P,KMCGUP	;T1/ TYMBASE "UP" BITS
	MOVSI	T2,^D8		;TYMBASE DOWN MESSAGE
	XCT	TSTDRU(T3)	;SKIP IF IT'S UP
	  JRST	AXERGV		;ELSE RETURN TYMBASE DOWN MESSAGE
	JRST	AUXDRU

TSTDRU:	TRZN	T1,DR1BIT
	TRZN	T1,DR2BIT
	TRZN	T1,DR3BIT
	TRZN	T1,DR4BIT

AUXDRU:	LSH	T3,6		;Request circuit on DR# * 64.
	IORM	T3,AUXPRT
> ; END IFKMC
IFNKMC<	LDB	T1,[POINT 16,P1,16]	;All but 1B0 and 1B17
	HRLM	T1,AUXPRT	;Store NETID number
	JUMPE	T1,AUXDRU	;OK if asking for default
	MOVSI	T2,^D8		;TYMBASE DOWN = illegal NETID
	MOVSI	T1,LICWCR	;Must have WRITE CORE to build an
	TDNN	T1,JBTLIC(J)	; aux circuit to other net
	 JRST	AXERGV		;(error code 8 means problems with LH of AC)
AUXDRU: > ;END IFNKMC
	MOVEI	T1,MLOWQ
	DPB	T1,PJBSTS##
	AOS	AUXSTA		;SET STATE TO 1
	PUSHJ	P,WSCHED	;AND RESCHEDULE
	SKIPE	T2,AUXERR	;ANY ERRORS
	 JRST	AXERGV
	SKIPGE	AUXRCP	;PORT THERE?
	 JRST	[
		AOS	NRPCNT	;BUMP COUNT
		MOVSI	T2, CXNCH%
		JRST	AXERGV	;ERROR-RETURN
	]
	HRRZ	T1,TTYTAB(J)	;WHERE TO LINK. REALLY SHOULD BE A DDB
	SKIPE	T1
	 PUSHJ	P,DDBSR1
	  JRST	[MOVSI T2,CXDCB%	;NO DDB SPACE
		JRST AXERGV]
	DPB	J,PJOBN
	MOVEI	T1,ASSCON
	TLNE	P1,(1B17)
	 TLO	T1,DVNZP	;SET NO ZAP BIT
	IORM	T1,DEVMOD(F)
	MOVE	U,AUXRCP
	LDB	T1,LDPLNO	;GET LINE NUMBER
	UMOVEM	T1,(W)
	HRRM	U,DDBLDB(F)
	HRRM	F,LDBDDB(U)
	PUSHJ	P,SCNNAM
	MOVEI	T1,22		;WRITE CREAUX
	PUSHJ	P,ACTWRT##	; STREAM RECORD
	AOS	(P)
	JRST	AUXGV1		;FINISHED
AXERGV:	UMOVEM	T2,(W)
AXELOG:	JRST	AXGIV		;JFCL IF WANT ACT REC FOR ERRS
	MOVEM	T2,AUXERR	;SAVE ERR TYPE FOR ACTSER
	MOVEI	T1,22		;CREAUX REC TYPE
	HLRZS	T2		;WRITE REC ONLY
	SKIPE	T2		; FOR EXTRA
	CAIN	T2,CXNCH%	; HOST ERRORS
	 PUSHJ	P,ACTWRT##
AXGIV:	SKIPL	U,AUXRCP
	 PUSHJ	P,TTYZAP
AUXGV1:	SETZM	JBTABT(J)
	SETZM	AUXSTA
	SOSL	AXREQ
	 SETOM	AXAVAL
	POPJ	P,
SUBTTL	READ INFO ON PORTS IN USE

AUXRED::MOVEI	T2,0		;NUMBER OF PORTS SO FAR
	JUMPGE	T1,[XCTTU <SETOM (W)>
		POPJ P,]	;FLAG ERROR
	AOBJN	T1,.+1
	PUSHJ	P,FRSTTY	;THIS WILL GET COMMAND PORT
	  JRST	AUXRN1		;OH WELL
	MOVSI	T4,DVTTY	;TO TEST FOR TTY
AUXRL1:	PUSHJ	P,NXTTTY	;NEXT IN CHAIN
	   JRST	AUXRN1		;FINISHED
	TDNN	T4,DEVMOD(F)
	 JRST	AUXRL1		;IGNORE ALL BUT TTYS
	HRRZ	U,DDBLDB(F)	;GET LINE
	JUMPE	U,AUXRL1	;IGNORE IF NO LINE
	JUMPGE	T1,AUXRL2	;NO ROOM TO PUT IT
	LDB	T3,LDPLNO
	UMOVEM	T3,-1(T1)
	AOBJN	T1,.+1
AUXRL2:	AOJA	T2,AUXRL1	;COUNT 1
AUXRN1:	XCTTU	<SETOM -1(T1)>	;FLAG END OF LIST
	UMOVEM	T2,(W)
	JRST	CPOPJ1		;FINISHED

;ZAP AUX CIRCUITS

ZAPCIR::JUMPL	T1,ZAPALL	;ALL OF THEM
	MOVE	F,T1
	PUSHJ	P,FNDPRT	;FIND THE PORT
	  POPJ	P,		;NOT THERE
	HRRZ	U,DDBLDB(F)
	JUMPE	U,CPOPJ		;NO LINE, IGNORE
	SETZ	T1,		;Don't cause any confusion
	JRST	HNGPRT		;GO HANG HIM

ZAPALL:	PUSHJ	P,FRSTTY
	  POPJ	P,		;NOT COMMAND
ZAPAL1:	PUSHJ	P,NXTTTY
	  POPJ	P,		;DONE
	MOVSI	T1,DVTTY
	TDNN	T1,DEVMOD(F)
	 JRST	ZAPAL1		;NOT A TTY
	HRRZ	U,DDBLDB(F)
	JUMPE	U,ZAPAL1
	SETZ	T1,
	PUSHJ	P,HNGPRT
	JRST	ZAPAL1		;ON TO NEXT
SUBTTL  POLL PORTS UUO

; POLPRT - POLL PORTS FOR INTERRUPT-CAUSING EVENTS
;
;	MOVE	AC, [BITS,,ADDR]
;	POLPRT	AC,
;	  ERROR RETURN (TABLE TOO SMALL)
;	NORMAL RETURN
;
;	(AC/ # OF PORTS RETURNED ON EITHER RETURN)
;
; ADDR:	WORD COUNT (# WORDS, INCLUDING THIS ONE)
;	BITS,,PORT (SET BY UUO)
;	...
;
; WHERE <BITS> IS A MASK FOR THE EVENT BITS IN RH(LDBDCX)

POLPRT::XCTFU	<MOVN T2, (T1)>
	MOVSS	T2
	HRR	T2, T1		; T2/ AOBJN POINTER
	SETZ	T4,		; T4/ COUNT OF PORTS RETURNED
	PUSHJ	P, FRSTTY
	  JRST POLPT4

	; GOT A PORT
POLPT1:	MOVE	T3, DEVMOD(F)
	TLNE	T3, DVTTY
	SKIPN	U, DDBLDB(F)
	JRST	POLPT3		; NOT TTY OR NO LDB

	; CHECK THE EVENTS FOR THIS PORT
	HLRZ	T3, T1		; T3/ 0,,MASK BITS
	AND	T3, LDBDCX(U)	; T3/ 0,,MASKED EVENTS
	ANDCAM	T3, LDBDCX(U)	; TURN OFF WHAT WE'VE READ
	JUMPE	T3, POLPT3	; NOTHING HAPPENED: TRY NEXT PT
	AOBJP	T2, POLPT5	; NO ROOM: ERROR-RETURN
	AOS	T4		; T4/ COUNT OF PORTS RETURNED
	XCTBU	<HRLM T3, (T2)>	; STORE THE EVENT BITS
	LDB	T3, LDPLNO
	XCTBU	<HRRM T3, (T2)>	; AND THE PORT NUMBER

	; GET ANOTHER PORT
POLPT3:	PUSHJ	P, NXTTTY
	  JRST POLPT4
	JRST	POLPT1
POLPT4:	AOS	(P)		; NORMAL RETURN: PORTS EXHAUSTED
POLPT5:	UMOVEM	T4, (W)		; AC := COUNT OF PORTS RETURNED
	POPJ	P,
SUBTTL BLOCK INPUT/OUTPUT (BIO) ROUTINES

;THE FORMAT OF A BLOCK I/O BUFFER IS:

BIOLNK==0	;PTR TO LINKED LIST OF BIO BUFFERS.
BIOCSH==1	;CACHE SWEEP NUMBER AT TIME REQUEST WAS QUEUED.
BIOPBP==2	;PTY BLOCK I/O: ILDB/IDPB POINTER FOR NEXT BYTE
BIOPBC==3	;PTY BLOCK I/O: # BYTES LEFT TO TRANSFER
BIOREQ==4	;CHAR COUNT OF LAST INPUT REQUEST BY THIS PORT.
BIOCHR==5	;COUNT OF CHARACTERS TO TRANSFER. (IN OR OUT).
BIODAT==6	;BEGINNING OF USER DATA.

;HERE FROM ENABLE BLOCK I/O AUXCAL

BLKIO:	MOVSI	T1,LMLBIO
	TDNE	T1,LDBMOD(U)	;IF ALREADY IN BLOCK MODE,
	 POPJ	P,		;  ERROR-RETURN
	SKIPN	T3,LDBBIO(U)	;DOES THE BIO PORT HAVE ANY
	 JRST	BLKIO2		;ACTIVE BUFFERS?
	HLRZ	T1,T3		;YES.  OUTPUT ACTIVE?
	JUMPE	T1,BLKIO1	;NO - GO CHECK FOR INPUT.
	PUSHJ	P,OQUEUE	;YES. QUEUE JOB UNTIL DONE.
	  POPJ	P,		;LINE IS GONE.  HE LOSES.
	JRST BLKIO

BLKIO1:	HRRZ	T1,T3		;INPUT BUFFER ACTIVE?
	SKIPE	T1		;
	 PUSHJ	P,IQUEUE	;YES. WAIT FOR CH7 TO RELEASE IT
	  POPJ P,		;NO.  DON'T WORRY ABOUT IT.
	JRST BLKIO

;HERE IF NO ACTIVE BUFFERS
BLKIO2:	PUSHJ	P,INCBC		;SET UP FOR 1 MORE JOB. IF CAN'T,
	  POPJ	P,		;  NONSKIP-RETURN
	MOVSI	T1,LMLBIO	;SET FLAG IN THE LDB INDICATING
	IORM	T1,LDBMOD(U)	;PORT IS IN BIO MODE.
	AOS	(P)		;MADE IT!  SKIP RETURN TO USER
	POPJ	P,
SUBTTL	BLKXIO - HERE FROM THE LEAVE BLOCK MODE AUXCAL

BLKXIO:	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO	;IF PORT'S NOT IN BLOCK MODE,
	 POPJ	P,		;  JUST RETURN
	SKIPN	T3,LDBBIO(U)	;IF THERE'S NOTHING IN PROGRESS,
	 JRST	BIORES		;  GET OUT NOW
	HLRZ	T1,T3
	JUMPE	T1,BLKX1	;IF THERE'S OUTPUT IN PROGRESS,
	PUSHJ	P,OQUEUE	;  WAIT FOR IT. IF ZAPPED,
	  POPJ	P,		;    JUST RETURN
	JRST	BLKXIO

    ;HERE FROM BLKXIO AND BIOREL - TERMINATE/DISCARD CURRENT BLK INPUT

BLKX1:	HRRZ	T1,T3
	JUMPE	T1,BLKX2	;IF THERE'S INPUT IN PROGRESS,
	PUSHJ	P,BLKXIN	;  REQUEST INPUT TERMINATION
	HRRZ	T1,LDBBIO(U)
	SKIPL	BIOCHR(T1)	;  IF THE BASE IS DONE WITH THE BUFFER,
	 PUSHJ	P,RELBI		;    THROW IT AWAY NOW
BLKX2:	SKIPN	LDBBIO(U)	;IF NO BUFFERS,
	 PJRST	BIORES		;  GET OUT NOW
	MOVSI	T1,LMLBIO
	ANDCAM	T1,LDBMOD(U)	;ELSE, CLEAR THE BLOCK MODE BIT
	POPJ	P,		;  CH7 WILL DO THE REST

;BIOREL - HERE FROM RESET UUO FOR EACH PORT IN BLOCK MODE
;	   TERMINATE BLOCK INPUT AND OUTPUT

BIOREL:	SKIPN	T3,LDBBIO(U)	;IF NO ACTIVE I OR O,
	 PJRST	BIORES		;  GET OUT NOW
	HLRZ	T1,T3
	JUMPE	T1,BLKX1	;IF OUTPUT ACTIVE,
	PUSHJ	P,BLKXOT	;  REQUEST OUTPUT TERMINATION
	JRST	BLKX1
SUBTTL	BIOZAP - CALLED WHEN A CIRCUIT IN BLOCK MODE IS ZAPPED

BIOZAP:	MOVSI	T1,LMLTBI
	ANDCAM	T1,LDBMOD(U)	;CLEAR "TERMINATE PENDING" FLAG
	DPB	T1,LOPBOP	;Clear PTY "Block-output-in-progress"
	PUSHJ	P,RELBI		;MUST BE DONE WITH INPUT
	PUSHJ	P,RELBO		;MUST BE DONE WITH OUTPUT
	PFALL	BIORES		;MUST BE DONE WITH BLOCK I/O

;BIORES - CLEAR BLKIO BIT AND FLAG NEGOTIATOR THAT WE'RE DONE

BIORES:	MOVSI	T1,LMLBIO	;TAKE PORT OUT OF BLKIO MODE
	ANDCAM	T1,LDBMOD(U)	;
	PJRST	DECBC		;ONE FEWER PORT DOING BLOCK I/O
SUBTTL	 BLKINP - BLOCK INPUT-AND-WAIT AUXCAL

BLKINP:	PUSHJ	P,BIOCHK	; EVERYTHING OK?
	  POPJ	P,		; NO
	HRRZ	T1,LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	JUMPE	T1,[		; NO INPUT BUFFER
		TLNE	S,IOEND		; IOEND SET?
		 JRST	BLKEOF		; RETURN EOF
		MOVE	T2,LDBMOD(U)
		TLNE	T2,LMLTBI	; TERMINATE PENDING?
		 JRST	BLKIP1		; WAIT FOR IT
		PUSHJ	P,REQBUF	; GET BUF & REQ. INPUT
		  POPJ	P,		; FAILED (PORT ZAPPED)
		JRST	BLKIP1		; MADE REQ.: NOW WAIT
	]
	MOVE	T2,BIOCHR(T1)	; T2/ IN-PROGRESS FLAG,,COUNT
	JUMPL	T2,BLKIP1	; IN-PROGRESS: WAIT FOR IT
	PUSHJ	P,GOTBUF	; COMPLETE: TRANSFER DATA
	  JFCL			; COUNT=0
	JRST	CPOPJ1		; OR COUNT .gt. 0: SKIP-RETURN

    ; HERE TO WAIT FOR "BLOCK INPUT TERMINATED" MESSAGE
    ; OF SOME SORT

BLKIP1:	PUSHJ	P,IQUEUE
	  POPJ	P,		; PORT GONE
	JRST	BLKINP		; RETRY
SUBTTL	 BLKINS - BLOCK INPUT-AND-SKIP AUXCAL

BLKINS:	PUSHJ	P,BIOCHK	; EVERYTHING OK?
	  POPJ	P,		; NO
	HRRZ	T1,LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	JUMPE	T1,[		; NO INPUT BUFFER
		TLNE	S,IOEND		; IOEND SET?
		 JRST	BLKEOF		; RETURN EOF
		MOVE	T2,LDBMOD(U)
		TLNE	T2,LMLTBI	; TERMINATE PENDING?
		 POPJ	P,		; NONSKIP-RETURN
		PUSHJ	P,REQBUF	; GET BUF & REQ. INPUT
		  POPJ	P,		; FAILED (PORT ZAPPED)
		POPJ	P,		; MADE REQ.: NOW RETURN
	]
	MOVE	T2,BIOCHR(T1)	; T2/ IN-PROGRESS FLAG,,COUNT
	JUMPL	T2,CPOPJ	; IN-PROGRESS: NONSKIP-RETURN
	PUSHJ	P,GOTBUF	; INPUT COMPLETE: TRANSFER DATA
	  POPJ	P,		; COUNT=0: NONSKIP-RETURN
	JRST	CPOPJ1		; COUNT.gt.0: SKIP-RETURN

; BLKEOF - COMMON CODE TO SET IO.END
;	    FOR BLOCK INPUT AUXCALS

BLKEOF:	XOR	S,[IOEND,,IODEND]
	MOVEM	S,DEVIOS(F)	; SET IO.EOF, CLEAR IOEND
	AOS	(P)
	PJRST	RELBI		; DONE WITH INPUT BUFFER
SUBTTL	 BIOCHK - COMMON SETUP CODE FOR BLOCK INPUT AUXCALS

BIOCHK:	MOVE	T1,LDBMOD(U)
	TLNN	T1,LMLBIO	; BLOCK I/O ENABLED?
	 POPJ	P,		; NO -- FAIL
	TRNE	S,IODEND	; IO.EOF SET?
	 POPJ	P,		; YES -- FAIL
	PUSHJ	P,BPXOFF	; IS THIS NECESSARY?
	NOCHARGE		; TURN OFF THE CLOCK
	JRST	CPOPJ1		; SUCCEED

; GOTBUF - COMMON BUFFER-TRANSFER CODE FOR BLOCK INPUT AUXCALS
;	    ENTER WITH T1/ INPUT BUFFER ADDRESS
;		       T2/ CHARACTER COUNT

GOTBUF:
	PUSH	P,P1		;Needed in one irritating place
	PUSH	P,T2		; SAVE CHARACTER COUNT
	ADDM	T2,JBTBIO(J)	; CHARGE JOB FOR CHARACTERS
	ADDM	T2,JBTBIO	; RECORD TOTAL CHARACTERS
	ADDI	T2,3
	LSH	T2,-2		; T2/ # OF WORDS
	HRLI	T3,BIOCHR(T1)	; T3/ START OF MON DATA,,
	HRR	T3,M		; T3/ ",,START OF USER BUFFER
IFNKMC<
	ADDI	T2,(T3)		; T2/ STOP LOCATION
	XCTTU <BLT T3,(T2)>	; TRANSFER THE COUNT&DATA
>;END IFNKMC
IFKMC<
	;T2/# OF WORDS
	;T3/MONITOR BUFFER,,USER BUFFER
	PUSH	P,T1		;SAVE T1
	PUSH	P,T4		;TO HOLD DESTINATION BYTEPOINTER
	LSH	T2,1		;T2/# OF HALF WORDS
	HRRZ	T4,T3		;T4/0,,USER BUFFER
	HLRZ	T3,T3		;T3/0,,MONITOR BUFFER
	MOVE	T1,(T3)		;GET FIRST WORD FOR USER BUFFER
	XCT 4,[MOVEM T1,(T4)]	;PUT IT IN USER BUF
	ADDI	T4,1
	ADDI	T3,1
	HRLI	T3,(POINT 18,0)	;PACK HALFWORD BYTES INTO
	HRLI	T4,(POINT 16,0)	;	FULLWORD BYTES
GBXLUP:	ILDB	T1,T3		;GET MONITOR HALF WORD
	XCT	1,[IDPB T1,T4]	;PUT TWO BYTES IN USER BUF
	SOJG	T2,GBXLUP
	POP	P,T4		;RESTORE THEM REGISTERS
	POP	P,T1		;RESTORE T1
>;END IFKMC
	MOVE	T2,LDBMOD(U)
	TLNN	T2,LMLTBI	; TERMINATE-INPUT PENDING?
	TLNE	S,IOEND		; IOEND SET?
	 JRST	[
		PUSHJ	P,RELBI		; DONE WITH INPUT BUFFER
		JRST	GOTBF1		; GO FINISH UP
	]
	PUSHJ	P,KEPBI		; IF SOMEONE ELSE WANTS A BUFFER,
	  SKIPA			;By all means let 'em have it
	 JRST	GOTBF0		;No competition
	MOVE	P1,BIOREQ(T1)	;Save count in a safe place (!)
	PUSHJ	P,RELBI		;Give up the buffer/port
	PUSHJ	P,GETBI		;Get a new one
	  JRST	GOTBF1		;Not needed...
	MOVEM	P1,BIOREQ(T1)	;Set count in new buffer
GOTBF0:
	MOVE	T2,BIOREQ(T1)	; T2/ OLD REQUEST COUNT
	PUSHJ	P,BLKIRQ	; REQUEST INPUT
GOTBF1:	POP	P,T1		; T1/ COUNT BLT'ED
	POP	P,P1		;Remember him?
	JUMPN	T1,CPOPJ1	; SKIP IF .GT. 0
	POPJ	P,
SUBTTL	 REQBUF - ALLOCATE A BUFFER FOR BLOCK INPUT
;	    STORE ITS ADDRESS IN RH(LDBBIO(U))
;	    SAVE THE USER'S BYTE COUNT IN BIOREQ(RH(LDBBIO(U)))
;	    AND SEND AN INPUT REQUEST
;	    SKIP-RETURN NORMALLY
;	    NONSKIP-RETURN IF ZAPPED WHILE IN "EXTRA" WAIT

REQBUF:	PUSHJ	P,GETBI		; SET UP FOR BLOCK INPUT
	  POPJ	P,		; FAILED (ZAPPED)

	; SUCCEEDED: T1/ INPUT BUFFER ADDRESS

	XCTFU <HRRZ T2, (M)>	; T2/ USER'S BYTE COUNT
	CAILE	T2, ^D400
	MOVEI	T2, ^D400	; T2/ USER'S COUNT .MIN. 400
	MOVEM	T2, BIOREQ(T1)	; SAVE FOR READAHEAD CODE
	AOS	(P)		; PREPARE FOR SKIP-RETURN
	PJRST	BLKIRQ		; REQUEST INPUT

; BLKIRQ - REQUEST BLOCK INPUT
;	    ENTER WITH T1/ BUFFER ADDRESS
;		       T2/ CHARACTER COUNT

BLKIRQ:
IFCPU (KL),<
	MOVE	T3,CSUCNT##	;WHEN I/O STARTS, SWEEP NUMBER
				;MUST BE DIFFERENT THAN THIS.
	MOVEM	T3,BIOCSH(T1)>
	MOVE	T3,LDBMOD(U)
	TLNE	T3,LMLTBI	; TERMINATE PENDING?
	 STOPCD			; IMPOSSIBLE!
	HRROM	T2,BIOCHR(T1)	; IN-PROG := -1, COUNT := T2.RH
	MOVEI	T1,1
	DPB	T1,LOPBIN	;SET BLOCK INPUT
	DPB	T1,LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,
SUBTTL	BLKOUT - HERE FROM BLOCK OUTPUT AUXCAL.  SKIPS ON SUCCESS.

BLKOUT:	MOVE T1,LDBMOD(U)	;TEST TO SEE IF BLOCK I/O
	TLNN T1,LMLBIO		;MODE HAS BEEN SET.
	 POPJ P,		;ERROR RETURN IF NOT.
	NOCHARGE		;TURN OFF THE CLOCK.
	HLRZ T1,LDBBIO(U)	;IS THERE A BLOCK OUTPUT
	JUMPE T1,BLKOT1		; ALREADY IN PROGRESS?
	PUSHJ P,OQUEUE		;I/O WAIT OR INTERRUPT
	 POPJ P,		;NO.  ERROR RETURN TO THE USER.
	JRST BLKOUT		;MAKE SURE BUFFER WAS RELEASED.
BLKOT1:	PUSHJ	P, GETBO	;SET UP FOR BLOCK OUTPUT
	  POPJ	P,		;  ZAPPED
	XCTBU <HRRZ T2,(M)>	;GET USER'S WORD COUNT
	CAIG	T2,^D400	;IF < 0 OR > 400
	SKIPN	T2		;OR = 0
	 PJRST	RELBO		;  GET OUT AND ERROR-RETURN
	CAILE T2,^D80		;MIN. NO. OF CHARS FOR CHARGING
	 SKIPA T3,T2		;PURPOSES IS EIGHTY.
	MOVEI T3,^D80
	ADDM T3,JBTBIO(J)	;ADD TO BIO CHRS XFER'D FOR JOB.
	ADDM T3,JBTBIO		;ADD TO TOTAL BIO CHARS XFERRED.
	ADDI T2,3
	LSH T2,-2
	XCTBU <MOVSI T3,(M)>	;GET ADDRESS OF USER BUFFER
	HRRI T3,BIOCHR(T1)	;PREPARE FOR BLT TO MONITOR
IFNKMC<
	ADDI T2,BIOCHR(T1)	;ADD IN BASE LOC FOR XFER
	XCTFU <BLT T3,(T2)>	;BUFFER.
IFCPU (KL),<
	MOVE	T2,CSVCNT##	;MUST DO ONE VALIDATE BEFORE CAN START
	MOVEM	T2,BIOCSH(T1)>	;I/O.
>;END IFNKMC
IFKMC<
	;T2/# OF WORDS
	;T3/USER BUFFER,,MONITOR BUFFER
	PUSH	P,T4		;TO HOLD DESTINATION BYTEPOINTER
	LSH	T2,1		;T2/# OF HALF WORDS
	HRRZ	T4,T3		;T4/0,,MONITOR BUFFER
	HLRZ	T3,T3		;T3/0,,USER BUFFER
	XCT	4,[MOVE T1,(T3)]	;GET FIRST WORD OF USER BUFFER
	MOVEM	T1,(T4)		;PUT IT IN MON BUF
	ADDI T4,1
	ADDI T3,1
	HRLI	T3,(POINT 16,0)	;UNPACK FULLWORD BYTES INTO
	HRLI	T4,(POINT 18,0)	;		HALFWORD BYTES
XCTLUP:	XCT 1,[ILDB T1,T3]	;GET TW0 USER BYTES
	IDPB	T1,T4
	SOJG	T2,XCTLUP
	POP	P,T4		;RESTORE THEM REGISTERS
>;END IFKMC
	MOVEI T1,1
	DPB T1,LOPBOT		;SET BLOCK OUTPUT
	DPB T1,LDBOPB(U)	;AND NEED-OUTPUT
	JRST CPOPJ1		;AND SUCCESS-RETURN
COMMENT %

There are (presently) three block i/o mechanisms, one for
620 bases, one for PTYs, and one, as yet uncoded, for Nexilis
bases. For the sake of everyone's sanity, there must be a
level in the block i/o code at which the distinction between
these three becomes invisible.

In particular, the UUOs should use only the following routines,
which will acquire and release the appropriate resources
regardless of the mechanism being used:

	GETBI	sets up a port to do block input
	RELBI	called when a port's done with block input
	KEPBI	skips if it's ok for this port to keep
		its block-input resources; if it nonskips,
		caller should do a RELBI/GETBI sequence
	GETBO	sets up a port for block output
	RELBO	called when a port's done with block output
	INCBC	enables the block i/o mechanism for 1 more
		job (1 more PDP10 port), and skip-returns
		if 1 more is ok
	DECBC	called when a port is disabled for block i/o

%
SUBTTL	INCBC - CALLED WHEN 1 MORE PORT IS TO BE ENABLED FOR BLOCK I/O
;	  SKIP-RETURNS IF 1 MORE IS OK
;	  CALLED WITH U/ LDB ADDR, J/ JOB #

INCBC:	HLL	U, LDBDCH(U)
	TLNE	U, LDLPTY	;IF IT'S A PTY,
	JRST	INCPBC		;  THINGS ARE SIMPLER

    ;HERE FOR REAL TTYS

	NOCHARGE		;TURN OFF THE CLOCK.
IFCPU (<KI,KL>), <
	AOSE	AXREQ		;INC REQUEST COUNT FOR AUX QUEUE
	 PUSHJ	P,AXWAIT	;QUEUE JOB IF REQ IN PROGRESS
	AOS	BIOCNT+0	;INCREMENT COUNT OF BIO JOBS
	HRROS	BIOCNT+0	;FLAG FOR CH7 TO SEND REQUEST.
	MOVEM	J,BIOJOB	;BIOJOB_JOB NO W REQ IN PROGRESS
	MOVEI	T1,MLOWQ	;PLACE THIS JOB IN THE ML QUEUE
	DPB	T1,PJBSTS##	;AND WAIT UNTIL AN ANSWER IS
	PUSHJ	P,WSCHED	;RECEIVED FROM THE BASE.
	SKIPLE	BIOPRT		;IF THERE'S AT LEAST ONE SLOT,
	 AOS	(P)		;  SET TO SKIP-RETURN
	SOSL	AXREQ
	 SETOM	AXAVAL
	POPJ	P,
> ;END IFCPU (<KI,KL>)
IFNCPU (<KI,KL>), <
	AOS	BIOCNT		;ONE MORE BIO JOB
	SOSL	BPREQ		;AND ONE MORE BUFFER
	 SETOM	BPAVAL		;ACTIVATE JOB WAITING FOR A BUFFER
	JRST	CPOPJ1
> ;END IFNCPU (<KI,KL>)

    ;HERE FOR PTYS

INCPBC:	AOS	BIOCNT+1	;1 MORE BLOCK-MODE PTY
	JRST	CPOPJ1		;SKIP-RETURN
SUBTTL	DECBC - CALLED WHEN A PORT HAS BEEN DISABLED FOR BLOCK I/O
;	  AND ALL BLOCK I/O ACTIVITY FOR IT HAS STOPPED
;	  CALLED WITH U/ LDB ADDR

DECBC:	HLL	U,LDBDCH(U)
	TLNE	U,LDLPTY	;IF IT'S A PTY,
	 JRST	DECPBC		;  THINGS ARE A BIT EASIER

    ;HERE FOR A REAL TTY

	HRRE	T1,BIOCNT+0	;T1/ REAL TTY BLOCK I/O USER COUNT
	SOJGE	T1,.+2
	 STOPCD (CPOPJ,INFO,TTYBCN,,<Block I/O count negative>);;DECBC+5
IFCPU (<KI,KL>), <
	HRROM	T1,BIOCNT+0	;BIOCNT+0/ "CHANGED",,NEW COUNT
> ;END IFCPU (<KI,KL>)
IFNCPU (<KI,KL>), <
	MOVEM	T1,BIOCNT+0	;ONE LESS BIO JOB
	AOS	BPREQ		;ONE LESS BUFFER
> ;END IFNCPU (<KI,KL>)
	ADD	T1,BIOCNT+1	;T1/ TOTAL BLOCK USER COUNT
	JRST	DECBC1

    ;HERE FOR A PTY

DECPBC:	SOSGE	T1,BIOCNT+1	;T1/ PTY BLOCK USER COUNT
	 STOPCD (,XCT,TTYBCN)
	HRRE	T2,BIOCNT+0
	ADD	T1,T2		;T1/ TOTAL BLOCK USER COUNT
	PFALL	DECBC1

    ;HERE FOR EITHER - FREE UP UNNECESSARY BUFFERS

DECBC1:	ASH	T1,1		;T1/ MAX # OF BUFFERS NEEDED (2*PORTS)
	SUB	T1,BIOBUF	;T1/ -# OF UNNEEDED BUFFERS IN POOL
	PUSH	P,T1
DECBC2:	AOSLE	(P)
	JRST	DECBC3
	PUSHJ	P,GETBBP	;GET A BUFFER FROM THE BLOCK I/O POOL
	PUSHJ	P,RELBBF	;RELEASE IT TO FREECORE
	JRST	DECBC2
DECBC3:	POP	P,T1
	POPJ	P,
SUBTTL	GETBI - SET UP A PORT FOR BLOCK INPUT
;	  NONSKIP IF LEFT BLOCK MODE
;	  ELSE SKIP WITH T1 AND LDBBIO(U).RH SET TO BUFFER

GETBI:	PUSHJ	P,GETBIO
	  POPJ	P,
	HRRM	T1,LDBBIO(U)
	JRST	CPOPJ1

;GETBO - SET UP A PORT FOR BLOCK OUTPUT

GETBO:	PUSHJ	P,GETBIO
	  POPJ	P,
	HRLM	T1,LDBBIO(U)
	JRST	CPOPJ1

;RELBI - CALLED WHEN A PORT'S DONE WITH BLOCK INPUT
;	  RETURNS T1/ LDBBIO(U)

RELBI:	HRRZ	T1,LDBBIO(U)
	JUMPE	T1,RELB0
	HLLZS	LDBBIO(U)
	PJRST	RELBIO

;RELBO - CALLED WHEN A PORT'S DONE WITH BLOCK OUTPUT
;	  RETURNS T1/ LDBBIO(U)

RELBO:	HLRZ	T1,LDBBIO(U)
	JUMPE	T1,RELB0
	HRRZS	LDBBIO(U)
	PJRST	RELBIO

RELB0:	MOVE	T1,LDBBIO(U)
	POPJ	P,
SUBTTL	KEPBI - SKIP-RETURNS IF IT'S OK FOR THIS PORT (U/ LDB ADDRESS)
;	  TO KEEP ITS BLOCK INPUT RESOURCES, NONSKIPS IF
;	  SOMEBODY ELSE WANTS THEM

KEPBI:	PUSH	P,T1
	MOVSI	T1,LDLPTY
	TDNE	T1,LDBDCH(U)	;IF IT'S NOT A PTY
	 JRST	KEPBI1
	MOVE	T1,LDBBIO(U)
	SKIPLE	BPREQ		;AND SOMEONE'S WAITING FOR PORTS
	 TLNE	T1,777777	;AND WE CAN FREE ONE,
KEPBI1:	SKIPLE	FCREQ		;OR IF SOMEONE'S WAITING FOR FREECORE,
	 JRST	.+2		;  DON'T SKIP
	AOS	-1(P)
	POP	P,T1
	POPJ	P,
SUBTTL	GETBIO - GET A BLOCK I/O BUFFER FOR LINE
;	   NONSKIP-RETURN IF PORT LEFT BIO MODE WHILE WAITING
;	   SKIP-RETURN WITH T1/ THE BUFFER ADDRESS OTHERWISE

GETBIO:	MOVSI	T1,LNLZIN	;Was a zapper seen on this line?
	TDNE	T1,LDBLIN(U)	; ...
	 POPJ	P,		;Pretend there are no more buffers for now
	MOVSI	T1,LDLPTY
	TDNN	T1,LDBDCH(U)	;IF IT'S NOT A PTY
	SKIPE	LDBBIO(U)	;AND THERE'S NO BLOCK I/O IN PROGRESS,
	 JRST	GTBIO1
	AOSLE	BPREQ
	PUSHJ	P,BPWAIT	;  GET A BASE PORT
GTBIO1:	PUSHJ	P,GETBB		;T1/ BUFFER ADDRESS
IFCPU (KL),<;P035/D05 - make sure page containing buffer is uncached.
	PUSH	P,T1		;Save pointer
	HRLI	T1,BIOCOR	;Size of buffer in LH
	PUSHJ	P,CSHCLR##	;Clear cache bit in EPT
	POP	P,T1
>
	MOVE	T2,LDBMOD(U)
	TLNE	T2,LMLBIO	;IF PORT'S STILL IN BLOCK MODE,
	 JRST	CPOPJ1		;  SKIP-RETURN
	PFALL	RELBIO

;RELBIO - RELEASE A BLOCK I/O BUFFER FOR U
;	   CALLED WITH T1/ THE BUFFER ADDRESS
;	   FREES THE PORT IF NO BUFFERS REMAIN
;	   RETURNS T1/ LDBBIO(U)

RELBIO:	PUSHJ	P,RELBB		;FREE THE BUFFER
	MOVSI	T1,LDLPTY
	TDNE	T1,LDBDCH(U)	;IF IT'S NOT A PTY
	 JRST	RLBIO1
	SKIPN	T1,LDBBIO(U)	;AND NO BLOCK I OR O IN PROGRESS,
	SOSL	BPREQ		;  FREE THE BASE PORT
	 SETOM	BPAVAL
	POPJ	P,

RLBIO1:	MOVE	T1, LDBBIO(U)	;T1/ LDBBIO
	POPJ	P,
SUBTTL	GETBB - GET A BLOCK I/O BUFFER AND RETURN ITS ADDRESS IN T1
;GETBBP - GET ONE FROM THE POOL (NOT FREECORE) OR CRASH

GETBB:	SKIPE	BBFREE		;IF NO FREE BLOCK BUFFERS,
	 JRST	GETBB1
	MOVEI	T2,BIOCOR
	SKIPGE	FCREQ		;  GET ANOTHER. IF OTHER JOBS IN FC WAIT
	 PUSHJ	P,GET4WD	;  OR NO FREE CORE,
	  JRST	[
		AOS  FCREQ
		PUSHJ P,FCWAIT
		SOS  FCREQ
		JRST GETBB	;    WAIT, THEN TRY AGAIN
	]
IFKMC<
	PUSH	P,T1		;SAVE UNMAPPED T1
	PUSHJ	P,SCANBB	;RETURNS T2 WITH UBA PAGE # OF T1
	  JRST [CAILE T2,UBAEND-<UBABIO&777> ;GUESS WE DIDN'T MATCH. ANY ROOM LEFT?
		 STOPCD 	;GIVE UP IF NO ROOM.
		HRLI T2,3	;T2/3,,AVAILABLE PAGE #
		LSH T1,-9	;T1/HIGH 11 BITS OF MAPPED ADDRESS
		TRO T1,1B21	;SET VALID BIT
		WRIO T1,UBABIO(T2)
		MOVEM T1,BBPAGE(T2)
		ADDI T1,1	;ALSO INIT NEXT PAGE
		WRIO T1,UBABIO+1(T2)
		MOVEM T1,BBPAGE+1(T2)
		HRRZ T2,T2	;T2/0,,PAGE #
		AOS  BBCRE	;;;COUNT BIO BUFFERS CREATED
		JRST .+1]	;CONTINUE
	LSH	T2,-1		;T2/PAGE PAIR #
	AOS	BBCNTS(T2)	;BUMP THE USE COUNT
	POP	P,T1		;RESTORE UNMAPPED T1
>;END IFKMC
	AOS	BIOBUF		;  1 MORE BUFFER IN POOL
	POPJ	P,		;  RETURN THE BUFFER

    ;HERE IF THERE ARE FREE BUFFERS IN THE BLOCK I/O POOL

GETBBP:	SKIPN	BBFREE
TTYNFB:: STOPCD (.,STOP,TTYNFB,,<No Free Buffrers>)     ;;GETBBP+1
GETBB1:	SOS	BBFREE
	AOS	BBPOOL		;COUNT USE OF FREE BIO BUFFERS
	HRRZ	T1,BUFLST
	SKIPN	T1
	 STOPCD (,XCT,TTYNFB)   ;No Free Buffers        ;;GETBB1+5
	HRRZ	T2,(T1)
	HRRM	T2,BUFLST	;MAKE NEXT-LINK THE NEW HEADER
	POPJ	P,

;RELBB - RELEASE THE BLOCK I/O BUFFER POINTED TO BY T1
;RELBBF - ALWAYS RETURN IT TO FREECORE

RELBB:	SKIPGE	FCREQ		;IF OTHER JOBS ARE WAITING FOR FREECORE,
	 JRST	RELBB1
RELBBF:	SKIPN	T2,T1
	 STOPCD
	SOS	BIOBUF
	MOVEI	T1, BIOCOR
IFKMC<	PUSHJ P,RELKMC>		;RELEASE UBA SLOT
	PJRST	GIV4WD		;  JUST RELEASE THE BUFFER

    ;HERE TO ADD THE BUFFER TO THE BLOCK I/O POOL

RELBB1:	SKIPN	T1
	 STOPCD
	HRRZ	T2,BUFLST	;T2/ HEAD OF FREE CHAIN
	MOVEM	T2,(T1)
	MOVEM	T1,BUFLST	;MAKE T1 THE NEW HEAD
	AOS	BBFREE
	POPJ	P,

IFKMC<
RELKMC:	PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;SAVE UNMAPPED T2
	MOVE	T1,T2		;T1/BUFFER ADDRESS
	PUSHJ	P,SCANBB	;RETURNS T2 WITH UBA PAGE # OF T1
	  STOPCD		;NO MATCH IS BAD NEWS!
	LSH	T2,-1		;T2/PAGE PAIR NUMBER
	SOSN	BBCNTS(T2)	;DEC PAGE PAIR USE COUNT
	 JRST  [LSH T2,1	;;IF COUNT WENT TO 0 RESTORE T2 &
		SETZ T1,	;;INVALIDATE THE PAGE PAIR
		HRLI T2,3	;;UBA #3,,EVEN PAGE #
		WRIO T1,UBABIO(T2)
		WRIO T1,UBABIO+1(T2)
		HRROS BBPAGE(T2)	;;;;DEBUG
		HRROS BBPAGE+1(T2)	;;;;DEBUG CODE
		AOS BBREL		;;;;INFO
		JRST .+1]
	POP	P,T2		;RESTORE UNMAPPED T2
	POP	P,T1		;RESTORE T1
	POPJ	P,		;RETURN


;RETURNS T1 MAPPED
;SKIP RETURNS WHEN T2/0,,MATCHED UBA PAGE
;NON-SKIP RETURNS WITH T2/0,,-1 OR T2/0,,AVAILABLE UBA PAGE #
SCANBB:	MAP	T1,(T1)
	PUSH	P,T1		;SAVE MAPPED T1 FOR RETURN
	PUSH	P,T3
	PUSH	P,T4
	AND	T1,[3777B26]	;MASK OUT ALL BUT HIGH 11 BITS
	TLO	T1,(1B8)	;SET VALID BIT
	MOVEI	T4,-1		;T4/0,,-1
	HRLZI	T2,3		;T2/3,,0
SBBLUP:	RDIO	T3,UBABIO(T2)	;T3/EVEN PAGE # CONTENTS
	AND T3,[<1B8!3777B26>]	;MASK OUT ALL BUT VALID BIT & HIGH 11
	CAMN	T1,T3		;DOES IT MATCH?
	 JRST  [POP P,T4	;IF IT DOES THEN SKIP RETURN
		POP P,T3
		POP P,T1	;RESTORE MAPPED T1
		HRRZ T2,T2	;T2/0,,MATCHED PAGE #
		JRST CPOPJ1	;DO SKIP RETURN
		]
	TLZN	T3,(1B8)	;IS THE VALID BIT ON?
	 MOVEI	T4,(T2)		;T4/0,,LATEST AVAILABLE PAGE #
	ADDI	T2,2		;T2/3,,NEXT PAGE PAIR
	CAMGE	T2,[3,,UBAEND-<UBABIO&777>]	;ARE WE STILL LESS THAN 30?
	 JRST	SBBLUP		;IF SO GO BACK TO SBB LOOP
	MOVE	T2,T4		;T2/0,,-1 OR 0,,AVAILABLE SLOT NUMBER
	POP	P,T4
	POP	P,T3
	POP	P,T1		;RESTORE MAPPED T1
	POPJ	P,		;NON-SKIP RETURN


;MISC KMC RELATED ROUTINES


SCNMIN: PUSHJ	P,MDRUP		;T1/ FLAG DRs WE THINK ARE UP
	MOVEM	T1,DRMBRK	;FLAG TO SEND DR PILLS
	POPJ	P,

SCNDRD:			;WILL SKIP A MINUTE WHEN KMCRES IS CALLED
	SKIPE	T1,DRDOW
	 JRST	SCNMI2		;SET DRMHSI ON 2ND MINUTE
	PUSHJ	P,KMCRST##	;T1/ DOWN DR BITS
	PUSHJ	P,DRFLAG	;T1/ 3-BIT DR NUMBERS NEEDING TYPHSI MSG
	MOVEM	T1,DRDOW	;START DELAY FOR 41 TO NODE(S)
	MOVEI	T1,^D60
	MOVEM	T1,TIMDRD
	POPJ	P,
SCNMI2:	MOVEM	T1,DRMHSI	;SET DRMHSI FLAG WITH DOWN DR NUMBERS
	SETZM	DRDOW		;CLEAR DRDOW
	POPJ	P,		;ACTUAL MESSAGES GET SENT FROM SNDHSI

SNDHSI:	SKIPN	T1,DRMHSI	;T1/DOWN DR NUMBERS
	 JRST	MDRSHT		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMHSI
	MOVSI	P3,TYPI TYPHSI
	PUSHJ	P,MDRMSG	;SEND TO ALL DR NUMs IN T1
	JUMPN	T1,[		;IF NO ROOM IN THE RING TO FINISH THEN
		MOVEM T1,DRMHSI ; SET DRMHSI TO DO THE REST NEXT TIME
		POPJ	P,]   	; AND NON-SKIP RETURN
MDRSHT:	SKIPN	T1,DRMSHT	;T1/DRs THAT NEED A SHUT MESSAGE
	  JRST	MDRBRK		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMSHT
	MOVSI	P3,TYPI TYPSHT
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMSHT	; SET DRMSHT TO DO THE REST NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRBRK:	SKIPN	T1,DRMBRK	;T1/DRs THAT NEED A 57 PILL
	  JRST	MDRCLP		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMBRK
	MOVSI	P3,TYPI TYPBRK	;WE USE A 51 "BRK" MSG FOR THE PILL
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMBRK	; SET DRMBRK TO DO THE REST NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRCLP:	SKIPN	T1,DRMCLP	;T1/DRs THAT NEED A CLOCK REQ MSG
	  JRST	MDRANS		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMCLP
	MOVSI	P3,TYPI TYPCLP
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMCLP	; SET DRMCLP TO DO THE REST NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRANS:	SKIPN	T1,DRMANS	;T1/DRs TO SEND AN ANSWERED MSG TO
	  JRST	MDRNXT		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMANS
	MOVSI	P3,TYPI TYPANS
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMANS	; SET UP FOR NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRNXT:	
	MOVE	T1,DRMTIM	;;;;;;;START KMC DEBUG CODE
	SUBI	T1,1
	JUMPE	T1,CPOPJ1	;IGNORE FOR THE FIRST SECOND
	PUSHJ	P,KMCGAV##
	MOVE	T2,T1
	ANDI	T2,377
	LSH	T2,8
	PUSHJ	P,KMCGAC##
	ANDI	T1,377
	IOR	T1,T2
	CAMN	T1,KMCLAS	;SAME AS LAST TIME?
	 JRST	CPOPJ1		;YES, BYE...
	MOVEM	T1,KMCLAS
	HRL	T1,DRMTIM
	MOVE	T2,KMCPDP
	MOVEM	T1,KMCFLG(T2)
	ADDI	T2,1
	ANDI	T2,77
	MOVEM	T2,KMCPDP	;;;;;;;;END KMC DEBUG CODE
	JRST	CPOPJ1	;END OF MDR CHAIN FOR NOW. SKIP RET

MDRMSG:	;MSG TO ALL UP DRs	;P3/ MOVSI P3,TYPI TYPmsg
	;T1/ 3-BIT UP DR NUMBERS;RET:T1/0 or DRs NOT SENT TO
;;;;;;;	MOVE	T2,SYSNUM##	;PUT THE SYSNUM IN THE MESSAGES JUST
	MOVE	T2,DRMTIM	;USE UP TIME FOR NOW
;;;;;;;	ANDI	T2,377		;INCASE THE NODE WANTS IT IN THE FUTURE
	ANDI	T2,1777		;SHOW 10 BITS FOR NOW
	LSH	T2,8		; OFCOURSE WE CAN ONLY SEND 8 BITS OF IT
	ANDCM	P3,[377,,-1]	;LEAVE ONLY MESSAGE TYPE IN BITS 2-9
	IOR	T2,P3		;T2 HOLDS THE MESSAGE
MDRLUP:	SKIPN	P3,T1
	 JRST	CPOPJ		;RETURN WHEN T1=0
	ANDI	P3,3		;ISOLATE A DR NUMBER
	JUMPE	P3,MDRL1	;IF IT'S 0 GO TRY THE NEXT ONE
	SUBI	P3,1		;1-4 GOES TO 0-3
	CAILE	P3,MAXDR	;P3 MUST BE .LE. PORTS/LINES PER DR
	 JRST	MDRL1
	LSH	P3,6		;MAKE IT A PORT NUMBER
	IORI	P3,LPERDR&77	;P3/(DRNUM*100) ! LINES PER DR
	CAILE	P3,<MAXDR*100>!<PORTN##-<MAXDR*LPERDR>>
	 JRST	[ANDCMI P3,77
		IORI	P3,PORTN##-<MAXDR*LPERDR>
		JRST	.+1]
	ANDCMI	P3,3		;MUST BE A MULTIPLE OF 4
	HRL	P3,P3		;P3/MAX PORT NUM,,MAX PORT NUM
	ANDCMI	P3,77		;P3/MAX PORT NUM,,DR NUM
	HLRZ	T3,T2		;TEST FOR TYPHSI
	CAIE	T3,TYPI TYPHSI	;TYPHSI USES MAX PORT,,DRNUM
	 HRLZ	P3,P3		;TYPE A MESSAGES DON'T USE MAX PORT
	IOR	P3,T2		;OR IN THE MESSAGE AND SYS NUMBER
	PUSH	P,T1
	PUSH	P,T2
	PUSHJ	P,CLSCHR	;MAKE SURE THE RING IS READY
	  JRST MDRRET		;IF NOT DO A NON-SKIP RETURN
	PUSHJ	P,WRDOUT	;PUT THE MESSAGE IN THE RING
	  JRST MDRRET		;THIS SHOULDN'T HAPPEN!
	POP	P,T2
	POP	P,T1
	HLRZ	T3,T2		;TEST FOR TYPHSI
	CAIE	T3,TYPI TYPHSI
	 JRST	MDRL1		;IF NOT HSI THEN SKIP TO MDRL1
	MOVE	T3,T1
	ANDI	T3,3
	SUBI	T3,1
	SETOM	SENT41(T3)	;FLAG THAT WE SENT A 41 TO THAT DR
MDRL1:	LSH	T1,-3		;THROW OUT 3-BIT DR NUM JUST PROCESSED
	JRST	MDRLUP		;GO DO THE NEXT ONE
MDRRET:	POP	P,T2
	POP	P,T1
	JRST	CPOPJ

DR1BIT==1B35
DR2BIT==1B34
DR3BIT==1B31
DR4BIT==1B28

MDRUP:	PUSHJ	P,KMCGUP##
DRFLAG: HRLZ	T1,T1		;MOVE FLAGS TO LEFT HALF
	TLZE	T1,DR1BIT	;TEST AND CLEAR THE FIRST FLAG
	 IORI	T1,0001		;IF A DRs FLAG IS SET PUT ONE PLUS IT'S
	TLZE	T1,DR2BIT	;    NUMBER IN A 3-BIT OCTAL DIGIT SLOT
	 IORI	T1,0020
	TLZE	T1,DR3BIT
	 IORI	T1,0300
	TLZE	T1,DR4BIT
	 IORI	T1,4000
	HRRZ	T1,T1		;T1/ 0,,3-BIT DR NUMBERS FLAGGED
	POPJ	P,		;RETURN
>;END IFKMC

;BASVER definitions: BYTE(8)TYPE,FLAGS,VERSION,RELEASE
	BV.DBG==<BYTE(8)0,001,0,0>	;Debugging if lsb of 2nd byte set
	BV.HDN==<BYTE(8)0,200,0,0>	;EBUS says host was down (we went away)
RCVRAK:	MOVE	T1,IRING(P4)	;TYPRAK=4 - Reset Acknowlege
	MOVEM	T1,BASVER##	;Store BYTE(8)CODE,DEBUG,VERSION,RELEASE
BASEOK:: STOPCD (.+1,EVENT,BASEOK,PRTBVR,<Base is up>)
	AOJA	P4,SCNIN1

IFCPU (<KI,KL>),<
PRTBVR:	PUSHJ	P,INLMES##	;Called from STOPCD(BASEOK)
	 ASCIZ /Code in base is version /
	LDB	T1,[POINT 8,BASVER,23]
	PUSHJ	P,PRTDEC##
	PUSHJ	P,PRPER##	;Period
	LDB	T1,[POINT 8,BASVER,31]
	PUSHJ	P,PRT2##	;2 decimal digits
;	PUSHJ	P,INLMES##
;	 ASCIZ / - debug flag is /
;	MOVEI	T1,[ASCIZ /OFF/]
;	MOVSI	T2,(BV.DBG)
;	TDNE	T2,BASVER	;Is it set?
;	 MOVEI	T1,[ASCIZ /ON/]	;Yes
;	PUSHJ	P,CONMES##	;STOPCD processor will provide CRLF
	POPJ	P,
>
IFNCPU(<KI,KL>),<PRTBVR==CPOPJ##> ;PDP-11 bases do not report version #

IFNKMC<				;TYPRES=3 - Reset interface
RCVRES:	SETOM	BASDWN##	;Set flag to call DETALL and send TYPRAK
	MOVE	T1,IRING(P4)	;Get the message
	EXCH	T1,BASVER##	;Store BYTE(8)CODE,DEBUG,VERSION,RELEASE
	CAME	T1,BASVER##	;Don't mumble about 2 in a row
	 STOPCD	(,XCT,BASEOK)	;Print "base is up" message
	PUSHJ	P,DETALL	;Detach all ports
	LDB	T1,[POINT 16,BASVER,31];Get 3rd and 4th bytes
	CAILE	T1,<02_^D8>+00	;Is it version 02.00 ?
	 AOJA	P4,SCNIN1	;No, done
	SETZM	IRPPDP		;Yes, EBUS has set IRP620 to zero
	SETZM	ORPPDP		; and ORP620 to zero
	POPJ	P,		;Return from SCNTIC - no more to do
>  ;End IFNKMC

IFKMC<		;Here when KMC detects problem with a DR11C
RCVRES:	SETZM	BASVER##	;Store BYTE(8)0,0,0,0 instead of EBUS version
	MOVEI	T1,^D60
	MOVEM	T1,TIMDRD	;RESET KMC CHECKUP TIMER
	MOVE	T1,DRMTIM ;;;;;;;TEMP STUFF UP TIME IN IRING 3 MSG
	DPB	T1,INPDL2 ;;;;;;;  "    "    "   "   "   "   "  "
	LDB	U,INPLIN
	ANDI	U,300		;U/FIRST PORT NUMBER OF FAILING DR
	CAILE	U,PORTN##	;THIS TEST WORKS ONLY WHEN LPERDR=^D64
	 AOJA	P4,SCNIN1	;IGNORE BAD PORT NUMBERS
	MOVE	T1,U
	LSH	T1,-6		;T1/DR NUMBER
	SETZM	SENT41(T1)	;RESET "WAITING FOR RESPONSE TO 41"
	PUSHJ	P,KMCCAC##	;CLEAR DR'S ACTIVE BIT & UP BIT
DRZAP:	PUSHJ	P,DETONE	;Detach one port on this particular DR11
	ADDI	U,1
	MOVE	T1,U
	ANDI	T1,LPERDR-1	;ONE OF 77, 37, or 17
	CAIG	U,PORTN##	;THIS TEST ONLY WORKS FOR LPERDR=64.
	 JUMPN	T1,DRZAP	;GO DO THE NEXT PORT
	AOJA	P4,SCNIN1	;EXIT
>;END IFKMC

;DETALL - Mark all lines as being detached

DETALL:	MOVEI	U,RPORTN##	;Do all real ports (not PTY ports)
	PUSHJ	P,DETONE	;Detach one
	SOJG	U,.-1		;Loop for all
	PJRST	SETSHT		;Set UPSHUT to the right value

;DETONE - Mark one line as being detached, port number in U preserved

DETONE:	PUSH	P,U		;SAVE U
	MOVE	U,LINTAB(U)	;U/ PORT LDB
	HLL	U,LDBDCH(U)	;U/DEVICE CHARARTERISTICS,,PORT LDB
	SKIPL	LDBLOG(U)	;SKIP IF PORT NOT LOGGED IN
	 JRST	DETON1
	PUSHJ	P,FRCZAP	;ZAP THE PORT
	PUSHJ	P,CLRTTY	;CANCEL THE "SEND ZAPPER" FLAG
DETON1:	POP	P,U		;RESTORE PORT NUMBER
	POPJ	P,

RCVANS:				;CALLED WHEN KMC/DR RESPONDS TO A 41 WE SENT IT
IFNKMC<	MOVE	T1,IRING(P4)	;Get the message
	EXCH	T1,BASVER##	;Store BYTE(8)CODE,DEBUG,VERSION,RELEASE
	CAME	T1,BASVER##	;Don't mumble about 2 in a row
	 STOPCD	(,XCT,BASEOK)	;Print "base is up" message
	AOJA	P4,SCNIN1>	;IGNORE ANS MESSAGE ON KI/KL/F3
IFKMC<	MOVE	T1,DRMTIM ;;;;;;;TEMP PUT TIME IN IRING 1 MSG
	DPB	T1,INPDL2 ;;;;;;;  "   "    "   "   "   "  "
	LDB	T1,INPLIN	;T1/ PORT LDB
	LSH	T1,-6		;T1/DR NUMBER
	SKIPN	SENT41(T1)	;DON'T SET ANSWERED BIT UNLESS WE SENT 41
	 AOJA	P4,SCNIN1
	SETZM	SENT41(T1)	;RESET "WAITING FOR RESPONSE TO 41"
	PUSH	P,T1
	PUSHJ	P,KMCSUP##	;SET DR'S ANSWERED BIT
	POP	P,T1
	ANDI	T1,3
	ADDI	T1,1
	MOVE	T2,DRMCLP
	LSH	T2,3
	IOR	T2,T1
	MOVEM	T2,DRMCLP
	MOVEI	T2,STSHUT	;400000
	TDNE	T2,STATES	;ARE WE SHUT?
	 JRST	KMCSHT		;YES, GO SET UP DRMSHT
	MOVE	T2,DRMANS	;NO, SET UP DRMANS INSTEAD
	LSH	T2,3
	IOR	T2,T1
	MOVEM	T2,DRMANS
	AOJA	P4,SCNIN1	;EXIT
KMCSHT:	MOVE	T2,DRMSHT
	LSH	T2,3
	IOR	T2,T1
	MOVEM	T2,DRMSHT
	AOJA	P4,SCNIN1
>;END IFKMC
SUBTTL	Variables used by TYMSER

CTYBLF::EXP 0	;0,,-1 to ding next second, -1,,-1 to ding this tick
OPRTIC::EXP 0	;Number of ticks before OPRCTY is allowed to continue

BUFLST:	0	;HEADER FOR LIST OF BLOCK INPUT/OUTPUT BUFFERS
BIOCNT:	0	;REAL TTYS: # OF JOBS ENABLED TO DO BLOCK I/O
		;	    LH := -1 AS A FLAG TO BLKNEG CODE
	0	;PTYS: # OF JOBS ENABLED TO DO PSEUDO-BLOCK I/O
BIOPRT: 0	;# OF BLOCK I/O PORTS, I.E., THE LAST RESPONSE
		;FROM THE BASE TO A NEGOTIATE MESSAGE
BIOBUF: 0	;# OF MONITOR BLOCK I/O BUFFERS
BBFREE:	0	;# OF FREE MONITOR BLOCK I/O BUFFERS
BBCRE:	0	;# OF BIO BUFFERS CREATED SINCE MONITOR LOADED (KS ONLY)
BBREL:	0	;# OF BIO BUFFERS RELEASED (KS ONLY)
BBPOOL:	0	;COUNT OF BIO BUFFER RE-USE SINCE MONITOR LOADED
BIOANS: 0	;# OF BLOCK I/O NEGOTIATE MESSAGES SENT BUT NOT
		;YET REPLIED-TO
ERRBNG: 0	;# OF UNSOLICITED BLOCK I/O NEGOTIATE MESSAGES
IRPSTP:	0	;Stopping place for SCNIN
BADKEY:	0	;Copy of KEY620 when base wants to crash us
IRPOLD:	0	;Old copy of IRP620 when base is declared down
ORPOLD:	0	;            ORP620
RCC.LO:	0	;Lowest legal chunk address
RCC.HI:	0	;One greater than highest legal chunk address
TTYLOS:	0	;COUNT OF LOST BUFFERS (BLACK BALLS)
PTYLOS:	0	;COUNT OF CHARACTERS LOST BY PTYS
LOGZAP:	0	;# OF LOGINS TO LOGGED-IN PORTS
ZAPLPT:	-1	;PORT LDB ADDRESS OF LAST LOGZAP OR DFRZAP
DFRZAP:	0	;# OF LDECS RECEIVED WHILE STILL ECHOING
NZAPIN: 0	;# ZAPPERS IN FROM TYMNET
NZAPN2: 0	;# TIMES WE GOT A ZAPPER ON A PORT W/ AN UNECHOED ZAP
NZAPLG: 0	;# TIMES WE GOT A LOGIN ON A PORT W/ AN UNECHOED ZAP
NZAPAX: 0	;# TIMES WE GOT AN AUX PORT FOR A PORT W/ AN UNECHOED ZAP
NZAPRS: 0	;# of times zapper had to be resent (based on LNLZIN)
NZAPOT: 0	;# ZAPPERS OUT IN RESPONSE TO ZAPPERS IN
TMCOOR: 0	;# OF UNKNOWN TERMINAL CHARACTERISTICS SET BY TYMNET
;This file must be assembled with TYMSER.MAC+TTYSYM.MAC+SCNSER.MAC

   n'sa8