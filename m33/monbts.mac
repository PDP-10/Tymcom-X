TITLE	MONBTS - Monitor resident BOOTStrap

	STOPCD(,ENTRY,MONBTS)

PRINTF(<[Need to implement BUGDMP for CRASH.EXE]>)
BUGDMP::PUSHJ	P,INLMES##	;Dump core into SYS:CRASH.EXE
	 ASCIZ /
BUGDMP - No crash dump for this stopcode
/
	POPJ	P,		;Return to DIE in ERRCON

REBOOT:	PUSHJ	P,BUGDMP	;Dump core into SYS:CRASH.EXE
	JRST	NEWMON		;Reload the monitor
SUBTTL	Load BOOTS from the disk

IFCPU(<KS,F3>),<EXTERN UPT.PN,EPT.PN	;Here from a 146 restart
BOTLOD::SYSPIF			;Turn off PI system
	WRUBR	[LG.LAB+LG.LUB+0B8+0B11+400000+UPT.PN];Select AC block 0
	WREBR	EPT.PN		;Turn off paging (bit 22 is off)
	SETZM	BTSTR##		;Flag to not do /D
IFCPU (F3),<TNCONO 0>		;Reset interface to node
IFCPU (F3),<DATAO PI,[-1]>	;Turn on all the lights
IFNCPU(KS),<WRADB [0]>		;Clear address break
	MOVE	P,.CPEPD##	;Reset stack
	PFALL	NEWMON
> ;END IFCPU(<KS,F3>)

	BOOTS=:1000000-3000	;BOOTS resides in the top 3 pages of core

NEWMON::MOVEI	F,BOOTS		;Load BOOTS into pages 775,776,777
	HRRM	F,BOOTCL	; ...

IFCPU(<KI,KL>),<;LOOK FOR BOOTS ON 3330 DRIVES.
	MOVSI	J,-7		;INIT CHANNEL COUNTER
BPBR0:	SETZ	W,		;INITIAL DEVICE
BPBR2:	MOVE	PG,BTADR	;<# OF WORDS,,DISK PAGE ADDR> FOR BOOTS
	HRRZ	F,BOOTCL	;BOOTS CORE ADDRESS (as set up by CRSDEV)
	PUSHJ	P,SAXPRD	;PROCURE BOOTS
	 JRST	BPBR		;COULD NOT GET IT
	JSP	T4,ISBOOT	;HAS BOOTS BEEN LOADED?
BPBR:	MOVEI	W,1(M)		;NO: INCREMENT DEVICE COUNTER
	CAIG	W,77		;HAS MAXIMUM BEEN REACHED?
	 JRST	BPBR2		;NO: TRY NEXT UNIT
	AOBJN	J,BPBR0		;CONTINUE IF MORE CHANNELS TO TRY
	JRST	BOTLOD##	;Try the paper-tape/DECtape routine, BOTLOD.MAC
> ;END IFCPU(<KI,KL>)

IFCPU (<KS,F3>),<;READ BOOTS FROM KS OR F3 UNITS
	MOVSI	W,-8		;INIT UNIT COUNTER
RMXPBT:	MOVE	PG,BTADR	;<# OF WORDS,,DISK PAGE ADDR> FOR BOOTS
	HRRZ	F,BOOTCL	;BOOTS CORE ADDRESS (as set up by BTPREP)
IFCPU(F3),<PUSHJ P,APXPRD>
IFCPU(KS),<PUSHJ P,RMXPRD>
	  SKIPA			;FAILED
	JSP	T4,ISBOOT	;GOT SOMETHING, SEE IF BOOTS
	AOBJN	W,RMXPBT	;NOT BOOTS, TRY NEXT UNIT IF ONE
IFCPU (KS),<
	MOVSI	W,-8		;Try alternate location
RMXBT1:	MOVE	PG,[1600,,11]	;Location of KS boots prior to P034/P20
	HRRZ	F,BOOTCL	;Core address
	PUSHJ	P,RMXPRD
	  SKIPA			;Not there either
	JSP	T4,ISBOOT	;Double check
	AOBJN	W,RMXBT1
> ;END IFCPU(KS)
NOBOOT:	MOVEI	T1,[ASCIZ / ?Can't read BOOTS!! /]
	PUSHJ	P,CTYTYP##	;Type out message
	HALT	BOTLOD		;Can't find BOOTS anywhere
> ;END IFCPU(<KS,F3>)

ISBOOT:	HRRZ	T2,BOOTCL	;GET BOOTS STARTING ADDR
	MOVE	T3,(T2)		;GET FIRST WORD OF BOOTS
	CAME	T3,BOOTFI	;IS IT CORRECT?
	 JRST	(T4)		;NO: RETURN
	MOVEI	T1,[ASCIZ /
"BOOTS loaded"
  /]
	PUSHJ	P,CTYTYP##	;TYPE "BOOTS LOADED"
	MOVEI	1,BTSTR##	;GET ADDR OF BOOTS COMMAND STRING
	HRRZ	2,BOOTCL	;GET BOOTS STARTING ADDR
	JRST	5(2)		;PASS CONTROL TO BOOTS

BCDSZ==3000-200			;SIZE OF BOOTS CODE (was 7 blocks)
BCDSSZ==BCDSZ+200		;SIZE OF BOOTS + SAX SAVE AREA
BTADR:	BCDSZ,,3		;SIZE OF BOOTS, DISK ADDR
BOOTCL:	XWD -BCDSZ,BOOTS
	0

BOOTFI:	WRAPR	200000		;First word of BOOTS is CONO APR,200000


;PRIMITIVE DISK READ SET UP AND DISPATCH
PMDRD::	PUSHJ	P,PMDSET	;SET UP TO READ
	HRRZ	T1,PMDDSP(T1)	;GET READ ADDRESS
	PJRST	(T1)		;READ FROM SELECTED UNIT

;PRIMITIVE DISK WRITE SET UP AND DISPATCH
PMDWT::	PUSHJ	P,PMDSET	;SET UP TO WRITE
	HLRZ	T1,PMDDSP(T1)	;GET WRITE ADDRESS
	PJRST	(T1)		;WRITE TO SELECTED UNIT

;SET UP FOR PRIMITIVE DISK ROUTINES
PMDSET:	LDB	J,UNYSCN##	;GET CHANNEL NUMBER
	LDB	W,UNYPUN##	;GET UNIT NUMBER OFFSET
	LDB	T1,UNYKTP##	;GET DEVICE TYPE
	TLNN	PG,-1		;IS # OF WORDS SPECIFIED?
	 TLO	PG,1000		;NO: DEFAULT TO ONE PAGE
IFCPU(<KI,KL>),<
	LDB	T2,UNYBPR##	;Get blocks per record
	CAIE	T2,4		;Record size set to 4 blocks to a page
	SKIPGE	UNICHR##(U)	;Formatted in pages? (sign bit set)
	 JRST	PMDST1		;Yes, formatted in pages
	MOVEI	T2,200		;Formatted in blocks if UNICHR is positive
	MOVEM	T2,SAWPR	;Words per record
	LDB	T2,UNYBPT##	;Blocks per track
	MOVEM	T2,SARPT	;Records per track
	LDB	T2,UNYBPY##	;Blocks per track
	MOVEM	T2,SARPC	;Records per cylinder
	POPJ	P,
PMDST1:	MOVEI	T2,1000		;Formatted in pages if UNICHR is negative
	MOVEM	T2,SAWPR	;Words per record
	LDB	T2,UNYPPT##	;Pages per track
	MOVEM	T2,SARPT	;Records per track
	LDB	T2,UNYPPY##	;Pages per cylinder
	MOVEM	T2,SARPC	;Records per cylinder
>  ;End IFCPU(KI,KL)
	POPJ	P,

;PRIMITIVE DRIVER DISPATCH TABLE
PMDDSP:	;WRITER,,READER
	XWD BADPWT,BADPRD	;0  DR
	XWD BADPWT,BADPRD	;1  FH
	XWD BADPWT,BADPRD	;2  DP
	XWD BADPWT,BADPRD	;3  MD
	XWD SAXPWT,SAXPRD	;4  SAX
	XWD RMXPWT,RMXPRD	;5  RM/RP
	XWD APXPWT,APXPRD	;6  F3 CDC/AMPEX DRIVES

IFNCPU(KS),<RMXPWT: RMXPRD:>
IFNCPU(F3),<APXPWT: APXPRD:>
IFNCPU(<KI,KL>),<SAXPWT: SAXPRD:>
BADPWT:
BADPRD:	MOVEI	T1,[ASCIZ /?Unit data block messed up
/]
	PJRST	CTYTYP##

CPOPJ1:	AOS	(P)		;SKIP RETURN
CPOPJ:	POPJ	P,		;NO SKIP RETURN
IFCPU(<KI,KL>),<SUBTTL	Primitive READ/WRITE routines for SA-10

COMMENT !PRIMITIVE ROUTINES TO READ OR WRITE A SPECIFIED NUMBER OF
	 WORDS STARTING AT AN ARBITRARY DISK PAGE FROM/TO ANY 3330
	 TYPE DRIVE CONNECTED TO AN SA-10.
	 PARAMETERS:	PG/ # OF WORDS,,DISK PAGE
			F/ CORE ADDR (NOT NECESSARILY ON PG BOUNDARY)
			J/ 1B33  SA-10
			   3B35  SUB-CHANNEL
			W/ UNIT
	 CALL:	PUSHJ P,SAXPRD  TO READ
		PUSHJ P,SAXPWT  TO WRITE
	 RETURN:	SUCCESS: M=W, SKIP RETURN
			ERROR: NON-SKIP RETURN
			       M=W OR 77  IF CHANNEL NOT AVAILABLE
				=W OR 7  IF NO MORE UNITS ON THIS
					 KONTROLLER
				=W  IF UNIT NUMBER GOOD BUT OTHER ERROR
	 ACS ALTERED:	T1-T4,M,P1-P3
!

SAXPWT:	MOVEI	P1,SAXWCD
	SKIPA
SAXPRD:	MOVEI	P1,SAXRCD
	DPB	P1,SAYBB	;STORE READ OR WRITE CODE
    ;STORE DEVICE ADDRESS IN COMMANDS.
	MOVEI	T1,SAUN0(W)	;COMPUTE DEVICE ADDRESS
	MOVE	M,[POINT 8,SACLST,23] ;B HOLDS PNTR.
	DPB	T1,M		;DEV ADDR TO SEEK
	HRRI	M,2(M)		;
	DPB	T1,M		;DEV ADDR TO SEARCH ID EQUAL.
	HRRI	M,3(M)		;
	DPB	T1,M		;DEV ADDR TO READ/WRITE CMD.

	MOVN	T1,SAWPR	;Negative of words per record
	LSH	T1,^D24		;Put in bits 0-11, zero bits 12-17
	HRR	T1,F		;Physical address (24 bits)
	MOVEM	T1,SACADR	;SET INIT DESTINATION ADDR

;PG has # of words in LH, disk page address in RH

	SETZ	P3,		;INIT RECORD INDEX
NEXREC:	HRRZ	T1,PG		;COPY PAGE NUM
	LSH	T1,P2WLSH	;PAGES TO WORDS
	IDIV	T1,SAWPR	;CONVERT TO RECORD NUM
	ADD	T1,P3		;COMPUTE CURRENT RECORD NUM
	IDIV	T1,SARPC	;COMPUTE CYLINDER,
	IDIV	T2,SARPT	; HEAD,
	ADDI	T3,1		; AND RECORD NUMBERS
	DPB	T1,SAYCC	;STORE CYLINDER NUMBER
	DPB	T2,SAYCC+1	;STORE HEAD NUMBER
	DPB	T3,SAYCC+2	;STORE RECORD NUMBER

	MOVEI	P1,SAX1AD	;GET ADDR OF SA-10 1
	TRNE	J,4		;SKIP IF SELECTED SA-10
	 MOVEI	P1,SAX2AD	;GET ADDR OF SA-10 2
	HRRZ	M,J		;WHICH SA-10?
	LSH	M,2
	ADDI	M,SAXREG	;NOW HAVE BASE FOR THIS CHANNEL
	MOVEI	T1,SACLST
	HRLI	T1,200000	;TIC COMMAND
	MOVEM	T1,(M)		;STORE IN BASE AREA
	MOVEI	P2,1		;SET A UNIQUE BIT IN P2 THAT CORR. TO
	LSH	P2,(J)		; THE SA-10, SUB-CHAN BEING REFERENCED
	TDNE	P2,CHNFLG	;DO WE KNOW ITS NOT THERE
	 JRST	STRT4A		;YES, GIVE UP ON IT
	MOVEI	T1,21
	SETCMI	T2,(J)
	ORI	T2,-4		;ZERO EXTRANEOUS BIT IF SET
	LSH	T1,7(T2)	;SET UP BIT FOR STAT FLAG FOR THIS CHAN
	SETCA	T2,		;RECOVER CHANNEL NUMBER
	LSH	T2,3		;CONVERT TO CORRECT POSITION FOR CONO
	HRL	T2,T1		;SAVE STATUS BIT IN LEFT HALF
RESTAR:	PUSHJ	P,IOCNI		;READ STATUS
	JUMPE	T4,STRT4	;JUMP IF SA-10 IS MISSING
	MOVEI	T1,640(T2)
	PUSHJ	P,IOCNO		;SET STATUS BIT
	MOVEI	T1,440(T2)
	PUSHJ	P,IOCNO		;AND GO FLAG
	MOVEI	T1,600(T2)
	PUSHJ	P,IOCNO		;AND THEN CLEAR STATUS
	MOVEI	T4,^D100000
	HLRZ	T1,T2		;GET STATUS BIT
	PUSHJ	P,IOCNSO	;AND DO THE CONSO
	 SOJG	T4,.-1
	JUMPE	T4,STRT4	;JUMP ON TIMEOUT
	MOVE	T4,1(M)		;GET STATUS
	TLNE	T4,(1B2)
	 JRST	STRT4A		;SELECT ERROR
	MOVEI	T1,400000	;IN CASE WE HAVE TO RESET
	TLNN	T4,BSY
	 JRST	STRT3		;NOT BUSY
	TLNE	T4,SM		;BUSY+STATUS MODIFIER?
	 JRST	STRT2		;YES
	TLNE	T4,CUE
	 JRST	RESTAR		;JUMP ON BUSY+CU END
STRT3:	TLNN	T4,CE+DE	;CHANNEL END AND DEVICE END?
	 JRST	STRT5		;NO. ERROR
	TLNN	T4,175114	;OTHER ERRORS?
	 JRST	NEXRC1		;THIS RECORD PROC. OK, CONTINUE
STRT5:	PUSHJ	P,IOCNO		;T1 IS LOADED WITH BIT 18
	HRRZ	M,W		;UNIT NUM SUPPLIED WAS GOOD
	POPJ	P,

STRT4:	IORM	P2,CHNFLG	;MARK CHANNEL NOT THERE
	MOVEI	T1,77		;AND WORD FOR BAD CHANNEL
	SKIPA
STRT4A:	MOVEI	T1,7		;AND WORD FOR NO MORE DEV ON KONT
	MOVE	M,W		;COPY UNIT NUMBER
	TDO	M,T1		;SET TO TOP OF MULT OF 10
	POPJ	P,

STRT2:	MOVEI	T1,600(T2)
	PUSHJ	P,IOCNO		;CLEAR STATUS
	HLR	T1,T2		;NO WAIT FOR STATUS BIT
	PUSHJ	P,IOCNSO
	 JRST	.-1
	MOVE	T4,1(M)
	TLNE	T4,CUE
	 JRST	RESTAR
	JRST	STRT2

NEXRC1:	MOVE	T1,SAWPR	;LOAD RECORD SIZE
	ADDM	T1,SACADR	;POINT TO NEXT RECORD LOCATION IN CORE
	ADDI	P3,1		;INCREMENT RECORD COUNTER
	HLRZ	T1,PG		;Get requested number of words
	IDIV	T1,SAWPR	;Convert to number of records
	CAMGE	P3,T1		;Done all of them?
	 JRST	NEXREC		;NO: DO NEXT RECORD
	MOVE	M,W		;UNIT NUM SUPPLIED WAS GOOD
	JRST	CPOPJ1		;SUCCESS RETURN

IOCNSO:	MOVSI	T3,(CONSO (T1))	;SETUP IO INSTR.
IOXCT:	DPB	P1,[POINT 7,T3,9];PUT IN I/O DEVICE FIELD
	XCT	T3		;DO THE IO
	 POPJ	P,		;NO SKIP RETURN
	JRST	CPOPJ1

IOCNI:	SKIPA	T3,[CONI T4]	;FOR SA-10
IOCNO:	MOVSI	T3,(CONO (T1))
	JRST	IOXCT

; SA-10 COMMAND LIST AND DEFINITIONS

CMDLST:
SACLST:	BYTE	(8)72,7		;SEEK
	BYTE	(12)-6(24)SACARG
SACIDE:	BYTE	(8)73,61	;SEARCH ID EQUAL
	BYTE	(12)-5(24)SACARG
SACTIC:	XWD	200000,SACIDE	;TIC
SACCMD:	BYTE	(8)160		;READ OR WRITE
SACADR:	BYTE	(12)-1(24)0	;-WORD COUNT(SAWPR), START ADDRESS
	0			;Zero terminates command list

SACARG:	BLOCK	2		;SEEK/SEARCH BLOCK

SAYBB:	POINT	8,SACCMD,15
SAYCC:	POINT	32,SACARG,31
	POINT	16,SACARG+1,15
	POINT	8,SACARG+1,23

CHNFLG:	Z			;DEFECTIVE CHANNEL FLAG WORD

;These 3 locations will be updated by PMDSET to the correct values
; The values here are defaults for loading BOOTS from 3330 formatted in blocks.
; Note that if the disk does not match these values, control will eventually
; go to BOTLOD, which is capable of reading all four formats.
SAWPR:	DEC 128		;Words per record       ( 512, 512, 128)
SARPT:	DEC  18		;Records per track      (   5,   7,  25)
SARPC:	DEC 18*19-2	;Records per cylinder   (5*19,7*30,25*30-2)

SAXWCD==5	;Disk write code
SAXRCD==6	;Disk read code
SAUN0==300	;Unit 0 at X'C0'
SAXREG==300
SAX1AD==274_-2		;SA-10 1
SAX2AD==400_-2		;SA-10 2
BSY==(BYTE (8)0,20)
CUE==(BYTE (8)0,40)
SM==(BYTE (8)0,100)
CE==(BYTE (8)0,10)
DE==(BYTE (8)0,4)
> ;END IFCPU(<KI,KL>)
IFCPU (KS),<SUBTTL	Primitive READ/WRITE routines for RM03/RP06

COMMENT	!PRIMITIVE ROUTINES TO READ OR WRITE A SPECIFIED NUMBER OF
	 WORDS STARTING AT AN ARBITRARY DISK PAGE FROM/TO AN
	 RM03/RP06 DISK DRIVE INTERFACED TO A KS THRU A UBA.
	 PARAMETERS:	PG/ # OF WORDS,,DISK PAGE
			F/ CORE ADDR (NOT NECESSARILY ON PAGE BOUNDARY)
			W/ UNIT
	 CALL:	PUSHJ P,RMXPRD	TO READ
		PUSHJ P,RMXPWT	TO WRITE
	 RETURN:	SUCCESS: SKIP
			FAILURE: NON-SKIP
	 ACS ALTERED:	T1-T4,P1-P2
!

DEFINE	RDREG(DEST,REG)	;EXPECTS THE UBA NUMBER IN T2
<	RDIO	DEST,REG'ADR(T2)>

DEFINE	WRREG(SRC,REG)	;EXPECTS THE UBA NUMBER IN T2
<	WRIO	SRC,REG'ADR(T2)>


RMXPRD:	SKIPA	P1,[F.RD]	;DO DISK READ
RMXPWT:	MOVEI	P1,F.WD		;DO DISK WRITE
	HRLZI	T2,UA1	;SET THE ADDRESS TO UBA1
	MOVEI T3,CS2CLR
	WRREG T3,CS2;			CLEAR RH11
	WRREG W,CS2;			SELECT UNIT
	RDREG T4,DS;			DRIVE EXISTS?
	RDREG T3,CS2
	TRNN T3,CS2NED
	  TRNN T4,DSMOL
	   POPJ	P,
	MOVEI T4,F.RIP			;READ IN PRESET
	WRREG T4,CS1
	MOVEI T4,^D100000
	MOVEI T3,DSDRY		;WAIT UNTIL INITIALIZATION DONE
	TION  T3,DSADR(T2)
	  SOJG T4,.-1
	JUMPLE	T4,RMPOPJ
	RDREG T4,DS
	TRNE T4,DSERR
	  POPJ	P,
	MOVEI T4,F.RECA
	WRREG T4,CS1;			ISSUE RECALIBRATE
	MOVEI T3,^D100000
	RDREG T4,DS
	TRNN T4,DSDRY
	 SOJG T3,.-2
	JUMPLE T3,RMPOPJ
	TRNE T4,DSERR
	 POPJ	P,
;TRY UNIT
	RDREG	P2,DT
	ANDI	P2,2		;Adr is function of unit type.
	LSH	P2,-1		;0:RM03, 1:RP06
	MOVEI	T1,^D148	;CALCULATE
	CAIE	P2,0		; ABSOLUTE
	 MOVEI	T1,^D380	; DISK
	HRRZ	T3,PG		; SECTOR
	LSH	T3,2		; ADDR
	IDIV	T3,T1		; FROM
	WRREG	(T3,DC)		; UNIT
	MOVE	T3,T4		; RELATIVE
	MOVEI	T1,^D30		; PAGE
	CAIE	P2,0		; NUMBER
	MOVEI	T1,^D20		; AND
	IDIV	T3,T1		; PASS
	DPB	T3,[POINT 5,T4,27]	; TO
	WRREG	(T4,DA)		; DRIVE
	HLRZ	T3,PG		;SET WORD COUNT
	LSH	T3,1		;(2 UNIBUS words per KS10 word)
	MOVNS	T3
	WRREG T3,WC
	MOVE T4,F		;SET VIRTUAL CORE ADDRESS
	SETZ T3,		;SET VIRTUAL CORE ADR
	ROTC T3,-9
	ROT T3,13
	WRREG T3,BA
	MOVE T3,[UA1,,PGRADR]
	TRO T4,PGRFST+PGRVAL		;SET PHYSICAL CORE ADR
	WRIO T4,@T3
	AOJ T4,
	AOJ T3,
	WRIO T4,@T3
	WRREG P1,CS1
	movei	t3,^D100	;busy wait loop index
rmp1:	movei	t4,^D2000	;bus saturation avoidance loop index
	sojg	t4,.		;only do read every few ms to avoid
				; saturating the bus
	RDREG T4,CS1
	TRNN T4,CS1RDY		;done?
	 sojg	t3,rmp1		;no, try again if haven't timed out
	JUMPLE	T3,RMPOPJ
	TRNN	T4,CS1TRE	;ANY ERRORS?
	AOS	(P)		;NO: READ/WRITE SUCCEEDED
RMPOPJ:	POPJ	P,
>;END IFCPU KS
IFCPU(F3),<	SUBTTL	Primitive READ/WRITE routines for FOONLY

RTYCNT==20000

DRVTYP==CDC
CDC==1
AMPEX==0

IFE DRVTYP-CDC,<
SPT==^D8		;SECTORS PER TRACK (DEPENDS ON HOW FORMATTED)
TPC==^D10		;TRACKS PER CYLINDER (NUMBER OF HEADS)
CPU==^D823-^D10		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>
IFE DRVTYP-AMPEX,<
SPT==^D8		;SECTORS PER TRACK
TPC==^D5		;TRACKS PER CYL (NUMBER OF HEADS)
CPU==^D815-^D5		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>;END IFN AMPEX
PPC==SPT*TPC		;PAGES PER CYLINDER
BPC==PPC*4		;BLOCKS PER CYLINDER
PPU==PPC*CPU		;PAGES PER UNIT
SPT==^D8		;SECTORS PER TRACK
BPT==SPT*^D4		;BLOCKS PER TRACK
USPR==^D17300		;MICROSECONDS PER REVOLUTION.

;DISK IOTS AND REGISTER BIT NAMES.
PRINTF(<[F3 disk definitions are duplicated in MONBTS and APXKON]>)

OPDEF RCMD	[715000000000]	;READ COMMAND REGISTER
	SUNT==1B0		;SELECTED UNIT NOT THERE (SELECT ERROR)
	SUWP==1B1		;SELECTED UNIT WRITE PROTECT
	SUNR==1B2		;SELECTED UNIT NOT READY
;---
	SUOC==1B3		;SELECTED UNIT ON CYLINDER
				; SHOULD ALWAYS BE SET EXCEPT AFTER RECAL UNTIL HEADS ALIGN
	SUSE==1B4		;SELECTED UNIT SEEK ERROR (DETECTED BY DRIVE)
				; RECAL MANDATORY AFTER THIS ERROR, FAULT CLEAR WILL NOT TURN THIS OFF.
	SUF==1B5		;SELECTED UNIT FAULT (DETECTED BY DRIVE)
;---
	SUA==1B6		;SELECTED UNIT ATTENTION
				; SET BY LEADING EDGE OF ON CYLINDER (BIT 3)
	HDECC==1B7		;ECC ERROR ON HEADER
	CI==1B8			;CONTROL IDLE (ONLY IF NO DATA XFER AND NO SEEKS OR RECALS GOING)
;---
	SECC==1B9		;SOFT ECC ERROR (NOT YET IMPLEMENTED IN F3 MICROCODE)
	HECC==1B10		;ECC UNRECOVERABLE ERROR

;FOLLOWING BITS ARE DETECTED BY CONTROLLER:
	ROE==1B11		;READ OVERRUN ERROR
;---
	WOE==1B12		;WRITE OVERRUN ERROR
	SOE==1B13		;SECTOR OVERRUN ERROR
	IPE==1B14		;INTERNAL PARITY ERROR (ONLY VALID IF AE, BIT 28, IS ZERO)
;---

;FOLLOWING ARE FROM LAST LCMD

	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH COMMAND 4)
;---
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
;	19 UNUSED
;	20 UNUSED
;---
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
;---
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
;---
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)

;END OF FROM RCMD BITS
	AE==1B28		;ANY  ERROR (EXCEPT IPE, BIT 14)
	AA==1B29		;ANY UNIT ATTENTION
;---

;FROM LCMD
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE

	NA==1B31		;NOT ACTIVE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
;---
;BITS 33, 34 NOT IMPLEMENTED.

	MPE==1B35		;MEMORY PARITY ERROR
;---
OPDEF RMA	[716000000000]	;READ MEMORY ADDRESS
OPDEF RDA	[717000000000]	;READ DISK ADDRESS (IN PAGES)
	AMSUNI==^D3		;SIZE OF UNIT BYTE
	AMPUNI==^D6		;RIGHTMOST BIT
	ROTUNI==-<AMPUNI+1>	;NUMBER OF PLACES TO ROTATE TO GET UNIT FIELD IN
	AMSCYL==^D12
	AMPCYL==^D19
	AMSTRK==^D8
	AMPTRK==^D27
	AMSSEC==^D8
	AMPSEC==^D35
	LDAMSK==034000,,177400	;MASK FOR $0% AND $0O IN DDT
OPDEF RECC	[720000000000]	;READ CONTROL REGISTER
OPDEF LCMD	[721000000000]	;LOAD COMMAND REGISTER
	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH COMMAND 4)
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
OPDEF LMA	[722000000000]	;LOAD MEMORY ADDRESS
OPDEF LDA	[723000000000]	;LOAD DISK ADDRESS
	SU==1B7			;SELECT UNIT
				;MUST BE CLEARED AND SET TO SELECT A UNIT.
OPDEF LECC	[724000000000]	;CLEARS ECC LOGIC, STARTS AND INITS CONTROL.
	SC==1			;START CONTROL
	IC==2			;INIT CONTROL (SEND BEFORE STARTING CMD)
OPDEF DCONO	[740000000000]	;CONO TO DISK CONTROL TO SET PI ASSIGNMENT
OPDEF DCONI	[741000000000]	;CONI FROM DISK CONTROL OPCODE
	DIDLE==10		;SET IF CONTROL IS IDLE
	DPIA==7B35		;PI ASSIGNMENT.
				;NOTE THAT NONZERO PI ASSIGNMENT SETS DIE (SEE LCMD)
OPDEF DCONSO	[742000000000]
OPDEF DCONSZ	[743000000000]

;ROUTINE TO START A FUNCTION UP ON CONTROL

DOKON:	LECC	[IC]		;INIT CONTROL
	LCMD	T1		;DO THE COMMAND
	LECC	[SC]		;START CONTROLLER
	POPJ	P,		;AND RETURN.

CLRKON:	MOVE	T1,[CF+FC]	;COMMAND FUNCTION FAULT CLEAR
DOWKON:	PUSHJ	P,DOKON		;DO THE COMMAND AND THEN
WATKON:	MOVEI	T2,RTYCNT	;NUMBER OF TIMES TO WAIT
	RCMD	TLNN	T1,(CI)		;CONTLOL IDLE YET?
	SOJG	T2,.-2		;NO
	JUMPG	T2,CPOPJ1	;JUMP IF IT WENT IDLE
	POPJ	P,		;DIDN'T.

APINI:	HRRZ	T1,W	;GET UNIT SELECTED
	ROT	T1,ROTUNI
	LDA	T1
	TLO	T1,(<SU>)
	LDA	T1
	PUSHJ	P,CLRKON	;CLEAR CONTROL
	  JFCL			;IGNORE ERRORS FOR NOW
	RCMD	T1		;GET STATUS
	TLNE	T1,(<SUNT!SUNR>) ;NON-SKIP IF NOT THERE OR NOT READY
	POPJ	P,
	PUSHJ	P,CLRKON	;CLEAR OUT CONTROL AGAIN
	  POPJ	P,		;TIMEOUT
	MOVE	T1,[CF+FC+RECAL]
	PUSHJ	P,DOWKON	;DO A RECAL IN CASE IT HAD SEEK ERROR
	  POPJ	P,		;NO GOOD.
	MOVSI	T1,^D10		;WAIT A LONG TIME
	RCMD	T2
	TRNN	T2,NA		;SKIP IF NOT ACTIVE ANYMORE.
	SOJG	T1,.-2
	JUMPE	T1,CPOPJ	;GO IF TIMED OUT
	RCMD	T1		;GET STATUS BITS AGAIN
	TRNN	T1,AE		;ERROR RETURN IF ANY ERRORS
	AOS	(P)		;NO ERRORS
	POPJ	P,

COMMENT ! PRIMITIVE ROUTINES TO READ OR WRITE A SPECIFIED NUMBER OF
	 WORDS STARTING AT AN ARBITRARY DISK PAGE FROM/TO AN
	 AMPEX OR CDC DISK DRIVE ON A FOONLY-F3.
	 PARAMETERS:	PG/ # OF WORDS,,DISK PAGE
			F/ CORE ADDR (NOT NECESSARILY ON PAGE BOUNDARY)
			W/ UNIT
	 CALL:	PUSHJ P,APXPRD	TO READ
		PUSHJ P,APXPWT	TO WRITE
	 RETURN:	SUCCESS: SKIP
			FAILURE: NON-SKIP
	 ACS ALTERED:	T1-T4,P1-P2
!

APXPRD:	SKIPA	P2,[APREAD]
APXPWT:	MOVEI	P2,APWRIT	;APPROPRIATE ROUTINE TO CALL.
	PUSHJ	P,APINI		;INIT THE UNIT
	  POPJ	P,		;COULDN'T INIT THE DRIVE.
	PUSH	P,PG		;NEED TO SAVE THIS
	PUSH	P,F		;SO CAN DO MORE THAN ONE REC AND PRESERVE ARGS.
	HLRZ	T1,PG		;GET COUNT OF WORDS WANTED.
	TRZE	T1,777		;If not a multiple of 1000
	 ADDI	T1,1000		; round up
	LSH	T1,-9		;TURN INTO PAGES.
	MOVNS	T1		;- COUNT
	HRL	PG,T1		;MAKE INTO AN AOBJN POINTER
APXPX1:	PUSHJ	P,(P2)		;CALL THE ROUTINE TO DO ONE PAGE
	  JRST	APXPER		;NO GOOD.
	ADDI	F,1000		;ADVANCE MEMORY ADDRESS
	AOBJN	PG,APXPX1
	AOS	-2(P)		;OK, GIVE SUCCESS RETURN.

APXPER:	POP	P,F
	POP	P,PG
	POPJ	P,

;HERE TO READ OR WRITE ONE PAGE WITH RH(PG) CONTAINING THE BLOCK NUMBER
; W CONTAINING THE UNIT NUMBER AND F CONTANING THE MEMORY ADDRESS.

APWRIT:	SKIPA	P1,[WRITE]
APREAD:	 MOVEI	P1,READ
	HRRZ	T1,PG		;GET PAGE NUMBER
	IDIVI	T1,PPC		;GET T1/CYL, T2/PAGES INTO CYL
	IDIVI	T2,SPT		;GET T2/TRACK, T3/SECTOR IN TRACK
	DPB	T2,[POINT AMSTRK,T3,AMPTRK]
	DPB	T1,[POINT AMSCYL,T3,AMPCYL]
	HRRZ	T1,W
	ROT	T1,ROTUNI	;GET UNIT NUMBER INTO POSITION
	TDO	T3,T1
	LDA	T3
	TLO	T3,(<SU>)
	LDA	T3
	PUSHJ	P,CLRKON	;CLEAR OUT CONTROL
	  JFCL			;IGNORE, WILL CATCH LATER.
	LMA	F		;LOAD MEMORY ADDRESS
				;NUMBER OF WORDS IS ALWAYS 1000
	MOVE	T1,P1		;GET COMMAND INTO T1 FOR DOKON
	PUSHJ	P,DOKON	;START THE TRANSFER
	MOVSI	T1,^D10		;TIMEOUT IS ABOUT 10 SECONDS.
	RCMD	T2
	TRNN	T2,NA
	 SOJG	T1,.-2
	JUMPE	T1,CPOPJ	;TIMED OUT, ERROR
	RCMD	T1		;OK, GET COMMAND
	TRNE	T1,AE		;MAKE SURE NO ERROR BITS ON
	 POPJ	P,		;SORRY.
	TLNE	T1,(<IPE>)	;THIS IS ONLY VALID IF AE OFF
	POPJ	P,		;NO GOOD.
	RMA	T1
	TLZ	T1,777774	;CLEAR UNUSED BITS
	SUB	T1,F		;GET NUMBER OF WORDS XFERRED
	CAIE	T1,1000
	 POPJ	P,		;WRONG COUNT
	JRST	CPOPJ1		;OK, SUCCESSFUL XFER.
>;END IFCPU (F3)

	$END	(BTS)		;End of MONBTS (BTSLIT: BTSEND:)

    @R–