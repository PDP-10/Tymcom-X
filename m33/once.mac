TITLE ONCE - ONCE ONLY INITIALIZATION AND OPERATOR DIALOGUE

;*;	STOPCD(,ENTRY,ONCE)	;Macro is expanded after the PHASE statement

EXTERN	REYDCA,DCNYUR,REYDCM,DCNYMN,RESTRT,REONCE,RESCOD,REPSID
EXTERN	RE.OND,RECOMP,RE.ONA,ONCMOD,DCFULL,DCNYOP,DCN.OP,DCN

;GENERAL PARAMETERS

EXTERNAL MEMSZP,SYSSZP,JBTUPM,UPSJOB
EXTERNAL PMEMSZ,PJOBN,GETWDS
IFCPU (KI),<EXTERNAL APRCH2>
IFNCPU(KI),<EXTERNAL APRCHN>
EXTERNAL SYSBEG,SYSEND,DEVLST,CRSHWD,NMRBPC,NMSTPC
EXTERN %SAT.C,%RIB.C,%RB2.C,%CTLRU,%CTMRU,%CTLST
EXT(<%UPT,%UPS>)
EXTERN EPYPSN,USYPTN
EXTERN M2REQ,M2SWT,PSREQ,PSSWT,PRREQ,PRSWT,M2HAV,SIREQ,SISWT,RIREQ,RISWT

;ROUTINES IN OTHER PLACES

EXTERNAL PEVEN8,CTEXT,COMTYI,CONMES,CPOPJ1,CRLF,FILMAN
EXTERNAL FILOPT,INLMES,LNGMES,DECLOP,ASKQMM,TYPONL,ONCTIM
EXTERNAL LINKDB,NULJOB

;FOR SETTING UP UPT

EXTERNAL CURUPT,EPT,EPT.PN,INTNUM,INTTAB
IFCPU (KL),<EXTERNAL CSRTAB>
EXTERNAL SERIAL,STATES,UPT,UPT.PN,UPTACP,UPTAC0,UPTPC
EXTERNAL CH1,CH2,CH3,CH4,CH5,CH6,CH7,USRMPE
EXTERNAL ERRPOV,UUOKNT,UUOKTR,UUOSNT,UUOSTR,UUOCNT,UUOCTR
EXTERNAL UUOPNT,UUOPTR,EXCMPE,EXCPDL
IFNCPU (KI),<EXTERNAL PGFAIL,PGFUIO>	;NEED A PAGE FAIL DISPATCH ON KLS
IFNCPU (KI),<EXTERN EPTEBR>

;FOR TTY CONTROL AND USE DURING ONCE ONLY CODE

EXTERNAL COMTIA,COMTOA,TTCMCH,MAX,MIN,COMTYO

;VARIOUS SYSTEM PARAMETERS PRINTED AND MODIFIED

EXTERNAL CONFIG,SYSDAT,THSDAT,TIME,USRLIM

;STUFF FOR PAGE TABLE

EXTERN PGYUNU,PGYPGO,PGYFPL,PGYLMA,PGYLMJ,PGYLMV,PGYBPL
EXTERN PGYDIO,PGYADR,PGYUNI,PGYPNO,PGYSPT,PGYSPB,PGYSPO,PGYCHT,PGYSIO
EXTERN PGYSIP,PGYSOP,PGYERR,PGYNXM,PGYDRT,PGYATB,PGYUSE,PGYCSH
EXTERN PGYSTS
EXTERN PGYLST,CFRLST,MAXPCB,CFR.N,USELST,USE.N,MINPCB
EXTERN SNDPGY,CNTPGY,IOPQTA,CHTPTR,CHTMSK
EXTERN SIDLST,SODLST
EXTERN USRMAX,MWSLIM

;STUFF FOR CORE CONTROL

EXTERNAL CORMXK

;INITIALIZE ROUTINES

EXTERNAL DDBLEN


ONCGO::	SETOM	DINITF##	;Set disk initialization in progress flag
	JSR	APRINI		;MAKE SURE APR IS SETUP RIGHT
	LDB	T1,REYDCA	;COPY USER SELECTED
	DPB	T1,DCNYUR+ONCMOD-%OND; DSKCLN TYPE
	LDB	T1,REYDCM	;COPY MONITOR SELECTED
	DPB	T1,DCNYMN+ONCMOD-%OND; DSKCLN TYPE
	MOVE	T1,RESTRT	;COPY RESTRT WORD TO PRESERVE
	MOVEM	T1,REONCE+ONCMOD-%OND; FLAGS AND VALIDATOR
	SETZM	RESTRT		;CLEAR JUST IN CASE
	SETZM	CRSHWD		;CLEAR HERE IN CASE CLOCK GOES OFF
				; (ON NON-F3 MACHINES WE MADE IT THROUGH FOR SOME REASON)
	MOVEI P,SYSPDL##	;GET A PDL SETUP
IFCPU (KL),<JSR SPCINI##>	;ENTER SECONDARY PROTOCOL IF HAVEN'T ALREADY
	JSR MOVSTP		;MAKE SURE SYMBOL TABLE PTR MOVED

;DETERMINE CTY SPEED

	MOVEI T3,0	;THIS WILL COUNT THE NUMBER OF CLOCK TICS
IFCPU (<KI,F3>),<
	CONSO APR,APRCLK	;WAIT FOR A CLOCK TIC
	 JRST .-1
IFCPU (KI),<WRAPR APRCLK>	;CLEAR THIS ONE
IFCPU (F3),<WRAPR LP.CSF+APRCLK>
	DATAO TTY,T3		;SEND THE ZERO
CTYSP1:	CONSO TTY,TT.OB		;IS IT DONE
	 JRST CTYSP2		;YES
	CONSO APR,APRCLK	;DID CLOCK TIC
	 JRST CTYSP1		;NO
IFCPU (KI),<WRAPR APRCLK>	;YES, CLEAR
IFCPU (F3),<WRAPR LP.CSF+APRCLK>
>;END IFCPU (<KI,F3>)
IFCPU (KL),<
	CONO	TIM,TO.CIT	;CLEAR TIMER
	CONO	TIM,TO.SIT!^D1666	;START TIMER
	MOVEI	T3,.DTCTO		;SEND NULL CHAR
	MOVEM	T3,EPT+SPCCMW
	SETZM	EPT+SPCMTD
	CONO	DTE,TO11DB
CTYSP1:	SKIPE	EPT+SPCMTD		;CHECK FOR OUTPUT DONE
	 JRST	CTYSP2			;DONE
	CONSO	TIM,TI.ITD		;TIMER TICKED YET?
	 JRST	CTYSP1			;NO, KEEP WAITING
	CONO	TIM,TO.CTD!TO.SIT!^D1666 ;RESTART TIMER FOR NEXT TICK
>;END IFCPU (KL)
IFCPU (KS),<
	WRINT	ITMTIM		;SET TICK
	MOVEI	T3,CTYOVL	;SET VALID FLAG
	MOVEM	T3,CTYOWD##	;STORE IN 8080 OUTPUT WORD
	WRAPR	LP.SSF+LP.I8C	;INTERRUPT 8080 CONSOLE
CTYSP1:	HRRZ	T1,CTYOWD##	;CHARACTER TAKEN YET?
	JUMPE	T1,CTYSP2	;YES
	CONSO	APR,LP.ITD	;TIMER TICKED YET?
	 JRST	CTYSP1		;NO KEEP WAITING
	WRINT	ITMTIM		;RESTART TIMER FOR NEXT TICK
>;END IFCPU (KS)
	AOJA	T3,CTYSP1	;AND COUNT

CTYSP2:	MOVEI	T1,0		;New 1200 baud terminals don't need fills
	CAIGE	T3,5
	 MOVEI	T1,2		;2 FILLS FOR 150 baud
	CAIGE	T3,3
	 MOVEI	T1,5		;5 FILLS FOR 300 baud
	MOVEM	T1,CTYFIL##	;SAVE IN FILL NUMBER (IN SCNSER)
COMMENT # DESCRIPTION OF MONITOR PHYSICAL LAYOUT DYNAMICS (ONCE.MAC)

IT IS ASSUMED THAT THE MONITOR TAKES UP LESS THAN 256K OF MEMORY
TOTAL (INCLUDING ALL DYNAMICALLY ALLOCATED SPACE). IF THE MONITOR
TOOK UP MORE THAN THIS, IT WOULD HAVE TO SHARE SOME OF ITS VIRTUAL
PAGES TO ACCESS PHYSICAL PAGES IN MEMORY, WHICH IS NOT PRESENTLY
DONE.
IT IS ALSO ASSUMED THAT THE TOP OF THE SYMBOL TABLE IS LESS THAN
340000. IN THE FUTURE, THIS RESTRICTION COULD BE LIFTED
IF THE EXEC PER PROCESS PAGES WERE USED TO ACCESS THE SYMBOL TABLE
UNTIL IT COULD BE MOVED DOWN UNDERNEATH 340000 (IF THAT WAS
POSSIBLE.)

WHEN THE MONITOR IS FIRST LOADED INTO CORE BY THE BOOTSTRAP PROGRAM,
THE LAYOUT OF PHYSICAL MEMORY IS:

	SYMBOLS			(HIGH CORE, MUST BE BELOW 340000)
	ONCE CODE		(APPROX 240000 IN P034/P MONITOR)
	DDT
	DEBUG
	PATCH			<--- SYSSIZ
	MONITOR CODE + ASSEMBLED TABLES, STARTING AT PHYSICAL PAGE 0

THE ONCE ONLY CODE MUST APPEAR LAST IN PHYSICAL MEMORY SO THAT IT
CAN BE REUSED AFTER THE SYSTEM IS INITIALIZED. THEREFORE,
THE MONITOR SCANS MEMORY UP TO 256K FOR THE FIRST NON-EXISTENT
LOCATION. THE ONCE CODE IS THEN LOCATED DIRECTLY UNDERNEATH
THIS LOCATION TO ALLOW THE MAXIMUM AMOUNT OF SPACE UNDER ITSELF
FOR THE MONITOR. THE ENTIRE MONITOR MUST FIT WITHIN THE
FIRST CONTIGUOUS BLOCK OF MEMORY.

THE ONCE CODE THEN CHECKS TO SEE IF IT CAN BLT ITSELF UP
TO THE TOP OF THE FIRST CONTIGUOUS BLOCK OF MEMORY WITHOUT
OVERWRITING THE SYMBOL TABLE. (IF IT CANNOT, A MESSAGE IS
PRINTED ON THE CONSOLE AND THE MONITOR CRASHES.)
THE ADDRESS SPACE THEN LOOKS LIKE THIS:

	ONCE TEMP. PGY, PCB, DDB
	ONCE CODE
	<BLANK AREA>
	SYMBOLS
	ONCE CODE
	DDT
	DEBUG
	PATCH			<--- SYSSIZ
	MONITOR CODE (IN LOW CORE)

THE ONCE CODE IS PHASED TO USE HIGH EXEC VIRTUAL LOCATIONS.
AFTER ONCE IS BLTTED TO ITS NEW LOCATION, MAP SLOTS ARE SET
UP FOR THE PROPER EXEC VIRTUAL PAGES, AND ONCE IS EXECUTED FROM THERE.

THEN ONCE CODE BLTS THE SYMBOLS DOWN TO THE TOP OF DDT.
(IT IS ASSUMED THAT DDT IS THE LAST MODULE IN THE MONITOR
BEFORE THE ONCE CODE).

	ONCE TEMP. PGY, PCB, DDB
	ONCE CODE
	<BLANK AREA>		<--- SYSSIZ IF DDT LOADED
	SYMBOLS
	DDT
	DEBUG
	PATCH			<--- SYSSIZ IF DDT NOT LOADED
	MONITOR CODE (IN LOW CORE)

ONCE THEN ALLOCATES SPACE FOR THE PGY TABLES, CHT, CALLS LINKDB
TO ALLOCATE THE MISCELLANEOUS DYNAMIC SPACE, THEN ALLOCATES
THE PCB TABLES AND PCB CORE PAGES.

	ONCE PCB, PGY, DDB
	ONCE CODE
	<POSSIBLY BLANK>		<--- SYSSIZ
	PCB PAGES
	PCB TABLES
	FREE CORE
	FREE CORE BIT TABLE
	FILSER CORE
	<SNOOP HISTOGRAM TABLE IF INCLUDED>
	LDB
	TTY CHUNKS
	TMPCOR
	DDBS
	CHT
	PGY TABLES	(LOWEST TABLES ACCESSED THRU EXEC VIRTUAL SPACE)
	STT TABLES	(ACCESSED THROUGH UNMAPPED AREA)
	<SYMBOLS IF LOADED>
	<DDT IF LOADED>
	<DEBUG IF DDT LOADED>
	<PATCH IF DDT LOADED OR PATSIZ UPDATED>
	MONITOR (IN LOW CORE)
# ;END COMMENT
;FIND OUT WHERE THE END OF THE FIRST CONTIGUOUS BLOCK OF MEMORY IS.
IFNCPU (F3),<			;Checks only first 256K
	WRAPR	CLRNXM		;CLEAR NXM FLAG
	MOVNI	T3,1000*^D16	;TEST REGISTER, ADDED TO BEFORE TEST
	MOVEI	T1,1000/^D16	;NUMBER OF 8K MODULES TO TEST
PTLP1:	ADDI	T3,1000*^D16	;CHECK EVERY 16 PAGES (8K)
	MOVE	T2,20(T3)	;TEST LOC 20 (AVOID ACS)
	CONSZ	APR,APRNXM	;END OF MEM?
	 JRST	PTLPD		;DONE, STORE MEMSIZ AND HGHBLK FOR NOW.
	MOVE	T2,21(T3)
	MOVE	T2,22(T3)
	MOVE	T2,23(T3)	;IN CASE BAD INTERLEAVE
	CONSZ	APR,APRNXM	;IS IT?
	 JRST	PTINTR		;YES, INTERLEAVE AND BOX OFF-LINE
	SOJG	T1,PTLP1	;TEST FOR 1000 PAGES
	ADDI	T3,1000*^D16
>;END IFNCPU (F3)
IFCPU (F3),<
	MOVSI	T3,1		;F3 ALWAYS HAS 512K, SO 256K IS ALWAYS THERE.
>;END IFCPU (F3)
PTLPD:	MOVEM	T3,MEMSIZ##	;STORE SIZE OF CORE IN WORDS (UPDATED LATER)
	LSH	T3,-9		;
	MOVEM	T3,HGHBLK	;
;NOW BLT ONCE, ONCDSK, AND REFSTR (FIRST MAKE SURE THEY FIT.)
;AND THEN SET UP AN AREA OF THE MAP TO POINT TO THEM.

COMMENT # LAYOUT OF EXEC VIRTUAL ADDRESS SPACE AFTER ALL THIS IS DONE:


VIRTUAL ADDRESS SYMBOLS AND LOCATIONS
(LISTED IN ORDER OF DECREASING VIRTUAL ADDRESSES)

		START				LENGTH

ONCE CODE	%ONC
ONCE PCB PAGES	BOTTM				NMOCPC*1000
ONCE DDB	BOTTM-ONCDDS+CNTPGY*NMOCPC	DDBLEN
PGY TABLES	BOTTM-ONCDDS			CNTPGY*NMOCPC

PHYSICAL ADDRESS LOCATIONS
(LISTED IN ORDER OF DECREASING PHYSICAL ADDRESS)

		START				END

ONCE PCB PAGES	C(MEMSIZ)-NMOCPC*1000		C(MEMSIZ)-1
<EMPTY SPACE>
ONCE DDB	END OF PGY + 1			BEG + DDBLEN
ONCE PGY	BEG OF PCB PAGES - ONCDDS	BEG + CNTPGY-NMOCPC
ONCE CODE

NOTE THAT THE ONCE CODE OCCUPIES THE HIGHEST VIRTUAL ADDRESS
LOCATIONS, BUT THE LOWEST PHYSICAL ONES.
#;END COMMENT.
ONCPYP==<<CNTPGY*NMOCPC>+DDBLEN+777>/1000
ONCDDS==1000			;[cab] This is the resolution!
;ONCDDS==ONCPYP*1000		;EXTRA SPACE AT TOP OF CORE TO ALLOCATE
				; ONCE ONLY PGY TABLES AND DDB.

	HLRO	T1,DDTSYM##	;GET SIZE OF SYMBOL TABLE
	HRRZ	T2,DDTSYM##	;AND START LOC.
	CAMGE	T2,PATSIZ##	;IS PATSIZ BIGGER?
	 MOVE	T2,PATSIZ##	;YES, USE THAT AS BASE
	SUB	T2,T1		;T2=1ST UNUSED LOC.
	SUBI	T2,1		;T2=LAST USED LOC.
	TRO	T2,777		;GET TO A PAGE BOUNDARY.
	CAILE	T2,337777	;HAD BETTER FIT IN UNPAGED MEMORY
	 JRST	PDDTNF		;DOES NOT.
	ADD	T2,TBLLNP	;ADD IN SIZE OF REFSTR,
	ADD	T2,TBLLNP+1	;ONCDSK, AND
	ADD	T2,TBLLNP+2	;ONCE.
	ADDI	T2,<NMOCPC*1000>+ONCDDS
	CAML	T2,MEMSIZ##	;DOES ONCE + ONCE PCB, PGY, DDB FIT?
	 JRST	PTSML		;NO, GO TYPE OUT THE PROBLEM.
	MOVEI	T2,1		;YES,  DO THEY FIT IN THE MAP?
BLTCK:	MOVE	T1,TBLLNP(T2)	;GET SIZE, ROUNDED UP TO A PAGE.
	ADD	T1,TBL%%%(T2)	;ADD IN ORIGIN.
	CAMLE	T1,TBL%%%+1(T2)	;PAST NEXT ORIGIN?
	 JRST	BLTBAD		;YES, DIE.
	SOJGE	T2,BLTCK	;NO, GO TO NEXT CHECK.

;EVERYTHING FITS. NOW BLT AND SETUP MAP SLOTS.

	MOVEI	T1,3		;LENGTH OF BLT TABLE.
	MOVE	T2,MEMSIZ##	;FIRST NON-EXIST LOCATION
	SUBI	T2,NMOCPC*1000+ONCDDS ;GET LAST LOCATION OF ONCE CODE
				; ITSELF + 1
BLTLP:	SUB	T2,TBLLNP-1(T1)	;T2=NEW START LOC.
	MOVE	P1,T2		;SAVE IT.
	HRL	T2,TBLSTT-1(T1)	;T2/OLD START,,NEW START.
	HLRZ	T3,TBLLNR-1(T1)	;SET UP T3 AS
	ADDI	T3,-1(T2)	;THE REAL END.
	BLT	T2,(T3)		;BLT.

    ;MAKE MAP ENTRIES FOR THIS MODULE.
	MOVE	U,TBLLNP-1(T1)	;GET U=
	LSH	U,-9		;THE NO. OF MAP ENTRIES.
	MOVE	T3,TBLNEW-1(T1)	;T3/BYTE POINTER.
	MOVE	T2,P1		;T2=
	LSH	T2,-9		;1ST REAL PAGE NO.
MAPLP:	TRO	T2,PGE.A!PGE.W!PGE.C ;MAKE IT A MAP ENTRY.
	IDPB	T2,T3		;INTO THE MAP WITH IT.
	TRZ	T2,PGE.A!PGE.W!PGE.C	;T2=
	AOJ	T2,.+1		;NEXT REAL PAGE NO.
	SOJG	U,MAPLP		;CONTINUE TO MAP.

	MOVE	T2,P1		;T2=CURRENT TOP.
	SOJG	T1,BLTLP	;GO TO NEXT BLT.
				;FALL THRU TO NEXT PAGE
;SETUP EPT LOCATIONS, AND ON KL THE MAP FOR "UNMAPPED" REGION.

	MOVSI	T1,(JFCL)	;SET
IFCPU (KI),<MOVEM	T1,EPT+420>	;TRAP LOCS
	MOVEM	T1,EPT+421	;IN
	MOVEM	T1,EPT+422	;THE
	MOVEM	T1,EPT+423	;EPT.
IFNCPU (KI),<MOVEI	T1,PGE.A+PGE.W+PGE.C+0
	MOVE	T2,[POINT 18,EPT+EPTMP0]	;BUILD A POINTER
EPTMAP:	IDPB	T1,T2		;MAP 0 TO 337
	CAIE	T1,PGE.A+PGE.W+PGE.C+337
	 AOJA	T1,EPTMAP

DEFINE X(A,B)<
	MOVE	T1,['B,,'A]
	PUSHJ	P,CSHCLR##
>;END X MACRO DEFINITION

;HERE IS THE LIST OF REGIONS THAT MUST BE UNCACHED.

>;END IFNCPU (KI)

IFCPU (KL),<
DEFINE UNCACHE<
EXTERNAL IRING,SIZIRG,ORING,SIZORG,SAXBAS,SAXN,CHNUNC,CHNUNE
X	IRING,<1_SIZIRG>
X	ORING,<1_SIZORG>
X	150,165-150+1	;BASE VECTOR
X	30,1		;BASE DEPOSITS IN PHYSICAL LOC 30
X	SAXBAS,SAXN+^D16 ;SA-10 VECTORS
X	CHNUNC,CHNUNE-CHNUNC+1 ;CHANNEL, UNIT DATA BLOCKS.
>;END UNCACHE MACRO DEFINITION

>;END IFCPU (KL)
IFCPU (KS),<
DEFINE UNCACHE<
EXTERNAL IRING,SIZIRG,ORING,SIZORG
X	IRING,<1_SIZIRG>
X	ORING,<1_SIZORG>
X	150,165-150+1	;BASE VECTOR
X	30,1		;BASE DEPOSITS IN PHYSICAL LOC 30
X	31,1		;CTY RELOAD WORD
X	32,1		;CTY INPUT WORD
X	33,1		;CTY OUTPUT WORD
>;END UNCACHE MACRO DEFINITION
>;END IFCPU (KS)

IFCPU (<KL,KS>),<
	UNCACHE			;TURN OFF PGE.C FOR PROPER PAGES.
>;END IFCPU (<KL,KS>)
IFCPU (KL),<

	MOVE	T2,[POINT 18,EPT+EPTMP0]
	MOVSI	T3,-4		;NEED 4 CACHED PAGES.
FNDCSP:	ILDB	T1,T2		;GET SLOT
	TRNN	T1,PGE.C	;THIS ONE CACHED?
	 AOJA	T3,FNDCSP	;NO, LOOK FOR 1 THAT IS.
	MOVEI	T1,1000		;GET ADDRESS
	IMULI	T1,(T3)		;FROM PAGE NUMBER
	HLRE	T4,T3		;GET NUMBER
	MOVMS	T4		;POSITIVE VERSION
	HRRM	T1,CSRTAB-1(T4)	;DONT WIPE OUT (T1).
	AOBJN	T3,FNDCSP
>;END IFCPU (KL)
IFCPU (KI),<MOVE T1,[IG.LLH+NULACB_^D15+UPT.PN,,IG.LRH+IG.TEN+EPT.PN]>
IFNCPU (KI),<MOVE T1,[UPT.PN]>		;GET CURUPT UP SO CAN DO CLRPTA
	MOVEM	T1,CURUPT
IFCPU (KI),<DATAO PAG,[IG.LRH+IG.TEN+EPT.PN]>
IFNCPU (KI),<MOVE	T1,EBRSET
	MOVEM	T1,EPT+EPTEBR
	CLRPTA		;SETUP EBR, TURN ON PAGING
>;END IFNCPU (KI)

	JSP	T4,OPCBST	;Set up special ONCE PCB's
	CLRPTA			;CLEAR PAGING MEMORY, MAP HAS CHANGED
	MOVEI	T1,ONCGOP	;STORE IN
	HRRM	T1,SYSDSP##	;CASE OF RESTART
ONCBUG::JRST	ONCGOP		;AND GO (GOOD PLACE FOR BREAKPOINT)
IFLE <<%REF-%OND>*<%OND-%ONC>>,<
PRINTX ONCE'S TBLS DEF MUST BE ARRANGED LOWEST TO HIGHEST.>

EXTERN REFLNR,REFLNP,ONDLNR,ONDLNP,REFSTT,ONDSTT,SYSDRB

DEFINE TBLS
< X ONC
  X OND
  X REF>

;SIZE ROUNDED UP TO A PAGE.
DEFINE X(A)
< A'LNP>
TBLLNP: TBLS

DEFINE X(A)
<EPTPGP (%'A'.N-1)>
TBLNEW: TBLS

;REAL SIZE,, OLD STARTING LOC.
DEFINE X(A)
<A'LNR,,A'STT>
TBLSTT:
TBLLNR: TBLS

DEFINE X(A)
<%'A>
TBL%%%: TBLS
;HERE ARE THE ERROR ROUTINES

PTSML:	PUSH	P,T2	;SAVE AMOUNT NEEDED
	MOVEI T1,[ASCIZ /
MUST HAVE /]
	PUSHJ	P,PAGTYP	;TYPE INFORMATION ON ERROR
	POP	P,T1
	LSH	T1,W2PLSH	;CONVERT TO PAGES
	PUSHJ	P,PAGDEC
	MOVEI	T1,[ASCIZ / CONTIGUOUS MEMORY PAGES ON LINE
TO LOAD THIS MONITOR, ONLY /]
	PUSHJ	P,PAGTYP
	MOVE	T1,MEMSIZ##
	LSH	T1,W2PLSH	;CONVERT TO PAGES
	PUSHJ	P,PAGDEC
	MOVEI	T1,[ASCIZ / PAGES ON LINE BEFORE FIRST HOLE.
/]
	PUSHJ	P,PAGTYP
	HALT	PTSML	;PAGES TOO SMALL TO BRING UP MONITOR

PTINTR:	MOVEI T1,[ASCIZ /
INTERLEAVE SET INCORRECTLY OR MEMORY BOX OFF-LINE
ADDRESS /]
	PUSHJ P,PAGTYP
	MOVEI T1,3
INTLP:	WRAPR CLRNXM
	ADDI T3,1
	MOVE T2,20(T3)
	CONSO APR,APRNXM
	SOJG T1,INTLP
	MOVE T1,T3
	PUSHJ P,PAGOCT
	MOVEI T1,[ASCIZ / (OCTAL)
/]
	PUSHJ P,PAGTYP
	HALT	PTINTR		;PT INTERLEAVING INCORRECT

BLTBAD:	MOVEI T1,[ASCIZ /
ONCE CODE BLT BAD, NOTIFY OPERATING SYSTEMS
/]
	PUSHJ	P,PAGTYP
	HALT	BLTBAD		;ONCE CODE BLT BAD

PDDTNF:	MOVEI	T1,[ASCIZ/
VIRGIN MONITOR DOES NOT FIT WITHIN 340000(8) LOCATIONS.
NOTIFY OPERATING SYSTEMS GROUP.
/]
	PUSHJ	P,PAGTYP
	HALT	PDDTNF		;MONITOR BIGGER THAN 340000

PAGTYP:	HRLI	T1,(POINT 7,0)
PAGTY2:	ILDB	T2,T1
	JUMPE	T2,PAGPOP
	PUSHJ	P,PAGTYO
	JRST	PAGTY2

;TTY output routines

PAGOCT:	MOVEI	T4,10
	JRST	PAGDC1
PAGDEC:	MOVEI	T4,^D10
PAGDC1:	IDIVI	T1,(T4)
	HRLM	T2,(P)
	SKIPE	T1
	PUSHJ	P,PAGDC1
	HLRZ	T2,(P)
	ADDI	T2,"0"
PAGTYO:	PUSH	P,T1
	EXCH	T2,T3
	PUSHJ	P,CTYTYO##	;Output character in T3
	POP	P,T1
	EXCH	T2,T3
PAGPOP:	POPJ	P,

PATSYM::JSR	MOVSTP		;MOVE SYMBOL TABLE POINTER
	JRST	DDT##		;AND START EXEC DDT

MOVSTP:	0			;ROUTINE TO MOVE SYMBOL TABLE POINTER
	MOVE	T1,JOBSYM##
	MOVEM	T1,DDTSYM##	;MOVE THE SYMBOL TABLE POINTER
	MOVEI	T1,DDT
	HRRM	T1,SYSDDT##	;MAKE FOR ANOTHER RESTART
	MOVE	T1,[JRST @MOVSTP]
	MOVEM	T1,MOVSTP+1	;DO THIS ONLY ONCE
	JRST	@MOVSTP		;AND RETURN

SYSZRO::SETZM	DDT		;ZERO OUT DDT
	MOVE	T1,[DDT,,DDT+1]
	BLT	T1,DDTEND##-1
	MOVE	T1,JOBSYM##
	SETZM	(T1)		;ZERO OUT THE SYMBOL TABLE
	AOBJN	T1,.-1
	MOVE	T1,[HALT 142]	;CANNOT RESTART
	MOVEM	T1,142
	EXIT
;PROCESSOR AND CLOCK INITIALIZATION

APRINI:	0
IFCPU (KI),<JRST @APRINI>
IFCPU (<KL,F3>),<
	WRAPR	LP.IOR+LP.CSF+LP.DSF+APRMSK+0B35   ;CLEAR ALL FLAGS
	WRPI	LI.CPP+LI.CPS+LI.COF+LI.PIF+LI.ACO ;AND PI SYSTEM
IFCPU (KL),<
	SWPIA			;THROW AWAY BAD CACHE DATA
	CONSZ	APR,LP.CSB	;WAIT FOR SWEEP BUSY TO CLEAR
	 JRST	.-1
	WRAPR	LP.CSF+LP.CSD	;AND NOW CLEAR SWEEP DONE.
>;END IFCPU (KL)
	WRADB	[0]		;TURN OFF ADDRESS BREAK
	MOVE	T1,[EPT,,EPT+1]
	SETZM	EPT
	BLT	T1,EPT+777	;CLEAR ENTIRE EPT OUT
IFCPU (F3),<
	MOVEI	T1,EPT+EPTACB##
	MOVEM	T1,EPT+EPTACP
>;END IFCPU F3
	WREBR	0		;TO AVOID BUG IN KS10 MICROCODE
	WREBR	EPT.PN		;SET EPT UP FOR CTY ROUTINES
	WRUBR	[LG.LUB+UPT.PN]	;SET UPT UP TO NULL JOB'S UPT
	MOVEI	T1,UUOKNT
	MOVEM	T1,UPT+UPTKNT	;IN CASE OF UUO ERROR
	MOVEI	T1,PGFAIL	;IN CASE OF PAGE FAIL
	MOVEM	T1,UPT+UPTNPP
	MOVEI	T1,UUOKTR	;IN CASE OF PDL OVERFLOW OR SOMETHING
	MOVEM	T1,UPT+UPTKTR
	MOVEI	T1,EXCPDL	;PDL OVERFLOW INSTRUCTION
	MOVEM	T1,EPT+EPTPOV	;AN MUUO THAT GOES TO UUOKTR.
	EXECAC			;USE EXEC MODE ACS
IFCPU (KL),<
	CONO	TIM,TO.CIT+TO.CTD	;CLEAR INTERVAL TIMER
	CONO	MTR,MO.LAC+MO.TOF+MO.CTB ;CLEAR TIME BASE, TURN ACCOUNTING OFF
>;END IFCPU (KL)
	MOVEI	T1,NUMACB-1	;HIGHEST AC BLOCK NUMBER TO START WITH
APRIN1:	CAIN	T1,EX0ACB	;SKIP OVER ONE WE'RE USING
	 JRST	APRIN2		;DON'T TOUCH
	MOVSI	T2,(LG.LAB+<EX0ACB>B8)
	DPB	T1,[POINT 3,T2,11] ;PUT INTO PREVIOUS AC FIELD
	WRUBR	T2		;SET PREVIOUS ACS
	MOVEI	T2,1		;0,,1
	XCTBU	<SETZM 0>	;CLEAR OUT 0
	XCTBU	<BLT T2,17>	;AND THE REST
APRIN2:	SOJGE	T1,APRIN1	;AND GO FOR ALL AC BLOCKS

	EXECAC			;BACK TO EXEC ACS
IFCPU (KL),<
	MOVE	T1,[POINT 3,CSATAB]
	MOVSI	T2,-200		;HOW BIG CACHE REFILL TABLE IS.
CSALUP:	ILDB	T3,T1		;GET NEXT 3 BIT DATA
	LSH	T3,^D35-^D20	;GET IT TO BIT 20
	DPB	T2,[POINT 7,T3,33]
	WRFIL	(T3)
	AOBJN	T2,CSALUP	;GO FOR MORE.
>;END IFCPU (KL)
	JRST	@APRINI
> ;END IFCPU (<KL,F3>).

IFCPU (KS),<
	WRAPR	LP.IOR+LP.CSF+APRMSK	;CLEAR ALL FLAGS
	WRAPR	LP.DSF+LP.TIM		;DISABLE TIMER
	WRPI	LI.CPP+LI.CPS+LI.COF+LI.PIF+LI.ACO ;AND PI SYSTEM
	WRHSB	[HLTSTS##]	;SET THE ADDRESS FOR HALT STATUS BLOCK
	EXECAC			;USE EXEC MODE AC
	WREBR	EPT.PN		;SET UP EPT
	SETZM	RLWORD##	;BE SURE KEEP ALIVE FLAG OFF
	MOVEI	T1,6		;AVOID AC BLOCK 7, MICROCODE USES IT.
APRIN1:	CAIN	T1,EX0ACB	;SKIP OVER ONE WE'RE USING
	 JRST	APRIN2		;DON'T TOUCH
	MOVSI	T2,(LG.LAB+<EX0ACB>B8)
	DPB	T1,[POINT 3,T2,11] ;PUT INTO PREVIOUS AC FIELD
	WRUBR	T2		;SET PREVIOUS ACS
	MOVEI	T2,1		;0,,1
	XCTTU	<SETZ 0,>	;CLEAR ALL THE ACS
	XCTTU	<BLT T2,17>	;
APRIN2:	SOJGE	T1,APRIN1	;AND GO FOR ALL AC BLOCKS

	EXECAC			;BACK TO EXEC ACS
	MOVEI	T1,EPT+1
	HRLI	T1,EPT
	SETZM	EPT
	BLT	T1,EPT+777	;CLEAR ENTIRE EPT OUT
	JRST	@APRINI
>;END IFCPU (KS)

IFCPU (<KL,F3>),<
EBRSET:	LG.CSL+LG.CSW+LG.TEN+EPT.PN> ;LOCATION TO SET EPTEBR FROM - MUST BE IN UNPAGED AREA.
IFCPU (KS),<EBRSET: LG.TEN+EPT.PN>

IFCPU (KL),<;DATA FOR LOADING 4 CACHE REFILL ALGORITHM
CSATAB:	012345673123
	212371271127
	656755670323
	022301234567
	077700074666
	446431331113
	077700070123
	4567455
	012201210566
	056045654564
	012345670000
> ;END IFCPU(KL)
	LIT
	VAR
;HERE IS THE CODE WHICH GETS MOVED TO THE TOP OF CORE.

ONCSTT:				;DEFINE "OLD" STARTING LOC.

	PHASE	%ONC
	STOPCD(,ENTRY,ONCE)	;Default for NONAME stopcodes

%O==:ONCSTT-%ONC	;Offset for phased code
			;To patch SYSTEM.SAV, use LABEL+%O/

;HERE ARE THE TEMPORARY "PCBS" FOR ONCDSK AND REFSTR.
; PAGE NUMBERS GET FILLED IN AFTER IT IS DETERMINED WHERE ONCE CODE WILL
; LIVE IN PHYSICAL MEMORY.

ONCPCB::

CCOUNT==NMOCPC

DEFINE X (A)
<INTERNAL %'A'.P
%'A'.P:	Z
Z
Z
CCOUNT==CCOUNT-1
IFE CCOUNT,<Z>
IFN CCOUNT,<EXP %'A'.P+4>
>

OPCNAM



;HERE IS THE TABLE OF PCB ADDRESSES.

DEFINE X (A)
<XWD 0,%'A'.P
>

OPCBTB:
OPCBTB:	OPCNAM
Z
;HERE IS A LIST OF VIRTUAL ADDRESSES WHICH CORRESPOND TO
; THE INDEX INTO OPCBTB, FOR USE IN CONVERTING PCB ADDRESS
; INTO VIRTUAL ADDRESS TO LOOK IN FOR DATA.

DEFINE X (A)
<EXP %'A'
>;END MACRO DEFINITION
OPCADR:	OPCNAM



;HERE IS THE TABLE OF MAP SLOT POINTERS FOR THE PCBS.

DEFINE X (A)
<EPTPGS(%'A'.N,EPT)>

MPSLOT:
OPCNAM



ONCDDB::0			;LOCATION OF ONCE ONLY DDB THAT ONCDSK USES.
OPCLOW:	0			;LOWEST PHYSICAL PAGE USED FOR ONCE PCB PAGES.

IFCPU (KS),<
EUBRBT:	EPT+EPTUB0,,EPT+EPTUB1	;BLT WORD TO SETUP VECTOR INTERRUPT TBLS
    >; END IFCPU (KS)
EPGTBT:	EPTSET,,EPT+EPTPGT	; BLT pointer to EPT trap vectors
UPGTBT:	UPTSET,,UPT+UPTPGT	; BLT pointer to UPT trap vectors
UPGTB0:	UPTSET,,0+UPTPGT	; BLT pointer to UPT trap vectors for page 0
EPIBLT:	LOC42,,EPT+42		;BLT WORD TO SETUP PI LOCS 40-61
CNCLBT:	CONFIG,,CONFIG+1	;BLT POINTER TO CLEAR CONFIG AREA
CNFCPY:	CONFIG,,CPYFIG		;BLT POINTER TO COPY CONFIG NAME/DATE
CPYBPT:	POINT 7,CPYFIG		;BYTE POINTER TO COPY OF CONFIG AREA
CNFBPT:	POINT 7,CONFIG		;BYTE POINTER TO CONFIG NAME/DATE

ONCWBR:
    IFCPU (KI),<XWD IG.LLH+NULACB_^D15+UPT.PN,IG.LRH+IG.TEN+EPT.PN>
    IFNCPU (KI),<EXP LG.LUB+UPT.PN>
ONCACB:
    IFCPU (KI),<XWD <UPTAC0-20>_9,%UPT+UPTAC0+17>
    IFNCPU (KI),<EXP LG.LAB+<EX0ACB>B8+<USRACB>B11+%UPT+UPTAC0+16>

;ROUTINE WHICH TAKES A PCB ADDRESS IN PG AND RETURNS THE VIRTUAL ADDRESS
; OF THE PCB'S DATA IN T2.
;CALLED BY ONCDSK. PRESERVES ALL ACS.

GETPEV::PUSH	P,T4		;PRESERVES ALL ACS
	SETZ	T4,
GETPE1:	SKIPN	T2,OPCBTB(T4)	;GET PCB ADDRESS
	 STOPCD                         ;;GETPE1+1
	CAME	PG,T2		;SAME?
	AOJA	T4,GETPE1	;NO, LOOK AT NEXT.
	MOVE	T2,OPCADR(T4)	;YES, GET ADDRESS
	POP	P,T4		;RESTORE T4 AND
	POPJ	P,		;RETURN.
;NOW MOVE THE SYMBOL TABLE DOWN

ONCGOP:	MOVEI	P,SYSPDL##
	MOVEI	T1,DDTEND##+100	;LEAVE SOME EXTRA SPACE
	CAMGE	T1,PATSIZ##	;MAKE SURE SOMEONE NOT TRYING TO RESERVE SPACE
	 HRRZ	T1,PATSIZ##	;THEY ARE, USE THAT AS PLACE TO BLT SYMBOLS TO
	HRL	T1,DDTSYM##	;PLACE TO BLT SYMBOLS FROM
	HRRM	T1,DDTSYM##	;STORE NEW HOME ADDRESS FOR SYMBOL TABLE
	HLRE	T2,DDTSYM##
	MOVNS	T2		;GET SIZE OF SYMBOL TABLE
	ADDI	T2,-1(T1)	;GET LAST ADDRESS IN T2
	HLRZ	T3,T1		;GET SOURCE ADDRESS
	CAILE	T3,(T1)		;MAKE SURE ITS BEING BLTTED DOWN
	 JRST	ONCG1A		;YES, JUST NORMAL BLT
	ADDI	T3,(T2)		;1ST SOURCE + LAST DEST - FIRST DEST
	SUBI	T3,(T1)		;GIVES LAST SOURCE.
SYMBK0:	MOVE	T4,(T3)		;MOVE SOURCE TO DEST
	MOVEM	T4,(T2)
	SUBI	T3,1		;SUBTRACT ONE FROM SOURCE ADDRESS
	CAIE	T2,(T1)		;DID JUST MOVE ONE TO FIRST DEST?
	 SOJA	T2,SYMBK0 	;NO, KEEP GOING
	JRST	ONCGP0		;OK, DONE.
ONCG1A:	BLT	T1,(T2)		;HERE IS WHERE END GOES
ONCGP0:	MOVEI	T1,ONCGP1	;DO NOT EXECUTE MORE THAN ONCE
	HRRM	T1,SYSDSP##	;SET FOR 140 RESTART

;RETURN HERE FROM DDT VIA 140$G

ONCGP1:	MOVEI	P,SYSPDL##
	WRAPR	APRIOB		;DO AN IOB RESET
IFCPU (KI),<WRPI  PIPOW>	;AND RESET PI POWER FAILURE INTERUPT
IFNCPU(KI),<WRAPR LP.CSF+LP.PWF>
	MOVE	T1,UPGTBT
IFNCPU(KS),<BLT  T1,UPT+UPTPTR>	;SET UP TRAPS LOCS
IFCPU (KS),<BLT  T1,UPT+UPTCTR+2>
	MOVE	T1,UPGTB0
	BLT	T1,0+UPTPTR	;SET UP TRAP LOCS in PAGE 0
IFNCPU(KI),<
	MOVE	T1,PGFUIO	;PAGE FAIL NEW PC
	MOVEM	T1,UPT+UPTNPP	;PAGE FAIL NEW PC WORD.
	MOVEM	T1,0+UPTNPP	;PAGE FAIL NEW PC WORD for page 0.
>;END IFNCPU (KI)
	MOVE	T1,EPGTBT	; EPT-PGT BLT WORD
	BLT	T1,EPT+EPTTR3	;BLT
	MOVE	T1,[JSR LUUOPC##];Error routine in ERRCON (calls S..EUE)
IFCPU (KI),<MOVEM T1,EPT+41>	;NO LUUOS
IFNCPU(KI),<MOVEM T1,41>	;KL,KS use Exec virtual address 40 and 41
	MOVEI	T1,UPT.PN+PGE.A+PGE.W+PGE.P+PGE.C
	DPB	T1,EPYPSN	;SET POINTER [EPTPTR(%UPS.N)]
	SETZM	UPSJOB		;NO ONE IS MAPPED THRU HERE.
IFNCPU(KI),<WRUBR     ONCWBR>
IFCPU (KI),<DATAO PAG,ONCWBR>
	DPB	T1,USYPTN	;AND SET IN UPT [UPSPTR(%UPT.N)]
	CLRPTA			;MAPPING GOES INTO EFFECT.
	MOVE	T1,ONCACB
	MOVEM	T1,UPT+UPTACP
	JRSTF	@[PC.UIO,,.+1]	;MAKE SURE USER I/O IS ON
IFCPU (KI),<
	MOVSI	17,NULACS
	XCTTU	<BLT 17,17>	;LOAD NULL JOB ACS
	MOVSI	T1,PC.UIO!PC.USR!PC.PUB	;SET NULL PC (LOC 0)
	MOVEM	T1,UPT+UPTPC
>;END IFCPU (KI)
IFCPU (KI),<
	CONI	PAG,T1		;READ PAGER TO GET REAL SERIAL NUMBER
	LDB	T1,[POINT 10,T1,9]
>;END IFCPU (KI)
IFNCPU (KI),<
	APRID	T1		;GET SERIAL NUMBER, UCODE VERSION, ETC.
	ANDI	T1,APRSER	;JUST SERIAL NUMBER
>;END IFNCPU (KI)
	SKIPE	T1		;Don't wipe out previous value on F3
	 MOVEM	T1,SERIAL
	MOVEI	T1,^D60
IFCPU (KI),<;NON-KI10 MACHINES ALWAYS 60HZ
	RDAPR	T2
	TLNE	T2,(1B6)		;CHECK FOR 50 HZ
	 MOVEI	T1,^D50
>;END IFCPU (KI)
	MOVEM	T1,JFYSEC##
	MOVEM	T1,TICSEC##
	IMULI	T1,^D60
	MOVEM	T1,JFYMIN##
	IMULI	T1,^D60
	MOVEM	T1,JFYHR##
	IMULI	T1,^D24
	MOVEM	T1,MIDNIT##
	MOVE	T1,JFYSEC##
	MOVSI	T2,(1B6)
	CAIE	T1,^D60
	 IORM	T2,STATES##	;SET STATES BIT IF 50 CYCLE
	IMULI	T1,2
	MOVEM	T1,JFY2SC##	;Jiffies per 2 seconds
	IDIVI	T1,^D24
	MOVEM	T1,JFYS12##	;Jiffies per 1/12 second
	MOVE	T1,JFYSEC##
	IDIVI	T1,2
	MOVEM	T1,JFYSC2##	;Jiffies per 1/2 second
	MOVEM	T1,QQYTTY##
	IDIVI	T1,5
	MOVEM	T1,QQYSD##	;Jiffies per 1/10 second

;SETUP LOCATIONS 40 THRU 61

	MOVE	T1,EPIBLT	;SETUP LOWER CORE PI LOCATIONS
	BLT	T1,EPT+57
IFCPU (KL),<
	MOVSI	T1,(HALT)
	MOVEM	T1,EPT+EPTITI
	MOVEM	T1,EPT+EPTDT0+DTEDII
>;END IFCPU (KL)
;LINK DEVICE SERVICE ROUTINES TOGETHER (INTERUPT CHAIN)

	MOVSI	T1,INTNUM	;NO, NEGATIVE NUMBER OF SERVICE ROUTINES*2
INTLOP:	HLRZ	U,INTTAB(T1)	;GET NEXT PI NUMBER
	ANDI	U,7		;MASK OUT NUMBER OF DDB'S

	LSH	U,1		;SHIFT LEFT ONE SO MATCH PI LOCATIONS
	JUMPE	U,NOPICH	;DOES THIS DEVICE HAVE A PI CHANNEL (PTY) ?
	MOVE	J,EPT+40(U)	;YES, PICK UP JSR CH'N FROM LOWER CORE
INTLP1:	MOVE	U,J		;SAVE IT IN U (EITHER A JRST DEV'NT OR
				; JEN @CH'N
	MOVE	J,1(U)		;PICK UP INSTR. FOLLOWING INTERRUPT CONSO
	TLNN	J,000740	;IS IT A JEN ?
	 JRST	INTLP1		;NO, KEEP LOOKING
	MOVE	T2,INTTAB(T1)	;YES, LAST DEVICE SO FAR, GET DEV'NT
	HRLI	T2,(JRST)	;MAKE JRST INSTR.
	MOVEM	T2,1(U)		;CHANGE JEN @CH'N TO JRST DEV'NT
	MOVEM	J,1(T2)		;MAKE DEV'NT+1 BE JEN @CH'N
NOPICH:	AOBJN	T1,.+1		;PICKUP EVERY OTHER WORD
	AOBJN	T1,INTLOP	;ANY MORE INTERRUPT SERVICE ROUTINES ?

IFCPU (KS),<

EXTERN TBISAV,TBISIZ
    ;SET UP TBLUBA FOR THE KS.
	MOVSI	T1,-TBISIZ	;Number of vectors in table
SETUBT:	HRRZ	T2,TBISAV(T1)	;GET VECTOR/4.
	MOVSI	T3,(JSR)	;BUILD JSR DEVINT.
	HLR	T3,TBISAV(T1)	;GET INTERRUPT ROUTINE ADDRESS.
	SKIPE	EPT+EPTVIT(T2)	;BETTER NOT BE ANOTHER WITH
	 STOPCD                         ;;SETUBT+4
	MOVEM	T3,EPT+EPTVIT(T2) ;SAME DISPATCH LOCATION.
	AOBJN	T1,SETUBT	;Loop TBISIZ times

    ;SET UP THE EPT SLOTS FOR THE VECTOR INTERRUPT TABLE PNTRS.
	SETZM	EPT+EPTUB0	;HOPE STRANGE ONES DIE IN LOW CORE.
	MOVE	T1,EUBRBT
	BLT	T1,EPT+EPUB17
	MOVEI	T1,EPT+EPTVIT	;ONLY UBA1 AND
	MOVEM	T1,EPT+EPTUB1	;UBA3
	MOVEM	T1,EPT+EPTUB3	;PRESENTLY EXIST.

;NOW SET THE UBA1'S PIA

EXTERNAL PIHIGH,PILOW

	MOVEI	T1,PIHIGH*10+PIHIGH
	WRIO	T1,@[UA1,,UBAADR]

;NEED TO PUT IN UBA3'S AT SOME TIME


> ;END IFCPU (KS).


	MOVEI	T1,ONCGP2
	HRRM	T1,SYSDSP##	;ONLY DO THIS ONCE

ONCGP2:	MOVEI	P,SYSPDL##
	PUSHJ	P,ONCTOS	;SET UP TTY
	PUSHJ	P,OHTINI##	;INIT THIS HERE SO OUTPUT ERROS
				; ARE CLEARED ON RESTART.
	PUSHJ	P,PRTSYS##	;Output SYSNO and monitor version
	PUSHJ	P,OPOUT
	PUSHJ	P,GETSYN	;SETUP serial FOR TTYINI, EVERYONE ELSE.
	HLRO	T1,DDTSYM##	;GET SIZE TO USE FOR SYSSIZ
	MOVNS	T1
	ADD	T1,DDTSYM##
	IORI	T1,777		;START WITH A FRESH PAGE
	ADDI	T1,1
	HRRZM	T1,SYSSIZ	;THIS IS IT, TOP OF SYMBOLS
IFCPU (KI),<;ONLY KI HAS DK10 UCYCLE CLOCK
CHKCLK:	CONSZ	CLK,1B26
	 JRST	ONCTST		;ON EXTERNAL
	PUSHJ	P,INLMES
	 ASCIZ	/
CLOCK ON INTERNAL - RESET AND TYPE <RETURN>
/
	PUSHJ	P,OPOUT
	PUSHJ	P,GETLIN
	 JRST	CHKCLK
	 JRST	CHKCLK
>;END IFCPU (KI)
	PFALL	ONCTST
;THIS IS THE MAIN SCAN DISPATCH ROUTINE.
;NOTE *** This is different than the macro copied from ONCDSK!!!

	DEFINE SCAN (A) <
	MOVEI	P1,SCN'A		; Get address of Scan Table
	SETZM	CMDSCF##		; Specify NO STR/UNIT stuff
	PUSHJ	P,CMDSCN##		; Call Scanning routine
	  JRST	HLP'A			; No good!
	XCT DSP'A'(P3)			; Yes?
	JRST	A'CMD			; Return as if cr typed.

A'HLP:	MOVE	P3,-2(P1)		; Setup AOBJN pointer for messages
A'HL1:	HRRZ	T1,(P3)			; Get address of message
	PUSHJ	P,LNGMES		; Print a long message
	AOBJN	P3,A'HL1		; Next?
	JRST	A'CMD			; Return.
>

	DEFINE SCNTB (NAM) <
	DEFINE X(SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	INS>	;INSTRUCTION TO EXECUTE

	JRST NUL'NAM		;FOR -1 RETURN
DSP'NAM: MK'NAM			;GENERATE DISPATCH TABLE
	SIZ'NAM==.-DSP'NAM
	-SIZ'NAM,,TXT'NAM	;AOBJN POINTER TO HELP
	-SIZ'NAM,,SCN'NAM	;AOBJN POINTER TO NAMES
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	<SIXBIT /SYM/>>
	LALL
SCN'NAM: MK'NAM			; Define Table to read
	SALL
	$XZ==0			; Need a counter
	DEFINE XZ$(ARGH)<LIT$'ARGH==.>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	xz$(\$XZ)
	ASCII \TEXT'TEXT1'TEXT2'TEXT3\
	Z
	$XZ==$XZ+1>
	MK'NAM
	$XZ==0
	DEFINE XZ$(ARGH)<LIT$'ARGH>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	XWD	BIT,XZ$(\$XZ)
	$XZ==$XZ+1>
	LALL
TXT'NAM: MK'NAM
>

	AB.ACK==:0B18		; OK (ACKnowledged) for ABbreviations.
	AB.NAK==:1B18		; OK (Not AcKnowledged) for ABbreviations.
	AB.VER==:1B19		; VERIFICATION required for Command.
	AB.TCV==:1B20		; Verify if TYPE or CHANGE (TYPONL) [ONCDSK]
	AB.CVR==:1B21		; No verify if at CONSOLE level

;NOW THE ACTUAL CODE

ONCTST:			;PFALL here from above
IFCPU (<KL,F3>),<
	WRAPR	LP.ESF+APRMSK+APRCHN	;ENABLE FOR SAKE OF PARITY ERRORS AND CACHE SWEEP DONE.
	WRPI	LI.PIN+LI.CON+<1_<7-APRCHN>> ;ALLOW APR TO INTERRUPT.
>;END IFCPU (KL)
IFCPU (KS),<
	WRAPR	LP.ESF+APFMSK+LP.HPE+APRCHN	;ENABLE FOR ERRORS
	WRPI	LI.PIN+LI.CON+<1_<7-APRCHN>>	;ALLOW APR TO INTERRUPT
>;END IFCPU (KS)
	MOVSI	T1,400000
	MOVEM	T1,THSDAT
	MOVEM	T1,TIME		;TIME AND DATE NOT RECEIVED FROM SUP
	MOVE	T2,REONCE	;GET ONCE COPY OF RESTRT WORD
	HLRZ	T1,T2		;POSITION VALIDATOR FOR TESTING
	CAIE	T1,RESCOD	;IS RESTRT VALID?
	 SETZB	T2,REPSID	;No, clear for RECOMP and ONCDSK
	MOVEI	T3,RE.OND	;COMPUTE ACTION FOR
	PUSHJ	P,RECOMP+1	; ONCE RESTART
IFCPU(<KI,KL>),<;Can't trust serial # on KS or F3
	HRRZ	T1,.CPCPU##	;Get CPU number monitor was built for
	CAMN	T1,SERIAL##	;Match APR serial number?
	 JRST	ONCTS1		;OK (check bits in T2)
	MOVEI	T1,[ASCIZ /
%% CPU serial number is /]
	PUSHJ	P,OCONM
	MOVE	T1,SERIAL##
	PUSHJ	P,PRTDEC##
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /.  This monitor was built for a different system.
Are you SURE you want to proceed? /]
	PUSHJ	P,YESNO		;Skip if "Y"
	  JRST	SYSBTS##	;Go get BOOTS if "N"
	MOVEI	T1,[ASCIZ /
Please notify TYMCOM-X Support Group if this is a permanent change.
/]
	JRST	HLPCM1		;Do NOT go into auto restart
>  ;END IFNCPU(KS)
ONCTS1:	TRNN	T2,RE.ONA	;MANUAL ONCE DESIRED?
	 JRST	AUTORS		;NO: DO AUTO RESTART
	MOVEI	T1,[ASCIZ /
/]				; Type a free CRLF
	JRST	HLPCM1		;   on entry.

HLPCMD:	MOVEI	T1,[ASCIZ /
?Unrecognized command - Please type HELP for help.
/]
HLPCM1:	PUSHJ P,OCONM
	PUSHJ P,OPOUT
TYPCMD:				; ** return from SCAN macro **
CHGCMD:				; ** return from SCAN macro **
CMDCMD:				; ** return from SCAN macro **
NULCMD:				; ** LABEL FOR NULL RETURN **
ONCCMD:	MOVEI T1,[ASCIZ /
ONCE>/]				;COMMAND PROMPT
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	PUSHJ P,GETLIN
	 JRST ONCCMD
	SCAN (CMD)		;SCAN FOR A COMMAND


	DEFINE MKCMD	<

X	TYPE,<JRST TYPIT>,AB.ACK,<
TYPE     Report information about the system.
         TYPE CORE   - the default minimum core available to users.
         TYPE SYSTEM - reports the system number.>
X	CHANGE,<JRST CHGIT>,AB.ACK,<
CHANGE   Change information about the system.
         CHANGE CORE   - changes the default minimum user core.
         CHANGE SYSTEM - changes the system number.>
X	FULL,<JRST FULLRS>,AB.NAK,<
FULL     Bring up the system with a FULL DSKCLN.  If there is any
         question about the integrity of the file system, then this>,<
         command should be used in place of GO.  Unless authorized,
         DO NOT enter the FILES dialogue to set the DSKCLN type.>
X	GO,<JRST AUTORS>,AB.ACK,<
GO       Bring up the system with the default settings and starts
         the auto-restart process.>
X	FILES,<PUSHJ P,FILES>,AB.NAK!AB.VER,<
FILES    Enter the FILES dialogue.  This is the subsystem of ONCE
         which is normally used ONLY for restructuring or repairing>,<
         the disk file system.  The commands in this subsystem could
         damage the file system if they are used incorrectly.  If you>,<
         are NOT sure of what you are doing, DO NOT enter this section.>
X	READONLY,<JRST REDOLY>,AB.ACK!AB.VER!AB.CVR,<
READONLY Bring up the system SHUT for emergency examination.
         Writing on the disk is prevented until DSKCLN has been run.>,<
         Note: The system cannot be UNSHUT until DSKCLN has been run.>
X	INITIA,<PUSHJ P,FLGINI>,AB.ACK,<
INITIA   Run DSKCLN, then CHKPNT, COPYCRASH, and XEXEC (auto restart).>
X	NOINITIA,<PUSHJ P,FLGNOI>,AB.ACK,<
NOINITIA Run DSKCLN but not XEXEC (when doing an all-files restore.)>
X	CONSOLE,<PUSHJ P,FLGCTY>,AB.ACK,<
CONSOLE  Allow the system to be brought up on the CONSOLE terminal ONLY.
         The system MUST be reloaded before it can be brought up on the>,<
         network.  This command should be followed by a command to bring
         up the system (one of: GO, FULL, MANUAL or READONLY).>
X	NETWORK,<PUSHJ P,FLGNET>,AB.ACK,<
NETWORK  Allow the system to be brought up on the NETWORK (default).
         This allows normal access to the system and overrides any>,<
         previous CONSOLE or NETWORK commands.  This command should be
         followed by a command to bring up the system. (see CONSOLE.)>
X	DEBUG,<PUSHJ P,ODEBUG##>,AB.NAK,<
DEBUG    Set the DEBUGFLAG to output more information on the console at
         startup and when a stopcode occurs.>
X	DDT,<PUSHJ P,DDT>,AB.NAK,<
DDT      Enter executive DDT.  To be used ONLY by software wizards
         for emergency patching and examination of the monitor.>,<
         UNDER NO CIRCUMSTANCES SHOULD YOU NORMALLY USE THIS COMMAND!>
X	MANUAL,<JRST MANRS>,AB.ACK!AB.VER!AB.CVR,<
MANUAL   Bring up the system in the SHUT state for DEBUGGING ONLY!
         The auto-restart process is not performed.>,<
         Note: You may not UNSHUT the system until DSKCLN has been run.>
X	BOOTS,<JRST SYSBTS##>,AB.NAK!AB.VER,<
BOOTS    Bring in BOOTS (to load a different monitor).>
IFKMC<
X	KMC,<JRST KMCMAN>,AB.ACK,<
KMC      Bring the system up loading the KMC-11 but without the>,<
         rest of the automatic restart procedure.  This must NEVER>,<
         be used for a restart after a system CRASH.  ONLY to be
         used when the system has been taken down gracefully and>,<
         DSKCLN has already been run.>
>;END IFKMC
X	HELP,<JRST CMDHLP>,AB.ACK,<
HELP     Type out this message.
>
>

	SCNTB (CMD)

TYPIT:	SETOM TYPONL	;ONLY TYPOUT
	SCAN (TYP)

	DEFINE MKTYP <
	X CORE,<PUSHJ P,TYPCOR>,AB.ACK,<
TYPE CORE   - Type the default minimum core available to users.>
	X SYSTEM,<PUSHJ P,TYPSYS>,AB.ACK,<
TYPE SYSTEM - Type the system number.>
	X HELP,<JRST TYPHLP>,AB.ACK,<
TYPE HELP   - Type out this message.
>
>
	SCNTB (TYP)
NULTYP:
HLPTYP:	MOVEI T1,[ASCIZ /
Type  "TYPE HELP"  for a list of options.
/]
	JRST	HLPCM1


CHGIT:	SETZM TYPONL	;NEED ANSWER
	SCAN (CHG)

	DEFINE MKCHG <
	X CORE,<PUSHJ P,CHGCOR>,ab.nak!ab.ver,<
CHANGE CORE   - Change the default minimum core available to users.>
	X SYSTEM,<PUSHJ P,CHGSYS>,ab.nak!ab.ver,<
CHANGE SYSTEM - Change the system number.  (This should ONLY be
                done when bringing up a system on hardware other>,<
                than what it was originally built for).>
	X HELP,<JRST CHGHLP>,ab.ack,<
CHANGE HELP   - Type out this message.
>
>
	SCNTB (CHG)
NULCHG:
HLPCHG:	MOVEI T1,[ASCIZ /
Type  "CHANGE HELP"  for a list of options.
/]
	JRST	HLPCM1

	XALL
;CHANGE AND TYPE ROUTINES

TYPCOR:	HRRZ P1,CORLIM
	MOVEI T1,[ASCIZ /Default minimum user core = /]
	PJRST DECLOP

TYPSYS:	MOVE	P1,SYSNUM	;GET SYSTEM NUMBER.
	MOVEI T1,[ASCIZ /System number = /]
	PJRST DECLOP

CHGCOR:	HRRZ P1,CORLIM
	MOVEI T1,6
	MOVEM T1,MIN
	MOVEI T1,^D256
	MOVEM T1,MAX
	MOVEI T1,[ASCIZ /Default minimum user core = /]
	PUSHJ P,ASKQMM
	 POPJ P,
	HRRM T2,CORLIM
	POPJ P,

CHGSYS:	MOVE	P1,SYSNUM	;Get current system number
	MOVEI	T1,^D1
	MOVEM	T1,MIN
IFCPU (<KI,KL>),<		;EBUS bases get the host number from the
	MOVEI	T1,^D256-1>	; PDP-10, it must fit in one 8-bit byte
IFNCPU(<KI,KL>),<		;Non EBUS bases can have 15-bit host numbers.
	MOVEI	T1,^D32768-1>	;(the PDP-11 will ignore what we send anyway)
	MOVEM	T1,MAX
	MOVEI	T1,[ASCIZ /System number = /]
	PUSHJ	P,ASKQMM
	 POPJ	P,
	MOVEM	T2,SYSNUM	;STORE INTO GETTAB TABLE.
	MOVE	T1,CNFCPY	;BLT POINTER TO COPY CONFIG NAME/DATE
	BLT	T1,CPYFIG+4	;COPY
	SETZM	CONFIG
	MOVE	T1,CNCLBT
	BLT	T1,SYSDAT-1	;CLEAR OUT IN CASE NEW STRING SHORTER
	MOVE	T3,CPYBPT	;GET POINTER TO COPY AREA
	MOVE	T4,CNFBPT	;GET POINTER TO CONFIG AREA
CHGSY1:	ILDB	T1,T3		;FIRST CHAR ALWAYS COPY
	CAIL	T1,"0"
	CAILE	T1,"9"
	 JRST	[IDPB	T1,T4	;Leading non-numeric
		 JRST	CHGSY1]
	PUSHJ	P,CPYSYN	;TURN T2 INTO STRING, DEPOSIT THRU T4.
CHGSY2:	ILDB	T1,T3		;SKIP OVER OLD NUMBER
	CAIL	T1,"0"
	CAILE	T1,"9"
	 SKIPA			;FINISHED SKIPPING OLD SYSTEM NUMBER
	JRST	CHGSY2		;CONTINUE TO EAT SYSTEM NUMBER
CHGSY3:	IDPB	T1,T4		;FIRST TIME, PUT IN FIRST NON-SYSNUM CHAR
	ILDB	T1,T3		;GET NEXT SOURCE CHAR
	JUMPN	T1,CHGSY3	;IF NON-ZERO, COPY.
	POPJ	P,		;ZERO MEANS DONE.
;ROUTINE TO GET SYSTEM NUMBER INTO T2 FROM CONFIG.
; CALLED ONCE, AT TIME SYSTEM NAME IS PRINTED OUT ON CONSOLE.
; ALL OTHERS INTERESTED IN WHAT SYSTEM NUMBER IS SHOULD
; LOOK AT SYSNUM.

EXTERNAL SYSNUM

GETSYN:	MOVE	T4,CNFBPT	;GET BYTE POINTER INTO CONFIG
	SETZ	T2,		;WILL GET SYSTEM NUMBER
GETSY0:	ILDB	T1,T4		;GO TILL FIRST NUMBER
	CAIL	T1,"0"
	CAILE	T1,"9"
	 JRST	GETSY0		;BETTER BE AT LEAST ONE.
GETSY1:	IMULI	T2,^D10
	ADDI	T2,-"0"(T1)
	ILDB	T1,T4
	CAIL	T1,"0"
	CAILE	T1,"9"
	 SKIPA
	  JRST	GETSY1
	MOVEM	T2,SYSNUM
	JUMPN	T2,CPOPJ	;Done if system number is nonzero
IFCPU (KI),<
	CONI	PAG,T1		;READ PAGER TO GET REAL SERIAL NUMBER
	LDB	T1,[POINT 10,T1,9]
>;END IFCPU (KI)
IFNCPU(KI),<
	APRID	T1		;GET SERIAL NUMBER, UCODE VERSION, ETC.
	ANDI	T1,APRSER	;JUST SERIAL NUMBER
>;END IFNCPU (KI)
	HRRM	T1,.CPCPU##	;Fake out the CAMN T1,SERIAL test
	PJRST	CHGSYS		;Demand a new system number

CPYSYN:	MOVE	T1,T2		;GET INTO T1
CPYSY1:	IDIVI	T1,^D10
	HRLM	T2,(P)		;SAVE ON STACK
	SKIPE	T1		;IF NO MORE DIGITS, START DEPOSITING.
	PUSHJ	P,CPYSY1	;CURSE, AND RECURSE.
	HLRZ	T1,(P)		;GET NEXT DIGIT
	ADDI	T1,"0"
	IDPB	T1,T4		;PUT INTO CONFIG
	POPJ	P,		;RETURN.

CPYFIG:	BLOCK	5+1		;5 WORDS FOR CONFIG, 1 FOR GOOD MEASURE.
COMMENT #
@@SUBROUTINE OPCBST/OPCBCL
@@PURPOSE
DEPENDING ON THE ENTRY POINT USED, EITHER (OPCBST)SETS UP OR
(OPCBCL)CLEARS THE TEMPORARY ONCE-TIME PCBS' MAP SLOTS
OPCBST ALSO SETS PCBTAB AND PGYXXX POINTERS.
CALLED WITH A JSP T4.
@@ENTRY
SEE PURPOSE.
@@ACCUM
DESTROYS T1, T2, AND T3.
@@ #

EXTERN PCBPAG,PCBTAB,PCBLNK

OPCBCL:	PUSH	P,PG		;

    ;HERE TO CLEAR THE USE AND SWAP DONE LISTS.  NO NEED TO CLEAR FPL/BPL/LST.
	SETZB	T2,USELST	;
	SETZM	SODLST		;
	SETZM	SIDLST		;
	MOVEI	T1,NMOCPC	;
	MOVE	PG,OPCLOW	;GET CP# OF LOWEST ONCE PCB
OPCBN1:	DPB	T2,PGYUSE	;
	DPB	T2,PGYERR	;
	DPB	T2,PGYDRT	;
	SOSLE	T1		;SKIP OVER AOJA IF DONE.
	AOJA	PG,OPCBN1	;
	JRST	OPCOUT

OPCBST:	PUSH	P,PG		;
	SETZM	ONCTIM		;FLAG FOR FINPCB.
	MOVEI	T1,OPCBTB	;SET UP POINTER TO LIST OF
	MOVEM	T1,PCBTAB	;PRIMARY PCBS.
	SETZ	T1,		;T1/ INDX TO TABLE OF PCB ADDRS.
	MOVE	PG,MEMSIZ##	;FIRST NON-EX LOCATION
	SUBI	PG,1000		;1ST LOC OF LAST PAGE
	LSH	PG,W2PLSH	;CONVERT TO PAGE NUMBER
OPCBS4:	SKIPN	T2,OPCBTB(T1)	;ANOTHER PCB?
	AOJA	PG,OPCBN0	;DONE. SET PG TO LOWEST PCB PAGE AND JUMP.
	HRLM	PG,PCBPAG(T2)	;YES, SET PAGE NUMBER IN PCB
	MOVEI	T3,PGE.A!PGE.W!PGE.C(PG)	;ITS
	DPB	T3,MPSLOT(T1)	;MAP ENTRY.
	SUBI	PG,1		;NEXT PAGE FOR ONCE PCBS.
	AOJA	T1,OPCBS4	;CONTINUE.
    ;SET BYTE PNTRS.
OPCBN0:	MOVEM	PG,OPCLOW	;REMEMBER LOWEST PHYSICAL PAGE USED FOR ONCE PCBS.
	MOVEI	T2,BOTTM-ONCDDS	;GET START OF ONCE ONLY PGY TABLES.
	SUB	T2,PG		;PGY IS INDEXED BY THAT MINIMUM INDEX.
	HRRM	T2,PGYUNU	;
	HRRM	T2,PGYPGO	;
	HRRM	T2,PGYFPL	;

	ADDI	T2,NMOCPC	;SECOND WORD.
	HRRM	T2,PGYLMA	;
	HRRM	T2,PGYLMV	;
	HRRM	T2,PGYLMJ	;
	HRRM	T2,PGYBPL	;

	ADDI	T2,NMOCPC	;THIRD WORD.
	HRRM	T2,PGYLST	;
	HRRM	T2,PGYDIO	;
	HRRM	T2,PGYADR	;
	HRRM	T2,PGYUNI	;
	HRRM	T2,PGYPNO	;

	ADDI	T2,NMOCPC	;FOURTH WORD.
	HRRM	T2,PGYSPT	;
	HRRM	T2,PGYSPB	;
	HRRM	T2,PGYSPO	;
	HRRM	T2,PGYCHT	;

	ADDI	T2,NMOCPC	;FIFTH WORD.
	HRRM	T2,PGYSTS
	HRRM	T2,PGYSIO	;
	HRRM	T2,PGYSIP	;
	HRRM	T2,PGYSOP	;
	HRRM	T2,PGYERR	;
	HRRM	T2,PGYNXM	;
	HRRM	T2,PGYDRT	;
	HRRM	T2,PGYATB	;
	HRRM	T2,PGYUSE	;

	ADDI	T2,NMOCPC	;SIXTH WORD
	HRRM	T2,PGYCSH

OPCBND:	MOVEI	T1,ONCPYP	;NUMBER OF PAGES FOR PGY AND DDB
	MOVEI	T2,EPT*2+<<BOTTM-ONCDDS>/1000>-1
	ROT	T2,-1
	TLNN	T2,(1B0)	;CAN'T USE EPTPTR, ONCPYP MADE OF EXTERNALS
	JRST	[HRLI T2,(POINT 18,0,17)
		 JRST .+2]	;IS EVEN USE RIGHT HAND SLOT
	HRLI	T2,(POINT 18,0,35) ;ODD, USE LEFT HAND SLOT
				;NOW HAVE PTR TO PAGE BEFORE ONE FOR PGY AND DDB.
	SKIPN	PG,T3		;IF T3 IS ZERO, CLEAR PG AND GO CLEAR MAP SLOTS
	JRST	OPCBNL
	MOVE	PG,OPCLOW	;GET LOWEST PAGE NUMBER OF ONCE PCBS
	SUBI	PG,ONCPYP	;GET FIRST PHYS PAGE OF PGY AND DDB
	TRO	PG,PGE.A!PGE.W!PGE.C ;MAKE INTO MAP SLOT POINTER
OPCBNL:	IDPB	PG,T2		;SET OR CLEAR SLOT
	ADDI	PG,1		;NEXT CP
	SOJG	T1,OPCBNL	;AND LOOP TILL DONE.
	CLRPTA			;GET MAPPING INTO EFFECT SO CAN USE IT BELOW.
	JUMPE	T3,OPCOUT	;IF CLEARING, JUST RETURN.
	MOVEI	T1,BOTTM-ONCDDS+CNTPGY*NMOCPC ;DDB LOCATION IN VIRTUAL SPACE
	MOVEM	T1,ONCDDB	;STORE IT FOR ONCDSK.

    ;HERE TO SET THE USE LIST.
OPCBN2:	MOVEI	T1,NMOCPC	;T1/ LOOP COUNTER.
	PUSH	P,T4		;T4/ PGYLST,
	MOVEI	T2,1		;T2/ PGYUSE.
	MOVEI	T4,USE.N	;
	SETZ	T3,		;BPL.
	MOVE	PG,OPCLOW	;PG/FIRST PAGE
	HRRM	PG,USELST	;
	HRRZM	PG,MINPCB	;
OPCBN3:	DPB	T3,PGYBPL	;
	DPB	T2,PGYUSE	;
	DPB	T4,PGYLST	;
	SOJLE	T1,OPCBN4	;
	MOVEI	T3,1(PG)	;
	DPB	T3,PGYFPL	;
	EXCH	T3,PG		;
	JRST	OPCBN3		;
OPCBN4:	SETZ	T3,		;
	DPB	T3,PGYFPL	;
	POP	P,T4		;
	HRLM	PG,USELST	;
	HRRZM	PG,MAXPCB	;STORE NO. OF HIGHEST PCB PAGE.
	MOVEI	T1,1(PG)	;FAKE
	HRRZM	T1,MEMSZP	;OUT SWPENQ AT ONCE TIME.
OPCOUT:	POP	P,PG		;RESTORE PG.
	JRST	(T4)		;
COMMENT ;@@SUBROUTINE EVASET
@@PURPOSE: Set up page map slots for mappable exec virtual
  address space (i.e., high seg)
@@ACCUM T1-T4
@@EXIT	EVAMAX/SETUP TO MAXIMUM VALUE EVASIZ CAN BE (ALWAYS %ONC FOR NOW).
@@;

EVASET:	MOVEI	T3,%ONC		;*****
	MOVEM	T3,EVAMAX	;*****FOR NOW EVAMAX IS ALWAYS %ONC
	MOVEI	T4,%ONC-%MIN	;GET NUMBER OF WORDS AVAILABLE
	LSH	T4,W2PLSH	;NUMBER OF AVAILABLE PAGES
	MOVE	T2,EVAMIN	;SETUP EPT HIGH SEG
	IBP	T2		;DECREMENT THE POINTER
	SOS	T2		;BECAUSE EPTPTR WON'T WORK RIGHT FOR 377.
	MOVEI	T3,PGE.A+PGE.C+PGE.W+340 ;MAP SLOT POINTER

EVASE1:	IDPB	T3,T2		;SET MAP SLOT POINTER
	ADDI	T3,1		;NEXT PAGE
	SOJG	T4,EVASE1	;AND LOOP SETTING UP MAP SLOTS
	CLRPTA			;DONE, MAKE MAP SETTINGS HAPPEN.
	POPJ	P,		;RETURN.

EVAONC:	EPTPTR(%ONC.N)
EVAMIN:	EPTPTR(<%MIN/^O1000>)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	EVMINI - Routine to set the lower bound for dynamic	;;
;;	exec virtual memory allocation.  May be called more	;;
;;	than once if the FILES dialogue is used, but it		;;
;;	doesn't matter since it will allocate again in the	;;
;;	normal sequence.					;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EVMINI:	MOVE	T1,SYSSIZ	;GET CURRENT SYSTEM SIZE
	MOVEM	T1,EVASIZ	;INITIALIZE FOR EVMALC
	POPJ	P,

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	EVMALC - Routine to allocate EVM for ONCE.  Called	;;
;;	with # of words requested in T2, returns address in	;;
;;	T1.  Adjusts across the per-process area.  Zeroes out	;;
;;	storage before returning to caller.			;;
;;	Returns at call+1 always, T2 preserved.			;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EVMALC::SKIPN	T1,EVASIZ	;Current highest allocated EVM address
	  PUSHJ	P,EVMINI	;This can happen if called from FILES
	CAIL	T1,%MIN		;Already allocating in high-seg?
	  JRST	EVMAL1		;If so, no problem
	ADD	T1,T2		;See where this request puts us
	CAIG	T1,340000	;Into the per-process area, maybe?
	  JRST	EVMAL2		;No, how nice
	MOVEI	T1,%MIN		;Time to start high-seg allocation
	MOVEM	T1,EVASIZ
EVMAL1:	ADD	T1,T2		;Bump old high address up
	CAMLE	T1,EVAMAX	;Encroaching on ONCE?
	 STOPCD			;If so, monitor too big ;;EVMAL1+2
EVMAL2:	EXCH	T1,EVASIZ	;Return start address for request
	PUSH	P,T1
	PUSH	P,T2
	SETZM	(T1)		;Clear first word for BLT
	ADDI	T2,-1(T1)	;Start address+length-1=last address
	ADDI	T1,1		;0,,start address + 1
	HRLI	T1,-1(T1)	;Start address,,start address + 1
	BLT	T1,(T2)		;Zero it all out
	POP	P,T2
	POP	P,T1
	POPJ	P,

EVASIZ::0			;UPDATED BY ALLOCATERS TO CONTAIN
				; LOCATION TO ALLOCATE AT.
EVAMAX::0			;HIGHEST LEGAL VALUE OF EVASIZ.
COMMENT ;@@SUBROUTINE EVACLR
@@PURPOSE CALLED BY ONCE TO CLEAR OUT THE UNUSED EXEC VIRTUAL
MAP SLOTS AFTER ALL THE DYNAMIC STORAGE IS ALLOCATED IN
EXEC VIRTUAL ADDRESS SPACE.
@@ENTRY	EVASIZ/	UPDATED LAST LOCATION USED + 1 OF DYNAMIC SPACE
@@ACCUM T1-T4
@@EXIT  EPT MAP SLOTS ZEROED TO STARTING PAGE OF ONCE
@@;

EVACLR:	MOVE	T4,EVASIZ	;GET FIRST UNUSED LOCATION
 ;P035/D08 - fix so it doesn't crash when EVASIZ is on a page boundary
        ADDI	T4,777		;MAKE SURE LAST LOC LOOKS LIKE IS
				; LAST LOC OF A PAGE
	TRZ	T4,777		;T4 GETS FIRST UNUSED LOCATION
	CAMLE 	T4,EVAMAX	;MAKE SURE ONCE NOT OVERWRITTEN.
	 STOPCD                         ;;EVACLR+4
	MOVE	T1,T4
	SUB	T1,EVAMAX	;GET -VE NUMBER OF UNUSED WORDS
	ASH	T1,W2PLSH	;MAKE IT -VE NUMBER OF UNUSED PAGES
	LSH	T4,W2PLSH	;CONVERT TO FIRST UNUSED VIRTUAL PAGE NUMBER
	MOVEI	T3,EPT*2-1(T4)
	LSH	T3,-1		;WORD IN EPT OF SLOT BEFORE ONE TO CLEAR
	HRLI	T3,(POINT 18,0,35) ;ASSUME ODD
	TRNE	T4,1		;IS IT? (TEST BACKWARDS BECAUSE ITS PAGE - 1)
	HRLI	T3,(POINT 18,0,17) ;NO, EVEN
	JUMPE	T1,CPOPJ##	;IF NO USED AREA, JUST RETURN.
	SETZ	T4,		;TO CLEAR MAP SLOT WITH
EVACL1:	IDPB	T4,T3		;CLEAR MAP SLOT
	AOJL	T1,EVACL1	;AND LOOP
	CLRPTA			;MAPPINGS GO INTO EFFECT WITH THIS
	POPJ	P,		;RETURN.
COMMENT #
@@SUBROUTINE FINALC
@@PURPOSE
  SUBROUTINE TO
     1) SET UP THE SYSTEM PCBS AT INITIALIZATION TIME AND
        TO LINK THEM TO THEIR PAGES AND EACH OTHER.  SETS UP
        TABLE OF ADDRS AND POINTS PCBTAB TO IT.  SETS UP LRU/MRU
        TABLES FOR SAT PCBS AND RIB PCBS.  ALSO SETS %CTLST'S.
     2) ALLOCATE FREE CORE.  WILL USE REMAINING EXECUTIVE
        VIRTUAL MEMORY UP TO THE BEGINNING OF ONCE UNLESS
        RESTRICTED BY SPECIFYING FCWDS.
@@ACCUM
  DESTROYS T1 TO T4 AND P1 TO P4 AND PG.
@@CALLS
  EVMALC
@@ #

;FIRST GET CORE FOR BOTH THE PCBS AND THE THREE TABLES
;OF PCB ADDRS.

FINALC:	SETOM	ONCTIM		;FLAG FOR FINPCB.

	MOVE	T2,NMSTPC	;COUNT THE NO. OF
	ADD	T2,NMRBPC	;SYSTEM PCBS.
	MOVE	P1,T2		;SAVE COUNT IN P1, FOR BELOW.
	IMULI	T2,6		;GET ROOM FOR PCBS (@4 WORDS) +
	ADDI	T2,3		;3 TBLS WITH 1 WORD PER TYPE OF
				;PCB + A ZERO ENTRY AT END.
	PUSHJ	P,EVMALC	;Allocate, returns base in T1
	MOVE	T2,P1		;CALC T2/ LAST LOC OF PCBS +
	LSH	T2,2		;T4/ STARTING LOC OF THE 1ST
	ADDI	T2,-1(T1)	;TABLE, AND
	MOVEI	T4,1(T2)	;STORE T4
	MOVEM	T4,PCBTAB	;IN PCBTAB.
	MOVE	P2,T1		;SAVE THE PCBS' STARTING ADDR.

        MOVE    T1,EVASIZ       ;UPDATE SYSSIZ AND EVASIZ
        CAIGE   T1,%MIN         ;BEYOND THE PER PROCESS AREA?
         MOVEI  T1,%MIN         ;NO. SKIP OVER IT
        MOVEM   T1,EVASIZ
        SUBI    T1,%MIN-340000  ;ADJUST SYSSIZ BY PER PROCESS PAGES
        MOVEM   T1,SYSSIZ

;;
;; Free-core consists of a block of bit-map words, followed by a block
;; of allocatable free storage.  Each bit in the bit-map corresponds to a
;; four-word core block, therefore, each bit-map word maps 144 (decimal)
;; words of core.  The size of the total (bit-map + 4-wd blocks) storage
;; is therefore an even multiple of ^D145 => ^D144 allocatable words +
;; 1 bit-map word.

        EXTERNAL FRECOR,FREPTR,LOCORE

        SKIPE   T2,FRECOR       ;FRECORE specified explicitly?
         JRST   FREAL1          ;Yes. Allocate it
        MOVE    T2,EVAMAX       ;No.  Allocate what's available
        SUB     T2,EVASIZ
FREAL1:	IDIVI	T2,^D145	;See above
; T2 now contains number of words which will be used for bit-map
	MOVN	T3,T2		;Remember -N
	IMULI	T2,^D145	;Re-calculate total allocation
	PUSHJ	P,EVMALC	;Allocate storage, returns base in T1
        ADDM    T2,SYSSIZ       ;DON'T FORGET PHYSICAL MEMORY
	HRL	T1,T3		;Make AOBJN ptr for bit-map words
	MOVEM	T1,FREPTR	; for free-core allocation routines
	SETZM (T1)		;Clear out bit-map words to indicate
	AOBJN T1,.-1		; nothing allocated yet.
	HRRZM	T1,LOCORE	;Allocatable storage begins after bit-map

	PUSHJ   P,EVACLR        ;Clear out remaining exec page map slots.

	HLRE	T1,FREPTR	;Minus # of 144 word blocks
	IMULI	T1,-^D144	;RH gets total size of free core
	HRLZ	T1,T1		;Count in LH
	HRR	T1,LOCORE	;Start addr in RH
FREALC:: JFCL	CSHCLR##	;Change this to PUSHJ P,CSHCLR to uncache all

    ;ADJUST SYSSIZ TO ACCOUNT FOR THE SYSTEM PCB PAGES.
	MOVE	T1,SYSSIZ	;GET INTO T1
        ADDI    T1,777          ;MAKE SURE 1ST PHYS PAGE CORRESPONDS
        TRZ     T1,777          ; TO 1ST PAGE RELEASED BY EVACLR
	MOVE	PG,T1		;SET PG TO
	LSH	PG,W2PLSH	;NEXT PAGE NO.
	HRRZM	PG,USELST	;
	HRRZM	PG,MINPCB	;
	LSH	P1,P2WLSH	;
	ADD	T1,P1		;
	MOVEM	T1,SYSSIZ	;

    ;NOW GET PAGES FOR THE PCBS AND BUILD THE THREE TABLES.
	MOVE	T2,NMSTPC	;
	ADD	T2,NMRBPC	;
	MOVE	T3,PCBTAB	;SET UP T3 AS START OF SAT
	ADDI	T3,1(T2)	;PCB LRU/MRU TABLE, AS ARG
	MOVEM	T3,%CTLRU+%SAT.C ;FOR SPCBLN, ALONG WITH
        MOVE    T4,PCBTAB       ;GET BACK PCB TABLE ADDRESS
	MOVE	P1,NMSTPC	;PG AND P1.
	HRRM	P2,%CTLST+%SAT.C ;
	SETZ	P3,		;BPL.
	PUSHJ	P,SPCBLN	;LINK/LINK.
	HRRZI	P3,(PG)		;
	HRRZI	PG,1(PG)	;
	MOVEM	T3,%CTMRU+%SAT.C ;
	ADDI	T3,1		;
	MOVEM	T3,%CTLRU+%RIB.C ;
	MOVEM	T3,%CTLRU+%RB2.C ;
	MOVE	P1,NMRBPC	;SET UP AND CALL SPCBLN
	HRRM	P2,%CTLST+%RIB.C ;
	HRRM	P2,%CTLST+%RB2.C ;
	PUSHJ	P,SPCBLN	;FOR RIB PCBS.
	MOVEM	T3,%CTMRU+%RIB.C ;
	MOVEM	T3,%CTMRU+%RB2.C ;
	SETZM	(T4)		;MARK END OF PCBTAB TABLE.
	HRLM	PG,USELST	;
	HRRZM	PG,MAXPCB	;
	SETZ	T1,		;TERMINATEE THE LAST
	DPB	T1,PGYFPL	;PAGE ON THE LIST.
	POPJ	P,

    ;A LITTLE SUBR TO LINK A SET OF PCBS.
    ;ENTER WITH P1/ # OF PCBS TO LINK, P2/ ADDR OF FIRST
    ;PCB, P3/BPL, PG/ 1ST PAGE NO., T4 AND T3/ ADDRS OF TABLE ENTRIES
    ;TO STORE PCB ADDRS IN.
SPCBLN:	MOVEI	T1,1		;
	MOVEI	P4,USE.N	;
SPCBL1:	HRLZM	PG,PCBPAG(P2)	;SET PCBPAG.
	DPB	T1,PGYUSE	;
	DPB	P4,PGYLST	;
	DPB	P3,PGYBPL	;
	MOVEM	P2,(T4)		;MAKE THE TBL ENTRIES
	MOVEM	P2,(T3)		;AND
	ADDI	T4,1		;ADJUST THE TBL
	ADDI	T3,1		;PNTRS.
	ADDI	P2,4		;NO, GET P2/ ADDR OF NEXT PCB
	SOJLE	P1,SPCBL2	;DONE?
	HRRM	P2,-4+PCBLNK(P2) ;AND LINK CURRENT PCB TO IT.
	MOVEI	P3,1(PG)		;
	DPB	P3,PGYFPL	;
	EXCH	P3,PG		;
	JRST	SPCBL1		;
SPCBL2:	SETZM	(T3)		;CLEAR LAST+1 ENTRY IN LRU/MRU.
	POPJ	P,
COMMENT #
@@SUBROUTINE SETM2P
@@PURPOSE
SUBROUTINE TO SET UP INFO FOR THE M2, PS, PR, SI, AND RI QUEUES.
@@ACCUM
DESTROYS
@@ #

    ;SET M2REQ, PSREQ, PRREQ, SIREQ, AND RIREQ TO MINUS THE NO. OF RESOURCES,
    ;AND SET OF THE LH'S OF THE AOBJN PNTRS IN M2SWT, M2HAV,
    ;PSSWT, PRSWT, SISWT, AND RISWT SIMILARLY.
SETM2P:	MOVN	T2,NMSTPC	;
	MOVEM	T2,PSREQ	;
	HRLZM	T2,PSSWT	;
	MOVEM	T2,SIREQ	;
	HRLZM	T2,SISWT	;
	MOVN	T2,NMRBPC	;
	MOVEM	T2,PRREQ	;
	HRLZM	T2,PRSWT	;
	MOVEM	T2,RIREQ	;
	HRLZM	T2,RISWT	;
	IDIVI	T2,2		;LSH ISN'T IDIV ON NEGATIVE NO.
	MOVEM	T2,M2REQ	;
	HRLZM	T2,M2SWT	;
	HRLZM	T2,M2HAV	;

    ;GET THE SPACE FOR THE THREE TABLES.
	MOVMS	T2		;CALC
	PUSH	P,T2		;AND
	LSH	T2,1		;
	ADD	T2,NMSTPC	;SAVE THE
	ADD	T2,NMSTPC	;SAVE THE
	ADD	T2,NMRBPC	;TOTAL SPACE
	ADD	T2,NMRBPC	;TOTAL SPACE
	PUSH	P,T2		;REQUIRED.
	PUSHJ	P,GETWDS	;
	 STOPCD                         ;;SETM2P+many
	POP	P,T2		;RESTORE TOTAL COUNT OF SPACE.
	PUSH	P,T1		;SAVE STARTING ADDRESS.
	ADDI	T2,-1(T1)	;CLEAR
	SETZM	(T1)		;THE
	ADDI	T1,1		;ACQUIRED
	HRLI	T1,-1(T1)	;SPACE.
	BLT	T1,(T2)		;

    ;BUILD THE RH OF THE AOBJN PNTRS IN M2SWT, PSSWT, AND PRSWT.
	POP	P,T1		;RESTORE STARTING LOCATION.
	HRRM	T1,PSSWT	;
	ADD	T1,NMSTPC	;
	HRRM	T1,PRSWT	;
	ADD	T1,NMRBPC	;
	HRRM	T1,M2SWT	;
	POP	P,T2		;
	ADDI	T1,(T2)		;
	HRRM	T1,M2HAV	;
	ADDI	T1,(T2)		;
	HRRM	T1,SISWT	;
	ADD	T1,NMSTPC	;
	HRRM	T1,RISWT	;
	POPJ	P,		;

;Here on the FILES command

FILES:	PUSHJ	P,SIZMEM	;Determine memory size
	PJRST	FILOPT		;Go into optional FILES dialog

;Here to select CONSOLE versus NETWORK mode

FLGNET:	TDZA	T1,T1		; Zero flag for NET access
FLGCTY:	SETO	T1,		; Ones flag for CTY access
	MOVEM	T1,CTYDO##	; Set CTYDO flag
IFKMC<
	SETCAM	T1,DRDO##	; Opposite for DR-11
	SETCAM	T1,DZDO##	; Opposite for DZ-11
	SETCAM	T1,KMCDO##	; Opposite for KMC-11
> ; End IFKMC
	MOVE	T1,[Exp [ASCIZ\
  Console\],[ASCIZ\
  Network\]]+1(T1)		; Print selection.
	PUSHJ	P,OCONM
	PUSHJ	P,OPOUT
	MOVEI	T1,[Asciz\ selected.
  Please type GO, FULL, MANUAL or READONLY to bring up the system.
\]				; Print something!
	PUSHJ	P,OCONM
	PUSHJ	P,OPOUT
	POPJ	P,		; Return to command level

;Here to select INITIA versus NOINITIA mode

FLGINI:	TDZA	T1,T1		; Zero flag to allow INITIA
FLGNOI:	SETO	T1,		; Ones flag to disable INITIA
	MOVEM	T1,NOXEXE##	; Set NOXEXEC FLAG
	MOVE	T1,[Exp [ASCIZ\
  NOINITIA\],[ASCIZ\
  INITAI\]]+1(T1)		; Print selection.
	PUSHJ	P,OCONM
	PUSHJ	P,OPOUT
	MOVEI	T1,[Asciz\ selected.
  Please type GO, FULL, MANUAL or READONLY to bring up the system.
\]				; Print something!
	PUSHJ	P,OCONM
	PUSHJ	P,OPOUT
	POPJ	P,		; Return to command level
SUBTTL	Size memory

IFCPU (F3),<MAXPAG==1777>	;F3 ALWAYS HAS  512K
IFCPU (KS),<MAXPAG==3777>	;FOR KS MAX IS 1024K (DEC only supports 512K)
	NDL MAXPAG,17777	;KI & KL GO TO 4096K
HIPAGE:	0			;Highest page number (22 bits)

DEFINE	NXM.OK,<	;NXM is expected - don't cause an interrupt
IFCPU (KL),<WRAPR LP.DSF+LP.NXM+LP.PAR+LP.IOF> ;THESE WILL COME UP.
IFCPU (KS),<WRAPR LP.DSF+LP.NXM+LP.HPE>	;THESE WILL COME UP.
>			;Nothing for KI or F3

DEFINE	NXM.NO,<	;Make NXM cause STOPCD(APRFAT)
IFCPU (F3),<WRAPR LP.ESF+LP.NXM+LP.PAR>	;Re-enable NXM and parity detection
IFCPU (KL),<WRAPR LP.ESF+LP.NXM+LP.PAR+LP.IOF+APRCHN>
IFCPU (KS),<WRAPR LP.ESF+LP.NXM+LP.HPE+APRCHN>
>			;Nothing for KI

SIZMEM:	NXM.OK			;We expect NXM here
	SETZB	PG,HIPAGE
	MOVEI	T1,340		;Start with this physical page number
SIZME1:	PUSHJ	P,PGCHK		;Does page in T1 exist?
	  SKIPA			;No
	 MOVE	PG,T1		;Yes, remember highest physical page
	ADDI	T1,1		;Try next
	CAIG	T1,MAXPAG	;Past highest possible?
	 JRST	SIZME1		;Not yet
	MOVEM	PG,HIPAGE	;Yes, remember highest
	NXM.NO			;No more NXM's expected
	MOVE	T1,HIPAGE	;Highest page of physical memory
	MOVEM	T1,RSVDPG##	;Mark that one as being reserved
	SUBI	T1,1
	MOVEM	T1,RSVDPG+1	;Reserve both pages at end of phys mem
	TRO	T1,PGE.A+PGE.W	;Access+write, not cached
	DPB	T1,[EPTPTR(%MS0.N)]	;Virtual address 774 = next to highest
	ADDI	T1,1
	DPB	T1,[EPTPTR(%MS1.N)]	;Virtual address 775 = highest page #
	CLRPTA			;Make these pages addressable
	PUSHJ	P,MSGINI##	;Re-enable MSGBUF logging
	PUSHJ	P,INLMES
	 ASCIZ	/
Highest memory address is /
	MOVE	T1,HIPAGE	;Page number
	LSH	T1,P2WLSH
	IORI	T1,777		;Address of end of page
	PUSHJ	P,PRT22A##	;Print 22-bit address
	PJRST	CRLFOP		;CRLF and output



; Routine to determine whether a particular physical page (number
; passed in T1) exists.  Non-skip return if not, skip return if so.

PGCHK:	TRO	T1,PGE.A	;Set access allowed
	DPB	T1,[EPTPGP(%ERR.N)] ;Store in EPT for page 777
	CLRPTO	%ERR		;Clear pager's memory for this one page
	TRZ	T1,PGE.A	;Clean up after self
IFCPU (KI),<WRAPR CLRNXM>	;If KI, PI system isn't on.
IFNCPU(KI),<WRAPR CLRNXM+APRCHN	;Clear NXM flags, keep PI channel assigned
	MOVEI	T3,PGCHK1	;Jump to PGCHK1 on AR/ARX parity page fault
	EXCH	T3,UPT+UPTNPP	;(KL and KS get page failures from NXM)
>
	MOVE	T2,%ERR+774	;Verify interleaving by
	MOVE	T2,%ERR+775	; trying to read
	MOVE	T2,%ERR+776	; four consecutive
	MOVE	T2,%ERR+777	; words
IFNCPU(KI),<			;Jump to here on page failure from NXM
PGCHK1:	MOVEM	T3,UPT+UPTNPP>	;Restore page-fail new PC
	CONSO	APR,APRNXM	;If not NXM
	 AOS	(P)		; then skip return
	WRAPR	CLRNXM
	MOVEI	T2,0		;Clear EPT entry so as to not confuse things
	DPB	T2,[EPTPGP(%ERR.N)] ; (SCNSER hits page 777 by mistake)
IFNCPU(KI),<SETZM UPT+UPTPFW	;Clear bogus AR.ARX indication
	    SETZM UPT+UPTOPP>
	POPJ	P,

; Routine to type out message about dis-continuous core - highest
; previous physical page number is in PG and first page after hole
; is in T1.
HOLMSG:	TLO	PG,(1B1)	;MARK DISCONTINUOUS CORE
	PUSH	P,T1
	PUSHJ	P,CLRSND
	PUSHJ	P,INLMES
	ASCIZ	/
"Hole" in core from /
	MOVEI	T1,1(PG)
	LSH	T1,9
	PUSHJ	P,RADIX8
	PUSHJ	P,INLMES
	ASCIZ	/ to /
	MOVE	T1,(P)
	ANDI	T1,17777
	LSH	T1,9
	SUBI	T1,1
	PUSHJ	P,RADIX8
	PUSHJ	P,CRLF
	PUSHJ	P,OPOUT
	PJRST	TPOPJ
;HERE IS WHERE WE REALLY START THINGS

MANRS:
IFKMC<	SKIPE	CTYDO
	 JRST	MANRSN
	MOVEI	T1,[ASCIZ /
WARNING: The KMC is not loaded when coming up manually.
         The 2020 host will not be able to talk to TYMNET.
/]
	PUSHJ	P,OCONM
	PUSHJ	P,OPOUT
MANRSN:>;IFKMC.END
	MOVEI	T1,SRPNDS##
	ANDCAM	T1,STRDDB##+STRBTS##
	SETOM	ADJMWS##	;TURN ON WORKING SET DIDDLER
	JRST	MANRS0

REDOLY:	MOVEI	T1,SRPNDS##	;Set the "DSKCLN not finished bit"
	IORM	T1,STRDDB##+STRBTS## ;which will prevent ENTER uuos from working
MANRS0:	MOVE	T1,[STAUTO!STSUPR] ;No autorestart, not super-shut
	ANDCAM	T1,STATES	;Set SCHED 400000
	JRST	AUTOR0

IFKMC<
KMCMAN:	SKIPN	KMCDO
	 JRST	KMCMER		;COMPLAIN KMC NOT ACTIVE
	SETOM	KMCDO		;FLAG KMC MANUAL MODE
	MOVEI	T1,SRPNDS##	;DONT LOCK DISK STRUCTURE
	ANDCAM	T1,STRDDB##+STRBTS##
	MOVEI	T1,STSUPR	;DONT SET SYSTEM AS SUPER SHUT
	ANDCAM	T1,STATES
	MOVEI	T1,STSHUT	;SET SYSTEM AS SHUT
	IORM	T1,STATES
	JRST AUTOR0
KMCMER:	MOVEI	T1,[ASCIZ/
KMC not set as active in system/]
	JRST HLPCM1		;GO COMPLAIN
>;END IFKMC

FULLRS:	MOVEI	T1,DCFULL	; SET FULL DSKCLN restart code
	DPB	T1,DCNYOP	; Save for override!
	MOVSI	T1,DCN.OP	; Specify that OPR
	IORM	T1,DCN		; Has set this in ONCE
	PFALL	AUTORS		;** FALL INTO AUTO RESTART CODE "GO"
SUBTTL	Initial auto-restart proceedures

AUTORS:	SKIPE	REFLAG##	;If OPER typed GO after doing a REFRESH,
	 JRST	MANRS		; then do MANUAL because DSKCLN is not there
	MOVEI	T1,SRPNDS##	;FULL and GO both need DSKCLN.
	IORM	T1,STRDDB##+STRBTS##
AUTOR0:	SKIPN	$1B##		;DO WE WANT TO KEEP DDT
	 JRST	AUTOR1		;NO
	MOVEI	T1,[ASCIZ /
EDDT breakpoints are set.
/]
	PUSHJ	P,CONMES
	PUSHJ	P,OPOUT
	JRST	COMLOD		;Don't remove DDT

AUTOR1:	SKIPL	DEBUGF##	;Is debugging flag set?
	 JRST	RMVDDT		;No, remove DDT
	MOVEI	T1,[ASCIZ /
DEBUGFLAG is set.
/]
	PUSHJ	P,CONMES
	PUSHJ	P,OPOUT
	JRST	COMLOD		;Don't remove DDT

RMVDDT:	MOVE	T1,PATSIZ##	;GET SIZE OF PATCH AREA
	MOVEM	T1,SYSSIZ##	;AND SAVE IT
	MOVEI	T1,(HALT)
	HRLM	T1,SYSDDT##	;NO MORE 141 RESTART
	MOVEI	T1,(JFCL)
	HRLM	T1,.CPDDT##	;Can't get to DDT from STOPCD

COMLOD:	SETZM	EVASIZ          ;INITIALIZE EXEC VIRTUAL MEMORY
	PUSHJ	P,SIZMEM	;Determine size of memory
	PUSHJ	P,FILMAN	;DO MANDATORY FILE STUFF.
	JSP	T4,OPCBCL	;CLEAR THE ONCE TIME PCBS.
	PUSHJ	P,EVASET	;SET UP EXEC ADDRESS SPACE ABOVE 400000
				; FOR DYNAMIC STORAGE ALLOCATION.
	MOVE	PG,EVASIZ	;Current highest monitor address
	LSH	PG,-9		;Highest page # before PGY table base
	ADDI	PG,1		;First page referred to by PGY
	MOVEM	PG,SYSSZP	;Used to figure PGY displacement
	PFALL	PAGALC
;HERE IS WHERE WE START BUILDING THE PAGE TABLE
; PGY IS A LITTLE BIGGER THAN IT HAS TO BE BECAUSE EVASIZ
; WILL BE MOVED UP SOME MORE, MAKING THE FIRST PAGE
; DESCRIBED BY PGY LARGER THAN IT IS HERE.
; SYSSZP and CAVPGN get overwritten later when the final size of
; the monitor is determined.

PAGALC:	MOVE	PG,HIPAGE	;Get page # of highest physical core page.
	SUB	PG,SYSSZP	;Don't count monitor pages
	ADDI	PG,1		;Because SYSSZP is really first PGY page
	MOVE	T2,PG		;Now allocate for free page table
	PUSHJ	P,EVMALC	;Returns base in T1
	MOVE	PG,SYSSZP	;System size in pages
	SUBI	T1,(PG)		;Because the zero'th entry is for the
	HRRM	T1,PGYFPL	; SYSSZP'th physical page
	MOVEM	PG,CFRLST	;First free page
	SETZM	CAVPGN##	;Available pages for users
; Now, repeat the physical page scan, and pay attention this time.
	MOVEI	T1,1(PG)
	NXM.OK			;We expect NXM to occur
PGSLP:	PUSHJ	P,PGCHK		;Page exists?
	  JRST	[TLO PG,(1B0)	;No, flag hole in memory
		 JRST PGSLP1]
	MOVEI	T2,RSVDPG##	;Start of reserved pages list
PGSLP0:	CAMN	T1,(T2)		;Is this a special physical page?
	 JRST	[AOS NRSVDP##	;Yes, count it
		 JRST PGSLP1]	; and pretend that it does not exist
	ADDI	T2,1		;Point to next entry in list
	SKIPE	(T2)		;List terminates with a zero
	 JRST	PGSLP0		;Check page in T1 with other entry on list
	TLZE	PG,(1B0)	;This one exists, did a hole go by?
	 PUSHJ	P,HOLMSG	;Yes, sound the trumpets
	AOS	CAVPGN##	;One more for the lucky user
	HRRZ	T2,PGYFPL	;Base address for free-page list
	ADDI	T2,(PG)		;Address of entry for last known
	MOVEM	T1,(T2)		; physical page - point to new page
	HRR	PG,T1		;Greet the new highest physical page
PGSLP1:	ADDI	T1,1		;Loop until boredom sets in
	CAIG	T1,MAXPAG	;Or until no more physically possible
	 JRST	PGSLP
	NXM.NO			;No more NXM's expected
	AOS	CAVPGN##	;This will get adjusted later to allow
				; for space allocated above SYSSIZ.
; PG should (!) once again have highest physical page #

	HRRZ	T1,PGYFPL	;CLEAR ALL OF FIRST PGY
	ADDI	T1,(PG)		;TABLE WORD, AND SET
	SETZM	(T1)		;PGYFPL TO ZERO.
	HRLM	PG,CFRLST	;
	MOVEI	PG,1(PG)
	MOVEM	PG,MEMSZP	;SIZE IN PAGES
	MOVE	T2,PG		;To get allocated size of remaining PGY
	SUB	T2,SYSSZP	; tables, duplicate PGYFPL arithmetic.
	LSH	PG,9
	MOVEM	PG,MEMSIZ##
	HRRZ	T1,PGYFPL
	HRRM	T1,PGYPGO	;
	HRRM	T1,PGYUNU	;
	PUSHJ	P,EVMALC	;Size in T2, returns base in T1
	SUB	T1,SYSSZP	;Adjust base address
	HRRM	T1,PGYLMA	;
	HRRM	T1,PGYLMV	;
	HRRM	T1,PGYLMJ	;
	HRRM	T1,PGYBPL	;
	PUSHJ	P,EVMALC	;Table size still in T2
	SUB	T1,SYSSZP
	HRRM	T1,PGYLST	;
	HRRM	T1,PGYDIO
	HRRM	T1,PGYADR
	HRRM	T1,PGYUNI
	HRRM	T1,PGYPNO
	PUSHJ	P,EVMALC
	SUB	T1,SYSSZP
	HRRM	T1,PGYSPT
	HRRM	T1,PGYSPB
	HRRM	T1,PGYSPO
	HRRM	T1,PGYCHT
	PUSHJ	P,EVMALC
	SUB	T1,SYSSZP
	HRRM	T1,PGYSIO
	HRRM	T1,PGYSTS
	HRRM	T1,PGYSIP
	HRRM	T1,PGYSOP
	HRRM	T1,PGYERR
	HRRM	T1,PGYNXM
	HRRM	T1,PGYDRT
	HRRM	T1,PGYATB
	HRRM	T1,PGYUSE
	PUSHJ	P,EVMALC
	SUB	T1,SYSSZP
	HRRM	T1,PGYCSH
	PFALL	CHTALC
;Allocate Core Hash Table
CHTALC:	MOVE	T1,CAVPGN##	;GET NUMBER OF USER PAGES
	JFFO	T1,.+2
	 STOPCD
	MOVN	T1,T2		;LSH IN RIGHT DIRECTION
	MOVSI	T2,(1B0)
	LSH	T2,-1(T1)	;GET NEXT HIGHEST POWER OF TWO - 2
				;(CHT START TABLE HAS # OF USER CORE PAGES
				; /2 HALFWORD ENTRIES).
	PUSHJ	P,EVMALC	;Returns base address in T1
	HRRM	T1,CHTPTR	;THIS IS WHERE CHT STARTS
	ROT	T2,1		;NOW GET MASK TO USE FOR GETTING BUCKET
	SUBI	T2,1		; NUMBER FROM DISK PAGE
	MOVEM	T2,CHTMSK	;AND SAVE IT.

	HRRZ	T1,CFRLST	;
	ADD	T1,CAVPGN##	;PLUS FIRST PAGE (OLD SYSSIZ)
	ADD	T1,NRSVDP##	;Plus number of reserved pages
	LSH	T1,-1		;CONVERT TO K
	PUSH	P,T1
	CAIL	T1,PMEMSZ	;TOO SMALL?
	 JRST	SIZOK		;NO
	PUSHJ	P,CLRSND
	PUSHJ	P,INLMES
	ASCIZ	/
?????Should have /
	MOVEI	T1,PMEMSZ
	PUSHJ	P,PRTDEC##
	PUSHJ	P,INLMES
	ASCIZ	/K of memory.
/
SIZOK:	POP	P,T1
	PUSHJ	P,PRTDEC##
	PUSHJ	P,INLMES
	ASCIZ	/K of memory online.
/
	PUSHJ	P,OPOUT
	SKIPN	REFLAG##	;AUTOMATIC "LOGIN" WANTED?
	 JRST	SYS0		;NO.
	MOVE	T1,OPRPPN##
	MOVEM	T1,REFLAG##	;Set to [1,21]
	PUSHJ	P,INLMES
	ASCIZ	/To automatically login, login over shut.
/
	PUSHJ	P,OPOUT
	PFALL	SYS0
SYS0:	PUSHJ	P,PRTSYS##	;Output SYSNO and monitor version again
	PUSHJ	P,OPOUT		;Dump last buffered line
	JSR	LINKDB		;AND LINK UP ALL DDB'S
	HRLI	T1,SYSBEG	;GET SET TO CLEAR LOW CORE
	HRRI	T1,SYSBEG+1	;CLEAR SYSTEM DATA STORAGE
	SETZM	SYSBEG
	MOVE	F,MEMSIZ##	;SAVE MEMSIZ(ALREADY SET UP)
	BLT	T1,SYSEND
	MOVEM	F,MEMSIZ##
	PUSHJ	P,NZRINI	;Set up any other nonzero values as needed
IFCPU (KL),<			; FOR KL with SIMULATOR LOADED
;*;	SKIPE	KL$SIM##	;IF ITS LOADED,
;*;	  JRST	SYS0A		;DON'T CLEAR JOB DATA AREA
;*;	MOVE	T1,[XWD 62,63]	;CLEAR SYSTEM PDL'S ETC ABOVE TRAP LOCATIONS
;*;	SETZM	62		;AND
;*;	BLT	T1,136		;UP TO BASE OF COMMON
>; End IFCPU (KL)

SYS0A:	MOVSI	T1,DVDIRIN+TTYATC
	HRRI	T1,ASSCON+ASSPRG
	HLRZ	F,DEVLST	;SCAN ALL DEVICES
SYS1:	ANDCAM	T1,DEVMOD(F)	;CLEAR DIRECTORY IN CORE BIT,
				;ASSIGNED BY CONSOLE & PROGRAM
	SETZB	T2,DEVLOG(F)	;CLEAR LOGICAL NAME AND T2
				; FOR NXM LOOP BELOW(SYS2-SYS3)

	MOVE	M,DEVMOD(F)
	SETZM	DEVIOS(F)
	SETZM	DEVBUF(F)
	TLNE	M,DVDSK!DVTTY
	  JRST	SYS2W		;DO NOT ASSIGN
	TRO	M,ASSCON
	MOVEM	M,DEVMOD(F)
	DPB	T2,PJOBN	;ASSIGNED TO JOB 0
SYS2W:	HLRZ	F, DEVSER(F)
	JUMPN	F, SYS1
IFCPU (KI),<
	MOVE	T1,ONCWBR
	HLRZM	T1,JBTUPM
> ; End IFCPU (KI)
IFNCPU (KI),<
	MOVEI	T1,UPT.PN
	MOVEM	T1,JBTUPM
> ; End IFNCPU (KI)
	MOVEM	T1,CURUPT
;NOW SET UP CORE THINGS.

	PUSHJ	P,FINALC	;SET UP THE SYSTEM TIME PCBS AND FREE CORE.
	PUSHJ	P,SETM2P	;SET UP INFO FOR M2 AND MP QS.
	MOVE	T2,SYSSIZ
	LSH	T2,-9	        ;CONVERT TO PAGES
	MOVEM	T2,SYSSZP
	HRRZ	T1,CFRLST	;
	HRRM	T2,CFRLST	;
	SUBI	T1,(T2)		;THE AMOUNT WE LOST
	SUB	T1,IOPQTA	;TAKE AWAY FROM CAVPGN FOR I/O PAGES.
	ADDB	T1,CAVPGN##	;ADJUST FREE PAGES
	MOVEM	T1,USRMAX	;MAX VALUE FOR MWSLIM. PATCHERS NOTICE !!
				; (MUST NOT INCLUDE I/O PAGES, OR ELSE
				; MAY NOT BE ABLE TO SWAP JOBS IN)
	HRRZ	T2,T1		;NOT LARGER THAN 18 BITS
	CAILE	T2,VPMAX	;MWSLIM:=SMALLER OF USRMAX,VPMAX
	 MOVEI	T2,VPMAX	;SO THAT HE GETS FULL LMAP
	MOVEM	T2,MWSLIM	;UNLESS NOT ENOUGH CORE FOR THAT.
	HRRZ	T2,T1		;18 BITS OF PAGE COUNT
	SUBI	T2,1
	LSH	T2,-2
	SUBI	T2,1
	LSH	T1,-1		;CONVERT USRMAX TO K
	CAMGE	T1,CORLIM	;MAKE SURE WE HAVE AT LEAST THIS MUCH CORE
	 STOPCD			;WE HAVE LESS THAN MINIMUM CORE, DON'T COME UP.
	MOVE	T1,CORLIM
	LSH	T1,-1
	SUBI	T1,1
	MOVEM	T1,CORMXK	;SET UP CORMXK.
	MOVE	PG,SYSSZP	;THE FIRST PAGE OF THE SYSTEM FOR USERS
	SETZ	W,		;
	SETO	T2,		;FOR SETTING PGYNXM AND PGYADR
	HRRZI	T4,CFR.N	;
	HRRZ	T3,CFRLST	;START OF FREE PAGE LIST.
NXPGLP:	CAMN	PG,T3		;IS NEXT FREE = NEXT PAGE
	  JRST	PAGXM		;YES, MARK IT THERE
	DPB	T2,PGYNXM	;NO, NOT THERE
	AOJA	PG,NXPGLP	;AND CONTINUE

PAGXM:	DPB	W,PGYBPL	;
	DPB	T4,PGYLST	;
	DPB	T2,PGYADR	;SAY NO DP IN THIS CP YET.
	CAIGE	PG,1000		;ARE WE ABOVE MAX ADDRESSABLE CORE?
	  MOVEM	PG,HGHBLK##	;NO. SAVE HIGH BLOCK ADDRESS.
	LDB	PG,PGYFPL	;NEXT FREE PAGE
	JUMPE	PG,PAGXMD	;FINISHED
	EXCH	PG,T3		;GET T3/ FPL, PG/ BPL.
	HRRZI	W,(PG)		;SAVE BPL.
	AOJA	PG,NXPGLP	;CONTINUE
PAGXMD:	MOVEI	P,SYSPDL##
	PUSHJ	P,TTYINI##	;INITIALIZE THINGS
	MOVEI	T1,(HALT)
	HRLM	T1,SYSDSP##	;NO MORE 140 RESTART
	PFALL	IOGO
SUBTTL	IOGO - Enable I/O device interrupts and go

IOGO:	SETZM	CRSHWD		;Clear location 30
IFCPU (KI),<
	WRAPR	APRIOB!APRNXM!APRIOP!APRDST!APRDSR
	WRAPR	APRCH2+APRENC	;APR RESET (IO RESET)
	WRPI	211577		;CLEAR PI SYSTEM (AND MEM PARITY)
>;END IFCPU (KI)
IFCPU (<KL,F3>),<
	WRAPR	LP.IOR+LP.CSF+LP.NXM+LP.PAR ;DON'T CLEAR STUFF THAT SHOULDN'T BE ON
	WRAPR	LP.ESF+APRMSK+APRCHN		    ;ENABLE FOR EVERYTHING
	WRPI	LI.CPP+LI.CPS+LI.COF+LI.PIF+LI.ACO  ;CLEAR PI SYSTEM
IFCPU (KL),<PUSHJ P,ITMINI>	;START UP INTERVAL TIMER, INIT TIME BASE, ETC.
>;END IFCPU (<KL,F3>)
IFCPU (KS),<
	WRAPR	LP.IOR+LP.CSF+LP.NXM+LP.HPE +LP.80C;DON'T CLEAR STUFF THAT SHOULDN'T BE ON
	WRAPR	LP.ESF+APRMSK-<LP.TIM+LP.80C>+APRCHN	;ENABLE FOR EVERYTHING EXCEPT 8080 & TIME
	WRPI	LI.CPP+LI.CPS+LI.COF+LI.PIF+LI.ACO ;CLEAR PI SYSTEM
	PUSHJ	P,ITMINI	;START UP INTERVAL TIMER, INIT TIME BASE
>;END IFCPU (KS)
				; DO NOT CLEAR POWER FAIL AS THIS DISABLES
	MOVEI	P,SYSPDL##	;REUSABLE SPACE(SEE IOINI1)
	PUSHJ	P,CTYSET##	;DO AFTER <WRAPR 200000> SO PI ASSIGNMENT STAYS.
	PUSHJ	P,NXTINI##	;ALWAYS INITILIZE SCHEDULER FIRST
				;SO DEVICES MAY RESET QUEUES IF DESIRED
	HLRZ	P3,DEVLST	;ADDR OF FIRST DDB
	SETZM	SAVITM
IOG01:	MOVE	F,P3		;SET UP F FOR INITIALIZATION CODE
				; (NOT ALWAYS USED)
	MOVE	P3,DEVSER(P3)
	HRRZ	T1,P3
	CAIE	T1,@SAVITM	;SAME DEVICE
	 PUSHJ	P,DINI(P3)	;NO. INITIALIZE IT.
	HRRZM	P3,SAVITM	;SKIP RETURN IF INITIALIZATION CODE IS TO BE CALLED
				; FOR EACH DEVICE (I.E. MULTIPLE LINE PRINTERS)
	HLRZS	P3
	JUMPN	P3,IOG01	;LOOP FOR ALL DEVICES
IFKMC<
	PUSHJ	P,DZINI##	;INITIALIZE DZ-11 DRIVER.
	PUSHJ	P,DRINI##	;INITIALIZE DR-11C DRIVER
	PUSHJ	P,KMCINI##	;INITIALIZE THE KMC COMMUNICATION
>; End IFKMC
	PUSHJ	P,CLKINI##	;INITIALIZE CLOCK QUEUE
	PUSHJ	P,TMPINI##	;TMPCOR
	PUSHJ	P,QINI##	;PUT ALL IN NULL QUE
	SETZM	SYSDRB
IFCPU (KI),<PUSHJ P,TIMINI##>	;DK-10
IFCPU (KI),<WRPI  52377>	;TURN ON PI SYSTEM
IFNCPU(KI),<WRPI LI.CON+LI.PIN+LI.ACO>
	SETZM	DINITF##	;End of ONCE code
	MOVSI	T1,(STAUTO)	; See if we are in
	TDNN	T1,STATES	; "auto"-restart mode.
	 JRST	IOGO2		; No!  So don't say anything.
	MOVEI	T1,[ASCIZ \
System in auto-restart, running INITIA
\]
	MOVEI	U,CTYLDB##	;ON CONSOLE
	PUSHJ	P,CONMES##	;LET OPERATOR KNOW WHAT IS GOING ON

IOGO2:	MOVEI	J,NULJOB##	;GET WHERE TO MAKE CLRONC POPJ TO
	PUSH	P,J		;SAVE ON STACK
	SETZ	J,		;NEXT JOB IS NULL JOB
	JRSTF	@.+1		;CLEAR OUT EXEC MAP ONCE-TIME ENTRIES,
	  PC.UIO,,CLRONC##	; SET PC.UIO AND POPJ TO NULJOB WHEN THRU.
;ERROR FOR NOW (DISCONTINUOUS CORE)

DSCCOR:	PUSHJ	P,CLRSND
	PUSHJ	P,INLMES
	ASCIZ	/
????Core is not contiguous, correct before trying to bring up system
/
	PUSHJ	P,OPOUT
	HALT	DSCCOR		;ERROR IF DISCONTIGUOUS CORE
;RELOAD UPT AND EPT FROM THIS STUFF

LOC40:	0
	STOPCD          ;;EPT+41
LOC42:	JSR	CH1
	STOPCD          ;;EPT+43
	JSR	CH2
	STOPCD          ;;EPT+45
	JSR	CH3
	STOPCD          ;;EPT+47
	JSR	CH4
	STOPCD          ;;EPT+51
	JSR	CH5
	STOPCD          ;;EPT+53
	JSR	CH6
	STOPCD          ;;EPT+55
	JSR	CH7
	STOPCD          ;;EPT+57

UPTSET:	USRMPE		;420 USER PAGE TRAP (SOFTWARE FOR KS AND KL)
	JFCL		;421 USER OVERFLOW
	ERRPOV		;422 USER PDL ERR
	JFCL		;423 USER TRAP 3
	0		;424 MUUO
	0		;425 PC OF MUUO
	0		;426 DATAI PAG, OF MUUO
	0		;427 RESERVED
	    UUOKNT	;430 KERNAL NO TRAP UUO
	    UUOKTR	;431 KERNAL TRAP UUO
	    UUOSNT	;432 SUPERVISOR NO TRAP
	    UUOSTR	;433 SUPERVISOR TRAP
IFNCPU(KS),<UUOCNT	;434 CONCEALED NO TRAP
	    UUOCTR	;435 CONCEALED TRAP
    PC.UIO,,UUOPNT	;436 PUBLIC NO TRAP
    PC.UIO,,UUOPTR>	;437 PUBLIC TRAP
IFCPU (KS),<
    PC.UIO,,UUOPNT	;434 NO TRAP, KS RUNS IN CONCEALED MODE
    PC.UIO,,UUOPTR	;435 TRAP, KS RUNS IN CONCEALED MODE
	0		;436 NO PUBLIC MODE ON KS
	0>		;437 NO PUBLIC TRAP ON KS

EPTSET:	EXCMPE		;420 EXEC MEM TRAP
	JFCL		;421 EXEC OVERFLOW
	EXCPDL		;422 EXEC PDLOV
	JFCL		;423 EXEC TRAP3

IFCPU (KI),<
NULACS:
	PHASE 0
	MOVEI	16,64000
	SOJG	16,.
NTS1:!	TLNE	17,400000
NTS2:!	TRNE	17,1
	  JRST	NULSHF
NTS3:!	TRNN	17,2
	  JRST	NULCMP
	TLC	NTS1,004000	;CONVERT TXNE AND TXNN
	TLC	NTS2,004000
	TLCA	NTS3,004000
NULCMP:!TRCA	17,1
NULSHF:!ROT	17,1
	DATAO	PI,17
	JRST	0
	0			;REG 16, SCRATCH
	1			;REG 17, STARTS AT 1
	DEPHASE
	PHASE NULACS+20
>;END IFCPU (KI)
IFCPU (<KL>),<
;ROUTINE TO INITIALIZE TIME BASE, ACCOUNTING CLOCK,
; AND INTERVAL TIMER.

ITMINI:	CONO	TIM,TO.CIT+TO.CTD	;CLEAR TIMER, TIMER DONE
	MOVE	T1,[JSR ITMINT##]
	MOVEM	T1,EPT+EPTITI	;THIS IS THE IRP INSTRUCTION
	CONO	MTR,MO.TON+ITMCHN##;START TIME BASE, GIVE INTERVAL PI ASSIGNMENT
	SETZM	EPT+EPTHTB
	SETZM	EPT+EPTLTB
	SETZM	EPT+EPTHPA
	SETZM	EPT+EPTLPA
	WRPAE	[PE.CLR]	;CLEAR PERF METER
	WRUBR	[LG.IAM]	;CLEAR OUT E AND M BOX COUNTS
	SETZM	UPT+UPTHEC
	SETZM	UPT+UPTLEC
	SETZM	UPT+UPTHMC
	SETZM	UPT+UPTLMC
	CONO	MTR,MO.LAC+MO.AEN+MO.AO+MO.CTB
				;TURN ON ACCT METERS
	CONO	TIM,TO.SIT+TO.CTD+^D1666 ;GET INTERVAL TIMERSTARTED.
	POPJ	P,		;EVERYTHING ALL SET.
>;END IFCPU (KL)

IFCPU (KS),<
;ROUTINE TO INITIALIZE TIME BASE, INTERVAL COUNTER

ITMINI:	WRAPR	LP.CSF+LP.ITD	;CLEAR TIMER DONE
	WRTIME	ITMCLR		;CLEAR TIME BASE
	WRINT	ITMTIM		;SET INTERVAL UP
	WRAPR	LP.ESF+LP.TIM+APRCHN	;START INTERVAL TIMER
	HRLI	T1,(JRST 7,)	;SET UP 71 ,FOR CTY KEEP ALIVE FAILURE
	HRRI	T1,KAFPC##	; ...
	MOVEM	T1,KAFLOC##	; STORE IN LOW CORE
	MOVSI	T1,(KPACT)	;INIT RELOAD WORD,ENABLE KEEP ALIVE COUNTER
	JFCL	;**D*	MOVEM	T1,RLWORD##	;START KEEP ALIVE
	JFCL
	POPJ	P,

ITMCLR:	EXP 0,0			; Values to clear time base.
ITMTIM:	^D16B23			; Interval time.
>;END IFCPU (KS)
SUBTTL	NZRINI - Called after SYS0 zeros out SYSBEG-SYSEND in COMMON

NZRINI:	MOVEI	T1,INADFL##	;Setup default inactivity timeout
	MOVEM	T1,INADEF##	; (NSWTBL+7)
	SETOM	SYSUDT##	;No date/time yet (NSWTBL+5)
	MOVEI	T1,TIMZON##+20+40;PST+daylight = 50 = 20+40+^D<-8>
	MOVEI	J,0		;PVYTIM uses J as an index register
	DPB	T1,PVYTIM##	;Job 0 has local TIMZON
	POPJ	P,
;TELTYPE ROUTINES

;ROUTINE TO READ A U FROM OPERATORS CONSOLE
;CALL:	PUSHJ P,GETLIN
;	JUST A CR TYPED IN
;	NORMAL RETURN (NOT A BLANK LINE)

GETLIN::MOVE T1,LINEPI
	MOVEM T1,ONCTIP	;INITIAL STORAGE POINTER
	SETZM BKSLS	;NOT IN BACKSLASHES
	MOVEI T3,40		;PRIME COMMAND ROUTINES WITH A SPACE
	MOVEM T3,TTCMCH		; ..
	MOVEI J,0		;FLAG NO ALTMODE SEEN
IFCPU(KS),<WRAPR LP.SSF!LP.I8C+APRCHN##>	;Tell the 8080 to pay attention
GET1:	PUSHJ P,XTYI		;WAIT FOR A CHARACTER
IFCPU (<KI,F3>),<DATAI	TTY,T3>		;GET IT
IFCPU (<KL,KS>),<PUSHJ	P,TYI1>
	ANDI T3,177		;STRIP PARITY
	CAIN T3,177		;RUBOUT?
	 JRST DELETE		;YES
	CAIN T3,"U"-100
	 JRST DELLIN
	CAIE T3,"C"-100
	CAIN T3,"O"-100
	 JRST GET1	;IGNORE ^C AND ^O
	PUSHJ P,LEVBKS	;IN CAS IN BACKSLASHES
	CAIN T3,33		;ALTMODE/ESCAPE?
	 JRST GETLN1		;YES
	CAIE T3,175		;OTHER ALTS?
	CAIN T3,176		; ..
	 JRST GETLN1		;YES
GET2:	PUSHJ P,XTYO		;ECHO
	CAIL T3,140		;LOWER CASE?
	TRZ T3,40		;YES. MAKE UPPER
	IDPB T3,ONCTIP		;STORE IN INPUT BUFFER
	CAIE T3,15		;CAR RET?
	AOJA J,GET1		;NO. LOOP TILL BREAK
	MOVEI T3,12		;YES. ADD LF
	PUSHJ P,XTYO		;OUTPUT LF
	MOVEI T3,0		;TERMINATE INPUT STRING IN BUFFER
	IDPB T3,ONCTIP		; ..
	MOVE T1,LINEPI
	EXCH T1,ONCTIP		;INITIAL STORAGE POINTER
	JUMPN J,CPOPJ1		;IF NON-NULL U, SKIP RET
	POPJ P,0		;NULL. NON-SKIP RET

BKSLS:	0
DELETE:	SOJL J,DELET1	;NOTHING THERE
	PUSHJ P,ENTBKS	;SEND \ IF NEEDED
	LDB T3,T1
	PUSHJ P,XTYO
	SUBI T1,1
	REPEAT 4,<IBP T1>
	JRST GET1	;BACK TO WORK

DELET1:	PUSHJ P,LEVBKS
	MOVEI T3,15
	PUSHJ P,XTYO
	MOVEI T3,12
	PUSHJ P,XTYO
	JRST GETLIN

GETLN1:	SETOM J		;MECHANISM USED TO BY-PASS PART OF DIALOGUE
	MOVEI T3,"$"
	PUSHJ P,XTYO
	MOVEI T3,15		; WHEN ALTMODE IS TYPED.
	JRST GET2

DELLIN:	PUSHJ P,LEVBKS
	PUSHJ P,ECHU		;ECHO THE ^U
	JRST GETLIN

LEVBKS:	SKIPN BKSLS
	POPJ P,		;NOT IN
COMBKS:	PUSH P,T3
	MOVEI T3,"\"
	PUSHJ P,XTYO
	POP P,T3
	SETCMM BKSLS	;COMPLIMENT
	POPJ P,

ENTBKS:	SKIPE BKSLS
	POPJ P,
	JRST COMBKS

ECHU:	PUSH P,T3
	MOVEI T3,"^"
	PUSHJ P,XTYO
	MOVE T3,(P)
	ADDI T3,100
	PUSHJ P,XTYO
	MOVEI T3,15
	PUSHJ P,XTYO
	MOVEI T3,12
	PUSHJ P,XTYO
	POP P,T3
	POPJ P,

OCONM::	PUSHJ P,CLRSND		;CLEAR OUTPUT SUPRESS FLAGS
	JRST CONMES		;OUTPUT MESSAGE

ONCTOS:	MOVEI T3,ONCTSZ		;SIZE OF BUFFER
	MOVEM T3,ONCCNT		;SO CANT OVERFLOW
	SETZM LINWID		;Force CRLF out before anything else
	MOVEI T3,ONCTYI		;ADDRESS FOR READ ROUTINES TO GO TO
	MOVEM T3,COMTIA		; ..
	MOVEI T3,ONCTYO		;ADDRESS FOR TYPEOUT ROUTINES TO GO TO
	MOVEM T3,COMTOA		; ..
	MOVE T3,LINEP		;INITIAL OUTPUT POINTER
	MOVEM T3,ONCTOP
CLRSND::SETZM SUPTYP
	SETZM SUPTYC
	POPJ P,0

YESNO::	PUSHJ P,OCONM		;FIRST OUTPUT THE QUESTION
	PUSHJ P,OPOUT
	PUSHJ P,GETLIN		;NOW GET RESPONSE
	  POPJ P,0		;JUST C-R
	PUSHJ P,COMTYI
	TRZ T3,40		;FIRST CHAR OF RESPONSE (U.C.)
	CAIN T3,"Y"		;WAS IT A Y ?
	 AOS 0(P)		;YES. SKIP
	POPJ P,			;NO, MAYBE IT WAS "N". SO DON'T SKIP

LINWID:	0
SUPTYP:	0
SUPTYC:	0

RADIX8:	IDIVI T1,10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,RADIX8	;PRINT OCTAL
	HLRZ T3,(P)
	ADDI T3,"0"
	JRST COMTYO
;ROUTINE TO TYPE A U ON OPERATOR CONSOLE
;ECHO CHECK STOPS U AND RETURNS
;CALL:	U SET TO END OF MESSAGE

CONOUT:	PUSHJ	P,CONMES	;Output ASCIZ string in T1 + CRLF
CRLFOP:	PUSHJ	P,CRLF		;Output CRLF and dump output buffer
OPOUT::	MOVEI T3,0		;MAKE SURE STRING ENDS
	IDPB T3,ONCTOP		;WITH A NULL
	MOVE T1,LINEP		;AND RESTART AT BEGINNING
	MOVEM T1,ONCTOP	; ..
IFCPU (<KI,F3>),<CONO TTY,TT.CID>		;CLEAR INPUT FLAG
OPOUT1:
IFCPU(<KI,F3>),<CONSZ TTY,TT.ID>		;MAKE SURE NOT BEING INTERRUPTED
IFCPU(KL),<     SKIPE EPT+SPCMTI>
IFCPU(KS),<     SKIPE CTYIWD##>	;SKIP IF NO INPUT
		 JRST OPOUT2	;INPUT FLAG
OPOUT3:	ILDB T3,ONCTOP		;GET CHAR TO TYPE
	JUMPE T3,OTST3		;QUIT ON NULL, AND RESET OUTPUT
	PUSHJ P,XTYO		;TYPE CHAR
	JRST OPOUT1		;LOOP

OPOUT2:	IFCPU (<KI,F3>),<DATAI TTY,T3>
	IFCPU (<KL,KS>),<PUSHJ P,TYI1>
	ANDI T3,177	;GET RID OF PARITY BIT
	CAIE T3,"O"-100
	CAIN T3,"C"-100
	 SKIPA
	JRST OPOUT1	;IGNORE ALL BUT ^O AND ^C
	PUSHJ P,ECHU
	CAIN T3,"C"-100
	 SETOM SUPTYC	;IF ^C SET TO SUPRESS UNTIL QUESTION
	SETOM SUPTYP	;IN ANY CASE UNTIL CRLF
OTST3:	MOVE T3,LINEP	;RESET OUTPUT
	MOVEM T3,ONCTOP
	MOVEI T3,ONCTSZ
	MOVEM T3,ONCCNT
	POPJ P,

IFCPU (KL),<
TYI1:	MOVE	T3,EPT+SPCF11
	CONO	DTE,CL11PT
	SETZM	EPT+SPCMTI
	POPJ	P,
>;END IFCPU (KL)


IFCPU (KS),<
TYI1:	MOVE	T3,CTYIWD	;GET CHARACTER
	SETZM	CTYIWD##	;CLEAR INPUT WORD
	TRNE	T3,CTYIVL	;CHECK VALID
	 POPJ	P,		;THAT BIT SHOULD BE SET
        MOVEM	T3,TYI1XX	;*HACK* INVALID NONZERO INDICATION!
	JRST	TYI1		;JUMP IF CHAR. NOT YET VALID
TYI1XX: 0
> ;END IFCPU (KS)
ONCTIP:	0			;TYPE-IN POINTER
ONCTOP:	0			;TYPE-OUT POINTER
ONCCNT:	0			;COUNTER FOR TYO
LINEP:	POINT 7,LINBUF		;INPUT AND OUTPUT U BUFFER
LINBUF:	BLOCK 30
ONCTSZ==<30*5>-1		;CHARACTERS WHICH FIT IN OUTPUT BUFFER
LINBFI:	BLOCK 30	;BUFFER FOR INPUT
LINEPI:	POINT 7,LINBFI
CORLIM:	USRLIM			;PRSET CORE LIMIT, MAY CHANGE
SAVITM:	0		;TEMP FOR INITIALIZING DEVICES
;WAIT TIL INPUT DONE ON BEFORE RETURNING WITH NEXT CHAR.

XTYI:
IFCPU(<KI,F3>),<CONSO	TTY,TT.ID>
IFCPU(KL),<	SKIPN	EPT+SPCMTI>
IFCPU(KS),<	SKIPN	CTYIWD##>
		 JRST	XTYI
	POPJ P,

ONCTYO:	SKIPE SUPTYC
	POPJ P,		;WANT ALL SUPPRESSED
	SKIPE SUPTYP
	JRST ETYCHK	;CHECK FOR LINE FEED TO END SUP
	SOSLE ONCCNT		;COUNT CHARACTERS
	IDPB T3,ONCTOP		;PUT IN BUFFER
	POPJ P,0		;AND RETURN

ONCTYI:	ILDB T3,ONCTIP		;GET INPUT CHARACTER
	MOVEM T3,TTCMCH		;STORE FOR RE-READS
	POPJ P,0		;AND RETURN TO CALLING ROUTINE

ETYCHK:	CAIN T3,12
	SETZM SUPTYP
	POPJ P,

XTYO:	PUSH	P,T1		;Routine to output to the CTY, with wrap at 80
	ANDI	T3,177		;Strip parity
	CAIE	T3,12
	CAIN	T3,177
	 JRST	NOFCR		;DO NOT COUNT LINE FEED OR RUBOUT
	CAIN	T3,15
	 JRST	[MOVEI T1,^D<72+8>
		 MOVEM T1,LINWID	;RESET COUNT BEFORE CR
		 JRST  NOFCR]
	SOSL	LINWID		;Check if line width exceeded
	 JRST	NOFCR
	PUSH	P,T3		;Time for free CRLF
	MOVEI	T3,15
	PUSHJ	P,XTYO		;Recursive call to set LINWID
	MOVEI	T3,12
	PUSHJ	P,XTYO
	POP	P,T3
NOFCR:	PUSHJ	P,CTYLOG##	;Log character in CTYBUF
	PUSHJ	P,MSGLOG##	;Log character in MSGBUF
	PUSHJ	P,PEVEN8##	;GET PARITY
	PUSHJ	P,CTYCHR##	;Output to the CTY
	ANDI	T3,177
	CAIN	T3,12		;Linefeed?
	 JRST	[MOVEI T3,0	  ;Yes, pad with a null
		 PUSHJ P,CTYCHR## ;So it won't get lost when DTE is reset
		 JRST  TPOPJ]
	CAIN	T3,15		;CHECK POSSIBLE RETURN
	SKIPN	T1,CTYFIL##	;YES, NEED FILLS?
	 JRST	TPOPJ		;NO
	MOVEI	T3,177
	PUSHJ	P,XTYO
	SOJG	T1,.-1
	MOVEI	T3,15
TPOPJ:	POP	P,T1
	POPJ	P,
REPEAT 0,<;TYO1 has been replaced by CTYCHR in SCNSER
IFCPU (<KI,F3>),<
TYO1:	CONSZ	TTY,TT.OB	;Wait for output busy to go off
	 JRST	TYO1
	DATAO	TTY,T3
	POPJ	P,
>
IFCPU (KL),<	;CHARACTER OUTPUT FOR CTY VIA DTE AND PDP-11
TYO1:	HRLM	T3,(P)
	MOVEI	T3,.DTCTO(T3)
	MOVEM	T3,EPT+SPCCMW
	CONO	DTE,TO11DB
	SETZ	T3,
	EXCH	T3,EPT+SPCMTD	;Wait for MTD to become nonzero
	JUMPE	T3,.-1
	HLRZ	T3,(P)
	POPJ	P,
>;END IFCPU (KL)


IFCPU (KS),<	;CHARACTER OUTPUT FOR CTY ON KS2020
TYO1:	SKIPE	CTYOWD##		;WAIT TIL EMPTY
	 JRST	.-1
	TRO	T3,CTYOVL		;SET THE VALID FLAG
	MOVEM	T3,CTYOWD##		;MOVE TO OUTPUT WORD
	WRAPR	LP.SSF!LP.I8C+APRCHN	;WHAP THE 8080
	SKIPE	CTYOWD			;WAIT TIL CHAR TAKEN
	 JRST	.-1
	POPJ	P,
>;END IFCPU (KS)
>  ;End REPEAT 0
;FINISH UP THINGS
ONCLIT:	LIT
	VAR
ONCLNR==.-%ONC+1
ONCLNP==:<ONCLNR!777>+1

ONSZCK(ONCE,ONC)	;CHECK TO SEE IF ENOUGH PAGES ALLOCATED

DEPHASE

ONCEND:	END ONCGO	;Cannot use $END in PHASEd code
     J[is"