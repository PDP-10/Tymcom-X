TITLE PICON - HANDLE USER PSEUDO INTERRUPTS. ALSO APR INTERRUPT

;TRAP HANDLER ALL TRAPS HAVE UUO INSTUCTIONS

INTERNAL UUOKTR,UUOPTR,KTRRET,KTRRT1,STKAC
EXTERNAL UUOPN1,EPLLEN,XACSTL,HIGHJB
EXTERNAL ESTOP,GETOPR,INLMES,JBTUPM,OCTPNT
EXTERNAL JBTSTS,JBTPRV,JOBN,MLOWQ
EXTERNAL UPTACP,UPTAC0,UPTPC,UPTPDL,%UPT,%UPS,EPYPSN
EXTERNAL APRCHN

IFCPU (KI),<
;KI10 EXEC MODE TRAP

UUOKTR:	MOVEM	17,@%UPT+UPTACP	;STACK AC'S IN UPT
	JSP	17,STKAC
	PUSH	P,%UPT+UPTMUP	;SAVE RETURN ADDRESS
	JRST	@%UPT+UPTMUU	;DISPATCH ON ADDRESS FROM UUO

STKAC:	EXCH	17,%UPT+UPTACP
	HLLM	17,%UPT+UPTACP
	HRRZS	17
	CAIN	17,%UPT+UPTAC0+20*XACSTL
	  STOPCD
	SUBI	17,17
	MOVEM	16,16(17)
	MOVE	16,17
	BLT	16,15(17)
	ADDI	17,37
	CAIN	17,%UPT+UPTAC0+20*XACSTL+17
	  MOVEI	17,%UPT+UPTAC0+20*XACSTL
	HLRZ	T1,%UPT+UPTACP
	ADDI	T1,20000
	RDEBR	T2
	TRZ	T2,760000
	IOR	T2,T1
	WREBR	(T2)
	HRL	17,T1
	EXCH	17,%UPT+UPTACP
	JRST	(17)

KTRRT1:	POP	P,%UPT+UPTMUP	;RESTORE RETURN ADR
KTRRET:	MOVSI	T1,PC.TRP	;RETURN FROM EXEC TRAP
	ANDCAM	T1,%UPT+UPTMUP
	HRRZ	17,%UPT+UPTACP
	CAIN	17,%UPT+UPTAC0+20*XACSTL
	  MOVEI	17,%UPT+UPTAC0+20*XACSTL+17
	SUBI	17,20
	HRRM	17,%UPT+UPTACP
	SUBI	17,17
	MOVSS	17
	HLRZ	16,%UPT+UPTACP
	SUBI	16,20000
	HRLM	16,%UPT+UPTACP
	RDEBR	T2
	TRZ	T2,760000
	IOR	T2,16
	WREBR	(T2)
	BLT	17,17
	JRSTF	@%UPT+UPTMUP
>;END IFCPU KI

;USER TRAP

UUOPTR:	EXECAC				;SWITCH TO EXEC ACS
	SKIPN	M,%UPT+UPTMUU		;GET THE UUO
	 STOPCD	.			;ONLY ZERO FROM NULL JOB
	TLNE	M,777000		;IS IT A 0
	  JRST	UUOPN1			;NO, USER SUPPLIED INSTRUCTION
	MOVE	P,[IOWD EPLLEN,%UPT+UPTPDL]
	PUSH	P,%UPT+UPTMUP		;SAVE RETURN ADDRESS
	JRST	(M)			;DISPATCH
SUBTTL UUO TRAP ROUTINES

;KL10 EXEC AND USER MODE TRAP UUO ROUTINES.

IFNCPU (KI),<

;EXEC MODE

BADTRP==1		;TO DELINEATE KL10 TRAP BUG CODE

INTERNAL PGFUIO
EXTERNAL EXCMPE

UUOKTR:	MOVEM	16,@%UPT+UPTACP	;SAVE AC 16
	JSP	16,STKAC	;STACK ACS
	PUSH	P,%UPT+UPTMUP	;SAVE RETURN ADDRES ON STACK
	JRST	@%UPT+UPTMUU	;DISPATCH ON ADDRESS IN UUO.

;PAGE FAILS COME HERE, EXEC AND USER MODE, USER IOT SET IN PC.

PGFUIO:	XWD	PC.UIO,PGFAIL	;ADDRESS POINTER USED IN ONCE

PGFAIL::MOVEM	16,@%UPT+UPTACP ;SAVE SOMEONE'S AC 16
	MOVE	16,%UPT+UPTOPP	;GET PAGE FAIL PC
	TLNN	16,PC.USR	;FROM USER?
	  JRST	PGFAI1		;NO, EXEC. GO STACK ACS.
IFN BADTRP,<;THIS CODE TO GET AROUND KL TRAP INSTRUCTION BUG
	TLNE	16,PC.TRP	;ANY TRAP FLAGS ON
	  JRST	PGFPCT		;YES, GO DO SPECIAL CHECK
>;END IFN BADTRP
	MOVE	16,@%UPT+UPTACP	;GET AC 16 BACK FOR USER
	EXECAC			;FIRST LEVEL OF EXEC ACS
	MOVE	P,[IOWD EPLLEN,%UPT+UPTPDL]
	PUSH	P,%UPT+UPTOPP
	JRST	@%UPT+UPTPGT	;DISPATCH TO PROPER FAULT HANDLING ROUTINE FOR USER.

PGFAI1:	JSP	16,STKAC	;STACK REST OF THE ACS
	PUSH	P,%UPT+UPTOPP	;STACK THE PC
	JRSTF	@[EXCMPE]	;CLEAR USER IOT AND GO DO EXEC FAULT.

IFN BADTRP,<

;THE FOLLOWING CODE IS AN ATTEMPT TO COMPENSATE FOR A KL10 HARDWARE
; BUG. THE BUG: IF A TRAP INSTRUCTION (ARITH OVERFLOW, PDL OVERFLOW, TRAP 3)
; CAUSES THE PC TO CHANGE, AND FETCHING THE NEW PC CAUSES A PAGE FAULT,
; THE RELEVANT TRAP FLAGS IN THE LH OF PC ARE STILL SET EVEN THOUGH
; THE TRAP CYCLE HAS COMPLETED. (FETCHING THE FIRST WORD OF THE
; TRAP ROUTINE IS NOT PART OF THE ACTUAL TRAP INSTRUCTION).
; THIS WILL CAUSE A SECOND TRAP, AS IF ONE HAD OCCURRED AT THE
; LOCATION IMMEDIATELY BEFORE THE START OF THE TRAP ROUTINE.
; THE TEMPORARY FIX IS TO SEE IF VIRTUAL ADDRESS AND PC MATCH
; WHEN WE GET A PAGE FAIL OLD PC WITH ANY TRAP FLAGS ON,
; AND TURN THE TRAP FLAGS OFF IF THIS IS TRUE. THE ONLY CASE WHERE
; THIS FAILS IS IF THE TRAP INSTRUCTION CANNOT COMPLETE BECAUSE
; OF A PAGE FAULT FOR THE WORD IMMEDIATELY FOLLOWING THE INSTRUCTION
; THAT CAUSED THE TRAP. THIS CIRCUMSTANCE IS CONSIDERED INFREQUENT
; ENOUGH TO JUSTIFY INSTALLING THIS FIX.

PGFPCT:	MOVE	16,@%UPT+UPTACP	;RESTORE USER'S AC 16
	EXECAC			;SWITCH TO EXEC ACS
	MOVE	P,[IOWD EPLLEN,%UPT+UPTPDL]
	MOVE	T1,%UPT+UPTOPP	;GET OLD PAGE FAIL PC
	PUSH	P,T1		;SAVE ON STACK LIKE REGULAR
	XOR	T1,%UPT+UPTPFW	;1S IN RH WHERE PC AND VA ARE DIFFERENT
	  TRNE	T1,-1		;SKIP IF NO DIFFERENCES IN PC AND VA
	JRST	@%UPT+UPTPGT	;LEGIT PAGE FAIL DURING TRAP INSTRUCTION
	MOVSI	T1,PC.TRP	;MOST LIKELY THIS IS THE BUG. CLEAR TRAP
	ANDCAM	T1,(P)		;FLAGS IN PC WORD ON STACK
	ANDCAM	T1,%UPT+UPTOPP	;AND IN OPP (IN CASE SOMEONE LOOKS THERE)
	JRST	@%UPT+UPTPGT	;AND DISPATCH TO PROPER ROUTINE.
>;END IFN BADTRP

;STILL IN FTKL10
SUBTTL KL10 AC STACK ROUTINES

COMMENT !

THE FOLLOWING IS A STATE TABLE SHOWING WHERE AC DATA LIVES.

CURRENT		PREVIOUS	STACK [CONTEXT SWITCH]
-------		--------	----------------------
USRACB		USRACB		-EMPTY-
EX0ACB(1)	USRACB		-EMPTY-
EX1ACB(1)	EX0ACB(1)	-EMPTY- [EX0ACB(1)]
EX0ACB(2)	EX1ACB(1)	EX0ACB(1) [EX1ACB(1)]
EX1ACB(2)	EX0ACB(2)	EX0ACB(1) EX1ACB(1) [EX0ACB(2)]
EX0ACB(3)	EX1ACB(2)	EX0ACB(1) EX1ACB(1) EX0ACB(2) [EX1ACB(2)]

NOTES:
IF CODE HAS PC.UIO OFF AND WISHES TO TURN IT ON IN ORDER
TO REFERENCE USER SPACE, CONTEXT SWITCHING CODE AND AC STACK
CODE WILL SET PREVIOUS AC BLOCK IN HARDWARE (WRUBR	)
TO USRACB, EVEN THOUGH UPTACP INDICATES THE ORIGINAL
PREVIOUS AC BLOCK.

AT CONTEXT SWITCH TIME, THE CURRENT EXEC ACS ARE SAVED
IN UPTXAC IF THE PC IS IN EXEC MODE.

WHEN SETTING USER IOT IN THE PC WORD, IT IS NOT NECESSARY
TO DO A WRUBR  TO SET PREVIOUS AC BLOCK TO USER ACS
UNLESS NECESSARY - HOWEVER, IF PAGE FAULT OR RESCHEDULE
OCCURS PREVIOUS AC BLOCK WILL BE SET TO USER. THEREFORE,
CODE THAT SETS USER IOT IN PC SHOULD ALWAYS RESTORE
STATE OF PREVIOUS AC BLOCK WITH "WRUBR	%UPT+UPTACP"
IN THE PLACE WHERE IT RESTORES THE ORIGINAL SETTING
OF USER IOT.

WHILE THE USER IS RUNNING, BOTH CURRENT AND PREVIOUS
AC BLOCKS ARE SET TO USRACB, BUT UPTACP CONTAINS
EX0ACB AS CURRENT AC BLOCK, USRACB AS PREVIOUS AC BLOCK.

!
COMMENT;@@SUBROUTINE STKAC
@@PURPOSE PROVIDE A STACK OF PREVIOUS CONTEXT ACS IN ORDER
TO ALLOW NESTING OF PAGE FAULTS AND UUOS
@@ENTRY
	MOVEM	16,@%UPT+UPTACP
	JSP	16,STKAC
	<ONLY RETURN>
LH OF UPTACP MUST BE SETUP TO REFLECT STATE OF CURRENT
AC STACK.
@@ACCUM PRESERVES DATA IN ALL ACS IN THE BLOCK SET AS CURRENT
AT TIME OF CALL. ON RETURN, CONTENTS OF ALL ACS
EXCEPT FOR P ARE UNSPECIFIED.
@@EXIT AC P SET TO VALUE OF AC P IN ORIGINAL CURRENT BLOCK.
@@RESTRICTIONS ADDRESSES IN AC STACK MUST BE LESS THAN 400000,
SO WRUBR %UPT+UPTACP DOES NOT SET 400000 (INHIBIT ACCT METER STORE)
AC STACK MUST START ON 16 WORD BOUNDARY, SO TRNE 17 CAN BE
USED FOR OVERFLOW CHECK.
;
IFN USRACB,<PRINTX USER AC BLOCK MUST BE BLOCK 0>
IFN EX0ACB-1,<PRINTX EX0ACB MUST BE SET TO 1>
IFN EX1ACB-2,<PRINTX EX0ACB MUST BE SET TO 2>
COMMENT ; THIS IS SO TLNE AC,(LG.PAC) IS QUICK CHECK FOR PREVIOUS
BLOCK SET TO USER, AND A TLC CAN BE USED TO QUICKLY SWAP
EX0ACB AND EX1ACB.
@@FUNCTION
IF PREVIOUS AC BLOCK SET TO USER, SET CURRENT AC BLOCK
TO EX1, PREVIOUS TO EX0, COPY AC P FROM EX0 TO ACP IN EX1,
AND RETURN.
IF PREVIOUS AC BLOCK SET TO AN EXEC BLOCK (EVEN IF USER IOT
IS ON AND HARDWARE PREVIOUS BLOCK IS REALLY SET TO USRACB)
SWAP PREVIOUS AND CURRENT AC BLOCKS, SAVE "NEW" CURRENT
(OLD PREVIOUS) ON AC STACK (CRASH IF OVERFLOW),
SETUP P FROM PREVIOUS ACS, AND RETURN.
@@;

STKAC:	EXCH	16,%UPT+UPTACP	;SAVE PC, GET AC POINTER
	TLNE	16,(LG.PAC)	;PREVIOUS ACS USER?
	  JRST	STKAC1		;NO, GO STACK PREVIOUS ACS
	HRLI	16,(LG.LAB+<EX1ACB>B8+<EX0ACB>B11)
	EXCH	16,%UPT+UPTACP	;EX0 NOW PREVIOUS
	EXCH	16,@%UPT+UPTACP	;GET AC 16 BACK, SAVE PC IN AC STACK
	WRUBR	%UPT+UPTACP	;NEW AC BLOCK ASSIGNMENTS NOW.
	XCTFU	<MOVE P,P>	;GET COPY OF P TO USE
	MOVE	16,@%UPT+UPTACP	;GET PC IN AC 16
	JRST	(16)		;AND RETURN.

;HERE IF PREVIOUS AC BLOCKS SET TO AN EXEC BLOCK - NEED TO STACK IT

STKAC1:	TLC	16,(3B8+3B11)	;2_1 AND 1_2
	EXCH	16,%UPT+UPTACP	;SAVE POINTER, GET PC
	EXCH	16,@%UPT+UPTACP	;GET AC 16 BACK, SAVE PC IN STACK.
	WRUBR	%UPT+UPTACP	;NEW AC BLOCKS NOW.
	EXCH	16,@%UPT+UPTACP	;SAVE OLD PREVIOUS AC 16 IN STACK,GET PC
	EXCH	16,%UPT+UPTACP	;GET AC POINTER, SAVE PC
	MOVEM	17,1(16)	;SAVE 17 IN AC STACK (16 THERE TOO)
	MOVEI	17,-16(16)	;0,,WORD 0 OF STACK
	TRNE	17,17		;OVERFLOW?
	  STOPCD		;YES, CRASH
	BLT	17,-1(16)	;SAVE 0-15 IN STACK
	ADDI	16,20		;ADVANCE STACK POINTER
	HRRZ	17,16		;COMPARE ONLY RIGHT HALF
	CAIN	17,%UPT+UPTAC0+20*XACSTL+16	;MORE ROOM??
	  HRRI	16,%UPT+UPTAC0+20*XACSTL	;NO - CRASH NEXT TIME
	EXCH	16,%UPT+UPTACP	;SAVE NEW POINTER, GET PC
	XCTFU	<MOVE P,P>	;GET COPY OF P FROM PREVIOUS ACS
	JRST	(16)		;AND RETURN.
;HERE TO UNSTACK ACS AFTER PAGE FAIL OR UUO WHICH HAS NESTED.
; ENTER AT KTRRT1 IF PC IS ON STACK, KTRRET IF PC IS IN
; UPTMUP.

KTRRT1:	POP	P,%UPT+UPTMUP	;GET PC INTO MUP
KTRRET:	MOVSI	T1,PC.TRP	;CLEAR THESE SO HE WON'T TRAP AGAIN.
	ANDCAM	T1,%UPT+UPTMUP
	HRRZ	17,%UPT+UPTACP	;GET STACK POINTER ADDRESS
	CAIE	17,%UPT+UPTAC0+16 ;ANYTHING STACKED?
	  JRST	KTRRT2		;YES, MUST RESTORE IT.
	HRLI	17,(LG.LAB+<EX0ACB>B8+<USRACB>B11)
	MOVEM	17,%UPT+UPTACP	;NO, SET TO TOP LEVEL STATE AGAIN
	WRUBR	17		;AND
	JRSTF	@%UPT+UPTMUP	;RETURN.

;HERE TO UNSTACK SOME EXEC ACS

KTRRT2:	CAIN	17,%UPT+UPTAC0+20*XACSTL ;FULL AT THE MOMENT?
	  MOVEI	17,%UPT+UPTAC0+20*XACSTL+16 ;YES, RESET POINTER TO REAL PLACE
	SUBI	17,20		;POP A LEVEL OF ACS OFF
	HLL	17,%UPT+UPTACP	;GET AC BLOCK INFO
	TLC	17,(3B8+3B11)	;1_2 AND 2_1
	MOVEM	17,%UPT+UPTACP	;SET NEW POINTER
	MOVE	16,%UPT+UPTMUP	;DID HE HAVE USER IOT SET?
	TLNE	16,PC.UIO
	  JRST	KTRRT3		;YES, DO THIS DIFFERENTLY.
	MOVSI	17,-16(17)	;1ST LOC,,0
	BLT	17,17		;RESTORE "PREVIOUS" AC DATA
	WRUBR	%UPT+UPTACP	;NOW MAKE THAT BLOCK PREVIOUS
	JRSTF	@%UPT+UPTMUP	;AND RETURN.

;HERE IF USER IOT WAS SET AT TIME OF PAGE FAULT OR UUO AND
; UPTACP SAID PREVIOUS AC BLOCK WAS NOT USER. PROGRAM
; TURNED ON USER IOT TO REFER TO USER SPACE, SO RESTORE
; THE SAVED PREVIOUS EXEC ACS AND THEN INSTEAD OF
; MAKING THEM PREVIOUS AC BLOCK, MAKE USER AC BLOCK PREVIOUS
; SO THAT ALL EXECUTIVE XCTS REFER TO USER'S DATA.

KTRRT3:	MOVSI	17,-16(17)	;1ST STACK LOC,,0
	BLT	17,17		;RESTORE "REAL" PREVIOUS AC DATA
				;AC 16 STILL IN AC STACK.
	HLLZ	16,%UPT+UPTACP	;GET AC BLOCK INFO
	TLZ	16,(LG.PAC)	;USE SPECIFIED CURRENT BLOCK, BUT PREVIOUS BLOCK = USER.
	EXCH	16,@%UPT+UPTACP	;RESTORE 16, PUT WRUBR  WORD IN AC STACK
	WRUBR	@%UPT+UPTACP	;SET NEW AC BLOCKS 
	JRSTF	@%UPT+UPTMUP	;AND RETURN.
>;END IFNCPU KI
;HERE ON AN INTERRUPT FROM THE APR

INTERNAL APRINT
EXTERNAL CTYDO
IFCPU (KS),<EXTERNAL DZDO>

APRINT:	CONSO	APR,APRMSK
	JRST	.		;NOT RELLY FOR APR
IFCPU (KS),<TBSAVE  TBVAPR>	;SAVE THE TIME BASE VALUE
	CONSZ	APR,APFMSK
	JRST	APRFAT		;THESE	ARE ALL FATAL - SOME EVEN HALT.

IFCPU (<KI,F3>),<;IF KL, THEN MUST BE PARITY ERROR, DON'T HAVE TO CHECK
	CONSZ	APR,APRPAR
	JRST	APRPR1		;PARITY ERROR
	MOVEM	T1,SAVT1	;GET HERE FOR KI AND F3 CLOCK
IFCPU (KI),<;ONLY KI HAS TO REENABLE FOR THIS
	RDAPR	T1
	ANDI	T1,77		;GET PI CHANELS
	WRAPR	APRCLK(T1)>
IFCPU (F3),<
	WRAPR	LP.ESF+LP.CSF+LP.CLK+APRCHN>
>;END IFCPU KI,F3

IFCPU (KL),<
	RDERA	SAVERA		;Log Error Address Register NOW before
				; anything else happens
	SBDIAG	SAVSB0		;Also SBUS function 0
	CONI	APR,SAVAPR	;And APR status just for good measure
	CONSZ	APR,APRPAR	;PARITY ERROR?
	JRST	APRPR1		;PARITY	ERROR, GO PROCESS
	CONSZ	APR,LP.CSD	;CACHE SWEEP DONE?
	JRST	APRCSH		;YES.
	CONSZ	APR,LP.SBE	;SBUS ERROR ON ALONE
	JRST	APRFAT		;YES, GO COMPLAIN.
	STOPCD			;SPURIOUS APR ERROR.

SAVERA:	0		;Save Error Address Register contents here
SAVSB0:	4B4+0		;SBUS function word - select controller
			; 4 (DMA20) plus function 0.
	0		;SBUS function 0 status stored here
SAVAPR:	0		;APR status at point of interrupt


ITMINT::0			;JSR HERE FROM EPT
	CONSZ	TIM,TI.TOV	;MAKE SURE NO OVERFLOW
	STOPCD
	MOVEM	T1,SAVT1
	AOSLE	T1,ITMPTR	;GET NEXT INTERVAL WORD
	SETCMB	T1,ITMPTR	;RESET FROM 1 TO -2
	CONO	TIM,@ITMTBL(T1)	;START IT AGAIN WITH PROPER INTERVAL
	MOVE	T1,ITMINT	;GET PC
	MOVEM	T1,APRCHL	;PUT IT INTO PROPER PLACE
>;END IFCPU KL

IFCPU (KS),<	;KS APRINT CODE
	CONSZ	APR,LP.HPE+LP.SPE	;TEST FOR HARD OR SOFT PARITY ERROR
	JRST	APRPR1			;GO PROCESS PARITY ERROR
APRP1R:	CONSO	APR,LP.80I		;8080 CONSOLE INTERRUPT?
	JRST	APRKST
	SKIPN	DZDO			;DZ-11 DRIVER?
	  JRST	APRI1A			;NO, CHECK FOR CTYSIM.
	SETOM	DZINF##
	JRST	APRI1B
APRI1A:	SKIPN	CTYDO			;SEE IF CTY IS ACTIVE AS CONSOLE
	JRST	APRIN1			;NO, JUST TURN OFF 8080 FLAG
	SETOM	CTYINF##		;FLAG 8080 INTERRUPT
APRI1B:	WRPI	LI.REQ+<1B35>_<7-6>	;REQUEST CHANNEL 6 INTERRUPT
	WRAPR	LP.CSF+LP.80I+APRCHN	;CLEAR 8080 FLAG
	JRST	APREXT			;JUMP TO JEN @APRCHL

APRIN1:	WRAPR	LP.CSF+LP.80I+APRCHN	;CLEAR 8080 FLAG
APRKST:	CONSO	APR,LP.ITD		;CHECK THE TIMER FLAG WENT OFF
	JRST	APREXT			; NOT TIMER, GO TO JEN @APRCHL
APRTIM:	MOVEM	T1,SAVT1		;GOT CLOCK
	AOSLE	T1,ITMPTR		;GET NEXT INTERVAL WORD
	SETCMB	T1,ITMPTR		;RESET WORD FROM 1 TO -2
	WRINT	ITMTBL(T1)
	WRAPR	LP.CSF+LP.ITD+APRCHN	;CLEAR INTERVAL TIMER DONE FLAG
>;END IFCPU (KS)

	EXTERN	CRSCNT			; TIME UNTIL HARD CRASH
	EXTERN	DWNFLG			; MEANS WE'VE TRIED TO SOFT BEFORE
CRSCHK::SKIPE	CRSHWD			; MUST BE CLOCK
IFCPU (KS),<
	  JRST [ MOVEI	T1,1		;KMC SENDS 1 TO CAUSE INSTANT CRASH
		 CAMN	T1,CRSHWD
		  JRST CRASHX
                 SOSL	CRSCNT
		 SKIPE	DWNFLG
		  JRST	CRASHX
		JRST 	.+1]
>;END IFCPU (KS)
IFNCPU (KS),<JRST	CRASHX>
	MOVE	T1,[633751506262]
KEYSET::MOVEM	T1,KEY620	;SET KEY FOR TYMNET
	JSP	T1,CH2RMT	;IF RMTSER, CALL ROUTINE TO SEE IF 620 UP
	AOS	TIME
	AOS	UPTIME
	SETOM	TIMEF
	SETOM	CLKFLG
	WRPI	REQCLK		;REQUEST A CH7 CLOCK INTERRUPT
	MOVE	T1,SAVT1
IFCPU (KS),<
APREXT:	TBSET	TBVAPR>		;RESET THE TIME BASE FOR CHARGING
	JEN	@APRCHL

SAVT1:	0


;2 WORDS TO SAVE THE TIME BASE VALUE
IFCPU (KS),<
TBVAPR:	BLOCK	2>
EXTERNAL CRSHWD,CRASHX,KEY620,TIME,UPTIME,TIMEF,CLKFLG
EXTERNAL REQCLK,CH2RMT,APRCHL
IFCPU (KI),<EXTERNAL APRCH2>

IFCPU (KL),<
ITMTBS:	TO.SIT+TO.CTD+^D1666	;LEAP TICK, TO AVG TO EXACTLY 16.66666 MS
	TO.SIT+TO.CTD+^D1667
ITMTBL:	TO.SIT+TO.CTD+^D1667
ITMPTR:	0			;TRIAD COUNTER (-2,-1,0)
>;END IFCPU (KL)

IFCPU (KS),<
ITMTBS:	<^D16>B23	;16 MILLISEC LEAP TICK TO AVERAGE 16.66666MS
	<^D17>B23	;17
ITMTBL:	<^D17>B23	;17
ITMPTR:	0		;TRIAD COUNTER (-2,-1,0)
>;END IFCPU (KS)
SUBTTL FATAL APR INTERRUPTS

APRFAT::				; make it global for FILDDT
IFCPU (KS),<STOPCD>
IFCPU (KI),<STOPCD>
IFCPU (KL),<
	CONSZ	APR,LP.NXM+LP.IOF+LP.PWF	;NORMAL TYPE FAILURE
	STOPCD			;YES, GET DUMPS OF THESE INSTEAD OF HALTING.
	MOVEI	P1,[ASCIZ/
FATAL PROCESSOR ERROR
/]
	JSP	T1,BUGTYP
	JSP	T3,APRMSG	;Type out APR, ERA and SBUS info
	HALT	.

;; This routine types out interesting hardware registers.
;; APR, ERA and SBUS info are saved at APRINT.  Called via
;; JSP T3,APRMSG.  Clobbers P1,P2,T1,T2, and 0.

APRMSG:
	MOVEI	P1,[ASCIZ/
APR STATUS (CONI) = /]
	JSP	T1,BUGTYP
	MOVE	P1,SAVAPR	;Retrieve saved CONI APR
	MOVSS	P1		;Set up LH for type-out
	JSP	T1,BUGTY6	;Type out RH of P1 in octal
	MOVEI	P2,","		;Seperator
	JSP	T2,BUGTY0	;Two commas between half-words
	JSP	T2,BUGTY0
	MOVSS	P1		;Get back original right half
	JSP	T1,BUGTY6	;And type it out
	MOVEI	P1,[ASCIZ/
ERA = /]
	JSP	T1,BUGTYP
	MOVE	P1,SAVERA	;Retrieve saved ERA contents
	MOVSS	P1
	JSP	T1,BUGTY6	;TYPE OUT LH
	MOVEI	P2,","		;TWO COMMAS BETWEEN 1/2 WDS, A LA DDT
	JSP	T2,BUGTY0
	JSP	T2,BUGTY0
	MOVSS	P1		;NOW RH
	JSP	T1,BUGTY6
	MOVEI	P1,[ASCIZ/
SBUS FN 0 = /]
	JSP	T1,BUGTYP
	HLRZ	P1,SAVSB0+1	;GET LH
	JSP	T1,BUGTY6
	MOVEI	P2,","		;A LA DDT HALFWORDS
	JSP	T2,BUGTY0
	JSP	T2,BUGTY0
	HRRZ	P1,SAVSB0+1	;GET RH
	JSP	T1,BUGTY6
	MOVEI	P1,[ASCIZ/
/]
	JSP	T1,BUGTYP
	JRST	(T3)		;Return to caller

;HERE ON CACHE SWEEP DONE.

APRCSH:	CONO	APR,LP.CSF+LP.CSD+APRCHN	;CLEAR SWEEP DONE.
	AOS	CSVCNT		;UNLOAD COUNTS AS VALIDATE TOO.
	MOVEM	T1,SAVT1	;TUCK THIS AWAY.
	MOVSI	T1,(SWPVA)	;GET VALIDATING INSTRUCTION BACK.
	EXCH	T1,CSVINS	;NOW CAN DO VALIDATE TO DO VALIDATE.
	TLNE	T1,(<SWPUA>-<SWPVA>);(ONLY DIFFER BY 1 BIT.)
	AOS	CSUCNT		;WAS AN UNLOAD, COUNT ONE MORE
	MOVE	T1,SAVT1	;GET T1 BACK
	JEN	@APRCHL		;DISMISS.

;ROUTINES FOR CACHE SWEEPING.

COMMENT #
THE PROCEDURE TO DO A CACHE SWEEP IS AS FOLLOWS: CALL THE APPROPRIATE
ROUTINE (CSHUNL, CSHVAL MACROS). THEY WILL RETURN THE CURRENT SWEEP
NUMBER FOR THE REQUESTED OPERATION IN T1. THE CALLING ROUTINE THEN
MAY DO SOME EXTRA PROCESSING. BEFORE STARTING THE IO THAT NEEDED THE SWEEP,
CALLER IS RESPONSIBLE FOR WAITING FOR HIS SWEEP TO COMPLETE
BY CAME T1,CS?CNT. WHEN THE NUMBERS NO LONGER MATCH, THE REQUESTED
SWEEP HAS FINISHED.
IN AN IO SYSTEM WHERE REQUESTS THAT NEED SWEEPS ARE QUEUED, THE CURRENT
SWEEP NUMBER AT THE TIME THE REQUEST ENTERS THE QUEUE CAN BE STORED
WITH THE REQUEST. WHEN THE REQUEST IS SERVICED, A SWEEP ONLY NEED
BE INITIATED IF THE CURRENT SWEEP COUNT AND THE ONE STORED WITH
THE REQUEST ARE THE SAME.
#

;CSHUNL MACRO PUSHJS HERE.

CSUNL::WRPI	LI.PIF	;MUST NOT ALLOW VALIDATE TO SNEAK IN
	SWPUA			;START THE UNLOAD.
;	WRAPR	LP.CSF+LP.CSD+APRCHN ;IN CASE A PREVIOUS SWEEP FINISHED AFTER LI.PIF
	MOVSI	T1,(SWPUA)	;ANYONE WHO DOES VALIDATE MUST REALLY DO AN UNLOAD NOW.
	MOVEM	T1,CSVINS
	MOVE	T1,CSUCNT	;RETURN WITH CURRENT SWEEP NUMBER
	WRPI	LI.PIN		;BACK ON
	POPJ	P,

;CSHVAL MACRO PUSHJS TO HERE

CSVAL::WRPI	LI.PIF	;TURN OFF PI SYSTEM, DON'T LET SWEEP DONE SNEAK IN
CSVINS:	SWPVA			;START OUT WITH VALIDATE ALL, CHANGE
				; TO UNLOAD ALL WHEN UNLOAD IS IN PROGRESS.
;	WRAPR	LP.CSF+LP.CSD+APRCHN ;IN CASE IT SET BEFORE INTERRUPT GOT A CHANCE TO GET IN
	MOVE	T1,CSVCNT	;PICKUP PROPER VALIDATE COUNT
	WRPI	LI.PIN		;TURN PI BACK ON
	POPJ	P,		;AND RETURN.

;LOCATIONS CONTAINING VALIDATE AND UNLOAD COUNTS. COUNTS ARE
; USED TO ALLOW ONE SWEEP TO SWEEP FOR MANY REQUESTS. WHEN
; ENTRY IS PUT ON QUEUE, AN ARBITRARY NUMBER OF THE LOW
; ORDER BITS OF THE SWEEP NUMBER IS STORED IN THE ENTRY.
; IF THE STORED SWEEP NUMBER BITS ARE DIFFERENT THAN
; THE CURRENT SWEEP NUMBER BITS AT THE TIME ACTUAL
; DMA I/O IS STARTED, THEN NO SWEEP IS NECESSARY.

CSUCNT::0			;NUMBER OF UNLOADS DONE
CSVCNT::0			;NUMBER OF VALIDATES DONE.
CSHSAV::0			;NUMBER OF SAVED SWEEPS.

>;END IFCPU (KL)

IFCPU (KS),<
;ROUTINE TO INVALIDATE THE ENTIRE CACHE FOR THE KS
;  SAVING ALL THE ACS.

INTERNAL CSINVL

CSINVL:: PUSH	P,T1	;SAVE T1
	RDUBR	T1	;GET THE CURRENT UBR
	WRUBR	T1	;WRITE UUSING CACHE TO BE INVALIDATED
	POP	P,T1	;RESTORE T1
	POPJ	P,	;RETURN
>;END IFCPU (KS)
;PARITY INTERRUPT
EXTERN PARFLG,UUOPNT,SYSDDT,UPSJOB
;DO MEMORY SCAN AND TYPE OUT BAD LOCS. THEN HALT.
;REPEAT MEMORY SCAN IF OPER PRESSES CONTINUE
;SCAN ALL OF MEMORY . IF GET NXM, GO TO NEXT 16K CHUNK.
;PARFLG IS -1 IF NO PAR ERRORS FOUND, ELSE IS = TO COUNT. USEFUL
;IF MEMORY GETS DUMPED BY MISTAKE; WE CAN FIND OUT WHAT HAPPENED

IFCPU (KS),<
	INTERNAL PARSPE
PARSPE:	0	;COUNT OF SOFT PARITY ERRORS
>; END IFCPU (KS)

	EXTERN EPT,EPT.PN,PARPC,PARTOT,PARWRD,PARSPR
	EXTERN GETCTY,JOB1,PGYADR,PHOLD,WSCHED,ERRPAR
APRPR1:
IFNCPU (KS),<MOVE T1,APRCHL>
IFCPU (KI),<WRPI	1B20>	;TURN OFF PARITY INTERRUPT
IFCPU (KL),<WRAPR LP.DSF+LP.PAR+LP.SBE+APRCHN>
IFCPU (F3),<WRAPR LP.DSF+LP.PAR+APRCHN>
IFCPU (KS),<
	CONSZ	APR,LP.SPE	;SKIP IF HARD ERROR
	JRST	[AOS	PARSPE	;ADD ONE TO THE COUNT OF SOFT PARITY ERRORS
		WRAPR	LP.CSF+LP.SPE+APRCHN	;CLEAR SOFT ERROR FLAG
		JRST	APRP1R]	;RETURN TO WHERE WE CAME FROM
	WRAPR	LP.DSF+LP.HPE+APRCHN	;DISABLE HARD PARITY ERRORS
	MOVE	T1,APRCHL
>;END IFCPU (KS)
	MOVEM T1,PARPC		;SAVE STATISTIC
	TLNE T1,PC.USR		;PARITY ERROR IN USER MODE?
	JEN @[PC.UIO,,USEPER]	;YES. PROCESS AT UUO LEVEL
EXCPAR:
APRPR2:	WRPI	LI.PIF	;TURN PI SYSTEM OFF
	WRAPR	CLRNXM
	CLPARF
	SETOM	PARFLG
	MOVEI	P1,PARMSG
	JSP	T1,BUGTYP	;REPORT ERROR TO CTY
IFCPU (KL),<JSP T3,APRMSG>	;Type APR, ERA, and SBUS info on CTY
APRER6:	MOVEI	P4,20		;START MEMORY SCAN AT LOC 20
	SETZ	T1,		;IF A PAR ERROR, T1 WILL GET CLOBBERED BY JSP
APRER1:	MOVE T2,P4		;GET ADDRESS
	LSH T2,-11		;PAGE NUMBER
	TRO T2,PGE.A!PGE.P	;SET ACCESS BITS
	DPB T2,EPYPSN	;SET UP UPS MAP SLOT TO PAGE [EPTPTR(%UPS.N)]
IFCPU (KI),<;MAYBE THIS IS NECESSARY IN CASE CURUPT NOT SETUP
	WRUBR	[420000+EPT.PN] ;PUT IT IN PAGING HARDWARE
>;END IFCPU (KI)
IFNCPU (KI),<CLRPTO	%UPS>
	SETZM UPSJOB		;JUST IN CASE WE EVER CALL MAPUPS
	MOVE T2,P4
	ANDI T2,777		;ISOLATE DISPLACEMENT IN PAGE
	MOVE P3,%UPS(T2)		;REFERENCE LOCATION 
	CONSZ	APR,APRNXM	;NXM?
	JRST	[TRNE P4,774	;IN FIRST 4 WORDS OF PAGE?
		 ADDI P4,37773	;NO. GO TO NEXT 16K
		 WRAPR	CLRNXM 
		 JRST APRER2]
	CONSZ	APR,APRPAR	;AN MPE IN THAT LOC?
	JRST	APRER3		;YES, REPORT IT
APRER2:	CAMGE	P4,[17777777]	;END OF MEMORY?
	AOJA	P4,APRER1	;NO, KEEP GOING
	MOVEI	P1,NONMSG
	CAIE	T1,
	MOVEI	P1,DONMSG
	JSP	T1,BUGTYP	;NO, SAY NONE FOUND
	HLRZ P1,SYSDDT
	CAIN P1,(HALT)
	HALT APRPR1		;SEE IF DDT STILL THERE (DEBUG)
	MOVEI P1,RSCMSG
	JSP T1,BUGTYP	;TYPE OUT RESCAN MESSAGE
APRPR4:
IFCPU (<KI,F3>),<
	CONSO TTY,TT.ID		;WAIT FOR INPUT CHR
	JRST .-1
	DATAI TTY,T1
>;END IFCPU (<KI,F3>)

IFCPU (KL),<
	SKIPN	EPT+SPCMTI	;INPUT CHAR YET
	JRST	.-1		;NO
	MOVE	T1,EPT+SPCF11	;YES, GET IT
	SETZM	EPT+SPCMTI	;AND CLEAR FLAG.
>;END IFCPU (KL)
IFCPU (KS),<
	SKIPN	T1,CTYIWD##	;INPUT CHAR YET
	JRST	.-1		;NO
	SETZM	CTYIWD##	;CLEAR IT
>;END IFCPU (KS)
	ANDI T1,177
	CAIN T1,"R"
	JRST APRER6	;RESCAN
	CAIN T1,"L"
	STOPCD
	JRST APRPR4	;CONTINUUE WAITING

;REPORT ERROR
APRER3:	CLPARF
	HLRZ P1,P4	;PRINT LEFT HALF OF ADDRESS
	JSP	T1,BUGTY6	;REPORT LOCATION
	HRRZ P1,P4	;NOW RIGHT HALF OF ADDRESS
	JSP T1,BUGTY6	
	MOVEI	P2," "
	JSP	T2,BUGTY0
	JSP	T2,BUGTY0
	HLRZ	P1,P3
	JSP	T1,BUGTY6	;TYPE OUT LEFT HALT OF CONTENTS
	MOVEI	P2,","
	JSP	T2,BUGTY0
	JSP	T2,BUGTY0
	HRRZ	P1,P3
	JSP	T1,BUGTY6	;THEN RIGHT HALF
	MOVEI	P1,[ASCIZ /
/]
	JSP	T1,BUGTYP
	JRST	APRER2
;;
;; Type out ASCIZ string on CTY. Called via
;; JSP T1,BUGTYP with address of string in P1.
;; Clobbers T2,P2,0. Preserves P1 and T1.
;; Functionally equivalent to CTYTYP in SCNSER except
;;  that BUGTYP has no internal PDL usage.

BUGTYP:
	MOVSI	0,440700!P1	;Generate byte pointer in AC 0
	ILDB	P2,0		;Pick up next character
	JUMPE	P2,0(T1)	;Exit if end of string
	JSP	T2,BUGTY0	;Type character in P2 on CTY
	JRST	BUGTYP+1	;Loop

;TYPE OUT 6 DIGIT OCTAL NUMBER IN P1 ON CTY
;JSP T1,BUGTY6
;CLOBBERS T2,P2,0
BUGTY6:	MOVE	0,[POINT 3,P1,17]
	ILDB	P2,0
	ADDI	P2,"0"
	JSP	T2,BUGTY0
	TLNE	0,770000
	JRST	BUGTY6+1
	JRST	(T1)

;TYPE OUT THE SINGLE CHARACTER IN P2 ON THE CTY
;JSP	T2,BUGTY0
BUGTY0:
IFCPU (<KI,F3>),<
	CONSZ	TTY,TT.OB
	JRST	.-1
	DATAO	TTY,P2
	JRST	(T2)
>;END IFCPU (<KI,F3>)

IFCPU (KL),<
	TRO	P2,.DTCTO	;COMMAND TO OUTPUT
	MOVEM	P2,EPT+SPCCMW
	SETZM	EPT+SPCMTD	;WAIT FOR DONE
	CONO	DTE,TO11DB	;HELLO 11
	SKIPN	EPT+SPCMTD	;DONE
	JRST	.-1		;NO
	ANDI	P2,377		;YES, CLEAR JUNK
	JRST	(T2)		;AND RETURN
>;END IFCPU (KL)

IFCPU (KS),<
	SKIPE	CTYOWD##	;MAKE SURE NOTHING IS THERE
	JRST	.-1
	TRO	P2,CTYOVL	;SET THE VALID CHARACTER FLAG
	MOVEM	P2,CTYOWD##	;STORE CHAR
	WRAPR	LP.SSF!LP.I8C+APRCHN	;WHAP THE 8080
	SKIPE	CTYOWD##	;WAIT TIL CHAR TAKEN
	JRST	.-1
	ANDI	P2,CTYICH	;GET RID OF JUNK
	JRST	(T2)		;AND RETURN
>;END IFCPU (KS)

RSCMSG:	ASCIZ /TYPE R TO RESCAN, L TO LOAD BOOTS
/

NONMSG:	ASCIZ /
NONE FOUND.
/
PARMSG:	ASCIZ /
EXEC PARITY ERROR
LOC           CONTENTS
/

DONMSG:	ASCIZ /
MEMORY SCAN COMPLETE.
/
;;
;; special STOP and WAIT routine to let individual patching of
;; WRUBR macro hack work to bring the system up and execute the
;; crash code without dying..
;;

WRHK0G:	Z			; non-zero means don't hack PI system
WRHK05:	Z
WRHK04:	Z
WRHK03:	Z
WRHK02:	Z
WRHK01:	Z

WRHK00:	Z			; JSR to here
	Exch	T1,WRHK01	; Don't
	Exch	T2,WRHK02	;  tamper
	Exch	P1,WRHK03	;  with
	Exch	P2,WRHK04	;  these
	Exch	0,WRHK05	;  acs.
	MOVEI	P1,[Asciz\
** UBR error -- Call Software support **
\]
	JSP	T1,BUGTYP	;REPORT ERROR TO CTY

	HRRZ	P1,WRHK00	; Get address
	JSP	T1,BUGTY6	; Print it
	MOVEI	P1,[Asciz\/   \]
	JSP	T1,BUGTYP
	HLRZ	P1,WRHK01	; Old T1 had arg to WRUBR
	JSP	T1,BUGTY6
	MOVEI	P1,[Asciz\,,\]
	JSP	T1,BUGTYP
	HRRZ	P1,WRHK01	; Get right half
	JSP	T1,BUGTY6

	MOVEI P1,[Asciz\

Type "C"ontinue, "R"eload, or "I"gnore: \]
	JSP T1,BUGTYP		; TYPE OUT RESCAN MESSAGE
WRHK0W:				; Come here to begin wait
IFCPU (<KI,F3>),<
	CONSO TTY,TT.ID		;WAIT FOR INPUT CHR
	JRST .-1
	DATAI TTY,T1
>;END IFCPU (<KI,F3>)

IFCPU (KL),<
	SKIPN	EPT+SPCMTI	;INPUT CHAR YET
	JRST	.-1		;NO
	MOVE	T1,EPT+SPCF11	;YES, GET IT
	SETZM	EPT+SPCMTI	;AND CLEAR FLAG.
>;END IFCPU (KL)
IFCPU (KS),<
	SKIPN	T1,CTYIWD##	;INPUT CHAR YET
	JRST	.-1		;NO
	SETZM	CTYIWD##	;CLEAR IT
>;END IFCPU (KS)
	ANDI T1,177
	CAIN T1,"C"		; "C"ontinue
	JRST WRHK0C
	CAIN T1,"R"
	JRST WRHK0R
	CAIN T1,"I"		; "I"gnore
	JRST WRHK0I
	JRST WRHK0W		;Wait for right character


WRHK0R:	STOPCD			; bye for now

WRHK0I: 

WRHK0C:	Exch	T1,WRHK01	; Don't
	Exch	T2,WRHK02	;  tamper
	Exch	P1,WRHK03	;  with
	Exch	P2,WRHK04	;  these
	Exch	0,WRHK05	;  acs.
	Jrstf	@WRHK00		; return & do WRUBR

SUBTTL USER PARITY ERROR

COMMENT ! USEPER
FUNCTION: SCAN ALL ACCESSIBLE MEMORY FOR THE RUNNING JOB;
FOR ALL PAGES WHICH HAVE 1 OR MORE SOFT PARITY ERRORS
DEACTIVATE ALL SLOTS FOR ALL JOBS SHARING THE PAGE;

IF PAGE CLEAN,JUST THROW IT OUT OF CORE. IF DIRTY,
ALSO PUT IT IN OUTPUT-ERROR HASH TABLE.

IF NO PARITY ERROR TURNS UP, PRETEND ALL DIRTY PAGES OF CURRENT
JOB HAVE A PARITY ERROR.

IF ANY PARITY ERROR IS HARD, PRINT MSG, TURN OFF PI'S, AND
GOTO EXEC PARITY ERROR CODE.

NOTICE: THIS CODE RUNS AT UUO LEVEL, HAVING BEEN ENTERED BY
 A JEN FROM APRINT.PI ENABLED.. PARITY INT. DISABLED.
 HOWEVER SINCE THIS CODE RUNS AT UUO LEVEL IN LONG LOOP SCANNING
 PAGES AND DEACTIVATING BAD ONES, SCHEDULER (AND PARTICULARLY,
 SCNSER) DO NOT RUN. AFTER WE KNOW THERE IS NO HARD UPE,
 EXPLICITLY CALL SCHEDULER TO LET SCNSER RUN ETC. ALSO
 MAY BLOCK DURING VCLEAR OF USER CORE. FINE.


ANY PARITY PROBLEMS WITH UPT CAUSE TRANSFER TO EXEC PARITY CODE.

REGISTER ASSIGNMENTS:
W/ VIRT. PG NO.		PG/ PHYS PG NO.		S/FLAGS
P1/USER VIRT. ADDR	P3,P4/LMAP SLOT DATA	J/JOB
F,U/ DDB & LDB FOR CTY OUTPUT
!


;FLAGS IS S, RH:
	FOUNDP==100000	;1 IF PARITY ERROR FOUND
	BADPAG==200000	;1 IF CURRENT PAGE ALREADY KNOWN BAD
	STOPUJ==400000	;1 IF MUST STOP USER JOB. (CURRENTLY
			;ALWAYS SET. ON KL10 MAYBE NOT).
	PG0UPE==40000	;1 IF USER VP 0 GOT HIT

SPERPT==4	;HOW MANY SOFT PARITY ERRORS TO REPORT


EXTERN CURUPT,DEALMS,REQUE,REMCHT,PGYDIO,PGYDRT,PGYUSE
EXTERN SCNLMC,LMPNER,%UPLMA,UPSJOB,ALR620

USEPER::MOVE T1,SAVT1		;GET USER'S T1 BACK (IN CASE KL)
	EXECAC			;GET TO EXEC MODE ACS
	CLPARF			;CLEAR NOW INCASE ANOTHER CH1 INT
IFCPU (KL),<JSP T3,APRMSG>	;Type APR, ERA, and SBUS info on CTY
	SKIPN J,JOB		;FOR DEALMS & FRIENDS
	STOPCD			;FROM NULJOB !
	MOVE P,[-EPLLEN,,%UPT+UPTPDL-1]	;INT CAME FROM USER MODE,
		;SO OK TO USE UPTPDL--NOTHING OF INTEREST THERE.
	PUSH P,PARPC	;IN CASE WE WANT TO RETURN TO USER
IFCPU (KS),<TBSET	TBVAPR>	;RESET THE TIME BASE FOR CHARGING
	NOCHARGE		;DON'T CHARGE USER FOR PARITY PROCESSING
	PUSHJ P,GETCTY	;SETUP F,U FOR SOFT UPE REPORTING
				;(ALSO CLEARS OUTPUT BUFFER)
	MOVEI S,STOPUJ		;FOUNDP_0
	MOVEI T1,SPERPT		;SOFT UPE REPORT COUNT
	MOVEM T1,SPECNT
	MOVEI P1,20		;SCAN FROM 20 TO 777777
	JRST UPEB1		;START SCAN OF PG 0 AT 20
UPE0:	;PROCESS NEXT USER VIRTUAL ADDR. PAGE BDRY TEST
	CAILE P1,777777		;DONE SCAN YET?
	JRST UPETF		;YES,TEST FOUNDP
	TRNE P1,777		;ABOUT TO LOOK AT NEW PAGE
	JRST UPE1		;NO

UPEB1:	;BEGIN NEW PAGE. SETUP W/VPG, PG/PHYS. IF PAGE NOT
	;ACCESSIBLE GOTO NEXT PAGE. MAKE SURE NO UPT MAP
	;SLOT PARITY TROUBLE. SET UP %UPS FOR READS

	TRZ S,BADPAG		;THIS PAGE NOT BAD YET
	HRRZ W,P1
	LSH W,-^D9		;W/VPG
	CLPARF
	CLRPTA			;FORCE PAGER TO READ UPT SO CATCH PAR ERRS IN UPT
	XCTBU <MAP PG,(P1)>	;PG_PHYS PG NO+BITS
	CONSZ APR,APRPAR	;PARITY FLAG FROM READING UPT?
	JRST UPEBA		;YES,TREAT LIKE EXEC PARITY
IFCPU (KI),<TRNE PG,MAP.M>		;ANY MATCH
IFNCPU (KI),<TLNE PG,PFW.H		;IF GET HARD ERROR, CRASH.
	STOPCD
	TLNN PG,PFW.A>		;SKIP IF CAN READ IT
	JRST [	IORI P1,777	;NO,SCAN ONLY PAGES WITH
		JRST UPENXA]	;PGE.A SET
IFNCPU (KI),<LSH PG,-^D9>		;KL GIVES FULL ADDRESS
	ANDI PG,17777		;PG/PHYS, NO BITS
	TRO PG,PGE.A!PGE.W
	DPB PG,EPYPSN		; [EPTPTR(%UPS.N)]
	SETZM UPSJOB		;TELL MAPUPS THAT %UPS IS CHANGED
	CLRPTO	%UPS
	TRZ PG,PGE.A!PGE.W

UPE1:	;READ USER ADDR THRU %UPS; IF PARITY COMES UP,
	;SEE IF SOFT OR HARD.
	CLPARF
	MOVE T2,P1	;T2/VIRT ADDR
	ANDI T2,777	;T2/OFFSET WITHIN PAGE
	MOVE T1,%UPS(T2)
	CONSO APR,APRPAR	;GOT PARITY?
	JRST UPENXA	;NOPE


;*********************
;BEGIN GOT PARITY
UPED:	;GOT PARITY ERROR THIS ADDR. P1/VIRT ADDR PG/PHYS PG
	;W/VPG  T1/BAD PARITY WORD CONTENTS
	MOVEM T1,PARWRD
	AOS PARTOT		;TOTAL PARITY COUNT
	TRO S,FOUNDP		;NOTE WE GOT ONE
	TRNN S,BADPAG		;GET ONE YET THIS PAGE?
	PUSHJ P,BPPAGE		;NO,FIRST ONE.
UPED2:	;SEE IF ERROR IS HARD OR SOFT. DO PATTERNS. PAGE IS
	;NO LONGER ACTIVE AND HAS BEEN THROWN OUT OF CORE,
	;SO THIS CORE PG IS ON A FREE LIST AND WE ARE DESTROYING
	;ITS DATA THRU %UPS, WHICH IS WRITEABLE.

	HRRZ P4,PG
	LSH P4,^D9	;MAKE P4/PHYSICAL ADDRESS
	MOVEI T2,777	;FOR PARITY PRINTER
	AND T2,P1
	IOR P4,T2	;T2/OFFSET IN PAGE
	MOVSI T1,-PARLEN
UPED2A:	CLPARF
	XCT PARSET(T1)	;WRITE ON THE WORD
	MOVE T3,%UPS(T2)	;SEE WHAT GOT THERE
	CAME T3,PARCMP(T1)	;THE RIGHT THING?
	JRST UPEHRD		;NO
	CONSO APR,APRPAR
	AOBJN T1,UPED2A		;NEXT TEST
	JUMPL T1,UPEHRD		;PARITY CAME UP IF T1<0
	PUSHJ P,PARSFT		;DEAL WITH SOFT PARITY REPORT
				;& GOTO NEXT ADDRESS. FALL THRU
	;END UPED..GOT PARITY ERR THIS VIRT ADDR

;END GOT PARITY
;*********************


UPENXA:	;END UPE0 LOOP. NEXT VIRT ADDR
	AOJA P1,UPE0

UPETF:	;HERE WHEN ENTIRE USER SPACE SCANNED. TEST
	;FOUNDP--HOPEFULLY WE GOT A PARITY ERROR SOMEWHERE. IF
	;NOT, EITHER IT'S SPURIOUS, OR (WHAT IS MORE
	;LIKELY) IT'S A READ-MODIFY-WRITE PARITY ERROR. WE
	;CAN'T TELL WHERE IT WAS, SO HAVE TO ASSUME ALL
	;HIS ACCESSIBLE DIRTY PAGES ARE BAD. YUCK!

	TRNE S,FOUNDP	;FIND AT LEAST ONE?
	JRST UPEG	;YEA!

	MOVEI P1,777	;EXAMINE 777,1777,2777,..FOR ACCESSIBLE
			;DIRTY PAGES.
	AOS PARSPR	;COUNT "SPURIOUS" UPE INTERRUPTS
	MOVEI T1,ALRCTY	;ALERT OPERS TO EXISTENCE
	IORM T1,ALR620	;OF MSG
	PUSHJ P,INLMES
	ASCIZ/
"SPURIOUS" USER PARITY ERROR INTERRUPT/
UPEH:	MOVE W,P1
	LSH W,-^D9	;W/VPG
	CAILE W,777
	JRST UPEG	;DONE PAGES 0-777
	XCTBU <MAP PG,(P1)> ;PG/BITS+PHYS
IFCPU (KI),<TRNE PG,MAP.M>	;ANY MATCH
IFNCPU (KI),<TLNE PG,PFW.H		;IF HARD ERROR, CRASH
	STOPCD
	TLNN PG,PFW.A>		;IF KL, MAKE SURE A BIT IS ON.
	JRST UPEH1	;NO
IFNCPU (KI),<LSH PG,-^D9>		;KL GIVES FULL ADDRESS INSTEAD OF PAGE NUMBER.
	ANDI PG,17777	;CLEAR BITS
	LDB T1,PGYDRT	;CLEAN PAGES CANNOT HAVE HAD
	JUMPE T1,UPEH1	;READ-MODIFY-WRITE PARITY ERROR
	PUSHJ P,BPPAGE	;EXPECTS J,PG,W
UPEH1:	ADDI P1,1000	;NEXT PAGE
	JRST UPEH

;*****************************
;	FINISHED USER PARITY PROCESSING

UPEG:
	POP P,T1	;USER PC
	CLPARF
	WRPI	LI.PIN
IFCPU (KI),<WRPI	1B21>	;ENABLE PARITY INTERRUPT
IFCPU (KL),<WRAPR LP.ESF+LP.PAR+LP.SBE+APRCHN>
IFCPU (F3),<WRAPR LP.ESF+LP.PAR+APRCHN>
IFCPU (KS),<WRAPR	LP.ESF+LP.HPE+APRCHN>
	TRNN S,STOPUJ	;CAN WE LET HIM RUN?
	JRSTF (T1)	;YES..THE FOOL!
	PUSHJ P,WSCHED	;LET SCHEDULER RUN..FINALLY
	MOVSI T1,LMPNER	;IF PG 0 GOT HIT,
	TRNE S,PG0UPE	;NEED TO PREVENT EXEC MPE'S ON
	IORM T1,%UPLMA+0;RESET REF'S TO JOBDAT (WE'RE GOING TO
			;THROW PG AWAY RIGHT AWAY ANYWAY).
	PUSHJ P,JOB1	;RESET,ZAP MEMORY
	PJRST	ERRPAR	;PRINT PARITY ERROR AND STOP JOB

;**************************************


UPEBA:	;GOT PARITY TESTING USER MAP SLOT. W/VPG
	WRPI	LI.PIF
	MOVEI P1,[ASCIZ/
UPT PAGE PARITY ERROR LOC /]
	JSP T1,BUGTYP
	HLRZ T1,CURUPT
	ANDI T1,17777
	LSH T1,^D9
	LSH W,-1	;VPG/2 = SLOT LOCN
	IOR W,T1	;W/PHYSICAL LOCN OF MAP SLOT
	HLRZ P1,W	;PRINT HI ORDER
	JSP T1,BUGTY6
	HRRZ P1,W
	JSP T1,BUGTY6
	JRST EXCPAR	;AND GO TREAT LIKE EXEC PARITY

UPEHRD:	;A PATTERN FAILED OR PARITY FLAG CAME UP ON PATTERNS
	;P4/PHYS LOCN OF WORD
	;T3/BAD CONTENTS READ
	;T1/PATTERN TABLE INDEX
	;PARWRD/ORIGINAL BAD CONTENTS OF WORD BEFORE TESTS
;PRINT DROPPED BIT	(OR OTHER APPROPRIATE MSG)
;	HARD UPE <LOCN> = <BAD PATTERN> = <ORIGINAL BAD DATA>
	MOVE P1,PARPRT(T1)
	JSP T1,BUGTYP
	MOVSI J,-2
	MOVEI P1,HRDUPE
	JSP T1,BUGTYP
	HLRZ P1,P4	;ADDRESS UPPER
	JSP T1,BUGTY6
	HRRZ P1,P4
	JSP T1,BUGTY6
UPEHR2:	MOVEI P1,[ASCIZ / = /]
	JSP T1,BUGTYP
	HLRZ P1,T3
	JSP T1,BUGTY6
	HRRZ P1,T3
	JSP T1,BUGTY6
	MOVE T4,PARWRD
	AOBJN J,UPEHR2
	JRST EXCPAR		;GO TO EXEC PARITY CODE

PARPRT:	EXP [ASCIZ/
BIT DROPPED/],[ASCIZ/
PICKED BIT/], [ASCIZ/
PICKED PARITY/]

PARSET:	SETOM %UPS(T2)
	AOS %UPS(T2)
	AOS %UPS(T2)
PARLEN==.-PARSET



PARCMP: EXP -1,0,1	;THIS DATA TO MATCH AFTER XCT PARSET(T1)

HRDUPE: ASCIZ/
HARD USER PARITY ERROR /

SPECNT:	BLOCK 1		;COUNTS HOW MANY SOFT UPE'S TO REPORT
PARSFT:	;SOFT ERROR. INTERRUPTS STILL ENABLED.
	;EXPECTS: P4/PHYS LOCN OF BAD WORD, PARWRD/ ITS CONTENTS
	;SPECNT/ HOW MANY OF THESE TO REPORT
	;F/CTY DDB   U/SCN LDB
	SOSGE SPECNT
	POPJ P,
	PUSHJ P,INLMES
	ASCIZ /
USER PARITY ERROR AT /
	HLRZ T1,P4
	PUSHJ P,OCTPNT
	HRRZ T1,P4
	PUSHJ P,OCTPNT
	PUSHJ P,INLMES
	ASCIZ / = /
	HLRZ T1,PARWRD
	PUSHJ P,OCTPNT
	HRRZ T1,PARWRD
	PJRST OCTPNT
COMMENT ! ROUTINE BPPAGE --  FIRST BAD PARITY FOR PAGE
FUNCTION: DEACTIVATE ALL SLOTS ON LMA CHAIN FOR THIS
 PHYSICAL PAGE; IF IT'S DIRTY, ENTER IT IN OHT. THROW IT
 OUT OF CORE HASH TABLE. MAKE SPECIAL NOTE OF UPE ON PG 0
EXPECTS: W/VPG PG/PHYS J/JOB
DESTROYS: M,T1-T4,P3,P4
PRESERVES: %UPS SET UP ON ENTRY TO PHYS WITH PGE.W FOR PATTERNS
	SETS THIS UP AGAIN ON EXIT. DEALMS AND FRIENDS 
	DESTROY IT.
!

EXTERN OHTTAB,INSOHT,OHTPAR,DSKPIF,DSKPIN,PGYSOP

DEFINE DSKON <WRPI DSKPIN>
DEFINE DSKOFF <WRPI DSKPIF>

BPPAGE:	PUSH P,P1		;NEED A P AC HERE
	PUSH P,F
	PUSH P,U		;THESE NEEDED FOR INLMES
	TRO S,BADPAG		;NOTE PAGE NOW KNOWN BAD
	CAIN W,0
	TRO S,PG0UPE		;NOTE VP 0 GOT HIT
	LDB T1,PGYDIO		;WAIT UNTIL ALL DIO STOPS. INTERRUPTS
	JUMPN T1,.-1		;ARE RUNNING.
	LDB T1,EPYPSN		; [EPTPTR(%UPS.N)]
	PUSH P,T1		;SAVE PATTERN SLOT
	PUSH P,J
	PUSH P,W
	PUSH P,PG		;SAVE THESE FROM SCNLMC
	LDB P1,PGYADR	;SAVE DSK PAGE FOR LATER INSOHT
	PUSH P,P1
	LDB P1,PGYDRT	;FOR LATER TEST IF NEED INSOHT OR NOT
	CLPARF
	JSP F,SCNLMC	;BEGIN SCAN LMA CHAIN. SKIP RTN SUCCESS
	JRST BPPG2	;NO MORE ON CHAIN
			;SKIP: P3,P4/SLOT,J/JOB,W/VP  OF NEXT SLOT
	PUSHJ P,DEALMS	;GETS PG/PHYS FOR THIS W/VP. DEACTIVATE SLOT
			;(SHOULD BE SAME AS PG ON ENTRY)
BPPG1:	JRST (M)	;COROUTINE RETURN TO SCNLMC,STORE SLOT &
			;CONTINUE SCAN OF LMA CHAIN
BPPG2:	POP P,T2	;GET T2/DSK PAGE ADDR
	JUMPE P1,BPPG3	;IF PAGE CLEAN, SKIP THIS
	DSKOFF
	PUSHJ P,INSOHT	;PUT IN OHT, GET T4/INDEX
	MOVSI T1,OHTPAR	;MARK WHAT KIND OF ERROR
	IORM T1,OHTTAB(T4)
	DSKON
BPPG3:
	POP P,PG
	POP P,W
	POP P,J
	CONSZ APR,APRPAR	;DID WE GET PARITY DURING LMA CHAIN SCAN?
	JRST EXCPAR	;YES,SIGH
	LDB T1,PGYUSE	;BY NOW IT SHOULD BE OK TO THROW THIS PG
	SKIPE T1	;OUT OF CHT.
	STOPCD
	POP P,T1	;%UPS SLOT FOR PATTERNS..NOT AN LMAP
	DPB T1,EPYPSN	; [EPTPTR(%UPS.N)]
	SETZM UPSJOB	;MAKE SURE MAPUPS KNOWS NOT VALID
	CLRPTO	%UPS
	POP P,U
	POP P,F
	POP P,P1	;THE ACS WE USED
	LDB T1,PGYSOP	;CAN'T BE SWAP IN, CHECK SWAP OUT
	JUMPN T1,CPOPJ	;IF ITS SOP AND FREE, WAIT FOR NEXT USER TO
			; REFERENCE IT AND HOPE ITS NOT ON ITS WAY OUT AGAIN.
	PJRST REMCHT	;NO I/O, THROW PG OUT OF CHT SO DOESN'T HAPEN AGAIN,
			; & RETURN NO SKIP
SUBTTL START/STOP CALLI MONITOR HISTOGRAM SNOOP FACILITY

EXTERN JBTLIC,THSDAT,JBTNAM,HFDBUF,SINTBS,SINTB
IFCPU (KI),<EXTERN TM2CHL,TM2CHN>

COMMENT ! DATABASE
BESIDES THE DATA KEPT HERE, THERE IS A BUFFER OF HISTOGRAM
DATA, AND MODIFIED INSTRUCTIONS IN THE SNOOP INTERRUPT
CODE, AND LINKAGES TO INTERRUPT HARDWARE !

;  SAMPLING-INTERVAL CODE TRANSLATION
%ZZ==0
LHFITTB==0
DEFINE TSIC(CODE,COUNT,LEAP)<
%ZZ==^D'CODE
IFG %ZZ-LHFITTB,<LHFITTB==%ZZ>
XWD [^D'COUNT,,^D'LEAP],^D'CODE  >

IFNCPU (KS),<
SICTB:	TSIC(8,208,211)	;8 PER TICK, 2.08MS COUNT, 2.11 MS LEAP COUNT
	TSIC(16,104,107) ;16/TICK,15 COUNTS @ 1.04MS, 1 @ 1.07MS
	TSIC(32,52,55)
	TSIC(64,26,29)
LSICTB==.-SICTB
>;END IFNCPU (KS)

IFCPU (KS),<
SICTB:	TSIC(8,2,3)	;8 PER TICK, 2MS COUNT, 3MS LEAP TICK
	TSIC(16,1,2)	;16 PER TICK
LSICTB==.-SICTB	;LENGTH OF SICTB TABLE
>;END IFCPU (KS)

HFUSNP==1		;ADDR SPACE TO HIST MASK

HFPIMK:	;LH OF WORD PI MASK.  1B0 FOR UUO LEVEL
HFSTS: BLOCK 1	;RH=STATE CODE
HFLOW: BLOCK 1  
HFHI: BLOCK 1  
HFSFC: BLOCK 1  	; SAMPLING-FREQUENCY CODE
HFCSPN: BLOCK 1  	; CUSP NAME
HFUPTM: BLOCK 1  	;UPTIME WHEN SAMPLING BEGAN: DAYS64,,JIFFIES
HFDSIZ: BLOCK 1  	;SIZE OF CURRENT HISTOGRAM IN HFDBUF
SNITPT: BLOCK 1  	;CIRCULATING POINTER (INDEX INTO) HFITTB
SNITMX: BLOCK 1  	;MAX VALUE FOR SNITPT
HFITTB: BLOCK LHFITTB 	;TIMER INTERVAL TABLE
SAVT12: BLOCK 2		;FOR SNOOPI SAVING T1,T2
  IFCPU (<KL>),<
SNSJSR: BLOCK 1		;SAVE NORMAL INTERVAL-TIMER JSR INSTR
SNOOJB:	BLOCK 1		;SNNMI TO SNOOPI FLAG&COMMUNICATION CELL
>
IFCPU (KS),<
SNSJSR:	BLOCK	1	;SAVE INSTRUCTION FOR INTERVAL TIMER PROCESSING
SNOOJB:	BLOCK	1	;SNNMI TO SNOOPI FLAG & COMMUNICATION CELL
>
HFPITB: BLOCK 10	;ENABLE/DISABLE COUNTING AT PI LEVEL N
			;COUNT IF HFPITB[N] .NE. 0 (FASTER THAN JFFO
			;AND BIT OPERATIONS AT INTERRUPT LEVEL.)
HFMODE:	BLOCK 1		;FLAG WHICH ADDR SPACE (USER/MONITOR) IN HIST

;CONTIGUOUS BLOCK OF COUNTERS
HFCNTB==.
TOTCNT: BLOCK 1  	;TOTAL SNOOP INTERRUPTS FIELDED
HISTOT: BLOCK 1  	;TOTAL COUNTS IN HISTOGRAM
USRCNT: BLOCK 1  	;TOTAL COUNTS IN USER PROGRAMS
OORCNT: BLOCK 1  	;TOTAL COUNTS OUT-OF-RANGE IN MONITOR
NULCNT: BLOCK 1  	;TOTAL COUNTS IN NULJOB
SYSCNT: BLOCK 1  	;TOTAL COUNTS IN MONITOR-MODE
PICNT: BLOCK 10	;COUNTS AT EACH PI LEVEL. PICNT[0] FOR UUO LEVEL
HFCTGL==.-HFCNTB

COMMENT ! COUNTER HIERARCHY: (WHEN SAMPLING MONITOR ADDRESSES)

TOTCNT =  USRCNT  +  SYSCNT  +  NULCNT

SYSCNT =   SUM ( PICNT[I] I=0 TO 7 )  IE, UUO LEVEL+ALL PI'S

SYSCNT = HISTOT + OORCNT

HISTOT = SUM ( HISTOGRAM[I] ALL I )

!
;COMMON ERROR RETURNS.  EXPECT: M/ XXX,,USER AC NUMBER

DEFINE ERRCOD(N,SYM,LABEL)<
 XP SYM,N
IFGE <7-N>,<LABEL==ERR0'N>
IFL <7-N>,<LABEL==ERR'N>
>

ERR00:	JSP T1,ECOD	;(0)
ERR01:	JSP T1,ECOD
ERR02:	JSP T1,ECOD
ERR03:	JSP T1,ECOD
ERR04:	JSP T1,ECOD
ERR05:	JSP T1,ECOD
ERR06:	JSP T1,ECOD
ERR07:	JSP T1,ECOD
;ADD MORE HERE IF NEEDED FOR OTHER UUOS
ECOD:	SUBI T1,ERR00+1
	XCTTU <HRRZM T1,(M)>	;RETURN TO USER
	POPJ P,
COMMENT ! SNOOP CALLI
USER CALL:	MOVE AC,[FUNCTION,,ADDR]
		CALLI AC,-116
		 ERROR, AC/CODE
		SUCCESS, AC UNCHANGED
ERROR CODES !
	;IF CALLI NOT IMPLEMENTED OR NO SNOOP BUFFER ALLOCATED
	;AT ONCE-TIME, ERROR RETURN AC/UNCHANGED
	ERRCOD(1,SNPNL%,SNOONL)	;NO LICENSE (TAKES RC & WC)
	ERRCOD(2,SNPBF%,SNOOBF)	;BAD FUNCTION CODE
	ERRCOD(3,SNPAR%,SNOOAR)	;ALREADY RUNNING, TRIED TO START
	ERRCOD(4,SNPBL%,SNOOBL)	;BAD LSH (RESOLUTION)
	ERRCOD(5,SNPBR%,SNOOBR)	;BAD RANGE LOW TO HIGH
	ERRCOD(6,SNPBI%,SNOOBI)	;BAD INTERVAL CODE
	ERRCOD(7,SNPBJ%,SNOOBJ)	;BAD JOB NO.

;SNOOP UUO FUNCTION CODES=HISTOGRAM FACILITY STATE CODES,
;PLUS SNOOP UUO DISPATCH.

SNDSP:
	PHASE 0
HFFMIN:!
HFZAPD:! JRST SNZAP ;ZAPPED: NO HISTO EXISTS, HARDWARE STOPPED
HFSTOP:!	JRST SNSTOP;STOPPED: HDW STOPPED, HISTO EXISTS
HFFMAX:!
HFRUN:!	JRST SNGO	;RUNNING: HDW RUNNING, HISTO EXISTS
	DEPHASE

COMMENT !	ARG BLOCK DEFN

ADDR:	BYTE (17)PI LEVELS INCLUDED (1)ADDR SPACE: 0=SYS 1=USER (18)0
+1	LOW ADDRESS
+2	HIGH ADDRESS
+3	RESOLUTION AS A LSH COUNT, 0.LE.COUNT.LE.^D18
+4	<JOB> OR 0,,<INTERVAL CODE>
+5	CUSP NAME OR 0

!
	ARGPI==0
	ARGLOW==1
	ARGHI==2
	ARGRES==3
	ARGJOB==4
	ARGSIC==4
	ARGCSP==5

;*************************
;ENTER T1/ FUNCTION,,ADDR	J/JOB

SNOOPU::
	SKIPN HFDBUF	;ANY SNOOP BUFFER EXIST?
	POPJ P,		;NO, FRETURN AC UNCHANGED
	IFCPU (KI),<
	CONO CLK2,CLKSTP+TM2CHN
	CONI CLK2,T2
	JUMPE T2,CPOPJ	;DOESNT EXIST,GIVE AC UNCHANGED FRETURN
	>; END IFCPU (KI)
	MOVE T2,JBTLIC(J)
	TLC T2,LICWCR!LICSPY
	TLCE T2,LICWCR!LICSPY
	 JRST SNOONL
	HLRZ T2,T1	;T2/FUNC CODE
	CAIG T2,HFFMAX
	CAIGE T2,HFFMIN
	JRST SNOOBF
	XCT SNDSP(T2)



SNZAP:	HRRZ T1,HFSTS
	SETZM HFUPTM	;NO MORE BEGINNING TIME
	SETZM HFDSIZ	;OR DATA
	CAIN T1,HFRUN	;IF RUNNING,
	PUSHJ P,SNNMI	;NO MORE INTERRUPTS
	MOVEI T1,HFZAPD
	HRRM T1,HFSTS
	JRST CPOPJ1

;STOP SAMPLING. LEAVE DATA INTACT FOR LATER READING

SNSTOP:
	HRRZ T1,HFSTS
	CAIN T1,HFZAPD	;IF ZAPPED ALREADY,
	JRST CPOPJ1	;DO NOTHING, BUT SKIP RTN
	CAIN T1,HFRUN	;IF RUNNING
	PUSHJ P,SNNMI	;NO MORE INTERRUPTS
	MOVEI T1,HFSTOP
	HRRM T1,HFSTS
	JRST CPOPJ1

; START A RUN. T1/FUNC,,ADDR
;CLEAR EVERYTHING OUT. GET ARGS & CHECK, SET UP TIMING TABLES,
;MODIFY INTERRUPT-CODE INSTRUCTIONS, HOOK UP TO INTERRUPT SERVICE,
;& LET NEXT INTERRUPT START SAMPLING.

SNGO:
	HRRZ T2,HFSTS
	CAIN T2,HFRUN
	 JRST SNOOAR	;ALREADY RUNNING, KEEP FROM MISTAKENLY WIPING OUT
	HRRZ T2,HFDBUF		;BEG ADDR SNOOP BUFF
	HLRZ T3,HFDBUF		;SIZE
	ADDI T3,-1(T2)		;T3/LAST WRD OF BUFF
	HRLS T2			;T2/BEG,,BEG
	ADDI T2,1		;T2/BEG,,BEG+1
	SETZM -1(T2)
	BLT T2,(T3)		;ZERO ENTIRE SNOOP BUFFER
	MOVE T2,[HFCNTB,,HFCNTB+1]
	SETZM HFCNTB
	BLT T2,HFCNTB+HFCTGL-1	;CONTIG BLK OF COUNTERS CLEAR
	MOVE T2,[SINTB,,SINTB+1] ;SWPPER PERFORMANCE HISTO SCHED1
	SETZM SINTB	;CLEAR TO REFLECT CURRENT
	BLT T2,SINTB+SINTBS-1		;PERFORMANCE & LOAD

	UMOVE T2,ARGPI(T1)	;PI & UUO LEVEL INCLUDE MASK
	HLLM T2,HFPIMK	;SAVE INCASE ANYBODY INQUIRES LATER
	HLRZ T3,T2
	TRZ T3,-1-HFUSNP	;ISOLATE PC MODE BIT
	MOVEM T3,HFMODE	;SAVE MODE
	MOVSI T3,-10
SNGO1:	SKIPL T2		;THIS BIT ON?
	TDZA T4,T4		;NO,LEVEL FLAG_0
	MOVEI T4,1		;YES,LEVEL FLAG_1
	MOVEM T4,HFPITB(T3)
	LSH T2,1
	AOBJN T3,SNGO1

	UHRRZ T2,ARGLOW(T1)
	UHRRZ T3,ARGHI(T1)
	CAMG T3,T2
	 JRST SNOOBR		;ADDRESS RANGE BAD
	MOVEM T3,HFHI
	MOVEM T2,HFLOW
	SUB T3,T2		;T3/HIGH-LOW

	UMOVE T4,ARGRES(T1)	;LSH CTR, 0 TO 18.
	JUMPL T4,SNOOBL
	CAILE T4,^D18
	JRST SNOOBL
	MOVNS T4
	ASH T3,(T4)		;(HIGH-LOW)/2**RESOLUTION =
				;NO. BUCKETS IN PROPOSED HISTOGRAM
	HLRZ T2,HFDBUF		;SIZE SNOOP BUFF=MAX NO. BUCKETS
	CAMLE T3,T2
	 JRST SNOOBR		;HIST WOULD BE LARGER THAN BUFFER
	MOVEM T3,HFDSIZ
;************************************************
	HRRM T4,HFLSHC		;MODIFY INTERRUPT LSH INSTR
;************************************************
	UHLRZ T2,ARGJOB(T1)
	CAILE T2,JOBN-1		;LEGIT NUMBER?
	JRST SNOOBJ		;NO,LET HIM KNOW
	SKIPN T2		;DOES HE WANT TO SELECT BY JOB?
	SKIPA T2,[JRST HFCSPT]	;NO,JRST WILL DISABLE TEST
	HRLI T2,(CAIE T1,)	;YES,CAIE T1,<JOBNO> ENABLES
;************************
	MOVEM T2,HFJOB		;MODIFY INT CODE
;************************

	UMOVE T2,ARGCSP(T1)
	MOVEM T2,HFCSPN		;CUSP-NAME TO SELECT
	SKIPN T2		;DO WE WANT TO SELECT BY CUSP?
	SKIPA T2,[JRST HFHIST]	;NO,JRST DISABLES
	MOVE T2,[MOVE T1,JBTNAM(T1)]  ;YES,MOVE ENABLES
;********************************
	MOVEM T2,HFCSPT		;MODIFY INT CODE
;*************************************

	HRRZ T2,HFDBUF		;BUFFER BEG ADDR
;***********************************
	HRRM T2,HFGHT		;MODIFY INT CODE; GOOD HIST COUNT INSTR
;*****************************************

	UHRRZ T1,ARGSIC(T1)	;SAMPLING-INTERVAL CODE
	MOVSI T3,-LSICTB
SNGO2:	HRRZ T2,SICTB(T3)	;COMPARE PROFFERED CODE AGAINST ITEMS
	CAME T1,T2		;IN SIC TABLE. MUST MATCH ONE
	AOBJN T3,SNGO2
	JUMPGE T3,SNOOBI	;IF AOBJN RAN OUT, DIDNT MATCH ANY
	HLRZ T3,SICTB(T3)	;T3 POINTS AT XWD COUNT,LEAP-COUNT
	MOVE T3,(T3)
	MOVEM T1,HFSFC
	MOVEM T1,SNITMX		;CIRCULATING POINTER RESET VALUE
	MOVEM T1,SNITPT		;CIRC POINTER

	MOVE T4,[HFITTB+1,,HFITTB+2]	;CLEAR TIMER TABLE
	SETZM HFITTB+1
	BLT T4,HFITTB+LHFITTB-1
  IFCPU (KI),<
	HRRZM T3,HFITTB+0	;LEAP-TICK COUNT ALONE IN TABLE
	>
  IFCPU (<KL>),<
	IOR T3,[TO.SIT+TO.CTD,,TO.SIT+TO.CTD] ;TIMER CONTROL BITS
	HRRZM T3,HFITTB+0	;LEAP-TICK COUNT 1ST IN TABLE
	MOVE T1,SNITMX		;FROM SNITMX-1 TO 1 FILL TABLE WITH
	SUBI T1,1
SNGO3:	HLRZM T3,HFITTB(T1)	;0,,NORMAL COUNT+BITS
	SOJG T1,SNGO3		;QUIT AFTER STORING HFITTB+1
	> ;END IFCPU (<KL,F3>)

IFCPU (KS),<
	HRRZM	T3,HFITTB+0	;LEAP TICK COUNT 1ST IN TABLE
	MOVE	T1,SNITMX	;FROM SNITMX-1 TO 1 FILL TABLE
	SUBI	T1,1		;WITH
SNGO3:	HLRZM	T3,HFITTB(T1)	;0,,NORMAL COUNT
	SOJG	T1,SNGO3
>;END IFCPU (KS)
;NOW HOOK UP TO INTERRUPT SOURCE & RETURN CHEERING

	PUSHJ P,SNSTI	;SNOOP,START INTERRUPTS
	MOVE T1,TIME
	IDIV T1,JFYSEC
	HRL T1,THSDAT
	MOVEM T1,HFUPTM	;<DAYS64>,,SECONDS SINCE MIDNITE
	MOVEI T1,HFRUN
	HRRM T1,HFSTS
	JRST CPOPJ1

COMMENT ! SNSTI
FUNCTION: START SNOOP INTERRUPTS.  FOR KL10, POINT THE
	INTERVAL-TIMER AT SNOOPI.  FOR KI10, PUT SNOOPI IN
	THE TM2CHL CHAIN, AT HEAD. TM2CHL IS ASSUMED TO BE
	CHANNEL 1 BY SNOOP CODE.
CLOBBERS: T1
!

IFCPU (<KL>),<
SNSTI:	MOVE T1,[JSR SNOOPI]
	EXCH T1,EPT+EPTITI
	MOVEM T1,SNSJSR
	POPJ P,
>

IFCPU (KS),<
SNSTI:	MOVE	T1,[JRST SNOOPI]
	EXCH	T1,APRTIM	;SPLICE SNOOPI INTO APRINT CODE
	MOVEM	T1,SNSJSR	;SAVE ORIGINAL INS. (TO BE RESTORED
	POPJ	P,		;WHEN SNOOPI UNSPLICED)
>;END IFCPU (KS)

IFCPU (KI),<
SNSTI:	MOVE T1,[JRST SNOOPI]
	WRPI	LI.PIF
	EXCH T1,TM2CHL+1
	MOVEM T1,SNOOPI+1	;THE JRST BEHIND THE CONSO/CONSZ
	WRPI	LI.PIN
	DATAO CLK2,HFITTB+0	;THE INTERVAL
	CONO CLK2,CLKON+CLKCDN+CLKCOV+CLKCUT+TM2CHN
	POPJ P,      >
IFCPU (F3),<SNSTI:	POPJ	P,>

COMMENT ! SNNMI -- SNOOP, NO MORE INTERRUPTS
FUNCTION:
	KL10:
	KS10: SET SNOOJB FLAG FOR SNOOPI INTERRUPT CODE TO
	STOP; SLEEP FOR 1 SECOND (MORE THAN ENUF TIME FOR
	THE CURRENT "TICK" TO COMPLETE) THEN RETURN. SNOOPI
	WILL REPLACE THE JSR TO ITSELF WITH THE ORIGINAL
	INTERVAL-TIMER INTERRUPT INSTRUCTION.

	KI10:  TAKE SNOOPI OFF TM2CHL CHAIN.
!

IFCPU (KI),<

SNNMI:	WRPI	LI.PIF
	CONO CLK2,CLKSTP+CLKCLR
	MOVE T1,SNOOPI+1	;JRST BEHIND THE CONSO/CONSZ
	MOVEM T1,TM2CHL+1
	WRPI	LI.PIN
	POPJ P,  >

IFCPU (<KL>),<
PRINTX TEST SNOOP ON FOONLY

SNNMI:	SKIPN	SNSJSR	;EVER SAVED A JSR?
	POPJ	P,	;NO, NOTHING TO DO
	HRROM	J,SNOOJB;FLAG SNOOPI TO STOP AT END OF "TICK"
	MOVEI	T1,1	;A SHORT NAP
	CALLI	T1,+31	;SLEEP T1,
	POPJ	P,	;IN 1 SEC SNOOPI WILL SURELY HAVE STOPPED

>;END IFCPU (KL)

IFCPU (KS),<

SNNMI:	SKIPN	SNSJSR	;EVER SAVED A JSR?
	POPJ	P,	;NO, NOTHING TO DO
	HRROM	J,SNOOJB;FLAG SNOOPI TO STOP AT END OF "TICK"
	MOVEI	T1,1	;A SHORT NAP
	CALLI	T1,+31	;SLEEP T1,
	POPJ	P,	;IN 1 SEC SNOOPI WILL SURELY HAVE STOPPED

>;END IFCPU (KS)
IFCPU (F3),<SNNMI:	POPJ	P,>
SUBTTL SNOOP FACILITY INTERRUPT CODE

IFCPU (<KL>), <

COMMENT ! 
THIS INTERRUPT ROUTINE GETS RUN INSTEAD OF ITMINT. THE JSR
IN THE EPT GETS ROUTED DIRECTLY HERE.  DEPENDING ON SNOOP
INTERVAL, THIS ROUTINE IS ENTERED 8,16,32 OR 64
TIMES PER "TICK"; EVERY 8TH (16TH,32ND OR 64TH) SNOOP INTERRUPT
DOES THE ITMINT CHORES AND ADJUSTS FOR "LEAP TICKS".

USES AND RESTORES: T1,T2
!

SNOOPI::  0	;JSR DIRECTLY HERE FROM EPT
	CONSZ TIM,TI.TOV
	STOPCD			;HUMBUG! OVERFLOW.
	DMOVEM T1,SAVT12
	SOSLE T1,SNITPT		;PTR CIRCULATES "BACKWARDS"
	JRST SNOOP1		;NO WRAPAROUND YET
	MOVE T1,SNITMX		;MAX VALUE
	MOVEM T1,SNITPT		;READY FOR SOSLE NEXT TIME

;CHORES FROM ITMINT
SNCRCK:	XCT CRSCHK	;MAY NOT BE SKIPE 30 IF STAND-ALONE
	JRST [SOSL CRSCNT
	       SKIPE DWNFLG
	        JRST CRASHX
               JRST .+1]
	MOVE T1,[633751506262]
SNKYST:	XCT KEYSET	;MAY NOT BE MOVEM IF STAND-ALONE
	JSP T1,CH2RMT
	AOS TIME
	AOS UPTIME
	SETOM TIMEF
	SETOM CLKFLG
	WRPI	REQCLK
	SKIPGE SNOOJB		;.LT.0 IF SNOOPI SHOULD STOP ITSELF
	 JRST	[MOVE T1,SNSJSR	;ORIGINAL JSR
		MOVEM T1,EPT+EPTITI ;SNOOPI NO LONGER RUNS
		HRRZS SNOOJB	;LH/0 RESETS FLAG RH/JOB FOR DEBUG
		AOSLE T1,ITMPTR	;ITMINT CHORE..FIGURE OUT LENGTH OF
		SETCMB T1,ITMPTR;NEXT "SUBTICK"
		CONO TIM,@ITMTBL(T1); SET INTERVAL TIMER
		JRST SNOOX]	;RESTORE T1,T2 & EXIT
;NOW LEAP-TICK CHECK
	AOSLE T1,ITMPTR		;TRIAD -2,-1,0 COUNTER
	JRST [	SETCMB T1,ITMPTR
		MOVE T1,HFITTB+0
		CONO TIM,-1(T1);LEAP TICK SMALLER BY 1 COUNT
		JRST SNOOP2]
	MOVEI T1,0
;NORMAL SUBTICK ALREADY SET UP IN HFITTB
SNOOP1:	CONO TIM,@HFITTB(T1)	;EFFECTIVE ADDR SETS UP TIMER
SNOOP2:	MOVE T1,SNOOPI
	MOVEM T1,APRCHL		;KEEP OTHER PEOPLE HAPPY
> ; END IFCPU (KL), FALL THRU TO SNOOP CODE PROPER


IFCPU (KS),<

COMMENT !
THIS INTERRUPT CODE GETS "SPLICED INTO" APR TIMER PROCESSING BY SNSTI.
COME HERE FROM APRTIM AND EXIT BACK TO APREXT.
DEPENDING ON THE SNOOP INTERVAL SNOOPI RUNS 8 OR 16 TIMES PER 
"TICK"; EVERY 8TH (16TH) SNOOP INTERRUPT DOES THE TIMER CHORES AND
ADJUSTS FOR "LEAP TICKS".

USES AND RESTORES: T1,T2
!
SNOOPI:: DMOVEM T1,SAVT12
	SOSLE T1,SNITPT		;PTR CIRCULATES "BACKWARDS"
	JRST SNOOP1		;NO WRAPAROUND YET
	MOVE T1,SNITMX		;MAX VALUE
	MOVEM T1,SNITPT		;READY FOR SOSLE NEXT TIME

;CHORES FROM APR TIMER CODE
SNCRCK:	XCT CRSCHK	;MAY NOT BE SKIPE 30 IF STAND-ALONE
	JRST CRASHX
	MOVE T1,[633751506262]
SNKYST:	XCT KEYSET	;MAY NOT BE MOVEM IF STAND-ALONE
	JSP T1,CH2RMT
	AOS TIME
	AOS UPTIME
	SETOM TIMEF
	SETOM CLKFLG
	WRPI	REQCLK
	SKIPGE SNOOJB		;.LT.0 IF SNOOPI SHOULD STOP ITSELF
	 JRST	[MOVE T1,SNSJSR	;ORIGINAL JSR
		MOVEM T1,APRTIM  ;SNOOPI NO LONGER RUNS
		HRRZS SNOOJB	;LH/0 RESETS FLAG RH/JOB FOR DEBUG
		AOSLE T1,ITMPTR	;ITMINT CHORE..FIGURE OUT LENGTH OF
		SETCMB T1,ITMPTR;NEXT "SUBTICK"
		WRINT ITMTBL(T1)
		WRAPR LP.CSF+LP.ITD+APRCHN ;clr timer done flag
		JRST SNOOX]	;RESTORE T1,T2 & EXIT
;NOW LEAP-TICK CHECK
	AOSLE T1,ITMPTR		;TRIAD -2,-1,0 COUNTER
	JRST [	SETCMB T1,ITMPTR
		MOVE T1,HFITTB+0
		SUBI	T1,1	;LEAP TICK SMALLER BY 1 COUNT
		JRST SNOOP2]
	MOVEI T1,0
;NORMAL SUBTICK ALREADY SET UP IN HFITTB
SNOOP1:	MOVE	T1,HFITTB(T1)	;EFFECTIVE ADDR SETS UP TIMER
SNOOP2:	LSH	T1,^D12		;POSITION INTERVAL FOR TIMER
	WRINT	T1
	WRAPR	LP.CSF+LP.ITD+APRCHN	;CLEAR THE TIMER DONE FLAG
	MOVE T1,APRCHL		;FOR SNOOP CODE PROPER SEE BELOW
>; END IFCPU (KS)
IFCPU (KI),<

COMMENT !
SECOND DK10 (CLK2) GETS PUT ON HEAD OF CHANNEL 1 CHAIN. DEPENDING
ON SNOOP INTERVAL, THIS ROUTINE GETS RUN 8,16,32 OR 64 TIMES FOR
EACH INTERRUPT GENERATED BY THE APR LINE-FREQUENCY CLOCK .
ACTUALLY, IT IS NOT EXACTLY 8,16 ETC.  WHEN THIS DK10 IS FIRED UP,
ITS INTERVAL IS SET TO 23.,54.,ETC.; WITHOUT "LEAP" COUNTS, THESE
INTERVALS CAUSE CLK2 TO GET "BEHIND" THE LINE-FREQUENCY
CLOCK, WHICH DOESNT MATTER FOR SAMPLING PURPOSES.
(ALL TIMING IS TAKEN CARE OF BY LINE-FREQUENCY INTERRUPTS
AND THE FIRST DK10, BOTH ALSO ON THIS CHANNEL AT THE MOMENT).

THIS DK10 IS RUN WITH "USER TIME" OFF--ALL MONITOR-MODE TIME
INCLUDING INTERRUPT-SERVICE TIME IS COUNTED.

USES AND RESTORES: T1,T2
!

SNOOPI::
	CONSO CLK2,CLKCDN+CLKCOV
	<JRST .-.>		;INTERRUPT CHAIN, MODIFIED INSTR
	DMOVEM T1,SAVT12
SNOOP1:
SNOOP2:	MOVE T1,TM2CHL		;GET PC OF INTERRUPT & FALL THRU
				;TO SNOOP CODE PROPER
> ; END IFCPU (KI)
;SNOOP CODE PROPER	T1/PC OF INTERRUPT

	AOS TOTCNT	
	TLNE T1,PC.USR
	 JRST [ SKIPN T1,JOB
		AOSA NULCNT
		AOS USRCNT
		SKIPN HFMODE	;HIST USER PC?
		JRST SNOOX	;NO
		JRST HFJOB]	;YES
	AOS SYSCNT
	RDPI	T1	;GET ACTIVE PI CHANNELS
	ANDI T1,037400	;IGNORE TM2CHL
	JFFO T1,.+2	;T2_20+HIGHEST ACTIVE PI #, OR 0
	MOVEI T2,^D20	;NONE ACTIVE
	AOS PICNT-^D20(T2)
	SKIPN HFPITB-^D20(T2)	;DO WE INCLUDE COUNTS AT THIS LEVEL?
	 JRST SNOOX		;NO
	SKIPE HFMODE	;HIST SYS PC?
	JRST SNOOX	;NO
	MOVE T1,JOB
HFJOB:	<CAIE T1,.-.>	;RH_JOB # OF INTEREST, OR INSTRUCTION_SKIPA
	JRST SNOOX	;WRONG JOB,NOT INTERESTED
HFCSPT:	<MOVE T1,JBTNAM(T1)>	;OR JRST HFHIST IF NO CUSP TEST
	CAME T1,HFCSPN
	 JRST SNOOX	;WRONG PROGRAM RUNNING, NOT INTERESTED
HFHIST:
  IFCPU (<KL>),< HRRZ T1,SNOOPI>
  IFCPU (KI),< HRRZ T1,TM2CHL>
IFCPU (KS),< HRRZ	T1,APRCHL>
	CAMG T1,HFHI	;IN-RANGE CHECK
	CAMGE T1,HFLOW	;BOTH ARE MONITOR ADDRESSES
	JRST HFOOR	;OUTA RANGE
	SUB T1,HFLOW	;KONVERT TO HISTOGRAM BUFF INDEX
HFLSHC:	<LSH T1,.-.>	;RH_NEG LSH COUNT, OR INSTR_JFCL
			;THIS INSTR IMPLEMENTS ADDRESS RESOLUTION DOWN
			;TO 2^0 = 1-WORD INCREMENTS
	AOS HISTOT	;COUNTERPART OF OORCNT
HFGHT:	<AOSA .-.(T1)>	;GOOD HISTOG COUNT. INSTR MODIFIED TO
			;PT AT BEG OF SNOOP BUFF ALLOCATED AT ONCE-TIME
			;NO BOUNDS-CHECKING AT INT LEVEL--DONE
			;WHEN HFHI,HFLOW,HFLSHC SET UP AT UUO LEVEL
HFOOR:	AOS OORCNT	;OUT-OF-RANGE (IN MONITOR) COUNT

; SNOOP INTERRUPT EXIT

SNOOX:	DMOVE T1,SAVT12
	IFCPU (<KL>), <JEN @SNOOPI>
	IFCPU (KI), <CONO CLK2,CLKCDN+CLKCOV+CLKON+CLKCUT+TM2CHN
		JEN @TM2CHL >
	IFCPU (KS),<JRST APREXT>	;JRST TO JEN @APRCHL
SUBTTL READ-HISTOGRAM CALLI  MONITOR-HISTOGRAM SNOOP FACILITY

COMMENT ! RDHIST
FUNCTION: RETURN HISTOGRAM COUNTERS AND STATE INFO TO RC-LICENSED
	USER, SUSPENDING SAMPLING WHILE DOING SO.
USER CALL:	MOVE AC,[-COUNT,,ADDR]
		CALLI AC,-117
		 ERROR, AC/CODE
		SUCCESS AC UNCHANGED, ADDR WRITTEN ON FOR COUNT WDS
ERROR AC: UNCHANGED-- UUO NOT IMPLEMENTED OR HARDWARE NOT PRESENT
	AC/1  MISSING RC LICENSE
	AC/2  ZAPPED STATE-- NO HIST TO READ
	AC/3  <ROOM>,,3  --COUNT WAS TOO SMALL TO RETURN ALL DATA,
			<ROOM> IS SIZE NEEDED. SOME DATA RETURNED,
			UP TO LIMIT IMPOSED BY COUNT.

ADDR: PI-INCLUDED MASK,,<SNOOP FACILITY STATE CODE>
+1	LOW MONITOR ADDR
+2	HIGH MONITOR ADDR
+3	RESOLUTION (AS A LSH COUNT .LE. 0)
+4	<JOB OR 0>,,<DATAVERSION><INTERVAL> <INTERVAL>=10,20,40 OR 100
			;<DATAVERSION>=INDEX OF HISTOGRAM[0] IN
			;RETURNED DATA BLOCK..TO KEEP SNOOPY IN
			;SYNCH W/MONITOR.
+5	<CUSP> OR 0	;<CUSP>=SIXBIT NAME BEING SELECTED
+6	UPTIME 		;WHEN SAMPLING BEGAN
+7	TOTCNT
+10	HISTOT
+11	USRCNT
+12	OORCNT		;OUT-OF-RANGE COUNT
+13	NULCNT  	;NULJOB COUNTS
+14	SYSCNT
+15	PICNT[0]	;COUNTS TAKEN FROM UUO LEVEL
+16	PICNT[1]=0	;PI LEVEL 1 IGNORED (SAMPLING LEVEL)
+17	PICNT[2]	;LEVEL 2 COUNTS
.
.
+24	PICNT[7]	;LEVEL 7 COUNTS
+25	SINTB[0]	;SWAPPER PERFORMANCE HISTO,CELL 0
.
.
+36	SINTB[9]	;(CURRENT)END SWAPPER HISTO
+37	HISTOGRAM[0]	;COUNTS IN 0TH CELL OF HISTOGRAM
.
. AS MUCH MORE AS COUNT ALLOWS


CALL:	JRST HERE FROM UUOCON DISPATCH
EXPECTS: T1/ -COUNT,,ADDR
	M/ USER AC#
	J/JOB
!

DATVER==37	;KEEP UPDATING THIS AS INTERESTING ITEMS ARE ADDED
		;TO "PROLOGUE" DATA BLOCK BEFORE REAL HISTOGRAM DATA
		;BEGINS. THIS SHOULD EQUAL INDEX OF HISTOG[0]


	ERRCOD(1,RDHNL%,RHNLIC)	;NO LICENSE (RC)
	ERRCOD(2,RDHZP%,RHZAPD)	;ZAPPED, NONE TO READ
	ERRCOD(3,RDHNR%,ZZ)	;INSUFFICIENT ROOM (SPECIAL HANDLING)


RDHIST::
	SKIPN HFDBUF	;ANY SNOOP BUFFER EXIST?
	POPJ P,		;NO, FRETURN AC UNCHANGED
	IFCPU (KI),<
	CONO CLK2,CLKSTP+TM2CHN
	CONI CLK2,T2
	JUMPE T2,CPOPJ	;DOESNT EXIST,GIVE AC UNCHANGED FRETURN
	>; END IFCPU (KI)
	MOVSI T2,LICSPY
	TDNN T2,JBTLIC(J)
	JRST RHNLIC
	HRRZ T2,HFSTS
	CAIN T2,HFZAPD
	JRST RHZAPD
	CAIE T2,HFRUN
	JRST RDHS2	;ALREADY STOPPED, NO NEED TO STOP IT WHILE
			;SAMPLING
	PUSH P,T1	;T1/-COUNT,,ADDR
	PUSHJ P,SNNMI	;NO MORE INTERRUPTS
	POP P,T1
RDHS2:	;RETURN A FEW ITEMS FROM SCATTERED LOCATIONS
	;HRRZ T2,HFSTS
	;HLL T2,HFPIMK
	MOVE T2,HFSTS
	AOBJP T1,RHNORM
	UMOVEM T2,-1(T1)
	MOVE T2,HFLOW
	AOBJP T1,RHNORM
	UMOVEM T2,-1(T1)
	MOVE T2,HFHI
	AOBJP T1,RHNORM
	UMOVEM T2,-1(T1)
	HRRE T2,HFLSHC	;LSH COUNT .LE. 0
	AOBJP T1,RHNORM
	UMOVEM T2,-1(T1)
	MOVE T2,HFJOB
	CAMN T2,[JRST HFCSPT]
	TDZA T2,T2	;NOT TESTING A JOB, RETURN 0
	HRLZS T2	;T2/<JOB NO.>,,0
	HRR T2,HFSFC	;SAMPLING-FREQUENCY-CODE
	MOVEI T3,DATVER_^D9
	IOR T2,T3	;T2/<JOB>,,<DATVER><HFSFC>
	AOBJP T1,RHNORM
	UMOVEM T2,-1(T1)
	MOVE T2,HFCSPN
	AOBJP T1,RHNORM
	UMOVEM T2,-1(T1)
	MOVE T2,HFUPTM
	AOBJP T1,RHNORM
	UMOVEM T2,-1(T1)
RDHS3:	;RETURN A BUNCH OF ITEMS FROM CONTIGUOUS BLOCK
	;T1/AOBJN LEFT TO GO
	MOVE T3,[-HFCTGL,,HFCNTB]
RDHS3A:	MOVE T2,(T3)
	AOBJP T1,RHNORM
	UMOVEM T2,-1(T1)
	AOBJN T3,RDHS3A
	;NOW RETURN THE LITTLE SWAPPER PERFORMANCE HISTOGRAM
	;OF PERCENT OF JOBS' MWS'S SWAPPED
	MOVE T3,[-SINTBS,,SINTB]
RDHS3B:	MOVE T2,(T3)
	AOBJP T1,RHNORM
	UMOVEM T2,-1(T1)
	AOBJN T3,RDHS3B
RDHS4:	;TRY TO RETURN HISTO DATA. T1/AOBJN LEFT TO GO
	movei t3,-1(t1)
	ADD T3,HFDSIZ	;T3/END OF DATA IN USER SPACE
	HLRE T2,T1
	MOVNS T2
	CAMGE T2,HFDSIZ
	JRST RHNORM	;AGAIN, NOT ENUF ROOM
	HRL T1,HFDBUF	;T1/BEG-OF-BUF,,USER ADDR
	XCTTU <BLT T1,(T3)>	;GEEV EET TO HEEM
	HRRZ T2,HFSTS
	AOS (P)		;SUCCESS SKIP RTN
	CAIN T2,HFRUN	;DO WE NEED TO RESTART SAMPLING?
	PJRST SNSTI	;YUP
	POPJ P,

RHNORM:	;NOT ENOUGH SPACE. SET UP LH OF USER AC WITH <ROOM> NEEDED
	HRRZ T1,HFDSIZ
	ADDI T1,HFCTGL+7
	HRLZS  T1
	HRRI T1,RDHNR%	;NO ROOM CODE
	UMOVEM T1,(M)
	HRRZ T2,HFSTS
	CAIN T2,HFRUN	;NEED TO RESTART IT?
	PJRST SNSTI	;YUP
	POPJ P,

SUBTTL USER PSEUDO-INTERRUPT ROUTINES

;TEST TO SEE IF THE CHANEL IN T1 CAN TAKE A TRAP NOW. SKIP IF SO.

TSTTRJ:	LDB J,PJOBN	;F SET UP BUT NOT J
TSTTRP::JUMPE T1,CPOPJ	;NO CHANNEL
	MOVE T1,TRPBTS(T1)	;GET THE BIT CONVERSION
	SKIPGE JBTENB(J)	;ARE TRAPS ENABLED?
	CAMG T1,JBTPIP(J)	;AND NO HIGHER IN PROGRESS?
	POPJ P,			;NO TO ONE OF THOSE, NO TRAP
	TDNE T1,JBTENB(J)	;IS THIS CHANNEL ENABLED?
	AOS (P)		;YES, SKIP
	POPJ P,		;NO

;  TEST IF TRAP IS ARMED.  T1=CHANNEL NUMBER

TSTARM:	JUMPE T1,CPOPJ
	MOVE T1,TRPBTS(T1)
	TDNE T1,JBTENB(J)
	AOS (P)
	POPJ P,

INTERNAL TSTARM
TRPBTS:	0		;NO CHANNEL 0
	SALL
XXQ==1B1
	REPEAT ^D35,<XXQ
		XXQ==XXQ_-1>
	XALL
	1B0		;FOR HIBERNATE REQUESTS

;SET THE TRAP WAITING BIT. IF THIS CAUSES A HIGHER CHANNEL AND
;EVERYTING IS ENABLED, SET JBTAWQ BIT 0. IF JOB IS SLEEPING
;OR IN TTY IOW AND WE NOW WANT TO TRAP, GET JOB STARTED

TAKTRJ:	LDB J,PJOBN
TAKTRP:	JUMPE T1,CPOPJ
	SKIPGE T1,TRPBTS(T1)	;^D36 (SLEEP) IS ONLY NEGATIVE
	JRST HIBWAK	;WAITING FOR HIBERNATE, WAKE UP
TAKTR2:	SKIPGE JBTENB(J)	;INTERRUPTS ENABLED?
	CAMG T1,JBTPIP(J)	;AND HIGHER THAN NOW HAPPENING?
	JRST TAKTR1		;NO
	TDNE T1,JBTENB(J)	;THIS ONE ENABLED?
	TLO T1,(1B0)		;YES, SET WAITING FOR REQUEST
TAKTR1:	IORB T1,JBTAWQ(J)
	JUMPGE T1,CPOPJ		;WANT A TRAP NOW?
TAKTR3:	LDB T1,PJBSTS		;YES, FIND OUT STATUS
	CAIN T1,SLPQ
	JRST HIBWK1		;SLEEPING
	CAIN T1,TIOWQ		;TTYIOW?
	JRST TTYWAK		;YES, GET IT OUT
	CAIN	T1,ILWQ		;CLUB INTERLOCK WAIT?
	JRST	HIBWK2		;YES.  GO "WAKE UP".
	POPJ P,			;NEITHER, LET IT GO FOR NOW

;TEST A TRAP TO SEE IF WE CAN TAKE IT NOW. IF SO DO, IF NOT
;SKIP RETURN

TSTKTJ:	LDB J,PJOBN
TSTKTP:	PUSHJ P,TSTTRP
	 JRST CPOPJ1		;CAN NOT TAKE IT NOW
	JRST TAKTR2		;GO, BITS ALREADY IN T1
;TAKE A TRAP IF WE CAN. MAY BE OLD STYLE. JUST IN CASE, T2 HAS
;REASON BITS

TAKOTJ:	LDB J,PJOBN
TAKOTP:	JUMPE T1,CPOPJ
TAKOT1:	SKIPGE T1,TRPBTS(T1)
	JRST HIBWAK	;SLEEPING
	SKIPL JBTPIP(J)	;OLD STYLE?
	JRST TAKTR2	;NO, GO DO IT
	MOVSI T1,(1B1)
	TDNE T1,JBTPIP(J)	;ALREADY IN A TRAP?
	JRST TAKOT2	;YES, JUST SAVE BITS
	IORM T1,JBTPIP(J)	;NO, SET TRAP
	TLO T2,(1B0)
TAKOT2:	IORB T2,JBTAWQ(J)	;SAVE REASON AND REQUEST TRAP
	JUMPL T2,TAKTR3		;DO WE WANT TO TRAP NOW?
	POPJ P,			;NO

;IF TRAP IS REALLY SET (NON-0) ALWAYS SKIP RETURN

TAKNZJ:	LDB J,PJOBN
	JUMPE T1,CPOPJ
	AOS (P)
	JRST TAKOT1	;MAY BE OLD

HIBWAK:	LDB T1,PJBSTS
	CAIE T1,SLPQ	;IS HE SLEEPING?
	JRST TTSCLR	;NO, CLEAR SLEEP FLAGS
HIBWK1:	PUSHJ P,TTSCLR
HIBWK2:	MOVEI T2,RNQ
	DPB T2,PJBSTS
	JRST SETR2		;START UP JOB

INTERNAL TAKNZJ,TAKOTJ,TSTKTJ,TAKTRJ,TSTTRJ,TAKTRP,TSTKTP
EXTERNAL SETR2,TTSCLR,JBTAWQ,JBTPIP,JBTENB
EXTERNAL CPOPJ,CPOPJ1,PJBSTS,PJOBN,RNQ,SLPQ,TIOWQ,TTYWAK,ILWQ

;LIKE TSTKTR BUT MAY BE AN OLD STYLE TRAP

TSTKOT:	SKIPL JBTPIP(J)		;TEST AND TAKE POSSIBLE OLD TRAP
	JRST TSTKTP		;NEW TYPE
	JUMPE T1,CPOPJ1	;NOT ENABLED
	MOVSI T1,(1B1)
	TDNE T1,JBTPIP(J)	;ALREADY IN A TRAP?
	JRST CPOPJ1		;YES, SKIP RETURN
	TLO T2,(1B0)
	IORM T2,JBTAWQ(J)	;SET WANT A TRAP FLAG
	POPJ P,			;AND RETURN
;ROUTINE TO CHECK FOR WAITING TRAPS AND TAKE THEM. CALLED
;AT END OF A UUO AND AT CLOCK LEVEL
;CALLED WITH OLD PC IN T3

CLKTRP:	JUMPE	J,CPOPJ			;NEVER FOR JOB 0
	TLNE	T3,PC.USR		;DO NOT INTERRUPT OUT OF UUO
	SKIPL	T1,JBTAWQ(J)		;IS THERE AN INTERRUPT WAITING?
	POPJ	P,			;KEEP OLD PC THE SAME
	SKIPGE	JBTPIP(J)
	JRST	CLKTRO			;OLD APRENB SYSTEM
	AND	T1,JBTENB(J)		;USE ONLY CHANNELS ENABLED
	TLZ	T1,(1B0)
	JFFO	T1,.+2			;SEE WHICH INTERRUPT IS WAITING
	JRST	CLKNTP			;NO TRAP THERE REALLY, TURN OFF AWQ
	MOVE	T1,TRPBTS(T2)		;GET READY TO SET BITS
	CAMG	T1,JBTPIP(J)		;IGNORE IF NOT HIGHER
	JRST	CLKNTP			;THAN HIGHEST IN PROG
CLKTR1::IORM	T1,JBTPIP(J)		;SET IN PROGRESS
	TLO	T1,(1B0)		;ALSO RESET AWAIT REQUEST BIT
	ANDCAM	T1,JBTAWQ(J)		;AND CLEAR WAITING
	HLRZ	T1,%UPT+UPTENB		;GET INTERRUPT ADDRESS
	LSH	T2,1
	ADDI	T1,-2(T2)		;FIND CORRECT LOCATION
CLKPC1::XCTTU	<MOVEM T3,(T1)>		;SAVE OLD PC
CLKPC2::XCTFU	<HRR T3,1(T1)>		;GET NEW PC
	TLZ	T3,PC.FPD!PC.ADR	;USE SAME FLAGS, EXCEPT TURN OFF
					; FLAGS THAT WILL BE TURNED OFF
					; IF INSTRUCTION AT PC HAD COMPLETED
					; (SO 2 PART INSTRUCTIONS WORK RIGHT IN INTERRUPT ROUTINE)
	POPJ	P,			;FINISHED

INTERNAL CLKTRP
EXTERNAL JOBAPR,JOBCNI,JOBTPC,JOBMUU

CLKTRO:	TLZ	T1,600000		;REMAINDER IN JOBCNI BITS
	XCTBU	<MOVEM T1,JOBCNI>
	XCTBU	<MOVEM T3,JOBTPC>	;SAVE OLD PC
	MOVE	T1,%UPT+UPTENB
	TRNN	T1,ENBUUO
	JRST	CLKTO1			;NOT ENABLED FOR UUO
	HLR	T3,%UPT+UPTENB		;TAKE NEW ADDRESS AS SET
	TRNN	T3,-1			;UNLESS 0
CLKTO1:	XCTBU	<HRR T3,JOBAPR>
	TRNE	T1,ENBRPT		;REPEAT ENABLED?
	TRZA	T1,ENBUUO!ENBCLK	;YES, JUST REMOVE CLOCK AND UUO
	MOVEI	T1,0			;NO, REMOVE EVERYTHING
	JRST	APRDIS			;GO DISABLE TRAPS (ALMOST LIKE APRENB)
;ROUTINES TO DO THE OLD APRENB (AND SETPOV) UUO'S

EXTERNAL USRMPT

SETPOV:	XCTBU	<MOVEM T1,JOBAPR>	;SET THE TRAP LOC
	MOVEI	T1,ENBPDL		;AND SET TO ENABLE PDL OV
				;FALL INTO APRENB

APRENB:	TDZA	T2,T2
APRDIS:	MOVSI	T2,(1B1)		;DO APRENB AND SET IN TRAP FLAG
	TLO	T2,(1B0)		;SET BIT TO INDICATE OLD SYSTEM
	MOVEM	T2,JBTPIP(J)
	SETZM	JBTENB(J)
	SETZM	JBTAWQ(J)
	MOVE	T2,[%UPT+UPTTCB,,%UPT+UPTTCB+1]
					;CLEAR INTERRUPT CELLS IN UPT
	SETZM	-1(T2)
	BLT	T2,%UPT+UPTTCE		;TPN, TP1, U?I, X?I
	SETZM	JBTINT(J)		;CLEAR INTERRUPT CELLS IN JOB TABLES
	MOVEM	T1,%UPT+UPTENB
	PUSHJ	P,TTTCLR		;CLEAR ALL TTY TRAPS
	MOVSI	T2,(JFCL)
	TRNE	T1,ENBOV+ENBFOV		;SET OVERFLOW INSTRUCTION
	MOVEI	T2,USROVT		;TO IGNORE OR TRAP
	MOVEM	T2,%UPT+UPTOVT		;SO WE DO NOT NEED TO CALL SETAPR
	MOVEI	T2,USRMPE
	TRNE	T1,ENBMPT		;MEM-PROT VIOLATION TO TRAP OR ERR
	MOVEI	T2,USRMPT
	MOVEM	T2,%UPT+UPTPGT
	MOVEI	T2,ERRPOV		;NOW PDLOV
	TRNE	T1,ENBPDL
	MOVEI	T2,USRPDT
	MOVEM	T2,%UPT+UPTPOV
	MOVEI	T2,UUOPNT		;AND UUO
	TRNE	T1,ENBUUO
	MOVEI	T2,UUOPTT
	HRRM	T2,%UPT+UPTPNT
	MOVEI	T2,1
	TRNE	T1,ENBHMS!ENBHNG
	DPB	T2,JBYHNG		;SET HUNG DEVICE TRAP NUMBER
	MOVSI	T2,-TTYRPT		;NUMBER OF TTY TRAPS TO SET
	HRRZS	T1
	HRRZ	F,TTYTAB(J)
	PUSH	P,T3			;CLKTRP CALLS THIS, PRESERVE T3
TTYENB:	TDNN	T1,TTYTRB(T2)		;WANT THIS ONE?
	JRST	TTYEN2			;NO
	PUSH	P,T2			;SAVE ARGUMENT POINTER
	MOVEI	T3,1			;CHANNEL NUMBER
	HLRZ	T2,TTYTRB(T2)		;INTERRUPT NUMBER
	PUSHJ	P,TINAS1		;CALL THE SETUP ROUTINE
	  JRST	TTYEN1			;NOT WAITING FOR TRAP
	MOVEI	T1,1			;WANT TRAP, CHANNEL 1
	MOVE	T2,(P)			;GET POINTER BACK
	MOVE	T2,TTYTRF(T2)		;GET THE FLAG
	PUSHJ	P,TAKOT1		;SET UP THE TRAP
TTYEN1:	POP	P,T2			;RESTORE ARG POINTER
	HRRZ	T1,%UPT+UPTENB		;GET BACK ENABLE BITS
TTYEN2:	AOBJN	T2,TTYENB		;TRY NEXT TRAP
	POP	P,T3
	POPJ	P,			;ALL FINISHED

;TABLE OF INTERRUPT NUMBERS AND ENABLE BITS

TTYTRB:	XWD TTNESC,ENBESC
	XWD TTNCHR,ENBCHR
	XWD TTNLIN,ENBLIN

TTYRPT==.-TTYTRB			;NUMBER

TTYTRF:	XWD FLGESC,0			;FLAGS
	FLGCHR
	FLGLIN

INTERNAL APRENB,SETPOV
EXTERNAL TTTCLR,TINAS1,TTNESC,TTNCHR,TTNLIN
EXTERNAL JBTINT,UPTTPN,UPTTP1,JBYHNG,TTYTAB,UPTTCB,UPTTCE
EXTERNAL USRMPE,ERRPOV,USRMP2


;HERE ON PDL OV. MUST BE AN OLD STYLE TRAP

USRPDT:	MOVEI	T1,FLGPDL
COMNT2::POP	P,T3			;GET THE PC FROM PDL
COMINT:	MOVE	J,JOB
	PUSHJ	P,CLKTRO		;AND GET IT CORRECTED AND JOBCNI ETC. SET
COMNT1::PUSH	P,T3
	JRST	USRXIT

;HERE ON OLD STYLE OVERFLOW TRAP

USROVT:	MOVEI	T1,FLGFOV!FLGOV
	POP	P,T3
	TLNN	T3,PC.FOV!PC.FXU	;SEE IF FLOATING
	TRZ	T1,FLGFOV		;IF NO, RESET FLAG
	JRST	COMINT
;HERE ON EITHER OLD OR NEW UUO TRAP

UUOPTT:	EXECAC				;SWITCH TO EXEC ACS
	MOVE	T3,%UPT+UPTMUP
	MOVE	M,%UPT+UPTMUU
	MOVE	P,[-EPLLEN,,%UPT+UPTPDL-1]	;SET UP PDL
	MOVE	J,JOB
	SKIPL	JBTPIP(J)		;NEW OR OLD
	  JRST	TRPUUO			;NEW
	XCTBU	<MOVEM M,JOBMUU>	;SAVE UUO
	MOVEI	T1,FLGUUO
	JRST	COMINT

TRPUUO:	LDB	T1,JBYUUO
	MOVE	T2,T1
	PUSHJ	P,TSTTRP		;CAN WE TAKE IT NOW?
	  JRST	DSBUUO			;NO, LET THE UUO HAPPEN AND DISABLE
	XCTBU	<MOVEM M,JOBMUU>
	PUSHJ	P,CLKTR1
	MOVEI	T1,UUOPNT
	HRRM	T1,%UPT+UPTPNT		;IN TRAP SO DISABLE
	JRST	COMNT1

DSBUUO:	MOVEI	T1,UUOPNT
	HRRM	T1,%UPT+UPTPNT
	JRST	UUOPN1			;NOW MAKE THE UUO HAPPEN

;SEE IF USER WANTS A CLOCK TRAP
;CALLED FROM CHANNEL 7

EXTERNAL UPTENB
USRCLK:	MOVE	T1,%UPT+UPTPC
	TLNN	T1,PC.USR
	  POPJ	P,			;NOT IN USER MODE
	MOVEI	T1,ENBCLK
	TDNN	T1,%UPT+UPTENB		;ENABLED FOR IT?
	  POPJ	P,			;NO
	SKIPL	JBTPIP(J)
	  JRST	CLKNEW			;NEW STYLE
	MOVE	T3,%UPT+UPTPC
	PUSHJ	P,CLKTRO
	MOVEM	T3,%UPT+UPTPC
	POPJ	P,

CLKNEW:	LDB	T1,JBYCLK
	JUMPN	T1,TAKTRP		;TAKE THE TRAP IF ONE THERE
	HLLZS	%UPT+UPTENB		;RESET FLAGS
	POPJ	P,			;AND ALL FINISHED
EXTERN PDNMUP

DISMIS:	SKIPL	JBTPIP(J)
	JRST	DISNEW			;NEW STYLE
	XCTFU	<MOVE T2,2(T1)>		;GET VALUE TO STORE IN AC
	XCTTU	<MOVEM T2,(M)>		;AND DO IT
	HRR	M,T1
	PUSH	P,JBTAWQ(J)		;SAVE THIS IN CASE OF ESC FLAG
	XCTFU	<MOVE T1,(M)>
	PUSHJ	P,APRENB
	POP	P,T2
	MOVE	T1,%UPT+UPTENB
	TLNE	T2,FLGESC
	TRNN	T1,ENBESC		;ESCAPE ENABLED AND FLAGGED?
	JRST	NODSSC			;NO
	MOVSI	T2,FLGESC+(1B0)
	IORM	T2,JBTAWQ(J)		;SET FOR A TRAP
NODSSC:	XCTFU	<MOVE T1,1(M)>
	TLO	T1,PC.USR!PC.PUB
	TLZ	T1,PC.UIO!37		;GET RID OF INDIRECT AND INDEX
	MOVSI	T2,PC.UIO		;SEE IF USER-IOT WAS SET
	TDNE	T2,PDNMUP(P)
	  TLO	T1,PC.UIO		;IF SO, SET IT AGAIN
	MOVEM	T1,PDNMUP(P)		;SAVE THE NEW PC
	POPJ	P,

DISNEW:	MOVE	T1,JBTPIP(J)
	JFFO	T1,.+2
	POPJ	P,			;NO TRAPS IN PROGRESS
	MOVE	T1,TRPBTS(T2)
	ANDCAB	T1,JBTPIP(J)		;TURN OFF IN PROGRESS FLAG
	LSH	T2,1
	HLRZ	T3,%UPT+UPTENB
	ADDI	T3,-2(T2)
	XCTFU	<MOVE T2,(T3)>		;GET THE REUTNR PC
	TLO	T2,PC.USR!PC.PUB
	TLZ	T2,PC.UIO!37
	MOVSI	T3,PC.UIO		;SEE IF USER-IOT WAS SET
	TDNE	T3,PDNMUP(P)
	  TLO	T2,PC.UIO		;IF SO, SET IT AGAIN
	MOVEM	T2,PDNMUP(P)		;SAVE THE NEW PC
DISTPC:	JFFO	T1,.+2			;FIND HIGHEST CHANNEL IN PROGRESS
	MOVEI	T2,^D36			;NONE
	LDB	T1,JBYUUO
	JUMPE	T1,UUOOK		;SHOULD WE REENABLE?
	CAML	T1,T2
	  JRST	UUOOK			;NO, HIGHER STILL IN PROGRESS
	MOVEI	T1,UUOPTT		;YES
	HRRM	T1,%UPT+UPTPNT
UUOOK:	SKIPGE	T1,JBTAWQ(J)		;ALREADY WAITING FOR TRAP
	  POPJ	P,			;YES, GO NOW
	AND	T1,JBTENB(J)		;GET BITS WHICH WANT AND ENABLED
	SKIPGE	JBTENB(J)		;IS PI SYSTEM ON AT ALL?
	CAMG	T1,JBTPIP(J)		;AND WANT HIGHER THAN NOW?
	  POPJ	P,			;NO
	MOVSI	T1,(1B0)
	IORM	T1,JBTAWQ(J)		;SET AWAIT REQUEST FLAG
	POPJ	P,
ABTUUO:	HRRI	P,%UPT+UPTPDL		;SET PDL TO THE RETURN TO USER LOC
	SOS	(P)			;RETURN POINTING TO UUO
	MOVE	J,JOB
	PUSHJ	P,TIMADJ		;GET OUT OF NO CLOCK STATE
	JRST	USRXIT

INTERNAL ABTUUO,DISMIS,USRCLK,TSTKOT
EXTERNAL JBYCLK,JBYUUO,JOB,USRXIT
EXTERNAL TIMADJ,JBYWAK,JBYNTQ,JBYEXC

;ROUTINES TO HANDLE TIME AND CONDITION DISMISS

INTERNAL SLEEP,HIBER

SLEEP:	SKIPGE	JBTAWQ(J)
	 JRST	ABTUUO			;DO NOT START SLEEP IF INT WAITING
	PUSHJ	P,TTSCLR		;CLEAR ALL TTY SLEEP CONDITIONS
	IMUL	T1,JFYSEC		;CONVERT SECONDS TO JIFFIES
	TRNN	T1,7777			;IF 0
	MOVEI	T1,1			;SET TO 1 JIFFIE
	ANDI	T1,7777			;ONLY 12 BITS FOR COMPATABLITY
SLEEP2:	HLRZ	T2,JBTICT(J)		;WILL HE SLEEP LONGER THAN IN
	CAMLE	T1,T2			;MEMORY PROTECT TIME?
SLEEP1:	HRROS	JBTICT(J)		;YES, SWAP HIM NOW
	DPB	J,CLKJOB##		;SET JOB. ACT AND TYPE ALREADY 0
	PUSHJ	P,CHGCLK		;CHANGE OR INSERT CLOCK REQ
	JRST	SETSLP			;AND PUT HIM TO SLEEP

XP .SLWAK,0
HIBER:	SKIPGE	JBTAWQ(J)
	  JRST	ABTUUO			;NO SLEEP IF INT WAITING
	PUSHJ	P,TTSCLR		;CLEAR SLEEP CONDITIONS
	TLNN	T1,HIBPRT		;IS A PORT SPECIFIED?
	  JRST	[HRRZ	F,TTYTAB(J)	;NO USE COMMAND PORT
		JRST	HIBPST]		;PORT SET
	LDB	F,[POINT HISPRT,T1,HINPRT]	;GET PORT NUMBER
	PUSHJ	P,FNDPRT		;FIND THE PORT
	  MOVEI	F,0			;NONE THERE
HIBPST:	JUMPE	F,CPOPJ			;NO PORT, ERROR RETURN
	MOVSI	T2,-HIBNUM		;NUMBER OT TTY REASONS
	PUSH	P,T1
HIBTTY:	HLLZ	T1,(P)
	TDNN	T1,HIBTAB(T2)		;THIS ONE?
	  JRST	HIBNOT			;NO
	PUSH	P,T2
	MOVEI	T3,^D36			;SLEEP CHANNEL
	HRRZ	T2,HIBTAB(T2)		;NUMBER OF INTERRUPT
	PUSHJ	P,TINAS1		;SET IT UP
	  SKIPA				;NOT SATISFIED
	JRST	NOHIB			;ALREADY SATISFIED
	POP	P,T2
HIBNOT:	AOBJN	T2,HIBTTY
	POP	P,T1
	TLNE	T1,HIBYLB
	  PUSHJ	P,TTYYLS		;SEND A YELLOW BALL
HIBNTY:	AOS	(P)			;FOR SKIP RETURN
	TLNN	T1,HIBWKU!HIBFEX	;SHOULD WE ENABLE FOR WAKE UUO OR FRAME EXITS??
	  JRST	HIBNWK			;NO
	SETZ	T2,
	TLNE	T1,HIBWKU		;ENABLE FOR WAKUUO?
	TRO	T2,WAKFLG		;YES
	TLNE	T1,HIBFEX		;ENABLE FOR EXIT IN CHILD?
	TRO	T2,EXCFLG		;YES
	TDNE	T2,JBTSTS(J)		;WAITING NOW?
	JRST	[ANDCAB	T2,JBTSTS(J)
		POPJ	P,]		;CLEAR AND GO
	MOVEI	T2,^D36
	TLNE	T1,HIBWKU		;ENABLE FOR WAKE UUO?
	DPB	T2,JBYWAK		;YES.
	TLNE	T1,HIBFEX		;ENABLE FOR FRAME EXITS?
	DPB	T2,JBYEXC		;YES.
HIBNWK:	LDB	T2,[POINT HISTIM,T1,HINTIM]
	HRRZS	T1			;THE TIME
	JUMPE	T1,SLEEP1		;NO TIME, FOREVER
	XCT	HIBTB1(T2)		;CORRECT TIME REFERENCE
	IMUL	T1,JFYSEC
	IDIVI	T1,^D1000		;CONVERT MS. TO JIFFIES
	SKIPE	T2
	ADDI	T1,1		;ROUND UP
	JRST	SLEEP2

HIBTB1:	JFCL
	JRST HIBSEC
	JRST HIBMIN
	JRST HIBMIN

HIBTAB:	XWD HIBCHR,TTNCHR
	XWD HIBLIN,TTNLIN
	XWD HIBYLB,TTNYLB

HIBNUM==.-HIBTAB

NOHIB:	POP	P,T2
	JRST	TPOPJ1

HIBSEC:	TLO	T1,(1B0)		;SET FOR SECONDS
	TRZE	T1,3B19			;IF OVERFLOW
	  HRRI	T1,177777		;SET FOR MAX
	JRST	SLEEP1

HIBMIN:	TLO	T1,(1B0)
	TRZE	T1,3B19
	HRRI	T1,377777
	TRO	T1,1B19			;FOR MIN
	JRST	SLEEP1

EXTERNAL JFYSEC,JBTICT,SETSLP,TTNYLB,TPOPJ1,CHGCLK,FNDPRT,TTYYLS
INTERNAL WAKUUO,EVICT
EXTERNAL FARCHK

;WAKE UUO. CALL IS
;
;	MOVEI	AC,<FRAME DESCRIPTOR>
;	WAKE	AC,
;	  <ERROR RETURN>
;	<SKIP RETURN>

WAKUUO:	MOVEI 	P3,.ARWAK	;NEED THIS LEVEL OF ACCESS
	HRRZ 	P4,T1		;GET FD IN P4
	PUSHJ 	P,FARCHK	;SEE IF CAN DO IT
	  POPJ 	P,		;NO
				;YES, J HAS FRAME NUMBER NOW, ALL CHECKED.
	MOVSI	T1,JNA		;FRAME EXISTS?
	TDNN	T1,JBTSTS(J)
	POPJ	P,		;NO, GIVE ERROR.
	AOS 	(P)
	LDB 	T1,JBYWAK
	JUMPN 	T1,TAKTRP	;GO
	MOVEI 	T1,WAKFLG
	IORM 	T1,JBTSTS(J)	;SET WAITING FLAG IN DEST
	POPJ 	P,


; WONDERFUL  EVICT  UUO - WAKES A JOB UP WHEN HE IS ABOUT TO BE HUNG
; BIT 17 SET IN AC IF WE ARE TO REALLY DO IT, OTHERWISE JUST RETURN
; THE CHANNEL OF THE INTERRUPT ASSIGNMENT IF ANY IN AC.

EVICT:	XCTTU 	<SETZM (W)>	;IN CASE SOME ERROR
	PUSH 	P,T1
	MOVEI 	P3,.ARHLT	;NEED TO BE ABLE TO HALT HIM TO EVICT
				; (PROG THINKS SYSTEM WILL CRASH HIM)
	HRRZ 	P4,T1		;GET FD IN P4
	PUSHJ 	P,FARCHK	;HAS ACCESS?
	  POPJ 	P,		;NO, ERROR
	POP 	P,T1
	SKIPGE	T2,JBTSTS(J)	;MAKE SURE ITS RUNNING
	 TLNN	T2,JNA		; AND IT EXISTS (REDUNDANT)
	  POPJ 	P,
	AOS 	(P)   		;SKIP RETURN
	MOVE 	T2,T1		;KEEP AROUND THE FLAGS FROM LH(AC)
	LDB 	T1,JBYNTQ
	UMOVEM 	T1,(W)
	TLNE 	T2,(1B17)	;DOES USER WANT US TO REALLY DO IT?
	  JUMPN T1,[	MOVSI	T2,PVLOS	; logout on stop
	  		IORM	T2,JBTPRV(J)
			JRST	TAKTRP ]	; go cause interrupt
	POPJ 	P,

;HERE ARE THE ROUTINES TO HANDLE THE NEW MULTI-LEVEL INTERRUPT
;STRUCTURE

;ROUTINE TO SET INTERRUPT TABLE ADDRESS
;RH OF AC=INTERRUPT TABLE ADDRESS (0=DO NOT CHANGE)
;LH OF AC.
;	BIT 17 TURN OFF SYSTEM
;	BIT 16 TURN ON SYSTEM
;	BIT 15 RESET SYSTEM. CLEAR WAITING TRAPS AND PI IN PROG

INTADR:	MOVE	T2,%UPT+UPTENB		;SET TO RETURN OLD VALUE
	SKIPL	JBTPIP(J)		;IS NEW SYSTEM ALREADY IN EFFECT?
	  TRZA	T2,-1			;YES, MAKE SURE R.H. IS 0
	 TRO	T2,1			;NO, MAKE SURE R.H. IS NON-0
	XCTTU	<MOVEM T2,(W)>		;RETURN VALUE TO USER
	TRNN	T1,-1			;ARE WE SETTING ADDRESS?
	  JRST	[SKIPGE JBTPIP(J)	;NO ALREADY IN NEW SYS?
		  POPJ	P,		;NO, ERROR RETURN
		 JRST	INTAD1]		;YES, GO
	HRLZM	T1,%UPT+UPTENB		;SAVE INTERRUPT TABLE ADDRESS
INTAD1:	AOS	(P)			;SET FOR SKIP RETURN
	SKIPL	JBTPIP(J)		;ALREADY NEW SYSTEM?
	  JRST	INTAD2			;YES
	PUSHJ	P,TTTCLR		;NO, RESET ALL TTY TRAPS
	SETZM	%UPT+UPTTPN		;AND APR TRAPS
	SETZM	%UPT+UPTTP1		;ALSO OTHER APR TRAPS
	SETZM	JBTINT(J)		;INTERRUPT CELLS IN JOB TABLES
	SETZM	JBTPIP(J)		;ALSO INTERRUPTS IN PROG
	SETZM	JBTENB(J)		;INTERRUPT ENABLED
	SETZM	JBTAWQ(J)		;AND INTERRUPTS WAITING
	MOVSI	T2,(JFCL)
	MOVEM	T2,%UPT+UPTOVT		;RESET TRAP CONDITIONS
	MOVEI	T2,USRMPE
	MOVEM	T2,%UPT+UPTPGT
	MOVEI	T2,ERRPOV
	MOVEM	T2,%UPT+UPTPOV
	MOVEI	T2,UUOPNT
	HRRM	T2,%UPT+UPTPNT
INTAD2:	TLNE	T1,(1B15)		;SHOULD WE RESET SYSTEM?
	  PUSHJ	P,CLRINT		;YES
	MOVSI	T2,(1B0)		;GET READY TO TURN ON OR OFF
	TLNE	T1,(1B17)
	  JRST	DSBALL			;TURN OFF, GO DO IT
	TLNE	T1,(1B16)
	  IORM	T2,JBTENB(J)		;TURN ON
	MOVE	T1,JBTPIP(J)
	JRST	DISTPC			;SEE IF SOMETHING SHOULD BE TURNED ON
;CALLI TO ENABLE CHANNELS OR DISABLE
;BIT 0 ON MEANS ENABLE, OFF MEANS DISABLE
;BITS 1-35 ARE THE CHANNELS TO ENABLE OR DISABLE

INTENB:	SKIPGE	JBTPIP(J)		;MUST HAVE SET NEW SYSTEM
	  POPJ	P,			;ELSE ERROR RETURN
	AOS	(P)
	MOVE	T2,JBTENB(J)
	XCTTU	<MOVEM T2,(W)>		;RETURN OLD ENB WORD
	TLZN	T1,(1B0)		;ENABLE OR DISABLE?
	  JRST	DSBCHL			;DISABLE
	IORM	T1,JBTENB(J)		;TURN ON
	MOVE	T1,JBTPIP(J)
	JRST	DISTPC			;GO SEE IF SOMETHING SHOULD BE RESET
DSBALL:	MOVE	T1,T2
DSBCHL:	ANDCAM	T1,JBTENB(J)
	SKIPL	T1,JBTAWQ(J)		;IS SOMETHING WAITING
	  POPJ	P,			;NO
	JRST	RSTCH1			;YES, SEE IF WE SHOULD RESET IT

;THIS UUO CAUSES AN INTERRUPT OR CLEARS AWAITING REQUEST
;BIT 0 ON MEANS CAUSE INTERRUPT, OFF MEANS CLEAR WAITING REQ
;BITS 1-35 ARE THE CHANNELS TO AFFECT

INTACT:	SKIPGE	JBTPIP(J)		;MUST BE NEW STYLE
	  POPJ	P,
	AOS	(P)
	MOVE	T2,JBTAWQ(J)
	XCTTU	<MOVEM T2,(W)>		;RETURN OLD AWQ WORD
	TLZN	T1,(1B0)
	  JRST	RSTCHL
	IORM	T1,JBTAWQ(J)
	JRST	UUOOK			;SEE IF INTERRUPT NEEDED NOW

RSTCHL:	ANDCAB	T1,JBTAWQ(J)
	JUMPGE	T1,CPOPJ		;DONE IF NOT NOW WAITING
RSTCH1:	TLZ	T1,(1B0)
	AND	T1,JBTENB(J)		;IS SOMETHING WAITING AND ENABLED
	CAMLE	T1,JBTPIP(J)		;HIGHER THAN IN PROG?
	  SKIPL	JBTENB(J)		;AND CURRENTLY ENABLED
	 SKIPA				;NO TO ONE OF THESE
	  POPJ	P,			;YES, GO
CLKNTP:	MOVSI	T1,(1B0)
	ANDCAM	T1,JBTAWQ(J)		;TURN OFF REQUEST FLAG
	POPJ	P,

INTERNAL INTACT,INTENB,INTADR,REDPIP

REDPIP:	SKIPGE	T1,JBTPIP(J)
	  POPJ	P,			;OLD SYSTEM
	UMOVEM	T1,(M)			;RETURN ARG.
	JRST	CPOPJ1			;AND RETURN.
;ROUTINES TO SET THE TRAP INSTRUCTIONS

;TRAP1 1 INSTRUCTION (OVERFLOW)

SETTR1:	MOVE	T2,%UPT+UPTOVT		;GET OLD ONE
	UMOVEM	T2,(W)
	JUMPE	T1,CPOPJ		;0 IS ERR REQUEST
	TLNN	T1,777000		;SEE IF WANTS MONITOR TO TAKE OVER
	  MOVSI	T1,(JFCL)		;YES
	MOVEM	T1,%UPT+UPTOVT
	JRST	CPOPJ1

;TRAP 2 INSTRUCTION (PDL OV)

SETTR2:	MOVE	T2,%UPT+UPTPOV
	UMOVEM	T2,(W)
	JUMPE	T1,CPOPJ		;0 IS ERR REQUEST
	TLNN	T1,777000		;MONITOR TO HANDLE?
	  MOVEI	T1,ERRPOV		;YES
	MOVEM	T1,%UPT+UPTPOV
	JRST	CPOPJ1

INTERNAL SETTR1,SETTR2

;SET TIMER TO GIVE INTERRUPT

SETTIM:	LDB	T2,[POINT HISTIM,T1,HINTIM]	;GET TYPE (MS, SEC, MIN)
	HRRZS	T1
	XCT	TIMTAB(T2)
	IMUL	T1,JFYSEC
	IDIVI	T1,^D1000		;MS TO JIFFIES
	TRZE	T1,1B18
	  MOVEI	T1,377777		;CONVERT LARGEST TO SOMETHING ELSE
SETIM1:	MOVEI	T2,<.SLTIM>B30!1B35	;DISP (6) 2B30 TYPE (5) 1B35
	DPB	T2,[POINT 11,T1,11]	;SET UP DISPATCH AND TYPE
	DPB	J,[POINT 7,T1,18]	;AND JOB
	AOS	(P)
	JRST	CHGCLK			;PUT IN REQUEST

TIMTAB:	JFCL				;MILLI-SECONDS
	JRST	TIMSEC			;SECONDS
	JRST	TIMMIN			;MINUTES
	JRST	TIMMIN			;UNDEF. MINUTES FOR NOW

TIMSEC:	TLO	T1,(1B0)
	TRZE	T1,3B19
	  HRRI	T1,177777		;OVERFLOW SET MAX
	JRST	SETIM1

XP .SLTIM,2
TIMMIN:	TLO	T1,(1B0)
	TRZE	T1,3B19
	  HRRI	T1,177777		;OVERFLOW, SET MAX
	TRO	T1,1B19			;SET FOR MIN
	JRST	SETIM1

TIMWAK:	MOVE	J,T1			;HERE WHEN TIMER GOES OFF
	LDB	T1,JBYTIM
	JRST	TAKTRP

; Here from UUOCON for SETMCY CALLI to set micro-cycle
; timer from argument in T1. Error returns if arg is negative.

	EXTERNAL UPTMTM
SETMCY::SETZM	%UPT+UPTMTM	;Clear previous timer (if any)
	JUMPL	T1,CPOPJ	;If negative, give error return
	PUSH	P,T1		;Preserve
	PUSHJ	P,TIMADJ	;Adjust u-cycles for timer accuracy
	POP	P,T1		;Restore
	MOVNM	T1,%UPT+UPTMTM	;Set timer to -<interval>
	PJRST	CPOPJ1		;And skip-return

;HERE TO SET AN INTERRUPT

INTASS:	HLRZ	T3,T1		;THE INTERRUPT NUMBER
	HRRZS	T1		;THE CHANNEL NUMBER
	CAIG	T1,^D35
	  CAIL	T3,INTRNM
	 POPJ	P,		;BAD ARGUMENT
	SKIPGE	JBTPIP(J)	;MUST BE NEW SYSTEM
	  POPJ	P,
	LDB	T2,INTBYP(T3)
	XCTTU	<MOVEM T2,(W)>	;RETURN OLD
	DPB	T1,INTBYP(T3)	;SET CHANNEL
	XCT	INTSET(T3)	;AND CHECK FURTHER WORK
	JRST	CPOPJ1

INTSET:	JRST	INTUUO		;(0) UUO
	JRST	INTCLK		;(1) CLOCK
	JRST	INTILM		;(2) ILL MEM REF
	JRST	CPOPJ1		;(3) HUNG DEVICE
	JRST	CPOPJ1		;(4) TIMER
	JRST	CPOPJ1		;(5) DEVICE ERROR
	JRST	INTWAK		;(6) ENABLE FOR WAKE UUO
	JRST	CPOPJ1		;(7) UWS FAULT, SIZE AT LEAST LIMIT
	JRST	CPOPJ1		;(10) UWS TRAP, SIZE LESS THAN LIMIT
	JRST	CPOPJ1		;(11) REF BIT TRAP
	JRST	CPOPJ1		;(12) TRAP ON I/O ERRORS.
	JRST	CPOPJ1		;(13) NOTICE TO QUIT (TO BE HUNG)
	JRST	INTEXC		;(14) FRAME EXIT INTERRUPT
	SETZM	%UPT+UPTMTM	;(15) Micro-cycle interrupt timer
	JRST	CPOPJ1		;(16) TRU Limit

INTUUO:	MOVEI	T2,UUOPTT
	SKIPN	T1
	  MOVEI	T2,UUOPNT
	HRRM	T2,%UPT+UPTPNT
	JRST	CPOPJ1

INTILM:	MOVEI	T2,USRMPE
	SKIPE	T1
	  MOVEI	T2,USRMPT
	MOVEM	T2,%UPT+UPTPGT
	JRST	CPOPJ1

INTCLK:	SKIPN	T1
	  TDZA	T2,T2		;SET A 0 IF DISABLE
	 MOVEI	T2,ENBCLK
	HRRM	T2,%UPT+UPTENB
	JRST	CPOPJ1

INTERNAL INTASS,TIMWAK,SETTIM
EXTERNAL INTRNM,INTBYP,JBYERR,JBYTIM

INTEXC:	MOVEI	T2,EXCFLG
	SKIPA
INTWAK:	MOVEI	T2,WAKFLG
	AOS	(P)		;WILL ALWAYS SKIP RETURN
	TDNN	T2,JBTSTS(J)	;WAITING ALREADY?
	  POPJ	P,		;NO, OK
	ANDCAM	T2,JBTSTS(J)	;CLEAR FLAG
	JRST	TAKTRP		;AND GO

;HERE FOR CHECKING ON A DEVICE ERROR

DEVECK:	MOVE	S,DEVIOS(F)
DEVEC1:	MOVE	T1,DEVMOD(F)
	TLNE	T1,DVMTA
	  TRNN	S,IOTEND	;IS IT MTA AND END OF TAPE?
	 TRNE	S,IOBKTL+IODTER+IODERR+IOIMPM+IODEND
	SKIPA			;AN ERROR
	  POPJ	P,		;NO ERROR
	LDB	J,PJOBN
	LDB	T1,JBYERR
	PUSHJ	P,TSTKTP
	  POPJ	P,		;TAKEN
	POPJ	P,		;COULD NOT TAKE, IGNORE

INTERNAL DEVECK,DEVEC1,CLRINT

;THIS ROUTINE IS USED TO CLEAR INTERUPT SYSTEM
;USED PRINCIPLY FROM MONSTR
;J MUST HAVE JOB NUMBER

CLRINT:	SETZM	JBTAWQ(J)		;NOT WAITING FOR ANY
	SETZM	JBTENB(J)		;NOTHING ENABLED
	SETZM	JBTPIP(J)		;AND NOTHING IN PROGRESS
	POPJ	P,

	END
  Ih`/S