TITLE ERRCON - MONITOR DETECTED ERROR HANDLING ROUTINES
SUBTTL T. HASTINGS/TH/CHW/TW/RCC SCNSER 07-OCT-70 V425

	STOPCD(,ENTRY,ERRCON)

;THESE ERROR ROUTINES PRINT "ERROR IN JOB N"
;FOLLOWED BY AN APPROPRIATE ERROR MESSAGE
;THEN THE JOB IS STOPPED AND CONSOLE IS RETURNED TO
;MONITOR COMMAND MODE

;APR DETECTED ERRORS
;PUSHDOWN OVERFLOW,ILLEGAL MEMORY, NONEXISTENT MEMORY
;FOR WHICH THE USER IS NOT ENABLED.
;SEE APRSER TO SEE HOW APR INTERRUPTS ARE HANDLED
;CALL:	SKIPE T1,APRERR	;RESULT OF CONI APR,APRERR
;	 PUSHJ P,APRILM	;FROM CLK SERVICE ROUT.(LOWEST PRIOTITY PI)
;	RETURN TO RESCHEDULE NEW USER

EXTERNAL HOLD,ALR620,TTYFND
EXTERNAL TSETBI,GETOPR,TTYFNU,TTYSTR,PIOMOD
EXT(<%UPT,%UPX,%UPS>)
EXTERNAL UPTPDL,UPTABK,UPTSTS,UPSABK,UPTABL
EXTERNAL UPTUII,UPTXII
IFCPU (KL),<EXTERNAL AB.USR>
EXTERNAL JBTSTS
EXTERNAL USRXIT,WSCHED,CLKPC1,CLKPC2
EXTERNAL JOB
SUBTTL SYSTEM ERROR EXIT DEFINITIONS
COMMENT #

GENERATE CODE TO STORE ERROR STATUS IN THE FRAME'S UPT, TRAP TO
TRAPHANDLER OR PARENT, PRINT MESSAGE IF NO ONE IS HANDLING ERRORS.

X ARGUMENTS:

CODE	THREE LETTER CODE FOR ERROR. SYMBOLS ERR??? GENERATED TO JRST TO.
TYPE	TYPE NUMBER WITHIN ERROR CLASS.
MESSAGE	BASIC MESSAGE TO PRINT.
TTYFIN	PUSHJ TO THIS ROUTINE TO FINISH MESSAGE.
	ERRSCP - "FOR (EXEC) LOCATION/PAGE <C(M)> AT USER <C(GETPC)>" OR
		 "FOR (EXEC) LOCATION/PAGE <C(M)>; UUO AT EXEC/USER <C(UPTPDL)-1>"
	ERRSCD - "AT USER <C(GETPC)>" OR
		 ";UUO AT <C(UPTPDL)-1>"
	ERRSCM - "AT USER <C(GETPC)-1>" OR
		";UUO AT <C(GETPC)-1>"
	UUOPCP - "AT USER <C(UPTPDL)-1>"
	ERRSCU - "; UUO AT <C(UPTPDL)-1>"
	TCLTTY - CLEAR TYPE AHEAD, PUT TTY IN MONITOR MODE, PRINT CRLF, WATCH
		 DATA, CRLF, AND PERIOD
	TNCTTY - SAME AS TCLTTY, BUT DOESN'T CLEAR TYPE AHEAD
	E1STTY - PRINT WATCH, CRLF, PERIOD, PUT TTY IN MONITOR MODE (FOR EXIT 1,)
	<BLANK> - DOES TCLTTY
STOP	ROUTINE TO USE TO STOP THE JOB, WHETHER OR NOT A MESSAGE
	IS PRINTED.
	KJSTOP - STOP JOB, SET JERR, SET IT TO LOGOUT IF JLOG OFF
	HISTOP - STOP JOB CONTINUABLY, CONTINUES POPJ
		  (FOR HALT INSTRUCTION AND ADDRESS BREAK.)
	HNSTOP - STOP CONTINUABLY, SET JDCON
	BISTOP - SPECIAL RETURN FOR BAD INTERRUPT ADDRESS
	E1STOP - STOP CONTINUABLY, JRST TO USCHED (FOR EXIT 1,)
		 CONTINUES AT ADDRESS C(P) (IS UPTPDL FOR EXIT 1,)
	HLSTOP - STOP CONTINUABLY, CONTINUE WILL POPJ FROM JRST ERR???
	STOP1  - IF JERR NOT ON, WILL RETURN TO CALLER OF ERR???.
		 USED IF CALLER NOT SAME AS THE FRAME THAT IS STOPPING.
		 ALSO USED IF FRAME STOPS BECAUSE OF DELAYED CONTROL-C
		 IN WHICH CASE PUSHJS TO ERR??? AND JRSTS TO WSCHED, USCHED, ETC.
	<BLANK> - KJSTOP
GETPC	<BLANK> - GET PC FROM STACK
	NONE - NO CODE GENERATED TO FETCH PC
	<NON-BLANK> GET PC FROM SPECIFIED ARG
SETTTY	<BLANK> - USE ERRTTY, SETS UP FRAME'S LDB, OR IF NONE, OPR LDB
	<NON BLANK> - PUSHJ TO ARG ROUTINE, JUMP TO STOP JOB ROUTINE IF
			C(U) IS ZERO, ELSE ASSUME F AND U ARE SETUP
	  TTYFNU - RETURNS C(U) 0 IF DETACHED, OR LDB ADDRESS. C(F) GETS TTY DDB ADDRESS
	  ERRFNU - SAME AS TTYFNU, BUT PRESERVES F.
	  EXIFNU - SPECIAL TTY FINDING ROUTINE FOR EXIT, SEE ROUTINE.
	  EXDFNU - SAME AS EXIFNU, BUT PRESERVES F.
	  NOMESS - NO MESSAGE OR TTY NEEDED, JUST STOP THE FRAME.
VALUE	<BLANK> - NO VALUE ASSOCIATED WITH MESSAGE
	<NON-BLANK> - AC NAME TO STORE INTO UPTELC
VALUE1	<BLANK> - NO VALUE
	<NON-BLANK> - AC NAME TO STORE INTO UPTEL1
UPLOC	<BLANK> - CONTEXT PAGES ACCESSIBLE THRU %UPT
	%UPS - THRU %UPS
	%UPX - THRU %UPX
#

DEFINE ERRS<
ERRCLS==0	;Memory violations
  INTERNAL ERRPCO,ERRIMR,ERRWRV,ERRADC,ERRIMU,ERRIIA,ERRABK,ERRPOV
X(PCO,0,<?PC out of bounds>,ERRSCD)
X(IMR,1,<?Illegal Memory Reference>,ERRSCP)
X(WRV,2,<?Write violation>,ERRSCP)
X(ADC,3,<?Address check for ,DEV>,ERRSCP,,,ERRFNU)
X(IMU,4,<?Illegal Memory Reference in UUO>,ERRSCP)
X(IIA,5,<?Illegal interrupt address>,,BISTOP,NONE)
X(ABK,6,<%Address break>,ERRSCP,HISTOP,P1)
X(POV,7,<?Stack overflow>,ERRSCD)

ERRCLS==1	;System related errors
  INTERNAL ERRPIO,ERRDFL,ERRPHE,ERRTPL,ERRCIO,ERRPAR,ERRMED
X(PIO,0,<?Page I/O error>,ERRSCP)
X(DFL,1,<?Disk full during C-O-W>,ERRSCP)
X(PHE,2,<?Paging hardware error>,ERRSCP)
X(TPL,3,<?Too many pages locked, can't handle fault>,ERRSCP)
X(CIO,4,<?Context page I/O error>)
X(PAR,5,<?Parity error.  All core removed>)
X(MED,6,<?Monitor Error Detected>,UUOPCP)

ERRCLS==2	;Device related errors
  INTERNAL ERROCI,ERRICO,ERRIDM,ERRIUC,ERRHDV,ERRDOP
X(OCI,0,<?Output ,DEV, cannot do input>,UUOPCP,,,ERRFNU)
X(ICO,1,<?Input ,DEV, cannot do output>,UUOPCP,,,ERRFNU)
X(IDM,2,<?Illegal data mode for ,DEV>,ERRSCU,,,ERRFNU)
X(IUC,3,<?I/O to unassigned channel>,UUOPCP)
X(HDV,4,<?Hung ,DEV>,ERRSCU,,,ERRFNU)
X(DOP,5,<?,DEV, OPR action requested>,,HNSTOP,NONE,ERRFNU)

ERRCLS==3	;Illegal instruction traps
  INTERNAL ERRILU,ERRUUE,ERRILI,ERRHLT,ERRCAL
X(ILU,0,<?Illegal UUO>,UUOPCP)
X(UUE,1,<?UUO error>,UUOPCP)
X(ILI,2,<?Illegal instruction>,UUOPCP)
X(HLT,3,<?HALT>,ERRSCM,HISTOP,P1)
X(CAL,4,<?Illegal CALL name>,UUOPCP)

ERRCLS==4	;Frame exits
  INTERNAL ERREXI,ERREX1,ERRFEX,ERRTLE,ERRJSU,ERRJSV,ERRFCL,ERRFX1
X(EXI,0,<CRLF,EXIT>,TNCTTY,KJSTOP,NONE,EXIFNU)
X(EX1,1,<>,E1STTY,E1STOP,NONE,EXIFNU)
X(FEX,2,<?Fail exit >,FEXPRT,KJSTOP,NONE,EXIFNU,T4)
X(TLE,3,<?Time limit exceeded>,TLETTY,STOP1,NONE,TTYFNU)
X(JSU,4,<FNAME, setup>,TNCTTY,KJSTOP,NONE,EXIFNU,P3,P4)
X(JSV,5,<FNAME, saved>,TNCTTY,KJSTOP,NONE,EXIFNU,P3,P4)
X(FCL,6,<%Frame cleared>,,KJSTOP,NONE,NOMESS)
X(FX1,7,<?Fail stop >,FEXPRT,E1STOP,NONE,EXIFNU,T4)

ERRCLS==5	;RUN, RUNSEG, GETSEG UUO errors
  INTERNAL ERRTRE,ERRPGN,ERRDNA,ERRFNF,ERRNSF,ERREUF,ERRCAN,ERRMHB
  INTERNAL ERRRMF,ERRMGF,ERRNSA
X(TRE,0,<?I/O error on file ,FNAME>,,KJSTOP,NONE,EXIFNU)
X(PGN,1,<?,DECPRT, pages needed>,,KJSTOP,NONE,EXIFNU,M)
X(DNA,2,<?,DEV, not available>,,KJSTOP,NONE,EXDFNU);;Preserve F
X(FNF,3,<?,FNAME, not found>,,KJSTOP,NONE,EXIFNU,P3,P4)
X(NSF,4,<?Not a SAVe file>,,KJSTOP,NONE,EXIFNU)
X(EUF,5,<?,FNAME, attempted ENTER UUO failed>,,KJSTOP,NONE,EXIFNU,P3,P4)
X(CAN,6,<?Core argument must be specified>,,KJSTOP,NONE,EXIFNU)
X(MHB,7,<?Magtape HISEG format BAD or system errors>,,KJSTOP,NONE,EXIFNU)
X(RMF,10,<?Fatal error during REMAP UUO>,,KJSTOP,NONE,EXIFNU)
X(MGF,11,<?Magtape GET failure>,,KJSTOP,NONE,EXIFNU)
X(NSA,12,<?No start address>,,KJSTOP,NONE,EXIFNU)
>;END ERRS MACRO DEFINITION
SUBTTL ERROR EXIT ROUTINE GENERATION

DEFINE IFADF(ARG1,ARG2,DO,%A)<;BEGIN DEFINITION OF IF ALL DIFFERENT MACRO
%A==0
IRP ARG2,<IFIDN <ARG1> <ARG2> <%A==-1>
>;END IRP ARG2
IFE %A,<'DO>
PURGE %A
>;END IFADF

DEFINE IFOID(ARG1,ARG2,DO,%A)<;BEGIN IF ONE IDENTICAL MACRO
%A==0
IRP ARG2,<IFIDN <ARG1> <ARG2> <%A==-1>
>;END IRP ARG2
IFN %A,<'DO>
PURGE %A
>;END IFOID
;NOW DEFINE X MACRO, SO CAN CALL ERRS AND GENERATE THE ERROR EXITING
; CODE.

DEFINE X(CODE,TYPE,MESS,TTYFIN,STOP,GETPC,SETTTY,VALUE,VALUE1,UPLOC,%STP,%UP)<
IFB <STOP> <%STP==KJSTOP>
IFNB <STOP> <%STP=='STOP>
IFB <UPLOC> <%UP==%UPT>
IFNB <UPLOC> <%UP=='UPLOC>

ERR'CODE:
IFB <GETPC> <
	MOVE P1,(P)>	;IF BLANK, MEANS PC IS (P).
IFADF GETPC,<P1,NONE,>,<
	MOVE P1,'GETPC	;IF NOT BLANK, MEANS GET PC FROM ARG PLACE
>;END IFADF

	MOVE	T1,[ERRCLS,,'TYPE] ;GET CLASS,,TYPE WITHING CLASS
	MOVEM	T1,%UP+UPTETP	;EXIT TYPE
IRP MESS,<IFIDN <MESS> <DEV> <
	MOVE	T1,DEVNAM(F)	;IF ITS A DEVICE MESSAGE, STORE NAME
	MOVEM	T1,%UP+UPTEDV
>>;END IFIDN AND IRP

IFIDN <TTYFIN> <ERRSCP> <
	MOVEM	M,%UP+UPTELC 	;IF PRINTING LOC, STORE IT TOO.
>;END IFIDN
IFNB <VALUE> <
	MOVEM 'VALUE,%UP+UPTELC ;OR IF OTHER VALUE SPECIFIED
>;END IFNB <VALUE>
IFNB <VALUE1> <
	MOVEM 'VALUE1,%UP+UPTEL1
>;END IFNB <VALUE1>

IFOID 'UPLOC,<%UPT,>,<
	PUSHJ	P,ERRSET>
IFIDN <UPLOC> <%UPS> <
	PUSHJ	P,ERRSES>
IFIDN <UPLOC> <%UPX> <
	PUSHJ	P,ERRSEX>
	  PJRST	%STP		;GO STOP THE JOB WITHOUT MESSAGES

IFDIF <SETTTY> <NOMESS> <
IFB <SETTTY> <
	PUSHJ	P,ERRTTY	;FIND A LINE TO TYPE MESSAGE ON
>;END IFB SETTTY

IFNB <SETTTY> <
  IFDIF <SETTTY> <CPOPJ> <
	PUSHJ P,'SETTTY		;SPECIAL ROUTINE TO SET TTY UP
  >;END IFDIF <SETTTY> <CPOPJ>
	JUMPE U,%STP		;JUST STOP JOB
>;END IFNB <SETTTY>
IFNB <MESS> <IRP MESS,<
IFIDN <MESS> <DEV> <
	PUSHJ P,ERNAM>		;PRINT DEVICE X
IFIDN <MESS> <CRLF> <
	PUSHJ P,CRLF>		;PRINT CRLF IF ASKED TO
IFIDN <MESS> <CRLFQ> <
	PUSHJ P,CRLFQ>
IFIDN <MESS> <FNAME> <
	PUSHJ P,ERFNAM>
IFIDN <MESS> <DECPRT> <
	MOVE T1,M		;GET VALUE INTO T1
	PUSHJ P,PRTDIG>
IFADF MESS,<DECPRT,CRLF,CRLFQ,DEV,FNAME>,<
	PUSHJ	P,INLMES
	ASCIZ	\'MESS\
>;END IFADF
>;END IRP MESS
>;END IFNB MESS
IFNB <TTYFIN> <
	PUSHJ P,'TTYFIN>	;IF NEED MORE PC TYPE INFO, DO IT.
IFB <TTYFIN> <
	PUSHJ P,TCLTTY>
>;END IFDIF <SETTTY> <NOMESS>
	PJRST	%STP		;AND STOP THE JOB.
>;END X MACRO DEFINITION
EXTERNAL UPTJOB,UPTETP,UPTEDV,UPTELC,UPTEL1
;NOW GENERATE ALL THE ROUTINES
XALL	;DON'T WASTE PAPER
	ERRS
SALL	;RESTORE REASONABLE LISTING
;HERE ON PAGE FAILURE. MAY BE OLD OR NEW STYLE

EXTERNAL TSTTRP,CLKTR1,COMNT1,COMNT2,PFSWE%,PFDFC%
EXTERNAL JBTPIP,JBYPGT

USRMPT::			;User mode Memory Page Trap
IFCPU (KI),<MOVE T1,%UPT+UPTUPF>
IFNCPU(KI),<MOVE T1,%UPT+UPTPFW>
	PUSHJ	P,PAGFLU##	;CHECK THE FAULT
	  JRST	USRXIT		;IN CASE HE NEEDS TRAP OR ^C OR CLOCK TICKED.
USRSPF:	XCT	UPFTBT(T1)	;DISPATCH FROM TRAP TABLE
				; HERE FOR WRITE VILOATIONS, ILL MEM REFS,
	HRL	F,M		;CONSTRUCT ILL MEM REF FAULT WORD
	MOVEM	F,%UPT+UPTUII	;PUT IN FOR PGISTS UUO
				; AND ADDRESS BREAKS.
	MOVE J,JOB
	MOVE	P1,T1		;SAVE ERROR CODE FOR LATER
	MOVEI T1,FLGMPT
	SKIPGE JBTPIP(J)	;IS THIS OLD STYLE?
	JRST COMNT2		;YES, GO TAKE CARE OF IT
	LDB T1,JBYPGT		;GET NEW STYLE INTERRUPT
	MOVE T2,T1		;IN CASE WE TAKE THE TRAP
	PUSHJ P,TSTTRP		;CAN WE TRAP RIGHT NOW?
	  JRST	USRSP1		;NO, TREAT AS ERROR.
	POP P,T3		;GET OLD PC
	PUSHJ P,CLKTR1		;SET FOR NEW STYLE TRAP
	JRST COMNT1		;AND GO RETURN TO USER

USRSP1:	XCT	UPFTAB(P1)	;DISPATCH TO PROPER PLACE
PAGUDE:: STOPCD (.,JOB,PAGUDE,,<Page fault - Unexpected Dispatch Error>)


UPFTBT:	 STOPCD (.,XCT,PAGUDE)	;USER CAN'T FAULT FOR EXEC PAGE
	JFCL			;ILL MEM REF
	JFCL			;WRITE VIOLATION
	JRST	ERRPIO		;PAGE I/O ERROR
	JRST	ERRDFL		;DISK FULL ON COW PAGE
	JRST	USRILR		;USER WROTE INTO COW SUPER PAGE
	JFCL			;LET USER HANDLE ADDRESS BREAK
	JRST	ERRTPL		;HARD PAGE FAIL.
SUBTTL	USRMPE - User Memory Protection Error - default handler

USRMPE::			;Called from PICON(PGFAIL) with ACs stacked
	EXCH	J,JOB		;Just in case job # is not in EXEC ac J
	MOVE	T1,(P)		;Get user-mode PC at time of page fault
	ADDI	T1,1		;Since Control-T subtracts 1 from JBTPC
	HRRZM	T1,JBTPC##(J)	; before printing it
	EXCH	J,JOB
IFCPU (KI),<MOVE T1,%UPT+UPTUPF>;UPT+427 = User Page Fault word
IFNCPU(KI),<MOVE T1,%UPT+UPTPFW>;UPT+500 = Page Fault Word
	PUSHJ P,PAGFLU##	;Set T1 for type of page fault user
	  JRST	USRXIT		;IN CASE USER IS GETTING FAULT TRAP OR TYPED ^C
USRMP2::XCT	UPFTAB(T1)	;DISPATCH ON ERROR TYPE.
	 STOPCD (,XCT,PAGUDE)	;Unexpected Dispatch Error

;ERROR DISPATCH TABLE FOR USER MODE FALTS

UPFTAB:	 STOPCD (,XCT,PAGUDE)	;USER CAN'T FAULT FOR EXEC PAGE.
	JRST	USRILR		;TRADITIONAL ILL MEM REF
	JRST	ERRWRV		;WRITE VIOLATION
	JRST	ERRPIO		;PAGE I/O ERROR
	JRST	ERRDFL		;DISK FULL ON COW
	JRST	USRILR		;WROTE INTO SUPER COW PAGE
	JRST	USRABK		;ADDRESS BREAK.
	JRST	ERRPHE		;HARDWARE PAGE FAIL.
	JRST	ERRTPL		;TOO MANY PAGES LOCKED

;USER PAGE FAIL ERROR ROUTINES

USRILR:	LDB	T2,[POINT 9,(P),26] ;GET PAGE OF PC
	CAIE	T2,(W)		;SAME AS ERROR PAGE?
	 JRST	ERRIMR		;NO, ILL MEM REF
	JRST	ERRPCO		;YES, PC OUT OF BOUNDS.


;HERE FOR ADDRESS BREAK

USRABK:	MOVSI	P1,PC.ADR	;SET IT NOW IN CASE TYPES DDT
	IORB	P1,%UPT+UPTPDL
	MOVEM	P1,%UPT+UPTABL	;THIS IS ADDRESS BREAK LOCATION.
	MOVE	M,%UPT+UPTABK	;GET LOCATION OF ADDRESS BREAK
	JRST	ERRABK		;GO PRINT OR TRAP
SUBTTL	Exec Memory Protection Error

EXCMPE::			;Called from PICON(PGFAIL) with ACs stacked
IFCPU (KI),<MOVE T1,%UPT+UPTXPF>	;GET THE PAGE FAIL WORD
IFNCPU(KI),<MOVE T1,%UPT+UPTPFW>
	PUSHJ	P,PAGFLE##	;TAKE USERS PAGE FAULT ROUTINE
	  JRST	KTRRT1##	;IT WAS OK, PAGE SHOULD NOW BE THERE
	XCT	EPFTAB(T1)	;AND DISPATCH.
	TRNN	F,SPFW.U	;IF EXEC PC FAULT TO EXEC PAGE FAILED,
S..IME:: STOPCD (.,STOP,IME,TYPIME,<Illegal Memory-reference from Exec>)
	HRRZ	T1,(P)		;GET FAULT PC
	CAIE	T1,CLKPC1	;IN CLKTRP?
	CAIN	T1,CLKPC2
	 JRST	ERRIIA		;YES, ILLEGAL INTERRUPT ADDRESS ERROR.
	JRST	UUOADR		;NO, BAD UUO ADDRESS ERROR.

;Routine to output data on an Ill Mem-ref Exec
TYPIME:	PUSHJ	P,INLMES##
	 ASCIZ /Instruction is /
IFCPU (KI),<	;Page fail PC is eventually stored at UPT+425
	MOVE	T1,@%UPT+UPTMUP	;Kernal Trap MUUO saved PC of failing instruction
	PUSHJ	P,HWDPNT	;Print the instruction that cause ILL MEM REF
	MOVE	T2,%UPT+UPTMUP	;Now the PC of that same instruction
	PUSHJ	P,PCP		;" at Exec PC xxxxxx"
	PUSHJ	P,INLMES##
	 ASCIZ /
Virtual page /
	LDB	T1,[POINT 9,%UPT+UPTXPF,17]
	PUSH	P,T1
	PUSHJ	P,OCTPNT
	PUSHJ	P,INLMES##
	 ASCIZ /, physical page /
	POP	P,T1
	LSH	T1,P2WLSH	;Convert to word address
	MAP	T1,(T1)
	MOVE	P1,T1		;Save error bits
	ANDI	T1,17777	;Only the page bits
	PUSHJ	P,OCTPNT
	MOVSI	P2,-MAPBTS	;Number of bits to decode
TYPIM1:	HLRZ	T2,MAPTBL(P2)	;Get the bit
	HRRZ	T1,MAPTBL(P2)	;Get message
	TRZN	T2,1		;Complain if bit is on?
	 TDC	T2,P1		;No, complain if it is off
	TDNE	T2,P1		;Bit now set?
	 PUSHJ	P,CONMES	;Yes, complain
	AOBJN	P2,TYPIM1
	PJRST	CRLF		;End of TYPIME for KI

MAPTBL:	1B18!1,,[ASCIZ /<no access>/]
	1B19!1,,[ASCIZ /<public>/]
	1B20!0,,[ASCIZ /<read only>/]	;Complain if B20 is off
	1B21!1,,[ASCIZ /<dirty>/]
	1B22!1,,[ASCIZ /<no match>/]
	MAPBTS==.-MAPTBL
>  ;End IFCPU(KI)

IFNCPU(KI),<	;Page fail PC is at UPT+501
	MOVE	T1,@%UPT+UPTOPP	;Get instruction old PC points to
	PUSHJ	P,HWDPNT	;Print instruction as halfwords
	MOVE	T2,%UPT+UPTOPP	;PC at time of failure UPT+501
	PUSHJ	P,PCP		;Print " at Exec PC xxxxxx"
	PUSHJ	P,INLMES##
	 ASCIZ /
Virtual address /
	HRRZ	T1,%UPT+UPTPFW	;Page fail word at UPT+500
	PUSH	P,T1
	PUSHJ	P,OCTPNT	;Output address
	PUSHJ	P,INLMES##
	 ASCIZ /, physical address /
	POP	P,T1
	MAP	T1,(T1)		;Returns <001000,,0>+<physical address>
	MOVE	P1,T1		;Save error bits
	TLZ	T1,777000	;Keep just physical address
	PUSHJ	P,PRT22A	;Output 27 bit address
	MOVSI	P2,-MAPBTS	;Number of bits to decode
TYPIM1:	HLLZ	T2,MAPTBL(P2)	;Get the bit
	HRRZ	T1,MAPTBL(P2)	;Get message
	TLZN	T2,(1B17)	;Complain if bit is on?
	 TDC	T2,P1		;No, complain if it is off
	TDNE	T2,P1		;Bit now set?
	 PUSHJ	P,CONMES	;Yes, complain
	AOBJN	P2,TYPIM1
	PJRST	CRLF		;End of TYPIME for KL

MAPTBL:	1B0!1B17![ASCIZ /<UPT>/]
	1B1!1B17![ASCIZ /<pager failure>/]
	1B2!0B17![ASCIZ /<no access>/]	;Complain if B2 is OFF
	1B3!0B17![ASCIZ /<read only>/]	;Complain if B3 is OFF
	1B4!1B17![ASCIZ /<dirty>/]	;Software bit, page dirty if set
	1B5!1B17![ASCIZ /<writing>/]	;Write or read-modify-write reference
	1B6!1B17![ASCIZ /<public>/]
	1B7!1B17![ASCIZ /<cached>/]
	1B8!0B17![ASCIZ /<unpaged>/]	;Always ON, complain if OFF
	MAPBTS==.-MAPTBL
>  ;End IFNCPU(KI)

IFNCPU(KS),<
;ROUTINE TO PRINT ADDRESS BREAK AT USER X, STOP JOB WITH NO ERROR
; BIT, AND RETURN. CALLED WITH PUSHJ.

EXCABK:	TRNN	F,SPFW.U	;IF EXEC GOT ADDRESS BREAK FOR USER SPACE,
	 JRST	ADRBRK		;FOR EXEC PAGE, DON'T BOTHER USER.
	HRL	F,M		;GET FAULT INFO WORD IN F
	MOVEM	F,%UPT+UPTXII	;AND STORE FOR USER TO SEE WHEN UUO RETURNS.
	MOVSI	T1,PC.ADR
	IORM	T1,(P)
	MOVE	T1,%UPT+UPTPDL	;THIS IS ADDRESS BREAK LOCATION
	SOS	T1		;BACK UP TO LOCATION OF UUO.
	MOVEM	T1,%UPT+UPTABL	;
EXCAB1:	MOVSI	T1,UPSABK	;SET ADDRESS BREAK AT UUO LEVEL FLAG
	IORM	T1,%UPT+UPTSTS
	MOVEI	T1,UTRP		;SET SO USRXIT WILL SEE
	IORM	T1,JBTSTS(J)
	JRST	KTRRT1		;RETURN.

ADRBRK::MOVSI	T1,PC.ADR	;INHIBIT ADDRESS FAILURE
	IORM	T1,(P)		;SO WE CAN DISMIS
	MOVE	T1,ABKSET##	;SEE IF OK TO MESS WITH ADDRESS BREAK
	CAME	T1,[WRADB %UPT+UPTABK] ;HAS IT BEEN CHANGED FOR EDDT?
	 JRST	KTRRT1		;NO, NO MESSAGE, DDT BREAKPOINT AT ADRBRK
	MOVE	T1,(P)		;GET PC OF ADDRESS BREAK
	MOVEM	T1,%UPT+UPTABL	;PUT EXEC PC FOR ABKPRT TO PRINT
				; MUST BE A %UPT SETUP, OR CAN'T GET ADDRESS BREAK
	MOVEI	T1,ABKACS	;SAVE ACS AT BREAK FOR EXEC ADDRESS SPACE
	XCTFU	<BLT T1,ABKACS+17>
	JRST	EXCAB1		;GO SET UTRP AND UPSABK AND RETURN.

ABKACS::BLOCK	20		;ACS STORED HERE ON EVA BREAK.
>  ;End IFCPU(KS)
;EXEC FAULT ERROR DISPATCH

EPFTAB:: STOPCD (,XCT,S..IME)	;Exec fault for context page or exec hiseg
	JFCL			;ILL MEM REF TO USER
	JFCL			;ILL WRITE REF TO USER
	JRST	EXCPIO		;I/O ERROR ON PAGE
	JRST	EXCDFL		;COW DISK FULL
	 STOPCD (,XCT,S..IME)	;CRASH IF EXEC WRITES INTO SUPER COW.
IFNCPU(KS),<JRST EXCABK>	;EXEC ADDRESS BREAK (KI+KL, don't know F3)
IFCPU (KS),<STOPCD (,XCT,S..IME)>;2020 does not have address break hardware
	 STOPCD (,XCT,S..IME)	;HARD PAGE FAILURE.
	JRST	EXCTPL		;CORE FULL ON MWSRPL

;ERROR ROUTINES

;EXEC PAGE I/O ROUTINE. CALLED FROM PAGFLE ERROR RETURN AND
; FROM DEFFERED I/O ERROR PROCESSING IN USRXIT. ASSUMES
; PAGE FAIL ALWAYS TURNS ON THE IGNORE ERROR BITS FOR VPS
; THAT IT REFERENCES.

EXTERNAL JBYPER,TSTKTP,ABTUUO

;ROUTINE TO PRINT PAGE I/O ERROR OR GIVE RETURN, IN WHICH CASE
; CALLER WILL CAUSE TRAP.

EXCPIO::PUSHJ	P,CHKABT	;ALLOW MONITOR TO CLEAN UP.
	HRRZS	W		;CLEAR LH
	CAILE	W,777		;IF EXEC PAGE,
	JRST	ERRPIO		;NO TRAPS, PLEASE
	LDB	T1,JBYPER	;GET PAGE I/O ERROR CHANNEL
	JUMPE	T1,ERRPIO	;USER NOT ENABLED FOR IT
	PUSHJ	P,TSTKTP	;OK, CAN HE TAKE IT NOW?
	  JRST	[MOVEI T1,ABTUUO ;ROUTINE TO BACKUP PC
		 HRRM T1,(P)	;PUT ONTO RETURN PLACE
		 JRST KTRRT1]	;AND LET CALLER TAKE THE TRAP
	JRST	ERRPIO		;EXEC PAGE ERROR.

EXCPDL::MOVEM	P,XXXPDL	;Save bad stack pointer
	MOVEI	P,XXXPDL	;Point to 1-word stack
	 STOPCD (.,STOP,EPDLOV,,<Exec Push Down List Overflow>)
XXXPDL:	BLOCK	2		;Saves old P, and 1 PC

EXCDFL:	PUSHJ	P,CHKABT	;CLEAN UP IF NECESSARY
	PJRST	ERRDFL		;AND TO DO THE ERROR.

EXCTPL:	PUSHJ	P,CHKABT	;CLEAN UP
	JRST	ERRTPL		;AND GO DO THE ERROR.
ADRERR::PUSHJ	P,CHKAB1	;DO JBTABT ROUTINE IF THERE
	JRST	ERRADC		;AND DO ADDRESS CHECK.

EXTERNAL JBTABT,ABTCPL

UUOADR::PUSHJ	P,CHKABT	;CLEAN UP IF NECESSARY.
	JUMPE F,ERRIMU		;ILLEGAL UUO ADDRESS
	MAP T1,DEVNAM(F)
IFCPU (KI),<TRNE T1,MAP.FL>
IFNCPU (KI),<TLNE T1,PFW.H		;FORGET IT IF HARD ERROR
	JRST ERRIMU
	TLC W.A+PFW.W	;MAKE EASY TO SEE IF ONE IS OFF
	TLNE	T1,PFW.R	;IF UNPAGED REF, SKIP
	TLNN	T1,PFW.A+PFW.W	;PAGED. IF A OR W WAS OFF, DIE.
	JRST	.+2>		;UNPAGED OR A AND W WERE BOTH ON.
	JRST ERRIMU		;BAD IF DEVNAM(F) NOT LEGAL ADRESS
	MAP T1,@PJOBN
IFCPU (KI),<TRNE T1,MAP.FL>		;ALSO CHECK THAT LDB PJOBN WILL NOT FAULT
IFNCPU (KI),<TLNE T1,PFW.H		;IF HARD FAILURE, FORGET IT
	JRST ERRIMU
	TLC T1,PFW.A+PFW.W
	TLNE T1,PFW.R
	TLNN T1,PFW.A+PFW.W
	JRST	.+2>
				;MUST BE PAGED WITH A OR W OFF.
	JRST ERRIMU		;NOT FAULT
	LDB T1,PJOBN
	CAMN T1,JOB		;POINTS TO CURRENT JOB?
	JRST ERRADC		;YES, PROBABLY REAL DDB ADDRESS
	JRST ERRIMU		;NO, JUST SAY ILL MEM REF IN UUO

;ROUTINE TO SET UP F AND J FOR CALLER, AND CALL JBTABT ROUTINE
; IF ONE IS SETUP. CLEARS JBTABT CELL.
; T1 SETUP WITH OLD CONTENTS OF JBTABT CELL FOR THE FRAME.
; JBTABT ROUTINES MUST PRESERVE W AND M.

CHKABT:	UMOVE	F,F		;GET F AT TIME OF ERROR (OR MAYBE USER'S F?)
CHKAB1:	MOVE	J,JOB
	SETZ	T1,
	EXCH	T1,JBTABT(J)
	PJUMPE	T1,ABTCPL	;IF NO JBTABT ROUTINE, JUST GIVE CONTEXT PAGE LOCKS UP
	PUSHJ	P,(T1)		;CALL JBTABT ROUTINE
	MOVE	J,JOB		;IN CASE JBTABT ROUTINE SMASHED IT
	PJRST	ABTCPL		;THEN GIVE UP LOCKS. (JBTABT ROUTINE MAY
				; NEED THE LOCK TO FIX UP STUFF)


;DISK FULL WHEN USER WROTE IN COPY ON WRITE PAGE.
; T1 HAS ERROR CODE, 1 = DISK FULL. OTHERS, CRASH.

EXTERN CRDFL%


NOCREA::HLRZ	M,T1		;GET PAGE NUMBER IN M
	ANDI	M,777		;JUST 9 BITS WORTH
	LSH	M,^D9		;TURN INTO LOCATION (LIE A LITTLE)
	HRRZS	T1		;JUST ERROR CODE IN RH
	CAIE	T1,CRDFL%	;DISK FULL?
	 STOPCD (.,JOB,PAGNCR,,<Page Fault, cannot create COW page>)
	JRST	ERRDFL		;DISK FULL.
SUBTTL	Illegal UUO or Illegal instruction
;Called at UUO level only, with ACs stacked, P set up, M has UUO

;Illegal UUO, opcodes 045,045,052,053,054 and CALLI -5,-4,-3,-2

UUOMNR::MOVE	P1,PDNMUP##(P)	;Return PC and flags stored at -2(P)
	TLNN	P1,PC.USR	;Check if from user mode
	 JRST	EMUERR		;Exec mode UUO error, do a STOPCD
	PFALL	UUOERR

;Error in UUO (LOGIN while already logged in, TMPCOR function out of range)

UUOERR::JRST	ERRILU		;Say ILLEGAL UUO


SUBTTL	Illegal instructions in Exec mode
;LUUO (opcodes 001-037) are illegal in Exec mode

LUUPDL:	BLOCK	2		;Old P at LUUPDL+0, PUSHJ stores PC at LUUPDL+1
LUUOPC::0			;JSR here from EPT+41 when LUUO detected
	MOVEM	P,LUUPDL	;Save P
	MOVEI	P,LUUPDL	;Set up pointer to 1 word stack
	MOVE	P1,LUUOPC	;Get PC and flags
	MOVEM	P1,%UPT+UPTMUP	;Save where MUUOs store their PC
IFCPU (KI),<MOVE M,EPT##+40>	;Get LUUO from EPT
IFNCPU(KI),<MOVE M,FORTY##>	;Get LUUO from virtual address 40
	MOVEM	M,%UPT+UPTMUU	;Save where MUUOs store their opcode
	PFALL	EMUERR		;Fall into Exec Mode UUO error routine

;Here on an Exec mode UUO error
;In most cases where memory fails, an interrupt will occur, causing UIL stopcode
;P1 and %UPT+UPTMUP contain the PC and flags, M and %UPT+UPTMUU has the opcode

EMUERR:
S..EUE:: STOPCD (.,JOB,EUE,,<Exec Uuo Error>)	;;INSSIM+2=ILLINS+2


SUBTTL	Illegal instruction
;The HALT instruction is a special case which stops job but the user may
;continue from its effective address.

ILLINS::MOVE	P1,PDNMUP##(P)	;Return PC and flags stored at -2(P)
	TLNN	P1,PC.USR	;Make sure in user mode
	 JRST	EMUERR		;Exec mode uuo error  STOPCD;;ILLINS+2
	HLRZ	T1,M		;Get the illegal opcode
	CAIE	T1,(JRST 4,)	;Is it a HALT?
	 JRST	ERRILI		;No, go say ILLEGAL INSTRUCTION
	HRRM	M,%UPT+UPTPDL	;Yes, store E of HALT as the return PC
	JRST	ERRHLT		;And halt job (but allow CONTINUE)
SUBTTL	ROUTINE FOR HUNG IO DEVICE
;CALL	MOVE F,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,DEVHNG
;ASSUMES THAT DEVICE SERVICE ROUTINE HAS BEEN CALLED AND DEVIOS
; WILL NO LONGER BE CHANGED BY INTERRUPT LEVEL.

DEVHNG::MOVE	S,DEVIOS(F)	;GET S
	TLZE	S,IOW		;IS HE IN IO WAIT?
	PUSHJ	P,SETIOD##	;YES, WAKE HIM UP
	TLO	S,IOHNG		;TELL WSYNC TO NEVER RETURN
	TRZ	S,IOACT		;TURN OFF IOACT
	MOVEM	S,DEVIOS(F)	;STORE BACK
	POPJ	P,		;AND JOB WILL START AT ERRHDV.

SUBTTL	HNGSTP - HALT A JOB WHEN A DEVICE IS NOT READY FOR I/O
;CALLED FROM XXXSER AT UUO LEVEL
;CALL	MOVE F,ADDR. OF DEV. DDB
;	PUSHJ P,HNGSTP

HNGSTP::PUSH	P,J
	PUSH	P,S
	PUSH	P,F
	PUSH	P,P1		;P1 USED FOR PRINTING PC
	LDB J,PJOBN##
	PUSHJ P,GETOPR		;GET OPR LINE
	MOVE	F,-1(P)		;GET ORIGINAL F BACK FOR PRINTING AND STORING NAME
	JUMPE U,HNGSTW		;NO LINE, IGNORE
	PUSHJ P,INLMES
	 ASCIZ /
problem on /
	PUSHJ	P,ERNAM		;Output device name F points to
	PUSHJ	P,INLMES
	 ASCIZ / for job /
	PUSHJ	P,PJOB##	;NOW THE JOB
	PUSHJ	P,CRLF
HNGSTW:	MOVSI	T2,FLGHNG	;SET TO FLAG HUNG DEVICE
	LDB	T1,JBYHNG	;GET INTERRUPT CHANNEL
	PUSHJ	P,TSTKOT	;TEST AND TAKE OLD TRAP
	 JRST	ABTUUO		;TOOK TRAP
	JRST	ERRDOP		;DEVICE OPER ACTION REQUESTED ERROR

;HERE TO STOP THE JOB ON OPER ACTION REQUESTED. ACS STILL ON STACK,
; MAYBE LINE, MAYBE NOT.
HNSTOP:	MOVEI T1,JDCON
	IORM T1,JBTSTS(J)
	PUSHJ	P,STOP1		;STOP THE JOB CONTINUABLY
	POP P,P1		;RESTORE SMASHED REG USED FOR PC
	POP P,F
	POP P,S
	POP P,J
	JRST WSCHED		;RESCHEDULE
;MONITOR JOB STARTED UP BY SWAPPER CONTEXT PAGE I/O ERROR CODE.

	EXTERN TPOPJ,JBYHNG,TSTKOT,ABTUUO
	EXTERN ESTOP,MONSTR

ERRSWP::MOVEI	T2,ESTOP	;WHERE TO STOP
	JSP	T1,MONSTR	;SETUP ACS, PDL, CLEAR INTERRUPTS
	MOVEI	T1,ALRACT
	IORM	T1,ALR620
	PUSHJ	P,GETOPR	;NOW PRINT ON OPR CONSOLE
	PUSHJ	P,ERROP1
	PUSHJ	P,INLMES
	 ASCIZ	"?context page I/O error"
	PJRST	ERRCIO		;GO DO THE RIGHT STUFF FOR THE FRAME.
COMMENT ;@@SUBROUTINE ERRSET/ERRSES/ERRSEX/HLTTRP
@@PURPOSE SETUP J TO RELEVANT FRAME NUMBER, STORE EXIT STATUS IN THE
CONTEXT PAGES OF THE FRAME.
HALT COMMAND CALLS AT HLTTRP TO INTERRUPT PARENT.
@@ENTRY	CONTEXT PAGES AT %UPT,%UPS,%UPX AT ENTRIES ERRSET,ERRSES,ERRSEX
	P1/PC OF ERROR
@@ACCUM T1-T4 (MUST SAVE SAME ACS THAT STOP1 DOES)
@@EXIT NON-SKIP IF NO MESSAGE TO BE PRINTED
	SKIP IF NO TRAPHANDLER OR ENABLED PARENT FOR CONDITION, PRINT MESSAGE
@@RESTRICTIONS ONLY CALLED AT UUO LEVEL.
@@FUNCTION SETUP J FROM JOB IF CALLED AT ERRSET. CHECK J, CRASH IF
OUT OF BOUNDS.
INCREMENT EXIT COUNT IN UPT, STORE PC, LAST UUO PC, AND IF
ENABLED PARENT OR TRAPHANDLER, FIRE UP SOFTWARE INTERRUPT IN
THEM.
@@;


EXTERNAL UPTJOB,CPOPJ1,JOBMAX,IPOPJ1
EXTERNAL UPTEPC,UPTEUP,UPTECN,JBTFTR

ERRSES:	MOVEI	T4,%UPS		;CONTEXT PAGES IN %UPS
	JRST	ERRSE0
ERRSEX:	SKIPA	T4,[%UPX]	;CONTEXT PAGES IN %UPX
ERRSET:	MOVEI	T4,%UPT		;CONTEXT PAGES IN %UPT
ERRSE0:	MOVE	J,UPTJOB(T4)	;GET CURRENT JOB NUMBER IN J
	SKIPE	J		;NULL JOB DOESN'T GET ERRORS.
	CAILE	J,JOBMAX	;LEGAL?
	 STOPCD (.,STOP,UUOEIJ,,<Error with Illegal Job number>)
	MOVEM	P1,UPTEPC(T4)	;REMEMBER IT
	MOVE	T1,UPTPDL(T4)	;GET PC OF LAST UUO
	MOVEM	T1,UPTEUP(T4)	;LAST TOP LEVEL UUO OR FAULT PC
	SETZ	U,		;NO LDB YET - MAYBE TTY FINDING ROUTINE WILL SET IT UP, MAYBE NOT.
				; ZERO IT NOW SO KJSTOP WON'T BE FOOLED
	AOS	UPTECN(T4)	;INCREMENT COUNT OF TIMES JOB EXITED.
HLTTRP:	LDB	T1,JBYECF##	;Parent's ECF channel is in child's JBTPNT(J)
	PUSH	P,J		;Save J of child that is exiting
	LDB	J,PRNTBP(J)	;Get frame's parent, if any
	JUMPE	J,IPOPJ1	;If no parent, output messages
	SKIPN	T1		;Use particular channel if set (.IAECF)
	 LDB	T1,JBYEXC##	;Otherwise get parent's general channel (.IAFEX)
	JUMPE	T1,HLTTR1	;Jump if interrupt not desired at present
	PUSHJ	P,TAKTRP##	;Else give parent the trap (J is for parent)
	POP	P,J		;Restore J of frame that is exiting
	POPJ	P,		;Nonskip return to stop frame, suppress message

HLTTR1:	MOVEI	T1,EXCFLG	;Flag that a child has exited
	IORM	T1,JBTSTS##(J)	;Set this for the parent
	JRST	IPOPJ1		;Restore J, skip return to output messages

; Routine to print frame exit error code (octal or SIXBIT), followed by
; "at user xxxxxx"

FEXPRT:	MOVE	T2,%UPT+UPTELC	;Pick up error code
	TLNE	T2,-1		;Skip if octal
	  JRST	[PUSHJ	P,PRNAME
		 JRST	FEXPR1]
	MOVEI	T1,(T2)		;Set up for octal type-out
	PUSHJ	P,OCTPNT
FEXPR1:	PJRST	UUOPCP		;Remainder of message


COMMENT ;@@SUBROUTINE ERRTTY
@@PURPOSE FIND AN LDB TO PRINT MESSAGE ON
@@ENTRY J/FRAME NUMBER
@@ACCUM ??
@@EXIT U SETUP
@@;

EXTERNAL TTYERP			;Set U and F for job's TTY, else for OPR or CTY

ERRTTY:	PUSH	P,F		;DON'T SMASH F
	PUSHJ	P,TTYERP	;GET F AND U SETUP
	  JRST	ERRTT1		;Job has no TTY, OPRLDB in U and F
	POP	P,F		;RESTORE F
	PJRST	CRLF		;PRINT CRLF AND RETURN.

ERRTT1:	POP	P,F		;GET F BACK
	LDB	T1,PRNTBP(J)	;IF HAS NO PARENT,
	JUMPE	T1,ERROPR	;Then continue with OPR's LDB or CTY
	SETZ	U,		;MAKE SURE NO MESSAGE COMES OUT
	POPJ	P,		;AND RETURN SILENTLY.

ERROPR:	MOVEI	T1,ALRUSR	;TELL NETWORK LOGGER OPR MESSAGE
	IORM	T1,ALR620
ERROP1:	PUSHJ	P,INLMES
	ASCIZ/?
?error in /
	PUSHJ	P,PJOBX##	;PRINT JOB NUMBER AND USERNAME
	PFALL	ERRPRG

;Output name of program running

ERRPRG::PUSHJ	P,INLMES##
	 ASCIZ /Running /
	MOVE	T1,JBTFPN##(J)	;Program directory
	PUSHJ	P,PRTDIR##	;Output directory name
	MOVE	T2,JBTPRG##(J)	;Program name
	PUSHJ	P,PRNAME
	MOVE	T2,JBTFPN##(J)	;Program directory
	PUSHJ	P,PRTPPN##	;Output directory number
	PJRST	CRLF##
COMMENT ;@@SUBROUTINE ERRFNU
@@PURPOSE FOR ERRORS THAT DON'T PRINT MESSAGES ON OPR CONSOLE IF JOB
IS DETACHED.
@@ENTRY J/JOB
@@ACCUM PRESERVES F
@@EXIT RETURNS U EITHER 0 IF DETACHED, OR LDB ADDRESS OF WHERE TO TYPE MESSAGE
@@;

ERRFNU:	PUSH	P,F		;THIS IS ALMOST RIDICULOUS
	PUSHJ	P,TTYFNU
	POP	P,F
	POPJ	P,		;IN CASE F HAS DDB ASSOCIATED WITH ERROR.
COMMENT ;@@SUBROUTINE EXIFNU
@@PURPOSE CALLED TO FIND TTY LDB IF ANY IF CALLER NOT DIRECTLY ENABLED
FOR EXIT TRAPPING.
@@ENTRY	J/JOB NUMBER
@@ACCUM T1-T4,F,U
@@EXIT U CONTAINS 0 OR LDB ADDRESS.
@@FUNCTION FIND LDB FOR TTY, IF ANY, AND IF THERE IS ONE, WAIT
FOR ANY CURRENT OUTPUT TO COMPLETE AND THEN RETURN WITH LDB ADDRES IN U.
IF THERE IS NO LDB, AND A PARENT (OR LATER, A TRAPHANDLER FRAME) EXISTS,
JUST RETURN WITH U/0, ERROR ROUTINE WILL JUST STOP THE JOB.
IF THERE IS NO LDB AND NO PARENT OR TRAPHANDLER, IF DISCONNECT STATUS
IS CONTINUE OR DETACH, JUST WAIT FOR ATTACH TO HAPPEN.
IF DISCONNECT STATUS IS OTHER THAN THE ABOVE, CAUSE THE JOB TO BE
KILLED BY CALLING MONHNG, CLEAR U SO ERROR ROUTINES DON'T ATTEMPT
TO PRINT MESSAGES, AND RETURN.
@@;

EXTERNAL IFDET,PVYHNG,TTYFUW,MONHNG

EXDFNU:	PUSH	P,F		;Save pointer to device
	PUSHJ	P,EXIFNU
	POP	P,F		;For RUN error "?Device XXX not available"
	POPJ	P,

EXIFNU:	PUSHJ	P,IFDET		;GET DDB, MAYBE LDB ADDRESS
	  POPJ	P,		;IS ATTACHED, RETURN WITH U SETUP.
	LDB	T1,PRNTBP(J)	;DOES IT HAVE A PARENT?
	JUMPN	T1,CPOPJ	;IF SO, DON'T DO ANY KILLING OR WAITING STUFF
;	DOES IT HAVE A TRAPHANDLER FOR EXITS?
	LDB	T1,PVYHNG	;HAS NO PARENT. SEE WHAT DISCONNECT MODE IS
	CAIE	T1,.PVHDT	;IF DETACH OR
	CAIN	T1,.PVHCN	;CONTINUE ON DISCONNECT,
	 PJRST	TTYFUW		;WAIT UNTIL SOMEONE ATTACHES.
	MOVE	T1,J		;NO, DO WHAT DISCONNECT WOULD HAVE DONE
	PUSHJ	P,MONHNG
	SETZ	U,		;CLEAR THIS SO NO MESSAGES COME OUT
	POPJ	P,		;AND RETURN.
COMMENT ;@@SUBROUTINES ERRSCP/ERRSCD
@@PURPOSE ERRSCP -  PRINT FOR LOCATION(PAGE ON KI) X, THEN ERRSCD
	ERRSCD - PRINT AT USER X OR UUO AT USER/EXEC X
@@ENTRY	P1/PC OF ERR
	M/LOCATION IF CALLED AT ERRSCP
	U/LDB TO TYPE ON
@@ACCUM ?
@@EXIT ALWAYS NON-SKIP
@@;

ERRSCP:
IFCPU (KI),<
	PUSHJ	P,INLMES
	 ASCIZ / for page /
	LDB	T1,[POINT 9,M,26] ;GET PAGE FROM M
	PUSHJ	P,OCTPNT
			;AND FALL INTO ERRSCD
>;END IFCPU (KI)
IFNCPU (KI),<
	PUSHJ	P,INLMES
	 ASCIZ / for location /
	HRRZ	T1,M	;GET FULL LOCATION
	PUSHJ	P,OCTPNT
			;AND FALL INTO ERRSCD
>;END IFCPU (KI)

ERRSCD:	MOVE	T2,P1	;GET PC INTO T2 FOR PCP
	TLNE	T2,PC.USR	;USER MODE
	JRST	ERRSC1		;PRINT PC AND STOP TTY
ERRSCU:	PUSHJ	P,INLMES	;NO, PRINT WHERE UUO IS
	 ASCIZ /; UUO/
	MOVE	T2,%UPT+UPTPDL
	SUBI	T2,1
ERRSC1:	PUSHJ	P,PCP		;PRINT PC
	PJRST	TCLTTY

;PRINT "AT USER <C(P1)-1>" OR ";UUO AT <C(P1)-1>

ERRSCM:	SOJA	P1,ERRSCD
SUBTTL	New externals used by STOPCODE processor

REPEAT 0,<
DATE		;Universal date/time  (18-Nov-1858, 1/3 second resolution)
JBTPRG		;Table with name of file that program came from (not JBTNAM)
SCCTAB,SCCTBL	;Stopcode count table and length
SCLTAB		;Table with LH=ticks until next check, RH=limit
.CPxxx		;CPU data block for this CPU (equated to .C0xxx)
%SYSxx		;System-wide errors, GETTAB table .GTSYS=51
DEBUGF		;Debugging flags, whether or not to dump/reload
DIECDB		;Pointer to CPU Data Block (for FILDDT to set paging)

REBOOT	COMMON	dump and reload the system
RCDSTB	COMMON	read CPU and device status blocks
TYPCSB	COMMON	type CPU status block
BUGDMP	MONBTS	copy all of physical memory to SYS:CRASH.EXE
FLTCHK	PICON	check if bits in T1 indicate a potential page fault
CSDMP	COMMON	do a cache sweep on a KL
SKPMRN	COMMON	skip if master PDP-11 is running on KL
SVPPC	SCNSER	save protocol status, start secondary
PRTDDB	COMCON	type DEVICE:FILE.EXT[P,PN] when F points to DDB
> ;End of REPEAT 0
SUBTTL	STOPCD -- DIE and GOBACK routines

;Routine to recover/reload after an internal system error.
;Called by the STOPCD macro with PUSHJ P,DIE (INFO and EVENT goto NODIE)
;Do a "147 RESTART" if a 2nd stopcode occurs during typeout from 1st stopcode.

NODIE::	AOSN	.CPEVN##	;Flag for an INFO or EVENT stopcode
	 JRST	DIE0		;Don't set the main interlock 1st time thru
DIE::	AOSE	.CPDWD##	;Interlock stopcode processor
	 JSR	CRS147##	;STOPCD(HALT,DIEREH,,<Recursion in Error Handler>)
DIE0:	POP	P,.CPCPC##	;Store continue PC
	SKIPL	.CPDWD##	;If it's a DIE stopcode
DIEDDT:: JFCL	.CPCPC##	;Put EDDT breakpoint here
	CONI	PI,.CPCPI##	;Save PI status
	CONO	PI,PI.TFP+177	;Turn off all PI channels
	MOVEM	17,CRSHAC##+17	;Store current ACs
	MOVEI	17,CRSHAC##	; where FILDDT can find them,
	BLT	17,CRSHAC##+16	; in a system-wide table
	MOVEI	17,PREVAC##	;Place to store previous context ACs
	PXCT	1,BPRVAC##	;XCTFU <BLT 17,PREVAC+17>;Save previous AC block
	MOVE	17,CRSHAC##+17	;Restore 17, then go save all ACs in CDB
	JSR	.CPSVA##	;Save all AC blocks, make .CPACA point to them
EXTERN SAV30,BASAVE		;.CPSVA updates these locations
	MOVE	P,.CPEPD##	;Set up error PDL
	SKIPN	T1,.CPCPC##	;Get PC of stopcode
	 MOVEI	T1,DIEBPC+1	;If zero, point at "Bad PC" stopcode
	SUBI	T1,1		;Back up incremented PC
	MOVEM	T1,.CPSPC##	;Store stop PC
	MOVE	M,0(T1) 	;Get the XCT instruction
	TLC	M,(XCT) 	;Clear these bits
	TLNE	M,777740	;Make sure it was an XCT instruction
	 MOVEI	M,@DIEBPC	;If not, point to "Bad PC" data
IFCPU (KL),<
	PUSHJ	P,CSDMP##	;Dump all of cache to physical memory
	PUSHJ	P,SKPMRN##	;Skip if master PDP-11 is running
	 STOPCD (.,HALT,DIEMNR,,<Master PDP-11 not running>)
>  ;End of IFN FTKL10
				;M points to start of literal block
	PUSHJ	P,DIE1		;Output STOPCODE, resume keep-alive via POPJ
				;.CPCPC may be modified

RESRET:	PUSHJ	P,DAEEST##	;Tell DAEMON(CHKPNT) about the stopcode
	MOVE	T1,.CPDWD##	;One of these flags should be 0, the other -1
	ADD	T1,.CPEVN##	;Was an INFO/EVENT code interrupted?
	AOJN	T1,RELOAD	;Yes, cannot continue
	CONO	PI,PI.TFP+177	;Turn off all PI channels
	MOVEI	T1,177		;All PI bits
	AND	T1,.CPCPI##	;Only the ones that were on
	IORI	T1,PI.TNP	;Turn on selected PI's
	MOVEM	T1,.CPCPI##	;Save for CONO
	HRLZ	17,.CPACA##	;Where to restore the AC's from
	BLT	17,17		;Restore them all
	SETOM	.CPDWD##	;Allow further STOPCD's
	SETOM	.CPEVN##	;Allow further EVENT/INFO codes
	  ..=DF.SBD		;(CREF the use of the sign bit)
	SKIPGE	DEBUGF##	;Is system being debugged?
	 XCT	.CPDDT##	;Yes, jump to DDT (use GOBACK$G to continue)
DIECON::
GOBACK::PUSH	P,.CPCPC##	;Set up continue PC
;*;	SETZM	SYSSNP##	;Disable the snapshot program
	CONO	PI,@.CPCPI##	;Turn on the PI system
	POPJ	P,		;Return from DIE (.CPCPC may have been changed)
SUBTTL	STOPCD -- Process tables


COMMENT @
"Recent findings have show bugs that are adaptive and intellegent.
The study of such bugs has been hampered by the probablity that these
bugs themselves have bugs, producing erratic buglike behavior.  If
this is indeed true, it provides the first demonstration that Murphy's
Law is recursive, that it can invoke itself."

IEEE Spectrum, September 1984
@

DIEBPC:: STOPCD (.,STOP,DIEBPC,,<Bad PC in DIE>)

;Tables for driving stopcode processing

S%FAST==1B0	;Flag for EVENT and INFO (don't switch to secondary protocol
S%NDDB==1B1	;Flag to suppress DDB/JOB typout
S%CSB== 1B2	;Flag to output CPU Status Block (hardware error detected)
S%EVNT==1B3	;Flag to indicate EVENT (as opposed to INFO or other stopcode)

DEFINE STPTAB,<;;Name, STP routine, CDB counter, GETTAB counter, flags
STP	NONAME,RELOAD,0,0,
STP	STOP,RELOAD,0,0,
STP	JOB,JOBSTP,.CPSNJ##,%SYNJS##,
STP	DEBUG,BUGSTP,.CPSND##,%SYNDS##,
STP	CPU,CPUSTP,.CPSNC##,%SYNCS##,<CSB>;;CPU or hardware failure
STP	INFO,INFSTP,.CPSNI##,%SYNIS##,<FAST,NDDB>
STP	EVENT,EVNSTP,.CPSNI##,%SYNIS##,<FAST,NDDB,EVNT>
STP	PATCH,EVNSTP,.CPSNI##,%SYNIS##,<FAST,NDDB,EVNT>
STP	DISK,DSKSTP,0,0,;;	;Set flag to do full DSKCLN and then RELOAD
>

	DEFINE STP(TYP,RTN,CPLOC,SYLOC,FLAGS),<
	IFN <.-STPTYP>-S$'TYP,<PRINTX ? Stopcode type TYP is out of order>
	SIXBIT	\TYP\	>

	XALL
STPTYP: STPTAB			;Table of types in SIXBIT
  STPMAX==.-STPTYP-1	;Maximum legal stopcode type

	DEFINE STP(TYP,RTN,CPLOC,SYLOC,FLAGS),<
	ZZ==0
	IRP FLAGS,<ZZ=ZZ!S%'FLAGS>
	EXP	ZZ ! RTN	;TYP
	PURGE ZZ
	>

PRCTAB: STPTAB			;Processing dispatch table

	DEFINE STP(TYP,RTN,CPLOC,SYLOC,FLAGS),<
	XWD	SYLOC,CPLOC	;TYP>

SCTTAB: STPTAB			;Table of counter locations
	SALL
SUBTTL	STOPCD -- Routine to output the stopcode information

;Here for STOPCODE processing which might need to be run in secondary protocol
;The Keep-Alive function is disabled during typeout, restored via POPJ

;1) Determine type of stopcode
;2) If not INFO or EVENT, disable keep-alive checking (secondary protocol)
;3) Store stopcode type, name, PC, etc in the GETTAB table (for FILDDT & SYSTAT)
;4) If not INFO or EVENT, set output routine to one that does not use interrupts
;5) For EVENT, output "%% Event".  For all others, output 10 bells and "?STOPCD"
;6) Output date and time
;7) For STOP, JOB, and DEBUG, output job status and DDB
;8) If optional typeout routine is provided, call it with original ACs
;9) Output CPU status block for CPU stopcodes
;10) Call RELOAD, JOBSTP, BUGSTP, or CPOPJ depending on stopcode type
;11) If system is to be continued, check for too many stopcodes per minute
;12) Restore primary protocol and keep-alive functions on POPJ
;13) Code at DIECON will resume at continue address (stored in .CPCPC)

DIE1:	HLRZ	T1,0(M)		;Get opcode (should be PUSHJ P,DIE)
	TRZ	T1,37		;Clear index and indirect fields
	CAIE	T1,(XCT)	;Is it a second XCT in a row?
	 JRST	DIE1A		;No, M points to literal block from macro
	MOVE	T1,0(M)		;Yes, get the XCT instruction
	MOVEM	T1,.CPSTY##	;Save outside of the ACs
	MOVE	T1,.CPACA##	;Restore ACs (only T1, M, and P were changed)
	MOVE	M,M(T1)		; in case of XCT TABLE(T1)
	MOVE	T1,T1(T1)
	MOVEI	M,@.CPSTY##	;Get address this XCT points to
	JRST	DIE1		;Check for multiple XCT in a row

;0(M)=PUSHJ P,DIE		;Format of the literal block
;1(M)=SIXBIT /NAME/		;Unique name or /?STOP?/
;2(M)=1B0+<TYPE_^D18>+CONTINUEADDRESS
;3(M)=DATA,,TYPEOUTADDRESS	;Optional, present if 1B0 set in 2(M)

DIE1A:	MOVEM	M,.CPSCB##	;Store address of STOPCD block
	LDB	T1,[POINT 4,2(M),17] ;Get stopcode type
	CAIL	T1,0		;Within range
	CAILE	T1,STPMAX
	 MOVEI	T1,S$STOP	;No, don't make things worse
	MOVEM	T1,.CPSTY##	;Save as stopcode type
		..=S%FAST	;Put reference to sign bit in the CREF listing
	SKIPG	PRCTAB(T1)	;Is this a fast stopcode (INFO or EVENT)?
	 JRST	DIE1B		;Yes
	PUSHJ	P,RCDSTB##	;No, record CPU and device status blocks
	PUSHJ	P,SVPPC##	;Save primary protocol, disable keep alive

COMMENT ~  Note: for TOPS-10 only ($U implemented in FILDDT version 40 or later)
 The following code is explicitly to make it easier to automatically map in
 a crash.  The usual sequence would be to use a DDT file which would say:
 	DIECDB[ $Q-.CPCDB+.CPEPT[ $Q'1000$U	Set up EPT to match dead CPU
 	SPTTAB$6U				Set up SPT mapping (KL paging)
 	.CPACA[ $Q$5U				Set up ACs active at the time
~  ;End of COMMENT

DIE1B:	MOVE	T1,.CPSLF##	;Get physical pointer to the CDB
	MOVEM	T1,DIECDB##	;Save where FILDDT can find it
	MOVE	T1,1(M) 	;Get name of stopcode
	MOVEM	T1,.CPSNM##	;	CDB
	MOVEM	T1,%SYSNM##	;	GETTAB
	MOVE	T1,.CPSPC##	;Get PC of STOPCD macro (points to XCT)
	MOVEM	T1,%SYSPC##	;	GETTAB
	MOVE	T1,.CPSTY##	;Get stopcode type
	MOVEM	T1,%SYSTY##	;	GETTAB
	MOVE	T1,DATE##	;Get universal date/time
	MOVEM	T1,.CPSDT##	;	CDB
	MOVEM	T1,%SYSDT##	;	GETTAB
	MOVE	T1,.CPCPN##	;CPU number
	MOVEM	T1,%SYSCP##	;	GETTAB
	HRRZ	T1,2(M) 	;Get continuation address
	CAIN	T1,1		;Is it <.+1> ?
	 AOS	T1,.CPCPC##	;Yes, make for a skip return
	SKIPE	T1		;If nonzero,
	 MOVEM	T1,.CPCPC##	; set the saved PC to the continue address

DIE2:	MOVE	T1,.CPSTY##	;Get stopcode type
	SKIPN	DINITF##	;Always use CTYWAT if still in once-only
		..=S%FAST	;Put reference to sign bit in the CREF listing
	 SKIPL	PRCTAB(T1)	;Is it an INFO or EVENT stopcode?
	  TDZA	T1,T1		;No, use non-interrupt output routine
	   MOVEI T1,2		;Yes, output to CTY and OPR LDB for these
	PUSHJ	P,OPROUT##	;Tell SCNSER to use this for INLMES
	MOVE	T1,.CPSTY##	;Get stopcode type
	MOVE	T1,PRCTAB(T1)	;Get the control bits for this type of STOPCD
	TLNN	T1,(S%EVNT)	;Is this an EVENT?
	 JRST	DIE3		;No, a real STOPCODE
	PUSHJ	P,INLMES##	;Yes, do not ding bell for an event
	 ASCIZ /
%% /
	MOVE	T1,.CPSTY##	;Get type
	MOVE	T2,STPTYP(T1)	;'EVENT' or 'PATCH'
	PUSHJ	P,PRNAME
	PUSHJ	P,INLMES##
	 ASCIZ / stopcode /
	MOVE	T2,.CPSNM##	;Get stopcode name
	PUSHJ	P,PRNAME	;Output SIXBIT
	PUSHJ	P,INLMES##
	 ASCIZ / at /
	PUSHJ	P,LOCTIM##	;Output date, time of day
	PUSHJ	P,CRLF##
	JRST	DIE5		;Common code

;?JOB stopcode UUOXWL(176070) at 24-JUL-85 12:34:56 GMT

DIE3:	MOVEI	T2,^D10		;Send 10 bells
	PUSHJ	P,BELLEN
	PUSHJ	P,INLMES##	;CRLF and "?"
	 ASCIZ /


?/
	MOVE	T1,.CPSTY##	;Get type
	MOVE	T2,STPTYP(T1)	;'STOP', 'JOB', 'DEBUG', 'INFO'
	CAIN	T1,S$STOP	;'STOP'?
	 MOVE	T2,[SIXBIT /HALT/] ;Yes, don't say "STOP stop"
	PUSHJ	P,PRNAME
	PUSHJ	P,INLMES##
	 ASCIZ / stopcode "/
	MOVE	T2,.CPSNM##	;Get stopcode name
	PUSHJ	P,PRNAME	;(up to 6 characters)
	MOVE	T1,.CPSTY##	;Get type
	CAIE	T1,S$NONAME	;One with no name?
	 JRST	DIE4		;Has a name
;?NONAME stopcode "SCNSER+123(123456)"
	PUSHJ	P,INLMES##
	 ASCIZ /+/
	HRRZ	T1,.CPSPC##	;Yes, get PC of XCT instruction
	SUBI	T1,(M)		;Minus addr of stopcode block
	PUSHJ	P,PRTDI8	;Print offset from start of module
	PUSHJ	P,PRLPR##	;"("
	HRRZ	T1,.CPSPC##	;Get stop PC
	PUSHJ	P,OCTPNT
	PUSHJ	P,PRRPR##		;")"
DIE4:	PUSHJ	P,INLMES##
	 ASCIZ /" at /
	PUSHJ	P,LOCTIM##	;Output date, time of day
	PUSHJ	P,CRLF
	PUSHJ	P,PRTSYS	;Output SYSNO and SERIAL etc
DIE5:	MOVE	T1,.CPSTY##	;Stopcode type again
	MOVE	T1,PRCTAB(T1)	;Get control bits
	TLNE	T1,(S%NDDB)	;Suppress DDB and job typeout?
	 JRST	NODDB
;If a job was running, output JOB then DDB, blame STOPCD on the job
;If at interrupt level, output DDB then JOB, blame STOPCD on the device
	MOVEI	S,PI.IPA	;Get the "PI's ON" mask
	AND	S,.CPCPI##	;Set S nonzero if any interrupts in progress
	MOVE	J,.CPJOB##	;Last job scheduled for this CPU
	SKIPN	S		;At interrupt level?
	 PUSHJ	P,WHATJB	;No, UUO level, output JOB info first
	TLZ	F,-1		;Clear LH in case F points to a DDB
	PUSHJ	P,CHKDDB	;Make sure it's not garbage
	  JRST	NODDB0		;Not a DDB pointer
	LDB	T1,PJOBN##	;Get owning job number from DDB
	SKIPE	T1		;Must not be null job
	CAILE	T1,JOBMAX##	;Must not be too big
	 JRST	NODDB0		;DDB not valid
	PUSHJ	P,INLMES##
	 ASCIZ /File /
	PUSHJ	P,PRTDDB##	;Print DEVICE:FILE.EXT[P,Pn,SFD,SFD,SFD]
	PUSHJ	P,CRLF##
	JUMPE	S,NODDB		;Don't change J if STOPCD at UUO level
	LDB	J,PJOBN##	;Interrupt level - get owning job number
NODDB0:	SKIPE	S		;Output job info last if at interrupt level
	 PUSHJ	P,WHATJB	;Output job number, PPN, etc

NODDB:	MOVE	T1,2(M)		;Get bits field
	TLNE	T1,400000	;Is there more information?
	 SKIPN	T1,3(M) 	;Yes, must be nonzero
	  JRST	NOTYPE		;Nothing there
	HLLM	T1,.CPCPC##	;Store LH where routine can find it
	TLZ	T1,-1		;Clear out for indirect
	PUSH	P,T1		;Save on stack
IFN P-1,<PRINTX ? The code at NODDB+5 assumes that P=1>
	MOVE	17,.CPACA##	;Point to the saved AC block
	MOVE	0,0(17) 	;Load up S
	MOVSI	17,2(17)	;Source address for AC2
	HRRI	17,2		;One past P
	BLT	17,17		;Restore all ACs except for P
	PUSHJ	P,@(P)		;Call routine, 18 bits of data in LH of .CPCPC
	POP	P,T1		;Clean up the stack
	MOVEI	S,PI.IPA	;Get the "PI's ON" mask
	AND	S,.CPCPI##	;Set S nonzero if any interrupts in progress

NOTYPE:	MOVE	T1,.CPSTY##	;Get error type
	MOVE	T1,PRCTAB(T1)	;Get control bits
	MOVSI	T2,(DF.RIP)	;Is RELOAD in progress on other CPU?
	TDNN	T2,DEBUGF##	;Don't output meaningless CSB if so
	TLNN	T1,(S%CSB)	;Output CSB?
	 JRST	NOCSB		;No, don't type CSB for trivial errors
		..=DF.SBD	;Put reference to sign bit in the CREF listing
	SKIPGE	DEBUGF##	;Want DDT?
	 JRST	DIERS0		;Yes, skip CSB typout and PUSHJ to processor
	PUSHJ	P,TYPCSB##	;Type CPU Status Block info on the CTY

NOCSB:	MOVE	T1,.CPSTY##	;Get error type
	HRRZ	T1,PRCTAB(T1)	;Address of routine to process it
	PUSHJ	P,(T1)		;One of RELOAD,JOBSTP,BUGSTP,CPUSTP,CPOPJ

DIERS0: MOVE	T1,.CPSTY##	;Get error type
	HRRZ	T2,SCTTAB(T1)	;Address of the per CPU counter
	AOS	(T2)		;Increment stopcode count
	HLRZ	T2,SCTTAB(T1)	;Address of the system-wide counter
	AOS	(T2)		;Increment stopcode count
	MOVE	T2,PRCTAB(T1)	;Get control bits
	MOVEI	T1,[ASCIZ /[Continuing system]/]
	SKIPE	SLOCRS##	;DSKCLN requested?
	 MOVEI	T1,[ASCIZ /Requesting FULL DSKCLN/]
	TLNN	T2,(S%EVNT)	;No message if EVENT
	 PUSHJ	P,CONMES##	;Send to CTY (don't do a SEND ALL)
	PUSHJ	P,CRLF##
	SKIPE	NOCRS##		;Severe disk errors detected?
	 JRST	RELOAD		;Don't continue if so
	POPJ	P,		;If SVPPC was called, resume primary protocol

;W1051, hardware XXX, KS-4097, base 4200, W1051-P034/P36-12, 10-12-86, M01720
;Called from DIE and from ONCE

PRTSYS::MOVE	T2,.CPSNO##	;SYSNO this monitor was built for
	PUSHJ	P,PR6BIT
	PUSHJ	P,INLMES##
	 ASCIZ /, hardware /
	HLLZ	T2,.CPLOG##	;'AA', 'BB', etc
	PUSHJ	P,PR6BIT
	PUSHJ	P,INLMES##
	 ASCIZ /, /
	HLLZ	T2,.CPCPU##	;'KL', 'KI', 'KS', 'F3'
	PUSHJ	P,PR6BIT
	MOVEI	T3,"-"
	PUSHJ	P,COMTYO##
	HRRZ	T1,.CPCPU##	;CPU serial number monitor was built for
	PUSHJ	P,PRTDEC##
	PUSHJ	P,INLMES##
	 ASCIZ /, base /
	HRRZ	T1,.CPLOG	;Base node number
	PUSHJ	P,PRTOCT
	PUSHJ	P,INLMES##
	 ASCIZ /, /
	MOVEI	T1,CONFIG##	;Full system number
	PUSHJ	P,CONMES##
	PUSHJ	P,INLMES##
	 ASCIZ /, /
	MOVEI	T1,SYSDAT##	;System build date
	PUSHJ	P,CONMES##
	PUSHJ	P,INLMES##
	 ASCIZ /, /
	MOVE	T2,CNFSID##	;Configuration system ID number
	PUSHJ	P,PRNAME
	PJRST	CRLF##

;SUBROUTINE TO SEND C(T2) BELLS
;CLOBBERS T1, T2, T3, T4
BELLEN: HRRZ	T1,.CPTOA##	;Get typeout routine
	CAIN	T1,CTYTYO##	;Using normal buffered typeout?
BELLS:: TDZA	T1,T1		;Noninterrupt routine - must delay
	 MOVEI	T1,1		;No delay for INFO or EVENT stopcodes
	PUSH	P,T1		;Save flag
	PUSH	P,T2		;Save count
BELOOP:	MOVEI	T3,"G"-100	;BELL
	PUSHJ	P,COMTYO##	;DING
	SOSG	(P)		;Decrement count of bells to output
	 JRST	TTPOPJ##	;Done
	SKIPE	-1(P)		;Need to delay?
	 JRST	BELOOP		;No delay for INFO or EVENT
IFCPU  (KL),<MOVSI T1,1> 	;Loop 2^18 times on a KL10
IFNCPU (KL),<MOVEI T1,200000>	;Loop 2^16 times for all others
	DMOVE	T2,BECODE	;Put delay in ACs to avoid erratic timing
	JRST	T2		; due to presence or absence of cache

BECODE: SOJG	T1,T2		;(T2) Decrement and loop
	JRST	BELOOP		;(T3) Output another bell when done
SUBTTL	STOPCD -- CPUSTP = CPU stopcode
CPUSTP:	PUSHJ	P,INLMES##
	 ASCIZ /? CPU or hardware error - / ;Hardware other than the disks
	JRST	RELOAD

SUBTTL	STOPCD -- DSKSTP = DISK stopcode
DSKSTP:	MOVE	T1,.CPSPC##	;PC of where error was detected
	MOVEM	T1,SLOCRS##	;Make nonzero to request full DSKCLN
	JRST	RELOAD

SUBTTL	STOPCD -- STPSTP = stopcode limit exceeded
STPSTP:	PUSHJ	P,INLMES##
	 ASCIZ /? Stopcode limit exceeded - /
	JRST	RELOAD

SUBTTL	STOPCD -- INFSTP = INFO stopcode
INFSTP:	POPJ	P,		;No dump on INFO codes, no limit either

SUBTTL	STOPCD -- EVNSTP = EVENT stopcode
EVNSTP:	POPJ	P,		;No dump on EVENT codes, no limit either

SUBTTL	STOPCD -- DSKCLN - Set flag to do a full DSKCLN
DSKCLN::POP	P,SLOCRS##	;Get PC of where error was detected
	JRST	@SLOCRS##	;"POPJ P,"

SUBTTL	STOPCD -- RELOAD = STOP or CPU stopcode

	DF.RLD==DF.RIP
RELOAD::MOVSI	T1,(DF.RLD)	;Indicate that reload was requested
	IORM	T1,DEBUGF##	;For CRSCPY to notice
	PUSHJ	P,INLMES##
	 ASCIZ /Reload monitor

----------------------------------------------------
/
	MOVEI	T2,^D20		;20 BELLS
	PUSHJ	P,BELLS		;..
;*;	MOVE	T1,.CPSPC##	;Get the stop PC
;*;	MOVEM	T1,CRSHWD##	;Store location 30 for SYSTAT/X
;*;	MOVE	T1,.CPSNM##	;Get stopcode name
;*;	MOVEM	T1,CRSWHY##	;Store in location 24 for ONCE to check
	PJRST	REBOOT##	;Go to COMMON and reload monitor
SUBTTL	STOPCD -- BUGSTP = DEBUG stopcode

BUGSTP:	PUSHJ	P,STCLIM	;Has STOPCD limit been exceeded?
	  JRST	STPSTP		;Yes, output message and reload
	MOVSI	T1,(DF.RDC)	;Want to Reload on Debug Codes?
	TDNE	T1,DEBUGF##
	 JRST	RELOAD		;Yes
	MOVSI	T1,(DF.DDC)	;Want to suppress Dump on Debug Codes?
	TDNN	T1,DEBUGF##	;If flag is off (normal case),
	 PUSHJ	P,CRSDMP	;Take a continuable dump
	POPJ	P,		;Return to DIERS0

SUBTTL	STOPCD -- JOBSTP = JOB stopcode

JOBSTP::PUSHJ	P,STCLIM	;Has STOPCD limit been exceeded?
	  JRST	STPSTP		;Yes, output message and RELOAD
	MOVSI	T1,(DF.RJE)	;Want to Reload on Job Error?
	TDNN	T1,DEBUGF##
	 SKIPE	S		; or is PI in progress?
	  JRST	RELOAD		;Yes, do not continue
	SKIPE	.CPJOB		;Can't stop the null job
	SKIPE	.CPISF##	;Can't stop a job if In Scheduler Flag is set
	 JRST	RELOAD
	MOVSI	T1,(DF.DJE)	;Want to suppress Dump on Job Errors?
	TDNN	T1,DEBUGF##	;If flag is off (normal case),
	 PUSHJ	P,CRSDMP	;Go take a continuable dump
	PUSHJ	P,INLMES##
	 ASCIZ /[Aborting job]
/
	PUSHJ	P,GIVLOK##	;Give back locks this CPU owns
	MOVEI	T1,STPJOB	;Routine to kill off job (after PI reenabled)
	MOVEM	T1,.CPCPC##	;Store as continue PC
	POPJ	P,		;Return to DIERS0

;This routine will be called for JOB stopcode after interrupts are re-enabled.
;Here to stop an ill fated user.

STPJOB::MOVE	J,.CPJOB	;Job number
	JRST	ERRMED		;Output "Monitor Error Detected" and halt job
SUBTTL	STOPCD -- WHATJB and WHATUU
;Routine to type user name and store info in .GTSYS (GETTAB table 51)
;Call with job number in J, and nonzero in S if at interrupt level

;Frame 2  TTY12  SMITHJOSEPH[3,431116](TYMCOM-P034[377777,377777])
;Running (FTSYS)FILDDT[1,315372]
; UUO is 043300,,000014 at exec PC 123456
;MUUO is 047000,,777777 at user PC 000141

WHATJB:	SKIPLE	J		;Check job number
	CAILE	J,JOBMAX##
	 JRST	WHATUU		;Output failing UUO for S..EUE with null job
	MOVEM	J,%SYSJN##	;Store job number in GETTAB table 51
	MOVEM	J,.CPSJN##
	HRRZ	T1,TTYTAB##(J)	;Get pointer to DDB (LH of TTYTAB has flags)
	MOVE	T1,(T1)		;Get name of controlling terminal
	MOVEM	T1,%SYSTN##
	MOVEM	T1,.CPSTN##
	MOVE	T1,JBTAUN##(J)	;Get user's logged-in PPN
	MOVEM	T1,%SYSPP##
	MOVEM	T1,.CPSPP##
	PUSHJ	P,PJOBX##	;Output job, TTY, username, PPN, crlf
	MOVE	T1,JBTFPN##(J)	;Program PPN
	MOVEM	T1,%SYSPD##
	MOVEM	T1,.CPSPD##
	MOVE	T2,JBTPRG##(J)	;Program name
	MOVEM	T2,%SYSPN##
	MOVEM	T2,.CPSPN##
	PUSHJ	P,ERRPRG	;Output program name
	JUMPN	S,CPOPJ##	;No UUO if at interrupt level
	PFALL	WHATUU		;Else fall into WHATUU and return

;Routine to output UUO and PC of UUO.  Example:
;UUO is 043300,,000014 at exec PC 123456 called from MUUO at user PC 000331

WHATUU::MOVE	T1,%UPT+UPTMUU	;Most recent UUO or illegal instruction
	MOVEM	T1,%SYSUU##
	MOVEM	T1,.CPSUU##
	MOVE	T2,%UPT+UPTMUP	;Get PC of UUO or illegal instruction
	SUBI	T2,1		;PC was incremented as part of the trap
	MOVEM	T2,%SYSUP##
	MOVEM	T2,.CPSUP##
	PUSHJ	P,INLMES##
	 ASCIZ / UUO is /
	MOVE	T1,.CPSUU##	;UUO or instruction causing Ill Mem Ref
	PUSHJ	P,HWDPNT	;Print as octal halfwords
	MOVE	T2,.CPSUP##
	PUSHJ	P,PCP		;" at exec PC" or " at user PC"
	MOVE	T2,%UPT+UPTPDL	;Get user's top-level return PC
	CAME	T2,%UPT+UPTMUP	;Same?
	SKIPN	%UPT+UPTUUO##	;And top level MUUO not zero?
	 PJRST	CRLF##		;Yes
	PUSHJ	P,INLMES##	;No, Monitor did MUUO on behalf of user
	ASCIZ /
MUUO is /
	MOVE	T1,%UPT+UPTUUO##;Get user-mode MUUO instruction
	PUSHJ	P,HWDPNT	;Print as octal halfwords
	MOVE	T2,%UPT+UPTPDL	;Get user-mode PC saved at top of stack
	SUBI	T2,1		;Backup PC to point to MUUO (not return PC)
	PUSHJ	P,PCP		;" at user PC 000000"
	PJRST	CRLF
SUBTTL	STOPCD -- CHKDDB and STCLIM

;ROUTINE TO CHECK A DDB ADDRESS BEFORE USING IT TO TYPE FILE INFORMATION
;DURING DIE PROCESSING.
;CALL:	MOVEI	F,ADDRESS
;	PUSHJ	P,CHKDDB
;	  RETURN HERE IF ADDRESS IS ILLEGAL FOR SOME REASON
;	RETURN HERE IF ADDRESS IS OK

CHKDDB:	CAMGE	F,SYSSIZ##	;LARGER THAN THE LOW SEG?
	CAIG	F,1000		;OR TOO SMALL?
	 CAIA			;YES, MAY STILL BE IN FUNNY SPACE
	  JRST	CPOPJ1##	;GIVE SKIP RETURN
; TYMCOM-X does not put DDBs in funny space
;*;	CAIL	F,.FPMC		;LEGAL ADDRESS IN
;*;	CAIL	F,.FPMC+NWMCP	;  FUNNY SPACE?
;*;	 POPJ	P,		;NO, BAD DDB ADDRESS
	MAP	T1,(F)		;MAP THE ADDRESS
	PUSHJ	P,FLTCHK##	;WILL REFERENCE FAULT?
	  POPJ	P,		;YES, BAD ADDRESS
; TYMCOM-X does not have DEFSFD, use DEVATB instead
	MAP	T1,DEVATB##(F)	;LAST ADDRESS IN DDB REFERENCED BY PRTDDB
	PJRST	FLTCHK##	;CHECK ADDRESS AND RETURN

;ROUTINE TO SEE IF THIS STOPCD HAS CAUSED US TO EXCEED ON OF THE
;STOPCDS-PER-UNIT-TIME LIMITS.
;CALL:	PUSHJ	P,STCLIM
;	  RETURN HERE IF A LIMIT HAS BEEN EXCEEDED
;	  RETURN HERE IF NOT
; SCLTAB::XWD	^D60,  LIM1MS	;Period = 1 minute,  Limit = LIM1MS = 2
;	  XWD	^D480, LIM8MS	;Period = 8 minutes, Limit = LIM8MS = 4
;	  XWD	^D3600,LIM1HS	;Period = 1 hour,    Limit = LIM1HS = 8
; SCLTBL=3 (SCLTAB and SCCTAB defined in COMMON)

STCLIM:	SKIPGE	DEBUGF##	;IF DEBUGGING
	 JRST	CPOPJ1##	;THEN NO STOPCD LIMITS
	MOVSI	T1,-SCCTBL##	;BUILD AOBJN POINTER TO TABLE
STCLI1:	AOS	T2,SCCTAB##(T1)	;INCREMENT NEXT COUNT
	HRRZ	T3,SCLTAB##(T1)	;GET THE LIMIT
	CAIL	T2,(T3)		;EXCEED THE LIMIT?
	 POPJ	P,		;YES, GIVE ERROR RETURN
	AOBJN	T1,STCLI1	;NO, LOOP FOR NEXT
XP .SLDSC,1	;Sleep request to Decrement Stopcode Count
	HLRZ	T1,SCLTAB##+0	;GET PERIOD OF LOWEST ENTRY IN TABLE (60 SECONDS)
	HRLI	T1,(1B0+<.SLDSC>B6+0B18) ;Flag for seconds, call DECSCC, at 0
	IDPB	T1,CLOCK##	;Set to call DECSCC 60 seconds from now
	JRST	CPOPJ1##	;GIVE SKIP RETURN


;ROUTINE TO DECREMENT A STOPCD COUNT AND RESUBMIT A CLOCK QUEUE REQUEST
;FOR THE NEXT HIGHER COUNT, IF ONE EXISTS.
;CALL:	MOVEI	T1,INDEX INTO SCCTAB
;	PUSHJ	P,DECSCC
;	  RETURN HERE ALWAYS

;Called from CLOCK1 with data in T1
DECSCC::SOSGE	SCCTAB##(T1)	;DECREMENT COUNT
	 SETZM	SCCTAB##(T1)	;LEAVE ZERO IF IT WAS ZERO
	AOS	T1		;INCREMENT LEVEL
	CAIL	T1,SCCTBL##	;DONE THE LAST LEVEL?
	 POPJ	P,		;YES, RETURN NOW
	MOVE	T2,SCLTAB##(T1)	;GET WORD WITH NEW PERIOD
	SUB	T2,SCLTAB##-1(T1) ;SUBTRACT OLD PERIOD
	HLRZS	T2		;KEEP JUST DIFFERENCE IN SECONDS
	HRLI	T2,(1B0+<.SLDSC>B6) ;Flag for seconds, call DECSCC,
	DPB	T1,[POINT 7,T2,18]  ;Put current level in job number field
	SYSPIF			;TELL SLAVE CPU TO NOT INTERRUPT THE IDPB PAIR
	IDPB	T2,CLOCK##	;STORE REQUEST
	PJRST	ONPOPJ##	;RETURN INTERLOCK AND POPJ
SUBTTL	STOPCD -- Common typeout routines (4th arg of STOPCD macro)

;ROUTINES FOR STOPCODE MACRO TYPE OUT
;ALL ROUTINES WILL HAVE THE FORM DIE???::
;WHERE ??? ARE 3 LETTERS DESCRIPTIVE OF THE ROUTINE
;AN AUTOMATIC CARRIAGE RETURN/LINE FEED IS DONE BY CALLER


;ROUTINE TO TYPE OUT UNINAM(U) DURING STOPCD
DIEUNI::PUSHJ	P,INLMES##	;START THE OUTPUT
	ASCIZ	/Unit = /
	MOVE	T2,.CPACA##	;GET ADDRESS OF AC SET
	MOVE	T2,U(T2)	;GET "U" AT CRASH
	MOVE	T2,UNINAM##(T2)	;GET THE NAME
	PJRST	PRNAME		;PRINT OUT SIXBIT AND RETURN

; ROUTINE TO TYPE OUT STRNAM(P2) DURING A STOPCODE
DIESTR::PUSHJ	P,INLMES##	;TYPE INTRODUCTION
	ASCIZ	/Structure = /
	MOVE	T2,STRNAM##(P2)	;GET STR NAME
	PJRST	PRNAME		;TYPE IT AND RETURN

;Here from FILRIB when there are too many disk errors.
;This replaces STOPCD(NO) = <manual boots>+<manual once>+<full DSKCLN>

DSKDIE::MOVE	T1,.CPSPC##	;Store PC of STOPCD(NO)
	MOVEM	T1,NOCRS##	; in NOCRS so COMMON won't tell BOOTS "/D"
	PJSP	T1,CONMES##	;Output message and POPJ
	 ASCIZ /Disk is unsafe - requesting manual BOOTS with no dump.
***** Need to do a FULL DSKCLN when the disk is fixed. *****
/				;POPJ back to DIE
;Routine to type out additional data during BUGINF
;Called via:
;	JSP	T1,BGCTYP
;	SIXBIT /NAME/
;	EXP    ADDR
;	SIXBIT /NAME2/
;	EXP    ADDR2
;	EXP	0       ;Returns by POPJ at end

BGCTYP::MOVE	P1,T1		;Copy pointer to data
BUGTY1:	MAP	T1,(P1)		;Make sure location is accessible
	PUSHJ	P,FLTCHK##	;Make sure it won't fault
	  POPJ	P,		;Will fault, give up
	SKIPN	(P1)		;Hit zero at end?
	 POPJ	P,		;Yes
	TLO	P1,400000	;Remember that something was typed
	PUSHJ	P,INLMES##	;Space entries apart
	 ASCIZ /   /
	MOVE	T2,(P1)		;Get item name
	PUSHJ	P,PRNAME
	PUSHJ	P,INLMES##
	 ASCIZ /: /
	MAP	T1,1(P1)	;Make sure this won't fault
	PUSHJ	P,FLTCHK##
	  POPJ	P,		;Abort instead of faulting
	MOVE	T2,1(P1)	;Get the address of the item
	MAP	T1,(T2)		;Check if it is legal
	PUSHJ	P,FLTCHK##
	  POPJ	P,
	MOVE	T1,1(P1)	;Get address
	MOVE	T2,.CPACA##	;Address of saved ACs
	ADD	T2,T1		;Offset into the AC save block
	CAIG	T1,17		;Item in the crash ACs?
	 SKIPA	T1,(T2)		;Yes, fetch from proper location
	  MOVE	T1,(T1)		;No, get directly
	PUSHJ	P,PRT22A	;Print as halfwords
	ADDI	P1,1		;Increment for doublewords
	AOJA	P1,BUGTY1	;Loop until 0 is found
;Routines to output the contents of one accumulator on the CTY

PRTT1::	PUSH	P,T1		;Routine to output the contents of T1
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of T1 = /
PRTT0:	POP	P,T1		;Get saved value
	PUSHJ	P,HWDPNT	;Print as halfwords
	PJRST	CRLF##

PRTT2::	PUSH	P,T2		;Routine to output the contents of T2
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of T2 = /
	PJRST	PRTT0

PRTT3::	PUSH	P,T3		;Routine to output the contents of T3
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of T3 = /
	PJRST	PRTT0

PRTT4::	PUSH	P,T4		;Routine to output the contents of T4
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of T4 = /
	PJRST	PRTT0

PRTJOB::PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Previous JOB = /
	MOVE	T1,JOB
	PUSHJ	P,PRTDEC
	PUSHJ	P,INLMES##
	 ASCIZ /, accumulator J = /
	PJRST	PJOB##		;Type J as decimal and CRLF

PRTP1::	PUSH	P,P1		;Routine to output the contents of P1
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of P1 = /
	PJRST	PRTT0

PRTPGU::PUSH	P,U		;Routine to output the contents of U and PG
	PUSH	P,PG
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of PG = /
	POP	P,T1		;Get saved value
	PUSHJ	P,HWDPNT	;Print as halfwords
	PUSHJ	P,INLMES##	;Then next part
	 ASCIZ /, Unit # (U) = /
	PJRST	PRTT0		;Restore U, and fall into common code

;ROUTINE TO CALL BUGDMP TO TAKE A CONTINUABLE STOPCD DUMP
;AND THEN SET DF.RQC IN DEBUGF WHICH WILL CAUSE CRSCPY
;TO BE CALLED BY THE BOOT CPU AT THE NEXT TICK.  WE
;CAN'T CALL CRSCPY DIRECTLY BECAUSE THE SCNSER INTERLOCK
;MAY NOT BE FREE.
;ENTER AT FRCCPY TO JUST SET DF.RQC (FROM ADDSDL)
;CALL:	PUSHJ	P,CRSDMP
;	RETURN HERE ALWAYS

CRSDMP:	PUSHJ	P,BUGDMP##	;Call MONBTS to take a dump
	  POPJ	P,		;Couldn't
	PFALL	FRCCPY		;Set flag to run CRSCPY

;Routine to set flag to run CRSCPY (called if BUGDMP is successful)
;Also called from ONCE to run CRSCPY when system starts up

FRCCPY::MOVSI	T1,(DF.RQC)	;If the CRSCPY request has not been
	MOVSI	T2,(DF.DCC)	; disabled via the /NOCOPY startup
	TDNN	T2,DEBUGF##	; switch, then set DF.RQC in DEBUGF to
	 IORM	T1,DEBUGF##	; cause the CRSCPY routine to be called
	ANDCAM	T2,DEBUGF##	; on the next clock tick
	POPJ	P,		;End of FRCCPY/CRSDMP

;Routine to start up the CRASH-COPY program to copy SYS:CRASH.EXE
;Called from once-a-tick code if DF.RQC was set in DEBUGF

;CRSCPY::SKIPGE	DEBUGF##	;Don't do anything if debugging
;*;	 POPJ	P,
;*;	PUSHJ	P,FRCSET##	;Set up to store characters in FRCLIN's input
;*;	MOVE	T2,CCPNAM##	;Get SIXBIT name of program to run
;*;	PUSHJ	P,PRNAME	;Store in FRCLIN's input bufer
;*;	PJRST	CRLF##		;Add CRLF and return

SUBTTL	End of STOPCD processor (see REBOOT:: and .CPSLF in COMMON)
;-------------------------------------------------------------------------------
SUBTTL	ROUTINE TO PRINT MUUO PC AND STOP JOB
;IF IN USER MODE PC WILL PRINT AS "AT USER LOC XXX"
;IF IN EXEC MODE "AT EXEC LOC XXX; EXEC CALLED FORM EXEC/USER/ LOC YYY

UUOPCP:	MOVE T2,%UPT+UPTPDL	;PC of user's MUUO is at top of PDL
	SUBI	T2,1		;POINT TO THE ACTUAL UUO
	PUSHJ	P,PCP		;PRINT " AT EXEC XXX" OR " AT USER "
	TLNN	T2,PC.USR	;PC IN USER MODE?
	PJRST	ERRSCU		;NO, TELL HIM WHERE UUO IS
;	PJRST	TCLTTY		;CLEAR TTY INPUT BUFFER AND PUT IT IN MONITOR MODE

;ROUTINE TO CLEAR TTY INPUT BUFFER AND PUT IT IN MONITOR MODE.

TCLTTY:	PUSHJ	P,TTYFND	;GET ORIGINAL U AND F FROM C(J)
	JUMPE	U,CPOPJ		;IF NO LINE, FORGET IT.
TCLTT0:	PUSHJ	P,TSETBI	;CLEAR TYPE AHEAD
	PUSHJ	P,PRRSP1	;PRINT WATCH DATA AND CRLF
	PJRST	TTYSTC		;AND PUT TTY IN MONITOR MODE.

;ROUTINE TO RESET U TO JOB'S LDB IF ANY, PRINT WATCH DATA AND PERIOD,
; STOP TERMINAL, BUT DO NOT CLEAR TYPE AHEAD.
; USED BY EXIT AND EXIT 1, IF JOB IS NOT DETACHED. (SO NEVER COME
; IN WITH OPR'S LDB)

TNCTTY:	PUSHJ	P,CRLF
E1STTY:	PUSHJ	P,PRRSP3	;WATCH DATA, CRLF, PERIOD
	PJRST	TTYSTC		;AND PUT TTY IN COMMAND MODE.

;ROUTINE TO HANDLE TTY ON TIME LIMIT EXCEEDED
; IF DETACHED, PUT IT INTO
; TO WAIT. WHEN IT COMES OUT OF WAIT ON ATTACH,
; JOB WILL RESCHEDULE AND PRINT TIME LIMIT EXCEEDED NEXT TIME
; AROUND THRU RSCHED.
;ROUTINE TO STOP TELETYPE FOR TIME LIMIT EXCEEDED.
; ERRFNU MUST BE SET AS THE TTY FINDING ROUTINE.
; MUST ENTER WITH U SETUP TO LINE OR 0, F SETUP TO DDB ADDRESS OF
; TTY OR 0.

EXTERNAL TTYSOW,CIP6,PJBSTS,TTYFNU,TIOWQ,TTYSTC,PRRSP1,PRRSP3

TLETTY:	JUMPN	U,TCLTT0	;IF LDB, DO NORMAL THING.
	JUMPN	F,TLTOW		;NO LDB, IF DDB, PUT FRAME INTO TO WAIT
	POPJ	P,		;NOTHING, JUST RETURN.

;HERE IF NO LINE, PUT INTO IO WAIT IF THERE IS A DDB
TLTOW:	PUSHJ	P,TTYSOW	;SET OUTPUT WAIT IN SCNSER
	MOVSI	S,IOW	;PUT DDB INTO IOW
	IORM	S,DEVIOS(F)
	MOVEI	T1,TIOWQ
	DPB	T1,PJBSTS
	POPJ	P,		;AND RETURN.
;ROUTINE TO STOP JOB, BUT RETURN TO CALLER AND LET HIM GO THRU NORMAL USRXIT
; USED FOR BAD INTERRUPT ADDRESS

EXTERNAL KJSTOP,STOP1,USCHED

BISTOP:	PUSHJ	P,KJSTOP	;STOP THE JOB
	MOVEI	T1,CPOPJ	;RETURN WITH A POPJ FROM CLKTRP
	HRRM	T1,%UPT+UPTMUP	;
	JRST	KTRRET##

;ROUTINE TO STOP JOB CONTINUABLY

HISTOP:	PUSHJ	P,STOP1		;STOP JOB CONTINUABLY.
	PJRST	WSCHED		;AND CALL SCHEDULER. POPJ RETURN TO JRST ERR???

;ROUTINE TO STOP FOR EXIT 1,

E1STOP:	PUSHJ	P,STOP1		;STOP THE JOB (DON'T SET JERR, SO IT COMES BACK)
	JRST	USCHED		;AND CALL THE SCHEDULER.

;ROUTINE CALLED WHEN IT IS DESIRED TO STOP A FRAME AND INTERRUPT
; ITS PARENT OR TRAPHANDLER BUT NOT STORE AN EXIT CODE OR
; INCREMENT EXIT COUNT IN THE TARGET FRAME. USED FOR HALT COMMAND,
; HALT FRMOP.

TRHALT::PUSHJ	P,HLTTRP	;INTERRUPT TRAPHANDLER OR PARENT IF ANY
	  PJRST	STOP1		;WAS TRAPHANDLER OR PARENT
	PJRST	STOP1		;WAS NO TRAPHANDLER OR PARENT.
;ROUTINE TO TYPE A NUMBER AS HALFWORDS SEPARATED BY COMMAS.
;CALL:	MOVE	T1,NUMBER
;	PUSHJ	P,HWDPNT
;	RETURN

HWDPNT::PUSH	P,T1		;SAVE T1 FOR RH
	HLRZS	T1		;KEEP JUST LH
	PUSHJ	P,OCTPNT	;PRINT AS 6 OCTAL DIGITS
	PUSHJ	P,INLMES	;PRINT THE TWO COMMAS
	ASCIZ/,,/		;...
	POP	P,T1		;RESTORE T1 FOR RH
	PJRST	OCTPNT		;PRINT RH AND RETURN

;ROUTINE TO PRINT PC AS:
;1) "EXEC LOC XXX" OR "USER LOC XXX"
;CALL:	MOVE T2,PC TO PRINT(LH=PC FLAGS)
;	PUSHJ P,PCP

XMODE:	ASCIZ / at exec PC /
UMODE:	ASCIZ / at user PC /

PCP::	MOVEI	T1,XMODE	;ASSUME PC IN EXEC MODE
	TLNE	T2,PC.USR	;IS IT?
	MOVEI	T1,UMODE	;NO, USER MODE
	PUSHJ	P,CONMES	;PRINT ONE OR OTHER
	HRRZ	T1,T2		;PRINT RIGHT HALF IN OCTAL
				; FALL INTO OCTPNT

;ROUTINE TO PRINT 6 DIGIT OCTAL NUMBER
;CALL:	MOVEI U,U DATA BLOCK ADDRESS FOR TTY
;	HRR T1, OCTAL NUMBER
;	PUSHJ P,OCTPNT
;	RETURN T2,PRESERVED,T1 DESTROYED

OCTPNT::HRLZ	T1,T1		;MOVE TO LH FOR ROTATING
	TRO	T1,700000	;SETUP AN END FLAG

OCTP1:	ROT	T1,3		;GET NEXT OCTAL DIGIT
	TLNN	T1,777777	;WAS THAT FLAG?
	POPJ	P,		;YES, DO NOT PRINT IT
	PUSH	P,T1		;SAVE T1 OVER I/O ROUTINE
	PUSHJ	P,PRTNUM	;NO, PRINT OCTAL DIGIT
	POP	P,T1		;RESTORE T1
	HRRI	T1,0		;CLEAR RH
	JRST	OCTP1		;GET NEXT OCTAL DIGIT
PRTDIG::IDIVI	T1,12		;DIVIDE BY 10
	HRLM	T2,(P)		;RT ON PD LIST
	JUMPE	T1,.+2		;FINISHED?
	PUSHJ	P,PRTDIG	;NO, CALL S OR F
PRTNMM:	HLRZ	T1,(P)		;YES, GET LAST NUMBER
PRTNUM:	MOVEI	T3,"0"(T1)	;CONVERT TO ASCII
	PJRST	COMTYO##	;AND TYPE IT OUT

;RECURSIVE OCTAL PRINT ROUTINE
;CALL:	MOVE T1,<OCTAL NUMBER>
	PUSHJ P,PRTOCT

PRTDI8::
PRTOCT::IDIVI	T1,10		;DIVIDE BY 8
	HRLM	T2,(P)		;PUT ON STACK
	JUMPE	T1,PRTNMM	;FINISHED?
	PUSHJ	P,PRTDI8	;NO - LOOP
	PJRST	PRTNMM		;OUTPUT

;SUBROUTINE TO PRINT 22 BIT OCTAL ADDRESS
;CALL:	MOVE	T1,22 BIT ADDRESS
;	PUSHJ	P,PRT22A
;	ALWAYS RETURN

PRT22A::PUSH	P,T1		;SAVE 22 BIT ADDRESS
	HLRZ	T1,(P)		;GET HIGH ORDER HALF
	JUMPE	T1,PRT22B	;IS IT 0 (USUALLY EXCEPT BIG SYSTEMS)
	PUSHJ	P,PRTDI8	;NO, PRINT AS LEADING 0 SUPPRESSED OCTAL
	PUSHJ	P,INLMES	;THEN TWO COMMAS
	 ASCIZ	/,,/
PRT22B:	POP	P,T1		;GET LOW ORDER HALF
	PJRST	OCTPNT		;PRINT AS NON ZERO SUPPRESSED OCTAL (RH ONLY)
;ROUTINE TO PRINT "DEVICE XXX"
;	MOVEI F,<ADDRESS OF DEVICE NAME TO PRINT>
;	PUSHJ P,ERNAM

ERNAM::	PUSHJ	P,INLMES
	 ASCIZ /device /
	SKIPN	F	;IF NO F SETUP,
	 SKIPA	T2,[SIXBIT/??????/] ;THEN SAY DON'T KNOW
	MOVE	T2,DEVNAM(F)	;NO, GET DEVICE NAME
	PFALL	PRNAME

;Routine to output sixbit name
;CALL	MOVE U,ADDRESS OF LDB
;	MOVE T2,NAME
;	PUSHJ P,PRNAME

PRNAME::JUMPE	T2,CPOPJ##	;Stop when no more (no trailing blanks)
	MOVEI	T1,0
	LSHC	T1,6		;SHIFT IN NEXT CHAR.
	MOVEI	T3,40(T1)	;CONVERT SIXBIT TO ASCII
	PUSHJ	P,COMTYO	;OUTPUT CHARACTER
	JRST	PRNAME

;Routine to output sixbit name, ignoring leading blanks

PR6BIT::JUMPE	T2,PRSPC##	;Print a single space if whole word is blank
	TLNE	T2,770000	;Left justified?
	 JRST	PRNAME		;Yes
	LSH	T2,6		;No, make it
	JRST	PR6BIT

;Routine to output name in full (including leading and trailing blanks)

PRNAMF::MOVE	T1,[POINT 6,T2]	;Print full name in T2
PRNAM1:	ILDB	T3,T1		;Get char
	ADDI	T3,40		;Convert to ASCII
	PUSHJ	P,COMTYO
	TLNE	T1,770000	;Ran out of byte pointer?
	 JRST	PRNAM1		;No, do all 6
	POPJ	P,

;ROUTINE TO PRINT FILE NAME AND EXTENSION IF NONZERO.
; P3/ FILE NAME   ; P4/ ZERO OR EXTENSTION TO PRINT

ERFNAM:	MOVE	T2,P3		;FIRST PRINT FILE NAME
	PUSHJ	P,PRNAME
	JUMPE	P4,CPOPJ	;IF NO EXTENSTION, JUST RETURN
	PUSHJ	P,PRPER##	;PRINT A DOT
	MOVE	T2,P4		;GET EXTENSTION
	PJRST	PRNAME		;PRINT EXTENSTION AND RETURN.

;ROUTINE TO PRINT OUT CRLF AND A QUESTION MARK FOR SEGCON ERRORS.

CRLFQ:	PJSP	T1,CONMES	;PRINT ? AND CRLF
	ASCIZ/
?/

	$END	(ECN)		;End of ERRCON (ECNLIT: ECNEND:)
     ;@D!