	|                       |                       |
	|                       .                       |
	|                                               |
	+-----------------------+-----------------------+


	COR - WORD OFFSETS FOR VARIOUS CORE BLOCKS.

	+-----------------------+-----------------------+
     0	| CMBNAM - BLOCK HEADER ( DRB, FNB )            |  CMBNAM
	+-----------------------+-----------------------+
     1	| CMBLNK - LINK TO NEXT |                       |  CMBLNK
	+-----------------------+-----------------------+
     2	| CMBDWN - DOWN POINTER |                       |  CMBDWN
	+-----------------------+-----------------------+
	|                       .                       |
	|                       .                       |
	|                       .                       |
	+-----------------------+-----------------------+

	CMBSIZ==ATBSPT+1  (13)  ENOUGH ROOM FOR ATB BLOCK


	ATB ( ACCESS TABLE BLOCK ) DEFINITIONS

    THERE IS ONE ATB FOR EACH ACTUAL FILE ON THE DISK THAT IS
    IN USE. THE 'FILE' THE ATB CORRESPONDS TO MAY NOT APPEAR
    IN THE DIRECTORY, IT MAY HAVE BEEN SUPERCEDED OR NOT YET
    ENTERED. IN THIS CASE, THE ATB WILL BE IN THE MARKED FOR
    DELETION, OR IN THE CREATE STATE. THE FOLLOWING ARE THE ATB
    STATES

	CREATE    SUPERCEDE    READ
	UPDATE    RENAME       MARKED FOR DELETION.

	+-----------------------+-----------------------+
     0	|  ATBRIB  -  RETRIEVAL PTR FOR THE FILE'S RIB  |  ATBRIB
	+-----------------------+-----------------------+
     1	|  ATBLNK - NXT ATB PTR |  ATBFNB - PTR TO NMB  |  ATBLNK,,ATBFNB
	+-----------------------+------------------------+
     2	|  ATBPGS - BITS 0-26         | ATBBLK | ATBWRD |  ATBSIZ
	|                             | 27-28  | 29-35  |
	+-----------------------+-----------------------+
     3	| ATBPRV | ATBMOD | ATBCTM  |      ATBCDT       |  ATBPVW
	| 0 - 8  | 9 - 12 | 13 - 23 |      24 - 35      |
	+-----------------------+-----------------------+
     4	|ATBUF1| ATBUF2 | ATBCSC|   ATBLIC  18 - 35     |  ATBLCW
	| 0-3  | 4 - 11 | 12-17 |   FILE LICENSE BITS   | (RIBCNA)
	+-----------------------+-----------------------+
     5	|ATBXCD| ATBADT  4 - 17 |   ATBLOK  18 - 35     |  ATBMSC
	| 2-3  |  ACCESS DATE   | 1ST DDB / ATOMIC LOCK |
	+-----------------------+-----------------------+
     6	|  ATBDOR  -  DORMANT POINTER                   |  ATBDOR
	+-----------------------+-----------------------+
     7	|0|FREE 1-8| ATBALP - NUMBER OF ALLOCATED PAGES |  ATBALP
	+-----------------------+-----------------------+
    10	|  ATBPID  -  FILE PROCESSOR ID                 |  ATBPID
	+-----------------------+-----------------------+
    11	|ATB|  ATBUMC  1 - 17   |   18-27 | ATBCNT 28-35|  ATBSTS
	|DUM|  # MAP SLOTS+SPTS | MXNDURSC|  # READERS  |
	+-----------------------+-----------------------+
    12	| PTR TO 1ST SPT TABLE  |  MAXIMUM WRITE COUNT  |  ATBSPT,,ATBMWC
	+-----------------------+-----------------------+



    THERE MAY BE ANY NUMBER OF ATB'S MARKED FOR DELETETION FOR A FILE NAME.
    THESE ATBS CANNOT HAVE ANY "WRITE" FIELDS ON (UPD, CRE, SUP, MXU)
    THE REMAINING ATBS FOR A GIVEN FILE NAME CAN ONLY OCCUR IN THE
    FOLLOWING CONFIGURATIONS:

    1) EXACTLY ONE SUPERCEDE ATB, WHOSE UMC,CNT,MWC FIELDS MAY
       BE NON-ZERO, PLUS A POSSIBLE ATB WHICH HAS ALL "WRITE"
       FIELDS AND BITS ZERO, AND ATBCNT AND/OR ATBUMC NON-ZERO.
       SOMETIMES THIS SUPERCEDE ATB HAS ATPUPD
       ON INSTEAD OF ATPSUP SO THAT USERS WHO LOOKUP THE
       FILE WHILE THE NEW VERSION IS BEING CLOSED WILL GET
       THE NEW VERSION.  THUS, THE SUPERCEDE ATB CAN ONLY HAVE
       ATBCNT NON-ZERO AFTER ATPUPD IS SET. ATBUMC AND MWC
       CAN BE NON-ZERO DUE TO EITHER THE SUPERCEDER OR TO LOOKUPS
       DONE AFTER ATPUPD IS SET.

    2) EXACLY ONE ATB WITH ATPUPD OR ATPMXU ON (SINGLE OR SIMULTANEOUS
       UPDATE).  ATBCNT, ATBMWC, AND ATBUMC MAY BE INCREMENTED.

    3) EXACTLY ONE ATB WITH ATPCRE ON. ATMUMC MAY BE NON-ZERO,
       BUT ONLY THE CREATOR HAS ANYTHING MAPPED FROM THE FILE
       BEING CREATED. ATBCNT MUST BE ZERO, SINCE NO CHANNEL
       INCLUDING THE OWNER CAN HAVE A FILE BEING CREATED
       OPEN FOR READ OR UPDATE.

    4) EXACLY ONE ATB WITH ATPREN ON. ATBUMC AND ATBCNT MAY
       BE NON-ZERO, REPRESENTING READERS OF THE FILE WHEN
       THE RENAME IS BEING DONE, BUT ATPMXU, ATPCRE, ATPSUP,
       AND ATPUPD MUST BE ZERO, I.E. NO WRITERS OF THE FILE
       CAN EXIST.


ATBLCW BITS:

 ATPDMP==(1B4)	;IF ON SAYS FILE DUMPED SINCE LAST CAHNGE
 ATPUFE==(1B5)	;A BIT SO AN ERROR GETS RECORDED IN THE UFD
		;NOTE THAT ATPUFE MUST=RIPUFE.
 ATPPID==(1B6)	;FOR UFDS, MEANS THIS UFD SHOULD HAVE SPECIAL PID
		; STORAGE ACCOUNTING (NOT USED BY MONITOR).
		;FOR FILES, MEANS THIS FILE HAS A NON-ZERO PID
		; (KEPT BY THE MONITOR).
 ATPALC==(1B7)	;BIT THAT SAYS ALLOCATION HAS CHANGED ON THIS FILE.
		; BIT APPEARS IN UFD SO DSKCLN CAN SCAN IN FAST MOE
		; AND ONLY OR IN THE BITS IN THE SATS FOR FILES WITH
		; THIS BIT ON.

ATBSTS BITS:

C ATPCRE==000400	;CREATE
S ATPSUP==001000	;SUPERCEDE
R ATPREN==002000	;RENAME
U ATPUPD==004000	;SINGLE UPDATE (ALSO USED TO LOCK THE FILE)
D ATPDEL==010000	;MARKED FOR DELETEION
N ATPNDL==020000	;DO NOT ALLOW DELETE, RENAME, SUPERCEDE, ETC
X ATPDIR==040000	;THIS IS A DIRECTORY
M ATPMXU==100000	;THE MAX WRITE COUNT IS UP.
			; (NO CHECK ANOTHER WORD TO SEE IF ATB IS UNUSED)

	FNB - THE FILE NAME BLOCK

    THERE IS ONE OF THESE FOR EACH FILE IN USE OR DORMANT.  THERE
    MAY BE SEVERAL ATB'S FOR EACH FNB IF SOME ARE MARKED FOR DELETION
    OR THERE IS A SUPERCEDE AND A READ BLOCK.

	+-----------------------+-----------------------+
     0	|  FNBNAM  -  FILE NAME IN SIXBIT               |  FNBNAM
	+-----------------------+-----------------------+
     1	| FNBLNK - NEXT FNB PTR | FNBEXT - SIXBIT EXT   |  FNBLNK,,FNBEXT
	+-----------------------+-----------------------+
     2	| FNBATB - 1ST ATB PTR  | FNBDRB - DRB POINTER  |  FNBATB,,FNBDRB
	+-----------------------+-----------------------+
     3	|  FNBRIB  -  RETRIEVAL POINTER TO FILE RIB     |  FNBRIB
	+-----------------------+-----------------------+
     4	|  FNBAPD  -  APPEND WORD (UPDATE APPEND MODE)  |  FNBAPD
	+-----------------------+-----------------------+
     5	|XL FNBSTS | FNBUPF - UFD PAGE FOR FILE (10-35) |  FNBSTS
	+-----------------------+-----------------------+
     6	|                       | FNBDBL - READERS DDBS |  0,,FNBDBL
	+-----------------------+-----------------------+
     7	|  FNBUPD  -  COUNT OF UPDATERS FOR THIS FILE   |  FNBUPD
	+-----------------------+-----------------------+
    10	|  FNBALT  -  PCB DIRTY MONITOR CLOCK FOR FILE  |  FNBALT
	+-----------------------+-----------------------+


FNBSTS BITS:
 X FNPNX==400000	;DOES NOT EXIST BIT
 L FNPLOK==200000	;LOCKED, USED SO FNB NOT TAKEN TO MAKE ATB


	DRB - THE DIRECTORY BLOCK. ONE PER USER NAME WITH FILES OPEN.

	+-----------------------+-----------------------+
     0	|  DRBNAM  -  NAME OF DIRECTORY  ( PPN )        |  DRBNAM
	+-----------------------+-----------------------+
     1	| DRBLNK - NEXT DRB PTR |LIX| DRBCNT - # USERS  |  DRBLNK,,STS/CNT
	+-----------------------+-----------------------+
     2	| DRBFNB - FNB POINTER  |  DRBSLT   |  DRBPRV   |  DRBFNB,,SLT/PRV
	+-----------------------+-----------------------+
     3	|  DRBALC  -  ALLOCATION LEFT IN THIS DIR       |  DRBALC
	+-----------------------+-----------------------+
     4	|  DRBMXA  -  MAXIMUM ALLOCATION EVER           |  DRBMXA
	+-----------------------+-----------------------+
     5	|  DRBRIB  -  RETRIEVAL POINTER TO RIB          |  DRBRIB
	+-----------------------+-----------------------+
     6	|  DRBUNM  -  SIXBIT USERNAME (IF KNOWN ELSE 0) |  DRBUNM
	+-----------------------+-----------------------+
     7	|  DRBUN1  -  SIXBIT USERNAME (SECOND HALF)     |
	+-----------------------+-----------------------+


DRBSTS - STATUS BITS IN HIGH 3 BITS OF DRBCNT
 DRPLOG==400000	;USER LOGGED IN BIT, KEEP DRB AROUND
 DRPLOK==200000	;INTERLOCK BIT
 DRPNX==100000	;NX BIT



	SPT (SHARED PAGE TABLE) DEFINITIONS

    THE SHARED PAGE TABLE CONSISTS OF ONE OR MORE SPT SECTIONS,
    THE FIRST OF WHICH IS POINTED TO BY AN ATB THROUGH
    ATBSPT.  EACH SECTION CONSISTS OF A HEADER, CONTAINING
    FORWARD AND BACKWARD LINKS TO OTHER SPT SECTIONS, AND
    A BACK LINK TO THE ORIGINATING ATB. ALSO CONTAINED
    IN THE HEADER IS A COUNT OF FREE ENTRY SLOTS IN THE SPT
    SECTION, FOR FAST INSERTION OF NEW ENTRIES IN THE
    SPT.

    THE SPT ENTRIES THEMSELVES ARE FOUND AFTER THE HEADER. EACH
    ENTRY CONSISTS OF TWO WORDS. ENTRY WORDS OF THE SAME TYPE
    APPEAR CONSECUTIVELY, RATHER THAN HAVING EACH TWO WORD ENTRY
    CONTIGUOUS IN MEMORY, TO MAKE LOOPS SHORTER. DATA IN THE
    ENTRIES CAN BE ACCESSED EITHER DIRECTLY OR THROUGH THE BYTE
    POINTERS PROVIDED.

    SPTS DO NOT COME FROM FILSER CORE. THEY COME FROM DDB FREE CORE.

	+-----------------------+-----------------------+
     0	| SPTBLN - PREV SPT PTR |                |SPTNFE|  SPTBEG
	|  (ATB+ATBSPT-SPTLNK)  |                |32-35 |  SPTBLN,,SPTNFE
	+-----------------------+-----------------------+
     1	| SPTLNK - NEXT SPT PTR | SPTATB - PTR TO ATB   |  SPTLNK,,SPTATB
	+-----------------------+-----------------------+
     2	| SPTEN1 - FIRST ENTRY  | SPTUSC - USE COUNT    |
	+-----------------------+-----------------------+

;SPT ENTRY DEFINITIONS, RELATIVE TO SPT ENTRY ADDRESS.
; FIRST SPT ENTRY ADDRESS IS SPT SECTION BASE ADDRESS
; PLUS SPTEN1.

 SPTUSC (18-35)	;USE COUNT. RIGHT JUSTIFIED SO CAN AOS AND SOS
 SPTVIR (0)	;WORD WITH VIRGIN BIT IN IT
 SPPVIR==400000	;ITS THE SIGN BIT. CAN DO SKIPL SPTVIR(T1)

 SPTPNO (0-35)	;THE NEXT SPTNME WORDS ARE THE DISK PAGE NUMBER
		; ALL BY ITSELF FOR QUICK COMPARES IN SRCSPT.

    SEE COMMOD.MAC PAGES 10-12 FOR MORE INFO


	DDB - DEVICE DATA BLOCK (ONE FOR EACH ACTIVE SOFTWARE USER CHANNEL)

	+-----------------------+-----------------------+
     0	| DEVNAM - SIXBIT NAME OF DEVICE                |  DEVNAM
	+-----------------------+-----------------------+
     1	| HUNG TIME COUNT       | BUFFER SIZE           |  DEVCHR
	+-----------------------+-----------------------+
     2	| MONITOR IO STATUS     | USER IO STATUS        |  DEVIOS
	+-----------------------+-----------------------+
     3	| LINK TO NEXT DDB      | DISPATCH TABLE ADDR   |  DEVSER
	+-----------------------+-----------------------+
     4	| CHARACTERISTICS       | DEVICE MODE INFO      |  DEVMOD
	+-----------------------+-----------------------+
     5	| DEVLOG - SIXBIT LOGICAL NAME                  |  DEVLOG
	+-----------------------+-----------------------+
     6	| OUTPUT BUFFER HEADER  | INPUT BUFFER HEADER   |  DEVBUF
	+-----------------------+-----------------------+
     7	|           0B13        | USER INPUT BUFFER PTR |  DEVIAD
	+-----------------------+-----------------------+
    10	|           0B13 <R>B17 | USER OUTPUT BUFFER PTR|  DEVOAD
	+-----------------------+-----------------------+
    11	|(2)CLASS(8)0(4)IO BLKS |                       |  DEVCLS
	+-----------------------+-----------------------+
    12	|  DEVSTS  -  WORD FOR DEVICE CONI              |  DEVSTS
	+-----------------------+-----------------------+
    13	|  DEVBLK - OBSOLETE - USED FOR SPARE RIB INFO  |  DEVBLK / DEVABC
	+-----------------------+-----------------------+
    14	|  OBSOLETE             |                       |  DEVBWC
	+-----------------------+-----------------------+
    15	|  DEVFIL - SIXBIT LAST FILE NAME, LOOKUP/ENTER |  DEVFIL
	+-----------------------+-----------------------+
    16	|  DEVEXT - SIXBIT EXT  | DEVSUP - 0/STR, U-DDB |  DEVEXT,,DEVSUP
	+-----------------------+-----------------------+
    17	|  DEVPPN - LAST PPN (NOT ARG TO FNDFIL)        |  DEVPPN
	+-----------------------+-----------------------+
    20	|  DEVPOS - BLOCK POSITION IN FILE / DEB AID    |  DEVPOS / DEVREL
	+-----------------------+-----------------------+
    21	|           0           | OFFSET TO RETREVAL PTR|  DEVRET
	+-----------------------+-----------------------+
    22	|  DEVLOK - USED BY RIB LOCKING ROUTINES        |  DEVLOK
	+-----------------------+-----------------------+
    23	|  DEV1UN - UNIT DB ADDR (OR 0 IF STR INITTED)  |  DEV1UN
	+-----------------------+-----------------------+
    24	|  1ST RET PTR / -1  IF NO RET PTRS IN DDB      |  DEVFLO
	+-----------------------+-----------------------+
    25	| DEVFUF - DEVFLO TYP LOCATION FOR FILFNX RTNS  |  DEVFUF
	+-----------------------+-----------------------+
    26	|  RIBSZS OF RIB WHICH DDB PTRS ARE FROM OR 0   |  DEVSZS
	+-----------------------+-----------------------+
    27	|  DEVRIB  -  DSK PTR TO RIB FOR DDB RET PTRS   |  DEVRIB
	+-----------------------+-----------------------+
    30	|  DEVELB - ERROR LOGICAL BLOCK (PAGE) OF FILE  |  DEVELB
	+-----------------------+-----------------------+
    31	|  DEVRPS  |DEV| DEVBTS | DEVDBL - NEXT DDB/FNB |  DEVRPS,,DEVDBL
	|  0 - 8   |STC| MF---- |                       |  DEVSTC/DEVBTS
	+-----------------------+-----------------------+
    32	| 1ST DDB RET PTR (NORM) / UNIT DB ADDR (SUPER) |  DEVRB1
	+-----------------------+-----------------------+
	| BLOCK PTRLEN-2 IN-CORE RET PTRS 3,4,...,RBN-1 |
	|                       .                       |
	|                       .                       |
	|                       .                       |
	|                                               |
	+-----------------------+-----------------------+
    XX	|        LAST RETRIEVAL POINTER IN CORE         |  DEVRBN
	+-----------------------+-----------------------+
    YY	| DEVDRB - DIR BLK PTR  | DEVATB - ATB BLK PTR  |  DEVDRB,,DEVATB
	+-----------------------+-----------------------+

DSK: DEVMOD:!XWD DVIN+DVOUT+DVDSK+DVDIR,154407

DEVIAD BITS:
  NORED==400000		;
  NOWRT==200000		;
  PTRCHG==100000	;ON IF RETRIEVAL PNTRS IN DDB HAVE BEEN
			;MODIFIED (AND CONSEQUENTLY HAVE TO BE
			;WRITTEN OUT TO THE RIB.).
  PIDACC==40000		;SET IF DDB IS SUBJECT TO PID ACCESS RULES.
			; (IF LAST UUO HAS UUPPID ON ON EXTENDED BLOCK)


	PAG - PARAMETERS WHICH APPEAR IN MORE THAN ONE DISK PAGE.

	+-----------------------+-----------------------+
      0	|  PAGNAM  -  SIXBIT NAME OF PAGE               |
	+-----------------------+-----------------------+
	|                                               |
	|                       .                       |
	|                       .                       |
	|                       .                       |
	|                                               |
	+-----------------------+-----------------------+
   776	|            0          | PAGCOD - PAGE ID CODE |
	+-----------------------+-----------------------+
   777	|  PAGSLF  -  RETRIEVAL POINTER TO THIS PAGE    |
	+-----------------------+-----------------------+


	WORD POSITIONS IN HOME FILE DATA PAGE.

    EACH FILE STRUCTURE HAS ONE HOME FILE HOME.SYS.

	+-----------------------+-----------------------+
     0	| HOMNAM - SIXBIT 'HOM' |           0           |  HOMNAM
	+-----------------------+-----------------------+
     1	| HOMHID - SIXBIT UNIT ID (WRITTEN BY MAP PROG) |  HOMHID
	+-----------------------+-----------------------+
     2	| HOMSNM - SIXBIT STRUCTURE NAME (0 IF NO STR)  |  HOMSNM
	+-----------------------+-----------------------+
     3	| HOMNXT - SIXBIT UNIT ID OF NEXT UNIT (0=LAST) |  HOMNXT
	+-----------------------+-----------------------+
     4	| HOMPRV - SIXBIT UNIT ID OF PREV UNIT (0=1ST)  |  HOMPRV
	+-----------------------+-----------------------+
     5	| HOMLOG - SIXBIT LOGICAL UNIT NUMBER IN STR    |  HOMLOG
	+-----------------------+-----------------------+
     6	| HOMLUN - LOGICAL UNIT NUMBER IN STRUCTURE     |  HOMLUN
	+-----------------------+-----------------------+
     7	|                                               |
	+-----------------------+-----------------------+
    10	| HOMREF - NONZERO IF STR MUST BE REFRESHED     |  HOMREF
	+-----------------------+-----------------------+
	|                                               |
	|                       .                       |
	|                       .                       |
	|                                               |
	+-----------------------+-----------------------+
    15	| HOMSPU - SAT PAGES PER UNIT                   |  HOMSPU
	+-----------------------+-----------------------+
    16	| HOMOVR - MINUS PAGES ALLOWED FOR OVERDRAW     |  HOMOVR
	+-----------------------+-----------------------+
    17	| HOMSAT - STR PAGE # OF 1ST RIB FOR SAT.SYS    |  HOMSAT / HOMTAB
    	+-----------------------+-----------------------+
    20	| HOMHMS - STR PAGE # OF 1ST RIB FOR HOME.SYS   |  HOMHMS
	+-----------------------+-----------------------+
    	|                                               |
	+-----------------------+-----------------------+
    22	| HOMCRS - STR PAGE # OF 1ST RIB FOR CRASH.SYS  |  HOMCRS
	+-----------------------+-----------------------+
    23	| HOMSUF - STR PAGE # OF 1ST RIB FOR SYS UFD    |  HOMSUF
	+-----------------------+-----------------------+
    24	| HOMPUF - STR PAGE # OF 1ST RIB FOR PRINT UFD  |  HOMPUF
	+-----------------------+-----------------------+
    25	| HOMMFD - STR PAGE # OF 1ST RIB FOR MFD [1,1]  |  HOMHMS
	+-----------------------+-----------------------+
    26	| HOMP4C - PAGES FOR CRASH.SAV FILE             |  HOMP4C
	+-----------------------+-----------------------+
    27	| HOMHSH - HASH CONSTANT| HOMRAN - PACK SET ID  |  HOMHSH,,HOMRAN
	+-----------------------+-----------------------+
    30	|  SIXBIT /DCV/           DSKCLN TYPE           |  HOMDCT
	+-----------------------+-----------------------+
	|                       .                       |
	|                       .                       |
	+-----------------------+-----------------------+
   174	| HOMSER - SERIAL NUMBER INCR ON SYSTEM UP      |  HOMSER
	+-----------------------+-----------------------+
	|                       .                       |
	|                       .                  |
	|                       .                       |
	+-----------------------+-----------------------+
   774	| HOMDAT - DATE OF THE LAST PACK COPY           |  HOMDAT
	+-----------------------+-----------------------+
	|                                               |
	+-----------------------+-----------------------+
   776	|  HOMCOD -  0          | PAGE ID CODE   070717 |  HOMCOD
	+-----------------------+-----------------------+
   777	|  HOMSLF -  0          | PAGE ADDR WITHIN UNIT |  HOMSLF
	+-----------------------+-----------------------+


		   RIB - RETRIEVAL INFORMATION BLOCK

;THE FIRST "RIBDDB" LOCATIONS OF THE RIB ARE KEPT IN CORE IN THE
; DDB WHILE THE FILE IS ACTIVE, THEY ARE FLAGGED (DDB).
;SOME OF THE SAME INFORMATION ALSO APPEARS IN THE ACCESS TABLE ENTRY
; THEY ARE FLAGGED (ACT).
;THE ORDER OF THESE ARGUMENTS CORRESPONDS EXACTLY TO THE EXTENDED LOOKUP,
; ENTER, RENAME BLOCKS.  WORDS APPEARING IN EXTENDED LOOKUP, ENTER, RENAME
; ARE FLAGGED WITH (ENT). SEE LEVEL D PROJECT SPECIFICATION FOR MORE
; INFORMATION ON LOOKUP/ENTRY/RENAME ARGUMENTS AND VALUES.
;A FEW EXTRA WORDS WHICH HAVE MEANING FOR UFD'S ONLY HAVE BEEN ADDED
; TO ALL FILES.  THEY HAVE NO MEANING FOR DATA FILES.  THESE WORDS ARE
; FLAGGED (UFD-ONLY).
;ALL QUANTITIES ARE IN BLOCKS EXCEPT THE FILE SIZE (RIBSIZ), WHERE
;USER MAY WANT TO KNOW NO. OF DATA WORDS IN LAST BLOCK


	+-----------------------+-----------------------+
     0	| RIBRIB - POINTER TO NEXT UPPER RIB (0=PRIME)  |  RIBRIB
	+-----------------------+-----------------------+
     1	| RIBRPS - POINTER LOC TO THIS RIB IN UPPER RIB |  RIBRPS
	+-----------------------+-----------------------+
     2	| RIBSZS - NUMBER OF BLOCKS IN EACH SUBRIB      |  RIBSZS
	+-----------------------+-----------------------+
     3	| RIBSNM - NUMBER OF SUBRIBS IN THIS RIB        |  RIBSNM
	+-----------------------+-----------------------+
     4	| RIBPPN - PROJECT,PROGRAMMER NUMBER IN OCTAL   |  RIBPPN / RIBSFS
	+-----------------------+-----------------------+
     5	| RIBNAM - SIXBIT NAME OF FILE (OR PPN IF UFD)  |  RIBNAM
	+-----------------------+-----------------------+
     6	| RIBEXT - SIXBIT FILE  | RIB | RIBACD - ACCESS |  RIBEXT,,RIBACD
	|          EXTENSION    | MSC | 24 - 35  DATE   |          RIBMSC
	+-----------------------+-----------------------+
     7	| PROT | MODE | CREATION TIME |  CREATION DATE  |  RIBPVW / RIBPRV
	| 0-8  | 9-12 | BITS 13 - 23  |  BITS 24 - 35   |
	+-----------------------+-----------------------+
    10	| RIBSIZ - SIZE OF FILE IN WORDS                |  RIBSIZ
	+-----------------------+-----------------------+
    11	| PROG NO. LAST CHANGE  | OCTAL VERSION NUMBER  |  RIBVER
	+-----------------------+-----------------------+
    12	|                    FUTURE                     |  RIBFUT
	+-----------------------+-----------------------+
    13	| RIBEST - ESTIMATED SIZE IN BLOCKS (OBSOLETE)  |  RIBEST
	+-----------------------+-----------------------+
    14	| RIBALC - NUMBER OF BLOCKS ALLOCATED           |  RIBALC
	+-----------------------+-----------------------+
    15	| RIBPOS - WAS POSITION ALLOCATED, NOW AVAILABLE|  RIBPOS
	+-----------------------+-----------------------+
    16	|                    FUTURE                     |  RIBFT1
	+-----------------------+-----------------------+
    17	|                       | RIBLIC - FILE LICENSE |  RIBLCW
	+-----------------------+-----------------------+

RIBLCW==17	;LICENSE WORD
  RIPDMP==ATPDMP	;(LH)SET BY MONITOR IF FILE CHANGED, CLEARED
			; BY TAPE BACKUP PROGRAM.
  RIPUFE==ATPUFE	;(LH)THIS FILE HAS AN ERROR OF SOME SORT(RIPHWE,
		;RIPHRE,RIPBDR,RIPBFS,RIBBDA.).
		;NOTE THAT RIPUFE MUST=ATPUFE.
  RIPPID==ATPPID	;(LH)IF UFD, SET BY SYS ADMINISTRATOR TO FLAG
			; THAT THIS UFD NEEDS SPECIAL PID STORAGE ACCOUTNING.
			; IF FILE, SET/CLEARED BY MONITOR WHEN PID IS
			; SET/CLEARED.

  RIPALC==ATPALC	;(LH)FOR FILES, NOT UFDS, SAYS THAT
			; THIS FILE HAS HAD AN ALLOCATION CHANGE
			; AND THE MONITOR DOESN'T KNOW IF ALL RIBS
			; AND SATS AND UFDS HAVE BEEN WRITTEN OUT YET.

	+-----------------------+-----------------------+
    20	| RIBMTA - TAPE LABEL FOR FILES PUT ON MAGTAPE  |  RIBMTA
	+-----------------------+-----------------------+
    21	| RIBDEV - FILE STRUCTURE FILE STARTS ON        |  RIBDEV
	+-----------------------+-----------------------+
    22	| RIBSTS - FILE STATUS                          |  RIBSTS
	+-----------------------+-----------------------+
    23	|                                               |
	+-----------------------+-----------------------+
RIBSTS==22	;STATUS BITS FOR ALL FILES IN UFD(LH),
		; THIS FILE IN RH

  RIPLOG==400000;(LH) IF 1 SAYS USER IS LOGGED IN. SET BY LOGIN CUSP
		; RENAME UUO.  SET TO 0 BY LOGOUT CUSP RENAME UUO.
		; BIT CHECKED BY LOGIN IN ORDER TO DETERMINE IF 
		; RIBTOT IS TO BE BELIEVED (IF RIBLOG==1) SYSTEM
		; MUST HAVE CRASHED OR BEEN RELOADED WITHOUT LOGGING
		; OUT ALL USERS.

  RIPBDA==1	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY DAMAGE
		; ASSESSMENT CUSP
  RIPBFS==10	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY FAILSAFE
		; WHEN READING MAGNETIC TAPE TO RESTORE TO DISK.
  RIPHRE==100	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
		; READ DATA ERROR DETECTED BY MONITOR.(IODTER)

  RIPHWE==200	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
		; WRITE DATA ERROR DETECTED BY MONITOR.(IODTER)

  RIPBDR==2000	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY OPERATING SYSTEM.

  RIPDIR==400000;(RH) 1 IF THIS FILE IS A DIRECTORY FILE (UFD OR MFD)
		; RATHER THAN A DATA FILE. NEEDED TO PROTECT
		; THE SYSTEM FROM THE USER WHO MIGHT TRY
		; TO MODIFY A DIRECTORY AS A DATA FILE
  RIPNDL==200000	;(RH)[NO DELETE] 1 IF THIS FILE CANNOT BY
		; DELETED EVEN BY A PRIVILEGED PROGRAM.  THESE FILES ARE IN
		; SOME SENSE FAKE OR CRUCIAL TO FILE STRUCTURE.
		; EG. HOME.SYS, SAT.SYS, MAINT.SYS, BADBLK.SYS
		; NAME CHANGED FOR SAVE REASONS AS NO DELETES ABOVE.
  RIPNFS==40000	;(RH)[NO FAILSAFE] 1 IF THIS FILE SHOULD NOT
		; BE DUMPED BY FAILSAFE BECAUSE IT IS A FUNNY FILE AND
		; SHOULD NOT BE RESTORED OR IS PART OF THE SKELETON
		; FILE STRUCTURE.  (BADBLK.SYS,SAT.SYS,HOME.SYS,MAINT.SYS
		; RECOV.SYS).  (SNAP.SYS, CRASH.SAV, UFD'S AND MFD
		; DO NOT HAVE RIPNFS ON, SO THEY ARE ALL SAVED).
RIPSPP==1000	;FILE HAD DEVPPN=JBTPPN AT CREATION TIME


	+-----------------------+-----------------------+
    23	| RIBELB - FIRST LOGICAL BLOCK WITH AN ERROR    |  RIBELB
	+-----------------------+-----------------------+
    24	| RIBXT1 - EXTRA ARGUMENT                       |  RIBXT1
	+-----------------------+-----------------------+
    25	| RIBQTF - FIRST COME LOGGED IN QUOTA IN BLOCKS |  RIBQTF
	+-----------------------+-----------------------+
    26	| RIBQTO - LOGGED OUT QUOTA IN BLOCKS           |  RIBQTO
	+-----------------------+-----------------------+
    27	| RIBMXA - MAXIMUM EVER USED COUNT IN BLOCKS    |  RIBMXA
	+-----------------------+-----------------------+
    30	| RIBUSD - BLOCKS USED AT LAST LOGOUT           |  RIBUSD
	+-----------------------+-----------------------+
    31	| RIBAUT - AUTHOR PPN FOR THIS FILE             |  RIBAUT
	+-----------------------+-----------------------+
    32	| RIBUNM - SIXBIT USERNAME (FIRST 6 CHARACTERS) |  RIBUNM
	+-----------------------+-----------------------+
    33	| RIBUN1 - SIXBIT USERNAME (2ND 6 CHARACTERS)   |  RIBUN1
	+-----------------------+-----------------------+
    34	| RIBTRU - PRIVILAGED ARGUMENT FOR CUSTOMER     |  RIBTRU
	+-----------------------+-----------------------+
    35	| RIBXT2 - A SECOND EXTRA AGRUMENT              |  RIBXT2
	+-----------------------+-----------------------+
    36	| RIBALP - NUMBER OF PAGES REALLY ALLOCATED     |  RIBALP
	+-----------------------+-----------------------+
    37	| RIBPJC - PROJECT CODE - WORD 0                |  RIBPJC
	+-----------------------+-----------------------+
    40	| RIBPJ1 - PROJECT CODE - WORD 1                |  RIBPJ1
	+-----------------------+-----------------------+
    41	| RIBPJ2 - PROJECT CODE - WORD 2                |  RIBPJ2
	+-----------------------+-----------------------+
    42	| RIBPID - PROCESSOR ID CODE                    |  RIBPID
	+-----------------------+-----------------------+
    43	| RIBALT -                                      |  RIBALT
	+-----------------------+-----------------------+
	|                                               |
	+-----------------------+-----------------------+
	|                                               |
	+-----------------------+-----------------------+

;THE NEXT LOCATIONS ARE USED FOR RIB POINTERS. THE RIB POINTERS
;HAVE THE FOLLOWING FORMAT
    RBSPAR==400000
;	BIT 0 POINTER TO A SPARE RIB NOT DATA
    RBREAL==200000
;	BIT 1 IS POINTER TO A REAL PAGE (AS OPPOSED TO JUST A PLACE HOLDER.).
    RBINDX==100000
;	BIT 2 SPECIAL BLOCK (INDEX) SKIP UNLESS MODE 200+N
    RBDLTA==40000
;	BIT 3 POINTER HAS BEEN CHANGED
;
    RBMASK==RBSPAR!RBREAL!RBINDX!RBDLTA

	PTSUNI==^D8
	PTNUNI==^D16
	PTSPNO==^D19
	PTNPNO==^D35
RBYUNI: POINT PTSUNI,T2,PTNUNI
RBYUN1: POINT PTSUNI,T1,PTNUNI
RBYUN4: POINT PTSUNI,T4,PTNUNI
RBYUNA:	POINT PTSUNI,ATBRIB(P2),PTNUNI
RBYUNR:	POINT PTSUNI,DRBRIB(P1),PTNUNI
RBYUNV:	POINT PTSUNI,DEVRIB(F),PTNUNI
;	BITS 9-16 UNIT NUMBER
RBYPNO:	POINT PTSPNO,T2,PTNPNO
RBYPN1:	POINT PTSPNO,T1,PTNPNO
RB1PNO:	POINT PTSPNO,P1,PTNPNO
;	BITS 17-35 PAGE NUMBER ON UNIT

RIBPFS==51		;FIRST SPOT WHICH CAN BE USED FOR RIB POINTERS


RIBCOD==PAGCOD	;CONTAINS UNLIKELY DATA WORD (I.E., NOT ASCII OR FLOATING POINT)
		;LH=0
  CODRIB==666666  ; THE UNLIKELY CODE
RIBLST==RIBCOD-1	;LAST LOCATION FOR POINTERS
  RBLVPR==RIBLST-RIBPFS+1  ;NO. OF PRIME RIB PNTRS.
  RBLVSP==RIBLST-RIBSFS+1  ;NO. OF SPARE RIB PNTRS.
INTERN TWOLVL,ONELVL
TWOLVL==RBLVSP*RBLVSP
ONELVL==RBLVSP

RIBSLF==PAGSLF	;A POINTER TO THIS RIB ITSELF


			   VESTIGIAL STR DB

STRDDB:

STRNAM:!0	;SIXBIT NAME OF FILE STR.  ALSO, <>0 IS FLAG THAT STR EXISTS.
STRHSH:!
STRUNI:!0	;LH=ADDR OF FIRST UNIT DATA BLOCK IN THIS STR.
		;END OF LIST IS 0.  LH IN UNI IS UNISTR.
		;RH IS HASH CONSTANT.

STRP4C:!0	;PAGES FOR CRASH.SAV.
STRUNM:!0	;RH=NO. OF UNITS IN THIS FILE STR.
STRREF==STRUNM	;LH=LH=NON-ZERO IF THIS STR NEEDS REFRESHING
STROVR:!0	;-NO. OF PAGES A USER IS ALLOWED TO WRITE OR
		;ALLOCATE BEYOND HIS RESERVED+FCFS QUOTA.
STRTAL:!0	;NO. OF FCFS FREE PAGES LEFT IN THIS STR MINUS
		;A SAFETY FACTOR (STVSFC - MONGEN SYMBOL).
		;THIS SAFETY FACTOR GUARANTEES THAT CLOSES
		;CAN BE DONE.
STRPPU:!0	;NO. OF PAGES PER UNIT IN THIS STR.
STRPID:!0	;LH=STR PACK SET ID
STRBTS==STRPID	;RH=SOME STATUS BITS
		;BITS 18 - 33 ARE UNDEFINED.
		;BIT 34 MEANS DSKCLN NEEDS TO BE RUN FOR THIS STR.
		;BIT 35 MEANS A SAT HAS BEEN FOUND BAD SINCE THE LAST REPORT.
    SRPNDS==2
    SRPRPT==1

STRLEN==.-STRNAM

		      UFD - USER FILE DIRECTORIES
;THESE HAVE SAME FORMAT AS THE MFD.
;NEITHER THE MFD NOR THE UFD NAME APPEAR IN THE UFD.
;FILE ENTRIES OCCUR IN PAIRS.

	+-----------------------+-----------------------+
     0	| UFDNAM - SIXBIT FILE NAME                     |  UFDNAM
	+-----------------------+-----------------------+
     1	| UFDEXT - SIXBIT EXT   |       |UFDUF2| UFDPRV |  UFDEXT
	|                       |              | 27-35  |
	+-----------------------+-----------------------+
     2	|                                               |
	+-----------------------+-----------------------+
     3	|                                               |
	+-----------------------+-----------------------+
UFDPRV==1	;PRVTECTION IN UFD
  UFSPRV==^D9
  UFNPRV==^D35
UFDUF2==1
  UFNUF2==^D26
  UFSUF2==^D8
  UFPDMP==1B19
  UFPERR==1B20
  UFPPID==1B21		;FOR UFD, MEANS SPECIAL PID STORAGE ACCOUNTING, NOT
			; SET BY MONITOR, SET BY USER.
			;FOR REGULAR FILE, SET/CLEARED BY MONITOR WHEN PID
			; IS SET/CLEARED.
  UFPALC==1B22		;NOT CURRENTLY USED FOR UFD, FOR FILE,
			; MEANS NOT ALL RELEVANT DATA IS GUARANTEED
			; TO BE ON DISK.
  UFDERR==UFDUF2
UFDUF1==2
  UFSUF1==4
  UFNUF1==4
UFDXCD==2	;EXTENDED DATE BITS
  UFSXCD==2
  UFNXCD==6
UFDCTM==2	;CREATION TIME
  UFSCTM==^D17
  UFNCTM==^D23
UFDCDT==2	;CREATION DATE
  UFSCDT==^D12
  UFNCDT==^D35
UFDALP==3	;SPACE ALLOCATED
UFDLIC==3	;LICENSE BITS
  UFPTMP==1B23	;SET BY USER TO SAY THAT THIS IS A TMP FILE,
		;EVEN THOUGH IT MAY NOT HAVE THE EXT TMP.
  ;THERE ARE OTHER BITS IN USE IN UFDLIC...WHO KNOWS WHAT
  ;THEY ARE.....
UFDRIB==4	;RETRIEVAL PNTR TO PRIME RIB OF FILE.

UFDHSI==7	;THIS IS THE HASH CODE USED TO LOOKUP FILES
UFDLNK==^D511	;THIS IS WHERE THE LINK TO THE NEXT BLOCK IS
UFDSIZ==5	;NUMBER OF WORDS/ENTRY

;BYTE POINTERS

UFYUF2:	POINT UFSUF2,%RIB+UFDUF2(T2),UFNUF2
UFYUF1:	POINT UFSUF1,%RIB+UFDUF1(T2),UFNUF1
UFYPRV:	POINT UFSPRV,%RIB+UFDPRV(T2),UFNPRV
UFYXCD:	POINT UFSXCD,%RIB+UFDXCD(T2),UFNXCD
UFYCTM:	POINT UFSCTM,%RIB+UFDCTM(T2),UFNCTM
UFYCDT:	POINT UFSCDT,%RIB+UFDCDT(T2),UFNCDT


;MONITOR JOB TABLES - ONE ENTRY PER JOB

	INTERN JBTRCT,JBTWCT,JBTMPC,JBTPWH,JBTPWL,JBTPWS
	INTERN JBRIRD,JBRIWT,JBYIRD,JBYRCT,JBYIWT,JBYWCT,JBSRCT
	INTERN SYSBG3,SYSEN3

SYSBG3:			;1ST. LOCATION CLEARED BY ACCINI ON 143 (RE)START
JBTRCT:	BLOCK	JOBN	;NO. OF DISK BLOCKS READ ON ALL STRS SINCE JOB LOGGED IN
			;JOB 0=SWAP READ ON ALL UNITS
			;JOB 0 = SWAP READ ON ALL UNITS
			; ACTUALLY IT IS A COPY OF THE LOW ORDER 12 BITS
			; OF THE ACCUMULATED READS FOR THIS JOB.
			; IT IS RESET TO NEW LOW ORDER TOTAL AFTER EVERY
			; "DISK" COMMAND.  IN THIS WAY ONLY ONE COUNT NEED
			; BE INCREMENTED EVERY READ INSTEAD OF TWO.
			; INCREMENTAL DISK BLOCKS READ IS COMPUTED BY:
			;  LDB T1,JBYRCT;LDB T2,JBYIRD;DPB T1,JBYIRD;SUB T1,T2
			;  ANDI T1,JBRIRD
  JBSIRD==^D12		;BYTE SIZE
  JBNIRD==^D11		;BYTE PTR POS.
  JBRIRD==1_JBSIRD-1	;BITS IN BYTE AFTER RIGHT JUSTIFIED
  JBSRCT==^D24		;BYTE SIZE
  JBNRCT==^D35		;BYTE PTR POS
JBTWCT:	BLOCK	JOBN	;NO. OF DISK BLOCK WRITTEN ON ALL STRS SINCE JOB LOGGED IN
			;JOB 0=SWAP WRITE ON ALL UNITS
  JBSIWT==^D12		;BYTE SIZE
  JBNIWT==^D11		;BYTE PTR POS
  JBRIWT==1_JBSIWT-1	;BITS IN BYTE AFTER BEING RIGHT JUSTIFIED
  JBSRCT==^D24		;BYTE SIZE
  JBNRCT==^D35		;BYTE PTR POS

JBTMPC:	BLOCK JOBN	;NO. OF PAGES MAPPED BY USER DOING A
			;MAP UUO.

JBTPWS:	BLOCK JOBN	;NO. OF PAGES USER HAS PUT INTO THE UWS.

JBTPWH: BLOCK JOBN	;HIGH PART OF NO. PAGES INTO UWS TIMES
			;SIZE.
JBTPWL: BLOCK JOBN	;LOW PART OF NO. PAGES INTO UWS TIMES
			;SIZE.
JBTDAB::BLOCK	<JOBN-1>*DABSIZ ;DUMMY ACCESS TABLES. SEE ATB DEFINITIONS
			; FOR DATA FORMAT.


SYSEN3==.-1		;LAST LOCATION CLEARED BY ACCINI ON 143 (RE)START

JBYIRD:	POINT JBSIRD,JBTRCT(J),JBNIRD	;BYTE POINTER
JBYRCT:	POINT JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINTER
JBYIWT:	POINT JBSIWT,JBTWCT(J),JBNIWT	;BYTE POINTER
JBYWCT:	POINT JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINTER


;STT - SAT TABLE FOR SATS IN CORE AND DISK FOR A UNIT.
;THERE IS ONE ENTRY FOR EACH SAT ON THE UNIT, EVEN THOUGH NOT
;ALL SATS ARE KEPT IN CORE.
;THERE IS AN EXTRA ZERO WORD TO MARK THE END OF EACH STT.
;
;AN ENTRY CONSISTS OF:

INTERNAL STTFPC,STTPTR,STTAOB,STTSTS,STTLEN,STYINC,STYBAD,STYCHK
INTERNAL STPINC,STPBAD,STPCHK,STPRPT

STTPTR==0	;DISK POINTER TO THIS SAT.
STTFPC==1	;FREE PAGE COUNT.
STTAOB==2	;AOBJN WORD.  (NOT REALLY.  REALLY THE LH/
		;-BIT NO IN WORD AND RH/WORD WRS START OF SAT.).
STTSTS==3	;BITS OF INTEREST.
  STYINC: POINT 1,STTSTS(T2),1	;ON IF SAT IS IN CORE IN A PCB.
  STPINC==200000
  STYBAD: POINT 1,STTSTS(T2),2	;ON IF SAT IS BAD.
  STPBAD==100000
  STYCHK: POINT 1,STTSTS(T2),3	;ON IF SAT HAS BEEN CHECKED.
  STPCHK==40000
  STPRPT==20000	;ON IF THE SAT NEEDS TO BE REPORTED AS BAD.

STTLEN==STTSTS-STTPTR+1


;"SYS" - SYSTEM WIDE QUANTITIES
; NO SPECIAL PREFIX

INTERN	MFDPPN,SYSPP,FSFPPN,SPLPPN,SYSDRB
	INTERNAL ACTPPN,CBUSER,CBADR,CNTBLK
INTERN	SYSDOR,SYSCOR
INTERN	STNPRT,CUSPPP,DUMPPP,HELPPP,SYSPP,QUEPPN
INTERN  SYSUNI,LVDTBL,LVDMXL,UFDPRT,SYSPPN,CORNUM,QUESTR,CRUPPN
INTERN  ETSUNI,ETSGTI,ETSBDT,ETSDCO,ETSDCA,ETSBCN,ETSCCO,ETSCCA
INTERN  ETSTAB,METSLN

LVDTBL:!	;GETTAB TABLE NO. 16(OCTAL)-LEVEL D DISK PARAMTERS

MFDPPN:	XWD 1,1		;(0)PROJECT-PROGRAMMER NUMBER FOR STORING UFDS ONLY
			;  (ALL OTHER FILE STRUCTURE FILES ARE STORED IN DEVICE SYS
			;  (SEE SYSPPN))
CUSPPP:
SYSPP:
SYSPPN:	XWD 1,4		;(1)PROJ-R NO. FOR DEVICE 'SYS' (I.E. CUSPS,LIBRARY)
			;  DIRECTORIES ARE STORED IN MDFPPN
DUMPPP:
FSFPPN:	XWD 1,2		;(2)PROJ-R NO. FOR FAILSAFE - ALL PRIVILEGED PROGRAM

HELPPP:	XWD 2,5		;(3)SYSTAT AND HELP RUN UNDER THIS NUMBER
			;  (IF NOT ALREADY LOGGED IN)
QUEPPN:
SPLPPN:	XWD 11653,115244;(4)PROJ-R NO. FOR PRINTR SPOOLING PROGRAM

SYSDRB:	XWD 0,0		;(5)LH=FIRST DRB IN FILSER FREECORE
			;  [THIS NEXT COMMENT LOOKS OBSOLETE.../AAA]
			;  RH=CORE ADDRESS OF NEXT PPB BLOCK TO SCAN
			;  NAME LIST TO RECLAIM GRABBABLE NMB BLOCK
			;  IF RH=0 CORE GRABBER SHOULD START OVER AT BEGINNING
			;  OF PPB LIST (I.E., LH OF SYSPPB)

	0		;(6) NOT USED

SYSUNI:	XWD FIRUNI,UNISYS;(7)LH=CORE ADDRESS(DOWNWARD POINTER)OF FIRST UNIT
			;  RH UNUSED
			;  DATA BLOCK IN SYSTEM
			;  RH=UNUSED.

	XWD	0,0	;(10) PLACE HOLDER FOR OBSOLETED ENTRY
FFCBLK==JOBN*<2+<2*OPNFPF>> ;  FILSER FREE CORE BLKS SYSTEM-WIDE. FOR
			;  EACH JOB ASSUME 2 DRB'S (LOGGED-IN AND GFD'D
			;  DIRECTORY).  FOR EACH OF THE OPNFPF FILES
			;  ASSUMED, EXPECT 1 ATB AND 1 FNB.
IFL FFCBLK-^D50,<FFCBLK==^D50>	;INSURE AT LEAST 50 FILSER BLOCKS
				; EVEN IF JUST A 1 JOB SYSTEM

CORNUM:	EXP FFCBLK	;(11)# PERMANENT FILSER CORE BLOCKS GENERATED AT ONCE ONLY TIME

STNPRT:	XWD PRVFIL*1000,0;(12)STANDARD PRIVILEGE

UFDPRT:	XWD PRVUFD*1000,0;(13)STANDARD UFD PRIVILEGE
			;  SYMBOL PRVUFD SHOULD NOT BE USED. INSTEAD
			;  UFDPRT SHOULD BE USED, SO CAN PATCH STANDARD.

INTERN  NMSTPC,NMRBPC

IFNDEF RPCBN,<RPCBN==7>
IFLE <RPCBN-4>,<RPCBN==5>
NMRBPC: EXP RPCBN	;(14) NO. OF SYSTEM-TIME PCBS FOR RIBS (CAN
			;  BE CHANGED AT ONCE ONLY TIME.

IFNDEF SPCBN,<SPCBN==17>
IFLE <SPCBN-4>,<SPCBN==5>
NMSTPC: EXP SPCBN	;(15) NO. OF SYSTEM-TIME PCBS FOR SATS (CAN
			;  BE CHANGED AT ONCE ONLY TIME.

QUESTR:	0		;(16) SIZBIT NAME OF FILE STRUCTURE
			;  FOR QUEUEING PROGRAMS LIKE PRINT,UMOUNT, ETC
			;  SETUP BY MANDATORY ONCE ONLY CODE TO BE
			;  THE FIRST(FASTEST) STR WHICH IS UP(TABSTR(0)).

ACTPPN:	XWD 6,270	;(17)ACCOUNTING, JL ON CAN ACCESS THESE

CRUPPN:	XWD	10,1	;(20) UFD FOR DUMPING CRASHES

LKBSIZ:	EXP UUXENT	;(21) SIZE OF LARGEST MEANINGFUL
			;  EXTENDED LOOKUP BLOCK

LVDMXL==<.-LVDTBL-1>B26	;END OF GETTAB TABLE


;SYSTEM VARIABLES NOT IN GETTAB:

SYSDOR:	XWD 0,0		;BEGINNING OF DORMANT ACCESS BLOCK LIST FOR SYSTEM
			;LH=ADDRESS OF FIRST DORMANT ACCESS BLOCK IN SYSTEM
			;LH=0 IF NO DORMANT ACCESS BLOCKS
			;RH=ADDRESS OF LAST DORMANT ACCESS BLOCK IN SYSTEM
SYSCOR:	XWD .,ZERO18	;BEGINNING OF PERMANENT FILSER CORE BLOCK LIST
			;LH=ADDRESS OF FIRST FREE FILSER CORE BLOCK,RH=0 ALWAYS
			; IF NO FREE BLOCKS, WHOLE WORD=0.
			; BLOCKS ARE LINKED TOGETHER BY CORLNK WORD.

CORBAS::0		;CONTAINS BASE ADDRESS OF FILSER CORE BLOCKS
			; FOR ATB POINTER COMPUTATIONS.
INTERN MFDRIB
MFDRIB:	0		;RETRIEVAL POINTER TO PRIME RIB OF MFD.

;SOFTWARE ERROR TESTING - SET AND CLEAR SELECTED CONI OR DATAI ERROR BIT
; N TIMES AFTER M TIMES
; .FSETS M ARGS ARE IN SAME ORDER AS BELOW:
ETSUNI:	0		;(0) CONTAINS UNIT DATA BLOCK ADDRESS OF
			; A UNIT WHICH IS BEING ERRROR TESTED WITH
			; .FSETS UUO.  IF THIS LOC CONTAINS 0, NO
			; ERROR TESTING (FOLLOWING LOC ARE IGNORED)!
ETSTAB:			;0TH ENTRY FOR ARG PICKUP LOOP
ETSGTI:	0		;(1)NO, OF GOOD TRANSFER INTERRUPTS BEFORE BAD TIMES
ETSBDT:	0		;(2)NO. OF BAD DATAI BEFORE CLEARING ETSUNI
ETSDCO:	0		;(3)ERROR DATAI BITS ORED WITH DATAI BITS
ETSDCA:	0		;(4)ERROR DATAI BITS ANDCMED WITH DATAI BITS
ETSBCN:	0		;(5)NO. OF BAD CONI BEFORE CLEARING ETSUNI
ETSCCO:	0		;(6)ERROR CONI BITS ORED WITH CONI BITS
ETSCCA:	0		;(7)ERROR CONI BITS ANDCMED WITH CONI BITS
ETSLEN==.-ETSTAB	;LENGTH OF .FSETS ARGS
XP METSLN,-ETSLEN

CBUSER:	0		;USER OF CB QUE (FOR ERROR TRACING)
;ALL THE FOLLOWING HAVE F IN LH ADR OF CALL IN RH FOR ERROR TRACE
CBADR:	0
CNTBLK:	0

CNTFLN:	SIXBIT /CNTBLK/

	1,,0
	.LINK 1,.-1
	CNTBLK,,CNTFLN

			; DEVICE SYS. (4 BIT BYTES ENDED WITH BYTE FSNEND
			; OR OFF THE END OF WORD, IE MAX OF 9 BYTES)


;BAD ALLOCATION FILE.

; A (DUPLICATED) PAGE IN HOME.SYS.
; PROGRAMS SEARCHING HOME.SYS SHOULD LOOK FOR SIXBIT IDENTIFICATION IN
; FIRST WORD OF EACH PAGE.

INTERNAL BATNBB,BAYNBB,BA1NBB,BATREG,BATFIR,BRMAX,BATPAT
INTERNAL CODBAT,BANNBB,BASNBB,BATNAM,BATSLF,BATCOD
INTERNAL BATCNT,BATELB

BATNAM==PAGNAM	;CONTAINS SIXBIT /BAT/ FOR IDENTIFICATION
	BATNUM==777		;MAX NUMBER OF BAD PAGES IN A REGION-1
BATFIR==1	;LH=-MAX. POSSIBLE NO. OF WORDS FOR BAD REGIONS MAP AND MONITOR
		; CAN ADD BEFORE PAGE FILLS UP
		;RH=REL ADR. WITHIN THIS PAGE OF FIRST BAD REGION PAIR
		; MAP R FORCES LH TO BE EVEN NUMBER.
		;ALL PROGRAMS SHOULD SCAN THE BAT PAGE BY STARTING WITH THIS WORD
		; RATHER THAN KNOWING WHERE DATA PAIRS START.  IN THIS WAY
		; ADDITIONAL HEADER WORDS CAN BE ADDED WITHOUT INVALIDATING ANY
		; PROGRAMS WHICH READ BAT PAGE.
		;BOTH HALVES WRITTEN BY MAP PROGRAM AND NEVER CHANGED BY MONITOR
BATPAT==2		;TOTAL NUMBER OF BAD PAGES

BATCNT==3	;NO. OF DISTINCT BAD REGION WORD PAIRS

BATREG==4	;FIRST BAD REGION WORD GOES HERE. THIS SYMBOL NEVER APPEARS IN ANY
		; CODE WHICH READS BAT PAGE - EXCEPT MAP PROGRAM OR OPTIONAL ONCE
		;ONLY CODE WHICH WRITES IT THE FIRST TIME.  INSTEAD SEE RH OF BATFIR
		;NOTE: BATREG MUST BE AN EVEN NUMBER



;THE MAP PROGRAM IS NOT PART OF THE MONITOR - IT RUNS AS A STAND-ALONE PROGRAM
; WHICH WRITES AN INITIAL BAT PAGE WITH ALL THE BAD REGIONS IT FINDS.
;BOTH THE MAP PROGRAM AND THE MONITOR WRITE TWO WORD ENTRIES OF THE SAME FORMAT
;THE MONITOR ADDS TWO-WORD ENTRIES WHENEVER IT FINDS BAD REGIONS
;WHILE READING, WRITING, OR POSITIONING (READ OR WRITE)
;THE MAP R AND MONITOR STORE LOGICAL RATHER THAN PHYSICAL ADDRESSES

BATNBB==0	;NUMBER OF BAD PAGES-1 IN THIS BAD REGION(NOT CLUSTERS
		; -SINCE BADNESS IS INDEPENDENT
		; OF THE CLUSTER SIZE - WORD ADR(WITHIN 2 WORD ENTRY)
  BASNBB==^D9	;BYTE SIZE
  BANNBB==^D8	;BYTE PTR. POS.
MAPBIT==1B9	;ALWAYS ON TO ENSURE THAT THIS WORD IS NON-ZERO
BAYNBB:	POINT BASNBB,BATNBB(T2),BANNBB	;BYTE PTR
BA1NBB: POINT BASNBB,%RIB+BATNBB(T1),BANNBB	; Used in (CORE1)
;BITS 18-35 ARE DATE OF ENTRY

BATELB==1	;ERROR LOGICAL PAGE ADR. WITHIN UNIT - WORD ADR. (WITHIN 2 WORD ENTRY)
		; OF FIRST LOGICAL PAGE IN BAD REGION OF PAGES
BATCOD==PAGCOD	;CONTAINS UNLIKELY CODE
		;LH=0
CODBAT==505050	;UNLIKELY CODE FOR BAT PAGE
BATSLF==PAGSLF	;LH=0, RH=THIS PAGE(NOT CLUSTER) AADR. WITHIN UNIT

BRMAX==BATCOD-BATREG	;MAX LENGTH OF AREA FOR APPENDING BAD REGIONS


;DEFINE PROTECTION LEVELS AND UFD PROTECTION BITS

;UFD

UFRXLK==4	;"TRANSPARENT" UFD
UFRXCR==2	;CAN CREATE NEW FILE
UFRXRD==1	;CAN READ UFD AS A FILE

INTERNAL UFRXLK,UFRXCR,UFRXRD

;PROTECTION FUNCTIONS. NESTED

FNCLOK==1	;LOKUP ONLY
FNCEXC==2	;EXECUTE
FNCRED==3	;READ
FNCAPP==4	;APPEND
FNCUPD==5	;UPDATE
FNCCRE==6	;CREATE
FNCCAT==7	;CHANGE ATRIBUTES
FNCCNM==10	;CHANGE NAME
FNCCPR==11	;CHANGE PROTECTION
FNCSUP==12	;SUPERCEDE
FNCTRN==13	;TRUNCATE
FNCDEL==14	;DELETE

INTERNAL FNCLOK,FNCEXC,FNCRED,FNCAPP,FNCUPD,FNCCRE
INTERNAL FNCCAT,FNCCNM,FNCCPR,FNCSUP,FNCTRN,FNCDEL


;CHN:	CHANNEL DATA BLOCK

;THESE LOCATIONS ARE SET, LOOKED AT AND CHANGED
;BY FILSER. DEVICE DEPENDENT MODULES DO NOT LOOK AT THEM.
;PARAMETERS FOR CHNCB:

	DEFINE	CHNCB <

INTERN CHNBSY

$CHUNN==0	;UNIT NUMBER WITHIN CHANEL
$KCHNN==0	;KONTROLER NUMBER WITHIN CHANNEL

REPEAT %KNCHN(\$CHN,FH),<KONTCB FH>
REPEAT %KNCHN(\$CHN,DP),<KONTCB DP>
REPEAT %KNCHN(\$CHN,MD),<KONTCB MD>
REPEAT %KNCHN(\$CHN,RM),<KONTCB RM>
REPEAT %KNCHN(\$CHN,AP),<KONTCB AP>

IFN $CHUNN,<NMCHUN(\$CHN,\$CHUNN)==NMCHUN(\$CHN,0)>

%NCH(INTERNAL,\$CHN)
CHNBSY==0	;;MAKE SURE FIRST ENTRY IN DATA BLOCK ELSE MACRO ERROR
NMCH(\$CHN):0	;;0 IS IDLE, NEGATIVE IS BUSY
		;; MUST BE WORD 0 OF CHN DATA BLOCK
		;; SO AOSG @KONCHN(J) WILL TEST BUSY AND SET
		;; BUSY IN ONE INSTRUCTION
NMKCN(\$CHN,\$KCHNN)==0
$CHN==$CHN+1
>	;END MACRO DEF OF CHNCB


;SA-10 DATA BLOCKS AND CHANNEL DATA BLOCKS

COMMENT ;

THE SA-10 STRUCTURE IS CONTROLLED BY THE FOLLOWING SYMBOLS.
SAXN IS THE NUMBER OF SA-10'S CONNECTED TO THE SYSTEM
FOR EACH SA-10 (#=THE NUMBER OF THE SA-10)
SAX# IS THE DEVICE MNEMONIC
SA#INT IS THE INTERUPT LOCATION

SAXC#N IS THE NUMBER OF CHANNELS ON THIS SA-10
BP<#1><#2> IS THE NUMBER OF 3330'S ON THE CHANNEL WHERE
<#1> IS THE SA-10 NUMBER AND <#2> IS THE CHANNEL NUMBER
FT<#1><#2> IS THE NUMBER OF 3420'S (MAGTAPES)
;

	DEFINE SAXCB (NUM)
<$SAXCN==0
;GENERATE THE CHANNEL BLOCKS

	REPEAT SAXC'NUM'N,<SACCB (NUM,\$SAXCN)>

SA'NUM'INT: CONSO SAX'NUM,1B18
	JRST .
	JSR SAXSAV
	JSP M,SAXINT

SAX'NUM'CB: 
	PHASE 0
SAXCNI:!	CONI SAX'NUM,T1
SAXCNO:!	CONO SAX'NUM,(T1)
SAXDTI:!	DATAI SAX'NUM,T1
%%XXQ=0
SAXCHL:!	REPEAT SAXC'NUM'N,<NMSCH(NUM,\%%XXQ)
	%%XXQ==%%XXQ+1>
	REPEAT 4-SAXC'NUM'N,<0>

INTERNAL SAXCNI,SAXCNO,SAXDTI,SA'NUM'INT,SAXCHL
EXTERNAL SAXSAV
	DEPHASE
>

;NOW THE SA-10 CHANNEL BLOCK

	DEFINE SACCB(XNUM,CNUM)
<IFE BP'XNUM'CNUM+FT'XNUM'CNUM,<SC'XNUM'CNUM'CB==0>
IFN BP'XNUM'CNUM+FT'XNUM'CNUM,<
$SAXUN==0	;NUMBER OF UNITS (MAX)
$CHUNN==0	;ALSO NUMBER OF UNITS BUT ACTUAL NOT MAX
$KCHNN==0
	REPEAT BP'XNUM'CNUM,<KONTCB (BP)>
	REPEAT FT'XNUM'CNUM,<KONTCB (FT)>
IFN BP'XNUM'CNUM,<NMCHUN(\$CHN,\$CHUNN)==NMCHUN(\$CHN,0)>
NMKCN(\$CHN,\$KCHNN)==0
SC'XNUM'CNUM'CB:
NMCH(\$CHN):
	PHASE 0
	0	;NORMALLY CHANNEL BUSY
CHNSTB:!	SAXBAS+XNUM*^D16+CNUM*4+1
CHNGO:!	CONO SAX'XNUM,4B29+1B30+<CNUM>B32+SAXCHN
CHNCLR:!	CONO SAX'XNUM,6B29+<CNUM>B32+SAXCHN
CHNIIE:!	CONO SAX'XNUM,7B29+1B30+<CNUM>B32+SAXCHN
CHNMER:!	Z
CHNACT:!	Z
CHNKON:!	NMKCN(\$CHN,0)
CHNBMX:!REPEAT $SAXUN,<-1>
	0	;BLOCK MULTIPLEXOR LIST
	DEPHASE
$CHN==$CHN+1
INTERNAL CHNSTB,CHNGO,CHNCLR,CHNIIE,CHNACT,CHNKON,CHNBMX,SC'XNUM'CNUM'CB
INTERNAL CHNMER
EXTERNAL SAXBAS,SAXCHN
>
$SAXCN==$SAXCN+1>


;CONTROLER NUMBERS

REPEAT 0,<
A SERIES OF MACROS ARE INCLUDED HERE FOR GENERATING CHANNEL, KONTROLLER,
AND UNIT CORE BLOCKS.  THE VARIOUS CORE BLOCKS ARE LINKED TOGETHER
APPROPRIATELY; THE NUMBER OF EACH TYPE AND APPROPRIATE LINKAGE ARE
DETERMINED BY SYMBOLS GENERATED BY MONGEN.  SYMBOLS GENERATED ARE:

	CHNN	TOTAL NUMBER OF DATA CHANNELS (DF10) FOR DISKS
		CHANNELS ARE NUMBERED FROM 0 TO CHNN - 1

	CNFH	NUMBER OF FIXED HEAD KONTROLLERS ON CHANNEL N
	CNDP	NUMBER OF DISK PACK KONTROLLERS ON CHANNEL N
	CNMD	NUMBER OF MASS FILE (BRYANT DISK) KONTROLLERS ON CHANNEL N

		KONTROLLERS OF EACH TYPE ARE LETTERED A,B,C, ETC., SO
		THE FIRST DISK PACK KONTROLLER IS DPA, THE SECOND DPB, ETC.

	XXYUN	NUMBER OF UNITS ON KONTROLLER XXY

THE CHNCB MACRO GENERATES A CHANNEL CORE BLOCK, THEN CALLS MACROS TO
GENERATE KONTROLLER AND UNIT CORE BLOCKS.  ITS ARGUMENT IS THE CHANNEL NUMBER,
IN ASCII.  CHNCB CALLS MACRO KONTCB FOR EACH KONTROLLER ON THE CHANNEL.  THERE
IS A REPEAT LOOP FOR EACH KONTROLLER TYPE, REPEATED CNXX TIMES, WHERE N IS THE
CHANNEL NUMBER AND XX IS THE KONTROLLER TYPE, EACH LOOP CALLING KONTCB ONCE.
THE ARGUMENTS FOR KONTCB ARE THE KONTROLLER TYPE, A LIST CONTAINING THE LETTERS
TO IDENTIFY SUCCESSIVE KONTROLLERS, AND THE CHANNEL NUMBER, IN ASCII.

KONTCB FIRST CALLS MACRO XXKON TO GENERATE A KONTROLLER CORE BLOCK FOR THE
KONTROLLER, THEN REPEATS XXYUN TIMES CALLING UNITCB MACRO TO GENERATE UNIT CORE
BLOCKS FOR THE KONTROLLER.  ARGUMENTS FOR XXKON ARE KONTROLLER TYPE (XX),
KONTROLLER IDENTIFIER, AND THE ASCII VALUE OF SYMBOL XXNUM, WHICH IS INCREMENTED
FOR EACH KONTROLLER OF TYPE XX.  XXKON FORMS SYMBOL XX'XXNUM (XX0, XX1, ...),
WHICH IS USED AS THE DEVICE CODE FOR THE KONTROLLER.  ARGUMENTS FOR UNITCB
INCLUDE KONTROLLER TYPE, KONTROLLER IDENTIFIER, UNIT NUMBER, AND SYMBOLS TO USE
IN LINKING THE UNIT CORE BLOCKS TOGETHER (SEE UNITCB MACRO).

EACH XXKON MACRO SHOULD CALL THE KONKON MACRO FOR THE KONTROLLER INDEPENDENT
PART OF THE KONTROLLER CORE BLOCK.  ARGUMENTS FOR KONKON MACRO ARE KONTROLLER
TYPE (XX), KONTROLLER IDENTIFIER (Y), AND SYMBOL XX'NUM WHICH IS THE DEVICE CODE
FOR THE KONTROLLER.  NUM IS INCREMENTED FOR EACH KONTROLLER OF TYPE XX.

THE UNIT CORE BLOCKS ARE LINKED IN THREE DIFFERENT WAYS.  ALL UNIT CORE
BLOCKS ON A KONTROLLER ARE LINKED IN A RING (THE LAST POINTS TO THE FIRST),
ALL UNIT CORE BLOCKS ON A CHANNEL ARE LINKED IN A RING, AND ALL UNIT CORE
BLOCKS IN THE SYSTEM ARE LINKED IN A LIST (THE LAST LINK IS 0).  TO
COMPLETE THIS LINKAGE, KONTCB CALLS MACRO KONCLS TO CLOSE THE KONTROLLER
RING, AFTER ALL UNIT CORE BLOCKS FOR THAT KONTROLLER HAVE BEEN GENERATED; CHNCB
CALLS CHNCLS TO CLOSE THE CHANNEL RING; AND AFTER ALL SYSTEM UNIT CORE BLOCKS
HAVE BEEN GENERATED, SYSCLS IS CALLED TO TERMINATE THE SYSTEM LIST.

TO ADD ANOTHER KONTROLLER TYPE XY, YOU MUST ADD ANOTHER REPEAT LOOP IN CHNCB,
REPEATING CNXY TIMES AND PASSING ARGUMENT XY TO KONTCB MACRO.  KONTCB
CALLS MACRO XYKON FOR THE KONTROLLER DEPENDENT PART OF THE KONTROLLER CORE
BLOCK; THAT MUST ALSO BE SUPPLIED.  XYKON SHOULD CALL THE KONKON MACRO FOR
THE KONTROLLER INDEPENDENT PART OF THE KONTROLLER CORE BLOCK.
>


INTERN	KONERM,KOPOFL,KOPFUS

;DEVICE INDEPENDENT STUFF

KONERM==740000		;MASK FOR ERROR BITS RETURNED IN T1 ON NON-SKIP RETURNS
KOPOFL==400000		;'OFF-LINE' OR 'NOT-READY' OR 'FILE UNSAFE' BIT (LIGHTS UNPOFL IN UNIDES)
KOPFUS==200000		;FILE UNSAFE

DEFINE KONTCB(%TYP)
<KONCB1 (%TYP,<A,B,C,D,E,F,G,H,I,J,K,L>)>

	DEFINE KONCB1(%TYP,TYPL)
<$U==0
IRP TYPL,<IFE $U-$'%TYP'NUM,<STOPI
		IFN %TYP'TYPL'UN,<
			$KNUNN==0	;UNIT NUMBER IN KON
			REPEAT %TYP'TYPL'UN,<%TYP'ITCB (%TYP,TYPL,\$'%TYP'NUM)>
			NMKNUN(%TYP'TYPL,\$KNUNN)==NMKNUN(%TYP'TYPL,0)
			IFIDN <%TYP> <FT>,<NMFTDB(TYPL,\$KNUNN)==>
			%TYP'KON(TYPL,\$'%TYP'NUM)
			$KCHNN==$KCHNN+1>
	IFE %TYP'TYPL'UN,<$'%TYP'NUM==$'%TYP'NUM+1>
		>
	$U==$U+1
>>



;KONTROLLER DATA BLOCK DISK PACKS (ONE DEFINITION NO MATTER
;HOW MANY DISK PACK KONTROLLERS)

;RP10 - CONTROLLER FOR RP01(MEMOREX) DISK PACK UNIT AND/OR RP02
;  (MEMOREX) DISK PACK UNIT:

XP TYPDP,2		;ALWAYS DEFINE CONTROLLER TYPE CODE - SEE UNIKTP

DEFINE DPKON (TYPL,N)<
DPFIX==0			;;NOT A FIXED HEAD DEVICE (IF 0)
KONMXU==10
DPCHN==0
INTCON (DP,TYPL,DP'N)
EXTERNAL DP'N'CHN
KONKON (DP,TYPL,DP'N'CHN)
KONUNL (DP,TYPL)	;GENERATE UNIT LIST
DFCON(DP,TYPL,DP'N)

;;KONTROLLER TYPE DEPENDENT PART OF KONTROLLER DATA BLOCK
DPC==250			;;DEF DISK PACK CONTROLLER DEVICE CODE
DPC2==254			;;AND SECOND CONTROLLER(UNTIL ADDED TO MACRO)
DPINF==10			;;INTERRUPT FLAGS FOR CONSO INSTR.
				;;(DONE FLAGS)

IFNDEF	DP0,<DP0==DPC>		;;DEFINE STANDARD MNEMONIC DEFINITIONS
IFNDEF	DP1,<DP1==DPC2>		;;BUT ALLOW FOR OVERRIDE

	INTERN DPXCO1,DPXDOT,DPXDO1,DPXDI1,DPXCIT

DPXCO1:! CONO	DP'N,(T2)
DPXDOT:! DATAO	DP'N,T1
DPXDO1:! DATAO	DP'N,T2
DPXDI1:! DATAI	DP'N,T2
DPXCIT:! CONI	DP'N,T1
	DEPHASE
$DPNUM==$DPNUM+1
>	;;END MACRO DEF OF DPKON


;RC10 CONTROLLER FOR RD10(BURROUGHS) FIXED HEAD DISK UNIT AND/OR
; RM10B(BRYANT) DRUM UNIT:

XP TYPFH,1			;ALWAYS DEFINE KONTROLLER TYPE CODE - SEE UNIKTP

DEFINE	FHKON (TYPL,N)<

FHFIX==400000			;BIT 0 = 1 IF FIXED HEAD DEVICE
KONMXU==10	;MAX NUMBER OF UNITS THIS KONTROLER
FHCHN==0	;DOES REQUIRE CHANNEL
INTCON (FH,TYPL,FH'N)
EXTERNAL FH'N'CHN
KONKON (FH,TYPL,FH'N'CHN)
KONUNL (FH,TYPL)
DFCON (FH,TYPL,FH'N)

FHD==170
FHD2==174
FHINF==10			;INTERRUPT FLAGS FOR CONSO INSTR.
				;;(DONE FLAG)

IFNDEF	FH0,<FH0==FHD>
IFNDEF	FH1,<FH1==FHD2>

	INTERN	FHXCI1,FHXCOT,FHXCO1,FHXDI2,FHXDOT,FHXIWD

FHXCI1:!CONI	FH'N,T2
FHXCOT:!CONO	FH'N,(T1)
FHXCO1:!CONO	FH'N,(T2)
FHXDI2:!DATAI	FH'N,T3
FHXDOT:!DATAO	FH'N,T1
FHXIWD:!0			;INITWD STORAGE

	DEPHASE
$FHNUM==$FHNUM+1
>	;END MACRO DEF OF FHKON



;3330 CONTROLER

	DEFINE BPKON(TYPL,N)
<BPFIX==0
BPCHN==400000
TYPBP==4	;TYPE 4

KONMXU==BP'TYPL'MX

	KONKON(BP,TYPL,0)
	KONSAX(BP,TYPL,N)
BPXCUB:!	0	;KONTROL UNIT BUSY BITS
	KONUNL (BP,TYPL)
	DEPHASE

INTERNAL BPXCUB
$BPNUM==$BPNUM+1
>

	DEFINE KONSAX(%TYP,TYPL,N)
<
KONBSU:!	XWD NMSCH(\$SAXN,\$SAXCN)+CHNBMX+$SAXUN,%TYP'TYPL
KONBMX==KONBSU	;L.H. POINTER TO BLOCK MULTIPLEX AREA FOR KON
		;R.H. BASE UNIT ADDRESS
KONUMX:! %TYP'TYPL+KONMXU
KONSNT:!%TYP'XINT	;POINTER TO INTERUPT ROUTINE
$SAXUN==$SAXUN+KONMXU
INTERNAL KONBSU,KONBMX,KONSNT
EXTERNAL %TYP'XINT
>

;Macro to generate data blocks for the 2020 disk system.
DEFINE RMKON(TYPL,N)
<RMFIX==0		;Not fixed head.
RMCHN==0		;Operations require channel to be idle
KONMXU==8		;Maximum number of units on this controller
	KONKON(RM,TYPL,0)
	KONUNL(RM,TYPL)
KONCUA:!ZERO18,,0	;UDB of transferring unit
	DEPHASE
INTERN KONCUA
$RMNUM==$RMNUM+1
>

;FOR APX AMPEX F3 DISKS

DEFINE APKON(TYPL,N)<
APFIX==0		;NOT FIXED HEAD
APCHN==0		;CHANNEL MUST BE IDLE
KONMXU==4		;MAXIMUM NUMBER OF UNITS IS 4
	KONKON(AP,TYPL,0)
	KONUNL(AP,TYPL)
KONCUA::!ZERO18,,0	;UDB OF XFERRING UNIT
	XP BLMSIZ,<^D8*^D10>
KONBLM::!BLOCK BLMSIZ+1	;;LIST OF MEMORY ADDRESSES
			;; (IN FORMAT OF LMA DISK INSTRUCTION)
			;; MUST BE ENOUGH TO HOLD ENTIRE CYLINDER.
			;; ONE EXTRA SO THAT ZERO TERMINATES THE LIST.
KONNLM::!BLOCK 1	;PLACE TO STORE ADDRESS OF NEXT LMA TO DO AT IRP LEVEL
KONNLD::!BLOCK 1	;PLACE TO STORE LDA DATA FOR NEXT XFER TO START AT IRP LEVEL
KONNL1::!BLOCK 1	;;COPY OF KONNLD WITH SU SET TO MAKE STARTING XFER FASTER

KONXFR::!BLOCK	1	;;INSTRUCTION TO EXECUTE AFTER A TRANSFER
KONNRM::!BLOCK 1	;;PLACE TO STORE VALUE WE EXPECT ON RMA AT END OF XFER.
			;; (SO DON'T WASTE PRECIOUS INSTRUCTIONS BETWEEN
			;; TRANSFERS OF A CHAIN.
KONNCM::!BLOCK 1	;PLACE TO STORE LCMD DATA FOR NEXT XFER (USUALLY SAME)
KONLRC::!BLOCK 1	;;PLACE TO REMEMBER RCMD OF LAST XFER TO INTERRUPT
KONLRM::!BLOCK 1	;;LAST RMA FOR XFER TO INTERRUPT
KONLRD::!BLOCK 1	;;LAST RDA FOR LAST XFER TO INTERRUPT
	DEPHASE
$APNUM==$APNUM+1
>

;3803 KONTROLLER FOR 3420'S

DEFINE FTKCHN(XX)
<XX==1B32
REPEAT 3-$SAXCN,<XX==XX*2>
>

	DEFINE FTKON(TYPL,N)
<FTFIX==0
FTCHN==0
TYPFT==0

KONMXU==10

	KONKON(FT,TYPL,0)
	KONSAX(FT,TYPL,N)
$SAXUN==$SAXUN+1  ;FOR SPECIAL SENSE LOC.
	KONUNL (FT,TYPL)

	DEPHASE

;OVERLAYING HERE.
	IFL KONLEN-FTXSMY+FTXMCH,<
PRINTX ERROR IN FTKON OVERLAY OF KONT. DB.  SEE COMMOD AT THIS PRINTX.
>
	STAR==.
	RELOC FT'TYPL'CB
	PHASE 0
	FTKCHN YY
FTXMCH:! XWD FT'TYPL'TYP,YY	;TYPE INFO,, CHN NO AS STAT FLG.
FTXBSY:! 0
FTXSNS:! BYTE(8)72,4,FT'TYPL	;SENSE.
FTXDAT:! BYTE(1)1(11)-^D24(24)FTXSTS+FT'TYPL'CB ;INFO TO FTXSTS.
FTXHLT:! Z			;HALT
FTXSS1:! Z
FTXSS2:! Z
FTXSM0:! Z
FTXSMY:! Z			;MEM ERR FLAG,, BUSY BITS
	DEPHASE
	RELOC STAR
	PHASE STAR-FT'TYPL'CB
FTXSTS:! Z
	Z
	Z
	Z
	Z
	Z
FTXSPR:! Z
FTXSP1:! Z
FTXSX1:! Z				;MOST RECENT SAXBAS+1(+5, ETC.)
	DEPHASE

INTERNAL FTXMCH,FTXBSY,FTXSNS,FTXSS1,FTXSPR,FTXSP1,FTXSX1
INTERNAL FTXSS2,FTXSMY,FTXSTS,FTXSM0

$FTMODE==1_D+1_DR+1_B+1_IB+1_I+1_AL+1_A

EXTERNAL MTSIZ
EXTERNAL FTADSP

$FTNUM==$FTNUM+1
>


	DEFINE INTCON (%TYP,TYPL,SYM)

<	EXTERNAL %TYP'XINT,SYM'SAV
	INTERNAL SYM'INT,KONINT

SYM'INT: CONSO	SYM,%TYP'INF		;;(4)SKIP IF INTERRUPT FOR THIS KONTROLLER
				;;ALWAYS HAVE INTERRUPT ROUTINE LOOKING FOR INTERRUPS
				;;THIS FLAG NEVER CLEARED (NEEDED FOR DISK PACKS
				;;OPERATOR MOUNTING AND REMOVING PACKS)
	JRST	.		;;(-3)GO TO NEXT SKIP CHAIN ELEMENT
	JSR	SYM'SAV		;;(-2) SAVE INTERRUPT ACS
	JSP	J,%TYP'XINT	;;(-1) SETUP ADDRESS OF KONTROLLER DATA BLOCK
				;; AND BRANCH INTO CODE WHICH IS COMMON
				;; TO ALL KONTROLLERS OF SAME TYPE
				;; (INTERRUPT DISMISSED BY EXTRA POPJ OR JRST XXRET)
KONINT==SYM'INT-.		;;INDEX TO CLEAR AND SET INTERRUPT CONSO FLAGS
>
	DEFINE KONUNL (%TYP,TYPL)
<;GENERATE UNIT LIST FOR KONTROLLER

	%%KONUS==.
	DEPHASE
%TYP'TYPL'CU:

$U1==0
	REPEAT %TYP'TYPL'UN,<
	NMUN(\$U1,%TYP'TYPL)
	$U1=$U1+1>
	BLOCK KONMXU-$U1	;UNIT ADDRESSES
	PHASE %%KONU+KONMXU
>


;KON:	KONTROLLER DATA BLOCK
;DEFINE FIRST PART OF KONTROLLER DATA BLOCK
;WHICH IS THE SAME FOR ALL KONTROLLER DATA BLOCKS

;FOR EACH KONTROLLER IN SYSTEM:
; PARAMETERS FOR KONKON
; %TYP  - KONTROLLER TYPE (ASCIZ) EG. DP,FH,DR,MD
; TYPL   - KONTROLLER NUMBER SYMBOL (ASCIZ) EG. A,B,C
; SYM - KONTROLLER SYMBOL (ASCIZ) EG. DP0,DP1,FH0,FH1

DEFINE	KONKON (%TYP,TYPL,SYM)<

	INTERN KONPOS,KONRED,KONWRT,KONADD,KONFIN,KONCPY,KONRCL
	INTERN KONLTM,KONCHN,KONPTR,KONOFS
	INTERN KOYPI,KONUPA,KONDWN,KOPDWN,KONSTP,KONHRD,KONSFT

				;; FROM DEV. DEP. CODE
%TYP'TYPL'CB::!	PHASE	0	;;CHANGE PHASE SO CAN DEFINE ALL SYMBOLS
				;; RELATIVE TO BEGINNING OF KONTROLLER
				;; DATA BLOCK. ALSO A CHECK TO BE SURE ALL
				;; KONTROLLER DATA BLOCKS ARE DEFINED THE
				;; SAME WAY.

NMKCN(\$CHN,\$KCHNN)==%TYP'TYPL'CB



;;MACRO DEFINITION CONTINUED
;;ENTRY POINTS INTO KONTROLLER TYPE DEPENDENT CODE:
;;INDIRECT AND INDEX FIELDS MUST BE 0 SINCE PUSHJ P,@KONYYY(J)
;; IS USED TO CALL

IFDIF <%TYP> <FT>, <EXTERN %TYP'XRED,%TYP'XWRT,%TYP'XADD
    EXTERN %TYP'XFIN,%TYP'XPOS,%TYP'XLTM,%TYP'XUPA,%TYP'XCPY
    EXTERN %TYP'XRCL,%TYP'XSTP,%TYP'XOFS,%TYP'XHRD,%TYP'XSFT>

IFIDN <%TYP> <FT>, <%TYP'XRED==0
		%TYP'XWRT==0
		%TYP'XADD==0
		%TYP'XFIN==0
		%TYP'XPOS==0
		%TYP'XLTM==0
		%TYP'XUPA==0
		%TYP'XCPY==0
		%TYP'XRCL==0
		%TYP'XSTP==0
		%TYP'XOFS==0
		%TYP'XHRD==0
		%TYP'XSFT==0
		>

KONRED:!XWD SYM_^D15,%TYP'XRED	;;ENTRY POINT TO READ
KOBPI==KONRED			;;PI CHANNEL THIS KONTROLLER IS ASSIGNED TO-WORD ADR.
  KOSPI==^D3			;;BYTE SIZE
  KONPI==^D2			;;BYTE PTR POS.
KONWRT:!XWD ZERO5,%TYP'XWRT	;;ENTRY POINT TO WRITE
KONADD:!XWD ZERO5,%TYP'XADD	;;ENTRY POINT TO READ,STOP ON ERR
KONFIN:!XWD ZERO5,%TYP'XFIN	;;ENTRY POINT TO WRITE,STOP ON ERR
KONPOS:!XWD %TYP'FIX!ZERO5,%TYP'XPOS ;;ENTRY POINT TO POSITION-BIT 0=1 IF FIXED HEAD DEV.
KONLTM:!XWD %TYP'CHN,%TYP'XLTM	;;ENTRY POINT TO RETURN TIME TO BEGINNING OF TRANSFER
				;; I.E. LATENCY TIME
KONUPA:!XWD ZERO5,%TYP'XUPA	;;ENTRY POINT TO TEST IF KONTROLLER IS ON-LINE
KONDWN==KONUPA			;;BIT0=1 IF KONTROLLER IS DOWN - WORD ADDRESS
  KOPDWN==400000		;; THE BIT (SET BY KONCHK - NOT BY %TYP'XUPA)
				;;KONTROLLER WAS OFF-LINEWHEN SYSTEM STARTED
				;; AND OPERATOR COULD NOT PUT IT ON-LINE
				;; SKIP RETURN IF YES, NO SKIP IF NOT

KONCPY:!XWD ZERO5,%TYP'XCPY	;;ENTRY POINT TO DETERMINE TYPE & CAPACITY OF UNIT
KONRCL:!XWD ZERO18,%TYP'XRCL	;;ENTRY POINT TO RECALIBRATE THIS UNIT
				;; NO-SKIP IN UNIT DOES NOT RECALIBRATE OR IS BAD
				;; SKIP RETURN IF RECALIBRATE STARTED OK
KONSTP:!XWD ZERO5,%TYP'XSTP	;;ENTRY POINT TO STOP A HUNG DISK
				;; NO-SKIP IF CAN'T, SKIP IF CAN
KONOFS:!XWD ZERO5,%TYP'XOFS	;;ENTRY POINT TO SET UNIT IN OFFSET MODE
KONHRD:!XWD ZERO5,%TYP'XHRD	;;ROUTINE TO CALL FOR HARD ERRORS
KONSFT:!XWD ZERO5,%TYP'XSFT	;;ROUTINE TO CALL FOR SOFT ERRORS
KONLEN==KONSFT-KONRED	;FTKON OVERLAYS UNNEEDED KONT. DB LOCS.
KONCHN:!XWD NMKCN(\$CHN,\<$KCHNN+1>),NMCH(\$CHN)	;;ADDRESS OF CHANNEL DATA BLOCK TO WHICH THIS KON
				;; CONNECTED (@USED TO TEST CHANNEL BUSY)
KONPTR:!XWD ZERO5,%TYP'TYPL'CU(P3) ;;USED TO PICKUP UNIT DATA BLOCK ADDRESS
				;; GIVEN PHYSICAL UNIT NUMBER IN AC P3. (@ USED)

>


	DEFINE DFCON (%TYP,TYPL,SYM)
<	INTERNAL KONCOM,KONCUA,KONIOC,KONSWC
EXTERNAL LOCOCW
KONSWC:!0		;SAVE WORD COUNT FOR THIS OPERATION
KONCOM:!XWD -CCWMAX,%TYP'TYPL'CB+KONLST
KONLST:!BLOCK CCWMAX
	0
KONCUA:!XWD ZERO18,0		;;CURRENT UNIT DATA BLOCK ADDRESS DOING
				;; DATA TRANSFER (OR LAST ONE)
KONIOC:!XWD ZERO18,SYM'IOC	;;CONTAINS ADR. OF LOWER CORE CHANNEL 
				;; PAIR FOR THIS PHYSICAL KONTROLLER
				;; (DIFF. PAIR FOR EACH KONTROLLER SO NO
				;;CHANNEL CONFLICT IF RECONFIGURE CHANNELS)
XP SYM'IOC,LOCOCW+$LOCW
$LOCW==$LOCW+2
KONINS:!			;;ADD IO INSTRUCTIONS AND ALL DATA LOCATIONS HERE:

>		;;END KONKON MACRO (SAME FOR ALL KONTROLLERS)

;;BYTE POINTERS
KOYPI:	POINT KOSPI,KOBPI(J),KONPI     ;;PI CHANNEL THIS KONTROLLER ASSIGNED TO

;INTERUPT COMMUNICATION BITS

KCMPOS==(1B7)	;SPECIAL POSITION INTERUPT (U IS UNIT)
KCMRER==(1B8)	;RECOVERED ERROR
KCMFUS==(1B9)	;FILE UNSAFE
KCMERR==(1B10)	;ERROR
KCMDTA==(1B11)	;DATA TRANSFER
KCMIOS==(1B12)	;I/O SELECT NEEDED (ONLY SET BY DEV-INDEP)
KCMOFL==(1B13)	;OFF-LINE

INTERNAL KCMOFL,KCMRER,KCMFUS,KCMERR,KCMDTA,KCMIOS,KCMPOS


;UNI:	UNIT DATA BLOCK

;PARAMETERS FOR UNITCB
;%TYP	- KONTROLLER TYPE (E.G. FH,DP,MD)
;TYPL	- KONTROLLER IDENTIFIER (STARTS AT A)

;UNI:	UNIT DATA BLOCK
;POINTED TO BY EACH STR (FANOUT)(STRTAB)
;POINTS TO NEXT UNI IN SYS (ACCROSS POINTER)(LH UNISYS)
;POINTS TO NEXT UNI WITHIN CHANNEL (RING)(RH UNICHN)
;POINTE TO NEXT UNI WITHIN KONTROLLER(ACCROS POINTER)(LH UNIKON)
;POINTS TO ITS CHN (UPWARD PTR)(RH UNICHN)
;POINTS TO ITS KON (UPWARD PTR)(RH UNIKON)
;POINTS TO NEXT UNI IN STR(ACCROSS PTR)(LH UNISTR)
;POINTS TO ITS STR DATA BLOCK(UPWARD POINTER)(RH UNISTR)

%NUN (INTERNAL,\$KNUNN,%TYP'TYPL)
IFNDEF FIRUNI,<FIRUNI:>	;;DEFINE FIRST UNIT DATA BLOCK ADR. IN SYSTEM
NMUN(\$KNUNN,%TYP'TYPL):	%SUN(\$KNUNN,%TYP'TYPL)
UNINAM==0	;;(0)SIXBIT PHYSICAL UNIT NAME WITHIN KONTROLLER
		;;LAST DIGIT IS 0 TO 7 -LEFT JUSTIFIED
		;; EXAMPLE:  DRA0,FHA0,MDA0,DPA0;;DPA1,DPB3
		;;[NEVER CHANGED BY MONITOR]

	PHASE	1
UNILOG:!0	;;(1)SIXBIT LOGICAL UNIT NAME WITHIN STR
		;; LAST DIGIT OR TWO IS 0 TO 77 LEFT JUSTIFIED
		;; EXAMPLE:  DSKA0,DSKB0,DSKC0;;DSKA17 [SET FROM HOMLOG BY HOMRED]
UNIHID:!0	;;(2)SIXBIT HOME BLOCK IDNAME - NEVER CHANGED IN HOME BLOCK
		;; SET WHEN SECTOR HEADERS ARE WRITTEN.  FOR DISK PACKS
		;; THE HOME BLOCK ID NAME IS THE PACK ID.
NMSYUN(\$SYUNN)==NMUN(\$KNUNN,%TYP'TYPL)
UNISYS:!XWD NMSYUN(\<$SYUNN+1>),0 ;;(3)LH=CORE ADDRESS(ACCROSS POINTER) OF NEXT
		;; UNIT DATA BLOCK IN SYSTEM, LH=0 IN LAST UNIT IN SYSTEM
UNILUN==UNISYS	;;RH. LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT-WORD ADR.
  UNSLUN==^D6	;;BYTE SIZE
  UNNLUN==^D35	;;BYTE PTR POS.

UNISTR:!0	;LH=ADDRESS OF NEXT UNIT DATA BLCOK IN STR
		;LH=0 IN LAST UNIT IN FILE STRUCTURE
		;RH=UPWARD POINTER TO FILE STR. DATA BLOCK.
		;WORD=0 IF THIS UNIT IS NOT IN A STR

NMCHUN(\$CHN,\$CHUNN)==NMUN(\$KNUNN,%TYP'TYPL)
UNICHN:!XWD NMCHUN(\$CHN,\<$CHUNN+1>),NMCH(\$CHN)	;;(5)LH=ADDRESS OF NEXT UNIT DATA BLOCK ON SAME CHANNEL
		;; LAST UNIT POINTS BACK TO FIRST UNIT (RING)
		;; RH=UPWARD POINTER TO CHANNEL DATA BLOCK.
NMKNUN(%TYP'TYPL,\$KNUNN)==NMUN(\$KNUNN,%TYP'TYPL)
UNIKON:!XWD NMKNUN(%TYP'TYPL,\<$KNUNN+1>),%TYP'TYPL'CB	;;(6)LH=ADDRESS OF NEXT UNIT DATA BLOCK ON SAME KON
		;; LAST UNIT POINTS BACK TO FIRST UNIT (RING)
		;; RH=UPWARD POINTER TO KONTROLLER DATA BLOCK
	XWD 0,0	;; (7) PLACE HOLDER FOR OBSOLETE ENTRY

;ERROR STATISTICS:
UNIHCT:!0	;;(10)NO. OF HARD DISK ERRORS ON THIS UNIT (RETRYS FAILED TO CLEAR ERROR)
		;; LH=NO. DEVICE+SEARCH ERRORS(IODERR)(CHAN+CONTROL)(SEE UNIPCT)
		;; RH=NO. DATA ERRORS(IODTER)(HARDWARE PARITY AND SEARCH)
UNISCT:!0	;;(11)NO. OF SOFT + NO. OF HARD ERRORS - INCREMENTED ON EVERY ERROR
		;; INTERRUPT
		;;LH=NO. SOFT+HARD DEVICE+SEARCH ERRORS(SEE UNIPCT)
		;; RH=NO SOFT+HARD DATA ERRORS
UNIMCT:!0	;;(12)NO. OF MONITOR DETECTED ERRORS(3 12 BIT FIELDS)
		;; USER PROGRAM SEES IOIMPM ERROR BIT SET FOR ALL 3 TYPES OF ERRORS
  UNPSER==100	;;NO. OF SAT FAILURES(NO. OF FREE BIT-PAIRS ON DISK SAT
		;; DISAGREE WITH EXPECTED NO AS STORED IN CORE)
  UNPRER==10000	;;NO. OF RIB REDUNDANT INFO FAILED TO COMPARE
  UNPCER==1	;;NO. OF SOFTWARE FOLDED CHECKSUM FAILURES(SWAP+USER IO)
		;; (MUST BE RIGHT JUSTIFIED FOR AOS)
UNIERR:!0	;;(13)LAST HARD ERROR DEVICE STATUS(IE STYTRY TIMES FAILED IN A ROW)
		;; WHICH OCCURRED ON THIS UNIT. SET BY MOVEM T2,UNIERR(U)
		;; IN FILSER WHERE T2 IS SET DIRECTLY FROM
		;; KONTROLLER STATUS WORD IN KONTROLLER DEPENDENT ROUTINE.
UNISOF:!0	;;(14)LAST SOFT OR HARD ERROR DEVICE STATUS
UNIHBN:!0	;;(15)LAST LOGICAL BLOCK NUMBER ON HARD ERROR

;;PERFORMANCE MONITORING DATA LOCATIONS:!
;;NOTE FOLLOWING 6 ENTRIES ARE MUTUALLY EXCLUSIVE AND ACCOUNT FOR ALL
;; TRANSFERS ON THIS UNIT(EXCEPT ERROR RETRYS)
;WRITE COUNT MUST BE READ COUNT+1
UNIBRC:!0	;;(16)NO. OF BUFFERED MODE 128 WORD BLOCKS READ
UNIBWC:!0	;;(17)NO. OF BUFFERRED MODE 128 WORD BLOCKS WRITTEN
UNIDRC:!0	;;(20)NO. OF DUMP MODE 128 WORD BLOCKS READ(INCLUDEING GETS)
UNIDWC:!0	;;(21)NO. OF DUMP MODE 128 WORD BLOCKS WRITTEN(INCLUDING SAVES)
UNIMRC:!0	;;(22)NO. OF MONITOR PAGES READ(SAT,UFD,MFD,BAT)
UNIMWC:!0	;;(23)NO. OF MONITOR PAGES WRITTEN(
		;; SAT,UFD,MFD,BAT)
UNIHNG:!0	; NO OF HUNG TIME OUTS WHICH COUNT NOT BE RECOVERED
		;LH HUNG FROM TRANSFER, RH OTHER (POSITION)


UNIICT:!0	;;(24)NO. OF 128 WORD BLOCKS SWAPPED IN(SET BY SWPINT)
UNIOCT:!0	;;(25)NO. OF 128 WORD BLOCKS SWAPPED OUT(SET BY SWPINT)
;;NOTE:!FOLLOWING 2 ENTRIES ARE MUTUALLY EXCLUSIVE AND ACCOUNT FOR ALL SEEKS
;; ON THIS UNIT EXCEPT END OF CYLINDER ADN RECALLIBRATION AND SEEK UUOS
UNIMSC:!0	;;(26)COUNT OF NO. OF MONITOR+SWAP SEEKS
UNIUSC:!0	;;(27)COUNT OF NO. OF USER(BUFFER+DUMP) SEEKS
		;; (INCLUDES GETS AND SAVES)

;;MORE ERROR STATISTICS:!
	0	;;(31) PLACE HOLDER FOR OBSOLETE ENTRY
UNISDI:!0	;;(32)LAST SOFT OR HARD ERROR DATAI IN STATUS WORD
		;; DATA,DEVICE,SEARCH ERRORS
UNIHDI:!0	;;(33)LAST HARD ERROR DATAI IN STATUS WORD
		;; DATA,DEVICE,SEARCH ERRORS
UNIECT:!0	;;(34) NO. OF CONSECUTIVE TIMES AN ERROR STATUS WAS RETURNED
		;; FOR THE LAST OPERATION ON THIS UNIT. (IE, FIRST+RETRIES
		;; WITH ERRORS).  SET BACK TO 1 ON FIRST ERROR, RATHER THAN
		;; BEGINNING OF NEW OPERATION, SO USER PROGRAMS HAVE MORE
		;; TIME TO LOOK AT IT.
UNISBN:!0	;;(35) BLOCK NUMBER WITH LAST SOFT ERROR
UNISTS:!0	;;STATUS WORD FOR UNIT - SET, CHANGED BY FILSER ONLY
		;;ONLY WHOLE WORD USED SO THAT EXCH TRICK CAN BE USED
		;;THESE SAME CODES ARE USED IN DEYCOD BYTE

UNIQUE:!XWD 0,0	;;LH=ADDRESS OF FIRST (LONGEST WAITING) DEVICE DATA BLOCK (FILE)
		;; IN POSITION WAIT FOR THIS UNIT (PW QUEUE)
		;;RH=ADDRESS OF LAST (SHORTEST WAITING) DEVICE DATA BLOCK (FILE)
		;; IN POSITION WAIT FOR THIS UNIT
		;;AS A FLAG, BOTH HALVES ARE SET TO 0 WHEN NO FILES IN
		;; POSITION WAIT QUEUE.
		;;NOTE:!THE FILE WHICH IS IN P STATE IS NOT IN QUEUE
		;; QUEUE SEARCH
UNICDA:!0	;;RH=CURRENT DEVICE DATA BLOCK ADDRESS OF FILE CURRENTLY
		;; POSITIONING OR TRANSFERRING ON THIS UNIT
UNIPPU:!0	;;NO. OF LOGICAL PAGES PER UNIT(RETURNED BY DSKCHR)
		;; SET BY TESTING IN ONCMOD



UNICHR:!0	;;UNIT CHARACTERISTICS (RETURNED IN DSKCHR M);;
UNIBPT==UNICHR	;;BITS 9-17= # BLOCKS/TRACK - SET BY TESTING IN ONCMOD
  UNSBPT==^D9
  UNNBPT==^D17
UNIPPY==UNICHR	;;BITS18-35= # PAGES/CYLINDER (THE SMALLEST IF CYLINDER
  UNSPPY==^D18	;; HAVE DIFFERENT SIZES (MDF)) - SET BY TESTING IN ONCMOD
  UNNPPY==^D35
UNIWPS:!0	;;# OF WORDS PER SAF BLOCK ON DISK FOR THIS UNIT-WORD ADR.
		;; LIMITED TO 128 WORDS OR CLUSTER SIZE WHICHEVER IS SMALLER
		;;BIT 9 UNUSED.
  UNSWPS==^D9	;;BYTE SIZE
  UNNWPS==^D8	;;BYTE PTR. POS.
UNISPU==UNIWPS	;;NO. OF SAT BLOCKS ON THIS UNIT - WORD ADR.
  UNSSPU==^D8	;;BYTE SIZE
  UNNSPU==^D17	;;PYTE PTR POS.
UNICYL:!-1	;;PHYSICAL CYLINDER UNIT IS CURRENTLY AT OR POSITIONING TOWARDS.
		;; THIS IS ONLY WORD SET AND LOOKED AT BY DEVICE DEPENDENT ROUTINE.
		;; USED BY FILSER TO SEE IF UNITS IN POSITION, NEVER CHANGED BY FILSER
		;; INITIALIZE TO -1 SO FORCE POSITIONING FOR FIRST READ
		;; ELSE GET POSITIONING ERROR AND FALSE ERROR DATA
UNIBLK:!0	;;LOGICAL BLOCK NUMBER WITHIN THE UNIT.
		;; ARG TO DEVICE DEPENDENT ROUTINES
UNISTT:!0	;;LH IS UNDEFINED.
		;;RH=ADDR OF STT FOR THIS UNIT.
UNITAL:!0	;;NO. OF FREE BLOCKS(RESERVED+FCFS) LEFT ON THIS UNIT
		;; [NO SAFETY FACTOR FOR UNIT
		;; INSTEAD THERE IS ONE FOR THE STR]
UNIDES:!BYTE (10)0(8)%UNSZ(\$SYUNN)(3)$CHN(6)TYP'%TYP(3)$'%TYP'NUM(2)0(4)$KNUNN


		;;WORD RETURNED IN AC FOR DSKCHR M DESCRIBES THIS DISK
		;; UNIT IN TERMS OF STR NUMBER, CHANNEL,
		;; KONTROLLER UNIT NUMBER. ETC.
		;; $K   = BINARY NUMBER OF NEXT UNIT ON KONTROLLER (STARTS AT 0)
		;; $CHN = BINARY CHANNEL NUMBER (STARTS AT 0)
		;; XX   = BINARY KONTROLLER NUMBER (STARTS 0 FOR EACH KONTROLLER TYPE)
		;;HENCE, UNIDES RH=(3)CHANNEL NUM(6)KONTROLLER TYPE
		;; (3)KONTROLLER NUM(3)UNIT TYPE(3)UNIT NUMBER
  UNPOFL==200000 ;;BIT 1=1 IF THE UNIT IS OFF U
  UNPHWP==100000 ;;BIT 2=1 IF THE UNIT IS HARDWARE WRITE PROTECTED
  UNPCHG==040000 ;;TIMESHARED BIT-A PARAMETER WAS CHANGED SO HOME BLOCK MUST BE WRITTEN
		;;  USED ONLY DURING ONCE ONLY CODE THEN CLEARED BEFORE SYSTEM STARTED
  UNPPRV==020000	;BIT 4=THIS IS A PRIVATE PACK.
 UNPFUS==4000	;BIT 6=1 IF FILE UNSAFE.
  UNPRRS==2000	;;BIT 7=1 IF UNIT NEEDS READ AND RESET BUFFERED LOG
		;; EITHER SINGLE ACCESS OR WRITE PROTECTED FROM ALL JOBS
  UNPMSB==400	;;BIT 9=1 IF THIS UNIT HAS MORE THAN ONE SAT BLOCK


UNISIZ==UNIDES	;;SIZE OF UNIT DATA BLOCK
  UNSSIZ==^D8	;;BYTE SIZE
  UNNSIZ==^D17	;;BYTE PTR POS.

		;;BITS 15 - 17 ARE A CODE WHICH TELLS WHETHER THE ARGUMENT PASSED TO
		;; MONITOR IN LOC WAS:(NEVER STORED IN UNIT DATA BLOCK)
		;; 0	GENERIC DEVICE DSK OR LOGICAL NAME FOR IT (E.G., DSK)
		;; 1	SUBSET OF STR BECAUSE OF AN STR ABBREVIATION
		;; 2	STR NAME OR LOGICAL NAME FOR IT (E.G., DSKA)
		;; 3	UNIT WITHIN A FILE STRUCTURE OR A LOGICAL NAME FOR IT
		;; 	(E.G., DSKA0)
		;; 4	A KONTROLLER CLASS NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DR,FH,DP,MD)
		;; 5	A KONTROLLER NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DRA,FHA,DPA,MDA,DPB)
		;; 6	A PHYSICAL DISK UNIT NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DRA0,DPA3)
		;;RH CONFIGURATION INFORMATION:
UNISCN==UNIDES	;;BITS 18-20 DATA CHANNEL NUMBER SOFTWARE THINKS HARDWARE IS
  UNSSCN==^D3	;; CONNECTED TO.  STARTS AT 0 SO FIRST DATA CHANNEL IS 0.
  UNNSCN==^D20	;;BYTE PTR POS.
UNIKTP==UNIDES	;;BITS 21-26 CONTROLLER TYPE
  UNSKTP==^D6	;;BYTE SIZE
  UNNKTP==^D26	;;BYTE PTR POS.
  TYPDR==0	;; 0	DR (FUTURE DRUM, IF ANY)
  TYPFH==1	;; 1	FH (BURROUGHS DISK OR BRYANT DRUM)
  TYPDP==2	;; 2	DP (MEMOREX RP01,RP02)
  TYPMD==3	;; 3	MD (BRYANT MASS DISK)
  TYPRM==5	;; 5    RM (RH11C CONTROLLER FOR RM03, RP06 UNITS)
  TYPAP==6	;; 6	AP (AMPEX OR CDC DISKS FOUND ON F3)
INTERN TYPRM	;;USED BY FILIO.
UNIKNM==UNIDES	;;BITS 27-29 KONTROLLER NUMBER.  STARTS AT 0, SO FIRST KONTROLLER OF
  UNSKNM==^D3	;; EACH TYPE STARTS AT 0.  (E.G., DPA=0,DPB=1,ETC.)
  UNNKNM==^D29	;;BYTE PTR POS.
UNIUTP==UNIDES	;;BITS 30-32 UNIT TYPE - A KONTROLLER DEPENDENT FIELD USED TO
  UNSUTP==^D2	;; DISTINGUISH VARIOUS OPTIONS OF A UNIT ON ITS KONTROLLER
  UNNUTP==^D31	;;BITS 21-26   BITS 30-32
		;;	0	     0
		;;	1	     0	BURROUGHS DISK ON RC10
		;;		     1	BRYANT DRUM ON RC10
		;;	2	     0	RP01
		;;		     1	RP02
		;;	3	     0	DUAL POSITIONER
		;;		     1	SINGLE POSITIONER
		;;	5	     0  RM03 UNIT
		;;		     1  RP06 UNIT
  UNPUTP==20	;;THE BIT
UNIPUN==UNIDES	;;BITS 33-35 PHYSICAL UNIT NUMBER WITHIN KONTROLLER - STARTS AT 0 FOR
  UNSPUN==^D4	;; EACH KONTROLLER SO FIRST UNIT IS 0
  UNNPUN==^D35	;;BYTE PTR POS.

	0	; Place holder for obsolete entry
	0	;   "	  "	"	"	"
UNIRCT:!0	;;HOLDRS RETRY COUNTS FROM DEVICE DEPENDENT CODE
UNIRTY==UNIRCT	;;NUMBER OF TIMES TO RETRY BEFORE RECAL
 UNSRTY==^D9
 UNNRTY==^D35	;POSITION OF FIELD
UNIRCL==UNIRCT	;;NUMBER OF TIMES TO RECALIBRATE
 UNSRCL==^D9
 UNNRCL==^D26
UNIRRT==UNIRCT	;;NUMBER OF TIMES TO RETRY BETWEEN RECALS
 UNSRRT==^D9
 UNNRRT==^D17

 UNPDEV==001000	;;FLAG THAT THIS WAS A DEVICE ERROR NOT DATA ERROR

UNIFCT:!0	;;FAIRNESS COUNT (USED ON UNITS WHICH POSITION)
UNIDIR:!0	;;ON UNITS WHICH POSITION, BIT 0 IS DIRECTION OF
		;;LAST POSITION
UNITIM==UNIDIR	;;TIMER FOR HUNG DEVICE (AND OFF-LINE)
 UNSTIM==6	;;SIZE
 UNNTIM==6
UNIPAC==UNIDIR	;;ACTIVE PAGE POINTER FOR PAGE REQ'S
 UNSPAC==^D13	;;SIZE
 UNNPAC==^D19	;;LOCATION
UNIPGL==UNIDIR	;;LIST OF PAGES TO DO REQUESTS FOR (POINTER TO FIRST)
 UNSPGL==^D13	;;SIZE
 UNNPGL==^D32	;;LOCATION
UNIPPL==UNIDIR	;;NUMBER OF BLOCKS OF PAGE COMPLETED (IN CASE OF ERROR)
 UNSPPL==2	;;SIZE
 UNNPPL==^D34	;;LOCATION

UNIRC1:!0	;;SECOND CELL USED BY E.R.
 UNIOCV==UNIRC1	;;STATE OF OFFSET E.R. 0 IMP FINISHED; ODD IMP AWAY,
  UNSOCV==^D9			;; EVEN IMP TOWARDS SPINDLE. (VARIABLE W)
  UNNOCV==^D35
 UNIRTO==UNIRC1	;;NUMBER OF TIMES TO RETRY AFTER OFFSET (PARAMETER X)
  UNSRTO==^D9
  UNNRTO==^D26
 UNIRCO==UNIRC1	;;NUMBER OF TIMES TO RECAL AFTER RETRIES AFTER OFFSET
  UNSRCO==^D9			;; (PARAMETER Y)
  UNNRCO==^D17
 UNIOS==UNIRC1	;;1 IFF SHOULD ENTER OFFSET MODE BEFORE STARTING A TRANSFER
  UNSOS==^D1
  UNNOS==^D7

$SYUNN==$SYUNN+1
$KNUNN==$KNUNN+1
$CHUNN==$CHUNN+1
>	;;END MACRO DEF OF UNITCB




	DEFINE DPITCB(%TYP,TYPL,N)
<	UNITCB (%TYP,TYPL)
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE>

	DEFINE RMITCB(%TYP,TYPL,N)
<	UNITCB(%TYP,TYPL)
UNISVA:!0		;Starting virtual address of transfer on unit.
UNITWC:!0
UNIOFS:!0
	XP SBSIZ,11	;NUMBER OF WORDS NEEDED TO SAVE RH11 REGISTERS.
UNISBH:!BLOCK SBSIZ	;RH11C/Rm03 registers of most recent hard error.
UNISBS:!BLOCK SBSIZ	; ditto for soft errors.
UNISB:!	BLOCK SBSIZ	;RH11C/RM03 registers saved here on error.
	; 0,10,14,42,2,12,4,16,20,22,24,26,30,32,34,40,6,44 saved in
	; that order (see SAVSTS in RM03), two per word, first in Lh.
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
INTERN UNISVA,UNITWC,UNIOFS>

	DEFINE APITCB(%TYP,TYPL,N)
<	UNITCB(%TYP,TYPL)
	XP SBSIZ,4	;NUMBER OF LOCATIONS NEEDED TO SAVE F3 DISK REGISTERS
UNISBH::!BLOCK SBSIZ	;CONTROL REGISTERS OF MOST RECENT HARD ERROR
UNISBS::!BLOCK SBSIZ	;SAME FOR SOFT ERRORS
UNISB::! BLOCK SBSIZ	;USED BY DEVICE DEPENDENT ROUTINE
UNITWC::! BLOCK 1	;TOTAL WORD COUNT, FOR INTERRUPT LEVEL CHECING
UNISVA::! BLOCK 1	;PLACE TO SAVE MEMORY ADDRESS
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
>
IFCPU (<KI,KL>),<
UNISB==0
UNISBH==0
UNISBS==0>

INTERN UNISB,UNISBS,UNISBH

	DEFINE FHITCB(%TYP,TYPL,N)
<	UNITCB(%TYP,TYPL)
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE>

	DEFINE BPITCB(%TYP,TYPL,N)
<	UNITCB(%TYP,TYPL)
UNISWC:!0	;SAVE WORD COUNT FOR THIS OPERATION
UNICNA:!0	;CONTINUE ADDRESS FOR LARGE TRANSFERS
UNICNC:!0	;CONTINUE COUNT
UNICCC:!0	;CURRENT COUNT IF TRANSFER BROKEN
UNISNS:!BYTE (8) 72,4,$KNUNN+BP'TYPL-1	;SENSE COMMAND
	BYTE (12) -^D24 (24) UNISND+NMUN(\<$KNUNN-1>,%TYP'TYPL)
	BYTE (8) 200
UNISND:!BLOCK 6		;READ SENSE INFORMATION HERE
UNISNC:!0	;NUMBER OF SENSES DONE
UNISVC:!0	;SAVE COUNT HERE ON SENSE
UNISCM:!0	;SAVE COMMAND HERE ON SENSE
UNIACT:!0	;SAVE CHANNEL ACTIVE COUNT FOR HUNG
UNICOM:!-BPCMSZ,,.+1+NMUN(\<$KNUNN-1>,%TYP'TYPL)
	BLOCK BPCMSZ
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
>

IFCPU (<KI,KL>),<	;**D*
	INTERNAL UNICOM,UNISWC,UNICNA,UNICNC,UNICCC,UNIACT
	INTERNAL UNISNS,UNISND,UNISVC,UNISCM,UNISNC
>; END IFCPU (<KI,KL>)
;SIZE OF 3330 COMMAND LIST IS ENOUGH FOR 1 TRACK (18 RECORDS)
;THIS IS 18*7 (7 PER RECORD. 2 DATA ADDRS 2 TRANSFER 3 SEARCH AND
;TIC) +1 FOR STOP +3 FOR SET SECTOR AND SET SECTOR DATA
;+2 FOR SEEK (DATA SAME AS FOR FIRST SEARCH ID) +1 IN CASE
;LAST TRANSFER IS IN 2 PARTS (CRROSSES PAGE BOUNDARY)

BPCMSZ==^D<18*7+1+3+2+1>


DEFINE NMFTDB(TYPL,NUMM)
<FT'TYPL'NUMM'DB>

DEFINE NMFTDI(TYPL,NUMM)
<INTERNAL FT'TYPL'NUMM'DB>

DEFINE SYFTNM(NM)
<%SYF'NM>

DEFINE FTDDB(TYPL,NUMM)
<NMFTDB(TYPL,\NUMM): PHASE 0
IFE NUMM,<FT'TYPL'DDB==NMFTDB(TYPL,\NUMM)
	NMFTDI(TYPL,D)>
DEVNAM:!%SUN(\NUMM,FT'TYPL)
DEVCHR:!XWD 7*HUNGST,MTSIZ+1
DEVIOS:!Z
DEVSER:!XWD NMFTDB(TYPL,\<NUMM+1>),FTADSP
DEVMOD:!XWD DVIN+DVOUT+DVMTA,$FTMODE
DEVLOG:!Z
DEVBUF:!Z
DEVIAD:!0
DEVOAD:!0
DEVCLS:!XWD 600000,DEVLSA+NMFTDB(TYPL,\NUMM)
DEVSTS:!Z
DEVABC:!Z
DEVBWC:!Z
DEVLSA:!BLOCK LENFXL
DEVUDB:!NMUN(\NUMM,FT'TYPL)	;STORAGE FOR DR,, UNIT DB ADDR.
DEVCNT:!Z
DEVFNJ:!Z			;FN IN PROGRESS,,IBM 9 TRK ADJ.
DEVADD:!<FT'TYPL+$KNUNN>*10000
DEVDWC:!Z
DEVER1:!Z
DEVER2:!Z
DEVOUT:!Z
DEVINS:!Z
DEV40:! Z
DEVNOI:!Z
DEVACT:!Z
DEVDIO:!Z			;LH UNUSED, RH USED FOR PGYDIO
				;CALCULATIONS.


INTERNAL DEVUDB,DEVCNT,DEVFNJ,DEVADD,DEVDWC,DEVER1,DEVER2
INTERNAL DEVNOI,DEVINS,DEV40,DEVOUT,DEVACT,DEVDIO
NMFTDI(TYPL,\NUMM)

XP FT'TYPL'DDS,.
INTERNAL FT'TYPL'DDS

DEPHASE
>


INTERNAL FTCMLN
FTCMLN==104

	DEFINE FTITCB (%TYP,TYPL,%%N)
<%NUN(INTERNAL,\$KNUNN,%TYP'TYPL)
NMUN(\$KNUNN,%TYP'TYPL):
SYFTNM(\$SYFTN)==.

	PHASE 0
UNIDDB:! NMFTDB(TYPL,\$KNUNN)	;ADDR OF ASSOCIATED DDB.

UNILNK:! SYFTNM(\<$SYFTN+1>)

;ERROR REPORTING.
FDHFUN:! Z		;FN IN PROGRESS WHEN DEVICE HUNG.
FDHCNT:! Z		;# OF TIMES UNIT HAS HUNG.
FDHCNI:! Z
FDCNI1:! Z
FDCNIE:! Z
FDNRE1:! Z		;# READS NOT SUCCEEDING ON 1ST TRY.
FDNWR1:! Z		;# WRITES NOT SUCCEEDING ON 1ST TRY.
FDNREE:! Z		;" READS     "       "   EVER.
FDNWRE:! Z		;" WRITES    "       "   EVER.
FDERBT:! Z
FDSENS:! Z
	Z
	Z
	Z
	Z
	Z
FDSCHR:! Z
	Z
	Z
	Z
	Z
	Z
FDMEMR:! Z		;INFORMATION ABOUT THE LAST MEM ERR
			;SEEN (CHNMER COPY).

INTERNAL FDHFUN,FDHCNT,FDHCNI,FDCNI1,FDCNIE,FDNRE1
INTERNAL FDNWR1,FDNREE,FDNWRE,FDERBT,FDSENS,FDMEMR,FDSCHR

;END OF ERROR REPORTING.

UNIKNT:! XWD NMCH(\$CHN),FT'TYPL'CB  ;CHAN DB,,KONT DB.
UNIERO:! BLOCK 7		;ERROR SPACE IS HERE TO UNICMD.
UNICMD:! BLOCK FTCMLN		;NORMAL COMMAND SPACE IS FROM
UNIDON:!			;UNICMD TO UNIDON.
UNIDCR:! BLOCK 1		;DURING DATA CHECK-READ RECOVERY
				;READ CMD SAVED HERE,
UNIDCN:! BLOCK 1		;NEXT CMD SAVED HERE,
UNIDC1:! BLOCK 1		;POINTER TO READ SAVED HERE.
UNITYP:! Z			;LH=7/9 TRK, DENS.
				;RH=FOR HUNG ROUTINE.(SIGN BIT MUST
				;BE 0).
UNISX1:! Z			;MOST RECENT SAXBAS+1(+5, ETC.)
				;FOR THIS UNIT.
UNISX2:! Z			;SAXBAS+2, OR +6, ETC.
UNISX3:! Z			;SAXBAS+3, OR +7, ETC.
$SYFTN==$SYFTN+1		;NO. OF FT UNITS ON SYSTEM.

FTULNH==.-UNIDDB+1
DEPHASE

FTDDB(TYPL,$KNUNN)

INTERNAL UNIDDB,UNILNK,UNIKNT,UNIERO,UNICMD,UNIDON,UNIDCR
INTERNAL UNIDCN,UNIDC1,UNITYP,FTULNH,UNISX1,UNISX2,UNISX3
$KNUNN==$KNUNN+1
%'%TYP'TYPL'0==0	>

IFNDEF MAGUN,<
  IFNCPU(<KS,F3>),<XP MAGUN,0>
  IFCPU(<KS,F3>),<XP MAGUN,1>
  > ; End IFNDEF MAGUN
IFN MAGUN,<;IF ANY KS10 OR F3 STYLE TAPE CONTROLLERS
;Magtape data structures: KDB, UDBs, DDBs
;Note: the KS-10 allows only one TM03 and a maximum of 4 TU45s.

;UDB.
DEFINE MTUDB(NUMBER),<
TU'NUMBER'CB::
	PHASE 0
TUBDDB::!TU'NUMBER'DDB		;(0)Address of this unit's DDB
TUBDA::!NUMBER			;(1) 7*<TM03 #> + <TU45 #> (TM03 #=0)
TUBKDB::!TMX0CB			;(2)Pointer to KBD of this unit.
UNITYP::!0			;(3)Lh: <>0 if unit online, 0 ow. Rh:<>0 if
				; device has timed out once.
TUBHC::!0			;(4)Number of times this unit called, "hung."
TUBIWC::!0			;(5)WC register before transfer.
TUBIFC::!0			;(6)FC register before transfer.
TUBCNT::!0			;(7)DEVCNT copied b4 transfer
TUBCLS::!0			;(10)DEVCLS copied b4 transfer
TUBER1::!0			;(11)Error rec. coroutine adr or 0
TUBER2::!0			;(12)Error rec. # tries left.
TUBS::!	0			;(13)Lh: On line state. Rh: rewind state
TUBEC::!0			;(14)number of device errors
TUBSB::!BLOCK 7			;(15:23)device regs last error.
TUBICW::!0			;INITIAL COMMAND WORD FOR CHANNEL
LENFXL==44
TUBCOM::!BLOCK LENFXL		;SPACE FOR COMMAND LIST, ONE WORD FOR EVERY DDB IOWD
MTUDBL==.			;Length of magtape UDB.
INTERNAL MTUDBL
	DEPHASE
>
ZZ==0
REPEAT MAGUN,<
	MTUDB(\ZZ)
ZZ==ZZ+1
>
TUYTMN::POINT 3,TUBDA(U),32	;Pointer to TM03 number
TUYTUN::POINT 3,TUBDA(U),35	;Pointer to TU45 number.

;KDB.
TMX0CB::
	PHASE 0
TKBCUN::!0			;(0)Address of UDB of currently active unit
IFCPU (KS),<
TKBCBA::!UA3,,772440		;(1)Base address of Rh11C
>;END IFCPU(KS)
TKBSPR::!0			;(2)Count of spurious interrupts received
TKBIUN::!-MAGUN,,TMX0CB+.+1	;Pointer to vector of addressess
				; of all UDBs on the TM03.
	DEPHASE

DEFINE TUCBNM(NUM)<
	TU'NUM'CB
>
ZZ==0
REPEAT MAGUN,<
TUCBNM(\ZZ)
ZZ==ZZ+1>

;There must be one extra 0 at the end of the vector.
REPEAT 5-MAGUN,<0>

;DDB.
;This macro, given a unit number, returns the name of the DDB.  It is
; necessary because of MACRO's primative macro processor.
DEFINE MFOO1(X)<TU'X'DDB>
DEFINE MTDDB(NUMBER),<
TU'NUMBER'DDB::
	PHASE 0
DEVNAM::!<SIXBIT/MTA/>+<NUMBER+20>_14
DEVCHR::!XWD 7*HUNGST,MTSIZ##+1
DEVIOS::!0
DEVSER::!XWD MFOO1(\<NUMBER+1>),MAGDSP##
DEVMOD::!XWD DVIN+DVOUT+DVMTA,<1_D+1_DR+1_B+1_IB+1_I+1_AL+1_A>
DEVLOG::!0
DEVBUF::!0
DEVIAD::!0
DEVOAD::!0
DEVCLS::!XWD 600000,DEVLSA+TU'NUMBER'DDB
DEVSTS::!0
DEVABC::!0
DEVBWC::!0
LENFXL==44		;At least that's what it is in other systems.
DEVLSA::!BLOCK LENFXL
DEVUDB::!TU'NUMBER'CB
DEVDIO::!0
DEVFNJ::!0
DEVMD1::!0			;Rh: mode.
DEVER1::!0			;Rh: MTER after error
DEVDWC::!0
DEVCNT::!0
MAGDDS==.
INTERNAL MAGDDS
	DEPHASE
>
;This makes the last link 0.
MFOO1(\<MAGUN>)==0

MAGDDB::
ZZ==0
REPEAT MAGUN,<
	MTDDB(\ZZ)
ZZ==ZZ+1
>
>;END IFN MAGUN


#Vi%