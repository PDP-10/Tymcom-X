TITLE	FILRIB	ROUTINE TO HANDLE RIB MANIPULATIONS

	STOPCD(,ENTRY,FILRIB)

EXTERN RBSPAR,RBREAL,RBINDX,RBDLTA,RBLVPR,RBLVSP,RBMASK
EXTERN RIBRIB,RIBRPS,RIBSNM,RIBSZS,RIBPFS,RIBSFS,RIBLST,TWOLVL,ONELVL,RIBELB,RIBSIZ,RIBNAM
EXTERN RIBSTS,RIPBDR
EXTERN RIBCOD,RIBSLF,RIBEXT,RIBPPN,RIBALP
EXTERN RBYPNO,RBYUNI,RBYUNA,RBYUNR,RBYUNV
EXTERN CODRIB

EXTERN ATYBSZ,ATBALP,ATBRIB,ATBSIZ,ATYBLK

EXTERN DRBALC,DRBRIB

EXTERN DEVRIB,DEYRPS,DEYRPS,DEVATB,DEVFLO,DEVPOS,DEVFUF
EXTERN DEVRET,DEVRBN,DEVRB1,DEVDRB
EXTERN DEVELB,DEVSZS,PTRLEN,PTRCHG

EXTERN DEVREL,DEVBLK ;******************
EXTERN UFDLNK,STRHSH,FLUSH

EXTERN UNLFIL,LOKMOD,KILFIL,FLUSHA

EXTERN UNIMCT,UNPRER
EXTERN UNIKON,UNIPPU,UNISTR

EXTERN STRDDB,STRNAM

EXTERN PGYERR

EXTERN MAPRDL,MAPWTL,MAPCML,MAPWLN,MAPRLS,GETER1
EXTERN %RIB.C,%RB2.C

EXTERN UPTRIB

EXTERN GIVPGK,RELSAT,GIVPAG

EXTERN CPOPJ1,CPOPJ,MFDPPN,GETAPG,UNTTBL,ERRFUL,IOSUPR
EXTERN RELLOK,TPOPJ,IOSRBE,IOSRIB,MAPXCH,CHKQTA,IOBDRB,JOB
EXT(<%COW,%COW.N>)
EXTERN ALIASD,FALAQA,FALRBE,PAGWAT,FALBDS
EXTERN LMPMXW,CLRCOW
COMMENT #
@@SUBROUTINE NXTPTR/NXTPT0
@@PURPOSE
THIS IS THE SUBR CALLED WHEN WE ARE OUT OF PNTRS IN THE DDB AND
WE WANT TO GET THE NEXT PNTR (REAL, SPARE, NON-EXIST, EOF, ETC.)
INTO THE DDB.
IF WE REACH THE END OF THE RIB STRUCTURE (I.E., OUR PREVIOUS
POINTER WAS AT THE END OF THE "LAST" RIB IN THE STR) (WE ARE
DOING OUTPUT) ADDITIONAL RIBS WILL BE GENERATED.
IT IS ASSUMED THAT THE CALLER HAS WRITTEN OUT THE DDB PNTRS
IF IT WAS NECESSARY TO DO SO.
@@ENTRY
EXPECTS F/ DDB, U/ UNIT DB, AND S TO BE SET UP.
ENTER AT NXTPTR IF CALLER DOES NOT HAVE THE RIB IN %RIB.
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@RESTRICTIONS
CALLING ROUTINES CANNOT LEAVE THE DDB WITH ONLY SPARE RIB
POINTERS IN IT, AS THAT IS AN ILLEGAL FORM.
@@EXIT
NON-SKIP RETURNS IF ERROR READING RIB OR CAN'T ALLOCATE ANOTHER
RIB.  ERROR FLAGS RETURNED IN T1 ARE, RESPECTIVELY, FALRBE
AND FALAQA.
ELSE SKIP RETURNS WITH THE NEXT PNTR IN THE DDB AND WE HAVE THE RIB
IN %RIB.  THE FORM OF THE NEXT PNTR (EOF, SPARE, ILLEGAL, ETC.)
IS NOT CHECKED BY THIS ROUTINE.
@@ #

INTERN NXTPT0

NXTPTR:	MOVE	T1,DEVRIB(F)	;MAP
	MOVEI	PG,%RIB.C	;IN THE
	PUSHJ	P,MAPWTL	;RIB.
	PUSHJ	P,RIBCON	;ERRORS?
	  JRST	[PUSHJ P,MAPRLS
		MOVEI T1,FALRBE
		POPJ P,]
	MOVE	S,DEVIOS(F)	;DID THE FILE GO BAD WHILE WE
	TLNE	S,IOBDRB	;WAITED?
	 JRST	[PUSHJ P,RELRIB ;
		MOVEI T1,FALRBE ;
		POPJ P,]
	MOVE	T4,DEVFLO(F)	;GET THE INVALIDATED DEVFLO
	TLZ	T4,(1B0)	;TURN OFF SIGN BIT, SO ARITHMETIC WORKS
	JRST	NXTP05		;AND GO GET POINTERS.

NXTPT0:	SKIPG	T4,DEVFLO(F)	;SEND ALONG THE NEXT DEVFLO
	 STOPCD (SLO)           ;;NXTPT0+1
	TLO	T4,(1B0)	;INVALIDATE THE POINTERS
	MOVEM	T4,DEVFLO(F)	;SO THAT NO ONE WILL GET THEM BETWEEN
				; THE TIME THAT WE CHANGE DEVRIB AND
				; THE TIME THE POINTERS FROM THE NEW RIB
				; ACTUALLY COME IN.
	TLZ	T4,(1B0)	;CLEAR THE BIT SO ARITHMETIC WILL WORK.
NXTP05:	SUBI	T4,1		;IN UNITS
	LSH	T4,-2		;OF
	ADDI	T4,PTRLEN+1	;PAGES.
	PUSHJ	P,PTRINN	;WON, MAYBE GET PNTRS FROM RIB.
	  JRST	NXTPT1		;OUT OF RIB PNTRS.
	JRST	CPOPJ1		;NOT OUT OF RIB POINTERS.
    ;HERE ON REACHED END OF POINTERS IN THIS RIB.
NXTPT1:	MOVE	T1,%RIB+RIBLST	;LAST PNTR IN THIS RIB IS A
	JUMPL	T1,NXTP15	;SPARE RIB PNTR?
	MOVE	T1,%RIB+RIBSZS	;NO.  AT LOWEST LEVEL
	CAIE	T1,1		;OF RIB TREE?
	 JRST	NXTPT3		;NO--AT EOF.
NXTP15:	SKIPN	T1,%RIB+RIBRIB	;IS THIS RIB THE PRIME RIB?
	 JRST	[MOVE T1,%RIB+RIBSZS  ;YES. AT EOF.
		 CAIN T1,TWOLVL
	 STOPCD (SLO)           ;;NXTP15+2
		JRST	NXTPT3]
	MOVEM	T1,DEVRIB(F)	;NO . GO SET
	MOVE	T1,%RIB+RIBRPS	;UP FOR
	DPB	T1,DEYRPS	;THE HIGHER RIB.
	MOVEI	PG,%RIB.C	;RELEASE
	PUSHJ	P,MAPRLS	;%RIB.
	JRST	NXTPTR		;


    ;HERE ON EOF.
NXTPT3:	CAIE	T1,TWOLVL	;DO WE NEED TWO PAGES?
	 JRST	NXTP34		;NO.
	PUSHJ	P,CHKQTA	;YES.  MAKE SURE NOT OVER QUOTA
	  JRST	NXTP35		;CAN'T GET ANOTHER PAGE.
	MOVEI	T1,FBIT##	;TRY TO GET
	HRRZ	T3,DEVATB(F)	;ANOTHER
	PUSHJ	P,GETAPG	;PAGE.
	  JRST	NXTP35		;CAN'T DO IT.
	MOVE	S,DEVIOS(F)	;
	TLNE	S,IOBDRB	;
	 JRST	NXTP35		;
	PUSH	P,T2		;GOT IT, SAVE RET PNTR.
NXTP34:	MOVEI	PG,%RB2.C	;MAP IN AND ZERO A NEW RIB.
	PUSHJ	P,GETRIB	;ALSO SET RIBSLF.
	  JRST	NXT344		;COULDN'T GET A DISK PAGE.
	MOVE	S,DEVIOS(F)	;FILE WENT BAD WHILE WE
	TLNN	S,IOBDRB	;WAITED?
	 JRST	NXTP36		;NO.  SUCCESS.
NXT344:	MOVEI	T1,TWOLVL	;DO WE HAVE A SECOND
	CAME	T1,%RIB+RIBSZS	;PAGE ON THE PDL?
	JRST	NXTP35		;NO.
	POP	P,T2		;YES.  GIVE
	TLZ	T2,RBMASK-RBREAL ;IT
	PUSHJ	P,GIVPAG	;BACK.
NXTP35:	PUSHJ	P,RELRIB	;RELEASE THE RIB.
	MOVEI	T1,FALAQA	;SET THE
	MOVE	S,DEVIOS(F)	;ERROR FLAG
	TLNE	S,IOBDRB	;AND
	MOVEI	T1,FALRBE	;THEN
	POPJ	P,		;IT.


NXTP36:	MOVE	T2,%RB2+RIBSLF	;SET
	MOVEM	T2,DEVRIB(F)	;DEVRIB.
	PUSH	P,P1		;SAVE P1 AND
	PUSH	P,P2		;P2.
	MOVEI	P1,%RIB		;SET THEM UP AS ARGS FOR THE
	MOVEI	P2,%RB2		;RIBEX? SUBRS.
	MOVE	T1,%RIB+RIBLST	;LAST PNTR IN OUR ORIGINAL RIB
	JUMPGE	T1,NXTPT4	;IS A SPARE RIB PNTR?
    ;HERE ON INCREASING OUR RIB STRUCTURE FROM TWO LEVELS
    ;TO THREE LEVELS.
	PUSHJ	P,RIBEX1	;SET UP INFO IN BOTH RIBS.
	MOVEI	T1,RIBSFS+RBLVPR-1 ;SET
	DPB	T1,DEYRPS	;DEYRPS.
	JRST	NXTPT5


    ;HERE ON ALL NEW RIB GENERATION EXCEPT GOING FROM TWO
    ;LEVELS TO THREE.
NXTPT4:	PUSHJ	P,RIBEX2	;SET UP INFO IN BOTH RIBS.
	JRST	[DPB T4,DEYRPS	;RETURN HERE ON NO INTER-
		JRST NXTPT5]	;MEDIATE RIB NEEDED.
	DPB	T4,DEYRPS	;HERE ON NEED AN INTERMEDIATE RIB.
	POP	P,T1		;RESTORE
	POP	P,T2		;GOTTEN
	EXCH	T2,(P)		;RETRIEVAL
	PUSH	P,T1		;PNTR.
	PUSHJ	P,RIBEX3	;LINK.
	MOVEI	PG,%RIB.C	;RELEASE
	PUSHJ	P,MAPRLS	;%RIB.
	MOVE	T1,(P)		;GET THE INTERMEDIATE PAGE
	PUSHJ	P,MAPWLN	;INTO %RIB.
	MOVEI	T1,%RIB		;ZERO
	PUSHJ	P,CORZER	;IT.
	JSP	T4,RIBEX4	;SET UP SOME MORE STUFF.


NXTPT5:	MOVEI	PG,%RB2.C	;RELEASE
	PUSHJ	P,MAPRLS	;BOTH
	MOVEI	PG,%RIB.C	;THE
	PUSHJ	P,MAPRLS	;RIBS.
	POP	P,P2		;RESTORE P2 AND
	POP	P,P1		;P1.
	JRST	NXTPTR		;TRY AGAIN.
COMMENT #
@@SUBROUTINE RIBCON
@@PURPOSE
SUBR TO CHECK A RIB.
@@ENTRY
EXPECTS THE RIB IN %RIB.
@@ACCUM
DESTROYS
@@CALLS
RIBCK1.
@@EXIT
SKIP RETURNS IF OKAY, ELSE NON-SKIP RETURNS WITH
ERROR BITS ALREADY SET.
@@ #

RIBCON::PUSHJ	P,RIBCK1	;CHECK THE RIB.
	  JRST	.+2		;BAD RIB.
	JRST	CPOPJ1		;PROBABLY OKAY.
	SETOM	DEVFLO(F)	;
	POPJ	P,
COMMENT #
@@SUBROUTINE RIBEX1
@@PURPOSE
SUBR TO HELP EXTEND THE RIB STRUCTURE.  USED WHEN EXPANDING
FROM TWO LEVELS TO THREE.  TRANSFERS INFORMATION BETWEEN
THE OLD 2ND LEVEL PRIME RIB AND THE NEW 2ND LEVEL RIB.
@@ENTRY
EXPECTS P1/ ADDRESS OF SOURCE RIB, P2/ ADDRESS OF NEW RIB, AND
THE NEW RIB TO HAVE BEEN ZEROED AND ITS RIBSLF AND RIBCOD SET.
@@ACCUM
DESTROYS T1 AND T2.
@@ #

RIBEX1::MOVSI	T1,RIBPFS(P1)	;COPY ALL THE
	HRRI	T1,RIBSFS(P2)	;PNTRS TO THE NEW
	BLT	T1,RIBLST-<RIBPFS-RIBSFS>(P2) ;RIB.
	SETZM	RIBPFS+1(P1)	;CLEAR OUT ALL OF THE
	MOVEI	T1,RIBPFS+2(P1)	;PNTR AREA IN THE OLD
	HRLI	T1,-1(T1)	;RIB EXCEPT WHERE THE SPARE
	BLT	T1,RIBLST(P1)	;RIB PNTR WILL GO.
	MOVE	T1,RIBSNM(P1)	;SET RIBSNM AND RIBSZS
	MOVEM	T1,RIBSNM(P2)	;IN THE NEW
	MOVE	T1,RIBSZS(P1)	;SPARE RIB TO THE OLD VALUES
	MOVEM	T1,RIBSZS(P2)	;IN THE PRIME RIB.
	MOVE	T1,RIBSLF(P1)	;POINT THE SPARE RIB BACK
	MOVEM	T1,RIBRIB(P2)	;TO THE PRIME RIB.
	MOVEI	T1,RIBPFS	;MARK THE PRIME RIB'S SPARE
	MOVEM	T1,RIBRPS(P2)	;RIB PNTR TO THIS SPARE RIB.
	MOVE	T2,RIBSLF(P2)	;PUT THE SPARE
	TLO	T2,RBSPAR	;RIB PNTR IN
	MOVEM	T2,RIBPFS(P1)	;THE PRIME RIB.
	MOVEI	T1,1		;PRIME RIB NOW
	MOVEM	T1,RIBSNM(P1)	;HAS ONE
	MOVE	T1,RIBSZS(P1)	;SPARE RIB POINTER.
	IMULI	T1,RBLVSP	;SET RIBSZS IN
	MOVEM	T1,RIBSZS(P1)	;THE PRIME RIB.
	POPJ	P,
COMMENT #
@@SUBROUTINE RIBEX2
@@PURPOSE
SUBR TO HELP EXPAND THE RIB STRUCTURE.  USED IN ALL NEW RIB
GENERATION EXCEPT GOING FROM TWO LEVELS TO THREE.  TRANSFERS
INFORMATION BETWEEN THE SOURCE RIB AND THE LOWEST LEVEL RIB.
@@ENTRY
EXPECTS P1/ ADDR OF SOURCE RIB   AND P2/ ADDR OF NEW LOWEST
LEVEL RIB.
@@ACCUM
DESTROYS T1 THRU T4.
@@EXIT
RETURNS "DEYRPS" IN T4.
SKIP RETURNS IF NEED TO GENERATE AN INTERMEDIATE RIB, ELSE
NON-SKIP RETURNS.
@@ #

INTERN RIBEX2
RIBEX2:	MOVEI	T3,RIBPFS	;OUR ORIGINAL RIB MAY BE
	SKIPE	RIBRIB(P1)	;A PRIME RIB OR
	MOVEI	T3,RIBSFS	;A SPARE RIB.
	MOVE	T1,RIBSNM(P1)	;CALC
	MOVEI	T2,RBLVPR	;T2/
	CAIE	T3,RIBPFS	;NO. NON-SPARE
	MOVEI	T2,RBLVSP	;RIB
	SUBI	T2,(T1)		;PNTRS TO TRANSFER.
	ADDI	T1,(T3)		;T1/ STARTING LOC.
	ADDI	T1,(P1)		;
	MOVE	T4,T1		;SAVE FOR LATER.
	HRLZI	T1,(T1)		;TRANSFER THE
	HRRI	T1,RIBSFS(P2)	;NON-SPARE
	ADDI	T2,RIBSFS-1(P2)	;RIB
	BLT	T1,(T2)		;PNTRS.
	SUBI	T2,(P2)		;SAVE
	PUSH	P,T2		;"DEYRPS".
	SETZM	(T4)		;CLEAR THE
	CAIN	T4,RIBLST(P1)	;
	JRST	RIBX22		;
	ADDI	T4,1		;TRANSFERRED
	HRLI	T4,-1(T4)	;AREA IN THE
	BLT	T4,RIBLST(P1)	;ORIGINAL RIB.
RIBX22:	SETZM	RIBSNM(P2)	;SET RIBSNM
	MOVEI	T1,1		;AND RIBSZS IN
	MOVEM	T1,RIBSZS(P2)	;THE NEW RIB.
	MOVE	T1,RIBSZS(P1)	;
	AOS	T2,RIBSNM(P1)	;ONE MORE SPARE RIB
	CAIE	T2,1		;PNTR
	JRST	RIBE25		;WILL BE IN
	MOVE	T2,RIBSZS(P1)	;ORIGINAL RIB.
	IMULI	T2,RBLVSP	;(POSSIBLY WE ARE
	MOVEM	T2,RIBSZS(P1)	;CREATING A NEW LEVEL.).
RIBE25:	POP	P,T4		;RESTORE "DEYRPS".
	CAIN	T1,TWOLVL	;NEED AN INTERMED RIB?
	JRST	CPOPJ1		;YES, SAY SO BY SKIP RETURNING.
	MOVE	T1,RIBSLF(P2)	;NO, JUST FINISH UP HERE.
	TLO	T1,RBSPAR	;POINT THE ORIGINAL
	MOVE	T2,RIBSNM(P1)	;RIB
	ADDI	T2,-1(T3)	;TO
	MOVEM	T2,RIBRPS(P2)	;THE
	ADDI	T2,(P1)		;NEW.
	MOVEM	T1,(T2)		;RIB.
	MOVE	T1,RIBSLF(P1)	;POINT THE NEW RIB BACK TO
	MOVEM	T1,RIBRIB(P2)	;THE ORIGINAL RIB.
	POPJ	P,
COMMENT #
@@SUBROUTINE RIBEX3/RIBEX4
@@PURPOSE
SUBRS TO HELP EXPAND THE RIB STRUCTURE.  RIBEX3 IS CALLED WHEN
WE HAVE JUST GOTTEN A DISK PAGE FOR AN INTERMEDIATE RIB AND
THE HIGHER AND LOWER RIBS ARE IN (P1) AND (P2) RESPECTIVELY.
RIBEX4 IS CALLED AFTER ITS CALLER HAS "WRITTEN OUT" THE
HIGHEST RIB AND ZEROED THE SPACE FOR THE INTERMEDIATE RIB.
@@ENTRY
EXPECTS P1/ ADDR OF SOURCE RIB, P2/ ADDR OF NEW LOWEST LEVEL
RIB, AND RIBEX3 EXPECTS T2/ DISK POINTER TO NEW INTERMEDIATE
RIB.
@@ACCUM
DESTROYS
@@EXIT
RIBEX3 EXITS WITH THE FOLLOWING THREE THINGS FOR THE INTER-
MEDIATE RIB ON THE TOP OF ITS PDL: RIBRPS, RIBRIB, AND RIBSLF.
THESE ARE FOR THE USE OF RIBEX4 (WHICH IS CALLED WITH A
JSP T4,).
@@ #

INTERN RIBEX3
RIBEX3:	MOVEM	T2,RIBRIB(P2)	;LOWEST RIB PNTS TO INTRMD PAGE.
	MOVEI	T1,RIBSFS	;LOWEST RIB POINTS
	MOVEM	T1,RIBRPS(P2)	;TO A SPARE RIB.
	TLO	T2,RBSPAR	;T2/ PNTR TO INTERMED PAGE.
	MOVE	T1,RIBSNM(P1)	;T1/ LOC IN HIGHEST RIB
	ADDI	T1,RIBPFS-1	;OF PNTR TO INTERMED RIB.
	MOVE	T4,T1		;
	ADDI	T4,(P1)		;
	MOVEM	T2,(T4)		;STORE PNTR IN HIGHEST RIB.
	TLZ	T2,RBSPAR	;RESTORE T2.
	POP	P,T4		;T4/ RETURN ADDRESS.
	PUSH	P,T1		;SAVE THESE THREE
	PUSH	P,RIBSLF(P1)	;THINGS FOR THE USE
	PUSH	P,T2		;OF RIBEX4.
	JRST	(T4)		;RETURN.

INTERN RIBEX4
RIBEX4:	POP	P,RIBSLF(P1)	;SET UP
	POP	P,RIBRIB(P1)	;STUFF IN THE
	POP	P,RIBRPS(P1)	;INTERMEDATE RIB.
	MOVEI	T3,CODRIB	;COPY SPARE
	MOVEM	T3,RIBCOD(P1)	;RIB REDUNDANT INFO.
	MOVEI	T2,1		;ONE SPARE
	MOVEM	T2,RIBSNM(P1)	;RIB POINTER.
	MOVE	T2,RIBSLF(P2)	;
	TLO	T2,RBSPAR	;
	MOVEM	T2,RIBSFS(P1)	;
	MOVEI	T2,RBLVSP	;SET
	MOVEM	T2,RIBSZS(P1)	;RIBSZS.
	JRST	(T4)		;RETURN.
COMMENT #
@@SUBROUTINE GETRIB
@@PURPOSE
SUBROUTINE TO GET A NEW PAGE ON THE DISK, MAP IT IN AS
(PG), ZERO IT, AND SET RIBSLF AND RIBCOD.
@@ENTRY
EXPECTS PG/ %RIB.C OR %RB2.C.
@@ACCUM
DESTROYS
@@CALLS
CKQOTA, GETAPG, MAPWLN, AND ZERPAG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

GETRIB:	PUSHJ	P,CHKQTA	;CHECK USER'S DISK QUOTA
	  POPJ	P,		;COULDN'T GET A PAGE.
	MOVEI	T1,FBIT##	;
	HRRZ	T3,DEVATB(F)	;T3/ ATB ADDR OR ZERO.
	PUSHJ	P,GETAPG	;GET A DISK PAGE ANYWHERE.
	  POPJ	P,		;NO SPACE ON DISK OR UNIT.
	MOVE	T1,T2		;MAP IT
	PUSH	P,T1		;IN
	PUSHJ	P,MAPWLN	;AS (PG).
	MOVEI	T1,%RIB		;ZERO
	CAIE	PG,%RIB.C	;THE
	 MOVEI	T1,%RB2		;PAGE
	PUSH	P,T1		;
	PUSHJ	P,CORZER	;AND
	POP	P,T1		;
	POP	P,RIBSLF(T1) 	;THEN
	MOVEI	T2,CODRIB	;SET
	MOVEM	T2,RIBCOD(T1)	;RIBCOD AND RIBSLF.
	JRST	CPOPJ1
COMMENT #
@@SUBROUTINE CORZER/CORONZ
@@PURPOSE
SUBR TO SET VALUES IN A PAGE IN CORE.
@@ENTRY
EXPECTS T1/ ADDR OF START OF PAGE IN CORE.
ENTRY POINT CORZER CLEARS THE PAGE, ENTRY POINT CORONZ SETS
ALL THE WORDS IN THE PAGE TO THE CONTENTS OF THE 1ST WORD
IN THE PAGE.
@@ACCUM
DESTROYS T1 AND T2.
@@EXIT
RETURNS T2/ ADDR OF LAST WORD IN THE PAGE.
@@ #

INTERN CORZER,CORONZ

CORZER:	SETZM	(T1)		;CLEAR 1ST WORD OF PAGE.
CORONZ:	HRLI	T1,(T1)		;SET UP THE
	ADDI	T1,1		;BLT PNTR.
	MOVEI	T2,776(T1)	;ADDR OF LAST WORD IN PAGE.
	BLT	T1,(T2)		;DO THE WHOLE PAGE.
	POPJ	P,
COMMENT #
@@SUBROUTINE PTROUT/PTROU0
@@PURPOSE
IF ANY POINTER IN THE DDB HAS CHANGED, TRANSFER THE PNTRS
INTO THE RIB, AND KEEP THE RIB ON RETURN.
ENTRY POINT PTROUT DOES NOT HAVE THE RIB ON ENTRY, ENTRY
POINT PTROU0 DOES.
@@ENTRY
EXPECTS F/DDB.
@@ACCUM
PTROUT DESTROYS T1, T2, T3, T4, AND PG.
PTROU0 DESTROYS T2 AND T3. (IT MUST NOT DESTROY OTHER ACS.).
@@EXIT
PTROUT NON-SKIP RETURNS IF ERROR, ELSE 2 SKIP RETURNS IF
THE DDB PNTRS HAVE CHANGED (IT HAS GOTTEN THE RIB), ELSE 1 SKIP
RETURNS IF THE DDB PNTRS HAVE NOT CHANGED (IT HAS NOT GOTTEN
THE RIB).
PTROU0 ALWAYS NON-SKIP RETURNS.
@@ #


PTROUT::MOVE	T1,DEVIAD(F)	;HAVE THE
	TLZN	T1,PTRCHG	;POINTERS CHANGED?
	JRST	CPOPJ1		;NO.
	MOVEM	T1,DEVIAD(F)	;
	MOVE	T1,DEVRIB(F)	;GET THE
	MOVEI	PG,%RIB.C	;RIB INTO
	PUSHJ	P,MAPWTL	;%RIB.
	PUSHJ	P,RIBCON	;ERROR ON READING?
	  PJRST	MAPRLS		;YES.
	PUSHJ	P,PTROU2	;NO.  TRANSFER THE PNTRS
	AOS	(P)		;AND
	AOS	(P)		;RETURN.
	POPJ	P,


PTROU0::MOVE	T3,DEVIAD(F)	;HAVE THE
	TLZN	T3,PTRCHG	;POINTERS CHANGED?
	 POPJ	P,		;NO.
	MOVEM	T3,DEVIAD(F)	;

PTROU2::LDB	T2,DEYRPS	;ADDR OF BEGINNING OF PNTR
	ADDI	T2,%RIB		;AREA IN RIB
	MOVE	T3,T2		;TO
	SUBI	T3,PTRLEN-1	;RH OF T3.  ADDR OF
	CAIGE	T3,%RIB+RIBSFS	;(DEBUGGING CHECK.).
	 STOPCD (SLO)           ;;PTROU2+5
	HRLI	T3,DEVRB1(F)	;BEGIN OF DDB AREA TO LH T3.
	BLT	T3,(T2)		;TRANSFER THE POINTERS.
	POPJ	P,
COMMENT #
@@SUBROUTINE PTRINN
@@PURPOSE
SUBROUTINE TO COPY POINTERS FROM THE RIB IN %RIB TO THE DDB.
TRANSFERS ESSENTIALLY ACCORDING TO DEYRPS.
@@ENTRY
EXPECTS F/DDB AND T4/ NEW DEVFLO IN UNITS OF PAGES (1,2, ETC.)..
@@ACCUM
DESTROYS T1 THRU T4.
@@EXIT
RETURNS POPJ IF NO POINTERS LEFT IN RIB.
ELSE CPOPJ1 WITH DEVSZS AND DEVFLO ALSO SET.
@@ #

INTERN PTRINN

PTRINN:	LDB	T1,DEYRPS	;OUT OF POINTERS
	SUBI	T1,RIBLST	;IN THIS
	JUMPE	T1,CPOPJ	;RIB?
	CAMLE	T1,[EXP -PTRLEN] ;ENOUGH TO FILL A DDB?
	 JRST	PTRIN4		;NO.

    ;ENOUGH TO FILL DDB.
	MOVEI	T1,DEVRB1(F)	;SET
	MOVEM	T1,DEVRET(F)	;UP
	LDB	T1,DEYRPS	;DEVRET
	ADDI	T1,PTRLEN	;AND
	DPB	T1,DEYRPS	;DEYRPS.
	JRST	PTRIN6		;

    ;NOT ENOUGH TO FILL DDB.
PTRIN4:	ADDI	T1,DEVRBN+1(F)	;SET UP
	MOVEM	T1,DEVRET(F)	;DEVRET
	MOVEI	T1,RIBLST	;AND
	DPB	T1,DEYRPS	;DEYRPS.

    ;TRANSFER THE POINTERS.
PTRIN6:	SUBI	T1,PTRLEN-1	;COPY THE
	HRLZI	T1,%RIB(T1)	;POINTERS FROM
	HRRI	T1,DEVRB1(F)	;THE RIB TO
	BLT	T1,DEVRBN(F)	;THE DDB.

    ;SET UP DEVSZS AND DEVFLO.
	MOVE	T1,%RIB+RIBSZS	;SET
	MOVEM	T1,DEVSZS(F)	;DEVSZS.

	SOS	T1,T4		;GET NEW DEVFLO AS 0,1, ETC.
	MOVE	T2,DEVRET(F)	;T2/ NO. OF PNTRS AHEAD OF US
	SUBI	T2,DEVRB1(F)	;IN THE DDB.
	JUMPE	T2,PTRIN9	;JUMP IF NONE.
	MOVEI	T3,DEVRB1(F)	;ELSE, COUNT FROM BEGINNING.
PTRIN7:	MOVE	T4,(T3)		;GET A PREVIOUS PNTR.
	TLNN	T4,RBSPAR	;ADJUST FLOOR BY
	SOJA	T1,PTRIN8	;ONE OR BY
	SUB	T1,%RIB+RIBSZS	;A SPARE RIB SIZE.
	SOJLE	T2,PTRIN9	;MORE PNTRS TO LOOK AT?
	AOJA	T3,PTRIN7	;YES, ADJUST ADDR TO LOOK AT.
PTRIN8:	SOJLE	T2,PTRIN9	;ONCE WE'VE SEEN A DATA PNTR,
	SUBI	T1,(T2)		;REST ARE ALL DATA POINTERS.
PTRIN9:	IMULI	T1,4		;CONVERT TO BLOCK 1,5,
	ADDI	T1,1		;ETC.
	MOVEM	T1,DEVFLO(F)	;HERE WHEN DONE.  STORE FLOOR.
	AOS	(P)		;SKIP RETURN.
	POPJ	P,
COMMENT #
@@SUBROUTINE USETST
@@PURPOSE
TO SET UP DDB PNTR AREA SO THAT @DEVRET POINTS TO THE RETRIEVAL
POINTER FOR PAGE N OF THE FILE.  IT IS THE CALLER'S
RESPONSIBILITY TO BE SURE THAT PAGE N IS NOT BEYOND
THE EOF.  THE CALLER MUST ALSO LOCK THE FILE.
THE CALLER MUST NOT ASK USETST FOR PAGE 0 UNLESS THE
FILE IS A NULL FILE.
@@ENTRY
EXPECTS M/ DESIRED LOGICAL PAGE NUMBER, F/ DDB, AND S/ DEVIOS.
MAY HAVE A RIB IN %RIB ON ENTRY.
@@ACCUM
DESTROYS T1-T4, U, PG,
@@EXIT
SEE PURPOSE.
SKIP RETURNS UNLESS ERROR READING A RIB OR BAD PNTRS IN RIB, IN
WHICH CASES IT NON-SKIP RETURNS (HAVING FIRST KILLED THE FILE)
WITH T1/FALRBE.
MAY HAVE A RIB IN %RIB ON EXIT.
ON SUCCESS EXIT, THERE MAY BE A RIB IN %RIB AND THE FILE MAY
BE LOCKED.
@@ #

EXTERN FINDM,FNDADB,MWLRIB,RELRIB,RELRB2

USETST::MOVE	S,DEVIOS(F)	;IS THE FILE
	TLNE	S,IOBDRB	;BAD?
	 JRST	USERFL		;YES.
	JUMPE	M,USENUL	;SPECIAL STUFF FOR A NULL FILE.
	PUSH	P,P1		;
	PUSH	P,P2		;
	SETZB	P1,P2		;
	SKIPG	T3,DEVFLO(F)	;IS OUR DDB PNTR AREA VALID?
	 JRST	USESS2		;NO.

    ;HERE WHEN OUR DDB PNTR AREA IS VALID.
    ;SEE IF WE CAN FIND PAGE N IN OUR DDB.
	MOVE	T1,F		;IS RET PNTR TO PAGE M
	PUSHJ	P,FINDM		;IN OUR DDB?
	  JRST	USESS1		;NO.
	JUMPN	T2,USES04	;MAYBE.  SAW ONLY SPARE RIB?
USEOUT:	POP	P,P2		;
	POP	P,P1		;
	SKIPG	T4,(T3)		;HERE, UNLESS BAD RET PNTR.
RIBBRP:: STOPCD (.,DISK,RIBBRP,RIBERX,<RIB error - Bad Retreival Pointer>);;USEOUT+3
	MOVEM	T3,DEVRET(F)	;STORE ADDR OF PAG N RET PNTR.
	JRST	CPOPJ1		;

USES04:	MOVE	P1,T2		;SAVE SPARE RIB INFO
	MOVEI	P2,(T3)		;FOR BELOW.
	HRLI	P2,(F)		;
    ;PAGE N NOT FOUND IN OUR DDB, OUTPUT OUR DDB IF NECESSARY.
USESS1:	MOVE	T1,DEVIAD(F)	;DO WE NEED TO
	TLNN	T1,PTRCHG	;OUTPUT OUR DDB PNTRS?
	 JRST	USESS2		;NO.
	MOVE	T1,DEVRIB(F)	;YES.  BE SURE WE
	PUSHJ	P,MWLRIB	;HAVE THE CORRECT RIB IN CORE.
	  PJRST	USERER		;BAD RIB, KILL THE FILE.
	PUSHJ	P,PTROU0	;OUTPUT THE PNTRS.

    ;HERE TO LOOK FOR PAGE N IN THE OTHER DDB PNTR AREAS.

USESS2:	SETZ	T1,		;GET NEXT DDB ON OUR ATB THAT
USES22:	PUSHJ	P,FNDADB	;IS VALID.
	  JRST	USESS3		;NONE LEFT.
	PUSHJ	P,FINDM		;FOUND ONE. HAS PAGE M?
	  JRST	USES22		;NO.
	JUMPE	T2,USES24	;JUMP ON RET PNTR TO PAGE M.
	CAMG	P1,T2		;ELSE, SAVE AWAY
	 JRST	USES22		;THE BEST
	MOVE	P1,T2		;SPARE RIB
	MOVEI	P2,(T3)		;PNTR WE HAVE FOUND.
	HRLI	P2,(T1)		;
	JRST	USES22		;TRY ANOTHER DDB.

USES24:	HRLZI	T4,DEVRB1(T1)	;COPY ALL THE PNTRS FROM THE
	HRRI	T4,DEVRB1(F)	;DDB WITH PAGE M'S PNTR
	BLT	T4,DEVRBN(F)	;TO OUR DDB.
	MOVE	T4,DEVSZS(T1)	;S THE OTHER DDB LOCS TOO.
	MOVEM	T4,DEVSZS(F)	;
	MOVE	T4,DEVRIB(T1)	;
	MOVEM	T4,DEVRIB(F)	;
	MOVE	T4,DEVFLO(T1)	;
	MOVEM	T4,DEVFLO(F)	;
	EXCH	T1,F		;
	LDB	T4,DEYRPS	;
	EXCH	T1,F		;
	DPB	T4,DEYRPS	;
	SUBI	T3,(T1)		;SET UP T3 FOR
	ADDI	T3,(F)		;DEVRET.
	JRST	USEOUT		;

    ;HERE WHEN PAGE N RET PNTR NOT FOUND IN CORE.
USESS3:	JUMPE	P1,USESS5	;JUMP IF START AT PRIME RIB.
    ;HERE WHEN WE HAVE IDENTIFIED A SPARE RIB PNTR.
	MOVE	T4,(P2)		;GET T4/SPARE RIB FOR PDL BELOW.
	HLRZ	T1,P2		;T1/ DDB ADDRESS.
	HRRZS	P2		;P2/ ADDR OF SPARE RIB.
	SUBI	P2,DEVRB1(T1)	;CALC THE
	IMUL	P2,P1		;"DEVFLO" OF THE
	MOVE	T3,DEVFLO(T1)	;
	SUBI	T3,1		;
	LSH	T3,B2PLSH	;
	ADD	P2,T3		;SPARE RIB, SO WE CAN FIND
	ADDI	P2,1		;
	MOVE	T3,M		;OUT HOW MANY PAGES IN WE ARE
	SUB	T3,P2		;WHEN WE JRST INTO THE ROUTINE
	PUSH	P,T3		;BELOW.
	PUSH	P,T4		;SAVE SPARE RIB.
	PUSHJ	P,RELRIB	;RELEASE ANY RIB WE HAVE.
	JRST	USES52		;

    ;HERE WHEN WE HAVE TO SEARCH FROM THE PRIME RIB.
USESS5:	MOVE	T2,M		;
	SUBI	T2,1		;
	PUSH	P,T2		;
	HRRZ	T1,DEVATB(F)	;T1/ ADDR OF
	MOVE	T1,ATBRIB(T1)	;PRIME RIB.
	SETOM	DEVFLO(F)	;INVALIDATE POINTERS, ELSE THERE IS WINDOW
				; WHERE DDB POINTER SCANNERS WILL THINK
				; THE PTRS ARE FROM THE WRONG RIB.
	MOVEM	T1,DEVRIB(F)	;
	SKIPN	T2,@%RIB.C+%CTUPT ;DO WE ALREADY
	 JRST	USES53		;HAVE THE
	CAMN	T1,PCBPTR(T2)	;PRIME RIB?
	 JRST	USES55		;YES.
	PUSH	P,T1		;NO.  SAVE T1 FROM MAPRLS.
	MOVEI	PG,%RIB.C	;
	PUSHJ	P,MAPRLS	;RELEASE CURRENT RIB.
      ;LOOK AT THE NEW RIB.
USES52:	POP	P,T1		;RESTORE T1 FOR MAPWTL.
USES53:	MOVEI	PG,%RIB.C	;
	SETOM	DEVFLO(F)	;INVALIDATE POINTERS NOW, IN CASE SOMEONE
				; IS SCANNING DDB PTRS - HE WOULD THINK
				; THEY ARE FROM THE WRONG RIB.
	MOVEM	T1,DEVRIB(F)	;
	PUSHJ	P,MAPWTL	;GET THE NEW RIB.
	PUSHJ	P,RIBCON	;CHECK IT.
	  JRST	[POP P,T2	;
		PJRST USERER]	;
	MOVE	S,DEVIOS(F)	;FILE WENT BAD WHILE WE
	TLNE	S,IOBDRB	;WAITED?
	 JRST	[POP P,T2	;YES.
		JRST USERER]	;
USES55:	POP	P,T2		;RESTORE T2/ NO. PAGES INTO IT.
	IDIV	T2,%RIB+RIBSZS	;T2/# SPARE RIB PNTRS, T3/PAGES.
	MOVEI	T4,%RIB+RIBPFS(T2) ;PRIME RIB PNTRS START AT
	SKIPE	%RIB+RIBRIB	;RIBPFS, SPARE RIB PNTRS START
	 MOVEI	T4,%RIB+RIBSFS(T2) ;AT RIBSFS.
	SKIPN	T1,(T4)		;EOF?
	 PJRST	USERER		;
	TLNN	T1,RBSPAR	;ARE WE LOOKING AT A SPARE RIB?
	 JRST	USES58		;NO.
	MOVE	T2,%RIB+RIBSZS	;YES.
	CAIN	T2,1		;
	 STOPCD (,XCT,RIBBRP)	;Bad Retrieval Pointer  ;;USES55+13
      ;HERE WHEN WE HAVE TO GO LOOK AT A SPARE RIB.
	PUSH	P,T3		;YES, SAVE # PAGES INTO IT
	PUSH	P,T1		;AND SPARE RIB LOC.
	MOVEI	PG,%RIB.C	;
	PUSHJ	P,MAPRLS	;RELEASE CURRENT RIB.
	JRST	USES52		;GO GET NEXT RIB.

      ;HERE WHEN WE EXPECT TO FIND A DATA PNTR IN THIS RIB.
USES58:	ADDI	T4,(T3)		;GET T3/ REL ADDR-1 OF PNTR
	SUBI	T4,%RIB+1	;IN RIB AND STORE IT
	DPB	T4,DEYRPS	;IN DEYRPS FOR PTRIN.
	SETZ	T1,		;FLUSH ALL THE DDBS FOR THIS
	PUSHJ	P,FLUSH		;RIB IN CASE MORE UP TO DATE.
	MOVE	T4,M		;T4/ NEW DEVFLO.
	PUSHJ	P,PTRINN	;GET THE PNTRS.
	 STOPCD (,XCT,RIBBRP)	;Bad Retreival Pointer  ;;USES58+7
	MOVE	T3,DEVRET(F)	;
	JRST	USEOUT		;

    ;ERROR EXITS.
USERER:	POP	P,P2		;
	POP	P,P1		;
	PJRST	KILFIL		;

    ;HERE WHEN SOMEONE ELSE HAS FOUND THE FILE BAD.
USERFL:	PUSHJ	P,RELRIB	;
	PUSHJ	P,RELRB2	;
	MOVEI	T1,FALRBE	;
	PJRST	UNLFIL		;

    ;HERE ON ASKED FOR PAGE 0.
USENUL:	HRRZ	T2,DEVATB(F)	;BETTER BE A
	LDB	T1,ATYBSZ	;NULL
	JUMPE	T1,.+2		;FILE.
	 STOPCD (,XCT,RIBBRP)	;Bad Retreival Pointer  ;;USENUL+3
	MOVE	T1,ATBRIB(T2)	;GET THE RIB SO
	MOVEM	T1,DEVRIB(F)	;WE CAN
	PUSHJ	P,MWLRIB	;GET RIBSZS.
	  PJRST	KILFIL		;ERROR RETURN.
	MOVE	T1,%RIB+RIBSZS	;
	MOVEM	T1,DEVSZS(F)	;
	MOVSI	T1,PTRCHG	;
	ANDCAM	T1,DEVIAD(F)	;
	MOVEI	T1,DEVRB1-1(F)	;
	MOVEM	T1,DEVRET(F)	;
	MOVEI	T1,1		;
	MOVEM	T1,DEVFLO(F)	;
	MOVEI	T1,RIBPFS+PTRLEN-1 ;
	DPB	T1,DEYRPS	;
	SETZM	DEVRB1(F)	;
	MOVEI	T1,DEVRB1+1(F)	;
	HRLI	T1,-1(T1)	;
	BLT	T1,DEVRBN(F)	;
	JRST	CPOPJ1
;ROUTINES FOR READING AND UPDATING DIRECTORIES

COMMENT ;
@@SUBROUTINE DIRFST
@@PURPOSE
GETS FIRST PAGE OF DIRECTORY INTO CORE FOR THE NAME FOUND IN
DEVNAM(F). DOES APPROPRIATE HASHING
@@ENTRY
FLAGS IN S: IO BLOCKS SHOULD BE WRITE LOCKED (UPDATING)
	IOSRIB DIRECTORY RIB IS IN %RB2 (FOR UPDATING)
T1: RIB POINTER TO DIRECTORY RIB
@@ACCUM DESTROYS T1,T2,T3,PG
@@CALLS MAPRDL,RIBCKD,RELLOK,DIRBLK(GETBLK)
@@TABLES SETS RIB POINTER IN DEVFLO(F), CHANGES DEVREL,DEVRIB
USES DEVNAM FOR NAME TO HASH ON
@@RET SKIP RETURN WITH BLOCK LOCKED IN %RIB. NON SKIP RETURN IF
AN ERROR (IOSRBE SET) OR IF NO FIRST BLOCK (NON-REAL POINTER)
ON NON-SKIP RETURN, NO BLOCK LOCKED.
@@;

DIRFST::SETOM	DEVFLO(F)	;PROTECT REAL FILE'S USERS.
	TLNE	S,IOSRIB
	 JRST	DIRUP2		;WE HAVE THE RIB IN %RB2, NO NEED TO GET IT
	PUSHJ	P,RIBDR1	;READ RIB, CHECK IT
	  JRST	RELLOK		;IF SOMETHING WRONG NON-SKIP IOSRBE SET
  ;At this point, the RIB for the directory is in %RIB and has been verified
REPEAT 0,<;Added in /A04, removed in /B01
	MOVEI	T1,SPUFDS##	;Check if in special UFDs list
DIRUP0:	SKIPL	T2,(T1)		;Get -size,,addr
	 JRST	DIRUP2		;End of list, file in question is not special
	MOVE	T3,DEVRIB(F)	;Does current retreival pointer
	CAME	T3,(T2)		; match one of the special ones?
	 AOJA	T1,DIRUP0	;No
	ADDI	T2,1		;Yes, dest is 1 past prime RIB
	HLRE	T3,T2		;Get size of block
	MOVMS	T3		;Positive length (including 1st word)
	ADDI	T3,-2(T2)	;Calculate end of BLT
	HRLI	T2,%RIB+RIBPFS	;Source
	BLT	T2,(T3)		;Copy the RIB pointers to MFDRIB+1 or SYSRIB+1
>  ;End REPEAT 0
   ;DEVFIL+DEVEXT have the name of the file being looked for.
DIRUP2:	MOVE	T1,DEVFIL(F)
	TLZ	T1,(1B0)	;CLEAR SIGN BIT BEFORE HASHING
	HRRZ	T2,STRDDB+STRHSH
	IDIVI	T1,(T2)
	HRRZ	T1,T2		;THE BLOCK TO GET
	SETOM	DEVFUF(F)	;NO RIB POINTERS
	PJRST	DIRBLK		;GO GET IT

SAVSYS:	





COMMENT ;
@@SUBROUTINE DIRNXT
@@PURPOSE
GETS NEXT PAGE OF DIRECTORY IF THERE IS ONE. FOLLOWES HASH LINK
@@ENTRY FLAGS IN S IO FOR WRITE LOCK REQUIRED (UPDATING)
	IOSRIB IF RIB IN %RB2 (ALSO UPDATING)
	PG SET TO %RIB.C
@@ACCUM DESTROYS T1,T2,T3
@@CALLS RELLOK,MAPRDL,RIBCKD,GETBLK
@@TABLES USES RIB PNTR FROM DEVFLO, SETS DEVREL
@@RET SKIP RETURN WITH NEXT BLOCK. NON-SKIP RETURN ON ERROR
(IOSRBE SET) OR NO NEXT BLOCK. NO BLOCK LOCKED ON NON-SKIP
EXCEPT IF UPDATE AND NO NEXT BLOCK, CURRENT STILL LOCKED
@@;

DIRNXT::SKIPN	T1,%RIB+UFDLNK	;LINK TO NEXT OVERFLOW PAGE
	 JRST	UPDRLK		;END OF THIS HASH CHAIN
	MOVEM	T1,DEVREL(F)	;A GOOD PLACE TO SAVE IT
	PUSHJ	P,RELLOK
	TLNE	S,IOSRIB
	 JRST	DIRUP1		;ALREADY HAVE THE RIB
	PUSHJ	P,RIBDR2	;READ IT AND CHECK IT
	  JRST	RELLOK		;ERROR
DIRUP1:	MOVE	T1,DEVREL(F)	;RELATIVE PAGE NUMBER
	PFALL	DIRBLK
COMMENT ;
@@SUBROUTINE DIRBLK
@@PURPOSE GET BLOCK N OF A FILE
@@ENTRY
EXPECTS DEVATB POINTS TO ATB.
AT ENTRY AT DIRBLK, RIB ALREADY IN %RIB OR %RB2 AND T1/ PAGE
NUMBER (STARTS AT 0).
FLAGS IN S: IO BLOCKS NEED WRITE LOCK FOR UPDATE IOSRBE RIB IN
%RB2 FOR UPDATE. PG SET TO %RIB.C
@@ACCUM DESTROYS T1,T2,T3
@@TABLES
MAY CHANGE DEVREL AND DEVRIB
@@RET SKIP RETURN IF ALL OK. NON-SKIP IF ERROR (IOSRBE SET)
OR BLOCK IS NON-EXISTANT (POSSIBLY NON-REAL PNTR)
@@ ;

DIRBLK::SETOM	DEVFLO(F)	;JUST IN CASE.
	SKIPL	DEVFUF(F)	;IF NO PNTRS IN DDB OR THIS IS
	CAML	T1,DEVFUF(F)	;EARLIER, DO NOT WORRY
	 JRST	GETBK1		;ABOUT DDB PNTRS.
	SUB	T1,DEVFUF(F)
	CAIL	T1,PTRLEN	;IS DESIRED PNTR IN CORE?
	 JRST	[ADD T1,DEVFUF(F)
		JRST GETBK1]	;NO, READ NEW ONE.
	MOVE	T2,T1
	ADD	T1,DEVFUF(F)
	ADDI	T2,DEVRB1(F)
	MOVE	T2,(T2)		;THIS IS THE PNTR
	TLNE	T2,RBSPAR
	 JRST	GETBK1		;IN CASE ITS A SPARE RIB PNTR, READ
	TLNN	T2,RBREAL
	 POPJ	P,
	MOVE	T1,T2
	JRST	GETBK6		;NOW READ IT

GETBK1:	MOVEM	T1,DEVFUF(F)	;THIS IS WHERE PNTRS WILL START NOW
	MOVEM	T1,DEVREL(F)
	MOVEM	T1,DEVBLK(F)	;SAVE IT HERRE FOR A WHILE
GETBK2:	TLNE	S,IOSRIB
	 PUSHJ	P,MAPXCH	;INTERCHANGE RB2 AND RIB
	MOVE	T1,DEVBLK(F)	;GET POSITION BACK
	IDIV	T1,%RIB+RIBSZS	;DIVIDE BY 1 OR 772
	SKIPE	%RIB+RIBRIB	;MAY BE SPARE RIB SECOND TIME AROUND
	 SKIPA	T3,%RIB+RIBSFS(T1);GET PROPER SPARE
	MOVE	T3,%RIB+RIBPFS(T1);OR PRIME RIB PNTR
	TLNN	T3,RBSPAR	;IS IT A SPARE RIB PNTR
	 JRST	GETBK3		;
	MOVEM	T2,DEVBLK(F)	;SAVE DISTANCE INTO SPARE RIB
	MOVEM	T3,DEVRIB(F)
	PUSHJ	P,MAPRXC
	PUSHJ	P,CRBRWL
	  JRST	UPDRLK
	JRST	GETBK2		;NOW CONTINUE IN THE NEW RIB

GETBK3:	ADD	T1,T2		;NO, MOVE A LITTLE MORE
	ADDI	T1,RIBSFS
	SKIPN	%RIB+RIBRIB
	 ADDI	T1,RIBPFS-RIBSFS;ADJUST BACK IF PRIME
	HRLI	T2,%RIB(T1)	;GET SET TO MOVE PNTRS
	HRRI	T2,DEVRB1(F)
	CAIG	T1,RIBLST+1-PTRLEN;ARE WE TOO FAR?
	 JRST	GETBK4		;NO
	MOVEI	T3,RIBLST+1-PTRLEN
	SUB	T3,T1
	ADDM	T3,DEVFUF(F)	;DECREASE THIS
	HRLZS	T3
	ADD	T2,T3		;AND ADJUST BLT PNTR
GETBK4:	BLT	T2,DEVRBN(F)
	MOVE	T1,DEVRB1(F)	;
	TLNE	T1,RBREAL	;NOW CHECK FOR REAL
	 JRST	GETBK5		;RELEASE RIB AND RETURN IF NOT
	TLZN	S,IOSRIB	;RESET SO WE KNOW ERROR TYPE
	 PJRST	RELLOK		;LET GO OF THE RIB
	PJRST	MAPXCH		;REVERSE MAP

GETBK5:	PUSHJ	P,MAPRXC	;EXCHANGE OR RELEASE
	MOVE	T1,DEVRB1(F)	;GET IT AGAIN
GETBK6:	PUSHJ	P,MAPRWL	;EITHER READ OR WRITE LOCK
	PUSHJ	P,GETER1
	JUMPE	T1,CPOPJ1
	TLO	S,IOSRBE	;SET ERROR FLAG
	JRST	RELLOK		;AND RELEASE
COMMENT ;@@SUBROUTINE DRRBLK
@@PURPOSE GET UFD BLOCK (START IS 0) IN C(T1) IN %RIB.
@@ENTRY UFD RIB IN %RIB, PAGE NUMBER IN C(T1) (START = 0)
@@ACCUM USES T1-T4
@@EXIT NON-SKIP IF GOT AN ERROR TRYING TO GET RETRIEVAL
POINTER TO UFD PAGE OR IF GOT I/O ERROR ON UFD PAGE.
ELSE SKIP RETURN.
@@RESTRICTIONS
@@FUNCTION SCAN RIB STRUCTURE FOR DESIRED PAGE.
@@;

EXTERN SAVE2

DRRBLK::JSP	T4,SAVE2
	TLO	S,IO		;GET RIBS WRITE LOCKED
	MOVE	P1,T1		;GET PAGE IN SAVE PLACE

DRRBL1:	IDIV	P1,%RIB+RIBSZS	;GET POINTER INDEX IN P1, REM IN P2
	SKIPN	%RIB+RIBRIB	;SKIP IF SPARE RIB
	SKIPA	T1,%RIB+RIBPFS(P1) ;PRIME
	MOVE	T1,%RIB+RIBSFS(P1) ;SPARE
	EXCH	P1,P2		;GET INDEX INTO NEXT RIB IN P1
				; AND THIS OFFSET IN P2
	TLNN	T1,RBSPAR	;THIS A SPARE POINTER?
	JRST	DRRBL2		;NO, ALMOST HAVE THE POINTER WE WANT.
	MOVE	P2,T1		;SAVE POINTER FROM RELLOK
	PUSHJ	P,RELLOK	;YES, NEED TO GET THAT RIB.
	MOVE	T1,P2		;GET BACK INTO T1 FOR MAPWTL
	PUSHJ	P,MAPRWL	;GET NEXT RIB
	PUSHJ	P,RBRCK1	;CHECK IT QUICK
	  PJRST	RELLOK		;NO GOOD, GET RID OF IT AND ERROR RETURN.
	JRST	DRRBL1		;AND TRY NEXT LEVEL.

DRRBL2:	ADD	P1,P2		;GET LOCATION OF POINTER IN P1
	SKIPE	%RIB+RIBRIB
	SKIPA	P1,%RIB+RIBSFS(P1) ;SPARE RIB PTR
	MOVE	P1,%RIB+RIBPFS(P1) ;PRIME RIB PTR
	PUSHJ	P,RELLOK
	MOVE	T1,P1		;GET INTO T1
	PUSHJ	P,MAPRWL	;GET UFD PGE WRITE LOCKED
	PUSHJ	P,GETER1	;I/O ERRORS?
	JUMPE	T1,CPOPJ1	;IF NOT, HAVE IT!
	PJRST	RELLOK		;SORRY, ITS BAD.
UPDRLK:	TLNN S,IOSRIB
	PJRST RELLOK	;DO NOT RELEASE IF WRITE LOCK, ONLY READ
	POPJ P,

MAPRWL::MOVEI	PG,%RIB.C	;MAKE SURE
	TLNN S,IO
	 JRST MAPRDL	;READ LOCK
	JRST MAPWTL	;OR WRITE LOCK


MAPRXC:	TLNE S,IOSRIB
	PJRST MAPXCH
	PUSH P,T1
	PUSHJ P,MAPRLS
	JRST TPOPJ

;READ OR WRITE LOCK CURRENT RIB

CRBRWR:	PUSHJ P,RELLOK
CRBRWL::MOVE T1,DEVRIB(F)
	PUSHJ P,MAPRWL		;READ RIB
	PJRST RIBCK1		;CHECK IT FOR CONSISTANCY




;SUBRS TO GET A RIB INTO %RIB AND CHECK IT.  RIBDIR ALSO
;INVALIDATES THE DDB.

RIBDIR::SETOM	DEVFLO(F)
	SETOM	DEVFUF(F)
	SKIPA	T1,DRBRIB(P4)
RIBDR2:	 SKIPA	T1,DEVRIB(F)	;Entry from DIRBLK, DEVRIB set
RIBDR1:	MOVEM	T1,DEVRIB(F)	;From DIRFST, set DEVRIB
	PUSHJ	P,MAPRWL	;READ OR WRITE LOCK
	PJRST	RIBCKD		;AND CHECK CONSISTANCY

RIBRDL::TLZA	S,IO
RIBWTL:: TLO	S,IO
	HRRZ	T1,DEVATB(F)
	MOVE	T1,ATBRIB(T1)
RBBRWL:	PUSH	P,DEVRIB(F)
	MOVEM	T1,DEVRIB(F)	;FOR PRMCHK
	PUSHJ	P,MAPRWL
	PUSHJ	P,PRMCHK
	 JRST	[POP P,DEVRIB(F)
		JRST RELLOK]
	POP	P,DEVRIB(F)
	JRST	CPOPJ1
;THESE ROUTINES CHECK FOR RIB CONSISTANCY

;RIBCKD - CHECK FOR A RIB FOR VALID DIRECTORY (A UFD OR THE MFD)
; NON-SKIP RETURN IF ERROR
; SKIP RETURN IF ALL OK

RIBCKD::PUSHJ	P,GETER1	;Get I/O status of this PCB page
	JUMPN	T1,RIBHRE	;Hardware read error while reading RIB
	MOVE	T1,%RIB+RIBSTS	;
	TRNE	T1,RIPBDR	;Check if known bad RIB
	 JRST	RIBER1		;FLAG S, ALREADY LOGGED.
	DMOVE	T1,%RIB+RIBPPN	;T1 GETS PPN, T2 NAME
	CAMN	T1,MFDPPN
	CAME	T2,DEVPPN(F)	;FILE NAME SHOULD MATCH DEVPPN
	 JRST	RIBERS		;INCONSISTANT
	HLRZ	T1,%RIB+RIBEXT
	CAIE	T1,'UFD'	;ALL DIRECTORIES ARE 'UFD'
	 JRST	RIBERS
	JRST	RIBCK2		;CHECK FILE STUFF


;RIBCK1 WILL CHECK ANY RIB, PRIME OR SPARE. BETTER CHECKS CAN
;BE APPLIED IF SOMETHING MORE IS KNOWN ABOUT THE RIB

RIBCK1:	PUSHJ	P,GETER1	;Get I/O status for this PCB page
	JUMPN	T1,RIBHRE	;Hardware read error while reading RIB
	SKIPE	%RIB+RIBRIB	;PRIME RIB?
	 JRST	RIBCK2		;NO
	MOVE	T1,%RIB+RIBSTS
	TRNE	T1,RIPBDR	;Check if known bad RIB
	 JRST	RIBER1		;FLAG S, ALREADY LOGGED.

;Now check RIBCOD, RIBSLF, RIBSZS, RIBSNM

RIBCK2:	MOVSI	T1,RBSPAR	;
	ANDCAM	T1,DEVRIB(F)	;
	DMOVE	T1,%RIB+RIBCOD	;T1 GETS COD, T2 SELF
	CAMN	T2,DEVRIB(F)
	CAIE	T1,CODRIB
	 JRST	RIBERS		;Bad COD or bad SELF pointer
	MOVE	T1,%RIB+RIBSZS
	CAIE	T1,1		;Primary RIB only?
	 JRST	RIBCK3		;No, check multi-RIB's
	SKIPE	%RIB+RIBSNM	;If RIBSZS=1, should be no spare RIBs
	 JRST	RIBERS		;There are, give error
	JRST	CPOPJ1		;No spares, give good return

RIBCK3:	SKIPN	%RIB+RIBSNM	;If RIBSZS .gt. 1, RIBSNM better be .gt. 0
	 JRST	RIBERS		;Inconsistent, give error
	CAIE	T1,ONELVL	;Must be either 772
	CAIN	T1,TWOLVL	; or 764044
	 JRST	CPOPJ1

    ;HERE ON SOFTWARE RIB ERROR (OR UNDETECTED HARDWARE WRITE ERROR).

RIBERS:	MOVE	T1,DEVRIB(F)	;GET WHAT RIB IS SUPPOSED TO BE
	CAMN	T1,LBDRIB	;SAME AS LAST ONE?
	 JRST	RIBER1		;YES, DON'T COUNT AGAINST THE SYSTEM
	MOVEM	T1,LBDRIB	;NO, REMEMBER NEW RIB AND
RIBERR:: STOPCD (.,EVENT,RIBERR,RIBERX,<RIB error - software detected>)
	AOS	T1,LBDCNT	;ONE MORE RIB ERROR WITHOUT I/O ERROR
	CAML	T1,LBDMAX	;IS IT TIME TO CRASH?
	 STOPCD (.,DISK,RIBTME,DSKDIE##,<Too Many RIB errors - disk is unsafe>);;RIBERR+6

    ;HERE ON MAYBE FIRST DISCOVERY OF A BAD RIB.  LOG IT.
    ;Jump to RIBHRE if got Hard Read Error trying to read RIB from disk.

	SKIPA			;RIBERS outputs stopcode RIBERR
RIBHRE:: STOPCD (.,EVENT,RIBHRE,RIBERX,<RIB error - Hard Read Error>)
	MOVEI	T1,UNPRER
	LDB	U,RBYUNV	;GET UNIT FIELD
	MOVE	U,UNTTBL(U)	;AND GET A POINTER TO UNIT DATA BLOCK
	ADDM	T1,UNIMCT(U)	;COUNT RIB ERRORS ON THIS UNIT

    ;HERE TO ERROR RETURN.

RIBER1:	TDO	S,[IOSRBE,,IOIMPM] ;SET ERROR BITS.
	MOVEM	S,DEVIOS(F)	;AND MAKE SURE STORED
	POPJ	P,

    ;Routine to output more info on RIBERR stopcodes

RIBERX:	PUSHJ	P,INLMES##	;F points to DDB
	 ASCIZ /RIB error in /
	PUSHJ	P,PRTDDB##	;DEV:(USERNAME)FILE.EXT[P,PN]
	PUSHJ	P,INLMES##
	 ASCIZ / on /
	LDB	T1,RBYUNV##	;Get disk unit part of DEVRIB(F)
	MOVE	U,UNTTBL(T1)	;Point to the CB
	MOVE	T2,UNILOG##(U)	;Get DSKB logical name
	PUSHJ	P,PRNAME##	;Print unit
	PUSHJ	P,INLMES##
	 ASCIZ	/: page /
	LDB	T1,RBYPNV##	;Get disk page number part of DEVRIB(F)
	PJRST	PRT22A##	;Print page address (6 or 7 octal digits)

;PRMCHK CHECKS A PRIME RIB FOR A FILE
; NON-SKIP RETURN IF ERROR
; SKIP RETURN IF OK

PRMCHK::PUSHJ	P,GETER1	;Get I/O status for this PCB
	JUMPN	T1,RIBHRE	;Hardware read error on spare RIB
	MOVE	T1,%RIB+RIBSTS	;
	TRNE	T1,RIPBDR	;Check if known bad RIB
	 JRST	RIBER1		;FLAG S, ALREADY LOGGED.
	DMOVE T1,%RIB+RIBPPN	;PPN TO T1, NAME TO T2
	CAMN T1,DEVPPN(F)
	CAME T2,DEVFIL(F)
	 JRST RIBERS		;PPN or name does not match
	HLLZ T1,DEVEXT(F)
	HLLZ T2,%RIB+RIBEXT
	CAME T1,T2
	 JRST RIBERS		;Extension does not match
	JRST RIBCK2

LBDCNT::	0		;COUNT OF BAD RIBS
LBDRIB::	0		;LAST BAD RIB SEEN - IF CHANGES, INCREMENT LBDCNT
LBDMAX::	^D50		;AFTER FIFTY DIFFERENT RIB ERRORS, CRASH
COMMENT ;@@SUBROUTINE UFRCHK
@@PURPOSE CHECK A UFD RIB AGAINS FILSER CORE BLOCKS
@@ENTRY UFD RIB IN %RIB
ATB ADDRESS IN P2
@@ACCUM USES T1-T4.
@@RESTRICTIONS DRB COUNT MUST STILL BE UP FOR UFD SO UFD RIB
 DOESN'T GO AWAY
@@FUNCTION CHECK FOR READ/WRITE ERRORS ON PCB PAGE, ERROR
IF SO. MAKE SURE NO RIB ERROR ON RIB ALREADY, ERROR IF SO.
CHECK RIBPPN AGAINST MFDPPN RIBNAM AGAINST DRBNAM, ERROR
IF NO MATCH ON EITHER. MAKE SURE RIBEXT IS UFD. IF ALL IS OK,
PJRST TO RBRCK2 TO DO CHECKING THAT IS COMMON TO ALL RIBS.
@@;

EXTERNAL ATBFNB,DRBNAM,FNBDRB,FNBEXT,FNBNAM
EXTERNAL SAVE1

UFRCHK::JSP	T4,SAVE1	;PUT DRB ADDR IN P1
	HRRZ	P1,ATBFNB(P2)	;FNB
	HRRZ	P1,FNBDRB(P1)	;DRB
	PUSHJ	P,GETER1	;GET ERRORS AFTER REFERENCING THE RIB
	JUMPN	T1,UFRER0	;Read error - can't read RIB for this UFD
	MOVEI	T1,RIPBDR	;THIS RIB ANY GOOD?
	TDNE	T1,%RIB+RIBSTS	;Check if known bad RIB
	 POPJ	P,		;KNOWN BAD, DON'T COUNT ANOTHER RIB ERROR.
	DMOVE	T2,%RIB+RIBPPN+<RIBNAM*0> ;GET PPN AND NAM
	CAMN	T2,MFDPPN	;PPN MUST BE ONE FOR MFD.
	CAME	T3,DRBNAM(P1)	;IF SOMETHING DOESNT MATCH
	 JRST	UFRER0		;COUNT A RIB ERROR
	HLRZ	T1,%RIB+RIBEXT	;UFD MUST BE EXTENSION
	CAIE	T1,'UFD'
	 JRST	UFRER0		;NO GOOD, BOMB.
	DMOVE	T1,%RIB+RIBCOD!<RIBSLF*0>
	CAIN	T1,CODRIB	;MAGIC NUMBER
	CAME	T2,DRBRIB(P1)	;AND POINTER TO SELF MUST BE OK
	 JRST	UFRER0		;NOT.
	MOVE	T1,%RIB+RIBSZS	;GET LEVEL
	SOJE	T1,CPOPJ1	;IF 1, OK.
	CAIE	T1,ONELVL-1
	CAIN	T1,TWOLVL-1
	 JRST	CPOPJ1		;ONLY THESE 3 VALUES ARE OK.

UFRER0:	LDB	U,RBYUNR	;
	PJRST	RBRER1		;
COMMENT ;@@SUBROUTINE PRRCHK
@@PURPOSE CHECK A PRIME RIB (FILE OR DIRECTORY)
AGAINST FILSER CORE BLOCKS.
@@ENTRY RIB IN %RIB
ATB ADDRESS IN P2
@@ACCUM USES T1-T4
@@EXIT NON-SKIP IF RIB IS NOT GOOD, WITH RIB RELEASED.
ELSE SKIP IF RIB IS GOOD, RIB STILL IN %RIB.
@@RESTRICTIONS
@@FUNCTION CHECK RIB FOR I/O ERRORS, COUNT A RIB ERROR IN
UNIT DATA BLOCK IF FIND SOME. IF BAD RIB BIT IS ON,
OR ATBRIB IS NOW ZERO (SOMEONE DELETED FILE'S RIB
WHILE WE WERE WAITING FOR RIB PCB) JUST RETURN AND RELEASE
THE RIB, SINCE IF ITS MARKED, DON'T COUNT IT AGAIN, AND
IF ATBRIB GOES AWAY, ITS NOT A REAL RIB ERROR.
IF OK SO FAR, CHECK RIB AGAINST FNBNAM, FNBEXT, DRBNAM.
IF OK, GO CHECK RIBCOD, RIBSLF, ETC.
@@;

PRRCHK::PUSHJ	P,GETER1	;I/O ERRORS FIRST
	JUMPN	T1,RBRER0	;THERE ARE SOME, LOG AND RETURN
	MOVEI	T1,RIPBDR
	TDNN	T1,%RIB+RIBSTS	;IF RIB ALREADY MARKED BAD OR
	SKIPN	ATBRIB(P2)	;HAS DISAPPEARED
	 PJRST	RELLOK		;GIVE IT UP AND RETURN.
	HRRZ	T1,ATBFNB(P2)	;GET FNB ADDRESS
	MOVE	T2,%RIB+RIBNAM	;DOES FILE NAME MATCH
	CAME	T2,FNBNAM(T1)	;IF NOT,
	 PJRST	RBRER0		;LOG AND RETURN.
	HRLZ	T3,FNBEXT(T1)	;GET EXTENSION
	HLLZ	T2,%RIB+RIBEXT
	CAME	T2,T3		;THIS MATCHES?
	 PJRST	RBRER0		;NO, LOG BAD RIB AND RETURN.
	HRRZ	T1,FNBDRB(T1)	;GET DRB ADDRESS NOW
	MOVE	T1,DRBNAM(T1)	;GET PPN OF FILE
	CAME	T1,%RIB+RIBPPN	;IF MATCH,
	 PJRST	RBRER0		;LOG AND RETURN
	JRST	RBRCK2		;GO DO COMMON CHECKS.
;CHECK RIB
RBRCK1:	PUSHJ	P,GETER1	;GET ERROR BITS
	JUMPN	T1,RBRER0	;GO COUNT IF I/O ERRORS
	SKIPE	%RIB+RIBRIB
	 JRST	RBRCK2		;NOT PRIME, NO RIBSTS
	MOVEI	T1,RIPBDR
	TDNE	T1,%RIB+RIBSTS	;BAD ALREADY?
	 PJRST	RELLOK		;YES, GET RID OF IT AND ERROR RETURN.

RBRCK2:	DMOVE	T1,%RIB+RIBCOD!<RIBSLF*0>
	CAMN	T2,ATBRIB(P2)	;RIBSLF MATCH POINTER?
	CAIE	T1,CODRIB	;AND RIBCOD IS MAGIC NUMBER?
	 PJRST	RELLOK		;NO, GIVE THING UP AND ERROR RETURN.
	MOVE	T1,%RIB+RIBSZS	;GET SIZE THAT POINTER REPRESENTS
	SOJE	T1,CPOPJ1	;MADE IT!
	CAIE	T1,ONELVL-1
	CAIN	T1,TWOLVL-1	;MUST BE THESE 3 VALUES
	 JRST	CPOPJ1		;OK.

;HERE TO LOG RIB ERROR IN A UNIT DATA BLOCK. ATB ADDRESS IN P2.
; ENTER AT RBRER1 WITH UNIT NUMBER WITHIN STR IN U.

RBRER0:	LDB	U,RBYUNA	;
RBRER1:	MOVE	U,UNTTBL(U)	;GET UDB ADDRESS.
	MOVEI	T1,UNPRER	;RIB ERROR BIT
	ADDM	T1,UNIMCT(U)
	 STOPCD (,XCT,RIBERR);;RIBER1+3 ;Let OPR know about it
	PJRST	RELLOK		;GIVE UP BAD RIB AND RETURN.
;SUBR TO SET UP THE DDB FOR THE START OF A NULL FILE.
;(AVOIDS UNNECESSARY READ OF RIB.).

INTERN ZERDDB

ZERDDB:	SETZM	DEVRB1(F)	;CLEAR
	MOVEI	T1,DEVRB1+1(F)	;THE
	HRLI	T1,-1(T1)	;DDB PNTR
	BLT	T1,DEVRBN(F)	;AREA.
	MOVE	T1,ATBRIB(P2)
	MOVEM	T1,DEVRIB(F)	;SET RIB POINTER
	MOVEI	T2,RIBPFS+PTRLEN-1 ;SET RIBRPS
	DPB	T2,DEYRPS	;HERE.
	HRRZI	T2,DEVRB1-1(F)	;SET DEVRET
	HRRZM	T2,DEVRET(F)	;HERE.
	MOVEI	T1,1
	MOVEM	T1,DEVFLO(F)
	MOVEM	T1,DEVSZS(F)
	JRST	INVDD2		;

    ;SUBR TO INVALIDATE THE DDB AND SET FILE LOC TO START.

INTERN INVDDB

INVDDB:	SETOM	DEVFLO(F)
	HRRZ	T1,DEVATB(F)	;
	MOVE	T1,ATBRIB(T1)	;
	MOVEM	T1,DEVRIB(F)	;
INVDD2:	MOVE	T1,[XWD 400000,1]
	MOVEM	T1,DEVPOS(F)
	MOVSI	T1,PTRCHG
	ANDCAM	T1,DEVIAD(F)	;CLEAR CHANGED FLAG
	POPJ	P,
;ROUTINE TO DELETE ALL THE PAGES IN A FILE, AND ALL THE RIBS.
;ENTERED WITH PRIME RIB IN %RIB.
;ASSUMES CALLER IS ONLY USER OF FILE.
;SKIP RETURNS IF DELETE WAS SUCCESSFUL, ELSE NON-SKIP RETURNS.
;IN EITHER CASE, HAS NO RIB IN %RIB ON EXIT.

INTERNAL DLTALL

DLTALL:	MOVE	S,DEVIOS(F)	;IF THE FILE IS BAD,
	TLNE	S,IOBDRB	;DON'T DARE
	 PJRST	RELRIB		;BELIEVE RET PNTRS.
	TLO	S,IO		;JUST IN CASE.
	SKIPE	T2,%RIB+RIBELB
	MOVEM	T2,DEVELB(F)	;SO IT IS NOT RETURNED
	PUSH	P,P1		;
	SETZ	P1,		;
	PUSHJ	P,DELRIB
	  JRST	[POP P,P1	;ERROR, RIB IS ALREADY
		POPJ P,]	;RELEASED.
	POP	P,P1		;SUCCESS RETURN.
	AOS	(P)
	PUSHJ	P,FREUP
	MOVE	T2,%RIB+RIBSLF
	PUSHJ	P,GIVPAG
	PJRST	RELLOK

;ROUTINE THAT DELETES EVERYTHING IN A FILE AFTER A GIVEN POINT.
; DECREMENTS P1 FOR EVERY PAGE OF THE FILE AND EVERY RIB GIVEN
; AWAY, NOT INCLUDING HOLES.
DELRIB:	SKIPE %RIB+RIBRIB
	 SKIPA T4,[-RBLVSP,,RIBSFS]	;AOBJN PTR TO SPARE
	MOVE T4,[-RBLVPR,,RIBPFS]	;OR PRIME
DLTRBC:	SKIPGE T1,%RIB(T4)	;GET NEXT. IS IT SPARE?
	 JRST DLTSRB		;YES, SPECIAL
	JUMPE T1,DLTRBD		;REALLY NONE THERE
	PUSH P,T4		;SAVE AOBJN PNTR
DLTRB3:	PUSH P,T4	;SAVE AGAIN FOR SORT
	MOVEI T3,0		;LARGEST SO FAR
DLTRB0:	SKIPN T1,%RIB(T4)	;POSSIBLY AT END
	 JRST DLTRB1		;YES, END OF THIS PASS OF SEARCH
	TLNN T1,RBREAL
	 JRST DLTRB2		;NOT REAL, IGNORE
	TLZ T1,RBMASK		;GET RID OF EXTRA BITS
	CAMG T1,T3
	 JRST DLTRB2		;NOT BIGGER
	MOVE T3,T1
	MOVE T2,T4
DLTRB2:	AOBJN T4,DLTRB0	;CONTINUE SEARCH
DLTRB1:	POP P,T4		;THIS IS WHERE BIGGEST GOES
	JUMPE T3,DLTRSZ		;NONE FOUND, SEARCH DONE
	MOVE T3,%RIB(T2)
	EXCH T3,%RIB(T4)	;INTERCHANGE
	MOVEM T3,%RIB(T2)
	AOBJN T4,DLTRB3		;CONTINUE SORTING
DLTRSD:	MOVE T4,(P)		;SEARCH ALL DONE
	SKIPN	T2,%RIB(T4)	;GET FIRST POINTER TO DELETE
	 JRST	DLTRG1		;
	SETZM	%RIB(T4)	;
	SOJ	P1,.+1		;COUNT ONE PAGE LESS.
	TLZ T2,RBMASK-RBREAL
	CAMN T2,DEVELB(F)	;IS THIS THE BAD PAGE?
	 PUSHJ	P,DLTBAD	;YES, CLEAN UP & SKIP OVER GIVPGK.
	PUSHJ P,GIVPGK		;GIVE UP BUT KEEP SAT
DLTRG1:	POP P,T4
	AOBJP T4,DLTRBG		;DONE, ALL GIVEN BACK
	SKIPN T2,%RIB(T4)	;IF EOF
	 JRST DLTRBG		;ALL DONE
	SETZM	%RIB(T4)	;
	SOJ	P1,.+1		;COUNT ONE PAGE LESS.
	TLZ T2,RBMASK-RBREAL
	PUSH P,T4
	CAMN	T2,DEVELB(F)	;
	 PUSHJ	P,DLTBAD	;
	PUSHJ P,GIVPGK	;RETURN NEXT PAGE
	JRST DLTRG1	;AND CONTINUE

DLTRBG:	PUSHJ P,RELSAT		;ALL DONE. LAST PAGE RETURNED
DLTRBD:	SKIPN	%RIB+RIBRIB
	 JRST	DLTTOP		;
	SKIPE	%RIB+RIBSFS	;GET FIRST PNTR
	 JRST	DLTRND		;PNTR THERE, DO NOT DELETE RIB
	PUSHJ	P,FREUP
	MOVE	T2,%RIB+RIBSLF
	PUSHJ	P,GIVPAG	;RETURN IT
	SOJ	P1,.+1		;COUNT ONE RIB PAGE LESS.
DLTRND:	MOVE	T1,%RIB+RIBRIB	;
	PUSH P,%RIB+RIBRPS
	MOVEM T1,DEVRIB(F)
	PUSHJ P,CRBRWR		;GET RIB
	  JRST RELLOK
	SKIPE %RIB+RIBRIB
	 SKIPA T4,[-RBLVSP,,RIBSFS]
	MOVE T4,[-RBLVPR,,RIBPFS]
	POP P,T1		;POSITION IN RIB OF SPARE PNTR
	SUBI	T1,(T4)		;
	HRLS T1			;ADJUST AOBJN
	ADD T4,T1
	AOBJN T4,DLTRBC		;CONTINUE IF MORE
	JRST DLTRBD		;NOW SEE IF TOP LEVEL

DLTSRB:	SETZM %RIB(T4)		;CLEAR THIS PNTR
	SOSGE	%RIB+RIBSNM
	 STOPCD (,XCT,RIBBRP)	;Bad Retreival Pointer  ;;DLTSRB+2
	MOVEM T1,DEVRIB(F)
	MOVE	T1,%RIB+RIBSZS	;Make sure this agrees with RIBSNM
	CAIN	T1,1		;Should not be 1 if RIBSNM was >0
	 STOPCD (,XCT,RIBBRP)   ;Bad Retreival Pointer  ;;DLTSRB+6
	SKIPN	%RIB+RIBSNM	;Just throw away last spare?
	IDIVI	T1,RBLVSP	;If so, reduce RIBSZS by one level
	MOVEM	T1,%RIB+RIBSZS	;NOTE: this could be done by just
				;checking the prime RIB at DLTTOP,
				;but this probably has a better chance
				;of working for multi-level RIB's.
	PUSHJ P,CRBRWR		;AND GET SUPRIB
	  JRST RELLOK
	JRST DELRIB		;CONTINUE

DLTRSZ:	HRRZS T4		;NEED TO ZERO REMAINING PNTRS (NON-REAL)
	SETZM %RIB(T4)
	CAIN T4,RIBLST		;IF ONLY THE LAST ONE
	 JRST DLTRSD		;THEN DONE
	HRLI T4,%RIB(T4)	;GET SET FOR BLT
	ADDI T4,%RIB+1
	BLT T4,%RIB+RIBLST
	JRST DLTRSD

DLTBAD:	HRRZ T1,DEVATB(F)
	SOS ATBALP(T1)		;ADJUST ALLOC (NORMALLY IN GIVPAG)
	HLRZ T1,DEVDRB(F)
	AOSG T2,DRBALC(T1)	;IF INCREMENT MAKE POS ALL OK
	 SOJG	T2,[MOVEM T2,DRBALC(T1)	;IF NOW<=0 WAS>0 DEC AGAIN
		JRST .+1]
	MOVSI T1,(1B0)
	IORM T1,DEVELB(F)	;FLAG AS BAD BLOCK SEEN
	JRST	CPOPJ1

DLTTOP:	AOS (P)
	SKIPL	DEVELB(F)	;IF BAD BLOCK WAS IN DELETED PART
	 POPJ	P,
	SETZM	%RIB+RIBELB	;CLEAR RIB FLAG
	MOVSI	T1,(1B0)	;
	ANDCAM	T1,DEVELB(F)	;
	POPJ	P,




EXTERN PCBPTR,PCBLKQ,PCBUSC,PCBPAG,PCISTS,PGYDRT,PGYADR
EXTERN PTNPNO,PTSPNO,STDPRE,%CTUPT

EXTERN DSKPIF,DSKPIN
DEFINE DSKON <WRPI DSKPIN>
DEFINE DSKOFF <WRPI DSKPIF>

EXTERN STDWRT,STDWAG,PWAIT1
FREUP:	HRRZ	T2,@%RIB.C+%CTUPT ;GET T2/ PCB ADDRESS.
	HRRZ	T1,PCBUSC(T2)	;WE BETTER
	SOJN	T1,.+3		;BE THE
	HRRZ	T1,PCBLKQ(T2)	;ONLY
	JUMPE	T1,.+2		;USER.
	 STOPCD (SLO)           ;;FREUP+6
	PUSH	P,PG		;GET PG/ CORE PAGE
	HLRZ	PG,PCBPAG(T2)	;NUMBER.
	PUSH	P,J		;
	MOVE	J,JOB		;
	PUSHJ	P,PAGWAT	;
	POP	P,J		;
	SETZ	T3,
	DPB	T3,PGYDRT	;CLEAR DATA MODIFIED.
	POP	P,PG		;
	POPJ	P,
;ROUTINE TO FIND A SPOT IN RIB STR AND DELETE EVERYTHING AFTER
;IT.  ALSO ZEROES OUT THE STUFF AFTER THE EOF AND IN THE LAST
;PAGE.
;EXPECTS T2/ UUXALC IN UNITS OF WORDS, WHICH IS
;< ACTUAL FILE SIZE, AND ALSO P2/ ATB ADDRESS.
;SKIP RETURNS ON SUCCESS, ELSE NON-SKIP RETURNS.
;SUCCESS RETURN HAS THE PRIME RIB IN %RIB.
;FAIL RETURN HAS RELEASED THE RIB.

EXTERNAL SETACH

INTERNAL DLTTRC

DLTTRC:	PUSH	P,T2		;CAN'T LOCK WHEN
	PUSHJ	P,RELRIB	;HAVE A
	POP	P,T2		;RIB.
	PUSHJ	P,LOKMOD	;LOCK SO NOT SEEN IN THE MIDDLE.

;HERE WITH FILE LOCK FROM TRUNCATE CHANIO.

DLTTCI::MOVE	T1,T2		;CALC T1/
	ADDI	T1,777		;NEW
	LSH	T1,W2PLSH	;HPW.
	LDB	T3,ATYBLK	;CALC T3/
	ADDI	T3,3		;CURRENT
	LSH	T3,B2PLSH	;HPW.
	TRNE	T2,177		;SET UP T2 AS
	ADDI	T2,200		;NEW ATBSIZ.
	MOVE	S,DEVIOS(F)	;FILE
	TLNE	S,IOBDRB	;ALREADY BAD?
	JRST	DLTFAL		;YES, JUST FAIL.
	PUSH	P,T2		;NO, SAVE NEW ATBSIZ.
	CAME	T1,T3		;NEED ACTUAL PAGE TRUNCATION?
	JRST	DLTTR0		;YES.
	PUSHJ	P,GETPRM	;GEE PRIME RIB FOR THE CALLER.
	JRST	DELTK0		;
	POP	P,T2		;RESTORE T2/ NEW ATBSIZ.
	EXCH	T2,ATBSIZ(P2)	;SET NEW ATBSIZ, OLD TO T2.
	JRST	DELTR7		;


    ;HERE FOR ACTUAL RETRIEVAL PNTR TRUNCATION.
    ;FLUSH AND INVALIDATE ALL DDBS ON THIS VERSION OF THE FILE.
DLTTR0:	PUSHJ	P,PTROUT	;FLUSH OUR DDB IF CALLED FROM KFTRN
	  PJRST	DELTK0		;BAD RIB, FORGET IT
	 JFCL			;THEY MAY HAVE CHANGED, MAYBE NOT. WHO CARES.
	PUSHJ	P,FLUSHA	;FLUSH AND INVALIDATE ALL DDBS.
	PJRST	DELTK0		;SAW A BAD RIB.
	PUSHJ	P,RELRIB	;RELEASE RIB IF HELD
	PUSHJ	P,SETACH	;SET ATPALC AND UFPALC, WAIT FOR UFD ENTRY TO GO OUT.

    ;GET THE PRIME RIB INTO %RIB.
	PUSHJ	P,GETPRM	;GET THE PRIME RIB.
	JRST	DELTK0		;BAD.
	SKIPE	%RIB+RIBRIB	;DEBUGGING CHECK
	 STOPCD (SLO)		;;DLTTR0+13
	SKIPE	T2,%RIB+RIBELB	;IN CASE IT SHOULD
	MOVEM	T2,DEVELB(F)	;NOT BE RETURNED.

    ;SET UP FOR DLTRBC.
	TLO	S,IO		;
	MOVEM	S,DEVIOS(F)	;
	MOVE	T1,(P)		;GET
	TRNE	T1,177		;
	SUBI	T1,200		;
	ADDI	T1,777		;T1/ NEW
	LSH	T1,W2PLSH	;HPW.
DELTR2:	IDIV	T1,%RIB+RIBSZS	;
	JUMPE	T2,DELTR5	;ON A SPARE RIB BOUNDARY, GO
	SKIPE	%RIB+RIBRIB	;LOAD THE
	SKIPA	T3,%RIB+RIBSFS(T1) ;PROPER
	MOVE	T3,%RIB+RIBPFS(T1) ;PNTR.
	TLNN	T3,RBSPAR	;
	JRST	DELTR4		;
	PUSH	P,T2		;SPARE RIB.
	MOVEM	T3,DEVRIB(F)
	PUSHJ	P,CRBRWR
	JRST	[PUSHJ P,RELRIB	;
		POP P,T2
		JRST DELTK0]
	POP	P,T1		;GET POSITION
	JRST	DELTR2		;AND CONTINUE
DELTR4:	ADD	T1,T2		;LAST DATA PNTRS, GET IT.
DELTR5:	HRLS	T1
	SKIPE	%RIB+RIBRIB
	SKIPA	T4,[-RBLVSP,,RIBSFS]
	MOVE	T4,[-RBLVPR,,RIBPFS]
	ADD	T4,T1		;ADJUST.
	MOVE	T1,(P)		;NOW, SET NEW ATBSIZ
	EXCH	T1,ATBSIZ(P2)	;AND REMEMBER
	MOVEM	T1,(P)		;ITS OLD VALUE.
	PUSH	P,P1		;P1 KEEPS TRACK OF
	SETZ	P1,		;STUFF FOR RIBALP.

    ;DO THE PARTIAL DELETE AND ADJUST RIBSIZ/ALP.
	PUSHJ	P,DLTRBC	;
	JRST	[POP P,P1	;
		JRST DELTK0]	;
	ADDM	P1,%RIB+RIBALP	;
	POP	P,P1		;
	POP	P,T2		;GET T2/ OLD ATBSIZ.
DELTR7:	MOVE	T1,ATBSIZ(P2)	;GET T1/ NEW
	TRNE	T1,177		;ATBSIZ UNROUNDED, AND
	SUBI	T1,200		;SET
	MOVEM	T1,%RIB+RIBSIZ	;RIBSIZ.

    ;NOW CLEAR OUT THE LAST PAGE, IF NECESSARY.
      ;ENTER HERE WITH T2/ OLD ATBSIZ AND T1/ NEW REAL SIZE.
      ;ALSO ENTER WITH THE PRIME RIB IN %RIB.
	TRNN	T1,777		;NEW EOF AT PAGE BOUNDARY?
	JRST	DELTR9		;YES, NO CLEARING NEEDED.
      ;FIND RELATIVE NO. OF LAST WORD TO CLEAR.
	TRNE	T2,177		;CONVERT OLD ATBSIZ EOF TO A
	SUBI	T2,200		;REAL SIZE.
	MOVE	T3,T1		;CALC NO. OF LAST WORD
	IORI	T3,777		;IN
	ADDI	T3,1		;PAGE.
	CAMLE	T2,T3		;WE WILL CLEAR TO
	MOVE	T2,T3		;%COW-1(T2).
	SUBI	T2,1		;
	TDZ	T2,[XWD-1,777000] ;T2/ RELATIVE TO START
	PUSH	P,T2		;OF PAGE.  SAVE IT.
      ;FIND T2/ RETRIEVAL PNTR TO LAST PAGE (FOR MAPKRN).
	LSH	T3,W2PLSH	;SET M/ NO. OF
	PUSH	P,M		;THE
	MOVE	M,T3		;LAST PAGE.
	SETOM	DEVFLO(F)	;JUST IN CASE.
	HRRZ	T1,DEVATB(F)	;DEBUGGING
	CAIE	T1,(P2)		;CHECK.
	 STOPCD (SLO)           ;;DELTR7+26
	PUSHJ	P,USETST	;SET UP @DEVRET.
	JRST	[POP P,M		;
		JRST DELTK0]	;
	SETOM	DEVFLO(F)	;ZAP DDB.
	POP	P,M		;RESTORE M.
	PUSHJ	P,GETPRM	;GET THE PRIME RIB AGAIN.
	JRST	DELTK0		;RIB WENT BAD.
	MOVE	T2,@DEVRET(F)	;DON'T BOTHER
	TLNN	T2,RBREAL	;WITH
	JRST	[POP P,T3	;HOLES.
		JRST DELTR9]	;
      ;MAP THE LAST PAGE INTO %COW.  (T2 HAS RETRIEVAL PNTR.).
	MOVE	T1,ATBSIZ(P2)	;FIND T1/ RELATIVE
	TRNE	T1,177		;
	SUBI	T1,200		;
	TDZ	T1,[XWD -1,777000] ;NO. OF 1ST WORD TO CLEAR.
	PUSH	P,T1		;NEW CODE TO
	PUSH	P,T2		;RELEASE THE RIB
	PUSHJ	P,RELRIB	;FOR ERNIE'S
	POP	P,T2		;CODE
	POP	P,T1		;IN REMOVE.
	POP	P,T3		;T3/ REL LAST TO CLEAR.
	SETZ	T4,		;ARG FOR CLRCOW.
	PUSHJ	P,CLRCOW	;CLEAR PART OF PAGE.
	JRST	.+2		;BLEW IT.
	JRST	DELTR8		;SUCCESS.
	HRRZI	T1,(T1)		;WHAT WAS
	CAIN	T1,FALBDS	;WRONG?
	TROA	S,IODERR	;BAD SAT, MAYBE DATA OKAY.
	TRO	S,IODTER	;IO ERROR.
	MOVEM	S,DEVIOS(F)	;BEST WE CAN DO FOR NOW.
DELTR8:	PUSHJ	P,GETPRM	;GET THE RIB BACK.
	PJRST	KILFIL		;
DELTR9:	PUSHJ	P,UNLFIL	;
	JRST	CPOPJ1

    ;SOME ERROR RETURNS.
DELTK0:	POP	P,T2		;
	PJRST	KILFIL		;

DLTFAL:	PUSHJ	P,RELRIB
	PJRST	UNLFIL		;

;THIS IS A LITTLE DEBUGGING ROUTINE TO GET THE PRIME
;RIB FOR DLTTRC. EXPECTS T1/ RETRIEVAL PNTR TO PRIME RIB.
;SKIP RETURNS IF RIB OKAY, NON-SKIP RETURNS IF IT IS BAD.
GETPRM:	MOVE	T1,ATBRIB(P2)	;
	MOVEM	T1,DEVRIB(F)	;BEWARE OF THE RIB
	SETOM	DEVFLO(F)	;CHECKING ROUTINE.
	PUSHJ	P,MWLRIB	;
	POPJ	P,		;
	SKIPE	%RIB+RIBRIB	;
	 STOPCD (SLO)           ;;GETPRM+6
	MOVE	T1,DEVPPN(F)	;
	CAME	T1,%RIB+RIBPPN	;
	 STOPCD (SLO)           ;;GETPRM+11
	MOVE	T1,DEVFIL(F)	;
	CAME	T1,%RIB+RIBNAM	;
	 STOPCD (SLO)           ;;GETPRM+14
	HLLZ	T1,DEVEXT(F)	;
	HLLZ	T2,%RIB+RIBEXT	;
	CAME	T1,T2		;
	 STOPCD (SLO)           ;;GETPRM+17
	JRST	CPOPJ1

	$END	(RIB)		;End of FILRIB (RIBLIT: RIBEND:)
    q @*