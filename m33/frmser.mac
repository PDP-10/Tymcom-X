TITLE	FRMSER - Frame-OP UUO and job assignment
SUBTTL	9 MAR 79 /EVS

	STOPCD(,ENTRY,FRMSER)

;          Table of Contents for FRMSER - FRMOP handler
;
;
;			   Section			      Page
;
;    1. FRMOP MUUO (opcode 044)  . . . . . . . . . . . . . . .   2
;    2. SETSTV - Set start vector address (CALLI -137) . . . .   4
;    3. FINASS - Assign frame interrupt causes (CALLI -151)  .   5
;    4. .FOREP=7 REPLICATE TO/FROM FRAME . . . . . . . . . . .   5
;    5. .FOVRM=10 VREMOV FOR ANOTHER FRAME . . . . . . . . . .   5
;    6. .FOVCL=11 VCLEAR FOR ANOTHER FRAME . . . . . . . . . .   5
;    7. .FOCSI=44 Cause software interrupt . . . . . . . . . .   6
;    8. .FOCFM=1 Create frame  . . . . . . . . . . . . . . . .   7
;    9. .FORVA=2 Read a virtual address  . . . . . . . . . . .  14
;   10. .FOWVA=3 Write a virtual address . . . . . . . . . . .  14
;   11. .FOSAA=4 Start at absolute address . . . . . . . . . .  16
;   12. .FOSVA=22 Start frame at start vector address  . . . .  17
;   13. .FOJMP=0 Gate jump to other frame  . . . . . . . . . .  20
;   14. .FOGIN=26 Gate jump Initialization . . . . . . . . . .  23
;   15. .FOCLR=14 Clear a stopped frame  . . . . . . . . . . .  24
;   16. .FOGET=32 Get new core image from SAVE file  . . . . .  25
;   17. .FORUN=33 Run program in frame . . . . . . . . . . . .  25
;   18. .FOSAV=34 Save frame's core image  . . . . . . . . . .  25
;   19. .FOSSA=35 Sharable save frame's core image . . . . . .  25
;   20. .FOHLT=5 Halt frame  . . . . . . . . . . . . . . . . .  26
;   21. .FOSTP=41 Stop Frame (^C)  . . . . . . . . . . . . . .  26
;   22. .FOFRC=42 Force Command for frame  . . . . . . . . . .  27
;   23. .FOCON=25 Continue a frame . . . . . . . . . . . . . .  28
;   24. .FOHST=23 Read Halt Status block . . . . . . . . . . .  29
;   25. .FORPC=6 Read PC (if PC is in user mode) . . . . . . .  30
;   26. .FOPRJ=43 Change Project Code for frame  . . . . . . .  31
;   27. .FORFA=36 Read Frame Attributes  . . . . . . . . . . .  31
;   28. .FOWFA=37 Write Frame Attributes . . . . . . . . . . .  31
;   29. .FOXFA=40 Exchange Frame Attributes  . . . . . . . . .  31
;   30. .FOCFH=12 Create handle  . . . . . . . . . . . . . . .  34
;   31. .FODFH=13 Destroy handle . . . . . . . . . . . . . . .  40
;   32. .FOSMF=20 Set Max Frame Rights . . . . . . . . . . . .  41
;   33. .FOCHR=21 Change rights in a handle  . . . . . . . . .  42
;   34. .FOVCH=27 Validate Child to Parent Handle for a chil .  44
;   35. .FORSI=15 Return standard access rights info . . . . .  46
;   36. .FORAR=16 Read a handle's access rights  . . . . . . .  47
;   37. .FORER=17 Read handle's effective rights . . . . . . .  47
;   38. .FOCAR=30 Read child's child to parent process handl .  50
;   39. .FOCER=31 Read child's C2P with effective rights . . .  50
;   40. COPY BITS FROM USER TO HANDLE  . . . . . . . . . . . .  52
;   41. .FOGFT=24 Graft a frame  . . . . . . . . . . . . . . .  55
;   42. FRAME TREE HANDLERS  . . . . . . . . . . . . . . . . .  56
;   43. ROUTINES TO GET CONTEXT PAGES AND CHECK ACCESS . . . .  59
;   44. FRAME DESCRIPTOR PROCESSING  . . . . . . . . . . . . .  62
;   45. BIT MAP TRANSLATION ROUTINES . . . . . . . . . . . . .  70
;   46. ERROR CODES  . . . . . . . . . . . . . . . . . . . . .  76
SUBTTL FRMOP MUUO (opcode 044)
;FRMOP MONITOR CODE. UUO CALLING FORMAT IS
;
;	MOVE	AC,[FUNCTION,,FRAME DESCRIPTOR]
;	FRMOP	AC,<EFFECTIVE ADDRESS (CAN BE IMMEDIATE)>
;	  ERROR RETURN
;	SUCCESS RETURN

;FRMOP ERROR CODES ARE GLOBAL ACROSS ALL FUNCTIONS, AND ARE
; ALSO FOUND AS SUB-ERROR CODES IN THE "OTHER FRAME" ERROR CODES
; IN VIRTUAL ADDRESS SPACE MANIPULATIONS.

;A FRMOP FUNCTION ROUTINE WILL FIND THE FRAME DESCRIPTOR IN P4,
; THE AC NUMBER IN W FOR ERROR CODE STORING, AND THE ADDRESS
; IN THE RIGHT HALF OF M.

;SOME FRMOP FUNCTIONS ARE IMMEDIATE (USE THE EFFECTIVE ADDRESS AS THE
; DATA) AND IN SOME THE EFFECTIVE ADDRESS POINTS TO AN ARGUMENT BLOCK.
; THE EFFECTIVE ADDRESS IS NEVER USED AS AN ADDRESS TO STORE THE
; RETURN DATA TO. RETURN DATA IS ALWAYS STORED EITHER IN THE AC
; OR IN A LOCATION SPECIFIED BY THE UUO ARGUMENTS.

EXT(<%UPT,%UPT.N,%UPX,%UPX.N>)

FRMOPD::UMOVE	T1,(W)		;GET FN,,FD
	HRRZ	P4,T1		;GET FD IN P4 FOR FD2FNO, CHEKAR ETC.
	HLRZS	T1		;JUST FN IN RH
;*;	JUMPE	T1,FRMJMP	;IF ZERO, BYPASS DISPATCH FOR SPEED.
	CAIL	T1,FRMOTL	;IN BOUNDS?
	 JRST	FOEBFN		;BAD FUNCTION CODE
	AOS	FRMCNT(T1)	;Count FRMOPs by function
	ROT	T1,-1		;<EVEN/ODD>,,FN/2
	SKIPGE	T1		;SKIP OF EVEN, USE LH
	 SKIPA	T1,FRMOTB(T1)	;ODD, USE RH
	MOVS	T1,FRMOTB(T1)	;EVEN, USE LH
	JRST	(T1)		;DISPATCH.

FOEBFN:	MOVEI	T1,FEBFN%	;BAD FUNCTION NUMBER
	UMOVEM	T1,(W)		;STORE INTO AC
	POPJ	P,		;AND GIVE ERROR RETURN.
;DISPATCH TABLE FOR FRMOP

DEFINE FRMOGN<XALL
X (JMP,FRMJMP)			;;(0)GATE JUMP TO FRAME (ZERO FOR FAST DISPATCH)
X (CFM,FRMCRE)			;;(1) CREATE FRAME
X (RVA,FRMRVA)			;;(2) READ A VIRTUAL ADDRESS
X (WVA,FRMWVA)			;;(3) WRITE A VIRTUAL ADDRESS
X (SAA,FRMSAA)			;;(4) START AT ABSOLUTE ADDRESS
X (HLT,FRMHLT)			;;(5) HALT FRAME
X (RPC,FRMRPC)			;;(6) READ PC (USER MODE PC)
X (REP,FRMREP)			;;(7) REPLICATE TO/FROM FRAME
X (VRM,FOOVRM)			;;(10) VREMOV FOR ANOTHER FRAME
X (VCL,FOOVCL)			;;(11) VCLEAR FOR ANOTHER FRAME
X (CFH,FRMCFH)			;;(12) CREATE HANDLE
X (DFH,FRMDFH)			;;(13) DESTROY HANDLE
X (CLR,FRMCLR)			;;(14) CLEAR A STOPPED FRAME
X (RSI,FRMRSI)			;;(15) RETURN STANDARD ACCESS RIGHT INFO
X (RAR,FRMRAR)			;;(16) READ A HANDLE'S ACCESS RIGHTS
X (RER,FRMRER)			;;(17) READ HANDLE'S EFFECTIVE RIGHTS
X (SMF,FRMSMF)			;;(20) SET MAX FRAME RIGHTS
X (CHR,FRMCHR)			;;(21) CHANGE RIGHTS IN A HANDLE
X (SVA,FRMSVA)			;;(22) START FRAME AT START VECTOR ADDRESS
X (HST,FRMHST)			;;(23) READ HALT STATUS BLOCK FOR FRAME
X (GFT,FRMGFT)			;;(24) GRAFT A FRAME
X (CON,FRMCON)			;;(25) CONTINUE A FRAME
X (GIN,FRMGIN)			;;(26) PREPARE FRAME TO BE GATE JUMPED INTO
X (VCH,FRMVCH)			;;(27) VALIDATE CHILD TO PARENT HANDLE FOR A CHILD
X (CAR,FRMCAR)			;;(30) READ CHILD'S CHILD TO PARENT PROCESS HANDLE
X (CER,FRMCER)			;;(31) READ CHILD'S CHILD TO PARENT PROCESS HANDLE, GIVE EFFECTIVE RIGHTS BACK
X (GET,FRMGET)			;;(32) SETUP FRAME'S CORE IMAGE FROM FILE
X (RUN,FRMRUN)			;;(33) RUN PROGRAM IN FRAME
X (SAV,FRMSAV)			;;(34) SAVE FRAME'S CORE IMAGE
X (SSA,FRMSSA)			;;(35) SHARABLY SAVE FRAME'S CORE IMAGE
X (RFA,FRMRFA)			;;(36) Read Frame Attributes
X (WFA,FRMWFA)			;;(37) Write Frame Attributes
X (XFA,FRMXFA)			;;(40) Exchange Frame Attributes
X (STP,FRMSTP)			;;(41) Stop Frame (^C)
X (FRC,FRMFRC)			;;(42) Force Command for frame
X (PRJ,FRMPRJ)			;;(43) Change Project Code for frame
X (CSI,FRMCSI)			;;(44) Cause software interrupt
X (ENA,FRMENA)			;;(45) Enable license in frame
X (DIS,FRMDIS)			;;(46) Disable license in frame
SALL>;END FRMOGN MACRO DEFINITION

DEFINE X(A,B)<
XP .FO'A,ZZ
IFE <ZZ/2*2-ZZ>,<ZZ1=='B
		'B,,FOEBFN>
IFN <ZZ/2*2-ZZ>,<RELOC .-1
		BYTE (18)ZZ1,'B> ;;GET AROUND BUG IN MACRO OR LOADER
ZZ==ZZ+1
>;END X MACRO DEFINITION

ZZ==0				;COUNTER TO USE DEFINING .FO???
FRMOTB:	FRMOGN
FRMOTL==ZZ

FRMCNT::BLOCK	FRMOTL	; Block for counters, one per .FO???
	SYDVF (<<FRMCNT,FRMOTL>>)	;For SYSDVF

SUBTTL	SETSTV - Set start vector address (CALLI -137)

COMMENT #
CALL:

	MOVE	AC,[COUNT,,ADDRESS]
	SETSTV	AC,
	  <ERROR RETURN> ;NEVER HAPPENS
	<SUCCESS RETURN>	;AC HAS OLD SETTING.
#

STVSET::EXCH	T1,%UPT+UPTSTV	;SET NEW ONE, GET OLD ONE
	UMOVEM	T1,(W)		;STORE OLD ONE IN USER'S AC
	JRST	CPOPJ1		;AND RETURN.
SUBTTL	FINASS - Assign frame interrupt causes (CALLI -151)
COMMENT ~
	MOVE	ac, [ <cause>B8+<channel>B17+<FD>B35 ]
	FINASS	ac,
	  error return
	normal return

where <cause> is a cause number from the table below,
<channel> is the INTADR channel number (1 to 35) to assign; 0 to deassign,
and <FD> is the frame descriptor for the specified frame (for causes 0-5, the
FD must be that of a child, for causes 6-13, the FD must be -1).
~

FNTBYP::	; FINASS interrupt channel assignments.
JBYLCF::POINT 6,JBTPNT##(J),05	;(00) interrupt parent - Lost Child Frame
  .IALCF==JBYLCF-FNTBYP
JBYECF::POINT 6,JBTPNT##(J),11	;(01) interrupt parent - Exit in Child Frame
  .IAECF==JBYECF-FNTBYP
JBYNIC::POINT 6,JBTPNT##(J),17	;(02) interrupt parent - NTQ in Child Frame
  .IANIC==JBYNIC-FNTBYP
	POINT 6,JBTPNT##(J),23	;(03) interrupt parent - unused
	POINT 6,JBTPNT##(J),29	;(04) interrupt parent - unused
	POINT 6,JBTPNT##(J),35	;(05) interrupt parent - unused
JBYSIP::POINT 6,JBTFNT##(J),05	;(06) Software Interrupt from Parent
  .IASIP==JBYSIP-FNTBYP
JBYSIC::POINT 6,JBTFNT##(J),11	;(07) Software Interrupt from Child
  .IASIC==JBYSIC-FNTBYP
JBYSIS::POINT 6,JBTFNT##(J),17	;(10) Software Interrupt from Sibling
  .IASIS==JBYSIS-FNTBYP
JBYSIA::POINT 6,JBTFNT##(J),23	;(11) Software Interrupt from Anyone
  .IASIA==JBYSIA-FNTBYP
;*;	POINT 6,JBTFNT##(J),29	;(12) unused
;*;	POINT 6,JBTFNT##(J),35	;(13) unused
FNTRNM==:.-FNTBYP	;Number of FINASS interrupts


FINASS::HRRZ	P4,T1		;Frame descriptor
	LDB	P2,[POINT 9,T1,17] ;Channel #
	CAILE	P2,^D35		;Legal interrupt channel number?
	 JRST	FEWBCN		;Bad Channel Number
	LDB	P1,[POINT 9,T1,8];Cause #
	CAILE	P1,FNTRNM	;Legal cause ?
	 JRST	FEWBTN		;Bad Table Number
	SETO	P3,		;No access rights needed
	PUSHJ	P,FD2FNO	;Convert FD to frame #
	  JRST	FRVERR		;No go
	HRRZ	T1,FNTBYP(P1)	;Get JBT table address
	CAIE	T1,JBTPNT##	;Is it set by parent in child's JBTPNT?
	 JRST	FINAS2		;No, must be doing to self
	PUSHJ	P,ISCHLD	;Check if J is a child
	  JRST	FEWNCH		;Not a child
FINAS1:	LDB	P3,FNTBYP(P1)	;Get old value
	DPB	P2,FNTBYP(P1)	;Store new into JBTFNT or JBTPNT
FRVOK:	UMOVEM	P3,(W)		;Return old value to user
	JRST	CPOPJ1	

FINAS2:	CAME	J,%UPT+UPTJOB	;Does FD reference self?
	 JRST	FEWBDF		;No, bad frame number
	JRST	FINAS1		;Yes, go set channel in JBTFNT




SUBTTL	.FOREP=7 REPLICATE TO/FROM FRAME
SUBTTL	.FOVRM=10 VREMOV FOR ANOTHER FRAME
SUBTTL	.FOVCL=11 VCLEAR FOR ANOTHER FRAME

	EXTERN	FRMREP		;This is in IOCSS
FOOVCL:	JRST	FRMVCL##	;*HACK* These 2 lines are so that LINK doesn't
FOOVRM:	JRST	FRMVRM##	;*HACK* mess up with 2 externals in 1 word.
SUBTTL	.FOCSI=44 Cause software interrupt

COMMENT ~
	MOVE	ac, [ XWD .FOCSI,Target-FD ]
	FRMOP	ac,
	  error return		; no rights or interrupt not enabled
	normal return		; ac = interrupt channel # enabled
where the Target-FD is a frame descriptor to the target frame.

If we are child of FD and parent is enabled, skip return with <.IASIP,,channel>.
If we are parent of FD and child is enabled, skip return with <.IASIC,,channel>.
If FD is a sibling and sibling is enabled, skip return with <.IASIS,,channel>.
If FD is enabled for interrupts from any, skip return with <.IASIA,,channel>.
Otherwise error return with zero in AC.
~

FRMCSI::SETO	P3,		;No access rights needed
	PUSHJ	P,FD2FNO	;Get frame number
	  JRST	FRVERR		;Bad frame descriptor, error code in P3
	PUSHJ	P,ISCHLD	;Is J one of our children?
	  SKIPA	P1,[.IASIA]	;No, could be anybody
	MOVEI	P1,.IASIP	;Yes, this is an interrupt from parent
	PUSHJ	P,ISSIBL	;Does J belong to a sibling (including myself)?
	  SKIPA			;No
	MOVEI	P1,.IASIS	;Yes, this is an interrupt from sibling
	MOVE	T1,%UPT+UPTJOB	;Get our frame number
	LDB	T1,PRNTBP(T1)	;Get our parent's frame number
	CAMN	T1,J		;Interrupting our parent?
	 MOVEI	P1,.IASIC	;Yes, this is an interrupt from child
	LDB	T1,FNTBYP(P1)	;Get the channel
	SKIPN	T1		;If this one is not enabled,
	 LDB	T1,JBYSIA	; get the "from anybody" channel
	UMOVEM	T1,(W)		;Tell caller (zero if not enabled)
	JUMPE	T1,CPOPJ	;Error return if callee not enabled
	PUSHJ	P,TAKTRP##	;Take the trap in T1 for job in J
	JRST	CPOPJ1		;End of FRMOP function .FOCSI
SUBTTL	.FOCFM=1 Create frame
COMMENT @;;SUBROUTINE FRMCRE
;;PURPOSE DOES CREFRM UUO
;;There are two formats for performing this call:

	OLDWAY:	MOVSI	ac,.FOCFM
		FRMOP	ac,[-count,,BLOCK]
		  error return
		normal return
	BLOCK:	exp JBTPPN,JBTPRV,JBTAUN,JBTUNM,JBTUN1

	NEWWAY:	MOVSI	ac,.FOCFM
		FRMOP	ac,BLOCK
		  error return
		normal return
	BLOCK:	flags,,count
		exp JBTPPN,JBTPRV,JBTAUN,JBTUNM,JBTUN1
		EXP RH<JBTLIC>		;IF FLAG 1B16 IS SET THIS CONTAINS
					; FRAME LIC FOR CHILD.  MAX FRAME
					; LIC PASSABLE IS FRAME LIC OF PARENT.
	;FLAGS
	CF.OLD== 1B0			; this word is -cnt,,adr (old way)
	CF.LOG== 1B17			; run LOGINN in child
	CF.LIC== 1B16			; pass frame license to child
	CF.PLI== 1B15			; LOGINN asks "please log in:" to
					; verify username and password
	CF.BAT== 1B14			; create child as batch job
	CF.BBJ== 1B13			; create child as background batch job

;;ACCUM ALL EXCEPT P
;;EXIT NON-SKIP IF ERROR (SEE ERROR CODES BELOW)
SKIP IF SUCCESS, FRAME DESCRIPTOR FOR NEW CHILD IN AC.
;;@


EXTERNAL AGENTV,ATBDUM,ATBMWC,ATBSTS,ATBUMC,ATPDUM,ATPMXU,CPOPJ1
EXTERNAL CTXTAB,DABBIT,DECHJB,HIGHJB,JBTAUN,JBTFTR,JBTLIC,JBTPPN,JBTPRV
EXTERNAL JBTUN1,JBTUNM,JBTUPM,JBYMWS,JBYUWS,JOBATB,LM3ATB,LM3HDA,LMPCUR
EXTERNAL LMPMXW,MAPUPX,MBIT,NCTXPG,PBMMSK,RBREAL,UP4LDA,UPT,UPTACP,UPTEND
EXTERNAL UPTJOB,UPTNTV,UPTPBM,UPTOFD,UXYUWL,UXYUWM
EXTERNAL UXYPSR,LMASRP,JOBMAX
EXTERNAL CLRJBT,JBTCTX,JBTSTS,LOGTAB
EXTERNAL SETLMX,TTYNFR
EXTERNAL SYSUID,JBTUID

	CF.OLD==1B0			; this word is -cnt,,adr (old way)
	CF.LOG==1B17			; run LOGINN in child
	CF.LIC==1B16			; PASS FRAME LIC TO CHILD
	CF.PLI==1B15			; Please Log In
	CF.BAT==1B14			; create batch job
	CF.BBJ==1B13			; create background batch job

;1) Get arguments from user, defaulting from caller's UPT
;2) Assign a new frame number (at this point, J does not equal JOB)
;3) Allocate pages for the new UPT, map them thru %UPX
;4) Insert initial values into the new UPT
;5) Put caller's arguments into JBT tables and in the new UPT

;P1=flag, P2=AC, P3&P4=LMAP, U=%UPT/%UPX, W=SETLMX, J=newframe

FRMCRE::MOVE	P2,W		;User's AC number for storing FD
	MOVEI	U,%UPT		;Read current args from caller's UPT
	PUSHJ	P,PSHARG	;SAVE USER'S ARGS ON THE STACK AND CHECK.
	  JRST	FCEBDA		;BaD Args (stack already cleaned up)
	TRNN	F,(CF.BAT!CF.BBJ);Want to create a (background) batch job?
	  JRST	FRMCR0		;No
	TLNN	F,LICJAL	;Require JL license for batch job
	  JRST	NBJFCE		;No Batch Job privileges (need to unstack)
FRMCR0:	MOVE	P1,F		;Save value of CF.LOG (TTYNFR clobbers F)
	PUSHJ	P,FRMASN	;ASSIGN A FRAME NUMBER
	  JRST	FCRFCE		;Frame Capacity Exceeded (need to unstack)
	MOVEI	T1,SWPINP	;TO KEEP SWAPPER HAPPY
	IORM	T1,JBTSTS(J)
	PUSHJ	P,TTYNFR	;GET NEW DETACHED TTY DDB FOR FRAME
	  JRST	FRMNCP		;Can't get it, (need to unstack)
				; TTYTAB(J) NOW SETUP WITH DDB.

;;	-- Privileges for creating batch jobs have already been checked --
	MOVSI	T1,JS.BAT	;Bit to indicate batch job
	TRNE	P1,(CF.BAT!CF.BBJ);Do we want any type batch job?
	  IORM	T1,JBTST2##(J)	;Yes, set batch job indicator
	MOVSI	T1,JS.BBJ	;Bit to indicate background class
	TRNE	P1,(CF.BBJ)	;Do we want background batch?
	  IORM	T1,JBTST2##(J)	;Yes, set bit for scheduler

	TRNN	P1,(CF.LOG!CF.PLI);Do we want to run LOGINN?
	  JRST	FRMCR2		;No
	MOVSI	T1,(1B0)	;Special flag to LOGINN
	TRNE	P1,(CF.PLI)	;Want to have LOGINN verify name and password?
	  MOVEM	T1,PSHARZ-<LOGTP0-CRESPC> ;Yes, set magic AUN
	MOVSI	T1,JLOG		;This is turned on now so that it
	IORM	T1,JBTSTS(J)	; gets cleared later when complemented
	MOVEI	T1,CMFCXN##	;Forced command index for .LOGIN
	PUSHJ	P,COMWCM##	;Yes, force the command
;;***NOTE*** COMCON will not try to process the .LOGIN as long as
;;***NOTE*** SWPINP is set - gross, but...

FRMCR2:	SETZB	P1,JBTCTX(J)	;P1 WILL CONTAIN LAST DISK ADDRESS ALLOCATED
	DPB	P1,JBYMWS	;INIT MWS SIZE.
				; FOR CONTIGUITY.
				; CLEAR ALL FLAGS IN JBTCTX ENTRY.
	PUSHJ	P,JOBATB	;GET DUMMY ATB ADDRESS
	MOVSI	T2,ATPDUM	;SET DUMMY BIT FOR GETPAG
	IORM	T2,ATBDUM(T1)
	MOVSI	W,-NCTXPG	;WHICH ONE WE'RE WORKING ON

FRMCR4:	MOVEI	T1,MBIT		;JUST MAPPING BIT
	MOVE	T2,P1		;TO BE CONTIGUOUS
	PUSHJ	P,JOBATB	;GET JOB'S ATB ADDRESS IN T1
	MOVE	T3,T1		;GET IT INTO T3
	MOVEI	T1,MBIT
	PUSHJ	P,FRMGTP	;GET A PAGE
	  JRST	FRMNRD		;NO ROOM, GIVE BACK PAGES, FRAME SLOT AND GIVE ERROR RETURN
	DPB	T2,CTXTAB(W)	;STORE.
	TLO	T2,RBREAL	;FOR NEXT TIME
	MOVE	P1,T2
	AOBJN	W,FRMCR4
;*** Start of duplicate code - This matches SWICSV in SCHED1.MAC

;NOW UPDATE THE DUMMY ATB COUNTS FOR THE CONTEXT PAGES ABOUT TO
; BE MAPPED. NOTE THAT THE DUMMY ATB CAN STILL HAVE VALUES
; IN IT FROM THE PREVIOUS OCCUPANT OF THE JOB NUMBER IF
; SOME OTHER JOB HAS PRIVATE PAGES MAPPED FROM THAT
; PREVIOUS OCCUPANT.

	PUSHJ	P,JOBATB	;NOW INIT THE JOB'S ATB
	MOVEI	T2,NCTXPG	;THIS MANY SLOTS WILL BE MAX-WRITE
	ADDM	T2,ATBMWC(T1) 	;THIS MANY MORE PAGES MAPPED WRITABLE.
	MOVS	T2,ATBDUM&ATBUMC&ATBSTS(T1) ;GET SWAPPED COPY
	TSO	T2,[ATPDUM,,ATPMXU] ;MAKE SURE DUMMY BIT IS ON, SET MXU
	ADDI	T2,NCTXPG	;INCREASE ATBUMC BY NCTXPG.
	MOVSM	T2,ATBDUM&ATBUMC&ATBSTS(T1)
				;SET THESE FIELDS

	MOVSI	T1,CTXCEX	;SAY THEY EXIST FOR MAPUPX
	IORM	T1,JBTCTX(J)
	PUSHJ	P,MAPUPX
	  STOPCD		;SHOULDN'T HAPPEN
	MOVE	T1,[<CPRRDW>B7+<NCTXPG>B17+%UPX.N+CNVVPN]
	VPROT	T1,		;WRITE ENABLE THEM TO INIT THEM.
	  STOPCD
	MOVE	T1,[UPT,,%UPX]
	BLT	T1,%UPX+UPTFSL-1	;COPY TRAP LOCS, PCS
IFCPU (KL),<
	SETZM	%UPX+UPTHEC
	SETZM	%UPX+UPTLEC
	SETZM	%UPX+UPTHMC
	SETZM	%UPX+UPTLMC
>;END IFCPU (KL)
	MOVE	T1,[%UPX+UPTFSL,,%UPX+UPTFSL+1]
	SETZM	%UPX+UPTFSL	;CLEAR OUT SOFTWRE LOCATIONS
	BLT	T1,%UPX+UPTEND
	MOVE	T1,PBMMSK	;SETUP PER PROCESS AREA BIT MASK

	MOVEM	T1,%UPX+UPTPBM	;USED FOR DYNAMIC ALLOC.
	MOVE	T1,UPT+UPTACP	;GET AC STACK POINTER
	MOVEM	T1,%UPX+UPTACP	;INIT THAT.
	HRRZ	T1,AGENTV
	MOVEM	T1,%UPX+UPTNTV	;FOR PAGE AGEING

	MOVEI	T1,1000		;INIT UWS LIMIT AND MAX
	DPB	T1,UXYUWM
	DPB	T1,UXYUWL
	MOVEM	J,%UPX+UPTJOB	;REMEMBER WHO THIS IS FOR.
	SETZ	T1,		;CLEAR UWS SIZE NOW.
	DPB	T1,JBYUWS
	HRLM	T1,JBTUPM(J)	;NUMBER OF EXISTENT PAGES TOO.
				;MWS SIZE ALREADY CLEARED IF THESE ARE NEW
				; (AS OPPOSED TO ERROR, THEN STILL NEED MWS SIZE TO DECREMENT SIPTOT.)

; *** End of duplicate code (FRMSER uses %UPX, SCHED1 uses %UPS).
;NOW SETUP THE LMAP SLOTS FOR THE NEW FRAMES CONTEXT PAGES.

	MOVE	W,[-NCTXPG,,<%UPT.N+CNVVPN>]

FRMCTP:	MOVSI	P3,<CPRRDW*LMPCUR>!LMPMXW ;READ WRITE, MAX WRITE
	LDB	T2,B-<%UPT.N+CNVVPN>(W) ;GET DP ADDRESS
	SETZ	P4,
	DPB	T2,UP4LDA	;Set up P3,P4,W for SETLMX
	LSH	T2,-LMASRP
	DPB	T2,LM3HDA
	MOVEI	T1,DABBIT(J)	;ATB POINTER
	DPB	T1,LM3ATB	;PUT INTO THE ATB FIELD
	PUSHJ	P,SETLMX	;STUFF THE SLOT INTO NEW FRAME'S LMAP SLOT
	AOBJN	W,FRMCTP	;LOOP FOR ALL CONTEXT PAGES.
	MOVSI	T1,MRQ+JERR	;SET MRQ SO JOB WON'T RUN UNTIL HIS CTX PAGES ARE IN.
				;SET JERR SO STARTING CODE WON'T THINK
				; ITS IN THE MONITOR SOMEWHERE.
	IORM	T1,JBTSTS(J)	;SET THESE BITS.
;;***NOTE*** JLOG is in the opposite of the state that it wants to be in,
;;***NOTE*** i.e., it wants to be turned on here unless a .LOGIN command
;;***NOTE*** was forced.  Therefore it gets turned on when the command is
;;***NOTE*** forced so that complementing it here always puts it in the
;;***NOTE*** correct state.
	MOVSI	T1,JLOG
	XORM	T1,JBTSTS(J)	;Sigh...

;Now store CREFRM arguments which are on the stack

	SETZM	JBTNM1##(J)	;Clear name associated with PPN
	SETZM	JBTNM2##(J)
	MOVEI	U,%UPX		;Store in new jobs UPT, not caller's UPT

;If batch job, license goes to JBTSLC(J) and 0 goes to JBTLIC(J)
;If normal job, license goes to JBTSLC(J) and JBTLIC(J)
	POP	P,JBTLIC(J)	;Set actual license on frame
	POP	P,JBTSLC(J)	;Set potential license on frame
	MOVEI	T1,LOGTOP-1	;GET NUMBER OF ARGS TO POP OFF STACK
	POP	P,@LOGTAB(T1)	;SET NEXT ARGUMENT INTO JBT TABLES.
	SOJGE	T1,.-1
	PUSHJ	P,CHGNAM##	;Make sure JBTNM1 and JBTNM2 match JBTPPN
	SETZM	JBTPRG##(J)	;Core image did not come from any file yet
	MOVE	T1,['------']
	MOVEM	T1,JBTNAM##(J)	;Do SETNAM for SYSTAT
	MOVSI	T1,PVDINA	;Did we set the default inactivity
	TDNN	T1,JBTPRV(J)	; timeout for the new frame?
	 JRST	FRMCR6		;No, don't bother with this rot
	MOVE	T2,JOB		;Get our parents number
	TDNN	T1,JBTPRV(T2)	;Is there an inactivity timer set here?
	 SKIPA	T1,INADEF##	;No, so use the system-wide default
	  LDB	T1,JBYIN2##	;Yes, use my parent's timeout value
	DPB	T1,JBYINA##	; and store it away for me.
FRMCR6:	MOVE	T1,[%UPT+UPTRNM##,,%UPX+UPTRNM##]
	BLT	T1,%UPX+UPTRPN##;Copy restricted command program

	MOVEI	T1,SWPINP	;CAN TURN OFF SWPINP NOW, SWAPPER CAN HAVE IT.
	ANDCAM	T1,JBTSTS(J)	;
	MOVSI	T1,JSTCTX	;SAVE SWAPPER SOME WORK
	IORM	T1,JBTCTX(J)
	MOVE	T1,%UPT+UPTJOB	;SETUP PARENT NUMBER
	PUSHJ	P,ADCHLD	;ADD A CHILD TO THE FRAME TREE.

;SETUP RIGHTS OF PARENT TO SELF TO BE EVERYTHING.

	MOVE	T1,ALLMFR	;GET FAST ACCESS BITS
	MOVEM	T1,JBTP2S(J)	;INITIALLY, PARENT HAS ALL RIGHTS
	MOVEM	T1,JBTMFR(J)	;AND SO DOES EVERYONE ELSE
	MOVE	T1,[ALLMFR+1,,%UPX+UPTMFR]
	BLT	T1,%UPX+UPTMFR+.ARSIZ-1 ;COPY THE SLOW BITS
	MOVE	T1,[ALLMFR+1,,%UPX+UPTP2S]
	BLT	T1,%UPX+UPTP2S+.ARSIZ-1 ;ALL RIGHTS.
	MOVE	T1,[<CPRRED>B7+<NCTXPG>B17+%UPX.N+CNVVPN]
	VPROT	T1,		;WRITE PROTECT THEM AGAIN
	  STOPCD

;THE NEW FRAME'S CONTEXT PAGE LMAP SLOTS ARE UNSHARED, AND OUR %UPX
; SLOTS WERE SHARED, SINCE THE M BITS WERE ON WHEN WE CALLED MAPUPX.
; THE NEW FRAME'S CONTEXT PAGES WILL ALWAYS BE SHARED, AND THE
; SPT USE COUNT WILL BE CORRECT BECAUSE MAPUPX USED THE NEW FRAME'S
; ATB.

;WRITE LOGINN RECORD FOR THE NEW FRAME

;Before writing LOGINN record, check to see whether LOGINN
; program will be run and do it for us.
	MOVE	T1,JBTSTS(J)
	TLNN	T1,JLOG		;If JLOG is off
	  JRST	FRMCRX		; don't write stream record, LOGINN will
	MOVEI	T1,40		;40 IS CODE FOR LOGINN RECORD
	PUSHJ	P,WRTACR##	;WRITE IT
	MOVEI	T1,RNQ##	;TAKE NEW FRAME OUT OF NULL QUEUE
	DPB	T1,PJBSTS	;PUT INTO WAIT STATE FIELD
	PUSHJ	P,REQUE##	;MAKE SCHEDULER MOVE IT INTO NEW QUEUE
				; (BUT MAYBE SOMEONE WILL START IT UP FIRST)
;End of CREFRM uuo - return Frame Descriptor to parent

FRMCRX:	MOVEI	T1,.FDFAM+.FMCHL(J) ;GET FD FOR THE NEW CHILD
	UMOVEM	T1,(P2)		;STORE IN AC
	JRST	CPOPJ1		;AND GIVE SKIP RETURN.
;ERROR EXITS FROM FRMCRE

;FRAME CAPACITY EXCEEDED

FCRFCE:	SUB	P,[PSHARZ,,PSHARZ] ;GET ARGS OFF THE STACK
	JRST	FCEFCE		;AND GIVE THAT ERROR CODE BACK TO USER

;NO PRIVS TO DO BATCH JOB
NBJFCE:	SUB	P,[PSHARZ,,PSHARZ] ;GET ARGS OFF THE STACK
	JRST	FCENBJ		;AND GIVE APPROPRIATE ERROR CODE

;HERE IF RUN OUT OF DISK TRYING TO ALLOCATE CONTEXT PAGES FOR
; THE NEW FRAME


FRMNRD:	SUB	P,[PSHARZ,,PSHARZ] ;GET ARGS OFF THE STACK
	HRREI	W,-1(W)		;GET C(W)-1 - LAST PAGE THAT WAS ALLOCATED.
	JUMPL	W,FRMNR2	;JUMP IF COULDN'T EVEN GET FIRST ONE.
FRMNR1:	LDB	T2,CTXTAB(W)	;GET DISK PAGE WE ALLOCATED
	TLO	T2,RBREAL	;MAKE IT ACCEPTABLE TO GIVPAG.
	PUSHJ	P,FRMGVP##	;GIVE IT BACK
	MOVE	T1,ADRNCT##	;SET TO "NO DISK PAGE" VALUE.
	DPB	T1,CTXTAB(W)	;ZERO THE DISK ADDRESS NOW.
	SOJGE	W,FRMNR1	;KEEP LOOPING TILL WE GIVE THEM ALL BACK
	PUSHJ	P,RELSAT##	;GIVE LAST SAT SNATCHED BY FRMGVP BACK.
FRMNR2:	PUSHJ	P,FCENRD	;STORE ERROR CODE IN USER'S AC
	JRST	FRMKJF		;AND DEALLOCATE THE FRAME SLOT

;HERE IF CAN'T ALLOCATE TTY DDB.

FRMNCP:	SUB	P,[PSHARZ,,PSHARZ] ;GET ARGS OFF THE STACK
	PUSHJ	P,FCENCP	;STORE NO COMMAND PORT ERROR INTO CALLER'S AC.

;HERE WITH ERROR CODE ALREADY STORED IN USER AC TO DEALLOCATE THE FRAME
; SLOT.

FRMKJF::MOVE	T1,[JNA,,SWPINP] ;TURN OFF JNA AND SWPINP
	ANDCAM	T1,JBTSTS(J)
	PUSHJ	P,CLRJBT	;CLEAR OUT STUFF WE SET
	PUSHJ	P,TTYKIL##	;GET RID OF TTY DDB.
	PJRST	DECHJB		;UPDATE HIGHJB IF NECESSARY AND GIVE USER THE ERROR RETURN.

;ERROR RETURNS

FCETAB:
FCENRD:	JSP	T1,FCEJSP	;(0)NO DISK ROOM
FCEFCE:	JSP	T1,FCEJSP	;(1)FRAME CAPACITY EXCEEDED
FCEBDA:	JSP	T1,FCEJSP	;(2)BAD ARG (NO LICENSE AND DOESN'T MATCH CALLERS PARAMETER)
FCENCP:	JSP	T1,FCEJSP	;(3)CANNOT CREATE COMMAND PORT (DDB)
FCENBJ:	JSP	T1,FCEJSP	;(4)NO PRIVS TO CREATE BATCH JOB
FCEJSP:	SUBI	T1,FCETAB+1
	XCTTU	<HRRZM T1,(P2)>	;STORE ERROR CODE INTO USER'S AC
	POPJ	P,		;AND GIVE ERROR RETURN.
;Set LDBLOG from UPTLOG if LDBLOG is zero
;Called with target frame number in J, LDB address in U

LOGLDB::PUSH	P,W		;Save ACs
	PUSH	P,PG
	CAMN	J,%UPX+UPTJOB	;Is required info already there?
	 JRST	LOGLD1		;Yes
	PUSHJ	P,MAPUPX##	;Map target's context pages in UPX
	  TDZA	T1,T1		;Couldn't
LOGLD1:	SWAPIN	T1,%UPX+UPTLOG##;Get data that CREFRM stored for us
	MOVE	T2,[BYTE(4)0(8)0,377,377,0] ;Mask for node number
	TDNN	T2,LDBLOG##(U)	;If not set already,
	 MOVEM	T1,LDBLOG##(U)	; store for jobs running on PTYs
	POP	P,PG
	POP	P,W		;Restore ACs
	POPJ	P,

COMMENT ;@@SUBROUTINE PSHARG
@@PURPOSE PUSH ARGS FOR CREFRM UUO ONTO THE STACK SO DON'T PAGE
FAULT OR GET I/O ERRORS FOR THEM DURING CRITICAL CODE.
@@ENTRY	J/FRAME NUMBER OF CURRENT FRAME (EXECUTER OF CREFRM UUO)
@@ACCUM T1-T4,M,W,F
@@EXIT ERROR RETURN IF NOT LICENSED AND NOT SETTING UP ARGS
	TO EXACTLY CORRESPOND TO THE CALLER'S FRAME PARAMETERS
SKIP RETURN IF OK, WITH ALL 10 ARGS PUSHJED ON STACK:
	PPN
	JBTPRV WORD
	AUN
	USER NAME WORD 1
	USER NAME WORD 2
	SUPERVISOR DATA (LDBLOG/UPTLOG)
	PROJECT CODE WORD 1
	PROJECT CODE WORD 2
	PROJECT CODE WORD 3

ALL UNSPECIFIED ARGS ARE SETUP TO BE THE CALLER'S.
PLUS
	RH<JBTLIC>
IF CF.LIC IS SET.
Returns with LH<F> = LICJAL bit copied from caller's JBTLIC word,
 RH<F> = caller's flag bits (if new style).
@@;

PSHARG:	POP	P,W		;RETURN IS IN W
	HLLZ	F,JBTLIC(J)	;Leave F<>0 iff caller has JL license
	TLZ	F,-1-LICJAL	;AC NOT GOOD ENUF, WE'RE IGNORING QUOTAS
	UMOVE	T2,(M)		;GET AOBJN POINTER FROM USER SPACE
	JUMPG	T2,PSHAR0	;Jump if new-style CREFRM
	HRRZ	M,T2		;Copy addr of user's arg block
	HLRE	T3,T2		;GET -VE COUNT IN RH OF T3
	JRST	PSHAR1

PSHAR0:	HLR	F,T2		;Copy user's flag bits
	MOVEI	M,1(M)		;Point to first user arg
	MOVNI	T3,(T2)		;Get -count in RH of T3
PSHAR1:	CAME	T3,[CRESPC-LOGTP1] ;Cannot have 1 word project code
	CAMN	T3,[CRESPC-LOGTP2] ;Cannot have 2 word project code
	 JRST	PSHERR		;Illegal number of arguments
	HRLI	M,-LOGTOP	;GET COUNT OF SPECIFIABLE ARGS IN LH OF M
				;ADDRESS IS ALREADY IN RH(M)
	MOVSI	T3,-1(T3)	;MAKE ONE MORE NEGATIVE, AOBJN IS FIRST.
				; RH OF T3 IS FOR INDEXING LOGTAB.
PSHAR2:	AOBJN	T3,.+2		;IF ANY USER ARG LEFT,
	SKIPA	T1,@LOGTAB-1(T3)	;USER DIDN'T SAY, USE HIS OWN
	 UMOVE	T1,(M)		;THERE IS ANOTHER ONE LEFT, GET IT
	TRNE	F,(CF.PLI)	;Going to have LOGINN validate everything?
	 JRST	PSHAR3		;Yes, ignore user's arguments
	CAME	T1,@LOGTAB-1(T3) ;SAME AS HIS OWN?
	 TLNE	F,LICJAL	;No, has license maybe?
	  JRST	PSHAR3		;Same arg or has license
;Argument mismatch with no JL license, check special cases
	HRRZ	T2,T3		;Copy argument index (1 through 9)
	XCT	CRESPC-1(T2)	;Perform argument-specific check
	  JRST	PSHERR		;Wrong arg or no secondary match, no go
PSHAR3:	PUSH	P,T1		;ARG IS OK, PUT IT ON STACK
	AOBJN	M,PSHAR2	;AND GO FOR ANOTHER ONE
	HLRZS	T3		;ENSURE THAT M POINTS
	SKIPL	T3		; TO LOCATION AFTER
	SUBI	M,1(T3)		; LOGTAB ARG BLOCK
	UHRRZ	T1,(M)		;GET FRAME LIC USER WANTS TO PASS
	HLR	T2,JBTLIC(J)	;GET PARENT'S PROCESS LIC
	TRZ	T2,LICRMT!LICHR	;TURN OFF HF and HR,  AND? what about WA-RP?
	AND	T1,T2		;CLEAR LIC THAT PARENT CAN'T PASS
	TRNN	F,(CF.LIC)	;WANT TO PASS FRAME LIC?
	  SETZ	T1,		;No, so clear license
	PUSH	P,T1		;STACK IT AWAY (saved license)
	TRNN	F,(CF.BAT!CF.BBJ);Creating a batch job?
	TRNN	F,(CF.LIC)	;No, Want to pass frame license?
	  SETZ	T1,		;No, or a batch job, so clear it
	PUSH	P,T1		;STACK IT AWAY (enabled license)
	JRST	1(W)		;GIVE SKIP RETURN.

PSHERR:	SUBI	T3,1		;CONVERT TO NUMBER PUSHED
	HRLS	T3		;GET #PUSHED,,#PUSHED
	SUB	P,T3		;FIX POINTER UP
	JRST	(W)		;AND GIVE ERROR RETURN.

; Execute table for special-case check when caller has no
; license and arguments don't match caller's job table entries.
CRESPC:	CAME	T1,JBTAUN(J)	;PPN (can also match AUN)
	PUSHJ	P,PSHPRV	;JBTPRV word
LOGTP0:	JFCL			;AUN must match if no license
	JFCL			;User name word 1 must match if no license
	JFCL			;User name word 2 must match if no license
	JFCL			;Tymnet supervisor data
LOGTP1:	SKIPA			;Project code word 1 can be different
LOGTP2:	SKIPA			;Project code word 2 can be different
	SKIPA			;Project code word 3 can be different
XP LOGTOP,.-CRESPC	;LINK will complain if this value does not match UUOCON
PSHARZ==LOGTOP+2	;This includes the *** 2 LICENSE words ***

PSHPRV:	MOVE	T2,T1		;Copy caller's arg
	XOR	T2,JBTPRV(J)	;T2 has bits that differ
	ANDCM	T2,PRVMSK##	;Clear bits which may legally differ
	SKIPL	JBTPRV(J)	;Check if LogoutOnStop *WAS* set
	 TLZ	T2,PVLOS	; if not - its legal to set it
	JUMPE	T2,CPOPJ1	;If no illegal different bits,
	POPJ	P,		; else error
COMMENT ;@@SUBROUTINE FRMGTP
@@PURPOSE GET A DISK PAGE FOR CREFRM UUO
@@ENTRY SAME AS GETPAG
@@ACCUM SAME AS GETPAG
@@EXIT NON-SKIP IF CAN'T ALLOCATE, SKIP IF CAN, PAGE IN T2
@@;


PRINTF(<[FRMGTP Needs to use DRBSTR for free disk page for CREFRM UUO]>)
FRMGTP:	MOVEI	T4,SRPNDS##	;IF DSKCLN HASN'T RUN YET
	TDNE	T4,STRDDB##+STRBTS##
	  JRST	[MOVE T2,ADRDUM##
		 POPJ P,]	;JUST GIVE DUMMY DISK ADDRESS AND RETURN
	PJRST	GETPAG##	;OTHERWISE, CALL GETPAG.

EXTERNAL FRMGVP			;SEE SWAMP FOR THIS ROUTINE.
COMMENT ~@@SUBROUTINE FRMASN
@@PURPOSE: ASSIGN A NEW FRAME NUMBER
@@ENTRY: NO INPUT PARAMS
@@ACCUM: T1,J
@@EXIT: Non-skip if all frames in use.
@@	Skip with frame number in J, job tables cleared, JBTUID setup.
@@~

FRMASN::MOVE	J,[-JOBMAX,,1]
FRMAS1:	MOVSI	T1,JNA+CMWB+JRQ	;Assigned ! Cmd needs core ! Requeue
	TDNE	T1,JBTSTS(J)	;Find a free frame number
	AOBJN	J,.-1
	JUMPGE	J,CPOPJ		;Frame capacity exceeded
	LDB	T1,PJBSTS	;Get job wait state/queue
	SKIPE	JBTSTS(J)	; 0 == never been used (.gt. HIGHJB)
	CAIN	T1,NULQ##	;Is it in the NULL queue
	 JRST	FRMAS2		;Yes, continue...
	AOS	BADQUE##	;No, I think this is fatal but only
	MOVE	T1,UPTIME##	; increment a flag for now!!!
	MOVEM	T1,BADQUE+1	;Save uptime in case of crash
	HRLM	J,BADQUE	;Save frame we tried this with
	AOBJN	J,FRMAS1	;Try another frame...
	POPJ	P,		;Ooops!  None left - just return

FRMAS2:	TLZ	J,-1		;Clear out count for HIGHJB compare
	MOVSI	T1,JNA		;Job Number Assigned
	MOVEM	T1,JBTSTS(J)	;Is now allocated
	PUSHJ	P,CLRJBT	;Clear job tables
	SETZM	JBTPNT##(J)	;Parent to child ints (not zeroed by CLRJBT)
	MOVE	T1,DATE##	;Get current UDT date
	CAMG	T1,SYSUID	;Make sure it's greater than last UID
	  AOSA	T1,SYSUID	;No, Get next unique universal frame id
	MOVEM	T1,SYSUID	;Ok, Set next unique universal frame id
	MOVEM	T1,JBTUID(J)	;Store it for user
	SETO	T1,		;Initially allow infinite VM
	DPB	T1,PVYCOR##	;Up to caller to adjust
				;***NOTE*** CREFRM UUO will over-write
				;***NOTE*** this field from caller's
				;***NOTE*** arg block - LOGIN command
				;***NOTE*** needs it to run LOGIN CUSP.
	CAMLE	J,HIGHJB	;If newly-assigned frame number higher
	MOVEM	J,HIGHJB	; than previous highest, set new highest
	PJRST	CPOPJ1		;Give good return

;FRMDSN - Called from KSTOP to turn off JNA
COMMENT ~@@SUBROUTINE FRMDSN
@@PURPOSE: DEASSIGN A FRAME NUMBER AT KJOB TIME
@@ENTRY: J HAS # OF FRAME LOGGING OUT
@@ACCUM: T1,J
@@EXIT: NON-SKIP ALWAYS.
@@~

FRMDSN::MOVE	T1,JSCLR	;Clear JNA and other special bits
	ANDCAM	T1,JBTSTS##(J)
	POPJ	P,		;Note: NOPRNT & TKCHLD have already been called

JSCLR:	XWD JNA+JLOG+JACCT,JACCT2+KJP+WAKFLG+EXCFLG ; "SPECIAL" JBTSTS BITS
SUBTTL	.FORVA=2 Read a virtual address
SUBTTL	.FOWVA=3 Write a virtual address

COMMENT #	READ/WRITE ANOTHER FRAME'S ADDRESS SPACE

CALLING FORMAT:

	MOVE	AC,[FN,,FD]	;FN = .FORVA,.FOWVA
	FRMOP	AC,<BLOCK>
	  <ERROR RETURN> 	;CODE IN AC
	<SUCCESS RETURN>

BLOCK:	<ADDRESS>
	<DATA>

IF LARGE QUANTITIES OF DATA ARE TO BE TRANSFERRED,
THE PROGRAM SHOULD REPLICATE THE PAGES INTO ITS ADDRESS SPACE
AND PERFORM THE TRANSFER. THESE FUNCTIONS ARE ONLY PROVIDED TO
ALLOW READING AND WRITING MEMORY LOCATIONS AND ACS WITH MINIMUM
SETUP TIME.
	#

EXTERNAL LMMERR,LMPNER
EXTERNAL UPTUAC,%COW,%COW.N,%UPLMA

FRMRVA::UHRRZ	U,(M)		;GET ADDRESS IN U
	CAILE	U,17		;SKIP IF REGISTERS
	JRST	FRMRVM		;ITS TO MEMORY
	MOVEI	P3,.ARRAC	;THE CAPABILITY
	PUSHJ	P,FDWUPX
	  JRST	FRVERR		;SOMETHING WRONG, CODE IN P3
	MOVE	T1,%UPX+UPTUAC(U) ;GET FRAME'S AC (IF SELF, GET OLD ACS)
	UMOVEM	T1,1(M)		;STORE IN ARG BLOCK
	JRST	CPOPJ1		;AND RETURN.

FRMWVA::UHRRZ	U,(M)		;GET ADDRESS IN U
	CAILE	U,17		;SKIP IF IN REGISTERS
	JRST	FRMWVM		;NOT, DO IT TO MEMORY
	MOVEI	P3,.ARWAC	;WRITE ACS ACCESS CODE
	PUSHJ	P,FDWUPX
	  JRST	FRVERR		;COMETHING WRONG, CODE IN P3
	UMOVE	T1,1(M)		;GET DATA TO WRITE
	MOVEM	T1,%UPX+UPTUAC(U)	;STORE INTO USER'S AC
	JRST	CPOPJ1		;AND RETURN.

FRVERR:	UMOVEM	P3,(W)
	POPJ	P,
;HERE IF READING OR WRITING NON-REGISTER MEMORY

FRMRVM:	XCTBU	<SETMM 1(M)>	;IN CASE ITS COW, WE'RE USING %COW.
	SETZ	S,		;INDICATE A READ
	PUSHJ	P,FRMXVM	;DO THE WORK, GET THE DATA
	  JRST FRVERR		;STORE ERROR CODE AND RETURN.
	UMOVEM	T1,1(M)		;OK GIVE THE DATA TO CALLER
	JRST	CPOPJ1		;AND RETURN.

FRMWVM:	UMOVE	T1,1(M)		;GET DATA
	MOVSI	S,IO		;INDICATE WRITE
;	PJRST	FRMXVM

FRMXVM:	TLNN	S,IO		;IF READ,
	SKIPA	T3,[<CPRRED>B7!1B17+%COW.N+CNVVPN] ;THEN MAP IT READ ONLY
	MOVE	T3,[<CPRRDW>B7!1B17+%COW.N+CNVVPN] ;ELSE MAP IT WRITEABLE
	LDB	T4,[POINT 9,U,26] ;PAGE NUMBER
	TLO	T4,OTFFLG	;INDICATE THAT ITS THE "OTHER" FRAME
	MOVE	T2,P4		;GET FD IN RH OF T2
	HRLI	T2,.FOREP	;REPLICATE
	FRMOP	T2,T3		;DO THE REPLICATE
	  JRST	FRMXVE		;ERROR.
	MOVSI	T2,LMPNER	;IGNORE ERROR BIT
	IORM	T2,%UPLMA+%COW.N+CNVVPN ;SET IT.
	ANDI	U,777		;LOCATION WITHING PAGE
	TLNN	S,IO		;IF READ,
	SKIPA	T1,%COW(U)	;THEN PICK UP DATE
	MOVEM	T1,%COW(U)	;ELSE STORE DATA.
				;HAD BETTER NOT FAIL - WHAT ABOUT I/O ERRORS?
	MOVSI	T3,LMMERR	;MAKE SURE NOT ERRORS HAPPENED
	TDNE	T3,%UPLMA+%COW.N+CNVVPN ;DID THEY?
	JRST	FRVIOE		;YES, GIVE I/O ERROR CODE
	MOVE	T3,[1B17+%COW.N+CNVVPN]
	VCLEAR	T3,
	  STOPCD		;SHOULD NOT HAPPEN.
	JRST	CPOPJ1		;DONE, SUCCESS.

FRVIOE:	MOVEI	P3,FEIOE%	;I/O ERROR
	JRST	FRVERR		;STORE ERROR CODE AND RETURN.

FRMXVE:	LDB	P3,[POINT 6,T2,5] ;GET SUBCODE
	JUMPN	P3,FRVERR	;IF NON-ZERO, THAT'S THE ERROR CODE.
	MOVEI	P3,FEADB%	;OTHERWISE INDICATE REPLICATE FAILURE
	JRST	FRVERR		;AND GO.
SUBTTL	.FOSAA=4 Start at absolute address
COMMENT # HERE ON START FRAME AT ABSOLUTE ADDRESS FUNCTION.
FRAME DESCRIPTOR IS IN P4. FORMAT OF THE UUO CALL IS

	MOVE	AC,[FN,,FD]
	FRMOP	AC,ADDR
	  <ERROR>
	<SUCCESS>

ADDR:	STARDI,,ADDRESS.

IF STARDI IS SET, THE ADDRESS IS THE ACTUAL ADDRESS TO START THE FRAME
AT. IF STARDI IS ZERO, THE ADDRESS IS THE ADDRESS OF THE ADDRESS IN
THE TARGET FRAME WHERE THE ADDRESS IS TO BE FOUND.
(STARDI IS DEFINED TO BE 1B0 IN COMCON - STARCL IS 1B1).
(USEFUL FOR STARTING AT START ADDRESS IN .JBSA, .JBDDT, .JBREN, ETC.
OF TARGET FRAME.
#

EXTERNAL UPTSTS,STARTX,MONJBX,JBTLIC,JBTSLC,UPTPID,UPTSPD,UPTPC,JBTSTS
EXTERNAL UPTXAC,PJBSTS,UPSPSR,UPNPSR,TIOWQ,SLPQ,STRTAD,SETRUN,STRTCL
EXTERNAL STARDI,STARCL

FRMSAA:	UMOVE	P1,(M)		;E POINTS TO STARDI,,ADDRESS.
	TLZ	P1,STARCL	;DON'T LOOK AT INCREMENT BIT USED IN FRMSVA
	MOVEI	P2,4		;STREAM ACCOUNTING RECORD TYPE TO WRITE.
	MOVEI	P3,.ARSAA	;MUST HAVE ABILITY TO START AT ABSOLUTE ADDRESS.

	PUSHJ	P,FDWUPX	;GET CONTEXT PAGES
	  PJRST	FRVERR		;COULD NOT, GIVE ERROR
	HRLS	T1,JBTLIC(J)	;RESET PROCESS LICENSE TO FRAME LICENSE
	HRLM	T1,JBTSLC(J)	;AND SAVED LICENSE TOO
	SETZM	%UPX+UPTPID	;GET RID OF PID AND
	SETZM	%UPX+UPTSPD	;SAVED PID.
	PJRST	FRMSTR		;DO THE WORK.
SUBTTL	.FOSVA=22 Start frame at start vector address

COMMENT #
CALL IS:

	MOVE	AC,[FN,,FD]
	FRMOP	AC,ADDR
	  <ERROR>
	<SUCCESS>
ADDR:	-VE JOB DATA AREA START VECTOR NUMBER OR
	  POSITIVE USER SPECIFIED START VECTOR NUMBER
#

FRMSVA:	UMOVE	P1,(M)		;GET NUMBER
	MOVEI	P3,.ARSVA	;NEED TO BE ABLE TO DO THIS MUCH
	PUSHJ	P,FDWUPX	;LOCK UPX AND SEE IF CAN
	  PJRST	FRVERR		;NO, CANNOT
	MOVEI	P2,4		;START RECORD TYPE
	JUMPGE	P1,FRMSV1	;JUMP IF SPECIFYING USER ONE
	ADDI	P1,1		;TURN FROM -N TO -N+1 = -(N-1)
	MOVMS	P1		;TURN INTO N-1
	CAIL	P1,JDSVLN	;CHECK RANGE
	 JRST	FEWBSV		;BAD START VECTOR OFFSET
	CAIN	P1,JDSVCO	;IS IT CONTINUE?
	 JRST	FRMCO0		;YES, DO A CONTINUE.
	MOVE	P1,JDSVTB(P1)	;GET USER LOC TO GET START ADDR FROM
	PJRST	FRMSTR		;AND DO THE WORK.

JDSVTB:	phase 0
	.JBSA##			;(-1) NORMAL START ADDRESS
JDSVCL:!STARCL,,.JBSA		;(-2) CCL START ADDRESS
	.JBREN##		;(-3) REENTER ADDRESS
	.JBDDT##		;(-4) DDT START ADDRESS
JDSVCO:!0			;(-5) CONTINUE POINT.
JDSVLN:!			;table length
	dephase
;HERE IF WANTS TO START IN USERS START VECTOR

EXTERNAL UPTSTV

FRMSV1:	SKIPN	T1,%UPX+UPTSTV	;GET START VECTOR WORD
	JUMPE	T1,FEWBSV	;BAD START VECTOR OFFSET - NO START VECTOR!
	HLRZ	T2,T1		;GET COUNT
	CAML	P1,T2		;SKIP IF OFFSET LESS THAN MAX+1
	JRST	FEWBSV		;OFFSET IS NO GOOD.
	ADDI	P1,(T1)		;OK, GET ADDRESS IN USER'S SPACE TO START THRU
	TLZ	P1,STARDI!STARCL!-1 ;GET RID OF POSSIBLE JUNK
	PFALL	FRMSTR		;AND START THE FRAME UP THERE.
;HERE FROM ALL START FRAME FUNCTIONS TO DO THE WORK. THE CODE
; STARTS THE SAME MONITOR JOB IN THE TARGET FRAME AS COMCON
; DOES WHEN A FRAME'S COMMAND PORT PERFORMS A START COMMAND.
; THIS MAKES IT EASIER TO SET JOBOPC, FETCH A START ADDRESS
; FROM THE TARGET FRAMES ADDRESS SPACE, ETC.

FRMSTR:	SKIPGE	JBTSTS(J)	;MAKE SURE RUN BIT IS OFF
	JRST	FEWALR		;ALREADY RUNNING ERROR RETURN.
	MOVE	T1,%UPX+UPTPC	;GET OLD PC
	TLNN	T1,PC.USR	;IN USER MODE ALREADY?
	JRST	FRSNUM		;NO, MAY HAVE TO SET UTRP
FRSST1:	MOVEM	P1,%UPX+UPTXAC+T3 ;STARTX EXPECTS NEW PC IN T3 WHEN ITS MONJOB RUNS
	MOVE	T1,%UPX+UPTPC	;OLD PC
	MOVEM	T1,%UPX+UPTXAC+T4	;IS EXPECTED IN T4
	MOVEM	P2,%UPX+UPTXAC+P4	;ACCT CODE IN P4
	MOVEI	T2,STARTX	;END OF START CODE IN COMCON
	AOS	(P)		;SKIP RETURN, WE SUCCEEDED.
	PJRST	MONJBX		;AND START MONITOR JOB FOR OTHER FRAME.

;HERE IF CANNOT START THE FRAME UP RIGHT AWAY SET A UTRP TO DO SO
; IF NOT OK TO START FROM EXEC MODE.
; PC TO START IS IN P1, STREAM RECORD TYPE TO WRITE IS IN P2.

FRSNUM:	MOVE	T1,JBTSTS(J)	;GET THIS
	TDNE	T1,[JERR,,JDCON] ;IF THESE SET, OK TO START
	JRST	FRSST1		;JUST START NORMALLY
	LDB	T1,PJBSTS	;GET WAIT STATE
	CAIE	T1,TIOWQ
	CAIN	T1,SLPQ
	JRST	FRSST1		;OK TO TAKE OUT OF TI OR SL.
	HRRM	P1,%UPX+UPTSTS	;CAN'T START, SET ADDRESS OR ADDR OF ADDRESS
	MOVE	T1,%UPX+UPTSTS	;GET IT
	SKIPL	P1		;SKIP IF ITS INDIRECT
	TLZA	T1,STRTAD	;ITS INDIRECT (@120, ETC)
	TLO	T1,STRTAD	;ITS NOT
	TLNE	P1,STARCL	;NEEDS CCL ADDRESS?
	TLO	T1,STRTCL	;YES, TELL USRXIT.
	MOVEM	T1,%UPX+UPTSTS	;SET IT
	MOVEI	T1,UTRP
	IORM	T1,JBTSTS(J)	;SO USRXIT WILL NOTICE
	DPB	P2,UXYPSR	;FOR USRXIT TO WRITE STREAM
	AOS	(P)		;GIVE GOOD RETURN
	PJRST	SETRUN		;AND SET RUN BIT, PUT HIM BACK INTO
				; WHATEVER WAIT HE WAS IN AND START HIM
				; WHEN HE COMES BACK TO USRXIT.
SUBTTL	.FOJMP=0 Gate jump to other frame

COMMENT #
CALL:
	MOVEI	AC,<CREATED FH INDEX> ;JUMP IS FUNCTION ZERO
	FRMOP	AC,[PC WORD + 1B17 IF ADDRESS IS VECTOR ADDRESS]
	  <ERROR RETURN>
	<RETURN HERE IF FRAME JUMPED TO JUMPS BACK TO CONTINUE ADDRESS>
#

XP FJ.VEC,(1B17)		;USE INDEX AND INDIRECT FIELD IN PC TO SPECIFY ABS OR VECTOR.

DEFINE BTXGEN(X)<DEFINE BTXN'X(AC,SYM)<IFLE <'SYM-'SYM/^D36*^D36-^D17>,<TLN'X 'AC,(1B<'SYM-'SYM/^D36*^D36>)>
	IFG <'SYM-'SYM/^D36*^D36-^D17>,<TRN'X 'AC,1B<'SYM-'SYM/^D36*^D36>>
>>;END BTXGEN MACRO DEFINITION
BTXGEN(E)
BTXGEN(N)

EXTERNAL TIMEF,CURUPT,EPLLEN,ABKSET,JOB,JBYQNT,STOP1,USCHED,USRXIT

FRMJMP:	UMOVE	P1,(M)		;GET DESIRED PC
	TLO	P1,PC.USR!PC.PUB	;MAKE SURE HE CAN'T START UP ANYONE IN EXEC MODE
	CAILE	P4,FHIMAX	;IS HANDLE INDEX VALID?
	JRST	FEWBDH		;NO
	SKIPN	P4,%UPT+UPTFHT(P4) ;GET HANDLE ADDRESS IF ANY
	JRST	FEWNOH		;NONE, GIVE ERROR.
	HRRZ	P3,.FHFNO(P4)	;GET FRAME NUMBER IN RH P3
	MOVE	T1,.FHUID(P4)	;MAKE SURE UID MATCHES
	CAME	T1,JBTUID(P3)	;MATCH?
	JRST	FEWBDI		;NO, GIVE ERROR. BAD UID.
				; (FRAME COULD HAVE LOGGED OUT)
	LDB	T1,[HTPPTR(.FHTYP(P4))] ;GET HANDLE TYPE
	MOVE	T2,.FHART(P4)	;GET ACCESS RIGHTS IN T2
	CAIN	T1,.FHPRC	;IF NOT PROCESS HANDLE, DON'T CHECK PNO
	JRST	[MOVE T3,.FHPNO(P4) ;PROCESS HANDLE, MUST MAKE SURE PNO MATCHES
		 CAME T3,JBTPNO(P3) ;MUST MATCH OR ELSE
		 JRST FEWNRT	;NO RIGHTS
		 JRST .+1]	;OK.
	CAIN	T1,.FHFRM	;IF FRAME HANDLE,
	AND	T2,JBTMFR(P3)	;THEN AND RIGHTS WITH MFR
	TLNE	P1,FJ.VEC	;IF VECTOR,
	JRST	[BTXNN T2,.ARSVA ;CHECK FOR PROPER BIT
		 JRST FEWNRT	;NO RIGHTS
		 JRST FRMJM0]	;OK.
	BTXNN	T2,.ARSAA	;CHECK FOR ABSOLUTE
	JRST	FEWNRT		;SORRY.
FRMJM0: PFALL	FRJSTS
;NOW CHECK TO SEE IF THE FRAME CALLER IS JUMPING TO CAN BE JUMPED
; INTO QUICKLY, OR WHETHER IT HAS TO BE DONE THE SLOW WAY.
;P1 HAS DESIRED STARTING PC, P2 HAS OLD PC (POINTS TO FRMOP+1),
; J HAS CALLER'S FRAME NUMBER, P3 HAS NEW FRAME FRAME NUMBER.

FRJSTS:	HLRZ	T1,JBTSTS(P3)	;OK, CAN CALL, GET JBTSTS, EXTEND RN BIT
	TRZ	T1,RUNMSK!JRQ	;CLEAR DON'T CARE BITS
	CAIE	T1,RUNABLE-RUN	;IS HE RUNNABLE EXCEPT FOR RUN BIT??
	JRST	FRJNRN		;SEE IF MRQ IS PROBLEM.
	SKIPE	TIMEF		;CHECK CLOCK - MAKE SURE DON'T
				; KEEP SCHEDULER FROM RUNNING BY MANY FAST GATE JUMPS.
	JRST	FRJSLO		;GO DO IT THE SLOW WAY, GIVE SCHEDULER A CHANCE TO RUN.
	AOS	T1,%UPT+UPTPDL	;GET CALLER PC, TURN IT INTO SKIP
	MOVEM	T1,%UPT+UPTPC	;MAKE THIS OUR RETURN PC SO HE CAN JUMP BACK (MUST BE USER MODE)

;JSP P1,FRJCTS FROM JUMPED TO FRAME IF START VECTOR IS BAD.
; P3 CONTAINS FRAME TO JUMP TO, J CONTAINS JUMPING FRAME,
; P1 HAS PC.

FRJCTS:	HRRZ	T1,JBTUPM(P3)	;GET UPT WORD

DEFINE SETMAP,<
IFCPU (KI),<
	HRLM	T1,CURUPT
	DATAO	PAG,CURUPT	;Combined WREBR and WRUBR
>;END IFCPU (KI)
IFNCPU (KI),<
	MOVEM	T1,CURUPT	;SAVE IT
	TLO	T1,(LG.LUB)	;JUST LOAD UBR
	WRUBR	T1		;AND SET IT
>;END IFNCPU (KI)
>;END SETMAP MACRO DEFINITION

	SETMAP
	MOVE	T1,%UPT+UPTPC	;GET HIS PC BEFORE WE DESTROY ANYTHING.
	TLNN	T1,PC.USR	;MAKE SURE IT WAS IN USER MODE
	JRST	[HRRZ T1,JBTUPM(J) ;GET OUR OWN MAP BACK
		 SETMAP
		 SOS %UPT+UPTPDL ;UN-SKIP RETURN.
		 JRST FEWCJF]	;SAY CAN'T JUMP TO FRAME
	XCT	ABKSET		;WAS, SET ADDRESS BREAK SETTING
	MOVEM	P3,JOB		;SETUP JOB TO NEW NUMBER
	MOVSI	T3,RUN
	ANDCAM	T3,JBTSTS(J)	;MAKE OLD FRAME STOP
	PUSHJ	P,REQUE		;HE IS NO LONGER CURRENT JOB
	LDB	T2,JBYQNT	;GET QUANTUM FOR OLD JOB
	EXCH	J,P3
	IORM	T3,JBTSTS(J)	;SET RUN BIT FOR NEW GUY
	DPB	T2,JBYQNT	;SETUP NEW RUN QUANTUM
	PUSHJ	P,REQUE		;AND FLAG SO SCHEDULER WILL PUT HIM INTO RUN QUEUE
	TLZE	P1,FJ.VEC	;SKIP IF ABSOLUTE, NOT VECTOR
	JRST	FRJVEC		;IS VECTOR, DO IT.
	TLZ	P1,(@(17))	;CLEAR OUT BITS THAT MUST BE CLEAR
	MOVEM	P1,%UPT+UPTPC	;SET IT HERE
	USERAC			;SWITCH TO USER ACS IF NECESSARY
	JEN	@%UPT+UPTPC	;AND DISMISS
FRJVEC:	HRRE	T1,P1		;GET THE NUMBER
	JUMPGE	T1,FRJUVC	;GO IF USER VECTOR
	ADDI	T1,1		;TURN FROM -N TO -N+1 = -(N-1)
	MOVMS	T1		;TURN INTO N-1
	CAIN	T1,JDSVCO	;IS IT CONTINUE?
	 JRST	FRJVGO		;GO SWITCH TO USERACS AND JUST DISMISS THRU UPTPC
	CAIL	T1,JDSVLN	;MAKE SURE ITS WITHIN RANGE
	 JRST	FRJBSV		;BAD START VECTOR
	HRRZ	T2,JDSVTB(T1)	;GET USER ADDRESS CONTAINING START ADR
	XCTFU	<HRR P1,(T2)>	;GET THE START ADDRESS
	CAIN	T1,JDSVCL	;CCL?
	 ADDI	P1,1		;YES
	TLZ	P1,(@(17))	;CLEAR OUT BAD BITS
	MOVEM	P1,%UPT+UPTPC	;SET IT HERE
FRJVGO:	USERAC			;SWITCH TO USER ACS IF NECESSARY
	JEN	@%UPT+UPTPC	;AND DISMISS

FRJUVC:	SKIPN	T1,%UPT+UPTSTV	;GET START VECTOR WORD
	JRST	FRJBSV		;BAD START VECTOR
	HLRZ	T2,T1		;GET COUNT
	CAIG	T2,(P1)		;MAKE SURE SIZE IS BIGGER THAN OFFSET
	JRST	FRJBSV		;BAD START VECTOR
	ADDI	P1,(T1)		;GET RH(P1) THE ADDRESS OF START ADDRESS IN USER SPACE
	XCTBU	<HRR P1,(P1)>	;GET THE ADDRESS FROM USER
	TLZ	P1,(@(17))	;CLEAR OUT BAD BITS
	MOVEM	P1,%UPT+UPTPC	;SET IT HERE
	USERAC			;SWITCH TO USER ACS IF NECESSARY
	JEN	@%UPT+UPTPC	;AND DISMISS

;HERE IF START VECTOR WAS BAD.
;  J HAS FRAME NUMBER OF JUMPED TO FRAME, P3 HAS OLD FRAME NUMBER.

FRJBSV:	JSP	P1,FRJCTS	;CONTEXT SWITCH BACK
	EXECAC			;MUST SWITCH BACK TO EXEC ACS
	MOVE	P,[-EPLLEN+1,,%UPT+UPTPDL] ;SETUP STACK TO POINT AT RETURN PC FOR USRXIT
	MOVEI	T1,FEBSV%	;BAD START VECTOR
	UMOVEM	T1,(W)		;GIVE THAT AS ERROR CODE
	SOS	(P)		;WAS SET FOR SKIP RETURN, SET FOR NON-SKIP
	JRST	USRXIT		;AND GIVE HIM ERROR RETURN.
;HERE WITH JBTSTS LH IN RH(T1) IF HE'S NOT RUNNABLE.

FRJNRN:	TRNE	T1,RUN		;IF HE HAS RUN BIT ON, NO DEAL
	JRST	FEWALR		;ALREADY RUNNING.
	TRZ	T1,MRQ!CMWB!JRQ	;IF THESE ARE ON, WE CAN STILL START
	CAIE	T1,RUNABLE-RUN	;RUNNABLE NOW?
	JRST	FEWCJF		;CANT JUMP, HAS SOME BAD BIT ON OR NON-ZERO WAIT STATE.

;HERE IF EITHER CLOCK HAS TICKED OR TARGET FRAME'S CONTEXT PAGES
; AREN'T ACTIVE. MUST DO IT BY HAND.

FRJSLO:	MOVE	J,P3		;GET TARGET FRAME NUMBER INTO J
	MOVEI	P3,.ARSVA	;ASSUME START VECTOR
	TLNN	P1,FJ.VEC	;IF NOT,
	MOVEI	P3,.ARSAA	;THEN CHECK ABSOLUTE
	UMOVE	P4,(W)		;GET INDEX IN P4 AGAIN FROM USER AC
	MOVEI	P4,.FDFRH(P4)	;TURN INTO A FRAME DESCRIPTOR.
	PUSHJ	P,FD2WL1	;GET HIS CONTEXT PAGES WRITE LOCKED
	  JRST	FRVERR		;STORE ERROR CODE.
	MOVE	T1,%UPX+UPTPC	;MAKE SURE HIS PC IS IN USER MODE.
	TLNN	T1,PC.USR
	JRST	[PUSHJ P,ULDUPX
		 JRST FEWCJF]	;GIVE BACK UPX AND GIVE PROPER ERROR.
	MOVEI	T1,%UPX+UPTUAC
	XCTFU	<BLT T1,%UPX+UPTUAC+17> ;COPY ACS TO DESTINATION
	PUSHJ	P,ULDUPX	;UNLOCK CONTEXT PAGES NOW
	UMOVE	P3,(W)		;GET INDEX IN P3 AGAIN
	MOVEI	P3,.FDFRH(P3)	;FRAME HANDLE
	HRLI	P3,.FOSAA	;ASSUME ABSOLUTE
	TLNN	P1,FJ.VEC	;SKIP IF VECTOR STARTING ADDRESS
	JRST	[HRLI P1,STARDI ;NOT. SAY ITS NOT INDIRECT
		 HRLI P3,.FOSAA ;SAY ITS ABSOLUTE
		 JRST FRJSL1]	;AND DO THE FRMOP
	HRLI	P3,.FOSVA	;DO PROPER START FUNCTION
	HRRES	P1		;EXTEND SIGN IN CASE ARG IS NEGATIVE.
FRJSL1:	FRMOP	P3,P1		;START UP THE OTHER FRAME
	  JRST	FRVERR		;STORE THE ERROR CODE FROM START FRMOP AS ERROR CODE FOR THIS ONE.



SUBTTL	.FOGIN=26 Gate jump Initialization

;HERE IS GATE JUMP INIT FRMOP. IT JUST STOPS THE JOB WITHOUT
; INTERRUPTING ANYONE, AND WITHOUT CHANGING THE TTY STATE, AND
; ENSURES THAT THE PC IS IN USER MODE, SO THAT THE CALLED FRAME
; CAN CALL BACK.

FRMGIN:	MOVE	J,%UPT+UPTJOB	;SETUP J FOR STOP1
	MOVE	P,[-EPLLEN+1,,%UPT+UPTPDL] ;POINT SO THAT POPJ PUTS PC INTO UPTPC
	PUSHJ	P,STOP1		;STOP THIS JOB
	AOS	(P)		;GIVE SKIP RETURN.
	PJRST	USCHED		;AND CALL SCHEDULER.
SUBTTL	.FOCLR=14 Clear a stopped frame
;HERE ON ZAP FRAME

FRMCLR:	MOVEI	P3,.ARCLR
	PUSHJ	P,FDWUPX	;SEE IF CAN DO IT, RETURN WITH CTX IF SO
	  JRST	FRVERR		;CAN'T DO IT.
	SKIPGE	JBTSTS(J)	;MUST BE STOPPED
	  JRST	FEWALR		;IS RUNNING, SORRY.
	MOVEI	T2,CLRFRM##	;GLOBAL PLACE THAT ZAPS JOBS
	AOS	(P)		;GIVE CALLER THE SKIP RETURN
	PJRST	MONJBX		;GO ZAP IT.
SUBTTL	.FOGET=32 Get new core image from SAVE file
SUBTTL	.FORUN=33 Run program in frame
SUBTTL	.FOSAV=34 Save frame's core image
SUBTTL	.FOSSA=35 Sharable save frame's core image

; Call is

;	MOVE	ac,[fn,,fd]
;	FRMOP	ac,adr
;	  error return
;	success return
;
;adr:	XWD 	start-incr,cnt	; number of arguments following
;	SIXBIT 	"dev"
;	XWD 	gan,uun
;	SIXBIT 	"name"
;	SIXBIT 	"ext"		; don't specify this!
;	XWD	ru-lic,core
;cnt==	.-adr-1

; This starts a monitor job for the target frame that actually gets
; (saves) the core image.  The license of the target frame applies
; for file access.

EXTERNAL GETFRM,RUNFRM,SAVFRM,GETFMU,RUNFMU,SAVFMU
EXTERNAL GNUARG,GNUARX,SG3
EXTERNAL HSLIC,LSLIC,NOSHR
EXTERNAL JBTNAM

;GET/RUN/SAVE table
; access-right-code,,monitor-job-address

GRSTAB:	XWD .ARVAW,GETFRM	;get
	XWD .ARVAW,RUNFRM	;run
	XWD .ARVAR,SAVFRM	;save
	XWD .ARVAR,SAVFRM	;ssave

FRMGET:	TDZA	P1,P1		; P1/ 0 ;for GET
FRMRUN:  MOVEI	P1,1		; P1/ 1 ;for RUN
	JRST	FRMGRS
FRMSAV:	SKIPA	P1,[2]		; P1/ 2 ;for SAVE
FRMSSA:	 MOVEI	P1,3		; P1/ 3 ;for SSAVE

FRMGRS:	HLRZ	P3,GRSTAB(P1)	;obtain proper access right code
	PUSHJ	P,FDWUPX	;check rights, return with %UPX if ok
	 JRST	FRVERR		;can't do it.
	TLZ	W,NOSHR!HSLIC!LSLIC ;clear flags of unwanted type
	CAIE	P1,3		;sharable save?
	 TLO	W,NOSHR		; no - flag it
;****** remove this JRST .+3 when GRS on self is working   /WRS 5-14-80
GRSPAT::JRST 	.+3		;GRS code crashes, disable if for now
;****** note: patch GRSPAT to JUMP .+3 for debugging GRS on self
	CAMN	J,JOB		;is he talking about himself?
	 JRST	GRSSLF		; yes - go GET/RUN/SAVE self
	SKIPGE	JBTSTS(J)	;must be stopped
	 JRST	FEWALR		; is running, sorry.
	PUSHJ	P,GNUARX	;get new user arguments into %UPX+UPTXAC
	 JRST	FEWBCN		; error - bad arg count
	MOVE	T2,%UPX+UPTXAC+P2 ;get program name
	CAIGE	P1,2		;if GET or RUN (0 or 1),
	 MOVEM	T2,JBTNAM(J)	; set new name for SYSTAT
	HRRZ  	T2,GRSTAB(P1)	;get address of monjob to queue
	SETZM	%UPX+UPTPID	;clear out pids
	SETZM	%UPX+UPTSPD	;clear out pids
	AOS	(P)		;give caller the skip return
	PJRST	MONJBX		;go zap it.

GRSSLF:	PUSHJ	P,ULDUPX	;don't need %UPX for self
	POP	P,U		;discard return address from FDWUPX
	PUSHJ	P,GNUARG	;get new user args on stack
	 JRST	FEWBCN		; error - bad arg count
	PUSHJ	P,SG3		;hack JOBDAT and set up XPACOM
	CAIGE	P1,2		;if GET or RUN (0 or 1),
	 CALLI	0		;do a reset
	JRST	@[EXP GETFMU,RUNFMU,SAVFMU,SAVFMU](P1)
	
SUBTTL	.FOENA=45 Enable  frame license
SUBTTL	.FODIS=46 Disable frame license

; Call is
;
;	MOVE	ac,[fn,,fd]
;	FRMOP	ac,adr
;	  error return
;	success return
;
;adr:	license-to-enable-or-disable
;
;  .FOENA
;	If <license> = -1, then all saved license is enabled
;	otherwise, the minimum of saved license and <license> is
;	enabled for the frame.
;
;
;  .FODIS
;	If <license> = -1, then all frame license is cleared
;	otherwise, the specified <license> is disabled for the frame.
;	If either LICWPJ or LICWFL are specified, both are disabled.
;	If either LICRPJ or LICRFL are specified, both are disabled.
;
; Note: LICRMT and LICHR are not settable on a frame, so they don't
;	really matter to this code.
;

FRMENA:	MOVEI	P3,.ARPLC	;Pass license - access right needed
	PUSHJ	P,FDRUPX	;GET UPX READ LOCKED (OR WRITE LOCKED?)
	  JRST	FRVERR		;Cannot
	UMOVE	T2,(M)		;Get license to enable
	CAMN	T2,[-1]		;Is it everything?
	  JRST	[HRRZ  T2,JBTSLC(J)	;Yes, get saved frame license
		 JRST  FRMEN1]		; and enable all of it
	HRL	T2,JBTSLC(J)	;No, copy saved frame license
	PUSHJ	P,LICMSK##	;Get what is allowable
	HRL	T2,JBTLIC(J)	;Copy current license
	PUSHJ	P,MAXLIC##	;Get maximum allowable
FRMEN1:	HRRM	T2,JBTLIC(J)	;Set it on specified frame
	UMOVEM	T2,(M)		;Store license in user ac
	JRST	CPOPJ1		;Return


FRMDIS:	MOVEI	P3,.ARPLC	;Pass license rights needed
	PUSHJ	P,FDRUPX	;Get UPX read lock
	  JRST	FRVERR		;Cannot
	UMOVE	T2,(M)		;Get license to disable
	CAMN	T2,[-1]		;Is it everything?
	  JRST	[SETZ  T2,	;Clear frame license
		 JRST  FRMEN1]	; for the frame
	HRL	T2,JBTLIC(J)	;Copy current frame license
	PUSHJ	P,LICMSK##	;Get what is allowed
	TRNE	T2,LICWPJ+LICWFL;Any WP-WF bits enabled
	  TRO	T2,LICWPJ+LICWFL;Yes, set both
	TRNE	T2,LICRPJ+LICRFL;Any RP-RF bits enabled
	  TRO	T2,LICRPJ+LICRFL;Yes, set both
	ANDCAB	T2,JBTLIC(J)	;Disable (clear) license
	UMOVEM	T2,(M)		;Store license in user ac
	JRST	CPOPJ1		;Skip return

SUBTTL	.FOHLT=5 Halt frame
COMMENT #HERE ON STOP FRAME. FRAME DESCRIPTOR IS IN P4.
FORMAT OF CALL IS

	MOVE	AC,[FN,,FD]
	FRMOP	AC,
	  <ERROR RETURN>
	<SUCCESS RETURN>
#

EXTERNAL JBTSTS,DELAYN,PJBSTS,TRHALT

FRMHLT:	MOVEI	P3,.ARHLT	;MUST HAVE HALT ACCESS RIGHT
	PUSHJ	P,FDWUPX	;TRY TO GET
	  JRST	FRVERR		;PASS ERROR CODE IN P3 BACK TO USER.
	SKIPL	T1,JBTSTS(J)	;MAKE SURE HE'S RUNNING
	JRST	FEWALH		;ALREADY STOPPED.
	TRZ	T1,JDCON	;CLEAR THIS SO ONCE A MINUTE STOPS
	TLNE	T1,JACCT	;CAN'T STOP JACCTED FRMAE
	JRST	FEWCSJ		;"CANT STOP JACCT"
	MOVEM	T1,JBTSTS(J)	;OK TO STORE JBTSTS NOW, WE WILL STOP HIM
	MOVE	T1,%UPX+UPTPC	;GET PC
	TLNE	T1,PC.USR	;IF IN USER MODE, STOP RIGHT NOW.
	JRST	FRMHLN		;HALT NOW.
	LDB	T1,PJBSTS	;NO, SEE WHAT STATE CODE IS
	MOVEI	T2,1
	LSH	T2,(T1)		;GET BIT FOR DELAYN
	TDNN	T2,DELAYN	;NEED TO STOP LATER?
	JRST	FRMHLN		;NO, HALT IT NOW.
	MOVSI	T1,CNTRLC	;YES, SET CONTROL C BIT FOR USRXIT
	IORM	T1,JBTSTS(J)
	JRST	CPOPJ1		;AND GIVE GOOD RETURN.

FRMHLN:	AOS	(P)		;HALT IT NOW.
	PJRST	TRHALT		;GIVE PARENT TRAP, STOP FRAME, GIVE GOOD RETURN TO USER.


SUBTTL	.FOSTP=41 Stop Frame (^C)

;;  FRMSTP - Non-privileged version of FRMHLT.
;;  Requires .ARSTP access right only, fakes ^C.

FRMSTP:	MOVEI	P3,.ARSTP	;Low privilege
	PUSHJ	P,FDWUPX	;Lock down UPT
	  JRST	FRVERR
	MOVSI	T1,JACCT	;The only exception
	TDNE	T1,JBTSTS(J)	;JACCT set?
	  JRST	FEWCSJ		;Can't Stop with JACCT set
	HRRZ	F,TTYTAB##(J)	;Command port TTY DDB address
	HRRZ	U,DDBLDB##(F)	;Line Data Block address (if any)
	SKIPE	U		;Skip if detached
	PUSHJ	P,TTYHLT##	;If not, put TTY in command mode
	MOVEI	T1,CMFCHT##	;Forced command index for ^C
	PUSHJ	P,COMWCM##	;Force command on frame
	PJRST	CPOPJ1##	;Give good return
SUBTTL	.FOFRC=42 Force Command for frame

;;  FRMFRC - Force a command on a frame.
;;  Argument is a SIXBIT string which must be a
;;  command from the forced command table in COMCON.
;;  The calling frame must have .ARVAW access rights to the
;;  target frame, and the target frame must be halted.

FRMFRC:	MOVEI	P3,.ARVAW	;Must have write access to target frame
	PUSHJ	P,FDWUPX	;Lock down UPT
	  JRST	FRVERR
	SKIPGE	JBTSTS(J)	;Frame halted?
	  JRST	FEWALR		;If not, give Already Running error
	UMOVE	T1,(M)		;Pick up user's argument word
	LDB	T2,[POINT 6,T1,5] ;Check first character
	CAIE	T2,'.'		;These are monitor-internal only
	 PUSHJ	P,CMFIDX##	;Convert to forced command table index
	  JRST	FEWILC		;No such forced command, say Illegal
	HRRZ	F,TTYTAB##(J)	;Command port TTY DDB address
	HRRZ	U,DDBLDB##(F)	;Line Data Block address (if any)
	PUSH	P,T1		;Save index returned by FCMIDX
	SKIPE	U		;Skip if detached
	  PUSHJ	P,TTYHLT##	;If not, put TTY in command mode
	POP	P,T1		;Restore forced command table index
	PUSHJ	P,COMWCM##	;Force command on frame
	PJRST	CPOPJ1##	;Give good return
SUBTTL	.FOCON=25 Continue a frame

COMMENT #CONTINUE FRAME FRMOP. ACTUALLY, CAN ALWAYS HALT FRAME, READ
PC, AND START AT PC BECAUSE READ PC FRMOP BACKS UP PC IF WAIT
STATE WAS IN TI OR SLP. IF WAIT STATE WASN'T IN TI OR SLP,
THE START CODE WILL JUST PUT THE FRAME BACK INTO THAT WAIT STATE,
EVEN IF IT WAS SJ, AND WHEN JOB COMES OUT OF THE UUO IN USRXIT,
IT WILL BE STARTED AT THE NEW PC SPECIFIED. SINCE HIBER INCREMENTS
PC BEFORE SLEEPING, THIS WILL RESULT IN SKIP RETURN.

FORMAT OF CALL IS

	MOVE	AC,[.FOCON,,FD]
	FRMOP	AC,
	  <ERROR RETURN>
	<SUCCESS RETURN>
#

FRMCON:	MOVEI	P3,.ARSVA	;IF CAN START AT VECTOR ADDRESS, CAN CONTINUE
	PUSHJ	P,FDWUPX	;LOCK CONTEXT PAGES FOR WRITING
	  JRST	FRVERR		;CAN'T DO IT

;HERE FROM START AT VECTOR ADDRESS FRMOP IF CONTINUE IS SPECIFIED

FRMCO0:	SKIPGE	T1,JBTSTS(J)	;MAKE SURE HE'S STOPPED
	JRST	FEWALR		;CAN'T DO IT, HE'S ALREADY RUNNING.
	TLNE	T1,JERR		;IF JERR SET, NOT CONTINUABLE
	JRST	FEWCCF		;CAN'T CONTINUE FRAME
	AOS	(P)		;OK, GIVE CALLER THE SKIP RETURN AND
	PJRST	SETRUN		;MAKE HIM RUN AGAIN.

SUBTTL	.FOHST=23 Read Halt Status block

COMMENT #
CALL IS

	MOVE	AC,[FN,,FD]
	FRMOP	AC,ADDR
	  <ERROR>
	<SUCCESS>

ADDR:	COUNT			;NUMBER OF WORDS TO RETURN
				;WORDS RETURNED STARTING AT ADDR+1
ADDR+1/ HALT CLASS,,HALT TYPE
ADDR+2/ HALT COUNT
ADDR+3/ PC OF HALT OR EXIT
ADDR+4/ PC OF LAST UUO
ADDR+5/ SIXBIT DEVICE NAME IF RELEVANT
ADDR+6/ 36 BIT DATA DEPENDENT ON HALT CLASS AND TYPE (E.G. LOCATION OF ILL MEM REF)
ADDR+7/ ANOTHER TYPE DEPENDENT DATA LOCATION
#

EXTERNAL UPTHST,FHSMXC

FRMHST:	UMOVE	P1,(M)		;GET COUNT
	JUMPE	P1,FEWBCN	;ZERO NO GOOD.
	CAILE	P1,FHSMXC	;MUST NOT ASK FOR TOO MUCH
	JRST	FEWBCN		;BAD COUNT
	MOVEI	P3,.ARRUN	;NEED TO BE ABLE TO READ FRAME STATE
	PUSHJ	P,FDRUPX	;GET FOR READING
	  JRST	FRVERR		;SORRY
	MOVSI	T1,%UPX+UPTHST	;GET FROM FIRST LOCATION
	HRRI	T1,1(M)		;STORE TO ADDRESS+1
	ADDI	P1,(M)		;GET LAST LOCATION TO XFER TO
	XCTTU <BLT T1,(P1)>	;TRANSFER THE DATA
	JRST	CPOPJ1		;AND RETURN.
SUBTTL	.FORPC=6 Read PC (if PC is in user mode)
COMMENT # FRMOP TO READ A FRAME'S LAST USER MODE PC

	MOVE	AC,[FN,,FD]
	FRMOP	AC,<ADDR>
	  <ERROR>
	<SUCCESS>		;PC IN <ADDR>

IF NO USER MODE PC IS KNOWN FOR THE FRAME (E.G. JUST FINISHED A RUN)
THEN ZERO IS RETURNED IN <ADDR> AND THE SUCCESS RETURN IS GIVEN.
#

EXTERNAL UPTPDL

FRMRPC:	MOVEI	P3,.ARRDS	;HAVE TO BE ABLE TO READ FRAME STATE
	PUSHJ	P,FDRUPX	;GET UPX READ LOCKED (REALLY WRITE FOR NOW)
	  JRST	FRVERR
	MOVE	T1,%UPX+UPTPC	;GET PC
	TLNE	T1,PC.USR	;IF NOT IN USER MODE,
	JRST	FRMRP1		;USER, OK.
	MOVE	T1,%UPX+UPTPDL	;THEN GET IT OFF PDL
	LDB	T2,PJBSTS	;GET STATE CODE
	CAIE	T2,TIOWQ	;IF IN TI OR
	CAIN	T2,SLPQ		;SLEEP OR HIBER,
	HRRI	T1,-1(T1)	;THEN DECREMENT PC, MUST EXECUTE UUO OVER.
				; ELSE START CODE WILL FINISH, AND PC SHOULD BE BELIEVED AS IS.
	TLNN	T1,PC.USR	;DON'T GIVE AWAY ANY EXEC PCS
	SETZ	T1,
FRMRP1:	UMOVEM	T1,(M)		;STORE IN AC
	JRST	CPOPJ1		;AND RETURN.
SUBTTL	.FOPRJ=43 Change Project Code for frame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	FRMPRJ - Change Project Code for a frame.		;;
;;	Calling sequence:					;;
;;		MOVE	ac,[function code,,frame descriptor]	;;
;;		FRMOP	ac,addr					;;
;;		  error return	;error code in AC		;;
;;		success return					;;
;;								;;
;;	addr:			bits				;;
;;	addr+1:			chars 1-5 of project code	;;
;;	addr+2:			chars 6-10 of project code	;;
;;	addr+3:	bits 0-13	chars 11-12 of project code	;;
;;	addr+3:	bits 14-34	0				;;
;;	addr+3:	bit 35		project-code-verify bit		;;
;;								;;
;;	where <bits> =	0 to read currect project code and	;;
;;			  verify bit				;;
;;			1 to set project code but not change	;;
;;			  verify bit				;;
;;			3 to set both project code and		;;
;;			  verify bit				;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;FUNCTION OF PJCVFY BIT: REQUIRE SETTERS OF PJC TO HAVE
;WPJ OR XC LICENSE. THE UNLICENSED USER MAY NOT SET PJC WITHOUT
;RUNNING A LICENSED PROGRAM TO DO IT. BIT GETS SET BY
;CHPJC 3,AC CALL FROM LICENSED PROGRAM AT LOGIN TIME, FOR
;USERS SUBJECT TO VERIFICATION.

CHGVFY==2; IN LH AC
PJCSET==1; "  "  "
PJCVFY==1; IN RH UPTPJ2, IN RH BLOCK+2
FRMPRJ:	UMOVE	T1,(M)		;First user arg word (control bits)
	MOVSS	T1,T1		;Move into left half
	HRRI	T1,1(M)		;Now in same format as CHPJC CALLI
	SKIPA			;Skip frame descriptor set-up
				;  (use caller's)
;;
;; Enter here for CHPJC UUO (CALLI -61) from UUOCON
;;
EXTERNAL UPTPJC,UPTPJ2
INTERNAL CHPJC
CHPJC:	SETO	P4,		;Frame descriptor for self (CALLI only)
	MOVEI	P3,.ARRFI	;Need Read Frame Info to read project code
	TLNE	T1,PJCSET	;SKIP IF WANTS READ ONLY
	  MOVEI	P3,.ARVAW	;Need Write access to write project code
	MOVE	P1,T1		;Save user's address & bits
	PUSHJ	P,FDWUPX	;Check access rights & lock down target UPT
	  JRST FRVERR
;; ***NOTE*** Register J now has job number of target, not caller
	MOVE	T1,P1		;Restore bits,,user's address
	TLNE	T1,PJCSET	;Want to read only?
	  JRST	CHPJC2
	HRRZI	T2,2(T1)	;T2:=LAST USER LOC=USER BLOCK LOC+2
	HRLI	T1,%UPX+UPTPJC
	XCTTU	<BLT T1,(T2)>	;MOVE 3 WORDS TO USER
	JRST	CPOPJ1

CHPJC2:	MOVEI	T2,PJCVFY
	TDNN	T2,%UPX+UPTPJ2	;SKIP IF LIC REQUIRED TO SET PJC
	  JRST	CHPJC3
	MOVE	T2,%UPT+UPTJOB	;Get back caller's job number
	MOVE	T2,JBTLIC(T2)	; to check the license word
	TLNN	T2,LICWPJ!LICXC
	  JRST	FEWNLC		;Return Not-Enough-License error

CHPJC3:	DMOVE	P2,%UPX+UPTPJC	;P2/P3/P4:=OLD PJC
	MOVE	P4,%UPX+UPTPJ2	;P4 BIT 35:=OLD PJCVFY BIT
	HRLZ	T2,T1
	HRRI	T2,UPTPJC+%UPX	;T2:=USERLOC,,UPTLOC
	XCTFU	<BLT T2,%UPX+UPTPJ2>	;UPT:=USER BLOCK
	TLNN	T1,CHGVFY	;IF USER ASKS, TAKE PJCVFY
	  DPB	P4,[POINT 1,%UPX+UPTPJ2,35]
				;FROM HIS CORE,ELSE RESTORE FROM OLD PJC
	XCTTU	<DMOVEM P2,(T1)>;RETURN OLD PJC &
	XCTTU	<MOVEM P4,2(T1)>;PJCVFY STATUS
;WRITE ACT REC TYPE 7
;J has target job number
	MOVEI	T1,7
	PUSHJ	P,ACTWRT##
	JRST	CPOPJ1		;SKIP RETURN TO USER
SUBTTL	.FORFA=36 Read Frame Attributes
SUBTTL	.FOWFA=37 Write Frame Attributes
SUBTTL	.FOXFA=40 Exchange Frame Attributes

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	FRMOPs to read, write or write/read (exch) frame	;;
;;	attributes.  Format of call is:				;;
;;								;;
;;		MOVE	AC,[FN,,FD]				;;
;;		FRMOP	AC,ADDR					;;
;;		  <ERROR>					;;
;;		<SUCCESS>					;;
;;								;;
;;	<ADDR>:	Attribute #,,<Argument address>			;;
;;			OR					;;
;;	<ADDR>:	     0,,<Argument block address>		;;
;;		-COUNT,,<Attribute list address>		;;
;;								;;
;;	On error return, FRMOP error is in AC right, positive	;;
;;	index into argument/attribute table is in AC left.	;;
;;								;;
;;	FRMOP function codes are:				;;
;;		36 - Read frame attribute			;;
;;		37 - Write frame attribute			;;
;;		40 - Exchange (read, then write) frame attr.	;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;; FRMRFA - Read Frame Attribute
;; FRMWFA - Write Frame Attribute
;; FRMXFA - Exchange (Write/Read) Frame Attribute
;;
;; Internal register usage:
;;	S - Flag word, LH set to all ones if context pages are locked.
;;	    RH has flag bits to indicate what actions are to be taken.
;;	J - Calling frame's frame number
;;	F - LH has absolute target frame number, RH has saved frame
;;	    descriptor.
;;	U - Address if user's argument or argument list
;;	P4 - contains frame descriptor as calling parameter
;;	P3 - access rights codes
;;	P2 - Copy of initial value of U for error calculation
;;	P1 - caller's attribute code
;;

	FA.RD==1
	FA.WR==2

FRMWFA:	MOVEI	S,FA.WR		;Indicate user wants to write
	JRST	FRMFA
FRMXFA:	MOVEI	S,FA.RD!FA.WR	;Indicate both read and write
	JRST	FRMFA
FRMRFA:	MOVEI	S,FA.RD		;Indicate user wants to read
FRMFA:
	PUSHJ	P,FD2FNO	;Convert frame descriptor in P4 to
				; absolute frame number in J.
	  JRST	FRATER		;Error - code in P3
	HRRZ	F,P4		;Get frame descriptor into RH
	HRL	F,J		;And absolute frame number into LH
	UMOVE	U,(M)		;Caller's argument word
	HRRZ	P2,U		;Copy original arg addr in case error
	TLNN	U,-1		;Attribute in left half?
	 JRST	FRALST		;No, must be a list
	MOVSI	M,-1		;Make a fake AOBJN word
	HLRZ	P1,U		;Get attribute code
	TLZ	U,-1		;Clear left half of argument address
	JRST	FRANX1		;Drop into main loop
;;
;; Here if U has first word of 2-word block (list form)
;;
FRALST:	UMOVE	M,1(M)		;Get AOBJN word for attribute list
	HLRE	T1,M		;-count
	JUMPGE	T1,FRABCN	;Error out if count not negative
	ADDI	T1,MXFRAT	;Within reason ?
	JUMPL	T1,FRABCN	;Bad count
FRANXT:	UMOVE	P1,(M)		;Get next attribute from caller's list
FRANX1:	CAILE	P1,MXFRAT	;Attribute legal ?
	 JRST	FRABTN		;No, Bad Table Number error
	HRRZ	J,%UPT+UPTJOB	;Set up caller's frame number
				; for license checking routines
	SETZ	P3,		;Error codes stored here
	LDB	T1,FARLCY	;Dispatch index to check license, etc.
	TRNE	S,FA.WR		;Wants to write ?
	 LDB	T1,FAWLCY	;Get different index if so
	XCT	FRADSP(T1)	;Allowed to access this attribute ?
	 JRST	FRANLC		;No - Not Enough License error

;;
;; Here to decide about access rights and the context page lock
;; There are five cases:
;;	1. No access rights or context page lock required.
;;	2. Access rights required and the context pages have not
;;	   yet been locked.
;;	3. Access rights required, but the context pages were
;;	   already locked in a previous pass through the loop.
;;	4. No access rights required, but the requested attribute
;;	   needs the context pages locked anyway.
;;	5. Same as (4) except that context pages were previously
;;	   locked.  This is effectively the same as (1) and is
;;	   treated as such.
;;

	LDB	P3,FARARY	;Read access rights required
	TRNE	S,FA.WR		;Wants to write ?
	 LDB	P3,FAWARY	;Get different index if so
	CAIE	P3,NOAR		;No access rights required ?
	 JRST	FRAGAR		;Get them if needed
	SETO	P3,		;Indicate to context-page-locking
				; routine not to check access rights
	SKIPGE	FRATAB(P1)	;Does this attribute need lock?
	 JUMPGE S,FRACTX	;If so and not locked, go get it
;;
;; No access rights or context lock needed
;;  OR no access rights needed and already locked.
;;
	HLRZ	J,F		;Get target absolute frame number
	JRST	FRATGO		;And get on with it
;;
;; Here if access rights required to target frame
;;
FRAGAR:	JUMPGE	S,FRACTX	;Branch if context pages not locked
;;
;; Here if access rights required and context pages are already
;; locked from previous loop pass.
;;
	PUSHJ	P,FARCHK	;Fast Access Rights Check
	  JRST	FRATER		;No access rights - error out
	HRRZ	P4,F		;Restore clobbered frame descriptor
	JRST	FRATGO		;Doo dah
;;
;; Here if context pages need to be locked.  P3 has access rights
;; code or -1 if none needed.
;;
FRACTX:	PUSHJ	P,FDWUPX	;Lock context pages
	  JRST	FRATER		;Failed - error out
	TLO	S,-1		;Indicate that context pages are locked
FRATGO:	LDB	T1,FRAPTR(P1)	;Get frame attribute
	UMOVE	T2,(U)		;Get caller's argument
	TRNE	S,FA.RD		;Does caller want to read it?
	 UMOVEM T1,(U)		;Pass it down if so
	TRNE	S,FA.WR		;Want to write it?
	 DPB	T2,FRAPTR(P1)	;If so, do it
	AOS	U		;Point to caller's next argument
	AOBJN	M,FRANXT	;Do next attribute, if any
	JRST	CPOPJ1		;Give good return

;;
;; Error exits from Read/Write Frame Attributes
;;

;; Here if attribute list is too long

FRABCN:	SKIPA	P3,[FEBCN%]	;Bad Count

;; Here if attribute code is illegal

FRABTN:	MOVEI	P3,FEBTN%	;Call it Bad Table Number

;; Here if license check failed (with possible error code in P3)

FRANLC:	JUMPN	P3,.+2		;Don't overwrite existing error code
	MOVEI	P3,FENLC%	;Not Enough License

;; Here for anything else (error code in P3)

FRATER:	SUBI	U,(P2)		;Find index into user's arg list
	HRL	P3,U		;Set into error code
	UMOVEM	P3,(W)		;Set into caller's AC
	POPJ	P,		;And give error return
;; Table for dispatching to license/privilege-checking routines

FRADSP:	SKIPA			;No check required
	PUSHJ	P,CHKJL		;Check for JL license

;; Indices into FRADSP
	NOLIC==0
	FRATJL==1

;; Table of licenses/access rights required to read/write frame
;;  attributes - indexed by P1.

	GETLOK==1	;Bit 0 (must be sign) - get context page lock

	FARLCS==1	;Start bit for Read index to FRADSP
	FARLCL==^D3	;Length of Read index field
	FARLCR==FARLCS+FARLCL-1 ;Rightmost bit of Read index field
FARLCY:	POINT	FARLCL,FRATAB(P1),FARLCR ;Byte pointer to Read index

	FAWLCS==FARLCR+1	;Start bit for Write index to FRADSP
	FAWLCL==FARLCL	;Length of Write index field
	FAWLCR==FAWLCS+FAWLCL-1 ;Rightmost bit of Write index field
FAWLCY:	POINT	FAWLCL,FRATAB(P1),FAWLCR ;Byte pointer to Write index

	FARARS==FAWLCR+1	;Start bit of Read Access Rights field
	FARARL==^D9	;Length of Read Access Rights field
	FARARR==FARARS+FARARL-1 ;Rightmost bit of R.A.R. field
FARARY:	POINT	FARARL,FRATAB(P1),FARARR ;Byte pointer to R.A.R. field

	FAWARS==FARARR+1	;Start bit of Write Access Rights field
	FAWARL==FARARL	;Length of Write Access Rights field
	FAWARR==FAWARS+FAWARL-1 ;Rightmost bit of W.A.R. field
FAWARY:	POINT	FAWARL,FRATAB(P1),FAWARR ;Byte pointer to W.A.R. field

	NOAR==777	;Special value for no access rights
			; (since 0 is defined)

	DEFINE	TABENT	(LOKFLG,RDLIC,WRLIC,RDAR,WRAR) <
	<LOKFLG>B0+<RDLIC>B<FARLCR>+<WRLIC>B<FAWLCR>+<RDAR>B<FARARR>+<WRAR>B<FAWARR>
	> ;End TABENT macro

FRATAB:	0				;No zero entry (yet)
	TABENT	GETLOK,NOLIC,FRATJL,.ARRFI,NOAR
				;Needs .ARRFI to read, JL to write
	MXFRAT==.-FRATAB-1	;Max legal attribute code

;; Table of byte pointers to frame attributes - must be ordered
;;  same as FRATAB.

FRAPTR:	0			;No zero entry (yet)
	POINT	36,%UPX+UPTLOG##,35 ;Byte pointer to fullword field

;;
;; Routines for verifying license/privilege
;;

;; Routine to check for JL license - Frame number in J

CHKJL:	MOVSI	T1,LICJAL	;JL license?
	TDNE	T1,JBTLIC(J)	;Got it?
	AOSA	(P)		;Yes, give good return
	MOVEI	P3,FENLC%	;No, say not enough license
	POPJ	P,
SUBTTL	.FOCFH=12 Create handle
COMMENT #HERE ON CREATE HANDLE. FRAME DESCRIPTOR
FOR TARGET FRAME IN P4. FORMAT OF CALL IS

	MOVE	AC,[FN,,FD]	;FD FOR TARGET FRAME
	FRMOP	AC,<ADDR>
	  <ERROR>
	<SUCCESS>

<ADDR>:	BITS,,FD FOR NEW HANDLE (INDEX FIELD 77777 TO FIND FIRST FREE SLOT)
	COUNT,,ADDR OF ACCESS BITS (0 FOR DEFAULT-MAX)
	<N WORDS OF ACCESS BITS>

	CURRENT BITS:
	  15-17 - HANDLE TYPE (FRAME, PROCESS, CLUB)
	OTHER BITS WILL BE USED IN THE FUTURE TO CREATE HANDLES
	WHICH CANNOT BE PASSED OR COPIED.
ON SUCCESS, RH OF AC IS SET TO FD OF NEW HANDLE

RULES FOR HANDLE CONVERSION, RESULTANT RIGHTS:

SOURCE		CREATE		MAX RIGHTS SETTING
--------------------------------------------------
LIC		LIC		HANDLE
		FRAME		HANDLE
		PROCESS		HANDLE,PNO FROM CURRENT
FRAME		LIC		FROM PROCESS LICENSE
		FRAME		HANDLE
		PROCESS		HANDLE .AND. MFR, PNO FROM CURRENT
PROCESS		LIC		FROM PROCESS LICENSE
		FRAME		(ILLEGAL)
		PROCESS		HANDLE, PNO FROM HANDLE
ABS FRAME	LIC		FROM PROCESS LICENSE
		FRAME		FROM PROCESS LICENSE
		PROCESS		FROM PROCESS LICENSE,PNO FROM CURRENT

SOURCE FD OF "CHILD" IS TREATED LIKE FRAME HANDLE.
SOURCE FD OF "PARENT" IS TREATED LIKE PROCESS HANDLE.
SOURCE FD OF "SELF" IS TREATED LIKE PROCESS HANDLE.
"SELF" PROCESS HANDLE BEHAVES AS IF ALL RIGHTS BITS WERE SET.

NOTE THAT A HANDLE OTHER THAN A LICENSED ONE IS NEEDED TO
CREATE A NEW LICENSED HANDLE WITH MAX RIGHTS BASED ON PROCESS LICENSE
RATHER THAN THE LICENSE IN THE HANDLE. THIS IS TO MAKE COPYING
AND PASSING HANDLES EASIER.
#
EXTERNAL GETWDS,FHIN,FCREQ,FCWAIT,JBTABT

FRMCFH:	UMOVE	P2,(M)		;GET BITS+TYPE,,FD FOR NEW HANDLE
	MOVEI	P1,-.FDFRH(P2)	;GET INDEX IN P1 (WE HOPE)
	TRNE	P1,700000	;IF IT WASN'T HANDLE, BOMB
	JRST	FEWFHE		;HANDLE EXPECTED.
	SETO	P3,		;NO SPECIAL ACCESS NEEDED - CHECK LATER.
	PUSHJ	P,FDWUPX
	  JRST	FRVERR		;NO, ERROR CODE IS IN P3
	TRC	P1,77777	;SEE IF WANTS NEW ONE ALLOCATED
	TRCN	P1,77777	;SIP IF INDEX WAS NOT ALL ONES
	JRST	FRMCF1		;IS ALL ONES, GO CREATE ONE.
	CAILE	P1,FHIMAX	;HE PROVIDES THE NUMBER. MAKE SURE ITS LEGAL
	JRST	FEWBDH		;NOT IN RANGE, BOMB
	SKIPE	%UPT+UPTFHT(P1)	;LEGAL, BUT IS IT FREE?
	JRST	FEWFHU		;NO, HANDLE USED.
	JRST	FRMCF3		;ALL SET.
FRMCF1:	MOVSI	P1,-FHIN	;GET AOBJN POINTER FOR SEARCH
FRMCF2:	SKIPE	%UPT+UPTFHT(P1)	;UNUSED?
	AOBJN	P1,FRMCF2	;USED.
	JUMPGE	P1,FEWNFH	;NO MORE HANDLES LEFT.
	HRRZS	P1		;GET RID OF COUNT
FRMCF3:	MOVEI	T2,.FHSIZ	;THIS IS HOW BIG A HANDLE IS
	PUSHJ	P,GETWDS	;GET A BLOCK OF FREE CORE
	  JRST	[AOS FCREQ
		 PUSHJ P,FCWAIT
		 SOS FCREQ	;ONE LESS WAITER
		 JRST FRMCF3]	;AND TRY AGAIN
	HLL	J,P2		;GET BITS+TYPE,,FRAME NUMBER IN J
	MOVE	P3,T1		;GET ADDRESS OF BLOCK IN SAFER P3
	MOVEM	P3,%UPT+UPTFHT(P1) ;KEEP TRACK OF IT.
	MOVEI	T1,CFHABT	;PLACE TO GIVE BACK FREE CORE IN CASE OF ILL MEM REF OR SOMETHING
	HRL	T1,P1		;GET FRAME HANDLE NUMBER FOR CFHABT
	MOVE	T2,%UPT+UPTJOB
	MOVEM	T1,JBTABT(T2)	;STORE FOR CURRENTLY RUNNING FRAME.
	UMOVE	PG,1(M)		;GET COUNT,,USER ADDRESS
				;COUNT WILL BE CHECKED BY FILLFH
	PUSHJ	P,FILLFH	;FILL IN ACCESS RIGHTS, UID, FRAME NUMBER
	  JRST	FRMCFE		;ERROR OF SOME SORT, CODE IN P3
	MOVE	T1,%UPT+UPTJOB
	SETZM	JBTABT(T1)	;NO LONGER NEED THIS.
	MOVEI	P1,.FDFRH(P1)	;MAKE INDEX NUMBER INTO FRAME DESCRIPTOR
	XCTTU	<MOVEM P1,(W)>	;FILL IN RH OF AC WITH FD FOR THE NEW HANDLE.
	JRST	CPOPJ1		;AND GIVE SUCCESS RETURN.

;HERE IF FILLFH GAVE AN ERROR, CODE IN P3.

FRMCFE:	SETZ	T2,		;GET RID OF HANDLE
	EXCH	T2,%UPT+UPTFHT(P1)
	MOVEI	T1,.FHSIZ	;NUMBER OF WORDS TO GIVE BACK
	TLZ	T2,-1		;GET RID OF JUNK IN LH OF T2
	PUSHJ	P,GIVWDS
	PJRST	FRVERR		;STORE CODE IN P3 BACK AND GIVE ERROR RETURN.

CFHABT:	HLRZS	T1		;GET INDEX NUMBER IN T1
	SETZ	T2,
	EXCH	T2,%UPT+UPTFHT(T1) ;GET ADDRESS OF HANDLE
	MOVEI	T1,.FHSIZ	;SIZE OF IT
	TLZ	T2,-1		;JUST ADDRESS IN T2
	PJRST	GIVWDS		;GIVE IT BACK.
COMMENT ;@@SUBROUTINE FILLFH
@@PURPOSE USING FRAME DESCRIPTOR IN P4, FILLS IN PROPER ACCESS RIGHTS
, FRAME NUMBER AND UNIVERSAL ID NUMBER IN A HANDLE CORE BLOCK.
@@ENTRY	P1/HANDLE INDEX NUMBER
	J/ BITS+TYPE,,FRAME NUMBER OF SAID FRAME
	%UPX/ CONTEXT PAGES OF SAID FRAME
	P3/ HANDLE BLOCK ADDRESS
	P4/ FD FOR TARGET FRAME OR PROCESS
	PG/ COUNT,,USER ADDR OF USER'S ACCESS BIT SPECIFICATION
@@ACCUM T1-T4,F,M,U,P2,P4,S
@@EXIT NON-SKIP IF ERROR ENCOUNTERED, ERROR CODE IN P3
	SKIP IF OK, HANDLE FILLED IN CORRECTLY.
@@;

FILLFH:	MOVEM	J,.FHTYP(P3)	;STORE BITS+TYPE,,FNO IN .FHTYP/.FDFNO
	MOVE	T1,JBTUID(J)	;GET ID NUMBER
	MOVEM	T1,.FHUID(P3)	;SET THAT ALSO
	MOVEI	T4,FILLTB	;GET ADDR OF TABLE IN RH OF T4
	JRST	FDDSP		;AND DISPATCH.

FILLTB:	JRST	FILABS		;(0)ABSOLUTE FRAME NUMBER
	STOPCD			;(1)FAMILY, USES WORDS BELOW
	STOPCD			;(2)OTHER FRAME
	JRST	FILFRH		;(3)HANDLE
	STOPCD			;(4)UNDEFINED (WAS SUPPOSED TO BE CHECKED)
	STOPCD			;(5)UNDEFINED
	STOPCD			;(6)UNDEFINED
	JRST	FILSLF		;(7) OWN FRAME
	JRST	FILCHL		;(1,0)CHILD
	JRST	FILPAR		;(1,1)PARENT
;HERE FOR HANDLE.

EXTERNAL TPOPJ

FILFRH:	LDB	T3,[POINT 15,P4,35] ;GET INDEX OF OLD HANDLE
	MOVE	T3,%UPT+UPTFHT(T3)	;GET BITS IN LH T3
	LDB	T1,[HTPPTR(.FHTYP(T3))]	;GET SOURCE HANDLE TYPE
	PUSHJ	P,CHKHDL	;T1/ SOURCE HANDLE TYPE
	  POPJ	P,		;P3 HAS ERROR CODE
	CAIE	T1,.FHLIC	;IF SOURCE NOT LIC AND
	CAIE	T2,.FHLIC	;DEST IS,
	JRST	.+2		;(EITHER SOURCE LIC OR DEST NOT LIC)
	JRST	FILAB0		; THEN SET ACCESS IN NEW HANDLE ACCORDING TO PROCESS LICENSE.
	PUSH	P,T1		;REMEMBER SOURCE HANDLE TYPE ON STACK
	MOVE	T4,.FHPNO(T3)	;ASSUME PNO COMES FROM OLD HANDLE
	CAIE	T1,.FHPRC	;IF SOURCE IS LIC OR FRAME HANDLE,
	MOVE	T4,JBTPNO(J)	;GET CURRENT PNO FOR TARGET.
	MOVEM	T4,.FHPNO(P3)	;THIS GOES IN TOO.
	MOVSI	P4,.FHART(T3)	;ADDRESS OF FAST RIGHTS MAX
	HRRI	P4,.FHART+1(T3)	;ADDRESS OF SLOW MAX HE CAN HAVE
	PUSHJ	P,SETHDL	;SET RIGHTS IN HANDLE
	  JRST	TPOPJ		;SOMETHING WENT WRONG.
	POP	P,T2		;GET SOURCE HANDLE TYPE BACK INTO T2
	LDB	T1,[HTPPTR(.FHTYP(P3))]	;GET KIND OF HANDLE WE'RE CREATING
	CAIN	T2,.FHFRM	;IF SOURCE HANDLE IS FRAME AND
	CAIE	T1,.FHPRC	;TRYING TO CREATE PROCESS HANDLE
	JRST	CPOPJ1		;NO, IF ITS FRAME HANDLE, ALWAYS SUBJECT TO MFR
				;THEN SET RIGHTS DOWN ACCORDING TO MFR.
FILFH0:	MOVE	T1,JBTMFR(J)	;GET MAX FRAME RIGHTS
	ANDM	T1,.FHART(P3)	;SET THEM DOWN
	MOVEI	T4,.ARSIZ-1	;HIGHEST INDEX TO USE FOR UPTMFR
	MOVEI	T3,.FHART+FARSIZ+.ARSIZ-1(P3) ;ADDRESS TO AND TO
FILFH1:	MOVE	T1,%UPX+UPTMFR(T4) ;GET WORD
	ANDM	T1,(T3)
	SUBI	T3,1
	SOJGE	T4,FILFH1	;KEEP GOING.
	JRST	CPOPJ1

;HERE FOR PARENT

FILPAR:	MOVEI	T1,.FHPRC	;CHILD TO PARENT IS PROCESS HANDLE
	PUSHJ	P,CHKHDL	;SEE IF OK
	  POPJ	P,		;NOT FOR SOME REASON.
	CAIN	T2,.FHLIC	;TRYING TO CREATE LICENSED HANDLE?
	JRST	FILAB0		;YES, DO IT ACCORDING TO PROCESS LICENSE.
	MOVE	T3,%UPT+UPTJOB	;GET OUR FRAME NUMBER
	MOVE	T1,JBTSPN(T3)	;PROG THAT GAVE US RIGHTS
	MOVEM	T1,.FHPNO(P3)	;SAME ONE THAT GAVE US CHILD TO PARENT RIGHTS.
	MOVSI	P4,JBTS2P(T3)	;ADDRESS OF MAX FAST RIGHTS
	HRRI	P4,%UPT+UPTS2P	;AND SLOW ONES
	PJRST	SETHDL		;GO SET THE RIGHTS.
;HERE FOR SELF FRAME DESCRIPTOR

FILSLF:	MOVEI	T1,.FHPRC	;SELF TO SELF IS PROCESS ONLY, NOT FRAME
	PUSHJ	P,CHKHDL	;SEE IF CAN DO IT
	  POPJ	P,		;NO.
	CAIN	T2,.FHLIC	;TRYING TO CREATE LIC HANDLE?
	JRST	FILAB0		;YES, DO IT ACCORDING TO PROCESS LICENSE.
	MOVE	T3,JBTPNO(J)	;NO, NEED TO FILL IN PROCESS HANDLE
	MOVEM	T3,.FHPNO(P3)	;WITH PROCESS NUMBER OF OUR "SELF" HANDLE (CURRENT PNO)
FILSL0:	SETZ	P4,		;NO MAX RIGHTS CHECK NEEDED.
	PJRST	SETHDL		;JUST SET THE BITS FROM USER SPEC.

;HERE FOR CHILD

FILCHL:	MOVEI	T1,.FHFRM	;PARENT TO CHILD IS FRAME HANDLE
	PUSHJ	P,CHKHDL	;SEE IF CAN DO IT
	  POPJ	P,		;NO
	CAIN	T2,.FHLIC	;TRYING TO CREATE LIC HANDLE?
	JRST	FILAB0		;YES, DO IT ACCORDING TO PROCESS LICENSE.
	MOVSI	P4,JBTP2S(J)	;GET THE MAX RIGHTS WE CAN HAVE OER IT
	HRRI	P4,%UPX+UPTP2S	;ADDRESS OF SLOW RIGHTS
	MOVE	T4,JBTPNO(J)	;GET PNO IN CASE ITS A PROCESS HANDLE
	MOVEM	T4,.FHPNO(P3)	;STORE IT
	CAIN	T2,.FHFRM	;CREATING A FRAME HANDLE?
	PJRST	SETHDL		;YES, NO NEED TO CUT RIGHTS DOWN.
	PUSHJ	P,SETHDL	;COPY RIGHTS
	  POPJ	P,		;SOME SORT OF ERROR, CODE STORED THRU (W)
	PJRST	FILFH0		;OK, SET THEM DOWN ACCORDING TO MFR.

;ABSOLUTE

FILABS:	MOVEI	T1,.FHLIC	;IF OUR LICENSE IS HIGH ENOUGH
	PUSHJ	P,CHKHDL	;LET HIM HAVE ANYTHING
	  POPJ	P,		;BAD DESIRED TYPE
FILAB0:	MOVE	T3,JBTPNO(J)	;IN CASE ITS PROCESS HANDLE, MAKE IT VALID
	MOVEM	T3,.FHPNO(P3)
	PUSHJ	P,ABSACC	;SET P4 TO ADDR,,ADDR+1 OF ABS RIGHTS HE HAS OVER TARGET
	  JRST	FENLC		;CAN'T CREATE, NOT ENOUGH LICENSE.
	PJRST	SETHDL		;AND GO SET FROM USER'S SPEC.
COMMENT ;@@SUBROUTINE CHKHDL
@@PURPOSE SEE IF IT IS LEGAL TO GENERATE A FRAME HANDLE
@@ENTRY	J/LH CONTAINS TYPE OF HANDLE TRYING TO CREATE IN FH.TYP FIELD
	T1/TYPE OF "HANDLE" TRYING TO CREATE NEW HANDLE WITH
	   (PARENT TO CHILD, "FRAME HANDLE"
	    CHILD TO PARENT, "PROCESS HANDLE" SUBJECT TO S2P RIGHTS)
@@ACCUM T2
@@EXIT NON-SKIP WITH ERROR CODE IN P3 IF CANNOT DO THE CREATE
	SKIP IF CAN, WITH T2/HANDLE TYPE OF NEW HANDLE
@@FUNCTION FRAME OR LICENSED HANDLE CAN CREATE FRAME, LICENSED OR PROCESS HANDLE
PROCESS HANDLE CAN ONLY CREATE PROCESS OR LICENSED HANDLES.
@@;
CHKHDL:	LDB	T2,[HTPPTR(J)]	;GET TYPE OF HANDLE DESIRED
	CAILE	T2,.FHMAX	;IN RANGE?
	JRST	FEBHT		;NO. BAD HANDLE TYPE.
	CAIE	T1,.FHPRC	;SOURCE IS PROCESS HANDLE?
	JRST	CPOPJ1		;NO, FRAME HANDLES AND LIC HANDLES CAN CREATE EVERYTHING.
	CAIN	T2,.FHFRM	;IF PROCESS HANDLE TRIES TO CREATE FRAME HANDLE,
	JRST	FECCH		;GIVE ERROR RETURN
	JRST	CPOPJ1		;OK, PROCESS CAN CREATE PROCESS OR LIC IF OWNING PROCESS HAS THE LIC.
SUBTTL	.FODFH=13 Destroy handle

COMMENT #FRMOP TO DESTROY A HANDLE. FRAME DESCRIPTOR
FOR THE HANDLE IN P4.
#

EXTERNAL GIVWDS

FRMDFH:	MOVEI	P4,-.FDFRH(P4) ;GET INDEX ALONE POSSIBLY
	TRNE	P4,700000	;HE MUST HAVE SPECIFIED A HANDLE FD
	JRST	FEWFHE		;HANDLE EXPECTED
	CAILE	P4,FHIMAX	;MAKE SURE ITS IN RANGE
	JRST	FEWBDH		;ITS NOT, BAD HANDLE ERROR RETURN
FRMDFR:	SETZ	T2,		;CLEAR THE SLOT
	EXCH	T2,%UPT+UPTFHT(P4) ;GET THE HANDLE
	JUMPE	T2,FEWNOH	;THERE WAS NO HANDLE IN HANDLE SLOT
	AOS	(P)		;OK, WE WILL SUCCEED
	MOVEI	T1,.FHSIZ	;GIVE BACK THIS MANY
	TLZ	T2,-1		;JUST ADDRESS IN RH.
	PJRST	GIVWDS		;MAKE IT DISAPPEAR.

;ROUTINE CALED BY RESET TO RELEASE ALL HANDLES
; USES T1-T4, P4.

RESFRH::MOVSI	P4,-FHIN	;AOBJN POINTER
RESFR1:	SETZ	T2,
	EXCH	T2,%UPT+UPTFHT(P4) ;GET HANDLE
	JUMPE	T2,RESFR2	;DON'T CALL IF NONE
	MOVEI	T1,.FHSIZ	;HOW MANY TO GIVE BACK
	TLZ	T2,-1		;JUST ADDRESS IN RH(T2)
	PUSHJ	P,GIVWDS
RESFR2:	AOBJN	P4,RESFR1	;AND LOOP.
	POPJ	P,		;RETURN.
SUBTTL	.FOSMF=20 Set Max Frame Rights

;FRMOP TO SET MAX FRAME RIGHTS.
; AC/FN,,FD E/COUNT,,ADDR OF RIGHTS.
; IF CALLER HAS THE RIGHTS, HE CAN SET MFR TO ANY DESIRED VALUE.

FRMSMF:	UMOVE	P2,(M)		;GET COUNT,,ADDR
	MOVEI	P3,.ARSMF	;SET MFR RIGHT NEEDED
	PUSHJ	P,FDRUPX	;GET CONTEXT PAGES
	  JRST	FRVERR
	MOVE	PG,P2		;OK GET INTO PG
	SETZ	P4,		;NO MAXIMUM NEEDED
	MOVSI	P3,JBTMFR(J)	;ADDRESS OF FAST RIGHTS TO SET
	HRRI	P3,%UPX+UPTMFR	;ADDRESS OF SLOW RIGHTS
	SETZ	P4,		;NO MAX TO WORRY ABOUT
	PUSHJ	P,SETARN	;DO IT
	  PJRST	FRVERR		;STORE ERROR CODE AND GIVE ERROR RETURN
	PJRST	CPOPJ1		;OK, RETURN.
SUBTTL	.FOCHR=21 Change rights in a handle

;FRMOP TO CHANGE RIGHTS IN A HANDLE WHICH CALLER OWNS.
; AC/FN,,FD OF HANDLE E/COUNT,,ADDR OF RIGHTS
;
;CANNOT CHANGE RIGHTS OF "SELF" HANDLE, "ABS" HANDLE.
;OTHER HANDLES CAN ONLY SET RIGHTS LOWER, EXCEPT FOR
; PROCESS HANDLES, WHICH CAN BE SET TO ANY VALUE - AND PNO
; IN THE HANDLE IS INVALIDATED.

FRMCHR:	UMOVE	PG,(M)		;GET COUNT,,ADDR INTO PG
	MOVEI	T4,RCHTAB	;GET TABLE ADDRESS
	JRST	FDDSP		;DISPATCH

RCHTAB:	JRST	FEWBHT		;(0) ABS FRAME, CANNOT CHANGE THIS.
	STOPCD			;(1) FAMILY
	STOPCD			;(2) OTHER FRAME, SHOULD BE CONVERTED
	JRST	CHRFRH		;(3) HANDLE
	JRST	FEWUND		;(4) UNDEFINED
	JRST	FEWUND		;(5) UNDEFINED
	JRST	FEWUND		;(6) UNDEFINED
	JRST	FEWBHT		;(7) OWN FRAME, CAN'T CHANGE IT
	JRST	CHRCHL		;(1,0) CHILD
	JRST	CHRPAR		;(1,1) PARENT
;HERE TO CHANGE RIGHTS IN A HANDLE

CHRFRH:	MOVE	P3,P4		;GET DESCRIPTOR
	ANDI	P3,FDDMSK	;JUST INDEX
	MOVE	P3,%UPT+UPTFHT(P3) ;GET ADDRESS IN P3
	MOVSI	P4,.FHART(P3)	;CANNOT SET RIGHTS HIGHER THAN CURRENT VALUES
	HRRI	P4,.FHART+1(P3)	;P4/SLOW,,FAST MAX RIGHTS
	LDB	T1,[HTPPTR(.FHTYP(P3))] ;GET HANDLE TYPE
	CAIE	T1,.FHPRC	;IF NOT PROCESS HANDLE
	TLOA	W,LIMMAX	;DON'T SET ANY RIGHTS HIGHER THAN MAX
	TLZ	W,LIMMAX	;ELSE PROCESS, CAN SET TO ANY VALUE.
	PUSHJ	P,SETHDL	;SET HANDLE RIGHTS
	  JUMPGE W,FRVERR	;IF COUNT ERROR, STORE CODE AND GIVE ERROR
	JUMPGE	W,CPOPJ1	;IF MAX NOT VIOLATED, GIVE GOOD RETURN NOW.
	TLNN	W,LIMMAX	;SKIP IF NOT PROCESS HANDLE
	JRST	[SETOM .FHPNO(P2) ;PROCESS, INVALIDATE PNO - HANDLE ADDRESS IN P2 NOW.
		 JRST CPOPJ1]	;AND SUCCEED.
	JRST	FEWNRT		;SAY RIGHTS VIOLATION AND RETURN MAX RIGHTS HE CAN HAVE.

;HERE TO SET CHILD TO PARENT PROCESS HANDLE RIGHTS

CHRPAR:	PUSHJ	P,FD2FNO	;MAKE SURE THERE IS A PARENT
	  JRST	FRVERR		;GUESS NOT
	MOVE	J,%UPT+UPTJOB	;GET CALLER'S FRAME NUMBER IN J
	MOVSI	P3,JBTS2P(J)	;ADDRESS OF FAST RIGHTS TO CHANGE
	HRRI	P3,%UPT+UPTS2P	;AND SLOW ONES
	MOVE	P4,P3		;THIS IS MAX TOO
	TLZ	W,LIMMAX	;WHICH ARE JUST FOR SEEING WHETHER TO SMASH PNO
	PUSHJ	P,SETARN	;SET THE RIGHTS TO WHAT HE WANTS
	  JUMPGE W,FRVERR	;IF NOT MAX VIOLATION, STORE AND RETURN.
	JUMPGE	W,CPOPJ1	;IF NOT INCREASING, GIVE GOOD RETURN.
	SETOM	JBTSPN(J)	;INCREASED. SMASH SPN.
	JRST	CPOPJ1		;AND RETURN.

;HERE TO SET PARENT TO CHILD FRAME HANDLE RIGHTS

CHRCHL:	MOVE	P2,PG		;SAVE PG
	SETO	P3,		;NO SPECIAL RIGHTS NEEDED TO LOOK
	PUSHJ	P,FDRUPX	;GET, OUR RIGHTS ARE IN CHILD UPT
	  JRST	FRVERR		;SORRY, SOMETHING IS WRONG.
	MOVE	PG,P2		;GET ARG COUNT,,ADDR BACK IN PG
	MOVSI	P3,JBTP2S(J)	;PARENT'S FAST RIGHTS OVER CHILD ADDRESS
	HRRI	P3,%UPX+UPTP2S	;ADDRESS OF PAR'S SLOW RIGHTS OVER CHILD
	MOVE	P4,P3		;CANNOT SET HIGHER THAN CURRENT VALUES
	TLO	W,LIMMAX	;DO NOT UNDER ANY CIRCUMSTANCES SET RIGHTS HIGHER THAN ALLOWED
	PUSHJ	P,SETARN	;COPY THE RIGHTS
	  PJRST	FRVERR		;MAX VIOLATION OR OTHER ERROR, STORE CODE AND ERROR RETURN
	JRST	CPOPJ1		;ALL OK, GOOD RETURN.
SUBTTL	.FOVCH=27 Validate Child to Parent Handle for a child

COMMENT #
CALL:
	MOVE	AC,[.FOVCH,,FD]
	FRMOP	AC,<ADDR>
	  <ERROR RETURN>
	<SUCCESS RETURN>


<ADDR>:	COUNT,,ADDR		;OF RIGHTS WHICH MUST MATCH IN CHILD'S PROCESS HANDLE

GIVE ERROR RETURN IF COUNT IS BAD OR IF THE ACCESS RIGHTS IN CHILD'S
HANDLE DO NOT MATCH THOSE GIVEN AT <ADDR> EXACTLY. (THIS IS SO
THAT A PARENT CAN READ IN THE RIGHTS OF ITS CHILD'S HANDLE TO
ITSELF AND THEN VALIDATE THAT HANDLE IF AND ONLY IF
THE CHILD HASN'T CHANGED THE RIGHTS SINCE THEY WERE READ.
#

FRMVCH:	UMOVE	P2,(M)		;GET COUNT,,ADDR IN P2
	SETO	P3,		;NO ACCESS RIGHT NEEDED TO VALIDATE HANDLE TO OURSELVES
	PUSHJ	P,FDWUPX	;GET THEM SO CAN READ ACCESS RIGHTS
	  JRST	FRVERR		;NO GO.
	PUSHJ	P,ISCHLD	;THIS HAS TO BE FOR A CHILD FRAME
	  JRST	FEWNCH		;SAY NOT A CHILD (SHARED CODE WITH ONE THAT SAYS FRAME NUMBER NOT THAT OF A CHILD)
	MOVSI	P3,JBTS2P(J)	;GET FAST RIGHTS OF THIS CHILD OVER ITS PARENT, THE CALLER
	HRRI	P3,%UPX+UPTS2P
	MOVE	PG,P2		;GET INTO PG FOR CMPARN
	PUSHJ	P,CMPARN	;SEE IF RIGHTS MATCH USER ARG EXACTLY.
	  JRST	FRVERR		;STORE ERROR CODE IN P3 THRU (W)
				;AND GIVE ERROR RETURN.
	MOVE	T1,%UPT+UPTJOB	;GET OUR JOB NUMBER
	MOVE	T1,JBTPNO(T1)	;GET OUR CURRENT PNO
	MOVEM	T1,JBTSPN(J)	;MAKE THE CHILD TO PARENT PROCESS HANDLE VALID.
	JRST	CPOPJ1		;AND GIVE THE GOOD RETURN.
COMMENT ;@@SUBROUTINE CMPARN
@@PURPOSE SKIP IF RIGHTS USER IS SPECIFYING ARE GREATER THAN OR EQUAL TO
THOSE IN THE MONITOR ACCESS RIGHTS TABLE
@@ENTRY PG/COUNT,,USER ADDR OF USER RIGHTS BITS
	P3/FAST RIGHTS ADDRESS,,SLOW RIGHTS ADDRESS
	W/ USER AC NUMBER TO STORE ERROR CODE INTO
@@ACCUM T1-T4,F,M,U,P2,S
@@EXIT NON-SKIP IF RIGHTS IN MONITOR TABLE ARE NOT GEQ THOSE
SPECIFIED IN USER TABLE
	SKIP IF USER RIGHTS ARE GEQ THE MONITOR ONES
@@;

XP .UAWMX,<<.UAMAX+^D35>/^D36>	;NUMBER OF WORDS IN USER'S BIT MAP

CMPARN:	JSP	T4,SAVE1	;SAVE P1
	HLRZ	S,PG		;GET USER'S COUNT
	JUMPE	S,CPOPJ1	;IF ZERO COUNT, HE MEANS ALL. WHATEVER THE MONITOR RIGHTS ARE, THEY ARE OK.
	CAILE	S,.UAWMX	;IN RANGE?
	JRST	FEBCN		;NO, BAD COUNT
	ADDI	S,-1(PG)	;GET LAST WORD TO READ FROM
	MOVEI	U,U2MACT	;CONVERT USER BITS TO MONITOR BITS
	JSP	F,ACRPTR	;START THE BYTE POINTERS COMING
	  JRST	CPOPJ1		;MUST HAVE BEEN OK.
	ADDI	T3,(PG)		;RELOACTE POINTER TO USER'S BLOCK
	CAIGE	S,(T3)		;STILL WITHIN SPECIFIED RANGE?
	TDZA	T1,T1		;NO, ASSUME HE MEANT ZERO RIGHTS
	XCTFU	<LDB T1,T3>	;ELSE GET THAT COLLECTION OF BITS
	TRNN	T4,-1		;IF ZERO INDEX,
	JRST	[HLR T4,P3	;THEN SETUP FAST RIGHTS ADDRESS
		 JRST .+2]
	ADDI	T4,-1(P3)	;IS SLOW ADDRESS
	LDB	T2,T4		;GET THE BYTE
	TDZ	T2,T1		;MAKE SURE NO BITS SET IN MONITOR TABLE THAT AREN'T IN USER'S SPEC
	JUMPE	T2,(M)		;IF ZERO, THEN ALL BITS WERE OK.
	JRST	FERNE		;RIGHTS NOT EQUAL

REPEAT 0,<;NOT NEEDED YET.
;ROUTINE TO CHECK IF P4/FAST,,SLOW RIGHTS ARE LESS THAN OR EQUAL TO
; P3/FAST,,SLOW MAXIMUM RIGHTS. NON-SKIP IF NOT LESS OR EQUAL TO.
; SMASHES T1-T4.

MAXCMP:	HLRZ	T1,P4		;GET FAST RIGHTS ADDRESS
	MOVE	T1,(T1)		;GET THE DATA
	HLRZ	T2,P3		;GET FAST MAX RIGHTS ADDRESS
	TDZ	T1,(T2)		;CLEAR ALLOWED BITS
	JUMPN	T1,CPOPJ	;IF ANYTHING LEFT, RIGHTS NOT LESS OR EQUAL TO
	MOVSI	T4,-.UAWMX	;GET AOBJN POINTER TO ALLMFR
	MOVE	T3,P4		;GET SLOW ADDRESS
	HRLI	T3,T4		;INDEX BY T4
	MOVE	T2,P3		;GET SLOW MAX ADDRESS
	HRLI	T2,T4		;INDEX THAT BY T4 ALSO.
CMPMX1:	MOVE	T1,@T3		;GET NEXT WORD
	TDZ	T1,@T2		;CLEAR THE ALLOWED BITS
	JUMPN	T1,CPOPJ	;IF ANYTHING LEFT, GIVE ERROR RETURN.
	AOBJN	T4,CMPMX1	;YES, CONTINUE
	JRST	CPOPJ1		;ALL RIGHTS ARE THE SAME, RETURN.
>;END REPEAT 0
SUBTTL	.FORSI=15 Return standard access rights info

;FRMOP TO RETURN STANDARD ACCESS BIT INFORMATION TO USER.
; AC/FN,,<TABLE NUMBER> E/COUNT,,ADDR
; RETURNS MAXIMUM USER RIGHT NUMBER IN AC.

FRMRSI:	UMOVE	PG,(M)		;GET COUNT,,ADDR
	JUMPLE	PG,FRMARD	;JUST RETURN SIZE OF BIT TABLE IF NEGAITVE.
	HRRZS	P4		;JUST TABLE ADDRESS
	CAILE	P4,RSIMAX	;IN RANGE?
	JRST	FEWBTN		;BAD TABLE NUMBER
	MOVE	P4,RSITAB(P4)	;GET PROPER ADDRESS OF FAST,,SLOW IN P4
	PUSHJ	P,FRMRMR	;RETURN MONITOR RIGHTS TO USER
	  POPJ	P,		;ERROR CODE STORED.
FRMARD:	MOVEI	T1,.UAMAX	;RETURN THIS IN AC FOR INFO PURPOSES
	UMOVEM	T1,(W)		;BACK IN HIS AC
	JRST	CPOPJ1		;DONE.

;TABLE OF ADDRESSES OF STANDARD BIT TABLES TO RETURN.

DEFINE RSIMAC<XALL
X(EXOMFR)			;;(0)EXECUTE ONLY
X(RDXMFR)			;;(1)EXECUTE ONLY + READ FUNCTIONS, IN CASE PROCESS HAS MORE CAPABILITY THAN FRAME
X(ALLMFR)			;;(2)ALL RIGHTS BITS CURRENTLY DEFINED
X(RCATAB)			;;(3)RIGHTS THAT RC LICENSE GIVES
X(SYSTAB)			;;(4)RIGHTS THAT SY LICENSE GIVES
X(TYPTAB)			;;(5)TYMSHARE PROPRIETARY RIGHTS
X(AUNTAB)			;;(6)RIGHTS THAT SAME AUN OR ACC SUPER GIVES
X(JALTAB)			;;(7)RIGHTS THAT JL LICENSE GIVES
X(WCATAB)			;;(10)RIGHTS THAT WC LICENSE GIVES
SALL>

DEFINE X(NAME)<'NAME,,'NAME+1>
RSITAB:	RSIMAC
RSIMAX==.-RSITAB-1
SUBTTL	.FORAR=16 Read a handle's access rights
SUBTTL	.FORER=17 Read handle's effective rights

;THESE TWO FRMOPS RETURN ACCESS RIGHTS ASSOCIATED WITH
; THE GIVEN FRAME DESCRIPTOR. READING ACCESS RIGHTS
; READS THE RIGHTS THAT ARE ASSOCIATED WITH THE HANDLE
; ITSELF. READING EFFECTIVE RIGHTS RETURNS WHICH RIGHTS
; THE HANDLE IS CURRENTLY GOOD FOR, WHICH MAY OR MAY
; NOT BE THE SAME AS THE RIGHTS ASSOCIATED WITH THE HANDLE.

; CALLING FORMAT FOR BOTH FRMOPS:

;	MOVE	AC,[FUNCTION,,FRAME DESCRIPTOR]
;	FRMOP	AC,ADDR
;	  ERROR
;	SUCCESS
;ADDR:	COUNT,,ADDR OF BLOCK TO RETURN RIGHTS IN.
;FORMAT OF BLOCK:
;
;0/ BITS+TYPE,,FRAME NUMBER	;SAME AS GIVEN TO CREATE HANDLE FRMOP
;1/ 36 BIT UID
;2/ PNO (ONLY VALID IF TYPE IS PROCESS HANDLE)
;3-N/ ACCESS BITS

FRMRAR:	TDZA	P1,P1		;P1 IS 0 IF JUST RETURNING
				; HANDLE RIGHTS
FRMRER:	MOVEI	P1,1		;P1 IS 1 IF RETURNING EFFECTIVE RIGHTS
	UMOVE	P2,(M)		;GET COUNT,,ADDRESS IN P2
	HLRZ	S,P2		;GET COUNT IN S FOR ROUTINES
	SKIPE	S		;ZERO IS ILLEGAL.
	CAILE	S,.UAWMX+3	;RIGHTS TABLE SIZE + FNO,UID,PNO
	JRST	FEWBCN		;BAD COUNT OTHERWISE
	MOVN	T1,S		;GET - COUNT IN T1
	HRL	P2,T1		;PASS -COUNT,,ADDR IN P2 TO ROUTINES
	SETO	P3,		;NO SPECIAL ACCESS REQUIREMENT
	PUSHJ	P,FDRUPX	;GET CONTEXT PAGES LOCKED IN
	  JRST	FRVERR		;ERROR CODE IN P3, GO STORE AND RETURN
	MOVE	PG,P2		;FDRUPX SMASHED PG BEFORE, BUT NOW ITS SAFE.
	MOVEI	T4,RXRTAB	;DISPATCH
	JRST	FDDSP

RXRTAB:	JRST	RXRABS		;(0) ABSOLUTE FRAME NUMBER
	STOPCD			;(1) FAMILY, NOT SUPPOSED TO GET HERE
	STOPCD			;(2) OTHER FRAME, SUPPOSED TO BE CONVERTED
	JRST	RXRFRH		;(3) HANDLE
	JRST	FEWUND		;(4) UNDEFINED
	JRST	FEWUND		;(5) UNDEFINED
	JRST	FEWUND		;(6) UNDEFINED
	JRST	RXRSLF		;(7) OWN FRAME
	JRST	RXRCHL		;(1,0) CHILD
	JRST	RXRPAR		;(1,1) PARENT FRAME

;HERE FOR THE VARIOUS TYPES OF FRAME DESCRIPTOR.
;PG/ -COUNT,,USER ADDR
;S/ ORIGINAL COUNT (TO RESTORE LH(PG) FROM)
;P4/ FD GIVEN IN FRMOP AC
; COUNT IS GUARANTEED TO BE NON-ZERO.

;HERE TO READ RIGHTS FOR A HANDLE

RXRFRH:	ANDI	P4,FDDMSK	;GET HANDLE INDEX, KNOW ITS GOOD
	MOVE	P2,%UPT+UPTFHT(P4) ;GET THE ADDRESS
	MOVE	T1,.FHFNO(P2)	;GET BITS+TYPE,,FRAME NUMBER
	UMOVEM	T1,(PG)		;STORE
	AOBJP	PG,CPOPJ1	;DONE IF COUNT EXHAUSED
	MOVE	T1,.FHUID(P2)	;GET UID
	UMOVEM	T1,(PG)		;STORE THAT
	AOBJP	PG,CPOPJ1	;DONE IF COUNT EXHAUSED
	MOVE	T1,.FHPNO(P2)	;GET PNO (ONLY MEANING FUL FOR PROCESS HANDLES)
	UMOVEM	T1,(PG)
	AOBJP	PG,CPOPJ1	;DONE IF COUNT EXHAUSED
				;IF COUNT GONE, LAST AOBJP WENT AWAY.
	MOVSI	P4,.FHART(P2)	;FAST,,
	HRRI	P4,.FHART+1(P2)	;SLOW
	JUMPE	P1,FRMRMR	;IF JUST READING HANDLE, GO NOW.
	LDB	T2,[HTPPTR(.FHTYP(P2))] ;GET HANDLE TYPE
	CAIN	T2,.FHLIC	;IF LIC HANDLE,
	PJRST	FRMRMR		;JUST RETURN THE RIGHTS IN THE HANDLE
	CAIE	T2,.FHFRM	;SKIP IF FRAME HANDLE
	JRST	RXRFR1		;NOT, MUST BE PROCESS
	MOVSI	P3,JBTMFR(J)	;NEED TO AND WITH MFR
	HRRI	P3,%UPX+UPTMFR	;P3/FAST,,SLOW RIGHTS TO AND WITH
	PJRST	FRMRMA		;RETURN RIGHTS AND GIVE SKIP RETURN

RXRFR1:	CAIE	T2,.FHPRC	;PROCESS?
	JRST	FEWBHT		;NO, BAD HANDLE TYPE
	CAME	T1,JBTPNO(J)	;PNO OF HANDLE MATCHES CURRENT PNO OF FRAME?
	MOVE	P4,[NULMFR,,NULMFR+1] ;NO, RETURN NULL RIGHTS
	PJRST	FRMRMR		;YES, RETURN ALL RIGHTS THAT APPEAR IN THE HANDLE.

;HERE FOR SELF FRAME

RXRSLF:	HRLI	J,.FHPRC	;MAKE IT LOOK LIKE PROCESS HANDLE
	UMOVEM	J,(PG)
	AOBJP	PG,CPOPJ1
	MOVE	T1,JBTUID(J)
	UMOVEM	T1,(PG)
	AOBJP	PG,CPOPJ1
	MOVE	T1,JBTPNO(J)
	UMOVEM	T1,(PG)		;PROCESS NUMBER ALWAYS VALID
	AOBJP	PG,CPOPJ1
	MOVE	P4,[ALLMFR,,ALLMFR+1]
	PJRST	FRMRMR		;NO RIGHTS TO AND WITH, JUST RETURN THEM AND SKIP
;HERE FOR PARENT FRAME DESCRIPTOR

RXRPAR:	HRLI	J,.FHPRC	;CHILD TO PARENT IS PROCESS HANDLE
	UMOVEM	J,(PG)
	AOBJP	PG,CPOPJ1
	MOVE	T1,JBTUID(J)	;GET UID OF PARENT
	UMOVEM	T1,(PG)
	AOBJP	PG,CPOPJ1
	MOVE	J,%UPT+UPTJOB	;GET OUR FRAME NUMBER
	MOVE	T1,JBTSPN(J)	;GET PROCESS NUMBER OF THIS HANDLE
	UMOVEM	T1,(PG)		;GIVE IT TO HIM
	AOBJP	PG,CPOPJ1	;GO IF DONE
	MOVSI	P4,JBTS2P(J)	;GET OUR RIGHTS OVER PARENT
	HRRI	P4,%UPT+UPTS2P	;FAST,,SLOW
	JUMPE	P1,FRMRMR	;IF JUST READING HANDLE, GO
	MOVE	J,%UPX+UPTJOB	;GET FRAME NUMBER OF PARENT
	CAME	T1,JBTPNO(J)	;SEE IF PNO OF HANDLE FROM ABOVE MATCHES
	MOVE	P4,[NULMFR,,NULMFR+1] ;NO RIGHTS
	PJRST	FRMRMR		;RETURN WHATEVER.

;HERE FOR CHILD FRAME DESCRIPTOR

RXRCHL:	HRLI	J,.FHFRM	;THIS IS A FRAME HANDLE
	UMOVEM	J,(PG)
	AOBJP	PG,CPOPJ1
	MOVE	T1,JBTUID(J)	;UID IS CURRENT ONE FOR CHILD
	UMOVEM	T1,(PG)
	AOBJP	PG,CPOPJ1	;RETURN IF DONE
	MOVE	T1,JBTPNO(J)	;MAY AS WELL RETURN PNO FOR CHILD
	UMOVEM	T1,(PG)
	AOBJP	PG,CPOPJ1	;RETURN IF DONE
	MOVSI	P4,JBTP2S(J)	;GET PARENT'S RIGHTS OVER TARGET CHILD
	HRRI	P4,%UPX+UPTP2S
	JUMPE	P1,FRMRMR	;GO IF JUST READING THE BITS
	MOVSI	P3,JBTMFR(J)	;WANTS EFFECTIVE RIGHTS, AND WITH MFR
	HRRI	P3,%UPX+UPTMFR
	PJRST	FRMRMA		;RETURN THEM.

;HERE FOR ABSOLUTE FRAME NUMBER

RXRABS:	HRLI	J,.FHLIC	;THIS LOOKS LIKE A LICENSED HANDLE
	UMOVEM	J,(PG)
	AOBJP	PG,CPOPJ1
	SETZ	T1,		;NO UID ASSOCIATED WITH ABS HANDLES
	UMOVEM	T1,(PG)
	AOBJP	PG,CPOPJ1
	UMOVEM	T1,(PG)		;NO PNO EITHER
	AOBJP	PG,CPOPJ1
	PUSHJ	P,ABSACC	;SET P4 TO FAST,,SLOW
	  MOVE	P4,[NULMFR,,NULMFR+1] ;RETURN 0 ACCESS BITS
	PJRST	FRMRMR		;RETURN RIGHTS AND SKIP.
SUBTTL	.FOCAR=30 Read child's child to parent process handle
SUBTTL	.FOCER=31 Read child's C2P with effective rights

COMMENT #FRMOPS TO READ A CHILDS CHILD TO PARENT HANDLE

CALL:

	MOVE	AC,[.FOCAR OR .FOCER,,<FD>]
	FRMOP	AC,ADDR
	  <ERROR RETURN>
	<SUCCESS RETURN>

ADDR:	COUNT,,ADDR OF BLOCK TO RETURN HANDLE INFO IN

FORMAT OF BLOCK:

0/ BITS+TYPE,,FRAME NUMBER
1/ 36 BIT UID
2/ PNO
3-N/ ACCESS BITS

FORMAT OF BLOCK IS COMPATIBLE WITH .FORAR AND .FORER CALLS.

#

FRMCAR:	TDZA	P1,P1		;FLAG TO SAY READ ACCESS/EFFECTIVE
FRMCER:	MOVEI	P1,1		;SAY TO DO EFFECTIVE RIGHTS
	UMOVE	P2,(M)		;GET COUNT,,ADDR
	HLRZ	S,P2		;GET COUNT IN S
	SKIPE	S
	CAILE	S,.UAWMX+3	;RIGHTS TABLE SIZE + FNO,UID,PNO
	JRST	FEWBCN		;BAD COUNT
	MOVN	T1,S		;GET -COUNT
	HRL	P2,T1		;PASS [COUNT,,ADDR IN P2
	SETO	P3,
	PUSHJ	P,FDRUPX	;GET LOCKED FOR READING
	  JRST	FRVERR		;NO GO
	PUSHJ	P,ISCHLD	;CHECK C(J) FOR CHILDNESS
	  JRST	FEWNCH		;NOT A CHILD
	MOVE	PG,P2		;PUT INTO PG

;THIS CODE SIMILAR TO THAT AT RXRPAR

	MOVE	T4,%UPT+UPTJOB	;GET PARENT'S (SELF) JOB NUMBER
	HRLI	T4,.FHPRC	;CHILD TO PARENT HANDLE IS PROCESS HANDLE
	UMOVEM	T4,(PG)		;STORE IT
	AOBJP	PG,CPOPJ1
	MOVE	T1,JBTUID(T4)	;GET PARENT'S UID
	UMOVEM	T1,(PG)		;STORE IT
	AOBJP	PG,CPOPJ1
	MOVE	T1,JBTSPN(J)	;GET PROCESS NUMBER
	UMOVEM	T1,(PG)		;STORE IT
	AOBJP	PG,CPOPJ1
	MOVSI	P4,JBTS2P(J)	;GET FAST RIGHTS,,
	HRRI	P4,%UPX+UPTS2P	;SLOW RIGHTS IN P4
	JUMPE	P1,FRMRMR	;IF NOT DOING EFFECTIVE, JUST GO
	CAME	T1,JBTPNO(T4)	;PNO IN HANDLE HAS TO BE SAME AS PARENT'S
	MOVE	P4,[NULMFR,,NULMFR+1] ;ELSE NO RIGHTS AT ALL
	PJRST	FRMRMR		;AND RETURN THE RIGHTS.
COMMENT ;@@SUBROUTINE FRMRMR/FRMRMA
@@PURPOSE RETURN USER ACCESS BIT MAP FROM MONITOR ACCESS BIT MAP
@@ENTRY	PG/-COUNT(CHECKED),,USER ADDRESS
	P3/ FAST,,SLOW RIGHTS TO AND WITH IF ENTER AND FRMRMA
	P4/ FAST,,SLOW RIGHTS TO RETURN
@@ACCUM U,F,M,P1-P2. PRESERVES W. STORES ERROR CODE THRU W IF COUNT TOO LARGE.
@@EXIT BIT MAP STORED INTO USER SPACE IF SKIP.
	NON-SKIP IF COUNT WAS BAD.
@@;

FRMRMR:	SETZ	P3,		;DON'T AND WITH ANYTHING IF ENTER HERE
FRMRMA:	HLRE	S,PG		;GET -SIZE IN S.
	MOVMS	S		;GET +SIZE
	ADDI	S,-1(PG)	;GET LAST WORD HE WANTS STORED.
	MOVEI	U,M2UACT	;CONVERTING MONITOR BIT MAP TO USER BIT MAP.
	JSP	F,ACRPTR	;START GETTING POINTERS
	  JRST	CPOPJ1		;OK RETURN.
	JUMPE	P3,FRMRM2	;IF NO ANDING, SKIP THIS NEXT STUFF
	MOVE	T2,T3		;COPY SOURCE POINTER
	TRNN	T2,-1		;IF WORD ZERO,
	JRST	[HLR T2,P3	;GET FAST ANDING RIGHTS ADDRESS IN RH OF T2
		 HLR T3,P4	;AND DO IT FOR MAIN SOURCE POINTER
		 JRST FRMRM1]
	ADDI	T2,-1(P3)	;GET SLOW RIGHTS IN T2
	ADDI	T3,-1(P4)	;FOR SOURCE AND AND SLOW RIGHTS
FRMRM1:	ADDI	T4,(PG)		;GET COUNT
	CAIGE	S,(T4)		;MAKE SURE STILL IN RANGE
	JRST	(M)		;NOT, GO FOR MORE DATA
	LDB	T2,T2		;GET DATA TO AND WITH
	LDB	T1,T3		;GET SOURCE DATA BYTE
	AND	T1,T2		;DO THE ANDING
	XCTBU	<DPB T1,T4>	;AND STORE IT FOR USER
	JRST	(M)		;GO FOR NEXT.

FRMRM2:	TRNN	T3,-1		;SOURCE WORD ZERO?
	JRST	[HLR T3,P4	;NO, GET FAST ADDRESS IN SOURCE POINTER
		 JRST .+2]	;AND SKIP NEXT INSTRUCTION
	ADDI	T3,-1(P4)	;ADD IN SLOW RIGHTS ADDRESS
	ADDI	T4,(PG)		;TURN REL USER ADDR INTO ABS ONE.
	LDB	T1,T3		;GET BYTE FROM TABLE
	CAIL	S,(T4)		;STORE IF ADDRESS IN POINTER IS IN RANGE.
	XCTBU	<DPB T1,T4>	;PUT IN USER'S AREA
	JRST	(M)		;GO FOR MORE. NOTE - HAVE TO
				; GO TILL ACRPTR DONE, USER PTRS DO NOT NECESSARILY
				; COME MONITONICALLY INCREASING.
SUBTTL COPY BITS FROM USER TO HANDLE

COMMENT ;@@SUBROUTINE SETHDL
@@PURPOSE FILL RIGHTS OF A HANDLE ACCORDING TO USER ARG
@@ENTRY	PG/COUNT,,USER ADDR OF USER RIGHTS BITS
	P3/HANDLE ADDRESS
	P4/ FAST,,SLOW MAXIMUM ALLOWED RIGHTS, OR 0 IF ALL IS MAX.
	W/ LIMMAX SETTING,,?
@@ACCUM T1-T4,F,M,U,P2,S,1B0 OF W
@@EXIT	NON-SKIP IF COUNT ERROR OR ATTEMPT TO SET RIGHTS HIGHER THAN MAX.
	  P3/ERROR CODE
	  P2/FRAME HANDLE ADDRESS
	  W/RETURNED NEGATIVE IFF USER ARG EXCEEDED MAX.
	  IF LIMMAX WAS 0, RIGHTS ARE USER SPECIFIED ONES.
	  IF LIMMAX WAS 1, RIGHTS ARE USER .AND. MAX
	SKIP IF USER ARG LESS THAN MAX AND COUNT OK, RIGHTS COPIED TO DEST.
@@;
SETHDL:	PUSH	P,P3		;SAVE HANDLE ADDRESS
	HRLI	P3,.FHART(P3)	;GET FAST RIGHTS ADDRESS IN LH P3
	HRRI	P3,.FHART+1(P3)	;SLOW RIGHTS ADDRESS IN RH(P3)
	PUSHJ	P,SETARN	;SET RIGHTS IN MONITOR FROM USER SPEC
	  JRST	[POP P,P2	;GET FH ADDRESS IN P2 FOR THOSE WHO CARE
		 POPJ P,]	;AND GIVE ERROR RETURN.
	AOS	-1(P)
	POP	P,P3
	POPJ	P,
COMMENT ;@@SUBROUTINE SETARN
@@PURPOSE SET RIGHTS IN MONITOR SOMEWHERE ACCORDING TO USER ARGUMENT
@@ENTRY	PG/COUNT,,USER ADDR OF USER RIGHTS BITS
	P3/FAST RIGHTS ADDRESS,,SLOW RIGHTS ADDRESS
	P4/ FAST,,SLOW MAXIMUM ALLOWED RIGHTS, OR 0 IF ALL IS MAX.
	W/LIMMAX SETTING,,USER AC NUMBER TO STORE ERROR CODE INTO
@@ACCUM T1-T4,F,M,U,P2,S,1B0 OF W
@@EXIT NON-SKIP IF RIGHTS EXCEED MAX, WITH RIGHTS SET TO USER SPEC
	IF LIMMAX WAS 0, TO USER SPEC .AND. MAX IF LIMMAX WAS 1,
	AND W NEGATIVE IFF MAX RIGHTS WERE EXCEEDED BY USER SPEC.
       SKIP OTHERWISE WITH RIGHTS COPIED INTO DESTINATION
	 WITH W NEGATIVE IFF MAX RIGHTS ARE EXCEEDED BY USER SPEC.
@@;


EXTERNAL SAVE1

XP LIMMAX,(1B1)		;IF ON, LIMIT DESTINATION TO MAX RIGHTS ARG.

SETARN:	TLZ	W,(1B0)		;CLEAR MAX EXCEEDED RETURN ARG.
	JSP	T4,SAVE1	;SAVE P1 FOR CALLER.
	TLNN	PG,-1		;IF COUNT IS ZERO,
	JRST	SETMAX		;THEN SET THE MAX RIGHTS HE IS ALLOWED.
	HLRZ	S,PG		;GET USER'S COUNT
	CAILE	S,.UAWMX	;IN RANGE?
	JRST	FEBCN		;NO, BAD COUNT
	ADDI	S,-1(PG)	;GET LAST WORD WE'RE ALLOWED TO STORE INTO
	MOVEI	U,U2MACT	;CONVERT USER BITS TO MONITOR ONES
	JSP	F,ACRPTR	;GET THINGS STARTED
	  JRST	[JUMPL W,FENRT	;IF MAX VIOLATION, GIVE ERROR.
		 JRST CPOPJ1]
	ADDI	T3,(PG)		;GET BYTE POINTER TO USER'S ARG BLOCK
	CAIGE	S,(T3)		;STILL WITHIN SPECIFIED SPACE?
	JRST	[SETZ T1,	;NO, ASSUME RIGHTS ARE OFF
		 JRST SETAR1]
	JUMPE	P4,[XCTFU <LDB T1,T3> ;ALL RIGHTS ALLOWED - JUST GET SOURCE BYTE
		   JRST SETAR1]
	MOVE	T2,T4		;GET COPY OF DEST POINTER
	TRNN	T2,-1		;IF ZEROTH WORD,
	JRST	[HLR T2,P4	;PUT ADDRESS OF FAST RIGHTS IN RH OF POINTER
		 JRST .+2]
	ADDI	T2,-1(P4)		;ELSE ADD SLOW RIGHTS ADDRESS IN
	XCTFU	<LDB T1,T3>	;GET A BYTE
	LDB	T2,T2		;GET MAX BYTE
	ANDCA	T2,T1		;T2 GETS A 1 FOR EVERY FORBIDDEN BIT
				; USER IS TRYING TO SET
	JUMPE	T2,SETAR1	;JUMP IF MAX NOT EXCEEDED.
	TLO	W,(1B0)		;THEY ARE, SET W TO BE NEGATIVE.
	TLNE	W,LIMMAX	;IF LIMMAX IS ONE,
	ANDCAM	T2,T1		;THEN TURN OFF BITS HE'S NOT ALLOWED TO HAVE.
SETAR1:	TRNN	T4,-1		;IF ZERO WORD,
	JRST	[HLR T4,P3	;FILL IN FAST RIGHTS ADDRESS
		 JRST .+2]	;AND SKIP
	ADDI	T4,-1(P3)	;FILL IN SLOW RIGHTS ADDRESS
	DPB	T1,T4		;STORE THEM
	JRST	(M)		;GO FOR MORE.
;HERE IF USER SPECIFIED ZERO COUNT - GIVE HIM THE MAX RIGHTS HE
; CAN HAVE.

SETMAX:	SKIPN	T1,P4		;IF P4 IS ZERO,
	MOVE	T1,[ALLMFR,,ALLMFR+1] ;THEN SKY IS THE LIMIT
	HLRZ	T2,T1		;GET FAST RIGHTS ADDRESS
	MOVE	T2,(T2)		;GET FAST RIGHTS DATA
	HLRZ	T3,P3		;GET DESTINAION ADDRESS
	MOVEM	T2,(T3)		;STORE IT.
	MOVSI	T2,(T1)		;GET SOURCE,,0
	HRR	T2,P3		;GET SOURCE,,DEST
	BLT	T2,.ARSIZ-1(P3)	;COPY REST OF BITS INTO DESTINATION
	JRST	CPOPJ1
SUBTTL	.FOGFT=24 Graft a frame

COMMENT #FRMOP FUNCTION TO GRAFT FRAMES AROUND.

CALL:

	MOVE	AC,[.FOGFT,,FD OF CHILD TO REMOVE]
	FRMOP	AC,[FD OF PARENT TO ADD CHILD TO OR 0 TO MAKE CHILD AN ORPHAN]
	  <ERROR RETURN>
	<SKIP RETURN>

THE CHILD TO PARENT PROCESS HANDLE IS INVALIDATED BY THIS OPERATION,
IN ORDER TO ALLOW FRAMES TO LET OTHER FRAMES GRAFT CHILDREN ONTO THEM
WITHOUT RUNNING THE RISK OF THE CHILD HAVING TOO MUCH ACCESS TO ITS
NEW PARENT.
THE PARENT TO CHILD FRAME HANDLE HAS THE SAME RIGHTS SET AS THE
LAST PARENT TO CHILD HANDLE TO THAT FRAME HAD. THE CHILD'S MFR
IS ALSO UNCHANGED BY THIS OPERATION. THIS ENSURES THAT A PARENT THAT
IS GIVEN A CHILD WITH ONLY CERTAIN RIGHTS OVER IT CANNOT INCREASE THOSE
RIGHTS WITHOUT ZAPPING THE FRAME.
#

FRMGFT:	UHRRZ	U,(M)		;GET DEST FD IF ANY IN U
	MOVE	P2,P4		;SAVE, HAVE TO DO MULTIPLE CHECKS
	JUMPE	U,FRMGNP	;GO IF NO NEW PARENT TO CHECK FOR
	MOVE	P4,U		;GET NEW PARENT'S FD
	MOVEI	P3,.ARGVC	;CHECK TO SEE IF CAN GIVE A CHILD
	PUSHJ	P,FARCHK	;CAN HE?
	  JRST	FRVERR		;NO
	MOVE	T1,JBTSTS(J)	;MAKE SURE IT EXISTS
	TLNN	T1,JNA		;IF NOT,
	 JRST	FEWBDF		;BAD FRAME NUMBER
	MOVE	U,J		;SAVE NEW PARENT'S FRAME NUMBER IN U
	MOVE	P4,P2		;GET FD FOR CHILD
	MOVEI	P3,.ARGVP	;CAN WE GIVE NEW PARENT TO CHILD?
	PUSHJ	P,FARCHK	;IF NOT
	  JRST	FRVERR		;DIE.
	MOVE	T1,JBTSTS(J)	;GET BITS TO SEE IF IT EXISTS
	TLNN	T1,JNA
	 JRST	FEWBDF		;DOES NOT.
	HRRZ	T1,U		;SCAN SUBTREE TO MAKE SURE NOT GRAFTING ONTO
				; ANYONE IN CHILD'S SUBTREE
FRMGF1:	CAIN	T1,(J)		;HAVE WE REACHED CHILD YET?
	 JRST	FEWCII		;YES, CAN'T ALLOW GRAPHS
	LDB	T1,PRNTBP(T1)	;GET PARENT NEXT UP
	JUMPN	T1,FRMGF1	;AND KEEP GOING

;HERE WITH NEW PARENT FRAME NUMBER OR 0 IN U, CHILD DESCRIPTOR IN P2

FRMGNP:	MOVE	P4,P2		;GET FD FOR CHILD IN P4
	PUSHJ	P,FD2FNO	;CONVERT TO FRAME NUMBER, IN J
	  JRST	FRVERR		;SOMETHING IS BAD
	MOVE	T1,JBTSTS(J)	;MAKE SURE IT EXISTS
	TLNN	T1,JNA		;DOES IT?
	 JRST	FEWBDF		;NO, BAD FRAME NUMBER
	LDB	T1,PRNTBP(J)	;HAS PARENT?
	JUMPE	T1,FRMNPR	;NO, DON'T HAVE TO CHECK TO SEE IF CAN TAKE PARENT AWAY
	MOVEI	P3,.ARTKP	;HAS ONE, CAN WE TAKE IT?
	PUSHJ	P,CHEKAR	;SEE
	  JRST	FRVERR		;NO, RETURN ERROR CODE
	PUSHJ	P,TKCHLD	;TAKE CHILD'S PARENT AWAY.
FRMNPR:	SETZM	JBTSPN(J)	;INVALIDATE CHILD'S PROCESS HANDLE
	SKIPE	T1,U		;GET NEW PARENT'S FRAME NUMBER
	 PUSHJ	P,ADCHLD	;ADD TO HIS TREE
	JRST	CPOPJ1		;AND RETURN.
SUBTTL FRAME TREE HANDLERS

COMMENT ;@@SUBROUTINE ADCHLD
@@PURPOSE ADDS A CHILD FOR A SPECIFIED PARENT FRAME
@@ENTRY	T1/PARENT FRAME NUMBER
	J/NEW CHILD FRAME NUMBER
@@ACCUM T1-T4
@@EXIT J IS PRESERVED, ALWAYS NON-SKIP
@@;

ADCHLD:	SETZM	JBTPNT##(J)	;Clear child to parent int channels
	LDB	T2,CHLDBP(T1)	;GET PARENT'S LEFTMOST CHILD IF ANY
	DPB	T2,NEIGBP(J)	;THIS IS OUR NEW NEIGHBOR
	DPB	J,CHLDBP(T1)	;WE ARE NOW LEFTMOST CHILD
	DPB	T1,PRNTBP(J)	;POINT US AT OUR PARENT
	POPJ	P,		;RETURN.


COMMENT ;@@SUBROUTINE TKCHLD
@@PURPOSE REMOVES A CHILD FROM ITS PARENT
@@ENTRY	J/ CHILD NUMBER
@@ACCUM T1-T4
@@EXIT J PRESERVED, ALWAYS NON-SKIP
  CALLER RESPONSIBLE FOR ACCESS CHECKING
  AND MAKING SURE FRAME HAS A PARENT
@@;

TKCHLD::LDB	T1,JBYLCF	;Does parent want to know "lost child frame"?
	SKIPN	T1		;If channel is not set,
	 LDB	T1,JBYECF	; try the Exit in Child Frame channel (JBTPNT)
	PUSH	P,J		;Save J of frame being taken
	LDB	J,PRNTBP(J)	;Get this guy's parent, if any
	SKIPE	J		;Nothing do do if no parent
	SKIPN	T1		; or if no interrupt channel assigned
	 SKIPA
	  PUSHJ	P,TAKTRP##	;Tell parent she has lost her child
	POP	P,J
	SETZM	JBTPNT##(J)	;Clear child to parent int channels
	LDB	T1,PRNTBP(J)	;GET PARENT FRAME NUMBER
	JUMPE	T1,CPOPJ	;IF NO PARENT, CAN'T DO IT.
	LDB	T2,CHLDBP(T1)	;GET FIRST CHILD
	CAMN	T2,J		;FIRST ONE IS US?
	 JRST	TKCHL2		;YES, NO PREVIOUS FRAME TO UNLINK
TKCHL1:	MOVE	T3,T2		;REMBMER PREVIOUS FRAME
	LDB	T2,NEIGBP(T2)	;GET NEXT ONE
	CAME	T2,J		;FOUND OURSELVES?
	 JRST	TKCHL1		;NO, KEEP LOOKING, WE SHOULD BE THERE IF DATA BASE IS NOT SCREWED UP

;FRAME THAT POINTS TO US IS IN T3.

	LDB	T2,NEIGBP(T2)	;GET OUR NEXTDOOR NEIGHBOR
	DPB	T2,NEIGBP(T3)	;LAST POINTS TO NEXT
	JRST	TKCHL3		;AND GO FINISH UP.

;HERE IF WE ARE FIRST CHILD FRAME OF PARENT IN C(T1).

TKCHL2:	LDB	T2,NEIGBP(J)	;GET NEXT FRAME IF ANY
	DPB	T2,CHLDBP(T1)	;PARENT POINTS TO NEXT FRAME

TKCHL3:	SETZ	T2,		;NOW CLEAR OUT
	DPB	T2,NEIGBP(J)	;NEIGBOR FRAME NUMBER
	DPB	T2,PRNTBP(J)	; AND PARENT NUMBER
	POPJ	P,		;AND RETURN.
COMMENT ;@@SUBROUTINE NOPRNT
@@PURPOSE CAUSE ALL CHILDREN OF A CERTAIN PARENT FRAME TO BECOME
ORPHANED (NO PARENTS, NO NEIGHBORS)
CALLED BY JOBKL
@@ENTRY J/PARENT FRAME NUMBER
@@ACCUM T1-T4
@@EXIT ALWAYS NON-SKIP, J PRESERVED
@@;

EXTERNAL CPOPJ

NOPRNT::LDB	T2,CHLDBP(J)	;GET LEFTMOST CHILD
	JUMPE	T2,CPOPJ	;IF NO CHILDREN, DONE.
	SETZ	T3,		;USE THIS REG FOR ZEROING
	DPB	T3,CHLDBP(J)	;NO MORE CHILDREN
NOPRN1:	DPB	T3,PRNTBP(T2)	;THIS CHILD HAS NO MORE PARENT
	SETZM	JBTPNT##(T2)	;Clear child to parent int channels
	LDB	T1,NEIGBP(T2)	;GET ITS NEXT BROTHER, IF ANY.
	JUMPE	T1,CPOPJ	;IF NO BROTHER, DONE.
	DPB	T3,NEIGBP(T2)	;THIS FRAME IS NOT THAT FRAME'S BROTHER ANYMORE
	MOVE	T2,T1		;ITS FORMER BROTHER IS NEW FRAME TO WORK ON
	JRST	NOPRN1		;GO ORPHAN NEXT FRAME.
COMMENT ;@@SUBROUTINE ISCHLD
@@PURPOSE USED TO CHECK IF C(J) IS A CHILD OF CURRENTLY RUNNING
FRAME.
@@ENTRY C(J)/ ALLEGED CHILD
	%UPT/ CURRENT FRAME'S CONTEXT PAGES
@ACCUM PRESERVES ALL ACS
@@EXIT NON-SKIP IF C(J) FRAME IS NOT A CHILD OF CURRENT FRAME,
	SKIP IF C(J) IS A CHILD.
@@;
EXTERNAL IPOPJ1,IPOPJ

ISCHLD:	PUSH	P,J		;SAVE WHAT WE WANT
	MOVE	J,%UPT+UPTJOB	;GET OUR FRAME NUMBER
ISCHL0:	LDB	J,CHLDBP(J)	;GET FIRST CHILD IF ANY
	JUMPE	J,IPOPJ		;NO CHILDREN AT ALL GIVE ERROR.
ISCHL1:	CAMN	J,(P)		;WHAT WE'RE LOOKING FOR?
	 JRST	IPOPJ1		;YES, GIVE SUCCESS RETURN
	LDB	J,NEIGBP(J)	;NO, GET NEXT
	JUMPN	J,ISCHL1	;AND LOOP
	POP	P,J		;NOT FOUND, GIVE ERROR RETURN
	POPJ	P,

COMMENT ;@@SUBROUTINE ISSIBL
@@PURPOSE USED TO CHECK IF C(J) IS A SIBLING OF CURRENTLY RUNNING FRAME.
@@ENTRY C(J)/ ALLEGED SIBLING
	%UPT/ CURRENT FRAME'S CONTEXT PAGES
@ACCUM PRESERVES ALL ACS
@@EXIT NON-SKIP IF C(J) FRAME IS NOT A CHILD OF CURRENT FRAME'S PARENT
	SKIP IF C(J) IS A SIBLING.
@@;

ISSIBL:	PUSH	P,J		;Save J on stack for compare
	MOVE	J,%UPT+UPTJOB	;Get our frame number
	LDB	J,PRNTBP(J)	;Get our parent if any
	JUMPE	J,IPOPJ		;No parent - therefore no siblings
	JRST	ISCHL0		;Jump into ISCHLD loop
SUBTTL ROUTINES TO GET CONTEXT PAGES AND CHECK ACCESS
COMMENT ;@@SUBROUTINE SRDUPX/SWRUPX
@@PURPOSE WRITE LOCK DESIRED CONTEXT PAGES IN %UPX AND CALL THE CALLER
SO DON'T HAVE TO WORRY ABOUT GIVING THE LOCK BACK ON ERRORS AND THINGS
@@ENTRY T1 CONTAINS VUUO POINTER - PAGE IN RH(T1) AND OTFFLG IN LH(T1)
	P3 CONTAINS ACCESS RIGHTS CODE FOR INTENDED OPERATIONI OR -1 FOR NO CHECK
	%UPT+UPTOFD CONTAINS FRAME DESCRIPTOR TO USE IF OTHER FRAME ENABLED.
@@ACCUM T3-T4,P3,P4,PG,J (CALLS WLKUPX)
  (SAVES T1 AND T2 BECAUSE UUO ARGS ARE IN THEM.)
@@EXIT NON-SKIP WITH ERROR CODE IN P3 IF CAN'T GET CONTEXT PAGES
	LOCKED OR GET FRAME DESCRIPTOR FAILURE.
SKIP IF CAN WITH J/FRAME NUMBER P4/FD %UPX/ C(J)'S CONTEXT PAGES
@@;

XP OTFFLG,(1B1)

SRDUPX::
SWRUPX::TLNE	T1,OTFFLG
	SKIPN	P4,%UPT+UPTOFD	;WANTS OTHER - GET IT IF NON-ZERO
	 MOVEI	P4,.FDSLF	;NONE SET, USE SELF.
	PUSH	P,T1		;SVE T1 AND T2
	PUSH	P,T2
	PUSHJ	P,FD2WLK	;SETUP J, CHECK RIGHTS, GET %UPX LOCKED.
	  JRST	[POP P,T2	;SUB ERROR CODE IS IN P3.
		 POP P,T1	;RESTORE AND RETURN.
		 POPJ P,]
	POP	P,T2
	POP	P,T1
	POP	P,T4		;GET CALLER'S PC
	PUSHJ	P,1(T4)		;CALL AT ADDR+2 (SKIP OVER ERROR RETURN)
	  SKIPA
	AOS	(P)		;GIVE CALLER'S CALLER SKIP RETURN
	PUSH	P,T1		;SAVE ERROR CODE
	PUSHJ	P,ULDUPX	;RELEASE LOCKDOWN
	POP	P,T1
	POPJ	P,
COMMENT ;@@SUBROUTINE FDWUPX/FDRUPX
@@PURPOSE SAME AS SWRUPX, SRDUPX EXCEPT TAKES FRAME DESCRIPTOR IN P4.
@@ENTRY P4 CONTAINS FRAME DESCRIPTOR
	P3 CONTAINS REQUIRED ACCESS RIGHT CODE OR -1 FOR NO CHECK
@@ACCUM T1-T4, P3, PG, J (CALLS WLKUPX)
@@EXIT NON-SKIP IF CAN'T GET CONTEXT PAGES LOCKED, J DESTROYED,
	ERROR CODE IN P3.
	SKIP IF OK, J HAS APPROPRIATE FRAME NUMBER, %UPX
	HAS THAT FRAME'S CONTEXT PAGES LOCKED.
@@;

FDWUPX::
FDRUPX::PUSH	P,P4		;SAVE AS A COURTESY TO CALLER
	PUSHJ	P,FD2WLK
	  JRST	[POP P,P4	;GET P4 BACK
		 POPJ P,]
	POP	P,P4		;RESTORE
	POP	P,T4
	PUSHJ	P,1(T4)		;CALL THE CALLER, SKIP OVER ERROR RETURN.
	  JRST	ULDUPX		;GIVE ERROR RETURN, UNLOCK UPX.
	AOS	(P)		;CALLER GIVING HIS CALLER SKIP RETURN.
	JRST	ULDUPX		;UNLOCK UPX AND RETURN.
COMMENT ;@@SUBROUTINE FD2WLK
@@PURPOSE TAKE A FRAME DESCRIPTOR AND GET THE ABSOLUTE
FRAME NUMBER IN J, WRITE LOCK C(J)'S CONTEXT PAGES IN %UPX.
@@ENTRY	ENTER AT FD2WL1 IF FD2FNO ALREADY CALLED.
	P3/ACCESS RIGHTS CODE FOR ATTEMPTED FUNCTION OR -1 FOR NO RIGHTS CHECK
	P4/FRAME DESCRIPTOR
@@ACCUM T1-T4, P3,P4, PG
@@EXIT	NON-SKIP, P3 HAS ERROR CODE
	UPX NOT LOCKED.
	SKIP, J HAS FRAME NUMBER, %UPX HAS CONTEXT PAGES WRITE LOCKED.
	ORIGINAL CONTENTS OF P3 AND P4 ARE LOST.
@@;

EXTERNAL WLKUPX,ULDUPX

FD2WLK::PUSHJ	P,FD2FNO	;GET FRAME NUMBER TO LOCK
	  POPJ	P,		;P3 HAS ERROR CODE.
FD2WL1::PUSHJ	P,WLKUPX	;TRY TO GET THE CONTEXT PAGES IN
	  JRST	FECLP		;CAN'T GET THEM IN.
	JUMPL	P3,CPOPJ1	;IF NO RIGHTS CHECK, RETURN NOW.
	PUSHJ	P,CHEKAR	;SEE IF HE HAS RIGHTS
	  PJRST ULDUPX		;GIVE BACK %UPX AND ERROR CODE IS IN P3.
	JRST	CPOPJ1		;OK, RETURN.


COMMENT  ;@@SUBROUTINE FARCHK
@@PURPOSE CHECK A FAST ACCESS RIGHT TO SEE IF CALLER HAS ACCESS
@@ENTRY	P3/ACCESS RIGHTS CODE FOR INTENDED FUNCTION
	P4/FRAME DESCRIPTOR
@@ACCUM T1-T4, P3, P4
@@EXIT	NON-SKIP, P3 HAS ERROR CODE FOR ERROR
	SKIP IF OK, FRAME NUMBER IN J.
@@;

FARCHK::PUSHJ	P,FD2FNO	;GET FRAME NUMBER.
	  POPJ	P,
	PUSHJ	P,CHEKAR	;SEE IF CAN DO IT
	  POPJ	P,		;NO, RETURN ERROR IN P3
	JRST	CPOPJ1		;OK.
SUBTTL FRAME DESCRIPTOR PROCESSING
COMMENT ;@@SUBROUTINE FD2FNO
@@PURPOSE CONVERT FRAME DESCRIPTOR TO ABSOLUTE FRAME NUMBER
@@ENTRY	RH(P4)/FRAME DESCRIPTOR
@@ACCUM T3,T4
@@EXIT	SKIP RETURN WITH C(J) FRAME NUMBER IF SUCCESSFUL
	NON-SKIP IF ERROR, CODE IN P3 IF NOT SUCCESSFUL.
	CONTENTS OF ARG C(P4) ARE PRESERVED.
@@;

FD2J::	PUSH	P,P3		;Convert FD in J to frame number in J
	PUSH	P,P4		;Preserves all other ACs
	HRRZ	P4,J		;Get FD
	SETO	P3,		;No access rights
	PUSHJ	P,FD2FNO	;Convert to frame number in J
	  JRST	[MOVE	J,P3	  ;Return error code in J
		 JRST	FD2J1]
	AOS	(P)		;Skip return
FD2J1:	POP	P,P4
	POP	P,P3
	POPJ	P,


FD2FNO::MOVEI	T4,FD2TAB	;ADDRESS OF INSTRUCTION TABLE
	JRST	FDDSP		;DISPATCH.

FD2TAB:	JRST	FD2ABS		;(0) ABS FRAME NUMBER
	STOPCD			;(1) FAMILY
	STOPCD			;(2) OTHER FRAME
	JRST	FD2FRH		;(3) HANDLE
	JRST	FEUND		;(4) UNDEFINED
	JRST	FEUND		;(5) UNDEFINED
	JRST	FEUND		;(6) UNDEFINED
	JRST	FD2SLF		;(7) OWN FRAME
	JRST	FD2CHL		;(1,0) CHILD
	JRST	FD2PAR		;(1,1) PARENT FRAME

FD2PAR:	MOVE	J,%UPT+UPTJOB	;GET OUR OWN FRAME NUMBER
	LDB	J,PRNTBP(J)	;GET OUR PARENT IF ANY
	JUMPE	J,FENPR		;NO PARENT, GIVE ERROR
	JRST	CPOPJ1		;OK, RETURN WITH PARENT'S FRAME NUMBER

FD2CHL:	MOVE	J,P4		;GET FD IN J
	ANDI	J,FDDMSK	;JUST FRAME NUMBER
	CAILE	J,JOBMAX	;FRAME NUMBER IN RANGE?
	 JRST	FEBDF		;NO, GIVE ERROR
	PUSHJ	P,ISCHLD	;MAKE SURE ITS ONE OF OUR CHILDREN
	  JRST	FENCH		;NOT A CHILD.
	JRST	CPOPJ1		;OK, RETURN WITH CHILD NUMBER IN J

FD2SLF:	MOVE	J,%UPT+UPTJOB	;GET OWN FRAME NUMBER
	JRST	CPOPJ1		;AND RETURN WITH IT.

FD2ABS:	MOVE	J,P4		;GET THE DESCRIPTOR
	ANDI	J,FDDMSK	;JUST THE FRAME NUMBER
	CAILE	J,JOBMAX	;OK AS LONG AS ITS INSIDE LEGAL RANGE.
	 JRST	FEBDF		;NO, GIVE ERROR.
	JRST	CPOPJ1		;GIVE SUCCESS. CHEKAR WILL CHECK LICENSE.

;HERE FOR HANDLE

FD2FRH:	MOVE	J,P4		;GET DESCRIPTOR
	ANDI	J,FDDMSK	;JUST THE HANDLE INDEX NUMBER
	CAILE	J,FHIMAX	;LEGAL HANDLE INDEX NUMBER?
	 JRST	FEBDH		;NO, ERROR
	SKIPN	J,%UPT+UPTFHT(J) ;GET HANDLE ADDRESS
	 JRST	FENOH		;NO HANDLE
	MOVE	T3,.FHUID(J)	;GET UNIVERSAL ID NUMBER
	MOVE	J,.FHFNO(J)	;GET FRAME NUMBER INTO J
	CAME	T3,JBTUID(J)	;MAKE SURE UID'S MATCH
	 JRST	FEBDI		;THEY DO NOT, GIVE ERROR.
	JRST	CPOPJ1		;AND GIVE GOOD RETURN
COMMENT ;@@SUBROUTINE CHEKAR
@@PURPOSE SEE IF THE CALLER HAS THE RIGHT TO PERFORM A GIVEN
FUNCTION THROUGH A GIVEN FRAME DESCRIPTOR
@@ENTRY	P3/ACCESS RIGHT FUNCTION CODE
	RH(P4)/FRAME DESCRIPTOR
	%UPX - HAS CONTEXT PAGES OF C(J) FRAME
IT IS ASSUMED THAT FD2FNO WAS CALLED, WHICH CHECKS THE VALIDITY
OF THE FRAME DESCRIPTOR.
@@ACCUM T1-T4, P3, P4
@@EXIT NON-SKIP IF CALLER CANNOT PERFORM FUNCTION
	ERROR CODE IN P3 (SEE FEERS ROUTINE)
	SKIP IF CALLER CAN PERFORM FUNCTION
	ORIGINAL CONTENTS OF P3 AND P4 ARE LOST.
@@;

EXTERNAL UPTS2P,UPTP2S,UPTFHT,UPTJOB
EXTERNAL BITTBL
EXTERNAL JBTLIC
EXTERNAL JOBMAX,FHIMAX,CPOPJ1
EXTERNAL JBTP2S,JBTS2P,JBTSPN,JBTPNO

CHEKAR::CAILE	P3,.ARMAX	;IS IT IN RANGE?
	 JRST	FEBAR		;NO, BAD ACCESS RIGHTS CODE.
	MOVE	T1,P3		;GET ACCESS RIGHT CODE INTO T1 FOR IDIVI
	IDIVI	T1,^D36		;T1 GETS INDEX INTO WHATEVER BIT TABLE,
	MOVE	T2,BITTBL(T2)	; T2 HAD BIT NUMBER, GETS THE BIT.
	MOVEI	T4,CHEKTB	;ADDRESS OF DISPATCH TABLE FOR FDDSP
	JRST	FDDSP		;AND DISPATCH.

;FRAME DESCRIPTOR ROUTINES ARE GIVEN INDEX FOR ACCESS RIGHT
; BIT TABLE IN T1, BIT IN T2, FRAME DESCRIPTOR IN P4.

CHEKTB:	JRST	CHEABS		;(0) ABS FRAME NUMBER
	STOPCD			;(1) FAMILY
	STOPCD			;(2) OTHER FRAME
	JRST	CHEFRH		;(3) HANDLE
	JRST	FEUND		;(4) UNDEFINED
	JRST	FEUND		;(5) UNDEFINED
	JRST	FEUND		;(6) UNDEFINED
	JRST	CPOPJ1		;(7) OWN FRAME
	JRST	CHECHL		;(1,0) CHILD FRAME
	JRST	CHEPAR		;(1,1) PARENT FRAME
;HERE FOR HANDLE, HANDLE INDEX IN P4, T1 AND T2 INDEX AND BIT
; INTO ACCESS BIT TABLE

CHEFRH:	ANDI	P4,FDDMSK	;JUST DATA.
	CAILE	P4,FHIMAX	;WITHIN THE RANGE OF A HANDLE INDEX?
	JRST	FEBDH		;NO, BAD HANDLE.
	SKIPN	P4,%UPT+UPTFHT(P4)	;GET HANDLE ADDRESS IN P4
	JRST	FENOH		;ZERO MEANS THERE ISN'T ANY HANDLE.
	MOVE	T3,T1		;GET RELATIVE WORD IN T3
	ADDI	T3,.FHART(P4)	;GET ADDRESS OF THE BIT TO CHECK
	TDNN	T2,(T3)		;OK IF THE BIT IS ON
	JRST	FENRT		;NO RIGHT TO DO THIS OPERATION
	LDB	T3,[HTPPTR(.FHTYP(P4))] ;GET HANDLE TYPE
	CAIN	T3,.FHLIC	;IF LICENSED, OK.
	JRST	CPOPJ1
	MOVE	P3,JBTUID(J)	;GET UNIVERSAL ID NUMBER
	CAME	P3,.FHUID(P4)	;MUST MATCH
	JRST	FEBDI		;IDS DO NOT MATCH
	CAIE	T3,.FHPRC	;PROCESS HANDLE?
	JRST	CHEFR1		;NO, SEE IF ITS ANOTHER TYPE.
	MOVE	T3,JBTPNO(J)	;YES, CAN ACCESS IF PNO MATCHES
	CAME	T3,.FHPNO(P4)	;THE ONE IN THE HANDLE
	JRST	FENRT		;LOSES, SOME OTHER PROGRAM GRANTED THE PROCESS RIGHTS.
	JRST	CPOPJ1		;OK, WINS.

CHEFR1:	CAIN	T3,.FHFRM	;FRAME HANDLE?
	JRST	MFRCHK		;YES, CAN HAVE RIGHTS SUBJECT TO MAX FRAME RIGHTS.
	JRST	FEBHT		;BAD HANDLE TYPE.

;HERE TRYING TO ACCESS PARENT. CHILD OVER PARENT RELATIONSHIP
; IS STRICLY A PROCESS RELATIONSHIP FOR THE MOMENT - LATER,
; WE MUST ADD A BIT WHICH ALLOWS IT TO BE A FRAME RELATIONSHIP
; WHEN WE ADD THE "SELF RIGHT" FOR A FRAME TO CREATE FRAME
; HANDLES TO ITSELF, RATHER THAN JUST PROCESS HANDLES.
; ELSE, FRAME COULD GET A FRAME HANDLE TO ITSELF BY CREATING
; A CHILD WHICH PASSED THE FRAME HANDLE TO PARENT.

CHEPAR:	MOVE	T3,[%UPT+UPTS2P,,JBTS2P]
	MOVE	J,%UPT+UPTJOB	;GET OUR FRAME NUMBER
	PUSHJ	P,ARCHEK	;CHECK RIGHT
	  JRST	FENRT		;SORRY.
	MOVE	T3,JBTSPN(J)	;GET PROCESS NUMBER THAT GRANTED THE RIGHTS
	LDB	J,PRNTBP(J)	;GET PARENT FRAME NUMBER
	CAMN	T3,JBTPNO(J)	;SAME PROCESS AS RUNNING NOW?
	AOS	(P)		;YES, WIN.
	POPJ	P,		;NO, NO RIGHTS AT ALL.

;HERE TRYING TO ACCESS CHILD. FD2FNO ALREADY CALLED, SO NO NEED TO CHECK.
; PARENT TO CHILD RELATIONSHIP ACTS LIKE A FRAME HANDLE - IT
; CANOT BE VALIDATED BY THE CHILD LIKE A PROCESS RELATIONSHIP,
; AND IT CAN ALWAYS HAVE UP TO CURRENT MAX FRAME RIGHTS OF CHILD FRAME.

CHECHL:	MOVE	T3,[%UPX+UPTP2S,,JBTP2S] ;FOR RIGHTS CHECKING
	PUSHJ	P,ARCHEK	;INHERENT RIGHTS ALLOW IT?
	  JRST	FENRT		;NO.
	PJRST	MFRCHK		;NO, RIGHTS SUBJECT TO MAX FRAME RIGHTS.

CHEABS:	ANDI	P4,FDDMSK	;JUST DATA, NO TYPE.
	CAILE	P4,JOBMAX	;LEGAL
	JRST	FEBDF
	PUSHJ	P,ABSACC	;GET P4 FAST,,SLOW = TABLE,,TABLE+1
	  JRST	FENLC		;HAS NO LICENSE
	ADDI	T1,-1(P4)	;GET ADDRESS TO CHECK
	TDNN	T2,(T1)		;HAS THE BIT SET?
	JRST	FENRT		;NO
	JRST	CPOPJ1		;YES.
COMMENT ;@@SUBROUTINE MFRCHK
@@PURPOSE CHECK MAX FRAME RIGHTS FOR FRAME
@@ENTRY	T1/INDEX
	T2/BIT
	J/FRAME NUMBER
	%UPX/CTX PAGES FOR C(J) IF SLOW ACCESS RIGHTS
@@ACCUM T3
@@EXIT	NONSKIP AND ERROR CODE FOR ACCESS RIGHTS FAIL IN P3 IF ERROR.
	SKIP IF OK.
@@;

EXTERNAL UPTMFR,JBTMFR

MFRCHK:	MOVE	T3,[%UPX+UPTMFR,,JBTMFR]
	PUSHJ	P,ARCHEK
	  JRST	FENRT
	JRST	CPOPJ1


COMMENT ;@@SUBROUTINE ARCHEK
@@PURPOSE CHECK BITS EITHER IN JBT TABLE OR UPT, DEPENDING ON
WHETHER INDEX AC T1 IS 0 OR NON-ZERO.
@@ENTRY	T1/INDEX (0 FOR JBT TABLE, 1-INF FOR UPT)
	T2/THE BIT WITHIN THE WORD
	T3/%UPT+UPT???,,JBT???
	J/FRAME NUMBER
	%UPX/SETUP IF NECESSARY FOR A SLOW ACCESS RIGHT
@@ACCUM T3
@@EXIT NON-SKIP IF ACCESS FAILURE
	SKIP IF ACCESS OK.
@@;

ARCHEK:	JUMPN	T1,ARCHE1	;GO IF SLOW ACCESS RIGHT.
	HRLI	T3,J		;MAKE T3/JBT???(J)
	TDNE	T2,@T3
	AOS	(P)
	POPJ	P,
ARCHE1:	HLRZS	T3		;GET %UPT+UPT??? IN RH OF T3
	ADDI	T3,-1(T1)	;GET INDEX TO CHECK.
	TDNE	T2,@T3
	AOS	(P)
	POPJ	P,

;ROUTINE FOR COMCON TO INIT RIGHTS FOR CURRENT JOB TO VIRGIN. SMASHES T1 ONLY.
; EXPECTS CTX PAGES FOR CURRENT JOB IN %UPT.

INIARB::MOVE	T1,ALLMFR	;GET FAST BITS
	MOVEM	T1,JBTP2S(J)	;INITIALLY, PARENT HAS ALL RIGHTS
	MOVEM	T1,JBTMFR(J)	;AND SO DOES EVERYONE ELSE
	MOVE	T1,[ALLMFR+1,,%UPT+UPTMFR]
	BLT	T1,%UPT+UPTMFR+.ARSIZ-1 ;COPY THE SLOW BITS
	MOVE	T1,[ALLMFR+1,,%UPT+UPTP2S]
	BLT	T1,%UPT+UPTP2S+.ARSIZ-1 ;ALL RIGHTS.
	POPJ	P,		;RETURN.
COMMENT ;@@SUBROUTINE ABSACC
@@PURPOSE RETURN ACCESS RIGHTS THAT CURRENTLY RUNNING FRAME HAS OVER
ANOTHER FRAME
@@ENTRY %UPT/ CONTEXT PAGES FOR CURRENT FRAME
	RH(J)/ FRAME NUMBER OF TARGET
@@ACCUM T3,T4
@@EXIT	NON-SKIP IF NO ABSOLUTE ACCESS OVER TARGET FRAME
	SKIP IF HAVE SOME LEVEL OF ACCESS WITH
	P4/FAST RIGHTS ADDRESS,SLOW RIGHTS ADDRESS
	RIGHTS ARE STORED ON THE STACK. POPJ OR CPOPJ1 WILL
	RETURN AND TAKE STUFF BACK OFF STACK.
@@;
ABSAUN==1B18			;SIGN BIT IS SAME AUN
ABSGAN==1B19			;SAME GAN
ABSNZA==1B20			;SET IF ANY BITS ARE SEEN AT ALL.

IFN <<ABSAUN!ABSGAN!ABSNZA>&<PVACTS!PVTYMP>>,<PRINTX ABSACC FLAGS MUST BE DIFFERENT THAN PVACTS AND PVTYMP
QQQQQQ>

ABSACC:	PUSH	P,T1		;CALLER CANNOT HAVE THEM ON STACK SO
	PUSH	P,T2		;WE HAVE TO SAVE THEM
	MOVSI	P4,1(P)		;THIS IS WHERE RIGHTS WILL BE RETURNED
	HRRI	P4,2(P)		; IN FAST,,SLOW FORMAT

	MOVE	T4,%UPT+UPTJOB	;GET CALLER'S FRAME NUMBER
	HRRZ	T3,JBTPRV(T4)	;GET JBTPRV FOR CALLER
	ANDI	T3,PVACTS!PVTYMP ;JUST ACT SUPER AND TYMSHARE PROPRIETARY
	MOVE	T2,JBTAUN(T4)	;GET CALLERS AUN
	XOR	T2,JBTAUN(J)	;XOR WITH TARGET FRAME'S AUN
	JUMPE	T2,[TRO T3,ABSAUN ;SAME AUN, MARK THE FLAG IN T3
		    JRST ABSAC0]  ;AND GO
	TLNE	T2,-1		;SAME GAN?
	JRST	[TRZ T3,PVACTS	;NOT ACCT SUPER FOR THIS TARGET
		 JRST ABSAC0]
	TRO	T3,ABSGAN	;FLAG THAT ITS SAME GAN, MAY HAVE ACCESS
				;AND LEAVE PVACTS ON IN RH(T3).
ABSAC0:	MOVSI	T1,-<.ARSIZ+FARSIZ> ;AOBJN POINTER
	HLL	T3,JBTLIC(T4)	;GET LICENSE BITS
	SETZ	T2,		;CLEAR OUT T2 FOR FIRST TIME
;NOW CHECK THE LICENSES AND OR THE ACCESS RIGHTS INTO T2
; FOR EACH MONITOR ACCESS RIGHTS WORD.

ABSAC1:	TLNE	T3,LICWCR	;WRITE CORE
	IOR	T2,WCATAB(T1)	;YES, GET THOSE BITS
	TLNE	T3,LICSPY	;READ CORE?
	IOR	T2,RCATAB(T1)	;YES
	TLNE	T3,LICJAL	;JACCT-LOGINN LICENSE?
	IOR	T2,JALTAB(T1)	;YES.
	TLNE	T3,LICSYS	;SYSTAT?
	IOR	T2,SYSTAB(T1)	;YES
	TRNE	T3,ABSAUN!PVACTS ;ACCT SUPERVISOR OR SAME AUN?
	IOR	T2,AUNTAB(T1)	;YES.
	TRNE	T3,PVTYMP	;TMSHARE PROPRIETARY?
	IOR	T2,TYPTAB(T1)	;YES

	PUSH	P,T2		;END OF CHECKS, PUSH RESULTANT WORD
	TDZE	T2,T2		;CLEAR T2 AND SKIP IF NO BITS WERE TURNED ON
	TRO	T3,ABSNZA	;REMEMBER THAT CALLER HAS SOME ACCESS.
	AOBJN	T1,ABSAC1	;AND GO FOR NEXT WORD.
	MOVE	T2,-<.ARSIZ+FARSIZ>(P) ;GET T2 AND T1 BACK FOR
	MOVE	T1,-<.ARSIZ+FARSIZ>-1(P) ;CALLER
	TRNN	T3,ABSNZA	;SKIP IF WE SAW SOME RIGHTS
	JRST	[SUB P,[.ARSIZ+FARSIZ+2,,.ARSIZ+FARSIZ+2]
		 POPJ P,]	;NO, GET STUFF OFF STACK AND GIVE ERROR RETURN.
	AOS	-<.ARSIZ+FARSIZ>-2(P)	;SKIP RETURN TO CALLER
	PUSHJ	P,@-<.ARSIZ+FARSIZ>-2(P) ;CALL THE CALLER
	  SKIPA			;NON-SKIP TO CALLER'S CALLER
	AOS	-<.ARSIZ+FARSIZ>-2-1(P) ;SKIP TO CALLER'S CALLER
	SUB	P,[.ARSIZ+FARSIZ+3,,.ARSIZ+FARSIZ+3] ;GET STUFF OFF STACK
	POPJ	P,		;AND RETURN TO CALLER'S CALLER.
;ROUTINE TO DISPATCH ACCORDING TO FD TYPE.
; TAKES FD IN P4, TABLE ADDRESS IN T4. SMASHES T3 AND T4.
; CALLED EITHER WITH PJRST OR PUSHJ. IF BAD FRAME DESCRIPTOR,
; RETURNS WITH P3 = ERROR CODE.
; TABLE FORMAT IS EIGHT WORDS, ONE FOR EACH FD TYPE, FOLLOWED
; BY 3 WORDS, ONE FOR EACH FAMILY TYPE.
; CHANGES P4 IF TYPE IS "OTHER FRAME" TO THE ACTUAL DESCRIPTOR.


FDDSP:	LDB	T3,[POINT 3,P4,20] ;GET TYPE FROM FD
	CAIN	T3,.FDOTF_-^D15	;IS IT OTHER FRAME?
	JRST	[MOVE P4,%UPT+UPTOFD ;SETUP P4 TO "OTHER FRAME"
		 JRST FDDSP]	;AND DO DISPATCH AGAIN.
	CAIN	T3,.FDFAM_-^D15	;FAMILY TYPE?
	JRST	[LDB T3,[POINT 3,P4,23] ;GET FAMILY TYPE
		 CAILE T3,.FMMAX_-^D12
		 PJRST FEBFD
		 ADDI T3,10(T4) ;GET ADDRESS OF INSTRUCTION
		 JRST .+2]	;AND REJOIN
	ADDI	T3,(T4)		;NOT FAMILY TYPE, GET ADDRESS OF INSTRUCTION
	XCT	(T3)		;DO THE INSTRUCTION
	JRST	CPOPJ1		;IN CASE CALLER CALLED WITH PUSHJ
SUBTTL BIT MAP TRANSLATION ROUTINES
COMMENT ;@@SUBROUTINE FNDOFS
@@PURPOSE FIND TABLE ENTRY COVERING NUMBER IN T1.
@@ENTRY	T1/NUMBER
	T2/END ADDRESS OF TABLE,,START OF TABLE
SEE COMMENT AT U2MACT AND M2UACT DEFINITIONS FOR FORMAT OF TABLE.
@@ACCUM T1-T4
@@RESTRICTIONS CALLER MUST NOT CALL WITH NUMBER IN T1 LESS THAN
LH OF FIRST TABLE ENTRY.
@@EXIT ALWAYS NON-SKIP, RH OF T2 CONTAINS ADDRESS OF TABLE ENTRY.
@@;

EXTERNAL CPOPJ

FNDOFS:	HLRZ	T3,T2		;GET END ADDRESS
	SUBI	T3,(T2)		;GET LENGTH-1
	JUMPLE	T3,CPOPJ	;IF START=END, FOUND IT.
				;IF -VE, NO ENTRY IN TABLE FOR IT.
	ADDI	T3,1+1		;GET LENGTH, CAUSE LSH TO ROUND UP.
	LSH	T3,-1		;(LENGTH)/2
	ADDI	T3,(T2)		;GET ADDRESS OF WORD TO CHECK
	HLRZ	T4,(T3)		;GET STARTING NUMBER
	CAMGE	T1,T4		;SKIP IF IN 2ND HALF OF TABLE
	JRST	FNDOF1		;NO, MUST BE IN FIRST PART
	HRRI	T2,(T3)		;USE THIS WORD AS NEW START
	JRST	FNDOFS
FNDOF1:	HRLI	T2,-1(T3)	;THIS WORD IS PAST, NEW END IS THIS -1.
	JRST	FNDOFS
COMMENT #@@SUBROUTINE ACRPTR
@@PURPOSE HELP CONVERT BETWEEN USER AND MONITOR ACCESS RIGHT BIT
MAPS BY PROVIDING BYTE POINTERS
@@ENTRY U/ AOBJN POINTER TO TRANSLATION TABLE
	JSP F,ACRPTR	;FIRST TIME.
	JRST	(M)	;FOR NEXT POINTER.
CALLER MUST PRESERVE CONTENTS OF P1,P2,U,M UNTIL FINISHED.
@@ACCUM T1-T4,P1-P2
@@EXIT RETURNS TO JSP + 2 WITH NEXT FROM BYTE PTR IN T3, TO POINTER IN T4.
	RETURNS TO JSP + 1 WHEN NO MORE POINTERS.
@@#

ACRPTR:	MOVS	P1,(U)		;P1 HAS DEST START,,SOURCE START
	JUMPL	P1,(F)		;IF NO MORE, RETURN.
	TLNE	P1,200000	;UNASSIGNED RANGE?
	AOJA	U,ACRPTR	;YES, IGNORE THAT POINTER.
	HLRZ	P2,1(U)		;P2 GETS END SOURCE BIT-1.
ACRPT0:	MOVEI	M,ACRNXW	;ASSUME WILL NOT SPLIT ACROSS WORDS.
	HRRZ	T1,P1		;GET START BIT NUMBER
	MOVEI	T3,-1(P2)	;GET END BIT IN T3
	IDIVI	T1,^D36		;GET WORD NUMBER
	IDIVI	T3,^D36		;T3/WORD T4/BIT IN WORD
	CAMN	T1,T3		;IN SAME WORD?
	JRST	ACRPT2		;YES, GO SEE DISPOSITION OF DESTINATION BYTE
	MOVEI	M,ACRPT0	;CONTINUE WITH CURRENT ENTRY NEXT TIME.
	MOVEI	T4,^D35		;AND LAST BIT WITHIN THAT WORD.
ACRPT2:	SUBI	T4,-1(T2)	;GET JUNK,,SOURCE BYTE SIZE IN T4.
	ADDI	P1,(T4)		;P1 GETS NEXT BIT NUMBER TO DO, IF ANY.
;HERE WITH T1 WORD NUMBER FOR SOURCE BYTE, T4 SOURCE BYTE SIZE.
; AND T2 SOURCE START BIT.

ACRDST:	HRL	T1,T4		;GET IN LH OF T1 FOR COMPRESSION
	PUSH	P,T1		;SAVE SOURCE: SIZE,,WORD NUMBER
	PUSH	P,T2		;SAVE SOURCE: START BIT
	MOVEI	T3,-1(T4)	;GET SOURCE BYTE SIZE-1 IN T3
	HLRZ	T1,P1		;GET START DEST BIT NUMBER IN TABLE
	ADD	T3,T1		;GET END DEST BIT NUMBER IN TABLE IN T3
	IDIVI	T1,^D36		;GET WORD IN T1, BIT POSITION IN T2 FOR START BIT
	IDIVI	T3,^D36		;SAME FOR T3, T4 FOR END BIT
	CAMN	T1,T3		;START AND END IN SAME WORD?
	JRST	ACRDS1		;YES
				;C(T3) MUST BE C(T1)+1 BECAUSE BYTE
				; SIZE IS GUARANTEED TO BE LESS THAN 36.
	MOVEI	M,ACRPT0	;CONTINUE WITH NEXT PART OF ENTRY NEXT TIME.
	MOVEI	T4,^D36		;GET READY TO COMPUTE
	SUB	T4,T2		;DEST SIZE IN T4
	HLRZ	T3,-1(P)	;GET OLD SOURCE BYTE SIZE
	HRLM	T4,-1(P)	;STORE NEW SOURCE AND DEST BYTE SIZE..
	SUB	T3,T4		;GET HOW MANY BITS WE COULDN'T DO
	SUBI	P1,(T3)		;UPDATE SOURCE BIT NUMBER
	MOVSI	T3,(T4)		;GET SIZE,,0
	ADD	P1,T3		;UPDATE DEST BIT NUMBER IN LH P1
	JRST	ACRDSS		;AND GO MAKE BYTE POINTERS.

ACRDS1:	SUBI	T4,-1(T2)	;GET JUNK,,DEST SIZE
	HRLZ	T3,T4		;GET SIZE,,0
	ADD	P1,T3		;UPDATE DEST BIT NUMBER IN CASE SOURCE BYTE IS SPLIT
				; AND FALL INTO ACRDSS.
; SIZE,,SOURCE WORD AT -1(P), START SOURCE BIT AT (P)
; T1/ DEST WORD NUMBER T2/START DEST BIT.
; T4/JUNK,,SIZE.
; WORD AND START BIT FOR DESTINATION.
; BYTE SIZE HERE MUST BE SAME FOR SOURCE AND DESTINATION.

ACRDSS:	HRLZ	T3,T4		;GET SIZE IN LH FOR BYTE POINTER
	EXCH	T3,T4		;GET JJJJSS,,0 IN T4, 0,,SS IN T3
	LSH	T4,6		;GET JJSS00,,0 IN T4
	HRR	T4,T1		;GET WORD NUMBER IN RH (T4) - THIS WILL BE DEST POINTER
				; (JJSS00,,WWWWWW)
	MOVEI	T1,^D36		;COMPUTE P FOR DEST BYTE POINTER
	SUB	T1,T2		;36-START
	SUB	T1,T3		;36-START-SIZE = 35-<START+SIZE-1> = P
	DPB	T1,[POINT 6,T4,5] ;PUT IN BYTE POINTER FOR DES.
				;(PPSS00,,WWWWWW)
	POP	P,T2		;GET SOURCE START BIT
	POP	P,T1		;GET SIZE,,WORD
	HRL	T3,T1		;SAVE WORD NUMBER IN LH OF T3 - SIZE STILL IN LH OF T3.
	MOVEI	T1,^D36
	SUB	T1,T2		;GET 36-START
	SUBI	T1,(T3)		;GET 36-START-SIZE = 35-<START+SIZE-1> = P
	HLRZS	T3		;GET WORD NUMBER IN RH
	HLL	T3,T4		;GET LH OF POINTER (S FIELD) FROM DEST.
	DPB	T1,[POINT 6,T3,5] ;PUT "P" FIELD FOR SOURCE BYTE IN ON TOP OF ONE FOR DES.
	JRST	1(F)		;RETURN WITH BYTE POINTERS.
ACRNXW:	AOJA	U,ACRPTR	;HERE THRU (M) WHEN POSSIBLY MODIFIED
				; TABLE ENTRIES IN P1 AND P2 DESCRIBE
				; SOURCE AND DEST BYTES THAT AREN'T SPLIT ACROSS WORDS
;DEFINE ACCESS BITS USED FOR CHECKING WHEN A JOB HAS RC BUT NOT WC
; LICENSE.


;MACRO TO GENERATE BIT TABLES FOR ARMAC FIELDS


DEFINE BITGEN(F,V)<IRP V,<IRP F,<IFIDN <'F> <'V> <ZZ==ZZ!<1>B<ZZ1>>>>
ZZ1==ZZ1+1
IFE ZZ1-^D36,<ZZ
ZZ==0
ZZ1==0>>;END BITGEN MACRO DEFINITION

DEFINE ARDO<ZZ==0
ZZ1==0
ARMAC
IFN <ZZ1-^D36>,<ZZ>	;;PLACE FINAL WORD IN TABLE
>;END ARDO MACRO DEFINITION

DEFINE ARBITS(ARG)<ARCALL(<BITGEN('ARG)>,ARDO)>


;GENERATE BIT TABLES FOR VARIOUS LICENSES

WCATAB:	ARBITS(<<LIC>,WC>)

RCATAB:	ARBITS(<<LIC>,RC>)

SYSTAB:	ARBITS(<<LIC>,SY>)

TYPTAB:	ARBITS(<<LIC>,TP>)

JALTAB:	ARBITS(<<LIC>,JL>)

AUNTAB:	ARBITS(<<LIC>,AUN>)

;GENERATE BIT TABLE FOR EXECUTE ONLY MAX FRAME RIGTS

EXOMFR::ARBITS(<RWX,X>)

;GENERATE BIT TABLE FOR SWR FILES WITHOUT WRITE ACCESS

RDXMFR::ARBITS(<RWX,<X,R>>)

;GENERATE BIT TABLE FOR NON-LICENSED NON-SWR FILES, SWR FILES WITH WRITE ACCESS

ALLMFR::ARBITS(<RWX,<X,R,W>>)

NULMFR::REPEAT .ARSIZ+FARSIZ,<Z>
COMMENT \
GENERATE TABLES TO TRANSLATE BETWEEN USER ACCESS RIGHTS CODES
 AND MONITOR ACCESS RIGHTS CODES. TABLES ARE ALSO USED TO
 TRANSLATE BETWEEN USER ACCESS RIGHTS BIT MAPS AND THE MONITOR
 ACCESS RIGHTS BIT MAPS.

FORMAT OF TABLE IS:

	XWD	<FROM CODE>,,<TO CODE>
	XWD	<FROM CODE>,,<TO CODE>
		.
		.
	XWD	<FROM CODE>,,200000	;SAYS UNASSIGNED BIT RANGE
		.
		.
	XWD	<FROM CODE>,,-1 ;LAST ENTRY.
WHERE <FROM CODE> IS MONOTONICALLY INCREASING AS THE TABLE ADDRESSES
INCREASE (SOAS TO BE ABLE TO DO A BINARY SEARCH ON THE TABLE).
THE ROUTINE FNDOFS TAKES THE START AND END ADDRESSES
OF THESE TABLES AS AN ARGUMENT, AND WILL FIND THE ENTRY
THAT COVERS A GIVEN <FROM CODE> ARGUMENT.
\


DEFINE Y(NUM)<
IFN LOFS-<NUM-ZZ>,<;;NEW OFFSET
	IFDEF LASZZ,<LASZZ,,LASZZ+LOFS>
	LOFS==NUM-ZZ
	LASZZ==ZZ>;END IFN LOFS-<ZZ-NUM>
GENUAR(\'NUM)
ZZ==ZZ+1
>;END Y MACRO DEFINITION

DEFINE GENUAR(NUM)<.UA'NUM==ZZ
IFNDEF .UAMAX,<.UAMAX==NUM>
IFL .UAMAX-NUM,<.UAMAX==NUM>>

DEFINE ARDO<
IFNDEF LASZZ,<LOFS==777777	;FORCE MATCH FIRST TIME
ZZ==0
>;END IFNDEF
IFDEF LASZZ,<PURGE LASZZ
LOFS==777777	;FORCE MATCH FIRST TIME
ZZ==^D36>;END IFDEF
ARMAC
IFDEF LASZZ,<LASZZ,,LASZZ+LOFS>
IFL ZZ-^D36,<;IF FAST RIGHTS AND UNASSIGNED BITS (LESS THAN ALL 36)
	ZZ,,200000	;GENERATE UNASSIGNED TABLE ENTRY FOR REST OF THE BITS.
			;(ZZ HAS BEEN INCREMENTED PAST LAST BIT ALREADY)
>;END IFL ZZ-^D35
>;END ARDO MACRO DEFINITION
IFDEF LASZZ,<PURGE LASZZ>

M2UACT:ARCALL(<Y('NUM)>,ARDO)
	M2UACE=.-1		;LAST ADDRESS IN TABLE
	ZZ,,-1

IFDEF LASZZ,<PURGE LASZZ>

DEFINE CALUAR(NUM)<Y(.UA'NUM)
PURGE .UA'NUM>
DEFINE GENUAR(NUM)<>

U2MACT::
ZZ==0
LOFS==777777	;FORCE MATCH FIRST TIME
REPEAT .UAMAX+1,<
CALUAR(\ZZ)
>;END REPEAT .UAMAX+1
IFDEF LASZZ,<LASZZ,,LASZZ+LOFS>			;GET THE LAST WORD.
U2MACE=.-1			;LAST ADDRESS IN TABLE
	ZZ,,-1
SUBTTL ERROR CODES
;ERROR CODE GENERATOR. ALL ROUTINES THAT DEAL WITH FRAMES
; USE THE ERROR CODES DEFINED HERE.
; THE VUUOS THAT NEED TO RETURN THESE CODES RETURN THEM
; IN 0-5, WITH "HANDLE ERROR" CODE FOR THAT PARTICULAR
; UUO IN 18-35.
; SUB ERROR CODES ARE GUARANTEED TO BE NON-ZERO FOR EASY EXISTENCE
; CHECKING.

;SEE S.MAC FOR FDEERP MACRO TO GENERATE BYTE POINTER TO PUT
; SUB ERROR CODE IN VUUO ERROR RETURN AC.


DEFINE FRMERS<XALL
X (NOH)		;;(1) NO HANDLE IN SLOT
X (BDI)		;;(2) UNMATCHING UNIVERSAL ID NUMBER
X (NRT)		;;(3) NO RIGHTS TO DO OPERATION
X (BDF)		;;(4) BAD FRAME NUMBER
X (NLC)		;;(5) NOT ENOUGH LICENSE
X (UND)		;;(6) UNDEFINED FRAME DESCRIPTOR TYPE
X (NCH)		;;(7) FD SAID CHILD BUT GAVE NON-CHILD FRAME NUMBER.
X (CLP)		;;(10) CAN'T LOCK CONTEXT PAGES (FD2UPX)
X (BAR)		;;(11) BAD ACCESS RIGHTS CODE
X (NPR)		;;(12) ORPHAN ASKED FOR ITS PARENT
X (BFD)		;;(13) BAD FAMILY DISPATCH TYPE
X (BDH)		;;(14) BAD HANDLE INDEX NUMBER IN FD
X (BFN)		;;(15) BAD FUNCTION CODE TO FRMOP
X (ADB)		;;(16) ADDRESS FOUND BAD (REPLICATE FAILED) IN .FO?VA
X (IOE)		;;(17) PAGE I/O ERROR IN FRMRVM/FRMWVM
X (ALR)		;;(20) ATTEMPT TO START A RUNNING FRAME
X (ALH)		;;(21) ATTEMPT TO HALT NON-RUNNING FRAME
X (CSJ)		;;(22) ATTEMPT TO HALT FRAME WITH JACCT ON
X (FHE)		;;(23) HANDLE DESCRIPTOR EXPECTED, NOT GIVEN
X (FHU)		;;(24) HANDLE (INDEX ALREADY) USED
X (NFH)		;;(25) NO HANDLE INDICES LEFT.
X (BCN)		;;(26) BAD COUNT
X (BTN)		;;(27) BAD TABLE NUMBER
X (BHT)		;;(30) BAD HANDLE TYPE
X (CCH)		;;(31) CAN'T CREATE HANDLE (ACCESS FAILURE)
X (BSV)		;;(32) BAD START VECTOR OFFSET
X (CII)		;;(33) ATTEMPT TO MAKE CHILD ITS OWN INFERIOR IN TREE
X (CCF)		;;(34) CAN'T CONTINUE FRAME
X (CJF)		;;(35) CAN'T JUMP TO FRAME (PC IS NOT USER MODE)
X (RNE)		;;(36) RIGHTS NOT EQUAL
X (ILC)		;;(37) Illegal Command
SALL>;END FRMERS MACRO DEFINITIONS

DEFINE X(ERR)<
XP <FE'ERR'%>,ZZ
FE'ERR'::JSP	P3,FEERR
ZZ==ZZ+1
>
ZZ==1
FEERS:
FRMERS
FEERR:	MOVEI	P3,-FEERS(P3)
	POPJ	P,

DEFINE X(ERR)<
FEW'ERR'::JSP P3,FEWERR
>
FEWERS:	FRMERS
FEWERR:	MOVEI	P3,-FEWERS(P3)
	UMOVEM	P3,(W)
	POPJ	P,		;STORE IN USER AC AND RETURN.

	$END	(FRM)		;End of FRMSER (FRMLIT: FRMEND:)
   
@p