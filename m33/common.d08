TITLE COMMON - MONITOR COMMON DATA AREA AND CONFIGURATION DEFINITION - V534
SUBTTL PART 3 COMMON.MAC - T. HASTINGS/CMF/TL/CHW/AF/TW/PFC/RCC/PH   TS  29 OCT 70
  XP VCOMMN,534		;PUT VERSION NUMBER IN GLOB AND LOADER STORAGE MAP

;*;	STOPCD(,ENTRY,COMMON)	;This macro is expanded at relocatable address
PRINTF([CPU status variables at .CPSLF:: need to be defined by a macro])

;Definitions from CONF##.MAC
  ND TIMZON,^D<-8>		;Default to Pacific Standard Time
IFCPU(<KI,KL>),<
  ND DISKS,2*8			;Default 2 strings of disks
  ND PRINTS,1			;Default 1 lineprinter
  ND TAPES,4			;Default 4 tape drives
  ND FTAUN,TAPES
    >  ;End KI,KL
IFCPU(F3),<
  ND DISKS,4			;Default 4 disk drives
  ND PRINTS,0			;Default no lineprinter
  ND TAPES,1			;Default 1 tape drive
  ND MAGUN,TAPES
    >  ;End F3
IFCPU(KS),<
  ND DISKS,4			;Default 4 disk drives
  ND PRINTS,1			;Default 1 lineprinter
  ND TAPES,1			;Default 1 tape drive, some have 2
  ND MAGUN,TAPES
  ND RM0UN,DISKS
    >  ;End KS
IFDEF PORTS,<ND RPORTN,PORTS>	;Number of TYMNET lines
IFDEF PTYS, <ND PPORTN,PTYS*2>	;2 TTY lines per PTY pair
IFDEF JOBS, <ND JOBN,JOBS>	;Number of jobs
  ND LPTN,PRINTS		;Number of line printers

REPEAT 0, <
;THE COMMON SUBPROGRAM CONSISTS OF 3 FILES ASSEMBLED TOGETHER AS ONE SUBPROGRAM:
  1. S.MAC - THE USUAL SYSTEM SYMBOL DEFINITIONS ASSEMBLED WITH
	EVERY MONITOR SUBPROGRAM
  2. CONFIG.MAC - THE CONFIGURATION DEFINITION FILE GENERATED BY THE
	CONFIGURATION PROGRAM (MONGEN) OR BY AN EDITOR (SEE ABOVE)
  3. COMMON.MAC - THE REST OF THIS PROGRAM WHICH IS THE SAME SOURCE FOR
	ALL CONFIGURATIONS.  HOWEVER, THE ASSEMBLIES ARE CONDITIONED BY
	SYMBOLS AND MACROS DEFINED IN 2.

	THE FOLLOWING SYMBOLS AND TABLES ARE GENERATED BELOW:

	A. MONITOR STARTUP LOCATIONS (140-147), HENCE LOAD THIS FIRST.
	B. JOB TABLES - LENGTH DEPENDENT ON MAXIMUM NUMBER OF JOBS ALLOWED
	C. ALL VARIABLE STORAGE NOT ASSOCIATED WITH A PARTICULAR DEVICE
	D. COMMON SUBROUTINE RETURNS
	E. COMMON BYTE POINTERS
	F. TABLE OF SERVICE ROUTINE INTERRUPT LOCS TO BE LINKED BY ONCE ONLY CODE
	G. TABLE OF DEVICE DATA BLOCK ADDRESSES AND NUMBER TO BE USED BY ONCE TO
		LINK THEM TOGETHER AND GENERATE MULTIPLE COPIES.
        H. ASSIGNMENT OF PI CHANNELS
	I. PI CHANNEL SAVE AND RESTORE ROUTINES
	J. M TRAP LOCATIONS 40/41, 60/61
	K. SYSTEM CRASH STOP CONI'S.
	L. CONFIGURATION DEPENDENT CODE FOR CERTAIN DEVICES AND THE SWAPPER.

LEVEL D DISK SERVICE PARAMETERS:

  ALL SYMBOLS AND LOCATIONS ARE IN A SEPARATE FILE CALLED
  COMMOD.MAC WHICH IS ALSO ASSEMBLED WITH S AND CONFIG (BUT NOT WITH FEATURS FILES).
  THE SEPARATE FILE IS FOR TWO REASONS:
    1.  ANTICIPATING MULTIPROCESSING SYSTEMS WHICH SHARE DISKS AND 1 16K MEMORY
        (THE DATA MUST BE IN THE COMMON MEMORY)
    2.  ELIMINATE THE NEED TO ASSEMBLE COMMOD IF NOT A DISK SYSTEM
        (COMMOD.MAC TAKES LOTS OF CORE FOR ITS COMPLICATED MACROS)
  HOWEVER, THE TWO FILES MAY BE ASSEMBLED TOGETHER IF DESIRED.
  TO DO THIS, COMMON.MAC MUST PRECEED COMMOD.MAC, AND SYMBOL FTCMBTH MUST BE DEFINED.
  THUS, A COMMAND STRING WOULD BE

	.R MACRO
	*COMMON,COMMON/C_TTY:,DSK:S,CONFIG,COMMON,COMMOD
	FTCMBTH==0
	^Z

	END OF PASS 1

	FTCMBTH==0
	^Z
>
;THE FOLLOWING STANDARD SYMBOLS CAN BE SUPERCEDED BY A CUSTOMER HAVING
; PREVIOUSLY DEFINED THEM ON THE CONFIG.MAC FILE

NDL LISTSN,1	;FORCE THE S.MAC FILE TO BE LISTED ON THE FRONT OF
		; COMMON (UNLESS LISTSN DEFINED TO BE 0 WITH MONGEN)

;THESE SYMBOLS DEFINE THE VALUES OF VERSION FROM MONGEN

	A00CLH=:BYTE(9)'P',^D035 ;Change this for P036
EXTERN	A00CVN			;This is defined in COMTXT based on CNFN##.MAC
EXTERN	A00EDT			;Defined in COMTXT, incremented by MONDOC

IFNDEF	A00CLH,<AXXWHO=0;>AXXWHO==2 ;NONZERO IF CUSTOMER MODIFIED MONITOR
ND	A00CLH,0		;CUSTOMER LH (%CNVER) (18-BITS)
;;	A00CVN,0		;CUSTOMER VERSION NUMBER (36-BITS)

ND	A00MVN,502		;MAJOR VERSION OF MONITOR--UPDATED AT
				; START OF DEVELOPMENT CYCLE (9-BITS)
ND	A00SVN,0		;SOUP NUMBER--UPDATED AT START
				; OF EACH SOUP DEVELOPMENT CYCLE (6-BITS)
;;	A00MCO,^D1000		;HIGHEST MCO IN THIS LOAD (18-BITS)
				; 7.01 has A00MVN=701, A00MCO=^D 9337
				; 7.03 has A00MVN=703, A00MCO=^D12834
ND	A00DLN,0		;DEC LOAD NUMBER (6-BITS)
				; SET TO ZERO FOR ANY RELEASE, ELSE
				; 1-7 IF SOUP, 10-77 IF DEVELOPMENT
ND	A00WHO,AXXWHO		;DEC LAST EDITED (3-BITS)

AXXVER==<BYTE(18)A00CLH(12)A00MVN-IFE A00SVN,<IFN A00DLN,<1>>(6)IFE A00SVN,<A00DLN>>
				;Note: CONFIG item 34 is not %CNVER in TYMCOM-X
ND	A00VER,AXXVER		;A00VER is in DEC's  %CNVER (GETTAB 34,,11)
				;A00CVN is stored in %CNCVN (GETTAB 70,,11)
A00DEC==<BYTE(3)A00WHO(9)A00MVN(6)A00SVN>_-^D18	;LH  %CNDVN (GETTAB 71,,11)
				;RH of %CNDVN is A00EDT (defined in COMTXT.MAC)
IFNCPU(F3),<ND DEFDEB,DF.RJE!DF.RDC>	;Get crash dump on JOB and DEBUG stopcodes
ND DEFDEB,0		;Default setting for DEBUGF
ND DEFBPT,0		;Default setting for SET EDDT ON/OFF
IF2,<IFN DEFDEB&<DF.RJE!DF.RDC>,<PRINTX [Will reload on JOB/DEBUG stopcodes]>>

				;STANDARD MAG TAPE DENSITY
IFNDEF STDENS, <XP STDENS,3>	;STANDARD == ODD PARITY ("BINARY" MODE) AT 800 BPI
				;STDENS,D
				;D=1 (200 BPI), OR D=2 (556 BPI), OR D=3 (800 BPI)

				;NUMBER OF CLOCK TICKS (JIFFIES) PER SECOND

				;NUMBER OF NANO-SECONDS PER MEMORY CYCLE
IFNDEF NSPMEM, <XP NSPMEM,^D1000>	;STANDARD == 1000 NANO-SECONDS PER MEMORY CYCLE



				;NUMBER OF TIMES TO TRY ON DECTAPE ERRORS
IFNDEF DTTRY, <XP DTTRY,4>	;STANDARD == 4 TRIES

				;SIZE OF MAGTAPE RECORDS (DATA WORDS IN BUFFER)
IFNDEF MTSIZ, <XP MTSIZ,^D128>	;STANDARD == 128 WORDS PER BUFFER

				;SIZE OF LPT BUFFER (NUMBER OF DATA WORDS+2)
IFNDEF LPTSIZ, <XP LPTSIZ,^D24+2>	;STANDARD == 24 WORDS PER LPT BUFFER

				;MAXIMUM NUMBER OF CONSECUTIVE DECTAPE BLOCKS TO BE
				; SEARCHED BEFORE RESCHEDULING IF ANOTHER JOB IS
				; WAITING TO USE THE DECTAPE CONTROL.
IFNDEF BLKQNT, <XP BLKQNT,^D50>	;STANDARD == 50 DECTAPE BLOCKS SEARCHED (3 SECS.)

IFNDEF M.SQTA,<XP M.SQTA,^D8> ;STANDARD == ^D8 PAGE TO SWAP IN AT, LIMIT SWAP RATE. (obsolete /AAA)
				; A TIME.
IFNDEF M.IQTA,<XP M.IQTA,0>;STANDARD == ONE I/O PGE FOR EVERY FOURTH JOB. (never implemented /AAA)
				; (ZERO UNTIL BUG IS FIXED)
IFNDEF M.SBSZ,<XP M.SBSZ,0>	;SNOOP BUFFER SIZE. STANDARD=NONE
IFNDEF MAXNBP,<XP MAXNBP,0>	;MAX NUMBER OF SNOOP BREAKPOINTS, DEFAULT 0

IFNDEF AGESIZ,<XP AGESIZ,^D3>	;STANDARD = 3 BITS PER AGES CELL

IFNDEF SHRFPG,<XP SHRFPG,0>	;EXPECTED SHARED FILE PAGES..SET
				;NON-ZERO IN CONFIG FOR SYSTEMS WHOSE
				;LOADS INCLUDE ALOT OF FILE PAGE SHARING. /AAA

IFNDEF FHIN,<XP FHIN,^D22>	;STANDARD = 22 FRAME HANDLE SLOTS PER FRAME
IFNDEF OPNFPF,<XP OPNFPF,^D10>	;STANDARD = 10 OPEN FILES/FRAME AVERAGE ESTIMATE

DEVLSD==DEVINT+1		;Length of DDB with short dispatch
DEVLLD==DEVPPN+1		;Length of DDB wwth long dispatch (DSK,DECtape)
MONORG==0			;Monitor does not have a HISEG


;DEVICE CODES

SAX0==274		;DEVICE CODE FOR FIRST SA-10 IBM DISK/TAPE CONTROLLER
SAX1==400		;            FOR SECOND SA-10
FHD1==170		;DEVICE CODE FOR FIRST FIXED HEAD CONTROLLER
FHD2==174		;            FOR SECOND FIXED HEAD CONTROLLER
DPC1==250		;DEVICE CODE FOR FIRST DISK PACK CONTROLLER (RP02)
DPC2==254		;            FOR SECOND DISK PACK CONTROLLER
LPT1==124		;DEVICE CODE FOR FIRST LINE PRINTER
LPT2==234		;            FOR SECOND LINE PRINTER
LPT3==230		;            FOR THIRD LINE PRINTER
LP0==LPT1
LP1==LPT2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	DEFINE SYSDEV
<	SIXBIT	"DSK">
	DEFINE SYSNAM
<IFNDEF SYSX0L,<EXTERNAL SYSX0L,SYSX0R,SYSX1L,SYSX1R,SYSX2L
	EXTERNAL SYSX2R,SYSX3L,SYSX3R,SYSX4L,SYSX4R>
	SYSX0L,,SYSX0R
	SYSX1L,,SYSX1R
	SYSX2L,,SYSX2R
	SYSX3L,,SYSX3R
	SYSX4L,,SYSX4R>

	DEFINE SYSDAT
<IFNDEF SYSX5L,<EXTERNAL SYSX5L,SYSX5R,SYSX6L,SYSX6R>
	SYSX5L,,SYSX5R
	SYSX6L,,SYSX6R>

	DEFINE SYSVER
<IFNDEF SYSX7L,<EXTERNAL SYSX7L,SYSX7R>
        SYSX7L,,SYSX7R>
XP DSKN,1		;SYSTEM HAS DISK DRIVES
XP PMEMSZ,^D512
IFCPU(<KI,KL>),<
;*;IFNDEF CHNN,<XP CHNN,0>
  IFNDEF SAXN,<XP SAXN,1>
  > ; End IFCPU(<KI,KL>)
IFCPU(<KS,F3>),<
;*;IFNDEF CHNN,<XP CHNN,1>
  IFNDEF SAXN,<XP SAXN,0>
  > ; End IFCPU(<KS,F3>)

IFNCPU(F3),<ND APXN,0>
IFCPU (F3),<ND APXN,1>
IFCPU(<KI,KL>),<ND MAGN,0>
IFCPU(<KS,F3>),<ND MAGN,1>
IFNDEF RA10N,<XP RA10N,0>
IFNDEF RP10N,<XP RP10N,0>
IFNDEF RD10N,<XP RD10N,0>

IFCPU(KS),<
  XP LPRUN,0
IFN LPTN,<XP LPRUN,1>	;Set LPRUN=1 if one or more LPTs
  XP LPRVEC,754
> ;End IFCPU(KS)

IFCPU (KI),<
  IFNDEF PTRN,<PTRN==1>
  IFNDEF PTPN,<XP PTPN,1> >
IFNCPU(KI),<
  IFNDEF PTRN,<PTRN==0>		;NOT GLOBAL BECAUSE OF DSKSER USE
  IFNDEF PTPN,<XP PTPN,0> >
IFNDEF PLTN,<XP PLTN,0>
IFNDEF CDRN,<XP CDRN,0>
IFNDEF CR10N,<XP CR10N,0>

IFNDEF COREN,<XP COREN,^D8>

COMMENT ! FREE CORE ALLOCATION CALCULATIONS.  ALLOCATE FOR
	DSK DDB'S, BLOCK IO BUFFERS, SPT SECTIONS, ETC.
!

INTERNAL BIOCOR
EXTERNAL DDBCOR			;NUMBER FREECORE BLOCKS PER DDB
EXTERNAL SPTNME,SPTSIZ
XP CORSIZ,4		;NO. OF WORDS IN MONITOR FREE CORE BLOCKS
XP BIOSIZ,<^D6+^D100>	;BLOCK I/O BUFFER SIZE
			;(HEADER + DATA AREA)
XP BIONUM,^D10		;NO. OF PORTS CONFIGURED FOR BLOCK I/O
BIOCOR==<BIOSIZ+CORSIZ-1>/CORSIZ  ;NO. OF 4WD BLOCKS FOR BIO BUFFER.
IFCPU(KI),<ND FCWDS,140000>	;Limit monitor FRECOR allocation
IFCPU(F3),<ND FCWDS,100000>	;Limit monitor FRECOR allocation
IFCPU(KS),<ND FCWDS,040000>	;Limit monitor FRECOR allocation
IF2,<
IFDEF FCWDS,<
DDBWDS==OPNFPF*DDBCOR*CORSIZ	;ESTIMATE OPNFPF DDB'S PER FRAME
EFCWDS==JOBN*DDBWDS
IFL JOBN-6,<EFCWDS==6*DDBWDS>	;PUT FLOOR UNDER FCWDS IF JOBN.LT.6
BIOWDS==<BIOSIZ/2>*BIONUM	;FREECORE NEEDED FOR BLOCK IO BUFFERS
SPTWDS==<SHRFPG/SPTNME>*SPTSIZ	;(VERY) ROUGH EST. OF SPT FREECORE
EFCWDS==EFCWDS+BIOWDS+SPTWDS
;IFL FCWDS-EFCWDS,<PRINTX FCWDS IS SMALLER THAN THE ESTIMATE EFCWDS
;>
>;END IFDEF
ND FCWDS,0			;No limit on KL
>;END IF2

IFNDEF INDPPN,<XP INDPPN,777777>	;NON-ZERO IF CUSTOMER WANTS PROGRAMMER NOS
				; IN PROJECT X TO BE INDEPENDENT OF THOSE IN PROJECT Y

;NOTE--IN ORDER TO RESERVE PI-CHANNELS FOR
;NON-STANDARD USAGE, FOR EACH CHANNEL (SAY N)
;DEFINE SYMBOL UNIQN==1 VIA CONFIG.  FOR
;EXAMPLE, TO RESERVE CHANNEL 4, DEFINE
;UNIQ4==1.


;DEFINE PARAMETERS THAT SPECIFY SIZE OF CORTAB, NUMBER OF BITS PER
;ENTRY, AND BYTE POINTERS FOR CORE ALLOCATION ROUTINES

INTERNAL CTNMCI,CTNBSA,CTNBPW

CTNBPE==1	;NUMBER OF BITS PER ENTRY IN CORTAB
		;MUST EVENLY DIVIDE 36 AND BE 1 OR A POWER OF TWO
CTNMCI==1	;PUT THIS IN CORTAB TO INDICATE A BLOCK IN USE BY MONITOR OR NXM

CTNBPW==^D36/CTNBPE
		;NUMBER OF BYTES/WORD

Z1==0
Z2==CTNBPE

	XLIST
REPEAT Z2/2,<
Z2==Z2/2
IFN Z2,<Z1==Z1+1>
>
	LIST

CTNBSA==Z1	;THE LARGEST POWER OF TWO IN CTNBPE

DEFINE NMCLC (SET,DE,X,U)
<$U==0
IRP U,<IFE X-$U,<SET==DE'U'UN>
	$U=$U+1>>

DEFINE CHNCLC (DE,NUM)
<$UU==0
	REPEAT NUM,<
	NMCLC (XX,DE,\$UU,<A,B,C,D,E,F,G>)
	IFN XX,<ALLKON==ALLKON+1>
	$UU==$UU+1>>

ALLKON==0
	CHNCLC (FH,RD10N)
	CHNCLC (DP,RP10N)
	CHNCLC (MD,RA10N)


;PERFORM TRANSLATION FROM HARDWARE TO SOFTWARE DESIGNATION
; FOR ALL DISK SYMBOLS

	FHDN==RD10N
	DPCN==RP10N
	MDFN==RA10N
SUBTTL	Magic locations in low memory (used by BOOT, CTY, etc)
;*; DPCIOC==22		;CHANNEL ADDRESS FOR RP10 DATA CHANNEL (LEVEL C ONLY)
;*; DPCCCW==DPCIOC+1	;CHANNEL STORE, TERMINATION WORD FOR RP10
;*; MTIOC==24		;CHANNEL ADDRESS FOR TM10B DATA CHANNEL
;*; MTCCW==MTIOC+1	;FINAL CONTROL WORD STORED HERE
;*; RAXIOC==26		;XWD 0,ADDRESS FOR RA-10'S DATA CHANNEL (LEVEL C ONLY)
;*; RAXCCW==RAXIOC+1	;CHANNEL STORE, TERMINATION WORD
;*; RCXIOC==34		;INITIAL CONTROL WORD FOR RC-10'S DATA CHANNEL
;*; RCXCCW==RCXIOC+1	;CHANNEL STORES FINAL CONTROL WORD HERE ON TERMINATION

	%100=:100	;Symbols for DDT
	%200=:200
	%300=:300
	%400=:400
	%500=:500
	%600=:600
	%700=:700
	%1000=:1000
	%2000=:2000
	%3000=:3000
	%4000=:4000

;*; CURJOB=:20	;RH=Current job on master CPU, LH=Current job on slave CPU
;*; CLKDDT=:21	;Jump to EDDT if DEBUG set, else physical addr of BOOTS data
    BOOTWD=:22	;Pointer to BOOT text
           ;23	; zero (22 and 23 used to read BOOTS from RP02 disk)
    KSSS4=: 24	;"Sense Switch 4" word for KS
;*; CRSDTM=:24	;(TOPS10) Date/Time of previous crash (default time on RELOAD)
;*; CRSWHY=:25	;(TOPS10) Stopcode name (duplicates %SYSNM but in low core)
    REPSID=:26	;Restart Pack Set ID to verify consistancy of disk packs
    RESTRT=:27	;Restart states and actions (MANUAL, FULL DSKCLN, etc)
;*; CPNDDT=:27	;(TOPS10) Nonzero if at EDDT breakpoint, slave CPUs loop in ACs
    CRSHWD=:30	;If nonzero, jump to REBOOT at clock tick
    RLWORD=:31	;KS reload bits, to enable/disable Keep-Alive with the 8080
    CTYIWD=:32	;2020 CTY input word
    CTYOWD=:33	;2020 CTY output word
    KLIIWD=:34	;2020 KLINIK input word
    KLIOWD=:35	;2020 KLINIK output word
    DDTSYM=:36	;Like JOBSYM, but after symbol table has been moved
;*; SYSSNP=:37	;(TOPS10) If nonzero, JSR @SYSSNP at clock tick (output to LPT)
    FORTY=: 40	;LUUO stored at here on KL-10 (not in the EPT)
    JOB41=: 41	;JSR to LUUO handler on KL-10
        ;42-57	;Priority interrupt for KA-10
    JOBREL=:44	;(user mode) Size of SYSTEM.SAV
;*; ARSLOC=:70	;(TOPS10) Instruction executed on a reload after power failure
    KAFLOC=:71	;Instruction executed on a Keep Alive Failure
;*; WRSINS=:72	;(TOPS10) Instruction executed on a Warm ReStart
           ;73	; zero
    JOBDDT=:74	;<ending,,starting> address of EDDT
;*; JOBHSO=:75	;(TOPS10) High Segment Origin
;*; JOBBPT=:76	;(TOPS10) Address of DDT's breakpoint #0
;*; LIGHTS= 77	;(TOPS10) Data to be displayed in lights (KA-10 and KI-10)
;*; JOBEDV=:112	;(TOPS10) Address of Exec Data Vector
    DDTSA=: 114	;Like JOBDDT, but after symbol table has been moved
    JOBHRL=:115	;(TOPS10) Length,,start of hiseg
    JOBSYM=:116	;Pointer to DDT symbol table as set up by LINK/LOADER
    JOBSA=: 120	;RH has starting address, LH has initial JOBFF
    JOBFF=: 121	;First Free location in lowseg, used by DDT autopatch
    JOBS41=:122	;Copy of JOB41 when creating/reading SAV file
    JOBCOR=:133	;Size of SYSTEM.SAV
    JOBCST=:136	;Reserved for customer definition
    JOBVER=:137	;Version number, pointer to CONFIG table in TYMCOM-X

	LOC	137
	EXP	CONFIG	;Pointer to configuration table for CRSHID

;SYSTEM INITIALIZATION DISPATCH TABLE, STARTING AT LOCATION 140

	COMORG==140	;ORIGIN OF COMMON IS 140
	LOC	COMORG	;MAKE LISTING BE SAME AS LOADING SO IT WILL BE EASY
			; TO EXAMINE SYSTEM LOCATIONS WITH CONSOLE SWITCHES
			; WITHOUT NEEDING LOADER MAP

SYSDSP::JRST ONCGO##	;(140) INITIALIZE SYSTEM VARIABLES ONCE ONLY
SYSDDT::JRST PATSYM##	;(141) PATCH SYMBOL TABLE POINTER, THEN ENTER EXEC DDT
	JRST SYSZRO##	;(142) ONCE CODE TO ZAP EDDT & SYMBOL TABLE.
	HALT .		;(143) INITIALIZE SYSTEM VARIABLES ALWAYS
	HALT .		;(144) ERROR RECOVERY
	HALT .		;(145) DO ONCE ONLY CODE OVER AGAIN
SYSBTS::JRST BOTLOD	;(146) Reload BOOTS from HOM pages on disk
S..147::JSR  CRS147	;(147) CRASH, without STOPCD printout ;;SYSINA+4

IFNDEF SIZIRG,<XP SIZIRG,7>	;SIZE OF INPUT RING (AS POWER OF 2)
IFNDEF SIZORG,<XP SIZORG,10>	;SIZE OF OUTPUT RING (AS POWER OF 2)
    XP MSKIRG,<1_SIZIRG-1>
    XP MSKORG,<1_SIZORG-1>

IFNCPU(F3),<LOC 150	;Data locs for VARIAN-620 or EBUS base
BASEDB::!
KEY620::0		;(150) Set to 63375150626 when system is up
	0		;(151) Alarm cell (BBORQ & BBOIO on F3)
	0		;(152) Location for 620 to dump core (obsolete)
IRINGA::IRING_4		;(153) Location of input ring in BASE format
IRINGS::1_<SIZIRG+4>	;(154) Size of input ring in BASE format
IRPPDP::0		;(155) PDP-10 pointer to empty input ring
IRP620::0		;(156) BASE pointer to fill input ring
ORINGA::ORING_4		;(157) Location of output ring in BASE format
ORINGS::1_<SIZORG+4>	;(160) Size of output ring in BASE format
ORPPDP::0		;(161) PDP-10 pointer to fill output ring
ORP620::0		;(162) BASE pointer to empty output ring
D620FN:!-1		;(163) SET 0 BY 620 WHEN 10 COMES UP, NON-0 WHEN
			;      620 FINISHED DUMPING (OBSOLETE)
LIVWRD:!0		;(164) Used by RMTSER if NUMPRT # 0
	0		;(165) if NUMPRT # 0, then QTOST_4
	0		;(166) NOT USED
	0		;(167) NOT USED
;Locations 150-167 are BLT'ed to 170-207 when the system crashes.  /JMS
BASEDL==:.-BASEDB
>;END IFNCPU(F3)
ND BASEDL,<170-150>	;Resolve forward reference for F3

	LOC	170		;Even on the F3, so CRSHID can dump the rings
BASAVE::BLOCK BASEDL	;(170-207) Copy of IRING/ORING pointers in crash
BASDWN:: 1		;(210) + = startup, 0 = ok, - = base went down
			;(211-277 unused)

	ND SAXBAS,300	;This location set by DIP switches on the SA-10
IFN SAXN,<LOC	SAXBAS	;Low-core pointers to command lists
SA0BAS::BLOCK 20	;4 words per channel, 4 channels (we use 0=disk,1=tape)
SA1BAS::BLOCK 20	;Reserved for 2nd SA10
SAXLEN==:.-SAXBAS
	LOC SAXBAS+40	;This area reserved, even on KS and F3
SASAVE::BLOCK 20+20	;340-377 Copy of SAXBAS in crash
>;END IFN SAXN		;The TOPS-10 KL in St.Louis uses SA0BSE=460
			;(400-777 unused)

IFN RA10N!RP10N!RD10N,<
	LOC	540		; Channel command words (for now)
	LOC <.+1>&777776	;GET TO EVEN LOC FOR CHANNEL COMMAND WORDS
LOCOCW:	BLOCK ALLKON*2

ifn <.+200>&777000,<PRINTX *** CHANNEL COMMAND WORDS PAST 600 ***>
ifn <.&777000>,<PRINTX *** CHANNEL COMMAND WORDS OVERWRITING EPT ***
STOPI>
>  ;End of RA10N!RP10N!RD10N

	LOC 1000
EPT::	BLOCK 1000		;EPT in locations 1000-1777
IFCPU(F3),<LOC 2000	;The pointers and rings for the F3 must be in page 2
BASEDB::!
KEY620::0		;(2000) Set to 63375150626 when system is up
BBORQ:	0		;(2001) BLOCK I/O REQUEST STORAGE WORD FOR UCODE
BBOIO:	0		;(2002) BLOCK I/O IO WORD FOR MICROCODE
IRINGA::IRING_4		;(173) LOC OF INPUT RING (for CRSHID, ignored by uCODE)
IRINGS::1_<SIZIRG+4>	;(174) SIZE OF INPUT RING (for CRSHID, ignored by uCODE)
IRPPDP::0		;(2005) HOST IRING POINTER
IRP620::0		;(2006) BASE IRING POINTER
ORINGA::ORING_4		;(177) LOC OF INPUT RING (for CRSHID, ignored by uCODE)
ORINGS::1_<SIZORG+4>	;(200) SIZE OF INPUT RING (for CRSHID, ignored by uCODE)
ORPPDP::0		;(2011) HOST OUTPUT RING POINTER
ORP620::0		;(2012) BASE OUTPUT RING POINTER
D620FN:!-1		;(2013) BASE NEVER DUMPS IN PDP-10 MEMORY
LIVWRD:!0		;(2014) Unused if NUMPRT = 0
	0		;(2015) QTOST_4 if NUMPRT # 0
	0		;(2016) NOT USED
	0		;(2017) NOT USED
;Locations 2000-2017 are BLT'ed t-207 when the system crashes.  /JMS
BASEDL==:.-BASEDB
	BLOCK 2200-2020	;(2020-2200) unused

IFN SIZIRG-7,<	PRINTX ? F3 input ring size must be 200 octal
		STOPI>	;Size hardcoded in F3 microcode
IFN SIZORG-10,<	PRINTX ? F3 output ring size must be 400 octal
		STOPI>	;Size hardcoded in F3 microcode
IFN .-2200,<	PRINTX ? F3 IRING must be at 2200, ORING must be at 2400
		STOPI>	;Location hardcoded in F3 microcode
IRING::	BLOCK	200	;SIZE FIXED BY F3 MICROCODE
ORING::	BLOCK	400	;SIZE FIXED BY F3 MICROCODE
>;END IFCPU (F3)

IFNCPU(F3),<
	LOC 2200		;Make this be consistant on all CPUs
IRING::	BLOCK	1_SIZIRG	;2200-2377
ORING::	BLOCK	1_SIZORG	;2400-2777
>;END IFNCPU(F3)
	LOC <.+777>&777000	;Go to start of next page

UPT::	BLOCK	SIZCTX*1000	;Context pages for null job (and crash dump)
UPDEND==.-1			;End of BLT for crash dump
SUBTTL	KS-LPT - Page aligned data for the 2020 lineprinter
IFCPU (KS),< IFG LPTN,<LOC <.+777>&777000	;Go to start of next page
  ;This data must all fit into one page or else LPTSER must be changed to use
  ;more than one UNIBUS paging RAM register.

;MACROS TO GENERATE KS10 VFU LOADING DATA.  CODE COPIED FROM T10 MODULE LP2SER
DEFINE MOD(A,B),<A-<<A/B>*B>>
..BC==0
..B==0
DEFINE OUTBYT(C),<
..C==C
..BC==..BC+1
IFE ..BC-1,<..C==<..C&377>_<^D18>>
IFE ..BC-2,<..C==<..C&377>_<^D26>>
IFE ..BC-3,<..C==<..C&377>>
IFE ..BC-4,<..C==<..C&377>_<^D8>>
..B==..C!..B
IFE ..BC-4,<EXP ..B
	    ..BC==0
	    ..B==0>
>;OUTBYT MACRO DEFINITION
DEFINE LASBYT,<
IFN ..B,<EXP ..B
>
>;LASBYT MACRO DEFINITION
DEFINE VFUBIT(LINE),<
..BT==0
IFE LINE,<..BT==..BT!1>		;;LINE 0 GETS CH. 1
IFE MOD(LINE,36),<..BT==..BT!2>	;;EVERY 30 LINES GET CH. 2
IFE MOD(LINE,4),<..BT==..BT!4>	;;EVERY 4TH LINE GETS CH. 3
IFE MOD(LINE,3),<..BT==..BT!10>	;;EVERY 3RD LINE GETS CH. 4
IFE MOD(LINE,12),<..BT==..BT!40>	;;EVERY 10TH LINE GETS CH. 6
IFLE LINE-<LPTLPP-1>,<..BT==..BT!20>	;;ALL LINES.LE.LINES/PAGE GET CH. 5
IFGE LINE-LPTLPP,<..BT==20>	;;LINES ABOVE LINES/PAGE GET ONLY CH. 5
OUTBYT(..BT)
..BT==0
IFE MOD(LINE,24),<..BT==..BT!1>	;;EVERY 20TH LINE GETS CH. 7
IFLE LINE-<LPTLPP-1>,<..BT==..BT!2>	;;LINES 0-LINES/PAGE GET CH. 8
IFE LINE-<LPTLPP-1>,<..BT==..BT!40>	;;LAST LINE ON PAGE GETS CH. 12
IFGE LINE-LPTLPP,<..BT==0>	;;LINES ABOVE LAST GET NOTHING
OUTBYT(..BT)
>;VFUBIT MACRO DEFINITION

IFNDEF LPTLPP,<LPTLPP==^D60>	;default lines/page is 60
IFNDEF LPTFS,<LPTFS==^D66>	;default form size is 66
NXDLPT::EXP LPRUN		;IF 0 THEN LPT IS A NON-EXISTANT DEVICE
LPVLPT::VLDATL,,<<.&777>*4>+4	;output pointer to load DAVFUQ
	XWD 356,37437		;start code,,channels 1-11
	REPEAT <<LPTFS-4>/2>,<	;this sets up most of the lines
	XWD 37037,37037		;generate 2 DAVFU lines w/ ch2-ch11
	>;REPEAT
	IFE MOD(LPTFS,2),<XWD 37037,37077
			  XWD 167400,0>;for even form sizes
	IFN MOD(LPTFS,2),<XWD 37077,16740>;for odd form sizes
VLDATL==.-LPVLPT-1
	BLOCK ^D46-VLDATL	;leave room for form sizes up to ~88/GL
LPCFPT::1,,<<.&777>*4>+4
	BYTE (2) 0 (8) 14,15
NEWTOF::1,,<<.&777>*4>+4	;new top of form /GL
	BYTE (2) 0 (8) 357,0	;stop byte /GL
LPTEPT::LTEDAT,,<<.&777>*4>+4
REPEAT ^D16,<BYTE (2) 0 (8) "8","8" (2) 0 (8) "8","8">
	BYTE (2) 0 (8) 12,15
LTEDAT==.-LPTEPT-1

IFN LPTN-1,<PRINTX LPT BUFFER ALLOCTION DONE FOR ONLY ONE PRINTER.>
LPBSIZ==40
LPTBUF:	BLOCK <LPBSIZ*5>/4+1
>>;IFCPU KS, IFG LPTN
SUBTTL	Start of relocatable COMMON (byte pointers, etc)

;Everything defined before here have fixed locations in absolute low core

	STOPCD(,ENTRY,COMMON)	;Default for noname stopcodes

	LALL
        SYDVF (<<RTIME,JOBN>>)			;For SYSDVF function 6
	SYDVF (<<IRING,<1_SIZIRG>> ,<ORING,<1_SIZORG>> ,<BASEDB,BASEDL>>)
	SYDVF (<<IRINGX,<1_SIZIRG>>,<ORINGX,<1_SIZORG>>,<BASAVE,BASEDL>>)
IFN SAXN,<SYDVF(<<SAXBAS,SAXLEN>,<SASAVE,SAXLEN>>)> ;For SYSDVF function 6
	SALL

IRINGX::BLOCK	1_SIZIRG	;Copy of IRING in crash dump
ORINGX::BLOCK	1_SIZORG	;Copy of ORING in crash dump
				;See also BASAVE at locations 170-207
KEYTIM::0			;UPTIME when the base last cleared KEY620
IRPTIM::0			;UPTIME when the message read from IRING
ORPTIM::0			;UPTIME when the last message was put in ORING

XP EPT.PN,<EPT_-9>
XP UPT.PN,<UPT_-9>
IFNCPU(KI),<XP EPTEBR,EPTFSL>	;WHERE TO DO CONO PAG FROM.
IFCPU (F3),<XP EPTACB,100>	;PLACE FOR F3 TO STORE NON-CURRENT AC BLOCKS

;LMAP AND UPT GENERATION

  UP%000=:%UPT+000	;User page map
  UP%200=:%UPT+200	;User HISEG map
  UP%400=:%UPT+400	;Funnyspace map
  UP%500=:%UPT+500	;Page fail words (KI uses 426)
  UP%600=:%UPT+600	;Stack and such  (KI uses 440)
			;PGT,MUU,MUP,KNT defined in K?SYM
  UP%PGT=:%UPT+UPTPGT	;Trap instructions (420-423)
  UP%MUU=:%UPT+UPTMUU	;UUO or illegal instruction stored here (424)
  UP%MUP=:%UPT+UPTMUP	;PC of UUO or illegal instruction (425)
  UP%KNT=:%UPT+UPTKNT	;Start of dispatch table (430-437)

	SALL		;MAKE COMMENTS COME OUT IN SPITE OF MACRO BUG.

DEFINE UVAR(LABEL)<UARRAY(LABEL,1)>

DEFINE UARRAY(LABEL,SIZE)<LABEL=:<%UPT.V==%UPT.V+SIZE>-<SIZE>>
DEFINE UARRAY(LABEL,SIZE)<XP LABEL,%UPT.V
			  %UPT.V==%UPT.V+'SIZE>

%UPT.V==UPTFSL		;START OF UPT LOCATIONS RELATIVE TO %UPT (440 or 600)

;THE FOLLOWING LOCATIONS MUST BE IN THE FIRST ^D512 WORDS

	XP XACSTL,4	;eXec AC STack Length (UUOs nested 4 deep)
UARRAY(UPTAC0,<<20*XACSTL>+1>)	;Extra word for stack pointer overflow
	IFN UPTAC0&17,<PRINTX UPTAC0 MUST BE ON 20 WORD BOUNDARY>
  UP%AC0=:%UPT+UPTAC0
UVAR(UPTSTS)	;JOB IN CORE STATUS BITS
			;18-35	STARTING ADDRESS IF STRTAD SET
	XP XPNCOR,1	;17	CORE NEEDS TO BE EXPANDED
	XP STRTAD,2	;16	RIGHT HALF CONTAINS A STARTING ADDRESS
	XP UPSCLK,4	;15	CLOCK SHOULD BE ON
	XP SAVCHG,10	;14	CHARGES ARE SAVED IN UPT
	XP REC.WR,20	;13	WRITE STREAM ACCTG RECORD NEXT EXIT
	XP LSAREC,40	;12	LOCAL STREAM ACCTG DONE
	XP SG.SWR,100	;11	CURRENT HISEG LOADED FROM .SWR FILE
	XP UPNPSR,^D10	;8-10	(POS) PENDING STREAM REC TYPE
	XP UPSPSR,^D3	;	(SIZ) SEE START CMD AND USRXIT
	XP UPSSWE,2000	;7	JOB GOT SWAP ERROR FOR USER PAGE
			;	WHILE IT OWNED DISK RESOURCE, AND
			;	JBTABT NOT SET UP. UTRP SET WITH
			;	THIS BIT SO USRXIT SEES IT.
	XP UPSABK,4000	;6	ADDRESS BREAK DURING UUO.
	XP STRTCL,10000	;5	INCREMENT START ADDRESS BEFORE USING IT.
			;0-4	(UNUSED)

 UPYPSR::POINT UPSPSR,%UPT+UPTSTS,UPNPSR ;POINTER TO PENDING STREAM REC TYPE
 USYPSR::POINT UPSPSR,%UPS+UPTSTS,UPNPSR ; One for %UPS
 UXYPSR::POINT UPSPSR,%UPX+UPTSTS,UPNPSR ; One for %UPX

UVAR(UPTJOB)		;HAS JOB NUMBER OWNING THIS UPT
UVAR(UPTPC)		;HAS THE JOB'S PC WHEN NEXT SET TO RUN
  UP%PC=:%UPT+UPTPC
UVAR(UPTACP)		;STACK POINTER TO SAVED EXEC AC'S
UVAR(UPTLDC)		;COUNT OF NUMBER OF LMAP SLOTS KEPT IN ACS FROM THIS UPT
UVAR(UPTABK)		;ADDRESS BREAK WORD.
  XP EPLLEN,176	;LENGTH EXEC PDL
UVAR(UPTUUO)		;Top level MUUO (called from user mode)
  UP%UUO=:%UPT+UPTUUO
UARRAY(UPTPDL,EPLLEN)	;SYSTEM UUO PDL FOR CURRENT JOB
  UP%PDL=:%UPT+UPTPDL		;Stack in funny space
	XP NUMCHN,^D48		;MAX NUMBER OF IO CHANNELS
	XP MAXCHN,<NUMCHN-1>
UARRAY(UPTJDA,NUMCHN)	;RH==DDB ADDRESSES (JOB DEV ASSIGNMENTS)
  UP%JDA=:%UPT+UPTJDA	;LH= VARIOUS STATUS BITS FOR CHANNEL:
			;(INITB,LOOKB,ICLOSB..ETC SEE S.MAC)
UARRAY(UPTSIM,NUMCHN)	;SIMULATED BUFF/DUMP MODE
			;IO DATABASE. LH=SEQUENCE STAMP. RH=
			;SIMIO STATUS BITS+PAGE NUMBER FIELD
UARRAY(UPTPOS,NUMCHN)	;BLOCK POSITION IN (DSK) FILE ON THIS CHANNEL
UVAR(UPTPBM)		;PAGE BIT MAP. BITS 0-31 SET IF PER-PROCESS
			;PGS 340-377 USED FOR SIMIO
UVAR(UPTIOC)	;SIMIO IO COUNT, FOR SEQ. STAMP
UARRAY(UPTXAC,20)	;EXEC ACS HERE WHEN JOB ISN'T RUNNING.
UARRAY(UPTUAC,20)	;USER ACS WHEN JOB ISN'T RUNNING (FORMERLY IN PAGE 0)
  UP%UAC=:%UPT+UPTUAC
	XP CHGSIZ,<^D22>
UARRAY (UPTCHG,CHGSIZ)	;SAVED TRU COMPONENTS. 17 PRE-P031

UVAR(UPTHCU)		;HIGHEST USER I/O CHANNEL IN USE.
UVAR(UPTENB)		;LH=UNUSED,RH=APR CONSO FLAGS FOR USER
			; APR TRAPPING.  SET BY APRENB UUO.
UVAR(UPTTPN)		;HAS TRAP NUMBERS FOR VARIOUS TRAPS
UVAR(UPTTP1)		;MORE TRAP NUMBERS
UVAR(UPTMTM)		;Micro-cycle interrupt timer
UVAR(UPTABL)		;SAVED LOCATION FOR ADDRESS BREAK (SO CAN REPORT WHERE UUO WAS)
UVAR(UPTUFI)		;USER WORKING SET PAGE FAULT INFORMATION
UVAR(UPTXFI)		;LIKE UFI, BUT FOR TIMES TRAP CAN'T HAPPEN
UVAR(UPTUEI)		;USER ERROR INFORMATION (FOR PAGES)
UVAR(UPTXEI)		;LIKE UEI, BUT USED WHEN TRAP CAN'T HAPPEN
UVAR(UPTURI)		;USER REF BIT TRAP INFO
UVAR(UPTXRI)		;LIKE URI, BUT USED WHEN TRAP CAN'T HAPPEN.
UVAR(UPTUII)		;ILL MEM REF, WRITE VIOL, ADDR BREAK INFO WORDS
UVAR(UPTXII)		; RETURNED BY PGISTS UUO.

  XP UPTTCB,UPTTPN	;FIRST LOC TO CLEAR IN APRENB
  XP UPTTCE,UPTXII	;LAST LOC.
UVAR(UPTREL)		;LH/0; RH/LOWSEG HI ADDR OR 0 IF NO LOWSEG
UVAR(UPTHRL)		;LH/0;  RH/HISEG HI ADDR, OR 0 IF NO HISEG
UVAR(UPTRNM)		;RESTRICTED COMMAND FILE NAME
UVAR(UPTRPN)		;RESTRICTED COMMAND FILE PPN
UVAR(UPTALD)		;ALTERNATE LOGOUT PROGRAM DEVICE
UVAR(UPTALP)		;ALTERNATE LOGOUT PROGRAM PPN
UVAR(UPTALN)		;ALTERNATE LOGOUT PROGRAM NAME
UVAR(UPTPJC)		;SESSION PROJECT CODE WORD 0
UVAR(UPTPJ1)		;WORD 1
UVAR(UPTPJ2)		;WORD 2,BIT 35 IS "LICENSE REQD" BIT
UVAR(UPTSAT)		;HAS STATUS BITS FOR + ADDR OF %SAT PCB.
UVAR(UPTRIB)		;HAS STATUS BITS FOR + ADDR OF %RIB PCB.
UVAR(UPTRB2)		;HAS STATUS BITS FOR + ADDR OF %RB2 PCB.
UVAR(UPTPID)		;PID FOR CURRENT PROGRAM - FROM RUN FILE'S PID.
UVAR(UPTSPD)		;SAVED PID, SO PIDSET UUO CAN SET IT TO 0 AND BACK

UVAR(UPTLOG)		;Originating Port for this frame.
  UP%LOG=:%UPT+UPTLOG
UVAR(UPTLKJ)		;JOB NUMBER OF JOB WHO OWNS CONTEXT PAGE WRITE LOCK FOR THESE CONTEXT PAGES
UVAR(UPTLKW)		;HEAD OF WAITERS FOR CTX PAGE WRITE INTERLOCK
UVAR(UPTOFD)		;FRAME DESCRIPTOR SET BY SETOTF UUO.
UVAR(UPTLKC)		;NUMBER OF TIMES OWNER OF LOCK CALLED FOR IT AGIN+1
			; (NESTED PAGE FAULTS INSIDE UUOS, ETC.)
UVAR(UPTETP)		;(0) CLASS,,TYPE WITHIN CLASS OF ERROR TRAP
XP UPTHST,UPTETP	;FIRST LOCATION OF HALT STATUS BLOCK
UVAR(UPTECN)		;(1) COUNT TO TELL HOW MANY ERRORS HAPPENED.
UVAR(UPTEPC)		;(2) PC OF ERROR TRAP
UVAR(UPTEUP)		;(3) PC OF LAST TOP LEVEL UUO PERFORMED
UVAR(UPTEDV)		;(4) DEVICE NAME, LOCATION, ETC.
UVAR(UPTELC)		;(5) LOCATION, OTHER DATA
UVAR(UPTEL1)		;(6) ANOTHER LOCATION FOR ERROR DATA.
XP FHSMXC,<UPTEL1-UPTHST+1> ;MAXIMUM COUNT

XP FHIMAX,FHIN-1	;MAXIMUM VALUE FOR INDEXING INTO UPTFHT

UARRAY(UPTFHT,FHIN)	;FRAME HANDLE ADDRESSES.

UARRAY(UPTS2P,.ARSIZ)	;BITS FOR ACCESS RIGHTS OF SELF OVER PARENT
UARRAY(UPTP2S,.ARSIZ)	;BITS FOR ACCESS RIGHTS OF PARENT OVER SELF
UARRAY(UPTMFR,.ARSIZ)	;MAX INWARD RIGHTS FOR THINGS THAT NEED CONTEXT PAGES IN.

UVAR(UPTSTV)		;CONTAINS SIZE,,START ADDRESS OF START VECTOR
;DEFINE LMAP LOCATIONS
UARRAY(UPTLMA,<VPMAX+1>);BASIC LMAP SLOT DATA, INDEXED BY VP
UARRAY(UPTMWB,<<VPMAX+1+^D35>/^D36>)
			;MONITOR WORKING SET BIT TABLE.
AGECPW==:<^D36/AGESIZ>
AGEMAX==:<<1_AGESIZ>-1>
UARRAY(UPTAGE,<<^D512+AGECPW-1>/AGECPW>)
			;PAGE AGE TABLE
UARRAY(UPTUWB,<<^D512+^D35>/^D36>)
			;USER WORKING SET BIT TABLE
UVAR(UPTUWS)		;USER WORKING SET DATA
			;CURRENT SIZE IS IN JBYUWS.
 UPYUWL::POINT 10,%UPT+UPTUWS,25	;CURRENT LIMIT
 USYUWL::POINT 10,%UPS+UPTUWS,25 ;ONE FOR %UPS
 UXYUWL::POINT 10,%UPX+UPTUWS,25 ;ONE FOR %UPX
 UPYUWM::POINT 10,%UPT+UPTUWS,35	;CEILING FOR CURRENT LIMIT
 USYUWM::POINT 10,%UPS+UPTUWS,35 ;ONE FOR %UPS
 UXYUWM::POINT 10,%UPX+UPTUWS,35 ;ONE FOR %UPX

UVAR(UPTNTV)		;TICKS UNTIL NEXT PAGE AGE RECOMPUTATION
UVAR(UPTMAT)		;# OF MATURE PAGES (AGE .GE. C(AGEMAT))
UVAR(UPTELD)		;# OF ELDERLY PAGES (AGE .GT. C(AGEELD))
UVAR(UPTRPT)		;POINTER FOR CIRCULAR PAGE REPLACEMENT ALGORITHM

UVAR(UPTRES)		;WORD FOR SWAPPER TO REMEMBER RESERVED PAGES
 USYSIN::POINT 10,%UPS+UPTRES,15	;NUMBER OF PAGES SWAPPED IN
			; FOR SETTING UP ICPT
 USYRES::POINT 10,%UPS+UPTRES,25	;NUMBER OF RESERVES PAGES JOB OWNS STILL
 USYLSP::POINT 10,%UPS+UPTRES,35	;LMAP SCAN POINTER (WHERE
			; SWAPPER STARTS SWAPPING IN ON A CYCLE

XP UPTEND,%UPT.V-1	;Ending location to clear, end of BLT when crashing
NCTXPG==:<%UPT.V!777+1>/1000
ONSZCK(CONTEXT,NCTXPG,CTX)	;Check if enough space allocated for CTX pages
  PDL=:   UPT+%UPT.V		;Stack for null job and scheduler
  NULUPL==NCTXPG*1000-%UPT.V	;Null job UPT limit = until end of page
  IFL <NULUPL-60>,<PRINTX ? Null job PDL is too small>
NULPDL::IOWD NULUPL,PDL		;Null job gets a short stack (70 words)

VPUMAX==:VPMAX-NCTXPG	;MAXIMUM NON-CONTEXT PAGE VP

XP %UPT.N,VPUMAX+1-CNVVPN 	;START PAGE OF CONTEXT PAGES
XP %UPT,<%UPT.N_9>	;START ADDRESS OF CONTEXT PAGES IN UPT
XP %UPLMA,%UPT+UPTLMA	;THIS ADDR+VP GIVES LMAP SLOT DATA
XP %UPLMX,%UPX+UPTLMA	;DITTO FOR %UPX.

XP %COW.N,%UPT.N-1	;USED FOR COPY ON WRITE
XP %COW,<%COW.N_^D9>

;%UPX IS A SPECIAL SET OF PAGES THAT EITHER CONTAINS POINTERS IDENTICAL
; TO %UPT POINTERS IF THE SLOTS DON'T EXIST, OR LMAP SLOTS FOR
; ANOTHER FRAMES'S CONTEXT PAGES.

XP %UPX.N,%COW.N-NCTXPG	;PLACE FOR VIRTUAL UUOS THAT WORK ON OTHER FRAMES TO
			; ACCESS CURRENT CONTEXT PAGES
XP %UPX,<%UPX.N_^D9>

;ADD OTHER PERMANENTLY ALLOCATED EXEC PER PROCESS VALUES ABOVE HERE
XP %LEP.N,%UPX.N-1	;LAST DYNAICALLY ALLOCATED EXEC PER PROCESS PAGE

PBMMSK::-1_<340-%LEP.N+1>	;MASK FOR DYNAMIC ALLOCATER.
				; 1 MEANS IN USE.

XP %UPS.N,EVPMAX-NCTXPG+1	;FIRST EPT PAGE NUMBER THAT CONTEXT PGES MAPPED IN
XP %UPS,<%UPS.N_9>	;FIRST CONTEXT PAGE ADDRESS IN EPT
XP %UPLMS,%UPS+UPTLMA	;THIS ADDR PLUS VP GIVES 36 BIT LMAP SLOT DATA

UPYPTN:: UPMPTR(%UPT.N)		;
UPYPTM:: UPMPTR(%UPT.N-1)	; (CORE1)
UPYPXN:: UPMPTR(%UPX.N)		;
UPYPXM:: UPMPTR(%UPX.N-1)	; (CORE1)

USYPTN:: UPSPTR(%UPT.N)		; (ONCE)(CORE1)
USYPXN:: UPSPTR(%UPX.N)		;
USYPTM:: UPSPTR(%UPT.N-1)	;
USYPXM:: UPSPTR(%UPX.N-1)	; (SCHED1)

UXYPTN:: UPXPTR(%UPT.N,%UPT)	;
UXYPTM:: UPXPTR(%UPT.N-1,%UPT)	; (COMCON)

EPYPSN:: EPTPTR(%UPS.N)		; (ONCE)(PICON)(UUOCON)
EPYPSM:: EPTPTR(%UPS.N-1)	; (CORE1)(SCHED1)
;LMAP BIT DEFINITIONS

XP LMPSHR,400000	;SHARED (OFF IS UNSHARED)

XP LMSCUR,2		;SIZE OF PROTECTION FIELD
XP LMNCUR,2		;BIT POSITION
XP LMPCUR,(1B<LMNCUR>)	;THE BIT (see CPRRED, CPRCOW, CPRDRW in S.MAC
  XP MAXCPR,CPRRDW	;MAXIMUM DEFINED PROTECTION.

LMYCUR:: POINT LMSCUR,%UPLMA(W),LMNCUR ;CURRENT PROTECTION: WRITE,
			;COW, OR READ ONLY.
LM3CUR:: POINT LMSCUR,P3,LMNCUR
XP LMMCUR,300000	;DEFINED ONLY BECAUSE OF LMMEXS.
XP LMMEXS,LMPSHR!LMMCUR ;IF ALL OF THE MASKED BITS ARE OFF,
			;THE PAGE IS NON-EXISTENT.
XP LMPACT,40000		;ACTIVE (SEMI IN-CORE BIT)
XP LMPMXW,20000		;MAXIMALLY WRITEABLE
  XP LMMMXW,LMPMXW!LMMCUR ; For use as Maximally writeable MASK
  XP LMMRED,LMPMXW!(<CPRRDW>B<LMNCUR>) ; Max WRITE, READ ONLY
  XP LMMRDW,LMPMXW!(<CPRRDW>B<LMNCUR>) ; PROTOTYPE LMAP SLOT
XP LMPREF,10000		;REF
XP LMPVIR,4000		;VIRGIN
XP LMPDER,2000		;DEVICE ERROR
XP LMPDTE,1000		;DATA ERROR
 XP LMMERR,LMPDER!LMPDTE ;MASK
LMYERR::POINT 2,%UPLMA(W),^L<LMPDTE>-^D18 ;SWAP ERROR BITS
LM3ERR::POINT 2,P3,^L<LMPDTE>-^D18	;ONE FOR P3
XP LMPSUP,400		;THIS IS A SUPER MAPPED PAGE.
  XP LMMSUP,LMPSUP!LMMMXW ; Super mapped, Maximally writeable MASK
XP LMPNER,200		;IGNORE I/O ERROR ON THIS PAGE.
XP LMPLOK,100		;SLOT IS LOCKED IN CORE (NEVER DEACTIVATED EXCEPT IN REMOVE)


LMYOVR: POINT ^D23,%UPLMA(W),^D35 ;AN AREA OF THE LMA SLOT
			; THAT IS SHARED BY LMYLMA, LMYSPT, LMYATB, AND
			; LMYHDA.
LM3OVR: POINT ^D23,P3,^D35
 LMYOV1: POINT ^D13,%UPLMA(W),^D25
 LM3OV1: POINT ^D13,P3,^D25
 LMYOV2: POINT ^D10,%UPLMA(W),^D35
 LM3OV2: POINT ^D10,P3,^D35

;THE FOLLOWING FIELDS EXIST IN AN ACTIVE LMAP SLOT.

XPP LMYLMA,LMYOVR	;LINK OF PGYLMA CHAIN.ITS FORM IS
			; THAT OF A JOB-VM PNTR. THE END OF
			; THE CHAIN HAS A ZERO (THE SPT ENTRY
			; ADDR IS IN PGYSPT, SEE BELOW.).
 XPP LMYLMJ,LMYOV1
 XPP LMYLMV,LMYOV2
 XPP LM3LMJ,LM3OV1
 XPP LM3LMV,LM3OV2

;THE FOLLOWING FIELDS EXIST IN AN INACTIVE SHARED LMAP SLOT.

XPP LMYSPT,LMYOVR	;AN SPT-ENTRY PNTR.
XPP LM3SPT,LM3OVR
 LMYSPB::POINT 18,%UPLMA(W),31 ;BASE ADDRESS OF SPT SECTION
 LM3SPB::POINT 18,P3,31		;SAME, BUT IN P3
 LMYSPO::POINT 4,%UPLMA(W),35	;OFFSET INTO ENTRIES OF THIS ENTRY
 LM3SPO::POINT 4,P3,35		;ONE FOR P3

;THE FOLLOWING FIELDS EXIST IN AN INACTIVE UNSHARED LMAP SLOT.

XPP LMYATB,LMYOV1	;ADDR OF THE ATB. (REALLY AN OFFSET FROM
			;THE START OF A CORE STORAGE AREA.).
XPP LM3ATB,LM3OV1
XPP LMYHDA,LMYOV2	;HIGH PART OF THE DISK ADDRESS. (TOTAL
			; DISK ADDRESS REQUIRES
			; 8 BITS FOR UNIT FIELD AND 19 BITS FOR
			; PAGE NUMBER.).LOW PART OF DISK ADDR
			; IS IN UPT AT THIS POINT.
XPP LM3HDA,LM3OV2

XP LMASRP,^D17		;LSH BY THIS TO GET RID OF LOW 17 BITS,
			; OBTAINING HI ORDER DISK ADDRESS.

;PARTS OF LMAP IN UPT MAP AREA

UP4LDA::POINT 17,P4,35	;LOW ORDER PART OF DISK ADDRESS


;END OF LMAP/UPT DEFN'S
IFCPU(KS),<SUBTTL	Special defintions for the KS-2020

;Update the Keep Alive Counter for the KS 8080 front end every second
KSSEC::	LDB	T1,BKPALV	;Get current count from location 31
	AOS	T1		;Increment it
	DPB	T1,BKPALV	;Store 8 bits (0-377) back
	POPJ	P,		;End of KSSEC
BKPALV:	POINT	KPALVL,RLWORD,KPALVE	;8080's keep alive count

IFNDEF LPTBAS,<LPTBAS==0>	;PDP11 PAGE RESERVED FOR LPT
XP UBATAP,<LPTBAS_-9>+1		;DEFINE THE PAGING RAM INDICES FOR TAPE
XP UBACM0,UBATAP+^D32		;SET CM 0 ADDRESS INDEX FOR PAGING RAM
XP UBAEND,^D64			;END OF PAGING RAM
XX==0
IFG 1000-<ORING+<1_SIZORG>>,<	;IF BOTH RINGS FIT INTO PAGE 0
	XP UBANXT,UBACM0+1	;SET RAM INDEX FOR BLOCK IO AFTER RINGS
	XP UBIRBG,UBACM0	;SET IRING BEGIN TO PAGE 0
	XX==1>
IFL IRING-1000,<XP UBIRBG,UBACM0>;SET INDEX FOR START OF IRING
IFGE IRING-1000,<XP UBIRBG,UBACM0+1>
IFE XX,<			;ELSE RINGS DONT FIT IN PAGE 0
	XX==<<ORING+<1_SIZORG>+777>_-9>-<IRING_-9>;CALC. # PAGES FOR RINGS
	XP UBANXT,UBIRBG+XX	;SET RAM INDEX FOR BLOCK IO TO AFTER RINGS
>;END IFE XX

;HERE TO CHECK FOR EXISTENCE OF UBA DEVICES
; CALL	MOVE	T1,<ADR> OF DEVICE TO CHECK
;	PUSHJ	P,UBGOOD
;	LOSE RETURN
;	WIN RETURN
UBGOOD::PUSHJ	P,SAVT.		;PRESERVE T1-T4
	SETZ	T2,		;BITS FOR TIOE
	MOVE	T3,[EXP UBNOGD] ;TEMP PAGE FAIL TRAP ADDR
	RDPI	T4		;SAVE STATE OF PI'S
	WRPI	PI.OFF		;DISABLE INTERRUPTS
	EXCH	T3,%UPT+UPTNPP	;SET TEMPORARY PAGE FAIL TRAP ADR
	TIOE	T2,(T1)		;CHECK FOR DEVICE
	  SKIPA			;FAILED
	 AOS	(P)		;WIN
	MOVEI	T2,UBANED!UBATO	;CLEAR NED IN UNIBUS ADAPTER
	HRRI	T1,UBAADR	;GET BASIC ADDRESS OF UNIBUS
	BSIO	T2,(T1)		;CLEAR FLAGS
	MOVEM	T3,%UPT+UPTNPP	;RESTORE TRAP VECTOR
	TRNE	T4,PI.ON	;WERE PI'S ON?
	 WRPI	PI.ON		;YES--THEN ENABLE THEM
	POPJ	P,		;RETURN

;HERE WHEN ADDRESS IS BUM
UBNOGD:	AOS	%UPT+UPTOPP	;SKIP LOSING INSTRUCTION
	JRST	@%UPT+UPTOPP	;JUST RETURN(NONSKIP)
>;END IFCPU(KS)

;Routine SAVT in FILUUO does not preserve T1!
SAVT.::	EXCH	T4,(P)		;SAVE T4, GET RETURN ADR.
	PUSH	P,T3		;SAVE T3
	PUSH	P,T2		;AND T2
	PUSH	P,T1		;AND T1
	MOVEM	T4,1(P)		;STORE PC
	MOVE	T4,-3(P)	;RESTORE T4
	PUSHJ	P,@1(P)		;RETURN TO CALLER
	  SKIPA			;POPJ RETURN
	AOS	-4(P)		;CPOPJ1 - SET SKIP RETURN
	POP	P,T1		;RESTORE T1
	POP	P,T2		;RESTORE T3 ACS
	POP	P,T3
	POP	P,T4
	POPJ	P,		;AND RETURN
SUBTTL	Start of zeroed data

SYSBEG::		;FIRST LOCATION CLEARED ON 143 RESTART (SEE SYSINI)

   JOB=:.CPJOB		;Number of current job stored in CDB

COMCNT::0			;NUMBER OF COMMANDS TYPED-IN BUT NOT DECODED
				;SET BY SCNSER, DECREMENTED BY COMCON
HNGTIM::0			;HUNG DEVICE TIME COUNT CHECK FOR HUNG I/O
				;DEVICES WHEN THIS GOES TO ZERO (ONCE PER HNGSEC)
HNGMIN::0			;COUNTER FOR ONCE A MINUTE
CLKFLG::0			;NON-ZERO WHEN CLK INTERRUPT FORCED FOR ANY REASON
STPFLG::0			;SET WHEN CURRENT JOB MAY BE STOPPED
				;CLK INT AND NOT EXEC MODE OR USCHED
TIMEF::	0			;NON-ZERO FOR CLOCK INTERRUPT ON APR
				;SET BY APRSER, TESTED AND CLEARED BY CLK ROUTINE
				;SET BY APRSER, CLEARED BY CLK ROUTINE (CLOCK)
DTMADJ::0			;Number of ticks to adjust date/time
APRPC::	0			;PC WHEN APR ERROR DETECTED
				;LH=-1 ON MEM PARITY ERROR
SCHEDF::0			;FORCED RESCHEDULING FLAG FOR CLK ROUTINE
				;USED TO FORCE RESCHEDULING WHEN JOB IS IN EXEC MODE
NULERR::0			;SET NON-ZERO IF MONITOR DETECTS ERROR WHILE
				; NULL JOB IS RUNNING
POTLST::0			;-1 WHEN SCHEDULER SEES THAT THERE ARE JOBS WHICH
				; ARE POTENTIALLY RUNABLE BUT HAS TO RUN NULL JOB.
				;0 WHEN IT FINDS A REAL JOB TO RUN OR NULL JOB IS
				; ONLY JOB WHICH WANTS TO RUN.  'LSTWRD' IS
				; INCREMENTED EVERY JIFFY IF THIS FLAG IS -1 AND
				; PREVIOUS JOB WAS NULL JOB.
SLJOBN==JOBN*2			;LEAVE TWO ENTRIES PER JOB
CIPWT::	BLOCK SLJOBN+3		;CLOCK REQUEST QUEUE
				; LH-MONITOR ADDRESS TO PUSHJ TO AT CLOCK LEVEL
				; WHEN BITS 24-35 COUNT DOWN TO ZERO
				; BITS 18-23 ARE DATA SET IN AC T1 WHEN PUSHJ DONE
				; BITS 24-35 ARE NUMBER OF CLK TICKS LEFT TO GO
	CIPWTM==:CIPWT-1		;FIRST LOC-1 OF CLOCK QUEUE
;STORAGE FOR VARIOUS CORE ALLOCATION FUNCTIONS


	XP PAGSIZ,1000		;BASIC UNIT OF CORE IN WORDS

BASVER::BYTE(8)0,0,0,0		;BASE version from type 3 or type 4 message
;*;	BYTE(8)0,0,0,0		;Version # of 2nd base
;*;	BYTE(8)0,0,0,0		;Version # of 3rd base
;*;	BYTE(8)0,0,0,0		;Version # of 4th base

NSWTBL::			;Words 0-7 were CORTAB on a PDP-6 monitor
	0			;(0) unused
	0			;(1) unused
	0			;(2) unused
	0			;(3) unused
	0			;(4) unused

;; NEW entries here re-using ancient CORTAB entries	;;  backwards
;;	which have also been made obsolete by DEC.	;;  from 7-0

;WARNING: This table is zeroed out at startup.  See NZRINI in ONCE

SYSUDT::-1			;(5) Date/Time when system was loaded
KSYS::  0			;(6) Minutes until timesharing ends
INADEF::INADFL			;(7) DEFAULT INACTIVITY TIMEOUT LIMIT MINUTES
CORMAX::0			;(10) MAXIMUM CORE REQUEST+1 (IE LARGEST REL. ADR,+1)
				; CAN BE RESTRICTED TO LESS THAN ALL OF USER CORE
				; BY BUILD AND/OR ONCE
	0			;*(11) 1 BIT BYTE POINTER TO LAST FREE BLOCK POSSIBLE
				; SET BY SYSINI ON 143 STARTUP
	0			;?(12) TOTAL NUMBER OF FREE+DORMANT+IDLE CORE BLKS LEFT
	0			;*(13) JOB NUMBER SHUFFLER HAS TEMPORARILY STOPPED FOR
				; ITS I/O DEVICES TO BECOME INACTIVE BEFORE SHUFFLING
	0			;*(14) ABSOLUTE ADDRESS OF LOWEST HOLE IN CORE, 0=NONE
UPTIME::0			;(15) NUMBER OF CLOCK TICKS SINCE SYSTEM LOADED OR
				; RESTARTED AT 143
	0			;*(16) TOTAL NUMBER OF WORDS SHUFFLED BY SYSTEM
	0			;*(17) JOB CURRENTLY USING THE SYSTEM TAPE
				; NEEDED SO CONTROL C WILL NOT TIE UP SYSTEM TAPE
HIGHJB::0			;(20) HIGHEST JOB NUMBER CURRENTLY ASSIGNED
CLRWRD::0			;(21) TOTAL NUMBER OF WORDS CLEARED BY 'CLRCOR' RTN.
LSTWRD::0			;(22) TOTAL NUMBER OF CLOCK TICKS WHEN NULL JOB RAN
				; BUT OTHER JOBS WANTED TO RUN AND COULD NOT
				; DO SO BECAUSE: ---
				;  1. SWAPPED OUT OR ON WAY IN OR OUT
				;  2. MONITOR WAITING FOR I/O TO STOP SO
				;      IT CAN SHUFFLE OR SWAP
				;  3. JOB BEING SWAPPED OUT BECAUSE IT IS
				;      EXPANDING CORE
MEMSIZ::0		;(23)SIZE OF PHYSICAL MEMORY IN WORDS (=FIRST NON EXIST WORD)
			; SET BY SYSINI ON 143 RESTARTS UNLESS SYMBOLS SAVED BY
			; PATCHING SYSLIM SMALLER.
PARTOT::0		;(24) TOTAL NUMBER OF BAD MEMORY PARITY ERRORS FOUND BY MONITOR
			;WHILE PROCESSOR WAS IN USER MODE
			; WHILE SYSTEM WAS RUNNING (IF MONITOR HALTS
			; THIS LOC ALREADY UPDATED)
PARSPR::0		;(25) TOTAL NUMBER OF SPURIOUS MEMORY PARITY ERRORS
			; FOUND BY APR, I.E. ONES WHICH DID NOT OCCUR
			; WHEN MONITOR SWEPT THRU CORE LOOKING FOR BAD
			; PARITY.
PARCON::0		;(26) COUNT OF NUMBER OF TIMES OPERATOR PUSHED CONTINUE
			; AFTER MEMORY PARITY HALT (PC) IN EXEC MODE OR MORE THAN 1
			; BAD PARITY WORD WHEN PC WAS IN USER MODE)
PARADR::0		;(27) LAST BAD PHYSICAL MEMORY ADDRESS FOUND
			; WHEN MONITOR SWEPT THRU CORE AFTER
			; PROCESSOR DETECTED FIRST BAD PARITY
PARWRD::0		;(30) CONTENTS OF LAST BAD WORD FOUND BY MONITOR
			; WHEN MONITOR SWEPT THRU CORE AFTER FIRST PARITY
PARPC::	0		;(31) PC OF LAST MEM PARITY (NOT COUNTING SWEEP THRU CORE)
			;INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
			; TO USERS IN NON-SWAP AND SWAP SYSTEMS
EPOCNT::0		;*(32) TOTAL #  OF PDL OVF'S  AT M LEVEL IN EXEC MODE
EPOREC::0		;*(33) # OF PDL OVF'S AT M LEVEL IN EXEC MODE
NULTIM::0		;(34) NUMBER OF CLOCK TICS NULL JOB HAS BEEN
			;RUNNING SINCE STARTUP
NULMNT::0		;(35) NUMBER OF CLOCK TICES NULL JOB RAN
			;IN PREVIOUS MINUTE
ALR620::0		;(36) 620 ALARM CELL (UNHAPPY MSGS)
USRMAX::0		;(37) MAXIMUM SIZE THAT A JOB'S MWS CAN GET.
			; SETUP BY ONCE TO BE NUMBER OF USER PAGES AVAILABLE.
SYSUID::0		;(40) last allocated universal frame id number
THSTIM::0		;(41) UPTIME when SCNSER last ran
MXTIM::	0		;(42) all time max of (THSTIM-UPTIME)

NSWMXL==:<.-NSWTBL-1>B26	;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9

SYSBG2:			;1ST. LOCATION FOR ONCE ONLY CODE TO BE ASSEMBLED HERE
			;CORE ALLOCATION DATA NOT AVAILABLE VIA GETTAB
LASCOR::0		;LAST JOB OR HIGH SEG TO CALL CORE ROUTINES
PARFLG::0		;-NO. OF PARITY ERRORS ALLOWED IN EXEC MODE
			; BEFORE HALT.  USED TO DETECT SWEEP THRU CORE

RCMAX:	177		;MAX SIZE OF USER JOB IN K
CORMXK::0		;MIN-MAXIMUM SIZE OF USER JOB IN K
MWSLIM::0		;CURRENT MWS LIMIT. SETUP BY ONCE TO C(USRMAX)
HLTBRK::0		;IF NON-ZERO, WE WILL HALT ON ADRESS BRK
;DATA LOCATIONS PRESENT ONLY IN SWAPPING SYSTEMS

SWPTBL::			;FIRST LOCATION OF MONITOR DATA STORAGE
				; RETURNED BY GETTAB M (THESE LOCATIONS
				; PRESENT ONLY IN SWAP SYSTEMS)
				; OCTAL NUMBERS IN () CORRESPOND TO GETTAB ARG
	0			;(0) CURRENT BIGGEST HOLE IN CORE (IN PAGES)
	0			;(1) IF +, THEN JOB NUMBER OF JOB BEING SWAPPED IN,
				;IF -, THEN JOB NUMBER OF JOB BEING SWAPPED OUT
	0			;(2) JOB NUMBER BEING FORCED TO SWAP OUT
	0			;(3) JOB NUMBER WAITING TO BE FITTED INTO CORE
	0			;(4) NUMBER OF FREE PAGES OF SWAPPING SPACE LEFT
				; (COUNTING DORMANT SEGMENTS AS IF FREE).
				; PRINTED WITH CORE COMMAND (NO ARG) OR ERROR
				; USUALLY THE SAME AS THE AMOUNT OF VIRTUAL CORE
				; LEFT IN SYSTEM, EXCEPT WHILE R,RUN,KJOB,GET
				; COMMAND ARE WAITING TO BE SWAPPED IN, BECAUSE
				; THE OLD DISK SPACE HAS NOT BEEN RETURNED YET,
				; BUT VIRTUAL CORE IS ONLY 140 WORDS FOR SWAPIN
SWPERC::0			;(5) LH= NUMBER OF SWAPPER READ OR WRITE FAILURES
				; RH= ERROR BITS (BITS 18-21) + NUMBER OF J OF
				; DISCARDED SWAPPING SPACE

				;INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
				; TO USER PROGS IN SWAPPING SYSTEMS
LASIN::	0			;(6) last job or high seg swapped in
LASOUT::0			;(7) last job or high seg swapped out
SWPMXL==:<.-SWPTBL-1>B26	;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9
;MORE SWAPPING SYSTEM LOCATIONS (NOT RETURNED BY GETTAB)

FULCNT::0			;PRINT DISK IS FULL EVERY 30 SECONDS

;DEFINE BLOCK FOR BIT TABLE DENOTING 4 WORD BLOCKS AVAILABLE (=0), IN USE (=1)
; USE MULTIPLES OF 4*^D36 WORDS SO THE TABLE WILL HAVE A MULTIPLE OF ^D36 BITS
; ADD 7 WORDS TO ACCOMODATE A POSSIBLE 1K BEYOND FRECOR AMOUNT
;MONITOR TABLES WITH ONE ENTRY PER JOB

	JOBMAX==:JOBN-1		;MAXIMUM LEGAL JOB NUMBER, HIGHEST JBT INDEX
	JOBMXL==:<JOBMAX>B26	;HIGH JOB NUMBER SHIFTED LEFT 9 (FOR GETTAB UUO)
	MJOBN==:-JOBN		;NEGATIVE NUMBERS OF JOBS (COUNTING NULL JOB)

JBTSTS::BLOCK 	JOBN		;JOB STATUS WORD
				;LH==STATUS BITS (SEE S.MAC FOR DESCRIPTION)
				;BITS 18-23=EXTENDED JOB STATUS BITS
JBTST2::BLOCK	JOBN		;2nd job status word (P035/B04)
JBTWRS::BLOCK	JOBN		;LAST 6 JOB STATE CODES (DEBUGGING)
JBTCTX::BLOCK	JOBN*NCTXPG	;DISK ADDRESSES, STATUS BITS FOR
				; CONTEXT PAGES

JBTIOA::BLOCK	JOBN		;LH=UNUSED (Was interrupt assignments!!!)
				;RH=COUNT OF CAN'T SWAP WHILE IO
				;WHICH USES USER CORE IS IN
				;PROGRESS. =0 MEANS SWAPPABLE.

JBTUPM::BLOCK	JOBN		;LH = NUMBER OF EXISTENT PAGES IN
				; USER ADDRESS SPACE. RH = USER
				; AC BLOCK, LOAD UBR BIT
				; AND PHYSICAL PAGE NUMBER OF UPT

JBTPGO::BLOCK	JOBN		;LH SEE BELOW, RH LINK TO NEXT JOB
				; WAITING FOR CORE PAGE. CHAIN STARTS
				; IN PGYPGO.

JBTFIT::BLOCK	JOBN		;DOUBLY LINKED LIST OF JOBS BEING
				; SWAPPED IN.

JBTMWS::BLOCK	JOBN		;MONITOR WORKING SET WORD
				;BITS 26-35 (JBYUWS) UWS SIZE
				;BITS 16-25 (JBYMWL) MWS SIZE LIMIT
				;BITS  6-15 (JBYMWS) MWS SIZE
				;BITS  0-5  (JBYPPP) # OF PER-PROCESS
				;PAGES

JBTICT::BLOCK	JOBN		;LH=IN CORE PROTECT TIME FOR JOB
				;RH=QUANTUM RUN TIME

XP JBSQNT,^D12
XP JBNQNT,^D35
XP JBMQNT,7777
INTERN	JBMQNT

JBTFTR::BLOCK	JOBN		;FRAME TREE TABLE. CONTAINS 3 12 BIT
				; FIELDS - PARENT, RIGHT HAND NEIGHBOR, AND LEFTMOST CHILD.

JBTUID::BLOCK	JOBN		;UNIVERSAL FRAME ID
JBTPNO::BLOCK	JOBN		;"PROGRAM NUMBER" - RIGHTS GO AWAY AFTER MISMATCH AGAINST THIS
JBTSPN::BLOCK	JOBN		;SELF TO PARENT RIGHTS PROGRAM NUMBER
JBTP2S::BLOCK	JOBN		;FAST ACCESS RIGHTS BITS FOR PARENT TO SELF
JBTS2P::BLOCK	JOBN		;FAST ACCESS RIGHTS BITS FOR SELF TO PRENT
JBTMFR::BLOCK	JOBN		;FAST MAXIMUM INWARD RIGHTS
				; (DEFAULT RIGHTS FOR FRAMES THAT DON'T KNOW EACH OTHER WELL)

JBTPPN::BLOCK	JOBN	;.GTPPN=2  GFD'd Project Programmer Number
JBTNM1::BLOCK	JOBN	;.GTNM1=31 GFD'd Username (1st half) sixbit chars 1-6
JBTNM2::BLOCK	JOBN	;.GTNM2=32 GFD'd Username (2nd half) sixbit chars 7-12

	XP ITMDEV,JOBMXL	;LH SYMBOL FOR GETTAB M SO THAT JBTDEV IS
				;UNDEFINED, IE. MAKE INDEXING BYITEM BE 0

RTIME::	BLOCK	JOBN		;TOTAL RUN TIME SINCE LAST IJOB OR RUNTIME

JBTTMP::BLOCK	JOBN		;TMPCOR POINTERS, FREE SPACE FOR NULL JOB.
				; EACH ENTRY HAS THE FORM   XWD <QUOTA>,<LINK>

JBTNAM::BLOCK	JOBN		;NAME OF FILE USED IN LAST R,RUN,GET, ETC
				; USED BY SYSTAT PROGRAM, subject to SETNAM
JBTPRG==:JBTNAM			;Name of program, immune to SETNAM uuo

JBTKCT::BLOCK	JOBN		;PRODUCT OF CORE LENGTH (IN J) * NUMBER OF JIFFIES
				; PROGRAM USED CPU. USED FOR TIME ACCOUNTING.

JBTWCH::BLOCK	JOBN		;BITS 1-5 = ENABLE BITS - SEE S.MAC
				;BITS 13-35 = TIME OF DAY IN JIFFIES USER
				;STARTED TO WAIT FOR RESPONSE FROM SYSTEM
				;REST UNUSED

JBTINT::BLOCK	JOBN		; INTASS interrupt channel assignments.
				; Bits  0-5  (4)  Timer trap (SETTIM)
				; Bits  6-11 (6)  Wake UUO
				; Bits 12-17 (13) Notice to quit/hang
				; Bits 18-23 (14) Exit in any/all child frame
				; Bits 24-29 (16) TRU limit exceeded

JBTFNT::BLOCK	JOBN		; FINASS interrupt channel assignments.
				; Bits  0-5  (2) Frame int from parent
				; Bits  6-11 (3) Frame int from child
				; Bits 12-17 (4) Frame int from sibling
				; Bits 18-23 (5) Frame int from anyone

JBTPNT::BLOCK	JOBN		; FINASS interrupt set by parent for child.
				; Bits  0-5  (0) Int parent when child is lost
				; Bits  6-11 (1) Int parent when child exits

JBTSTA::BLOCK	JOBN		;Used by .USESTAT command

JBTLIC::BLOCK	JOBN		;FOR LICENSE BITS (process,,frame)
JBTSLC::BLOCK	JOBN		;Saved license    (process,,frame)
				; RH use by ENABLE and DISABLE commands

JBTFPN::BLOCK	JOBN		;PPN OF PROGRAM LAST RUN OR CURRENTLY
				;BEING RUN BY THIS JOB.  (0 IF PROGRAM
				;CAME FROM MAGTAPE.).

JBTAUN::BLOCK	JOBN	;.GTAUN=-23 Logged-in PPN (Accounting user number)
JBTUNM::BLOCK	JOBN	;.GTUNM=-22 Logged-in Username (1st half) sixbit chars
JBTUN1::BLOCK	JOBN	;.GTUN1=-21 Logged-in Username (2nd half) sixbit chars
JBTSLM::BLOCK	JOBN	; Console settable TRU limit     - Frame global
JBTLIM::BLOCK	JOBN	; Console/UUO settable TRU limit - Process local

JBTDLK::BLOCK	JOBN	;LOOKUPS
JBTERN::BLOCK	JOBN	;ENTERS AND RENAMES
JBTSLK::BLOCK	JOBN	;LOOKUPS*SIZE
JBTSER::BLOCK	JOBN	;ENTERS AND RENAMES*SIZE
JBTSIN::BLOCK	JOBN	;DISK BLOCKS READ*SIZE
JBTSOT::BLOCK	JOBN	;DISK BLOCKS WRITTEN*SIZE
JBTCIN::BLOCK	JOBN	;CHRS IN
JBTCOT::BLOCK	JOBN	;CHRS OUT
JBTELP::BLOCK	JOBN	;ELAPSED TIME*SIZE
JBTCNK::BLOCK	JOBN	;CONNECT TIME (DETACHED NOT COUNTED)
JBTBCS::BLOCK	JOBN	;BREAK CHRS *SIZE
JBTSOK::BLOCK	JOBN	;FROM SOAKEM UUO
JBTCMP::BLOCK	JOBN	;MICRO CYCLES FROM DK10
JBTCP2::BLOCK	JOBN	;HIGH ORDER PART OF MICRO CYCLES
JBTCPU::BLOCK	JOBN	;HIGH ORDER BITS OF MICRO CYC*SIZE

JBTABT::BLOCK	JOBN	;ROUTINE TO CALL ON SWAP ERROR OR ILL MEM REF


JBTBET::BLOCK	JOBN		;ELAPSED TIME IN BLOCK I/O MODE (IN SECONDS)
JBTBIO::BLOCK	JOBN		;BIO CHARS IN/OUT

JBTAJF::BLOCK	JOBN		;# FAULTS FOR PAGES IN UWS BUT NOT
				;IN MWS (# FAULTS CCAUSED BY MWS
				;ADJUST ALGORITHM)

JBTSCA::BLOCK	JOBN			;TRU scaling word

JBTENB::BLOCK	JOBN	;CHANELS ENABLED. BIT 0 IS 1 IF PI SYSTEM
			;IS ENABLED, BITS 1-35 INDICATE CHANELS ENABLED

JBTPIP::BLOCK	JOBN	;CHANELS IN PROGRESS. BITS 0 INDICATES
			;OLD APRENB SYSTEM. IF BIT 0=1 BITS 1 IS TRAP
			;IN PROGRESS. IF BIT 0=0 BITS 1-35 ARE THE
			;CHANELS IN PROGRESS

JBTAWQ::BLOCK	JOBN	;CHANELS AWAITING REQUEST. IF BIT0=1
			;MEANS TAKE A TRAP AS SOON AS POSSIBLE
			;IF OLD STYLE APRENB, ALL BITS BUT BIT 0 USED
			;TO STORE FLAGS GIVING REASON FOR TRAP

;THIS MAY NOT GO AWAY

;BITS 0-5 UUO TRAP NUMBER
;BITS 6-11 CLOCK TRAP NUMBER
;BITS 12-17 PAGE TRAP NUMBER
;BITS 18-23 HUNG DEVICE TRAP NUMBER
;BITS 24-29 TIMER TRAP NUMBER
;BITS 30-35 DEVICE ERROR TRAP NUMBER

JBTPRV::BLOCK	JOBN		;PRIVILEGE BITS FOR JOB SET BY LOGIN

QUEPCB::BLOCK	JOBN		;PCBIO DATABASE AREA.
JBTPCB::BLOCK	JOBN		;FOR LAYOUT, SEE PCBIO MODULE.

JBTCLB::BLOCK	JOBN		;TABLE USED BY THE CLUB FACILITY

JBTINA::BLOCK	JOBN		;INACTIVITY TIMEOUT
				;LH - LIMIT
				; NOTE THAT THIS FIELD IS MUCH LARGER THAN
				; IT NEEDS TO BE
				;RH - # MIN SINCE JOB LAST RAN

JBTPC::	BLOCK	JOBN		;LH=DDB, RH=PC, for Control-T

;THE FOLLOWING ARE USED TO CREATE MXQUE
;THE MAXIMUM QUEUE SIZE, USED BY SWAPPING SCHEDULER (SCHED)
	XP	MXQUE,0

	DEFINE	X	<MXQUE==MXQUE+1;>
	QUEUES
DEFINE	X	(A)

		<A'Z==MXQUE
		MXQUE==MXQUE+1;>
	CODES
		MXQUE==MXQUE+4

	BLOCK	MXQUE		;NUMBER OF QUEUES FOR SWAPPING SCHEDULER
JBTQ::	BLOCK	JOBN		;ONE ENTRY PER JOB,
				; LH=PREVIOUS JOB, RH=NEXT JOB IN QUEUE
				; NEGATIVE MEANS THIS IS FIRST (LH) OR LAST (RH)
				; JOB IN QUEUE
	JBQMN==:JBTQ-NULZ	;J1
;DISK JOB TABLES (FORMERLY IN COMMOD)

JBTRCT::BLOCK	JOBN	;NO. OF DISK BLOCKS READ ON ALL STRS SINCE JOB LOGGED IN
			;JOB 0 = SWAP READ ON ALL UNITS
			; ACTUALLY IT IS A COPY OF THE LOW ORDER 12 BITS
			; OF THE ACCUMULATED READS FOR THIS JOB.
			; IT IS RESET TO NEW LOW ORDER TOTAL AFTER EVERY
			; "DISK" COMMAND.  IN THIS WAY ONLY ONE COUNT NEED
			; BE INCREMENTED EVERY READ INSTEAD OF TWO.
			; INCREMENTAL DISK BLOCKS READ IS COMPUTED BY:
			;  LDB T1,JBYRCT;LDB T2,JBYIRD;DPB T1,JBYIRD;SUB T1,T2
			;  ANDI T1,JBRIRD
  JBSIRD==^D12		;BYTE SIZE
  JBNIRD==^D11		;BYTE PTR POS.
  JBRIRD==:1_JBSIRD-1	;BITS IN BYTE AFTER RIGHT JUSTIFIED
  JBSRCT==^D24		;BYTE SIZE
  JBNRCT==^D35		;BYTE PTR POS
JBTWCT::BLOCK	JOBN	;NO. OF DISK BLOCK WRITTEN ON ALL STRS SINCE JOB LOGGED IN
			;JOB 0=SWAP WRITE ON ALL UNITS
  JBSIWT==^D12		;BYTE SIZE
  JBNIWT==^D11		;BYTE PTR POS
  JBRIWT==:1_JBSIWT-1	;BITS IN BYTE AFTER BEING RIGHT JUSTIFIED
  JBSRCT==:^D24		;BYTE SIZE
  JBNRCT==^D35		;BYTE PTR POS


JBTMPC::BLOCK	JOBN	;NO. OF PAGES MAPPED BY USER DOING A MAP UUO

JBTPWS::BLOCK	JOBN	;NO. OF PAGES USER HAS PUT INTO THE UWS.

JBTPWH::BLOCK	JOBN	;HIGH PART OF NO. PAGES INTO UWS TIMES SIZE.

JBTPWL::BLOCK	JOBN	;LOW PART OF NO. PAGES INTO UWS TIMES SIZE

  XP DABSIZ,2	;LOADER will complain if this does not match COMMOD
JBTDAB::BLOCK	<JOBN-1>*DABSIZ ;DUMMY ACCESS TABLES. SEE ATB DEFINITIONS
			; FOR DATA FORMAT.
;THE FOLLOWING GLOBALS ARE USED IN VARIOUS ROUTINES SUCH AS
;ONCE,SCNSER,ETC.

IFNDEF PPORTN,<XP PPORTN,<<<JOBN/4>+7>*2>>;32 pairs if JOBN=^D100
IFNDEF RPORTN,<XP RPORTN,PORTN-PPORTN>
IFNDEF PORTN,<XP PORTN,RPORTN+PPORTN>
IFG <PORTN-^D255>, <
	PRINTX MORE THAN 255 PORTS!!!
	STOPI>
IFL <RPORTN-^D11>, <
	PRINTX MUST HAVE AT LEAST 11 REAL PORTS
	STOPI>
RPORTN==:RPORTN		;Show values in CREF listing
PPORTN==:PPORTN		;Show values in CREF listing
PORTN==:PORTN		;Show values in CREF listing

XP RMXLIN,RPORTN-1	;"REAL" PORT #S ARE BELOW RPORTN,
			;PTY PORT #S ARE ABOVE RMXLIN

SCNN==<JOBN/4>+PORTN+1	;Number of TTY DDBs - enough for detached jobs
			; plus all ports (TTY, AUX CIR, PTY, CTY).
IFG <SCNN-^D255>,<
IF2,<PRINTX More than 255 TTY DDBs requested - allocating 255 only.>
SCNN==^D255>
XP MXLIN,PORTN-1
NFLG==<PORTN+^D36>/^D36
XP NMXFLG,-NFLG
XP NMXLIN,-PORTN
XP LINMXL,<<MXLIN>B26>

ACTN==1			;NUMBER OF ACCOUNTING DDBS
;TTYTAB IS A TABLE OF CONTROLLING (ATTACHED) TTY'S FOR EACH JOB,
;INDEXED BY JOB NUMBER. IF C(TTYTAB)=0 THEN NO TTY IS ATTACHED.
;OTHERWISE, RH(TTYTAB(N)) IS CONTROLLING DDB FOR JOB N.

TTYTAB::BLOCK JOBN

;COMFLG is a bit table with one bit per frame, indicating whether
; there is a command pending for that frame.  Whenever the
; COMFLG bit is set for a particular frame, the "command
; request" bit (CMDCMR) in the left half of TTYTAB should also
; be set.
CFLG==<JOBN/^D36>+1	;Number of entries in COMFLG table
XP NCMFLG,-CFLG
COMFLG::BLOCK	CFLG
	INTERN NCMFLG

	SYSEND=:.-1		;END OF CLEARED STORAGE ON RESTART
SUBTTL	ONCE ONLY CODE TO CREATE DEVICE DATA BLOCKS

	LOC SYSBG2		;PUT IN SYSTEM DATA AREA SO NOT TO TAKE
				; VALUABLE SPACE.  THIS AREA IS CLEARED
				; BY SYSINI AFTER IT HAS BEEN EXECUTED

COMMENT ! ROUTINE LINKDB
FUNCTION:  ONCE-TIME CODE TO ALLOCATE / CREATE / LINK DEVICE DDB'S,
FILSER CORE BLOCK, TTY DDB'S, AND VARIOUS OTHER SYSTEM DATA AREAS.
JSR HERE FROM ONCE CODE.

!

LINKDB::0
				;SO THAT E.G. SAT TABLES MAY BE SCANNED
				; BE OVERLAYED BY MULTIPLE DEVICE DATA
				; BLOCK GENERATION)

PRINTF(<[LINKDB: Store STRNAM of only STR in QUESTR]>)
	MOVE	T1,STRNAM##+STRDDB## ;STORE ADDR OF FASTEST (ONLY)
	MOVEM	T1,QUESTR##	;STR FOR QUEUEING CUSPS.

	MOVSI	P1,INTNUM	;NEG NUMBER OF ENTRIES IN TABLE
	MOVEI	F,DEVLST-DEVSER ;MAKE DEVLST LOOK LIKE DEVSER IN A DDB
LOOP:	MOVE	P2,INTTB1(P1)	;GET NEXT DEVICE DATA BLOCK ADDRESS
	JUMPE	P2,NEXT		;0 MEANS NO DOB FOR DEVICE
	CAIN	F,(P2)		;IS THIS THE SAME AS LAST TIME (DSK)
	 JRST	NEXT		;YES, IGNOREM
	MOVE	M,DEVMOD(P2)
	TLNN	M,DVTTY		;IS IT TTY
	 JRST	NTYLNK		;NO
	MOVEM	P2,FRETTY##
	MOVEM	F,TTYFLK##
	JRST	TTYLNK

NTYLNK:	HRLM	P2,DEVSER(F)	;YES, STORE IN PREVIOUS DEVICE DATA BLOCK
TTYLNK:	HRRZ	F,P2		;MAKE F POINT TO CURRENT DOB
	LDB	M,[POINT 8,INTTAB(P1),8] ;GET NUMBER OF DDB'S
	HLRZ	U,DEVSER(F)	;MULTI FT'S ARE ALREADY LINKED.
	JUMPE	U,NOTFT
	HRRZI	F,(U)		;FT.
	HLRZ	U,DEVSER(F)	;FIND
	JUMPN	U,.-2		;LAST
	JRST	NEXT		;ONE.

NOTFT:	SOJLE	M,NEXT		;ONE OR LESS ?
	HRRZ	U,F		;NO, CREATE MULTIPLE COPIES OF DOB
				; SAVE ORIGINAL IN U
	MOVEI	P3,1		;STARTING WITH DEV1,DEV2,DEV77
	LDB	P4,PUNIT	;START UNIT NUMBER FROM
				; ASSEMBLE DEVICE DATA BLOCK
				; PTY STARTS UNIT NUMBER AT 1 INSTEAD OF 0
				; ALTHOUGH DEVICE NAMES ARE PTY0,PTY1,ETC.

MULDDB:	HLRZ	T2,INTTB1(P1)	;Size of these DDB's
	PUSHJ	P,EVMALC##	;Allocate EVM for new DDB
	HRLM	T1,DEVSER(F)	;Point previous DDB to new one
	HRL	F,U		;Set up BLT word
	HRR	F,T1		;Make new DDB the current one
	ADDI	T1,(T2)		;Last word to be BLT'ed +1
	MOVE	T3,F		;KL SMASHES BLT AC
	BLT	T3,-1(T1)	;MOVE ORIGINAL TO FREE STORAGE
	MOVE	PG,[POINT 6,DEVNAM(F),17] ;BYTE POINTER TO NEWLY CREATED
				; DDB PHYSICAL NAME
	MOVE	J,P3		;MAKE COPY OF UNIT NUMBER
	TRNN	J,70		;IS IT 10 OR MORE ?
	 JRST	SMALL		;NO
	ROT	J,-3		;YES, CONVERT HIGH ORDER OCTAL DIGIT TO
	ADDI	J,20		;SIXBIT
	IDPB	J,PG		;AND STORE
	TRZ	J,-1		;CLEAR OUT HIGH ORDER DIGIT
	ROT	J,3		;MOVE LOW ORDER DIGIT BACK
SMALL:	ADDI	J,20		;CONVERT LOW ORDER DIGIT IN SIXBIT
	IDPB	J,PG		;AND STORE IN PHYSICAL NAME
	ADDI	P4,1		;INCREMENT BINARY UNIT NUMBER
	DPB	P4,PUNIT	;STORE UNIT NUMBER
	CAIGE	P3,(M)		;COMPARE WITH HIGHEST DEVICE NUMBER
	AOJA	P3,MULDDB	;DO ANOTHER COPY
	HRRZS	DEVSER(F)	;REMOVE THE LINK
	PFALL	NEXT
NEXT:	MOVE	P3,DEVMOD(F)
	TLNE	P3,DVTTY
	 MOVE	F,TTYFLK##	;NO BACK TO REAL LINKING
	AOBJN	P1,.+1		;MOVE BY TWOS
	AOBJN	P1,LOOP		;ANY MORE DEVICES

;End of DDB loop

	MOVEI	P1,0		;NO, FLAG END OF DDB CHAIN WITH 0 LINK
	HRLM	P1,DEVSER(F)	;YES, STORE 0 IN CASE LAST DDB IS MULTIPLE
TMPALC:	MOVEI	T2,TMPSZT	;Total storage for TMPINI
	PUSHJ	P,EVMALC##	;Allocation base address returned in T1
	HRLI	T1,TMPSZ
	MOVEM	T1,TMPTAB##	;FREE DATA SPACE,ADDRESS OF TABLE
	HRLZI	T1,TMPSZJ
	HRRI	T1,TMPBKS
	MOVEM	T1,TMPTAB##+1	;USER QUOTA,NUMBER OF BLOCKS IN AREA

;FOLLOWING CODE ALLOCATES SPACE FOR THE LINE DATA BLOCKS & FOR CHARACTER LISTS

LINALC:	HLRZ	T2,TTCLST	;Number of bufferlets
	IMULI	T2,TTCHKS	;Times chunk size
	ADDI	T2,3		;In case misaligned
	PUSHJ	P,EVMALC##	;Allocate storage
	ADDI	T1,3
	TRZ	T1,3		;MAKE SURE A MULTIPLE OF 4
	HRRM	T1,TTCLST	;SAVE AS FIRST CHARACTER CHUNK ADDR

LDBALC:	MOVSI	J,-PORTN-1	;Enough for 0 through PORTN
	MOVEI	T2,LDBLEN##	;Constant throughout loop
TTY0:	SKIP	T1,[CTYLDB##]	;Make TTY0 be the CTY
  PRINTF(<[Need to change SKIP to SKIPA at TTY0: for CTY]>)
LNKTTL:	PUSHJ	P,EVMALC##	;Allocate one LDB (Size in T2)
	HRRM	T1,LINTAB(J)	;Store address into table
	SKIPN	LDBVRG		;First LDB?
	 HRRZM	T1,LDBVRG	;Yes, store in CONFIG table item 150
	HRLI	U,CTYLDB##	;GET THE ADR OF THE PROTO LDB
	HRRI	U,(T1)		;Rest of BLT word
	ADDI	T1,(T2)		;Last word of BLT target + 1
	MOVE	T3,U		;KL SMASHES BLT AC
	BLT	T3,-1(T1)	;COPY THE LDB
	DPB	J,LDPLNO##	;STORE PHYSICAL LINE NUMBER IN LDB
	AOBJN	J,LNKTTL	;NO. MAKE ANOTHER ONE

;ALLOCATE BUFFER FOR SNOOP HISTOGRAMS, IF ANY DESIRED

SNBALC:	SKIPN	T2,HFDBUF	;SIZE NONZERO IN LH?
	 JRST	NOSNBF		;NO, ALLOCATE NOTHING FOR SNOOPING
	HLRZS	T2		;T2/0,,MAX HISTOGRAM SIZE FOR SNOOPING
	PUSHJ	P,EVMALC##	;Returns base address in T1
	HRRM	T1,HFDBUF	;HFDBUF/SIZE,,BEGINNING LOCATION
NOSNBF:	;DONE SNOOP BUFF ALLOC
;ALLOCATE CORE BLOCKS
ND FFCBLK,<JOBN*<2+<2*OPNFPF>>>;  FILSER FREE CORE BLKS SYSTEM-WIDE. FOR
			;  EACH JOB ASSUME 2 DRB'S (LOGGED-IN AND GFD'D
			;  DIRECTORY).  FOR EACH OF THE OPNFPF FILES
			;  ASSUMED, EXPECT 1 ATB AND 1 FNB.
IFL FFCBLK-^D50,<FFCBLK==^D50>	;INSURE AT LEAST 50 FILSER BLOCKS
				; EVEN IF JUST A 1 JOB SYSTEM

FILALC:	SKIPN	T2,CORNUM##	;Number of core blocks
	 MOVEI	T2,FFCBLK	;Use calculated value if not patched in
	MOVEM	T2,CORNUM##
	IMULI	T2,CMBSIZ##	;Times block size gives total storage
	PUSHJ	P,EVMALC##	;Allocate, returns base in T1
	MOVEM	T1,CORBAS##	;REMEMBER START OF FILSER FREE CORE SO CAN
				; COMPUTE ATB POINTERS, WHICH ARE RELATIVE.
	HRLZM	T1,SYSCOR##	;FIRST FREE FILSER CORE BLOCK
	MOVE	T2,CORNUM##	;GET # OF BLOCKS TO BE GENERATED
	ADDI	T1,CMBSIZ##	;COMPUTE ADR. OF NEXT BLOCK
	HRLZM	T1,-CMBSIZ##+CMBLNK##(T1) ;YES - SAVE ADR. OF NEXT BLOCK IN THIS BLOCK
	SOJG	T2,.-2		;FINISHED YET?
	SETZM	-CMBSIZ##+CMBLNK##(T1)	;YES - ZERO LINK IN LAST BLOCK TO SIGNALEND OF LIST
	JRST	@LINKDB		;RETURN TO CALLER

NRSVDP::0			;Number of pages actually reserved by ONCE
RSVDPG:: ;*;PRINTF(<[RSVDPG - reserving pages at 1 meg boundries for SA10 bug]>)
;*;	EXP 03777,04000		;*HACK* 1 page before and after 1 meg boundry
;*;	EXP 07777,10000		;*HACK* to get around SA10 bug that affects
;*;	EXP 13777,14000		;*HACK* systems with more than 1 meg of core
;*;	EXP 17777		;*HACK* (removed 20-Mar-87)
;*;	EXP 775,776,777		;Last 3 unmapped pages reserved for BOOTS
	EXP 0			;Zero marks end of list

;Here from the DEBUG command in ONCE

ODEBUG::MOVSI	T1,(1B0)	;Set the sign bit in DEBUGF
	IORM	T1,DEBUGF
	MOVSI	T1,(JFCL)	;Disable Keep-Alive-Failure
	HLLM	T1,KAF
	MOVEI	T1,[ASCIZ /Use 1^B if you want to set DDT break point
/]
	PUSHJ	P,CONMES##	;Output message to console
PRINTF(<[ODEBUG routine could use more work]>)
				;Insert code to do 1^B to set EDDT breakpoints
	POPJ	P,
;MORE PARAMETERS FOR TEMPORARY IN-CORE FILE STORAGE FOR SHORT (CCL) FILES

TMPNX==JOBN*^D20		;IF SIZE OF SPACE NOT SET, DEFAULT VALUE
TMPBKS==<TMPNX+TMPBL>/<TMPBL+1>	;NUMBER OF BLOCKS (LINKED LIST) IN AREA
TMPSZ==TMPBKS*TMPBL		;NUMBER OF DATA WORDS AVAILABLE
TMPSZT==TMPBKS*<TMPBL+1>	;TOTAL TABLE LENGTH (ROUNDED)
TMPBKJ==<<^D60+TMPBL>/<TMPBL+1>> ;USER SPACE QUOTA. DEFAULT VALUE
TMPSZJ==TMPBKJ*TMPBL		;QUOTA OF DATA WORDS PER USER


				; (DO NOT DESTROY ONCE)
				; FLAG NON-ZERO IF CALLED BY JRST LINKDB
				; (OK TO DESTROY ONCE CODE)

DDSTAR::Z		;STARTING ADDR OF STR DATA BLOCKS ETC. IN HIGH CORE
			;(USED BY ONCMOD AND REFSTR)
;;MACROS TO DEFINE PI CHANNEL NUMBER AND GENERATE INTERRUPT CHAINING
;; INFORMATION FOR ONCE SO IT CAN LINK THE DEVICE INTERRUPT SERVICE
;; ROUTINES AND THE DEVICE DATA BLOCKS

;;TABLE INTTAB IS GENERATED WITH PAIRS OF ENTRIES FOR EACH DEVICE
;; WHICH HAS A DEVICE DATA BLOCK
;;FIRST WORD: BIT 0==1 IF DECTAPE, BITS 1-9==NUMBER OF DDBS, BITS 9-17==PI
;; CHANNEL (0-7) WHERE 0 MEANS NO PI CHANNEL (E.G., PTY)
;;SECOND WORD: LH==0 IF SINGLE DEVICE,==LENGTH OF DDB IF MULTIPLE, RH==DDB ADDRESS

;;MACRO FOR DEVICES WHICH ARE ALWAYS PRESENT (AND WHICH DO NOT USE A
;; CHANNEL SAVE ROUTINE AND HAVE NO DDB)  EXAMPLES ARE APR, CTY, PEN, CLK...

;DEFINE SPASGINT (DEV,PI) <
;	DEV'N==1
;			ASGINT DEV,PI
;>

DEFINE ASGINT (DEV,PI) <
	IFG DEV'N, <IFG PI, <
	IFE <PI-.CH>, <.CHAS==1		;;CHANNEL PI IN USE.
>
	UNASS'PI==0		;;MARK CHANNEL AS ASSIGNED
	DEV'CHN==:PI		;;DEFINE INTERNAL PI CHAN FOR DEV'CHN
	XWD	PI,DEV'INT##	;;GENERATE INT SERVICE CONSO ENTRY FOR ONCE
	XWD	0,0		;;NO DDBS TO CHAIN TOGETHER
	ASGIN1 DEV,\PI
>>
>

DEFINE ASGIN1 (DEV,PI) <
IFDEF CH'PI,<			;;WAIT TILL PASS 2 TO DEFINE
	DEV'CHL==:CH'PI		;;DEFINE INTERNAL DEV'CHL
>>

;;MACRO FOR OPTIONAL DEVICES WHICH ALWAYS USE A CHANNEL SAVE ROUTINE
;; (EXAMPLES: CDR, DSK, PTR, ETC.  ALSO PTY WITH 0 PI)

;DEFINE SPASGDDB (DEV,PI,NUM) <
;	DEV'N==NUM
;	NOSAV==1
;	ASGSAV DEV,PI
;>
DEFINE ASGSAV (DEV,PI) <
	IFG DEV'N, <IFG PI, <
	UNASS'PI==0		;;MARK CHANNEL AS ASSIGNED
IF2, < IFNDEF DEV'INT, <EXTERNAL DEV'INT>>	;;INTERRUPT SERVICE CONSO INSTRUCTION
>
IF2, < IFNDEF DEV'DDB, <EXTERNAL DEV'DDB>>	;;DEVICE DATA BLOCK ADDRESS
	ASGSV1 DEV,\PI
	>>

;;MACRO FOR:	1. COMPLETION OF THE DEFINITION REQUIRED FOR THOSE
;;		   DEVICES INVOKING THE ASGSAV MACRO
;;		2. COMPLETE DEFINITION FOR THOSE DEVICES WITH THEIR INTERRUPT
;;		   ENTRY POINT AND DDB'S HERE IN COMMON  (EXAMPLE: LPT'S)

DEFINE ASGSV1 (DEV,PI) <
	IFG PI,<
	IFE <PI-.CH>,<.CHAS==1>		;;CHANNEL PI IN USE.
		DEV'CHN==:PI		;;DEFINE DEVICE CHANNEL NUMBER
	IFE NOSAV,<ASGSV2 DEV,PI>
	>

	DTBIT==0			;;ASSUME THIS IS NOT A DECTAPE
	IFIDN <DEV> <DTA>, <DTBIT==1>	;;IS IT P-10 DECTAPES ?
	IFIDN <DEV> <DTC>, <DTBIT==1>	;; OR P-6 DECTAPES ?

	IFE PI,<XWD DEV'N*1000+0,0>	;;NO PI CHANNEL FOR THIS DEVICE
	IFG PI, <
	    XWD DTBIT*400000+DEV'N*1000+PI,DEV'INT	;;FIRST WORD OF INTTAB ENTRY
	    IFE DEV'N,<EXTERNAL DEV'INT> ;;LEVEL D DISK IN COMMOD
	>

	IFG DEV'N-1,<XWD DEV'DDS##,DEV'DDB> ;;MULTIPLE DEVICE 2ND WRD OF INTTAB ENTRY
	IFE DEV'N-1,<XWD 0,DEV'DDB>	;;SINGLE DEVICE 2ND WRD OF INTTAB ENTRY

	IFE DEV'N,<
	0	;NO DDBS FOR DISK
		DEFBIT DEV
		DSKPIF==DSKPIF!DEV'BIT ;;KEEP LOG. OR OF PI OFF BIT FOR DSK CONTROLLERS
		DSKPIN==DSKPIN!DEV'BIT ;;AND FOR PI ON
	>
>		;;END ASGSV1 DEFINITION
;;MACRO'S TO ALLOW GENERATION OF MULTIPLE INTTAB ENTRIES FOR MULTIPLE
;; DEVICES SUCH AS LINE-PRINTERS

DEFINE MULASG (DEV,DE,PI,DSKFL) <
	IFG DEV'N, <
		UNASS'PI==0		;;MARK CHANNEL AS ASSIGNED
		ZZ==0
		REPEAT DEV'N, <
			DEVASG DE,\ZZ,PI,DSKFL
			ZZ==ZZ+1
		>
	>
>

DEFINE DEVASG (DE,X,PI,DSKFL) <
	IFE DSKFL,<DE'X'N==1
		ASGSV1 DE'X,\PI>
	IFL DSKFL,<DE'X'N=0	;-VE MEANS NO DDB GENERATED HERE
		ASGSV1 DE'X,\PI>
	IFG DSKFL,<	;DISK
		NMCLC (XX,DE,X,<A,B,C,D,E,F,G>)
		IFN XX,<DE'X'N==0	;SOME UNITS ON CONTROLER
			ASGSV1 DE'X,\PI>>>

;;MACROS TO CONTROL ASSIGNMENT OF PI CHANNELS TO DEVICES

DEFINE NEXTCH < .CH==.CH+1		;;START ASSIGNING TO NEXT LOWER CHANNEL
.CHAS==0
NEXTCU \.CH	
>
DEFINE NEXTCQ <	IFN .CHAS, <NEXTCH>>	;;START ASSIGNING TO NEXT LOWER CHANNEL IF
					;; CURRENT CHANNEL HAS BEEN USED.
DEFINE NEXTCU (N) < IFDEF UNIQ'N, < IFN UNIQ'N, <NEXTCH>>>	;;TO SKIP OVER ANY
					;; SPECIALLY SPECIFIED CHANNELS (RECURSIVELY!)

DEFINE DEFBIT (DEV) <
	DEV'BIT==1
	REPEAT 7-DEV'CHN, <DEV'BIT==DEV'BIT*2>
>

;;INITIALLY ASSUME NO PI CHANNEL SAVE ROUTINES NEEDED

	USED1==0
	USED2==0
	USED3==0
	USED4==0
	USED5==0
	USED6==0
	USED7==0

;;ALL CHANNELS ARE INITIALLY UNASSIGNED

	UNASS1==1
	UNASS2==1
	UNASS3==1
	UNASS4==1
	UNASS5==1
	UNASS6==1
	UNASS7==1
;MACRO TO ALLOW GENERATION OF CHANNEL SAVE ROUTINES ONLY

;DEFINE SPASGSAV (DEV,PI,%ACNUM) <
;	HIGAC'PI==%ACNUM
;	DEV'HAC==%ACNUM
;INTERNAL HIGAC'PI,DEV'HAC

;	ASGSV2 DEV,PI
;>

DEFINE ASGSV2 (DEV,PI) <
		USED'PI==1		;SET FLAG SO THAT A CHANNEL SAVE
					; ROUTINE WILL BE GENERATED FOR
					; THIS PI CHANNEL

IFDEF DEV'ACB,<;DEFINED IF A KL10 AND AC BLOCK ALLOCATED TO THIS DEVICE'S CHANNEL
	IFDEF ACBPI'PI,<IFN DEV'ACB-ACBPI'PI,<PRINTX CONFLICTING AC BLOCK ASSIGNMENTS
		STOPI>>
	ACBPI'PI==<DEV'ACB>	;NEGATIVE IS FLAG FOR CHANNEL
				; MACROS TO GENERATE DIFFERENT CODE.
>;END IFDEF DEV'ACB

	IFDEF SAV'PI, <		;WAIT TILL CHANNEL SAVE ROUTINES
					; ARE DEFINED BELOW (IN PASS 2)

		DEV'SAV==SAV'PI		;CHANNEL AC SAVE ROUTINE LOCATION
		DEV'RET==RET'PI		;CHANNEL AC RESTORE ROUTINE LOCATION
					; (USUALLY POPJ USED)
		DEV'CHL==CH'PI		;LOCATION WHERE INTERRUPT PC IS STORED
		DEV'SAC==SAVAC'PI	;STARTING CHANNEL SAVE LOCATION FOR AC'S
		DEV'P==CH'PI'P	;LOCATION WHERE P STORED
		DEV'JEN==CH'PI'JEN	;LOCATION WHERE INT. IS DISMISSED

		INTERN DEV'SAV, DEV'RET, DEV'CHL, DEV'SAC,DEV'P,DEV'JEN
>>
;NOW GENERATE THE TABLE FOR ONCE AND DEFINE PI CHANNEL ASSIGNMENTS

	INTERNAL INTTAB,INTTB1,INTNUM,SCNN,DSKPIF,DSKPIN

				; ONE FOR EACH JOB + NULL JOB (EXTRA ONE)
		APRN==1		;ALWAYS AN APR
		CLKN==1		;ALWAYS LOWEST PRIORITY CLOCK
IFCPU (KI),<;DK10 ONLY AVAILABLE ON KI10
		TIMN==1		;ALWAYS A DK10
		TM2N==1		;SECOND DK-10 FOR TIMING
>;END IFCPU (KI)

IFCPU (<KI,KL,F3>),<
	DSKPIN==LI.CON	;SET PI ON BIT - WILL ALSO HAVE PI ON FOR DISK CONTOLLERS
	DSKPIF==LI.COF	;AND FOR PI OFF
> ;END IFCPU KI,KL,F3

INTTAB:			;TABLE OF DATA FOR DEFINING PI CHAN AND NUMBER OF DOB
	NOSAV==0	;DO NOT SUPPRESS GENERATION OF SAVE ROUTINES
	INTTB1==INTTAB+1

	ASGSAV SCN,0	;NO PI CHANNEL FOR SCNSER (AT CLOCK)
	ASGSAV ACT,0

.CHAS==0
.CH==0
NEXTCH		;BEGIN AT CHANNEL 1

IFCPU (<KI,KL,F3>),<
;THE FOLLOWING DEVICES MUST HAVE A UNIQUE, HIGH PRIORITY
; CHANNEL FOR BLOCK I/O TRANSFERS.


IFNDEF BLKMXC, <BLKMXC==.CH>	;REMEMBER THIS CHANNEL ON PASS 1
.CH==BLKMXC			;ON PASS 2, SKIP OVER BLKI CHANNELS


;THE FOLLOWING ARE GROUPED ON A CHANNEL FOR HIGH-PRIORITY DEVICES
	ASGSAV CDR,\.CH
> ;END IFCPU KI,KL,F3
	ASGINT APR,\.CH
IFCPU (KI),<;DK10S ONLY EXIST ON KI
	ASGINT TIM,\.CH
	ASGINT TM2,\.CH
>;END IFCPU (KI)

NEXTCQ

IFCPU (<KI,KL,F3>),<
;THE FOLLOWING ARE MEDIUM-PRIORITY DEVICES, AS A GROUP
	ASGSAV PTR,\.CH
	MULASG LPT,LP,\.CH,0
;	ASGSAV DTA,\.CH
;	ASGSAV DTC,\.CH
;	ASGSAV MTA,\.CH
;	ASGSAV MTB,\.CH
;	ASGSAV MTC,\.CH

NEXTCQ
;THE FOLLOWING ARE LOWER-PRIORITY DEVICES, AS A GROUP
				;FIRST ARE THE VARIOUS TYPES OF DISK CONTROLLERS....

	MULASG FHD,FH,\.CH,1
	MULASG DPC,DP,\.CH,1
	MULASG SAX,SA,\.CH,-1
	MULASG APX,AP,\.CH,-1
IFN SAXN,<SAXCHN==:SA0CHN
	  SAXSAV==:SA0SAV>
IFN APXN,<APXCHN==:AP0CHN
	  APXSAV==:AP0SAV>
	ASGSAV DSK,0	;GET DSK IN CHAIN, NO INTERUPT CODE (SEE ABOVE
	ASGSAV MAG,\.CH


DEFINE MNYASG(DE,UU)
<IRP UU,<IFNDEF DE'UU'UN, <STOPI>
	 IFDEF DE'UU'UN, <DE'UU'N==DE'UU'UN
			  ASGSAV DE'UU,0
			 >
	>
>

MNYASG(FT,<A,B,C,D,E,F,G,H,J,K,L>)	;ASGSAV for FTA, FTB, FTC, etc

;	ASGSAV PEN,\.CH
	ASGSAV PTP,\.CH
;	ASGSAV CDP,\.CH
	ASGSAV PLT,\.CH

NEXTCQ

;THE DISPLAY GETS ITS OWN LOW-PRIORITY CHANNEL
;	ASGSAV DIS,\.CH

NEXTCQ
> ;END IFCPU KI,KL,F3

IFCPU (KS),<

;GEN INTTAB ENTRIES OF FORM: NO. OF DDBS, DEVINT
;			LENGTH OF DDBS , PROTOT DDB ADDR.
DEFINE GENDDB (DEV) <
	IFG DEV'UN,<
		EXTERN DEV'INT,DEV'DDS,DEV'DDB
		XWD DEV'UN*1000,DEV'INT
		XWD DEV'DDS,DEV'DDB>
> ;END DEF OF GENDDB.

;SET THE INTTAB ENTRY FOR THE DISK

	XWD	0,RMXINT##	;WORD 1 OF INTTAB
	0

	ASGSAV DSK,0
IFN LPTN,<1*1000,,0
	LP0DDS,,LP0DDB>

IFCPU(KS),<
	0,,MAGINT##		;Entry for tapes.  Note 0 "units" indicates
	MAGDDS##,,MAGDDB##	; the DDBs are already linked.
>;IFCPU(KS)END

PIHIGH==:3	;PI FOR DISK AND TAPE.
PILOW==:2	;PI FOR OTHER DEVICES.

	DSKPIF==LI.COF!<1_<7-PIHIGH>>
	DSKPIN==LI.CON!<1_<7-PIHIGH>>
> ;END IFCPU KS.
;LAST IS THE SCHEDULER, ON CHANNEL 7 BY ITSELF

IFG <.CH-7>, <	PRINTX ;NOT ENOUGH PI'S TO SERVICE THIS CONFIGURATION.
		PRINTX ;SUGGEST EDITING COMMON TO PUT MORE DEVICES ON
		PRINTX ; A SINGLE CHANNEL
>

.CH==7
	ASGINT CLK,\.CH

;	SPCINT
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NOT USE A CHANNEL SAVE ROUTINE AND HAVE
				; NO DEVICE DATA BLOCK
;	SPCDDB
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				;WHICH HAVE MULTIPLE DEVICE DATA BLOCKS (0 MEANS NONE)
;	SPCSAV
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NEED A CHANNEL SAVE ROUTINE

;END OF THE ASSIGNMENT TABLE

	INTNUM==INTTAB-.	;-LENGTH OF INTERRUPT CHANNEL ASSIGNMENT TABLE

XP ITMCHN,APRCHN		;INTERVAL TIMER PI ASSIGNMENT SAME AS THAT OF APR.

IFCPU (KS),<
RM0VEC=254
MAGVEC=224
;GEN DISPATCH VECTOR TABLE ENTRIES.
DEFINE GENVEC (DEV), <
	IRP DEV
		<IFG DEV'UN,<
			IFNDEF DEV'INT,<EXTERNAL DEV'INT>
			XWD DEV'INT,DEV'VEC/4
			>
>
>

TBISAV::GENVEC <RM0,LPR,MAG>
	TBISIZ==:.-TBISAV

;EPT+EPTVIT WILL BE THE REAL TABLE, NO CONFLICT ASSUMED
;  BETWEEN THE DEVICE VECTOR ADDRESSES AND EPT DEFINED SLOTS
>;END IFCPU KS


	IFLE .-SYSEND, <LOC SYSEND+1>
				; SET LOC UP TO SYSEND+1, UNLESS ONCE ONLY CODE
				; IS BIGGER
;SYSTEM CONSTANTS AND PARAMETERS

;; Negative indexes from CNFTBL are used by CRSHID and are not GETTAB-able.
;; Their position is subject to change and should not be published!

	CRSDB,,NUMTAB##		;(-2) so CRSHID can do "GETTABs"
CURUPT::0			;(-1) CONTAINS DATAO STUFF FOR CURRENT UPT

CNFTBL:: ;origin of GETTAB table 11 (configuration data)
	; octal numbers in () correspond to the index relative to CNFTBL
	; certain tools expect physical address 137 to point to CNFTBL
	; (these locations not cleared by SYSINI)
CONFIG::SYSNAM			;(0-4) NAME OF SYSTEM, IN ASCII
	LOC CONFIG+5		; ALWAYS LEAVE 5 WORDS (24 CHARS)
SYSDAT::SYSDAT			;(5,6) GENERATE SYSTEM DATE
	LOC SYSDAT+2		; ALWAYS LEAVE 2 WORDS (9 CHARS)
SYSTAP::SYSDEV			;(7) NAME OF SYSTEM DEVICE, IN SIXBIT
;LOCATIONS SETUP BY ONCE ONLY OPERATOR DIALOGUE AND NEVER RESET ON RESTARTS
TIME::	0			;(10) TIME OF DAY IN JIFFIES (60TH OR 50THS OF A SEC)
THSDAT::0			;(11) TODAY'S DATE (we use consecutive days since
				; 1-Jan-64, DEC uses ((Y-1964)*12+(M-1))*31+(D-1)
SYSSIZ::exp PATCH##		;(12) SIZE OF MONITOR (FIRST LOC NOT USED)
DEVOPR::sixbit /CTY/		;(13) SIXBIT PHYSICAL NAME OF OPERATORS CONSOLE
				; (IF THIS LOCATION CONTAINS 0, NONE HAS
				; BEEN DESIGNATED)
				; PUBLIC LOGICAL NAME "OPR" WILL BE THIS
				; DEVICE. ALSO UNEXPLAINED MONITOR ERROR
				; MESSAGES WILL BE TYPED ON TTY OPR:
DEVLST::xwd 0,0			;(14) LH CONTAINS ADDRESS OF FIRST DEVICE DATA BLOCK
				; ONCE ONLY CODE LINKS DEVICE DATA BLOCKS
	xwd 0,JOBN		;(15) AOBJN POINTER TO 1ST HIGH SEG IN JBTXXX TABLES
				; LH= - NUMBER OF HIGH SEGS,  RH= 1ST HIGH SEG NUMBER
	0			;(16) FLAG TO INDICATE WHETHER BOTH HARDWARE AND
				; SOFTWARE HAVE 2 RELOC REG CAPACITY
				; NON-ZERO IF BOTH DO, 0 IF EITHER OR BOTH DO NOT
				; SET BY ONCE ONLY CODE

;STATES WORD LH BITS:
	ZZ==0
	ZZ==ZZ!1B0		; 1 IF DISK SYSTEM (ANALOGOUS TO FTDISK)
	ZZ==ZZ!1B1		; 1 IF SWAPPING SYSTEM (ANALOGOUS TO FTSWAP)
	ZZ==ZZ!1B2		; 1 IF LOGIN (ANALOGOUS TO FTLOGIN)
	ZZ==ZZ!1B3		; 1 FOR TTCALL, FULL DUPLEX
	ZZ==ZZ!1B4		; 1 IF PRIVILEGE FEATURE INCLUDED
	ZZ==ZZ!1B5		; 1 IF REENTRANT SOFTWARE
	ZZ==ZZ!1B9		; 1 IF LEVEL D DISK SOFTWARE
				; 0 if level C, 2 if spooled disk
	IFN INDPPN,<ZZ==ZZ!1B10>; 1 IF INDEPENDENT PROJ-R NUMBERS
	ZZ==ZZ!1B11		; 1 FOR IMAGE, 8-BIT SCNSER
;B12-B17 defined for TOPS-10, not applicable to TYMCOM-X
	ZZ==ZZ!0B12		; 1 if dual processor system
	ZZ==ZZ!0B13		; 1 if TOPS-10 style multiple RIBs
	ZZ==ZZ!0B14		; 1 if high precision time accounting
;*;	ZZ==ZZ!1B15		; 1 if exclude monitor overhead from accounting
	ZZ==ZZ!0B16		; 1 if system includes real-time clock
;*;	ZZ==ZZ!1B17		; 1 if system built for FOROTS version 5A
				;Bit 17 is used as STAUTO, below

;STATES word, TOPS-10 RH bits:
;000001=1B35  no login except on CTY or subjob of OPSER
;000002=1B34  no login on "remote" lines (don't answer datasets)
;000004=1B33  batch jobs only
;000010=1B32  no logins from ANF10 or DECnet nodes
;000100=1B29  allow ASSIGN of restricted devices
;000200=1B28  allow unspooling for all users
;000400=1B27  no operator in attendance
;001000=1B26  no automatic reload of ANF-10 nodes (NETLDR program)

;STATES word, TYMCOM-X RH bits (defined in S.MAC):
;STAUTO	;1B17 System in auto-restart (note: this is an LH bit!)
;STSHUT	;1B18 System is shut
;STSUPR	;1B19 System is super-shut (don't allow shut-override)
;STRLB	;1B20 Restricted logins.  See LOGINN.MAC at NONRES-7
;STMDED	;1B?? IF CHKPNT WATCHDOG FOUND CHKPNT DEAD

STATES::exp ZZ!STAUTO!STSHUT!STSUPR ;(17) LH BITS=TYPE OF SYSTEM
				; RH PATCHED BY "SCHED" COMMAND TO
				; INDICATE OPERATIONAL STATE OF SYSTEM
SERIAL::exp <APRSN&777777>	;(20) SERIAL NUMBER OF CENTRAL PROCESSOR (APR)
				; GETS OVERWRITTEN BY APRID IN ONCE
MEMNSP::exp NSPMEM		;(21) NANO-SEC PER MEMORY CYCLE
FREPTR:: 0			;(22) AOBJN WORD POINTING TO USE BIT MAP OF
				; MONITOR FREECORE BLOCKS. SET BY ONCE
				; NEVER CHANGED WHILE MONITOR RUNS.
;T10; PTYCNF: XWD PTYOFS##,PTYN	;(22) PTY PARAMETERS FOR BATCH (RPORTN,,PPORTN)
LOCORE:: 0			;(23) LH=0, RH=ABS. ADR. OF 1ST FREECORE CHUNK
				; SET BY ONCE ONLY CODE AND NEVER CHANGED WHILE
				; MONITOR RUNS.
;T10; FREPTR::0			;T10; (23) AOBJN WORD FOR FREE-CORE BIT MAP
NUMLIN::exp PORTN		;(24) # OF PORTS
;T10; LOCORE::0			;T10; (24) RH=ABS. ADR. FOR 4-WORD CHUNKS
LGONAM::SIXBIT /LOGOUT/		;(25) NAME OF LOGOUT PROGRAM
;T10; STBPTR::EXP 0		;T10; (25) POINTER NOT USED WITH NETWORKS
JFYSEC::0			;(26) JIFFIES/SEC
;T10; OPRLDB::0			;T10; (26) LDB OF OPR TELETYPE
JFYMIN::0			;(27) JIFFIES/MIN
;T10; TTFREE::0			;T10; (27) FILLED IN AT ONCE TIME BY FREE LIST ADR
JFYHR::	0			;(30) JIFFIES/HOUR
;T10; TTCLST::XWD TTCHKN,0	;T10; (30) NUMBER OF TTY CHUNKS, ADDRESS OF FIRST ONE
HGHBLK::777			;(31) HIGHEST BLOCK IN ADRESSABLE CORE
;T10; TTFREN::0			;T10; (31) NUMBER OF FREE TTY CHUNKS AT THE MOMENT
HFDBUF::xwd M.SBSZ,0		;(32) HISTOGRAM FACILITY (SNOOPY)
				; BUFF PTR. 0 IF NONE ALLOCATED BY LNKDB
				; (STANDARD); ELSE SIZE,,BEG LOC
;T10; LINSAV::0			;T10; (32) POINTER TO CURRENT TTY SEEN BY COMMAND DECODER
SYSNUM::.-.			;(33)SYSTEM NUMBER, FILLED IN BY ONCE ONLY.
;T10; LINPTR::XWD MTTYLN##,LINTAB;T10;(33) POINTER TO EXAMINE TTY LINE TABLE,
FRECOR::exp FCWDS		;(34)AMOUNT OF FREECORE ALLOCATED
;T10; MONVER: EXP A00VER	;T10; (34) VERSION OF MONITOR (LH FOR CUSTOMER)
CRSCNT::exp ^D1800		;(35)TICS ALLOWED FOR SOFT CRASH
;T10; DSCPTR::XWD MDSLN##,DSCTAB##;T10; (35) POINTER TO DATASET CONTROL TABLE
	SAV30,,NUMTAB##		;(36)ADDRESS OF THINGS FOR CRSHID
;T10; DLSRWD::0			;T10; (36) LAST RECEIVE INTERRUPT FROM DC10
extern	PATCH,PATEND,TTYINI,TTIEND
DSKPAT::PATCH-PATEND,,PATCH	;(37)AOBJN pointer to PATCH area patches
;T10; CCIRWD::0			;T10; (37) LAST RECEIVE INTERRUPT FROM 680
RUNPAT::TTYINI-TTIEND,,TTYINI	;(40)AOBJN pointer to TTYINI area patches
;T10; SEGPT1::EXP JOBN		;T10; (40) LAST DORMANT SEG NUMBER THROWN AWAY
CNFCPU::CPUTYP			;(41)cpu model index (KI,KL,KS,F3)
;T10; LASPOK::0			;T10; (41) CONTAINS ADR. OF LAST LOCATION POKED
PATMAP::0			;(42)bit mask of patches installed
;T10; LASPUC::0			;T10; (42) JOB#,,COUNT OF POKES
CNFSID::;SYSID			;(43)sixbit monitor ID (serial number)
SYSIDL##,,SYSIDR##; work around MACRO/LOADER bug regarding 36bit externs
;T10; WHYCOD::0			;T10; (43) SIXBIT ANSWER FOR "WHY RELOAD" AT ONCE

  ;Start of TOPS-10 entries added in P034/P

TICSEC:: ^D60		;(44) CONTAINS NUMBER OF TICKS PER SECOND
PDBPTR:	XWD 0,0;JBTPDB	;(45) RH=POINTER TO TABLE OF PDB'S FOR JOBS
			; LH=0 FOR FUTURE EXPANSION
RTCUPS:: 0		;(46) RESOLUTION (UNITS/SEC.) OF CLOCK USED FOR RUN ACCT
SYSCHN::XWD CHN0CB##,0	;(47) LH=ADR OF FIRST CHANNEL (DF10) DATA BLOCK, RH=UNUSED
LOGMAX::EXP	JOBMAX	;(50) MAX.# JOBS ALLOWED TO BE LOGGED IN
BATMAX::EXP 0;	M.BMAX	;(51) MAX.# BATCH JOBS ALLOWED
BATMIN::EXP 0;	M.BMIN	;(52) MIN.# BATCH JOBS GUARENTEED (RESERVED)
DATE::	 0		;(53) DATE TIME IN UNIVERSAL DATE/TIME (UDT) FORMAT
	;See also GMTUDT; LH = DAYS SINCE NOV. 17, 1858, RH = FRACTION OF A DAY
LOGNUM:: 0		;(54) NUMBER JOBS CURRENTLY LOGGED IN
BATNUM:: 0		;(55) NUMBER BATCH JOBS CURRENTLY LOGGED IN.
LOCYER:: 0		;(56) LOCAL YEAR
LOCMON:: 0		;(57) LOCAL MONTH (1,2,...,12)
LOCDAY:: 0		;(60) LOCAL DAY OF MONTH (1,2,3,...)
LOCHOR:: 0		;(61) LOCAL HOUR (MIDNIGHT=0) reset by HOUR routine
LOCMIN:: 0		;(62) LOCAL MINUTE (0,1,...,59)
LOCSEC:: 0		;(63) LOCAL SECOND (0,1,...,59)
GMTDIF:: <TIMZON>B17/^D24;(64) DIFFERENCE BETWEEN LOCAL AND GMT TIME. (UDT)
			; IN SAME UNITS AS DATE --
			; E.G. DATE + GMTDIF = LOCAL DATE-TIME
			; (LH = DAY, RH = FRACT. OF DAY)
DEBUGF:: DEFDEB!DEFBPT	;(65) DEBUGGING STATES WORD - SIGN BIT=1 IF SYSTEM PROG IS
			; DEBUGGING MONITOR (SPEED UP ONCE ONLY)
			; BIT1=1 TO RELOAD ON DEBUG STOPCD'S
			; BIT2=1 TO RELOAD ON STOPCD'S WHICH ONLY
			; AFFECT 1 JOB
			; BIT3=1 TO DISABLE AUTO-RELOADS
			; BIT4=1 TO STOP SYSTEM IF ANY CPU GETS A CPU STOPCD
FRUSED:: 0		;(66) AMOUNT OF FREE CORE IN USE
RCCMAX:: 0		;(67) NUMBER OF BYTES IN TTY CHUNKS
CNFCVN::SYSVER		;(70) CUSTOMER VERSION (=C(136)) = A00CVN
CNFDVN::A00DEC,,A00EDT	;(71) DEC VERSION IN LH, TYMCOM-X EDIT # IN RH
CNFCHN::EXP	CHNN##	;(72) NUMBER OF DATA CHANNELS (DF10 or RH11S or F3)
CNFRTD::EXP 0;	M.RTD	;(73) NUMBER OF REAL TIME DEVICES
CNFHPQ::EXP 0;	M.HPQ	;(74) NUMBER OF HPQ'S
CNFLDB::EXP	DDBLDB##;(75) WORD IN TTY DDB WHICH POINTS TO LDB
CNFMVO::EXP 0;	PSIMVO	;(76)MAX. VECTOR OFFSET FOR PISYS. UUO
CNFMIP::EXP 0;	PSIMPI	;(77)MAX. PRIORITY FOR PSISER
CNFMTA::XWD	TUBRID##,MT0DDB##  ;(100) POINTER TO FIRST MTA DDB AND INDEX
				   ; OF START OF DAEMON INFORMATION
CNFET1:	EXP 0;	JOBDAC##+T1	;(101) EXEC AC1 IN USER'S ADDRESS SPACE
CNFLSD:	EXP	DEVLSD		;(102) LENGTH OF SHORT DDB
CNFLLD:	EXP	DEVLLD		;(103) LENGTH OF LONG DDB
CNFLDD:	EXP	DDBLEN##	;(104) LENGTH OF DISK DDB
CNFEXM:	EXP	JOBEXM##	;(105) WORD IN JOBDAT USED BY "E" AND "D" COMMAND
	ZZ==0
	ZZ==ZZ!1B35		;BIT 35=1 IF SWAP SPACE ALLOCATED IN PAGES
;IFN M.TM10,<ZZ==ZZ!1B34>	;BIT 34=1 IF MTA ERROR REPORTING
	ZZ==ZZ!1B33		;BIT 33=1 IF VM MONITOR
;IFN M.IPCF,<ZZ==ZZ!1B32>	;BIT 32=1 IF IPCSER IS LOADED
;IFN M.PSI,<ZZ==ZZ!1B31>	;BIT 31=1 IF PSISER IS LOADED
;IFN M.MSG,<ZZ==ZZ!1B30>	;BIT 30=1 IF MSGSER IS LOADED
	ZZ==ZZ!1B29		;BIT 29=1 IF NON-SUPER ENTER IS SUPPORTED
;IFN FTNSCHED,<ZZ==ZZ!1B28>	;BIT 28=1 IF NEW CLASS SCHEDULER IS PRESENT
;IFN M.EQDQ,<ZZ==ZZ!1B27>	;BIT 27=1 IF ENQ/DEQ IS LOADED
;IF2, <ZZ==ZZ!<<ZGAL>B26>>	;BIT 26=1 IF MONITOR CONTAINS GALAXY-10 FEATURES
;ZZ==ZZ!1B25			;BIT 25=1 MONITOR SUPPORTS MASSBUS ERROR REPORTING
;ZZ==ZZ!1B24			;BIT 24=1 IF NEW TAPSER
;ZZ==ZZ!1B23			;BIT 23=1 IF NEW ERROR REPORTING
;ZZ==ZZ!1B22			;BIT 22=1 IF JOB NUMBERS ARE 9 BITS NOT 7
;IFN M.EXE,<ZZ==ZZ!1B21>	;BIT 21=1 IF "SAVE" COMMAND PRODUCES EXE FILE
;IFN M.EMRT,<ZZ==ZZ!ST%EMR>	;BIT 20=1 IF EBOX/MBOX RUNTIME IS IN EFFECT (KL ONLY)
;IFN M.XPI,<ZZ==ZZ!ST%XPI>	;BIT 19=1 IF PI TIME IS EXCLUDED FROM USER RUNTIME (KL ONLY)
;ZZ==ZZ!1B18			;BIT 18=1 IF FULL 6 CHAR DEVICE NAMES "LPT231"
;IFN M.ITA,<ZZ==ZZ!ST%ITA>	;BIT 17=1 IF INTERVAL TIMER ON KL10 IS AVAILABLE
;IFE M.CLSS,<ZZ==ZZ!ST%NCS>	;BIT 16=1 IF NOT CLASS SYSTEM SCHED.
;ZZ==ZZ!ST%NER			;BIT 15=1 MONITOR SUPPORTS 6.03 ERROR REPORTING
;IFN M.ACV,<ZZ==ZZ!ST%ACV>	;BIT 14=1 IF ACCOUNT VERIFICATION SHOULD BE DONE
;IFN FTKL10!FTKS10,<ZZ==ZZ!ST%LSC> ;BIT 13=1 IF LOW SEGMENT OF MONITOR IS CACHED
;IFN FTMDA,<ZZ==ZZ!ST%MDA>	;BIT 12=1 IF ALLOCATOR WILL RUN
;IFN FTKLP,<ZZ==ZZ!1B11>	;BIT 11=1 IF KL RATHER THAN KI PAGING IN MONITOR
;IFN M.DECN,<ZZ==ZZ!1B10>	;BIT 10=1 IF PHASE 3 DECNET LOADED
CNFST2::EXP	ZZ		;(106) FLAG BITS DEFINED ABOVE
PISYMN: EXP 0;	M.PSI*C$MIN	;(107) MINIMUM CONDITION FOR PISYS.UUO
PITLEN: EXP 0;	PITSIZ		;(110)LENGTH OF PI TABLE
CNFPIA::EXP 0;	JBTPIA		;(111)ADDRESS OF JBTPIA
%CNMNT:	BYTE	(1)0(17)0(6)5(6)0(6)0	;(112) TYPE OF MONITOR
					;    (1)=STRANGE
					;    (17)=RESERVED TO DEC
					;    (6)=TYPE:	1=TOPS-10
					;		2=I.T.S.
					;		3=TENEX
					;		4=TOPS-20
					;		5=TYMCOM-X
					;		REST RESERVED TO DEC
					;    (6)=SUBTYPE (RESERVED TO DEC)
					;    (6)=RESERVED TO CUSTOMERS

  ;Items added for P035 monitor

	EXP 0; CR0DDB,,CDRCNT##	;(113)OFFSET TO CARD COUNT FOR CDR
	EXP 0; CP0DDB##,,CDPCTO##;(114)OFFSET TO CARD COUNT FOR CDP
	EXP	PAGSIZ		;(115)BASIC UNIT OF CORE ALLOCATION
	EXP 0;	MINMAX		;(116)MIN VALUE FOR CORMAX
	EXP 0;	M.CLSN		;(117)NUMBER OF SCHEDULER CLASSES
	EXP	0		;(120)EXPONENTIAL FACTOR USED IN COMPUTING USER TIME
SYSORG::	0		;(121)START OF MONITOR HISEG
SYSLEN::	0		;(122)LENGTH OF MONITOR HISEG
NWCORE::^D<512*1024>		;(123)NUMBER OF WORDS OF CORE MINIMUM
NXMPTR::0			;(124)AOBJN POINTER TO NXMTAB USED TO SCAN FOR ZEROES
	EXP 0;	NETNDB##	;(125)POINTER TO THE FIRST NODE BLOCK
CNFTKB:	EXP	TKBCDB##	;(126)POINTER FROM KDB TO CDB FOR MAGTAPES
	XWD CTYPTR##,CTYBUF##	;(127)POINTER TO CTY OUTPUT,,ADDR OF BUFFER
HNGLST::XWD	0,0		;(130)LH IS ADDRESS OF FIRST DEVICE WHICH SHOULD BE
				; CHECKED TO SEE IF IT IS HUNG
	EXP	BOOTXT		;(131) ADDRESS OF RELOAD CCL TEXT
	EXP	TUBDDB##	;(132) OFFSET OF DDB PTR'S IN TUB
	EXP	MT0KDB##	;(133) 1ST MTA KDB IN SYS
NOCPUS::EXP	1		;(134) NO OF CPUS MONITOR WAS BUILT FOR
CNFDJB:	XWD	PJBNLH,DEVJOB	;(135) GETTABLE PJOBN (SANS INDEX FIELD)
;T10; UPTIME::
SYSUPT::EXP	0		;(136) SYSTEM UPTIME
BOOTCP::EXP	-1		;(137) BOOT CPU NUMBER
BOOTCT::EXP 0;	CT0LIN		;(140) BOOT CPU CTY LINE NUMBER
NCPRUN::EXP	1		;(141) NUMBER OF CPUS ALLOWED TO RUN
STRMON::SIXBIT	/SYS/		;(142) FILE STRUCTURE MONITOR WAS BOOTED FROM
FILMON::SIXBIT	/SYSTEM/	;(143) FILE NAME
EXTMON::SIXBIT	/SAV/		;(144) EXTENSION
PPNMON::XWD	1,4		;(145) PPN
SYSNBP::EXP	MAXNBP		;(146) MAXIMUM NUMBER OF BREAK POINTS FOR SNOOP.
MONVFF::EXP	MONORG		;(147) FIRST FREE VIRTUAL ADDRESS ABOVE MONITOR
LDBVRG::EXP	0		;(150) VIRTUAL ADDRESS OF THE ORGIN OF LDBS
FOPHXC::EXP 0;	HIGHXC-20	;(151) NUMBER OF EXTENDED CHANNELS AVAILABLE VIA FILOP.
MONHSO:	EXP	MONORG		;(152) VIRTUAL ADDRESS OF START OF MONITOR HIGHSEG
SUPTIM::EXP	0		;(153) UNIVERSAL DATE/TIME OF LAST ROLE SWITCH
CNFDCH:	XWD LDBSTR##,LDBDCH##	;(154) OFFSET OF LDBDCH IN LDB'S, AUX STRING
SFDMON::EXP	0		;(155) 1ST SFD MONITOR WAS BOOTED FROM
	EXP	0		;(156) 2ND SFD MONITOR WAS BOOTED FROM
	EXP	0		;(157) 3RD SFD MONITOR WAS BOOTED FROM
	EXP	0		;(160) 4TH SFD MONITOR WAS BOOTED FROM
	EXP	0		;(161) 5TH SFD MONITOR WAS BOOTED FROM
	EXP 0;	FRCLIN		;(162) TTY LINE NUMBER OF FRCLIN
PTYPTR:	XWD	-PTYN,PTYTAB	;(163) POINTER TO PTY TABLE

;* * *
;* * * THIS IS THE END OF THE CONFIG GETTAB TABLE: add new entries above
;* * *
CNFMXL==:<.-CNFTBL-1>B26		;MAXIMUM ENTRY IN CNFTBL FOR GETTAB M

REPEAT 0,<;Unused TOPS-10 entries
	XWD	-LATLEN##,NETLAT## ;(164)-LENGTH,,LOCATION LINK ADDRESS TABLE
CNFLPD:	EXP	.PDLEN		;(165) LENGTH OF A PDB (SIZUPS*1000?)
	XWD	0,PAGSIZ	;(166) XWD FLAG, SIZE OF LARGEST JOBPEK TRANSFER
				; WHERE FLAG=0 IF SWAP SPACE JOBPEK'S MAY NOT
				; CROSS A PAGE BOUNDARY, FLAG=1 IF THEY MAY
	EXP	CNFDAE		;(167) XWD OLD DAEMON NAME,CURRENT MONITOR
				; VERSION. OLD DAEMON NAME IS THE SIXBIT NAME
				; OF THE PREVIOUS MONITOR, E.G. 701.
CNFHSH::XWD	-HSHLEN,HSHTAB	;(170) AOBJN POINTER TO HSHTAB FOR ENQ/DEQ
	EXP	<.PDACS-.PDBEG>	;(171) OFFSET IN PDB FOR ACCOUNT STRING
	XWD	TOPLN1##,TOPTB1## ;(172) POINTER TO TOPTB1, TRMOP DISPATCH
	EXP	JBTSFD##	;(173) POINTER TO JBTSFD
	EXP	CIPWT		;(174) POINTER TO CLOCK QUEUE
CNFMXL==:<.-CNFTBL-1>B26	;MAXIMUM ENTRY IN CNFTBL FOR GETTAB UUO
				;(175) JBTPRV for INITIA
				;(176) CTERM data in 8-bit bytes, first 4
				;(177) CTERM data, 4 more 8-bit bytes
				;(200) LAT host node database
				;(201) AND mask for .GTIMI/.GTIMO
				;(202) ACB
				;(203) AHB

;----------------------------------
;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY ONCE ONLY CODE.
; OR ARE CONSTANTS WHICH ARE NOT CLEARED AT STARTUP
;-------------------------------------
TIMLST::0			;VALUE OF "TIME" LAST TIME AT CLOCK LEVEL
				; USED FOR ALL TIMING FUNCTIONS, E.G.,
				; MAINTAINING CLOCK QUEUE AND SMITHSONIAN DATE
>  ;End of TOPS-10 definitions

BGBENF::1B0+<XWD ^D<4*60>,0>	;Output at system startup, then every 4 hours
LOCWEK::0			;Pointer to ASCIZ string for day of week
;GETTAB TABLE OF QUEUE CODES FOR JOBS - TABLE(RH)=25
;MUST BE A SEPARATE TABLE SINCE THE NUMBER OF ENTRIES VARIES ACCORDING
;TO THE CONFIGURATION

;ENTRIES ARE 2 SIXBIT CHARACTERS, THREE PER WORD
;STATE CODE 0 IS LEFT THIRD, 1 IS MIDDLE THIRD, 2 IS RIGHT THIRD OF FIRST WORD
;STATE CODE 3 IS LEFT THIRD OF SECOND WORD, ETC.

STSTBL::

DEFINE X(A,B,C)
<	IFE ZZ-ZZ/3*3-0,
  <	  XX==   <SIXBIT /A/&7777B11>B35>
	IFE ZZ-ZZ/3*3-1,
  <	  XX==XX!<SIXBIT /A/&7777B11>B47>
	IFE ZZ-ZZ/3*3-2,
  <	  XX==XX!<SIXBIT /A/&7777B11>B59
	  EXP XX>
ZZ==ZZ+1
>

ZZ==0
	QUEUES
	CODES
	IFN ZZ-ZZ/3*3-0,<
	  EXP XX>

STSMXL==:<.-STSTBL-1>B26	;MAX ENTRY IN STSTBL FOR GETTAB UUO
SUBTTL	License bit defintions table

LICTBL::Point 1,'WC '!1,00		; Write Core
	Point 1,'RC '!1,01		; Read Core
	Point 1,'OP '!1,02		; Operator
	Point 1,'SY '!1,03		; Systat
	Point 1,'GD '!1,04		; Get Devices
	Point 1,'TD '!1,05		; Transfer Devices
	Point 1,'ST '!1,06		; Structures
	Point 1,'HF '!1,07		; Home Files (Write)
	Point 1,'JL '!1,08		; Jacct-Login
	Point 1,'AC '!1,09		; Aux Circuit
	Point 1,'XC '!1,10		; eXchange Charges
	Point 1,'QM '!1,11		; Queue Manager
	Point 1,'HR '!1,12		; Home Read
	Point 1,'-- '!0,13		; --Unused--
	Point 2,'RP '!1,15		; Read in Project
	Point 2,'RF '!2,15		; Read Files
	Point 2,'RA '!3,15		; Read Absolute
	Point 2,'WP '!1,17		; Write in Project
	Point 2,'WF '!2,17		; Write Files
	Point 2,'WA '!3,17		; Write Absolute
LICMAX=:<.-LICTBL>		; Number of license entries
LICMXL=:<.-LICTBL-1>B26		; Range of entries 0-n (shifted 9)

ODPTBL::			;FIRST LOCATION IN MONITOR DATA AREA FOR DISK-
				; RELATED LOCATIONS WHICH ARE NOT SET TO 0
				; WHEN THE SYSTEM IS STARTED UP.
				; ODPTBL IS GETTAB TABLE NUMBER 15.

SWPHGH::0	; (obsolete)	;(0) HIGHEST LOGICAL BLOCK # ASSIGNED FOR
				; SWAPPING. SPACE IS ASSIGNED FROM HIGHEST
				; BLOCK # DOWNWARDS.

K4SWAP:	0	; (obsolete)	;(1) # OF J OF DISK WORDS SET ASIDE FOR
				; SWAPPING. ASSIGNED AT ONCE ONLY REFRESH
				; TIME.

ICPFACTOR==:1			;FACTOR BY WHICH TO MULTIPLY AVERAGE SWAP-IN
				; TIMES TO PRODUCE IN-CORE PROTECT TIMES.
KXFTIM==1			;SET PROTECT TIMES TO 1
IFCPU (<KI,KL>),<SEEKTM==1>	;Set PROT0 to 2 for KI and KL
IFNCPU(<KI,KL>),<SEEKTM==3>	;Set PROT0 to 4 for KS and F3

PROT::	EXP ICPFACTOR*KXFTIM	;(2) IN-CORE PROTECT TIME PARAMETER TO BE
				; MULTIPLIED BY <J-1> OF CORE IN JOB.

PROT0::	EXP ICPFACTOR*<SEEKTM+KXFTIM>;(3) IN-CORE PROTECT TIME PARAMETER TO
				; BE ADDED TO ABOVE RESULT.

MXPROT::  EXP ^D60		;(4) MAX VALUE FOR ICPT FUNCTION, KEEP CORE
				; FROM GETTING CLOGGED WITH HUGE JOBS WITH
				; HUGE ICPT WHICH SCHEDULER DOESNT WANT TO
				; RUN. /AA

DCN::	DCFULL+(DCNDFT)		;(5) DSKCLN TYPE DESIRED, DEF IS FULL, INIT HM
EXTERN	DCNDFT			; Default DSKCLN bits from ONCDSK

;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY
; ONCE ONLY CODE AND WHICH PERTAIN ONLY TO DISK SYSTEMS.
ODPMXL==:<.-ODPTBL-1>B26	;MAXIMUM ENTRY IN ODPTBL FOR GETTAB M

;DISK LOCATIONS NOT IN GETTAB

REFLAG:: 0			;FLAG LOCATION TO INDICATE WHETHER ANY REFRESHING
				; OCCURRED AND TO CONTAIN THE [PROJ,R]
				; NUMBERS FOR AUTOMATIC LOG-IN FOLLOWING REFRESH.
;MORE DATA LOCATIONS SETUP AT ASSEMBLY TIME OR ONCE ONLY TIME
; BUT NOT OF INTEREST TO USER PROGRAMS

;MONTH TABLE FOR DAYTIME COMMAND PRINTING

PMONTB::POINT 6,MONTAB(T1),5	;POINTER TO NUMBER OF DAYS IN MONTH
MONTAB::EXP ^D30B5+"JAN"
	EXP ^D27B5+"FEB"
	EXP ^D30B5+"MAR"
	EXP ^D29B5+"APR"
	EXP ^D30B5+"MAY"
	EXP ^D29B5+"JUN"
	EXP ^D30B5+"JUL"
	EXP ^D30B5+"AUG"
	EXP ^D29B5+"SEP"
	EXP ^D30B5+"OCT"
	EXP ^D29B5+"NOV"
	EXP ^D30B5+"DEC"
;The following are set up by ONCE when it calculates jiffies per second
MIDNIT::0	;JIFFIES TILL MIDNIGHT
JFYSC2::0	;JIFFIES IN 1/2 SEC
JFY2SC::0	;JIFFIES IN 2 SEC
JFYS12::0	;Jiffies in 1/12 second
QQYTTY::0	;Jiffies for TTY satisified quantum (1/2 second)
QQYSD:: 0	;Jiffies for swap done (1/10 second)

SYSSZP::0	;SYSTEM SIZE IN PAGES
MEMSZP::0	;MEMORY SIZE IN PAGES
MAXPCB::0	;LARGEST PCB PAGE NUMBER
MINPCB::0	;SMALLEST PCB PAGE NUMBER
;TABLE TRANSLATING BIT NUMBERS TO BITS

BITTBL::ZZ==1B0
REPEAT ^D36,<
	ZZ
	ZZ==ZZ_<-1>
>;END REPEAT ^D36
;Table which gives the absolute number of bit 0 in any given word in a
; bit table.  This is used by SCNSER and COMCON to determine what port
; or frame number a given bit in a given word corresponds to.
; NFLG is the number of words in SCNSER's LINFLG table;
; CFLG is the number of words in COMCON's COMFLG table;
; BFLG is MAX(NFLG,CFLG)+1 for safety.

	BFLG==NFLG+1
IFG <CFLG-NFLG>,<BFLG==CFLG+1>

BITNTB::XYZZY==0
REPEAT BFLG,<
	XYZZY
	XYZZY==XYZZY+^D36
>
SUBTTL	Feature Test Table  (GETTAB '71)

	DEFINE	FTBITS(FET),<
	.X==0
	.Y==0
	.Z==0
IRP FET<
IFGE .Y-21,<PRINTX ? FET CANT BE INSERTED>
IFN	FT'FET,<.X==.X!1_.Y>
	.Z==.Z!1_.Y
	F.'FET==1_.Y
	.Y==.Y+1>
	XWD .Z,.X>
	FT1==-1			;FORCE ON (NAME=1)
	FT0==0			;FORCE OFF (NAME=0)

; "YES"=Is in P034/P      "NO"=Is not in P034/P    "NO !"=Should be in P034/Q
; "OTHER"=Same function, different UUO    "BUG??"=Not sure if it works right
  ;	%FTTYM==-1,,71       TYMSHARE
  ;F%14ND 35        YES   14-bit node numbers
  ;F%16ND 34        NO    16-bit node numbers
  ;F%LHST 33        MAYBE Login host number available
  ;F%SUDT 32        YES   SYSUDT in NSWTBL+5 and KSYS in NSWTBL+6
FETTYM:	17,,1B32!1B33!1B35	;(-1) TYMSHARE bits

FETTBL::		;Feature Test Table (GETTAB table 71)

  ;	%FTUUO==0,,71        UUOS
  ;F%2REL 35 FT0    NO    2-REGISTER RELOCATION
  ;F%GETT 34 FT1    YES   GETTAB UUO
  ;F%DAEM 33 FT1    NO    DAEMON FUNCTIONS, ETC.
  ;F%PRV  32 FT1    YES   JOB PRIVS
  ;F%SPL  31 FTSPL  NO    SPOOLING (LPT TO DSK)
  ;F%JCON 30 FT1    YES   JOB CONTINUE
  ;F%POKE 29 FTPOKE OTHER POKE. UUO
  ;F%PEEK 28 FTPEEK YES   PEEK UUO
  ;F%PTYU 27 FT1    NO !  JOBSTS AND CTLJOB UUOS
  ;F%CCIN 26 FT1    OTHER CONTROL-C INTERCEPT
  ;F%IPCF 25 FTIPCF NO    IPCF
  ;F%PI   24 FTPI   OTHER SOFT. PI SYS
  ;F%GALA 23 FT1    NO    GALAXY-10 FEATURES
  ;F%EQDQ 22 FTEQDQ OTHER ENQ./DEQ.
  ;F%MIC  21 FTMIC  NO !  MACRO COMMAND PROCESSOR
  ;F%MLOG 20 FTMLOG NO    MIC LOG FILE SUPPORT
  ;F%MDA  19 FTMDA  NO    MOUNTABLE DEVICE ALLOCATOR
    ;(0) LIST OF MONITOR NON-I/O FEATURES WHICH DIRECTLY IMPACT CUSPS (THIS WORD IS FULL)
  ;*;	FTBITS<0,1,1,1,SPL,1,POKE,PEEK,1,1,IPCF,PI,1,EQDQ,MIC,MLOG,MDA>
FETUUO:	377777,,1B28!1B30!1B32!1B34	;(0) Monitor Call features

  ;	%FTRTS==1,,71        REAL TIME AND SCHEDULER
  ;F%HPQ  35 FTHPQ  NO    HIGH PRIORITY RUN QUEUES
  ;F%HIBW 34 FT1    YES   HIBER/WAKE UUOS
  ;F%SLEE 33 FT1    YES   SLEEP UUO
  ;F%RTTR 32 FTRTTR NO    RTTRAP UUO
  ;F%TRPS 31 FTTRPS NO    TRPSET UUO
  ;F%LOCK 30 FTLOCK NO    LOCK UUO
  ;F%RTC  29 FT0    KI10  DK10 SERVICE
  ;F%SHFL 28 FT0    NO    SHUFFLER
  ;F%SWAP 27 FT1    NO    SWAPPER
  ;F%VM   26 FT1    YES   VIRTUAL MEMORY
  ;F%NSCH 25 FTNSCH NO    NEW SCHEDULER
  ;F%PSCD 24 FTPSCD NO    SCHEDULER PERFORMANCE GATHERING
  ;F%CMSR 23 FTCMSR NO    COMMUNICATION MEASUREMENT CODE
  ;       22-19 unused as of 7.03
    ;(1) REAL-TIME AND SCHEDULING FEATURES
  ;*;	FTBITS<HPQ,1,1,RTTRAP,TRPSET,LOCK,0,0,1,1,NSCHED,PSCD,CMSR>
FETRTS:	017777,,1B26!1B33!1B34	;(1) Realtime & Scheduler features

  ;	%FTCOM==2,,71        COMMANDS
  ;F%ATTA 35 FT1    YES   ATTACH COMMAND/UUO
  ;F%TALK 34 FT1    YES   SEND
  ;F%EXAM 33 FT1    YES   E AND D
  ;F%REAS 32 FT1    YES   REASSIGN UUO/COMMAND
  ;F%FINI 31 FT1    YES   FINISH AND CLOSE
  ;F%WATC 30 FT1    YES   WATCH
  ;F%SEDA 29 FT1    YES   SET DAYTIME AND SET DATE
  ;F%BCOM 28 FT1    NO !  BATCH CONTROL FILE
  ;F%VERS 27 FT1    YES   VERSION
  ;F%SET  26 FT1    YES   SET UUO/COMMAND
  ;F%QCOM 25 FT1    NO !  QUEUE AND FRIENDS
  ;F%CCLX 24 FT1    YES   COMPIL-CLASS
  ;F%CCL  23 FT1    YES   COMPIL COMMANDS
  ;F%MONL 22 FT1    NO    SET MEMORY ON LINE
  ;F%MOFF 21 FT1    NO    SET MEMORY OFF LINE
  ;F%EXE  20 FT1    NO !  .EXE FORMAT FILES SUPPORTED
  ;F%PJOB 19 FT1    YES   EXTENDED PJOB COMMAND
    ;(2) COMMAND FEATURES (THIS WORD IS FULL)
  ;*;	FTBITS<1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1>
FETCON:	377777,,1B19!1B23!1B24!1B26!1B27!1B29!1B30!1B31!1B32!1B33!1B34!1B35 ;(2) Command features

  ;	%FTACC==3,,71        ACCOUNTING INFO
  ;F%TIME 35 FT1    YES   RUN TIME
  ;F%KCT  34 FT1    YES   KILO-CORE-TICKS
  ;F%UNAM 33 FT1    YES   USER NAME
  ;F%CNO  32 FT1    NO    CHARGE NUMBER
  ;F%TLIM 31 FT1    YES   TIME/CORE LIMITS, ETC.
  ;F%FDAE 30 FTFDAE NO    FILE DAEMON SUPPORT
  ;F%EMRT 29 FTEMRT KL10  KL10 EBOX/MBOX USER RUNTIME CAPABILITY
  ;F%ACCT 28 FT1    YES   ACCOUNTING SUPPORT
  ;       27-19 unused as of 7.03
    ;(3) ACCOUNTING FEATURES
  ;*;	FTBITS<1,1,1,1,1,FDAE,EMRT,1>
FETACC:	000377,,1B28!1B31!1B33!1B34!1B35	;(3) Accounting features

  ;	%FTERR==4,,71        ERROR CONTROL AND OPTIONS
  ;F%MEMP 35 FT1    YES   MEMORY PARITY RECOVERY CODE
  ;F%MS   34 FTMP   NO    MULTI-PROCESSORS
  ;F%EL   33 FT1    NO    DAEMON ERROR LOGGING
  ;F%2SWP 32 FT1    NO    MULT. SWAPPING DEVICES
  ;F%BOOT 31 FT1    YES   BOOTS BOOTSTRAP
  ;F%KII  30 FT1    NO    KI-10 INSTR CHECK ON KA10
  ;F%EXON 29 FT1    YES   EXECUTE ONLY FILES
  ;F%METR 28 FT0    NO    METER. UUO
  ;F%KI10 27 FT0    KI10  THIS IS A KI10
  ;F%PDBS 26 FT0    NO    SWAPPING PDB
  ;F%22BI 25 FT1    YES   22 BIT CHANNEL (DF10C)
  ;F%KA10 24 FT0    F3    THIS IS A KA10
  ;F%KL10 23 FTKL10 KS10  THIS IS A KL10
  ;F%MNXM 22 FT1    YES   NXM ERROR RECOVERY CODE
  ;F%KS10 21 FTKS10 KS10  THIS IS A KS10
  ;F%KLP  20 FT1    NO    KL10 PAGING
  ;F%SCA  19 FTSCA  NO    SYSTEMS COMMUNICATIONS ARCHITECTURE (ethernet)
    ;(4) NON I/O FEATURES NOT RELATED TO DEBUGGING (THIS WORD IS FULL)
  ;*;	FTBITS<1,MP,1,1,1,1,1,0,0,0,1,0,KL10,1,KS10,1,SCA>
FETERR:				;(4) Error Recovery features
    IFCPU (KI),<177777,,1B22!1B27!1B29!1B31!1B35> ;(4) KI
    IFCPU (KL),<177777,,1B22!1B23!1B29!1B31!1B35> ;(4) KL
    IFCPU (KS),<177777,,1B22!1B21!1B29!1B31!1B35> ;(4) KS
    IFCPU (F3),<177777,,1B22!1B24!1B29!1B31!1B35> ;(4) KA bit used for F3

  ;	%FTDEB==5,,71        DEBUGGING FEATURES
  ;F%CHEC 35 FT0    NO    MONITOR CHECKSUMMED
  ;F%MONP 34 FT0    NO    MONITOR WRITE PROTECTED
  ;F%RCHK 33 FT1    MAYBE INTERNAL REDUNDANCY CHECKS
  ;F%HALT 32 FT1    YES   HALTS IN MONITOR
  ;F%TRAC 31 FT0    NO    BACK TRACKING FEATURES
  ;F%PATT 30 FTPATT YES   PATCH SPACE IN TABLES
  ;F%WHY  29 FT1    NO !  WHY RELOAD
  ;F%RSP  28 FTRSP  NO    RESPONSE TIME
  ;F%2SEG 27 FT1    NO !  2 SEGMENT MONITOR
  ;       26-19 unused as of 7.03
    ;(5) NON I/O DEBUGGING FEATURES
  ;*;	FTBITS<0,0,1,1,0,PATT,1,RSP,1>
FETDEB:	000777,,1B30!1B32!1B33	;(5) Debugging features

  ;	%FTSTR==6,,71        FILE STRUCTURE PARAMS
  ;F%MOUN 35 FT1    YES   STRUUO FUNCTIONS
  ;F%SFD  34 FT1    NO    SUB FILE DIRECTORIES
  ;F%PHYO 33 FT1    YES   PHYSICAL ONLY
  ;F%5UUO 32 FT1    NO !  MISC. 5-SERIES UUOS (LIB AND PATH)
  ;F%STR  31 FT1    NO !  MULTIPLE STRUCTURES
  ;F%DQTA 30 FT1    YES   DISK QUOTAS
  ;F%DSUP 29 FT1    YES   SUPER USETI/O
  ;F%DSEK 28 FT0    NO    SEEK UUO
  ;F%DRDR 27 FT1    YES   RENAME ACROSS DIRECTORIES
  ;F%GSRC 26 FT1    NO !  GENERIC DEVICE SEARCH
  ;F%AIR  25 FT1    MAYBE APPEND IMPLIES READ
  ;F%APLB 24 FTAPLB MAYBE APPEND TO LAST BLOCK
  ;F%DPRI 23 FTDPRI NO    DISK PRIORITY TRANSFERS
  ;F%LIB  22 FT1    NO !  LIB/SYS/OLD/NEW ETC.
  ;F%NUL  21 FT1    NO !  NUL
  ;F%DSIM 20 FT1    OTHER MULTI. ACCESS UPDATE
  ;F%DHIA 19 FT1    MAYBE HIGH AVAIL. FEATURES
    ;(6) DISK UUO FEATURES (THIS WORD IS FULL)
  ;*;	FTBITS<1,1,1,1,1,1,1,0,1,1,1,APLB,DPRI,1,1,1,1>
FETSTR:	377777,,1B20!1B27!1B29!1B30!1B33!1B35	;(6) File structure features

  ;	%FTDSK==7,,71        INTERNAL DISK PARAMS
  ;F%DOPT 35 FT1    YES   LATENCY OPTIMIZATION
  ;F%DBAD 34 FT1    YES   DISK OFF-LINE RECOVERY
  ;F%DHNG 33 FT1    YES   HUNG DISK RECOVERY
  ;F%DSTT 32 FT1    YES   DISK USAGE STATISTICS
  ;F%DALC 31 FT1    NO    ALLOCATION OPTIMISATIONS
  ;F%DSMC 30 FT1    NO    SMALLER ALLOC. OF DISK CORE BLOCKS
  ;F%DMRB 29 FT1    YES   MULTI RIBS
  ;F%DETS 28 FT1    NO    DISK ERROR SIMULATOR
  ;F%DUFC 27 FTDUFC NO    UFD COMPRESSOR
  ;F%DBBK 26 FT1    BUG?? BAD BLOCK MARKING
  ;F%SWPE 25 FT1    NO    SWAP READ ERROR RECOVERY
  ;F%FFRE 24 FT0    NO    PREVENT RACES IN FILFND
  ;F%DISK 23 FT1    YES   DISK SYSTEM
  ;F%LOGI 22 FT1    YES   LOGIN
  ;F%CBDB 21 FTCBDB MAYBE DEBUG CB INTERLOCK
  ;F%2ATB 20 FT0    NO    2 PART ACCESS BLOCKS
  ;F%SLCK 19 FT0    NO    DEBUG SEARCH LIST CODE
    ;(7) DISK "INVISIBLE" FEATURES (THIS WORD IS FULL)
  ;*;	FTBITS<1,1,1,1,1,1,1,1,DUFC,1,1,0,1,1,CBDB,0,0>
FETDSK:	377777,,1B22!1B23!1B29!1B32!1B33!1B34!1B35	;(7) Internal disk features

  ;	%FTSCN==10,,71        SCANNER OPTIONS
  ;F%HDPX 35 FT0    YES   TRULY HALF DUPLEX TERMINALS
  ;F%GPO2 34 FT0    NO    U.K. MODEM SUPPORT
  ;F%630H 33 FT0    NO    SINGLE SCANNER 630
  ;F%MODM 32 FT1    YES   MODEM CONTROL
  ;F%SCNR 31 FT1    YES   HARDWARE SCANNER
  ;F%SCLC 30 FT0    NO    SPECIAL LINE CONTROL
  ;F%DIAL 29 FT1    NO    AUTO DIALER
  ;F%TPAG 28 FT1    YES   PAGE AND DISPLAY KNOWLEDGE (^S/^Q BS-SP-BS)
  ;F%TBLK 27 FT1    NO !  TTY BLANK COMMAND
  ;F%CAFE 26 FT1    NO    DC76
  ;F%2741 25 FT0    YES   SUPPORT 2741-LIKE TERMINALS
  ;F%TYPE 24 FT0    NO    TYPESET-10 FEATURES IN DC76
  ;F%TVP  23 FT1    NO !  FANCY VERTICAL POSITIONING
  ;F%DCXH 22 FT1    NO    DC10-H (2741 ON DC10) SUPPORTED
  ;F%RDX  21 FTRDX  NO    REMOTE DATA ENTRY SERVICE
  ;F%RP04 20 FT1    KS10  INCLUDE RP04 & RP06 SUPPORT
  ;       19 unused as of 7.03
    ;(10) SCANNER, RP04 FEATURES
  ;*;	FTBITS<0,0,0,1,1,0,1,1,1,1,0,0,1,1,RDX,1>
FETSCN:	177777,,1B25!1B28!1B31!1B32!1B35	;(10) Scanner features

  ;	%FTPER==11,,71        I/O PARAMS
  ;F%TMP  35 FT1    YES   TMPCOR AREA
  ;F%MTSE 34 FT1    NO !  MTA DENSITY/BLOCK COMMANDS
  ;F%CDRS 33 FT1    NO    CDR SUPER IMAGE MODE
  ;F%OPRE 32 FT1    YES   DEVICE ERRS TO OPER
  ;F%LPTR 31 FT1    YES   LPT DEVICE ERROR RECOVERY
  ;F%NET  30 FTNET  OTHER NETWORK SOFTWARE, REMOTE ANF10 STATIONS
  ;F%CTY1 29 FT1    NO !  SUPPORT CTY1 ON DUAL-SMP
  ;F%CRTR 28 FT1    NO    CDR TROUBLE INTERCEPT
  ;F%CPTR 27 FT1    NO    CDP TROUBLE INTERCEPT
  ;F%HSLN 26 FT1    NO !  HIGH-SPEED LOGICAL DEVICE SEARCH
  ;F%MSGS 25 FTMSGS NO    MSGSER (MPX DEVICE)
  ;F%XTC  24 FTXTC  NO    DA28-C NETWORK SUPPORT
  ;F%DAS7 23 FTDN60 NO    DAS78 (REMOTE 360/370/2780) SUPPORT
  ;F%TASK 22 FTTSK  OTHER TASK TO TASK NETWORK SUPPORT
  ;F%TLAB 21 FTTLAB NO    TAPE LABEL SUPPORT
  ;F%TAPO 20 FT1    NO !  TAPOP. UUO
  ;F%RDBA 19 FT1    NO    READ BACKWARDS ON TU70
    ;(11) OTHER PERIPHERALS (THIS WORD IS FULL)
  ;*;	FTBITS<1,1,1,1,1,NET,1,1,1,1,MSGS,XTC,DN60,TSK,TLAB,1,1>
FETPER:	377777,,1B31!1B32!1B35	;(11) I/O features

  ;	%FTPE2==12,,71        I/O PARAMS (SECOND WORD)
  ;F%DX10 35 FTDX10 YES   DX10 DEVICE - CHAINING (MAGTAPES)
  ;       34-19 unused as of 7.03
    ;(12) OTHER PERIPERALS (SECOND WORD)
  ;*;	FTBITS<DX10>
FETPE2:	1,,0			;(12) More I/O features

  ;	%FTDS2==13,,71        INTERNAL DISK PARAMS
  ;F%DUAL 35 FTDUAL NO    DUAL-PORTED DISKS (RP04,RP06)
  ;       34-19 unused as of 7.03
    ;(13) DISK "INVISIBLE" FEATURES (SECOND WORD)
  ;*;	FTBITS<DUAL>
FETDS2:	1,,0			;(13) More Internal Disk features

  ;	%FTST2==14,,71        FILE STRUCTURE PARAMS
  ;F%PSTR 35 FTPSTR NO    PRIVATE FILE STRUCTURE
  ;F%SETS 34 FTSETS NO !  DON'T MOUNT CERTAIN DISKS AT ONCE-ONLY
  ;       33-19 unused as of 7.03
    ;(14) DISK UUO FEATURES (SECOND WORD)
  ;*;	FTBITS<PSTR,SETS>
FETST2:	3,,0			;(14) More File Structure features

  ;	%FTUU2==15,,71        UUOS
  ;F%MPB  35 FTMPB  NO    OLD VBATCH CODE
  ;       34-19 unused as of 7.03
    ;(15) LIST OF MONITOR NON-I/O FEATURES WHICH DIRECTLY IMPACT CUSPS (SECOND WORD)
  ;*;	FTBITS <MPB>
FETUU2:	1,,0			;(15) More Monitor Call features

FETLEN==.-FETTBL		; Table length
FETMXL==:<FETLEN-1>_^D9		; Length-1 for GETTABs
SUBTTL	Start of STOPCD data (see DIE:: in ERRCON)

;Data base to limit the number of STOPCD's per unit time so that we don't keep
;getting "continuable" STOPCD's that really aren't.  The data base consists of
;two tables, SCCTAB and SCLTAB.  SCCTAB is the count of the number of STOPCD's
;processed during the period indicated by the offset to it in the table.  SCLTAB
;contains, in the left half, the period for this entry and, in the right half,
;the limit of the number of STOPCD's during the period.  Both tables must be
;ordered such that the period of each entry is monotonically increasing.  The
;limits of each period are changable via the MONGEN dialog and may be changed
;by the customer.  When a STOPCD is processed by DIE, STCLIM increments the
;counts of STOPCD's for each entry and compares each with the limit for the
;entry.  If a limit has been exceeded, DIE turns the continuable STOPCD into a
;"stop" STOPCD.  If no limit has been exceeded, STCLIM puts in a clock request
;to call DECSCC after the period of the lowest entry in the table.  DECSCC
;decrements the count of STOPCD's for this entry and puts in a clock request to
;decrement the next higher count.  This continues until all have been
;decremented.  Note, that since the clock queue is used to decrement STOPCD
;counts, the period of the largest entry cannot be larger than 2**18-1 ticks.

SCCTAB::EXP	0		;Number of stopcodes in the last 60 seconds
	EXP	0		;Number of stopcodes in the last  8 minutes
	EXP	0		;Number of stopcodes in the last 60 minutes
SCCTBL==:.-SCCTAB		;LENGTH OF TABLE

ND LIM1MS,2	;Default values, can be overridden by MONGEN
ND LIM8MS,4
ND LIM1HS,8

SCLTAB::XWD	^D60,  LIM1MS	;Period = 1 minute,  Limit = LIM1MS = 2
	XWD	^D480, LIM8MS	;Period = 8 minutes, Limit = LIM8MS = 4
	XWD	^D3600,LIM1HS	;Period = 1 hour,    Limit = LIM1HS = 8

;(days from Nov17 to Jan01) + 105 years + leap years (except for 1900)
GMTUDT::^D<30-17+31+1+<<1964-1859>*365>+<<1964-1859>/4>-1>,,0 ;112773,,0
			;Number of days since 17-NOV-1858 and 1-JAN-1964

  ;Disk flags
CONTIG:: 1		;Nonzero to make files contiguous
DINITF:: 0		;Nonzero during disk initialization (ONCE)

  ;Data for STOPCD processor (see DIE:: in ERRCON)
DIECDB:: 0		;Physical address of CPU Data Block of crashing CPU
EPTSTS:: 0		;EPT status
UPTSTX:: 0		;UPT status

CCPNAM==:'CRSCPY'	;Name of program to run to copy crash

IFCPU (KL),<
SKPMRN::	;Routine to skip if master PDP-11 is running on KL
	JRST	CPOPJ1
CSDMP::	CSHUNL	;Routine to do a cache sweep on a KL
	POPJ	P,
>  ;End of IFCPU KL
SUBTTL	SYSTBL - System wide error data, GETTAB table .GTSYS=51

SYSTBL::!
%SYERR:: 0		;(00) System wide error count
%SYCCO::
CMNOTF:: 0		;(01) Number of times COMCNT was wrong
%SYDEL:: 0		;(02) Count of errors when error logging was disabled
%SYSPC:: 0		;(03) EXEC PC of most recent stopcode
%SYNDS:: 0		;(04) Number of DEBUG stopcodes
%SYNJS:: 0		;(05) Number of JOB stopcodes
%SYNCP::
COMTOT:: 0		;(06) Number of commands processed
%SYSJN:: 0		;(07) Job that caused most recent stopcode
%SYSTN:: 0		;(10) TTY name belong to user at most recent stopcode
%SYSPN:: 0		;(11) Program name running at most recent stopcode
%SYSUU:: 0		;(12) UUO in progress at most recent stopcode
%SYSUP:: 0		;(13) PC of UUO at most recent stopcode
%SYSPP:: 0		;(14) PPN of user running at most recent stopcode
%SYSPD:: 0		;Program directory
%SYSCP:: 0		;Number of CPU that got most recent stopcode
%SYSNM:: 0		;Name of most recent stopcode
%SYSTY:: 0		;Type of most recent stopcode
%SYSDT:: 0		;Date/time of most recent stopcode
%SYNCS:: 0		;Number of continued CPU stopcodes
%SYNIS:: 0		;Number of INFO/EVENT stopcodes
SYSMXL==:<.-SYSTBL-1>B26

DSKBAD:: 0		;Number of INFO/JOB stopcodes that set SLOCRS

SUBTTL	GTBWHY - Operator Reload Comments, GETTAB table .GTWHY=52
;In a running monitor, this table contains the comment the Operator gave when
;reloading the system, such as "Base crash - had to reload KL".
;In a crash dump, this table has the ACs in use at the time of a STOPCD.

CRSHAC:: BLOCK	20	;Operators answer to "Why reload" question in ASCIZ
PREVAC:: BLOCK	20	;Previous context ACs
WHYMXL==:<.-CRSHAC-1>B26

.CPCAC:: BLOCK 20	;Contents of AC block 0
.CPCA0=.CPCAC
.CPCA1::		;This block is not contiguous with .CPCAC in TOPS-10
IFCPU (F3),<BLOCK 20*3>	;AC blocks 1,2,3
IFCPU (KI),<BLOCK 20*3>	;AC blocks 1,2,3
IFCPU (KL),<BLOCK 20*5>	;AC blocks 1,2,3,4,5 (6 and 7 are special in microcode)
IFCPU (KS),<BLOCK 20*5>	;AC blocks 1,2,3,4,5
SUBTTL	SVSETS - Save all AC sets, call via JSR .CPSVA

;Routine to save all AC sets in .CPAC0, .CPAC1, etc.  Returns with
;all ACs preserved and the following locations set up:
;
;	.CPCPG - Argument to DATAO PAG, to restore current AC set
;	.CPACA - Address of saved values for current AC set.
;
;Call:
;		JSR	.CPSVA
;		 return here always

SVSETS:	DATAI	PAG,.CPCPG	;Save current state of AC blocks
IFNCPU(KI),<
	WRUBR	[LG.LAB+1B8]	;Save AC set 1
	MOVEM	17,.CPCA1+17
	MOVEI	17,.CPCA1+00
	BLT	17,.CPCA1+16
	MOVE	17,.CPCA1+17
	WRUBR	[LG.LAB+2B8]	;Save AC set 2
	MOVEM	17,.CPCA1+37
	MOVEI	17,.CPCA1+20
	BLT	17,.CPCA1+36
	MOVE	17,.CPCA1+37
	WRUBR	[LG.LAB+3B8]	;Save AC set 3
	MOVEM	17,.CPCA1+57
	MOVEI	17,.CPCA1+40
	BLT	17,.CPCA1+56
	MOVE	17,.CPCA1+57
IFG <NUMACB-4>,< ;F3 has only 0-3
	WRUBR	[LG.LAB+4B8]	;Save AC set 4
	MOVEM	17,.CPCA1+77
	MOVEI	17,.CPCA1+60
	BLT	17,.CPCA1+76
	MOVE	17,.CPCA1+77
>  ;End IFGE NUMACB-4
IFG <NUMACB-5>,< ;F3 has only 0-3
	WRUBR	[LG.LAB+5B8]	;Save AC set 5
	MOVEM	17,.CPCA1+117
	MOVEI	17,.CPCA1+100
	BLT	17,.CPCA1+116
	MOVE	17,.CPCA1+117
>  ;End IFGE NUMACB-5
	WRUBR	[LG.LAB+0B8]	;And leave AC set 0 as the current one
	MOVEM	17,.CPCA0+17
	MOVEI	17,.CPCA0+00
	BLT	17,.CPCA0+16
	LDB	17,[POINT 3,.CPCPG,8] ;Get number of current AC set
	JUMPN	17,SVSET1	;Go if not AC set 0
	MOVEI	17,.CPCA0	;AC set 0 might not be at .CPCA1-20
	JRST	SVSET2
SVSET1:	IMULI	17,20		;Compute offset into .CPCA1 of this set
	ADDI	17,.CPCA1-20	;Compute address of this nonzero set
SVSET2:	MOVEM	17,.CPACA	;Set address of active AC set
>  ;End IFNCPU(KI)
  PAGE
IFCPU (KI),<	;EXEC mode always uses AC block 0
IFN IG.LLH-400000,<PRINTX ?IG.LLH definition changed>
	MOVEM	17,.CPCA0+17	;Save AC 17 of block 0
	MOVEI	17,.CPCA0	;Place to store rest of AC's
	BLT	17,.CPCA0+16	;Save the rest
	JRSTF	@[PC.UIO,,.+1]	;Make XCTFU work
	DATAO	PAG,[<IG.LLH,,0>!1B2]  ;Make AC set 1 be the user set
	MOVEI	17,.CPCA1+00
	XCTFU	<BLT 17,.CPCA1+17>;Save AC block 1
	DATAO	PAG,[<IG.LLH,,0>!2B2]  ;Make AC set 2 be the user set
	MOVEI	17,.CPCA1+20	
	XCTFU	<BLT 17,.CPCA1+37>;Save AC block 2
	DATAO	PAG,[<IG.LLH,,0>!3B2]  ;Make AC set 3 be the user set
	MOVEI	17,.CPCA1+40
	XCTFU	<BLT 17,.CPCA1+57>;Save AC block 3
	MOVE	17,[IG.LLH,,IG.LRH];Get Load Left and Load Right bits
	IORM	17,.CPCPG	;Set for restore
	MOVEI	17,.CPCA0	;Address of saved AC block
	MOVEM	17,.CPACA	;Set address of active AC set
>  ;End IFCPU (KI)

;Save important stuff where CRSHID can find it
	MOVE	17,CRSHWD
	MOVEM	17,SAV30	;Save contents of location 30
	MOVE	17,[BASEDB,,BASAVE]
	BLT	17,BASAVE+BASEDL-1 ;Save IRING/ORING pointers in 170-207
	MOVE	17,[IRING,,IRINGX]
	BLT	17,IRINGX+<1_SIZIRG>-1;Save a snapshot of the IRING and ORING
	MOVE	17,[ORING,,ORINGX]
	BLT	17,ORINGX+<1_SIZORG>-1
	MOVEI	17,IRINGX_4	;Update pointer to copy of IRING
	MOVEM	17,BASAVE+IRINGA-BASEDB
	MOVEI	17,ORINGX_4	;Update pointer to copy of ORING
	MOVEM	17,BASAVE+ORINGA-BASEDB
	MOVE	17,.CPCA0+17	;Restore AC 17 of set 0
	DATAO	PAG,.CPCPG	;Restore current AC set
	JRSTF	@.CPSVA		;Return to caller
SUBTTL	RCDSTB and CPUSTS - Save CPU status

;ROUTINE TO RECORD THE CPU AND DEVICE STATUS BLOCKS.
;CALL:	PUSHJ	P,RCDSTB
;	RETURN

RCDSTB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
  ftdaem==0
IFN FTDAEM,<
	MOVEI	T1,.ERCSB	;CPU STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY FOR DAEMON
	MOVEI	T1,.ERDSB	;DEVICE STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY
>;END IFN FTDAEM
IFE FTDAEM,<DAEEST::>
	POPJ	P,		;RETURN

;SUBROUTINE TO STORE INFORMATION IN THE CPU STATUS BLOCK

CPUSTS::	;Taken from DEC's COMMON.702
IFNCPU(KI),<APRID .CPAPD	;(0) APRID >
IFCPU (KI),<CONI  PAG,T1	;(0) APR SERIAL NUMBER
	    LSH   T1,-^D26	;Only the serial number
	    MOVEM T1,.CPAPD  >
	CONI	APR,.CPACN	;(1) CONI APR,
	CONI	PI,.CPPIC	;(2) CONI PI,
	DATAI	PAG,.CPPGD	;(3) DATAI PAG,
	CONI	PAG,.CPPGC	;(4) CONI PAG,
IFCPU (KI),<HLRZ T1,.CPPGD	;Get UBR
	    HRRZ T2,.CPPGD	;Get EBR >
IFNCPU(KI),<HRRZ T1,.CPPGD	;Get UBR
	    HRRZ T2,.CPPGC	;Get EBR >
	MOVEM	T1,UPTSTX	;Store for FILDDT
	MOVEM	T2,EPTSTS	;           "
	ANDI	T1,17777	;Just the UBR
	LSH	T1,^D9		;Address of UPT
	CAML	T1,MEMSIZ	;Within physical memory?
	 TLO	T1,(1B0)	;No, flag it as being unreliable
	MOVEM	T1,.CPUPT	;Store physical address of UPT in the CDB
	MOVE	T1,[%UPT+424,,.CPUP0] ;(5) UPT LOCS 424-427
	SKIPL	.CPUPT		;Don't try to access funnyspace if bad UBR
	 BLT	T1,.CPUP0+3	;(5-10)
IFCPU(KL),<
	DTE0==200	;Data Ten/Eleven interface (DTE0=console front end)
	DTE1==204
	DTE2==210
	DTE3==214
	RH20==540	;RH20 Massbus controller - Disk and Tape on KL
	RH21==544	; (RP04/RP05/RP06 disks)
	RH22==550	; (DX20 with TU70/TU71/TU72 tape drives)
	RH23==554	; (DX20 with RP20 fixed disk)
	RH24==560
	RH25==564
	RH26==570
	RH27==574
	MTR== 024	;Meter
	TIM== 020	;Timer

	RDERA	.CPERA		;(11) RDERA
	CONI	RH20,.CPRHC+0	;(12) CONI RH20, FOR ALL 8 RH'S
	CONI	RH21,.CPRHC+1
	CONI	RH22,.CPRHC+2
	CONI	RH23,.CPRHC+3
	CONI	RH24,.CPRHC+4
	CONI	RH25,.CPRHC+5
	CONI	RH26,.CPRHC+6
	CONI	RH27,.CPRHC+7
	CONI	DTE0,.CPDTC+0	;(22) CONI DTEn
	CONI	DTE1,.CPDTC+1
	CONI	DTE2,.CPDTC+2
	CONI	DTE3,.CPDTC+3
	HRLZ	T1,.CPEPT	;(26) EPT LOCS 0-37 (RH20 LOGOUT AREAS)
	HRRI	T1,.CPEP0
	BLT	T1,.CPEP0+37	;(26-65)
	MOVE	T1,.CPEPT	;(66) EPT LOCS 140-177  (DTE CONTROL BLOCKS)
	HRLI	T1,140(T1)
	HRRI	T1,.CPEP1
	BLT	T1,.CPEP1+37	;(66-125)
>  ;END IFCPU(KL)
IFNCPU(KI),<
	MOVE	T1,[%UPT+500,,.CPUP1] ;(126) UPT LOCS 500-503  (PAGE FAIL)
	SKIPL	.CPUPT		;Don't try to access funnyspace if bad UBR
	 BLT	T1,.CPUP1+3
>  ;END IFNCPU(KI)
IFCPU(<KL,KS>),<;F3 does not have AC blocks 4-7
	WRUBR	[LG.LAB+6B8]	;(132) AC BLOCK 6, REGS 0-3 AND 12
	MOVEM	0,.CP6
	MOVEM	1,.CP6+1
	MOVEM	2,.CP6+2
	MOVEM	3,.CP6+3
	MOVEM	12,.CP6+4
	WRUBR	[LG.LAB+7B8]	;(136) AC BLOCK 7, REGS 0-2
	MOVEM	0,.CP7
	MOVEM	1,.CP7+1
	MOVEM	2,.CP7+2
	DATAO	PAG,.CPPGD	;RESTORE ORIGIONAL AC BLOCK
>;END IFCPU(KL,KS)
IFCPU(KL),<PUSHJ P,REDSBC>	;READ SBDIAG INFO
	MOVEI	T1,SR.CSB	;SET FLAG TO INDICATE CPU
	IORM	T1,.CPSBR	;STATUS BLOCK READ ON THIS CPU
	POPJ	P,
SUBTTL	S-BUS diagnostic routines
IFCPU(KL),<;ROUTINE TO CLEAR SBUS ERRORS IN EACH MEMORY CONTROLLER.  RETURNS
	   ;CPOPJ ALWAYS AND PRESERVES ALL AC'S.

CLRSBD::JSP	T4,SAVE4	;SAVE P1-P4 ;*NOTE*: Not PUSHJ P,SAVE4 !
	MOVSI	P1,-.SBNMC	;MAKE AOBJN POINTER TO ALL MEM CONTROLLERS
	MOVSI	P2,SB.CLR	;BIT TO CLEAR ALL ERRORS
CLRSB1:	DPB	P1,[POINT 5,P2,4] ;STORE MEMORY CONTROLLER NUMBER
	SBDIAG	P2		;CLEAR THE ERROR BITS
	AOBJN	P1,CLRSB1	;LOOP FOR ALL CONTROLLERS
	POPJ	P,		;RETURN

;ROUTINES TO PERFORM SBDIAG FUNCTIONS 0 AND 1 FOR EACH MEMORY CONTROLLER.
;CALL REDSBD TO JUST READ THE DATA.  CALL REDSBC TO READ THE DATA AND
;CLEAR THE ERRORS.  THE FORMAT OF THE SBDIAG STATUS BLOCK IS AS FOLLOWS:
;	WORD 0: -NUMBER OF DATA BLOCKS,,OFFSET TO FIRST BLOCK
;EACH DATA BLOCK HAS THE FOLLOWING FORMAT:
;	WORD 0: -NUMBER OF WORDS FOLLOWING,,CONTROLLER NUMBER
;	WORD 1: SBDIAG FUNCTION 0 FROM-MEMORY WORD
;	WORD 2: SBDIAG FUNCTION 1 FROM-MEMORY WORD
;DESTROYS T1, PRESERVES ALL OTHERS

REDSBD::TDZA	T1,T1		;CLEAR T1 AND SKIP
REDSBC::MOVSI	T1,SB.CLR	;BIT TO CLEAR ERRORS
	JSP	T4,SAVE4	;SAVE P1-P4 ;*NOTE*: Not PUSHJ P,SAVE4 !
	SETZM	.CPSBD		;CLEAR FIRST WORD OF BLOCK FOR COUNT
	MOVSI	P1,-.SBNMC	;AOBJN POINTER TO MEMORY CONTROLLERS
	MOVEI	P2,.CPSBD+1	;START FIRST BLOCK HERE
	HRLI	P2,-.SBFNC	;-FUNCTIONS TO LH
REDSB1:	MOVEI	P3,0		;SET TO BUILD TO-MEMORY WORD
	DPB	P1,[POINT 5,P3,4] ;STORE MEMORY CONTROLLER
	SBDIAG	P3		;DO FUNCTION 0
	PUSH	P,P4		;SAVE FUNCTION 0 FROM-MEMORY WORD
	JUMPE	T1,REDSB2	;AVOID 2ND SBDIAG IF NOT CLEARING CONTROLLER
	IOR	P3,T1		;SET SB.CLR
	SBDIAG	P3		;DO FUNCTION 0 TO CLEAR CONTROLLER
REDSB2:	TRO	P3,1		;MAKE IT FUNCTION 1
	SBDIAG	P3		;DO FUNCTION 1
	POP	P,P3		;RESTORE FUNCTION 0 FROM-MEMORY WORD
	SKIPN	P3		;ANYTHING THERE?
	 JUMPE	P4,REDSB3	;NO, NO MEMORY CONTROLLER IF BOTH ZERO
	MOVEM	P3,1(P2)	;SAVE FUNCTION 0 WORD IN THE BLOCK
	MOVEM	P4,2(P2)	;  ALONG WITH FUNCTION 1 WORD
	HRRZM	P1,0(P2)	;SAVE CONTROLLER NUMBER AS WORD 0
	HLLM	P2,0(P2)	;MAKE IT -WORDS,,CONTROLLER
	AOS	.CPSBD		;COUNT THIS CONTROLLER
	ADDI	P2,.SBFNC+1	;INCREMENT TO NEXT BLOCK
REDSB3:	AOBJN	P1,REDSB1	;LOOP FOR NEXT CONTROLLER
	MOVN	P1,.CPSBD	;GET NUMBER OF BLOCKS WE STORED
	JUMPE	P1,CPOPJ	;LEAVE IT ZERO IF NONE
	HRLI	P1,1		;MAKE SWAPPED HEADER WORD
	MOVSM	P1,.CPSBD	;SAVE IN WORD 0
	POPJ	P,		;RETURN
>;END IFCPU (KL)
;SUBROUTINE TO READ AND STORE DEVICE STATUS

DVCSTS::POPJ P, ;*HACK*;	;Don't do CONI of all possible I/O devices
REPEAT 0,<;;Not needed yet for TYMCOM-X hardware
; 000=CPA   004=PI    010=PAG   014=CCA   020=TIM   024=MTR   030=ADC2  034=
; 040=      044=      050=      054=      060=DLB1  064=DLC2  070=CLK1  074=CLK2
; 100=PTP   104=PTR   110=CDP   114=CDR   120=TTY   124=LPT1  130=DIS1  134=DIS2
; 140=PLT1  144=PLT2  150=CR1   154=CR2   160=DLB2  164=DLC2  170=DSK1  174=DSK2
; 200=DTE0  204=DTE1  210=DTE2  214=DTE3  220=DX10  224=      230=LPT3  234=LPT2
; 240=DLS1  244=DLS2  250=DPC1  254=DPC2  260=DPC3  264=DPC4  270=FSD1  274=FSD2
; 300=DCSA  304=DCSB  310=      314=      320=DTC1  324=DTS1  330=DTC2  334=DTS2
; 340=TMC1  344=TMS1  350=TMC2  354=TMS2  360=FSD3  364=      370=      374=
; 400=      404=      410=      414=      420=      424=      430=      434=
; 440=      444=      450=      454=      460=DSS1  464=DSI1  470=DSS2  474=DSI2
; 500=      504=      510=      514=      520=      524=      530=      534=
; 540=RH20  544=RH21  550=RH22  554=RH23  560=RH24  564=RH25  570=RH26  574=RH27
; 600=      604=      610=      614=      620=      624=      630=      634=
; 640=      644=      650=      654=      660=      664=      670=      674=
; 700=      704=      710=      714=      720=      724=      730=      734=
; 740=user  744=user  750=user  754=user  760=user  764=user  770=user  774=user

;Device codes, in alphabetical order
	CCI== 014	;Computer-Computer Interface (KI to PDP-8 on DA-10)
	CLK1==070	;Real-time clock
	CLK2==074
	CDP== 110	;Card punch
	CDR== 114	;Card reader
	CDR1==150	;Buffered card reader
	CDR2==154
	DAC== 320	;DECtape controller (TD10+TU55)
	DAS== 324
	DBC== 330	;DTB:
	DBS== 334
	DLB1==060	;Old PDP-11 interface
	DLB2==160
	DLC1==064
	DLC2==164
	DLS1==240	;Data line scanner
	DLS2==244
	DPC1==250	;Disk pack control (RD10 with RP02 or RP03)
	DPC2==254
	DPC3==260
	DPC4==264
	DX10==220	;Old TU-70 tape controller
	FHD1==170	;Fixed Head Disk controller (RD10)
	FHD2==174
	FSD1==270	;?
	FSD2==274
	FSD3==360
	LPT1==124	;Lineprinter
	LPT2==234
	LPT3==230
	PLT1==140	;Plotter
	PLT2==144
	PTP== 100	;Paper tape reader/punch
	PTR== 104
	TMC1==340	;Magtape controller
	TMS1==344
	TMC2==350
	TMS2==354
	TTY== 120	;Console TTY (KI only)

DVCSTS::
IFCPU (KI),<CONI TTY,.CPTTY	;Console CTY
	    CONI CCI,.CPCCI >       ;DA-CONI 014, sweeps cache on KL)
IFCPU (<KI,KL>),< ;Read status of devices on the I/O bus
	CONI	PTR,.CPPRA
	CONI	PTP,.CPPPA
	CONI	DLS1,.CPDLS
;	CONI	DLS2,.CP---
	CONI	DAC,.CPDAC
	CONI	DAS,.CPDAS
	CONI	TMS1,.CPTMS
	CONI	TMC1,.CPTMC
;	CONI	TMS2,.CP---
;	CONI	TMC2,.CP---
	CONI	DX10,.CPDX1
	CONI	FHD1,.CPDSK
	CONI	FHD2,.CPFH2
	CONI	FSD1,.CPFSD
	CONI	FSD2,.CPFS2
	CONI	FSD3,.CPFS3
	CONI	DPC1,.CPDPC
	CONI	DPC2,.CPDP2
	CONI	DPC3,.CPDP3
	CONI	DPC4,.CPDP4
	CONI	DBS,.CP2DS
	CONI	DBC,.CP2DC
	CONI	DLC1,.CPDLC
	CONI	DLB1,.CPDLB
	CONI	DLC2,.CPDC2
	CONI	DLB2,.CPDB2
	CONI	CDP,.CPCDP
;	CONI	CDR,.CP---
	CONI	CDR1,.CPCRA
	CONI	CDR2,.CPCRB
	CONI	LPT1,.CPLPT
	CONI	LPT2,.CPLPB
	CONI	LPT3,.CPLPC
	CONI	PLT1,.CPPLA
	CONI	PLT2,.CPPLB
IFCPU (KI),<DATAI APR,.CPDST >		;CONSOLE SWITCHES
IFCPU (KL),<DATAI APR,.CPDAK >		;ADDRESS BREAK CONDITIONS
	DATAI	DSK1,.CPDDK
	DATAI	FHD2,.CPDH2
	DATAI	FSD1,.CPDFS
	DATAI	FSD2,.CPDS2
	DATAI	FSD3,.CPDS3
	DATAI	DPC1,.CPDDP
	DATAI	DPC2,.CPDD2
	DATAI	DPC3,.CPDD3
	DATAI	DPC4,.CPDD4
	DATAI	DLC1,.CPDDC
	DATAI	DLB1,.CPDDB
	DATAI	DLC2,.CPD2C
	DATAI	DLB2,.CPD2B
>;END IFCPU (<KI,KL>)
IFCPU (KL),<
	CONI	TIM,.CPTMR	;KL interval timer status
	CONI	MTR,.CPMTR	;KL meter status
	DATAO	RH20,RH2IVI
	DATAI	RH20,.CPIVI+1
	DATAO	RH21,RH2IVI
	DATAI	RH21,.CPIVI+3
	DATAO	RH22,RH2IVI
	DATAI	RH22,.CPIVI+5
	DATAO	RH23,RH2IVI
	DATAI	RH23,.CPIVI+7
	DATAO	RH24,RH2IVI
	DATAI	RH24,.CPIVI+11
	DATAO	RH25,RH2IVI
	DATAI	RH25,.CPIVI+13
	DATAO	RH23,RH2IVI
	DATAI	RH26,.CPIVI+15
	DATAO	RH27,RH2IVI
	DATAI	RH27,.CPIVI+17
>;END IFCPU (KL)
IFCPU (KS),<
	RDINT	.CPTMR		;READ INTERVAL TIMER
	RDTIME	.CPTMB		;READ TIME BASE
	PUSH	P,%UPT+.LMPFP
	PUSH	P,%UPT+.LMPFW
	MOVE	T1,[-KSCTBL,,KSCTAB] ;POINTER TO DEVICE ADDRESS TABLE
	MOVE	T2,[EXP XC.UIO+KSCTRP] ;TRAP ADDRESS FOR NX DEVICES
	EXCH	T2,%UPT+.LMPFN	;SET IT AND SAVE CURRENT ONE
	MOVEI	T3,.CPUB1	;FIRST STORE ADDRESS IN CDB SUB-TABLE
KSCLOP:	RDIO	T4,@(T1)	;READ SOME REGISTER
	MOVEM	T4,(T3)		;SAVE IT IN RIGHT SLOT
KSCTRP:	AOS	T3		;BUMP CDB ADDRESS
	AOBJN	T1,KSCLOP	;DO NEXT
	EXCH	T2,%UPT+.LMPFN	;RESTORE TRAP ADDRESS
	JRST	KSCEND		;DONE

KSCTAB==.			;START OF KS10 DEVICE ADDRESS TABLE
UB1STS:	XWD	1,UNBSTW	;UBA1 STATUS REGISTER
UB3STS:	XWD	3,UNBSTW	;UBA3 STATUS REGISTER
RH1STS:	RH11CA			;RPCS1
RH1ST2:	RH11CA+10		;RPCS2
RH2STS:	RH21CA			;MTCS1
RH2ST2:	RH21CA+10		;MTCS2
LPTSTS:	LP11CA			;LPT CSRA
LPTST2:	LP11CA+2		;LPT CSRB
CDRSTS:	CD11BA			;CDR CDST
KSCEND==.			;END OF KS10 DEVICE ADDRESS TABLE
KSCTBL==KSCEND-KSCTAB	;LENGTH OF KS10 DEVICE ADDRESS TABLE
	POP	P,%UPT+.LMPFW
	POP	P,%UPT+.LMPFP
>;END IFCPU (KS)
LENDVS==:<.-DVCSTS-1>B26
	MOVEI	T1,SR.DSB		;SET FLAG TO INDICATE
	IORM	T1,.CPSBR		;DEVICE STATUS BLOCK READ
	POPJ	P,
IFCPU (KL),< RH2IVI:	740000,,0 >
>  ;End of REPEAT 0
SUBTTL	TYPCSB - Routine to type relevant parts of the CPU status block

TYPCSB::PUSHJ	P,INLMES##
	ASCIZ/
CPU Status Block
/
	PUSHJ	P,INLMES##
	ASCIZ/
APRID = /
	MOVE	T1,.CPAPD	;GET APRID
	PUSHJ	P,HWDPNT##	;TYPE IT
IFCPU (KL),<
	PUSHJ	P,INLMES##
	ASCIZ/
ERA = /
	SKIPN	T1,.CPAER
	 MOVE	T1,.CPERA	;GET ERA
	PUSHJ	P,HWDPNT##	;TYPE IT
>  ;END IFCPU (KL)
	PUSHJ	P,INLMES##
	ASCIZ/
CONI APR, = /
	MOVE	T1,.CPACN	;GET CONI APR
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PI, = /
	SKIPN	T1,.CPCPI
	 MOVE	T1,.CPPIC	;GET CONI PI
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PAG, = /
	MOVE 	T1,.CPPGC	;GET CONI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
DATAI PAG, = /
	MOVE	T1,.CPPGD	;GET DATAI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
IFNCPU(KL),<PUSHJ P,CRLF##>	;Force blank line after CPU status block
IFCPU (KL),<
	PUSHJ	P,INLMES##
	 ASCIZ/
AR ARX Data Words (7:0 & 7:1) = /
	MOVE	T1,.CP7+0	;GET AC BLOCK 7 LOC 0
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	 ASCIZ/ & /
	MOVE	T1,.CP7+1	;GET AC BLOCK 7 LOC 1
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	 ASCIZ/
Page Fail Words   (7:2 & 500) = /
	MOVE	T1,.CP7+2	;GET AC BLOCK 7 LOC 2
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	 ASCIZ/ & /
	MOVE	T1,.CPUP1+0	;Page fail code from UPT location 500
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	 ASCIZ/

SBUS Diags:

CNTRLR FNC 0          FNC 1
/
	PUSHJ	P,TYPSBD	;TYPE SBDIAG INFORMATION
>  ;END IFCPU(KL)
	PJRST	CRLF##		;END WITH CRLF AND RETURN
;Routine to type the SBDIAG functions and values on CTY during crash

IFCPU(KL),<
TYPSBD::PUSH	P,P1		;SAVE P1
	PUSH	P,P2		;  AND P2
	MOVE	P1,.CPSBD	;GET -# BLOCKS,, OFFSET TO FIRST
	HRRZI	P2,.CPSBD(P1)	;POINT AT FIRST BLOCK
TYPSB1:	HLL	P2,0(P2)	;MAKE P2 BE AOBJN POINTER TO THIS BLOCK
	HRRZ	T1,0(P2)	;GET CONTROLLER LOGICAL ADDRESS
	PUSHJ	P,OCTPNT##	;PRINT IT
	HRRI	P2,1(P2)	;ADVANCE TO FIRST OF FUNCTION WORDS
TYPSB2:	PUSHJ	P,PRSPC##	;SEPARATE FIELDS WITH A SPACE
	MOVE	T1,0(P2)	;GET NEXT FUNCTION WORD
	PUSHJ	P,HWDPNT##	;TYPE IT
	AOBJN	P2,TYPSB2	;LOOP FOR ALL WORDS IN THIS BLOCK
	PUSHJ	P,CRLF##	;TYPE CRLF AT END OF LINE
	AOBJN	P1,TYPSB1	;LOOP FOR ALL BLOCKS
	POP	P,P2		;RESTORE P2
	POP	P,P1		;  AND P1
	POPJ	P,		;RETURN
>  ;END IFCPU(KL)
SUBTTL	CRSDB - crash data block definitions

  ;Per CPU data (This table needs to be rearranged in the right order)

.CPSLF:: .		;Pointer to start of CDB for this CPU
.CPDWD:: -1		;DIE word, checks for recursion in stopcode handler
.CPEVN:: -1		;NODIE word, checks for INFO and EVENT stopcodes
.CPCPC:: 0		;Continue PC, defaults to location after STOPCD macro
.CPCPI:: 0		;Saves CONI PI, during STOPCD
.CPCPG:: 0		;Pager status (including AC set in use) at STOPCD
.CPSCB:: 0		;STOPCD block address
.CPSNM:: 0		;STOPCD name
.CPSPC:: 0		;STOPCD EXEC PC
.CPSTY:: 0		;STOPCD type
.CPSDT:: 0		;STOPCD date/time
.CPSJN:: 0		;STOPCD job number
.CPSPN:: 0		;STOPCD program name
.CPSPD:: 0		;STOPCD program directory
.CPSPP:: 0		;STOPCD PPN
.CPSTN:: 0		;STOPCD TTY name
.CPSUU:: 0		;STOPCD UUO
.CPSUP:: 0		;STOPCD user PC
.CPSND:: 0		;STOPCD number of DEBUG stopcodes
.CPSNJ:: 0		;STOPCD number of JOB stopcodes
.CPSNC:: 0		;STOPCD number of CPU stopcodes
.CPSNI:: 0		;STOPCD number of INFO/EVENT stopcodes

.GTCRS:: ;Crash data block (The numbers in parens are defined for TOPS-10)
.CPAPD:: 0		;(0) APRID
.CPACN:: 0		;(1) CONI APR,
.CPPIC:: 0		;(2) CONI PI,
.CPPGD:: 0		;(3) DATAI PAG,
.CPPGC:: 0		;(4) CONI PAG,
.CPUP0:: BLOCK 4	;(5-10) UPT LOCS 424-427 (MUUO AREA)
  ;11-125 meaningful on KL only
.CPERA:: 0		;(11) RDERA
.CPRHC:: BLOCK 8	;(12-21) CONI RH20, FOR ALL 8 RH'S
.CPDTC:: BLOCK 4	;(22-25) CONI DTEn
.CPEP0:: BLOCK 40	;(26-65) EPT LOCS 0-37 (RH20 LOGOUT AREAS)
.CPEP1:: BLOCK 40	;(66-125) EPT LOCS 140-177  (DTE CONTROL BLOCKS)
  ;126-141 on KL and KS (not KI)
.CPUP1:: BLOCK 4	;(126-131) UPT LOCS 500-503  (PAGE FAIL AREA)
.CP6::   BLOCK 5	;(132-135) AC BLOCK 6, REGS 0-3 AND 12
.CP7::   BLOCK 3	;(136-141) AC BLOCK 7, REGS 0-2
  ;142-211 on KL only
.CPSBD:: BLOCK 50	;(142-211) SBDIAG DATA
.CPSBR:: 0		;Status, SR.CSB set if 0-136 have saved data


.CPUPT:: UPT		;Physical address of the UPT, negative if invalid
.CPEPT:: EPT		;Physical address of the EPT for this CPU
.CPCPN:: 1		;Number of this CPU
.CPJOB:: 0		;Number of job running on this CPU
.CPISF:: 0		;In Scheduler-context Flag
.CPCTN:: '0'-'0'	;CTY: is line 0, TTY0:=CTYLDB
.CPTIA:: 0		;Routine to input 1 character from TTY (or CTY)
  COMTIA=:.CPTIA
.CPTOA:: 0		;Same for output
  COMTOA=:.CPTOA
.CPEPD:: IOWD 60,.CPPDL	;To reset the stack
.CPPDL:: BLOCK 60	;Stack for error processing
  SYSPDL=:.CPPDL+1	;Used by ONCE and CRASH code
.CPDDT:: JRST DDTX##	;Instruction to enter DDT on this CPU
.CPLOG:: APRNAM		;Logical name (AA, BB, CC, etc) ,, base node #
.CPCPU:: APRSN		;CPU type in LH,,Serial number system was built for
			;ONCE sets SERIAL to APRID but leaves .CPCPU alone
.CPSNO:: SYSNO		;System number from CONF##.MAC (right justified SIXBIT)
.CPSVA:: 0		;Do JSR .CPSVA to save all AC blocks
	 JRST SVSETS	;Jump to routine to save ACs
.CPACA:: 0		;Address of active ACs

;Data locations for PICON when APRINT detects parity error
.CPPER=SAVAPR##		;Results of CONI APR, on PARITY/NXM interrupt
IFCPU (KL),<
.CPAER=SAVERA##		;Results of RDERA on PARITY/NXM interrupt
.CPSB0=SAVSB0##		;SBUS DIAG, controller 4 (DMA20), function 0
.CPS0A=SAVSB0##+1	; result stored here after parity error
.CPSB1=SAVSB1##		;SBUS DIAG, controller 4 (DMA20), function 1
.CPS1A=SAVSB1##+1	; result stored here after parity error
>  ;End IFCPU(KL)

;End of DEC's crash data block
;-------------------------------------------------------------------------------
;Start of TYMSHARE's crash data block

IFCPU (KL),<;KL specific CPU registers
SBDST1:: 4B4+0		;(-5) SBUS DIAG, controller 4 (DMA20), function 0
         0		;(-4) result stored here after stopcode
SBDST2:: 4B4+1		;(-3) SBUS DIAG, controller 4 (DMA20), function 1
         0		;(-2) result stored here after stopcode
ERASTS:: 0		;(-1) Results of RDERA after stopcode
>; IFCPU KL

IFCPU (KS),<;KS specific CPU registers
KAFPC::	0		;(-25) 4 word block for XPCW if keep alive fails
	0		;(-24) KAFPC+0 = old flags, KAFPC+1 = old 30-bit PC
	0		;(-23) KAFPC+2 = new flags (zero for kernel)
	KAFCRS		;(-22) KAFPC+3 = new 30-bit PC
HLTSTS::0		;(-21) MAG register
	0		;(-20) PC register
	0		;(-17) HR register
	0		;(-16) AR register
	0		;(-15) ARX register
	0		;(-14) BR register
	0		;(-13) BRX register
	0		;(-12) ONE (1) register
	0		;(-11) EBR register
	0		;(-10) UBR register
	0		;(-7) MASK register
	0		;(-6) FLG (flags,page fail code) register
	0		;(-5) PI register
	0		;(-4) XWD1 (1,,1) register
	0		;(-3) T0 register
	0		;(-2) T1 register
	0		;(-1) VMA (with flags)
>; IFCPU KS

IFCPU (KI),<;KI specific CPU registers - none>
IFCPU (F3),<;F3 specific CPU registers - none>

CRSDB::	; * * * CRASH DATA BLOCK * * *
	; + index are processor independent
	; - index are processor dependent
	; CRSDB is pointed to by lh(CONFIG-2) so CRSHID can find it
;symbol			index  instruction          cpus
;------			-----  ----------- 	    ----
PISTS::	0		;(0)  CONI  PI,  (RDPI)	    ILS3
APRSTS::0		;(1)  CONI  APR, (RDAPR)    ILS3
PAGDTI::0		;(2)  DATAI PAG, (RDUBR)    ILS3
PAGCNI::0		;(3)  CONI  PAG, (RDEBR)    ILS3
AIDSTS::0		;(4)  BLKI  APR, (APRID)    .LS.
APRDTI::0		;(5)  DATAI APR, (RSW)	    IL.3 (KL address break)
	0		;(6)
	0		;(7)
	0		;(10)
	0		;(11)
	0		;(12)
	0		;(13)
	EPT,,CRSHAC	;(14) address of some useful stuff
SAV30::	0		;(15) value of 30 saved here
STOPCN::0		;(16) count of times we tried to crash
STOPPC::0		;(17) real PC of first STOPCD we hit
CRSLEN==.-CRSDB
CRSMXL==:<CRSLEN-1>_^D9

  ;These variables should be moved somewhere else
BADINT::0		;bad interrupts weve gotten
BADQUE::0		;attempts to assign a job not in NUL queue
BADQTM::0		;time last job assignment was made
SUBTTL	JSR SYSCRS and JRST CRASHX routines

SLOCRS::0	;Nonzero for slow DSKCLN, set by STOPCD(.,DSKCLN) or STOPCD(SLO)
NOCRS:: 0	;Nonzero for no dump + manual DSKCLN, PC of STOPCD(NO) in RH

KAFCRS::MOVEM	P,KAFPDL	;Save possible stack pointer
	MOVEI	P,KAFPDL	;Point to 1-word stack
S..KAF:: STOPCD (.,CPU,KAF,KAFPRT,<Keep Alive Failure>)

KAFPRT:	PUSHJ	P,INLMES##	;Routine for STOPCD(KAF)
	 ASCIZ	/Last interrupt/
IFCPU(KS),<SKIPN T2,KAFPC+1>	;Get old PC if 8080 did it to us
	MOVE	T2,CH1		;Get PC at time of channel-1 interrupt
	PJRST	PCP##		;" at user PC 000000"

KAFPDL:	BLOCK	2		;Old P at KAFPDL+0, PUSHJ stores PC at KAFPDL+2

TAKDWN:: 0			;JSR here from CLOCK1 on an orderly shutdown
	EXCH	P,TAKDWN	;TAKDWN nonzero if TAKEIT ran
	SUBI	P,1
	MOVEM	P,STOPPC	;CRSDB+17
	EXCH	P,TAKDWN
	JRST	CRASHX

CRS147:: 0			;JSR here from a 147 restart
	EXCH	P,CRS147
	SUBI	P,1
	MOVEM	P,STOPPC	;CRSDB+17
	EXCH	P,CRS147
	JRST	CRASHX

CRASH2:: 0			;JSR here from PICON when "DM 30,1"
	EXCH	P,CRASH2
	SUBI	P,1
	MOVEM	P,STOPPC	;CRSDB+17
	EXCH	P,CRASH2
	PFALL	CRASHX

;Here for a non-STOPCD crash (TAKEIT, DM 30.1, ST 147)
;Need to save things that the stopcode processor would have saved.

CRASHX::SKIPE	STOPCN		;CRSDB+16 Have we been here before?
	 JRST	CRASHZ		;Don't wipe out saved data
	AOS	STOPCN		;Make nonzero so we don't come here again
	CONI	PI,PISTS	;CRSDB+0 (PIs active)
	CONI	APR,APRSTS	;CRSDB+1 (APR error bits)
	DATAI	PAG,PAGDTI	;CRSDB+2 (UPT and current AC block)
	CONI	PAG,PAGCNI	;CRSDB+3 (EPT addres)
IFCPU(<KL,KS>),<APRID AIDSTS>	;CRSDB+4 (CPU serial number)
IFNCPU(KS),<DATAI APR,APRDTI>	;CRSDB+5 (address break conditions)
IFCPU (KL),<
	SWPUA			;Sweep cache, unload all words to memory
	CONSO	APR,LP.CSD      ;Wait for sweep done
	 JRST	.-1
	RDERA	ERASTS		;CRSDB-1 (error address)
	SBDIAG	SBDST1		;CRSDB-5 (function 0 for DMA20)
	SBDIAG	SBDST2		;CRSDB-3 (function 1 for DMA20)
>  ;End IFCPU(KL)
	MOVEM	17,CRSHAC+17
	MOVEI	17,CRSHAC	;Save current AC block
	BLT	17,CRSHAC+16
	MOVEI	17,PREVAC
	PXCT	1,BPRVAC	;XCTFU <BLT 17,PREVAC+17>;Save previous AC block
	MOVE	17,CRSHWD	;Contents of location 30
	MOVEM	17,SAV30	;CRSDB+15
	JRST	CRASHZ
BPRVAC::BLT	17,PREVAC+17	;Not in a literal in case COMLIT gets wiped out

REBOOT::	;Enter here from DIE, the STOPCD processor
;Start of CRSHID kludge (store in old locations for CRSHID or curious CE's)
	MOVE	P,.CPCPI	;Get CONI PI that DIE saved
	MOVEM	P,PISTS		;CRSDB+0
	MOVE	P,.CPACN	;Get CONI APR from RCDSTB
	MOVEM	P,APRSTS	;CRSDB+1
	MOVE	P,.CPPGD	;Get DATAI PAG from RCDSTB
	MOVEM	P,PAGDTI	;CRSDB+2 (UPT and AC block status)
	MOVE	P,.CPPGC	;Get CONI PAG from RCDSTB
	MOVEM	P,PAGCNI	;CRSDB+3
	MOVE	P,.CPAPD	;Get APRID from RCDSTB
	MOVEM	P,AIDSTS	;CRSDB+4
IFNCPU(KS),<DATAI APR,APRDTI>	;CRSDB+5 Console switches or KL address break
	MOVE	P,.CPSPC	;Get the STOP-PC saved by DIE
	MOVEM	P,STOPPC	;CRSDB+17 (CRSDB+15=SAV30 set by .CPSVA)
IFCPU (KL),<
	SWPUA			;Sweep cache, unload all words to memory
	CONSO	APR,LP.CSD      ;Wait for sweep done
	 JRST	.-1
	RDERA	ERASTS		;CRSDB-1
	SBDIAG	SBDST1		;CRSDB-5
	SBDIAG	SBDST2		;CRSDB-3
>  ;End IFCPU(KL)
	AOS	STOPCN		;CRSDB+16 Tell CRSHID that CRSDB is valid
	PFALL	CRASHZ
;End of CRSHID kludge

;Here when all ACs have been saved, and crash data block set up

CRASHZ:	SYSPIF			;Turn off PI system (again)
IFNCPU(KI),<	WRUBR [LG.LAB+0B8+0B11]> ;KI always uses AC block 0
IFCPU(<KI,F3>),<DATAO PI,[-1]>	;Turn on all the lights
IFCPU (F3),<	TNCONO 0 >	;Reset interface to node
IFNCPU(KS),<	WRADB [0]>	;Clear address break
	MOVE	P,.CPEPD	;Set up emergency PDL
	MOVE	T1,STOPCN	;Stop count
	CAILE	T1,4		;Are we looping?
	 JRST	NOBOOT		;Yes, output message and halt
	PUSHJ	P,CRSWHY	;Tell OPR why we are crashing
	MOVE	T1,STOPCN	;This should be 1
	CAIE	T1,1		;Have we been here before?
	 JRST	BOTLOD		;Go to BOOTS, don't touch HOM pages this time
	PUSHJ	P,CRSDEV	;Read device status (duplicates RCDSTB's work)
	PUSHJ	P,CRSMAP	;Remap context pages into exec memory
	PUSHJ	P,CRSHOM	;Update HOM pages if needed
	PUSHJ	P,NEWMON##	;Go load new monitor, never returns
NOBOOT:	  HALT	BOTLOD##	;Load BOOTS only if NEWMON fails
;Try to determine cause of crash, output message to CTY

CRSWHY:	MOVEI	T1,[ASCIZ /
/]					;No message if STOPCD crash
	SKIPN	T2,SAV30
	 JRST	CRSWH1
	MOVEI	T1,[ASCIZ /
Crashed by deposit 1 in 30 /]
	SOJE	T2,CRSWH3		;Skip next tests if DM 30,1
	MOVEI	T1,[ASCIZ /
Crashed by deposit nonzero in location 30 /]
	LDB	T2,[POINT 16,SAV30,15]	; Get Base ORING pointer field
	CAME	T2,ORP620		; Does it match?
	 JRST	CRSWH2			; No! Skip this (not base)
	LDB	T2,[POINT 16,SAV30,31]	; Get Base IRING pointer field
	CAME	T2,IRP620		; Does it match?
	 JRST	CRSWH2			; No! Skip this (not base)
	MOVE	T2,SAV30		; Get entire quantity
	CAMN	T2,CRSHWD		; Does it STILL match 30?
	 MOVEI	T1,[ASCIZ /
Base initiated crash (IRP620 & ORP620 in 30)/]
CRSWH1:	LDB	T2,[POINT 16,KEY620,15]	;Get the KEY value
	CAIN	T2,354			;Hex 'EC'?
	 MOVEI	T1,[ASCIZ /
Base halted itself (KEY=354='EC')/]
CRSWH2:	SKIPE	TAKDWN			;System hung from TAKEIT?
	 MOVEI	T1,[ASCIZ /
TAKEIT run /]
	SKIPE	CRS147
	 MOVEI	T1,[ASCIZ /
Manual restart (from location 147) /]
CRSWH3:	PUSHJ	P,CTYTYP##		;Output reason for SYSTOP
	MOVEI	T1,[ASCIZ /
Full DSKCLN requested /]
	SKIPN	SLOCRS			;STOPCD(SLO) or STOPCD(,DSKCLN)?
	SKIPE	NOCRS			;STOPCD(NO) (too many RIB errors)?
	 PUSHJ	P,CTYTYP##		;Yes
	PFALL	CTYTIM			;Output time

;Type date and time on CTY (immediately - output is not buffered up)

CTYTIM::PUSH	P,T2		;PRESERVE RELOAD FLAGS IN T2
	PUSH	P,.CPTOA	;SAVE CURRENT TYPEOUT ROUTINE
	MOVEI	T1,CTYTYO##	;Output to the CTY without interrupts
	MOVEM	T1,.CPTOA	; (no jobs are scheduled when CTYTYO is used)
	PUSHJ	P,LOCTIM##	;Output time
	PUSHJ	P,CRLF##
	POP	P,.CPTOA	;Restore typeout address
	POP	P,T2
	POPJ	P,
SUBTTL	CRSDEV - Read status of all devices at time of crash

CRSDEV:	PRINTF(<[CRSDEV should be replaced by RCDSTB]>)
IFCPU(F3),<
	CONI	TTY,TTYSTS#	;Status of CTY
>;END IFCPU(F3)
IFCPU (KI),<
	CONI	TTY,TTYSTS#
	CONI	PTR,PTRSTS#
	CONI	PTP,PTPSTS#
	CONI	CLK,CLKCNI#
>;END IFCPU (KI)
IFCPU (KL),<
	CONI	TIM,TIMSTS#
	CONI	MTR,MTRSTS#
> ;END IFCPU(KL)
IFCPU (KS),<
	RDINT	TIMSTS#
KMCSTP:	SETZ	T1,		;Label for DDT
	WRIO	T1,@[3,,760540]	;Stop the KMC
IFG TAPES,<
	RDIO	T2,@[3,,772440]
	MOVEM	T2,MAGSTS#
> ; End IFG TAPES
IFG LPTN,<
	SKIPL	T2,NXDLPT
	 RDIO	T2,@[3,,775400]
	MOVEM	T2,LPRSTS#
> ; End IFG LPTN
	RDIO	T2,@[1,,776700]
	MOVEM	T2,DSKSTS#
> ; END IFCPU (KS)

IFCPU(<KI,KL>),<		;I/O bus devices
IFN CDRN,<CONI	CR,CDRSTS#>
IFN PLTN,<CONI	PLT,PLTSTS#>

DEFINE LPTMC (A)<CONI LP'A,LPT'A'STS#>
    %LPTNN==0
    REPEAT LPTN,<
	LPTMC (\%LPTNN)
	%LPTNN==%LPTNN+1
    > ; End REPEAT LPTN

DEFINE SAXMC (A)<CONI SAX'A,SA'A'STS#>
    %SAXN==0
    REPEAT SAXN,<
	SAXMC(\%SAXN)
	%SAXN==%SAXN+1
    > ; End REPEAT SAXN

	MOVE	T1,[SAXBAS,,SASAVE]
	BLT	T1,SASAVE+SAXLEN-1 ;Save SA-10 area in 340-377
> ; END IFCPU (<KI,KL>)

	POPJ	P,		;End of CRSDEV routine
SUBTTL	CRSMAP - Map context pages into just before physcial page 337

CRSMAP:	SKIPN	JOB		;If null job is running
	 POPJ	P,		; then %UPT is already in UPT
	MAP	T1,%UPT		;PREVENT PG FAULTS HERE
	MOVEM	T1,CRSBLK	;SAVE IN CASE OF FAILURE
IFCPU (KI),<
	TRNE	T1,MAP.M	;ONLY SAVE IF PAGED ACCESSIBLE REFERENCE (DON'T NEED TO WRITE)
	 POPJ	P,		;NO GOOD.
> ; End IFCPU (KI)
IFNCPU(KI),<
	TLNE	T1,PFW.H	;IF HARD FAILURE, FORGET IT
	 POPJ	P,
	TLNE	T1,PFW.R	;SKIP IF UNPAGED REF - THATS NO GOOD.
	TLNN	T1,PFW.A	;IF A BIT IS ON, ITS OK, ELSE NOT
	 POPJ	P,		;YES, CANT ADDRESS UPT
>;END IFNCPU(KI)
SUPT0:	MOVE	T1,[%UPT,,UPT]	;From 372000 to 3000
	BLT	T1,UPT+UPTEND	;Copy as much as will fit to the null job's UPT
	MOVSI	T1,-NCTXPG	;Alter copied mapping of context pages
SUPT1:	MOVEI	T2,UPT.PN(T1)	;Physical page number (3,4,5)
	MOVEI	T3,%UPT.N+CNVVPN(T1)	;Virtual page number  (372,373,374)
	ROT	T3,-1		;Standard UPT calculation
	TLNN	T3,(1B0)	;If even
	 DPB	T2,[POINT 13,UPT(T3),17]
	TLNE	T3,(1B0)	;If odd
	 DPB	T2,[POINT 13,UPT(T3),35]
	AOBJN	T1,SUPT1	;Update all 3 self pointers
	POPJ	P,		;End of CRSMAP routine

DDTMAP::500000+UPT.PN,,420000+EPT.PN	;For FILDDT
SUBTTL	CRSHOM - Write DSKCLN indicator in the HOM pages

CRSHOM:	WRAPR	APRIOB			;Reset I/O bus devices
	JRSTF	@[PC.UIO,,.+1]		;Set user I-O in PC flags
IFCPU (KS),<
	WRAPR	LP.DSF+LP.CSF+LP.TIM	;Disable interval timer interrupt
	MOVSI	T1,(KPACT)		;Clear keep alive active
	ANDCAM	T1,RLWORD
>;END IFCPU (KS)
IFCPU (KL),<
	CONO	MTR,0			;Turn off interval timer and meter
	SWPUA				;Sweep cache, unload all to memory
	CONSZ	APR,LP.CSB		;Wait for Cache Sweep Busy to clear
	 JRST	.-1			;(do this before the WREBR)
>;END IFCPU (KL)
IFCPU (KI),<				;AC block 0 always selected on KI
	DATAO	PAG,[XWD 400000,400000]	;Turn off paging
>;END IFCPU (KI)
IFNCPU(KI),<
	WREBR	EPT.PN			;Turn off paging (turn off KL cache)
>;END IFNCPU(KI)
;*;	PUSHJ	P,FILSTP##		;In FILUUO, currently just a POPJ
	SETZ	T2,			;CLEAR HANG FLAGS

MONCRS:	SKIPN	NOCRS			;HARDWARE TROUBLE?
	 JRST	MONCR1			;NO
	MOVEI	T1,[ASCIZ /
Severe ERROR encountered: HARDWARE SUSPECT /]
	PUSHJ	P,CTYTYP##		;If STOPCD(NO)
	IORI	T2,RE.BTA!RE.ONA!DCFULL	;STOPCD(NO) WANT MAN BTS, MAN ONC, FULL DC

PRINTF(<[MONCRS check DSKCLN completed only SYSTEM structure?]>)
MONCR1:	MOVE	T1,STRDDB##+STRBTS##	;HAS DSKCLN NOT
	TRNN	T1,SRPNDS##		; COMPLETED?
	SKIPE	SLOCRS			;Is it a STOPCD(.,DSKCLN) ?
	 IORI	T2,DCFULL		;Yes, set FULL-DSKCLN (old STOPCD(SLO))
	MOVE	T4,REUSER		;Get restart bits set by TAKEIT
	SKIPE	TAKDWN			;HANG (or TAKEIT run?)
	 JRST	MONCR2			;Yes
	IORI	T2,DCFAST		;No, force FAST DSKCLN
	LSH	T4,-RENUM		;Move bits 20-27 into bits 28-35
	SKIPA
MONCR2:	 IORI	T2,RE.BTA		;HANG, cancel monitor's automatic "/D"
	ANDI	T4,1_RENUM-1		;Keep only bits 28-35
	HRLI	T4,RESCOD		;Include "valid" code
	MOVEM	T4,RESTRT		;Save for next monitor to see (loc 27)
	DPB	T2,REYMON		;Put MON restart stat in bits 23-27
;RE.BTA in T2 if monitor decides not to do automatic /D to save dump
;RE.ONA in T2 if monitor decides disk is not safe enough to have ONCE run
;DCFULL in T2 if full DSKCLN requested because SLOCRS or NOCRS was nonzero
;DCNONE in T2 if TAKEIT run
;DCFAST in T2 otherwise

PRINTF(<[MONCRS @MONCR2+5 Save STRPID in inter-monitor area REPSID]>)
	HLRZ	T1,STRDDB##+STRPID##	;Get pack set ID
	MOVEM	T1,REPSID		;Save in inter-monitor area (loc 26)
IFCPU (KI),<
	WRAPR	APRIOB			;RESET AGAIN TO MAKE SURE
	WRPI	411577			;AND PI SYSTEM
>;END IFCPU (KI)
IFNCPU(KI),<
	WRPI	LI.CPS+LI.COF+LI.PIF+LI.ACO ;CLEAR PI SYSTEM
	WRAPR	LP.CSF+LP.PWF+LP.IOR	;AND APR
>;END IFNCPU(KI)
	MOVEI	T3,RE.BTD		;Check if BOOTS action is selected
	PUSHJ	P,RECOMP		; (read SS4 if RE.BTD not set)
	TRNE	T2,RE.BTA		;Manual BOOTS desired?
	 SETZM	BTSTR			;Yes, cancel the "/D<CR><CR>"
	LDB	S,REYDCA		;Get user "HANG" or "CRASH" DSKCLN type
	MOVE	T4,RESTRT
	TRNN	T4,RE.DCD		;Has TAKEIT explicitly set DSKCLN mode?
	 LDB	S,REYDCM		;No, get monitor DSKCLN type
	MOVE	T1,REUSER		;Get bit 19 from TAKEIT's restart word
	TRNN	T1,RE.DCW		;Don't write DC type to HOME page?
	CAIN	S,DCFULL		; or disk untrustworthy?
	 POPJ	P,			;Yes, don't write HOM pages
PRINTF(<[Need a SYSTEM structure to check BOOTS options?]>)
	SKIPN	STRDDB##		;STRDDB and UNI tables set up?
	 POPJ	P,			;No, can't write to DSKB0 then
	HRLI	S,HOMDCV##		;Get HOME DSKCLN type validator
	SETZ	P4,			;DSKB0 has no previous unit ID
	MOVEI	U,STRDDB##		;DSKCLN stuff only on prime STR!
	HLRZ	U,STRUNI##(U)		;Get addr of first unit CB in STR
	MOVEI	F,BOOTS##-1000		;Read into page 774
NXTUNT:	MOVEI	PG,LPNHOM##		;1ST HOME page
	SKIPA
HOMP2:	 MOVEI	PG,LP2HOM##		;2ND HOME page
	PUSHJ	P,PMDRD			;Read page off disk
	  JSR	TDERR			;"TAKE DOWN ERROR"
	MOVSI	T1,'HOM'
	MOVEI	T2,CODHOM##
	CAMN	T1,HOMNAM##(F)		;Verify HOME page name
	CAME	T2,HOMCOD##(F)		;Verify HOME page code
	 JSR	TDERR
	CAME	P4,HOMPRV##(F)		;Check previous unit for consistancy
	 JSR	TDERR
	MOVEM	S,HOMDCT##(F)		;Set valid DSKCLN type
	PUSHJ	P,PMDWT			;Write back to disk
	  JSR	TDERR
	HRRZS	PG
	CAIE	PG,LP2HOM##		;See if both HOME blocks processed
	 JRST	HOMP2			;No, do 2nd HOME page
	MOVE	P4,HOMHID##(F)		;Save current unit ID
	HLRZ	U,UNISTR##(U)		;Point to next unit CB
	JUMPN	U,NXTUNT		;Finished if no more units in DSKB
	POPJ	P,			;End of WRTHOM routine

TDERR::	0				;Nonzero (JSR) on take-down error
	MOVEI	T1,[ASCIZ /
Serious restart error while writing to HOM pages
/]
	PJRST	CTYTYP##		;Serious restart error detected
;ROUTINE TO COMPUTE RESTART STATE
;
RECOMP::MOVE	T2,RESTRT	;GET INTER-MONITOR WORD
		;ONCE does a PUSHJ P,RECOMP+1 with T2 set up
	TDNE	T2,T3		;IS USER ACTION DEFINED?
	 POPJ	P,		;YES
IFCPU (KI),<RDAPR T1>		;READ SENSE SWITCHES
IFCPU (F3),<DATAI APR,T1>	;READ PANEL SWITCHES
IFCPU (KL),<PUSHJ P,SPCGSW##>	;GET KLDCP SWITCHES
IFCPU (KS),<MOVE T1,KSSS4>	;GET SSW WORD
IFCPU (KI),<TLNE T1,SS4>	;IS SS4 ON?
IFNCPU(KI),<TRNE T1,SS4>	;IS SS4 ON?
	 JRST	[LSH	T3,-NUMREV	;SET SELECTED
		 TDO	T2,T3		; ACTION BIT
		 POPJ	P,]
	LSH	T2,-RENUM		;NO: RETURN MONITOR ACTION
	POPJ	P,

;MACRO TO DEFINE RESTART SYMBOLS AND BYTE POINTERS.
; SYMBOL SUFFIX INERPRETATIONS:
;	'A'  [USER SELECTED] RESTART ACTION.
;	'D'  DEFINITION STATE OF USER ACTION.
;	'M'  MONITOR RESTART ACTION.
;
DEFINE RESYM (DCNAM,DCS,ACT)<
  INTERN  REUSER,REY'DCNAM'A,REY'DCNAM'M,RESCOD,RE.'DCNAM'D,DCSIZ
	DCSIZ==DCS
	RESCOD=='RES'			;INTER-MONITOR WORD VALIDATOR
	REUSER:	EXP	0		;RECEPTACLE FOR USER RESTART
	NUMREV==1			;COUNT NUM OF
	IRP ACT, <NUMREV==NUMREV+1>	; RESTART TYPES
	RENUM==DCSIZ+2*NUMREV-1		;NUMBER OF RESTART BITS
	REYMON: POINT DCSIZ+NUMREV-1,RESTRT,35-RENUM
	REY'DCNAM'A: POINT DCSIZ,RESTRT,35
	RE.'DCNAM'D==1_<DCSIZ+NUMREV-1>
	REY'DCNAM'M: POINT DCSIZ,RESTRT,35-RENUM
  INTERN  DCNAM'FULL,DCNAM'FAST, DCNAM'NONE
	DCNAM'FULL==7
	DCNAM'FAST==1
	DCNAM'NONE==0
	REXX==1_DCSIZ
	IRP ACT, <RE.'ACT'A==REXX
		  RE.'ACT'D==REXX_NUMREV
		  RE.'ACT'M==REXX_RENUM
		  REXX==REXX_1>
	RE.'DCNAM'W==1B19
>

	LALL
RESYM (DC,DC.SIZ,<ON,BT>);CREATE SYMBOLS FOR THE 3 BIT DSKCLN TYPE
			; FIELD 'DC' AND FOR RESTART CONDITIONS
			; 'ON' - AUTO/MANUAL ONCE AND
	SALL		; 'BT' - STRING/MANUAL BOOTS

INTERN	RE.ONA,RE.OND

BTSTLN==:^D24			;MAX CHARS IN BOOTS COMMAND STRING
BOOTXT:
BTSTR::	BYTE	(7)"/","D",15,15,0	;DEFAULT STRING: DUMP MEM,
					; LOAD AND RUN DEFAULT MON
	BLOCK	BTSTLN/5

EXTERN	PMDRD,PMDWT		;Defined in MONBTS
SUBTTL	COMMON SUBROUTINE RETURNS

CPOPJ2::AOS	(P)		;DOUBLE SKIP SUBROUTINE RETURN
RSKP::!				;FOR MACSYM USERS
CPOPJ1::AOSA	(P)		;SKIP SUBROUTINE RETURN
DPOPJ::	MOVEM	S,DEVIOS(F)	;DEPOSIT I/O STATUS WORD IN DDB
RTN::!
CPOPJ::	POPJ	P,

TPOPJ1::AOSA	-1(P)		;RESTORE T1 THEN SKIP RETURN
TTPOPJ::POP	P,T2
TPOPJ::	POP	P,T1		;RESTORE T1
	POPJ	P,		;AND RETURN
JPOPJ1::			;DUPLICATE NAME (PREFERRED)
IPOPJ1::AOS	-1(P)		;SET FOR SKIP RETURN
JPOPJ::				;DUPLICATE NAME (PREFERRED)
IPOPJ::	POP	P,J		;RESTORE J (USUALLY JOB OR HIGH SEG NUMBER)
	POPJ	P,
	POP	P,
T2POJ1::AOS	-1(P)
T2POPJ::POP	P,T2		;RESTORE T2
	POPJ	P,
MPOPJ::	POP	P,M
	POPJ	P,
WPOPJX::CAIA			;NETSER PUSHES THIS ADDR ON THE STACK THEN
WPOPJ1::AOS	-1(P)		; EVENTUALLY DOES A CPOPJ1 RETURN
WPOPJ::	POP	P,W
	POPJ	P,
T3POPJ::POP	P,T3
	POPJ	P,
P3POPJ::POP	P,P3
	POPJ	P,


FUPOJ1::POP	P,F
UPOPJ1::
LPOPJ1::AOSA	-1(P)		;SKIP AND RESTORE LINE
FUPOPJ::POP	P,F
UPOPJ::
LPOPJ::	POP	P,U		;RESTORE LINE AND RETURN
	POPJ	P,0		;RETURN
FPOPJ1::AOS	-1(P)
FPOPJ::	POP	P,F		;RESTORE F
	POPJ	P,0		;RETURN
ZPOPJ::	TDZA	T1,T1
M1POPJ::SETOM	T1
	POPJ	P,


ANYCPU::CAME	J,.CPJOB
	 AOS	(P)
	POPJ	P,		;TURN ON DEVICE PI LEVEL

ONPOPJ::SYSPIN			;Turn on PI system
	POPJ	P,

DEFINE	NTGIVE,<		;;ROUTINE TO GIVE UP THE INTERLOCK ON AN ERROR
;*;	IFNDEF NTLERR,<EXTERNAL NTLERR>
;*;	PUSHJ	P,NTLERR>	;;GIVE UP THE INTERLOCK ONLY IF WE OWN IT

GIVLOK::NTGIVE
	POPJ	P,
;SUBROUTINES TO SAVE AND RESTORE PRESERVED ACS

SAVE1::	PUSH	P,P1		;JSP T4,SAVE1 to save P1
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-1(P)
	JRST	RES1

SAVE2::	PUSH	P,P1		;JSP T4,SAVE2 to save P1 and P2
	PUSH	P,P2
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-2(P)
	JRST	RES2

SAVE3::	PUSH	P,P1		;JSP T4,SAVE3 to save P1,P2,P3
	PUSH	P,P2
	PUSH	P,P3
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-3(P)
	JRST	RES3

SAVE4::	PUSH	P,P1		;JSP T4,SAVE4 to save P1,P2,P3,P4
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-4(P)
	POP	P,P4
RES3:	POP	P,P3
RES2:	POP	P,P2
RES1:	POP	P,P1
	POPJ	P,
SUBTTL	SYSTEM BYTE POINTERS

PUUOAC::POINT	4,M,12		;M AC FIELD
PIOMOD::POINT	4,S,35		;MODE BITS
XP PJBNLH,350700		;LEFT HALF OF "POINT 7,XXX,6"
IFG JOBS-<1_<<PJBNLH&007700>_-6>>,<;Check on maximum allowed by byte pointer
	PRINTX ?PJBLNH can't handle that many jobs
	TOOBIG##>		;Cause an undefined global at LOAD time
DEVJOB==:DEVCHR	;BYTE(7)JOB(3)TIM(7)CNT(7)UNIT(12)SIZE
PJOBN::	XWD PJBNLH+F,DEVJOB	;DEVICE JOB ASSIGNMENT
PUNIT::	POINT	7,DEVCHR(F),23	;DEVICE UNIT NUMBER
PJBSTS::POINT	JWSIZ,JBTSTS(J),JWPOS ;JOB WAIT STATE (QUEUE) CODE
PJBST2::POINT	JWSIZ,T2,JWPOS	;ONE FOR T2
				;IN JOB STATUS WORD
PDVTIM::POINT	3,DEVCHR(F),9	;CODE FOR TIME DEVICE MAY
				;BE ACTIVE BEFORE BEING DECLARED
				;HUNG. N MEANS 2^N-1 SECONDS
PDVCNT::POINT	7,DEVCHR(F),16	;COUNTED DOWN EACH SECOND,
				;1 TO 0 TRANSITION MEANS HUNG DEVICE
IADPTR::POINT	2,DEVIAD(F),2	;COUNT OF NUMBER OF USER CHANNELS INITED
				; ON THIS DEVICE (DECTAPE ONLY)
DEYCLS::POINT 2,DEVCLS(F),1	;DEVICE CLASS CODE
DEYMCT::POINT 4,DEVCLS(F),13	;DEVICE MAX FREE CORE COUNT
DEYTCT::POINT 4,DEVCLS(F),17	;DEVICE CURRENT FREE CORE COUNT
JBYQNT::POINT JBSQNT,JBTICT(J),JBNQNT ;POINTER TO QUANTUM RUN TIME FOR JOB
				;(NO OF JIFFIES BEFORE NEXT LOWER RUN QUEUE)

CTXTAB::			;TABLE OF BYTE POINTERS TO DISK
				; ADDRESSES. ALSO USED TO COMPUTE
				; EFFECTIVE ADDRESSES IN JBTCTX
ZZ==0
REPEAT NCTXPG,<
	POINT 27,JBTCTX+ZZ(J),35 ;POINTER TO DISK ADDRESS FOR PAGE ZZ
	ZZ==ZZ+JOBN
>

JBYSWS::POINT 2,JBTPGO(J),1	;SWAPPER STATE
JBYACT::POINT 10,JBTPGO(J),11	;NUMBER OF ACTIVE LMAP SLOTS
JBYCTR::POINT 5,JBTPGO(J),17	;NUMBER OF PAGES RESERVED FOR
				;CONTEXT PAGES
IFG NCTXPG-<1_<5-1>>,<PRINTX JBYCTR FIELD OVERFLOW>
JBYPPP::POINT 6,JBTMWS(J),5	;# OF PER-PROCESS PAGES
JBYMWS::POINT 10,JBTMWS(J),15	;MONITOR WORKING SET SIZE
JBYMWL::POINT 10,JBTMWS(J),25	;LIMIT
JBYUWS::POINT 10,JBTMWS(J),35	;USER WORKING SET SIZE.

JBYWCH::POINT 23,JBTWCH(J),35 ;BYTE POINTER TO TIME OF DAY STARTED WAITING

JBYRPT::POINT 2,JBTLIC(J),LICRPS
JBYWPT::POINT 2,JBTLIC(J),LICWPS
JBLMSZ==:^D17				;INACTIVITY TIMEOUT LIMIT FIELD SIZE
JBLMSK==:<1_JBLMSZ>-1			;INACTIVITY TIMEOUT LIMIT MASK
INADFL==:^D15				;INACTIVITY TIMEOUT DEFAULT LIMIT
INAHIT==:(1B0)				;INACTIVITY TIMEOUT LIMIT HAS BEEN HIT
JBYINA:: POINT JBLMSZ,JBTINA(J),17	;POINTER TO INACTIVITY LIMIT FIELD (J)
JBYIN2:: POINT JBLMSZ,JBTINA(T2),17	;POINTER TO INACTIVITY LIMIT FIELD (T2)
PVYMOD::POINT PVSMOD,JBTPRV(J),PVNMOD
PVZMOD::POINT PVSMOD,JBTPRV(T1),PVNMOD
PVYCOR::POINT PVSCOR,JBTPRV(J),PVNCOR
PVYTIM::POINT PVSTIM,JBTPRV(J),PVNTIM
PVYCRM::POINT PVSCRM,JBTPRV(J),PVNCRM
PVYHNG::POINT PVSHNG,JBTPRV(J),PVNHNG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;									;;;
;;;	NOTE:  This following table is in order by INTASS cause number	;;;
;;;	       and should not be re-arranged for any reason.		;;;
;;;									;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INTBYP::	; INTASS interrupt channel assignments
JBYUUO::POINT 6,%UPT+UPTTPN,5	; (0) UUO TRAP NUMBER
JBYCLK::POINT 6,%UPT+UPTTPN,11	; (1) CLOCK TRAP NUMBER
JBYPGT::POINT 6,%UPT+UPTTPN,17	; (2) PAGE TRAP NUMBER
JBYHNG::POINT 6,%UPT+UPTTPN,23	; (3) HUNG DEVICE TRAP NUMBER
JBYTIM::POINT 6,JBTINT(J),5	; (4) TIMER TRAP NUMBER
JBYERR::POINT 6,%UPT+UPTTPN,29	; (5) DEVICE ERROR TRAP NUMBER
JBYWAK::POINT 6,JBTINT(J),11	; (6) WAKE UUO
JBYSAL::POINT 6,%UPT+UPTTP1,5	; (7) UWS FAULT, SIZE AT LEAST LIMIT
JBYSLL::POINT 6,%UPT+UPTTP1,11	;(10) UWS FAULT, SIZE LESS THAN LIMIT
JBYREF::POINT 6,%UPT+UPTTP1,17	;(11) REF BIT TRAP
JBYPER::POINT 6,%UPT+UPTTP1,23	;(12) TRAP ON I/O ERRORS.
JBYNTQ::POINT 6,JBTINT(J),17	;(13) NOTICE TO QUIT (TO BE HUNG)
JBYEXC::POINT 6,JBTINT(J),23	;(14) Exit in any/all child frame
JBYMCY::POINT 6,%UPT+UPTTP1,29	;(15) Micro-cycle interrupt timer
JBYLIM::POINT 6,JBTINT(J),29	;(16) TRU limit interrupt
INTRNM==:.-INTBYP	;Number of INTASS interrupts

JBYSC1::POINT 9,JBTSCA(J),8	;Numerator for non-kcore factor
JBYSC2::POINT 9,JBTSCA(J),17	;Denominator for non-kcore
JBYSC3::POINT 9,JBTSCA(J),26	;Num. for kcore factor
JBYSC4::POINT 9,JBTSCA(J),35	;Denom. for kcore (or 0 if absolute)

;Byte pointers formerly in COMMOD
JBYIRD::POINT JBSIRD,JBTRCT(J),JBNIRD	;BYTE POINTER
JBYRCT::POINT JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINTER
JBYIWT::POINT JBSIWT,JBTWCT(J),JBNIWT	;BYTE POINTER
JBYWCT::POINT JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINTER
COMMENT $
HERE IS THE INNFORMATION FOR THE PAGE TABLE. THIS TABLE
IS USED FOR SWAP IN AND OUT AND OTHER THINGS. THE BYTES
ARE ARRANGED SO THAT THE MOST FREQUENTLY USED BYTES ARE
RIGHT JUSTIFIED IN THE WORD TO MINIMIZE SHIFTING TIME REQUIRED
DURING THE BYTE INSTRUCTIONS.

THIS TABLE IS ALLOCATED AT ONCE TIME AND ALL POINTER ADDRESSES ARE
ADJUSTED. THE POINTER WILL HAVE A LOWER ADDRESS THAN THE FIRST
ENTRY SO THAT ALL THE MONITOR PAGES ARE NOT POINTED TO
$

;FIRST WORD

PGYUNU::POINT 6,.-.(PG),10	;UNUSED
PGYPGO::POINT 12,.-.(PG),22	;OUTPUT WAIT FOR THIS PAGE LINK
PGYFPL::POINT 13,.-.(PG),35	;FORWARD LINK (PAGE NUMBER)
			;PGYFPL MUST BE IN THE FIRST WORD.

;SECOND WORD

PGYLMA::POINT 22,.-.(PG),22	;LMA CHAIN START (LINKS
SNDPGY==:PGYLMA	;DEFINED FOR ONCE TIME.  MUST BE A PNTR
			;TO THE SECOND WORD, AND PGYFPL MUST BE
			;IN THE FIRST WORD.
				; ALL ACTIVE SLOTS FOR CORE PAGE
PGYLMV::POINT 10,.-.(PG),10	;VP NUMBER OF NEXT SLOT
PGYLMJ::POINT 12,.-.(PG),22	;JOB NUMBER OF NEXT SLOT, 0 IF END
PGYBPL::POINT 13,.-.(PG),35	;BACKWARD LINK (PAGE NUMBER)

;THIRD WORD

PGYLST::POINT 3,.-.(PG),2	;WHICH LIST PAGE IS ON (SEE CORE1
				; FOR LIST NUMBER DEFINITIONS)
	XP DIOMAX,77		;MAXIMUM THAT DIO CAN BE.
PGYDIO::POINT 6,.-.(PG),8	;DIRECT I/O COUNT (TAPE, NOT DISK)
  XP PGPDIO,001000
PGYADR::POINT 27,.-.(PG),35	;DISK ADDRESS. (RETRIEVAL POINTER FORMAT)
PGYUNI::POINT 8,.-.(PG),16	;UNIT NUMBER PART
PGYPNO::POINT 19,.-.(PG),35	;PAGE ADDRESS WITHIN UNIT

;FOURTH WORD

PGYSPT::POINT 22,.-.(PG),22	;SPT BASE + OFFSET
PGYSPB::POINT 18,.-.(PG),18	;SPT BASE
PGYSPO::POINT 4,.-.(PG),22	;OFFSET
PGYCHT::POINT 13,.-.(PG),35	;LINK TO NEXT CORE PAGE ON CHT

;FIFTH WORD

PGYNXM::POINT 1,.-.(PG),0	;NXM
PGYERR::POINT 2,.-.(PG),2	;IODERR,IODTER
PGYSIP::POINT 1,.-.(PG),3	;SWAP IN IN PROGRESS
PGYSOP::POINT 1,.-.(PG),4	;SWAP OUT IN PROGRESS
PGYDRT::POINT 1,.-.(PG),5	;DIRTY

PGYSTS::POINT 6,.-.(PG),5	;CORE PAGE STATUS WORD
	XP PGPNXM,40		;BIT IN STATUS WORD FOR NXM
	XP PGPDER,20		;DEVICE ERROR
	XP PGPDTE,10		;DATA ERROR
	 XP PGMERR,PGPDER!PGPDTE ;MASK FOR ERRORS
	XP PGPSIP,4		;SWAP IN IN PROGRESS
	XP PGPSOP,2		;SWAP OUT IN PROGRESS
				; MUST BE 1B34!! (SEE DECUSE)
	XP PGPDRT,1		;DIRTY
				;MUST BE 1B35!! (SEE DECUSE)

PGYSIO::POINT 2,.-.(PG),4	;COVERS SIP AND SOP.

PGYATB::POINT 13,.-.(PG),18	;PLACE TO REMEMBER ATB ADDRESS WHILE
				; PAGE IS ON LMA CHAIN (SO DON'T HAVE
				; FIND LAST SLOT ON CHAIN TO FIND ATB)
	XP USEMAX,377777	;MAXIMUM THAT USE COUNT CAN BE.
PGYUSE::POINT 17,.-.(PG),35	;NUMBER OF REASONS WHY PAGE IS IN CORE
				;MUST BE RIGHT JUSTIFIED FOR AOS @PGYUSE.

;SIXTH WORD

PGYCSH::POINT 36,.-.(PG),35	;WHOLE WORD (TO MAKE CODE FASTER)
				; SAVED CACHE SWEEP SERIAL NUMBER.
CNTPGY==:6		;NUMBER OF PGY WORDS (FOR ONCE).

ADRNCT::EXP	1B<35-27>-1	;IF PGYADR IS EQUAL TO THIS, CORE PAGE
			; IS NOT IN CHT AND HAS NO DP ASSOCIATED WITH IT.
ADRDUM::EXP	1B<35-27>-2	;IF PGYADR IS EQUAL TO THIS, CORE PAGE
			; HAS NO DISK PAGE ASSOCIATED WITH IT, BUT
			; CAN BE USED AS A PRIVATE PAGE AS LONG AS ITS NOT
			; DEACTIVATED. USED BEFORE DSKCLN FINISHED FIXING DISK.
;(WAS A PROBLEM WITH DSKCLN DOING SUPER I/O AND WRITING IN ITSELF,
; AND DSKCLN OVERWRITING RIBS AFTER IT HAD CHECKED THEM BY
; WRITING IN ITS OWN CORE IMAGE)

IFCPU (KL),<
;HERE ARE FOUR LOCATIONS WHICH HAVE THE ADDRESSES OF FOUR CACHED
; PAGES. BY LOADING THE RELATIVE ADDRESS IN THE PAGE
; INTO T1 AND THEN REFERENCING @CSRTAB+0,1,2,3, ONE CAN ENSURE
; THAT A CERTAIN FOUR WORD CHUNK HAS BEEN UNLOADED FROM THE CACHE
; WITHOUT HAVING TO DO A CACHE SWEEP.
;
;USE THE MACRO "CSHREF" TO DO THIS.

CSRTAB::.-.(T1)
	.-.(T1)
	.-.(T1)
	.-.(T1)
>;END IFCPU KL
;TABLES FOR MWS ADJUST AND PAGE AGEING CODE

AGEHST::BLOCK AGEMAX+1	;HISTOGRAM FOR OBSERVING AGE DISTRIBUTION

AGEPTR::		;TABLE OF BYTE POINTERS FOR ACCESSING
			;AGE CELLS
ZZBIT=2
REPEAT <AGECPW>,<
	POINT AGESIZ,%UPT+UPTAGE(T1),ZZBIT
	ZZBIT=ZZBIT+AGESIZ
>


;DEFINE PI CHANNEL SAVE AND RESTORE ROUTINES IF A DEVICE IS ON THE CHANNEL

	PDL==42		;LENGTH OF INTERRUPT PI PUSH DOWN LIST

DEFINE CHAN (PI)<
	XLIST
   IFNDEF ACBPI'PI,<;IF NO AC BLOCK ALLOCATED TO THIS CHANNEL,
	IFNDEF HIGAC'PI,<XP HIGHAC,17>
  >;END IFNDEF ACBPI'PI
	IFDEF HIGAC'PI,<
	IFGE HIGAC'PI-10,<XP HIGHAC,<HIGAC'PI>>
	IFL HIGAC'PI-11,<XP HIGHAC,11>
>
  IFNDEF ACBPI'PI,<;IF NO AC BLOCK ALLOCATED TO THIS CHANNEL,
	HIACBL==HIGHAC
  >;END IFNDEF ACBPI'PI
	INTERNAL SAV'PI,RET'PI,CH'PI,CH'PI'JEN,CH'PI'P,CH'PI'PD1
CH'PI:	0		;PC STORED HERE BY JSR ON INTERRUPT TO CHANNEL PI
	JEN @CH'PI	;LAST INSTRUCTION ON CONSO DEV, CHAIN

IFNDEF ACBPI'PI,<;IF NO AC BLOCK ALLOCATED TO THIS CHANNEL, GENERATE NORMAL AC SAVE CODE.

;HERE FROM AN INTERRUPT ROUTINE WHICH HAS FOUND ITS DEVICE NEEDS SERVICE
;SAVE ACS 0 THRU HIGHAC, CALLED BY JSR, SETS UP P TO PUSH DOWN LIST FOR THIS PI

SAV'PI:	0		;CALLED BY JSR
IFCPU (KS),<TBSAVE TBVA'PI>	;SAVE CURRENT TIME BASE VALUE
	EXCH	HIGHAC,CH'PI	;;GET PI, SAVE HIGHAC
	TLNN	HIGHAC,PC.USR	;;IF FROM USER MODE,
	JRST	SAV'PI'A		;;(NOT USER MODE)
	EXCH	HIGHAC,CH'PI	;NO NEED TO SAVE ANYTHING
	EXECAC
	MOVE	P,CH'PI'P	;;GET PDL FOR THIS PI LEVEL
	JRST	@SAV'PI		;;AND RETURN.

SAV'PI'A:
IFNCPU(KI),<RDUBR	SAVPG'PI>	;;NEED TO SAVE STATE ON KL
	EXCH	HIGHAC,CH'PI	;GET PC AND AC HIGHAC BACK IN RIGHT PLACES
	MOVEM HIGHAC,SAVAC'PI+HIGHAC	;SAVE AC HIGHAC
	MOVEI HIGHAC,SAVAC'PI	;SETUP TO SAVE 0 THRU HIGHAC-1
	BLT HIGHAC,SAVAC'PI+HIGHAC-1	;SAVE ACS
	MOVE P,CH'PI'P	;SETUP PUSH DOWN POINTER
	JRST @SAV'PI			;RETURN TO CALLER AND PROCESS INTERRUPT
>;END IF HIGAC'PI

IFDEF ACBPI'PI,<;IF CHAN HAS AC BLK,THEN WE ARE TO USE AN AC BLOCK FOR THIS CHANNEL.
SAV'PI:	0		;JSR TO HERE
IFCPU (KS),<TBSAVE TBVA'PI>		;SAVE THE CURRENT TIME BASE VALUE
	RDUBR	SAVPG'PI	;REMEMBER AC BLOCK SETTING
	WRUBR	[LG.LAB+<ACBPI'PI>B8+<ACBPI'PI>B11]
	MOVE	P,CH'PI'P	;GET PDL POINTER FOR THIS CHANNEL
	JRST	@SAV'PI		;AND RETURN.
>;END IFDEF ACBPI'PI

;HERE FROM INTERRUPT ROUTINE WHEN IT HAS FINISHED SERVICING INTERRUPT
;RESTORE ACS AND DISMISS INTERRUPT
;USUALLY TRANSFERRED TO BY POPJ P,

IFNDEF ACBPI'PI,<;IF CHANNEL DOESN'T HAVE AN AC BLOCK,

RET'PI:	MOVE	HIGHAC,CH'PI	;;GET RETURN PC
	TLNN	HIGHAC,PC.USR	;IF FROM USER MODE
	JRST	RET'PI'A
	USERAC			;;DON'T HAVE TO RESTORE
	JRST	CH'PI'JEN

RET'PI'A:MOVSI HIGHAC,SAVAC'PI	;RESTORE ACS 0 THRU HIGHAC
	BLT HIGHAC,HIGHAC
IFNCPU(KI),<WRUBR	SAVPG'PI>	;IF KL, NEED TO SWITCH BACK BY HAND.
>;END IFNDEF ACBPI'PI

IFDEF ACBPI'PI,<;IF AC BLOCK ASSIGNED TO THIS CHANNEL,

RET'PI:	MOVE	17,SAVPG'PI	;GET DATAI PAG WORD
	TLZ	17,(LG.LUB+LG.LPC+LG.LAB-LG.LAB) ;JUST LG.LAB SET
	WRUBR	17		;BACK TO ORIGINAL AC BLOCKS
>;END IFDEF ACBPI'PI
CH'PI'JEN:
IFCPU (KS),<	TBSET  TBVA'PI>		;RESET THE TIME BASE FOR KS
		JEN @CH'PI		;DISMISS INTERRUPT ON THIS PI CHANNEL


SAVAC'PI:: BLOCK HIACBL+1
IFNCPU(KI),<
SAVPG'PI::BLOCK	1		;PLACE TO DO DATAI PAG TO IN KL VERSION
>;END IFNCPU (KI)
IFCPU (KS),<
TBVA'PI: 0			;2 WORDS FOR SAVING THE TIME BASE
	 0>
CH'PI'P:	XWD -PDL+1,.+1		;INITIAL PUSH DOWN POINTER
CH'PI'PD1:	EXP RET'PI	;FIRST WORD ON LIST,
				; POPJ WILL RETURN TO DISMISS INTERRUPT
	BLOCK PDL-1		;PUSHDOWN LIST SPACE
	LIST
>



;GENERATE THE CHANNEL SAVE ROUTINE ONLY FOR PI WHICH NEED THEM (ASGSAV MACRO USED)

	IFN USED1, <CHAN 1>
	IFN USED2, <CHAN 2>
	IFN USED3, <CHAN 3>
	IFN USED4, <CHAN 4>
	IFN USED5, <CHAN 5>
	IFN USED6, <CHAN 6>
	IFN USED7, <CHAN 7>

;GENERATE NULL CHANNEL SAVE ROUTINES FOR THOSE CHANNELS NOT USED

DEFINE NULL (PI)<
	XLIST
CH'PI::	0
	JEN	@CH'PI
	LIST
>

;GENERATE UNASSIGNED CHAN ROUTINES FOR THOSE CHANNELS NOT ASSIGNED

DEFINE UNASS (PI)<
	XLIST
CH'PI::	0
	MOVEM	T1,SAVAC'PI
	MOVEI	T1,1_<7-PI>	;LOAD CHANNEL FLAG
	ORM	T1,BADINT	;INDICATE ILL INT OCCURED ON THIS CHAN
	WRPI	LI.COF!1_<7-PI>	;TURN CHANNEL OFF
	MOVE	T1,SAVAC'PI
	JEN	@CH'PI
SAVAC'PI: 0			;SAVE WORD
	LIST
>

	IFE USED1+UNASS1, <NULL 1>
	IFE USED2+UNASS2, <NULL 2>
	IFE USED3+UNASS3, <NULL 3>
	IFE USED4+UNASS4, <NULL 4>
	IFE USED5+UNASS5, <NULL 5>
	IFE USED6+UNASS6, <NULL 6>
	IFE USED7+UNASS7, <NULL 7>

	IFN UNASS1, <UNASS 1>
	IFN UNASS2, <UNASS 2>
	IFN UNASS3, <UNASS 3>
	IFN UNASS4, <UNASS 4>
	IFN UNASS5, <UNASS 5>
	IFN UNASS6, <UNASS 6>
	IFN UNASS7, <UNASS 7>
	IFE COREN, <COREN==^D256		;NO RESTRICTION IF 0 TYPED>
	XP USRLIM,COREN			;DEFINE GLOBAL RESTRICTING MAXIMUM SIZE OF
					; CORE FOR ANY SINGLE USER
					; ONCE ONLY CODE CAN ALTER THIS VALUE
					; (PATCH RH CORLIM IN SYSINI)

;APR AND PI BITS
	INTERN	REQCLK,PICLK
	INTERNAL APRNOT

	CLKBIT==1
	REPEAT 7-CLKCHN, <CLKBIT==CLKBIT*2>
	INTERNAL CLKBIT
	REQCLK==1B24+CLKBIT	;REQUEST INTERRUPT ON LOW PRIORITY CLK CHANNEL
	PICLK==LI.PIN+REQCLK	;TURN ON PI,REQUEST INTERRUPT ON CLK CHANNEL
IFCPU (KI),<;ONLY NEEDED FOR KI10, WHICH HAS 2 PI ASSIGNMENTS INSTEAD OF 1.
	XP APRCH2,<APRCHN_3+APRCHN>		;BOTH CLOCK AND ERROR
>;END IFCPU (KI)
XP PIPROG,77400		;PI STATUS REGISTER
			;ONES IF ANY PI'S IN PROGRESS
			;DO NOT DEFINE IF P-6 SO UNDEFINED
			;GLOBAL WILL BE CLUE TO P-6 USER
			;TO CHANGE CODE
	APRNOT==PIPROG-<400_<7-APRCHN>>	;DEFINE ALL PI IN PROGRESS FLAGS EXCEPT
					; APR FOR HALT TEST IN APRINT.
;SCANNER ENTRY POINTS AND BIT DEFINITIONS

LINFLG::BLOCK NFLG		;FOR LINE OUTPUT BITS

;XP LINTBE,LINTAB+PORTN

;TELETYPE LINE CHARACTERISTICS (LH OF LINTAB)
;USED BY SCNSER

XP TTVINI,200			;RUN INITIAL CUSP
XP TTVIN2,400			;RUN INITIAL CUSP FROM SETUUO

;LINES TO RUN INITIA

INI0==1	;LINE 0 INITIA AT START TIME
IN21==1	;LINE 1 INITIA FROM SETUUP
IN22==1	;ALSO LINE 2
IN23==1	;AND LINE 3
IN24==1	;AND LINE 4
IN25==1	;AND LINE 5 (see INITIA.MAC for what these are used for)

;NOW DEFINE THE LINE TABLE FOR EACH TTY'S CHARACTERISTICS
;USING THE INFO FROM CONFIG, AND DATA FROM TTYTAB AREA.

DEFINE GENLIN(LIN)<ZZ==0
.GNLN(LIN,INI)
.GNLN(LIN,IN2)
	XWD ZZ,0		;LINE LIN >

DEFINE .GNLN (N,BIT) <
IFDEF BIT'N,<ZZ==ZZ+BIT'N*TTV'BIT>
>

LINTAB::	;LINE CHARACTERISTICS BITS (NOT CLEARED ON SYSTEM STARTUP)
		LIN==0
REPEAT PORTN+1,<GENLIN(\LIN)
                LIN==LIN+1>

PTYN==PPORTN		;Number of PTY lines
PTYTAB=:LINTAB+RPORTN	;Address in LINTAB where PTYs start

;THE FOLLOWING SLIDING SCALE DEFINES THE LENGTH OF THE TTY FREE LIST

IFNDEF TTCHKN,<IFL PORTN-10,<XP TTCHKN,7*PORTN>>
IFNDEF TTCHKN,<IFL PORTN-20,<XP TTCHKN,6*PORTN>>
IFNDEF TTCHKN,<XP TTCHKN,^D10*PORTN>

TTFREE::EXP .-.			;FILLED IN AT ONCE TIME BY FREE LIST ADR
TTCLST::XWD TTCHKN,.-.		;# OF TTY CHUNKS,,ADDRESS OF FIRST ONE
XP TTCHKS,4				;CHUNK SIZE

CSUPTN:: BLOCK 1	;PHYS PG NO UPT SAVED IN ON CRASH
CRSBLK:: BLOCK ^D10	;HARDWARE MAP DATA OVERWRITTEN IS SAVED HERE AFTER PAGCNI
	SAVDMP==:<SIXBIT /   SAV/>	;EXTENSION FOR SAVED FILES == "SAV"
;CARD READER ENTRY POINT AND BITS

	IFG CDRN, <
		CDRBTS==:1670+CDRCHN
>

;CARD PUNCH ENTRY POINT

;	IFG CDPN, <
;	EXTERNAL CDPSER		;ENTRY POINT
;>


	IFG LPTN, <

;PROTOTYPE DEFINITION FOR U PRINTER DEVICE DATA BLOCKS

LPTDON==100

DEFINE	LPTDDB (N) <
IFCPU (<KI,KL>),<	;KI/KL DDB GENERATION.

	XLIST				;TURN OFF LISTING DURING EXPANSION

LP'N'SV1==LP'N'SAC+F		;DEFINE F SAVE LOCATION

LPTCON==.-LP'N'DDB
LP'N'INT: CONSO LP'N,0			;(-4) SKIP IF INTERRUPT FOR THIS LPT
	  JRST .-1			;(-3)  GO TO NEXT SKIP CHAIN ELEMENT
	  MOVEM F,LP'N'SV1		;(-2) SAVE F IN CHANNEL SAVE AREA
	  JSP F,LPTINT		;(-1) SET UP DDB ADDRESS AND BRANCH
LP'N'DDB::
LP'N'NAM:
	LPNAM==SIXBIT /LPT/
	IFE LPTN-1, <LPNAM>		;( 0) PHYSICAL DEVICE NAME
	IFN LPTN-1, <LPNAM+<20+$LPNUM>B23> ;( 0) PHYSICAL DEVICE NAME
	  XWD 6*HUNGST,<N>B23+LPTSIZ    ;( 1) DEVICE CHARACTERISTICS
					; HUNG TIME IS 63 SECS (CODE 6)
	  0				;( 2) DEVICE I/O STATUS
	  XWD 0,LPTDSP##		;( 3) LH=DDB LINK, RH=DSP TABLE ADDR.
LPTMOD==1_A+1_AL+1_I			;LPT LEGAL MODES
	  XWD DVOUT+DVLPT,LPTMOD	;( 4) DEVICE CHARACTERISTICS
	  0 				;( 5) LOGICAL DEVICE NAME
	  0				;( 6) BUFFER HEADER ADDRESSES
LPTPTR==.-LP'N'DDB
LP'N'PTR: 0				;( 7) BLOCK OUTPUT POINTER
	  0			;(10) CURRENT OUTPUT BUFFER ADDRESS
LP'N'CLS:	XWD  0,LP'N'BUF	;(11) CLASS AND MON. BUFF. POINTER
LP'N'STS:	0			;(12) DEVICE STATUS WORD
LP'N'PWC:	XWD LP'N'BL/2,0	;(13) WAKEUP COUNT LIMIT
LP'N'WUC:	0		;(14) ACTIVE WAKEUP COUNT
LP'N'CTR:	0		
LP'N'INW:	0		;(16) INTERRUPT WORD
LPTCH==.-LP'N'DDB
	  EXP 11*LP'N'CHN!LPTDON	;(15) INTERRUPT CHANNEL ASSIGNMENTS
LPTSVE==.-LP'N'DDB
	  MOVE F,LP'N'SV1		;(16) RESTORE F, SAVE AC'S
	  JSR LP'N'SAV			;(17)  AND ESTABLISH P
	  MOVEI F,LP'N'NAM		;(20) SET UP DDB ADDRESS AND RETURN
	  JRST LPTNXT			;(21)  TO COMMON INTERRUPT HANDLER
LPTEX1==.-LP'N'DDB
	  MOVE F,LP'N'SV1		;(22) RESTORE F AND
	  JEN @LP'N'CHL			;(23)  DISMISS INTERRUPT
LPTSV2==.-LP'N'DDB
	  0				;(24) SAVE LOCATION FOR U
LPTECH==.-LP'N'DDB
	  CONSZ LP'N,LPTECM		;(25) THE REST OF THE DDB CONTAINS
LPTDNE==.-LP'N'DDB
	  CONSO LP'N,LPTDON		;(26)  THE ACTUAL I/O INSTRUCTIONS
LPTCSO==.-LP'N'DDB
	  CONSO LP'N,(U)		;(27)  USED BY THE COMMON SERVICE
LPTCSZ==.-LP'N'DDB
	  CONSZ LP'N,(U)		;(30)  ROUTINE TO CONTROL A U
LPTCNI==.-LP'N'DDB
	  CONI  LP'N,U		;(31)  PRINTER. THEY ARE EXECUTED
LPTCNO==.-LP'N'DDB
	  CONO  LP'N,(U)		;(32)  BY MEANS OF AN XCT INSTRUCTION
LPTDTO==.-LP'N'DDB
	  DATAO LP'N,(U)		;(33)  INDEXED TO THE PROPER DDB
LPTBKO==.-LP'N'DDB
	  BLKO  LP'N,LP'N'PTR		;(34)
LPXSTS==.-LP'N'DDB
	CONI LP'N,LP'N'STS		;(35) DEVICE STATUS WORD CONI

SIZLPT==.-LP'N'DDB
;
;  MONITOR BUFFER DEFINITON
;
  LP'N'BL=400
	XWD LP'N'BUF,LP'N'BUF	;IN AND OUT
	EXP LP'N'BUF+LP'N'BL	;LAST
LP'N'BUF:	BLOCK	LP'N'BL	;BUFFER SPACE
;
	INTERN LPTCON,LPTPTR,LPTCH,LPTSVE,LPTEX1,LPTSV2,LPTECH
	INTERN LPTDNE,LPTCSO,LPTCSZ,LPTCNI,LPTCNO,LPTDTO,LPTBKO
	INTERN LPXSTS,SIZLPT
	LIST				;TURN LISTING BACK ON AFTER EXPANSION
>;END IFCPU KI,KL
IFCPU (KS),<	;KS10 LPT DDB GENERATION
LPTBAS==0	;the first of 4000 bytes of -11 virtual adr space
		; reserved for use by the LPT.  this space
		; will be mapped to -10 page containing LPTBUF
LP'N'DDB::
LP'N'NAM:
	PHASE 0
	LPNAM==SIXBIT /LPT/
	IFE LPTN-1, <LPNAM>		;( 0) PHYSICAL DEVICE NAME
	IFN LPTN-1, <LPNAM+<20+$LPNUM>B23> ;( 0) PHYSICAL DEVICE NAME
	  XWD 6*HUNGST,<N>B23+LPTSIZ    ;( 1) DEVICE CHARACTERISTICS
					; HUNG TIME IS 63 SECS (CODE 6)
	  0				;( 2) DEVICE I/O STATUS
	  XWD 0,LPTDSP##		;( 3) LH=DDB LINK, RH=DSP TABLE ADDR.
LPTMOD==1_A+1_AL+1_I			;LPT LEGAL MODES
	  XWD DVOUT+DVLPT,LPTMOD	;( 4) DEVICE CHARACTERISTICS
	  0 				;( 5) LOGICAL DEVICE NAME
	  0				;( 6) BUFFER HEADER ADDRESSES
	EXP 0,0				;7,10 UNUSED
	XWD  0,LP'N'BUF		;(11) CLASS AND MON. BUFF. POINTER
LPTSTS::!0			;(12) DEVICE STATUS WORD
	XWD 200,0		;(13) WAKEUP COUNT LIMIT
	0			;(14) ACTIVE WAKEUP COUNT
LPTBA::!3,,775400		;(16) BASE ADR OF LP20 REGISTERS
LPT11A::!<LPTBUF&777>_2+LPTBAS	;(17) -11 ADR OF START OF MONITOR BFR
LPTWC::!0		;(20) WORD COUNT OF MOST RECENT XFR
LPTFUN::!0		;(21) MOST RECENT FUNCTION TYPE.
LPTEC::!0		;(22) NUMBER OF LPT ERRORS
LPTLBA::!LPTBUF,,<<LPTBUF&777>*4+LPTBAS>;(23) -10,,-11 ADR OF LPT BUFFER
LPTSB::!BLOCK 4			;(24-27) DEVICE REGS ON ERROR
	DEPHASE
SIZLPT==:.-LP'N'DDB
	LP'N'BUF,,LP'N'BUF
	LP'N'BUF+LPBSIZ
LP'N'BUF:BLOCK LPBSIZ
LP'N'DDS==.-LP'N'DDB
>;IFCPU KS

>;LPTDDB MACRO DEFINITION
IFCPU (<KI,KL>),<EXTERN LPTNXT,LPTECM,LPTINT>

		$LPNUM==0		;TEMPORARY SYMBOL USED TO FACILITATE
					; MACRO GENERATION

		REPEAT LPTN, <

			LPTDDB \$LPNUM
			$LPNUM==$LPNUM+1
		>
	>;IFG LPTN
;PLOTTER ENTRY POINT

		;Nothing special

;PAPER TAPE READER ENTRY POINT AND MASK

		PTRMSK==:0		;MASK==0 IF PDP-10 READER

;PAPER TAPE PUNCH ENTRY POINT

		;Nothing special


;END OF COMMON

;Can't use $END here
CMNLIT:: LIT
CMNEND=: .-1
;*;	BLOCK	<1000-<.&777>>&777	;End on a page boundry
	RELOC	.-COMORG		;So that relocatable stuff follows

	END			;Can't use $END (CMN) because of abs loc

   @@