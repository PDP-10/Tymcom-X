IFCPU(KI),<TITLE BOTLOD.KI - Paper tape to load BOOTS from the disk
IF2,<PRINTX [KI-BOTLOD reads 7 blocks of BOOTS into KI core]>>
IFCPU(KL),<TITLE BOTLOD.KL - DECtape program to load BOOTS from the disk
IF2,<PRINTX [KL-BOTLOD reads 7 blocks of BOOTS into KL core]>>
IF2,<PRINTX [The 7th block of BOOTS is 1st block on 2nd track of 3330]>

R=1	;RELOC
T1=2
T2=3
T3=4
T4=5
P1=6
P2=7
P3=10
P4=11
P5=12
P6=13
P7=14
BTL=15

SAX1==274
SAX2==400
BASE==300
BSY==(BYTE (8)0,20)
CUE==(BYTE (8)0,40)
SM==(BYTE (8)0,100)
P=17

LP.NXM==1B25
LP.CSF==1B22
BOOTWD==22	;LOW CORE CMD WORD FOR DSK

	INTERNAL JOBVER
	JOBVER==137

	LOC JOBVER
	20
	RELOC


IFCPU(KI),<	;DETERMINE SIZE OF CORE ON KI

DMPBTS:	IOWD LDSIZ,1

	PHASE	1

	CONO	APR,100			;CLEAR NXM
	HRROI	R,0
NXMCHK:	ADDI	R,2000			;CHECK NEXT K BOUNDRY
	MOVE	0,(R)
	CONSO	APR,100			;IS THAT NXM?
	  JUMPL	R,NXMCHK		;NO, AND NOT END OF CORE
	CONSO	PTR,10			;WAIT FOR READER DONE
	  JRST	.-1
	DATAI	PTR,2			;GET SIZE OF  NEXT LOADER
	HRRI	2,-4000+140(R)		;PLACE TO PUT IT
TAPLOD:	CONSO	PTR,10
	  JRST	.-1
	DATAI	PTR,(2)
	AOBJN	2,TAPLOD
	JRST	-4000+140(R)		;KI BOTLOD IN TOP 2K OF CORE
	JRST	1			;START WORD

LDSIZ==.-1

	XWD	-BLSIZ,0		;FOR AOBJN WD. TO READ DSK LOADER

	PHASE	140

	SUBI	R,4000
	HRRZS	R
> ; End IFCPU(KI)

IFCPU(KL),<				;KL BOTLOD IN TOP 2K UNMAPPED CORE
	LOC	340000-4000

BOTLOD:					;START OF KL BOTLOD, LOADED FROM KLDCP
	SETZ	R,			;NO RELOCATION NECESARY.
> ; End IFCPU(KL)

BOOTFI:	CONO	200000
	CONO	PI,011577		;CLEAR THE WORLD
	MOVE	P,PDL(R)
	ADDI	P,(R)			;RELOCATE IT
IFCPU(KL),<	;DETERMINE SIZE OF PHYSICAL CORE ON KL
	CONO	APR,LP.CSF+LP.NXM
	SETZ	BTL,
KLNXLP:	ADDI	BTL,2000
	TLNE	BTL,-1			;HAVE ALL 256 K?
	  JRST	KLNXL1			;YES, USE IT THEN.
	SKIP	(BTL)
	CONSO	APR,LP.NXM
	  JRST	KLNXLP
KLNXL1:	SUBI	BTL,4000		;256K - 2K = 254K
> ; End IFCPU(KL)
IFCPU(KI),<MOVE	BTL,R>			;REGISTER WITH LOCATION OF BOOTS.
	HRRI	T4,2140+1700(BTL)	;END OF BOOTS
	HRL	T4,BASEA(R)		;BASE LOCS
	BLT	T4,2140+1700+37(BTL)	;SAVE BASE LOCATIONS
	MOVE	T4,R
IFCPU(KI),<
	ADDM	R,CMDTIC(R)		;RELOCATE TIC TO COMMAND LIST
	ADDM	R,ENDLTC(R)		;RELOCATE TIC TO NOOP COMMAND
> ; End IFCPU(KI)

BPLOOP:	XCT	BPCNI(T4)		;READ STATUS TO T1
	JUMPN	T1,SAFND(R)		;FOUND AN SA10
BPLOO1:	ADDI	T4,1			;TRY NEXT SA10
	MOVEI	T1,20
	ADDM	T1,BASEA(R)		;SET BASE ADDRESS FOR NEXT SA10
	CAIE	T4,2(R)			;ASSUME ONLY 2 SA 10'S
	  JRST	BPLOOP(R)		;NOT DONE SO TRY NEXT SA10

;  NO GOOD 3330 (BP) UNIT WITH BOOTS.  TRY 2314 (DP) UNITS.

	MOVEI	T1,BOTLST(R)
	HRRZM	T1,BOOTWD
	SETZM	BOOTWD+1
	ADDM	BTL,BOTLST(R)		;RELOCATE THE INPUT LIST

DPLOOP:	PUSHJ	P,DPREAD(R)		;FIRST IS RECAL
	PUSHJ	P,DPREAD(R)		;NEXT READ
	CONSZ	DPC,377720		;ANY ERRORS?
	  JRST	DPNEXT(R)		;YES, TRY NEXT UNIT
	MOVE	T2,2140(BTL)		;FIRST WORD
	CAMN	T2,BOOTFI(R)		;IS IT RIGHT?
	  JUMPG	T3,2140(BTL)		;AND NO TIMEOUT?. YES, GO

DPNEXT:	DATAO	DPC,ATNCLR(R)
	ADD	T1,NXUNIT(R)
	TLNN	T1,700000		;OVERFLOW?
	  JRST	DPLOOP(R)		;NO
	HALT	.(R)

DPREAD:	TLC	T1,700000
	CONO	DPC,175710
	HRRI	T1,BOOTWD+45000		;BLOCK 4
	DATAO	DPC,T1
	MOVEI	T3,^D100000
	CONSO	DPC,10
	  SOJG	T3,.-1(R)
	POPJ	P,
SAFND:	MOVEI	T3,SREQ			;STATUS REQ. FOR CHAN 0
	MOVEI	T2,1B29			;STATUS FLAG FOR CHAN 0
SAFND1:	MOVEI	T1,^D100000		;LOOP COUNTER
	XCT	BPCNO1(T4)		;STATUS REQ CONO
	TRC	T3,100			;CHANGE STATUS REQUEST TO GO
	XCT	BPCNO2(T4)		;STATUS STORED?
	SOJG	T1,.-1(R)		;WAIT A WHILE
	JUMPG	T1,CHFND(R)		;BUT NOT TOO LONG A WHILE
SAFND2:	LSH	T2,-1			;NEXT CHANNEL
	ADDI	T3,10
	HRRM	T3,CHGO(T4)		;UPDATE CHANNEL  NUMBER
	TRC	T3,240			;CHANGE GO TO CLEAR STATUS
	HRRM	T3,CHCLR(T4)
	TRC	T3,340			;CHANGE CLEAR STATUS TO REQUEST STATUS
	TRNN	T2,1B33			;LAST CHANNEL?
	  JRST	SAFND1(R)		;NO
	JRST	BPLOO1(R)		;YES. TRY NEXT SA10

CHFND:	MOVE	P1,T3
	LSH	P1,-1
	ANDI	P1,14			;ISOLATE CHANNEL NUMBER*4
	ADD	P1,BASEA(R)		;SET BASE ADDRESS FOR THIS CHANNEL
	MOVE	T1,ENDLTC(R)		;TIC TO EOL-1 (NO-OP)
	MOVEM	T1,(P1)
	MOVE	T1,NOOPD0(R)		;NO-OP TO DEVICE 0
CHFN1:	MOVEM	T1,ENDLST-1(R)		;CHANNEL COMMAND WORD
	PUSHJ	P,STRTIT(R)		;START DEVICE
	  JRST	UTFND(R)		;FOUND WORKING UNIT
CHFN2:	CAMN	T1,MAXDEV(R)		;LAST DEVICE?
	  JRST	SAFND2(R)		;YES. TRY NEXT CHANNEL
	ADDI	T1,1B23			;ERROR. TRY NEXT UNIT NUMBER
	JRST	CHFN1(R)		;NO. TRY NEXT ONE

UTFND:	MOVE	P3,CMDTIC(R)		;SET UP TO START COMMAND LIST
	MOVEM	P3,(P1)
	MOVEI	P4,CMDLST(R)		;FIX UP ADDRESS
	MOVE	P5,[POINT 8,(P4),23](R)	; DEVICE ADDRESS IN COMMAND LIST
	LDB	P6,[POINT 8,ENDLST-1(R),23](R)	; GET DEVICE ADDRESS
UTFND1:	DPB	P6,P5
IFCPU(KI),<
	ADDI	P5,1
	SKIPE	ENDLST(R)		;RELOC DONE?
	ADDM	BTL,@P5			;RELOCATE ADDRESS  (R.GT.BTL?)
	CAME P5,[POINT 8,3(P4),23](R)	;NEXT COMMAND TIC?
	CAMN P5,[POINT 8,^D20(P4),23](R);OR TIC FOR 2ND HEAD?
	  JRST	.+2(R)			;YES.
	JRST	UTFND2(R)		;NO
	ADDI	P5,1			;YES. ADVANCE POINTER
	SKIPE	ENDLST(R)		;RELOC DONE?
	ADDM	BTL,@P5			;AND RELOCATE
> ; End IFCPU(KI)
IFCPU(KL),<
	LDB	P7,[POINT 8,@P5,15]	;GET COMMAND
	ADDI	P5,1			;NEXT THING IN CHANNEL PROG
	CAIN	P7,6			;READ COMMAND AND
	SKIPN	ENDLST(R)		;HAVEN'T RELOCATED YET?
	  JRST	.+2			;NO
	ADDM	BTL,@P5			;YES, NEEDS RELOCATION
	CAME	P5,[POINT 8,3(P4),23](R) ;NEXT THING A TIC?
	CAMN	P5,[POINT 8,^D20(P4),23](R)
	ADDI	P5,1			;YES, GET PAST IT.
>;END IFCPU(KL)

UTFND2:	ADDI	P5,1			; DONE? (WILL ADD RELOC FACTOR TO STOP
	CAME P5,[POINT 8,ENDLST-CMDLST-1(P4),23](R) ; COMMAND WHICH IS O.K.)
	  JRST	UTFND1(R)		;NO DO NEXT COMMAND
	SETZM	ENDLST(R)		;CLEAR TERMINATOR
	PUSHJ	P,STRTIT(R)		;START DEVICE
	  JRST	RDDONE(R)		;READ COMPLETED O.K.
	JRST	CHFN2(R)		;NO GOOD. TRY NEXT DEVICE
RDDONE:	MOVE	P3,2140(BTL)		;CHECK FIRST WORD
	CAME	P3,BOOTFI(R)
	  JRST	CHFN2(R)		;NOT BOOTS
	JRST	2140(BTL)		;ALL GOOD. GO START BOOTS

STRTIT:	HRRZ	P7,CHCLR(T4)
	TRO	P7,1B30			;SET THE SET BIT
	XCT	STSET(T4)		;SET STATUS FLAG SO CLR CAN FOLLOW GO
	XCT	CHGO(T4)
	MOVEI	P3,0
STRT2:	XCT	CHCLR(T4)
	MOVEI	P7,^D100000		;TIME OUT LOOP
	XCT	BPCNO2(T4)		;WAIT FOR STATUS STORED
	SOJG	P7,.-1(R)
	JUMPE	P7,STRT4(R)		;TIMED OUT
	CAIE	P3,0			;PREVIOUS BUSY STATUS?
	  HRLZI	P3,BSY			;YES. MAKE THIS ONE BUSY + NEW STATUS
	IOR	P3,1(P1)		;GET STATUS WORD
	TLNN	P3,BSY			;BUSY?
	  JRST	STRT3(R)		;NO.
	TLNE	P3,SM			;BUSY AND STATUS MODIFIER?
	  JRST	STRT2(R)		;YES. WAIT FOR CONTROL UNIT END
	TLNE	P3,CUE			;BUSY AND CONTROL UNIT END?
	  JRST	STRTIT(R)		;YES. RESTART
STRT3:	TLNN	P3,175114		;ANY ERRORS?
	  POPJ	P,
	TLNE	P3,SELERR		;IF IT WAS A SELECT ERROR
	TRO	T1,7B23			;RUN UP TO TOP UNIT FOR NEW CONTROLLER
STRT4:	XCT	RSET(T4)		;YES. RESET SA-10
	SKIPN	P7			;TIMED OUT?
	MOVE	T1,MAXDEV(R)		;GO TO NEW CHANNEL
	AOS	(P)			;AND SKIP RETURN
	POPJ	P,


BOTLST:	IOWD	1400,2140
	0
NXUNIT:	XWD	10000,0
ATNCLR:	XWD	500000,776
PDL:	IOWD	10,PDLP
PDLP:	REPEAT	10,<0>

SELERR==(1B2)

STSET:	CONO	SAX1,(P7)
	CONO	SAX2,(P7)
RSET:	CONO	SAX1,400000
	CONO	SAX2,400000
CMDTIC:	XWD	200000,CMDLST
SREQ==540

CHGO:	CONO	SAX1,440
	CONO	SAX2,440
CHCLR:	CONO	SAX1,600
	CONO	SAX2,600
BPCNI:	CONI	SAX1,T1
	CONI	SAX2,T1
BPCNO1:	CONO	SAX1,(T3)
	CONO	SAX2,(T3)
BPCNZ2:	CONSZ	SAX1,(T2)
	CONSZ	SAX2,(T2)

BASEA:	BASE				;SAX1 LOOKS AT BASE=300, SAX2 AT 320
ENDLTC:	XWD	200000,ENDLST-1
MAXDEV:	BYTE	(8)240,3,377
BPCNO2:	CONSO	SAX1,(T2)
	CONSO	SAX2,(T2)
NOOPD0:	BYTE	(8)240,3,300
;IPL/0=(1,2,3,4), HOM/1=(5,6,7,8), BAT/2=(9,10,11,12),
;BOOT/3=(13,14,15,16), BOOT/4(17,18,1,2), BOOT/5=(3,4,5,6)
;HOM/6=(7,8,9,10), BAT/7=(11,12,13,14), XXX/8=(15,16,17,18)
CMDLST:	BYTE	(8)72,7			;SEEK
	BYTE	(12)-6(24)ENDLST+1	;SEEK ARG POINTER
	BYTE	(8)73,61		;SEARCH ID=
	BYTE	(12)-5(24)ENDLST+1	;CYL 0, HEAD 0, BLOCK 13 (PAGE 3)
	XWD	200000,.-2		;TIC IF SEARCH FAILS
    %TEMP==0
REPEAT 6,<
	BYTE (8)160,6			;READ
	BYTE (12)-200(24)2140+%TEMP	;128 WORDS
    %TEMP==%TEMP+200
> ; End REPEAT 6
	BYTE	(8)72,7			;SEEK
	BYTE	(12)-6(24)ENDLST+3	;SEEK ARG POINTER
	BYTE	(8)73,61		;SEARCH ID=
	BYTE	(12)-5(24)ENDLST+3	;CYL 0, HEAD 1, RECORD 1
	XWD	200000,.-2
REPEAT 1,<
	BYTE (8)160,6			;READ
	BYTE (12)-200(24)2140+%TEMP	;128 WORDS
    %TEMP==%TEMP+200
> ; End REPEAT 1

	BYTE	(8)240,3		;NO-OP
ENDLST:	1
	BYTE	(8)0,0,0,0,0,0,15	;ADDRESS FOR SEEK AND SEARCH
	BYTE	(8)0,0,0,0,0,1,1

	LIT
IFCPU(KI),<
BLSIZ==.-140
	DEPHASE

DMEBTS:		;END
;PROGRAM TO GIVE END OF TAPE MESSAGE

DMPOTP:	IOWD	ENDSZ,1


	PHASE	1
PRLP:	MOVEI	0,STR
	HRLI	0,(POINT 7,0)
PRLP1:	ILDB	17,0
	JUMPE	17,PRLP		;AND OF STRING
	CONSZ	TTY,20		;WAIT FOR NOT BUSY
	  JRST	.-1
	DATAO	TTY,17
	JRST	PRLP1
STR:	BYTE	(7) "",177,177,177,177
	ASCII	/RELOAD TAP/
	BYTE	(7) "E","",177,177,177,177,177,15,12,177,177,177,177,177,0
	JRST	PRLP

ENDSZ==.-1
	DEPHASE
DMEOTP:
;USER MODE PROGRAM TO PUNCH BOOT PAPER TAPE FOR KI-10

PT==1	;PAPER TAPE PUNCH CHANNEL

ARRAY PDLX[40],OBUF[3]

STPT:	RESET				;START OF KI BOTLOD, PUNCH PAPER TAPE
	MOVE	P,[IOWD 40,PDLX]
	INIT	PT,10
	SIXBIT	/PTP/
	XWD	OBUF,0
	  JRST	NOPTP			;CAN NOT GET PTP
	OUTPUT	PT,
	OUTSTR	[ASCIZ /
NUMBER OF COPIES TO PUNCH /]
NUMRD1:	MOVEI	T1,0
NUMRD:	INCHWL	T4
	CAIG	T4,"9"
	CAIGE	T4,"0"
	  JRST	WTLF			;FINISHED WITH NUMBER
	IMULI	T1,^D10
	ADDI	T1,-"0"(T4)
	JRST	NUMRD

	INCHWL	T4
WTLF:	CAIE	T4,12
	  JRST	.-2			;WAIT FOR END OF LINE
	CAILE	T1,0
	CAILE	T1,^D12			;SET SOME LIMITS ON TAPE SIZE
	  JRST	BADNUM
COPLP:	PUSHJ	P,FEED			;BLANK TAPE
	MOVE	T2,[DMPBTS-DMEBTS,,DMPBTS]
	PUSHJ	P,DUMPIT
	SOJG	T1,COPLP
	PUSHJ	P,FEED			;NOW SOME BLANK TAPE
	MOVE	T2,[DMPOTP-DMEOTP,,DMPOTP]
	PUSHJ	P,DUMPIT
	PUSHJ	P,FEED
	CLOSE	PT,0
	STATZ	PT,760000
	  JRST	PTPERR			;GOT AN OUTPUT ERROR
	EXIT				;FINISHED

NOPTP:	OUTSTR	[ASCIZ /
CAN NOT INIT PAPER TAPE PUNCH/]
	EXIT

BADNUM:	OUTSTR	[ASCIZ /
NUMBER TOO LARGE OR 0, RETYPE /]
	JRST	NUMRD1

;BOTLOD BUFFERED OUTPUT ROUTINES
FEED:	MOVEI	T3,0
	MOVEI	T4,200			;SOME BLANK TAPE
	PUSHJ	P,PTOUT
	SOJG	T4,.-1
	POPJ	P,
PTPERR:	OUTSTR	[ASCIZ /
PUNCH ERROR/]
	EXIT

PTOUT:	IDPB	T3,OBUF+1
	SOSG	OBUF+2
	OUT	PT,
	  POPJ	P,			;ALL OK
	JRST	PTPERR

DUMPIT:	MOVE	T4,(T2)
	MOVEI	P1,6
DUMPT1:	MOVEI	T3,0
	LSHC	T3,6
	TRO	T3,200
	PUSHJ	P,PTOUT
	SOJG	P1,DUMPT1
	AOBJN	T2,DUMPIT
	POPJ	P,

	END	STPT	;KI-BOTLOD RUNS IN USER MODE TO PUNCH PAPER TAPE
> ; End IFCPU(KI)

IFCPU(KL),<
	END BOTLOD	;KL-BOTLOD STARTS IN EXEC MODE FROM KLDCP DECTAPE
> ; End IFCPU(KL)

     