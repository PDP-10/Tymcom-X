TITLE	UUOCON - UUO HANDLER AND UUO ROUTINES

	STOPCD(,ENTRY,UUOCON)

IFNDEF .ELINK,<
    IFDEF  .LNKEND,<SYN .LNKEND,.ELINK>
PRINTF(% .ELINK needs to be changed to .LNKEND for macro %53B)
> ;end IFDEF .ELINK

IFNDEF MAXCAL,<XP MAXCAL,56>
			;DEFINE HIGHEST CALLI UUO WHICH HAS
			; CORRESPONDING CALL MUUO

COMMENT ! UUOCON
FUNCTION: PUBLIC NO-TRAP MUUO HANDLER AND CALL [SIXBIT /NAME/],
 CALLI AC,INDEX HANDLER. THE USER'S UPT MUUO NEW PC WORD
 CAUSES EXECUTION TO START HERE AT UUOPNT WHEN HE GIVES AN
 MUUO. IF MUUO IS EXECUTED AS A RESULT OF A TRAP CONDITION,
 THEN THE NEW PC WORD SELECTED POINTS AT UUOPTR.

RESTRICTION: UUOS CANNOT BE CALLED BY INTERRUPT SERVICE ROUTINES.
 THE UUO HANDLER IS PURE OTHERWISE (ALL STORAGE IN CONTEXT
 PAGES AND JBT TABLES, ETC.)
!
SUBTTL UUOPNT DISPATCH,CALLI'S & ETC.

INTERNAL NINTRP,NOUTRP,NWATRP,NERTRP,NEFTRP,NSPTRP
EXTERNAL ERRCAL
EXT(<%UPT,%UPS,%UPX>)
EXTERNAL UPTSTS,STRTAD,STRTCL,ERRNSA,EPT,PGYNXM,CURUPT,EPYPSN
EXTERNAL UPTNTV,UPTABK
EXTERNAL UPSSWE,UPSABK,ERRABK
EXTERN JOBOPC,TTYRES,CHGPPN,EPLLEN
EXTERNAL JOBDDT
IFCPU (KI),<EXTERNAL TIMCHN>
EXTERNAL UPTPDL,UPTRNM,UPTRPN,UPTUUO
EXTERNAL ERRPIO,UPTXEI
EXTERNAL TTYFNU,JBTWCH
EXTERN CORUUO,HOLD,ILLINS
EXTERN ERRIUC,JOBKL
EXTERN UGTSEG,URUN,USCHD1,LOGOFF
EXTERN WSYNC
EXTERNAL PUUOAC,UUOMNR
EXTERNAL JOB,JBTSTS,TIMEF,JBTUPM
EXTERNAL UPTACP,STKAC,KTRRET
EXTERN JOBOPC,UPNPSR,UPSPSR
EXTERNAL ADJMWS, AGEPAG
EXTERNAL CPOPJ1,CPOPJ,TPOPJ,TPOPJ1,T2POPJ
EXTERNAL CBLAMB,DEVLST,DVCNSG,STDRNG,TTYFND,TTYUUO,UUOTAB
EXTERNAL CLKTRP
EXTERNAL WRTACR
SUBTTL	UUOPNT - UUO from Public mode, No Trap (normal Monitor calls)
	XP	PDNMUP,-2	;PDNMUP(P) IS WHERE UUO ROUTINES LOOK AT PC.

UUOPNT::EXECAC			;SWITCH TO EXEC MODE ACS
	SKIPN	JOB
	 STOPCD (.,STOP,UUOJB0,,<UUO from Job 0>)
	MOVE	M,%UPT+UPTMUU	;PICON jumps to UUOPN1 with UUO in M
UUOPN1::MOVEM	M,%UPT+UPTUUO	;Store top-level MUUO for debugging
	MOVE	J,JOB		;J should already have job (from USRXIT)
	MOVE	F,%UPT+UPTMUP	;Get PC, it is in user mode
	HRRZM	F,JBTPC##(J)	;Store PC, clear saved DDB address
	MOVEI	F,0		;BECAUSE ERRCON LOOKS FOR ADDRESS CHECK ERROR
	MOVE	P,[IOWD EPLLEN,%UPT+UPTPDL] ;SETUP STACK POINTER
	PUSH	P,%UPT+UPTMUP	;PC OF UUO GOES ON FIRST.
	PUSH	P,[0]		;DUMMY UP FAKE CHGSTS WORD
	PUSHJ	P,UUODSP	;CALL THE DISPATCH ROUTINE
	  JRST	UUOPN3		;NON-SKIP RETURN
UUOPN2:	  AOSA	PDNMUP+1(P)	;SKIP RETURN
	JRST	UUOPN4		;DOUBLE SKIP, A LITTLE SLOWER.
UUOPN3:	POP	P,T1		;GET JUNK OFF STACK
	JRST	USRXIT		;AND RETURN TO USER

UUOPN4:	AOS	PDNMUP+1(P)	;ONE MORE TIME FOR DOUBLE SKIP
	JRST	UUOPN2		;AND GO BACK.


;TYMCOM-X does not use Concealed mode.

UUOCNT:: STOPCD (.,JOB,UUOCNT,,<UUO from Concealed mode, No Trap>)
SUBTTL	UUOKNT - UUO from Kernel mode, No Trap (MUUO from the EXEC)

;Here when monitor does a UUO on behalf of the user.
;Note that a VREMOV uuo can be nested as a result of a CHANIO.

UUOKNT::CONSZ	PI,PI.IPA	;Any interrupts in progress?
S..UIL:: STOPCD (.,CPU,UIL,,<Uuo at Interrupt Level>)
IFCPU (KI),<
	MOVEM 17,@%UPT+UPTACP	;SAVE 17 FIRST
	JSP	17,STKAC	;PUSH THE REST ON THE AC STACK
>;END IFCPU (KI)
IFNCPU(KI),<
	MOVEM	16,@%UPT+UPTACP	;FOR KL, SAVE AC 16 & 17
	JSP	16,STKAC
>;END IFNCPU(KI)

	MOVE	M,%UPT+UPTMUU	;GET UUO INTO M FIRST IN CASE PDL OV
	PUSH	P,%UPT+UPTMUP	;PUT PC ONTO STACK
	MOVEI	F,0		;NO PDL OV, SO CLEAR F FOR ILL MEM REF/ADDRESS CHECK DISTINCTION
	CHGSTS	T1		;GET STATE OF CHARGING CLOCK
	PUSH	P,T1		;SAVE THAT ON STACK
	PUSHJ	P,UUODSP	;DO THE UUO
	  SKIPA			;NON-SKIP
	AOS	PDNMUP+1(P)	;SKIP
	POP	P,T1		;GET CLOCK STATE BACK
	TRNE	T1,CHGON	;IF CHARGING WAS ON,
	 CHARGE			;THEN TURN IT BACK ON NOW.
	POP	P,%UPT+UPTMUP	;GET PC BACK INTO MUP
	JRST	KTRRET		;AND RETURN TO UUO CALLER.


;TYMCOM-X does not use Supervisor mode

UUOSNT:: STOPCD (.,CPU,UUOSNT,,<UUO from Supervisor mode, No Trap>)
COMMENT ~ CONVENTIONS FOR UUO AND CALLI SUBROUTINES

UUO ROUTINES:

CALL: UUO ROUTINES ARE CALLED WITH PUSHJ TYPE CALL.

ENTRY: M CONTAINS THE UUO, W CONTAINS AC NUMBER (CHANNEL NUMBER),
PDNMUP(P) HAS PC OF UUO CALLER. J IS NOT SETUP. F SHOULD BE
SET TO ZERO.

ACCUM: UUO SUBROUTINES CAN USE ALL ACS EXCEPT P.

EXIT: POPJ RETURN FOR NON-SKIP RETURN TO UUO CALLER, CPOPJ1
TYPE RETURN FOR SKIP RETURN TO UUO CALLER, AND CPOPJ2 TYPE
RETURN FOR DOUBLE SKIP RETURN. IF STATE OF CHARGING CLOCK
WAS CHANGED, NO NEED TO RESTORE, UUO EXIT CODE RESTORES CLOCK
TO BE ON.

CALLI ROUTINES:

CALL: CALLI ROUTINES ARE CALLED WITH PUSHJ TYPE CALL.

ENTRY: T1 CONTAINS CONTENTS OF USER AC, W AND RH(M) CONTAIN
USER AC NUMBER (FOR STORING RETURN ARGS), J CONTAINS JOB NUMBER,
LH(W) HAS 1B0 SET IF THE CALLI IS PHYSICAL ONLY (THOSE CALLIS
IN WHICH 1B18 AND 1B19 ARE DIFFERENT ARE PHYSICAL ONLY).
IF CHARGING CLOCK STATE WAS CHANGED, NO NEED TO RESTORE IT,
UUO EXIT CODE WILL RESTORE.

ACCUM: CAN SMASH ALL ACS EXCEPT P

EXIT: POPJ FOR NON-SKIP, CPOPJ1 FOR SKIP, CPOPJ2 FOR DOUBLE
SKIP. STATE OF CHARGING CLOCK NEED NOT BE RESTORED IF IT
WAS CHANGED.
~

UUODSP:	LDB	W,PUUOAC	;GET USER'S CHANNEL/AC NUMBER
	TLNN	M,740000	;Opcodes 000 to 037?
	 JRST	ILLINS##	;000 is always illegal, 001-037 never get here
	TLNE	M,700000	;Greater than 077?
	 JRST	INSSIM		;Go to INStruction SIMulator
;Here for opcodes 040 to 077 only
	HLLZ	T2,M		;GET LH OF UUO INTO LH OF T2
	ROT	T2,^D8		;SHIFT ALL BUT LO ORDER BIT INTO RH OF T2
	SKIPGE	T2		;IF UUO IS ODD,
	  SKIPA	U,UUOTAB-20(T2)	;DISPATCH FROM RH ELSE
	 MOVS	U,UUOTAB-20(T2)	; DISPATCH FROM LH
	JRST	(U)		;RETURN ADDRESS IS ON PDL.
SUBTTL	INSSIM - instruction simulator

 PURGE ADJSP,ADJBP,DADD,DSUB,DMUL,DDIV	;Cancel definitions in KISYM.MAC
;OPDEF	UJEN	[100B8]		;User-mode Jump and ENable PI system (TOPS10)
;OPDEF		[101B8]		;unassigned (UMOVEI on TENEX)
;OPDEF	GFAD	[102B8]		;G-floating ADD (new KL microcode only)
;OPDEF	GFSB	[103B8]		;G-floating SUB (new KL microcode only)
 OPDEF	JSYS	[104B8]		;TOPS-20 Jump to SYStem monitor call
 OPDEF	ADJSP	[105B8]		;KL,KS Adjust Stack Pointer
;OPDEF	GFMP	[106B8]		;G-floating MUL (new KL microcode only)
;OPDEF	GFDV	[107B8]		;G-floating DIV (new KL microcode only)
;110=DFAD, 111=DFSB, 112=DFMP, 113=DFDV, KI double-precision floating point
 OPDEF	DADD	[114B8]		;KL,KS 71-bit integer ADD
 OPDEF	DSUB	[115B8]		;KL,KS 71-bit integer SUB
 OPDEF	DMUL	[116B8]		;KL,KS 141-bit integer MUL
 OPDEF	DDIV	[117B8]		;KL,KS 141-bit integer DIV
;120=DMOVE, 121=DMOVN, 124=DMOVEM, 125=DMOVNM, KI double-word moves
 OPDEF	FIX	[122B8]		;KI convert floating point to integer
 OPDEF	EXTEND	[123B8]		;KL,KS extended instructions
 OPDEF	FIXR	[126B8]		;KI convert floating to integer rounding
 OPDEF	FLTR	[127B8]		;KI convert integer to floating point rounding
 OPDEF	UFA	[130B8]		;KA d.p. partial add  (not in new KL microcode)
 OPDEF	DFN	[131B8]		;KA d.p. floating neg (not in new KL microcode)
 OPDEF	FSC	[132B8]		;KA floating scale (works in KI,KL,KS,F3)
 OPDEF	ADJBP	[133B8]		;KL,KS adjust byte pointer if AC field nonzero
 OPDEF	FADL	[141B8]		;KA d.p. floating add (not in new KL microcode)
 OPDEF	FSBL	[151B8]		;KA d.p. floating sub (not in new KL microcode)
 OPDEF	FMPL	[161B8]		;KA d.p. floating mul (not in new KL microcode)
 OPDEF	FDVL	[171B8]		;KA d.p. floating div (not in new KL microcode)
 OPDEF	XJRSTF	[HALT 5,]	;KS jump&restore flags (also in extended KL)

INSSIM:	LDB	T2,[POINT 9,M,8];Get opcode (000-777)
	MOVSI	T4,-SIMLEN	;AOBJN pointer
INSIM1:	LDB	T3,[POINT 9,SIMTBL(T4),8]
	CAMN	T2,T3		;Match?
	 JRST	@SIMTBL(T4)	;Yes, go do it
	AOBJN	T4,INSIM1	;Try all
	JRST	ILLINS##	;Not in our list, illegal instruction

SIMTBL:	JSYS	U.JSYS	;List of opcodes and address of routine
IFCPU(F3),<
	FIXR	U.FIXR	;KI Floating to integer, with rounding
	FLTR	U.FLTR	;KI Integer to floating, with rounding
	DFAD	U.DFAD	;KI Double floating add
	DFSB	U.DFSB	;KI Double floating subtract
	DFMP	U.DFMP	;KI Double floating multiply
	DFDV	U.DFDV	;KI Double floating divide
			;KL DADD and DSUB appear to work on the F3
;*;	ADJBP	U.ADBP	;KL Adjust byte pointer (needs microcode change)
;*;	DMUL	U.DMUL	;KL Double integer multiply, quad-word result
;*;	DDIV	U.DDIV	;KL Quad-word divide, double integer results
;WARNING: (15-MAY-86) Bug in F3 microcode - DDIV halts microcode, dead!
;The current F3 microcode ignores nonzero in AC field of IBP (ADJBP).
IF2,<PRINTX [Can't emulate ADJBP and DDIV due to F3 microcode errors]>
>  ;End IFCPU(F3)
IFCPU(KI),<
	ADJSP	U.ADSP	;KL Adjust stack pointer
;*;	ADJBP	U.ADBP	;KL Adjust byte pointer (needs ECO to work)
;*;	DADD	U.DADD	;KL Double integer add
;*;	DSUB	U.DSUB	;KL Double integer subtract
;*;	DMUL	U.DMUL	;KL Double integer multiply, quad-word result
;*;	DDIV	U.DDIV	;KL Quad-word divide, double integer results
>  ;End IFCPU(KI)
SIMLEN=.-SIMTBL

N.JSYS::0			;Count of JSYS instructions seen
U.JSYS:	AOS	N.JSYS		;Count attempted execution of JSYS
	JRST	ILLINS##	;Illegal for now

IFCPU(F3),<
N.DFAD::0			;Count of DFAD instructions seen
U.DFAD:	AOS	N.DFAD		;Count attempts at double floating add
	JRST	ILLINS##	;Illegal for now
N.DFSB::0			;Count of DFSB instructions seen
U.DFSB:	AOS	N.DFSB		;Count attempts at double floading subtract
	JRST	ILLINS##	;Illegal for now
N.DFMP::0			;Count of DFMP instructions seen
U.DFMP:	AOS	N.DFMP		;Count attempts at double floating multiply
	JRST	ILLINS##	;Illegal for now
N.DFDV::0			;Count of DFDV instructions seen
U.DFDV:	AOS	N.DFDV		;Count attempts at double floating divide
	JRST	ILLINS##	;Illegal for now

U.FIXR:	UMOVE	T1,(M)			;get contents of eff addr
	HRLZI	T2,(0.5)		;Assume argument is positive
	SKIPGE	T2			;Still assuming...
	 MOVE	T2,[600000,,1]		;If negative, use -.49999999...
	FADR	T1,T2			;Round up or down, sign depending
	FIX	T1,T1			;Strip off fractional part
	UMOVEM	T1,(W)			;put into users AC
	POPJ	P,			;return

U.FLTR: UMOVE	T1,(M)			;get contents of eff addr
	CAMN	T1,[xwd 400000,0]	;special case
	 JRST	[HRLZI	T2,533400
		 JRST	GOODGO]
	MOVM	T2,T1			;get absolute value
	TLNN	T2,777000		;will a FSC work?
	 JRST	[FSC	T2,233		;yup
		 JRST	SIGNGO]
	JFFO	T2,.+1			;drop leading zeros
	LSH	T2,(T3)
	MOVNI	T3,-244(T3)		;= 233 (ls=1) + 9 (handles ROT) - shifts
	ROTC	T2,-11			;put in exponent field, get LSBITS
	JUMPG	T3,SIGNGO		;if fraction less than 1/2 LSBIT ignore
	TLNN	T3,377			;if fraction is precisely 1/2 LSBIT
	 JUMPL	T1,SIGNGO		; then nothing on negatives
	HLRZ	T3,T2			;otherwise, create a 1/2 LSBIT
	SUBI	T3,033000
	TLZ	T3,000377		;only MSBIT used
	FADRI	T2,(T3)			;and add it in with rounding
SIGNGO:	JUMPGE	T1,GOODGO
	 MOVN	T2,T2
GOODGO:	UMOVEM	T2,(W)			;put into users AC
	POPJ	P,			;return
>  ;End IFCPU(F3)

IFCPU(KI),<
U.ADSP:	UMOVE	T1,(W)			;Get current stack pointer
	HRRES	M			;Get amount of adjustment
	JUMPL	M,ADJSPN		;Handle negative adjustments
	HRLS	M			;Put positive number in both halves
	JCRY	.+1			;Clear carry 0 and carry 1
	ADD	T1,M			;Adjust both halves
	JCRY0	ADJSPO			;Carry 0 set if negative LH now positive
	JRST	ADJSPX			;No overflow, or incremented 377777,,x

ADJSPN:	MOVMS	M			;Get positive adjustment
	HRLS	M			; in both halves
	JCRY	.+1			;Clear carry 0 and carry 1
	SUB	T1,M			;Decrement stack pointer
	JCRY0	ADJSPX			;Carry 0 set unless positive LH now neg
ADJSPO:	MOVSI	T2,(1B9)		;Set trap 2, PDL OV
	IORM	T2,PDNMUP(P)		;Set it in user PC flags
ADJSPX:	UMOVEM	T1,(W)			;Return adjusted pointer to user's AC
	POPJ	P,
>  ;End IFCPU(KI)
SUBTTL	USRXIT - Exit from UUO, return to user mode

USRXIT::MOVE	J,JOB			;CURRENT JOB NUMBER
	MOVE	T1,%UPT+UPTJOB##	; *** DEBUGGING CHECK. ***
	CAME	T1,%UPX+UPTLKJ##	; Going back to user without
	CAMN	T1,%UPT+UPTLKJ##	;  giving up all context page locks?
UUOXWL:: STOPCD (.,JOB,UUOXWL,,<UUO eXit With context Locks active>) ;;USRXIT+3
	HRRZ	T1,@%RIB.C##+%CTUPT##	; Must not have PCBs still locked
	JUMPN	T1,UUOXWL		;
	HRRZ	T1,@%RB2.C##+%CTUPT##	;
	JUMPN	T1,UUOXWL		;
	HRRZ	T1,@%SAT.C##+%CTUPT##	;
	JUMPN	T1,UUOXWL		; *** End of DEBUGGING CHECK ***

	MOVE	T1,JBTSTS(J)		;STATUS WORD FOR CURRENT USER
	TRNE	T1,UTRP			;IS THERE A START,REEN OR DDT WAITING
	 JRST 	[LDB	T1,UPYPSR##	;PENDING STREAM RECORD TYPE
		PUSHJ	P,ACTWRT	;WRITE IT. CLOB T1-T4
		MOVE	T2,%UPT+UPTSTS
		TLZE	T2,UPSSWE	;GOT SWAP ERROR IN BAD PLACE?
		  JRST	USRSWE		;YES.
		TLZE	T2,UPSABK	;ADDRESS BREAK WAITING
		  JRST	UUOABK		;YES, GO DO IT.
		TLNN	T2,STRTAD	;ADDRESS OR INDIRECT?
		  UMOVE	T2,(T2)		;INDIRECT
		TLNE	T2,STRTCL	;WANTS CCL START ADDRESS?
		  AOS	T2		;YES, CCL IS ONE MORE THAN STANDARD
		TRNN	T2,-1		;NO ZERO STARTING ADDR ALLOWED
		  JRST	ERRNSA
		EXCH	T2,(P)		;GET JOB'S OLD PC, FORCE NEW PC
		HLLM	T2,(P)		;TO START ADDRESS, KEEP FLAGS FROM PDL,
		UMOVEM	T2,JOBOPC	;TELL USER WHERE TRAP WAS
		MOVEI	T1,UTRP		;RESET TRAP FLAG,
		ANDCAB	T1,JBTSTS(J)	;AND RESTORE T1
		JRST	.+1]
	TLNN	T1,CMWB!CNTRLC		;IS MONITOR TRYING TO STOP THIS USERS
					; IO OR IS HE TRYING TO STOP HIS JOB
					; (BY TYPING ^C WHILE HE WAS IN MONITOR)?
	SKIPE	TIMEF			;NO. HAS CLOCK TICKED WHILE IN MONITOR?
	 PUSHJ	P,USCHD1		;YES, GO CALL SCHEDULER
					;STOPPING JOB IF CONTROL C TYPED IN EXEC
	POP	P,T3			;USER RETURN ADDRESS
USRXT7::MOVE	J,JOB			;MAKE SURE SET UP FOR CLKTRP
	PUSHJ	P,CLKTRP		;SEE IF TRAPPING NEEDED
	MOVEM	T3,%UPT+UPTMUP		;T3 CHANGED IF NEEDED
	JUMPE	J,USRXT8
	SKIPN	%UPT+UPTNTV		;IF PAGE-AGE QUANTUM HAS EXPIRED,
	 PUSHJ	P,AGEPAG		;  INCREMENT PAGE AGES
USRXT8:	HLLZS	JBTINA##(J)		;RESET INACTIVITY COUNT
	CHARGE				;TURN CHARGING CLOCK BACK ON
	USERAC				;SWITCH BACK TO USER'S ACS IF KL
	JEN	@%UPT+UPTMUP		;RESTORE FLAGS AND RETURN TO USER
					; DISMISS INTERRUPT ONLY ON TRPJEN MUUO
					; IN ALL OTHER CASES NO INTERRUPTS
					; ARE IN PROGRESS

EXTERNAL GETLMA,STOLMA,LMMERR,VPUMAX,%UPLMA

USRSWE:	MOVEM	T2,%UPT+UPTSTS		;STORE THIS WITH UPSSWE OFF
	MOVEI	T1,UTRP
	ANDCAM	T1,JBTSTS(J)		;TURN THIS OFF NOW
	MOVEI	W,VPUMAX		;MUST TURN OFF "A" BITS
	MOVSI	T1,LMMERR		; FOR PAGES WE IGNORED ERRORS ON
	TDNN	T1,%UPLMA(W)		;ANY ERRORS?
USRSW1:	SOJGE	W,.-1			;NO, DO NEXT
	JUMPL	W,USRSW2

	PUSHJ	P,GETLMA		;FOUND ONE, MUST FORCE FAULT
	TRZ	P4,PGE.A!PGE.W		;SO USER DOESN'T TOUCH PAGE
	PUSHJ	P,STOLMA
	MOVSI	T1,LMMERR		;SETUP MASK AGAIN
	JRST	USRSW1			;AND CHECK FOR NEXT PAGE.

USRSW2:	HRRZ	M,%UPT+UPTXEI		;GET PAGE GOT I/O ERROR ON (MAYBE LAST OF MANY)
	LSH	M,^D9			;MAKE INTO LOCATION
	PJRST	ERRPIO			;WILL GO BACK THRU ABTUUO TO USRXIT.

UUOABK:	MOVEM	T2,%UPT+UPTSTS		;STORE UPTSTS WITHOUT UPSABK ON
	MOVEI	T2,UTRP			;CLEAR UTRP
	ANDCAM	T2,JBTSTS(J)		;FORGET ABOUT PENDING DDT, REE, ETC.
	HRRZ	M,%UPT+UPTABK		;SETUP M SO MESSAGE PRINTS OUT LOCATION OF ADDRESS BREAK
	JRST	ERRABK			;PRINT ADDRESS BREAK. RETURNS THRU USRXIT.
; CALLING SEQUENCE
;	CALL D,[SIXBIT/NAME/]
; WHERE NAME IS THE NAME OF A SYSTEM ROUTINE.
; IF NO SYSTEM ROUTINE WITH THE SPECIFIED NAME IF FOUND, THIS ROUTINE
; EXITS TO UUOERR.
; CONTENTS OF USER AC PLACED IN AC T1, M SET TO POINT TO USER AC.
; J SET TO JOB NUMBER

UCALL::	UMOVE	T1,(M)			;SET T1 FROM CONTENTS OF USER ADDRESS
	MOVSI	T2,-UCLLEN-CCLLEN-1	;-SUM OF LENGTHS OF SIXBIT TABLES,
					; -1 FOR THE CARRY TO LH IN AOBJN
	HRRI	T2,-CCLLEN		;- LENGTH OF CUSTOMER TABLE
	CAMN	T1,UCLTAB(T2)		;SEARCH SYSTEM ROUTINE NAME TABLE
	 JRST	UCALLF
	AOBJN	T2,.-2
	JRST	ERRCAL			;CALL ARGUMENT NOT FOUND

UCALLF:	HRRM	T2,M			;STORE INDEX IN M,
					; JUST AS IF USER HAD DONE CALLI MUUO

;CALLI MUUO	-	CALL IMMEDIATE
;CALLI D,E
;WHERE E IS RELATIVE INDEX IN CALL TABLE


UCALLI::HRRE	T2,M		;GET CALLI NUMBER(POS.=DIGITAL,NEG.=CUSTOMER DEFINED)
	JUMPL	T2,UCALL1	;IF NEG CALLI, TEST IS REVERSED
	TRZE	T2,UPHNLY	;TEST BIT TO SPECIFY PHYSICAL ONLY
	 HRLI	W,PHONLY	;AND REMEMBER IT IN LH OF W
	JRST	UCALL2
UCALL1:	TRON	T2,UPHNLY
	 HRLI	W,PHONLY
UCALL2:	CAML	T2,[-CCILEN]	;MORE NEGATIVE THAN MOST NEGATIVE CUSTOMER DEFINED M?
	CAIL	T2,UCILEN	;MORE POSITIVE THAT DIGITAL DEFINED CALLI?
	 POPJ	P,		;YES, RETURN TO USER TREAT AS NO-OP SO
				; PROGRAMS AHEAD OF MONITOR WILL STILL
				; RUN WITHOUT ERROR MESSAGE
	HRR	M,W		;AC FIELD FROM MUUO INSTRUCTION
	UMOVE	T1,(M)		;PICK UP CONTENTS OF USER AC
	ROT	T2,-1		;DEVIDE BY 2 AND SAVE REMAINDER
	MOVE	J,JOB		;SETUP CURRENT JOB NUMBER(IN CASE THIS IS CALLI)
	SKIPGE	T2		;IS CALLI ODD?
	 SKIPA	U,UCLJMP(T2)	;YES, USE RH
	   MOVS	U,UCLJMP(T2)	;NO, USE LH
	JRST	(U)		;DISPATCH.

;CALL MUUO DISPATCH TABLE
;NEW MUUO'S MUST BE ADDED AT END SINCE CALLI DEPENDS ON
;POSITION IN TABLE, CUSTOMERS SHOULD ADD MUUO'S IN CNAMES MACRO SO CALLI ADDRESS
;WILL BE NEGATIVE.  IN THIS WAY BOTH DIGITAL AND ITS CUSTOMERS CAN ADD MUUO'S
;WITHOUT CONFLICT, DIGITAL GOING POSITIVE, CUSTOMERS GOING NEGATIVE.
; (ALSO, TOWARD TOP OF PAGE)

EXTERNAL DDTIN,DDTOUT,CPOPJ,DSKCLR,URUNHI,HNGUUO,AUXRED,ZAPCIR
EXTERNAL INTADR,INTENB,INTACT,INTASS,SETTIM,SETTR1,SETTR2,TINASS
EXTERNAL REDPIP,CREAUX
EXTERNAL POLPRT,RDHIST,SNOOPU,EVICT,RETACH,CREPTY
EXTERNAL UVALID,UPRERF,UWSCTL,URFBIT,UPROT,UPGSTS,UCREAT
EXTERNAL UPFSTS,UPESTS,UPESET,UVDSKP,VPGFIL,SETPID
EXTERNAL BLTPAG,UPISTS,UPRSTS,OTFSET,ABKUUO
EXTERNAL UCBADD,UCBHNG,UCBINI,UCBINW,UCBLEV,UCBMEM,UCBRLI,UCBSTS,UCBWAK
EXTERNAL VCLEAU,VFLCKU,VREMOU,VREPLU
EXTERNAL MOVBUF,SETMOD,WAIT,UUOSK1,STVSET,SETMCY,FINASS
IFCPU (<KS,F3>),<EXTERNAL CI.OPR>
IFCPU (<KI,KL>),<CI.OPR==CPOPJ>

DEFINE CNAMES <
	X FINASS,FINASS		; (-151) Frame interrupt assignment
	X SETLIM,SETLIM		; (-150) Set TRU limit
	X FLSTOP,FLSTOP		; (-147) Fail stop, continue allowed
	X SETINA,SETINA		; (-146) SET INACTIVITY TIMEOUT LIMIT
	X SETMAI,SETMAI		; (-145) Set (new) mail waiting bit
	X SETMCY,SETMCY		; (-144) Set micro-cycle timer
	X DAYTIM,DAYUUO		; (-143) RETURN DATE AND TIME
	X FLEXIT,FLEXIT		; (-142) Fail exit, no continue
	X CREPTY,CREPTY		; (-141) CREATE PTY
	X CIOPR,CI.OPR		; (-140) 2020/F3 COMMUNICATIONS UUO
	X SETSTV,STVSET		; (-137) SET START VECTOR
	X VPEEK,NPEEK		; (-136) PEEK WITH ERROR RETURN
	X RETACH,RETACH		; (-135) MOVE A TTY
	X EVICT,EVICT		; (-134) CAUSE NTQ SOFT. INT.
	X PGRSTS,UPRSTS		; (-133) GET REF BIT FAULT INFO
	X PGISTS,UPISTS		; (-132) GET ILL MEM REF/ADDR BREAK FAULT INFO
	X SETABK,ABKUUO		; (-131) SET ADDRESS BREAK
	X LOGOFF,LOGOFF		; (-130) RUN ALT. LOGOUT PROGRAM
	X SETALP,SETALP		; (-127) SET ALT. LOGOUT PROGRAM
	X SETOFSET		; (-126) SET "OTHER" FRAME UUO FOR VUUOS
	X CONT,CONTUU		; (-125) PUT TERMINAL IN USER MODE
	X PUTROY,PUTROY		; (-124) PUT ROYALTY STREAM RECORD
	X BLTPAG,BLTPAG		; (-123) BLT DATA TO A LOCKED PAGE
	X PIDSET,SETPID		; (-122) SET PROGRAM'S PID
	X FOO,CPOPJ		; (-121) DEFUNCT GET PAGE FAULT WORD UUO
	X BITPOK,BITPOK		; (-120) POKE WITH MASK
	X RDHIST,RDHIST		; (-117) READ SNOOP HISTOGRAM
	X SNOOP,SNOOPU		; (-116) START/STOP SNOOP HISTOGRAM
	X POLPRT,POLPRT		; (-115) POLL PORTS
	X CLBADD,UCBADD		; (-114) ADD SELF TO CLUB.
	X CLBLEV,UCBLEV		; (-113) REMOVE SELF FROM CLUB.
	X CLBINW,UCBINW		; (-112) GET CLB INTRLK (WAIT).
	X CLBINI,UCBINI		; (-111) GET CLB INTRLK (IMMED).
	X CLBRLI,UCBRLI		; (-110) RELEASE CLB INTRLK.
	X CLBMEM,UCBMEM		; (-107) GET INFO ABOUT CLB MBR.
	X CLBSTS,UCBSTS		; (-106) GET STATUS OF CLB MBR.
	X CLBWAK,UCBWAK		; (-105) WAKE JOB IN SAME CLB.
	X CLBHNG,UCBHNG		; (-104) HANG JOB IN SAME CLUB.
	X VPGFIL,VPGFIL		; (-103) GET FILENAME ETC FOR VP
	X VDSKPT,UVDSKP		; (-102) GET DISK POINTER FOR VP
	X PGFSTS,UPFSTS		; (-101) GET AND CLEAR PAGE FAULT STATUS
	X PGESTS,UPESTS		; (-100) GET AND CLEAR PAGE ERROR STATUS
	X VFSTAT,VFLCKU		; (-77) SEE IF THE F BIT IS ON.
	X VALPAG,UVALID		; (-76) VALIDATE AND WAIT
	X PREREF,UPRERF		; (-75) PRE REFERENCE A VIRTUAL PAGE
	X WSCTL,UWSCTL		; (-74) WORKING SET CONTROL
	X REFBIT,URFBIT		; (-73) REFERENCE BIT CONTROL
	X PERSET,UPESET		; (-72) SET/CLEAR IGNORE ERROR BIT
	X PAGSTS,UPGSTS		; (-71) GET PAGE STATUS
	X VPROT,UPROT		; (-70) SET VM PAGE PROTECTION
	X VCREAT,UCREAT		; (-67) CREATE PRIVATE VM PAGE
	X VCLEAR,VCLEAU		; (-66) CLEAR VM PAGE.
	X VREMOV,VREMOU		; (-65) REMOVE VM PAGE.
	X VREPLC,VREPLU		; (-64) REPLICATE VM PAGE.
	X PUTLSA,LSAUUO		; (-63) GENERATE LOCAL STR ACCTG REC
	X PUTSAR,PUTSAR		; (-62) PUT STREAM ACCT'G RECORD
	X CHPRJ,CHPJC##		; (-61) CHANGE PROJ CODE
	X XCHARG,XCHARG		; (-60) SAVE (ETC) CHARGING
	X SETRCF,RECMFL		; (-57) DEFINE RESTRICTED COMMAND FILE AND PPN
	X TYMCHG,SOAKEM		; (-56) ADD TRU CHARGES
	X DATUUO,DATUUO		; (-55) CONVERT DATES AND TIMES
	X DDT620,CPOPJ		; (-54) INTERROGATE REMOTE 620
	X VALRMT,CPOPJ		; (-53) VALIDATE REMOTE PASSWORD
	X INTRMT,INTRMT		; (-52) SET REMOTE INTERRUPTS (CHKPNT & ACT:)
	X IDLRMT,CPOPJ		; (-51) SET REMOTE IDLE
	X ZAPRMT,CPOPJ		; (-50) ZAP REMOTE
	X CRERMT,CPOPJ		; (-47) CREATE REMOTE PORT
	X AUXRED,AUXRED		; (-46) READ AUX CIRCUIT INFO
	X ZAPCIR,ZAPCIR		; (-45) ZAP AUX CIR
	X CREAUX,CREAUX		; (-44) CREATE AUX CIR
	X REDPIP,REDPIP		; (-43) READ PI IN PROGRESS BITS
	X TINASS,TINASS		; (-42) ASSIGN TTY INTERRUPTS
	X SETTR2,SETTR2		; (-41) SET TRAP 2 INSTR (PDLOV)
	X SETTR1,SETTR1		; (-40) SET TRAP 1 INSTR (OVERFLOW)
	X SETTIM,SETTIM		; (-37) SET INTERRUPT TIMER
	X INTASS,INTASS		; (-36) ASSIGN APR INTERRUPTS
	X INTACT,INTACT		; (-35) CAUSE PSEUDO INTERRUPT
	X INTENB,INTENB		; (-34) ENABLE INTERUPT CHANNELS
	X INTADR,INTADR		; (-33) TURN ON NEW INTERRUPT SYSTEM
SIXSTP==-1
	X HANG,HNGUUO		; (-32) HANG A JOB
	X CHKLIC,CHKLIC		; (-31) CHECK SETTABLE LICENSE
	X LEVDEF,LEVDEF		; (-30) LEAVE DEFERED ECHO MODE
	X MOVBUF,MOVBUF		; (-27) MOVE I/O BUFFER
	X SETMOD,SETMOD		; (-26) SET TTY MODE (SETSTS BUT NO INIT)
	X RUNSEG,URUNHI		; (-25) RUN A HIGH SEG
	X SYSDVF,SYSDVF		; (-24) GET DEVICE INFO
	X DISMIS,DISMIS		; (-23) DISMAISS TRAP
	X DSKCLR,DSKCLR		; (-22) CLEAR DSK CORE INFO
	X SETJAL,SETJAL		; (-21) SET JACCT, LOGIN
	X ONEJOB,ONEJOB		; (-20) SEE IF ONLY JOB ON SYSTEM
	X SETMAL,SETMAL		; (-17) SET MAIL WAITING
	X GETTMC,GETTMC		; (-16) GET TERM CHRS
	X SETTMC,UUOMNR		; (-15) SET TERM CHRS
	X REDNXT,REDNXT		; (-14) READ NEXT CHR
	X WAITCH,WAITCH		; (-13) WAIT FOR CHARACTER
	X POKE,POKE		; (-12) POKE MUUO
	X SETPRV,SETPRV		; (-11) MOVING SETPRV HERE
	X SETLIC,SETLIC		; (-10) SET JBTLIC
	X SETE,SETE		; (-7) SETE WITH SYS PASSWORD
	X ATTACH,ATTUUO		; (-6) ATTACH, DETACH MUUO
	X UUOERR,UUOMNR		; (-5) PLACE FOR CUSTOMERS TO PATCH UUOS
	X UUOERR,UUOMNR		; (-4)
	X UUOERR,UUOMNR		; (-3) SET BITS IN JBTPRV
	X 6WDBLK,UUOMNR		; (-2) FOR COMPATABILITY
	X LIGHTS,LIGHTS		; (-1) SET LIGHTS (EXAMPLE OF CUSTOMER DEFINED M)
>  ;end DEFINE CNAMES

DEFINE NAMES,<
	X RESET,RESET		;  (0) RESET IO
	X DDTIN,DDTIN		;  (1) EXT-GET DDT CHAR.
	X SETDDT,SETDDT		;  (2) SETDDT LOC IN PROTECTED JOB DATA
	X DDTOUT,DDTOUT		;  (3) EXT:SEND DDT CHAR.
	X DEVCHR,DVCHR		;  (4) DEVICE CHARACTISTICS
	X DDTGT,CPOPJ		;  (5) GET DDT MODE
	X GETCHR,DVCHR		;  (6) DEVICE CHAR.(DIFF. NAME)
	X DDTRL,CPOPJ		;  (7) RELEASE DDT MODE
	X WAIT,WAIT		; (10) WAIT TILL DEVICE INACTIVE
	X CORE,CORUUO		; (11) CORE MUUO
	X EXIT,EXIT		; (12) EXIT
	X UTPCLR,CPOPJ		; (13) CLEAR DEC TAPE DIRECTORY
	X DATE,DATEU		; (14) GET DATE
	X LOGIN,LOGIN		; (15) LOGIN
	X APRENB,APRENB		; (16) ENABLE APR FOR TRAPPING
	X LOGOUT,LOGOUT		; (17) LOGOUT
	X SWITCH,SWITCH		; (20) RETURN DATA SWITCHES
	X REASSIGN,REASSIGN	; (21) REASSIGN DEVICE TO ANOTHER JOB
	X TIMER,TIMER		; (22) RETURN JIFFY CLOCK TIME
	X MSTIME,MSTIME		; (23) RETURN TIME OF DAY IN MS
	X GETPPN,GETPPN		; (24) RETURN PROJECT-PROGRAMMER NUMBER
	X TRPSET,UTRPST		; (25) SET USER-IOT
	X TRPJEN,UUOMNR		; (26) DISMISS INTERRUPT TO EXEC MODE(SUPERCEDED BY UJEN)
	X RUNTIM,JOBTIM		; (27) RETURN TOTAL JOB RUNNING TIME
	X PJOB,JOBNO		; (30) RETURN JOB NUMBER
	X SLEEP,SLEEP		; (31) SLEEP FOR N SECONDS, THEN RETURN TO USER
	X SETPOV,SETPOV		; (32) OLD SET PUSH DOWN OVERFLOW TRAP
	X PEEK,UPEEK		; (33) TO PEEK AT CERTAIN MONITOR PARAMETERS
	X GETLIN,GETLN		; (34) GET TTY UNE NUMBER
	X RUN,URUN		; (35) RUN DEV:FILE
	X SETUWP,SETUWP		; (36) SET OR CLEAR USER MODE WRITE PROTECT
	X REMAP,REMAP		; (37) REMAP TOP OF LOW SEGMENT INTO HIGH SEG
	X GETSEG,UGTSEG		; (40) GET SHARABLE HIGH SEG
	X GETTAB,GETTAB		; (41) GET EXEC ADDRESS OF A JOB TABLE
	X SPY,CPOPJ		; (42) MAP MONITOR LOWSEG TO USER'S HISEG
	X SETNAM,SETNAM		; (43) SET NAME OF THIS PROGRAM
	X TMPCOR,TMP.UU		; (44) TEMPORARY FILE STORAGE (CCL)
	X DSKCHR,DSKCHR		; (45) DISK CHARACTERISTICS
	X SYSSTR,SYSTUU		; (46) RETURN NEXT STR IN SYSTEM
	X JOBSTR,JOBSTR		; (47) RETURN NEXT STR IN JOB
	X STRUUO,STRUUO		; (50) VARIOUS FUNCTION FOR STRS
	X SYSPHY,SYSPHY		; (51) RETURN ALL PHYSICAL DEVS AND UNITS IN SYSTEM
	X FRECHN,CPOPJ		; (52) RETURN 1ST FREE USER CHAN IN AC, STARTING FROM C(AC)
	X DEVTYP,DEVTYP		; (53) EXTENDED DEVICE CHARACTERISTICS AND BUFFER SIZE
	X DEVSTS,DEVSTA		; (54) DEVICE STATUS
	X DEVPPN,DEVPPU		; (55) RETURN PPN FOR DEVICE
	X SEEK,UUOSK1		; (56) SEEK
	X RTTRP,CPOPJ		; (57) REAL TIME TRAP
	X LOCK,CPOPJ		; (60) LOCK JOB IN CORE
	X JOBSTS,JOBSTS		; (61) RETURN STATUS OF JOB AND ITS PTY
	X LOCATE,CPOPJ		; (62) SET DEFAULT FOR ANF-10 PRINTER
	X WHERE,CPOPJ		; (63) GET NODE NUMBER OF ANF-10 DEVICE
	X DEVNAM,UDEVNM		; (64) GET PHYSICAL DEVICE NAME
	X CTLJOB,CTLJOB		; (65) FIND CONTROLLER OF THIS JOB (IF BY PTY)
	X GOBSTR,GOBSTR		; (66) GENERALIZED JOBSTR (ANY JOB'S SEARCH LIST)
	X FOO,CALI67		; (67) RESERVED (ACTIVATE UUO NEVER IMPLEMENTED)
	X FOO,CALI70		; (70) RESERVED (DEACTIVATE UUO NEVER IN TOPS10)
	X HPQ,CPOPJ		; (71) SET HIGH PRIORITY QUE
	X HIBER,HIBER		; (72) HIBERNATE
	X WAKE,WAKUUO		; (73) WAKE SLEEPING JOB
	X CHGPPN,CHGPPN		; (74) CHANGE PPN
	X SETUUO,SETUUO		; (75) SET UUO
	X DEVGEN,CPOPJ		; (76) GENERIC NUMBER
	X OTHUSR,OTHUSR		; (77) SEE IF OTHER USER
	X CHKACC,CPOPJ		;(100) SEE IF ACCESS ALLOWED
	X DEVSIZ,DVSIZU		;(101) BUFFER SIZE AND NUMBER
                                        ;Last CALLI in 5.02
	X DAEMON,CPOPJ		;(102) CALL DAEMON
	X JOBPEK,CPOPJ		;(103) READ/WRITE ANOTHER JOB'S CORE
	X ATTACH,UATTAC		;(104) ATTACH OR DETACH JOBS.
	X DAEFIN,CPOPJ		;(105) DAEMON FINISHED - RESTART USER JOB
	X FRCUUO,CPOPJ		;(106) FORCE COMMAND FOR JOB
	X DEVLNM,CPOPJ		;(107) SET DEVICE LOGICAL NAME
                                        ;Last CALLI in 5.03

	X CPOPJ,CPOPJ		;2 SPARE MUUO'S FOR PATCHING - DIGITAL ONLY
	X CPOPJ,CPOPJ		;ALWAYS ADD NEW MUUO'S ABOVE THESE
				;  CUSTOMERS SHOULD ADD MUUO'S ABOVE
				; IN CNAMES MACRO RATHER THAN NAMES MACRO
				; SO THAT THEIR CALLI INDICES WILL BE NEGATIVE
>  ;end DEFINE NAMES
;;;;;	PATH.,PTHUUO##,UU.LEA	;(110) TEST/SET FULL PATHS FILES (SFD'S, LIB:)
;;;;;	METER.,METER##,UU.LEA+UU.CP0 ;(111)PERFORMANCE METERING
;;;;;	MTCHR.,MTACHR##,	;(112)GET MAGTAPE CHARACTERISTICS
;;;;;	JBSET.,JBSET.##,UU.EA+2	;(113)SETUUO ON OTHE JOB
;;;;;	POKE.,POKE,UU.EA+3	;(114)CHANGE MONITOR
;;;;;	TRMNO.,TRMNO##,		;(115)TERMINAL NUMBER FOR JOB
;;;;;	TRMOP.,TRMOP##,UU.LEA	;(116)TERMINAL OPERATIONS UUO
;;;;;	RESDV.,RESDV,		;(117)RESET DEVICE OR CHANNEL
;;;;;	UNLOK.,UNLOK.##,	;(120)UNLOCK A LOCKED JOB
                                        ;Last CALLI in 5.04
;;;;;	DISK.,DSKUUO##,UU.EA	;(121)RANDOM DISK FUNCTIONS
;;;;;	DVRST.,DEVRST,		;(122)RESTRICT DEVICE TO OPER ONLY
;;;;;	DVURS.,DEVURS,		;(123)UNRESTRICT DEVICE
                                        ;Last CALLI in 5.05 & 5.06
;;;;;	XTTSK.,XTUUO##,UU.LEA	;(124)DA28C DEPENDENT FUNCTIONS
;;;;;	CAL11.,CALL11##,UU.LEA	;(125)MULTI-FUNCTION CALLI FOR THE PDP-11
;;;;;	MTAID.,MTARID##,	;(126)FOR MTA ERROR REPORTING
;;;;;	IONDX.,UIONDX,		;(127)RETURN IO DEVICE INDEX
;;;;;	CNECT.,CONECT##,UU.EA+1	;(130)CONNECT A DEVICE TO AND MPX CHANNEL
;;;;;	MVHDR.,MOVHDR,		;(131)MOVE BUFFER HEADER
;;;;;	ERLST.,ERLST##,UU.EA+2	;(132)ERROR LIST
;;;;;	SENSE.,SENSE##,UU.LEA	;(133)SENSE
;;;;;	CLRST.,CLRST##,UU.LEA	;(134)CLEAR STATUS
;;;;;	PIINI.,PIINI##,UU.EA	;(135)INITIALIZE SOFTWARE INTERRUPT SYSTEM
;;;;;	PISYS.,PISYS##,		;(136)MANIPULATE SOFT. INTERRUPT SYSTEM
;;;;;	DEBRK.,DEBRK##,		;(137)DISMISS A SOFTWARE INTERRUPT
;;;;;	PISAV.,PISAVE##,UU.LEA	;(140)SAVE THE PI SYSTEM
;;;;;	PIRST.,PIRST##,UU.EA+UU.CEA ;(141)RESTORE THE PI SYSTEM
;;;;;	IPCFR.,UIPCFR##,	;(142) IPCF READ
;;;;;	IPCFS.,UIPCFS##,	;(143) IPCF SEND
;;;;;	IPCFQ.,UIPCFQ##,	;(144) IPCF QUERY
;;;;;	PAGE.,UPAGE.##,		;(145) PAGING (REPLACES CORE UUO)
;;;;;	SUSET.,USUSET##,	;(146) SUPER USETI/O
;;;;;	COMPT.,CPOPJ##,		;(147) CALL TO COMPATABILITY PACKAGE PA1040
                                        ;Last CALLI in 5.07/6.01
;;;;;	SCHED.,SCHED.##,	;(150) SET SCHEDULING PARAMETERS
;;;;;	ENQ.,ENQ##,		;(151) ENQUEUE
;;;;;	DEQ.,DEQ##,		;(152) DEQUEUE
;;;;;	ENQC.,ENQC##,		;(153) ENQ CONTROLLER
;;;;;	TAPOP.,UTAPOP##,UU.LEA	;(154) TAPE OPERATIONS
;;;;;	FILOP.,FILOP,UU.LEA	;(155) FILE OPERATIONS
;;;;;	CAL78.,CALL78##,	;(156) FOR DAS78
;;;;;	NODE.,NODE.U##,		;(157) ANF-10 NETWORK INFORMATION
;;;;;	ERRPT.,ERRPT.##,	;(160) ERROR REPORTING, CALLS DAEMON
;;;;;	ALLOC.,CPOPJ##,		;(161) OBSOLETE, ALLOC.
;;;;;	PERF.,UPERF.,		;(162) KL10 PERFORMANCE ANALYSIS
                                        ;Last CALLI in 6.02
;;;;;	DIAG.,DIAUUO,		;(163) DIAGNOSTIC
;;;;;	DVPHY.,DVPHY.,		;(164) RETURN PHYSICAL DEVICE NAME
;;;;;	GTNTN.,GTNTN,		;(165) GET THE NETWORK TTY NUMBER
;;;;;	GTXTN.,GTXTN,		;(166) GET THE -10 TTY NAME GIVEN NET TTY #
;;;;;	ACCT.,ACCT,		;(167) READ/SET ACCOUNTING STRING
;;;;;	DTE.,DTE.##,		;(170) DTE. UUO TO CONTROL CONSOLE-FRONT END
;;;;;	DEVOP.,DEVOP,UU.LEA	;(171) GENERAL DEVICE OPERATIONS
;;;;;	SPPRM.,SPPRM,UU.LEA	;(172) OBSOLETE, USE QUEUE. TO SET SPOOL PARMS
                                        ;Last CALLI in 6.03
;;;;;	MERGE.,UMERGE##,UU.EA+6	;(173) MERGE LOWSEG PAGES FROM EXE FILE
;;;;;	UTRP.,UUTRP,UU.LER	;(174) SET USER-MODE TRAP INSTRUCTION IN UPT
;;;;;	PIJBI.,PIJOB##,		;(175) CAUSE CROSS-JOB INTERRUPTS
;;;;;	SNOOP.,SNOOP,		;(176) INSERT/DEL BREAKPOINTS IN RUNNING MONITOR
;;;;;	TSK.,TSK.##,		;(177) TASK-TO-TASK LINKS
;;;;;	KDP.,KDP.##,		;(200) LOAD/DUMP/START KMC-11
                                        ;Last CALLI in 7.00
;;;;;	QUEUE.,GLXINF##,	;(201) INTERFACE TO GALAXY
;;;;;	RECON.,RECON,		;(202) SYSTEM RECONFIGURATION
                                        ;Last CALLI in 7.01
;;;;;	PITMR.,PITMR##,		;(203) PSI TIMER INTERRUPT
;;;;;	ACCLG.,ACCLOG,		;(204) ACCESS CHECKING FOR LOGIN VIA ACTDAE
;;;;;	NSP.,SCUUUO##,		;(205) DECNET-10 NETWORK SESSION PARAMETERS
;;;;;	NTMAN.,NTMAN##,		;(206) DECNET NETWORK MANAGEMENT
;;;;;	DNET.,DNET##,		;(207) DECNET INFORMATION
;;;;;	SAVE.,USAVE##,UU.EA+6	;(210) SAVE CORE-IMAGE ON DISK
;;;;;	CMAND.,CMAND,		;(211) USER DEFINABLE COMMANDS
;;;;;	PIBLK.,PIBLK##,		;(212) DETERMINE ADDRESS OF PI VECTOR BLOCK
                                        ;Last CALLI in 7.02
                                ;CUSTOMERS SHOULD ADD UUO'S ABOVE
                                ;IN CNAMES MACRO RATHER THAN NAMES MACRO
                                ; SO THAT THEIR CALLI INDICES WILL
                                ; BE NEGATIVE
	LIST
	SALL
;GENERATE SIXBIT TABLE OF MUUO NAMES

DEFINE X (A,B) <
IFN SIXSTP,<EXP SIXBIT /A/>
>

;GENERATE CUSTOMER CALL/CALLI MUUO'S
SIXSTP==0

CCLTAB:	CNAMES
CCLLEN==.-CCLTAB		;LENGTH OF CUSTOMER DEFINED CALL/CALLI MUUO'S
			;(MINIMUM CALLI NUMBER, TOO)

;GENERATE DIGITAL MUUO'S

DEFINE X (A,B)  <
	IFL .-UCLTAB-MAXCAL,<EXP SIXBIT /A/>
>

UCLTAB:	NAMES
UCLLEN==.-UCLTAB		;DEFINE LENGTH OF DIGITAL MUUO TABLE
DEFINE X (A,B)
<	ZZ==ZZ+1
	DEFINE XX (C)		;DEFINE XX IN CASE JOB NUMBER OF CUSTOMER MUUO'S
<	XWD UUOERR,C
>>
ZZ==0
;COUNT NUMBER OF CUSTOMER DEFINED MUUO'S
	CNAMES
CCILEN==ZZ

;GENERATE HALF WORD MUUO DISPATCH TABLE

DEFINE X (A,B)
<	IFE ZZ&1,
<	DEFINE XX (C)
<
	XWD B,C
>>
	IFN ZZ&1,
<
	XX B
>
ZZ==ZZ+1
>  ;end DEFINE X
;GENERATE CUSTOMER TABLE

	CNAMES

ZZ==0

;FIX UP SYMBOLS NOT IN UUOCON

EXTERNAL REASSIGN,WAKUUO

EXTERN TMP.UU
EXTERN DSKCHR,SYSTUU,JOBSTR,STRUUO,SYSPHY,GOBSTR
EXTERNAL APRENB,SETPOV,SLEEP,HIBER,DISMIS	;IN PICON

;GENERATE DIGITAL TABLE

UCLJMP:	NAMES

	IFN ZZ&1,<XX CPOPJ>	;GEN. LAST WORD IF ODD NUMBER OF UUOS
UCILEN==<.-UCLJMP>*2	;MAX DIGITAL CALLI INDEX

OTHUSR:	POPJ	P,	;CALLI +77
CTLJOB:	POPJ	P,	;CALLI +65
JOBSTS:	POPJ	P,	;CALLI +61

;CONT UUO
;CALLI -125

;	CONT
;	  <NO-LICENSE or DETACHED>
;	<NORMAL-RETURN>

EXTERN	TTYUSM				; ROUTINE IN SCNSER
EXTERN	DDBLDB				; HOME OF LDB POINTER IN DDB

CONTUU:	MOVE	F,TTYTAB(J)		; FIND THE DDB
	HRRZ	U,DDBLDB(F)		; FIND THE LDB
	JUMPE	U,CPOPJ			; ERROR IF DETACHED
	PUSHJ	P,TTYUSM		; DO THE WORK
	JRST	CPOPJ1


;EXIT MUUO ROUTINE
;CALL:	CALL FIELD, [SIXBIT/EXIT/]
;IF FIELD - 0, PRINT EXIT ^C.  CONT WILL NOT WORK
;IF FIELD NON-ZERO, JUST PRINT.  DO NOT RELEASE DEVICES

EXTERNAL ERREXI,ERREX1,IORELS

EXIT:	MOVSI	T1,JACCT	;CLEAR PRIVILEGED CUSP BIT ON EXIT FOR
				; BENEFIT OF PLEASE AND RECALL
	HRRI	T1,JACCT2	;ALSO USER SETTABLE ONE
	ANDCAM	T1,JBTSTS(J)
	JUMPN	W,EXIT1		;AC FIELD NON-ZERO?
	PUSHJ	P,IORELS	;NO, RELEASE ALL DEVICES
	PUSHJ	P,RESET		;AFTER CLOSING OUT FILES, RELEASE RT DEV
				;UNLOCK JOB, RESET APR
 EXTERNAL ACTWRT
	MOVEI	T1,1
	PUSHJ	P,ACTWRT	;WRITE TYPE 1 ACCOUNTING RECORD
	PJRST	ERREXI		;MOVE "EXIT" TO OUTPUT BUFFER
				; AND STOP JOB, AND START TTY
				; "CONTINUE" WILL NOT WORK
EXIT1:	MOVEI	T1,2
	PUSHJ	P,ACTWRT	;WRITE TYPE 2 ACCOUNTING RECORD
	PJRST	ERREX1


;Frame Exit Routine(s)
; Specified AC is stored into %UPT+UPTELC
;FLEXIT - Fail exit, not continuable
;FLSTOP - Fail stop, continuable

EXTERNAL ERRFEX,ERRFX1

FLEXIT:	MOVSI	T1,JACCT	;CLEAR PRIVILEGED CUSP BIT ON EXIT FOR
				; BENEFIT OF PLEASE AND RECALL
	HRRI	T1,JACCT2	;ALSO USER SETTABLE ONE
	ANDCAM	T1,JBTSTS(J)
	PUSHJ	P,IORELS	;NO, RELEASE ALL DEVICES
	PUSHJ	P,RESET		;AFTER CLOSING OUT FILES, RELEASE RT DEV
				;UNLOCK JOB, RESET APR
	MOVEI	T1,1
	PUSHJ	P,ACTWRT	;WRITE TYPE 1 ACCOUNTING RECORD
	UMOVE	T4,(W)		;Pick up arg from user's AC
	PJRST	ERRFEX		;MOVE "EXIT" TO OUTPUT BUFFER
				; AND STOP JOB, START TTY, CONT WILL NOT WORK

FLSTOP:	MOVSI	T1,JACCT	;CLEAR PRIVILEGED CUSP BIT ON EXIT FOR
				; BENEFIT OF PLEASE AND RECALL
	HRRI	T1,JACCT2	;ALSO USER SETTABLE ONE
	ANDCAM	T1,JBTSTS(J)
	MOVEI	T1,2
	PUSHJ	P,ACTWRT	;WRITE TYPE 2 ACCOUNTING RECORD
	UMOVE	T4,(W)		;Pick up arg from user's AC
	PJRST	ERRFX1

;
;  CODE TO HANDLE SOFTWARE I/O INTERRUPT UUO
;

NINTRP:	POINT 6,DEVINT(F),5		;INPUT INTERRUPT
NOUTRP:	POINT 6,DEVINT(F),11		;OUTPUT INTERRUPT
NWATRP:	POINT 6,DEVINT(F),17		;IO WAIT INTERRUPT
NERTRP:	POINT 6,DEVINT(F),23		;ERROR INTERRUPT
NEFTRP:	POINT 6,DEVINT(F),29		;EOF INTERRUPT
NSPTRP:	POINT 6,DEVINT(F),35		;SPECIAL INTERRUPT
NUMINT==.-NINTRP
;; NEW VM SYSTEM RESET UUO KERNEL
;; FUNCTION:1) (NEW) GUARANTEE THAT PAGE 0 BECOMES PRIVATE-RDW
;;	    2) RESET CONTROLLING TTY
;;	    3) DIDDLE PC FLAGS
;;	    4) (NEW) SET USER WS LIMIT TO MAX
;;	    5) SET JWSADJ BIT FROM ADJMWS
;;	    6) (NEW) RESET TRU LIMIT FROM JBTSLM
;;	    7) RESET XCHARG "CHARGES SAVED IN UPT" BIT
;;	    8) RESET TRAP SYSTEM
;;
;; PRESERVES: M  ---  DESTROYS: PRACTICALLY ALL AC'S.
;; EXPECTS: J/JOB

EXTERN PS.CPR,PS.FIL,UPYUWL,UPYUWM,RESFRH,IOKILL,CHNCHK,CHNCK1

RESET::	MOVEI	PG,0
	CALLI	PG,-71 		;GET PG/ PAGE STATUS, VP 0
	  JFCL			;NOT SPOSED TO HAPPEN
	TRNN	PG,PS.FIL	;SKIP IF FILE PAGE
	  JRST	RSET1		;PRIVATE, MAY NEED TO MAKE RDW
	MOVSI	PG,1		;PG/<CONTIG>,,VP#
	CALLI	PG,-65		;REMOVE PAGE 0
	  JFCL
	MOVSI	PG,(<CPRRDW>B7+1B17)
	CALLI	PG,-67		;CREAT NEW PAGE 0
	  JFCL			;SIGH
	JRST RSET2
RSET1:	;PRIVATE PAGE, JUST MAKE SURE IT'S RDW
	ANDI	PG,PS.CPR
	CAIE	PG,CPRRED	
	  JRST	RSET2		;NOT DO- MUST BE COW OR RDW
	MOVSI	PG,(<CPRRDW>B7+1B17)
	CALLI	PG,-70		;VPROT PG,
	  JFCL			;SIGH
RSET2:	PUSHJ	P,TTYRES	;RESET CONTROLLING TTY
	PUSHJ	P,IOKILL	;RELEASE ALL DEVICES
	MOVSI	T1,777777-PC.USR-PC.PUB	;CLEAR ALL MUUO PC FLAGS IN LH, EXCEPT USER MODE
	ANDCAM	T1,%UPT+UPTPDL	;LEAVE USER MODE OFF TOO, IF EXEC DOING CALL RESET
	MOVSI	T1,SAVCHG
	ANDCAM	T1,%UPT+UPTSTS	;RESET "XCHARG DONE" FLAG
	SETZM	JBTSCA##(J)	;Reset TRU scaling factor
	LDB	T1,UPYUWM	;CONSOLE-SETTABLE WS MAXIMUM
	DPB	T1,UPYUWL	;PROGRAMMABLE LIMIT
	MOVE	T1,JBTSTS(J)
	SKIPE	ADJMWS
	  TROA	T1,JWSADJ
	 TRZ	T1,JWSADJ
	MOVEM	T1,JBTSTS(J)	;SET PER-JOB MWS ADJUST BIT FROM ADJMWS
	PUSHJ	P,RESFRH	;GET RID OF ALL FRAME HANDLES
	MOVE	T1,JBTSLM(J)	;Copy saved TRU limit (if any) into the
	MOVEM	T1,JBTLIM(J)	; current LIMIT (checked at clock level)
	MOVEI	T1,0
	PJRST APRENB		;ALSO RESET INTERRUPTS


;; SETLIM - SET TRU LIMIT  (CALLI -150)
;;
;;  CALL:
;;	MOVE	AC,[ <funct>B8 + <tru-limit>B35 ]
;;	SETLIM	AC,
;;	  error return		; AC contains error code
;;	normal return
;;
;;  FUNCT:
;;	0  -  Set TRU limit to <tru-limit>, if 0 then reset limit
;;	1  -  Add <tru-limit> to current TRU limit
;;	2  -  Set TRU limit to current charges plus <tru-limit>
;;
;;  ERROR CODES:
;;	1  -  Illegal function code
;;	2  -  Illegal tru-limit (must be 0 to 3,435,973 TRUs)
;;	3  -  Limit exceeds maximum (set by console SET LIMIT)
;;
;;	
	XP .SLSET,0		; Set JBTLIM from C(AC), reset if C(AC)=0
	XP .SLEXT,1		; Extend JBTLIM by C(AC)
	XP .SLINC,2		; Increment current TRU by C(AC)

SETLIM:	JUMPE	T1,SETLI2		; .SLSET, limit=0 :: reset
	LDB	T2,[POINT 9,T1,8]	; Copy function
	TLZ	T1,777000		; Clear function bits
	CAILE	T2,.SLINC		; Must be legal
	  JRST	SETLE1			; *** Error: Illegal function code
	JUMPE	T2,SETLI0		; .SLSET, check size and set limit
	PUSH	P,T1			; Save increment
	MOVE	T1,JBTLIM(J)		; Default to extend current limit
	CAIE	T2,.SLEXT		; Check if want to EXTEND limit
	  PUSHJ	P,CLKTRU		; No, get current TRUs instead
	IDIVI	T1,^D10000		; Reduce to next smaller integer
	ADD	T1,(P)			; Add in saved increment
	POP	P,(P)			;   then fixup stack
SETLI0:	CAMLE	T1,[^D3435973]		; Is it still in range?
	  JRST	SETLE2			; No, *** Error: Too large
	IMULI	T1,^D10000		; Put limit in proper perspective
	SKIPN	JBTSLM(J)		; Was one set by console command?
	  JRST	SETLI1			; No, go set the limit
	CAMLE	T1,JBTSLM(J)		; Check against console value
	  JRST	SETLE3			; Sigh! *** Error: Exceeds maximum
SETLI1:	MOVEM	T1,JBTLIM(J)		; All is OK, set the limit
	JRST	CPOPJ1			; Return

SETLI2:	MOVE	T1,JBTSLM(J)		; Copy limit set by console
	MOVEM	T1,JBTLIM(J)		; All is OK, set the limit
	JRST	CPOPJ1			; Return

SETLE1:	SKIPA	T2,[1]			; %1 Illegal function
SETLE2:	MOVEI	T2,2			; %2 Illegal limit large
	JRST	RETERR			;  return error to user
SETLE3:	MOVEI	T2,3			; %3 Limit larger than maximum
	JRST	RETERR
; RESTRICED COMMAND FILE AND PPN UUO
;
RECMFL:	UMOVE T2,(T1)		;GET NAME
	MOVEM T2,%UPT+UPTRNM
	UMOVE T2,1(T1)		;GET PPN
	MOVEM T2,%UPT+UPTRPN
	POPJ P,

SETPRV:	MOVE	T2,PRVMSK	;get mask of legal bits
	TLO	T2,PVLOS	;allow user to SET PVLOS LogoutOnStop
	AND	T1,T2		;mask selected bits
	MOVE	T3,T1
	SETZ	T2,		;IF WANT TO RESET TIMEOUT
	TLNE	T3,PVDINA	;SET OR RESET INACTIVITY TIMEOUT?
	  HRRZ	T2,INADEF##	;SET. DEFAULT TIMEOUT (15 MIN, SEE NSWTBL+7)
	XOR	T3,JBTPRV(J)
	TLNE	T3,PVDINA	;HAS PVDINA CHANGED?
	  DPB	T2,JBYINA##	;YES, UPDATE
	MOVE	T2,PRVMSK
	ANDCAM	T2,JBTPRV(J)	;TURN OFF
	IORM	T1,JBTPRV(J)	;SET AS HE WANTED
	LDB	T1,PVYCRM	;GET MAX CORE HE CAN HAVE
	LDB	T2,PVYCOR	;AMOUNT HE JUST SET IT TO
	CAMLE	T2,T1		;TOO MUCH?
	  MOVE	T2,T1		;YES, RESET TO MAX
	CAMGE	T2,CORMXK
	  MOVE	T2,CORMXK
	DPB	T2,PVYCOR
	POPJ	P,

SETINA:	SETCMI	T2,JBLMSK##
	TDNE	T1,T2		;LIMIT TOO BIG?
	  POPJ	P,		;YES, ERROR RETURN
	CAMG	T1,INADEF##	;If limit is greater than default
	CAIG	T1,0		;  or less than acceptable
	  PUSHJ	P,CHKASL##	;Check if we have appropriate privs
	 CAIA			;Acceptable limit, sup or proper license
	   POPJ	P,		; otherwise, error return
	DPB	T1,JBYINA##	;SET LIMIT
	MOVSI	T2,PVDINA
	IORM	T2,JBTPRV(J)	;SET INACTIVITY TIMEOUT IN PRIVS
	SKIPN	T1		;DID WE JUST SET THE LIMIT TO 0?
	 ANDCAM	T2,JBTPRV(J)	;YES, SO CLEAR THE BIT
	JRST	CPOPJ1

PRVMSK::XWD PVNMAI!PVNOAT!PVMTIM!PVMCOR!PVDINA!PVSCMD,PVMMOD!PVEXO!PVMHNG!PVRCMD

comment !	SETALP uuo

	MOVEI	ac,	[sixbit "<device>"
			 xwd <gan>,<uun>
			 sixbit "<filename>"]
	SETALP	ac,
	  <error return>	; if already set, if logout in progress
				; or if no PPN given
	<ok return>
!
SETALP:	MOVE	T2,JBTSTS(J)
	TRNE	T2,KJP		; IF LOGOUT IN PROGRESS - ERROR
	 POPJ	P,
	SKIPE	%UPT+UPTALN	; IF ONE ALREADY SET - ERROR
	 JRST	[UMOVE	T2,0(T1)  ;Check if trying to set it to current value
		 CAME	T2,%UPT+UPTALD##
		  POPJ	P,	  ;Cannot change what is there
		 UMOVE	T2,1(T1)
		 UMOVE	T3,2(T1)
		 CAMN	T2,%UPT+UPTALP##
		 CAME	T3,%UPT+UPTALN##
		  POPJ	P,
		 JRST	CPOPJ1	] ;Don't complain if setting to same
	UMOVE	T2,0(T1)	; GET DEVICE
	MOVEM	T2,%UPT+UPTALD##
	UMOVE	T2,1(T1)	; GET PPN
	MOVEM	T2,%UPT+UPTALP##
	UMOVE	T2,2(T1)	; GET NAME
	MOVEM	T2,%UPT+UPTALN##
	PJRST	CPOPJ1		; SKIP RETURN
;DEC's ATTACH uuo (CALLI +104) attaches a job to a TTY line.  That is, you
;cannot detach an arbitrary job, but you can detach an arbritrary line.
;The only function that works under TYMCOM-X is <-1,,0> to detach this job.

UATTAC:	TLZ	T1,(1B0+1B1)	;Ignore flag bits if specified
	TLC	T1,177777	;Give error return if not now 177777,,0
	JUMPN	T1,CPOPJ	;Anything else should be done via RETACH uuo
	PFALL	ATTUUO		;Detach command port from current line if so

;ATTACH UUO (CALLI -6) -  CALLED WITH ONE OF
;
;	T1/	NEGATIVE (EQUIVALENT TO T1/ 0)
;	T1/	BITS,,0  (DETACH TTY FROM CURRENT JOB)
;	T1/	BITS,,JOB # (DETACH FROM CURRENT, ATTACH TO SPEC.)
;
;	BITS = 1 TO SUPPRESS FORCING THE ATTACHEE INTO COMMAND MODE
;	     + 2 TO SUPPRESS FORCING AN EXIT FOR THE DETACHEE

ATTUUO:	SKIPGE	T1		;IF T1 .LT. 0,
	 SETZ	T1,		;    T1 := 0
	TRNN	T1,-1		;IF T1.RIGHT = 0,
	 JRST	TDTUUO		;    DO A DETACH
	HRRZ	T3,T1		;T3/ JOB NUMBER
	MOVSI	T2,JNA
	CAIGE	T3,JOBN
	TDNN	T2,JBTSTS(T3)
	 POPJ	P,		;JOB DOES NOT EXIST
	MOVSI	T2,JLOG
	TDNN	T2,JBTSTS(J)	;IF CALLER ISN'T LOGGED-IN,
	 JRST	TRYATT		;    ALLOW ATTACH TO ANY AUN
	MOVSI	T2,LICJAL
	TDNE	T2,JBTLIC(J)	;IF CALLER HAS JL LICENSE,
	 JRST	TRYATT		;    ALLOW ATTACH TO ANY AUN
	MOVE	T2,JBTAUN(J)	;OTHERWISE,
	CAME	T2,JBTAUN(T3)	;    AUN'S MUST MATCH
	 POPJ	P,

TRYATT:	PUSH	P,T1		;SAVE <BITS>
	PUSHJ	P,TATUUO	;CALL SCNSER'S ATTACH ROUTINE
	  JRST	TPOPJ		;(IT COULDN'T ATTACH)
	POP	P,T1		;RESTORE <BITS>
	TLNE	T1,2		;IF SUPRESS-EXIT BIT SET,
	 POPJ	P,		;    JUST RETURN
	MOVE	J,JOB		;OTHERWISE, FORCE AN EXIT UUO
	MOVSI	T1,JLOG
	TDNN	T1,JBTSTS(J)
	 JRST	JOBKL		;OR JUST KILL THE JOB IF NOT LOGGED-IN
	MOVEI	W,0		;FORCE AN EXIT 0,
	JRST	EXIT

EXTERNAL TATUUO,TDTUUO,PVYCRM,PVYCOR,CORMXK
COMMENT !

INTRMT AC,0
	ASSIGNS CERTAIN INTERRUPT CAUSING CONDITIONS TO PSEUDO-
	INTERRUPT CHANNELS, USING THE NEW PSEUDO-INTERRUPT
	SYSTEM. MUST BE PRECEDED BY INTADR UUO.

	AC BITS 18-35 HAVE CHANEL NUMBER ON WHICH DEVICE IS INITED
		AN INIT MUST HAVE BEEN DONE
	AC BITS 9-17 HAVE THE INTERUPT CHANNEL NUMBER
	AC BITS 0-8 HAVE THE REASON FOR THE INTERUPT

		0  INPUT AVAILABLE
		1  OUTPUT BUFFER AVAILABLE. MUST HAVE INTERUPTED
		   FOR I/O WAIT
		2  UUO WOULD PLACE JOB IN I/O WAIT
		3  END OF FILE ON INPUT (NOT YET USED)
		4  ERROR ON INPUT OR OUTPUT (NOT YET USED)
		5  PORT ZAPPED

	NOTE THAT THE ERROR RETURN IS ALWAYS TAKEN IF THE PORT IS
	ALREADY ZAPPED

	SKIP RETURN IF SUCCESSFUL. AC HAS PREVIOUS CHANNEL ASSIGNMENT.
	NON-SKIP RETURN  IF NONSUCCESSFUL, ERROR CODE IN AC RIGHT
		NOPORT = PORT NOT ASSIGNED TO THIS JOB
		NXCOND = NON-EXISTENT CONDITION
		NXCHAN = NON-EXISTENT CHANNEL
		NOINT  = NOT PRECEDED BY INTADR
!



EXTERN JBTPIP
;T1 HAS USER AC CONTENTS
EXTERNAL TAKTRP,CHNCK1
INTERNAL RETERR
NXICHN==1		;INCORRECT CHANNEL NUMBER
NXCOND==5		;NON EXISTENT INTERRUPT CONDITION
NXCHAN==6		;NON EXISTENT INTERRUPT CHANNE
NOINT==7		;INTADR UUO NOT CALLED
INTRMT::MOVEI	T2,NXICHN	;INCASE ERROR RETURN FROM CHNCK1
	HRRZ	W,T1		;GET PROPOSED CHANNEL NUMBER
	PUSH	P,T1
	MOVEI	T1,DDINT
	PUSHJ	P,CHNCK1##	;SEE IF REAL CHANNEL
	  JFCL			;BAD CHAN
	  JRST	[POP P,T1	;NOT IN DISPATCH TABLE,UNWIND STK &
		JRST RETERR]	; RTN NXICHN ERR COD
	POP	P,T1
	SKIPGE	JBTPIP(J)
	  JRST	INTER1		;NO INTADR DONE
	LDB	T2,[POINT 9,T1,8]
	CAIL	T2,NUMINT	;LEGAL CONDITION?
	  JRST	INTER2		;NO
	LDB	T1,[POINT 9,T1,17]
	CAILE	T1,^D35		;LEGAL CHANNEL?
	  JRST	INTER3
	LDB	T3,NINTRP(T2)	;GET OLD CHANNEL
	UMOVEM	T3,(W)		;AND RETURN
	DPB	T1,NINTRP(T2)
	JUMPE	T1,CPOPJ1	;IF 0, COULD NOT INTERUPT NOW
	MOVE	P1,T1		;SAVE CHANNEL NUMBER
	PUSHJ	P,DDINT(T4)	;CALL DEVICE DEPENDENT ROUTINE
	  JRST	INTER3		;ERROR RETURN
	  SKIPA			;O.K. BUT NO TRAP NOW
	JRST	[MOVE T1,P1	;TAKE TRAP. RECOVER CHANNEL NUMBER
		 PUSHJ P,TAKTRP
		 JRST CPOPJ1]
	JRST	CPOPJ1


INTER1:	MOVEI	T2,NOINT
	JRST	RETERR
INTER2:	MOVEI	T2,NXCOND
	JRST	RETERR
INTER3:	MOVEI	T2,NXCHAN
RETERR:	UMOVEM	T2,(M)		;T2 has error code, return it to user
	POPJ	P,
SUBTTL	SETLIC (CALLI -10) - Set process and frame license
EXTERNAL JBTLIC,MAXLIC,LICMSK,JBTSLC

	;SETLIC UUO. SETS BOTH HALVES OF JBTLIC
	;CHECKS TO SEE IF MAX OF CURRENT TWO HALVES ALLOWS
	;DESIRED SETTING. IF NOT SETS AS MUCH AS IT CAN GET
	;CALL
	;	MOVE AC,DESIRED LICENSE
	;	CALL AC,[SIXBIT /SETLIC/] OR CALLI AC,-10

SETLIC:	MOVE	T2,JBTLIC(J)
	HLL	T2,JBTSLC(J)	;SAVED LIC ALWAYS .GE. JBTLIC L.H.
	PUSH	P,T1		;LICENSE DESIRED
	PUSHJ	P,JOBLIC	;FIND WHAT CAN BE SET
	MOVE	T2,(P)		; Get max of new
	HLR	T2,JBTSLC(J)	;  and old
	PUSHJ	P,MAXLIC	;  process lic
	HRLM	T2,JBTSLC(J)	; Save so can restore if reduced later
	MOVE	T2,(P)		; Get max of new
;*;	TRNN	T2,-1		; ** HACK **		if 0 frame license
;*;	  JRST	SETLC1		; ** HACK **		don't check maximum
	HRL	T2,JBTSLC(J)	;  and old
	PUSHJ	P,MAXLIC	;  frame license
SETLC1:	HRRM	T2,JBTSLC(J)	; Save for ENABLE and DISABLE (* possibly 0 *)
	POP	P,T2		; GET LICENSE HE CAN GET OFF STACK
	EXCH	T2,JBTLIC(J)	; GIVE IT TO HIM
	XOR	T2,JBTLIC(J)	; SEE WHAT CHANGED
	TRNN	T2,-1		; SEE IF HE CHANGED THE FRAME LICENSE
	  POPJ	P,
	MOVEI	T1,14		;RECORD THAT HE SET LICENSE
	PJRST	ACTWRT		;AND RETURN FROM UUO NOSKIP

JOBLIC:	PUSH	P,T2		;SAVE CURRENT LICENSE
	MOVSS	(P)		;IN L.H. KEEP CUR. JOB LIC.
	PUSHJ	P,MAXLIC	;FIND MAX OF JOB AND PROCESS
	HRRM	T2,(P)		;SAVE LICENSE JOB CAN GET
	HLL	T2,-2(P)	;GET DESIRED PROCESS
	PUSHJ	P,LICMSK
	HRLM	T2,-2(P)	;AND SAVE IT
	POP	P,T2		;RESTORE MAX CAN HAVE
	MOVE	T1,JBTLIC(J)	;GET HIS CURRENT LICENSE
	TLNN	T1,LICWCR	;IF HAS WC, LET HIM INCREASE JOB LIC
	  HLRS	T2		; NO, CAN NOT INCREASE JOB LIC
	HRL	T2,-1(P)	;DESIRED JOB LIC
	PUSHJ	P,LICMSK	;WHAT HE CAN HAVE
	TRZ	T2,LICRMT!LICHR	;CAN NOT HAVE HF or HR IN JOB
	HRRM	T2,-1(P)	;RETURN ALLOWED JOB LICENSE
	POPJ	P,

SUBTTL	CHKLIC (CALLI -31) - Check license a job can set

	;CHKLIC UUO. CHECKS ON LICENSE A JOB CAN SET
	;CALL
	;	MOVEI AC,LOC
	;	MOVSI AC,BITS
	;	CALL AC,[SIXBIT /CHKLIC/] OR CALLI AC,-31
	;
	;LOC:	DESIRED LICENSE
	;	PRETEND THIS IS IN LICENSE WORD (SEE BITS)
	;	XOR OF PPN OF USER AND FILE IF SET FOR FILE
	;BITS 1=USE LOC+1 INSTEAD OF JBTLIC
	;     2=SET TO FILE NOT CORE

CHKLIC:	PUSH	P,M
	HRR	M,T1
	MOVE	T3,T1		;SAVE LEFT HALF BITS
	XCTFU	<PUSH P,(M)>
	TLNN	T3,1
	  SKIPA	T2,JBTLIC(J)
	 UMOVE	T2,1(M)
	TLNE	T3,2		;TO FILE?
	  JRST	CKLCFL		;YES
	PUSHJ	P,JOBLIC
	POP	P,T1
	POP	P,M
	UMOVEM	T1,(M)		;STORE IT IN THE USER'S AREA.
	POPJ	P,		;RETURN.


CKLCFL:	HLLZS	T2		;USE ONLY THE PROCESS LIC
	UMOVE	T3,2(M)		;GET THE XOR TO USE
	POP	P,T1
	PUSHJ	P,FILLIC
	  POP	P,M
	UMOVEM	T1,(M)		;STORE T1 IN USER'S AREA.
	POPJ	P,		;RETURN.

EXTERNAL FILLIC
SUBTTL	SETE (CALLI -7) - Set license using system password

	;SETE UUO. TAKES A 2 WORD SYSTEM PASSWORD AND
	;HASHES IT. THEN COMPARES WITH THE NTH ENTRY OF A TABLE
	;IF COMPARES, TABLES HAS WHAT LICENSE MAY BE SET
	;CALL
	;	MOVEI AC,BLOCK
	;	CALL AC,[SIXBIT /SETE/] OR CALLI AC,-7
	;	ERROR RETURN - INCORRECT PASSWORD
	;	NORMAL RETURN

	;BLOCK:	WORD 1 OF PASSWORD
	;	WORD 2 OF PASSWORD
	;	NUMBER OF SYSTEM PASSWORD
	;	LICENSE DESIRED

EXTERNAL SETECD,SETENM,SETELV
;TABLES IN SETE##.MAC DEFINE NAMES,PASSWORDS

SETE:	HRR	M,T1			; Use address portion
	XCTFU <SKIPN T2,3(M)>		; If setting license to 0
	  JRST	ENDHOK			;  Yes, any hash/number ok
	PUSHJ	P,INIRDM		;INITIALIZE
	UMOVE	P1,1(M)			;ONE WORD OF USER HASH
	MOVE	T2,M			; Copy M for -1 comparison (obviously)
	PUSH	P,M
	UMOVE	M,(M)			;THE OTHER HASH WORD
	XCTFU	<SKIPGE 2(T2)>		; If password number -1
	  PUSHJ	P,MOHASH		; Minus One pre-HASHing
	MOVE	T3,[POINT 7,HNMAM]	;MORE CHRS TO HASH
HS3:	ILDB	F,T3
	JUMPE	F,ENDHSH
	PUSHJ	P,LOPRDM
	JRST	HS3

LOPRDM:	ADDM	F,M
	ADDM	F,P3
	MOVEI	F,12
HS2:	MOVE	T1,M(T4)
	MUL	T1,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
	ADDM	T2,P1(T4)
	CAIE	T4,3
	  AOJA	T4,HS1
	MOVE	T4,P4
	ADDM	T4,M
	LSH	T4,-42		;GET HIGH 2 BITS FOR NEW INDEX
HS1:	SOJG	F,HS2
	POPJ	P,

INIRDM:	MOVE	T1,[XINIT,,P2]
	BLT	T1,P4
	MOVEI	T4,0
	POPJ	P,

INTERNAL INIRDM,LOPRDM
ENDHSH:	MOVE	P4,M		;SAVE HASH RESULT
	POP	P,M
	XCTFU  <SKIPGE T1,2(M)>	;GET PASSWORD NUMBER, Skip if positive
	  SETO	T1,		; Make any negative = -1
	CAIL	T1,SETENM
	  POPJ	P,		;TOO BIG, ERROR RETURN
	MOVEI	T2,STRDDB##	;Check if the
	MOVE	T2,STRBTS##(T2)	; system structure
	TRNE	T2,SRPREF##	; has been refreshed
	 JUMPL	T1,ENDROK	;Yes, ignore hash check if SETE -1
	CAME	P4,SETECD(T1)	;GET PASSWORD
	  POPJ	P,		;WRONG
ENDROK:	MOVE	T2,SETELV(T1)	;MAX HE CAN HAVE
	XCTBU	<HRL T2,3(M)>
	PUSH	P,T1		; Save for check later
	PUSHJ	P,LICMSK
	POP	P,T1		; Restore saved password number
	JUMPGE	T1,ENDHOK	; SETE -1 for refresh recovery?
	  HRLM	T2,JBTLIC(J)	; Yes, make license process only
	  HRLM	T2,JBTSLC(J)
	  JRST	ENDAOK
ENDHOK:	TRZ	T2,LICRMT!LICHR	; Clear HF and HR in frame license
	HRRM	T2,JBTLIC(J)
	HRRM	T2,JBTSLC(J)	;Save as current max frame license
ENDAOK:	MOVEI	T1,15
	PUSHJ	P,ACTWRT
	JRST	CPOPJ1		;GOOD RETURN


MOHASH:	XOR	P1,[SIXBIT/OPER/]	; Username OPER
	XOR	P1,JBTUNM(J)		; Undo user name
	XOR	P1,JBTAUN(J)		;  and logged-in ppn

	XOR	M,THSDAT##		; Today from CNFTBL(11)
	XOR	M,JBTUN1(J)		; Harmful to long user names
	XOR	M,JBTPPN(J)		;  must be GFD'd correctly
	POPJ	P,


XINIT:	555555555555
	361275431652
	555555555555

HNMAM:	ASCIZ /TYMSHR/

SUBTTL	SETMAI, SETMAL - Mail waiting

WAITCH:	MOVEI W,-1
	PJRST TTYUUO

GETTMC:	MOVEI W,-2
	PJRST TTYUUO

SETTMC:	MOVEI W,-3
	PJRST TTYUUO

REDNXT:	MOVEI W,-4
	PJRST TTYUUO

LEVDEF:	MOVEI W,-5
	PJRST TTYUUO

SETMAI:	MOVE	T1,JBTLIC(J)
	TLNN	T1,LICOPR	; require OP in process license
	 POPJ	P,
	UMOVE	T1,(M)		; job number to set
	SKIPLE	T1		; leq 0 illegal
	 CAIL	T1,JOBN		; geq JOBN illegal
	  POPJ	P,
	MOVE	T2,JBTSTS(T1)
	TLNN	T2,JLOG		; not logged in illegal
	 POPJ	P,
	HRLZI	T2,PVNMAI	; [new mail] bit in priv word
	IORM	T2,JBTPRV(T1)
	AOS	(P)
	POPJ	P,

SETMAL:	MOVE T2,SYSPPN
	MOVEI T1,FNCDEL
	MOVEI T4,077
	PUSHJ P,CHKPRJ		;SEE IF CAN WRITE ON THE MAILBOX
	 SKIPA			;YES
	  POPJ P,		;ERROR RETURN
	UMOVE T1,(M)		;GET ADDRESS FROM USER AREA.
	HRR M,T1		;SET TO GET USER NAME
	UMOVE T1,(M)		;GET ARGUMENT FROM USER AREA.
	MOVE T2,T1
	HRRI M,1(M)		;INCREMENT POINTER TO USER AREA.
	UMOVE T1,(M)		;AND FETCH ARGUMENT.
	MOVE P1,HIGHJB
NXMAL:	JUMPE T2,FNDMAL		;ALL USERS
	CAMN T2,JBTUNM(P1)
	CAME T1,JBTUN1(P1)
	JRST NOMAL		;NOT FOR HIM
FNDMAL:	PUSH P,T1
	MOVEI T1,PVMAIL		; BIT TO SET IN PRIV WORD
	IORM T1,JBTPRV(P1)
	POP P,T1
NOMAL:	SOJG P1,NXMAL
	POPJ P,

EXTERNAL FNCDEL,CHKPRJ
SUBTTL	SYSDVF (CALLI -24) - Get device info

;Call:	MOVE	AC,[LEN,,ADR]
;	SYSDVF	AC,		;CALLI -24
;	  error return
;	success return
;ADR+0/	function (see SYDDSP)
;ADR+1/	previous device (zero to start at beginning of chain
;ADR+2/	BLOCK LEN-2	;DDB or buffer size is returned here
;ADR+3/			;First word of DDB or buffer is returned here

SYSDVF:	HRRM	T1,M		;RH of AC has address of block
	HLRZ	P1,T1		;LH of AC has size of block
	SOSG	P1		;Not counting function word
	 MOVEI	P1,1		;Must be at least 2
	UMOVE	T3,(M)		;Get function code
	HRRZ	T1,T3		;Watch out for sign bit set in code
	CAIL	T1,SYDTBL	;Check if in range
	 POPJ	P,
	SKIPE	SYDDSP(T1)	;Routing may be external
	 JRST	@SYDDSP(T1)
	POPJ P,			;Function not implemented on this machine

SYDDSP:	SYDNAM			;0  DDB by name (excluding TTY and DSK)
	SYDLOC			;1  DDB by location, all DDBs
	SYDUNI##		;2  Disk unit (in FILUUO)
	SYDSTR##		;3  Structure (in FILUUO)
	SYDFTA##		;4  FTA unit  (in FTASER on KI and KL)
	SYDTMX##		;5  MTA unit  (in MAGSER or F3TSER)
	SYDBUF			;6  Named buffer (new in P035/C04)
	SYDJBT			;7  GETTAB table (new in P035/C04)
	SYDSPY			;10 SPY/PEEK on block of memory (/C08)
SYDTBL==.-SYDDSP
;SYSDVF function 0 - DDB by name

SYDNAM:	HRRI	M,1(M)		;Increment pointer to user's area
	UMOVE	T1,(M)		;Pick up name of previous device
	HLRZ	U,DEVLST	;Start of DDB chain
	MOVSI	T2,DVDSK!DVTTY!DVRMT	;Don't give info about these
	JUMPE	T1,SYDNM1	;Zero means asking for first device
SYDNM3:	TDNN	T2,DEVMOD(U)	;Excluded device?
	CAME	T1,DEVNAM(U)	; or not there yet?
	 SKIPA			;Yes, keep looking
	  JRST	SYDNM2		;Found where we left off last time
	HLRZ	U,DEVSER(U)	;Point to next DDB
	JUMPN	U,SYDNM3	; if any
	POPJ	P,		;Bad starting name, give error return

SYDNM2:	SKIPL	T3		;This device if 1B0 set
	 HLRZ	U,DEVSER(U)	;First device after requested one
	JUMPE	U,SYDNM4	;Out of devices, store 0 and skip return
SYDNM1:	MOVE	T2,DEVMOD(U)	;Is is a good device?
	TLNE	T2,DVTTY!DVDSK!DVRMT
	 JRST	SYDNM2		;No, skip it
	EXCH	F,U		;For PJOBN
	LDB	J,PJOBN
	EXCH	F,U
	PUSHJ	P,CHKSEG	;SEE IF CAN GET INFO ABOUT THIS JOB
	 JRST	SYDNM2		;NO, SAY NOTHING ABOUT DEVICE
	MOVE	T1,DEVNAM(U)
	UMOVEM	T1,(M)		;Store name of device for next time
SYDLC5:	SOJLE	P1,CPOPJ1	;DOES HE WANT ANY MORE?
	HRRI	M,1(M)		;INCREMENT PTR TO USER'S AREA.
	HRRZ	T1,DEVSER(U)
	XCT	DVSIZ(T1)	;GET THE DDB SIZE
	PFALL	SYDCOM		;Join common code
;Here to return data to user.
;Source:      T1 has size of DDB, U has address of DDB
;Destination: P1 has # of words left, M has UADDR+2 (where count is returned)
;If P1 has 1, then only the count is stored.

SYDCOM::UMOVEM	T1,(M)		;RETURN SIZE TO USER
	CAILE	P1,1(T1)	;GET MIN OF REQUESTED AND AVAILABLE
	 MOVEI	P1,1(T1)	;1(T1)SINCE WE SOJLE FIRST
SYDNM5:	SOJLE	P1,CPOPJ1	;DONE
	ADDI	M,1		;POINT TO FIRST WORD FOR DDB ETC
	ADD	P1,M
	HRL	M,U		;GET THE BLT SET UP
	XCTTU <BLT M,-1(P1)>	;GIVE TO USER
	JRST	CPOPJ1

;Here from SYDFTA,etc when at end of list

SYDNM4::XCTBU  <SETZM (M)>	;End of DDB chain, zero to start over again
	SOJLE	P1,CPOPJ1	;Done if no room for data block
	XCTBU  <SETZM 1(M)>	;Zero first word (at ADR+3)
	JRST	CPOPJ1		;Skip return at end of chain

;SYSDVF function 1 - DDB by location, all DDBs

SYDLOC:	HRRI	M,1(M)		;INCREMENT PTR.
	UMOVE	T1,(M)		;AND GET NEXT ENTRY.
	HLRZ	U,DEVLST
	JUMPE	T1,SYDLC1
SYDLC3:	CAIN	T1,(U)
	 JRST	SYDLC2		;FOUND
	HLRZ	U,DEVSER(U)
	JUMPN	U,SYDLC3
	POPJ	P,		;NOT IN LIST (MAYBE DSK GONE AWAY)

SYDLC2:	SKIPL	T3		;This device if 1B0 set
	 HLRZ	U,DEVSER(U)	;Else get next one
	JUMPE	U,SYDNM4
SYDLC1:	EXCH	F,U		;FOR PJOBN
	LDB	J,PJOBN
	EXCH	F,U
	PUSHJ	P,CHKSEG
	  JRST	SYDLC2
	UMOVEM	U,(M)
	JRST	SYDLC5
;SYSDVF function 6 - named buffer

SYDBF0:	0
	.ELINK 2,SYDBF0		;Set up link (see SYDVF macro)
;The RH of SYDBF0 points to the start of a linked list.  The list format is:
;THIS: XWD -N,NEXT	;# of pairs, pointer to next
;      SIXBIT /NAME/	;Name of this part of the buffer
;      XWD SIZE,NAME	;Size and starting address
;      SIXBIT /NAM2/	;More pairs if buffer is in multiple parts
;      XWD SIZ2,NAM2	; ... (N in LH of THIS is count of pairs)

SYDBUF:	MOVSI	T1,LICSYS!LICSPY;Job must have SYSTAT license to see
	TDNN	T1,JBTLIC(J)	; any of these tables
	  POPJ	P,		;Nope, give error return
	HRRI	M,1(M)		;Increment pointer to user's area
	UMOVE	T1,(M)		;Pick up name of previous buffer
	HRRZ	U,SYDBF0	;Start of list
SYDBF1:	JUMPE	U,SYDBF4	;Error return if name not found
	HLLZ	T4,(U)		;Get minus number of pairs
	HRRI	T4,1(U)		;Point to first
SYDBF2:	SKIPE	T1		;Zero matches first name
	CAMN	T1,0(T4)	;Match name?
	 JRST	SYDBF5		;Found starting point
SYDBF3:	ADDI	T4,1		;No, skip SIZE,,ADDR
	AOBJN	T4,SYDBF2	;Try next name in this set
	HRRZ	U,(U)		;Get pointer to next
	JRST	SYDBF1		;Try next set

;Here if current not found or no next one
SYDBF4:	JUMPE	T1,SYDNM4	;Store zero if no next one
	POPJ	P,		;Error return if this one not found

SYDBF5:	JUMPE	T1,SYDBF6	;Use first one if user supplied zero
	JUMPL	T3,SYDBF6	;Use this one if 1B0 is set
	MOVEI	T1,0		;Give us the next one
	JRST	SYDBF3		;Go find it

SYDBF6:	MOVE	T1,0(T4)	;Found it, get starting name
	UMOVEM	T1,(M)		;Store at UADDR+1
	SOJLE	P1,CPOPJ1	;Room for any more?
	HRRI	M,1(M)		;Yes, point to UADDR+2
	MOVE	U,T4		;Save pointer in U for SYDBF8
	MOVEI	T3,0		;Accumulate count
SYDBF7:	HLRZ	T1,1(T4)	;Get size
	ADDI	T3,2(T1)	;Include word for name and word for pointer
	ADDI	T4,1
	AOBJN	T4,SYDBF7
	UMOVEM	T3,(M)		;Store total size in UADDR+2

;Loop thru and return all related buffers.  U has AOBJN pointer to descriptors
;P1 has # of words remaining, M points to previous returned word

SYDBF8:	SOJLE	P1,CPOPJ1	;Room for any more?
	HRRI	M,1(M)		;Next word in
	MOVE	T1,0(U)		; user's buffer
	UMOVEM	T1,(M)		; gets name
	SOJLE	P1,CPOPJ1
	HRRI	M,1(M)		;Next word in
	MOVE	T1,1(U)		; user's buffer
	UMOVEM	T1,(M)		; gets count,,addr
	JUMPLE	P1,CPOPJ1	;See if room for more
	HLRZ	T1,1(U)		;Size of buffer
	CAMLE	T1,P1		;Is user's argument block big enough?
	 MOVE	T1,P1		;No, use smaller
	HRLZ	T2,1(U)		;First source address
	HRRI	T2,1(M)		;First destination address
	ADD	M,T1		;Last destination address
	XCTTU <BLT T2,(M)>	;Copy to user
	SUB	P1,T1		;Decrement word count
	ADDI    U,1		;Go to next pair
	AOBJN	U,SYDBF8	; of descriptors
	JRST	CPOPJ1

;SYSDVF function 7 - GETTAB table

SYDJBT:	MOVSI	T1,LICSYS!LICSPY;Job must have SYSTAT license to see
	TDNN	T1,JBTLIC(J)	; any of these tables
	 POPJ	P,		;Nope, give error return
	HRRI	M,1(M)		;Increment pointer to UADDR+1
	UMOVE	T1,(M)		;Pick up gettab table number
	HRRE	T2,T1		;IN CASE NEGATIVE
	ADDI	T2,NUMTAB
	CAIG	T2,ENDGTB
	CAIGE	T2,MINTAB	;IS IT IN RANGE
	 POPJ	P,		;YES. ERROR RETURN, AC UNCHANGED
	MOVE	U,T2		;Get addr of table
	SOJLE	P1,CPOPJ1	;Continue if room to return count
	HRRI	M,1(M)		;Point to UADDR+2
;	LDB	T1,SIZE.OF.TABLE  ;U has address
;	PJRST	SYDCOM
PRINTF (<[SYDJBT not fully implemented yet]>)
	POPJ	P,		;Error return

;SYSDVF function 10 - GETTAB table

SYDSPY:	MOVSI	T1,LICSPY	;Job must have read-core license to see
	TDNN	T1,JBTLIC(J)	; any of these tables
	 POPJ	P,		;Nope, give error return
	HRRI	M,1(M)		;Increment pointer to UADDR+1
	UMOVE	U,(M)		;Get address (1B0 set for exec virtual address)
	SOJLE	P1,CPOPJ1	;Continue if room to return count
	HRRI	M,1(M)		;Point to UADDR+2
	HRRZ	T1,P1		;Size is what user asked for
;T1=size, U=mon.addr, P1=size, M=user.addr
	JUMPL	U,SYDCOM	;Return block if virtual address
	MOVEI	T2,-1(T1)	;Physical address - calculate ending address
	ADD	T2,U
	CAIGE	T2,340000	;Is it part of the one-for-one area?
	 JRST	SYDCOM		;Yes, physical equals virtual
PRINTF (<[SYDSPY does not handle physical addresses above 340000]>)
	JRST	SYDCOM		;*HACK* (need to change map of %COW)
;RETURN JOB NUMBER FOR THIS JOB

JOBNO:	UMOVEM	J,(M)		;CALLI +30
	POPJ	P,		;RETURN JOB NUMBER

;RETURN JOB RUNNING TIME IN MILLISECONDS

JOBTIM:	SKIPL	T1		;CALLI +27
	CAILE	T1,JOBN##
	 JRST	RTZER
	SKIPN	J,T1		;GET JOB NUMBER DESIRED
	MOVE	J,JOB		;CURRENT JOB
	PUSHJ	P,CHKSEG	;SEE IF LEGAL
	 JRST	RTZER		;NO
	PUSHJ	P,TIMADJ	;READ CLOCK
	PUSHJ	P,CLKTRU	;GET TRU'S
	UMOVEM	T1,(M)		;MOVE INFO TO USER'S AREA.
	POPJ	P,		;AND RETURN.
;PEEK INTO MONITOR MUUO
;CALL	MOVEI	AC,<MONITOR ADDRESS>
;	CALL	AC,[SIXBIT .NPEEK.]
;IF AC BIT 0=1 DO VIRTUAL PEEK ELSE PHYSICAL

	EXTERN MEMSIZ,UPSJOB

NPEEK:	MOVSI T2,LICSPY
	TDNN T2,JBTLIC(J)	;CAN HE DO IT?
	POPJ P,			;NO. TAKE ERROR RETURN
	JUMPL T1,UPEEK1		;JUMP IF VIRTUAL PEEK DESIRED
	PUSHJ P,PEKCHK		;CHECK ADDRESS VALIDITY
	 POPJ P,		;ADDRESS INVALID, ERROR RETURN
	MOVE	T1,%UPS(T1)
UPEEK3:	UMOVEM T1,(M)		;MOVE TO USER'S AREA
	JRST CPOPJ1		;AND RETURN
IFCPU (KI),<
UPEEK1:	MAP T2,(T1)		;SEE IF ADDR IS READALBE WITHOUT FAULT
	TRC T2,MAP.FL!MAP.M	;PG IS READABLE IF FL AND MUUO
	TRNN T2,MAP.FL!MAP.M	;BOTH NOT SET
	 POPJ P,		;PAGE NOT READABLE
>;END IFCPU (KI)
IFNCPU (KI),<
UPEEK1:	TRNN T1,-20		;CHECK IF ADDR POINTS TO AN AC
	 JRST UPEEK2		;AC POINTED TO, SO ADDR OK
	MAP T2,(T1)		;SEE IF ADDR IS READABLE WITHOUT FAULT
	TLNN T2,PFW.A		;READABLE IF PG IS ACCESSIBLE
	 POPJ P,			;PAGE NOT READABLE
>;END IFNCPU (KI)
UPEEK2:	MOVE T1,(T1)		;FETCH REQUESTED WORD
	JRST UPEEK3		;FINISH UP

;OLD PEEK. SAME AS NPEEK EXCEPT RETURNS ZERO IF UNSUCCESSFUL
;AND HAS ONLY ONE RETURN POINT.

UPEEK:	PUSHJ P,NPEEK		;ATTEMPT THE PEEK
	 JRST RTZER		;ERROR: RETURN 0
	POPJ P,			;SUCCES

;POKE MUUO CALL
;MOVEI AC,D
;CAL AC,[SIXBIT /POKE/]
; D/  DATA TO STORE
; D+1/ LOC TO STORE INTO
;      WITH SIGN BIT=1 FOR VIRTUAL POKE, 0 FOR PHYSICAL

POKE:	MOVSI T2,LICWCR	;HAVE PRIV
	TDNN T2,JBTLIC(J)
	 POPJ P,			;NO, ERROR RETURN
	UMOVE T4,(T1)		;GET VALUE TO POKE FROM USER
	UMOVE T1,1(T1)		;GET ADDRESS TO POKE AT
	JUMPL T1,POKE1		;JUMP IF VIRTUAL POKE DESIRED
	PUSHJ P,PEKCHK
	  POPJ P,
	MOVEM T4,%UPS(T1)
	JRST CPOPJ1

POKE1:	PUSHJ P,POKCHK		;SEE IF VIRTUAL POKE LEGAL
	  POPJ P,		;BAD ADDR, ERROR RETURN
	MOVEM T4,(T1)		;POKE REQUESTED WORD
	JRST CPOPJ1		;AND RETURN

PEKCHK:	TLZ T1,400000	;CLEAR SIGN BIT
	MOVE PG,T1	;GET ABSOLUTE ADDRESS
	JUMPL PG,CPOPJ	;BAD IF NEGATIVE
	CAIL PG,20	;BAD IF IN AC'S (PHYSICAL ONLY)
	 CAML PG,MEMSIZ	;BAD IF NO MEMORY THERE
	  POPJ P,	;ERROR RETURN - DON'T MAP IT
	LSH PG,-11	;GET BLOCK NUMBER
	LDB T3,PGYNXM	;DOES BLOCK EXIST?
	CAIL PG,340	;SKIP IF IN UNMAPPED AREA
	 JUMPN T3,CPOPJ	;NO. ERROR
	TRO PG,PGE.P!PGE.A!PGE.W
			;NO CACHE BIT, OR ELSE CAN DRAG AREA INTO CORE
			;THAT SHOULD NOT BE CACHED!
	MOVE T3,EPYPSN	; From [EPTPTR(%UPS.N)]
	DPB PG,T3
	SETZM UPSJOB		;NO REAL UPT MAPPED THRU HERE ANYMORE
	CLRPTO	%UPS		;SETUP UPS SLOT IN MAP TO POINT TO BLOCK
	ANDI T1,777		;T1_OFFSET IN BLOCK
	JRST CPOPJ1	;EITHER WRITE OK OR READ OK

IFCPU (KI),<
POKCHK:	MAP T2,(T1)	;SEE IF ADDR IS WRITEABLE WITHOUT FAULT
	TRNE T2,MAP.FL	;SKIP IF WRITEABLE
	POPJ P,		;ERROR RETURN
	JRST CPOPJ1	;SKIP RETURN
>;END IFCPU (KI)
IFNCPU (KI),<
POKCHK:	TRNN T1,-20	;CHECK IF ADDR POINTS TO AN AC
	JRST CPOPJ1	;AC POINTED TO, SO ADDR GOOD
	MAP T2,(T1)	;SEE IF ADDR IS WRITEABLE WITHOUT FAULT
	TLC T2,PFW.A!PFW.W	;PG IS WRITEABLE IF A & W BOTH NOT SET
	TLNE T2,PFW.A!PFW.W	;SKIP IF WRITEALBE
	POPJ P,		;ERROR RETURN
	JRST CPOPJ1	;SKIP RETURN
>;END IFNCPU (KI)
;BITPOK	UUO
;CALL:
;	MOVE AC,FOO
;	BITPOK AC,
;	  <ERROR>
;	<NORMAL>
;
;FOO:	<ADDRESS>
;	<ANDCAM WORD>
;	<IORM WORD>
;
;WITH SIGN BIT OF <ADDRESS>=1 FOR VIRTUAL POKE, 0 FOR PHYSICAL

;ON SUCCESS, IF (RC) LICENSE, (AC):=OLD VALUE OF <ADDRESS>

BITPOK:	MOVSI T2,LICWCR		; CHECK FOR WC LICENSE
	TDNN T2,JBTLIC(J)
	 POPJ P,
	HRR T4,T1		; USER ADDRESS OF ARGUMENTS
	UMOVE T1,(T4)		; GET PHYS ADR FROM USER
	JUMPL T1,[PUSHJ P,POKCHK	;SEE IF POKE LEGAL
		   POPJ P,		;BAD ADDR, ERROR RETURN
		  MOVE  T3,(T1)		;GET OLD VALUE TO RETURN
		  JRST  BITPK1]		;PROCEED
	PUSHJ P,PEKCHK		; SEE IF VALID
	 POPJ P,		;  BAD ADR - ERROR RETURN
	MOVE T3,%UPS(T1)	; GET OLD VALUE TO RETURN
BITPK1:	MOVSI T2,LICSPY		; SEE IF WE SHOULD RETURN OLD VALUE
	TDNE T2,JBTLIC(J)
	 UMOVEM T3,(M)		;  RETURN OLD VALUE IN AC (IF RC LIC)
	UMOVE T2,1(T4)		; GET ANDCAM WORD FROM USER
	UMOVE T3,2(T4)		; GET IORM WORD FROM USER
	JUMPL T1, [ANDCAM T2,(T1)	;CLEAR BITS AS NECESSARY
		   IORM T3,(T1)		;SET BITS AS NECESSARY
		   JRST CPOPJ1]		;NORMAL RETURN
	ANDCAM T2,%UPS(T1)	; CLEAR BITS AS NECESSARY
	IORM T3,%UPS(T1)	; SET BITS AS NECESSARY
	JRST CPOPJ1
;TRPSET UUO - SET USER IOT

;CALL	SETZ AC,	OR	SETO AC,
;	TRPSET AC,
;	  <NO WC LICENSE>
;	<OKAY>

UTRPST:	MOVSI T2,PC.UIO		; CLEAR IT ALWAYS
	ANDCAM T2,PDNMUP(P)
	MOVSI T3,LICWCR		; TEST WC LICENSE
	TDNN T3,JBTLIC(J)
	  POPJ P,		; NO LIC - ERROR RETURN
	JUMPE T1,CPOPJ1		; WANTS IT OFF (ALREADY IS)
	JUMPG T1,CPOPJ		; CAN'T HAVE POSITIVE ARGUMENT
	IORM T2,PDNMUP(P)	; SET U-IOT AND GO HOME
	JRST CPOPJ1
SUBTTL	Date/Time uuos

;Get universal date/time GMT
;	MOVE	ac,[%CNDTM]	;53,,11
;	GETTAB	ac,
;	  MOVEI	ac,0		;Always skips if after P034/P
;	MOVEM	ac,UDT		;Days since 18-Nov-1858,,fraction of a day
;				;Note: Day 0 (17-Nov-1858) was a Wednesday
;
;Get universal date/time local to the CTY
;	MOVE	ac,[%CNGMT]	;64,,11
;	GETTAB  ac,
;	  MOVEI	ac,0		;Always skips if after P034/P
;	ADD	ac,UDT		;Offset from GMT to CTY local time


;Return GMT in TYMSHARE format, T1/time, T2/date

GETGMT::MOVE	T2,THSDAT##	;Day 0 was 1-Jan-1964
	MOVE	T1,TIME##	;Ticks since midnight
	CAME	T2,THSDAT##	;Watch out for midnight!
	 JRST	GETGMT
	TLZ	T1,(1B0)	;Clear half-valid bit
	POPJ	P,		;1B0 set in T2 if date has not been set

;Get the date in DEC format of (YEARS-1964)*12*31 + (MONTH-1)*31 + DAY-1
;	DATE	ac,		;CALLI +14
;	 <only return>

DATEU:	PUSHJ	P,GETULT	;Get user local time and date in DEC format
	  SETZB	T1,T2		;Date not set, return 1-Jan-1964
	UMOVEM	T2,(M)		;Days since 1-Jan-1964 in DEC format
	POPJ	P,


;Get the time of day in jiffies since local midnight (60 jiffies per second)
;	TIMER	ac,		;CALLI +22
;	 <only return>

TIMER:	PUSHJ	P,GETULT	;Get user local time and date in DEC format
	  SETZB	T1,T2		;Date not set, return midnight
	UMOVEM	T1,(M)		;Jiffies since midnight local time
	POPJ	P,


;Get the time of day in milliseconds since local midnight
;	MSTIME	ac,		;CALLI +23
;	 <only return>

MSTIME:	PUSHJ	P,GETULT	;Get user local time and date in DEC format
	  SETZB	T1,T2		;Date not set, return midnight
	IMULI	T1,^D1000	;1000 milliseconds per second
	IDIV	T1,JFYSEC##	;Convert from JIFFIES*1000 to milliseconds
	UMOVEM	T1,(M)		;Milliseconds are correct for 50Hz and 60Hz
	POPJ	P,


;Get elapsed time since 1/1/64 00:00 in seconds
;	MOVEI	ac,time-zone	;0 for user's local time zone
;	DAYTIM	ac,		;CALLI -143
;	 <only return>

DAYUUO:	PUSHJ	P,GETGMT	;Get Tymshare date and time in T2 and T1
	UMOVE	P4,(M)		;Get desired time zone (6 bits)
	TRO	P4,600000	;Request 1-word Tymshare seconds format
	HRLI	P4,400020	; from GMT 2-word Tymshare format
	PUSHJ	P,DATCOM	;Convert the date
	  SETZB	T1,T2		;Date not set
	UMOVEM	T2,(M)		;Return seconds since 1-Jan-1964 00:00
	POPJ	P,

SUBTTL	DATUUO - Convert date formats

;	MOVEI	ac,LOC		;Point to 3-word block
;	DATUUO	ac,		;CALLI -55
;	  <error return>	;Negative dates not allowed
;	<success return>	;First 2 words of block modified
;
;LOC:	DATE		;Or SECONDS or DATE,,TIME or -1 for current time
;	TIME		;Jiffies since midnight (ignored on 1-word formats)
;	FROM,,TO	;See bits below


DATUUO:	MOVE	M,T1	;User's AC has address of 3-word block
	UMOVE	T1,1(M)	;Time
	UMOVE	T2,0(M)	;Date or date&time in 1 word
	UMOVE	P4,2(M)	;Use <400020,,0> to convert TYM-GMT to DEC-local
	PUSHJ	P,DATCOM
	  POPJ	P,	;Negative dates other than -1 are not legal
	UMOVEM	T1,1(M)	;Time
	UMOVEM	T2,0(M)	;Date or date&time in 1 word
	JRST	CPOPJ1	;Success


;FROM and TO formats: 1B0=TYM format, 1B1=1-word/seconds, 1B2=1-word/halfwords
;	0000xx	DEC 2-word format;   (YR-64)*372+(MN-1)*31+(DY-1), tics
;	1000xx	DEC halfword format; days since 11/18/1858,,fraction of day
;	2000xx	DEC seconds format;  DECdays*86400 + seconds past midnight
;	4000xx	TYM 2-word format;   days since 1/1/64, tics since midnight
;	5000xx	TYM halfword format; days since 1/1/1964,,fraction of day
;	6000xx	TYM seconds format;  seconds since 1/1/64 00:00
;	    xx	Time zone code, 0 means user local time
;	    40	Subject to daylight savings, 50=PDT,51=MDT,52=CDT,53=EDT
;		20=GMT,21=Paris,31=Toyko,    10=PST,11=MST,12=CST,13=EST,14=AST

;Get user local time in T1 and date in DEC format in T2
;Error return if date has not been received from the supervisor yet

GETULT::PUSHJ	P,GETGMT	;Get THSDAT and TIME
	JUMPLE	T2,CPOPJ	;Error return, date not set
	MOVSI	P4,400020	;From GMT days to DEC format, user's time zone
	PFALL	DATCOM		;Convert and skip return


;Subroutine DATCOM - convert date formats.
;  T1/time in tics since midnight GMT (2-word formats only)
;  T2/date or combined date and time
;  P4/conversion options
;  J/job number to get user's local time zone
;Uses T3 and T4


DATCOM::CAMN	T2,[-1]		;If -1,
	 PUSHJ	P,GETGMT	; use current date/time
	JUMPL	T2,CPOPJ	;Other negative dates not legal
	LDB	T3,PVYTIM##	;Get user's time zone from JBTPRV(J)
	SKIPN	T3
	 MOVEI	T3,50		;If none, assume PDT
	TRNN	P4,37
	 TRO	P4,(T3)		;Set zones if not specified
	TLNN	P4,37
	 TLO	P4,(T3)

	LDB	T3,[POINT 3,P4,2] ;Get format code from LH
	XCT	DATCNV(T3)	;Convert to days in T2, ticks in T1

;1 day = 24 hours = 1440 minutes = 86400 seconds = 5184000 ticks (60 Hz)
;octal = 30       = 2640          250600          23615000 (23 bits)
;The date format in the RIB is 14 bits, from 1-Jan-1964 to 8-Nov-2008
; 2^14 = 16384 days = 44.85 years, 1964+44.85 = 2008.85 = 8-Nov-2008

	PUSH	P,T2		;Save date on stack, jiffies in T1
	IDIV	T1,JFYHR##	;T1/hours, T2/ticks since start of hour
	EXCH	T2,(P)		;T2/date, (P)/min-sec-jif
	IMULI	T2,^D24		;Convert days to hours
	ADD	T1,T2		;T1/hours since 1-Jan-1964
	TLNN	P4,40		;"from" time subject to daylight savings?
	 JRST	NODST1		;No
	PUSHJ	P,DSTCHK	;Yes, was daylight savings in effect then?
	  SUBI	T1,1		;Yes, convert "from" time to standard time
NODST1:	HLRZ	T2,P4
	ANDI	T2,37		;Time zone of source
	SUB	T1,T2		;Convert time to hours GMT
	MOVE	T2,P4
	ANDI	T2,37		;Time zone of destination
	ADD	T1,T2		;Convert to new local standard time
	TRNN	P4,40		;"to" time subject to daylight savings?
	 JRST	NODST2		;No
	PUSHJ	P,DSTCHK	;Yes, will daylight savings be in effect?
	  ADDI	T1,1		;Yes
NODST2:	POP	P,T3		;T1/date, T3/tics
	JUMPL	T1,CPOPJ	;Error if negative hours
	IDIVI	T1,^D24		;T1/days, T2/hours since midnight
	IMUL	T2,JFYHR##	;Convert hours to ticks
	ADD	T2,T3		;Add ticks since start of hour
	EXCH	T1,T2		;T1/tics, T2/date

	LDB	T3,[POINT 3,P4,18+2] ;Get format code from RH
	XCT	CNVDAT(T3)	;Convert from TYMSHARE format to other

	JRST	CPOPJ1		;Success

;Table to convert from input format to TYMSHARE format (T1/ticks, T2/days)

DATCNV:	PUSHJ	P,DEC2YR	;0 Adjust T2, DEC 31*12 day year to 365 day year
	PUSHJ	P,UDT2YR	;1 Convert from UDT to TYM format
	PUSHJ	P,SEC2YR	;2 Divide by 86400 seconds and then DEC2YR
	POPJ	P,		;3 Illegal
	JFCL			;4 Already in TYM 2-word format
	PUSHJ	P,TDT2YR	;5 Convert from TDT to TYM format
	PUSHJ	P,SEC2JF	;6 Divide by 86400 seconds per day
	POPJ	P,		;7 Illegal

;Convert to TYMSHARE format (date in T2, ticks in T1)

SEC2JF:	IDIV	T2,[^D60*^D60*^D24];T2/date T3/secs
	IMUL	T3,JFYSEC##	;T2/date T3/tics
	MOVE	T1,T3		;T1/tics T2/date
	POPJ	P,

UDT2YR:	SUB	T2,GMTUDT##	;Days since 1/1/64 in LH, fraction in RH
TDT2YR:	HLRZ	T1,T2		;Days in T1
	HRRZ	T2,T2		;<fraction.of.day>*2^18 in T2
	MUL	T2,MIDNIT##	;T2&T3/tics*2^18
	ADDI	T3,400000	;Round up to nearest tic
	ASHC	T2,^D17		;T2/tics, T3/0  (only 17 bits in LH of T3)
	EXCH	T1,T2		;T1/tics, T2/date
	POPJ	P,

SEC2YR:	PUSHJ	P,SEC2JF	;Split seconds in T2 to day in T2 and tic in T1
DEC2YR:	IDIVI	T2,^D31		;Convert DEC's 12*31 format to consecutive days
	PUSH	P,T3		;T2/# of 31-day months, (P)/day-1
	IDIVI	T2,^D12		;T2/year-1964, T3/month-1, (P)/day-1
	MOVE	T3,MONTB(T3)	;Day corresponding to the first of the month
	TRNE	T2,3		;Is it a non-leap year?
	CAIGE	T3,^D60		;And after Feb 28th?
	 SKIPA			;No
	  SUBI	T3,1		;Yes, compensate for missing Feb 29th
	ADDM	T3,(P)		;(P)/days since start of year
	MOVEI	T3,3(T2)	;Year (rounded up)
	LSH	T3,-2		;Divide by 4 to get # of leap days since 1964
	IMULI	T2,^D365	;Convert years to days
	ADD	T2,T3		;Add in leap days
	ADDM	T2,(P)		;Add in day of year
	JRST	T2POPJ		;T2 has consecutive days since 1-1-64, T1/ticks

MONTB:	DEC 0,31,60,91,121,152,182,213,244,274,305,335,366

;Table  to convert from TYMSHARE format (T1/ticks, T2/days) to desired format

CNVDAT:	PUSHJ	P,YR2DEC	;0 Adjust T2, DEC 31*12 day year to 365 day year
	PUSHJ	P,YR2UDT	;1 Convert from TYM to UDT format
	PUSHJ	P,YR2SEC	;2 YR2DEC then multiply by 86400 seconds per day
	POPJ	P,		;3 Illegal
	JFCL			;4 User wants TYM 2-word format T2/date, T1/time
	PUSHJ	P,YR2TDT	;5 Convert from TYM to TDT format
	PUSHJ	P,JF2SEC	;6 Multiply by 86400 seconds per day
	POPJ	P,		;7 Illegal

;Convert from TYMSHARE format (date in T2, ticks in T1)

YR2UDT:	PUSHJ	P,YR2TDT	;First convert to UDT based on 1-Jan-1964
	ADD	T2,GMTUDT##	;Make LH days since 18-Nov-1858
	POPJ	P,

;ADJUDT - Convert from TIME and THSDAT to universal date/time format

ADJUDT::MOVE	T1,TIME##	;Get jiffies since midnite
	MOVE	T2,THSDAT##	;Days since 1-Jan-1964
	PUSHJ	P,YR2TDT	;Convert to days,,fraction (LSB=0.3296 seconds)
	ADD	T2,GMTUDT##	;Change reference date to 18-Nov-1858
	MOVEM	T2,DATE##	;Set UDT (GETTAB item 53 in table 11 = %CNDTM)
	POPJ	P,		;Return with UDT in T2

YR2TDT:	SETZ	T3,		;Convert to UDT based on 1-Jan-1964
	PUSH	P,T4		;T1/ticks, T2/TYM date, uses T3, preserves T4
	MOVE	T4,T1		;Jiffies since midnight
	ASHC	T3,^D18		;T3&T4/ jiffies * 2^18
	MOVE	T1,MIDNIT##	;Ticks per day
	DIV	T3,T1		;T3/ fraction.of.a.day * 2^18, T4/remainder
	LSH	T1,-1		;Half if a UDT increment
	CAML	T4,T1		;More than halfway to next 0.32959 second?
	 ADDI	T3,1		;Yes, round up
	HRLZ	T2,T2		;Days since 1-JAN-1964 in LH
	ADD	T2,T3		;T2/ days,,fraction
	SETZ	T1,		;T1/ 0
	POP	P,T4
	POPJ	P,

YR2SEC:	PUSHJ	P,YR2DEC	;First convert to DEC format
JF2SEC:	IMUL	T2,[^D60*^D60*^D24];T2/seconds (for full days) T1/tics
	PUSH	P,T2		;Save from IDIV
	MOVE	T3,JFYSEC##	;Jiffies per second
	IDIV	T1,T3		;T1/secs T2/fraction.of.a.second
	LSH	T3,-1		;Jiffies per half second
	CAML	T2,T3		;More than half way into the next second?
	 ADDI	T1,1		;Yes, round up
	ADDM	T1,(P)		;seconds since 1/1/64 00:00
	SETZ	T1,
	JRST	T2POPJ		;T2/seconds, T1/0

YR2DEC:	IDIVI	T2,^D<365*4+1>	;Convert to DEC's 12*31 format (ticks in T1)
	IMULI	T2,4		;T2/years, T3/days into leap-year cycle
	CAIG	T3,^D366	;In the leap year?
	 JRST	YR2DC1		;Yes, MONTB is correct, T2 has right year
	SUBI	T3,1		;Account for day #59 being a leap day
	IDIVI	T3,^D365	;T3/1..3, T4/day in year
	ADD	T2,T3		;Combine years
	CAIL	T4,^D59		;After 28-Feb?
	 ADDI	T4,1		;Adjust since 29-Feb does not exist this year
	MOVE	T3,T4		;Get day in year
YR2DC1:	MOVEI	T4,1		;T2/year, T3/day
	CAML	T3,MONTB(T4)	;Check month table
	 AOJA	T4,.-1
	SUB	T3,MONTB-1(T4)	;Days-1 in T3, months in T4
	IMULI	T2,^D12		;Years-64*12
	ADDI	T2,-1(T4)	;+months-1
	IMULI	T2,^D31		;*31
	ADD	T2,T3		;+days-1
	POPJ	P,		;T2/day-1+<mon-1>*31+<year-1964>*31*12, T1/tics

;DSTCHK - CHECK TO SEE IF TIME IN DAYLIGHT SAVING RANGE
;CALL:
;	MOVEI T1,HOURS SINCE 1-JAN-64
;	PUSHJ P,DSTCHK		;Uses T3, preserves T2
;	 <YES-DST IN EFFECT>
;	<NO---DST NOT IN EFFECT>
;
DSTCHK::MOVSI	T3,-DLTLEN	;Search entire DAYLIGHT SAVINGS table
DSTCK1:	CAMGE	T1,DLTTAB(T3)	;IS IT AFTER START TIME
	 JRST	CPOPJ1		;NO, NOT DAYLIGHT SAVINGS
	CAMGE	T1,DLTTAB+1(T3)	;AFTER END?
	 POPJ	P,		;NO, IN CORRECT RANGE
	ADDI	T3,1		;GET NEXT PAIR IN TABLE
	AOBJN	T3,DSTCK1
	JRST	CPOPJ1		;OUT OF TABLE, ASSUME NOT D.S.T

;TABLE FOR DAYLIGHT SAVINGS TIME. ENTRIES ARE IN PAIRS
;FIRST IS START, SECOND END. NUMBER IS HOURS SINCE JAN 1,1964
;Start is at 2:00am standard time (which jumps forward to 3:00am daylight time)
;  End is at 1:00am standard time (jumped back to from 2:00am daylight time)

DLTTAB:	OCT    5342,  15761	;APR 26-OCT 25 1964
	OCT   26402,  37271	;APR 25-OCT 31 1965
	OCT   47442,  60331	;APR 24-OCT 30 1966
	OCT   70752, 101371	;APR 30-OCT 29 1967
	OCT  112012, 122431	;APR 28-OCT 27 1968
	OCT  133052, 143471	;APR 27-OCT 26 1969
	OCT  154112, 164531	;APR 26-OCT 25 1970
	OCT  175152, 206041	;APR 25-OCT 31 1971
	OCT  216462, 227101	;APR 30-COT 29 1972
	OCT  237522, 250141	;APR 29-OCT 28 1973
	OCT  253362, 271201	;JAN  6-OCT 27 1974 (Started early in 74)
	OCT  276652, 312241	;FEB 23-OCT 26 1975
	OCT  322662, 333551	;APR 25-OCT 31 1976
	OCT  343722, 354611	;APR 24-OCT 30 1977
	OCT  365232, 375651	;APR 30-OCT 29 1978
	OCT  406272, 416711	;APR 29-OCT 28 1979
	OCT  427332, 437751	;APR 27-OCT 26 1980
	OCT  450372, 461011	;APR 26-OCT 25 1981

	;     United States; France (Central European Summer time)
	OCT  471432, 502321;  470220, 500612	;APR 25-OCT 31 1982
	OCT  512472, 523361;  511231, 521653	;APR 24-OCT 30 1983
	OCT  534002, 544421;  532272, 542712	;APR 29-OCT 28 1984
	OCT  555042, 565461;  553603, 563752	;APR 28-OCT 27 1985

	%3W=^D<3*7*24>	;# of hours in 3 weeks
	OCT  576102, 606521	;APR 27-OCT 26 1986
	OCT  617142-%3W, 627561	;APR  5-OCT 25 1987 Congress redefined it
	OCT  640202-%3W, 651071	;APR  3-OCT 30 1988
	OCT  661512-%3W, 672131	;APR  9-OCT 29 1989
	OCT  702552-%3W, 713171	;APR  8-OCT 28 1990
	OCT  723612-%3W, 734231	;APR  7-OCT 27 1991
	OCT  744652-%3W, 755271	;APR  5-OCT 25 1992
	OCT  765712-%3W, 776601	;APR  4-OCT 31 1993
	OCT 1006752-%3W,1017641	;APR  3-OCT 30 1994
	OCT 1030262-%3W,1040701	;APR  9-OCT 29 1995
	OCT 1051322-%3W,1061741	;APR  7-OCT 27 1996
	OCT 1072362-%3W,1103001	;APR  6-OCT 26 1997
	OCT 1113422-%3W,1124041	;APR  5-OCT 25 1998
	OCT 1134462-%3W,1145351	;APR  4-OCT 31 1999
	OCT 1155772-%3W,1166411	;APR  9-OCT 29 2000
	OCT 1177032-%3W,1207451	;APR  8-OCT 28 2001
	OCT 1220072-%3W,1230511	;APR  7-OCT 27 2002
	OCT 1241132-%3W,1251551	;APR  6-OCT 26 2003
	OCT 1262172-%3W,1273061	;APR  4-OCT 31 2004
	OCT 1303232-%3W,1314121	;APR  3-OCT 30 2005
	OCT 1324542-%3W,1335161	;APR  9-OCT 29 2006
	OCT 1345602-%3W,1356221	;APR  8-OCT 28 2007
	OCT 1366642-%3W,1377261	;APR  6-OCT 26 2008 (Last DAYLIGHT SAVINGS time)
DLTLEN==<.-DLTTAB>/2		;1377777 = 8-Nov-2008

;NOTE: The field which counts the number of days since 1-Jan-1964 will exceed
;      14 bits on November 8th, 2008.  On that date, TYMCOM-X will die.
;SETUUO SET VARIOUS THINGS

SETUUO:	HLRZ	T2,T1		;Get argument number
	CAIL	T2,SUUNUM	;(argument value is in RH of T1)
	 POPJ	P,		;Too large
	HLLZ	T3,SUUTAB(T2)	;Get license needed to do this operation
	JUMPE	T3,SETUU1	;Jump if none required
	TDNE	T3,JBTLIC(J)	;If it has any of these licenses
	 JRST	SETUU1		;Go to it
	JUMPN	T2,CPOPJ	;Return if not OPRSND
	MOVE	T3,JBTFPN(J)	;Find program's source PPN
	CAME	T3,SYSPPN	;Always let SYS programs type on CTY
	 POPJ	P,		;Not from (SYS), error out
SETUU1:	HRRZ 	T2,SUUTAB(T2)	;Dispatch
	JRST 	(T2)

SUUTAB:	       LICOPR,,OPRSND##	;(0) SEND TO OPR/CTY
	       LICOPR,,SCHSET	;(1) SCHEDULE
		    0,,INISET##	;(2) INIT2 FUNCTION
	LICOPR!LICJAL,,TIMSET	;(3) SET TIME
	LICOPR!LICJAL,,DATSET	;(4) SET DATE
	LICOPR!LICJAL,,OPRSET	;(5) SET OPR
		    0,,SETWTC	;(6) SET WATCH
	       LICJAL,,SCSPRV	;(7) SET OR CLEAR SCHPRV
		    0,,SETTLK	;(10) TALK TO JOB'S CMND PORT
 LICSPY!LICOPR!LICWCR,,BTCMD	;(11) READ/WRITE BOOTS CMND STRING
 LICSPY!LICOPR!LICWCR,,REST	;(12) READ/WRITE RESTART BITS
	       LICOPR,,INASET	;(13) SET DEFAULT INACTIVITY LIMIT
	       LICOPR,,KSYSET	;(14) SET KSYS
SUUNUM==.-SUUTAB

;SET DATE (SETUUO function 4) - do this immediately.
;Do not output message to CTY until the time has also been changed.

DATSET:	HRRZ	T2,T1		;Set date UUO
COMDAS::PUSH	P,T2		;SET DATE command
	PUSHJ	P,GETULT	;Get user local time and date in DEC format
	  MOVEI	T1,0		;If date/time not set, use midnite local time
	POP	P,T2		;Recover date (in DEC format)
	MOVEI	P4,400020	;Convert from DEC to GMT days
	PUSHJ	P,DATCOM
	  POPJ	P,		;Invalid date
	SKIPG	THSDAT##	;If date was not previously set,
	 TLO	T1,(1B0)	; flag the time as being not valid
	MOVEM	T1,TIME##	;Update time
	MOVEM	T2,THSDAT##	;Set new date
	JRST	CPOPJ1		;Wait for LOGINN to set the time via UUO

;SET TIME (SETUUO function 3) - set DTMADJ and adjust clock gradually.
;Output message to CTY at start and at end of adjustment.

TIMSET:	HRRZS	T1		;Set time UUO
COMTMS::IMUL	T1,JFYMIN##	;SET TIME command
	PUSH	P,T1		;T1 has time in jiffies
	PUSHJ	P,GETULT	;Get user local time and date in DEC format
	  JRST	TPOPJ		;Must set date before time can be set
	POP	P,T1		;T2 has date in DEC format, get new time
	MOVEI	P4,400020	;From user to GMT ticks
	PUSHJ	P,DATCOM	;Convert, watching for daylight savings
	  POPJ	P,		;Should not happen, GETULT checked already
	AOS	(P)		;Set for skip return
	PFALL	COMGMS		;Date in T2, new time in T1

;Here from SCNSER when we get GMT time from the supervisor
;T2 has days since 1-Jan-64, T1 has jiffies since midnight
;Uses T1-T4, preserves all others (SCNSER depends on P4)

COMGMS::SETZM	DTMADJ##	;Cancel any previous fix-up
	SKIPL	THSDAT##	;If date has not been set yet
	SKIPGE	TIME##		; or date set but time has not
	 JRST	COMGM2		;Change it now, do not output TIMEOK
	MOVE	T3,T2		;Copy date
	SUB	T3,THSDAT##	;# of days difference
	IMULI	T3,^D<24*60*60>	;Days to seconds
	ADD	T3,T1		;New ticks
	SUB	T3,TIME##	;# of ticks difference
	MOVEM	T3,DTMADJ##	;Tell CLOCK1 to speed up or slow down the clock
	MOVMS	T3		;Get absolute value
	IDIV	T3,JFYMIN##	;Number of minutes (destroys T4)
	CAILE	T3,^D60		;If more than one hour
	 JRST	COMGM1		; make the change immediately
	SKIPE	T3		;No EVENT if less than 1 full minute
TIMEOK:	 STOPCD (.,EVENT,TIMEOK,COMGM0,<Date/time has been changed>)
	POPJ	P,		;CLOCK1 will call OPRDTM when DTMADJ goes to 0

COMGM0:	PUSHJ	P,INLMES##	;The EVENT stopcode outputs the old time
	 ASCIZ /Time of day is being adjusted by /
	MOVE	T1,DTMADJ##
	IDIV	T1,JFYSEC##
	CAML	T1,[-^D300]	;If more than 5 minutes
	CAILE	T1,^D300
	 JRST	[IDIVI	T1,^D60	  ;Report minutes
		PUSHJ	P,PRTDEC##
		PUSHJ	P,INLMES##
		 ASCIZ / minutes./
		POPJ	P,]
	PUSHJ	P,PRTDEC##	;Output signed decimal number
	PUSHJ	P,INLMES##
	 ASCIZ / seconds./	;CRLF provided by stopcode output
	POPJ	P,		;End of TIMEOK event stopcode


;Adjustment is more than 1 hour, do it now

COMGM1:	MOVEM	T1,TIME##	;Set the new time now
	MOVEM	T2,THSDAT##	;and date
	 STOPCD (,XCT,TIMEOK)	;Tell OPR what the old date/time was
	SETZM	DTMADJ##	;Cancel slow adjustment
	MOVEI	T1,400000
	IORM	T1,STATES##	;SHUT the system
	SETOM	CTYBLF##	;Ding the bell
	JRST	COMGM3		;Tell OPR what the new date/time is

;Here when date hasn't been set yet

COMGM2:	MOVEM	T1,TIME##	;Set the new time now
	MOVEM	T2,THSDAT##	;and date
	PUSHJ	P,ADJUDT	;Set universal date/time, return it in T2
	SKIPG	SYSUDT##	;This starts at -1.  If not set yet,
	 MOVEM	T2,SYSUDT##	;Store UDT of when system came up
COMGM3:	PUSHJ	P,FIXWEK##	;Set GMTDIF and LOCWEK
	PUSHJ	P,UDTFIX##	;Fix LOCSEC,LOCMIN,LOCHOR,LOCDAY,LOCMON,LOCYER
	PJRST	OPRDTM##	;Tell OPR about the new date/time


;SET SCHED (SETUUO function 1)

SCHSET:	SKIPE	DWNFLG##
	 POPJ	P,		;IN PROCESS OF HANGUP, CAN NOT SET
	HRRZ	T2,T1
	PJRST	SKDCOM##

;SET OPR (SETUUO function 5)

OPRSET:	PUSHJ	P,TTYFNU
	JUMPE	U,CPOPJ		;NO TTY
	MOVE	T1,F
	AOS	(P)		;GIVE SKIP RETURN
	JRST	COMSOP##	;COMMON SET OPR IN COMCON

;SET WATCH (SETUUO function 6)

SETWTC:	ANDI	T1,WCHALL
	HRLZS	T1
	IORM	T1,JBTWCH(J)
	JRST	CPOPJ1

COMMENT ! FUNCTION 7: SET OR CLEAR SCHPRV
CALLED: MOVSI	AC,7
	HRRI	AC,NONZERO TO SET SCHPRV, ELSE LEAVE 0 TO CLEAR
	SETUUO	AC,
	 ERROR, NOT LICENSED TO DO THIS
	SUCCESS AC UNCHANGED
!

;SET SCHPRV (SETUUO function 7)

SCSPRV:	MOVE	T2,JBTSTS(J)	;SET OR CLEAR SCHPRV
	TRNE	T1,-1		;RH USER AC 0 IF WANTS CLEARED
	 TROA	T2,SCHPRV
	TRZ	T2,SCHPRV
	MOVEM	T2,JBTSTS(J)
	JRST	CPOPJ1

COMMENT	! .STTLK (10) -- TALK TO JOB'S COMMAND PORT

	HRLI	AC, .STTLK
	HRRI	AC, ADDR
	SETUUO	AC,
	  ERROR RETURN	;AC/ ERROR CODE (SEE SCNSER)
	NORMAL RETURN	;COMPLETE MESSAGE SENT, AC UNCHANGED

ADDR:	COUNT,,JOB #		;JOB=0 TO TALK TO CTY
	ILDB POINTER TO STRING, ASCIZ IF COUNT=0

!

;TALK (SETUUO function 10)

SETTLK:	PUSH	P,T1
	XCTFU	<MOVE T2,1(T1)>	;T2/ BYTE POINTER
	XCTFU	<MOVE T1,0(T1)>	;T1/ TALKEE JOB #
	HLRZ	T4,T1		;T4/ Byte count, 0 means string is ASCIZ
	HRRZS	T1		;Job number (zero for CTY)
	PUSHJ	P,STTLK##	;TRY TO TALK
	  JRST	.+2		;(FAILURE)
	 JRST	TPOPJ1		;(SUCCESS -- RESTORE ADDR)
	POP	P,T3		;T3/ addr of two word block
	UMOVEM	T1,(W)		;Store error code in user's AC
	CAIE	T1,TKROM%##	;Error code for no room in TTY chunks?
	 POPJ	P,		;No
	XCTTU	<MOVEM T2,1(T3)>;Update byte pointer
	XCTTU	<HRLM  T4,0(T3)>;Update byte count
	POPJ	P,		;Error return from UUO

COMMENT !FUNCTION 11 (.BTSTR): READ/WRITE BOOTS COMMAND STRING

	HRLI	AC,.BTSTR
	HRRI	AC,<CONTROL WORD ADDR>
	SETUUO	AC,
	  ERROR RETURN		;LACKING LIC OR BAD STRING LENGTH
	NORMAL RETURN

CONTROL WORD: BITS 18-35: ADDR OF SOURCE/DESTINATION ASCIZ STRING
	      1B0=0 FOR READ -- REQUIRES RC, OP, OR WC
	      1B0=1 FOR WRITE -- REQUIRES WC
		    IF STRING IS TOO LONG IT WILL BE TRUNCATED
		     AND THE ERROR RETURN TAKEN
		    AN ADDR OF ZERO CLEARS COMMAND STRING
	      IF CONTROL WORD ADDR IS ZERO NEITHER READ NOR WRITE

RETURN MAXIMUM STRING LENGTH IN CHARACTERS IN AC

!


BC.RDW==(1B0)			;CONTROL WORD READ/WRITE BIT

;Read/Set BOOTS command string (SETUUO function 11)

BTCMD:	HRRZ	T1,T1		;ISOLATE CONTROL WORD ADDR
	JUMPE	T1,BTCMD1	;IF ZERO ONLY WANT BTSTLN
	UMOVE	T1,(T1)		;FETCH CONTROL WORD
	MOVE	T3,[POINT 7,BTSTR##]	;PREPARE BTSTR BYTE PTR
	TLNE	T1,BC.RDW	;STRING READ DESIRED?
	 JRST	BTCMD2		;NO: GO WRITE CORE
	HRLI	T1,(POINT 7,)	;PREPARE USER STRING BYTE PTR
BTCMD3:	ILDB	T2,T3		;GET CHAR FROM BTSTR
	XCTFU	<IDPB T2,T1>	;GIVE TO USER
	JUMPE	T2,BTCMD1	;DONE IF 'NULL'
	JRST	BTCMD3		;CONTINUE WITH NEXT CHAR
BTCMD2:	MOVSI	T2,LICWCR	;USER MUST HAVE WC LIC
	TDNN	T2,JBTLIC(J)	; TO MODIFY BOOTS CMD STRING
	 POPJ	P,		;DOES NOT, ERRROR RETURN
	HRRZ	T1,T1		;ISOLATE USER STRING ADDR
	JUMPE	T1,BTCMD5	;CLEAR STRING
	HRLI	T1,(POINT 7,)	;PREPARE USER STRING BYTE PTR
	MOVEI	T4,BTSTLN##	;INIT CHAR COUNTER
BTCMD4:	XCTFU	<ILDB T2,T1>	;GET A CHARACTER FROM USER
	JUMPE	T2,BTCMD5	;DONE IF 'NULL'
	JUMPE	T4,BTCMD6	;ERROR IF STRING TOO LONG
	IDPB	T2,T3		;PLACE IN BTSTR
	SOJA	T4,BTCMD4	;CONTINUE IF ROOM IN STRING

BTCMD6:	SOS	(P)		;SET TO NON-SKIP RETURN
BTCMD5:	SETZ	T2,		;PUT 'NULL' TERMINATOR AT
	IDPB	T2,T3		; END OF STRING
BTCMD1:	MOVEI	T1,BTSTLN##	;GET MAX STRING LENGTH
	UMOVEM	T1,(W)		;GIVE TO USER
	JRST	CPOPJ1		;SKIP RETURN

COMMENT !FUNCTION 12 (.REST): READ/WRITE RESTART BITS

	HRLI	AC,.REST
	HRRI	AC,<BITS>
	SETUUO	AC,
	  ERROR RETURN		;MISSING LIC
	SUCCESS RETURN

<BITS>:		1B18=0  READ RESTART BITS INTO AC
		    =1  SWAP AC RESTART BITS WITH CURRENT RESTART BITS

		1B19=0  WRITE DSKCLN TYPE TO DISK
		    =1  DO NOT WRITE DSKCLN TYPE TO DISK

		377B27  CRASH RESTART
		377B35  HANG RESTART

	THE FORMAT OF THE CRASH AND HANG RESTART FIELDS ARE IDENTICAL.
	LET THE LEFT MOST BIT OF EITHER FIELD BE LABELED '0', THEN
	THE FIELDS ARE INTERPRETED AS FOLLOWS:

		7B2  DEFINITION STATE OF ACTIONS, 1=DEFINED,
		     BITS CORRESSPOND LEFT TO RIGHT WITH THE
		     THREE ACTIONS

		1B3=0  STRING PASSED TO BOOTS
		   =1  MANUAL BOOTS
		1B4=0  AUTO ONCE
		   =1  MANUAL ONCE
		7B7  DSKCLN TYPE
		

FOR READ OP, RC, OR WC IS NEEDED.  FOR SWAP WC IS REQUIRED.

!

;Read/Set RESTART bits (SETUUO function 12)

REST:	MOVE	T2,REUSER##	;GET CURRENT RESTART BITS
	UMOVEM	T2,(W)		;PASS ALONG TO USER
	TRNN	T1,1B18		;SWAP DESIRED?
	 JRST	CPOPJ1		;NO. SUCCESS RETURN
	MOVSI	T2,LICWCR	;GET WC MASK
	TDNN	T2,JBTLIC(J)	;DOES USER HAVE WC SET?
	 POPJ	P,		;NO. ERROR RETURN
	HRRM	T1,REUSER##	;SET RESTART BITS
	JRST	CPOPJ1		;SUCCESS RETURN


;SET DEFAULT INACTIVITY (SETUUO function 13)

INASET:	SETCMI	T2,JBLMSK##	;ALLOW A REASONABLE VALUE
	TDNE	T2,T1		;Limit too big?
	 POPJ	P,		;Yes, error return
	SKIPN	T1		;If no value given
	 MOVEI	T1,INADFL##	; then use the hard-coded default
	MOVEM	T1,INADEF##	;Store
	JRST	CPOPJ1		;  and return

;SET KSYS (SETUUO function 14) - set KSYS timer for N minutes

KSYSET:	HRREM	T1,KSYS##	;Zero cancels, +5 if 5 minutes from now,
	JRST	CPOPJ1		;Negative if KSYS has expired, hang all
;SET OR CLEAR USER MODE WRITE PROTECT BIT IN HIGH SEG FOR THIS USER ONLY
;CALL:	MOVEI AC,0 OR 1
;	CALL AC,[SIXBIT /SETUWP/] OR CALLI AC,34
;	ERROR - MACHINE OR MONITOR CANNOT HANDLE TWO REG, OR TRYING TO CLEAR
;			;UWP OF A SHARABLE SEG(AC=1 ON RETURN)
;	OK RETURN - AC CONTAINS PREVIOUS SETTING( OR JOB HAS NO HIGH SEG)

SETUWP:	JRST USTUWP##		;GO TO ROUTINE IN SEGCON

;M TO REMAP TOP PART OF LOW SEGMENT INTO HIGH SEGMENT
;PREVIOUS HIGH SEG(IF ANY) IS KILLED AND A NEW SEGMENT NUMBER IS ASSIGNED
;TO THIS JOB. REMAP IS USED BY LOADER AND GET
;CALL:	MOVEI AC,NEW HIGHEST USER ADR IN LOW SEG(EXEC ORS IN 1777)
;	CALL AC,[SIXBIT /REMAP/] OR CALLI AC,35
;	ERROR RETURN, MACHINE OR EXEC CANNOT HANDLE 2 REG OR DESIRED ADR
;			;GREATER THAN OLD LOW SEG
;	OK RETURN, LOW SEG ABOVE ARG NOW THE HIGH SEG

REMAP:	JRST UREMAP##		;CORE1 MODULE IN SEGCON
;SET LIGHTS ON CONSOLE FROM USER PROGRAM
;CALL AC,[SIXBIT /LIGHTS/] OR CALLI AC,-1

LIGHTS::   ;THIS IS AN EXAMPLE OF A USER DEFINED MUUO WITH A NEGATIVE CALLI ARG.
IFCPU (<KI,F3>),<
	DATAO	PI,T1>		;SENT USER'S AC TO CONSOLE LIGHTS
	POPJ	P,		;END OF LIGHTS UUO

SWITCH::	;RETURN DATA SWITCHES
IFCPU (<KI,F3>),<DATAI T1>	;READ CONSOLE DATA SWITCHES DIRECTLY
IFCPU (KL),<PUSHJ P,SPCGSW##>	;SECONDARY PROTOCOL - GET SWITCH VALUE
IFCPU (KS),<MOVE T1,KSSS4##>	;FAKE SENSE SWITCHES ON KS2020
	UMOVEM	T1,(M)		;MOVE TO USER'S AREA.
	POPJ	P,		;END OF SWITCH UUO

;CALLI 67 - Cause a JOB stopcode if CALI67+0 is patched to a JFCL

CALI67::POPJ	P,		;Do nothing on an unpatched monitor
	 STOPCD (.,JOB,S..JOB,,<CALLI 67 requested JOB stopcode>)
	POPJ	P,		;In case S..JOB changed to DEBUG/INFO/EVENT

;CALLI 70 - Cause a DEBUG stopcode if CALI70+0 is patched to a JFCL

CALI70::POPJ	P,		;Do nothing on an unpatched monitor
	 STOPCD (CPOPJ,DEBUG,S..CI7,,<CALLI 70 requested DEBUG stopcode>)
	POPJ	P,		;In case S..CI7 is changed

;RETURN DEVICE CHARACTERISTICS

;DEVTYP = CALLI 53
DEVTYP:	AOS	(P)		;Skip return to indicate UUO is implemented
	PFALL	DVCHR	;*HACK* This is good enough for (AUTOPATCH)COMPAR
PRINTF(<[DEVTYP uuo is not fully implemented]>)

;DEVCHR = CALLI 4
DVCHR:	PUSHJ	P,DVCNSG	;SEARCH FOR DEVICE
	  TDZA	T1,T1		;NOT A DEVICE, RETURN ZERO
	SKIPA	T1,DEVMOD(F)	;DEVICE FOUND,RETURN DEVMOD
	 JRST	DVCHR1		;RETURN ZERO, DEVICE NOT FOUND.
	TLZ	T1,DVAVAL	;THIS BIT USED FOR OTHER PURPOSES IN CORE
	LDB	T2,PJOBN##	;GET JOB NO.  USING DEVICE
	CAME	T2,JOB		;DOES CURRENT USER ALREADY HAVE IT?
	TRNN	T1,ASSCON+ASSPRG;NO, IS IT ASSIGNED?
	 TLO	T1,DVAVAL	;NO, BUT HE CAN GET IT.
DVCHR1:	UMOVEM	T1,(M)		;MOVE TO USER'S AREA.
	POPJ	P,		;AND RETURN.

;RETURN PROJECT-PROGRAMMER NUMBER IN AC

GETPPN:	MOVSI	T1,JACCT
	TDNE	T1,JBTSTS##(J)	;LOGIN OR LOGOUT CUSP RUNNING ?
	 JRST	GETPPL		;YES, SPECIAL PROJ,R NUMBER CHANGE.
	MOVE	T1,JBTPPN##(J)	;NO, RETURN PROJECT-PROGRAMMER NO. OF THIS JOB.
	UMOVEM	T1,(M)		;INFO TO USER'S AREA.
	POPJ	P,		; AND RETURN.

RTZER::	XCTBU <SETZM (M)>	;RETURN A ZERO TO THE USER AC.
	POPJ	P,		;AND RETURN.

DEVPPU:	PUSHJ	P,DVCNSG
	  JRST	RTZER		;NOT A DEVICE
	TLNE	F,SYSDEV	;For device SYS:
	 SKIPA	T1,SYSPPN##	; return [1,4]
	MOVE	T1,JBTPPN##(J)	;Return GFD'd PPN for DSK:
	UMOVEM	T1,(M)		;MOVE PPN TO USER'S AREA.
	JRST	CPOPJ1		;AND SKIP RETURN.
;RETURN BUFFER SIZE, STANDARD NO OF BUFFERS
;CALL:	MOVE AC,LOC OF (2 WORRD) OPEN BLOCK
;CALLI AC,DVSIZ
;NOT IMPLEMENTED RETURN
;AC=XWD NO OF BUFS,BUF SIZE

DVSIZU:	PUSH	P,M		;SAVE UUO
	HRR	M,T1		;GET LOC OF OPEN-BLOCK
	UMOVE T1,(M)		;PICK UP MODE FROM USER'S AREA.
	MOVE	P1,T1		;SAVE IT
	HRRI M,1(M)		;INCREMENT POINTER TO USER'S AREA.
	UMOVE T1,(M)		;AND GET THE DEVICE.
	PUSHJ	P,DVCNSG	;FIND ITS DDB
	  TDZA	T1,T1		;NOT A DEVICE
	SKIPA	M,P1		;FOUND - SET UUO=MODE
	SOJA	T1,SIZRET	;NOT A DEV - RETURN AC=-1
	MOVEI	T2,1		;SET FOR MODE TEST
	ANDI	P1,17		;GET MODE ALONE
	LSH	T2,(P1)		;POSITION THE BIT
	MOVNI	T1,2		;IF MODE IS ILLEGAL,
	CAIL	P1,SD		;TEST FOR DUMP MODE
	TDZA	T1,T1		;IT IS, RETURN AC=0
	TDNN	T2,DEVMOD(F)	; RETURN AC=-2
	PJRST	SIZRET
	LDB T1,[POINT 12,DEVCHR(F),35]
	HRLI	T1,STDRNG	;T1/BUFF IN STD RING,,BUFF SIZE
	ADDI	T1,2		;BUMP SIZE BY 2 HOUSEKEEPING WRDS
SIZRET:	POP	P,M		;RESTORE LOC OF AC
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

UDEVNM:	PUSHJ P,DVCNSG		;FIND DEVICE OR CHANNEL
	 JRST RTZER		;NON-RETURN 0
	MOVE T1,DEVNAM(F)	;GET REAL NAME
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

	EXTERNAL JBTSOK

SOAKEM:	ANDI T1,377		;MAKE SURE IN RANGE 0-255
	IMULI T1,^D1000
	MOVE T2,T1		;A COPY
	ADD T1,JBTSOK(J)
	JUMPLE T1,CPOPJ1	;IGNORE IF OVERFLOW
	MOVEM T1,JBTSOK(J)
	ADDM T2,JBTSOK
	JRST CPOPJ1
;DEVICE STATUS CONI RETRIEVAL CALLI MUUO

;     CALL AC,[SIXBIT/DEVSTS/]
;                 OR
;    CALLI AC,54

;             WHERE AC CONTAINS THE CHANNEL NUMBER OF THE
;		INIT'ED DEVICE....
;		THE CONI STATUS WORD IN THE DDB (DEVSTS)
;		IS RETURNED IN AC

DEVSTA:	PUSHJ P,DVCNSG		;FIND DEVICE OR CHANNEL
	 JRST RTZER
	MOVE T1,DEVSTS(F)
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

SETJAL:	MOVSI T2,LICJAL
	TDNE T2,JBTLIC(J)	;CAN HE DO IT?
	SKIPA T2,JALMSK		;YES, ALL THINGS
	MOVEI T2,JACCT2		;ONLY JACCT2 FOR NORMAL USER
	PUSHJ P,CKLGO		;SEE IF WAITING FOR LOGOUT
	TRZ T2,JACCT2		;IF SO, CAN NOT SET THIS
	PUSH P,T1
	AND T1,T2		;THE BITS HE CAN SET
	IORM T1,JBTSTS(J)
	XOR T1,T2
	ANDCAM T1,JBTSTS(J)
	POP P,T1		;GET BACK REQUEST
	XOR T1,JBTSTS(J)
	AND T1,JALMSK
	JUMPE T1,CPOPJ1		;ALL SET, GOOD RETURN
	POPJ P,			;SOME NOT SET, ERROR RETURN

JALMSK:	XWD JACCT+JLOG,JACCT2+KJP

ONEJOB:	MOVE T1,STATES		;CHECK FOR SUPER SHUT
	TRC T1,600000
	TRCE T1,600000
	POPJ P,			;NOT SUPER-SHUT
	MOVE T1,HIGHJB
	SOJLE T1,CPOPJ1	;IF HIGHEST IS JOB 1 MUST BE OK
	MOVSI T2,JNA
	TDNE T2,JBTSTS(T1)	;JOB NUMBER ASSIGNED?
	POPJ P,			;YES
	SOJG T1,.-2
	JRST CPOPJ1		;ONLY JOB AND SUPER-SHUT

EXTERNAL STATES,CKLGO

SETDDT:	UMOVEM T1,JOBDDT	;SET JOBDDT IN JOB DATA AREA
	POPJ P,		;RETURN TO USER

EXTERNAL	HIGHJB
GETPPL:	MOVE T1,JBTPPN(J)	; AND GET OLD NUMBERS.
	MOVE T2,HIGHJB	;CHECK FOR OTHER USERS UNDER SAME PP NUMBER.
PPNLUP:	CAIN T2,(J)	;IS NEXT JOB TO BE LOOKED AT CURRENT JOB ?
	SOJLE T2,[UMOVEM T1,(M)	;YES, FINISHED SCANNING ALL JOBS ?
		POPJ P,]	;IF SO, RETURN.
	CAMN T1,JBTPPN(T2)	;NO, ANOTHER USER UNDER SAME PROJ,R NUMBER ?
	AOSA	(P)		;YES, SKIP RETURN TO USER (LOGIN OR LOGOUT)
	SOJG T2,PPNLUP	;NO, KEEP LOOKING
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	POPJ P,			; AND RETURN.

GETLN:	PUSHJ	P,TTYFND	;FIND USER'S TTY DATA BLOCK.
	MOVE	T1,DEVNAM(F)	;GET DEVICE NAME IN SIXBIT
	UMOVEM T1,(M)		;MOVE IT TO USER'S AREA.
	POPJ P,			; AND RETURN.
;LOGIN UUO USED ONLY BY LOGIN AND LOGOUT CUSPS
;CALL:	CALL AC,[SIXBIT /LOGIN/]
;WHERE AC CONTAINS XWD -NO. OF ENTRIES,LOCATION
;WHICH IS A LIST OF JOB STATISTICS TO BE STORED IN MONITOR
;RETURNS TO UUO +1 IF SUCCESSFUL AND THAT LOC DOES NOT CONTAIN A HALT

LOGIN:	MOVSI	T2,JLOG		;IS USER ALREADY LOGGED IN?
	TDNE	T2,JBTSTS(J)
	 JRST	UUOERR##	;YES, PRINT ILLEGAL UUO
	HLRE	T2,T1		;User supplies negative word count in LH
	MOVM	P1,T2		;Positive number of words
	CAIE	P1,LOGTP1-LOGTAB ;Cannot have 1 word project code
	CAIN	P1,LOGTP2-LOGTAB ;Cannot have 2 word project code
	 JRST	UUOERR##
	MOVEI	U,%UPT		;LDBLOG and project code go in %UPT
	SETZM	JBTNM1##(J)	;Invalidate GFD'd name
	SETZM	JBTNM2##(J)
	HRR	M,T1		;FIRST REL. LOC.
	MOVSI	P2,-LOGTOP	;SET FOR LOOP
LOGIN1:	AOSG	T2		;More arguments from the caller?
	 XCTBU <SKIPA P3,(M)>	;Yes, get next word
	  MOVEI	P3,0		;No, default to zero
	MOVEM	P3,@LOGTAB(P2)	;Store in JBT or UPT
	ADDI	M,1		;Point to next user argument
	AOBJN	P2,LOGIN1	;Do all in LOGTAB

	PUSHJ	P,CHGNAM##	;Make sure JBTNM1 and JBTNM2 match JBTPPN
	MOVEI	T1,40		;LOGIN accounting record type
	CAIL	P1,LOGTP3-LOGTAB;All three words of project code?
	 PUSHJ	P,WRTACR	;Yes, go write record
	MOVSI	T2,JLOG		;Job is now logged in
	IORM	T2,JBTSTS(J)

;Copy originating port from LDB (if one exists)

	SKIPN	T1,TTYTAB(J)	;Address of TTY DDB
	 JRST	LOGIN3		;None there???
	HRRZ	T1,DDBLDB(T1)	;Address of Line Data Block
	JUMPE	T1,LOGIN3	;Skip if detached
	MOVE	T1,LDBLOG##(T1)	;Originating port from network
	SKIPN	%UPT+UPTLOG##	;If set by CREFRM, don't set again
	 MOVEM	T1,%UPT+UPTLOG## ;Set into UPT

LOGIN3:	LDB	T1,PVYCOR	;JUST MAKE SURE NOT TOO MUCH CORE
	LDB	T2,PVYCRM
	CAMLE	T1,T2
	MOVE	T1,T2
	CAMGE	T1,CORMXK
	MOVE	T1,CORMXK
	DPB	T1,PVYCOR

	MOVSI	T1,PVDINA	;SEE IF WE WANT TO SET THE
	TDNN	T1,JBTPRV(J)	;  DEFAULT INACTIVITY TIMEOUT?
	 TDZA	T1,T1		; NO -- CLEAR THE FIELD
	HRRZ	T1,INADEF##	; YES-- USE DEFAULT FROM TABLE
	DPB	T1,JBYINA##	;UPDATE THE JBT TABLES

	UMOVE	T1,@PDNMUP(P)	;GET NEXT INSTR FROM USER AREA
	LSH	T1,-30		;LOOK AT TOP 12 BITS
	CAIE	T1,2542		;HALT?
	 POPJ	P,0		;NO. RETURN TO USER.
	PUSHJ	P,IORELS	;RELEASE ALL DEVICES
	PUSHJ	P,TTYFUW##	;FIND TTY AND PRINT ^C
	JRST	HOLD

;Table of pointers to tables for use by MOVEM data,@LOGTAB(ac).
;To make LOGIN set more tables in the Monitor, just add table names at end.
;This table is also used by the CREFRM uuo.

LOGTAB::XWD	J,JBTPPN##	;Project-Progremmer Number (GFD PPN)
	XWD	J,JBTPRV##	;Job privilege bits
	XWD	J,JBTAUN##	;Accounting User Number (LOGIN PPN)
	XWD	J,JBTUNM##	;Login user name (1st part)
	XWD	J,JBTUN1##	;Login user name (2nd part)
	XWD	U,UPTLOG##	;Tymnet supervisor information
LOGTP1:	XWD	U,UPTPJC##	;Three word project code
LOGTP2:	XWD	U,UPTPJ1##
LOGTP3:	XWD	U,UPTPJ2##
XP	LOGTOP,.-LOGTAB		;Number of tables to be set (for FRMSER too)



;LOGOUT MUUO

LOGOUT:	MOVSI	T1,JLOG
	TDNN	T1,JBTSTS(J)	;IS JOB ALREADY LOGGED OUT ?
	 JRST	JOBKL		;NO, GO COMPLETE WORK OF LOGOUT CUSP.
	JRST	EXIT		;YES, TREAT AS "EXIT"
;HERE WITH FD IN J AND ACCESS RIGHTS NUMBER IN P3 TO SEE IF CALLER
; CAN GET INFORMATION. IF SO, GO TO FINTAB, IF NOT, POPJ AND GIVE ERROR RETURN.

EXTERNAL FARCHK

ACCWAY:	MOVE	P4,J		;GET FD INTO P4 WHERE IT BELONGS
	PUSH	P,T1		;SVE TABLE ADDRESS
	PUSHJ	P,FARCHK	;CHECK THE FD, SEE IF CALLER HAS RIGHTS
	  JRST	TPOPJ		;NO, GIVE ERROR RETURN TO UUO CALLER
	POP	P,T1		;OK, RESTORE T1 AND
	JRST	FINTAB		;GIVE HIM THE DATA.

SYSWAY:	MOVE	T2,JOB
	MOVE	T2,JBTLIC(T2)
	TLNN	T2,LICSYS!LICSPY
	  POPJ	P,		;MUST HAVE SYSTAT
	JRST	FINTAB

ACJWAY:	SKIPA	P3,[.ARRAD]	;NEED READ ACCT DATA FOR THIS
JLNWAY:	MOVEI	P3,.ARRDS	;NEED READ STATE TO GET FRAME'S TTY NAME
	MOVE	P4,J		;GET FD IN P4 FOR FARCHK
	PUSH	P,NUMTAB(T1)	;SAVE ADDRESS TO GO TO ON STACK.
	PUSHJ	P,FARCHK	;MAKE SURE FD IS OK, CHECK ACCESS
	  JRST	TPOPJ		;NO GOOD, GIVE ERROR
	POPJ	P,		;GET ROUTINE ADDRESS OFF STACK AND GO TO IT.

TAJWAY:	PUSHJ	P,TIMADJ
	MOVEI	P3,.ARRAD	;WAYTAJ IS USED TO READ ACCOUNTING DATA
	JRST	ACCWAY		;GO CHECK.

JPOPJ:	POP P,J
	POPJ P,


DEFINE X(NAM,OK,DO)<
WAY'NAM==<.-WAYTAB>_5
IFGE <.-WAYTAB>-17,<PRINTX TOO MANY WAYS IN GETTAB
QQQQQQ>
IFNB <DO>,<DO>
IFB <DO>,<JRST [MOVEI P3,.AR'NAM
		JRST ACCWAY]>
>;END X MACRO DEFINITION

DEFINE WAYS<
X(RPI)
X(RFI)
X(RUN)
X(RDS)
X(RAD)
X(JLN,<POPJ P,>,<JRST JLNWAY>)
X(ACJ,<POPJ P,>,<JRST ACJWAY>)
X(SYS,<JFCL>,<JRST SYSWAY>)
X(TAJ,<JFCL>,<JRST TAJWAY>)
X(JMP,<POPJ P,>,<JRST @NUMTAB(T1)>)
>;END WAYS MACRO DEFINITION

;GENERATE TABLE OF WAYS

WAYTAB:	JFCL				;IF NO WAY, DO NOTHING.
	WAYS

DEFINE X(NAM,OK,DO)<
IFNB <OK>,<OK>
IFB <OK>,<JFCL>
>;END X MACRO DEFINITION

WAYTJB:	JFCL				;IF NO WAY, DO NOTHING
	WAYS

;HERE FROM COMCON WITH C(T2) FRAME TRYING TO EXECUTE COMMAND,
; C(J) TARGET FRAME NUMBER

EXTERNAL JOBMAX


CHKSGJ:	PUSH	P,T1
	MOVEI	T1,LICSYS!LICSPY
	JRST	CHKSJ1

;HERE WITH C(JOB) CURRENT FRAME NUMBER, FRAME NUMBER TO CHECK FOR IN
; C(J) (UNCHECKED)

CHKSEG:	MOVE	T2,JOB
	CAILE	J,JOBMAX	;IN RANGE?
	POPJ	P,		;NO, GIVE ERROR RETURN.
	PUSH	P,T1
	MOVSI	T1,LICSYS!LICSPY
CHKSJ1:	TDNE	T1,JBTLIC(T2)
	  JRST	TPOPJ1		;HAS SYSTAT, GIVE IT TO HIM
	MOVE	T1,JBTAUN(J)
	XOR	T1,JBTAUN(T2)
	JUMPE	T1,TPOPJ1	;SAME AUN, OK TO HAVE IT
	TLNE	T1,-1
	  JRST	TPOPJ		;NOT SAME PROJECT, NEVER CAN GET IT
	MOVEI	T1,PVACTS	;CHECK ACCOUNT SUP
	TDNE	T1,JBTPRV(T2)
	  AOS	-1(P)
	JRST	TPOPJ

;HERE TO DO NUMTAB - TAKE CARE OF NEGATIVE INDICES.

DONUMT:	HLRE	J,T1		;Incase LH is -1 (do NOT use current job number)
	MOVEI	T2,NUMTAB(J)	;GET ADDRESS HE WANTS
	CAIGE	T2,ENDGTB	;IF PAST END OR
	CAIGE	T2,MINTAB	;BEFORE THE BEGINNING
	  POPJ	P,		;ERROR RETURN.
	MOVE	T3,JOB		;MUST HAVE SY
	MOVE	T3,JBTLIC(T3)
	TLNN	T3,LICSYS!LICSPY;OR ELSE
	  POPJ	P,		;GIVE HIM ERROR RETURN
	CAIN	T2,NUMTAB+.GTSLF;WANTS ADDRESS OF NUMTAB ITSELF?
	  SKIPA	T1,[NUMTAB]	;RETURN ADDRESS OF NUMTAB TO HIM.
	MOVE	T1,(T2)		;GET THE DATA
	UMOVEM	T1,(M)
	JRST	CPOPJ1		;AND RETURN.
;GETTAB UUO
;UUO TO RETURN CONTENTS OF A MONITOR JOB TABLE ENTRY
;CALL:	HRROI AC, MONITOR JOB TABLE NUMBER
;	HRLI AC, JOB NUMBER (OPTIONAL) LH = -1 MEANS CURRENT JOB
;	CALL AC, [SIXBIT /GETTAB/] OR CALLI AC,41
;	  ERROR RETURN (AC PRESERVED) IF BAD TABLE OR INDEX, NOT PRIVILEGED
;	NORMAL RETURN - AC CONTAINS VALID DATA
	EXTERN TTYTAB,JOBMXL,STSTBL,STSMXL
	EXTERNAL GETLOG,TIMADJ,JBTCMP,JBTCPU,JBTBCS,JBTFPN
	EXTERNAL JBTCNK,JBTELP,JBTCOT,JBTCIN,JBTSOT,JBTSIN
	EXTERNAL JBTBET,JBTBIO
	EXTERNAL JBTSER,JBTSLK,JBTDLK,LINJOB,JBTERN
NOMXL==777000			;DEFINED TO FOOL OLD NUMTAB WATCHERS

GETTAB:	HLRZ	J,T1		;GET USER SUPPLIED JOB NUMBER
	CAIN	J,-1		;If index is -1 and table indexed by job number,
	 MOVE	J,JOB		; use current job number
	HRRE	T2,T1		;IN CASE NEGATIVE
	ADDI	T2,NUMTAB
	CAIG	T2,ENDGTB
	CAIGE	T2,MINTAB	;IS IT IN RANGE
	  POPJ	P,		;YES. ERROR RETURN, AC UNCHANGED
	CAIN	T2,NUMTAB+.GTSLF;Table of GETTAB addresses is special
	 JRST	GETTB1		;It can have negative indices
	TRNE	J,400000	;Any other negative index is not allowed
	 POPJ	P,		;(including -2 = job's hiseg)
GETTB1:	LDB	T2,[POINT 9,NUMTAB(T1),8]	;MAX LEGAL ARG.
	CAIN	T2,NOMXL_-^D9	;IF SPECIAL CODE (777) THEN
	 JRST	GETTB2		;NO BOUNDS CHECK, SOMEONE ELSE WILL DO IT.
	CAMLE	J,T2		;DOES HIS ARG EXCEED LEGAL ONE?
	 POPJ	P,0		;YES. ERROR RETURN
GETTB2:	LDB	T2,[POINT 4,NUMTAB(T1),12]	;GET ACTION TYPE
	XCT	WAYTAB(T2)	;DO IT
FINTAB:	MOVE	T1,@NUMTAB(T1)	;GET CONTENTS OF MONITOR TABLE
	UMOVEM	T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST	CPOPJ1		;AND SKIP RETURN.

;THE MONITOR JOB TABLE NUMBERS:
        INTERN NUMTAB
	EXTERN LICTBL,LICMXL
	EXTERN JBTNAM,NSWTBL,CNFTBL,NSWMXL,CNFMXL,JBTCP2
	EXTERN JBTSLM,JBTLIM,GETLPS,GETMOD,JBTBET,JBTBIO
	EXTERN JBTMPC,JBTPWS,JBTPWH,JBTPWL
	EXTERN ODPMXL,ODPTBL,LVDMXL,LVDTBL,JBTWCT,JBTRCT
	EXTERN SWPTBL,SWPMXL
	EXTERN TTYTBL,TTYMXL,FETTBL,FETMXL,CRSDB,CRSMXL
	EXTERN COMTAB,COMMXL,WATTAB,WATMXL,SETBL,SETMXL
	EXTERN JBTKCT,JBTFTR,JBTUID,JBTPNO
MINTAB:
	XWD LICMXL+J,LICTBL		;(-57)LICENSE POINTERS,NAMES,VALUES
	XWD NOMXL+WAYRDS+J,JBTSLM	;(-56)MAXIMUM TRU LIMIT
	XWD NOMXL+WAYRPI+J,JBTINA	;(-55)INACTIVITY TIMEOUT
	XWD NOMXL+WAYRFI+J,JBTFTR	;(-54)PARENT, BROTHER, CHILD
	XWD NOMXL+WAYRFI+J,JBTUID	;(-53)UNIVERSAL ID NUMBER FOR FRAME
	XWD NOMXL+WAYRPI+J,JBTPNO	;(-52)PROGRAM NUMBER FOR FRAME
	XWD NOMXL+WAYACJ,PWSGET		;(-51)DP PGS TO WS*SIZE.
	XWD NOMXL+WAYRAD+J,JBTPWS	;(-50) NO. PAGES TO UWS.
	XWD NOMXL+WAYRAD+J,JBTMPC	;(-47) NO. PAGES MAPPED.
	XWD NOMXL+WAYACJ,MCYGET		;(-46)GET D.P. MICROCYCLES
	XWD NOMXL+WAYACJ,KCTGET		;(-45)GET D.P. KILO-CORE-TICKS
	XWD NOMXL+WAYACJ,TRUGET		;(-44)GET D.P. TRU TO AC,AC+1
	XWD NOMXL+WAYACJ,TRUGN2		;(-43) HIGH PART OF TRU
	XWD NOMXL+WAYTAJ+J,JBTCP2	;(-42) HIGH PART OF MICRO-CYCLES
	XWD NOMXL+WAYRAD+J,JBTBIO	;(-41) BIO CHAR CHARGE
	XWD NOMXL+WAYRAD+J,JBTBET	;(-40) BIO TIME CHARGE
	XWD NOMXL+WAYRAD+J,JBTSOK	;(-37) SOAKEM ARG
	XWD NOMXL+WAYJMP,GETLNK		;(-36) LINKED GETTAB
	XWD NOMXL+WAYRAD,[0]		;(-35) RMT CHR CHARGE
	XWD NOMXL+WAYRAD,[0]		;(-34) RMT TIME CHARGE
	XWD NOMXL+WAYRAD+J,JBTERN	;(-33) ENTERS+RENAMES
	XWD NOMXL+WAYJMP,GETLPS		;(-32) GET TTY LINE POS
	XWD NOMXL+WAYJMP,GETMOD		;(-31) GET TTY MODE
	XWD NOMXL+WAYRDS+J,JBTLIM	;(-30) TIME (TRU) LIMIT
	XWD NOMXL+WAYJLN,JOBLIN		;(-27) JOB TO LINE
	XWD NOMXL+WAYJMP,LINJOB		;(-26) LINE TO JOB
	XWD NOMXL+WAYRPI+J,JBTFPN	;(-25) JBTFPN
	XWD NOMXL+WAYJMP,GETLOG		;(-24) LDBLOG BY U NUMBER
	XWD NOMXL+WAYRFI+J,JBTAUN	;(-23) ACCOUNT USER NUM
	XWD NOMXL+WAYRUN+J,JBTUNM	;(-22) FIRST PART OF USER NAME
	XWD NOMXL+WAYRUN+J,JBTUN1	;(-21) SECOND PART
	XWD NOMXL+WAYRPI+J,JBTLIC	;(-20) LICENSE (NEEDS READ PROCESS DATE TO PROTECT PROCESS LICENSE)
	XWD WAYJMP,CPOPJ		;(-17)
	XWD WAYJMP,CPOPJ		;(-16)
	XWD NOMXL+WAYTAJ+J,JBTCMP	;(-15) CLOCK TIM
	XWD NOMXL+WAYTAJ+J,JBTCPU	;(-14) HIGH PART OF KCT
	XWD NOMXL+WAYRAD+J,JBTBCS	;(-13) BREAK CHRS*SIZE
	XWD NOMXL+WAYRAD+J,JBTCNK	;(-12) CONNECT TIME
	XWD NOMXL+WAYRAD+J,JBTELP	;(-11) ELAPSED TIME*SIZE
	XWD NOMXL+WAYRAD+J,JBTCOT	;(-10) CHRS OUT
	XWD NOMXL+WAYRAD+J,JBTCIN	;(-7) CHRS IN
	XWD NOMXL+WAYRAD+J,JBTSOT	;(-6) DISK BLOCKS OUT*SIZE
	XWD NOMXL+WAYRAD+J,JBTSIN	;(-5) DISK BLOCKS IN*SIZE
	XWD NOMXL+WAYRAD+J,JBTSER	;(-4) ENTER+RENAME*SIZE
	XWD NOMXL+WAYRAD+J,JBTSLK	;(-3) LOOKUPS*SIZE
	XWD NOMXL+WAYRAD+J,JBTDLK	;(-2) LOOKUPS
	XWD WAYJMP,CPOPJ		;(-1)
NUMTAB:	XWD NOMXL+WAYRUN+J,JBTSTS	;(0) - JOB STATUS BITS
	XWD JOBMXL+WAYRPI,[0]		;(1) - JOB SIZE -1 AND PAGE NO. OF UPT FORMERLY,
					; NOW RETURN 0 FOR CHKPNT.

	XWD NOMXL+WAYRFI+J,JBTPPN	;(2) - PROJECT,PROGRAMMER NUMBER
	XWD NOMXL+WAYRPI+J,JBTNAM	;(3) - PROGRAM BEING RUN
	XWD NOMXL+WAYACJ,TRUGN		;(4) - TRU'S
	XWD NOMXL+WAYTAJ+J,JBTKCT	;(5) - KILO-CORE TICKS(JIFFIES*SIZE IN J)

	XWD NOMXL+WAYRPI+J,JBTPRV	;(6) - PRIVILEGE BITS SET BY LOGIN
	XWD NOMXL+WAYJMP,SIMJSW		;(7) - FAKE JBTSWP, TEMPORARY TILL SYSTAT FIXED.
	XWD NOMXL+WAYRDS+J,TTYTAB	;(10) - TTY TRANSLATOR TABLE (DDB ADDRESS)
	XWD CNFMXL+J,CNFTBL		;(11) - CONFIGURATION DATA
	XWD NSWMXL+WAYSYS+J,NSWTBL	;(12) - NON-SWAPPING DATA
	XWD SWPMXL+WAYSYS+J,SWPTBL	;(13) - SWAPPER DATA

	XWD WAYJMP,CPOPJ	;JBTSGN	;(14) - OBSOLETE (OLD HISEG NUMBER)
	XWD ODPMXL+WAYSYS+J,ODPTBL	;(15) - ONCE ONLY DISK PARAMETERS
	XWD LVDMXL+J,LVDTBL		;(16) - LEVEL D DISK PARAMS
	XWD NOMXL+WAYRAD+J,JBTRCT	;(17) - DISK BLOCKS READ BY JOB
	XWD NOMXL+WAYRAD+J,JBTWCT	;(20) - DISK BLOCKS WRITTEN BY JOB
	XWD WAYJMP,CPOPJ	;NONE	;(21) - ACC. DSK-BLOCK-SECONDS ALLOCATED BY JOB
	XWD WAYJMP,CPOPJ	;NONE	;(22) - TIME OF DAY DSK BLOCKS LAST ALLOCATED+TOTAL BLOCKS ALLOCATED
.GTSLF==.-NUMTAB			;.GTSLF=23 - Get self pointer
	XWD NOMXL+WAYJMP,DONUMT		;(23) - THE GETTAB ADDRESSES THEMSELVES (GETTAB IMMEDIATE)
	XWD WAYJMP,CPOPJ	;JBTDEV	;(24) - OBSOLETE (OLD DEVICE NAME FOR HISEGS)
					; OF SHARABLE HIGH SEG
	XWD STSMXL+J,STSTBL		;(25) - SIXBIT NAMES FOR JOB QUEUE CODES
	XWD WAYJMP,CPOPJ	;JBTLOC	;(26) - RESERVED FOR REMOTE COMMUNICATIONS
	XWD WAYJMP,CPOPJ	;NONE	;(27) - PHYSICAL CORE ALLOCATION TABLE
	XWD COMMXL+WAYSYS+J,COMTAB	;(30) - SIXBIT Monitor Command Names
	XWD NOMXL+WAYRUN+J,JBTNM1##	;(31) - SIXBIT Username [1 for 6]
	XWD NOMXL+WAYRUN+J,JBTNM2##	;(32) - SIXBIT Username [7 for 6]
	XWD NOMXL+WAYRAD+J,JBTAUN	;(33) - DEC: Job charge number [AUN]
	XWD WAYJMP,CPOPJ	;NONE	;(34) - (Obsolete) Pointer to TMPCOR
	XWD NOMXL+WAYRFI+J,JBTWCH	;(35) - FRAME WATCH BITS
	XWD WAYJMP,CPOPJ	;JBTSPL	;(36) - DEC: Spooling control flags
	XWD WAYJMP,CPOPJ	;JBTRTD	;(37) - DEC: Real time status word
	XWD WAYJMP,CPOPJ	;JBTLIM	;(40) - DEC: JBTLIM and batch status
	XWD WAYJMP,CPOPJ	;NONE	;(41) - DEC: .GTQQQ Obsolete
	XWD WAYJMP,CPOPJ	;NONE	;(42) - DEC: .GTQJB Obsolete
	XWD SETMXL+WAYSYS+J,SETBL	;(43) - SIXBIT SET Command Names
	XWD CRSMXL+WAYSYS+J,.GTCRS##	;(44) - 3-word Crash data block
	XWD WAYJMP,CPOPJ	;ISCAN	;(45) - DEC:.GTISC spwinp scan list
	XWD WAYJMP,CPOPJ	;OSCAN	;(46) - DEC:.GTOSC swpout scan list
	XWD WAYJMP,CPOPJ	;SSCAN	;(47) - DEC:.GTSSC sched scan list
	XWD WAYJMP,CPOPJ	;JBTRSP	;(50) - DEC:.GTRSP Response counter
	XWD SYSMXL##+WAYSYS+J,SYSTBL##	;(51) - System-wide ERROR data
	XWD WHYMXL##+WAYSYS+J,CRSHAC##	;(52) - ASCIZ Reload string (CRSHAC)
	XWD WAYJMP,CPOPJ	;JBTRQT	;(53) - DEC: Total time in run queue
	XWD WAYJMP,CPOPJ	;JBTSPS	;(54) - DEC: Status word for CPUn(s)
	XWD WAYJMP,CPOPJ	;.C0CDB	;(55) - DEC:.GTC0C
	XWD WAYJMP,CPOPJ	;.C0VBG	;(56) - DEC:.GTC0V
	XWD WAYJMP,CPOPJ	;.C1CDB	;(57) - DEC:.GTC1C
	XWD WAYJMP,CPOPJ	;.C1VBG	;(60) - DEC:.GTC1V
	XWD WAYJMP,CPOPJ	;.C2CDB	;(61) - DEC:.GTC2C
	XWD WAYJMP,CPOPJ	;.C2VBG	;(62) - DEC:.GTC2V
	XWD WAYJMP,CPOPJ	;.C3CDB	;(63) - DEC:.GTC3C
	XWD WAYJMP,CPOPJ	;.C3VBG	;(64) - DEC:.GTC3V
	XWD WAYJMP,CPOPJ	;.C4CDB	;(65) - DEC:.GTC4C
	XWD WAYJMP,CPOPJ	;.C4VBG	;(66) - DEC:.GTC4V
	XWD WAYJMP,CPOPJ	;.C5CDB	;(67) - DEC:.GTC5C
	XWD WAYJMP,CPOPJ	;.C5VBG	;(70) - DEC:.GTC5V
	XWD FETMXL+WAYSYS+J,FETTBL	;(71) - Feature test table
	XWD WAYJMP,CPOPJ	;SDVTBL	;(72) - DEC: Ersatz device table
	XWD WAYJMP,CPOPJ	;.GTSCN	;(73) - DEC: Scanner data
	XWD WAYJMP,CPOPJ	;SNDTMP	;(74) - DEC: ASCIZ Last SEND ALL
	XWD TTYMXL+WAYSYS+J,TTYTBL	;(75) - SIXBIT Set TTY commands
	XWD WAYJMP,CPOPJ	;PIDTAB	;(76) - DEC: Process communications ID
	XWD WAYJMP,CPOPJ	;IPCTAB	;(77) - DEC: Misc IPCF data
	XWD NOMXL+WAYRPI+J,JBTUPM	;(100)- User pages,Physical UPT page#
					;For hiseg, LH has start page number
	XWD WATMXL+WAYSYS+J,WATTAB	;(101)- SIXBIT Set WATCH commands
	XWD WAYJMP,CPOPJ	;PDB	;(102)- DEC: Current Virt/Phys Limits
	XWD WAYJMP,CPOPJ	;PDB	;(103)- DEC: Maximum Virt/Phys Limits
	XWD WAYJMP,CPOPJ	;PDB	;(104)- DEC: .GTIPA IPCF statistics
	XWD WAYJMP,CPOPJ	;PDB	;(105)- DEC: .GTIPP IPCF pointers etc.
	XWD WAYJMP,CPOPJ	;PDB	;(106)- DEC: PID for Jobs [SYSTEM]INFO
	XWD WAYJMP,CPOPJ	;PDB	;(107)- DEC: .GTIPQ IPCF flags/quotas
	XWD WAYJMP,CPOPJ	;PDB	;(110)- DEC: Job logical name table
	XWD WAYJMP,CPOPJ	;PDB	;(111)- DEC: ADRBRK word for job
	XWD WAYJMP,CPOPJ	;NONE	;(112)- DEC: .GTCMP Obsolete
	XWD WAYJMP,CPOPJ	;.GTVM	;(113)- DEC: General VM Info by Item
	XWD WAYJMP,CPOPJ	;JBTVRT	;(114)- DEC: Paging rate for job
	XWD WAYJMP,CPOPJ	;.GTSST	;(115)- DEC: Scheduler statistics
	XWD WAYJMP,CPOPJ	;.GTDCF	;(116)- DEC: Desired use fract/chan
	XWD NOMXL+WAYRUN+J,JBTST2##	;(117)- Second job status word
	XWD WAYJMP,CPOPJ	;JBTSCD	;(120)- DEC: Job type/Scheduler Class
	XWD WAYJMP,CPOPJ	;CLSSTS	;(121)- DEC: Scheduler Class quotas
	XWD WAYJMP,CPOPJ	;NONE	;(122)- DEC: .GTCOJ Obsolete
	XWD WAYJMP,CPOPJ	;SIDOFS	;(123)- DEC: Class runtime since quota set
	XWD WAYJMP,CPOPJ	;NONE	;(124)- DEC: .GTSQH Obsolete
	XWD WAYJMP,CPOPJ	;NONE	;(125)- DEC: .GTSQ  Obsolete
	XWD WAYJMP,CPOPJ	;.GTSID	;(126)- DEC: .GTSID Special PID table
	XWD WAYJMP,CPOPJ	;.EQTAB	;(127)- DEC: .GTENQ ENQ/DEQ statistics
	XWD NOMXL+WAYRPI+J,JBTUID	;(130)- .GTJLT UDT at LOGIN (DEC:JBTJLT)
	XWD WAYJMP,CPOPJ	;PDB	;(131)- DEC: .GTEBT EBOX time/jiffies
	XWD WAYJMP,CPOPJ	;PDB	;(132)- DEC: .GTEBR EBOX jiffy remainder
	XWD WAYJMP,CPOPJ	;PDB	;(133)- DEC: .GTMBT MBOX time/jiffies
	XWD WAYJMP,CPOPJ	;PDB	;(134)- DEC: .GTMBR MBOX jiffy remainder
	XWD NOMXL+WAYRPI,['DSKB  ']	;(135)- .GTRDV program run device
	XWD NOMXL+WAYRPI+J,JBTFPN;PDB	;(136)- .GTRDI program run directory
	XWD NOMXL+WAYRPI+J,JBTPRG##	;(137)- .GTRFN program run filename
	XWD WAYJMP,CPOPJ;  JBTXXX;PDB	;(140)- .GTDFL User defaults for job
	XWD WAYJMP,CPOPJ	;NETGTT	;(141)- DEC: .GTNTP Network perf data
	XWD WAYJMP,CPOPJ	;SCDPER	;(142)- DEC: .GTSPA Scheduler perf data
	XWD WAYJMP,CPOPJ	;PDB	;(143)- DEC: .GTVKS Virtual KCT
	XWD WAYJMP,CPOPJ;  JBTXXX;PDB	;(144)- .GTUUC Monitor Calls XCT'd
	XWD WAYJMP,CPOPJ	;PDB	;(145)- DEC: .GTRS0
	XWD WAYJMP,CPOPJ	;PDB	;(146)- DEC: .GTRS1
	XWD WAYJMP,CPOPJ	;PDB	;(147)- DEC: .GTRS2
	XWD WAYJMP,CPOPJ	;PDB	;(150)- DEC: .GTRS3
	XWD WAYJMP,CPOPJ	;PDB	;(151)- DEC: .GTRS4
	XWD NOMXL+WAYRFI+J,JBTPC	;(152)- .GTPC I/O wait DDB/PC
;*; End of currently defined GETTAB tables
;	XWD NOMXL+WAYRFI+J,JBTPRV;PDB	;(153)- DEC: .GTCAP job capabilities
;					;Max possible privs, used by ENABLE command
;	XWD WAYJMP,CPOPJ	;RNGTAB	;(154)- DEC: .GTIDX min,max table range
;	XWD WAYJMP,CPOPJ	;NUMTAB	;(155)- DEC: .GTGTB gettab immediate
;	XWD XXXMXL+J,XXXTBL	;TTTWDT	;(156)- DEC: .GTTNM terminal type names
;	XWD WAYJMP,CPOPJ	;PDB	;(157)- DEC: .GTOBI WTO & Batch data
;	XWD WAYJMP,CPOPJ	;DVCSTS	;(160)- DEC: .GTDCD coni/datai for DSB
;	XWD WAYJMP,CPOPJ	;NDBTBL	;(161)- DEC: .GTNDB byt ptrs to NDB
;	XWD WAYJMP,CPOPJ	;JBTPDB	;(162)- DEC: .GTPDB PP pages, PDB addr
;	XWD WAYJMP,CPOPJ	;PDB	;(163)- DEC: .GTEQJ ENQ/DEQ queue header
;	XWD XXXMXL+WAYSYS+J,XXXTBL	;(164)- DEC: Set DEFAULT cmd args
;	XWD NOMXL+WAYRPI+J,JBTXXX;PDB	;(165)- DEC: .GTLBS disk buffer sizes
;	XWD WAYJMP,CPOPJ	;PDB	;(166)- DEC: .GTPTR program to run
;	XWD WAYJMP,CPOPJ	;PDB	;(167)- DEC: .GTSTM UDT of last RESET
;	XWD WAYJMP,CPOPJ	;DCNGTB	;(170)- DEC: .GTDNT decnet v3 q headers
;	XWD WAYJMP,CPOPJ	;PDB	;(171)- DEC: .GTSJB decnet session CB
;	XWD WAYJMP,CPOPJ	;NONE	;(172)- DEC: .GTNSP (DEC Reserved)
;	XWD WAYJMP,CPOPJ	;.GTNDA	;(173)- DEC: .GTNDA Node data blk addr
;	XWD WAYJMP,CPOPJ	;OJBTAB	;(174)- DEC: .GTAOT ANF10 Obj Translation	

ENDGTB==.-1
GTTBLN==.-NUMTAB			;LENGTH OF TABLE
;MUUO TO SET CURRENT PROGRAM NAME
;	MOVE AC,[SIXBIT /NAME/]
;	ALWAYS RETURN

SETNAM:	MOVEM	T1,JBTNAM(J)	;STORE PROGRAM NAME FOR SYSTAT AND SYSDPY
	SETZM	JBTFPN(J)	;ZERO THIS OUT FOR CHAIN FROM LOADER
	MOVEI	T1,3		;Do NOT change accounting info in JBTPRG
	PJRST	ACTWRT		;WRITE TYPE 3 ACCOUNTING RECORD AND RETURN

TRUGN:	PUSHJ	P,TIMADJ	;READ CLOCK AND UPDATE COUNTS
	PUSHJ	P,CHKSEG
	  POPJ	P,		;CAN NOT GIVE HIM THIS INFO
	PUSHJ	P,CLKTRU	;CALCULATE TRU'S
	UMOVEM	T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST	CPOPJ1		;AND SKIP RETURN.

	INTERNAL CLKTRU,CHKSEG,CHKSGJ

TRUGN2:	PUSHJ	P,TIMADJ
	PUSHJ	P,CHKSEG
	 POPJ	P,		;JUST LIKE ABOVE
	PUSHJ	P,CLKTRU
	UMOVEM	T2,(M)		;BUT STORE HIGH PART
	JRST	CPOPJ1

;-THREE GETTABS WHICH RETURN DOUBLE-PRECISION QUANTITY
;	IN AC,AC+1 (NO WRAPAROUND).

TRUGET:	PUSHJ	P,TIMADJ
	PUSHJ	P,CHKSEG
	  POPJ	P,		;JUST LIKE ABOVE
	PUSHJ	P,CLKTRU
	UMOVEM	T1,1(M)		;LOW ORDER TO AC+1
	UMOVEM	T2,(M)		;HI TO AC
	JRST	CPOPJ1
KCTGET:	PUSHJ	P,TIMADJ
	PUSHJ	P,CHKSEG
	  POPJ	P,
	MOVE	T1,JBTCPU(J)
	UMOVEM	T1,(M)
	MOVE	T1,JBTKCT(J)
	UMOVEM	T1,1(M)
	JRST	CPOPJ1
MCYGET:	PUSHJ	P,TIMADJ
	PUSHJ	P,CHKSEG
	  POPJ	P,
	MOVE	T1,JBTCP2(J)
	UMOVEM	T1,(M)
	MOVE	T1,JBTCMP(J)
	UMOVEM	T1,1(M)
	JRST	CPOPJ1

;ROUTINE TO RETURN JBTPWH/JBTPWL.
PWSGET:	PUSHJ	P,CHKSEG
	  POPJ	P,
	MOVE	T1,JBTPWH(J)
	UMOVEM	T1,(M)
	MOVE	T1,JBTPWL(J)
	UMOVEM	T1,1(M)
	JRST	CPOPJ1

;TEMPORARY ROUTINE TO FAKE UP IMGIN AND IMGOUT IN JBTSWP

SIMJSW:	CAILE	J,JOBMAX	;IN RANGE?
	  POPJ	P,		;NO, FORGET IT.
	HLRZ	T1,JBTUPM(J)	;GET NUMBER OF EXISTENT PAGES
	MOVE	T2,T1		;COPY INTO T2
	LSH	T1,^D9		;SHIFT IT INTO OTHER PLACE
	IOR	T1,T2		;GET INTO BOTH IMGIN AND IMGOUT
	UMOVEM	T1,(M)		;STORE RETURN VALUE
	JRST	CPOPJ1		;AND RETURN.
	DEFINE SINGL1 (MULT,QUANT,%%X,%%Y),<IFG %%X+%%Y-5,<%%Z==1
	REPEAT %%X+%%Y-5,<%%Z==%%Z*^D10>
	PUSH	P,T2
	OPSET	(IDIV,T1,%%Z)
	EXCH	T1,(P)
	EXCH	T1,T2
	OPSET	(DIV,T1,%%Z)
	MOVE	T2,T1
	POP	P,T1>
	ADD	T2,-1(P)
	TLZE	T2,(1B0)
	ADDI	T1,1
	MOVEM	T2,-1(P)
	ADDM	T1,(P)
>  ;end DEFINE SINGL1

	DEFINE OPSET (OP,AC,ARG),<
 IFG ARG-777777,<OP AC,[ARG]>
IFLE ARG-777777,<OP'I AC,ARG>
>  ;end DEFINE OPSET

	DEFINE SINGLE (MULT,QUANT),<
%%X==0
%%Y==0
IRPC MULT,<%%X==%%X+1>
IRPC QUANT,<%%Y==%%Y+1>
%%Z==1
REPEAT 5-%%X-%%Y,<%%Z==%%Z*^D10>
	OPSET(MUL,T1,^D'MULT*%%Z)
	SINGL1(MULT,QUANT,%%X,%%Y)
>  ;end DEFINE SINGLE

	DEFINE SINGLL(VAL,MULT,QUANT),<
	MOVE T1,JBT'VAL(J)
	SINGLE(MULT,QUANT)
>  ;end DEFINE SINGLL

	DEFINE DOUBLE(VAL1,VAL2,MULT,QUANT),<
	MOVE T1,JBT'VAL1(J)
	MOVE T2,JBT'VAL2(J)
	OPSET(IMUL,T1,^D'MULT)
	PUSH P,T1
	MOVE T1,T2
	OPSET(MUL,T1,^D'MULT)
	ADDM T1,(P)
	POP P,T1
%%X==0
%%Y==0
IRPC MULT,<%%X==%%X+1>
IRPC QUANT,<%%Y==%%Y+1>
	SINGL1(MULT,QUANT,%%X,%%Y)
>  ;end DEFINE DOUBLE
COMMENT !  CLKTRU: CALCULATE DOUBLE-PRECISION TRU'S &
	RETURN IN T1 (LOW), T2 (HI).

	IN THE MACRO CALLS 'DOUBLE', 'SINGLE', & 'SINGLL'
	THE CONSTANTS HAVE THESE MEANINGS:
  DOUBLE(V1,V2,RATE,QUANT)..THE D.P. ENTITY (V1,V2) CHARGES AT
  0.RATE TRU'S PER QUANTITY OF ENTITY..IE, 0.03371 TRU'S
   PER 100,000 [MICROCYCLES*SIZE]
 SINGLL(V,RATE,QUANT)..  0.RATE TRU'S PER QUANT OF V
 SINGLE(RATE,QUANT)..  0.RATE TRU'S PER QUANT OF ITEM IN T1

WHEN CHANGING THIS ALGORITHM, PLEASE CHANGE (MONDOC)TRUFRM.DOC
AND THE FORTRAN COST CALCULATION PROGRAM APPROPRIATELY, AND
SEND OUT A MEMO TO THE PEOPLE WHO NEED TO KNOW ABOUT THE CHANGE.
!
EXTERNAL JBSRCT,JBRIRD,JBYSC1,JBYSC2

	SALL
CLKTRU:	PUSH	P,[0]		;Double precision running total
	PUSH	P,[0]		; is accumulated on top of PDL

;; First, compute the size-independent components.

	DOUBLE (CP2,CMP,9004,100000) ;Double-precision micro-cycles
	SINGLL(SOK,001,1)	;SOAKEM UUO charges

	MOVE	T1,JBTCOT(J)	;Characters out
	ADD	T1,JBTCIN(J)	;Characters in
	SINGLE(856,1000)

	SINGLL(BET,004,1)	;Elapsed time in block i/o mode
	SINGLL(BIO,4,1000)	;Block i/o characters in+out
	SINGLL(MPC,000168,1)	;ONE-TENTH DISK READ FOR MAP.
	SINGLL(PWS,02696,1)	;# pages put into UWS

	MOVE	T1,JBTERN(J)	;Enters + renames
	LSH	T1,2
	ADD	T1,JBTDLK(J)	;Lookups
	IMULI	T1,3
	MOVE	T2,JBTRCT(J)	;Disk blocks read
	ADD	T2,JBTWCT(J)	;Disk blocks written
	SKIPE	J		;NOT FOR JOB 0
	  TLZ	T2,JBRIRD_<JBSRCT-^D18> ;ONLY LOW ORDER 24 BITS
	ADD	T1,T2
	SINGLE (00674,1)

;; Before performing the kilocore-dependent calculations, see if
;; a kilocore-independent scale factor should be applied (from the
;; XCHARG TRU-scaling call) - any size-dependent TRU scaling is
;; done by adjusting the charging size in GTCGSZ.

	LDB	T2,JBYSC1	;Is there a scale factor numerator?
	JUMPE	T2,CLKTRX	;Jump around code if not
	IMULM	T2,0(P)		;First, multiply high-order word
	MOVE	T1,-1(P)	;Copy low-order word
	MUL	T1,T2		;D.P. result clobbers T2
	ADDM	T1,0(P)		;Sum up high-order partial products
	MOVEM	T2,-1(P)	;Save new low-order word

	LDB	T1,JBYSC2	;Get divisor
	EXCH	T1,0(P)		;Save divisor, get high-order product
	IDIV	T1,0(P)		;T1 gets quotient, t2 gets remainder
	EXCH	T1,T2		;T2  "      "    , T1  "       "
	EXCH	T2,-1(P)	;-1(P) gets high-order quotient, T2
				; gets low-order product
	DIV	T1,0(P)		;T1 gets (T1,,T2)/0(P)
	TLZE	T1,400000	;Correct for double precision
	  AOS	-1(P)		;Carry into high-order word
	EXCH	T1,-1(P)	;Swap low-order quot. with high-order
	MOVEM	T1,0(P)		;Store high-order quotient

;; Now, calculate all the size-dependent components (i.e.,
;;   units*size.

CLKTRX:
	DOUBLE (CPU,KCT,03371,100000) ;D.P. microcycles*size
	DOUBLE (PWH,PWL,00154,10000) ;D.P. <pgs put in UWS>*size
	SINGLL(ELP,00016,1)	;<Elapsed time>*size
	SINGLL(BCS,00535,1)	;<Break chars seen>*size

	MOVE	T1,JBTSER(J)	;<Enters + Renames>*size
	LSH	T1,2
	ADD	T1,JBTSLK(J)	;Lookups*size
	IMULI	T1,3
	ADD	T1,JBTSIN(J)	;<Disk blocks read>*size
	ADD	T1,JBTSOT(J)	;<Disk blocks written>*size
	SINGLE(00077,1)
;; Calculation complete, get double-precision result from PDL
;;   into T1 and T2.

	POP	P,T2
	POP	P,T1
	POPJ	P,		;ALL CALCULATED T1 IS LOW PART T2 HIGH
	XALL

JOBLIN:	PUSHJ	P,CHKSEG		;CAN HE GET THIS INFO
	  POPJ	P,			;NO
	HRRZ	T1,TTYTAB(J)		;IS THERE ONE THERE??
	JUMPE	T1,[UMOVEM T1,(M)	;STORE IN USER'S AREA.
		    POPJ   P,]		;AND RETURN.
	MOVE	T1,DEVNAM(T1)		;YES, GET NAME, (ELSE RET 0)
	UMOVEM	T1,(M)			;MOVE TO USER'S AREA.
	JRST	CPOPJ1			;AND SKIP RETURN.

; GETLNK--FOR LINKED GETTAB. SCAN LIST STRUCTURE
;  & RETURN VALUES. USED FOR TEMP DEBUGGING TABLES
;  PUT IN MONITOR.  USED AS FOLLOWS:
;  MOVE AC,[EVEN'INDEX,,-36]
;  GETTAB AC,
;   OOPS
;  RETURN AC=SIXBIT TABLEE NAME.  DO  I WANT THIS TABLE?
;  NO..EVEN'INDEX:=EVEN'INDEX+2 & GETTAB AGAIN
;  YES..EVEN'INDEX:=EVEN'INDEX+1
;  GETTAB AC,
;   ..
;  RETURN AC=DATA FROM TABLE PREVIOUSLY NAMED

COMMENT !   DATA STRUCTURE:
1. A LINKED (IN RH) LIST OF 2-WD HEADER BLOCKS BEGINNING
  AT LNKHED, INITIALIZED BY LOADER.  LAST RH=0.  FORMAT OF
  HEADER BLOCK:
2. HEADER: XWD COUNT,NEXT'HEADER  (COUNT IS SIZE OF NAME & VALUE TABLES)
	XWD NAME'TABLE,VALUE'TABLE
3. FORMAT OF NAME'TABLE:
	NAME'TABLE: SIXBIT /NAME/	(I.E., /JBTXXX/, ETC.)
	SIXBIT /NAME/
	..
	.. (TOTAL OF COUNT ENTRIES)
4. FORMAT OF VALUE TABLE ANALAGOUS
!
GETLNK:	MOVSI	T1,LICSYS!LICSPY
	MOVE	T2,JOB
	TDNN	T1,JBTLIC(T2)
	  POPJ	P,		;NEED SYSTAT LIC
	HRRZ	T2,LNKHED	;GET POINTER TO LIST
LNKLP:	JUMPE	T2,CPOPJ	;COUNT TOO BIG, NON-SKIP RETURN
	HLRZ	T1,(T2)		;GET COUNT
	LSH	T1,1		;*2 FOR NAMES
	CAMGE	J,T1
	  JRST	LNKFND		;THIS IS THE RIGHT PLACE
	SUB	J,T1		;DECREASE DESIRED COUNT
	HRRZ	T2,(T2)
	JRST	LNKLP		;AND CONTINUE

LNKFND:	ROT	J,-1		;DIVIDE BY 2 AND REM TO HIGH BIT
	SKIPL	J		;SEE IF EVEN OR ODD
	  SKIPA	T1,1(T2)	;EVEN, NAME POINTER
	 HLRZ	T1,1(T2)	;ODD, DATA POINTER
	ADD	T1,J
	MOVE	T1,(T1)
	UMOVEM	T1,(M)		;INFO TO USER'S AREA.
	JRST	CPOPJ1		;AND SKIP RETURN.

LNKHED:	0
	.ELINK 1,LNKHED	;SET UP LINK
SUBTTL XCHARG

EXTERNAL SAVCHG,CHGSIZ,UPTCHG

COMMENT ! XCHARG UUO SEVERAL FUNCTIONS

CALL:	MOVE AC,[-COUNT,,ADDR]
	XCHARG AC,
	 ERROR RTN, AC/CODE FUNCTIONS 4 OR 5 ONLY
	OK RTN, AC/UNCHANGED
LOC:	FUNCTION NUMBER
	BITMASK,SOME FUNCTIONS
	TABLE SPACE
	.	.
	.	.
LICENSE: SOME FUNCTIONS REQUIRE XC LICENSE

DESTROYS: PRACTICALLY ALL AC'S

!




XCHARG:	UMOVE	T2,(T1)	;CODE
	SKIPL	T2
	CAIL	T2,XCHFUN	;SEE IF IN RANGE
	  POPJ	P,
	PUSHJ	P,TIMADJ	;UPDATE CLOCK CHARGES BEFORE
				;ANY READ,RESET,ETC.
	XCT	XCHFNT(T2)

XCHFNT:	JRST	XCHSAV		;SAVE (0)
	JRST	XCHRED		;READ SAVED (1)
	JRST	XCHCRD		;READ CURRENT (2)
	JRST	CPOPJ		;NO-OP. WAS RESET CHARGES (3) JRST XCHRST
	JRST	XCHF4		;RESET & SAVE CHARGES (4). USE USER DATA
	JRST	XCHF5		;FN 5,TRANSACTION CHARGE RECORD
	JRST	XCHF6		;FN 6 TRU COMPONENT CHECKPOINT RECORD
	JRST	XCHSCA		;FN 7, TRU Scaling
XCHFUN==.-XCHFNT

XCHCTB:	400000,,JBTCPU(J)	;SIGN BIT SEZ "WORD 1 OF D.P. VALUE".
	JBTKCT(J)
	400000,,JBTCP2(J)	;MICROCYCLES NOW D.P. P031
	JBTCMP(J)
	JBTELP(J)
	JBTBCS(J)
	JBTCIN(J)
	JBTCOT(J)
	JBTBET(J)
	JBTBIO(J)
	JBTSER(J)
	JBTSLK(J)
	JBTSIN(J)
	JBTSOT(J)
	JBTERN(J)
	JBTDLK(J)
	JBTRCT(J)
	JBTWCT(J)
	JBTMPC(J)
	JBTPWS(J)
	400000,,JBTPWH(J)
	JBTPWL(J)

XCHFLN==.-XCHCTB

XCHSAV:	MOVSI	T1,-XCHFLN	;NUMBER OF SOURCES
	MOVSI	T2,-CHGSIZ	;NUMBER OF SAVES
	MOVSI	T3,SAVCHG
	IORM	T3,%UPT+UPTSTS	;SAVE IN STATUS WORD
XCHSV1:	MOVE	T3,@XCHCTB(T1)
	MOVEM	T3,%UPT+UPTCHG(T2)
	AOBJP	T2,CPOPJ1
	AOBJN	T1,XCHSV1
	JRST	CPOPJ1		;DON'T OVERRUN EITHER

XCHRED:	AOBJP	T1,CPOPJ	;NUMBER REQUESTED
	UMOVE	T2,(T1)
	MOVSI	T3,-XCHFLN
	MOVSI	T4,SAVCHG
	TDNN	T4,%UPT+UPTSTS
	  POPJ	P,		;NOTHING SAVED
XCHRD1:	TLNN	T2,(1B0)
	  JRST	XCHRD2
	MOVE	T4,%UPT+UPTCHG(T3)
	AOBJP	T1,CPOPJ1
	UMOVEM	T4,(T1)
XCHRD2:	LSH	T2,1
	JUMPE	T2,CPOPJ1
	AOBJN	T3,XCHRD1
	JRST	CPOPJ1
XCHCRD:	AOBJP	T1,CPOPJ	;GET BITS
	UMOVE	T2,(T1)
	MOVSI	T3,-XCHFLN
XCHCR1:	TLNN	T2,(1B0)
	  JRST	XCHCR2
	MOVE	T4,@XCHCTB(T3)
	AOBJP	T1,CPOPJ1
	UMOVEM	T4,(T1)
XCHCR2:	LSH	T2,1
	JUMPE	T2,CPOPJ1
	AOBJN	T3,XCHCR1
	JRST	CPOPJ1

COMMENT ! ;-CHANGE SEPT 76 A.ATKINSON TO WRITE STREAM
XCHRST:	MOVSI	T2,LICXC	;CAN HE DO IT
	TDNN	T2,JBTLIC(J)
	  POPJ	P,		;NO
	AOBJP	T1,CPOPJ	;NO BITS
	UMOVE	T2,(T1)
	MOVSI	T3,SAVCHG
	TDNN	T3,%UPT+UPTSTS
	  POPJ	P,		;CHARGES NOT SAVE SINCE LAST RESET
	AOBJP	T1,XCHRS0
	UMOVE	T3,(T1)		;GET SOAK CHARGE
	MOVE	T1,T3		;GET A COPY
	ADD	T3,JBTSOK(J)
	JUMPLE	T3,XCHRS0
	MOVEM	T3,JBTSOK(J)
	ADDM	T1,JBTSOK
XCHRS0:	MOVSI	T1,-CHGSIZ
	MOVSI	T3,-XCHFLN
	TLNE	T2,(3B1)
	  TLO	T2,(3B1)	;THESE MUST BOTH BE TOGETHER (DOUBLE PRECISION WORDS)
XCHRS1:	TLNN	T2,(1B0)
	  JRST	XCHRS2
	MOVE	T4,%UPT+UPTCHG(T1)
	MOVEM	T4,@XCHCTB(T3)
XCHRS2:	AOBJP	T3,CPOPJ1
	AOBJP	T1,CPOPJ1
	LSH	T2,1
	JUMPN	T2,XCHRS1
	JRST	CPOPJ1
;-NOW FOLLOWS CODE TO DO ABOVE FUNCTION PLUS WRITE ACT REC
!
REPEAT 0,<	;REMOVE THIS FUNCTION. AAA 15 NOV
XCHRST:	MOVSI	T2,LICXC
	TDNN	T2,JBTLIC(J)
	  POPJ	P,
	AOBJP	T1,CPOPJ
	UMOVE	P2,(T1)	;-P2:=USER BITMASK
	MOVSI	T3,SAVCHG
	TDNN	T3,%UPT+UPTSTS
	  POPJ	P,		;-DIDNT SAV CHGS
	AOSE	ACREQ		;-IF ANYONE WAITING ON ACT DEVICE,
	PUSHJ	P,ACWAIT	;-WE WAIT TOO
	PUSH	P,T1		;-SAV FOR XCHRS0
	MOVEI	P1,XCHARL	;SIZE REC WE'D LIKE TO WRITE
	PUSHJ	P,BACTJB	;-MAY WE WRITE ACT?
	 JRST	[SETO U,	;-NO. U:=FLAG NO ACT & GO
		 JRST XCHRS0]	;-DO THE UUO WITHOUT ACT RECORD
	 JRST	[JFCL ACREQ	;-CANT WRITE AT THE MOMENT,
		 PUSHJ P,ACWAIT	;-WAIT TIL BUFF EMPTIED BY
		 JRST .+1]	;-ACT OWNER, THEN CONTINUE
;-DOUBLE SKIP RTN, CAN WRITE IMMEDIATELY.
	SETZ	U,		;-U:=FLAG "YES", DO UUO WITH ACT RECORD
XCHRS0:	POP	P,T1		;-USER ARG PTR
	AOBJP	T1,XCHRS1	;-GO AHEAD IF NO SOAKEM VALUE
	UMOVE	T3,(T1)		;-SOAKEM VALUE TO
	ADD	T3,JBTSOK(J)	;-ADD TO SOAKEM
	JUMPLE	T3,XCHRS1
	MOVEM	T3,JBTSOK(J)
	UMOVE	T3,(T1)
	ADDM	T3,JBTSOK
;-WRITE 4-WD HEADER PART OF ACT RECORD
XCHRS1:	JUMPL	U,XCHRS2	;U=-1 IF NOT DOING ACT REC
	PUSHJ	P,CBLAMB	;-T1:=LENGTH,T2:=LOC OF BUFFER SPACE
	MOVEI	T3,XCHTAR	;-XCHARG REC TYPE
	MOVEI	T4,XCHARL	;-&LENGTH
	PUSHJ	P,WACRHW	;-WRITE  HEADER WORDS,RETURN T1,T2
				;-FOR MORE WRITING IN ACTBUF
	MOVE	T3,JBTNAM(J)	;-WHO IS GIVING AWAY TRU'S?
	PUSHJ	P,PUTBUF	;-RECORD IT
	MOVE	T3,JBTFPN(J)
	PUSHJ	P,PUTBUF
	MOVE	T3,JBTSOK(J)
	PUSHJ	P,PUTBUF
XCHRS2:	MOVSI	P1,-CHGSIZ	;-SET UP LOOP CONTROL
	MOVSI	P3,-XCHFLN

;-IN THE FOLLOWING CODE, REGISTER ASSIGNMENTS ARE:
;-P1: AOBJN INDEX IN UPT ARRAY
;-P3: AOBJN INDEX IN XCHCBT ARRAY
;-T1: LENGTH OF REMAINING ACTBUF AREA, AS RET'D BY CBLAMB
;-T2: LOC OF THIS BLOCK,
;-T3: DATA VALUE PASSED TO PUTBUF TO STORE IN ACTBUF
;-T4: SECOND HALF OF DOUBLE-PREC. VALUES, FIRST IN T3.
;-U: FLAG -1 IF NO ACT WRITE,0 IF YES
;-P2: USER'S BITMASK OF VALUES TO BE RESET

;-IF BITMASK VALUE IS 0 (RESET NOT DESIRED FOR THIS COMPONENT)
;-THEN JBT'S ARE RESET WITH THEMSELVES & 0 WRITTEN TO ACTBUF.

XCHRS3:	SKIPG	XCHCTB(P3)	;SKIP IF SINGLE-PRECISION COMPONENT
	  JRST	XCHRSD		;DOUBLE
	TLNN	P2,(1B0)
	  SKIPA	T4,@XCHCTB(P3)	;FORCE DIFF=0 & NO RESET
	MOVE	T4,%UPT+UPTCHG(P1)
	MOVE	T3,@XCHCTB(P3)
	SUB	T3,T4
	SKIPL	U		;ACT WRITE WANTED?
	PUSHJ	P,PUTBUF	;YES.T3=DIFF OR ZERO TO ACTBUF
	MOVEM	T4,@XCHCTB(P3)	;RESET OR RESTORE JBT

;-LOOP TEST
XCHRLT:	AOBJP	P1,XCHRFA	;FINISH ACTBUF IF UPT DONE
	LSH	P2,1		;NEXT BIT IN USER MASK
	AOBJN	P3,XCHRS3	;LOOP WHILE XCHCTB VALUES REMAIN,THEN FALL THRU
;-FINISH ACT
XCHRFA:	JUMPL	U,CPOPJ1	;-IF NO ACT,DONE SKIP RTN
	SETZ	T3,		;-0 TO FINISH OUT XCHARG RECORD
;-WHILE P3=XCHFLN INDEX NOT FINISHED,WRITE ZEROS TO
;-COMPLETE XCHARL- WORD RECORD
;-WHEN DONE, FINACB IN ACTSER CLEAN UP & UNINTERLOCK
XCHRF2:	AOBJP	P3,FINACB
	PUSHJ	P,PUTBUF	;PUT 0
	JRST	XCHRF2

;-XCHRSD..DOUBLE PRECISION ROUTINE. VALUES D.P. IN XCHCTB
;-HAVE 1ST WORD FLAGGED IN XCHCBT SIGN BIT.

XCHRSD:	TLNN	P2,(3B0)	;SKIP IF EITHER OF 2 WDS OF DP IS TO BE RESET
	 JRST	[PUSH P,@XCHCTB(P3);PUT CURRENT VALUE INTO
		 PUSH P,@XCHCTB+1(P3);-1(P) HIGH,(P) LOW ORDER,
		 JRST XCHRD0]	;FORCE DIFF=0 & NO UPDATE
	PUSH	P,%UPT+UPTCHG(P1)
	PUSH	P,%UPT+UPTCHG+1(P1)	;SAVED INTO -1(P),(P)
XCHRD0:	MOVE	T3,@XCHCTB(P3)
	MOVE	T4,@XCHCTB+1(P3)
	SUB	T4,(P)		;LOW ORDER-LOW
	SUB	T3,-1(P)	;HI - HI
	TLZE	T4,(1B0)	;TEST/RESET CARRY,SKIP IF NONE
	  SUBI	T3,1
;NOW T3/T4=D.P. DIFFERENCE (OR ZERO IF P2&3B0=0), -1(P)/(P)=
;RESET/RESTORE VALUE
	JUMPL	U,XCHRD1	;WANT ACT WRITE,JUMP IF NO
	PUSHJ	P,PUTBUF	;HI ORDER TO ACTBUF
	MOVEM	T4,(T2)		;LOW ORDER TO BUF
	PUSHJ	P,MORBUF	;ADVANCE PTR ONE
XCHRD1:	POP	P,@XCHCTB+1(P3)	;RESET/RESTORE LOW ORDER TO JBT'S
	POP	P,@XCHCTB(P3)	;HI ORDER
;ADVANCE P1 P2 P3 ONE TO ACCOUNT FOR 2ND WORD OF DP PAIR
	AOBJP	P1,.+1
	AOBJP	P3,.+1
	LSH	P2,1
	JRST	XCHRLT		;NOW PERFORM LOOP TEST
>;END REPEAT 0 TO REMOVE XCHRST FN 3
;XCHF4..RESET CHARGES, USING VALUES FROM USER. PERFORM
;	SIMULTANEOUS SAVE OF NEW VALUES (IMPLICIT FN 0).
;	REQUIRE THAT CURRENT.GE. USER .GE. SAVED  FOR
;	EVERY COMPONENT TOUCHED. IF THIS IS UNTRUE, NO
;	CHANGE TO CURRENT OR SAVED FOR THAT COMPONENT.

;-EXTERNALS FROM ACTSER & SCHEDULER
EXTERNAL GETABS,FINACB,PUTBUF,MORBUF,WACRHW
XCHARL==XCHFLN+^D8	;XCHARG REC LENG=
;	5 HEADER WRDS
;	1 JBTNAM
;	1 JBTFPN
;	1 JBTSOK
;  XCHFLN  DIFFERENCES


INTERNAL XCHARL ;REF'D IN ACTSER CODE
XCHTAR==10		;XCHARG ACT REC TYPE

;ERROR RETURNS.
XCF4NL:	JSP	P4,XC4FR	;NO LIC (0)
XCF4NS:! JSP	P4,XC4FR	;NO PREVIOUS SAVE (1)
XCF4NA:! JSP	P4,XC4FR	;NO ACCT'G (2) .. SYS UP FOR FREE
XCF4BC:!			;BAD COMPONENT (3) HANDLED SPECIALLY
XCF7BC:! JSP	P4,XC4FR	;Except for fn 7
XCF4BA:! JSP	P4,XC4FR	;BAD AC (4)
XCF4BB:! JSP	P4,XC4FR	;BAD BITMASK (5)
XC4FR:!	SUBI	P4,XCF4NL+1
	XCTBU	<HRRZM P4,(M)>	;MOVE ERR CODE RH P4 TO USER AC
	POPJ	P,

UBMASK:	Z	;USERS BITMASK
XCBADC: Z	;FOR SAVE BAD COMPONENT BIT POSITIONS FOUND

DEFINE CURRENT(OFFSET<0>)<@XCHCTB+OFFSET(P3)>
DEFINE SAVVAL(OFFSET<0>)<%UPT+OFFSET+UPTCHG(P1)>
DEFINE HISAV <%UPT+UPTCHG(P1)>
DEFINE LOSAV <%UPT+UPTCHG+1(P1)>

;REGISTER ASSIGN IN LOOP WHICH DOES THE WORK:
; P4-TRAVELLING BIT FOR UBMASK TEST
; P3-XCHCTB AOBJN
; P2-USER AOBJN
; P1-UPT AOBJN

;T1-CBLAMB/PUTBUF/MORBUF BLOCK SIZE
;T2-BLOCK ADDRESS WITHIN ACTBUF
;T3-
;T4-WORKING STORAGE. T3 IS ARG TO PUTBUF
;M- USER AC #
;U-DATA FOR DP COMPARE
;PG- DATEA FOR DP COMPARE

;NAMES OF REGISTERS FOR HELP IN UNDERSTANDING CODE. NOTE U,PG
HICUR==T3
LOCUR==T4
HIUSR==U
LOUSR==PG	;U,PG ARE NOT  CONSECUTIVE

;HERE WHEN A SINGLE PRECISION COMPONENT IS BAD
.XCBSP:	IORM	P4,XCBADC	;RECORD WHICH COMPONENT WAS BAD
	SETZB	HICUR,LOCUR
	JRST	.XCACCT
;HERE IF BAD DP COMP
.XCBDP:	IORM	P4,XCBADC
	SETZB	HICUR,LOCUR
	JRST	.XCDACCT

XCHF4:	MOVSI	T2,LICXC
	TDNN	T2,JBTLIC(J)
	  JRST	XCF4NL		;ERR RTN 0
	AOBJP	T1,XCF4BA	;T1:= -(COUNT-1),,LOC+1
	HLRE	T2,T1		;T2/-(COUNT-1)
	MOVNS	T2
	ADDI	T2,-1(T1)	;T2/ADDR LAST WD IN ARG BLK
	UMOVE	T2,(T2)		;MAKE SURE CAN READ IT
	UMOVE	T2,(T1)		;T2:=USER BITMASK
	HLRZ	T3,T1		;BEGIN CHECKOUT COUNT,MASK
	CAIGE	T3,-3		;T3=0,,7777XX E=0,,777775
	CAIG	T3,-XCHFLN-2	;-(XCHFLN+1) .LE. COUNT .LE. -4
	  JRST	XCF4BA		;COUNT BAD
	MOVSI	T4,(1B0)	
	ASH	T4,(T3)
	ANDCA	T4,T2
	JUMPN	T4,XCF4BB	;YES IF T4#0
	MOVSI	T3,SAVCHG	;CHECK IF PREVIOUS SAVE,
	TDNN	T3,%UPT+UPTSTS	;XCHARG FN 0
	  JRST	XCF4NS		;NO,COMPLAIN
	PUSH	P,T1		;USER AOBJN,SAVE FROM GETACB
	PUSH	P,T2		;USER BITMASK, SAVE
	MOVEI	P1,XCHARL	;LENGTH OF XCHARG RECORD
;MAY WE WRITE THE RECORD FOR THIS XCHARG
XCHBAJ:	PUSHJ	P,GETABS	;GET SPACE IN ACT BUFFER
	  JRST	[POP  P,T2	;UNWIND
		 POP  P,T1
		 JRST XCF4NA]	;STREAM DEAD, FRETURN
;NOW CAN WRITE
XCHF4A:	PUSHJ	P,CBLAMB	;T1:=SIZE,T2:=LOC OF BLOCK IN ACTBUF
	MOVEI	T3,XCHTAR	;REC TYPE
	MOVEI	T4,XCHARL	;LENGTH
	PUSHJ	P,WACRHW	;WRITE HEADER WDS
	MOVE	T3,JBTNAM(J)
	PUSHJ	P,PUTBUF
	MOVE	T3,JBTFPN(J)
	PUSHJ	P,PUTBUF
	MOVE	T3,JBTSOK(J)
	PUSHJ	P,PUTBUF
;PREPARE LOOP. RETREIVE USER AOBJN,BITMASK,SET MONITOR AOBJN'S
	POP	P,UBMASK
	POP	P,P2		;USER AOBJN,WAS IN T1 BEFORE
	AOBJP	P2,.+1		;NOW P2 PTS AT 1ST COMPONENT
	SETZM	XCBADC
	MOVSI	P3,-XCHFLN
	MOVSI	P1,-CHGSIZ
	MOVSI	P4,(1B0)	;TRAVELLING BIT FOR MASK TESTS
;LOOP TOP
XCF4L0:	SKIPG	XCHCTB(P3)	;SKIP IF SINGLE PRECISION
	  JRST	XCF4DP		;DOUBLE
	TDNE	P4,UBMASK	;SKIP IF NO RESET DESIRED THIS COMP
	  XCTFU	<SKIPA LOUSR,(P2)>
	MOVE	LOUSR,CURRENT
;LOUSR:=EITHER CURRENT OR USER
	MOVE	T4,SAVVAL
	MOVE	T3,CURRENT
	CAMG	LOUSR,T3
	CAMGE	LOUSR,T4
	  JRST	.XCBSP		;OUT OF RANGE,FLAG BAD COMP
	MOVEM	LOUSR,CURRENT
	MOVEM	LOUSR,SAVVAL
	SUB	T3,LOUSR
.XCACCT:
	PUSHJ	P,PUTBUF	;RECORD DIFFERENCE
;LOOP TEST,USED FOR BOTH S.P. AND D.P.
XCF4L1:	AOBJP	P1,XCF4L2
	LSH	P4,-1		;TRAVELLING BIT MOVES DOWN ONW
	AOBJP	P2,XCF4L2
	AOBJN	P3,XCF4L0	;NEXT COMPONENT
;LOOP END
;FINISH ACT RECORD WITH 0'S
XCF4L2:	SETZ	T3,
	AOBJP	P3,XCF4L3
	PUSHJ	P,PUTBUF
	JRST	XCF4L2
;CLEAN UP ACTBUF,RETURN FROM XCHARG UUO SKIP IF NO BAD COMP
XCF4L3:	PUSHJ	P,FINACB	;UNINTERLOCK,FIX BUFF PTRS
	  JFCL			;ALWAYS SKIPS, IGNORE
	SKIPN	T1,XCBADC	;SEE IF BAD COMPONENTS HIT,FRETURN IF SO
	  JRST	CPOPJ1
	IORI	T1,XCF4BC-XCF4NL;RETURN BITS 0-32=BITMASK, 33-35=CODE
	UMOVEM	T1,(M)
	POPJ	P,

;CODE FOR DOUBLE-PRECISION COMPONENTS
;	EXECUTED INSTEAD OF CODE BETWEEN XCF4L0+2,XCF4L2

XCF4DP:	TDNN	P4,UBMASK
	 JRST	[MOVE HIUSR,CURRENT	;<@XCHCTB+0(P3)>
		 MOVE LOUSR,CURRENT(1)	;<@XCHCTB+1(P3)>
		 JRST XCF4DA]
	UMOVE	HIUSR,(P2)
	UMOVE	LOUSR,1(P2)
XCF4DA:	MOVE	HICUR,CURRENT		;<@XCHCTB+0(P3)>
	MOVE	LOCUR,CURRENT(1)		;<@XCHCTB+1(P3)>
;(HIUSR,LOUSR) NOW = USER VALUE OR CURRENT IF NO RESET DESIRED
;TEST IF CURRENT .GE. USER .GE. SAVED IS TRUE
	CAMN	HIUSR,HICUR
	CAMG	LOUSR,LOCUR
	CAMLE	HIUSR,HICUR
	  JRST	.XCBDP		;BAD,USER .GT. CURRENT
	CAMN	HIUSR,HISAV
	CAML	LOUSR,LOSAV
	CAMGE	HIUSR,HISAV
	  JRST	.XCBDP		;BAD,USER .LT. SAVED
	MOVEM	HIUSR,SAVVAL
	MOVEM	LOUSR,SAVVAL(1)
	MOVEM	HIUSR,CURRENT		;<@XCHCTB+0(P3)>
	MOVEM	LOUSR,CURRENT(1)	;<@XCHCTB+1(P3)>
	SUB	LOCUR,LOUSR
	SUB	HICUR,HIUSR
	TLZE	LOCUR,(1B0)
	  SUBI	HICUR,1
.XCDACCT:
	PUSHJ	P,PUTBUF	;SAVE HI-ORDER DIFF
	MOVEM	LOCUR,(T2)	;AND LOW
	PUSHJ	P,MORBUF	;ADVANCE T1,T2
	LSH	P4,-1		;ADVANCE BIT & ALL AOBJN'S
	AOBJP	P1,.+1
	AOBJP	P2,.+1		;TO ACCOUNT FOR EXTRA
	AOBJP	P3,XCF4L1	;WORD ALREADY PROCESSED
	JRST	XCF4L1
;XCHARG FUNCTION 5 -- TRANSACTION RECORD OUTPUT

TRNTAR==:17	;TRANSACTION RECORD TYPE NUMBER SEE ACTSER
TRNARL==:36	;TRANS. ACCTG REC LENGTH
TRNNHW==10	;TRANS. NUMBER HEADER WORDS

XCF5NL==XCF4NL	;NO LICENSE ERROR
XCF5BA==XCF4BA	;BAD AC ERROR
XCF5NA==XCF4NA	;NO ACCOUNTING ERROR

XCHF5:	;EXPECTING T1/USER -COUNT,,ADDR
	MOVSI	T2,LICXC
	TDNN	T2,JBTLIC(J)
	  JRST	XCF5NL		;NO LICENSE
	HLRE	T2,T1
	CAMLE	T2,[-2]
	  JRST	XCF5BA		;MINIMUM 2 (FUNCTION NO, 1 WORD DATA)
	PUSH	P,T1		;SAVE USER AOBJN
	MOVEI	P1,TRNARL	;GET TRNARL WORDS IN ACCTG DEVICE
	PUSHJ	P,GETABS	;AND RETURN F/ACTDDB SKIPPING IF CAN
	  JRST	[POP P,T1	;USER AOBJN. NO ACCTG ACTIVE
		JRST XCF5NA]	;GIVE ERROR CODE
;NOW HAVE ACT DEVICE LOCKED DOWN
	PUSHJ	P,CBLAMB	;GET T2/LOC T1/COUNT OF ACTBUF BLOCK
	MOVEI	T3,TRNTAR
	MOVEI	T4,TRNARL
	PUSHJ	P,WACRHW	;WRITE ACT HEADER WORDS:HDR,DATE,ETC.
	MOVE	T3,JBTNAM(J)
	PUSHJ	P,PUTBUF	;DEPOSIT T3 ACCORDING TO T2,T1
	MOVE	T3,JBTFPN(J)
	PUSHJ	P,PUTBUF
	MOVE	T3,JBTSOK(J)
	PUSHJ	P,PUTBUF
	POP	P,P2		;USER AOBJN
	MOVEI	P1,TRNARL-TRNNHW
;P1/MONITOR COUNTER, ITEMS LEFT TO GO IN RECORD
;P2/USER POINTER, AFTER AOBJN PTS AT DATA TO LOAD NEXT
;T2/LOC FOR PUTBUF TO WRITE IN ACTBUF
;T1/LENGTH CURRENT ACTBUF BLOCK, FOR PUTBUF
;T3/ARG TO PUTBUF, DATA
;T4/SPARE

XCF5L1:	AOBJN	P2,.+2		;IF USER DATA RUNS OUT BEFORE RECORD LENGTH,
	TDZA	T3,T3		;PAD REC W/ZEROS
	  UMOVE	T3,(P2)
	PUSHJ	P,PUTBUF
	SOJG	P1,XCF5L1	;CONTINUE FOR RECORD LENGTH
	UMOVEM	P2,(M)		;RETURN UPDATED AOBJN TO USER
	PJRST	FINACB		;RELEASE ACT,UPDATE BUFF PTRS,SKIP RTN
;XCHARG FUNCTION 6 -- TRU COMPONENT CHECKPOINT

TCCTAR==:21	;TCC RECORD TYPE NUMBER SEE ACTSER
TCCNHW==10	;NUMBER HEADER WORDS
TCCARL==:TCCNHW+XCHFLN+3	;TCC REC LENGTH

XCF6NL==XCF4NL	;NO LICENSE ERROR
XCF6NA==XCF4NA	;NO ACCTG ERROR CODE

COMMENT ! XCHARG FUNCTION 6 PUTS A RECORD IN THE STREAM WHICH LOGS THE
EXACT VALUE OF EACH TRU COMPONENT AND OTHER CHARGING VARIABLES
[CONNECT TIME ETC];  THE PURPOSE IS TO BE ABLE LATER TO
SCAN STREAM FILES AND DETERMINE WHICH PROGRAMS USE WHICH RESOURCES
SO AS TO BE ABLE TO PREDICT EFFECT OF CHANGING TRU ALGORITHM
COEFFICIENTS OR XCHARGING POLICIES.

THIS UUO SHOULDN'T BE ISSUED MORE THAN ONCE BETWEEN ANY RUN/RUNSEG
AND EXIT.

XC LICENSE IS REQUIRED

!

XCHF6:	;EXPECTS M/USER AC, J/JOB
	MOVE	T2,JBTLIC(J)
	TLNN	T2,LICXC
	  JRST	XCF6NL		;NO LICENSE,SLAP HIS HAND
	MOVEI	P1,TCCARL
	PUSHJ	P,GETABS	;TRY TO GET SPACE ON ACT DEV
	  JRST	XCF6NA		;CANT GET IT; ACT MUST BE DOWN
;NOW ACT DEVICE LOCKED DOWN FOR US
	PUSHJ	P,CBLAMB	;GET T2/LOC T1/COUNT OF ACTBUF BLOCK
	MOVEI	T3,TCCTAR
	MOVEI	T4,TCCARL
	PUSHJ	P,WACRHW	;WRITE HEADER FOR OUR REC TYPE,LENGTH
	MOVE	T3,JBTNAM(J)
	PUSHJ	P,PUTBUF	;CONTINUE HEADER SECTION
	MOVE	T3,JBTFPN(J)
	PUSHJ	P,PUTBUF
	MOVE	T3,JBTSOK(J)
	PUSHJ	P,PUTBUF

;TRANSFER TRU COMPONENT VALUES TO RECORD. EXPECTS J/JOB
	MOVSI	P3,-XCHFLN	;XCHCTB LENGTH
XCF6L1:	MOVE	T3,@XCHCTB(P3)
	PUSHJ	P,PUTBUF
	AOBJN	P3,XCF6L1

;TRANSFER CONNECT & DISPATCH BASE CHARGING PARAMETERS (NOT ACTUALLY
;PART OF TRU COMPUTATION, BUT USED IN CHARGING USER ANYWAY.

	MOVE	T3,JBTCNK(J)
	PUSHJ	P,PUTBUF
;*;	MOVE	T3,JBTRMT(J)
	SETZ	T3,
	PUSHJ	P,PUTBUF
;*;	MOVE	T3,JBTRMC(J)
	SETZ	T3,
	PUSHJ	P,PUTBUF
	PJRST	FINACB		;RELEASE ACT AND SKIP RETURN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	XCHARG Function 7 - Scale TRU's				;;
;;								;;
;;	Calling sequence:					;;
;;		MOVE	AC,[-count,addr]			;;
;;		XCHARG	AC,					;;
;;		  <error> /AC=error code (0 or 3)		;;
;;		<success return> /old JBTSCA(J) stored into	;;
;;				 /addr+2			;;
;;								;;
;;	addr:	7	;function code				;;
;;		BYTE (9) SC1,SC2,SC3,SC4			;;
;;		previous scaling word (stored if successful)	;;
;;								;;
;;	Where:	SC1 & SC2 are the numerator & denominator of an	;;
;;	integer fraction scaling factor (SC1/SC2) to be applied	;;
;;	to the non-kilocore (size-independent) portion of the	;;
;;	TRU function, and SC3 & SC4 are the numerator &		;;
;;	denominator of the kilocore (size-dependent) portion,	;;
;;	with the special case of SC3.GT.0 and SC4=0 indicating	;;
;;	that the value in SC3 should be substituted for the	;;
;;	current charging size in K.				;;
;;	The value of "count" is ignored.			;;
;;	Error if job does not have XC license			;;
;;		or if SC1.GT.0 and SC2=0.			;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EXTERNAL JBTSCA

	XCF7NL=XCF4NL

XCHSCA:
	MOVSI	T2,LICXC	;XC license
	TDNN	T2,JBTLIC(J)	;Does it have it?
	  JRST	XCF7NL		;No, give error
	UMOVE	T2,1(T1)	;Get new scaling word
	LDB	T3,[POINT 9,T2,8] ;Check for special case
	JUMPE	T3,XCHSC1	;SC1=0, no matter what SC2 is
	LDB	T3,[POINT 9,T2,17] ;Pick up SC2
	JUMPE	T3,XCF7BC	;Bad component
XCHSC1:
	EXCH	T2,JBTSCA(J)	;Store new, load old
	UMOVEM	T2,2(T1)	;Store old into user's arg block
	PJRST	CPOPJ1

;-PUTSAR     PUT STREAM ACCOUNTING RECORD UUO.
;	A.ATKINSON NEW SEPT 76 WITH P031 MONITOR
;-CALL:	MOVEI AC,RECORD
;	PUTSAR AC,
;	 ERROR: AC=ERR CODE
;	OK RTN,AC PRESERVED

BADSRT==3 ;BAD STR REC TYPE
SRNLIC==1 ;NO LICENSE TO WRITE THIS ONE
SRSZW==2  ;SIZE WRONG
SRNAO==0  ;NO ACT OWNER, BUFFER FULL, SYS UP FOR FREE

;-RECORD FORMAT:
; WORD 0:	HEADER WORD: TYPE,BIT 0-8; SIZE, BITS 30-35
; WORD 1:	DATE WORD: MONITOR WILL DATE STAMP HERE
; WORD 2:	AUN OR OTHER DATA
; WORD 3:	TRU'S OR OTHER DATA
; WORDS 4 THRU SIZE-1 : DATA ACCORDING TO TYPE

;EXTERNALS FROM ACTSER,ETC.
EXTERNAL ACYSIZ,ACRTAB,ACYTYP,ACTDDB
EXTERNAL ACUTAB ;-USER PART OF ACRTAB
EXTERNAL ACURTL ;-LENG OF USER PART
EXTERNAL ACYMIN ;MIN SIZE IF REC VAR LEN ELSE ZERO
EXTERNAL UPTPJC,UPTPJ1,UPTPJ2 ;FROM COMMON

PUTSAR:	UMOVE	P2,(T1)		;P2:=USER HEADER WORD
	LDB	P3,[POINT 9,P2,8];  P3:=PROPOSED TYPE
;SEARCH ACRTAB (ACTSER) FOR DESCRIPTOR FOR THIS TYPE.
;IF NOT FOUND,OR LICENSE BAD, OR SIZE WRONG,FRETURN
	MOVE	T3,[XWD -ACURTL,ACUTAB]
	LDB	T2,ACYTYP
	CAME	T2,P3
	  AOBJN	T3,.-2
	MOVEI	P4,BADSRT	;IN CASE NOT FOUND
	JUMPG	T3,PTSRFX	;NOT FOUND
	HLLZ	T4,ACRTAB(T3)
	MOVEI	P4,SRNLIC	;IN CASE NO LIC
	TDNN	T4,JBTLIC(J)
	  JRST	PTSRFX		;NOT LICENSED TO WRITE THIS ONE
	LDB	P1,ACYSIZ
	LDB	T2,[POINT 6,P2,35];USER SIZE FIELD
	MOVEI	P4,SRSZW	;IN CASE
	CAME	T2,P1
          JRST	[LDB    T4,ACYMIN
                 JUMPE  T4,PTSRFX       ;ERROR IF REC LEN FIXED
                 CAML   T2,T4           ;YES: TOO SMALL OR
		 CAMLE	T2,P1		; TOO LARGE?
		   JRST	PTSRFX		;YES, ERROR
		 MOVE	P1,T2		;SET REC SIZE TO THAT WHICH USER SUP
		 JRST	.+1]	;CONTINUE
	ADDI	T2,-1(T1)	;T2/ADDR LAST WRD OF RECORD
	UMOVE	T2,(T2)		;MAKE SURE CAN GET IT
	XCTBU	<MOVES 1(T1)>	;MAKE SURE CAN WRITE DATE WORD
;SEE IF OK TO WRITE THIS RECORD. SIZE IN P1
	MOVE	P2,T1		;P2 POINT TO USER DATA FROM NOW ON
PTSBAJ:	PUSHJ	P,GETABS	;GET C(P1) ACT BUFFER SPACE
	  JRST	[MOVEI P4,SRNAO	;ERR CODE FAIL PUTSAR
		 JRST  PTSRFX]	;STREAM DEAD.
;DATE STAMP RECORD IN USER MEMORY
PTSR1:	MOVE	T3,TIME##
	IDIV	T3,JFYSEC##
	HRL	T3,THSDAT
	UMOVEM	T3,1(P2)	;WORD 1 OF RECORD
;MOVE USER BLOCK TO ACTBUF. P2 POINTS TO USER BLOCK
	MOVEI	F,ACTDDB
	PUSHJ	P,CBLAMB	;T2=LOC,T1=LENG OF CONTIGUOUS ACTBUF BLOCK
	MOVNS	P1		;P1:= -SIZE USER REC
	HRL	P2,P1		;P2:= -SIZ,,USER LOC
PTSR2:	UMOVE	T3,(P2)
	PUSHJ	P,PUTBUF	;CALLS CBLAMB IF WRAPAROUND
	AOBJN	P2,PTSR2
;CLEAN UP ACTBUF, UNINTERLOCK & EXIT SKIPPING
	PJRST	FINACB		;IN ACTSER
;RETURN ERROR CODE FROM P4 TO USER AC
PTSRFX:	UMOVEM	P4,(M)
	JRST	CPOPJ


COMMENT ! PUT ROYALTY STREAM RECORD UUO
EXPECTS: T1/ CONTENTS OF USER AC, BYTE(1)FLAG BYTE(35)ROYALTY ID
	J/JOB
RETURNS: SKIPPING ON SUCCESS, NO SKIP IF CANNOT GET
	SPACE IN ACT DEVICE BUFFER.
!

ROYTAR==:20	;ROYALTY TYPE ACT RECORD SEE ACTSER
ROYARL==:11	;ROYALTY ACT RECORD LENGTH


PUTROY::
	PUSH	P,T1		;SAVE FLAG & ROYALTY ID
	MOVEI	P1,ROYARL	;SEE IF WE CAN GET SPACE
	PUSHJ	P,GETABS	;TO WRITE ROYARL WORDS
	  JRST	TPOPJ		;CANNOT, POP OUT T1 AND NOSKIP RETURN
;NOW HAVE ACT DEVICE LOCKED DOWN
	PUSHJ	P,CBLAMB	;GET T2/LOC T1/COUNT OF ACTBUF FREE BLOCK
	MOVEI	T3,ROYTAR
	MOVEI	T4,ROYARL
	PUSHJ	P,WACRHW	;WRITE HEADER WORDS: HDR,DATE,TIME,ETC.
	MOVE	T3,JBTNAM(J)
	PUSHJ	P,PUTBUF	;DEPOSIT JBTNAM IN BUF,UPDATE T1,T2
	MOVE	T3,JBTFPN(J)
	PUSHJ	P,PUTBUF	;AND FPN
	MOVE	T3,JBTSOK(J)
	PUSHJ	P,PUTBUF
	POP	P,T3		;RECOVER SAVED FLAG & ROYALTY ID
	PUSHJ	P,PUTBUF
	PJRST	FINACB		;RELEASE ACT DEVICE,CLEANUP BUFFER, SKIP RTN

COMMENT ! LSAUUO KERNEL -- GENERATE LOCAL STREAM ACCOUNTING RECORD
PURPOSE: ALLOW PROGRAM RUN OUT OF OWN UFD TO BE TRACKED IN
	THE STREAM.
FUNCTION: WRITE TYPE 13 STREAM RECORD UNLESS USER HAS
	ALREADY ISSUED THIS UUO ONCE SINCE THE LAST
	RUN UUO/RUN CMD.   NOTE THAT IF PROGRAM IS RUN OUT
	OF ANOTHER UFD, ORDINARY TYPE 0 RUN RECORD IS WRITTEN,
	BUT THIS UUO WILL ALLOW 1 MORE TO GO IN, WITH
	SPECIAL SIXBIT /IDENTIFIER/.
CALL:	MOVE	AC,[SIXBIT /IDENTIFIER/] (ANY 36 BITS OK)
	CALLI	AC,-63
	ALWAYS RETURN HERE, AC PRESERVED
NOTE: THESE /IDENTIFIER/'S SHOW UP IN STREAM AS THE PROGRAM
	NAME. THERE MUST BE AGREEMENT AMONG TECH DIVISION
	GROUPS ABOUT WHO USES WHAT /IDENTIFIER/ FOR CONFLICTS
	TO BE AVOIDED.
!

LSAUUO::	;EXPECTS J/JOB, T1/C(USER AC)
	PUSH	P,JBTNAM(J)
	SKIPE	T1		;IF USER PASSES 0, USE JBTNAM(J)
	  MOVEM	T1,JBTNAM(J)	;ELSE TEMPORARILY JBTNAM_IDENTIFIER
	MOVEI	T1,13
	PUSHJ	P,ACTWRT	;GO WRITE TYPE 13 USING JBTNAM(J)
	POP	P,JBTNAM(J)
	POPJ	P,

	$END	(UUO)		;End of UUOCON (UUOLIT: UUOEND:)

    ' 8