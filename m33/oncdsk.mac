TITLE	ONCDSK	OPTIONAL & MANDATORY ONCE ONLY CODE

;*;	STOPCD(,ENTRY,ONCDSK)	;Macro is expanded after the PHASE statement

INTERN FILOPT,FILMAN,TYPONL,ONDSTT,ONDLNP,ONDLNR
INTERN MIN,MAX,LNGMES,DECLOP,CMDSCN,CMDSCF,ASKQMM,OPAGIN,OPAGOT
INTERN GETHOM,WTBOTH,GETBAT

;CONMES = output ASCIZ string, addr in T1
;TYPDEC = output P1 as decimal
;CRLF   = output CRLF
;DECLOP = save ACs, message in T1, TYPDEC, CRFLOP
;ASKQUE = save ACs, then YESNO
;YESNO  = output string, get response, skip if "Y"
;CONOUT = CONMES + CRLFOP
;CRLFOP = CRLF + OPOUT
;OPOUT  = output buffer, can be suppressed by ^O or ^C
;OCONM  = cancel ^O suppression, then CONMES

EXTERN BATCNT,BATPAT,HOMSUF,PRT22A,UNICHR,UNYBPR,UNYBPT,UNYBPY
EXTERN CONMES,CRLF,CTEXT,DECIN,GETLIN,OCONM,OCTIN,OPOUT,DSKDDB
EXTERN CORZER,SCNBAT,STTPTR,UNTTBL,STTFPC,UNTLEN
EXTERN STTLEN,SATCNT,UFDHSI
EXTERN NMRBPC,CPOPJ,CPOPJ1,MFDRIB
EXTERN %HOM.P,%BAT.P,%STR.P,%STA.P
EXTERN COMTYO,BRMAX,INLMES,NMSTPC
EXTERN CLRSND,PRNAME,RADX10,TPOPJ,CMPLOG
EXTERN PAGIN,PAGOUT,PCISTS,PGYUNI,PGYPNO,STDREA,PGYERR,OHTNUM,OHTINI
EXTERN PCBPAG,PAKREF,STDWRT,GETPEV
EXTERN BATFIR,BATREG,BAYNBB,BATNBB,BATELB,PAGCOD,PAGNAM,PAGSLF
EXTERN CODBAT,CODHOM,CODRIB,DDBLEN,DDSTAR,ONCDDB
EXTERN ICPFAC,JFYSEC,KONDWN,KONUPA,KOPDWN,KONLTM,KONCPY
EXTERN LPNHOM,LP2HOM,LPNBAT,LP2BAT,SYSUNI,SYSSIZ,EVASIZ
EXTERN REFRSH,SAVE4,SETDDO,IOSEL,CCOD,CWCOD,CLRDDB,YESNO

EXTERN HOMEND,HOMDAT,HOMMFD,HOMHSH,HOMRAN
EXTERN HOMHID,HOMP4C,HOMLOG,HOMLUN,HOMNXT,HOMOVR
EXTERN HOMPRV,HOMREF,HOMSNM,HOMSPU,HOMSAT,HOMFEP

EXTERN RIBLST,RIBPFS,RIBNAM,RIBEXT,RBSPAR,RBREAL,RBINDX,RBMASK
EXTERN RBYUNI,RBYPNO,RBYUN4,RBYUN1,RBLVPR,RBLVSP

EXTERN STRDDB,STRLEN,SRPNDS
EXTERN STRNAM,STRHSH,STRUNI,STRP4C,STRNXT,STRUNM,STRREF
EXTERN STROVR,STRTAL,STRPPU,STRPID,STRBTS,STRSID

EXTERN UNIPPU,UNIDES,UNIERR,UNIHID,UNISYS,UNIFEP
EXTERN UNINAM,UNISTT,UNISTR
EXTERN UNITAL,UNPCHG,UNPHWP,UNPMSB,UNPOFL,UNVRSF
EXTERN UNYLN1,UNYLUN,UNYSPU,UNIONC
EXTERN UNIKON,UNILOG,UNICHN,UNPPRV,UNISTS

EXTERN DCN,STRPID,REPSID,RE.DCD,HOMDCT,HOMDCV

EXTERN CH7
ENTRY ONCMOD

ONCMOD:

ONDSTT:	PHASE %OND
	STOPCD(,ENTRY,ONCDSK)	;Default for NONAME stopcodes
	%D==ONDSTT-ONCDSK	;To look at LABEL, use LABEL+%D

;MACRO TO DEFINE ONCE RESTART SYMBOLS AND BYTE POINTERS
;
DEFINE DCNDEF (DCD)<
  INTERN  REONCE
	REONCE:	0
	DCNUM==0
	IRP DCD, <DCNUM==DCNUM+1>
	DCNTAB:
	DCXX==0
	IRP DCD, <DCN.'DCD==(1B<DCXX>)
		  DCNY'DCD: POINT DCSIZ,DCN,35-DCSIZ*<DCNUM-1-DCXX>
		  Intern DCN.'DCD,DCNY'DCD
		  DCXX==DCXX+1>
>
DCSIZ==DC.SIZ			;(FROM S).
DCNDEF (<OP,ON,UR,MN,HM,DF>)	;DSKCLN TYPE CAN BE SPECIFIED BY:
				; 'OP' - OPER in ONCE (FULL COMMAND)
				; 'ON' - OPER IN ONCDSK
				; 'UR' - USER PROG VIA .REST SETUUO
				; 'MN' - MONITOR IN CRASH CODE
				; 'HM' - HOME BLOCKS
				; 'DF' - DEFAULT
INTERN DCNDFT			;IN THAT ORDER OF PRIORITY
DCNDFT==DCN.HM!DCN.DF		; SETUP DEFAULT TO HOME-BLOCKS ! DEFAULT
SUBTTL	FILMAN

FILMAN:	SETOM	BATMAN		;MANDATORY CODE.
	PUSHJ	P,RDHOME	;READ HOME PAGES OF ALL UNITS.
	  JRST	MANOK		;ALL OK.
	  JRST	MANQST		;MINOR ERRORS.
	MOVEI	T1,[ASCIZ /
ERRORS which prevent bringing the system UP/]
MANCM1:	PUSHJ	P,CONMES
MANCOM:	PUSHJ	P,FILOPT
	JRST	FILMAN

MANREF:	MOVEI	T1,[ASCIZ /
File structure NEEDS refreshing/]
	JRST	MANCM1

MANQST:	MOVEI	T1,[ASCIZ /
MINOR ERRORS - Bring system UP anyway? /]
	PUSHJ	P,ASKQUE
	  JRST	MANCOM		;NO.
MANOK:	PUSHJ	P,REDBAT	;READ THE BAT PAGES OF ALL UNITS.
	HLLZ	T1,STRREF+STRDDB
	JUMPN	T1,MANREF	;NEEDS REFRESH.
	MOVEI	T1,SRPREF##
	TDNN	T1,STRBTS+STRDDB;Was REFSTR called on this STR?
	 SETZM	REFLAG##	;No, ignore setting REFLAG from DDT

;HERE TO REWRITE HOME PAGES, WITH INCREMENTED PACK SET ID.

	HLRZ	U,STRDDB+STRUNI	;Start with DSKB0
	AOS	T1,RANHOM	; Increment save'd copy of HOMRAN
	TLNN	T1,-1
	 JRST	MANOK1
	MOVEI	T1,(SIXBIT/CAT/)	;
	HRRZM	T1,RANHOM	; If zero - save sixbit CAT
MANOK1:	HRLM	T1,STRDDB+STRPID
	PUSHJ	P,UPDHOM	;
	HLRZ	U,UNISTR(U)	;Update HOM pages on all units in STR
	JUMPN	U,.-2		;
	PUSHJ	P,SPCDKP	;GET CURRENT DC MODE AND PRIORITY
	CAIE	T3,^L<(DCN.DF)>	;IS MODE DEFAULT
	 JRST	MANOK2		;NO, DON'T QUERY OPER FOR MODE
	MOVEI	P3,DCFAST##	;Default to FAST instead of asking OPR
	MOVE	T1,STRDDB+STRBTS;DOES STR REQUIRE
	TRNE	T1,SRPNDS	; DSKCLN TO BE RUN
;*;	 PUSHJ	P,SPCDKN	;YES, ASK OPER TO SELECT MODE
	 DPB	P3,DCNYON	;Yes, do fast DSKCLN (trust HOM page for FULL)
MANOK2:	LDB	T1,DCNYON	;GET MODE
	MOVEM	T1,DCN		; AND SAVE IT FOR DSKCLN TO GETTAB
;HERE TO READ THE RIB FOR SAT.SYS AND SET UP THE STTPTR
;ENTRIES IN STT.

	HLRZ	U,STRDDB+STRUNI	;GET THE PRIME (AND ONLY)
	PUSHJ	P,GETSRB	;RIB INTO %STR.
	 STOPCD
	LDB	T1,[POINT 14,%STR+RIBEXT,35] ;Access date of SAT.SYS
	HRRZ	T2,THSDAT##	;Current date (if any)
	CAMG	T1,T2		;Get larger into T1
	 MOVE	T1,T2
	HRRM	T1,THSDAT##	;Store so COPYCRASH had a reasonable date
	MOVEI	P4,RIBPFS	;P4/ REL ADDR OF RETRIEVAL POINTERS.
	HLRZ	U,STRDDB+STRUNI	;Start with DSKB0

      ;HERE FOR EACH UNIT.
RDRBS2:	LDB	T4,UNYLUN	;
	HRRZ	P2,UNISTT(U)	;P2/ STT ENTRY ADDRESS.
	LDB	P3,UNYSPU	;P3/ # SATS ON THE UNIT.

      ;HERE FOR EACH SAT.
RDRBS3:	CAIG	P4,RIBLST	;MUSTN'T RUN OUT OF RIB ROOM.
	SKIPN	T1,%STR(P4)	;NOT EXPECTING EOF HERE.
	 STOPCD
	TLNN	T1,RBSPAR!RBINDX ;CHECK THAT THE POINTER IN T1
	TLNN	T1,RBREAL	;IS A CORRECT POINTER.
	 STOPCD
	LDB	T3,RBYUN1	;IS THIS THE UNIT
	CAME	T3,T4		;THAT WE EXPECT TO SEE?
	 STOPCD
	TLZ	T1,RBMASK-RBREAL ;
	MOVEM	T1,STTPTR(P2)	;YES.  SET STTPTR.
	ADDI	P4,1		;INC PNTR TO PNTRS.
	ADDI	P2,STTLEN	;ADJUST P2 TO NEXT STT ENTRY.
	SOJG	P3,RDRBS3	;LOOP AGAIN IF MORE SATS ON THIS UNIT.
	SETZM	STTPTR(P2)	;

	HLRZ	U,UNISTR(U)	;IS THERE ANOTHER
	JUMPN	U,RDRBS2	;UNIT?
	SKIPE	%STR(P4)	;NO.  CHECK THAT EOF IS PRESENT.
	 STOPCD
	PFALL	RDSATS
;NOW READ ALL THE SATS ON EACH UNIT IN THE STR, AND SET STTFPC
;IN THE SATS.

RDSATS:	SETZM	STRDDB+STRTAL	;CLEAR THE TOTAL COUNT FOR THE STR.
	HLRZ	U,STRDDB+STRUNI	;
RDSTS1:	HRRZ	P3,UNISTT(U)	;P3/PNTR INTO STT FOR THIS UNIT.
RDSTS4:	SKIPN	T2,STTPTR(P3)	;OUT OF SATS ON THIS UNIT?
	 JRST	RDSTS5		;YES, GO TO NEXT UNIT.
	LDB	T4,RBYPNO	;SAT
	MOVEI	PG,%STA.P	;INTO
	PUSHJ	P,OPAGIN	;%STA.
	  JRST	.+2		;ERROR ON READ.
	 JRST	RDST45		;READ OKAY.
	SETZM	%STA		;PRETEND ALL F BITS IN USE,
	MOVE	T1,[XWD %STA,%STA+1] ;AND LET
	BLT	T1,%STA+377	;DSKCLN WORRY.
RDST45:	SETOM	%STA+400	;SET ALL THE
	MOVE	T1,[XWD %STA+400,%STA+401] ;M BITS
	BLT	T1,%STA+777	;FREE.
	MOVE	T1,[XWD -400,%STA] ;AOBJN PNTR FOR SATCNT.
	PUSHJ	P,SATCNT	;T4/ NO. FREE PAGES IN THIS SAT.
	MOVEM	T4,STTFPC(P3)	;
	ADDM	T4,UNITAL(U)	;
	MOVE	T2,STTPTR(P3)	;WRITE  OUT THE SAT
	LDB	T4,RBYPNO	;SO THE CLEARED M BITS
	MOVEI	PG,%STA.P	;GET
	PUSHJ	P,OPAGOT	;OUT THERE.
	 STOPCD
	ADDI	P3,STTLEN	;ADJUST PNTR TO STT.
	JRST	RDSTS4

    ;COMPUTE SAFETY FACTOR FOR UNIT AND ADJUST STRTAL.
RDSTS5:	MOVE	T1,UNIPPU(U)	;COMPUTE THE SAFETY FACTOR FOR
	IDIVI	T1,UNVRSF	;THE UNIT.
	LDB	T2,UNYSPU	;
	IMULI	T1,(T2)		;
	MOVNS	T1		;
	ADDB	T1,UNITAL(U)	;ADD TO UNIT'S COUNT.
	JUMPGE	T1,.+3		;DO NOT ALLOW
	SETZM	UNITAL(U)	;UNITAL TO GO
	JRST	RDSTS6		;NEGATIVE.
	ADDM	T1,STRDDB+STRTAL ;ADJUST STRTAL.

RDSTS6:	HLRZ	U,UNISTR(U)	;
	JUMPN	U,RDSTS1	;

;The calculation of PROT and PROT0 based on disk type is not valid in the                                      i
;paging monitor.  The code that was deleted here produced garbage for PROT0
;on the F3 as a result of dividing by zero.  The values are now set in COMMON
;based on IFCPU(<KI,KL>),<PROT0:2> and IFNCPU(<KI,KL>),<PROT0:4>.

	MOVSI	T1,UNPCHG
	HLRZ	U,SYSUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN SYSTEM
	ANDCAM	T1,UNIDES(U)	;CLEAR CHANGE BIT
	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN SYSTEM
	JUMPN	U,.-2		;REPEAT IF ANY LEFT
	SKIPE	F,DDSTAR	;IF A DDB SETUP
	PUSHJ	P,CLRDDB	;THEN CLEAR IT.
	POPJ	P,		;NO - RETURN
COMMENT #
@@SUBROUTINE GETSRB
@@PURPOSE
SUBR TO READ THE RIB BLOCK FOR SAT.SYS INTO %STR.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
@@ACCUM
DESTROYS
@@CALLS
RDCHEK.
@@EXIT
SKIP RETURNS IF THE PAGE READ SUCCESSFULLY.
@@ #


GETSRB:	PUSHJ	P,GETHOM	;Read in HOM page for DSKB0
	  POPJ	P,		;Can't read it
	SKIPG	T4,%HOM+HOMSAT	;Get logical page number for RIB for SAT.SYS
	 POPJ	P,		;Should be LPNSAT, not zero!
	MOVEI	P3,CODRIB	;GET CODE WORD FOR RIB PAGES.
	MOVSI	P2,(SIXBIT .SAT.)
	MOVEI	PG,%STR.P	;
	SETOM	WHICH		;INDICATE READING FIRST (AND
	SETZM	NOERH		;ONLY) PAGE.
	PJRST	RDCHEK		;READ & VERIFY RIB PAGES.
;SOME MACROS FOR COMMAND WORK

	DEFINE SCAN (A,B) <
IFB <B>,<
PRINTX	SCANNER TABLE 'A' Has an undefined SETxM statement
>
	MOVEI	P1,SCN'A		; Get address of Scan Table
	SET'B'M	CMDSCF			; Specify NO STR/UNIT stuff
	PUSHJ	P,CMDSCN		; Call Scanning routine
	  JRST	HLP'A			; No good!
	XCT DSP'A'(P3)			; Yes?
	JRST	A'CMD			; Return as if cr typed.

A'HLP:	Move	P3,-2(P1)		; Setup AOBJN pointer for messages
A'HL1:	Hrrz	T1,(P3)			; Get address of message
	Pushj	P,LNGMES		; Print a long message
	Aobjn	P3,A'HL1		; Next?
	Jrst	A'CMD			; Return.
>

;MACRO TO MAKE SCAN TABLE
;UNI IS PLACE TO JRST TO IF UNIT
;STR IS PLACE TO JRST TO IF STR
;NAM IS TABLE NAME  Generates SCN'NAM, DSP'NAM, TXT'NAM, SIZ'NAM
; Assumes MK'NAM as the macro defining the X arguments
; JRST to NUL'NAM on <CR> and HLP'NAM on error
; Defines NAM'HLP for a standard typeout of help texts

	Extern Ab.Ack,Ab.Nak,Ab.Ver,Ab.Tcv,Ab.Cvr ; Bits - See ONCE.MAC
	DEFINE SCNTB (UNI,STR,NAM) <

	DEFINE X(SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	INS>	;INSTRUCTION TO EXECUTE

	JRST UNI		;FOR -3 RETURN
	JRST STR		;FOR -2 RETURN
	JRST NUL'NAM		;FOR -1 RETURN
DSP'NAM: MK'NAM			;GENERATE DISPATCH TABLE
	SIZ'NAM==.-DSP'NAM
	-SIZ'NAM,,TXT'NAM	;AOBJN POINTER TO HELP
	-SIZ'NAM,,SCN'NAM	;AOBJN POINTER TO NAMES
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	<SIXBIT /SYM/>>
SCN'NAM: MK'NAM			; Define Table to read

	$XZ==0			; Need a counter
	define xz$(argh)<lit$'argh==.>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	xz$(\$XZ)
Ifnb <TEXT>,<ASCIZ \TEXT'TEXT1'TEXT2'TEXT3\>
	$XZ==$XZ+1>
	MK'NAM

	$XZ==0
	define xz$(argh)<lit$'argh>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	<Xwd	Bit,xz$(\$XZ)>
	$XZ==$XZ+1>
TXT'NAM: MK'NAM

>

;P1 IS A POINTER TO THE NAMES TABLE
;The command scanning routine - Copied and munged from ONCDSK

CMDSCN:	PUSHJ	P,SETRAN	; Start number generator on any question.
	PUSHJ	P,CTEXT		; Get text (up to 6 chars) in T2
	PUSHJ	P,GETRAN	; Stop generator (KI,F3) and get number
	 JUMPE	T2,[CAIL T3,40	;  EOL?
		    POPJ P,	;NOT NULL LINE, SPC CHR
		    MOVNI P3,1	;RETURN P3=-1 FOR NULL STRING
		    JRST CPOPJ1]
	MOVE	T1,T2		;GET TEXT IN T1
	SKIPN	CMDSCF		; Skip IF we want to do UNI/STR stuff
	  Jrst	CMDSC1		; NO!  Don't Bother.
	MOVEM	U,SVU
	PUSHJ	P,FNDSTR	;IS IT A STR?
	JRST	[MOVNI P3,2	;-2 FOR STR WITH P2 TO STR BLOCK
		 JRST CPOPJ1]
	PUSHJ	P,FNDUNI	;CHECK ON UNIT
	  SKIPA			;NO
	JRST	[MOVNI P3,3	;-3 WITH U POINTING TO UNIT BLOCK
		 JRST CPOPJ1]
	MOVE	U,SVU
CMDSC1:	MOVE	P2,-2(P1)	;GET AOBJN POINTER TO HELP TABLE
	MOVE	P3,-1(P1)	;GET AOBJN POINTER TO NAME TABLE
	MOVEI	P4,0		;NOTHING SEEN SO FAR
	MOVSI	T3,770000	;MAKE A MASK
CMDSC2:	TDNE	T1,T3		; Did we type something?
	TDO	T1,T3		; If something there, set mask bits
	LSH	T3,-6		; Shift
	  JUMPN	T3,CMDSC2	; While we have more to check...
CMDSC3:	CAMN	T2,(P3)		; Compare !
	  JRST	CMDSC5		; Exact match
	Move	T3,(P2)		; Get Bits,,Text-Adr
	TLNE	T3,AB.NAK	; See if we can abbreviate it
	  JRST	CMDSC4		; No! -- Don't bother
	MOVE	T3,(P3)		;NO - CHECK MORE
	AND	T3,T1		;MASK OUT UN-TYPED STUFF
	CAME	T3,T2		;CHECK AFTER MASK
	  JRST	CMDSC4		;NO
	JUMPN	P4,[MOVEI P4,1	;SET POSITIVE FOR MULTI MATCH
		    JRST   CMDSC4]
	MOVE	P4,P3		;SAVE MATCH
CMDSC4:	AOJ	P2,		; Increment text pointer
	AOBJN	P3,CMDSC3	; Loop through the table
	SKIPL	P3,P4		;ANY MASKED MATCHES
	  POPJ	P,		;NONE OR MORE THAN 1
CMDSC5:	SUB	P3,P1		;CONVERT TO RELATIVE INDEX
	HRRZ	P2,-2(P1)	; Get AOBJN Pointer for
	ADD	P2,P3		; Add offset
	MOVE	P2,(P2)		; Get Bits,,Text-Addr
	SKIPE	CMDMSG		; See if debugging?
	 JRST	CPOPJ1		;  Yes!  Don't bother to verify!
	TLNN	P2,AB.VER	; Should we Verify?
	 JRST	CPOPJ1		; No! Just Return "SAFE"
	TLNN	P2,AB.CVR	; Ignore verify for CONSOLE?
	 CAIA			; No.. Don't bother to check!
	SKIPN	CTYDO##		;  Setup for CTY?
	 CAIA			; No.. Keep going!
	  JRST	CPOPJ1		; YES! Don't verify.
	TLNN	P2,AB.TCV	; Is it a TYPE/CHANGE item?
	 CAIA			; No.. Don't worry!
	SKIPL	TYPONL		;  Type ONLY?
	 CAIA			; No.. Keep going!
	  JRST	CPOPJ1		; YES! Don't verify.
	HRRZ	T1,P2		; Get Text Address
	PUSHJ	P,LNGMES	; No -- Type it out.
	MOVEI	T1,[ASCIZ\

Are you SURE you want to do this? \]
	PUSHJ	P,YESNO		; A "Y" will skip, else assume NO.
	  MOVNI P3,1		; Set for null-command return
	JRST	CPOPJ1		; Always skip return.


CMDMSG:	0			; Debugging flag. 0=Type long messages.
CMDSCF:	0			; Flag for checking UNI/STR Stuff
				; 0==No checking, -1==Check!
SVP2:	0
SVU:	0

;Here from the FILES command in ONCE
FILOPT:	MOVEI	T1,[ASCIZ /
Entering the FILES dialogue...
  Type "GO" to return to ONCE./]
	PUSHJ	P,CONOUT
	SETZM	BATMAN
        SETZM	EVASIZ		;ENSURE EVMINI GETS CALLED IN EVMALC
	PUSHJ	P,RDHOME
	 JFCL
	 JFCL
	PUSHJ	P,REDBAT	;READ BAT PAGES.

HLPFIL:	MOVEI T1,[ASCIZ /
  Type "HELP" for a list of options.
/]
HLPTY1:	PUSHJ P,OCONM
	PUSHJ P,OPOUT

TYPCMD:
CHGCMD:
SRPCMD:
NULFIL:
FILCMD:	MOVEI T1,[ASCIZ /
FILES* /]
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	SETOM KNOUNI
	SETOM DBLSTD
	PUSHJ P,GETLIN
	 JRST FILCMD	;NOTHING THERE
	SCAN (FIL,Z)

	DEFINE MKFIL <
	X DSKCLN,<PUSHJ P,SPCDKN>,Ab.Nak!Ab.Ver,<
DSKCLN  Query or Select DSKCLN mode.
        List the current mode and allow the operator to change it.>
	X TYPE,<JRST TYPIT>,Ab.Ack,<
TYPE    List information about the structure.
        Type "TYPE HELP" for a list of options.>
	X CHANGE,<JRST CHGIT>,Ab.Ack,<
CHANGE  Change information about the structure.
        Type "CHANGE HELP" for a list of options.>
	X ADD,<PUSHJ P,ADDUNI>,Ab.Nak!Ab.Ver,<
ADD     Add a unit to the structure.
        Reconfigure the disk structure and add another pack.>
	X DISOLVE,<JRST BADDIS>,Ab.Nak,<.>
	X DISSOLVE,<PUSHJ P,STSDSL>,Ab.Nak!Ab.Ver,<
DISSOLVE Dissolve the disk structure for DSKB.
        Remove all units from the system structure.>
	X DEFINE,<PUSHJ P,STSDEF>,Ab.Nak!Ab.Ver,<
DEFINE  Define a NEW structure for DSKB.
        Create a completely new system structure.>
	X REFRESH,<PUSHJ P,STSREF>,Ab.Nak!Ab.Ver,<
REFRESH Refresh the structure.
        Delete all files on the system and start over
        with a "FRESH" disk.>
	X DDT,<PUSHJ P,DDTX##>,AB.ACK!AB.VER,<
DDT     Enter executive DDT.  To be used ONLY by software wizards
        for emergency patching and examination of the monitor.>,<
        UNDER NO CIRCUMSTANCES SHOULD YOU NORMALLY USE THIS COMMAND!>
	X TSTSUP,<PUSHJ P,TSTSUP##>,AB.ACK!AB.VER,<
TSTSUP  Disk patching routine.  To be used ONLY by software wizards
        for emergency patching of the disk structure.>,<
        UNDER NO CIRCUMSTANCES SHOULD YOU NORMALLY USE THIS COMMAND!>
	X BOOTS,<JRST SYSBTS##>,AB.NAK!AB.VER,<
BOOTS   Crash the system with "BOOTS LOADED" immediately.>
	X GO,<JRST FILGO>,Ab.Ack,<
GO      Leave the FILES dialogue and return to the ONCE
        dialogue.>
	X HELP,<JRST FILHLP>,Ab.Ack,<
HELP    Type this message.
>
>
	SCNTB (HLPFIL,HLPFIL,FIL)

BADDIS:	MOVEI	T1,[ASCIZ /  DISSOLVE is spelled with two "S"es.
/]			;Here if typed "DISOLVE"
	JRST	HLPTY1
TYPIT:	SETOM TYPONL	;ONLY TYPEOUT
	SCAN (TYP,O)

NULTYP:
HLPTYP:	MOVEI T1,[ASCIZ /
Type "TYPE HELP" for a list of options.
/]
	JRST HLPTY1

	DEFINE MKTYP <
	X STR,<PUSHJ P,TYPSTR>,Ab.Nak,<
STR     Name of the STRUCTURE and UNITS on it.>
	X UNITS,<PUSHJ P,TYPUNS>,Ab.Nak,<
UNITS   Names of all units NOT in a file structure.>
	X BAT,<PUSHJ P,TYPBAT>,Ab.Nak,<
BAT     Number of BAD pages and regions for a unit.>
	X SATPCBS,<PUSHJ P,TYPSPC>,Ab.Nak,<
SATPCBS Number of SAT PCBs.>
	X RIBPCBS,<PUSHJ P,TYPRPC>,Ab.Nak,<
RIBPCBS Number of RIB PCBs.>
	X ALL,<JRST TYPALL>,Ab.Nak,<
ALL     All of the above.>
	X HELP,<JRST TYPHLP>,Ab.Ack,<
str-name  Type information about the structure.
unit-name Type information about the unit.
HELP    Type this message.
>
>
	SCNTB (TYPUIP,TYPSRP,TYP)
CHGIT:	SETZM TYPONL
	SCAN (CHG,O)
NULCHG:
HLPCHG:	MOVEI T1,[ASCIZ /
Type "CHANGE HELP" for a list of options.
/]
	JRST HLPTY1

	DEFINE MKCHG <
	X SATPCBS,<PUSHJ P,CHGSPC>,Ab.Nak!Ab.Ver,<
SATPCBS   Change the number of SAT PCBs.>
	X RIBPCBS,<PUSHJ P,CHGRPC>,Ab.Nak!Ab.Ver,<
RIBPCBS   Change the number of RIB PCBs.>
	X BAT,<PUSHJ P,CHGBAT>,Ab.Nak!Ab.Ver,<
BAT       Refresh the BAT pages for a UNIT.>
	X HELP,<JRST CHGHLP>,Ab.Ack,<
str-name  Change parameters for the structure
unit-name Change parameters for a unit.
HELP    Type this message.
>
>
	SCNTB (TYPUIP,TYPSRP,CHG)
TYPUIP:	HRRZ	P2,UNISTR(U)	;IN CASE IN FS
	MOVEM	P2,UIPSVU	;SAVE IT!
	MOVEI	P1,SCNUIP	; Get address of Scan Table
	SETOM	CMDSCF		; Specify STR/UNIT stuff
	PUSHJ	P,CMDSCN	; Call Scanning routine
	  JRST	HLPUIP		; No good!
	MOVE	P2,UIPSVU	;RESTORE in case needed.
	XCT	DSPUIP(P3)	; Yes?
	JRST	FILCMD		; Return as if cr typed.
UIPSVU:	0

UIPHLP:	Move	P3,-2(P1)	; Setup AOBJN pointer for messages
UIPHL1:	Hrrz	T1,(P3)		; Get address of message
	Pushj	P,LNGMES	; Print a long message
	Aobjn	P3,UIPHL1	; Next?
	Jrst	FILCMD		; Return.
NULUIP:
HLPUIP:	MOVEI T1,[ASCIZ /
Type "TYPE unit-name HELP" for a list of options./]
	SKIPL TYPONL
	MOVEI T1,[ASCIZ /
Type "CHANGE unit-name HELP" for a list of options./]	;WAS A CHANGE
	JRST HLPTY1

	DEFINE MKUIP <
	X ID,<PUSHJ P,UNITID>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... ID    Unit ID.>
	X HELP,<JRST UIPHLP>,Ab.Ack,<
... HELP  Type this message.
>
>
	SCNTB (HLPUIP,HLPUIP,UIP)

UNCHKA:	SKIPN UNIHID(U)
	PUSHJ P,UNITID
	PJRST	UNITST


TYPSRP:	SCAN (SRP,O)
NULSRP:
HLPSRP:	MOVEI T1,[ASCIZ /
Type "TYPE str-name HELP" for a list of options./]
	SKIPL TYPONL
	MOVEI T1,[ASCIZ /
Type "CHANGE str-name HELP" for a list of options./]
	JRST HLPTY1

	DEFINE MKSRP <
	X OVERDRAW,<PUSHJ P,STRTOV>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... OVERDRAW  The number of pages for ove.>
	X CRASH,<PUSHJ P,STRTCH>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... CRASH     The number of pages for CRASH.SAV.>
	X ALL,<JRST STRTPA>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... ALL       All of the ABOVE.
              The number of pages for Overdraw, for CRASH.SAV.>
	X HELP,<JRST SRPHLP>,Ab.Ack,<
... HELP      Type this message.
>
>
	SCNTB (HLPSRP,HLPSRP,SRP)

STRTPA:	PUSHJ P,STRTOV
	PUSHJ P,STRTCH
	JRST SRPCMD

;HELP INFORMATION

LNGMES:	HRLI T1,(POINT 7,0)
LNGMS1:	ILDB T3,T1
	JUMPE T3,CPOPJ
	PUSHJ P,COMTYO
	CAIE T3,12
	JRST LNGMS1
	PUSH P,T1
	PUSHJ P,OPOUT
	POP P,T1
	JRST LNGMS1
COMMENT #
@@SUBROUTINE RDHOME
@@PURPOSE
SUBR TO READ & VERIFY HOME PAGES FOR ALL UNITS AT SYSTEM
INITIALIZATION.  BUILDS THE SYSTEM STR.
SETS INFO IN THE STR DB AND IN THE UNIT DBS.
@@CALLS

@@EXIT
NON-SKIP RETURNS IF AN ERROR WAS DETECTED WHILE READING THE
HOME PAGES OF 1 OR MORE UNITS AND/OR NO STR WAS CREATED
AND/OR MORE THAN ONE STR WAS CREATED.
SKIP RETURNS IF ALL HOME PAGES THAT WERE NOT DOWN READ OK.
@@ #

RDHOME:	PUSHJ	P,INLMES##
	 ASCIZ /
Checking all units on disk controller - reading UNIT ID from HOME pages./
	SETOM	TYPUI0		;Force CRLF next output from TYPUID
	SETZM	DSKDDB+DEVIOS	;
	WRPI	LI.PIN		;TURN PI SYSTEM ON FOR WAITS
	SKIPE	F,DDSTAR	;IS THERE A DDB SETUP?
	PUSHJ	P,CLRDDB	;YES, CLEAR IT
	MOVE	T1,ONCDDB	;GET LOCATION OF ONCE ONLY DDB
	MOVEM	T1,DDSTAR
	PUSHJ	P,SETDDO	;CREATE A DDB FOR ONCE ONLY I/O
	 STOPCD .
	PUSHJ	P,CLRSTR	;INITIALLY THERE IS NO STR.
	SETZM	RANHOM		; Clear so pack-set id check works
	HLRZ	U,SYSUNI	;GET ADR. OF 1ST UNIT DATA BLOCK IN SYSTEM.
	JUMPE	U,RDHOM2	;
	MOVSI	T3,UNPPRV	;
RDHOM1:	IORM	T3,UNIDES(U)	;SET UNIT TO BE A PRIVATE PACK.
	HLRZ	U,UNISYS(U)	;
	JUMPN	U,RDHOM1	;
RDHOM2:	HLRZ	U,SYSUNI	;
	SETZM	ERRHOM		;CLEAR ERROR(S) WHILE READING HOME PAGES FLAG
	SETZM	ERRHM2
	TDZA	T1,T1
SCNUNI:	 MOVE	T1,J		;SAVE OLD KON
	HRRZ	J,UNIKON(U)	;GET ADR. OF KONTROLLER DATA PAGE FOR THIS UNIT
	SKIPGE	KONUPA(J)	;HAS KONTROLLER BEEN FLAGGED AS DOWN?
	 JRST	FLGDWN		;YES - FLAG UNIT AS DOWN ALSO
	CAMN	T1,J		;IS IT THE SAME
	 JRST	KONTOK		;YES, DO NOT NEED TO TRY AGAIN
TRYKON:	PUSHJ	P,@KONUPA(J)	;SEE IF KONTROLLER IS UP
	  SKIPA	P1,UNINAM(U)	;IT'S DOWN
	JRST	KONTOK		;NOW SEE IF UNIT IS OK

;HERE IF KONTROLLER IS DOWN.    (P035/D01 - Don't ask if BPC or BPD are down)
;*;	HLLZS	P1		;GET SIXBIT KONTROLLER NAME
;*;	MOVEI	T3,[ASCIZ .DO YOU WANT IT TO BE 1)ON-LINE, OR 2)DOWN? (TYPE #)
;*;.]
;*;	PUSHJ	P,MCKKON	;PRINT MSG & GET ANSWER
;*;	  JRST	TRYKON		;ILLEGAL RESPONSE
;*;	CAIE	T2,2		;WAS "2" TYPED?
;*;	JRST	TRYKON		;NO - CHECK AGAIN IF "1" OR ANYTHING ELSE WAS TYPED
	PUSHJ	P,CRLFOP	;Start a new line
	HLLZ	T2,P1		;Get Kontroller name ("BPA", "BPB", etc)
	PUSHJ	P,PRNAME	;Put it in buffer
	MOVEI	T1,[ASCIZ / is off-line/]
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	PUSHJ	P,CRLFOP	;ADD CRLF & OUTPUT MSG.
	MOVSI	T1,KOPDWN	;KONTROLLER DOWN BIT(SIGN BIT)
	IORM	T1,KONDWN(J)	;FLAG KONTROLLER AS DOWN
	JRST	FLGDWN		;FLAG UNIT DOWN AS WELL

;HERE IF KONTROLLER ON-LINE - TO CHECK IF UNIT OK
KONTOK:
IFCPU (F3),<
	MOVSI	T1,UNPOFL
	TDNE	T1,UNIDES(U)	;IS UNIT OFF-LINE OR DOWN?
	 JRST	SCNUN1		;YES - CONTINUE SCAN ON NEXT UNIT
>;END IFCPU (F3)
	PUSHJ	P,DSKCPY	;GET CAPACITY AND SEE IF UP
	SKIPL	T4,UNIONC(U)	;1B0 set if off-line, 1B1 if write-protect
	 JRST	WCKUNI		;IF POSITIVE, UNIT IS UP
;Use routine TYPUID instead of UNTDWN to report off-line units

;HERE TO FLAG UNIT AS DOWN & OFF-LINE.
FLGDWN:	MOVEI	T2,SYSUNI-UNISYS ;SYSUNI - UNISYS
FLGDN1:	HLRZ	T1,UNISYS(T2)	;NEXT UNIT IN SYSTEM
	CAMN	T1,U		;SKIP IF NOT FOUND DOWN UNIT
	 JRST	FLGDN2
	HLRZ	T2,UNISYS(T2)	;NEXT UNIT IN SYSTEM
	JUMPN	T2,FLGDN1
	JRST	FLGDN3		;NOT THERE?

FLGDN2:	HLRZ	T1,UNISYS(T1)	;LINK TO NEXT UNIT
	HRLM	T1,UNISYS(T2)	;STORE IN PREVIOUS
FLGDN3:	SKIPA	T2,U		;T2 = THIS UNIT
FLGDN4:	 HLRZ	T2,UNIKON(T2)	;NEXT UNIT IN KONTROLLER RING
	HLRZ	T1,UNIKON(T2)	;NEXT BACK TO US?
	CAME	T1,U
	 JRST	FLGDN4		;NO
	HLRZ	T1,UNIKON(T1)	;YES, LINK TO NEXT
	HRLM	T1,UNIKON(T2)	;STORE IN PREVIOUS
	SKIPA	T2,U		;T2 = THIS
FLGDN5:	 HLRZ	T2,UNICHN(T2)	;T2 = NEXT UNIT IN CHANNEL RING
	HLRZ	T1,UNICHN(T2)
	CAME	T1,U		;BACK TO US?
	 JRST	FLGDN5		;NO
	HLRZ	T1,UNICHN(T1)	;LINK TO NEXT
	HRLM	T1,UNICHN(T2)	;STORE IN PREVIOUS
	MOVSI	T1,UNPOFL	;OFF-LINE BIT
	IORM	T1,UNIDES(U)	;SET BIT IN LH. OF UNIDES WORD
	JRST	SCNUN1		;CONTINUE SCAN ON NEXT UNIT

;HERE IF UNIT ON-LINE - TO CHECK IF UNIT WRITE ENABLED
WCKUNI:	MOVSI T1,UNPHWP
	TDNN T1,UNIDES(U)
	TLNN T4,(1B1)		;IS IT WRITE PROTECTED?
	 JRST CHKHOM		;UNIT IS OK OR HAVE BEEN HERE BEFORE
	MOVEI	T3,[ASCIZ .DO YOU WANT IT TO BE 1)WRITE-ENABLED, OR 2)WRITE-PROTECTED? (TYPE #)
.]
	PUSHJ	P,WRPUNM	;PRINT MSG & GET ANSWER
	  JRST	TRYKON		;ILLEGAL RESPONSE
	CAIE	T2,2		;WAS "2" TYPED?
	JRST	TRYKON		;NO - CHECK AGAIN IF "1" OR ANYTHING ELSE WAS TYPED
	MOVSI	T1,UNPHWP	;HARDWARE WRITE-PROTECT BIT
	IORM	T1,UNIDES(U)	;FLAG UNIT AS WRITE PROTECTED
	PFALL	CHKHOM

;HERE IF UNIT ON-LINE & LEGALLY WRITE PROTECTED OR ENABLED - CHECK ITS HOME PAGES

CHKHOM:	PUSHJ	P,GETHOM	;GET HOME PAGE INTO CORE.
	  CAIA			;ERROR(S) ON BOTH HOME PAGES - T3 RETURNED NON 0.
	JRST	HMBOK		;AT LEAST ONE HOME PAGE OK
				;FORCE TO BE A NULL PAGE, NO OPTIONS
	MOVEI	T1,%HOM		;
	PUSHJ	P,CORZER	;
	MOVEM	P2,%HOM+PAGNAM	;STORE SIXBIT "HOM"
	MOVEM	P3,%HOM+PAGCOD	;STORE HOME PAGE CODE
	PUSHJ	P,SETCHG	;FLAG THAT THIS UNIT'S HOME PAGE MUST BE REWRITTEN
	PUSHJ	P,MOVUNI	;MOVE PARAMS FROM HOME PAGE TO UNIT DATA BLOCK.
	JRST	NTISTR		;
;HERE IF HOME PAGE(S) READ INTO CORE OK
; GENERATE STR DB & LINK UNIT DBS CORRECTLY.

HMBOK:	JUMPE	T3,.+2		;ERR WHILE READING HOME PAGES?
	PUSHJ	P,SETCHG	;YES. FLAG THEY NEED REWRITING.
	PUSHJ	P,MOVUNI	;MOVE PARAMS FROM HOME PAGE TO UNIT DB
	MOVEI	P2,0		;SET STR DB ADR. = 0 IN CASE NO STR FOUND
	MOVE	T1,%HOM+HOMSNM	;GET STR NAME FROM HOME PAGE.
	JUMPE	T1,NTISTR	;DON'T LOOK FOR OR CREATE A ZERO STR NAME.
HMBOK2:	PUSHJ	P,FNDSTR	;DOES THIS STR EXIST?
	  JRST	NOTPRV		;YES. UNIT IS NOT A PRIVATE PACK.
	SKIPE	STRNAM(P2)	;NO, DOES ANY STR EXIST?
	 JRST	NOSTR		;YES, ONLY ONE STR IS LEGAL. DIE.
				;NO, THIS IS THE SYSTEM STR.
	PUSHJ	P,MOVSTR	;MOVE PARAMS FROM HOME PAGE TO STR DB.
	MOVE	T2,REONCE	;GET ONCE COPY OF RESTRT WORD
	TLZ	T2,DCN.UR!DCN.MN	;IN CASE STR IS MODIFIED
	HRRZ	T1,%HOM+HOMRAN	;GET PACK SET ID
	CAME	T1,REPSID	;HAS NEW PACK SET BEEN MOUNTED?
	 JRST	HMBOK3		;YES: IGNORE RESTRT
	SETZ	T1,		;ZERO DSKCLN TYPE SPEC FLAG WORD
	TRNE	T2,RE.DCD	;DID USER SELECT A DSKCLN TYPE?
	 TLO	T1,DCN.UR	;YES: SO INDICATE
	TLO	T1,DCN.MN	;IND MON SELECTED A DSKCLN TYPE
	IORM	T1,DCN
HMBOK3:	MOVE	T1,%HOM+HOMDCT	;INITIALIZE FOR VERIFICATION OF
	DPB	T1,DCNYHM	; HOME BLOCK DSKCLN TYPE VALIDITY
NOTPRV:	PUSHJ	P,SETPUB	;SET THE UNIT PUBLIC.

    ;HERE WHEN STR UNIT BELONGS IN EXISTS
OLDSTR:	JUMPE	P2,OLDST8	;SKIP OVER RAN & HSH CHK IF NO STR.
	LDB	T1,DCNYHM	;SET UP TO VERIFY THAT HOME
	HRLI	T1,HOMDCV	; DSKCLN TYPE IS VALID/CONSISTENT
	HRLZI	T2,DCN.HM
	CAME	T1,%HOM+HOMDCT	;IS TYPE GOOD?
	 ANDCAM	T2,DCN		;NO: SO INDICATE
	HLRZ	T1,%HOM+HOMHSH	;T1/ UNIT'S HASH CONSTANT.
	JUMPE	T1,OLDST1	;MUST BE NON-ZERO.
OLDST2:	HRRZ	T2,STRHSH(P2)	;T2/ STR'S HASH CONSTANT SET
	JUMPN	T2,OLDST0	;YET?
	HRRM	T1,STRHSH(P2)	;NO, JUST STORE FIRST FOUND.
	JRST	OLDST4		;GO TO RAN LOOK.
OLDST0:	CAIN	T1,(T2)		;YES, BETTER MATCH OTHERS'.
	 JRST	OLDST4		;OKAY.
OLDST1:	MOVEI	T1,[ASCIZ /MISSING OR INCONSISTENT HASH CONSTANT FOR UNIT /]
	PUSHJ	P,MSGUNI	;
OLDST4:	HRRZ	T1,%HOM+HOMRAN	;T1/ UNIT'S PACK SET ID.
	JUMPE	T1,OLDST5	;CAN'T BE ZERO.
OLDST6:	SKIPE	T2,RANHOM	;ALREADY SEEN ID?
	 JRST	STRFIX		;YES.
	HRRZM	T1,RANHOM	;NO, JUST STORE FIRST FOUND.
	 JRST	OLDST8		;
STRFIX::CAIN	T1,(T2)		;YES, BETTER MATCH OTHERS'.
	 JRST	OLDST8		;OKAY.
 ;Label STRFIX to JFCL missing or inconsistant pack set it
OLDST5:	MOVEI	T1,[ASCIZ /MISSING OR INCONSISTENT PACK SET ID FOR UNIT /]
	PUSHJ	P,MSGUNI	;
OLDST8:	
	JUMPE	P2,NTISTR	;IF UNIT NOT IN STR, JUMP OVER THIS.
	MOVEI	T1,[ASCIZ .
DISK FORMAT DOES NOT MATCH EXPECTED FORMAT ON UNIT .]
	SKIPN	T2,DSKPPU##	;# of disk pages per unit we expect
	 MOVE	T2,UNIPPU(U)	;If zero, we can accept anything
	CAME	T2,UNIPPU(U)	;Match?
	 PUSHJ	P,MSGUNI	;Error, don't let BPXKON destroy 3650 disk
	LDB	T2,UNYLUN	;GET LOGICAL UNIT # WITHIN STR
	SKIPE	%HOM+HOMNXT	;IS THIS LAST UNIT IN STR?
	 JRST	NLSUNI		;NO - GO LINK UNIT DATA BLOCK INTO STR
	HRRZ	T1,STRUNM(P2)	;HAVE WE ALREADY SEEN A LAST UNIT FOR THIS STR?
	JUMPE	T1,LSTUNI	;NO - NOW WE HAVE
	PUSH	P,T2		;SAVE LOG. UNIT #
	MOVEI	T1,[ASCIZ .
MORE THAN ONE LAST UNIT IN STR .]
	PUSHJ	P,MSGSTR	;PRINT MSG FOLLOWED BY SIXBIT STR NAME
	POP	P,T2		;RESTORE LOG. UNIT #

;HERE WHEN UNIT READ IS THE LAST IN A STR.

LSTUNI:	ANDI	T2,77		;MAX. OF 64 UNITS IN STR!!!!!!!
	HRRM	T2,STRUNM(P2)	;STORE LOG. # OF LAST UNIT IN STR
	AOS	STRUNM(P2)	;LEAVE T2 ALONE BUT MAKE MEMORY OK

;HERE WHEN UNIT READ ISN'T LAST IN THE STR
; LINK UNIT TO STR & OTHER UNITS IN STR

NLSUNI:	MOVEI	T4,STRUNI(P2)	;GET ADR. OF LINK TO 1ST. UNIT DATA BLOCK IN STR
	JRST	LINKT1

LINKIT:	LDB	T3,UNYLN1	;YES - GET LOG. UNIT # OF NEXT UNIT
	CAMLE	T3,T2		;IS IT GREATER THAN UNIT JUST READ?
	 JRST	INSERT		;YES - INSERT UNIT DATA BLOCK HERE
	MOVEI	T4,UNISTR(T1)	;GET ADR. OF LINK TO NEXT UNIT
LINKT1:	HLRZ	T1,(T4)		;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	T1,LINKIT	;MORE DATA BLOCKS?
INSERT:	HRLM	T1,UNISTR(U)	;SAVE LINKS TO STR & NEXT UNIT DATA BLOCK
	HRRM	P2,UNISTR(U)	; IN THIS UNIT DATA BLOCK
	HRLM	U,(T4)		;SAVE THIS UNIT ADR. IN PREVIOUS UNIT DATA BLOCK
				; (OR STR DATA BLOCK)
	JRST	CRESTT		;TRY & SETUP SAB RING & SPT TABLE FOR THIS UNIT

NOSTR:	MOVEI T1,[ASCIZ /
TOO MANY STR'S /]
	PUSHJ P,OCONM
	MOVE	T2,%HOM+HOMSNM
	PUSHJ P,NAMFLO
	STOPCD
;HERE TO CREATE STT TABLE FOR THIS UNIT.
;(EVEN IF NOT IN STR, MAY ADD TO STR LATER.).

NTISTR:	SETZM	UNILOG(U)	;INDICATE UNIT NOT IN A STR.
CRESTT:	PUSHJ	P,SPUCLC	;CALC NO. SATS ON UNIT.
	LDB	P3,UNYSPU	;
	IMULI	P3,STTLEN	;COMPUTE LENGTH OF
	ADDI	P3,1		;STT TABLE.
	MOVE	T2,P3		;GET TOTAL NO. OF WORDS NEEDED
	PUSHJ	P,EVMALC##	;FOR STT
	HRRM	T1,UNISTT(U)	;STORE ADR OF STT IN UNIT DB.
	SETZM	(T1)		;
	HRLZI	T2,(T1)		;BUILD A
	HRRI	T2,1(T1)	;BLT AC.
	ADDI	T1,-1(P3)	;ADR OF LAST WORD IN STT TABLE.
	BLT	T2,(T1)		;CLEAR THE STT.

SCNUN1:	PUSHJ	P,TYPUID	;Output physical name and HOM id
	HLRZ	U,UNISYS(U)	;GET NEXT UNIT DB ADR IN SYSTEM.
	JUMPN	U,SCNUNI	;AROUND AGAIN IF ANY LEFT
	PUSHJ	P,CRLFOP	;Finish off last disk report line
	PUSHJ	P,CRLFOP	;Add a blank line

	PRINTF(<[Need to define seperate UNTTBL for each STR]>)
    ;HERE TO CREATE UNTTBL.
	SETZM	UNTTBL		;CLEAR OUT
	HRLI	T1,UNTTBL	;ALL
	HRRI	T1,UNTTBL+1	;OF
	BLT	T1,UNTTBL+UNTLEN-1 ;UNTTBL.

	HLRZ U,SYSUNI		;GET SET TO GENERATE UNTTBL
	MOVEI T1,UNTLEN-1
SETUNT:	JUMPE U,SCNSTR	;DONE
	SKIPE UNILOG(U)		;IS IT IN A STR?
	JRST SETUTS		;YES
	MOVEM U,UNTTBL(T1)
	DPB T1,UNYLUN
	HLRZ U,UNISYS(U)
	SOJA T1,SETUNT		;AND GO

SETUTS:	LDB T2,UNYLUN
	MOVEM U,UNTTBL(T2)
	HLRZ U,UNISYS(U)
	JRST SETUNT

TYPUI0:	-1
TYPUID:	JSP	T2,SVOTAC	;Save ACs
	AOS	T2,TYPUI0	;Formatting
	TRNN	T2,3		;If multiple of 4,
	 PUSHJ	P,CRLFOP	; start a new line
	LDB	T2,UNYPUN##	;Get physical unit number
	CAIG	T2,7		;If single digit number
	 PUSHJ	P,PRSPC##	; output leading blank
	MOVE	T2,UNINAM(U)
	PUSHJ	P,PRNAME##	;Physical unit name
	PUSHJ	P,PRCOL##	;Colon
	SKIPGE	T1,UNIONC(U)	;Off line?
	 JRST	TYPUI1		;Yes
	MOVE	T2,UNIHID(U)	;No, get UNIT-ID from HOM block
	PUSHJ	P,PRNAMF##	;Output 6 digits
	SKIPE	T2,UNILOG(U)	;Get name (such as 'DSKB17')
	 HRLI	T2,'  ='	;If blank leave it blank, else
	ROT	T2,^D12		; make it '=B17  '
	PUSHJ	P,PRNAMF##	;Output 6 characters (even if all blanks)
	PJRST	OPOUT		;Force out message now
TYPUI1:	MOVE	T1,OFLTAB(T1)	;Get addr of off-line message
	PUSHJ	P,CONMES##	;Output 12 ASCII characters
	PJRST	OPOUT

	%%ZZQ==.
OFLTAB:	PHASE 0 ;123456789012;	;4 drive reports per line = 72 columns
	 [ASCIZ /-offline-   /]	;Pack not spinning or no ID plug
%OFLER::![ASCIZ /unit error  /]	;Hardware indications on drive
%OFLFM::![ASCIZ /bad format  /]	;Incorrectly formatted pack on drive
%OFLMT::![ASCIZ /maintenance /]	;Drive is in MAINT. mode
%OFLRS::![ASCIZ /(no disk)   /]	;No response from drive (RM03 not plugged in)
%OFLIG::![ASCIZ /(ignored)   /]	;Wrong vol-set-ID (belongs to another system)
	PHASE .+%%ZZQ
;HERE WHEN ALL UNITS IN SYSTEM HAVE TRIED TO BE READ &
; THE STR DATA BLOCK HAS BEEN CREATED IF IT CAN BE.  NOW
; CHECK THAT ALL UNITS THAT SHOULD BE ARE PRESENT IN THE STR.

SCNSTR:	MOVEI	P2,STRDDB	;GET ADR. OF STR DATA BLOCK.
	SKIPN	STRNAM(P2)	;IS THERE A STR?
	 JRST	SCNSTD		;NO, NON-SKIP RETURN
	HRRZ	T1,STRUNM(P2)
	JUMPN	T1,LSTRED	;WAS THE LAST UNIT IN THIS STR FOUND?
	MOVEI	T1,[ASCIZ .
LAST UNIT WASN'T FOUND IN STR .]
	PUSHJ	P,MSGSTR	;NO - PRINT MSG. FOLLOWED BY SIXBIT STR NAME
	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN STR
	SKIPA			;
SCNST2:	MOVE	U,T1
	HLRZ	T1,UNISTR(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	T1,SCNST2	;REPEAT UNTIL LAST ONE FOUND
	LDB	T1,UNYLUN	;GET ITS LOG. UNIT # IN STR
	ADDI	T1,1		;MAKE INTO # UNITS IN STR
	HRRM	T1,STRUNM(P2)	; & STORE IT

;HERE TO CHECK FOR THE PRESENCE OF ALL UNITS BUT THE LAST IN A STR.

LSTRED:	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN THIS STR
	SETOM	P4		;SETUP FAKE PREVIOUS LOG. UNIT #
CHKUNI:	LDB	P1,UNYLUN	;GET LOG. UNIT # OF THIS UNIT WITHIN STR
	EXCH	P1,P4		;PUT THIS & PREVIOUS LOG. UNIT #'S IN PROPER ACS
	CAME	P4,P1		;ARE LOG. UNIT #'S THE SAME?
	 JRST	MISUNI		;NO - CHECK FOR MISSING UNITS
	MOVEI	T3,[ASCIZ .
TWO LOGICAL UNIT .]
	MOVEI	T1,[ASCIZ .'S FOUND IN STR .]
	PUSHJ	P,MSGLNG	;PRINT MSGS FOLLOWED BY SIXBIT STR NAME
	JRST	CHKUN1		;CHECK NEXT PAIR OF UNITS

MISUNI:	CAIN	P4,1(P1)	;IS THIS UNIT 1 GREATER THAN LAST ONE?
	 JRST	CHKUN1		;YES - CHECK NEXT PAIR OF UNITS
	ADDI	P1,1		;INCREMENT TO GET CORRECT MISSING LOG. UNIT #
	MOVEI	T3,[ASCIZ .
LOGICAL UNIT .]
	MOVEI	T1,[ASCIZ . MISSING FROM STR .]
	PUSHJ	P,MSGLNG
	JRST	MISUNI		;REPEAT UNTIL ALL MISSING ARE TYPED OUT

CHKUN1:	HLRZ	U,UNISTR(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	U,CHKUNI
	JRST	SCNSD2
;HERE WHEN THROUGH CHECKING ALL UNITS WITHIN A STR.

SCNSTD:	MOVEI	T1,[ASCIZ .
?NO SYSTEM STRUCTURE.]
	PUSHJ	P,SVMOT2	;NO, TYPE MESSAGE
SCNSD2:	SKIPE	ERRHOM		;ANY ERRORS?
	AOS	(P)		;NO - SKIP RETURN
	SKIPE ERRHM2
	AOS (P)
	POPJ	P,

ERRHOM:	0			;FLAG FOR ERRORS WHILE READING A HOME PAGE.
ERRHM2:	0			;"BAD" ERROR DETECTED.

RANHOM:	Z			; Holds PACK-SET ID info (random #)
WRPUNM:	MOVEI	T4,[ASCIZ . IS WRITE PROTECTED.]

	MOVE	P1,UNINAM(U)	;GET SIXBIT UNIT NAME
	MOVEI	T1,[ASCIZ .
.]
	PJRST	NASTYP		;TYPE MSGS. & GET USER'S RESPONSE

;SUBROUTINE TO PRINT "CONTROLLER" FOLLOWED BY A "NAME" FOLLOWED BY "IS OFF-LINE"
; FOLLOWED BY A MESSAGE ASKING WHAT STATE OF THE KONTROLLER IS DESIRED
; THEN IT WAITS FOR OPERATOR TO TYPE AN OCTAL NUMBER TERMINATED BY CRLF
;CALL	MOVE	P1,SIXBIT KONTROLLER NAME
;	MOVEI	T3,MSG. ADR.
;	PUSHJ	P,MCKKON
;	  ERROR RETURN	MSG. PRINTED BUT RESPONSE WASN'T AN OCTAL #
;	OK RETURN	 "      "    T2 CONTAINS OCTAL # TYPED

MCKKON:	MOVEI	T1,[ASCIZ .
.]
	MOVEI	T4,[ASCIZ . IS OFF-LINE.]
NASTYP:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	PUSH	P,T3		;SAVE 2ND. MSG ADR.
	PUSH	P,T4		;SAVE 1ST. MSG. ADR.
	PUSHJ	P,OCONM		;PUT MSG IN BUFFER
	MOVE	T2,P1		;GET UNIT/KONTROLLER SIXBIT NAME
	PUSHJ	P,PRNAME	;PUT IT IN BUFFER
	POP	P,T1		;RESTORE 1ST. MSG. ADR.
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	PUSHJ	P,CRLFOP	;ADD CRLF & O/P MSG.
	POP	P,T1		;RESTORE 2ND. MSG ADR.
	PUSHJ	P,CONOUT	;O/P MSG. & ADD CRLF
	PUSHJ	P,GETLIN	;GET USER'S RESPONSE
	  POPJ	P,		;CR TYPED
	PUSHJ	P,OCTIN		;READ IT AS AN OCTAL NO.
	  POPJ	P,		;NOTHING BUT A BREAK CH.
	  POPJ	P,		;ILLEGAL CH.
	JRST	CPOPJ1		;OK RETURN WITH NO. IN T2

COMMENT #
@@SUBROUTINE FNDSTR
@@PURPOSE
SUBR TO SET UP THE STR DB ADDRESS IN P2 IF THE STR HAS THE
SIXBIT NAME IN T1.
@@ENTRY
EXPECTS SIXBIT STR NAME IN T1.
@@ACCUM
DESTROYS T1 AND P2.
@@EXIT
NON-SKIP RETURNS ONLY IF THE SYSTEM STR HAS BEEN SET UP AND IT
HAS THE NAME IN T1.  ELSE SKIP RETURNS.
@@ #

FNDSTR:	MOVEI	P2,STRDDB	;GET ADDR OF STR DB TO P2.
	TRZ	T1,7777		;STR NAMES ARE A MAX OF 4 CHARS.
	CAME	T1,STRNAM(P2)	;
	AOS	(P)		;
	POPJ	P,
;SUBROUTINE TO MOVE PARAMETERS FROM HOME PAGE TO UNIT DATA BLOCK

MOVUNI:	MOVE	T1,%HOM+HOMLOG	;05 Logical unit name (DSKB0-DSKB37)
	MOVEM	T1,UNILOG(U)	;01
	MOVE	T1,%HOM+HOMHID	;01 Unit ID (330000-330037)
	MOVEM	T1,UNIHID(U)	;02
	MOVE	T1,%HOM+HOMLUN	;06 Logical unit number (00-37)
	DPB	T1,UNYLUN	;03
	MOVE	T1,%HOM+HOMSPU	;15 Sats per unit (4 or 8)
	DPB	T1,UNYSPU	;43
	MOVSI	T2,UNPMSB	;400
	ANDCAM	T2,UNIDES(U)	;53
	CAIE	T1,1		;If more than one SAT page
	 IORM	T2,UNIDES(U)	; then set Multiple Sat Blocks bit
	MOVE	T1,%HOM+HOMFEP	;14 Front-End Pointer (set on 2020 disks)
	MOVEM	T1,UNIFEP(U)	;07 (nonzero when BOOTS in pages 3-5 on KS)
	POPJ	P,
;SUBROUTINE TO MOVE PARAMETERS FROM HOME PAGE TO STR DB.

MOVSTR:	MOVE	T1,%HOM+HOMSNM	;02 Structure name
	MOVEM	T1,STRNAM(P2)	;00
	HRRZ	T1,%HOM+HOMP4C	;26 Pages for CRASH.SAV
	HRRM	T1,STRP4C(P2)	;02
	MOVE	T1,%HOM+HOMSUF	;23 Page # of RIB to SYS on unit 0
	TLO	T1,RBREAL	;   Make it a real RIB pointer
	MOVEM	T1,SYSRIB##
	MOVE	T1,%HOM+HOMMFD	;25 Page # of RIB to MFD on unit 0
	TLO	T1,RBREAL	;   Make it a real RIB pointer
	MOVEM	T1,MFDRIB
	MOVE	T1,UNIPPU(U)	;41 Pages per unit
	CAMLE	T1,STRPPU(P2)	;06 If this one has more than any other in STR
	 MOVEM	T1,STRPPU(P2)	;06  then set this bogus value
	MOVE	T1,%HOM+HOMOVR
	MOVEM	T1,STROVR(P2)
	MOVE	T1,%HOM+HOMREF
	HLLM	T1,STRREF(P2)
	POPJ	P,
;Error messages
MSGLNG:	JSP	T2,REFSAV	;SAVE P4,T3,F,U & J AND INDICATE STR NEEDS REFRESHING
	PUSH	P,T1		;SAVE 2ND. MSG ADR. IN T1
	MOVE	T1,T3		;GET ADR OF 1ST. MSG
	PUSHJ P,CLRSND
	PUSHJ	P,TYPDEC	;PUT MSG. & UNIT # IN BUFFER
	PUSHJ	P,OPOUT		;O/P BUFFER
	POP	P,T1		;RESTORE 2ND. MSG ADR.
	CAIA

MSGSTR:	JSP	T2,REFSAV	;SAVE P4,T3,F,U & J AND INDICATE STR NEEDS REFRESHING
	PUSHJ	P,OCONM		;PUT MSG. IN BUFFER
	SETOM	ERRHOM		;INDICATE ERROR IN "RDHOME"
	SETOM ERRHM2		;"BAD" ERROR
	MOVE	T2,STRNAM(P2)	;GET SIXBIT STR NAME
NAMFLO:	PUSHJ	P,PRNAME	;PUT IT IN THE BUFFER FOLLOWED BY CRLF & START O/P
	PJRST	CRLFOP


MSGUNI:	JSP	T2,REFSAV
	PUSH	P,UNINAM(U)
	PUSHJ	P,OCONM
	SETOM	ERRHOM
	SETOM	ERRHM2
	POP	P,T2
	PJRST	NAMFLO

COMMENT #
@@SUBROUTINE GETHOM
@@PURPOSE
SUBR TO TRY TO READ BOTH OF A UNIT'S HOME PAGES SUCCESSFULLY
INTO %HOM.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS IF AT LEAST ONE OF THE PAGES READ SUCCESSFULLY.
@@ #

GETHOM:	MOVSI	P2,(SIXBIT .HOM.)
	MOVEI	P3,CODHOM	;CODE WORD FOR HOME PAGES.
	MOVE	P4,[XWD LPNHOM,LP2HOM]	;P4/ NO. 1ST PAGE,,2ND PAGE.
	MOVEI	PG,%HOM.P
	PJRST	RDBOTH		;READ & VERIFY HOME PAGES.




COMMENT #
@@SUBROUTINE GETBAT
@@PURPOSE
SUBR TO TRY TO READ BOTH OF A UNIT'S BAT PAGES SUCCESSFULLY
INTO %BAT.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS IF AT LEAST ONE OF THE PAGES READ SUCCESSFULLY.
@@ #

GETBAT:	PUSHJ	P,SETBAT	;
	PJRST	RDBOTH		;




COMMENT #
@@SUBROUTINE SETBAT
@@PURPOSE
LITTLE SUBR TO SET UP SOME PARAMETERS FOR HANDLING BAT PAGES.
@@ #

SETBAT:	MOVSI	P2,(SIXBIT .BAT.)
	MOVEI	P3,CODBAT
	MOVE	P4,[XWD LPNBAT,LP2BAT]
	MOVEI	PG,%BAT.P	;
	POPJ	P,

COMMENT #
@@SUBROUTINE RDBOTH
@@PURPOSE
SUBROUTINE TO READ SPECIAL REDUNDANT PAGES ON THE DISK (HOME
AND BAT) INTO CORE.
@@ENTRY
EXPECTS U/ UNIT DB, P2/ SIXBIT BAT, HOM, OR SAT, P3/ AP-
PROPRIATE CODE WORD FOR PAGES, P4/ PAGE NO. ON THE
DISK OF 1ST PAGE,, 2ND PAGE, AND PG/ PCB ADDRESS.
PRINTS NO ERROR MESSAGES IF NOERH <>0.
@@ACCUM
DESTROYS
@@CALLS
RDCHEK.
@@EXIT
NON-SKIP RETURNS ONLY IF BOTH PAGES ARE BAD.
T3/ 0 IF NO ERRORS, O'E LH(T3)<>0 IF ERROR ON 1ST PAGE AND
RH(T3)<>0 IF ERROR ON 2ND PAGE.
S=0 IF NO ERRORS, ELSE S HAS THE STANDARD RH ERROR BITS SET.
NOERH = 0 ON EXIT.
@@ #

RDBOTH:	MOVE	F,DDSTAR	;F/ DDB.
	SETZM	REDERR		;CLEAR ERR FLAG FOR BOTH PAGES.
FIROK:	SETOM	WHICH		;INDICATE READING 1ST PAGE.
	HLRZ	T4,P4		;T4/ DISK PAGE NO.
	PUSHJ	P,RDCHEK	;READ PAGE & CHECK FOR ERRORS.
	  JRST	REDSEC		;ERR DETECTED - GO TRY 2ND PAGE.
	JUMPG	T3,RDBSKP	;NO ERR. JUMP TO SUCCESS IF WE
				;ARE HERE FROM A BAD 2ND PAGE.

REDSEC:	SETZM	WHICH		;INDICATE READING 2ND PAGE.
	HRRZ	T4,P4		;T4/ DISK PAGE NUMBER.
	PUSHJ	P,RDCHEK	;READ PAGE & CHECK FOR ERRORS.
	  JUMPL	T3,RDBNON	;ERROR(S) DETECTED.  IF ON 1ST
				;PAGE AS WELL, GIVES ERR RETURN.
	JUMPG	T3,FIROK	;IF 2ND BAD 1ST OK GO RETRY 1ST.
RDBSKP:	AOS (P)			;SET FOR SKIP RETURN.
RDBNON:	SETZM NOERH		;CLR NO ERR MSG FLAG.
	POPJ P,

COMMENT #
@@SUBROUTINE RDCHEK
@@PURPOSE
SUBR CALLED BY RDBOTH AND OTHERS TO READ A SPECIAL PAGE
INTO CORE AND CHECK FOR ERRORS.
@@ENTRY
EXPECTS  T4/ PAGE NO. ON UNIT, F/ FILE DB, PG/ PCB ADDRESS,
U/ UNIT DB, P2/ SIXBIT BAT, HOM, OR
SAT, AND P3/ CODE WORD FOR PAGES.
WHICH <>0 FOR FIRST PAGE, =0 FOR 2ND.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@CALLS
OPAGIN AND RDWMSG.
@@ACCUM
DESTROYS
@@EXIT
FOR 1ST PAGE, LH(T3)=0 UNLESS ERROR, IN WHICH CASE LH(T3)<>0.
FOR 2ND PAGE, RH(T3)=0 UNLESS ERROR, IN WHICH CASE RH(T3)<>0.
NON-SKIP RETURN IF ERROR, ELSE SKIP-RETURN.
IF NO ERROR, S=0 ELSE S HAS RH ERROR BITS SET.
@@ #

RDCHEK:	SETZM	CHKFLG		;CLR FLG FOR USE OF RDCHEK ONLY
				;(NEEDED SINCE S ACCUMULATES.).
	PUSHJ	P,OPAGIN	;READ THE PAGE.
	  SKIPA	T3,UNINAM(U)	;ERROR	- GET SIXBIT UNIT NAME.
	JRST	CONCHK		;GO MAKE CONSISTANCY CHECKS.
	MOVEI	T1,[ASCIZ . PAGE HARDWARE READ ERROR.]
	PUSHJ	P,RDWMSG	;PRINT ERROR MSG. FOR PAGE TYPE.
	SETOM	CHKFLG		;SAW ERROR ON THIS PAGE.
CONCHK:	PUSHJ	P,GETPEV	;GET VIRTUAL ADDR FOR PCB IN PG IN T2
	CAMN	P2,[SIXBIT /SAT/] ;READING SAT.SYS RIB PAGE?
	CAME	P2,RIBNAM(T2)	;YES. NAME IN RIB = 'SAT'?
	 CAMN	P2,PAGNAM(T2)	;NO - CHECK BLOCK NAME(THIS ALWAYS FAILS WITH RIB)
	CAME	P3,PAGCOD(T2)	;OK - CHECK CODE WORD
	 SKIPA	T3,UNINAM(U)	;NO CHECK - GET SIXBIT UNIT NAME
	  JRST	TSTCHK		;EXIT CHECKING ERRORS ON THE WAY
	MOVEI	T1,[ASCIZ . PAGE CONSISTENCY ERROR.]
	PUSHJ	P,RDWMSG	;PRINT ERROR MSG. FOR PAGE TYPE
	SETOM	CHKFLG		;SAW ERROR ON THIS PAGE.
TSTCHK:	MOVE	T3,REDERR	;ERR WRD FOR CHECKING BY CALLER.
	SKIPN	CHKFLG		;SKIP RETURN IF
	 AOS	(P)		;NO ERRORS.
	POPJ	P,

CHKFLG: Z	;FLAG FOR USE BY RDCHEK ONLY.

COMMENT #
@@SUBROUTINE WTBOTH
@@PURPOSE
SUBR TO WRITE SPECIAL REDUNDANT PAGES TO THE DISK (HOM
AND BAT) FROM CORE.
@@ENTRY
EXPECTS F/ FILE DB, U/ UNIT DB, P4/ PAGE NO. ON
DISK OF 1ST PAGE,, 2ND PAGE, AND PG/ PCB ADDRESS.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@ACCUM
DESTROYS
@@CALLS
OPAGOT AND RDWMSG.
@@EXIT
RETURNS WITH S = 0 IF NO ERRORS. OTHERWISE S HAS STANDARD
RH ERROR BITS SET.
T3/ 0 IF NO ERRORS, OTHERWISE RH(T3)<>0 IF ERROR ON 2ND PAGE
AND LH(T3)<>0 IF ON 1ST PAGE.
@@ #

WTBOTH:	SETZM	REDERR		;CLR ERR SWITCH FOR BOTH PAGES.
	SETOM	WHICH		;INDICATE WRITING 1ST PAGE.
	PUSHJ	P,GETPEV	;GET VIRTUAL ADDRESS OF DATA FROM C(PG)
	MOVE	P1,T2		;GET IN MORE PERMANENT PLACE THAN T2

WRTRN1:	LDB	T1,UNYLUN	;ALSO WORKS FOR ONES NOT IN STR
	MOVSI	T2,RBREAL	;
	DPB	T1,RBYUNI	;
	HLRZ	T4,P4		;
	DPB	T4,RBYPNO	;
	MOVEM	T2,PAGSLF(P1)	;
	HRLZS	P4		;SETUP P4 FOR PAGE #2.
	PUSHJ	P,WTCHEK	;GO WRITE OUT PAGE.
	SETZM	WHICH		;INDICATE WRITING 2ND PAGE.
	JUMPN	P4,WRTRN1	;HAVE WE WRITTEN BOTH PAGES?
	SKIPN	T3,REDERR	;ERR WRD FOR CHECKING BY CALLER.
	 AOS	(P)		;SKIP RETURN IF NO ERRORS.
	POPJ	P,		;

WTCHEK:	PUSHJ	P,OPAGOT	;TRY TO WRITE THE PAGE.
	  JRST	.+2		;ERRORS.
	POPJ	P,		;WON.
	MOVEI	T1,[ASCIZ .HARDWARE WRITE ERROR.]
	MOVE	T3,UNINAM(U)	;PICK UP UNIT NAME AND PRINT
	PUSHJ	P,RDWMSG	;ERROR MSG. FOR PAGE TYPE.
	POPJ	P,

COMMENT #
@@SUBROUTINE RDWMSG
@@PURPOSE
SUBR TO PRINT ERROR MSG. FOR RDCHEK AND WTCHEK, AND TO SET
REDERR APPROPRIATELY.
(REDERR IS AN INTERNAL FLAG FOR RDBOTH AND WTBOTH.).
@@ENTRY
EXPECTS T1/ MSG. ADR. AND T3/ SIXBIT UNIT NAME.
IF NOERH <>0, DOES NOTHING AND RETURNS IMMEDIATELY.
@@ACCUM
DESTROYS
@@CALLS
SVOTAC, CLRSND, PRNAME, CONMES, AND CRLFOP.
@@EXIT
RETURNS LH. OR RH. OF REDERR = -1, DEPENDING ON WHETHER 1ST
OR 2ND PAGE, RESPECTIVELY, HAS ERROR.
@@ #

RDWMSG:	SKIPE	NOERH
	 POPJ	P,		;DO NOT PRINT ERR MSG.
	JSP	T2,SVOTAC	;SAVE T3,F,U & J
	PUSH	P,PG		;SAVE PG.
	PUSH	P,T1		;SAVE ADDR OF MESSAGE
	PUSHJ	P,CLRSND
	MOVE	T2,T3		;SIXBIT UNIT NAME
	PUSHJ	P,PRNAME	;PUT NAME IN BUFFER
	MOVEI	T1,[ASCIZ . FIRST .] ;PRESUME ERROR ON 1ST PAGE.
	SKIPE	WHICH		;2ND. PAGE WAS READ?
	 JRST	FSTERR		;NO - 1ST. PAGE.
	HLLOS	REDERR		;INDICATE ERROR ON 2ND. PAGE.
	SKIPA	T1,[[ASCIZ . SECOND .]]
FSTERR:	 HRROS	REDERR		;INDICATE ERROR ON 1ST. PAGE.
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	MOVE	T2,P2		;GET SIXBIT PAGE TYPE(HOME OR "BAT")
	CAMN	P2,[SIXBIT .SAT.] ;IF THIS WAS A RIB PAGE
	 HRRI	T2,(SIXBIT .RIB.) ; TYPE "SATRIB"
	PUSHJ	P,PRNAME	;PUT IT IN BUFFER
	POP	P,T1		;ADDR OF MESSAGE
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	PUSHJ	P,CRLFOP	;CRLF AND TYPE MESSAGE
	POP	P,PG		;RESTORE PG.
	POPJ	P,

REDERR:	0			;ERR WORD FOR RDBOTH AND WTBOTH.
				; RH=-1 IF ERROR ON 2ND. PAGE,
				; LH "  "    "   "  1ST.   "
WHICH:	0			;FLAG TO INDICATE WHETHER 2ND
				;OR 1ST PAGE BEING READ.

NOERH:	0			;FLAG TO NOT PRINT ERROR FROM UPDHOM.
COMMENT #
@@SUBROUTINE OPAGIN/OPAGOT
@@PURPOSE
ONCE-TIME SUBR TO READ OR WRITE A PAGE.
@@ENTRY
ENTRY POINT OPAGOT IS TO WRITE A PAGE, ENTRY POINT OPAGIN IS TO
READ A PAGE.
EXPECTS U/ UNIT DB, T4/ PAGE NUMBER ON THE UNIT,
PG/ ONCE-TIME PCB ADDRESS, AND F/ DDB.
@@ACCUM
DESTROYS T1-T4 AND S.
@@EXIT
SKIP RETURNS IF NO ERRORS, ELSE NON-SKIP RETURNS AND T3 HAS
THE PGYERR BITS.
@@ #

    ;HERE TO READ A PAGE.
OPAGIN:	MOVEI	T3,PAGIN	;FILIO SUBR TO CALL.
	MOVEI	T1,STDREA
	JRST	OPAGIO

    ;HERE TO WRITE A PAGE.
OPAGOT:	MOVEI	T3,PAGOUT	;FILIO SUBR TO CALL.
	MOVEI	T1,STDWRT

OPAGIO:	PUSH	P,PG		;SAVE PG.
	MOVE	T2,PG		;SET UP T2/ PCB ADDR AND
	DPB	T1,PCISTS	;SET FLAG FOR INTRPT LEVEL.
	HLRZ	PG,PCBPAG(T2)	;PG/ IN-CORE PAGE NUMBER.
	SETZ	T1,		;CLEAR ANY
	DPB	T1,PGYERR	;ERROR BITS.
	PUSHJ	P,OHTINI	;CLEAR OUT ALL OUTPUT ERRORS (SHOULD BE 1 AT THE MOST.)
	DPB	T4,PGYPNO	;SET THE "UNIT NUMBER" AND
	LDB	T1,UNYLUN	;PAGE NUMBER IN PGYADR.
	CAME	U,UNTTBL(T1)	;STRANGE CROCK TO
	MOVEM	U,UNTTBL(T1)	;HELP SWPENQ AND FINPCB, WHICH
	DPB	T1,PGYUNI	;EXPECT UNTTBL TO BE SET UP.
	PUSH	P,T2		;SAVE PCB ADDR.
	PUSHJ	P,(T3)		;CALL PAGIN OR PAGOUT.
	POP	P,T2		;RESTORE PCB ADDRESS.
	LDB	T3,PCISTS	;WAIT FOR
	TRNE	T3,STDWRT!STDREA ;THE INTRPT ON COMPLETION TO
	 JRST	.-2		;HAPPEN.
	LDB	T3,PGYERR	;GET ERRORS.
	POP	P,PG		;RESTORE PG/ PCB ADDR.
	SKIPN	OHTNUM		;SKIP IF GOT AN OUTPUT ERROR.
	 JUMPE	T3,CPOPJ1	;SKIP RETURN IF NO ERRORS
	POPJ	P,		;
SUBTTL	CHECK ON DISK CAPACITY

DEFINE DSKOFF <WRPI DSKPIF##>
DEFINE DSKON  <WRPI DSKPIN##>

IFCPU(<KI,KL>),<
CPYMSG:	[ASCIZ	/IBM 3330-1/]	  ;0 3330-1  (100 MEGABYTE) IBM DISK ON SA10
	[ASCIZ	/3330-II or 3675/];1 3330-11 (200 MEGABYTE) IBM DISK ON SA10
	[ASCIZ	/3650 or 3652/]	  ;2 3650/52 (300 MEGABYTE) Memorex disk on SA10
	[ASCIZ	/IBM compatible/] ;3 reserved for other IBM disk on SA10
CPYFLG:	-1			;Output geometry message first time thru
>  ;End IFCPU(<KI,KL>)

DSKCPY:	HRRZ	J,UNIKON(U)	;Point to kontroller for this unit
	DSKOFF
	SKIPE	UNISTS(U)	;Unit must be idle before setting CWCOD
	 JRST	[DSKON
		 POPJ	P,]	;Should never get here
	MOVEI	T1,CWCOD	;Set unit to capacity-test wait
	MOVEM	T1,UNISTS(U)
	DSKON			;Turn on disk interrupts
	PUSHJ	P,IOSEL		;Start it going
	MOVSI	T1,100		;Approx 16 seconds
CPYWAT:	SKIPE	UNISTS(U)	;Done yet?
	 SOJG	T1,CPYWAT	;Wait for unit to be idle

IFCPU(<KI,KL>),<;Output what type of disk was found
	SKIPG	UNIONC(U)	;Is it on-line?
	 POPJ	P,		;No
	LDB	T2,UNYKTP##	;Get type of kontroller
	CAIN	T2,4		;Is it "BP"?
	AOSE	CPYFLG		;Yes, has message been output yet?
	 POPJ	P,		;Don't mention it
	LDB	T1,UNYUTP##	;Get unit type
	MOVE	T1,CPYMSG(T1)	;Description
	PUSHJ	P,CONMES
	MOVEI	T1,[ASCIZ / unknown format/]
	LDB	T2,UNYBPR##	;Get blocks per record
	CAIN	T2,1		;Does each record = 1 block?
	 MOVEI	T1,[ASCIZ / formatted in blocks/]
	CAIN	T2,4		;Does each record = 4 blocks?
	 MOVEI	T1,[ASCIZ / formatted in pages/]
	JUMPE	T1,CPOPJ	;No message if unit is off-line
	PUSHJ	P,CONOUT	;How formatted
>  ;End IFCPU(KI,KL)
	POPJ	P,		;End of DSKCPY
;SUBROUTINE TO EXECUTE AN INSTRUCTION FOR ALL UNITS WITHIN A STR.
; USUALLY STORES A BYTE
;T1=INSTRUCTION TO BE EXECUTED, P1=ARG., P2=STR DATA BLOCK ADR.

STOUNI:	HLRZ	U,STRUNI(P2)
	PUSH	P,T1
STOUN1:	XCT	(P)		;EXECUTE INSTRUCTION SUPPLIED IN AC T1
	HLRZ	U,UNISTR(U)
	JUMPN	U,STOUN1
	JRST	TPOPJ




DECLOP:	JSP	T2,SVOTAC	;Output string in T1 then number in P1
	PUSHJ	P,TYPDEC
	PJRST	CRLFOP

TYPMSN:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	PUSHJ P,CLRSND
	PUSHJ	P,TYPDEC	;PUT MSG. IN THE BUFFER FOLLOWED BY DECIMAL #
	PJRST	OPOUT		;O/P THE BUFFER

TYPDEC:	PUSHJ	P,CONMES	;Output message in T1
	MOVE	T1,P1		;Then number in P1
	PJRST	RADX10




SPSNAM:	SKIPA	T2,STRNAM(P2)
SPUNAM:	MOVE	T2,UNINAM(U)
	PJRST PRNAME

SVMOT2:	SETOM ERRHM2
SVMOTE:	SETOM	ERRHOM
	PUSHJ P,CLRSND
SVMOUT:	JSP	T2,SVOTAC
CONOUT:	PUSHJ	P,CONMES
CRLFOP:	PUSHJ	P,CRLF
	PJRST	OPOUT

ASKQUE:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	PJRST	YESNO		;GET USER'S RESPONSE - SKIP RETURN IF 1ST.
				;T3="Y" NON SKIP RETURN IF ANYTHING ELSE TYPED



;T2 & T3 ARE RESPECTED

SETCHG:	MOVSI	T1,UNPCHG	;PREPARE TO FLAG HOME PAGES NEED REWRITING
	MOVSI	T4,UNPOFL!UNPHWP
	TDNN	T4,UNIDES(U)	;IS UNIT WRITE PROTECTED OR OFF-LINE?
	IORM	T1,UNIDES(U)	;SET UNPCHG FLAG
	POPJ	P,		;RETURN



;SUBR TO MARK A UNIT AS A PRIVATE/PUBLIC PACK.
SETPUB:	MOVSI	T3,UNPPRV	;
	ANDCAM	T3,UNIDES(U)	;
	POPJ	P,		;

SETPRV:	MOVSI	T3,UNPPRV	;
	IORM	T3,UNIDES(U)	;
	POPJ	P,		;
	
;Get name of physical unit
GETUNI:	PUSHJ	P,GETLIN	;GET USER'S RESPONSE
	  POPJ	P,		;JUST CR TYPED - NON SKIP RETURN
	PUSHJ	P,CTEXT		;GET SIXBIT UNIT NAME
	SETZM	U		;ASSUME "ALL" WAS TYPED
	HLRZ	T1,T2		;MAKE AC LOOK GOOD FOR COMPARE
	PUSHJ	P,FNDUNI	;SEE IF UNIT EXISTS & RETURN WITH UNIT DATA BLOCK
	  SKIPA	T1,[[ASCIZ .NOT A PHYSICAL UNIT-TRY AGAIN.]]
	 JRST	CPOPJ1		;UNIT EXISTS - SKIP RETURN
	PUSHJ	P,SVMOUT	;ADD CRLF & O/P MSG.
	JRST	GETUNI		;TRY AGAIN

FNDUNI:	HLRZ	U,SYSUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN SYSTEM
FNDUN1:	CAMN	T2,UNINAM(U)	;MATCH?
	 JRST	CPOPJ1		;YES - SKIP RETURN
	HLRZ	U,UNISYS(U)	;GET NEXT UNIT DATA BLOCK ADR. IN SYSTEM
	JUMPN	U,FNDUN1	;REPEAT IF THERE IS ONE
	POPJ	P,		;NONE FOUND - NON SKIP RETURN

;SUBROUTINE TO PRESERVE AC'S P4,F,U & J

REFSAV:	HRROS	STRREF(P2)	;INDICATE STR NEEDS REFRESHING
SVOTAC:	PUSH	P,P4
	PUSH	P,T3
	PUSH	P,F
	PUSH	P,U
	PUSH	P,J
	PUSHJ	P,(T2)
	  CAIA
	AOS	-5(P)
	POP	P,J
	POP	P,U
	POP	P,F
	POP	P,T3
	POP	P,P4
	POPJ	P,

COMMENT #
@@SUBROUTINE REDBAT
@@PURPOSE
SUBR TO READ AND VERIFY THE BAT PAGES ON ALL UNITS IN THE SYSTEM.
@@ENTRY
EXPECTS
@@CALLS
CHKBAT AND SCNBAT.
@@ACCUM
DESTROYS
@@ #

REDBAT:	HLRZ	U,SYSUNI	;GET ADR. OF 1ST UNIT DB IN THE SYSTEM.
	MOVSI	P4,UNPOFL
RDBAT1:	TDNE	P4,UNIDES(U)	;UNIT OFF-LINE?
	JRST	RDBAT6		;YES, GO READ NEXT BAT PAGE
	PUSHJ	P,CHKBAT	;NO - GO CHECK "BAT" PAGES FOR THIS UNIT
	  JFCL			;IGNORE ERRORS
RDBAT6:	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA PAGE IN SYSTEM
	JUMPN	U,RDBAT1	;REPEAT IF THERE IS ONE
	POPJ	P,		;NONE LEFT - EXIT

COMMENT #
@@SUBROUTINE CHKBAT/BATREF
@@PURPOSE
SUBR TO READ THE BAT PAGES AND ALLOW THE USER TO REINITIALIZE
THEM IF THEY ARE BAD.
@@ENTRY
THE ENTRY POINT CHKBAT READS THE BAT PAGES AND IF ERRORS ARE
FOUND, ASKS THE USER IF HE/SHE WISHES TO REINITIALIZE THE BAT
PAGES.  IF YES, IT FALLS INTO BATREF, WHICH DOES.
EXPECTS U/ UNIT DB AND F/ DDB.
@@ACCUM
DESTROYS
@@CALLS
SVOTAC, GETBAT, ASKQUE, CORZER, SETBAT, AND WTBOTH.
@@EXIT

@@ #

CHKBAT:	JSP	T2,SVOTAC	;SAVE P4,F,U & J.
	SETZM	BATBAD		;CLEAR BAT PAGE BAD FLAG.
	PUSHJ	P,GETBAT	;READ BOTH BAT PAGES & VERIFY THEM.
	  JFCL			;ERROR(S)
	SKIPN	T1,REDERR	;ANY ERRORS FOUND AT ALL IN EITHER BAT PAGE?
	 PJRST	WTBOTH		;No, rewrite UNI field of self pointer
	MOVEM	T1,BATBAD	;YES. BAD BAT PAGE.
	SKIPE	BATMAN		;DO NOT GET TO REFRESH IF FORCED
	 POPJ	P,		; (I.E. FROM FILMAN).
	MOVEI	T1,[ASCIZ .
Do you want to initialize the BAT pages on this UNIT?
.]
	MOVSI	T2,UNPHWP
	TDNN	T2,UNIDES(U)	;DON'T INITIALIZE IF UNIT HARDWARE WRITE-PROTECT
	 PUSHJ	P,ASKQUE	;TYPE QUESTION & GET USER'S RESPONSE
	  POPJ	P,		;HE DOESN'T WANT TO
	MOVEI	T1,[ASCIZ .
THIS is not normally done, are you SURE?
.]
	PUSHJ	P,ASKQUE	;ASK AGAIN
	  POPJ	P,		;HE SAVED HIMSELF SOME BOTHER
	MOVE T3,P1		;GET CORE PNTR IN CORRECT AC.

BATREF:	MOVEI	T1,%BAT
	PUSHJ	P,CORZER	;
	PUSHJ	P,SETBAT	;
	MOVEM	P2,%BAT+PAGNAM	;PUT SIXBIT 'BAT' IN THE PAGE.
	MOVSI	T1,-BRMAX	;SETUP AOBJN PTR. TO BE STORED IN PAGE
	HRRI	T1,BATREG
	MOVEM	T1,%BAT+BATFIR ;SAVE IT IN THE PAGE
	MOVEM	P3,%BAT+PAGCOD ;SAVE THE CODE FOR BAT PAGES IN THE PAGE
	PJRST	WTBOTH		;

BATBAD:	0			;0 INDICATES VIRGIN BAT PAGES(INITIALIZED)
				; LH = -1 INDICATES ERROR(S) DETECTED WHILE READING
				; RH = # BAD REGIONS ON UNIT
BATMAN:	0			;0=OPTIONAL, -1=MANDATORY
;SUBROUTINE TO TYPE SIXBIT UNIT NAME FOLLOWED BY (ID)
; ENTER WITH U = UNIT DATA BLOCK ADR.

TYPUNI:	MOVEI	P1,[ASCIZ .,.]
TYPUN1:	MOVE	T1,P1		;GET MSG. ADR. INTO KOSHER AC
	PUSHJ	P,CONMES	;PUT "," OR MSG. IN BUFFER
	JUMPE	U,OPOUT	;JUST O/P MSG.
	PUSHJ	P,SPUNAM	;PUT SIXBIT UNIT NAME IN BUFFER
	MOVEI	T1,[ASCIZ .(.]
	PUSHJ	P,CONMES	;PUT "(" IN BUFFER
	SKIPE	T2,UNIHID(U)	;GET SIXBIT UNIT ID - IF ANY
	PUSHJ	P,PRNAME	;PUT IT IN THE BUFFER
	MOVEI	T1,[ASCIZ .).]
	PUSHJ	P,CONMES	;PUT ")" IN THE BUFFER
	PJRST	OPOUT		;O/P BUFFER

;SUBROUTINE TO TYPE STR NAME IN "SYS" SEARCH LIST.

TYPSYS:	MOVEI	T1,[ASCIZ .
STR IN "SYS" SEARCH LIST:.]
	PUSHJ	P,CONOUT
	PUSHJ	P,SPSNAM	;PUT SIXBIT STR NAME IN BUFFER
	PJRST	OPOUT		;O/P BUFFER & EXIT
TYPSR1:	PJRST	CRLFOP		;O/P CRLF

;SUBROUTINE TO TYPE ALL UNITS IN SYSTEM THAT ARE NOT IN ANY STR
; RETURN WITH P1,P4,F,U & J DESTROYED

TYPUNS:	MOVEI	P1,[ASCIZ .
UNITS NOT IN A FILE STRUCTURE:
.]
	HLRZ	U,SYSUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN SYSTEM
	TDZA	P4,P4		;INDICATE UNIT ID TO BE TYPED IN TYPUNI
TYPNS1:	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN SYSTEM
	JUMPE	U,CPOPJ		;EXIT IF NONE LEFT
	SKIPE	UNILOG(U)	;IS THIS UNIT IN A STR?
	JRST	TYPNS1		;YES - CHECK NEXT UNIT
	PUSHJ	P,TYPUN1	;NO - TYPE MSG., UNIT NAME & (ID)

TYPNS2:	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN SYSTEM
	JUMPE	U,TYPSR1	;O/P CRLF & EXIT IF NONE LEFT
	SKIPN	UNILOG(U)	;IS THIS UNIT IN A STR?
	PUSHJ	P,TYPUNI	;YES - TYPE "," UNIT NAME & (ID)
	JRST	TYPNS2		;REPEAT

;SUBROUTINE TO TYPE THE STR & ITS UNITS.
; RETURN WITH P1,P4,F,U & J DESTROYED

TYPSTR:	SETZM	P4		;INDICATE UNIT ID TO BE PRINTED IN TYPUNI
	MOVEI	P2,STRDDB	;ADR. OF STR DATA BLOCK.
	SKIPN	STRNAM(P2)	;ANY STR?
	POPJ	P,		;NO.
    ;TYPE STR NAME & ALL ITS UNITS.

	HLLZ	T2,STRREF(P2)
	JUMPE	T2,NOREF	;DOES STR NEED REFRESHING?
	MOVEI	T1,[ASCIZ .NEEDS REFRESHING .]		;YES
	PUSHJ	P,CONMES	;PUT MSG IN BUFFER
NOREF:	PUSHJ	P,SPSNAM	;PUT SIXBIT STR NAME IN BUFFER
	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT IN STR
	JUMPE	U,CRLFOP	;IF NO UNITS IN STR - O/P BUFFER WITH CRLF & EXIT
	PUSHJ	P,OPOUT	;O/P BUFFER
	MOVEI	P1,[ASCIZ .:.]
	PUSHJ	P,TYPUN1	;TYPE ":" UNIT NAME & (ID) [IST. TIME THRU]
TYPST1:	HLRZ	U,UNISTR(U)	;GET NEXT UNIT DATA BLOCK IN STR
	JUMPE	U,TYPSR1	;IF NO MORE UNITS - ADD CRLF & EXIT
	PUSHJ	P,TYPUNI	;TYPE "," UNIT NAME & (ID)
	JRST	TYPST1		;REPEAT UNTIL NO MORE UNITS IN STR

TYPALL:	PUSHJ P,TYPSTR
	PUSHJ P,TYPUNS
	PUSHJ P,TYPSYS
	JRST FILCMD

;ROUTINE TO TYPE VALUE AND MESSAGE OR ASK FOR NEW
;VALUE USING MIN AND MAX
;ONLY TYPE IF TYPONL NON-0
;DBLSTD MAY HAVE 2 VALUES TO TRY WITHOUT ASKING
;VALUE IN P1, MSG IN T1, RESULT IN T2
;NON-SKIP RETURN IF UNCHANGED OR ONLY TYPING

ASKQMM:	SKIPGE TYPONL
	 JRST DECLOP	;JUST TYPE IT
	MOVEM T1,MSGSAV	;SAVE MESSAGE
	MOVEM P1,VALSAV	;AND VALUE
	MOVE T2,MIN
	CAMN T2,MAX
	JRST RETFIX	;ONLY ONE POSSIBLE VALUE
ASKRPT:	SKIPL DBLSTD
	JRST QSTSTD	;TRY A STANDARD ANSWER
	PUSHJ P,FTYUNI	;FORCED TYPE OF UNIT?
	 JRST KNNUNI	;NO
	MOVE T1,MSGSAV
	MOVE P1,VALSAV	;MAKE SURE RESTORED
KNNUNI:	PUSHJ P,DECLOP	;TYPE VALUE AND MESSAGE
	MOVEI T1,[ASCIZ /MIN = /]
	MOVE P1,MIN
	PUSHJ P,TYPDEC
	MOVEI T1,[ASCIZ / MAX = /]
	MOVE P1,MAX
	PUSHJ P,DECLOP
	PUSHJ P,GETLIN
	 JRST KEPSAM	;DOES NOT WANT IT CHANGED
	PUSHJ P,DECIN
	 JFCL
	 JRST ASKRP1	;ASK FOR IT AGAIN, WAS BAD
	CAIN	T3,"-"	;IS HYPHEN TERMINATOR?
	JRST	ASKRP1	;YES, NEGATIVE RESPONSE ILLEGAL
CHKANS:	CAMG T2,MAX
	CAMGE T2,MIN
	JRST ASKRPQ	;NOT IN RANGE
RETFIX:	CAME T2,VALSAV
	AOS (P)
	SETOM DBLSTD	;SO NOTHING THERE NEXT TIME
	POPJ P,

QSTSTD:	HLRZ T2,DBLSTD	;GET FIRST TRY
	CAIN T2,377777
	MOVE T2,MAX	;FLAG FOR MAX
	JRST CHKANS

KEPSAM:	MOVE T2,VALSAV
	JRST CHKANS

ASKRPQ:	MOVEI T1,[ASCIZ /
VALUE NOT IN PERMITTED RANGE/]
	SKIPGE DBLSTD	;NO ERROR IF STANDARD SETTING
	PUSHJ P,CONOUT	;PUT OUT THE MESSAGE
	HRLOS DBLSTD	;TRY SECOND STANDARD IF PRESENT
ASKRP1:	MOVE T1,MSGSAV
	MOVE P1,VALSAV
	JRST ASKRPT	;TRY AGAIN

MSGSAV:	0
DBLSTD:	0
VALSAV:	0
TYPONL:	0
MAX:	0
MIN:	0
KNOUNI:	0

COMMENT #
@@SUBROUTINE MAYREF
@@PURPOSE
SUBR TO TYPE WARNING THAT A CHANGE WILL CAUSE REFRESH.
@@ #

MAYREF:	SKIPL TYPONL
	SKIPL DBLSTD
	 POPJ P,		;ONLY TYPING, OR DOING STANDARD
	JUMPE P2,CPOPJ	;NO STR
	HLLZ T1,STRREF(P2)
	JUMPN T1,CPOPJ	;ALREADY SET FOR REFRESH
	MOVEI T1,[ASCIZ /
CHANGE WILL CAUSE STR TO NEED REFRESHING/]
	PJRST CONOUT




COMMENT #
@@SUBROUTINE FTYUNI
@@PURPOSE
LITTLE SUBR TO POSSIBLY TYPE A UNIT NAME.
@@ #

FTYUNI:	SKIPE KNOUNI	;KNOW WHAT UNIT?
	 POPJ P,		;YES
	PUSHJ P,SPUNAM
	AOS (P)
	SETOM KNOUNI
	PJRST CRLFOP
COMMENT #
@@SUBROUTINE SPUCLC
@@PURPOSE
SUBR TO CALC THE NUMBER OF SATS FOR A UNIT, GIVEN THE NO. OF
PAGES ON THE UNIT.
@@ENTRY
EXPECTS U/ UNIT DB.
@@ACCUM
DESTROYS T2 AND T3.
@@EXIT
SETS UNYSPU.
@@ #

SPUCLC:	MOVE	T2,UNIPPU(U)	;T2/ NO. OF PAGES ON THE UNIT.
	SUBI	T2,1		;
	IDIVI	T2,400*^D36	;DIVIDE BY NO. PAGES PER SAT.
	ADDI	T2,1		;
	DPB	T2,UNYSPU	;SET ANSWER.
	POPJ	P,

COMMENT #
@@SUBROUTINE UNITST
@@PURPOSE
SUBR TO CALC AND STORE THE NO. OF SATS ON A UNIT.  MAY FLAG
HOME PAGES NEED REWRITING.
@@ENTRY
EXPECTS U/ UNIT DB.
JUST RETURNS IF TYPONL IS < 0.
@@CALLS
SPUCLC AND SETCHG.
@@EXIT
STORES RESULT IN UNYSPU.
@@ #

UNITST:	SKIPGE	TYPONL
	POPJ	P,
	LDB	T3,UNYSPU
	PUSHJ	P,SPUCLC
	CAME	T3,T2
	PJRST	SETCHG
	POPJ	P,

COMMENT #
@@SUBROUTINE UNITID
@@PURPOSE
SUBR TO SET THE UNIT ID.
@@ #

UNITID:	PUSHJ	P,FTYUNI
	JFCL
	MOVEI	T1,[ASCIZ /
UNIT ID IS /]
	SKIPN	P1,UNIHID(U)
	MOVEI	T1,[ASCIZ /
ZERO UNIT ID - NEW ID NEEDED/]
	PUSHJ	P,CONMES
	SKIPE	T2,P1		;PRINT IF NON-ZERO.
	PUSHJ	P,PRNAME
	PUSHJ	P,CRLFOP
	SKIPGE	TYPONL
	POPJ	P,		;DONE IF ONLY PRINTING.
	PUSHJ	P,GETLIN
	  SKIPA	T2,UNIHID(U)	;NO CHANGE, GET BACK OLD.
	PUSHJ	P,CTEXT	;READ
	JUMPE	T2,UNITID	;STILL 0, TRY AGAIN.
	EXCH	T2,UNIHID(U)
	CAME	T2,UNIHID(U)
	PJRST	SETCHG		;CHANGED.
	POPJ	P,		;NOT CHANGED

COMMENT #
@@SUBROUTINE STRTCH
@@PURPOSE
SUBR TO ALLOW THE REDEFINITION OF THE SIZE OF CRASH.SAV.
@@ #

STRTCH:	SETZM	MIN
	MOVE	T1,[^D8192+2]	;(2**22)/512. (allow for EXE directory pages)
	MOVEM	T1,MAX
	PUSHJ	P,MAYREF
	HRRZ	P1,STRP4C(P2)
	MOVEI	T1,[ASCIZ /PAGES FOR CRASH.SAV = /]
	PUSHJ	P,ASKQMM
	  POPJ	P,
	HRRM	T2,STRP4C(P2)
	HRROS	STRREF(P2)
CHGSTR:	MOVE	T1,[PUSHJ P,SETCHG]
	PJRST	STOUNI



COMMENT #
@@SUBROUTINE
@@PURPOSE
SUBR TO ALLOW THE REDEFINITION OF THE NO. OF PAGES OF
OVERDRAW PER USER.
@@ #

STRTOV:	SETZM	MIN
	MOVE	T1,STRPPU(P2)
	MOVEM	T1,MAX
	MOVEI	T1,[ASCIZ /# OF PAGES ALLOWED FOR OVERDRAW PER USER = /]
	MOVM	P1,STROVR(P2)
	PUSHJ	P,ASKQMM
	POPJ	P,
	MOVNM	T2,STROVR(P2)
	PJRST	CHGSTR

COMMENT #
@@SUBROUTINE STSDEF
@@PURPOSE
SUBR TO DEFINE A STR.
@@ENTRY
EXPECTS
@@ACCUM
DESTROYS
@@CALLS
CONOUT, GETLIN, CTEXT, FNDSTR, GETUNI, CMPLOG, SETCHG,
STRTOV, AND STRTCH.
(AND ITS INTERNAL SUBRS STSINS, UNICHK, AND UNICK1.).
@@ #

STSDEF:	MOVE	T1,[SIXBIT/DSKB/] ;ALL STR NAMES ARE DSKB.
	PUSHJ	P,FNDSTR	;DOES THIS STR ALREADY EXIST?
	  SKIPA	T1,[[ASCIZ /STR already exists/]] ;YES, THIS IS A NO-NO.
	JRST	STSNEW		;NO, OKAY UNLESS ALREADY A STR.
	PJRST	CONOUT

STSNEW:	SKIPN	STRNAM(P2)	;DOES ANY STR EXIST?
	 JRST	STSNE1		;NO, THIS IS IT.
	MOVEI	T1,[ASCIZ /
Too many file structures!  Only one allowed!
/]
	PJRST	CONOUT

    ;HERE WITH A GOOD STR NAME.
STSNE1:	PUSHJ	P,CLRSTR
	MOVEM	T1,STRNAM(P2)
	HRROS	STRREF(P2)	;NEED REFRESH.
    ;HERE TO PUT THE UNITS IN THE STR.
STSNE2:	MOVEI	T1,[ASCIZ /Type names of physical units in STR, extra CR when done/]
	PUSHJ	P,CONOUT

	MOVEI	P3,STRUNI(P2)
	SETZ	P1,
STSNXT:	PUSHJ	P,GETUNI	;GET A UNIT NAME
	JRST	[CAIE P3,STRUNI(P2)  ;FINISHED GETTING UNIT NAMES.
		  JRST STSFIN
		 JRST STSNE2]
	PUSHJ	P,STSINS	;INSERT UNIT.
	  JRST	STSNXT		;ALREADY IN STR
	JRST	STSNXT		;CONTINUE

    ;SUBR INTERNAL TO STSDEF TO INSERT A UNIT IN THE STR.
STSINS:	HRRZ	T1,UNISTR(U)	;SEE IF THIS UNIT IS ALREADY IN A STR.
	JUMPE	T1,STSUN2	;T1 = 0 IF IT ISN'T
	MOVEI	T1,[ASCIZ .
Unit already in file structure
.]
	PJRST	CONOUT		;TYPE MSG. & EXIT

STSUN2:	HRLM	U,(P3)		;LINK THIS UNIT DATA BLOCK TO PREVIOUS ONE
	HRRZM	P2,UNISTR(U)	;ATTACH THIS UNIT DATA BLOCK TO THIS STR
	HRRZ	T1,STRUNM(P2)	;GET LOGICAL UNIT # WITHIN STR
	DPB	T1,UNYLUN	;SAVE IT IN UNIT DATA BLOCK
	PUSHJ	P,CMPLOG	;COMPUTE SIXBIT LOGICAL UNIT NUM, STORE IN UNILOG
	PUSHJ	P,SETPUB
PRINTF(<[All references to STRPPU should be eliminated]>)
	MOVE	T1,UNIPPU(U)
	CAMLE	T1,STRPPU(P2)
	 MOVEM	T1,STRPPU(P2)
	CAIE P1,0
	 CAMGE	T1,UNIPPU(P1)	;COMPARE WITH SMALLEST SO FAR
	MOVE	P1,U		;SAVE ADDR OF SMALLEST IN P1
	AOS	STRUNM(P2)	;INCREMENT # OF UNITS IN STR
	PUSHJ	P,SETCHG	;FLAG THAT UNIT'S HOME PAGES MUST BE REWRITTEN
	MOVEI	P3,UNISTR(U)	;MAKE CURRENT UNIT PREDECESSOR
	JRST	CPOPJ1		;SKIP RETURN

    ;HERE TO FINISH UP.
STSFIN:	HLRZ	U,STRUNI(P2)
	HLRZ	U,UNISTR(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	U,.-1		;REPEAT IF ANY LEFT
	SETZM	TYPONL		;JUST IN CASE.
	MOVE	U,P1		;GET SMALLEST UNIT.
	LDB	P1,UNYKTP##	;Get Kontroller type
	PUSH	P,P1		;SAVE IT.
	MOVE	T1,OVRDEF(P1)
	HRLOM	T1,DBLSTD
	PUSHJ	P,STRTOV	;SET OVERDRAW.
	MOVE	T1,(P)
	MOVE	T1,P4CDEF(T1)	;Pages for CRASH.SAV based on kontroller type
	HRLOM	T1,DBLSTD
	PUSHJ	P,STRTCH	;SET DEFAULT SIZE OF CRASH.SAV.
	POP	P,P1
	MOVE	T1,[PUSHJ P,UNICK1]
	PUSHJ	P,STOUNI	;CHECK SATS.
	MOVE T1,[PUSHJ P,UNICHK]
	PJRST STOUNI		;NOW DO ALL UNITS.

    ;A LITTLE INTERNAL STSDEF SUBR.
UNICHK:	SETZM KNOUNI		;DO NOT KNOW UNIT.
	PJRST UNCHKA		;GO DO THE STANDARD STUFF.

    ;A LITTLE INTERNAL STSDEF SUBR.
UNICK1:	SETZM KNOUNI
	SETZM TYPONL		;JUST TO MAKE SURE.
	PJRST UNITST		;CHECK SATS.

;DEFAULT DEFS BY UNIT TYPE.

;Default overdraw in blocks
OVRDEF:	1	;0 DR (unused)
	^D50	;1 FH (unused)
	^D125	;2 DP (unused)
	^D125	;3 MF (unused)
	^D125	;4 3330
	^D125	;5 RM03
	^D125	;6 AP
	^D125	;7    (unused)

;Default pages for CRASH.SAV
P4CDEF:	0	;0 DR (unused)
	0	;1 FH (unused)
	^D512	;2 DP (unused)
	^D512	;3 MF (unused)
	^D8192+1;4 3330 KI/KL with 4096K of memory = 8193 pages for CRASH.EXE
	^D512	;5 RM03 KS-2020
	^D512	;6 AP   Foonly
	^D512	;7    (unused)
COMMENT #
@@SUBROUTINE STSDSL
@@PURPOSE
SUBR TO DISSOLVE A STR.
CLEARS UNILOG, UNISTR, AND STRNAM AND FLAGS THAT ALL THE
STR'S UNITS' HOME PAGES NEED REWRITING.
@@ENTRY
EXPECTS
@@ACCUM
DESTROYS
@@CALLS
SETCHG.
@@ #

STSDSL:	PUSH	P,T2		;SAVE T2 AND
	PUSH	P,T1		;T1.
	MOVEI	P2,STRDDB
	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN STR.
	JUMPE	U,DISST2	;JUST UNLINK STR IF IT HAS NO UNITS.
	MOVSI	T1,UNPPRV	;UNIT MAY BE GOING PRIVATE.
DISST1:	SETZB	T3,UNILOG(U)	;CLEAR OUT NAME OF LOGICAL UNIT WITHIN STR.
	EXCH	T3,UNISTR(U)	;CLEAR OUT LINKS TO STR & NEXT UNIT DATA BLOCKS.
	IORM	T1,UNIDES	;UNIT IS NOW A PRIVATE PACK
	PUSHJ	P,SETCHG	;FLAG THAT THIS UNIT'S HOME PAGE MUST BE REWRITTEN.
	HLRZ	U,T3		;GET NEXT UNIT DATA BLOCK ADR.
	JUMPN	U,DISST1	;REPEAT IF THERE IS ONE.
DISST2:	PUSHJ	P,CLRSTR	;INDICATE STR NO LONGER EXISTS.
	POP	P,T1		;RESTORE T1 AND
	POP	P,T2		;T2.
	POPJ	P,		;RETURN - DON'T WORRY ABOUT RETURING CORE
				; AS RDHOME MUST BE CALLED AGAIN.



COMMENT #
@@SUBROUTINE CLRSTR
@@PURPOSE
LITTLE SUBR TO CLEAR OUT THE STR DB (SETTING STRNAM TO
ZERO INDICATES THAT THERE IS NO STR.).
@@ACCUM
DESTROYS NO ACS.
@@ #

CLRSTR:	PUSH	P,T1
	PUSH	P,STRDDB+STRBTS
	SETZM	STRDDB	
	HRLI	T1,STRDDB
	HRRI	T1,STRDDB+1
	BLT	T1,STRDDB+STRLEN-1
	POP	P,T1
	HRRZM	T1,STRDDB+STRBTS
	POP	P,T1
	POPJ	P,

COMMENT #
@@SUBROUTINE ADDUNI
@@PURPOSE
SUBR TO ADD A UNIT TO THE SYSTEM STR.
@@ENTRY
EXPECTS
@@CALLS

@@ACCUM
DESTROYS
@@EXIT

@@ #

ADDUNI:	MOVEI	P2,STRDDB	;P2/ ADDR OF STR DB.
	SKIPN	STRNAM(P2)	;HAS THE STR BEEN DEFINED?
	 JRST	ADDNOT		;NO, ILLEGAL TO ADD TO IT.
	MOVEI	T1,[ASCIZ .Enter unit name to add.]
	PUSHJ	P,CONOUT	;BY NOW P2=STR DDB.
	PUSHJ	P,GETUNI	;GET A UNIT NAME.
	  JRST	CANTAD		;NOT A UNIT, CAN NOT ADD.
	JUMPE	U,CANTAD	;CAN NOT ADD ALL EITHER.
	HRRZ	T1,UNISTR(U)	;IS THE UNIT IN A STR ALREADY?
	JUMPE	T1,ADDUN2	;NO.
	MOVEI	T1,[ASCIZ .THAT unit is already in a structure.]
	JRST	CONOUT

    ;HERE WHEN WE HAVE A UNIT TO ADD, AND THE UNIT IS NOT
    ;ALREADY IN A STR.
ADDUN2:	MOVE	T1,UNIPPU(U)
	CAMLE	T1,STRPPU(P2)	;MUST NOT WANT TO CHANGE STRPPU
	 JRST	CANTAD
	SETZM	TYPONL
	PUSHJ	P,UNCHKA	;SET UNIT ID AND NO. OF SATS PER UNIT.
	HRRZ	T1,STRUNM(P2)
	LDB	T2,UNYLUN
	DPB	T1,UNYLUN	;CHANGE THIS UNIT NUMBER
	SETZM	UNTTBL(T2)	;ZERO OLD CELL
	MOVE	T1,T2
	SKIPE	UNTTBL-1(T1)
	 SOJA	T1,.-1		;LOOK FOR ZERO
	CAMN	T1,T2
	 JRST	ADUNT
	EXCH	U,UNTTBL(T1)	;GET THAT ONE
	DPB	T2,UNYLUN	;CHANGE ITS NUMBER
	EXCH	U,UNTTBL(T2)	;AND STOR IN NEW PLACE (SETS U=0)
	EXCH	U,UNTTBL(T1)	;GET OLD U BACK
ADUNT:	LDB	T1,UNYLUN	;AND OLD UNIT NUMBER
	MOVEM	U,UNTTBL(T1)	;STORE IN NEW PLACE
	HLLZ	T1,STRREF(P2)	;IS IT MARKED FOR REFRESH
	JUMPN	T1,ADDUN4	;YES, DO NOT NEED TO REFRESH PACK
	PUSH	P,P2		;SAVE THE STR POINTER.
	PUSHJ	P,UPDHOM	;WRITE HOME PAGES.
	POP	P,P2		;RESTORE STR PTR.
	MOVSI	P4,UNPCHG
	ANDCAM	P4,UNIDES(U)	;PAKREF WILL READ HOME PAGES.
	PUSHJ	P,PAKREF	;REFRESH PACK.
	  JRST	CANTAD		;COULD NOT DO IT.
ADDUN4:	AOS	T1,STRUNM(P2)	;ONE MORE IN STR
	SUBI	T1,1		;
	HRRZM	P2,UNISTR(U)	;LINK TO STR DDB
	PUSHJ	P,CMPLOG	;MAKE A LOGICAL UNIT NAME
	HLRZ	T1,STRUNI(P2)
ADDUN5:	HLRZ	T2,UNISTR(T1)
	JUMPE	T2,ADDUN7	;FIND END OF CURRENT LIST
	MOVE	T1,T2
	JRST	ADDUN5
ADDUN7:	PUSH	P,T1		;SAVE LAST UNIT.
	HRLM	U,UNISTR(T1)
	PUSHJ	P,SETCHG	;MARK HOME PAGE CHANGED.
	PUSHJ	P,SETPUB
	POP	P,U		;WANT TO SET CHANGED HOME ON THIS ONE TOO.
	PUSHJ	P,SETCHG
	POPJ	P,

ADDNOT:	MOVEI T1,[ASCIZ .The SYSTEM structure has not been DEFINED yet.]
	JRST CONOUT

CANTAD:	HLLZS	UNISTR(U)	;
	MOVEI	T1,[ASCIZ .Cannot add unit to structure.]
	JRST	CONOUT
;SUBR TO REFRESH A STR.

STSREF:	PUSHJ	P,GETDAT	;Get date (so HOME.SYS doesn't say 2-JAN-64)
	MOVEI	T1,UFDHSI	; RANNO already setup!
	HRRM	T1,STRHSH+STRDDB
	SKIPN	RANHOM		; Is this a virgin pack set?
	 AOS	RANHOM		; If so, prevent RDHOME from complaining.
	PUSHJ	P,RWRHOM	;WRITE HOME PAGES.
	SETZM	BATMAN
	PUSHJ	P,RDHOME	; Read & Verify HOM pages
	  JFCL			; Ignore "all" errors
	  JFCL
	MOVE	F,DDSTAR
	PUSHJ	P,REFRSH	;REFRESH THE STR.
	  JRST	CNTADS		;LOST.
	PUSHJ	P,RDHOME	; Read & Verify new HOM pages
	  JFCL			; Just to make sure.
	  JFCL
	POPJ P,

CNTADS:	HRROS	STRREF(P2)	;MARK WE STILL NEED REFRESHING.
	MOVEI	T1,[ASCIZ /The structure WAS NOT successfully refreshed./]
	PJRST	CONOUT

GETDAT:	SKIPL	THSDAT##	;Do nothing if date is valid
	 POPJ	P,
	JSP	T4,SAVE4	;Save P2 and P4
	PUSH	P,J
	MOVEI	J,0		;Job 0 is local time zone
GETDT1:	MOVEI	T1,[ASCIZ /Enter date as MM-DD-YYYY /]
	PUSHJ	P,OCONM
	PUSHJ	P,OPOUT
	PUSHJ	P,GETLIN	;Get response
	  JRST	GETDT1
	PUSHJ	P,DECIN		;	MM
	  JRST	GETDT1
	  JRST	GETDT1
	MOVEI	P2,-1(T2)
	IMULI	P2,^D31
	PUSHJ	P,DECIN		;	    DD
	  JRST	GETDT1
	  JRST	GETDT1
	ADDI	P2,-1(T2)
	PUSHJ	P,DECIN		;		YYYY
	  JRST	GETDT1
	  JRST	GETDT1
	SUBI	T2,^D1964
	IMULI	T2,^D31*^D12
	ADD	T2,P2
	PUSHJ	P,COMDAS##
	  JRST	GETDT1
GETDT2:	MOVEI	T1,[ASCIZ /Enter time as HHMM /]
	PUSHJ	P,OCONM
	PUSHJ	P,OPOUT
	PUSHJ	P,GETLIN	;Get response
	  JRST	GETDT2
	PUSHJ	P,DECIN		;4 digit number
	  JRST	GETDT2
	  JRST	GETDT2
	MOVE	T1,T2		;SET TIME ACCORDING TO ARGUMENT
	IDIVI	T1,^D100	;Seperate HH from MM
	IMULI	T1,^D60		;
	ADD	T1,T2		;COMPUTE MINUTES
	PUSHJ	P,COMTMS##
	  JRST	GETDT2
	POP	P,J
	POPJ	P,
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	Routine SETRAN - Start timer for pseudo-random number		;;
;;									;;
;;	Called by CMDSCN whenever it prompts the operator for		;;
;;	anything during ONCE and ONCDSK.  Needed in conjunction		;;
;;	with GETRAN which reads the current timer value for the		;;
;;	REFRESH command.						;;
;;									;;
;;	Clobbers T1, T2  - depending upon processor			;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SETRAN:			; Entry point to start timer for random number
IFCPU (<KL,KS>),<
IFCPU (<KL>),<
	EXTERN EPT
	SETZM	EPT+EPTLTB	; Clear EPT locations (KL)
	CONO	MTR,MO.TON	; Turn on MTR clock
>; END IFCPU (KL)
IFCPU (KS),<
	SETZB	T1,T2		; Set the Time Base
	WRTIME	T1		; To Zero.
>;END IFCPU (KS)
	POPJ	P,		; Return.
>;END IFCPU(<KL,KS>)

IFCPU (<KI,F3>),<
	MOVE	T1,[JRST CLKLVL]; New Clock-routine
	EXCH	T1,CH7+1	; Set New/Save Old Value
	MOVEM	T1,CLKRAN	; Store for later
	SETZM	CLKCNT		; Reset time base
	WRPI	1B25!1B35	; TURN ON CHANNEL SEVEN.
IFCPU (KI),<WRAPR 1B25!1B26!7B35>
IFCPU (F3),<WRAPR LP.ESF+LP.CSF+LP.CLK+7B35>
	POPJ	P,		; Return.

CLKLVL:	AOS	CLKCNT		;
IFCPU (KI),<WRAPR 1B25!1B26!7B35>	;
IFCPU (F3),<WRAPR LP.ESF+LP.CSF+LP.CLK+7B35>
	JEN	@CH7

CLKRAN:	Z			; Holder for old CH7+1
CLKCNT: 0			; Timer value
>;END IFCPU (<KI,F3>)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	Routine GETRAN - Read the time-base or clock value		;;
;;									;;
;;	Called by CMDSCN in ONCE and ONCDSK each time the operator	;;
;;	is prompted for a response.  Updates RANNO## with a new		;;
;;	random seed used by REFSTR each time.				;;
;;									;;
;;	Clobbers T1.							;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

External RANNO			  ; Located in REFSTR, set here each cmd line

GETRAN:	PUSH	P,T2		  ; Save this register (T2)
IFCPU (<KL,KS>),<RDTIME	T1>	  ; Read time base setup earlier + counter
IFCPU (KL),<LSH T2,-^D12>	  ; Strip low order zero bits on KL
IFCPU (<KI,F3>),<
	HRRZ T2,CLKCNT		  ; Read clock setup earlier + elapsed
IFCPU (KI),<WRAPR 1B24!7B35>	  ; Disable CLOCK now
IFCPU (F3),<WRAPR LP.CSF+LP.DSF+LP.CLK+7B35>
	WRPI	1B26!1B35	  ; Turn OFF channel seven
	MOVE	T1,CLKRAN	  ; Get previous channel 7
	MOVEM	T1,CH7+1	  ; Reset
>;End IFCUP(<KI,F3>)
	TRNN	T2,-1		  ; Make sure RH is neq 0
	 MOVEI	T2,(SIXBIT /CAT/) ; If not, set to 'CAT'
	HRRZM	T2,RANNO	  ; Store for later
	POP	P,T2		  ; Restore T2 from entry
	POPJ	P,		  ; Return.
;SUBR TO ALLOW OPER TO QUERY/SELECT DSKCLN TYPE
;
SPCDKN:	MOVEI	T1,[ASCIZ /
DSKCLN mode is: /]
	PUSHJ	P,OCONM		;MOVE MSG TO OUTPUT BUF
	PUSHJ	P,SPCDKP	;GET CURRENT DC MODE AND PRIORITY
	MOVSI	T1,DCN.ON	;INDIC OPER HAS SEEN AND/OR
	IORM	T1,DCN		; SELECTED DSKCLN MODE
	MOVE	T2,SCNDSK(T2)	;GET SIXBIT NAME OF CURRENT MODE
	CAIN	T3,^L<(DCN.DF)>	;IS MODE DEFAULT?
	 MOVE	T2,[SIXBIT /NULL/]	;YES, TELL THIS TO OPER
	PUSHJ	P,PRNAME	;BUFFER MODE NAME
	PUSHJ	P,CRLFOP	;APPEND CRLF, DO CTY OUTPUT
SPCDK1:	MOVEI	T1,[ASCIZ /DSKCLN mode desired? /]
	PUSHJ	P,OCONM		;MOVE MSG TO OUTPUT BUF
	PUSHJ	P,OPOUT		;DO CTY OUTPUT
	PUSHJ	P,GETLIN	;GET OPER'S RESPONSE
	 POPJ	P,		;NULL, NO CHANGE IN MODE
	MOVEI	P1,SCNDSK	; Get address of Scan Table
	SETZM	CMDSCF		; Specify NO STR/UNIT stuff
	PUSHJ	P,CMDSCN	; Call Scanning routine
	  JRST	SPDKHP		; No good!
	DPB	P3,DCNYON	;SAVE IN DCN
NULDSK:	POPJ	P,		;RETURN

SPDKHP:	MOVEI	T1,[ASCIZ \
Bad entry: Type 'FULL', 'FAST', 'NONE'
 or just <Return> for default (NO CHANGE)\]
	PUSHJ	P,CONOUT	;TYPE ERROR MSG ON CTY
	JRST	SPCDK1		;LET OPER TRY AGAIN

;MODE-MNEMONIC CORRESPONDENCE TABLE
;
	DEFINE	MKDSK <
	X NONE,0,Ab.Nak,
	X FAST,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X FULL,0,Ab.Nak,
>

	SCNTB	(SPDKHP,SPDKHP,DSK)

;ROUTINE TO GET/SET DSKCLN MODE AND DETERMINE WHO LAST SET IT
;
SPCDKP:	MOVE	T2,DCN		;GET DSKCLN MODE WORD
	JFFO	T2,.+1		;DETERMINE HIGHEST PRIORITY MODE
	LDB	T2,DCNTAB(T3)	;FETCH IT
	DPB	T2,DCNYON	;OPER HAS SEEN OR SELECTED THIS MODE
	POPJ	P,		;RETURN

FILGO:	MOVEI T1,[Asciz\
Leaving the FILES dialogue...\]
	PUSHJ P,LNGMES		; Let everyone know we're leaving!
RWRHOM:	MOVSI P4,UNPCHG
	HLRZ U,SYSUNI		;FIRST UNIT
CHGHOM:	TDNE P4,UNIDES(U)
	PUSHJ P,UPDHOM		;REWRITE IF NEEDED.
	ANDCAM P4,UNIDES(U)
	HLRZ U,UNISYS(U)
	JUMPN U,CHGHOM
	POPJ P,


COMMENT #
@@SUBROUTINE UPDHOM
@@PURPOSE
SUBROUTINE TO READ A HOME PAGE, UPDATE IT FROM THE STR AND
UNIT DB, AND THEN WRITE IT OUT.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
@@ACCUM
DESTROYS
@@CALLS
SVOTAC, GETHOM, AND WTBOTH.
@@ #

UPDHOM:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	SETOM	NOERH		;NO ERRORS PRINTED FOR HOME READ.
	PUSHJ	P,GETHOM	;GET HOME PAGE INTO CORE.
	  JRST	[MOVEI T1,%HOM
		PUSHJ P,CORZER
		JRST .+1]
	MOVEM	P2,%HOM+PAGNAM	;SAVE SIXBIT HOME PAGE IDENTIFIER
	HRRZ	P2,UNISTR(U)	;GET STR DATA BLOCK ADR.
	MOVE	T1,UNIHID(U)	;GET SIXBIT UNIT ID
	MOVEM	T1,%HOM+HOMHID	;SAVE IN HOME PAGE
	HLRZ	T1,UNISTR(U)	;GET NEXT UNIT DATA BLOCK ADR. IN STR
	SKIPE	T1		;SAVE 0 IF LAST UNIT IN STR OR NOT IN A STR
	MOVE	T1,UNIHID(T1)	;GET ITS ID
	MOVEM	T1,%HOM+HOMNXT	;SAVE IN HOME PAGE
	SKIPE	T1,P2		;SAVE 0 STR NAME IF UNIT NOT IN A STR
	MOVE	T1,STRNAM(P2)	;GET SIXBIT STR NAME
	MOVEM	T1,%HOM+HOMSNM	;SAVE IN HOME PAGE
	JUMPE	P2,UPDHM3	;BYPASS ALL REFERENCES TO VALUES IN STR DATA BLOCK
	HLRZ	T2,STRUNI(P2)	;GET ADR. OF 1ST UNIT DATA BLOCK IN STR
UPDHM1:	MOVE	T1,T2		;CURRENT UNIT_NEXT UNIT
	JUMPE	T1,UPDHM2	;IF NONE LEFT SAVE 0 IN HOMPRV
	HLRZ	T2,UNISTR(T1)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	MOVE	T1,UNIHID(T1)	;GET CURRENT UNIT'S SIXBIT ID
	CAME	T2,U		;IS ADR. OF NEXT UNIT DATA BLOCK SAME AS THIS ONE?
	JRST	UPDHM1		;YES - PUT SIXBIT ID INTO THIS UNIT'S HOME PAGE
UPDHM2:	MOVEM	T1,%HOM+HOMPRV	;SAVE IN HOME PAGE
				; 0 OR SIXBIT UNIT ID OF PREVIOUS UNIT IN STR
	HLLZ	T1,STRREF(P2)	;GET 'REFRESH' FLAG
	HLLM	T1,%HOM+HOMREF	;SAVE IN HOME PAGE
	HRRZ	T1,STRDDB+STRHSH ;
	HRLZM	T1,%HOM+HOMHSH	;
	HRRZ	T1,RANHOM	;Use Remembered HOMRAN value
	HRRM	T1,%HOM+HOMRAN	;
	MOVE	T1,STROVR(P2)	;GET -VE # PAGES USER IS ALLOWED TO OVERDRAW
	MOVEM	T1,%HOM+HOMOVR	;SAVE IN HOME PAGE
	HRRZ	T1,STRP4C(P2)	;GET # PAGES FOR CRASH.SAV
	MOVEM	T1,%HOM+HOMP4C	;SAVE IN HOME PAGE

UPDHM3:	MOVE	T1,UNILOG(U)	;GET SIXBIT LOGICAL UNIT WITHIN STR
	MOVEM	T1,%HOM+HOMLOG	;SAVE IN HOME PAGE
	LDB	T1,UNYLUN	;GET LOGICAL UNIT # WITHIN STR
	MOVEM	T1,%HOM+HOMLUN	;SAVE IN HOME PAGE
	LDB	T1,UNYSPU	;GET # SAT BLOCKS PER UNIT
	MOVEM	T1,%HOM+HOMSPU	;SAVE IN HOME PAGE
	MOVEI	T1,%HOM+HOMEND+1 ;FIRST WORD TO CLEAR.
	CAILE	T1,%HOM+HOMDAT-1 ;SKIP IF AT LEAST ONE WORD.
	JRST	UPDHM4
	SETZM	(T1)		;CLEAR THE FIRST WORD
	CAIN	T1,%HOM+HOMDAT-1	;SKIP IF MORE
	JRST	UPDHM4
	HRLI	T1,%HOM+HOMEND+1
	HRRI	T1,%HOM+HOMEND+2
	BLT	T1,%HOM+HOMDAT-1	;CLEAR UNUSED WORDS
    ;HERE TO WRITE OUT.
UPDHM4:	MOVEM	P3,%HOM+PAGCOD	;SAVE CODE WORD IN HOME PAGE.
	MOVSI	P2,(SIXBIT .HOM.) ;RESTORE ARG.
	PUSHJ	P,WTBOTH	;WRITE OUT BOTH HOME PAGES
	STOPCD
	POPJ	P,		;RETURN

;PRINT OR CHANGE SAT+RIB PCBS
TYPSPC:	MOVE	P1,NMSTPC
	MOVEI	T1,[ASCIZ /NUMBER OF SAT PCBS = /]
	PJRST	DECLOP

CHGSPC:	MOVEI	T1,5
	MOVEM	T1,MIN
	MOVEI	T1,^D40		;%CTAMX=77  MAX PERMISSABLE VALUE IN PCBIO
	MOVEM	T1,MAX
	MOVEI	T1,[ASCIZ /NUMBER OF SAT PCBS = /]
	MOVE	P1,NMSTPC
	PUSHJ	P,ASKQMM
	 POPJ	P,
	MOVEM	T2,NMSTPC
	POPJ	P,


TYPRPC:	MOVE	P1,NMRBPC
	MOVEI	T1,[ASCIZ /NUMBER OF RIB PCBS = /]
	PJRST	DECLOP

CHGRPC:	MOVEI	T1,5
	MOVEM	T1,MIN
	MOVEI	T1,^D20		;%CTAMX=77  MAX PERMISSABLE VALUE IN PCBIO
	MOVEM	T1,MAX
	MOVEI	T1,[ASCIZ /NUMBER OF RIB PCBS = /]
	MOVE	P1,NMRBPC
	PUSHJ	P,ASKQMM
	  POPJ	P,
	MOVEM	T2,NMRBPC
	POPJ	P,

;CHANGE BAT BLOCKS

CHGBAT:	MOVEI	T1,[ASCIZ /Type unit name to refresh BAT pages  /]
	PUSHJ	P,CONMES
	PUSHJ	P,OPOUT
	PUSHJ	P,GETUNI
	  POPJ	P,
	PUSHJ	P,BATREF
	  POPJ	P,
	POPJ	P,
;TYPE BAT

TYPBAT:	MOVEI	T1,[ASCIZ /Type unit name  /]
	PUSHJ	P,CONMES
	PUSHJ	P,OPOUT
	PUSHJ	P,GETUNI
	  POPJ	P,
	SETZM	BATMAN
	PUSHJ	P,CHKBAT
	  JFCL			;IGNORE ERRORS.
	MOVE	T2,UNINAM(U)	;Physical unit name
	PUSHJ	P,PRNAME
	MOVEI	T3,"("
	PUSHJ	P,COMTYO
	MOVE	T2,UNILOG(U)	;Logical name (such as DSKB1)
	PUSHJ	P,PRNAME
	MOVEI	T3,":"
	PUSHJ	P,COMTYO
	MOVE	T2,UNIHID(U)	;Home block ID
	PUSHJ	P,PRNAME
	MOVEI	T3,")"
	PUSHJ	P,COMTYO
	MOVE	T2,%BAT+BATFIR	;Get AOBJN pointer
	ADDI	T2,%BAT
	SETZB	P3,P1		;P1 IS PAGE COUNT, P3 REGION COUNT.
TYPBT1:	SKIPN	BATNBB(T2)
	 JRST	TYPBT2		;DONE.
	ADDI	P3,1		;1 REGION.
	LDB	T1,BAYNBB	;(uses T2 as index reg)
	ADDI	P1,1(T1)	;THIS MANY PAGES.
	AOBJP	T2,TYPBT2
	AOBJN	T2,TYPBT1
TYPBT2:	MOVEI	T1,[ASCIZ /  (counts do not agree)/]
	CAMN	P1,%BAT+BATPAT	;Page total
	CAME	P3,%BAT+BATCNT	;Count of regions
	 PUSHJ	P,CONMES
	MOVE	T1,P1
	PUSHJ	P,PR6DIG	;Output number in 6-character field
	MOVEI	T1,[ASCIZ / bad pages in /]
	PUSHJ	P,CONMES
	MOVE	T1,P3
	PUSHJ	P,PRTDIG
	MOVEI	T1,[ASCIZ / distinct regions./]
	PUSHJ	P,CRLFOP
	JUMPE	P3,TYPBT9	;Just CRLF if none
	MOVEI	T1,[ASCIZ /Do you want a list of bad spots? /]
	PUSHJ	P,YESNO		;Skip if "Y"
	  POPJ	P,		;Done if "N" or no bad spots
;Output the bad spots

	MOVE	P2,%BAT+BATFIR	;Reset AOBJN pointer
	ADDI	P2,%BAT
TYPBT3:	SKIPN	BATNBB(P2)	;Zero marks end
	 JRST	TYPBT9
	MOVE	T2,P2		;Set up T2 for BAYNBB
	LDB	T1,BAYNBB	;Get repeat count
	JUMPN	T1,TYPBT4	;Zero means single page
	MOVEI	T1,[ASCIZ / 1 page  at /]
	PUSHJ	P,CONMES
	JRST	TYPBT5

TYPBT4:	ADDI	T1,1		;Add 1 to repeat count
	PUSHJ	P,PR2DIG	;Output leading blank if needed
	MOVEI	T1,[ASCIZ / pages at /]
	PUSHJ	P,CONMES

TYPBT5:	MOVE	T1,BATELB(P2)	;Get page address
	PUSHJ	P,PRT22A	;19-bit octal number
	MOVE	T1,BATELB(P2)	;Page address
	LSH	T1,P2BLSH	;Convert to blocks
	LDB	T2,UNYBPY	;Blocks per cylinder
	IDIV	T1,T2
	LDB	T3,UNYBPT	;Blocks per track
	IDIV	T2,T3
	LDB	T4,UNYBPR	;Blocks per record
	SKIPN	T4		;If old monitor,
	 MOVEI	T4,1		; formatted in blocks
	IDIV	T3,T4
	ADDI	T2,1		;SYSTAT and ERRCHK number heads starting at 1
	ADDI	T3,1		;Everyone numbers records starting at 1
	PUSH	P,T3		;Record (T4 = block in record = 0)
	PUSH	P,T2		;Head
	PUSH	P,T1		;Cyl
	MOVEI	T1,[ASCIZ / = cylinder/]
	PUSHJ	P,CONMES
	POP	P,T1
	PUSHJ	P,PR4DIG
	MOVEI	T1,[ASCIZ /, head/]
	PUSHJ	P,CONMES
	POP	P,T1
	PUSHJ	P,PR3DIG
	MOVEI	T1,[ASCIZ /, record/]	;Entire page is 1 record if in pages
	SKIPL	UNICHR(U)		;If formatted in blocks,
	 MOVEI	T1,[ASCIZ /, records/]	; all 4 blocks are marked as unuseable
	PUSHJ	P,CONMES
	MOVE	T1,(P)
	PUSHJ	P,PR3DIG
	POP	P,T1
	SKIPGE	UNICHR(U)	;Formatted in pages?
	 JRST	TYPBT6		;Yes, done
	MOVEI	T3,"-"		;No, output range of blocks
	PUSHJ	P,COMTYO
	ADDI	T1,3		;4th block in page
	LDB	T2,UNYBPT
	CAMLE	T1,T2		;If end block is past # of blocks per track
	 SUB	T1,T2		; then it is on the next track
	PUSHJ	P,PR2DIG	;Output ending block number
TYPBT6:	PUSHJ	P,SPACE3
	HRRZ	T2,BATNBB(P2)	;Get date
	PUSHJ	P,TYPDAT	;Convert and output it
	PUSHJ	P,CRLF
	AOBJP	P2,CPOPJ	;Increment by 2
	AOBJN	P2,TYPBT3	;Loop

TYPBT9:	SKIPE	%BAT+BATCNT	;If any were found,
	 PUSHJ	P,CRLF		; output a blank link
	POPJ	P,		;End of TYPBAT

;Routine to output the date

TYPDAT:	JUMPE	T2,NODATE	;Call with 14-bit TYMSHARE date in T2
	MOVEI	T1,0		;No time-of-day
	MOVSI	P4,400020	;Convert from TYM-GMT to DEC-local
	PUSHJ	P,DATCOM	;Returns 15-bit date in T2
	  POPJ	P,		;Illegal date
	IDIVI	T2,^D<31*12>	;T2/Year
	ADDI	T2,^D64
	PUSH	P,T2
	IDIVI	T3,^D31		;T3/Month, T4/Day
	PUSH	P,T3
	MOVEI	T1,1(T4)
	PUSHJ	P,PR2DIG	;Day (with leading blank if needed)
	POP	P,T1
	MOVE	T1,MONTAB(T1)	;"-Mmm-"
	MOVEM	T1,DATBLK+0	;DATBLK+1 has 0 in bits 0-6
	MOVEI	T1,DATBLK+0
	PUSHJ	P,CONMES	;Output month
	POP	P,T1
	PJRST	P,PR2DIG	;Year

NODATE:	MOVEI	T1,[ASCIZ /(no date)/]
	PJRST	CONMES

DATBLK:	BLOCK	2
	EXTERN	DATCOM
MONTAB:	ASCII/-Jan--Feb--Mar--Apr--May--Jun--Jul--Aug--Sep--Oct--Nov--Dec-/

;Decimal output routines

PR6DIG:	CAIGE	T1,^D100000	;Output leading blanks if not 6 digits
	 PUSHJ	P,PRSPC
PR5DIG:	CAIGE	T1,^D10000
	 PUSHJ	P,PRSPC
PR4DIG:	CAIGE	T1,^D1000
	 PUSHJ	P,PRSPC
PR3DIG:	CAIGE	T1,^D100
	 PUSHJ	P,PRSPC
PR2DIG:	CAIGE	T1,^D10
	 PUSHJ	P,PRSPC##
	JRST	PRTDIG##

SPACE3:	MOVEI	T1,[ASCIZ /   /];3 blanks
	PJRST	CONMES

	VAR
ONDLIT:	LIT


ONDLNR==.-%OND+1
ONDLNP==<ONDLNR!777>+1

ONSZCK(ONCDSK,OND)	;CHECK TO SEE IF ENOUGH PAGES ALLOCATED

DEPHASE

ONDEND:	END		;Cannot use $END in PHASEd code
   2i$G