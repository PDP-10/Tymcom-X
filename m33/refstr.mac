TITLE REFSTR - ROUTINE TO REFRESH A FILE STRUCTURE

ENTRY	REFRSH,PAKREF,SCNBAT	;Main entry points
ENTRY	TSTSUP,PREAD,PWRITE	;Debugging/maintenance routines
INTERN	REFSTT,REFLNR,REFLNP	;Start of phased code, lengths
INTERN	RANNO			;Set at GETRAN in ONCDSK

EXTERN RIBALP,RIBCOD,RIBUNM,RIBRPS,RBYPNO,RBYUNI,RIBUN1
EXTERN RIBEXT,RIBNAM,RIBPPN,RIBQTF,RIBQTO,RIBSIZ,RIBPVW
EXTERN RIBSLF,RIBSTS,RIBUSD,RIBVER,RIPDIR,RIPNDL,RIPNFS
EXTERN RIBLST,RIBSNM,RIBSFS,RIBRIB,CODRIB
EXTERN RBREAL,RIBSZS,RIBPFS,RBLVPR,RBLVSP,RIBMXA,RBSPAR,RIBPRV

EXTERN UNISTT,UNISTR,UNIPPU
EXTERN UNYPPY,UNYSPU,UNYLUN

EXTERN HOMREF,HOMHSH,HOMRAN

EXTERN STRREF,STRP4C,STRUNI,STRUNM,STRHSH,STRDDB,STRBTS

EXTERN STTAOB,STTLEN,STTPTR,STTFPC,STTSTS

EXTERN %HOM.P,%HMR.P,%STR.P,%STA.P,%BAT.P,%TMP.P,%T2P.P

EXTERN CPOPJ1,REFLAG,SAVT,MFDRIB,CORZER,CORONZ
EXTERN RIBEX1,RIBEX2,RIBEX3,RIBEX4
EXTERN BATFIR,BAYNBB,BATNBB,BATELB,FSFPPN
EXTERN OPAGIN,OPAGOT,WTBOTH,GETBAT,GETHOM
EXTERN SAVE1,SAVE4,OCONM,OPOUT,CONMES
EXTERN UNTTBL,UFDHSI


IFNDEF FTSPAG,<XP FTSPAG,-1>	;; -1 == FT Spare Pages on CYL 1 and 2

REFSTT:
PHASE %REF
	%R==REFSTT-REFSTR	;To look at LABEL, use LABEL+%R

	STOPCD(,ENTRY,REFSTR)
SUBTTL	REFSTR definitions

;QUOTAS FOR UFD'S WE CREATE

ND QF,377777777777	;FIRST COME, FIRST SERVED QUOTA.
ND QO,377777777777	;LOGGED OUT QUOTA.
QUOTAF: EXP QF		;To patch this in SAV file, use QUOTAF+%R/
QUOTAO: EXP QO

;SOME DEFINITIONS FOR HOME AND BAT PAGES AND BOOTS AND SAT.SYS RIB:
;(ALL MUST BE IN THE 1ST SAT ON THE UNIT.).

XP LPN000,0		;Page 0 is reserved (has TOPS-10 HOM block on KS2020)
XP LPNHOM,1		;Logical page # of first HOME page
XP LPNBAT,2		;  "       "    of first BAT page
XP FBOOTB,3		;First BOOTS page (see BOTLOD and MONBTS)
XP NBOOTP,3		; # of pages reserved for BOOTS (pages 3,4,5)
XP LP2HOM,6		;Logical page # of second HOME page
XP LP2BAT,7		;  "       "    of second BAT page
XP LPNSAT,10		;  "       "    of RIB to SAT.SYS
			;1st SAT page is 11 on DSKB0, page 10 on all others

IFN FTSPAG,<		;The size of a cylinder depends on the type of disk
; XP LPNSPG,<CYL*1>	;START OF SPARE PAGES AREA (CYL 1 & 2)
; XP SPGLEN,<CYL*2>	;LENGTH IN PAGES OF SPARE PAGES AREA
> ; End IFN FTSPAG

IFCPU(KS),< XP FEFLEN,100 >	;LENGTH IN PAGES OF FE FILE AREA
DEFINE MSGDIE (A)
<PUSHJ P,[MOVEI T1,A
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	STOPCD ()]>

DEFINE MSGSFE (A)
<PUSHJ P,[MOVEI T1,A
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	MOVEI T1,SOFERR;;CALL PDP-10 OPERATING SYSTEMS GROUP
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	STOPCD ()]>

DEFINE MSGLIV (A)
<PUSHJ P,[MOVEI T1,A
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	POP  P,(P);;Dump most recent PUSHJ return address
	POPJ P,]>

IOFAL:	ASCIZ /
ERROR ON DISK TRANSFER.
/

OGTPG: ASCIZ /
OUT OF ROOM ON DISK.
/

BATBAD:	ASCIZ /
BAT PAGE CONSISTENCY ERROR.
/

RBNOUT:	ASCIZ /
OUT OF RETRIEVAL POINTER SPACE IN NON-EXTENDED FILE.
/

RBEOUT:	ASCIZ /
OUT OF RETRIEVAL POINTER SPACE IN EXTENDED FILE.
/

UFDERR:	ASCIZ /
OUT OF ROOM IN A ONE PAGE UFD.
/

NOTAVL:	ASCIZ /
RESERVED PAGE HAS ALREADY BEEN ALLOCATED.
/

RIBFAL:	ASCIZ/
FAULTY RIB STRUCTURE.
/

SOFERR:	ASCIZ /
SOFTWARE ERROR.
CALL PDP-10 OPERATING SYSTEMS GROUP.
/
SUBTTL	REFRSH - Refresh a complete file structure
;ARGS	P2=ADDR OF STR DATA BLOCK
;	F=ADDR OF DDB

REFRSH::JSP	T4,SAVE4	;SAVE PERMANENT ACS
	HLRZ	U,STRUNI(P2)	;U=ADDR OF FIRST UNIT IN STR
	MOVEM	U,FSTUNI	;REMEMBER FIRST UNIT.
	SETZM	REFUNI		;Not doing PAKREF
	SETZM	R.ZERB		;ZERO OUT LOCS RECORDING FIRST PAGE NOS.
	MOVE	T1,[XWD R.ZERB,R.ZERB+1] ;NEVER ON PAGE 0 SO WE KNOW
	BLT	T1,R.ZERE	;IF REALLY SET UP.
	SETZM	SATDSK		;MARK NO SAT IN CORE IN %STA.

;SET UP RIB IN CORE FOR HOME.SYS.

	MOVE	T1,HOMFIL	;NAME OF HOME.SYS FILE
	MOVE	T2,HOMEXP	;Extension and protection
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%HMR		;PNTR TO HOME.SYS RIB IN CORE.
	MOVEI	P4,RIPNDL!RIPNFS ;NO DELETE, NO FAILSAFE BITS
	PUSHJ	P,RIBSET	;SET UP RIB FOR HOME.SYS.
	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD TO
	HRRI	T1,%HMR+RIBPFS-1
	MOVEM	T1,HOMRBP	;RETREVIAL AREA.

;SET UP RIB IN CORE FOR SAT.SYS.

	MOVE	T1,SATFIL	;NAME OF SAT.SYS FILE
	MOVE	T2,SATEXP	;Extension and protection
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%STR		;PNTR TO SAT.SYS RIB IN CORE.
	MOVEI	P4,RIPNDL!RIPNFS ;NO DELETE, NO FAILSAVE BITS
	PUSHJ	P,RIBSET	;SET UP RIB FOR SAT.SYS.
	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD TO
	HRRI	T1,%STR+RIBPFS-1
	MOVEM	T1,SATRBP	;RETREVIAL POINTER AREA+1.

;SPAGES.SYS is set up later
;HERE IS THE LOOP FOR EACH UNIT IN THE STR.

NXUNIT:	PUSHJ	P,GETBAT	;READ BAT PAGE(S).
	  JRST	REFFAL
	PUSHJ	P,SATCLC	;SET BEGSAT, SVSBTL, LPGSAT, AND SATIND.

;HERE IS THE LOOP FOR EACH SAT ON THE UNIT.

NXTSAT:	PUSHJ	P,INISAT	;Reserve special pages, build RIB to SAT.SYS
	  JRST	REFFAL		; and RIB to HOME.SYS

	PUSHJ	P,NXCLC		;ANOTHER SAT FOR THIS UNIT?
	  JRST	NXTSAT		;YES, GO DO IT.

	HLRZ	U,UNISTR(U)	;NEXT UNIT IN STR.
	JUMPN	U,NXUNIT	;LOOP FOR ALL UNITS IN STR.

;HERE AFTER ALL SATS ON ALL UNITS ARE WRITTEN.

	MOVE	U,FSTUNI	;RESET TO FIRST UNIT IN STR
;WRITE RIBS FOR SAT.SYS AND HOME.SYS ON FIRST UNIT.

    ;WRITE RIB FOR SAT.SYS (IT IS PRE-ALLOCATED)
	MOVEI	T1,%STR		;Set RIBSIZ
	PUSHJ	P,CNVSIZ	;
	SETZ	T2,		;STORE THE EOF AND
	PUSHJ	P,SATRBS	;COUNT THE PRIME RIB IN ALP.
	MOVEI	T4,LPNSAT	;BUILD THE RETRIEVAL POINTER TO
	TLO	T4,RBREAL	;THE SAT.SYS RIB AND
	MOVEM	T4,%STR+RIBSLF	;STORE IT.
	MOVEM	T4,SATRBD	;REMEMBER LOGICAL PAGE NUMBER OF SAT.SYS RIB
	TLZ	T4,RBREAL	;(U is set to first unit)
	MOVEI	PG,%STR.P	;WRITE OUT THE RIB OF
	PUSHJ	P,OPAGOT	;SAT.SYS (page 10 = RIB, page 11 = data)
	  JRST	REFFAL
	MOVE	T1,%STR+RIBALP
	MOVEM	T1,SATALP	;# of pages allocated to SAT.SYS

    ;ALLOCATE AND WRITE RIB FOR HOME.SYS.

	MOVEI	T1,%HMR		;Set RIBSIZ
	PUSHJ	P,CNVSIZ	;
	SETZ	T2,		;STORE THE EOF AND
	PUSHJ	P,HOMRBS	;COUNT THE PRIME RIB IN ALP.
	PUSHJ	P,OGETPG	;ALLOCATE A PAGE FOR HOME.SYS RIB.
	  JRST	REFFAL
	MOVEM	T2,%HMR+RIBSLF
	MOVEM	T2,HOMRBD	;REMEMBER LOG. PAGE NUMBER OF RIB FOR HOME.SYS.
	LDB	T4,RBYPNO	;PAGE NO. OF RIB.
	MOVEI	PG,%HMR.P	;WRITE OUT THE RIB OF
	PUSHJ	P,OPAGOT	;HOME.SYS (page 12)
	  JRST	REFFAL
	MOVE	T1,%HMR+RIBALP	;
	MOVEM	T1,HOMALP	;# of pages allocated to HOME.SYS
;ALLOCATE SPACE FOR SPAGES.SYS - SPECIAL/SPARE PAGES CYL 1 & 2

IFN FTSPAG,<
	MOVE	U,FSTUNI	;USE FIRST UNIT FOR RIB
	MOVE	T1,SPGFIL	;NAME OF SPAGES.SYS FILE
	MOVE	T2,SPGEXP	;Extension and protection
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%TMP		;ADDRESS OF RIB IN MEMORY.
	MOVEI	P4,RIPNDL!RIPNFS ;NO DELETE, NO FAILSAFE BITS
	PUSHJ	P,RIBSET	;SET UP RIB IN MEMORY.

	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD
	HRRI	T1,%TMP+RIBPFS-1 ; TO RETREVIAL
	MOVEM	T1,TMPRBP	; AREA FOR PTREXT.

	PUSHJ	P,OGETPG	;Allocate page 13 for RIB to SPAGES.SYS
	  JRST	REFFAL
	MOVEM	T2,%TMP+RIBSLF	;REMEMBER LOG. PAGE # OF RIB
	MOVEM	T2,SPGRBD	; FOR SPAGES.SYS IN HOM PAGE.
	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER
	LSH	T1,1		; 2 cylinders each unit
	HRRZ	P3,UNISTR(U)	; Up pointer to STR
	HRRZ	P3,STRUNM(P3)	; Number of units on structure
	IMUL	T1,P3		;Calculate number of pages
	MOVEM	T1,%TMP+RIBALP	;Set current pages
	AOS	%TMP+RIBALP	; plus 1 for prime rib
	LSH	T1,P2WLSH	;Convert to words
	MOVEM	T1,%TMP+RIBSIZ	;Store

	SETZM	PGSRIB		;CLEAR # OF SPARE RIBS
SPGCRE:	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER	(REMEMBER
	MOVN	P3,T1		; NEGATE AND POSITION		 THESE WERE
	LSH	P3,^D<18+1>	; FOR AOBJN LENGTH (-n*2,,0)	 RESERVED
	HRR	P3,T1		;GET FIRST PAGE AS POINTER	 BY INISAT).

SPGCR1:	HRRZ	T1,P3		;GET THIS PAGE NEXT
	PUSHJ	P,MAKPAG	; CONVERT T1 TO RETRIEVAL POINTER
	PUSHJ	P,PTREXT	;PUT THE PAGE IN THE RIB
	  JRST	REFFAL
	AOBJN	P3,SPGCR1	;LOOP FOR ALL PAGES THIS UNIT
	HLRZ	U,UNISTR(U)	;ANOTHER UNIT?
	JUMPN	U,SPGCRE	;YES, GO TO IT

	MOVE	U,FSTUNI	;RETRIEVE THE UNIT POINTER
	MOVEI	T1,%TMP		;POINT TO RIB PAGE
	PUSHJ	P,RBNFL9	;STORE EOF, ADJUST RIBALP, WRITE RIB
	  JRST	REFFAL
	MOVE	T1,%TMP+RIBALP	;REMEMBER ALLOCATED PAGES
	MOVEM	T1,SPGALP	;FOR LATER
> ; End IFN FTSPAG
;ALLOCATE SPACE FOR FEFILE.SYS ON KS-10s ONLY (for now)

IFCPU(KS),<			;; KS-10 HAS FE-FILE AREA FOR 8080
	MOVE	U,FSTUNI	;USE FIRST UNIT FOR RIB
	MOVE	T1,FEFFIL	;NAME OF FEFILE.SYS FILE
	MOVE	T2,FEFEXP	;Extension and protection
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%TMP		;ADDRESS OF RIB IN MEMORY.
	MOVEI	P4,RIPNDL!RIPNFS ;NO DELETE, NO FAILSAFE BITS
	PUSHJ	P,RIBSET	;SET UP RIB IN MEMORY.

	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD
	HRRI	T1,%TMP+RIBPFS-1 ; TO RETREVIAL
	MOVEM	T1,TMPRBP	; AREA FOR PTREXT.

	PUSHJ	P,OGETPG	;Allocate page 14 for RIB to FEFILE.SYS
	  JRST	REFFAL
	MOVEM	T2,%TMP+RIBSLF	;REMEMBER LOG. PAGE # OF RIB
	MOVEM	T2,FEFRBD	; FOR FEFILE.SYS (IN HOM PAGE?).
	MOVEI	T1,FEFLEN	;# of pages in FEFILE
	MOVEM	T1,%TMP+RIBALP	;Set current pages
	AOS	%TMP+RIBALP	; plus 1 for prime rib
	LSH	T1,P2WLSH	;Convert to words
	MOVEM	T1,%TMP+RIBSIZ	;Store

	SETZM	PGSRIB		;CLEAR # OF SPARE RIBS
FEFCRE:	LDB	P3,UNYPPY	;GET # PAGES PER CYLINDER	(REMEMBER
IFN FTSPAG,<	;IF SPAGES EXISTS START ON CYL 3 ELSE CYL 1	 THESE WERE
	IMULI	P3,3 >		; MAKE FIRST PAGE ON CYLINDER 3	 RESERVED
	HRLI	P3,-FEFLEN	;GET LENGTH OF FE AREA		 BY INISAT).

FEFCR1:	HRRZ	T1,P3		;GET THIS PAGE NEXT
	PUSHJ	P,MAKPAG	; CONVERT T1 TO RETRIEVAL POINTER
	PUSHJ	P,PTREXT	;PUT THE PAGE IN THE RIB
	  JRST	REFFAL
	AOBJN	P3,FEFCR1	;LOOP FOR ALL PAGES UNIT 0 (ONLY)
	MOVEI	T1,%TMP		;POINT TO RIB PAGE
	PUSHJ	P,RBNFL9	;STORE EOF, ADJUST RIBALP, WRITE RIB
	  JRST	REFFAL
	MOVE	T1,%TMP+RIBALP	;REMEMBER ALLOCATED PAGES
	MOVEM	T1,FEFALP	;FOR LATER
> ; End IFCPU(KS)
;ALLOCATE SPACE FOR CRASH.SAV - SPACE TO WRITE OUT A CRASH FILE.

CRSCRE:	MOVE	P2,UNISTR(U)	;SEE IF A
	HRRZ	T4,STRP4C(P2)	;  CRASH FILE
	SKIPN	T4		;  ON THIS STR.
	 JRST	NORCV		;NO
	MOVE	U,FSTUNI	;PUT IT ON FIRST UNIT.
	MOVE	T1,CRSFIL	;File name
	MOVE	T2,CRSEXP	;Extension and protection
	MOVE	T3,SYSPPN	;In (SYS)
	MOVEI	P4,RIPNDL!RIPNFS ;SET UP THE RIB IN %TMP AND
	PUSHJ	P,RBNFIL	;THE FILE.
	  JRST	REFFAL		;
	MOVE	T2,%TMP+RIBALP	;SAVE THE NO. OF PAGES IN THIS
	MOVEM	T2,CRSALP	;FILE + RIB PAGES FOR RIBUSD.
	MOVE	T2,%TMP+RIBSLF	;
	MOVEM	T2,CRSRBD	;

;CREATE PRINT UFD.

NORCV:	MOVE	U,FSTUNI	;
	SETZB	P1,P2		;NO FILES= SUM OF ALPS=0.
	MOVE	T1,SPLPPN	;PPN for print UFD
	MOVEM	T1,SPLUFD	; is filename for MFD
	MOVE	T2,SPLEXP	;'UFD' and protection
	PUSHJ	P,UFDSET	;Build RIB for UFD and write it out
	  JRST	REFFAL		;
	MOVEM	T2,SPLRBD	;SAVE LOGICAL PAGE NUM OF RIB.
	MOVE	T4,%TMP+RIBALP
	MOVEM	T4,SPLALP	;PAGES ALLOCATED TO (SPOOLING).UFD
;CREATE SYS UFD AND ITS RIB.

	MOVE	U,FSTUNI	;FIRST UNIT ON STR
	SETZ	P2,
	MOVSI	T1,-NFILE	;FIND SUM OF
	ADD	P2,R.SIZE(T1)	;ALPS FOR
	AOBJN	T1,.-1		;ITS FILES.
	MOVSI	P1,-NFILE	;
	MOVE	T1,SYSPPN	;PPN for SYS UFD
	MOVEM	T1,SYSUFD	; is filename for MFD
	MOVE	T2,SYSEXP	;'UFD' and protection
	PUSHJ	P,UFDSET	;SET UP & WRITE OUT INFO IN THE RIB FOR SYS.UFD.
	  JRST	REFFAL
	MOVEM	T2,SYSRBD	;Ret Ptr to RIB
	MOVE	T4,%TMP+RIBALP
	MOVEM	T4,SYSALP	;UFD has 7 data pages
	MOVSI	P1,-NFILE	;MAKE ENTRIES IN THE UFD FOR THE FILES
	PUSHJ	P,SETUFD	;SET UP AND WRITE OUT THE UFD ITSELF.
	  JRST	REFFAL


;CREATE (1,1).UFD (MFD) AND ITS RIB.

	SETZ	P2,		;Sum up the ALPs
	MOVE	T1,[-NUFDS,,NFILE]; of all the UFDs
	ADD	P2,R.SIZE(T1)
	AOBJN	T1,.-1
	ADDI	P2,2		;COUNT MFDALP ALSO.
	MOVE	P1,[-NUFDS,,NFILE]
	MOVE	T1,MFDPPN	;PPN for MFD UFD
	MOVEM	T1,MFDUFD	; is filename for MFD
	MOVE	T2,MFDEXP	;'UFD' and protection
	PUSHJ	P,UFDSET	;SET UP AND WRITE OUT INFO IN THE RIB FOR MFD.
	  JRST	REFFAL
	MOVEM	T2,MFDRBD	;Ret Ptr to RIB
	MOVEM	T2,MFDRIB	;Store for FILRIB
	MOVE	T4,%TMP+RIBALP
	MOVEM	T4,MFDALP	;7 data pages in UFD
	MOVE	P1,[-NUFDS,,NFILE]	;MAKE ENTRIES IN THE MFD FOR THE UFDS
	PUSHJ	P,SETUFD	;SET UP AND WRITE OUT THE MFD ITSELF.
	  JRST	REFFAL
	PUSHJ	P,CNDSWT	;IF THERE IS A SAT IN CORE, WRITE IT.
	  JRST	REFFAL

;HERE TO UPDATE THE HOME PAGES ON EACH UNIT OF THE STR.


	MOVE	U,FSTUNI	;START WITH THE FIRST UNIT.
HOMUPD:	PUSHJ	P,GETHOM	;READ HOME PAGES.
	  JRST	REFFAL
	SETZM	%HOM+HOMREF	;CLEAR NEEDS REFRESHING FLAG
IFCPU(KS),<
	LDB	T1,UNYPPY	;GET # PAGES PER CYL
IFN FTSPAG,<	;; Use CYL 1 if no special/spare pages ELSE use CYL 3
	IMULI	T1,3		;STARTS AT CYL 3
> ; End IFN FTSPAG
	HRLI	T1,FEFLEN	;FOR FEFLEN PAGES
	CAME	U,FSTUNI	;But only on unit 0
> ; End IFCPU(KS)
	 MOVEI	T1,0		;Nothing for KI,KL,F3 and other units on KS
	MOVEM	T1,%HOM+HOMFEP	;SET POINTER TO FE FILE
	MOVEI	T1,UFDHSI	;RESET HASH
	HRLZM	T1,%HOM+HOMHSH	;AND
	HRRZ	T1,RANNO
	HRRM	T1,%HOM+HOMRAN	;RANDOM PACK-SET MOUNT COUNT TO SAME
	MOVSI	T1,-NFILE-NUFDS	;*.SYS and *.UFD
HOMUP1:	MOVE	T2,R.RIBS(T1)	;Ret Ptr to RIB of this file or UFD
	LDB	T3,[POINT 9,R.EXPR(T1),35];Get index (zero if none)
	SKIPE	T3		;If it belongs in the HOM page
	 MOVEM	T2,%HOM(T3)	; put it there
	AOBJN	T1,HOMUP1	;Update HOMTAB (HOMSAT thru HOMMFD)
	PUSHJ	P,WTBOTH	;P4 & PG STILL SET UP FROM GETHOM.
	 STOPCD			;WTBOTH HAS TYPED AN ERR MSG.
	HLRZ	U,UNISTR(U)
	JUMPN	U,HOMUPD	;LOOP FOR ALL UNITS IN STR
	PUSHJ	P,CLSAOB	;Clear STTAOB on all SATs

;HERE WHEN ALL DONE

	MOVE	T1,FSFPPN	;FAILSAFE PPN
	MOVEM	T1,REFLAG	;SET REFLAG NON-ZERO
	MOVE	U,FSTUNI	;RESET U TO FIRST UNIT
	HRRZ	P2,UNISTR(U)	;TO RESET P2 WHICH WAS CLOBBERED
	MOVEI	T1,UFDHSI	;  FIXING HOME PAGES.
	HRRM	T1,STRHSH(P2)	;Update STR datablock
	MOVEI	T1,SRPREF##	;Mark the STR
	IORM	T1,STRBTS(P2)	; has having been refreshed
	HRRZS	STRREF(P2)	;CLEAR NEEDS REFRESHING FLAG IN CORE
	JRST	CPOPJ1		;SKIP RETURN


REFFAL:	POPJ	P,		;ERROR EXIT.
SUBTTL	PAKREF - Refresh a single pack which is being added to a STR
;ENTER WITH U/ UNIT DB AND P2/ STR DB.

;The RIB to HOME.SYS needs to be updated to include the additional HOM pages.
;The RIB to SAT.SYS needs to be updated to include the additional SATs.
;The RIB to SPAGES.SYS needs to be updated to include the new cylinders.
;Then the new HOM page is rewritten.

PAKREF::MOVEM	U,REFUNI	;SAVE UNIT BEING REFRESHED.
	SETZM	FSTUNI		;FLAG FOR INISAT.
	HRRM	P2,UNISTR(U)	;PUT STR HERE, SOME LOOK FOR IT.
	HLRZ	U,STRUNI(P2)	;GET THE 1ST UNIT IN THE STR.
	SETZM	SATDSK		;MARK NO SAT IN CORE IN %STA.
	SETZM	R.ZERB		;Zero out R.RIBS and R.SIZE
	MOVE	T1,[XWD R.ZERB,R.ZERB+1]
	BLT	T1,R.ZERE

	PUSHJ	P,GETHOM	;GET HOME PAGES FROM FIRST UNIT.
	  JRST	PAKLEV		;ERROR.
	MOVSI	T1,-NFILE-NUFDS	;Loop thru entire table
PREF1:	LDB	T3,[POINT 9,R.EXPR(T1),35]
	SKIPE	T3		;If it comes from the HOM page
	 MOVE	T3,%HOM(T3)	; get it, else use zero
	MOVEM	T3,R.RIBS(T1)	;Ret Ptr to RIB of this file or ufd
	AOBJN	T1,PREF1	;Read HOMTAB (HOMSAT thru HOMMFD)

  ;Read the current RIBs for HOME,SAT,SPAGES into %HMR,%STR,%TMP
	MOVSI	P4,-NFILE	;P4/ LOOP INDEX.
PREF2:	SKIPE	R.PCBS(P4)	;Only SAT,HOME,SPAGES belong on added packs
	SKIPN	T4,R.RIBS(P4)	;T4/ PAGE NO. OF PRIME RIB FIRST UNIT.
	 JRST	PRFNST		;No big deal if no RIB to SPAGES.SYS (SWAP.SYS)
	TLZ	T4,RBREAL	;Page within unit, unit 0 always

	HRRZ	PG,R.PCBS(P4)	;PG/ %XXX.P = PCB
	HLRZ	P1,R.PCBS(P4)	;P1/ %XXX   = virtual address
	MOVE	U,REFUNI	;Requested unit
	HRRZ	P2,UNISTR(U)	;STR it belongs to
	HLRZ	U,STRUNI(P2)	;First unit of that STR
	PUSHJ	P,OPAGIN	;Read RIB of this file
	  JRST	PAKLEV
	MOVE	P2,RIBSIZ(P1)	;CALC NO. OF THE LAST PAGE IN
	IDIVI	P2,1000		;FILE. (NB NOT TRUE IN GENERAL.)
PREF3:	MOVE	T3,RIBSZS(P1)	;FOUND RIGHT RIB IF
	CAIE	T3,1		;AT LOWEST LEVEL.
	 JRST	PREF4		;
	ADDI	P2,RIBPFS(P1)	;P2/ ADDR OF EOF PNTR.
	SKIPE	RIBRIB(P1)	;
	 ADDI	P2,RIBSFS-RIBPFS;Spare RIBs start at a different location
	JRST	PREF11		;
;GO DOWN A LEVEL INTO A SPARE RIB

PREF4:	IDIV	P2,RIBSZS(P1)	;ELSE P2/ #PRECED SPARE PNTRS, P3/ INDEX
	ADDI	P2,RIBPFS(P1)	;P2/ ADDR OF NEXT PNTR.
	SKIPE	RIBRIB(P1)	;
	 ADDI	P2,RIBSFS-RIBPFS;Third level of RIBs
	MOVE	T2,(P2)		;IS THE PNTR
	TLNN	T2,RBSPAR	;A SPARE RIB PNTR?
	 JRST	PREF5		;NO, WE ARE IN THIS RIB.
	MOVE	P2,P3		;YES, WE MUST READ
	LDB	U,RBYUNI	;IN
	MOVE	U,UNTTBL(U)	;THE
	LDB	T4,RBYPNO	;LOWER
	PUSHJ	P,OPAGIN	;RIB.
	  JRST	PAKLEV		;
	JRST	PREF3		;P2 has index into the current RIB

PREF5:	ADDI	P2,(P3)		;Index to a real pointer following a spare

    ;HERE WITH ADDR OF EOF PNTR IN P2.

PREF11:	MOVE	T1,P2		;BUILD
	SUB	P2,P1		; AN
	SUBI	P2,RIBLST+2	; AOBJN
	HRLM	P2,T1		; POINTER
	HRRI	T1,-1(T1)	; IN T1.
	MOVEM	T1,R.RBPS(P4)	;Store for adding more RIB pointers
PRFNST:	AOBJN	P4,PREF2	;Locate all 3 files

    ;READ THE BAT PAGE INTO %BAT.
	MOVE	U,REFUNI	;READ THE
	PUSHJ	P,GETBAT	;BAT PAGE.
	  JRST	PAKLEV		;
;HERE FOR THE SATS FOR THIS UNIT.

	PUSHJ	P,SATCLC	;CALC BEGSAT, SVSBTL, LPGSAT, AND SATIND.

    ;THIS IS THE LOOP FOR EACH SAT.

RFNXST:	PUSHJ	P,INISAT	;SET UP A SAT AND PART OF HOME.SYS.
	 STOPCD

	PUSHJ	P,NXCLC		;CALC INFO FOR NEXT SAT.
	  JRST	RFNXST		;Loop for all SATs on new unit


    ;SET NEW RIBSIZ'S IN THE RIBS FOR HOME.SYS AND SAT.SYS

	MOVEI	T1,%HMR		;		HOME
	PUSHJ	P,CNVSZM	;
	SETZ	T2,		;STORE THE
	PUSHJ	P,HOMRBS	;EOF POINTER.

	MOVEI	T1,%STR		;		SAT
	PUSHJ	P,CNVSZM	;
	SETZ	T2,		;
	PUSHJ	P,SATRBS	;STORE EOF POINTER

IFN FTSPAG,<    ;If TMPRBP is nonzero, then SPAGES.SYS exists and the RIB
		;in %TMP has the EOF pointer.  This may be the spare RIB,
		;depending on how many pages are in SPAGES already.
	SKIPN	TMPRBP		;Is there a file to be added to?
	 JRST	PAKSP0		;No
;INISAT has reserved cylinders 1 and 2 for SPAGES.SYS
	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER
	MOVN	P3,T1		; NEGATE AND POSITION
	LSH	P3,^D<18+1>	; FOR AOBJN LENGTH (-N*2,,0)
	HRR	P3,T1		;First page is start of cyl 1

PAKSPG:	HRRZ	T1,P3		;GET THIS PAGE NEXT
	PUSHJ	P,MAKPAG	; CONVERT T1 TO RETRIEVAL POINTER
	PUSHJ	P,PTREXT	;PUT THE PAGE IN THE RIB
	  JRST	PAKLEV
	AOBJN	P3,PAKSPG	;LOOP FOR ALL PAGES THIS UNIT

	SETZ	T2,		;STORE THE
	PUSHJ	P,PTREXT	;NEW EOF POINTER
;P035/D10 28-Nov-88 Don't put updated size in a spare RIB.
	PUSHJ	P,GETPRM	;Get the prime RIB into %TMP
	  JRST	PAKSP0		;Can't fail (DSKCLN will check)
	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER
	LSH	T1,1		; 2 cylinders
	ADDM	T1,%TMP+RIBALP	;Add to allocated pages
	LSH	T1,P2WLSH	; # of words
	ADDM	T1,%TMP+RIBSIZ	;Add to written words
PAKSP0:
>  ;end IFN FTSPAG
;NOW FIX UP THE HOME PAGES ON THIS UNIT.

FIXHOM:	MOVE	U,R	;Read HOM page on unit in question
	PUSHJ	P,GETHOM
	 STOPCD
	SETZM	%HOM+HOMREF	;Clear "needs refreshing" flag
	SETZM	%HOM+HOMFEP	;Front-end file system on DSKB0 only
	HRRZ	T1,STRDDB+STRHSH
	HRLZM	T1,%HOM+HOMHSH	;
	HRRZ	T1,RANNO	;
	HRRM	T1,%HOM+HOMRAN	;
	MOVSI	T1,-NFILE-NUFDS
FIXHM1:	MOVE	T2,R.RIBS(T1)	;Ret Ptr to RIB of this file or ufd
	LDB	T3,[POINT 9,R.EXPR(T1),35]
	SKIPE	T3		;If it belongs in the HOM page
	 MOVEM	T2,%HOM(T3)	; put it there
	AOBJN	T1,FIXHM1	;Update HOMTAB (HOMSAT thru HOMMFD)
	PUSHJ	P,WTBOTH	;NOW WRITE THEM OUT.
	 STOPCD
	HRRZ	P2,UNISTR(U)	;
	MOVEI	T1,UFDHSI	;
	HRRM	T1,STRHSH(P2)	;

    ;NOW WRITE OUT THE RIBS FOR HOME AND SAT and maybe SPAGES.

	MOVSI	P4,-NFILE	;
PAKRB1:	SKIPE	R.PCBS(P4)	;Do only the 3 special files
	SKIPN	R.RIBS(P4)	;Was this RIB read in?
	 JRST	PKRB1A		;No, OK for RIB to SPAGES.SYS to be missing
	HLRZ	T3,R.PCBS(P4)	;Virtual address
	MOVE	T2,RIBSLF(T3)	;Self pointer says where to write the data
	LDB	T4,RBYPNO	;Page within unit
	LDB	U,RBYUNI	;Unit number
	MOVE	U,UNTTBL(U)	;Unit data block
	HRRZ	PG,R.PCBS(P4)	;Physical address
	PUSHJ	P,OPAGOT	;Write it out
	 STOPCD
PKRB1A:	AOBJN	P4,PAKRB1	;Do all 3 files
	PUSHJ	P,CNDSWT	;Write out SAT if any
	 STOPCD
	PUSHJ	P,CLUAOB	;Clear SATAOB
	AOS	(P)		;SUCCESS RETURN

PAKLEV:	MOVE	U,REFUNI	;Restore U and P2
	HRRZ	P2,UNISTR(U)	;
	POPJ	P,		;End of PAKREF
SUBTTL	SCNBAT - Scan BAT pages

COMMENT #
@@SUBROUTINE SCNBAT
@@PURPOSE
SUBR TO SCAN BAT AREA AND EXECUTE AN INSTRUCTION FOR EACH BAD PAGE.
@@ENTRY
EXPECTS T2/ INSTRUCTION TO EXECUTE (AND IF CALLING SETBTS,
T3/ ADDR OF STT ENTRY.).
@@ACCUM
DESTROYS T1, T2, AND T4.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

;Called from INISAT to mark bad pages as unuseable.
;The old version of PAKCOP interpreted the numbers in the BAT pages as being
;block numbers, it has been corrected to use page numbers.
;See also UPERBT (update error BAT) routine in CORE1.

SCNBAT::JSP	T4,SAVE4	;SAVE P1-P4
	MOVE	P2,T2		;P2=INSTRUCTION TO EXECUTE.
	MOVEI	P4,%BAT		;P4/ -NO. OF WORDS IN AREA,,
	ADD	P4,%BAT+BATFIR	;ADDR OF 1ST ENTRY.

    ;HERE FOR EACH ENTRY.
SCNBT2:	SKIPN	BATNBB(P4)	;AT END?
	 JRST	CPOPJ1		;YES.
	HRRZ	T2,P4		;Put addr in T2 for BAYNBB
	LDB	P3,BAYNBB	;NUMBER BAD PAGES-1.
	SKIPA	P1,BATELB(P4)	;P1=1ST BAD PAGE.
    ;HERE FOR EACH BAD PAGE.
SCNBT3:	 ADDI	P1,1		;P1=NEXT BAD PAGE.
	MOVE	T1,P1		;ARG FOR INSTRUCTION.
	XCT	P2		;MARK THIS PAGE IN SAT.
	SOJGE	P3,SCNBT3	;LOOP FOR ALL BAD PAGES THIS REGION.
	AOBJP	P4,.+2		;COMPENSATE FOR 2 WORD ENTRIES.
	AOBJN	P4,SCNBT2	;LOOP FOR ALL ENTRIES
	 MSGLIV	BATBAD		;Output message if BAT is completely full
COMMENT #
@@SUBROUTINE SETBTS
@@PURPOSE
SUBR TO CLEAR AN F BIT IN %STA AND DECREMENT STTFPC.
This marks the page as being "in use".
@@ENTRY
EXPECTS T1/ PAGE NO. OF BIT AND T3/ ADDR OF STT ENTRY.
@@ACCUM
DESTROYS T1, T2, AND T4.
@@ #

SETBTS:	CAML	T1,BEGSAT	;SKIP IF BEFORE BEGINNING OF CURRENT SAT.
	CAMLE	T1,LPGSAT	;SKIP IF WITHIN CURRENT SAT (NOT PAST END)
	 POPJ	P,		;PAGE NOT IN CURRENT SAT.
	SUB	T1,BEGSAT	;
	IDIVI	T1,^D36		;T1=INDEX IN PAGE OF BIT.
	MOVNS	T2		;T2=BITS TO SHIFT RIGHT
	MOVSI	T4,400000	;SET LEFTMOST BIT
	LSH	T4,(T2)		;POSITION BIT
	TDNN	T4,%STA(T1)	;SKIP IF BIT SET.
	 POPJ	P,		;ALREADY CLEAR, JUST RETURN.
	ANDCAM	T4,%STA(T1)	;SO CLEAR IT.
	SOS	STTFPC(T3)	;NOTE ONE LESS FREE PAGE.
	POPJ	P,


SUBTTL VARIOUS SUBROUTINES.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	INISAT	Set all the bits in %STA to represent available pages,	;;
;;		except for BAD pages, the HOME, BAT and BOOT pages, on	;;
;;		KS-10 the FEFILE pages, the special spare pages on all	;;
;;		disk units, non-existent pages and page 0.		;;
;;		Also, make the STT entry and write out the SAT.		;;
;;									;;
;;		Destroys T1 thru T4, P1 thru P4 and PG.			;;
;;		calls: CORONZ, SCNBAT, SETBTS, GETHMP, SATSRH, SATRBS,	;;
;;		       OPAGOT, TAKPAG and CPOPJ1.			;;
;;									;;
;;	expects	BEGSAT, SVSBTL, LPGSAT and SATIND setup.		;;
;;		U/ UNIT DB						;;
;;		F/ DDB							;;
;;									;;
;;	returns	SKIP if no errors.					;;
;;		NON-SKIP if anything goes wrong.			;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;HERE TO MAKE THE STT ENTRY.
INISAT:	PUSHJ	P,CNDSWT	;WRITE OUT ANY SAT IN CORE BEFORE
	  POPJ	P,		; WE WIPE IT OUT.
	AOS	T1,SATIND	;GET INTO T1 THE
	IMULI	T1,STTLEN	;ADDR OF THE
	HRRZ	T2,UNISTT(U)	;STT
	ADDI	T1,(T2)		;ENTRY.
	SETZM	STTAOB(T1)	;CLEAR AOBJN POINTER.
	MOVE	T2,SVSBTL	;SET THE COUNT OF
	MOVEM	T2,STTFPC(T1)	;FREE PAGES.
	SETZM	STTSTS(T1)	;CLEAR THE STATUS.
	PUSH	P,T1		;SAVE ENTRY ADDR FOR BELOW.

    ;HERE TO SET ALL SAT BITS AND THEN CLEAR BITS OF NON-EXISTENT PAGES.
	HRRZI	T1,%STA		;SET THE ENTIRE
	SETOM	%STA		;AREA REPRESENTED IN THIS
	PUSHJ	P,CORONZ	;SAT TO AVAILABLE.
	MOVE	T2,SVSBTL	;ANY NON-EXISTENT PAGES
	CAIL	T2,400*^D36	;AT THE END OF THE SAT?
	 JRST	INISA3		;NO.
	SETZ	T1,		;YES, DOES A PARTIAL
	IDIVI	T2,^D36		;WORD IN THE SAT HAVE
	JUMPE	T3,INISA2	;TO BE SET?
	MOVSI	T1,400000	;YES.  SET
	MOVNI	T3,-1(T3)	;THE PARTIAL
	ASH	T1,(T3)		;WORD.
INISA2:	MOVEM	T1,%STA(T2)	;SET PARTIAL WORD OR NEXT WORD.
	CAIL	T2,377		;ANY MORE WORDS TO SET?
	 JRST	INISA3		;NO.
page
	SETZM	%STA+1(T2)	;YES, PREPARE TO BLT.
	CAIL	T2,376		;BUT NOT IF ONLY ONE
	 JRST	INISA3		;WORD TO DO.
	HRRZI	T2,%STA+2(T2)	;SET THE REST OF
	HRLI	T2,-1(T2)	;THE SAT TO
	BLT	T2,%STA+377	;UNAVAILABLE.

    ;HERE TO SCAN BAT AREA AND MARK BAD PAGES IN SAT.

INISA3:	POP	P,T3		;RESTORE STT ENTRY ADDRESS.
	MOVE T2,[PUSHJ P,SETBTS];INSTRUCTION TO EXECUTE
	PUSHJ	P,SCNBAT	;FOR EACH BAD PAGE.
	  POPJ	P,

INISA5:	SKIPE	BEGSAT		;SKIP IF THIS IS 1ST SAT ON THIS UNIT
	 JRST	INISA6

    ;HERE TO ALLOCATE PAGES (HOME, BAT, AND BOOTS) IN HOME.SYS FILE
    ;AND PAGE FOR SAT.SYS RIB.
    ;(DONE ONLY IF THIS IS THE FIRST SAT ON THIS UNIT.).
	MOVSI	P3,-LBNLEN
INISAA:	MOVE	T1,LBNLST(P3)
	PUSHJ	P,GETHMP	;GET NEXT PAGE IN THE GROUP.
	  POPJ	P,		;CAN'T GET IT.
	AOBJN	P3,INISAA	;LOOP FOR ALL OF THE GROUP
	MOVE	P3,[XWD -NBOOTP,FBOOTB]	;P3=-# PAGES FOR BOOTS, 1ST PAGE.
INISAB:	HRRZ	T1,P3		;NEXT PAGE TO ALLOCATE.
	PUSHJ	P,GETHMP	;ALLOCATE THE PAGE, STORE IN %HMR
	  POPJ	P,
	AOBJN	P3,INISAB	;LOOP FOR ALL PAGES TO ALLOCATE FOR BOOTS.
IFN FTSPAG,<	;;Allocate 2 cylinders in SAT even if no RIB for SPAGES.SYS
	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER
	MOVN	P3,T1		; NEGATE AND POSITION
	LSH	P3,^D<18+1>	; FOR AOBJN LENGTH (-N*2,,0)
	HRR	P3,T1		;GET FIRST PAGE AS POINTER
INISAC:	HRRZ	T1,P3		; NEED TO GET THIS PAGE #
	PUSHJ	P,TAKPAG	;RESERVE THE PAGE SO NOBODY ELSE GETS IT.
	  POPJ	P,
	AOBJN	P3,INISAC	;LOOP FOR ALL PAGES ON CYL 1 AND 2
> ; End IFN FTSPAG

	CAME	U,FSTUNI	;If not first unit,
	 JRST	INISA6		; skip the rest
IFCPU(KS),<			;KS-10 HAS FE-FILE AREA FOR 8080
	LDB	P3,UNYPPY	;GET # PAGES PER CYLINDER
IFN FTSPAG,<IMULI P3,3>		;Skip over cylinders 0,1,2,3 if SPAGES
	HRLI	P3,-FEFLEN	;GET LENGTH OF FE AREA
INISAD:	HRRZ	T1,P3		; NEED TO GET THIS PAGE #
	PUSHJ	P,TAKPAG	;RESERVE THE PAGE SO NOBODY ELSE GETS IT.
	  POPJ	P,
	AOBJN	P3,INISAD	;LOOP FOR ALL PAGES TO ALLOCATE FE AREA
> ; End IFCPU(KS)
page
	MOVEI	T1,LPNSAT	;ALLOCATE PAGE 10 FOR THE RIB TO
	PUSHJ	P,TAKPAG	; SAT.SYS SO NOBODY ELSE GETS IT.
	  POPJ	P,		;End of first-unit-only stuff
    ;HERE TO WRITE THIS SAT PAGE OUT TO THE DISK.

INISA6:	MOVE	P1,T3		;P1 HAS INDEX FOR SATSRH AND SAFETY.
	SKIPLE	STTFPC(P1)	;ROOM IN THIS SAT FOR ITSELF?
	 JRST	INISA8		;YES. (always is)
	HRRZ	T1,UNISTT(U)	;NO.  TRY TO
	CAIN	P1,(T1)		;FIND ROOM
	 MSGLIV	OGTPG		;IN AN EARLIER SAT, IF THERE IS ONE.
	MOVE	T1,[XWD %STA,%T2P] ;MEANWHILE, SAVE US
	BLT	T1,%T2P+777	;IN %T2P.
	SETZM	STTPTR(P1)	;DON'T LET OGETPG GET PAST US.
	PUSHJ	P,OGETPG	;TRY TO GET A PAGE IN AN EARLIER SAT.
	  POPJ	P,		;
	MOVEI	PG,%T2P.P	;REMEMBER WE WANT TO WRITE OUT %T2P.
	JRST	INISA9		;
INISA8:	MOVEI	P2,1		;HERE TO GET A PAGE
	PUSHJ	P,SATSRH	;IN OURSELVES.
	  POPJ	P,
	MOVEI	PG,%STA.P	;REMEMBER WE WANT TO WRITE OUT %STA.
INISA9:	MOVEM	T2,STTPTR(P1)	;STORE THE DISK PNTR TO THE SAT.
	PUSHJ	P,SATRBS	; " IN SAT.SYS RIB.
	LDB	T4,RBYPNO	;WRITE OUT THE
	PJRST	OPAGOT		;SAT PAGE, SKIP RETURN

LBNLST:	0		;Page 0 is reserved (TOPS-10 HOM block on KS)
	LPNHOM		;Primary HOM
	LP2HOM		;Secondary HOM
	LPNBAT		;Primary BAT
	LP2BAT		;Secondary BAT
LBNLEN==.-LBNLST
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	NXCLC	See if this unit needs more SATs than we have already	;;
;;		created.  Destroys T2.					;;
;;									;;
;;	expects	U/ UNIT DB						;;
;;		BEGSAT and SVSBTL setup.				;;
;;									;;
;;	returns	SKIP if no more SATs for this unit.			;;
;;		NON-SKIP with BEGSAT, LPGSAT and SVSBTL set up.		;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NXCLC:	MOVE	T2,SVSBTL	;PAGES IN THIS SAT.
	ADD	T2,BEGSAT	;LAST PAGE IN THIS SAT+1. NEXT
	CAML	T2,UNIPPU(U)	;SAT WOULD BE PAST E O UNIT?
	 JRST	CPOPJ1		;YES, NO MORE SATS THIS UNIT.
	MOVEM	T2,BEGSAT	;NO, ANOTHER SAT FOR THIS UNIT.
	ADD	T2,SVSBTL	;COMPUTE END OF NEXT
	SUBI	T2,1		;SAT.
	MOVEM	T2,LPGSAT	;REMEMBER LAST PAGE NEW SAT.
	ADDI	T2,1		;SKIP IF NEW SAT WOULD GO
	CAMG	T2,UNIPPU(U)	;PAST END OF UNIT.
	 POPJ	P,		;NO, KEEP GOING.
	SUB	T2,UNIPPU(U)	;YES. FIND OUT HOW
	MOVNS	T2		;MUCH OVER.
	ADDM	T2,SVSBTL	;CORRECT SIZE OF SAT
	ADDM	T2,LPGSAT	;AND LAST PAGE.
	POPJ	P,		;MORE SATS THIS UNIT.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	SATCLC	Set BEGSTA, SVSBTL, LPGSAT and SATIND for the first	;;
;;		SAT on a unit.  Destroys T1.				;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SATCLC:	SETZM	BEGSAT		;BEGSAT/ 1ST SAT ON A UNIT.
	MOVEI	T1,400*^D36	;SVSBTL/ NO. OF REAL
	MOVEM	T1,SVSBTL	;ENTRIES IN THIS SAT.
	SUBI	T1,1		;LPGSAT/ LAST PAGE IN
	MOVEM	T1,LPGSAT	;THE FIRST SAT.
	SETOM	SATIND		;SAT INDEX,
	POPJ	P,		;SET TO -1 (BECAUSE WE AOS.).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	GETHMP	Allocate 1 page in current SAT for HOME.SYS while	;;
;;		creating SATs.  (Only works for first SAT on a unit).	;;
;;		Destroys T1 and T2.					;;
;;		calls: TAKPAG and HOMRBS.				;;
;;									;;
;;	expects	T1/ LOGICAL PAGE NO. TO ALLOCATE			;;
;;		T3/ STT ENTRY ADDRESS					;;
;;		U/  UNIT DB						;;
;;									;;
;;	returns	NON-SKIP IF CAN'T HAVE PAGE.				;;
;;		SKIP IF GET PAGE, RETRIEVAL POINTER STORED IN RIB	;;
;;		OF HOME.SYS IN MEMORY.					;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GETHMP:	PUSHJ	P,TAKPAG	;
	  POPJ	P,		;NOT AVAILABLE.
	PUSHJ	P,HOMRBS	;
	JRST	CPOPJ1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	TAKPAG	Marks a page taken and adjust SSTFPC.			;;
;;		Destroys T1 and T2.					;;
;;									;;
;;	expects	T1/ LOGICAL PAGE NO. TO ALLOCATE			;;
;;		T3/ STT ENTRY ADDRESS					;;
;;		U/  UNIT DB						;;
;;									;;
;;	returns	NON-SKIP RETURN IF CAN'T HAVE PAGE.			;;
;;		SKIP RETURN IF GET PAGE, WITH THE RETRIEVAL POINTER	;;
;;		TO THE PAGE IN T2.					;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TAKPAG:	JSP	T4,SAVE1	;SAVE P1
	PUSH	P,T1		;SAVE PAGE NEEDED (FOR PNTR.).
	CAML	T1,BEGSAT	;Make sure it is in the SAT that
	CAMLE	T1,LPGSAT	; T3 points to
	 MSGLIV	NOTAVL		;The caller goofed
	SUB	T1,BEGSAT	;Page with the SAT
	IDIVI	T1,^D36
	ADDI	T1,%STA		;
	MOVNS	T2		;
	MOVSI	P1,400000
	LSH	P1,(T2)		;SHIFT BIT INTO POSITION
	POP	P,T2		;
	TDNN	P1,(T1)		;SKIP IF AVAILABLE.
	 MSGLIV	NOTAVL		;NOT AVAILABLE.
	XORM	P1,(T1)		;MARK THE PAGE UNAVAILABLE.
	TLO	T2,RBREAL	;MAKE T2
	LDB	T1,UNYLUN	;A
	DPB	T1,RBYUNI	;RETRIEVAL POINTER.
	SOS	STTFPC(T3)	;
	JRST	CPOPJ1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	MAKPAG	Makes a retrieval pointer out of the page number in	;;
;;		T1 and returns it in T2.				;;
;;									;;
;;	expects	T1/ logical page number on unit				;;
;;		U/  unit data block					;;
;;									;;
;;	returns	T2/ retrieval pointer					;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MAKPAG:	PUSH	P,T1		; Save page.
	MOVE	T2,T1		; Copy for pointer.
	TLO	T2,RBREAL	; Make T2
	LDB	T1,UNYLUN	; a
	DPB	T1,RBYUNI	; Retrieval pointer.
	POP	P,T1		; Restore page
	POPJ	P,		;  and return
COMMENT #
@@SUBROUTINE UFDSET
@@PURPOSE
SUBR TO SET UP INFORMATION IN A UFD RIB IN %TMP AND THEN WRITE IT OUT.
@@ENTRY
EXPECTS T1/ FILENAME OF UFD, T2/EXT+PROT     U/ UNIT DB, P1/ AOBJN PNTR TO
FILENAMES, AND P2/ ARG. FOR RIBUSD.
@@CALLS
HASH, RIBSET, OGETPG, AND TMPOUT.
@@EXIT
NON-SKIP RETURNS IF ERROR, ELSE SKIP RETURNS WITH
T2/ DISK PNTR TO RIB ITSELF.
@@ #

UFDSET:	PUSH	P,P2		;RIBUSD
	MOVE	T3,MFDPPN	;T1&T2 HAVE NAME & EXT & PROT
	MOVEI	T4,%TMP		;
	MOVEI	P4,RIPDIR	;SET DIRECTORY BIT IN STATUS
	PUSHJ	P,RIBSET	;SET UP INFO IN RIB IN CORE.
	POP	P,T2		;STORE NO. OF PAGES IN ALL THE
	MOVEM	T2,%TMP+RIBUSD	;FILES THIS UFD POINTS TO.
	MOVEM	T2,%TMP+RIBMXA	;
    ;SET UP UFDHSI NON-EXISTENT PNTRS.
	MOVEI	T1,UFDHSI	;SET UP UFDHSI
	MOVEI	T2,(SIXBIT/CAT/) ;NON-EXISTENT PNTRS
	MOVEM	T2,%TMP+RIBPFS-1(T1) ;IN THE PRIME
	SOJG	T1,.-1		;RIB.
    ;SET UP THE REAL PNTRS.
	MOVEI	P3,1		;COUNT FOR RIBALP.
	JUMPE	P1,UFDST3	;All done if UFD has no files
REPEAT 0,<;Removed 15-May-87, changed to allocate 7 data pages)
PRINTF (<[Should allocate all 14. data pages in UFDSET for UFD project]>)
UFDST1:	MOVE	T1,R.FILE(P1)	;GET T1/ FIRST FILENME.
	PUSHJ	P,HASH		;HASH IT TO T1.
	MOVE	T2,%TMP+RIBPFS-1(T1) ;PNTR FOR THIS FILE'S PAGE.
	TLNE	T2,RBREAL	;HAS IT ALREADY BEEN MADE REAL?
	  JRST	UFDST2		;YES.
	MOVE	P2,T1		;SAVE PLACE.
	PUSHJ	P,OGETPG	;NO, GET A PAGE FOR IT.
	  POPJ	P,		;LOST.
	ADDI	P3,1		;COUNT FOR RIBALP.
	MOVEM	T2,%TMP+RIBPFS-1(P2) ;STORE THE REAL PNTR.
UFDST2:	AOBJN	P1,UFDST1	;CONTINUE FOR ALL FILES.
>  ;End of REPEAT 0
page
;If the UFD has any files in it at all, allocate UFDHSI data pages.
;P3 starts at 1, gets set to total pages (including RIB page).

	MOVEI	P2,UFDHSI	;Number of hash buckets
UFDST1:	PUSHJ	P,OGETPG	;Get a UFD data pages
	  POPJ	P,		;Error
	MOVEM	T2,%TMP+RIBPFS-1(P3)
	ADDI	P3,1		;Count for RIBALP
	SOJG	P2,UFDST1	;Do all 7
;End of new code added 15-May-87

UFDST3:	MOVEM	P3,%TMP+RIBALP	;STORE RIBALP.
	MOVEI	P3,UFDHSI*1000	;CALC AND
	MOVEM	P3,%TMP+RIBSIZ	;STORE RIBSIZ.
	PUSHJ	P,OGETPG	;GET A PAGE FOR THE
	  POPJ	P,
	MOVEM	T2,%TMP+RIBSLF	;RIB.
	PUSHJ	P,TMPOUT	;WRITE OUT THE RIB.
	  POPJ	P,
	MOVE	T2,%TMP+RIBSLF	;
	JRST	CPOPJ1
COMMENT #
@@SUBROUTINE SETUFD
@@PURPOSE
SUBR TO SET UP INFO IN THE PAGES OF A UFD AND THEN WRITE THEM OUT.
@@ENTRY
EXPECTS P1/ -LOOP COUNTER,,INDEX TO FIRST FILENAME.
EXPECTS PRIME RIB TO BE SET UP IN %TMP.
@@ACCUM
DESTROYS contents of page %T2P
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

SETUFD:	PUSH	P,P2		;SAVE P2.
	MOVEI	P2,1		;P2/ CURRENT HASH NUMBER.

SETUF1:	MOVE	T2,%TMP+RIBPFS-1(P2) ;T2/ ASSOCIATED RIB PNTR.
	TLNE	T2,RBREAL	;ANY FILE WITH THIS HASH?
	 JRST	SETUF2		;YES, GO MAKE ENTRIES.

    ;HERE TO TRY NEXT HASH NUMBER, OR TO FINISH UP.
SETUFN:	CAIGE	P2,UFDHSI	;ALL DONE?
	 AOJA	P2,SETUF1	;NO, CONTINUE.
	POP	P,P2		;YES, RESTORE P2.
	JRST	CPOPJ1		;End of SETUFD

    ;HERE TO MAKE ENTRIES IN ONE PAGE OF THE UFD.
SETUF2:	MOVEI	T1,%T2P		;CLEAR AN AREA FOR
	PUSHJ	P,CORZER	;THE UFD IN CORE, IN %T2P.
	MOVE	T1,[XWD -776,%T2P] ;776 DIVIDES EVENLY BY 5.
	MOVEM	T1,UFDSTP	;SET UP AOBJN PNTR FOR ENTUFD.
	PUSH	P,P1		;P1.
SETUF4:	MOVE	T1,R.FILE(P1)	;Get filename or PPN
	PUSHJ	P,HASH		;GET HASH TO T1.
	CAIN	T1,(P2)		;MATCH FOR THIS BLOCK?
	 PUSHJ	P,ENTUFD	;YES, MAKE THE UFD
	AOBJN	P1,SETUF4	;
SETUF5:	POP	P,P1		;RESTORE P1
	MOVEI	PG,%T2P.P	;WRITE
	MOVE	T2,%TMP+RIBPFS-1(P2)	;OUT
	LDB	T4,RBYPNO	;THE
	LDB	U,RBYUNI	;PAGE
	MOVE	U,UNTTBL(U)	;OF THE
	PUSHJ	P,OPAGOT	;UFD.
	  POPJ	P,
	JRST	SETUFN		;Next hash bucket
;LITTLE SUBR TO HASH A FILENAME FOR A UFD.
;EXPECTS FILENAME IN T1, RETURNS HASH IN T2, DESTROYS T1.

HASH:	TLZ	T1,(1B0)	;Clear sign bit (so remainder is positive)
	IDIVI	T1,UFDHSI
	MOVEI	T1,1(T2)	;By convention, the first bucket is 1 not 0
	POPJ	P,



COMMENT #
@@SUBROUTINE ENTUFD
@@PURPOSE
SUBR TO MAKE AN ENTRY IN A UFD.
@@ENTRY
EXPECTS P1/ TABLE INDEX OF FILE TO ENTER
AND UFDSTP/ AOBJN POINTER TO UFD IN CORE.
@@ACCUM
DESTROYS T1 THRU T4 AND U.
@@ #

XP UFDNAM,0	;File name
XP UFDEXT,1	;Extension, file flags, protection
XP UFDCDT,2	;Creation date and time
XP UFDLIC,3	;File size and license
XP UFDRIB,4	;Retrieval pointer to the RIB
XP UFDSIZ,5	;Number of words in a UFD entry

ENTUFD:	SKIPN	T1,R.RIBS(P1)	;Do we have a RIB for this file?
	 POPJ	P,
	SKIPL	T4,UFDSTP	;SKIP IF STILL ROOM IN THIS PAGE.
	 MSGSFE	UFDERR
	MOVEM	T1,UFDRIB(T4)	;STORE RETRIEVAL POINTER
	MOVE	T1,R.FILE(P1)	;FILE NAME
	HLLZ	T2,R.EXPR(P1)	;EXTENSION
	MOVEM	T1,UFDNAM(T4)	;STORE FILE NAME
	HLLM	T2,UFDEXT(T4)	;AND EXTENSION.
	LDB	T2,[POINT 9,R.EXPR(P1),^D26]
	HRRM	T2,UFDEXT(T4)	;NO FLAG BITS, PROTECTION IN BITS 27-35
	HRRZ	T2,THSDAT##	;Today's date
	LDB	T3,[POINT 2,T2,23]
	DPB	T3,[POINT 2,T2,6];High two bits
	MOVEM	T2,UFDCDT(T4)	;Creation date
	MOVE	T2,TIME##	;Ticks since midnight
	IDIV	T2,JFYSEC##	;Convert to seconds
	DPB	T2,[POINT 17,UFDCDT(T4),23]
	MOVE	T2,R.SIZE(P1)
	HRLZM	T2,UFDLIC(T4)	;ALLOCATED SIZE, NO LICENSE
	ADD	T4,[XWD UFDSIZ,UFDSIZ]	;BUMP POINTER
	MOVEM	T4,UFDSTP	;RESTORE POINTER
	POPJ	P,
COMMENT #
@@SUBROUTINE RBNFIL
@@PURPOSE
SUBR TO SET UP A RIB IN CORE IN %TMP.P, GET A SPECIFIED
NO. OF PAGES ON A UNIT, STORE THEIR RETRIEVAL PNTRS
IN THE RIB(S), AND WRITE OUT THE RIB(S).
@@ENTRY
EXPECTS:
	T1/ FILE NAME
	T2/ EXT,,PROT
	T3/ PPN
	T4/ NUMBER OF PAGES TO ALLOCATE (NOT INCLUDING RIBS).
	P4/ BITS TO SET IN STATUS WORD
	U/ UNIT DB
@@ACCUM
DESTROYS
@@CALLS
RIBSET, OGETPG, OPAGOT, SATSRH, GETSAT, GETPRM, AND PTREXT.
@@EXIT
IF ERROR, NON-SKIP RETURNS, ELSE SKIP
RETURNS WITH PRIME RIB IN %TMP (ALREADY WRITTEN OUT)
AND PGSRIB INCREMENTED FOR EACH RIB (OTHER THAN THE PRIME RIB)
GENERATED.
@@ #

    ;SET UP THE PRIME RIB IN CORE.
RBNFIL:	MOVEM	T4,PAGNED	;SAVE NO. OF PAGES REQUESTED.
	SETZM	PGSRIB		;PGSRIB HOLDS NO. OF SPARE RIBS GENERATED.
	MOVEI	T4,%TMP		;SET UP THE
	PUSHJ	P,RIBSET	;RIB AREA.
	MOVEI	T4,1		;SET NO. OF PAGES
	ADD	T4,PAGNED	;PLUS ONE
	MOVEM	T4,%TMP+RIBALP	;RIB.
	PUSHJ	P,OGETPG	;GET A DISK PAGE FOR THE RIB.
	  POPJ	P,
	MOVEM	T2,%TMP+RIBSLF	;STORE SELF RIB PNTR.
	HRLI	T1,-RBLVPR-1	;SET UP
	HRRI	T1,%TMP+RIBPFS-1
	MOVEM	T1,TMPRBP	;PNTR TO RIB AREA.

    ;LOOK FOR DISK SPACE. SEARCH FOR THE SAT ON THIS UNIT WITH THE MOST SPACE.

RBNFL1:	SETZB	P1,P2		;CLR MAX FOUND AND INDEX.
	HRRZ	T1,UNISTT(U)	;T1/ INDEX INTO STT.
RBNFL2:	SKIPN	T2,STTPTR(T1)	;AT E O TABLE?
	 JRST	RBNFL4		;YES.
	SKIPN	T3,STTFPC(T1)	;NO. ANY FREE PAGES IN THIS SAT?
	 JRST	RBNFL3		;NO.
	CAML	T3,PAGNED	;YES. ENOUGH TO SATISFY REQUEST?
	 JRST	RBNFL6		;YES.
	CAMG	T3,P2		;NO. FOUND MORE THAN MAX SEEN ALREADY?
	 JRST	RBNFL3		;NO.
	MOVE	P2,T3		;YES, SAVE IT AS
	MOVE	P1,T1		;MAX.
RBNFL3:	ADDI	T1,STTLEN	;NO.  LOOK AT NEXT
	JRST	RBNFL2		;SAT ENTRY IN STT.

      ;HERE AT END OF TABLE.
RBNFL4:	JUMPN	P2,.+2		;BETTER HAVE FOUND SOMETHING.
	 MSGLIV	OGTPG
	PUSH	P,P1		;SAVE SAT'S INDEX IN STT.
	SKIPA	T2,STTPTR(P1)	;T2/ SAT'S DISK POINTER.

    ;HERE TO READ IN THE SAT.
RBNFL6:	PUSH	P,T1		;SAVE SAT'S INDEX IN STT.
	PUSHJ	P,GETSAT	;
	  JRST	[POP  P,T1
		 POPJ P,]
	MOVE	P2,PAGNED	;SET UP ARGS
	POP	P,P1		;FOR SATSRH. (CLRS BITS & RETURNS

    ;HERE TO GET SOME SPACE IN THE SAT.
RBNFL7:	PUSHJ	P,SATSRH	;T2/ DISK PNTR AND T1/ COUNT.).
	  POPJ	P,
	MOVE	P3,T1		;P3/ # PAGES GOTTEN.
	MOVE	P2,PAGNED	;CALC NO.
	SUB	P2,P3		;LEFT TO
	MOVEM	P2,PAGNED	;GET.
RBNFL8:	PUSHJ	P,PTREXT 	;STORE THE
	  POPJ	P,
	SOJLE	P3,.+2		;DISK POINTERS
	AOJA	T2,RBNFL8	;TO GOTTEN SPACE.

	JUMPLE	P2,RBNFL9	;MORE PAGES TO GET?
	SKIPLE	STTFPC(P1)	;YES.  MORE ROOM IN THIS SAT?
	 JRST	RBNFL7		;YES.
	JRST	RBNFL1		;NO.

    ;HERE WHEN DONE STORING PNTRS (EXCEPT FOR EOF PNTR).
RBNFL9:	SETZ	T2,		;STORE
	PUSHJ	P,PTREXT	;EOF PNTR.
	  POPJ	P,
	SKIPN	PGSRIB		;MORE THAN JUST A PRIME RIB?
	 JRST	RBNF10		;NO.
	PUSHJ	P,GETPRM	;YES, GET IT AND
	  POPJ	P,
	MOVE	P1,PGSRIB	;ADJUST
	ADDM	P1,%TMP+RIBALP	;RIBALP.
RBNF10:	MOVE	T2,%TMP+RIBSLF	;
	LDB	T4,RBYPNO	;WRITE
	MOVEI	PG,%TMP.P	;IT
	PUSHJ	P,OPAGOT	;OUT.
	  POPJ	P,
	JRST	CPOPJ1

PAGNED: Z		;TEMP STORAGE FOR RBNFIL.
COMMENT #
@@SUBROUTINE SATSRH
@@PURPOSE
SUBR TO GET SOME CONTIGUOUS FREE PAGES ON A SAT IN %STA, AND SET THEM IN USE.
SAT IS GUARANTEED TO HAVE SOME PAGES FREE ON ENTRY.
@@ENTRY
EXPECTS P1/ STT ENTRY ADDR OF SAT, P2/ MAX NO. OF PAGES
TO GET, U/ UNIT NO., AND F/ DDB.
@@ACCUM
DESTROYS T1 THRU T4 AND P2.
@@EXIT
IF ERROR, NON-SKIP RETURNS
 ELSE SKIP RETURNS WITH
	T2/ DISK POINTER TO FIRST PAGE GOTTEN
	T1/ NO. OF PAGES ACTUALLY GOTTEN
	THE SAT HAS THE PAGES TAKEN MARKED IN USE.
	STTFPC AND STTAOB ARE ALSO ADJUSTED.
@@ #

SATSRH:	SKIPN	T1,STTAOB(P1)	;T1/ CURRENT AOBJN POINTER.
	 JRST	SATSR2		;START AT START OF SAT IF NONE.
	SKIPE	T2,(T1)		;ANY FREE BITS IN THIS WORD?
	 JRST	SATSR3		;YES.
	AOBJN	T1,.-2		;NO, TRY NEXT WORD.

SATSR2:	MOVE	T1,[XWD -400,%STA] ;T1/ AOBJN PNTR TO START OF SAT.
	SKIPE	T2,(T1)		;ANY FREE BITS IN THIS WORD?
	  JRST	SATSR3		;YES.
	AOBJN	T1,.-2		;NO, TRY NEXT WORD.
	MSGLIV	OGTPG

    ;HERE ON FOUND FIRST FREE PAGE.  BUILD THE DISK POINTER TO IT.

SATSR3:	JFFO	T2,.+2		;GET T3/ NO. OF BITS INTO WORD.
	 STOPCD
	HRRZI	T4,-%STA(T1)	;Page # =
	IMULI	T4,^D36		;         (word in SAT * 36)
	ADDI	T4,(T3)		;          + (bit in word)
	HRRZ	T2,UNISTT(U)	;          + (starting page in SAT)
	SUB	T2,P1		;
	MOVNS	T2		;Offset into STT for this unit
	PUSH	P,T3		;
	IDIVI	T2,STTLEN	;
	IMULI	T2,400*^D36	;Starting page in this SAT
	POP	P,T3		;
	ADDI	T4,(T2)		;
	MOVSI	T2,RBREAL	;Build a Ret Ptr in T2
	DPB	T4,RBYPNO	; (page)
	LDB	T4,UNYLUN	;
	DPB	T4,RBYUNI	; (unit)
	PUSH	P,T2		;SAVE IT.

    ;NOW FIND ALL THE CONTIGUOUS PAGES WE CAN/WANT, AND MARK THEM TAKEN.

	MOVE	T2,(T1)		;T2/ SAT WORD AGAIN.
	HRLZI	T4,400000	;BUILD THE
	MOVNS	T3		;MASK IN
	LSH	T4,(T3)		;T4.
	MOVEM	T1,STTAOB(P1)	;SAVE THE AOBJN POINTER.
	SETZ	T1,		;T1/ # OF FREE PAGES.
	ADDI	T3,^D36		;T3/ MAX NO.
	CAMLE	T3,P2		;OF BITS TO LOOK
	 MOVE	T3,P2		;AT IN THIS WORD.
SATSR5:	TDZN	T2,T4		;NEXT PAGE IS FREE?
	 JRST	SATSR8		;NO, DONE.
	ADDI	T1,1		;YES, COUNT IT.
	LSH	T4,-1		;ADJUST THE MASK.
	SOJG	T3,SATSR5	;CONTINUE IN THIS WORD.
	CAML	T1,P2		;NEED MORE?
	 JRST	SATSR8		;NO.
	MOVE	T3,STTAOB(P1)	;YES, TRY TO GET
	AOBJP	T3,SATSR8	;NEXT WORD.  IS THERE ONE?
	MOVEM	T2,-1(T3)	;YES.
	SKIPN	T2,(T3)		; ANY FREE PAGES IN IT?
	 JRST	SATSR9		;NO.  DONE.
	MOVEM	T3,STTAOB(P1)	;YES.  SAVE AOBJN PNTR.
	HRLZI	T4,400000	;SET UP MASK FOR NEW WORD.
	MOVE	T3,P2		;SET UP T3 TO
	SUB	T3,T1		;MAX. NO. OF
	CAILE	T3,^D36		;BITS TO LOOK AT
	 MOVEI	T3,^D36		;IN THIS WORD.
	JRST	SATSR5		;GO LOOK AT THIS WORD.

    ;HERE ON DONE.

SATSR8:	MOVE	T3,STTAOB(P1)	;
	MOVEM	T2,(T3)		;
SATSR9:	MOVE	T3,STTFPC(P1)	;ADJUST THE
	SUB	T3,T1		;FREE PAGE
	MOVEM	T3,STTFPC(P1)	;COUNT.
	POP	P,T2		;RESTORE T2/ DISK POINTER.
	JRST	CPOPJ1
COMMENT #
@@SUBROUTINE OGETPG
@@PURPOSE
SUBR TO GET ONE PAGE ON THE DISK.
@@ENTRY
EXPECTS F/ DDB AND U/ UNIT DB.
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@CALLS
SATSRH AND GETSAT.
@@EXIT
NON-SKIP RETURNS IF NO PAGE AVAILABLE,
ELSE SKIP RETURNS WITH T2/ DISK PNTR TO THE PAGE.
@@ #

OGETPG:	PUSH	P,P1		;SAVE P1 AND
	PUSH	P,P2		;P2.
	MOVEI	P2,1		;TELL SATSRH WE WANT ONE PAGE.
	HRRZ	P1,UNISTT(U)	;P1/ STT ENTRY ADDR.
OGETP2:	SKIPE	T2,STTPTR(P1)	;AT END OF STT?
	 JRST	OGETP3
	POP	P,P2
	POP	P,P1
	MSGLIV	OGTPG
OGETP3:	SKIPE	STTFPC(P1)	;NO.  ANY FREE PAGES IN THIS SAT?
	 JRST	OGETP4		;YES.
	ADDI	P1,STTLEN	;NO, CONTINUE.
	JRST	OGETP2		;

OGETP4:	PUSHJ	P,GETSAT	;Read in SAT
	  JRST	OGETP5
	PUSHJ	P,SATSRH	;GET T2/ DISK PNTR TO 1ST FREE PAGE.
	  JRST	OGETP5
	POP	P,P2		;RESTORE P2 AND
	POP	P,P1		;P1.
	JRST	CPOPJ1

OGETP5:	POP	P,P2
	POP	P,P1
	POPJ	P,
COMMENT #
@@SUBROUTINE CNDSWT
@@PURPOSE
SUBR TO CONDITIONALLY WRITE OUT A SAT IN CORE.
@@ACCUM
DESTROYS U, PG,
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE, NON-SKIP RETURNS.
@@ #

CNDSWT:	SKIPN	T2,SATDSK	;IS THERE A SAT IN %STA?
	 JRST	CPOPJ1		;NO, NO NEED TO DO ANYTHING.
	LDB	T4,RBYPNO	;YES,
	LDB	U,RBYUNI	; WRITE
	MOVE	U,UNTTBL(U)	; IT
	MOVEI	PG,%STA.P	; OUT.
	PUSHJ	P,OPAGOT	;
	 MSGLIV	IOFAL
	SETZM	SATDSK		;MARK NO SAT IN CORE.
	JRST	CPOPJ1		;SUCCESS RETURN.
COMMENT #
@@SUBROUTINE GETSAT
@@PURPOSE
SUBR TO GET A SAT INTO CORE, POSSIBLY WRITING OUT A SAT FIRST.
@@ENTRY
EXPECTS T2/ DISK ADDRESS OF DESIRED SAT, U/ UNIT DB, AND F/ DDB.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE, NON-SKIP RETURNS.
@@ #

GETSAT:	CAMN	T2,SATDSK	;ALREADY HAVE THIS SAT IN CORE?
	 JRST	CPOPJ1		;YES.  JUST TAKE SUCCESS RETURN.
	MOVEI	PG,%STA.P	;NO, IS THERE
	EXCH	T2,SATDSK	;A SAT
	JUMPE	T2,GTSAT6	;IN CORE?
	LDB	T4,RBYPNO	;YES.  WRITE IT
	PUSH	P,U		;
	LDB	U,RBYUNI	;
	MOVE	U,UNTTBL(U)	;
	PUSHJ	P,OPAGOT	;OUT.
	  PUSHJ	P,[POP P,T2	;
		EXCH T2,(P)	;
		MSGLIV 	IOFAL]
	POP	P,U		;
GTSAT6:	MOVE	T2,SATDSK	;HERE TO READ OUR SAT
	LDB	T4,RBYPNO	;INTO CORE.
	PUSHJ	P,OPAGIN	;
	 MSGLIV	IOFAL
	JRST	CPOPJ1		;
COMMENT #
@@SUBROUTINE SATRBS/HOMRBS
@@PURPOSE
VARIOUS SUBRS TO STORE A RETRIEVAL POINTER AND INC RIBALP.
@@ENTRY
EXPECTS T2/ RETRIEVAL POINTER TO STORE AND XXXRBP TO BE AN AOBJN POINTER.
@@ACCUM
DESTROYS T1.
@@EXIT
STOPCDS IF AOBJN POINTER RUNS OUT.
ELSE RETURNS WITH NEW AOBJN POINTER STORED AND RIBALC ADJUSTED.
@@ #

TMPRBS:	MOVE	T1,TMPRBP
	AOBJN	T1,TMPRS1
	 MSGSFE	RBNOUT
TMPRS1:	MOVEM	T1,TMPRBP
	PUSHJ	P,SAVT		;SAVE T2,T3,T4
	MOVEI	T3,%TMP
	JRST	HOMRS2

SATRBS:	MOVE	T1,SATRBP
	AOBJN	T1,SATRS1
	 MSGSFE	RBNOUT
SATRS1:	MOVEM	T1,SATRBP
	PUSHJ	P,SAVT		;SAVE T2,T3,T4
	MOVEI	T3,%STR
	JRST	HOMRS2

HOMRBS:	MOVE	T1,HOMRBP
	AOBJN	T1,HOMRS1
	 MSGSFE	RBNOUT
HOMRS1:	MOVEM	T1,HOMRBP
	PUSHJ	P,SAVT
	MOVEI	T3,%HMR
HOMRS2:	MOVEM	T2,(T1)
	AOS	RIBALP(T3)	;COUNT NO. OF PAGES IN THIS FILE.
	POPJ	P,
COMMENT #
@@SUBROUTINE CLUAOB/CLSAOB
@@PURPOSE
SUBRS TO CLEAR OUT THE STTAOB ENTRIES FOR A UNIT (CLUAOB)
OR FOR ALL UNITS IN A STR (CLSAOB).
@@ENTRY
CLUAOB EXPECTS UNIT DB ADDR IN REFUNI.  CLSAOB EXPECTS
DB ADDB OF FIRST UNIT ON THE STR IN FTSUNI.
@@ACCUM
DESTROYS U AND T1.
@@ #

CLUAOB:	MOVE	U,REFUNI
CLUAB1:	HRRZ	T1,UNISTT(U)	;
CLUAB2:	SKIPN	STTPTR(T1)	;
	  POPJ	P,
	SETZM	STTAOB(T1)	;Zero the AOBJN pointer
	ADDI	T1,STTLEN
	JRST	CLUAB2		;

CLSAOB:	MOVE	U,FSTUNI	;First unit
	PUSHJ	P,CLUAB1	;
	HLRZ	U,UNISTR(U)	;Next unit
	JUMPN	U,.-2		;
	POPJ	P,
COMMENT #
@@SUBROUTINE TMPIN/TMPOUT
@@PURPOSE
LITTLE SUBRS TO SET UP ARGS AND CALL OPAGIN/OT FOR IO TO/FROM %TMP.
@@ENTRY
EXPECT T2/ DISK POINTER OF PAGE TO BE TRANSFERRED.
@@CALLS
OPAGIN AND OPAGOT.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURN ON SUCCESS.
@@ #

TMPIN:	SKIPA	T3,[OPAGIN]	;Input
TMPOUT:	 MOVEI	T3,OPAGOT	;Output
	LDB	T4,RBYPNO	;GET PAGE NO. FROM T2.
	LDB	U,RBYUNI	;GET UNIT DB
	MOVE	U,UNTTBL(U)	;ADDR FROM T2 AND UNTTBL.
	MOVEI	PG,%TMP.P	;IO TO/FROM %TMP.
	PUSHJ	P,(T3)		;READ OR WRITE THE PAGE.
	 MSGLIV	IOFAL
	JRST	CPOPJ1		;WON.

;Routines to do what TSTSUP.SAV does - read/patch/write disk pages.

TSTSUP::MOVEM	P,SAVEP
	MOVEI	T1,[ASCIZ /TSTSUP routines.
Set page number in PAGE, then use PREAD$G to read, and PWRITE$G to write./]
	PUSHJ	P,CONOUT
	MOVEI	T1,[ASCIZ /
Data is in %TMP<%TMP+777>0$N.   Use FILES$G to get back to "FILES*".
/]
	PUSHJ	P,CONOUT
	MOVEI	T2,LPNHOM	;Reset to first HOM page on unit 0
	MOVEM	T2,PAGE
	PUSHJ	P,TMPIN		;Read it
	  JRST	PREAD4
;*;	JRST	PREAD1		;Show what's been read it
	MOVEI	0,[ASCIZ \C REFSTR: %TMP6T/ PAGE[\]
	JRST	DDT+1		;Tell DDT to unlock the symbol table


FILES::	SKIPN	P,SAVEP		;Reset PDL
	 JRST	SYSDSP##	;If no stack, do 140$G
	POPJ	P,		;Return to "FILES*" in ONCDSK

	PURGE	D		;Get rid of D=17 (for dump mode)
	D=%TMP			;Local symbol (only if REFSTR$:)
	EXTERN	DDT
;Write data from %TMP to disk address in PAGE

PWRITE::PUSHJ	P,PREAD0	;TSTSUP routine to write a page
	PUSHJ	P,TMPOUT
	  JRST	PREAD4		;Error
	PFALL	PREAD		;Verify by reading it back in again

;Read data from disk address in PAGE to %TMP

PREAD::	PUSHJ	P,PREAD0	;TSTSUP routine to read a page
	PUSHJ	P,TMPIN
	  JRST	PREAD4		;Error
PREAD1:	PUSHJ	P,OPOUT		;Type out the contents of PAGE
;*;	MOVEI	T1,[ASCIZ .PAGE/  .]
;*;	PUSHJ	P,CONMES
;*;	MOVE	T1,PAGE
;*;	PUSHJ	P,PRT22A##	;Print 22-bit address
;*;	PUSHJ	P,CRLFOP
;*;	JRST	DDT
	MOVEI	0,[ASCIZ .PAGE/.]
	JRST	DDT+1		;Let EDDT type out the data

PREAD0:	MOVE	T2,PAGE		;Set up T2 for TMPIN/TMPOUT
	LDB	U,RBYUNI	;Get unit # from bits 9-16 of T2
	CAIG	U,UNTLEN##	;Don't exceed size of UNTTBL
	SKIPN	U,UNTTBL(U)	;Check if UNTTBL has been set up
	 JRST	PREAD2		;Out of range or did not go thru FILES
	LDB	T4,RBYPNO	;Get page # from T2
	CAMGE	T4,UNIPPU(U)	;Within range of page addresses?
	 POPJ	P,		;OK
PREAD2:	MOVEI	T1,[ASCIZ \? PAGE out of range or UNTTBL not set up.  \]
	PUSHJ	P,CONMES
	POP	P,(P)		;Dump return address
	JRST	PREAD1

PREAD4:	MOVEI	T1,[ASCIZ \?I/O error on \]
	PUSHJ	P,CONMES
	JRST	PREAD1

CONOUT:	PUSHJ	P,CONMES	;String in T1 + CRLF + output buffer
CRLFOP:	PUSHJ	P,CRLF##
	PJRST	OPOUT
COMMENT #
@@SUBROUTINE PTREXT
@@PURPOSE
SUBR TO STORE A RETRIEVAL POINTER IN %TMP ACCORDING TO TMPRBP,
TAKING INTO ACCOUNT AN EXTENDED RIB STRUCTURE.
(THIS REALLY DOESN'T NEED THREE LEVELS; ALSO PERHAPS THE
OGETPG CALLS SHOULD LOOK AT MORE THAN ONE UNIT.)
@@ENTRY
EXPECTS TMPRBP AND THE RIB IN %TMP TO BE SET UP,
T2/ THE RETRIEVAL POINTER TO BE STORED, AND F/ DDB.
@@CALLS
RIBEX1, RIBEX2, RIBEX3, RIBEX4, OGETPG, TMPOUT, TMPIN, CORZER AND MOROOM.
@@ACCUM
DESTROYS T1, T3, T4, AND PG.
PRESERVES U.
@@EXIT
IF ERROR, NON-SKIP RETURNS, ELSE SKIP RETURNS.
ON EXIT, THE RIB IN %TMP MAY NOT BE THE RIB THAT WAS THERE
ON ENTRY.  ON SUCCESSFUL EXIT, TMPRBP WILL BE SET UP PROPERLY
AND PGSRIB IS INCREMENTED FOR EACH ADDITIONAL RIB GENERATED.
@@ #

PTREXT:	MOVE	T1,TMPRBP	;GET THE AOBJN PNTR TO THE
	AOBJN	T1,PTROT2	;RETRIEVAL PNTR STORAGE AREA.
	PUSH	P,U		;PRESERVE U.
	JRST	PTREX1		;OUT OF ROOM.

PTROU0:	POP	P,P2		;
	POP	P,P1
PTROUT:	POP	P,T2		;RESTORE THE RETRIEVAL POINTER.
	POP	P,U		;RESTORE U.
PTROT2:	MOVEM	T1,TMPRBP	;STORE THE AOBJN
	MOVEM	T2,(T1)		;PNTR & RETRIEVAL PNTR.
	JRST	CPOPJ1

    ;HERE WHEN WE MUST GET ANOTHER RIB.
PTREX1:	PUSH	P,T2		;SAVE RET PNTR WE WANT TO STORE.
	SKIPE	T2,%TMP+RIBSLF	;GET A DISK PAGE TO WRITE US
	  JRST	PTREX2		;OUT TO, UNLESS
	PUSHJ	P,OGETPG	;WE HAVE
	  JRST	PTRFAL		;ONE
	MOVEM	T2,%TMP+RIBSLF	;ALREADY.
PTREX2:	MOVE	T1,%TMP+RIBSZS	;IF NOT AT LOWEST LEVEL
	SOJG	T1,PTREX3	;AND EO RIB WITH REAL PNTR,
	SKIPN	%TMP+RIBRIB	;OR IF ONLY ONE RIB, WE
	  JRST	PTREX3		;HAVE TO EXPAND.

    ;HERE WHEN WE ARE AT LOWEST LEVEL AND THERE IS A HIGHER RIB.
    ;WE MAY OR MAY NOT HAVE TO EXPAND.

	PUSH	P,%TMP+RIBRPS	;SAVE OUR POSITION FOR MOROOM.
	PUSHJ	P,TMPOUT	;(WE HAVE ALREADY SET UP T2), SO
	  JRST	PTRFL1		;WRITE US OUT.
	MOVE	T2,%TMP+RIBRIB	;READ IN THE
	PUSHJ	P,TMPIN		;HIGHER RIB.
	  JRST	PTRFL1
	POP	P,T1		;RESTORE OUR POINTER.
	PUSHJ	P,MOROOM	;ROOM FOR ANY MORE PNTRS IN IT?
	  JRST	PTROUT		;YES.
	SKIPN	T2,%TMP+RIBRIB	;NO. IF THIS IS THE HIGHEST,
	  JRST	PTREX3		;GO EXPAND.
	PUSH	P,%TMP+RIBRPS	;SAVE OUR POSITION FOR MOROOM.
	PUSHJ	P,TMPIN		;READ IN THE HIGHER
	  JRST	PTRFL1		;RIB.
	POP	P,T1		;RESTORE OUR POSITION.
	PUSHJ	P,MOROOM	;ROOM FOR ANY MORE PNTRS?
	  JRST	PTROUT		;YES.
	MSGSFE	RBEOUT		;EXCEEDED 3 LEVELS (IMPOSSIBLE!)

    ;HERE TO EXPAND THE RIB STRUCTURE.

PTREX3:	MOVEI	T1,%T2P		;CLEAR OUT A SPARE RIB
	PUSHJ	P,CORZER	;IN %T2P.
	AOS	PGSRIB		;COUNT IT.
	PUSHJ	P,OGETPG	;GET A PAGE
	  JRST	PTRFAL		;FOR
	MOVEM	T2,%T2P+RIBSLF	;IT.
	MOVEI	T1,CODRIB	;SET ITS
	MOVEM	T1,%T2P+RIBCOD	;RIBCOD.
	PUSH	P,P1		;SET UP THE
	PUSH	P,P2		;ARGS
	MOVEI	P1,%TMP		;FOR
	MOVEI	P2,%T2P		;THE RIBEX? SUBRS.
	MOVE	T1,%TMP+RIBLST	;JUMP UNLESS LAST PNTR IN OUR
	JUMPGE	T1,PTREX4	;SOURCE RIB IS A SPARE RIB PNTR.

    ;HERE TO EXPAND FROM TWO LEVELS TO THREE.

	PUSHJ	P,RIBEX1	;SET UP INFO IN BOTH RIBS.
	MOVEI	T4,RIBSFS+RBLVPR-1 ;
	JRST	PTRE45		;


    ;HERE ON ALL RIB EXPANSION EXCEPT FROM TWO LEVELS TO THREE.

PTREX4:	PUSHJ	P,RIBEX2	;SET UP INFO IN BOTH RIBS.
	  JRST	PTRE45		;NEED NO INTERMED RIB.
	PUSH	P,T4		;NEED INTERMED RIB.  SAVE RPS.
	PUSHJ	P,OGETPG	;
	  JRST	PTRFL2
	AOS	PGSRIB		;COUNT THE INTERMEDIATE RIB.
	PUSHJ	P,RIBEX3	;LINK IT IN.
	MOVE	T2,%TMP+RIBSLF	;
	PUSHJ	P,TMPOUT	;WRITE OUT THE
	  JRST	PTRFL2		;HIGHEST RIB.
	MOVEI	T1,%TMP		;CLEAR SPACE FOR THE
	PUSHJ	P,CORZER	;INTERMEDIATE RIB.
	JSP	T4,RIBEX4	;SET UP MORE STUFF.
	POP	P,T4		;RESTORE RPS.


PTRE45:	HRLZI	P1,-RIBLST(T4)	;SET UP THE AOBJN PNTR
	HRRI	P1,%TMP+1(T4)	;FOR PTROU0.
	MOVE	T2,%TMP+RIBSLF	;WRITE OUT
	PUSHJ	P,TMPOUT	;A RIB.
	  JRST	PTRFL0
	MOVE	T1,[XWD %T2P,%TMP] ;COPY THE NEW RIB TO
	BLT	T1,%TMP+777	;THE CURRENT RIB AREA.
	MOVE	T1,P1		;GET AOBJN PNTR FOR PTROUT.
	JRST	PTROU0		;


PTRFL2:	POP	P,T1		;VARIOUS
PTRFL0:	POP	P,P2
	POP	P,P1		;ERROR
	JRST	PTRFAL

PTRFL1:	POP	P,T1		;EXITS.
PTRFAL:	POP	P,T2
	POP	P,U
	POPJ	P,
COMMENT #
@@SUBROUTINE MOROOM
@@PURPOSE
LITTLE SUBR TO SEE IF THERE IS ANY MORE ROOM IN A RIB IN
%TMP TO STORE POINTERS.
@@ENTRY
EXPECTS T1/RIBRPS FROM LOWER RIB.
@@ACCUM
DESTROYS T1 AND T2.
@@EXIT
SKIP RETURNS IF NO MORE ROOM.  NON-SKIP RETURNS IF THERE IS
MORE ROOM, WITH T1/ AOBJN POINTER TO ROOM.
@@ #

MOROOM:	ADDI	T1,%TMP+1	;GET ADDR OF NEXT POINTER.
	CAILE	T1,%TMP+RIBLST	;PAST E O RIB?
	 JRST	CPOPJ1		;YES, RETURN.
	MOVEI	T2,(T1)		;NO.  MAKE THE USED AOBJN
	SUBI	T2,%TMP+RIBLST	;PNTR IN T1,
	HRLI	T1,-1(T2)	;AND TAKE THE
	POPJ	P,		;SUCCESSFUL RETURN.
COMMENT #
@@SUBROUTINE GETPRM
@@PURPOSE
SUBR TO WRITE OUT THE RIB IN CORE IN %TMP AND THEN GET
ITS PRIME RIB INTO %TMP.
@@CALLS
TMPIN AND TMPOUT.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

GETPRM:	SKIPN	%TMP+RIBRIB	;Check if there is a pointer to upper level
	 JRST	CPOPJ1		;Already at prime RIB
	MOVEI	P1,2		;CHECK FOR 2 more levels
GETPR4:	PUSH	P,%TMP+RIBRIB	;SAVE ADDR OF HIGHER RIB.
	SKIPE	T2,%TMP+RIBSLF	;IF NECESSARY, GET
	  JRST	GETPR5		;
	PUSHJ	P,OGETPG	;A PAGE FOR THE
	  JRST	[POP  P,T1
		 POPJ P,]
GETPR5:	MOVEM	T2,%TMP+RIBSLF	;CURRENT RIB.
	PUSHJ	P,TMPOUT	;
	  JRST	[POP  P,T1
		 POPJ P,]
	POP	P,T2		;READ IN THE
	PUSHJ	P,TMPIN		;HIGHER RIB.
	  POPJ	P,
	SKIPN	%TMP+RIBRIB	;DONE?
	 JRST	CPOPJ1		;YES
	SOJG	P1,GETPR4	;NO, DON'T DO MORE THAN 3 LEVELS.
	MSGSFE	RIBFAL
COMMENT #
@@SUBROUTINE RIBSET
@@PURPOSE
SUBR TO SET UP PRIME RIB INFORMATION IN A SPECIFIED AREA IN CORE.
@@ENTRY
EXPECTS:
	T1=NAME OF FILE
	T2=EXT,,PROTECTION
	T3=PPN
	T4=ADDR OF CORE AREA TO BE SET UP.
	P4=BITS TO SET IN STATUS WORD
@@ACCUM
DESTROYS T1 AND T2.
@@CALLS
CORZER.
@@ #

RIBSET:	PUSH	P,T1		;SAVE T1 AND
	PUSH	P,T2		;T2 FROM CORZER.
	MOVE	T1,T4		;ARG FOR CORZER.
	PUSHJ	P,CORZER	;CLEAR OUT THE RIB AREA.
	POP	P,T2		;RESTORE T2 AND
	POP	P,T1		;T1.
	MOVEM	T1,RIBNAM(T4)	;File name
	HLLZM	T2,RIBEXT(T4)	;Extension
	TRZ	T2,777		;Clear possible HOM index from protection
	HRLZM	T2,RIBPRV(T4)	;Set protection code
	MOVEM	T3,RIBPPN(T4)	;PPN
	HRRZ	T3,THSDAT##	;Today's date
	HRRM	T3,RIBPRV(T4)	;Set 12-bits creation date (and 2 bits time)
	HRRM	T3,RIBEXT(T4)	;Set 14-bits access date
	LSH	T3,-^D12	;High-order 2 bits of creation date
	DPB	T3,[POINT 2,RIBEXT(T4),21]
	MOVE	T2,TIME##	;Ticks since midnight
	IDIV	T2,JFYMIN##	;Convert to minutes
	DPB	T2,[POINT 11,RIBPVW(T4),23] ;Creation time
	MOVEI	T3,1		;Single-level RIB structure
	MOVEM	T3,RIBSZS(T4)	;
	MOVEI	T3,CODRIB	;UNLIKELY CODE
	MOVEM	T3,RIBCOD(T4)	;FOR RIB.
	MOVEM	P4,RIBSTS(T4)	;
	TRNN	P4,RIPDIR	;UFD OR MFD?
	 POPJ	P,		;NO, RETURN.
        PFALL	RIBSTU
    ;HERE ONLY FOR MFD OR UFDS.
RIBSTU:	MOVE	T3,QUOTAF	;YES, SET FCFS
	MOVEM	T3,RIBQTF(T4)	; AND
	MOVE	T3,QUOTAO	; LOGGED OUT
	MOVEM	T3,RIBQTO(T4)	; QUOTAS.
	MOVE	T2,[SIXBIT /UFD/];SET UP
	CAMN	T1,MFDUFD	; RIBUNM
	 JRST	RIBST8		; WITH
	MOVE	T2,[SIXBIT /SYS/];THE
	CAMN	T1,SYSUFD	; APPROPRIATE
	 JRST	RIBST8		; NAME
	CAME	T1,SPLUFD
	 POPJ	P,		;Unknown PPN, don't set name
	MOVE	T2,[SIXBIT /NG/]
	MOVEM	T2,RIBUN1(T4)	;Set to 'SPOOLING'
	MOVE	T2,[SIXBIT /SPOOLI/]
RIBST8:	MOVEM	T2,RIBUNM(T4)
	POPJ	P,
COMMENT #
@@SUBROUTINE CNVSIZ/CNVSZM
@@PURPOSE
LITTLE SUBRS TO SET RIBSIZ.
@@ENTRY
EXPECTS T1/ ADDR OF RIB IN CORE.
@@ACCUM
DESTROYS T2.
@@ #

CNVSZM:	SOSA	T2,RIBALP(T1)	;Decrement for later increment (PAKREF)
CNVSIZ:	MOVE	T2,RIBALP(T1)	;Allocated pages so far (excluding RIB)
	LSH	T2,P2WLSH	;CALCULATE WORDS
	MOVEM	T2,RIBSIZ(T1)	;
	POPJ	P,
SUBTTL	Tables and storage

;The following definitions and table need to be updated if COMMOD is changed.
;The offsets into the HOM page are defined here for easy reference, LOADER
;will complain if they differ from the definitions in COMMOD.

XP HOMFEP,014	;# of FEFILE data pages ,, First FEFILE data page (unit 0 only)
XP HOMSAT,017	;RIB for SAT.SYS
XP HOMHMS,020	;RIB for HOME.SYS
XP HOMSPG,021	;Prime RIB for SPAGES.SYS (formerly SWAP.SYS)
XP HOMCRS,022	;Prime RIB for CRASH.SAV (8192+ pages on KL)
XP HOMSUF,023	;RIB for (SYS) [1,4].UFD
XP HOMPUF,024	;RIB for (SPOOLING) [11653,115244].UFD
XP HOMMFD,025	;RIB for (UFD) [1,1].UFD
XP HOMP4C,026	;Number of pages allocated to CRASH.SAV
EXTERN SYRDPR,SYNRPR	;Read and no-read protection for *.SYS files
EXTERN SYSPPN,SYSPRV	;PPN for SYS and protection for that directory
EXTERN MFDPPN,MFDPRV	;PPN for MFD and protection for that directory
EXTERN SPLPPN		;PPN for (SPOOLING)

DEFINE ITEMS<;;SYS files must come before UFDs, otherwise can be in any order
;;NAM,FILENAME,EXT,PROT,INDEX,PCB
X HOM,HOME  ,SYS,SYRDPR,HOMHMS,HMR;;020  HOME.SYS   HOME, BAT and BOOTS
X SAT,SAT   ,SYS,SYRDPR,HOMSAT,STR;;017  SAT.SYS    SAT file
X CRS,CRASH ,SAV,SYNRPR,HOMCRS    ;;022  CRASH.SAV  (later .EXE) crash file
X SPG,SPAGES,SYS,SYNRPR,HOMSPG,TMP;;021  SPAGES.SYS Spare PAGES file, cyl 1 & 2
IFCPU (KS),<;;Note: pointer to RIB is NOT stored in HOM page.
X FEF,FEFILE,SYS,SYNRPR,0 >       ;;014  FEFILE.SYS for 2020 front-end
  ;;The UFDs must be last
X SYS,SYSPPN,UFD,SYSPRV,HOMSUF    ;;023  (SYS).UFD
X SPL,SPLPPN,UFD,754000,HOMPUF    ;;024  (SPOOLING).UFD
X MFD,MFDPPN,UFD,MFDPRV,HOMMFD    ;;025  (UFD).UFD
> ; End Define ITEMS

	NFILE==<NUFDS==0>	;Initialize counters
DEFINE X(NAM,FILE,EXT,PROT,INDEX,PCB),<
    IFDIF <EXT>,<UFD>,<NFILE==NFILE+1;;Count number of nonUFD files
            IFG NUFDS,<PRINTX ? UFDs must be last in ITEMS macro>
  NAM'FIL: SIXBIT /FILE/>
    IFIDN <EXT>,<UFD>,<NUFDS==NUFDS+1;;Count number of UFDs
  NAM'UFD: EXP 0 >;;PPN will be filled in later
>
R.FILE:	ITEMS			;File names or addr of PPN

DEFINE X(NAM,FILE,EXT,PROT,INDEX,PCB),<
  NAM'EXP: XWD ''EXT'',PROT+INDEX>
R.EXPR:	ITEMS			;Extension, protection, index into %HOM

DEFINE X(NAM,FILE,EXT,PROT,INDEX,PCB),<
  NAM'ALP: 0>
R.ZERB:!			;Start of area to zero
R.SIZE:	ITEMS			;Allocated size
				;R.SIZE+R.RIBS zeroed before REFRESH
DEFINE X(NAM,FILE,EXT,PROT,INDEX,PCB),<
  NAM'RBD: 0>
R.RIBS:	ITEMS			;RIB data (retrieval pointer)
R.ZERE==.-1			;End of area to zero

DEFINE X(NAM,FILE,EXT,PROT,INDEX,PCB),<;;Generates 0 if PCB is blank
  NAM'CTL: IFNB <PCB>,<XWD %'PCB,%'PCB'.P;> 0>
R.PCBS:	ITEMS			;PCB data for files that are on all units

DEFINE X(NAM,FILE,EXT,PROT,INDEX,PCB),<IFNB <PCB>,<PCB'RBP:>
  NAM'RBP: 0 >
R.RBPS:	ITEMS			;Pointers into RIB for adding new pages
SUBTTL	MISC. DATA LOCATIONS.

RANNO::	BLOCK	1	;Holder for RANDOM # for REFRESH
UFDSTP:	BLOCK	1	;PNTR TO SPACE IN UFD RIB FOR PNTRS.

BEGSAT:	BLOCK	1	;First page in SAT
SVSBTL:	BLOCK	1	;# of pages in SAT
LPGSAT:	BLOCK	1	;Last page in current SAT

FSTUNI:	BLOCK	1	;ADDR OF FIRST UNIT IN STR (FOR REFRSH)
REFUNI:	BLOCK	1	;STORAGE FOR PAKREF.  (UNIT CURRENTLY BEING REFRESHED)

SATIND:	BLOCK	1	;USED AS A TEMPORARY.

SATDSK:	BLOCK	1	;FLAG TO PREVENT UNNECESSARY IO ON SAT PAGE.

PGSSPG:	BLOCK	1	;USED BY SPAGES AND FEFILE
PGSRIB:	BLOCK	1	;USED BY RBNFIL, ETC. TO KEEP TRACK OF COUNT OF
			;RIBS AND MAYBE OF PAGES.

SAVEP:	BLOCK	1	;Saved PDL
PAGE::	BLOCK	1	;Current disk page number for TSTSUP

REFLIT:	LIT
	VAR


REFLNR==.-%REF+1	;# of words in REFSTR
REFLNP==<REFLNR!777>+1	;Rounded up to page boundry

ONSZCK(REFSTR,REF)	;CHECK TO SEE IF ENOUGH PAGES ALLOCATED

DEPHASE

REFEND:	END		;Cannot use $END in PHASEd code
   Uhf
b