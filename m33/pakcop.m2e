SUBTTL	SAXPRM	Parameters for SA-10 + IBM-disk + STC-tape
;The prefix "SAX" is "SA-10" using roman numerals.

COMMENT ~	Created by Joe Smith for the P034/P00 monitor, September 1985

The SA-10 lives on the I/O bus and emulates two IBM block multiplexor channels.
(Systems Concepts makes a four channel SA-10, but TYMSHARE does not use any.)

On TYMCOM-X systems, SAX channel 0 goes to the STC tape controller.
On TYMCOM-X systems, SAX channel 1 goes the disk subsystem.

The disk subsystem consists of:
  One or two 3672 Storage Control Units with one or two strings each.
    Each disk string has a 3673 string controller and four 3675 disks modules.
      Current maximum of 32 disk packs (two SCUs with two strings each).
      Each module has two mountable 200 megabyte disks (3330 equivalents).
        Total of 6.4 gigabytes on 32 disks.
                         - or -
  One 3674 Storage Control Unit with up to four strings.
    The disk string is a 3653 CTLR and up to three 3650 disk modules (8 disks).
    The disk string may be a 3673 string controller and four 3675 disks modules.
      Current maximum of 32 disk packs (one SCU with four strings).
      Each module has two fixed 317 megabyte disks (3350 equivalents).
        Total of 10.2 gigabytes on 32 disks if all are 3650s.

There is an absolute maximum of 256 disks on an IBM-compatible channel:
  16 SCUs * 2 CTLRs * 8 packs  - or -  8 SCUs * 4 CTLRs * 8 packs

Note: A 24-pack 3675 system (4.8 Gb) can be replaced with a 16-pack 3650 system.

        -------------------------------------------------------------

Nomenclature:

 TYM "Channel" = one of the 4 channels on an SA-10, a PDP-10 can have 8
		channels if it has two expanded SA-10's.  Selected by the
		device code and 2 bits of a CONO instruction.

 IBM "Channel" = one of 16 block multiplexor channels attached to a 370.
		Selected by bits 4-7 of 3rd byte of an I/O instruction.

PAKCOP "Kontroller" = Mythical device that can handle up to 32 disk drives.
		Up to 8 kontrollers, for a maximum of 256 disk drives.
		(Software currently set up for only 1 kontroller.)

 TYM "Kontroller" = Device that can handle 16 disk drives (two strings).
		A 16-pack (2-string) system has 1 kontroller.
		A 32-pack (4-string) system has 2 kontrollers.
		One kontroller = 1 Memorex 3672 + 2 Memorex 3673 string CTLRs.
		Or 1 kontroller = 1 Ampex DC830 + 2 strings of 331 disks.
		1 Memorex 3674 = 2 kontrollers = 4 strings.

 IBM "SCU+CTLR"   = Storage Control Unit and disk string controller.
		Selected by bits 0-4 of 4th byte of an I/O instruction.
		Up to 32 SCU+CTLR's, each with 8 disks, maximum of 256 disks.
	The new model SCU can handle 4 strings of 8, total of 32 disks.
	The old model SCU has only 2 strings of 8 disks, requiring two SCU's.

 TYM "Unit"  = one of 16 disk drives attached to a kontroller.
 IBM "Drive" = one of 8 disks on a string.  Selected by bits 5-7 of 4th byte.

 TYM "Disk Address" = Combination of KONTROLLER+UNIT = one of 256 disks.
 IBM "Storage Subsystem Address" = 4th byte of I/O instruction, one of 256 disks

TYMCOM-X arbitrarily assigns the first available disk unit address as X'1C0'.
This is channel 1 address 'C0' hex, caused by "KN0==300" (octal).  The first
kontroller handles unit addresses 'C0' to 'CF', a second kontroller would
handle unit addresses 'D0' to 'EF'.  (Note: PAKCOP uses a different definition
It uses KONTROLLER to refer to a device combination that can handle 32 disks. .

        -------------------------------------------------------------

Definition of CB's in PAKCOP.MAC

%UNI incremented per unit, equals total units at end
%KUN incremented per unit, reset for each KONCB, equals unit on this kontroller
%CUN incremented per unit, reset for each CHNCB, equals unit on this channel
%KON  incremented per KONCB, equals total kontrollers at end
%KCUN incremented per KONCB, reset for each CHNCB, equals kon on this channel
%CHN  incremented per CHNCB, equals total channels at end

%.A0   SA-10 #0                                %SAX=0
		CONI, CONO, and DATAI for the entire SA-10
 %.B0   Channel 0 of SA 0                       %CHN=0
		TAPE stuff
 %.B1   Channel 1 of SA 0                       %CHN=1
		CONO and CONSO for this channel (one of 4 possible channels)
  %.C0   Kontroller for first 32 disks           %KON=0 %KCUN=0
   %.D0   Disk unit (0-7 on 1st string of 1st 3672 or 1st string on 3674)
   %.D10  Disk unit (0-7 on 2nd string of 1st 3672 or 2nd string on 3674)
   %.D20  Disk unit (0-7 on 1st string of 2nd 3672 or 3rd string on 3674)
   %.D30  Disk unit (0-7 on 2nd string of 2nd 3672 or 4th string on 3674)
  %.C1   Kontroller for next 32 disks would go here, addresses '1E0' to '1FF'.
   %.D40  (additional disk units would go here)
 %.B2   Channel 2 of SA 0 (does not exist)
 %.B3   Channel 3 of SA 0 (does not exist)
%.A1   SA-10 #1 (does not exist)
		CONI, CONO, and DATAI for the entire second SA-10
 %.B4   Channel 0 of SA 1 (does not exist)
 %.B5   Channel 1 of SA 1 (does not exist)
 %.B6   Channel 2 of SA 1 (does not exist)
 %.B7   Channel 3 of SA 1 (does not exist)

~  ;End of COMMENT
SUBTTL	CONO and CONI bits

	SA0=274		;I/O device code for first SA-10  (300-317 in low core)
	SA1=400		;I/O device code for second SA-10 (320-337 in low core)

;SA-10 CONO bits

CLERSA==1B18	;400000 (FTASER) Reset the SA-10
CLRMER==1B19	;200000 (FTASER) Clear memory errors
;	77B25	;176000 unused?
;	1B26+1B30; 1040 Set clock on, no-op if already on
;	1B26+0B30; 1000 Stop clock, pulse it if already stopped
;	29-30 + 31-32   Set/Clear flags
;	7B29+1B30;  740 Enable interrupts from channel  (in bits 31&32)
;	7B29+0B30;  700 Disable interrupts from channel (in bits 31&32)
;	6B29+1B30;  640 Set attention flag for channel  (in bits 31&32)
;	6B29+0B30;  600 Dismiss interrupt from channel  (in bits 31&32)
;	5B29+1B30;  540 Set STATUS REQUEST for channel  (in bits 31&32)
;	5B29+0B30;  500 Clear STATUS REQUEST            (in bits 31&32)
;	4B29+1B30;  440 Set GO bit for channel          (in bits 31&32)
;	4B29+0B30;  400 Clear GO bit for channel        (in bits 31&32)
;	3B29	;   300 Reset channel                   (in bits 31&32)
;	2B29	;         ?
;	1B29	;         ?
;	0B29	;       NOOP, set up to return one of 6 words on next DATAI
;	   5B32	;    50     Return high order 2 bits of memory address
;	   4B32	;           ?
;	   3B32	;    30     Return RH of memory buffer
;	   2B32	;    20     Return LH memory buffer in 18-35, channel in 16-17
;	   1B32	;    10     Return 20 bits of memory address
;	   0B32	;           ?
;	3B32	;    30 Addresses the channel (0, 1, 2, or 3) if not NOOP
;	7B35	;     7 PI assignment

;SA-10 CONI bits

;	1B18	;400000 This SAX caused an interrupt (test for CONSO skip chain)
MEMERR==3B20	;300000 (FTASER)
;	1B19	;200000 PARITY error detected by channel
;	1B20	;100000 NXM error detected by channel
;	17B24	; 71000 Interrupt enable flags   (21=0,22=1,23=2,24=3)
;	17B28	;  3400 GO flags                 (25=0,26=1,27=2,28=3)
;	17B32	;   170 Attention (STATUS) flags (29=0,30=1,31=2,33=3)
;	7B35	;     7 PI assignment

;----------------------

;Error bits returned instead of CONI data

ERRCMR== 1B30	;(BPXKON) COMMAND REJECT
ERRBOP== 1B29	;(BPXKON) BUS OUT PARITY
ERRBIP== 1B28	;(BPXKON) BUS IN PARITY
ERRPRT== 1B27	;(BPXKON) PROTECTION (SET FILE MASK) FAILURE
ERRUNK== 1B26	;(BPXKON) UNKNOWN ERROR (NO BITS CHECK BUT UNIT CHECK)
ERROVR== 1B25	;(BPXKON) OVERRUN
ERRNXM== 1B24	;(BPXKON) NXM
ERRPAR== 1B23	;(BPXKON) PARITY ERROR
ERRSRC== 1B22	;(BPXKON) SEARCH ERROR (NO RECORD FOUND)
ERRINV== 1B21	;(BPXKON) INVALID TRACK FORMAT
ERRRCV== 1B20	;(BPXKON) RECOVERABLE DATA CHECK
ERRDTA== 1B19	;(BPXKON) UNRECOVERABLE DATA CHECK
ERRCNT== 1B18	;(BPXKON) COUNT ERROR (CHANNEL TERMINATION)
ERRBSY==(1B17)	;(BPXKON) BUSY
ERRATN==(1B16)	;(BPXKON) ATTENTION FLAG
ERRUXC==(1B15)	;(BPXKON) UNIT EXCEPTION
ERREQP==(1B14)	;(BPXKON) PERMANENT EQUIPMENT CHECK
ERREQC==(1B13)	;(BPXKON) EQUIPMENT CHECK
ERRLEN==(1B12)	;(BPXKON) LENGTH ERROR
ERRCON==(1B11)	;(BPXKON) CONTROL ERROR
ERRSEL==(1B10)	;(BPXKON) SELECT ERROR
ERRWPT==(1B9)	;(BPXKON) WRITE PROTECT ERROR (COMMAND REJECT ALSO ON)

;SA-10 ERROR BITS (first 8 bits of reported status)

ASYNCH==(1B0)	;(FTASER)
SELERR==(1B2)	;         SELECT ERROR
BUSERR==(1B3)	;         BUS IN PARITY ERROR
 BUSIN==(1B3)	;(FTASER)
CONERR==(1B4)	;(BPXKON) CONTROL ERROR
CNTLER==(1B4)	;(FTASER)
LENERR==(1B6)	;         LENGTH ERROR
PIFERR==(1B7)	;(PAKCOP) PROGRAM INTERUPT FLAG
PRGINT==(1B7)	;(FTASER)

;SA-10 REPORTED STATUS BITS

ATTEN== (1B8)	; (BOTH)  ATTENTION
ATTN==  (1B8)	;(FTASER) ATTENTION
STSMOD==(1B9)	; (BOTH)  STATUS MODIFIER
STAMOD==(1B9)	;(FTASER) STATUS MODIFIER
CUEND== (1B10)	;         CONTROL UNIT END
BUSY==  (1B11)	;         BUSY
CHNEND==(1B12)	;(PAKCOP) CHANNEL END
DEVEND==(1B13)	;         DEVICE END (COMES FROM PACK ON LINE)
UCHK==  (1B14)	; (BOTH)  UNIT CHECK
UNITCK==(1B14)	;(FTASER) UNIT CHECK
UXCP==  (1B15)	; (BOTH)  UNIT EXCEPTION
UNITEX==(1B15)	;(FTASER) UNIT EXCEPTION

;SA-10 CONTROL BITS  (first 8 bits of control word)

TIC==   (1B1)	;TRANSFER IN CHANNEL
NOMEMT==200	;NO MEMORY TRANSFER
TRBIT== 100	;TRANSFER BIT STREAM MODE (DISK AND 7-TRACK)
XCTCMD== 40	;EXECUTE COMMAND (HALT IF THIS BIT NOT SET)
CHAIN==  20	;CHAIN COMMAND
TRBYTE== 10	;TRANSFER BYTE MODE (INDUSTRY MODE, DISK AND TAPE)
INTRPT==  4	;INTERUPT
IGNLEN==  2	;IGNORE LENGTH ERROR
OFFSET==  1	;BYTE MODE OFFSET
TRWORD==  0	;TRANSFER WORD MODE
TRTAPE==110	;TRANSFER TAPE COMPATABILITY (9-TRACK DEC FORMAT)

;BYTMOD==TRBYTE+CHAIN+XCTCMD+IGNLEN	;(BPXKON)
 BYTMOD==TRBYTE+CHAIN+XCTCMD		;(PAKCOP) NORMAL FOR A BYTE MODE TRANSFER
 NOXFR== NOMEMT+XCTCMD+IGNLEN		;(BPXKON)
;STROFA==XCTCMD+CHAIN+TRBYTE+OFFSET+IGNLEN;(BPXKON)
 WRDMOD==TRBIT+XCTCMD+CHAIN		;NORMAL FOR A WORD MODE TRANSFER

	SAXBAS==300	;Base address for SA-10 (absolute address in low core)
	SA0BAS==SAXBAS+00 ;4 words per channel, 4 channels on SA10 #0
	SA1BAS==SAXBAS+20 ;4 words per channel, 4 channels on SA10 #1

;Format of a command

; BYTE (8) SAX.MODE, CCW.OPCODE, UNIT		;1st word (only 24 bits used)
; BYTE (12) -COUNT (24) ADDRESS.OF.BYTES	;2nd word (1B0 off for TIC)
;  (more pairs, or else TIC .-1)
; BYTE (8) 200					;End of command chain
SUBTTL	CCW-OP - Channel Command Word Operation codes

;Function codes (1st byte of CCW) for 3380 + 3330-11 or 3380-2 + 3350
;Same codes work for Memorex devices  3672 +  3675   or  3674  + 3650

  ;Command controls
;     ==  0	;X'00'          TEST I/O
;     == 20	;X'10'          .
;     ==  3	;X'03'          NO-OP
RECAL==  23	;X'13' (BPXKON) RECALIBRATE
SETSEC== 43	;X'23'  (BOTH)  SET SECTOR
SEEK==    7	;X'07'  (BOTH)  SEEK
;     == 27	;X'17'          RESTORE
SEEKCY== 13	;X'0B' (BPXKON) SEEK CYLINDER
;     == 33	;X'1B'          SEEK HEAD
;     == 17	;X'0F'          SPACE COUNT
SETFMK== 37	;X'1F' (PAKCOP) SET FILE MASK (FOR ALTERNATE TRACKS)

  ;Sense commands
SENSE==   4	;X'04'  (BOTH)  SENSE
;     == 24	;X'14'          UNCONDITIONAL RESERVE
;     ==224	;X'94'          DEVICE RELEASE
RRBL==  244	;X'A4' (BPXKON) READ AND RESET BUFFERED LOG
;     ==264	;X'B4'          DEVICE RESERVE
;     ==344	;X'E4'          SENSE I/O TYPE

  ;Write commands
;     ==  1	;X'01'          WRITE SPECIAL COUNT, KEY, DATA
BPXWT==   5	;X'05' (BPXKON) WRITE DATA
WRT33==   5	;X'05' (PAKCOP) WRITE DATA
;     == 15	;X'0D'          WRITE KEY AND DATA
;     == 21	;X'11'          ERASE
WRTR0==  25	;X'15' (PAKCOP) WRITE RECORD ZERO
WHOM==   31	;X'19' (PAKCOP) WRITE HOME ADDRESS
WCKD==   35	;X'1D' (PAKCOP) WRITE COUNT, KEY, DATA
;     ==135	;X'5D'          .

  ;Read commands
;     ==  2	;X'02'          READ IPL
BPXRD==   6	;X'06' (BPXKON) READ DATA
RED33==   6	;X'06' (PAKCOP) READ DATA
;     == 16	;X'0E'          READ KEY AND DATA
RCNT==   22	;X'12' (PAKCOP) READ COUNT
RDR0==   26	;X'16' (PAKCOP) READ RECORD ZERO
RHOM==   32	;X'1A' (PAKCOP) READ HOME ADDRESS
;     == 36	;X'1E'          READ COUNT, KEY, DATA
;     ==136	;X'5E'          READ MULTIPLE COUNT, KEY, DATA

  ;Multitrack read
;     ==202	;X'82'          .
;     ==206	;X'86'          READ DATA MULTITRACK
;     ==216	;X'8E'          READ KEY AND DATA MULTITRACK
;     ==222	;X'92'          READ COUNT MULTITRACK
;     ==226	;X'96'          READ RECORD ZERO MULTITRACK
;     ==232	;X'9A'          READ HOME ADDRESS MULTITRACK
;     ==236	;X'9E'          READ COUNT, KEY, DATA MULTITRACK
;     ==336	;X'DE'          .

  ;Search commands
;     == 51	;X'29'          SEARCH KEY EQUAL
;     ==251	;X'A9'          SEARCH KEY EQUAL MULTITRACK
SRCIDE== 61	;X'31'  (BOTH)  SEARCH ID EQUAL
;     ==261	;X'B1'          SEARCH ID EQUAL MULTITRACK
;     ==111	;X'49'          SEARCH KEY HIGH
;     ==311	;X'C9'          SEARCH KEY HIGH MULTITRACK
;     ==121	;X'51'          SEARCH ID HIGH
;     ==321	;X'D1'          SEARCH ID HIGH MULTITRACK
;     ==151	;X'69'          SEARCH KEY EQUAL OR HIGH
;     ==351	;X'E9'          SEARCH KEY EQUAL OR HIGH MULTITRACK
;     ==161	;X'71'          SEARCH ID EQUAL OR HIGH
;     ==361	;X'F1'          SEARCH ID EQUAL OR HIGH MULTITRACK

SRCHA==  71	;X'39'          SEARCH HOME ADDRESS EQUAL
;     ==271	;X'B9'          SEARCH HOME ADDRESS EQUAL MULTITRACK
SUBTTL	Sense bits returned (as a result of CCW opcode SENSE=4)

;	CMDREJ==400000	;(FTASER)
;	INTREQ==200000	;(FTASER)
;	BUSOUT==100000	;(FTASER)
;	EQPCHK==40000	;(FTASER)
;	DATCHK==20000	;(FTASER)
;	OVERUN==10000	;(FTASER)
;	CNVCHK==20000	;(FTASER)

SCMDRJ==(1B0)	;(PAKCOP) COMMAND REJECT
;	(1B1)	;         OFF-LINE (INTERVENTION REQUIRED)
;	(1B2)	;         BUS OUT PARITY ERROR
;	(1B3)	;         EQUIPMENT CHECK
;	(1B4)	;         DATA CHECK
;	(1B5)	;         PERMANENT OVERRUN
;	(1B6)	;         (3640 disks only) TRACK CONDITION CHECK
;	(1B7)	;         (3640 disks only) SEEK CHECK
;	(1B8)	;         PERMANENT ERROR, other bits should be on
;	(1B9)	;         INVALID TRACK FORMAT
;	(1B10)	;         END OF CYLINDER on multrack search
;	(1B11)	;         always zero
SNOREC==(1B12)	;(PAKCOP) NO RECORD FOUND
;	(1B13)	;         FILE PROTECTED
SNOWRT==(1B14)	;(PAKCOP) WRITE INHIBITED, COMMAND REJECT is also on
;	(1B15)	;         OPERATION INCOMPLETE, other bits should be on
;	(1B16)	;	(3640 disks only) RPS FEATURE
;	(1B17)	;	CORRECTABLE
;	(1B18)	;	ALTERNATE CONTROLLER SELECTED (3353/3354 or 3355/3356)
;	(1B19)	;	ENVIRONMENTAL DATA PRESENT
;	(1B20)	;	EMULATION MODE (335x disks only)
;	(1B21)	;	(3640 disks only) FIXED HEAD
;	(1B22)	;	(3640 disks only) DATA MODULE SIZE = 70 MB
;	(1B23)	;	(3640 disks only) DATA MODULE SIZE = 35 MB
  ;The remaining 21 bytes (24 bytes total) have varying interpretations
SUBTTL	Defintions from FTASER.MAC

REPEAT 0,<
;FORMAT OF SA-10 WORDS:

;    UNIT COMMAND LIST WORDS:

;        DEVICE COMMAND WORDS:

;            BITS	MEAN
;            0		1=NO MEMORY TRANSFER, 0=MEM TRANS.
;     	     1&4	00-WORD MODE
;            		01-BYTE MODE
;            		10-NATURAL MODE
;            		11-TAPE COMPATABILITY MODE
;            2		1=EXECUTE,0=HALT
;            3		CHAIN TO NEXT COMMAND
;            5		PROGRAM INTERRUPT
;            6		1=IGNORE LENGTH ERR,0=DON'T IGNORE
;            8-15	DEVICE COMMAND
;            16-23	DEVICE ADDRESS

;        DATA WORDS:

;            BITS	MEAN
;            0		1=THIS IS THE LAST DATA WORD IN THIS
;	    		GROUP, 0=NOT LAST.
;            1-11	2'S COMPLEMENT OF WORD/BYTE COUNT
;            14-35	1ST MEM ADDR, UNLESS 0 & WE ARE READING
;			FROM THE DEVICE, IN WHICH CASE MEANS
;			NO DATA TRANSFER.

;        TRANSFERS IN CHANNEL:

;            BITS	MEAN
;            0		MUST BE 0
;            1		MUST BE 1
;            14-35	ADDR OF NEXT COMMAND


;    BMX WORDS:

;	     BITS	MEAN
;	     0-7	DEVICE ADDRESS
;	     8-11	1101-START DEVICE
;	    		1110-WAITING ON DEVICE
;	    		1111-TERMINATED DEVICE
;	    		0000-END OF LIST
;	     14-35	ADDR OF DEVICE(UNIT) CMD LST
;FLAGS:

    ;FOR UNIT CMDS:

	NOMXFR==400000	;(FTASER)
	EXECUT==100000	;(FTASER)
	CMDCHN==40000	;(FTASER)
	FRCINT==10000	;(FTASER)
	IGNLEN==4000	;(FTASER)
	OFFSET==2000	;(FTASER)
	    CNEXNO==CMDCHN!EXECUT!NOMXFR

    ;FOR TRANSFERS IN CHANNEL:
	TIC==200000	;(FTASER)


    ;FOR DATA WORDS:
	LASDAT==400000	;(FTASER)


    ;FOR HALTS:
	HALT==400000	;(FTASER)


    ;FOR BMX WORDS:
	STRTDV==15	;(FTASER)
	TERMDV==17	;(FTASER)


    ;TO SET UP BMX MODE:
	BMX==400000	;(FTASER)

>  ;End of REPEAT 0 around FTASER definitions

;End of SAXPRM.MAC
SUBTTL	PAKCOP definitions
;TITLE	PAKCOP - Pack copy, format, etc for 3330's and 3350's
;  .LOAD /SAVE:PAKCOP SAXPRM.MAC+PAKCOP.MAC
IFNDEF SA0,<PRINTX ?Need to search SAXPRM for SA-10 definitions>

IFNDEF RECSIZ,<RECSIZ==^D128>
IFNDEF FT3350,<FT3350==0>
IFE FT3350,<IF2,<PRINTX [Building PAKCOPY for 3330 disks]>
  IFE RECSIZ-^D128,<TITLE PAKCOP - Pack copy, format, etc for 3330 in blocks>
  IFE RECSIZ-^D512,<TITLE PAKCP3 - Pack copy, format, etc for 3330 in pages>
>
IFN FT3350,<IF2,<PRINTX [Building PAKCOPY for new 3350 disks]>
  IFE RECSIZ-^D128,<TITLE PAKCPX - Pack copy, format, etc for 3350 blocks>
  IFE RECSIZ-^D512,<TITLE PAKCP5 - Pack copy, format, etc for 3350 pages>
>

;                  Table of Contents for PAKCOPY
;
;
;			   Section			      Page
;
;    1. CONO and CONI bits . . . . . . . . . . . . . . . . . .   2
;    2. CCW-OP - Channel Command Word Operation codes  . . . .   3
;    3. Sense bits returned (as a result of CCW opcode SENSE .   4
;    4. Defintions from FTASER.MAC . . . . . . . . . . . . . .   5
;    5. "DDT" - Go to DDT if it is loaded, else RESTART  . . .  10
;    6. "RESTART" - check status of all on-line packs  . . . .  15
;    7. "INIT" - Initialize HOME and BAT pages on one unit . .  21
;    8. "COPY" - Copy a set of packs . . . . . . . . . . . . .  22
;    9. "OLDC" - Old copy routine (1 pack at a time) . . . . .  38
;   10. "NEW" - Change unit ID on an existing home page  . . .  41
;   11. "STATUS" - List status of all on-line units  . . . . .  42
;   12. "AVERIFY" - Verify that alternate tracks are readabl .  42
;   13. "AFORMAT" - Verify that the alternaacks are for .  42
;   14. "LIST" - List map of bad spots from BAT page . . . . .  47
;   15. "ALIST" - List information about alternate track ass .  48
;   16. "DOIT" - HERE TO HANDLE A COMMAND WHICH REQUIRES VER .  50
;   17. "REFRESH" - Refresh alternate track assignments  . . .  51
;   18. "ASSIGN" - Assign one alternate track  . . . . . . . .  53
;   19. "DEASSIGN" - Deassign an alternate track . . . . . . .  57
;   20. "ERRMAK" - Make a bad alternate track (to test COPY  .  58
;   21. "FORMAT" - Rewrite COUNT-KEY-DATA on pack  . . . . . .  63
;   22. "VERIFY" - Verify that all pages can be read . . . . .  70
;   23. "SHH" - Quiets the bell  . . . . . . . . . . . . . . .  72
;   24. "SWITCH" - Print settings of the sense switches  . . .  72
;   25. "BOOTS" - Load BOOTS from disk pages 3,4,5 . . . . . .  73
;   26. TTY initialization (set KL10 flag if appropriate)  . .  77
;AC ASSIGNMENTS
P=17	;PDL
U=16	;UNIT
K=15	;KONTROLER
C=14	;CHANNEL
S=13	;SA-10
CH=12	;CHARACTER
DAT=11	;POINTER TO DATA AREA
CMD=10	;POINTER TO COMMAND AREA
CYL=7
HEAD=6
REC=5

;TEMPS
T1=1
T2=2
T3=3
T4=4
F==0

;UUO'S FOR OUTPUT

OPDEF ODEC [1B8]	;DECIMAL OUTPUT
OPDEF OOCT [2B8]	;OCTAL OUTPUT
OPDEF OCHR [3B8]	;CHARACTER OUTPUT
OPDEF OCHI [4B8]	;CHARACTER OUTPUT IMMEDIATE
OPDEF OASC [5B8]	;ASCIZ OUTPUT
OPDEF CRLF [6B8]	;CR-LF OUTPUT
OPDEF OSIX [7B8]	;OUTPUT SIXBIT

;UUO MAY DESTROY T1,T2,CH

	;FLAG BITS IN F

F.NBAT==1	;COPY - ABORT IF BAD AREAS IN BAT BLOCKS
F.NERR==2	;COPY - CONTINUE IF READ ERRS ON SOURCE
F.NALT==4	;COPY - ABORT IF READ OR WRITE ERRS ON DEST
F.BCOP==10	;BAD COPY
KL10==20	;KL10 cpu

BLKSIZ==^D<128>		;Words per block
PAGSIZ==^D<512>		;Words per page
RECSIZ==RECSIZ		;Number of PDP-10 words per record
RECPAG==PAGSIZ/RECSIZ	;Records per page, either 1 or 4
BYTSIZ==<^D36*RECSIZ>/8	;Number of 8-bit bytes in a record, 576 or 2304

IFE RECSIZ-BLKSIZ,<IF2,<PRINTX [Formatting in blocks]>>
IFE RECSIZ-PAGSIZ,<IF2,<PRINTX [Formatting in pages]>>

IFE FT3350,<    ;3330(3675) definitions
    HEADS=^D<19>	;Heads 0-18
    CYLS=^D<808>	;Cylinders 0-807
    ALTS=^D<815-808>	;7 maintenance cylinders, 808-814
    BYTES=^D<13030>	;Unformatted bytes per track
    GAP=^D<135>		;see OS/VS2 MVS Data Management Services Guide
    ;RECTRK=18 if formatted in blocks, =5 if formatted in pages (=20 blocks)
>  ;End 3330

IFN FT3350,<    ;3350(3650) definitions
    HEADS=^D<30>	;Heads 0-29
    CYLS=^D<555>	;Cylinders 0-554
    ALTS=^D<560-555>	;5 maintenance cylinders, 555-559
    BYTES=^D<19069>	;Unformatted bytes per track
    GAP=^D<185>		;see OS/VS2 MVS Data Management Services Guide
    ;RECTRK=7 if formatted in pages, =25 if formatted in blocks
>  ;End 3350

RECTRK==<BYTES+GAP>/<BYTSIZ+GAP> ;Records per track (18 or 5 or 7)
PAGCYL=<RECTRK*HEADS>/RECPAG	;Pages per cylinder (85, 95, or 210)
RECCYL=PAGCYL*RECPAG		;Blocks per cylinder must be multiple of 4
PAGES=PAGCYL*CYLS		;Total pages (68680, 76760, or 116550)

DEFINE PRINTD(A1,A2,B1,B2,C1,C2),<IF2,<PRINTX A1 A2 B1 B2 C1 C2>>

  RADIX 10
PRINTD (\RECSIZ,words per record =,\RECTRK,records per track &,\HEADS,heads)
PRINTD (\PAGCYL,pages per cylinder *,\CYLS,cylinders =,\PAGES,pages)
  RADIX 8

COPCML==HEADS*<RECTRK*<SIDZ.C+REDZ.C>+SEKZ.C>+1
COPDTL==SEKZ.D*RECTRK*HEADS
COPDL1==RECSIZ*HEADS*RECTRK
XTRREC==100			;Extra record for write check
;APR BITS
NXM==1B29
APRCLK==1B26

;TURN ON DISK PI'S

DSKON==1B28+1B25+1B32	;TURN ON PI, CHANNEL, CHANNEL 4

;UNIT STATUS BITS

NOWRT==(1B2)	;WRITE PROTECTED
NOFMT==(1B3)	;NOT FORMATTED
DRVUSD==(1B4)	;USED IN COPY PROGRAM
SNGDNS==(1B1)	;SINGLE DENSITY
;OFLIN==(1B0)	;OFF-LINE, HIGH ORDER BIT FOR SKIPL

RVFZ.C==RECPAG*<SEKZ.C+SIDZ.C+REDZ.C>+1
RVFZ.D==RECPAG*<SEKZ.D+REDZ.D>

FT1Z.C=<RECTRK+1>*WCKZ.C	;FORMAT 1 TRACK
FT1Z.D=<RECTRK+1>*WCKZ.D

AVFZ.C==SEKZ.C+RH0Z.C
AFMZ.C==MSKZ.C+SEKZ.C+WH0Z.C+1

FMTZ.C=HEADS*<FT1Z.C+SEKZ.C+SIDZ.C>+SECZ.C+1	;FORMAT CYL
FMTZ.D=HEADS*<FT1Z.D+SEKZ.D>
;KL10 DEFINITIONS

DTE==200	;DTE DEVICE CODE

DTEFLG=EBRADD+444	;DTE OPERATION DONE FLAG
DTEF11=EBRADD+450	;DATA FROM 11
DTECMD=EBRADD+451	;COMMAND TO 11
DTEMTD=EBRADD+455	;CTY OUTPUT DONE
DTEMTI=EBRADD+456	;CTY INPUT READY
CL11PT==1B26		;CLEAR DOORBELL
TO11DB==1B22		;DOORBELL
.DTESP==11B27		;ENTER SECONDARY PROTOCOL COMMAND
.DTCTO==10B27		;CTY OUTPUT CHAR
.DTRSW==3B27		;READ SWITCHES

;TIMER STUFF
TIM==20			;TIMER DEVICE CODE
TICK==^D1666		;SET INTERVAL FOR 1/60 SEC
TO.CIT==1B18		;CLEAR TIMER
TO.SIT==1B21		;START TIMER
TI.ITD==1B22		;TIMR DONE
TO.CTD==1B22		;CLEAR TIMER DONE


LG.LUB==1B2		;LOAD UBR

LP.NXM==1B25
LP.CSF==1B22
SUBTTL	Start of program is at location 1000 (DDT at 1001)

JOBVER=137
INTERNAL JOBVER

	LOC JOBVER
	20		;VERSION NUMBER

	LOC 0			;MAKE EBR AT PAGE 0.
				; (KL DOESN'T DO LUUOS TO EBR LIKE IT SHOULD, INSTEAD
				; IT DOES THEM TO VIRTUAL PAGE 0.)

UBRADD:
EBRADD:	BLOCK	1000		;SPACE FOR EPT IN CASE ITS A KL

EBR==EBRADD/1000
UBR==UBRADD/1000


START::	SKIPA	T1,JOBSYM##	;Start of program at location 1000
	 JRST	GODDT		;Start at 1001 to go to DDT or RESTRT
	MOVEM	T1,36
	MOVE	T1,[JSR UUOH]
	MOVEM	T1,EBRADD+41	;SET UP UUO HANDLER
	MOVE	T1,[UUOERR]
	MOVEM	T1,UBRADD+430	;UBR ALSO SET TO THIS.
	MOVEI	P,PDL-1
	PUSHJ	P,TTYINI	;Determine if KI CTY or KL with KLDCP console
	PUSHJ	P,ABTINI	;INITIALIZE ABORT
IFE FT3350,< OASC [ASCIZ /
230 AND 3330 PACK COPY AND FORMAT (230COP)
VERSION /] >
IFN FT3350,< OASC [ASCIZ /
3350 Pack copy and format program version /] >
	OOCT JOBVER
	OASC [ASCIZ /

Type date as MM-DD-YYYY /]
REDDAT:	PUSHJ P,REDLIN
	MOVEI T1,^D10
	MOVEM T1,RADIX	;SET INPUT RADIX
	PUSHJ P,SCAN
	CAIE T1,1
	JRST BADDAT	;MUST BE A NUMBER
	MOVE T1,ACCUM
	CAIG T1,^D12
	CAIGE T1,1
	JRST BADDAT
	MOVEM T1,MONTH
	PUSHJ P,SCAN
	CAIN T1,3
	PUSHJ P,SCAN	;ALLOW ONE SPECIAL CHR BETWEEN NUMBS
	CAIE T1,1
	JRST BADDAT
	MOVE T1,ACCUM
	CAIG T1,^D31
	CAIGE T1,1
	JRST BADDAT
	MOVEM T1,DAY
	PUSHJ P,SCAN
	CAIN T1,3
	PUSHJ P,SCAN
	CAIE T1,1
	JRST BADDAT
	MOVE T1,ACCUM
	CAIG T1,^D2008
	CAIGE T1,^D1974
	JRST BADDAT
	SUBI T1,^D1964
	MOVE T2,T1
	ANDI T2,3
	MOVE T3,T1
	IMULI T1,^D365
	ADDI T3,3
	LSH T3,-2
	ADD T1,T3	;NOW HAVE NUMBER OF DAYS TO START OF YEAR
	MOVE T3,MONTH
	ADD T1,MONTAB-1(T3)
	CAILE T3,2
	SKIPE T2	;IS IT A LEAP YEAR
	SKIPA
	ADDI T1,1	;LEAP YEAR AND MONTH LATER THAN FEB
	ADD T1,DAY	;NOW THE DAY
	SUBI T1,1
	MOVEM T1,THSDAT
	OASC [ASCIZ /
Type time as HHMM /]
REDTIM:	PUSHJ P,REDLIN
	PUSHJ P,SCAN
	CAIN T1,1	;MUST BE A NUMBER
	SKIPGE T1,ACCUM	;AND NOT NEGATIVE
	JRST BADTIM
	IDIVI T1,^D100	;DIVIDE INTO HOURS AND MINUTES
	CAIGE T2,^D60	;IF HOURS TOO BIG
	CAIL T1,^D24	;OR HOURS TOO BIG
	JRST BADTIM	;DON'T ACCEPT IT
	IMULI T1,^D60
	ADD T1,T2	;CONVERT WHOLE THING TO MINUTES
	HRLM T1,THSDAT
	SKIPE	DDT	;Is DDT loaded?
	 OASC	[ASCIZ /Loaded with DDT
/]
	JRST	RESTRT

BADTIM:	OASC [ASCIZ /
INCORRECT TIME, RETYPE /]
	JRST REDTIM
	DEFINE MSIZE
<X <31,28,31,30,31,30,31,31,30,31,30,31>>

	DEFINE X (A)
<%%Z==0
IRP A,<%%Z==%%Z+^D'A
	%%Z>>

MONTAB:	0
	MSIZE

BADDAT:	OASC [ASCIZ /
INCORRECT DATE, RETYPE /]
	JRST REDDAT

	DEFINE X(A)
<%%Z==0
IRP A,<%%Z==%%Z+^D'A
IFE ^D'A-^D28,<%%Z==%%Z+1>
	%%Z>>
MONTB2:	0	;FOR BACK CONVERSION
	MSIZE
SUBTTL	Control-Block definitions

SAXN==1		;NUMBER OF SA-10'S
 CH0N==2		;2 CHANNELS ON SA-10 0
  KN00==0	;NO KONTROLERS ON CHANNEL 0
  KN01==1	;1 ON SECOND
   BP0N==^D32	;32 UNITS
   BP0M==^D32	;OUT OF 32
   KN0==300

;NOW THE MACRO TO GENERATE CONTROL INFORMATION

%SAX==0	;SA-10 NUMBER
%CHN==0	;CHANNEL NUMBER
%KON==0	;KONTROLER NUMBER
%UNI==0	;UNIT NUMBER

	DEFINE CHNM(NUM)
<%.B'NUM>
	DEFINE KONM(NUM)
<%.C'NUM>
	DEFINE SXNM(NUM)
<%.A'NUM>
	DEFINE UNNM(NUM)
<%.D'NUM>
	DEFINE KDNM(NUM)
<KN'NUM>
	DEFINE KCNM(KNUM,CNUM)
<%'KNUM'.'CNUM>
	DEFINE INTNM(SAN)
<SA'SAN'INT>
	DEFINE UNITCB(UN)
<%.D'UN:
	PHASE 0
UNIIOW:!0
UNIBMX:!CHNM(\%CHN)+%CUN+CHNBMX
UNIKON:!KONM(\%KON)
UNISAX:!SXNM(\%SAX)
UNICHN:!CHNM(\%CHN)
UNISYS:!UNNM(\<%UNI+1>),,0
UNIRST:!0		;RESTART WORD FOR DEVICE
UNISTS:!0
UNINUM:!KDNM(\%KON)+%KUN
UNIERF:!0
UNICNT:!0
UNISAC:!BLOCK 20	;SAVE AC'S
UNIPDL:!BLOCK 40	;USE THIS FOR A PDL FOR THIS UNIT
UNIPC:!	0	;SAVE PC
UNIRDS:!BYTE (8) BYTMOD,SENSE,KDNM(\%KON)+%KUN
	BYTE (12)-^D24 (24) %.D'UN+UNISNS
	BYTE (8) 200
UNISNS:!BLOCK 6
	DEPHASE
%UNI==%UNI+1
%CUN==%CUN+1
%KUN==%KUN+1
>

	DEFINE KONCB(KNX)
<%KUN==0
	REPEAT BP'KNX'N,<UNITCB(\%UNI)>
%.C'KNX:
KCNM(\%KCUN,\%CHN)==.
	PHASE 0
KONRNG:!KN'KNX,,KN'KNX+BP'KNX'M
KONBSU:!0
KONRST:!0
KONKON:!KCNM(\<%KCUN+1>,\%CHN)
	%T==%UNI-%KUN
KONTAB:!REPEAT BP'KNX'N,<UNNM(\%T)
	%T==%T+1>
	REPEAT BP'KNX'M-BP'KNX'N,<0
	%CUN==%CUN+1>
	DEPHASE
%KCUN==%KCUN+1
%KON==%KON+1>

	DEFINE CHNCB(CN,SAN,CN1)
<%CUN==0
%KCUN==0
	REPEAT KN'SAN'CN,<KONCB(\%KON)>
IFN %CUN,<
%.B'CN1:
	PHASE 0
CHNIIE:!CONO SA'SAN,7B29+1B30+4+<CN>B32
CHNGO:!	CONO SA'SAN,4B29+1B30+4+<CN>B32
CHNCLR:!CONO SA'SAN,6B29+4+<CN>B32
CHNCHK:!CONSO SA'SAN,100_<-CN>
CHNSTS:!SAXBAS+SAN*20+CN*4+1
CHNKON:	KCNM(0,\CN1)
CHNBMX:!REPEAT %CUN,<-1>
	0
	DEPHASE
>
IFE %CUN,<%.B'CN=0>
KCNM(\%KCUN,\CN1)==0
%CHN==%CHN+1
>
	DEFINE SAXCB(SAN)
<	%TS==0
	REPEAT CH'SAN'N,<CHNCB (\%TS,\SAN,\%CHN)
	%TS==%TS+1>
SA'SAN'INT: CONSO SA'SAN,1B18	;IS THIS INTERUPT FOR THIS SA-10
	JRST INTNM(\<SAN+1>)	;ON TO NEXT CHANNEL
	JSR CHNSAV	;SAVE CHANNEL
	JSP S,SAXCOD
%.A'SAN:
	PHASE 0
SAXCNI:!CONI SA'SAN,T2
SAXCNO:!CONO SA'SAN,(T2)
SAXDTI:!DATAI SA'SAN,T2
	%TS==%CHN-CH'SAN'N
SAXCHN:!REPEAT CH'SAN'N,<CHNM(\%TS)
	%TS==%TS+1>
	REPEAT 4-CH'SAN'N,<0>
	DEPHASE
%SAX==%SAX+1
>

	REPEAT SAXN,<SAXCB(\%SAX)>

UNNM(\%UNI)==0
SUBTTL	"RESTART" - check status of all on-line packs

GODDT::	SKIPE	DDT	;Is DDT loaded?
	 JRST	GODDT1	;Yes
	OASC	[ASCIZ /?DDT not loaded
/]
	JRST	RESTRT

GODDT1:	OASC	[ASCIZ /Entering DDT, use RESTRT<ESC>G to continue
EDDT
/]
	JSP	T1,DDT	;Put return PC in T1
RESTRT::CONO APR,1B19	;RESET WORLD
	CONO APR,@CLRNXM
	CONO PI,1B23	;AND PI TO MAKE SURE
	MOVE T1,[JSR CHINT]
	MOVEM T1,EBRADD+50
	MOVEI P,PDL-1
	MOVEI T1,10
	MOVEM T1,RADIX	;RESET RADIX TO OCTAL
	MOVSI T1,-^D255
MEMLP:	MOVE T2,(T1)
	CONSZ APR,@NXMFLG
	JRST MEMFND
	ADDI T1,1777
	AOBJN T1,MEMLP
MEMFND:	HRRZM T1,MEMSIZ	;SET UPT MEMORY SIZE
	HLRZ T1,JOBSA##	;THIS IS LEFT HERE BY LOADER
	MOVEM T1,MEMLOW	;AND SAVE IT AS LOW MEMORY ADDRESS
	PUSHJ P,CLRIO	;RESET ALL I/O WAIT FLAGS
	HLRZ U,SYSUNI	;NOW RESET ALL DRIVE FLAGS
ONLCHK:	HRRZ K,UNIKON(U)
	HRRZ S,UNISAX(U)
	HRRZ C,UNICHN(U)
	XCT SAXCNI(S)	;READ CONI DATA
	JUMPE T2,SAXOFL	;SA-10 IS OFF LINE
	MOVE T1,[200000,RQZRO]
	MOVE T2,CHNSTS(C)
	MOVEM T1,-1(T2)	;SET POINTER TO A RANDOM COMMAND
	MOVEI T1,^D10000
	XCT CHNGO(C)	;AND START CHANNEL
	XCT CHNCHK(C)
	SOJG T1,.-1	;WAIT FOR RESPONSE FOR A WHILE
	JUMPLE T1,CHNOFL	;CHANNEL OFF LINE
	MOVEI T2,600000
	XCT SAXCNO(S)	;CLEAR SA-10
	MOVE T2,CHNSTS(C)
	MOVEI T1,CHNBMX(C)
	TLO T1,600000
	MOVEM T1,-1(T2)	;SET POINTER TO BLOCK MULTIPLEXOR LIST
	MOVE T1,UNINUM(U)
	DPB T1,[POINT 8,SEK0AD,23]
	MOVEI T1,SEK0AD
	CONO PI,DSKON	;TURN DISK ON
	PUSHJ P,STRTU
	CONO PI,1B23	;RESET PI'S
	SKIPN T1,UNIERF(U)
	JRST UNIONL
	TLNE T1,SELERR
	JRST KONOFL	;SELECT ERROR-KONTROLLER OFF-LINE
SAYOFL:	OASC [ASCIZ /
#U OFF-LINE/]
	SETOM UNISTS(U)	;ASSUME UNIT OFF-LINE
	CONO PI,1B23
NXTUNI:	HLRZ U,UNISYS(U)
NXTUN2:	JUMPN U,ONLCHK	;CHECK REST OF UNIT
NXTUN3:	PUSHJ P,ABTINI	;RESET ABORT LOCATION
	JRST CMDSET	;SET TO RECIEVE A COMMAND
UNIONL:	SETZM UNISTS(U)	;SET UNIT ON-LINE
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,WRTQ0,23]
	DPB T2,[POINT 8,WRTQ0+3,23]	;THE WRITE
	MOVEI T1,WRTQ0
	CONO PI,DSKON
	PUSHJ P,STRTU
	SKIPN T1,UNIERF(U)
	JRST TRY500	;SEE IF SINGLE OR DOUBLE DENSITY
	TLNN T1,UCHK
	JRST SAYOFL	;NOT UNIT CHECK, SAY OFF-LINE
	MOVE T1,UNISNS(U)	;GET SENSE BITS
	TLNE T1,SNOREC
	JRST NONFMT
	TLNN T1,SNOWRT	;DID IT SAY WRITE PROTECT?
	JRST SAYOFL	;STRANG CONDITION, SAY OFF-LINE
	MOVSI T1,NOWRT
	IORM T1,UNISTS(U)	;MARK WRITE PROTECT
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,REDQ0,23]	;NOW SET THE READ
	DPB T2,[POINT 8,REDQ0+3,23]
	MOVEI T1,REDQ0
	PUSHJ P,STRTU
	SKIPN T1,UNIERF(U)
	JRST TRY500	;MUST HAVE READ THE RECORD
	TLNN T1,UCHK
	JRST SAYOFL	;SOME FUNNY ERROR
	MOVE T1,UNISNS(U)
	TLNN T1,SNOREC
	JRST SAYOFL	;AGAIN A FUNNY ERROR
NONFMT:	MOVSI T1,NOFMT	;NOT FORMATTED
	IORM T1,UNISTS(U)
TRY500:	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,SEK500,23]
	MOVEI T1,SEK500
	PUSHJ P,STRTU
	CONO PI,1B23	;RESET
	SKIPN T1,UNIERF(U)
	JRST PRTONL	;PRINT THE ON-LINE MESSAGE
	TLNN T1,UCHK
	JRST SAYOFL	;FUNNY ERROR
	MOVE T1,UNISNS(U)
	TLNN T1,SCMDRJ	;SHOULD BE COMMAND REJECT
	JRST SAYOFL
	MOVSI T1,SNGDNS	;SIGLE DENSITY
	IORM T1,UNISTS(U)
PRTONL:	OASC [ASCIZ /
#U /]
	LDB T1,[POINT 3,UNISTS(U),3]
	OASC @ONLTAB(T1)
	JRST NXTUNI	;NEXT UNIT

ONLTAB:	[ASCIZ /ON-LINE, DUAL DENSITY/]
	[ASCIZ /ON-LINE, DUAL DENSITY, UNFORMATED/]
	[ASCIZ /ON-LINE, DUAL DENSITY, WRITE PROTECT/]
	[ASCIZ /ON-LINE, DUAL DENSITY, WRITE PROTECT, UNFORMATED/]
	[ASCIZ /ON-LINE/]
	[ASCIZ /ON-LINE, UNFORMATED/]
	[ASCIZ /ON-LINE, WRITE PROTECT/]
	[ASCIZ /ON-LINE, WRITE PROTECT, UNFORMATED/]

CHNOFL:	OASC [ASCIZ /
SA-10 CHANNEL OFF-LINE, UNITS /]
	MOVEI T2,600000
	XCT SAXCNO(S)	;RESET SA-10 IF CHANNEL OFF-LINE
CHNOF1:	PUSHJ P,PRTKON
	JUMPE U,NXTUN3	;FINISHED
	HRRZ T1,UNICHN(U)
	CAME T1,C
	JRST NXTUN2	;DIFFERENT CHANNEL
	OCHI ","
	JRST CHNOF1

KONOFL:	OASC [ASCIZ /
KONTROLER OFF-LINE, UNITS /]
	PUSHJ P,PRTKON
	JRST NXTUN2	;WILL GET TO CMDSET IF LAST UNIT
;CLEAR I/O WAIT FLAGS AND BLOCK MULTIPLEXOR LIST

CLRIO:	CONO PI,1B23
	SETZM DEVWAT	;NO DEVICES WAITING
	HLRZ U,SYSUNI
CLRIO1:	SETZM UNIIOW(U)
	MOVSI T2,DRVUSD
	ANDCAM T2,UNISTS(U)	;CLEAR DRIVE IN USE BIIT FRROM COPY
	SETOM @UNIBMX(U)
	SETOM UNIRST(U)	;ALSO THE RESTART WORD
	HRRZ K,UNIKON(U)
	SETZM KONBSU(K)
	HRRZ S,UNISAX(U)
	MOVEI T2,600000
	XCT SAXCNO(S)	;RESET SA-10
	HLRZ U,UNISYS(U)
	JUMPN U,CLRIO1
CPOPJ:	POPJ P,

SAXOFL:	OASC [ASCIZ /
SA-10 OFF-LINE, UNITS /]
SAXOF1:	PUSHJ P,PRTKON	;PRINT UNITS FOR THIS KONTROLER
	JUMPE U,NXTUN3	;FINISHED
	HRRZ T1,UNISAX(U)
	CAME T1,S
	JRST NXTUN2	;CONTINUE LOOKING, DIFFERENT SA-10
	OCHI ","
	JRST SAXOF1

PRTKON:	MOVE T3,UNINUM(U)
	HRRZ K,UNIKON(U)	;JUST IN CASE
	OOCT T3
PRTKN2:	MOVE T4,UNINUM(U)
	SETOM UNISTS(U)	;SAY UNIT IS OFF-LINE
	HLRZ U,UNISYS(U)
	JUMPE U,PRTKN1	;END OF UNIT LIST
	HRRZ T1,UNIKON(U)
	CAMN T1,K	;ARE THEY THE SAME?
	JRST PRTKN2	;YES, CONTINUE
PRTKN1:	CAMN T3,T4	;JUST A SINGLE UNIT?
	POPJ P,		;YES, NOTHING MORE TO PRINT
	OCHI "-"
	OOCT T4
	POPJ P,
SUBTTL	STRTU - Start up a unit transfer and wait till something done

STRTU:	POP P,UNIPC(U)	;SAVE RETURN ADDRESS
	MOVEM 17,UNISAC+17(U)	;SAVE AC'S
	MOVEI 17,UNISAC(U)
	BLT 17,UNISAC+16(U)
	MOVE 17,UNISAC+17(U)	;RESTORE SO ALL IN GOOD ORDER
	SETZM UNIERF(U)	;NO ERRORS
	SETOM UNIIOW(U)	;AND IN I/O WAIT
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,T1,7]	;SET UNIT
	TLO T1,(15B11)	;SET START ALSO
	MOVEM T1,UNIRST(U)
	MOVEM T1,@UNIBMX(U)	;SET IN BLOCK MULTIPLEX LIST
	AOS DEVWAT
	HRRZ C,UNICHN(U)
	XCT CHNIIE(C)	;ENABLE INTERUPT
	XCT CHNGO(C)	;AND START CHANNEL
WAIT:	JSP T1,TSTALT	;SEE IF HE WANTS TO ABORT
	HLRZ U,SYSUNI	;LLOK FOR UNITS THAT HAVE FINISHED
WAIT1:	SKIPLE UNIIOW(U)
	JRST WAITFN	;FOUNT ONE
	HLRZ U,UNISYS(U)	;NEXT UNIT
	JUMPN U,WAIT1
	SKIPE DEVWAT
	JRST WAIT
MAINGO:	MOVSI 17,SAVAC	;ALL DONE
	BLT 17,17	;RETURN
	POPJ P,

WAITFN:	SETZM UNIIOW(U)
	SOS DEVWAT
	MOVSI 17,UNISAC(U)
	BLT 17,17
	JRST @UNIPC(U)	;RESTART ROUTINE
SUBTTL	Command parser

GO::	MOVEI	P,PDL-1
CMDSET:	PUSHJ P,CLRIO
	MOVE T1,MEMLOW
	MOVEM T1,MEMFRE
	MOVEI T1,10
	MOVEM T1,RADIX
	SETOM BELFLG
	CONO PI,DSKON	;NOW WE HAVE THE WORLD RESET
CMDLP:	SETZM DOFLG	;CLEAR HELD COMMAND
;<
CMDLP1:	OASC [ASCIZ /

PAKCOP>/]
	SKIPE BELFLG	;THIS IS RESET BY THE SHH COMMAND
	PUSHJ P,BELWAT	;RING BELL EVERY 5 SECS UNTIL INPUT
	PUSHJ P,REDLIN
	PUSHJ P,SCAN	;GET SOMETHING FROM THE COMMAND LINE
	XCT CMDDSP(T1)	;DEPENDS ON WHAT WE SEE
BADCMD:	SETZM DOFLG	;CLEAR HELD COMMAND ON REAL ERROR
BADCD1:	OASC [ASCIZ /
TYPE HELP FOR LIST OF COMMANDS/]
	JRST CMDLP1

CMDDSP:	JRST CHKCMD	;ID IS 0, SEE WHAT COMMAND
	JFCL		;NUMBER NOT PERMITTED
	JRST CMDLP	;TERMINATION, JUST SAY * AGAIN
	JFCL		;SPECIAL CHARACTER NOT PERMITTED

CHKCMD:	MOVSI T2,770000
	MOVEI T3,0	;GET SET TO CREAT A MASK
	MOVE T1,ACCUM	;SET UP FOR THE SIXBIT OF THE ID
MAKMSK:	TDNN T1,T2
	JRST MSKDON	;FINISHED
	IOR T3,T2
	LSH T2,-6
	JUMPN T2,MAKMSK
MSKDON:	MOVSI T4,-CMDLEN	;TABLE LENGTH
	MOVEI U,0	;SAVE DISPATCH POINTER
CMDCHK:	CAMN T1,CMDNAM(T4)
	JRST @CMDGO(T4)	;EXACT MATCH, GO
	MOVE T2,CMDNAM(T4)
	AND T2,T3
	CAME T1,T2
	JRST NXTCMD
	JUMPN U,BADCMD	;MATCH ON WHAT WE HAVE, ANOTHER SEEN?
	MOVE U,T4	;NO, REMEMBER IT
NXTCMD:	AOBJN T4,CMDCHK
	JUMPE U,BADCMD	;NOTHING MATCHED, BAD COMMAND
	JRST @CMDGO(U)	;DISPATCH
;HERE ARE THE COMMAND DISPATCH TABLES

	DEFINE NAMES
<	X RESTART,RESTRT
	X DDT,GODDT
	X DOIT,DOITCM
	X COPY,PAKCOP
	X REFRESH,REFACMD
	X NEW,NEWID
	X ASSIGN,ASSCMD
	X DEASSIGN,DEACMD
	X ERRMAK,ERRCMD
	X INIT,HINIT
	X STATUS,STSCMD
	X LIST,MAPLST
	X BOOTS,LOAD
	X LOAD,LOAD
	X OLDC,OLDCOP
	X ALIST,ALTLST
	X SHH,QUIET
	X VERIFY,VERCMD
	X HELP,HELP
	X FORMAT,FORMAT
	X AFORMAT,AFMCMD
	X AVERIFY,AVRCMD
	X SWITCHES,PRTSWS
>

	DEFINE X(A,B)
<	<SIXBIT /A/>>

CMDNAM:	NAMES
CMDLEN==.-CMDNAM

	DEFINE X(A,B)
<	B>

CMDGO:	NAMES

HELP:	OASC HLPMSG
	JRST CMDLP

HLPMSG:	ASCIZ /
COMMANDS ARE:

HELP      PRINT THIS MESSAGE

BOOTS     LOAD BOOTS FROM THE DISK IF IT IS THERE

SHH       STOP RINGING THE BELL AND WAIT FOR MORE COMMANDS

RESTART   RESTART THE PROGRAM AND RECHECK DRIVE STATES

FORMAT    FORMAT A PACK OR PACKS

VERIFY    CHECK FORMATTING ON A PACK OR PACKS

AVERIFY   CHECK FORMATTING OF ALTERNATE TRACKS ON A PACK OR PACKS

AFORMAT   CHECK AND CORRECT IF NECESSARY THE ALTERNATE TRACK
              FORMATTING ON A PACK OR PACKS. ALSO RUNS AVERIFY.

ALIST     LIST INFORMATION ABOUT ALTERNATE TRACKS ON A PACK OR
              PACKS

LIST      LIST INFORMATION FROM THE HOME AND BAT BLOCKS ON A PACK
              OR PACKS

STATUS    LIST THE STATUS (WRITE PROTECTED, ETC.) OF ALL DRIVES
              ON-LINE

INIT      CLEAR THE BAT BLOCKS AND GENERATE A FRESH HOME BLOCK ON A PACK.
              INTENDED FOR PACKS THAT HAVE BEEN FORMATTED BUT DO NOT
              HAVE AN ID.

NEW       CHANGE THE ID ON A PACK

SWITCHES  PRINT A LIST OF SENSE SWITCH MEANINGS FOR THE COPY COMMAND

COPY      DO A SET OF PACK COPIES. TAKES A SET OF SOURCE AND
              DESTINATION PACKS

REFRESH   REFORMATS TRACKS ASSIGNED ALTERNATES & MARKS GOOD

    *********************************************
    *   THE COMMANDS BELOW ARE NOT TO BE USED   *
    *   WITHOUT SUPERVISOR AUTHORIZATION!!!     *
    *********************************************

ASSIGN    SPECIFY PARTICULAR ALTERNATE TRACK ASSIGNMENTS

DEASSIGN  REMOVE PARTICULAR ALTERNATE TRACK ASSIGNMENTS

ERRMAK    GENERATE ALTERNATE TRACK ASSIGNMENTS WITH ERRORS

OLDC      OLD COPY ROUTINE THAT DOES NOT USE BLOCK MULTIPLEXING

DDT       GO TO DDT
/
SUBTTL	"INIT" - Initialize HOME and BAT pages on one unit

HINIT:	PUSHJ P,ONEUNT	;INIT HOME AND BAT BLOCKS
	HRRZ CMD,MEMFRE
	MOVEI DAT,RVFZ.C(CMD)
	HRLS DAT
	HRLS CMD
	HRROI K,HOMPTR	;DON'T TELL ABOUT CONSISTANCY ERR
	PUSHJ P,REDVER
	 JRST DOINIT	;HOME BLOCKS BAD, INIT
	OASC [ASCIZ /UNIT ALREADY HAS HOME BLOCKS, OVERWRITE? /]
	PUSHJ P,REDLIN
	PUSHJ P,YESNO
	 JRST CMDSET	;HE SAID NO
DOINIT:	HLRS DAT
	MOVE T1,DAT
	ADDI T1,1
	SETZM (DAT)
	BLT T1,777(DAT)	;ZERO OUT BLOCK
	MOVEI K,BATPTR
	MOVE T1,[-BRMAX,,BATREG]
	MOVEM T1,BATFIR(DAT)	;IS IS ALL THAT IS INITIALIZED
	PUSHJ P,WRTVER
	 JRST CMDSET	;ERROR, WRTVER TOLD US
	HLRS DAT
	MOVE T1,DAT
	ADDI T1,1
	SETZM (DAT)
	BLT T1,777(DAT)
	MOVEI K,HOMPTR
	SETOM HOMSRC(DAT)
	SETOM HOMSUN(DAT)
;	MOVE T1,(K)	;GET THE HOME BLOCK ADDRESSES
;	MOVEM T1,HOMHOM(DAT)
HOMGID:	OASC [ASCIZ /ID: /]
	PUSHJ P,REDLIN
	PUSHJ P,SCNID
	JUMPN T1,HOMGID	;NOT A REAL ID, TRY AGAIN
	MOVE T1,ACCUM
	MOVEM T1,HOMHID(DAT)
	PUSHJ P,WRTVER	;WRITE IT OUT
	 JFCL
	JRST CMDSET	;AND FINISH UP
SUBTTL	"COPY" - Copy a set of packs

;THESE ARE MESSAGES FOR HOW PAKCOPY OPERATED DEPENDING ON
;SETTINGS OF SENSE SWITCHES

MDOBAT:	ASCIZ /ALTERNATE TRACKS WILL BE ASSIGNED FOR BLOCKS
INDICATED BAD IN BAT BLOCKS (SENSE SWITCH 1 [40] OFF)
/
MNOBAT:	ASCIZ /COPY WILL ABORT IF ANY BAD REGIONS ARE
INDICATED IN THE BAT BLOCKS (SENSE SWITCH 1 [40] ON)
/
MNOERR:	ASCIZ /COPY WILL ABORT ON READ ERRORS FROM SOURCE PACK
FOR BLOCKS NOT MARKED BAD (SENSE SWITCH 2 [20] OFF)
/
MDOERR:	ASCIZ /READ ERRORS FROM SOURCE PACK WILL BE REPORTED BUT
COPY WILL CONTINUE (SENSE SWITCH 2 [20] ON)
/
MDOALT:	ASCIZ /ALTERNATE TRACKS WILL BE ASSIGNED FOR BLOCKS
WITH READ OR WRITE ERRORS ON DESTINATION PACK (SENSE SWITCH 3 [10] OFF)
/
MNOALT:	ASCIZ /COPY WILL ABORT ON READ OR WRITE ERRORS ON
DESTINATION PACK (SENSE SWITCH 3 [10] ON)
/

PAKCOP:	TRZ F,F.NBAT!F.NERR!F.NALT
	TLNN F,KL10
	JRST PAKCKI

PAKCKL:	MOVEI T1,.DTRSW		;GET SWITCH SETTINGS
	MOVEM T1,DTECMD
	SETZM DTEFLG
	CONO DTE,TO11DB
	SKIPN DTEFLG
	JRST .-1
	MOVE T1,DTEF11
	TRNE T1,40
	TRO F,F.NBAT
	TRNE T1,20
	TRO F,F.NERR
	TRNE T1,10
	TRO F,F.NALT
	JRST PAKCKX

PAKCKI:	CONI APR,T1		;GET SENSE SWITCH SETTINGS
	TLNE T1,(1B12)
	TRO F,F.NBAT
	TLNE T1,(1B13)
	TRO F,F.NERR
	TLNE T1,(1B14)
	TRO F,F.NALT
PAKCKX:	TRNE F,F.NBAT
	OASC MNOBAT
	TRNE F,F.NERR
	OASC MDOERR
	TRNE F,F.NALT
	OASC MNOALT	;NOW HAVE REPORTED ON STATE
	OASC [ASCIZ /
SOURCE DRIVES: /]
	PUSHJ P,REDDV1	;READ A LIST OF SOURCE DRIVES
	SETZM SPCLNK	;HERE IS A LIST POINTER TO THE WAITERS
CPYDRV:	PUSHJ P,@DRVDSP	;GET A SOURCE DRIVE NUMBER
	 JRST CPYLP0	;WE ARE ALL SET UP, GET STARTED
	MOVE T1,UNISTS(U)
	TLNE T1,NOFMT
	JRST SRCNFT	;SOURCE PACK NOT FORMATTED
	TLNN T1,NOWRT
	JRST SRCWRT	;SOURCE PACK IS WRITABLE
	MOVS T1,U
	PUSH P,T1
	OASC [ASCIZ /COPY FROM #U TO: /]
	PUSHJ P,ONEUN1	;GET THE DESTINATION DRIVE
	HRRM U,(P)
	POP P,U
	MOVE T1,UNISTS(U)
	TLNE T1,NOFMT
	JRST DSTNFT	;DESTINATION DRIVE IS NOT FORMATTED
	TLNE T1,NOWRT
	JRST DSTNWT	;DESTINATION DRIVE IS WRITE PROTECTED
	TLOE T1,DRVUSD
	JRST DSTUSD	;DESTINATION DRIVE IN USE BY A COPY
	MOVEM T1,UNISTS(U)	;MARK USED
	MOVS T2,U
	XOR T1,UNISTS(T2)
	TLNE T1,SNGDNS
	JRST WRGDNS	;DRIVES NOT OF THE SAME DENSITY
	HRRZ DAT,MEMFRE	;GET A PLACE TO PUT THINGS
	MOVEI CMD,3000+RVFZ.D(DAT)	;ENOUGH ROOM FOR 2 HOME AND 2 BAT BLOCKS
	HRLS DAT
	HRLS CMD
	MOVSS U	;GET INFO FROM SOURCE DRIVE
	MOVEI K,HOMPTR
	PUSHJ P,REDVER
	 JRST CPYABT	;ABORT THE COPY
	ADD DAT,[1000,,0]
	MOVEI K,BATPTR
	PUSHJ P,REDVER
	 JRST CPYABT	;BAD BAT BLOCKS, ALSO ABORT
	MOVSS U
	MOVEI K,HOMPTR
	ADD DAT,[1000,,0]
	PUSHJ P,REDVER
	 JRST CPYABS	;ABORT BUT U IS SWAPPED
	MOVEI K,BATPTR
	ADD DAT,[1000,,0]
	PUSHJ P,REDVER
	 JRST CPYABS
	HLRZS DAT
	SUBI DAT,3000	;NOW HAVE DAT POINTED BACK TO START
	TRZ F,F.BCOP	;COPY NOT BAD YET
	MOVS T1,HOMCOP(DAT)	;INTERCHANGE HALVES SO DATE IN TOP
	MOVS T4,HOMCOP+2000(DAT)	;COMPARE DATES
	CAML T1,T4
	JRST COPOK1	;OK IN THIS RESPECT
	OASC [ASCIZ /DESTINATION COPY DATE LATER THAN SOURCE COPY DATE
/]
	TRO F,F.BCOP
COPOK1:	MOVE T4,HOMHID(DAT)
	XOR T4,HOMHID+2000(DAT)
	TLNN T4,777700
	JRST COPOK2
	OASC [ASCIZ /SOURCE AND DESTINATION SYSTEM NUMBERS DIFFER
/]
	TRO F,F.BCOP
COPOK2:	TRNN T4,7777
	JRST COPOK3
	OASC [ASCIZ /SOURCE AND DESTINATION UNIT NUMBERS DIFFER
/]
	TRO F,F.BCOP
COPOK3:	TDNE T4,[77,,770000]
	JRST COPOK4
	OASC [ASCIZ /SOURCE AND DESTINATION SET NUMBERS ARE THE SAME
/]
	JRST CPYABS	;WE DEFINATELY ABORT HERE
COPOK4:	TRNE F,F.BCOP	;EVERYTHING OK?
	JRST CPYABS	;NO, ABORT
	OASC [ASCIZ /
COPY FROM /]
	OSIX HOMHID(DAT)
	OASC [ASCIZ / (/]
	MOVE T1,HOMCOP(DAT)	;PRINT COPY DATE ALSO
	PUSHJ P,PRDATZ
	OASC [ASCIZ /) TO /]
	OSIX HOMHID+2000(DAT)
	OASC [ASCIZ / (/]
	MOVE T1,HOMCOP+2000(DAT)	;PRINT COPY DATE ALSO
	PUSHJ P,PRDATZ
	OASC [ASCIZ /)
OK? /]
	PUSHJ P,REDLIN
	PUSHJ P,YESNO
	 JRST CPYABS	;ABORT THE COPY
	MOVEI T4,3000(DAT)	;POINT TO THE BAT BLOCK
	ADD T4,BATFIR(T4)
BATSR1:	SKIPN (T4)	;SORT THE BLOCK. ANY DATA LEFT?
	JRST BATSRD	;NO, DONE
	MOVE T3,T4	;GET POINTER FOR THIS PASS
	MOVE K,T4	;REMEMBER POINTER TO SMALLEST BLOCK
	MOVE T1,BATELB(T4)	;AND THE BLOCK NUMBER
BATSR3:	AOBJP T3,BATSR2	;OUT OF POINTER, END OF PASS
	AOBJP T3,BATSR2
	SKIPN (T3)
	JRST BATSR2	;END OF BLOCK
	MOVE T2,BATELB(T3)
	CAML T2,T1	;IS THIS ONE SMALLER?
	JRST BATSR3	;NO
	MOVE T1,T2	;YES, SAVE IT
	MOVE K,T3	;AND THE POINTER
	JRST BATSR3	;AND CONTINUE
BATSR2:	CAMN K,T4	;IS THE SMALLEST ALREADY FIRST?
	JRST BATSR4	;YES, JUST START ANOTHER PASS
	DMOVE T1,(K)
	EXCH T1,(T4)	;EXCHANGE SMALLEST AND FIRST
	EXCH T2,1(T4)
	DMOVEM T1,(K)
BATSR4:	AOBJP T4,BATSRD	;IF WE RUN OUT OF POINTER, WE ARE DONE
	AOBJN T4,BATSR1
			;ALL INTO BATSRD
BATSRD:	MOVEI T4,3000(DAT)
	ADD T4,BATFIR(T4)	;SET UP POINTER AGAIN
	MOVEI CMD,4000(DAT)
	HRLS CMD
	MOVEI DAT,AFMZ.C+FT1Z.C(CMD)	;FOR ROOM TO ASSIGN ALT
	HRLS DAT	;A PLACE WE CAN READ FROM
	MOVNI T1,1	;DO NOT WORRY ABOUT SMALLER THAN THIS
	PUSH P,T1	;SAVE SAMLLEST TO WORRY ABOUT-1 AND
	PUSH P,T4	;POINTER
BATCK1:	MOVE T4,(P)
BATCK0:	SKIPN (T4)	;ARE WE OUT OF DATA
	JRST BATCKD	;YES
IFN <RECPAG-1>,<MOVEI T1,RECPAG
	HRRM T1,BATNBB(T4)	;STORE BLOCK/PAGE COUNT IN RH. OB NBB
	IMULM T1,BATELB(T4)>
BATCK8:	MOVE T1,BATELB(T4)
	CAMG T1,-1(P)
	JRST BATCK2	;DO NOT LOOK AT THIS BLOCK
	PUSHJ P,TRANS	;TRANSLATE INTO CYL, HEAD, RECORD
	MOVSI T4,-DATLEN	;GET SET TO TEST IT
BATCK3:	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSKF
	PUSHJ P,GENSID
	PUSHJ P,GENWRT
	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	HRL T1,DAT
	HRRI T1,1(DAT)	;SET DATA TO WRITE
	MOVE T2,DATTAB(T4)
	MOVEM T2,(DAT)
	BLT T1,RECSIZ-1(DAT)
	MOVNI T3,1	;NOW DO THE READ
BATCE1:	HLRZ T1,CMD	;THIS IS THE RETRY POINT
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST BATGE1	;GOT AN ERROR, EXAMINE IT
	HLRS DAT
	HLRS CMD	;WROTE WITHOUT ERROR
	PUSHJ P,GENSKF
	PUSHJ P,GENSID
	PUSHJ P,GENRED	;NOW READ IT BACK
	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	MOVNI T3,1
BATCE2:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST BATGE2
	MOVE T2,DATTAB(T4)	;NOW CHECK DATA
	HRRZ T1,DAT
	HRLI T1,-RECSIZ
	CAME T2,(T1)
	JRST BATAL1	;DATA IS WRONG BUT NOT ERR, SET ALT
	AOBJN T1,.-2
	AOBJN T4,BATCK3		;ALL DATA CORRECT, NEXT PATTERN
BATCK2:	MOVE T4,(P)	;TRY ANOTHER BLOCK
	AOS BATELB(T4)
IFN <RECPAG-1>,<HRRZ T1,BATNBB(T4)
	SOJLE T1,.+3
	HRRM T1,BATNBB(T4)
	JRST BATCK8
	MOVEI T1,RECPAG
	HRRM T1,BATNBB(T4)>
	LDB T1,[POINT BASNBB,BATNBB(T4),BANNBB]	;NUMBER-1
	SOJL T1,BATCK4	;DEC, IF NEG, FINISHED THIS PTR
	DPB T1,[POINT BASNBB,BATNBB(T4),BANNBB]	;RESTORE IT
	JRST BATCK8	;AND TRY NEXT BLOCK
BATCK4:	AOBJP T4,BATCKD
	AOBJP T4,BATCKD	;POSSIBLY OUT OF DATA
	MOVEM T4,(P)	;NO, RESTORE SAVED COPY
	JRST BATCK0	;AND GO

BATCKD:	POP P,T1
	POP P,T1	;CLEAR STACK
	HLRS CMD
	MOVEI DAT,-4000(CMD)	;RESET DAT
	MOVE T1,HOMHID+2000(DAT)	;DEST ID
	MOVEM T1,HOMHID(DAT)	;TO COPY OF SOURCE HOME BLOCK
	MOVEI T1,2000(DAT)	;SAVE HOME AND BAT BLOCK COPIES
	MOVEM T1,MEMFRE
	MOVE T4,SPCLNK		;REMEMBER FOR WHEN WE RESTART
	HRRZM U,SPCLNK
	PUSHJ P,QUEUNT
	 JRST PAKDO		;HERE IS WHERE WE START
	SOS DEVWAT	;RESET WHAT QUE DID
	SETZM UNIIOW(U)	;FOR NOT
	JRST CPYDRV	;AND GET NEXT DRIVE

DATTAB:	0
	-1
	525252525252
	252525252525
DATLEN==.-DATTAB
;ERROR ON TESTING A BLOCK MARKED BAD

BATGE1:	PUSHJ P,COMERR	;IN CASE RECOVERABLE
	 JRST BATCE1	;YES
	JRST BATALT	;NEED ALTERNATE BLOCK

BATGE2:	PUSHJ P,COMERR
	 JRST BATCE2
BATALT:	MOVE T2,UNIERF(U)
	TLNN T2,UCHK
	JRST BATALB	;PROBABLY HARDWARE, ABORT
	MOVSI T2,(1B4!1B12)	;DATA AND NO RECORD
	TDNN T2,UNISNS(U)
	JRST BATALB	;NO, HARDWARE, ABORT
BATAL1:	TRNE F,F.NBAT
	JRST BATABT	;HE SAID NOT TO ASSIGN ALTERNATES, ABORT
	PUSHJ P,GETALT
	 JRST CPYABT	;CAN NOT ASSIGN ALTERNATE, ABORT
	MOVEI REC,RECTRK	;NUMBER IN THIS TRACK
	PUSHJ P,BAKTRN	;DO A BACK TRANSLATION
	MOVEM T1,-1(P)	;TO TOP REC OF TRACK, DO NOT REASSIGN TRACK
	JRST BATCK2	;CHECK NEXT BLOCK

BATALB:	PUSH P,T1
	OASC [ASCIZ /
PROBABLE HARDWARE ERROR ON DESTINATION PACK
/]
BATAB1:	POP P,T1
	PUSHJ P,COMERP
	JRST CPYABS

BATABT:	OASC [ASCIZ /
BAD BLOCK ON DESTINATION PACK AT CYL #C HEAD #H REC #R
/]
	JRST CPYABS

;TRANSLATE CYL,HEAD, REC TO LOGICAL BLOCK

BAKTRN:	HRRZ T1,HEAD
	IMULI T1,RECTRK
	ADDI T1,-1(REC)
	CAIL T1,RECCYL
	MOVEI T1,RECCYL-1	;IN CASE IT GOES ACROSS CYL
	HRRZ T2,CYL
	IMULI T2,RECCYL
	ADD T1,T2
	POPJ P,
;NOW REALLY START IT

CPYLP0:	SKIPN U,SPCLNK	;IS THERE SOMEONE WAITING?
	JRST CMDSET	;NO, FINISHED
	AOS UNIIOW(U)	;SET HIM TO START
	AOS DEVWAT	;1 MORE WAITER
	HLRZM U,UNISAC+CMD(U)	;STORE SPACE
	PUSHJ P,ALLWAT
	JRST CPYLP0	;MAKE SURE ALL GET FINISHED

;For 3330, read heads 0-4, 5-9, 10-14, 15-18 (only 4 tracks on last one)
 DOTRK==5				;NUMBER OF TRACKS TO DO AT ONE TIME
 NUMCOP==<HEADS+DOTRK-1>/DOTRK		;NUMBER OF READS PER CYL (4 for 3330)
 REMTRK==HEADS-<DOTRK*<NUMCOP-1>>	;NUMBER OF TRACK IN 'ODD' READ

CDAT.Z==DOTRK*RECTRK*RECSIZ	;DATA AREA NEEDED FOR A READ (DATA FROM DISK)
CPYZ.D==DOTRK*SEKZ.D*RECTRK+SECZ.D	;DATA SPACE FOR COMMANDS
CPYZ.C==DOTRK*<SEKZ.C+RECTRK*<SIDZ.C+REDZ.C>>+SECZ.C+1	;COMMAND SPACE

PAKDO:	JUMPN CMD,PAKDO1	;DO THIS IF WE HAVE SPACE
	MOVEI T1,CDAT.Z*2+CPYZ.D+CPYZ.C	;SPACE NEEDED
	ADD T1,MEMFRE
	CAML T1,MEMSIZ
	JRST WAIT	;NOT ENOUGH (WILL GET HERE AGAIN)
	HRRZ CMD,MEMFRE	;GOT IT, SET UP
	MOVEM T1,MEMFRE
PAKDO1:	HRRZM T4,SPCLNK	;NEXT ONE IN LINE
	JUMPE T4,PAKDO2	;IS THERE SOMEONE?
	AOS UNIIOW(T4)
	AOS DEVWAT	;MAKE SURE HE GETS STARTED
	SETZM UNISAC+CMD(T4)
PAKDO2:	HRLS CMD
	PUSH P,DAT	;THIS POINTS TO THE HOME AND BAT BLOCKS
	MOVEI DAT,CPYZ.C(CMD)
	HRLS DAT
	MOVSI CYL,-CYLS/2	;3330-1 (100 megabytes = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVSI CYL,-CYLS
	MOVSS U		;FROM THE SOURCE UNIT
PAKCYL:	MOVSI T1,-NUMCOP	;HERE FOR EACH CYLINDER
PAKRED:	PUSH P,T1	;SAVE THAT ALSO (HEAD NUMBER IN RH)
	PUSHJ P,SETCOP	;SET UP FOR A COPY
	MOVEI T3,GENRED	;WANT TO READ
	PUSHJ P,TRNSET	;SET UP THE TRANSFER
	MOVNI T3,1
PAKRT1:	HLRZ T1,CMD
	PUSHJ P,STRTU	;GO
	SKIPE T1,UNIERF(U)
	JRST PAKER1	;ERROR ON READ FROM SOURCE
;NOW NEED TO DO SOMETHING SPECIAL FOR HOM AND BAT IF HERE

	PUSHJ P,SETCOP	;SET TRANSFER PARAMETERS
	MOVSI T3,-NUMSPR	;THE NUMBER OF SPECIAL RECORDS
	HLRO T1,HEAD
	SETCA T1,
	ADDI T1,(HEAD)	;THIS IS THE MAX THE HEAD GET THIS TIME
	IMULI T1,RECTRK
	ADDI T1,RECTRK-1	;MAX RECORD NUMBER IN CYL
	CAIL T1,RECCYL	;DO NOT LET IT GET TOO BIG
	MOVEI T1,RECCYL-1
	PUSH P,T1
	HRRZ T1,HEAD
	IMULI T1,RECTRK
	PUSH P,T1	;FIRST RECORD ON CYL
	HRRZ T1,CYL
	IMULI T1,RECCYL
	ADDM T1,(P)
	ADDM T1,-1(P)	;NOW HAVE RECS IN THIS TRANS
SPRCHK:	HRRZ T1,SPCRTB(T3)	;GET A RECORD NUMBER
	CAMG T1,-1(P)	;IF SMALLER THAN BIGEST
	CAMGE T1,(P)	;AND BIGGER THAN SMALLEST (OR EQUAL)
	JRST NXTSPR	;NO, TRY NEXT
	SUB T1,(P)	;FIND OFFSET
	IMULI T1,RECSIZ
	ADD T1,T4	;HERE IS THE RECORD
	HLRZ T2,SPCRTB(T3)
	PUSHJ P,(T2)	;DO SPECIAL ROUTINE
NXTSPR:	AOBJN T3,SPRCHK
	POP P,T1	;CLEAR STACK
	POP P,T1
	MOVEI T3,GENWRT
	MOVSS U
	PUSHJ P,TRNSET
	MOVNI T3,1	;NOW WRITE IT
PAKRT2:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST PAKER2	;ERROR WRITING
	PUSHJ P,SETCOP	;NOW READ BACK
	MOVEI T3,GENRED
	ADDI T4,CDAT.Z	;TO DIFFERENT PLACE
	PUSHJ P,TRNSET
	MOVNI T3,1
PAKRT3:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST PAKER3	;ERROR REREADING
	PUSHJ P,SETCOP	;NOW NEED TO COMPARE DATA
	HLRO T1,HEAD
	MOVNS T1
	ADDI T1,(HEAD)
	IMULI T1,RECTRK
	CAILE T1,RECCYL
	MOVEI T1,RECCYL
	HRRZ T2,HEAD
	IMULI T2,RECTRK
	SUB T1,T2	;NOW HAVE BLOCKS TRANSFERED
	IMULI T1,RECSIZ
	MOVNS T1	;NUMBER OF WORDS
	HRL T4,T1	;NOW AN AOBJN POINTER
PAKDCK:	MOVE T1,(T4)
	CAME T1,CDAT.Z(T4)
	JRST PAKAB1	;BAD ABBORT
	AOBJN T4,PAKDCK
	MOVSS U	;GET SOURCE IN RH AGAIN
	POP P,T1
	TRNE T1,-1	;IS IT FIRST COPY ON THIS CYL
	ADDI T1,DOTRK-REMTRK	;NEED TO ADD DOTRK
	ADDI T1,REMTRK-1	;ELSE REMTRK (-1 FOR AOBJN)
	AOBJN T1,PAKRED
	AOBJN CYL,PAKCYL
	POP P,DAT
	HRLS DAT
	HLRS CMD
	MOVSS U	;DEST IN RH
	MOVE T1,THSDAT
	MOVEM T1,HOMCOP(DAT)
	MOVEI K,HOMPTR
	PUSHJ P,WRTVER
	 JRST PAKAB2	;ABORT AGAIN
	MOVSS U
	OASC [ASCIZ /COPY COMPLETED FROM #U TO/]
	MOVSS U
	OASC [ASCIZ / #U
/]
	JRST FMTENC	;THIS WILL RESTART SPACE WAITERS ETC
;HERE ON ERRORS

PAKER1:	PUSHJ P,COMERR	;ERROR FROM SOURCE PACK
	 JRST PAKRT1	;RECOVERABLE, RETRY
	MOVE T2,UNIERF(U)
	TLNN T2,UCHK
	JRST PAKSHW	;TREAT AS HARDWARE ERROR AND ABORT
	MOVSI T2,(1B4!1B12)
	TDNN T2,UNISNS(U)
	JRST PAKSHW
	PUSH P,CYL
	PUSHJ P,COMERP	;PRINT THE ERROR MESSAGE (WILL SET CYL, HEAD, REC)
	PUSHJ P,BAKTRN	;BACK TRANSLATE FOR BAT COMPARE
IFN <RECPAG-1>,<ADDI T1,RECPAG-1
	IDIVI T1,RECPAG	;CONVERT TO A PAGE ADDRESS>
	POP P,CYL
	MOVE T4,-1(P)	;POINTER TO THE BAT AND HOM BLOCKS
	ADDI T4,1000	;POINT TO BAT
	ADD T4,BATFIR(T4)
PKR1S:	SKIPN (T4)
	JRST PAKE1F	;NOT IN A BAT BLOCK
	MOVE T3,BATELB(T4)
	CAMGE T1,T3
	JRST PKR1N	;NOT IN THIS REGION
	LDB T2,[POINT BASNBB,BATNBB(T4),BANNBB]
	ADD T3,T2
	CAMG T1,T3
	JRST PKR1B	;IT IS IN THIS REQION
PKR1N:	AOBJP T4,PAKE1F
	AOBJN T4,PKR1S	;CONTINUE SEARCH
PAKE1F:	TRNN F,F.NERR	;SHOULD WE CONTINUE FROM ERROR?
	JRST PAKTM1	;NO, TERMINATE
	OASC [ASCIZ /CONTINUING
/]
PAKCON:	MOVE T1,UNICNT(U)	;NOW CONTINUE
        ADDI T1,2               ;POINT TO DATA RECORD POINTER
        HRR T2,(T1)             ;POINT TO DATA RECORD
        SETZM (T2)              ;ZERO 1ST WORD OF BAD RECORD
        HRLS T2                 ;THEN ZERO ENTIRE RECORD
        MOVEI T3,177(T2)
        AOS T2
        BLT T2,(T3)
        AOS T1                  ;STEP PAST DATA WORD
	HRLI T1,TIC
	HLRZ T2,CMD
	MOVEM T1,(T2)
	MOVNI T3,1
	JRST PAKRT1

PKR1B:	OASC [ASCIZ /ERROR IS IN A BLOCK MARKED BAD. CONTINUING
/]
	JRST PAKCON

PAKSHW:	PUSH P,T1
	OASC [ASCIZ /
PROBABLE HARDWARE ERROR ON SOUCE PACK
/]
	POP P,T1
	PUSHJ P,COMERP
PAKTM1:	OASC [ASCIZ /COPY FROM #U/]
	MOVSS U
	OASC [ASCIZ / TO #U ABORTED
/]
	JRST FMTENC	;START WAITERS
;THIS IS WRITE ERROR ON DESTINATION PACK

PAKER2:	PUSHJ P,COMERR
	 JRST PAKRT2	;RETRY
	PUSH P,T1
	OASC [ASCIZ /WRITE ERROR ON DESTINATION PACK
/]
DESECM:	POP P,T1
	PUSH P,CYL
	PUSHJ P,COMERP
	POP P,CYL
	MOVE T1,UNIERF(U)
	TLNN T1,UCHK
	JRST DSTHWD	;WARDWARE ERROR
	MOVSI T1,(1B4!1B12)
	TDNN T1,UNISNS(U)
	JRST DSTHWD
	TRNE F.NALT
	JRST DESABT	;ABORT, CAN NOT GET  ALT
	PUSHJ P,GETALT	;GET ALTERNATE TRACK
	 JRST DESABT	;CAN NOT GET ONE
	MOVSS U
	POP P,T1
	JRST PAKRED	;RESTART

DSTHWD:	OASC [ASCIZ /PROBABLE HARDWARE ERROR
/]
DESABT:	MOVSS U
	JRST PAKTM1

PAKER3:	PUSHJ P,COMERR
	 JRST PAKRT3
	PUSH P,T1
	OASC [ASCIZ /READ ERROR ON DESTINATION PACK
/]
	JRST DESECM	;TO COMMON CODE
;HERE WHEN DATA DOES NOT COMPARE BUT NO ERRORS

PAKAB1:	OASC [ASCIZ /DATA DOES NOT COMPARE BUT NO HARDWARE
DETECTED ERRORS
/]
	JRST DESECM	;ABORT

;HERE IF WE CAN NOT WRITE THE HOME BLOCK

PAKAB2:	OASC [ASCIZ /CAN NOT WRITE HOME BLOCKS ON DESTINATION
PACK AFTER ALL BLOCKS COPIED.
DESTINATION PACK MAY CONTAIN INCORRECT COPY DATE AND OTHER
WRONG DATA
/]
	JRST DESECM
BATSPC:	SETZM BATREG(T1)	;CLEAR BAT BLOCKS
	HRLI T2,BATREG(T1)
	HRRI T2,BATREG+1(T1)
	BLT T2,775(T1)	;DO NOT CLEAR COD AND SELF
	SETZM BATSEC(T1)	;THE NUMBER OF BAD SECTORS
	SETZM BATCNT(T1)	;AND BAD REGIONS
	POPJ P,

HOMSPC:	MOVE T2,-4(P)	;GET POINTER TO HOME BLOCK
	MOVE T2,HOMHID(T2)	;GET ID
	MOVEM T2,HOMHID(T1)
	SETOM HOMSRC(T1)	;NOT IN SYS SEARCH LIST
	SETZM HOMSNM(T1)	;OR IN STR
	SETZM HOMLOG(T1)
	SETOM HOMSUN(T1)	;OR IN SWAP LIST
	SETZM HOMCOP(T1)	;VERY EARLY DATE
	POPJ P,

DEFINE MAKSPC(ADRS,BLK)
<IFG <<BLK*1000+777>-<REMTRK*RECTRK*RECSIZ>>,<
	PRINTX ?RECORD OVERFLOW FOR BLK - REDO SPECIAL PROCESSING>
	XWD ADRS,BLK*RECPAG>

SPCRTB:	MAKSPC(HOMSPC,LBNHOM)
	MAKSPC(HOMSPC,LB2HOM)
	MAKSPC(BATSPC,<<LBNHOM+1>>)
	MAKSPC(BATSPC,<<LB2HOM+1>>)
NUMSPR==.-SPCRTB
SETCOP:	HLRS CMD
	HLRS DAT
	MOVEI T4,CPYZ.D(DAT)	;DATA AREA
	HRRZ HEAD,-1(P)
	SKIPE HEAD
	TLOA HEAD,-DOTRK
	HRLI HEAD,-REMTRK	;SET ONE OR THE OTHER
	POPJ P,

TRNSET:	MOVEI REC,1
	PUSHJ P,GENSKF
	MOVE T1,-1(P)
	SUB T1,HEAD
	TRNN T1,-1	;SEE IF FIRST TIME THROUGH
	PUSHJ P,GENSEC	;GENERATE A SET SECTOR THE FIRST TIME
	HRLI REC,-RECTRK
	HRRZ T1,HEAD
	CAIN T1,HEADS-1	;LAST HEAD HAS 16 RECORDS IF FORMATTING IN BLOCKS
	HRLI REC,-<RECCYL-RECTRK*<HEADS-1>>
	JRST TRNRC1
TRNREC:	PUSHJ P,GENSKF
	SUBI CMD,SEKZ.C	;JUST WANT DATA
TRNRC1:	PUSHJ P,GENSID
	PUSHJ P,(T3)	;EITHER GENRED OR GENWRT
	HRRM T4,-1(CMD)	;PLACE TO TRANSFER
	ADDI T4,RECSIZ
	AOBJN REC,TRNREC
	AOBJN HEAD,TRNSET
	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	POPJ P,	;FINISHED

;DO A SET SECTOR

GENSEC:	AOS -1(CMD)	;THE SEEK DATA HAS MOVED
	PUSHJ P,GENSC0	;GENERATE THE SET SECTOR COMMAND
	DMOVE T1,-2(DAT)
	DMOVEM T1,-1(DAT)	;REALLY MOVE THE DATE
	MOVE T1,SECTAB-1(REC)	;GET SECTOR ARG
	MOVEM T1,-2(DAT)
	AOJA DAT,CPOPJ		;AND DONE

SECZ.D==1

%%Z==0

SECTAB:	REPEAT RECTRK,< RADIX 10	;;237 and 410 are magic numbers
%%Y==128*<237+%%Z*<GAP+BYTSIZ>>/<BYTES+410>
	BYTE (8) %%Y
%%Z==%%Z+1
; PRINTD (Record,\%%Z,is at RPS sector,\%%Y)
	RADIX 8>
;COPY ERROR MESSAGES

SRCNFT:	OASC [ASCIZ /SOURCE DRIVE NOT FORMATTED
/]
	JRST CPYDRV

SRCWRT:	OASC [ASCIZ /SOURCE DRIVE NOT WRITE PROTECTED
/]
	JRST CPYDRV

DSTNWT:	OASC [ASCIZ /DESTINATION DRIVE WRITE PROTECTED
/]
	JRST CPYDRV

DSTNFT:	OASC [ASCIZ /DESTINATION DRIVE NOT FORMATTED
/]

DSTUSD:	OASC [ASCIZ /DESTINATION DRIVE ALREADY IN USE
/]
	JRST CPYDRV

WRGDNS:	OASC [ASCIZ /SOURCE AND DESTINATION DRIVE NOT SAME TYPE
/]
	MOVSI T1,DRVUSD
	ANDCAM T1,UNISTS(U)	;REST IN USE BIT
	JRST CPYDRV

CPYABS:	MOVSS U		;ABORT COPY BUT U IS SWAPPED
CPYABT:	OASC [ASCIZ /COPY FROM #U/]
	MOVSI T1,DRVUSD
	ANDCAM T1,UNISTS(U)
	MOVSS U
	ANDCAM T1,UNISTS(U)
	OASC [ASCIZ / TO #U ABORTED
/]
	JRST CPYDRV
SUBTTL	"OLDC" - Old copy routine (1 pack at a time)

OLDCOP:	JSP T1,DOWAT
	OASC [ASCIZ /
SOURCE: /]
	PUSHJ P,ONEUN1	;GET A DRIVE
	PUSH P,U
	OASC [ASCIZ /
DESTINATION: /]
	PUSHJ P,ONEUN1
	CAMN U,(P)
	JRST SAMEU	;SAME UNIT
	HRLM U,(P)
	POP P,U
	HRRZ CMD,MEMFRE
	MOVEI DAT,COPCML(CMD)	;SAVE SOME SPACE
	HRLS DAT
	HRLS CMD
	MOVSI CYL,-CYLS/2	;3330-1 (100 megabytes = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVSI CYL,-CYLS
COPCYL:	HLRS DAT
	HLRS CMD
	MOVEI T4,COPDTL(DAT)	;LEAVE SPACE FOR COMMAND DATA
	MOVSI HEAD,-HEADS
COPHED:	MOVSI REC,-RECTRK
	HRRI REC,1	;START WITH RECORD 1
COPREC:	PUSHJ P,GENSKF
	TRNE REC,-2
	SUBI CMD,2	;IF NOT RECORD 1, NO SEEK NEEDED
	PUSHJ P,GENSID	;BUT DATA NEEDED FOR SEARCH ID=
	PUSHJ P,GENRED	;A READ
	HRRM T4,-1(CMD)
	ADDI T4,RECSIZ
	AOBJN REC,COPREC
	AOBJN HEAD,COPHED
	MOVNI T3,1
COPRTY:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST COPERR
	HLRS CMD
	HLRS DAT
	MOVEI T4,COPDTL(DAT)	;NOW WRITE INFORMATION OUT
	MOVSS U		;DIFFERENT UNIT
	MOVSI HEAD,-HEADS
COPHD1:	MOVSI REC,-RECTRK
	HRRI REC,1
COPRC1:	PUSHJ P,GENSKF
	TRNE REC,-2
	SUBI CMD,2
	PUSHJ P,GENSID
	PUSHJ P,GENWRT
	HRRM T4,-1(CMD)
	ADDI T4,RECSIZ
	AOBJN REC,COPRC1
	AOBJN HEAD,COPHD1
	MOVNI T3,1
COPRT1:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST COPER1
	HLRS CMD
	HLRS DAT
	MOVEI T4,COPDL1+COPDTL(DAT)	;READ BACK
	MOVSI HEAD,-HEADS
COPHD2:	MOVSI REC,-RECTRK
	HRRI REC,1
COPRC2:	PUSHJ P,GENSKF
	TRNE REC,-2
	SUBI CMD,2
	PUSHJ P,GENSID
	PUSHJ P,GENRED
	HRRM T4,-1(CMD)
	ADDI T4,RECSIZ
	AOBJN REC,COPRC2
	AOBJN HEAD,COPHD2
	MOVNI T3,1
COPRT2:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST COPER2
	HLRZ T4,DAT
	ADDI T4,COPDTL
	HRLI T4,-COPDL1
	MOVE T1,(T4)
	CAME T1,COPDL1(T4)
	JRST COPER3
	AOBJN T4,.-3
	MOVSS U
	AOBJN CYL,COPCYL
	OASC [ASCIZ /
COPY COMPLETED/]
	JRST CMDSET

SAMEU:	OASC [ASCIZ /
SAME UNIT/]
	JRST CMDSET

COPERR:	PUSHJ P,COMERR
	 JRST COPRTY
	PUSHJ P,COMERP
	JRST CMDSET

COPER1:	PUSHJ P,COMERR
	 JRST COPRT1
	PUSHJ P,COMERP
	JRST CMDSET

COPER2:	PUSHJ P,COMERR
	 JRST COPRT2
	PUSHJ P,COMERP
	JRST CMDSET

COPER3:	OASC [ASCIZ /
DATA COMPARE ERROR/]
	JRST CMDSET
SUBTTL	"NEW" - Change unit ID on an existing home page

NEWID:	PUSHJ P,ONEUNT	;GET A DRIVE TO CHANGE ID ON
	HRRZ CMD,MEMFRE
	MOVEI DAT,RVFZ.C(CMD)
	HRLS DAT
	HRLS CMD
	MOVEI K,HOMPTR
	PUSHJ P,REDVER
	 JRST CMDSET	;ERROR READING HOME BLOCKS ABORT
NEWIDG:	OASC [ASCIZ /ID: /]
	PUSHJ P,REDLIN
	PUSHJ P,SCNID
	JUMPN T1,NEWIDG
	HLRS DAT
	MOVE T1,ACCUM
	MOVEM T1,HOMHID(DAT)
	PUSHJ P,WRTVER
	 JRST CMDSET
	JRST CMDSET
SUBTTL	"STATUS" - List status of all on-line units

STSCMD:	HLRZ U,SYSUNI
STSLP:	SKIPGE UNISTS(U)
	JRST NXTSTS	;UNIT IS OFF-LINE, IGNORE IT
	OASC [ASCIZ /
#U /]
	LDB T1,[POINT 3,UNISTS(U),3]
	OASC @ONLTAB(T1)
NXTSTS:	HLRZ U,UNISYS(U)
	JUMPN U,STSLP
	JRST CMDLP

SUBTTL	"AVERIFY" - Verify that alternate tracks are readable

AVRCMD:	PUSHJ P,REDDRV
AVRLP:	PUSHJ P,@DRVDSP
	 JRST CMDSET
	HRRZ CMD,MEMFRE
	MOVEI DAT,AVFZ.C(CMD)
	HRLS DAT
	HRLS CMD
	OASC [ASCIZ /
UNIT #U
/]
	PUSHJ P,AVERIF
	 JRST AVRLP
	OASC [ASCIZ /ALTERNATE TRACKS VERIFIED
/]
	JRST AVRLP

SUBTTL	"AFORMAT" - Verify that the alternate tracks are formatted

AFMCMD:	PUSHJ P,REDDRV
AFMLP:	PUSHJ P,@DRVDSP
	 JRST CMDSET
	HRRZ CMD,MEMFRE
	MOVEI DAT,AFMZ.C(CMD)
	HRLS DAT
	HRLS CMD
	OASC [ASCIZ /
UNIT #U
/]
	PUSHJ P,AFRMT
	 JRST AFMLP
	PUSHJ P,AVERIF
	 JRST AFMLP
	OASC [ASCIZ /ALTERNATE TRACKS FORMATTED AND VERIFIED
/]
	JRST AFMLP
;ALTERNATE TRACK VERIFY

AVERIF:	MOVEI CYL,CYLS/2	;3330-1 (100 megabyte = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI CYL,CYLS
	HRLI CYL,-ALTS	;7 or 5 ALTERNATE CYLS
AVFCYL:	MOVSI HEAD,-HEADS
AVFHED:	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO	;NORMAL GO ROUTINE
	 POPJ P,	;HERE ON UNRECOVERABLE ERROR
	LDB T2,[POINT 2,(DAT),7]
	CAIE T2,1
	JRST AVFNXT	;NEXT
	PUSH P,CYL
	PUSH P,HEAD
	LDB CYL,[POINT 16,1(DAT),15]
	LDB HEAD,[POINT 16,1(DAT),31]
	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST AVFER1
	POP P,HEAD
	POP P,CYL
	LDB T2,[POINT 2,(DAT),7]
	CAIE T2,2
	JRST AVFER2	;VERIFY ERROR
	LDB T2,[POINT 16,1(DAT),15]
	CAIE T2,(CYL)
	JRST AVFER2
	LDB T2,[POINT 16,1(DAT),31]
	CAIE T2,(HEAD)
	JRST AVFER2
AVFNXT:	AOBJN HEAD,AVFHED
	AOBJN CYL,AVFCYL
	AOS (P)
	POPJ P,	;FINISHED
AVFER1:	POP P,HEAD
	POP P,CYL
	POPJ P,		;HARDWARE ERROR

AVFER2:	OASC [ASCIZ /INCORRECT ALTERNATE TRACK. CYL,HEAD #C,#H
/]
	POPJ P,		;ERROR RETURN

;HERE IS THE ROUTNE TO START A UNIT AND HANDLE NORMAL ERROR
;PROCEDURES

UNIGO:	MOVNI T3,1
UNIRTY:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST UNIGER	;GOT AN ERROR
	JRST CPOPJ1	;ALL IS OK

UNIGER:	PUSHJ P,COMERR
	 JRST UNIRTY	;NEED TO RETRY
	JRST COMERP	;PRINT ERROR MESAGE AND NON-SKIP RETURN
;ALTERNATE TRACK REFORMAT (IN CASE OF ERROR)

AFRMT:	MOVEI CYL,CYLS/2	;3330-1 (100 megabyte = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI CYL,CYLS
	HRLI CYL,-ALTS	;7 or 5 ALTERNATE CYLS
	SETZM	ALTBAD		;No bad alternate tracks seen yet
AFRCYL:	MOVSI HEAD,-HEADS
AFRHED:	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO	;NORMAL GO ROUTINE
	 JRST AFRER1	;HERE ON UNRECOVERABLE ERROR
	LDB T2,[POINT 2,(DAT),7]
	CAIE T1,2	;Is the alternate itself bad?
	 JRST AFRER3	;Yes, count it
	CAIE T2,1	;Is it a good alternate for a bad track?
	JRST AFRNXT	;No, 0 means this track is unassigned
	PUSH P,CYL
	PUSH P,HEAD
	LDB CYL,[POINT 16,1(DAT),15]
	LDB HEAD,[POINT 16,1(DAT),31]
	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST [	POP P,HEAD
		POP P,CYL
		JRST AFRER1]	;GIVE UP
	POP P,HEAD
	POP P,CYL
	LDB T2,[POINT 2,(DAT),7]
	CAIE T2,2
	JRST AFRER2	;VERIFY ERROR
	LDB T2,[POINT 16,1(DAT),15]
	CAIE T2,(CYL)
	JRST AFRER2
	LDB T2,[POINT 16,1(DAT),31]
	CAIE T2,(HEAD)
	JRST AFRER2
AFRNXT:	AOBJN HEAD,AFRHED
	AOBJN CYL,AFRCYL
	SKIPN	ALTBAD		;Error return if any bad alternates detected
	 AOS (P)
	POPJ P,	;FINISHED

AFRER1:	OASC	[ASCIZ /Continuing with next alternate track
/]
	PUSHJ	P,ASSGOD	;Try to reformat the track, skip if OK
AFRER2:	 PUSHJ	P,ASSBAD	;The alternate track itself is bad
	  JFCL			;This is skip return from ASSGOD
AFRER3:	AOS	ALTBAD		;Count bad alternates detected
	JRST	AFRNXT		;FORMAT NEXT

;Set File Mask - need to rewrite HA or R0
;Must be immiately followed by GENSEK

SETMSK:	MOVSI	T1,(BYTE (8) 300)	;SET FILE MASK FOR ALL WRITES OK
	MOVEM	T1,(DAT)
	MOVSI	T1,(BYTE (8) BYTMOD,SETFMK)
	MOVEM	T1,(CMD)
	HRRZ	T1,DAT
	HRLI	T1,(BYTE (12) -1)
	MOVEM	T1,1(CMD)
	MOVE	T1,UNINUM(U)
	DPB	T1,[POINT 8,(CMD),23]
	ADDI	CMD,2
	ADDI	DAT,1
	POPJ	P,


;Here to write Home Address (HA) and Record 0 (R0).
;SETMSK and GENSEK already done.  T2 has CYL,,HEAD to write in R0.
;T1 has 0 for good track, has 2 for bad track

SDZERO::BLOCK	3	;Data to be set via DDT to do special skip defect
	;SDZERO+0/ Number of tracks to write special data
	;SDZERO+1,+2/ 6 bytes to write instead
	;Set SDZERO to 1 to fix first track on cylinder 0.

GENHW0:
IFN FT3350,<	;Have to do more work with 3350 type disks
	SD3350==6		;6 bytes for "skip defect" info
;DAT+0 will get: C C H H                4 bytes from Read Home Address
;DAT+1 will get: x x x x  x x 0 0       6 skip defect bytes
;DAT+3 is where DAT will be adjusted to for new HA data
	MOVSI	T3,(BYTE (8) BYTMOD,RHOM)
	MOVEM	T3,0(CMD)		;Read existing Home Address
	MOVSI	T3,(BYTE (12) 4000-1)
	MOVEM	T3,1(CMD)		;Skip over the flag byte
	MOVSI	T3,(BYTE (12) -4)
	HRRI	T3,0(DAT)
	MOVEM	T3,2(CMD)		;Read current CC HH to DAT+0
	MOVSI	T3,(BYTE (8) BYTMOD,SENSE)
	MOVEM	T3,3(CMD)		;Read sense bytes
	MOVSI	T3,(BYTE (12) 4000-^D<24-SD3350>)
	MOVEM	T3,4(CMD)		;But skip the first 18 (24-6)
	MOVSI	T3,(BYTE (12) -SD3350)
	HRRI	T3,1(DAT)
	MOVEM	T3,5(CMD)		;Read in 6 skip defect bytes
	MOVSI	T3,(BYTE (8) BYTMOD,SRCHA)
	MOVEM	T3,6(CMD)		;Search for Home Address
	MOVSI	T3,(BYTE (12) -4)
	HRRI	T3,0(DAT)
	MOVEM	T3,7(CMD)		;Using the former CC HH
	MOVSI	T3,TIC
	HRRI	T3,6(CMD)		;Build a TIC back to SRCHA
	MOVEM	T3,10(CMD)		; (the TIC is always skipped over)
	MOVSI	T3,(BYTE (8) BYTMOD,WHOM)
	MOVEM	T3,11(CMD)		;Write Home Address
	MOVSI	T3,(BYTE (12) 4000-SD3350) ;6 bytes chained to next 8 bytes
	HRRI	T3,1(DAT)
	SOSL	SDZERO			;Has this been set positive via DDT?
	 HRRI	T3,SDZERO+1		;Yes, write zero skip defect this time
	MOVEM	T3,12(CMD)		;Chain the skip defect bytes before rest
	MOVE	T3,UNINUM(U)
	DPB	T3,[POINT 8,0(CMD),23]	;Set unit numbers in RHOM
	DPB	T3,[POINT 8,3(CMD),23]	;                    SENSE
	DPB	T3,[POINT 8,6(CMD),23]	;                    SRCHA
	DPB	T3,[POINT 8,11(CMD),23]	;                    WHOM
	ADDI	CMD,12			;4 commands, 6 data transfers, 1 TIC
	ADDI	DAT,1+<SD3350+3>/4	;4 + 6 bytes of data
>  ;End IFN FT3350
IFE FT3350,<	;Just a simple Write Home Address command
	MOVSI T3,(BYTE (8) BYTMOD,WHOM)
	MOVEM T3,0(CMD)
>  ;End IFE FT3350
;DAT is set to:  F C C H  H 0 0 0       Data for 3330 Write Home Address
;DAT+2 set to:   C C H H  R K D D	Data for Record 0
	DPB	T1,[POINT 8,0(DAT),7]	;Store flag byte
	DPB	CYL,[POINT 16,0(DAT),23];Store 2 bytes of cyl
	MOVE	T1,HEAD
	LSH	T1,-^D8
	DPB	T1,[POINT 8,0(DAT),31]	;Store high half of head
	DPB	HEAD,[POINT 8,1(DAT),7]	;Data is F,C,C,H,H
	MOVSI	T3,(BYTE (12) -5)	;Last 5 bytes
	HRR	T3,DAT
	MOVEM	T3,1(CMD)		;Point to the 5 bytes

;Now write R0 pointing to alternate track

	DPB	T2,[POINT 16,2(DAT),31]	;Store alternate head
	MOVSS	T2
	DPB	T2,[POINT 16,2(DAT),15]	;Store alternate cylinder
	MOVEI	T2,<BYTE (8) 0,0,0,^D8>
	MOVEM	T2,3(DAT)		;Store R,KL,DL,DL
	MOVSI	T1,(BYTE (8) BYTMOD!IGNLEN,WRTR0)
	MOVEM	T1,2(CMD)		;Write Record 0
	MOVSI	T1,(BYTE (12) -^D8)
	HRRI	T1,2(DAT)
	MOVEM	T1,3(CMD)		;Controller will write 8 zeros data
	MOVE	T1,UNINUM(U)
IFE FT3350<DPB	T1,[POINT 8,0(CMD),23]>	;Put unit number in WHOM
	DPB	T1,[POINT 8,2(CMD),23]	;Put unit number in WRTR0
	ADDI	CMD,4
	ADDI	DAT,4
	POPJ	P,

MSKZ.C==2
IFE FT3350,<WH0Z.C==4>
IFN FT3350,<WH0Z.C==4+13>
SUBTTL	"LIST" - List map of bad spots from BAT page

MAPLST:	PUSHJ P,REDDRV
MAPLOP:	PUSHJ P,@DRVDSP	;GET NEXT DRIVE
	 JRST CMDSET	;FINISHED
	HRRZ CMD,MEMFRE
	MOVEI DAT,RVFZ.C(CMD)
	HRLS DAT
	HRLS CMD
	OASC [ASCIZ /
UNIT #U
/]
	MOVEI K,HOMPTR	;GET A POINTER TO THE HOME BLOCKS
	PUSHJ P,REDVER	;READ AND VERIFY HOMVE BLOCKS
	 JRST BADHOM	;BAD HOME BLOCKS
	OASC [ASCIZ /UNIT ID: /]
	OSIX HOMHID(DAT)
	CRLF
	SKIPN HOMSNM(DAT)
	JRST NOSTR	;NOT IN A STRUCTURE
	OASC [ASCIZ /STRUCTURE: /]
	OSIX HOMSNM(DAT)
	OASC [ASCIZ / LOGICAL UNIT: /]
	OSIX HOMLOG(DAT)
	CRLF
NOSTR:	SKIPN HOMCOP(DAT)	;HOW ABOUT COPY DATE?
	JRST	[OASC [ASCIZ /NO COPY DATE
/]
		JRST BADHOM]
	OASC [ASCIZ /LAST COPY DATE: /]
	MOVE T1,HOMCOP(DAT)
	PUSHJ P,PRDAT
	CRLF
BADHOM:	MOVEI K,BATPTR
	PUSHJ P,REDVER
	 JRST MAPLOP	;FINISHED
	OASC [ASCIZ /NUMBER OF BAD REGIONS: /]
	ODEC BATCNT(DAT)
	OASC [ASCIZ /
NUMBER OF BAD SECTORS: /]
	ODEC BATSEC(DAT)
	CRLF
	HRRZ K,DAT
	ADD K,BATFIR(DAT)	;GENERATE POINTER
	MOVEI T4,0
BATLOP:	SKIPN (K)
	JRST DONBAT
	ADDI T4,1
	MOVE T1,BATELB(K)
IFN <RECPAG-1>,<IMULI T1,RECPAG>
	PUSHJ P,TRANS
	OASC [ASCIZ /RECORD,HEAD,CYL #R,#H,#C
   /]
	LDB T1,[POINT BASNBB,BATNBB(K),BANNBB]
	ADDI T1,1
IFN <RECPAG-1>,<IMULI T1,RECPAG>
	ODEC T1
	OASC [ASCIZ / RECORD(S) /]
	HRRZ T1,BATDAT(K)
	JUMPE T1,BATNDT
	PUSHJ P,PRDATO	;DATE ONLY
	CRLF
NXTBAT:	AOBJP K,MAPLOP
	AOBJN K,BATLOP
	JRST MAPLOP

BATNDT:	OASC [ASCIZ /NO DATE
/]
	JRST NXTBAT

DONBAT:	JUMPN T4,MAPLOP
	OASC [ASCIZ /NO BAD SPOTS
/]
	JRST MAPLOP
SUBTTL	"ALIST" - List information about alternate track assignments

ALTLST:	PUSHJ P,REDDRV
ALOOP:	PUSHJ P,@DRVDSP	;GET NEXT DRIVE
	 JRST CMDSET	;FINISHED
	MOVEI REC,0	;WILL ACCUMULATE TOTAL LEFT
	MOVEI CYL,CYLS/2	;3330-1 (100 megabytes = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI CYL,CYLS
	HRLI CYL,-ALTS	;NUMBER OF ALT CYLS, 7 or 5
	HRRZ CMD,MEMFRE
	MOVEI DAT,SEKZ.C+RH0Z.C(CMD)
	OASC [ASCIZ /
UNIT #U
/]
	HRLS DAT
	HRLS CMD
ALTCYL:	MOVSI HEAD,-HEADS
ALTHED:	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST ALOOP	;UNRECOVERABLE ERROR
	LDB T2,[POINT 2,(DAT),7]
	CAIN T2,2
	JRST DEFALT	;ALT TRACK IS DEFECTIVE
	CAIE T2,1
	AOJA REC,NOTDEF	;THIS ALT NOT IN USE
	OASC [ASCIZ /CYL,HEAD: #C,#H  ALTERNATE FOR CYL,HEAD: /]
	LDB T1,[POINT 16,1(DAT),15]
	ODEC T1
	OCHI ","
	LDB T1,[POINT 16,1(DAT),31]
	ODEC T1
	CRLF
	JRST NOTDEF

DEFALT:	OASC [ASCIZ /CYL,HEAD: #C,#H DEFECTIVE
/]
NOTDEF:	HLRS CMD
	HLRS DAT
	AOBJN HEAD,ALTHED
	AOBJN CYL,ALTCYL
	OASC [ASCIZ /#R ALTERNATE TRACKS REMAINING
/]
	JRST ALOOP
;GENERATE A READ HOME ADDRESS (1 BYTE) AND A READ R0 (4 BYTES)

GENHR0:	MOVSI T2,(BYTE (8) BYTMOD!IGNLEN,RHOM)
	MOVEM T2,(CMD)
	MOVSI T2,(BYTE (8) BYTMOD!IGNLEN,RDR0)
	MOVEM T2,2(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	DPB T2,[POINT 8,2(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE (12) -1)
	MOVEM T2,1(CMD)
	MOVEI T2,1(DAT)
	HRLI T2,(BYTE (12) -4)
	MOVEM T2,3(CMD)
	MOVSI T2,(BYTE (8) 200)
	MOVEM T2,4(CMD)
	POPJ P,

RH0Z.C==5
RH0Z.D==2
SUBTTL	"DOIT" - HERE TO HANDLE A COMMAND WHICH REQUIRES VERIFICATION

DOITCM:	SKIPN T1,DOFLG
	JRST BADCMD	;THERE IS NOTHING WAITING
	SETZM DOFLG
	JRST (T1)	;GO DO IT

DOWAT:	MOVEM T1,DOFLG	;JSP HERE ON CMD REQUIRING VERIFY
	JRST BADCD1	;DO NOT DESTROY DOFLG BUT ACT LIKE ILL CMD
SUBTTL	"REFRESH" - Refresh alternate track assignments

REFACM:	JSP T1,DOWAT
	OASC [ASCIZ /
UNIT TO REFRESH ALTERNATE TRACKS ON: /]
	PUSHJ P,ONEUN1	;GET A DRIVE
	MOVSI CYL,-<CYLS/2+ALTS>	;411 WITH ALTERNATES
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVSI CYL,-<CYLS+ALTS>	;815 or 560
	MOVE CMD,MEMFRE
	MOVSI DAT,AFMZ.C+FT1Z.C(CMD)
	HRLS CMD	;GET BOTH SET IN LEFT HALF
REFCYL:	MOVSI HEAD,-HEADS
REFHED:	PUSHJ P,ASSGOD	;Write new HA and R0 and format track
	  OASC [ASCIZ /Attempting to REFRESH rest of pack
/]
	AOBJN HEAD,REFHED
	AOBJN CYL,REFCYL
	OASC [ASCIZ /UNIT #U, ALTERNATE TRACKING REFRESHED
/]
	JRST CMDSET
;SCAN A NUMBER, MUST BE A NUMBER OR REQUEST RETYPE

SCNUM:	PUSHJ P,REDLIN
	PUSHJ P,SCAN
	CAIN T1,1
	POPJ P,	;IT WAS A NUMBER, NOW IN ACCUM
	OASC [ASCIZ /NOT A NUMBER, RETYPE: /]
	JRST SCNUM

RCYHD:	OASC [ASCIZ /CYLINDER: /]	;READ CYLINDER AND HEAD
	MOVEI T1,^D10
	MOVEM T1,RADIX
BADCY1:	PUSHJ P,SCNUM
	MOVEI CYL,^D411
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI CYL,^D815
	SKIPL ACCUM
	CAMG CYL,ACCUM
	JRST BADCYL	;CYLINDER IS INCORRECT
	HRL CYL,ACCUM	;PICK IT UP
	OASC [ASCIZ /HEAD: /]
BADHD1:	PUSHJ P,SCNUM
	SKIPL HEAD,ACCUM
	CAIL HEAD,HEADS
	JRST BADHED
	MOVEI T1,10
	MOVEM T1,RADIX	;RESET RADIX
	POPJ P,

BADHED:	OASC [ASCIZ /
ILLEGAL HEAD NUMBER, RETYPE /]
	JRST BADHD1

BADCYL:	OASC [ASCIZ /
ILLEGAL CYLINDER NUMBER, RETYPE /]
	JRST BADCY1
SUBTTL	"ASSIGN" - Assign one alternate track
ASSCMD:	JSP T1,DOWAT
	OASC [ASCIZ /
UNIT TO ASSIGN ALTERNATE ON: /]
	PUSHJ P,ONEUN1
	PUSHJ P,RCYHD
	MOVE CMD,MEMFRE
	HRLS CMD
	MOVEI DAT,AFMZ.C+FT1Z.C(CMD)
	HRLS DAT
	MOVSS CYL	;NOW R.H. IS CYLINDER DESIRED
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST CMDSET
	HLRZ T1,CYL	;THIS IS SET UP WITH THE MAX
	CAILE T1,^D7(CYL)
	JRST ASSLOW	;THIS IS A LOW CYLINDER NOT SPARE
	LDB T1,[POINT 2,(DAT),7]
	JUMPN T1,ASHERR	;ANY FLAG BYTE BUT 0 IS AN ERROR
ASSCD1:	PUSHJ P,ASSBAD
	 JRST CMDSET	;ERROR
	JRST CMDSET	;FINISHED

ASHERR:	PUSH P,T1
	OASC [ASCIZ /
CYL #C HEAD #H, IS /]
	POP P,T1
	OASC @DEFTBL(T1)
	CRLF
	JRST CMDSET

DEFTBL:	[ASCIZ /GOOD/]
	[ASCIZ /ALTERNATE/]
	[ASCIZ /DEFFECTIVE/]
	[ASCIZ /UNKNOWN/]
;MARK A TRACK BAD OR MARK IT GOOD AND FORMAT IT

ASSGOD:	TDZA T1,T1
ASSBAD:	MOVEI T1,2	;T1 IS FLAG BYTE
	PUSH P,T1	;SAVE IT
	HLRS DAT
	HLRS CMD
	PUSHJ P,SETMSK	;SET A FILE MASK
	PUSHJ P,GENSEK	;GENERATE SEEK
	MOVE T1,(P)
	HRL T2,CYL
	HRR T2,HEAD	;SAME CYL AND HEAD
	PUSHJ P,GENHW0	;WRITE HOME ADDRESS AND R0
	POP P,T1
	SKIPN T1	;FORMAT IF MARKING GOOD
	PUSHJ P,TRKFMT
	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	JRST UNIGO	;START IT UP

ASSLOW:	LDB T1,[POINT 2,(DAT),7]
	JUMPE T1,ASSLOG	;SET UP AN ALTERNATE TRACK
	CAIE T1,2	;ALREADY HAVE ALTERNATE SET UP?
	JRST ASHERR	;NO, SOMETHING WRONG
ASSLOG:	PUSHJ P,GALT2
	 JRST CMDSET
	JRST CMDSET	;FINISHED IN EITHER CASE
GETALT:	HLRS CMD
	HLRS DAT
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0	;READ HOME INFORMATION ON OLD TRACK
	PUSHJ P,UNIGO
	 POPJ P,	;ERROR
	LDB T1,[POINT 2,(DAT),7]
GALT2:	CAIE T1,2	;HERE AS ALTERNATE ENTRY IF HOME INFO READ
	JRST GALT1	;NOT ALREADY DEFECTIVE, GET ALTERNATE
	PUSH P,1(DAT)	;SAVE POINTER TO OLD
	PUSHJ P,GALT1	;SET UP ALTERNATE
	 JRST	[POP P,T1
		POPJ P,]	;ERROR SETTING ALTERNATE
	POP P,T2
	PUSH P,HEAD
	PUSH P,CYL
	LDB HEAD,[POINT 16,T2,31]
	LDB CYL,[POINT 16,T2,15]
	PUSHJ P,ASSBAD	;MARK IT AS BAD
	 JFCL	;JUST IGNRRE ERROR
	POP P,CYL
	POP P,HEAD
	JRST CPOPJ1

GALT1:	PUSH P,CYL
	PUSH P,HEAD	;SAVE CYL AND HEAD TO ASSIGN ALT FOR
	MOVEI CYL,CYLS/2	;3330-1 (100 megabyte = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI CYL,CYLS	;SET APPROPRIATE STARTING PLACE
	HRLI CYL,-ALTS	;7 or 5 CYLS TO SEARCH
GALCY:	MOVSI HEAD,-HEADS
GALHED:	HLRS CMD
	HLRS DAT
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST GALFAL
	LDB T1,[POINT 2,(DAT),7]
	JUMPE T1,GALFND	;CAN USE THIS AS ALTERNATE
	AOBJN HEAD,GALHED
	AOBJN CYL,GALCY
	OASC [ASCIZ /NO MORE ALTERNATE TRACKS AVAILABLE
/]
GALFAL:	OASC [ASCIZ /ALTERNATE TRACK NOT ASSIGNED
/]
	POP P,HEAD
	POP P,CYL
	POPJ P,
GALFND:	HLRS DAT
	HLRS CMD
	PUSHJ P,SETMSK
	PUSHJ P,GENSEK
	MOVEI T1,1	;MARK THIS AS THE ALTERNATE
	HRR T2,(P)	;GET HEAD
	HRL T2,-1(P)	;AND CYL
	PUSHJ P,GENHW0
	EXCH CYL,-1(P)
	EXCH HEAD,(P)
	PUSHJ P,TRKFMT	;GENERATE FORMAT INFORMATION
	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	EXCH CYL,-1(P)
	EXCH HEAD,(P)
	PUSHJ P,UNIGO
	 JRST GALFAL
	OASC [ASCIZ /CYL,HEAD #C,#H ASSIGNED AS ALTERNATE FOR CYL,HEAD/]
	HRR T2,HEAD
	HRL T2,CYL
	POP P,HEAD
	POP P,CYL
	PUSH P,T2	;SAVE OLD HEAD,CYL
	OASC [ASCIZ / #C,#H
/]
	HLRS DAT
	HLRS CMD
	PUSHJ P,SETMSK
	PUSHJ P,GENSEK
	POP P,T2
	MOVEI T1,2
	PUSHJ P,GENHW0
	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	PUSHJ P,UNIGO
	 POPJ P,
	JRST CPOPJ1	;ALL FINISHED
SUBTTL	"DEASSIGN" - Deassign an alternate track

DEACMD:	JSP T1,DOWAT
	OASC [ASCIZ /
UNIT TO DEASSIGN ALTERNATE ON: /]
	PUSHJ P,ONEUN1
	PUSHJ P,RCYHD
	MOVE CMD,MEMFRE
	HRLS CMD
	MOVEI DAT,AFMZ.C+FT1Z.C(CMD)
	HRLS DAT
	MOVSS CYL	;NOW R.H. IS CYLINDER DESIRED
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST CMDSET
	HLRZ T1,CYL	;THIS IS SET UP WITH THE MAX
	CAILE T1,^D7(CYL)
	JRST DEALOW	;NOT ONE OF THE ALTERNATE TRACKS
	LDB T1,[POINT 2,(DAT),7]
	CAIE T1,2	;IS IT MARKED BAD?
	JRST ASHERR	;NO, ERROR
	JRST DEACM1	;JUST DO AN ASSGOD ON IT

DEALOW:	LDB T1,[POINT 2,(DAT),7]
	CAIE T1,2	;IS IT MARKED AS HAVING AN ALTERNATE?
	JRST ASHERR	;NO
	PUSH P,1(DAT)	;SAVE INFORMATION ON ALTERNATE
	PUSHJ P,ASSGOD	;ASSIGN THIS AS A GOOD TRACK
	 JRST CMDSET	;FAILED
	POP P,T2
	PUSH P,CYL
	PUSH P,HEAD	;SAVE FOR CHECK
	LDB CYL,[POINT 16,T2,15]
	LDB HEAD,[POINT 16,T2,31]
	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST CMDSET	;FAILED TO READ
	LDB T1,[POINT 2,(DAT),7]
	CAIE T1,1
	JRST DEAER1	;ALTERNATE NOT RIGHT
	LDB T1,[POINT 16,1(DAT),31]
	POP P,T2
	CAIE T1,(T2)
	JRST DEAER2	;DOES NOT AGREE
	LDB T1,[POINT 16,1(DAT),15]
	POP P,T2
	CAIE T1,(T2)
	JRST DEAER3
DEACM1:	PUSHJ P,ASSGOD
	 JRST CMDSET
	JRST CMDSET

DEAER1:	POP P,T2
	POP P,T2
	JRST ASHERR

DEAER2:	POP P,T2
DEAER3:	OASC [ASCIZ /
CYL #C HEAD #H, IS NOT MARKED AS ALTERNATE FOR CORRECT TRACK
/]
	JRST CMDSET
SUBTTL	"ERRMAK" - Make a bad alternate track (to test COPY routine)

ERRCMD:	JSP T1,DOWAT
	OASC [ASCIZ /
UNIT TO CHANGE ALTERNATE TRACKING ON: /]
	PUSHJ P,ONEUN1
	OASC [ASCIZ /SET /]
	PUSHJ P,RCYHD
	HLRZS CYL	;REAL CYL NUMBER IN LEFT HALF
	MOVE CMD,MEMFRE
	MOVEI DAT,AFMZ.C+FT1Z.C(CMD)
	HRLS CMD
	PUSH P,CYL
	PUSH P,HEAD	;SAVE FOR GENHW0
	PUSHJ P,SETMSK
	PUSHJ P,GENSEK
	OASC [ASCIZ /TO /]
	PUSHJ P,RCYHD
FLGAGN:	OASC [ASCIZ /FLAG BYTE: /]
	PUSHJ P,SCNUM
	SKIPL T1,ACCUM
	CAILE T1,2
	JRST BADFLG	;BAD FLAG BYTE
	HLL T2,CYL
	HRR T2,HEAD
	EXCH HEAD,(P)
	EXCH CYL,-1(P)
	PUSH P,T1	;SAVE FLAG BYTE
	PUSHJ P,GENHW0
	POP P,T1
	POP P,HEAD
	POP P,CYL
	CAIE T1,2	;DO NOT FORMAT IF MARKING BAD
	PUSHJ P,TRKFMT	;IN CASE THIS IS THE ALTERNATE
	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	PUSHJ P,UNIGO
	 JRST CMDSET
	JRST CMDSET

BADFLG:	OASC [ASCIZ /BAD FLAG BYTE
/]
	JRST FLGAGN
;CONSTANTS

LBNHOM==1	;FIRST HOME BLOCK
LB2HOM==6	;SECOND HOME BLOCK

BLKNAM==0	;BLOCK NAME STORED HERE
BLKCOD==776	;CODE STORED HERE
BLKSLF==777	;OWN ADDRESS STORED HERE

HOMHID==1	;PHYSICAL UNIT ID IN HOME BLOCK
HOMSRC==3	;NUMBER OF STR IN SYS SEARCH LIST (-1 IF NOT IN)
HOMSNM==2	;FILE STRUCTURE NAME (0 IF NOT IN STR)
HOMLOG==5	;LOGICAL UNIT NAME (AS DSKB3)
;HOMHOM==12	;HOME BLOCK ADDRESS (LBNHOM,,LB2HOM)
HOMSUN==12	;NUMBER OF UNIT IN SWAP LIST (-1 IF NOT IN)
HOMCOP==774	;DATE OF LAST PACKCOPY

BATCNT==3	;COUNT OF NUMBER OF BAD REGIONS
BATSEC==2	;NUMBER OF BAD SECTORS
BATFIR==1	;RELATIVE AOBJN POINTER TO DATA AREA
BATNBB==0	;WITHIN 2 WORD GROUP. WORD OF NUMBER BAD(-1)
 BASNBB==^D9	;SIZE OF BYTE FIELD
 BANNBB==^D8	;POSITION
BATELB==1	;R.H. FIRST LOGICAL BLOCK OF BAD REGION
BATDAT==0	;R.H. DATE IN DAYS SINCE JAN 1,1964 GMT
BATREG==4	;FIRST WORD OF BAT BLOCK DATA
BRMAX==BLKCOD-BATREG	;SPACE WE HAVE

HOMPTR:	LBNHOM,,LB2HOM	;FIRST AND SECOND HOME BLOCKS
	SIXBIT /HOM/	;NAME WHICH SHOULD BE IN BLKNAM
	070717	;CODE IN BLKCOD
	SIXBIT /HOME/	;WHAT TO CALL IT ON PRINTOUT

BATPTR:	LBNHOM+1,,LB2HOM+1
	SIXBIT /BAT/
	505050
	SIXBIT /BAT/
REDVER:	MOVEI T4,0	;FLAG, 0 NEITHER READ
RDVNXB:	HLRZ T1,(K)	;PICK UP ADDRESS
	TRNE T4,-1	;R.H. IS -1 IF READING SECOND
	HRRZ T1,(K)
	HLRS CMD
	HLRS DAT
	ADDI DAT,1000	;PUT THE DATA AREA FIRST
IFN <RECPAG-1>,<IMULI T1,RECPAG
	PUSH P,T1>
	PUSHJ P,TRANS	;TRANSLATE ADDRESS
	PUSHJ P,GENSKF	;GENERATE FULL SEEK (WITH RECORD)
	PUSHJ P,GENSID	;AND SEARCH ID=
	MOVSS DAT	;GET BACK THE CORRECT DATA AREA
	PUSHJ P,GENRED	;AND READ
%%Z==1
	REPEAT RECPAG-1,<ADDI DAT,RECSIZ
	MOVSS DAT
	AOS T1,(P)
	PUSHJ P,TRANS
	PUSHJ P,GENSKF
	PUSHJ P,GENSID
	MOVSS DAT
	PUSHJ P,GENRED>
IFN <RECPAG-1>,<POP P,T1
	HRLI DAT,-RECSIZ*<RECPAG-1>(DAT)>
;*;	HLRS DAT	;*WRONG* LH has CYL,HEAD,REC bytes
	HRLS DAT	;RH points to the page of data just read in
	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	PUSHJ P,UNIGO
	 JRST RDVERR
	MOVE T1,BLKNAM(DAT)
	MOVE T2,BLKCOD(DAT)
	CAMN T1,1(K)	;CHECK WITH EXPECTED
	CAME T2,2(K)
	JRST RDVCON	;CONSISTANCY ERROR
	HLRZ T1,(K)
	TRNE T4,-1
	HRRZ T1,(K)
	MOVE T2,BLKSLF(DAT)
	TLZ T2,777776	;GET RID OF EXTRA BITS
	CAME T1,T2
	JRST RDVCON
	JUMPN T4,CPOPJ1	;IF T4 NON-ZERO HAVE READ BOTH
	HLLOS T4	;SET T4 R.H. TO FORCE SECOND TO READ
	JRST RDVNXB	;AND GO

;T4=0,0 READ FIRST NONE READ
;T4=-1,0 READ FIRST ERROR READING SECOND
;T4=0,-1 READ SECOND NO ERROR ON FIRST
;T4=-1,-1 READ SECOND ERROR READING FIRST

RDVERR:	MOVEI T1,[ASCIZ /HARDWARE READ ERROR
/]
RDVER1:	PUSHJ P,RDVERP	;PRINT
	JUMPL T4,CPOPJ	;FAIL IF L.H. T4 NOT 0 (BOTH BAD)
	SETCA T4,
	JRST RDVNXB

RDVCON:	TLNE K,-1	;THIS IS A FLAG FOR NO ERROR MSG
	POPJ P,
	MOVEI T1,[ASCIZ /CONSISTANCY ERROR
/]
	JRST RDVER1

RDVERP:	PUSH P,T1
	MOVEI T1,[ASCIZ /FIRST /]
	TRNE T4,-1
	MOVEI T1,[ASCIZ /SECOND /]
	OASC (T1)
	OSIX 3(K)	;NAME
	OASC [ASCIZ / BLOCK /]
	POP P,T1
	OASC (T1)
	POPJ P,
SUBTTL	WRTVER - Write and verify HOME/BAT pages

WRTVER:	MOVE	T1,1(K)		;WRITE OUT A PAIR OF BLOCKS (HOME, BAT)
	MOVEM	T1,BLKNAM(DAT)	;SIXBIT/HOM/ OR SIXBIT/BAT/
	MOVE	T1,2(K)
	MOVEM	T1,BLKCOD(DAT)	;UNLIKELY CODE
	HLRZ	T1,(K)		;PAGE NUMBER
	PUSHJ	P,WRTVR1	;WRITE THE FIRST ONE
	  POPJ	P,		;ERROR
	HRRZ	T1,(K)		;AND THE SECOND ONE
WRTVR1:	HLRS	DAT		;RESET RH BACK TO START OF PAGE
	HLRS	CMD		;RESET BACK TO START OF COMMAND LIST
	DPB	T1,[POINT 19,BLKSLF(DAT),35]	;SET SELF
	ADDI	DAT,1000	;DATA AREA FOR GENSKF/GENSID
IFN <RECPAG-1>,<IMULI T1,RECPAG
	PUSH	P,T1>		;SAVE STARTING BLOCK NUMBER
	PUSHJ	P,TRANS		;TRANSLATE ADDRESS
	PUSHJ	P,GENSKF	;GENERATE SEEK
	PUSHJ	P,GENSID	;GENERATE SEARCH ID
	MOVSS	DAT		;POINT TO DATA AGAIN
	PUSHJ	P,GENWRT	;WRITE FIRST BLOCK OF PAGE
%%Z==1
REPEAT RECPAG-1,<
	ADDI	DAT,RECSIZ	;POINT TO START OF NEXT BLOCK
	MOVSS	DAT		;FOR GENSKF/GENSID
	AOS	T1,(P)		;GET NEXT BLOCK NUMBER
	PUSHJ	P,TRANS
	PUSHJ	P,GENSKF
	PUSHJ	P,GENSID
	MOVSS	DAT		;BACK TO PAGE AREA
	PUSHJ	P,GENWRT	;DO PAGE+200, PAGE+400, PAGE+600
>
IFN <RECPAG-1>,<
	POP	P,T1		;RESET DAT FROM PAGE+600 BACK TO PAGE+000
	HRLI	DAT,-RECSIZ*<RECPAG-1>(DAT)>
IFE <RECPAG-1>,<HRLS DAT>	;RESET TO START OF PAGE
	MOVSI	T1,(BYTE (8) 200)
	MOVEM	T1,(CMD)	;HALT I/O
	PUSHJ	P,UNIGO
	  POPJ	P,
	JRST	CPOPJ1	;NO ERRORS
SUBTTL	GENSKF/GENWRT/GENRED

GENSKF:	PUSHJ P,GENSEK
	DPB REC,[POINT 8,-1(DAT),23]	;PUT IN RECORD
	POPJ P,

GENWRT:	MOVSI T2,(BYTE (8) WRDMOD,WRT33)
	SKIPA
GENRED:	MOVSI T2,(BYTE (8) WRDMOD,RED33)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE (12) -RECSIZ)
	MOVEM T2,1(CMD)
	ADDI CMD,2
	POPJ P,

REDZ.C==2
REDZ.D==RECSIZ

TRANS:	IDIVI T1,RECCYL		;Translate block number to CYL,HEAD,REC
	MOVE CYL,T1
	MOVE T1,T2
	IDIVI T1,RECTRK
	MOVE HEAD,T1
	MOVEI REC,1(T2)		;Records are numbered 1-18, not 0-17
	POPJ P,
SUBTTL	"FORMAT" - Rewrite COUNT-KEY-DATA on pack

FORMAT:	PUSHJ P,REDDRV	;READ A LIST OF DRIVES TO FORMAT
	SETZM SPCLNK	;THIS IS A FLAG THAT SOMEONE WANTS SPACE
FMTLP:	PUSHJ P,@DRVDSP	;GET THE NEXT DRIVE NUMBER
	 JRST FMTLP3	;ALL DRIVES COMPLETED OR BAD OR SOMETHING
	MOVE T1,UNISTS(U)	;GET STATUS OF UNIT
	TLNE T1,NOWRT		;AND SEE IF WRITE PROTECTED
	JRST FMTWPT	;TELL HIM THE DRIVE IS WRITE PROTECTED
	TLNN T1,NOFMT
	JRST FMTAST	;SAYS FORMATED, ASK IF REFORMAT
FMTLP1:	MOVE T1,SPCLNK
	MOVEM T1,UNISAC(U)
	HRRZM U,SPCLNK	;MAKE A LIST FOR STARTING
	JRST FMTLP	;BUT AFTER ALL QUESTIONS

FMTLP3:	HRRZ U,SPCLNK	;GET NEXT UNIT NOT STARTED
	JUMPE U,ALLCMP	;ANG GET GOING IF NONE THERE
	MOVE T1,MEMFRE
	ADDI T1,FMTZ.C+FMTZ.D
	CAML T1,MEMSIZ
	JRST FNOMEM	;NOT ENOUGH MEMORY
	MOVE CMD,MEMFRE
	MOVEM T1,MEMFRE	;UPDATE FREE MEMORY
FMTLP2:	MOVEI DAT,FMTZ.C(CMD)	;SET DATA SIZE
	MOVE T1,UNISAC(U)	;NEXT LINK ON CHAIN
	MOVEM T1,SPCLNK
	PUSHJ P,QUEUNT	;QUE THE UNIT FOR THE TRANSFER
	 JRST FMTDO	;GO TO DO ACTUAL WORK FOR ONE UNIT
	JRST FMTLP3	;CONTINUE SETTING THINGS UP

ALLCMP:	PUSHJ P,ALLWAT	;WAIT FOR ALL UNITS TO COMPLETE
	JRST CMDSET	;FINISHED, NEXT COMMAND

FMTWP:	OASC [ASCIZ /
UNIT #U IS WRITE PROTECTED, NOT FORMATED
/]
	POPJ P,

FNOMEM:	HRRZM U,SPCLNK	;SET LINK
	PUSHJ P,ALLWAT
	HLRZ CMD,SPCLNK		;GET THE FREE LOCATION
	JRST FMTLP2	;AND CONTINUE SETTING UP FORMATTING

FMTWPT:	PUSHJ P,FMTWP
	JRST FMTLP

FMTAST:	OASC [ASCIZ /
UNIT #U IS ALREADY FORMATTED, REFORMAT? /]
	PUSHJ P,REDLIN
	PUSHJ P,YESNO
	 JRST FMTLP	;HE SAID NO  (AT LEAST NOT YES)
	JRST FMTLP1	;REFORMAT
QUEUNT:	MOVE T1,(P)
	MOVEM T1,UNIPC(U)	;SET UP PC
	MOVEI T1,1
	MOVEM T1,UNIIOW(U)
	MOVEM 17,UNISAC+17(U)	;SAVE AC'S
	MOVEI 17,UNISAC(U)
	BLT 17,UNISAC+16(U)
	MOVE 17,UNISAC+17(U)
	MOVEI T1,UNIPDL-1(U)
	MOVEM T1,UNISAC+P(U)
	AOS DEVWAT	;ONE MORE WAITER
CPOPJ1:	AOS (P)
	POPJ P,

ALLWAT:	MOVEM 17,SAVAC+17
	MOVEI 17,SAVAC
	BLT 17,SAVAC+16
	MOVE 17,SAVAC+17
	JRST WAIT	;WAIT FOR UNITS TO FINISH

YESNO:	PUSHJ P,SCAN
	JUMPN T1,CPOPJ
	MOVS T1,ACCUM
	CAIE T1,'YES'
	CAIN T1,'YE '
	JRST CPOPJ1
	CAIN T1,'Y  '
	AOS (P)
	POPJ P,
FMTDO:	HRLS DAT
	HRLS CMD	;SAVE STARTING ADDRESSES
	PUSHJ P,AFRMT
;*;	  JRST FMTER2	;COULD NOT SET ALTERNATE TRACK FORMATS
	  OASC [ASCIZ/
Warning: The alternate tracks on this pack are untrustworthy.
Use the REFRESH or AFORMAT commands to re-format the alternate tracks.
/]			;Continue anyway
	MOVEI	CYL,<CYLS/2>-1	;3330-1 (100 megabyte = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI	CYL,CYLS-1	;SET CORRECT NUMBER OF CYLINERS
	HLRS DAT
	HLRS CMD
FMTCYL:	MOVEI HEAD,HEADS-1
FMTHED:	PUSHJ P,GENSEK	;GENERATE A SEEK
	CAIN HEAD,HEADS-1
	PUSHJ P,GENSC0		;GENERATE A SET SECTOR TO 0
	PUSHJ P,GENSID	;GENERATE A SEARCH ID AND TIC
	PUSHJ P,TRKFMT	;GENERATTE 1 TRACK OF FORMAT
	SOJGE HEAD,FMTHED	;NOW FOR THE REST OF THE HEADS
FMTCYD:	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	MOVNI T3,1	;RETRY COUNTER FIRST ERROR
FMTRTY:	HLRZ T1,CMD	;RETRY HERE
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	 JRST FMTERR	;THERE IS A FORMAT ERROR
FMTCY:	HLRS CMD
	HLRS DAT
	SOJGE CYL,FMTCYL
	PUSHJ P,VERIFY	;NOW VERIFY THE FORMATTED PACK
	 JRST NOFVF	;NOT VERIFIED
	OASC [ASCIZ /
FORMATTED AND VERIFIED, UNIT #U
/]
FMTENC:	SKIPN SPCLNK	;IS THERE A SPACE WAITER
	JRST WAIT	;NO, GO TO THE WAIT LOOP
	HLLM CMD,SPCLNK	;YES, GIVE HIM OUR SPACE
	JRST MAINGO	;AND START THINGS UP

NOFVF:	OASC [ASCIZ /
UNIT #U DOES NOT VERIFY
/]
	JRST FMTENC
GENSC0:	MOVSI T2,(BYTE (8) BYTMOD,SETSEC)	;SET SECTOR
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	MOVEI T2,-2(DAT)	;FOR SECTOR 0 USE 0 BYTES OF SEEK
	HRLI T2,(BYTE (12) -1)
	MOVEM T2,1(CMD)
	ADDI CMD,2
	POPJ P,

SECZ.C==2
SZSDAT==2

FMTERR:	TLNN T1,UCHK
	JRST FMTER1	;NO A UNIT CHECK SO NOT OFF-LINE
	MOVE T1,UNISNS(U)
	TLNE T1,(BYTE (8) 0,10)	;CHECK FOR NO RECORD FOUND
	JRST FMTNRC	;NO RECORD, CHECK ALTERNATE TRACKS
	TLNN T1,(BYTE (8) 0,2)	;SET FOR WRITE LOCK
	JRST FMTER1
	PUSHJ P,FMTWP	;SAY WRITE PROTECT
	JRST FMTENC	;AND TERMINATE

FMTER1:	PUSHJ P,COMERR
	 JRST FMTRTY	;NEED TO RETRY
FMTER3:	PUSHJ P,COMERP
	OASC [ASCIZ /Continuing FORMAT anyway
/]
	JRST FMTCY	;[JMS]

FMTER2:	OASC [ASCIZ /FORMAT ABORTED
/]
	JRST FMTENC

TRKFMT:	MOVSI REC,-RECTRK	;18 RECORDS
	MOVEI T1,BYTSIZ
	PUSHJ P,GENWCK
	AOBJN REC,.-2
	MOVEI T1,1	;1 BYTE
	MOVEI REC,XTRREC-1	;WILL GENERATE RECORD 100 ACTUALLY
	
	JRST GENWCK	;A FINAL WRITE COUNT KEY DATA

FMTNRC:	PUSHJ P,COMERR	;MAKE SURE MESSAGE PRINTS
	 JFCL
	PUSHJ P,COMERP
	PUSHJ P,ATRCHK	;CHECK ON ALTERNATE TRACK ERROR
	 SKIPA
	JRST FMTER3
	OASC [ASCIZ /NOTIFY THE SHIFT SUPERVISOR
SAVE THIS PRINTOUT WITH PACK
/]
	JRST FMTER2
;VERIFY SUBROUTINE, CMD AND DAT SET UP (ALSO U OF COURSE)
;SKIP RETURN IF OK, NOFMT HAS BEEN RESET
;ON NON-SKIP RETURN, NOFMT HAS BEEN SET JUST TO MAKE SURE

VERIFY:	HRLS DAT
	HRLS CMD	;JUST TO MAKE SURE
	PUSHJ P,AVERIF	;CHECK ALTERNATE TRACKING
;*;	 POPJ P,	;DO NOT MARK UNFORMATTED IF BAD
	OASC	[ASCIZ /ATTEMPTING TO VERIFY REST OF PACK ANYWAY
/]
	HLRS DAT
	HLRS CMD
	MOVEI CYL,<CYLS/2>-1	;3330-1 (100 megabyte = RP04)
	MOVSI T1,SNGDNS
	TDNN T1,UNISTS(U)
	MOVEI CYL,CYLS-1
VERCYL:	MOVEI HEAD,HEADS-1
VERHED:	PUSHJ P,GENSEK
	CAIN HEAD,HEADS-1
	 PUSHJ P,GENSC0
	PUSHJ P,GENSID
	MOVEI T1,RECTRK+1
	PUSHJ P,GENRCN	;GENERATE SOME READ COUNTS
	SOJG T1,.-1
	SOJGE HEAD,VERHED
	MOVSI T1,(BYTE (8) 200)
	MOVEM T1,(CMD)
	MOVNI T3,1
VERRTY:	HLRZ T1,CMD
	PUSHJ P,STRTU
	SKIPE T1,UNIERF(U)
	JRST VERERR
	MOVEI	HEAD,HEADS-1	;NO CHECK THE DATA
	HLRS DAT
VERDHD:	MOVSI REC,-RECTRK	;NORMALLY 18 RECORDS
	ADDI DAT,2	;FOR THE SEEK DATA
VERREC:	MOVEI T1,BYTSIZ
	PUSHJ P,CHKREC	;CHECK DATA FOR 1 RECORD
	 JRST BADVER	;WRONG DATA
	AOBJN REC,VERREC
	MOVEI T1,1
	MOVEI REC,XTRREC-1
	PUSHJ P,CHKREC
	 JRST BADVER
	SOJG HEAD,VERDHD	;FINAL CHECK FOR RECORD 100
	HLRS CMD
	HLRS DAT
	SOJGE CYL,VERCYL
	MOVSI T1,NOFMT
	ANDCAM T1,UNISTS(U)
	JRST CPOPJ1

BADVER:	MOVSI T1,NOFMT
	IORM T1,UNISTS(U)	;JUST TO MAKE SURE
	POPJ P,


GENRCN:	MOVSI T2,(BYTE (8) BYTMOD,RCNT)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE (12) -10)
	MOVEM T2,1(CMD)
	SETZM (DAT)
	SETZM 1(DAT)
	ADDI DAT,2
	ADDI CMD,2
	POPJ P,

CHKREC:	LDB T2,[POINT 16,1(DAT),31]
	CAME T2,T1
	POPJ P,
	LDB T2,[POINT 16,(DAT),15]
	CAIE T2,(CYL)
	POPJ P,
	LDB T2,[POINT 16,(DAT),31]
	CAIE T2,(HEAD)
	POPJ P,
	LDB T2,[POINT 8,1(DAT),7]
	CAIE T2,1(REC)
	POPJ P,
	LDB T2,[POINT 8,1(DAT),15]
	JUMPN T2,CPOPJ
	ADDI DAT,2
	JRST CPOPJ1

VERERR:	TLNN T1,UCHK
	JRST VERER1
	MOVE T1,UNISNS(U)
	TLNN T1,(BYTE (8) 0,10)	;NO RECORD FOUNT
	JRST VERER1
	PUSHJ P,ATRCHK	;CHECK ALTERNATE TRACK ERROR
	 JRST BADVER	;IT IS
	OASC [ASCIZ /
UNIT #U INCORRECT FORMAT
/]
	JRST BADVER

VERER1:	PUSHJ P,COMERR
	 JRST VERRTY
	PUSHJ P,COMERP
	JRST BADVER
;CHECK ON ALTERNATE TRACK TO SEE IF BAD INFO THERE

ATRCHK:	PUSHJ P,FNDERR	;THIS SHOULD SET CYL AND HEAD TO CORRECT VALUES
	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST CPOPJ1	;JUST SAY NOT BAD FORMAT
	LDB T1,[POINT 2,(DAT),7]
	CAIE T1,2	;DOES THIS ONE SAY BAD?
	JRST CPOPJ1	;NO
	PUSH P,CYL
	PUSH P,HEAD	;SAVE INFORMATION
	LDB CYL,[POINT 16,1(DAT),15]
	LDB HEAD,[POINT 16,1(DAT),31]
	HLRS DAT
	HLRS CMD
	PUSHJ P,GENSEK
	PUSHJ P,GENHR0
	PUSHJ P,UNIGO
	 JRST ERRPJ1	;GET STUFF OFF STACK AND SKIP
	POP P,HEAD
	POP P,CYL	;GET BACK CYL AND HEAD
	LDB T1,[POINT 2,(DAT),7]
	CAIE T1,1
	JRST ATRERR	;IT IS WRONG
	LDB T1,[POINT 16,1(DAT),15]
	LDB T2,[POINT 16,1(DAT),31]
	CAMN T1,CYL
	CAME T2,HEAD
	SKIPA
	JRST CPOPJ1	;THAT LOOKS OK, LET OTHER MSG COME OUT
ATRERR:	OASC [ASCIZ /
UNIT #U BAD ALTERNATE TRACK SETUP ON CYL #C HEAD #H
GIVE THIS PACK AND PRINTOUT TO THE SHIFT SUPERVISOR
/]
	POPJ P,		;AND RETURN

ERRPJ1:	POP P,T1
	POP P,T1
	JRST CPOPJ1
SUBTTL	"VERIFY" - Verify that all pages can be read

VERCMD:	PUSHJ P,REDDRV
	SETZM SPCLNK
VERLP:	PUSHJ P,@DRVDSP
	 JRST ALLCMP	;FINISHED
	MOVE T1,MEMFRE
	ADDI T1,FMTZ.C+FMTZ.D	;SAME SIZES AS FOR FORMAT
	CAML T1,MEMSIZ
	JRST VNOMEM
	MOVE CMD,MEMFRE
	MOVEM T1,MEMFRE
VERLP2:	MOVEI DAT,FMTZ.C(CMD)
	PUSHJ P,QUEUNT
	 JRST VERDO	;GO DO THE ACTUAL WORK
	JRST VERLP	;NEXT

VNOMEM:	HRRZM U,SPCLNK
	PUSHJ P,ALLWAT
	HLRZ CMD,SPCLNK
	SETZM SPCLNK
	JRST VERLP2

VERDO:	PUSHJ P,VERIFY
	 JRST NOFVF	;SAME AS FOR NON-VERIFY ON FORMAT
	OASC [ASCIZ /
VERIFIED UNIT #U
/]
	JRST FMTENC	;SAME AS END FOR FORMAT
;GENERATE A SEEK

GENSEK:	MOVSI T2,(BYTE (8) BYTMOD,SEEK)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE (12) -6)
	MOVEM T2,1(CMD)
	ADDI CMD,2
	SETZM (DAT)
	DPB CYL,[POINT 16,(DAT),31]
	SETZM 1(DAT)
	DPB HEAD,[POINT 16,1(DAT),15]
	ADDI DAT,2
	POPJ P,

GENSID:	MOVSI T2,(BYTE (8) BYTMOD+OFFSET,SRCIDE)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	MOVEI T2,-2(DAT)
	HRLI T2,(BYTE (12) -5)
	MOVEM T2,1(CMD)
	HRRZ T2,CMD
	HRLI T2,TIC
	MOVEM T2,2(CMD)
	ADDI CMD,3
	POPJ P,

GENWCK:	MOVSI T2,(BYTE (8) BYTMOD!IGNLEN,WCKD)
	MOVEM T2,(CMD)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,(CMD),23]
	HRRZ T2,DAT
	HRLI T2,(BYTE(12) -10)
	MOVEM T2,1(CMD)
	ADDI CMD,2
	SETZM 1(DAT)
	DPB T1,[POINT 16,1(DAT),31]
	DPB CYL,[POINT 16,(DAT),15]
	DPB HEAD,[POINT 16,(DAT),31]
	MOVEI T2,1(REC)
	DPB T2,[POINT 8,1(DAT),7]
	ADDI DAT,2
	POPJ P,

SEKZ.C==2
SEKZ.D==2	;SIZES FOR SEEK
SIDZ.C==3	;AND FOR SEARCH ID=
SZIDAT==0	;DATA FROM SEEK
WCKZ.C==2
WCKZ.D==2
SUBTTL	"SHH" - Quiets the bell

QUIET:	SETZM BELFLG
	JRST CMDLP	;JUST RESET FLAG TO RING BELL

SUBTTL	"SWITCH" - Print settings of the sense switches

PRTSWS:	OASC [ASCIZ /
SENSE SWITCH SETTINGS FOR THE COPY COMMAND ARE:

/]
	OASC MDOBAT
	OASC MNOBAT
	CRLF
	OASC MNOERR
	OASC MDOERR
	CRLF
	OASC MDOALT
	OASC MNOALT
	JRST CMDLP
SUBTTL	"BOOTS" - Load BOOTS from disk pages 3,4,5

LOAD:	CONO	APR,1B19	;LOAD BOOTS FROM THE DISK
	CONO	PI,1B23
	MOVEI	T1,SAXBAS
	MOVEM	T1,BASEA
	MOVSI	T4,-SAXN
BPLOOP:	XCT	BPCNI(T4)	;READ STATUS TO T1
	JUMPN	T1,SAFND	;FOUND AN SA10
BPLOO1:	MOVEI	T1,20
	ADDM	T1,BASEA	;SET BASE ADDRESS FOR NEXT SA10
	AOBJN	T4,BPLOOP	;NOT DONE SO TRY NEXT SA10
	OASC	[ASCIZ /
CAN NOT FIND BOOTS - RESTARTING
/]
	JRST	RESTRT

SAFND:	MOVEI	T3,SRGO		;STATUS REQ. FOR CHAN 0
	MOVEI	T2,1B29		;STATUS FLAG FOR CHAN 0
	JRST	SAFND3		;SET UP FLAGS
SAFND1:	MOVEI	T1,^D100000	;LOOP COUNTER
	XCT	BPCNO1(T4)	;STATUS REQ CONO
	TRC	T3,100		;CHANGE STATUS REQUEST TO GO
	XCT	BPCNO2(T4)	;STATUS STORED?
	SOJG	T1,.-1		;WAIT A WHILE
	JUMPG	T1,CHFND	;BUT NOT TOO LONG A WHILE
SAFND2:	LSH	T2,-1		;NEXT CHANNEL
	ADDI	T3,10	
SAFND3:	HRRM	T3,CHGO(T4)	;UPDATE CHANNEL  NUMBER
	TRC	T3,240		;CHANGE GO TO CLEAR STATUS
	HRRM	T3,CHCLR(T4)
	TRC	T3,340		;CHANGE CLEAR STATUS TO REQUEST STATUS
	TRNN	T2,1B33		;LAST CHANNEL?
	 JRST	SAFND1	;NO
	JRST	BPLOO1	;YES. TRY NEXT SA10

CHFND:	MOVE	C,T3
	LSH	C,-1
	ANDI	C,14		;ISOLATE CHANNEL NUMBER*4
	ADD	C,BASEA		;SET BASE ADDRESS FOR THIS CHANNEL
	MOVE	T1,ENDLTC	;TIC TO EOL-1 (NO-OP)
	MOVEM	T1,(C)
	MOVE	T1,NOOPD0	;NO-OP TO DEVICE 0
CHFN1:	MOVEM	T1,ENDLST-1	;CHANNEL COMMAND WORD
	PUSHJ	P,STRTIT	;START DEVICE
	JRST	UTFND		;FOUND WORKING UNIT
CHFN2:	CAMN	T1,MAXDEV	;LAST DEVICE?
	JRST	SAFND2		;YES. TRY NEXT CHANNEL
	ADDI	T1,1B23		;ERROR. TRY NEXT UNIT NUMBER
	JRST	CHFN1		;NO. TRY NEXT ONE
UTFND:	MOVE	K,CMDTIC	;SET UP TO START COMMAND LIST
	MOVEM	K,(C)
	MOVEI	S,CMDLST	;FIX UP ADDRESS
	MOVE	DAT,[POINT 8,(S),23]; DEVICE ADDRESS IN COMMAND LIST
	LDB	CMD,[POINT 8,ENDLST-1,23]; GET DEVICE ADDRESS
	MOVE	U,[POINT 8,(S),7]	;TO GET CODE
	MOVE	K,MEMSIZ
	SUBI	K,4000-137
UTFND1:	LDB	CH,U
	CAIN	CH,100	;TIC
	 AOJA	S,UTFND1
	CAIN	CH,240	;NOP AT END
	 JRST	UTFNDE
	DPB	CMD,DAT	;STORE UNIT
	ADDI	S,1
	CAIN	CH,160	;IS IT READ
	SKIPN	ENDLST	;AND RELOC NOT DONE
	 AOJA	S,UTFND1
	ADDM	K,(S)
	AOJA	S,UTFND1

UTFNDE:	SETZM	ENDLST	;CLEAR TERMINATOR
	PUSHJ	P,STRTIT	;START DEVICE
	  JRST	RDDONE	;READ COMPLETED O.K.
	JRST	CHFN2	;NO GOOD. TRY NEXT DEVICE
RDDONE:	HRRZ	S,MEMSIZ	;GET BOOTS STARTING ADDRESS
	MOVE	K,140-4000(S)	;CHECK FIRST WORD
	CAME	K,LOAD
	 JRST	CHFN2	;NOT BOOTS
	OASC [ASCIZ /
BOOTS LOADED
/]
	JRST	140-4000(S)		;ALL GOOD. GO START BOOTS
;
STRTIT:	HRRZ	U,CHCLR(T4)
	TRO	U,1B30		;SET THE SET BIT
	XCT	STSET(T4)	;SET STATUS FLAG SO CLR CAN FOLLOW GO
	XCT	CHGO(T4)
	MOVEI	K,0
STRT2:	XCT	CHCLR(T4)
	MOVEI	U,^D100000	;TIME OUT LOOP
	XCT	BPCNO2(T4)	;WAIT FOR STATUS STORED
	SOJG	U,.-1
	JUMPE	U,STRT4		;TIMED OUT
	CAIE	K,0		;PREVIOUS BUSY STATUS?
	HRLZI	K,BSY		;YES. MAKE THIS ONE BUSY + NEW STATUS
	IOR	K,1(C)	;GET STATUS WORD
	TLNN	K,BSY		;BUSY?
	JRST	STRT3	;NO.
	TLNE	K,SM		;BUSY AND STATUS MODIFIER?
	JRST	STRT2	;YES. WAIT FOR CONTROL UNIT END
	TLNE	K,CUE		;BUSY AND CONTROL UNIT END?
	JRST	STRTIT	;YES. RESTART
STRT3:	TLNN	K,175114	;ANY ERRORS?
	POPJ	P,
	TLNE K,SELERR		;WAS IT SELECT ERROR?
	TRO T1,7B23	;YES USE NEXT KONTROLLER
STRT4:	XCT	RSET(T4)	;YES. RESET SA-10
	SKIPN	U		;TIMED OUT?
	MOVE	T1,MAXDEV	;GO TO NEW CHANNEL
	AOS	(P)		;AND SKIP RETURN
	POPJ	P,

	DEFINE GSAX (A,B)
<%%SX==0
	REPEAT SAXN,<GSAX1 (A,B,\%%SX)
	%%SX==%%SX+1>>

	DEFINE GSAX1 (A,B,C)
<	A SA'C,B>
STSET:	GSAX (CONO,(U))
RSET:	GSAX (CONO,400000)
CMDTIC:	XWD	200000,CMDLST
SRGO==440
CHGO:	GSAX (CONO,440)
CHCLR:	GSAX (CONO,600)
BPCNI:	GSAX (CONI,T1)
BPCNO1:	GSAX (CONO,(T3))
BPCNZ2:	GSAX (CONSZ,(T2))
BASEA:	SAXBAS
ENDLTC:	XWD	200000,ENDLST-1
MAXDEV:	BYTE	(8)240,3,377
BPCNO2:	GSAX (CONSO,(T2))
NOOPD0:	BYTE	(8)240,3,300


;This is the command list to read in BOOTS from the HOM pages

CMDLST:	BYTE	(8)72,7		;SEEK
	BYTE	(12)-6(24)ENDLST+1	;SEEK ARG POINTER
	BYTE	(8)73,61	;SEARCH ID=
	BYTE	(12)-5(24)ENDLST+1
	XWD	200000,.-2
IFE RECTRK-^D18,<	;3330 Formatted in blocks
	BYTE (8)160,6
	BYTE (12)-200(24)0001
	BYTE (8)160,6
	BYTE (12)-200(24)0201
	BYTE (8)160,6
	BYTE (12)-200(24)0401
	BYTE (8)160,6
	BYTE (12)-200(24)0601
	BYTE (8)160,6
	BYTE (12)-200(24)1001
	BYTE (8)160,6
	BYTE (12)-200(24)1201
	BYTE (8) 72,7		;SEEK
	BYTE (12) -6(24) C0H1R1
	BYTE (8) 73,61		;SEARCH ID=
	BYTE (12) -5(24) C0H1R1
	XWD 200000,.-2
	BYTE (8) 160,6
	BYTE (12)-200(24)1401
	BYTE (8) 160,6
	BYTE (12)-200(24)1601
	BYTE (8) 160,6
	BYTE (12)-200(24)2001
	BYTE (8) 160,6
	BYTE (12)-200(24)2201
	BYTE (8) 160,6
	BYTE (12)-200(24)2401
	BYTE (8) 160,6
	BYTE (12)-200(24)2601
	BYTE	(8)240,3	;NO-OP
ENDLST:	1
	BYTE	(8)0,0,0,0,0,0,15	;CYL 0 HEAD 0 RECORD ^D13
>
IFE RECTRK-^D5,<	;3330 Formatted in pages
	BYTE (8)160,6
	BYTE (12)-1000(24)0001
	BYTE (8)160,6
	BYTE (12)-1000(24)1001
	BYTE (8) 72,7		;SEEK
	BYTE (12) -6(24) C0H1R1
	BYTE (8) 73,61		;SEARCH ID=
	BYTE (12) -5(24) C0H1R1
	BYTE (8) 160,6
	BYTE (12)-1000(24)2001
	BYTE	(8)240,3	;NO-OP
ENDLST:	1
	BYTE	(8)0,0,0,0,0,0,4	;CYL 0 HEAD 0 RECORD ^D4
>
IFE RECTRK-^D7,<	;3650 Formatted in pages
	BYTE (8)160,6
	BYTE (12)-1000(24)0001
	BYTE (8)160,6
	BYTE (12)-1000(24)1001
	BYTE (8) 160,6
	BYTE (12)-1000(24)2001
	BYTE	(8)240,3	;NO-OP
ENDLST:	1
	BYTE	(8)0,0,0,0,0,0,4	;CYL 0 HEAD 0 RECORD ^D4
>
IFN <RECTRK-^D18>*<RECTRK-^D5>*<RECTRK-^D7>,<
	PRINTX ?Unknown value of RECTRK detected at CMDLST>
C0H1R1:	BYTE (8) 0,0,0,0,0,1,1		;CYL 0 HEAD 1 RECORD 1
BSY==(BYTE (8)0,20)
CUE==(BYTE (8)0,40)
SM==(BYTE (8)0,100)
SUBTTL	TTY initialization (set KL10 flag if appropriate)

TTYINI:	SETZ	T1,	;CHECK PROCESSOR TYPE
	BLT	T1,0
	JUMPN	T1,KTYINI	;KL leaves 1,,1 in AC after null BLT
	MOVEI T1,NXM		;It's a KI
	MOVEM T1,NXMFLG
	MOVEM T1,CLRNXM
	DATAO PAG,[400000+UBR,,400000+EBR]
	CONO APR,APRCLK	;RESET CLOCK
	CONSO APR,APRCLK
	JRST .-1	;THEN WAIT FOR A TICK
	CONO APR,APRCLK	;AND RESET
	MOVEI T1,0
	DATAO TTY,T1	;SEND NULL
	CONSO TTY,20	;WAIT FOR DONE (TEST BUSY)
	JRST .+5
	CONSO APR,APRCLK
	JRST .-3
	CONO APR,APRCLK
	AOJA T1,.-5	;COUT CLOCK TICKS UNTIL DONE
TTYIN1:	MOVEI T2,0
	CAIGE T1,5
	MOVEI T2,2
	CAIGE T1,3
	MOVEI T2,5	;30 CPS
	MOVEM T2,TTYFIL	;SET FILL COUNT
	POPJ P,

KTYINI:	TLO	F,KL10		;FLAG KL10 CPU
	CONO	PAG,EBR		;SET UP EPT
	DATAO	PAG,[LG.LUB+UBR]
	MOVEI	T1,LP.NXM
	MOVEM	T1,NXMFLG
	TRO	T1,LP.CSF
	MOVEM	T1,CLRNXM
	SETZM	DTEMTI
	SETZM	DTEMTD
	SETZM	DTECMD
	SETZM	DTEF11
	SETZM	DTEFLG
	CONO	DTE,CL11PT
	MOVEI	T1,.DTESP	;GIVE CMD TO ENTER 2DARY PROTOCOL
	MOVEM	T1,DTECMD
	MOVEI	T2,10
KTY1:	CONO	DTE,TO11DB	;RING DOORBELL
	MOVSI	T1,10		;AND WAIT FOR COMMAND TO BE RECEIVED
	SKIPN	DTEFLG
	SOJG	T1,.-1
	JUMPG	T1,KTY2
	SOJGE	T2,KTY1
	HALT	.		;COMMAND NOT RECEIVED - DIE
KTY2:	CONO	TIM,TO.CIT	;CLEAR TIMER
	CONO	TIM,TO.SIT!TICK	;TURN TIMER ON
	MOVEI	T3,.DTCTO	;SEND NULL CHAR
	MOVEM	T3,DTECMD
	CONO	DTE,TO11DB
KTY3:	SKIPE	DTEMTD		;COUNT TICKS UNTIL DONE
	JRST	TTYIN1
	CONSO	TIM,TI.ITD
	JRST	KTY3
	CONO	TIM,TO.SIT!TICK
	AOJA	T1,KTY3

;KL TTY Output

KLTYO:	MOVEI	CH,.DTCTO(CH)
	MOVEM	CH,DTECMD
	CONO	DTE,TO11DB
	HRLM	CH,(P)
	SETZ	CH,
	EXCH	CH,DTEMTD
	JUMPE	CH,.-1
	HLRZ	CH,(P)
	ANDI	CH,377
	POPJ	P,

;KL TTY Input

KLTYI:	SKIPN	DTEMTI		;WAIT FOR INPUT READY
	JRST	.-1
	MOVE	CH,DTEF11
	SETZM	DTEMTI
	POPJ	P,
SUBTTL	TTY output routines

OUTASC:	HRLI T1,(POINT 7,0)
OUTAS1:	ILDB CH,T1
	JUMPE CH,CPOPJ	;FINISHED WHEN 0 BYTE
	CAIN CH,"#"
	JRST OASCSH
OUTAS2:	PUSHJ P,OCHR
	JRST OUTAS1

OUTOCT:	IDIVI T1,10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTOCT
	HLRZ CH,(P)
	ADDI CH,"0"
OCHR:	TLNE	F,KL10
	JRST	[SKIPE DTEMTI
		JRST .+2
		JRST .+3]
	CONSZ TTY,40	;CHECK FOR INPUT WAITING
	PUSHJ P,TTYINC	;CHHECK FOR ALTMODE AND ^O
	SKIPE CTOFLG
	POPJ P,
OCHR1:	TLNE	F,KL10
	JRST	[PUSHJ P,KLTYO
		JRST OCHR2]
	CONSZ TTY,20
	JRST .-1
	DATAO TTY,CH
OCHR2:	CAIN CH,15
	SKIPN TTYFIL
	POPJ P,	;DONE
	PUSH P,T1
	MOVE T1,TTYFIL
	MOVEI CH,177
	PUSHJ P,OCHR
	SOJG T1,.-1
	POP P,T1
	MOVEI CH,15
	POPJ P,	;FINISHED
;More TTY output routines

OUTSIX:	MOVEI T1,0
	LSHC T1,6
	MOVEI CH," "(T1)
	PUSHJ P,OCHR
	JUMPN T2,OUTSIX
	POPJ P,

OUTDEC:	IDIVI T1,^D10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTDEC
	HLRZ CH,(P)
	ADDI CH,"0"
	JRST OCHR

OASCSH:	ILDB CH,T1
	CAIN CH,"U"
	JRST OASCU
	CAIN CH,"C"
	JRST OASCC
	CAIN CH,"H"
	JRST OASCH
	CAIN CH,"R"
	JRST OASCR
	JUMPN CH,OUTAS2
	POPJ P,	;IN CASE OF NULL FOR END

OASCU:	PUSH P,T1
	MOVE T1,UNINUM(U)
	PUSHJ P,OUTOCT
	POP P,T1
	JRST OUTAS1

OASCC:	PUSH P,T1
	HRRZ T1,CYL
	PUSHJ P,OUTDEC
	POP P,T1
	JRST OUTAS1

OASCR:	PUSH P,T1
	HRRZ T1,REC
	PUSHJ P,OUTDEC
	POP P,T1
	JRST OUTAS1

OASCH:	PUSH P,T1
	HRRZ T1,HEAD
	PUSHJ P,OUTDEC
	POP P,T1
	JRST OUTAS1
;More TTY output routines
PRDAT:	PUSH P,T1
	HLRZS T1
	IDIVI T1,^D60
	PUSH P,T1
	ODEC T1
	OCHI ":"
	POP P,T1
	CAIG T1,^D9
	OCHI "0"	;MAKE SURE 2 DIGITS IN MINUTES
	ODEC T1
	POP P,T1
	HRRZS T1
	OCHI " "
PRDATO:	IDIVI T1,^D<365*4+1>	;DATE IN T1, PRINT IT
	IMULI T1,4
	ADDI T1,^D1964
	PUSH P,T1	;SAVE YEAR
	MOVE T1,T2
	CAIGE T1,^D366
	JRST BREAK1	;THIS IS A LEAP YEAR
	SUBI T1,^D366
	IDIVI T1,^D365
	ADDM T1,(P)	;ADD TO YEAR (STILL 1 SHORT)
	MOVEI T3,MONTAB+1
	AOSA (P)	;ADD ONE MORE TO YEAR AND SKIP
BREAK1:	MOVEI T3,MONTB2+1
	HRLI T3,T1	;SET UP INDEX
	MOVSI T1,-^D12
	CAML T2,@T3
	AOBJN T1,.-1
	SUBI T3,1
	SUB T2,@T3	;GET DAY
	ADDI T2,1
	PUSH P,T1	;SAVE MONTH
	ODEC T2
	POP P,T1
	OSIX MONNAM(T1)
	POP P,T2
	ODEC T2	;AND THE YEAR
	POPJ P,

	DEFINE ZOT (A)
<IRP A,<SIXBIT /-A-/>>

MONNAM:	ZOT <JAN,FEB,MAR,APR,MAY,JUNE,JULY,AUG,SEPT,OCT,NOV,DEC>

PRDATZ:	JUMPN T1,PRDAT	;JUST PRINT DATE IF THERE IS ONE
	OASC [ASCIZ /NO DATE/]
	POPJ P,		;ELSE MESSAGE
SUBTTL	LUUO handler

UUOH:	0
	LDB CH,[POINT 9,EBRADD+40,8]	;GET DISPATCH
	CAIL CH,UUONUM
	JRST UUOERR
	PUSHJ P,@UUODSP(CH)
	JRST @UUOH

UUODSP:	UUOERR
	UODEC
	UOOCT
	UOCHR
	UOCHI
	UOASC
	UOCRLF
	UOSIX
UUONUM==.-UUODSP

UUOERR:	MOVEI T1,[ASCIZ /
***UUO ERROR***
/]
	PUSHJ P,OUTASC
	JRST ABORT

UODEC:	MOVE T1,@EBRADD+40
	JRST OUTDEC

UOOCT:	MOVE T1,@EBRADD+40
	JRST OUTOCT

UOCHR:	MOVE CH,@EBRADD+40
	JRST OCHR

UOCHI:	HRRZ CH,EBRADD+40
	JRST OCHR

UOASC:	HRRZ T1,EBRADD+40
	JRST OUTASC

UOCRLF:	MOVEI T1,[ASCIZ /
/]
	JRST OUTASC

UOSIX:	MOVE T2,@EBRADD+40
	JRST OUTSIX
;BELLS
BELWAT:	MOVEI	T1,^D120
	TLNE	F,KL10
	 JRST	KLBLWT
BEL2:	CONSZ	TTY,40		;KI-10 loop
	 POPJ	P,		;CHARACTER IS WAITING TO BE READ
	CONSO	APR,APRCLK
	 JRST	BEL2
	CONO	APR,APRCLK	;CLEAR CLOCK FLAG
	SOJG	T1,BEL2		;NOT ENOUGH TIME
	SETZM	CTOFLG		;RESET CONTROL O FLAG
	OCHI	7
	JRST	BELWAT		;NOW WAIT ANOTHER 5 SECS

SUBTTL	TTY input routines

KLBLWT:	CONO	TIM,TO.SIT!TO.CTD!TICK	;KL-10 loop
KLBL1:	SKIPE	DTEMTI		;INPUT CHAR WAITING?
	POPJ	P,		;YES, GO GET IT
	CONSO	TIM,TI.ITD	;TICK?
	JRST	KLBL1
	CONO	TIM,TO.SIT!TO.CTD!TICK
	SOJG	T1,KLBL1
	SETZM	CTOFLG
	OCHI	7
	JRST	BELWAT

TSTALT:	TLNE	F,KL10
	JRST	[SKIPN DTEMTI
		JRST (T1)
		MOVE T2,DTEF11
		SETZM DTEMTI
		JRST TSTAL1]
	CONSO TTY,40	;DO A JSP T1,TSTALT TO SEE IF ALTMODE
	JRST (T1)	;NO CHR
	DATAI TTY,T2
TSTAL1:	ANDI T2,177
	CAIE T2,175
	CAIN T2,176
	JRST ABORT	;YES, ALTMODE
	CAIE T2,33
	JRST (T1)	;NOT ALTMODE, IGNORE
ABORT:	CONO PI,1B23
	CONO APR,1B19
	SETZM CTOFLG
	MOVEI P,PDL-1
	OASC [ASCIZ /

***ABORTED***

/]
	JRST @ABTDSP	;GO TO ABORT LOCATION

ABTINI:	POP P,ABTDSP
	JRST @ABTDSP	;SET ABORT LOCATION

TTYINC:	PUSH P,T1
	PUSH P,T2
	MOVEI T2,0
	JSP T1,TSTALT	;WILL ABORT IF ALTMODE WAITING
	CAIE T2,"Z"-100	;DELETE TO DISABLE ^O
	JRST TTYINN	;NOT CONTROL O
	POP P,T2
	POP P,T1
	PUSH P,CH
	MOVEI CH,"^"
	PUSHJ P,OCHR1
	MOVEI CH,"O"
	PUSHJ P,OCHR1
	MOVEI CH,15
	PUSHJ P,OCHR1
	MOVEI CH,12
	PUSHJ P,OCHR1
	SETCMM CTOFLG
	POP P,CH
	POPJ P,
TTYINN:	POP P,T2
	POP P,T1
	POPJ P,
;More TTY input routines
REDLIN:	MOVEI T1,^D100	;MAX  NUMBER OF CHRS
	MOVE T2,[POINT 7,INPBUF]
	MOVEM T2,SCNPTR	;FOR READING
	SETZM CTOFLG
	SETZM RUBFLG
	SETZM SAVCHR	;NO SAVED CHRS YET
RDLN1:	TLNE	F,KL10
	JRST	[PUSHJ P,KLTYI
		 JRST RDLN2]
	CONSO TTY,40
	JRST RDLN1
	DATAI TTY,CH
RDLN2:	ANDI CH,177
	CAIE CH,175
	CAIN CH,176
	JRST ABORT	;ABORT ON ALTMODE
	CAIN CH,33
	JRST ABORT
	CAIN CH,"O"-100
	JRST RDLN1	;IGNORE CONTROL O
	CAIN CH,"U"-100
	JRST CTLU
	CAIN CH,177
	JRST RUBOUT
	PUSHJ P,OFFRUB
	PUSHJ P,OCHR1
	SOJL T1,ENDLN2
	IDPB CH,T2
	CAIL CH,40
	JRST RDLN1
	CAIN CH,15	;IS IT RETURN
	JRST ENDLN1	;YES
ENDLN2:	MOVEI CH,15
	PUSHJ P,OCHR	;NO, SEND ONE
ENDLN1:	MOVEI CH,12
	PUSHJ P,OCHR	;AND A LINE FEED
	MOVEI CH,0
	IDPB CH,T2
	POPJ P,

OFFRUB:	SKIPN RUBFLG
	POPJ P,
	PUSH P,CH
	MOVEI CH,"\"
	PUSHJ P,OCHR1
	POP P,CH
	SETZM RUBFLG
	POPJ P,

RUBOUT:	CAIN T1,^D100
	JRST RUBCRL
	MOVEI CH,"\"
	SKIPN RUBFLG
	PUSHJ P,OCHR1	;ENTER RUBOUT MODE
	SETOM RUBFLG
	LDB CH,T2
	PUSHJ P,OCHR1
	SUBI T2,1
	REPEAT 4,<IBP T2>
	AOJA T1,RDLN1

RUBCRL:	PUSHJ P,OFFRUB
RUBCR1:	MOVEI CH,15
	PUSHJ P,OCHR1
	MOVEI CH,12
	PUSHJ P,OCHR1
	JRST REDLIN

CTLU:	PUSHJ P,OFFRUB
	MOVEI CH,"^"
	PUSHJ P,OCHR1
	MOVEI CH,"U"
	PUSHJ P,OCHR1
	JRST RUBCR1
;SCAN INPUT LINE. 4 CASES
;T1=0 ID, SIXBIT IN ACCUM
;T1=1 NUMBER, NUMBER IN ACCUM
;T1=2 TERMINATOR, CHR IN CH
;T1=3 SPECIAL CHR, CHR IN CH

SCNID:	TDZA T1,T1	;USE T1 AS FLAG TO TREAT NUMBER AS ID
SCAN:	MOVEI T1,1
	SKIPN CH,SAVCHR
SCAN1:	ILDB CH,SCNPTR
	CAIN CH," "
	JRST SCAN1
	CAIGE CH," "
	JRST SCAN2	;TERMINATOR
	CAIG CH,"9"
	CAIGE CH,"0"
	JRST SCNLET	;LETTER, TRY IDENT
	JUMPE T1,SCNLET	;TREAT AS IDENT
	MOVEI T1,-"0"(CH)
SCNNUM:	ILDB CH,SCNPTR
	CAIG CH,"9"
	CAIGE CH,"0"
	JRST ENDNUM	;END OF THE NUMBER
	IMUL T1,RADIX
	ADDI T1,-"0"(CH)
	JRST SCNNUM

ENDNUM:	MOVEM CH,SAVCHR	;SAVE TERMINATING CHR
	MOVEM T1,ACCUM
	MOVEI T1,1
	POPJ P,

SCAN2:	MOVEM CH,SAVCHR	;SAVE TERMINATOR SO DON'T RUN OFF LINE
	MOVEI T1,2
	POPJ P,

SCNLET:	SETZM ACCUM
	MOVE T1,[POINT 6,ACCUM]
SCNLT1:	CAIL CH,140
	SUBI CH,40	;FOR LOWER CASE
	CAIG CH,"Z"
	CAIGE CH,"0"
	JRST ENDID	;END OF IDENT
	CAIGE CH,"A"
	CAIG CH,"9"	;ALSO RECOGNIZE DIGITS
	SKIPA
	JRST ENDID
	SUBI CH,40
	TLNE T1,770000
	IDPB CH,T1
	ILDB CH,SCNPTR
	JRST SCNLT1	;SCAN REST OF ID

ENDID:	SKIPN ACCUM	;ANTHING THERE?
	JRST SCNSPC	;NO, MUST HAVE BEEN A SPECIAL CHR
	MOVEM CH,SAVCHR	;SAVE TERM
	MOVEI T1,0
	POPJ P,

SCNSPC:	SETZM SAVCHR	;NO SAVED CHR
	MOVEI T1,3
	POPJ P,
;READ A DRIVE LIST

REDDRV:	OASC [ASCIZ /
DRIVE(S): /]
REDDV1:	PUSHJ P,REDLIN
	MOVSI T4,-DRVLEN	;LENGTH OF THE DRIVE LIST
	PUSHJ P,SCAN
	XCT RDVTAB(T1)	;GO TO IT

RDVTAB:	JRST DRVALL	;CHECK FOR ALL
	JRST DRVNUM
	JRST NODRV	;JUST TERM, NO DRIVES
	JRST BADDRV

BADDRV:	OASC [ASCIZ /
BAD DRIVE LIST, RETYPE/]
	JRST REDDRV

NODRV:	OASC [ASCIZ /
NO DRIVES SPECIFIED/]
	JRST REDDRV

DRVALL:	MOVS T1,ACCUM
	CAIE T1,'ALL'
	CAIN T1,'AL '
	JRST ALLDRV
	CAIE T1,'A  '
	JRST BADDRV	;NOT ALL, NO OTHER ID IS GOOD
ALLDRV:	JSR DRVDSP	;CO-ROUTINE RETURN
	HLRZ U,SYSUNI
	JUMPE U,CPOPJ	;RETURN
CHKDRA:	SKIPGE UNISTS(U)
	JRST NXTDRA	;TRY NEXT
	MOVEM U,DRVSAV	;SAVE INFORMATION
	AOS (P)
	JSR DRVDSP
	MOVE U,DRVSAV
NXTDRA:	HLRZ U,UNISYS(U)
	JUMPN U,CHKDRA	;CHECK FOR ON LINE
	POPJ P,

DRVDSP:	0
	POPJ P,
;Read a drive number
DRVNUM:	PUSHJ P,DRVSRC
	 JRST NXDRV	;THAT DRIVE DOES NOT EXIST
	 JRST MLTDRV	;DRIVE IS MULTIPLY USED
	MOVEM U,DRVTAB(T4)
	PUSHJ P,SCAN
	XCT RDVTB2(T1)
	JRST BADDRV
	PUSHJ P,SCAN
	CAIE T1,1
	JRST BADDRV	;MUST BE NUMBER
	AOBJN T4,DRVNUM
	OASC [ASCIZ /
TOO MANY DRIVES, RETYPE/]
	JRST REDDRV

RDVTB2:	JRST BADDRV
	JRST BADDRV
	AOJA T4,GODRV	;ADD 1 TO COUNT TO MAKE AOBJN PNTR
	CAIE CH,","	;MUST BE A SPECIAL CHR THAT IS ,

GODRV:	MOVNS T4
	HRLZM T4,DRVSAV
GODRV1:	JSR DRVDSP
	SKIPL T4,DRVSAV
	POPJ P,		;RAN OUT OF DRIVES
	AOS (P)
	MOVE U,DRVTAB(T4)
	AOBJN T4,.+1
	MOVEM T4,DRVSAV
	JRST GODRV1

NXDRV:	OASC [ASCIZ /
DRIVE /]
	OOCT ACCUM
	OASC [ASCIZ / IS OFF-LINE OR DOES NOT EXIST/]
	JRST BADDRV

MLTDRV:	OASC [ASCIZ /
DRIVE /]
	OOCT ACCUM
	OASC [ASCIZ / IS SPECIFIED MORE THAN ONCE/]
	JRST BADDRV
;SEARCH DRIVES FOR THE NUMBER GIVEN. NUMBER IS IN ACCUM
;CALL PUSHJ P,DRVSRC
;	NO SUCH DIRVE
;	DRIVE ALREADY IN DRIVE LIST
;     OK

DRVSRC:	HLRZ U,SYSUNI
	MOVE T1,ACCUM
DRVSR1:	SKIPL UNISTS(U)	;NOT UNIT OFF-LINE
	CAME T1,UNINUM(U)
	JRST DRVSR2	;OFF-LINE OR WRONG NUMBER, TRY NEXT
	AOS (P)		;FOUND CORRECT DIRVE AND ITS ON-LINE
	TRNN T4,-1
	JRST CPOPJ1	;NOTHING IN LIST, TAKE GOOD RETURN
	MOVN T1,T4
	HRLZS T1
DRVSR3:	CAMN U,DRVTAB(T1)	;DOES IT MATCH?
	POPJ P,		;YES, MULTIPLE USE ERROR
	AOBJN T1,DRVSR3
	JRST CPOPJ1	;TAKE GOOD RETURN

DRVSR2:	HLRZ U,UNISYS(U)	;NEXT DRIVE
	JUMPN U,DRVSR1
	POPJ P,		;OUT OF DRIVES, NX RETURN

ONEUNT:	OASC [ASCIZ /
DRIVE: /]
ONEUN1:	PUSHJ P,REDLIN
	PUSHJ P,SCAN
	CAIE T1,1
	JRST ONENXD
	MOVEI T4,0
	PUSHJ P,DRVSRC
	 JRST ONENXD	;NO DRIVE
	 JRST ONENXD	;SHOULD NEVER GET HERE
	POPJ P,

ONENXD:	OASC [ASCIZ /
BAD DRIVE NUMBER, RETYPE/]
	JRST ONEUNT
SUBTTL	Device interrupt handlers

;HERE WHEN WE HAVE FOUND THE CORRECT SA-10, S SET UP

SAXCOD:	XCT SAXCNI(S)
	TRNE T2,1B19!1B20
	JRST SAXMEM	;MEMORY PROBLEM
	ANDI T2,170	;GET THE STATUS FLAGS
	JFFO T2,.+2	;FIND ONE ONE
	JRST SAXDIE	;LOSE BIG
	SUBI T3,^D29	;NOW T3 IS THE CHANNEL NUMBER
	MOVEI T1,SAXCHN(S)
	ADD T1,T3	;NOW WE HAVE APOINTER TO THE CHANNEL
	SKIPN C,(T1)
	JRST SAXDIS	;UNKNOWN CHANNEL, DISMISS INTERUPT
	HRRZ K,CHNKON(C)	;GET A POINTER TO THE FIRST CHANNEL
	LDB T1,[POINT 8,@CHNSTS(C),23]	;GET THE UNIT
KONSRC:	HRRZ T2,KONRNG(K)
	CAML T1,T2	;IS IT BELOW TOP
	JRST NXTKON	;NO, TRY ANOTHER KONTROLER
	HLRZ T2,KONRNG(K)
	CAML T1,T2	;IS IT GREATER OR = TO BOTTOM
	JRST KONFND	;HAVE CORRECT CONTROLER, GET UNIT
NXTKON:	HRRZ K,KONKON(K)
	JUMPN K,KONSRC	;SEARCH FOR CORRECT KONTROLER
SAXDIS:	LSH T3,3	;SET UP CHANNEL NUMBER
	MOVEI T2,6B29+4
	IOR T2,T3
	XCT SAXCNO(S)
	POPJ P,		;DISMIS INTERUPT

SAXMEM:	MOVEI T1,[ASCIZ /
PARITY ERROR AT LOCATION /]
	TRNE T2,1B19
	MOVEI T1,[ASCIZ /
NXM AT LOACTION /]
	OASC (T1)
	MOVEI T2,1B32
	XCT SAXCNO(S)
	XCT SAXDTI(S)
	OOCT T2
RSTBEL:	OASC[ASCIZ /
TYPE ANY CHARACTER TO RESTART
/]
	TLNE	F,KL10
	JRST	BELLKL
	CONO TTY,1B26
BELIT:	MOVEI T1,^D300
BELL1:	CONSZ TTY,40
	JRST RESTRT	;SEEN A CHARACTER, RESTART
	CONSO APR,APRCLK
	JRST BELL1
	CONO APR,APRCLK
	SOJG T1,BELL1
	OCHI 7
	JRST BELIT

BELLKL:	SETZM	DTEMTD		;CLEAR CHAR WAITING IF ANY
	MOVEI	T1,^D5*^D60	;RING EVERY5 SECONDS
	PUSHJ	P,KLBLWT
	SETZM	DTEMTI
	JRST	RESTRT
SAXDIE:	OASC [ASCIZ /
UNDEFINED SA-10 INTERUPT CONDITION/]
	JRST RSTBEL

CHINT:	0
	JRST SA0INT	;START SA-10

CHNSAV:	0		;JSR HERE TO SAVE AC'S AND SET PDL
	MOVEM 17,CHNACS+17
	MOVEI 17,CHNACS
	BLT 17,CHNACS+16
	MOVEI P,CHNPDL-1
	PUSHJ P,@CHNSAV
	MOVSI 17,CHNACS
	BLT 17,17
RETCHL:	JEN @CHINT	;DISMIS INTERUPT

CHNDIE:	OASC [ASCIZ /
UNDEFINED INTERUPT ON CHANNEL/]
	JRST RSTBEL
INTNM(\%SAX)==CHNDIE
ANYERR==SELERR+BUSERR+CONERR+LENERR+PIFERR+ATTEN+CUEND+BUSY+UCHK+UXCP
;SET FOR ANY ERROR CONDITION

KONFND:	MOVE T1,@CHNSTS(C)
	LDB U,[POINT 8,T1,23]	;GET UNIT
	HLRZ T2,KONRNG(K)	;AND BASE OF UNIT RANGE
	SUB U,T2
	ADDI U,KONTAB(K)
	SKIPN U,(U)	;GET POINTER TO THE UNIT
	JRST [TLNE T1,CUEND	;IF CONTROL UNIT END ON,
	      JRST KONEND	;WE DON'T EXPECT VALID DEVICE ADDRESS, GO RESTART EVERYONE
	      JRST UNTDIS]	;NO UNIT, JUST DISMISS.
	TLNE T1,ANYERR
	JRST KONERR	;FOUND AN ERROR CONDITION (MAYBE)
UNTFIN:	MOVEI T1,1
	SKIPGE UNIIOW(U)
	MOVEM T1,UNIIOW(U)	;SET IOW IF WAITING
	SKIPE KONRST(K)	;DOES IT NEED RESTARTING?
	JRST KONEND	;YES, PRETEND KONTROL UNIT END
UNTDIS:		XCT CHNCLR(C)	;CLEAR STATUS FLAG
	XCT CHNGO(C)	;AND RESTART IN CASE WE MISSED A GO
	POPJ P,

KONERR:	TLNE T1,UCHK
	JRST RDSTS	;NEED TO READ STATUS ON UNIT CHECK
	TLNE T1,BUSY
	JRST CHKBSY	;MAY BE CONTROL UNIT BUSY ETC
	TLNE T1,CUEND
	JRST KONEND	;CONTROL UNIT END, RESTART WAITERS
KONER1:	MOVEM T1,UNIERF(U)
	JRST UNTFIN	;SETT TERMINATED FLAG

CHKBSY:	TLNN T1,STSMOD
	JRST DEVBSY	;A DEVICE BUSY
CUBSY2:	MOVSI T2,(1B0)
	HLRZ T3,KONRNG(K)	;GET LOW NUMBER
	SUB T3,UNINUM(U)	;SUBTRACT UNIT NUMBER (GIVES - OFFSET)
	LSH T2,(T3)
	IORM T2,KONBSU(K)	;SET RESTART FLAG
	TLNN T1,CUEND	;IS CUEND ALSO ON?
	JRST UNTDIS	;JUST DISMISS
KONEND:	MOVE T2,KONBSU(K)
	MOVEI T4,KONTAB(K)
	SETZM KONBSU(K)	;WE WILL RESTART ALL OF THESE
	SETZM KONRST(K)	;NOW RESTARTED
KONEN2:	JFFO T2,.+2	;LLOK FOR NEXT
	JRST UNTDIS	;FINISHED, DISMISS INTERUPT
	LSH T2,1(T3)
	ADD T4,T3
	SKIPN U,(T4)	;SEE IF A UNIT THERE
	AOJA T4,KONEN2	;SEE IF MORE UNITS TO RESTART
	MOVE T1,UNIRST(U)
	MOVEM T1,@UNIBMX(U)	;SET RESTART
	AOJA T4,KONEN2	;AND CONTINUE
DEVBSY:	TLNN T1,CUEND!DEVEND
	JRST KONER1
	TLNE T1,CUEND	;IF REALLY CONTROL UNIT END
	SETOM KONRST(K)	;THEN NEED TO RESTART LATER
	JRST RDSTS1

RDSTS:	MOVEM T1,UNIERF(U)	;SET ERROR FLAG
	MOVE T1,CHNSTS(C)
	MOVE T1,1(T1)
	MOVEM T1,UNICNT(U)	;SAVE THE ADDRESSPOINTER
RDSTS1:	MOVEI T1,UNIRDS(U)
	MOVE T2,UNINUM(U)
	DPB T2,[POINT 8,T1,7]	;SET UP A START FOR READ STS
	TLO T1,(15B11)
	MOVEM T1,UNIRST(U)
	MOVEM T1,@UNIBMX(U)
	JRST UNTDIS

;FIND CYL,HEAD, REC OF ERROR

FNDERR:	MOVE T1,UNICNT(U)
CYLSRC:	SKIPGE -1(T1)
	SOJA T1,CYLSRC	;NEGATIVE WORDS ARE HALTS AND TRANSFERS
	LDB T2,[POINT 8,-1(T1),15]
	CAIE T2,SEEK
	CAIN T2,SRCIDE	;BACK UP TO SEEK OR SEARCHID
	SKIPA
	SOJA T1,CYLSRC
	HRRZ T1,(T1)	;GET DATA ADDRESS
	LDB CYL,[POINT 16,(T1),31]
	LDB HEAD,[POINT 16,1(T1),15]
	LDB REC,[POINT 8,1(T1),23]
	POPJ P,
COMERR:	MOVE T1,UNIERF(U)
	TLNN T1,UCHK
	JRST SAXERR	;SA-10 DETECTED ERROR
	HLLZ T1,UNISNS(U)
	TLZ T1,3	;GET RID OF EXTRA 2 BITS
	JFFO T1,.+2
	POPJ P,		;MUST BE ENVIRON DATA, RETRY
	MOVE T1,ERRTB1(T2)	;GET INFORMATION ON ERROR TYPE
	JUMPL T1,(T1)	;NEEDS DISPATCH
ERRREN:	SKIPGE T3	;CHECK ON RETRY COUNTER
	HLRZ T3,T1	;GET RETRY COUNT
	SOJGE T3,CPOPJ	;STILL SOME RETRY TO GO
	JRST CPOPJ1	;TAKE NON-RECOVERY RETURN

COMERP:	JUMPE T1,CPOPJ	;NO ERROR MESSAGE
	PUSH P,T1
	PUSHJ P,FNDERR
	OASC [ASCIZ /

UNRECOVERABLE ERROR ON UNIT #U
CYLINDER #C,HEAD #H,RECORD #R
/]
	POP P,T1
	OASC (T1)
	POPJ P,

ERRTB1:	-1,,CMDRJC	;COMMAND REJECT POSSIBLE WRITE PROTECT
	-1,,OFLIN	;UNIT OFF LINE
	1,,[ASCIZ /BUS OUT PARITY ERROR
/]
	-1,,EQCHK	;EQUIPMENT CHECK
	-1,,DTACHK	;DATA CHECK
	0,,[ASCIZ /OVERRUN
/]
	0,,[ASCIZ /UNKNOWN ERROR BYTE 0 BIT 6
/]
	0,,[ASCIZ /UNKNOWN ERROR BYTE 0 BIT 7
/]
	0,,[ASCIZ /UNKNOWN ERROR BYTE 1 BIT 0
/]
	0,,[ASCIZ /INVALID TRACK FORMAT
/]
	0,,[ASCIZ /UNKNOWN ERROR BYTE 1 BIT 2
/]
	0,,[ASCIZ /UNKNOWN ERROR BYTE 1 BIT 3
/]
	0,,[ASCIZ /NO RECORD FOUND
/]
	0,,[ASCIZ /PROTECTION FAILURE
/]
	0,,[ASCIZ /UNKNOWN ERROR BYTE 1 BIT 6
/]
	0,,[ASCIZ /UNKNOWN ERROR BYTE 1 BIT 7
/]
DTACHK:	MOVSI T1,(1B17)
	TDNN T1,UNISNS(U)
	JRST DTANRC	;UNRECOVERABLE DATA CHECK
	PUSH P,T2
	PUSH P,T4
	LDB T1,[POINT 16,UNISNS+4(U),15]	;GET RECORD BYTE SIZE
	LDB T2,[POINT 8,UNISNS+3(U),31]
	DPB T2,[POINT 8,T1,19]
	LDB T2,[POINT 16,UNISNS+4(U),31]	;NO OFFSET FROM END OF REC
	SUB T1,T2	;COMPUT OFFSET FROM START OF REC
	MOVE T2,UNICNT(U)
	LDB T4,[POINT 8,-2(T2),7]	;THIS SHOULD BE THE COMMAND
	MOVE T2,-1(T2)	;THIS IS THE TRANSFER WORD
	LDB T3,[POINT 12,T2,11]	;SIZE
	TRO T3,770000
	HRLM T3,T2	;MAKE IT INTO AN AOBJN POINTER
	TRNE T4,TRBYTE	;IS IT BYTE MODE?
	JRST BYTDTC	;YES, HANDLE DIFFERENTLY
	PUSH P,T2
	LSH T1,3	;CONVERT BYTES TO BITS
	IDIVI T1,^D36	;AND FORM A WORD POINTER
	HRLS T1
	ADDM T1,(P)	;ADD TO THE AOBJN POINTER FOR THE DATA
	POP P,T1
	JUMPGE T1,CDTRRD	;ERROR OUTSIDE DATA AREA, IGNORE
	LDB T3,[POINT 24,UNISNS+5(U),23]
	LSH T3,^D12	;THE CORRECTION SYNDROME
	MOVEI T4,0
	MOVNS T2
	LSHC T3,(T2)	;NOW HAVE BITS CORRECTLY POSITIONED
GORCV1:	XORM T3,(T1)	;FIRST WORD GET FIXED
	AOBJP T1,CDTRRD	;STILL IN DATA AREA?
	XORM T4,(T1)	;YES, FIX UP SECOND WORD
CDTRRD:	HRRZ T2,UNICNT(U)
	HRLI T2,TIC
	HLRZ T1,CMD
	MOVEM T2,(T1)	;START COMMAND CHAIN WITH A TIC
	POP P,T4
	POP P,T2
	MOVNI T3,1	;RESET ERROR COUNT TO NONE
	POPJ P,		;TAKE RECOVERABLE ERROR RETURN

DTANRC:	MOVEI T1,[ASCIZ /DATA CHECK
/]
	JRST ERRREN

BYTDTC:	HLRO T3,T2	;GET BYTE COUNT
	ASH T3,-2	;CONVERT TO WORDS (4 BYTES /WORD)
	HRLM T3,T2
	PUSH P,T2
	IDIVI T1,4
	HRLS T1		;MAKE SURE TO ADD TO BOTH AHLVES
	ADDM T1,(P)	;T1 HAS WORD OFFSET, T2 BYTE
	POP P,T1
	JUMPGE T1,CDTRRD	;NOTHING TO CORRECT
	LDB T3,[POINT 24,UNISNS+5(U),23]
	LSH T3,^D8	;DO NOT SHIFT FOR EXTRA 4 BITS ON RIGHT
	MOVEI T4,0
	LSH T2,3	;CONVERT BYTES TO BITS
	MOVNS T2
	LSHC T3,(T2)	;SHIFT
	LSH T3,4	;AND REPOSITION T3 (4 EXTRA BITS ON RIGHT
	JRST GORCV1
OFLIN:	SETOM UNISTS(U)	;SET UNIT OFF-LINE
	OASC [ASCIZ /

UNIT #U	 HAS GONE OFF-LINE

/]
	MOVEI T1,0
	JRST CPOPJ1	;NON-RECOVERABLE WITH NO ERR

CMDRJC:	MOVE T1,UNISNS(U)
	TLNE T1,(BYTE (8) 0,2)
	JRST UNIWPT	;UNIT IS WRITE PROTECTED
	MOVEI T1,[ASCIZ /COMMAND REJECT
/]
	JRST ERRREN	;AND GIVE ERROR

UNIWPT:	MOVSI T1,NOWRT
	IORM T1,UNISTS(U)	;SET FLAG
	MOVEI T1,[ASCIZ /UNIT IS WRITE PROTECTED
/]
	JRST ERRREN

EQCHK:	MOVE T1,UNISNS(U)
	TLNN T1,(BYTE (8) 0,200)
	SKIPA T1,[^D10,,[ASCIZ /EQUIPMENT CHECK
/]]
	MOVEI T1,[ASCIZ /PERMANENT EQUIPMENT CHECK
/]
	JRST ERRREN

SAXERR:	HLLZ T3,UNIERF(U)
	TLZ T3,3
	MOVEI T1,0	;NO MSG YET
	MOVEI T2,0
SAXER1:	JFFO T3,.+2
	JRST CPOPJ1	;RAN OUT OF BITS
	LSH T3,1(T4)	;GET RID OF BITS SCANNED
	ADD T2,T4	;FIND BIT NUMBER
	SKIPE T1,SAERTB(T2)	;IS THIS AN ERROR BIT?
	JRST CPOPJ1	;YES, TAKE FIRST
	AOJA T2,SAXER1	;ELSE CONTINUE

SAERTB:	0
	0
	[ASCIZ /SELECT ERROR /]
	[ASCIZ /BUS IN PARITY ERROR /]
	[ASCIZ /CONTROL ERROR /]
	0
	[ASCIZ /LENGTH ERROR /]
	[ASCIZ /INTERUPT ERROR /]
	[ASCIZ /ATTENTION /]
	0
	0
	[ASCIZ /BUSY /]
	0
	0
	0
	[ASCIZ /UNIT EXCEPTION /]
SUBTTL	Data area

PDL:	BLOCK 40
MEMSIZ:	0
MEMLOW:	0	;FIRST WORD OF MEMORY TO USE
MEMFRE:	0	;FIRST FREE WORD OF MEMORY
SYSUNI:	%.D0,,0	;POINTER TO FIRST UNIT DATA BLOCK
DEVWAT:	0	;NUMBER OF WAITING UNITS
SAVAC:	BLOCK 20	;PALCE TO SAVE AC'S
ALTBAD:	0	;Count of bad alternate tracks
TTYFIL:	0
SEK0AD:	BYTE (8) BYTMOD,SEEK
	BYTE (12) -6 (24) SEKAD0	;GENERATE COMMAND FOR A SEEK
	BYTE (8) 200
SEKAD0:	BYTE (16) 0,0,0		;CYL=0 HEAD=0

CHNACS:	BLOCK 20
CHNPDL:	BLOCK 40

RQZRO:	BYTE (8) TRWORD+NOMEMT+XCTCMD,0,0
	BYTE (8) 0		;AND A HALT

WRTQ0:	BYTE (8) BYTMOD,SRCIDE
	BYTE (12) -5 (24) ADR377
	TIC,,WRTQ0
	BYTE (8) BYTMOD!IGNLEN,WRT33
	BYTE (12) -1 (24) BLANK
	BYTE (8) 200

REDQ0:	BYTE (8) BYTMOD,SRCIDE
	BYTE (12) -5 (24) ADR377
	TIC,,REDQ0
	BYTE (8) BYTMOD!IGNLEN,RED33
	BYTE (12) -1 (24) BLANK
	BYTE (8) 200

ADR377:	BYTE (16) 0,0 (8) XTRREC
BLANK:	0

SEK500:	BYTE (8) BYTMOD,SEEK
	BYTE (12) -6 (24) SK5ADR
	BYTE (8) 200

SK5ADR:	BYTE (16) 0,^D500,0
BELFLG:	0	;FLAG TO RING BELL
ACCUM:	0	;RESULTS OF SCAN STORED HERE
SAVCHR:	0	;SAVE INPUT CHRACTER ON SCAN
SCNPTR:	0	;SCAN POINTER FOR SCAN
INPBUF:	BLOCK <^D100+1+4>/5
SPCLNK:	0
DRVSAV:	0	;SAVE WORD OF INFORMATION FOR NEXT DRIVE ROUTINE
DRVTAB:	BLOCK 20	;MAX NUMBER OF DRIVES IN A LIST
	DRVLEN==.-DRVTAB
SUBTTL	LITerals
RADIX:	10	;FOR INPUT CONVERSION
MONTH:	0
DAY:	0
THSDAT:	0

CTOFLG:	0
RUBFLG:	0
ABTDSP:	0
DOFLG:	0
CLRNXM:	0
NXMFLG:	0

LITS::	LIT
	VAR
	RELOC	.-140
SUBTTL	End of PAKCOP

DDT::		;DDT goes here if loaded


	END	START
     Yt c