TITLE	FILUUO	DISK SERVICE ROUTINE

	STOPCD(,ENTRY,FILUUO)

;DEFINITIONS IN M

UUOLUK==400000	;UUO IS A LOOKUP
EXTUUO==200000	;EXTENDED UUO
UUOMLK==100000	;MULTIPLE EXTENSION LOOKUP
UUOENT==040000	;UUO IS AN ENTER
UUOUFD==020000	;FILE UUO DEALS WITH IS A UFD
UUOREN==010000	;UUO IS A RENAME
UUOSIM==004000	;SET IN UPDATE IF ITS SIMULTANEOUS STYLE
UUOIRE==002000	;SET SO THAT FILFND STILL LEAVES ATB COUNT UP IF RIB ERROR,
		; WITH INFO FROM UFD IN THE ATB.
UUOMSK==777777	;CLEAR ALL BITS INCLUDING INDEX AND INDIR

;BITS IN UUXNUM.
UUPWDS==200000	;ENTER/RENAME--ALLOCATION WORD IS IN UNITS
		;OF WORDS, NOT BLOCKS.
UUPPID==100000	;LOOKUP/ENTER/RENAME - PID ACCESS BIT

INTERNAL UUOLUK,EXTUUO,UUOMLK,UUOENT,UUOUFD,UUOREN,UUOIRE
INTERNAL DSKRES,DSKKJB,JOBSTR,DSKDSP
INTERNAL PRTWDW,PRTWDR
INTERNAL UUPPID

;EXTERNALS FROM OTHER PARTS OF THE MONITOR

EXTERNAL GETWDS,GIVWDS,TPOPJ,CPOPJ,CPOPJ1,TPOPJ1,PJOBN,WATPCB
EXTERNAL KMAPP,KFDEL,KFCRE,KFEXC,IOSERR,IOSRBE,IOSRIB,IOSUPR,KSMAPP
EXTERN KVLRIB,KFFIFP,KFTRN,KMOVPG
EXTERNAL JBTPRV,JBTPPN,JBTUNM,JBTUN1,JBTAUN,JBTSER
EXTERN NORED,NOWRT,PIDACC
EXTERNAL JBTDLK,JBTSLK,JBTERN,JBTLIC,JBYWPT,UPTPJC
EXTERNAL UPTPID,UPTSPD
EXTERNAL TIME,JFYSEC,THSDAT,WAIT1,HIGHJB,JOB,UPTJDA,CLOSE1
EXTERNAL UPTRIB,UPTRB2,UPTSAT,QUEPCB,JBTABT,JBTSTS,CPOPJ2
EXTERNAL SYDNM4,STOIOS,SAVE4,GET4WD,GIV4WD,PWAIT1,CURUPT,EPT,ONCTIM
  %COW.N==:371	;Hack for new MACRO/LINK
EXT(<%UPT,%COW,%COW.N>)
EXTERNAL UPTPDL,DATCOM
EXTERNAL PDNMUP

;EXTERNAL IN OTHER PARTS OF FILSER

EXTERNAL SRCFIL,CHKPRV,FREATB,GETCBR,INVDDB,RIBRDL,RIBWTL,ZERDDB
EXTERNAL RELLOK,SRCNAM,DLTTRC,FNDDRB,GIVCBR
EXTERN GIVCB1,%RIB.C,MAPWLN,DLTNAM,USETI0,USETO0,DLTALL,%CTUPT
EXTERNAL DIRSRC,TSTWRT,LKDATB,ULKDBL,TSTWRS
EXTERNAL LOKPPB,NLKPPB,DEVLG,GUFBT,GIVCB1,RMVATB
EXTERNAL MAPWTL,%RB2.C,MAPRLS,MAPXCH,GETER1,RIBDIR,MAPRDU
EXTERNAL DIRBLK,PTROUT,CRBRWL,INSNAM,RRSETB,FPCSET
EXTERNAL PCBCLR,PTROU2,GIVPAG,UUOSEK
;EXTERNAL IN COMMOD

EXTERNAL MFDPPN,SYSPPN,SYSDRB,UFDPRT,STNPRT,DSKDDB
EXTERNAL CBUSER,INDPPN,SYSCOR,SYSUNI,ETSUNI,METSLN,ETSTAB
EXTERNAL STRDDB,STRNAM,STRTAL,STROVR,STRNXT,STRUNI,STRSID,STRLEN

EXTERNAL UNILOG,UNINAM,UNISYS,UNIKON,UNIDES,UNITAL,UNICHR
EXTERNAL UNIFEP,UNIPPU,UNIHID,UNISTR
EXTERNAL UNYSIZ,UNYSPU,UNYWPS

EXTERNAL DEVATB,DEVDRB,DEVDBL,DEVELB,DEYTCT,DEYSTC
EXTERNAL DEVRB1,DDBCOR,DDBLEN,DEVRIB,DEVRET,DEVFLO,DEVPOS
EXTERNAL PTRCHG

EXTERNAL ATBFNB,ATBCNT,ATBSIZ,ATBPVW,ATBMSC,ATBLIC,ATBALP,ATBSTS
EXTERNAL ATBRIB,ATBPRV,ATBLCW,ATBDOR,ATBLNK,ATBMWC,ATBUMC
EXTERNAL ATBPID
EXTERNAL ATPMXU,ATPDIR,ATPCRE,ATPNDL,ATPDEL,ATPUPD,ATPDMP,ATMCNT,ATPCNT
EXTERNAL ATPSUP,ATPREN,ATPUFE,ATPPID,ATPALC,ATMCSC,ATMUFP,ATMUFU,ATMMWC,ATMUMC
EXTERNAL ATYBSZ,ATYBLK,ATYXCD,ATYCTM,ATYCSC,ATYCTD,ATYCDT
EXTERNAL ATYCNT,ATYPRV,ATYADT,ATYUF1,ATYUF2

EXTERNAL FNBEXT,FNBAPD,FNBNX,FNBRIB,FNBNAM,FNBDRB,FNBLNK,FNBUPD,FNBALT
EXTERNAL FNPNX,FNBATB,FNBDBL,FNYUFP

EXTERNAL FNCLOK,FNCRED,FNCEXC,FNCCRE,FNCSUP,FNCAPP
EXTERNAL FNCUPD,FNCTRN,FNCCAT,FNCDEL,FNCCNM,FNCCPR

EXTERNAL DRBCNT,DRBRIB,DRBALC,DRBMXA,DRBLNK,DRBUNM,DRBUN1,DRBNAM
EXTERNAL DRBNX,DRBFNB,DRYPRV,DRYCNT
EXTERNAL DRPMXC,DRPNX,DRMCNT,DRPLOG,DRBLOG

EXTERNAL RIBVER,RIBFUT,RIBPPN,RIBEST,RIBEXT,RIBPVW,RIBNAM,RIBPOS
EXTERNAL RIBFT1,RIBLCW,RIBMTA,RIBDEV,RIBSTS,RIBELB,RIBXT1,RIBQTF
EXTERNAL RIBQTO,RIBAUT,RIBUNM,RIBUN1,RIBTRU,RIBXT2,RIBSNM,RIBALC
EXTERNAL RIBUSD,RIBMXA,RIBPID,RIBCOD,CODRIB,RIBSLF,RIBSZS,RBMASK
EXTERNAL RIBALT
EXTERNAL RIPDIR,RIPHRE,RIPHWE,RIPLOG,RIBPFS,RIPNFS,RIPUFE,RIPPID
EXTERNAL RBYPN1,PTSPNO,PTNPNO,RBYUN1,RIBRIB,RIBSIZ,RIBALP,RIPBDR
EXTERNAL RIBPJC,RIBPJ1,RIBPJ2	;-
EXTERNAL RIPBDA,RIPBFS,RIBLST,RBDLTA,RBINDX,RIPSPP,RIPBDR

EXTERNAL STRHSH

EXTERNAL STRBTS,SRPNDS

EXTERNAL CMBLNK

EXTERNAL KONLTM

EXTERNAL UFPERR,UFDERR,UFDALP,UFDCDT,UFDEXT,UFDLIC,UFDNAM,UFDRIB
EXTERNAL UFYCTM,UFYPRV,UFYUF1,UFYUF2,UFYXCD,RBREAL,UFDSIZ
EXTERNAL UFYCDT,UFDLNK

;EXTERNS FROM SIMIO MODULE
EXTERN USETI0,USETO0,INBLT,OUTBLT,SIMRLS
EXTERN UPTPOS
EXTERN PCDTIM
COMMENT ! **************************************************

		DISK  DISPATCH  TABLE   DSKDSP

		( DEVSER(F) POINTS HERE )
***********************************************************!

	PHASE -2
DDO:	JRST	OUTBLT		;DUMP OUTPUT
DDI:	JRST	INBLT		;DMP INPUT.  SEE SIMIO
	DEPHASE
DSKDSP:
	PHASE 0
DDXZ:	DSPSIZ
DDINT:	POPJ	P,
DBYT:	4400,,4400
DVSIZ:	MOVEI	T1,DDBLEN
DINI:	POPJ	P,
DHNG:	JRST	CPOPJ1
DRL:	JRST	DSKREL		;CALLS CLOS IN/OUT WHICH CALL SIMRLS
DCL:	JRST	CLOSOU
DOU:	STOPCD			;BUFF OUTPUT. SIMBOU USES DDO EXCLUSIVELY
DIN:	STOPCD			;BUFF INPUT, SIMBIN USES DDI EXCLUSIVELY
DZAP:	POPJ	P,		;FORGET ZAP
DGTRD:	POPJ	P,		;FORGET GET READY
DMT:	POPJ	P,
DGF:	JRST	DSKUGF
DEN:	JRST	UENTR
DLK:	JRST	ULOOK
DRN:	JRST	RENAM
DSI:	JRST	USETI0
DSO:	JRST	USETO0
DCLI:	JRST	CLOSIN
DUFD:	JRST	UFDUUO
DSEK:	JRST	UUOSEK
DVMAP:	JRST	KMAPP
DFDEL:	JRST	KFDEL
DFCRE:	JRST	KFCRE
DFEXC:	JRST	KFEXC
DSIM:	JRST	USIMUP		;SIMULTANEOUS UPDATE CHANIO
DFVLR:	JRST	KVLRIB
DVSMAP:	JRST	KSMAPP
DFFIF:	JRST	KFFIFP
DFTRN:	JRST	KFTRN
DMOVPG:	JRST	KMOVPG		;MAKE VP MAPPABLE FROM FILE
	DSPSIZ==.-1
	DEPHASE

SUBTTL	INTERFACE SUBROUTINES WITH THE REST OF THE MONITOR

INTERN	TSTDSK,SETDDB,CLRDDB

;SUBROUTINE TO SAVE AND RESTORE TEMP ACS
;CALLED BY PUSHJ P,SAVT   RETURN EITHER CPOPJ OR CPOPJ1 WHEN THROUGH
INTERN SAVT
SAVT:	EXCH	T4,(P)		;SAVE T4, GET RETURN ADR.
	PUSH	P,T3		;SAVE T3
	PUSH	P,T2		;AND T2
	PUSHJ	P,(T4)		;RETURN TO CALLER
	  SKIPA			;POPJ RETURN
	AOS	-3(P)		;CPOPJ1 - SET SKIP RETURN
	POP	P,T2		;RESTORE T3 ACS
	POP	P,T3
	POP	P,T4
	POPJ	P,		;AND RETURN

;SUBROUTINE TO TEST IF THE DEVICE WHOSE NAME IS IN T1 IS A DISK
;ENTER WITH J (=J)= JOB NUMBER
;EXIT CPOPJ IF A DISK, WITH F=PROTOTYPE DDB
;EXIT CPOPJ1 IF NOT A DISK, OR A SINGLE-ACCESS DISK NOT FOR THIS JOB
;CALLED BY DEVPHY
TSTDSK:	JUMPE	T1,CPOPJ1	;"0" IS NOT A DISK
	PUSHJ	P,SAVT		;SAVE T2-T4
	MOVEI	F,DSKDDB	;SET F FOR PROTOTYPE DDB
	PUSHJ	P,ALIASD	;IS NAME AN ALIAS FOR "DSK"?
	  POPJ	P,		;YES. NON-SKIP RETURN
	CAMN T1,[SIXBIT /DSKB/]	;CHECK FOR STR NAME
	  POPJ	P,
	PUSHJ	P,SRUNI		;IS USER SUPPLYING A UNIT NAME?
	  JRST	CPOPJ1		;NOT A DISK - SKIP RETURN
	  JFCL			;PHYSICAL DSK NAME (Logical unit return)
	HRRZ	T3,UNISTR(U)	;YES, SET T3 TO STR DB LOC
	JUMPN	T3,CPOPJ	;JOB MUST BE PRIVILEGED IF UNIT NOT IN AN STR
	MOVSI	T3,LICSTR
	TDNN	T3,JBTLIC(J)	;SPECIAL FOR LICENSED JOB
	  AOS	(P)		;NO, ERROR RETURN
	POPJ	P,		;YES, OK RETURN
;SUBROUTINE TO CLEAN UP THE ACCESS TABLES FOR A JOB AFTER A SWAP-READ ERROR
;SCANS THE DDB'S, WHEN IT FINDS ONE FOR THE JOB IT FIXES IT-
; DECREMENTS THE READ-COUNT IF READING, CLEARS THE STATUS BYTE IF WRITING
; AND INCREMENTS THE QUOTA IF CREATE OR SUPERSEDE
;IT EXITS BY RETURNING ANY SYSTEM RESOURCES THE JOB MIGHT HAVE
SWPCLN:	MOVEI	F,DSKDDB	;START AT PROTOTYPE DDB
	JSP T4,SAVE4	;SAVE SOME TEP ACS TO WORK IN (FOR CALLS)
SWPCL1:	HLRZ	F,DEVSER(F)	;LINK TO NEXT DDB
	JUMPE	F,CPOPJ		;DONE IF 0
	MOVE	T1,DEVMOD(F)
	TLNN	T1,DVDSK	;IS THIS DDB A DISK?
	POPJ P,			;NO, THROUGH
	LDB	T1,PJOBN	;YES, SAME JOB?
	CAME	T1,J
	JRST	SWPCL1		;NO, TRY NEXT DDB
	SKIPN P2,DEVATB(F)
	JRST SWPCL1
	HLRZ P4,P2	;DRB POINTER
	HRRZ P3,ATBFNB(P2)
	HRRZS P2
	LDB T1,DEYSTC	;WHAT WERE WE DOING
	MOVEI T2,0
	DPB T2,DEYSTC
	XCT .+1(T1)
	PHASE 0
	JRST SWPCL1
DECLUK:!JRST SWPLUK
DECUPD:!JRST SWPUPD
DECUP2:!JRST SWPUP2	;WAS UPDATING BUT INPUT CLOSED
DECENT:!JRST SWPENT	;FOR SUPERCEDE OR RENAME
DECSTP:! STOPCD (SLO)	;IN THE MIDDLE OF A UUO
	DEPHASE

SWPENT:	MOVE T1,ATBALP(P2)	;NUMBER OF PAGES ALLOCATED
	ADDM T1,DRBALC(P4)	;RETURN TO HIS QUOTA
	PUSHJ P,FREATB	;RETURN ATB TO FREE STORAGE
	JRST SWPLK1	;AND RESET A FEW THINGS

SWPUPD:	MOVEI T1,ATPUPD
	ANDCAM T1,ATBSTS(P2)
	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	 STOPCD (SLO)           ;;SWPUPD+4
SWPLUK:	SOS T1,ATBCNT(P2)
SWPLK2:	TRNN T1,ATMCNT!ATPUPD!ATPREN
	PUSHJ P,LKDATB	;MAKE DORMANT IF NOT IN USE
SWPLK1:	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	 STOPCD (SLO)           ;;SWPLK1+2
	SETZM DEVATB(F)
	PUSHJ P,ULKDBL
	JRST SWPCL1

SWPUP2:	MOVSI T1,ATPUPD
	ANDCAB T1,ATBSTS(P2)
	JRST SWPLK2

INTERNAL SWPCLN
;UGETF

COMMENT ! ROUTINE DSKUGF -- UGETF FOR DSK FILE.
FUNCTION: RETURN TO USER LOC/ CURRENT POSITION,,FILE SIZE UNLESS
	EITHER VALUE EXCEEDS 18 BITS OR NO LOOKUP/ENTER DONE
	(IN WHICH CASES -1).
EXPECTS: M/ USER DATA LOCN ADDR
	F/ DDB
	W/ CHANNEL
!
DSKUGF:	PUSHJ P,WAIT1
	MOVNI T1,1		;READY FOR ERROR RETURN
	HRRZ T2,DEVATB(F)
	JUMPE T2,DSKUG1	;NO LOOKUP/ENTER, ERROR
	LDB	T1,ATYBSZ
	TLNE	T1,-1
	JRST	DSKUG2
	MOVE	T2,DEVPOS(F)
	TLNE	T2,377777	;DONT TEST USETI/O FLAG 1B0
	JRST	DSKUG2
	HRLI	T1,(T2)
DSKUG1:	UMOVEM T1,(M)		;RETURN TO USER
	POPJ P,
DSKUG2:	MOVNI	T1,1
	JRST	DSKUG1
; CALLED FROM COMMON IN CRASH CODE.
;*;FILSTP::POPJ	P,	;DSKSTP:;GOOD PLACE TO WRITE SATS OUT

;HERE ON A LOGOUT, WHEN THERE ARE NO OTHER JOBS LOGGED IN UNDER THIS PPB
;CALLED BY LOGOUT , WITH AC=PPN  (DSKLGO M)
DSKLGO:	CAME	T1,SYSPPN	;YES. IS JBTPPN FOR SYS?
	CAMN	T1,MFDPPN	; OR AN MFD?
	  POPJ	P,		;YES, DONT DELETE  CORE BLOCKS
	PUSHJ	P,GETCBR
	HLRZ	T2,SYSDRB	;% NO. SET TO SEARCH DRB'S
	MOVNI	T3,1		;% DO NOT CREATE A NEW ONE
	PUSHJ	P,SRCNAM	;% FIND PPB FOR THIS JOB
	  JUMPE	T2,GIVCBR
	MOVEI	T1,DRPLOG	;% FOUND - SET NLG
	ANDCAM	T1,DRBLOG(T2)	;%  IN PPB BLOCK
	PJRST	GIVCBR
INTERNAL DSKCLR
EXTERNAL ADJMWS

;CODE TO CLEAR CORE INFO (CALLED BY DSKFIXER)

DSKCTB:	JRST	DSKCL2			;0  CLEAR IN-CORE DISK INFO
	JRST	DSKCL3			;1  SET STTFPC FOR ALL SATS
	JRST	DSKCL4			;2  CLEAR SRPNDS ONLY
DCTBSZ==.-DSKCTB

PRINTF(<[DSKCLR This entire UUO needs work, maybe a STRUUO function]>)
DSKCLR:	MOVE	T1,JBTLIC(J)
	TLC	T1,LICWFL+LICWPJ
	TLCE	T1,LICWFL+LICWPJ	;DOES HE HAVE WRITE ABSOLUTE??
	  JRST	CPOPJ1
	LDB	T1,[POINT 4,M,^D12]	;GET AC FIELD.
	CAIL	T1,DCTBSZ		;IS VALUE TOO LARGE?
	  JRST	CPOPJ1			;YES
	XCT	DSKCTB(T1)		;DISPATCH

DSKCL4:	MOVEI	T1,SRPNDS		;CLEAR THE NEED DSKCLN FLAG
	ANDCAM	T1,STRDDB+STRBTS	; FOR THIS STRUCTURE
	SETOM	ADJMWS			;TURN MWS ADJUST
	POPJ	P,
DSKCL3:	MOVE	T1,PDNMUP(P)		;GET RETURN ADDR
	AOS	PDNMUP(P)		;INC PAST ARG
	UMOVE	T1,(T1)			;GET AOBJN WORD ADDR
	PUSHJ	P, FPCSET		;SET FREE PGS
	SOS	0(P)
	SETOM	ADJMWS			;TURN ON MWS ADJUST
	JRST	CPOPJ1
DSKCL2:	PUSHJ	P,PCBCLR		;ZAP ALL SAT AND RIB PCBS.
	  POPJ	P,			;PCB I/O IN PROGRESS
	  JRST	CPOPJ1			;CAN NOT CLEAR PCBS
	AOS	%UPT+UPTPDL		;FOR MULTIPLE SKIP RETURN TO USER
	PUSHJ	P,GETCBR
	HLRZ	P4,SYSDRB		;% ALL DRB BLOCKS
	JUMPE	P4,GIVCB1		;% SKIP RETURN, ALL DONE
DSKCL1:	LDB	T1,DRYCNT		;% GET COUNT
	JUMPN	T1,GIVCBR		;% DRB IN USE, ERROR
	HLRZ	P3,DRBFNB(P4)		;% NOW THE NAME BLOCK
	JUMPE	P3,DSKCL7		;% ALL DONE, GIVE BACK DRB
DSKCL6:	HLRZ	P2,FNBATB(P3)		;% FOR FOR THE ACCESS TABLE
	JUMPE	P2,DSKCL5		;% NONE THERE, GIVE BACK FNB
	PUSHJ	P,RMVATB		;% GET RID OF ATB (DRBCNT=0 SO OK)
	JRST	DSKCL6			;%

DSKCL5:	MOVE	T1,SYSCOR
	EXCH	T1,CMBLNK(P3)		;% THIS POINTS TO NEXT FNB (MAYBE)
	HRLZM	P3,SYSCOR		;% NOW FNB RETURNED
	HLLM	T1,DRBFNB(P4)		;% SO LINK FROM DRB OK
	HLRZ	P3,T1			;% NEXT LINK
	JUMPN	P3,DSKCL6		;%

DSKCL7:	MOVE	T1,SYSCOR		;% NOW GIVE BACK DRB
	EXCH	T1,CMBLNK(P4)
	HRLZM	P4,SYSCOR
	HLLZM	T1,SYSDRB		;% RELINK START
	HLRZ	P4,T1			;%
	JUMPN	P4,DSKCL1		;%
	JRST	GIVCB1			;%
SUBTTL	.CHUFD - Read UFD uuo
EXTERN USETST,UNLFIL,LOKUNM,RELRIB,IOBDRB

UFDUUO:	TLNN	F,LOOKB
	 POPJ	P,
	HRRZ	P2,DEVATB(F)		;MUST HAVE A UFD LOOKED UP
	MOVEI	T1,ATPDIR
	TDNN	T1,ATBSTS(P2)
	 POPJ	P,
	NOCHARGE
	UMOVE	P4,1(M)			;NAME
	XCTBU	<HLLZ P2,2(M)>		;EXTENSION
	XCTBU	<SETZM 7(M)>		;ZERO COUNT
	SETZB	P3,P1			;NO MASK YET
	XCTBU	<SKIPGE 3(M)>		;CHECK TO SEE IF WANT * AND #
	 JRST	UFDNMK			;NO
	EXCH	P2,P4
	PUSHJ	P,UFDMSK		;CONVERT * AND # IN P2 TO MASK IN P1
	EXCH	P2,P4			;PUT NAME BACK IN P4
	MOVE	P3,P1			;GET MASK
	PUSHJ	P,UFDMSK		;NOW DO EXTENSION, EXT MASK IN P1
UFDNMK:	HLRZS	P2			;EXTENSION IN RH
	HLRZS	P1			;EXTENSION MASK IN RH
	HRL	P1,M			;P1/USER ADDR,,MASK
	XCTBU	<SKIPN T1,4(M)>		;MONITOR WORD IS ZERO?
	 JRST	[			;SET UP INITIAL HASH LINK
		JUMPN P3,UFDNXM		;NOT ONE SPECIFIC NAME
		MOVE  T1,P4
		TLZ   T1,(1B0)
		HRRZ  T2,STRDDB+STRHSH
		IDIV  T1,T2
		MOVE  T1,T2
		JRST  UFDNXM]

;; P4/NAME  P3/NMASK  P2/0,,EXT  P1/USERADDR,,MASK  T1/HASH LINK
UFDNXM:	HRL	P2,T1			;P2/HASH LINK,,FILE EXT
	TRZ	T1,400000
	AOSG	M,T1			;M/PAGE IN UFD
	 POPJ	P,			;PG 0 OR <0 BAD OR END
	PUSHJ	P,LOKUNM		;LOCK(UNMODIFIABLE) F/UFD DDB
					;DESTROY NO ACS
	HRRZ	T2,DEVATB(F)
	LDB	T1,ATYBSZ		;SIZE OF UFD, IN BLOCKS
	ADDI	T1,3	
	LSH	T1,-2			;T1/SIZE UFD, IN PAGES
	CAMGE	T1,M			;SKIP IF PAGE IN M AT OR BEFORE EOF
	 JRST	[PUSHJ P,UNLFIL		;PAST EOF,UNLOCK
		 TDO   S,[IOEND,,IODEND]
		 PJRST STOIOS]		;SET IN DEVIOS & NOSKIP RTN
	PUSHJ	P,USETST		;GET @DEVRET(F) SETUP FOR
					;M/PAGE. CLOB T1-T4,U,PG. SKIP SUCCESS
	 JRST	[TRO   S,IODTER
		 PJRST STOIOS]		;NOSKIP RTN
	PUSHJ	P,UNLFIL		;UNLOCK,DESTROY NO ACS
	PUSHJ	P,RELRIB		;RELEASE RIB IN %RIB, CLOB T1-T4,PG
	TRNE	S,760000		;ANY ERRORS?
	 POPJ	P,			;
	HLRZ	M,P1			;M/USER CONTROL BLOCK ADDR AGAIN
	MOVE	T1,@DEVRET(F)
	TLNN	T1,RBREAL
	 JRST	UFDSPR			;HOLE.
	MOVEI	PG,%RIB.C
	PUSHJ	P,MAPRDU		;READ IT
	LDB	J,PJOBN
	MOVEI	T2,UFDRLK
	MOVEM	T2,JBTABT(J)
	PUSHJ	P,GTCGSZ		;GET T1/ CHARGING SIZE.
	ADDM	T1,JBTSIN
	ADDM	T1,JBTSIN(J)
	AOS	JBTRCT
	AOS	JBTRCT(J)
	MOVSI	T2,-<1000/UFDSIZ>	;NUMBER OF ENTRIES TO SEARCH
	JUMPGE	P2,UFDSFD		;DO NOT SEARCH FOR NAME, NEW BLK
	UMOVE	T3,5(M)			;NAME TO SEARCH FOR
	XCTBU	<HLRZ T4,6(M)>
UFDSLP:	CAME	T3,%RIB+UFDNAM(T2)
	 JRST	UFDNSL			;NOT THIS ONE, CONTINUE
	HLRZ	T1,%RIB+UFDEXT(T2)
	CAMN	T1,T4
	 JRST	UFDSF0			;FOUND IT
UFDNSL:	ADDI	T2,UFDSIZ-1
	AOBJN	T2,UFDSLP
	JRST	UFDRLK			;GIVE UP AND ERROR RETURN IF NOT FOUND

UFDSF0:	ADDI	T2,UFDSIZ-1		;FOUND THE STARTING NAME
	AOBJP	T2,FINUS0		;FINISHED
UFDSFD:	PUSH	P,P4
	PUSH	P,P3
	UMOVE	T4,(M)			;GET AOBJN POINTER FOR RETURNING DATA
	JUMPGE	T4,[POP  P,P3		;ERROR IF NONE TO RETURN
		    POP  P,P4
		    JRST UFDRLK]

UFDLLP:	SKIPN	T1,%RIB+UFDNAM(T2)	;SEARCH FOR NAMES THAT MATCH MASK
	 JRST	UFDLCN
	ANDCM	T1,(P)
	CAME	T1,-1(P)
	 JRST	UFDLCN			;NAME DOES NOT MATCH
	HLRZ	T1,%RIB+UFDEXT(T2)
	ANDCM	T1,P1
	CAIE	T1,(P2)
	 JRST	UFDLCN			;EXT DOES NOT MATCH
	DMOVE	P3,%RIB+UFDNAM(T2)
	AOBJP	T4,FINSUP
	HLLZS	P4
	XCTBU	<DMOVEM P3,-1(T4)>	;RETURN NAME AND EXT TO USER
	UMOVE	T3,3(M)
	TLNN	T3,(1B1)
	 JRST	UFNBLK			;NO BLOCKS
	AOBJP	T4,FINSUP
	HLRZ	T1,%RIB+UFDALP(T2)
	TRNE	T1,400000
	TLOA	T1,-1
	 LSH	T1,2			;CONVERT TO BLOCKS, NEG IF UNKNOWN
	UMOVEM	T1,(T4)
UFNBLK:	TLNN	T3,(1B2)
	 JRST	UFNLIC			;NO LICENSE
	AOBJP	T4,FINSUP
	HRRZ	T1,%RIB+UFDLIC(T2)
	UMOVEM	T1,(T4)
UFNLIC:	TLNN	T3,(1B3)
	 JRST	UFNDAT			;NO DATE
	AOBJP	T4,FINSUP
	LDB	P4,UFYCDT
	LDB	P3,UFYXCD
	DPB	P3,[POINT 2,P4,23]
	LDB	P3,UFYCTM
	TLNN	T3,200			;DOES HE WANT TIME AND DATE CONVERSION
	 JRST	UFNNCV			;NO, HE WANTS TYMSHARE FORMAT
	IMUL	P3,JFYSEC
	PUSH	P,T2
	DMOVE	T1,P3
	MOVS	P4,T3
	ANDI	P4,177
	TRZE	P4,100			;WANT IT IN DEC FORMAT?
	 TRO	P4,400000		;NO, TYMSHARE BUT DIFFERENT TIME ZONE
	HRLI	P4,400020		;FROM GMT
	PUSH	P,T3
	PUSH	P,T4
	PUSHJ	P,DATCOM
	  JFCL
	EXCH	T1,T2
	IDIV	T2,JFYSEC		;RECONVERT
	HRLM	T2,T1
	POP	P,T4
	POP	P,T3
	POP	P,T2
	XCTBU	<MOVSM T1,(T4)>		;STORE CONVERTED
	JRST	UFNDAT

UFNNCV:	HRLM	P4,P3
	UMOVEM	P3,(T4)			;STORE NONCONVERTED DATE
UFNDAT:	TLNN	T3,(1B4)
	 JRST	UFNSTS			;NO STATUS
	AOBJP	T4,FINSUP
	LDB	P4,UFYPRV
	LDB	T1,UFYUF2
	DPB	T1,[POINT 8,P4,26]
	LDB	T1,UFYUF1
	DPB	T1,[POINT 4,P4,18]
	UMOVEM	P4,(T4)
UFNSTS:	HRL	P1,T2			;SAVE LOCATION
	XCTBU	<AOS 7(M)>		;COUNT NUMBER OF FILES RETURNED
	AOBJP	T4,FINSUP
UFDLCN:	ADDI	T2,UFDSIZ-1
	AOBJN	T2,UFDLLP
	POP	P,P3
	POP	P,P4
	XCTBU	<SKIPN 7(M)>		;ANY MATCHES AT ALL?
	 JRST	FINUS0
	JUMPN	P3,[HLRZ T1,P2
		    AOJA T1,FINNXB]
	SKIPN	T1,%RIB+UFDLNK
	 MOVEI	T1,377777
	JRST	FINNXB


UFDSP1:	PUSHJ	P,RELLOK
	LDB	T1,PJOBN
	SETZM	JBTABT(T1)
UFDSPR:	JUMPE	P3,UFDEOF		;SPECIFIC NAME, ONLY ONE HASH CODE
	HLRZ	T1,P2
	TRZ	T1,400000
	AOJA	T1,UFDNXM

FINSUP:	POP	P,P3
	POP	P,P4
	XCTBU	<SKIPN 7(M)>		;COUNT OF MATCHES
	 JRST	UFDRLK			;ERROR IF NONE FOUND
	HLRZ	T4,P1
	DMOVE	T1,%RIB+UFDNAM(T4)	;GET LAST NAME STORED
	HLLZS	T2
	XCTBU	<DMOVEM T1,5(M)>	;STARTING NAME AND EXT FOR NEXT TIME
	HLRZ	T1,P2
	TROA	T1,400000		;SEARCH THIS AGAIN
FINNXB:	 TRZ	T1,400000
	UMOVEM	T1,4(M)
	AOS	(P)			;SKIP RETURN
	JRST	UFDRLK			;DONE

UFDEOF:	TDO	S,[IOEND,IODEND]
	MOVEM	S,DEVIOS(F)
	POPJ	P,

UFDRLK:	LDB	T1,PJOBN
	SETZM	JBTABT(T1)
	PJRST	RELLOK

FINUS0:	SKIPN	T1,%RIB+UFDLNK
	 JRST	UFDSP1			;NO LINK, EOF IF SPECIAL NAME, ELSE NEXT
	JUMPN	P3,UFDSP1		;LINK AND NOT SPECIAL
	PUSH	P,T1
	PUSHJ	P,RELLOK
	LDB	T1,PJOBN
	SETZM	JBTABT(T1)
	POP	P,T1
	JRST	UFDNXM
;CHECK P2 FOR * AND #, RETURN MASK IN P1
UFDMSK:	CAMN	P2,[SIXBIT /*/]
	 JRST	[MOVNI P1,1
		 MOVEI P2,0
		 POPJ  P,]
	MOVE	T2,P2
	XOR	T2,[SIXBIT /######/]
	MOVEI	P1,0
	MOVSI	T1,770000
UFDMS0:	TDNN	T2,T1
	 TDO	P1,T1
	LSH	T1,-6
	JUMPN	T1,UFDMS0
	ANDCM	P2,P1			;GET RID OF #'S
	POPJ	P,


;UUO TO SET PID TO NEW VALUE
; CALL:
;	MOVE	AC,[PID]
;	PIDSET	AC,
;	  <ERROR RETURN>		;NOT AUTHORIZED TO SET PID
;	<SUCCESS RETURN>
SETPID::JUMPE	T1,SETPIO		;ZERO ALWAYS OK
	LDB	T2,JBYWPT		;IF WF, CAN SET PID TO ANYTHING.
	CAILE	T2,1			;SKIP IF WP OR LESS
	  JRST	SETPIO			;OK TO SET ANY PID IF WF OR WA.
	MOVS	T2,JBTAUN(J)		;GET UUN IN LH
	XOR	T2,T1			;LH = 0 IF ALL BITS MATCH
	TLNN	T2,-1			;SKIP IF MATCH ON AUN
	  JRST	SETPIO			;OK, SAVE OLD PID AND SET NEW ONE
	CAMN	T1,%UPT+UPTSPD		;SETTING BACK TO LAST VALUE?
	  JRST	SETPIO			;YES, THAT'S OK
	CAMN	T1,%UPT+UPTPID		;NOT CHANGING?
	  AOS	(P)			;NOT CHANGING, DON'T BOTHER WITH UPTSPD
	MOVE	T1,%UPT+UPTPID		;GET CURRENT PID
	UMOVEM	T1,(M)			;RETURN "OLD" PID (SAME AS NEW)
	POPJ	P,			;NOT AUTHORIZED TO SET THIS PID

SETPIO:	EXCH	T1,%UPT+UPTPID		;SET NEW PID, GET OLD ONE
	SKIPE	T1			;DON'T SET SAVED PID TO ZERO, SO IF
					; JOB HAS PID, SETS IT TO ZERO, SETS IT
					; TO ANOTHER PID, DOESN'T LOSE ABILITY
					; TO RESET TO ORIGINAL PID.
	  MOVEM	T1,%UPT+UPTSPD		;REMEMBER WHAT LAST ONE WAS SO CAN RESTORE IT.
	UMOVEM	T1,(M)			;RETURN OLD PID VALUE
	JRST	CPOPJ1
;SUBROUTINE TO BUILD A DISK DEVICE DATA BLOCK
;ENTER WITH T1=DEVICE NAME, F=LOC OF DDB (OR TYPE DDB)
;CALLED BY ASSPRG
;HERE FROM ONCE-ONLY CODE
INTERN SETDDO
SETDDO:	PUSH	P,DSKDDB	;SAVE NAME
	JRST	SETDD3		;GO CREATE THE DDB

;THIS IS THE NORMAL ENTRY POINT
SETDDB:	PUSHJ	P,SAVT		;SAVE T2-T4
	HRRZ	T3,F		;ADDR. OF THE DDB
	CAIE	T3,DSKDDB	;IS IT THE PROTOTYPE?
	  MOVE	T1,DEVNAM(F)	;NO. GET THE PHYSICAL DEVICE NAME
	PUSH	P,T1		;SAVE NAME
	MOVE	T1,DEVMOD(F)
	TRNE	T1,ASSPRG	;DDB BEEN INITED?
	  JRST	SETDD1		;YES. HAVE TO COPY PROTOTYPE
	CAIE	T3,DSKDDB	;IS IT PROTOTYPE?
	  JRST	SETDD2		;NO. USE IT

;HERE WHEN WE MUST MAKE A COPY OF THE PROTOTYPE DDB
SETDD1:	MOVEI	T2,DDBCOR	;NO OF 4-WORD BLOCKS NEEDED
	PUSHJ	P,GET4WD	;GET THE CORE
	  JRST	TPOPJ		;CANT GET IT - RETURN
SETDD3:	HRR	F,T1		;LOC OF THE CORE
	HRLI	T1,DSKDDB	;FROM THE PROTOTYPE
	BLT	T1,DDBLEN-1(F)	;BLT THE NEEDED INFORMATION
	HRLM	F,DSKDDB+DEVSER	;LINK PROTOTYPE TO THEIS DDB
				;(COPY ALREADY CONTAINS LINK TO NEXT)
	MOVEI	T1,ASSCON+ASSPRG	;MAKE SURE ASSIGN BITS ARE OFF
	ANDCAM	T1,DEVMOD(F)	;(1 WILL BE TURNED ON BY ASSPRG)

SETDD4:	POP	P,DEVNAM(F)	;SET NAME INTO DDB
	JRST	CPOPJ1		;SUCCESS RETURN

SETDD2:	MOVEI	T1,DEVLOG+1(F)	;MAKE SURE DDB PROPERLY INITED
	HRLI	T1,DSKDDB+DEVLOG+1 ;BUT SKIP STUFF BEFORE THIS
	BLT	T1,DEVRB1-1(F)
	SETZM	DEVIOS(F)	;EXCEPT FOR DEVIOS
	JRST	SETDD4
;SUBROUTINE TO CLEAR A DISK DEVICE DATA BLOCK
;ENTER WITH F=LOC OF DDB
;CALLED BY RELEASE CODE AND ONCDSK AT ONCE TIME

CLRDDB:
	;PUSHJ P,IOLDEL		;NO IOLIST TO DELETE IN VM SYSTEM

	MOVEI	T1,DSKDDB	;START AT PROTOTYPE
CLRDD1:	MOVE	T2,T1
	HLRZ	T1,DEVSER(T2)	;GET SUCCESSOR TO THIS DDB
	SKIPN	T1		;END?
	 STOPCD (SLO)		;;CLRDD1+3
	CAIE	T1,(F)		;NO. IS LINK THE ONE WE WANT?
	JRST	CLRDD1		;NO. TRY NEXT

;HERE WITH T2=LOC OF DDB WHOSE LINK IS THE ONE WE WANT
	MOVE	T3,DEVSER(F)	;LINK OF DDB WE ARE REMOVING
	HLLM	T3,DEVSER(T2)	;SAVE IN LINK OF PREDECESSOR
	MOVEI	T1,DDBCOR	;NO OF 4-WORD BLOCKS TO RETURN
	HRRZ	T2,F		;LOC OF DDB TO CLEAR
	SKIPE	ONCTIM		;SKIP IF AT ONCE TIME
	PJRST	GIV4WD		;RETURN THE CORE AND RETURN TO CALLER
	POPJ 	P,

	INTERN	NAMSTR
;SUBROUTINE TO RETURN THE ACTUAL STR NAME FOR A DDB
;ENTER WITH F=LOC OF DDB
;EXIT CPOPJ IF NOT A DISK OR NO UNIT ASSOCIATED WITH DDB (LOOKUP NOT DONE)
;EXIT CPOPJ1 IF A DISK, WITH T1=NAME OF STR

PRINTF(<[NAMSTR Ought to return STRNAM( DRBSTR( DEVDRB(F) ) ) as name]>)
NAMSTR:	MOVE	T1,DEVMOD(F)	;IS DEVICE A DISK?
	TLNN	T1,DVDSK
	  POPJ	P,

;;*;;	Might need CB resource for this -- consider this!
;;*;;	HLRZ	T1,DEVDRB(F)		; Get directory block
;;*;;	HRRZ	T1,DRBSTR(T1)		; and structure block
;;*;;	MOVE	T1,STRNAM(T1)		; Name of structure

	MOVE	T1,[SIXBIT /DSKB/]	; Think DSKB for now
	PJRST	CPOPJ1			;SKIP-RETURN

SUBTTL	COMCON - COMMAND DECODER INTERFACE ROUTINES

;SUBROUTINE TO PERFORM "DISK" COMMAND - PRINT DISK ACCESSES
;CALL:	MOVE	J,JOB NO.
;	PUSHJ	P,DSKCOM	;CALLED FROM COMCON - COMMAND DECODER
;	ALWAYS RETURN
;PRINTS INCREMENTAL READS AND WRITES, TOTAL READS AND WRITES
;TOTAL BLOCKS ALLOCATED, AND KILO-DISK-MIN FOR ALL STRS COMBINED

	INTERN	DSKCOM
EXTERN	DECIN,COMERA,ATT1,CRLF,JBTRCT,JBTWCT,JBYRCT,RADX10,JBTSIN
	EXTERN	JBYWCT,INLMES,JOBN,CHKSGJ

DSKCOM:	PUSHJ	P,DECIN		;GET DECIMAL JOB NO. ARG IF ANY
	  JRST	DSKCM1		;NO ARG, ASSUME USER'S OWN JOB(AC [=J)
	  JRST	COMERA		;BAD CHARACTER, PRINT ERROR
	CAIL	T2,JOBN		;JOB NUMBER TO LARGE?
	JRST	ATT1		;YES, PRINT NOT A JOB NO.
	EXCH	J,T2		;NO, SETUP JOB NUMBER
	PUSHJ P,CHKSGJ		;SEE IF HE CAN HAVE THAT INFO
	  JRST	[MOVE J,T2	;No - restore caller's frame number
		 JRST COMERA]	;And take common command error exit.
	PUSH P,T2		;SAVE JOB NUM (IN CASE DSK 0)
	PUSHJ P,DSKCM2
	POP P,J
	POPJ P,

;HERE WHEN USER DID NOT SPECIFY A JOB NUMBER - SO DO HIS WITH INCREMENTAL
DSKCM1:	PUSHJ	P,INLMES	;NO, PRINT MESSAGE
	ASCIZ	/RD,WT=/
	PUSHJ	P,DSKINC	;PRINT INCREMENTAL DISK READS
	PUSHJ	P,INLMES	;COMMA
	ASCIZ	/,/
	PUSHJ	P,PRTWDW	;PRINT NO OF INCREMENTAL DISK WRITES
	PUSHJ	P,CRLF		;PRINT CRLF
;HERE TO PRINT DATA FOR ANOTHER JOB(IE DO NOT PRINT INCREMENTAL)
DSKCM2:	PUSHJ	P,INLMES	;PRINT HEADING
	ASCIZ	/RD,WT=/
	LDB	T1,JBYRCT	;TOTAL NO. OF READS FOR JOB SINCE LOG-IN
	PUSHJ	P,RADX10	;PRINT DECIMAL
	PUSHJ	P,INLMES	;PRINT COMMA
	ASCIZ	/,/
	ADDI	J,JBTWCT-JBTRCT	;INCREASE JOB NO. BY DIFF. IN TABLE ORIGINS
	LDB	T1,JBYWCT	;TOTAL NO. OF WRITES FOR JOB SINCE LOGIN
	PUSHJ	P,RADX10	;PRINT DECIMAL
	MOVEI	J,JBTRCT-JBTWCT(J)	;RESTORE J TO ORIGINAL JOB NO. (ELSE COMCON CONFUSED)
	PJRST	CRLF		;PRINT CRLF AND RETURN

;SUBROUTINE TO PRINT NO OF DISK WRITES (RESULT OF WATCH COMMAND)
;CALL:	MOVE J,JOB NO [J=J]
;	PUSHJ P,PRTWDW
PRTWDW:	ADDI	J,JBTWCT-JBTRCT	;INCREASE JOB NO BY DIFF IN READ/WRITE TABLE ORIGINS
	PUSHJ	P,DSKINC	;PRINT INCREMENTAL DISK WRITES
	MOVEI	J,JBTRCT-JBTWCT(J)	;@ECREASE JOB NO BY DIFF IN TABLE ORIGINS
	POPJ	P,

;SUBROUTINE TO PRINT INCREMENTAL NO. OF BLOCKS READ OR WRITTEN
;CALL:	MOVE	J,JOB NO.(J=J)
;	PUSHJ	P,DSKINC
;	ALWAYS RETURN

	EXTERN	JBYIRD,JBRIRD

PRTWDR:				;PRINT INCREMENTAL NO OF BLOCKS READ
DSKINC:	LDB	T1,JBYRCT	;TOTAL NO OF READS(OR WRITES) FOR JOB
	LDB	T2,JBYIRD	;INCREMENTAL SETTING(LOW ORDER N BITS
				; OR TOTAL NO.)
	DPB	T1,JBYIRD	;UPDATE INCREMENTAL SETTING WITH CURRENT TOTAL
	SUB	T1,T2		;DIFFERENCE CUR TOTAL-LAST TOTAL
	ANDI	T1,JBRIRD	;MASK OUT ALL BITS OUTSIDE INCREMENTAL FIELD
	PJRST	RADX10		;PRINT DECIMAL AND RETURN
;COMMAND TO PRINT FILE STRUCTURES IN SYSTEM, AND UNITS NOT IN STRUCTURES
; (RESOURCES COMMAND)
DSKRES==CPOPJ		;FOR NOW

;SUBROUTINE TO CLEAN UP CORE ON A KJOB COMMAND
;CALLED AT CLOCK LEVEL IF NO CORE, M LEVEL IF CORE WHEN JOB IS KILLED
;CALL	MOVE J,JOB NUMBER
;	PUSHJ P,DSKKJB
DSKKJB:	MOVE	T1,JBTPPN(J)	;PPN OF JOB
	MOVE	T2,HIGHJB	;CHECK FOR OTHER JOBS WITH SAME PPN
DSKKLP:	CAIN	T2,(J)		;IS NEXT JOB=CURRENT JOB?
	SOJLE	T2,DSKLGO	;YES, DONT TEST PPN'S
	CAMN	T1,JBTPPN(T2)	;NO. IS ANOTHER JOB LOGGED IN UNDER SAME NUMBER?
	POPJ P,
	SOJG	T2,DSKKLP	;NO, KEEP LOOKING
	PJRST DSKLGO

;CHGPPN - Change PPN, used by the GFD program, called from CALLI 74 uuo

CHGPPN::MOVSI	T2,LICJAL	;Must have JL license
	CAME	T1,MFDPPN	;Cannot GFD to (UFD)[1,1]
	TDNN	T2,JBTLIC(J)
	 POPJ	P,
	PUSH	P,T1
	PUSHJ	P,DSKKJB	;GET RID OF OLD PPN
	SETZM	JBTNM1(J)	;Clear out the username associated with GFD'd
	SETZM	JBTNM2(J)	; PPN so CHGNAM will work
	POP	P,JBTPPN(J)
	PUSHJ	P,CHGNAM	;Make sure GETTAB tables 31 and 32 match
	JRST	CPOPJ1		;End of CHGPPN uuo

;CHGNAM - Change name, called from CHGPPN, LOGIN, and CREFRM uuos

CHGNAM::MOVE	T1,JBTPPN##(J)	;Get current PPN (as set by GFD)
	PUSHJ	P,PPNUSR	;Get username in T2 and T3
	  SETZB	T2,T3		;Not found
	MOVEM	T2,JBTNM1##(J)	;Store first half
	MOVEM	T3,JBTNM2##(J)	;2nd half
	POPJ	P,		;End of CHGNAM
SUBTTL	CLOSE
;WHEN RENAME CALLS CLOSE, IT MAY ALREADY HAVE THE MONITOR BUFFER, AND THE RIB
;MAY BE IN IT. IF SO, DEPRIB IS ON IN S

;INPUT CLOSE
CLOSIN:	TLZN	F,LOOKB		;LOOKUP IN FORCE?
	  PJRST	STOIOS		;NO. RETURN
	NOCHARGE
	TLNN	F,ENTRB		;IF OUTPUT STILL OPEN, DON'T WIPE OUT UPTPOS.
	  PUSHJ	P,SIMRLS	;CLEAN UP SIMIO DATA BASE
	MOVEI	T1,DECSTP
	DPB	T1,DEYSTC	;IN CASE OF ERROR HERE
	PUSHJ	P,GETCBR
	HRRZ	P2,DEVATB(F)	;% CHECK ON STATUS OF FILE
	HLRZ	P4,DEVDRB(F)
	SKIPE	P2
	  SKIPN	P4
	 STOPCD (SLO)           ;;CLOSIN+14
	MOVE	T1,ATBSTS(P2)
	TRNE	T1,ATPREN	;% IF RENAME ON, THE ONE WHO TURNS
	  JRST	CLSXT1		;% IT OFF WILL WORRY ABOUT READ COUNT=0
	PUSHJ	P,TSTRES	;% MAKE SURE WE GIVE UP RESOURCES(UNLESS RENAME)
CLOSRN:	TRNN	T1,ATMCNT-1	;% IS HE THE LAST READER?
	TRNN	T1,ATPDEL	;% FILE MARKED FOR DELETION?
	  JRST	CLSIN2		;% NO
CLIDEL:	PUSHJ	P,GIVCBR
	PUSHJ	P,RIBWTL	;GET RIB WRITE LOCKED
	  JRST	CLIBDR		;BAD RIB, FIX QUOTAS AND GO TO FREACC.
	PUSHJ	P,DLTALL	;I CAN'T BELIEVE I ATE THE WHOLE THING.
	  JFCL			;IGNORE ERROR RETURN
				;DON'T TRY TO ADJUST QUOTAS, GIVPAG SUBTRACTS AS IT GOES ALONG.
	SETZM	ATBRIB(P2)	;IN CASE THE FILE IS STILL MAPPED,
				; TELLS REMOVE THAT RIB WENT AWAY.
	PUSHJ	P,LOGTST	;RECOMPUTE RIBUSD IF PPN NOT LOGGED IN

;HERE WHEN THE FILE NAME WAS NOT FOUND IN THE UFD.
; ALSO COME HERE FROM DELETE CODE WHEN RIB ERROR OCCURS, ATBRIB CAN BE ZERO!
FREACC:	TLZ	F,RENMB!ENTRB		;TURN OFF RENMB SO CLOSE OUTPUT WONT DO ANYTHING
	PUSHJ P,GETCBR
	HRRZ P3,ATBFNB(P2)	;% FOR DELETING FNB
	PUSHJ P,ULKDBL		;% AND REMOVE DDB
	MOVNI	T1,ATPCNT	;% ONE LESS READER OF FILE
	ADDB	T1,ATBSTS(P2)	;% AND GET ATBSTS IN T1
	TLNN	T1,ATMUMC	;% ANYONE STILL HAVE A PAGE MAPPED?
	PJRST CLSN3A		;% NO, DELETE PPB ETC. IF NECESSARY
	PJRST CLSIN5		;% YES, JUST ZERO DEVATB AND LEAVE AT ALONE

;HERE IF BAD RIB TRYING TO DELETE ATPDEL FILE OR BAD RIB IN DELETE
; CODE

CLIBDR:	MOVE	T1,ATBALP(P2) ;TRY TO ADJUST QUOTAS PROPERLY
	ADD	T1,DRBALC(P4)  ;GET PROPER VALUE - AS IF WE DELETED THE PAGES
	SKIPL	DRBALC(P4)	;IF NEGATIVE, REPLACE ANYWAY
	SKIPL	T1		;DON'T DECREASE
	MOVEM	T1,DRBALC(P4)	;STORE NEW DRBALC
	PUSHJ	P,LOGTST	;IF DIRECTORY NOT CONNECTED TO, RECOMPUTE RIBUSD AND RIBMXA
	JRST	FREACC		;AND GO GET RID OF ATB IF WE CAN.
;HERE WHEN FILE IS NOT MARKED FOR DELETION
CLSIN2:	TRNN	M,CLSOUT	;% SUPPRESSING OUTPUT CLOSE?
	TLNN	F,ENTRB+RENMB	;% NO, ENTER OR RENAME DONE?(IF SO, CLSOUT WILL BE CALLED)
	SKIPA
	JRST CLSXIT		;% YES. RETURN
	MOVE	T1,JBTLIC(J)	;% GET PROCESS LIC
	TRNE	M,CLSDMP	;% SET DUMPED BIT?
	TLNN	T1,LICJAL+LICWFL	;% APPROPRIATE LIC?
	JRST	CLSIN7		;% NO
	MOVSI	T1,ATPDMP
	IORM	T1,ATBLCW(P2)	;% SET DUMPED BIT
	PUSHJ	P,UPDUF0	;% UPDATE THE UFD
	PUSHJ	P,GETCBR	;GET CB BACK
	JRST	CLSIN8		;UPDATE RIB
CLSIN7:	TRNE	M,CLSACC	;% SUPPRESS UPDATING ACCESS DATE?
	JRST	CLSIN3		;% YES, DONT WRITE RIB

;NOW CLEAR ATPALC IF ITS OK TO. IF CLSACC ON, TRY TO GUARANTEE
; THAT WE DON'T WRITE ANY DISK ON INPUT CLOSE - THUS THIS CALL
; IS AFTER CHECK ON CLSACC.

CLSIN8:	MOVE	T1,ATBLCW(P2)	;% GET LIC WORD
	TLNE	T1,ATPALC	;% IF THIS BIT IS SET,
	 PUSHJ	P,CLRACH	;% TRY TO CLEAR IT.
	LDB	T4,ATYADT	;% GET CURRENT ACCESS DATE FOR BELOW
	MOVE	T1,ATBLCW(P2)	;% GET NEW LIC WORD
	TLNE	T1,ATPALC	;% IF ATPALC HAS CHANGED (WENT OFF)
	TLNE	T1,ATPDMP	;%  OR ATPDMP IS SET
	 JRST	CLSN2B		;%  THEN ALWAYS UPDATE RIB
	CAME	T4,THSDAT	;% IS ACCESS DATE=TODAY?
	 TLNN	F,INPB!MAPB	;% DATE NEQ TODAY, ANY INPUTS DONE?
	  JRST	CLSIN3		;% NO NEED TO UPDATE ACCESS DATE, JUST SET A.T. DORMANT
CLSN2B: TLNE	F,INPB!MAPB	;% IN CASE FORCING RIB OUT DUE TO ATPALC
	 MOVE	T4,THSDAT	;% SET ACCESS DATE=TODAY IF INPUT DONE
	TRNN 	M,CLSACC	;% DO NOT RESET ACCESS IF HERE ON ERR
	 DPB	T4,ATYADT	;% IN AKB
	PUSHJ 	P,GIVCBR
	PUSHJ 	P,RIBWTL	;GET RIB WRITE LOCKED
	 JRST 	CLSN2A		;ERROR
	HLRZ T2,ATBMSC(P2)	;RESET ACCESS DATE
	HRRM T2,%RIB+RIBEXT
	MOVE T2,ATBLCW(P2)	;GET LIC WORD
	CAME T2,%RIB+RIBLCW	;IF ITS CHANGING
	MOVEM T2,%RIB+RIBLCW	;THEN CHANGE IT.
	PUSHJ P,RELLOK		;FINISHED WITH RIB
CLSN2A:	PUSHJ P,GETCBR
	MOVE T2,ATBSTS(P2)
	TRNE T2,ATPREN
	JRST CLSXT1		;% RENAME ON WHILE RIB FIDDLE, EXIT
	TRNE T2,ATMCNT-1		;% COUNT NOW 1?
	JRST CLSIN3		;% NO
	TRNE T2,ATPDEL		;% YES, HAS DELETE GONE ON?
	JRST CLIDEL		;%YES, GO DELETE FILE

;DELETE EXPECTS TO JUMP INTO THIS POINT ON RIB ERROR, WITH ATBRIB POSSIBLY 0.

CLSIN3:	TLNE	F,ENTRB+RENMB	;% ENTER OR RENAME DONE?
	JRST CLSXIT		;% YES, EXIT (UPDATE SUPPRESSING OUTPUT CLOSE)
	HRRZ P3,ATBFNB(P2)
	PUSHJ P,ULKDBL	;REMOVE DDB FROM LINKED LIST
	MOVNI T1,ATPCNT
	ADDB T1,ATBSTS(P2)	;DECREMENT COUNT
	TDNE T1,[ATMUMC,,ATMCNT!ATPUPD!ATPMXU]
	JRST CLSIN5		;STILL IN USE
	TLNE	F,INPB!MAPB		;% NO. ANY INPUTS BEEN DONE?
	JRST	CLSIN6		;% YES, JUST MAKE A.T. DORMANT
;HERE TO SEE IF NMB NOW HAS NO A.T.S IN ITS RING
CLSN3A:	PUSHJ P,FREATB		;% RETURN AT TO FREE STORAGE
	HLRZ T1,FNBATB(P3)	;% ANY ATBS LEFT?
	JUMPN T1,CLSIN5		;% YES, DO NOT DELETE FNB
	HRRZ T2,FNBDRB(P3)	;% GET SET TO REMOVE FNB
	MOVEI T3,DRBFNB-FNBLNK(T2)	;% FAKE A PRED.
	HLRZ T2,DRBFNB(T2)	;% FIRST FNB
CLSN3B:	CAIN T2,(P3)
	JRST CLSIN4
	MOVE T3,T2		;% RESET PRED
	HLRZ T2,FNBLNK(T2)	;% NEXT
	JUMPN T2,CLSN3B
	 STOPCD (SLO)		;;CLSN3B+5

CLSIN4:	MOVE T1,FNBLNK(P3)	;% NOW LINK AROUND FNB
	HLLM T1,FNBLNK(T3)
	MOVE T2,SYSCOR
	HRLM P3,SYSCOR
	HLLM T2,CMBLNK(P3)	;% AND PUT FNB ON FREE LIST
	JRST CLSIN5

CLSIN6:	PUSHJ P,LKDATB		;%JUST PUT THE ATB ON DORMANT LIST
CLSIN5:	SETZM DEVATB(F)
	JRST CLSXT2

CLSXT1:	HRRZ P3,ATBFNB(P2)
	PUSHJ P,ULKDBL
	SETZM DEVATB(F)
	TDZA T1,T1	;FOR DEB IN DAYSTS
CLSXIT:	MOVEI T1,DECUP2	;HERE ON UPDATE CLOSE IN (SET DEYSTC
	DPB T1,DEYSTC
	MOVNI T1,ATPCNT
	ADDM T1,ATBSTS(P2)	;% DEC COUNT
CLSXT2:	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	 STOPCD (SLO)           ;;CLSXT2+2
STOCBR:	MOVEM S,DEVIOS(F)
	HLLM F,%UPT+UPTJDA(W)
	PJRST GIVCBR
;CLOSE OUTPUT


CLOSOU:	TLNN	F,ENTRB	;ENTER OR RENAME DONE?
	POPJ	P,		;NO. RETURN
	PUSHJ P,TSTRES
	NOCHARGE	;TURN OFF CHARGING
	PUSHJ P,SIMRLS		;CLEAN UP SIMIO DATA BASE
	MOVEI T1,DECSTP
	DPB T1,DEYSTC
	HRRZ P2,DEVATB(F)
	HLRZ P4,DEVDRB(F)
	SKIPE P2
	SKIPN P4
	 STOPCD (SLO)           ;;CLOSOU+11
	HRRZ P3,ATBFNB(P2)	;JUST TO MAKE SURE ITS LOADED
	PUSHJ P,PTROUT	;DUMP CHANGED POINTERS
	 JRST NOOUT2	;RIB ERROR
	 JRST CLSOU1	;NONE (RIB NOT GOTTEN)
	SKIPN %RIB+RIBRIB	;IS IT THE PRIME RIB IN CORE
	JRST CLSOU0	;YES, GO
	PUSHJ P,RELLOK	;GET RID OF IT
CLSOU1:	PUSHJ P,RIBWTL	;GET RIB WRITE LOCKED
	 JRST NOOUT2	;CAN NOT, RIB ERROR
;HERE WHEN THE FILE IS COMPLETELY WRITTEN
CLSOU0:	TRNE	M,CLSRST	;SHOULD THIS CLOSE ACT LIKE A RESET?
	TLO	F,RESETB	;YES. TURN ON RESETB
	HRRZ	P2,DEVATB(F)	;NO. JUST GET LOC OF A.T.
	MOVE	T2,ATBSTS(P2)	;STATUS OF FILE
	TRNN	T2,ATPCRE!ATPSUP ;SKIP IF NOT UPDATING
	TLZ	F,RESETB	;UPDATING, MAKE SURE FILE ISNT DELETED
	TLZN F,RESETB	;IS THIS A RESET?
	JRST CLSOU2	;NO, GO
	PUSHJ	P,DLTALL	;I CAN'T BELIEVE I ATE THE WHOLE THING.
	 JFCL
	SETZM	ATBRIB(P2) ;TELL REMOVE RIB IS GONE. NO ONE ELSE
			; CAN USE THIS ATB YET IS ASSUMPTION.
	PUSHJ P,LOGTST	;AND UFD QUOTAS
CLORS1:	PUSHJ P,GETCBR
	HRRZ P3,ATBFNB(P2)
	PUSHJ P,ULKDBL	;UNLINK DDB FROM FNB
	MOVEI T1,ATPCRE!ATPSUP	;TURN THESE OFF IN CASE THIS STAYS AROUND
	ANDCA T1,ATBSTS(P2)	;GET STATUS WITHOUT BITS
	TLNN T1,ATMUMC		;ANYTHING STILL MAPPED?
				; (MUST BE THIS JOB)
	JRST CLORS2		;NO, DELETE THE ATB
	TRO T1,ATPDEL		;YES, SET ATPDEL SO DECUMC WILL DELETE THE ATB
				;WHEN LAST PAGE IS UNMAPPED
	MOVEM T1,ATBSTS(P2)	;STORE
	JRST CLORS3
CLORS2:	PUSHJ P,FREATB	;RETURN ATB TO FREE CORE
CLORS3:	SOS T2,DRBCNT(P4)	;DECREMENT COUNT
	TRNE T2,DRPMXC
	 STOPCD (SLO)		;;CLORS3+2
	SETZM DEVATB(F)
	TLZ F,ENTRB!RENMB!LOOKB
	PJRST STOCBR	;DONE

NOOUT2:	TLZE F,RESETB	;RIB ERROR, RESET?
	JRST CLORST	;YES, GO DUMP IT
	MOVE T1,ATBSTS(P2)
	TRNN	T1,ATPCRE!ATPSUP	;SKIP IF NOT UPDATE
	JRST	CLOUPD	;THIS IS UPDATE, MUST WATCH OUT FOR OTHER USERS OF FILE ETC.
	TRNE T1,ATPCRE	;IS THIS CREATE?
	JRST CLOSCR	;GO DO IT ANYWAY

CLORST:	MOVE T1,ATBALP(P2)	;TRY TO ADJUST QUOTAS
	ADD T1,DRBALC(P4)
	SKIPL DRBALC(P4)
	SKIPL T1
	MOVEM T1,DRBALC(P4)
	JRST CLORS1
CLSOU2:	MOVE	T1,ATBSIZ(P2)	;RESET SOME THING IN RIB
	TRNE	T1,177
	SUBI	T1,200
	CAME	T1,%RIB+RIBSIZ	;CHANGE ONLY IF CHANGING
	MOVEM	T1,%RIB+RIBSIZ
	MOVE	T1,THSDAT
	MOVE	T3,ATBSTS(P2)
	TRNN	T3,ATPCRE!ATPSUP
	TLNE	F,INPB!OUTPB!MAPB	;IF UPDATE, RESET ONLY IF I/O
	DPB	T1,ATYADT		;SET ACCESS DATE
	HLRZ	T1,ATBMSC(P2)
	HRRZ	T2,%RIB+RIBEXT	;SEE IF CHANGING
	CAME	T1,T2
	HRRM	T1,%RIB+RIBEXT
	MOVE	T1,ATBLCW(P2)
	MOVE	T2,%RIB+RIBSTS
	TRNN	T2,RIPHWE!RIPHRE!RIPBDA!RIPBFS!RIPBDR
	TLZA	T1,ATPUFE
	TLO	T1,ATPUFE
	TRNE	T3,ATPSUP!ATPCRE	;IF NOT UPDATE,
	TLO	T1,ATPALC	;THEN HAVE TO SET THIS BECAUSE PRIME RIB GOT ALLOCATED
				;IF NOTHING ELSE.
	MOVEM	T1,ATBLCW(P2)	;GET SET FROM ERROR BITS
	CAME	T1,%RIB+RIBLCW 	;ONLY WRITE IF ITS CHANGING
	MOVEM	T1,%RIB+RIBLCW
	MOVE	T1,ATBALP(P2)
	CAME	T1,%RIB+RIBALP
	MOVEM	T1,%RIB+RIBALP
	MOVE	T1,ATBPVW(P2)
	CAME	T1,%RIB+RIBPVW
	MOVEM	T1,%RIB+RIBPVW
	HRRZ	T3,ATBFNB(P2)	;GET FNB
	MOVE	T1,ATBLCW(P2)	;GET ATPALC BIT
	TLNN	T1,ATPALC	;IF ATPALC IS SET, THEN NEED TO STORE RIBALT AND FNBALT
	JRST	CLSOU3
	MOVE	T2,PCDTIM	;OK, SET FNBALT AND RIBALT FOR ANY ALLOCATION
				; THAT MIGHT HAVE HAPPENED
	CAME	T2,%RIB+RIBALT  	;ONLY CHANGE IF ITS CHANGING
	MOVEM	T2,%RIB+RIBALT	;SET CORRECT VALUE.
	MOVEM	T2,FNBALT(T3)	;WE MAY BE INCREASING THE FNBALT FOR
				; THE OLD FILE, BUT DOESN'T MATTER SINCE
				; NORMALLY OLD FILE GOES AWAY UNLESS
				; CAN'T UPDATE UFD OR SOMETHING, IN WHICH
				; CASE NO HARM MAKING THIS BIGGER.
				; (IN THAT CASE, RIBALT WILL DIFFER FROM FNBALT)
CLSOU3:	PUSHJ	P,RELLOK	;ASSUME THIS WON'T RESCHEDULE.
				; (OR ELSE PCDTIM WILL BE WRONG FOR THE RIB.)
	MOVE	T2,ATBSTS(P2)
	TRNE	T2,ATPCRE
	JRST	CLOSCR		;CLOSE FOR CREATE
	PUSHJ	P,UPDUFD	;UPDATE THE UFD.
	MOVE	T1,ATBSTS(P2)
	TRNN	T1,ATPSUP 	;IF SUPERCEDE
	JRST	CLOUPD		;NOT, MUST BE UPDATE
	MOVSI	T2,ATPALC	;AND IF ALC IS ON,
	TDNE	T2,ATBLCW(P2)	;THEN
	PUSHJ	P,WATPCB	;MUST WAIT FOR UFPALC TO GO OUT.
				; OR ELSE MIGHT GET OLD UFD POINTER WITH NO
				; BIT ON POINTING TO FREE PAGE.
;SUPERCEDE MUST LOOK AT OTHER A.T.'S

	PUSHJ P,GETCBR
	MOVEI T2,ATPUPD!ATPSUP!ATPMXU
				;TURN SUP INTO UPD
				; SO THAT ANYONE WHO LOOKS UP THIS
				; FILE WHILE WE'RE STILL CLOSING WILL
				; GET THIS COPY.
	XORM T2,ATBSTS(P2)
	AOS T2,ATBMWC(P2)	;INCREMENT MAX WRITE COUNT
	TRNN T2,ATMMWC		;CHECK FOR OVERFLOW
	 STOPCD (SLO)		;;CLOSU3+20
	AOS FNBUPD(P3)		;BUMP COUNT OF UPDATERS
	HLRZ T2,FNBATB(P3)	;GET SET TO SEARCH
CLOSU1:	MOVE T1,ATBSTS(T2)	;IF THERE IS ONE SUP ATB, SHOULDN'T BE
	TRNE T1,ATPCRE!ATPSUP!ATPREN ; ANY OTHER WRITERS
	 STOPCD (SLO)		;;CLOSU1+2
	TRNE T1,ATPUPD!ATPDEL ;IGNORE OUR OWN AND DELETED ONES
	JRST CLOSU2	;IGNORE THESE
	SKIPE ATBDOR(T2)	;NOT DORMANT MUST BE READERS
	JRST CLOSU3
	MOVEI T1,ATPDEL
	IORM T1,ATBSTS(T2)	;MARK TO DELETE IT
	PUSHJ P,GIVCBR
	JRST CLOCOM	;AND GO

CLOSU2:	HLRZ T2,ATBLNK(T2)	;NEXT ATB
	JUMPN T2,CLOSU1
CLOSU4:	MOVE T1,ATBRIB(P2)
	EXCH T1,FNBRIB(P3)
	PUSHJ P,GIVCBR
	MOVEM T1,DEVRIB(F)	;NOW MUST DELETE OLD
	TLO S,IO
	PUSHJ P,CRBRWL
	 JRST	[PUSHJ P,RELLOK
		JRST CLOCOM]	;RIB ERROR, GIVE UP
	HLLZS DEVATB(F)	;DO NOT WANT ATBALP ADJUSTED
	PUSHJ	P,DLTALL	;I CAN'T BELIEVE I ATE THE WHOLE THING.
	 JFCL
	HRRM P2,DEVATB(F)	;RESTORE
	JRST CLOCOM	;NOW FOR COMMON CODE

CLOSU3:	PUSH P,P2
	MOVE P2,T2	;MUST REMOVE ATB
	PUSHJ P,RMVATB
	POP P,P2
	JRST CLOSU4	;AND FINISH UP
CLOSCR:	SETZ	T2,		;NO RET PNTR SUPPLIED TO INSNAM.
	PUSHJ P,INSNAM	;CREATE, INSERT NAME IN UFD
	 JRST CLOCOM	;COULDN'T(ALLOC FAIL, RIB ERR, DIR FULL).
	PUSHJ P,CREUFD	;PUT STUFF INTO THE DIRECTORY
	PUSHJ P,RELLOK
	MOVEI T1,ATPDIR
	TDNN T1,ATBSTS(P2)
	JRST CLOCOM
	PUSHJ P,GETCBR	;ITS A UFD. MUST WORRY IF DRB
	MOVE T1,DEVFIL(F)
	PUSHJ P,FNDDRB
	 JRST CLOUF1	;NONE THERE
	SETZM DRBRIB(T2)
	MOVEI T1,DRPNX
	ANDCAM T1,DRBNX(T2)
CLOUF1:	PUSHJ P,GIVCBR
	JRST CLOCOM

CLOUPD:	TLNN F,LOOKB	;IF CLOSING OUTPUT ONLY
	JRST CLOCOM
	PUSHJ	P,INVDDB	;INVALIDATE THE DDB, SET FILE LOC TO START.
		;FALL INTO COMMON CODE
	SKIPA T1,[DECLUK]	;SET TO LOOKUP IF ONLY OUT CLSD
CLOCOM:	MOVEI T1,0	;DONE WITH STATUS
	DPB T1,DEYSTC
	PUSHJ P,LOGTST	;RESET UFD USD INFO IF NEEDED
	MOVE T1,ATBRIB(P2)
	TLZ F,ENTRB!RENMB
	MOVEM T1,FNBRIB(P3)
	MOVSI T1,FNPNX
	ANDCAM T1,FNBNX(P3)	;MAKE SURE FNB MARKED AS THERE
	PUSHJ P,GETCBR
	MOVE T1,ATBSTS(P2)	;PICKUP ATBSTS
	TRZE T1,ATPSUP!ATPCRE	;CLEAR THESE, SKIP IF UPDATING
	JRST CLOCM1		;CREATE (SUPERCEDE TURNED INTO UPDATE)
	SOSGE FNBUPD(P3)	;DECREMENT UPDATE COUNT
	 STOPCD (SLO)		;;CLOCOM+15
	SOS T2,ATBMWC(P2)	;DECREMENT MWC FOR UPDATER
	TRNN T2,ATMMWC		;COUNT GO TO ZERO?
	TRZ T1,ATPMXU		;YES, CLEAR MAX WRITE BIT
	TRZ T1,ATPUPD		;CLEAR IN CASE IT WAS SINGLE UPDATER
CLOCM1:	MOVEM T1,ATBSTS(P2)	;STORE NEW ATBSTS.
	TDNN T1,[ATMUMC,,ATPMXU!ATMCNT] ;SKIP IF ANY USERS STILL
	PUSHJ P,LKDATB	;MAKE ATB DORMANT IF NO MORE USERS
	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	 STOPCD (SLO)           ;;CLOCM1+5
	TLNE	F,LOOKB
	JRST	CLOCM2		;ALMOST DONE.
	PUSHJ	P,ULKDBL	;REMOVE FROM DDB LIST
	SETZM	DEVATB(F)	;NO MORE AT
CLOCM2:	PUSHJ	P,STOCBR	;
	PJRST	WATPCB		;
;TEST TO SEE IF THE USER IS LOGGED IN AND RESET UFD USD IF NOT

LOGTST:	MOVEI T2,DRPLOG
	TDNE T2,DRBLOG(P4)
	POPJ P,		;NOT LOGGED IN
	TLO S,IO
	PUSHJ P,RIBDIR
	 PJRST RELLOK	;CAN NOT GET IT
	HLRZ T1,DEVDRB(F)
	MOVE T2,%RIB+RIBQTF
	SUB T2,DRBALC(T1)
	MOVEM T2,%RIB+RIBUSD
	MOVE T2,%RIB+RIBQTF
	SUB T2,DRBMXA(T1)
	MOVEM T2,%RIB+RIBMXA
	PJRST RELLOK	;ALL DONE

;FILL IN THE UFD FROM THE IN CORE TABLES
; USES T1-T3. EXPECT P2/ATB ADDRESS.

CREUFD:	PUSH	P,P3		;SAVE P3 AND SETUP TO BE FNB ADDRESS
	HRRZ	P3,ATBFNB(P2)	;GET FNB ADDR IN P3
	PUSH	P,T4		;SVE T4 FOR COMPARES BELOW
	MOVE T1,DEVFIL(F)
	CAME	T1,%RIB+UFDNAM(T2) ;DON'T WRITE IF ITS THE SAME
	MOVEM T1,%RIB+UFDNAM(T2)	;T2 POINTS TO THE UFD SLOT
	HLLZ T1,DEVEXT(F)
	HLLZ	T4,%RIB+UFDEXT(T2)	;SEE IF ITS SAME
	CAME	T1,T4
	MOVEM	T1,%RIB+UFDEXT(T2)	;NOT, UPDATE.
	LDB T3,ATYPRV
	LDB	T4,UFYPRV		;SEE IF SAME
	CAME	T3,T4		;SKIP IF NO NEED TO WRITE
	DPB T3,UFYPRV
	LDB T3,ATYUF2
	LDB	T4,UFYUF2	;SEE IF ANY NEED TO WRITE
	CAME	T3,T4		;?
	DPB T3,UFYUF2
	LDB T1,ATYCDT
	CAME	T1,%RIB+UFDCDT(T2)	;ANY NEED TO WRITE?
	MOVEM T1,%RIB+UFDCDT(T2)	;CREATION DATE
	LDB T1,ATYXCD
	LDB	T4,UFYXCD	;SEE IF SAME
	CAME	T1,T4
	DPB T1,UFYXCD	;AND THE EXTENDED PART
	LDB T1,ATYCTM
	IMULI T1,^D60
	LDB T3,ATYCSC	;SECONDS
	ADD T1,T3
	LDB	T4,UFYCTM	;SEE IF SAME
	CAME	T1,T4
	DPB T1,UFYCTM	;AND STORE IN UFD
	LDB T1,ATYUF1
	LDB	T4,UFYUF1
	CAME	T1,T4
	DPB T1,UFYUF1	;MORE BITS
	MOVE T1,ATBLIC(P2)
	HRRZ	T4,%RIB+UFDLIC(T2)
	CAME	T1,T4
	HRRZM T1,%RIB+UFDLIC(T2)
	MOVE T1,ATBALP(P2)	;NUMBER OF ALLOCATED PAGES
	CAIL T1,400000
	MOVEI T1,400000	;SET FLAGIF VERY BIG. NEEDS LOOKUP
	HLRZ	T4,%RIB+UFDALP(T2)
	CAME	T1,T4
	HRLM T1,%RIB+UFDALP(T2)
	MOVE T1,ATBRIB(P2)
	CAME	T1,%RIB+UFDRIB(T2)
	MOVEM T1,%RIB+UFDRIB(T2)
	POP	P,T4		;RESTORE T4 AND
	POP	P,P3		;P3
	POPJ P,
;ROUTINE TO FILL IN ATB WITH PRELIMINARY INFORMATION FROM UFD
; ENTRY IN CASE WE GET A RIB ERROR TRYING TO READ RIB.
; CALLED FROM SRCFIL WITH CB, DRBCNT UP, RIB LOCKED STILL.
; DOES NOT FILL IN ATBRIB, SINCE INFO IS REALLY NOT VALID - IS
; OVERWRITTEN WITH THE REAL DATA FROM THE RIB NORMALLY.
; IF GET A RIB ERROR, PROTECTION AND PID ARE SETUP SO THAT
; USER CAN DELETE IT IF IT REALLY WAS HIS FILE AND IT WAS
; PROTECTED SO HE COULD DELETE IT.
; P2 HAS ATB ADDRESS, T2 HAS POINER TO UFD ENTRY (%RIB+UFD???(T2))

UFDATB::SKIPE	ATBRIB(P2)	;MAKE SURE NOTHING IN THERE ALREADY
	 STOPCD (SLO)		;;UFDATB+1
	LDB	T1,UFYPRV	;GET PROTECTION CODE
	DPB	T1,ATYPRV	;STORE IT THERE.
	LDB	T1,UFYUF2	;GET DUMPED, ERROR, PID BITS ETC
	DPB	T1,ATYUF2
	MOVE	T1,%RIB+UFDCDT(T2) ;GET CREATION DATE
	DPB	T1,ATYCDT
	LDB	T1,UFYXCD	;GET REST OF BITS (EXTENDED)
	DPB	T1,ATYXCD
	LDB	T1,UFYCTM
	IDIVI	T1,^D60		;GET SECONDS IN T2, TIME IN T1
	DPB	T1,ATYCTM	;IN MINUTES
	DPB	T2,ATYCSC	;IN SECONDS
	LDB	T1,UFYUF1	;GET FIRST 4 BITS
	DPB	T1,ATYUF1	;AND STORE THEM
	HRRZ	T1,%RIB+UFDLIC(T2)
	HRRM	T1,ATBLIC(P2)	;STORE INTO RH OF ATBLIC.
				;(FOR INFO - CAN'T RUN ANYTHING ANYWAY)
	MOVE	T1,%RIB+UFDALP(T2) ;GET SIZE
	MOVEM	T1,ATBALP(P2)	;STORE. INCLUDES 400000,,0 IF DON'T KNOW HOW BIG.
	MOVSI	T1,ATPPID	;DOES THIS FILE HAVE A PID?
	TDNN	T1,ATBLCW(P2)	;IF NOT, JUST RETURN.
	POPJ	P,		;AND RETURN.
	MOVEI	T1,777777	;USE LAST SYSTEM PID
	MOVEM	T1,ATBPID(P2)	;SO THAT ITS PROTECTED AGAINST THE OWNER UNLESS HE HAS LICENSE.
	POPJ	P,		;RETURN NOW.
;ROUTINE CALLED BY ROUTINES THAT ALLOCATE BEFORE THEY ALLOCATE
; TO SET UFDALC AND ATBALC. GETS CB RESOURCE, NEEDS %RIB TO
; PUT UFD INTO.
; EXPECTS F/DDB ADDRESS
; USES T1-T3
; IF CALER DOESN'T WANT ANYTHING TO HAPPEN UNLESS ATPALC IS CLEAR,
; HE MUST CHECK HIMSELF. OTHERWISE ALL CHANGED UFD VALUES WILL GET
; UPDATED.

SETACH::PUSHJ	P,GETCBR	;GET CB RESOURCE
	HRRZ	T2,DEVATB(F)	;GET ATB ADDRESS IN T2 FOR FILSER ROUTINES
	HRRZ	T3,ATBFNB(T2)	;GET FNB ADDRESS IN T3
	MOVE	T1,ATBRIB(T2)	;MAKE SURE THIS FILE-ATB IS THE ONE WITH UFD ENTRY
	CAME	T1,FNBRIB(T3)
	PJRST	GIVCBR		;ITS NOT, DON'T HAVE TO SET THE BIT
	SETOM	FNBALT(T3)	;SO THAT NO ONE WILL CLEAR IT - ACTUALLY JUST DEBUGGING CHECK
	MOVSI	T1,ATPALC	;GET THE BIT
	TDNE	T1,ATBLCW(T2)	;IS IS SET ALREADY?
	PJRST	GIVCBR		;YES, THEN NO NEED TO WRITE OUT UFD AGAIN
	IORM	T1,ATBLCW(T2)	;NO, SO SET IT. NO ONE WILL CLEAR THIS
				; AFTER RELEASE OF CB, SINCE WE HAVE WRITE
				; BITS ON IN THIS ATB.
	PUSH	P,P2		;SAVE P2, NEED IT FOR ATB ADDRESS FOR UPDUF0
	MOVE	P2,T2		;GET ATB ADDRESS IN P2
	PUSHJ	P,UPDUF0	;DO THE COMMON WORK
	POP	P,P2		;RESTORE P2
	PUSH	P,T4		;BOY OH BOY, WATPCB CLOBBERS T4 AND WE CAN'T
	PUSHJ	P,WATPCB
	POP	P,T4
	POPJ	P,		;RETURN.

;HERE IF ATPALC WAS ON TO CLEAR IT
; WITH CB RESOURCE.
;EXPECTS ATB ADDRESS IN P2
;SMASHES T1-T3

CLRACH:	PUSHJ	P,TSTWRT	;DON'T MUCK WITH IT IF FILE IS OPEN FOR ANY SORT OF WRITE
	  POPJ	P,		;GO AWAY, STILL HAVE CB
	HRRZ	T3,ATBFNB(P2)	;GET FNB ADDR IN T3
	MOVE	T1,ATBRIB(P2)	;GET RIB POINTER
	CAME	T1,FNBRIB(T3)	;MAKE SURE THIS FILE IS STILL IN UFD
	POPJ	P,		;JUST RETURN WITH CB STILL
	MOVE	T1,FNBALT(T3)	;GET WHAT PCB DIRTY MONITOR CLOCK WAS AFTER ALLOCATION
	CAMLE	T1,PCDTIM	;IF ALT IS GREATER THAN CURRENT PCDTIM,
	JRST	CLRAC0		; THEN RIBALT MUST HAVE BEEN FROM PREVIOUS MONITOR.
				; SO CLEAR ATPALC.
	ADDI	T1,2		;ONE COUNT FOR THE PCBS THAT WERE ON THEIR
				; WAY OUT, ONE FOR THE ONES THAT WERE DIRTY
	CAMLE	T1,PCDTIM	;IF IT HAS INCREMENTED 2 TIMES, WE WIN
	POPJ	P,		;SORRY, EVERTHING HASN'T GONE OUT YET.

;NOW WE NOW THERE ARE NO MORE WRITERS OF FILE, THE ATB STILL
; REPRESENTS THE FILE WHICH HAS A UFD ENTRY, AND ALL THE PCBS THAT
; WERE DIRTY AT THE LAST ALLOCATION CHANGE HAVE BEEN WRITTEN OUT
; AT LEAST ONCE, AND ALL THE PCBS WHICH HAD IO IN PROGRESS HAVE
; BEEN WRITTEN OUT ONCE AFTER THAT IO STOPPED. WE CAN NOW SAFELY
; SAY THAT ALL INFORMATION (RIBS, SATS, UFD ENTRIES) FOR THE FILE
; ARE ON THE DISK.
CLRAC0:	MOVSI	T1,ATPALC
	ANDCAM	T1,ATBLCW(P2)	;CLEAR IT AND
	PUSHJ	P,UPDUF0	;UPDATE THE UFD
	PJRST	GETCBR		;GET CB BACK FOR CALLER AND RETURN.
				;(NO NEED TO WAIT FOR CLEARED BIT TO MAKE IT BACK TO DISK.)
;ROUTINE TO UPDATE A UFD ENTRY FROM ATB INFORMATION
; CAL WITH CB AT UPDUF0 OR WITHOUT AT UPDUFD
; USES T1-T3, %RIB.
; EXPECTS ATB ADDRESS IN P2, DDB ADDRESS IN F.

UPDUF0:	PUSHJ	P,GIVCBR	;GIVE BACK CB CALLER SHOULD HAVE HAD.
UPDUFD:	PUSH	P,P4		;SVE THIS
	PUSH	P,T4		;MUST SAVE THIS TOO.
	HLRZ	P4,DEVATB(F)	;GET DRB ADDRESS
	PUSHJ	P,RIBDIR	;GET UFD RIB IN %RIB
	  JRST	UPDNUR		;NO UFD RIB, MUST CALL RELLOK
	PUSH	P,P3		;SAVE P3
	HRRZ	P3,ATBFNB(P2)	;GET FNB ADDRESS
	LDB	T1,FNYUFP	;GET POINTER TO THE UFD ENTRY
	TLO	S,IO		;NEED TO WRITE INTO IT
	TLZ	S,IOSRIB	;NOTHING IN %RIB, SO USE IT, NOT %RB2
	PUSHJ	P,DIRBLK	;GET PAGE OF THE UFD THAT ENTRY IS IN
	  PJSP	T1,[POP P,P3	;RESTORE P3
		    JRST UPDNU1] ;AND GO SAY MUST DO SLOW DSKCLN.
	PUSHJ	P,DIRSRC	;OK, GET ENTRY ADDRESS IN T2
	  JRST	UPDUF1		;HAVE IT
;P035/D06 - The only way to get to UPDUFD is if the file was not marked for
;           deletion last time we checked.  If someone (such as MAILER)
;           deleted the file while we where in the page fault from RIBDIR
;           or from DIRSRC, then we should ignore this file.
	MOVE	T1,ATBSTS(P2)	;Could not find file, check its ATB status
	TRNE	T1,ATPDEL	;This bit wasn't set when we started, if
	 JRST	UPDUF2		; now set, then file went away
	 STOPCD (.,DISK,UFDER1,,<UFD error - file disappeared>) ;;UPDUFD+16

UPDUF1:	PUSHJ	P,CREUFD	;OK, UPDATE UFD IF NECESSARY
UPDUF2:	PUSHJ	P,RELLOK	;GET RID OF IT NOW
	POP	P,P3		;RESTORE P3 AND
	POP	P,T4		; T4
	POP	P,P4
	POPJ	P,		;AND RETURN. (DON'T PJRST, RELLOK SMASHES T4.)

UPDNUR:	PUSHJ	P,RELLOK
UPDNU1:	POP	P,T4
	POP	P,P4		;RESTORE THIS.
	 STOPCD (.+1,INFO,BADUFD,DSKCLN##,<Inconsistent UFD - FULL DSKCLN requested>);;UPDNU1+3
	POPJ	P,

;ROUTINE TO SET FNBALT. EXPECTS LIVE DDB IN F (RH(DEVATB) SETUP)
; PRESERVES T1, USES T2 AND T3.
; DON'T NEED CB, SINCE FILE SHOULD HAVE ATPMXU ON, PREVENTING
; SOMEONE ELSE FROM DELETING IT OUT FROM UNDER US (EITHER ITS
; ALREADY DELETED (TRUNCATING RENAME) OR IT IS STILL IN UFD.

SETALT::PUSH	P,T1		;PRESERVE T1
	PUSH	P,P2		;SAVE P2 ALSO
	HRRZ	P2,DEVATB(F)	;GET ATB IN P2
	HRRZ	T1,ATBFNB(P2)	;GET FNB
	MOVE	T3,FNBRIB(T1)	;GET POINTER
	MOVE	T2,PCDTIM	;GET READY IN CASE THIS IS FILE IN UFD
	CAMN	T3,ATBRIB(P2)	;IS THIS THE FILE IN THE UFD?
	MOVEM	T2,FNBALT(T1)	;YES, MAKE COUNT >= TO WHAT IT WAS
	POP	P,P2		;RESTORE
	JRST	TPOPJ		;AND RETURN.
;RELEASE UUO
DSKREL:	PUSHJ	P,WAIT1		;WAIT FOR I/O TO STOP
	MOVE 	J,JOB
	PUSHJ	P,SIMRLS	;FIX SIMIO DATA BASE (DO THIS
				;HERE FOR SUPERIO)
	TLO	F,RESETB	;INDICATE RESET IN PROGRESS
	PUSHJ	P,CLOSIN	;CLOSE INPUT (IF NOT ALREADY DONE)
	PUSHJ	P,CLOSOU	;CLOSE OUTPUT (DITTO)
	TLZ	F,RESETB	;RESET BIT
	SETZM	DEVFIL(F)	;INDICATE FILE RELEASED
	SETZM 	DEVPOS(F)	;FOR GOOD MEASURE, MARK BAD POSITION
	SETZM DEVPPN(F)
	TLZ S,IOSUPR
	PJRST STOIOS
;THIS ROUTINE IS AN ERROR CHECKING ROUTINE CALLED AT THE START
;OF VARIOUS UUO'S. IT INSERTS A NEW RETURN ON THE PUSH-DOWN
;LIST WHICH WILL CHECK TO SEE THAT RESOURCES HAVE BEEN RELEASED.

TSTRES:	POP P,(P)	;CALLED WITH PUSHJ GET STACK DECED
	PUSHJ P,@1(P)	;NOW CALL USING OLD RETURN ADDRESS
	 SKIPA
	AOS (P)		;SKIP RETURN
	PUSH P,T1
	MOVE T1,JOB
	CAME T1,CBUSER	;SEE IF JOB HAS CB
	SKIPE QUEPCB(T1)	;OR A DIRECTORY
UUOXWR:: STOPCD (.,DISK,UUOXWR,,<UUO eXit with Resources still owned>);;TSTRES+10
	SKIPN %UPT+UPTRIB	;NO BLOCKS LOCKED
	SKIPE %UPT+UPTRB2
	 STOPCD (,XCT,UUOXWR)	;;TSTRES+13
	SKIPE %UPT+UPTSAT
	 STOPCD (,XCT,UUOXWR)	;;TSTRES+15
	JRST TPOPJ
SUBTTL	LOOKUP

;LOOKUP
ULOOK:	PUSHJ P,TSTRES	;MAKE SURE WE EVENTUALLY GIVE ALL BACK
	TLNN	S,IOSUPR
	TLNE F,ENTRB
	JRST LUKER1	;CAN NOT DO LOOKUP AFTER ENTER
	NOCHARGE
	PUSHJ P,LKSET	;CHARGE 1 LOOKUP
	PUSHJ P,CHKARG	;CHECK ARGUMENT LIST
	 JRST ILNMER	;BAD NAME (ACTUALLY EXTENDED WITH SMALL COUNT)
	TLO M,UUOLUK	;SET FOR LOOKUP
	PUSHJ P,SETFIL	;GET FILE NAME STORED
	 JRST ILNMER	;BAD NAME
	MOVEI T1,DECSTP
	DPB T1,DEYSTC
	HLRZ T1,DEVEXT(F)	;SEE IF UFD
	TLNE M,EXTUUO		;ONLY ON EXTENDED UUO
	CAIE T1,'UFD'
	JRST ULOOK2		;NOT EXTENDED OR NOT UFD
	MOVE T1,DEVPPN(F)
	CAME T1,MFDPPN
	JRST ULOOK2
	MOVE T1,DEVFIL(F)
	TLNE T1,-1		;IS L.H. 0
	JRST ULOOK2		;NO
	PUSHJ P,LOKLUD		;GET USER NAME TO PPN
	MOVEM T1,DEVFIL(F)
	UMOVEM T1,UUXNAM(M)
ULOOK2:	TLNN M,EXTUUO	;CHECK FOR MULTIPLE EXTENSION LOOKUP
	JRST ULOOK3	;CAN NOT BE
	UMOVE T1,(M)
	TRNN T1,400000
	JRST ULOOK3	;THAT WAS THE FLAG

COMMENT ! DISABLE FANCY LOOKUP FEATURE 16 NOV 77 AAA.
	(GIVE ERROR 0 IF FANCY LOOKUP SPECIFIED) !
	JRST ILNMER
COMMENT !
;PROCESS FANCY (MULTIPLE EXTENSION) LOOKUP. READ USER ARGUMENT
;POINTED AT BY USER'S EXTENSION WORD, NOW IN DEVEXT(F).
;DEVEXT(F)/     USER BLOCK,,0		USER BLOCK/  N
;					          / EXT 1
;						  / EXT 2
;						...ETC...
;						  / EXT N

	HLRZ P2,DEVEXT(F)	;THIS IS THE CORE TABLE OF EXTENSIONS
	UMOVE T2,(P2)
	CAIGE T2,1000
	CAIG T2,0	;DON'T ALLOW TOO MANY
	JRST ERRLKM
	MOVE T1,P2
	ADD T1,T2
	UMOVE T1,(T1)	;TRY TO READ IT SO WE FAULT NOW
;PROCESS FANCY LOOKUP
	HRL P2,T2	;P2/ USER COUNT,,USER ADDR
	ADDI T2,1	;NEED <USER COUNT>EXTENSION WDS+1 COUNT WD
	HRLZ P3,T2	;P3/WDS BEING ALLOCATED,,0
	PUSHJ P,GETWDS	;TAKE T2/WDS NEEDED. RETURN T1/LOC FREECORE
	 JRST ERRNET	;NOT AVAILABLE
	HRR P3,T1	;P3/SIZE EXTBLOCK,,ADDR EXTBLOCK
	SETZM (T1)	;EXTBLOCK[0]_COUNT OF DISTINCT EXT'S SEEN
	HLRZ T2,P2	;T2/USER COUNT
	MOVNS T2	;T2/-USER COUNT
	HRLM T1,DEVEXT(F)	;DEVEXT(F)/EXTBLOCK ADDR,,0
	HRLM T2,P2	;P2/-USER COUNT,,USER ADDR SEE ULK2A
	UMOVE T2,1(P2)
	AOJA T1,ULK2D	;GO STORE IN MONITOR CORE
;ULK2C - ULK2A:  PICK UP EXTENSIONS FROM USER BLOCK
;AND CHECK TO SEE THAT THEY'RE NOT ALREADY IN MONITOR EXTBLOCK
;(DON'T REPEAT IF USER REPEATS AN EXT). INCREMENT EXTBLOCK
;CONTROL COUNT FOR EACH DISTINCT EXT SEEN.
;T1/EXTBLOCK ADDR	T2/GET USER EXT		T3/TEST EXTBLOCK EXT
;P2/USER AOBJN		P3/SIZE,,ADDR OF EXTBLOCK[0] CONTROL WORD

ULK2C:	 XCTBU <HLLZ T2,1(P2)>	;NORMAL LOOP. NEXT EXT
	MOVEI T3,1(P3)	;POINT TO MONITOR CORE
ULK2B:	CAMN T2,(T3)	;HAVE WE SEEN THIS EXT BEFORE?
	JRST ULK2A	;YES, SKIP IT
	CAIE T3,(T1)	;HAVE WE LOOKED AT ALL OF THEM?
	AOJA T3,ULK2B	;NO, CONTINUE
	ADDI T1,1	;THIS ONE IS NEW, STORE IT
ULK2D:	AOS (P3)	;COUNT ONE MORE
	HLLZM T2,(T1)	;AND STORE EXTENSION
ULK2A:	AOBJN P2,ULK2C	;ANY MORE FROM USER?


			;FINISHED ALL USER BLOCK.
	MOVN T2,(P3)	;T2/-COUNT DISTINCT EXTENSIONS
	HRLM T2,(P3)	;EXTBLOCK[0]_-COUNT,,COUNT FOR SRCFIL
	TLO M,UUOMLK	;SET FLAG
;******************************************************
	PUSHJ P,SRCFIL	;GO FIND FILE. P1-P4 PRESERVED
	 SKIPA		;NO FILE
	JRST FOUND0
;PASS SRCFIL THE FOLLOWING ARGUMENT:
;DEVEXT(F)/ FREECORE EXTBLOCK,,0
;FREECORE EXTBLOCK/ -COUNT,,COUNT
;		  / EXTENSION,,0
;		  / EXTENSION,,0
; ETC.
;( COUNT IS THE NUMBER OF UNIQUE EXTENSIONS PRESENT, NOT THE
;  SIZE OF THE FREECORE AREA ALLOCATED. THAT IS IN P3, FOR
;  CLNML.  COUNT MAY BE ALTERED BY SRCFIL AS IT FINDS NX FILES,
;  ETC.)
;********************************************************
	PUSHJ P,CLNML	;RETURN FREE CORE
	JRST STRERZ	;AND GIVE ERROR

CLNML:	;RETURN EXTBLOCK FREECORE. EXPECTS
	;P3/SIZE OF EXTBLOCK,,ADDR EXTBLOCK
	;DESTROYS T2
	PUSH P,T1
	HRRZ T2,P3	;T2/ADDR FREECORE
	HLRZ T1,P3	;T1/SIZE
	PUSHJ P,GIVWDS	;EXPECTS T1,T2
	JRST TPOPJ

FOUND0:	PUSHJ P,CLNML
	HLL T1,DEVEXT(F)
	XCTBU <HLLM T1,UUXEXT(M)>	;RETURN TO USER
	JRST FOUND

END FANCY LOOKUP !

;PROCESS ORDINARY SINGLE-EXTENSION LOOKUP. M/ UUOMLK IS OFF
; AND DEVEXT(F)/EXTENSION,,0

ULOOK3:	PUSHJ P,SRCFIL
	 JRST STRERZ
	TLZ	S,IOSRIB	;CLEAR DUMB FLAG.
			;FALL INTO FOUND
;HERE WHEN FILE NAME IS FOUND ON LOOKUP
FOUND:	HRRZ P2,DEVATB(F)	;GET ATB LOCATION
	HLRZ P4,DEVDRB(F)	;AND DRB
	MOVEI T1,FNCLOK
	PUSHJ P,CHKPRV
	 JRST LKER1		;CAN NOT REALLY DO THE LOOKUP
	MOVEI T1,FNCRED		;CAN LOOKUP, NOW CHECK READ
	TLNE F,GETB		;IF FROM GET OR RUN
	MOVEI T1,FNCEXC		;THEN EXECUTE IS ENOUGH
	PUSHJ P,CHKPRV
	SKIPA
	JRST FNDROK		;OK TO READ
	MOVSI T1,NORED
	IORM T1,DEVIAD(F)
FNDROK:	TLNN F,GETB		;IS IT A GET OR RUN??
	JRST FNDNGT		;NO
	MOVEI T1,FNCRED	;SEE IF HE CAN READ
	PUSHJ P,CHKPRV
	SKIPA			;NO, EXECUTE ONLY
	JRST FNDNGT
	MOVEI T1,PVEXOG
	LDB T2,PJOBN
	IORM T1,JBTPRV(T2)	;SET GOT EX ONLY R BIT
FNDNGT:	TLNE	M,EXTUUO	;EXTENDED M?
	JRST FOUND2	;YES
	MOVE T1,ATBSIZ(P2)
	CAILE T1,400000	;TOO BIG TO REPORT WORDS?
	JRST	[LSH T1,W2BLSH	;YES, JUST REPORT BLOCKS
		JRST FOUND1]
	TRNE T1,177	;CORRECT FOR ADJUST MENT TO BLOCK FIELD
	SUBI T1,200
	MOVNS T1
FOUND1:	 XCTTU <HRLZM T1,UUNPPN(M)>	;GIVE USER SIZE
	MOVE T1,ATBPVW(P2)	;GET PRIVS, ETC
	UMOVEM T1,UUNATT(M)	;AND GIVE TO USER
	HLRZ T1,ATBMSC(P2)	;ACCESS DATE
	XCTBU <HRRM T1,UUNEXT(M)>
	JRST FOUND3	;FINISH UP

;HERE WHEN FILE IS FOUND FOR AN EXTENDED LOOKUP
FOUND2:	HLRZ	T1,ATBMSC(P2)	;ACCESS DATE
	XCTBU <HRRM T1,UUXEXT(M)>	;AND ACCESS DATE
	CAIGE	P1,UUXPRV		;STORE VALUES?
	JRST	FOUND3		;NO. FINISH UP
	MOVE	T1,ATBPVW(P2)	;PRIVILEGES WORD
	UMOVEM T1,UUXPRV(M)	;GIVE PRIVS TO USER
	CAIGE P1,UUXSIZ
	JRST FOUND3
	MOVE T1,ATBSIZ(P2)
	TRNE T1,177
	SUBI T1,200	;CORRECT FOR BLOCK ADJUSTMENT
	UMOVEM	T1,UUXSIZ(M)		;YES. SAVE IT
	CAILE	P1,UUXSIZ	;NEED MORE VALUES?
	JRST FOUND4	;YES. GO READ RIB

;HERE TO FINISH UP A LOOKUP IF THE RIB DOESN'T HAVE TO BE READ
FOUND3:	TLZ S,IO
	JRST FOUND8
;HERE WHEN USER WANTS MORE VALUES THAN ARE STORED IN ACCESS TABLE
;READ RIB (IF IT ISN'T ALREADY IN CORE)
FOUND4:	TLZ	S,IO		;NO MORE NEED TO WRITE IN RIB.
	SKIPE	@%RIB.C+%CTUPT	;DO WE HAVE THE RIB?
	JRST	FOUND5		;YES.
	PUSHJ	P,RIBRDL	;NO.
	JRST	FOUND8		;SOMETHING WRONG WITH RIB

;HERE WITH FILE RIB IN CORE
FOUND5:	SUBI P1,UUXVER-1	;NUMBER MORE TO TRANSFER
	MOVNS P1
	HRLS P1
	HRRI P1,UUXVER
	TLO M,P1		;FORCE INDEXING FOR M.
	XCT TUTAB-UUXVER(P1)	;XCT FOR SPECIAL ARGS
	UMOVEM T1,@M
	AOBJN P1,.-2
    ;HERE WHEN VALUES SET UP, OR NO NEED TO DO SO,  OR COULDN'T
    ;GET GOOD RIB TO DO SO.
FOUND8:	PUSHJ P,INVDDB	;INVALIDATE DDB AREA, SET FILE LOC TO START.
	PUSH	P,PG		;SAVE PG.
	PUSHJ	P,RELRIB	;GET RID OF RIB IF WE HAVE IT.
	POP	P,PG		;
	MOVEI T1,DECLUK
	DPB T1,DEYSTC
	MOVEM S,DEVIOS(F)
	PJRST CPOPJ1
;TABLE FOR LOADING ARGUMENTS TO RETURN TO USER

;To User from RIB (LOOKUP), FUTAB is From User (ENTER)
TUTAB:	MOVE T1,%RIB+RIBVER	;RIBVER
	MOVE T1,%RIB+RIBFUT
	MOVE T1,%RIB+RIBEST
	PUSHJ P,CLCALC		;SPECIAL FOR ALLOCATED
	MOVE T1,%RIB+RIBPOS
	MOVE T1,%RIB+RIBFT1
	MOVE T1,%RIB+RIBLCW
	MOVE T1,%RIB+RIBMTA
	MOVE T1,%RIB+RIBDEV
	MOVE T1,%RIB+RIBSTS
	MOVE T1,%RIB+RIBELB
	MOVE T1,%RIB+RIBXT1
	MOVE T1,%RIB+RIBQTF
	MOVE T1,%RIB+RIBQTO
	PUSHJ P,CLCMXA		;IF DIRECTORY, SPECIAL
	PUSHJ P,CLCUSD		;ALSO
	MOVE T1,%RIB+RIBAUT
	MOVE T1,%RIB+RIBUNM
	MOVE T1,%RIB+RIBUN1
	MOVE T1,%RIB+RIBTRU
	MOVE T1,%RIB+RIBXT2
	MOVE T1,ATBALP(P2)
	MOVE T1,%RIB+RIBSNM
	MOVE T1,%RIB+RIBPJC	;PROJECT CODE
	MOVE T1,%RIB+RIBPJ1	;-
	MOVE T1,%RIB+RIBPJ2	;-
	MOVE T1,%RIB+RIBPID	;PROCESSOR ID

CLCALC:	LDB T1,ATYBLK	;GET NUMBER OF BLOCKS IN FILE (TO EOF)
	CAMGE T1,%RIB+RIBALC
	MOVE T1,%RIB+RIBALC	;GET LARGEST REQUEST
	POPJ P,

CLCMXA:	MOVEI T1,ATPDIR
	TDNN T1,ATBSTS(P2)
	JRST MXACL1
	PUSHJ P,GETCBR
	MOVE T1,DEVFIL(F)
	HLRZ T2,SYSDRB	;WHERE TO START AND NO CREATE
	MOVNI T3,1	;SET T3 NEG SO NO NEW BLOCK
	PUSHJ P,SRCNAM
	 JRST MXACL2	;JUST USE IT FROM RIB
	SKIPN DRBRIB(T2)
	JRST MXACL2	;ALSO IF RIB NOT READ YET
	MOVE P3,T2	;FOR RIBUSD
	MOVN T1,DRBMXA(P3)
	ADD T1,%RIB+RIBQTF
	PJRST GIVCBR

MXACL2:	PUSHJ P,GIVCBR
MXACL1:	MOVEI P3,0	;FOR RIBUSD IF WANTED
	MOVE T1,%RIB+RIBMXA
	POPJ P,

CLCUSD:	SKIPE P3
	SKIPA T1,%RIB+RIBQTF
	SKIPA T1,%RIB+RIBUSD	;JUST GET ARG FROM RIB
	SUB T1,DRBALC(P3)
	POPJ P,
SUBTTL	ENTER


COMMENT ! ROUTINE UENTR - DISPATCH HERE FROM DSKDSP
CALL:	HRRZ AC,DEVSER(F)
	PUSHJ P,DEN(AC)
	RETURN HERE FAILURE
	SUCCESS
!
UENTR:	NOCHARGE
	PUSHJ	P,TSTRES
	TLNE	S,IOSUPR		;Check if supersede
	 JRST	LUKER1
	PUSHJ	P,ERNSET		;CHARGE 1 ENTER
	PUSHJ	P,SIMENT##		;DEAL WITH SIMIO DATA BASE
	TLNE	F,LOOKB			;LOOKUP IN FORCE?
	 JRST	UPDATE			;YES. UPDATE
	PUSHJ	P,CHKARG		;NO. SET M FOR ENTER
	  JRST	ILNMER			;BAD NAME - ERROR
	TLO	M,UUOENT		;INDICATE ENTER
	PUSHJ	P,SETFIL		;SET UP FILE NAME
	  JRST	ILNMER
	MOVEI	T1,DECSTP
	DPB	T1,DEYSTC
	PUSHJ	P,SRCFIL		;SEARCH FOR MATCH, SET A.T.
	  JRST	STRERZ			;ERROR
	HRRZ	P2,DEVATB(F)		;LOC OF A.T.
	HLRZ	P4,DEVDRB(F)
	MOVE	T2,ATBSTS(P2)
	MOVEI	T1,FNCCRE
	TRNN	T2,ATPCRE
	 MOVEI	T1,FNCSUP		;CHECK SUP OR CRE
	TRNN	T2,ATPNDL		;IF NO DELETE SET, FORGET IT
	 PUSHJ	P,CHKPRV
	  JRST	ENTER1			;CAN NOT DO IT
	SKIPL	DRBALC(P4)		;See if room in this UFD
PRINTF(<[UENTR++ ROOM ON DSK?  DRBALC(P4) + SKIPG STRTAL(DRBSTR(P4))]>)
	SKIPG	STRDDB+STRTAL		;AND IF ROOM ON DISK
	 JRST	ENTER2			;NO ROOM
	SKIPN	T1,DEV1UN(F)		;SPECIAL UNIT STUFF?
	 JRST	.+3			;NO.
	SKIPG	UNITAL(T1)		;YES, ROOM ON SPECIAL UNIT?
	 JRST	ENTER2			;NO.
	SETZM	ATBSIZ(P2)
	SETZM	ATBALP(P2)		;FORCE TO ZERO
	HRRZ	T3,DEVATB(F)		;T3/ ATB ADDR OR 0 IF NO ATB.
	MOVEI	T1,FBIT##		;(Used to call GETAPG before P035/B02)
	PUSHJ	P,GETUPG##		;Get a page from unit with most space
	  JRST	ENTER2			;Couldn't get page to build the RIB
	MOVEM	T2,ATBRIB(P2)
	MOVE	T1,T2
	MOVEI	PG,%RIB.C
	PUSHJ	P,MAPWLN
	SETZM	%RIB
	MOVE	T1,[%RIB,,%RIB+1]
	BLT	T1,%RIB+777		;ZERO ENTIRE RIB
	MOVEI	T1,RIPSPP
	LDB	T2,PJOBN
	MOVE	T2,JBTPPN(T2)
	CAMN	T2,DEVPPN(F)		;IS IT THE SAME PPN AS CREATOR
	 IORM	T1,%RIB+RIBSTS		;YES, SET BIT
	HRRZS	ATBMSC(P2)
	MOVEI	T1,ATPDIR
	TLNE	M,UUOUFD
	 IORM	T1,ATBSTS(P2)
	PUSHJ	P,SAVLIC
	HRRZM	T1,ATBLIC(P2)		;PRESERVE WHAT WE CAN
;-MOVE PJC IN UPT TO RIB EXCEPT ON UFD'S
	MOVE	T1,[%UPT+UPTPJC,,%RIB+RIBPJC]	;-
	TLNN	M,UUOUFD			;-
	 BLT	T1,%RIB+RIBPJ2			;-
	SETZM	ATBPID(P2)		;CLEAR PID NOW, GETS SETUP AGAIN AT
					; SETVAL IF USER IS ALLOWED
	SETZM	%RIB+RIBPID		;ATPPID CLEARED ABOVE, STORED INTO RIBLCW AT SETEN5.
	PUSHJ	P,GETEXT
	LSH	T1,-^D14
	DPB	T1,ATYXCD		;SET EXTENDED DATE FIELD
	MOVEI	P3,UUNATT(M)		;SET P2 TO POINT TO PRV WORD
	TLNE	M,EXTUUO
	 MOVEI	P3,UUXPRV(M)
	TLNE	M,EXTUUO		;IS IT EXTENDED UUO
	CAIL	P1,UUXPRV		;AND SPECIFIED
	 XCTFU	<SKIPA T2,(P3)>		;NOT EXTENDED OR SPECIFIED
	MOVEI	T2,0			;NOT SPECIFIED, USE 0
	TDNE	T2,[37,,-1]		;TIME, DATE GIVEN?
	 JRST	SETEN1			;YES
	LDB	T1,ATYXCD		;GET EXTENDED DATE
	JUMPN	T1,SETEN1		;SINCE IT ALSO COUNTS
	HLL	P3,T2			;SAVE LEFT HALF OF T2
	PUSHJ	P,GETGMT##		;GET T1/TIME T2/DATE
	MOVE	T3,T2
	IDIV	T1,JFYSEC
	IDIVI 	T1,^D60			;GET SECONDS PART TOO
	DPB 	T2,ATYCSC		;SAVE SECONDS PART
	HRRZ	T2,T3
	ROT 	T2,-^D12
	DPB 	T2,ATYXCD		;SAVE HIGH PART OF DATE
	ROT 	T2,^D12			;AND GET DATE BACK
	HLL 	T2,P3			;GET LEFT HALF BACK
	DPB	T1,[POINT 11,T2,23]	;STORE TIME IN T2

SETEN1:	MOVEI	T3,ATPSUP
	TDNN	T3,ATBSTS(P2)		;IS IT SUPERSEDE
	 JRST	SETEN2			;NO, USE STANDARD IF NO PROT GIVEN
	MOVSI	T3,777000		;YES, USE OLD IF NO PROT GIVEN
	AND	T3,ATBPRV(P2)
	JRST	SETEN3
SETEN2:	TLNE	M,UUOUFD		;CREATE, SET UP DEFAULT PROT. DIRECTORY FILE?
	 SKIPA	T3,UFDPRT		;YES. USE UFD STANDARD PROTECTION
	MOVE	T3,STNPRT		;NO. USE REGULAR STANDARD PROTECTION
SETEN3:	TLNN	T2,777740		;PROTECTION  ALREADY GIVEN? (OR MODE IF 000 DESIRED)
	 OR	T2,T3			;NO, SET STANDARD PROTECTION
	DPB	S,[POINT 4,T2,12]	;MODE
	LDB	T1,[POINT 12,T2,35]	;GET DATE
	LDB	T3,ATYXCD
	DPB	T3,[POINT 2,T1,23]	;GET ALL OF DATE
	CAMG	T1,THSDAT		;IN THE FUTURE?
	 JRST	SETN3A			;NO
	MOVE	T1,THSDAT
	DPB	T1,[POINT 12,T2,35]
	LSH	T1,-^D12
	DPB	T1,ATYXCD		;IN FUTURE, SET TODAY
SETN3A:	TLNE	M,EXTUUO		;IF NOT EXTENDED
	 CAIL	P1,UUXPRV		;SAVE IN USERS AREA
	  UMOVEM T2,(P3)			; IF HE ASKED FOR IT
	MOVEM	T2,ATBPVW(P2)		;SAVE IN AKB
	TLNN	M,EXTUUO		;EXTENDED M?
	 JRST	SETEN4
	XCTBU	<HRRZ T4,UUXEXT(M)>
	ANDI	T4,37777		;GET ONLY ACCESS DATE
	SKIPE	T4			;IF NONE GIVEN
	CAMLE	T4,THSDAT		;OR IF GREATER THAN TODAY
SETEN4:	 MOVE	T4,THSDAT		;USE TODAY'S DATE
	DPB	T4,ATYADT		;STORE THE ACCESS DATE
	MOVE	T2,ATBSTS(P2)
	TRNN	T2,ATPCRE		;IS THIS A CREATE??
	 TRO	T4,400000		;NO, SET OLD FILE FLAG
	LDB	T2,ATYXCD
	DPB	T2,[POINT 2,T4,21]	;SAVE EXTENDED DATE INFO
	TLNN	M,EXTUUO
	 JRST	SETN5A			;NOT EXTENDED
	XCTBU	<HRRM T4,UUXEXT(M)>	;GIVE ARG TO USER
	PUSHJ	P,SETVAL
	  SKIPA
SETN5A:	 XCTBU	<HRRM T4,UUNEXT(M)>
;HERE WHEN THE RIB BLOCK IS SET UP. INSERT CONSTANT VALUES, WRITE IT
SETEN5:	MOVE	T2,ATBRIB(P2)		;GET RIB POINTER
	MOVEM	T2,%RIB+RIBSLF		;SAVE ADR AS LAST WORD OF RIB
	LDB	T3,PJOBN		;JOB NUMBER
	MOVE	T3,JBTAUN(T3)		;AUTHORS PRJ,PRG NUMBER
	SKIPN	%RIB+RIBAUT		;IF NO PRJ,PRG GIVEN
	 MOVEM	T3,%RIB+RIBAUT		;STORE USERS PRJ,PRG
	MOVEI	T3,CODRIB		;CODE WORD SHOWING THIS BLOCK IS A RIB
	MOVEM	T3,%RIB+RIBCOD		;SAVE IN RIB BLOCK
	MOVEI	T1,1
	MOVEM	T1,%RIB+RIBSZS		;SET SPARE RIB SIZE
	MOVE	T4,ATBPVW(P2)		;PRIVS, DATE
	MOVEM	T4,%RIB+RIBPVW		;SAVE IN RIB
	MOVE	T4,ATBLCW(P2)
	MOVEM	T4,%RIB+RIBLCW
	MOVE	T4,%RIB+RIBSTS
	TLO	T4,RIPLOG
	TLNE	M,UUOUFD		;DIRECTORY FILE?
	 TROA	T4,RIPDIR		;YES. SET A BIT IN RIBSTS
	 TRZ	T4,RIPDIR		;  ELSE CLEAR IT
	MOVEM	T4,%RIB+RIBSTS	
	DMOVE	T1,DEVFIL(F)		;GET NAME AND EXTENSION
	HLR	T2,ATBMSC(P2)		;ACCESS DATE AND EXTENDED DATE
	DMOVEM	T1,%RIB+RIBNAM		;TO RIB
	MOVE	T1,DEVPPN(F)
	MOVEM	T1,%RIB+RIBPPN
	TLNN	M,UUOUFD		;IS THIS A DIRECTORY
	 JRST	SETENA			;NO
	HRRZ	T1,STRDDB+STRHSH	;MUST PUT A FEW NX PTRS THERE
	MOVEI	T2,1			;THIS WILL DO
	MOVEM	T2,%RIB+RIBPFS-1(T1)
	SOJG	T1,.-1
	HRRZ	T1,STRDDB+STRHSH
	IMULI	T1,1000
	MOVEM	T1,ATBSIZ(P2)
SETENA:	PUSHJ	P,ZERDDB		;ALL 0 BUT NOT READ RIB BEFORE CREATE PNTRS
	  AOS	(P)
	MOVEI	T1,DECENT
	DPB	T1,DEYSTC
	MOVEM	S,DEVIOS(F)
	JRST	RELLOK			;NO RELEASE RIB

;GET PART OF OLD LICENSE THAT CAN STILL BEE SET ON FILE

SAVLIC:	LDB	T4,PJOBN		;GET SET TO PRESERVE LICENSE ON SUP
	HLLZ	T2,JBTLIC(T4)
	MOVE	T3,JBTPPN(T4)
	XOR	T3,DEVPPN(F)
	HRRZ	T1,ATBLIC(P2) 		;WILL BE 0 FOR CRE, OLD FOR SUP OR UPD
	PJRST	FILLIC
;SIMULTANEOUS UPDATE CHANIO COMES HERE.

USIMUP:	NOCHARGE			;DON'T CHARGE MICROCYCLES
	PUSHJ	P,TSTRES		;SETUP STACK FOR RETURN CHECK
	TLNN	F,LOOKB			;GUY HAD TO DO LOOKUP
	  JRST	LUKER1			;HE DIDN'T, ILLEGAL SEQUENCE OF UUOS
	PUSHJ	P,ERNSET		;CHARGE ONE ENTER
	PUSHJ	P,CHKAG1		;CHECK ARGS, SETUP M
	  JRST	ILNMER			;ILLEGAL NAME ERROR
	TLO	M,UUOSIM		;SET THE FLAG FOR UPDATE
	JRST	UPDAT1			;AND JOIN COMMON CODE.

;HERE WHEN THE ENTER IS AN UPDATE (LOOKUP ALREADY DONE)
; OR FROM THE SIMULTANEOUS UPDATE CHANIO, ABOVE, WITH UUOSIM SET.

UPDATE:	PUSHJ	P,CHKAG1		;CHECK ARGUMENTS NOW
	  JRST	ILNMER			;SAY ILLEGAL NAME
UPDAT1:	PUSHJ	P,WAIT1			;WAIT FOR I/O TO STOP
	PUSHJ	P,GETCBR
	PUSHJ	P,GETNAM
	CAME	T1,DEVFIL(F)
	  JRST	UILNMD			;%  NAME DOES NOT MATCH
	PUSHJ	P,GETEXT
	HLLZS	T1			;% ONLY WANT LEFT HALF
	HLLZ	T2,DEVEXT(F)
	CAME	T1,T2
	  JRST	UILNMD
	PUSHJ	P,GETPPN
	CAME	T1,DEVPPN(F)
	  JRST	UILNMD
	HRRZ	P2,DEVATB(F)
	HLRZ	P4,DEVDRB(F)		;% LOAD POINTERS FOR PROTECTION CHECK ETC
	MOVE	T1,ATBRIB(P2)		;SET UP
	MOVEM	T1,DEVRIB(F)		;FOR
	SETOM	DEVFLO(F)		;TRUNCATION.
;% HERE WHEN THE NAME, EXTENSION AND PRJ,PRG AGREE WITH THE LOOKED-UP FILE
	MOVSI	T1,NOWRT
	ANDCAM	T1,DEVIAD(F)		;% TURN OFF IN CASE ON FROM BEFORE
	MOVEI	T2,ATPNDL		;% DO NOT ALLOW IF UNDELETABLE
	MOVEI	T1,FNCAPP		;% CHECK TO SEE IF APPEND IS LEGAL
	TDNN	T2,ATBSTS(P2)
	 PUSHJ	P,CHKPRV		;% OK?
	  JRST	UPDER2			;% NO. ERROR
	MOVEI	T1,FNCUPD		;% NOW CHECK IF APPEND OR UPDATE
	PUSHJ	P,CHKPRV
	  SKIPA
	 JRST	WRTOK
	MOVSI	T1,NOWRT
	IORM	T1,DEVIAD(F)		;% SET NO WRITE BIT
WRTOK:	MOVEI	T1,DECSTP
	DPB	T1,DEYSTC
	MOVE	T3,ATBSTS(P2)		;% FILE STATUS
	TRNE	T3,ATPDEL		;% IF FILE IS GOING TO GO AWAY
	  JRST	UPDER3			;% GIVE BEING MODIFIED ERROR
	TLNN	M,UUOSIM		;% THIS SIMULTANEOUS UPDATE?
	  JRST	WRTOK1			;% NO, MAKE SURE NO OTHER WRITERS.
	PUSHJ	P,TSTWRS		;% BOMB IF SINGLE UPDATER OR SUPERCEDE
	  JRST	UPDER3			;% BEING MODIFIED SOMEHOW.
	MOVEI	T2,ATPMXU		;% DON'T SET ATPUPD
	JRST	WRTOK2			;% GO SET MXU
WRTOK1:	PUSHJ	P,TSTWRT		;% SINGLE UPDATE, IF OTHER WRITERS,
	  JRST	UPDER3			;% GIVE FILE BEING MODIFIED.
	MOVEI	T2,ATPUPD!ATPMXU	;% MAX WRITE COUNT IS ABOUT TO BE INCED
WRTOK2:	IORM	T2,ATBSTS(P2)
	HRRZ	T3,ATBFNB(P2)
	AOS	FNBUPD(T3)
	AOS	T3,ATBMWC(P2)		;% INCREMENT COUNT WHICH INCLUDES UPDATERS
	TRNN	T3,ATMMWC		;% MAKE SURE IT DIDN'T TO TO ZERO (OVERFLOW)
	 STOPCD (SLO)           	;;WRTOK2+5
	AOS	T2,DRBCNT(P4)		;% COUNT ONE MORE IN UFB IN CASE CLOSE IN
	TRNE	T2,DRPMXC		;% OVERFLOW?
	 STOPCD (SLO)	        	;;WRTOK2+10
	PUSHJ	P,GIVCBR		;% NOW ALL FINISHED WITH CB
	MOVSI	T1,ATMUFP-ATPALC-ATPPID	;ZERO PRIV UFD BITS
	ANDCAM	T1,ATBLCW(P2)
	PUSHJ	P,SAVLIC		;GET LIC HE CAN STILL HAVE
	HRRM	T1,ATBLIC(P2)		;AND SAVE IT
	MOVE	T1,THSDAT
	DPB	T1,ATYADT		;UPDATE ACCESS DATE
	TLNN	M,EXTUUO		;NO. EXTENDED ENTER?
	  JRST	UPDEN3			;NO
	CAIGE	P1,UUXPRV
	  JRST	UPNSDT			;NOT SETTING DATE
	UMOVE	T1,UUXPRV(M)
	UMOVE	T2,UUXEXT(M)		;GET EXTENSION WORD
	TRNN	T2,140000		;TO SEE IF EXTENDED DATE INFO
	  TDNE	T1,[37,,-1]		;SEE IF DATE, TIME GIVEN
	 SKIPA	
	  JRST	UPNSDT
	DPB	T1,ATYCDT
	LSH	T1,-^D12
	DPB	T1,ATYCTM
	MOVEI	T1,0
	DPB	T1,ATYCSC		;IF HE SETS IT LATTER OK
	LSH	T2,-^D14
	DPB	T2,ATYXCD		;SAVE EXTENDED DATE INFO
UPDTDN:	MOVE	T1,ATBPVW(P2)
	CAIL	P1,UUXPRV
	 UMOVEM	T1,UUXPRV(M)		;TELL THE USER
	HLRZ	T1,ATBMSC(P2)
	XCTBU	<HRRM T1,UUXEXT(M)>
	CAIGE	P1,UUXSIZ
	  JRST	UPDTD2			;CAN NOT POSSIBLE WANT SIZE BACK
	MOVE	T1,ATBSIZ(P2)
	TRNE	T1,177
	  SUBI	T1,200			;ADJUST TO WORDS
	UMOVEM	T1,UUXSIZ(M)		;AND GIVE IT TO USER
UPDTD2:	CAIGE	P1,UUXALC		;SPECIFYING ALLOCATION?
	  JRST	UPDEND			;NO. TAKE GOOD RETURN.
	PUSHJ	P,ALCCHK		;MAYBE.
	  JRST	UPDEND			;NO.
	JRST	DELGRP			;YES.

;HERE ON 4-WORD UPDATE   SET UP SIZE IN E+3
UPDEN3:	MOVE	T1,ATBSIZ(P2)		;GET NUMBER OF WORDS IN FILE
	TRNE	T1,177
	  SUBI	T1,200
	CAIG	T1,400000
	  JRST	[MOVNS T1
		 JRST  UPDEN4]
	LSH	T1,W2BLSH
UPDEN4: XCTBU <HRLZM T1,UUNPPN(M)>	;IN LH (E+3)
UPNSDT:	PUSHJ	P,GETGMT		;GET T1/TIME T2/DATE
	DPB 	T2,ATYCDT		;UPDATE 'CREATION' TIME
	LSH 	T2,-^D12
	DPB 	T2,ATYXCD
	IDIV 	T1,JFYSEC
	IDIVI 	T1,^D60
	DPB 	T1,ATYCTM
	DPB 	T2,ATYCSC
	TLNE	M,EXTUUO
	  JRST	UPDTDN
	MOVE	T1,ATBPVW(P2)
	UMOVEM	T1,UUNATT(M)
	HLRZ	T1,ATBMSC(P2)
	XCTBU	<HRRM T1,UUNEXT(M)>
	JRST	UPDEND			;MUST GO CLEAR LICENSE.

;SMALL SUBR TO SEE IF A FILE SHOULD BE TRUNCATED.
;EXPECTS P2/ ATB ADDRESS.
;DESTROYS T2 AND T3.
;NON-SKIP RETURNS IF CHANGE OF ALLOCATION IS NOT REQUESTED OR
;IF REQUEST IS >= ACTUAL SIZE.  ELSE SKIP RETURNS WITH
;T2/ UUXALC IN UNITS OF WORDS.

ALCCHK:	UMOVE	T3,UUXNUM(M)		;IS TRUNCATION
	XCTFU	<SKIPN T2,UUXALC(M)>	;BEING
	TRNE	T3,UUPWDS		;REQUESTED?
	  JRST	.+2			;YES.
	 POPJ	P,			;NO.
	JUMPL	T2,CPOPJ		;
	TRNN	T3,UUPWDS		;IS UUXALC IN WORDS?
	  JRST	[CAMLE T2,[XWD 1777,-1] ;NO, SO WE MUST
		  POPJ P,		;CONVERT IT FROM BLOCKS.
		 LSH   T2,B2WLSH	;(WON'T OVERFLOW, SINCE WE
		 JRST  .+1]		;JUST CHECKED FOR THAT.).
	MOVE	T3,ATBSIZ(P2)		;GET THE ACTUAL FILE
	TRNE	T3,177			;SIZE IN
	  SUBI	T3,200			;WORDS.
	CAMGE	T2,T3			;ACTUALLY WANT TO TRUNCATE?
	  AOS	(P)			;YES.
	POPJ	P,			;NO.
DELGRP:	MOVEI	T1,FNCTRN		;CAN WE TRUNCATE?
	PUSHJ	P,CHKPRV
	  JRST	UPDEND			;NO
	UMOVE	T2,UUXALC(M)		;GET
	UMOVE	T1,UUXNUM(M)		;T2
	TRNN	T1,UUPWDS		;IN
	  LSH	T2,B2WLSH		;WORDS.
	TLO	M,UUOENT		;DELETE THINGS FROM RIB.
	PUSHJ	P,DLTTRC		;FLAG SO WE NEED RB2DDB NEEDED.
	  JRST	UPDND3			;ERROR ON TRUNCATION, BAD FILE NOW.
	JRST	UPDEN2			;NOW HAVE PRIME RIB IN CORE, FINISH UP

UPDEND:	PUSHJ	P,RIBWTL
	  JRST	UPDND3
	MOVEI	T1,FNCCAT		;CAN HE CHANGE ATTRIBUTES?
	PUSHJ	P,CHKPRV
	  SETZ	P1,			;CAN'T TOUCH ATTRIBUTES, MAKE SETVAL DO NOTHING.
UPDEN2:	SETZM	ATBPID(P2)		;CLEAR PID AND BIT THAT SAYS THERE IS ONE
	SETZM	%RIB+RIBPID		;IN CASE NO VALID PID SPECIFIED.
	MOVSI	T1,ATPPID		;CLEAR BIT THAT SAYS THERE'S A PID
	ANDCAB	T1,ATBLCW(P2)		;STORE LICENSE NOW SO THAT SOMEONE DOESN'T
					; CHANGE CONTENTS OF LICENSED FILE WHILE
					; ITS BEING UPDATED AND STILL HAVE LICENSE
					; UNTIL CLOSE. (ALSO STORE ATPPID=RIPPID)
	MOVEM	T1,%RIB+RIBLCW
	TLNE	M,EXTUUO		;IF EXTENDED UUO, CALL SETVAL. (ELSE ALL DONE SETTING THINGS.)
	  PUSHJ	P,SETVAL
	TLNE	M,UUOENT
	  PUSHJ	P,INVDDB		;NEEDED IF PAGES DELETED
UPDEN5:	PUSHJ	P,RELLOK		;NOW RELEASE RIB
UPDND4:	AOS	(P)			;AND FALL INTO SETAPN
	MOVEI	T1,DECUPD
	DPB	T1,DEYSTC
	MOVEM	S,DEVIOS(F)

SETAPN:	LDB	T1,ATYBLK		;GET BLOCKS CURRENTLY IN FILE
	HRRZ	T2,ATBFNB(P2)
	MOVEM	T1,FNBAPD(T2)		;AND STORE IN CASE APPEND ONLY
	POPJ	P,

UPDND3:	TLNE	M,UUOENT
	  PUSHJ	P,INVDDB		;INVALIDATE THE DDB, SET FILE LOC TO START.
	 JRST	UPDND4			;COULD NOT GET RIB TO UPDATE
;CHECK ARGUMENT LIST AND TAKE CARE OF USER NAME INSTEAD OF PPN

CHKARG:	MOVSI	S,IOSERR		;RESET SOME EXTRA BITS
	ANDCAB	S,DEVIOS(F)
	SKIPA	T2,[<NORED!NOWRT!PIDACC>,,0] ;BITS TO CLEAR IN DEVIAD
CHKAG1:	MOVSI	T2,PIDACC
	ANDCAM	T2,DEVIAD(F)
	TLZ	M,UUOMSK
	UMOVE	P1,(M)			;GET COUNT OR NAME
	TLNN	P1,-1			;SEE IF EXTENDED
	  JRST	CHKAGX			;YES
	PUSH	P,M			;SAVE ARG POINTER (IN CASE EXTENDED)
CHKPPN:	XCTBU	<MOVES T1,UUNPPN(M)>	;MAKE SURE CAN WRITE IN THIS
	JUMPLE	T1,[LDB  T3,PJOBN
		    MOVE T1,JBTPPN(T3)	;USE JOBS IF 0 OR NEG
		    JRST CHKPP1]
	TLNN	T1,-1			;IS IT USER NAME?
	  PUSHJ	P,LOKLUD
CHKPP1:	TLNN	F,SYSDEV		;SYS?
	  JRST	CHKPP2			;NO
PRINTF(<[Including HACK at CHKPP1 that makes SYS:[1,1] work for accounting]>)
	CAME	T1,MFDPPN		;*HACK* for dumb accounting programs (no source!)
	MOVE	T1,SYSPPN		;USE SYS PPN UNLESS MFD PPN
CHKPP2:	UMOVEM	T1,UUNPPN(M)		;SAVE FOR USER
	POP	P,M
	JRST	CPOPJ1

CHKAGX:	MOVSI	T1,PIDACC		;GET READY TO SET
	TRNE	P1,UUPPID		;CALLER ASKING FOR PID ACCESS?
	  IORM	T1,DEVIAD(F)		;YES, SET BIT FOR CHKPRV
	ANDI	P1,777			;MASK TO COUNT FIELD
	CAILE	P1,UUXENT
	  MOVEI	P1,UUXENT		;MUST NOT BE TOO BIG
	JUMPE	P1,CPOPJ1		;NOT REALLY EXTENDED, JUST 0 NAME
	TLO	M,EXTUUO		;MARK EXTENDED UNLESS 0 NAME
	CAIGE	P1,3			;BUT MUST BE AT LEAST 3
	  POPJ	P,			;OR ERROR
	HRRZ	T1,M
	ADD	T1,P1
	XCTBU	<MOVES (M)>		;MAKE SURE CAN WRITE IN FIRST AND LAST
	XCTFU	<MOVES (T1)>		;WORDS (ASSUMES LOOKUP BLOCK LESS THAN 1 PAGE LONG)
	PUSH	P,M			;SAVE ARG
	SUBI	M,UUNPPN-UUXPPN		;CORRECT M FOR EXTENDED PPN
	JRST	CHKPPN			;AND GO TAKE CARE OF IT

;ROUTINES TO GET THE VARIOUS ARGS

GETNAM:	TLNN	M,EXTUUO
	  XCTFU	<SKIPA T1,UUNNAM(M)>
	UMOVE	T1,UUXNAM(M)
	POPJ	P,			;NAME

GETEXT:	TLNN	M,EXTUUO
	  XCTFU	<SKIPA T1,UUNEXT(M)>
	UMOVE	T1,UUXEXT(M)
	POPJ	P,

GETPPN:	TLNN	M,EXTUUO
	  XCTFU	<SKIPA T1,UUNPPN(M)>
	UMOVE	T1,UUXPPN(M)
	POPJ	P,

;SET UF DEVFIL, DEVEXT, DEVPPN, LEAVE PPN IN T1

SETFIL:	PUSHJ	P,GETNAM
	JUMPE	T1,CPOPJ		;GERROR IF NAME 0
	MOVEM	T1,DEVFIL(F)
	PUSHJ	P,GETEXT
	HLLM	T1,DEVEXT(F)
	PUSHJ	P,GETPPN
	MOVEM	T1,DEVPPN(F)
	JRST	CPOPJ1
SUBTTL	PPNUSR - Translate PPN to USERNAME using only in-core tables
;Call:	MOVE	T1,[PPN]
;	PUSHJ	P,PPNUSR
;	  error return	;Need to read DUL.SYS
;	success return	;USERNAME in T2 and T3

PPNUSR::CAMN	T1,SYSPPN##	;Is it [1,4]
	 JRST	[MOVSI T2,'SYS'	;Yes
		 SETZ  T3,
		 JRST  CPOPJ1]	;[1,4]=(SYS)
	MOVE	T3,HIGHJB	;Search the JBT tables
PPNUS1:	CAME	T1,JBTAUN(T3)	;Check if Accounting User Number matches
	 JRST	PPNUS2
	MOVE	T2,JBTUNM(T3)	;Get USERNAME for this AUN
	JUMPE	T2,PPNUS2
	MOVE	T3,JBTUN1(T3)
	JRST	CPOPJ1		;Success
PPNUS2:	SOJG	T3,PPNUS1

;No one logged in by that PPN, check if anyone is GFD'd to that directory

	MOVE	T3,HIGHJB	;Search the JBT tables
PPNUS3:	CAME	T1,JBTPPN(T3)	;Check if PPN matches
	 JRST	PPNUS4
	MOVE	T2,JBTNM1(T3)	;Get USERNAME for this PPN
	JUMPE	T2,PPNUS4
	MOVE	T3,JBTNM2(T3)
	JRST	CPOPJ1		;Success
PPNUS4:	SOJG	T3,PPNUS3

	SKIPL	.CPDWD##	;Processing a stopcode?
	 POPJ	P,		;Yes, can't trust DRB's, give error return
	PUSH	P,JOB
	MOVEM	J,JOB
	PUSHJ	P,GETCBR	;Not found, need to search core blocks
	MOVEI	T3,SYSDRB-DRBLNK;Pointer to first place
	JRST	PPNUS6		;Jump into loop

;Check for USERNAME/PPN correlation in the PPBs

PPNUS5:	CAME	T1,DRBNAM(T3)	;Check if PPN matches
	 JRST	PPNUS6
	MOVE	T2,DRBUNM(T3)	;Get USERNAME
	MOVE	T3,DRBUN1(T3)
	PUSHJ	P,GIVCBR
	POP	P,JOB
	JRST	CPOPJ1		;Success
PPNUS6:	HLRZ	T3,DRBLNK(T3)
	JUMPN	T3,PPNUS5	;Follow pointer to next one
	PUSHJ	P,GIVCBR	;No more pointers, error return
	POP	P,JOB
	POPJ	P,		;Give error return
SUBTTL	USRPPN - Translate USERNAME to PPN using only in-core tables
;Call:	DMOVE	T2,[SIXBIT/USERNAME/]
;	PUSHJ	P,USRPPN
;	  error return	;Need to read LUD.SYS
;	success return	;PPN in T1

USRPPN::CAMN	T2,[SIXBIT/SYS/];Is it (SYS)
	 JUMPE	T3,[MOVE T1,SYSPPN##
		    JRST CPOPJ1];(SYS)=[1,4]
	MOVE	T1,HIGHJB	;Search the JBT tables
USRPP1:	CAMN	T2,JBTUNM(T1)	;Check if username matches
	CAME	T3,JBTUN1(T1)	; (in the AUN tables)
	 JRST	USRPP2
	MOVE	T1,JBTAUN(T1)	;Get Accounting User Number for this name
	JRST	CPOPJ1		;Success
USRPP2:	SOJG	T1,USRPP1

;No one logged in by that name, check if anyone is GFD'd to that directory

	MOVE	T1,HIGHJB	;Search the JBT tables
USRPP3:	CAMN	T2,JBTNM1(T1)	;Check if username matches
	CAME	T3,JBTNM2(T1)
	 JRST	USRPP4
	MOVE	T1,JBTPPN(T1)	;Get PPN for this username
	JRST	CPOPJ1		;Success
USRPP4:	SOJG	T1,USRPP3

	SKIPL	.CPDWD##	;Processing a stopcode?
	 POPJ	P,		;Yes, can't trust DRB's, give error return
	PUSH	P,JOB
	MOVEM	J,JOB
	PUSHJ	P,GETCBR	;Not found, need to search core blocks
	MOVEI	T1,SYSDRB-DRBLNK;Pointer to first place
	JRST	USRPP6		;Jump into loop

;Check for USERNAME/PPN correlation in the PPBs

USRPP5:	CAMN	T2,DRBUNM(T1)	;Check if username matches
	CAME	T3,DRBUN1(T1)
	 JRST	USRPP6
	MOVE	T1,DRBNAM(T1)	;Get PPN
	PUSHJ	P,GIVCBR
	POP	P,JOB
	JRST	CPOPJ1		;Success
USRPP6:	HLRZ	T1,DRBLNK(T1)
	JUMPN	T1,USRPP5	;Follow pointer to next one
	PUSHJ	P,GIVCBR	;No more pointers
	POP	P,JOB
	POPJ	P,		;Give error return
SUBTTL	LOKLUD - LOOKUP USER NAME IN LUD.SYS TO TRANSLATE USERNAME TO PPN

LOKLUD:	PUSH	P,T1		;Save pointer (return it in T2)
	PUSH	P,M
	XCTBU	<DMOVE T2,(T1)>	;GET USER NAME
	PUSHJ	P,USRPPN	;See if USERNAME and PPN is in memory
	  JRST	LOKLL5		;Its not, have to read LUD.SYS
	POP	P,M
	POP	P,T2
	POPJ	P,

;LOKLUD continued - Go read SYS:LUD.SYS
LOKLL5:	PUSH P,F
	MOVEM S,DEVIOS(F)	;MAKE SURE THIS STAYS AROUND
	MOVEI F,DSKDDB	;GET A DDB
	MOVSI T1,'DSK'
	PUSHJ P,SETDDB
	 JRST LUDER2		;CAN NOT GET DDB
	MOVE T1,JOB
	DPB T1,PJOBN
	MOVEI T1,ASSPRG
	IORM T1,DEVMOD(F)
	PUSH P,%UPT+UPTJDA(W)	;REPLACE HIS POINTER
	MOVEM F,%UPT+UPTJDA(W)
	MOVSI T2,'LUD'
	MOVEM T2,DEVFIL(F)
	MOVEI T2,'SYS'
	HRLM T2,DEVEXT(F)
	MOVSI M,UUOLUK
	MOVE T1,SYSPPN		;Read from SYS:(SYS)[1,4]
	MOVEM T1,DEVPPN(F)
	SETOM	DEVFLO(F)
	PUSHJ	P,SRCFIL	;DO A LOOKUP ON LUD.SYS
	  JRST	LUDER0
	TLZE S,IOSRIB
	PUSHJ P,RELLOK	;MAKE SURE WE DON'T HAVE RIB
	MOVE T1,[555555555555]
	MOVEM T1,X
	MOVE T1,[361275431652]
	MOVEM T1,X+1
	MOVE T1,[612754316523]
	MOVEM T1,X+2
	MOVE T3,-3(P)	;Get pointer to name block
	UMOVE T1,(T3)
	MOVEM T1,N
	UMOVE T1,1(T3)
	MOVEM T1,N+1	;GET USER NAME
	MOVEI T3,0
	REPEAT 4,<PUSHJ P,RND>
	MOVE T1,X+2
	XOR T1,X+1
	MOVE T2,X
	XOR T2,T1
	PUSH P,P1	;PRESERVE P1
	PUSH P,T2	;THE HASHED USER NAME
	TLZ S,IOSRIB!IOSRBE!IO
	MOVEI P1,100	;DO NOT LINK FOREVER
	TLZ T1,400000
	IDIVI T1,LUDHSH	;T2 gets block # within file (starting at 0).
			;NOTE: programs doing USETI need "ADDI T2,1" here.
	JRST USRUSI	;(we don't because we are going to fake a USETI.)

RND:	MOVE T1,N
	MOVE T2,N+1
	ADDM T1,X+1
	ROTC T1,-22
	MOVEM T1,N
	MOVEM T2,N+1
	MOVEI T4,5
RND1:	MOVE T1,X+1(T3)
	MUL T1,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
	ADDM T2,X+2(T3)
	AOJE T3,RND2
	MOVNI T3,1
	MOVE T1,X+1
	TRNE T1,1
	SKIPL X+2
	MOVEI T3,0
	MOVE T1,X
	EXCH T1,X+2
	MOVEM T1,X
RND2:	SOJG T4,RND1
	POPJ P,

LUDHSH==^D887
LHUN==4		;RELATIVE LOC OF HASHED USER NAME
LPPN==0		;PPN
LLINK==2	;SIZE OF ENTRY
EXTERN PE.NER

MAPID==35	;CHANIO VMAP FUNCTION NO.
EXTERN FALHOL,FALPHP,PE.NER

;Call with zero-based block number in T2 and username hash on top of stack
USRUSI:	TLO	F,LOOKB		;FOOL MAP.
	MOVEM	F,%UPT+UPTJDA(W)
	PUSH	P,T2		;SAVE DESIRED BLOCK NUMBER.
	MOVE	T1,[<CPRRED>B7+1B17+%COW.N+<CNVVPN>]
	LSH	T2,B2PLSH	;MAP IN THAT
	MOVEI	T2,1(T2)	;[P035/E01] Clear LH, add one for CHANIO
	HRRZI	T3,(W)		;PAGE OF
	HRLI	T3,MAPID	;THE
	CHANIO	T3,T1		;FILE.
	  JRST	.+2		;LOST.
	JRST	USRUS2		;WON.
	TLZ	F,LOOKB		;
	MOVEM	F,%UPT+UPTJDA(W)
	POP	P,T1		;DUMP BLOCK NUMBER
	HRRZI	T3,(T3)		;GET T3/ ERROR CODE.
	CAIE	T3,FALHOL	;
	CAIN	T3,FALPHP	;
	JRST	LUDER1		;
	 STOPCD (LUDER1,DEBUG,USRUS1,PRTT3##,<Unexpected CHANIO error in USETI>);;USRUSI+22
USRUS2:	MOVE	T1,[PE.NER+1,,%COW.N+CNVVPN] ;SET IGNORE ERROR BIT
	PERSET	T1,		; (OLD PCB CODE IGNORED ERRORS TOO)
	 STOPCD (SLO)		;;USRUS2+2
	TLZ	F,LOOKB		;
	MOVEM	F,%UPT+UPTJDA(W)
	POP	P,T1		;REQUESTED BLOCK NUMBER
	ANDI	T1,3		;BLOCK WITHIN PAGE
	LSH	T1,B2WLSH
	HRLI	T1,-200
SRUSR:	MOVE	T2,%COW+LHUN(T1) ;GET THIS USERS'S HASH
	CAMN	T2,(P)		;CHECK WITH HASHED USERNAME
	 JRST	FUNM		;FOUND IT.
	SKIPG	T2,%COW+LPPN(T1)
	 JRST	BLKLNK		;END OR A LINK.
	MOVE	T2,%COW+LLINK(T1)
	ANDI	T2,177
	HRLS	T2
	ADD	T1,T2
	JUMPL	T1,SRUSR
	MOVE	T1,[XWD 1,%COW.N+CNVVPN] ;
	VREMOV	T1,
	  STOPCD (SLO)           ;;SRUSR+14
	JRST	LUDER1		;RAN OUT OF BUFFER.

BLKLNK:	MOVE	T1,[XWD 1,%COW.N+CNVVPN] ;
	VREMOV	T1,
	  STOPCD (SLO)           ;;BLKLNK+2
	JUMPE	T2,LUDER1	;0=END OF CHAIN, NEG=NEXT BLOCK # IN RH
	SOJL	P1,LUDER1	;MAKE SURE WE ARE NOT LOOPING.
	SOJA	T2,USRUSI	;[P035/E01] Make zero-based block number

FUNM:	POP	P,T2		;HASHED USER NAME
	POP	P,P1		;PRESERVED P1
	MOVE	M,%COW+LPPN(T1)
	PUSHJ	P,UNLFIL	;
	MOVE	T1,[XWD 1,%COW.N+CNVVPN] ;
	VREMOV	T1,
	 STOPCD (SLO)           ;;FUNM+6
	PUSHJ	P,GETCBR		;% NOW NEED TO ADD TO LIST
	HLRZ	T2,SYSDRB		;%
	MOVEI	T3,SYSDRB-DRBLNK 	;% SET TO SEARCH DRB
	MOVE	T1,M			;% GET PPN
	PUSHJ	P,SRCNAM		;%
	JUMPLE	T2,[MOVEM M,-3(P)	;% NO CORE
		JRST FUNM1]
	EXCH	M,-3(P)			;% ADDRESS OF USER NAME
	XCTBU	<DMOVE T3,(M)>		;%
	DMOVEM	T3,DRBUNM(T2)		;%
FUNM1:	PUSHJ	P,GIVCBR		;%
LUDERR:	MOVEI	M,0
	TLO	F,INPB!LOOKB		;FLAG SO A.T. NOT DELETED
	PUSHJ	P,CLOSIN
	PUSHJ	P,CLRDDB
LUDER0:	POP	P,%UPT+UPTJDA(W)	;THE PUSHED UPTJDA WORD
	POP	P,F
	MOVE	S,DEVIOS(F)		;RESTORE IOS
	POP	P,M
	PJRST	TPOPJ

LUDER1:	PUSHJ	P,UNLFIL	;
	POP	P,T1		;DUMP HASHED USER NAME
	POP	P,P1		;RESTORE P1
	JRST	LUDERR

LUDER2:	POP	P,F
	POP	P,M
	PJRST	TPOPJ

X:	BLOCK	3
N:	BLOCK	2
;ROUTINE TO CHARGE FOR 1 LOOKUP-ENTER

EXTERN GTCGSZ
LKSET:	LDB	J,PJOBN
	PUSHJ	P,GTCGSZ	;GET CHARGING SIZE OF JOB.
	AOS	JBTDLK(J)
	AOS	JBTDLK		;ACCUMULATE TOTAL IN JOB 0
	ADDM	T1,JBTSLK(J)
	ADDM	T1,JBTSLK
	POPJ	P,

;SIMILAR ROUTINE TO CHARGE FOR USETI'S, AND USETO'S

ERNSET:	LDB	J,PJOBN
	PUSHJ	P,GTCGSZ
	AOS	JBTERN(J)
	AOS	JBTERN
	ADDM	T1,JBTSER(J)
	ADDM	T1,JBTSER
	POPJ	P,
SUBTTL	RENAME

RENAM:	NOCHARGE
	PUSHJ	P,WAIT1	;WAIT FOR I/O TO STOP
	PUSHJ	P,TSTRES
	TLNE	S,IOSUPR
	  JRST	LUKER1
	PUSHJ	P,ERNSET		;CHARGE 1 RENAME
	TLZ	S,IOSRIB
	PUSHJ	P,CHKAG1		;CHECK ARGUMENTS
	  JRST	ILNMER			;BAD COUNT FOR EXTENDED
	SKIPN	DEVFIL(F)		;IS THERE AN OPEN FILE?
	  JRST	RENER0			;NO. ERROR RETURN
	TLNE	F,ENTRB			;IS IT OPEN FOR OUTPUT
	  TLNE	F,OCLOSB
	 JRST	RECLSD			;NO
	PUSH	P,M
	HRRI	M,CLSIN			;CLOSE ONLY OUTPUT
	PUSHJ	P,CLOSE1		;YES, CLOSE IT
	POP	P,M
RECLSD:	TLZ	S,IOSRIB		;JUST TO MAKE SURE
	HRRZ	P2,DEVATB(F)		;LOC OF ACCES BLOCK
	JUMPN	P2,RENAM1		;DONT HAVE TO LOOKUP IF THERE
	TLO	M,UUOLUK		;INDICATE LOOKUP FOR FNDFIL
	PUSHJ	P,GETNAM		;GET FILE NAME RENAMING TO
	SKIPN	T1			;IF TRYING TO DELETE,
	  TLO	M,UUOIRE		;THEN IGNORE RIB ERROR, USE INFO FROM UFD FOR ACCESS CHECKING.
					; (SRCFIL WILL GIVE SKIP RETURN FOR RIB ERRORS TOO WHEN THIS IS ON.)
	MOVEI	T1,DECSTP
	DPB	T1,DEYSTC
	PUSHJ	P,SRCFIL		;SET UP AN ACCESS BLOCK FOR IT
	  JRST	STRERR			;ERROR - RETURN
	TLZE	S,IOSRIB		;GIVE IT BACK IN CASE RETURNED WITH IT
	PUSHJ	P,RELLOK
	TLZ	M,UUOMSK-EXTUUO		;RESET ALL BITS BUT EXTENDED UUO
	PUSHJ	P,RENAM0		;GO DO REST OF RENAME
	  PJRST	CLOSIN			;ERROR - FIX UP ACCESS TABLE
					;(UUOCON WONT DO A CLOSE SINCE THE RENAME FAILED)
	PJRST	CPOPJ1			;GOOD RETURN
RENAM0:	TLO	F,LOOKB			;SET SO CLOSE INPUT WILL HAPPEN
	TLZ	F,OCLOSB+ICLOSB
	HRRZ	P2,DEVATB(F)		;LOC OF A.T. INTO P2

RENAM1:	PUSHJ	P,GETCBR		;%
	MOVE	T1,ATBRIB(P2)		;%
	MOVEM	T1,DEVRIB(F)		;%
	MOVE	T1,ATBSTS(P2)
	TRNE	T1,ATPNDL
	  JRST	UPDER2			;% CAN NOT BE DELETED
	TLO	M,UUOREN	 	;% LIGHT UUOREN
	PUSHJ	P,GETNAM		;% GET FILE NAME
	JUMPN	T1,RENAM3		;% NON-ZERO, DO NOT DELETE
;HERE WHEN RENAMING A FILE TO 0 (DELETING)
RENAM2:	HLRZ	P4,DEVDRB(F)
	MOVEI	T1,FNCDEL
	PUSHJ	P,CHKPRV
	   JRST UPDER2			;% NO. ERROR RETURN
	PUSHJ	P,TSTWRT		;DO NOT ALLOW IF SOMEONE WRITING
	  JRST UPDER3			;% BEING UPDATED, ERROR
	MOVEI	T1,DECSTP
	DPB	T1,DEYSTC
	MOVE	T1,ATBSTS(P2)
	TRNN	T1,ATPDIR		;% DIRECTORY IS SPECIAL
	  JRST	RENM2A
	MOVE	T1,DEVFIL(F)
	PUSHJ	P,FNDDRB		;% FIND THIS DIRECTORY BLOCK
	  JRST RENM2B			;% NOT THERE
	MOVE	T1,DRBCNT(T2)
	TRNE	T1,DRMCNT		;% IS COUNT UP?
	  JRST	UPDER3			;% YES, CAN NOT DELETE
	SETZM	DRBRIB(T2)
	MOVEI	T1,DRPNX
	IORM	T1,DRBNX(T2)		;% AND FLAG NOT THERE
RENM2B:	MOVE	T1,ATBSTS(P2)
RENM2A:	TLZ	F,LOOKB			;% ZERO LOOKB SO A FOLLOWING ENTER WILL SUCCEED
	HLLM	F,%UPT+UPTJDA(W)	;% UUOCON WONT SAVE LH(F)
	TRNE	T1,ATPDEL		;% IF ALREADY MARKED FOR DELETE,
	  JRST	RENM2C			;% GO DO INPUT CLOSE, ETC.
	TRO	T1,ATPUPD		;%SET UPD SO NO ONE ELSE CAN MODIFY, JUST READ
	MOVEM	T1,ATBSTS(P2)
	HRRZ	P3,ATBFNB(P2)		;% GET FNB ADDRESS FOR DLTNAM
	PUSHJ	P,GIVCBR
	PUSHJ	P,SETACH		;SET CHANGED BIT IN CASE UFD PAGE DOESN'T MAKE IT OUT BEFORE SYSTEM CRASH
	PUSHJ	P,DLTNAM		;REMOVE NAME FROM UFD
	HLLZS	M			;NO ONE ELSE CAN MAKE NEW UFD ENTRY SINCE ATPUPD IS ON
	PUSHJ	P,SIMRLS		;EXPECTS F,S,W; CLEAN UP SIMIO DATABASE
					;MAY SET IODTER IF VREMOV FAILURE,OUTPUT
	PUSHJ	P,GETCBR		;%
	MOVSI	T1,FNPNX		;%
	IORM	T1,FNBNX(P3)		;% TELL WORLD IT DOESN'T EXIST NOW.
	SETZM	FNBRIB(P3)		;% CLEAR SO HAS TO SCAN UFD AGAIN.
	MOVEI	T1,ATPDEL!ATPUPD
					;% (DEL CAN'T GO ON SINCE UPD IS ON.)
	XORB	T1,ATBSTS(P2)		;% TURN ON DEL, TURN OFF UPD
	JRST	RENM2D
RENM2C:	PUSHJ	P,GIVCBR
	PUSHJ	P,SIMRLS		;CLEAN UP SIMIO DATABASE
	PUSHJ	P,GETCBR
RENM2D:	AOS	(P)			;% GIVE SKIP RETURN TO THE RENAME UUO
	TLNN	S,IOSRBE		;% IF RIB ERROR, BETTER CHECK FOR OTHER USER
	  PJRST	CLOSRN			;% JUMP INTO THE CLOSE CODE TO FINISH UP
					;% ASSUME IF THERE IS A RIB ERROR THAT CLOSE WILL IGNORE IT - WHICH RESULTS IN LOST PAGES.
	TRNE	T1,ATMCNT-1		;% IF LAST READER, NO NEW ONES CAN COME,
	  JRST	CLSIN3			;% WE KNOW ATPDEL SET AND OTHER USERS, SO
					;% GO DO NORMAL CLOSE, LAST USER WILL DELETE THE FILE IN INPUT CLOSE
					;% (ATBRIB HAS TO BE NON-ZERO IF OTHER USER?
	PUSHJ	P,GIVCBR 		;% SO GIVE BACK CB AND
	JRST	CLIBDR			;GET RID OF ATB IF NO MAPPERS.
					; NOTE THAT WE SKIP AROUND TRYING TO GET RIB IN CLOSE.
					; NOTE THAT ATBRIB CAN BE ZERO IN RIB ERROR CASE!
					; CODE THAT WE CALL HERE IN CLOSE HAD BETTER
					; NOT CALL ANYTHING THAT NEEDS ATBRIB.
;HERE TO RENAME A FILE TO SOMETHING (NOT DELETE)
RENAM3:	MOVE	T3,ATBSTS(P2)
	TRNN	T3,ATPDEL		;% MUST NOT BE MARKED FOR DEL
	PUSHJ	P,TSTWRT
	  JRST	UPDER3			;% BEING WRITTEN
	MOVEI	T1,DECSTP
	DPB	T1,DEYSTC
	MOVEI	T1,ATPREN
	IORM	T1,ATBSTS(P2)		;% SET RENAME
	HLRZ	P4,DEVDRB(F)
	AOS	T2,DRBCNT(P4)		;% ONE EXTR COUNT
	TRNE	T2,DRPMXC
	 STOPCD (SLO)			;;RENAM3+13
	PUSHJ	P,GETPPN
	CAME	T1,DEVPPN(F)		;% YES. CHANGING PPN?
	  JRST	RENM4B			;% YES.
	PUSHJ	P,GETNAM
	CAME	T1,DEVFIL(F)		;% RENAMING TO SAME NAME?
	  JRST	RENAM4			;% NO
	PUSHJ	P,GETEXT
	HLLZS	T1
	HLLZ	T2,DEVEXT(F)		;% OLD EXTENSION
	CAMN	T1,T2			;% SAME?
	  JRST	RENAM6			;% YES

RENAM4:	SKIPA	T1,[FNCCNM]
RENM4B:	MOVEI	T1,FNCDEL		;% CHANGING DIRECTORIES
	PUSHJ	P,CHKPRV		;%
	  JRST	RENER7			;%
;% HERE WHEN RENAME HAS BEEN CHECKED (IF CHANGING DIRECTORIES)
RENM4A:	PUSHJ	P,SETFIL		;% SET NAME INTO DEVFIL ETC
	 STOPCD (SLO)			;;RENM4A+1  ;% ALREADY KNOW NAME NON-ZERO
	PUSHJ	P,GIVCBR		;%
	PUSHJ	P,SRCFIL		;CHECK THAT NEW FILE NAME DOESN'T EXIST
	  JRST	RENER9			;NEW FILE NAME ALREADY EXISTS
	TLO	M,UUOENT		;FLAG THIS SO WE KNOW NAME CHANGE
	HLRZ	T1,DEVDRB(F)
	CAME	T1,P4
	  TLZ	M,UUOREN		;REN ON IF NO DIR CHANGE
	PUSHJ	P,RENNMR
	HRRZ	T1,DEVATB(F)		;NEW ATB
	HRRM	P2,DEVATB(F)		;PUT BACK OLD
	HLL	T1,DEVDRB(F)
	HRLM	P4,DEVDRB(F)
	MOVEM	T1,ATBDOR(P2)		;CROSS LINK THROUGH ATBDOR
	HRRM	P2,ATBDOR(T1)
	HRLM	P4,ATBDOR(T1)
	PUSHJ	P,RIBWTL
	 JRST	RENRR2			;ERROR READING RIB
	TLNE	M,UUOREN
	  JRST	RENAM7			;NOT CHANGING DIRECTORY
	HLRZ	P4,ATBDOR(P2)
	HRRZ	P2,ATBDOR(P2)
	PUSHJ	P,RENNMR
	MOVEI	T1,FNCCRE
	PUSHJ	P,CHKPRV		;CAN WE CREATE IN NEW DIRECTORY?
	  JRST	RENRR1			;NO
	HRRZ	P2,DEVATB(F)
	HLRZ	P4,DEVDRB(F)
	PUSHJ	P,RENNMR
	HLRZ	T1,ATBDOR(P2)
	MOVN	T2,ATBALP(P2)		;FILE SIZE
	ADD	T2,DRBALC(T1)
PRINTF(<[RENM4A++ STROVR check for room in dir, must check file STR+STROVR]>)
	CAMGE	T2,STRDDB+STROVR
	  JRST	RENRR0			;NO ROOM IN NEW DIRECTORY
	MOVEM	T2,DRBALC(T1)
	CAMGE	T2,DRBMXA(T1)
	  MOVEM	T2,DRBMXA(T1)
	MOVE	T1,ATBALP(P2)
	ADD	T1,DRBALC(P4)
	SKIPL	DRBALC(P4)		;DO NOT LET IT OVERFLOW
	  SKIPL	T1
	 MOVEM	T1,DRBALC(P4)
	PUSHJ	P,SAVLIC
	HRRM	T1,ATBLIC(P2)
	HRLOI	T1,ATMUFP!ATMCSC	;SAVE UNPROTECTED PART OF UFD BITS
	ANDM	T1,ATBLCW(P2)
;NOW INTERCHANGE THE ATB ETC
RENAM7:	PUSHJ	P,GETCBR		;%
	LDB	T1,ATYCNT		;% GET COUNT IN OLD ATB
	MOVSI	T2,ATMUMC		;% IF UMC IS NON-ZERO, THEN DRBCNT
	TDNE	T2,ATBUMC(P2)		;% WAS INCREMENTED ONCE FOR IT
	  ADDI	T1,1			;% SO CAUSE DRBCNT TO GET INCREMENTED AND DECREMENTED CORRECTLY
	HLRZ	T2,ATBDOR(P2)		;% NEW DRB
	MOVE	T3,T1
	ADDB	T3,DRBCNT(T2)
	TRNE	T3,DRPMXC
	 STOPCD (SLO)			;;RENAM7+11
	MOVNS	T1
	ADDB	T1,DRBCNT(P4)		;% DECREMENT OLDCOUNT
	TRNE	T1,DRPMXC
	 STOPCD (SLO)			;;RENAM7+15
	HRRZ	T4,ATBDOR(P2)
	HLL	T1,ATBLNK(P2)		;% OLD LINK
	HLL	T2,ATBLNK(T4)		;% NEW LINK
	HLLM	T1,ATBLNK(T4)
	HLLM	T2,ATBLNK(P2)		;% INTERCHANGE
	HRRZ	T1,ATBFNB(T4)		;% GET OLD FNB ADDRESS
	MOVE	T1,FNBALT(T1)		;% GET OLD ALT
	MOVEM	T1,FNBALT(P3)		;% AND PUT IT INTO NEW FNB
	DMOVE	T1,ATBSIZ(P2)
	DMOVEM	T1,ATBSIZ(T4)		;% MOVE SOME INFORMATION
	MOVE	T1,ATBALP(P2)
	MOVEM	T1,ATBALP(T4)
	MOVE	T1,ATBLCW(P2)
	MOVEM	T1,ATBLCW(T4)
	HLL	T1,ATBMSC(P2)
	HLLM	T1,ATBMSC(T4)
	MOVEI	T1,FNBATB-ATBLNK(P3)
RNM7A:	HLRZ	T2,ATBLNK(T1)
	SKIPN	T2
	 STOPCD (SLO)			;;RNM7A+2
	CAIE	T2,(P2)			;% FOUND POINTER TO CURRENT?
	  JRST	RNM7A
	HRLM	T4,ATBLNK(T1)		;% POINT TO NEW
	HRRZ	T1,ATBFNB(T4)
	HRRM	T1,ATBFNB(P2)		;% REPLACE BACK POINTER WHILE WE HAVE IT
	MOVEI	T1,FNBATB-ATBLNK(T1)
RNM7B:	HLRZ	T2,ATBLNK(T1)
	SKIPN	T2
	 STOPCD (SLO)			;;RNM7B+2
	CAIE	T2,(T4)
	  JRST	RNM7B
	HRLM	P2,ATBLNK(T1)
	HRRM	P3,ATBFNB(T4)		;% AND OTHER BACK POINTER
	HRL	T4,P4
	HLRZ	P4,ATBDOR(P2)
	HLLM	T4,ATBDOR(P2)		;% NOW NEED TO RESET ATBDOR LINKS
	HRLM	P4,ATBDOR(T4)		;% ALSO
	HRRM	P2,DEVATB(F)
	HRLM	P4,DEVATB(F)		;% NOW HAVE THE NEW ONE
	HRRZ	P3,ATBFNB(P2)
	MOVE	T1,FNBNAM(P3)
	MOVEM	T1,DEVFIL(F)
	MOVEM	T1,%RIB+RIBNAM
	MOVE	T1,FNBEXT(P3)
	HRLM	T1,DEVEXT(F)
	HRLM	T1,%RIB+RIBEXT
	MOVE	T1,DRBNAM(P4)		;% RESET ALL NAMES
	MOVEM	T1,DEVPPN(F)
	MOVEM	T1,%RIB+RIBPPN
	HRRZ	T3,ATBDOR(P2)		;% GET OLD FNB
	HRRZ	T3,ATBFNB(T3)
	MOVEI	T1,FNBDBL-DEVDBL(T3)	;% GET SET TO RELINK DDBS
	HRRZ	T3,FNBDBL(T3)
DBRLP:	HRRZ	T2,DEVATB(T3)
	CAIE	T2,(P2)			;% IF IT POINTS TO THIS ACCESS TABLE
	  JRST	DBRNXT			;% (IF NOT IGNORE IT)
	HRRZ	T2,DEVDBL(T3)		;% THEN LINK AROUND
	HRRM	T2,DEVDBL(T1)
	HRRZ	T2,FNBDBL(P3)
	HRRM	T2,DEVDBL(T3)		;% AND LINKK INTO NEW
	HRRM	T3,FNBDBL(P3)
	PUSH	P,T1			;% SAVE BACK POINTER
	DMOVE	T1,DEVFIL(F)
	MOVEM	T1,DEVFIL(T3)
	HLLM	T2,DEVEXT(T3)
	MOVE	T1,DEVPPN(F)
	MOVEM	T1,DEVPPN(T3)		;% RESET NAME
	HRLM	P4,DEVDRB(T3)
	POP	P,T3			;% USE OLD BACK POINTER TO COUNTINUE
DBRNXT:	MOVE	T1,T3			;% REMEMBER BACK POINTER
	HRRZ	T3,DEVDBL(T3)
	JUMPN	T3,DBRLP
	PUSHJ	P,GIVCBR		;% FINISHED RESETTING
	JRST	RENAM8

RENNXR:	MOVE	P2,ATBDOR(P2)
	MOVEM	P2,DEVATB(F)
	HLRZ	P4,P2			;% RESET ATB, DRB POINTERS ALSO

RENNMR:	HRRZ	P3,ATBFNB(P2)
	MOVE	T1,FNBNAM(P3)
	MOVEM	T1,DEVFIL(F)		;% PUT BACK OLD NAME BEFORE READING RIB
	HRRZ	T1,FNBEXT(P3)
	HRLM	T1,DEVEXT(F)
	MOVE	T1,DRBNAM(P4)
	MOVEM	T1,DEVPPN(F)
	POPJ	P,

RENAM6:	PUSHJ	P,GIVCBR		;%
	MOVEI	T1,FNCCPR		;CAN HE MODIFY FILE
	PUSHJ	P,CHKPRV
	  JRST	RENRR3
	PUSHJ	P,RIBWTL
	  JRST	RENRR4
;HERE WITH THE RIB IN THE MON BUF, M POINTING TO PPN WORD
RENAM8:	;;TLZ S,IOSRIB		;MAKE SURE WE DON'T CONFUCE DIR ROUTINES
	;;This was moved to RENSTS+1 so DLTTRC can't botch it up/WRS
	MOVSI	T1,ATPPID!ATPDMP	;CLEAR BIT THAT SAYS THERE
					; IS A PID AND FILE DUMPED BIT
	ANDCAM	T1,ATBLCW(P2)		;GETS STORED INTO RIB AT RENDEA
	SETZM	ATBPID(P2)		;ZERO PID IN ATB AND
	SETZM	%RIB+RIBPID		; RIB.
	TLNN	M,EXTUUO		;EXTENDED M?
	  JRST	RENM8A			;NO. POINT TO ATT WORD
	CAIGE	P1,UUXPRV		;SPECIFYING ATTRIBUTES?
	  JRST	RENDEA			;NO
	XCTFU	<SKIPA P3,UUXPRV(M)>
RENM8A:	  UMOVE	P3,UUNATT(M)		;GET ATTRIBUTES WORD
	JUMPE	P3,RENAM9		;NO CHANGE
	MOVE	T2,P3
	XOR	T2,ATBPVW(P2)		;COMPARE WITH RIB ATTR. WORD
	PUSHJ	P,GETEXT		;GET EXTENSION WORD
	HLRZ	T3,ATBMSC(P2)
	XOR	T1,T3
	TRNN	T1,140000		;SEE IF EXTENDED DATE CHANGING
	  JUMPE	T2,RENAM9		;SAME IF 0
	HRLOI	T3,37			;SET UP MASK FOR PRIVS, MODE
	ANDM	T3,ATBPVW(P2)		;TAKE PRIVS, MODE OUT OF RIB
	ANDCA	T3,P3			;GET PRIVS FROM USER
	IORM	T3,ATBPVW(P2)		;AND SET THEM IN RIB WORD
	MOVEI	T1,ATPDIR
	TDNE	T1,ATBSTS(P2)
	  TLNN	T2,777000
	 JRST	RENM9B			;ARE WE CHANGING PROT OF A UFD?
	PUSHJ	P,GETCBR		;% YES!
	MOVE	T1,DEVFIL(F)		;%
	PUSHJ	P,FNDDRB		;% SEE IF A DRB BLOCK FOR IT
	  JRST	RENM9A			;%
	LDB	T1,ATYPRV		;%
	EXCH	P4,T2			;%
	DPB	T1,DRYPRV		;%
	MOVE	P4,T2			;%
RENM9A:	PUSHJ	P,GIVCBR		;% AND RETURN CB RESOURCE
RENM9B:	PUSHJ	P,GETEXT
	TRNN	T1,140000		;IS ANYTHING BUT PROTECTION
	  TDNE	P3,[37,,-1]		;NON-ZERO
	 SKIPA				;YES
	  JRST	RENM9C			;NO, DO NOT CHANGE IT
	LSH	T1,-^D14
	DPB	T1,ATYXCD
	DPB	P3,ATYCTD
	MOVE	T1,ATBMSC(P2)
	HLRM	T1,%RIB+RIBEXT		;NOW UPDATE RIB
RENM9C:	MOVE	T1,ATBPVW(P2)
	MOVEM	T1,%RIB+RIBPVW
	TLNN	M,EXTUUO
	  JRST	[UMOVEM T1,UUNATT(M)	;GIVE IT TO USER
		 JRST   RENDEA]
	CAIL	P1,UUXPRV
	 UMOVEM	T1,UUXPRV(M)	;USER WANTS IT
RENAM9:	TLNN	M,EXTUUO	;
	  JRST	RENDEA		;
	CAIGE	P1,UUXALC	;
	  JRST	RENRIB		;NOT CHANGING ALLOC.
	PUSHJ	P,ALCCHK	;CHANGING ALLOCATION?
	  JRST	RENRIB		;NO.
	PUSHJ	P,DLTTRC	;AND REMOVE PAGES
	  JRST	.+2		;ERR ON TRUNC, BAD FILE NOW.
	 JRST	RENM9D		;SUCCESS.
	PUSHJ	P,RIBWTL	;MOST UNGRACEFUL ERROR HANDLING.
	 STOPCD (SLO)           ;;RENAM9+12
RENM9D:	HRRZ	T1,ATBFNB(P2)	;GET FNB ADDRESS
	MOVE	T2,PCDTIM	;GET CURRENT PCB TIMER
	MOVEM	T2,FNBALT(T1)	;SET IN FNB AND
	MOVEM	T2,%RIB+RIBALT	;RIB.

;FALL INTO RENRIB
RENRIB:	PUSHJ	P,SETVAL		;STORE ARGUMENTS FROM USER IN RIB

RENDEA:	MOVE	T1,ATBLCW(P2)
	MOVE	T2,%RIB+RIBSTS
	TRNN	T2,RIPHWE!RIPHRE!RIPBDA!RIPBFS!RIPBDR
	  TLZA	T1,ATPUFE
	 TLO	T1,ATPUFE		;KEEP ERROR BIT CORRECT
	MOVEM	T1,ATBLCW(P2)
	MOVEM	T1,%RIB+RIBLCW
	LDB	T1,PJOBN
	HLL	T1,JBTLIC(T1)		; KEEP JOB# IN RH FOR LATER
	TLNE	T1,LICWFL		; LET USER SET RIPSPP IF HAS WF
	 JRST	RENSTS
	MOVE	T1,JBTPPN(T1)
	CAME	T1,DEVPPN(F)		;IS IT THE SAME
	  TRZA	T2,RIPSPP		;NO RESET
	 TRO	T2,RIPSPP		;OR SET
RENSTS:	MOVEM	T2,%RIB+RIBSTS
	PUSHJ	P,RELLOK		;ALL DONE
	TLZ	S,IOSRIB		;DIR### routines die if they think its there
	TLNE	M,UUOENT		;IS THERE A NAME CHANGE?
	  JRST	RENNMC			;YES, DO IT
	PUSHJ	P,RIBDIR
	  JRST	RENR7A			;CAN NOT GET IT
	HRRZ	P3,ATBFNB(P2)
	LDB	T1,FNYUFP
	TLO	S,IO			;WANT UFD PAGE WRITEABLE.
	PUSHJ	P,DIRBLK
	  JRST	RENRR7			;CAN NOT GET IT
	PUSHJ	P,DIRSRC
	  SKIPA				;FOUND IT
	 STOPCD (,XCT,UFDER1)		;UFD error return from DIRSRC ;;RENSTS+16
	PUSHJ	P,CREUFD		;UPDATE UFD WITH NEW VALUES
RENR7A:	PUSHJ	P,RELLOK		;DONE WITH UFD BLOCK
RENRR7:	MOVEI	T1,ATPREN
	ANDCAM	T1,ATBSTS(P2)		;RESET FLAG
RENECM:	SOS	T1,DRBCNT(P4)
	TRNE	T1,DRPMXC
	 STOPCD (SLO)			;;RENECM+2
	AOS	(P)
	PUSHJ	P,WATPCB		;WAIT FOR THE RIB PCBS TO BE VAIDATED.
	MOVEI	M,CLSACC		;NO ACCESS DATE UPDATE ON FORCED CLOSE
	PJRST	CLOSE1			;FINISH UP

RENNMC:	TLNN	M,UUOREN		;NAME CHANGE, DIRECTORY ALSO?
	  JRST	RENDCR			;YES, MUST DELETE OLD AND CREATE NEW
	HRRZ	T1,ATBDOR(P2)
	HRRZ	T1,ATBFNB(T1)
	MOVE	T1,FNBNAM(T1)		;GET OLD NAME
	TLZ	T1,(1B0)
	MOVE	T2,DEVFIL(F)
	TLZ	T2,(1B0)
	SUB	T1,T2
	HRRZ	T2,STRDDB+STRHSH
	IDIVI	T1,(T2)
	JUMPN	T2,RENDCR		;DIFFERENT NAME FORCES DELETE AND CREATE
	PUSHJ	P,RENNXR		;GET READY TO FIND OLD NAME
	HRRZ	P3,ATBFNB(P2)
	PUSHJ	P,RIBDIR
	 JRST	[PUSHJ	P,RELLOK
		 JRST	RENZAP]		;CAN NOT READ UFD
	LDB	T1,FNYUFP
	PUSHJ	P,DIRBLK
	  JRST	RENZAP
	PUSHJ	P,DIRSRC		;SEARCH THIS PAGE.
	  SKIPA	
	 STOPCD (,XCT,UFDER1)		;UFD error return from DIRSRC ;;RENNMC+24
	PUSH	P,T2			;SAVE LOCATION
	LDB	T1,FNYUFP		;SAVE THIS
	PUSH	P,T1			;FOR OTHER ENTRY.
	PUSHJ	P,RENNXR		;GET NEW NAME BACK
	POP	P,T2			;GET OLD FNYUFP BACK.
	DPB	T2,FNYUFP
	POP	P,T2
	JRST	RENFL1			;AND DO IT LIKE CREATE

RENDCR:	PUSHJ	P,RENNXR		;GET SET TO DELETE OLD NAME
	PUSHJ	P,DLTNAM
	TLNN	M,UUOREN		;CHANGE OF DIR OR JUST NAME
	  PUSHJ	P,LOGTST		;DIR, REWRITE IF NEEDED
RENZAP:	PUSHJ	P,RENNXR		;NOW TRY TO CREATE NEW
	TLNN	M,UUOREN
	  PUSHJ	P,LOGTST
	SETZ	T2,			;FLAG NO RET PNTR FOR INSNAM.
	PUSHJ	P,INSNAM
	  JRST	RENFL2			;COULD NOT(ALLOC FAIL/RIB ERR/DIR FULL).
RENFL1:	PUSHJ	P,CREUFD		;STORE INFORMATION
	PUSHJ	P,RELLOK
RENFL2:	HRRZ	P3,ATBFNB(P2)
	PUSHJ	P,GETCBR		;%
	MOVSI	T1,FNPNX		;%
	ANDCAM	T1,FNBNX(P3)		;% RESET FOR NEW NAME
	MOVE	T1,ATBRIB(P2)		;%
	MOVEM	T1,FNBRIB(P3)		;%
	MOVEI	T2,ATPREN		;%
	ANDCAM	T2,ATBSTS(P2)		;%
	SOS	T1,DRBCNT(P4)		;%
	TRNE	T1,DRPMXC		;%
	 STOPCD (SLO)			;;RENFL2+12
	MOVEI	T1,0			;%
	EXCH	T1,ATBDOR(P2)		;%
	SETZM	ATBDOR(T1)		;%
	HRRZ	P2,T1			;%
	HLRZ	P4,T1			;%
	HRRZ	P3,ATBFNB(P2)		;%
	PUSHJ	P,FREATB		;% GET RID OF ATB NOW ATTACHED TO OLD FNB
	MOVSI	T1,FNPNX		;%
	IORM	T1,FNBNX(P3)		;%
	SETZM	FNBRIB(P3)		;%
	PUSHJ	P,GIVCBR		;%
	JRST	RENECM
;SUBROUTINE TO STORE USER-SUPPLIED ARGUMENTS IN THE RIB BLOCK
;CALLED BY ENTER AND RENAME
;ENTER WITH P1=NUMBER OF ARGS

;-SEP 76 AAA. ADDITIONS FOR PROJ CODES. WF USER CAN SET PJC AT WILL.
;-	WPJ USER CAN SET PJC ON RENAME OR UPDATE
SETVAL:	CAIGE	P1,UUXVER	;Check for extended ENTER block past .RBSIZ
	 POPJ	P,		;NOT ENOUGH TO WORRY ABOUT
	MOVE	T4,UNPARG	;CAN ALWAYS SET UN-PRIV'D ARGS
	PUSH	P,J
	LDB	J,PJOBN
	LDB	T2,JBYWPT	;GET LICENSE
	CAILE	T2,1		;CHECK FOR WRITE-FILES OR WRITE-ABSOLUTE
	 IOR	T4,WRTARG	;CAN SET THESE IF WRITE FILES
	MOVSI	T2,LICJAL
	TDNE	T2,JBTLIC(J)
	 IOR	T4,JALARG	;CAN SET THESE IF JACCT-LOGIN
	MOVSI	T2,LICWPJ	;CHECK WRITE PROJECT
	TDNN	T2,JBTLIC(J)	;-
	 JRST	SETVL0		;-
	MOVEI	T2,ATPCRE!ATPSUP;-FOR RENAME OR UPDATE,
	TDNN	T2,ATBSTS(P2)	;-(SKIP IF NEITHER)
	 IOR	T4,WPJARG	;-LICWPJ USER CAN SET THESE
SETVL0:	POP	P,J
	MOVEI	T2,ATPDIR
	TDNN	T2,ATBSTS(P2)
	 IOR	T4,NONUA	;AND CAN SET THESE IF NOT A UFD
	SUBI	P1,UUXVER-1	;NUMBER WE WANT TO SET
	MOVNS	P1
	HRLS	P1		;Make AOBJN pointer
	HRRI	P1,UUXVER	;Start from .RBVER
	TLOA	M,P1		;So "@M" uses P1 for indexing
SETVL1:	LSH	T4,1		;Get next bit to set
	JUMPGE	T4,SETVTU	;Zero bit means user cannot set this word
	UMOVE	T1,@M		;Get arg from user
	XCT FUTAB-UUXVER(P1)	;Store in %RIB or else PUSHJ to routine
	AOBJN	P1,SETVL1
	POPJ	P,		;DONE

SETVTU:	XCT TUTAB-UUXVER(P1)	;For those args user cannot set,
	UMOVEM	T1,@M		; return current value to him
	AOBJN	P1,SETVL1
	POPJ	P,

;From User to RIB (ENTER), TUTAB is To User (LOOKUP)
FUTAB:	MOVEM T1,%RIB+RIBVER	;06.RBVER Version number
	MOVEM T1,%RIB+RIBFUT	;07.RBFUT (.RBSPL Spooling name on ENTER)
	MOVEM T1,%RIB+RIBEST	;10.RBEST Estimated size
	PUSHJ P,CLFALC		;11.RBALC Allocated size
	MOVEM T1,%RIB+RIBPOS	;12.RBPOS Absolute disk position
	MOVEM T1,%RIB+RIBFT1	;13.RBFT1 unused (DEC .RBUFW)
	PUSHJ P,CLFLIC		;14.RBLIC Check on license he can set
	MOVEM T1,%RIB+RIBMTA	;15.RBMTA Tape ID used in last all-files BACKUP
	MOVEM T1,%RIB+RIBDEV	;16.RBDEV Device name
	PUSHJ P,CLFSTS		;17.RBSTS File/UFD status bits
	JFCL			;20.RBELB Disk address of bad page
	JFCL			;21.RBXT1 unused (DEC .RBEUN)
	PUSHJ P,CLFQTF		;22.RBQTF Quota in (check with DRBMXA+DRBALC)
	MOVEM T1,%RIB+RIBQTO	;23.RBQTO Quota out (UFDs only)
	PUSHJ P,CLFMXA		;24.RBQTR Quota reserved (max used last time)
	PUSHJ P,CLFUSD		;25.RBUSD Pages used
	MOVEM T1,%RIB+RIBAUT	;26.RBAUT Author
	PUSHJ P,CLFUNM		;27.RBUNM Username 1st half
	PUSHJ P,CLFUN1		;30.RBUN1 Username 2nd half
	MOVEM T1,%RIB+RIBTRU	;31.RBTRU UFD TRU limit
	MOVEM T1,%RIB+RIBXT2	;32.RBXT2 ???
	JFCL			;33.RBALP Allocated pages
	JFCL			;34.RBSNM Number spare RIBs
	MOVEM T1,%RIB+RIBPJC	;35.RBPJC Project code 1-5
	MOVEM T1,%RIB+RIBPJ1	;36.RBPJ1 Project code 6-10
	MOVEM T1,%RIB+RIBPJ2	;37.RBPJ2 Project code 11-12
	PUSHJ P,CLFPID		;40.RBPID Set or clear PID
	JFCL			;41.RBACT Can never set ACCT from ENTER

CLFALC:	UMOVE	T2,UUXNUM(M)	;ARG IN UNITS OF
	TRNE	T2,UUPWDS	;WORDS?
	  JRST	CLFAL2		;YES.
CLFAL1:	CAMGE	T1,%RIB+RIBEST	;NO. SO WE CAN SIMULATE EST SIZE
	  MOVE	T1,%RIB+RIBEST
	MOVEM	T1,%RIB+RIBALC
	LDB	T2,ATYBLK
	CAMLE	T2,T1
	  MOVE	T1,T2
	UMOVEM	T1,UUXALC(M)	;GIVE USER A FAKE NUMBER
	POPJ	P,		;SO LOOKS LIKE ALLOC SUCCEDED
CLFAL2:	MOVE	T2,T1		;CONVERT THE ARG
	LSH	T1,W2BLSH	;TO
	TRNE	T2,177		;BLOCKS, WATCHING OUT FOR
	  AOJA	T1,CLFAL1	;OVERFLOW.
	JRST	CLFAL1		;

	DEFINE TXXGEN (AC,NUM,TYP)
<IFE NUM&777777,<TL'TYP AC,(NUM)>
 IFN NUM&777777,<
	IFE NUM&777777000000,<TR'TYP AC,NUM>
	IFN NUM&777777000000,<TD'TYP AC,[NUM]>>>

CLFSTS:	TXXGEN (T4,<1B0_<^L<ARGSTS>-^L<ARGPVS>>>,NN)
	  JRST	CLFNPS		;NO.
	MOVEI	T2,RIPDIR	;DO NOT LET DIR GET SET
	ANDM	T2,%RIB+RIBSTS	;JUST THAT BIT
	TRZ	T1,RIPDIR
	IORM	T1,%RIB+RIBSTS	;PRIV CALL, SET STATUS
	POPJ	P,

CLFNPS:	ORCMI	T1,RIPBDA!RIPBFS!RIPHWE!RIPHRE ;SET TO 1
				;ALL BITS BUT ONES WANTED CLEARED.
	ANDB	T1,%RIB+RIBSTS	;(DON'T LET CLR RIPBDR.).
	UMOVEM	T1,UUXSTS(M)	;TELL USER
	POPJ	P,

CLFQTF:	MOVEI	T2,ATPDIR
	TDNN	T2,ATBSTS(P2)
	  JRST	CLFQT1		;NOT A DIRECTORY
	PUSHJ	P,GETCBR	;% TRY TO FIND DRB
	PUSH	P,T1		;%
	MOVE	T1,DEVFIL(F)	;%
	PUSHJ	P,FNDDRB	;%
	  JRST	CLFQT2		;% NOT THERE
	SKIPN	DRBRIB(T2)	;%
	  JRST	CLFQT2		;% NOT REALLY READ YET
	MOVE	P3,T2		;% SAVE FOR LATER ARGUMENTS
	POP	P,T1		;%
	PUSHJ	P,GIVCBR	;%
	MOVE	T2,T1
	SUB	T2,%RIB+RIBQTF
	ADDM	T2,DRBMXA(P3)
	ADDM	T2,DRBALC(P3)
	JRST	CLFQT3		;AND GO

CLFQT2:	PUSHJ	P,GIVCBR	;%
	POP	P,T1
	TDZA	P3,P3		;SET 0 AS FLAG FOR LATER ARGS
CLFQT1:	  MOVNI	P3,1		;NEGATIVE AS FLAG THAT NOT DIR
CLFQT3:	MOVEM	T1,%RIB+RIBQTF
	POPJ	P,

CLFUNM:	JUMPLE	P3,CLFUM1
	MOVEM	T1,DRBUNM(P3)	;STORE IT IN DRB IF CHANGING
	SETZM	DRBUN1(P3)	;JUST IN CASE
	SETZM	%RIB+RIBUN1
CLFUM1:	MOVEM	T1,%RIB+RIBUNM
	POPJ	P,

CLFUN1:	SKIPLE	P3
	  MOVEM	T1,DRBUN1(P3)
	MOVEM	T1,%RIB+RIBUN1
	POPJ	P,

EXTERNAL JBTNAM

CLFUSD:	JUMPL	P3,CLFUS1	;NOT A UFD
	JUMPL	T1,CLFUS2	;DOES NOT WANT CHANGED
	JUMPE	P3,CLFUS3	;NO DRB, JUST CHANGE RIB
	MOVE	T2,%RIB+RIBQTF
	SUB	T2,T1		;HAVE A DRB, CHANGE FOR NEW USD
	MOVEM	T2,DRBALC(P3)
	CAMGE	T2,DRBMXA(P3)
	  MOVEM	T2,DRBMXA(P3)	;AND THIS IF CHANGED
CLFUS1:	MOVEM	T1,%RIB+RIBUSD
	POPJ	P,

CLFUS3:	CAMLE	T1,%RIB+RIBMXA	;MAY HAVE TO CHANGE THIS TOO
	  MOVEM	T1,%RIB+RIBMXA
	JRST	CLFUS1

CLFUS2:	SKIPE	P3
	  SKIPA	T1,%RIB+RIBQTF	;IF WE HAVE DRB, RETURN QTF-ALC
	 SKIPA	T1,%RIB+RIBUSD	;ELSE USD FROM RIB
	SUB	T1,DRBALC(P3)
	UMOVEM	T1,UUXUSD(M)
	POPJ	P,

CLFMXA:	JUMPL	P3,CLFMX1	;NOT A UFD, JUST ANOTHER ARG
	JUMPL	T1,CLFMX2	;DO NOT WANT IT CHANGED
	JUMPE	P3,CLFMX3	;CHANGE TO CURRENT USD AND REPORT OLD
	MOVE	T2,DRBALC(P3)	;IF HAVE DRB, GET CURRENT
	EXCH	T2,DRBMXA(P3)	;AND STORE FOR MAX. GET OLD
	SUB	T2,%RIB+RIBQTF	;NOW OLD MAX-QUOTA
	MOVNM	T2,%RIB+RIBMXA	;TEMP STORE OLD MAX
	SKIPA	T1,%RIB+RIBQTF	;GET QUOTA
CLFMX3:	  SKIPA	T1,%RIB+RIBUSD	;IF NO DRB, GET CURRENT USED
	SUB	T1,DRBALC(P3)	;IF DRB QUOTA-CURRENT QUOTA LEFT
	EXCH	T1,%RIB+RIBMXA	;SET RIBMXA TO CURRENT USED, GET OLD
	UMOVEM	T1,UUXMXA(M)
	POPJ	P,

CLFMX1:	MOVEM	T1,%RIB+RIBMXA
	POPJ	P,

CLFMX2:	SKIPE	P3		;IS THERE A DRB
	  SKIPA	T1,%RIB+RIBQTF	;YES
	 SKIPA	T1,%RIB+RIBMXA	;NO
	SUB	T1,DRBMXA(P3)	;NOW HAVE CURRENT MAX
	UMOVEM	T1,UUXMXA(M)
	POPJ	P,

CLFPID:	JUMPGE	P3,CPOPJ	;FORGET IT FOR UFDS
	JUMPE	T1,CLFPIZ	;ZEROING PID IS ALWAYS OK
	MOVS	T2,T1		;GET SWAPPED COPY OF NEW PID IN T2 (UUN IN RH INSTEAD OF LEFT HALF)
	XOR	T2,JBTAUN(J)	;SEE IF PID UUN MATCHES JOB'S AUN UUN
	TRNN	T2,-1
	  JRST	CLFPIO		;OK TO GIVE OUT THIS PID
	LDB	T2,JBYWPT
	CAILE	T2,1		;IF HAS WF OR WA,
	  JRST	CLFPIO		;OK TO GIVE PID OUT
	CAME	T1,%UPT+UPTPID	;PROGRAM TRYING TO GIVE OUT ITS OWN PID?
	  POPJ	P,		;NO, WAS HIS LAST CHANCE, NO PID.
CLFPIO:	MOVSI	T2,ATPPID
	IORM	T2,ATBLCW(P2)	;SET TO GOES INTO UFD ENTRY AND RIBLCW
CLFPIS:	MOVEM	T1,%RIB+RIBPID	;OK, STORE IN RIB AND IN
	MOVEM	T1,ATBPID(P2)	;ATB
	POPJ	P,
CLFPIZ:	MOVSI	T2,ATPPID
	ANDCAM	T2,ATBLCW(P2)
	JRST	CLFPIS
	DEFINE XA (A)
<	A==%%Z
	%%Z==%%Z_-1>
	%%Z==400000,,0

;DEFINE 'ALLOWED TO CHANGE' BIT NAMES

XA ARGVER
XA ARGFUT
XA ARGEST
XA ARGALC
XA ARGPOS
XA ARGFT1
XA ARGLIC
XA ARGMTA
XA ARGDEV
XA ARGSTS
XA ARGELB
XA ARGEUN
XA ARGQTF
XA ARGQTO
XA ARGMXA
XA ARGUSD
XA ARGAUT
XA ARGUNM
XA ARGUN1
XA ARGTRU
XA ARGUFD
XA ARGALP
XA ARGSNM
XA (ARGPJ0)	;-
XA (ARGPJ1)	;-
XA (ARGPJ2)	;-
XA ARGPID
XA ARGALT
XA (ARGPVS)	;FAKE TO REMEMBER STATUS PRIV

;NOW THE WORDS DEFINING BITS ALLOWED TO CHANGE

UNPARG:	ARGVER+ARGFUT+ARGEST+ARGALC+ARGPOS+ARGFT1+ARGLIC+ARGUFD+ARGSTS+ARGPID
WRTARG:	ARGMTA+ARGAUT+ARGPVS+ARGPJ0+ARGPJ1+ARGPJ2	;-
JALARG:	ARGQTF+ARGQTO+ARGMXA+ARGUSD+ARGUNM+ARGUN1+ARGTRU+ARGPVS
NONUA:	ARGUNM+ARGUN1+ARGTRU+ARGQTF+ARGQTO+ARGMXA+ARGUSD
WPJARG:	ARGPJ0+ARGPJ1+ARGPJ2	;-NEW FOR PJC

CLFLIC:	MOVE	T2,ATBLCW(P2)		;GET CURRENT VALUE
	PUSH	P,T4
	TLNE	T1,77			;SPECIFYING SECONDS?
	  TLOA	T2,77			;YES, VOID OLD FOR MERGE
	 TLO	T1,77			;NO, VOID NEW FOR MERGE
	LDB	T4,PJOBN
	MOVSI	T3,LICJAL+LICWFL
	TDNE	T3,JBTLIC(T4)
	  TLOA	T2,ATMUFP!ATMUFU	;LET HIM SET SPECIAL BITS
	 TLO	T2,ATMUFU		;JUST THE USUAL ONES
	HLLO	T3,T2
	AND	T1,T3			;ADJUST LEFT HALF
	HLL	T2,JBTLIC(T4)
	TLNE	T2,LICWFL		;FIND OUT IF HE HAS WA
	TLNN	T2,LICWPJ		;
	  TLZA	T1,ATPPID!ATPALC	;NO. IGNORE HIS ATPPID AND ATPALC ARGS.
	 JRST	CLFLC1			;YES.
	MOVE	T3,ATBLCW(P2)		;DOESN'T HAVE WA. DON'T LET HIM CLEAR
	TLZ	T3,-<ATPPID!ATPALC>-1	;ATPPID OR ALC
	IOR	T1,T3
CLFLC1:	MOVE	T3,JBTPPN(T4)
	XOR	T3,DEVPPN(F)
	PUSHJ	P,FILLIC
	UMOVEM	T1,UUXLCW(M)
	MOVEM	T1,ATBLCW(P2)
	POP	P,T4
	POPJ	P,


FILLIC::TLZ	T2,LICRMT!LICHR		;DON'T LOOK AT THESE (HF + HR)
	PUSH	P,T3
	PUSHJ	P,MAXLIC
	POP	P,T3
	TLNN	T3,-1			;SAME PROJ??
	  JRST	LICSPJ			;YES
	TRNN	T1,LICWFL		;CAN NOT SET WRIT PROJ UNLESS
	TRNE	T2,LICWFL		;SOMEONE HAS WRITE FILE
	  SKIPA	
	TRZ	T1,LICWPJ
	TRNN	T1,LICRFL
	TRNE	T2,LICRFL
	  SKIPA	
	TRZ	T1,LICRPJ
	TRNN	T2,LICRMT!LICWFL	;SOME ONE MUST HAVE WF OR HF
	  TRZ	T1,LICRMT		; TO SET HF ON A FILE
	TRNN	T2,LICRMT!LICHR!LICWFL!LICRFL	;NEED WF,RF OR HF,HR
	  TRZ	T1,LICHR		; TO SET HR ON A FILE
	JRST	LICSPG

LICSPJ:	TDNN	T3,[XWD INDPPN,-1]
	  JRST	LICSPG
	TRNN	T2,LICRMT!LICWFL!LICWPJ	;NEED HF,WF OR WP
	  TRZ	T1,LICRMT		; TO SET HF ON A FILE
	TRNN	T2,LICRMT!LICHR!LICWFL!LICRFL!LICWPJ!LICRPJ
	  TRZ	T1,LICHR		;NEED ABOVE OR HR,RF OR RP TO SET HR

LICSPG:	TRO	T2,LICRMT!LICHR		;OK TO SET HF OR HR
	HRL	T2,T1			;  NOT OK TO ASK IF UNABLE TO SET
	PUSHJ	P,LICMSK
	HRRM	T2,T1
	POPJ	P,


;SET MAX LICENSE OF LEFT HALF OF T2 AND RIGHT HALF OF T2
MAXLIC::LDB	T3,[POINT 2,T2,LICWPS]	;MAX OF WRITE PRVS
	LDB	T4,[POINT 2,T2,LICWPS+^D18]
	CAMGE	T4,T3
	  MOVE	T4,T3
	DPB	T4,[POINT 2,T2,LICWPS+^D18]
	LDB	T3,[POINT 2,T2,LICRPS]	;READ IS MAX OF READ
	CAMGE	T3,T4			;WRITE PRV. IMPLIES READ SO INCLUDE
	  MOVE	T3,T4
	LDB	T4,[POINT 2,T2,LICRPS+^D18]
	CAMGE	T4,T3
	  DPB	T3,[POINT 2,T2,LICRPS+^D18]
	HLRZ	T3,T2
	TRZ	T3,LICFMK		;TURN OFF ALL READ AND WRITE DSK BITS
	IOR	T2,T3
	POPJ	P,


;SETS LICENSE BY MASKING. LEFT HALF OF T2 IS THE REQUESTED
;LICENSE. RIGHT HALF IS WHAT HE CAN HAVE

LICMSK::LDB	T3,[POINT 2,T2,LICWPS]
	LDB	T4,[POINT 2,T2,LICWPS+^D18]
	CAMGE	T4,T3
	  DPB	T4,[POINT 2,T2,LICWPS]
	LDB	T3,[POINT 2,T2,LICRPS]
	LDB	T4,[POINT 2,T2,LICRPS+^D18]
	CAMGE	T4,T3
	  DPB	T4,[POINT 2,T2,LICRPS]
	HLRZ	T3,T2
	TRNE	T2,LICRMT		;IF HF OK BUT HR UNSPECIFIED
	  TRO	T2,LICHR		; THEN MAKE HR OK ALSO
	TRO	T2,LICFMK
	AND	T2,T3
	TRZ	T2,LICUNU		;TURN OFF UNUSED BITS JUST IN CASE
	POPJ	P,

COMMENT ! LICSAM
EXPECTS: T2/ LICENSE (FROM HIGH FILE),,LICENSE(FROM LOW FILE)
FUNCTION: RETURN T2/ 0,,LICENSES COMMON TO BOTH HALVES
DESTROY: T3,T4
NOTE: VIRTUALLY IDENTICAL TO LICMSK. USED BY SEGCON
!
LICSAM::LDB	T3,[POINT 2,T2,LICWPS]
	LDB	T4,[POINT 2,T2,LICWPS+^D18]
	CAME	T4,T3
	  TLZ	T2,3B<LICWPS+^D18>	;DIFFERENT. ZAP WRITE PRIVS
	LDB	T3,[POINT 2,T2,LICRPS]
	LDB	T4,[POINT 2,T2,LICRPS+^D18]
	CAME	T4,T3
	  TLZ	T2,3B<LICRPS+^D18>	;DIFFERENT. ZAP READ PRIVS
	HLRZ	T3,T2			;T3/0,,LICS (READ,WRITE PRIVS FIXED)
	TRO	T2,LICFMK		;R/W PRIV MASK
	AND	T2,T3			;T2/0,,LICS(ANDED)+R/W PRIVS, FIXED
	TRZ	T2,LICUNU
	POPJ	P,

;GET LICENSE FROM CORE TABLES. F IS SET UP. RETURN IN T1
;NON-SKIP RETURN IF NOT DISK. USED BY SEGCON

GETLIC::MOVE	T1,DEVMOD(F)
	TLNE	F,GETB			;IF OFF A GETSEG, NO LICENSE
	TLNN	T1,DVDSK
	  JRST	CPOPJ1
GETLI1::HRRZ	T1,DEVATB(F)		;ENTERED HERE FROM SEGCON
	HRRZ	T1,ATBLIC(T1)
	MOVE	T2,JOB
	MOVE	T2,JBTPPN(T2)
	XOR	T2,DEVPPN(F)		;SEE IF IN SAME PROJECT
	TLNN	T2,-1
	  POPJ	P,			;YES
	TRNN	T1,LICWFL
	  TRZ	T1,LICWPJ		;RESET PROJECT READ AND WRITES
	TRNN	T1,LICRFL		;FROM OTHER PROJECTS
	  TRZ	T1,LICRPJ
	POPJ	P,

	SUBTTL ERROR RETURNS

ILNMER:	MOVEI	T1,FNFERR
	JRST	STRERR

LUKER1:	TLZ	M,EXTUUO
	XCTFU	<SKIPN T2,(M)>		;DO NOT KNOW YET IF EXTENDED
	  JRST	RENER0
	TLNN	T2,-1
	  TLO	M,EXTUUO		;IT IS EXTENDED
RENER0:	MOVEI	T1,ISUERR
	JRST	STRERR
UILNMD:	MOVEI	T1,AEFERR		;%
UPDERC:	PUSHJ	P,GIVCBR
	JRST	STRERR

UPDER2:	MOVEI	T1,PRTERR		;%
	JRST	UPDERC

UPDER3:	MOVEI	T1,FBMERR		;%
	JRST	UPDERC

CLRENT:	PUSHJ	P,GETCBR		;% GET RESOURCE
	MOVEI	T1,ATPCRE!ATPSUP	;%
CLRNT1:	ANDCAB	T1,ATBSTS(P2)		;%
CLRCOM:	HRRZ	P3,ATBFNB(P2)		;% IN CASE WE NEED IT (FNB)
	TDNN	T1,[ATMUMC,,ATMCNT!ATPREN!ATPUPD!ATPSUP!ATPCRE!ATPMXU]
	  JRST	[PUSHJ  P,FREATB	;%
		 HLLZS  DEVATB(F)	;%
		 JRST   .+1]		;%
	SOS	T1,DRBCNT(P4)		;%
	TRNE	T1,DRPMXC		;%
	 STOPCD (.,DISK,CLRCM1,,<CLRCOM decremented DRBCNT too far>);;CLRCOM+5
	PUSHJ	P,ULKDBL		;%
	PJRST	GIVCBR			; Free CB resource

LKER1:	PUSHJ	P,RELRIB		;GET RID OF RIB IF WE HAVE IT.
	MOVEI	T1,PRTERR
	PUSHJ	P,STRERR		;SET FLAG
	PUSHJ	P,GETCBR		;%
	MOVE	T1,ATBCNT(P2)		;% SET ARGUMENT
	MOVEI	M,CLSACC!CLSOUT		;% MAKE LOOK LIKE A CLOSE
	PJRST	CLOSRN			;% IN CASE ATPDEL IS SET (SUPERCEDE)

ENTER1:	PUSHJ	P,CLRENT
	MOVEI	T1,PRTERR
	JRST	STRERZ

ENTER2:	PUSHJ	P,CLRENT		;Here when RIB page cannot be allocated
	MOVEI	T1,NRMERR		;"No room"
	JRST	STRERZ

ERRLKM:	MOVEI	T1,LKMERR
	JRST	STRERR

ERRNET:	MOVEI	T1,NETERR
STRERZ:	MOVEI	T2,0
	DPB	T2,DEYSTC
STRERR:	TLNN	M,EXTUUO
	  XCTBU	<HRRM T1,UUNEXT(M)>
	TLNE	M,EXTUUO
	  XCTBU	<HRRM T1,UUXEXT(M)>
	POPJ	P,
RENER9:	HRRM	P2,DEVATB(F)		;PUT THINGS BACK
	HRLM	P4,DEVDRB(F)
	PUSH	P,T1			;SAVE ERROR CODE
	PUSHJ	P,RENNMR		;RESTORE OLD NAME
	POP	P,T1
	JRST	RENRCM			;AND GIVE ERROR

RENER7:	PUSHJ	P,GIVCBR		;%
RENRR3:	MOVEI	T1,PRTERR
RENRCM:	MOVEI	T2,ATPREN
	ANDCAM	T2,ATBSTS(P2)
	SOS	T2,DRBCNT(P4)
	TRNE	T2,DRPMXC
	 STOPCD (SLO)			;;RENRCM+4
	MOVEI	T2,DECLUK
	DPB	T2,DEYSTC		;RESET, LOOKUP WAS IN FORCE AND IS AGAIN
	JRST	STRERR

RENRR4:	MOVEI	T1,TRNERR
	JRST	RENRCM

RENRR2:	MOVEI	T1,TRNERR
RENCLR:	PUSH	P,T1			;SAVE IT
	HLRZ	P4,ATBDOR(P2)		;OLD DRB
	HRRZ	P2,ATBDOR(P2)
	PUSHJ	P,GETCBR
	HRRZ	P3,ATBFNB(P2)		;%
	PUSHJ	P,FREATB		;% GIVE BACK ATB (NEW)
	SOS	T1,DRBCNT(P4)		;%
	TRNE	T1,DRPMXC		;%
	 STOPCD (SLO)			;;RENCLR+8
	PUSHJ	P,GIVCBR		;%
	HRRZ	P2,DEVATB(F)
	HLRZ	P4,DEVDRB(F)
	SETZM	ATBDOR(P2)		;REMOVE LINK
	POP	P,T1
	JRST	RENRCM			;AND GO

RENRR1:	PUSHJ	P,RELLOK
	PUSHJ	P,RENNXR
	MOVEI	T1,PRTERR
	JRST	RENCLR

RENRR0:	PUSHJ	P,RELLOK
	MOVEI	T1,NRMERR
	JRST	RENCLR
;THIS IS PART OF THE SYSDEV UUO

SYDUNI::HRRI	M,1(M)			;GET THE UNIT NAME SPECIFIED BY USER
	UMOVE	T1,(M)
	HLRZ	U,SYSUNI		;START OF UNIT CHAIN
	JUMPE	T1,SYDUN1		;USER SPECIFIED 0, FIRST UNIT
SYDUN3:	CAMN	T1,UNINAM(U)
	  JRST	SYDUN2			;FOUND UNIT SPECIFIED
	HLRZ	U,UNISYS(U)		;NEXT UNIT
	JUMPN	U,SYDUN3		;MORE LEFT?
	POPJ	P,			;NO, NAME SPECIFIED NOT UNIT, ERROR RET

SYDUN2:	HLRZ	U,UNISYS(U)		;GET NEXT UNIT
	JUMPE	U,SYDNM4		;RETURN A 0 FOR END OF LIST
SYDUN1:	LDB	T1,UNYSIZ		;GET THE SIZE WE CAN GIVE HIM
	MOVE	T2,UNINAM(U)
SYDUN4:	UMOVEM	T2,(M)			;GIVE HIM THE NAME OF THIS ONE
	MOVSI	T2,LICSYS!LICSPY	;SEE IF HE CAN HAVE MORE
	TDNN	T2,JBTLIC(J)
	  JRST	CPOPJ1			;NO
	SOJLE	P1,CPOPJ1		;OR MAYBE DOES NOT WANT MORE
	HRRI	M,1(M)
	JRST	SYDCOM


SYDSTR::HRRI	M,1(M)			;Addr of user block + 1
	UMOVE	T1,(M)
	JUMPE	T1,SYDST3		;FIRST STRUCTURE REQUESTED
	MOVEI	U,STRDDB		;NO, CHECK LIST FOR POSITION
SYDST1:	CAME	T1,STRNAM(U)		;IS THIS THE CURRENT ONE?
	  JRST	SYDST2			;NO, TRY NEXT ONE
	HLRZ	U,STRNXT(U)		;YES, GET NEXT
	JUMPN	U,SYDST4		;ANOTHER STR, GIVE IT TO HIM
	JRST	SYDNM4			;SAY NOTHING MORE

SYDST2:	HLRZ	U,STRNXT(U)		;TRY FOR ANOTHER ONE
	JUMPN	U,SYDST1		;YES, KEEP LOOKING FOR A MATCH
	  POPJ	P,			;NO MATCH, BAD ARGUMENT

SYDST3:	MOVEI	U,STRDDB		;STR DATA FROM COMMOD
SYDST4:	MOVEI	T1,STRLEN
	MOVE	T2,STRNAM(U)		;NAME FROM STR BLOCK
	JRST	SYDUN4

EXTERNAL SYDCOM
SUBTTL  F.S. UUO FUNCTION AND ERROR RETURN CODES

;STRUUO FUNCTION CODES

XP .FSSRC,0	;DEFINE NEW SEARCH LIST (UNPRIVILEGED)
XP .FSDSL,1	;DEFINE NEW SEARCH LIST (PRIVILEGED)
XP .FSDEF,2	;DEFINE NEW FILE STRUCTURE
XP .FSRDF,3	;REDEFINE FILE STRUCTURE STATUS
XP .FSLOK,4	;LOCK OUT NEW INITS,ENTERS,LOOKUPS
XP .FSREM,5	;REMOVE FILE STRUCTURE FROM SYSTEM

;STRUUO & GOBSTR ERROR CODES

XP .ERILF,0	;ILLEGAL FUNCTION CODE
XP .ERSNF,1	;1 OR MORE FILE STRUCTURES NOT FOUND
XP .ERSSA,2	;1 OR MORE FILE STRUCTURES SINGLE ACCESS ONLY
XP .ERILE,3	;1 OR MORE ILLEGAL ENTRIES IN ARG. LIST
XP .ERTME,4	;TOO MANY ENTRIES IN SEARCH LIST
XP .ERUNA,5	;1 OR MORE UNITS NOT AVAILABLE
XP .ERPPN,6	;JOB # , PP # DO NOT MATCH
XP .ERMCN,7	;MOUNT COUNT NOT 0
XP .ERNPV,10	;NOT PRIVILEGED USER
XP .ERFSA,11	;F.S. ALREADY EXISTS
XP .ERILL,12	;ILLEGAL ARG. LIST LENGTH (LH UUO AC)
XP .ERUNC,13	;UNABLE TO COMPLETE THE FUNCTION
XP .ERNFS,14	;SYSTEM FULL OF FILE STRUCTURES
XP .ERNCS,15	;NOT ENOUGH FREE CORE FOR DATA BLOCK
XP .ERUNF,16	;ILLEGAL UNIT
XP .ERRSL,17	;FILE STRUCTURE REPEATED IN SEARCH LIST DEFINITION

;MACRO TO ASSOCIATE SYMBOLIC ADDRESS AND ERROR CODE

	DEFINE	ERCODE	(NAME,CODE)<
IFG <CODE-MXECOD>,<MXECOD==CODE>
	NAME==ECOD'CODE>

MXECOD==0	;NUMBER OF ERROR CODES TO GENERATE
SUBTTL	SYSSTR UUO
;UUO TO RETURN NAME OF NEXT FILE STRUCTURE IN SYSTEM
;NOTE THAT ACCUMULATOR J IS J AND CONTAINS THE JOB NUMBER OF THE JOB
; EXECUTING THE UUO


SYSTUU::JUMPE	T1,SYSTU1		;% JUMP IF 1ST STR DESIRED
	CAME	T1,[SIXBIT /DSKB/]	;ONLY LEGAL STR NAME
	  POPJ	P,			;% NO, ERROR RETURN
	TDZA	T1,T1			;AFTER DSKB IS END
SYSTU1:	MOVE	T1,[SIXBIT /DSKB/]
	JRST	RETARG
SUBTTL	SYSPHY UUO
;CALLI AC,51
;UUO TO RETURN NAME OF NEXT PHYS.DEV. NAME IN SYSTEM
; CALLING SEQUENCE IS SIMILAR TO SYSSTR UUO


SYSPHY::HLRZ	U,SYSUNI	;U=ADDRESS 1ST UNIT D.B.
	JUMPE	T1,SYSPH4	;IF USER AC=0: RETURN 1ST UNIT

SYSPH2:	CAMN	T1,UNINAM(U)	;THIS UNIT PHYS.NAME = ARGUMENT?
	JRST	SYSPH3		;YES-GO RETURN NEXT PHYS.NAME
	HLRZ	U,UNISYS(U)	;NO--GET NEXT UNIT
	JUMPN	U,SYSPH2	;IF THIS IS LAST UNIT:
	POPJ	P,		;   GIVE ERROR RETURN

SYSPH3:	SETZ	T1,		;RETURN 0 IN CASE IT WAS LAST UNIT
	HLRZ	U,UNISYS(U)	;GET NEXT UNIT D.B.
	JUMPE	U,RETARG	;IF THAT WAS LAST UNIT: RETURN 0
SYSPH4:	MOVE	T1,UNINAM(U)	;OTHERWISE RETURN PHYS.NAME
	JRST	RETARG
SUBTTL GOBSTR M
; GENERALIZED JOBSTR M  -  CALLI AC,66


;ERROR RETURN CODES:

ERCODE GERIFS,\.ERILE	;1ST ARG. NOT VALID (-1 OR F.S. NAME IN JOBS SRCH LIST)
ERCODE GERPPN,\.ERPPN	;JOB# (1ST ARG) NO GOOD OR DOESNT MATCH PPN (2ND ARG)
ERCODE GERILL,\.ERILL	;ILLEGAL ARG.LIST LENGTH (LH OF M AC)
; ALSO .ERNPV		;(SUBROUT PRIVJ) NOT PRIVILEGED JOB

INTERN GOBSTR
GOBSTR:	JSP	T4,PRIVJ		;PRIVILEGED JOB?
	HRRM	T1,M		;RH M=ADDR. USERS ARG. LIST
	HLRZ	P1,T1		;P1=LENGTH OF ARG. LIST
	SKIPN	P1		;CONVERT 0 TO 3
	MOVEI	P1,3
	CAIGE	P1,3		;LENGTH 3 OR GREATER?
	JRST	GERILL		;NO--ERROR RETURN

	PUSHJ	P,CKJPPN	; JOB # MATCH PPN?
	  JRST	GERPPN		; NO--ERROR RETURN
	ADDI M,2		; POSITION FOR THE JOBSTR ARG
	PUSHJ	P,JOBST0	; PUSHJ TO JOBSTR CODE SO I
	  JRST	GERIFS		;   CAN HANDLE MY OWN ERROR RETURN
	JRST	CPOPJ1		; GOOD RETURN--PASS IT ON
;UUO TO RETURN NEXT STR IN JOB'S OWN SEARCH LIST


;SO GOBSTR CAN USE THIS SAME CODE:
;   J HOLDS # OF JOB WHOSE SEARCH LIST IS TO BE SEARCHED (0 IS SYS SEARCH LIST)
;   P1=# OF ARGUMENTS

JOBSTR:	HRRM	T1,M		;ADDR OF USER'S ARGUMENT LIST
	HLRZ	P1,T1		;P1=NUMBER OF ARGS DESIRED
	SKIPN	P1
	  MOVEI	P1,1		;CONVERT 0 TO 1

JOBST0:				; HERE FROM GOBSTR
	UMOVE	T1,(M)		; GET 1ST ARG=STR NAME
	AOJE	T1,JOBST2	; JUMP IF BEGINNING DESIRED (-1)
	SOJN	T1,JOBST1	; JUMP IF NOT FENCE (0)
	MOVNI	P2,1		; FENCE, NEXT IS END
	JRST	JOBST8

JOBST1:	CAME	T1,[SIXBIT /DSKB/]
	  POPJ	P,		; DSKB IS ONLY ALLOWED STR
	TDZA	P2,P2		; FOLLOWED BY FENCE
JOBST2:	MOVE P2,[SIXBIT /DSKB/]	; FIRST STR IS DSKB
JOBST8:	UMOVEM	P2,(M)		; STORE STR NAME
	SOJE	P1,CPOPJ1	; SKIP RETURN IF NO MORE ARGS DESIRED
	XCTBU	<SETZM 1(M)>	; ZERO FOR PPN WORD FOR NOW ***
	SOJE	P1,CPOPJ1	; SKIP RETURN IF NO MORE ARGS DESIRED
	XCTBU	<SETZM 2(M)>	; STORE 0 FOR STATUS BITS
	JRST	CPOPJ1		; SKIP RETURN
SUBTTL	STRUUO M
;M TO PERFORM VARIOUS FUNCTIONS FOR FILE STRUCTURES
;NOTE THAT ACCUMULATOR J IS J AND CONTAINS THE JOB NUMBER OF THE JOB
; EXECUTING THE M

;ERROR CODES

ERCODE ILLERR,\.ERILL	;ILLEGAL ARG.LIST LENGTH (LH M AC)
ERCODE NPVERR,\.ERNPV	;NOT PRIVILEGED PROGRAM
ERCODE PPNERR,\.ERPPN	;JOB #--PPN MISMATCH
ERCODE SNFERR,\.ERSNF	;F.S. NOT FOUND (NONEXISTANT)
INTERNAL SNFERR
ERCODE ILFERR,\.ERILF	;ILLEGAL FUNCTION
ERCODE UNFERR,\.ERUNF	;NO SUCH UNIT
ERCODE NCSERR,\.ERNCS	;NOT ENOUGH FREE CORE
INTERNAL NCSERR
ERCODE UNCERR,\.ERUNC	;UNABLE TO COMPLETE THE FUNCTION


INTERN STRUUO
STRUUO:	JSP	T4,SAVE4	;SAVE ALL 4 GLOBAL ACCUMULATORS
	MOVE	P4,T1		;SAVE T1 IN P4
	HRRM	T1,M		;ADDRESS OF ARGUMENT LIST
	UMOVE	T1,(M)		;GET FIRST ARGUMENT = FUNCTION
	JUMPL	T1,ILFERR	;ILLEGAL IF NEGATIVE
	CAIL	T1,STRFNN	;SEE IF LEGAL FUNCTION
	JRST	ILFERR		;WELL, NO
	AOJA	M,@STRFNC(T1)
STRFNC:	XWD	ZERO5,SRCSTR	;(0) DEFINE NEW SEARCH LIST (UNPRIVILEGED)
	XWD	ZERO5,DSLSTR	;(1) DEFINE NEW SEARCH LIST (PRIVILEGED)
	XWD	ZERO5,ILFERR	;(2) DEFINE NEW FILE STRUCTURE
	XWD	ZERO5,ILFERR	;(3) REDEFINE FILE STRUCTURE (CHANGE BITS)
	XWD	ZERO5,ILFERR	;(4) LOCK OUT NEW INIT'S, ENTER'S ,ETC.
	XWD	ZERO5,ILFERR	;(5) REMOVE FILE STRUCTURE FROM SYSTEM
	XWD	ZERO5,ULKSTR	;(6) TEST/SET UFD INTERLOCK FOR LOGIN, LOGOUT, ETC
	XWD	ZERO5,UCLSTR	;(7) CLEAR UFD INTERLOCK
	XWD ZERO5,ETSSTR	;(10 ERROR TEST M (SIMULATE ERRORS) .FSETS
	RRSET			;(11) READ AND RESET BUFFERED LOG FOR 3330'S
STRFNN==.-STRFNC
SUBTTL STRUUO M - DEFINE NEW SEARCH LIST
;FUNCTIONS TO DECLARE NEW SEARCH LISTS

;FOR THIS JOB (UNPRIVILEGED)

SRCSTR:	HLRZ	P3,P4		; P3=ARG.LIST LENGTH - 1
	SOJA	P3,SLSTRR

;FOR ANY JOB (PRIVILEGED)

DSLSTR:	JSP	T4,PRIVJ		;PRIVILEGED JOB?
	PUSHJ	P,CKJPPN	; JOB # MATCH PPN?
	  JRST	PPNERR		; NO--ERROR RETURN
	HLRZ	P3,P4		; P3=ARG.LIST LENGTH - 4
	SUBI	P3,4
	ADDI M,3		; FOR CKJPPN
; RH(J)=# OF JOB WHOSE SEARCH LIST IS TO BE DEFINED
; P3=ARG.LIST LENGTH (EXCLUDING INITIAL STUFF LIKE FUNCTION NO.)

; FALL OR SKIP INTO HERE FROM DSLSTR CODE

SLSTRR:	JUMPLE	P3,CPOPJ1	; IF NO F.S. GIVEN, TREAT AS ERROR
SLSTR0:	UMOVE	T1,(M)		; GET NEXT F.S. NAME
	JUMPE	T1,NPVERR	; NOT ALLOWED TO HAVE EMPTY LIST
	CAMN T1,[SIXBIT /DSKB/]	;NOT ALLOWED ANY BUT DSKB
	  XCTBU	<SKIPE 2(M)>	;NO SPECIAL STATUS ALLOWED
	 JRST	SNFERR
	ADDI	M,3
	SUBI	P3,3
	JUMPLE	P3,CPOPJ1	;FINISHED (ASSUME FENCE)
	XCTBU	<SKIPN 2(M)>	;ALLOW A FENCE
	CAILE	P3,3		;BUT THAT MUST BE END OF LIST
	  JRST	SNFERR
	JRST CPOPJ1
SUBTTL	STRUUO - UFD INTERLOCK
LKCLNA==3			;MUST HAVE 3 ARGS INCLUDING FUNCTION CODE
ULKSTR:	TDZA	P3,P3		;CLEAR P3 AND SKIP
UCLSTR:	SETO	P3,		;SET P3 NON-0
	JSP	T4,PRIVJ	;ONLY RETURN IF PRIVILEGED JOB
	HLRZ	T1,P4		;T1=NUMBER OF ARGS
	CAIGE	T1,LKCLNA	;MUST HAVE ENOUGH ARGS
	PJRST	ILLERR		;NOT ENOUGH ARGUMENTS
	UMOVE P1,(M)		;GET STR NAME IN P1 FOR LOKPPB
	UMOVE P2,1(M)		;AND PPN IN P2
	PJUMPE	P3,LOKPPB	;IF ILK, CALL LOKPPB TO TEST/SET
	PUSHJ	P,NLKPPB	;ELSE CALL NLKPPB TO CLEAR
	PJRST	CPOPJ1		;AND RETURN OK

SUBTTL STRUUO - .FSETS ERROR TESTING

;.FSET-ERROR TESTING-FUNCTION TO FORCE CONI AND DATAI ERRORS ON A UNIT
;PART OF STRUUO.
;ARGS ARE FUNCTION, UNIT NAME, ETC. SEE COMMOD FOR
;TABLE OF ARGS-ETSTAB.
;USER MUST BE PRIVILEGED
; ERROR RETURN IF SOME UNIT IS ALREADY BEING ERROR TESTED (.ERUNC)
; UNIT NOT FOUND (.ERFUNF)

ETSSTR:	JSP	T4,PRIVJ	;CHECK FOR PRIVILEGED JOB
	UMOVE T1,(M)		;GET UNIT NAME
	SKIPE	ETSUNI		;ALREADY TESTING ERRORS ON SOME UNIT?
	JRST	UNCERR		;YES, GIVE ERROR RETURN SO TWO
				; USER'S DO NOT CONFUSE EACH OTHER
	SETOM	T2		;SET UNIT NAME MASK TO -1
	PUSHJ	P,SRUNI		;SEARCH FOR UNIT NAME
	  JRST	UNFERR		;UNIT NOT FOUND
	  JFCL			;LOGICAL UNIT NAME
	MOVSI	P1,METSLN	;-LENGTH OF ARG PICKUP
ETSLUP:	ADDI M,1		;GET NEXT USER ARG
	UMOVE T1,(M)
	MOVEM	T1,ETSTAB(P1)	;STORE
	AOBJN	P1,ETSLUP	;MORE?
	MOVEM	U,ETSUNI	;NOW SET UNIT ADDRESS WHICH
				;ENABLES FAKE ERROR TESTING
	JRST	CPOPJ1
SUBTTL M RETURNS AND ERROR CODES

;HERE TO PUT T1 IN USERS M AC AND SKIP RETURN

RETARG:	UMOVEM T1,(W)
	JRST	CPOPJ1

;THESE RETURNS TO PUT ERROR CODE IN USERS M AC AND NO-SKIP RETURN

	DEFINE XCOD(A)
<ECOD'A:	JSP T1,ECOD>

%%XCOD==0
	REPEAT MXECOD+1,<XCOD (\%%XCOD)
%%XCOD==%%XCOD+1>
ECOD:	SUBI	T1,ECOD0+1

	UMOVEM T1,(W)
	POPJ	P,
;CODE FOR INTERLOCK

;	JSP	T4,LOCK
;	--WILL BE UNLOCKED BY MATCHING POPJ (OR CPOPJ1)--

LOCK:	PUSHJ P,GETCBR
	MOVEI F,GIVCBR
	PUSH P,J
	MOVE J,JOB
	MOVEM F,JBTABT(J)	;SET IN CASE OF ADDRESS ERROR
	POP P,J
	MOVEI F,0		;JUST IN CASE
	PUSHJ P,(T4)
	 SKIPA
	AOS (P)
	MOVE J,JOB
	SETZM JBTABT(J)
	PJRST GIVCBR

RRSET:	MOVSI T1,LICSTR!LICJAL
	TDNN T1,JBTLIC(J)		;MUST HAVE ENOUGH LICENSE
	JRST NPVERR
	UMOVE T1,(M)	;THIS IS THE UNIT NAME
	MOVNI T2,1
	PUSHJ P,SRUNI
	 JRST UNFERR
	 JRST UNFERR	;DO NOT ACCEPT LOGICAL NAMES
	HRRZ J,UNIKON(U)
	SKIPL KONLTM(J)
	 JRST UNCERR	;ONLY FOR NON-CHANNEL DEVICES
	JRST RRSETB	;GO TO THE CODE IN FILIO
;% SUBROUTINE TO GET JOB # & PPN FROM ARG. LIST AND CK FOR A MATCH
;% CALL:		M=ADDRESS-1 OF JOB # ARG.
;% 		    PPN ARG. FOLLOWS
;% RETURN+0	IF RIDICULOUS JOB # OR DOESNT MATCH PPN
;% 		M & J ARE CHANGED
;% RETURN+1	IF JOB # ARG. MATCHES PPN ARG.: J=JOB # ARG.
;% 		IF JOB # ARG.=PPN ARG.=-1: J=J (CURRENT JOB #)

CKJPPN:	UMOVE T1,(M)		;% T1=JOB # (1ST ARG.)
	JUMPN T1,CKJPP2		;% NOT SYS
	UMOVE T1,1(M)
	CAME T1,SYSPPN
	POPJ P,			;% NO MATCH
	MOVEI J,0		;% JOB=0 FOR SYS SEARCH LIST
	JRST CPOPJ1
CKJPP2:	SKIPG	T1		;% IF -1: USE CURRENT JOB #
	MOVE	T1,J
	SKIPLE	T1		;% IS IT GOOD JOB #?
	CAMLE	T1,HIGHJB
	POPJ	P,		;% NO
	MOVE	J,JBTSTS(T1)	;% MAYBE  (CK JNA BIT)
	TLNN	J,JNA
	POPJ	P,		;% NO
	MOVE	J,T1		;% YES--MAKE J=JOB #
	UMOVE T1,1(M)		;% T1=PPN
	SKIPG	T1		;% IF -1: USE CURRENT PPN
	MOVE	T1,JBTPPN(J)
	CAME	T1,JBTPPN(J)	;% IS PPN FOR THIS JOB #?
	POPJ	P,		;% NO
	JRST	CPOPJ1		;% YES--GOOD MATCH


;SUBROUTINE TO CK FOR PRIVILEGED JOB (FAILSAFE PPN OR JACCT LIT)
;CALL:	JSP	T4,PRIVJ
;		J=JOB #
;		PRESERVES T1
;RETURNS IF PRIVILEGED OTHERWISE GOES TO NPVERR

PRIVJ:	MOVSI T3,LICSTR
	TDNE T3,JBTLIC(J)
	JRST (T4)		;HE CAN DO IT
	JRST NPVERR	;NO- GIVE ERROR RETURN
SUBTTL DSKCHR MUUO

CODDSK==0		; generic DSK
CODSFS==1		; file structure
CODSTR==2		; structure name
CODLUF==3		; logical unit in file structure
CODKNC==4		; controller class
CODKON==5		; controller name
CODPUN==6		; logical unit of a controller

DSKCHR::HLRZ	T3,T1		;COMPUTE LAST ADDRESS OF TABLE
	MOVN	J,T3
	HRLZS	J
	JSP	T4,LOCK		;LOCK DATA SO IT CAN BE BELIEVED

	HRR	J,T1		;% REMEMBER START OF ARG LIST
	UMOVE	T1,(T1)		;% GET DISK NAME
	JUMPE	T1,CPOPJ	;% ERROR IF ARG. ZERO
	MOVSI	S,CODDSK	;% PRESUME ARG. TO BE "DSK". SET CODE ACCORDINGLY
	PUSH	P,J		;% SAVE J
	MOVE	J,JOB		;% SET J TO CURRENT JOB
	PUSHJ	P,DEVLG		;% SEARCH ALL LOGICAL NAMES IN SYSTEM FOR A MATCH
	  JRST	DSKCHK		;% NO MATCH - CHECK FOR "DSK"
	MOVSI	T2,DVDSK
	TDNN	T2,DEVMOD(F)	;% IS IT A DISK?
	  JRST	TPOPJ		;% NO - EXIT
	MOVE	T1,DEVNAM(F)	;% PICK UP
	MOVEI	F,0		;% JUST TO MAKE SURE 0 IN CASE ERROR
;% HERE TO SEE WHETHER C(T1) IS "DSK","DS" OR "D"

DSKCHK:	PUSHJ	P,ALIASD	;% IS NAME AN ALIAS FOR "DSK"?
	  JRST	DSKFND		;% YES - FIND FIRST UNIT OF 1ST. STR FOR THIS JOB
	MOVSI	S,CODSTR	;% PRESUME ARG. TO BE STR NAME
	CAMN T1,[SIXBIT /DSKB/]	;% ONLY STR ALLOWED
	  JRST	DSKFND		;% YES, USE FIRST UNIT
	MOVSI	S,CODLUF	;%ASSUME LOG. UNIT IN STR
	PUSHJ	P,SRUNI		;% SCAN ALL PHYSICAL AND LOGICAL UNIT NAMES
	  JRST	TPOPJ		;% NO MATCH - EXIT
	  JRST	LOGCHK		;% MATCH ON LOGICAL NAME
	SETCA	T2,0		;% MATCH ON PHYSICAL NAME
	JFFO	T2,.+2		;% DETERMINE # CHARS. IN ARG. FROM MASK
	 STOPCD			;% ERROR - 6 CH. ARG. CAN'T MATCH WITH REMAINING NAME ;;DSKCHK+13
	MOVSI	S,CODKNC	;% PRESUME KONTROLLER NAME
	CAIG	T3,^D12		;% 1 OR 2 CHARS.?
	  JRST	FNDSTR		;% YES. SETUP USER AC
	MOVSI	S,CODPUN	;% PRESUME PHYS. UNIT NAME
	CAIN	T3,^D18		;% 3 CHARS.?
	  MOVSI	S,CODKON	;% YES KONTROLLER NAME
	JRST	FNDSTR		;% DEPOSIT VALUE IN TABLE AND SETUP USER AC.

;HERE WHEN ARG. WAS OR IMPLIED "DSK" TO FIND FIRST UNIT OF JOB'S FIRST FILE STRUCTURE
PRINTF(<[DSKCHR @DSKFND setup P2 with default DSK structure, for this job.]>)
DSKFND:	MOVEI	P2,STRDDB	;% DEFAULT (Only) STRUCTURE is DSKB
	HLRZ	U,STRUNI(P2)	;% USE FIRST UNIT IN STR FOR DSK OR DSKB
	JRST	FNDSTR		;% STR? found


;SUBR TO SEE IF SPECIAL UNIT IN STR IS DESIRED (CALLED BY INIT/OPEN).

TST1UN::MOVE	T1,DEVMOD(F)	;IS THIS A
	TLNN	T1,DVDSK	;DISK?
	  POPJ	P,		;NO.
	MOVE	T1,DEVNAM(F)	;YES. IS IT DSK OR
	PUSHJ	P,ALIASD	;DS OR D?
	  POPJ	P,		;YES.
	CAMN	T1,[SIXBIT/DSKB/] ;NO, DSKB?
	  POPJ	P,		;YES.
	MOVEI	P2,STRDDB	;No, Check each unit on each STR
TST1U0:	HLRZ	U,STRUNI(P2)	;NO, MAYBE A SPECIAL
TST1U2:	CAME	T1,UNINAM(U)	;UNIT?
	CAMN	T1,UNILOG(U)	;
	  JRST	TST1U5		;YES.
	HLRZ	U,UNISTR(U)	;TRY AGAIN.
	JUMPN	U,TST1U2	;
	HLRZ	P2,STRNXT(P2)	; Go through all STRs (only 1) ***
	JUMPN	P2,TST1U0	; Next STR?
	POPJ	P,		; No.
EXTERN DEV1UN
TST1U5:	MOVEM	U,DEV1UN(F)	;SPECIAL UNIT.
	POPJ	P,


;SUBROUTINE TO TEST IF A NAME IS AN ALIAS FOR "DSK"
;ENTER WITH NAME IN T1
;EXIT NAME IN T1, MASK IN T2
;RETURN CPOPJ IF NAME IS AN ALIAS FOR "DSK", CPOPJ1 OTHERWISE

ALIASD::PUSHJ	P,MSKUNI	;GENERATE MASK IN T2 FROM # OF CHARS. IN T1
	MOVSI	T3,(SIXBIT .DSK.)
	AND	T3,T2		;MASK OUT SUPERFLUOUS CHARS
	CAME	T1,T3		;MATCH ON "D", "DS" OR "DSK"?
	  AOS	(P)		;NO. SET FOR SKIP RETURN
	POPJ	P,		;RETURN CPOPJ OR CPOPJ1
;% HERE WHEN A MATCH IS FOUND BETWEEN LOGICAL NAME(UNILOG) & C(T1)

LOGCHK:	CAME	T1,UNILOG(U)	;% EXACT MATCH WITH LOGICAL UNIT NAME?
	  MOVEI	S,CODSFS	;% NO - MUST BE SUBSET OF STRS
FNDSTR:	MOVE	T1,UNIDES(U)	;% LOAD UP BITS FOR USER AC.
	TLZ	T1,377		;% GET RID OF UNIT BLOCK SIZE
	IOR	T1,S		;% "OR" IN ARG. TYPE CODE.
FNDST1:	POP	P,J		;% RESTORE USER ARG
	UMOVEM	T1,(W)		;% STORE BITS IN USER AC.
	AOBJP	J,CPOPJ1	;% IS LENGTH >1?
	MOVSI	T1,MATLEN	;% SETUP LENGTH & INDEX INTO ARGTAB
	HRRZ	P2,UNISTR(U)	;% UP PTR TO STR DATA BLOCK =0 IF NOT IN STR
	MOVE	P1,[647210,,0]	;% BITS=1 FOR ARGS TO IGNORE IF NO FS
ARGLUP:	TLNE	P1,400000	;% HIGH ORDER BIT A 1, THEN CHECK STR
	  SKIPE	P2		;% IGNORE IF NO FS
	 SKIPA			;% ALWAYS RETURN OR IN FS
	TDZA	T2,T2		;% IGNORE, RETURN 0
	  XCT	ARGTAB(T1)
	LSH	P1,1		;% AND SHIFT FOR NEXT TEST
	UMOVEM	T2,(J)		;% DEPOSIT IN TABLE
	AOBJP	J,CPOPJ1	;% FINISHED?
	AOBJN	T1,ARGLUP	;% NO INCREMENT INDEX
	JRST	CPOPJ1		;% RETURN

ARGTAB:	PUSHJ	P,GUFBT			;LOC+1(.UFTAL)	UFD  QUOTA LEFT
	MOVE	T2,STRTAL(P2)		;LOC+2(.STTAL)	STR  SPACE LEFT
	MOVE	T2,UNITAL(U)		;LOC+3(.UNTAL)	UNIT SPACE LEFT
	MOVE	T2,STRNAM(P2)		;LOC+4(.STNAM)	STR  NAME
	MOVE	T2,UNICHR(U)		;LOC+5(.UNCHR)	UNIT CHARs
	MOVE	T2,UNIPPU(U)		;LOC+6(.UNPPU)	# PAGES on UNIT
	MOVEI	T2,0			;LOC+7(.STMNT)	MOUNT COUNT
	LDB	T2,UNYWPS		;LOC+10(.UNWPS)	WORDS PER SAT
	LDB	T2,UNYSPU		;LOC+11(.UNSPU)	SATS PER UNIT
	MOVE	T2,UNIFEP(U)		;LOC+12(.UNFEP) FE FILE PAGES
	MOVEI	T2,0			;LOC+13(.STJOB)	SINGLE ACCESS JOB
	MOVE	T2,UNILOG(U)		;LOC+14(.UNLOG)	STR LOGICAL UNIT
	MOVE	T2,UNINAM(U)		;LOC+15(.UNNAM) KON UNIT NAME
	MOVE	T2,UNIHID(U)		;LOC+16(.UNHID)	UNIT ID
	MOVEI	T2,STRSID(P2)		;LOC+17(.STSID) STR SET ID
	MOVE T2,[LPNHOM##,,LP2HOM##]	;LOC+20(.UNHA)	HOME ADDRESS
	MOVE T2,[LPNBAT##,,LP2BAT##]	;LOC+21(.UNBA)	BAT ADDRESS
IFCPU (KS),<PUSHJ P,GETBSA>		; LOC+22(.UNBSA) BOOTS ADDRESS
IFNCPU(KS),<MOVE T2,[NBOOTP##,,FBOOTB##]>;LOC+22(.UNBSA) BOOTS ADDRESS
MATLEN==ARGTAB-.		;ADD NEW ENTRIES TO TABLE HERE

IFCPU (KS),<
GETBSA:	SKIPN	UNIFEP##(U)		;Has the 8080 area been moved?
	 SKIPA	T2,[100,,10]		;No, give expected value to DSKCLN
	MOVE	T2,[NBOOTP##,,FBOOTB##]	;Yes, KS-BOOTS is now 3 starting at 3
	POPJ	P,
>  ;End IFCPU(KS)
;SUBROUTINE TO SET UP A SEARCH-MASK FOR A NAME
;ENTER WITH T1 =NAME
;EXIT WITH T1=NAME, T2=MASK

MSKUNI:	SKIPN	T2,T1		;GET NAME
	  POPJ	P,		;NOT A NAME - RETURN MASK =0
	MOVSI	T3,770000	;SET  UP MASK
UNIMS1:	TDON	T2,T3		;THIS CHARACTER 0?
	  JRST	UNIMS2		;YES. HAVE MASK
	LSH	T3,-6		;NO, SHIFT AND TRY NEXT CHAR
	JUMPN	T3,UNIMS1
UNIMS2:	TDZ	T2,T3		;0 THE LAST BYTE
	POPJ	P,		;AND RETURN WITH MASK IN T2
;SUBROUTINE TO SEARCH UNIT DATA BLOCKS FOR A MATCH BETWEEN C(T1)
;AND AN EQUIVALENT NUMBER OF CHARACTERS OF UNILOG AND UNINAM
;CALL	MOVE	T2,MASK
;	MOVE	T1,SIXBIT NAME OF FILE STRUCTURE,UNIT,KONTROLLER, ETC.
;	PUSHJ	P,SRUNI
;	  NON MATCH RETURN	T1 & T2 ARE RESPECTED. U IS 0
;	  LOGICAL NAME MATCH	T1 & T2 ARE RESPECTED. U IS THE ADR. OF UNIT DATA BLOCK.
;	PHYSICAL NAME MATCH

SRUNI::	HLRZ	U,SYSUNI	;GET ADR. OF FIRST UNIT IN SYSTEM
LUPUNI:	MOVE	T3,UNILOG(U)	;GET LOGICAL UNIT NAME WITHIN STR
	TRNN	T2,007700	;Don't stop at DSKB10 when looking for DSKB1
	 AND	T3,T2		;MASK OUT UNWANTED CHARS.
	CAMN	T1,T3		;MATCH?
	 JRST	CPOPJ1		;YES - FOUND A LOGICAL UNIT MATCH RETURN
	MOVE	T3,UNINAM(U)	;GET PHYSICAL UNIT NAME
	TRNN	T2,770000	;Don's stop at BPA10 when looking for BPA1
	 AND	T3,T2		;MASK
	CAMN	T1,T3		;MATCH?
	 JRST	CPOPJ2		;YES - FOUND A PHYSICAL UNIT MATCH RETURN
	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT IN SYSTEM
	JUMPN	U,LUPUNI	;LAST ONE?
	POPJ	P,		;YES - RETURN
;SUBROUTINE TO COMPUTE SIXBIT LOGICAL UNIT NUMBER WITHIN STR
; T1 HAS NUMBER WITHIN STR IN RH, LH GARBAGE.

INTERN CMPLOG
CMPLOG:	PUSH	P,P3
	HRRZ	P3,T1
	LSH	P3,-^D3
	ADDI	P3,20
	LSH	P3,^D6
	ANDI	T1,7
	ADDI	P3,20(T1)
	MOVE	T1,[SIXBIT /DSKB/]	; Needs thought, STR setup somewhere?
	PUSHJ	P,MSKUNI
	SETCA	T2,0
	JFFO	T2,.+2
	 STOPCD (SLO)           ;;CMPLOG+13
	MOVEI	T2,^D24
	TRNE	P3,700
	  JRST	INSUN2
	TRZ	P3,7700
	MOVEI	T2,^D30
INSUN2:	SUB	T2,T3
	LSH	P3,(T2)
	ADD	T1,P3
	MOVEM	T1,UNILOG(U)
	POP	P,P3
	POPJ	P,

	$END	(FUU)		;End of FILUUO (FUULIT: FUUEND:)

 gQ