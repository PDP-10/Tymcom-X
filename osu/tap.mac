TITLE   TAP     03/26/74

;*CHECK OUT THE ESCAPE ROUTINE
;*IMPROVE TAPE ERROR LOGIC TO READ WHOLE FILE
;*DON'T ALWAYS CHECK FOR WRITE RING
;*PERHAPS HF LICENSE SHOULD BE RESTORED
;*REJECT "AFTER DATE" IF DATE AND TIME IS IN THE FUTURE
;*REENTER AND CONTINUE MAY NOT WORK
;*SHORTEN RESTORE OLD FILE MESSAGE
;*ACCEPT TIME WITH NO COLON 0100
;*ACCEPT DASH BETWEEN TIME AND DATE
;*LICENSE RESTORE LOGIC IS NONEXISTENT
;*ON RESTORE, TITO SHOULD NOT GO PAST LAST POSSIBLE FILE
;*TAPIN ERR SHOULD SAY WHAT KINDS OF ERRORS
;*DON'T RESTORE LICENSE TO FILES WITHOUT LICENSE - ?
;*HAVE OPERS RECOVER BAD FILES - ?
;*CHECK EACH TAPE TO BE SURE IT'S NOT THE ONE WE JUST DUMPED
;*CONTROL OVER TYPES OF ERROR MESSAGES WHICH GO TO TER AND COF FILE
;*SORT BY FILENAME WITHIN USER IN STORE
;*STORE SHOULD PUT USERNAME AS WELL AS PPN ON TAPE
;*TRANSLATE COMMAND NEEDED
;*NEED TO MAKE DIRECTORIES ON SYSTEMS OTHER THAN THE ORIGINAL
;*      OR ON SYSTEMS WHERE THE LUD HAS CHANGED
;*NEED TO SWITCH TO SYNCHRONOUS INPUT MODE AT VARIOUS ABORT
;*      POINTS AND LOOK FOR LOGICAL END OF TAPE

VERLOC= 137
	LOC     VERLOC
	XWD     VERSION,VERPAT          ;STORE VERSION NUMBER IN LOC 137
	RELOC

;ACCUMULATOR ASSIGNMENTS
;U=     15      ;FIRST  WORD ON A READ OF MFD OR UFD
W=      16      ;SECOND WORD ON A READ OF MFD OR UFD
HA==    5       ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER
HB==    HA+1    ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER
HC==    HA+2    ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER
HD==    HA+3    ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER
HE==    HA+4    ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER

;CHARACTERS
QCHR=   121
PRIME=  47
COMMA=  54
LBRACK= 133
RBRACK= 135

;PARAMETER ASSIGNMENTS
CNFSIZ==5		;Size of CNF string in title [15.14]
NDEV==10                ;NO. OF DEVICES IN DEVTBL
XLOOKN==44              ;NO. OF ARGS FOR EXTENDED LOOKUP/ENTER
XHDRN==100              ;LENGTH OF FILE HEADER BLOCK, WHICH INCLUDES
;       FILDM1 (SIXBIT /DSK/ IN LH AND TITO VERSION NO. IN RH)
;       ALL DISC FILE PARAMETERS (.RBARG + XLOOKN WDS), TAPE FILE
;       PARAMETERS (TPDEN,TPSER,TPTIM, AND TPPOS).  FILMRK IS
;       NOT INCLUDED.  THE DISC FILE PARAMETERS START AT THE BEGINNING
;       OF THE BLOCK AND GROW TOWARDS THE END.  THE TAPE FILE PARAMETERS
;       START AT THE END OF THE BLOCK AND GROW TOWARD THE BEGINNING.
XHDR==XHDRN+2           ;LAST WORD IN HEADER RELATIVE TO BUFFER PTR
UCHGBT==200000          ;CHANGED (DUMPED) BIT IN UFD (RH)
RCHGBT==20000           ;CHANGED (DUMPED) BIT IN RIB (LH)
FILCTD==100000          ;(LH) FILE CONTINUED ON NEXT TAPE BIT IN TRAILER
USRCTD==200000          ;(LH) USER CONTINUED ON NEXT TAPE BIT IN TRAILER
TAPCTD==400000          ;(LH) CONTINUATION TAPE(S) FOLLOW BIT IN TRAILER
MSKCTD==TAPCTD!USRCTD!FILCTD    ;MASK FOR CONTINUED BITS

;CALLI ADDRESSES
DEVCHR==4
RESET== 0
WAIT==  10
DATE==  14
MSTIME==23

;CHANIO VALUES
.CHFSI==27		; Position file to input block #  (USETI) [15.14]
.CHFSO==30		; Position file to output block # (USETO) [15.14]


;DEVICE ASSIGNMENTS
MFD==   4               ;DISK FOR MASTER FILE DIRECTORY
UFD==   5               ;DISK FOR USER FILE DIRECTORY (MUST BE MFD+1)
;FIL==   6               ;DISC FOR USER FILE
LUD==   10              ;LUD
DUL==   11              ;DUL
TP0==   12              ;TAPE READ OR WRITE
TP1==   13              ;TAPE READ OR WRITEN

;NUMBER OF BUFFERS/CHANNEL
TAPN==  1
MFDN==  2
UFDN==  2
FILN==: 7
LUDN==  1
DULN==  1

;SIZE OF BUFFERS/DEVICE
TAPSIZ==^D3740+3
DSKSIZ==203

;I/O STATUS BIT ASSIGNMENTS
BUFBIN==14              ;BUFFERED BINARY MODE
DVMTA== 20              ;DEVICE IS MAGTAPE
NOCNT== 20              ;MONITOR IS NOT TO COMPUTE BUFFER WORD COUNT
SYNCIN==40              ;SYNCHRONOUS INPUT
IOEND== 20000           ;END OF FILE
BOTBIT==4000                    ;BEGINNING OF TAPE
IOTEND==2000                    ;END OF TAPE
IOBAD== 740000                  ;I/O ERROR
BTL==   40000                   ;BLOCK TOO LARGE FOR BUFFER
DLL==   4                       ;DO NOT DEALLOCATE EXCESS BLOCKS
DNC==   10                      ;DO NOT CHG ACCESS DATE
DMP==	100000			;SET FILE DUMPED BIT - TYMSHARE ONLY
;RST==   40                      ;DISCARD THIS FILE AND KEEP OLD ONE

;MONITOR VERSION WHEN DMP (above) WAS INTRODUCED
DMPMON==<Byte (^D9) ^D034, "K"-"@", ^D16, 0>

;CHANIO CONTROL BITS FOR READING UFD'S
RCD== 040000    ;READ CREATION DATE
RSB== 020000    ;READ STATUS BITS

;EXTENDED LOOKUP FILE STATUS BITS
.RPNFS==40000           ;(RH) DO-NOT-SAVE BIT
.RPBAD==1               ;(RH) FILE MARKED BAD BY DSKFIX

;MISC PARAMETERS

CUTS==1 ;1=SYNCHRONOUS MODE FOR CUT COMMAND, -1 OTHERWISE TRY ASYNCHRONOUS

;FLAG ASSIGNMENTS (LH OF AC F)
EOTFND==1                       ;EOT HAS BEEN READ
EOFFND==2                       ;END OF DISC FILE HAS BEEN READ
BOTFLG==4                       ;AT BEGINNING OF TAPE
FILFND==10                      ;A FILE WAS SAVED FOR THIS USER
CTDFLG==20                      ;TAPE CONTINUED AT EITHER END
UFDFLG==40                      ;ON IF PROG HAS LICENSE TO SET UP UFDS
LUDFLG==100                     ;ON IF LUD IS OPEN
DULFLG==200                     ;ON IF DUL IS OPEN
STOFLG==400                     ;ON FOR STORE.  OFF FOR RESTORE
DIRFLG==1000                    ;ON FOR DIRECTORY.
INIFLG==: 2000                    ;TAPE INITIALIZED FOR STORE IF ON
P12FLG=:4000                    ;MONITOR P012 OR LATER IF ON
T12FLG=:10000                   ;TAPE CREATED ON P012 OR LATER
CUTFLG==20000           ;ON FOR CUT.  OFF FOR OTHER.
RPTFLG==:40000                   ;REPEATED STORE FLAG
RPTFIL==:100000 ;TURNED ON BY TAPE WRITE ERROR TO REPEAT FILE AT UFD2
PRPFLG== 200000 ;INDICATES THAT TAPE SAVESET HAS BEGUN
FAIFLG== 400000 ;INDICATES THAT DIRECTORY IS IN FAILSAFE FORMAT
; FLAGS IN RH OF ACCUM F
NEWFLG==1       ;TAPE VERSION 14 OR GREATER
HDRFLG==2       ;DELAYED HEADER MESSAGES PENDING
FNDFLG==4       ;INDICATES TAPE HAS BEEN POSITIONED TO RANFST
RANFLG==10      ;INDICATES RANGE OF TAPE POSITIONS MUST BE ENTERED
EOFFLG==20      ;AN EOF HAS JUST BEEN READ
EOTFLG==:40     ;TWO CONSECUTIVE EOF'S HAVE BEEN READ
UNMFLG==100     ;DIR RECORD HAS BEEN FOUND WITH NEW USER NAME
SSCFLG==200     ;COMMAND STARTED AT BEGINNING OF TAPE, CAN USE
;               SAVE SET NOS.
IGNFLG==400     ;IGNORE DATA RECORDS IF SET
;               ;WILL BE RESET IF WE ARE PROCESSING A FILE
HDRMSG==1000    ;SUPPRESS HEADER MESSAGES IF SET
HDRFND==2000    ;FOUND HEADER (NEEDED TO RESTORE OLD FILES)
RANCMD==:4000   ;RANGE PRE-ENTERED FROM COMMAND DISPATCHER
TRTFLG==:10000  ;TRANSLATIONS IN EFFECT
TRTFG2==:20000  ;PARTWAY THROUGH ENTERING OF DISC/TAPE USERNAME PRS
TRTFG3==:40000  ;CLEAR TRT AT COMMAND DISPATCH IF NOT SET
LPTFLG==:100000 ;INDICATES THAT LPT: IS OUTPUT MEDIUM
FSTFLG==:200000 ;USE DUL INSTEAD OF FAST DUL WHEN SET
NWFLG==:400000 ;NO WAIT FLAG.  AVOID MTCLS AT CDISP.

SRTOT==:4                       ;STORE/RESTORE PRINT TOTALS
SRUSR==:2                       ;STORE/RESTORE PRINT USERS
SRFIL==:1                       ;STORE/RESTORE PRINT FILES
SRMSK== SRTOT+SRUSR+SRFIL       ;STORE/RESTORE MASK
OSNEW==:10                      ;OLD FILE/SYS RESTORE NEWEST FILE
OSTAP==:20                      ;OLD FILE/SYS RESTORE FILE FROM TAPE
OSDSK==:40                      ;OLD FILE/SYS IGNORE FILE FROM TAPE
OSCON==:100                     ;OLD FILE/SYS ASK FOR CONFIRMATION
OSMSK== OSNEW+OSTAP+OSDSK+OSCON ;OLD FILE/SYS MASK


START:  MOVE    P,STACK##       ;INITIALIZE THE STACK
	CALLI   RESET           ;CLEAR ALL I/O
	SETZM COUT##
	PUSHJ P,COFRLS
	SETOM EROSW##
	SETZ    UNIT,           ;CLEAR UNIT
	SETZ    F,              ;CLEAR ALL FLAGS
	SETZM DEVTBL    ;ZERO THE DEVICE TABLE
	HRLI R1,DEVTBL
	HRRI R1,DEVTBL+1
	BLT 1,DEVTBL+3*NDEV-1
	PUSHJ   P,GETDUL        ;OPEN THE DUL BEFORE THROWING AWAY LIC
	HRROI   R1,-20          ;LOOK FOR OPERATOR LICENSE
	GETTAB  R1,             ;READ JOB AND PROCESS LICENSE
	MOVEI   R1,0            ;CANNOT READ LICENSE SO SET TO ZERO
	HRLZM   R1,JBLIC#       ;SAVE THE JOB'S LICENSE
	TRNN    R1,100000       ;SKIP IF OPER LICENSE SET
	HRLS    R1              ;THROW AWAY PROGRAM'S LICENSE
	TRNN    R1,100000       ;SKIP IF OPER LICENSE SET
	TYPE    [ASCIZ "$OPERATOR LICENSE IS NOT SET."]
	TLO     F,UFDFLG        ;ASSUME WE HAVE LIC TO SET UP UFDS
	TLC     R1,5002         ;COMPLEMENT WF JL ST LICENSE BITS
	TLCE    R1,5002         ;PUT LIC BACK AND SKIP IF ENOUGH LIC
	TLZ     F,UFDFLG        ;NOT ENOUGH LICENSE TO SET UP UFDS
	SETLIC  R1,             ;SET APPROPRIATE LICENSE
	MOVE    R1,[XWD -1,2]   ;NEED PPN FOR THIS JOB
	GETTAB  R1,             ;GET PPN FOR THIS JOB
	MOVEI   R1,0            ;SHOULD NEVER FAIL LIKE THIS
	MOVEM   R1,JBPPN#       ;SAVE PPN FOR THIS JOB
	SETZM   CNVDAT          ;ZERO THE CREATION DATE
	SETZM   CNVTIM          ;ZERO THE CREATION TIME
	SETZM   CNVFMT          ;ZERO THE CREATION FORMAT
	SETZM	ALLFSW		;ZERO THE "ALL FILES" SWITCH
	MOVEI   R1,CNVDAT       ;GET ADDRESS OF TABLE FOR DATUUO
	TLO     F,P12FLG        ;ASSUME THIS IS MONITOR P012 OR LATER
	DATUUO  R1,             ;SKIP IF MONITOR P012 OR LATER
	TLZ     F,P12FLG        ;TURN OFF FLAG - MONITOR P11 OR EARLIER
	MOVE    R1,[XWD 26,11]  ;CONFIG TABLE - JIFFIES PER SEC ENTRY
	GETTAB  R1,             ;GET JIFFIES PER SECOND
	MOVEI   R1,74           ;SHOULD NEVER FAIL, BUT ASSUME 60/SEC
	MOVEM   R1,JIFFPS       ;SAVE JIFFIES PER SECOND
	IMULI   R1,74           ;COMPUTE JIFFIES PER MINUTE
	MOVEM   R1,JIFFPM       ;SAVE JIFFIES PER MINUTE
	PUSHJ P,NHDAT   ;GET TODAY'S DATE
	TYPE [ASCIZ"$TITO (V"]
	MOVE    R1,VERLOC       ;GET VERSION NUMBER
	HLRZM   R1,VERTMP#      ;SAVE PRIMARY VERSION NUMBER
	ERT     [XWD [VERTMP],[ASCIZ "_H"]]
	HRRZM   R1,VERTMP       ;SAVE MINOR CHANGE NUMBER
	SKIPE   VERTMP          ;DON'T PRINT MINOR CHANGE IF ZERO
	ERT     [XWD [VERTMP],[ASCIZ "._H"]]
	ERT [XWD[DAYTIM#],[ASCIZ") HERE AT _L"]]
	PUSHJ P,TPID    	;GET SYSTEM ID
	MOVE R0,[XWD 700!<CNFSIZ*5>,TPID2-1] ; Use Entire name	[15.14]
	MOVEM ID
	MOVE R1,[POINT 7,TPID2]	; POINTER TO SYSTEM NAME	[16.2]
	MOVEI R2,<CNFSIZ*5>	; AND STRING LENGTH		[16.2]
	PUSHJ P,GETVER##	; GET THE MONITOR VERSION ALSO	[16.2]
	MOVEM R1,MONVER#	; AND SAVE IT FOR LATER		[16.2]
	ERT [XWD[ID],[ASCIZ"$SYSTEM _P"]]
UNIROU:  TCO [CRCHR]
	TYPE [ASCIZ "DEVICE: "]
	MOVEI R1,UNIROU
	MOVEM R1,UNISW          ;ERROR UUO JUMP INDIRECT THRU HERE
	MOVEM P,ERRSTP
	PUSHJ P,RDUNI##         ;READ UNIT NAME IN SIXBIT
	MOVEM   FS6BIT          ;STORE DEVICE NAME
	PUSHJ   P,SETIN         ;ASSIGN THE TAPE UNIT
	SETZM SER
	PUSHJ P,GDC             ;GET DEVICE CHARACTERISTICS
	PUSHJ P,PTRK    ;PRINT NO. OF TRACKS
	MOVE R1,TRK1
	MOVEM R1,TRK
	SETOM BPI1
	PUSHJ P,FINDEV          ;FIND SLOT IN DEVTBL FOR FS6BIT
;                               SHOULD NOT SKIP
SETB:   PUSHJ P,SETBPI          ;SET DENSITY
	JRST SETC               ;ERROR
	SKIPL SENTAB+1
	TYPE [ASCIZ"TAPE NOT WRITE PROTECTED
"]
	SKIPGE SENTAB+1
	TYPE [ASCIZ"TAPE IS WRITE PROTECTED
"]
	SETOM   UNISW           ;UNIT PROPERLY ENTERED
	JRST    SCDISP##        ;START UP THE COMMAND DISPATCHER
SETC:   PUSHJ P,DDI
	JRST SETB

; BUFFERS AND VARIABLE STORAGE

F$LKB0:	Block	XLOOKN+1	; Room for Lookup block + 1	[15.14]
F$LKB1:	Block	XLOOKN+1	; Copy of Lookup block for CMP	[15.14]

;I/O BUFFERS

MFDBUF: BLOCK   MFDN*DSKSIZ     ;BUFFERS FOR MFD
UFDBUF: BLOCK   UFDN*DSKSIZ     ;BUFFERS FOR UFD
FILBUF::BLOCK   FILN*DSKSIZ     ;BUFFERS FOR USER FILE
TAPBUF: BLOCK   TAPN*TAPSIZ

LUDTAB: XWD     0,17            ;DUMP MODE
	SIXBIT  /SYS/           ;DEVICE SYS
	0                       ;NO BUFFERS

LOKLUD: SIXBIT  /LUD/           ;FILE NAME
	SIXBIT  /SYS/           ;EXTENSION
	0
	0

	0
LUDLST: IOWD    200,LUDBLK      ;BUFFER
	0
LUDBLK: BLOCK   200
LUDL::  -1                      ;BLOCK NO. IN LUD (SEE USRPPN)

DULTAB: XWD     0,17            ;DUMP MODE
	SIXBIT  /SYS/           ;DEVICE SYS
	0                       ;NO BUFFERS

LOKDUL: SIXBIT  /DUL/           ;FILE NAME
	SIXBIT  /SYS/           ;EXTENSION
	0
	0

	0
DULLST: IOWD    200,DULBLK      ;BUFFER
	0
DULBLK: BLOCK   200
DULL::  -1                      ;BLOCK NO. IN DUL (SEE PPNUSR)

;BUFFER HEADERS

TAPHED::BLOCK   3               ;MAGTAP INPUT OR OUTPUT BUFFER HEADER**2
TAPHD1= TAPHED+1
TAPHD2= TAPHED+2

MFDHED: BLOCK   3               ;DISK MFD BUFFER HEADER**2
MFDHD1= MFDHED+1
MFDHD2= MFDHED+2

UFDHED: BLOCK   3               ;DISK UFD BUFFER HEADER**2
UFDHD1= UFDHED+1
UFDHD2= UFDHED+2

FILHED::BLOCK   3               ;DISK USER FILE BUFFER HEADER**2
FILHD1==:FILHED+1
FILHD2==:FILHED+2

COFHED::BLOCK   3               ;OUTPUT FILE
COFHD1=:COFHED+1
COFHD2=:COFHED+2

LUDHED: BLOCK   3               ;LOCAL USER DIRECTORY HEADER
DULHED: BLOCK   3               ;INVERSE LUD HEADER

;MTA HEADER BLOCK
FIRBLK: XWD     VERSION,4       ;WD0=XWD HEADER FLAG,BLK WDCT
	SIXBIT  /*FAILS/        ;WD1
FIRBL2: SIXBIT  /AFE   /        ;WD2=XWD SIXBIT "AFE",TAPE SEQ#
	                        ;NEGATIVE TAPE SEQ# MEANS TRAILER
FIRBL3: EXP     0               ;WD3=TAPCTD BIT (B0), USRCTD BIT (B1)
	                        ;    FILCTD BIT (B2)
	                        ;    CRTIME (B11-21), CRDATE (B22-35)
	XWD     1,2             ;WD4=TITO PROJ,PROG #

SYSPP:  XWD     1,1

STRPPN::0                       ;STARTING PPN
STRFIL::0                       ;STARTING FILE
STREXT::0                       ;STARTING EXTENSION
STRBLK::0                       ;STARTING BLOCK
STRUSR: BLOCK   2               ;STARTING USER NAME

; CURRENT AND LAST FILE.  SEE TRCL.

CURPPN::0                       ;CURRENT PPN
CURFIL: 0                       ;CURRENT FILE NAME
CUREXT: 0                       ;CURRENT EXTENSION
CURPOS: 0       ;FILE NO. ON TAPE
CURUN1::0       ;FIRST HALF OF USER NAME
CURUN2::0       ;SECOND HALF OF USER NAME
CURTRK: 0       ;TRACKS AND DENSITY
CURVER::0       ;TITO VERSION NO.
CURDAT: 0       ;TIME-DATE WRITTEN
CURSER: 0       ;TAPE UNIT SERIAL NO.
CURNUM: 0       ;SAVE SET REEL NO.
DATTIM: 0       ;CURDAT BACKWARDS FOR COMPARISON

LSTPPN::0                       ;LAST PPN
LSTFIL: 0                       ;LAST FILE
LSTEXT: 0                       ;LAST EXTENSION
LSTPOS: 0
LSTUN1::0
LSTUN2::0
LSTTRK: 0
LSTVER::0
LSTDAT: 0
LSTSER: 0
LSTNUM: 0
LSTTIM: 0

CUTPPN: BLOCK 14
CUTTIM==CUTPPN+13
UFDBLK: 0                       ;FUNCTION FOR UFD INTERLOCK
UFDBL1: 0                       ;STRUCTURE FOR UFD INTERLOCK
UFDBL2: 0                       ;PPN FOR UFD INTERLOCK

CNVDAT::0                       ;CREATION DATE - DAYS SINCE 1964
CNVTIM::0                       ;CREATION TIME - SECONDS LSH 12 (JIFFIES?)
CNVFMT::0                       ;CONVERSION FORMAT FOR DATUUO
CREDAT::0                       ;CREATION DATE FOR ST CRE AFTER
CRETIM::0                       ;CREATION TIME FOR ST CRE AFTER
CRTION: 0                       ;CREATION DATE AND TIME FROM UFD
CHANGD::0                       ;NON-ZERO IF CHECKING FOR CHANGED FILES
JIFFPS::0                       ;JIFFIES PER SECOND (US=60, EUROPE=50)
JIFFPM::0                       ;JIFFIES PER MINUTE
FILCNT::0                       ;NUMBER OF FILES TRANSFERED FOR THIS USER
TOTCNT::0                       ;NUMBER OF FILES TRANSFERED FOR THIS SAVE SET
CKLICT: BLOCK   3               ;TABLE FOR CHKLIC UUO

;LOOKUP & ENTER SPECS
	                        ;EXT LOOKUP     -    OLD LOOKUP
MFDDIR: 0                       ;0,XLOOKN       -     FILNAM
MFDDI1: 0                       ;PPN            -     EXT.,ACC.DAT.
	0                       ;FILNAM         -     PROT,MODE,CREAT
MFDDI3: 0                       ;EXT.,ACC.DAT.   -    PPN
	0                       ;PROT,MODE,CREAT
	BLOCK   1+XLOOKN+MFDDIR-.

UFDDIR: 0                       ;0,XLOOKN       -     FILNAM
UFDDI1: 0                       ;PPN            -     EXT.,ACC.DAT.
UFDDI2: 0                       ;FILNAM         -     PROT,MODE,CREAT
UFDDI3: 0                       ;EXT.,ACC.DAT.   -    PPN
UFDDI4: 0                       ;PROT,MODE,CREAT
URBSIZ: 0
	BLOCK   2               ;--NEVER TOUCH--
URBEST: 0
URBALC: 0
URBPOS: 0                       ;--CLR BEFORE RESTORE--
URBNXT: 0                       ;   "    "       "
URBPRD: 0                       ;   "    "       "
	BLOCK   2
URBSTS:	0			;FILE STATUS WORD
	BLOCK	5
URBCSZ: BLOCK   1               ;CURRENT SIZE
	BLOCK   1+XLOOKN+UFDDIR-. ;---NEVER TOUCH ON SAVE OR RESTORE--


; FILE HEADER BLOCK, LENGTH XHDRN+1

FILMRK: XWD     -1,XHDRN        ;RH CONTAINS COUNT OF WORDS BELOW
FILDM1: SIXBIT  /DSK/   ;CURRENT FILE STRUCTURE (MUST PRECEDE FILDIR)
FILDIR::0                       ;0,XLOOKN       -     FILNAM
FILDI1::0                       ;PPN            -     EXT.,ACC.DAT.
FILDI2::0                       ;FILNAM         -     PROT,MODE,CREAT
FILDI3::0                       ;EXT.,ACC.DAT.   -    PPN
FILDI4: 0                       ;PROT,MODE,CREAT
FRBSIZ: 0                       ;FILE SIZE IN WORDS
	BLOCK   2               ;--NEVER TOUCH--
FRBEST: 0                       ;ESTIMATED SIZE OF FILE
FRBALC: 0                       ;# OF BLKS NEEDED
FRBPOS: 0                       ;--CLR BEFORE RESTORE--
FRBNXT: 0                       ;   "    "       "
FRBNCA: 0                       ;   "    "       " (DUMPED BIT)/LICENSE
	0                       ;
	0
FRBSTS: 0                       ;FILE STATUS WORD
	BLOCK XHDRN-8+FILDM1-.
TPUN1: 0        ;USER NAME (SIXBIT) FIRST HALF
TPUN2: 0        ;USER NAME (SIXBIT) SECOND HALF
TPID1: Block 2	;SYSTEM NAME IN ASCII WORD 1 thru CNFSIZ	[16.2]
TPDEN::0        ;LH IS TAPE DENSITY, RH IS NO. OF TRACKS
TPSER: 0        ;LH IS CUSTOMER TAPE NO., RH IS TAPE DRIVE SERIAL NO.
TPTIM: 0        ;TIME IN BITS 11-21, DATE IN BITS 22-35 TAPE WRITTEN
TPPOS: 0        ;LH IS TAPE SEQUENCE NO., RH IS FILE NO. ON TAPE
SAVBUF: BLOCK   XLOOKN+1
TRBSIZ= SAVBUF+5        ;TAPE FILE WORD COUNT

;MISCELLANEOUS DATA

TPID2:	Block CNFSIZ	; Ascii text name of system		[16.2]
CKSUM:: 0       ;FOLDED CHECKSUM OF FILE BEING PROCESSED
BPI1::  0       ;DESIRED TY BPI
BPI:    0       ;ACTUAL DENSITY
TRK:    0       ;ACTUAL NO. OF TRACKS
TRK1:   0       ;DESIRED NO. OF TRACKS
TPSZM2: 0       ;TAPE RECORD SIZE - 2
TPSZM3: 0       ;TAPE RECORD SIZE -3
TPSZM4: 0       ;TAPE RECORD SIZE -4
ESCDI:: 0       ;NEG. IF ESCAPE TRAP DISABLED (SEE NXTTAP)
UNISW:: 0       ;NEG. IF STILL IN UNIROU
ERRSTP:: 0      ;SAVED STACK PTR FOR ERRUUO WHEN UNISW SET
STO23:   0      ;PTR TO COMMAND LIST FOR INDIVIDUAL FILES OR USERS
CSTATE: 0       ;COMMAND STATE 0=ALL,1=GANS,2=USERS,3=FILES
RPTCNT:: 0      ;REPEAT COUNT FOR STORE
SCOUNT:: 0      ;COUNT OF FILES STORED
RCOUNT:: 0      ;COUNT OF FILES RESTORED
UCOUNT: 0       ;COUNT OF UFD'S SET UP
CPPN:: 0        ;LAST PPN REFERENCED IN COMMAND DISPATCHER.  SEE FINGAN.
PPN:: 0         ;PPN OF USER TO RECEIVE FILES WHEN USING TRANSLATE OPTION
ERC:    0       ;EXCESSIVE RECORD COUNT
UPDMOD: 0       ;UPDATE MODE IF NON-ZERO
SEXT:   0       ;SAVED FILE EXT
ORBALC: 0       ;FORMER RIB ALLOCATION
ORBSIZ: 0       ;FORMER RBSIZ
TAPCNT: 0       ;EXPECTED TAPE WORD COUNT+1
WDCNT:  0       ;NO. DATA WORDS WRITTEN TO FILE
TRBALC: 0       ;TAPE FILE SIZE ALLOCATION, BLOCKS
FILCOD: 0       ;ERROR BITS ON DATA TRANSMISSION ERROR
FILPOS: 0       ;USED BY TRUNCATE
SAVHED: 0       ;USED BY TRUNCATE
SAVBYT: 0       ;USED BY TRUNCATE
CREDSC: 0       ;CREATION DATE SAVED BY GCREDAT
SAVDI4: 0       ;  "  "
ERCODE: 0       ;ERROR CODE FROM EXTENDED LOOKUP,ENTER, OR RENAME
EXTPPN:	0	;EITHER CURRENT PPN OR LOGGED-IN PPN
EXTFIL:	0
EXTEXT:	0
UPDFLG:: 0
PRAFLG:: 0
ASKFLG:: 0	;[16.5] CONTINUE IF NONZERO, ASK IF ZERO
FLGOFF:: 0      ;MARK FILES NOT CHANGED IF UNEQUAL ZERO
ALLFSW:: 0	;"ALL FILES" SWITCH.

MFDSPK: BUFBIN
	SIXBIT  /DSK/           ;MUST BE MFDSPK+1
IOBUF:  0                       ;OBUF,IBUF FOR MFD - MUST BE MFDSPK+2

; CHANIO ARGLIST AND BUFFERS
MFDARG: -2,,MFDTAB
	SIXBIT /######/
	SIXBIT /UFD   /
	0
MFDMON: BLOCK 4 ;WRITTEN BY MONITOR
MFDTAB: 0       ;PPN
	0       ;EXTENSION

UFDARG: -4,,UFDTAB
	SIXBIT /######/
	SIXBIT /###   /
	RCD!RSB,,0
UFDMON: BLOCK 4 ;WRITTEN BY MONITOR
UFDTAB: 0       ;FILENAME
	0       ;EXT
UFDCRE: 0       ;CREATION DATE
UFDBTS: 0       ;STATUS BITS
	VAR

; TABLE OF MAGTAPE INSTRUCTIONS TO XCT INDEXED BY UNIT
MF0:    MTAPE TP0,0     ;WAIT FOR COMPLETION
	MTAPE TP1,0     ;WAIT FOR COMPLETION
MF1:    MTAPE TP0,1     ;REWIND WITHOUT WAIT
	MTAPE TP1,1
MF7:    MTAPE TP0,7     ;BACKSPACE RECORD
	MTAPE TP1,7
MF11:   MTAPE TP0,11    ;UNLOAD WITHOUT WAIT
	MTAPE TP1,11
MF13:   MTAPE TP0,13    ;ERASE 3 INCH GAP
	MTAPE TP1,13
MF17:   MTAPE TP0,17    ;BACKSPACE FILE
	MTAPE TP1,17
MOUT:   OUT TP0,        ;WRITE TAPE
	OUT TP1,
MOUTPUT: OUTPUT TP0,    ;WRITE TAPE
	OUTPUT TP1,
MIN:    IN TP0,         ;READ TAPE
	IN TP1,
MINPUT: INPUT TP0,      ;READ TAPE
	INPUT TP1,
MRELS:  RELEASE TP0,    ;RELEASE TAPE
	RELEASE TP1,
MCLOS:: CLOSE TP0,      ;CLOSE TAPE
	CLOSE TP1,
MOPEN:  OPEN TP0,TAPOPN ;OPEN TAPE
	OPEN TP1,TAPOPN
MCHNL1: MOVEI R1,TP0    ;LOAD CHANNEL NO. INTO R1
	MOVEI R1,TP1
MUGETF: UGETF TP0,SENTAB ;GET DEVICE CHARACTERISTICS
	UGETF TP1,SENTAB
MGET1:  GETSTS TP0,R1   ;LOAD CHANNEL STATUS INTO R1
	GETSTS TP1,R1
MGET2:  GETSTS TP0,R2   ;LOAD CHANNEL STATUS INTO R2
	GETSTS TP1,R2
MSET1:  SETSTS TP0,(R1) ;SET CHANNEL STATUS FROM R1
	SETSTS TP1,(R1)
MSET2:  SETSTS TP0,(R2) ;SET CHANNEL STATUS FROM R2
	SETSTS TP1,(R2)
MSTPDE: STATZ TP0,200000        ;PHYSICAL DEVICE ERROR
	STATZ TP1,200000
MSTWRL: STATZ TP0,400000        ;WRITE LOCKED TAPE
	STATZ TP1,400000
MSTEOT: STATO TP0,IOTEND        ;TEST END OF TAPE
	STATO TP1,IOTEND
MSTERR: STATZ TP0,740000        ;TEST WRITE ERROR
	STATZ TP1,740000
MSTALL: STATO TP0,760000        ;TEST ALL ERROR BITS
	STATO TP1,760000
MSTOEND: STATO TP0,IOEND        ;END OF FILE
	STATO TP1,IOEND
MTWAIT: CALLI TP0,WAIT          ;WAIT FOR I/O TO STOP
	CALLI TP1,WAIT

STOROU::PUSHJ P,CRLS##          ;CLOSE NAMES FILE IF OPEN
	TRNE F,RANCMD
	ERROR [ASCIZ"COMMAND ERROR--RANGE NOT NEEDED"]
	TRNE F,TRTFG2
	ERROR [ASCIZ"COMMAND ERROR--TRANSLATE MEANINGLESS FOR STORE"]
	SKIPN STRPPN           ;SKIP IF CONTINUED FILE
	TLNE    F,INIFLG        ;SKIP IF TAPE NOT INITIALIZED
	JRST    .+2
	ERROR   [ASCIZ"TAPE NOT INITIALIZED."]
	MOVEM   P,STOSTP#       ;SAVE STACK POINTER
	TLZ F,DIRFLG+CUTFLG     ;NOT DIR OR CUT
	TLO     F,STOFLG        ;THIS IS A STORE AND NOT A RESTORE
	SKIPE   R1,STRPPN       ;SKIP IF NO STARTING PPN
	TYPE    [ASCIZ "REEL NUMBER: "]
	SETZM   SCOUNT          ;ZERO COUNT OF FILES STORED
	SETZM   FILCNT          ;TOTAL FILES THIS USER
	SETZM   TAPNUM          ;STARTING REEL IS ONE IF NO STARTING PPN
	JUMPE   R1,CONSTO       ;JUMP IF NO STARTING PPN
	PUSHJ   P,RDDNUM##      ;READ DECIMAL NUMBER
	CAIE    CT,TE           ;SKIP IF NUMBER TERMINATED BY A CR
	ERROR   [ASCIZ "INVALID REEL NUMBER"]
	SOJ     R0,             ;DECREMENT REEL NUMBER
	MOVEM   R0,TAPNUM#      ;INITIALIZE THE TAPE SEQ NUMBER
CONSTO: SETZM   USRPTR          ;MARK AS NOTHING IN SORT TABLE
	SETZM   USRGPT          ;INITIALIZE POINTER FOR GETTING ENTRIES
	MOVEI   R1,3            ;NO. OF RECORDS WHICH CAN BE WRITTEN
	MOVEM   R1,ERC          ;PAST EOT MARKER (EXCESS RECORD COUNT)
	MOVEM   R1,FILDIR       ;SET UP FILDIR FOR CKTY3
	SETZM   STO23           ;INITIALIZE STO23 PTR.
	MOVEI   R1,2
	MOVE    R1,CTABL2(R1)   ;FETCH COMMAND STATE
	HLRZM   R1,CSTATE       ;SAVE STATE
	CAMG    R1,[1,,777777]
	JRST    STAT01          ;STATE 0 OR 1
	HRRZM   R1,STO23        ;PTR. TO FIRST ITEM ON COMMAND LIST
	CAMG    R1,[2,,777777]
	JRST    STAT02          ;USERS
	LDB     R2,[XWD CNTFP+R1,0]
	CAIE    R2,CNTFT        ;LOOK FOR CR TERMINATOR ON PPN
	AOJA    R1,.-2
	HRRZ   U,(R1)          ;FETCH UUN
	PUSHJ   P,FINGAN        ;GET GAN FOR THIS UUN FROM LUD
	MOVEM   U,FILDI1
        INIT    FIL,BUFBIN
	SIXBIT  /DSK/
	XWD     0,0
	ERROR   [ASCIZ "DISC NOT AVAILABLE."]
CKTY3:  MOVEI   R3,11
	MOVEM   R3,TMP#         ;COUNT OF CHARS TO EXAMINE
	HRLZ    R3,2(R1)        ;FETCH EXTENSION (RH OF COMMAND WD)
	MOVS    R2,1(R1)        ;FETCH FILENAME BACKWARDS
	CAIN    R2,(SIXBIT/ALL/)
	JRST CKTY3C             ;LIST ENDS WITH "ALL"
	MOVS    R2,R2           ;FILENAME FORWARDS
	MOVEM   R2,FILDI2
	MOVEM   R3,FILDI3
CKTY3B: XOR     R2,[SIXBIT /#/]
	TLNN    R2,770000
	JRST    CKTY3A          ;BYPASS FILE WITH WILD CARD
	XOR     R2,[BYTE (6)34] ;XOR OF "#" AND "?"
	TLNN    R2,770000
	JRST    CKTY3A          ;FOUND QM
	XOR     R2,[BYTE (6)25] ;XOR OF "?" AND "*"
	TLNN    R2,770000
	JRST    CKTY3A          ;FOUND ASTERISK
	LSHC    R2,6
	SOSE    TMP
	JRST    CKTY3B
	LOOKUP  FIL,FILDIR      ;TRY TO FIND FILE
	  JRST	ER$NSF		; No such File message		[15.14]
	CLOSE   FIL,DNC
	JRST    CKTY3A          ;VALIDATE NEXT FILE
ER$NSF:	ERT [XWD[FILDI1],[ASCIZ"$NO SUCH FILE: _J$"]]	; Label	[15.14]
	RELEASE FIL,
	JRST    CLDSP
CKTY3A: AOS     R1
	LDB     R2,[XWD CNTFP+R1,1]
	CAIE    R2,CNTFT        ;CHECK FOR TERMINATOR
	AOJA    R1,CKTY3        ;MORE TO EXAMINE
CKTY3C: RELEASE FIL,
STAT01:
STAT02: TLZ F,PRPFLG    ;SAVESET HEADER NOT YET CREATED

MORE1:  PUSHJ   P,MFD2          ;GET ENTRY FROM MFD - SKIP IF NOT DONE
	JRST    MORE4           ;DONE WITH SAVE SET
MORE2:  PUSHJ   P,UFD2          ;GET ENTRY FROM UFD - SKIP IF NOT DONE
	JRST    MORE1           ;DONE WITH THIS UFD
	SKIPN STRBLK    ;DON'T ZERO FOR CONTINUED FILE
	SETZM CKSUM
	PUSHJ   P,DIRBLT        ;BLT DIRECTORY INTO TAPE BUFFER
MORE3:  SOSLE   FILHD2          ;GET A WORD FROM USER FILE
	JRST    .+3             ;NOT OUT OF WORDS
	PUSHJ   P,FILIN         ;INPUT A BUFFER - SKIP IF NOT END OF FILE
	JRST    MORE2           ;DONE WITH THIS FILE SO GET NEXT
	SOSG    TAPHD2          ;STASH IT AWAY ON TAPE
	PUSHJ   P,TAPOUT
	ILDB    R1,FILHD1       ;GET NEXT WORD FROM DISC FILE
	IDPB    R1,TAPHD1       ;PUT NEXT WORD IN TAPE BUFFER
	MOVE CKSUM
	ROT R0,7
	XOR R0,R1
	ADDI R0,1
	MOVEM CKSUM
	JRST    MORE3           ;CONTINUE FILLING BUFFER
MORE4:  TLNE    F,RPTFLG        ;TEST REPEAT FLAG
	SOSG    RPTCNT          ;DECREMENT COUNT IF SET
	JRST    CDISP##         ;REALLY DONE
	SETZM   STRPPN
	SETZM   STRFIL
	SETZM   STRBLK
	SETZM   CURPPN
	SETZM   FILCNT
	SETZM   TOTCNT
	JRST    STOROU          ;HAVE ANOTHER GO AT IT


TMPUSR: BLOCK   2               ;USER NAME OF USER JUST READ FROM MFD
TMPPPN: BLOCK   1               ;PPN OF USER JUST READ FROM MFD

USRSC== 100                     ;NUMBER OF USERS TO SORT AT A TIME

USRGPT: 0                       ;POINTER USED TO GET ENTRIES FROM TABLE
USRPTR: 0                       ;POINTER TO VARIABLE END OF SORT TABLE
USRSRS: 0                       ;STARTING RANGE FOR PLACING NEW USER
USRSRE: 0                       ;ENDING RANGE FOR PLACING NEW USER

	BLOCK   3               ;EXTRA OVERFLOW ENTRY - THROWN AWAY
USROVF: BLOCK   3               ;FIRST USER OVERFLOWED FROM TABLE
	                        ;USRTAB MUST FOLLOW USROVF
USRTAB: BLOCK   3*USRSC         ;USER SORT TABLE
USRTBE: BLOCK   3               ;END OF USER SORT TABLE

CMPLP:  MOVE    R1,USRGPT       ;POINTER TO NEXT ENTRY
	CAMLE   R1,USRPTR       ;SKIP IF NO ENTRIES LEFT
	JRST    CPOPJ1          ;SUCESS RETURN IF ENTRIES LEFT
	MOVE    R0,STRPPN       ;GET PPN OF STARTING USER
	SKIPE   USRPTR          ;SKIP IF FIRST TIME THROUGH CMPLP
	JUMPE   R0,CPOPJ        ;FAIL RETURN IF DONE
	MOVEI   R1,USRTBE       ;ADDR OF END OF TABLE
	MOVEM   R1,USRGPT       ;SAVE POINTER FOR GETTING ENTRIES
	MOVEM   R1,USRPTR       ;SAVE POINTER TO VARIABLE END OF TABLE
	SETZ    R1,             ;ZERO NAME IN CASE IT'S 0,0
	JUMPE   R0,CMPLP6       ;JUMP IF NO STARTING USER
	PUSHJ   P,PPNUSR        ;CONVERT PPN TO USER NAME
	ERT [XWD [STRPPN
CLDSP],[ASCIZ "CANNOT CONVERT STARTING PPN _K._E"]]
	PUSHJ   P,SHFTUN        ;FIX USER NAME FOR COMPARING WITH OTHERS
CMPLP6: MOVEM   R0,STRUSR       ;SAVE 1ST HALF OF USER NAME
	MOVEM   R1,STRUSR+1     ;SAVE 2ND HALF OF USER NAME
	SETZM   USROVF+2        ;SET DEFAULT PPN TO ZERO
	MOVE    R1,[XWD 377777,-1];LARGEST POSSIBLE NUMBER
	MOVEM   R1,USROVF       ;SET NAMES TO LARGEST POSSIBLE VALUE
	MOVEM   R1,USROVF+1     ;SET NAMES TO LARGEST POSSIBLE VALUE
	HRLZI   R1,USROVF       ;ADDR OF START OF SORT TABLE
	HRRI    R1,USROVF+3     ;SHIFT ALL WORDS BY THREE
	BLT     R1,USRTBE+2     ;ZERO THE SORT TABLE
	PUSHJ   P,OPNMFD        ;OPEN THE MFD
	JRST    CMPLP3          ;START SORTING
CMPLP2: MOVE    R1,USRPTR       ;ADDR OF VARIABLE END OF SEARCH TABLE
	HRLS    R1              ;ADDR IN BOTH HALVES FOR BLT
	SUBI    R1,3            ;SHIFT EVERYTHING BY THREE WORDS
	MOVE    R2,USRSRS       ;LAST ENTRY TO BE MOVED
	BLT     R1,-1(R2)       ;MAKE ROOM FOR NEW ENTRY
	HRLI    R1,TMPUSR       ;ADDRESS OF NEW ENTRY
	HRRI    R1,(R2)         ;ADDR OF SLOT FOR NEW ENTRY
	BLT     R1,2(R2)        ;PUT NEW ENTRY INTO THE TABLE
	MOVE    R1,USRPTR       ;ADDRESS OF VARIABLE END OF TABLE
	CAILE   R1,USROVF       ;SKIP IF TABLE IS FULL
	SUBI    R1,3            ;ADD ONE ENTRY TO TABLE
	MOVEM   R1,USRPTR       ;SAVE NEW END OF TABLE POINTER
CMPLP3: MOVE    R1,USRPTR       ;POINTER TO VARIABLE END OF SORT TABLE
	MOVEM   R1,USRSRS       ;STARTING RANGE FOR PLACING NEW USER
	MOVEI   R1,USRTBE       ;FIXED END OF SORT TABLE
	MOVEM   R1,USRSRE       ;ENDING RANGE FOR PLACING NEW USER
	PUSHJ   P,GMFD          ;GET NEXT ENTRY
	JRST    CMPLP4          ;RETURN FROM CMPLP IF STRPPN FOUND
	MOVEI   R1,TMPUSR       ;ADDR OF NAME JUST READ
	MOVEI   R2,USROVF       ;ADDR OF OVERFLOWED NAME
	PUSHJ   P,USRCMP        ;SKIP IF TMPUSR NOT GREATER
	JRST    CMPLP3          ;GET NEXT ENTRY CAUSE THIS WOULD OVERFLOW
CMPLP1: MOVE    R1,USRSRE       ;ENDING RANGE FOR PLACING NEW USER
	SUB     R1,USRSRS       ;FIND POSSIBLE RANGE FOR NEW USER
	JUMPE   R1,CMPLP2       ;JUMP IF PLACE HAS BEEN FOUND
	IDIVI   R1,6            ;3 WRDS/ENTRY AND 2 FOR BINARY SEARCH
	IMULI   R1,3            ;3 WORDS/ENTRY
	ADD     R1,USRSRS       ;STARTING RANGE FOR NEW USER
	SKIPA   R2,[TMPUSR]     ;ADDR OF USER NAME JUST READ
CMPLP5: ADDI    R1,3            ;BUMP R1 IF NO PROGRESS BEING MADE
	MOVEI   R3,USRSRE       ;ASSUME END RANGE MUST BE CHANGED
	PUSHJ   P,USRCMP        ;SKIP IF TMPUSR GREATER
	MOVEI   R3,USRSRS       ;MUST CHANGE STARTING RANGE
	CAIN    R3,USRSRE       ;SKIP IF NOT CHANGING END OF RANGE
	SUBI    R1,3            ;WE CAN MOVE IT UP BY ONE ENTRY
	CAMN    R1,(R3)         ;SKIP IF PROGRESS STILL BEING MADE
	JRST    CMPLP5          ;NO PROGRESS SO TRY ANOTHER ADDR
	MOVEM   R1,(R3)         ;SET NEW USRSRS OR USRSRE
	JRST    CMPLP1          ;NEXT ITERATION OF SEARCH
CMPLP4: MOVE    R1,USRTBE+2     ;GET FIRST PPN TO BE STORED
	SKIPN   STRPPN          ;SKIP IF LOOKING FOR A STARTING PPN
	SETZ    R1,             ;FORCE STARTING PPN'S TO BE EQUAL
	CAME    R1,STRPPN       ;SKIP IF STARTING PPN FOUND
	ERT [XWD [STRPPN
CLDSP],[ASCIZ "CANNOT FIND STARTING USER _A._E"]]
	MOVE    R1,USROVF+2     ;GET FIRST OVERFLOW FROM TABLE
	MOVEM   R1,STRPPN       ;SET NEW STARTING PPN
	MOVE    R1,USRPTR       ;POINTER TO END OF TABLE
	CAIG    R1,USRPTR       ;SKIP IF NO OVERFLOW
	MOVEI   R1,USRTAB       ;PUT IT BACK IN RANGE
	MOVEM   R1,USRPTR       ;PUT BACK THE END OF TABLE POINTER
	JRST    CPOPJ1          ;SKIP RETURN FROM CMPLP

USRCMP: MOVE    R0,(R1)         ;GET NAME FROM TABLE
	CAMN    R0,(R2)         ;SKIP IF NOT EQUAL TO NAME READ IN
	JRST    .+4             ;EQUAL SO COMPARE SECOND HALF
	CAMG    R0,(R2)         ;SKIP IF NAME IN TABLE GREATER
	AOS     (P)             ;SKIP RETURN
	POPJ    P,              ;RETURN
	MOVE    R0,1(R1)        ;GET 2ND HALF OF NAME FROM TABLE
	CAMG    R0,1(R2)        ;SKIP IF GREATER THAN NAME READ IN
	AOS     (P)             ;SKIP RETURN
	POPJ    P,              ;RETURN SKIPPING IF R1 .LE. R2

OPNMFD: MOVEI   R1,MFDHED
	MOVEM   R1,IOBUF
	OPEN    MFD,MFDSPK      ;WANT TO READ MFD FOR THIS STR
	ERROR   [ASCIZ "UNABLE TO INIT DEVICE DSK."]
	MOVEI   R1,MFDBUF       ;SET UP BUFFERS
	MOVEM   R1,JOBFF##      ;TELL SYSTEM WHERE TO PUT THE BUFFERS
	INBUF   MFD,MFDN
	MOVE    R1,SYSPP        ;LOOK FOR MFD
	MOVEM   R1,MFDDI3       ;IN THE MFD
	MOVEM   R1,MFDDIR
	MOVSI   R1,(SIXBIT /UFD/)
	MOVEM   R1,MFDDI1
	LOOKUP  MFD,MFDDIR      ;(OLD STYLE LOOKUP)
	ERROR   [ASCIZ "UNABLE TO DO LOOKUP ON MFD."]
	SETZM   MFDMON          ;READ SEQUENTIALLY THROUGH MFD
	POPJ    P,              ;RETURN FROM OPNMFD

;READ MFD

GMFD:   SKIPE   R1,STO23        ;FETCH STO23 AND CK IF NONZERO
	JRST    GMFD2           ;SPEED-UP CODE FOR COMMAND STATES 2-3
	MOVE R1,[33,,MFD]
	CHANIO R1,MFDARG
	JRST MFDEND             ;MUST HAVE REACHED END OF MFD
	MOVE U,MFDTAB           ;SAVE PPN IN REGISTER U
	HLRZ W,MFDTAB+1         ;SAVE EXTENSION IN RH OF W FOR EASY COMPARE
GMFD1:  CAIE    W,(SIXBIT /UFD/);SKIP IF THIS IS A UFD
	JRST    GMFD            ;LOOK FOR NEXT UFD
	JUMPLE	U,GMFD		;Ignore negative PPNs		[15.14]
	MOVEM   U,TMPPPN        ;SAVE PPN
	MOVE    R0,TMPPPN       ;GET PPN FOR COVERSION TO USER NAME
	PUSHJ   P,PPNUSR        ;CONVERT PPN TO USER NAME AND SKIP IF OK
	JRST    GMFD            ;IGNORE STRAY UFD'S
	PUSHJ   P,SHFTUN        ;FIX USER NAME FOR COMPARING WITH OTHERS
	MOVEM   R0,TMPUSR       ;SAVE 1ST HALF OF USER NAME
	MOVEM   R1,TMPUSR+1     ;SAVE 2ND HALF OF USER NAME
	MOVEI   R1,STRUSR       ;ADDR OF NAME OF STARTING USER
	MOVEI   R2,TMPUSR       ;USER JUST READ
	SKIPN   STRPPN          ;SKIP IF LOOKING FOR STARTING PPN
	JRST    .+3             ;DON'T CHECK FOR PAST STARTING PPN
	PUSHJ   P,USRCMP        ;SKIP IF STARTING USER OR PAST IT
	JRST    GMFD            ;IGNORE THIS USER
	PUSHJ   P,CKNPPN        ;SKIP IF THIS USER SHOULD BE DUMPED
	JRST    GMFD            ;NOT THIS USER, TRY THE NEXT
	JRST    CPOPJ1          ;SKIP RETURN FROM GMFD
GMFD2:  TLNN    R1,400000       ;TEST LAST ITEM FLAG
	JRST GMFD3              ;MORE TO DO
	CLOSE MFD,DNC
	RELEASE MFD,
	POPJ P,
GMFD3:  MOVEI   W,(SIXBIT/UFD/)
	HRRZ U,(R1)
	PUSHJ   P,FINGAN
	MOVE R2,CSTATE
	CAIE R2,3
	JRST GMFD6              ;BETTER BE STATE 2 (USERS)
	LDB R2,[XWD CNTFP+R1,0] ;TERMINATION BETTER BE CRCH
	CAIE R2,CNTFT
GMFD4:  ERROR [ASCIZ"PROG. ERROR-GMFD4"]
GMFD5:  TLO     R1,400000       ;NO MORE PPNS TO GET
	MOVEM R1,STO23          ;SET LAST ITEM FLAG IN STO23
	JRST GMFD1
GMFD6:  CAIE R2,2
	ERROR [ASCIZ"PROG. ERROR-GMFD6"]
	LDB R2,[XWD CNTFP+R1,0] ;LOOKING FOR CRCH TO END LIST OF PPNS
	CAIN R2,CNTFT
	JRST GMFD5              ;LAST PPN IN LIST
	AOS     STO23           ;ADVANCE STO23 TO NEXT ITEM
	JRST    GMFD1           ;AND RETURN

SHFTUN: SETZ    R2,             ;ASSUME SHIFT OF ZERO
	CAMN    R0,[SIXBIT /UFD/] ;SKIP IF NOT USER 1,1 (UFD)
	HRRZI   R2,-14          ;PUT (UFD) ON THE TAPE FIRST
	CAMN    R0,[SIXBIT /SYS/] ;SKIP IS NOT USER 1,4 (SYS)
	HRRZI   R2,-6           ;PUT (SYS) ON THE TAPE SECOND
	LSHC    R0,(R2)         ;SHIFT IF (UFD) OR (SYS)
	TLC     R0,400000       ;COMPLEMENT SIGN BIT FOR COMPARE
	TLC     R1,400000       ;COMPLEMENT SIGN BIT FOR COMPARE
	POPJ    P,              ;RETURN FROM SHFTUN

MFD2:   PUSHJ   P,CMPLP         ;GET NEXT BATCH OF ENTRIES
	JRST    STODON          ;DONE WITH THE STORE
	MOVE    R1,USRGPT       ;GET POINTER TO NEXT ENTRY
	MOVE    U,2(R1)         ;GET NEXT PPN
	SUBI    R1,3            ;POINT TO NEXT ENTRY
	MOVEM   R1,USRGPT       ;SAVE POINTER TO NEXT ENTRY
	HRRZI   W,(SIXBIT /UFD/);THE EXTENSION "UFD"
	INIT    UFD,BUFBIN      ;IS IT AVAILABLE
	SIXBIT  /DSK/
	XWD     0,UFDHED        ;INPUT ONLY
	ERROR   [ASCIZ "UNABLE TO INIT DSK"]
	MOVEI   R1,UFDBUF       ;SETUP BUFFERING
	MOVEM   R1,JOBFF
	INBUF   UFD,UFDN
	MOVE    R1,SYSPP        ;LOOK FOR UFD
	MOVEM   R1,UFDDI1       ;IN THE UFD
	MOVEI   R1,XLOOKN       ;EXT. LOOKUP
	MOVEM   R1,UFDDIR
	MOVEM   U,UFDDI2        ;PPN FOR THIS USER
	HRLZM   W,UFDDI3        ;THE EXTENSION "UFD"
	LOOKUP  UFD,UFDDIR      ;IS IT STILL THERE
	ERB [XWD [UFDDI2
MFD2],[ASCIZ "$UNABLE TO DO LOOKUP ON UFD FOR USER _A.  CONTINUING WITH NEXT USER.$_E"]]
	SKIPN	ALLFSW		;IS THIS AN "ALL FILES"?
	JRST	MFD3		;NO - LOOK AT ALL DIRECTORIES.
	MOVE	R1,URBSTS	;IF "NO FAILSAFE" BIT IS ON,
	TRNE	R1,.RPNFS	;IGNORE THIS WHOLE DIRECTORY.
	ERB	[XWD [UFDDI2
MFD2],[ASCIZ "$IGNORING FILES FOR USER _A.  CONTINUING WITH NEXT USER.$_E"]]
MFD3:	TLZ     F,FILFND        ;NO FILES FOUND YET FOR THIS USER
; PUT USER NAME INTO FILE HEADER RECORDS
	MOVE R0,U
	PUSHJ P,PPNUSR
	ERB [XWD[UFDDI2
MFD2],[ASCIZ"$UNABLE TO FIND USER _K IN DUL.  CONTINUING WITH NEXT USER.$_E"]]
	MOVEM TPUN1
	MOVEM R1,TPUN2
	SETZM   UFDMON          ;READ SEQUENTIALLY THROUGH UFD
	JRST    CPOPJ1          ;WE READ SOMETHING SO SKIP RET FROM MFD2

MFDEND: STATZ   MFD,IOBAD       ;SKIP IF NO ERROR (END OF BUFFER)
	ERROR   [ASCIZ "ERROR IN READING MFD"];*
	CLOSE   MFD,DNC
	RELEASE MFD,
	POPJ    P,              ;FAIL RETURN FROM GMFD

STODON:	SETZM	ALLFSW		;ZERO OUT "ALL FILES" SWITCH
	TLNN 	F,PRPFLG   	;DID WE DO ANYTHING
	ERROR [ASCIZ "NOTHING WRITTEN ON TAPE"]
	SKIPE   STRPPN          ;SKIP IF NOT LOOKING FOR STARTING PPN
	ERROR   [ASCIZ "CANNOT FIND STARTING USER."]
	XCT MF0(UNIT)
	XCT MF7(UNIT)           ;BACK SPACE OVER EOF
	XCT MF0(UNIT)           ;WAIT FOR OPERATION TO COMPLETE
	PUSHJ   P,TRLOUT        ;WRITE TRAILER RECORD
	TRO F,EOTFLG            ;POSITIONED AT LOGICAL EOT
	ERT [XWD[CURPOS],[ASCIZ"LAST FILE AT POS _H$"]]
	ERB [XWD[SCOUNT],[ASCIZ"STORE COMPLETE, _C FILES.$$"]]
	SETZM SCOUNT
	POPJ    P,              ;FAIL RETURN FROM GMFD

;READ UFD

UFD2:   SETZM   BLKCNT#         ;SET BLOCK COUNT FOR FILE TO ZERO
	SETZM   STRER#          ;ZERO ERROR CODE FOR STARTING FILE
	TLZ     F,EOFFND        ;END OF FILE NOT YET FOUND
	TLZE    F,RPTFIL        ;ARE WE REPEATING LAST FILE
	JRST  UFD2A     ;YES
	MOVE R1,[33,,UFD]
	CHANIO R1,UFDARG
	JRST UFDEND     ;MUST HAVE REACHED END OF UFD
	MOVE U,UFDTAB   ;FILENAME IN U
	HLRZ W,UFDTAB+1 ;EXT IN RH OF W FOR EZ COMPARE
	MOVE R1,UFDCRE  ;GET CREATION DATE
	MOVEM R1,CRTION ;SAVE FOR CKNCRE
	CAIN    W,(SIXBIT /TMP/);IGNORE TEMP FILES
	JRST    UFD2            ;GET NEXT ENTRY FROM UFD
	MOVE    R1,STREXT       ;HAS EXT IN LEFT HALF
	HLRZM   R1,STRJNK#      ;MOVE TO RH FOR COMPARE
	MOVE    R1,STRFIL       ;ZERO IF NOT LOOKING FOR STARTING FILE
	CAMN    W,STRJNK        ;SKIP IF NOT STARTING EXTENSION
	CAME    U,STRFIL        ;SKIP IF THIS IS THE STARTING FILE
	JUMPN   R1,UFD2         ;JUMP IF STARTING FILE NOT YET FOUND
	SETZM   STRFIL          ;MARK STARTING FILE AS FOUND
	PUSHJ   P,CKNFIL        ;SKIP IF THIS FILE SHOULD BE STORED
	JRST    UFD3            ;NO - TRY ANOTHER
	PUSHJ   P,CKNCRE        ;SKIP IF CREATION DATE OK TO DUMP
	JRST    UFD4            ;NO - TRY ANOTHER
	PUSHJ   P,CKNCHG        ;SKIP IF CHANGED OR IF WE DON'T CARE
	JRST    UFD5            ;NOT CHANGED
	MOVEI   R1,XLOOKN       ;EXT. LOOKUP
	MOVEM   R1,FILDIR
	MOVEM   U,FILDI2        ;FILE NAME
	HRLZM   W,FILDI3        ;EXTENSION
	MOVE    R1,UFDDI2       ;PROJ-PROG NUMBER
	MOVEM   R1,FILDI1
UFD2A:  INIT    FIL,BUFBIN      ;SET TO GET FILE
	SIXBIT  /DSK/
	XWD     0,FILHED        ;INPUT ONLY
	ERROR   [ASCIZ "UNABLE TO INIT DSK."]
	MOVEI   R1,FILBUF       ;SETUP BUFFERS
	MOVEM   R1,JOBFF
	INBUF   FIL,FILN
	LOOKUP  FIL,FILDIR      ;IS IT THERE?
	ERB [XWD [FILDI1
UFD6],[ASCIZ "$UNABLE TO DO LOOKUP ON FILE _J. CONTINUING WITH NEXT FILE.$_E"]]
	MOVE    R1,FRBSTS       ;GET FILE STATUS
	TRNE    R1,.RPNFS	;DO-NOT-SAVE BIT?		[15.14]
	ERB [XWD[FILDI1
UFD7],[ASCIZ "$FILE NOT DUMPED _J, MARKED DO NOT DUMP.$_E"]] ; Tell! [15.14]
	MOVE    R1,FRBSTS       ;GET FILE STATUS
	TRNE    R1,.RPBAD	;DO NOT SAVE IF BAD BIT ON?	[15.14]
	ERB [XWD[FILDI1
UFD7],[ASCIZ "$FILE NOT DUMPED _J, MARKED BAD ON DSK.$_E"]] ; Tell! [15.14]
; WRITE SAVESET HEADER IF NECESSARY.
	TLNE F,PRPFLG
	  JRST	UFD$L1		; Replace .+4 with label UGH!	[15.14]
	PUSHJ P,WPREP           ;SET UP SAVESET HEADER
	ERB [XWD[TAPNUM
DAYTIM],[ASCIZ"$$TAPE NUMBER _C FOR _L$"]]
	PUSHJ P,LABBLT          ;WRITE OUT HEADER
UFD$L1:	Move R1,Monver		;Get monitor version number	[16.2]
	Caml R1,[DmpMon]	;  and compare for P034/K16	[16.2]
	 Jrst UFD$L2		; If so, don't do this cruft	[16.2]
	Move R1,[FILDIR,,F$LKB0];Get a copy of the lookup block	[15.14]
	Blt R1,F$LKB0+XLOOKN	;  to compare against later.	[15.14]
UFD$L2:	TLO F,FILFND+PRPFLG     ;FILE FOUND, AND SAVESET HEADER WRITTEN
	PUSHJ   P,TRCL          ;TRANSFER CURPPN-FIL-EXT TO LST...
	AOS CURPOS              ;ADVANCE CURRENT POSITION
	SKIPN FILCNT		;[16.4] First file for this user?
	ERO [XWD[FILDI1
CURPOS],[ASCIZ"_Y START POS _H - "]]	;[16.4]
; UPDATE TEMPORARY TAPE PARAMETERS FOR FILE HDR BLOCK
	HRRZ R1,CURPOS
	CAILE R1,RANSIZ*44-1
	ERROR [ASCIZ"EXCEEDED PROG LIMIT FOR NO. OF FILES ON TAPE"]
	HRL  R1,TAPNUM          ;REEL NO. IN SAVE SET
	MOVEM R1,TPPOS
	HRLZM   W,CUREXT        ;SAVE NEW EXTENSION
	MOVEM   U,CURFIL        ;SAVE NEW FILE NAME
	MOVE    R1,UFDDI2       ;GET NEW PPN
	MOVEM   R1,CURPPN       ;SAVE NEW PPN
	MOVEI R1,VERSION
	MOVEM R1,CURVER
	MOVE TPUN1
	MOVEM CURUN1
	MOVE TPUN2
	MOVEM CURUN2
	JRST    CPOPJ1          ;SKIP RETURN FROM UFD2
UFD3:   AOS STRER ;ERCODE=34
UFD4:   AOS STRER ;ERCODE=33
UFD5:   AOS STRER ;ERCODE=32
UFD6:   AOS STRER ;ERCODE=31
UFD7:   SKIPN STRBLK ;ERCODE=30
	JRST UFD2 ;WE WEREN'T LOOKING FOR STARTING FILE
	ERT [XWD 0,[ASCIZ"$UNABLE TO ACCESS STARTING FILE--"]]
	SETZM STRBLK
	MOVE STRER
	ADDI 30
	MOVEM ERCODE
	PUSHJ P,WHY
	ERROR [ASCIZ"TRY MANUAL RESTART"]

UFDEND: STATO   UFD,IOBAD       ;END OF FILE?
	JRST    ENDUFD          ;YES, GO DO WRAPUP
	STATZ   UFD,BTL         ;SKIP IF BLOCK NOT TOO LARGE
	ERB [XWD 0,[ASCIZ "BLOCK TOO LARGE$"]]
	ERB [XWD[UFDDI2],[ASCIZ"ERROR READING UFD FOR _A$"]]
	POPJ P,                 ;UFD2 FAIL RETURN
ENDUFD: SKIPE   STRFIL          ;SKIP IF NOT LOOKING FOR STARTING FILE
	ERT [XWD [STRFIL
CLDSP##],[ASCIZ "CANNOT FIND STARTING FILE _B._E"]]
	TLZN    F,FILFND        ;ANY FILES FOR THIS USER?
	JRST    NULUFD          ;NOPE
	PUSHJ   P,CLSUSR        ;WRITE EOFS ON TAPE
	PUSHJ   P,TRCL          ;FINISH UP THE LAST FILE
	PUSHJ   P,SPRTU         ;PRINT USER TOTALS IF WE SHOULD
	SKIPA
NULUFD: PUSHJ   P,NULTAP        ;RESET BUFFER
	CLOSE   UFD,DNC
	RELEASE UFD,            ;GIVE UP UFD DDB
	POPJ P,         ;FAIL RETURN FROM UFD2

;DISK FILE INPUT

FILIN:  TLNN F,RPTFIL
	JRST .+3
	SETZM OLDBLK	; DONE SO RESTART WORKS RIGHT
	JRST NOTDMP
	CAIE W,(SIXBIT/UFD/)
	JRST FILIN0
	MOVE CURPPN
	CAMN SYSPP
	JRST FILIN1     ;PRETEND EOF ON UFD FILES
FILIN0: SKIPE   STRBLK          ;SKIP IF NO SPECIAL STARTING BLOCK
	PUSHJ   P,FSTWRD        ;FIX UP FIRST BLOCK OF FILE
	MOVE CKSUM
	MOVEM PCKSUM#           ;CHECKSUM OF LAST COMPLETE BLOCK
	AOS     BLKCNT          ;INCREMENT NUMBER OF BLOCKS READ
	IN      FIL,            ;GET NEXT BUFFER
	JRST    CPOPJ1          ;SUCCESSFUL - SKIP RETURN
	STATZ   FIL,IOBAD       ;SKIP IF NO ERROR
	ERB [XWD[CURPPN],[ASCIZ "$ERROR IN READING FILE: _J$"]]
FILIN1: SETZM   OLDBLK          ;FILE WILL NOT BE SPLIT OVER 3 TAPES NOW
	MOVEI   R1,1
	TLNE    F,RPTFLG
	CAMN    R1,RPTCNT
	SKIPN CHANGD    ;*CHANGE TO JRST NOTDMP IN PRELIMINARY RELEASES
	JRST NOTDMP             ;NOT TIME TO MARK FILES DUMPED
	MOVEI   R1,2            ;SECOND PART OF COMMAND
	MOVE    R1,CTABL2(R1)   ;GET SECOND PART OF COMMAND
	CAIN    R1,ALLLST       ;SKIP IF NOT THE WORD "ALL"
	MOVEI   R1,0            ;CHANGE ALL TO ZERO
	OR      R1,CREDAT       ;MERGE IN CREATION DATE TO CHECK
	JUMPN   R1,NOTDMP       ;DON'T MARK DUMPED EXCEPT FOR BACKUP (ALL CHANGED)
	HRLZI   R1,RCHGBT       ;GET THE RIB CHANGED BIT
	TDNE    R1,FRBNCA       ;SKIP IF NOT ALREADY MARKED AS DUMPED
	JRST    NOTDMP          ;DON'T BOTHER TO DO IT AGAIN
	Move	R1,Monver	; Get monitor version number	[16.2]
	Caml	R1,[DmpMon]	;  and compare with P034/K16	[16.2]
	  Jrst	FSTDMP		; Yes!!! Set the "dumped" bit	[16.2]
	Close	FIL,DNC		; No, Close No-Modify		[16.2]
	Move	R1,[FILDIR,,F$LKB1] ; Prepare to make a copy	[15.14]
	Lookup	FIL,FILDIR	; See if the file still there?	[15.14]
	  Jrst	ER$UMM		; No?? Warn OPER: Missing file	[15.14]
	Blt	R1,F$LKB1+XLOOKN; Copy! so we can compare it.	[15.14]
;	Enter	FIL,FILDIR	; Now Exclusive Access		[16.1]
;	  Jrst	ER$UME		; Can't?  Warn OPER: Enter fail	[16.1]
	Pushj	P,CMPLKB	; Now, Compare lookup blocks	[15.14]
	  Jrst	ER$UMN		; -- No Match, Warn OPER: New!	[15.14]
	Hrlzi	R1,RCHGBT	; Get the bit to set		[15.14]
	ORM     R1,FRBNCA       ;MARK FILE AS DUMPED
	RENAME  FIL,FILDIR      ;DO A RENAME ON THE FILE TO MARK IT DUMPED
ER$UME:	ERB [XWD[CURPPN],[ASCIZ "UNABLE TO MARK FILE _J AS DUMPED.$"]]
	  Jrst	NOTDMP		; Continue after message	[15.14]
ER$UMN:	ERB [XWD[CURPPN],[ASCIZ "NEW FILE _J NOT MARKED AS DUMPED.$"]]
	  Jrst	NOTDMP		; Continue after message	[15.14]
ER$UMM:	ERB [XWD[CURPPN],[ASCIZ "MISSING FILE _J NOT MARKED AS DUMPED.$"]]
	  Jrst	NOTDMP		; Continue after message	[15.14]
FSTDMP:	Close	Fil,DMP		; Set the "dumped" bit safely	[16.2]

NOTDMP:

; PUT CHECKSUM PAST LAST DATA WORD
FILL:   SOSG TAPHD2
	PUSHJ P,TAPOUT          ;WRITE FULL BUFFER
	MOVE R2,TPSZM3 ;TAPE RECORD SIZE-3    CALC. NO. WDS IN BUFFER
	SUB R2,TAPHD2
	MOVE CKSUM
	IDPB R0,TAPHD1          ;DEPOSIT CKSUM
	CAIG R2,4               ;LAST RECORD TO CONTAIN AT LEAST 5 WDS
	JRST FILL               ;STATISTICS HERE WOULD BE NICE
	TLO F,EOFFND            ;END OF FILE HAS BEEN FOUND
	SOS     TAPHD2          ;FIXUP SINCE TAPHD2 IS OFF BY
;                               ONE DUE TO MORE3:+4 LOGIC
	PUSHJ   P,TAPOUT        ;OUTPUT LAST BUFFER (USES EOFFND FLAG)
	CLOSE   FIL,DNC
	RELEASE FIL,            ;GIVE UP USER FILE
	AOS     FILCNT          ;INCR. TOT FILES DUMPED THIS USER
	AOS     SCOUNT          ;INCR. TOT FILES DUMPED
	MOVEI   R1,MSPTR##      ;GET STORE MODE
	LDB     R1,(R1)
	TRNE    R1,1            ;PRINT FILENAME IF DESIRED
	ERO [XWD[CURPOS
XWD 10,5
CURPPN],[ASCIZ"_N  _J$"]]
	POPJ    P,              ;FAIL RETURN FROM FILIN

FSTWRD: PUSH    P,R1            ;SAVE R1 ON STACK
	PUSH    P,R2            ;SAVE R2 ON STACK
	ERB [XWD[STRBLK
CURPPN],[ASCIZ "STARTING WITH BLOCK _C OF FILE _J.$"]]
	MOVE    R1,STRBLK       ;GET THE STARTING WORD
	MOVEM   R1,OLDBLK#      ;SAVE IN CASE FILE IS SPLIT TWICE
	Sos	Oldblk		; Decrement so that this works	[16.0]
	Move	R2,[.Chfsi,,FIL]; Set file input position to	[15.14]
	Chanio	R2,Strblk	;  start block.  USETI FIL,(R1)	[15.14]
	SETZM   STRBLK          ;RE-SET STARTING BLOCK TO ZERO	[15.14]
	POP     P,R2            ;RESTORE R2 FROM STACK
	POP     P,R1            ;RESTORE R1 FROM STACK
	POPJ    P,              ;RETURN FROM FSTWRD


CMPLKB:	Movei	R2,XLOOKN	; Lookup block length		[15.14]
CMPLKP:	Move	R1,F$LKB0(R2)	; Compare initial block		[15.14]
	Came	R1,F$LKB1(R2)	;   against current block	[15.14]
	  Popj	P,		; Mis-Match -- Error return	[15.14]
	Sojg	R2,CMPLKP	; Check all entries		[15.14]
	Aos	(P)		; Looks Ok			[15.14]
	Popj	P,		; So, Return!			[15.14]

;MAG TAPE OUTPUT

TAPOUT: MOVE R2,TPSZM4 ;TAPE RECORD SIZE-4    DATA WDS/BUFFER
	SUBB    R2,TAPHD2       ;COMPUTE WORDS USED
	JUMPE   R2,NULTAP       ;NONE USED, DONT OUTPUT
	HRRZ    R1,TAPHED       ;ADDR OF BUFFER CURRENTLY IN USE
	HRRM    R2,2(R1)        ;BUFFERED BINARY WORD COUNT FOR TITO
	AOS     R2
	HRRZM   R2,1(R1)        ;TOTAL DATA WORD COUNT FOR MONITOR
TAPOU1: XCT MOUT(UNIT)          ;WRITE ANOTHER RECORD
	JRST    TAPOU3           ;WRITE OK
	XCT MSTERR(UNIT)        ;CHECK ERROR BITS
	JRST    BADTAP          ;SOME KIND OF ERROR
TPROC:  XCT MSTEOT(UNIT)        ;PHYSICAL END OF TAPE
	JRST    TAPOU3          ;POST-RECORD CLEANUP
	TLNE    F,EOTFND        ;POST EOT
	JRST    TAPOU3           ;IGNORE EOT LOGIC
	TLZE    F,EOFFND        ;TEST FOR LAST BUFFER IN FILE
	JRST    ETNF            ;EOF--GET NEXT FILE
	SOSL    ERC             ;DECREMENT EXCESSIVE RECORD COUNT
	JRST    TAPOU3           ;KEEP WRITING PAST EOT INDICATOR
ETNF2:  PUSHJ   P,SETSTR        ;SET UP STARTING FILE PARAMETERS
	SKIPE   STRBLK          ;SKIP IF FILE NOT SPLIT
	JRST    SPLIT           ;FILE CONTINUED ON NEXT TAPE
	ERB [XWD[LSTPPN],[ASCIZ"THE LAST FILE ON THIS TAPE IS: _J$"]]
	ERB [XWD[CURPPN],[ASCIZ"THE FIRST FILE ON THE NEXT TAPE WILL BE: _J$"]]
SPLIT:  TLO     F,EOTFND        ;IGNORE EOT LOGIC HENCEFORTH
	JRST    ETBRET          ;SETUP NEXT RECORD (TRAILER)
ETNF1:  TLO     F,EOTFND        ;IGNORE EOT LOGIC
	PUSHJ   P,MFD2          ;GET NEXT USER
	JRST    CDISP           ;STORE COMPLETE--MFD2 WRITES TRAILER
ETNF:   PUSHJ   P,UFD2          ;GET NEXT FILE
	JRST    ETNF1           ;NO MORE FILES--UFD2 DOES CLSUSR
	SETZM   BLKCNT          ;FILE NOT SPLIT
	JRST    ETNF2           ;THERE WILL BE NO EOF BEFORE TRAILER
	                        ;SINCE LSTPPN=CURPPN
BADTAP: XCT MSTWRL(UNIT)        ;WRITE-LOCKED TAPE?
	  JRST	TAPNWR          ;NEED WRITE RING IN TAPE
	SKIPE	CURPPN
	ERB	[XWD[CURPPN],[ASCIZ"ERROR WRITING _J--"]]
	XCT	MSTPDE(UNIT)	;PHYSICAL DEVICE ERROR?
	  JRST	TAPPDE          ;YES
	ERB	[XWD 0,[ASCIZ"TAPE WRITE PARITY ERROR$"]]
	JRST	TAPCON

TAPPDE: ERB	[XWD 0,[ASCIZ "PHYSICAL DEVICE ERROR
THIS SECTION OF TAPE MAY BE HOPELESSLY UNREADABLE.$"]]
	JRST    TAPCON          ;ACCEPT CARRIAGE RETURN AND RETRY

TAPNWR: ERROR   [ASCIZ "TAPE NEEDS A WRITE RING. "]

TAPCON: SKIPE	CURPPN
	TLO	F,RPTFIL	;SET TO REPEAT SAME FILE AT BEGINNING
	XCT	MGET2(UNIT)	;CLEAR ERROR BITS FOR RETRY
	ANDCMI	R2,760000	;CLEAR THE BITS
	XCT	MSET2(UNIT)	;PUT STATUS BACK
	SKIPE	ASKFLG		;[16.5] ARE WE ASKING TO CONTINUE?
	  JRST	TPROC		;[16.5] NO, JUST CONTINUE
				;[16.5] YES, PRINT MESSAGE AND ASK
	ERT	[XWD [TPROC
		      ABORTA],[ASCIZ "CONTINUE? _F_G_E"]]

AGUFO:  SETZ	R2,		;ALL
	HLRZ	R2,U		;GANS
	PUSHJ	P,CKTR		;USERS
	PUSHJ	P,CKTR		;FILES

DEFINE  CNTF    (X) <
CNTF'X==:.-CNTTAB
	CNTF'X'R>

TRTF==:(POINT 1,0,3)            ;INDICATES THAT TAPE USER NAME
;       WILL BE FOUND IN TRANSLATION TABLE.  UUN AND LUD LOCATOR
;       IN COMMAND LIST ARE THOSE OF THE USER TO RECEIVE THE FILES.
SUCS==:(POINT 1,0,2)            ;SUCCESS MATCH BY CKNFIL
LUDLC==:(POINT 10,0,17)          ;POINTER FOR LUD LOCATOR
CNTFP==:(POINT 2,0,1)           ;POINTER USED TO GET THIS FIELD
CNTTAB: BLOCK   0               ;TABLE FOR CONTROL FIELD OF LIST
	CNTF    (C)             ;ITEM TERMINATED WITH A COMMA
	CNTF    (D)             ;ITEM TERMINATED WITH A DASH
	CNTF    (T)             ;ITEM TERMINATED WITH A CR
	CNTF    (N)             ;NOT

ALLLST::BYTE(2)CNTFT            ;DUMMY LIST FOR ALL FILES

CKTR:   LDB R2,[XWD TRTF+R1,0]  ;CHECK TRANSLATE BIT
	CAIE R2,1               ;ARE WE TRANSLATING
	JRST CKTR2              ;NO
	MOVE R2,R0              ;NOTE THAT WE CANNOT GET HERE WITH OLD
;                               TAPE FILES.  FHDR7 WILL NOT ALLOW US TO
;                               PROCESS TEX FILES WHILE TRANSLATE IS IN EFFECT.
	MOVE R0,1(R2)
	CAME CURUN1
	JRST CKTR1
	MOVE R0,2(R2)
	CAME CURUN2
	JRST CKTR1
	MOVE R0,(R2)
	MOVEM PPN
	MOVE R0,R2
	POPJ P,
CKTR1:  MOVN R0,R2
	POPJ P,
CKTR2:  HRRZ R2,U
	POPJ P,


CKNCHR: XOR     R2,[SIXBIT /#/] ;CHECK FOR POUND SIGN CHAR
	TLNN    R2,770000       ;SKIP IF IT'S NOT A POUND SIGN
	TLZ     R3,770000       ;THAT CHAR OF FILE MATCHES
	XOR     R2,[BYTE (6)34] ;EXCLUSIVE OR OF QUESTION AND POUND
	TLZN    R2,770000       ;SKIP IF IT'S NOT A QUESTION MARK
	TLZ     R3,770000       ;MAKE THAT CHAR OF FILE MATCH
	TLZE    R3,770000       ;SKIP IF CHARS MATCH
	POPJ    P,              ;FAIL RETURN
	LSHC    R2,6            ;SHIFT TO NEXT CHAR
	JUMPN   R3,CKNCHR       ;LOOP IF OTHER CHARS DON'T MATCH
	JRST    CPOPJ1          ;SUCCESS RETURN

CKNCRE: HLRZ R1,CRTION  ;CHECK THE DATE BITS
	CAMLE   R1,CREDAT       ;SKIP IF DATE OF FILE NOT GREATER
	JRST    CPOPJ1          ;SKIP RETURN
	CAME    R1,CREDAT       ;SKIP IF DATES ARE EQUAL
	POPJ    P,              ;FAIL RETURN
	HRRZ R1,CRTION  ;GET THE TIME BITS
	CAML    R1,CRETIM       ;SKIP IF FILE TIME IS TOO OLD
	JRST    CPOPJ1          ;SKIP RETURN
	POPJ    P,              ;FAIL RETURN

CKNCHG: SKIPN   CHANGD          ;SKIP IF WE'RE CHECKING FOR CHANGED FILES
	JRST    CPOPJ1          ;SUCCESS RETURN FROM CKNCHG IF NOT CHECKING
	MOVE    R1,UFDBTS       ;GET STATUS BITS FROM UFD
	TRNN    R1,UCHGBT       ;SKIP IF FILE NOT CHANGED
	AOS     (P)             ;CHANGED SO SKIP RET AND DUMP IT
	POPJ    P,              ;RETURN FROM CKNCHG

CKNFIL: SETOM CKNFP     ;NOT STATE 3 OR ALL FILES
	MOVEI   R1,2            ;SECOND PART OF COMMAND
	HLRZ    R2,CTABL2(R1)   ;GET STATE FOR SECOND PART OF COMMAND
	CAIE    R2,FF2##        ;SKIP IF CHECKING FOR INDIVIDUAL FILES
	JRST    CPOPJ1          ;SUCCESS RETURN - ALL FILES ARE OK
	HRRZ    R1,CTABL2(R1)   ;ADDRESS OF LIST
	LDB     R2,[XWD CNTFP+R1,0]
	CAIE    R2,CNTFT        ;SKIP IF THIS IS END OF USER NAME ETC
	AOJA    R1,.-2          ;LOOK AT THE NEXT ENTRY
CKNNX1: HRRZ    R2,2(R1)        ;GET THE EXTENSION
	MOVS    R3,1(R1)        ;GET FILE NAME BACKWARDS
	CAIN    R3,(SIXBIT /ALL/)
	JUMPE   R2,CPOPJ1       ;SUCCESS RETURN IF FILE "ALL"
	CAIN    R3,(SIXBIT /*/) ;SKIP IF NOT WILD CARD
	MOVS    R3,U            ;MAKE THE FILE NAMES MATCH
	MOVS    R3,R3           ;PUT THE FILE NAME BACK THE WAY IT SHOULD BE
	MOVE    R2,R3           ;ALSO PUT FILE NAME IN R2
	XOR     R3,U            ;EXCLUSIVE OR THE NAMES TO FIND DIFF
	PUSHJ   P,CKNCHR        ;SKIP IF NAMES MATCH
	AOJA    R1,CKNNXT       ;DON'T MATCH SO TRY THE NEXT
	HRRZ    R3,2(R1)        ;EXTENSION IN RH FOR EASY COMPARE
	CAIN    R3,(SIXBIT /*/) ;SKIP IF IT'S NOT A WILD CARD
	HRRZ    R3,W            ;MAKE THE EXTENSIONS MATCH
	MOVE    R2,R3           ;ALSO PUT EXTENSION IN R2
	XOR     R3,W            ;EXCLUSIVE OR THE EXTENSIONS TO FIND DIFF
	LSHC    R2,22           ;THIS ISN'T NECESSARY BUT SPEEDS UP CKNCHR
	PUSHJ   P,CKNCHR        ;SKIP IF NAMES MATCH
	AOJA    R1,CKNNXT       ;DON'T MATCH SO TRY THE NEXT
	MOVEM R1,CKNFP#         ;POS. WHEN CONTAINING ADDRESS OF A
;                               FILENAME MATCH OTHER THAN "ALL"
	JRST    CPOPJ1          ;SUCCESS RETURN FOR MATCH
CKNNXT: LDB     R2,[XWD CNTFP+R1,1]
	CAIN    R2,CNTFT        ;SKIP IF NOT THE LAST FILE IN LIST
	POPJ    P,              ;FAIL RETURN
	AOJA    R1,CKNNX1       ;CHECK THE NEXT FILE NAME

CKNPPN: SETOM   NOTWRD#         ;-1 FOR NORMAL, 0 FOR NOT
	MOVEI   R1,2            ;SECOND PART OF COMMAND
	MOVE    R1,CTABL2##(R1) ;GET PARAMETERS FOR COMMAND
	HLRZ    R3,R1           ;SAVE STATE IN R3
	JUMPE   R1,CPOPJ1       ;SUCCESS RET IF NOT SET UP
	LDB     R2,[XWD CNTFP+R1,0]
	HRRZ    R0,(R1)
	PUSHJ   P,@CNTTAB(R2)
	AOJA    R1,.-3          ;LOOP
	CAME    R2,[-1]         ;SKIP IF NO MATCH
	SETZ    R2,             ;ZERO FOR MATCH
	XOR     R2,NOTWRD       ;INVERT IF NORMAL, DO NOTHING IF NOT
	JRST    CPOPJ(R2)       ;ADD ONE FOR SUCCESS RETURN

CNTFNR: SETCMM  NOTWRD          ;INVERT THE OPERATION
	POPJ    P,
CNTFCR: XCT     AGUFO(R3)
	CAMN    R0,R2           ;SKIP IF NOT DONE
	AOS     (P)             ;DONE - DON'T LOOP ANYMORE
	POPJ    P,
CNTFDR: XCT     AGUFO(R3)
	AOJ     R1,
	CAMLE   R0,R2
	JRST    CNTFTT
	HRRZ    R0,(R1)
	CAML    R0,R2
	JRST    CPOPJ1
CNTFTT: LDB     R2,[XWD CNTFP+R1,0]
	SETO    R0,
	CAIN    R2,CNTFT        ;SKIP IF NOT A TERMINATOR
	AOS     (P)             ;TERMINATOR, SO STOP LOOPING
	POPJ    P,
CNTFTR: XCT     AGUFO(R3)
	CAME    R0,R2           ;SKIP IF MATCH
	SETO    R2,             ;TERMINATE WITHOUT MATCH
	JRST    CPOPJ1          ;DONE LOOPING NO MATTER WHAT HAPPENED

;OUTPUT TRAILER BLOCK

TRLOUT: MOVN    R1,TAPNUM       ;NEGATE TAPE #
	HRRM    R1,FIRBL2       ;RESET TRAILER
	TRO F,EOTFLG            ;SET FLAG  TO REMIND DIR OR RES
	                        ;TO BACKSPACE FILE AT THIS POINT
	                        ;FALL INTO LABBLT

;WRITE HEADER OR TRAILER ON TAPE

LABBLT: MOVE    R1,DAYTIM       ;GET DATE ETC
	TLZ     R1,MSKCTD       ;TURN OFF CONTINUED BITS
	SKIPE   STRPPN          ;SKIP IF NO STARTING PPN
	TLO     R1,TAPCTD       ;THIS IS A CONTINUATION TAPE
	SKIPE   STRFIL          ;SKIP IF NO STARTING FILE
	TLO     R1,USRCTD       ;USER IS CONTINUED FROM PREVIOUS TAPE
	SKIPE   STRBLK          ;SKIP IF NO STARTING BLOCK
	TLO     R1,FILCTD       ;FILE IS CONTINUED FROM PREVIOUS TAPE
	MOVEM   R1,FIRBL3       ;SAVE WORD IN TAPE HEADER
	MOVEI   R1,10           ;ASSUME TAPE VERSION 10
	TLNN    F,P12FLG        ;SKIP IF MON P012 OR LATER
	HRLM    R1,FIRBLK       ;CREATING OLD FORMAT TAPE
	MOVSI   R1,FIRBLK       ;ADDR OF HEADER
	HRR     R1,TAPHD1       ;GET BUFFER DATA ADDR FROM BYTE PTR
	MOVEI   R2,4(R1)        ;SET STOP AT 5TH DATA WORD
	BLT     R1,(R2)         ;BLT HEADER INTO BUFFER
	HRRM    R2,TAPHD1       ;RESET BYTE POINTER
	MOVNI   R1,3            ;RESET COUNT
	ADDM    R1,TAPHD2
	SOS     TAPHD2          ;ADJUST FOR NON-LOOP CALL
	PUSHJ   P,TAPOUT        ;WRITE ONE RECORD
CLSUSR: PUSHJ P,MTCLS           ;CLOSE TAPE
NULTAP: MOVSI   R1,400000       ;TURN OFF VIRGIN BIT
	ANDCAB  R1,TAPHED
	AOS     R1              ;SET BYTE POINTER TO BEG OF BUFFER
	HRRM    R1,TAPHD1
TAPOU3: MOVE R1,TPSZM4 ;TAPE RECORD SIZE-4   DATA WDS/BUFFER -1
	HRRZM   R1,TAPHD2       ;BUFFER COUNT
	IDPB    R1,TAPHD1       ;BUFFER COUNT TO 1ST DATA WORD
	POPJ    P,              ;RETURN

; CLOSE TAPE.  ASSURE USE BIT TURNED OFF IN BUFFER HEADER

MTCLS:: XCT MCLOS(UNIT)         ;ASK THE MONITOR TO CLOSE
	XCT MTWAIT(UNIT)        ;WAIT UNTIL OUTPUT FINISHED
	XCT MGET1(UNIT)
	TRNN R1,740000
	POPJ P,
	TRNE R1,400000
	ERB [XWD 0,[ASCIZ"$TAPE WRITE LOCKED AT CLOSE"]]
	TRNE R1,200000
	ERB [XWD 0,[ASCIZ"$PHYS DEV ERR AT CLOSE"]]
	TRNE R1,100000
	ERB [XWD 0,[ASCIZ"$PARITY ERR AT CLOSE"]]
	ANDCMI R1,740000
	XCT MSET1(UNIT)
	MOVSI R1,400000
	ANDCAM R1,TAPBUF+1
	IORM R1,TAPHED
	MOVE R1,INOUT
	TRNE R1,777777
	JRST .+3
	XCT MOUTPUT(UNIT) ;VACUOUS TO REINITIALIZE DEVOAD
	POPJ P,
	XCT MINPUT(UNIT)
	POPJ P,


;BLT HEADERS INTO TAPE BUFFER

DIRBLT: MOVSI   R1,FILMRK       ;HEADER WORD FOR DIRECTORY
	HRR     R1,TAPHD1       ;GET BUFFER DATA ADDR FROM BYTE PTR
	MOVEI   R2,XHDRN(R1)    ;SET STOP AT LAST RETRIEVAL WORD
	BLT     R1,(R2)         ;BLT HEADER INTO BUFFER
	HRRM    R2,TAPHD1       ;RESET BYTE POINTER
	MOVNI   R1,XHDRN-1      ;RESET COUNT
; IF THIS LOOKS STRANGE CONSIDER XHDRN=776 SO THAT THERE IS
; ROOM FOR ONE DATA WORD PAST THE HEADER.  THEN TAPHD2 WILL BE =
; TWO SO THAT ONE WORD CAN BE DEPOSITED INTO THE BUFFER AT MORE3
	ADDM    R1,TAPHD2
	POPJ    P,              ;RETURN

SETSTR: MOVE    R1,CURPPN       ;GET CURRENT PPN - ONLY RH COUNTS
	MOVEM   R1,STRPPN       ;MAKE IT THE STARTING PPN FOR NEXT TAPE
	MOVE    R1,CURFIL       ;GET CURRENT FILE NAME
	MOVEM   R1,STRFIL       ;MAKE IT THE STARTING FILE FOR NEXT TAPE
	MOVE    R1,CUREXT       ;GET CURRENT EXTENSION
	HLLZM   R1,STREXT       ;MAKE IT THE STARTING EXT FOR NEXT TAPE
	MOVE    R1,BLKCNT       ;GET REAL BLOCK COUNT IF ENOUGH TAPE USED
	ADD     R1,OLDBLK       ;ADD IN PREVIOUS STRT BLK IF ANY
	MOVEM   R1,STRBLK       ;SAVE STARTING BLOCK OF FILE
	SKIPE   STRBLK          ;SKIP IF FILE IS NOT SPLIT
	PUSHJ P,PCFM    ;PRINT CONTINUED FILE MESSAGES AND FIX CKSUM
	POPJ    P,              ;RETURN FROM SETSTR

ETBRET: PUSHJ   P,TAPOU3        ;SET UP TRAILER
	PUSHJ   P,TRLOUT        ;WRITE TRAILER
	CLOSE   MFD,DNC         ;CLOSE THE MFD
	RELEASE MFD,
	CLOSE FIL,DNC
	RELEASE FIL,
	PUSHJ   P,NXTTAP        ;REWIND CURRENT TAPE, GET NEXT MTD
	MOVE    P,STOSTP        ;FIX STACK FOR BRANCH OUT OF SUBROUTINE
	JRST    CONSTO          ;CONTINUE THE STORE

; PREPARE TAPE FOR OUTPUT.  USED BY STORE AND CUT COMMANDS

WPREP:  PUSHJ   P,SETOUT        ;INIT TAPE AND SET UP HEADER AS VIRGIN
	XCT MOUTPUT(UNIT)       ;DUMMY OUTPUT TO SET UP TAPHED
	PUSHJ   P,TAPOU3        ;SET UP BUFFER COUNTS
	TLNN F,CUTFLG           ;CUT PERMITTED PAST REFLECTIVE SPOT
	TLNN F,EOTFND           ;AT END OF TAPE MARKER OR BEYOND
	JRST .+2                ;EITHER NOT THERE OR CUT COMMAND
	ERROR [ASCIZ"ATTEMPT TO STORE PAST PHYSICAL EOT"]
	TRZ F,EOTFLG            ;NOT POSITIONED AT LOGICAL EOT
;*      TLNE    F,BOTFLG        ;SKIP IF NOT AT BEGINNING OF TAPE
	XCT MF13(UNIT)          ;ERASE 3 INCHES TO GET OFF LOAD POINT
	XCT MF0(UNIT)           ;WAIT FOR OPERATION TO COMPLETE
	AOS     R1,TAPNUM       ;INCREMENT AND LOAD TAPE SEQ NUMBER
	HRRM    R1,FIRBL2       ;PLACE IN HEADER
	PUSHJ P,NHDAT
; MOVE PERMANENT TAPE PARAMETERS TO FILE HDR BLOCK
	MOVE DAYTIM
	MOVEM TPTIM
	HRRI R0,VERSION
	HRLI R0,(SIXBIT/DSK/)
	MOVEM FILDM1
	PUSHJ P,TPID
	POPJ P,

NHDAT:  TLO     F,T12FLG        ;WRITING NEW FORMAT TAPE
	MOVE    R1,[XWD 11,11]  ;GETTAB FOR DATE IN DAYS SINCE 1964 GMT
	GETTAB  R1,
	SETZ    R1,             ;SHOULD NEVER FAIL BUT DEFAULT TO 0
	MOVEM   R1,DAYTIM       ;SAVE THE DATE
	MOVE    R1,[XWD 10,11]  ;GETTAB FOR TIME IN JIFFIES GMT
	GETTAB  R1,
	SETZ    R1,             ;SHOULD NEVER FAIL BUT DEFAULT TO 0
	IDIV    R1,JIFFPM       ;CONVERT JIFFIES TO MINUTES
	DPB     R1,[POINT 11,DAYTIM,21] ;SAVE TIME
	POPJ P,

; GET SYSTEM IDENT AND SAVE IN TPID2

TPID:	Push P,R1	; Save a register			[15.14]
	Movei R1,CNFSIZ	; Figure how many to do			[15.14]
TPID0:	Hrli R0,-1(R1)	; Index from 0 to (n-1)			[15.14]
	Hrri R0,11	; Rest of Gettab			[15.14]
	Gettab R0,	; Get system name in ASCII		[15.14]
	  Setz R0,						[15.14]
	Movem R0,TPID2-1(R1)	; Store it			[15.14]
	Sojg R1,TPID0	; Loop till got it all			[15.14]
	Move R1,[TPID2,,TPID1]	; Setup for copy		[16.2]
	Blt R1,TPID1+1	; And copy 2 words for the tape		[16.2]
	Pop P,R1	; Restore save'd register		[15.14]
	Popj P,

;INITIALIZE MAGNETIC TAPE

SETIN:  HRRZI   R1,TAPHED       ;SET UP FOR INPUT
	SKIPA
SETOUT: HRLZI   R1,TAPHED       ;SET UP FOR OUTPUT
	MOVEM   R1,INOUT        ;SET HEADER
	XCT MOPEN(UNIT)         ;OPEN UNIT 0 OR 1
	ERROR   [ASCIZ "CAN'T ACCESS TAPE DEVICE"]
	XCT MCHNL1(UNIT)
	CALLI   R1,4            ;GET DEVICE CHARACTERISTICS
	TLNE    R1,DVMTA        ;SKIP IF NOT MAGTAPE
	JRST    SETTP
	XCT MCLOS(UNIT)
	XCT MRELS(UNIT)
	ERROR   [ASCIZ "DEVICE NOT MAGTAPE."]
SETTP:  MOVE R1,[TAPBUF+1+1B0]
	MOVEM R1,TAPHED
	PUSHJ P,SETBUF  ;SET UP RING BUFFER
	TLZ     F,EOTFND!BOTFLG ;CLEAR EOT AND BOT FLAGS
	IFL -CUTS,<
	XCT MGET1(UNIT)
	TLNE F,CUTFLG
	IORI R1,SYNCIN
	XCT MSET1(UNIT)
	>
	XCT MUGETF(UNIT)        ;SENSE DEVICE CHARACTERISTICS
	MOVE R1,SENTAB+1
	TLNE    R1,040000       ;SKIP IF NOT BEGINNING OF TAPE
	TLO     F,BOTFLG        ;AT BEGINNING OF TAPE
	TLNE    R1,020000       ;SKIP IF NOT AT END OF TAPE
	TLO     F,EOTFND        ;AT END OF TAPE
	PUSHJ P,SETDEN          ;SET TAPE DENSITY
	POPJ    P,              ;RETURN

TAPOPN: EXP BUFBIN!NOCNT!1B0!SYNCIN
FS6BIT: SIXBIT /MTAX/           ;STORED INTO BY START ROUTINE
INOUT:  XWD     0,0             ;STORED INTO BY SETIN/SETOUT

; SETBUF SETS UP THE BUFFER RING
SETBUF: HRL R1,TPSZM2 ;TAPE RECORD SIZE-2
	SETZM TAPBUF
	HRRI R1,TAPBUF+1
	MOVEM R1,TAPBUF+1
	POPJ P,

; CLRTAP CLOSES TAPE AND CLEARS EOF AND ERROR BITS.  SYSTEM
; IS NOT CONSISTENT ABOUT DOING THIS.

CLRTAP: XCT MCLOS(UNIT)
	XCT MGET1(UNIT)
	TRZ R1,760000
	XCT MSET1(UNIT)
	POPJ P,

; TAPIN READS ONE RECORDS FROM TAPE AND RETURNS TO:
;  CALL+1 IF END OF FILE READ
;  CALL+2 IF DIRECTORY, HEADER, OR TRAILER IS READ
;  CALL+3 IF DATA RECORD READ
; IF IT RETURNS TO CALL+2, R1 TELLS WHAT WAS READ:
;  TRAILER=-1, HEADER=0, DIRECTORY=1

TAPIN:  MOVEI R0,CURPPN         ;SET UP FOR ERROR PRINTOUTS
	MOVEM R0,ERRPPN#        ;WILL BE SET TO LSTPPN BY TINDIR
	SETOM   R0              ;INITIALIZE ERROR COUNT TO 0-1
TAPINE: XCT MIN(UNIT)           ;READ ANOTHER BUFFER
	JRST    TAPIN2          ;READ OK
	XCT MSTOEND(UNIT)       ;END OF FILE?
	JRST    ERRTIN          ;GO TO ERROR ROUTINE
	PUSHJ P,CLRTAP  ;CLOSE TAPE AND CLEAR END BIT
	TRNE F,EOFFLG
	TRO F,EOTFLG            ;TWO EOF'S IN A ROW
	TRO F,EOFFLG            ;AT LEAST ONE EOF READ
	POPJ    P,              ;RETURN CALL+1 (EOF)

TAPIN2: TRZ F,EOFFLG
	MOVE    R1,TAPHED       ;LOOK AT PHYS. EOT BIT
	MOVE    R1,-1(R1)       ;IN BFR HDR (NOT RING BFR HDR)
	TRNE    R1,IOTEND       ;SKIP IF NOT END OF TAPE FOUND
	TLO     F,EOTFND        ;MARK END OF TAPE FOUND
	ILDB    R2,TAPHD1       ;PICKUP WORD COUNT
	SOS     TAPHD2          ;ADJUST WD CT BELOW THIS WORD
	HLRZ    R2,R2           ;0 FOR DATA, -1 FOR DIR
	JUMPE   R2,CPOPJ2       ;JUMP IF IT'S A DATA RECORD
	MOVE    R1,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
	CAIN    R2,-1           ;SKIP IF NOT A DIR RECORD
	JRST    TINDIR          ;DIRECTORY FOUND
	HRL     R1,4(R1)        ;GET THE TAPE NUMBER
	HLREM   R1,FIRBL2       ;SAVE THE TAPE NUMBER
	MOVMS   FIRBL2          ;WE WANT THE MAGNITUDE OF THE NUMBER
	MOVE    R1,5(R1)        ;GET FLAGS AND DATE
	MOVEM   R1,FIRBL3       ;SAVE FLAGS AND DATE
	MOVE    R1,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
	HRL     R1,4(R1)        ;-=TRAILER, +=HEADER
	CAIN    R2,-6
	ERROR   [ASCIZ "FAILSAFE LEVEL C FORMAT TAPE"];*
	SKIPL   R1              ;SKIP IF TRAILER
	TLZ     F,CTDFLG        ;TURN OF CONTINUED FLAG IF HEADER
	SKIPGE  5(R1)           ;SKIP IF CONTINUED BIT OFF
	TLO     F,CTDFLG        ;SET CONTINUED FLAG
	HLLE    R1,R1           ;-=TRAILER, +=HEADER; 0 OR -1 IN ADDR
	JUMPG   R2,CPOPJ1       ;HEADER/TRAILER
	ERB [ASCIZ"$UNRECOGNIZABLE TAPE DATA.$"]
	JRST    FAKERR          ;FAKE ERROR--BYPASS QUESTIONABLE RECORD

ERRTIN: XCT MGET1(UNIT)
	TRNN R1,760000
	JRST    TAPIN2          ;NO, FURTHER ALONG IN RING
	TRZ     R1,760000       ;CLEAR ERROR BITS
	XCT MSET1(UNIT)         ;SET NEW STATUS
FAKERR: AOJG    R0,TAPINE       ;INC ERR CNT - JUMP IF NOT 1ST ERROR
	PUSHJ   P,TAPINE        ;NOTE THAT THIS IS CALLED RECURSIVELY
	JRST    ETIEOF          ;EOF - TELL OPERATOR AND RETURN
	JRST    ETIDIR          ;DIR - TELL OPERATOR AND RETURN
	PUSHJ P,PFN             ;PRINT FILENAME AND ERROR COUNT
	JRST    CPOPJ2          ;RETURN CALL+3 AS IF NOTHING HAPPENED
ETIDIR: PUSHJ P,PFN
	CAIN    R1,1
	ERB [XWD[CURPPN],[ASCIZ"$CONTINUING WITH FILE _J$"]]
	JRST CPOPJ1
ETIEOF: PUSHJ P,PFN
	ERB [XWD 0,[ASCIZ"$CONTINUING WITH NEXT USER.$"]]
	POPJ P,
PFN:    AOS R0                  ;INCREMENT ERROR CNT BEFORE PRINTING
	MOVEM   R0,TAPERR#      ;SAVE ERROR COUNT FOR PRINTING
	ERB [XWD [TAPERR],[ASCIZ"$_C TAPE ERRORS"]]
	HRLI R2,ERRPPN          ;POINTS TO CURPPN OR LSTPPN
	HRRI R2,[ASCIZ" READING FILE _J"]
	MOVEM R2,PFNE#
	SKIPE @ERRPPN
	ERB PFNE
	TCO [CRCHR]     ;OUTPUT CHAR TO BOTH COF AND TER
	POPJ P,

TINDIR: PUSHJ P,TRCL            ;MOVE CURPPN TO LST
	MOVE R1,TAPHED          ;CURRENT BUFFER
	MOVSI   R2,5(R1)        ;ADDRESS OF NEW PPN-FIL-EXT
	HRRI    R2,CURPPN       ;ADDRESS OF CURRENT PPN
	BLT     R2,CUREXT       ;SET UP NEW CURRENT PPN-FIL-EXT
	TRZ F,NEWFLG            ;ASSUME NO POSITION NOS.
	SETZM CURVER            ;ASSUME OLD TAPE
	SETZM DATTIM
	HLRZ R2,3(R1) ;LOGICAL NAME
	CAIE R2,(SIXBIT /DSK/)
	JRST TIND1
	HRRZ R2,3(R1)
	CAIG R2,37
	CAIG R2,13
	JRST TIND1
	TRO F,NEWFLG            ;POSITION NOS.
	TLO F,T12FLG            ;CERTAINLY > 11
	MOVEM R2,CURVER        ;TITO VERSION NO. THAT WROTE TAPE
	MOVE R2,XHDR(R1)        ;TPPOS
	HLRZM   R2,CURNUM      ;REEL NO.
	HRRZM   R2,CURPOS      ;FILE POS. NO.
	MOVE R2,XHDR-1(R1)      ;TPTIM
	MOVEM R2,CURDAT        ;TIME-DATE WRITTEN
	DPB R2,[POINT 14,DATTIM,24]
	LSH R2,-16              ;SHIFT OUT DATE
	DPB R2,[POINT 11,DATTIM,35]
	MOVE R2,XHDR-2(R1)      ;TPSER
	MOVEM R2,CURSER         ;SERIAL NO. OF DRIVE THAT WROTE TAPE
	MOVE R2,XHDR-3(R1)      ;TPDEN
	MOVEM R2,CURTRK
	MOVE R2,XHDR-7(R1)      ;TPUN1
	MOVEM R2,CURUN1
	MOVE R2,XHDR-6(R1)      ;TPUN2
	MOVEM R2,CURUN2
TIND1:  MOVEI   R1,LSTPPN
	MOVEM   R1,ERRPPN       ;SAVE FOR ERROR MESSAGE
	MOVEI   R1,1            ;JUST READ A DIRECTORY
	JRST    CPOPJ1          ;SKIP RETURN FROM TAPIN

TRCL:   SKIPN   CURPPN          ;SKIP IF THERE IS A CURRENT FILE
	POPJ    P,              ;*RETURN FROM TRCL DOING NOTHING (KLUDGE)
	MOVE    R1,[XWD CURPPN,LSTPPN]
	BLT     R1,LSTTIM       ;MOVE CURPPN-FIL-EXT TO LSTPPN-FIL-EXT
	SETZM   CURPPN          ;MARK AS NO CURRENT FILE
	POPJ    P,              ;RETURN FROM TRCL

CPOPJ2: AOS     (P)             ;RETURN TWO SKIPS
CPOPJ1: AOS     (P)             ;RETURN +1
CPOPJ:: POPJ    P,              ;RETURN

SKITRM::MOVEM   R0,SKICNT#      ;SAVE THE SKIP COUNT
	MOVEM R2,SAV2#
	PUSHJ   P,SETIN         ;SET TAPE FOR INPUT
	TRZ F,HDRFND+HDRMSG+EOFFLG+SSCFLG+UNMFLG
	TRNE F,EOTFLG           ;ARE WE ALREADY AT END OF TAPE
	JRST  SKIEO             ;YES
	PUSHJ P,ZPOS            ;ZERO ALL POSITIONAL INFORMATION
SKITIN: PUSHJ   P,TAPIN         ;READ A RECORD
	JRST    SKITIN          ;IGNORE END OF FILE
	JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
	JRST    SKITIN          ;IGNORE DATA
	JRST    SKITRL          ;TRAILER
	JRST    SKITIN          ;IGNORE HEADER
	TRNN F,NEWFLG
	JRST    SKITIN          ;OLD TAPE--IGNORE DIRECTORIES
	PUSHJ P,COMPA           ;COMPATIBILITY CHECKS
	ERROR [ASCIZ"ABORT"]
	JRST SKITIN
SKITRL: PUSHJ  P,VERFLG
	ERT [XWD[SKITIN],[ASCIZ"BAD TRAILER FOUND_E"]]
	PUSHJ   P,TAPIN         ;READ EOF FOLLOWING TRAILER
	JRST    .+3             ;EOF - CONTINUE
	JUMP                    ;TRAILER, HEADER, OR DIR - ERROR
	ERROR   [ASCIZ "END OF FILE NOT FOUND AFTER TRAILER"];**CHANGE THIS
	SOSG    SKICNT          ;DECREMENT COUNT AND SKIP IF NOT DONE
	JRST    SKINI
	PUSHJ   P,TAPIN         ;READ EOF OR HEADER AFTER LAST EOF
	JRST    SKIEOT          ;END OF TAPE
	JRST    SKITIN          ;PROBABLY HEADER SO CONTINUE LOOPING
	JRST    SKITIN          ;SHOULDN'T BE DATA HERE BUT IGNORE IT
SKIEOT: XCT MF17(UNIT)          ;BACKSPACE OVER LAST EOF
	XCT MF0(UNIT)           ;WAIT FOR OPERATION TO COMPLETE
SKIEO:  TRO F,EOTFLG
	TYPE    [ASCIZ "LOGICAL EOT$"]
SKINI:  ERT [XWD[CURPPN],[ASCIZ"LAST FILE WAS _J"]]
	TRNN F,NEWFLG
	ERT [XWD[FIRBL3],[ASCIZ" WRITTEN _L."]]
	TRNE F,NEWFLG
	ERT [XWD[CURPOS],[ASCIZ" AT POS _H."]]
	MOVE R2,SAV2
	CAIE R2,SKI2## ;INITIALIZE FOR SKIP WRITE OR
	CAIN    R2,APPROU##     ;APPEND ONLY
	TLO     F,INIFLG        ;TAPE NOW INITIALIZED
	JRST    CDISP           ;RETURN TO COMMAND DISPATCHER

; NOUPDATE, UPDATE, QUIT, RWN, REW, UNL

ASKERR::SKIPA R1,[0]		;ASK TO CONTINUE (DEFAULT)
NASKER::HRREI R1,-1		;DON'T ASK, JUST CONTINUE
	MOVEM R1,ASKFLG
	JRST CDISP

NFLROU::SKIPA R1,[0]
FLGROU::HRREI R1,-1
	MOVEM R1,FLGOFF
	JRST CDISP

NPRROU::SKIPA R1,[0]
PRROU:: HRREI R1,-1
	MOVEM R1,PRAFLG         ;PREALLOCATE STORAGE IF NON-ZERO
	JRST CDISP
NUPROU::SKIPA R1,[0]
UPDROU::HRREI	R1,-1
	MOVEM	R1,UPDFLG
	JRST	CDISP

QUIROU::PUSHJ P,COFRLS## ;GET COF FILE CLOSED
	CALLI   RESET           ;TERMINATE ALL I/O
	EXIT                    ;RETURN TO EXEC
REWROU::PUSHJ   P,REWWAI        ;REWIND THE TAPE AND WAIT
	JRST    CDISP           ;RETURN TO COMMAND DISPATCHER
RWNROU::PUSHJ P,REWTAP          ;REWIND THE TAPE
	JRST .+2
UNLROU::PUSHJ P,UNLTAP
	TRO F,NWFLG             ;DON'T DO MTCLS AT CDISP
	JRST CDISP

; UNLOAD TAPE WITHOUT WAIT
UNLTAP: XCT MF11(UNIT)
	JRST REWTAP+1
; REWIND TAPE WITHOUT WAIT
REWTAP: XCT MF1(UNIT)           ;REWIND WITHOUT WAIT FOR COMPLETION
	TLZ     F,EOTFND        ;NOT AT END OF TAPE
	TLO     F,BOTFLG        ;AT BEGINNING OF TAPE
; FORGET ANYTHING WE MAY HAVE READ
	PUSHJ P,ZPOS            ;ZERO POSITIONAL INFORMATION
	TRZ F,EOTFLG+EOFFLG+UNMFLG+HDRMSG+HDRFND
	TRO F,SSCFLG    ;CAN PRINT SAVE SET NOS.
	SETZM   DIRSSC#         ;NO SAVE SETS FOUND YET
	POPJ    P,              ;RETURN FROM REWTAP

; REWIND AND WAIT
REWWAI:: PUSHJ   P,REWTAP        ;REWIND THE TAPE
	XCT MF0(UNIT)
	POPJ    P,              ;RETURN FROM REWWAI

; REWIND CURRENT TAPE AND GET NEXT TAPE MOUNTED

NXTTAP: PUSHJ P,REWTAP  ;REWIND WITHOUT WAIT
	MOVE BPI
	MOVEM BPI1      ;REMEMBER DENSITY SETTING
	SETOM ESCDI     ;DISABLE ESCAPES
	MOVE FS6BIT
	MOVEM OFS6
	MOVEM UNIT,OUNIT        ;SAVE UNIT ASSIGNMENT
	MOVE INOUT
	MOVEM OINOUT#           ;SAVE FOR I/O DIRECTION TEST
	TYPE [ASCIZ"$MOUNT NEXT TAPE"]
NXTT1:  MOVEI R1,NXTT5
	MOVEM R1,UNISW  ;GO TO NXTT5 IN ERROR UUO
	MOVEM P,ERRSTP
	TCO [CRCHR]
NXTT1A: TYPE [ASCIZ"CONTINUE ON DEVICE: "]
	PUSHJ P,RDUNI   ;READ SIXBIT DEVICE NAME
	MOVS R0,R0      ;SWAP HALVES FOR EASY COMPARE
	CAIE R0,(SIXBIT /UNL/)
	CAIN R0,(SIXBIT/U/)
	JRST NXTT2      ;UNLOAD
	CAIN R0,(SIXBIT/UN/)
	JRST NXTT2       ;UNLOAD
	CAIE R0,(SIXBIT/NO/)
	CAIN R0,(SIXBIT/N/)
	JRST ABORTA##   ;DISPATCHER TO CLEAR ESCDI AND UNISW
	CAIE R0,(SIXBIT/?/)
	JRST NXTT3      ;DEVICE NAME
	CLRIN
	TYPE [ASCIZ"$TYPE U TO UNLOAD CURRENT TAPE.  TYPE A MAGTAPE
DEVICE WHEN NEXT TAPE IS MOUNTED AND YOU WISH TO PROCEED."]
	TYPE [ASCIZ"$TYPE NO TO ABORT."]
	JRST NXTT1
; UNLOAD CURRENT TAPE
NXTT2:  XCT MF11(UNIT)
	JRST NXTT1A
; GET DEVICE
NXTT3:  MOVSM R0,FS6BIT
	TRC UNIT,1      ;CHANGE UNITS
	PUSHJ P,SETIN
	SETZM SER       ;DEMAND DEVICE SERIAL NO.
	PUSHJ P,GDC     ;GET CHARACTERISTICS OF NEW DEVICE
	MOVE TRK1
	CAME TRK        ;DO NOT PERMIT NO. OF TRACKS TO CHANGE
	ERROR [ASCIZ"CANNOT CHANGE NO. OF TRACKS IN PROCESS"]
	PUSHJ P,FINDEV  ;LOOKUP FS6BIT IN DEVICE TABLE
	JRST NXTT4      ;NOT FOUND
	MOVE R0,1(R1)   ;GET SERIAL FROM DEVICE TABLE
	MOVEM SER
	JRST NXTT4A     ;DON'T PRINT TRACKS
NXTT4:  PUSHJ P,PTRK    ;PRINT TRACKS
NXTT4A: PUSHJ P,SETBPI  ;KEEP SAME DENSITY
	ERROR [ASCIZ"CANNOT CHANGE DENSITY IN PROCESS"]
	MOVE OINOUT
	TLNE R0,777777          ;WERE WE WRITING TAPE
	SKIPL SENTAB+1          ;YES, IS IT WRITE LOCKED
	JRST .+2                ;NO
	ERROR [ASCIZ"TAPE NEEDS WRITE RING"]
	SETOM UNISW
	SETZM ESCDI
	PUSHJ P,REWWAI  ;REWIND NEW TAPE
	ERO [XWD 0,[14B6]]      ;OUTPUT TOP OF FORM
	POPJ P,         ;RETURN FROM NXTTAP
NXTT5:  MOVE OFS6
	MOVEM FS6BIT
	MOVE UNIT,OUNIT# ;RESTORE UNIT
	SETOM UNISW
	PUSHJ P,SETIN
	JRST NXTT1


; DEVICE COMMAND.  SYNTAX IS *DEV <DEVNAM> <DENSITY>(CR)
;       IF DEVNAM IS MISSING THE CURRENT DEVICE IS USED.
;       IF DEVNAM IS PRESENT DEVNAM BECOMES THE NEW TAPE DEVICE.
;       IF DENSITY IS MISSING THE DEVICE CHARACTERISTICS ARE PRINTED.
;       IF DENSITY IS PRESENT THE GIVEN DENSITY REPLACES THE EXISTING
;       DENSITY (PROVIDING THE UNIT IS CAPABLE OF THE NEW SETTING)

DEVROU::SETZM PSW#
	MOVE TRK
	MOVEM TRK1
	SETOM BPI1      ;SET TO DEMAND DENSITY IF NOT IN DEVTBL
	SETZM SER       ;SET TO DEMAND SERIAL NO.
	SETOM ESCDI     ;DISABLE ESCAPES
	MOVEI DEVERR
	MOVEM UNISW
	MOVEM P,ERRSTP
	MOVE FS6BIT
	MOVEM OFS6#             ;SAVE OLD DEVICE NAME FOR DEVERR
	CAIE CT,SP
	JRST DEVR4              ;PRINT CHARACTERISTICS OF CURRENT DEVICE
	PUSHJ P,DEVR5           ;CONSUME SPACES
	CAIN CT,NU              ;SKIP IF NOT A DIGIT
	JRST DEVR1              ;SET DENSITY OF CURRENT DEVICE
	PUSHJ P,RDUNI           ;GET NAME
	MOVEM FS6BIT
	XCT MRELS(UNIT)
	PUSHJ P,SETIN           ;IOPEN DEVICE
	PUSHJ P,GDC             ;GET DEVICE CHARACTERISTICS
	CAIE CT,SP              ;DENSITY ENTERED TOO
	JRST DEVR4B     ;NO, PRINT KNOWN CHARACTERISTICS OR COMPLETE DEVTBL
	PUSHJ P,DEVR5
	CAIE CT,NU
	ERROR [ASCIZ"EXPECTED DIGIT"]
DEVR1:  PUSHJ P,RDDNUM
	CAILE R0,0
	CAIE CT,TE
	ERROR [ASCIZ"EXPECTED TERMINATOR"]
	MOVEM BPI1
	PUSHJ P,FINDEV
	JRST DEVR2              ;NOT IN DEVTBL
DEVR1A: MOVE R0,1(R1)           ;SERIAL
	MOVEM SER
	JRST DEVR2A     ;DON'T PRINT TRACKS
DEVR2:  PUSHJ P,PTRK    ;PRINT TRACKS
DEVR2A: PUSHJ P,SETBPI
	JRST DEVR3              ;INCAPABLE OF THIS DENSITY
	SKIPE PSW
	ERT [XWD[SER
TPDEN],[ASCIZ"_S: _O"]]
	JRST CDISP
DEVR3:  PUSHJ P,DDI
	JRST DEVR2A
DEVR4:
	PUSHJ P,FINDEV
	ERROR [ASCIZ"CANNOT FIND CURRENT DEVICE IN DEVTBL"]
DEVR4A: SETOM PSW
	HLRZ R0,2(R1)           ;DENSITY FROM DEVTBL
	MOVEM BPI1
	JRST DEVR1A
; PRINT CHARACTERISTICS IF IN DEVTBL
; DEMAND CHARACTERISTICS IF THIS IS A NEW DEVICE
DEVR4B: PUSHJ P,FINDEV
	JRST DEVR2  ;DEMAND
	JRST DEVR4A ;PRINT
DEVR5:  TCL CT,CH
	CAIE CT,SP
	POPJ P,
	TCI CT,CH
	JRST .-4
DEVERR: MOVE OFS6
	MOVEM FS6BIT
	SETOM UNISW
	PUSHJ P,SETIN           ;OPEN ORIGINAL DEVICE
	JRST CDISP

; FINDEV SEARCHES DEVTBL FOR A MATCH ON DEVICE NAME IN FS6BIT.
; THE SEARCH ENDS ON A ZERO NAME WITH A NONSKIP RETURN AND
; WITH R1 POINTING AT THE ZERO ENTRY.  IF A MATCH IS FOUND
; R1 POINTS AT THE MATCHING ENTRY WITH A SKIP RETURN GIVEN.

FINDEV: MOVE R1,[-NDEV,,DEVTBL]
FIND1:  MOVE R0,(R1)
	CAMN R0,FS6BIT
	JRST FIND2
	CAIN R0,0
	JRST FIND3
	AOS R1
	AOS R1
	AOBJN R1,FIND1
	ERROR [ASCIZ"DEVICE TABLE FULL"]
FIND2:  AOS (P)
FIND3:  MOVEM R1,DEVTX#
	POPJ P,

; DEVTBL CONTAINS 3 WORDS PER ENTRY.  WORD 0 IS THE SIXBIT DEVICE NAME.
; [WORD 1]RH CONTAINS THE UNIT SERIAL NO.  [WORD 2]LH CONTAINS THE
; DENSITY SETTING (DECIMAL) AND [WORD 2]RH CONTAINS THE NO. OF TRACKS

DEVTBL: BLOCK 3*NDEV

; SET DENSITY BITS IN CHANNEL STATUS

SETDEN: XCT MGET2(UNIT)
	MOVE R1,DEN
	XOR R1,R2
	ANDI R1,600
	XOR R1,R2
	XCT MSET1(UNIT)
	POPJ P,

; SETBPI CHECKS TO SEE IF UNIT IS CAPABLE OF DENSITY BPI1.
;   IF UNIT IS CAPABLE STORE BPI1 INTO BPI AND SKIP RETURN
; WE ALSO SET THE DRIVE TO THE CORRECT HI, MEDIUM, OR LOW SETTING.

SETBPI::MOVE R2,[-3,,0]
	MOVE R1,DENTAB(R2)
	CAMN R1,BPI1
	JRST .+3
	AOBJN R2,.-3
	POPJ P,         ;UNIT NOT CAPABLE OF BPI1
	MOVE TRK1
	MOVEM TRK
	MOVEM R1,BPI
	MOVEI ^D512+3   ;RECORD SIZE FOR 800 BPI OR LESS
	CAIN R1,^D1600
	MOVEI ^D1916+3
	CAIN R1,^D6250
	MOVEI ^D3740+3
	SUBI 2
	MOVEM TPSZM2
	SUBI 1
	MOVEM TPSZM3
	SUBI 1
	MOVEM TPSZM4
	PUSHJ P,SETBUF ;SET RECORD SIZE INTO BUFFER
	HRRZ R2,R2
	SUBI R2,3
	LSH R2,7
	MOVNM R2,DEN#   ;DEN=(3-R2)*200
	PUSHJ P,SETDEN  ;SET DENSITY BITS IN CHANNEL STATUS
	SKIPN SER
	PUSHJ P,SERROU  ;GET SERIAL NO. OF DRIVE IF REQ'D
	AOS (P)         ;FOR SKIP RETURN
; STOBPI STORES PERMANENT TAPE PARAMETERS INTO FILE HEADER BLOCK
STOBPI::MOVE R2,DEVTX   ;INDEX INTO DEVICE TBL
	HRL R1,BPI
	HRR R1,TRK
	MOVEM R1,TPDEN  ;DENSITY TO LH, TRKS TO RH
	MOVEM R1,2(R2)  ;DEN AND TRKS TO DEVTBL
	MOVE R1,SER
	MOVEM R1,TPSER  ;SERIAL TO RH
	MOVEM R1,1(R2)  ;SERIAL TO DEVTBL
	MOVE R1,FS6BIT
	MOVEM R1,0(R2)  ;DEVICE NAME TO DEVTBL
	POPJ P,

; INPUT DRIVE SERIAL NO. TO R0 AND SER

SERROU: MOVE FS6BIT
	MOVEM SER#
	POPJ P,

; PRINT NO. OF TRACKS FROM TRK1

PTRK:   TYPE [ASCIZ"TRACKS: "]
	MOVE TRK1
	ADDI R0,60
	TCO R0
	TCO [15]
	POPJ P,


; GET DEVICE CAPABILITIES.  HI, MED, AND LOW DENSITY SETTINGS
; ARE RETURNED IN DENTAB.  NO. OF TRACKS IS RETURNED IN TRK1.

GDC:    MOVE R1,SENTAB+1        ;UGETF DONE BY SETIN OR SETOUT
	MOVEI R0,11
	TLNE R1,40
	MOVEI R0,7
	MOVEM TRK1#     ;7 OR 9 TRACKS
	MOVE R2,[-5,,0]
	SETOM R3
GDC1:  TLNE R1,20      ;SKIP IF DRIVE CANNOT HANDLE THIS DENSITY
	JRST GDC3
GDC2:  LSH R1,1
	AOBJN R2,GDC1
; GUARANTEE MEDIUM AND LOW SETTINGS FOR DRIVES WITH FEWER THAN
; THREE SETTINGS
	CAIGE R3,0
	ERROR [ASCIZ"DRIVE DENSITY CANNOT BE SENSED"]
	HRLI R1,DENTAB(R3)
	HLR R1,R1
	AOS R1
	CAIE R3,2
	BLT R1,DENTAB+2
	POPJ P,
GDC3:  AOS R3
	CAIN R3,3
	ERROR [ASCIZ"DRIVE DENSITY CAPABILITIES AMBIGUOUS"]
	MOVE R0,BPICOD(R2)
	MOVEM R0,DENTAB(R3)
	JRST GDC2

BPICOD: EXP ^D6250,^D1600,^D800,^D556,^D200
DENTAB: BLOCK 3
SENTAB:: XWD 0,2
	EXP 0

; DISPLAY AND INPUT DENSITY.  UNIT CAPABILITIES ARE DISPLAYED
; IN PARENTHESES TO PROMPT OPERATOR

DDI:: TYPE [ASCIZ"DENSITY("]
	MOVE R2,[-3,,0]
	SETZM R3
DDI1:    MOVE R1,DENTAB(R2)
	CAMN R1,R3
	JRST DDI2        ;THIS NO. HAS ALREADY PRINTED
	SKIPE R3
	TCO [54]
	MOVEM R1,R3
	MOVEM R1,TMP
	ERT [XWD[TMP],[ASCIZ"_C"]]
DDI2:    AOBJN R2,DDI1
	TYPE [ASCIZ"): "]
	PUSHJ P,RDDNUM
	CAILE R0,0
	CAIE CT,TE
	CLRIN
	MOVEM BPI1
	POPJ P,

; ZERO POSITIONAL INFORMATION TO DEFEAT COMPATIBILITY TESTS.
; CALL WHEN TAPE SCAN IS REVERSED

ZPOS:   SETZM CURPPN
	MOVE R1,[CURPPN,,CURFIL]
	BLT R1,LSTTIM
	POPJ P,

; COMPATIBILITY CHECKS.  CHECKS NO. OF TRACKS AND DENSITY,
;       TAPE POSITION, AND RECORDED DATE.  IF AN ERROR IS
;       DETECTED THE OPERATOR MUST CONFIRM TO CONTINUE OR ELSE
;       THIS ROUTINE GIVES A NONSKIP RETURN
; TRACK AND DENSITY
COMPA:  SKIPE R1,LSTTRK
	CAMN R1,CURTRK
	JRST COMPA1     ;SAME OR LSTTRK=0
	ERT [XWD[CURPPN],[ASCIZ"$COMPATIBILITY ERROR AT FILE HEADER FOR _J"]]
	ERT [XWD[LSTTRK
		 CURTRK
		 COMPA1],[ASCIZ"$PREVIOUS FILE WRITTEN _O
CURRENT FILE WRITTEN _O
CONTINUE OK? _F_G"]]		;[16.5] Ding Ding
	JRST COMPA5
; TAPE TRACK AND DENSITY AND DRIVE TRACK AND DENSITY
COMPA1: MOVE R1,CURTRK
	SKIPN TRKSW
	CAMN R1,TPDEN
	JRST COMPA2
	ERT [XWD[CURPPN],[ASCIZ"$COMPATIBILITY ERROR AT FILE HEADER FOR _J"]]
	ERT [XWD[CURTRK
		 TPDEN
		 COMP2A],[ASCIZ"$CURRENT FILE WRITTEN _O
TAPE DRIVE SET TO _O
CONTINUE OK? _F_G"]]		;[16.5] Ding Ding
	JRST	COMPA5

COMP2A: SETOM	TRKSW#
; TAPE POSITION
COMPA2: MOVE	R1,LSTPOS
	ADDI	R1,1
	SKIPE	LSTPOS
	CAMN	R1,CURPOS
	  JRST	COMPA3     ;TAPE SEQUENCE OK OR LSTPOS=0
	ERT [XWD[CURPPN],[ASCIZ"$TAPE POSITIONING ERROR AT FILE HEADER FOR _J"]]
	ERT	[XWD[LSTPOS
		     XWD 10,5
		     CURPOS
		     XWD 10,5
		     COMPA3],[ASCIZ"$LAST TAPE POSITION WAS _N
CURRENT TAPE POS IS _N
CONTINUE OK? _F_G"]]		;[16.5] Ding Ding
	JRST	COMPA5

; CHECK DATE FILE RECORDED
COMPA3: SKIPE	R1,LSTTIM
	CAMG	R1,DATTIM
	  JRST	COMPA4
	ERT [XWD[CURPPN],[ASCIZ"$COMPATIBILITY ERROR AT FILE HEADER FOR _J"]]
	ERT [XWD[LSTDAT
CURDAT
COMPA4],[ASCIZ"$PREVIOUS FILE WRITTEN _L
CURRENT FILE WRITTEN _L
CONTINUE OK? _F_G"]]		;[16.5] Ding Ding
	JRST COMPA5
COMPA4: AOS (P)
COMPA5: POPJ P,
; POSITION TAPE TO FILE POS. RANFST.  INPUT RANGE OF POS. NOS.
;       IF NOT ALREADY DONE.
;       SKIP RETURN IF TAPE ALREADY POSITIONED.

POSTAP: TRNN F,RANFLG   ;HAVE WE ENTERED RANGE YET
	PUSHJ P,RAN     ;NO
	TRNN F,FNDFLG   ;HAVE WE FOUND RANFST FILE YET
	JRST POST2      ;FIND IT
POST1:  AOS (P)
	POPJ P,         ;RETURN FROM POSTAP
POST2:  MOVE R1,CURPOS
	CAMG R1,RANFST##;HAVE WE GONE PAST FIRST
	JRST POST3      ;NO
; FORGET ANYTHING WE READ IN FORWARD DIRECTION
	TRZ F,HDRFND+HDRMSG+EOFFLG+EOTFLG+SSCFLG+UNMFLG
	PUSHJ P,ZPOS            ;ZERO ALL POSITIONAL INFORMATION
	XCT MTWAIT(UNIT)        ;WAIT FOR INPUT TO STOP
	XCT MF17(UNIT)  ;BACK USER
	XCT MF17(UNIT)  ;BACK USER
	XCT MF17(UNIT)  ;BACK USER
	XCT MF0(UNIT)
	PUSHJ P,CLRTAP  ;CLOSE TAPE AND CLEAR FLAGS
	POPJ P,         ;NONSKIP RETURN FROM POSTAP
POST3:  CAME R1,RANFST  ;HAVE WE GOTTEN THERE YET
	POPJ P,         ;NO
	TRO F,FNDFLG
	JRST POST1      ;RETURN FROM POSTAP SKIPPING

; INPUT RANGE OF TAPE POS. NOS.

RAN:    TRZE F,RANCMD           ;RANGE ALREADY ENTERED FROM CMD
	JRST RAN3               ;YES, MARK RANGE AS ENTERED NOW
;                               (RANFLG ALSO INDICATES WE HAVE
;                               LOCATED OUR FIRST FILE BUT HAVE NOT
;                               YET POSITIONED TAPE)
	TYPE [ASCIZ"INPUT TAPE POS RANGE: "]
	TCL CT,CH               ;LOOKAHEAD FOR CR OR ?
	CAIN CT,TE
	JRST RAN8
	CAIN CH,77
	JRST RAN7               ;HELP THEM SOME
	CAIN CH,127
	JRST RAN9
	PUSHJ P,RANZ##          ;SET RANGE TO ZEROES
RAN1:   PUSHJ P,RDONUM##
	MOVEM N1##
	CAIN CT,CO
	JRST RAN4               ;COMMA
	CAIN CT,DA
	JRST RAN5               ;HYPHEN
	CAIE CT,TE
	JRST RAN6               ;IMPROPER TERMINATOR
RAN2:   MOVEM N2##
	PUSHJ P,SETN12##        ;SET BITS CORRESPONDING TO SELECTED RANGE
	JRST RAN6               ;ILL. POSITION
RAN3:   TRO F,RANFLG            ;RANGE ENTERED
	TLNN F,CUTFLG
RAN3A:  POPJ P,                 ;RETURN FROM RAN
	ERT [XWD[RAN3A],[ASCIZ"ARE YOU SURE? _F_G"]] ;[16.5] Ding Ding
	JRST NEWR1A##           ;YOU SAID NO
RAN4:   MOVEM N2                ;ONE POS. SELECTED BUT DON'T STOP HERE
	PUSHJ P,SETN12
	JRST RAN6               ;ILL. POSITION
	JRST RAN1               ;GET NEXT POS.
RAN5:   PUSHJ P,RDONUM
	CAIE R0,0               ;PERHAPS THEY TYPED "E"
	JRST .+3                ;NOPE
	CAIN CH,ECHR##
	MOVEI R0,RANSIZ##*44-1    ;ASSUME END
	CAIN CT,DA
	JRST RAN6               ;MAY NOT TERMINATE WITH DASH
RAN5A:  CAIN CT,TE
	JRST RAN2               ;END OR RANGE TERM. BY CR
	CAIN CT,CO
	JRST RAN4
	CAIN R0,RANSIZ*44-1
	CAIE CH,ECHR
	JRST RAN6
	TCI CT,CH               ;GET REAL DELIMITER AFTER "E"
	JRST RAN5A
RAN6:   CLRIN
	JRST RAN
RAN7:   TYPE [ASCIZ"
TAPE POSITION NOS. MAY BE ENTERED SEPARATED BY COMMAS OR SPACES.
A HYPHEN MAY BE USED TO SEPARATE A RANGE OF TAPE POS. NUMBERS.
THE NUMBER SPECIFIED AS THE END OF THE RANGE MUST BE GREATER
"]
	TYPE [ASCIZ"THAN THE START OF THE RANGE.  AN 'E' MAY BE USED TO DENOTE
THE GREATEST POSSIBLE END OF RANGE."]
	TYPE [ASCIZ"  A CARRIAGE RETURN MAY BE USED
TO DEFAULT TO ALL POSSIBLE TAPE POSITIONS, LIKE '1-E'.
"]
	TYPE [ASCIZ"A 'W' PRINTS THE LAST KNOWN TAPE POSITION.
A '?' OR 'H' REPRINTS THIS MESSAGE.
"]
	JRST RAN6
RAN8:   TCI CT,CH       ;EAT CR
	PUSHJ P,RANO##          ;SET RANGE TO ONE'S
	JRST RAN3
RAN9:   TCI CT,CH
	CAIE CT,TE
	JRST RAN9
	PUSHJ P,WHERE
	JRST RAN

; CHECK TO SEE IF FILE SELECTED.  FILE NO. IN R1
; SKIP IF BIT SET (FILE SELECTED)

CKNRAN: IDIVI R1,44
	MOVEI R0,1
	LSH 0,(R2)
	TDNE R0,RANGE##(R1)
	AOS (P)
	POPJ P,

; PRINT LAST TAPE POSITION SCANNED

WHEROU::PUSHJ P,WHERE
	JRST CDISP
WHERE:  SKIPE CURPOS
	ERT [XWD[CURPOS],[ASCIZ"LAST KNOWN POS WAS _H$"]]
	SKIPN CURPOS
	TYPE [ASCIZ"POSITION UNKNOWN$"]
	POPJ P,

; CUT TAPE.  USES RESTORE CODE TO POSITION FILE.

CUTROU::MOVEI R1,2
	MOVE R1,CTABL2(R1)      ;FETCH COMMAND STATE
	SKIPN STRFIL
	CAMG R1,[2,,777777]     ;CHECK INDIVIDUAL FILES
CUTT0:  ERROR [ASCIZ"COMMAND ERROR--EXPECTED FILENAME"]
	LDB R2,[XWD CNTFP+R1,0]
	CAIE R2,CNTFT           ;LOOK FOR CR TERMINATOR ON PPN
	AOJA R1,.-2
	MOVS R2,1(R1)           ;FETCH FILENAME BACKWARDS
	LDB R1,[XWD CNTFP+R1,2] ;LOOK AT TERMINATOR
	CAIN R1,CNTFT           ;MUST BE TERMINATOR (SINGLE FILE)
	CAIN R2,(SIXBIT/ALL/)
	JRST CUTT0
	SKIPGE SENTAB+1
	ERROR [ASCIZ"TAPE NEEDS A WRITE RING"]
	HRREI R1,-1             ;USE RESTORE CODE
	TLZ F,DIRFLG+STOFLG     ;NOT DIR AND NOT STORE
	TLO F,CUTFLG            ;CUT
	JRST DIRENT
; JUMP BACK HERE AFTER LOCATING FILE ON TAPE
CUTT2:
	IFL CUTS,<
	XCT MTWAIT(UNIT)        ;WAIT UNTIL INPUT FINISHED
	XCT MGET2(UNIT)
	TRZ R2,760000
	IORI R2,SYNCIN  ;CHANGE TO SYNCHRONOUS INPUT
	XCT MSET2(UNIT)
	MOVEI R1,1
FWD:    CAIN R1,TAPN
	JRST BACK
	AOS R1
	XCT MIN(UNIT)
	JRST .+1
	STATO TAP,760000
	JRST FWD
; EOF, ERROR, OR TAPN REACHED
BACK:   XCT MF7(UNIT)   ;BACK RECORD
	XCT MF0(UNIT)
	SOJG R1,BACK
	XCT MCLOS(UNIT)
	XCT MGET2(UNIT)
	TRZ R2,760000
	IORI R2,SYNCIN
	XCT MSET2(UNIT)
; SKIP FORWARD TO FILE HDR
CUTT3:  PUSHJ P,TAPIN
	JRST CUTT7
	JRST CUTT4(R1)          ;TRAILER, HEADER OR FILE HDR
	JRST CUTT3
CUTT4:  JRST CUTT3
	MOVE R2,TAPHED
	MOVE U,5(R2)
	PUSHJ P,CKNPPN
	JRST CUTT3
	MOVE R2,TAPHED
	MOVE U,6(R2)
	HLRZ W,7(R2)
	PUSHJ P,CKNFIL
	JRST CUTT3
; FOUND CUT FILE.  NOW POSITION JUST PAST LAST RECORD
	>
CUTT5:  MOVE R1,[XWD CURPPN,CUTPPN]
	BLT R1,CUTTIM
CUTT5A: PUSHJ P,TAPIN
	JRST CUTT6      ;EOF
	JRST CUTT6      ;OTHER
	JRST CUTT5A     ;DATA
; BACK EXACTLY ONE RECORD
CUTT6:  XCT MF7(UNIT)
	XCT MF0(UNIT)
	MOVE R1,[XWD CUTPPN,CURPPN]
	BLT R1,DATTIM
; SET UP TO WRITE TRAILER
	SETZM STRPPN
	SETZM STRFIL
	SETZM STRBLK
	SETZM TAPNUM
	PUSHJ P,WPREP           ;OPENS TAPE FOR WRITE
	TLO F,EOTFND            ;IGNORE EOT LOGIC IN TAPOUT
;                               WILL BE SET PROPERLY BY NEXT OPEN
	PUSHJ P,TRLOUT          ;SETS EOTFLG, DOES CLOSE
	TYPE [ASCIZ"CUT FINISHED--NOW POSITIONED AT LOGICAL END OF TAPE."]
	JRST CDISP
	IFL CUTS,<
CUTT7:  TRNN F,EOTFLG   ;SECOND EOF IN A ROW
	JRST CUTT3
	XCT MF7(UNIT)
	XCT MF0(UNIT)
	ERROR [ASCIZ"UNABLE TO RELOCATE CUT FILE"]
	>

; DIRECTORY, GET, RESTORE

DIRROU::HRREI R1,-1             ;SAME AS RESTORE
	TLZ F,STOFLG+CUTFLG     ;NOT STORE AND NOT CUT
	TLO     F,DIRFLG
	JRST DIRENT
GETROU::MOVE	R1,JBLIC	;GET JOB'S LICENSE
	TLNN	R1,100000	;OP LICENSE SET?
	ERROR	[ASCIZ "OPERATOR LICENSE IS NOT SET.$"]
	SKIPA   R1,[0]          ;GET ROUTINE
RESROU::HRREI   R1,-1           ;RESTORE ROUTINE
	TLZ F,STOFLG+DIRFLG+CUTFLG ;NOT STORE,DIRECTORY, OR CUT
DIRENT: MOVEM R1,GETFLG#        ;FLAG TO DISTINGUISH GET AND RES
	PUSHJ P,CRLS            ;CLOSE NAMES FILE IF OPEN
	TRNE F,TRTFG2  ;HAVE TRANSLATIONS BEEN ENTERED
	TRO F,TRTFLG    ;YES, NOW IN EFFECT
	SETZM GTBLOCK
	SETZM UCOUNT            ;COUNT OF UFD'S SET UP
	SETZM TOTCNT
	SETZM   FILCNT          ;ZERO COUNT OF FILES RESTORED FOR USER
	SETZM TOTBLK            ;ZERO TOTAL BLOCKS IN USER FILES
	SETZM   RCOUNT          ;ZERO COUNT OF FILES RESTORED
	TRNN F,EOTFLG
	JRST CONRES
; IF AT LOGICAL EOT BACKSPACE 1 USER AFTER DIR OR RES COMMAND
	PUSHJ P,SETIN
	XCT MF17(UNIT)
	XCT MF17(UNIT)
	XCT MF0(UNIT)
	PUSHJ P,CLRTAP  ;CLOSE TAPE AND CLEAR FLAGS
CONRES: MOVEI R1,15
	MOVEM R1,ERC
	PUSHJ   P,SETIN         ;ENSURE BUFFERS
	TRZ F,FNDFLG+RANFLG+EOFFLG+EOTFLG+SSCFLG+UNMFLG+HDRMSG+HDRFND
	TLNE F,BOTFLG           ;ARE WE AT BEGINNING OF TAPE
	TRO F,SSCFLG            ;YES, DIR CAN PRINT SAVE SET NOS.
	TRO F,IGNFLG            ;IGNORE DATA RECORDS FOR AWHILE
	TLZ F,INIFLG            ;TAPE NO LONGER INITIALIZED
	SETZM NULSW#            ;SWITCH USED BY CKNNUL
	SETZM DIRSSC            ;WORKING ON SAVE SET ZERO
	PUSHJ P,ZPOS            ;ZERO POSITIONAL INFORMATION

; LOOP FOR READING TAPE, DRIVEN BY RECORD TYPE

READTAP:PUSHJ P,TAPIN
	JRST EOFRD      ;READ EOF
	JRST HTDRD      ;READ HEADER,TRAILER,OR DIR RECORD

; DATA RECORD RECEIVED

	TRNE F,IGNFLG           ;SKIP IF WE ARE NOT IGNORING THIS FILE
	JRST READTAP            ;GET NEXT RECORD
; ENTRY PT. FROM DIR RECORD
XFER1:  MOVE R0,CKSUM
	AOS TAPHD2
XFER2:  SOSLE TAPHD2
	JRST XFER2A     ;DATA REMAINING IN TAPE BUFFER
	MOVEM R0,CKSUM
	JRST READTAP    ;GET NEXT RECORD
XFER2A: ILDB R1,TAPHD1  ;FETCH TAPE DATA WD
	TLNE F,DIRFLG   ;DIRECTORY COMMAND
	JRST XFER2E     ;YES
	SOSLE FILHD2    ;IS DISC BUFFER FULL
	JRST XFER2B     ;NO
	MOVEM PCKSUM            ;CHECKSUM OF LAST COMPLETE BLOCK
	OUT FIL,
	AOSA BLKCNT     ;SUCCESSFUL
	ERB [XWD[FILDI1
WRITER],[ASCIZ"ERROR WRITING TO FILE _Z.$SKIPPING REMAINDER OF FILE--_E"]]
XFER2B: SOSL TAPCNT
	IDPB R1,FILHD1
XFER2D: SKIPL TAPCNT
	JRST XFER2C     ;NOT YET REACHED END
	TRNE F,NEWFLG   ;TAPE FORMAT 14 OR GREATER
	MOVEM R1,TAPCK# ;SAVE LAST WORD WRITTEN PAST END OF DATA
	JRST XFER2
XFER2C: AOS WDCNT
	ROT R0,7
	XOR R0,R1
	AOJA R0,XFER2
; FAKE DISC OUTPUT FOR DIR
XFER2E: SOSLE FILHD2    ;FAKE DISC OUTPUT
	JRST XFER2F
	MOVEM PCKSUM            ;CHECKSUM OF LAST COMPLETE BLOCK
	MOVEI R2,200
	MOVEM R2,FILHD2
	AOS BLKCNT
XFER2F: SOS TAPCNT
	JRST XFER2D

; HEADER, TRAILER, OR DIR. RECORD READ

HTDRD:  JRST .+2(R1)
	JRST TRLRD              ;(-1) TRAILER
	JRST HDRRD              ;( 0) HEADER
; FILE HEADER (DIR)              (+1) DIR
	TRNN F,NEWFLG           ;TAPE VERSION 14 OR GREATER
	JRST FHDR0              ;OLD TAPE FILE
	PUSHJ P,POSTAP          ;SKIP IF TAPE POSITIONED
	JRST READTAP            ;KEEP READING UNTIL TAPE POSITIONED
; FINISH UP FILE
FHDR0:  TRNN F,IGNFLG           ;ARE WE PROCESSING A FILE
	PUSHJ P,CLTFIL          ;YES, CLOSE, TRUNCATE, AND SET IGNFLG
; FINISH UP USER
	MOVE R1,CURPPN
	SKIPE LSTPPN    ;IF LSTPPN=0 THERE CAN BE NO USER TOTAL
	CAMN R1,LSTPPN          ;DID WE FIND A NEW USER
	JRST FHDR0.     	;NO
	SOS CURPOS		;[16.4] Previous user ended 1 before here
	PUSHJ P,RPRTU           ;YES, TOTAL USER AND CLEAR UNMFLG
	AOS CURPOS		;[16.4] Restore current position
; DO WE HAVE ANYTHING TO DO
FHDR0.: PUSHJ P,CKNNUL
	JRST EOT4               ;FINISHED
; CHECK TO SEE IF RANGE SELECTED
	TRNN F,NEWFLG
	JRST FHDR7              ;OLD TAPE--DON'T CHECK RANGE
; COMPATIBILITY CHECKS FOR NEW TAPE
	PUSHJ P,COMPA
	JRST EOT4               ;INCOMPATIBLE--OPERATOR ABORT
	MOVE R1,CURPOS
	CAMLE R1,RANLAS##       ;GONE PAST LAST OF RANGE
	JRST EOT4               ;YES--TREAT LIKE LOGICAL EOT
	PUSHJ P,CKNRAN          ;SKIP IF FILE IN SELECTED RANGE
	JRST READTAP            ;BYPASS
; CHECK TO SEE IF FILE SELECTED
FHDR1:  SETZM PPN               ;ZERO TRANSLATE PPN
	MOVE R2,TAPHED          ;CURRENT BUFFER PTR
	MOVE    U,5(R2)         ;GET PPN
	MOVEI R1,2
	HLRZ R1,CTABL2(R1)      ;GET STATE
	CAIG R1,0       ;SKIP UNLESS ALL FILES INTENDED
	TRNN F,TRTFLG   ;ARE WE TRANSLATING
	JRST FHDR8      ;MATCH TAPE PPN AGAINST COMMAND LIST
	PUSHJ P,FINUN## ;LOOK FOR TAPE NAME IN TRANSLATION TABLE
	JRST READTAP    ;NOT FOUND
	MOVEM PPN       ;RESTORE FILE TO DIRECTORY SPECIFIED BY TABLE
	JRST FHDR9

FHDR8:  PUSHJ   P,CKNPPN        ;SEE IF THIS PPN SHOULD BE RESTORED
	JRST    READTAP          ;IGNORE THIS USER
FHDR9:  MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
	MOVE    U,6(R2)         ;GET FILE NAME
	HLRZ    W,7(R2)         ;GET EXTENSION
	PUSHJ   P,CKNFIL        ;SKIP IF THIS FILE SHOULD BE RESTORED
	JRST    READTAP          ;IGNORE THIS FILE
; CUT COMMAND EXITS HERE, HAVING LOCATED THE CUT FILE
	TLNE F,CUTFLG
	JRST CUTT2
	JRST FHDR6

; BYPASS OLD TAPE FILES FOR CUT COMMAND OR WHILE POSITIONING TAPE
; TO A NEW SECTION.  IF TAPE HAS BEEN POSITIONED, WE HAVE HIT
; AN OLDER SECTION FOLLOWING A NEWER SECTION (PROBABLY PUT ON BY TEX 12)
; IN THIS CASE IT IS NOT SAFE TO RESTORE THE FILE SINCE IT MAY
; OVERWRITE A FILE ALREADY RESTORED.  PRINT IN DIRECTORY, HOWEVER.
FHDR7:  TRNN F,TRTFLG           ;TRANSLATE TOO DANGEROUS FOR OLD TAPE FILES
	TLNE F,CUTFLG
	JRST READTAP            ;CUT TOO DANGEROUS FOR OLD TAPE FILES
	TRNN F,RANFLG           ;TAPE IS NOT POSITIONED BUT RANGE HAS
;                               BEEN ENTERED.  WE SOMEHOW GOT ONTO
;                               AN OLDER SECTION OF TAPE.
	JRST FHDR7C             ;TAPE NOT BEING POSITIONED
	TRNE F,FNDFLG
	TLNN F,DIRFLG
	JRST READTAP            ;EITHER NOT POSITIONED OR RESTORE COMMAND
; OLD TAPES MUST HAVE READ HEADER IN ORDER TO CORRECTLY
; DO DATE CONVERSION.  HERE WE REWIND TAPE IF NO HEADER WAS FOUND.
FHDR7A: TRNE F,HDRFND
	JRST FHDR7B             ;PRINT HEADER MESSAGE IF NOT DIR
	TYPE [ASCIZ"MISSED SAVE SET HEADER NEEDED TO DO DATE CONVERSION
"]
	TYPE [ASCIZ"TYPE CR TO PROCEED ASSUMING P012 STYLE DATES
"]
	TYPE [ASCIZ"TYPE NO TO REWIND TAPE AND ABORT:"] ;[16.5] Ding Ding
	TRO F,HDRFND+HDRMSG
	TLO F,T12FLG
	ERO [XWD[FHDR1],[ASCIZ"_F_G"]]
	PUSHJ P,REWWAI
	JRST EOT4
FHDR7B: TLNN F,DIRFLG
	PUSHJ P,HDRPRI          ;HELPS OPER TO KNOW WHERE TAPE IS POSITIONED
	JRST FHDR1              ;CHECK TO SEE IF FILE SELECTED
FHDR7C: TRNE F,RANCMD           ;HAS RANGE BEEN PRE-ENTERED FROM DISPATCHER
	JRST READTAP            ;YES, IGNORE TEX FILES UNTIL WE REACH
;                               FIRST TITO FILE AND SET RANFLG
	JRST FHDR7A             ;NO, CHECK THE FILE
; ZERO CKSUM IF FILE NOT SPLIT

FHDR6:  SKIPN STRBLK
	SETZM CKSUM
	TLNN F,DIRFLG
	JRST FHDR3              ;RESTORE OR GET
; PRINT DIRECTORY INFO
; PRINT HEADER MESSAGES FOR DIR
	PUSHJ P,HDRPRI
	SKIPN STRBLK            ;ARE WE LOOKING FOR SPLIT FILE
	JRST FHDR1A                 ;NO
	PUSHJ P,XFER4E          ;CHECK FILE PPN AGAINST STRPPN, ETC.
	ERB [XWD[STRBLK
CURPPN],[ASCIZ"STARTING WITH BLOCK _C OF FILE _J.$"]]
	MOVE R1,STRBLK
	MOVEM R1,OLDBLK
	Sos Oldblk		; Decrement so never off by 1	[16.0]
	SETZM STRBLK
FHDR1A: TRON F,UNMFLG           ;HAS USER HEADING PRINTED
	ERO [XWD 0,[ASCIZ"$POSITION    FILE NAME      USER NAME     CREATION DATE     DATE WRITTEN  SIZE CHECKSUM$"]]
	MOVE R1,TAPHED
	MOVE R1,37(R1)
	MOVEM R1,BLKSIZ#        ;ALLOCATED FILE SIZE IN BLOCKS
	SKIPN OLDBLK    ;IS FILE SPLIT
	ADDM R1,TOTBLK          ;NO, TOTAL BLKS ALLOCATED TO THIS USER
	TRNE F,NEWFLG
	JRST FHDR2
	ERO [XWD[TAPHED
TAPHED
TAPHED
BLKSIZ
XWD 12,5],[ASCIZ"           _Q     _M  _R                 _N$"]]
	JRST FHDR3
FHDR2:  ERO [XWD[CURPOS
XWD 10,5
CURNUM
XWD 12,3
TAPHED
TAPHED
TAPHED
CURDAT
BLKSIZ
XWD 12,5],[ASCIZ"_N_N   _Q     _M  _R  _L_N "]]
; CHECK FOR PPN.UFD FILES IN [1,1]
FHDR3:  HRLEI R0,0
	TRNE F,NEWFLG
	MOVE CURPOS
	MOVEM POSITION#         ;SAVE FOR CLTFI2
	MOVE R2,TAPHED          ;CURRENT BUFFER PTR
	MOVE U,5(R2)            ;GET THE PPN
	HLRZ    R1,7(R2)        ;GET THE EXTENSION
	CAMN    U,SYSPP         ;SKIP IF NOT USER 1,1 (UFD)
	CAIE    R1,(SIXBIT /UFD/)
	SKIPA                   ;NOT A UFD IN 1,1
	JRST    SETST1          ;MAKE SURE THE UFD IS SET UP
; FILE IS SELECTED FOR RESTORE OR GET
	SETZM WDCNT
	SETZM BLKCNT
	SETZM FILHD2
	SETZM TAPCK
	SETZM ORBSIZ            ;ZERO ORBSIZ FOR ENTER
; REMOVE HEADER WORDS FROM BEGINNING OF FILE
	MOVEI   R1,42
	TRNE F,NEWFLG
	MOVEI R1,XHDRN
	ADDM    R1,TAPHD1
	MOVN R1,R1
	ADDM    R1,TAPHD2
; MOVE HEADER WORDS TO FILDIR
	MOVE R2,TAPHED
	MOVSI R1,4(R2)
	HRRI R1,FILDIR
; DIRECTORY.  JUST CALCULATE OLDBLK, TAPCNT
	TLNE F,DIRFLG
	JRST FHDR5              ;FAKE FILE OPENING
; FILE.  SETUP FILE OPENING AND POSITIONING TO CORRECT BLOCK.
	BLT     R1,FILDIR+XLOOKN
	SKIPN FILCNT		;[16.4] First file for this user?
	ERO [XWD[FILDI1
CURPOS],[ASCIZ"_Y START POS _H - "]]	;[16.4]
	MOVE    R1,UPDFLG       ;SAVE UPDFLG
	MOVEM   R1,UPDMOD       ;IN UPDATE MODE SWITCH
	SETZM   FRBPOS          ;DON'T WORRY ABOUT TRACKS AND CYLINDERS
	SETZM   FRBNXT          ;RESERVED FOR FUTURE USE
	MOVE R1,FRBSIZ
	ADDI R1,177
	LSH R1,-7
	CAMLE R1,FRBALC
	MOVEM R1,FRBALC         ;ASSURE ESTIMATED SIZE IS SUFFICIENT
	MOVE    R1,FRBALC       ;GET NUMBER OF ALLOCATED BLOCKS
	SETZM   FRBALC          ;DON'T NEED STORAGE IN ONE BIG BLOCK
	MOVEM   R1,FRBEST       ;GET THE STORAGE IN ANY WAY POSSIBLE
	CAIG    R1,5            ;IGNORE UPD FLAG ON SMALL FILES
	SETZM   UPDMOD          ;SMALLER THAN 6 BLOCKS
	MOVEM   R1,TRBALC       ;REMEMBER FILE SIZE
	TLNN    F,P12FLG        ;SKIP IF MONITOR P012 OR LATER
	JRST    RP11            ;RUNNING ON MONITOR P011
	TLNE    F,T12FLG        ;SKIP IF OLD FORMAT TAPE
	JRST    DCDONE          ;NEW MONITOR AND NEW TAPE - NO CONVERSION
	LDB     R1,[POINT 12,FILDI4,35] ;NEW MONITOR AND OLD TAPE
	MOVEM   R1,CNVDAT       ;SAVE LOW ORDER BIT OF CREATION DATE
	LDB     R1,[POINT 2,FILDI3,21] ;GET HIGH DATE BITS
	DPB     R1,[POINT 2,CNVDAT,23] ;SAVE HIGH CRE DATE BITS
	LDB     R1,[POINT 11,FILDI4,23] ;GET CREATION TIME
	IMUL    R1,JIFFPM       ;CONVERT MINUTES TO JIFFIES
	MOVEM   R1,CNVTIM       ;SAVE CREATION TIME
	MOVE    R1,[XWD 50,400020] ;CONVERT OLD TO NEW
	MOVEM   R1,CNVFMT       ;SAVE CONVERSION FORMAT
	MOVEI   R1,CNVDAT       ;GET ADDRESS OF CONVERSION TABLE
	DATUUO  R1,             ;CONVERT DATE AND TIME
	ERB [XWD[CURPPN],[ASCIZ "DATE CONV ERR ON _Z. CONTINUING..."]]
	MOVE    R1,CNVDAT       ;GET THE NEW CREATION DATE
	DPB     R1,[POINT 12,FILDI4,35]
	LDB     R1,[POINT 2,CNVDAT,23] ;GET HIGH CRE DATE BITS
	DPB     R1,[POINT 2,FILDI3,21] ;SAVE THE HIGH CRE DATE BITS
	MOVE    R1,CNVTIM       ;GET THE NEW CREATION TIME
	MOVEM   R2,CNVTIM       ;SAVE R2 IN TEMP CELL
	IDIV    R1,JIFFPM       ;CONVERT JIFFIES TO MINUTES
	MOVE    R2,CNVTIM       ;RESTORE R2
	DPB     R1,[POINT 11,FILDI4,23] ;SAVE THE CREATION TIME
	LDB     R1,[POINT 14,FILDI3,35]
	MOVEM   R1,CNVDAT       ;SAVE THE ACCESS DATE
	SETZM   R1,CNVTIM       ;ZERO THE ACCESS TIME
	MOVE    R1,[XWD 0,400000] ;CONVERT OLD TO NEW
	MOVEM   R1,CNVFMT       ;SAVE THE CONVERSION FORMAT
	MOVEI   R1,CNVDAT       ;GET ADDRESS OF THE CONVERSION TABLE
	DATUUO  R1,             ;CONVERT THE ACCESS DATE
	ERB [XWD[CURPPN],[ASCIZ "DATE CONV ERR ON _J. CONTINUING..."]]
	MOVE    R1,CNVDAT       ;GET THE NEW ACCESS DATE
	DPB     R1,[POINT 14,FILDI3,35] ;SAVE THE ACCESS DATE
DCDONE: INIT    FIL,BUFBIN
	SIXBIT  /DSK/
	XWD     FILHED,0
	ERROR   [ASCIZ "DISC NOT AVAILABLE"]
	MOVEI   R1,FILBUF
	MOVEM   R1,JOBFF        ;FAKE OUT OUTBUF
	OUTBUF  FIL,FILN
	GETPPN  R1,             ;GET PPN OF TITO USER
	TLN                     ;NOP
	SKIPE   GETFLG          ;SKIP IF GET COMMAND
	MOVE R1,FILDI1
	SKIPE PPN
	MOVE R1,PPN             ;TRANSLATE OPTION
	MOVEM   R1,FILDI1       ;REPLACE TAPE PPN WITH MINE
	PUSHJ   P,CKLIC
	HRLZI   R1,RCHGBT       ;GET THE RIB CHANGED BIT
	SKIPE FLGOFF    ;SHOULD WE MARK FILE DUMPED
	IORM R1,FRBNCA  ;YES
	SKIPN FLGOFF    ;SHOULD WE MARK FILE NOT DUMPED
	ANDCAM R1,FRBNCA ;YES
	MOVE    R1,FRBSTS       ;GET STATUS WORD OF FILE ON TAPE
	TRNE    R1,.RPBAD       ;SKIP IF FILE NOT BAD ON TAPE
	ERB [XWD[FILDI1
XFER3D],[ASCIZ "NOT RESTORING _J.  IT IS BAD ON TAPE.$_E"]]
	HRLI    R1,FILDIR       ;SETUP SAVE
	HRRI    R1,SAVBUF       ;OF FILE PARAMETERS
	BLT     R1,SAVBUF+XLOOKN        ;IN "SAVBUF"
	MOVE R1,FILDI3 ;SAVE EXTENSION AND CONVERTED DATE
	MOVEM R1,SEXT   ;IN CASE OF ENTER ERROR RETURN
;                               IN NEWEST FILE MODE SAVE
;                               CREATION DATE.  REQUIRES EXTRA
;                               LOOKUP.
	MOVE    R1,FILDI1       ;PICKUP FILE PPN
	LDB     R2,MOPTR##      ;GET MODE FOR DISC FILE
	CAMN    R1,[XWD 1,4]    ;SKIP IF NOT SYS PPN
	LDB     R2,MSYPTR##     ;GET MODE FOR SYS FILES
	CAIN    R2,MOMNEW##     ;SKIP IF NEWEST FILE OPTION NOT SELECTED
	JRST    GCREDAT         ;GET CREATION DATE
UTRY:   SKIPN   UPDMOD  ;SKIP IF UPDATE MODE
	SKIPE   STRBLK  ;NO SKIP IF CONTINUED FILE
	PUSHJ   P,XFER4 ;DO LOOKUP AND MOVE TRBALC TO FRBALC
RTRY:   SKIPE   FRBPOS          ;BETTER BE ZERO
	PUSHJ P,RBER            ;REPORT AND FIX .RBPOS
	SKIPE PRAFLG
	JRST .+3
	SETZM FRBALC
	SETZM FRBEST
	ENTER   FIL,FILDIR      ;ATTEMPT ENTER
	JRST    CKER    ;EVALUATE ERROR
;       MOVE R1,FRBALC
;       CAMGE R1,TRBALC         ;BETTER BE ENOUGH
;       JRST NOROOM             ;FILE TOO FAT
	SKIPE   STRBLK          ;SKIP IF FILE NOT SPLIT
	PUSHJ   P,FSTWRD        ;SET POSITION IN FILE
	MOVEI   R1,0            ;ASSUME ZERO IN CASE FILE IS SPLIT
	SKIPN   OLDBLK          ;SKIP IF FILE NOT SPLIT
;                               NO SKIP IF SECOND PART OF CONTINUED FILE
	MOVE    R1,FILDI3       ;GET OLD/NEW BIT FOR THIS FILE
	TRNE    R1,400000       ;SKIP IF NEW FILE OR SPLIT FILE
	JRST    XFER3A          ;SEE IF HE REALLY WANTS TO WRITE FILE
XFER3C: SKIPE   R1,OLDBLK       ;CALCULATE
	LSH     R1,7            ;REMAINING (SKIPPED IF 0)
	SUB     R1,TRBSIZ       ;TAPE WORDCOUNT
	MOVNM  R1,TAPCNT       ;SAVE FOR USE AT XFER2B:
	TRZ F,IGNFLG            ;RESET TO HANDLE DATA RECORDS
	JRST XFER1              ;NOW MOVE DATA TO DISC FILE

; DIRECTORY. FAKE FILE OPENING.

FHDR5:  BLT R1,FILDIR+3         ;NEEDED AT CLTFI5
	MOVE R1,11(R2)          ;FILE SIZE IN RIB
	MOVEM R1,TRBSIZ
	JRST XFER3C

; ENTER FAILED.  PERHAPS DISC ALLOCATION WAS INSUFFICIENT.
; IF WE ARE GOUGING FILE CHECK PROGRESS AND RETRY.

CKER:   MOVE R1,SEXT    ;RESTORE FILE EXTENSION
	EXCH    R1,FILDI3       ;DESTROYED BY ERROR CODE
	HLLI    R1,
	MOVEM   R1,ERCODE       ;SAVE FOR THE CURIOUS
	CAIE    R1,17   ;KLUDGE TO GET MORE SPACE IN UPDATE MODE
	JRST    TWHY    ;EXPLAIN TRANSGRESSIONS
	MOVE    R1,FRBALC       ;CHECK PROGRESS
	CAMN    R1,ORBALC       ;DID WE GET ANY
NOROOM: ERB [XWD[FILDI1
XFER3D],[ASCIZ"BYPASSING _J.  NOT ENOUGH DISC SPACE.$_E"]]
	SKIPN   UPDMOD  ;WAS FILE IN UPDATE MODE
	SKIPE   STRBLK  ;OR SPLIT
	JRST    .+2     ;TRY TO GET MORE SPACE
	JRST    NOROOM
	MOVEM   R1,ORBALC       ;MOVE FRBALC TO ORBALC
	CLOSE   FIL,DLL!DNC
	LOOKUP  FIL,FILDIR
	JRST NOROOM
	PUSHJ P,FI      ;RESTORE PARAMETERS AND MOVE TRBALC TO FRBALC
	JRST    RTRY    ;TRY TO ENTER FILE
TWHY:   ERB [XWD[FILDI1],[ASCIZ"CANNOT ENTER _Z---"]]
	PUSHJ   P,WHY
	JRST    XFER3D

; MONITOR VERSION P011.  HANDLE TAPES WRITTEN WITH TEX VER 12 OR LATER.

RP11:   TLNN    F,T12FLG        ;SKIP IF NEW FORMAT TAPE
	JRST    DCDONE          ;OLD MONITOR AND OLD TAPE SO NO CONVERSION
	SETZ    R1,             ;ZERO R1 FOR DEFAULT CRE AND ACC
	DPB     R1,[POINT 16,FILDI3,35] ;ACC DATE AND HIGH BITS OF CRE
	DPB     R1,[POINT 23,FILDI4,35] ;CRE TIME AND LOW BITS OF CRE DATE
	JRST    DCDONE          ;CONVERSION DONE - CURRENT DATES

; PROGRAM ERROR - RBPOS IS NONZERO.  SET TO ZERO AND PROCEED.

RBER:   ERB [XWD[FILDI1],[ASCIZ"FILE _Z .RBPOS RESET TO ZERO$PROCEEDING O.K.$"]]
	SETZM FRBPOS
	JRST RTRY

;ERROR WRITING TO DISC FILE

WRITER: PUSHJ P,DWHY    ;DECODE WHY WRITE FAILED
	JRST XFER3D     ;IGNORE REST OF FILE

;GET CREATION DATE FOR NEWEST FILE MODE

GCREDAT: LOOKUP FIL,FILDIR      ;DO LOOKUP TO GET CRE DAT
	JRST REBTRY             ;NOT THERE--MUST BE NEW FILE
	MOVE R1,FILDI4
	MOVEM R1,SAVDI4         ;SAVE FOR XFER3N TIME CHECK
	LSHC    R1,-14          ;POSITION LOW ORDER PT IN R2
	LDB     R1,[POINT 2,FILDI3,21]  ;GET HI ORDER PT
	LSHC    R1,14
	MOVEM   R1,CREDSC       ;SAVE FOR USE IN XFER3N
	SKIPN   STRBLK          ;SKIP IF FILE SPLIT
	SKIPN   UPDMOD  ;SKIP IF UPDATE MODE
	JRST    .+3
	PUSHJ   P,FII        ;DO UPD MODE ONLY PART OF XFER4
	JRST    RTRY            ;SAVES DOING EXTRA LOOKUP
	CLOSE   FIL,DNC!DLL
REBTRY: HRLI    R1,SAVBUF       ;RESTORE ENTER BUFFER
	HRRI    R1,FILDIR
	BLT     R1,FILDIR+XLOOKN
	JRST    UTRY

; CONFIRM WRITING OVER OLD FILE

XFER3A: MOVE    R1,FILDI1       ;GET PPN FOR THIS FILE
	LDB     R2,MOPTR##      ;GET MODE FOR DSK FILES
	CAMN    R1,[XWD 1,4]    ;SKIP IF NOT SYS FILE
	LDB     R2,MSYPTR##     ;GET MODE FOR SYS FILES
	CAIN    R2,MOMDIS##     ;DON'T SKIP IF WE SHOULD KEEP DISC FILE
	JRST    XFER3E          ;KEEP DISC FILE
	CAIN    R2,MOMTAP##     ;DON'T SKIP IF WE SHOULD KEEP TAPE FILE
	JRST    XFER3B          ;RESTORE FILE FROM TAPE
	CAIN    R2,MOMNEW##     ;DON'T SKIP IF WE SHOULD KEEP NEWEST FILE
	JRST    XFER3N          ;KEEP NEWEST FILE
	ERT [XWD[FILDI1
	XFER3C],[ASCIZ "OK TO WRITE OVER _Z? _F_G"]] ;[16.5] Ding Ding
	SKIPA                   ;DON'T PRINT THE IGNORE MESSAGE
XFER3E: ERO     [XWD [FILDI1],[ASCIZ "NOT WRITING OVER FILE _Z.$"]]

; BYPASS FILE ON TAPE, ALREADY OPENED

XFER3D: CLOSE   FIL,RST         ;CLOSE FILE AND KEEP IT OUT OF DIR
	TRO     F,IGNFLG        ;IGNORE REMAINDER OF FILE DATA
	JRST READTAP

; WRITE OVER DISC FILE

XFER3B: ERO     [XWD [FILDI1],[ASCIZ "WRITING OVER FILE _Z.$"]]
	JRST    XFER3C          ;CONTINUE AS USUAL

; COMPARE CREATION DATES IN NEWEST FILE MODE

XFER3N: MOVE    R1,FILDI4       ;GET CREATION DATE FROM TAPE FILE
	LSHC    R1,-14          ;POSITION IN R2
	LDB     R1,[POINT 2,FILDI3,21]  ;GET HI ORDER BITS
	LSHC    R1,14           ;REPOSITION IN R1
	CAMGE   R1,CREDSC       ;SKIP IF TAPE > (NEWER) DISC
	JRST    XFER3E          ;DON'T RESTORE FILE
	CAME    R1,CREDSC       ;SKIP IF DATES EQUAL
	JRST    XFER3B          ;RESTORE THE FILE FROM TAPE
	MOVE    R1,SAVDI4       ;GET CREATION DATE FROM DSK FILE
	MOVE    R2,FILDI4       ;GET CREATION DATE FROM TAP FILE
	AND     R1,[XWD 37,770000] ;THROW AWAY ALL BUT TIME BITS
	AND     R2,[XWD 37,770000] ;THROW AWAY ALL BUT TIME BITS
	CAML    R1,R2           ;SKIP IF TAPE FILE NEWER
	JRST    XFER3E          ;DON'T RESTORE FILE
	JRST    XFER3B          ;RESTORE THE FILE FROM TAPE

; HANDLE UPDATE MODE AND SPLIT FILES.  PERFORM LOOKUP

XFER4:	SKIPE	STRBLK     ;IF NOT SPLIT, MUST BE UPDATE MODE
	PUSHJ P,XFER4E          ;CHECK FILE PPN AGAINST STRPPN, ETC.
	LOOKUP  FIL,FILDIR      ;OPEN FILE FOR INPUT
	JRST    XFER4C          ;SOME KIND OF LOOKUP PROBLEM
FII:    MOVE R1,FRBSIZ  ;SIZE OF FILE ON DISC
	MOVEM R1,ORBSIZ ;SAVE FOR USE BY TRUNCATE
FI:     HRLI    R1,SAVBUF       ;SETUP UNSAVE
	HRRI    R1,FILDIR       ;OF FILE PARAMETERS
	BLT     R1,FILDIR+XLOOKN        ;FROM SAVBUF TO FILDIR
	MOVE    R1,TRBALC       ;TRY TO GET ALLOCATED BLOCKS
	MOVEM   R1,FRBALC       ;FORCE ENTER TO GRAB THEM
	SETZM   FRBEST  ;NORMALLY IGNORED BY ENTER FOLLOWING LOOKUP
	HRRZI   R1,400000       ;TURN ON OLD FILE BIT UNCONDITIONALLY
	IORM    R1,FILDI3       ;SINCE NOT DONE BY LOOKUP-ENTER
	POPJ    P,              ;RETURN FROM XFER4
; LOOKUP FAILURE IN UPDATE MODE.  MAYBE IT IS A NEW FILE.
XFER4C: MOVE R1,SEXT
	EXCH    R1,FILDI3
	HLLI    R1,
	MOVEM   R1,ERCODE       ;SAVE TO DECODE
	SKIPE   UPDMOD          ;FILE NOT FOUND AND UPDATE MODE
	CAIE    R1,0            ;YES, IS ERCODE RIGHT
	JRST    XFER4D          ;NO
	SETZM   UPDMOD          ;NEW FILE ON DISC
;                               AND UPDATE MODE SWITCH SELECTED BY OPER.
;                               OPEN USING ENTER.
	HRLI    R1,SAVBUF
	HRRI    R1,FILDIR
	BLT     R1,FILDIR+XLOOKN
	POPJ    P,              ;TRY TO ENTER FILE
XFER4D: ERB [XWD[FILDI1],[ASCIZ"BYPASSING _Z, LOOKUP FAILURE--"]]
	PUSHJ   P,WHY
	JRST    XFER3D          ;BYPASS FILE

; COMPARE TAPE FILENAME WITH STR FILENAME

XFER4E: MOVE R1,CURPPN
	CAME    R1,STRPPN       ;SKIP IF PPN OF SPLIT FILE
XFER4A: ERT [XWD[STRPPN
CURPPN
CLDSP],[ASCIZ "LOOKING FOR _J ON TAPE, BUT FOUND _J._E"]]
	MOVE    R1,CURFIL       ;GET FILE NAME FROM TAPE
	CAME    R1,STRFIL       ;SKIP IF NAME OF SPLIT FILE
	JRST    XFER4A          ;ERROR
	HLLZ    R1,CUREXT       ;GET EXTENSION FROM TAPE
	CAME    R1,STREXT       ;SKIP IF EXTENSION OF SPLIT FILE
	JRST    XFER4A          ;ERROR
	SETZM   STRPPN          ;ZERO STARTING PPN
	SETZM   STRFIL          ;ZERO STARTING FILE
	SETZM   STREXT          ;ZERO STARTING EXTENSION
	POPJ P,

; SPECIAL HANDLING OF PPN.UFD FILES IN [1,1].  SET UP UFDS.

;*DON'T CREATE UFD FOR GET COMMAND 6/9/73
SETST1: MOVEM U,FILDI1  ;NEEDED BY RPRTU
	HRLZM R1,FILDI3 ;NEEDED TO PRINT FILE EXTENSION
	MOVE R1,6(R2)
	MOVEM R1,FILDI2 ;NEEDED TO PRINT FILENAME
	TLNN F,DIRFLG           ;BYPASS IF DIR COMMAND
	JRST SETST5
	TRNE F,NEWFLG
	ERO [XWD 0,[ASCIZ"$"]]  ;NO CHECKSUM PRINTED
SETST6: PUSHJ P,CLTFI2 ;*RESTORE DOES UNNECESSARY CLOSE OF FIL CHANNEL
	JRST READTAP
SETST5: TLNN    F,UFDFLG        ;SKIP IF JL ST WF LIC SET
	JRST    READTAP          ;NOT ENOUGH LICENSE TO EXECUTE CODE
	MOVEM   U,UFDDI1        ;SAVE PPN FOR UFD LOOKUPS
	MOVE    U,6(R2)         ;GET PPN FOR THIS USER
	PUSHJ   P,CKNPPN        ;SKIP IF USER SHOULD BE SET UP
	JRST    READTAP          ;IGNORE THIS UFD
	MOVE    R1,JBLIC        ;GET THE USER'S LICENSE
	TLNE    R1,1000         ;SKIP IF JL NOT SET
	JRST    SETST4          ;EITHER REFRESH OR SOMEONE WITH JL
	MOVE    R0,U            ;GET PPN IN R0 FOR CALL TO PPNUSR
	PUSHJ   P,PPNUSR        ;SKIP IF NAME IN DUL
	JRST    READTAP          ;DON'T SET UP UFD
SETST4: INIT    UFD,BUFBIN
	SIXBIT  /DSK/
	XWD     0,UFDHED        ;LOOKUPS ONLY
	ERROR   [ASCIZ "CANNOT ACCESS THE DISC."]
	MOVEI   R1,UFDBUF       ;USE THE UFD BUFFERS
	MOVEM   R1,JOBFF        ;TELL MONITOR WHERE TO PUT THE BUFFERS
	INBUF   UFD,UFDN        ;SET UP THE BUFFERS
	MOVEI   R1,XLOOKN       ;SET SPECS FOR LOOKUP
	MOVEM   R1,UFDDIR
	MOVEM   U,UFDDI2        ;SAVE PPN AS NAME OF FILE (UFD)
	HRLZI   R1,(SIXBIT /UFD/);EXT=UFD
	MOVEM   R1,UFDDI3
	MOVEM   U,UFDBL2        ;SAVE THE PPN FOR INTERLOCK
	MOVE    R1,[SIXBIT /DSKB/]
	SETZ    R2,             ;ZERO TO GET FIRST ENTRY ON SEARCH LIST
	SYSSTR  R2,             ;GET NEXT STRUCTURE ON LIST
	SETZ    R2,             ;ERROR RETURN SO FALL THROUGH BELOW
	CAME    R1,R2           ;SKIP IF THIS IS THE RIGHT STRUCTURE
	JUMPN   R2,.-3          ;LOOP IF NOT DONE WITH LIST
	JUMPN   R2,.+3          ;JUMP IF WE FOUND THE STRUCTURE
	SYSSTR  R2,             ;GET FIRST STRUCTURE ON THE LIST AS DEFAULT
	ERROR   [ASCIZ "CANNOT FIND A VALID FILE STRUCTURE."]
	MOVEM   R2,UFDBL1       ;SAVE STRUCTURE FOR INTERLOCK
	PUSHJ   P,SETJL         ;SET THE JL BIT
	ERROR   [ASCIZ "UNABLE TO SET JACCT-LOGIN BIT."]
	PUSHJ   P,SETINT        ;SET THE UFD INTERLOCK
	ERB [XWD[UFDBL2
SETST3],[ASCIZ "UNABLE TO SET UFD INTERLOCK FOR _A.$_E"]]
	LOOKUP  UFD,UFDDIR      ;DOES THIS UFD ALREADY EXIST?
	JRST    FIXUFD          ;NO, MAKE ONE LIKE THE ORIGINAL
SETST2: PUSHJ   P,RESINT        ;RESET THE UFD INTERLOCK
	ERB [XWD[UFDBL2],[ASCIZ "UNABLE TO RESET UFD INTERLOCK FOR _A.  SOMETHING IS WRONG.$"]]
	PUSHJ P,RESJL
	JRST SETST7
	JRST SETST6
SETST3: PUSHJ   P,RESJL         ;RESET THE JACCT-LOGIN BIT
SETST7: ERROR   [ASCIZ "UNABLE TO RESET THE JACCT-LOGIN BIT."]
	JRST    READTAP          ;SKIP TO NEXT UFD OR FILE

;MAKE A UFD ON THIS STR WITH QUOTA FROM THE TAPE
;*PERHAPS THIS SHOULD NOT BE DONE

FIXUFD: MOVE    R2,TAPHED       ;GET ADDR OF CURRENT BUFFER
	INIT    MFD,BUFBIN
	SIXBIT  /DSK/
	XWD     MFDHED,0
	ERROR   [ASCIZ "UNABLE TO ACCESS MFD"]
	MOVEI   R1,UFDDIR
	HRLI    R1,4(R2)
	BLT     R1,UFDDIR+XLOOKN
	MOVE R1,URBALC
	MOVEM R1,URBEST
	SETZM URBALC
	SETZM   URBPOS
	SETZM   URBNXT
	SETZM   URBPRD
	SETZM   URBCSZ          ;ZERO CURRENT SIZE SINCE NO FILES
	ENTER   MFD,UFDDIR      ;CREATE THIS UFD
	ERROR   [ASCIZ "UNABLE TO OUTPUT TO MFD"]
	Move	R1,[.Chfso,,MFD]; Make all UFD's at least 	[15.14]
	Chanio	R1,[4]		;   one page long.  USETO MFD,2	[15.14]
	CLOSE   MFD,DNC         ;CLOSE THE MFD
	RELEAS  MFD,            ;RELEASE THE MFD
	CLOSE   UFD,DNC         ;CLOSE UFD
	AOS     UCOUNT          ;COUNT OF UFD'S SET UP
	JRST    SETST2          ;CLEAR JACCT AND UFD INTERLOCK & GET NEXT UFD

RESJL:  TDZA    R2,R2           ;SET TO ZERO AND ALWAYS SKIP
SETJL:  MOVSI   R2,1            ;SET THE JACCT-LOGIN BIT
	MOVSI   R1,-1           ;GET BITS FOR THIS JOB
	GETTAB  R1,             ;GET BITS SO WE DON'T DESTROY THEM
	ERROR   [ASCIZ "CANNOT DO A GETTAB FOR THIS JOB."]
	TLZ     R1,1            ;ASSUME WE'RE RESETING THE BIT
	TLNE    R2,1            ;SKIP IF BIT SHOULD BE RESET
	TLO     R1,1            ;SET THE BIT
	CALLI   R1,-21          ;FIX THE JAL BIT (SETJAL)
	POPJ    P,              ;NOT ENOUGH LICENSE - FAIL RETURN
	JUMPN   R2,CPOPJ1       ;SUCCESS RETURN FROM SETJL
	HRROI   R1,-24          ;GET TERMINAL BITS
	GETTAB  R1,             ;WE WANT TO KNOW IF PHONE WAS HUNG UP
	SETZ    R1,             ;DETACHED, SO PHONE WAS NOT HUNG
	TLNE    R1,200000       ;SKIP IF PHONE NOT HUNG UP
	EXIT                    ;GET OUT OF PROG AND MONITOR WILL LOGOUT
	JRST    CPOPJ1          ;SUCCESS RETURN FROM RESJL

RESINT: SKIPA   R1,[7]          ;RESET UFD INTERLOCK
SETINT: MOVEI   R1,6            ;  SET UFD INTERLOCK
	MOVEM   R1,UFDBLK       ;SAVE THE FUNCTION TO BE PERFORMED
	MOVEI   R2,550          ;NUMBER OF TIMES TO TRY
RTRINT: MOVE    R1,[XWD 3,UFDBLK];POINTER TO PARAMETER TABLE
	STRUUO  R1,             ;TEST AND SET/RESET UFD INTERLOCK
	SKIPA                   ;FAILED - TRY AGAIN IN ONE SECOND
	JRST    CPOPJ1          ;SUCCESS RETURN FROM SETINT/RESINT
	MOVEI   R1,1            ;NUMBER OF SECONDS TO SLEEP
	SLEEP   R1,             ;DISMISS FOR A SECOND
	SOJG    R2,RTRINT       ;RETRY THE INTERLOCK
	POPJ    P,              ;FAIL RETURN FROM SETINT/RESINT

; TRAILER READ

TRLRD:  TRZ F,HDRMSG+HDRFND     ;CANCEL SAVESET FLAGS
	CLOSE UFD,DNC   ;SEE SETST1
	RELEASE UFD,
	MOVE R2,TAPHED
	SKIPL R1,5(R2)  ;IS TAPE CONTNUED
	JRST TRL6       ;NO
	TLNE R1,FILCTD  ;IS FILE CONTINUED
	JRST TRL5       ;YES
; IF FILE IN PROGRESS THEN FINISH UP
	TRNN F,IGNFLG
	PUSHJ P,CLTFIL  ;CLOSE, TRUNCATE, PRINT FILE NAME IF DESIRED
	MOVE R2,TAPHED
	MOVE R1,5(R2)   ;GET CONTINUED BITS
	TLNN R1,USRCTD  ;IS USER CONTINUED
	JRST TRL3       ;NO
; USER CONTINUED
	ERB [XWD[CURPPN],[ASCIZ"_A WILL BE CONTINUED ON NEXT TAPE.$"]]
; HAVE WE REACHED END OF SELECTED RANGE
TRL4:   MOVE R2,TAPHED
	HLRE R1,2(R2)   ;GET VERSION
	CAIG R1,13
	JRST TRL2       ;OLDER THAN 14--NO POS. NOS.
	MOVE R1,CURPOS
	CAMGE R1,RANLAS ;COMPARE WITH LAST FILE SCANNED BEFORE TRAILER
	JRST TRL2       ;GET NEXT TAPE MOUNTED

; UNIVERSAL ABORT POINT

EOT4:
TRL1:   PUSHJ P,RPRTU   ;PRINT USER TOTALS IF DESIRED
; FINISHED--PRINT GRAND TOTALS
	TRNE F,EOTFLG
	ERB [XWD 0,[ASCIZ"LOGICAL EOT--NO SAVE SETS FOLLOW.$"]]
	ERB [XWD[RCOUNT],[ASCIZ"$TOTAL _C FILES PROCESSED.$$"]]
	PUSHJ P,PFM     ;PRINT FILES MISSED
	SETZM RCOUNT
	JRST CDISP
; MORE FOLLOWS ON NEXT TAPE
TRL2:   SETZM OLDBLK
	PUSHJ P,NXTTAP  ;REWIND CURRENT TAPE, GET NEXT MTD
	JRST CONRES
;USER NOT CONTINUED
TRL3:   PUSHJ P,RPRTU   ;PRINT USER TOTALS IF DESIRED
	JRST TRL4
;FILE IS CONTINUED
TRL5:   TRNN F,IGNFLG
	PUSHJ P,CLFIL   ;CLOSE FILE WITHOUT TRUNCATE OR DEALLOCATE
	MOVE R1,CURPPN
	MOVEM R1,STRPPN
	MOVE R1,CURFIL
	MOVEM R1,STRFIL
	MOVE R1,CUREXT
	HLLZM R1,STREXT ;SAVE FILENAME IN STR FILE
	MOVE R1,BLKCNT  ;COMPUTE BLOCK NO. IN FILE
	ADD R1,OLDBLK   ;BLOCKS FROM PREVIOUS TAPE
	MOVEM R1,STRBLK ;NEW BLOCK NO. TO POSITION TO
	PUSHJ P,PCFM    ;PRINT CONTINUED FILE MESSAGES
	JRST TRL2       ;NOTE TRL2 SETS OLDBLK=0
; TAPE IS NOT CONTINUED
TRL6:   TRNN F,IGNFLG
	PUSHJ P,CLTFIL  ;FINISH CURRENT FILE
	TLNN F,DIRFLG   ;SKIP IF DIRECTORY COMMAND
	JRST TRL7
; PRINT USER AND SAVE SET TOTALS HERE FOR DIRECTORY ONLY
; RESTORE COMMAND WILL PRINT USER TOTALS AT NEXT FILE HDR OR LOGICAL EOT
	PUSHJ P,RPRTU
	SKIPE TOTCNT
	ERO [XWD[TOTCNT],[ASCIZ"$TOTAL _C FILES FOR SAVE SET.$$"]]
	SETZM TOTCNT
; RESTORE MUST STOP ON TRAILER RECORD WHEN READING OLD TAPE SECTION,
; TO PREVENT OVERWRITING FILES WHICH HAVE ALREADY BEEN RESTORED.
TRL7:   TLNE F,CUTFLG+DIRFLG
	JRST READTAP    ;KEEP GOING FOR CUT OR DIR
	MOVE R2,TAPHED
	HLRE R1,2(R2)   ;GET VERSION NO.
	CAIG R1,13      ;SKIP IF 14 OR GREATER
	TRNE F,RANFLG+FNDFLG    ;KEEP GOING ON OLD SECTION IF RESTORING NEW
	JRST READTAP    ;KEEP GOING UNTIL LOGICAL EOT
	JRST TRL1       ;FINISH TAPE(S)

; TAPE HEADER READ

HDRRD:  PUSHJ P,VERFLG  ;GET VERSION FLAGS
	ERB [XWD[READTAP],[ASCIZ"BAD HEADER FOUND_E"]]
	AOS R1,DIRSSC
; SAVE INFO. FROM LAST HEADER READ
;       PRINT LATER IF WE FIND SOMETHING
	MOVEM R1,HDRSSC#        ;SAVE SET NO.
	MOVE R1,FIRBL2
	MOVEM R1,HDRTAP#        ;TAPE NO. IN SAVE SET
	MOVE R1,FIRBL3
	MOVEM R1,HDRDAT#        ;DATE RECORDED
	MOVE R1,5(R2)   ;GET CONTINUED BITS
	MOVEI R2,[ASCIZ""]     ;NULL STRING
	TLNE R1,TAPCTD
	MOVEI R2,[ASCIZ"THIS IS A CONTINUATION TAPE.$"]
	TLNE R1,USRCTD
	MOVEI R2,[ASCIZ"USER CONTINUED FROM PRECEDING TAPE.$"]
	TLNE R1,FILCTD
	MOVEI R2,[ASCIZ"FILE CONTINUED FROM PRECEDING TAPE.$"]
	MOVEM R2,CTDMSG#
	TRZ F,HDRMSG            ;NEED TO PRINT HEADER MESSAGES
	TRO F,HDRFND            ;HEADER FOUND
	JRST READTAP

FSTROU::TLO     F,FAIFLG        ;TAPE DIRECTORY IN FAILSAFE FORMAT
	JRST    CDISP

FCRROU::TLZ     F,FAIFLG        ;TAPE DIRECTORY IN TITO FORMAT
	JRST    CDISP

; GET VERSION FLAGS FROM HEADER OR TRAILER

VERFLG: TLNE    F,FAIFLG        ;TAPE IN FAILSAFE FORMAT?
	JRST    [TLZ F,T12FLG
	         TRZ F,NEWFLG
	         JRST CPOPJ1]   ;IF SO, ASSUME PRE-P012 & PRE-VER14
	MOVE R2,TAPHED
	HLRE R1,2(R2)   ;GET VERSION
	TLO F,T12FLG    ;ASSUME TAPE CREATED VER. 12 OR LATER
	TRZ F,NEWFLG    ;ASSUME OLD TAPE IF HEADER BAD
	CAIG R1,0       ;INSIST ON POS. VER NO
	POPJ P,
	CAIGE R1,11
	TLZ F,T12FLG    ;TAPE WRITTEN BY MONITOR BEFORE P012.
	TRO F,NEWFLG    ;ASSUME VER 14 OR LATER
	CAIG R1,13
	TRZ F,NEWFLG
	JRST CPOPJ1

; PRINT HEADER MESSAGES (DELAYED)

HDRPRI: TROE F,HDRMSG   ;SUPPRESS FURTHER SAVESET HEADER MESSAGES
	POPJ P,
	TRNE F,NEWFLG   ;NEW TAPE
	TRNE F,HDRFND   ;HEADER RECORD FOUND
	JRST HDRP2      ;OLD TAPE OR ACTUAL HEADER FOUND
; NEW TAPE.  FAKE HEADER IF MISSING.  HEADER IS IMPLIED IF DATE
; TAPE WRITTEN CHANGES FROM PREVIOUS FILE.
	MOVE R1,CURDAT
	CAMN R1,LSTDAT
	JRST HDRP1
	AOS R1,DIRSSC
	MOVEM R1,HDRSSC ;INCREMENT SAVESET NO.
HDRP1:  MOVE CURNUM
	MOVEM HDRTAP
	MOVE CURDAT
	MOVEM HDRDAT
	MOVEI R0,[ASCIZ""]
	MOVEM CTDMSG
HDRP2:  ERO [XWD 0,[ASCIZ"$$THIS IS "]]
	TRNE F,SSCFLG
	ERO [XWD[HDRSSC],[ASCIZ"SAVE SET NO. _C (D),$"]]
	ERO [XWD[HDRTAP
HDRDAT],[ASCIZ"TAPE NO. _C RECORDED _L$"]]
	TRNN F,NEWFLG
	JRST HDRP3
	MOVE TAPHED
	ADDI R0,XHDR-5-1 ;ADDR. OF STRING - 1
	HRLI R0,700!<2*5> ;MAKE SEVENBIT POINTER-10 CHARS	[16.3]
	MOVEM ID#
	MOVE R1,CURVER
	HRRI R0,[ASCIZ"SYSTEM _P DRIVE _S _O$"]
	CAIG R1,14
	HRRI R0,[ASCIZ"SYSTEM _P DRIVE _C _O$"]
	HRLI R0,[ID
TMP2
CURTRK]
	MOVEM TMP
	MOVE CURSER
	CAIG R1,14
	HRRZ CURSER
	MOVEM TMP2#
	ERO TMP
HDRP3:  TRNE F,SSCFLG
	ERO CTDMSG
	POPJ P,


; EOF READ

EOFRD:  TRNN F,EOTFLG   ;TWO IN A ROW
	JRST READTAP    ;NO, IGNORE EOF
	TRNN F,IGNFLG   ;WERE WE PROCESSING A FILE
	PUSHJ P,CLTFIL  ;YES, FINISH IT
	XCT MF7(UNIT)   ;BACK OVER ONE OF THE EOF'S
	XCT MF0(UNIT)   ;WAIT FOR COMPLETION
	JRST TRL1



; SET UP PARTIAL CHECKSUM AND PRINT CONTINUED FILE MESSAGE FOR SPLIT FILE

PCFM:   MOVE PCKSUM
	MOVEM CKSUM     ;SET CHECKSUM BACK TO LAST COMPLETE BLOCK
	HLRZM R0,C1#
	HRRZM R0,C2#
	ERB [XWD[STRPPN],[ASCIZ"$FILE _J WILL BE CONTINUED ON NEXT TAPE$"]]
	SKIPE STRBLK    ;SKIP IF ZERO (FILE NOT BEING PROCESSED)
	ERB [XWD[STRBLK
C1
C2],[ASCIZ"STARTING WITH BLOCK _C.  PARTIAL CKSUM: _H,,_H$"]]
	POPJ P,

; CLOSE FILE SPLIT BETWEEN TAPES.  DO NOT DEALLOCATE.

CLFIL:  TLNN F,DIRFLG
	CLOSE FIL,DNC!DLL
	TRO F,IGNFLG
	POPJ P,

; CLOSE AND FINISH FILE.  PRINT FILENAME IF DESIRED.  TRUNCATE
; FILE IF UPDATE MODE OR CONTINUED FILE AND DISC FILE WAS BIGGER
; THAN TAPE FILE.  VERIFY CHECKSUM.  SET FILE NOT IN PROGRESS.
; DIRECTORY DOES NOT WRITE ON THE FILE BUT DOES CONFIRM THE CHECKSUM

CLTFIL: SKIPE R1,TAPCNT         ;EOF--CHECK EXPECTED WORDCOUNT
	JRST CLTFI3             ;TOO MUCH OR TOO LITTLE DATA
CLTFI1: SKIPE   R1,OLDBLK       ;BLOCKCOUNT FROM PRECEDING TAPE(S)
	LSH     R1,7            ;CALCULATE WORDS READ (SKIPPED IF 0)
	ADD     R1,WDCNT        ;TOTAL
	SETZM   OLDBLK          ;FINISHED THIS FILE
	TLNE F,DIRFLG
	JRST CLTFI2             ;BYPASS TRUNCATION CHECKS
	CAMGE   R1,ORBSIZ       ;COMPARE WITH FILE WE WROTE OVER
	JRST TRUNCATE           ;NEED TO SHRINK SOME
; RETURN EXCESS ALLOCATED SPACE TO THE SYSTEM
	MOVE TRBALC
	CAMGE FRBALC
	JRST CLTFI9             ;EXCESS
CLTFI2: AOS     FILCNT          ;INCR. FILES RESTORED THIS USER
	AOS     RCOUNT          ;INCR. TOTAL FILES RESTORED
	MOVEI R0,1
	SKIPLE R1,CKNFP
	DPB R0,[XWD SUCS+R1,2]  ;MATCH ON PARTICULAR FILENAME
	SETOM CKNFP
;                               SEE CKNFIL TO SEE HOW FILENAME IS
;                               TAGGED.
	TRO F,IGNFLG    ;IGNORE SUBSEQUENT DATA
	TLNE F,DIRFLG
	POPJ P,         ;FORGET CLOSE
	MOVEI   R1,MRPTR##      ;GET RESTORE MODE
	LDB     R1,(R1)
	TRNN    R1,1            ;PRINT FILENAME IF DESIRED
	JRST CLTFI6     ;MOD RES F NOT SET
	SKIPE POSITION
	ERO [XWD[POSITION
XWD 10,5],[ASCIZ"_N  "]]
	ERO [XWD[FILDI1],[ASCIZ"_Z$"]]
CLTFI6: SKIPN PRAFLG    ;DID WE PREALLOCATE
	JRST .+3        ;NO
	CLOSE FIL,DNC!DLL ;CLOSE WITHOUT DEALLOCATION
	POPJ P,
	CLOSE FIL,DNC
	POPJ P,
CLTFI3: TLNN R1,400000  ;INSUFFICIENT
	ERB [XWD[FILDI1
CLTFI1],[ASCIZ"$FILE _J HAD TOO LITTLE DATA ON TAPE.$_E"]]
	TRNN F,NEWFLG
	ERB [XWD[FILDI1
CLTFI1],[ASCIZ"$FILE _J HAD TOO MUCH DATA ON TAPE.$_E"]]
	MOVE R1,TAPCK           ;LAST WORD WRITTEN PAST DATA
	CAME R1,CKSUM           ;CHECKSUM COMPUTED WHILST READING TAPE
	JRST CLTFI5             ;MISCOMPARE
	TLNN F,DIRFLG
	JRST CLTFI1
	ERO [XWD 0,[ASCIZ""]]   ;FORCE OUTPUT TO COF FILE
; PRINT CHECKSUM EXPECTED
CLTFI4: TLZ R1,400000
	PUSHJ P,TRIGR   ;FIRST 3 CHARS
	PUSHJ P,TRIGR   ;SECOND 3 CHARS
	TCO [CRCHR]
	JRST CLTFI1
CLTFI5: TLNE F,DIRFLG   ;DON'T PRINT FILENAME FOR DIR
	SKIPL COUT      ;UNLESS THERE IS A TOUT FILE
	JRST CLTFI8     ;NOT DIR OR TOUT TERMINAL
	ERT [XWD[FILDI1],[ASCIZ"FILE _J "]] ;THIS PART COMES TO TER ONLY
CLTFI7: ERB [XWD 0,[ASCIZ"EXPECTED CHECKSUM "]]
	JRST CLTFI4
CLTFI8: TLNN F,DIRFLG
	ERB [XWD[FILDI1],[ASCIZ"FILE _J "]]
	JRST CLTFI7

; TRBALC < FRBALC.  RETURN EXCESS

CLTFI9: MOVEM FRBALC
	RENAME FIL,FILDIR
	PUSHJ P,TRCERR
	JRST CLTFI2

; TRUNCATE FILE WHEN DISC FILE SIZE EXCEEDS TAPE FILE SIZE

TRUNCATE: ADDI R1,177   ;CALC. NO. OF BLOCKS WE WROTE
	LSH R1,-7       ;INCLUDING LAST PARTIAL BLOCK
	MOVEM   R1,FRBALC ;SET TO TRUNCATE FILE
	MOVEM   R1,FILPOS       ;SAVE FOR REPOSITION
	MOVE R1,FILHED ;SAVE BUFFER ADDR
	MOVEM R1,SAVHED ;FOR USE IN WRITING LAST PARTIAL BLOCK AGAIN
	MOVE    R1,FILHD1 ;SAVE BYTE PTR
	MOVEM R1,SAVBYT ;DITTO
	RENAME FIL,FILDIR       ;RENAME AND TRUNCATE
	JRST TRCER      ;RENAME FAILURE
	LOOKUP FIL,FILDIR
	JRST TRCER
	ENTER FIL,FILDIR
	JRST TRCER
	Move	R1,[.Chfso,,FIL]; Position to last block	[15.14]
	Chanio	R1,FILPOS	;  of the file.	USETO FIL,(R1)	[15.14]
	OUT     FIL,            ;VACUOUS WRITE, RING ADVANCED BY CLOSE
	JRST    TRUNC2
	JRST    TRUNC3  ;SOME KIND OF ERROR
TRUNC2: MOVE R1,SAVBYT
	MOVEM R1,FILHD1         ;RESTORE BYTE PTR
	MOVE R1,SAVHED
	OUT     FIL,(R1)        ;SWITCH TO PREVIOUS BUFFER IN RING
	JRST CLTFI2
TRUNC3: ERB [XWD[FILDI1],[ASCIZ"TROUBLE TRUNCATING _Z--"]]
	PUSHJ P,DWHY
	JRST CLTFI2
TRCER:  PUSHJ P,TRCERR
	JRST CLTFI2

TRCERR: MOVE R1,SEXT
	EXCH R1,FILDI3
	HLLI    R1,
	MOVEM   R1,ERCODE       ;SAVE ERROR CODE
	ERB [XWD[FILDI1],[ASCIZ"CANNOT TRUNCATE _Z---"]]
	PUSHJ P,WHY
	POPJ P,

; ROUTINE TO PRINT CHECKSUMS IN EASYSPEAK
; NOTE THAT THE TCO'S IN THIS ROUTINE OUTPUT TO COF FILE OR TO
; BOTH TERMINAL AND COF FILE, DEPENDING ON WHERE TRIGR WAS CALLED

TRIGR:  PUSHJ P,CONS
	IDIVI R1,5
	MOVE R0,VOWT(R2)
	TCO R0
CONS:   MOVEI R3,25
	IDIV R1,R3
	MOVEI R0,101(R2)
	MOVSI CH,-5
CONS1:  CAMN R0,VOWT(CH)
	JRST CONS2
	AOBJN CH,CONS1
	JRST CONS3
CONS2:  MOVEI R0,126(CH)
CONS3:  TCO R0
	POPJ P,
VOWT: 101
 105
 111
 117
 125


; REPORT MISSING FILES.  SEARCH COMMAND LIST FOR ENTRIES
; WHICH HAVE NOT BEEN PROCESSED.  THIS ROUTINE HAS TROUBLE
; WITH FILENAMES WHICH WERE NOT MATCHED BY CKNFIL DUE TO
; REDUNDANCY IN COMMAND LIST.

PFM:    SETOM PFMSW#    ;HEADING SWITCH FOR PFM
	MOVEI R1,2
	MOVE R1,CTABL2(R1)
	CAMG R1,[2,,777777]
	POPJ P,         ;NOT STATE 3 (INDIVIDUAL FILES)
	LDB R2,[XWD CNTFP+R1,0]
	CAIE R2,CNTFT   ;LOOK FOR TERMINATOR AFTER PPN
	AOJA R1,.-2
	HRRZ U,(R1)     ;FETCH UUN
	LDB R2,[XWD TRTF+R1,0]
	CAIN R2,1
	JRST PFM2
	PUSHJ P,FINGAN  ;DO A LUD LOOKUP
PFM0:   MOVEM U,FILDI1  ;SAVE FULL PPN
PFM1:   MOVS R2,1(R1)   ;FETCH FILENAME BACKWARDS
	CAIN R2,(SIXBIT /ALL/)
	POPJ P,         ;LIST ENDS WITH ALL
	LDB R2,[XWD SUCS+R1,2]  ;FETCH SUCCESS BIT IN EXT. WD
	CAIE R2,1       ;ONE IF CKNFIL SUCCESS ON THIS NAME
	PUSHJ P,PFMM    ;REPORT
	AOS R1
	LDB R2,[XWD CNTFP+R1,1]
	CAIE R2,CNTFT
	AOJA R1,PFM1
	POPJ P,         ;LIST ENDS WITH TERMINATOR
; TRANSLATE OPTION.  RH OF COMMAND LIST POINTS INTO TRANSLATION TABLE.
PFM2:   MOVE R0,1(U)
	MOVEM LSTUN1
	MOVE R0,2(U)
	MOVEM LSTUN2
	MOVEI R0,VERSION
	MOVEM LSTVER
	MOVEM U,LSTPPN ;FAKE PPN FOR THE TAPE NAME.  GAN IS ZERO SO
;                       THERE CAN BE NO CONFUSION WITH A REAL PPN.
	JRST PFM0

; PRINT FILENAME SUSPECTED TO BE MISSING

PFMM:   MOVE R2,1(R1)
	MOVEM R2,FILDI2 ;FILENAME
	HRLZ R2,2(R1)
	MOVEM R2,FILDI3 ;EXTENSION
	AOSG PFMSW      ;PRINT HEADING ONCE
	TYPE [ASCIZ"$FILENAMES UNSATISFIED: (MISSING ON TAPE OR
DUPLICATED IN LIST)$"]
	ERT [XWD[FILDI1],[ASCIZ"_J$"]]
	POPJ P,

; CHECK FOR AN EMPTY COMMAND LIST AND SKIP IF NOT EMPTY.  A LIST
; WHICH DOES NOT CONSIST OF INDIVIDUAL FILENAMES OR
; WHICH CONTAINS WILD CARDS WILL NEVER BE EMPTY.
; THE SWITCH "NULSW" = 0 THE FIRST TIME THROUGH
; THEREAFTER, NULSW = 1 IF WILD CARDS WERE FOUND AND = 2 IF NOT

CKNNUL: MOVEI R1,2
	MOVE R1,CTABL2(R1)
	CAMG R1,[2,,777777]
	JRST CPOPJ1     ;LIST NOT EMPTY
	LDB R2,[XWD CNTFP+R1,0]
	CAIE R2,CNTFT   ;SKIP IF TERMINATOR ON UUN
	AOJA R1,.-2
	MOVE R2,NULSW
	CAIG R2,0               ;SKIP IF NOT FIRST TIME THROUGH
	JRST CKNN3A     ;LOOK FOR WILD CARDS
	CAIG R2,1       ;SKIP IF NO WILD CARDS WERE FOUND
	JRST CPOPJ1
CKNN2:  AOS R1
	LDB R2,[XWD SUCS+R1,1]  ;LOOK AT SUCCESS BIT
	CAIE R2,1               ;SKIP IF WE PROCESSED THIS FILE
	JRST CPOPJ1
	LDB R2,[XWD CNTFP+R1,1] ;LOOK AT TERMINATOR
	CAIE R2,CNTFT           ;SKIP IF END
	AOJA R1,CKNN2           ;GET NEXT FILENAME
	POPJ P,                 ;NONSKIP RETURN IF LIST EMPTY
CKNN3A: AOS NULSW               ;MARK AS NOT FIRST TIME
	MOVE R0,R1              ;SAVE R1
CKNN3:  MOVEI   R3,11
	MOVEM   R3,TMP#         ;COUNT OF CHARS TO EXAMINE
	HRLZ    R3,2(R1)        ;FETCH EXTENSION (RH OF COMMAND WD)
	MOVS    R2,1(R1)        ;FETCH FILENAME BACKWARDS
	CAIN    R2,(SIXBIT/ALL/)
	JRST CPOPJ1             ;LIST ENDS WITH "ALL"
CKNN3B: XOR     R2,[SIXBIT /#/]
	TLNN    R2,770000
	JRST    CPOPJ1          ;BYPASS FILE WITH WILD CARD
	XOR     R2,[BYTE (6)34] ;XOR OF "#" AND "?"
	TLNN    R2,770000
	JRST    CPOPJ1          ;FOUND QM
	XOR     R2,[BYTE (6)25] ;XOR OF "?" AND "*"
	TLNN    R2,770000
	JRST    CPOPJ1          ;FOUND ASTERISK
	LSHC    R2,6
	SOSE    TMP
	JRST    CKNN3B
	AOS R1
	LDB     R2,[XWD CNTFP+R1,1]
	CAIE    R2,CNTFT        ;CHECK FOR TERMINATOR
	AOJA    R1,CKNN3        ;MORE TO EXAMINE
	MOVE R1,R0
	AOS NULSW               ;MARK AS NO WILD CARDS PRESENT
	JRST CKNN2
; TOTAL FILES FOR USER

SPRTU:  SKIPA   R1,[MSPTR]      ;GET POINTER FOR STORE MODE
RPRTU:  MOVEI   R1,MRPTR##      ;GET POINTER FOR RESTORE MODE
	TRZ F,UNMFLG            ;RESET SO TITLE FOR NEXT USER WILL
;                               BE PRINTED AT NEXT DIR RECORD
	SKIPN UCOUNT
	JRST .+3
	ERB [XWD[UCOUNT],[ASCIZ"$TOTAL _C UFD'S SET UP.$"]]
	SETZM UCOUNT
	SKIPN   FILCNT          ;SKIP IF FILES TRANSFERED FOR USER
	POPJ    P,              ;RETURN FROM SPRTU/RPRTU
	LDB     R1,(R1)         ;GET BYTE FOR STORE OR RESTORE
	TLNN    F,DIRFLG        ;SKIP IF DIRECTORY CMD AND PRINT USER TOT
	TRNE    R1,2            ;SKIP IF USER NAMES SHOULD NOT BE PRINTED
	JRST    RPRTA           ;PRINT USER TOTAL
RPRTB:  MOVE    R1,FILCNT       ;GET NUMBER OF FILES FOR THIS USER
	SETZM   FILCNT          ;ZERO NUMBER OF FILES FOR NEXT USER
	ADDM    R1,TOTCNT       ;ADD TO TOTAL FOR THIS SAVE SET
	MOVE R1,TOTBLK
	SETZM TOTBLK
	ADDM R1,GTBLOCK#        ;GRAND TOTAL BLOCKS
	POPJ    P,              ;RETURN FROM SPRTU/RPRTU
RPRTA:  TLNE F,STOFLG           ;IS THIS "STORE" COMMAND
	JRST    RPRTC           ;YES--USE LSTPPN
	TLNE F,DIRFLG
	JRST .+3
	ERO [XWD[FILDI1
CURPOS
FILCNT],[ASCIZ"_Y END POS _H,   _C FILES.$$"]]	;[16.4]
	JRST    RPRTB
	MOVE R1,FILDI1
	HRRZM R1,DUUN#
	HLRZM R1,DGAN#
	MOVEI R1,FILDI1-5
	MOVEM R1,TMP#
	ERO [XWD[FILCNT
XWD 12,5
TMP
DGAN
XWD 10,6
DUUN
XWD 10,6
TOTBLK#
XWD 12,6],[ASCIZ"TOTAL_N FILES  FOR     _M  [_N,_N]                _N$$"]]
	JRST RPRTB
RPRTC:  ERO [XWD[LSTPPN
CURPOS
FILCNT],[ASCIZ"_Y END POS _H,   _C FILES.$$"]]	;[16.4]
	JRST    RPRTB
; INTERPRET ERCODE ON LOOKUP OR ENTER FAILURES.

WHY:    HRREI   R1,-1
	EXCH    R1,ERCODE
	MOVE    R1,ENTTAB(R1)
	MOVEM R1,TMP
	ERB TMP
	TCO [CRCHR]
	POPJ    P,

; TABLE OF ERROR MESSAGES FOR LOOKUP AND ENTER

	EXP EMM1
ENTTAB: EXP EM0,EM1,EM2,EM3,EM4,EM5,EM6,EM30
	EXP EM30,EM30,EM30,EM30
	EXP EM14,EM15,EM16,EM17,EM20,EM21,EM22,EM23
	EXP EM24,EM25,EM26,EM30,EM30A
	EXP EM30,EM32,EM33,EM34
EMM1:   ASCIZ"NO ERROR"
EM0:    ASCIZ"FILE NOT FOUND"
EM1:    ASCIZ"INVALID PPN"
EM2:    ASCIZ"PROTECTION FAILURE"
EM3:    ASCIZ"FILE BEING MODIFIED"
EM4:    ASCIZ"FILENAME ALREADY EXISTS"
EM5:    ASCIZ"ILL. UUO SEQUENCE"
EM6:    ASCIZ"ERROR IN UFD RIB"
EM14:   ASCIZ"OVERDRAWN UFD QUOTA"
EM15:   ASCIZ"WRITE-LOCK ERROR"
EM16:   ASCIZ"MONITOR OUT OF TABLE SPACE"
EM17:   ASCIZ"PARTIAL ALLOCATION ONLY"
EM20:   ASCIZ"BLOCK NOT FREE"
EM21:   ASCIZ"CANNOT SUPERSEDE EXISTING DIR."
EM22:   ASCIZ"CANNOT DELETE NON-EMPTY DIR."
EM23:   ASCIZ"SUBDIRECTORY NOT FOUND"
EM24:   ASCIZ"SEARCH LIST EMPTY"
EM25:   ASCIZ"SFD NESTED TOO DEEP"
EM26:   ASCIZ"NO FILE STRUCTURE?"
EM30:   ASCIZ"DON'T KNOW WHY"
EM30A:  ASCIZ"NFS OR BDA BIT ON"
EM32:   ASCIZ"NOT CHANGED"
EM33:   ASCIZ"CREATION DATE CHANGED"
EM34:   ASCIZ"NOT SELECTED"

; INTERPRET DISC ERRORS

DWHY::  GETSTS FIL,FILCOD
	MOVE R1,FILCOD
	TRNE R1,400000
	ERB [XWD 0,[ASCIZ"FILE SOFTWARE WRITE PROTECTED.$"]]
	TRNE R1,200000
	ERB [XWD 0,[ASCIZ"SEARCH ERROR.$"]]
	TRNE R1,100000
	ERB [XWD 0,[ASCIZ"DISC PARITY ERROR.$"]]
	TRNE R1,40000
	ERB [XWD 0,[ASCIZ"CANNOT ALLOCATE DISC.$"]]
	POPJ P,

; SETUP FILE LICENSE

CKLIC:  HRRZ    R1,FRBNCA       ;GET LICENSE THE FILE HAD
	JUMPE   R1,CPOPJ        ;RETURN FROM CKLIC IF NO LICENSE
	MOVEM   R1,CKLICT       ;SAVE THE DESIRED LICENSE
	SKIPE	GETFLG		;IF IN GET MODE, SAVE LOGGED IN PPN
	SKIPA	R1,CURPPN	;IF NOT, SAVE CURRENT PPN
	GETPPN	R1,
	MOVEM	R1,EXTPPN
	MOVE	R1,CURFIL
	MOVEM	R1,EXTFIL
	MOVE	R1,CUREXT
	HLLZM	R1,EXTEXT
	MOVE    R1,JBLIC        ;GET LICENSE OF CURRENT JOB
	MOVEM   R1,CKLICT+1     ;SAVE JOB'S LICENSE
	MOVE    R2,TAPHED       ;ADDR OF CURRENT BUFFER
	SKIPE   R1,5(R2)        ;SKIP IF FILE'S PPN IS ZERO (GET CMD)
	XOR     R1,JBPPN        ;EXCLUSIVE OR OF JOB AND FILE PPNS
	MOVEM   R1,CKLICT+2     ;SAVE XOR OF PPNS
	MOVEI   R1,CKLICT       ;ADDR OF TABLE
	HRLI    R1,3            ;BIT 17 FOR LIC FROM TAB/BIT 16 FOR FILE
	CALLI   R1,-31          ;CHKLIC - RETURN ALLOWABLE LICENSE
	CAMN    R1,CKLICT       ;SKIP IF NOT ALL LICENSE ALLOWABLE
	ERO     [XWD [EXTPPN
	        PRLIC],[ASCIZ "FILE _Z GIVEN LICENSE _E"]]
	HLLZS   R1,FRBNCA       ;ZERO THE LICENSE
	ERB [XWD[EXTPPN],[ASCIZ "*********** FILE _Z NOT GIVEN LICENSE "]]
; PRINT LICENSES FROM CKLICT
PRLIC:  MOVE [POINT 12,LIC-1,35]
	MOVEM TLIC#
	MOVE R3,[-13,,0] ;BITS 18-28 INDICATE 11 UNIQUE LICENSES
	MOVE R2,CKLICT
	ILDB R0,TLIC
	TRNE R2,400000
	PUSHJ P,PLIC
	LSH R2,1
	AOBJN R3,.-4
	LDB R1,[POINT 2,CKLICT,33]
	MOVE READL
	XCT ILIC(R1)
	PUSHJ P,PLIC
	LDB R1,[POINT 2,CKLICT,35]
	MOVE WRITL
	XCT ILIC(R1)
	PUSHJ P,PLIC
	TCO [CRCHR]
	POPJ P,
PLIC:   ANDI 7777
	TRNN 7777
	POPJ P,
	LSHC R0,-6
	ADDI 40
	TCO R0
	LSHC R0,6
	ANDI 77
	ADDI 40
	TCO R0
	TCO [40]
	POPJ P,
LIC: SIXBIT /WCRCOPSYGDTDSTHFJLACXC/
ILIC:   SETZ R0,
	LSH -30
	LSH -14
	TRN
READL: SIXBIT /RPRFRA/
WRITL: SIXBIT /WPWFWA/

;PPNUSR CONVERTS A PPN TO A USER NAME BY LOOKING IN THE DUL
;  CALL WITH PPN IN R0
;  NON-SKIP RETURN IF USER NAME NOT FOUND. R0 PRESERVED IN THIS CASE
;  SKIP RETURN IF USER NAME FOUND.  USER NAME RETURNED IN R0 & R1
;  ALL REGISTERS OTHER THAN R0 & R1 ARE PRESERVED.

PPNUSR::TLNN    F,DULFLG        ;SKIP IF THE DUL HAS BEEN OPENED
	PUSHJ   P,GETDUL        ;TRY TO OPEN THE DUL
	TLNN    F,DULFLG        ;SKIP IF THE DUL HAS BEEN OPENED
	POPJ    P,              ;FAIL RETURN FROM PPNUSR
	PUSH    P,R2            ;SAVE R2 IN STACK
	PUSH    P,R3            ;SAVE R3 IN STACK
	PUSHJ   P,FINPPN        ;FIND PPN IN THE DUL AND RET USR NAME
	SKIPA                   ;ERROR RETURN  USER NAME NOT FOUND
	AOS     -2(P)           ;SKIP RETURN WHEN WE RETURN
	POP     P,R3            ;RESTORE R3 FROM STACK
	POP     P,R2            ;RESTORE R2 FROM STACK
	POPJ    P,              ;RETURN USER NAME IN R0 AND R1

FINPPN:	SKIPG	R0		;Make sure we have a good PPN	[15.14]
	  Popj	P,		;  Wel... Uh.. we don't!	[15.14]
	MOVE    R3,R0           ;SAVE PPN IN R3
	IDIVI   R0,^D101        ;DIVIDE BY 101 FOR BLOCK NUMBER
	ADDI    R1,1            ;REMAINDER PLUS ONE IS BLOCK NUMBER
	CAMN R1,DULL
	JRST PPN2
PPN3:   Move	R2,[.Chfsi,,DUL];Set file to "USETI DUL,@R1"	[15.14]
	Chanio	R2,R1		;  proper input block.		[15.14]
	INPUT   DUL,DULLST      ;INPUT THE BLOCK
	STATZ   DUL,760000      ;SKIP IF NO ERRORS
	ERROR   [ASCIZ "ERROR IN DUL.$"]
	MOVEM R1,DULL           ;SAVE DUL LOCATOR
PPN2:   SETZ    R2,             ;INITIALIZE INDEX TO ZERO
	MOVE    R0,R3           ;RESTORE PPN IN R0 IN CASE OF FAILURE
PPN1:   SKIPN   DULBLK(R2)
	POPJ    P,              ;FAIL RETURN FROM PPNUSR
	HRRZ    R1,DULBLK(R2)
	SKIPG   DULBLK(R2)
	JRST    PPN3
	MOVE    R0,DULBLK+1(R2) ;GET 1ST HALF OF NAME IN CASE WE'RE DONE
	MOVE    R1,DULBLK+2(R2) ;GET 2ND HALF OF NAME IN CASE WE'RE DONE
	CAMN    R3,DULBLK(R2)
	JRST    CPOPJ1          ;SUCCESS RETURN FROM PPNUSR
	MOVE    R0,R3           ;RESTORE PPN IN R0 IN CASE OF FAILURE
	ADDI    R2,3
	CAIGE   R2,200
	JRST    PPN1            ;LOOP
	POPJ    P,              ;FAIL RETURN FROM PPNUSR

;USRPPN CONVERTS A USER NAME TO A PPN
;  CALL WITH USER NAME IN R0 AND R1
;  SKIP RETURN WITH PPN IN R0 IF SUCCESSFUL
;  NON-SKIP RETURN IN UNSUCCESSFUL
;  R1, R2, AND R3 ARE NOT PRESERVED. R0 NOT PRESERVED ON FAILURE
USRPPN::TLNN    F,LUDFLG        ;SKIP IF THE LUD HAS BEEN OPENED
	PUSHJ   P,GETLUD        ;TRY TO OPEN THE LUD
	TLNN    F,LUDFLG        ;SKIP IF THE LUD HAS BEEN OPENED
	POPJ    P,              ;FAIL RETURN FROM USRPPN
	PUSHJ   P,HASHER        ;HASH THE USER NAME
	PUSHJ   P,FINNAM        ;FIND NAME IN LUD
	POPJ    P,              ;FAIL RETURN
	MOVE    R0,LUDBLK(R2)   ;GET PPN
	JRST    CPOPJ1          ;RETURN PPN IN R0

;RETURN IF NOT FOUND
;RETURN+1 IF NOT FOUND BUT USER WAS THERE(DELETED IN LUD)
;RETURN+2 IF FOUND
TYP1:   SKIPN   R1,LUDBLK(R2)
	POPJ    P,              ;FAIL RETURN FROM USRPPN
FINNAM: CAMN R1,LUDL
	JRST TYP2
	Move	R2,[.Chfsi,,LUD]; Position  (USETI LUD,@R1)	[15.14]
	Chanio	R2,R1		;   file at proper block.	[15.14]
	INPUT   LUD,LUDLST
	STATZ   LUD,760000
	ERROR   [ASCIZ "ERROR IN LUD.$"]
	MOVEM   R1,LUDL         ;SAVE LUD LOCATOR
TYP2:   SETZ    R2,
TYP3:   JUMPLE  R1,TYP1
	CAMN    R0,LUDBLK+4(R2)
	JRST    CPOPJ1          ;SUCCESS RETURN FROM USRPPN
	LDB     R1,[POINT 7,LUDBLK+2(R2),35]
	ADD     R2,R1
	JRST    TYP3
FINGAN::MOVE CPPN       ;LAST PPN REFERENCED IN COMMAND DISPATCHER
	XOR R0,U        ;U CONTAINS UUN IN RH ONLY
	TRNE R0,777777
	JRST .+3
	HLL U,R0        ;COMPLETE PPN
	POPJ P,
	TLNN     F,LUDFLG
	PUSHJ   P,GETLUD
	TLNN    F,LUDFLG
	ERROR   [ASCIZ"CANNOT OPEN LUD"]
	LDB     R2,[XWD LUDLC+R1,0]
	CAMN R2,LUDL
	JRST FING2
	Push	P,R1		; Save register "USETI LUD,@R2"	[15.14]
	Move	R1,[.Chfsi,,LUD]; Set channel-function		[15.14]
	Chanio	R1,R2		; Position input file		[15.14]
	Pop	P,R1		; Restore			[15.14]
	INPUT   LUD,LUDLST
	STATZ   LUD,760000
	ERROR   [ASCIZ"ERROR IN LUD"]
	MOVEM R2,LUDL
FING2:  SETZ    R2,
FING1:  MOVE    R0,LUDBLK(R2)
	XOR     R0,U            ;LOOK FOR MATCHING UUN
	TRNE    R0,777777
	JRST    .+3
	HLL     U,R0
	POPJ    P,
	LDB     R0,[POINT 7,LUDBLK+2(R2),35]
	CAIG    R0,
	ERROR   [ASCIZ"PROG. ERROR-FING1"]
	ADD     R2,R0
	JRST FING1

HASHER: PUSH    P,HA
	PUSH    P,HB
	PUSH    P,HC
	PUSH    P,HD
	PUSH    P,HE
	MOVEI   HB,0
	MOVE    HC,[555555555555]
	MOVE    HD,[361275431652]
	MOVE    HE,[612754316523]
	PUSHJ   P,RND
	PUSHJ   P,RND
	PUSHJ   P,RND
	PUSHJ   P,RND
	XOR     HE,HD
	MOVE    R0,HE
	TLZ     R0,400000
	IDIVI   R0,^D887
	MOVE    R0,HE
	XOR     R0,HC
	ADDI    R1,1
	POP     P,HE
	POP     P,HD
	POP     P,HC
	POP     P,HB
	POP     P,HA
	POPJ    P,
RND:    ADD     HD,R0
	ROTC    R0,-22
	MOVEI   HA,5
RND1:   MOVE    R2,HC+1(HB)
	MUL     R2,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
	ADDM    R3,HD+1(HB)
	AOJE    HB,RND2
	MOVNI   HB,1
	TRNE    HD,1
	SKIPL   HE
	MOVEI   HB,0
	EXCH    HC,HE
RND2:   SOJG    HA,RND1
	POPJ    P,

GETDUL: OPEN    DUL,DULTAB      ;INIT THE DEVICE SYS
	ERROR   [ASCIZ "CANNOT ACCESS SYS.$"]
	LOOKUP  DUL,LOKDUL      ;LOOKUP THE DUL
	  POPJ	P,		;FAIL RETURN FROM GETDUL
	SETOM DULL              ;NOTHING IN BUFFER YET
	TLO     F,DULFLG        ;MARK DUL AS OPENED
	POPJ    P,              ;SUCCESS RETURN FROM GETDUL

GETLUD: OPEN    LUD,LUDTAB      ;INIT THE DEVICE SYS
	ERROR   [ASCIZ "CANNOT ACCESS SYS.$"]
	LOOKUP  LUD,LOKLUD      ;LOOKUP THE LUD
	  POPJ	P,		;FAIL RETURN FROM GETLUD
	SETOM	LUDL		;NOTHING IN BUFFER YET
	TLO     F,LUDFLG        ;MARK LUD AS OPENED
	POPJ    P,              ;SUCCESS RETURN FROM GETLUD

	END     START
@/