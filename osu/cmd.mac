TITLE   CMD     03/21/74
;*MAKE PART NUMBERS START AT ZERO INSTEAD OF ONE
;*FIX INVALID COMMAND MSG TO PRINT OUT COMMAND
;*MOVETHE IGNORE CHARACTER LOGIC TO UUO PACKAGE
;*FIND OUT HOW DASH IS USED IN LISTS OF FILE NAMES
;*SHOULD NOT ALLOW *X.*X AS A FILE NAME
;*MAKE SURE 'STORE NOT (JIMF)FILE.EXT' DOES WHAT IT SHOULD
;*BE SURE EXTRA LONG COMMAND GIVES PROPER DIAGNOSTIC
;*ACCEPT COMMANDS IN UPPER AND LOWER CASE
;*CHANGE QUIT TO NOT PRINT EXIT AND PRINT 3 CR'S INSTEAD
;*DISALLOW RESTORE CHANGED
        INTERNAL CIN,FF2,TE,NU
        EXTERNAL PRONUM,CHRCNT
        EXTERNAL JOBAPR,JOBCNI ;JOBTPC


W=      5       ;CURRENT PART OF COMMAND BEING READ
S=      6       ;CURRENT STATE
ASTRSK= 52
COLON=  72
QUOTE=  42
ECHR==: 105
DOTCHR= 56
LBROK==74
RBROK==76

DATE==  14

CIN:    0
RANSIZ==: 1000                  ;SIZE OF FILE POS. SELECT BUFFER (1 page)
STACKL= 40                      ;LENGTH OF STACK
STACK:: XWD     -STACKL,.       ;INITIAL STACK POINTER
        BLOCK   STACKL          ;PUSH DOWN STACK
STACKE: 0                       ;STACK OVERFLOW MARKER

DEFINE  CMND(C,F,R,H)
< XWD [XWD F,R
       ASCIZ "H'"],[ASCIZ "C'"]>

DUM==   400000          ;DUMMY ENTRY - NO COMMAND
MOK==   200000          ;MORE PARTS TO COMMAND ARE OK
DKY==  100000           ;DOUBLE KEYWORD EXPECTED
PND== 40000             ;PPN NOT IN DUL OK

CM1==   1               ;FIRST PART OF ALL COMMANDS
SR2==   2               ;SECOND PART OF STORE/RESTORE
SR3==   3               ;THIRD PART OF STORE/RESTORE
MM2==   4               ;SECOND PART OF MODE
MS3==   5               ;THIRD PART OF MODE STORE/RESTORE
MO3==   6               ;THIRD PART OF MODE OLD FILE/SYS
NCSEC== 6               ;NUMBER OF DIFFERENT COMMAND SECTIONS
MORMSK==37              ;MASK OF FIELD FOR NEXT PART OF COMMAND

KF0TAB: CMND    DUMMY,CM1,0,<DUMMY ENTRY TO START ALL COMMANDS>

KF1TAB: BLOCK   0
        CMND <NEW TAPE>,0,NEWROU,<NEW TAPE - INITIALIZE TO STORE AT TAPE BEGINNING>
        CMND APPEND,0,APPROU,<INITIALIZE TO STORE AT TAPE END (LIKE SKIP E)>
        CMND STORE,SR2,STOROU##,<STORES FILES FROM DISC TO TAPE>
        CMND RESTORE,SR2,RESROU##,<RESTORES FILES TO DISC FROM TAPE>
        CMND DIRECTORY,SR2,DIRROU##,<PRINT DIRECTORY OF THE TAPE>
        CMND FAILON,0,FSTROU##,<ASSUME DIRECTORY IN FAILSAFE FORMAT>
        CMND FAILOFF,0,FCRROU##,<ASSUME DIRECTORY IN TITO FORMAT>
        CMND TRANSLATE,SR2,TRAROU,<TRANSLATE USERS NAMES FOR RESTORE>
        CMND UNTRANSLATE,0,UNTROU,<CLEAR OUT THE TRANSLATION TABLE>
        CMND <CUT AFTER>,SR2+DKY,CUTROU##,<MAKE EOT AFTER SPECIFIED FILE>
        CMND WHERE,0,WHEROU##,<PRINT LAST TAPE POSITION SCANNED>
        CMND COF,0,COFROU,<CHANGE OUTPUT FILE FOR NEXT COMMAND>
        CMND REWIND,0,REWROU##,<REWIND THE TAPE>
        CMND RWNW,0,RWNROU##,<REWIND BUT DON'T WAIT FOR COMPLETION>
        CMND UNLOAD,0,UNLROU##,<REWIND AND UNLOAD TAPE BUT DON'T WAIT>
        CMND HELP,0,HELROU,<PRINTS LIST OF VALID COMMANDS>
        CMND ?,0,HELROU,<SAME AS HELP>
        CMND QUIT,0,QUIROU##,<EXIT FROM PROGRAM>
        CMND SKIP,0,SKIROU,<SKIP N SAVE SETS OR TO END OF TAPE>
        CMND DEVICE,0,DEVROU##,<DEVICE OPEN, E.G. *DEV MTA1 800>
        CMND GET,SR2+PND,GETROU##,<SAME AS RESTORE BUT RESTORES TO UFD OF USER RUNNING TITO>
        CMND MODE,MOK+MM2,MDEROU,<PRINT AND SET DEFAULT MODES>
	CMND UPDATE,0,UPDROU##,<SET UPDATE FLAG>
	CMND NOUPDATE,0,NUPROU##,<TURN OFF UPDATE FLAG>
        CMND PREALLOCATE,0,PRROU##,<PREALLOCATE DISC SPACE DURING RESTORE>
        CMND NOPREALLOCATE,0,NPRROU##,<CANCEL PREALLOCATE SWITCH>
        CMND FLAGOFF,0,FLGROU##,<MARK FILES AS DUMPED FOR REBUILD>
        CMND NOFLAGOFF,0,NFLROU##,<MARK FILES NOT DUMPED WHEN RESTORED>
	CMND ASK,0,ASKERR##,<ASK TO CONTINUE WHEN TAPE ERRORS OCCUR>
	CMND NOASK,0,NASKER##,<CONTINE AUTOMATICALLY WHEN TAPE ERRORS OCCUR>
KF1TBE: BLOCK   0

KF2TAB: CMND ALL,MOK+SR3,ALLROU,<ALL FILES>
;*      CMND NOT,0,CNYI,<EXCLUDES THE ITEMS LISTED>
        CMND HELP,0,HELROU,<LISTS VALID OPTIONS AT THIS POINT IN COMMAND>
        CMND ?,0,HELROU,<SAME AS HELP>
        CMND <P2-4,7>,DUM+MOK+SR3,0,<A LIST OF TAPE POSITION NUMBERS PRECEDED BY A P>
        CMND <#2-4,7>,DUM+MOK+SR3,0,<A LIST OF TAPE POSITION NUMBERS PRECEDED BY A #>
KF2TBE: BLOCK   0

GF2TAB: CMND <G1-4,6>,DUM+MOK+SR3,0,<A LIST OF GLOBAL ACCOUNT NUMBERS PRECEDED BY A G>
GF2TBE: BLOCK   0

UF2TAB: CMND <[1,1],[1,4]>,DUM+MOK+SR3,0,<A LIST OF PPN NUMBERS>
UF2TBE: BLOCK   0

FF2TAB: CMND <[1,4]A.X,B.X>,DUM+MOK+SR3,0,<A LIST OF FILE NAMES PRECEDED BY A PPN NUMBER>
FF2TBE: BLOCK   0

KF3TAB: CMND TWICE,0,TWIROU,<COMMAND APPLIES TWICE TO STORE ONLY>
        CMND THRICE,0,THRROU,<COMMAND APPLIES THRICE TO STORE ONLY>
        CMND CREATED,0,CREROU,<COMMAND APPLIES ONLY TO FILES CREATED BEFORE OR AFTER HH:MM DA MON YR>
        CMND CHANGED,0,CHAROU,<COMMAND APPLIES ONLY TO FILES CHANGED SINCE LAST ALL FILES OR BACKUP>
        CMND <STARTING WITH>,0,STAROU,<RESTART WITH [GAN,UUN]FILE.EXT>
KF3TBE: BLOCK   0

KF4TAB: CMND STORE,MS3,MSROU,<MODES FOR STORE COMMAND>
        CMND RESTORE,MS3,MRROU,<MODES FOR RESTORE COMMAND>
        CMND OLD,MO3,MOROU,<MODES FOR RESTORING OLD FILES OTHER THAN SYS>
        CMND SYS,MO3,MSYROU,<MODES FOR RESTORING OLD FILES TO SYS>
        CMND HELP,0,HELROU,<LISTS VALID OPTIONS AT THIS POINT IN COMMAND>
KF4TBE: BLOCK   0

KF5TAB: CMND TOTALS,0,MSTROU,<PRINT TOTALS ONLY>
        CMND USERS,0,MSUROU,<PRINT TOTALS FOR EACH USER>
        CMND FILES,0,MSFROU,<PRINT EACH FILE NAME>
        CMND HELP,0,HELROU,<LISTS VALID OPTIONS AT THIS POINT IN COMMAND>
KF5TBE: BLOCK   0

KF6TAB: CMND NEWEST,0,MONROU,<RESTORE MOST RECENT FILE>
        CMND TAPE,0,MOTROU,<RESTORE THE FILE FROM TAPE>
        CMND DISC,0,MODROU,<RETAIN THE FILE CURRENTLY ON DISC>
        CMND CONFIRM,0,MOCROU,<ASK FOR CONFIRMATION BEFORE RESTORING>
        CMND HELP,0,HELROU,<LISTS VALID OPTIONS AT THIS POINT IN COMMAND>
KF6TBE: BLOCK   0

;THE FOLLOWING ARE ROUTINES TO READ ANYTHING AND EVERYTHING OUT OF THE
;COMMAND TABLE.  NOTHING SHOULD ACCESS THIS TABLE EXCEPT
;THROUGH THESE ROUTINES SO THAT THE FORMAT CAN EASILY BE CHANGED.
;ALL ROUTINES ARE CALLED WITH THE ADDRESS OF THE MAIN TABLE ENTRY IN R1.
;THE RESULT IS RETURNED IN R2.

GETHLP: BLOCK   0               ;GET ADDRESS OF FIRST WORD OF HELP MSG
        HLRZ    R2,(R1)         ;GET ADDRESS OF WORD BEFORE HELP MSG
        AOJA    R2,CPOPJ##      ;INCREMENT AND DO A POPJ

GETCMD: HRRZ    R2,(R1)         ;GET ADDRESS OF FIRST WORD OF COMMAND
        POPJ    P,              ;RETURN

GETFLG: BLOCK   0               ;GET FLAG WORD
        HLRZ    R2,(R1)         ;GET ADDRESS OF FLAG WORD
        MOVE    R2,(R2)         ;GET FLAGS
        POPJ    P,              ;RETURN

GETADR: BLOCK   0               ;GET ADDRESS OF ROUTINE FOR THIS CMD
        HLRZ    R2,(R1)         ;GET ADDRESS OF THE ADDRESS WE WANT
        MOVE    R2,(R2)         ;GET THE ADDRESS OF THE ROUTINE
        POPJ    P,              ;RETURN

GETTST: PUSH    P,R2            ;SAVE R2 ON THE STACK
        MOVE    R1,CTABLE-1(W)  ;GET POINTER TO LAST PART OF CMD READ
        PUSHJ   P,GETFLG        ;GET TYPE OF NEXT PART OF COMMAND
        HLRZ    R2,R2           ;PUT FLAGS IN RH
        ANDI    R2,MORMSK       ;KEEP ONLY THE TYPE
        MOVE    R1,TSTAB(R2)    ;ADDR OF TERM STATE TAB FOR THIS PART
        POP     P,R2            ;RESTORE R2 FROM STACK
        POPJ    P,              ;RETURN FROM GETTST

COMPTR:: XWD     0700,COMBUF-1
COMPT1: XWD     0700,COMBUF-1
COMPT2: 0

COMBUF:: BLOCK 200
COMBFE: BLOCK 0
        BLOCK 1 ;RESERVE FOR BLT CODE WHICH ZEROES 1
;               LOC. PAST END OF ARRAY

CLDSP:: CLRIN                   ;CLEAR INPUT BUFFER
        JRST    CDISP           ;BRANCH TO COMMAND DISPATCHER

SCDISP::MOVEI   R1,ESCR1        ;GET ADDRESS OF ESCAPE ROUTINE
        MOVEM   R1,JOBAPR       ;PUT IN TRAP LOCATION
        MOVEI   R1,2000         ;BIT TO TRAP ESCAPES
        APRENB  R1,             ;TRAP ESCAPES
        SETZM   ESCFLG#         ;NO ESCAPES SEEN YET
CDISP:: SETOM EROSW##
                                ;*CHECK HERE FOR ESCAPES ENABLED*
        TRZN F,NWFLG##  ;NO CLOSE FOLLOWING RWNW OR UNLOAD
        PUSHJ P,MTCLS
        MOVE    P,STACK         ;ADJUST THE STACK
        SKIPE   STACKE          ;SKIP IF STACK HAS NOT OVERFLOWED
        TYPE [ASCIZ"$Stack has overflowed.  Report to S.Q.A.$"]
        SETZM   STACKE          ;MARK STACK AS NOT OVERFLOWED
        SETOM UNISW##           ;ON ERROR GO TO DISPATCHER
        SETZM   ESCDI##         ;ESCAPE TRAP TO DISPATCHER
        PUSHJ P,CRLS##          ;MARK NAMES FILE AS CLOSED (SEE TCIUUO)
        SETZM FAKFLG
        PUSHJ   P,IPTR          ;INITIALIZE POINTER TO COMBUF
        TYPE [ASCIZ""]   ;ASSURE TCOUU7 IS SET CORRECTLY
        SKIPE   CHRCNT          ;SKIP IF WE'RE AT START OF LINE
        TCO     [CRCHR]         ;CR IF WE NEED IT
        TCO     [ASTRSK]        ;OUTPUT COMMAND DISPATCHER SYMBOL (*)
        MOVEI   W,NPARTS        ;NUMBER OF PARTS IN A COMMAND
        SETZM   CTABLE(W)       ;INITIALIZE TABLE OF CMDS READ
        SETZM   CTABL2(W)       ;INITIALIZE TABLE DESCRIBING CMDS TO ROU
        SOJG    W,.-2           ;LOOP
        MOVEI   W,1             ;INITIALIZE PART OF CMD WE'RE WORKING ON
        SETZM   STRPPN##        ;ZERO THE STARTING PPN
        SETZM   STRFIL##        ;ZERO THE STARTING FILE
        SETZM   STRBLK##        ;ZERO THE STARTING BLOCK
        SETZM   CREDAT##        ;ZERO THE CREATION DATE
        SETZM   CRETIM##        ;ZERO THE CREATION TIME
        SETZM   CHANGD##        ;NOT LOOKING FOR CHANGED FILES YET
        SETZM   CURPPN##        ;NO CURRENT FILE
        SETZM   FILCNT##        ;NO FILES TRANSFERED FOR THIS USER
        SETZM   TOTCNT##        ;NO FILES TRANSFERED FOR THIS SAVE SET
        TLZ     F,RPTFLG+RPTFIL##
        TRZ     F,TRTFG2##+RANCMD## 
        TRNN    F,TRTFG3##
        TRZ     F,TRTFLG
NXTPRT: MOVE    R1,CTABLE-1(W)  ;GET PTR TO LAST PART OF CMD READ
        PUSHJ   P,GETFLG        ;GET TYPE OF NEXT PART OF COMMAND
        HLRZ    R2,R2           ;PUT FLAGS IN RH
        ANDI    R2,MORMSK       ;KEEP ONLY THE TYPE
        HLRZ    S,ISTAB(R2)     ;GET INITIAL STATE
        MOVE    R1,COMPTR       ;ADDRESS-1 OF STRING WE'LL READ
        ADDI    R1,1            ;MAKE IT POINT TO THE STRING
        HRRM    R1,CTABL2(W)    ;IF IT ISN'T A COMMAND WE'LL NEED IT
NXTCHR: TCI     CT,CH           ;GET A CHARACTER AND ITS TYPE
        SETZM   ESCFLG          ;SOMETHING DONE SINCE LAST ESCAPE
SAMCHR: MOVE    R1,CTABLE-1(W)  ;GET POINTER TO LAST PART OF CMD READ
        PUSHJ   P,GETFLG        ;GET TYPE OF NEXT PART OF COMMAND
        HLRZ    R2,R2           ;PUT FLAGS IN RH
        ANDI    R2,MORMSK       ;KEEP ONLY THE TYPE
        MOVE    R2,ISTAB(R2)    ;GET ADDRESS OF TABLES FOR THIS PART
        ADD     R2,S            ;ADD THE CURRENT STATE TO THIS ADDR
        MOVE    R2,(R2)         ;GET ADDRESS OF TABLE FOR THIS STATE
        ADD     R2,CT           ;ADD TYPE OF THE CHARACTER JUST READ
        HLRZ    S,(R2)          ;GET THE NEW STATE
        MOVE    R2,(R2)         ;GET ADDRESS OF ROUTINE TO GO TO
        JRST    (R2)            ;GO TO PROPER ROUTINE

EXTCOM: MOVEI   R1,CNTFC        ;DELIMITER IS A COMMA
        PUSHJ   P,FFTRM         ;TERMINATE THE EXTENSION NAME
FILDOT: AOS     R1,COMPTR       ;GET ADDR OF NEXT AVAILABLE WORD
        PUSHJ   P,S6PTR         ;SET UP POINTERS
        JRST    NXTCHR          ;GET NEXT CHARACTER
FILCOM: AOS     R1,COMPTR       ;GET ADDRESS OF NEXT AVAILABLE WORD
        PUSHJ   P,S6PTR         ;SET UP POINTERS
        JRST    SAMCHR          ;REPLAY THE SAME CHARACTER
ENDUN:  MOVEI   R1,CNTFT        ;TERMINATOR FOR USER LIST
        PUSHJ   P,UFTRM         ;STORE ACCUMULATOR
        PUSHJ   P,NPTR          ;REINITIALIZE THE POINTERS
STRTUN: MOVEI   R1,0600         ;SIXBIT BYTE POINTER
        HRLM    R1,COMPTR       ;CHANGE STRING PTR FROM 7 BIT TO SIXBIT
        HRLM    R1,COMPT1       ;DITTO
        HRRZ    R1,COMPT1       ;GET NEXT FREE ADDR-1
        SUBI    R1,COMBFE-1     ;NUMBER OF FREE WORDS
        IMUL    R1,[-6]         ;NUMBER OF FREE CHARACTERS
        MOVEM   R1,COMPT2       ;SAVE NUMBER OF AVAILABLE CHARACTERS
STOSIX: SUBI    CH,40           ;CONVERT CHAR JUST READ TO SIXBIT
STOCHR: WCI     CH,COMPTR
        ERROR   [ASCIZ "Ran out of space for input string."]
        JRST    NXTCHR

; GAN READ.  SAVE FOR FIXLL
STOGAN: HRLZI R0,0
        EXCH R0,ACMLTR
        MOVEM GAN#
        JRST NXTCHR
; OCTAL DIGIT READ. SHIFT ACCUMULATOR 3 BITS AND ADD
ACCNUM: EXCH    CH,ACMLTR       ;GET NUMBER READ SO FAR
        IMULI   CH,10           ;*SHOULD THIS BE OCTAL OR DECIMAL?*
        SUBI    CH,60           ;CHAR READ WAS IN THE RANGE 60-71
        ADDM    CH,ACMLTR       ;FORM THE NEW RESULT
        JRST    NXTCHR          ;GET THE NEXT CHAR OF THE COMMAND
ACCEND: CAIE    CH,ECHR         ;SKIP IF CHAR "E" READ
        ERROR   [ASCIZ "Illegal number read"]
        SETOM   ACMLTR          ;SET NUMBER TO -1 FOR HIGHEST POSSIBLE
        JRST    NXTCHR          ;GET THE NEXT CHAR OF THE COMMAND
ACCCOM: SKIPA   R1,[CNTFC##]    ;NUMBER TERMINATED WITH A COMMA
ACCDSH: MOVEI   R1,CNTFD##      ;NUMBER TERMINATED WITH A DASH
        PUSHJ   P,GFTRM         ;STORE ACCUMULATOR IN LIST
        JRST    NXTCHR          ;READ THE NEXT CHARACTER

TSTLPI: CAIE    CH,LPAREN       ;DON'T SKIP IF LEFT BRACKET READ
        MOVEI   S,YL2           ;READ PPN INSTEAD OF USER NAME
        JRST    NXTCHR          ;GET THE NEXT CHARACTER

TSTLPP: CAIE    CH,LPAREN       ;DON'T SKIP IF LEFT BRACKET READ
        MOVEI   S,PL2           ;READ PPN INSTEAD OF USER NAME
        JRST    NXTCHR          ;GET THE NEXT CHARACTER
; PPN READ. MUST GO TO DUL AND THEN TO LUD TO GET LUD LOCATOR
FIXLL:  MOVE R0,ACMLTR
        HRL R0,GAN
        PUSHJ P,PPNUSR##        ;LOOK UP NAME IN DUL
        JRST CONVVV     ;NOT FOUND
        JRST CONVUU
; USER NAME READ
CONVUN: MOVE    R1,COMPTR       ;GET STARTING ADDR-1 OF USER NAME
        MOVE    R0,1(R1)        ;GET FIRST WORD OF USER NAME
        MOVE    R1,2(R1)        ;GET SECOND WORD OF USER NAME
CONVUU: PUSHJ   P,USRPPN##      ;CONVERT USER NAME TO PPN
        ERROR   [ASCIZ "No such user in LUD"]
        HRRZM   R0,ACMLTR       ;SAVE THE UNIVERSAL USER NUMBER
        MOVEM CPPN               ;SAVE LAST PPN REFERENCED
        MOVE R1,LUDL##          ;FETCH LUD BLOCK NO
        DPB     R1,[XWD LUDLC##,ACMLTR]
        JRST    NXTCHR          ;GET THE NEXT CHARACTER
CONVVV: MOVE R1,CTABLE-1(W)     ;GET FLAGS FOR THIS COMMAND
        PUSHJ P,GETFLG
        TLNN R2,PND             ;IS IT THE GET COMMAND
        ERROR [ASCIZ"PPN not found in DUL"]
        MOVEM CPPN
        HRRZM R0,ACMLTR
        JRST NXTCHR

TRMEOL: SKIPA   R2,[0]          ;LINE TERMINATED WITH CR OR LF
TRMNAT: HRREI   R2,-1           ;TERMINATION OF A PART OF THE COMMAND
        MOVEM   R2,EOLFLG#      ;SAVE FLAG TO KNOW HOW LINE WAS ENDED
        PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TABLE IN R1
        ADD     R1,S            ;ADDRESS OF ENTRY FOR THIS STATE
        MOVS    R2,(R1)         ;ADDRESS OF ROUTINE TO FINISH UP
        MOVEI   R1,CNTFT##      ;TERMINATING CHARACTER JUST READ
        PUSHJ   P,(R2)          ;FINISH READING WHATEVER WE JUST READ
        PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TABLE IN R1
        ADD     R1,S            ;GET ADDRESS FOR THIS STATE
        MOVE    R1,(R1)         ;GET TERM STATE TAB ENTRY FOR THIS STATE
        MOVE    R1,(R1)         ;GET ADDR OF CMD TABLE FOR THIS STATE
        PUSHJ   P,GETFLG        ;GET FLAGS FOR FIRST COMMAND IN TABLE
        MOVE    R3,CTABL2(W)    ;GET ADDRESS OF STRING JUST READ
        TLNN    R2,DUM          ;SKIP IF IT'S A DUMMY ENTRY
        PUSHJ   P,CMDSRC        ;SEARCH TABLE FOR COMMAND
        PUSH    P,R1            ;SAVE COMMAND POINTER ON STACK
        PUSHJ P,GETFLG
        TLNE R2,DKY
        PUSHJ P,DKYROU
        PUSHJ   P,NPTR          ;STRAIGHTEN UP POINTERS FOR NEXT PART
        POP     P,R1            ;RESTORE COMMAND POINTER FROM STACK
        HRLM    S,CTABLE(W)     ;SAVE THE STATE
        HRLM    S,CTABL2(W)     ;SAVE STATE FOR STORE/RESTORE
        PUSHJ   P,GETFLG        ;GET THE FLAGS FOR THIS THING
        HRRM    R1,CTABLE(W)    ;SAVE POINTER TO CMD TABLE
        TLNE    R2,MOK          ;SKIP IF MORE INPUT NOT OPTIONAL
        JRST    TRMNA3          ;CHECK FOR OPTIONAL INPUT
        TLNE    R2,MORMSK       ;SKIP IF THERE'S NO MORE
        AOJA    W,CPRMPT        ;PROMPT IF CARRIAGE RETURN TYPED
TRMNA2:
TRMNA1: PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TABLE IN R1
        HLRZ    R3,CTABLE(W)    ;GET STATE FOR THIS PART OF COMMAND
        ADD     R3,(R1)         ;ADD ADDR OF BEG OF TERM STATE TAB
        MOVE    R1,(R3)         ;GET FIRST COMMAND IN TABLE FOR THIS STATE
        PUSHJ   P,GETFLG        ;GET THE FLAGS FOR THIS COMMAND
        TLNN    R2,DUM          ;SKIP IF IT'S A DUMMY COMMAND
        MOVE    R1,CTABLE(W)    ;NOT DUMMY SO GET READ COMMAND
        PUSHJ   P,GETADR        ;GET ADDRESS OF ROUTINE FOR CMD
        TRNN    R2,-1           ;SKIP IF A GOOD ADDRESS WAS FOUND
ALLREE: SOJG    W,TRMNA1        ;GET ADDR FROM PREVIOUS PART IF ANY
        SKIPG   W               ;SKIP IF WE HAVE A GOOD ADDRESS
        PUSHJ   P,FERR          ;FATAL ERROR
        JRST    (R2)            ;GO EXECUTE THE COMMAND

TRMNA3: SKIPE   EOLFLG          ;SKIP IF LINE TERMINATED
        AOJA    W,NXTPRT        ;INPUT NEXT PART OF COMMAND
        JRST    TRMNA2          ;DONE WITH INPUT SO PROCESS THE COMMAND

CPRMPT: SKIPN   EOLFLG          ;SKIP IF CARRIAGE RETURN NOT TYPED
PROMPT: TYPE    [ASCIZ "More input needed: "]
        JRST    NXTPRT          ;INPUT NEXT PART OF COMMAND
DKYROU: PUSH P,R2       ;SAVE R2 ON STACK
        PUSH P,R3
        MOVEI R3,COMBUF
        CAIE CT,SP
        JRST CDLP0
        PUSHJ P,READKW
        SSKE R3,AFSTG
        JRST NEWR3
        HRREI R2,-1
        CAIE CT,SP
        MOVE R2,        MOVEM R2,EOLFLG
        POP P,R3
        POP P,R2
        POPJ P,
AFSTG: ASCIZ "AFTER"

KFTRM:  MOVEI   R1,EOLIT        ;TERMINATE STRING
        WCI     R1,COMPTR       ;WRITE BACK ARROW TO END OF STRING
        PUSHJ   P,FERR          ;RAN OUT OF SPACE FOR STRING INPUT
        POPJ    P,              ;RETURN TO TRMNAT ROUTINE

UFTRM:  BLOCK   0
GFTRM:  DPB     R1,[XWD CNTFP##,ACMLTR]
        AOS     R2,COMPTR       ;INC AND GET ADDRESS OF LIST ENTRY
        MOVEM   R2,COMPT1       ;SET UP FOR NPTR
        MOVE    R1,ACMLTR       ;GET THE NUMBER TO BE SAVED
        MOVEM   R1,(R2)         ;STORE THE NUMBER
        SETZM   ACMLTR          ;ZERO ACCUMULATOR FOR NEXT TIME
        POPJ    P,              ;RETURN TO TRMNAT ROUTINE

FFTRM:  MOVE    R2,COMPTR       ;GET ADDR OF EXTENSION -1
        HLRZ    R3,1(R2)        ;PUT EXTENSION IN RH
        TRNN    R3,777777       ;TEST FOR ZERO EXTENSION
        AOS     COMPT1          ;PRETEND WE WROTE ONE--FIX STG PTRS
        DPB     R1,[XWD CNTFP,R3]
        MOVEM   R3,1(R2)        ;PUT EXTENSION BACK WHERE IT BELONGS
        POPJ    P,              ;RETURN

CMDSRC: SETOM   GOODC#          ;INDICATE THAT NO CMDS HAVE BEEN FOUND
CDLP:   PUSHJ   P,GETCMD        ;GET ADDRESS OF THIS COMMAND'S NAME
        SSKE    R3,(R2)         ;SKIP IF THE STRINGS ARE EQUAL
        JRST    CDLP1           ;THEY'RE NOT EQUAL SO CHECK ANOTHER
        AOS     GOODC           ;INCREMENT THE NUMBER OF COMMANDS FOUND
        HRLM    R1,GOODC        ;SAVE POINTER INTO COMMAND TABLE
CDLP1:  AOBJN   R1,CDLP         ;CONTINUE SEARCH IF NOT DONE
        PUSHJ   P,NPTR          ;FIX PTR TO START ON WORD BOUNDARY
        MOVS    R1,GOODC        ;GET NUMBER OF COMMANDS FOUND AND PTR
        TLNE    R1,400000       ;SKIP IF AT LEAST ONE WAS FOUND
        JRST    CDLP0           ;INVALID COMMAND
        TLNN    R1,-1           ;SKIP IF ONLY ONE WAS FOUND
        POPJ    P,              ;RETURN WITH POINTER IN R1
        MOVE    R2,R1
        HLREM   R1,GOODC
        PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TABLE IN R1
        ADD     R1,S
        MOVE    R1,(R1)
        MOVE    R1,(R1)
        TLNE    R2,-2           ;SKIP IF ONLY TWO COMMANDS WERE FOUND
        JRST    CDLP3
        TYPE    [ASCIZ "Cannot distinguish between "]
        PUSHJ   P,GETCMD
        SSKE    R3,(R2)
        AOBJN   R1,.-2
        TYPE    (R2)
        TCO     [SPACE]
CDLP2:  TYPE    [ASCIZ "and "]
        AOBJN   R1,.+1
        PUSHJ   P,GETCMD
        SSKE    R3,(R2)
        AOBJN   R1,.-2
        TYPE    (R2)
        TCO     [DOTCHR]
        JRST    CLDSP
CDLP3:  TYPE    [ASCIZ "Cannot distinguish among "]
        PUSHJ   P,GETCMD
        SSKE    R3,(R2)
        AOBJN   R1,.-2
        TYPE    (R2)
        TYPE    [ASCIZ ", "]
        SOSLE   GOODC
        JRST    .-4
        JRST    CDLP2
CDLP0:  TYPE    (R3)            ;TYPE COMMAND JUST TYPED
        ERROR   [ASCIZ " is an invalid command."]

HELROU: PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TAB IN R1
        MOVE    R3,R1           ;PUT ADDR IN R3
HELLP1: MOVE    R1,(R3)         ;GET TERM STATE TAB ENTRY FOR THIS STATE
        MOVE    R1,(R1)         ;GET ADDRESS OF COMMAND TABLE
HELLP:  PUSHJ   P,GETCMD        ;GET ADDRESS OF COMMAND STRING
        HRRZM R2,HX#
        ERO HX
        TAB     15              ;TAB TO POSITION 15 OCTAL
        PUSHJ   P,GETHLP        ;GET ADDRESS OF THE HELP MESSAGE
        HRRZM R2,HX
        ERO HX
        TCO     [CRCHR]         ;END THE LINE WITH A CARRIAGE RETURN
        AOBJN   R1,HELLP        ;LOOP FOR NEXT CMD FOR THIS STATE
        AOBJN   R3,HELLP1       ;LOOP FOR NEXT STATE FOR THIS PART
        JRST    CDISP           ;*CHANGE THIS?*

ALLROU:	SETOM	ALLFSW##	;SET "ALL FILES" SWITCH
	MOVEI   R2,ALLLST##     ;DUMMY LIST FOR ALL FILES
        HRRM    R2,CTABL2(W)    ;SET UP THE LIST
        JRST    ALLREE          ;REENTER THE COMMAND DISPATCHER

STAROU: SKIPN   EOLFLG          ;SKIP IF NO NEED TO PROMPT
        JRST    STAPMT          ;PROMPT FOR PPN AND FILE.EXT
        TCI     CT,CH           ;INPUT A CHAR
        CAIN    CT,SP           ;SKIP IF NOT A SPACE
        JRST    .-2             ;TRY AGAIN
        CAIN    CT,TE           ;SKIP IF NOT A TERMINATOR
        JRST    STAPMT          ;PROMPT FOR PPN AND FILE.EXT
        CAIE    CT,AL           ;SKIP IF ALPHABETIC
        JRST    STALBR          ;CHECK FOR LEFT BRACKET
        TCI     CT,CH           ;READ ANOTHER CHAR
        CAIN    CT,AL           ;SKIP IF ALPHABETIC
        JRST    .-2             ;TRY AGAIN
        CAIN    CT,SP           ;SKIP IF NOT A SPACE
        JRST    STARED          ;START READING PPN ETC
        CAIE    CT,TE           ;SKIP IF TERMINATOR
        JRST    STALBR          ;CHECK FOR LEFT BRACKET
STAPMT: OUTSTR  [ASCIZ "Typee [GAN,UUN]FILE.EXT"]
STARED: TCI     CT,CH           ;READ LEFT BRACKET
STALBR: CAIE    CT,LP           ;SKIP IF RIGHT BRACKET
        JRST    ILCH            ;ILLEGAL CHARACTER
        PUSHJ   P,READUN        ;READ USER NAME OR PPN
        MOVEM   R0,STRPPN       ;STORE STARTING UUN
        TCI     CT,CH           ;INPUT TERMINATOR OR FILE NAME
        CAIE    CT,NU           ;SKIP IF IT'S A NUMBER
        CAIN    CT,AL           ;SKIP IF NOT ALPHABETIC
        SKIPA                   ;SKIP ALWAYS
        JRST    CHARET          ;TERMINATOR OR BAD CHARACTER
        MOVEI   R1,0600         ;SIXBIT BYTE POINTER
        HRLM    R1,COMPTR       ;CHANGE STRING PTR FROM 7 BIT TO SIXBIT
        HRLM    R1,COMPT1       ;DITTO
        HRRZ    R1,COMPT1       ;GET NEXT FREE ADDR-1
        SUBI    R1,COMBFE-1     ;NUMBER OF FREE WORDS
        IMUL    R1,[-6]         ;NUMBER OF FREE CHARACTERS
        MOVEM   R1,COMPT2       ;SAVE NUMBER OF AVAILABLE CHARACTERS
        PUSHJ   P,STASIX        ;READ AND STORE FILE NAME
        AOS     R1,COMPTR       ;GET ADDRESS OF NEXT AVAILABLE WORD
        PUSHJ   P,S6PTR         ;SET UP NEW POINTERS
        MOVE    R1,@COMPTR      ;GET FILE NAME
        MOVEM   R1,STRFIL       ;SAVE STARTING FILE NAME
        CAIN    CT,AT           ;SKIP IF LAST CHAR NOT @ FOR STARTING WRD
        JRST    STATRM          ;END OF FILE NAME
        CAIE    CT,TE           ;SKIP IF LAST CHAR WAS A CR ETC
        CAIN    CT,SP           ;SKIP IF LAST CHAR WAS NOT A SPACE
        JRST    STATRM          ;TERMINATOR OF THIS PART OF COMMAND
        CAIE    CT,EX           ;IT HAD BETTER BE A DOT
        JRST    ILCH            ;ILLEGAL CHARACTER
        PUSHJ   P,STASX1        ;READ AND STORE EXTENSION
STATRM: AOS     R1,COMPTR       ;GET ADDRESS OF EXTENSION
        HLLZ    R2,(R1)         ;PUT EXTENSION IN LH
        MOVEM   R2,STREXT##     ;SAVE STARTING EXTENSION
        PUSHJ   P,S6PTR         ;INITIALIZE THE POINTERS FOR NEXT PART
        MOVEI   R0,0            ;DEFAULT STARTING BLK IS ZERO
        CAIN    CH,LBROK        ;SKIP IF LAST CHAR NOT < FOR STR BLK
        PUSHJ   P,RDDNUM        ;READ STARTING BLOCK NUMBER
        MOVEM   R0,STRBLK       ;SAVE STARTING BLOCK OF FILE
STACH1: CAIN    CH,RBROK        ;NOSKIP IF LAST CHR WAS >
        JRST STACH2
CHARET: CAIN    CT,SP           ;SKIP IF LAST CHARACTER WAS NOT A SPACE
        JRST    NXTPRT          ;READ NEXT PART OF COMMAND
        CAIN    CT,TE           ;SKIP IF LAST CHAR WAS NOT A CR ETC
        JRST    ALLREE          ;CONTINUE DISPATCHING COMMAND
        JRST    ILCH            ;ILLEGAL CHARACTER
STASIX: SUBI    CH,40           ;CONVERT CHAR TO SIXBIT
        WCI     CH,COMPTR       ;WRITE CHAR TO STRING
        ERROR   [ASCIZ "Ran out of space for input string."]
STASX1: TCI     CT,CH           ;INPUT THE NEXT CHARACTER
        CAIE    CT,NU           ;SKIP IF IT'S A NUMBER
        CAIN    CT,AL           ;SKIP IF IT'S NOT ALPHABETIC
        JRST    STASIX          ;LOOP
        POPJ    P,              ;RETURN
STACH2: TCI CT,CH               ;READ NEXT CHAR
        CAIE CH,LBROK           ;SKIP IF LAST CHAR < FOR PART. CKSUM
        JRST CHARET
        PUSHJ P,RDONUM          ;READ PARTIAL CHECKSUM
        TLNE R0,777777
STACH3: ERROR [ASCIZ"Too many digits in checksum"]
        HRLZM R0,CKSUM##        ;STORE LEFT HALF
        CAIE CT,CO              ;NUMBER HAD BETTER TERMINATE WITH COMMA
        JRST ILCH
        TCI CT,CH               ;EXPECT TWO COMMAS
        CAIE CT,CO
        JRST ILCH
        PUSHJ P,RDONUM
        TLNE R0,777777
        JRST STACH3
        HRRM R0,CKSUM##         ;STORE RIGHT HALF
        CAIN CH,RBROK
        JRST STACH1
        JRST ILCH

READUN: PUSH    P,R1            ;SAVE R1 ON STACK
        PUSH    P,R2            ;SAVE R2 ON STACK
        CAIE    CH,LPAREN       ;SKIP IF USER AND NOT PPN
        JRST    READPP          ;READ PPN
        PUSH    P,R3            ;SAVE R3 ON STACK
        MOVE    R0,[XWD 0600,1] ;BYTE POINTER POINTING TO R2
        SETZB   R2,R3           ;ZERO R2 AND R3 FOR STRING
REDUN2: TCI     CT,CH           ;READ NEXT CHAR OF USER NAME
        CAIN    CT,RP           ;SKIP IF NOT RIGHT PAREN
        JRST    REDUN1          ;DONE READING USER NAME
        SUBI    CH,40           ;CONVERT CHAR TO SIXBIT
        IBP     R0              ;INCREMENT BYTE POINTER
        TRNE    R0,777774       ;SKIP IF USER NAME NOT TOO LONG
        ERROR   [ASCIZ "User name may not be longer than 12 characters."]
        DPB     CH,R0           ;DEPOSIT BYTE IN STRING
        JRST    REDUN2          ;GET NEXT CHARACTER
REDUN1: MOVE    R0,R2           ;NEED USER NAME IN R0 AND R1
        MOVE    R1,R3           ;MOVE SECOND HALF OF USER NAME
        PUSHJ   P,USRPPN        ;CONVERT USER NAME TO PPN
        ERROR   [ASCIZ "No such user."]
        POP     P,R3            ;RESTORE R3 FROM STACK
UU1RE2: POP     P,R2            ;RESTORE R2 FROM STACK
        POP     P,R1            ;RESTORE R1 FROM STACK
        POPJ    P,              ;RETURN
READPP: PUSHJ   P,RDONUM##      ;READ GAN
        CAIE    CT,CO           ;SKIP IF TERMINATED WITH A COMMA
        JRST    ILCH            ;ILLEGAL TERMINATOR
        MOVE    R2,R0           ;SAVE GAN IN R2
        PUSHJ   P,RDONUM        ;READ UUN
        HRL     R0,R2           ;COMBINE GAN AND UUN TO FORM PPN
        CAIE    CT,RP           ;SKIP IF TERMINATED WITH RIGHT BRACKET
        JRST    ILCH            ;ILLEGAL TERMINATOR
        JRST    UU1RE2          ;RETURN FROM READUN

MODWRD: BYTE    (2)MSMUSR,MSMUSR,MOMCON,MOMCON ;DEFAULT MODES
MODTMP: 0                       ;TEMP CELL FOR STORING MODE

MSPTR:: POINT   2,MODWRD,1      ;POINTER FOR STORE MODES
MRPTR:: POINT   2,MODWRD,3      ;POINTER FOR RESTORE MODES
MOPTR:: POINT   2,MODWRD,5      ;POINTER FOR OLD FILE MODES
MSYPTR::POINT   2,MODWRD,7      ;POINTER FOR OLD SYS FILE MODES

MSMTOT==:0                      ;MODE FOR STORE/RESTORE IS TOTALS
MSMUSR==:2                      ;MODE FOR STORE/RESTORE IS USERS
MSMFIL==:3                      ;MODE FOR STORE/RESTORE IS FILES

MOMNEW==:0                      ;MODE FOR OLD/SYS IS NEWEST
MOMTAP==:1                      ;MODE FOR OLD/SYS IS TAPE
MOMDIS==:2                      ;MODE FOR OLD/SYS IS DISC
MOMCON==:3                      ;MODE FOR OLD/SYS IS CONFIRM

MODROU: SKIPA   R1,[MOMDIS]     ;GET MODE FOR KEEPING DISC FILE
MOCROU: MOVEI   R1,MOMCON       ;GET MODE FOR CONFIRMATION
MOCOM:  MOVEM   R1,MODTMP       ;SAVE IT FOR NEXT PART OF THE COMMAND
        JRST    ALLREE          ;REENTER THE COMMAND DISPATCHER
MONROU: SKIPA   R1,[MOMNEW]     ;MODE TO KEEP NEWEST FILE
MOTROU: MOVEI   R1,MOMTAP       ;MODE TO RESTORE THE TAPE FILE
        JRST    MOCOM           ;SAVE MODE AND REENTER COMMAND DISPATCHER
MSFROU: MOVEI   R1,MSMFIL       ;PRINT EACH FILE NAME
        JRST    MOCOM           ;SAVE MODE AND REENTER CMD DISPATCHER
MSTROU: SKIPA   R1,[MSMTOT]     ;PRINT ONLY TOTALS FOR THE TAPE
MSUROU: MOVEI   R1,MSMUSR       ;PRINT TOTALS FOR EACH USER
        JRST    MOCOM           ;SAVE MODE AND REENTER CMD DISPATCHER

MSROU:  MOVE    R1,MODTMP       ;GET THE MODE
        DPB     R1,MSPTR        ;SAVE NEW STORE MODE
        JRST    CDISP           ;REENTER COMMAND DISPATCHER
MRROU:  MOVE    R1,MODTMP       ;GET THE MODE
        DPB     R1,MRPTR        ;SAVE NEW RESTORE MODE
        JRST    CDISP           ;REENTER THE COMMAND DISPATCHER
MOROU:  MOVE    R1,MODTMP       ;GET THE NEW MODE
        DPB     R1,MOPTR        ;SAVE THE NEW OLD FILE MODE
        JRST    CDISP           ;REENTER THE COMMAND DISPATCHER
MSYROU: MOVE    R1,MODTMP       ;GET THE NEW MODE
        DPB     R1,MSYPTR       ;SAVE THE NEW SYS MODE
        JRST    CDISP           ;REENTER THE COMMAND DISPATCHER

MDEROU: TYPE    [ASCIZ "Store:   "]
        LDB     R1,MSPTR        ;GET MODE FOR STORE
        PUSHJ   P,TYPSRM        ;TYPE STORE/RESTORE MODE
        TYPE    [ASCIZ "Restore: "]
        LDB     R1,MRPTR        ;GET RESTORE MODE
        PUSHJ   P,TYPSRM        ;TYPE STORE/RESTORE MODE
        TYPE    [ASCIZ "Old files:    "]
        LDB     R1,MOPTR        ;GET MODE FOR OLD FILES
        PUSHJ   P,TYPOM         ;TYPE OLD FILE MODE
        TYPE    [ASCIZ "Old SYS files:"]
        LDB     R1,MSYPTR       ;GET SYS MODE
        PUSHJ   P,TYPOM         ;TYPE OLD FILE MODE
        SKIPE UPDFLG##
        TYPE [ASCIZ"Update mode set$"]
        SKIPE PRAFLG##
        TYPE [ASCIZ"Disk space to be preallocated$"]
        SKIPE FLGOFF##
        TYPE [ASCIZ"Files restored will be marked as dumped$"]
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER

TYPSRM: CAIN    R1,MSMTOT       ;SKIP IF NOT TOTALS
        TYPE    [ASCIZ "totals$"]
        CAIN    R1,MSMUSR       ;SKIP IF NOT USERS
        TYPE    [ASCIZ "users$"]
        CAIN    R1,MSMFIL       ;SKIP IF NOT FILES
        TYPE    [ASCIZ "files$"]
        POPJ    P,              ;RETURN FROM TYPSRM

TYPOM:  CAIN    R1,MOMNEW       ;SKIP IF NOT NEWEST
        TYPE    [ASCIZ "Newest$"]
        CAIN    R1,MOMTAP       ;SKIP IF NOT TAPE
        TYPE    [ASCIZ "Tape$"]
        CAIN    R1,MOMDIS       ;SKIP IF NOT DISC
        TYPE    [ASCIZ "Disk$"]
        CAIN    R1,MOMCON       ;SKIP IF NOT CONFIRM
        TYPE    [ASCIZ "Confirm$"]
        POPJ    P,              ;RETURN FROM TYPOM

NEWROU: MOVEI R3,COMBUF ;NEEDED AT CDLP0
        CAIE CT,SP              ;MUST HAVE SPACE AFTER "NEW"
        JRST CDLP0
        PUSHJ P,READKW          ;INITIALIZE NEW TAPE FOR STORE
        SSKE    R3,TAPSTG       ;KLUDGE FOR DOUBLE KEYWORD "NEW TAPE"
        JRST    NEWR3
        SKIPGE SENTAB+1
        JRST APPR9
        TLNE    F,INIFLG
        ERROR   [ASCIZ"Tape already initialized"]
        ERT [XWD[NEWR2],[ASCIZ"Are you sure?_F_G"]]
NEWR1A::TCO [77]        ;ENTRY PT FROM CUT CODE
        TCO [CRCHR]
        JRST CLDSP
NEWR2:  PUSHJ   P,REWWAI##      ;REWIND TAPE AND WAIT
        TLO     F,INIFLG##      ;TAPE INITIALIZED
        JRST    CDISP
NEWR3:  MOVEI R1,COMBUF
        TYPE (R1)
        TCO [40]
        JRST CDLP0

TAPSTG: ASCIZ "TAPE"
WRISTG: ASCIZ "WRITE"

APPROU::SKIPGE SENTAB##+1
APPR9:  ERROR [ASCIZ"Tape needs a write ring"]
        TRNN F,EOTFLG##         ;ARE WE AT LOGICAL EOT
        PUSHJ   P,REWWAI        ;NO, WHO KNOWS WHERE
        MOVE    R0,[XWD 377777,777777]
        JRST    SKITRM##        ;LIKE SKIP END

SKIROU: CAIE CT,SP              ;LOOK FOR SPACE AFTER "SKIP"
        JRST SKI1               ;NONE
        TCL     CT,CH           ;LOOK AHEAD FOR "W"
        CAIE CH,127
        JRST SKI1
        PUSHJ P,READKW
        SSKE R3,WRISTG          ;KEYWORD "WRITE"
        JRST NEWR3
SKI2::  MOVEI R2,SKI2
SKI1:   SKIPN   EOLFLG          ;SKIP IF NO NEED TO PROMPT
        TYPE    [ASCIZ "Number of save sets to skip (decimal): "]
        SETZ    R0,             ;ZERO THE ACCUMULATOR
SKILUP: TCI     CT,CH           ;READ IN THE NEXT CHAR
        CAIN    CT,TE           ;SKIP IF NOT A TERMINATOR
        JRST    SKITRM          ;END OF LINE
        CAIN    CH,ECHR         ;SKIP IF NOT CHAR E
        JRST    SKIEND          ;SKIP TO END OF TAPE
        CAIE    CT,NU           ;SKIP IF IT'S A DIGIT
        ERROR   [ASCIZ "Invalid character"]
        IMULI   R0,12           ;MULTIPLY ACCUMULATOR BY TEN
        ADDI    R0,(CH)         ;ADD TO ACCUMULATOR
        SUBI    R0,60           ;CONVERT CHAR TO DIGIT
        JRST    SKILUP          ;GET NEXT DIGIT
SKIEND: MOVE    R0,[XWD 377777,777777] ;HIGHEST POSSIBLE NUMBER
        TCI     CT,CH           ;READ NEXT CHARACTER
        CAIE    CT,TE           ;SKIP IF IT'S A TERMINATOR
        JRST    .-2             ;LOOP
        JRST    SKITRM##        ;GO TO SKIP ROUTINE IN TAPE PACKAGE

CHAROU: SETOM   CHANGD          ;LOOKING ONLY FOR CHANGED FILES
        JRST    CHARET          ;FINISH PROCESSING COMMAND

THRROU: MOVEI   R1,3
        JRST .+2
TWIROU: MOVEI   R1,2
        MOVEM   R1,RPTCNT##     ;REPEAT COUNT FOR STORE
        TLO     F,RPTFLG##
        JRST CHARET

; CODE SUPPORTING FILE POSITION RANGE

;ALPHA - DISTINGUISH BETWEEN "G" FOR GAN OR RANGE OF GANS
;       AND "P" FOR RANGE OF POSITIONS.  IF NEITHER STATE
;       IS KN2 - KEYWORD PARTIALLY READ.
CHKGP:  CAIN CH,107
        JRST CHKG
        CAIE CH,120
        JRST STOCHR     ;STATE IS KN2
        MOVEI S,PP2
PNU:    MOVEI R0,PTE1
        MOVEM PTEP
        PUSHJ P,RANZ
        TRO F,RANCMD    ;RANGE PRE-ENTERED FROM COMMAND DISPATCHER
        MOVEI CH,101    ;FAKE KEYWORD "ALL"
        JRST STOCHR
CHKG:   MOVEI S,GA2
        JRST NXTCHR
;TERMINATOR
PTE:    PUSHJ P,@PTEP
        JRST TRMEOL
;SPACE
PSP:    PUSHJ P,@PTEP
        JRST TRMNAT
;DASH
PXA:    MOVEI R0,0
        EXCH R0,ACMLTR
        MOVEM N1
        MOVEI R0,PTE2
        MOVEM PTEP
        JRST NXTCHR
;COMMA
PCO:    PUSHJ P,@PTEP
        MOVEI R0,PTE1
        MOVEM PTEP
        JRST NXTCHR
; "E" AS FIRST CHAR OF 2ND PART OF RANGE
PEN:    CAIE CH,105
        JRST ILCH
        MOVEI RANSIZ*44-1
        MOVEM ACMLTR
        JRST NXTCHR
; CODE TO SET BITS IN RANGE BITMAP.  POINTED TO BY PTEP.
PTEP:   JRST PTE1
PTE2:   MOVEI R0,0
        EXCH R0,ACMLTR
        JRST PTE3
PTE1:   MOVEI R0,0
        EXCH R0,ACMLTR
        MOVEM N1
PTE3:   MOVEM N2
        PUSHJ P,SETN12  ;SET FROM N1 TO N2 TO ONE
        ERROR [ASCIZ"Selected position out of bounds"]
        POPJ P,

; SET RANGE TO ZEROES

RANZ::  SETZ R0,
        MOVE R1,[377777,,777777]
        SETZM RANGE
RANO1:  MOVEM RANLAS
        MOVEM R1,RANFST
        HRLI R1,RANGE
        HRRI R1,RANGE+1
        BLT R1,RANGE+RANSIZ-1   ;SET RANGE TO ZEROES
        POPJ P,

; SET RANGE TO ONES

RANO::  SETOM RANGE             ;SET RANGE TO ONE'S
        MOVEI R0,RANSIZ*44-1
        MOVEI R1,1
        JRST RANO1

; SET BIT IN RANGE BITMAP FOR N=N1 TO N2
; SKIP RETURN UNLESS N1 OR N2 OUT OF BOUNDS OR N1>N2

SETN12::MOVE N1
        CAIG RANSIZ*44-1
        CAIG 0
        POPJ P,
        CAMG RANFST
        MOVEM RANFST
        MOVE N2
        CAIG RANSIZ*44-1
        CAMGE N1
        POPJ P,
        CAML RANLAS
        MOVEM RANLAS
        AOS (P)         ;FOR SKIP RETURN
SETN:   MOVE R1,N1
        CAMLE R1,N2
        POPJ P,                 ;DONE
        IDIVI R1,44
        MOVEI R0,1
        LSH 0,(R2)
        IORM 0,RANGE(R1)
        AOS N1
        JRST SETN
N1:: 0
N2:: 0
RANFST:: 0      ;LOWER BOUND OF SELECTED RANGE
RANLAS:: 0      ;UPPER BOUND OF SELECTED RANGE
RANGE::BLOCK RANSIZ

; CODE TO HANDLE TRANSLATION OF TAPE USER NAMES

TRTM==20        ;NO OF ENTRIES
TRT: BLOCK 3*TRTM
TRTS: 0
TRTN: 0
TRTPTR: 0
; UNTRANSLATE
UNTROU: TRZ F,TRTFG3  ;ALLOW DISPATCHER TO CLEAR TRTFLG
        JRST CDISP
; TRANSLATE
TRAROU: MOVEI R1,2
        HLRZ R0,CTABL2(R1)
        SKIPN STRPPN
        CAIE R0,2
        ERROR [ASCIZ"Expected list of user names"]
        TRNN F,TRTFG2 ;TRANSLATIONS ENTERED
        ERROR [ASCIZ"No translations entered"]
        TRO F,TRTFLG+TRTFG3
        JRST CDISP
; BACK ARROW READ
T137A:  CAIE CH,BARROW
        JRST ILCH
        MOVEM S,TRTS
        MOVEI S,TD2
        TRZ F,TRTFG3+TRTFLG##  ;TRANSLATION TABLE NOT YET COMPLETE
        MOVEI R0,1
        DPB R0,[XWD TRTF##,ACMLTR]
        TRON F,TRTFG2## ;FLAG FOR DISPATCHER TO CLEAR TRT ONLY ONCE
        PUSHJ P,CLRTRT  ;CLEAR TRT
        MOVE R2,[-TRTM,,TRT]
T137C:  MOVE R0,(R2)
        CAIE R0,0
        CAMN R0,CPPN
        JRST T137B      ;FOUND EMPTY ENTRY OR MATCH
        AOS R2
        AOS R2
        AOBJN R2,T137C
        ERROR [ASCIZ"Translation table full"]
T137B:  MOVE CPPN##
        MOVEM R0,(R2)   ;STORE PPN
        HRRM R2,ACMLTR  ;SAVE TRT PTR IN COMMAND LIST
        HRLI R2,0600
        MOVEM R2,TRTPTR ;CALC SIXBIT PTR FOR TAPE NAME
        MOVEI R0,14
        MOVEM TRTN
        JRST NXTCHR
; LEFT PAREN READ
T137LP: CAIE CH,LPAREN
        JRST ILCH
        JRST NXTCHR
; CHAR OF TAPE USER NAME READ
TRTCHR: SUBI CH,40      ;CONV TO SIXBIT
        SOSL TRTN       ;KEEP FIRST 12 CHARS
        IDPB CH,TRTPTR  ;DEPOSIT IN TRT 
        JRST NXTCHR
; RETURN TO LIST OF PPN'S IF NECESSARY
TRST:   MOVE TRTS
        CAIN R0,PR2
        MOVEI S,TR2
        JRST NXTCHR

; CLEAR TRANSLATION TABLE

CLRTRT: SETZM TRT
        HRLI R1,TRT
        HRRI R1,TRT+1
        BLT R1,TRT+3*TRTM-1
        POPJ P,
; SEARCH FOR CURUN1,CURUN2 IN TRANSLATION TABLE

FINUN:: MOVE R2,[-TRTM,,TRT]
FINUN0: MOVE R0,(R2)
        CAIN R0,0
        POPJ P,
        MOVE R0,1(R2)
        CAME CURUN1##
        JRST FINUN1
        MOVE R0,2(R2)
        CAMN CURUN2##
        JRST FINUN2
FINUN1: AOS R2
        AOS R2
        AOBJN R2,FINUN0
        POPJ P,
FINUN2: AOS (P)
        MOVE R0,(R2)    ;PPN
        POPJ P,

COFENT: BLOCK   4               ;TABLE FOR ENTER
COFENE= COFENT+3

COFFIL: 0
COFEXN: 0
        0                       ;PROT-TIME-DATE FOR ENTER
        0                       ;PPN FOR ENTER
DEVWRD: XWD     DEVTAB-DEVTBE,DEVTAB
DEVTAB: XWD     PRIDEV,[ASCIZ "PRINTER"]
        XWD     PRIDEV,[ASCIZ"LPT:"]
;*      XWD     NOTDEV,[ASCIZ "NOTHING"]
        XWD     CDISP,[ASCIZ "TERMINAL"]
        XWD     CDISP,[ASCIZ "TELETYPE"]
DEVTBE: BLOCK   0
COFXBF: BLOCK   203*2           ;*LET'S HOPE THIS IS RIGHT
COFSTS: 0                       ;COF STATUS WORD
COFDEV: 0                       ;COF DEVICE WORD
COFBUF: 0                       ;COF BUFFER WORD
AL==1
COF==2
COFN==2

;*THIS THING IS A KLUDGE AND SHOULD BE REDONE ASAP
;*IT SHOULD BE ABLE TO ACCESS FILES IN OTHER DIRECTORIES
COFROU: PUSHJ P,COFRLS##        ;CLOSE CURRENT COF FILE
        SKIPN   EOLFLG          ;SKIP IF NO NEED TO PROMPT
        TYPE    [ASCIZ "To file: "]
        MOVEI   R0,COFXBF       ;ADDRESS OF COF BUFFER
        MOVEM   R0,JOBFF##      ;THIS IS WHERE BUFFER SHOULD GO
        MOVEI   R0,AL           ;ASCII LINE MODE
        MOVEM   R0,COFSTS       ;SAVE THE STATUS
        MOVSI   R0,COFHED##     ;CHANGE OUTPUT FILE BUFFER HEADER
        MOVEM   R0,COFBUF       ;ADDRESS OF OUTPUT BUFFER
        MOVE    R3,[XWD 0600,R2-1]
        SETZ    R2,             ;FILE NAME TO BE READ
        MOVEI   R0,6            ;SIX CHAR IN FILE NAME
COFCHR: TCI     CT,CH           ;READ A CHAR OF FILE NAME
        CAIN    CT,TE           ;SKIP IF NOT A CARRIAGE RETURN
        JRST    COFTRM          ;END OF LINE
        WCI     CH,COMPTR       ;WRITE CHAR TO STRING
        ERROR   [ASCIZ "Too many characters in command"]
        CAIN    CT,EX           ;SKIP IF NOT DOT
        JRST    COFEXT          ;START READING EXTENSION
        SOJL    R0,COFCHR       ;JUMP IF SIX CHAR READ
        SUBI    CH,40           ;CONVERT TO SIXBIT
        IDPB    CH,R3           ;ADD CHAR TO FILE NAME
        JRST    COFCHR          ;LOOP
COFEXT: MOVEM   R2,COFFIL       ;SAVE THE FILE NAME
        SETZ    R2,             ;ZERO THE EXTENSION
        MOVE    R3,[XWD 0600,R2-1]
        MOVEI   R0,3            ;READ THREE CHAR FOR EXTENSION
COFXCH: TCI     CT,CH           ;READ A CHAR OF EXTENSION
        CAIN    CT,TE           ;SKIP IF NOT CR ETC
        JRST    COFXTR          ;END OF EXTENSION
        SOJL    R0,COFXCH       ;JUMP IF THREE CHAR READ
        SUBI    CH,40           ;CONVERT CHARACTER TO SIXBIT
        IDPB    CH,R3           ;ADD CHAR TO EXTENSION
        JRST    COFXCH          ;LOOP

COFTRM: MOVEM   R2,COFFIL       ;SAVE THE FILE NAME
        SETZ    R2,             ;ZERO THE EXTENSION
COFXTR: MOVEM   R2,COFEXN       ;SAVE THE EXTENSION
        MOVEI   R1,EOLIT        ;TERMINATE STRING
        WCI     R1,COMPTR       ;ADD IT TO STRING
        ERROR   [ASCIZ "Too many characters in command"]
        MOVE    R1,DEVWRD       ;LOOP CONTROL WORD
        MOVE    R3,COMPTR       ;STRING WE JUST READ
        ADDI    R3,1            ;POINT TO STRING
COFLUP: MOVE    R2,(R1)         ;GET ADDRESS OF STRING TO COMPARE
        SSKE    R3,(R2)         ;SKIP IF STRINGS MATCH
        AOBJN   R1,COFLUP       ;LOOP IF NOT DONE
        MOVS    R2,(R1)         ;GET ADDRESS TO GO TO
        JUMPL   R1,(R2)         ;GO THERE IF STRINGS MATCHED
        MOVSI   R1,(SIXBIT /DSK/)
        MOVEM   R1,COFDEV       ;DEVICE IS DISC
        OPEN    COF,COFSTS      ;INIT THE DEVICE
        ERROR   [ASCIZ "Cannot access device"]
        OUTBUF  COF,COFN        ;SET UP BUFFERS
        MOVE    R1,[XWD COFFIL,COFENT]
        BLT     R1,COFENE       ;SET UP TABLE FOR LOOKUP
        LOOKUP  COF,COFENT      ;SEE IF IT'S ALREADY THERE
        JRST    COFNEW          ;IT'S A NEW FILE
        TYPE    [ASCIZ "Old file? "]
        CLOSE   COF,            ;CLOSE THE FILE WE JUST OPENED
COFTST: TCI     CT,CH
        JRST    .+2
        TCI     CT,CH
        CAIE    CT,TE
        JRST    .-2
        CAIE    CH,CRCHR
        JRST    COFABT
        MOVE    R1,[XWD COFFIL,COFENT]
        BLT     R1,COFENE       ;SET UP TABLE FOR ENTER
        ENTER   COF,COFENT
        ERROR   [ASCIZ "Unable to do ENTER on file"]
COFRET: SETOM COUT##            ;OUTPUT TO MEDIUM
        JRST    CDISP
COFNEW: TYPE    [ASCIZ "New file? "]
        JRST    COFTST
COFABT: RELEASE COF,
        JRST    CDISP
PRIDEV: MOVSI   R1,(SIXBIT /LPT/)
        MOVEM   R1,COFDEV
        OPEN    COF,COFSTS
        ERROR   [ASCIZ "Unable to access the line printer"]
        OUTBUF COF,COFN ;PUT OUT RING BEFORE JOBFF IS CHANGED
        TRO F,LPTFLG##          ;NOW USING LPT:
        JRST    COFRET

AFTSTR: ASCIZ   "AFTER"
BEFSTR: ASCIZ   "BEFORE"

CREROU: PUSHJ   P,READKW        ;READ IN A KEYWORD
        SSKE    R3,BEFSTR       ;SKIP IF HE TYPED "BEFORE"
        SKIPA                   ;SKIP ALWAYS
        ERROR   [ASCIZ "BEFORE is not yet implemented."]
        SSKE    R3,AFTSTR       ;SKIP IF HE TYPED "AFTER"
        ERROR   [ASCIZ "Invalid parameter typed."]
        CAIN    CT,TE           ;SKIP IF NOT TERMINATED BY A CR
        TYPE    [ASCIZ "Type date as HH:MM DD MON YY: "]
        AOS     R1,COMPTR       ;GET ADDRESS OF CURRENT STRING
        PUSHJ   P,SPTR          ;RETURN THE SPACE
        PUSHJ   P,RDDNUM##      ;READ HOURS
        MOVE    R3,R0           ;SAVE HOURS IN R3
        CAIE    CH,COLON        ;SKIP IF TERMINATED BY A COLON
        ERROR   [ASCIZ "Hours must be terminated by a colon."]
        CAIL    R3,30           ;SKIP IF HOURS LESS THAN TWENTY-FOUR
        ERROR   [ASCIZ "Hours must be less than 24"]
        IMULI   R3,74           ;CONVERT HOURS TO MINUTES
        PUSHJ   P,RDDNUM        ;READ MINUTES
        CAIL    R0,74           ;SKIP IF MINUTES LESS THAN SIXTY
        ERROR   [ASCIZ "Minutes must be less than 60."]
        ADD     R3,R0           ;ADD MINUTES TO HOURS
        IMUL    R3,JIFFPM##     ;CONVERT TO JIFFIES
        MOVEM   R3,CNVTIM##     ;SAVE CREATION TIME
        CAIN    CT,TE           ;SKIP IF TERMINATED WITH A CR
        JRST    CREDMY          ;USE CURRENT DAY-MONTH-YEAR
        CAIE    CT,SP           ;SKIP IF TERMINATED WITH A SPACE
        ERROR   [ASCIZ "Time must be terminated with a space or carriage return."]
        PUSHJ   P,RDDNUM        ;READ DAY OF MONTH
        CAIE    R0,0            ;SKIP IF IT'S ZERO
        CAIL    R0,40           ;SKIP IF DAY LESS THAN 32
        ERROR   [ASCIZ "Day must be in the range 0-31."]
        SOS     R3,R0           ;PUT DAY-1 IN R3
        CAIN    CT,TE           ;SKIP IF NOT TERMINATED WITH A CR
        JRST    CREMY           ;USE CURRENT MONTH-YEAR
        CAIE    CT,SP           ;SKIP IF TERMINATED WITH A SPACE
        CAIN    CT,DA           ;SKIP IF NOT TERM WITH A DASH
        SKIPA                   ;TERMINATED WITH SPACE, DASH, OR CR
        ERROR   [ASCIZ "Day must be terminated with a space, dash, or carriage return."]
        PUSHJ   P,RDMON##       ;READ MONTH-1 AND RETURN IT IN R2
        IMULI   R2,37           ;CONVERT MONTH TO DAY OF YEAR
        ADD     R3,R2           ;ADD IT INTO THE DAY OF MONTH
        TCI     CT,CH           ;READ CR OR SPACE AFTER MONTH
        CAIN    CT,TE           ;SKIP IF NOT A CARRIAGE RETURN
        JRST    CREY            ;USE CURRENT YEAR
        CAIE    CT,SP           ;SKIP IF TERMINATED WITH A SPACE
        CAIN    CT,DA           ;SKIP IF NOT TERMINATED WITH A DASH
        SKIPA                   ;TERMINATED WITH A SPACE OR DASH
        ERROR   [ASCIZ "Year must be terminated with a space, dash, or carriage return."]
        PUSHJ   P,RDDNUM        ;READ YEAR
        CAIL    R0,100          ;SKIP IF LESS THAN SIXTY-FOUR
        CAIL    R0,144          ;SKIP IF LESS THAN ONE HUNDRED
        ERROR   [ASCIZ "Year must be in the range 64-99."]
        SUBI    R0,100          ;CONVERT TO YEARS SINCE 1964
CRETRM: IMULI   R0,14*37        ;CONVERT TO DAYS SINCE 1964
CRETR1: ADD     R3,R0           ;ADD IT INTO THE DAY OF THE DAY
CRETR2: HRRZM   R3,CNVDAT##     ;SAVE CREATION DATE
        MOVE    R3,[XWD 0,400020] ;OLD TO NEW FORMAT
        MOVEM   R3,CNVFMT##     ;SAVE CONVERSION FORMAT
        MOVEI   R3,CNVDAT       ;GET ADDRESS OF CONVERSION TABLE
        DATUUO  R3,             ;CONVERT DATE AND TIME
        JUMP                    ;FAILS IF P011 BUT THAT'S OK
        MOVE    R3,JIFFPS##     ;GET JIFFIES PER SECOND
        EXCH    R3,CNVTIM       ;EXCHANGE WITH TIME
        IDIVM   R3,CNVTIM       ;CONVERT TIME FROM JIFFIES TO MIN
        MOVE    R3,CNVTIM       ;GET CREATION TIME
        MOVEM   R3,CRETIM       ;SAVE CREATION TIME
        MOVE    R3,CNVDAT       ;GET CREATION DATE
        MOVEM   R3,CREDAT       ;SAVE CREATION DATE
        CAIE    CT,TE           ;SKIP IF TERMINATED WITH A CARRIAGE RET
        JRST    NXTPRT          ;CONTINUE READING COMMAND
        SOJA    W,TRMNA2        ;CONTINUE DISPATCHING COMMAND
CREY:   CALLI   R0,DATE         ;READ CURRENT DATE
        IDIVI   R0,14*37        ;CONVERT TO YEARS SINCE 1964
        JRST    CRETRM          ;FINISH UP
CREMY:  CALLI   R0,DATE         ;GET CURRENT DATE
        IDIVI   R0,37           ;CONVERT TO MONTHS SINCE 1964
        IMULI   R0,37           ;CONVERT THAT BACK TO DAYS
        JRST    CRETR1          ;FINISH UP
CREDMY: CALLI   R3,DATE         ;READ CURRENT DATE
        JRST    CRETR2          ;FINISH UP

; CODE TO HANDLE OPENING OF NAMES FILE.  SEE STATE DIAGRAMS FOR
; SECOND PART OF COMMAND

; USE PROGRAM USER'S PPN WHEN USERNAME MISSING

FAKPPN: SETOM FAKFLG#   ;SET FLAG FOR CEOL-CNAT
        GETPPN U,
        TLN
        MOVEI R1,0600
        HRLM R1,COMPTR  ;CONVERT TO SIXBIT
        HRLM R1,COMPT1
        HRRZ R1,COMPT1
        SUBI R1,COMBFE-1
        IMUL R1,[-6]
        MOVEM R1,COMPT2
        JRST ENDUN      ;HOPE COMMAND BUFFER POINTERS ARE OK

; INSIST ON USERNAME WITH NAMES FILE--DISALLOW [GAN,,UUN]

TSTL:   CAIE CH,LPAREN
        JRST ILCH       ;LEFT BRACKET ILLEGAL
        JRST NXTCHR

; TERMINATE "NAMES" FILE.  SET PTRS BACK TO BEGINNING OF THIS PART.
; ZERO PART OF COMMAND BUFFER USED

CEOL:   SKIPA R3,[CRCHR];TERMINATED WITH TE
CNAT:   MOVEI R3,SPACE  ;TERMINATED WITH SP
; SAVE FILENAME IN FILDI1
        MOVEI R1,3
        MOVEM R1,FILDIR##
        HRRZ R1,COMPTR
        SUBI R1,1       ;POINT TO UUN
        SKIPE FAKFLG    ;FAKE PPN FOR NAMES FILE WHEN USERNAME MISSING
        JRST .+3
        HRRZ U,(R1)     ;FETCH UUN
        PUSHJ P,FINGAN##;FIND GAN IN LUD
        MOVEM U,FILDI1##
        HRLZ R2,COMPTR
        HRRI R2,FILDI2##
        BLT R2,FILDI3## ;MOVE NAME AND EXT
; ZERO BUFFER SPACE USED
        SETZM (R1)
        HRL R1,R1
        AOS R1
        MOVEI R2,COMBFE-1
        BLT R1,@R2
; RESET PTRS TO BEGINNING OF THIS PART
        HRRZ R1,CTABL2(W)
        SUBI R1,1
        HRLI R1,0700
        MOVEM R1,COMPTR
        MOVEM R1,COMPT1
        HRRZ R1,R1
        SUBI R1,COMBFE-1
        IMUL R1,[-5]
        MOVEM R1,COMPT2
; OPEN NAMES FILE AND INFORM TCI UUO BY SETTING FLAG
        INIT FIL,0      ;ASCII MODE
        SIXBIT /DSK/
        XWD 0,FILHED##
        ERROR [ASCIZ"Cannot access disk"]
        MOVEI R1,FILBUF##
        MOVEM R1,JOBFF
        INBUF FIL,FILN##
        LOOKUP FIL,FILDIR
        ERT [XWD[FILDI1
CLDSP],[ASCIZ"Cannot locate names file _J_E"]]
        MOVEM R3,CINFLG##
        JRST NXTCHR     ;INPUT SCAN CONTINUES, NOW IN NAMES FILE
CNYI:   BLOCK   0               ;ROUTINE FOR COMMANDS NOT YET IMPLEMENTED
        PUSHJ   P,GETCMD        ;GET ADDRESS OF COMMAND NAME
        TYPE    (R2)            ;TYPE THE NAME OF THE COMMAND
        ERROR   [ASCIZ " Not yet implemented"]
ILCH:   TYPE    [ASCIZ "Illegal input character: "]
        TCO     [LPAREN]        ;TYPE LEFT PAREN
        MOVE    R0,CH           ;PUT NUMBER IN R0 TO PRINT
        PUSHJ   P,PRONUM        ;PRINT OCTAL NUMBER
        TCO     [RPAREN]        ;TYPE RIGHT PAREN
        TCO     [SPACE]         ;SPACE
        TCO     [QUOTE]         ;OUTPUT A QUOTE MARK
        TCO     CH              ;OUTPUT THE CHARACTER
        TCO     [QUOTE]         ;OUTPUT ANOTHER QUOTE MARK
        JRST    CLDSP           ;CLEAR INPUT BUFFER AND GO TO CDISP
ESCR1:  HLR     R1,JOBCNI
        ANDI    R1,1
        CAIE    R1,1
        PUSHJ   P,FERR          ;*NOT SURE WHY IT WOULD COME HERE*
        PUSH    P,JOBTPC##      ;SAVE RETURN ADDRESS ON STACK
        PUSH    P,R0            ;SAVE R0 ON STACK
        MOVEI   R1,2000         ;BIT TO TRAP ON ESCAPE
        APRENB  R1,             ;TRAP ON ESCAPE
        MOVSI   R0,-1           ;STATUS BITS FOR THIS JOB
        GETTAB  R0,             ;GET STATUS OF THIS JOB
        SETZ    R0,             ;FAIL - SET ALL BITS TO ZERO
        SKIPN   ESCDI           ;SKIP IF USER DISABLED ESCAPES
        TLNE    R0,1            ;SKIP IF THE JAL BIT IS NOT SET
        JRST    UUORET##        ;IGNORE THE ESCAPE
        POP     P,R0            ;RESTORE R0 EVEN IF NOT NECESSARY
        POP     P,JOBTPC        ;POP STACK ONCE MORE
ESCR::  CLOSE   FIL,RST         ;CLOSE ANY OPEN FILE - KEEP OUT OF DIR
        PUSHJ P,MTCLS##
;*      PUSHJ P,COFRLS##        ;CLOSE COUT FILE
        HRROI   R1,6            ;PRV WORD FOR THIS JOB
        GETTAB  R1,             ;FIND OUT IF THIS IS A TYMEX USER
        SETZ    R1,             ;FAILED SO ASSUME PDP10 USER
        TRC     R1,200          ;COMPLEMENT THE TYMEX BIT
        TRNE    R1,600          ;SKIP IF THIS IS A TYMEX USER
        JRST    ESCR2           ;PDP10, GE, OR SUDS USER
        CLRBFO                  ;CLEAR OUTPUT BUFFER
        SETOM EROSW
        TYPE [ASCIZ""]  ;ASSURE OUTPUT TO TERMINAL
        TCO     [BARROW]
        TCO     [BARROW]
ESCR2:  SKIPGE  ESCFLG          ;SKIP IF NOT SECOND ESCAPE IN A ROW
        EXIT                    ;*LET THE GUY OUT - MAY WANT TO CHANGE THIS
        SETOM   ESCFLG          ;SET FLAG FOR NEXT TIME
        MOVEI   R1,2000
        APRENB  R1,
ABORTA::SKIPN   RCOUNT##
        SKIPE   SCOUNT##
        JRST    ABORT           ;ESCAPE FROM STORE OR RESTORE COMMAND
        JRST    CLDSP           ;CLEAR INPUT BUFFER AND GO TO CDISP
ABORT:  SKIPE   RCOUNT
        JRST    RESABO          ;RESTORE ABORTED
        ERT [XWD[SCOUNT],[ASCIZ"$Store aborted, _C files written$"]]
        SETZM   SCOUNT
        JRST    CLDSP
RESABO: ERT [XWD[RCOUNT],[ASCIZ"$Operation aborted, _C files processed$"]]
        SETZM   RCOUNT
        JRST    CLDSP

FERR::  BLOCK   0               ;FATAL ERROR ROUTINE
        SETOM EROSW
        TYPE    [ASCIZ "$Fatal error at location: "]
        HRRZ    R0,(P)          ;FIND FROM WHERE THIS WAS CALLED
        SUBI    R0,1            ;DECREMENT ADDRESS
        PUSHJ   P,PRONUM        ;PRINT THE ADDRESS
        JRST    CLDSP           ;CLEAR INPUT BUFFER AND GO TO CDISP

S6PTR::  PUSH    P,R0
        MOVEI   R0,6
        JRST    APTR
IPTR:   SKIPA   R1,[COMBUF-1]
NPTR:   MOVE    R1,COMPT1
SPTR:   PUSH    P,R0
        MOVEI   R0,7
APTR:   DPB     R0,[POINT 6,R0,11]
        PUSH    P,R2            ;*
        HLL     R1,R0
        HRRZ    R0,R0
        MOVEM   R1,COMPTR
        CAMN    R1,COMPT1
        JRST    NPTR1
        PUSH    P,@R1
        SETZM   @R1
        HRL     R1,R1
        AOJ     R1,
        BLT     R1,@COMPT1
        POP     P,@COMPTR
        MOVE    R1,COMPTR
NPTR1:  MOVEM   R1,COMPT1
        MOVEI   R2,COMBFE
        SUBI    R2,1(R1)        ;R2=NO. OF WDS
        MOVEI R1,44
        EXCH R0,R1
        IDIV R0,R1              ;R0=NO. OF BYTES/WD
        IMUL R0,R2              ;R0=NO. OF BYTES
        MOVE R1,R0
        MOVEM   R1,COMPT2
        SETZM   ACMLTR#         ;INITIALIZE NUMBER BEING READ
        POP     P,R2
        POP     P,R0
        POPJ    P,

READKW: TCI     CT,CH           ;INPUT NEXT CHAR OF WORD AFTER
        CAIE    CT,SP           ;SKIP IF SPACE WAS READ
        CAIN    CT,TE           ;SKIP IF CRARRIAGE RETURN NOT READ
        JRST    RKWBAT          ;TERMINATOR READ
        WCI     CH,COMPTR       ;PUT CHAR IN STRING
        ERROR   [ASCIZ "Too many characters in command."]
        JRST    READKW          ;LOOP
RKWBAT: MOVEI   CH,EOLIT        ;TERMINATE STRING
        WCI     CH,COMPTR       ;WRITE BACK ARROW TO STRING
        ERROR   [ASCIZ "Too many characters in command."]
        MOVE    R3,COMPTR       ;GET ADDRESS-1 OF STRING
        ADDI    R3,1            ;ADDRESS OF STRING
        POPJ    P,              ;RETURN FROM READKW

;STATES FOR THE COMMAND DISPATCHER

DEFINE  STATBT(B,S)     <
.'S'B>

DEFINE  ISTATE(A,B)     <
A'B=    .-ISTAB'B
        [CHARDO <STATBT B,A>
        ]
;;NIS'B= .-ISTAB'B
>

DEFINE  TSTATE(A,B)     <
A'B=    .-TSTAB'B
        XWD     A'TRM,[XWD A'B'TAB-A'B'TBE,A'B'TAB]
NTS'B=  .-TSTAB'B>

NPARTS==3       ;NUMBER OF COMMAND PARTS

DEFINE  XWDM(A,B,C)     <
        XWD     A'C,B'C>

DEFINE  XSTABM(T,L,R)   <X==0
T=.-1
REPEAT  NCSEC,  <X==X+1
        XWDM    L,R,\X>>

CTABL2::BLOCK   NPARTS+1        ;CELL DESCRIBING COMMAND READ

CTABLE: XWD     0,KF0TAB        ;STATE/COMMAND POINTER
        BLOCK   NPARTS          ;CTABLE REMEMBERS COMMANDS WE'VE READ

        XSTABM  ISTAB,IS,ISTAB; POINTER TO INITIAL STATE TABLES

        XSTABM  TSTAB,-NTS,TSTAB; POINTERS TO TERMINAL STATE TABLES


;SYMBOLS FORMING STATE DIAGRAM FOR FIRST PART OF COMMAND

.ISIC1= XWD     000,ILCH
.ISAL1= XWD     KN1,STOCHR
.ISNU1= XWD     000,ILCH
.ISRP1= XWD     000,ILCH
.ISIG1= XWD     IS1,NXTCHR
.ISLP1= XWD     000,ILCH
.ISAS1= XWD     000,ILCH
.ISEX1= XWD     000,ILCH
.ISAT1= XWD     000,ILCH
.ISCO1= XWD     000,ILCH
.ISTE1= XWD     000,CDISP
.ISSP1= XWD     IS1,NXTCHR
.ISPO1= XWD     000,ILCH
.ISQU1= XWD     KN1,STOCHR
.ISPU1= XWD     000,ILCH
.ISDA1= XWD     000,ILCH

.KNIC1= XWD     000,ILCH
.KNAL1= XWD     KN1,STOCHR
.KNNU1= XWD     000,ILCH
.KNRP1= XWD     000,ILCH
.KNIG1= XWD     KN1,NXTCHR
.KNLP1= XWD     000,ILCH
.KNAS1= XWD     000,ILCH
.KNEX1= XWD     000,ILCH
.KNAT1= XWD     000,ILCH
.KNCO1= XWD     000,ILCH
.KNTE1= XWD     KF1,TRMEOL
.KNSP1= XWD     KF1,TRMNAT
.KNPO1= XWD     000,ILCH
.KNQU1= XWD     KN1,STOCHR
.KNPU1= XWD     000,ILCH
.KNDA1= XWD     000,ILCH

;INTERMEDIATE STATE FOR FIRST PART OF COMMAND

ISTAB1: BLOCK   0
        ISTATE  IS,1;   INITIAL STATE
        ISTATE  KN,1;   KEYWORD PARTIALLY READ


;TERMINAL STATES FOR FIRST PART OF COMMAND


TSTAB1: BLOCK   0
        TSTATE  KF,1;   KEYWORD FOUND

ISTAB4==ISTAB1
ISTAB5==ISTAB1
ISTAB6==ISTAB1

IS4==   IS1
IS5==   IS1
IS6==   IS1

TSTAB4: TSTATE  KF,4;           KEYWORD FOUND
TSTAB5: TSTATE  KF,5;           KEYWORD FOUND
TSTAB6: TSTATE  KF,6;           KEYWORD FOUND

;SYMBOLS FORMING STATE DIAGRAM FOR SECOND PART OF COMMAND

.ISIC2= XWD     000,ILCH
.ISAL2= XWD     KN2,CHKGP
.ISNU2= XWD     000,ILCH
.ISRP2= XWD     000,ILCH
.ISIG2= XWD     IS2,NXTCHR
.ISLP2= XWD     XL2,TSTLPI
.ISAS2= XWD     000,ILCH
.ISEX2= XWD     000,ILCH
.ISAT2= XWD     CA2,NXTCHR
.ISCO2= XWD     000,ILCH
.ISTE2= XWD     IS2,PROMPT
.ISSP2= XWD     IS2,NXTCHR
.ISPO2= XWD     PP2,PNU
.ISQU2= XWD     KN2,STOCHR
.ISPU2= XWD     000,ILCH
.ISDA2= XWD     000,ILCH

.KNIC2= XWD     000,ILCH
.KNAL2= XWD     KN2,STOCHR
.KNNU2= XWD     000,ILCH
.KNRP2= XWD     000,ILCH
.KNIG2= XWD     KN2,NXTCHR
.KNLP2= XWD     000,ILCH
.KNAS2= XWD     000,ILCH
.KNEX2= XWD     000,ILCH
.KNAT2= XWD     000,ILCH
.KNCO2= XWD     000,ILCH
.KNTE2= XWD     KF2,TRMEOL
.KNSP2= XWD     KF2,TRMNAT
.KNPO2= XWD     000,ILCH
.KNQU2= XWD     000,ILCH
.KNPU2= XWD     000,ILCH
.KNDA2= XWD     000,ILCH

.GAIC2= XWD     000,ILCH
.GAAL2= XWD     000,ILCH
.GANU2= XWD     GN2,ACCNUM
.GARP2= XWD     000,ILCH
.GAIG2= XWD     GA2,NXTCHR
.GALP2= XWD     000,ILCH
.GAAS2= XWD     000,ILCH
.GAEX2= XWD     000,ILCH
.GAAT2= XWD     000,ILCH
.GACO2= XWD     000,ILCH
.GATE2= XWD     000,ILCH
.GASP2= XWD     000,ILCH
.GAPO2= XWD     000,ILCH
.GAQU2= XWD     000,ILCH
.GAPU2= XWD     000,ILCH
.GADA2= XWD     000,ILCH

.GNIC2= XWD     000,ILCH
.GNAL2= XWD     000,ILCH
.GNNU2= XWD     GN2,ACCNUM
.GNRP2= XWD     000,ILCH
.GNIG2= XWD     GN2,NXTCHR
.GNLP2= XWD     000,ILCH
.GNAS2= XWD     000,ILCH
.GNEX2= XWD     000,ILCH
.GNAT2= XWD     000,ILCH
.GNCO2= XWD     GC2,ACCCOM
.GNTE2= XWD     GF2,TRMEOL
.GNSP2= XWD     GF2,TRMNAT
.GNPO2= XWD     000,ILCH
.GNQU2= XWD     000,ILCH
.GNPU2= XWD     000,ILCH
.GNDA2= XWD     GD2,ACCDSH

.GCIC2= XWD     000,ILCH
.GCAL2= XWD     000,ILCH
.GCNU2= XWD     GN2,ACCNUM
.GCRP2= XWD     000,ILCH
.GCIG2= XWD     GC2,NXTCHR
.GCLP2= XWD     000,ILCH
.GCAS2= XWD     000,ILCH
.GCEX2= XWD     000,ILCH
.GCAT2= XWD     000,ILCH
.GCCO2= XWD     000,ILCH
.GCTE2= XWD     000,ILCH
.GCSP2= XWD     000,ILCH
.GCPO2= XWD     000,ILCH
.GCQU2= XWD     000,ILCH
.GCPU2= XWD     000,ILCH
.GCDA2= XWD     000,ILCH

.GDIC2= XWD     000,ILCH
.GDAL2= XWD     GE2,ACCEND
.GDNU2= XWD     GS2,ACCNUM
.GDRP2= XWD     000,ILCH
.GDIG2= XWD     GD2,NXTCHR
.GDLP2= XWD     000,ILCH
.GDAS2= XWD     000,ILCH
.GDEX2= XWD     000,ILCH
.GDAT2= XWD     000,ILCH
.GDCO2= XWD     000,ILCH
.GDTE2= XWD     000,ILCH
.GDSP2= XWD     000,ILCH
.GDPO2= XWD     000,ILCH
.GDQU2= XWD     000,ILCH
.GDPU2= XWD     000,ILCH
.GDDA2= XWD     000,ILCH

.GSIC2= XWD     000,ILCH
.GSAL2= XWD     000,ILCH
.GSNU2= XWD     GS2,ACCNUM
.GSRP2= XWD     000,ILCH
.GSIG2= XWD     GS2,NXTCHR
.GSLP2= XWD     000,ILCH
.GSAS2= XWD     000,ILCH
.GSEX2= XWD     000,ILCH
.GSAT2= XWD     000,ILCH
.GSCO2= XWD     GC2,ACCCOM
.GSTE2= XWD     GF2,TRMEOL
.GSSP2= XWD     GF2,TRMNAT
.GSPO2= XWD     000,ILCH
.GSQU2= XWD     000,ILCH
.GSPU2= XWD     000,ILCH
.GSDA2= XWD     000,ILCH

.GEIC2= XWD     000,ILCH
.GEAL2= XWD     000,ILCH
.GENU2= XWD     000,ILCH
.GERP2= XWD     000,ILCH
.GEIG2= XWD     GE2,NXTCHR
.GELP2= XWD     000,ILCH
.GEAS2= XWD     000,ILCH
.GEEX2= XWD     000,ILCH
.GEAT2= XWD     000,ILCH
.GECO2= XWD     GC2,ACCCOM
.GETE2= XWD     GF2,TRMEOL
.GESP2= XWD     GF2,TRMNAT
.GEPO2= XWD     000,ILCH
.GEQU2= XWD     000,ILCH
.GEPU2= XWD     000,ILCH
.GEDA2= XWD     000,ILCH

.YLIC2= XWD     000,ILCH
.YLAL2= XWD     000,ILCH
.YLNU2= XWD     YA2,ACCNUM
.YLRP2= XWD     000,ILCH
.YLIG2= XWD     YL2,NXTCHR
.YLLP2= XWD     000,ILCH
.YLAS2= XWD     000,ILCH
.YLEX2= XWD     000,ILCH
.YLAT2= XWD     000,ILCH
.YLCO2= XWD     000,ILCH
.YLTE2= XWD     000,ILCH
.YLSP2= XWD     000,ILCH
.YLPO2= XWD     000,ILCH
.YLQU2= XWD     000,ILCH
.YLPU2= XWD     000,ILCH
.YLDA2= XWD     000,ILCH

.YAIC2= XWD     000,ILCH
.YAAL2= XWD     000,ILCH
.YANU2= XWD     YA2,ACCNUM
.YARP2= XWD     000,ILCH
.YAIG2= XWD     YA2,NXTCHR
.YALP2= XWD     000,ILCH
.YAAS2= XWD     000,ILCH
.YAEX2= XWD     000,ILCH
.YAAT2= XWD     000,ILCH
.YACO2= XWD     YC2,STOGAN
.YATE2= XWD     000,ILCH
.YASP2= XWD     000,ILCH
.YAPO2= XWD     000,ILCH
.YAQU2= XWD     000,ILCH
.YAPU2= XWD     000,ILCH
.YADA2= XWD     000,ILCH

.YCIC2= XWD     000,ILCH
.YCAL2= XWD     000,ILCH
.YCNU2= XWD     YU2,ACCNUM
.YCRP2= XWD     000,ILCH
.YCIG2= XWD     YC2,NXTCHR
.YCLP2= XWD     000,ILCH
.YCAS2= XWD     000,ILCH
.YCEX2= XWD     000,ILCH
.YCAT2= XWD     000,ILCH
.YCCO2= XWD     000,ILCH
.YCTE2= XWD     000,ILCH
.YCSP2= XWD     000,ILCH
.YCPO2= XWD     000,ILCH
.YCQU2= XWD     000,ILCH
.YCPU2= XWD     000,ILCH
.YCDA2= XWD     000,ILCH

.YUIC2= XWD     000,ILCH
.YUAL2= XWD     000,ILCH
.YUNU2= XWD     YU2,ACCNUM
.YURP2= XWD     YR2,FIXLL
.YUIG2= XWD     YU2,NXTCHR
.YULP2= XWD     000,ILCH
.YUAS2= XWD     000,ILCH
.YUEX2= XWD     000,ILCH
.YUAT2= XWD     000,ILCH
.YUCO2= XWD     000,ILCH
.YUTE2= XWD     000,ILCH
.YUSP2= XWD     000,ILCH
.YUPO2= XWD     000,ILCH
.YUQU2= XWD     000,ILCH
.YUPU2= XWD     000,ILCH
.YUDA2= XWD     000,ILCH

.YRIC2= XWD     YR2,T137A
.YRAL2= XWD     FN2,ENDUN
.YRNU2= XWD     FN2,ENDUN
.YRRP2= XWD     000,ILCH
.YRIG2= XWD     YR2,NXTCHR
.YRLP2= XWD     000,ILCH
.YRAS2= XWD     FN2,ENDUN
.YREX2= XWD     000,ILCH
.YRAT2= XWD     000,ILCH
.YRCO2= XWD     PD2,ACCCOM
.YRTE2= XWD     UF2,TRMEOL
.YRSP2= XWD     UF2,TRMNAT
.YRPO2= XWD     FN2,ENDUN
.YRQU2= XWD     FN2,ENDUN
.YRPU2= XWD     000,ILCH
.YRDA2= XWD     000,ILCH

.PLIC2= XWD     000,ILCH
.PLAL2= XWD     000,ILCH
.PLNU2= XWD     PA2,ACCNUM
.PLRP2= XWD     000,ILCH
.PLIG2= XWD     PL2,NXTCHR
.PLLP2= XWD     000,ILCH
.PLAS2= XWD     000,ILCH
.PLEX2= XWD     000,ILCH
.PLAT2= XWD     000,ILCH
.PLCO2= XWD     000,ILCH
.PLTE2= XWD     000,ILCH
.PLSP2= XWD     000,ILCH
.PLPO2= XWD     000,ILCH
.PLQU2= XWD     000,ILCH
.PLPU2= XWD     000,ILCH
.PLDA2= XWD     000,ILCH

.PAIC2= XWD     000,ILCH
.PAAL2= XWD     000,ILCH
.PANU2= XWD     PA2,ACCNUM
.PARP2= XWD     000,ILCH
.PAIG2= XWD     PA2,NXTCHR
.PALP2= XWD     000,ILCH
.PAAS2= XWD     000,ILCH
.PAEX2= XWD     000,ILCH
.PAAT2= XWD     000,ILCH
.PACO2= XWD     PB2,STOGAN
.PATE2= XWD     000,ILCH
.PASP2= XWD     000,ILCH
.PAPO2= XWD     000,ILCH
.PAQU2= XWD     000,ILCH
.PAPU2= XWD     000,ILCH
.PADA2= XWD     000,ILCH

.PBIC2= XWD     000,ILCH
.PBAL2= XWD     000,ILCH
.PBNU2= XWD     PU2,ACCNUM
.PBRP2= XWD     000,ILCH
.PBIG2= XWD     PB2,NXTCHR
.PBLP2= XWD     000,ILCH
.PBAS2= XWD     000,ILCH
.PBEX2= XWD     000,ILCH
.PBAT2= XWD     000,ILCH
.PBCO2= XWD     000,ILCH
.PBTE2= XWD     000,ILCH
.PBSP2= XWD     000,ILCH
.PBPO2= XWD     000,ILCH
.PBQU2= XWD     000,ILCH
.PBPU2= XWD     000,ILCH
.PBDA2= XWD     000,ILCH

.PUIC2= XWD     000,ILCH
.PUAL2= XWD     000,ILCH
.PUNU2= XWD     PU2,ACCNUM
.PURP2= XWD     PR2,FIXLL
.PUIG2= XWD     PU2,NXTCHR
.PULP2= XWD     000,ILCH
.PUAS2= XWD     000,ILCH
.PUEX2= XWD     000,ILCH
.PUAT2= XWD     000,ILCH
.PUCO2= XWD     000,ILCH
.PUTE2= XWD     000,ILCH
.PUSP2= XWD     000,ILCH
.PUPO2= XWD     000,ILCH
.PUQU2= XWD     000,ILCH
.PUPU2= XWD     000,ILCH
.PUDA2= XWD     000,ILCH

.PRIC2= XWD     PR2,T137A
.PRAL2= XWD     000,ILCH
.PRNU2= XWD     000,ILCH
.PRRP2= XWD     000,ILCH
.PRIG2= XWD     PR2,NXTCHR
.PRLP2= XWD     000,ILCH
.PRAS2= XWD     000,ILCH
.PREX2= XWD     000,ILCH
.PRAT2= XWD     000,ILCH
.PRCO2= XWD     PD2,ACCCOM
.PRTE2= XWD     UF2,TRMEOL
.PRSP2= XWD     UF2,TRMNAT
.PRPO2= XWD     000,ILCH
.PRQU2= XWD     000,ILCH
.PRPU2= XWD     000,ILCH
.PRDA2= XWD     000,ILCH

.PDIC2= XWD     000,ILCH
.PDAL2= XWD     000,ILCH
.PDNU2= XWD     000,ILCH
.PDRP2= XWD     000,ILCH
.PDIG2= XWD     PD2,NXTCHR
.PDLP2= XWD     UL2,TSTLPP
.PDAS2= XWD     000,ILCH
.PDEX2= XWD     000,ILCH
.PDAT2= XWD     000,ILCH
.PDCO2= XWD     000,ILCH
.PDTE2= XWD     000,ILCH
.PDSP2= XWD     000,ILCH
.PDPO2= XWD     000,ILCH
.PDQU2= XWD     000,ILCH
.PDPU2= XWD     000,ILCH
.PDDA2= XWD     000,ILCH

.ULIC2= XWD     000,ILCH
.ULAL2= XWD     UN2,STRTUN
.ULNU2= XWD     UN2,STRTUN
.ULRP2= XWD     000,ILCH
.ULIG2= XWD     UL2,NXTCHR
.ULLP2= XWD     000,ILCH
.ULAS2= XWD     UN2,STRTUN
.ULEX2= XWD     UN2,STRTUN
.ULAT2= XWD     000,ILCH
.ULCO2= XWD     000,ILCH
.ULTE2= XWD     000,ILCH
.ULSP2= XWD     000,ILCH
.ULPO2= XWD     000,ILCH
.ULQU2= XWD     000,ILCH
.ULPU2= XWD     UN2,STRTUN
.ULDA2= XWD     UN2,STRTUN

.UNIC2= XWD     000,ILCH
.UNAL2= XWD     UN2,STOSIX
.UNNU2= XWD     UN2,STOSIX
.UNRP2= XWD     PR2,CONVUN
.UNIG2= XWD     UN2,NXTCHR
.UNLP2= XWD     000,ILCH
.UNAS2= XWD     UN2,STOSIX
.UNEX2= XWD     UN2,STOSIX
.UNAT2= XWD     000,ILCH
.UNCO2= XWD     000,ILCH
.UNTE2= XWD     000,ILCH
.UNSP2= XWD     UN2,STOSIX
.UNPO2= XWD     000,ILCH
.UNQU2= XWD     000,ILCH
.UNPU2= XWD     UN2,STOSIX
.UNDA2= XWD     UN2,STOSIX

.XLIC2= XWD     000,ILCH
.XLAL2= XWD     XN2,STRTUN
.XLNU2= XWD     XN2,STRTUN
.XLRP2= XWD     000,ILCH
.XLIG2= XWD     XL2,NXTCHR
.XLLP2= XWD     000,ILCH
.XLAS2= XWD     XN2,STRTUN
.XLEX2= XWD     XN2,STRTUN
.XLAT2= XWD     000,ILCH
.XLCO2= XWD     000,ILCH
.XLTE2= XWD     000,ILCH
.XLSP2= XWD     000,ILCH
.XLPO2= XWD     000,ILCH
.XLQU2= XWD     000,ILCH
.XLPU2= XWD     XN2,STRTUN
.XLDA2= XWD     XN2,STRTUN

.XNIC2= XWD     000,ILCH
.XNAL2= XWD     XN2,STOSIX
.XNNU2= XWD     XN2,STOSIX
.XNRP2= XWD     YR2,CONVUN
.XNIG2= XWD     XN2,NXTCHR
.XNLP2= XWD     000,ILCH
.XNAS2= XWD     XN2,STOSIX
.XNEX2= XWD     XN2,STOSIX
.XNAT2= XWD     000,ILCH
.XNCO2= XWD     000,ILCH
.XNTE2= XWD     000,ILCH
.XNSP2= XWD     XN2,STOSIX
.XNPO2= XWD     000,ILCH
.XNQU2= XWD     000,ILCH
.XNPU2= XWD     XN2,STOSIX
.XNDA2= XWD     XN2,STOSIX

.FXIC2= XWD     000,ILCH
.FXAL2= XWD     FX2,STOSIX
.FXNU2= XWD     FX2,STOSIX
.FXRP2= XWD     000,ILCH
.FXIG2= XWD     FX2,NXTCHR
.FXLP2= XWD     000,ILCH
.FXAS2= XWD     FX2,STOSIX
.FXEX2= XWD     000,ILCH
.FXAT2= XWD     000,ILCH
.FXCO2= XWD     FC2,EXTCOM
.FXTE2= XWD     FF2,TRMEOL
.FXSP2= XWD     FF2,TRMNAT
.FXPO2= XWD     FX2,STOSIX
.FXQU2= XWD     FX2,STOSIX
.FXPU2= XWD     000,ILCH
.FXDA2= XWD     000,ILCH

.FCIC2= XWD     000,ILCH
.FCAL2= XWD     FN2,STOSIX
.FCNU2= XWD     FN2,STOSIX
.FCRP2= XWD     000,ILCH
.FCIG2= XWD     FC2,NXTCHR
.FCLP2= XWD     000,ILCH
.FCAS2= XWD     FN2,STOSIX
.FCEX2= XWD     000,ILCH
.FCAT2= XWD     000,ILCH
.FCCO2= XWD     000,ILCH
.FCTE2= XWD     000,ILCH
.FCSP2= XWD     000,ILCH
.FCPO2= XWD     FN2,STOSIX
.FCQU2= XWD     FN2,STOSIX
.FCPU2= XWD     000,ILCH
.FCDA2= XWD     000,ILCH

.FNIC2= XWD     000,ILCH
.FNAL2= XWD     FN2,STOSIX
.FNNU2= XWD     FN2,STOSIX
.FNRP2= XWD     000,ILCH
.FNIG2= XWD     FN2,NXTCHR
.FNLP2= XWD     000,ILCH
.FNAS2= XWD     000,ILCH
.FNEX2= XWD     FX2,FILDOT
.FNAT2= XWD     000,ILCH
.FNCO2= XWD     FX2,FILCOM
.FNTE2= XWD     FX2,FILCOM
.FNSP2= XWD     FX2,FILCOM
.FNPO2= XWD     FN2,STOSIX
.FNQU2= XWD     FN2,STOSIX
.FNPU2= XWD     000,ILCH
.FNDA2= XWD     000,ILCH
; READ "@" TO READ NAMES FILE
.CAIC2= XWD     000,ILCH
.CAAL2= XWD     CN2,FAKPPN      ;PLUG IN PPN OF PROGRAM USER
.CANU2= XWD     CN2,FAKPPN      ;PLUG IN PPN OF PROGRAM USER
.CARP2= XWD     000,ILCH
.CAIG2= XWD     000,ILCH
.CALP2= XWD     CL2,TSTL        ;DON'T ALLOW LEFT BRACKET
.CAAS2= XWD     000,ILCH
.CAEX2= XWD     000,ILCH
.CAAT2= XWD     000,ILCH
.CACO2= XWD     000,ILCH
.CATE2= XWD     000,ILCH
.CASP2= XWD     000,ILCH
.CAPO2= XWD     000,ILCH
.CAQU2= XWD     000,ILCH
.CAPU2= XWD     000,ILCH
.CADA2= XWD     000,ILCH

.CLIC2= XWD     000,ILCH
.CLAL2= XWD     CC2,STRTUN
.CLNU2= XWD     CC2,STRTUN
.CLRP2= XWD     000,ILCH
.CLIG2= XWD     CL2,NXTCHR
.CLLP2= XWD     000,ILCH
.CLAS2= XWD     CC2,STRTUN
.CLEX2= XWD     CC2,STRTUN
.CLAT2= XWD     000,ILCH
.CLCO2= XWD     000,ILCH
.CLTE2= XWD     000,ILCH
.CLSP2= XWD     000,ILCH
.CLPO2= XWD     000,ILCH
.CLQU2= XWD     000,ILCH
.CLPU2= XWD     CC2,STRTUN
.CLDA2= XWD     CC2,STRTUN

.CCIC2= XWD     000,ILCH
.CCAL2= XWD     CC2,STOSIX
.CCNU2= XWD     CC2,STOSIX
.CCRP2= XWD     CR2,CONVUN
.CCIG2= XWD     CC2,NXTCHR
.CCLP2= XWD     000,ILCH
.CCAS2= XWD     CC2,STOSIX
.CCEX2= XWD     CC2,STOSIX
.CCAT2= XWD     000,ILCH
.CCCO2= XWD     000,ILCH
.CCTE2= XWD     000,ILCH
.CCSP2= XWD     CC2,STOSIX
.CCPO2= XWD     000,ILCH
.CCQU2= XWD     000,ILCH
.CCPU2= XWD     CC2,STOSIX
.CCDA2= XWD     CC2,STOSIX

.CRIC2= XWD     000,ILCH
.CRAL2= XWD     CN2,ENDUN
.CRNU2= XWD     CN2,ENDUN
.CRRP2= XWD     000,ILCH
.CRIG2= XWD     CR2,NXTCHR
.CRLP2= XWD     000,ILCH
.CRAS2= XWD     000,ILCH
.CREX2= XWD     000,ILCH
.CRAT2= XWD     000,ILCH
.CRCO2= XWD     000,ILCH
.CRTE2= XWD     000,ILCH
.CRSP2= XWD     000,ILCH
.CRPO2= XWD     000,ILCH
.CRQU2= XWD     000,ILCH
.CRPU2= XWD     000,ILCH
.CRDA2= XWD     000,ILCH

.CNIC2= XWD     000,ILCH
.CNAL2= XWD     CN2,STOSIX
.CNNU2= XWD     CN2,STOSIX
.CNRP2= XWD     000,ILCH
.CNIG2= XWD     CN2,NXTCHR
.CNLP2= XWD     000,ILCH
.CNAS2= XWD     000,ILCH
.CNEX2= XWD     CX2,FILDOT
.CNAT2= XWD     000,ILCH
.CNCO2= XWD     000,ILCH
.CNTE2= XWD     CX2,FILCOM
.CNSP2= XWD     CX2,FILCOM
.CNPO2= XWD     000,ILCH
.CNQU2= XWD     000,ILCH
.CNPU2= XWD     000,ILCH
.CNDA2= XWD     000,ILCH

.CXIC2= XWD     000,ILCH
.CXAL2= XWD     CX2,STOSIX
.CXNU2= XWD     CX2,STOSIX
.CXRP2= XWD     000,ILCH
.CXIG2= XWD     CX2,NXTCHR
.CXLP2= XWD     000,ILCH
.CXAS2= XWD     000,ILCH
.CXEX2= XWD     000,ILCH
.CXAT2= XWD     000,ILCH
.CXCO2= XWD     000,ILCH
.CXTE2= XWD     IS2,CEOL;       TERMINATES NAMES FILENAME WITH TE
.CXSP2= XWD     IS2,CNAT;       TERMINATES NAMES FILENAME WITH SP
.CXPO2= XWD     000,ILCH
.CXQU2= XWD     000,ILCH
.CXPU2= XWD     000,ILCH
.CXDA2= XWD     000,ILCH

.PPIC2= XWD     000,ILCH
.PPAL2= XWD     000,ILCH
.PPNU2= XWD     PN2,ACCNUM
.PPRP2= XWD     000,ILCH
.PPIG2= XWD     PP2,NXTCHR
.PPLP2= XWD     000,ILCH
.PPAS2= XWD     000,ILCH
.PPEX2= XWD     000,ILCH
.PPAT2= XWD     000,ILCH
.PPCO2= XWD     000,ILCH
.PPTE2= XWD     000,ILCH
.PPSP2= XWD     000,ILCH
.PPPO2= XWD     000,ILCH
.PPQU2= XWD     000,ILCH
.PPPU2= XWD     000,ILCH
.PPDA2= XWD     000,ILCH

.PNIC2= XWD     000,ILCH
.PNAL2= XWD     000,ILCH
.PNNU2= XWD     PN2,ACCNUM
.PNRP2= XWD     000,ILCH
.PNIG2= XWD     PN2,NXTCHR
.PNLP2= XWD     000,ILCH
.PNAS2= XWD     000,ILCH
.PNEX2= XWD     000,ILCH
.PNAT2= XWD     000,ILCH
.PNCO2= XWD     PC2,PCO
.PNTE2= XWD     KF2,PTE
.PNSP2= XWD     KF2,PSP
.PNPO2= XWD     000,ILCH
.PNQU2= XWD     000,ILCH
.PNPU2= XWD     000,ILCH
.PNDA2= XWD     PX2,PXA

.PCIC2= XWD     000,ILCH
.PCAL2= XWD     000,ILCH
.PCNU2= XWD     PN2,ACCNUM
.PCRP2= XWD     000,ILCH
.PCIG2= XWD     PC2,NXTCHR
.PCLP2= XWD     000,ILCH
.PCAS2= XWD     000,ILCH
.PCEX2= XWD     000,ILCH
.PCAT2= XWD     000,ILCH
.PCCO2= XWD     000,ILCH
.PCTE2= XWD     000,ILCH
.PCSP2= XWD     000,ILCH
.PCPO2= XWD     000,ILCH
.PCQU2= XWD     000,ILCH
.PCPU2= XWD     000,ILCH
.PCDA2= XWD     000,ILCH

.PXIC2= XWD     000,ILCH
.PXAL2= XWD     PE2,PEN
.PXNU2= XWD     PS2,ACCNUM
.PXRP2= XWD     000,ILCH
.PXIG2= XWD     PX2,NXTCHR
.PXLP2= XWD     000,ILCH
.PXAS2= XWD     000,ILCH
.PXEX2= XWD     000,ILCH
.PXAT2= XWD     000,ILCH
.PXCO2= XWD     000,ILCH
.PXTE2= XWD     000,ILCH
.PXSP2= XWD     000,ILCH
.PXPO2= XWD     000,ILCH
.PXQU2= XWD     000,ILCH
.PXPU2= XWD     000,ILCH
.PXDA2= XWD     000,ILCH

.PEIC2= XWD     000,ILCH
.PEAL2= XWD     000,ILCH
.PENU2= XWD     000,ILCH
.PERP2= XWD     000,ILCH
.PEIG2= XWD     PE2,NXTCHR
.PELP2= XWD     000,ILCH
.PEAS2= XWD     000,ILCH
.PEEX2= XWD     000,ILCH
.PEAT2= XWD     000,ILCH
.PECO2= XWD     PC2,PCO
.PETE2= XWD     KF2,PTE
.PESP2= XWD     KF2,PSP
.PEPO2= XWD     000,ILCH
.PEQU2= XWD     000,ILCH
.PEPU2= XWD     000,ILCH
.PEDA2= XWD     000,ILCH

.PSIC2= XWD     000,ILCH
.PSAL2= XWD     000,ILCH
.PSNU2= XWD     PS2,ACCNUM
.PSRP2= XWD     000,ILCH
.PSIG2= XWD     PS2,NXTCHR
.PSLP2= XWD     000,ILCH
.PSAS2= XWD     000,ILCH
.PSEX2= XWD     000,ILCH
.PSAT2= XWD     000,ILCH
.PSCO2= XWD     PC2,PCO
.PSTE2= XWD     KF2,PTE
.PSSP2= XWD     KF2,PSP
.PSPO2= XWD     000,ILCH
.PSQU2= XWD     000,ILCH
.PSPU2= XWD     000,ILCH
.PSDA2= XWD     000,ILCH

.TDIC2= XWD     000,ILCH
.TDAL2= XWD     000,ILCH
.TDNU2= XWD     000,ILCH
.TDRP2= XWD     000,ILCH
.TDIG2= XWD     TD2,NXTCHR
.TDLP2= XWD     TL2,T137LP
.TDAS2= XWD     000,ILCH
.TDEX2= XWD     000,ILCH
.TDAT2= XWD     000,ILCH
.TDCO2= XWD     000,ILCH
.TDTE2= XWD     000,ILCH
.TDSP2= XWD     000,ILCH
.TDPO2= XWD     000,ILCH
.TDQU2= XWD     000,ILCH
.TDPU2= XWD     000,ILCH
.TDDA2= XWD     000,ILCH

.TLIC2= XWD     000,ILCH
.TLAL2= XWD     TN2,TRTCHR
.TLNU2= XWD     TN2,TRTCHR
.TLRP2= XWD     000,ILCH
.TLIG2= XWD     TL2,NXTCHR
.TLLP2= XWD     000,ILCH
.TLAS2= XWD     TN2,TRTCHR
.TLEX2= XWD     TN2,TRTCHR
.TLAT2= XWD     000,ILCH
.TLCO2= XWD     000,ILCH
.TLTE2= XWD     000,ILCH
.TLSP2= XWD     000,ILCH
.TLPO2= XWD     000,ILCH
.TLQU2= XWD     000,ILCH
.TLPU2= XWD     TN2,TRTCHR
.TLDA2= XWD     TN2,TRTCHR

.TNIC2= XWD     000,ILCH
.TNAL2= XWD     TN2,TRTCHR
.TNNU2= XWD     TN2,TRTCHR
.TNRP2= XWD     TY2,TRST
.TNIG2= XWD     TN2,NXTCHR
.TNLP2= XWD     000,ILCH
.TNAS2= XWD     TN2,TRTCHR
.TNEX2= XWD     TN2,TRTCHR
.TNAT2= XWD     000,ILCH
.TNCO2= XWD     000,ILCH
.TNTE2= XWD     000,ILCH
.TNSP2= XWD     TN2,TRTCHR
.TNPO2= XWD     000,ILCH
.TNQU2= XWD     000,ILCH
.TNPU2= XWD     TN2,TRTCHR
.TNDA2= XWD     TN2,TRTCHR

.TRIC2= XWD     000,ILCH
.TRAL2= XWD     000,ILCH
.TRNU2= XWD     000,ILCH
.TRRP2= XWD     000,ILCH
.TRIG2= XWD     TR2,NXTCHR
.TRLP2= XWD     000,ILCH
.TRAS2= XWD     000,ILCH
.TREX2= XWD     000,ILCH
.TRAT2= XWD     000,ILCH
.TRCO2= XWD     PD2,ACCCOM
.TRTE2= XWD     UF2,TRMEOL
.TRSP2= XWD     UF2,TRMNAT
.TRPO2= XWD     000,ILCH
.TRQU2= XWD     000,ILCH
.TRPU2= XWD     000,ILCH
.TRDA2= XWD     000,ILCH

.TYIC2= XWD     000,ILCH
.TYAL2= XWD     FN2,ENDUN
.TYNU2= XWD     FN2,ENDUN
.TYRP2= XWD     000,ILCH
.TYIG2= XWD     TY2,NXTCHR
.TYLP2= XWD     000,ILCH
.TYAS2= XWD     FN2,ENDUN
.TYEX2= XWD     000,ILCH
.TYAT2= XWD     000,ILCH
.TYCO2= XWD     PD2,ACCCOM
.TYTE2= XWD     UF2,TRMEOL
.TYSP2= XWD     UF2,TRMNAT
.TYPO2= XWD     FN2,ENDUN
.TYQU2= XWD     FN2,ENDUN
.TYPU2= XWD     000,ILCH
.TYDA2= XWD     000,ILCH

;INTERMEDIATE STATES FOR SECOND PART OF COMMAND

ISTAB2: BLOCK   0
        ISTATE  IS,2;   INITIAL STATE
        ISTATE  KN,2;   KEYWORD PARTIALLY READ
        ISTATE  GA,2;   GAN - "G" JUST READ
        ISTATE  GN,2;   GAN - PARTIALLY READ
        ISTATE  GC,2;   GAN - COMMA JUST READ
        ISTATE  GD,2;   GAN - DASH JUST READ
        ISTATE  GS,2;   GAN - SECOND GAN OF RANGE PARTIALLY READ
        ISTATE  GE,2;   GAN - E FOR END JUST READ IN 2ND HALF OF RANGE
        ISTATE  YL,2;   PPN OR F - LEFT BRACKET JUST READ
        ISTATE  YA,2;   PPN OR F - ACCT NUMBER PARTIALLY READ
        ISTATE  YC,2;   PPN OR F - COMMA JUST READ
        ISTATE  YU,2;   PPN OR F - USER NUMBER PARTIALLY READ
        ISTATE  YR,2;   PPN OR F - RIGHT BRACKET JUST READ
        ISTATE  PL,2;   PPN - LEFT BRACKET JUST READ
        ISTATE  PA,2;   PPN - ACCT NUMBER PARTIALLY READ
        ISTATE  PB,2;   PPN - COMMA BETWEEN GAN AND UUN JUST READ
        ISTATE  PU,2;   PPN - USER NUMBER PARTIALLY READ
        ISTATE  PR,2;   PPN - RIGHT BRACKET JUST READ
        ISTATE  PD,2;   PPN - COMMA BETWEEN PPNS JUST READ
        ISTATE  UL,2;   UN - LEFT PAREN JUST READ
        ISTATE  UN,2;   UN - NAME PARTIALLY READ
        ISTATE  XL,2;   UN OR F - LEFT PAREN JUST READ
        ISTATE  XN,2;   UN OR F - NAME PARTIALLY READ
        ISTATE  FX,2;   F - EXTENSION PARTIALLY READ
        ISTATE  FC,2;   F - COMMA JUST READ
        ISTATE  FN,2;   F - NAME PARTIALLY READ
        ISTATE  CA,2;   @ JUST READ TO START NAMES FILE
        ISTATE  CL,2;   LEFT PAREN READ
        ISTATE  CC,2;   USER NAME PARTLY READ
        ISTATE  CR,2;    RIGHT PAREN READ
        ISTATE  CN,2;   NAME PARTLY READ
        ISTATE  CX,2;   EXTENSION PARTLY READ
        ISTATE  PP,2;   POS - "P" OR "#" JUST READ
        ISTATE  PN,2;   POS - NUMBER PARTIALLY READ
        ISTATE  PC,2;   POS - COMMA JUST READ
        ISTATE  PX,2;   POS - DASH JUST READ
        ISTATE  PE,2;   POS - E JUST READ TO END RANGE
        ISTATE  PS,2;   POS - 2ND HALF OF RANGE PARTIALLY READ
        ISTATE  TD,2;   BACK ARROW READ AFTER USER NAME
        ISTATE  TL,2;   LEFT PAREN JUST READ FOR TAPE USER NAME
        ISTATE  TN,2;   TAPE USER NAME PARTIALLY READ
        ISTATE  TR,2;   RT PAREN READ (LIKE PR BUT BACKARROW DISALLOWED)
        ISTATE  TY,2;   RT PAREN READ (LIKE YR BUT BACKARROW DISALLOWED)

;TERMINAL STATES FOR SECOND PART OF COMMAND

TSTAB2: BLOCK   0
        TSTATE  KF,2;   KEYWORD FOUND
        TSTATE  GF,2;   GAN FOUND
        TSTATE  UF,2;   USER NAME FOUND
        TSTATE  FF,2;   FILE NAME FOUND
       ;TSTATE  PF,2;   POSITION NUMBER FOUND

;SYMBOLS FORMING STATE DIAGRAM FOR THIRD PART OF COMMAND

.ISIC3= XWD     000,ILCH
.ISAL3= XWD     KN3,STOCHR
.ISNU3= XWD     000,ILCH
.ISRP3= XWD     000,ILCH
.ISIG3= XWD     IS3,NXTCHR
.ISLP3= XWD     000,ILCH
.ISAS3= XWD     000,ILCH
.ISEX3= XWD     000,ILCH
.ISAT3= XWD     000,ILCH
.ISCO3= XWD     000,ILCH
.ISTE3= XWD     000,CDISP
.ISSP3= XWD     IS3,NXTCHR
.ISPO3= XWD     000,ILCH
.ISQU3= XWD     KN3,STOCHR
.ISPU3= XWD     000,ILCH
.ISDA3= XWD     000,ILCH

.KNIC3= XWD     000,ILCH
.KNAL3= XWD     KN3,STOCHR
.KNNU3= XWD     000,ILCH
.KNRP3= XWD     000,ILCH
.KNIG3= XWD     KN3,NXTCHR
.KNLP3= XWD     000,ILCH
.KNAS3= XWD     000,ILCH
.KNEX3= XWD     000,ILCH
.KNAT3= XWD     000,ILCH
.KNCO3= XWD     000,ILCH
.KNTE3= XWD     KF3,TRMEOL
.KNSP3= XWD     KF3,TRMNAT
.KNPO3= XWD     000,ILCH
.KNQU3= XWD     KN3,STOCHR
.KNPU3= XWD     000,ILCH
.KNDA3= XWD     000,ILCH

;INTERMEDIATE STATE FOR THIRD PART OF COMMAND

ISTAB3: BLOCK   0
        ISTATE  IS,3;   INITIAL STATE
        ISTATE  KN,3;   KEYWORD PARTIALLY READ


;TERMINAL STATES FOR THIRD PART OF COMMAND


TSTAB3: BLOCK   0
        TSTATE  KF,3;   KEYWORD FOUND

;*

        VAR
        END
  %"