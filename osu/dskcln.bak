TITLE DSKCLN - DAMAGE CLEANUP AND DAMAGE ASSESMENT

IFNDEF MAKSW,<MAKSW=0>
IFNDEF DEBUG,<DEBUG==0>
IFN MAKSW,<DEBUG==0>

;                  Table of Contents for DSKCLN
;
;
;			   Section			      Page
;
;    1. Revision history . . . . . . . . . . . . . . . . . . .   2
;    2. Definitions  . . . . . . . . . . . . . . . . . . . . .   3
;    3. BEGINNING OF CODE  . . . . . . . . . . . . . . . . . .   7
;    4. Call main loop . . . . . . . . . . . . . . . . . . . .  13
;    5. Start FIXUP pass . . . . . . . . . . . . . . . . . . .  15
;    6. MFDPRC - Process one page in the MFD . . . . . . . . .  21
;    7. UFDPRC - Process one data page in a UFD  . . . . . . .  23
;    8. FILPRC - Process a file  . . . . . . . . . . . . . . .  28
;    9. SPRPTR - Found a spare pointer, go down a level  . . .  29
;   10. RIBEOF - Go back to prime RIB if in a spare  . . . . .  31
;   11. BAD RIB Routine  . . . . . . . . . . . . . . . . . . .  32
;   12. PAGE HOLE DATA . . . . . . . . . . . . . . . . . . . .  67
SUBTTL	Revision history

VRAT==37	; version
VMIN=="@"-"@"	; minor release
VEDT==110	; edits

; %xxx - Add new rib bit RBHOLD for DKSCLN use only.  This bit means that
;	 DSKCLN thought the rib was good but needed to be marked bad for
;	 one reason or another.  RBREAL will be turned off so that it will
;	 look like a hole to the monitor.  DSKCLN will keep the page marked
;	 in the SATS as used until all users of this rib pointer have been
;	 deleted.  /CARL        **** NOT IMPLEMENTED YET ****
;
;37(110)   5-Feb-88/JMS  Preserve PPN when deleting file due to NAM or SLF.
;37(107)  21-Aug-87/JMS  Output elapsed time when done.
;37(106)  12-Aug-87/JMS  Start of new major version
;	Don't die when critical file is damaged.
;	Use DSKCHR info for unit 0 when doing HOME.SYS checking, to not die
;	on a multipack 2020 system.  (The pointer to FEFILE.SYS on DSKB0 only.)
;   (105)  5-Mar-87/JMS  Free pages is a minor error, not a severe one.
;   (104)  4-Mar-87/JMS  Only 1 NOT MARKED IN SAT message per file in check
;	   mode.  This is not a severe error - message was changed.
;   (103)  2-Feb-87/JMS  Don't run out of core when CLRALC needs running.
;   (102) 23-Jan-87/JMS  Output "starting pass 2" and "SATs written".
;   (101) 22-Jan-87/JMS  Set up T before processing DOBAD list.
; %36J - Fix bug from 36H where size written wrong error occurred.  /JMS
; %36I - Leave residual reason for FILPRC fail return in T3 when possible.
; %36H - Output usernames in RECOV.SYS.   /JMS
; %36G - Make sure files which DSKCLN marks as losing data always show up
;	 in (SYS)RECOV.SYS when DSKCLN is finished.  /CARL
;      - Print file name when punching holes.  We now have prime rib in
;	 BUF while setting up FIXBAD chain. /CARL
; %36F - Fixup bad rib reason messages and multiply used code.  /CARL
; %36E - Use RIBFIX instead of FILFIX for possible spare ribs.  /CARL
; %36D - Print more info at the appropriate points.  /CARL
; %36C - Setup T3 with various reasons for punching holes.  /CARL
; %36B - Put option 2 for printing out all holes.  Print other holes too.
;      - Print usernames and PPNs where possible.  /JMS
; %36A - Print a messge when DSKCLN punches a hole in a file.  /CARL

;version 36 11/15/81 DWS
; 1. make sure system is super shut before running in fix mode.
; 2. try to improve error messages for critical files (in/around crterr:).
; 3. comment out dead code (swpprc:) from edit 35.
;version 35 7/17/81 WRS
; 1. continue analysis if critical file damaged while in check mode
; 2. eliminate SWAP.SYS as a critical file
;VERSION 34
;CHECK FOR UNIT OUT OF RANGE IN FNDSK1
;VERSION 33.
;DSKCLN CAN NOW CONDITIONALLY PROCESS SELECTED SUBSETS OF FILE
; STRUCTURES.  THE SUBSET DESIRED IS PASSED TO DSKCLN BY A TYPE
; NUMBER (AN INTERER FROM 0-7) ENTERED BY THE OPER IN CHECKING
; MODE OR GETTABED IF FIX MODE.  THREE TYPES ARE CURRENTLY AVAILABLE:
; 0  NONE:  THIS STRUCTURE NEEDS NO ANALYSIS
; 1  FAST:  EXAMINE ONLY THOSE FILES WHICH HAVE RECENTLY UNDERGONE
;	    ALLOCATION.  THIS IS ACCOMPLISHED BY CHECKING THE BIT
;	    UFPALC IN THE UFD ENTRY FOR EVERY FILE.  AFTER ANALYSIS,
;	    IF FIXING IS BEING PERFORMED, THE DSKCLN GENERATED SATS
;	    ARE ANDED WITH THE DSK SATS.
; 7  FULL:  CHECK AND/OR CORRECT FILE PROBLEMS OVER ENTIRE STR.  THIS
;	    WAS THE ONLY MODE PREVIOUSLY AVAILABLE.
; DSKCLR CALLS WERE MODIFIED TO CONFORM TO THE NEW DSKCLR UUO FORMAT
; WHICH WAS NECESSARY TO SUPPORT MODE. 0.  IDENT NOW REPORTS MODE.
; OUTPUT TO TTY NO LONGER USES BUFFERED I/O.  DSKCLN IDENTIFIES
; ITSELF, REPORTS KEY FACTS ON STRUCTURE UNDER ANALYSIS, AND PRINTS
; TERMINATION MESSAGE ON CTY. 4/25/80 /TLC.
;VERSION 32.
;MERGED 2020 MODIFICATIONS WITH DSKCLN VERSION 31 USING DSKCLN V30
; AS THE MASTER FILE / FEB 8,1980 ELB/ SEE BELOW DESCRIPTION FOR
; 2020 CHANGES
;MODIFIED 1/17/79 BY DSB TO USE DSKCHR TO GET SOME OF THE HOME FILE
; STRUCTURE: ADDRESSES OF HOME, BAT PAGES AND SIZE & LENGTH OF THE
; BOOTSTRAP AREA.
SUBTTL	Definitions

	OPDEF	ONEJOB	[CALLI 777760]
	OPDEF	DATUUO	[CALLI 777723]
	OPDEF	DSKCLR	[CALLI 777756]
	OPDEF	SETJAL	[CALLI 777757]
	OPDEF	SETUUO	[CALLI 000075]
	OPDEF	CHANIO	[043000,,0]
	  CIO.RL==0	;RELEASE
	  CIO.OP==13	;OPEN
	  CIO.IN==14	;IN
	  CIO.OT==15	;OUT
	  CIO.ST==16	;SETSTS
	  CIO.SK==24	;SEEK
	  CIO.PI==31	;PAGE USETI
	  CIO.PO==32	;PAGE USETO
	OPDEF	PJRST	[JRST]
	DEFINE	PFALL(LABEL),<IF2,<IFN .-LABEL,<PRINTX PFALL error at LABEL>>>

;PARAMETERS FROM COMMOD.MAC

HOMNAM==0	;"HOM" IN SIXBIT
HOMSNM==2	;FILE STR NAME UNIT IS IN
HOMNXT==3	;ID OF NEXT UNIT IN FILE STRUCTURE
HOMLOG==5	;LOGICAL NAME OF THIS UNIT IN FILE STR (DSKB5)
HOMLUN==6	;LOGICAL UNIT IN STR
HOMP4S==7	;PAGES FOR SWAPPING
HOMSLP==13	;FIRST LOGICAL BLOCK FOR SWAPPING
HOMSPU==15	;SATS ON THIS UNIT
HOMOVR==16	;OVERDRAW ALLOWED
HOMSAT==17	;LOGICAL BLOCK WITHIN STR OF 1ST RIB FOR SAT.SYS
HOMHMS==20	;LOGICAL BLOCK WITHIN STR OF 1ST RIB FOR HOME.SYS
HOMSWP==21	;LOGICAL BLOCK WITHIN STR OF 1ST RIB FOR SWAP.SYS
HOMSUF==23	;LOGICAL BLOCK WITHIN STR OF 1ST RIB FOR SYS UFD
HOMMFD==25	;LOGICAL BLOCK WITHIN STR OF 1ST MFD RIB
HOMHSH==27	;HASH CODE FOR DIRECTORIES STORED HERE
HOMCOD==776	;CONAINS UNLIKELY CODE
  CODHOM==070717;UNLIKELY CODE FOR HOME PAGE
HOMSLF==777	;THIS BLOCK WITHIN UNIT

BATNAM==0	;INFO FOR BAT BLOCKS
BATFIR==1	;AOBJN POINTER TO DATA
  BATNBB==0	;Number of additional bad pages (1st word of pair)
  BASNBB==^D9	;SIZE OF FIELD
  BANNBB==^D8	;LOW ORDER BIT (FOR BYTE POINTER)
  BATELB==1	;PAGE NUMBER OF ERROR WITHIN REGION (2nd word of pair)
BATCOD==776
  CODBAT==505050
BATSLF==777

RIBRIB==0	;BACK POINTER IN RIB
RIBRPS==1	;UP LEVEL WORD POINTER  [B
RIBSZS==2	;SIZE OF A SPARE RIB POINTER IN THIS RIB
RIBSNM==3	;NUMBER OF SPARE RIBS IN TOP LEVEL POINTER
RIBSFS==4	;FIRST POINTER IN SPARE RIB
RIBPPN==4	;PPN, NAME, EXT, etc in prime RIB only
RIBNAM==5
RIBEXT==6
RIBPVW==7
RIBSIZ==10
RIBLCW==17
  RIPALC==(1B7)	;FILE MODIFIED RECENTLY (IN LH RIBLCW)
RIBSTS==22
  RIPNUB==400000
  RIPDIR==400000
  RIPBDA==1	;FILE FOUND BAD BY DAMAGE ASSESMENT
RIBUSD==30
RIBUNM==32	;USER NAME
RIBMXA==27
RIBALP==36	;NUMBER OF PAGES ALLOCATED
RIBPFS==51	;FIRST POINTER IN PRIME RIB
RIBLST==775	;LAST POINTER IN ANY RIB
  RBLVPR==RIBLST-RIBPFS+1	;NUMBER OF POINTERS IN PRIME RIB
  RBLVSR==RIBLST-RIBSFS+1	;NUMBER OF POINTERS IN SPARE RIB
RIBCOD==776
  CODRIB==666666	;Code in RIBCOD for a RIB
RIBSLF==777	;Pointer to self

;Format of retrieval pointers
  PTSUNI==^D8	;UNIT FIELD IN POINTER
  PTNUNI==^D16
  PTSPNO==^D19
  PTNPNO==^D35
  RBSPAR==400000	;SPARE RIB POINTER
  RBREAL==200000	;REAL POINTER
  RBHOLD==020000	;HOLD POINTER (BAD OR MULTIPLY USED)

PAGSIZ==1000		;END PARAMETERS FROM COMMOD.MAC
;ACS

M=0
T=1
T1=T+1
T2=T+2
T3=T+3
T4=T+4
N=6
N1=N+1
CH=10
CHAN=11
U=12
P1=13
P2=P1+1
P3=P2+1
P4=P3+1
P=17

;IO CHANNELS

DSK==0		;FOR READING DISK
LPT==16		;FOR OUTPUT
MXCHN==16	;MAX NUMBER OF CHANNELS TO HAVE
;*;FIL==17	;(never used)

;Offsets into DSKCHR block
  .CHSNM==4	;NAME OF STR
  .CHCHR==5	;CHARACTERISTICS
  .CHBPU==6	;BLOCKS ON THIS UNIT
  .CHHA==20	;HOME PAGE 1,,HOME PAGE 2
  .CHBA==21	;BAT PAGE 1,,BAT PAGE 2
  .CHBSA==22	;# PAGES IN BOOTSTRAP AREA,,FIRST PAGE IN BOOTSTRAP AREA
  .CHLEN==1+.CHBSA	;WORDS IN DSKCHR ARGUMENT LIST


	DEFINE ERRLEV (A)
<	XCT A,[PUSHJ P,ERLSET]>

;FILE LOOKUP ENTER INDICES

FLMNAM==2
FLMEXT==3
FLMPPN==1
FLMSTS==17	;.RBSTS file status bits
FLMUNM==27	;Username field  (2 words)
FLMUN1==30
MFDPPN=<XWD 1,1>
SYSPPN=<XWD 1,4>
UFDNAM==0	;NAME
UFDEXT==1	;EXTENSION (LEFT HALF)
UFDPRV==1
UFDUF2==1
UFDTMD==2
UFDLIC==3
UFDALC==3
UFDRBP==4	;POINTER TO RIB
UFDSIZ==5
UFDLST=<<1000/UFDSIZ>-1>*UFDSIZ	;LAST UFD ENTRY
UFPALC==1B22	;FILE MODIFIED RECENTLY (IN RH UFDUF2)

IF1,<
IFN DEBUG,<PRINTX DEBUG VERSION>
IFN MAKSW,<PRINTX FILE MAKER>>

IFN MAKSW!DEBUG,<FILSIZ==17777	;NUMBER OF BLOCKS PERMITTED
	FILOFS==<FILSIZ+200>/200>

;DSKCLR MODES

DC.CLR==0	;CLEAR IN-CORE DISK INFO
DC.FPC==1	;SET STTFPC FOR ALL SATS ON ALL UNITS
DC.NDS==2	;CLEAR SRPNDS ONLY

JACCT==1
JBTSTS==0
LICOPR==100000
LICSY==(1B3)
LICST==(1B6)
LICJL==(1B8)
LICRA==(3B15)
LICWA==(3B17)
LICTAB==-20
CNFTAB==11	;CONFIGURATION TABLE WITH SYSTEM NAME
LINJOB==-26	;GETTAB FOR JOB TO LINE CONVERSION

PDLSIZ==100	; stack size
ARRAY PDL[PDLSIZ]

ARRAY IOCW[2],CHRBUF[.CHLEN],BUF[1000],LOBUF[3]
ARRAY TRMBLK[^D80],CNFNAM[6],FIXREN,FIXPTR,FIXBAD[2]
ARRAY CHANU,CHANUU[MXCHN],FILNAM[FLMUN1+1],UFDPCT[1000]

IFN MAKSW!DEBUG,<ARRAY TABCMD[2],BLKCNT[FILSIZ+1]>

STAITM==17	;GETTAB ITEM AND TABLE FOR STATES WORD
STATAB==11
LOGITM==25	;GETTAB ITEM AND TABLE FOR LOGOUT NAME
LOGTAB==11
DATITM==11	;GETTAB ITEM AND TABLE FOR DATE
DATTAB==11
TIMITM==10	;GETTAB ITEM AND TABLE FOR TIME (JIFFIES)
TIMTAB==11

DCNITM==5	;GETTAB ITEM AND TABLE FOR DSKCLN TYPE
DCNTAB==15

SUUMSG==0	;DISPATCH CODE FOR SETUUO MESSAGE
SUUSTA==1	;DISPATCH CODE FOR SET SCHED (STATES)
SUUINI==2	;DISPATCH CODE FOR SETUUO INITIA PASS 2

DV.TTA==(1B4)	;IS A JOBS COMMAND PORT

;DEFINE LOCATIONS TO GO IN THE BLOCKS TO CONTROL SCAN OF
;UFD, MFD, AND FILES

	DEFINE UUU(A,B),<A==<%%Z==%%Z+B>-B>

%%Z==0
	UUU RIBLBN,1	;RETRIEVAL PNTR TO RIB
	UUU NXTPTR,1	;BLOCK NUMBER CURRENTLY BEING READ
	UUU UFDPTR,1	;POINTER TO THE UFD SLOT
	UUU UFDOGP,1	;UFD ORIGIN POINTER
	UUU ROUTIN,1	;ROUTINE TO CALL TO GET DOWN A LEVEL
	UUU SAVRIB,1000	;CURRENT RIB (PRIME OR SPARE)
	UUU DEVRSU,1	;POINTR INTO RIB INFO
	UUU DEVREL,1	;LOGICAL BLOCK NUMBER
	UUU SAVPAG,1	;ADDRESS OF EITHER MFDBUF OR UFDBUF
	UUU UFDBKF,2	;FOR CHANGES TO UFD PAGE
	UUU UFDUSD,1	;PAGES USED IN THIS UFD
	UUU FIXRBP,2	;FOR CHANGS TO RIB
	UUU UFDLSD,1	;THIS UFD HAS LOST DATA
	UUU ERRNAM,1	;FILE NAME FOR ERROR TYPE OUT
	UUU ERREXT,1
	UUU ERRPPN,1
	UUU ERRUNM,2	;USER NAME (FROM UFD)
	UUU UFDHSP,1	;POINTER TO HASH TABLE FOR UFD
	UUU SIZRIB,1	;Number of logical pages (including holes)
	UUU ALCRIB,1	;Number of real pages (excluding holes)

ARRAY MFDRIB,UFDRIB,FILRIB[%%Z]
ARRAY MFDBUF,UFDBUF[1000]
ARRAY BUFNAM[5]		; place for name,ext,ppn,username
SUBTTL	BEGINNING OF CODE

	LOC	<JOBREN==:124>
	RENADR					;REENTER address
	LOC	<JOBVER==:137>
	BYTE (3) 0 (9) VRAT (6) VMIN (18) VEDT	;Version number
	RELOC

EXTERN	JOBREL,JOBFF,JOBSA

RENADR:	SETZM DETSW	;REENTER ADDRESS
	JSP P,CHKOPR
	JRST RENAD1	;DO NOT DO THE FIX FUNCTION, JUST DSKRAT

STPT:	MOVE	P,[IOWD PDLSIZ,PDL]	; Set up the stack
	MOVEI	T,TRMCHR	;Start with CTY/TTY output routine
	MOVEM	T,TYODSP

IFE DEBUG,<
	HRROI	T,JBTSTS
	GETTAB	T,
	 JRST	NOJAL
	TLO	T,JACCT			;MAKE SURE WE DO NOT GET STOPPED
	SETJAL	T,
	 JRST	NOJAL
>; IFE DEBUG

	SETZM	DETSW#			; Clear AUTO RESTART flag
	MOVE	T,[STAITM,,STATAB]
	GETTAB	T,			;Get the SCHED setting
	 MOVEI	T,0
	TLNE	T,1			; Still in AUTO RESTART?
	SETOM	DETSW#			; Yes, set flag.

	SETOM 	FIXFLG#			;WANT TO DO THE FIXUP OPERATION
	MOVEI	M,[ASCIZ /
     D-S-K-C-L-N   version /]
	PUSHJ	P,TRMMES		;IDENTIFY OURSELF
	PUSHJ	P,PRVER			;Output version number
	PUSHJ	P,CRLF
	SKIPE	DETSW#			; Are we in AUTO RESTART?
	 JRST	STPT1			; Yes, continue checking
	SETZM	FIXFLG			; No, only checking function.
	MOVEI	M,[ASCIZ/
SYSTEM IS NOT IN AUTO-RESTART.
ONLY CHECKING FUNCTION WILL BE PERFORMED.
/]
	PUSHJ	P,TRMMES
	JRST	STPT2

STPT1:	ONEJOB				; Skip if we're the only job
	 SKIPA				; no, we're not
	JRST	GOFIX			; yes, continue checking
	MOVEI	M,[ASCIZ/
NOT THE ONLY JOB.
ONLY CHECKING FUNCTION WILL BE PERFORMED.
/]
	PUSHJ	P,TRMMES
	SETZM	FIXFLG			; Checking function only

STPT2:	JSP	P,CHKOPR		; Make sure that we have license
	HRROI	T,JBTSTS		; No, Reset JACCT
	GETTAB	T,
	 JRST	NOJAL
	TLZ	T,JACCT
	SETJAL	T,
	 JRST	NOJAL
RENAD1:	SETZM FIXFLG		;HERE FROM REENTER

GOFIX:	MOVE	P,[IOWD PDLSIZ,PDL]
	PUSHJ	P,CHKLIC	;Determine if prog has correct lic
	MOVE	T,JOBREL	;RECORD UPPER
	MOVEM	T,UPRBND	;BOUND OF CORE.
IFN MAKSW!DEBUG,<
	MOVE	T,[IOWD FILSIZ+1,BLKCNT]
	MOVEM	T,TABCMD
	SETZM	TABCMD+1>
	MOVE	T,[IOWD 1000,BUF]
	MOVEM	T,IOCW
	SETZM	IOCW+1		;SET UP FOR DISK OPERATIONS
	MOVSI	T,'STR'
	MOVEM	T,CHRBUF	;NOW SEE IF STR IS THERE
	MOVE	T,[.CHLEN,,CHRBUF]
	DSKCHR	T,
	 JRST	ALLSTR		;NOT THERE
	SKIPN	T,CHRBUF+.CHSNM
	JRST	ALLSTR		;OR NOT PART OF A STRUCTURE
	MOVEM	T,STRNAM#	;DO THIS STRUCTURE
	PUSHJ	P,CHKSTR
FINSTR:	JRST	QUIT		;DONE (WRITE DIR IF MAKSW ON).

ALLSTR:	SETZM	STRNAM
ALLSTL:	MOVE	T,STRNAM
	SYSSTR	T,		;NEXT STR IN SYSTEM
	 JRST	FINSTR
	JUMPE	T,FINSTR	;ALL DONE
	MOVEM	T,STRNAM
	PUSHJ	P,CHKSTR
	JRST	ALLSTL

;START OF ROUTINE TO CHECK A SINGLE STR

CHKSTR:	MOVEI	T,TRMSAV	;Start with CTY/TTY output routine
	MOVEM	T,TYODSP
	SETZB	T2,FSTFLG#	;INIT FAST DSKCLN FLAG
IFN MAKSW!DEBUG,<
	INIT	FIL,16		;GET THE FAKE FILE OPEN
	SIXBIT	/DSK/
	0
	 JRST	FALFAK
	MOVE	T,[SIXBIT /FAKFIL/]
	SETZB	T1,T2
	MOVEI	T3,0
IFE MAKSW,<LOOKUP FIL,T
	 JRST	FALFAK
	SETZB	T2,T3>
	ENTER	FIL,T
	 JRST	FALFAK
IFN MAKSW,<SETZM BLKCNT>
IFN DEBUG,<INPUT FIL,TABCMD>>
	SKIPE	FIXFLG
	 JRST	DCTFIX
	MOVSI	T3,'LST'	;Output to logical device LST:
	MOVSI	T4,LOBUF
	OPEN	LPT,T2
	  JRST	[MOVSI	T3,'TTY'
		 OPEN	LPT,T2
		   JRST	FALLPT
		 JRST	.+1]
	MOVE	T1,STRNAM
	MOVSI	T2,'RAT'
	SETZB	T3,T4
	ENTER	LPT,T1
	  JRST	FALLPT		;CAN NOT GET LPT

DCTENT:	MOVE	P1,[POINT 7,TRMBLK]
	MOVE	T,STRNAM
	PUSHJ	P,PR6BIT
	PUSHJ	P,NULL		;TERMINATE STRING
	OUTSTR	TRMBLK
	OUTSTR	[ASCIZ / MODE CODE: /]	;QUERY USER FOR TYPE CODE
	INCHRW	T		;GET HIS RESPONSE
	SUBI	T,"0"		;CONVERT TO BINARY
	JRST	DCT1
  PAGE
DCTFIX:	MOVE	T,[DCNITM,,DCNTAB]	;GET TYPE CODE FROM
	GETTAB	T,			; SYSTEM
	  MOVEI	T,7		;DEFAULT TO FULL
DCT1:	TDNE	T,[-10]		;DOES CODE OVERFLOW ITS FIELD?
	 JRST	DCNDEF		;YES
	XCT	DCNDIS(T)	;DISPATCH ON TYPE
	JRST	CHKST1		;CODE DEFINED

DCNDIS:	JRST	DONST1		;0  NONE
	SETOM	FSTFLG		;1  FAST
	JRST	DCNDEF		;2
	JRST	DCNDEF		;3
	JRST	DCNDEF		;4
	JRST	DCNDEF		;5
	SETOM	VERBOS#		;6  VERBOSE
	JFCL			;7  FULL

DCNNAM:	SIXBIT /NONE/	;0
	SIXBIT /FAST/	;1
	0		;2
	0		;3
	0		;4
	0		;5
	SIXBIT /VERBOS/	;6
	SIXBIT /FULL/	;7

DCNDEF:	SKIPE	FIXFLG
	JRST	DCT2
	OUTSTR	[ASCIZ /
LEGAL CODES ARE: 0=NONE, 1=FAST, 6=VERBOSE, 7=FULL.
/]
	JRST	DCTENT		;GIVE USER ANOTHER TRY
DCT2:	MOVE	P1,[POINT 7,TRMBLK]	;MODE READ FROM MONITOR
	MOVE	T,STRNAM		; IS NOT DEFINED, SO
	PUSHJ	P,PR6BIT		; INDICATE ON CTY
	MOVEI	M,[ASCIZ /.  MODE: /]
	PUSHJ	P,MSG
	MOVE	N,DCN
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ / NOT DEFINED, DEFAULTING TO 7.
/]
	PUSHJ	P,MSG
	PUSHJ	P,NULL		;TERMINATE STRING
	MOVEI	M,TRMBLK
	PUSHJ	P,TRMMES
	MOVEI	T,7		;DEFAULT TO FULL DSKCLN
CHKST1:	MOVEM	T,DCN#		;SAVE TYPE FOR FUTURE REFERENCE
	HLRZ	T,JOBSA
	HRLI	T,U
	MOVEM	T,PTRPPU#	;TO PUT BLOCKS/UNIT FOR EACH UNIT
	SETZB	U,STRPPU#	;FOR STR
SETTLE:	PUSHJ	P,LNAME
	MOVE	T,[.CHLEN,,CHRBUF]
	DSKCHR	T,
	  JRST	INITL		;FINALLY OUT OF UNITS
	MOVEI	T,@PTRPPU
	PUSHJ	P,GETCOR	;GET MORE CORE, IF NECESSARY.
	MOVE	T,.CHBPU+CHRBUF
	MOVEM	T,@PTRPPU	;SAVE BLOCKS/UNIT
	CAMLE	T,STRPPU	;GET LARGEST FOR STR
	MOVEM	T,STRPPU
	AOJA	U,SETTLE	;NOW FOR NEXT UNIT
;Build unit and SAT tables

INITL:	MOVEM	U,HIGHU#	;NUMBER OF UNITS
	MOVEI	U,0		;[107] Go back to unit 0
	PUSHJ	P,LNAME		;[107]
	MOVE	T,[.CHLEN,,CHRBUF] ;[107]
	DSKCHR	T,		;[107] Boots Starting Address is valid on
	  JFCL			;[107]  unit 0 only on 2020's
	HLRZ	T,JOBSA		;GET STARTING ADDRESS
	HRLI	T,U		;SET TO INDEX
	ADD	T,HIGHU
	MOVSI	T1,-UNTLEN	;NOW GENERATE POINTERS TO ALL PER UNIT TABLES
CREUNT:	MOVEM	T,@UNITAB(T1)
	ADD	T,HIGHU
	AOBJN	T1,CREUNT
	HRRZS	T
	MOVEM	T,JOBFF		;SAVE POINTER TO FREE CORE.
	PUSHJ	P,GETCOR	;GET MORE CORE, IF NECESSARY.
	SOS	HIGHU	;NOW MAKE IT NUMBER OF HIGHEST UNIT
	MOVEI	T,16	;NOW OPEN ALL I/O CHANNELS
	MOVE	T1,STRNAM	;TO POINT TO THIS STR
	SETZB	T2,TRBFLG#	;THIS FLAG NON-ZERO IF MULTIPLY USED PAGES PRESENT
	HRLI	T3,CIO.OP	;CHANIO OPEN
	MOVSI	P1,-MXCHN	;OPEN ALL CHANNELS
	HRR	T3,P1
	CHANIO	T3,T
	  JRST	OPNERR
	AOBJN	P1,.-3
	SKIPN	FIXFLG
	 OUTBUF	LPT,2		;MAKE SURE ROOM FOR OUTPUT BUFFER DECLARED
	MOVE	P1,[POINT 7,TRMBLK+1]	;INIT OUTPUT BYTE PNTR
	PUSHJ	P,IDENT		;IDENTIFY ANALYSIS OF THIS STR
	PUSHJ	P,NULL		;TERMINATE STRING
	SKIPE	FIXFLG
	 JRST	CHKST3
	MOVEI	T,LPT		;IS LPT ASSIGNED
	DEVCHR	T,		; TO THE COMMAND
	TLNE	T,DV.TTA	; PORT?
	 JRST	CHKST3
	OUTSTR	TRMBLK+1		;NO
	MOVEI	T,TYO		;OUTPUT TO LPT IN CHECK MODE
	SKIPA
CHKST3:	MOVEI	T,TRMOPR	;OUTPUT TO CTY IN FIX MODE
	MOVEM	T,TYODSP
	MOVEI	M,TRMBLK+1
	PUSHJ	P,MSG		;DUMP BUFFER
;NOW READ AND CHECK THE HOME BLOCKS

	MOVEI	U,0
	MOVEI	CHAN,0
	PUSHJ	P,HOMCHK	;READ AND DO PRELIMINARY CHECKS
	 JRST	BADHOM		;NOT A GOOD HOME BLOCK
	MOVSI	P1,-HOMTLN
HOMMOV:	MOVE	T1,HOMTAB(P1)	;GET DATA FROM FIRST HOME BLOCK
	MOVE	T,BUF(T1)
	MOVSS	T1
	MOVEM	T,(T1)
	AOBJN	P1,HOMMOV
	PUSHJ	P,HOMCOP	;NOW COPY SOME PER/UNIT DATA
NXTHOM:	SKIPN	BUF+HOMNXT	;IS THERE A NEXT UNIT?
	JRST	ENDHOM		;NO, SHOULD BE ALL DONE
	ADDI	U,1		;YES, DO IT
	PUSHJ	P,HOMCHK
	 JRST	BADHOM
	MOVSI	P1,-HOMTLN
HOMSAM:	MOVE	T1,HOMTAB(P1)	;THIS INFORMATION SHOULD BE THE SAME IN ALL HOME BLOCKS
	MOVE	T,BUF(T1)
	MOVSS	T1
	CAME	T,(T1)
	JRST	BADHOM		;IT IS NOT
	AOBJN	P1,HOMSAM
	PUSHJ	P,HOMCOP	;GET THE PER UNIT DATA
	JRST	NXT;AND TRY FOR NEXT ONE

ENDHOM:	CAME	U,HIGHU		;WE SHOULD HAVE JUUT DONE THE LAST UNT
	JRST	HOMNUM		;NO. WRONG NUMBER OF UITS

;NOW GET CORE TO HOLD SAT TABLES

	MOVEI	U,0
	MOVE	T,JOBFF
	HRRZM	T,UFDHSP+MFDRIB
	HLRZS	STRHSH		;MAKE IT BE THE CORRECT NUMBER
	ADD	T,STRHSH	;ROOM FOR HASH TABLE
	HRRZM	T,UFDHSP+UFDRIB
	ADD	T,STRHSH
	MOVN	T1,STRHSH
	HRLZM	T1,STRHAD#
SATULP:	HRRM	T,@PTRSAD	;POINTERS TO SAT ADDRESSES
	HLRZ	T1,@PTRDST	;NUMBER OF SATS ON UNIT
	ADD	T,T1
	ADDI	U,1
	CAMG	U,HIGHU
	 JRST	SATULP
  PAGE
	MOVSI	P4,-STBLEN	;NOW SET UP VARIOUS SAT TABLES
SATFUN:	MOVE	U,HIGHU		;GENERATE A SAT TABLE
SATFN1:	HRRM	T,@SATTAB(P4)
	HLRZ	T1,@PTRDST
	IMULI	T1,400
	ADD	T,T1
	SOJGE	U,SATFN1
	AOBJN	P4,SATFUN
	MOVEM	T,ENDSAT#
	HRRZ	T1,T		;SAVE FROM GETCOR.
	PUSHJ	P,GETCOR	;
	HRRZ	T,JOBFF
	HRLS	T		;SET ALL TO 1'S (UNUSED)
	SETOM	(T)
	ADDI	T,1
	BLT	T,-1(T1)
	MOVEM	T1,JOBFF
	MOVE	T,SATRIB	;READ THE RIB FOR THE SAT BLOCK
	PUSHJ	P,RIBCHK
	 JRST	SRBERR		;RIB ERROR
	MOVE	T,[BUF,,MFDBUF]	;SAVE RIB HERE
	BLT	T,MFDBUF+777
	MOVE	U,HIGHU		;NOW READ ALL SATS
NXTSTU:	HLLZ	P3,@PTRDST	;NUMBER OF SATS
	MOVNS	P3		;TURN INTO AOBJN PTR
	MOVSI	P2,-RBLVPR	;AOBJN POINTER TO SAT RIB
NXTSPT:	SKIPN	T,MFDBUF+RIBPFS(P2)
	JRST	NXTSDN		;EOF
	JUMPL	T,SRBERR	;SPARE PNTRS ARE ILLEGAL.
	TLNN	T,RBREAL	;HOLES ARE ILLEGAL.
	JRST	SRBERR		;
	LDB	T1,[POINT PTSUNI,T,PTNUNI]
	CAME	T1,U		;IS IT THIS UNIT?
	JRST	NXTSP2		;NO, CONTINUE SEARCHING
	JUMPGE	P3,SRBERR	;FOUND TOO MANY
	LDB	T1,[POINT PTSPNO,T,PTNPNO]
	HRRZ	T,P3		;THE NUMBER OF THIS SAT ON THIS UNIT
	ADD	T,@PTRSAD
	MOVEM	T1,(T)		;AND STORE THE ADDRESS
	PUSHJ	P,PAGRED	;READ IT
	 JRST	SBKERR		;ERROR
	HRRZ	T,P3
	IMULI	T,400
	ADD	T,@PTRDST	;WHERE TO PUT THE BITS
	MOVE	T1,T
	HRLI	T,BUF
	BLT	T,377(T1)
	AOBJN	P3,.+1		;COUNT ONE MORE SAT
NXTSP2:	AOBJN	P2,NXTSPT	;SEE IF ANY MORE POINTERS TO LOOK AT
NXTSDN:	JUMPL	P3,SRBERR	;NOT ENOUGH SATS
	SOJGE	U,NXTSTU	;CONTINUE FOR ALL UNITS
	SETZM	ERRSAV#		;NO ERRORS SO FAR
	MOVEI	T,FIXPTR
	PUSHJ	P,SETFIX	;SET UP POINTER CHAIN
	MOVEI	T,FIXBAD
	PUSHJ	P,SETFIX	;NO FILES TO REENTER
	SETZM	TRBFIL#
	SETZM	TRBFLG#		;NO MULTIPLY USED CLUSERS
	MOVE	T,JOBFF
	MOVEM	T,FREPTR#
	SKIPN	FIXFLG
	JRST	MGONFX

IFE DEBUG,<DSKCLR DC.CLR,	;FUNCTION 0
	     JRST .-1		;PCB I/O IN PROGRESS
             JRST   NOCLR>
	MOVEI	T,TRMOPR
	MOVEM	T,TYODSP
MGONFX:	PUSHJ	P,CHKSAT
	MOVEI	T,MFDPRC	;Process 1 page of MFD data (102 UFDs)
	MOVEM	T,MFDRIB+ROUTIN
	MOVEI	T,UFDPRC	;Process 1 page of UFD data (102 files)
	MOVEM	T,UFDRIB+ROUTIN
	MOVEI	T,MFDBUF	;Copy of current MFD data page
	MOVEM	T,MFDRIB+SAVPAG
	MOVEI	T,UFDBUF	;Copy of current UFD data page
	MOVEM	T,UFDRIB+SAVPAG
	MOVEI	P4,MFDRIB
	MOVE	T1,RIBLBN(P4)
	MOVEM	T1,MFDRBC#	;SAVE HERE FOR SPECIAL FILE CHECK
	MOVE	T,[MFDPPN]
	MOVEM	T,ERRNAM(P4)	;For type-out routines
	MOVEM	T,ERRPPN(P4)	; while processing MFD
	MOVSI	T,'UFD'
	MOVEM	T,ERREXT(P4)
	MOVEM	T,ERRUNM(P4)	;Username for [1,1] is UFD
	SETZM	ERRUNM+1(P4)
SUBTTL	Call main loop

;*******  START OF PASS 1  *******  CHECK ALL IN THE MFD  *******
PASS1:	SETZ	P2,		;NO UFD ENTRY, WE GOT HERE FROM HOME PAGE
	PUSHJ	P,MFDUFD	;PROCESS ALL FILES
	  JRST	CRTERM		;CRITICAL ERROR IN MFD
;*******  END OF PASS 1  *******  CHECK ALL IN THE MFD  *******

	SKIPN	TRBFLG		;ANY MULTIPLY USED PAGES?
	 JRST	NOTRB		;NO
	MOVEI	T,FIXPTR	;YES, RESET FIX POINTERS
	PUSHJ	P,SETFIX
	MOVEI	T,FIXBAD
	PUSHJ	P,SETFIX
	SETZM	TRBFIL
	MOVE	T,JOBFF
	MOVEM	T,FREPTR
	SKIPE	FIXFLG
	 JRST	PASS1A
	OUTPUT	LPT,0
	PUSHJ	P,IDENT
PASS1A:	MOVEI	M,[ASCIZ /
? FILE ALLOCATION ERROR - A disk page is in use by more than one file.
Starting pass 2 to locate all other files using this page.
/]
	PUSHJ	P,TRMMES
	MOVE	U,HIGHU
	HRRZ	T,@PTROST	;CLEAR RIB SAT AND OUR SAT
	SETOM	(T)
	HRLS	T
	ADDI	T,1
	MOVE	T1,ENDSAT
	BLT	T,-1(T1)
	PUSHJ	P,CHKSAT	;RECHECK SAT (IF FIXING SET BITS IN OUR SAT)
	MOVEI	P4,MFDRIB
	MOVE	T1,RIBLBN(P4)
	MOVEM	T1,MFDRBC	;FORCE RECHECK

;*******  START OF PASS 2  *******  FIND MULTIPLY USED PAGES  *******
PASS2:	SETZ	P2,		;NO UFD ENTRY, WE GOT HERE FROM HOME PAGE
	PUSHJ	P,MFDUFD
	 JRST	CRTERM
;*******  START OF PASS 2  *******  FIND MULTIPLY USED PAGES  *******

NOTRB:	PUSHJ	P,CHKBAT	;CHECK BAT BLOCKS
	MOVSI	T,-SPCLEN	;CHECK THAT ALL CRITICAL FILES FOUND
	SKIPE	FSTFLG		;IF IN FAST MODE ONLY CHECK TO SEE
	 MOVSI	T,-SPUFDN	; IF CRITICAL UFDS FOUND
	SKIPL	@SPCACT(T)	;Found?
	 JRST	MISCRT		;No, critical file missing!
	AOBJN	T,.-2
	SKIPE	FIXFLG
	 JRST	FINFIX		;Finish fixups, jump to DONSTR
;Here when done in CHECK mode
	PUSHJ	P,IDENT
	SKIPE	FSTFLG
	 JRST	FRERPT
	MOVEI	P4,LOSTAB
	SKIPE	VERBOS		;Don't print unless very verbose mode
	 PUSHJ	P,CLSSRC	;PRINT LOST PAGES
FRERPT:	MOVEI	P4,FRETAB
	PUSHJ	P,CLSSRC	;FREE PAGES
	MOVEI	P4,MLTTAB
	PUSHJ	P,CLSSRC	;AND MULTIPLY USED PAGES
	CLOSE	LPT,
	MOVE	T,ERRSAV
	OUTSTR	[ASCIZ /
/]				;[105] Blank line
	OUTSTR	@ERRTAB(T)	;OUTPUT MESSAGE
DONSTR:	RELEASE	LPT,0
	MOVSI	T,-MXCHN
	HRLI	T3,CIO.RL	;CHANIO RELEASE.
	HRR	T3,T
	CHANIO	T3,0
	AOBJN	T,.-2
	POPJ	P,		;FINISHED THIS STR, EXIT

DONST1:	MOVE	P1,[POINT 7,TRMBLK]	;INIT OUTPUT BYTE POINTER
	MOVEI	M,[ASCIZ /

NO ANALYSIS REQUIRED FOR /]
	PUSHJ	P,MSG		;BUFFER MSG
	MOVE	T,STRNAM	;GET TRANSLATE AND
	PUSHJ	P,PR6BIT	; BUFFER STR NAME
	PUSHJ	P,PDOT
	PUSHJ	P,CRLF2
	PUSHJ	P,NULL
	MOVEI	M,TRMBLK	;OUTPUT TO TTY
	PUSHJ	P,TRMMES	; OR CTY
	SKIPN	FIXFLG
	 POPJ	P,		;DONE WITH THIS STR
	DSKCLR	DC.NDS,		;TURN OFF NEED DSKCLN FLAG (FUNCTION 2)
	  POPJ	P,		;DONE WITH THIS STR
	JRST	NOJAL		;MISSING WA LIC
SUBTTL	Start FIXUP pass

FINFIX:
IFE DEBUG!MAKSW,<DSKCLR DC.CLR,	;FUNCTION 0
		  JRST	.-1	;PCBIO in progress
		  JRST	NOCLR>
	MOVE	U,HIGHU		;NOW WRITE OUT SAT TABLES
WRTSAT:	HLRZ	P3,@PTRDST	;NUMBER TO WRITE
	SUBI	P3,1		;NOW HAVE NUMBER OF THE SAT TO WRITE
	MOVE	P2,@PTRSAD	;POINTER TO SAT ADDRESSES TABLE
	HRLI	P2,P3		;SET INDEX BY SAT NUMBER
WRTSTU:	MOVE	T1,@P2		;Read SAT (to get the "M" bits)
	PUSHJ	P,PAGRED	;Read into BUF
	  JRST	SBKERR
	MOVE	T,P3
	IMULI	T,400		;NUMBER OF WORDS/SAT
	MOVE	T1,T
	ADD	T,@PTROST
	HRLS	T
	HRRI	T,BUF		;Copy our SAT
	BLT	T,BUF+377	; into the "F" bits
	SKIPN	FSTFLG		;If FAST mode, have to combine OSAT with DSAT
	 JRST	WRTST1		;In FULL mode, OSAT replaces DSAT
	MOVEI	T3,0		;INIT PNTR INTO OUR SAT BUFFER
	ADD	T1,@PTRDST	;SET UP AOBJN POINTER TO CURRENT
	HRLI	T1,-400		; DISK SAT ON CURRENT UNIT
SATIOR:	MOVE	T2,(T1)		;GET DISK VALUE FOR THIS SAT WORD
	ANDM	T2,BUF(T3)	;OR WITH OUR SAT WORD
	AOS	T3		;POINT TO NEXT OUR SAT WORD
	AOBJN	T1,SATIOR	;CONTINUE, IF NOT DONE
WRTST1:	MOVE	T1,@P2		;GET SAT ADDRESS
	PUSHJ	P,PAGWRT	;WRITE IT OUT
	MOVEI	T,0		;NOW COUNT BITS
	MOVSI	T1,-400
				;NOTE: SWAMP uses a different algorithm!
STCNT3:	MOVE	T2,BUF(T1)	;GET F BITS
	AND	T2,BUF+400(T1)	;F AND M BITS MUST BE 1
	JUMPE	T2,STCNT1	;IF NO BITS THAT ARE BOTH ONE, NO FREE PAGES
	MOVE	T3,T2		;COPY BITS INTO T3
	LSH	T3,-1		;RIGHT ONE
	AND	T3,[333333,,333333] ;MASK OUT FORMER LEAST SIG. BITS IN OCTAL DIGITS
	SUB	T2,T3		;D-[D/2]
	LSH	T3,-1		;RIGHT ANOTHER POSITION
	AND	T3,[333333,,333333] ;JUST HI ORDER
	SUBB	T2,T3		;D-[D/2]-[D/4], TWO COPIES
	LSH	T3,-3		;SHIFT RIGHT 1 OCTAL DIGIT
	ADD	T2,T3		;ADD NUMBERS IN DIGIT PAIRS
	AND	T2,[070707,,070707] ;NOW ITS BASE 64
	IDIVI	T2,77		;DIVIDE BY 63, NUMBER OF BITS IS IN T3.
	ADD	T,T3		;COUNT MORE BITS IN THIS SAT.
STCNT1:	AOBJN	T1,STCNT3
	MOVEM	T,@P2		;STORE OVER SAT ADDRESS
	SOJGE	P3,WRTSTU	;MORE SATS ON THIS UNIT
	SOJGE	U,WRTSAT	;AND MORE UNITS IN THIS STR
;Inform the monitor of the correct Free Page Count for each SAT page
	MOVE	U,HIGHU
	MOVEI	T,0
	HLRZ	T1,@PTRDST
	ADD	T,T1		;COUNT TOTAL NUMBER OF SATS
	SOJGE	U,.-2
	MOVNS	T
	HRLS	T
	MOVEI	U,0
	HRR	T,@PTRSAD
IFE DEBUG!MAKSW,<		;Tell monitor total number of free pages
	DSKCLR	DC.FPC,		;Function 1 requires an in-line argument
	  T			;Negative entries ,, list of counts
	  JFCL
>
	MOVEI	M,[ASCIZ /
SATs written to disk

/]
	PUSHJ	P,TRMMES	;End of pass 1 (and optional pass 2)
	MOVEI	T,FIXREN	;Zero out the FIXREN list
	PUSHJ	P,SETFIX	;(it will be built by FIXDEL's fixup)
	SETOM	PAGIN#		;BLOCK IN CORE

;Start of FIX-UP pass, now it's OK to write on the disk
;Format of the fix-up chain:
;   0(P3)/ Link to next ,, resume PC
;   1(P3)/ Retrieval pointer to disk page that needs fixing
;   2(P3)/ Contents of T2 (usually the value to store in the RIB)
;   3(P3)/ Contents of T3 (somtimes an index into the page)

	MOVEI	P3,FIXPTR	;Start at beginning of master fix-up list
FIXLP:	HLRZ	T1,(P3)		;Get pointer to next
	SETZM	(P3)		;Clear old link (for FIXREN)
	SKIPN	P3,T1		;Get new link into P3 (if any)
	 JRST	FIXDON
	MOVE	T,1(P3)		;Page pointer
	CAMN	T,PAGIN
	 JRST	PAGOK		;Already in BUF
	EXCH	T,PAGIN		;Get old page #
	SKIPL	T		;Nothing really
	 PUSHJ	P,PAGWTP	;Write it
	SKIPGE	T,PAGIN
	 JRST	[TLZ  T,(1B0)	;Just want to zero the entire page
		MOVEM T,PAGIN	;Do not need to read first
		JRST  PAGOK]	;Since it has an error anyway
	PUSHJ	P,PAGRDP	;Get page
	  JRST	FRDER		;Fatal read error
PAGOK:	MOVE	T2,2(P3)	;Page is in BUF.  Set T2 and T3
	MOVE	T3,3(P3)	; to what they were when ADDFIX was called
	MOVE	T,(P3)		;Current page number
	PUSHJ	P,1(T)		;Resume at <PUSHJ P,ADDFIX> + 2
	JRST	FIXLP		;Continue down fix-up chain

;The first fix-up pass creates a FIXREN chain and adds to the FIXBAD chain

FIXDON:	SKIPL	T,PAGIN		;One last page still in core?
	 PUSHJ	P,PAGWTP	;Dump it
	SKIPE	T,FIXBAD	;Any files found bad?
	 PUSHJ	P,DOBAD		;Yes, go set BDA
	SKIPE	T,FIXREN	;Any files to re-ENTER?
	 PUSHJ	P,DOREN		;Yes, go create them
	SKIPE	FIXBAD		;Anything on FIXBAD now?
	 PUSHJ	P,PRNFIL	;Yes, list them in RECOV.SYS
	JRST	DONSTR		;Finished
;Set BDA on any file that gets a hole punched in it.

;T has a pointer to the list of files to process

DOBAD:	MOVSS	T		;Pointer to chain now in RH
	RELEASE	DSK,0		;BECAUSE IT IS IN ABSOLUTE MODE
	MOVEI	T1,16
	MOVE	T2,STRNAM
	MOVEI	T3,0
	OPEN	DSK,T1
	  POPJ	P,		;CAN NOT RENAME THEM
BDAFIL:	SETZM	FILNAM
	MOVE	T1,[FILNAM,,FILNAM+1]
	BLT	T1,FILNAM+FLMSTS	;CLEAR EXTRA ENTRIES
	MOVEI	T1,FLMSTS
	MOVEM	T1,FILNAM	;SET SIZE OF LOOKUP BLOCK
	MOVE	T1,1(T)
	MOVEM	T1,FILNAM+FLMNAM
	MOVE	T1,2(T)
	HLLZM	T1,FILNAM+FLMEXT
	MOVE	T1,3(T)
	MOVEM	T1,FILNAM+FLMPPN
	LOOKUP	DSK,FILNAM
	  JRST	BDAFL1
	MOVEI	T1,RIPBDA	;Found bad by damage assessment program
	IORM	T1,FILNAM+FLMSTS
IFE DEBUG,<RENAME DSK,FILNAM>
	  JFCL
	CLOSE	DSK,0
BDAFL1:	HLRZ	T,(T)		;CHECK LINK
	JUMPN	T,BDAFIL
	POPJ	P,
;Files with bad RIBs where removed from their UFDs.
;Re-ENTER the file so that BDA can be set in it

DOREN:	HLLM	T,@FIXBAD+1	;PUT ON END OF LOST DATA LIST
	MOVSS	T		;Pointer to chain now in left half
	RELEASE	DSK,0		;BECAUSE IT IS IN ABSOLUTE MODE
	MOVEI	T1,16
	MOVE	T2,STRNAM
	MOVEI	T3,0
	OPEN	DSK,T1
	  POPJ	P,		;CAN NOT REENTER THEM
RENFIL:	SETZM	FILNAM
	MOVE	T1,[FILNAM,,FILNAM+1]
	BLT	T1,FILNAM+FLMSTS	;CLEAR EXTRA ENTRIES
	MOVEI	T1,RIPBDA
	MOVEM	T1,FILNAM+FLMSTS	;SET FOUND BAD BY DAMAGE ASSESMENT
	MOVEI	T1,FLMSTS
	MOVEM	T1,FILNAM	;SET SIZE OF ENTER BLOCK
	MOVE	T1,1(T)
	MOVEM	T1,FILNAM+FLMNAM
	MOVE	T1,2(T)
	HLLZM	T1,FILNAM+FLMEXT
	MOVE	T1,3(T)
	MOVEM	T1,FILNAM+FLMPPN
IFE DEBUG,<ENTER DSK,FILNAM>
	  JFCL
	CLOSE	DSK,0
	HLRZ	T,(T)		;CHECK LINK
	JUMPN	T,RENFIL
	POPJ	P,
;Print list of files on FIXBAD chain to the CTY and to SYS:RECOV.SYS

PRNFIL:	MOVEI	T,RCVBUF
	MOVEM	T,JOBFF		;SO WE CAN SET UP BUFFERS
	SETZB	T,P4		;P4 IS FLAG TO SAY FILE OPEN
IFE DEBUG,<MOVSI T1,'SYS'>
IFN DEBUG,<MOVSI T1,'DSK'>
	MOVSI	T2,LOBUF	;OPEN ERROR RECORD FILE
	OPEN	LPT,T
	  JRST	FILOPN		;CAN NOT OPEN, P4=0 SAYS THAT
	MOVEI	T,3
	MOVEI	T1,0
	MOVE	T2,[SIXBIT /RECOV/]
	MOVSI	T3,'SYS'
	LOOKUP	LPT,T
	  JFCL			;TRY TO GET IN UPDATE MODE
	ENTER	LPT,T
	  JRST	FILOPN		;CAN NOT GET IT
	USETI	LPT,-1		;GET TO END
	MOVEI	P4,1		;FLAG TO SAY IT IS OPEN
FILOPN:	MOVEI	T1,TYOBTH	;OUTPUT TO BOTH
	MOVEM	T1,TYODSP
	MOVE	P1,[POINT 7,TRMBLK]
	PUSHJ	P,IDENT		;IDENTIFY
	MOVEI	T1,0
	IDPB	T1,P1
	MOVEI	M,TRMBLK
	PUSHJ	P,TRMMES	;SEND MESSAGE TO TERMINAL
	SKIPN	P3,FIXBAD
	 POPJ	P,		;NO BAD FILES TO PRINT
	MOVEI	M,[ASCIZ /
The following files have lost data:
/]
	MOVE	P1,[POINT 7,TRMBLK]
	PUSHJ	P,MSG
	MOVEI	T1,0
	IDPB	T1,P1
	MOVEI	M,TRMBLK
	PUSHJ	P,TRMMES	;SEND MESSAGE (ALSO POSSIBLY TO FILE)
	MOVEI	T,FLMUN1
	MOVEM	T,FILNAM	;Size of LOOKUP block
	SETZM	FILNAM+FLMNAM
	SETZB	T1,T3
	MOVE	T2,STRNAM	;'DSKB'
	OPEN	DSK,T1
	  TDZA	P2,P2		;Can't do LOOKUPs
	MOVEI	P2,1
	MOVSS	P3		;GET LIST POINTER

;P1=TRMBLK, P2=OPEN OK, P3=LIST, P4=LPT OK

FLPLP:	MOVE	T,3(P3)	        ;PPN of next file
	SKIPE	P2		;Skip this in unlikely case of no disk
	CAMN	T,FILNAM+FLMNAM	;Match current?
	 JRST	FLPLP1
	MOVEM	T,FILNAM+FLMNAM	;New PPN
	MOVSI	T,'UFD'
	MOVEM	T,FILNAM+FLMEXT
	MOVE	T,[MFDPPN]
	MOVEM	T,FILNAM+FLMPPN
	SETZB	T1,T2
	LOOKUP	DSK,FILNAM	;Find UFD to get username
	  DMOVEM T1,FILNAM+FLMUNM ;No name if LOOKUP fails

FLPLP1:	MOVE	P1,[POINT 7,TRMBLK]
	HRRZ	T,2(P3)		;RH of extension is reason
	PUSHJ	P,PR6BIT
	PUSHJ	P,SPC
	PUSHJ	P,SPC
	HLRZ	T,2(P3)		;GET EXTENSION
	CAIN	T,'UFD'		;CHECK FOR UFD
	 JRST	FLPUFD		;POSSIBLE, MORE CHECKS
FLPNUF:	SKIPN	T,FILNAM+FLMUNM
	 JRST	FLPLP2		;No username available
	MOVEI	CH,"("
	PUSHJ	P,@TYODSP
	PUSHJ	P,PR6BIT	;1st half of username
	SKIPE	T,FILNAM+FLMUN1
	 PUSHJ	P,PR6BIT	;2nd half of username
	MOVEI	CH,")"
	PUSHJ	P,@TYODSP
FLPLP2:	MOVE	T,1(P3)
	PUSHJ	P,PR6BIT
FLPEXT:	HLLZ	T,2(P3)		;EXTENSION
	SKIPE	T
	 PUSHJ	P,PDOT
	SKIPE	T
	 PUSHJ	P,PR6BIT
	MOVEI	CH,"["
	PUSHJ	P,@TYODSP
	HLRZ	N,3(P3)		;PPN
	PUSHJ	P,OCTPRT
	PUSHJ	P,COMMA
	HRRZ	N,3(P3)
	PUSHJ	P,OCTPRT
	MOVEI	CH,"]"
	PUSHJ	P,@TYODSP
	PUSHJ	P,CRLF
	MOVEI	T1,0
	IDPB	T1,P1
	MOVEI	M,TRMBLK	;Dump buffer to CTY
	PUSHJ	P,TRMMES
	HLRZ	P3,(P3)		;NEXT LINK
	JUMPN	P3,FLPLP
	RELEAS	DSK,
	POPJ	P,		;DONE

FLPUFD:	MOVE	T,3(P3)		;GET PPN
	CAME	T,[MFDPPN]	;IN MFD?
	 JRST	FLPNUF		;NO, NOT UFD
	HLRZ	N,1(P3)
	PUSHJ	P,OCTPRT
	PUSHJ	P,COMMA
	HRRZ	N,1(P3)
	PUSHJ	P,OCTPRT
	JRST	FLPEXT
SUBTTL	MFDUFD - Process an entire UFD (or the MFD)
;P1 is used for sending messages to the CTY
;P2 points to 5-word entry in [1,1].UFD (execpt when processing MFD)
;P4 has <0,,MFDRIB> for the MFD, <MFDRIB,,UFDRIB> for regular UFDs

MFDUFD:	MOVE	T3,DOGMFD	; We are working with the MFD
	MOVEI	CHAN,0		; JUST TO MAKE SURE
	MOVEM	P2,UFDPTR(P4)
	SETZM	UFDLSD(P4)	;NO DATA LOST YET
	SETZM	UFDUSD(P4)
	MOVE	T,RIBLBN(P4)	;Retrieval pointer for UFD's RIB
	PUSHJ	P,FULRBC	;Get all the information on this RIB
	  POPJ	P,		;Something is wrong
	DMOVE	T,SAVRIB+RIBUNM(P4) ;SAVRIB gets overwritten,
	DMOVEM	T,ERRUNM(P4)	; so get name and preserve it
	MOVE	T,SAVRIB+RIBSZS(P4)
	CAIE	T,1		;Must not be any spare RIBs in UFD
	 POPJ	P,
	MOVE	T,PTROST	;Check with our SATs
	MOVE	T1,RIBLBN(P4)
	PUSHJ	P,TSTZRO	;See if already marked in use
	  SKIPA	
	 POPJ	P,		;UFD's RIB is multiply used
	MOVE	T1,UFDHSP(P4)
	HLL	T1,STRHAD
	MOVEI	T,0		;SET ORIGINAL VALUES
UMFSLP:	MOVEM	T,(T1)		;First 7 pointers (51-57)
	ADDI	T,1		; are hash buckets 0-6
	AOBJN	T1,UMFSLP
	MOVEI	T,FIXRBP(P4)	;No errors for this RIB yet
	PUSHJ	P,SETFIX
	MOVE	T,RIBLBN(P4)
	PUSHJ	P,FILMKC	;Mark page in use in our SATs
	  POPJ	P,
	PFALL	NXUFDB		;Start with first UFD data page
SUBTTL	NXUFDB - Read in next data page from UFD

NXUFDB:	MOVE	T3,DOGUFD	;We are working with a UFD page
	PUSHJ	P,GETPAG	;Get pointer for next page
	  JRST	UFDIGN		;Bad pointer (unit or page out-of-range)
	JUMPE	T,UFDDON	;EOF
	AOS	SIZRIB(P4)	;Count this data page
	TLNN	T,RBREAL	;Real pointer?
	 JRST	UFDNRL		;No, no other checks
	TLNE	T,RBSPAR	;Spare rib in UFD?
	 JRST	[HRR  T3,DOGSNV	;Spare not valid
		 JRST	UFDIGN]	;These are not allowed for UFDs
	PUSHJ	P,FILMKC	;Mark page in use
	  JRST	UFDIGN		;UFD data page is a multiply used page
	MOVE	T3,DOGHRE	;UFD Hard Read Error?
	PUSHJ	P,PAGRDP	;Read the page
	  JRST	UFDIGN		;Read error, Make page go away
	SKIPN	T,BUF
	 JRST	ANYHSH		;Page is allowed to be empty
	TLZ	T,(1B0)
	IDIV	T,STRHSH	;First word of page must hash correctly
	HRLM	T1,UFDHSP(P4)
	ADD	T1,UFDHSP(P4)	;GET A POINTER TO THE HASH TABLE
	MOVE	T,DEVREL(P4)
	CAME	T,(T1)			; Hash to same bucket?
	 JRST	[HRR	T3,DOGWHC	; UFD Wrong Hash for file in UFD page
		 JRST	UFDIGN]		; No, bad hash code
UFDBSZ:	MOVEI	T,UFDBKF(P4)
	PUSHJ	P,SETFIX	;Clear list of corrections to UFD page
	PUSH	P,T1
	SKIPN	T,BUF+777
	 JRST	UFDESH		;END OF LINKS
	CAMLE	T,DEVREL(P4)
	CAIL	T,RBLVPR
	 JRST	UFDBDH		;Bad hash link
	MOVE	T2,UFDHSP(P4)
	HLL	T2,STRHAD
	CAMN	T,(T2)
	 JRST	UFDBDH		;BAD HASH IF ANYONE ELSE POINTS HERE
	AOBJN	T2,.-2
	SKIPA
UFDESH:	 SETO	T,		;End of link for this hash bucket
	POP	P,T1
	MOVEM	T,(T1)		;RESET HASH LINK
	AOS	ALCRIB(P4)	;Count real page
	MOVE	T,SAVPAG(P4)	;Destination is MFDBUF or UFDBUF
	HRLI	T,BUF		;Source
	MOVE	T1,T
	BLT	T,777(T1)	;Copy UFD data page
	SETO	T,
	PUSHJ	P,@ROUTIN(P4)	;Call MFDPRC or UFDPRC do process this page
	MOVEI	T,UFDBKF(P4)
	PUSHJ	P,ADDTOT	;Put fix-ups on the master chain
	JRST	NXUFDB		;Continue with next UFD data page
;Still processing UFD data pages

;UFDIGN is called when a UFD data page cannot be processed.  T3 is set up
UFDIGN:	PUSHJ	P,PUNCH		;Punch a hole in the UFD
UFDNRL:	MOVE	T1,UFDHSP(P4)	;Here when found a hole in the UFD
	HLL	T1,STRHAD	;THIS IS THE HASH ADDRESS AOBJN
	MOVE	T,DEVREL(P4)
	CAMN	T,(T1)
	 SETOM	(T1)		;END OF THIS LINK
	AOBJN	T1,.-2
	JRST	NXUFDB		;AND GO

ANYHSH:	MOVE	T1,UFDHSP(P4)
	HLL	T1,STRHAD
	MOVE	T,DEVREL(P4)
	CAMN	T,(T1)		;LOOK FOR ANY MATCH (EMPTY BLOCK)
	 JRST	UFDBSZ		;FOUND IT, CONTINUE
	AOBJN	T1,.-2		;KEEP LOOKING
	HRR	T3,DOGNHM	;NO HASH MATCH?
	JRST	UFDIGN		;Cound not find it, replace UFD page with hole

UFDBDH:	SKIPN FIXFLG		;Bad UFD hash
	 JRST	UFDBHM
	MOVEI	T,UFDBKF(P4)
	MOVE	T1,NXTPTR(P4)
	PUSHJ	P,ADDFIX
	  JRST	UFDESH
	SETZM	BUF+777		;Clear out hash link pointer
	POPJ	P,

UFDBHM:	ERRLEV	(LEVBAD)
	MOVSI	T,[ASCIZ /BAD UFD HASH/]
	PUSHJ	P,FLRERR
	JRST	UFDESH

UFDDON:	SETZM	SAVSNM
	MOVEI	T1,PRMRB1	;Check RIB with the 5-word entry
	TLNN	P4,-1
	 MOVEI	T1,PRMRB2	;No 5-word entry for MFD (HOME pointer)
	PUSHJ	P,(T1)
	MOVE	T2,UFDUSD(P4)	;Total pages used in this UFD
	SKIPE	FSTFLG		;CANNOT DETERMINE USE ERRORS
	 JRST	UFDDN1		; IN FAST MODE
	CAME	T2,SAVRIB+RIBUSD(P4)
	 PUSHJ	P,BADUSD
	MOVE	T2,UFDUSD(P4)
	CAMLE	T2,SAVRIB+RIBMXA(P4)
	 PUSHJ	P,BADMXA	;Bad max used
UFDDN1:	AOS	(P)		;ALL IS OK NOW, SKIP RETURN
	MOVEI	T,FIXRBP(P4)
	JRST	ADDTOT		;Add this UFD's RIB fixes to the chain

BADUSD:	SKIPN	FIXFLG		;RIBUSD is wrong
	 JRST	BADUSM
	PUSHJ	P,FILFIX
	  POPJ	P,
	MOVEM	T2,BUF+RIBUSD
	POPJ	P,

BADUSM:	HRLZI	T,[ASCIZ /USED COUNT INCORRECT/]
	JRST	FLMERR

BADMXA:	SKIPN	FIXFLG		;RIBMXA is wrong
	 JRST	BADMXM
	PUSHJ	P,FILFIX
	  POPJ	P,
	MOVEM	T2,BUF+RIBMXA
	POPJ	P,

BADMXM:	HRLZI	T,[ASCIZ /MAXIMUM USED COUNT INCORRECT/]
	JRST	FLMERR
SUBTTL	MFDPRC - Process one page in the MFD
;For every UFD in this data page, call MFDUFD on it.

MFDPRC:	MOVE	P2,SAVPAG(P4)	;RH gets addr of MFDBUF
	HRLI	P2,-1000/UFDSIZ	;102 files per page
	MOVEM	P2,UFDOGP(P4)	;Origin point
MFDPR1:	SKIPN	T,UFDNAM(P2)	;Get next file name
	 POPJ	P,		;Zero marks end of this page
	TLZ	T,(1B0)
	IDIV	T,STRHSH
	HLRZ	T,UFDHSP(P4)	;Check with current hash code
	CAME	T,T1
	 JRST	[PUSH P,P2	;Does not match
		JRST	MFDDEL]
	MOVE	T,UFDNAM(P2)
	HLRZ	T1,UFDEXT(P2)
	CAIE	T1,'UFD'
	 JRST	NOTUFD		;Non UFD file in [1,1]
	MOVE	T2,UFDRBP(P2)	;RIB pointer
	CAMN	T2,MFDRBC
	 JRST	[SETOM MFDRBC	;[1,1].UFD seen, don't re-process it
		JRST SKPENT]
;Switch from "processing MFD" mode to "processing UFD" mode
	MOVE	P4,[MFDRIB,,UFDRIB]
	HRLZM	T1,ERREXT(P4)	;Extension was swapped above
	MOVEM	T,ERRNAM(P4)	;File name is the PPN
	MOVE	T,[MFDPPN]
	MOVEM	T,ERRPPN(P4)	;[1,1]
	MOVSI	T,'UFD'	
	MOVEM	T,ERRUNM(P4)	;Name of owner of file
	SETZM	ERRUNM+1(P4)	;(this will get overwritten by UFD's name)
	MOVE	T,UFDRBP(P2)
	PUSH	P,P2		;Remember where to resume scan
	MOVEM	T,RIBLBN(P4)	;Pointer to UFD's RIB
	PUSHJ	P,MFDUFD	;Recursive call - process entire UFD
	  JRST	MFDDEL		;Entire UFD needs deleting
;P4 still points to UFDRIB
	SKIPE	UFDLSD(P4)	;DID FILE IN UFD LOSE DATA?
	SKIPN	FIXFLG		;DID A FILE LOSE DATA AND FIXING
	 JRST	MFDPR2		;NO
	MOVE	T1,RIBLBN(P4)
	MOVEI	T,FIXPTR
	PUSHJ	P,ADDFIX	;ADD A FIXUP ENTRY
	  JRST	MFDPR2
	MOVSI	T2,RIPBDA	;Return here from FIXLP
	IORM	T2,BUF+RIBSTS	;Mark UFD as containing bad files
	POPJ	P,

MFDPR2:	POP	P,P2		;Where to resume in scan
SKPENT:	MOVEI	P4,MFDRIB	;Back to MFD's data structure
	ADDI	P2,UFDSIZ-1
	AOBJN	P2,MFDPR1
	POPJ	P,		;FINISHED A MFD BLOCK
;Here for a file in [1,1] with an extension other than 'UFD'
NOTUFD:	MOVE	P4,[MFDRIB,,FILRIB]
	MOVEM	T,ERRNAM(P4)	;Name, ext, PPN
	HRLZM	T1,ERREXT(P4)
	MOVE	T,[MFDPPN]
	MOVEM	T,ERRPPN(P4)
	MOVSI	T,'UFD'		;Owner's name
	MOVEM	T,ERRUNM(P4)
	SETZM	ERRUNM+1(P4)
	PUSH	P,P2
	MOVSI	T,[ASCIZ /NON-UFD FILE IN [1,1]/]
	SKIPN	FIXFLG
	 PUSHJ	P,FLRERR	;Output warning if in check mode
	MOVE	T,UFDRBP(P2)
	MOVEM	T,RIBLBN(P4)
	PUSHJ	P,FILPRC	;Process file's RIB
	  JRST	MFDDEL		;Need to delete file from MFD
	JRST	MFDPR2

;Here to delete an entire UFD (because its RIB could not be processed)

MFDDEL:	MOVE	P2,P4		;SAVE FOR ERROR MESSAGE
	MOVEI	P4,MFDRIB	;Point back to MFD's data
	MOVE	T2,(P)
	SUB	T2,UFDOGP(P4)	;Offset within MFDBUF
	SKIPN	FIXFLG
	 JRST	MFDRBE
	MOVEI	T,UFDBKF(P4)
	MOVE	T1,NXTPTR(P4)
	PUSHJ	P,ADDFIX
	  JRST	MFDRBD
	MOVEI	T1,BUF(T2)	;Return here from FIXLP
	HRLI	T1,UFDSIZ(T1)	;Addr of next entry
	BLT	T1,BUF+UFDLST-1	;Copy everything forward 5 words
	MOVEI	T1,BUF+UFDLST+1
	SETZM	-1(T1)
	HRLI	T1,-1(T1)
	BLT	T1,BUF+776	;Zero out the last entry on the page
	POPJ	P,

MFDRBE:	HRLZI	T,[ASCIZ /RIB ERROR/]	;Message for CHECK mode
	HRRI	T,ERRNAM(P2)
	PUSHJ	P,PRTRBL
	JRST	MFDPR2

;BLT data in MFDBUF so it matches what the disk page will look like

MFDRBD:	MOVE	T2,(P)		;GET POINTER TO BAD UFD ENTRY
	MOVEI	T1,(T2)		;OVERWRITE IT WITH NEXT ENTRY
	HRLI	T1,UFDSIZ(T2)	;WHICH IS HERE
	MOVE	T2,UFDOGP(P4)	;GET BEGINNING OF MFD IN CORE
	BLT	T1,UFDLST-1(T2)	;MOVE EVERYTHING UP
	MOVEI	T1,UFDLST+1(T2)	;NOW CLEAR VACANT LAST ENTRY
	SETZM	-1(T1)
	HRLI	T1,-1(T1)
	BLT	T1,776(T2)	;BUT DON'T CLEAR LINK AT THE END.
	POP	P,P2		;RESTORE POINTER TO MFD
	JRST	MFDPR1		;AND CONTINUE WHERE WE LEFT OFF.
SUBTTL	UFDPRC - Process one data page in a UFD
;For each file on this page, call FILPRC

UFDPRC:	MOVE	T1,RIBLBN(P4)	;Pointer to RIB of current UFD
	CAMN	T1,SYSRIB
	 SETOM	SYSRIB		;[1,4] has been checked
	MOVE	U,HIGHU
	SETZM	@PTRUNU		;CLEAR UNIT IN USE FLAGS
	SOJGE	U,.-1
	SETZM	CHANU
	MOVE	T1,[CHANU,,CHANU+1]
	BLT	T1,CHANU+MXCHN-1	;AND CHANNEL IN USE FLAGS
	SETZM	CHNCNT#		;NONE IN USE
	SETZM	UFDPCT		;ALSO CLEAR FILE PROCESSED FLAGS
	MOVE	T1,[UFDPCT,,UFDPCT+1]
	BLT	T1,UFDPCT+777
	MOVE	P2,SAVPAG(P4)	;RH gets addr of UFDBUF
	HRLI	P2,-1000/UFDSIZ	;Scan all 102 entries
	MOVEM	P2,UFDOGP(P4)	;SAVE POINTER TO ORIGIN
	MOVE	P4,[UFDRIB,,FILRIB]
	MOVSI	CHAN,-MXCHN
	PUSHJ	P,FNDSEK	;START UP ALL POSSIBLE SEEKS
	  JRST	FINSEK
	AOBJN	CHAN,.-2

FINSEK:	SKIPN	CHNCNT		;ANY FILES TO PROCESS?
	 JRST	NEDZT		;NO
	MOVNS	CHAN		;GET THE MAX CHANNEL USED
	HRLZM	CHAN,BIGCHN#
FINSK0:	MOVE	CHAN,BIGCHN	;NOW CYCLE THROUGH CHANNELS
FINSK1:	SKIPN	P2,CHANU(CHAN)	;THIS ONE IN USE?
	 JRST	CHNFRE		;NO

;At this point, P2 points to the start of a 5-word entry in BUF
;UFDRIB+ERRNAM is name of UFD = PPN of user.
;UFDRIB+ERRUNM has been overwritten with the name of the user from UFD RIB

	MOVE	T,UFDNAM(P2)	;Name from 5-word entry in UFD data page
	MOVEM	T,ERRNAM(P4)	;Store in FILRIB area
	MOVE	T,UFDEXT(P2)
	HLLZM	T,ERREXT(P4)
	MOVE	T,UFDRIB+ERRNAM
	MOVEM	T,ERRPPN(P4)
	DMOVE	T,UFDRIB+ERRUNM	;User name (from RIB of current UFD)
	DMOVEM	T,ERRUNM(P4)	;For typeout routines
	MOVE	T,UFDRBP(P2)
	MOVEM	T,RIBLBN(P4)
	MOVE	T,UFDNAM(P2)
	TLZ	T,(1B0)
	IDIV	T,STRHSH	;Remainder in T1
	HLRZ	T,UFDHSP+UFDRIB
	CAMN	T,T1		;Match the expected hash code?
	 PUSHJ	P,FILPRC	;PROCESS FILE
	  PUSHJ	P,FILDEL	;RIB error or bad hash - delete from UFD
	MOVE	T1,FILLOS	;If this file has lost data,
	IORM	T1,UFDRIB+UFDLSD; flag it in the UFD
	MOVE	T1,ALCRIB(P4)	;Pages allocated to previous file
	ADDM	T1,UFDUSD+UFDRIB;Add to total pages used in UFD
	PUSHJ	P,FNDSK1	;START A NEW SEEK
	  JRST	CHNFRE		;NOTHING NEW TO DO
NXTCHN:	AOBJN	CHAN,FINSK1
	JRST	FINSK0

CHNFRE:	SKIPE	CHNCNT		;ANY STILL ACTIVE
	 JRST	NXTCHN		;YES, GO FIND THEM AND PROCESS
NEDZT:	MOVEI	P4,UFDRIB	;Reset from FILRIB to UFDRIB
	MOVE	T1,SAVPAG(P4)	;Get addr of UFDBUF
	ADDI	T1,777
	SUB	T1,P2
	MOVNS	T1
	HRL	P2,T1		;SET AOBJN POINTER
	SKIPE	(P2)		;Check if all that should be zero are
	 JRST	NEDZRO		;Garbage found at end of UFD data page
	AOBJN	P2,.-2
	POPJ	P,		;End of this UFD data page

;Force remaining words on this UFD page to zero

NEDZRO:	SKIPN	FIXFLG
	 JRST	NEDZER		;ERROR MESSAGE
	MOVE	T3,P2
	SUB	T3,UFDOGP+UFDRIB
	HRRZS	T3		;Relative addr of first word to zero
	MOVE	T1,NXTPTR(P4)
	MOVEI	T,UFDBKF(P4)	;Add this to the UFD data page chain
	PUSHJ	P,ADDFIX
	  POPJ	P,
	SETZM	BUF(T3)		;Zero first of several words
	CAIL	T3,776
	 POPJ	P,		;DONE IF JUST 1 WORD
	ADDI	T3,BUF+1
	HRLI	T3,-1(T3)
	BLT	T3,BUF+776	;Zero to end of UFD data page
	POPJ	P,

NEDZER:	ERRLEV	(LEVUSR)
	MOVE	N,NXTPTR(P4)	;Pointer to page in UFD
	HRLZI	T,[ASCIZ /NEED EXTRA WORDS ZEROED/]
	HRRI	T,ERRNAM(P4)	;Addr of name of UFD
	JRST	PRTRBL
;ROUTINE TO HANDLE SEEKS.
;
;ENTER AT FNDSEK TO FIND A UFD ENTRY IN THE PAGE POINTED TO BY
;P2, SUCH THAT THE RETRIEVAL PNTR FOR THE RIB OF THAT ENTRY
;IS ON A UNIT THAT IS NOT BUSY AND THE ENTRY HAS NOT
;BEEN PROCESSED BEFORE.  IF FOUND, START THE SEEK AND SKIP
;RETURN.  IF NONE FOUND, NON-SKIP RETURN.
;ENTER AT FNDSK1 AFTER EACH FILE HAS BEEN PROCESSED, TO FIND ANOTHER ONE.

FNDSK1:	MOVE	P2,CHANU(CHAN)	;HERE WHEN WE HAVE FINISHED A FILE
	MOVE	U,CHANUU(CHAN)	;THE UNIT WE WERE PROCESSING
	SETZM	CHANU(CHAN)	;CHANNEL IS NOW FREE
	CAMG	U,HIGHU		;IF OUT OF RANGE, LET DISK READING ROUTINE
				; GIVE ERROR
	 SETZM	@PTRUNU		;ALSO UNIT
	SOS	CHNCNT		;ONE FEWER CHANNEL
FNDSK2:	ADDI	P2,UFDSIZ-1	;NEXT FILE
	AOBJP	P2,CPOPJ	;SET THE PLACE OF ENDING
FNDSEK:	SKIPN	(P2)
	 POPJ	P,
	LDB	U,[POINT PTSUNI,UFDRBP(P2),PTNUNI]
	CAMG	U,HIGHU		;IF OUT OF RANGE, LET DISK READING ROUTINE GIVE ERROR
	SKIPN	@PTRUNU
	 JRST	.+2		;OUT OF RANGE OR UNIT NOT BUSY.
	  JRST	FNDSK2		;THAT UNIT IS BUSY
	MOVE	T2,P2
	SUB	T2,UFDOGP+UFDRIB
	SKIPE	UFDPCT(T2)	;HAVE WE PROCESSED THAT ONE?
	 JRST	FNDSK2		;YES
	SETOM	UFDPCT(T2)	;NO, WE WILL NOW
	SKIPN	FSTFLG
	 JRST	FNDSK3
	MOVE	T,UFDUF2(P2)	;HAS THIS FILE BEEN
	TRNN	T,UFPALC	; MODIFIED RECENTLY?
	 JRST	FNDSK2		;NO, DON'T BOTHER TO PROCESS IT
FNDSK3:	MOVEM	P2,CHANU(CHAN)
	MOVEM	U,CHANUU(CHAN)	;CHANNEL IN USE
	AOS	CHNCNT
	CAMLE	U,HIGHU		;IF UNIT NUMBER IS BAD,
	 JRST	CPOPJ1		;RETURN NOW.
	SETOM	@PTRUNU		;AND UNIT
	MOVE	T,CHAN
	LDB	T1,[POINT PTSPNO,UFDRBP(P2),PTNPNO]
	HRLI	T,CIO.PI	;CHANIO PAGE USETI.
	CHANIO	T,T1
	HRLI	T,CIO.SK	;CHANIO SEEK.
	CHANIO	T,
	JRST	CPOPJ1		;GOT IT
;Here for one of the following reasons:
;1) The retrieval pointer from the 5-word UFD entry is garbage; no RIB.
;2) The retrieval pointer is good, but the RIB page got a read error.
;3) The RIB does not match the 5-word UFD entry or has a bad self pointer.
;4) The RIB is a multiply used page.
;In all cases, the 5-word UFD entry must be eliminated.
;   T3 contains the reason as in PUNCH, with explicit names.

FILDEL:	SETOM	FILLOS			;At least 1 file has lost data
	MOVEM	T3,DEBRSN		;Save reason for problem
	MOVEI	T1,1
	MOVEM	T1,ALCRIB(P4)		;File will be reduced to a single page
	SKIPN	FIXFLG
	 JRST	RIBERR			;Output generic "RIB error" message
	MOVE	T1,UFDRIB+NXTPTR	;Ret Ptr for this UFD data page
	MOVE	T2,CHANU(CHAN)		;Current 5-word entry
	SUB	T2,UFDOGP+UFDRIB	;Offset into page
	TLZ	T2,-1			;Get rid of count
	IDIVI	T2,UFDSIZ		;Make sure it's a multiple of 5
	IMULI	T2,UFDSIZ
	SKIPN	T3			;Remainder must be zero
	CAILE	T2,777			; and offset must be within page
	 JSP	T,BUG
	MOVEI	T,UFDBKF+UFDRIB
	HRL	T2,DEBRSN		;Get error code in right half
	MOVE	T3,UFDRIB+ERRNAM	;ALSO GET PPN FOR REENTRY
	SETOM	UFDLSD+UFDRIB		;FILE IN UFD HAS LOST DATA
	PUSHJ	P,ADDFIX
	  JRST	RELDEL			;Remove entry from UFDBUF as well
	MOVE	T,BUF(T2)		;GET FILE NAME
	MOVEM	T,1(P3)			;P3 POINTS TO THE ERROR BLOCK
	MOVE	T,BUF+1(T2)
	HLR	T,T2			;Get reason from LH of index
	MOVEM	T,2(P3)			;3(P3) IS ALREADY PPN
	HRLM	P3,@FIXREN+1		;LINK IN
	HRRZM	P3,FIXREN+1
	ADDI	T2,BUF			;Shift everything down 5 positions
	HRLI	T2,UFDSIZ(T2)
	BLT	T2,BUF+UFDLST-1
	MOVEI	T2,BUF+UFDLST+1
	SETZM	-1(T2)			;Zero the last 5-word entry
	HRLI	T2,-1(T2)
	BLT	T2,BUF+776
	POPJ	P,

;Need to invent a routine to output octal numbers to CTY

BUG:	MOVEI	M,[ASCIZ /BUG detected at FILDEL
/]					;Need to output PC in T someday
	PJRST	TRMMES

RIBERR:	MOVE	N,RIBLBN+FILRIB	;RIB is unusable
	ERRLEV	(LEVUSR)
	HRLZI	T,[ASCIZ /RIB ERROR/]
	HRRI	T,ERRNAM+FILRIB
	JRST	PRTRBL

;Remove entry from current UFD page.
;Do this so the in-core copy of the UFD page will match the fixed up disk page.
;Shuffle the look-ahead data used by FNDSK1 as well

RELDEL:	MOVE	T1,CHANU(CHAN)		;Pointer to current UFD entry
RELDL1:	MOVE	T2,BIGCHN
	CAME	T1,CHANU(T2)		;See if any other channel points here
	 AOBJN	T2,.-1
	JUMPGE	T2,RELDL2		;Jump if channel is not in use
	MOVN	T,[1,,UFDSIZ]		;Back up pointer for channel
	ADDM	T,CHANU(T2)
RELDL2:	ADDI	T1,UFDSIZ-1
	AOBJN	T1,RELDL1		;Fix all pointers after this
	MOVE	T1,CHANU(CHAN)
	ADDI	T1,UFDSIZ+UFDPCT	;Move the UFDPCT array
	SUB	T1,UFDOGP+UFDRIB
	HRLI	T1,UFDSIZ(T1)
	BLT	T1,UFDPCT+UFDLST-1	;BLT forward 5 words in UFDPCT
	MOVEI	T1,UFDPCT+UFDLST+1
	SETZM	-1(T1)
	HRLI	T1,-1(T1)
	BLT	T1,UFDPCT+776		;Zero end of UFDPCT
	MOVE	T1,CHANU(CHAN)
	ADDI	T1,UFDSIZ
	HRLI	T1,UFDSIZ(T1)
	MOVE	T2,SAVPAG+UFDRIB	;Address of UFDBUF
	BLT	T1,UFDLST-1(T2)		;BLT forward 5 words in UFDBUF
	HRLI	T1,UFDLST(T2)
	HRRI	T1,UFDLST+1(T2)
	SETZM	UFDLST(T2)
	BLT	T1,776(T2)		;Zero end of UFDBUF
	POPJ	P,
SUBTTL	FILPRC - Process a file
;For each RIB in the file, count the retrieval pointers

FILPRC:	MOVEM	P2,UFDPTR(P4)		;Save pointer to 5-word UFD entry
	MOVEI	T1,CPOPJ		;No special routine for each page
	MOVEM	T1,ROUTIN(P4)		;(might want to try to read each page)
	SKIPE	TRBFIL			;If last file had a problem,
	 PUSHJ	P,CRLF			; separate with a blank line
	SETZM	TRBFIL
	MOVE	T,RIBLBN(P4)		;Pointer to file's RIB
;At this point, only RBREAL+UNIT+PAGE should be set.  Anything else is garbage.
	PUSHJ	P,FULRBC		;Full RIB check - Sets T3
	  PJRST	ISCRIT			;Bad ret-ptr, check if critical file
	MOVE	T,RIBLBN(P4)
	PUSHJ	P,FILMKC		;Mark bit and check multiply used
	  PJRST	ISCRIT			;Multiply used, critical? and return
	MOVSI	T,-SPCLEN
	MOVE	T1,RIBLBN(P4)		;Retreival pointer
	CAME	T1,@SPCACT(T)		;Match a special one (found in HOME)?
	 AOBJN	T,.-1
	JUMPGE	T,NOSPEC		;Not special
;Verify that the ret-ptrs in the HOME page point to the proper RIBs
	HRRI	T3,'SNM'		;Special name mismatch
	MOVE	T1,SPCNAM(T)		;Check NAME, EXT, PPN
	CAME	T1,ERRNAM(P4)
	 JRST	UFDERR			;Bad UFD pointer to critical file
	HLLZ	T1,ERREXT(P4)
	CAME	T1,SPCEXT(T)
	 JRST	UFDERR
	MOVE	T1,SPCPPN(T)
	CAME	T1,ERRPPN(P4)
	 JRST	UFDERR
	MOVE	T1,SPACT2(T)
	PUSHJ	P,(T1)			;Goto (MFDPR1,SYSPRC,HOMPRC,SATPRC)

NOSPEC:	MOVEI	T,FIXRBP(P4)
	PUSHJ	P,SETFIX		;Reset chain of fixes to this RIB
	MOVE	P2,CHANU(CHAN)		;Point to channel
	SETZM	SAVSNM#			;For recording SNM in first RIB
	SETOM	SPAROK#			;OK to have a spare pointer
	SETZM	EOFSEN#		;EOF not seen
	SETZM	FILLOS#		;File has not lost data
	SETZM	FILTRB#		;File does not have trouble

;Here when RIB (prime or spare) has been read into SAVRIB(P4)

FILRBN:	PUSHJ	P,SETPTR	;Set DEVRSU to first ret-ptr position

;Loop back here to count all retreival pointers in the current RIB

FILCNT:	MOVE	T3,DOGFIL	;We are working on a file rib
	PUSHJ	P,GETPAG	;Get next ret-ptr from DEVRSU
	  JRST	PTRBAD		;PTNUNI or PTNPNO error with RBREAL set
	JUMPE	T,RIBEOF	;Zero marks end of rib
	TLZE	T,RBSPAR
	 JRST	SPRPTR		;Found a pointer to a spare RIB
	SKIPE	EOFSEN
	 JRST	FRCEOF		;Should have already seen a zero ret-ptr
	AOS	SIZRIB(P4)	;Count logical page (including holes)
	SETZM	SPAROK		;No spare RIBs allowed after a real ptr
	TLNN	T,RBREAL
	 JRST	HOLCHK		;Found a hole
	PUSHJ	P,FILMKC	;Mark page in use (T3 contains DOGFIL already)
	  JRST	PTRBD1		;Cancel AOS SIZRIB and replace ptr with hole
	PUSHJ	P,@ROUTIN(P4)	;Call special processor on this page
	AOS	ALCRIB(P4)	;Count number of allocated pages
	JRST	FILCNT

PTRBD1:	SOS	SIZRIB(P4)	;Should not have counted this one
PTRBAD:	PUSHJ	P,PUNCH		;Punch a hole where ret-ptr was
	JRST	FILCNT		;Resume looking at file

;Here when there is a hole in the file (holes are legal somtimes)

HOLCHK:	SKIPE	FIXFLG		;Fix or check?
	 JRST	HOLCH3		;Fix - no LPT therefore no verbose messages
	MOVE	T1,[SIXBIT /  HOLE/]
	MOVEM	T1,DEBRSN	;Reason for this message
	CAIN	T,'CAT'		;Normal hole?
	 JRST	[SKIPN	VERBOS	;Want to see normal holes?
		  JRST	FILCNT	;No, don't complain
		 MOVSI	T,[ASCIZ /Normal hole (CAT)/]
		 JRST	HOLCH2]
	HRLI	T,[ASCIZ /Other hole/]
	MOVE	T2,[-DOGLEN,,DOGNAM]
HOLCH1:	HRRZ	T1,(T2)		;Get secondary cause
	CAIE	T1,(T)		;See if it matches
	 AOBJN	T2,HOLCH1	;No, try more
	JUMPGE	T2,HOLCH2	;Match? No?
	HRLI	T,[ASCIZ /DSKCLN detected hole/]
	MOVE	T2,(T2)		;Get what matched
	MOVEM	T2,DEBRSN	;Store for printout
HOLCH2:	PUSHJ	P,SAVPTR	;Save ptr info in debug block
	PUSHJ	P,FLRERR
	JRST	FILCNT

;Hole found in FIX mode

HOLCH3:	CAIN	T,'CAT'		;Normal hole?
	 JRST	FILCNT		;Yes, ignore it
	SETOM	FILLOS		;Found a file that lost data
	MOVE	T2,DEVRSU(P4)	;Pointer to abnormal hole
	SUBI	T2,1+SAVRIB(P4)	;Offset, 004 to 775
	DPB	T,[POINT 27,T2,26] ;3/4ths of the non-real pointer
	MOVE	T3,SAVRIB+RIBSLF(P4);Self pointer to RIB (might be a spare)
	PUSHJ	P,FILFIX	;Want to look at prime RIB on fix-up
	  PJRST	FILCNT		;Continue, skip return from FIXLP with prime RIB in BUF
	MOVE	T,BUF+RIBSTS	;Get file status bits
	TRNE	T,RIPBDA	;Already marked bad?
	 POPJ	P,		;Yes, don't complain twice for same file
;Can't simply set RIPBDA here, that would make UFDUF2 wrong.
	MOVE	T,BUF+RIBNAM	;GET FILE NAME
	MOVEM	T,1(P3)		;P3 POINTS TO THE ERROR BLOCK
	MOVE	T,BUF+RIBEXT
	HRRI	T,'HOL'		;Reason = abnormal hole detected
	MOVEM	T,2(P3)
	MOVE	T,BUF+RIBPPN
	MOVEM	T,3(P3)
	HRLM	P3,@FIXBAD+1	;LINK IN
	HRRZM	P3,FIXBAD+1
;Here would be a good place to output more info if necessary.
;T3 has retreival pointer to RIB (prime or spare) where hole was detected
;T2 has <BYTE (27)HOLE(9)OFFSET> (offset into page and part of hole)
	POPJ	P,
SUBTTL	SPRPTR - Found a spare pointer, go down a level

SPRPTR:	SKIPN	SPAROK			; Is it OK to have a spare?
	 JRST	[HRR	T3,DOGSNV	; Spare Not Valid (Fill in right half)
		 JRST	PTRBAD]		; No, make it known
	MOVE	T3,DOGSPA		; Spare rib - never here if UFD
	PUSHJ	P,FILMKC
	  JRST	PTRBAD			;CAN NOT USE IF MULTIPLE ETC
	PUSHJ	P,RIBCHK
	  JRST	PTRBAD			; Not a good spare rib
	MOVE	T1,DEVRSU(P4)
	MOVE	T2,SAVRIB+RIBSLF(P4)	; Get self pointer from prime rib
	CAME	T2,BUF+RIBRIB		; Does prime pointer in spare match?
	 JRST	[HRR	T3,DOGBPP	; Bad prime pointer
		 JRST	PTRBAD]		; No, Bad prime pointer
	SUBI	T1,SAVRIB+1(P4)
	HRRZS	T1
	CAME	T1,BUF+RIBRPS		; Does up pointer match prime slot
	 JRST	[HRR	T3,DOGBUP	; No, Bad up level pointer
		 JRST	PTRBAD]
	PUSHJ	P,COPTR
	AOS	ALCRIB(P4)		;Count number of allocated pages
	JRST	FILRBN			;GO
    ;SUBR TO SET THE F BIT FOR THE RETRIEVAL PNTR IN T, IN
    ;THE PTROST SATS.  FIRST CHECKS PTRTST AND PTRDST.

FILMKC:	PUSH	P,T
	MOVE	T1,T
	CAMN	T1,DEBPAG	;IS THIS THE ONE WE WANT?
DEBBRK:	 JFCL	DEBPAG		;YES, ALLOW BREAKPOINT HERE
	MOVE	T,PTRTST	;IS THIS BIT
	PUSHJ	P,TSTZRO	;ALREADY KNOWN TO BE MUL USED?
	  JRST	MKNMLT		;NO.
	SETOM	FILTRB		;YES.
	SETOM	TRBFLG		;TROUBLE (MULTIPLE USED)
	HRR	T3,DOGMUP	;Multiply Used Page
	PUSHJ	P,ISCRIT	;Output message if critical file
	SKIPE	FIXFLG
	 JRST	TPOPJ		;JUST RETURN IF FIXING
	ERRLEV	(LEVBAD)
	MOVSI	T,[ASCIZ /Multiply-Used Page/]
	PUSHJ	P,FREETR	; Print message
	JRST	TPOPJ		; Take appropriate error return
MKNMLT:	MOVE	T1,(P)

	MOVE	T,PTRDST	;IS THIS BIT MARKED IN USE
	PUSHJ	P,TSTZRO	;IN THE DISK SATS?
	PUSHJ	P,FREE		;NO, MAYBE REPORT USED BUT NOT MARKED.
	MOVE	T1,(P)		;YES.
	MOVE	T,PTROST	;MARK THIS BIT IN USE
	PUSHJ	P,MRKZRO	;IN OUR SATS.
	  SKIPA			;BAD NEWS, ALREADY IN USE.
	 JRST	TPOPJ1		;SUCCESS.
	HRR	T3,DOGMUP	;Multiply Used Page
	SETOM	TRBFLG
	SETOM	FILTRB
	MOVE	T1,(P)
	MOVE	T,PTRTST	;MARK THIS BIT IN THE MULTIPLY
	PUSHJ	P,MRKZRO	;USED SATS.
	  JFCL
	SKIPA
TPOPJ1:	AOS	-1(P)
TPOPJ:	POP	P,T
	POPJ	P,


FREE:	SKIPE	FIXFLG
	 POPJ	P,		;NOTHING IF FIXING
	MOVSI	T,[ASCIZ /NOT MARKED IN SAT/]
	ERRLEV	(LEVSAT)	;[105] Semi-minor error
	SKIPE	TRBFIL		;[104] Only 1 NOT MARKED message per file
	 POPJ	P,		;[104]
FREETR:	HRRI	T,ERRNAM(P4)
	MOVE	N,-1(P)
	JRST	PRTRBL
SUBTTL	RIBEOF - Go back to prime RIB if in a spare

RIBEOF:	SKIPL	T2,DEVRSU(P4)
	 JRST	RIBZEF			;OUT OF POINTERS, NONE TO ZERO
	SKIPE	(T2)			;REMAINING MUST BE ZERO
	 JRST	RIBNZF
	AOBJN	T2,.-2
RIBZEF:	MOVE	T1,SAVRIB+RIBSFS(P4)
	SKIPN	SAVRIB+RIBRIB(P4)
	 MOVE	T1,SAVRIB+RIBPFS(P4)
	TLNE	T1,RBSPAR
	 JRST	RBEOF1			;FIRST IS A SPARE POINTER
	MOVEI	T2,1
	CAME	T2,SAVRIB+RIBSZS(P4)	;MUST BE 1
	 PUSHJ	P,BADSZS
RBEOF1:	SKIPN	T,SAVRIB+RIBRIB(P4)
	 JRST	PRMRIB			;BACK TO PRIME RIB, CONTINUE
	MOVEM	T,RIBLBN(P4)
	PUSHJ	P,RIBCHK
	  PJRST	ISCRIT			;CALL IT A RIB ERROR
	SETZM	SPAROK			;UNLESS RESET BELOW
	SKIPN	T1,SAVRIB+RIBLST(P4)
	SETOM	EOFSEN			;EOF HAS BEEN SEEN
	MOVE	T,SAVRIB+RIBSZS(P4)
	TLNN	T1,RBSPAR
	CAIN	T,1
	 SETOM	SPAROK			;SPARE POINTERS OK IN THIS CASE
	MOVE	T1,SAVRIB+RIBRPS(P4)
	HRLI	T1,-RIBLST(T1)
	ADDI	T1,SAVRIB+1(P4)
	MOVEM	T1,DEVRSU(P4)
	SUBI	T1,SAVRIB+RIBPFS(P4)
	HRRZM	T1,SAVSNM		;SAVE LAST SPARE RIB SEEN
	PUSH	P,SAVRIB+RIBSZS(P4)
	PUSHJ	P,COPTR
	POP	P,T2
	IMULI	T2,RBLVSR
	CAME	T2,SAVRIB+RIBSZS(P4)
	 PUSHJ	P,BADSZS
	JRST	FILCNT			;AND GO

SAVPTR:	MOVE	T2,DEVRSU(P4)		; Get aobjn ptr
	SUBI	T2,1+SAVRIB(P4)		;  convert to buffer offset
	MOVEM	T2,DEBIDX		;  save index for print routine
	MOVE	T2,BUF(T2)		;  get invalid pointer
	MOVEM	T2,DEBPTR		;  save pointer from buf
	MOVE	T2,BUF+RIBSLF		;  get ribslf pointer
	MOVEM	T2,DEBRIB		;  save it for printout
	POPJ	P,			; and return
SUBTTL	BAD RIB Routine

PTRBSB:!  ;This routine used to be called the "PTR Bad SuBroutine"
PUNCH:	AOS	SIZRIB(P4)		;Count old # of allocated pages
	SETZM	SPAROK			; No more spare ribs
	MOVEM	T3,DEBRSN		; Save reason
	PUSHJ	P,SAVPTR		; Save pointer info
	PUSHJ	P,ISCRIT		; Set critical level if true
	SKIPN	FIXFLG			; Are we fixing?
	 JRST	BDPMER			; No.
	SETOM	FILLOS			; At least one file has lost data
	MOVE	T2,DEVRSU(P4)		;T3/reason
	SUBI	T2,1+SAVRIB(P4)		;T2/offset into page
	PUSHJ	P,RIBFIX		;Mark this page as needing fixup
	  POPJ	P,			;Nothing more right now

;Return here from FIXLP+21 - Only T2, T3, and BUF are set up (P3 is fix-up)
	MOVEM	T2,DEBIDX		;Set index value
	MOVEM	T3,DEBRSN		;Set reason field
	MOVE	T1,BUF+RIBSLF		;Get # of this rib
	MOVEM	T1,DEBRIB		;Set this up for msg
	MOVE	T1,[BUFNAM,,BUFNAM+1]	;Clear out
	SETZM	BUFNAM			;  the name
	BLT	T1,BUFNAM+4		;  block  (cough +4 constant)
REPEAT 0,<	; don't do this until checking established
	MOVE	T1,DOGMUP		;See if the reason is
	CAIE	T1,(T3)			;  multiply used page
	 JRST	PUNCH1			;No, skip a bit
	MOVE	T3,BUF(T2)		;Yes, get old pointer
	MOVEM	T3,DEBPTR		;Set old pointer value
	TLZ	T3,RBREAL		;Clear real bit (may be already)
	TLO	T3,RBHOLD		;Set holding bit (may be already)
	MOVEM	T3,BUF(T2)		;Put new value into rib
	JRST	PUNCH2			;Don't clobber pointer now
> ; end repeat 0
PUNCH1:	EXCH	T3,BUF(T2)		;Set & remember old value
	MOVEM	T3,DEBPTR		;Set old pointer value

;Now locate the prime RIB so that the file name can be remembered

PUNCH2:	SKIPN	T,BUF+RIBRIB		;Prime rib? (non-zero if spare)
	 JRST	PUNCH3			;Yes, process
	EXCH	T,PAGIN			;No, get old page #
	SKIPL	T			;Is there one ?
	 PUSHJ	P,PAGWTP		;Yes, write current page
	MOVE	T,PAGIN			;Get new page #
	PUSHJ	P,PAGRDP		;Read it in
	  JRST	PUNCH4			;Not there, ignore this one ***
	JRST	PUNCH2			;See if prime rib

PUNCH3:	MOVE	T,BUF+RIBNAM		;Get file name
	MOVEM	T,BUFNAM		;  for error printout
	MOVEM	T,1(P3)			;  now and later
	MOVE	T,BUF+RIBEXT		; extension
	HRR	T,DEBRSN		;  and reason
	MOVEM	T,BUFNAM+1
	MOVEM	T,2(P3)
	MOVE	T,BUF+RIBPPN		; ppn
	MOVEM	T,BUFNAM+2
	MOVEM	T,3(P3)
	HRLM	P3,@FIXBAD+1		;Link block in lost pages list
	HRRZM	P3,FIXBAD+1		;It will be used later

PUNCH4:	MOVEI	P1,TRMSAV		;Get saving pointer
	MOVEM	P1,TYODSP		;For typeout
	MOVE	P1,[POINT 7,TRMBLK]	;Set text pointer
	MOVSI	T,[Asciz\Hole punched in rib\]
	HRRI	T,BUFNAM		;Message and file name blcok
	PUSHJ	P,PTRBFL		;Print it
	PUSHJ	P,NULL			;Null byte at end
	MOVEI	M,TRMBLK		;Message address
	PUSHJ	P,TRMMES		;Send to CTY
	POPJ	P,

PTRBFL:	PUSH	P,BUF+RIBSLF		;Page # of 'last' prime rib
	PUSH	P,T			; ** N,T on stack as in PRTRBL **
	PJRST	PRTRBX			; Fall into common print code
BDPMER:	ERRLEV	(LEVCRS)
	MOVSI	T,[ASCIZ /Bad retrieval pointer/]
	JRST	FLRERR

FRCEOF:	MOVE	T2,DEVRSU(P4)
	SUBI	T2,1			;POINT AT ONE WHICH SHOULD BE ZERO
	JRST	RIBNZF			;AND GO ZERO THEM

EOFERM:	ERRLEV	(LEVCRS)
	MOVSI	T,[ASCIZ /Should have found EOF/]
	PUSHJ	P,FLRERR
	JRST	RIBEOF

BADSZS:	MOVEM	T2,SAVRIB+RIBSZS(P4)
	SKIPN	FIXFLG
	 JRST	SZSERM
	PUSHJ	P,FILFIX
	  POPJ	P,
	MOVEM	T2,BUF+RIBSZS
	POPJ	P,

SZSERM:	ERRLEV	(LEVCRS)
	MOVSI	T,[ASCIZ /Bad RIBSZS/]
	JRST	FLRERR

RIBNZF:	SETZM	(T2)			;ZERO EXTRA POINTERS T2 IS POINTER
	HRL	T,T2
	HRRI	T,1(T2)
	SUBI	T2,SAVRIB(P4)
	CAIE	T2,RIBLST
	 BLT	T,SAVRIB+RIBLST(P4)	;NO BLT IF AT END
	SKIPN	FIXFLG
	 JRST	EOFERM
	PUSHJ	P,RIBFIX		;Use RIBFIX in case of spare RIB
	  JRST	RIBEOF			;WILL FIND IT ZERO NOW
	SETZM	BUF(T2)
	CAIN	T2,RIBLST
	 POPJ	P,			;DO NOT OVERFLOW ON BLT
	HRLI	T2,BUF(T2)
	ADDI	T2,BUF+1
	BLT	T2,BUF+RIBLST
	POPJ	P,

PRMRIB:	AOS	(P)
	MOVEI	T,0
	PUSHJ	P,@ROUTIN(P4)		;DONE
	PUSHJ	P,PRMRB1
	MOVEI	T,FIXRBP(P4)
	JRST	ADDTOT
COMMENT #
@@SUBROUTINE PRMRB1/PRMRB2
@@PURPOSE
SUBRS TO CHECK MANY NON-RETRIEVAL PNTR THINGS ABOUT THE PRIME
RIB, SUCH AS DATE, TIME, ALP, ETC.
@@ENTRY
THERE ARE TWO ENTRY POINTS, PRMRB1 AND PRMRB2.
EXPECTS THE RIB TO BE IN SAVRIB(P4).
@@ACCUM
@@EXIT
@@ #

PRMRB1:	MOVE	P2,UFDPTR(P4)		;WHERE WE SAVED IT
	HRRZ	T,UFDLIC(P2)
	HRRZ	T2,SAVRIB+RIBLCW(P4)
	CAME	T,T2			;LICENSE FIELDS SHOULD MATCH
	 PUSHJ	P,BADLIC		;BUT DO NOT
	LDB	T,[POINT 9,UFDPRV(P2),35]
	LDB	T2,[POINT 9,SAVRIB+RIBPVW(P4),8]
	CAME	T,T2		;CHECK PROTECTION FIELD
	 PUSHJ	P,BADPRV
	LDB	T2,[POINT 11,SAVRIB+RIBPVW(P4),23]	;MIN
	IMULI	T2,^D60
	LDB	T1,[POINT 6,SAVRIB+RIBLCW(P4),17]	;SEC
	ADD	T2,T1
	LDB	T,[POINT 17,UFDTMD(P2),23]		;NOW FROM UFD
	CAME	T,T2
	 PUSHJ	P,BADTIM
	LDB	T,[POINT 12,UFDTMD(P2),35]
	LDB	T1,[POINT 2,UFDTMD(P2),6]	;EXTRA 2 BITS
	DPB	T1,[POINT 2,T,23]
	LDB	T2,[POINT 12,SAVRIB+RIBPVW(P4),35]
	LDB	T1,[POINT 2,SAVRIB+RIBEXT(P4),21]
	DPB	T1,[POINT 2,T2,23]
	CAME	T,T2				;CHECK DATE
	 PUSHJ	P,BADDAT
	MOVE	T,UFDUF2(P2)
	MOVE	T4,SAVRIB+RIBLCW(P4)
	SKIPN	FIXFLG			;IN CHECK MODE ONLY REPORT
	 JRST	MODCL1			; DIFFERENCES IN MOD BIT IN UFD AND RIB
;*** WARNING:  If there are too many files with RIPALC, then we run out of core!
	MOVE	T1,UPRBND		;Find out how much core in use already
	CAIL	T1,300000		;If more than this, ignore RIPALC
	 JRST	PRMRB0
	TRNN	T,UFPALC		;IS UFD MOD BIT SET?
	 JRST	MODCL2			;NO
	PUSHJ	P,SETUFX		;INSERT UFD FIX UP ENTRY
	  JRST	MODCL2
	MOVEI	T2,UFPALC		;CLEAR UFD FILE
	ANDCAM	T2,BUF+UFDUF2(T3)	; RECENTLY MOD BIT
	POPJ	P,
  PAGE
MODCL2:	TLNN	T4,RIPALC		;IS RIB FILE MODE BIT SET?
	 JRST	PRMRB0			;NO

	PUSHJ	P,FILFIX		;INSERT FILE FIX UP ENTRY
	  JRST	PRMRB0
	MOVSI	T2,RIPALC		;CLEAR FILE RIB RECENTLY
	ANDCAM	T2,BUF+RIBLCW		; MOD BIT
	POPJ	P,

MODCL1:	LSH	T,^L<UFPALC>-<^L<RIPALC>-^D18>	;ARE BOTH
	XOR	T,T4			; FILE RIB AND UFD FILE RECENTLY MOD
	TLNN	T,RIPALC		; BITS SET OR CLEAR?
	 JRST	PRMRB0			;YES
	HRLZI	T,[ASCIZ /ONLY UFPALC SET/]
	TLNE	T4,RIPALC
	 HRLZI	T,[ASCIZ /ONLY RIPALC SET/]
	PUSHJ	P,FLMERR	;OUTPUT ERROR MSG
PRMRB0:	LDB	T,[POINT 9,UFDPRV(P2),26]
	TRZ	T,UFPALC_-<^D35-^D26>	;IGNORE UFPALC
	LDB	T2,[POINT 8,SAVRIB+RIBLCW(P4),11]
	TRZ	T2,RIPALC_-<^D17-^D11>	;IGNORE RIPALC
	CAME	T,T2
	 PUSHJ	P,BADBT1		;WRONG BITS
	LDB	T,[POINT 5,UFDTMD(P2),4]
	LDB	T2,[POINT 4,SAVRIB+RIBLCW(P4),3]
	CAME	T,T2
	PUSHJ	P,BADBT2
	MOVE	T2,ALCRIB(P4)		;Number of allocated pages
	CAIL	T2,400000
	 MOVEI	T2,400000		;THE FUNNY 18-BIT TRUNCATION
	HLRZ	T1,UFDALC(P2)
	CAME	T1,T2
	 PUSHJ	P,BADALU
PRMRB2:	PUSHJ	P,ISUFD	;SKIP IF UFD
	TDZA	T,T
	 MOVEI	T,RIPDIR
	XOR	T,SAVRIB+RIBSTS(P4)	;MAKE SURE DIR BIT CORRECT
	TRNE	T,RIPDIR
	 PUSHJ	P,BADDIR
	MOVE	T2,ALCRIB(P4)		;Number of pages counted as in use
	CAME	T2,SAVRIB+RIBALP(P4)	;Pages the file said it had
	 PUSHJ	P,BADALP		;Needs correcting if we punched hole
	MOVE	T1,SAVRIB+RIBSIZ(P4)	;Number of words written
	TRZE	T1,777
	 ADDI	T1,1000			;Round up to next full page
	MOVE	T2,SIZRIB(P4)		;# of pointers before we punched holes
	LSH	T2,9			;(including existing holes)
	CAMGE	T2,T1			;Compare with written words
	 PUSHJ	P,BADSIZ		;RIBSIZ is wrong
	MOVE	T2,SAVSNM
	CAME	T2,SAVRIB+RIBSNM(P4)	;Number of spare RIBs
	 PUSHJ	P,BADSNM
	POPJ	P,			;Finished with this file
;HERE FOR THE VARIOUS ERRORS

BADLIC:	SKIPN FIXFLG
	JRST LICERM
	PUSHJ P,SETUFX
	 POPJ P,
	HRRM T2,BUF+UFDLIC(T3)	;SET LICENSE WHEN FIXING
	POPJ P,

LICERM:	HRLZI T,[ASCIZ /WRONG UFD LICENSE/]
FLMERR:	ERRLEV (LEVMIN)
FLRERR:	MOVE N,RIBLBN(P4)
	HRRI T,ERRNAM(P4)
	JRST PRTRBL

BADPRV:	SKIPN FIXFLG
	JRST PRVERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 9,BUF+UFDPRV(T3),35]
	POPJ P,

PRVERM:	HRLZI T,[ASCIZ /WRONG UFD PROTECTION/]
	JRST FLMERR

SETUFX:	HLRZ T1,P4	;GET PLACE CALLED FROM
	MOVEI T,UFDBKF(T1)
	MOVE T3,P2
	SUB T3,UFDOGP(T1)
	MOVE T1,NXTPTR(T1)	;THE PLACE TO FIX
	JRST ADDFIX
BADTIM:	SKIPN FIXFLG
	JRST TIMERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 17,BUF+UFDTMD(T3),23]
	POPJ P,

TIMERM:	HRLZI T,[ASCIZ /WRONG UFD TIME/]
	JRST FLMERR

BADDAT:	SKIPN FIXFLG
	JRST DATERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 12,BUF+UFDTMD(T3),35]
	LSH T2,-^D12		;NOW HIGH ORDER 2 BITS
	DPB T2,[POINT 2,BUF+UFDTMD(T3),6]
	POPJ P,

DATERM:	HRLZI T,[ASCIZ /WRONG UFD DATE/]
	JRST FLMERR

BADBT1:	SKIPN FIXFLG
	JRST BT1ERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 9,BUF+UFDPRV(T3),26]
	POPJ P,

BT1ERM:	HRLZI T,[ASCIZ /WRONG UFD BITS1/]
	JRST FLMERR

BADBT2:	SKIPN FIXFLG
	JRST BT2ERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 5,BUF+UFDTMD(T3),4]
	POPJ P,

BT2ERM:	HRLZI T,[ASCIZ /WRONG UFD BITS2/]
	JRST FLMERR

BADDIR:	SKIPN FIXFLG
	JRST DIRERM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEI T2,RIPDIR
	XORM T2,BUF+RIBSTS
	POPJ P,

FILFIX:	MOVEI T,FIXRBP(P4)		;Add to this fixup chain (prime)
	MOVE T1,RIBLBN(P4)		;Use prime rib pointer in block
	JRST ADDFIX

RIBFIX:	MOVEI T,FIXRBP(P4)		;Add to this fixup chain
	MOVE T1,SAVRIB+RIBSLF(P4)	;Use self pointer (in case spare RIB)
	JRST ADDFIX
DIRERM:	HRLZI T,[ASCIZ /RIPDIR SET WRONG/]
	JRST FLMERR

BADSNM:	SKIPN FIXFLG
	 JRST SNMERM
	PUSHJ P,RIBFIX			;Use RIBFIX not FILFIX for spare RIB
	 POPJ P,
	MOVEM T2,BUF+RIBSNM
	POPJ P,

SNMERM:	MOVSI T,[ASCIZ /NUMBER OF SUBRIBS WRONG/]
	JRST FLMERR

BADALP:	SKIPN FIXFLG
	JRST ALCERM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEM T2,BUF+RIBALP
	POPJ P,

ALCERM:	MOVSI T,[ASCIZ /ALLOCATION WRONG/]
	ERRLEV (LEVCRS)
	JRST FLRERR

BADSIZ:	SKIPN FIXFLG
	JRST SIZERM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEM T2,BUF+RIBSIZ
	POPJ P,

SIZERM:	MOVSI T,[ASCIZ /EOF MISMATCH/]
	ERRLEV (LEVCRS)
	JRST FLRERR

BADALU:	SKIPN FIXFLG
	JRST ALUERM
	PUSHJ P,SETUFX
	 POPJ P,
	HRLM T2,BUF+UFDALC(T3)
	POPJ P,

ALUERM:	MOVSI T,[ASCIZ /UFD ALLOCATION MISMATCH/]
	JRST FLMERR

;SPECIAL PROCESSING ROUTINES FOR CERTAIN FILES

;SYSPRC==CRTERR
SYSPRC:	MOVEI	M,[ASCIZ /RIB POINTER TO (SYS) FOUND IN MFD/]
	JRST	CRTERR

;MFDPC1==CRTERR
MFDPC1:	MOVEI	M,[ASCIZ /RIB POINTER TO MFD FOUND IN MFD/]
	JRST	CRTERR

SATPRC:	SETOM SATRIB
	POPJ P,
;HOME.SYS FILE.  CHECK THE RIB AGAINST OUR IMPRESSION OF WHAT IT SHOULD
; BE.  ITS RIB IS CREATED BY THE CODE IN REFSTR @ INISA5+2, FF.
;THE TWO HOME PAGES ARE ALLOCATED FIRST, NEXT THE BAT PAGES,
; AND THEN THE BOOTSTRAP AREA.  IN KA,I,L SYSTEMS THE BOOTSTRAP
; AREA IS 3 PAGES LONG.  IN KS SYSTEMS IT IS 100 PAGES LONG.

HOMPRC:	MOVEI T1,HOMRTN
	MOVEM T1,ROUTIN(P4)
	MOVEM T,RTNIDX#			;SAVE IN CASE OF ERROR
	SETZM	RTNUNI#
	SETOM	RTNPAG#			;GET STARTED
	HLRZ	T1,CHRBUF+.CHBSA	;COMPUTE SIZE OF HOME FILE.
	ADDI	T1,HTL			;PAGE 0, HP1, HP2, BP1, BP2
	MOVEM	T1,HFSIZ#
	POPJ	P,

HOMRTU:	SETOM	RTNPAG
	AOS	U,RTNUNI		;NEXT UNIT
	CAMG	U,HIGHU			;END?
	 JRST	HOMRTN			;NO
	JUMPN	T,CRTIDX		;J-NOT EOF SO ERROR.
	SETOM	HOMRIB
	POPJ	P,

HOMRTN:	AOS T1,RTNPAG
	CAML T1,HFSIZ
	 JRST HOMRTU		;FINISHED WITH THIS UNIT
	CAIL T1,HTL
	 JRST [	ADD T1,CHRBUF+.CHBSA	;HOMLTB+N -> RH(.CHBSA)+N, N>=0
		SUBI T1,HTL
		HRRZS T1
		JRST HOMRT1]
	CAIGE	T1,HTL
	 XCT	HOMTBL(T1)
HOMRT1:	MOVE	U,RTNUNI
	DPB	U,[POINT PTSUNI,T1,PTNUNI]
	TLO	T1,RBREAL
	CAMN	T1,T
	 POPJ	P,			;THIS ONE IS OK
CRTIDX:	MOVE	T,RTNIDX
	JRST	CRTERR			;ERROR

HOMTBL:	SETZ	T1,
	HLRZ	T1,CHRBUF+.CHHA
	HRRZ	T1,CHRBUF+.CHHA
	HLRZ	T1,CHRBUF+.CHBA
	HRRZ	T1,CHRBUF+.CHBA
HTL==.-HOMTBL
repeat 0,<			; removed by edit 35
SWPPRC:	MOVEI T1,SWPRTN
	MOVEM T1,ROUTIN(P4)
	MOVEM T,RTNIDX
	SETZM RTNCNT#
	SETOM RTNUNI
	POPJ P,

SWPRTU:	AOS U,RTNUNI
	CAMLE U,HIGHU
	JRST SWPEOF
	SKIPN T1,@PTRSWP
	JRST SWPRTU	;NO SPACE ON THIS UNIT
	MOVEM T1,RTNCNT
	MOVE T1,@PTRSWB
	MOVEM T1,RTNPAG
SWPRTN:	SOSGE RTNCNT
	JRST SWPRTU
	MOVE T1,RTNPAG
	MOVE U,RTNUNI
	DPB U,[POINT PTSUNI,T1,PTNUNI]
	TLO T1,RBREAL
	CAME T1,T
	JRST CRTIDX
	AOS RTNPAG
	POPJ P,

SWPEOF:	JUMPN T,CRTIDX
	SETOM SWPRIB
	POPJ P,
>; end repeat 0
;TABLES USED BY VARIOUS ROUTINES

;POINTERS TO VARIOUS PER UNIT TABLES

UNITAB:	PTRDST#		;DISK SATS
	PTRTST#		;TROUBLE SATS (FOR MULTIPLY USED PAGES)
	PTROST#		;OUR SAT (CREATED BY DSKCLN)
	PTRSAD#		;SAT ADDRESSES
	PTRUNU#		;UNIT IN USE
	PTRSWP#		;NUMBER OF K FOR SWAPPING ON UNIT
	PTRSWB#		;FIRST BLOCK FOR SWAPPING
UNTLEN==.-UNITAB

;USED TO READ AND CHECK INFORMATION IN HOME BLOCKS

HOMTAB:	STROVR#,,HOMOVR	;OVERDRAW
	SATRIB#,,HOMSAT	;SAT.SYS RIB
	HOMRIB#,,HOMHMS	;HOME.SYS RIB
	SWPRIB#,,HOMSWP	;SWAP.SYS RIB
	SYSRIB#,,HOMSUF	;SYS UFD RIB
	MFDRIB+RIBLBN,,HOMMFD	;1,1.UFD RIB
	STRHSH#,,HOMHSH		;HASH FOR UFD
HOMTLN==.-HOMTAB
;TABLE TO USE IN SETTING UP SATS

SATTAB:	@PTRDST		;DISK SAT
	@PTRTST		;TROUBLE SAT (MULIPLY USED PAGES)
	@PTROST		;OUR SAT (THE ONE WE ARE CREATING)
STBLEN==.-SATTAB

;ERROR MESSAGES AFTER DSKRAT

ERRTAB:	PHASE	0		;[105]
LEV000:	[ASCIZ /NO DISK PROBLEMS./]
LEVMIN:	[ASCIZ /ONLY MINOR ERRORS DETECTED.  OK TO BRING SYSTEM UP FOR USERS./]
LEVUSR:	[ASCIZ /ERRORS DETECTED WHICH MAY BE SERIOUS TO INDIVIDUAL USERS.
    SHOULD NOT KILL SYSTEM./]
LEVSAT:	[ASCIZ /SATS NEED TO BE REWRITTEN BECAUSE FREE PAGES EXIST.
    RELOAD THE SYSTEM SO THAT A "FAST DSKCLN" CAN FIX THE SATS./]
	;[105] Note that LEVSAT can only occur in CHECK mode, never FIX mode.
LEVCRS:	[ASCIZ /ERRORS DETECTED WHICH MAY CAUSE SYSTEM CRASHES.  SUGGEST FIXING
    ERRORS BEFORE BRING SYSTEM UP FOR USERS./]
LEVBAD:	[ASCIZ /ERRORS DETECTED WHICH MAY CAUSE SEVERE DISK GARBAGING.  DO NOT
    BRING SYSTEM UP FOR USERS UNTIL ERRORS ARE FIXED./]
	REPEAT 20+LEV000-.,<[0]>
	DEPHASE			;[105]

LOSTAB:	@PTRDST	;FIRST SAT TO USE
	@PTROST	;SECOND SAT TO USE
	NOLOS	;NO LOST PAGES MESSAGE
	HEDLOS	;HEADER FOR LOST PAGES
	TOTLOS	;TOTAL LOST MESSAGE
	ERRLEV (LEVMIN)	;PUSHJ HERE TO SET ERROR LEVEL
	POPJ P,
	TDNE T1,(T4)	;PUSHJ HERE TO TEST FOR LOST. IN OUR SAT?
	TDNE T1,(T3)	;NO, IN DISK SAT?
	POPJ P,	;IN OURS OR IN NEITHER
	JRST CPOPJ1	;NOT IN OURS BUT IN DISK

NOLOS:	ASCIZ /
THERE ARE NO LOST PAGES (MARKED IN USE, BUT IN NO FILE).
/
HEDLOS:	ASCIZ /
THE FOLLOWING PAGES ARE LOST (MARKED IN USE, BUT IN NO FILE):
/
TOTLOS:	ASCIZ /
TOTAL NUMBER OF LOST PAGES = /
FRETAB:	@PTRDST	;CHECK FOR FREE PAGES
	@PTROST
	NOFREE
	HEDFRE
	TOTFRE
	ERRLEV (LEVBAD)
	POPJ P,
	TDNN T1,(T4)	;IN OUR SAT?
	TDNN T1,(T3)	;YES, IN DISK SAT?
	POPJ P,		;NOT IN OURS OR IN BOTH
	JRST CPOPJ1	;IN OURS BUT NOT DISK

NOFREE:	ASCIZ /
THERE ARE NO FREE PAGES (NOT MARKED IN USE, BUT IN SOME FILE).
/
HEDFRE:	ASCIZ /
THE FOLLOWING PAGES ARE FREE (NOT MARKED IN USE, BUT IN SOME FILE):
/
TOTFRE:	ASCIZ /
TOTAL NUMBER OF FREE PAGES = /

MLTTAB:	@PTRTST	;TROUBLE SAT
	@PTRTST	;REALLY ONLY ONE THAT MATTERS
	NOMULT
	HEDMLT
	TOTMLT
	POPJ P,		;ERROR LEVEL ALREADY SET
	POPJ P,
	TDNN T1,(T3)
	AOS (P)	;BAD IF MARKED
	POPJ P,

NOMULT:	ASCIZ /
THERE ARE NO MULTIPLY USED PAGES (BELONG TO MORE THAN ONE FILE).
/
HEDMLT:	ASCIZ /
THE FOLLOWING PAGES ARE MULTIPLY USED (BELONG TO MORE THAN ONE FILE):
/
TOTMLT:	ASCIZ /
TOTAL NUMBER OF MULTIPLY USED PAGES = /
	DEFINE SPCMAC
< IFNDEF XX,<XX:>
	X MFDPPN,UFD,MFDRBC,MFDPC1
	X SYSPPN,UFD,SYSRIB,SYSPRC
  IFNDEF SPUFDN,<SPUFDN==.-XX>;;# OF UFD ENTRIES
	X HOME,SYS,HOMRIB,HOMPRC
	X SAT,SYS,SATRIB,SATPRC
;;*;	X SWAP,SYS,SWPRIB,SWPPRC	;SWAP.SYS is obsolete, deleted
;;*;	X SPAGES,SYS,SWPRIB,SPGPRC	;SPAGES.SYS is not on all systems yet
	X CRASH,SAV,[-1],CPOPJ;;	;CRASH.SAV only needs to exist
>

	DEFINE X (A,B,C,D),<C>
SPCACT:	SPCMAC				;Ret-ptr to special file

	DEFINE X (A,B,C,D),<D>
SPACT2:	SPCMAC				;Routine to call on special file

	DEFINE X (A,B,C,D),<
	IFIDN <B><UFD>,<MFDPPN>
	IFDIF <B><UFD>,<SYSPPN>>
SPCPPN:	SPCMAC				;PPN of special files

	DEFINE X (A,B,C,D),<
	IFIDN <B><UFD>,<A>
	IFDIF <B><UFD>,<SIXBIT /A/>>
SPCNAM:	SPCMAC				;Name of special files

	DEFINE X (A,B,C,D),<SIXBIT /B/>
SPCEXT:	SPCMAC				;Extension of special files
	SPCLEN==.-SPCEXT		;Number of special files
;ERROR ROUTINES

TRMMES:	SKIPE	DETSW		;MESSAGE POINTED TO BY M
	 JRST	DETMSG		;EVENTUALLY TO CTY
	OUTSTR	@M
	POPJ	P,

TRMCHR:	SKIPE	DETSW		;Character in CH
	 JRST	DETCHR
	OUTCHR	CH
	POPJ	P,

DETCHR:	LSH	CH,^D<36-7>	;Make character left justified
	MOVEI	M,CH		;Point to single character string
DETMSG:	HRLI	M,SUUMSG
	SETUUO	M,		;SEND MSG TO OPR
	 OUTSTR	@M		;OUTSTR IF IT FAILS
	POPJ	P,

;Check for SY, ST, JL, RA, and WA lic

CHKLIC:	HRROI	T,LICTAB	;Get lic word
	GETTAB	T,
	  MOVEI	T,0		;As if had no lic
	SETCA	T,T
	TLNN	T,LICSY+LICST+LICJL+LICRA+LICWA	;Does process have required
						; lic?
	 POPJ	P,		;Yes
NOJAL:	MOVEI	M,[ASCIZ /
SY, ST, JL, RA, AND WA LICENSE REQUIRED.  NOTIFY SQC.
/]
	
FATERR:	CLOSE LPT,
	PUSHJ P,TRMMES
	JRST QUIT0

NOCOR:	MOVEI M,[ASCIZ /
INSUFFICIENT CORE AVAILABLE/]
	JRST FATERR

PVYERR:	MOVEI	M,[ASCIZ/
DSKCLN USER CORE LIMIT SET TOO LOW/]
	JRST	FATERR

OPNERR:	MOVEI M,[ASCIZ /
CAN NOT OPEN AN OUTPUT FILE/]
	JRST FATERR

NODSER:	MOVEI	M,[ASCIZ/
DSKCLN UUO FAILED.
NOTIFY OPERATING SYSTEMS/]
	JRST	FATERR

FALLPT:	MOVEI M,[ASCIZ /
CAN NOT OPEN LIST OUTPUT. LPT NOT AVAILABLE?/]
	JRST FATERR

IFN MAKSW!DEBUG,<
FALFAK:	OUTSTR [ASCIZ /
CAN NOT OPEN SIMULATION FILE/]
	EXIT>

  PAGE
HOMNUM:	MOVEI M,[ASCIZ /
WRONG NUMBER OF HOME BLOCKS READ
NOTIFY OPERATING SYSTEMS/]
	JRST FATERR

BADHOM:	MOVEI M,[ASCIZ /
BAD HOME BLOCK ON UNIT /]
	PUSHJ P,TRMMES
	MOVE P1,[POINT 7,TRMBLK]
	MOVE N,U
	MOVEI P4,TRMSAV
	MOVEM P4,TYODSP#
	PUSHJ P,DECPRT
	MOVEI T,0
	IDPB T,P1
	MOVEI M,TRMBLK
	PUSHJ P,TRMMES
	MOVEI M,[ASCIZ /
NOTIFY OPERATING SYSTEMS/]
	JRST FATERR

;THIS ROUTINE IS USED TO OUTPUT CHRS TO A BYTE POINTER IN P1

TYOBTH:	SKIPE P4	;POSSIBLE TO BOTH FILE AND TERMINAL
	PUSHJ P,TYO	;SEND TO FILE
TRMSAV:	IDPB CH,P1
	POPJ P,

FRDER:	MOVEI M,[ASCIZ /
FATAL READ ERROR WHILE FIXING DISK/]
	JRST FATERR

NOCLR:	MOVEI M,[ASCIZ /
CAN NOT CLEAR DISK INFORMATION
CRASH SYSTEM, BRING IT BACK UP, RUN DSKCLN AGAIN.
IF PROBLEM PERSISTS, CALL SYSTEMS
REMEMBER TO SAVE THE CRASH.
/]
	JRST FATERR
COMMENT #
@@SUBROUTINE GETCOR
@@PURPOSE
SUBR TO SEE IF WE NEED CORE, AND THEN TO GET CORE, IF
NECESSARY.
@@ENTRY
EXPECTS T/ HIGHEST DESIRED ADDRESSABLE LOCATION.
@@ACCUM
DESTROYS T.
@@EXIT
NON-SKIP RETURNS IF OKAY, NEVER RETURNS IF NOT OKAY.
ON SUCCESS, HAS SET UPRBND TO NEW VALUE.
@@ #

GETCOR:	CAMG	T,UPRBND	;NEED MORE CORE?
	 POPJ	P,		;NO.
	IORI	T,1777		;GO BY K.
	MOVEM	T,UPRBND	;
	CORE	T,		;OLD STYLE GET CORE.
	  JRST	NOCOR		;
	POPJ	P,
;CHECK FOR OPER LICENSE

CHKOPR:	HRROI	T,LICTAB	;GET LICENSE WORD
	GETTAB	T,
	  MOVEI	T,0		;AS IF HAD NO LICENSE
IFE DEBUG!MAKSW,<
	TRNE	T,LICOPR	;DOES JOB, NOT PROCESS, HAVE OP?
	 JRST	(P)		;YES, OK.
	MOVEI	M,[ASCIZ/
OP LICENSE REQUIRED/]
	PUSHJ	P,TRMMES
	EXIT
>

IFN DEBUG!MAKSW,<
	TRNN	T,3		;MAKE SURE HE ISN'T DANGEROUS
	 JRST	(P)		;OK.
	OUTSTR	[ASCIZ/
MUST NOT HAVE WP,WF, OR WA IN DEBUG OR MAKE MODE/]
	EXIT
>

QUIT0:	MOVEI	M,NOUP
	PUSHJ	P,TRMMES
	PUSHJ	P,IDEND	;PRINT TERMINATION MESSAGE
	EXIT		;ALWAYS EXIT IF FATAL ERROR


QUIT:	PUSHJ	P,IDEND		;PRINT TERMINATION MESSAGE
IFN MAKSW,<PUSHJ P,OUTDIR>
	SKIPN	DETSW		;SPECIAL IF AUTO-RESTART
	 EXIT
	HLRZ	T,JOBSA		;KEEP LOWSEG BELOW 256K
	CORE	T,		;SO LOGOUT WILL RUN UNDER P032.
	  JFCL			;SHOULD NEVER FAIL
	MOVSI	T,SUUINI
	SETUUO	T,		;START REST OF AUTO-RELOAD GOING
	 JFCL
	MOVE T,[LOGITM,,LOGTAB]
	GETTAB T,
	 MOVE T,[SIXBIT /LOGOUT/]
	MOVEM T,FILNAM+1
	SETZM FILNAM+2
	MOVE T,[FILNAM+2,,FILNAM+3]
	BLT T,FILNAM+5
	MOVSI T,'SYS'
	MOVEM T,FILNAM
	MOVEI T,FILNAM
	HRLI T,1	;NOW LOGOUT
	RUN T,
	HALT .		;IN CASE OF ERROR

NOUP:	ASCIZ /
DO NOT ATTEMPT TO BRING SYSTEM UP FOR USERS/

SRBERR:	MOVEI M,[ASCIZ /
ERROR IN SAT.SYS RIB/]
	JRST FATERR

SBKERR:	MOVEI M,[ASCIZ /
ERROR READING A SAT BLOCK/]
	JRST FATERR

ERLSET:	PUSH P,T
	MOVE T,-1(P)
	LDB T,[POINT 4,-1(T),12]
	MOVEM T,THSERR#
	CAMLE T,ERRSAV
	MOVEM T,ERRSAV
	POP P,T
	POPJ P,
;SUBROUTINE TO PRINT ERROR MESSAGES CONCERNING PARTICULAR PAGES IN THE FORMAT:
;     FILE  FILE.EXT  [PRJ,PRG] PAGE #  RANDOM ERROR MESSAGE
; THE ARGUMENTS TO THE SUBROUTINE ARE:
;     ACC N CONTAINS THE CLUSTER NUMBER (IF NEGATIVE CLSTR # WILL NOT BE PRINTED)
;     LH OF ACC T HAS ADR OF RANDOM ASCIZ ERROR MESSAGE (CAN BE 0 IF NONE DESIRED)
;     RH OF ACC T HAS ADR OF 4-WORD LOOKUP BLOCK CONTAINING THE SIXBIT
;      FILENAME AND EXTENSION AND PRJ,PRG IN THE STANDARD PLACES

PRTRBL:	PUSH	P,N		;Page pointer
	PUSH	P,T		;Pointer to ERRNAM,ERREXT,ERRPPN,ERRUNM
	MOVE	T1,THSERR
	CAMGE	T1,MINERR
	 JRST	PRTRB5
	SETOM	TRBFIL
PRTRBX:	HLRZ	T1,1(T)
	CAIN	T1,'UFD'
	 JRST	PRTRBU		;Check if really a UFD, jrst to PRTBU1 if not
PRTBU1:	SKIPN	T,ERRUNM-ERRNAM+0(T)	;Any username?
	 JRST	PRTBU2		;No, unknown at this time
	MOVEI	CH,"("		;Yes, print it (T is preserved so this works)
	PUSHJ	P,@TYODSP
	PUSHJ	P,PR6BIT	;Username, first half
	MOVE	T,0(P)		; sixbit output clobbers T
	SKIPE	T,ERRUNM-ERRNAM+1(T)
	 PUSHJ	P,PR6BIT	;Username, second half
	MOVEI	CH,")"
	PUSHJ	P,@TYODSP
PRTBU2:	MOVE	T,0(P)
	MOVE	T,ERRNAM-ERRNAM(T)
	PUSHJ	P,PR6BIT	;File name
PRTRB2:	MOVE	T,0(P)
	HLLZ	T,ERREXT-ERRNAM(T)
	SKIPE	T		;File extension
	 PUSHJ	P,PDOT		;PRINT DOT ONLY IF NON-NULL EXT
	PUSHJ	P,PR6BIT
	MOVE	T,0(P)
	SKIPN	ERRPPN-ERRNAM(T)
	 JRST	PRTRB3
	MOVEI	CH,"["		;Project,Programmer Number
	PUSHJ	P,@TYODSP
	HLRZ	N,ERRPPN-ERRNAM(T)	;Project #    (GAN)
	PUSHJ	P,OCTPRT
	PUSHJ	P,COMMA
	HRRZ	N,ERRPPN-ERRNAM(T)	;Programmer # (UUN)
	PUSHJ	P,OCTPRT
	MOVEI	CH,"]"
	PUSHJ	P,@TYODSP
PRTRB3:	SKIPGE	N,-1(P)		;Page pointer supplied?
	 JRST	PRTRB4
	MOVEI	M,[ASCIZ / unit /]
	PUSHJ	P,MSG
	LDB	N,[POINT PTSUNI,N,PTNUNI]
	PUSHJ	P,OCTPRT
	MOVEI	M,[ASCIZ / page /]
	PUSHJ	P,MSG
	LDB	N,[POINT PTSPNO,-1(P),PTNPNO]
	PUSHJ	P,OCTPRT
PRTRB4:	PUSHJ	P,SPC
	PUSHJ	P,SPC
	HLRZ	M,0(P)		;LH of T had extra message, if any
	SKIPE	M
	 PUSHJ	P,MSG
	PUSHJ	P,CRLF		;Finish file-unit-msg line
	SKIPN	DEBIDX		;Anything stored for rib index info
	 JRST	PRTRB5		;No, not that type of error
	MOVEI	M,[ASCIZ /Unit /]
	PUSHJ	P,MSG
	PUSH	P,U
	LDB	U,[POINT PTSUNI,DEBRIB,PTNUNI]
	PUSHJ	P,LNAME
	POP	P,U
	MOVE	T,CHRBUF	;DSKB logical name
	PUSHJ	P,PR6BIT
	MOVEI	M,[ASCIZ / page /]
	PUSHJ	P,MSG
	LDB	N,[POINT PTSPNO,DEBRIB,PTNPNO]
	PUSHJ	P,OCTPRT
	MOVEI	M,[ASCIZ / index /]
	PUSHJ	P,MSG
	HRRZ	N,DEBIDX	;Get index to block
	PUSHJ	P,OCTPRT	;And print it
	MOVEI	M,[ASCIZ /, value /]
	PUSHJ	P,MSG
	HLRZ	N,DEBPTR	;Get pointer (left)
	PUSHJ	P,OCTPRT
	PUSHJ	P,COMMA
	HRRZ	N,DEBPTR	;Get pointer (right)
	PUSHJ	P,OCTPRT
	MOVEI	M,[ASCIZ /  reason/]
	PUSHJ	P,MSG		;Let them know
	MOVE	T,DEBRSN	; the reason
	PUSHJ	P,PR6BIT
	PUSHJ	P,CRLF		;Finish up message

PRTRB5:	SETZM	DEBIDX		; Only print it once
	POP	P,T
	POP	P,N
	POPJ	P,

PRTRBU:	SKIPE	N,ERRPPN-ERRNAM(T)
	CAMN	N,[MFDPPN]
	 SKIPA			;REALLY A UFD
	  JRST	PRTBU1		;Not in [1,1] or not MFD itself
	MOVEI	CH,"["
	PUSHJ	P,@TYODSP
	HLRZ	N,0(T)
	PUSHJ	P,OCTPRT
	PUSHJ	P,COMMA
	HRRZ	N,0(T)
	PUSHJ	P,OCTPRT
	MOVEI	CH,"]"
	PUSHJ	P,@TYODSP
	JRST	PRTRB2		;Output ".UFD"

MINERR:	0
;ROUTINES TO PRINT RIGHT-JUSTIFIED INTEGERS
; FIELD WIDTH IN ACC T
; NUMBER IN ACC N

DECSPC:	SKIPA CH,[40]		;DECIMAL WITH LEADING SPACES
DECZRO:	MOVEI CH,"0"		;DECIMAL WITH LEADING ZEROES
	MOVEI N1,^D10
	JRST RJRDXP
OCTSPC:	SKIPA CH,[40]		;OCTAL WITH LEADING SPACES
OCTZRO:	MOVEI CH,"0"		;OCTAL WITH LEADING ZEROES
	MOVEI N1,^D8
RJRDXP:	MOVEM N1,RADIX#
JUSTFY:	SOJLE T,RDXPRT		;RIGHT JUSTIFY
	CAMGE N,N1
	PUSHJ P,@TYODSP
	IMUL N1,RADIX
	JRST JUSTFY

DECPRT:	SKIPA N1,[^D10]
OCTPRT:	MOVEI N1,^D8
	MOVEM N1,RADIX
RDXPRT:	IDIV N,RADIX		;ANY RADIX PRINT ROUTINE
	HRLM N1,0(P)
	SKIPE N
	PUSHJ P,RDXPRT
	HLRZ CH,0(P)
	ADDI CH,"0"
	JRST @TYODSP

;Routine to print version number

PRVER:	LDB	N,[POINT 9,JOBVER,11]
	PUSHJ	P,OCTPRT	;Major version number
	LDB	CH,[POINT 6,JOBVER,17]
	JUMPE	CH,PRVER1
	ADDI	CH,"@"		;Minor version letter
	PUSHJ	P,@TYODSP
PRVER1:	MOVEI	CH,"("
	PUSHJ	P,@TYODSP
	LDB	N,[POINT 18,JOBVER,35]
	PUSHJ	P,OCTPRT	;Edit number
	MOVEI	CH,")"
	PUSHJ	P,@TYODSP
	LDB	N,[POINT 3,JOBVER,2]
	JUMPE	N,CPOPJ		;No "who" value
	MOVEI	CH,"-"
	PUSHJ	P,@TYODSP
	JRST	OCTPRT		;Who edited
;SUBROUTINE TO IDENTIFY THIS RUN

IDENT:	PUSHJ	P,CRLF2
	MOVSI T,-6		;GET SYSTEM NAME
NAMLP:	HRL M,T
	HRRI M,CNFTAB
	GETTAB M,
	 MOVEI M,0
	MOVEM M,CNFNAM(T)
	AOBJN T,NAMLP
	MOVEI M,CNFNAM	;NOW PRINT IT
	PUSHJ P,MSG
	PUSHJ P,CRLF
	MOVE	T,STRNAM
	PUSHJ	P,PR6BIT
	MOVEI	M,[ASCIZ /.  MODE: /]
	PUSHJ	P,MSG
	MOVE	T,DCN
	MOVE	T,DCNNAM(T)
	PUSHJ	P,PR6BIT
	MOVEI	M,[ASCIZ /.     ANALYSIS BEGUN AT /]
	PUSHJ	P,MSG
	PUSHJ	P,NOW
	PJRST	CRLF2

;SUBROUTINE TO PRINT TERMINATION MESSAGE

IDEND:	MOVEI	M,[ASCIZ /

DSKCLN DONE AT /]
	PUSHJ	P,TRMMES
	MOVE	P1,[POINT 7,TRMBLK]
	MOVEI	T,TRMSAV
	MOVEM	T,TYODSP
	PUSHJ	P,NOW
	PUSHJ	P,CRLF2
	PUSHJ	P,NULL
	MOVEI	M,TRMBLK
	PJRST	TRMMES
;THESE ARE PRINT-OUT ROUTINES LIFTED FROM DSKLST AND OCCASIONALLY
; SLIGHTLY MODIFIED  (AC USAGE, ETC.)

MSG:	HRLI M,440700		;PRINT RANDOM LENGTH (ASCIZ) MESSAGE
MSGL:	ILDB CH,M		;  ADDRESS OF MESSAGE IS IN ACC M
	JUMPE CH,CPOPJ
	PUSHJ P,@TYODSP
	JRST MSGL

SPC:	MOVEI CH,40		;PRINT OUT PARTICULAR CHARACTERS...
	JRST @TYODSP
FORM:	MOVEI	CH,14
	JRST	@TYODSP
COMMA:	MOVEI CH,","
	JRST @TYODSP
PDOT:	MOVEI CH,"."
	JRST @TYODSP
NULL:	MOVEI	CH,0
	JRST	@TYODSP

CRLF3:	PUSHJ P,CRLF
CRLF2:	PUSHJ P,CRLF
CRLF:	JSP M,MSG
	ASCIZ /
/
PR6BIT:	MOVEI M,0
	LSHC M,6	;FROM T
	MOVE CH,M
	ADDI CH," "
	PUSHJ P,@TYODSP
	JUMPN T,PR6BIT
	POPJ P,

TRMOPR:	PUSH P,CH
	MOVE CH,[POINT 7,TRMBLK]
	MOVEM CH,TRMPTR#
	MOVEI CH,TRMOP2
	MOVEM CH,TYODSP
	POP P,CH
TRMOP2:	IDPB CH,TRMPTR
	CAIE CH,12
	POPJ P,
	PUSH P,M
	MOVSI M,TRMOPR
	MOVSM M,TYODSP
	IDPB M,TRMPTR	;SWAPPED GIVES US A ZERO TO IDPB
	MOVEI M,TRMBLK
	PUSHJ P,TRMMES
	POP P,M
	POPJ P,
TYO:	SOSG LOBUF+2
	OUTPUT LPT,0
	IDPB CH,LOBUF+1
	POPJ P,

NOW:	MOVEI	M,[ASCIZ / DATE NOT RECEIVED/]
	MOVE	T1,[DATITM,,DATTAB]
	GETTAB	T1,
	  SETO	T1,
	JUMPL	T1,NODAT		;DATE NOT YET SET
	MOVE T2,[TIMITM,,TIMTAB]
	GETTAB T2,
	 MOVEI T2,0
	MOVE T3,[400020,,20]	;CONVERT TO DEC FMT GMT
	MOVEI T4,T1
	DATUUO T4,
	 MOVEI T4,0	;FLAG IF NO DATUUO (TIME NOT GMT)
	PUSH P,T4	;SAVE FLAG
	PUSH P,T1	;AND DATE
	MOVE T1,T2	;GET TIME
	IDIVI T1,^D3600
	MOVE T3,T2
	IDIVI T3,^D60		;SECONDS IN T3
	IDIVI T1,^D60		;HOURS IN T1, MINUTES IN T2
	HRREI T4,-2
	SKIPA CH,[40]
NOWLUP:	MOVEI CH,":"
	PUSHJ P,@TYODSP
	MOVEI T,2
	MOVE N,T3(T4)
	PUSHJ P,DECZRO
	AOJLE T4,NOWLUP
	PUSHJ P,SPC
	PUSHJ P,SPC
	POP P,T1		;RESTORE DATE

PRDATE:	IDIVI T1,^D31
	MOVEI N,1(T2)
	MOVEI T,2
	PUSHJ P,DECZRO
	IDIVI T1,^D12
	MOVE M,MONTAB(T2)
	MOVEI T3,0
	PUSHJ P,MSG
	MOVEI N,^D1964(T1)
	PUSHJ P,DECPRT
	POP	P,T1		;GMT FLAG
	MOVEI	M,[ASCIZ / GMT/]
	SKIPE	T1		;Nonzero if this monitor understands GMT
NODAT:	 PUSHJ	P,MSG		;[107]
	MOVEI	M,[ASCIZ /     UPTIME = /];[107]
	PUSHJ	P,MSG		;[107]
	MOVE	T1,[15,,12]	;[107] *HACK* Need to convert to UUOSYM symbols
	GETTAB	T1,		;[107] Get system uptime
	  MOVEI	T1,0		;[107]
	IDIVI	T1,^D<60*60>	;[107] *HACK* Assume 60 Hz
	MOVE	N,T1		;[107]
	PUSHJ	P,DECPRT	;[107]
	JSP	M,MSG		;[107]
	 ASCIZ / MINUTES/	;[107]

DEFINE MONMAC(A)<IRP A,<[ASCIZ /-A-/]>>
MONTAB:
MONMAC<JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC>

; Here on a critical error.  Build a call to PRTRBL (print file and
;  error message), then die.
;
; Entered with M pointing to ASCIZ string indicating cause of death.


CRTERM:	MOVEI	T,0			;ERROR IN MFD
CRTERR:	MOVEI	P3,[ASCIZ /CRITICAL FILE DAMAGED/]
	JRST	CRTER1

UFDERR:	MOVEI	M,[ASCIZ /BAD FILE SPEC IN UFD POINTING TO CRITICAL FILE/]
	JRST	CRTER1

MISCRT: MOVEI	M,[ASCIZ /CRITICAL FILE MISSING/]
	MOVEI	P3,[0]

CRTER1:	MOVEI	P4,FILRIB
	MOVE	T1,SPCNAM(T)
	MOVEM	T1,ERRNAM(P4)
	MOVE	T1,SPCEXT(T)
	MOVEM	T1,ERREXT(P4)
	MOVE	T1,SPCPPN(T)
	MOVEM	T1,ERRPPN(P4)
	HRLZ	T,M			;POINTER TO CAUSE OF DEATH STRING
	MOVE	P1,[POINT 7,TRMBLK]
	MOVEI	T1,TRMSAV		;DAMAGE TO CRITICAL FILE
	MOVEM	T1,TYODSP
	SETO	N,
	HRRI	T,ERRNAM(P4)
	PUSHJ	P,PRTRBL
	PUSHJ	P,CRLF
	MOVE	M,P3			;MISSING OR DAMAGED MESSAGE
	PUSHJ	P,MSG
	MOVEI	T,0
	IDPB	T,P1
	MOVEI	M,TRMBLK
	PUSHJ	P,TRMMES		;[107] Output message
	POPJ	P,			;[107] Continue anyway
;SUBROUTINES START HERE

;SUBROUTINE TO COMPUTE SIXBIT FOR LOGICAL UNIT WITHIN FILE STRUCTURE
;ARGS	STRNAM=SIXBIT NAME OF FILE STRUCTURE
;	U=LOGICAL UNIT IN STR
;VALUE	CHRBUF=SIXBIT LOGICAL UNIT IN STR

LNAME:	MOVE	T2,STRNAM	;SIXBIT/DSKB/
	MOVE	T3,[POINT 6,T2]
LNAME1:	TLNN	T3,770000	;If tried all 6 chars,
	 JRST	STRLUX		; stop
	ILDB	T4,T3
	JUMPN	T4,LNAME1	;FIND END OF STR NAME
	MOVE	T,U
	IDIVI	T,10
	JUMPE	T,STRLU1	;Single digit
	ADDI	T,'0'
	DPB	T,T3
	IBP	T3
STRLU1:	ADDI	T1,'0'		;Convert to sixbit number
	DPB	T1,T3
STRLUX:	MOVEM	T2,CHRBUF
	POPJ	P,

;READ AND CHECK THE HOME BLOCKS. TRY FIRST BLOCK THEN SECOND
;IF FIRST IS BAD

HOMCHK:	MOVE P1,CHRBUF+.CHHA	;ADDRESS OF HOME PAGES.
	PUSHJ P,HOMCK1	;READ THEM AND CHECK
	 JRST CPOPJ1	;NON-SKIP RETURN SAYS GOOD
	MOVSS P1	;TRY THE NEXT ONE
	PUSHJ P,HOMCK1
CPOPJ1:	 AOS (P)	;GOOD, TAKE SKIP RETURN TO SAY GOOD
CPOPJ:	POPJ P,
HOMCK1:	HLRZ T1,P1	;GET BLOCK NUMBER TO READ
	PUSHJ P,PAGRED
	 JRST CPOPJ1	;BLOCK WAS BAD
	MOVSI T,'HOM'
	MOVEI T1,CODHOM
	CAMN T,BUF+HOMNAM
	CAME T1,BUF+HOMCOD
	JRST CPOPJ1	;ONE OF THOSE WAS BAD
	HLRZ T1,P1
	DPB U,[POINT PTSUNI,T1,PTNUNI]
	TLO T1,RBREAL	;AMKE IT A REAL POINTER
	CAME T1,BUF+HOMSLF
	JRST CPOPJ1	;SHOULD HAVE OWN BLOCK NUMBER
	PUSHJ P,LNAME	;GET NAME FOR THIS UNIT IN STR
	MOVE T,STRNAM
	MOVE T1,CHRBUF	;NAME OF THIS UNIT
	CAMN T,BUF+HOMSNM
	CAME T1,BUF+HOMLOG	;THESE SHOULD AGREE
	AOS (P)		;THEY DO NOT, SKIP RETURN
	POPJ P,		;ALL GOOD, OK RETURN

;GET SOME OF THE PER UNIT DATA FROM THE HOME BLOCK

HOMCOP:	MOVE T,BUF+HOMSPU	;SATS/UNIT
	HRLZM T,@PTRDST	;INTO DISK SAT POINTER TABLE
	MOVE T,BUF+HOMP4S
	MOVEM T,@PTRSWP	;SAVE SWAPING SPACE
	MOVE T,BUF+HOMSLP
	MOVEM T,@PTRSWB	;AND BLOCK TO CHECK SWAP.SYS
	POPJ P,
;SUBROUTINE TO READ A PAGE
;ARGS	T1=LOGICAL PAGE WITHIN UNIT TO READ
;	U=LOGICAL UNIT NUMBER
;	IOCW=IOWD
;ENTER AT PAGRD1 IF T1=LOGICAL PAGE WITHIN STR

IFE DEBUG,<			; ** Not debugging **
PAGRDP:	LDB	U,[POINT PTSUNI,T,PTNUNI]
	LDB	T1,[POINT PTSPNO,T,PTNPNO]
	HRR	T3,DOGUOR	; Unit out of range
	CAMLE	U,HIGHU		; Is it in range?
	 POPJ	P,		; No.
	HRR	T3,DOGPOR	; Page out of range
	CAML	T1,@PTRPPU	; Page number in range?
	 POPJ	P,
PAGRED:	MOVE	T2,STRPPU	;PAGES PER UNIT IN STR
	IMUL	T2,U		;PAGE NUM OF 1ST PAGE ON UNIT
	ADD	T1,T2		;T1=LOGICAL PAGE WITHIN STR
	HRLI	CHAN,CIO.ST	;CHANIO SETSTS.
	CHANIO	CHAN,16
	HRLI	CHAN,CIO.PI	;CHANIO PAGE USETI.
	CHANIO	CHAN,T1
	HRLI	CHAN,CIO.IN	;CHANIO IN.
	CHANIO	CHAN,IOCW
IFN MAKSW,<JRST PAGOT1>
IFE MAKSW,<JRST CPOPJ1>	;GOOD
	HRLI	CHAN,CIO.ST	;CHANIO SETSTS.
	CHANIO	CHAN,16
IFN MAKSW,<JRST PAGOUT>
IFE MAKSW,<POPJ	P,>		;ERROR RETURN
>; end ife debug
ife debug,<
PAGWTP:	LDB	U,[POINT PTSUNI,T,PTNUNI]
	LDB	T1,[POINT PTSPNO,T,PTNPNO]
	CAMG	U,HIGHU
	CAML	T1,@PTRPPU
	 POPJ	P,
PAGWRT:
IFE MAKSW,<
	MOVE	T2,STRPPU
	IMUL	T2,U
	ADD 	T1,T2
	HRLI	CHAN,CIO.ST	;CHANIO SETSTS.
	CHANIO	CHAN,16
	HRLI	CHAN,CIO.PO	;CHANIO PAGE USETO.
	CHANIO	CHAN,T1
	HRLI	CHAN,CIO.OT	;CHANIO OUT.
	CHANIO	CHAN,IOCW
	POPJ	P,		;ALL OK

	MOVEI	M,[ASCIZ /PAGE WRITE ERROR, UNIT # /]
	PUSHJ	P,MSG
	MOVE	N,U
	PUSHJ	P,OCTPRT
	MOVEI	M,[ASCIZ/, PAGE # /]
	PUSHJ	P,MSG
	MOVE	N,T1
	PUSHJ	P,OCTPRT
	MOVE	M,[ASCIZ/ (WITHIN STR)/]
	JRST	FATERR
>;END IFE MAKSW

IFN MAKSW,<JRST	PAGOUT>
>; end ife debug
IFN MAKSW,<
PAGOT1:	AOS	(P)
PAGOUT:	PUSH	P,T
	HRLZ T,BLKCNT
	JUMPGE T,NEWBLK
SRBLP:	CAMN T1,BLKCNT+1(T)
	JRST	[POP P,T
		 POPJ P,]
	AOBJN T,SRBLP
NEWBLK:	MOVEM T1,BLKCNT+1(T)
	MOVE	T1,[CIO.PO,,FIL] ;CIO.PO=CHANIO PAGE USETO.
	ADDI T,FILOFS+1
	CHANIO T1,T
	OUTPUT FIL,IOCW
	STATZ FIL,760000
	JRST BADFIL
	SOS T,BLKCNT
	CAMLE T,[-FILSIZ]
	JRST	[POP P,T
		 POPJ P,]
	OUTSTR [ASCIZ /TOO MANY PAGES/]
	POP	P,T
	JRST QUIT

BADFIL:	OUTSTR [ASCIZ /BAD OUTPUT FILE/]
	POP	P,T
	JRST QUIT

OUTDIR:	USETO FIL,1
	OUTPUT FIL,TABCMD
	POPJ P,>
IFN DEBUG,<
PAGRDP:	LDB U,[POINT PTSUNI,T,PTNUNI]
	LDB T1,[POINT PTSPNO,T,PTNPNO]
	CAMG U,HIGHU
	CAML T1,@PTRPPU
	POPJ P,
PAGRED:	PUSH	P,T
	MOVE T2,STRPPU
	IMUL T2,U
	ADD T1,T2
	HRLZ T,BLKCNT
	CAME T1,BLKCNT+1(T)
	AOBJN T,.-1
	JUMPGE T,NOBLK
	MOVEI T,FILOFS+1(T)
	MOVE	T1,[CIO.PI,,FIL] ;CIO.PI=CHANIO PAGE USETI.
	CHANIO T1,T
	IN FIL,IOCW
	JRST	[POP P,T
		 JRST CPOPJ1]
	SETSTS FIL,16
	POP	P,T
	POPJ P,

PAGWTP:	LDB U,[POINT PTSUNI,T,PTNUNI]
	LDB T1,[POINT PTSPNO,T,PTNPNO]
	CAMG U,HIGHU
	CAML T1,@PTRPPU
	POPJ P,
PAGWRT:	PUSH	P,T
	MOVE T2,STRPPU
	IMUL T2,U
	ADD T1,T2
	HRLZ T,BLKCNT
	CAME T1,BLKCNT+1(T)
	AOBJN T,.-1
	JUMPGE T,NOBLK
	MOVEI T,FILOFS+1(T)
	MOVE	T1,[CIO.PO,,FIL] ;CIO.PO=CHANIO PAGE USETO.
	CHANIO T1,T
	OUT FIL,IOCW
	JRST	[POP P,T
		 POPJ P,]
	OUTSTR [ASCIZ /BLOCK WRITE ERROR/]
	POP	P,T
	JRST QUIT0
NOBLK:	OUTSTR [ASCIZ /BLOCK NOT IN SIMULATION/]
	POP	P,T
	JRST QUIT
>
;READ AND CHECK A RIB
;ARGS	T=STR BLOCK NUMBER OF FIRST RIB
;	SKIP RETURN IF OK

RIBCHK:	TLNN	T,RBREAL		; Test if a real rib
	 JRST	[HRR	T3,DOGRRE	; Not a real rib
		 MOVEI	M,[ASCIZ/Real RIB expected/]
		 POPJ	P,]
	PUSHJ	P,PAGRDP		; PAGRDP sets T3
	  JRST	[MOVEI	M,[ASCIZ/Read error for RIB/]
		 POPJ	P,]
	CAME	T,BUF+RIBSLF
	 JRST	[HRR	T3,DOGSLF	; Bad self pointer
	  	 MOVEI	M,[ASCIZ/Bad self pointer/]
		 POPJ	P,]
	MOVEI	T1,CODRIB
	CAME	T1,BUF+RIBCOD		; Check code
	 JRST	[HRR	T3,DOGRCD	; Bad rib code
		 MOVEI	M,[ASCIZ/Bad RIBCOD/]
		 POPJ	P,]
	JRST CPOPJ1	;ALL OK

;DO A COMPLETE CHECK OF A RIB. BLOCK NUMBER IN T

FULRBC:	MOVEI	M,[ASCIZ/Bad data in RIB/]	; SETUP DEFAULT ERROR TEXT
	PUSHJ	P,RIBCHK	;READ AND MAKE PRELIMINARY CHECKS
	  POPJ	P,		;BAD - T3 already setup in RIBCHK
	MOVE	T,ERRNAM(P4)
	MOVE	T1,ERRPPN(P4)
	CAME	T,BUF+RIBNAM
	 JRST	[HRRI  T3,'NAM'	;Name mismatch
		 POPJ  P,]
	CAME	T1,BUF+RIBPPN	;CHECK NAME, EXT AND PPN
	 JRST	[HRRI  T3,'PPN'	;PPN mismatch
		 POPJ  P,]
	HLLZ	T,ERREXT(P4)
	HLLZ	T1,BUF+RIBEXT
	SKIPE	BUF+RIBRIB	;Better be zero to be a prime rib
	 JRST	[HRRI  T3,'RIB'	;Rib mismatch
		 POPJ  P,]
	CAME	T,T1
	 JRST	[HRRI  T3,'EXT'	;Extension mismatch
		 POPJ  P,]
	SETZM	SIZRIB(P4)	;Zero number of logical pointers
	SETZM	ALCRIB(P4)	;Set number of allocated pages
	AOS	ALCRIB(P4)	; to 1 (have to count the RIB itself)
	PUSHJ	P,COPTR		;Copy RIB into SAVRIB(P4)
	PUSHJ	P,SETPTR	;Set up DEVRSU(P4) to point to first ret-tr
	AOS	(P)		;RIB has now been verified
	POPJ	P,
;SUBROUTINE TO COPY POINTERS INTO SAVE RIB SLOT

COPTR:	MOVEI	T,SAVRIB(P4)		;Copy current RIB
	HRLI	T,BUF			; from BUF
	BLT	T,SAVRIB+777(P4)	; to SAVRIB
	POPJ	P,			;(note: spare overwrites prime RIB)

;SUBROUTINE TO SET UP DEVRSU ETC. TO POINT TO STARTING POINT
;OF RIB POINTERS SAVED
;ARG	P4=CORE BLOCK

SETPTR:	MOVE	T,[-RBLVPR,,RIBPFS]	;AOBJN pointer for prime RIB
	SKIPE	SAVRIB+RIBRIB(P4)	;If spare,
	 MOVE	T,[-RBLVSR,,RIBSFS]	;AOBJN pointer for spare RIB
	ADDI	T,SAVRIB(P4)		;Index into SAVRIB
	MOVEM	T,DEVRSU(P4)		;This is addr of next ret-ptr
	SETOM	DEVREL(P4)		;So it will AOS to logical page 0
	POPJ	P,

;SUBROUTINE TO RETURN NEXT POINTER FROM THE RIB
;ARG P4=ADDRESS OF CORE BLOCK
;FAIL RETURN IS TAKEN ONLY IF THE UNIT AND PAGE VALUES IN AN
;OBTAINED PNTR ARE TOO LARGE.
;ALL OTHERS(HOLES, SPARES, REAL IN BOUNDS) TAKE THE SUCCESS
;RETURN, INCLUDING T/0 ON OUT OF PNTRS.

GETPAG:	AOS	DEVREL(P4)		;Logical page within file
	SKIPL	T1,DEVRSU(P4)		;GET T1/ AOBJN PNTR TO RET PNTR.
	 JRST	NOPTR
	MOVE	T,(T1)		;GET T/ POSSIBLE RET PNTR.
	AOBJN	T1,.+1		;INCREMENT THE AOBJN
	MOVEM	T1,DEVRSU(P4)	;PNTR IN DEVRSU.
	JUMPE	T1,NOPTR
	MOVEM	T,NXTPTR(P4)
	TLNN	T,RBREAL
	 JRST	CPOPJ1		;Hole in file - this is ok
	LDB	U,[POINT PTSUNI,T,PTNUNI]
	CAMLE	U,HIGHU
	 JRST	[HRR	T3,DOGUOB	; Unit out of range (GETPAG)
		 POPJ	P,]
	LDB	T1,[POINT PTSPNO,T,PTNPNO]
	HRR	T3,DOGPOB	; Page out of range (GETPAG)
	CAMGE	T1,@PTRPPU
	 AOS	(P)
	POPJ	P,

NOPTR:	MOVEI	T,0
	JRST	CPOPJ1
;CODE TO MARK BITS IN SAT BLOCKS
;RIB PTR IN T1, POINTER TO SAT TABLE IN T

;TEST BIT, SKIP RETURN IF BIT IS OFF

TSTZRO:	LDB	U,[POINT PTSUNI,T1,PTNUNI]
	LDB	T1,[POINT PTSPNO,T1,PTNPNO]
	IDIVI	T1,^D36
	ADD	T1,@T		;NOW HAVE WORD ADDRESS
	MOVE	T,T1		;AND BIT NUMBER IN T2
	MOVNS	T2
	MOVSI	T1,(1B0)
	LSH	T1,(T2)		;NOW HAVE BIT POSITIONED
	TDNN	T1,(T)		;TEST BIT
	 AOS	(P)
	POPJ	P,

;SET BIT 0, SKIP IF BIT WAS A 1

MRKZRO:	PUSHJ	P,TSTZRO
	 AOS	(P)		;BIT WAS A 1, SKIP RETURN
	ANDCAM	T1,(T)		;MAKE SURE BIT IS OFF
	POPJ	P,

;SET BIT 1, SKIP IF BIT WAS A 0

MRKONE:	PUSHJ	P,TSTZRO
	  SKIPA
	 AOS	(P)		;BIT WAS A 0
	IORM	T1,(T)		;MARK IT A 1
	POPJ	P,
;CHECK BAT BLOCKS

CHKBAT:	MOVE U,HIGHU
BATUNI:	MOVE P1,CHRBUF+.CHBA
	PUSHJ P,CKBAT1
	 JRST DOBAT	;THIS BAT BLOCK IS OK
	MOVSS P1	;TRY OTHER ONE
	PUSHJ P,CKBAT1
	 JRST DOBAT	;OK, USE IT
	JRST BATUDN	;BOTH BAD, JUST IGNORE
DOBAT:	MOVEI P1,BUF
	ADD P1,BATFIR(P1)
BATUN1:	SKIPN (P1)	;ZERO AT END OF LIST
	JRST BATUDN	;DONE WITH THIS UNIT
	LDB P2,BAYNBB	;NUMBER BAD (-1) IN THIS REGION
NXTBBK:	MOVE T1,BATELB(P1)
	ADDI T1,(P2)
	CAML T1,@PTRPPU
	JRST BATBK2		;IGNORE BLOCKS TOO HIGH
	DPB U,[POINT PTSUNI,T1,PTNUNI]
	PUSH P,T1
	MOVE T,PTROST
	PUSHJ P,MRKZRO	;MARK IN OUT SAT
	 JRST BATBKD	;WAS MARKED, DO NOT MARK IN DSK SAT IN CASE FREE
	MOVE T1,(P)	;BECAUSE THAT WOULD CAUSE LOST PAGES MSG.
	MOVE T,PTRDST	;IN DISK SAT
	PUSHJ P,MRKZRO
	 JFCL
BATBKD:	POP P,T1
BATBK2:	SOJGE P2,NXTBBK	;DO IT FOR ALL IN THIS REGION
	AOBJP P1,BATUDN	;DONE WHEN RUN OUT OF ROOM
	AOBJN P1,BATUN1	;DO MORE IF MORE THERE (2 WORDS/ENTRY)
BATUDN:	SOJGE U,BATUNI	;TRY NEXT UNIT
	POPJ P,

BAYNBB:	POINT BASNBB,BATNBB(P1),BANNBB	;HERE IS WHERE NUMBER OF BAD BLOCKS IN REGION LIVES

CKBAT1:	HLRZ T1,P1
	PUSHJ P,PAGRED
	 JRST CPOPJ1
	MOVSI T,'BAT'
	MOVEI T1,CODBAT
	CAMN T,BUF+BATNAM	;CHECK CONSISTANCY
	CAME T1,BUF+BATCOD
	JRST CPOPJ1	;NO GOOD
	HLRZ T1,P1
	DPB U,[POINT PTSUNI,T1,PTNUNI]
	TLO T1,RBREAL	;TURN IT INTO A POINTER
	CAME T1,BUF+BATSLF
	AOS (P)
	POPJ P,
;HERE TO GO THROUGH ALL THE CLUSTER IN ORDER IN THE SAT TABLES
;P4 CONTAINS A POINTER TO A DRIVER TABLE
;	(P4) POINTER TO FIRST SAT TABLE (@ BIT ON)
;	1(P4) POINTER TO SECOND SAT TABLE
;	2(P4) NO CLUSTER BAD MESSAGE
;	3(P4) HEADER IF SOME BAD
;	4(P4) TOTAL BAD MESSAGE
;	5(P4) PUSHJ HERE IF ANY BAD
;	7(P4) PUSHJ HERE TO SEE IF BAD RETURNS CPOPJ1 IF IS

CLSSRC:	SETOM COUNT#
	MOVEI U,0
SRNWUN:	MOVE P3,@PTRPPU	;GET NUMBER OF BLOCKS
	MOVE T,U
	IMUL T,STRPPU
	SOS P2,T	;P2 WILL BE CLUSTER NUMBER (AOS'ED BEFORE CHECK)
	HRRZ T3,@(P4)	;FIRST SAT POINTER
	HRRZ T4,@1(P4)	;SECOND SAT POINTER
	SUBI T3,1
	SUBI T4,1	;DECRIMENT SINCE AOS BEFORE USE
SRNWST:	MOVEI T1,1	;START OF SAT, T1 HAS BIT TO TEST
	MOVEI T2,400*^D36
SRNXCL:	ADDI P2,1	;NEXT CLUSTER
	SOJL P3,SRNXUN	;SEE IF OUT OF PAGES ON THIS UNIT
	SOJL T2,SRNXST	;OR POSSIBLY IN THIS SAT
	ROT T1,-1	;MOVE BIT
	JUMPGE T1,SRTST	;IF HIGH ORDER BIT, MUST WANT NEXT WORD
	ADDI T3,1
	ADDI T4,1
SRTST:	PUSHJ P,7(P4)	;TEST
	 JRST SRNXCL	;ALL OK
	MOVE M,3(P4)	;GET READY TO PUT OUT HEADER
	AOSG COUNT
	PUSHJ P,MSG	;FIRST BAD ONE
	MOVE N,P2
	MOVEI T,6
	PUSHJ P,OCTZRO	;PRINT 6 DIGITS WITH LEADING ZEROS
	PUSHJ P,SPC
	PUSHJ P,SPC
	MOVE N,COUNT
	ADDI N,1
	IDIVI N,^D15
	JUMPN N1,SRNXCL	;SEE IF ENOUGH ON THIS LINE
	PUSHJ P,CRLF	;YES
	JRST SRNXCL

SRNXST:	ADDI P3,1
	SOJA P2,SRNWST	;COMPENSATE FOR EXTRA INCS
SRNXUN:	CAMGE U,HIGHU
	AOJA U,SRNWUN	;GO WITH NEXT UNIT
	MOVE M,2(P4)	;GET READY WITH NO ERRORS MESSAGE
	AOSG N,COUNT
	JRST MSG	;THERE WERE NONE
	PUSHJ P,5(P4)	;MARK ERRORS
	MOVE M,4(P4)	;TOTAL ERRORS MESSAGE
	PUSHJ P,MSG
	PUSHJ P,DECPRT
	PUSHJ P,PDOT
	JRST CRLF3	;DONE
;TEST TO SEE IF FILE IS A UFD

ISUFD:	HLRZ T,ERREXT(P4)
	MOVE T1,ERRPPN(P4)
	CAIN T,'UFD'
	CAME T1,[MFDPPN]
	 POPJ P,		;NOT UFD, NON-SKIP RETURN
	JRST CPOPJ1	;IS A UFD


;TEST TO SEE IF CRITICAL FILE DAMAGED

ISCRIT:	MOVSI	T,-SPCLEN
	MOVE	T1,ERRNAM(P4)
	CAME	T1,SPCNAM(T)	;CHECK NAME TABLE
CRIT1:	 AOBJN	T,.-1
	JUMPGE	T,CPOPJ		;NOT ON CRITICAL LIST.
	MOVE	T2,ERRPPN(P4)
	CAME	T2,SPCPPN(T)
	 JRST	CRIT1		;NO MATCH
	HLLZ	T2,ERREXT(P4)
	CAME	T2,SPCEXT(T)
	 JRST	CRIT1
	SKIPE	FIXFLG		;DON'T DIE IF CHECKING MODE
	 JRST	CRTERR
	OUTSTR	[ASCIZ /
Bad RIB detected in critical file
/]
	PJRST	RIBERR		;Output file name to LST:
;CHECK SAT FOR EXTRA (UNUSED) BITS NOT MARKED. IF FIXING,
;MARK EXTRA BITS IN OUR SAT

CHKSAT:	MOVE	U,HIGHU		;NOW CHECK FOR EXTRA SAT BITS
	MOVE	P1,PTRDST
	SKIPE	FIXFLG
	 MOVE	P1,PTROST	;FOR FIXING
CKBUNI:	MOVE	T,@PTRPPU	;GET NUMBER OF PAGES
	IDIVI	T,400*^D36	;NUMBER OF BITS/PAGE
	HLRZ	T4,@PTRDST		;GET EXPECTED NUMBER
	JUMPE	T1,[CAME T,T4	  ;EVEN NUMBER OF SATS
		     JRST BADNST  ;DOES NOT COMPARE
		    JRST NXTST2]
	CAIE	T4,1(T)		;DO NUMBERS MATCH
	 JRST	BADNST		;NO
	IMULI	T,400		;WORDS IN FULL SATS
	ADD	T,@P1		;LOCATION
	MOVE	T4,T		;SAVE IT. FIRST WORD OF LAST SAT
	MOVE	T,T1
	IDIVI	T,^D36		;FULL WORDS IN LAST SAT
	ADD	T4,T
	MOVEI	T3,400
	SUB	T3,T		;THE NUMBER OF WORDS NOT FULL
	SETO	T,
	MOVNS	T1
	LSH	T,(T1)		;T NOW HAS 1 BITS WHERE SAT SHOULD HAVE 0'S
	MOVEI	N,0		;ERROR FLAG
	TDNE	T,(T4)
	 MOVEI	N,1		;SET ERROR FLAG
	ANDCAM	T,(T4)		;SET CORE BITS
CHKST2:	SOJLE	T3,NXTSAT	;ARE WE DONE?
	SKIPE	1(T4)		;NO REST SHOULD BE ALL ZERO
	 MOVEI	N,1
	SETZM	1(T4)
	AOJA	T4,CHKST2
NXTSAT:	SKIPN	FIXFLG		;NO ERROR MESSAGE IF FIXING
	JUMPN	N,BADSAT
NXTST2:	SOJGE	U,CKBUNI
	POPJ	P,		;FINISHED ALL SATS

BADSAT:	ERRLEV (LEVBAD)
	MOVEI M,[ASCIZ /EXTRA BITS IN SAT NOT MARKED UNIT /]
	PUSHJ P,MSG
	MOVE N,U
	PUSHJ P,DECPRT
	PUSHJ P,CRLF
	JRST NXTST2

BADNST:	MOVEI M,[ASCIZ /
WRONG NUMBER OF SATS/]
	JRST FATERR
;SET UP AN ERROR LIST POINTER. FIRST WORD POINTS TO CHAIN
;SECOND TO END OF CHAIN FOR ADDING AT END
;POINTER TO BLOCK IN T

SETFIX:	MOVEM T,1(T)
	SETZM (T)
	POPJ P,

;ADD SOMETHING TO END OF CHAIN
;ADD A 4 WORD BLOCK
;	WORD 0 LH. IS LINK. RH IS ADDRESS CALLED FROM
;		WILL GO TO ADDRESS CALLED FROM+1 TO FIX
;	WORD 1 IS BLOCK NUMBER
;	WORDS 2 AND 3 ARE ROUTINE DEPENDENT ARGS

ADDFIX:	PUSH	P,T3
	MOVEI	T3,4
	ADDB	T3,FREPTR	;GET SPACE
	PUSH	P,T		;SAVE T
	MOVE	T,T3		;
	PUSHJ	P,GETCOR	;
	  POP	P,T		;
	MOVE	T3,FREPTR
	SUBI	T3,4
	POP	P,3(T3)
	MOVEM	T2,2(T3)
	MOVEM	T1,1(T3)	;BLOCK NUMBER
	HRRZ	T1,(P)		;LINK IS ALWAYS 0
	MOVE	T2,1(T)		;T POINTS TO CHAIN BLOCK
	MOVEM	T1,(T3)		;SAVE ADDRESS
	HRLM	T3,(T2)		;LINK ON END
	MOVEM	T3,1(T)		;AND SET NEW END
	POPJ	P,

ADDTOT:	SKIPN T1,(T)	;ANYTHING TO ADD?
	POPJ P,		;NO
	HLLM T1,@FIXPTR+1	;ADD TO END OF MASTER CHAIN
	MOVE T1,1(T)
	MOVEM T1,FIXPTR+1	;RESET END
	POPJ P,
SUBTTL	PAGE HOLE DATA

DEBPAG:	BLOCK	1		; NonZero page to look for
DEBIDX:	BLOCK	1		; Index to word
DEBRSN:	BLOCK	1		; Reason for punching hole
DEBPTR:	BLOCK	1		; Bad pointer
DEBNXT:	BLOCK	1		; Copy of bad ptr from block
DEBRIB:	BLOCK	1		; Contents of BUF+RIBSLF

DOGMFD:	SIXBIT	/  MXXX/	; MFD operation
DOGUFD:	SIXBIT	/  UXXX/	; UFD scan
DOGFIL:	SIXBIT	/  FXXX/	; File scan
DOGSPA:	SIXBIT	/  SXXX/	; Spare rib scan

DOGNAM:	SIXBIT	/   DOG/	; Old Dogs never die
DOGONE:	EXP	      1		; DSKCLN version 36 punches "hole in 1"
DOGBPP:	SIXBIT	/   BPP/	; Bad Prime Pointer in Spare
DOGBUP:	SIXBIT	/   BUP/	; Bad Up Pointer (in spare?)
DOGHRE:	SIXBIT	/   HRE/	; Hard read error
DOGMUP:	SIXBIT	/   MUP/	; Multiply used page
DOGNHM:	SIXBIT	/   NHM/	; No hash match
DOGPOB:	SIXBIT	/   POB/	; Page out of range (GETPAG)
DOGPOR:	SIXBIT	/   POR/	; Page out of range (RIBCHK)
DOGRCD:	SIXBIT	/   RCD/	; Bad Rib CoDe
DOGRRE:	SIXBIT	/   RRE/	; Real rib expected
DOGSLF:	SIXBIT	/   SLF/	; Self pointer does not match
DOGSNV:	SIXBIT	/   SNV/	; Spare rib not valid here
DOGUOB:	SIXBIT	/   UOB/	; Unit out of range (GETPAG)
DOGUOR:	SIXBIT	/   UOR/	; Unit out of range (RIBCHK)
DOGWHC:	SIXBIT	/   WHC/	; Wrong hash code
DOGXXX:	SIXBIT	/   XXX/	; Error code not setup
    DOGLEN==.-DOGNAM


RCVBUF:	BLOCK 406	;RESERVED SPACE FOR RECOV.SYS BUFFERS.

UPRBND:	Z		;HAS ADDR OF HIGHEST ADDRESSABLE WORD
			;OF CORE.

	VAR		;ARRAY and # variables
LITS:	LIT
	END STPT
   g 
V