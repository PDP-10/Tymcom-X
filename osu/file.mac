	TITLE	DAF	DIRECT ACCESS FILE SUBROUTINES
	SUBTTL	V32/15	02-JAN-73	DGROW BUGS/DLH


;FROM V32/14	04-DEC-72	REC LEN=127/DLH
;FROM V30/04	02-FEB-72	USER NAME PATCH	/DLH


;DGROW ROUTINE BY R. SCOTT MAR 1,1971
	ENTRY DGROW
	ENTRY	DOPEN,DOPENB,DREAD,DWRITE,DCLOSE,DDEL
	EXTERN	NAMPPN
;FOLLOWING IS DISPLACEMENT DEFINITION BLOCK FOR ALL DIRECT
;ACCESS I/O
;IN TRUTH, THESE ARE DISPLACEMENTS FROM AC 'A'
FILE=0	;SIXBIT FILENAME
EXT=FILE+1	;SIXBIT EXTENSION, ERROR FLAG
PDT=EXT+1	;PROTECTION,DAY,TIME
USER=PDT+1	;USER NUMBER UNDER WHICH FILE IS TO BE FOUND
FLGLRL=USER+1	;FLAGS,LOGICAL RECORD LENGTH
MXNREC=FLGLRL+1	;MAX # RECORDS (SPECIFIED AT INITIALIZATION TIME)
CBN=MXNREC+1	;CURRENT RELATIVE PHYSICAL BLOCK NUMBER
PPLRP=CBN+1	;PUT PHYSICAL/LOGICAL RECORD POINTER
BLKL=PPLRP+1	;LENGTH OF USEABLE DATA AREA
XOPEN=BLKL+1	;XCT OPEN UUO
XLOOK=XOPEN+1	;XCT LOOKUP UUO
XENTER=XLOOK+1	;XCT ENTER UUO
XINPUT=XENTER+1	;XCT INPUT UUO
XINA=XINPUT+1	;ADDRESS WORD FOR INPUT ABOVE
XINB=XINA+1	;CHAIN STOPPER WORD FOR INPUT ABOVE
XOTPUT=XINB+1	;XCT OUTPUT UUO
XOUTA=XOTPUT+1	;ADDRESS WORD FOR OUTPUT ABOVE
XOUTB=XOUTA+1	;CHAIN STOPPER WORD FOR OUTPUT ABOVE
XUSETI=XOUTB+1	;XCT USETI UUO
XUSETO=XUSETI+1	;XCT USETO UUO
XGTSTS=XUSETO+1	;XCT GETSTS UUO
XCLOSE=XGTSTS+1	;XCT CLOSE UUO
XOPNCB=XCLOSE+1	;OPEN CONTROL BLOCK FOR XOPEN ABOVE
BUFL=XOPNCB+3	;BUFFER LENGTH WORD FOR MONITOR
BUFFER=BUFL+1	;DATA BUFFER
BLKEND=BUFFER+200	;LENGTH OF DATA SET SOFTWARE CONTROL BLOCK
;DATA SET REFERENCE NUMBER TABLE
;LH:
;BIT 0	0=UNOPENED
;	1=SUCCESSFULLY OPENED
;    1	0=NO WRITE IS PENDING
;	1=WRITE IS PENDING
;    2	0=CURRENT RECORD IS DEFINED
;	1=CURRENT RECORD IS UNDEFINED
DSRNTB:	REPEAT	20,<0>	;GENERATE ADDRESS TABLE OF
;DATA SET CONTROL BLOCKS

CHANTB:	REPEAT	20,<0>	;CHANNEL ALLOCATION TABLE



JOBFF=121	;NATURALLY
JOBREL=44	;DITTO

SAVE:	BLOCK	20	;AC SAVE AREA
STACK:	BLOCK	20	;PUSH/POP STACK

;ACCUMULUMULATOR EQUATES
Z=0	;GENERAL WORK, AND ONE WORD PASS REGISTER
A=1	;CONTAINS ADDRESS OF ACTUAL DATA SET CONTROL BLOCK
B=2	;CONTAINS DSRN (IS INDEX TO DSRNTB TO GET 'A')
C=3	;NO COMMENT
D=4
E=5
F=6
G=7
H=10
I=11	;HOLDS MODE DURING OPEN
J=12
K=13
L=14
M=15	;WILL CONTAIN NEXT RECORD NUMBER FOR USETI/USETO
P=16	;POINTS TO PARAMETER LIST FROM CALLER
S=17	;POINTS TO PUSH/POP STACK
T=8	;DELETE INDICATOR


	DEFINE	ERROR(N)
<	MOVEI	Z,^D'N
	JRST	ERSET>


	DEFINE	IMPER(N)
<	HRROI	Z,-^D'N
	JRST	ERSET>



PATCH:	REPEAT	10,<0>	;PATCH AREA
MODEL:	OPEN	0,XOPNCB(A)	;I AM THE MODEL BLT ED INTO
				;THE SOFTWARE DATA SET CONTROL BLOCK
	LOOKUP	0,FILE(A)
	ENTER	0,FILE(A)
	INPUT	0,XINA(A)
	0
	0
	OUTPUT	0,XOUTA(A)
	0
	0
	USETI	0,0(M)	;NEXT RECORD NUMBER IS IN 'M'
	USETO	0,0(M)	;DITTO
	GETSTS	0,F	;PLUNK STATUS INTO F
	CLOSE	0,
;END OF MODEL

;*************USER PATCH****02-FEB-72****V30/04************************
DPBFLG:	BLOCK	1
NAME:	BLOCK	3
JMPCON:	JUMP	5,0
IPPN:	BLOCK	1
IER:	BLOCK	1
;**********END OF USER PATCH********************************
XENTCB:	0,4		;***CONTROL BLOCK FOR EXTENDED ENTER
	0		;***USER NUMBER
	0		;***FILE NAME
	0		;***FILE EXT
	0		;***PROT,TIME,DATE
XEENTR:	ENTER	0,XENTCB	;***XCT INSTR FOR EXTENDED ENTER
SAVBUF:	0
	0
	0
	0

BPMODE:	POINT	2,FLGLRL(A),1	;MODE BYTE POINTER
BPCHAN:	POINT	4,FLGLRL(A),5	;CHANNEL
BPLRC1:	POINT	10,L,14	;POINTER FOR LRECL
BPLRC2:	POINT	10,-1(C),14	;DITTO
BPNRC1:	POINT	21,-1(C),35	;POINTER FOR RECORD NUMBER



;LOGICAL RECORD CONTROL WORD
;
;BIT 0	0=RECORD IS UNDEFINED
;	1=RECORD HAS BEEN WRITTEN
;  1-4	UNUSED
; 5-14	LRECL
;15-35	# WORDS / LOGICAL RECORD


;MODE SETTINGS ALLOWED:
;	00	INITIALIZATION
;	01	READ ONLY
;	10	WRITE ONLY	HIDDEN READ IS IMPLICIT
;	11	READ AND WRITE (UPDATE)


;CALL DGROW(DSRN,ERR,NEWSIZ,IARRAY)
;WHERE THE FILE IS OPEN,MODE 3, AND NEWSIZ IS THE NO. OF RECORDS
;IT IS DESIRED THAT THE FILE GROW TO.



GFLAG:	0

DGROW:	0
	MOVEM 17,SAVE+17
	MOVEI 17,SAVE
	BLT 17,SAVE+16
	MOVEI 17,STACK
	SETZ T,
	PUSHJ S,DSRNTS
	LDB I,BPMODE
	TRNN I,2
	JRST ERWRT
	TLNE A,200000
	PUSHJ S,WRITE
	SETZM CBN(A)
	MOVE H,@2(P)
	EXCH H,MXNREC(A)
	MOVEM H,@2(P)
;***********DGROW PATCH****02-JAN-73****V32/15**********************
	MOVE	Z,FILE(A)		;SET UP SAVBUF AREA FOR WIPOUT
	MOVEM	Z,SAVBUF
	MOVE	Z,FILE+1(A)
	MOVEM	Z,SAVBUF+1
	SETZM	SAVBUF+2
	SETZM	SAVBUF+3
	SETZM	USER(A)
;************END OF PATCH**********************************************
	SETOM GFLAG
	PUSHJ S,NINITL
	MOVE H,MXNREC(A)
	MOVEM H,@2(P)
	MOVEI Z,1
	JRST RETURN-1



	
AGAIN:	MOVEI T,1	;DELETE SWITCH
	AOS H,@2(P)	;OLD MAX REC+1 IS NOW TREATED AS ASSOC VAR
			;FOR DELETE SEQUENCE
	PUSHJ S,DRED1	;GET THE DESIRED RECORD IN CORE
	PUSHJ S,DWRT5	;AND SET THE DELETE CODE IN AND WRITE IT
	TLZ A,100000
	MOVEM A,DSRNTB(B)
	CAMGE H,MXNREC(A)	;AND KEEP THIS UP UNTIL THE LAST
			;RECORD HAS HAD ITS DELETE CODE SET
	JRST AGAIN	;SET ANOTHER
	JRST DDEL1	;ALL DONE,EXIT

;*********USER PATCH****02-FEB-72****V30/04***************************
TWOWRD:	PUSH	S,P
	MOVE	C,4(16)		;GET ADDRESS OF USER NAME
	MOVE	Z,(C)		;PICK UP FIRST WORD OF NAME
	MOVEM	Z,NAME
	MOVE	Z,1(C)		;PICK UP SECOND WORD OF NAME
	MOVEM	Z,NAME+1
	SETZM	NAME+2
	HLL	Z,JMPCON	;SET UP LEFT HALF OF ARG
	HRRI	Z,NAME		;SET UP RIGHT HALF
	MOVEM	Z,PPNCAL+1
	JRST	PPNCAL		;RETURN

;CALL DOPENB (DSRN,ERR,ASSOC,'FILE.EXT',USER,MODE,NREC,RLEN)
DOPENB:	0	;FORTRAN NONREENTRANCY WORD
	SETOM	DPBFLG		;FLAG FOR 1-12 CHAR USER NAME
	JRST	DOPEN+1
DOPEN:	0
	SETZM	DPBFLG		;6-10 CHAR NAME (COMPATIBLE WITH OLD FORMAT
;**********END OF USER PATCH***************************************
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	S,STACK
	MOVE	B,@0(P)	;PICK UP DSRN
	CAILE	B,0	;INSURE IT IS IN THE PROPER RANGE
	CAILE	B,17
	JRST	ERDSRN	;DSRN IS NOGOOD
	SKIPE	A,DSRNTB(B)	;ADDRESS OF CB
	JRST	DOPEN1	;ALREADY EXISTS
	MOVE	Z,JOBFF
	MOVEI	A,BLKEND	;GET A END OF REQUIRED CORE
	ADDB	A,Z	;TOGETHERNESS
	CAMG	A,JOBREL	;STILL WITHIN MY AREA
	JRST	.+4
	TRO	Z,1777	;ROUND UP TO NEXT 1K
	CALLI	Z,11	;CORE UUO
	JRST	ERCORE	;NONE TO BE HAD
	EXCH	A,JOBFF	;GOT IT, SET ADDRESS IN JOBFF
	MOVEM	A,DSRNTB(B)	;AND DATA SET REFERENCE TABLE
DOPEN1:	TLNE	A,400000	;SEE IF ALREADY OPEN
	JRST	EROPEN	;JRST IF YEP
	SETZM	,FILE(A)	;PREPARE TO CLEAR BLOCK
	HRLI	C,FILE(A)
	HRRI	C,FILE+1(A)
	MOVEI	D,BLKEND(A)
	BLT	C,@D	;ZAP
	HRRZ	C,3(P)	;SIXBITIZE FILE NAME
	SUBI	C,1	;SUB 1 FROM C TO ENABLE ILDB
	MOVE	D,[POINT 7,0(C),35]	;ASCII FILE NAME POINTER
	MOVE	E,[POINT 6,FILE(A),35]	;SIXBIT F N
	SUBI	A,1	;BACK UP A TO ENABLE ILDB BEOLW TO WORK
DOPEN4:	ILDB	Z,D	;GET AN ASCII CHARACTER
	TRZ	Z,40	;COMMENCE TO SIXBITIZE IT
	CAIL	Z,100
	SUBI	Z,40
	JUMPE	Z,DOPEN2	;JUMP TO FILE.EXT DONE
	CAIN	Z,16	;IS IT SIXBIT '.'
	JRST	DOPEN3	;JUMP TO FILE DONE, DO EXT YET
	IDPB	Z,E	;SAVE SIXBIT CHARACTER
	TLNE	E,770000	;HAVE SIX YET?
	JRST	DOPEN4	;LOOP BACK FOR NEXT CHARACTER
	ILDB	Z,D	;ALREADY HAVE SIX,PASS TILL . OR NULL
			;OR BLANK
	JUMPE	Z,DOPEN2	;JUMP TO FILE.EXT DONE
	CAIN	Z,40	;SKI@ IF NOT BLANK
	JRST	DOPEN2	;JUMP TO FILE.EXT DONE
	CAIE	Z,56	;IS IT ASCII "."
	JRST	.-5	;LOOP BACK TO PASS MORE
DOPEN3:	MOVE	E,[POINT 6,EXT(A),35]	;EXT BYTE POINTER
;NOTE: AC 'A' IS 1 LESS TO MAKE ILDB TO WORK
	ILDB	Z,D	;GET NEXT ASCII CHARACTER
	TRZ	Z,40
	CAIL	Z,100	;SIXBITIZING IT AGAIN
	SUBI	Z,40
	JUMPE	Z,DOPEN2	;ALL DONE
	IDPB	Z,E	;PUT IT INTO EXT SLOT
	JRST	DOPEN3+1
DOPEN2:	ADDI	A,1	;GET A BACK TO REAL ADDRESS
	HRRM	Z,EXT(A)	;INSURE SECOND HALF WORD IS ZERO
	MOVE	Z,@4(P)	;MOVE USER NUMBER INTO PLACE
	JUMPE	Z,DOPE2A	;*****PATCH FOR ASCII USER NUMBERS - 17-JAN-72
	SKIPN	DPBFLG		;WHICH FORM OF USER NAME?
	JRST	TWOWRD		;6-10 CHAR
	PUSH	S,P		;SAVE AC
	MOVE	C,4(P)
	MOVEM	C,PPNCAL+1	;PICK UP USER NAME ARG
PPNCAL:	JSA	P,NAMPPN	;COVERT NAME TO PPN
	0
	JUMP	4,IPPN
	JUMP	0,IER
	POP	S,P		;RESTORE AC
	MOVE	C,IER		;PICK UP ERROR INDICATOR
	JUMPE	C,DOPE2B	;SUCCESSFIL?
	CAIN	C,1		;NO
	JRST	NOCHAN
	JRST	NOPEN
DOPE2B:	MOVE	Z,IPPN
	JRST	.+3	;***** END OF PATCH***
DOPE2A:	CALLI	Z,24	;GET MY USER NUMBER
	JRST	.+1	;IN CASE IT DONT WORK
	MOVEM	Z,USER(A)
	MOVE	I,@5(P)	;MODE
	CAIL	I,0
	CAILE	I,3
	JRST	ERMODE	;MODE WAS NOT 0,1,2,3
	DPB	I,BPMODE	;STICK IT IN
	DPB	B,BPCHAN	;SAVE DSRN IN FLAG WORD
	JUMPN	I,.+10	;JUMP AROUND IF NOT INITIALIZATION PHASE
	MOVE	Z,@6(P)	;GET AND SAVE NREC
	MOVEM	Z,MXNREC(A)
	MOVE	Z,@7(P)	;AND LOGICAL RECORD LENGTH
	CAIL	Z,1	;TEST TO INSURE LRECL IS IN ACCEPTABLE RANGE
	CAILE	Z,^D1023
	JRST	ERLRCL	;NO IT ISNT
	HRRM	Z,FLGLRL(A)
;NOW LETS MOVE MODEL INTO POSITION
	HRLI	C,MODEL	;BUILD A BLT WORD
	HRRI	C,XOPEN(A)
	HRRZI	D,XCLOSE(A)	;ENDING ADDRESS
	BLT	C,@D	;ZAP MODEL INTO PLACE
	MOVEI	D,17	;COMPUTE NEXT FREE CHANNEL NUMBER
	SKIPE	C,CHANTB(D)	;PICK UP AND TEST CHANNEL ALLOC TABLE
	SOJG	D,.-1	;LOOP BACK IF NOT FREE
	JUMPE	D,NOCHAN	;NO CHANNEL IS AVAILABLE
	MOVE	Z,D
	MOVEM	B,CHANTB(D)	;MARK IT IN USE
	MOVE	C,[POINT 4,0(D),12]	;POINTER FOR CAHNNEL #
	HRRI	C,XOPEN(A)	;SET UP ALL THE CHANNEL NUMBERS
	MOVEI	D,XCLOSE-XOPEN	;NUMBER TO BE MOVED
	DPB	Z,C	;PUT CHANNEL NUMBER IN
	SOJGE	D,.-1	;LOOP TILL DONE
	DPB	Z,[POINT 4,XEENTR,12]	;***INSERT CHAN IN EXT. ENTER
	DPB	Z,BPCHAN	;POINT SOFT DSCB TO RIGHT CHANNEL
	SETZM	,XOUTB(A)	;CLEAR THE CHAIN STOPPER WORDS
	SETZM	,XINB(A)
	HRRZI	Z,200	;CONSTRUCT BUFFER LENGTH WORD
	MOVEM	Z,BUFL(A)
	MOVEM	Z,BLKL(A)	;SET UP BLOCK LENGTH
	HRLI	Z,-200	;BUILD FIRST IN AND OUT WORDS
	HRRI	Z,BUFFER-1(A)
	MOVEM	Z,XINA(A)
	MOVEM	Z,XOUTA(A)
	MOVEI	Z,17	;DUMP MODE
	MOVEM	Z,XOPNCB(A)	;INTO OPEN CONTROL BLOCK
	MOVSI	Z,(SIXBIT /DSK/)	;DEVICE IN
	MOVEM	Z,XOPNCB+1(A)
	HRLI	Z,FILE(A)
	HRRI	Z,SAVBUF
	BLT	Z,SAVBUF+3
	XCT	XOPEN(A)	;DO THE OPEN
	JRST	NOPEN	;IT DIDNT
	XCT	XLOOK(A)	;DO THE LOOKUP
	JRST	NLOOK1	;IT DIDNT
	JUMPE	I,ERINIT	;ATTEMPT TO INIT AN EXISTING FILE
	CAIN	I,1	;SKIP IF OUT OR IN/OUT
	JRST	RTG	;***IN, GO READ DSCB TO BUILD MXNREC,FLGLRL
ENTR1:	MOVE	Z,SAVBUF	;***GET FILE NAME
	MOVEM	Z,XENTCB+2	;***SAVE FOR EXTENDED ENTER
	MOVE	Z,SAVBUF+1	;***GET FILE EXT
	MOVEM	Z,XENTCB+3	;***
	MOVE	Z,SAVBUF+3	;***GET USER NUMBER
	MOVEM	Z,XENTCB+1	;***
	HLLZ	Z,PDT(A)	;***GET PROTECTION
	SETZ	D,		;***ZERO TIME IN MIN
	DPB	D,[POINT 11,Z,23]	;***MISH PROT,TIME,DATE
	MOVEM	Z,XENTCB+4	;***
	XCT	XEENTR		;***EXECUTE ENTER
	JRST	ERNAFL	;IT DIDNT WORK
RTG:	TLO	A,400000	;MARK IT OPEN
	MOVEM	A,DSRNTB(B)
	SKIPN	,I	;SKIP IF NOT INITIALIZATION PHASE
	PUSHJ	S,NINITL
NRDSCB:	PUSHJ	S,RDSCB	;READ DSCB AND BUILD MXNREC AND LRECL
	MOVEI	Z,1	;MARK SUCCESSFUL OPEN
	MOVEM	Z,@2(P)	;ASSOC VARIABLE
	MOVEM	Z,@1(P)	;ERROR CODE (NO ERROR)
RETURN:	MOVSI	17,SAVE
	BLT	17,17
	JRA	16,2(16)	;SHORTEST PARAM LIST HAS 2 ENTRIES
NLOOK1:	JUMPE	I,ENTR1	;IS A LEGITIMATE INITIALIZATION
	JRST	ERNOFL	;LOOKUP FAIL ON INPUT FILE



NINITL:	SKIPE	M,CBN(A)	;GET CBN AND HOPE ITS ZERO
	JRST	ERINIT	;NONZERO, ATTEMPT TO INIT OLD DATASET
	AOS	,CBN(A)	;MAKE IT A 1
	MOVE	K,MXNREC(A)	;GET # LOGICAL RECORDS
	HRRZ	Z,FLGLRL(A)	;CLEAR CARRY BITS AND PICK UP LRECL
	SETZ	L,
	DPB	Z,BPLRC1	;PUT LRECL IN
	TLO	L,400000	;INDICATE UNDEFINED RECORD
	MOVEI	J,1	;INIT LOGICAL RECORD NUMBER
	HRRZI	C,BUFFER(A)	;BUFFER POINTER
	HRRZI	D,BLKEND-1(A)	;END OF BUFFER POINTER
	MOVE	Z,[40000000002]	;2 WORDS OF DAF INFO
	MOVEM	Z,0(C)	;CREATE FIRST DATA RECORD
	MOVEM	K,1(C)	;MXNREC IN
	HRRZ	Z,FLGLRL(A)	;INIT LRECL WORD
	HRRZM	Z,2(C)	;LRECL IN
	ADDI	C,3	;UP POINTER PAST PRIMING WORDS
	SETZM	,0(C)	;CLEAR OUT NEXT WORD
	CAMGE	C,D	;CHECK FOR END OF BUFFER
	AOJA	C,.-2	;LOOP BACK IF NOT
INIT8:	HRRZ	G,FLGLRL(A)	;ESTABLISH LRECL WORD COUNTER
	DPB	G,BPLRC1	;PUT IT INTO LRECL AREA
	SKIPGE GFLAG
	JRST GRINIT
INIT5:	PUSHJ	S,WRITER	;OUTPUT THE RECORD
INIT9:	AOS	,CBN(A)	;UP RECORD POINTER
	MOVEI	C,BUFFER(A)	;RESET BUFFER ADDRESS
INIT1:	MOVEM	L,0(C)	;PUT THE CONTROL WORD IN
	IORM	J,0(C)	;AND THE RECORD NUMBER
	ADDI	C,1	;UP DATA POINTER
	CAMLE	C,D	;TEST FOR END OF BUFFER
	JRST	INIT4	;HAVE REACHED END
INIT3:	SETZM	,0(C)	;CLEAR NEXT WORD
	CAML	C,D	;TEST POSITION IN BUFFER AGAIN
	JRST	INIT6	;OUT OF ROOM
	ADDI	C,1	;STILL ROOM, UP POINTER
	SOJG	G,.-4	;MORE LRECL WORDS, YES=JUMP
	HRRZ	G,FLGLRL(A)	;SET LRECL AGAIN
	DPB	G,BPLRC1
	ADDI	J,1	;UP LRECL NUMBER
	SOJG	K,INIT1	;JUMP IF STILL MORE LRECLS TO DO
	SETOM	,0(C)	;CLEAR OUT THE REST OF THE BUFFER
	CAMGE	C,D	;SPIN TILL BUFFER HAS BEEN CLEARED
	AOJA	C,.-2
INIT7:				;**V32/14**
	PUSHJ	S,WRITER	;GO WRITE OUT THE RECORD
	PUSHJ	S,CLOSE	;DO A CLOSE
	PUSHJ	S,WIPOUT
	XCT	XOPEN(A)	;OPEN IT AGAIN
	JRST	IMP3	;THIS CANNOT HAPPEN
	XCT	XLOOK(A)	;DO THE LOOKUP
	JRST	IMP3	;IMPOSSIBLE
	PUSHJ	S,WIPOUT
	XCT	XENTER(A)	;DO THE ENTER
	JRST	IMP3
	MOVEI	Z,2	;SET MODE TO WRITE ONLY
	AOSE GFLAG
	DPB	Z,BPMODE
	POPJ	S,0	;GO BACK TO CALLER


INIT6:	SOJG	G,INIT4
	HRRZ	G,FLGLRL(A)	;RESET LRECL
	DPB	G,BPLRC1
	ADDI	J,1	;UP RECORD NUMBER
	SOJLE	K,INIT7		;**V32/14**
	JRST	INIT5	;CONTINUE
INIT4:	PUSHJ	S,WRITER	;WRITE IT OUT
	MOVEI	C,BUFFER(A)	;POINT IT AGAIN
	AOS	,CBN(A)	;UP RECORD BLOCK NUMBER
	JRST	INIT3
WIPOUT:	HRLI	Z,SAVBUF	;CLEAR WORDS FOR LOOKUP AND ENTER
	HRRI	Z,FILE(A)
	BLT	Z,USER(A)
	POPJ	S,


GRINIT:	MOVE K,MXNREC(A)
	SUB K,H
	MOVEI J,1(H)
	PUSHJ S,WRITE
	AOS @2(P)
	PUSHJ S,PRCMPT
	MOVEM M,CBN(A)
	CAIE D,0
	PUSHJ S,READ
	MOVEI C,BUFFER(A)
	ADD C,D
	MOVEI D,BLKEND-1(A)
	JRST INIT1



CLWRT:
WRITE:
WRITER:	SKIPN	M,CBN(A)	;BETTER SKIP
	JRST	ZERCBN
	XCT	XUSETO(A)	;SET AN OUTPUT RECORD NUMBER
	XCT	XOTPUT(A)	;OUTPUT A RECORD
	XCT	XGTSTS(A)	;GET RESULTANT STATUS
	TRNE	F,760000	;SKIP IF CLEAN
	JRST	EROUT
	MOVEI	C,BUFFER(A)	;PREPARE TO RESET BUFFER POINTER
	TLZ	A,200000	;CLEAR WRITE PENDING BIT
	POPJ	S,


DSRNTS:	MOVE	B,@0(P)	;PICK UP DSRN
	CAILE	B,0	;TEST FOR OK
	CAILE	B,17
	JRST	ERDSRN	;JRST	FI NO GOOD
	MOVE	A,DSRNTB(B)	;GET CONTROL BLOCK ADDRESS
	JUMPE	A,ERNODS
	TLNN	A,400000	;SEE IF IT WAS SUCESSFULLY OPENED
	JRST	ERNODS
	POPJ	S,	;GO BACK


PRCMPT:	SKIPN	C,@2(P)	;GET AND TEST ASSOC VARIABLE
	JRST	ERASOC	;BETTER NOT COME HERE
	CAMLE	C,MXNREC(A)	;SEE IF SMALL ENUF
	JRST	ERASOC	;NOPE
	SUBI	C,1
	HRRZ	E,FLGLRL(A)
	ADDI	E,1
	IMUL	C,E
	IDIV	C,BLKL(A)	;DIVIDE BY PHYSICAL SIZE
	MOVEI	M,2(C)	;AND ADD 2 FOR CONTROL INFO
;M CONTAINS BLOCK NUMBER FOR NEXT BLOCK
;D CONTAINS DISPLACEMENT INTO THE BLOCK FOR THE CONTROL WORD
	POPJ	S,0	;RETURN


; CBN=((ASSOC-1)*(RLEN+1)/BLKSIZ)+2

;CALL DREAD (DSRN,ERR,ASSOC,ARRAY)
DREAD:	0	;FORTRANS NONREENTRANT WORD
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	S,STACK
	SETZ 	T,
	PUSHJ	S,DSRNTS	;GO DO DSRN TESTS
	LDB	I,BPMODE	;INSURE READ IS ALLOWED
	TRNN	I,1	;READ BIT
	JRST	ERRED	;NOPE, TAINT
DRED1:	PUSHJ	S,PRCMPT	;DSRN OK, GO TO COMPUTE RELATIVE BLOCK NUMMER
	HRRZ	K,FLGLRL(A)	;SET LRECL
	HRRZ	L,3(P)	;ARRAY ADDRESS
	CAMN	M,CBN(A)	;ARE WE ALREADY THERE?
	JRST	RDRD1+1	;DONT DO THE READ
RDRD2:	TLNN	A,200000	;TEST WRITE PENDING BIT
	JRST	RDRD1	;NO, NO WRITE IS NECESSARY
	PUSH	S,M	;SAVE THE LREC NUMBER
	PUSHJ	S,WRITE	;WRITE OUT THE CURRENT RECORD
	POP	S,M	;RETRIEVE THE NEXT RECORD NUMBER
RDRD1:	PUSHJ	S,READ	;DO THE READ
	MOVEI	C,BUFFER(A)	;SET UP POINTERS
	ADDI	C,1(D)	;TO ACTUAL DATA
RDHAVR:	MOVE	Z,-1(C)	;THIS IS THE RITE RECORD
	TRNE	T,000001  ; DELETING AT THIS POINT
	TLO	A,100000  ; MAKE UNDEFINED
	TLNE	Z,400000	;SEE IF RECORD WAS DEFINED
	TLO	A,100000	;TURN ON THE RECORD UNDEFINED BIT
	MOVEI	J,BLKEND(A)	;STOPPER
RDHAV2:	CAML	C,J	;SEE IF STILL WITHIN BUFFER
	JRST	RDSPAN
	MOVE	Z,0(C)	;PICK UP A DATA WORD
	MOVEM	Z,0(L)	;AND PUT IT INTO THE USERS ARRAY!
	ADDI	C,1	;UP THE TWO POINTERS
	ADDI	L,1
	SOJG	K,.-6	;LOOP AROUND TILL DONE
RDHAV1:	TRNE	T,000001 ;  DELETING NOW
	POPJ	S,0	 ; RETURN
	AOS	@2(P)	;UP L REC N
	MOVEI	Z,1
	MOVEM	Z,@1(P)	;ERROR CODE = NO ERROR
	TLZE	A,100000	;TEST THE RECORD UNDEFINED BIT
	JRST	ERRDUN	;JRST IF ON(RECORD WAS UNDEFINED, BUT MOVED
	JRST	RETURN

RDSPAN:	JUMPE	K,RDHAV1	;JUMP IF REALLY DONE
	SETZ	D,	;CLEAR DISPLACEMENT
	TLNN	A,200000	;IS A WRITE PENDING?
	JRST	.+4	;NOPE
	PUSH	S,M	;SAVE BLOCK NUMBER
	PUSHJ	S,WRITER	;WRITE OUT THE CURRENT RECORD
	POP	S,M	;RESTORE BLOCK NUMBER
	ADDI	M,1	;UP BLOCK NUMBER
	PUSHJ	S,READ	;GO READ THE NEXT RECORD
	MOVEI	C,BUFFER(A)	;POINT IT AGAIN
	JRST	RDHAV2+2	;CONTINUE

READ:	XCT	XUSETI(A)	;USETI SET FOR NEXT LOGICAL PHYSICAL RECORD
	JRST	.+1	;IN CASE OF ERROR
	XCT	XINPUT(A)	;INPUT A RECORD
	XCT	XGTSTS(A)	;PULL THE STATUS OF THE READ
	TRNE	F,740000	;SKIP IF CLEAN
	JRST	ERINP	;NG
	TRNE	F,20000	;EOF TEST
	JRST	INEOF	;EOF IS TRUE
	MOVEM	M,CBN(A)	;PUT NEW CURRENT BLOCK NUMBER IN
	POPJ	S,0	;YES, JUST RETURN


RDSCB:	MOVEI	M,1	;SET UP TO READ THE FILE DESCRIPTOR
	PUSHJ	S,READ
	MOVE	Z,BUFFER+1(A)	;PICK UP NREC
	MOVEM	Z,MXNREC(A)	;SAVE IT AWAY
	MOVEM	Z,@6(P)	;PUT MXNREC IN FOR CALLER
	HRRZ	Z,BUFFER+2(A)	;LRECL ALSO
	HRRM	Z,FLGLRL(A)
	MOVEM	Z,@7(P)	;PUT LRECL IN FOR CALLER
	POPJ	S,0	;GO BACK

;CALL DWRITE (DSRN,ERR,ASSOC,IARAY)
DWRITE:	0	;FORTRANS NONREENTRABILITY WORD
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	17,STACK
	SETZ	T,
	PUSHJ	S,DSRNTS	;TEST DSRN
	LDB	I,BPMODE	;INSURE WRITE IS ALLOWED
	TRNN	I,2	;WRITE BIT
	JRST	ERWRT	;NOPE,TAINT
DWRT5:	PUSHJ	S,PRCMPT
;NOW HAVE COMPUTED ACTUAL RELATIVE BLOCK ADDRESS
	CAMN	M,CBN(A)	;ARE WE ALREADY THERE
	JRST	DWRT4	;YES, SCAN RECORD
	MOVE	F,CBN(A)	;TEST CBN FOR DSCB RECORD
	CAIN	F,1	;DONT REWRITE FIRST RECORD
	JRST	.+4
	PUSH	S,M	;NO, SAVE NEXT RECORD NUMBER
	PUSHJ	S,WRITE	;WRITE OUT THE CURRENT RECORD
	POP	S,M	;GET NEXT RECORD NUMBER BACK
	PUSHJ	S,DWRT2	;GET NEW LOGICAL RECORD
DWRT4:	MOVEI	C,BUFFER(A)
	ADDI	C,1(D)	;POINT IT TO DATA
	HRRZ	E,FLGLRL(A)
	HRRZ	L,3(P)	;NOW HAVE LENGTH AND ADDRESS
	MOVEI	J,BLKEND(A)
	MOVSI	Z,400000	;CLEAR UNWRITTEN BIT
	ANDCAM	Z,-1(C)
	TLO	A,200000	;MARK WRITE PENDING
	TRNN	T,000001	; TEST DELETE
	JRST	DWRT1	;GO REGULAR ROUTE
	MOVSI	Z,400000
	IORM	Z,-1(C)	;OR IT OFF
	POPJ	S,0	;GET OUT
DWRT1:	CAML	C,J	;SEE IF STILL WITHIN BUFFER
	PUSHJ	S,DWRT3
	MOVE	Z,0(L)	;GET NEXT WORD
	MOVEM	Z,0(C)	;PUTIT INTO NEXT POSITION
	ADDI	L,1	;UPDATE THE POINTERS
	ADDI	C,1
	SOJG	E,DWRT1	;LOOP BACK FOR MORE
	MOVEM	A,DSRNTB(B)	;PUT IOSTATUS BACK
	MOVEI	Z,1	;SET ERROR CODE
	MOVEM	Z,@1(P)
	AOS	,@2(P)	;UP ASSOC VARIABLE
	JRST	RETURN

DWRT3:	CAIN	E,0	;SEE IF THICAL RECORD IS REALLY FINISHED
	POPJ	S,0	;YES IT IS
	MOVEM	M,CBN(A)	;PUT RECORD NUMBER IN
	PUSHJ	S,WRITE	;DO A WRITE AND A READ FOR NEXT BLOCK
	SETO	D,
	AOS	,M	;UP CBN TO BE FETCHED
DWRT2:
	PUSHJ	S,READ	;DO THE READ
	TLO	A,200000	;MARK A WRITE IS PENDING
	MOVEI	C,BUFFER(A)
	ADDI	C,1(D)	;TO DATA
	POPJ	S,0	;RETURN
;CALL DCLOSE (DSRN,ERR)
DCLOSE:	0	;FORTRANS NONREENTRANT WORD
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	S,STACK
	MOVE	B,@0(P)	;GET DSRN
	CAILE	B,0
	CAILE	B,17	;GET RANGE AND TEST IT
	JRST	ERDSRN	;NO GOOD
	MOVE	A,DSRNTB(B)	;GET ADDRESS OF DATASET CB
	JUMPE	A,ERNODS	;TAINT ONE
	TLNN	A,400000	;SEE IF IT WAS OPENED SUCCESSFULLY
	JRST	ERNODS	;NO
	TLZE	A,200000	;SEE IF RECORD IS TO BE WRITTEN
	PUSHJ	S,CLWRT	;HERE IF YES
	PUSHJ	S,CLOSE	;DO THE CLOSE
	MOVEI	Z,1		;SET ERROR=1 (NO ERROR)
	MOVEM	Z,@1(P)
	PUSHJ	S,CLEAR
	JRST	RETURN
CLEAR:	LDB	D,BPCHAN	;CLEAR CHANNEL IN USE FLAGE
	SETZM	,CHANTB(D)
	HRRZ	Z,A	;SEE IF BLOCK ENDS AT JOBFF
	ADDI	Z,BLKEND
	CAME	Z,JOBFF
	JRST	.+4	;JUMP IF NOT
	HRRM	A,JOBFF	;MAKE NEW JOBFF
	SETZM	,DSRNTB(B)	;MARK IT NONEXISTANT
	JRST	.+3
	MOVEI	Z,777777	;GET A MASK
	ANDM	Z,DSRNTB(B)	;MARK IT EXISTANT BUT VACANT
	POPJ	S,
CLOSE:	XCT	XCLOSE(A)	;DO THE CLOSE
	XCT	XGTSTS(A)	;PULL THE STATUS
	TRNE	F,740000	;SKIP IF CLEAN
	JRST	ERCLS	;CLOSE ERROR HAS OCCURRED
	POPJ	S,	;GET BACK
;ERROR EXIT ROUTINE ARE HERE
ERSET:	MOVEM	Z,@1(P)	;PUT ERROR CODE INTO ERROR WORD
	JRST	RETURN

ERDSRN:	ERROR	2	;DSRN OUTSIDE OF ALLOWED RANGE
ERCORE:	ERROR	3	;CORE NOT AVAILABLE
ERMODE:	ERROR	4	;MODE NOT COMPATIBLE WITH EXISTING FILES
ERNAFL:	MOVEI	Z,^D5	;FILE NOT ACCESSIBLE
	JRST	DOPERR
ERNOFL:	MOVEI	Z,^D6	;NO SUCH FILE EXISTS
	JRST	DOPERR
EROUT:	ERROR	7	;DEVICE OUTPUT ERROR
ERINP:	ERROR	8	;DEVICE INPUT ERROR
ERNODS:	ERROR	9	;I/O TO CLOSED DATA SET
INEOF:	ERROR	10	;READ EOF
NOPEN:	MOVEI	Z,^D11	;UNSUCCESSFUL OPEN
	JRST	DOPERR
ERINIT:	MOVEI	Z,^D12	;ATTEMPT TO INIT A FILE ALREADY IN USE
	JRST	DOPERR
ERCLS:	ERROR	13	;UNSUCCESSFUL CLOSE
ERASOC:	ERROR	14	;ASSOCIATED VARIABLE NO GOOD
ERRDUN:	ERROR	15	;ATTEMPT TO READ AN UNDEFINED RECORD
NOCHAN:	ERROR	16	;NO CHANNEL IS AVAILABLE
EROPEN:	ERROR	17	;ATTEMPT TO OPEN AN OPEN DATASET
ERWRT:	ERROR	18	;ATTEMPT TO WRITE A READ ONLY DATASET
ERRED:	ERROR	19	;ATTEMPT TO READ A WRITE ONLY DATASET
ERLRCL:	ERROR	20	;INVALID LOGICAL RECORD LENGTH
ERRDEL:	ERROR	21    ;INNVALID DELETE ATTEMPT
DOPERR:	MOVEM	Z,@1(P)	;SAVE ERROR CODE
	PUSHJ	S,CLEAR
	JRST	RETURN

;IMPOSSIBLE ERRORS
;***IMP1:	IMPER	1	;CBN NOT CORRESPOND W DATA THERE
ZERCBN:	IMPER	2	;CBN IS ZERO!
IMP3:	HRROI	Z,-^D3	;LOOKUP/ENTER FAIL IN INITIALIZATION ROUTINE
	JRST	DOPERR
;CALL DDEL (DSRN,ERR,ASSOC,IARAY)
DDEL:	0	;FORTRANS NON REENTRANT WORD
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	S,STACK
	MOVEI	T,1	;SET DELETE SWITCH
	PUSHJ	S,DSRNTS ;DO DSRN TESTS
	LDB	I,BPMODE
	TRNN	I,2	;TEST ABILITY TO UPDSTE
	JRST	ERRDEL	;CANT UPDATE INDICATE SO
	PUSHJ	S,DRED1	;GO READ UNTIL HIT OCCURS
	PUSHJ	S,DWRT5	;SET UNDEFINED BIT AND REWRITE
DDEL1:	TLZ	A,100000
	MOVEM	A,DSRNTB(B)
	MOVEI	Z,1	;INDICATE SUCCESS
	MOVEM	Z,@1(P)	;LOCATE
	AOS	@2(P)	;
	JRST	RETURN	;GO BACK TO CALLER
	PRGEND	
TITLE	AFILE  ROUTINE FOR DOING LOOKUPS UNDER DIFFERENT USER NOS.
SUBTTL	17-MAR-72	V31/01	ALLOW ENTERS ALSO	/DLH

;FROM 02-FEB-72	V30/04	/DLH


IFNDEF	REENT,<REENT==0>
IFN	REENT,<  HISEG  >
IFN	REENT,<LOW=16>
IFE	REENT,<LOW=0>


	ENTRY	AFILE,BFILE
	EXTERN TEMP.,TBLER.,NAMPPN


;BFILE CALLED  WITH

;	JSA 16,BFILE
;	ARG 0,A1
;	ARG 5,A2
;*	ARG 5,A3

;WHERE A1 IS THE ADDRESS OF THE FORTRAN LOGICAL UNIT NUMBER
;AND A2 IS THE ADDRESS OF THE WORD CONTAINING THE ASCII
;FILE NAME FOR THE LOOKUP.
;A3 IS THE ADDRESS OF THE FIRST FIVE CHAR. OF A ONE TO 
;TWELVE CHAR ASCII USER NAME.

AFILE:	0			;TWO WORD USER NAME
	PUSH	17,2
	MOVE	2,2(16)		;GET ADDRESS OF NAME
	MOVE	0,(2)		;GET FIRST WORD OF NAME
	MOVEM	0,NAME
	MOVE	0,1(2)		;GET 2ND WORD OF NAME
	MOVEM	0,NAME+1
	SETZM	NAME+2		;CLEAR THIRD WORD
	HLL	0,JMPCON	;GET LEFT HALF OF ARG
	HRRI	0,NAME		;GET RIGHT OF ARG
	MOVEM	0,PPNCAL+1	;SAVE IT
	JRST	BOTH		;JOIN BFILE IN PROGRESS
BFILE:	0
	PUSH	17,2
	MOVE	2,2(16)		;GET USER NAME ARG
	MOVEM	2,PPNCAL+1	;SET IT UP
BOTH:	MOVE	0,@(16)		;UNIT NO.
	HRRM	0,INF		;DEPOSIT IN INF. UUO
	MOVE	0,1(16)		;**V31/01** FILE NAME
	PUSH	17,16
PPNCAL:	JSA	16,NAMPPN	;CONVERT NAME TO PPN
	0
	JUMP	4,IPPN
	JUMP	0,IER
	POP	17,16		;RESTORE AC 16
	MOVE	2,IER		;GET ERROR INDICATOR
	JUMPE	2,NOERR		;SUCCESSFUL
	CAIN	2,1		;NO AVAIL CHAN ERROR?
	JRST	TBLER.		;YES
NOERR:	MOVE	2,IPPN		;USE PPN
	MOVEM	2,TEMP.+1(LOW)
	HLRZ	2,3(16)		;**V31/01**
	TRZ	2,777		;**V31/01**
	CAIE	2,(ARG)		;**V31/01** 3RD ARG?
	JRST	POP		;**V31/01** NO
	HLRZ	2,@3(16)	;**V31/01**
	CAIE	2,476532	;**V31/01** INPUT?
	JRST	POP		;**V31/01** YES
	HRRZI	2,(OUTF.)	;**V31/01**
	HRLM	2,INF		;**V31/01**
	MOVEI	2,007000	;**V31/01**
	HRLZM	2,TEMP.+4	;**V31/01**
POP:	POP	17,2
INF:	INF.	0,INF		;THIS ADDRESS GETS MODIFIED
	HRRZI	0,(INF.)	;**V31/01** RESTORE
	HRLM	0,INF		;**V31/01**
	JRA	16,2(16)	;RETURN
IPPN:	BLOCK	1
IER:	BLOCK	1
NAME:	BLOCK	3
JMPCON:	JUMP	5,0		;HOLLERITH ARG
	PRGEND
	TITLE RENAME
	ENTRY RENAME

	;RENAME HAS THE FOLLOWING CALLING SEQUENCE:-
;CALL RENAME('OLD NAME','OLD EXT','NEW NAME','NEW EXT',NEW PROT,IERR)
;IF NO PROTECTION CHANGE IS REQUIRED USE ZERO, NEW PROTECTION MUST
;BE SPECIFIED AS AN OCTAL NUMBER E.G. "057
;IF EXTENSIONS ARE TO BE NULL SPECIFY A ZERO ARGUMENT OR
;USE A STRING OF AT LEAST THREE BLANKS E.G '   '.
;NOTE THAT A MAXIMUM OF FIVE NON BLANK CHARACTERS ARE ALLOWED
;IN A FILE NAME, AND A MAXIMUM OF 3 NON BLANK CHARACTERS ARE ALLOWED
;IN A FILE EXTENSION.
;IF THE SPECIFIED OLD FILE IS TO BE DELETED THE NEW NAME AND EXT AND 
;PROTECTION SHOULD EACH BE SPECIFIED AS ZERO IN THE CALL E.G.:-
;CALL RENAME('OLDFILE','OLDEXT',0,0,0,IERR).
;IERR IS AN ERROR CODE PARAMETER WITH THE RETURN VALUES SPECIFIED
;BELOW. NOTA BENE.. THIS ARGUMENT MUST BE A VARIABLE NAME (IDENTIFIER)
;AND MUST NOT BE A CONSTANT.
;IERR=	0	SUCCESSFUL RENAME OPERATION
;IERR=	1	USER FILE DIRECTORY NOT FOUND
;IERR=	2	PROTECTION FAILURE
;IERR=	3	FILE IN USE BY ANOTHER JOB
;IERR=	4	NEW FILE NAME ALREADY IN USE
;IERR=	5	NO FILE SELECTED ON RENAME CHANNEL(FILE WAS DELETED
;		IN THE LAST 500 MICROSECONDS)
;IERR=	6	OLD FILE NOT FOUND
;IERR=	7	DISC ERROR
;IF THE ERROR RETURN CODE IS NON ZERO NO RENAMING OR PROTECTION 
;CHANGES HAVE TAKEN PLACE. THE STATUS IS EXACTLY AS IT WAS
;BEFORE RENAME WAS CALLED.

	;ACCUMULATOR ASSIGNMENTS
	A=1
	B=2
	C=3
	D=4
	E=5
	F=6
	G=10
	H=11
	J=12
	K=13
	L=14
	M=15
	P=16
	Q=17

RENAME:REN:0
	MOVEM	Q,SAVAC+17	;SAVE AC Q
	MOVEI	Q,SAVAC		;GET STORAGE ADDRESS
	BLT	Q,SAVAC+16	;STORE AC'S
	MOVE	J,[XWD -5,PDLST-1];SET PUSHDOWN LIST POINTER
	INIT	0,17		;USE CHANNEL 0 IN DUMP MODE
	SIXBIT/DSK/		;DISC ONLY
	0			;NO BUFFERS
	JRST DSKERR		;NO DISC AVAILABLE
	MOVE	A,[POINT 7,@0(P),];POINTER TO OLD NAME
	MOVE	B,[POINT 7,@1(P),];POINTER TO OLD EXTENSION
	PUSHJ J,NAME		;GO AND SETUP LOOKUP FILE DATA
	LOOKUP	0,FILE		;DO THE LOOKUP
	JRST	LUPERR		;ERROR
	SKIPN	@4(P)		;NEW PROT SPECI     "        "@       "`       "P       "@       "P       "`       "p       "P       "`       "28       "P       "        "10       "P       "        "p       "P       "        "0       "P       "        "       "p       "        "0       "P       "P       "p       "P       "`       "@       "P       "P       "@       "P       "        "@       "P       "        "3        "P       "@       "P       "P       "@       "@       "P       "       "@       "P       "        "@       "P       "       "`       "P       "        "0       "P       "`       "0P       "P       "`       "`       "p       "       "0       "P       "       "5        "P       "       "0       "P       "        "0       "P       "0       "`       "p       "0p       "0        "P       "p       "0h       "P       "        "0       "P       "0       "0       "P       "0       "p       "P       "0       "0        "P       "0       "0        "P       "p       "0        "P       "p                                                                                                                               !        !        !        !        !        !        !        !        !        !        #1w       #2       #2       #1w       #2       #2       #2       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #1w       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2       #2                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
IFE REENT,<LOW=0>

A=1
Q=16
P=17

SIZE:   0
        PUSH    P,A             ;GET A REGISTER
        MOVE    A,@(Q)          ;GET F4 UNIT
IFN REENT,<ADDI A,(LOW)>
        MOVE    0,FILSZ.(A)     ;GET FILE SIZE
        POP     P,A             ;RESTORE REGISTER
        JRA     Q,1(Q)          ;RETURN

        PRGEND
TITLE	LOGOUT	TERMINATE OUTPUT AND LOGOUT JOB
SUBTTL	V31/01	13-MAR-72	/DLH


ENTRY	LOGOUT
EXTERN	RUN
OPDEF	FCALL.	[35B8]

	SIXBIT	/LOGOUT/
LOGOUT:	0
	FCALL.	1,
	JSA	16,RUN
	JUMP	5,SYS
	JUMP	5,LGOUT
	CALLI	12


SYS:	ASCIZ	/SYS  /
LGOUT:	ASCIZ	/LOGOUT    /

	PRGEND
	TITLE RUN
	SUBTTL	14-JUN-72	V31/14	USER NAME BUG	DLH

	; FROM 12-JUN-72	V31/12	ALTERNATE ENTRIES	/DLH

	; FROM 08-MAR-72	V31/01	/DLH
	ENTRY RUN
	EXTERN NAMPPN

RUN:0
	SETZM	INCRMT	;**V31/12**
	MOVEI 0,5	;SET COUNTER
GETCHR:	ILDB 1,A	;GET FIRST CHARACTER
	SUBI 1,40	;CONVERT TO SIXBIT
	IDPB 1,B		;DEPOSIT CHARACTER
	SKIPE 1		;TEST IF CHARACTER WAS A BLANK
	SOJN 0,GETCHR	;TEST IF COMPLETE
END:	MOVEI 0,5	;SET COUNTER
GETCR1:	ILDB 1,D	;GET CHARACTER
	SUBI 1,40	;CONVERT TO SIXBIT
	IDPB 1,C	;DEPOSIT CHARACTER
	SKIPE 1		;TEST IF CHARACTER WAS A BLANK
	SOJN 0,GETCR1	;TEST IF FINISHED
	LDB    0,[POINT 4,1(16),12]   ;**V31/14**
	CAIGE	0,5		;**V31/01**
	JRST	END2		;**V31/14**NOT HOLLERITH, DOUBLE PRECISION OR COMPLEX
	MOVEI	0,@1(16)	;**V31/01**
	HLL	0,E		;**V31/01**
	ADDI	0,1		;**V31/01**
	ILDB	1,0		;**V31/01**
	SUBI	1,40		;**V31/01**
	CAIL	1,0		;**V31/01**
	IDPB	1,C		;**V31/01**
;***********USER NAME PATCH****21-MAR-71****V31/01*******************
END2:	HLRZ	1,2(16)		;**V31/14**CHECK FOR USER NAME ARG
	TRZ	1,777
	CAIE	1,(ARG)
	JRST	END1		;NO USER NAME
	MOVE	1,2(16)		;GET ADDRESS OF USER NAME
	MOVEM	1,PPNCAL+1
	PUSH	17,16		;SAVE AC
PPNCAL:	JSA	16,NAMPPN	;CONVERT NAME TO PPN
	0
	JUMP	4,SIXWRD+4
	JUMP	0,IER
	POP	17,16		;RESTORE AC
;***********END OF USER NAME PATCH*************************************


;***********ENTRY PATCH****12-JUN-72****V31/12**************************
	HLRZ	1,3(16)
	TRZ	1,777
	CAIE	1,(ARG)
	JRST	END1
	MOVE	1,@3(16)
	MOVEM	1,INCRMT
END1:	MOVS	1,INCRMT
	HRRI	1,SIXWRD
;***********END OF ENTRY PATCH****************************************
	CALL 1,[SIXBIT/RUN/]	;UP-UP-&-AWAY
	TTCALL 3,[ASCIZ/
ERROR IN CALL TO RUN/]	;CRUNCH
	SETZ 0,		;SET ACCUMULATOR TO ZERO TO RELEASE DEVICES
	JUMPE 1,ERR1
	SUBI 1,7
	JUMPL 1,KILL
	JUMPE 1,ERR2
	SUBI 1,2
T:	JUMPL 1,KILL
	JUMPE 1,ERR3
	SUBI 1,1
	JUMPE 1,ERR4
	XCT KILL
ERR1:	TTCALL 3,[ASCIZ/:- FILE NOT FOUND/]
	XCT KILL
ERR2:	TTCALL 3,[ASCIZ/:- NOT A SAVED FILE/]
	XCT KILL
ERR3:	TTCALL 3,[ASCIZ/:- DEVICE NOT AVAILABLE/]
	XCT KILL
ERR4:	TTCALL 3,[ASCIZ/:- NO SUCH DEVICE/]
KILL:	CALLI 0,12	;CALL EXIT AND RELEASE DEVICES
IER:	BLOCK	1		;**V31/01**
A:	POINT 7,@0(16)
B:	POINT 6,SIXWRD
C:	POINT 6,SIXWRD+1
D:	POINT 7,@1(16)
E:	POINT	7		;**V31/01**
INCRMT:	BLOCK	1		;**V31/12**
SIXWRD:	BLOCK 6
	PRGEND
	TITLE	NAMPPN	LIB40 ROUTINE TO CONVERT USER NAMES TO PPNS
	SUBTTL	03-JAN-72	/DLH


	EXTERN	DYNDV.,DYNND.

	ENTRY	NAMPPN


	IFNDEF REENT,<REENT==0>
	IFN REENT,<LOW=16>
	IFE REENT,<LOW=0>

	A=1
	B=2
	C=3
	D=4
	E=5
	F=6
	G=7
	H=10
	CS=11
	CQ=12
	Q=16
	P=17	;STACK POINTER

	LHUN==4
	LDPPN==0
	LLINK==2


SAVEAC:	BLOCK	20
ACBLT:	XWD	A,SAVEAC+A
SBUF:	BLOCK	200
SHED:	IOWD	200,SBUF
	0
CFPTR:	POINT	7,F
FPTR:	POINT	7,F
CDPTR:	POINT	6,D
DPTR:	POINT	6,D

NAMPPN:	0			;FORTRAN ENTRY
	MOVEM	0,SAVEAC+0		;SAVE REGISTERS
	MOVE	0,ACBLT
	BLT	0,SAVEAC+P
	MOVEI	D,DYNDV.+1(LOW)		;THE SEARCH FOR A FREE CHAN
SLLOOP:	LDB	C,[POINT 30,(D),29]
	JUMPE	C,GOTSLT
	AOJ	D,
	CAIG	D,DYNND.(LOW)
	JRST	SLLOOP
	JRST	NOCHAN			;ALL CHANNELS BUSY!
GOTSLT:	MOVEI	C,DYNDV.(LOW)		;FOUND FREE CHAN
	SUBM	D,C
	DPB	C,[POINT 4,OPUD,12]	;PUT CHAN # IN I/O STMTS
	DPB	C,[POINT 4,LKUD,12]
	DPB	C,[POINT 4,RDBLK,12]
	DPB	C,[POINT 4,RDBLK+1,12]
	DPB	C,[POINT 4,RDBLK+2,12]
	DPB	C,[POINT 4,REL,12]
	DPB	C,[POINT 4,CLOS,12]
OPUD:	INIT	0,17			;**MODIFIED
	SIXBIT	/SYS/
	XWD	0,0
	JRST	NOINIT			;TROUBLE ON THE INIT
	MOVE	A,[SIXBIT /LUD/]	;INIT OK - OPEN FILE
	MOVSI	B,(SIXBIT /SYS/)
	SETZB	C,D
LKUD:	LOOKUP	0,A			;**MODIFIED
	JRST	NOLOOK			;TROUBLE ON LOOKUP

	HRRZ	CQ,Q			;CLEAR LEFT HALF OF RETURN REG
	SETZB	D,E			;CLEAR FOR SIXBIT NAME
	MOVE	G,[POINT 6,D]
	MOVE	CS,(CQ)
	MOVE	F,@CS			;CONVERT NAME TO SIXBIT
	JUMPE	F,NONAM			;FORGOT NAME!
	PUSHJ	P,TRAN76		;CONVERT 5 CHAR
	ADDI	CS,1
	MOVE	F,@CS			;IS THERE MORE?
	JUMPE	F,LKLUD			;NO
	PUSHJ	P,TRAN76
	ADDI	CS,1
	MOVE	F,@CS
	JUMPE	F,LKLUD
	PUSHJ	P,TRAN76		;EXTRA 3 CHAR OVERFLOW INTO AC F
	JRST	LKLUD

TRAN76:	MOVE	C,[POINT 7,F]		;TRANSLATE 5 ASCII CHAR TO 6BIT
	MOVEI	A,5
	ILDB	B,C
	SUBI	B,40
	IDPB	B,G
	SOJG	A,TRAN76+2
	POPJ	P,
LKLUD:	MOVEI	H,0		;HAVE NAME IN SIXBIT - FIND PPN
	MOVE	A,[555555555555]
	MOVE	B,[361275431652]
	MOVE	C,[612754316523]
	PUSHJ	P,RND
	PUSHJ	P,RND
	PUSHJ	P,RND
	PUSHJ	P,RND
	XOR	B,C
	XOR	A,B
	TLZ	B,400000
	IDIVI	B,^D887
	MOVE	B,A
SRUS:	PUSHJ	P,RDBLK
	MOVEI	A,0
SRUSR:	CAME	B,SBUF+LHUN(A)
	JRST	NUSER
	JRST	FINUP
NUSER:	SKIPG	F,SBUF+LDPPN(A)
	JRST	BLKLNK
	MOVE	F,SBUF+LLINK(A)
	ANDI	F,177
	ADD	A,F
	JRST	SRUSR
BLKLNK:	JUMPE	F,NOTFND
	MOVE	C,F
	JRST	SRUS

RND:	ADD	B,D
	JFCL
	ROTC	D,-22
	MOVEI	CS,5
RND1:	MOVE	F,B(H)
	MUL	F,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
	ADDM	G,C(H)
	JFCL
	AOJE	H,RND2
	MOVNI	H,1
	TRNE	B,1
	SKIPL	C
	MOVEI	H,0
	EXCH	A,C
RND2:	SOJG	CS,RND1
	POPJ	P,
RDBLK:	USETI	0,1(C)		;**MODIFIED
	INPUT	0,SHED		;**MODIFIED
	STATZ	0,760000	;**MODIFIED
	JRST	NOINP
	POPJ	P,
NOCHAN:	MOVEI	C,1		;ERR0R - NO CHANNELS AVAIL
	JRST	OUT
NONAM:	MOVEI	C,2		;ERROR - 1ST WORD OF NAME =0
	JRST	OUT
NOTFND:	MOVEI	C,3		;ERROR - NAME NOT FOUND IN LUD.SYS
	JRST	OUT
NOINIT:	MOVEI	C,11		;ERROR - INIT DIDN'T WORK
	JRST	OUT
NOLOOK:	MOVEI	C,11		;ERROR - LOOKUP DIDN'T WORK
	JRST	OUT
NOINP:	MOVEI	C,11		;ERR0R - INPUT DIDN'T WORK
	JRST	OUT

FINUP:	MOVE	C,SBUF(A)
	JUMPE	C,NOTFND	;PPN IS ZERO
	MOVEM	C,@1(CQ)		;REPLACE 2ND ARG WITH PPN
	MOVEI	C,0		;SUCCESS
OUT:	MOVEM	C,@2(CQ)		;REPLACE 3RD ARG WITH ERROR IND
	JUMPE	C,CLOS		;WAS THERE ERROR?
	MOVEI	C,0		;YES - RETURN ZERO PPN
	MOVEM	C,@1(CQ)
CLOS:	CLOSE	0,0		;**MODIFIED
REL:	RELEAS	0,		;**MODIFIED
	MOVSI	17,SAVEAC
	BLT	17,17
	MOVE	0,SAVEAC+0
	JRA	Q,3(Q)		;RETURN



	PRGEND
TITLE BENCHMARK STATISTICS PRINTER FOR FORTRAN
SUBTTL 02-DEC-71 DLH

ENTRY BENCHMARK
EXTERNAL ERRFI.,UUOL.

P=17

SIXBIT /BENCHM/
BENCHMARK: 0
	XCT	UUOL.		;SET UP AC 16
	PUSHJ	P,ERRFI.	;PUBLISH ERROR/TIMING SUMMARY
	XCT	UUOL.		;RESTORE AC16 FOR LUSER
	JRA	16,0(16)	;TRA 1,4
	PRGEND
TITLE IFILE     ROUTINE FOR DOING LOOKUPS FROM FORTRAN IV
SUBTTL 17-MAR-72	V31/01	/DLH

;FROM V.005	9-SEP-67
	;18-FEB-66 BEGAT 9-SEP-67 REPLACED ALL INFIL'S WITH IFILE.

	ENTRY	IFILE

;IFILE CALLED  WITH

;	JSA 16,IFILE
;	ARG 0,A1
;	ARG 5,A2

;WHERE A1 IS THE ADDRESS OF THE FORTRAN LOGICAL UNIT NUMBER
;AND A2 IS THE ADDRESS OF THE WORD CONTAINING THE ASCII
;FILE NAME FOR THE LOOKUP.

IFILE:	0
	MOVE	0,@(16)		;UNIT NO.
	HRRM	0,INF		;DEPOSIT IN INF. UUO
	MOVE	0,1(16)		;**V31/01** FILE NAME
INF:	INF.	0,INF		;THIS ADDRESS GETS MODIFIED
	JRA	16,2(16)	;RETURN
	PRGEND
TITLE OFILE  	ROUTINE FOR DOING ENTERS FROM FORTRAN IV
SUBTTL	17-MAR-72	V31/01	/DLH

;FROM V.005 9-SEP-67
	;18-FEB-66 BEGAT 9-SEP-67 REPLACED ALL OUTFIL'S WITH OFILE

	ENTRY OFILE

;OFILE CALLED WITH

;	JSA 16,OFILE
;	ARG 0,A1
;	ARG 5,A2

;WHERE A1 IS THE ADDRESS OF THE FORTRAN LOGICAL UNIT NUMBER
;AND A2 IS THE ADDRESS OF THE WORD CONTAINING THE ASCII
;FILE NAME FOR THE LOOKUP.

OFILE:	0
	MOVE	0,@(16)		;UNIT NUMBER
	HRRM	0,OUTF		;DEPOSIT IN OUTF UUO
	MOVE	0,1(16)		;**V31/01** FILE NAME
OUTF:	OUTF.	0,OUTF		;THIS ADDRESS MODIFIED
	JRA	16,2(16)	;RETURN
	PRGEND
TITLE EOFTST  V.30.0.136    TO SKIP ONE OR MORE END OF FILES
SUBTTL	9-APR-71	/DMN
;FROM	V.27U.1 3/NOV/70 /VAA

;THIS SUBROUTINE CHECKS THE END OF FILE ON A DEVICE SPECIFIED
;BY THE USER,IF THE EOF BIT IS ON A -1 IS RETURNED IN AC 0;
;OTHERWISE A ZERO IS RETURNED.

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA 16,EOF1  OR  JSA 16,EOFC
;	ARG A  (WHERE A IS THE DEVICE NO. TO BE CHECKED)

EXTERN	LOGEN.,DEVER.,EOFFL.,ONLY1.,DEVTB.,DYNDV.,DYDVL.,UUOL.

ENTRY	EOF1,EOFC

;ACCUMULATORS
A=0
B=1
C=2
P=17

MLON

EOF1:	0
	SETOM	EOF1.		;SET FLAG FOR ONE EOF ONLY
	JRST	E1
EOFC:0
	SETZM	EOF1.		;MORE THAN 1 EOF ALLOWED
E1:	PUSH	P,B
	PUSH	P,C
	MOVE	A,@(16)		;GET ARG
	IDIVI	A,12		;CONVERT TO 6BIT
	LSH	A,6
	OR	A,B		;CARRY
	IORI	A,2020		;6BITMASK
	HRLZS	A		;RIGHT JUSTIFY
	TLNN	A,700		;2 DIGITS?
	LSH	A,6		;ONE DIGIT
	LSH	A,6		;ONE AND/OR TWO DIGS
	PUSHJ	P,GETCHN	;SEE IF THAT HAS BEEN INITED
	MOVE	C,@(16)		;GET ARG AGAIN
	MOVE	A,DEVTB.(C)	;FAIL,TRY DEVTB DEFAULT NAME
	PUSHJ	P,GETCHN	;GET CHANNEL ASSOCIATED WITH DEVTB NAME
	MOVE	A,@(16)		;FAIL, NOT INITED EITHER
	XCT	UUOL.		;SET UP AC 16 BEFORE GOING TO ERROR.
	PUSHJ	P,DEVER.	;TYPE ERROR MESSAGE AND EXIT

EQUAL:	POP	P,(P)		;GET RID OF RETURN ADDRESS
	SETOM	EOFFL.(C)	;SET EOFTST HAS BEEN CALLED FLAG
	SKIPE	ONLY1.(C)	;SKIP IF NO EOF HAS BEEN SEEN BEFORE ON CHAN
	PUSHJ	P,[SKIPN EOF1.	;EOF HAS BEEN SEEN, ONE ALLOWED.
		POPJ	P,	;MULTIPLE EOFS ALLOWED
		XCT	UUOL.	;SET UP AC 16 FIRST
		PUSHJ	P,LOGEN.];FAIL,GO PRINT MESSAGE AND EXIT
	SETZM	ONLY1.(C)	;CLEAR ONLY ONE FLAG IN CASE THIS IS FIRST CALL TO EOFTST.
	MOVE	B,DYNDV.(C)	;GET DYNDV. ENTRY
	TRNE	B,4		;EOF BIT SET?
	SETOB	A,ONLY1.(C)	;SET FLAGS FOR USER AND EOF1
	TRZN	B,4		;CLEAR IT
	MOVEI	A,0		;SET NO EOF FOR USER
	MOVEM	B,DYNDV.(C)	;CLEAR DYNDV. FLAG FOR EOF
	POP	P,C
	POP	P,B
	JRA	16,1(16)	;RETURN

GETCHN:	SETZ	C,
G1:	MOVE	B,DYNDV.(C)	;GET DEVICE NAME ON CHAN IN AC'C'
	TRZ	B,7		;CLEAR OUTPUT LAST FLAG ,EOF FLG, IF ANY
	CAMN	A,B		;DOES IT CORRESPOND TO UNIT IN CALL?
	JRST	EQUAL		;YES, GO SET UP FLAGS
	CAIE	C,DYDVL.	;DON'T EXCEED DYNDV. TABLE
	AOJA	C,G1		;LOOP BACK
	POPJ	P,		;RETURN HAVING FAILDE TO MATCH DEVICE TO CHANNEL

	EOF1.:	BLOCK	1	;FLAG

	PRGEND
TITLE DEFINE FILE  FORTRAN IV DIRECT ACCESS ROUTINES
SUBTTL	V31/01	28-FEB-72	/DLH
;V30.203	09-JUN-71  	V.ALUSIC/DMN

MLON
ENTRY		DEFINE,DEFINB
EXTERN		NAMPPN,TBLER.
EXTERN		FILE1.,FILE2.,FILE3.,FILE4.,FILE5.,DYDVL.,TYPER.

A=1
B=2
C=3
D=4
E=5
F=6
DFBFLG:	BLOCK	1		;**V31/01**
NAME:	BLOCK	3		;**V31/01**
JMPCON:	JUMP	5,0		;**V31/01**
IPPN:	BLOCK	1		;**V31/01**
IER:	BLOCK	1		;**V31/01**

;*************PPN PATCH****28-FEB-72****V31/01***********************
	SIXBIT	/DEFINB/
DEFINB:	0
	SETOM	DFBFLG
	JRST	DEFINE+2
	SIXBIT	/DEFINE/
DEFINA:	0			;**V31/01**
DEFINE:	0
	SETZM	DFBFLG
;****************END OF PATCH****************************************
	MOVE	A,@(16)		;DEV NO
	CAILE	A,DYDVL.	;LEGAL NUMBER?
	JRST	ILLNUM		;NO
	SETZM	FILE5.(A)	;**V31/01**
	SETZM	FILE4.(A)	;**V31/01**
	HRRZ	D,3(16)		;PICK UP FILENAME ADDR.
	HRRZI	E,1(D)		;EXT
	MOVE	F,[POINT 7,@D]
	MOVE	0,[POINT 6,FILE5.(A)]
	HRROI	B,-^D10		;10 CHARS
GETCHR:	ILDB	C,F		;GET CHR
	JUMPE	C,BACK		;NULL => FINISHED
	CAIN	C,56		;DEC PT?
	JRST	[HRROI	B,-3	;YES
		MOVE	0,[POINT 6,FILE4.(A)]
		JRST	GETCHR]	;RETURN FOR EXT
	CAIGE	C,140		;TEST FOR LOWER CASE
	SUBI	C,40		;NO, CONVERT TO 6-BIT
	IDPB	C,0		;PUT IT IN FILES.
	AOJL	B,GETCHR	;NOT DONE? THEN GET NEXT CHR
BACK:				;**V31/01**
	MOVE	D,@1(16)	;PICK UP RECORD SIZE
	MOVEM	D,FILE2.(A)	;STORE IN 4TH WD
	HRRZ	D,2(16)		;PICK UP VARIABLE ADDR
	HRRZM	D,FILE1.(A)	;STORE IN 5TH WD
	SETZM	FILE3.(A)	;ZERO BY DEFAULT
	HLRZ	D,4(16)		;GET OP CODE
	TRZ	D,777		;AND ONLY OP CODE
	CAIE	D,(ARG)		;IF ARG ALL OK
	JRA	16,4(16)	;NO, SO RETURN
;**********PPN PATCH****28-FEB-72****V31/01***************************
	PUSH	17,16		;SAVE AC 16
	SKIPN	,DFBFLG		;2 0R 3 WORD NAME?
	JRST	TWOWRD		;TWO
	MOVE	B,4(16)		;GET ADDR OF USER NAME
	MOVEM	B,PPNCAL+1	;SAVE AS ARG FOR NAMPPN
PPNCAL:	JSA	16,NAMPPN	;CALL CONVERSION ROUTINE
	0
	JUMP	4,IPPN
	JUMP	0,IER
	POP	17,16		;RESTORE AC
	MOVE	B,IER
	JUMPE	B,NOERR		;CHECK FOR ERROR
	CAIN	B,1
	JRST	TBLER.		;CHANNEL NOT AVAILABLE
NOERR:	MOVE	B,IPPN
	MOVEM	B,FILE3.(A)	;SAVE SIXBIT USER #
;**********END OF PPN PATCH******************************************
	HLRZ	D,6(16)
	TRZ	D,777
	CAIE	D,(ARG)
	JRA	16,6(16)	;RETURN
	MOVE	D,@6(16)	;GET PROTECTION CODE
	HRRM	D,FILE4.(A)	;STORE IT WITH EXTENSION
	JRA	16,7(16)	;RETURN
;************PPN PATCH****28-FEB-72****V31/01***********************
TWOWRD:	MOVE	D,4(16)		;SET UP ARGS
	MOVE	B,(D)
	MOVEM	B,NAME
	MOVE	B,1(D)
	MOVE	B,NAME+1
	SETZM	NAME+2
	HLL	B,JMPCON
	HRRI	B,NAME
	MOVEM	B,PPNCAL+1
	JRST	PPNCAL
;**************END OF PATCH******************************************
ILLNUM:	IDIVI	A,^D10		;MAKE TWO DIGITS
	IORI	A,"0"		;THEN ASCII
	IORI	B,"0"
	MOVE	C,[POINT 7,ILLMES+5,27]
	IDPB	A,C		;PUT NUMBER IN MESSAGE
	IDPB	B,C
	MOVSI	0,ILLMES	;FATAL MESSAGE
	PUSHJ	17,TYPER.	;NEVER TO RETURN

ILLMES:	ASCIZ /?DIRECT ACCESS DEVICE NUMBER XX IS ILLEGAL/




	PRGEND
TITLE	BUFFER	IBUFF-OBUFF V32(432)
SUBTTL	1-JUN-72	/DMN

ENTRY	BUFFER,IBUFF,OBUFF
EXTERN	SAVCK.,INTVR.,DATTB.,UNSV.,TYPER.


	;AC'S
A=1
B=2
C=3
D=4
E=5
Q=16
P=17

; SAVE AC'S, INITIALIZE, CHECK ARGS, SAVE INFORMATION

BUFFER:	0
	PUSHJ	P,SAVCK.	;INITIALIZE
	PUSHJ	P,INTVR.	;PICK UP DEV NAME IN E
				;MAKE SURE DEVICE NOT INITED.
	SKIPLE	B,@1(Q)		;DEV NUM IN A, GET DIR
	CAILE	B,3		;SEE IF ARGUMENT IS REASONABLE
	JRST	ILLNUM		;IF UNREASONABLE,FAIL!
	SKIPLE	C,@2(Q)		;INOUT ARG IN B, GET NUM
	CAILE	C,17		;FROM ONE TO FIFTEEN
	JRST	ILLNUM		;BUFFS ALLOWED

; (0),(A)=DEV NUM, (B)=DIR, (C)=NUM



; NOW SET THE APPRPORAITE FIELDS IN THE DATTB. ENTRY

	TRNE	B,1		;IN SET?
	DPB	C,[POINT 4,DATTB.(A),31]
	TRNE	B,2		;OUT SET ?
	DPB	C,[POINT 4,DATTB.(A),35]
RET:	PUSHJ	P,UNSV.		;RESTORE
	JRA	Q,3(Q)		;RETURN

; HERE FOR ILLEGAL PARAMETER IN CALL

ILLNUM:	MOVE	0,[[ASCIZ /INVALID PARAMETER FOR BUFFER SUBROUTINES/],,14]
	PUSHJ	P,TYPER.
	JRST	RET


;THESE TWO ENTRY POINTS ARE FOR THE BUFFER SIZE ROUTINES

IBUFF:	0
	PUSHJ	P,SAVCK.	;GET DEV NUNBER IN A
	SKIPLE	B,@1(Q)		;GET NUMBER BUFFERS DESIRED
	CAILE	B,17		;UP TO 15 ALLOWED (4 BITS ONLY)
	JRST	ILLNUM		;ILLEGAL
	DPB	B,[POINT 4,DATTB.(A),31]	
BUFR:	SKIPLE	B,@2(Q)		;GET SIZE
	CAILE	B,-1		;RIGHT HALF ONLY ALLOWED
	JRST	ILLNUM		;ILLEGAL
	HRLM	B,DATTB.(A)	;STOR IT
	JRST	RET		;RETURN

OBUFF:	0
	PUSHJ	P,SAVCK.	;DEVICE # IN A
	SKIPLE	B,@1(Q)		;GET # BUFFERS DESIRED
	CAILE	B,17		;CHECK RANGE
	JRST	ILLNUM		;ILLEGAL
	DPB	B,[POINT 4,DATTB.(A),35]  ;STORE IT
	JRST	BUFR

	PRGEND
TITLE	MAGDEN	V31(214)
SUBTTL	24-JUN-71	/DMN
;FROM	31-JAN-68	V.001


ENTRY	MAGDEN
EXTERN	DEVTB.,MTABF.,UUOL.
EXTERN	UNSV.,ILLMG.,INIER.,SAVCK.
EXTERN	TABP1.,DEVIC.,INTVR.


	;ARGUMENT PARAMETER DEFINITIONS
LOW== ^D200
MED== ^D556
HIGH==^D800
ODD== 0
EVEN==1



	;AC'S
A=1		;DEVICE NUMBER,POINTER
B=2
C=3
D=4		;DENSITY AND PARITY MASK
E=5
F=6		;FREE CHANNELL
Q=16
P=17


	;MODE MASKS FOR DENSITIES AND PARITIES
LMASK==2
MMASK==4
HMASK==6
EVNMSK==10
;SAVE AC'S, INITIALIZE, CHECK ARGS, SAVE INFORMATION

MAGDEN:	0
	PUSHJ	P,SAVCK.	;SAVE 0-6,INIT D,E;CHECK DEV NUM
	MOVE	B,@1(Q)		;DEV NUM IN A, GET DENSITY.
	SETZ	D,		;START WITH STANDARD ZERO
	CAIN	B,LOW		;LOW DENSITY?
	MOVEI	D,LMASK		;YES
	CAIN	B,HIGH		;HIGH DENSITY?
	MOVEI	D,HMASK		;YES
	CAIN	B,MED		;MEDIUM DENSITY?
	MOVEI	D,MMASK		;YES
	JUMPE	D,DIEM		;FAIL IF NOT ONE OF ABOVE
	MOVE	B,@2(Q)		;GET PARITY ARG
	CAIN	B,ODD		;ODD PARITY?
	JRST	AFTRCK		;YES, GO ON, NO BITS SET
	CAIE	B,EVEN		;EVEN PARITY?
	JSP	F,DIEM		;NO,FAIL!
	IORI	D,EVNMSK	;YES, SET BIT

;DEV NUM IN "A", MASK IN "D", ARGS LEGAL
AFTRCK:	PUSHJ	P,INTVR.	;PICK UP DEV NAME
				;MAKE SURE DEV NOT YET INIT

;MODE IN D, DEV NAM IN E



;FIND A SLOT, INSERT DATA, RESTORE AC'S , RETURN

GOTNAM:	MOVEI	A,TABP1.	;INIT TABLE POINTER
	SETZB	B,F		;INIT POINTER TO FREE SLOT
SLTLOP:	SUBI	A,1		;UPDATE TABLE POINTER
	CAIGE	A,MTABF.	;DONE WITH TABLE?
	JRST	PREPUT		;YES, PUT DATA IN SLOT
	MOVE	C,(A)		;GET NAME FROM SLOT
	TRZ	C,77		;CLEAR MODE BITS
	CAMN	C,E		;THE ONE WE WANT?
	JRST	SETPUT		;YES,DONE LOOKING
	JUMPN	C,SLTLOP	;NO,LOOP BACK UNLESS 0
	MOVE	B,A		;IF ZERO,SAVE POINTER AND
	JRST	SLTLOP		;THEN LOOP BACK
SETPUT:	MOVE	B,A		;SET POINTER, THIS DEV PREVIOUSLY
				;INIT IN THIS SLOT
PREPUT:	JUMPN	B,PUT		;WAS THERE A FREE SLOT?
	JSP	F,DIE		;NO,FAIL!
PUT:	MOVEM	E,(B)		;YES, PUT NAME IN SLOT
	IORM	D,(B)		;GET MODE BITS IN TOO
	PUSHJ	P,UNSV.		;RESTORE
	JRA	Q,3(Q)		;RETURN


DIE:	XCT	UUOL.		;SET UP AC 16 FIRST
	MOVE	7,[PUSHJ P,INIER.]	;SO IT CAN FIND DEV NUM
	JRST	7

DIEM:	XCT	UUOL.
	MOVE	0,DEVTB.(A)	;SET UP
	MOVEM	0,DEVIC.	;DEV NAM
	PUSHJ	P,ILLMG.	;FOR ERROR



	PRGEND
TITLE	SAVCK. V32(272)
SUBTTL	V32(272)	9-SEPT-71	/DMN
;V.001  31-JAN-68 N PAPPAS


ENTRY		SAVCK.,SAVP1.,SAVPL.,INTVR.,UNSV.
EXTERNAL	DEVER.,DVTOT.,DEVTB.,DYNND.,DYNDV.,INIER.,UUOL.


A=1
B=2
C=3
D=4
E=5
F=6
Q=16
P=17


;USES A SEVEN WORD BLOCK TO SAVE AC'S 0-6
;VERIFIES THAT DEV NUM IS LEGAL
;ZEROES D AND E, DEV NUM IN A&0
;CALLED BY PUSHJ P,SAVCK.

SAVCK.:	MOVEM	0,SAVPL.		;SAVE
	MOVE	0,[XWD A,SAVP1.]	;AC'S
	BLT	0,SAVPL.+6		;0-6
	SETZB	D,E		;INITIALIZE STORAGE AREAS
	MOVE	0,@(Q)		;GET DEV NUM FOR DEVER.
	CAIGE	0,77		;IS DEV NUM BELOW LIMIT?
	SKIPG	A,0		;YES, BUT IS IT >0?
	PUSHJ	P,DIER		;NO, FATAL ERROR!
	POPJ	P,		;GOOD RETURN

DIER:	XCT	UUOL.		;SET UP AC 16
	JRST	DEVER.		;BEFORE GOING TO OP-SYSTEM

UNSV.:	MOVS	0,[XWD A,SAVP1.]	;
	BLT	0,F		;RESTORE
	MOVE	0,SAVPL.
	POPJ	P,
; GET DEVICE NAME AND SEE IF DEVICE ALREADY INIT
; CALLED BY :  PUSHJ P,INTVR.
; EXPECTS DEV NUM IN A
; USES: 0,E,F
; BAD RETURN: INIER., DEV NUM IN A, PC&FLAGS IN E
; GOOD RETURN: DEV NAM IN E, (F)=PTR TO DYNDV.,DEV NUM IN A,(0)=GARBAGE


INTVR.:	MOVE	C,A		;SAVE DEV NUM IN C
	IDIVI	A,12		;CONVERT DEVICE NUMBER TO 6BIT
	LSH	A,6
	OR	A,B
	IORI	A,2020
	TRNN	A,700
	LSH	A,6
	LSH	A,30
	MOVE	E,A
	CALLI	E,4
	TRNN	E,400000	;IS UNIT ASSIGNED BY CONSOL?
	JRST[	CAILE	C,DVTOT.;NOT ASSIGNED BY CONSOL.TOO BIG FOR DEVTB.?
		PUSHJ	P,DIER		;YES, FAIL
		MOVE	E,DEVTB.(C)	;NO, GET DEFAULT NAME
		JRST	INTVR1	]	;RETURN
	MOVE	E,A		;YES ASSIGNED BY CONSOL
INTVR1:	MOVEI	F,DYNDV.	;START-OF-DYNDV. IN F
NAMLOP:	MOVE	0,(F)		;PICK UP A NAME
	TRZ	0,77		;CLEAR CHAN. NUMBER
	MOVE	A,C		; *272* RESTORE DEV NUMBER
	CAMN	E,0		;THE ONE WE WANT?
	JSP	0,DIE		;YES,FAIL!
	CAIGE	F,DYNND.	;END OF SEARCH?
	AOJA	F,NAMLOP	;NO, UPDATE PTR
	POPJ	P,		;YES, NOT YET INIT

DIE:	XCT	UUOL.		;SET UP AC 16 FIRST
	MOVE	7,[PUSHJ P,INIER.]
	JRST	7		;DEV NAM AT PC-2


SAVPL.:	BLOCK	7	;AC'S SAVED HERE
SAVP1.=SAVPL.+1

	PRGEND
TITLE RELEASE F4 I/O DEVICES	V30.207
SUBTTL	8-JUN-71	D.M.NIXON

ENTRY	RELEAS
OPDEF	FCALL.	[35B8]

Q=16

RELEAS:	0
	MOVE	0,@(Q)		;GET DEVICE NUMBER
	FCALL.	0,		;LET FORSE DO ALL THE WORK
	JRA	Q,1(Q)		;RETURN

	END
 ‰