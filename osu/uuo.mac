TITLE   UUO     02/20/74
;*LAST LINE EDITING WOULD BE NICE
;*REDO RDLINE ROUTINE TO USE TABLE
;
;
; THIS PACKAGE CONTAINS A UUO DISPATCHER AND SOME TELETYPE
; UUOS.
;
; IT IS ASSUMED THAT REGISTER P IS SET UP FOR A PUSH STACK.
; IT IS USED EXTENSIVELY BY THIS CODE BUT IS NOT SET UP.
;
; IT IS ASSUMED THAT LOCATION 41 OCTAL CONTAINS THE INSTRUCTION
; 'PUSHJ P,UUO'.
;
; TO ADD NEW UUOS, PUT THE UUO NAME AND ROUTINE ADDRESS INTO
; THE TABLE 'UUOTAB'. THE FORMAT OF AN ENTRY IS:
; NAME,ROUTINE. THE LOCATIION OF THE UUO IN THE TABLE
; DEFINES IT'S OPCODE FIELD. IN OTHER WORDS, THE FIRST ENTRY
; IN THE TABLE HAS OPCODE 1, THE SECOND ENTRY HAS OPCODE 2.
; IN GENERAL, THE NTH ENTRY IN THE TABLE HAS OPCODE N.
; UNUSED ENTRIES SHOULD BE ZERO.
;
; WHEN THE UUO DISPATCHER BRANCHES TO THE UUO ROUTINE,
; THE RETURN ADDRESS AND THE ORIGINAL CONTENTS OF REGISTER ZERO
; WILL HAVE BEEN PUSHED ONTO THE STACK. CELL ZERO IS ON THE
; TOP OF THE STACK. THE RETURN ADDRESS IS NEXT. CELL ZERO
; WILL HAVE BEEN CLOBBERED.
        EXTERNAL CDISP,ESCR,CIN,FERR

SAVBEG=1
SAVEND=16
FORTY=40

LBRACK==133
RBRACK==135
YCHR=   131
LFCHR=12
BELCHR=7
BSLASH=134
UARROW=136
RUBOUT=377
RUB177=177
LOWERA=141
LOWERZ=172
CTRLQ=21
COLON==72
DASH==55
COMMA=54
DOLLAR=44

FORTY1= 41
        LOC     FORTY1
        PUSHJ   P,UUO                   ;SET UP BRANCH TO UUOS IN LOC 41
        RELOC

SAVR1:  BLOCK   SAVEND-SAVBEG
SAVR1E: BLOCK   1
SAVR2:  BLOCK   SAVEND-SAVBEG
SAVR2E: BLOCK   1
SPTR:   BLOCK   3
LBUFF:  BLOCK   64
SAVE1:  0
SAVE2:  0
SAVE3:  0
CTEST2: 0
CTEST:  0
TTYSTA: 0
TTYFLG: 0
CHRCNT::        0               ;CHAR COUNT FOR TCO UUO
CNT:    0
ESCFLG: 0
SAVESC: 0
CLIN:   POPJ    P,              ;*CHANGE THIS*
CLOUT:  POPJ    P,              ;*CHANGE THIS*
LPTCTR: ^D63    ;LPT LINE COUNTER.  0-65.
PRVCHR: 12      ;PREVIOUS CHAR PRINTED ON LPT:
COUT::  0
SCHAR:  0
; BOTH OF THESE CELLS NEED TO BE INITIALIZED ZERO
CINFLG::0       ;NORMALLY ZERO.  WHEN NONZERO CONTAINS TERMINATING
;               CHARACTER FOR NAMES FILE.
GCHB::0         ;BUFFER TO HOLD CHAR AFTER CR/LF PAIR
UUO:    EXCH    R0,STKCNT#      ;EXCHANGE R0 AND STACK CONTENTS OF UUO
        HRRZS   (P)             ;SET ALL FLAGS TO ZERO
        EXCH    P,STKPTR        ;EXCHANGE OLD AND NEW STACK POINTERS
        CAMGE   P,STKPTR#       ;SKIP IF LOWER OR SAME LEVEL UUO CALL
        CAME    R0,(P)          ;SKIP IF NOT A NEW UUO CALL
        MOVE    P,STKPTR        ;SAVE NEW STACK POINTER
        CAMN    P,STKPTR        ;SKIP IF NOT A NEW UUO CALL
        MOVE    R0,(P)          ;SAVE CURRENT CONTENTS OF RETURN CELL
        EXCH    P,STKPTR        ;RE-EXCHANGE P AND STACK POINTER
        EXCH    R0,STKCNT       ;RE-EXCHANGE R0 AND STACK CONTENTS
        PUSH    P,R0
        LDB     R0,[POINT 9,FORTY,8]
        CAILE   R0,X            ;SKIP IF UUO NOT TOO BIG
        JRST    UUOERR          ;GO TO ERROR ROUTINE
        ADDI    R0,UUOTAB-1
        JRST    @R0
UUOERR: SETZM   .               ;EXECUTE THIS ROUTINE ONLY ONCE
        ERROR   [ASCIZ "ATTEMPT TO EXECUTE AN ILLEGAL UUO"]
;THE SSKE UUO SKIPS IF TWO STRINGS ARE EQUAL

SSKUUO: BLOCK   0
        LDB     R0,[POINT 4,FORTY,12] ;GET AC FIELD OF UUO
        SKIPN   R0              ;SKIP IF IT'S NOT ZERO
        HRR     R0,P            ;POINT TO STACK FOR R0
        HRRZ    R0,@R0          ;GET ADDRESS OF STRING PTR
        ADD     R0,[7B11-1]     ;DEC AND MAKE BYTE POINTER FOR 7 BIT
        MOVEM   R0,SKPT2        ;SAVE POINTER TO STRING
        HRR     R0,FORTY        ;GET ADDRESS OF FIRST STRING PTR
        SUBI    R0,1            ;DECREMENT TO POINT TO PRECEDING WORD
        MOVEM   R0,SKPT1        ;SAVE POINTER TO STRING
SSKELP: ILDB    R0,SKPT2        ;GET NEXT CHAR FROM SECOND STRING
        CAIN    R0,EOLIT        ;SKIP IF IT'S NOT THE END OF STRING
        JRST    UUOSKR          ;EVERYTHING MATCHES SO SKIP RETURN
        MOVEM   R0,SSKET        ;SAVE THE CHARACTER
        ILDB    R0,SKPT1        ;GET NEXT CHAR FROM FIRST STRING
        CAME    R0,SSKET        ;SKIP IF THE CHARACTERS ARE THE SAME
        JRST    UUORET          ;NOT EQUAL SO RETURN WITHOUT SKIPPING
        JRST    SSKELP          ;LOOP

SSKET:  0                       ;TEMP CELL

SKPT1:  0                       ;ADDRESS OF FIRST STRING

SKPT2:  0                       ;ADDRESS OF SECOND STRING
; THE TCI UUO READS ONE CHARACTER FROM THE TERMINAL. THE CHARACTER
; IS RETURNED IN THE CORE ADDRESS SPECIFIED AND IN THE AC
; SPECIFIED (UNLESS THE AC IS ZERO). CARRIAGE RETURN/LINEFEED
; PAIRS ARE REDUCED TO A SINGLE CARRIAGE RETURN.
; LINEFEEDS ARE ECHOED AS LINEFEED, CARRIAGE RETURN, RUBOUT.
; EDITTING AND BREAK CHARACTERS ARE DEFINED BY THE SETTTY UUO.
TCIUUO: PUSH    P,FORTY
        SKIPL   CTEST   ;IS THERE A LOOKAHEAD CHAR
        JRST    TCI3    ;NO
        AOS     CTEST   ;YES, CONSUME IT
TCI1:   MOVE    R0,SCHAR
TCI4:   POP     P,FORTY
        MOVEM   R0,SCHAR
        PUSHJ   P,CHATYP        ;GET THE CHARACTER TYPE
        CAIN    R0,TE           ;SKIP IF NOT A LINE TERMINATOR
        SETZM   CHRCNT          ;ZERO CHAR COUNT FOR NEW LINE
        PUSH    P,R0            ;SAVE THE TYPE ON THE STACK
        LDB     R0,[POINT 4,FORTY,12]
        POP     P,@R0           ;STORE TYPE IN APPROPRIATE REGISTER
        MOVE    R0,SCHAR
        EXCH    R0,0(P)
        POP     P,@FORTY
        POPJ    P,
TCI2:   MOVE    R0,[POINT 7,LBUFF-1,34]
        MOVEM   R0,SPTR
        MOVEM   R0,SPTR+1
        MOVEI   R0,^D260
        MOVEM   R0,SPTR+2
        RDLINE  SPTR
        JRST    .+1
TCI3:   SKIPE CINFLG
        JRST TCI5
        GCI     R0,SPTR
        JRST    TCI2
        JRST    TCI4
; THE TCL UUO IS IDENTICAL TO THE TCI UUO EXCEPT THAT THE
; CHARACTER IS NOT REMOVED FROM THE INPUT STRING.
TCLUUO: PUSH    P,FORTY
        SKIPGE  CTEST   ;IS THERE A LOOKAHEAD CHAR
        JRST    TCI1    ;YES, THIS TCL WAS PRECEDED BY ANOTHER TCL
        SOS     CTEST   ;NO, GET AND CREATE A LOOKAHEAD CELL
        JRST    TCI3


; GET CHAR FROM NAMES FILE


TCI5:   SKIPN GCHB      ;CHAR IN GCH BUFFER
        JRST TCI6       ;NO
        MOVE GCHB
        SETZM GCHB
        JRST TCI4
; READ ONE FROM FILE, REPLACE CR/LF PAIRS WITH COMMA
TCI6:   PUSHJ P,GCH
        JRST TCI8       ;EOF
        CAIE R0,CRCHR
        CAIN R0,12
        JRST TCI7
        JRST TCI4
; SAVE FIRST CHAR PAST CR/LF IN GCHB
TCI7:   PUSHJ P,GCH
        JRST TCI8
        CAIE R0,CRCHR
        CAIN R0,12
        JRST TCI7       ;THROW AWAY
        MOVEM GCHB
; REPLACE CR/LF'S WITH SINGLE COMMA
        MOVEI R0,54
        JRST TCI4
; END OF NAMES FILE.  PLUG IN CHAR READ AT CEOL.
TCI8:   RELEASE FIL,
        MOVE CINFLG
        SETZM GCHB
        SETZM CINFLG
        JRST TCI4

; PULL A CHAR FROM NAMES FILE AND SKIP IF NOT EOF
GCH:    SOSGE FILHD2##
        JRST GCH1
        ILDB R0,FILHD1##
        CAIN R0,0
        JRST GCH
        AOS (P)
        POPJ P,
GCH1:   IN FIL,
        JRST GCH
        GETSTS FIL,R0
        TRNN R0,740000
        JRST GCH2       ;PROBABLY EOF
        ERO [XWD[FILDI1##],[ASCIZ"TROUBLE READING NAMES FILE _J--"]]
        PUSHJ P,DWHY##
        ERROR [ASCIZ"ABORT"]
GCH2:   TRNE R0,020000
        POPJ P,
        JRST GCH

; CLOSE NAMES FILE.  USED AT CDISP AND ELSEWHERE

CRLS::  SKIPE CINFLG
        RELEASE FIL,
        SETZM CINFLG
        SETZM GCHB
        POPJ P,

CHATYP: PUSH    P,R1            ;SAVE R1 ON THE STACK
        PUSH    P,R2            ;SAVE R2 ON THE STACK
        MOVE    R1,R0           ;GET THE CHAR FROM R0
        IDIVI   R1,11           ;DIVIDE CHAR BY 9 TO LOOK UP TYPE
        LDB     R0,FS3(R2)      ;GET THE CHAR TYPE
        POP     P,R2            ;RESTORE R2 FROM STACK
        POP     P,R1            ;RESTORE R1 FROM STACK
        POPJ    P,              ;RETURN FROM SUBROUTINE

;INPUT CHARACTER DISPATCH MATRIX

FS3:    POINT   4,FS4(R1),3      ;BYTE POINTERS TO CLASSIFICATION TABLE
        POINT   4,FS4(R1),7
        POINT   4,FS4(R1),11
        POINT   4,FS4(R1),15
        POINT   4,FS4(R1),19
        POINT   4,FS4(R1),23
        POINT   4,FS4(R1),27
        POINT   4,FS4(R1),31
        POINT   4,FS4(R1),35

;       CLASSIFICATION TABLE FOR INPUT CHARACTERS
;       SECOND ALPHABET REPRESENTS LOWER CASE CHARACTER CODES

FS4:    BLOCK   0
BYTE (4)IG,IC,IC,IC,IC,IC,IC,IC,IC ;NUL SOH STX ETX EOT ENQ ACK BEL BS 
BYTE (4)IG,TE,IG,IG,TE,IC,IC,IC,IC ;HT  LF  VT  FF  CR  SO  SI  DLE DC1
BYTE (4)IC,IC,IC,IC,IC,IC,IC,IC,IC ;DC2 DC3 DC4 NAK SYN ETB CAN EM  SUB
BYTE (4)IC,IC,IC,IC,IC,SP,IC,IC,PO ;ESC FS  GS  RS  US  SP  !   "   #
BYTE (4)PU,IC,IC,PU,LP,RP,AS,IC,CO ;$   %   &   '   (   )   *   +   ,
BYTE (4)DA,EX,PU,NU,NU,NU,NU,NU,NU ;-   .   /   0   1   2   3   4   5
BYTE (4)NU,NU,NU,NU,IC,IC,IC,IC,IC ;6   7   8   9   :   ;   <   =   >
BYTE (4)QU,AT,AL,AL,AL,AL,AL,AL,AL ;?   @   A   B   C   D   E   F   G
BYTE (4)AL,AL,AL,AL,AL,AL,AL,AL,AL ;H   I   J   K   L   M   N   O   P
BYTE (4)AL,AL,AL,AL,AL,AL,AL,AL,AL ;Q   R   S   T   U   V   W   X   Y
BYTE (4)AL,LP,IC,RP,IC,IC,IC,IC,IC ;Z   [   \   ]   ^   _   '   A   B 
BYTE (4)IC,IC,IC,IC,IC,IC,IC,IC,IC ;C   D   E   F   G   H   I   J   K
BYTE (4)IC,IC,IC,IC,IC,IC,IC,IC,IC ;L   M   N   O   P   Q   R   S   T
BYTE (4)IC,IC,IC,IC,IC,IC,IC,IC,IC ;U   V   W   X   Y   Z   173 174 175
BYTE (4)IC,IG                      ;176 DEL

TABUUO: HRRZ    R0,FORTY
        SUB     R0,CHRCNT
TABLP:  SOJL    R0,UUORET
        TCO     [SPACE]
        JRST    TABLP

; THE GCI UUO READS ONE CHARACTER FROM THE FRONT OF A STRING
; AND INCREMENTS THE FIRST CHARACTER POINTER.
; IT SKIPS IF THE STRING IS NOT EMPTY.
; THE CHARACTER IS RETURNED IN THE SPECIFIED AC.
; THE ADDRESS PORTION OF THE INSTRUCTION POINTS TO A 3 WORD
; STRING POINTER. THE FORMAT OF THE STRING POINTER IS:
;
; PTR:   BYTE POINTER. POINTS TO THE CHARACTER POSITION PRECEEDING
;        THE FIRST CHARACTER IN THE STRING.
; PTR+1: BYTE POINTER. POINTS TO THE LAST CHARACTER IN THE STRING.
; PTR+2: LPTR,,RPTR
;
; LPTR IS THE NUMBER OF CHARACTER POSITIONS TO THE LEFT
; OF THE 1ST CHARACTER IN THE STRING. RPTR IS THE NUMBER
; OF CHARACTER POSITIONS TO THE RIGHT OF THE LAST
; CHARACTER IN THE STRING.
GCIUUO: PUSH    P,R1
        MOVE    R1,FORTY
        MOVE    R0,0(R1)
        CAMN    R0,1(R1)
        JRST    UUORE1
        HRLZI   R0,1
        ADDM    R0,2(R1)
        ILDB    R0,0(R1)
GCI2:   LDB     R1,[POINT 4,R1,12]
        MOVEM   R1,FORTY
        POP     P,R1
        EXCH    R0,0(P)
        POP     P,@FORTY
        JRST    UUOSK1
; THE GCD UUO READS ONE CHARACTER FROM THE END OF A STRING AND
; DECREMENTS THE LAST CHARACTER POINTER. THE CHARACTER IS
; RETURNED IN THE SPECIFIED AC. SEE 'GCI' UUO FOR A
; DESCRIPTION OF STRING POINTER WHICH IS ADDRESSED BY GCL UUO.
; GCL SKIPS IF THE STRING WAS NOT EMPTY.
GCDUUO: PUSH    P,R1
        MOVE    R1,FORTY
        MOVE    R0,0(R1)
        CAMN    R0,1(R1)
        JRST    UUORE1
        AOS     2(R1)
        LDB     R0,1(R1)
        DEC     1(R1)
        JRST    GCI2
; THE WCI UUO WRITES ONE CHARACTER TO THE END OF A STRING.
; IT SKIPS IF THE STRING DOES NOT OVERFLOW.
; THE LAST CHARACTER POINTER IS INCREMENTED.
; THE CHARACTER IS TAKEN FROM THE SPECIFIED AC. THE ADDRESS FIELD
; IS USED TO ADDRESS A SET OF STRING POINTERS.
WCIUUO: PUSH    P,R1
        MOVE    R1,FORTY
        MOVE    R0,2(R1)
        TRNN    R0,-1
        JRST    UUORE1
        SOS     2(R1)
        AOS     FORTY
        POP     P,R1
        LDB     R0,[POINT 4,FORTY,12]
        MOVEM   R0,1(P)
        MOVE    R0,0(P)
        MOVE    R0,@R1(P)
        IDPB    R0,@FORTY
UUOSKR: POP     P,R0
UUOSK1: AOS     0(P)
        POPJ    P,
; THE WCD UUO WRITES ONE CHARACTER TO THE FRONT OF A STRING.
; THE FIRST CHARACTER POINTER IS DECREMENTED. THE CHARACTER
; IS TAKEN FROM THE SPECIFIED AC. THE ADDRESS FIELD
; IS USED TO ADDRESS A SET OF STRING POINTERS.
; THE WCD UUO SKIPS IF THE STRING DOES NOT UNDERFLOW.
WCDUUO: PUSH    P,R1
        MOVE    R1,FORTY
        TLNN    R0,-1
        JRST    UUOSKR
        HRLZI   R0,1
        SUBM    2(R1)
        POP     P,R1
        LDB     R0,[POINT 4,FORTY,12]
        MOVEM   R0,1(P)
        MOVE    R0,0(P)
        MOVE    R0,@1(P)
        DPB     R0,@FORTY
        DEC     @FORTY
        JRST    UUOSKR
; THE RDLINE UUO READS ONE LINE FROM THE TELETYPE INTO A STRING
; DEFINED BY STRING POINTERS ADDRESSED BY THE UUO.
; EDITTING AND BREAK CHARACTERS ARE DEFINED BY THE SETTTY UUO.
; IF THE STRING OVERFLOWS, IT IS TREATED AS A BREAK CHARACTER.
RDUUO:  PUSH    P,R1
        PUSH    P,R2
        HRRZ    R2,FORTY
        MOVE    R0,0(R2)
        MOVEM   R0,SAVE1
        MOVE    R0,1(R2)
        MOVEM   R0,SAVE2
        MOVE    R0,2(R2)
        MOVEM   R0,SAVE3
        SETZM   CNT
        SKIPL   TTYFLG  ;HAS TTY STATUS BEEN SET?
        SETTTY  [0]     ;INITIALIZE TTY STATUS TO DEFAULT
RDL1:   PUSHJ   P,GETCHR
        CAIN    R0,CRCHR
        JRST    CR
        CAIN    R0,LFCHR
        JRST    LF
        MOVE    R1,TTYSTA
        TRNN    R1,2000
        JRST    RDX1
        CAIN    R0,3
        JRST    RDX2
        JRST    RDX
RDX1:   HRLZI   R1,-3
        CAMN    R0,ESCTAB(R1)
        JRST    .+3
        AOBJN   R1,.-2
        JRST    RDX
RDX2:   SKIPL   ESCFLG
        JRST    ESCR
        SETOM   SAVESC
RDX:    SKIPGE  CIN
        JRST    RDC
        MOVE    R1,TTYSTA
        TLNN    R1,40000
        TLNN    R1,600000
        JRST    RDC
        MOVE    R1,TTYSTA
        TRNN    R1,2000
        JRST    RDX3
        CAIN    R0,25
        JRST    CQ
        CAIN    R0,RUB177
        JRST    CA
        JRST    RDC
RDX3:   HRLZI   R1,-4
        CAMN    R0,CTAB1(R1)
        JRST    @CTAB2(R1)
        AOBJN   R1,.-2
RDC:    CAIG    R0,LOWERZ
        CAIGE   R0,LOWERA
        JRST    NCV
        MOVE    R1,TTYSTA
        TRNE    R1,400
        SUBI    R0,40
NCV:    WCI     R0,@R2
        PUSHJ   P,FERR
        HRRZ    R1,2(R2)
        JUMPE   R1,RDONE+1
        AOS     CNT
        MOVE    R1,TTYSTA
        TLNN    R1,440000
        JRST    RDC2
        CAIE    R0,CRCHR
        CAIN    R0,LFCHR
        JRST    RDONE
        JRST    RDL1
RDC2:   HRLZI   R1,-8
        CAML    R0,BITTAB(R1)
        JRST    .+2
        AOBJN   R1,.-2
        HLRE    R1,R1
        ADDI    R1,10
        CAIE    R1,7
        JRST    RDC3
        MOVE    R1,TTYSTA
        TLNN    R1,200000
        JRST    RDC3-1
        HRLZI   R1,-4
        CAMN    R0,CTAB1(R1)
        JRST    RDL1
        AOBJN   R1,.-2
        MOVEI   R1,7
RDC3:   MOVEI   R0,1
        LSH     0(R1)
        TDNN    R0,TTYSTA
        JRST    RDL1
RDONE:  AOS     -3(P)
        JRST    UUORE2
CQ:     OUTCHR  [UARROW]
        OUTCHR  [CRCHR]
        OUTCHR  [LFCHR]
        SKIPL   TTYSTA
        JRST    RDC
        MOVE    R0,SAVE1
        MOVEM   R0,0(R2)
        MOVE    R0,SAVE2
        MOVEM   R0,1(R2)
        MOVE    R0,SAVE3
        MOVEM   R0,2(R2)
        JRST    RDL1
CA:     SKIPL   TTYSTA
        JRST    CA2
        GCD     R0,@R2
        JRST    BELL
        OUTCHR  [BARROW]
        JRST    RDL1
CA2:    OUTCHR  [BARROW]
        JRST    RDC
CW:     SKIPL   TTYSTA
        JRST    CW2
        GCD     R0,@R2
        JRST    BELL
        OUTCHR  [BSLASH]
        JRST    .+3
        GCD     R0,@R2
        JRST    RDL1
        CAIN    R0,SPACE
        JRST    .-3
        GCD     R0,@R2
        JRST    RDL1
        CAIE    R0,SPACE
        CAIN    R0,COMMA
        JRST    RDC
        JRST    .-5
CW2:    OUTCHR  [BSLASH]
        JRST    RDC
CI:     MOVE    R0,CNT
        HRLZI   R1,-12
        CAMGE   R0,TAB(R1)
        JRST    CI2
        AOBJN   R1,.-2
        ADDI    R1,10
        CAML    R0,R1
        JRST    .-2
        JRST    .+2
CI2:    MOVE    R1,TAB(R1)
        SUB     R1,CNT
        MOVEI   R0,40
        HLL     R0,TTYSTA
        TLZ     R0,10000
        TLNE    R0,400000
        JRST    .+2
        TLNE    R0,100000
        TLO     R0,10000
        TLNN    R0,10000
        JRST    .+3
        WCI     R0,@R2
        JRST    RDONE
        AOS     CNT
        SUBI    R1,1
        JUMPG   R1,.-6
        TLNE    R0,10000
        JRST    RDL1
        MOVEI   R0,CTRLQ
        JRST    RDC
TAB:    EXP     10,20,30,40,50,60,70,100,110,120
BELL:   OUTCHR  [BELCHR]
        JRST    RDL1
LF:     MOVEI   R0,CRCHR
        PUSHJ   P,GIVCHR
        MOVEI   R0,LFCHR
        MOVE    R1,TTYSTA
        TRNE    R1,1000
        MOVEI   R0,CRCHR
        SKIPL   COUT
        OUTCHR  [RUBOUT]
        JRST    RDC
CR:     PUSHJ   P,GETCHR
        MOVEI   R0,CRCHR
        JRST    RDC
ESCTAB: EXP     175,33,37              ;*DO SOMETHING ABOUT THIS*
BITTAB: EXP     173,141,133,101,72,60,40,0
CTAB1:  EXP     R1,27,21,11
CTAB2:  EXP     CA,CW,CQ,CI
GETCHR: SKIPL   CIN
        JRST    RDTTY
        ERROR   [ASCIZ "COMMAND INPUT FILE NOT YET IMPLEMENTED"]
EOF:    DISABL
        PUSHJ   P,CLIN
        ENABLE
        MOVE    R0,[XWD SAVR1,SAVBEG]
        BLT     R0,SAVEND
RDTTY:  MOVE    R0,TTYSTA
        TLNN    R0,40000
        JRST    RDTTY2
        INCHWL  R0
        JRST    TTYDON
RDTTY2: INCHRW  R0
TTYDON: SKIPL   CIN
        SKIPGE  COUT
        JRST .+1        ;USED TO BE JRST GIVCHR
        POPJ    P,
; THE TCO UUO OUTPUTS ONE CHARACTER TO THE TERMINAL. CARRIAGE
; RETURN AND LINEFEED ARE TREATED SPECIALLY.
; FOR CARRIAGE RETURN, A CARRIAGE RETURN AND LINEFEED ARE SENT.
; FOR LINEFEED, A LINEFEED, CARRIAGE RETURN, AND RUBOUT ARE SENT.
; IF COUT IS NEGATIVE, THE RUBOUT IS NOT SENT. *CHANGE THIS*
GIVCHR: SKIPL   COUT
        JRST    WRTTY
        PUSH    P,R0
        MOVE    R0,[XWD SAVBEG,SAVR2]
        BLT     R0,SAVR2E
        PUSHJ   P,BYO
        ERROR   [ASCIZ "WRITE ERROR"]
        MOVE    R0,[XWD SAVR2,SAVBEG]
        BLT     R0,SAVEND       ;*THIS MAY NOT BE NECESSARY
        JRST    UUORET          ;RETURN FROM GIVCHR
WRTTY:  OUTCHR  R0
        POPJ    P,

;NEW TCO UUO 5/28/72
TCOUU:  MOVE    R0,(P)     ;RESTORE R0 IN CASE IT CONTAINED CHAR
        PUSH    P,R1            ;STACK R1
        MOVE    R0,@FORTY       ;LOAD CHAR INTO R0
        ANDI    R0,177          ;USE ONLY SEVEN BITS
        MOVEI   R1,0            ;ASSUME WE START IN STATE 0
        AOS     CHRCNT          ;INCREMENT CHARACTER COUNT
        CAIN    R0,CRCHR        ;SKIP IF CHAR IS NOT CARRIAGE RETURN
        MOVEI   R1,1            ;START IN STATE 1 FOR CARRIAGE RETURN
        CAIE    R0,LFCHR        ;SKIP IF CHAR IS NOT A LINE FEED
        JRST    TCOUU1          ;NOT A LINE FEED
        SOSN    TCOSTA          ;SKIP IF LAST CHAR WAS NOT A CR
        JRST    UUORE1          ;IGNORE A LINE FEED AFTER A CR
        MOVEI   R1,2            ;START IN STATE 2 FOR LINE FEED
TCOUU1: CAIE    R1,0            ;SKIP IF NOT END OF LINE
        SETZM   CHRCNT          ;ZERO THE CHARACTER COUNT
        MOVEM   R1,TCOSTA#      ;SAVE STATE OF LAST CHAR OUTPUT
        SKIPA                   ;SKIP TO START OF THE ROUTINE
TCOLP:  LDB     R1,[POINT 2,TCOTAB(R1),21] ;LOAD NEW STATE
        JRST @TCOUU7    ;GO TO APPROPRIATE OUTPUT ROUTINE
TCOUU4: SKIPL   COUT            ;SKIP IF OUTPUT NOT TO TERMINAL
TCOUU5: OUTCHR  R0              ;OUTPUT CHAR TO TERMINAL
        SKIPGE  COUT            ;DON'T SKIP IF OUTPUT TO FILE
        PUSHJ   P,BYO           ;OUTPUT CHAR TO FILE
TCOUU8: LDB     R0,[POINT 7,TCOTAB(R1),17] ;LOAD NEXT CHAR
        SKIPL   TCOTAB(R1)      ;SKIP IF WE ARE ALL DONE
        JRST    TCOLP           ;LOOP FOR NEXT CHAR
        JRST    UUORE1
TCOUU6: OUTCHR R0
        JRST TCOUU8
TCOUU7: JRST TCOUU4
EROSW:: -1

TCOTAB: XWD     -1,0            ;STATE 0 - RETURN FROM UUO
        XWD     LFCHR,0         ;STATE 1 - GO TO STATE 0 AND OUTPUT LF
        XWD     3000+CRCHR,0    ;STATE 2 - GO TO STATE 3 AND OUTPUT CR
        XWD     RUBOUT,0        ;STATE 3 - GO TO STATE 0 AND OUTPUT RUBOUT

COF==   2                       ;*THIS SHOULD NOT BE HERE
BYO:    TRNN F,LPTFLG##         ;ARE WE OUTPUTING TO LPT:
        JRST LPT6               ;NO
        CAIE TOFCHR
        JRST LPT3       ;NOT TOP OF FORM
LPT2:   SETZM LPTCTR    ;SET TO LINE 0
        SETZM PRVCHR    ;SET TO NO PREVIOUS CHARACTER
        PUSHJ P,BYOO
        POPJ P,
LPT3:   PUSH P,R0       ;SAVE R0 ON THE STACK
        MOVE PRVCHR
        CAIE LFCHR   ;WAS PREVIOUS CHAR LF
        JRST LPT4       ;NO
        MOVE LPTCTR
        CAIE ^D63    ;TIME TO EJECT PAGE
        JRST LPT4       ;NO
        MOVEI TOFCHR
        PUSHJ P,LPT2
LPT4:   SKIPE LPTCTR    ;ARE WE AT TOP OF FORM
        JRST LPT5       ;NO
        MOVEI 3
        ADDM LPTCTR     ;ADVANCE TO LINE 3
        MOVEI CRCHR
        PUSHJ P,BYOO
        MOVEI LFCHR
        PUSHJ P,BYOO
        PUSHJ P,BYOO
        PUSHJ P,BYOO
LPT5:   POP P,R0        ;RETRIEVE R0
        MOVEM PRVCHR    ;SAVE LAST CHAR
        CAIN LFCHR
        AOS LPTCTR
LPT6:   PUSHJ P,BYOO
        POPJ P,
BYOO:   SOSG    COFHD2##        ;DECREMENT CHAR COUNT - SKIP IF BUFF NOT FULL
        PUSHJ   P,COFOUT        ;OUTPUT THE BUFFER
        IDPB    R0,COFHD1##     ;DEPOSIT THE BYTE
        POPJ    P,              ;RETURN
COFOUT: OUT     COF,            ;OUTPUT THE BUFFER
        POPJ    P,              ;SUCCESSFUL SO RETURN
        ERROR   [ASCIZ "ERROR IN WRITING TO OUTPUT FILE"]

; THE DEC UUO DECREMENTS A BYTE POINTER. THE ADDRESS FIELD
; SHOULD ADDRESS A PDP10 BYTE POINTER.
DECUUO: PUSH    P,R1
        LDB     R1,[POINT 6,@FORTY,5]
        LDB     R0,[POINT 6,@FORTY,11]
        ADD     R1,R0
        CAIGE   R1,^D36
        JRST    DEC2
        MOVE    R1,R0
        MOVEI   R0,^D36
        IDIV    R0,R1
        SOS     @FORTY
DEC2:   DPB     R1,[POINT 6,@FORTY,5]
        JRST    UUORE1
; THE TYPE UUO OUTPUTS A STRING TO THE TERMINAL.
; THE ADDRESS SHOULD POINT TO THE DESIRED MESSAGE.
; DOLLAR SIGNS ARE INTERPRETED AS CARRIAGE RETURNS
TYPUUO: PUSH    P,R1
        PUSH P,R2       ;NOT NEEDED BUT LETS US SHARE CODE AT UUORE3
        MOVEI R1,TCOUU6
        AOSN EROSW
        MOVEM R1,TCOUU7
        HRRZ    R1,FORTY
        HRLI    R1,10700
        SUBI    R1,1
TYP1:   ILDB    R0,R1
        CAIN    R0,DOLLAR
        MOVEI   R0,CRCHR
        CAIN    R0,EOLIT        ;SKIP IF NOT END OF STRING
        JRST    UUORE3
        TCO     R0
        JRST    TYP1
UUORE3: SKIPL EROSW
        SOS EROSW
UUORE2::POP     P,R2
UUORE1: POP     P,R1
UUORET::POP     P,R0
        POPJ    P,

; OUTPUT TO TERMINAL ONLY
ERTUUO: PUSH P,R1
        MOVEI R1,TCOUU6
        JRST ERO1A
; OUTPUT TO BOTH TERMINAL AND OUTPUT MEDIUM
ERBUUO: PUSH P,R1
        MOVEI R1,TCOUU5
        JRST ERO1A
; OUTPUT TO OUTPUT MEDIUM ONLY
EROUUO: PUSH    P,R1
        MOVEI R1,TCOUU4
ERO1A:  AOSN EROSW
        MOVEM R1,TCOUU7
        PUSH    P,R2
        HRRZ    R1,FORTY
        HLRZ    R2,(R1)
        HRRZ    R0,(R1)
        HRLI    R0,10700
        SUBI    R0,1
ERO1:   ILDB    R1,R0
        CAIN    R1,DOLLAR       ;SKIP IF CHAR IS A DOLLAR SIGN
        MOVEI   R1,CRCHR        ;CONVERT DOLLAR INTO CR
        SKIPL   STKCNT          ;SKIP IF RET ADDR HAS BEEN CHANGED
        CAIN    R1,EOLIT        ;SKIP IF NOT END OF STRING
        JRST    UUORE3          ;DONE WITH MESSAGE
        CAIN    R1,BARROW       ;SKIP NO CONTROL CHARACTER FOLLOWS
        JRST    ERO2            ;PROCESS CONTROL CHARACTER
        TCO     R1
        JRST    ERO1            ;LOOP
ERO2:   ILDB    R1,R0           ;GET CONTROL CHAR FROM STRING
        ADDI    R1,EROTAB-101   ;GET ADDRESS OF ENTRY IN TABLE
        MOVE    R1,(R1)         ;GET ADDRESS OF ROUTINE
        PUSH    P,R0            ;ROUTINES MUST PRESERVE ALL BUT R0 & R1
        MOVE    R0,(R2)         ;GET NEXT VARIABLE FROM LIST
        TLNE    R1,400000       ;SKIP IF WE WANT THE ADDRESS
        MOVE    R0,@R0          ;GET VALUE POINTED TO BY THE ADDRESS
        AOJ     R2,             ;POINT TO NEXT VARIABLE IN LIST
        PUSHJ   P,(R1)          ;BRANCH TO PROPER ROUTINE
        POP     P,R0            ;RESTORE R0 FROM STACK
        JRST    ERO1            ;LOOP
EROTAB: BLOCK   0               ;ADDRESSES OF ROUTINES FOR ERO FORMAT CHARACTERS
        XWD     400000,EROUN    ;A - USER NAME
        XWD     000000,EROFN    ;B - FILE NAME
        XWD     400000,PRDNUM   ;C - DECIMAL NUMBER
        XWD     000000,EROMG    ;D - MESSAGE
        XWD     000000,EROBR    ;E - BRANCH
        XWD     000000,EROCL    ;F - CLEAR INPUT
        XWD     000000,EROCB    ;G - BRANCH ON CONFIRMATION
        XWD     400000,PRONUM   ;H - OCTAL NUMBER
        XWD     000000,ERODF    ;I - QUIT IF DEFAULT FLAG NOT SET
        XWD     000000,EROUF    ;J - USER NAME AND FILE NAME
        XWD     400000,EROPP    ;K - PPN
        XWD     400000,ERODT    ;L - DATE AND TIME
        XWD     400000,EROTD    ;M - PRINT TAPE DIR. USER NAME
        XWD     400000,EROISC   ;N - PRINT FW INTEGER FOR RADIX GIVEN
        XWD     400000,EROBPI   ;O - PRINT BPI FROM LH AND TRACKS FROM RH
        XWD     400000,EROSYS   ;P - PRINT STRING FROM BYTE PTR
        XWD     400000,EROFF    ;Q - PRINT TAPE DIR. FILENAME
        XWD     400000,EROFD    ;R - PRINT TAPE DIR. CREATION DATE
        XWD     000000,EROSE    ;S - PRINT TAPE SERIAL OR DEV NAME
        XWD     0,0             ;T - UNASSIGNED
        XWD     0,0             ;U - UNASSIGNED
        XWD     0,0             ;V - UNASSIGNED
        XWD     0,0             ;W - UNASSIGNED
        XWD     0,0             ;X - UNASSIGNED
        XWD     400000,EROUY    ;Y - PRINT USER NAME FROM DUL
        XWD     0,EROUZ    ;Z - PRINT USERNAME AND FILENAME USING DUL

EROMG:  HRRZ    R0,R0           ;CLEAR ALL BUT ADDRESS FOR INDIRECT REFERENCE
        ERO     @R0             ;RECURSIVE CALL TO MESSAGE ROUTINE
        POPJ    P,              ;RETURN

;CLEAR INPUT BUFFER
EROCL:
        CLRIN                   ;CLEAR INPUT BUFFER
        SOJA    R2,CPOPJ##      ;PUT BACK UNNEEDED VARIABLE AND RETURN
EROUY:  TRNE F,TRTFLG## ;ARE WE TRANSLATING
        TRO F,FSTFLG##  ;YES, SET FLAG TO USE DUL INSTEAD OF FAST DUL
        PUSHJ P,EROUN
        POPJ P,
EROUN:  PUSHJ   P,FSTDUL        ;CONVERT PPN TO USER NAME
        JRST    EROPP           ;NO USER NAME FOUND SO PRINT PPN
        PUSH    P,R2            ;SAVE R2 ON STACK
        PUSH    P,R0            ;PUT FIRST HALF OF USER NAME ON STACK
        PUSH    P,R1            ;PUT SECOND HALF OF USER NAME ON STACK
        MOVEI   R0,-2(P)        ;GET POINTER TO USER NAME -1
        HRLI    R0,0600         ;MAKE A SIXBIT STRING POINTER
        MOVE    R1,[XWD -14,1]  ;GET LOOP INDEX AND CHAR COUNT
        PUSH    P,R1            ;PUT CHAR COUNT ON STACK
        ILDB    R2,R0           ;GET NEXT CHAR FROM USER NAME
        SKIPE   R2              ;SKIP IF IT'S A BLANK
        HRRZM   R1,(P)          ;UPDATE POS OF LAST NONBLANK CHAR
        AOBJN   R1,.-3          ;LOOP
        POP     P,R1            ;GET CHAR COUNT FROM THE STACK
        MOVEI   R0,-2(P)        ;GET POINTER TO USER NAME -1 AGAIN
        HRLI    R0,0600         ;MAKE SIXBIT STRING POINTER AGAIN
        TCO     [LPAREN]        ;OUTPUT LEFT PAREN BEFORE USER NAME
        ILDB    R2,R0           ;GET NEXT CHAR FROM USER NAME
        ADDI    R2,40           ;CONVERT FROM SIXBIT TO ASCII
        TCO     R2              ;OUTPUT THIS CHAR OF USER NAME
        SOJG    R1,.-3          ;LOOP UNTIL ALL OF USER NAME IS TYPED
        TCO     [RPAREN]        ;OUTPUT RIGHT PAREN AFTER USER NAME
        POP     P,R1            ;GET SECOND HALF OF USER NAME FROM STACK
        POP     P,R0            ;GET FIRST  HALF OF USER NAME FROM STACK
        POP     P,R2            ;RESTORE R2 FROM STACK
        POPJ    P,              ;RETURN FROM EROUN
EROPP:  TCO     [LBRACK]        ;OUTPUT A LEFT BRACKET
        LSHC    R0,-22          ;RIGHT SHIFT HALF WORD INTO R1
        PUSHJ   P,PRONUM        ;PRINT GLOBAL ACCT NUMBER
        TCO     [COMMA]
        HLRZ    R0,R1           ;PUT USER NUMBER BACK IN R0
        PUSHJ   P,PRONUM        ;PRINT UNIVERSAL USER NUMBER
        TCO     [RBRACK]        ;PRINT A RIGHT BRACKET
        POPJ    P,              ;RETURN
; PRINT FILENAME WITH RESPECT TO TAPHED
EROFF:  ADDI R0,6 ;POINT TO FILENAME
        PUSHJ P,EROFN ;PRINT FILENAME
        POPJ P,
; PRINT USERNAME OF FILE ENTRY WITH RESPECT TO TAPHED
EROTD:  MOVE R1,R0
        MOVE R0,5(R1)
        PUSHJ P,FSTDUL
        JRST EROTD2     ;JUST TAB 12 SPACES
        PUSH P,R2       ;SAVE R2 ON STACK
        PUSH P,R0       ;SAVE USER NAME ON STACK
        PUSH P,R1       ;SAVE 2ND HALF OF USER NAME ON STACK
        MOVEI R0,-2(P)  ;BYTE POINTER TO USER NAME -1
        HRLI R0,0600    ;MAKE SIXBIT POINTER
        MOVEI R1,14
        ILDB R2,R0
        ADDI R2,40
        TCO R2
        SOJG R1,.-3
        POP P,R1        ;UNWIND STACK
        POP P,R0
        POP P,R2
        POPJ P,
EROTD2: MOVEI R1,14
        TCO [40]
        SOJG R1,.-1
        POPJ P,
; PRINT DATE OF FILE ENTRY WITH RESPECT TO TAPHED
EROFD:  ADDI R0,6       ;POINT TO FILENAME
        MOVE R1,R0
        MOVE    R0,2(R1)        ;GET CREATION DATE AND TIME
        TLNN    F,T12FLG        ;SKIP IF NEW FORMAT TAPE
        JRST    EROFD1          ;DATE AND TIME ALREADY IN RIGHT FMT
        PUSH    P,R2            ;SAVE R2 ON STACK
        LDB     R2,[POINT 2,1(R1),21];GET HIGH BITS OF CRE DATE
        DPB     R2,[POINT 2,R0,23];SAVE HIGH BITS OF CRE DATE
        LDB     R2,[POINT 11,2(R1),23];GET CREATION TIME
        DPB     R2,[POINT 11,R0,21];SAVE CREATION TIME
        POP     P,R2            ;RESTORE R2 FROM STACK
EROFD1: PUSHJ   P,ERODT         ;PRINT DATE AND TIME
        POPJ    P,              ;RETURN FROM EROFD
EROUZ:  TRNE F,TRTFLG   ;ARE WE TRANSLATING
        TRO F,FSTFLG    ;YES, USE DUL
        PUSHJ P,EROUF
        POPJ P,
EROUF:  PUSH    P,R0            ;SAVE ADDRESS OF FILE NAME ON STK
        MOVE    R0,@R0          ;GET PPN
        PUSHJ   P,EROUN         ;PRINT USER NAME
        POP     P,R0            ;RESTORE R0 FROM STACK (ADDR OF ARG)
        AOJ     R0,             ;POINT TO FILE INSTEAD OF PPN
EROFN:  PUSH    P,R2            ;SAVE R2 ON STACK
        MOVE    R2,R0           ;PUT ADDRESS OF FILE NAME IN R2
        HRLI    R2,0600         ;MAKE SIXBIT BYTE STRING
        HLRZ    R1,1(R2)        ;GET THE EXTENSION
        CAIN    R1,(SIXBIT /UFD/);SKIP IF NOT A UUFD
        JRST    EROUFD          ;*SHOULD ALSO CHECK PPN
        SOJ     R2,             ;DECREMENT TO POINT TO WORD BEFORE
        MOVEI   R1,6            ;PRINT SIX CHARACTER FILE NAME
EROFN1: ILDB    R0,R2           ;GET NEXT CHARACTER
        ADDI    R0,40           ;CONVERT FROM SIXBIT TO ASCII
        TCO     R0              ;PRINT THE CHARACTER
        SOJG    R1,EROFN1       ;LOOP IF NOT DONE
ERODOT: TCO     [DOTCHR]        ;PRINT DOT FOR FILE OR UFD
        MOVEI   R1,3            ;PRINT THREE CHARACTERS
EROFN2: ILDB    R0,R2           ;GET NEXT CHARACTER
        ADDI    R0,40           ;CONVERT FROM SIXBIT TO ASCII
        TCO     R0              ;OUTPUT NEXT CHAR OF EXTENSION
        SOJG    R1,EROFN2       ;LOOP IF NOT DONE WITH EXTENSION
        POP     P,R2            ;RESTORE R2 FROM STACK
        POPJ    P,              ;RETURN
EROUFD: HLRZ    R0,(R2)         ;GET THE GLOBAL ACCT NUMBER
        PUSHJ   P,PRONUM        ;PRINT THE GAN
        TCO     [COMMA]         ;PRINT A COMMA
        HRRZ    R0,(R2)         ;GET THE UNIVERSAL USER NUMBER
        PUSHJ   P,PRONUM        ;PRINT THE UUN
        JRST    ERODOT          ;PRINT DOT AND THE EXTENSION
EROCB:  PUSH    P,R2            ;SAVE R2 ON STACK
        HRRZS   R0              ;TURN OFF SIGN BIT ON ADDR FOR FAIL RET
        TCI     R1,R2           ;INPUT FIRST CHAR OF RESPONSE
        CAIE    R2,CRCHR        ;SKIP IF IT'S A CARRIAGE RETURN
        CAIN    R2,YCHR         ;SKIP IF IT'S NOT THE CHAR Y
        TLOA    R0,400000       ;SET SIGN BIT ON ADDR FOR YES RET & SKIP
        TCI     R1,R2           ;INPUT NEXT CHAR OF RESPONSE
        CAIE    R1,TE           ;SKIP IF END OF LINE
        JRST    .-2             ;READ MORE UNTIL END OF LINE
        POP     P,R2            ;RESTORE R2 FROM STACK
        JUMPGE  R0,CPOPJ        ;RETURN IF NO
EROBR:  HRLI    R0,400000       ;SET SIGN BIT TO MARK RET AS CHANGED
        MOVE    R1,STKPTR       ;GET INDEX INTO STACK
        MOVEM   R0,(R1)         ;PUT NEW RETURN ADDR IN STACK
        MOVEM   R0,STKCNT       ;ALSO UPDATE CURRENT STACK CONTENTS
        POPJ    P,              ;RETURN TO RESTORE REGISTERS ETC.
ERODF:  AND     R0,DEFALT#      ;IF ZERO WE SHOULD QUIT
        JUMPN   R0,CPOPJ        ;RETURN IF NON ZERO
        MOVE    R0,STKCNT       ;RETURN TO SAME PLACE WE WOULD ANYWAY
        JRST    EROBR           ;TURN ON BIT TO END FORMAT
;*-

CLRUUO: CLRBFI  0              ;*THIS UUO SHOULD ALSO KILL CMD FILES*
        MOVE    R0,[POINT 7,LBUFF-1,34]
        MOVEM   R0,SPTR
        MOVEM   R0,SPTR+1
        MOVEI   R0,^D260
        MOVEM   R0,SPTR+2
        SETZM   CTEST
        SETZM   CTEST2
        PUSHJ P,CRLS    ;CLOSE NAMES FILE IF OPEN
        PUSHJ   P,CLIN
        PUSHJ   P,CLOUT
        JRST    UUORET
; THE TTY UUO IS USED TO DEFINE EDITTING AND BREAK CHARACTERS
; FOR TCI, TCL, AND RDLINE. THE ADRESS PORTION SHOULD POINT
; TO THE NEW TTY STATUS WORD. THE OLD ONE IS RETURNED IN THE
; SPECIFIED AC (UNLESS THE AC IS ZERO). IF THE NEW STATUS WORD
; IS ILLEGAL, IT DOES NOT REPLACE THE OLD ONE, BUT THE OLD ONE
; IS STILL RETURNED IN THE SPECIFIED AC. THIS ALLOWS
; READING OF THE STATUS WORD WITHOUT CHANGING IT BY SPECIFYING
; AN ILLEGAL STATUS WORD.
; A STATUS WORD MUST EITHER HAVE BIT 0, BIT 3 OR ANY ONE OF BITS
; 28-35 TURNED ON TO BE LEGAL.
; THE BIT DEFINITIONS ARE:
;  0 - COMMAND EDIT MODE. CONTROL A, W, Q, AND I EDITTING ARE
;      DONE. BREAKS ONLY ON CARRIAGE RETURN OR LINEFEED.
;      CONTROL A ECHOES "_". CONTROL W ECHOES "\". CONTROL Q
;      ECHOES "^", CARRIAGE RETURN, LINEFEED.
;      CONTROL I (TAB) ECHOES THE PROPER NUMBER OF BLANKS WHICH
;      ARE ALSO SENT TO THE PROGRAM.
;  1 - SPECIAL ECHO MODE. THE CONTROL CHARACTERS A, W, AND Q
;      ARE ECHOED AS IN COMMAND EDIT MODE. HOWEVER, NO EDITTING
;      IS DONE. THE EDITTING CHRACTERS ARE PASSED TO THE
;      PROGRAM. BREAKS ACCORDING TO BREAK BITS BUT WILL NOT
;      BREAK ON CONTROL A, W, Q, OR I.
;      CONTROL I STILL SENDS THE PROPER NUMBER OF BLANKS TO THE
;      PROGRAM AND THE CONTROL I IS NOT SENT.
;  2 - SUPPRESS TABS. THIS BIT CAUSED "SPECIAL ECHO" MODE
;      TO SUPPRESS TABS. CONTROL I WILL STILL ECHO BLANKS
;      BUT THE BLANKS WILL NOT BE SENT TO THE PROGRAM. THE
;      CONTROL I WILL BE SENT INSTEAD.
;  3 - SYSTEM EDITTING. EDITTING IS DONE BY THE MONITOR. BREAK
;      CHARACTERS ARE CARRIAGE RETURN AND LINEFEED.
; 25 - PDP10/TYMEX FLAG. NOT SETTABLE BY USER. 1 = PDP10.
;      0 = TYMEX.
; 26 - CONVERT LINEFEEDS TO CARRIAGE RETURNS.
; 27 - CONVERT LOWER CASE ALPHA TO UPPER CASE ALPHA.
; 28 - BREAK ON CONTROL CHARACTERS (001-037).
; 29 - BREAK ON PUNCTUATION GROUP 1 (40-57).
; 30 - BREAK ON NUMBERS (60-71).
; 31 - BREAK ON PUNCTUATION GROUP 2 (72-100).
; 32 - BREAK ON UPPER CASE ALPHA (101-132).
; 33 - BREAK ON PUNCTUATION GROUP 3 (133-140).
; 34 - BREAK ON LOWER CASE ALPHA (141-172).
; 35 - BREAK ON PUNCTUATION GROUP 4 (173-176).
;
; TTY STATUS IS EFFECTIVEY INITIALIZED AS "40000,,400".
TTYUUO: SKIPGE  TTYFLG
        JRST    TTY2
        PUSH    P,FORTY
        DISABL
        SOS     TTYFLG
        SETTTY  [XWD 40000,400]
        ENABLE
        POP     P,FORTY
TTY2:   PUSH    P,R1
        MOVE    R1,[XWD -1,6]
        GETTAB  R1,
        PUSHJ   P,FERR          ;FATAL ERROR
        MOVE    R0,@FORTY
        ANDCMI  R0,2000
        TRNN    R1,200
        IORI    R0,2000
        POP     P,R1
        TLNN    R0,440000
        TRNE    R0,377
        JRST    .+2
        MOVE    R0,TTYSTA
        EXCH    R0,TTYSTA
        PUSH    P,R0
        LDB     R0,[POINT 4,FORTY,12]
        POP     P,@R0
        JRST    UUORET

COFRLS::SKIPE COUT
        RELEASE COF,
        SETZM COUT
        PUSH P,R0
        MOVEI ^D63
        MOVEM LPTCTR
        MOVEI LFCHR
        MOVEM PRVCHR
        TRZ F,LPTFLG    ;NOT USING LPT:
        POP P,R0
        POPJ P,

ERRUUO: MOVE    R0,FORTY
        SETOM DULL##
        SETOM LUDL##
;*      SKIPG UNISW             ;DON'T RESET COUT IN NXTTAP CODE
;*      PUSHJ P,COFRLS          ;CLOSE COF FILE
        TYPE    @R0
        CLRIN                   ;CLEAR INPUT BUFFER
        SKIPG   UNISW##         ;HAVE WE ENTERED UNIT YET
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER
        MOVE P,ERRSTP##         ;RESTORE STACK PTR
        JRST    @UNISW          ;LET THEM RETYPE TAPE DEVICE NAME
ENUUO:  POP     P,R0
        AOSL    ESCFLG
        SKIPL   SAVESC
        POPJ    P,
        JRST    ESCR
DISUUO: SOS     ESCFLG
        JRST    UUORET


;PRINT OCTAL NUMBER ON TERMINAL
; CALL WITH NUMBER IN R0

PRONUM::HRLM    R0,(P)          ;PUT THAT DIGIT ON THE STACK
        LSH     R0,-3           ;RIGHT SHIFT THREE
        SKIPE   R0              ;SKIP IF THERE ARE NO MORE DIGITS
        PUSHJ   P,PRONUM        ;DO IT AGAIN
        HLRZ    R0,(P)          ;GET NEXT DIGIT OFF THE STACK
        TRZ     R0,777770       ;SAVE ONLY RIGHT THREE BITS
        ADDI    R0,"0"          ;CONVERT IT TO A CHARACTER
        TCO     R0              ;TYPE IT
        POPJ    P,              ;TYPE NEXT DIGIT OR RETURN

;PRINT DECIMAL NUMBER ON TERMINAL
; CALL WITH NUMBER IN R0

PRDNUM::IDIVI   R0,12           ;DIVIDE BY TEN FOR NEXT DIGIT
        HRLM    R1,(P)          ;STICK THE DIGIT IN THE STACK
        SKIPE   R0              ;SKIP IF WE'VE GOT ALL THE DIGITS
        PUSHJ   P,PRDNUM        ;GET THE NEXT DIGIT
        HLRZ    R0,(P)          ;GET THE NEXT DIGIT FROM THE STACK
        ADDI    R0,"0"          ;CONVERT NUMBER TO CHARACTER
        TCO     R0              ;OUTPUT THE CHARACTER
        POPJ    P,              ;GET NEXT DIGIT OR RETURN
; PRINT DEVICE NAME FOR VERSION>14
EROSE:  PUSH P,R2
        MOVEI R2,6
        SUBI R0,1
        HRLI R0,0600
EROSE2: ILDB R1,R0
        CAIN R1,0
        JRST EROSE3
        ADDI R1,40
        TCO R1
        SOJG R2,EROSE2
EROSE3: POP P,R2
        POPJ P,

;PRINT OCTAL OR DECIMAL NO. IN GIVEN FIELD WIDTH WITH LEADING BLANKS
;REQUIRES TWO ARGUMENTS:  FIRST THE CELL TO BE PRINTED OUT, SECOND
;CONTAINS RADIX IN LH AND FIELD WIDTH IN RH.  THE NO. TO BE PRINTED
;IS IN R0 AND R2 POINTS AT THE SECOND ARG.
EROISC: MOVE R1,(R2)
        HLRZM R1,RADIX#
        HRRZM R1,FW#
        AOS R2
EROIS:  IDIV R0,RADIX
        HRLM R1,(P)             ;SAVE DIGIT IN LH OF STACK
        SOS FW
        SKIPE R0
        PUSHJ P,EROIS
EROIS1: SKIPG FW
        JRST EROIS2
        TCO [40]
        SOS FW
        JRST EROIS1
EROIS2: HLRZ R0,(P)
        ADDI R0,"0"
        TCO R0
        POPJ P,

;PRINT BPI AND NO. OF TRACKS
EROBPI: HLRZM R0,BP#
        HRRZM R0,TR#
        ERO [XWD[BP
TR],[ASCIZ"_C BPI _C TRACK"]]
        POPJ P,
;PRINT STRING OF WIDTH N CHARS FROM BYTE POINTER IN R0
; WIDTH N IS IN BITS 12-17 OF R0 WHICH ARE CLEARED SO INDEXING IS
; NOT POSSIBLE
EROSYS: PUSH P,R1
        PUSH P,R2
        SETZ R1,
        LDB R2,[POINT 6,R0,11]
        CAIN R2,6
        MOVEI R1,40
        MOVEM R1,FW
        LDB R2,[POINT 6,R0,17]
        TLZ R0,77
        ILDB R1,R0
        ADD R1,FW
        TCO R1
        SOJG R2,.-3
        POP P,R2
        POP P,R1
        POPJ P,

;PRINT A TWO DIGIT DECIMAL NUMBER TO THE TERMINAL
; CALL WITH NUMBER IN R0

PRD2N:: IDIVI   R0,12           ;DIVIDE BY TEN TO SEPARATE DIGITS
        ADDI    R0,60           ;CONVERT FIRST NUMBER TO CHARACTER
        TCO     R0              ;OUTPUT THE CHARACTER
        ADDI    R1,60           ;CONVERT SECOND NUMBER TO CHARACTER
        TCO     R1              ;OUTPUT THAT CHARACTER
        POPJ    P,              ;RETURN

;READ DECIMAL/OCTAL NUMBER
; RETURN NUMBER IN R0, TERMINATING CHAR IN CH, TYPE IN CT
; RETURN NUMBER OF CHARACTERS IN NUMBER IN R1

RDONUM::SKIPA   R1,[10]         ;SET BASE TO EIGHT
RDDNUM::MOVEI   R1,12           ;SET BASE TO TEN
        PUSH    P,R1            ;SAVE BASE ON THE STACK
        SETZB   R1,R0           ;ZERO THE ACCUMULATOR AND CHAR COUNT
RDNU1:  TCI     CT,CH           ;READ NEXT CHAR
        CAIE    CT,NU           ;SKIP IF IT'S A DIGIT
        JRST    RDNRET          ;ANYTHING ELSE IS A TERMINATOR SO RET
        IMUL    R0,(P)          ;MULTIPLY ACCUMULATOR BY BASE
        ADD     R0,CH           ;ADD IN THE NEW DIGIT
        SUBI    R0,60           ;CONVERT NEW DIGIT FROM CHAR TO NUMBER
        AOJA    R1,RDNU1        ;INCREMENT CHAR COUNT AND GET NEXT CHAR
RDNRET: POP     P,(P)           ;POP STACK TO THROW AWAY THE BASE
        POPJ    P,              ;RETURN FROM RDDNUM OR RDONUM
;
;READ SIXBIT STRING FOR DEVICE NAME
;NAME RETURNED IN R0 AND COMBUF

RDUNI:: MOVE R1,[-7,,0]
        SETZM R0
        MOVE R2,[POINT 6,0]	; [POINT 6,-1,35]
RUNI:   TCI     CT,CH           ;READ A CHAR
        CAIE    CT,SP           ;IS IT A SPACE
        CAIN    CT,TE           ;IS IT A TERMINATOR
        POPJ P,
        CAIN CH,COLON
        JRST RUNI1
        ADDI    CH,40           ;CONVERT TO SIXBIT
        AOBJN R1,.+2
        ERROR [ASCIZ"DEVICE NAME TOO VERBOSE."]
        IDPB CH,R2
        JRST RUNI
RUNI1:  TCI CT,CH
        CAIE CT,SP
        CAIN CT,TE
        POPJ P,
        JRST RUNI1

;PRINT THE DATE AND TIME FROM AC A
;FOR MONITORS P012 OR LATER THE DATE IS DAYS SINCE JAN 1, 1964 GMT
; AND THE TIME IS MINUTES SINCE MIDNIGHT GMT
; WITH THE DATE IN BITS 22-35 AND THE TIME IN BITS 11-21.
;THE OLD FORMAT IS:
;DATE = ((Y-1964)*12+M-1)*31+D-1 IN BITS 24-35
;TIME IN MINUTES SINCE MIDNITE IN BITS 13-23

ERODT:  PUSH    P,R2            ;SAVE R2 ON THE STACK
        TLNN    F,T12FLG##      ;SKIP IF TAPE MADE ON P012 OR LATER
        JRST    ERODT1          ;TAPE IS IN OLD FORMAT
        TLNN    F,P12FLG##      ;SKIP IF NEW MONITOR IS RUNNING
        JRST    ERODT3          ;CANNOT CALCULATE DATE SO PRINT OCTAL
        LDB     R2,[POINT 14,R0,35] ;GET THE DATE
        MOVEM   R2,CNVDAT##     ;SAVE THE DATE FOR CONVERSION
        LDB     R2,[POINT 11,R0,21] ;GET THE TIME
        IMUL    R2,JIFFPM##     ;CONVERT MINUTES TO JIFFIES
        MOVEM   R2,CNVTIM##     ;SAVE THE TIME
        MOVE    R2,[XWD 400020,0] ;CONVERT NEW TO OLD FORMAT
        MOVEM   R2,CNVFMT##     ;SAVE THE CONVERSION FORMAT
        MOVEI   R2,CNVDAT       ;GET ADDRESS OF CONVERSION TABLE
        DATUUO  R2,             ;CONVERT DATE AND TIME
        TYPE    [ASCIZ "ERROR IN CONVERTING DATE."]
        MOVE    R0,CNVTIM       ;GET THE NEW TIME
        IDIV    R0,JIFFPM       ;CONVERT FROM MINUTES TO JIFFIES TO MINUTES
        MOVE    R2,CNVDAT       ;GET THE NEW DATE
        JRST    ERODT2          ;CONTINUE PRINTING DATE AND TIME
ERODT1: LDB     R2,[POINT 12,R0,35] ;GET DATE
        LDB     R0,[POINT 11,R0,23] ;GET THE TIME
ERODT2: IDIVI   R0,^D60         ;DIVIDE INTO HOURS AND MINS
        PUSH    P,R0+1          ;SAVE MINUTES
        PUSHJ   P,PRD2N         ;PUBLISH HOURS
        TCO     [COLON]
        POP     P,R0            ;PUBLISH MINUTES
        PUSHJ   P,PRD2N         ;PRINT TWO DIGIT DECIMAL NUMBER
        TCO     [SPACE]
        MOVE    R0,R2           ;PUT DATE IN R0
        IDIVI   R0,^D31*^D12    ;GET YEARS
        PUSH    P,R0            ;SAVE YEAR ON STACK
        IDIVI   R1,^D31         ;GET MONTH AND DAY
        MOVEI   R0,1(R2)        ;NEED TO ADD ONE TO DAY OF MONTH
        MOVE    R2,R1           ;PUT MONTH IN R2
        PUSHJ   P,PRD2N         ;PRINT DAY OF MONTH
        TCO     [DASH]
        TYPE    MONTAB(R2)      ;TYPE MONTH
        TCO     [DASH]
        POP     P,R0            ;GET YEAR FROM STACK
        ADDI    R0,^D64         ;PUBLISH YEAR
        PUSHJ   P,PRD2N         ;PRINT TWO DIGIT DECIMAL NUMBER
        POP     P,R2            ;RESTORE R2 FROM STACK
        POPJ    P,              ;RETURN
ERODT3: POP     P,R2            ;RESTORE R2
        JRST    PRONUM          ;PRINT OCTAL NUM FROM R0 AND RETURN

MONTAB: ASCIZ   "JAN"          ;TABLE OF MONTH NAMES
        ASCIZ   "FEB"
        ASCIZ   "MAR"   
        ASCIZ   "APR"
        ASCIZ   "MAY"
        ASCIZ   "JUN"
        ASCIZ   "JUL"
        ASCIZ   "AUG"
        ASCIZ   "SEP"
        ASCIZ   "OCT"
        ASCIZ   "NOV"
        ASCIZ   "DEC"

RDMON:: MOVE    R0,[XWD 0700,R1-1] ;BLANK STRING POINTER TO R1
        SETZ    R1,             ;CLEAR R1
        MOVEM   R0,MONPTR#      ;SAVE IN TEMP CELL
        MOVEI   R0,3            ;READ THREE CHARACTERS
        MOVEM   R0,MONCNT#      ;SAVE IN ANOTHER TEMP CELL
RDMON1: TCI     R2,R0           ;READ CHAR OF MONTH
        IDPB    R0,MONPTR       ;DEPOSIT CHAR IN STRING
        CAIE    R2,AL           ;SKIP IF ALPHABETIC CHARACTER READ
MONBMT: ERROR   [ASCIZ "BAD MONTH READ."]
        SOSLE   MONCNT          ;SKIP IF DONE
        JRST    RDMON1          ;LOOP
        MOVEI   R0,EOLIT        ;END THE STRING
        IDPB    R0,MONPTR       ;DEPOSIT BACK ARROW IN STRING
        MOVEI   R2,13           ;LOOP TWELVE TIMES TO FIND MONTH
        CAME    R1,MONTAB(R2)   ;SKIP IF THIS IS MONTH JUST READ
        SOJGE   R2,.-1          ;TRY THE NEXT MONTH
        JUMPL   R2,MONBMT       ;BAD MONTH TYPED
        POPJ    P,              ;RETURN

; REPLACE CALLS TO PPNUSR.  TRY TO MATCH CURPPN OR LSTPPN FIRST.

; R0=PPN  RETURNS R0,R1 WITH 6BIT USERNAME.  SKIP IF FOUND.

FSTDUL: TRZE F,FSTFLG
        JRST FSTD3      ;USE DUL WHEN TRANSLATING
        CAME R0,CURPPN##
        JRST FSTD2
        MOVE R1,CURVER##
        SKIPE CURUN1
        CAIG R1,12
        JRST FSTD2
        MOVE CURUN1##
        MOVE R1,CURUN2##
FSTD1:  AOS (P)
        POPJ P,
FSTD2:  CAME R0,LSTPPN##
        JRST FSTD3
        MOVE R1,LSTVER##
        SKIPE LSTUN1
        CAIG R1,12
        JRST FSTD3
        MOVE LSTUN1##
        MOVE R1,LSTUN2##
        JRST FSTD1
FSTD3:  PUSHJ P,PPNUSR##;LOOK IN DUL
        POPJ P,         ;NOT FOUND
        JRST FSTD1

        VAR
        END
@nD