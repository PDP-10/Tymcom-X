TITLE FLIRT.	V.032(411)	FLOATING POINT INPUT
SUBTTL	3-MAY-1972	DAVE NIXON, TOM EGGERS
;***COPYRIGHT 1969,1970,1971,1972 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

;REENT==1 FOR RE-ENTRANT OPERATING SYSTEM
IFNDEF REENT,<REENT==0>
IFN REENT,<	HISEG	>

;"FLIRT." AND "DIRT." ARE ROUTINES WHICH INPUT A STRING OF ASCII
;CHARACTERS. THE CHARS ARE RECEIVED IN AC0 FROM "CHINN."; THE RESULT
;IS RETURNED IN AC0 (AND AC1).  "IIB." IS AN EXTERNAL ROUTINE WHICH
;ADVANCES THE POINTER; "HITEN.","LOTEN.", AND "EXP10." ARE EXTERNAL
;TABLES OF FLOATING POINT POWERS OF TEN IN DOUBLE PRECISION INTEGER
;PLUS EXPONENT FORM. "PTLEN." IS THE LENGTH OF THE TABLES.
;AC1 IS RESTORED IF RESULT IS SINGLE PRECISION

;IF THE FLAG ILLEG. HAS BEEN SET (BY A CALL TO ILL), THE
;INPUT WORD WILL BE SET TO 0 IF ANY ILLEGAL CHARACTERS
;ARE SCANNED FOR THAT WORD.

;  CALLING SEQUENCE:
;	PUSHJ P,FLIRT.	OR	PUSHJ P,DIRT.
;  2 RETURNS:
;	ILLEGAL CHARACTER
;	NORMAL
;  PUSHDOWN LIST CONTAINS:
;	1.  FORMAT WORD CONSTRUCTED AS FOLLOWS:
;	    BIT 0:  0=F TYPE CONVERSION
;	            1=E TYPE CONVERSION
;	    BIT 1:  1=G TYPE CONVERSION
;	    BITS 4-10:  D -- NO. OF DIGITS FOLLOWING THE DECIMAL POINT
;	    BITS 11-17:  W -- FIELD WIDTH; W=0, VARIABLE FIELD
;	    BITS 18-35:  N -- SCALE FACTOR
;	2.  PROGRAM COUNTER (RETURN ADDRESS)

;THE SYNTAX ANALYSIS FOR THE SINGLE AND DOUBLE PRECISION INPUT
;IS STATE TABLE DRIVEN. EACH NEW INPUT CHARACTER IS CONVERTED TO
;A CHARACTER TYPE AND COMBINED WITH THE OLD "STATE". THIS RESULT
;IS THEN LOOKED UP IN THE TABLE "NXTSTA" TO GET THE NEW STATE AND
;AN INDEX INTO THE "XCTTAB" TABLE TO DISPATCH FOR THE INPUT
;CHARACTER. THE STATE TABLE LOGIC AND THE DISPATCH ROUTINES BUILD
;THREE RESULTS: A DOUBLE PRECISION INTEGER(IN B,C) FOR THE FRACTIONAL
;PART OF THE RESULT, AN INTEGER(IN XP) FOR THE EXPONENT AFTER
;"D" OR "E", AND A COUNTER(IN "X") TO KEEP TRACK OF THE DECIMAL POINT.
;WHEN A TERMINATING CHARACTER IS FOUND, THE DOUBLE PRECISION INTEGER
;IS NORMALIZED TO THE LEFT TO GIVE A DOUBLE PRECISION FRACTION.
;THE DECIMAL POINT POSITION(FROM "X")OR THE IMPLIED DECIMAL POINT
;POSITION FROM THE FORMAT STATEMENT, THE "D" OR "E" EXPONENT, AND ANY
;SCALING FROM THE FORMAT STATEMENT ARE COMBINED INTO A DECIMAL
;EXPONENT. THIS DECIMAL EXPONENT IS USED AS AN INDEX INTO A POWER
;OF TEN TABLE (KEPT IN DOUBLE PRECISION INTEGER PLUS EXPONENT FORM
;SO INTERMEDIATE RESULTS WILL HAVE 8 MORE BITS OF PRECISION THAN
;FINAL RESULTS) TO MULTIPLY THE DOUBLE PRECISION FRACTION. THIS
;RESULT IS THEN ROUNDED TO GIVE A SINGLE PRECISION,
;KA10 DOUBLE PRECISION, OR PDP6/KI10 DOUBLE PRECISION RESULT.
;OVERFLOWS RETURN THE LARGEST POSSIBLE
;NUMBER (WITH CORRECT SIGN), WHILE UNDERFLOWS RETURN 0. NO ERROR
;MESSAGE IS GIVEN FOR  EITHER OVER OR UNDERFLOW.

ENTRY	FLIRT.,DIRT.
EXTERN	CHINN.,IIB.,ILLEG.,DELIM.,OVFLS.,TTYFL.
EXTERN	HITEN.,LOTEN.,EXP10.,PTLEN.
SEARCH	DEF40


;ACCUMULATOR DEFINITIONS

SAVHI==13		;HIGHEST AC TO SAVE
SAVACS==SAVHI		;NUMBER SAVED IN STACK
A=0			;RETURNED CHAR. FROM CHINN.
B=A+1			;RESULT RETURNED IN A OR A AND B
C=B+1			;B,C, AND D ARE USED AS A MULTIPLE PRECISION
D=C+1			;  REGISTER FOR DOUBLE PRECISION OPERATIONS
XP=D+1			;EXPONENT AFTER D OR E
F=5			;FLAGS
X=6			;COUNTS DIGITS AFTER POINT
M=7			;BUFFER HEADER POINTER - MUST NOT BE USED
ST=10			;STATES
T=ST+1			;TEMPORARY
BXP=12			;BINARY EXPONENT
W=13			;FIELD WIDTH COUNTER
Q=16			;CONTAIN FLAGS
P=17			;PUSHDOWN POINTER
IFE REENT,<LOW==0>
IFN REENT,<LOW==16>

;FLAGS IN AC "F"
DPFL==(1B0)		;DOUBLE PRECISION (MUST BE SIGN BIT)
;RIGHT HALF FLAGS
ETYPE==1B18		;FROM FORMAT "E" TYPE
GTYPE==1B19		;"G" TYPE
DOTFL==1		;DOT SEEN
MINFR==2		;NEGATIVE FRACTION
MINEXP==4		;NEGATIVE EXPONENT
EXPFL==10		;EXPONENT SEEN IN DATA (MAY BE 0)

;INPUT CHARACTER TYPES
CRTYP==1	;CARRIAGE RETURN
DOTTYP==2	;DECIMAL POINT
DIGTYP==3	;DIGITS 0-9
SPCTYP==4	;SPACE OR TAB
EXPTYP==5	;D OR E
PLSTYP==6	;PLUS SIGN (+)
MINTYP==7	;MINUS SIGN (-)
		;ANYTHING ELSE IS TYPE 0
FLIRT.:	TDZA	0,0		;ENTRY TO SINGLE PRECISION
DIRT.:	MOVSI	0,DPFL		;ENTRY TO DOUBLE PRECISION
	HLR	0,-1(P)		;GET FORMAT WORD
	PUSH	P,1		;SAVE AC1 INCASE SINGLE PRECISION
	MOVEI	1,1(P)		;ADDRESS TO SAVE ACCS ON STACK
	HRLI	1,2		;ONLY SAVE FROM 2 UP
	ADD	P,[SAVACS-1,,SAVACS-1]	;COMPENSATE FOR BLT
	BLT	1,(P)
	MOVE	F,0		;SETUP FLAG ACC
	TRZ	F,177		;CLEAR SPACE FOR FLAGS
	SETZB	B,C		;INIT D.P. FRACTION
	SETZB	ST,XP		;INIT STATE AND DECIMAL EXPONENT
	SETZ	X,		;INIT "DIGITS AFTER POINT" COUNTER
	HRRZ	W,0		;GET FIELD WIDTH
	ANDI	W,177		;BUT ONLY 7 BITS OF IT
	JUMPN	W,GETCH1	;NOT FREE FORMAT IF NON-ZERO
	SOJA	W,GETCH1	;WAS FREE FORMAT, SET TO -1

GETNXT:	SKIPN	OVFLS.(LOW)	;DON'T ADVANCE POINTER IF AT END OF LINE
	XCT	IIB.		;ADVANCE BYTE POINTER
GETCHR:	JUMPE	W,ENDF1		;END OF FIELD
	LSH	ST,-^D30	;MOVE STATE TO BITS 30-32
GETCH1:	PUSHJ	P,CHINN.	;GET NEXT CHARACTER
	CAIL	0,"0"		;CHECK FOR NUMBER
	CAILE	0,"9"
	JRST	CHRTYP		;NO, TRY OTHER
	SUBI	0,"0"		;CONVERT TO NUMBER
GOT0:	TRO	ST,DIGTYP	;SET TYPE
GOTST:	REPEAT 0,<		;REMOVED TO SAVE TIME
	IDIVI	ST,5		;DIVIDE BY NUMBER OFBYTES PER WORDS
	LDB	ST,STATAB(ST+1)	;GET NEXT STATE AND DISPATCH ADDRESS>
	LSHC	ST,-2		;DIVIDE BY NUMBER OF BYTES IN WORD
	TLNE	ST+1,(1B0)	;TEST WHICH HALF
	SKIPA	ST,NXTSTA(ST)	;RIGHT HALF (BYTES 2 OR 3)
	HLRZ	ST,NXTSTA(ST)	;UNFORTUNATELY BYTES 0 OR 1
	TLNN	ST+1,(1B1)	;WHICH QUADRANT
	LSH	ST,-9		;BYTES 0 OR 2
	ANDI	ST,777		;LEAVE ONLY RIGHT MOST  QUARTER
	ROT	ST,-3		;PUT DISPATCH ADDRESS IN BITS 32-35
				; AND NEW STATE IN BITS 0-2
	XCT	XCTTAB(ST)	;DISPATCH OR EXECUTE
	SOJA	W,GETNXT	;RETURN FOR NEXT CHAR.

XCTTAB:	JRST	ILLCH		; (00) ILLEGAL CHAR
	JRST	CRIN		; (01) CR-LF
	TRO	F,DOTFL		; (02) PERIOD
	JRST	DIG		; (03) DIGIT BEFORE POINT
	JRST	BLNKIN		; (04) BLANK OR TAB
	SOJA	W,GETNXT	; (05) RETURN FOR NEXT CHAR.
	TRO	F,MINFR		; (06) NEGATIVE FRACTION
	TRO	F,MINEXP	; (07) NEGATIVE EXP
	SOJA	X,DIG		; (10) DIGIT AFTER POINT
	JRST	DIGEXP		; (11) EXPONENT
	JRST	DELCK		; (12) DELIMITER TO BACK UP OVER
;REPEAT ^D16-.+XCTTAB,<	HALT .>	;JUST IN CASE

CHRTYP:	CAIN	0,"+"		;CONVERT INPUT CHARS TO CHARACTER TYPE
	TRO	ST,PLSTYP
	CAIN	0,"-"
	TRO	ST,MINTYP
	CAIE	0," "		;SPACE
	CAIN	0,"	"	;TAB
	TRO	ST,SPCTYP
	CAIN	0,"."
	TRO	ST,DOTTYP
	CAIE	0,"D"
	CAIN	0,"E"
	TRO	ST,EXPTYP
	CAIN	0,15		;CARRIAGE RETURN
	TRO	ST,CRTYP
	JRST	GOTST		;GO DISPATCH ON OLD STATE AND CHAR TYPE


DIG:	JUMPN	B,DPDIG		;NEED D.P. YET?
	CAMLE	C,MAGIC		;NO, WILL MUL AND ADD CAUSE OVERFLOW?
	JRST	DPDIG		;MAYBE, SO DO IT IN DOUBLE PRECISION
	IMULI	C,12		;NO, MULTIPLY BY 10 SINGLE PRECISION
	ADD	C,0		;ADD DIGIT INTO NUMBER
	SOJA	W,GETNXT	;GO GET NEXT CHARACTER

DPDIG:	CAMLE	B,MAGIC		;WILL MULTIPLY AND ADD CAUSE OVERFLOW?
	AOJA	X,DIGRET	;YES
	IMULI	B,12		;MULTIPLY HIGH D.P. FRACTION BY 10
	MULI	C,12		;MULTIPLY LOW D.P. FRACTION BY 10
	ADD	B,C		;ADD HI PART OF LO PRODUCT INTO RESULT
	MOVE	C,D		;GET LO PART OF LO PRODUCT
	TLO	C,(1B0)		;STOP OVERFLOW IF CARRY INTO HI WORD
	ADD	C,0		;ADD DIGIT INTO FRACTION
	TLZN	C,(1B0)		;SKIP IF NO CARRY INTO HI WORD
	ADDI	B,1		;PROPOGATE CARRY INTO HI WORD
DIGRET:	SOJA	W,GETNXT	;DECREMENT FIELD WIDTH AND GET NEXT CHAR

MAGIC:	<377777777777-9>/^D10	;LARGEST NUM PRIOR TO MULTIPLY AND ADD

DIGEXP:	TRO	F,EXPFL		;SET FLAG TO SAY WE'VE SEEN EXPONENT
	CAILE	XP,^D100	;SIMPLE TEST FOR LARGNESS
	JRST	GETNXT		;THROW DIGIT AWAY
	IMULI	XP,12		;MULTIPLY BY TEN
	ADD	XP,0		;ADD IN NEXT DIGIT
	SOJA	W,GETNXT	;DECREMENT FIELD WIDTH AND GET NEXT CHAR

REPEAT 0,<
STATAB:	POINT	7,NXTSTA(ST),6	;POINTERS INTO STATE TABLE
	POINT	7,NXTSTA(ST),13
	POINT	7,NXTSTA(ST),20
	POINT	7,NXTSTA(ST),27
	POINT	7,NXTSTA(ST),34
>

;NOTE CHANGE BACK TO BYTE (7) IF USING IDIVI AND LDB
;	 ? ,CR , . ,0-9,   ,D E, + , - ,
NXTSTA:	BYTE (9)
	000,010,022,031,050,000,051,061,
	000,011,022,031,041,053,054,074,
	000,012,120,102,042,053,054,074,
	000,013,120,114,043,000,054,074,
	000,014,120,114,044,000,120,120
	

CRIN:	TLNE	Q,TTYFL.	;INPUT FROM TTY?
	JRST	ENDF1		;YES, AS IF IN DELIMITER MODE (FREE FORMAT)
	JUMPL	W,ENDF1		;FREE FORMAT?, ALREADY PASSED OVER CR-LF

BLNKIN:	JUMPL	W,ENDF		;FREE FORMAT
	MOVEI	0,0		;NO, CHANGE SPACE TO 0
	LSH	ST,-^D30	;PUT STATE IN BITS 30-32
	JRST	GOT0		;AND USE IT

ILLCH:	JUMPL	W,ENDF		;CHECK DELIMITER IN FREE FORMAT
DELCK:	JUMPL	W,ADDCNT	;DON'T EAT UP NEXT NUMBER
ERROR:	SKIPN	ILLEG.(LOW)	;ILLEGAL CHAR. FLAG SET?
	JRST	RETRN2		;NO, JUST RETURN
ERROR1:	SKIPN	OVFLS.(LOW)
	XCT	IIB.		;ADVANCE BYTE POINTER
	SOJLE	W,ZERO		;SKIP IT
	PUSHJ	P,CHINN.	;GET NEXT CHAR
	JRST	ERROR1


ADDCNT:	AOSA	2(M)		;INCREMENT BYTE COUNT (DECREMENTED BY CHINN.)
ENDF:	XCT	IIB.		;OTHERWISE, PASS OVER ILLEG CHARACTER
ENDF1:	MOVEM	0,DELIM.(LOW)	;SAVE DELIMITER FOR NAMELIST
	TRNE	F,DOTFL		;HAS DECIMAL POINT BEEN INPUT?
	JRST	ENDF2		;YES
	LDB	D,[POINT 7,F,28] ;NO, GET DIGITS AFTER POINT FROM FORMAT
	SUB	X,D		;  AND MODIFY DECIMAL EXPONENT
ENDF2:	HRRZ	D,-1-SAVACS(P)	;GET SCALE FACTOR
	TRNN	F,EXPFL		;EXPONENT IN DATA?
	ADD	X,D		;NO, ADD INTO EXPONENT
	TRNE	F,MINEXP	;WAS D OR E EXPONENT NEGATIVE?
	MOVNS	XP		;YES, SO NEGATE IT
	ADD	X,XP		;ADD EXPONENT FROM D OR E
NORM:	MOVEI	BXP,306		;INIT BINARY EXPON FOR D.P. INTEGER
	JUMPN	B,NORM1		;XFER IF AT LEAST ONE 1 IN HIGH HALF
	EXCH	B,C		;HIGH HALF ZERO, MOVE LOW HALF TO HIGH,
				;AND CLEAR LOW HALF
	SUBI	BXP,^D35	;AND ADJUST EXPONENT FOR 35 SHIFTS
NORM1:	MOVE	A,B		;GET D.P. HIGH HALF INTO A
	JFFO	A,NORM2		;ANY ONES NOW?
	JRST	ZERO		;NO, RESULT IS 0
NORM2:	EXCH	B,C		;YES, GET D.P. LOW HALF INTO B, AND
				;PUT SHIFT COUNT INTO C
	ASHC	A,-1(C)		;NORMALIZE D.P. INTEGER WITH BIN POINT
				;BETWEEN BITS 0 AND 1 IN HIGH WORD
	SUBI	BXP,-1(C)	;AND ADJUST EXPON TO ALLOW FOR SHIFTING
	JUMPE	X,ENDF6		;IF DECIMAL EXP=0, NO MUL BY 10 NEEDED
ENDF3:	MOVM	D,X		;GET MAGNITUDE OF DECIMAL EXPONENT
	CAILE	D,PTLEN.	;BETWEEN 0 AND MAX. TABLE ENTRY?
	MOVEI	D,PTLEN.	;NO, MAKE IT SO
	SKIPGE	X		;AND RESTORE CORRECT SIGN
	MOVNS	D
	SUB	X,D		;LEAVE ANY EXCESS EXPONENT IN X
	JUMPL	F,DPMUL		;DOUBLE PRECISION?
SPMUL:	MUL	A,HITEN.(D)	;NO, MULTIPLY BY POWER OF TEN
ENDF5:	TLNE	A,(1B1)		;NORMALIZED? 1.0 > RESULT >= 0.25
	JRST	ENDF5A		;YES, RESULT >= 0.5
	ASHC	A,1		;NO, SHIFT LEFT ONE PLACE
	SUBI	BXP,1		;AND ADJUST EXPONENT
ENDF5A:	IDIVI	D,4		;CONVERT DEC EXP TO BINARY EXPONENT
	LDB	D,EXTAB.(D+1)	;BY TABLE LOOKUP
	ADDI	BXP,-200(D)	;ADJUST BINARY EXPONET (LESS EXCESS 200)
	JUMPN	X,ENDF3		;ANY MORE DECIMAL EXPONENT LEFT?
ENDF6:	TLO	A,(1B0)		;NO, START ROUNDING (ALLOW FOR OVERFLOW)
	JUMPL	F,DPRND		;DOUBLE PRECISION?
SPRND:	ADDI	A,200		;NO, ROUND IN HIGH WORD
	TRZ	A,377		;GET RID OF USELESS (UNUSED) BITS
	MOVEI	B,0		; DITTO
ENDF7:	TLZE	A,(1B0)		;CARRY PROPOGATE TO BIT 0?
	JRST	ENDF7A		;NO
	ASHC	A,-1		;YES, RENORMALIZE TO RIGHT
	ADDI	BXP,1		;AND ADJUST BINARY EXPONENT
	TLO	A,(1B1)		;AND TURN ON HI FRACTION BIT
ENDF7A:	TRNE	BXP,777400	;IS BINARY EXPONENT TOO LARGE
	JRST	BADEXP		;YES, RETURN ZERO OR INFINITY
	ASHC	A,-8		;NO, LEAVE ROOM FOR EXPONENT
	DPB	BXP,[POINT 9,A,8] ;INSERT EXPONENT INTO HI WORD
IFN KA10,<
	JUMPGE	F,ENDF8		;KA10 DOUBLE PRECISION?
	ASH	B,-8		;YES, ALLOW ROOM FOR LOW EXPONENT
	JUMPE	B,ENDF8		;IS LOW FRACTION ALL ZERO?
	SUBI	BXP,^D27	;NO, INSERT EXPONENT 27 SMALLER THAN
	DPB	BXP,[POINT 9,B,8] ;  HIGH EXPONENT
ENDF8: >
RETURN:	AOS	-SAVACS(P)	;NORMAL RETURN IS A SKIP RETURN
	TRNE	F,MINFR		;RESULT NEGATIVE?
	DFN	A,B		;YES, SO NEGATE RESULT
RETRN2:	MOVEM	7,7-SAVHI(P)	;PUT AC7 IN STACK
	JUMPGE	F,.+2		;IF DOUBLE PRECISION
	MOVEM	1,1-SAVHI(P)	;SAVE AC1 ON STACK, SO RESTORE WILL SET IT UP AGAIN
	MOVSI	SAVHI,1-SAVACS(P)	;SET UP BLT "FROM" ADDRESS
	HRRI	SAVHI,1		;SET UP BLT "TO" ADDRESS
	BLT	SAVHI,SAVHI	;RESTORE ACS 1 THRU SAVHI
	SUB	P,[SAVACS,,SAVACS]	;BACKUP STACK POINTER
	POPJ	P,		;RETURN TO USER

BADEXP:	HRLOI	A,377777	;SET NUMBER TO LARGEST POSSIBLE
	JUMPGE	F,.+2		;SKIP IF SINGLE PRECISION
IFE KA10,<	HRLOI	B,377777 >	;FOR PDP-6 OR KI10
IFN KA10,<	HRLOI	B,344777 >	;FOR KA10
	TRNE	BXP,1B18	;IF EXPONENT IS NEGATIVE
ZERO:	SETZB	A,B		;SET TO ZERO
	JRST	RETURN

	POINT 9,EXP10.-1(D),17
	POINT 9,EXP10.-1(D),26
	POINT 9,EXP10.-1(D),35
EXTAB.:	POINT 9,EXP10.(D),8
	POINT 9,EXP10.(D),17
	POINT 9,EXP10.(D),26
	POINT 9,EXP10.(D),35
;HERE FOR DOUBLE PRECISION MULTIPLY, ROUNDING 

DPMUL:	MUL	B,HITEN.(D)	;LO FRAC TIMES HI POWER OF TEN(RESULT IN B,C)
	MOVE	T,B		;GET HI PART OF PREVIOUS PRODUCT OUT OF WAY
	MOVE	B,A		;COPY HI PART OF FRACTION
	MUL	B,LOTEN.(D)	;HI FRAC TIMES LO POWER OF TEN
	TLO	T,(1B0)
	ADD	T,B		;SUM OF HI PARTS OF CROSS PRODUCTS TO AC T
	MUL	A,HITEN.(D)	;HI FRACTION TIMES HI POWER OF TEN
	TLON	T,(1B0)		;DID CARRY OCCUR?  ALLOW FOR NEXT CARRY
	ADDI	A,1		;CARRY FROM ADDING CROSS PRODUCTS
	ADD	B,T		;ADD CROSS PRODUCTS TO LO PART
				;  OF (HI FRAC TIMES HI POW TEN)
	TLZN	B,(1B0)
	AOJA	A,ENDF5		;AND PROPOGATE A CARRY, IF ANY
	JRST	ENDF5		;GO NORMALIZE RESULT

DPRND:	TLO	B,(1B0)		;START ROUNDING (ALLOW FOR CARRYS)
IFE KA10,<	ADDI	B,200 >	;LOW WORD ROUNDING FOR PDP-6 OR KI10
IFN KA10,<
	CAIGE	BXP,^D27	;KA10 LOW EXPONENT UNDERFLOW?
	JRST	SPRND		;YES, ROUND IN HIGH WORD
	ADDI	B,100000 >	;NO, KA10 ROUND IN LOW WORD
	TLZN	B,(1B0)		;DID CARRY PROPOGATE TO SIGN?
	AOJA	A,ENDF7		;YES, ADD CARRY INTO HIGH WORD
	JRST	ENDF7		;AND GO RENORMALIZE IF NECESSARY

	END
    