Title	CHKPNT %31(102) - TYMCOM-X Accounting Daemon
Subttl	Statistics Gatherer

	SEARCH	MACTEN,JOBDAT,UUOSYM

CKPVER==31	; TYMSHARE SPEC NO.
CKPMIN==0	; TYM RELEASE NO.
CKPEDT==102	; Edit number
CKPWHO==0	; Who last edited

	LOC	137
	VRSN.	(CKP)
	RELOC

IF2,<printx License required: SY GD HF JL>

Subttl	Edit History

;	The "recorded" transmittal record of CHKPNT forms the basis
;	for this part of the modification history.  Further reference
;	must be directed to each FDM archive file listed below.
;
;   XMT# VER#     Programmer   XMT Date   FDM file
;    263 17       WEIHER     12/22/1975 CHKPNF 017
;    849 20       GINZBURG    5/15/1976 CHKPNF 214
;
;        22 ?     ATKINSON    SEPT 1976
;	SEPT 76 AAA CONVERT ALL FACT REF TO STREAM REF.
;	NOW CHKPNT WRITES CHECKPOINT RECORDS INTO THE STREAM
;	VIA NEW CALLI & RETRIEVES THEM LIKE ALL OTHER
;	STREAM RECORDS, WRITES THEM INTO STREAM ACCOUNT
;	FILE.  LOGIN,LOGOUT ALSO WRITE TO THE STREAM.
;
;   1368 21.4     KOLLING    10/06/1976 CHKPNF 214
;   1550 23.0     ATKINSON   12/16/1976 CHKPNF 230
;   1904 23.1     ATKINSON    1/14/1977 CHKPNF 231
;   1905 23.2     ATKINSON    1/18/1977 CHKPNF 232
;   1907 23.3     ATKINSON    1/20/1977 CHKPNF 233
;   2006 23.4     ATKINSON    9/16/1977 CHKPNF 234
;   2018 25       ATKINSON   12/05/1977 CHKPNF 250
;   2024 25.1     ATKINSON   12/30/1977 CHKPNF 251
;   2405 25.2     ATKINSON    2/23/1978 CHKPNF 252
;   2590 26.1     ATKINSON   12/01/1978 CHKPNF 261
;   5427 27.0     SOLEY       2/12/1980 CHKPNF 270
;   5440 30.0     SOLEY       9/18/1980 CHKPNF 300
;   7010 30.2     CORENSON    3/15/1982 CHKPNF 302
;   7676 30.3     CORENSON   10/22/1982 CHKPNF 303
;
; %30.3	Fixed DEB conditionals so that CHECKPOINT records would be
;	recorded regardless of the setting of DEB.  22-Oct-82  /TLC
;
; %30.4	Mangled NEWUSE & NEWSTM to reserve a cache of disk pages for
;	CHKPNT so that it would have plenty of warning before the
;	actual accounting would die due to lack of disk space.  This
;	version didn't work and was never released.  9-May-85  /CARL
;


;********* New history begun ***** Old history reconstructed *********
;********* Convert to DEC style version (edit) numbers.      *********
;********* %31(100)  12-Jun-85  /CARL                        *********

; 100	12-Jun-85 /CARL
;	Created this edit history.  Reformatted things to use MACTEN
;	and other standard universals.  GETTABs, CLOSE UUOs and INTADR
;	calls all use standard names.  Removed %30.4 disk-cache code.
; 101	12-Jun-85 /CARL
;	ACTINI now uses a flag instead of clobbering code.  Converted
;	many of the hard-coded numbers to symbols.
; 102	18-Jun-85 /CARL
;	Converted disk-block code to use disk-pages.
;

SUBTTL	Flags, accumulators and opdefs

IFNDEF INITIA,<INITIA==-1>	;Flag non-zero for interface with INITIA
IFNDEF DEB,<DEB==0>		;Flag non-zero for DEBUG CHKPNT
IFNDEF SERDBG,<SERDBG==0>	;Flag non-zero for DEBUG STM ERR records

	P=17
	PTR=16
	PTR2=15
	T1=1
	T2=2
	T3=3
	T4=4
	T5=5
	N1=T5+1		;
	N2=N1+1 	;
	N3=N2+1 	;
	N4=N3+1 	;ALL THESE N AC'S USED FOR NUMBER OUTPUT ROUTINES

	FIL==1		;"USE" FILE, STAT&ERROR INFO, (SYS)MMDDYY.DAT
	STREAM==2	;(UN1)MMDDYY.SAT . ALL ACCTG RECORDS
	ACTDV==3	;CHANNEL FOR INPUT FROM ACT DEVICE SEE "GETACT"

	STMPAG==377		; Stream Buffer Page
	STMADR==STMPAG_^D9	; Stream Buffer Address
	STMSIZ==1_^D9		; Stream Buffer Size
	USEPAG==STMPAG-1	; Usage  Buffer Page
	USEADR==USEPAG_^D9	; Usage  Buffer Address
	USESIZ==1_^D9		; Usage  Buffer Size

	OPDEF	CALL	[PUSHJ P,]
	OPDEF	RET	[POPJ P,]
	OPDEF	SRETURN	[JRST CPOPJ1]	; SKIP (SUCCESS) RTN

	OPDEF	ATTACH	[CALLI -6]	; ATTACH (TYMCOM-X Style)
	OPDEF	INTRMT	[CALLI -52]	; ASSOCIATED WITH ACCOUNTING DEVICE
	OPDEF	LOGOFF	[CALLI -130]

	IFE DEB,<OPDEF	PUTSAR	[CALLI -62]>	; PUT STREAM ACCT REC
	IFN DEB,<OPDEF	PUTSAR	[CAIA]>		; DO NO-OP

SUBTTL	RECORD TYPE DEFINITIONS & TYPE-CHECKING CONVENTIONS

;RECORD TYPE DEFINITIONS & TYPE-CHECKING CONVENTIONS
;	RECORDS OF TYPES 0-MAXSTY-1 ARE CHECKED FOR PROPER
;	LENGTH BY STMTYC WHEN INPUT FROM ACTDEV. RECORD
;	TYPES 400,401,402 ETC. NOT CHECKED.  THEY DO NOT
;	COME IN FROM ACTDEV, BUT ARE PLACED IN STREAM RECORDS
;	BY CHKPNT ON THE WAY OUT.
;
;FOLLOWING REC TYPES ARE WRITTEN BY CHKPNT INTO STREAM.

	RESTYP==400	;RESTART RECORD
	RESLNG==2
	UPTYP==43	;UPTIME RECORD
	UPLENG==3
	ERRTYP==402	;ERROR REC
	ERRLNG==2
	ER3TYP==403	;DEBUG TYPE ERROR HEADER. SEE STMERS
	ER4TYP==404	;DEBUG TYPE ERROR TRAILER. SEE STMERS. AAA DEC 76
	DUMTYP==401	;DUMMY RECORD FILL TO END OF BLOCK
			;(LENGTH VARIABLE)
	CKPTYP==41	;CHECKPOINT REC

	; (CKPLNG==DEFINED FOLLOWING CHECK ROUTINE)

	MAXSTY==44+1	;CURRENTLY TATTLETALE IS MAX TYPE

; HEADER WORD FORMAT:
; BITS 0-8:	RECORD TYPE
; BITS 9-17:	JOB NO.
; BITS 18-29:	SUPERVISOR INFO. (LOGIN REC ONLY)
; BITS 30-35:	LENGTH OF REC, INCLUDING HEADER WD

;Macros

DEFINE XMSG(NAME)<IF2,<PRINTX CHKPNT EXPECTS ALL STREAM TYPES .LT. NAME>>
XMSG(\MAXSTY)

SUBTTL	FLAG DEFINITIONS

;License
	.GTLIC==-20	;JOB LICENSE
	OPRLIC==100000	;OP LICENSE BIT
	SYLIC==40000	;SYSTAT LICENSE
	LICGDV==20000	;GET DEVICES
	HFLIC==2000	;HOME FILES OTHERWISE KNOWN AS RMT LIC
	LICJAL==1000	;JACCT-LOGIN LICENSE

	LICENSE==OPRLIC!SYLIC!LICGDV!HFLIC!LICJAL

;Frame Status
	.GTSTS==0	;JBTSTS
	JNA==40000	;JOB NUMBER ASSIGNED
	JLOG==4		;JOB LOGGED IN BIT
	JACCT==1	;JOB CANNOT BE KILLED

;Privileges
	.GTPRV==6	;JBTPRV
	NOATT==200000	;IN LH JBTTPRV

;Interrupt bits and causes
	IA.DIS==1	; DISABLE INTERRUPTS
	IA.REE==2	; REENABLE INTERRUPTS
	IA.CLR==4	; CLEAR INTERRUPTS

	.IAESC==0	;INPUT AVAIL ?? From ACT: ??
	.IAIOW==2	;IOWAIT
	.IATIM==4	;INTERUPT REASON - TIMER
	.IANTQ==13	;INTERRUPT REASON - NOTICE TO QUIT (SYS GOING DOWN)

;Miscellaneous
	CHKOFS==5	;NUMBER OF 5 MIN PERIODS FOR CHKPNT
	ASSPRG==200000	;DEVICE IS INNITTED..USED TO CHK ACT DEV AT STPT

	ACTDED==400000	;BIT IN ACTDDB DEVSTS WORD SET BY WATCHDOG
			;WHEN CHKPNT IS FOUND DEAD, AND CHECKED BY CHKPNT
			;JUST BEFORE INITTING DEVICE TO GOVERN UN-SHUTTING
			;OF SYS. THIS BIT USED TO LIVE IN STATES WORD. /AA
			;THE INIT UUO RESETS IT.
			; (STMDED==1B21 OLD STREAM DEAD BIT)

SUBTTL	GETTAB Tables: Accounting data

;SEE 'CHECK' ROUTINE 'GTAB' TABLE WHICH DEFINES THE CHKPNT
;	RECORD WRITTEN TO THE STREAM FOR THE USE OF THESE
;	GETTAB ITEMS:

	.GTSPW==-51	;D.P. PWS*SIZE;  PWH IS HI ORDER, PWL LOW
	.GTPWS==-50	;PG TO WORKING SET
	.GTMPC==-47	;MAPPED PG COUNT
	.GTMCY==-46	;GETS D.P. MICRO CYCLES
	.GTKCM==-45	;RETURN DOUBLE PRECISION KILO-COORE-TICKS
	.GTTRU==-44	;RETURN DOUBLE PRECISION TRU'S
	.GTBIO==-41	;BIO CHRS
	.GTBET==-40	;BIO ELAPSED TIME
	.GTSOK==-37	;FROM SOAKEM UUO
	.GTLNK==-36	;LINK CHAIN (for debugging)
	.GTRMC==-35	;REMOTE CHARACTERS
	.GTRMS==-34	;REMOTE TIME
	.GTERN==-33	;ENTERS
	.GTLIN==-27	;JOB TO LINE CONVERSION
	.GTLOG==-24	;LOGIN INFO FROM SUPERVISOR
	.GTAUN==-23	;AUN
	.GTBCS==-13	;BREAK CHRS*SIZE
	.GTCNK==-12	;CONNECT TIME
	.GTELP==-11	;ELAPSED TIME*SIZE
	.GTCOT==-10	;CHRS OUT
	.GTCIN==-7	;CHRS IN
	.GTSOT==-6	;BLOCKS OUT*SIZE
	.GTSIN==-5	;BLOCKS IN*SIZE
	.GTSRN==-4	;ENTERS*SIZE
	.GTSLK==-3	;LOOKUPS*SIZE
	.GTDLK==-2	;LOOKUPS
	.GTTR1==4	;SINGL PREC. USED BY FNDMOD (STAT & USAGE)
	.GTRCT==17	;BLOCKS READ
	.GTWCT==20	;BLOCKS WRITTEN

SUBTTL	GETTAB Tables: CNF NSW, CLOSE bits

    .GTCNF==11		;;Config Table Items

	%CNTIM==10,,.GTCNF	;.CNTIM - Time
	%CNDAT==11,,.GTCNF	;.CNDAT - Date
	%CNNJB==15,,.GTCNF	;.CNNJB - Max jobs+1
	%CNSTS==17,,.GTCNF	;.CNSTS - System states
	    STAUTO==1		;LH - Auto restart
	    STSHUT==400000	;RH - Shut
	    STSUPR==200000	;RH - Super-Shut
	%CNJPS==26,,.GTCNF	;.CNJPS - Jiffies/Sec

    .GTNSW==12		;;NSW data

	%NSUPT==15,,.GTNSW	;.NSUPT - Uptime (jiffies)
	%NSLST==22,,.GTNSW	;.NSLST - Lost time (jiffies)
	%NSTPE==24,,.GTNSW	;.NSTPE - # PARITY ERRORS
	%NSSPE==25,,.GTNSW	;.NSSPE - # SPURIOUS PARITY ERRORS
	%NSCPE==26,,.GTNSW	;.NSCPE - # OPER CONTINUE FROM PE
	%NSMPA==27,,.GTNSW	;.NSMPA - last memory parity address
	%NSMPW==30,,.GTNSW	;.NSMPW - last memory parity word
	%NSMPP==31,,.GTNSW	;.NSMPP - last memory parity pc
	%NSNUL==34,,.GTNSW	;.NSNUL - Null time (jiffies)

	.STTYO==0	; SETUUO CODE TO PRINT TO OPR: & CTY:
	.STSTA==1	; SETUUO CODE TO SET STATES WORD

	CL.OUT==1		; CLOSE OUTPUT SUPPRESSED
	CL.IN==2		; CLOSE INPUT  SUPPRESSED
	CL.DLL==4		; CLOSE BUT DO NOT DEALLOCATE
	CL.ACS==10		; CLOSE INHIBIT ACCESS UPDATE
	CL.NMB==20		; CLOSE INHIBIT NAME BLOCK DELETION
	CL.RST==40		; CLOSE INHIBIT DELETE OF FILE ON SUPERSEDE
	CL.DAT==100		; CLOSE DELETE NAME BLOCK & ACCESS TBLS

	.RBCNT==0		; Lookup/Enter count
	.RBPPN==1		; Lookup/Enter directory
	.RBNAM==2		; Lookup/Enter filename
	.RBEXT==3		; Lookup/Enter extension,,access/error
	.RBPRV==4		; Lookup/Enter protection/mode,,creation
	.RBSIZ==5		; Lookup/Enter file size in words

SUBTTL	UNIT DATA ADDRESS DEFINITIONS

UNINAM==0
UNILOG==2
UNIHCT==10
UNISCT==11
UNIERR==13
UNISOF==14
UNIHBN==15
UNIICT==25
UNIOCT==26
UNIBRC==16
UNIDRC==20
UNIMRC==22
UNIBWC==17
UNIDWC==21
UNIMWC==23
UNISDI==32
UNIHDI==33
UNIECT==34
UNISBN==35
UNIDIL==56	;LENGTH OF DEVICE INDENDENDENT PART OF UNITCB
UNISNS==UNIDIL+10	;SENSE BYTE GO HERE IN UNIT DATA BLOCK
UNISNC==UNIDIL+16	;SENSE COUNT HERE
SWPSIZ==^D9
SWPPOS==^D35
UNISBH==UNIDIL+4	;REGISTERS SAVED HERE ON HARD ERROR
UNISHS==UNIDIL+15	;REGISTERS SAVED HERE ON SOFT ERROR
  NRSW==11	;NUMBER OF RH11/RM03 STATUS WORDS SAVED.
UNIDES==50
UNIKTP==UNIDES	;;BITS 21-26 CONTROLLER TYPE OF UNIT'S CONTROLLER.
  UNSKTP==^D6	;;BYTE SIZE
  UNNKTP==^D26	;;BYTE PTR POS.
  TYPDR==0	;; 0	DR (FUTURE DRUM, IF ANY)
  TYPFH==1	;; 1	FH (BURROUGHS DISK OR BRYANT DRUM)
  TYPDP==2	;; 2	DP (MEMOREX RP01,RP02)
  TYPMD==3	;; 3	MD (BRYANT MASS DISK)
  TYPBP==4	;; 4	BP (CONTROLLER FOR 3330 UNITS)
  TYPRM==5	;; 5	RM (RH11C CONTROLLER FOR RM03 UNITS)
  MCT==5	;; HIGHEST CONTROLLER TYPE WE KNOW ABOUT.
UNIUTP==UNIDES	;BITS 30-31, UNIT TYPE WITHIN CONTROLLER
  UNSUTP==2	;BYTE SIZE
  UNNUTP==^D31	;POSITION

SUBTTL	FTA, TMX, PARITY ERROR DEFINITIONS

FTARCT==7	;RECOVERABLE READ ERRORS
FTARFL==11	;NON-RECOVERABLE READ ERRORS
FTAWCT==10	;RECOVERABLE WRITE ERRORS
FTAWFL==12	;NON-RECOVERABLE WRITE ERRORS
FTAHNC==3	;NUMBER OF TIMES HUNG
FTANAM==-2	;THIS WILL FORCE USE OF SYSNAM
FTASCI==5	;CONI ON LAST SOFT (RECOVERABLE) ERROR
FTAHCI==6	;CONI ON LAST HARD (NON-RECOVERBLE) ERROR
FTAHFN==2	;FUNCTION WHEN LAST HUNG
FTACIH==4	;CONI ON LAST HANG
FTASNS==14	;FIRST WORD OF 6 WORDS OF SENSE BYTES FOR LAST ERROR

TMXHC==4
TMXEC==14
TMXSB==15
TMXNAM==-2

SUBTTL	PLACEMENT TABLE FOR STATISTICS GETTABS

;LEFT HALF IS INDEX FOR PLACEMENT INTO CKPREC. RH IS GETTAB ITEM
;	SIGN BIT FLAGS ITEM AS WORD 1 OF DOUBLE PRECISION VALUE

GTAB:	 2,,.GTAUN	;Account User Number
    400003,,.GTTRU	;HI ORDER TRU
	;4 IS LOW ORDER TRU
	;5 IS -1 FLAG THISS REC FROM CHKPNT
    400006,,.GTKCM	;HI ORDER KILO CORE TICKS
	;7 IS LOW ORDER KILO CORE TICKS
	10,,.GTDLK	;LOOKUPS
	11,,.GTSLK	;LOOKUPS*SIZE
	12,,.GTSRN	;ENTER+RENAMES*SIZE
	13,,.GTSIN	;BLOCKS READ * SIZE
	14,,.GTSOT	; BLOCKS WR  * SIZE
	15,,.GTCIN	;CHARS IN
	16,,.GTCOT	;CHARS OUT
	17,,.GTELP	;SECONDS ELAPSED * SIZE
	20,,.GTCNK	;SECONDS CONNECT NO DETACH
	21,,.GTBCS	;BR CHARS*SIZE
	22,,.GTRCT	;BLOCKS READ
	23,,.GTWCT	;	WRITTEN
	24,,.GTLOG	;SUPERV LOGIN INFO
	25,,.GTERN	;USETI USETO'S
	26,,.GTRMS	;REM PERIPH TIME
	27,,.GTRMC	;REM PERIPH CHARS
	30,,.GTSOK	;PREM CHARG CELL
	31,,.GTBET	;SECONDS ELAPSED BLOCK PORT IO
	32,,.GTBIO	;BLOCK PORT CHARS
    400033,,.GTMCY	;MICRO CYCLES
	;34 IS LOW MICRO CYCLES
	35,,.GTMPC	;MAPPED PG COUNT
	36,,.GTPWS	;PGS TO WORKING SET
    400037,,.GTSPW	;HI ORDER PWS*SIZE
	;40 IS LOW ORDER PWS*SIZE
GTBLEN==.-GTAB


SUBTTL	STATIC DATA STORAGE - Tables

MONTAB:	ASCII	/-JAN-/
	ASCII	/-FEB-/
	ASCII	/-MAR-/
	ASCII	/-APR-/
	ASCII	/-MAY-/
	ASCII	/-JUN-/
	ASCII	/-JUL-/
	ASCII	/-AUG-/
	ASCII	/-SEP-/
	ASCII	/-OCT-/
	ASCII	/-NOV-/
	ASCII	/-DEC-/

RECRST:	BYTE (9)RESTYP,0 (18) RESLNG

USEUSR:	SIXBIT	/SYS/
	0

STMUSR: SIXBIT	/UN1/
	0

OPN:	16			; OPEN block for device DSK:
	SIXBIT /DSK/
	0

ACTHED:	10			; OPEN block for device ACT:
	SIXBIT /ACT/
	ABUF

SUBTTL	INTERRUPT VECTOR DATA

;INTERRUPT TRANSFER VECTOR. 3 LEVELS OF SOFTWARE PI.
;
;LEVEL 1- ACTIOW. USED TO BLAST FREE FROM "INPUT ACTDV," IN
;	LEVEL 2 WHICH HANGS FOR INPUT WAIT. LOCATION INTTAB
;	IS MONKEYED WITH & SAVED IN ACTLOC. NEXT TIME LEVEL 2
;	FIRES IT CONTINUES WHERE IT LEFT OFF.
;
;LEVEL 2- ACTDTA. FIRES WHEN MONITOR BUFFER APPROACHING FULL.
;	DOES INPUT ACTDV, WRITE IN STM POINTER STMLOC COUNTER
;	STMCNT. WRITES STMPAG TO STREAM OCCASIONALLY
;	(&OPENS NEW FILES AS NEEDED??)
;
;LEVEL 3- TIMINT. TIMER FIRES EVERY 300 SECS. GATHER USAGE
;	&STAT INFO, WRITE "USE" FILE AS NEEDED.
;	EVERY "CHKOFS" INTERRUPTS, CALL "CHECK" & WRITE
;	CHKPNT RECORDS INTO THE STREAM FOR INPUT BY LEVEL 2.
;
;LEVEL 4- .IANTQ. NOTICE TO QUIT interrupt goes off at least 60
;	seconds before the system goes down.  This gives us time
;	to clean up.

INTTAB: 0
	ACTIOW
	0
	ACTDTA
	0
	TIMINT
	0
	NTQINT
INTLEN==<.-INTTAB>/2


SUBTTL	Dynamic Storage

USENAM: 5			; LOOKUP BLOCK FOR (SYS)MMDDYY.DAT
	USEUSR			; Pointer to (SYS)  might not be [1,4]
	0
	SIXBIT	/DAT/
	0
	0

STMNAM: 5			; LOOKUP BLOCK FOR (UN1)MMDDYY.SAT
	STMUSR			; Pointer to (UN1)
	0
	SIXBIT	/SAT/
	0
	0

;DEFINITIONS OF CHKPNT STREAM RECORD HEAADER,DATA LOCATIONS

CKPLNG==GTBLEN+^D7	;CHKPNT REC LENGTH=
			; TABLE LENGTH GTBLEN
			;+HEADER WORD
			;+DATE WORD (1)
			;+LOW TRU (4)
			;+FLAG (5)
			;+LOW KCT (7)
			;+LOW MICRO CYCLES (34)
			;+LOW PWS*SIZE (40)

CKPHED: BYTE (9)CKPTYP,0(18)CKPLNG	;HEADER
CKPREC: BLOCK CKPLNG
CKPFLG==CKPREC+5
CKPRCT==CKPREC+22
CKPWCT==CKPREC+23	;BLOCKS READ,WRITTEN
CKPLOG==CKPREC+24	;SUPERVISOR LOGIN INFO

RRSETB:	11	;STRUUO FUNCTION 11, READ AND RESET BUFFERED LOG (FOR 3330)
	0	;UNIT NAME GOES HERE

COM:	IOWD	USESIZ,USEADR
	0
STMCOM:	IOWD	STMSIZ,STMADR
	0

UNYUTP: POINT UNSUTP,UNIUTP+SYSBLK,UNNUTP
UNYKTP: POINT UNSKTP,UNIKTP+SYSBLK,UNNKTP  ;TYPE CODE OF UNIT'S CONTROLLER.

;STORAGE FOR UDB READ USING SYSDVF.

LOC:	2
SYSNAM: 0
	0
SYSBLK: BLOCK 115

SUBTTL	More Data Storage

ZCORE::
RERUN:	Block	1		;WHETHER TO UN-SHUT SYSTEM OR NOT
JOBPTR:	Block	1		;JOBPTR:=-NUMB JOBS,,0
PDL:	Block	40

USEPDL:	Block	40
USESAC:	Block	20
USEFIL:	Block	1		; Usage statistics file
USETRM:	Block	1		; Usage TIME stamp

USEZER::
USEBUF:	Block	1		; Usage Buffer in-use flag
USEMAP:	Block	1		; Usage Buffer mapped flag
USEEZR::

STMFIL:	Block	1		; Stream accounting filename
STMTRM:	Block	1		; Stream TIME stamp

STMZER::
STMBUF:	Block	1		; Stream Buffer in-use flag
STMMAP:	Block	1		; Stream Buffer mapped flag
STMLOC:	Block	1		; Stream Buffer position
STMCNT:	Block	1		; Stream Buffer count
STMEZR::

STYTYP:	Block	MAXSTY		;SIZE OF EACH TYPE OF RECORD. (see stmtyc)

DCNV:	Block	3
ABUF:	Block	3		; ACT: device buffer ring header
ACT1ST:	Block	1		;Flag non-zero if already in interrupt loop.
ACTLOC:	Block	1		;IS THERE AN OLD PC?
ACISAV:	Block	20		;Previous saved Interrupt ACs
ACTSAV:	Block	20		;Saved ACs
ACTPDL:	Block	40		;PDL to use at ACT: interrupt level

SERAC:	Block	6		;FOR DUMP AC'S ON ENTRY TO STMERS
STMERP:	Block	1		;POINTER FOR MAKING STRING ERR MSG
STMERM:	Block	^D80/5		;80 CHARS AT LEAST

LSTSTD:	Block	1		;IN CASE OF ERRORS
LSTTIM:	Block	1
LSTNUL:	Block	1
LSTLOS:	Block	1
LSTSWP:	Block	1		;FOR DISK STATS
LSTDSK:	Block	1
LSTMON:	Block	1
LSTPAR:	Block	1		;AND PARITY STATS
LSTTRU:	Block	1
LSTUPT:	Block	1
INCUPT:	Block	1		;FOR DSK RECORD
UNILST:	Block	1

SUBTTL	Information

CHKCEL:	Block	1		;SEE TIMINT+5
GMTDAT:	Block	1		;SAVE IT
JFYSEC:	Block	1
TIMPTR:	Block	1
SNSCNT:	Block	1		;THIS IS TO GET THE FINAL SENSE DONE ON 3330'S
CURDAT:	Block	1
CURTIM:	Block	1
CURSWP:	Block	1
CURMON:	Block	1
CURDSK:	Block	1
EZCORE::

SUBTTL *** MAIN PROGRAM ***

STPT:	RESET
	Store	T1,ZCORE,EZCORE-1,0	; Initialize the zero data fields

IFE DEB,<	;; Debugging - So don't bother with this stuff...
	HRROI	T1,.GTLIC
	GETTAB	T1,
	  SKIPA				;SAY NOT OP IF CANNOT GET IT
	TLNN	T1,OPRLIC
	  JRST	[MOVEI T1,[ASCIZ/
CHKPNT missing OP license, quitting!/]
		JRST	NOTRUN]
	TLC	T1,LICENSE		; CHKPNT NEEDS THESE
	 TLCE	T1,LICENSE		;   OP SY GD HF JL
	  JRST	[MOVEI T1,[ASCIZ/
CHKPNT license(s) missing, quitting!/]
		JRST	NOTRUN]
MUPLP:
IFE INITIA,<	;; FOR SYNC WITH INITIA. AAA DEC 76
	MOVE	T1,[%CNSTS]
	GETTAB	T1,			;WAIT FOR AUTO RESTART TO GO OFF
	  MOVEI	T1,0
	TLNE	T1,1
	  JRST	WATMUP			;STILL ON, WAIT
> ; End IFE INITIA
	MOVE	T1,[%CNDAT]
	GETTAB	T1,			;AND DATE NON-NEG, RESP FROM SUP
	  MOVEI	T1,0
	JUMPGE	T1,OKUP
WATMUP:	MOVEI	T1,5			;WAIT 5 SEC
	SLEEP	T1,
	JRST	MUPLP
OKUP:	HRROI	T1,.GTSTS
	GETTAB	T1,
	  JRST	NOJAL
	TLO	T1,JACCT
	SETJAL	T1,			;SET JACCT BIT
	  JRST	NOJAL
> ; End IFE DEB

;Continued on next page

	MOVE	P,[IOWD 40,PDL]
	MOVEI	T1,'ACT'		;SEE IF ACT DEVICE WAS NOTED AS
	DEVSTS	T1,			;HUNG (CHKPNT DIED) BY WATCHDOG
	  JFCL				;ALWAYS SKIPS
	TLNN	T1,ACTDED		;CHECK THIS BIT BEFORE INITTING,
	 TDZA	T1,T1			;AS INIT RESETS IT ON SUCCESS.
	  MOVEI	T1,1			;T1/0 OR 1. LATER USE TO KNOW
	MOVEM	T1,RERUN 		;WHETHER TO UN-SHUT SYSTEM OR NOT
	OPEN	ACTDV,ACTHED		;****INIT ACT DEV WORD MODE INPUT***
	  JRST	[MOVEI	T1,[ASCIZ/
CHKPNT already running./]
		MOVSI	T2,'ACT'	; SEE IF DEVICE
		DEVCHR	T2,		;ALREADY INITTED. MEANS CHKPNT
		  TRNN	T2,ASSPRG	;RUNNING IF SO
		 MOVEI	T1,[ASCIZ/
Aborting, notify operating system group immediately!/]
		JRST	NOTRUN]
	MOVEI	T1,[ASCIZ/
CHKPNT cant assign ACT device.  Leave system up;
Notify operating system group immediately!/]
	PJOB	T2,			;***REASSIGN ACT TO THIS JOB*******
	MOVEI	T3,ACTDV
	REASSI	T2,
	JUMPE	T3,NOTRUN

;SET UP FOR STATISTICS GATHERING: (SYS)MMDDYY.DAT
	OPEN	FIL,OPN			;DUMP RECORDS MODE
	  JRST	NODSK
	MOVE	T1,[%CNJPS]
	GETTAB	T1,
	  MOVEI	T1,^D60
	MOVEM	T1,JFYSEC
	DATE	T1,			;TIME-ZONE ADJUSTED DATE
	MOVSS	T1			;GET IN PROPER POSITION
	CALL	NEWUSE			;OPEN OLD(OR NEW) (SYS)MMDDYY.DAT FOR APPEND.
	 CALL	NOUSEET UP FOR STREAM FILE OUTPUT: (UN1)MMDDYY.SAT
	SETZM	STMFIL
	SETZM	STMBUF
	OPEN	STREAM,OPN
	  JRST	NODSK		;FATAL MSG
	MOVE	T1,[%CNDAT]
	GETTAB	T1,		;GMT DATE
	  MOVEI	T1,0
	MOVSS	T1
	CALL	NEWSTM		;OPEN OLD(OR NEW) (UN1)MMDDYY.SAT FOR APPEND.
	 CALL	NOSTM


	SKIPE	USEFIL
	JRST	GOPG3
GOPG2A:	DATE	T1,
	MSTIME	T2,
	DATE	T3,
	CAME	T1,T3
	  JRST	GOPG2A
	IDIVI	T2,^D1000
	MOVSS	T1
	HRR	T1,T2
	CAMLE	T1,USETRM
	  JRST	[CALL	NEWUSE
		  CALL	NOUSE
		 JRST	.+1]
	MOVEM	T1,(PTR)	;GENERATE THE RECORD
	HRROI	T1,2
	MOVEM	T1,1(PTR)
	MOVE	T1,JFYSEC
	MOVEM	T1,2(PTR)	;GIV JIFFIES/SEC FOR REFERENCE
	CALL	NXTREC
	MOVEM	PTR,TIMPTR
GOPG3:	SKIPE	STMFIL
	  JRST	GOPG4
GOPG3A:	MOVE	T1,[%CNDAT]	;CHECK FOR MIDNITE TRANSITION
	GETTAB	T1,
	  MOVEI	T1,0
	MOVE	T2,[%CNTIM]
	GETTAB	T2,
	  MOVEI	T2,0
	MOVE	T3,[%CNDAT]
	GETTAB	T3,
	  MOVEI	T3,0
	CAME	T1,T3
	  JRST	GOPG3A
	INBUF	ACTDV,4		;***4 INPUT BUFFERS FOR ACT DEV***
	MOVSS	T1
	IDIV	T2,JFYSEC
	HRR	T1,T2
	CAMLE	T1,STMTRM
	  JRST	[CALL	NEWSTM
		  CALL	NOSTM
		JRST	.+1]
	MOVEM	T1,STMADR+1		; Store in new buffer page
	MOVEM	T1,LSTSTD		; Save in case of errors
	MOVE	T1,RECRST		; Restart REC to stream
	MOVEM	T1,STMADR
	MOVNI	T1,2
	ADDM	T1,STMCNT
	MOVEI	T1,2
	ADDM	T1,STMLOC
	SETOM	STMBUF
	SETZM	STYTYP
	MOVE	T1,[STYTYP,,STYTYP+1]
	BLT	T1,STYTYP+MAXSTY-1
	SETZM	ACTLOC		;SEE ACTDTA+3. SAVED PC FOR LEVEL 2 PI.

;HERE REMOVE CALL GETFCT,CALL APPEND UPTIME RECORD
;FROM "STRHED" AREA

GOPG4:
GOPG5:	MOVE	T1,[%NSUPT]
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,LSTTIM
	MOVE	T1,[%NSNUL]
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,LSTNUL
	MOVE	T1,[%NSLST]
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,LSTLOS
	SETOM	LSTSWP		;FOR DISK STATS
	SETOM	LSTDSK
	SETOM	LSTMON
	SETZM	LSTPAR		;AND PARITY STATS
	SETZM	UNILST
	MOVE	T1,[%CNNJB]
	GETTAB	T1,
	  MOVE	T1,[-^D96,,0]
	MOVNS	T1
	HRLZS	T1
	MOVEM	T1,JOBPTR	;JOBPTR:=-NUMB JOBS,,0
	MOVEI	T1,CHKOFS
	MOVEM	T1,CHKCEL	;SEE TIMINT+5
;Continued on next page


GOPG6:	MOVEI	T1,0		;CLEAR TIMER
	SETTIM	T1,
	  CALL	BADUUO
	MOVE	T1,[1,,^D300]	;TIMER FIRES IN 300 SEC=5 MIN
	SETTIM	T1,
	  CALL	BADUUO
	MOVEI	T1,INTTAB	;ASSIGN SOFTWARE PI SYSTEM. INTTAB,
	HRLI	T1,IA.REE!IA.CLR
	INTADR	T1,
	  CALL	BADUUO
	MOVSI	T1,760000	;ENABLE PI LEVELS 1,2,3,4
	INTENB	T1,
	  CALL	BADUUO
	MOVE	T1,[.IANTQ,,4]	;ASSIGN LEV 4 TO CAUSE 11=NoticeToQuit
	INTASS	T1,
	  CALL	BADUUO
	MOVE	T1,[.IATIM,,3]	;ASSIGN LEV 3 TO CAUSE 4=TIMER
	INTASS	T1,
	  CALL	BADUUO
	SKIPE	STMFIL
	  JRST	DETACH
	MOVE	T1,[.IAIOW_9+1,,ACTDV]	;PI LEV 1 <->IO WAIT ACTDV
	INTRMT	T1,
	  CALL	BADUUO
	MOVE	T1,[.IAESC_9+2,,ACTDV]	;PI LEV 2 <->INPUT AVAIL
	INTRMT	T1,			;FROM ACTDV
	  CALL	BADUUO

; ANNOUNCE CHKPNT INITIALIZATION CONSOLE TTY

GOPG7:	MOVE	T1,[POINT 7,STMERM]
	MOVEM	T1,STMERP
	MOVEI	T1,[BYTE(7)15,12,1,1,1,1,1,1,1,1,1,0] ;CR DELAY ?!?
	CALL	APPERM
	MOVEI	T1,[ASCIZ/CHKPNT on job /]
	CALL	APPERM
	PJOB	N1,
	CALL	DECWR
	MOVEI	T1,[BYTE(7)15,12]
	CALL	APPERM
	MOVEI	T1,0		;END MSG W/NULL
	IDPB	T1,STMERP
	MOVEI	T1,STMERM	;NOW PT AT MSG
	CALL	ERRMES		;NOT REALLY AN ERROR MSG
	HRROI	T1,.GTPRV	;NOW SET NO ATTACH IN JBTPRV TO KEEP
	GETTAB	T1,		;CLOWNS FROM INADVERTENTLY ATTACHING
	  CALL	GETER		;TO CHKPNT
	TLO	T1,NOATT	;
	SETPRV	T1,

;Continued on next page

;NOW UN-SHUT SYSTEM IF THIS RUN OF CHKPNT IS RECOVERING
;FROM AN ACTDED STATE (FORMER COPY OF CHKPNT DIED).
;THE WATCHDOG IN CLOCK1 SHUT THE SYSTEM WHEN IT DECLARED
;THE ACT DEVICE DEAD.

GOPG8:	MOVE	T1,[%CNSTS]
	GETTAB	T1,
	  CALL	GETER
	HRLI	T1,.STSTA	;T1/<SETUUO STATES FN.>,,SCHED VALUE
	TRZ	T1,STSHUT
	SKIPE	RERUN		;SET UP BEFORE INIT OF ACTDV
	 SETUUO	T1,
	 JFCL

; NOW THAT LEVEL 2 IS ENABLED, WE MAY IMMEDIATELY BEGIN
;  GETTING INTERRUPTS. DATA EXISTING IN ACT BUFFER BEFORE
;  CHKPNT BEGAN WILL APPEAR FIRST IN THE STREAM FILE,
;  FOLLOWED BY:
;
; HERE PUT UPTIME RECORD IN STREAM

	MOVE	T1,[BYTE (9)UPTYP,0(18)UPLENG]	;PUT UPTIME
	MOVE	T3,[%NSUPT]	;RECORD INTO
	GETTAB	T3,		;STREAM. GET UPTIME
	  SETZ	T3,		;(SORRY..)
	MOVEI	T2,0		;DATE SUPPLIED BY MONITOR
	MOVEI	T4,T1		;POINT AT RECORD
	PUTSAR	T4,		;PUT IT IN.
	  CALL	BADPUT
	CALL	CHECK		;WRITE BEGINNING CKPT RECORDS FOR EVERYBODY
DETACH:	MOVNI	T1,1
	ATTACH	T1,		;****DETACH FROM TTY***
	OUTCHI	0		;HANG HERE. INTERRUPT DRIVEN FROM NOW ON.
	MOVEI	T1,0
	SETTIM	T1,		;TURN OFF TIMER
	  CALL	BADUUO
	OUTSTR	[ASCIZ "
CHKPNT attached! Shutting down...
"]			       ; output to TTY
	MOVEI	T1,[ASCIZ "
CHKPNT attached! Shutting down...
"]
	SETUUO	T1,	       ; output to CTY
	  JFCL
	PUSHJ	P,BYEBYE	       ; clean up
	OUTSTR	[ASCIZ "
CHKPNT shut down.  There is now no accounting for this system.
If this was unintentional, run (SYS)CHKPNT."]
	MOVEI	T1,[ASCIZ/
CHKPNT shut down.
/]
	SETUUO	T1,
	  JFCL
	EXIT

SUBTTL	NTQ interrupt (LEV 4)

; Note: HERE ON NTQ interrupt (LEV 4)
NTQINT:	MOVEI	T1,0		; this interrupt is never DISMIS'd
	SETTIM	T1,		;TURN OFF TIMER
	  CALL	BADUUO
	MOVEI	T1,[ASCIZ "
CHKPNT received notice to quit - shutting down
"]
	SETUUO	T1,		; Tell CTY
	  JFCL
	SETZ	T1,		; deassign (assign to job 0)
	MOVSI	T1+1,'ACT'	; the ACT device
	REASSI	T1,		; turn of INIT BY CONSOLE bit
	PUSHJ	P,BYEBYE
	MOVSI	1		; Silence LOGOUT
	LOGOFF			; Go away!
	  EXIT			; In case LOGOFF fails

;CLEAN UP & EXIT AFTER RE-ATTACH or NTQ

BYEBYE:	CALL	CHECK		;LAST CKPT RECORDS TO STREAM
	CALL	FINSTS		;LAST USE&STAT INFO TO "USE" FILE
	SKIPE	STMFIL
	  POPJ	P,
	MTAPE	ACTDV,0		;ASK FOR EOF ON ACTDV INPUT. SEE GETACT
	MOVSI	T1,(1B0+1B2)
	INTACT	T1,		;FIRE LEVEL 2 ACTDTA
	  CALL	BADUUO
	CLOSE	STREAM,0	;LAST LEVEL 2 DID REL ACTDV+CLOSE STREAM,4
	MOVSI	T1,IA.DIS	;DISABLE
	INTADR	T1,		;ENTIRE PI SYS. NO MORE INTERRUPTS
	  CALL	BADUUO
	POPJ	P,

SUBTTL	LEVEL 2 - Normal Priority Interrupt

;************LEVEL 2 PI ROUTINE "ACTDTA"***********

ACTDTA:	MOVEM	17,ACTSAV+17	;SAVE AC'S FROM LOWER LEVEL
	MOVEI	17,ACTSAV
	BLT	17,ACTSAV+16
	SKIPN	ACTLOC		;IS THERE AN OLD PC?
	  JRST	ACTINI		;No?  May be a suprious interrupt
	MOVSI	17,ACISAV	;YES, RESTORE ACS (Usual case)
	BLT	17,17
	JRST	@ACTLOC		;Continue from where we left off

ACTINI:	SKIPE	ACT1ST		; 1ST time through here?
	  CALL	LV2DBG		; No, someone goofed!
	SETOM	ACT1ST		; Set flag
	MOVE	P,[IOWD 40,ACTPDL]
	JRST	ACTLP		; Set PDL and loop "forever"

LV2DBG:	MOVEI	T1,[ASCIZ/
CHKPNT spurious LEV 2 interrupt, FATERR/]
IFN SERDBG,<LIGHTS T1,> 	;IN CASE $B SET IN MONITOR
	JRST	FATERR

ACTLP:	CALL	GETACT		;THIS SHOULD BE THE HEADER WORD WITH COUNT
	CALL	STMTYC		;CHECK TYPE
	  JRST	STMERS		;ERROR. MESSAGE, THEN RTN TO ACTLPC
ACTLPC:	PUSH	P,T1		;HEADER WORD TO STACK
	CALL	GETACT		;DATE/TIME WORD
	CAMLE	T1,STMTRM	;IS .LE. DATE ON CURR FILE?
	JRST	[CALL	NEWSTM	; NEED A NEW FILE
		 CALL	NOSTM	;FATAL, NO RETURN
		 JRST	ACTCP1]	;NOW OK, TRANSFER REC TO STM BUFFER
ACTCP1:	LDB T2,[POINT 6,(P),35]	;SIZE FIELD OF HEADER IN STK
	CAMLE	T2,STMCNT
	  JRST	[CALL	STMNXR	;OUTPUT RECORD
		 CALL	SETSTM	;RE-SPECIFY FILE
		 CALL	NOSTM	;ERROR, DIE
		 JRST	ACTCP1]	;SHOULD BE ROOM NOW
ACTCP2:	MOVE	T3,STMLOC
	EXCH	T1,(P)
	CALL	ACTDP		;STORE FIRST WORD
	  POP	P,T1
	MOVEM	T1,LSTSTD	;SAVE IN CASE OF ERROR
	CALL	ACTDP		;AND SECOND
	  SUBI	T2,2
	JUMPLE	T2,ACTFN1
	CALL	GETACT
	CALL	ACTDP
	SOJG	T2,.-2
ACTFN1:	SETOM	STMBUF		;RECORD THAT DATA IS PRESENT IN STM
	MOVEM	T3,STMLOC
	JRST	ACTLP


ACTDP:	MOVEM	T1,STMADR(T3)
	SOS	STMCNT
	AOJA	T3,CPOPJ
GETACT:	SOSG	ABUF+2
	  IN	ACTDV,0
	JRST	GETAC1		;ALL OK
	STATZ	ACTDV,20000
	  JRST	ACTEOF		;HAPPENS WHEN CLOSING DOWN
	SETSTS	ACTDV,10	;CLEAR ERROR BIT
GETAC1:	ILDB	T1,ABUF+1
	POPJ	P,

ACTEOF:	RELEASE	ACTDV,0
	SKIPE	STMBUF
	  CALL	STMNXR		;DUMP RECORD
	CLOSE	STREAM,CL.DLL
LEVACT:	MOVSI	17,ACTSAV
	BLT	17,17
	DISMIS			;LEAVE INTERUPT LEVEL


;CHECK TYPES & LENGTHS OF INCOMING RECORDS

STMTYC:	LDB T3,[POINT 9,T1,8]	;TYPE
	CAIL	T3,MAXSTY
	  POPJ	P,	 	;TYPE TOO BIG
	SKIPE	T2,STYTYP(T3)
	  JRST	ACTTY1		;HAVE TYPE ALREADY
	MOVE	T2,T3
	UGETF	ACTDV,T2
	MOVEM	T2,STYTYP(T3)
ACTTY1:	LDB T3,[POINT 6,T1,35]	;T3:=SIZE FIELD
	PUSH	P,T4
	TLNN	T2,-1           ;IS REC VAR LEN?
	  JRST	ACTTY2          ;NO
	HLRZ	T4,T2           ;GET MIN SIZE IN T4
	HRRZS	T2              ; AND MAX IN T2
	CAML	T3,T4           ;SIZE TOO SMALL OR
	  CAMLE	T3,T2           ; TOO LARGE?
	 JRST	ACTTY3		;YES, ERROR RETURN
        SKIPA
ACTTY2:	CAMN	T3,T2
	  AOS	-1(P)
ACTTY3:	POP	P,T4
	POPJ	P,

;*************************************END OF LEVEL 2****
SUBTTL	LEV 1 - High Priority Interrupt

;LEVEL 1 HI PRIORITY INTERRUPT. UNHANG STUCK "IN ACTDV,0"
;	& SAVE PC FOR CONTINUE LATER WHEN INPUT AVAILABLE.

ACTIOW:	MOVEM	17,ACISAV+17	;SAVE ACS FOR NEXT TIME
	MOVEI	17,ACISAV
	BLT	17,ACISAV+16
	MOVEI	T1,LEVACT
	EXCH	T1,INTTAB
	MOVEM	T1,ACTLOC	;SAVE LOC INTERUPTED FROM
	DISMIS			;AND DISMIS AND FORCE LOWER LEVEL DISMIS

;****END LEVEL 1 **********

SUBTTL INCONSISTENT ACT: DATA, ERROR RECOVERY

;HERE IF ACT DATA INCONSISTENT. CALLED JRST STMERS FROM LEVEL 2

STMERS:	MOVEM	T5,SERAC+5
	MOVEI	T5,SERAC	;FROM AC0 TO SERAC+0
	BLT	T5,SERAC+4
IFN SERDBG,<LIGHTS 0,>		; SYSCRS OR $B AT LIGHTS IN MONITOR
				; TO CATCH THIS & EXAMINE ACTBUF
	MOVE	T1,[POINT 7,STMERM]
	MOVEM	T1,STMERP ;INIT STR PTR FOR MAKE MESSAGE
	MOVEI	T1,[ASCIZ/
CHKPNT data error: /]
	CALL	APPERM
	MOVE	T4,SERAC+T1	;RECOVER BAD HEADER FROM T1
	CALL	OUTNUM		;MAKE STRING IN N1,N2,N3 POINT AT IN T1
	CALL	APPERM
	MOVEI	T1," "
	IDPB	T1,STMERP
	MOVE	T4,LSTSTD
	CALL	OUTNUM
	CALL	APPERM
	MOVEI	T1," "
	IDPB	T1,STMERP
	CALL	APPERD		;WRITE DATE ON STRING END
	SETZ	T1,		;WRITE NULL TO TERMINATE
	IDPB	T1,STMERP	;ERR MSG STR
	MOVEI	T1,STMERM
	CALL	ERRMES		;PUT ALL ON CONSOLE TTY
IFE SERDBG,<
; NOW PUT ERROR REC INTO STREAM
	MOVEI	T1,ERRLNG
	CAMG	T1,STMCNT	;IS THERE ROOM?
	  JRST	STMER0		;YES
	CALL	STMNXR
	CALL	SETSTM
	  CALL	NOSTM
STMER0:	MOVE	T3,STMLOC
	MOVE	T1,[BYTE (9)ERRTYP,0(18)ERRLNG]	;ERR REC HEADER
	CALL	ACTDP		;WRITE IT
	MOVE	T1,LSTSTD
	CALL	ACTDP		;RECORD LAST GOOD REC TIME,DATE
	MOVEM	T3,STMLOC	;REPLACE INDEX
	SETOM	STMBUF

; EAT WORDS UNTIL GOOD HEADER APPEARS

STMER1:	CALL	GETACT		;NEXT WORD
	CALL	STMTYC		;SKIP IF GOOD HEADER WORD
	  JRST	STMER1		;BAD,EAT ANOTHER
	PUSH	P,T1		;SAVE THIS GOOD HEADER
	MOVSI	T5,SERAC	;FROM SERAC+0 TO AC0
	BLT	T5,T5		;THRU T5=AC5
	POP	P,T1		;RECOVER THIS GOOD HEADER
	JRST	ACTLPC		;NOW GO CONTINUE W/GOOD RECORDS
>; END USUAL CODE FOR HANDLE STREAM ERROR

IFN SERDBG,<
;SPECIAL CODE TO PUT ALL ERROR DATA INTO STREAM FILE
;PRECEEDED BY A 403000,,0 HEADER & TRAILED BY A 404000,,0
IF2,<PRINTX SPECIAL STREAM ERROR DEBUG CODE INCLUDED>
	MOVSI	T1,(BYTE (9)ER3TYP)
	CALL	DBGDP
	MOVE	T1,SERAC+T1
	CALL	DBGDP		;PUT IN BAD HEADER VALUE
STMERL:	CALL	GETACT		;GET DATA FR ACT DEV
	CALL	STMTYC		;SKIP IF GOOD HEADER
	  JRST	[CALL	DBGDP	;BAD, PUT IN ERR REC
		JRST	STMERL]	; KEEP ON TILL GOOD
	PUSH	P,T1		;SAVE THE GOOD HEADER
	MOVSI	T1,(BYTE (9)ER4TYP)
	CALL	DBGDP		;WRITE IT
	MOVSI	T5,SERAC	;RESTORE 0 - T5
	BLT	T5,T5
	POP	P,T1		;RECOV GOOD HEADER
	JRST	ACTLPC		;CONTINUE W/GOOD RECORDS
DBGDP:	SKIPLE	STMCNT
	  JRST	DBGDP2
	PUSH	P,T1
	CALL	STMNXR
	CALL	SETSTM
	  CALL	NOSTM
	POP	P,T1
DBGDP2:	MOVE	T3,STMLOC
	CALL	ACTDP
	MOVEM	T3,STMLOC
	POPJ	P,
>; END SPECIAL DEBUG CODE.


;HERE AT LEVEL 2 TO WRITE BUFFER TO STREAM FILE. PUSHJ HERE

STMNXR:	PUSH	P,T1
	MOVEI	T1,STMSIZ
	SUB	T1,STMLOC
	JUMPE	T1,TPOPO		;BUFFER IS FULL
	  HRLI	T1,(BYTE (9)DUMTYP)	;SKIP RECORD
	PUSH	P,T2
	MOVE	T2,STMLOC
	MOVEM	T1,STMADR(T2)
	POP	P,T2
TPOPO:	MOVE	T1,[.CHVMP,,STREAM]	; Function,Channel
	CHANIO	T1,STMVMP		; ( Xwd 1,STMPAG : -1 )
	  HALT	.			;  ?? Impossible ??
	SETZM	STMBUF
	CLOSE	STREAM,CL.IN!CL.DLL
	POP	P,T1
	POPJ	P,

SUBTTL	NEW USE FILE

;NEWUSE - GENERATE NEW "USE" FILE, SET PTR,USEBUF,CLREAR BUF
;	CALLED AT INITIALIZATION & IN LEVEL 3

NEWUSE:	PUSH	P,T1			; Save a register
	HLLOM	T1,USETRM
	HLRZS	T1			; Use todays DATE to
	CALL	GENNMM			;  generate a new filename
	MOVEM	T3,USENAM+.RBNAM
	SKIPE	USEBUF			; Anything in buffer? (BUF)
	  CALL	NXTREC...			; Yes, NEEDS AN OUTPUT
	CLOSE	FIL,0			; No,  DONE WITH THE FILE
	SETZM	USEBUF			; Buffer now empty.

NEWUS1:	LOOKUP	FIL,USENAM		; Lookup file
	JRST	[HRRZ  T1,USENAM+.RBEXT	; Get error code
		JUMPN	T1,TPOPJ	; *** ERROR *** unless (0) %ERFNF
		  ENTER	FIL,USENAM	; FNF - So create a new one
		 JRST	TPOPJ		; CAN NOT ENTER - Give ERROR
		CLOSE	FIL,CL.DLL	; Close file and
		JRST	NEWUS1]		;  loop back for UPDATE mode

NEWUS2:	SETZM	USENAM+.RBPRV		; Set creation and
	HLLZS	USENAM+.RBEXT		;  access to today
	ENTER	FIL,USENAM		; Open in UPDATE mode
	  JRST	TPOPJ			; Hmmmmmm.  *** ERROR ***
	MOVE	T1,USENAM+.RBSIZ	; Get the size
	TLNE	T1,777			; See if non-page aligned
	  CALL	USEFIX			; Fixup the useage file
	Store	T1,USEZER,USEEZR-1,0	; Clear Usage data area
;; Do MAP STUFF Here!!!
	MOVSI	PTR,-^D8
	HRRI	PTR,USEADR
TPOPJ1:	AOS	-1(P)			; Set !Skip! return
TPOPJ:	POP	P,T1			; Restore save'd register
	POPJ	P,			; Normal return


;ENTER HERE FROM LEVEL 3,"NXTREC"

SETFIL:	PUSH	P,T1
	JRST	NEWUS2

SUBTTL	NEW STREAM FILE

;NEWSTM GENERATE NEW (UN1)MMDDYY.SAT STREAM FILE OR PUT EXISTING ONE
;	IN UPDATE MODE, WIND FORWARD TO APPEND DATA.  SET STMLOC,STMCNT.
;	CLEAR STMPAG.  CALLED AT INITZN & IN LEVEL 2
;
; IT CAN HAPPEN THAT NEWSTM IS UNABLE TO OPEN MMDDYY.SAT, SO IT TRIES
; 64 ALTERNATIVES MMDDYY.S01, S02, ..., etc.  IF CHKPNT SHOULD DIE & A
; NEW COPY BE RUN, THE NEW COPY MIGHT APPEND MORE DATA TO MMDDYY.SAT
; EVEN THOUGH .S01 .S02 ETC. FILES MIGHT EXIST & BE MORE CURRENT.  IF
; THIS PROVES TO BE A PROBLEM, CODE MUST BE PUT AT  OKUP: INIT'ZN CODE
; TO LOCATE HIGHEST EXTENSION PRESENT FOR MMDDYY AND PUT THAT IN STMNAM+3
; BEFORE CALLING NEWSTM THE 1ST TIME.

NEWSTM:	PUSH	P,T1			; Save a working register
	HLLOM	T1,STMTRM
	HLRZS	T1			; Use todays DATE
	CALL	GENNM1			;  to generate a filename
	MOVEM	T3,STMNAM+.RBNAM	;  for the stream file
	SKIPE	STMBUF			; If any data in buffer
	  CALL	STMNXR			;  then write it out first.
	CLOSE	STREAM,0		; Close the old file
	SETZM	STMBUF			; Clear the buffer in-use flag

NEWST1:	LOOKUP	STREAM,STMNAM		; Look for the "new" file
	JRST	[HRRZ  T1,STMNAM+.RBEXT	; Get error code
		JUMPN	T1,TPOPJ	; *** ERROR *** unless (0) %ERFNF
		  ENTER	STREAM,STMNAM	; FNF - So create a new one
		 JRST	TPOPJ		; CAN NOT ENTER - Give ERROR
		CLOSE	STREAM,CL.DLL	; Close file and
		JRST	NEWST1]		;  loop back for UPDATE mode

NEWST2:	SETZM	STMNAM+.RBPRV		; Set creation and
	HLLZS	STMNAM+.RBEXT		;  access to today
	ENTER	STREAM,STMNAM		; Set UPDATE mode
	  JRST	[HRRZ  T1,STMNAM+.RBEXT	; Get error code
		 JUMPE	T1,TPOPJ	; %ERFNF??? - Give error
		  CLOSE	STREAM,0	; BUSY OR FILE ERR. ADVANCE
		 CALL	NXTALT		; TO NEXT ALTERNATE EXTENSION
		 JRST	NEWST1]		; GET NEW FILE TO UPDATE MODE

	Store	T1,STMZER,STMEZR-1,0	; Clear STM flags and data area
;; DO MAP PAGE HERE?
	MOVEI	T1,STMSIZ
	MOVEM	T1,STMCNT		; Set buffer count
	JRST	TPOPJ1

SUBTTL	NEXT ALTERNATE FILENAME

; ENTER HERE FROM "ACTCP1" LEVEL 2
; RE-OPEN OUTPUT SIDE OF STREAM CHANNEL. INT ROUTINE HAS
; ALREADY DONE CLOSE CH,CL.DLL  - NOW FORCE UPDATE OF ACCESS,
; CREATION TIMES & RE-OPEN FOR APPEND.

SETSTM:	PUSH	P,T1
	JRST	NEWST2

;NXTALT ENTER HERE TO GET NEXT ALTERNATIVE EXTENSION FOR
;	STREAM FILES. USUALLY USE MMDDYY.SAT, BUT IF NEED BE,
;	CHKPNT WILL OPEN MMDDYY.S01, MMDDYY.S02,,,QUIT AT
;	MMDDYY.S77 & CALL NOSTM, FATAL ERROR.

NXTALT:	HLRZ	T1,STMNAM+.RBEXT
	CAIN	T1,'S77'
	  CALL	NOSTM			;RAN OUT OF ALTERNATIVES
	CAIN	T1,'SAT'
	  MOVEI	T1,'S00'
	ADDI	T1,1
	TRNN	T1,7			;DID WE CARRY?
	ADDI	T1,100-10		;YES.  "S07" --> "S10", ETC.
	HRLZM	T1,STMNAM+.RBEXT
	POPJ	P,

SUBTTL GENERATE MMDDYY NAME

;GENNAM GENERATE NAME OF FORM MMDDYY IN T3 FOR OPENING NEW "USE" OR
;	"STREAM" FILE. THIS ROUTINE EXTRACTED FROM OLD "APPEND" PKG.
;
;ENTRIES:
;	GENNAM:  NO ARGS. GET DATE FR SYS, CONVERT, RETURN T2,T3
;	GENNM1:  T1=GMTDAT VALUE TO USE. CONVERT, RETURN T2,T3
;	GENNMM:  T1=DEC DATE,CONVERT, RETURN T3
;
;RETURNS: RT0 ALWAYS
;	T3/ SIXBIT NAME MMDDYY
;	T2/ CORRESPONDING NUMERIC MMDDYY GENNAM,GENNM1 ONLY
;
;CALLED: "NEWUSE" & "NEWSTM"

GENNAM:	MOVE	T1,[%CNDAT]
	GETTAB	T1,
	  MOVEI	T1,0
GENNM1:	MOVEM	T1,GMTDAT	;SAVE IT
	MOVEM	T1,DCNV
	SETZM	DCNV+1
	MOVSI	T1,400000	;JUST FROM DAYS TO DEC STYLE DATE
	MOVEM	T1,DCNV+2
	MOVEI	T1,DCNV
	DATUUO	T1,
	  JFCL
	MOVE	T1,DCNV
GENNMM:	IDIVI	T1,^D31
	PUSH	P,T2		;DAY-1
	IDIVI	T1,^D12
	PUSH	P,T2		;MONTH-1
	ADDI	T1,^D64
	CAIL	T1,^D100
	  SUBI	T1,^D100	;CONVERT 20XX INTO XX
	MOVE T2,[POINT 6,T3,29]	;SPOT FOR FIRST DIGIT
	PUSHJ	P,SXNM
	POP	P,T1		;MONTH-1
	ADDI	T1,1
	MOVE	T2,[POINT 6,T3,5]
	PUSHJ	P,SXNM
	POP	P,T1
	ADDI	T1,1
	MOVE T2,[POINT 6,T3,17]	;DAY
	PUSHJ	P,SXNM
	MOVE	T2,GMTDAT
	POPJ	P,
SXNM:	PUSH	P,T2		;BYTE POINTER
	IDIVI	T1,^D10
	ADDI	T1,'0'
	DPB	T1,(P)
	ADDI	T2,'0'
	IDPB	T2,(P)
	POP	P,T2
	POPJ	P,

SUBTTL TIMER-LEVEL CODE FOR "USE" & CHKPNT RECORDS.

;HERE WHEN THE TIMER GOES OFF

TIMINT:	MOVEM	17,USESAC+17
	MOVEI	17,USESAC
	BLT	17,USESAC+16
	MOVE	P,[IOWD 40,USEPDL]
	MOVE	PTR,TIMPTR
	SOSL	CHKCEL
	  JRST	NOCHK
	CALL	CHECK
	MOVEI	T1,CHKOFS
	MOVEM	T1,CHKCEL
NOCHK:	SKIPE	USEFIL
	  JRST	DONINT
	CALL	GENERR
	CALL	GENSTS
DONINT:	MOVE	T1,[1,,^D300]	;SET TIMER AGAIN
	SETTIM	T1,
	  CALL	BADUUO
	MOVEM	PTR,TIMPTR
	MOVSI	17,USESAC
	BLT	17,17
	DISMIS			;AND LEAVE INTERUPT

SUBTTL	FINISH STAT INFO

;ENTER HERE AT NON INTERRUPT LEVEL TO FINISH STAT INFO.

FINSTS:	MOVE	PTR,TIMPTR
	CALL	GENERR		;CLEAN UP ANY EXTRA ERRORS
	SETZB	T1,SNSCNT	;THIS IS TO GET THE FINAL SENSE DONE ON 3330'S
RRSET:	SYSPHY	T1,		;GET THE NEXT UNIT NAME
	  JRST	NOWERR		;ERROR FROM SYSPHY, GET ERRORS NOW
	JUMPE	T1,NOWERR	;OR ON END OF LIST
	 MOVEM	T1,RRSETB+1	;SET UNIT NAME TO FORCE READ AND RESET LOG
	MOVE	T2,[2,,RRSETB]
	STRUUO	T2,
	  JRST	RRSET		;ERROR RETURN, DO NOT FORCE ONE
	AOS	SNSCNT		;COUNT ONE MORE TO DO
	JRST	RRSET

NOWERR:	CALL	GENERR		;FOR NOW JUST FINISH UP ERROR CONDTIONS
	SKIPE	USEFIL		;IN CASE HAD TO SWITCH FILES AND COULD NOT
	  POPJ	P,	 	;JUST GIVE UP
	SKIPG	SNSCNT		;ANY MORE TO DO?
	  JRST	FINERR		;NO, DONE
	MOVEI	T1,1
	SLEEP	T1,		;SLEEP FOR A SECOND
	JRST	NOWERR		;AND TRY AGAIN
FINERR:	SKIPE	USEBUF
	 OUTPUT	FIL,COM		;WRITE LAST BUFFER
	CLOSE	FIL,CL.DLL	;AND CLOSE IT
	POPJ	P,

SUBTTL	GENERATE STATUS INFORMATION

GENSTS:	SKIPE	USEFIL
	  POPJ	P,
	MOVE	T1,CURTIM
	HRL	T1,CURDAT
	MOVEM	T1,(PTR)
	MOVE	T1,[%NSUPT]
	GETTAB	T1,
	  JRST	GETER
	MOVEM	T1,LSTUPT
	EXCH	T1,LSTTIM
	SUB	T1,LSTTIM
	MOVNM	T1,1(PTR)
	MOVNM	T1,INCUPT	;FOR DSK RECORD

	MOVE	T1,[%NSNUL]
	GETTAB	T1,
	  JRST	GETER
	EXCH	T1,LSTNUL
	SUB	T1,LSTNUL
	MOVNM	T1,2(PTR)
	MOVE	T1,[%NSLST]
	GETTAB	T1,
	  JRST	GETER
	EXCH	T1,LSTLOS
	SUB	T1,LSTLOS
	MOVNM	T1,3(PTR)

;Continued on next page


	HLRE	T1,JOBPTR	;T1/-NUMBER JOBS SYSTEM CONFIGURED FOR
	MOVNS	T1
	SUBI	T1,1		;T1/LAST JOB NO.
	HRRZ	T2,.JBFF
	MOVE	T3,T2		;T2 WILL REMEMBER FORMER .JBFF
	ADDI	T3,1(T1)
	IORI	T3,1777
	CAMG	T3,.JBREL
	  JRST	COROK
	CORE	T3,
	  JRST	CORER
COROK:	CALL	SIZJOB
	SOJG	T1,.-1
	MOVE	T3,5(PTR)
	IDIV	T3,4(PTR)
	MOVEM	T3,6(PTR)
SRLP1:	HRRZ	T1,.JBFF
	CAML	T1,T2
	  JRST	FNDMOD		;FIND MEDIAN JOB SIZE
	HRRZ	T3,(T1)
	HRL	T3,T1
	ADDI	T1,1
SRLP:	CAML	T1,T2
	  JRST	FINSRL
	MOVE	T4,(T1)
	CAIG	T4,(T3)
	  AOJA	T1,SRLP
	 HRRZ	T3,T4
	HRL	T3,T1
	AOJA	T1,SRLP

FINSRL:	MOVE	T4,-1(T2)
	MOVSS	T3
	EXCH	T4,(T3)
	MOVEM	T4,-1(T2)
	SOJA	T2,SRLP1

;Continued on next page


FNDMOD:	MOVE	T1,4(PTR)
	SUBI	T1,1
	IDIVI	T1,2
	ADD	T1,.JBFF
	MOVE	T3,(T1)
	ADD	T1,T2
	ADD	T3,(T1)
	IDIVI	T3,2
	MOVEM	T3,7(PTR)
	CALL	NXTREC
	SKIPE	USEFIL
	  POPJ	P,		;IN CASE WE LOST WRITING THAT ONE
	SKIPGE	T1,LSTDSK	;FIRST TIME?
	  JRST	[MOVE	T1,CURDSK
		MOVEM	T1,LSTDSK
		MOVE	T1,CURMON
		MOVEM	T1,LSTMON
		MOVE	T1,CURSWP
		MOVEM	T1,LSTSWP
		MOVEI	T1,.GTTR1	;NUMBER OF TRU'S TOTAL
		GETTAB	T1,
		  MOVEI	T1,0
		MOVEM	T1,LSTTRU
		POPJ	P,]		;JUST SET VARIABLES
	MOVE	T2,CURDSK
	MOVEM	T2,LSTDSK
	SUB	T2,T1
	MOVEM	T2,3(PTR)	;DISK USAGE
	MOVE	T1,CURSWP
	EXCH	T1,LSTSWP
	SUB	T1,LSTSWP
	MOVNM	T1,4(PTR)	;AND SWP
	HRROI	T1,7
	MOVEM	T1,1(PTR)
	MOVE	T1,INCUPT
	MOVEM	T1,2(PTR)	;INCREMENTAL UPTIME
	MOVEI	T1,.GTTRU
	GETTAB	T1,
	  MOVEI	T1,0
	EXCH	T1,LSTTRU
	SUB	T1,LSTTRU
	TLO	T1,400000	;JUST IN CASE OF SINGLE PRECISION OVERFLOW
	MOVNM	T1,5(PTR)	;INCREMENTAL TRU'S
	MOVE	T1,CURTIM
	HRL	T1,CURDAT
	MOVEM	T1,(PTR)
	MOVE	T1,CURMON
	EXCH	T1,LSTMON
	SUB	T1,LSTMON
	MOVNM	T1,6(PTR) 	;NUMBER OF PAGES OF MONITOR (PCB) I/O
;	JRST	NXTREC		; FALL INTO NXTREC TO WRITE

SUBTTL	NEXT RECORD: NXTREC

NXTREC:	ADDI	PTR,17
	SETOM	USEBUF		;BUFFER HAS DATA
	AOBJN	PTR,CPOPJ
;; VMOVPG[ FIL,-1 ]
;; VREMOV[ USEPAG ]
;; VREPLC[ USEPAG_ NEXT(CACHE) ]
;; VCREAT[ FILL(CACHE) ]
	CLOSE	FIL,CL.IN!CL.DLL
	CALL	SETFIL
	  JRST	NOUSE		;ERROR
	POPJ	P,

SUBTTL	ERROR MESSAGE ROUTINES

NOJAL:	MOVEI	T1,[ASCIZ /
CHKPNT HAS INSUFFICIENT LICENSE/]

;ENTER AT NOTRUN T1/ADDR OF ASCIZ

NOTRUN:	MOVEI	T2,0
	SETNAM	T2,		;FOR INITIA
	GETLIN	T3,		;MAKE SURE WE CAN OUTSTR W/O HANGING UP
	  HLRZS	T3		;RETURNS LH ZERO IF DETACHED
	JUMPE	T3,FATERR	;NO TTY,PUT ON CTY & DIE
	 OUTSTR	(T1)		;JRST NOTRUN with T1/ addr or asciz err msg
	CALL	ERRMES		;CTY too
	EXIT

FATERR:	CALL	ERRMES		;CALL FATERR W/T1 PT AT MESSAGE
	RESET
	MOVEI	T1,0
	SETNAM	T1,		;FOR INITIA
	HALT	.

ERRMES:	SETUUO	T1,
	  JFCL
	POPJ	P,

NODSK:	MOVEI	T1,[ASCIZ /
CHKPNT unable to access DSK:/]
	JRST	FATERR

NOUSE:	MOVEI	T1,[ASCIZ /
CHKPNT not gathering statistical data (not fatal)/]
	CALL	ERRMES
	SETOM	USEFIL
	RELEASE	FIL,0
	POPJ	P,

NOSTM:	RELEASE	STREAM,
	RELEASE	ACTDV,
	MOVE	T1,[POINT 7,STMERM]
	MOVEM	T1,STMERP
	MOVEI	T1,[ASCIZ/
job /]
	CALL	APPERM
	PJOB	N1,
	CALL	DECWR
	MOVEI	T1,[ASCIZ/ CHKPNT no acctg files.  Leave system up;
Notify operating system group immediately!/]
	CALL	APPERM
	MOVEI	T1,STMERM
	JRST	FATERR



BADUUO:	MOVEI	T1,[ASCIZ /
CHKPNT illegal uuo function./]
	JRST	FATERR

GETER:	MOVEI	T1,[ASCIZ /
CHKPNT GETTAB error./]
	JRST	FATERR

CORER:	MOVEI	T1,[ASCIZ /
CHKPNT insufficient core./]
	JRST	FATERR

BADPUT:	MOVEI	T1,[ASCIZ/
CHKPNT PUT-STREAM UUO failure,/]
	CALL	ERRMES
	CAIG	T4,3
	  CAIGE	T4,0	;CODES 0-3 LEGAL
	 MOVEI	T4,4
	MOVE	T1,BADMSG(T4)
	CALL	ERRMES
	MOVEI	T1,[ASCIZ/
location:/]
	CALL	ERRMES
	HRRZ	T4,(P)
	CALL	OUTNUM
	JRST	FATERR
BADMSG: [ASCIZ/ no ACT owner!?/]
	[asciz/ license wrong/]
	[asciz/ size wrong/]
	[asciz/ bad record type/]
	[asciz/ illeg error code/]

SUBTTL	UTILITY ROUTINES:  OUTNUM

;OUTNUM	MAKE OUTPUT 12-DIGIT OCTAL STRING OUT OF NUMBER IN T4.
; RETURN RT0: T1/ "N1" POINT AT STRING FOR ERRMES TO PRINT
;	T2/ GARB (USED BYTE PTR)
;	T4/ GARB
;	T5/GARB
;	N1,N2,N3/ ASCII STRING

OUTNUM:	MOVE	T1,T4		;SAVE DATA FOR 2 HALFWORD OPERATIONS
	MOVE	T2,[POINT 7,N1]
	SETZB	N1,N2
	SETZ	N3,
	HLRZ	T4,T1
	CALL	OUTNU1		;DO LEFT HALF
	MOVEI	T4,","
	IDPB	T4,T2
	IDPB	T4,T2		;LEFT HALF,,RIGHT HALF
	HRRZ	T4,T1
	MOVEI	T1,N1		;POINT AT STRING
OUTNU1:	IDIVI	T4,^D8
	PUSH	P,T4+1		;T5 HAS REMDR
	SKIPE	T4
	  PUSHJ	P,.-3
	POP	P,T4
	ADDI	T4,"0"
	IDPB	T4,T2
	POPJ	P,

SUBTTL	UTILITY ROUTINES:  APPERM  APPERD

;APPERM APPEND STRING POINTED TO BY T1 TO STMERM.
; QUIT ON NULL

APPERM:	HRLI	T1,(POINT 7,0)	;MAKE BYTE PTR
	PUSH	P,T1
APPER2:	ILDB	T1,(P)
	JUMPE	T1,APPERX
	  IDPB	T1,STMERP
	JRST	APPER2
APPERX:	POP	P,T1
	POPJ	P,

;APPERD	WRITE DATE TO END OF STMERM STRING
;CLOBBERS T1,N1,N2,N3

APPERD:	MSTIME	T1,
	IDIVI	T1,^D1000	;T1:=SECONDS
	IDIVI	T1,^D60		;T1_MIN T2_SEC
	PUSH	P,T2
	IDIVI	T1,^D60		;T1_HRS, T2_MIN
	MOVE	N1,T1
	PUSHJ	P,DECWR
	MOVEI	T1,":"
	IDPB	T1,STMERP
	MOVE	N1,T2		;MINUTES
	PUSHJ	P,DECWR
	IDPB	T1,STMERP	;COLON SEPARATOR
	POP	P,N1		;SAVED SECONDS
	PUSHJ	P,DECWR
	MOVEI	T1," "
	IDPB	T1,STMERP	;APPENDED "HH:MM:SS " TO STR
	DATE	T2,
	IDIVI	T2,^D31		;T2 MONTHS,T3 DAYS
	MOVEI	N1,1(T3)
	PUSHJ	P,DECWR		;N1 DAYS TO STRING
	IDIVI	T2,^D12
	MOVEI	N1,MONTAB(T3)	;POINT N1 AT MONTH STR
	HRLI	N1,(POINT 7,0)	;MAKE BYTE PTR
STMER7:	ILDB	T1,N1
	IDPB	T1,STMERP	;COPY MONTH NAME TO ER MSG STR
	TLNE	N1,760000	;SKIP IF 5 CHARS WRITTEN
	  JRST	STMER7
	MOVEI	N1,^D1964(T2)
	PUSHJ	P,DECWR	;YEAR TO STRING
	POPJ	P,

SUBTTL	UTILITY ROUTINES:  DECWR  OCTWR  APP6B

;NUMBER WRITERS: DECWR, OCTWR
;EXPECTS N1/ NUMBER TO CONVERT & APPEND TO APPERM STRING
;STMERP/ BP TO CURRENT STRING POS
; RADIX WRITER RDXWR EXPECTS N4/ RADIX ALSO
;CLOBBERS N1-N4

OCTWR:	SKIPA	N4,[^D8]
DECWR:	MOVEI	N4,^D10
RDXWR:	MOVEI	N3,"0"
	CAIG	N1,-1(N4)
	  IDPB	N3,STMERP	;INSURE LEADING ZERO
RDXWR2:	IDIV	N1,N4
	HRLM	N2,0(P)
	SKIPE	N1
	  PUSHJ	P,RDXWR2
	HLRZ	N3,0(P)
	ADDI	N3,"0"
	IDPB	N3,STMERP
	POPJ	P,


;SIXBIT APPENDER   APP6B
;EXPECTS T3,T4 SIXBIT STRING TO APPEND TO STMERM
;STMERP/ BP TO CURR STRING POS
;CLOBBERS: T2,T3,T4	  WRITES 12 CHARS MAX, STOPS ON NULL

	LSHC	T3,6		;LOAD OUT OF TOP BYTE OF T3+T4
APP6B:	LDB T2,[POINT 6,T3,5]
	ADDI	T2,40
	IDPB	T2,STMERP
	CAIE	T2,40		;GOT A 00 BYTE?
	  JRST	APP6B-1		;NO,SHIFT 6 AND CONTINUE
	POPJ	P,

SUBTTL	GENERR

GENERR: SKIPE	USEFIL	
	  POPJ	P,
	DATE	T1,
	MOVEM	T1,CURDAT
	MSTIME	T1,
	IDIVI	T1,^D1000
	MOVEM	T1,CURTIM
	DATE	T1,
	CAME	T1,CURDAT
	  JRST	GENERR			;PASSING MIDNIGHT
	MOVSS	T1
	HRR	T1,CURTIM
	CAMG	T1,USETRM
	  JRST	GENER2			;NEED NEW FILE?
	CALL	NEWUSE			;YES
	  JRST	NOUSE			;COULD NOT GET IT
	MOVE	T1,CURTIM
	HRL	T1,CURDAT
	MOVEM	T1,(PTR)
	HRROI	T1,10
	MOVEM	T1,1(PTR)
	MOVE	T1,JFYSEC
	MOVEM	T1,2(PTR)		;MAKE SURE KNOWN
	CALL	NXTREC

;HERE TO WRITE STREAM RECORDS FROM UDBS.
;FOR EACH UNIT IN THE SYSTEM, SAVE ANY NEW ERRORS AND SENSE DATA.
; THE FORMER ARE TYPE -1,,0 RECORDS, THE LATTER -1,,4.

GENER2: SKIPE	USEFIL	
	  POPJ	P,
	MOVEI	T1,2			;SET TO READ ALL UDBS BY NAME
	MOVEM	T1,LOC
	SETZM	SYSNAM
	SETZM	CURSWP
	SETZM	CURMON
	SETZM	CURDSK
NXTUNI: MOVE  T1,[XWD 120,LOC]	;LOOP THROUGH HERE UNTIL END OF UDB LIST.
	SYSDVF	T1,
	  JRST	GETER
	SKIPN	T1,SYSNAM	 	;FINISHED?
	  JRST	DOMTA			;YES.
	MOVE	T2,SYSBLK+UNIMRC
	ADD	T2,SYSBLK+UNIMWC	;NUMBER OF PCB PAGES
	ADDM	T2,CURMON
	LSH	T2,2			;TO BLOCKS
	MOVNS	T2			;SUBTRACT FROM "SWAP" COUNT
	ADD	T2,SYSBLK+UNIICT
	ADD	T2,SYSBLK+UNIOCT
	ADDM	T2,CURSWP		;RECORD THINGS FOR TRANSFERS
	MOVE	T2,SYSBLK+UNIBRC
	ADD	T2,SYSBLK+UNIDRC
	ADD	T2,SYSBLK+UNIMRC
	ADD	T2,SYSBLK+UNIBWC
	ADD	T2,SYSBLK+UNIDWC
	ADD	T2,SYSBLK+UNIMWC
	ADDM	T2,CURDSK
	MOVE	T2,SYSBLK+UNIHCT
	IOR	T2,SYSBLK+UNISCT
	JUMPE	T2,DOSNS		;J-NO ERRORS ON CURRENT UNIT.
	 CALL	FNDUNI			;FIND THE UNIT IN THE LIST.
	  JRST	UNICOM			;NEW UNIT, DO NOT CHECK ERRORS.
	MOVE	T1,SYSBLK+UNIHCT	;COMPARE ERROR TALLY NOW WITH WHAT IT
	XOR	T1,2(T2)		; WHAT IT WAS THE LAST TIME THROUGH.
	MOVE	T3,SYSBLK+UNISCT
	XOR	T3,3(T2)
	IOR	T1,T3
	JUMPE	T1,DOSNS		;J-NO NEW ERRORS WERE RECORDED.
UNICOM:	MOVE	T1,CURTIM		;ERRORS, WRITE ERROR RECORD.
	HRL	T1,CURDAT
	MOVEM	T1,(PTR)
	MOVSI	T1,-1
	MOVEM	T1,1(PTR)
	HRROI	T1,4			;GET TRU FOR JOB
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,2(PTR)
	MOVE	T1,SYSBLK+UNINAM
	MOVEM	T1,3(PTR)
	MOVEM	T1,1(T2)		;IN CASE THIS IS A NEW UNIT.
	MOVE	T1,SYSBLK+UNILOG
	MOVEM	T1,4(PTR)
	MOVE	T1,SYSBLK+UNIHCT
	MOVEM	T1,5(PTR)
	MOVEM	T1,2(T2)		;SAVE ERRORS.
	MOVE	T1,SYSBLK+UNISCT
	MOVEM	T1,6(PTR)
	MOVEM	T1,3(T2)
	LDB	T1,UNYKTP		;CONTROLLER TYPE.
	CAILE	T1,MCT			;DO WE KNOW ABOUT IT?
	  MOVEI	T1,MCT			;NO, CALL IT THIS ONE.
	CALL	@[EXP ERRBP,ERRBP,ERRBP,ERRBP,ERRBP,ERRRM](T1)
	PUSH	P,T2			;SAVE AROUND NXTREC.
	CALL	NXTREC			;ADVANCE RECORD BUFFER POINTER.
	POP	P,T2
	SKIPE	USEFIL
	  RET
	LDB	T1,UNYKTP
	CAIE	T1,TYPBP		;3330S?
	  JRST	NXTUNI		;NO, SO NO SENSE DATA.
	JRST	DOSNS

SUBTTL	RM03 error records

;Two records are written to report Rm03 errors:
; #1 (type 0):
;   0: tad, 1: -1,,0 2: tru count of CHKPNT 3: UNINAM 4: UNILOG
;   5: UNIHCT 6: UNISCT 7-17: UNISBH.
; #2 (type 1):
;   0: ? 1: -1,,100 2: ? 3: UNIHBN 4: UNISBN 5: UNIECT 6-16: UNISBS.
ERRRM:	MOVSI	T1,SYSBLK+UNISBH	;RM03 HARD ERROR DATA.
	HRRI	T1,7(PTR)
	BLT	T1,17(PTR)
	PUSH	P,T2
	MOVSI	T1,400000
	LDB	T2,UNYUTP		;UNIT TYPE
	SKIPE	T2
	  IORM	T1,7(PTR)	 	;FLAG RP06
	CALL	NXTREC			;ADVANCE RECORD BUFFER POINTER
	POP	P,T2
	MOVE	T1,CURTIM
	HRL	T1,CURDAT
	MOVEM	T1,0(PTR)
	HRROI	T1,100			;SECOND ERROR RECORD, TYPE (-1,,100)
	MOVEM	T1,1(PTR)
	MOVSI	T1,SYSBLK+UNISHS	;RM03 SOFT ERROR DATA.
	HRRI	T1,6(PTR)
	BLT	T1,16(PTR)
	MOVE	T1,SYSBLK+UNIHBN
	MOVEM	T1,3(PTR)
	MOVE	T1,SYSBLK+UNISBN
	MOVEM	T1,4(PTR)
	MOVE	T1,SYSBLK+UNIECT
	MOVEM	T1,5(PTR)
	  RET
ERRBP:	MOVE	T1,SYSBLK+UNIERR	;3330 ERROR DATA.
	MOVEM	T1,7(PTR)
	MOVE	T1,SYSBLK+UNISOF
	MOVEM	T1,10(PTR)
	MOVE	T1,SYSBLK+UNIHBN
	MOVEM	T1,11(PTR)
	MOVE	T1,SYSBLK+UNISDI
	MOVEM	T1,12(PTR)
	MOVE	T1,SYSBLK+UNIHDI
	MOVEM	T1,13(PTR)
	MOVE	T1,SYSBLK+UNIECT
	MOVEM	T1,14(PTR)
	MOVE	T1,SYSBLK+UNISBN
	MOVEM	T1,15(PTR)		;SOFT ERROR BLOCK NUMBER
	RET


DOSNS:	MOVE	T1,SYSNAM+1	;CHECK TO SEE IF SENSE BYTES
	CAIGE	T1,UNISNC 	;IS THERE A SENSE COUNT?
	  JRST	NXTUNI		;NO, NOTHING TO DO.
	JUMPN	T2,DOSNS1 	;WAS THIS UNIT FOUND ALREADY?
	SKIPN	SYSBLK+UNISNC	;HAS A SENSE BEEN DONE?
	  JRST	NXTUNI		;NO, FORGET IT.
	MOVE	T1,SYSNAM	;GET UNIT DESCRIPTOR IN T2.
	CALL	FNDUNI
	  MOVEM	T1,1(T2)
DOSNS1:	MOVE	T1,SYSBLK+UNISNC
	CAMN	T1,4(T2)	;SEE IF CHANGED SINCE UNIT DATA STORED.
	  JRST	NXTUNI
	MOVEM	T1,4(T2)	;RESET IN CORE.
	MOVE	T1,CURTIM
	HRL	T1,CURDAT
	MOVEM	T1,(PTR)
	HRROI	T1,4		;ERROR CODE TYPE 4
	MOVEM	T1,1(PTR)
	HRROI	T1,4
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,2(PTR) 	;ALL THIS SETS BASIC INFORMATION
	MOVE	T1,SYSBLK+UNINAM
	MOVEM	T1,3(PTR)
	MOVEI	T1,4(PTR)
	HRLI	T1,SYSBLK+UNISNS	;GET READY FOR SENSE DATA
	BLT	T1,11(PTR)
	CALL	NXTREC		;ADVANCE RECORD BUFFER POINTER.
	SOS	SNSCNT		;DECREMENT COUNT OF SENSE REMAINING IF LAST
	SKIPE	USEFIL
	  POPJ	P,
	JRST	NXTUNI

SUBTTL	NEWUNI	FNDUNI

;RETURN NEW 5 WORD UNIT DESCRIPTOR ADDRESS IN T2, CONSED ONTO FRONT OF
; CHAIN OF UNITS.  THE CHAIN IS SINGLY LINKED THROUGH THE RIGHT HALF OF
; THE FIRST WORD IN THE DESCRIPTOR.

NEWUNI:	MOVE	T2,.JBFF
	ADDI	T2,5
	CAMG	T2,.JBREL
	  JRST	UNCROK
	IORI	T2,1777
	CORE	T2,
	  JRST	CORER
UNCROK:	MOVEI	T2,5
	EXCH	T2,.JBFF
	ADDM	T2,.JBFF
	MOVE	T3,UNILST
	MOVEM	T3,(T2)
	HRRZM	T2,UNILST
	SETZM	1(T2)		;JUST TO MAKE SURE.
	SETZM	2(T2)
	SETZM	3(T2)
	SETZM	4(T2)
	POPJ	P,


;FIND A UNIT IN THE UNIT DESCRIPTOR LIST. THE NAME OF THE UNIT IS IN T1.
;RETURN POINTER TO 5 WORD BLOCK IN T2
;SKIP RETURN IF OLD, NON-SKIP WITH NEW BLOCK CREATED IF NEW.

FNDUNI:	MOVEI	T2,UNILST
SRCUNI:	HRRZ	T2,(T2)
	JUMPE	T2,NEWUNI 	;END OF LIST
	CAME	T1,1(T2)	;CHECK NAME
	  JRST	SRCUNI		;NOT THE SAME
CPOPJ1:	AOS	(P)		;SKIP RETURN (INCR RET ADDR)
CPOPJ:	POPJ	P,		;RETURN



DOMTA:	MOVEI	T4,0		;THIS IS THE LINKED GETTAB POINTER
MTASRC:	MOVEI	T1,.GTLNK
	HRL	T1,T4
	GETTAB	T1,
	  JRST	DOFTA		;MUST BE OUT OF GETTABS
	CAMN	T1,[SIXBIT /MTANAM/]
	  JRST	GOTMTA
	ADDI	T4,2
	JRST	MTASRC		;CONTINUE SEARCHING

GOTMTA:	MOVEI	T1,.GTLNK
	HRLI	T1,17(T4)	;CHECK FOR ERRORS
	GETTAB	T1,
	  JRST	DOFTA		;SOMETHING WRONG
	JUMPE	T1,MTANXT	;NO ERRORS
	MOVEI	T1,.GTLNK
	HRLI	T1,1(T4)
	GETTAB	T1,		;GET THE UNIT NAME
	  JRST	DOFTA
	CALL	FNDUNI
	  JRST	NEWMTA		;THIS IS A NEW UNIT
	MOVEI	T1,.GTLNK
	HRLI	T1,17(T4)
	GETTAB	T1,
	  JRST	DOFTA
	CAME	T1,2(T2)	;HAS ERROR COUNT CHANGED?
	  JRST	NEWMTA		;YES, PUT OUT A RECORD
MTANXT:	ADDI	T4,32
	JRST	MTASRC		;SKIP THIS MTA BLOCK
NEWMTA:	MOVE	T1,CURTIM
	HRL	T1,CURDAT
	MOVEM	T1,(PTR)
	HRROI	T1,1
	MOVEM	T1,1(PTR)
	MOVEI	T1,.GTLNK
	HRLI	T1,1(T4)
	GETTAB	T1,
	  JRST	DOFTA
	MOVEM	T1,3(PTR)
	MOVEM	T1,1(T2)	;IN CASE NEW UNIT
	MOVEI	T1,.GTLNK
	HRLI	T1,17(T4)
	GETTAB	T1,
	  JRST	DOFTA
	MOVEM	T1,4(PTR)
	MOVEM	T1,2(T2)	;IN CASE NEW UNIT

;Continued on next page
	DEFINE INFO (FROM,TO)<
	MOVEI	T1,.GTLNK
	HRLI	T1,FROM(T4)
	GETTAB	T1,
	  JRST	DOFTA
	MOVEM	T1,TO(PTR)
>

	INFO	(15,5)
	INFO	(21,6)
	INFO	(23,7)
	INFO	(25,10)
	INFO	(27,11)
	INFO	(31,12)
	CALL	NXTREC		;WRITE THE RECORD
	SKIPE	USEFIL
	  POPJ	P,
	JRST	MTANXT

;GENERATE A RESTART RECORD
RSTREC:	MSTIME	T1,
	IDIVI	T1,^D1000
	MOVEM	T1,(PTR)
	DATE	T1,
	HRLM	T1,(PTR)
	HRROI	T1,2
	MOVEM	T1,1(PTR)
	JRST	NXTREC


DOFTA:	SETZM	SYSNAM
	MOVEI	T1,4
	MOVEM	T1,LOC		;SET FOR FTA
FTALP:	MOVE	T1,[XWD 73+3,LOC]
	SYSDVF	T1,
	  JRST	DOTMX		;NOW MAGTAPES ON 2020
	SKIPN	T1,SYSNAM
	  JRST	DOTMX
	MOVE	T2,SYSBLK+FTARCT
	ADD	T2,SYSBLK+FTARFL
	ADD	T2,SYSBLK+FTAWCT
	ADD	T2,SYSBLK+FTAWFL
	ADD	T2,SYSBLK+FTAHNC	;HUNG COUNT
	JUMPE	T2,FTALP	;NO ERRORS
	PUSH	P,T2
	CALL	FNDUNI
	  JRST	NEWFTA		;THIS IS A NEW FTA
	POP	P,T3		;GET BACK ERROR COUNT
	CAMN	T3,2(T2)	;NUMBER OF ERRORS CHANGED?
	  JRST	FTALP		;NO, DO NOT RECORD
	SKIPA
NEWFTA:	  POP	P,T3
	MOVE	T1,SYSBLK+FTARCT
	MOVEM	T1,4(PTR)
	MOVE	T1,SYSBLK+FTARFL
	MOVEM	T1,5(PTR)
	MOVE	T1,SYSBLK+FTAWCT
	MOVEM	T1,6(PTR)
	MOVE	T1,SYSBLK++FTAWFL
	MOVEM	T1,7(PTR)
	MOVE	T1,SYSBLK+FTASCI
	MOVEM	T1,10(PTR)
	MOVE	T1,SYSBLK+FTAHCI
	MOVEM	T1,11(PTR)

;Continued on next page

	MOVE	T1,SYSBLK+FTAHNC
	MOVEM	T1,12(PTR)
	MOVE	T1,SYSBLK+FTAHFN	;HUNG FUNCTION
	MOVEM	T1,13(PTR)
	MOVE	T1,SYSBLK+FTACIH	;CONI ON HUNG
	MOVEM	T1,14(PTR)
	CALL	NXTREC			;DUMP THAT RECORD
	SKIPE	USEFIL
	  POPJ	P,
	MOVE	T1,CURTIM
	HRL	T1,CURDAT
	MOVEM	T1,(PTR)
	HRROI	T1,5			;SENSE FOR FTA
	MOVEM	T1,1(PTR)
	HRROI	T1,4
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,2(PTR)
	MOVE	T1,SYSBLK+FTANAM
	MOVEM	T1,3(PTR)
	MOVEI	T1,4(PTR)
	HRLI	T1,SYSBLK+FTASNS	;SENSE BYTES
	BLT	T1,11(PTR)
	CALL	NXTREC			;DUMP RECORD
	SKIPE	USEFIL
	  POPJ	P,
	JRST	FTALP			;AND CONTINUE

SUBTTL	2020 MAGTAPE ERRORS - TU45A, TM02

;HERE TO LOG ERRORS ON 2020 MAGTAPES (TU45A, TM02 CONTROLLER)

DOTMX:	SETZM	SYSNAM
	MOVEI	T1,5
	MOVEM	T1,LOC		;SET FOR TMX
TMXLP:	MOVE	T1,[XWD 24+3,LOC]
	SYSDVF	T1,
	  JRST	DOPAR		;NOW PARITY ERRORS.
	SKIPN	T1,SYSNAM
	  JRST	DOPAR
	MOVE	T2,SYSBLK+TMXEC
	ADD	T2,SYSBLK+TMXHC	;HUNG COUNT
	JUMPE	T2,TMXLP	;NO ERRORS
	PUSH	P,T2
	CALL	FNDUNI
	  JRST	NEWTMX		;THIS IS A NEW TMX
	POP	P,T3		;GET BACK ERROR COUNT
	CAMN	T3,2(T2)	;NUMBER OF ERRORS CHANGED?
	  JRST	TMXLP		;NO, DO NOT RECORD
	SKIPA
NEWTMX:	  POP	P,T3
	MOVEM	T3,2(T2)	;RECORD NUMBER OF ERRORS
	MOVE	T1,CURTIM
	HRL	T1,CURDAT
	MOVEM	T1,(PTR)
	HRROI	T1,101		;TMX ERROR CODE
	MOVEM	T1,1(PTR)
	HRROI	T1,4
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,2(PTR)
	MOVE	T1,SYSBLK+TMXNAM
	MOVEM	T1,3(PTR)
	MOVEM	T1,1(T2)	;IN CASE NEW UNIT
	MOVE	T1,SYSBLK+TMXHC
	MOVEM	T1,4(PTR)
	MOVE	T1,SYSBLK+TMXEC
	MOVEM	T1,5(PTR)
	HRRI	T1,6(PTR)
	HRLI	T1,SYSBLK+TMXSB
	BLT	T1,14(PTR)
	CALL	NXTREC
	SKIPE	USEFIL
	  POPJ	P,
	JRST	TMXLP


SUBTTL	PARITY ERROR LOGGING

DOPAR:	MOVE	T1,[%NSSPE]
	GETTAB	T1,
	  MOVEI	T1,0
	CAMG	T1,LSTPAR	;MORE THAN BEFORE?
	  POPJ	P,	 	;NO, DO NOT RECORD
	MOVEM	T1,2(PTR)
	MOVEM	T1,LSTPAR	 ;SAVE AND GENERATE RECORD
	MOVE	T1,[%NSTPE]
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,3(PTR)
	MOVE	T1,[%NSMPA]
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,4(PTR)
	MOVE	T1,[%NSMPW]
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,5(PTR)
	MOVE	T1,[%NSMPP]
	GETTAB	T1,
	  MOVEI	T1,0
	MOVEM	T1,6(PTR)
	HRROI	T1,6
	MOVEM	T1,1(PTR)
	MOVE	T1,CURTIM
	HRL	T1,CURDAT
	MOVEM	T1,(PTR)
	JRST	NXTREC		;GOT THE PARITY RECORD

SUBTTL	STATISTICS ROUTINES - SIZJOB  SIZE

;SIZJOB EXPECTS T1/ 0,,JOB #

SIZJOB:	HRLZ	T3,T1
	GETTAB	T3,		;GET JBTSTS(J)
	  JRST	GETER
	TLNN	T3,JNA
	  POPJ	P,	 	;NO JOB YET
	AOS	4(PTR)
	MOVE	T3,T1
	CALL	SIZE		;RETURN T4/ SIZE IN K
	HRL	T3,T1
	HRRI	T3,14
	GETTAB	T3,
	  JRST	NOSEG		;IFNORE ERR FOR VM/NON-VM SYS COMPATIBILITY
	JUMPLE	T3,NOSEG	;NO HIGH SEG
	HRRZS	T3
	PUSH	P,T4
	CALL	SIZE		;SIZE OF HIGH SEG
	POP	P,T3
	ADD	T4,T3
NOSEG:	ADDM	T4,5(PTR)	;TOTAL SIZE
	MOVEM	T4,(T2)		;SAVE IN LIST
	ADDI	T2,1
	CAILE	T4,^D56
	  MOVEI	T4,^D56
	IDIVI	T4,10
	ADDI	T4,10(PTR)
	AOS	(T4)
	POPJ	P,

;SIZE EXPECTS T3/JOB #;  RETURNS T4/SIZE IN K

SIZE:	HRL	T4,T3
	HRRI	T4,1
	GETTAB	T4,		;ALWAYS RETURNS 0 SINCE P032/C
	  JRST	GETER
	JUMPE	T4,SWAP
	HLRZS	T4
	ADDI	T4,1777
	LSH	T4,-^D10
	POPJ	P,
SWAP:	HRL	T4,T3
	HRRI	T4,7
	GETTAB	T4,	;SIMULATED IN VM SYS FROM COUNT OF EXISTENT PAGES
	  JRST	GETER
	LDB	T4,[POINT SWPSIZ,T4,SWPPOS]
	LSH	T4,-1		;CONVERT PAGES TO K
	POPJ	P,

SUBTTL	CHECK - Write a checkpoint record to stream for all jobs

;CHECK:  WRITE A CHECKPOINT RECORD TO STREAM FOR ALL JOBS
;	ALIVE IN SYSTEM.

CHECK:	MOVE	T5,JOBPTR	;THIS WAS SET AT INITIALIZATION
	AOBJP	T5,CHKEND	;DONE IF OUT OF JOBS
CHKLP:	HRL	T1,T5
	HRRI	T1,.GTSTS	;GET STATUS
	GETTAB	T1,
	  JRST	CHKNXT		;TRY NEXT IF CAN NOT GET IT
	TLNE	T1,JLOG		;IF NOT LOGGED IN
	  TLNN	T1,JNA		;OR JOB NUMBER NOT ASSIGNED
	 JRST	CHKNXT		;SKIP THIS ONE
CHKCOK:	MOVSI	T2,-GTBLEN

;FOLLOWING LOOP INDEX T2 THRU GTAB. T3:=CURR JOB,,GETTAB ITEM;
;(T5=JOBPTR=AOBJN INITIAL -NUMBER JOBS,,0),
;T3:=GETTAB DATA, OR [T3,T4] :=DOUBLE PRECISION GETTAB DATA,
;T1:=INDEX IN LH GTAB(T2) FOR PLACEMENT IN CKPREC

GTBLOP:	HRRZ	T3,GTAB(T2)
	HRL	T3,T5		;T3:=JOB,,GETTAB ITEM
	GETTAB	T3,
	  SETZB	T3,T3+1		;DEFAULT ZERO. (T3+1 INCASE D.P.)
	HLRZ	T1,GTAB(T2)
	TRZE	T1,(1B0)	;TEST & RESET D.P. FLAG
	  MOVEM	T3+1,CKPREC+1(T1)	;DEPOSIT LOW ORDER VALUE
	MOVEM	T3,CKPREC(T1)
	AOBJN	T2,GTBLOP
	MOVE	T3,CKPHED	;HEADER WORD FOR CHKPNT REC
	MOVEM	T3,CKPREC
	DPB	T5,[POINT 9,CKPREC,17]	;JOB NO. IN HEADER
;MONITOR DUPPLIES TIME STAMP.
	SETOM	CKPFLG		;FLAG WORD 5 THIS IS CKPNT REC
	HRLOI	T2,77
	ANDM	T2,CKPRCT
	ANDM	T2,CKPWCT	;MASK BLOCK WRITTEN & READ
	HRL	T2,T5
	HRRI	T2,.GTLIN	;GET TTY LINE NAME
	GETTAB	T2,
	  SKIPA			;FAIL
	TLNN	T2,-1
	  JRST	[SETZ	T3,
		JRST	LINFIN]
	HRRZS	T2
	MOVEI	T3,0
	LDB	T4,[POINT 6,T2,23]
	JUMPE	T4,LINFIN
	MOVEI	T3,-'0'(T4)
	LDB	T4,[POINT 6,T2,29]
	JUMPE	T4,LINFIN
	IMULI	T3,10
	ADDI	T3,-'0'(T4)
	LDB	T4,[POINT 6,T2,35]
	JUMPE	T4,LINFIN
	IMULI	T3,10
	ADDI	T3,-'0'(T4)
LINFIN:	HRLS	T3
	HRRI	T3,.GTLOG
	GETTAB	T3,
	  MOVEI	T3,0
LINFN1:	MOVEM	T3,CKPLOG
	LDB	T3,[POINT 4,T3,11]	;GET TTY TYPE
	DPB	T3,[POINT 12,CKPREC,29]
;SEND THIS CHKPNT RECORD TO STREAM, ON TO NEXT JOB, IF ANY
	MOVEI	T4,CKPREC
	PUTSAR	T4,		;(USE T4 FOR BADPUT)
	  CALL	BADPUT
CHKNXT:	AOBJN	T5,CHKLP	;NEXT JOB, IF ANY
CHKEND:	POPJ	P,


	END STPT
 0 Z