	TYMSPC==14		;TYMSHARE SPEC OF CREF
	TYMREL==3		;RELEASE OF TYMSHARE SPEC
	DECSPC==37		;DIGITAL VERSION
	DECREL==0		;RELEASE OF DEC VERSION

DEFINE TITL(TS,TR,DS,DR)<
TITLE	CROSS (OR CREF) - VERSION TS'.'TR'-'DS'.'DR
SUBTTL	CROSS REFERENCE GENERATION PROGRAM -AUG 21,1975
IF1,<PRINTX VERSION TS'.'TR'-'DS'.'DR>
VCREF==BYTE(8)DS,TS,DR,TR>

	TITL(\TYMSPC,\TYMREL,\DECSPC,\DECREL)

	LOC	137
JOBVER:	VCREF
	RELOC
EXTERNAL	JOBFF,	JOBREL,	JOBDDT,	JOBSYM
INTERNAL	CREF

IFNDEF TEMPC,<TEMPC==1>	;TMPCOR UUO ALLOWED IF SET TO 1
;ACCUMULATOR DEFINITIONS
AC0==0
TEMP==1
TEMP1==2
WPL==3	;CONTAINS COUNT OF HOW MANY REFERENCES/LINE IN LISTING
RC==WPL
SX==4
BYTEX==5
BYTEM==6
TX==BYTEM
TIO==6	;AC USED FOR MTAPE FLAGS IN COMMAND SCANNER LOGICTX==BYTEM
C==7
CS==10
LINE==11	;HOLDS LINE #
FLAG==12
FREE==13	;POINTS TO HIGH END OF INCREMENT BYTE TABLE
TOP==15	;CONTAINS HIGHEST AVAILABLE ADR IN MEMORY
IO==16	;HOLDS FLAGS
P==17	;PUSH DOWN POINTER

;DEFINITIONS FOR LENGTHS OF LINES AND PAGES
WPLLPT==^D14	;IN OUTPUT LPT LISTING, 14 REFERENCES/LINE
WPLTTY==8	;IN OUTPUT TTY LISTING, 8 REFERENCES/LINE
.LPP==^D56	;LINES PER PAGE IN LISTING
PDL==30		;PUSH DOWN STACK LENGTH

IOLST==	000001	;IF 1, SUPPRESS PROGRAM LISTING
IONCRF==000002	;1 IF COMMAND STRING SEARCH LIMITS BEING USED
IOPAGE==000004	;IF 1, DO A FORM FEED
IOFAIL==000010	;1 IF "NEW STYLE" CREF DATA HAS BBEN SEEN
IODEF==	000020	;1 IF SYMBOL IS A DEFINING OCCURRANCE
IOENDL==000040
IORPG==	000100	;1 IF RPG SYSTEM IN USE (SET BY STATTING AT (JOBSA)+1)
IOTABS==000200	;"RUBOUT A" SEEN AT AND OF CREF DATA (INSERT TAB IN LISTING)
IOEOF==	000400	;END OF FILE SEEN
IONLZ==	001000	;LEADING ZERO TEST
IOTB2==	002000	;FOR F4
IOSAME==10000	;TO SYMBOLS WITH SAME BLOCK NAME
IOTTY==	004000	;1 IF LISTING DEVICE IS TTY
IOSYM==	040000	;SYMBOL DEFINED WITH = OR :
IOMAC==	100000	;MACRO NAME
IOOP==	200000	;OPDEF, OP CODE, OR PSEUDO INSTRUCTION OCCURRANCE
IODF2==	020000	;DEFINING OCCURRANCE OF A SYMBOL

;RIGHT HALF OF IO
IOCMB==1	;COMBINE FORTRAN PROGRAMS ON SAME FILE
IOJLST==2	;JUST LIST. DO NOT CHECK CREF INFO
IOSOUT==4	;SPECIAL OUTPUT TO A SWEET PROGRAM
IOERR==10	;WE HAVE GIVEN THE ILLEGAL INPUT FORMAT MESSAGE
IOEXT==20	;DEF IS EXTERNAL
IOSUBT==40	;TITLE CONTAINS CR-LF (SUBTITLE)

;DEFINITIONS FOR "OLD STYLE" CODES FROM VARIOUS PROCESSORS
%OP==33
%MAC==34
%LINE==35
%SYM==36
%EOF==37	;MULTIPLE-PROGRAM BREAK CHARACTER
HASH==^D101	;HASH CODE TO USE FOR SYMBOL TABLE

A==0		;ASCII MODE
AL==1		;ASCII LINE MODE

CTLI==1		;CONTROL DEVICE NUMBER (INPUT)
CHAR==2			;INPUT DEVICE NUMBER
LST==3			;LISTING DEVICE NUMBER
SOP==4		;SPECIAL OUTPUT CHANEL

;	COMMAND STRING ACCUMULATORS

ACDEV==TEMP			;DEVICE
ACFILE==TEMP1			;FILE
ACEXT==TX			;EXTENSION
ACDEL==4			;DELIMITER
ACPNTR==5			;BYTE POINTER

;FLAGS USED IN AC TIO

TIORW==1000	;MTAPE REWIND FLAG
TIOLE==2000	;SET(BUT NOT USED ANYWHERE) BY BACKSPACE REQUEST
TIOCLD==20000	;CLEAR DIRECTORY FLAG

OPDEF	RESET	[CALLI	 0]
OPDEF	DEVCHR	[CALLI	 4]
OPDEF	WAIT	[MTAPE	 0]
OPDEF	CORE	[CALLI	11]
OPDEF	UTPCLR	[CALLI	13]

OPDEF	DDTOUT	[CALLI 3]
OPDEF	EXIT	[CALLI 12]
TMPCOR==44	;TMPCOR UUO CALLI #

COMMENT * THIS IS AN EXPLANATION OF THE CREF SYMBOL TABLE
AND LINE NUMBER STORAGE MECANISM. LINE NUMBERS ARE STORED IN
TWO WORD BLOCKS. THE FIRST WORD OF EACH BLOCK IS GUARANTEED
TO HAVE AN EVEN ADDRESS. THE FIRST WORD OF THE BLOCK AND
THE LEFT HALF OF THE SECOND WORD ARE USED TO STORE LINE NUMBERS.
THE RIGHT HALF OF THE SECOND WORD IS A POINTER TO THE NEXT
TWO WORD BLOCK. THE POINTER IS 0 IF THIS IS THE LAST
BLOCK. (THIS IS TRUE OF ALL THINGS REFERED TO AS POINTERS
IN THE FUTURE) LINE NUMBERS ARE STORED IN SIXBIT BYTES.
CREF PICKS UP THE FIRST SIX BIT BYTE. IF THE HIGH ORDER
BIT OF THESE SIX IS 0, THEN CREF HAS ALL OF THE LINE NUMBER.
IF IT IS NON-ZERO, CREF SHIFTS IT LEFT 5 AND ORS IN THE LOW ORDER
FIVE BITS OF THE NEXT SIX BIT BYTE, REPEATING
THIS PROCESS UNTIL IT FINDS A BYTE WITH THE HIGH ORDER BIT 0.
THE LINE NUMBERS THAT ARE STORED ARE RELITIVE. THAT IS THE
NUMBER CALCULATED AS ABOVE IS ADDED TO THE AS LINE NUMBER
TO OBTAIN THE ACTUAL LINE NUMBER. WHEN THE BYTES HAVE
BEEN PICKED UP TO FORM A NUMBER, THE LOW ORDER BIT IS ON
IF A DEFINITION OF THIS SYMBOL OCCURED ON THIS LINE. THE NUMBER
IS THEN SHIFTED RIGHT ONE BEFORE BEING ADDED TO THE
LINE NUMBER ON WHICH THE LAST OCCURANCE OF THIS SYMBOL WAS FOUND.
EXAMPLE:  IF SYMBOL FOO OCCURS ON (OCTAL) LINE NUMBER 100,
107(DEFINITION) 132 AND 167(DEFINITION), THE BYTES LOOK LIKE
44,0,17,41,6,41,33. THE FIRST BYTE HAS
THE 40 BIT ON INDICATING IT SHOULD BE COMBINED WITH THE
SECOND BYTE. THESE TWO BYTES COMBINED GIVE THE NUMBER 200. THE
LOW ORDER BIT IS OFF INDICATING IT IS NOT A DEFINITION. THE
REMAINING BITS INDICATE IT OCCURED 100(OCTAL) LINES AFTER
THE LAST OCCURANCE(0) OR LINE 100. THE NEXT BYTE HAS BIT 40 OFF
SO THATS ALL THERE IS. THE LOW ORDER BIT IS ON SO IT
IS A DEFINITION. THE REMAINING BITS GIVE THE NUMBER 7 SO
THE OCCURANCE IS 7 LINES PASED THE LAST ONE(100) OR 107 ETC.

	EACH CHAIN OF SIX BIT BYTES HAS A HEADER CALLED
A "LINE HEADER". THIS IS A TWO WORD BLOCK. THE
FIRST WORD IS A BYTE POINTER INDICATING WHERE TO PLACE THE
NEXT SIX BIT BYTE. THE RIGHT HALF OF THE SECOND WORD POINTS
TO THE FIRST 2 WORD BLOCK OF SIX BIT BYTES. BIT 5 OF
THE SECOND WORD IS ON IF A NON-DEFINING OCCURANCE
WAS ON THE LAST LINE NUMBER, BIT 4 IS ON IF A DEFINING OCCURANCE
AND BOTH ON IF BOTH(THIS IS SO CREF DOES NOT PRINT THE
SAME LINE NUMBER TWICE EVEN THOUGH THE SYMBOL OCCURED TWICE
ON THAT LINE. IT IS WILLING TO PRINT THE NUMBER TWICE, ONCE
AS A NON-DEFINITION AND ONCE AS A DEFINITION)
BIT 3 IS ON IF THE DEFINING OCCURRENCE IN THIS CHAIN IS AN
EXTERNAL STATEMENT.

	THERE ARE THREE SYMBOL TABLES KEPT BY CREF. ONE IS FOR
OPCODES, THE SECOND FOR MACROS (AND OPDEFS) THE OTHER FOR
OTHER SYMBOLS. EACH SYMBOL TABLE HAS A BLOCK WHICH
IS HASH WORDS LONG. A SYMBOL IS DEVIDED BY HASH AND THE
REMAINDER TAKEN. THIS ENTRY OF THE BLOCK IS A LINKED LIST
OF SYMBOLS WITH THIS "HASH CODE". EACH SYMBOL ENTRY TAKES
FOUR WORDS. THE FIRST WORD IS THE SIXBIT FOR THE NAME OF THE
SYMBOL. THE RIGHT HALF OF THE SECOND WORD IS A POINTER TO
THE NEXT SYMBOL WITH THIS "HASH CODE". THE LEFT HALF OF THE
SECOND WORD IS 0. BIT 0 OF THE THIRD WORD MEANS TO IGNORE
THIS SYMBOL(I'M SURE THIS MEANS SOMETHING BUT I DON'T KNOW
JUST WHAT). BITS 1-17 OF THE THIRD WORD ARE THE LINE NUMBER ON
WHICH THE SYMBOL WAS LAST SEEN AND ARE USED TO COMPUTE RELITIVE
LINE NUMBERS TO BE STORED AS ABOVE. THE RIGHT HALF OF THE
THIRD WORD IS A POINTER TO THE "LINE HEADER" FOR THIS SYMBOL.
	THE FOURTH WORD OF THE SYMBOL TABLE ENTRY TAKES
A LITTLE EXPLANATION. THIS WORD IS USED ONLY FOR BLOCK STRUCTURE
PROCESSORS. A BLOCK STRUCTURE PROCESSOR MAY HAVE
SEVERAL SYMBOLS WITH THE SAME NAME BUT OCCURING IN DIFFERENT
BLOCKS. THUS A BLOCK STRUCTURE PROCESSOR USUALLY EMITS A
UNIQUE NUMBER TO INDICATE THE SYMBOL INSTEAD OF THE SYMBOL ITSELF.
THE SYMBOL NUMBER AND NAME/BLOCK ARE THEN LATER EQUATED. THE
PROCESSOR MAY AT SOME TIME FIND THAT TWO SYMBOLS WHICH IT
THOUGHT WERE DIFFERENT ARE REALLY THE SAME. THIS REQUIRES
THAT THE LISTS OF LINE NUMBERS BE COMBINED. IT IS ASSUMED
THAT ALL THE LINE NUMBERS IN ONE LIST COME BEFORE ALL THE
LINE NUMBERS IN THE OTHER LIST. (THIS IS ALWAYS TRUE IN PRACTICE)
THE FOURTH WORD OF THE SYMBOL TABLE IS USED TO HOLD POINTERS
TO THE "LINE HEADERS" FOR THE LISTS OF LINE NUMBERS WHICH HAVE BEEN
COMBINED IN THIS WAY. THE POINTER IN THE THIRD WORD IS ALWAYS
TO THE LIST WITH THE LARGEST LINE NUMBERS. EACH SEPERATE
LIST STARTS WITH RELITIVE LINE NUMBER 0. THE LEFT HALF
OF THE FOURTH WORD POINTES TO A TWO WORD BLOCK WHOSE
FIRST WORD HAS A POINTER TO A "LINE HEADER" IN ITS RIGHT HALF
AND A POINTER TO A SIMILAR TWO WORD BLOCK IN ITS LEFT HALF.
THE SECOND WORD IS UNUSED. THE FIRST "LINE HEADER" HAS THE
SMALLEST LINE NUMBERS, THE SECOND THE NEXT SMALLEST, ETC.
THE RIGHT HALF OF THE FOURTH WORD POINTS TO THE LAST OF THESE
TWO WORD BLOCKS TO MAKE ADDING MORE THE THE LIST EASIER.
WHEN THE DEFINITION OF THE SYMBOL/BLOCK NAME IS FINALLY SEEN
THE RIGHT HALF OF THE FOURTH WORD IS CHANGED TO A POINTER TO
THE BLOCK END ENTRY FRO THAT BLOCK(SEE BELOW). IT IS ASSUMED
THAT NO MORE ADDITIONS TO THE LINE NUMBER LIST FOR A GIVEN
SYMBOL WILL BE MADE AFTER ITS NAME IS DEFINED. 
	IN A MACRO PROGRAM, THE SYMBOL USED IS THE REAL SYMBOL
INSTEAD OF A NUMBER REPRESENTING IT. THUS COMBINATION AND
DEFINITION NEVER HAPPEN AND THE FOURTH WORD IS NOT USED.

	THE REMAINING PIECE OF LIST STRUCTURE IS THE BLOCK TABLE
WHICH OCCURS ONLY FOR BLOCK STRUCTURE PROCESSORS. THE VARIABLE
BLKST HAS A POINTER TO THE BLOCK TABLE. EACH ENTRY HAS
FOUR WORDS. THE FIRST WORD IS THE SIXBIT FOR THE BLOCK NAME.
THE RIGHT HALF OF THE SECOND WORD IS A POINTER TO THE NEXT ENTRY.
THE LEFT HALF OF THE SECOND WORD IS A LEVEL NUMBER.
THIS IS JUST THE DEPTH OF THIS BLOCK IN THE BLOCK STRUCTURE.
THE OUTER MOST BLOCK IS LEVEL 0, NEXT INNER LEVEL 1 ETC.
THE RIGHT HALF OF THE THIRD WORD IS THE LINE NUMBER ON WHICH
THE START OR END OF THE BLOCK OCCURED. THIS BLOCK TABLE HAS
ONE ENTRY FOR THE START OF EACH BLOCK AND ONE FOR THE END OF
EACH BLOCK. THE ENTRIES ARE IN THE ORDER IN WHICH BEGINING
OF BLOCK AND END OF BLOCK ARE SEEN BY THE PROCESSOR. THE
LEFT HALF OF THE THIRD WORD IS A 0 IF THIS IS A START OF A BLOCK
AND 1 IF THIS IS THE END OF A BLOCK. THE FOURTH WORD IS NOT
USED.
	NOTE THAT BLOCKS ARE ALWAYS A MULTIPLE OF TWO WORDS LONG.
THIS IS DONE SO THAT THE SIX BIT BYTES FOR THE LINE
NUMBERS ALWAYS START WITH AN EVEN WORD *


MLON

CREF:	TDZA IO,IO		;START HERE FROM (JOBSA)
	MOVSI IO,IORPG		;START HERE FROM (JOBSA)+1
	RESET
	MOVE P,[IOWD PDL,PPSET]	;INIT PUSH DOWN LIST

IFN TEMPC,<
	SETZM TMPFLG		;ZERO TMPCOR FLAG
	TLNN IO,IORPG		;IS A CCL TYPE CALL?
	JRST TMPEND		;NO
	HRRZ AC0,JOBFF		;GET START OF BUFFER AREA
	HRLI AC0,-200		;-LENGTH IN LH FOR TMPCOR IOWD
	MOVEM AC0,TMPFIL+1	;STORE IT IN TMPCOR IOWD
	SOS TMPFIL+1		;MAKE IT CONFORM TO IOWD FORMAT
	HRRM AC0,CTIBUF+1	;SET UP DUMMY BYTE POINTER
	MOVSI TEMP,(SIXBIT /CRE/)	;SETUP 2 WORD BLOCK FOR TMPCOR UUO
	MOVEM TEMP,TMPFIL
	MOVE TEMP,[XWD 1,TMPFIL]	;SET UP FOR READ FROM CORE
	CALLI TEMP,TMPCOR	;READ AND DELETE FILE "CRE"
	JRST TMPEND		;FILE NOT THERE, TRY THE DISK
	ADD AC0,TEMP		;GET END OF BUFFER
	MOVEM AC0,JOBFF		;DUMMY UP JOBFF
	MOVEM AC0,SVJFF		;SAVE NEW JOBFF
	IMULI TEMP,5		;CALCULATE THE CHARACTER COUNT
	ADDI TEMP,1	;TAKE CARE OF SOSG PROBLEM
	MOVEM TEMP,CTIBUF+2	;DUMMY UP CHARACTER COUNT IN HEADER
	MOVEI TEMP,440700	;SET UP REST OF BYTE POINTER
	HRLM TEMP,CTIBUF+1	;HEADER NOW COMPLETE
	SETOM TMPFLG
	JRST GORPGO		;RETURN TO MAIN FLOW
TMPEND:>
	MOVEI TEMP,AL		;OPEN FILE IN ASCII LINE MODE
	MOVSI TEMP+1,(SIXBIT /TTY/)
	TLNE IO,IORPG		;USING CCL MODE?
	MOVSI TEMP+1,(SIXBIT /DSK/)	;YES
	MOVEM TEMP+1,CTIDEV	;SAVE DEVICE NAME
	MOVEI TEMP+2,CTIBUF	;SET UP INPUT BUFFER HEADER ADDRESS
	OPEN CTLI,TEMP		;OPEN INPUT COMMAND FILE
	 JRST CREF		;OPEN FAILURE, START OVER
	INBUF CTLI,1		;SET UP 1 INPUT BUFFER
	HRRZ JOBFF
	MOVEM SVJFF		;SAVE JOBFF
	TLNN IO,IORPG
	JRST RETRPG		;NOT IN CCL MODE

;THE FOLLOWING CODE LOOKS UP A FILE -DSK:QQCREF.RPG
;AND TRIES TO INITIALIZE IT. IF EVERYTHING WORKS, THAT FILE IS
;USED FOR THE COMMAND DATA TO CREF. IF SOMETHING GOES WRONG,
;A MESSAGE IS OUTPUT AND CREF EXITS BACK TO THE EXEC.

	MOVEI AC0,3		;JOB # IS 3 CHARS LONG
	CALLI TEMP,30		;GET JOB #
CREF1:	IDIVI TEMP,12
	ADDI TEMP+1,"0"-40	;CHANGE REMAINDER TO SIXBIT DIGIT
	LSHC TEMP+1,-6		;SHOVE DIGITS INTO TEMP+2
	SOJG AC0,CREF1			;3 DIGITS YET?
	HRRI TEMP+2,(SIXBIT /CRE/)
	MOVEM TEMP+2,CTIDIR		;SET UP ###CRE
	MOVSI TEMP,(SIXBIT /TMP/)
	MOVEM TEMP,CTIDIR+1		;SET UP EXTENSION
	SETZM CTIDIR+3			;CLEAR PROJ,PROG
	LOOKUP CTLI,CTIDIR		;DO LOOKUP ON COMMAND FILE
	JRST	[OUTSTR [ASCIZ/No cross reference files waiting to be processed/]
		JRST LEAVE]

; .TMP FILE OPEN (TMPCOR OR DSK:) SO SAY WE ARE PROCESSING
GORPGO:

RETRPG:	TLO IO,IOPAGE!IOSYM!IOMAC
	HRRZ 0,SVJFF		;GET THE SAVED JOBFF
	MOVEM 0,JOBFF		;RESTORE JOBFF
	SKIPE JOBDDT
	JRST .+3	;NO CORE UUO WHEN USING DDT
	CORE 0,			;SHRINK CORE
	 JRST CREF		;CORE FAILURE
	SETZM STCLR
	MOVE 0,[XWD STCLR,STCLR+1]
	BLT 0,ENDCLR		;CLEAR OUT VARIABLE AREA

	MOVE P,[IOWD PDL,PPSET]	;INIT PUSH DOWN LIST POINTER
	HLLOS UPPLIM		;?

	TLNE IO,IORPG		;IN CCL MODE?
	JRST	LSTSET		;YES, NO *
	PUSHJ P,CRLF	;NO
	MOVEI C,"*"
	PUSHJ P,TYO	;OUTPUT *

;THIS CODE IS USED TO SET UP  SOURCE AND
;DESTINATION DEVICES, DO MAGTAPE SPACING COMMANDS, ETC.

LSTSET:	MOVE	ACDEV,[SIXBIT'CROSS']	;TRY CROSS FIRST
	INIT	LST,0
	SIXBIT/CROSS/
	Z
	MOVSI	ACDEV,(SIXBIT /DSK/)	;FALED, ASSUME DSK
	RELEASE	LST,
	MOVEM	ACDEV,LSTDEV		;DEFAULT LIST DEVICE IS DSK:
	PUSHJ	P,NAME1	;GET NEXT DEVICE
	CAIE	C,"_"		;LISTING DEVICE SPECIFIED?
	JRST	LSTS2		;NO
	SKIPE	ACDEV
	MOVEM	ACDEV,LSTDEV	;SAVE DEVICE NAME
	MOVEM	ACFILE,LSTDIR	;STORE FILE NAME
	MOVEM	ACEXT,LSTDIR+1

LSTS2:	MOVEI FLAG,AL		;INIT DEVICE IN ASCII LINE MODE
	MOVE FLAG+1,LSTDEV	;GET DEVICE NAME
	MOVSI FLAG+2,LSTBUF	;BUFFER HEADER ADDRESS
	OPEN LST,FLAG		;TRY TO INIT DEVICE
	PUSHJ	P,WATLPT	;;CHECK LISTING DEVICE
	OUTBUF LST,2		;SET UP A TWO RING BUFFER

	CAIE	C,"_"		;LISTING DEVICE SPECIFIED?
	JRST	INSET1		;NO
	DEVCHR ACDEV,		;GET OUTPUT DEVICE CHARACTERISTICS
	TLNE	ACDEV,10	;IS IT A TTY?
	TLO	IO,IOTTY	;YES, SET TTY FLAG
	TLZE	TIO,TIORW	;REWIND REQUESTED?
	MTAPE	LST,1		;YES
	JUMPGE	CS,LSTSE3
	MTAPE	LST,17		;BACKSPACE MTA
	AOJL	CS,.-1		;IF COUNT IS NEG., BACKSPACE AGAIN
	WAIT	LST,		;WAIT FOR TAPE TO STOP SO LOAD POINT CAN BE SENSED
	STATO	LST,1B24	;SKIP IF AT LOAD POINT-
				; THIS PUTS TAPE ON CORRECT SIDE OF EOF
	MTAPE	LST,16		;SPACE FORWARD 1 FILE
LSTSE3:	SOJG	CS,.-1		;LOOP UNTIL POS. COUNT RUNS OUT

	TLNE	TIO,TIOCLD	;DIRECTORY CLEAR REQUESTED?
	UTPCLR	LST,		;YES, CLEAR IT
INSET:	PUSHJ P,NAME1
INSET1:	PUSH P,[SIXBIT /DSK/]
	POP P,INDEV
	PUSHJ P,INSETF
	SKIPE LSTDIR	;WAS A NAME GIVEN
	JRST NOASNM	;YES, DO NOT USE DEFALT
	PUSH P,INDIR	;GET INPUT NAME
	POP P,LSTDIR
	MOVSI FREE,(SIXBIT /LST/)
	MOVEM FREE,LSTDIR+1
NOASNM:	ENTER LST,LSTDIR
	JRST ERRENT
	TRNN IO,IOSOUT	;IF SPECIAL REQUEST
	JRST NOSPO
	INIT SOP,14
	SIXBIT /DSK/
	XWD SOBUF,0
	JRST NOSOUT
	SETZM SONAM+3
	SETZM SONAM+2
	MOVSI FREE,(SIXBIT /SWT/)	;MAKE IT CRF
	MOVEM FREE,SONAM+1
	MOVE FREE,INDIR		;STILL LEFT THERE
	MOVEM FREE,SONAM
	ENTER SOP,SONAM
NOSOUT:	TRZA IO,IOSOUT	;GIVE UP
	OUTBUF SOP,2
NOSPO:	TLNN	IO,IORPG	;IN CCL MODE?
	JRST	NOSPO1		;NO, DONT TYPE NAME OUT
;IN RPG MODE, TYPE OUT NAME OF OUTPUT FILE BEING GENERATED
;USES AUXCAL SO THAT IF USER ^C/ESC AND DETACHES, CROSS
;WILL CONTINUE TO RUN  ...  (REMEMBER, AUXCAL IS A NO-OP
;IF CONTROLLING TERMINAL SPECIFIED AND TERMINAL IS DETACHED)
	HRROI	TEMP,5		;AUXCAL FCN:5 - OUTPTR
	MOVE	TEMP1,[POINT 7,[ASCIZ/CROSS: /]]
	AUXCAL	TEMP,TEMP1	;TYPE CROSS:
	 JFCL
	MOVEI	TEMP,6		;NUMBER OF CHARS(MAX) IN NAME
	MOVE	TEMP1,[POINT 6,LSTDIR]	;POINTER TO NAME
NOSPLP:	ILDB	C,TEMP1		;GET CHAR FROM NAME
	JUMPE	C,NOSPO0	;DONE IF 0 (SPACE)
	ADDI	C,40		;CONVERT TO ASCII
	PUSHJ	P,OUTNWT	;OUTPUT CHARACTER
	SOJG	TEMP,NOSPLP	;LOOP OUTPUTING CHARACTERS
NOSPO0:	MOVEI	C,15		;C.R.
	PUSHJ	P,OUTNWT
	MOVEI	C,12		;L.F.
	PUSHJ	P,OUTNWT
NOSPO1:	;OUT OF LOOP

	MOVEI FREE,BLKST-1	;SET UP THINGS FOR COMBG
	MOVEM FREE,BLKND

RECYCL:	HRRZ	FREE,JOBFF	;RETURN FOR MULTIPLE F4 PROGS
	ADDI	FREE,1
	TRZ	FREE,1		;SET UP BYTE TABLE ADR ON EVEN LOCATION

	HRRZ	TOP,JOBREL	;SET UP HIGH ADR OF SYMBOL TABLE
	SKIPE	JOBDDT
	HRRZ	TOP,JOBSYM	;SAVE DDT'S SYMBOL TABLE WHEN IN USE
	CAMGE TOP,JOBFF
	SKIPA TOP,JOBREL	;USE JOBREL IF DDT AND MOVED
	SUBI TOP,1	;JUST IN CASE

	MOVEM P,PPSAV#	;SAVE PDL FOR ERROR RECOVERY
	MOVEI	LINE,1	;INITIALIZE LINE COUNTER
	MOVEM LINE,LINEX
	PUSHJ P,READ	;TEST FIRST CHARACTER
	TRNE IO,IOJLST	;JUST LIST?
	JRST M1
	CAIE C,%EOF	;PROGRAM BREAK?
	JRST M2A	;NO, PROCESS
	JRST M2		;YES, BYPASS


MLON
M1:	TLNN	IO,IOLST
	PUSHJ	P,WRITE
M2:	PUSHJ	P,READ
	TRNE IO,IOJLST	;JUST LIST IT
	JRST M1
M2A:	CAIN C,177
	JRST FAILM
	CAIN C,12
	JRST M1
	CAIN C,15
	JRST FCKLF
	CAIG C,%EOF
	CAIGE C,%OP
	SKIPA
	JRST M2C
	TLZE IO,IOENDL
	TLNE IO,IOLST
	JRST M1
	PUSH P,C
	MOVEI C,11
	PUSHJ P,WRITE
	POP P,C
	JRST M1

M2C:	TLNE IO,IOFAIL		;IF "NEW STYLE" DATA SEEN (IOFAIL=1),IGNORE OLD
	JRST M1			;IGNORE "OLD STYLE" CREF DATA
	TLZ IO,IOENDL
	TLO IO,IOTB2
	XCT	MTAB-%OP(C)	;DO SOMETHING (USUALLY SET BITS) WITH CONTROL CHAR
	JRST	M3		;BITS WERE SET (EITHER IOOP,IOMAC, OR IOSYM)

M2B:	TLNN	IO,IOLST
	PUSHJ	P,CNVRT	;IF MAKING LISTING, CONVERT (LINE) TO TEXT
	TLNE IO,IOTABS
	JRST	[MOVEI C,11
		TLNN IO,IOLST
		PUSHJ P,WRITE
		JRST .+1]
M2BINC:	MOVE	TEMP,CHOLD
	CAIE	TEMP,105
	AOS	LINEX	;INCREMENT LINE NUMBER
	CAIE	TEMP,107
	CAIN	TEMP,105
	JRST .+2
	MOVE	LINE,LINEX
	JRST	M2

M3:	MOVEI	AC0,0
M4:	PUSHJ	P,READ
	CAIGE C,40
	JRST M5A	;NOT SIXBIT
	LSH AC0,6
	SUBI C,40
	ANDI C,77	;AMKE SURE
	IOR AC0,C
	JRST	M4

M5A:	PUSHJ P,M5
	JRST M2
	LSH AC0,6
M5:	TLNN AC0,770000	;ANY BITS IN HIGH CHR?
	JRST .-2	;JUSTIFY
	JUMPN	AC0,M6
	MOVEI	RC,[SIXBIT /(OM) Improper data code@/]
ERROR:	MOVE P,PPSAV	;SET TO RECOVER
	PUSHJ P,PNTMSG
	PUSHJ P,CRLF
	JRST M2		;AND DO SO

M6:	TDNE	IO,SX
	TLNE	IO,IONCRF
	POPJ P,

	CAML	LINE,LOWLIM
	CAMLE	LINE,UPPLIM
	TDZA	FLAG,FLAG
	MOVSI	FLAG,(1B0)
	JRST SRCH
	POPJ P,

MTAB:	MOVSI	SX,IOOP
	MOVSI	SX,IOMAC
	SKIPA	C,LINE
	MOVSI	SX,IOSYM
	JRST R0A		;BREAK BETWEEN PROGRAMS

FCKLF:	TLNE IO,IOTABS!IOTB2
	TLO IO,IOENDL
	JRST M1

R0A:	TRNE IO,IOCMB	;IF COMBINING FORTRAN PROGRAMS
	JRST M2		;JUST CONTINUE
			;ELSE FALL INTO R0

R0:
	SKIPE BYTEX,BLKST	;CHECK FOR FAIL BLOCK STRUCTURE
	PUSHJ P,BLKPRN
	TRNE IO,IOSOUT
	PUSHJ P,SETPNM	;SET UP PROGRAM NAME IF NEEDED
	TLNN IO,IOSYM
	JRST NOSYM
	MOVEI BYTEX,SYMTBL
	PUSHJ P,SORT
	MOVEI CS,3
	MOVEI SX,[ASCIZ*Symbol cross reference*]
	PUSHJ P,OUTP
NOSYM:	TLNN IO,IOMAC
	JRST NOMAC
	MOVEI BYTEX,MACTBL
	PUSHJ P,SORT
	MOVEI CS,2
	MOVEI SX,[ASCIZ*Macro/Opdef cross reference*]
	PUSHJ P,OUTP
NOMAC:	TLNN IO,IOOP
	JRST FINI0
	MOVEI BYTEX,OPTBL
	PUSHJ P,SORT
	MOVEI CS,1
	MOVEI SX,[ASCIZ*Opcode cross refe*]
	PUSHJ P,OUTP
FINI0:	MOVEI CS,0
	PUSHJ P,OUTWD
	JRST FINIS

CNVRT:	MOVEI	TEMP,6	;OUTPUT SPACES FOR LEADING ZEROS
CNVR1:	MOVEI C+1," "-"0"
	SKIPE C
	IDIVI C,12
	HRLM C+1,(P)
	SOSG TEMP
	SKIPE C
	PUSHJ P,CNVR1
	HLRZ C,(P)
	MOVEI C,"0"(C)
	JRST WRITE

OUTASC:	TLZ IO,IONLZ	;READY TO SUPRESS LEADING 0'S
OUTAS1:	MOVEI C,0
	LSHC C,6
	ADDI C,40
	CAIN C,"0"
	TLNE IO,IONLZ
	TLOA IO,IONLZ
	MOVEI C," "
	PUSHJ P,WRITE0
	JUMPN CS,OUTAS1	;ANY MORE TO PRINT?
	POPJ P,	;DONE

OUTWD:	TRNN IO,IOSOUT
	POPJ P,		;SO WE DON'T NEED TO TEST EVERYWHERE
	SOSG SOBUF+2
	OUTPUT SOP,0	;DON'T WORY ABOUT ERRORS
	IDPB CS,SOBUF+1
	POPJ P,

SETPNM:	SETZM PNAME#
	SETZM HWD#	;FOR HALF WORD OUTPUT LATER
	MOVE BYTEX,[POINT 7,TIBUF]
	MOVE BYTEM,[POINT 6,PNAME]
CHLP:	ILDB C,BYTEX
	CAIL C,140
	SUBI C,100	;CONVERT CASE?
	CAIG C,"Z"
	CAIGE C,"0"
	JRST CHDOT	;SPECIA LETTERS ALLOWED
	CAIGE C,"A"
	CAIG C,"9"
	JRST CHOK	;ALL OK
	POPJ P,		;MUST BE DONE
CHDOT:	CAIE C,"."
	CAIN C,"%"
	JRST CHOK
	CAIE C,"$"
	POPJ P,
CHOK:	SUBI C,40
	IDPB C,BYTEM
	TLNE BYTEM,770000	;OUT OF ROOM?
	JRST CHLP	;MORE
	POPJ P,

SORT:	HRLI BYTEX,-HASH	;SET UP FOR FIST SORT AOBJN
L2:	MOVEI SX,0
	EXCH SX,(BYTEX)		;GET FIRST TABLE ENTRY
	JUMPE SX,NXTENT		;NOTHING THERE
L3:	MOVEI C,-1(BYTEX)	;GET A POINTER FOR LINKING IN
	MOVE FLAG,(SX)
L1:	SKIPN TX,1(C)
	JRST INSRT	;AT END OF CHAIN SO PUT IT IN
	CAML FLAG,(TX)
	JRST CKEQ	;CHECK ON EQUALITY AND INSERT
L4:	MOVE C,TX
	JRST L1
CKEQ:	CAME FLAG,(TX)
	JRST INSRT	;NO THE SAME GO PUT IN
	MOVE FLAG,3(SX)
	MOVE FLAG,(FLAG)
	MOVE TEMP,3(TX)
	CAML FLAG,(TEMP)
	JRST INSRT
	MOVE FLAG,(SX)
	JRST L4
INSRT:	EXCH TX,1(SX)
	MOVEM SX,1(C)
	SKIPE SX,TX
	JRST L3
NXTENT:	AOBJN BYTEX,L2

	SETZM LINKL#	;NO PUT ALL SORTED CHAINS TOGETHER
TRY0:	SUBI BYTEX,HASH
	MOVSI C,400000
	HRLI BYTEX,-HASH
NXTSY:	SKIPN TX,(BYTEX)
	JRST TRYNXT
	CAMG C,(TX)
	JRST CKEQ2
TRYNXT:	AOBJN BYTEX,NXTSY
	CAMN C,[1B0]
	POPJ P,
	MOVE TX,(SX)
	MOVE FLAG,LINKL
	EXCH FLAG,1(TX)
	MOVEM FLAG,(SX)
	MOVEM TX,LINKL
	JRST TRY0
CKEQ2:	CAME C,(TX)
	JRST FND
	MOVE FLAG,3(TX)
	MOVE FLAG,(FLAG)
	MOVE TEMP,(SX)
	MOVE TEMP,3(TEMP)
	CAMGE FLAG,(TEMP)
	JRST TRYNXT
FND:	MOVE C,(TX)
	MOVE SX,BYTEX
	JRST TRYNXT

OUTP:	MOVEM SX,SBTBUF	;SAVE SUBTITLE
	SKIPN SX,LINKL
CPOPJ:	POPJ P,	;NONE THERE
	PUSHJ P,OUTWD
	TLO IO,IOPAGE
OUTPA:	SKIPL 2(SX)	;IGNORE SYMBOL?
	JRST LNKOUT	;YES
	PUSHJ P,LINOUT
	MOVE CS,(SX)
	PUSHJ P,OUTWD
	PUSHJ P,OUTASC
	MOVE CS,(SX)
	MOVE TX,1(SX)
	CAMN CS,(TX)	;SAME SYMBOL NAME
	JRST ISBLK	;YES, PRINT BLOCK
	TLZN IO,IOSAME	;OR LAST OF SET THAT IS THE SAME?
	JRST NOBLK	;NO
	SKIPA
ISBLK:	TLO IO,IOSAME
DOBLK:	PUSHJ P,TABOUT
	MOVE CS,3(SX)
	MOVE CS,(CS)
	PUSHJ P,OUTWD
	PUSHJ P,OUTASC
	JRST NOBLK2
NOBLK:	MOVEI CS,0
	PUSHJ P,OUTWD
NOBLK2:	MOVE CS,PNAME
	PUSHJ P,OUTWD
	PUSHJ P,OUTP1
LNKOUT:	SKIPN SX,1(SX)
	POPJ P,
	JRST OUTPA

OUTP1:	MOVEI FLAG,3(SX)
LINLP:	HLRZ FLAG,(FLAG)
	JUMPE FLAG,LAST
	HRRZ BYTEX,(FLAG)
	HRLI BYTEX,(POINT 6,0,5)
	ADDI BYTEX,1
	MOVE BYTEM,-1(BYTEX)
	PUSHJ P,OUTP2
	JRST LINLP
LAST:	HRRZ BYTEX,2(SX)
	HRLI BYTEX,(POINT 6,0,5)
	ADDI BYTEX,1
	MOVE BYTEM,-1(BYTEX)
	LDB LINE,BYTEX
	TRNE LINE,4
	TROA IO,IOEXT	;EXTERN, SET FLAG
	TRZ IO,IOEXT	;NOPE
OUTP2:	MOVEI LINE,0
R3:	PUSHJ P,GETVAL
	JRST FINOUP
	TRNN IO,IOSOUT
	JRST NOSO
	TLNE IO,IODEF
	TRO C,400000
	TRNE IO,IOEXT
	TRO C,200000	;SET IF EXTERNAL
	PUSHJ P,HOUT
	TRZ C,600000
NOSO:	PUSHJ P,CNVRT
	JRST R3

FINOUP:	TRNN IO,IOSOUT
	POPJ P,
	HRLZ CS,HWD
	SETZM HWD
	JRST OUTWD

HOUT:	SKIPE HWD
	JRST	[MOVE CS,C
		HRL CS,HWD
		PUSHJ P,OUTWD
		SETZM HWD
		POPJ P,]
	HRROM C,HWD
		POPJ P,

FREAD:	PUSHJ P,READ	;GET CHARACTER COUNT
	MOVE TEMP1,C
	MOVEI AC0,0
FM4:	PUSHJ P,READ
	LSH AC0,6
	SUBI C,40
	ANDI C,77
	IOR AC0,C
	SOJG TEMP1,FM4
	POPJ P,

; HERE TO READ A "NEW" CODE
; A '177' HAS JUST BEEN SEEN - DECODE WHAT IS AHEAD OF US
FAILM:	PUSHJ P,READ	;READ NEXT CODE
	CAIE C,102	;IS IT START CODE ?
	JRST NOTINF	;NO, PUT OUT 177 AND THIS CHAR
	TLO IO,IOFAIL	;THIS IS FAIL(NEW METHOD)
FM2:	PUSHJ P,READ	;READ NEXT CODE
	CAIN C,177	;POSSIBLE END CODE?
	JRST TEND	;YES, CHECK
	CAILE C,20	;IN RANGE?
	JRST	[MOVEI RC,[SIXBIT /(NM) Improper data code@/]
		JRST ERROR]
	TRZ IO,IOEXT
	XCT DTAB-1(C)
	JUMPE SX,FM2
	TLZE SX,IODF2	;DO WE WANT TO DEFINE IT?
	TLOA IO,IODEF	;YES, SET FLAG
	TLZ IO,IODEF	;JUST TO MAKE SURE
	PUSHJ P,FREAD	;GET THE SYMBOL
FM6:	PUSHJ P,M5	;GO ENTER SYYMBOL
	JRST FM2

; HERE WHEN 177 WAS SEEN AND WAS NOT A START CODE (177 102)
NOTINF:	PUSH P,C	;PUT IT OUT AS IT WAS READ
	MOVEI C,177	;FIRST PUT OUT A 177
	TLNN IO,IOLST
	PUSHJ P,WRITE
	POP P,C	;GET BACK CHAR FOLLOWING 177
	JRST M1		;BACK INTO MAIN STREAM

; HERE WHEN A 177 WAS SEEN AFTER A START CODE (177 102 ... 177)
; CHECK TO SEE IF A VALID END CODE
TEND:	PUSHJ P,DFLAB	;CHECK TO SEE IF DEFINING SYMBOL
	PUSHJ P,READ	;CHECK FOR END CHARACTER
	CAIG C,110	;110=VALID HIGH END CODE
	CAIG C,100	;101=VALID LOW END CODE
IECERR:	JRST	[MOVEI RC,[SIXBIT /(NM) Improper end code@/]
		JRST ERROR]
	MOVEM C,CHOLD	;SAVE THE END CODE (FOR M2#### CODE)
	CAIN C,104	;JUST A PLAIN END OF CREF INFO?
	JRST M2		;JUST EAT INFO BUT NO LINE NUMBER
	TLZ IO,IOENDL	;ONLY IF A LINE NUMBER IS TO BE PUT OU
	CAIN C,101	;END, PUT OUT AND SET TABS?
	TLO IO,IOTABS	;YES, SET TAB FLAG
	CAIE C,106	;END AND INCREMENT?
	CAIN C,107	;OR END, INCREMENT BUT DONT USE?
	JRST	M2BINC	;YES, JUMP INTO MAIN STREAM WHCH DOES INC
	CAIN C,110	;END AND EAT LINE NUMBER?
	JRST EATLIN	;YES, GO TO IT
	TRNN C,1
	JRST	IECERR
	MOVE C,LINEX	;SET UP TO ENTER
	JRST M2B

; HERE ON A CODE 110
; THIS ALWAYS COMES IN AS:
; 177 110 LB3 LB2 LB1
; WHERE LB3,LB2,LB1 ARE THE 21 BITS OF THE LINE NUMBER TO USE
EATLIN:	SETZM	LN2COM		;LINE NUMBER TO BUILD
	PUSHJ	P,READXX		;GET NEXT 7-BITS
	DPB	C,[POINT 7,LN2COM,21]
	PUSHJ	P,READXX		;GET NEXT 7-BITS
	DPB	C,[POINT 7,LN2COM,28]
	PUSHJ	P,READXX		;GET LAST 7-BITS
	DPB	C,[POINT 7,LN2COM,35]
COMMENT *
THE NEW LINE NUMBER WE ARE TO USE (LN2COM) MUST BE GREATER
THAN THE CURRENT LINE NUMBER, ELSE AN ERROR WILL BE
GENERATED *
	CAML	LINE,LN2COM	;NEW LINE BIGGER ?
	JRST	[MOVEI RC,[SIXBIT/(NM) code 110 specified non-sequential line number@/]
		JRST ERROR]
	MOVE	LINE,LN2COM	;YES,GET NEW LINE NUMBER
	MOVEM	LINE,LINEX	;MAKE NUMBERS JIVE
	JRST	M2		;BACK INTO MAIN STREAM

DTAB:	JRST SETLAB
	JRST DLAB
	MOVSI SX,IOOP
	MOVSI SX,IOOP!IODF2
	MOVSI SX,IOMAC
	MOVSI SX,IOMAC!IODF2
	SETZB SX,SVLAB
	JRST COMBIN
	JRST DEFSYM
	JRST	[MOVEI RC,[SIXBIT/(NM) bad code 12 specified@/]
		JRST ERROR]
	JRST DEFMAC
	JRST	[MOVEI RC,[SIXBIT/(NM) bad code 14 specified@/]
		JRST ERROR]
	JRST BBEG
	JRST BBEND
	JRST DLBEXT
	JRST RDTTL	;TITLE

RDTTL:	MOVEI TEMP1,^D200	;COUNT
	SKIPE TIBUF
	TDZA TEMP,TEMP	;TAKE ONLY FIRST ONE
	MOVE TEMP,[POINT 7,TIBUF]
TLP1:	PUSHJ P,READ
	CAIN C,177
	JRST ENDTL
	SOJL TEMP1,TLP1
	CAIN C,12
	TRO IO,IOSUBT	;SHOW THAT PROGRAM SUPPLIED A SUBTITLE
	IDPB C,TEMP
	JRST TLP1
ENDTL:	MOVEI TEMP1,0
	IDPB TEMP1,TEMP
	JRST TEND	;SEEN 177 SOMETHING

DFLABD:	TLOA IO,IODEF	;DEFINITION
DFLAB:	TLZ IO,IODEF	;NOT DEFINITION
	MOVE AC0,SVLAB
	JUMPE AC0,CPOPJ	;NO, EXIT
	MOVSI SX,IOSYM	;A SYMBOL
	SETZM SVLAB	;NOT ANY MORE
	JRST M5		;GO ENTER IT

DEFMAC:	SKIPA SX,[MACTBL]
DEFSYM:	MOVEI SX,SYMTBL
	PUSH P,SX
	PUSHJ P,DFLAB
	POP P,SX
	PUSHJ P,FREAD
	MOVE BYTEX,AC0
	IDIVI BYTEX,HASH
	MOVMS TX
	ADDI TX,(SX)
	SKIPN SX,(TX)
	JRST DEFBYP
DEFS1:	CAMN AC0,(SX)	;FIND SYMBOL
	JRST DEFFD
	SKIPE SX,1(SX)
	JRST DEFS1
	JRST DEFBYP	;NO FOUND
DEFFD:	PUSHJ P,FREAD	;NOW GET DEFINITION
	SKIPA
	LSH AC0,6
	TLNN AC0,770000
	JRST .-2
	MOVEM AC0,(SX)
	MOVE AC0,BLKND	;AND BLOCK
	HRRM AC0,3(SX)
	JRST FM2
DEFBYP:	PUSHJ P,FREAD
	JRST FM2
COMBIN:	PUSHJ P,DFLAB	;JUST IN CASE ANY ARE WAITING
	PUSHJ P,FREAD	;GET FIRST
	MOVE BYTEX,AC0	;AND FINE
	IDIVI BYTEX,HASH
	MOVMS TX
	MOVEI SX,SYMTBL-1(TX)
CMB1:	MOVE TEMP,SX
	SKIPN SX,1(TEMP)
	JRST DEFBYP
	CAME AC0,(SX)
	JRST CMB1
	PUSHJ P,FREAD	;GET OTHER NAME
	MOVE BYTEX,AC0
	IDIVI BYTEX,HASH
	MOVMS TX
	MOVEI TEMP1,SYMTBL-1(TX)
CMB2:	MOVE TX,TEMP1
	SKIPN TEMP1,1(TX)
	JRST MOVSYM
	CAME AC0,(TEMP1)
	JRST CMB2
	LDB BYTEX,[POINT 17,2(TEMP1),17]	;GET LINE
	LDB AC0,[POINT 17,2(SX),17]
	CAML BYTEX,AC0	;AND SEE WHICH IS SMALLER
	JRST CMBOK	;SMALLER IS ONE TO DELETE
	MOVE AC0,2(SX)
	EXCH AC0,2(TEMP1)
	MOVEM AC0,2(SX)
	MOVE AC0,3(SX)
	EXCH AC0,3(TEMP1)
	MOVEM AC0,3(SX)
CMBOK:	MOVE BYTEX,FREE
	ADDI FREE,2
	CAML FREE,TOP
	PUSHJ P,XCEED
	MOVE AC0,2(SX)	;THIS CODE IS MAJIC
	HLL AC0,3(TEMP1)
	MOVEM AC0,(BYTEX)
	SKIPN 3(TEMP1)
	MOVEM BYTEX,3(TEMP1)
	MOVE C,3(SX)
	HLLM C,3(TEMP1)
	JUMPE C,[HRLM BYTEX,3(TEMP1)
		JRST .+2]
	HRLM BYTEX,(C)
CMB3:	MOVE TX,FSTPNT	;PUT DELETE BACK ON FREE
	EXCH TX,1(SX)	;AND LINK AROUND
	MOVEM SX,FSTPNT
	MOVEM TX,1(TEMP)
	JRST FM2
MOVSYM:	MOVE BYTEX,AC0	;GET THE SYMBOL NAME AGAIN
	IDIVI BYTEX,HASH
	MOVMS TX
	SKIPE TEMP1,FSTPNT	;GET A BLOCK
	JRST	[MOVE BYTEX,1(TEMP1)
		MOVEM BYTEX,FSTPNT
		JRST MOVS1]
	MOVE TEMP1,FREE
	ADDI FREE,4
	CAML FREE,TOP
	PUSHJ P,XCEED
MOVS1:	MOVE BYTEX,SYMTBL(TX)	;INSERT SYMBOL
	MOVEM BYTEX,1(TEMP1)
	MOVEM TEMP1,SYMTBL(TX)
	MOVEM AC0,(TEMP1)
	HRLI BYTEX,2(SX)
	HRRI BYTEX,2(TEMP1)
	BLT BYTEX,3(TEMP1)	;MOVE INFORMATION
	JRST CMB3	;AND GO DELETE OLD ONE

SETLAB:	PUSHJ P,DFLAB	;DEFINE ANY WAITING
	PUSHJ P,FREAD	;GET NEW ONE
	MOVEM AC0,SVLAB	;SAVE IT
	JRST FM2	;AND BACK FOR MORE

DLBEXT:	TRO IO,IOEXT	;SAME AS DLAB BUT EXTERNAL
DLAB:	PUSHJ P,DFLABD	;GO DEFINE IT
	JRST FM2

BBEG:	AOS TEMP,LEVEL	;GET CURRENT LEVEL
	MOVSI SX,0
	PUSHJ P,COMBG	;GO INSER
	JRST FM2

BBEND:	MOVE TEMP,LEVEL	;CURRENT LEVEL
	MOVEI SX,1
	PUSHJ P,COMBG
	SOS LEVEL	;RESET
	JRST FM2

COMBG:	PUSHJ P,FREAD	;GET NAME
	SKIPA
	LSH AC0,6
	TLNN AC0,770000
	JRST .-2
	MOVE TEMP1,FREE
	ADDI FREE,4	;RESERVE 4 WORDS
	CAML FREE,TOP
	PUSHJ P,XCEED	;OVERLAP
	MOVEM AC0,(TEMP1)	;SAVE NAME
	HRLZM TEMP,1(TEMP1)	;AND LEVEL
	MOVEM LINE,2(TEMP1)	;AND CURRENT LINE
	HRLM SX,2(TEMP1)
	MOVE TEMP,BLKND	;SAVE CURRENT POINTER
	HRRM TEMP1,1(TEMP)	;SET UP LINK
	MOVEM TEMP1,BLKND
	POPJ P,

BLKPRN:	PUSHJ P,LINOUT
	MOVE CS,@BLKND
	PUSHJ P,OUTASC
	MOVEI C,11
	PUSHJ P,WRITE
	MOVE CS,[SIXBIT /PROGRAM/]
	PUSHJ P,OUTASC
	MOVEI C,"M"
	PUSHJ P,WRITE
BLKP3:	PUSHJ P,LINOUT
	HLRZ BYTEM,1(BYTEX)
	LSH BYTEM,-1
	JUMPE BYTEM,BLKP1
	PUSHJ P,TABOUT
	SOJG BYTEM,.-1
BLKP1:	HLRZ BYTEM,1(BYTEX)
	HLRZ SX,2(BYTEX)
	TRNE BYTEM,1
	ADDI SX,4
	JUMPE SX,BLKP2
	MOVEI C," "
	PUSHJ P,WRITE
	SOJG SX,.-2
BLKP2:	MOVE CS,(BYTEX)
	PUSHJ P,OUTASC
	HLRZ SX,2(BYTEX)
	MOVNS SX
	ADDI SX,5
	SKIPA CS,(BYTEX)
	LSH CS,-6
	TRNN CS,77
	AOJA SX,.-2
	MOVEI C," "
	PUSHJ P,WRITE
	SOJG SX,.-1
	HRRZ C,2(BYTEX)
	PUSHJ P,CNVRT
	HRRZ BYTEX,1(BYTEX)
	JUMPN BYTEX,BLKP3
	TLO IO,IOPAGE
	POPJ P,

SRCH:	MOVE BYTEX,AC0	;GET SIXBIT
	IDIVI BYTEX,HASH
	MOVMS TX
	TLNE SX,IOOP
	MOVEI TX,OPTBL(TX)	;SEARCH CORRECT ONE
	TLNE SX,IOMAC
	MOVEI TX,MACTBL(TX)
	TLNE SX,IOSYM
	MOVEI TX,SYMTBL(TX)
	SKIPN SX,(TX)
	JRST NTFND
SRCH1:	CAMN AC0,(SX)
	JRST STV10
	SKIPE SX,1(SX)
	JRST SRCH1
NTFND:	SKIPE SX,FSTPNT
	JRST	[MOVE BYTEX,1(SX)
		MOVEM BYTEX,FSTPNT	;RESET FREE STG
		JRST NTFND1]
	MOVE SX,FREE
	ADDI FREE,4	;GET A SPACE TO PUT NEW SYMBOL
	CAML FREE,TOP
	PUSHJ P,XCEED
NTFND1:	MOVEM AC0,(SX)
	MOVE BYTEX,(TX)	;LINK INTO TABLE
	MOVEM BYTEX,1(SX)
	MOVEM SX,(TX)
	SETZM 3(SX)
	MOVE TX,FREE
	ADDI FREE,2
	CAML FREE,TOP
	PUSHJ P,XCEED
	SETZM 1(TX)
	MOVEI BYTEX,1(TX)
	HRLI BYTEX,(POINT 6,0,5)
	MOVEI C,1
	TLNE IO,IODEF
	TRC C,3
	TRNE IO,IOEXT
	ORI C,4		;EXTERN
	DPB C,[POINT 6,1(TX),5]
	MOVE C,LINE
	LSH C,1
	TLZN IO,IODEF
	IORI C,1
	HRLM LINE,2(SX)
	HRRM TX,2(SX)
	JRST STV12

STV10:	LDB	C,[POINT 17,2(SX),17]
	HRRZ TX,2(SX)
	LDB TEMP,[POINT 6,1(TX),5]
	CAME C,LINE
	JRST STV10A
	TLNN IO,IODEF
	JRST STV10B
	TROE TEMP,2
	POPJ P,
	JRST STV10C
STV10B:	TROE TEMP,1
	POPJ P,
	JRST STV10C
STV10A:	TRZ TEMP,3
	ORI TEMP,1
	TLNE IO,IODEF
	TRC TEMP,3
STV10C:	TRNE IO,IOEXT
	ORI TEMP,4
	DPB TEMP,[POINT 6,1(TX),5]
STV10D:
	DPB	LINE,[POINT 17,2(SX),17]
	LSH LINE,1
	TLZN IO,IODEF
	IORI LINE,1
	LSH C,1
	SUBM	LINE,C
	LSH LINE,-1	;NOW ELIMINATE DEFINE BIT
	MOVE	BYTEX,0(TX)

STV12:	ORM	FLAG,2(SX)
	CAIGE	C,^D32
	JRST	STV20
	MOVEM	P,PPTEMP

STV14:	IDIVI	C,^D32
	PUSH	P,CS
	CAIL	C,^D32
	JRST	STV14
STV16:	TRO	C,40
	PUSHJ	P,STV20
	POP	P,C
	CAME	P,PPTEMP
	JRST	STV16

STV20:	TRNE	BYTEX,1
	CAML	BYTEX,[POINT 6,,16]
	JRST	STV22
	HRRM	FREE,0(BYTEX)
	MOVE	BYTEX,FREE
	HRLI	BYTEX,(POINT 6,,)
	ADDI	FREE,2
	CAML	FREE,TOP
	PUSHJ	P,XCEED

STV22:	IDPB	C,BYTEX
	MOVEM	BYTEX,0(TX)
POPOUT:	POPJ	P,

GETVAL:	TLZN IO,IODEF
	JRST GETV20
	MOVEI C,"#"
	TRNE IO,IOEXT
	MOVEI C,"%"	;EXTERN
	PUSHJ P,WRITE
GETV20:	CAMN	BYTEX,BYTEM
	POPJ	P,
	AOS	0(P)
	PUSHJ	P,TABOUT
	MOVEI	C,0
GETV10:	TRNE	BYTEX,1
	CAML	BYTEX,[POINT 6,,16]
	JRST	GETV12
	MOVE	BYTEX,0(BYTEX)
	HRLI	BYTEX,(POINT 6,,)

GETV12:	ILDB	CS,BYTEX
	ROT	CS,-5
	LSHC	C,5
	JUMPN	CS,GETV10
	TRNN C,1	;SET DEFINED FLAG
	TLO IO,IODEF
	LSH C,-1
	ADDB	LINE,C
	POPJ	P,

TABOUT:	MOVEI	C,11
	SOJGE	WPL,WRITE0
	PUSHJ	P,LINOUT
	JRST	TABOUT

LINOUT:	SOSG	LPP
	TLO	IO,IOPAGE
	MOVEI	C,15
	PUSHJ	P,WRITE
	MOVEI	C,12
	PUSHJ	P,WRITE
	MOVEI	WPL,WPLLPT		;ASSUME LINES FOR LPT
	TLNE IO,IOTTY			;CORRECT ASSUMPTION?
	MOVEI WPL,WPLTTY		;NO, SET UP LINES TO TTY

	POPJ	P,

WRITE0:	TLZN	IO,IOPAGE
	JRST	WRITE
	PUSH	P,C
	MOVEI	C,14
	PUSHJ	P,WRITE
	MOVEI	C,.LPP
	MOVEM	C,LPP
	SKIPE TIBUF	;IF TITLE THERE
	PUSHJ P,OUTTL	;PUT IT OUT
	SKIPE	TIBUF
	TRNE	IO,IOSUBT
	JRST	.+2		;IF THERE IS A TITLE BUT NO SUBTITLE,
	PUSHJ	P,LINOUT	;OUTPUT A CR-LF
	MOVE	C,SBTBUF
	HRLI	C,(POINT 7,0)
	PUSHJ	P,OUTTLX	;OUTPUT THE CREF SUBTITLE
	PUSHJ	P,LINOUT
	PUSHJ	P,LINOUT	;AND A BLANK LINE
	POP	P,C

WRITE:	CAMGE LINE,FIRSTL	;HAVE WE REACHED REQUESTED LINE?
	POPJ P,
	SOSG	LSTBUF+2
	PUSHJ	P,DMPLST
	IDPB	C,LSTBUF+1
	CAIN	C,12		;IF NOT LINE-FEED, OR
	TLNN IO,IOTTY		;IF NOT TTY, DON'T OUTPUT EVERY LINE
	POPJ	P,
	JRST DMPLST		;OUPUT LINE

OUTTL:	MOVE C,[POINT 7,TIBUF]
OUTTLX:	MOVEM C,SVPTR#
OUTTL1:	ILDB C,SVPTR
	JUMPE C,ENDRT
	CAIN C,12
	SOS LPP		;COUNT THE LINE
	PUSHJ P,WRITE
	JRST OUTTL1
ENDRT:	POPJ P,

;GET 1K MORE CORE AND MOVE THE SYMBOL TABLE (BOTH DDT'S AND CREF'S)
;UP INTO THE NEW SPACE

XCEED:	PUSH	P,0
	PUSH	P,1
	PUSH	P,2
	HRRZ	1,JOBREL	;GET CURRENT TOP
	MOVEI	0,2000(1)
XCEED2:	CORE	0,		;REQUEST MORE CORE
	JRST	ERRCOR		;ERROR, BOMB OUT
	HRRZ	2,JOBREL	;GET NEW TOP

XCEED1:	MOVE	0,0(1)		;GET ORIGIONAL
	MOVEM	0,0(2)		;STORE IN NEW LOCATION
	SUBI	2,1		;DECREMENT UPPER
	CAMLE	1,TOP	;HAVE WE ARRIVED?
	SOJA	1,XCEED1	;NO, GET ANOTHER
	MOVEI	1,2000
	ADDM	1,TOP
	CAME TOP,JOBREL
	ADDM 1,JOBSYM	;TOP=JOBREL ONLY IF SYMBOLS MOVED
	POP	P,2
	POP	P,1
	POP	P,0
	POPJ P,

FINIS:
	TLZN IO,IOEOF	;END OF FILE SEEN?
	JRST RECYCL	;NO, RECYCLE
	TLNE IO,IORPG
	JRST RPGFN
	CLOSE LST,0	;THIS WILL CLOSE IT ONLY IF LAST THING
	PUSHJ	P,CRLF
	PUSHJ	P,CRLF
	MOVE	C,FREE
	LSH	C,-^D10
	ADDI	C,1
	IDIVI	C,^D10
	JUMPE	C,FINIS1
	ADDI	C,"0"
	PUSHJ	P,TYO
FINIS1:	MOVEI	C,"0"(CS)
	PUSHJ	P,TYO
	MOVE RC,[POINT 6,[SIXBIT /K CORE@/]]
	PUSHJ P,PNTM1		;PRINT MESSAGE

RPGFN:	CLOSE	CHAR,
	TLNE IO,IORPG	;IF IN RPG MODE
	RENAME CHAR,ZEROS	;THEN DELETE INPUT FILE
	JFCL
RPGIGN:	RELEAS	CHAR,
	CLOSE	LST,
	PUSHJ	P,TSTLST	;YES, TEST FOR ERRORS
	RELEAS	LST,
	RELEASE SOP,0
	TLNN IO,IORPG
	JRST	CREF		;RETURN FOR NEXT ASSEMBLY
	MOVSI IO,IORPG
RPGFN2:	PUSHJ P,TTYIN
	CAIG C,15
	CAIGE C,12
	SKIPA
	JRST RPGFN2
	MOVSI C,70000
	ADDM C,CTIBUF+1
	AOS CTIBUF+2
	JRST RETRPG

NAME1:	SETZB	ACDEV,ACFILE
	SETZB	ACEXT,ACDEL
	SETZB	TIO,CS

NAME3:	MOVSI	ACPNTR,(POINT 6,AC0)	;SET POINTER
	TDZA	AC0,AC0		;CLEAR SYMBOL

SLASH:	PUSHJ	P,SW0
GETIOC:	PUSHJ	P,TTYIN	;GET INPUT CHARACTER
	CAIN	C,"/"
	JRST	SLASH
	CAIN	C,"("
	JRST	SWITCH
	CAIN	C,":"
	JRST	DEVICE
	CAIN	C,"."
	JRST	NAME
	CAIE	C,"_"
	CAIG	C,15
	JRST	TERM
	CAIE C,","
	CAIN	C,33	;NEW ALT MODE?
	JRST	TERM	;YES
	CAIN	C,"["
	JRST	PROGNP		;GET PROGRAMER NUMBER PAIR
	SUBI	C,40		;CONVERT TO 6-BIT
	TLNE	ACPNTR,770000	;HAVE WE STORED SIX BYTES?
	IDPB	C,ACPNTR	;NO, STORE IT
	JRST	GETIOC		;GET NEXT CHARACTER

DEVICE:	SKIPA	ACDEV,AC0	;DEVICE NAME
NAME:	MOVE	ACFILE,AC0	;FILE NAME
	MOVE	ACDEL,C		;SET DELIMITER
	JRST	NAME3		;GET NEXT SYMBOL

TERM:	CAIE	ACDEL,":"	;IF PREVIOUS DELIMITER
	CAIN ACDEL,0		;ASSUME FILE NAME IF NOTHING ELSE
	MOVE	ACFILE,AC0	;SET FILE
	CAIN	ACDEL,"."	;IF PERIOD,
	HLLZ	ACEXT,AC0	;SET EXTENSION
	MOVEM C,SVLET#	;SAVE THIS FOR A COMMAA CHECK
	POPJ	P,		;EXIT

PROGNP:	JUMPL	P,PROGN2	;ERROR IF OUTPUT
ERRCM:	JSP RC,ERRMSG
	SIXBIT /?COMMAND ERROR@/

PROGN1:	HRLZM	RC,INDIR+3	;COMMA, STORE LEFT HALF
PROGN2:	MOVEI	RC,0		;CLEAR AC
PROGN3:	PUSHJ	P,TTYIN
	CAIN	C,","
	JRST	PROGN1		;STORE LEFT HALF
	HRRM	RC,INDIR+3	;ASSUME TERMINAL
	CAIN	C,"]"
	JRST	GETIOC		;YES, RETURN TO MAIN SCAN
	LSH	RC,3		;SHIFT PREVIOUS RESULT
	ADDI	RC,-"0"(C)	;ADD IN NEW NUMBER
	JRST	PROGN3		;GET NEXT CHARACTER

SWITCH:	PUSHJ	P,TTYIN
	CAIL	C,"0"
	CAILE	C,"9"
	JRST	SWIT1
	PUSHJ	P,GETLIM
	CAIE	C,","
	JRST	ERRCM
	MOVEM	RC,LOWLIM
	PUSHJ	P,TTYIN
	PUSHJ	P,GETLIM
	CAIE	C,")"
	JRST	ERRCM
	MOVEM	RC,UPPLIM
	CAMGE	RC,LOWLIM
	TLO	IO,IONCRF
	JRST	GETIOC

SWIT1:	CAIN	C,")"
	JRST	GETIOC
	PUSHJ	P,SW1
	PUSHJ	P,TTYIN
	JRST	SWIT1

GETLIM:	TDZA	RC,RC
GETLI1:	PUSHJ	P,TTYIN
	CAIL	C,"0"
	CAILE	C,"9"
	POPJ	P,
	IMULI	RC,^D10
	ADDI	RC,-"0"(C)
	JRST	GETLI1

SW0:	PUSHJ	P,TTYIN
SW1:	MOVEI	C,-"A"(C)	;CONVERT FROM ASCII TO NUMERIC
	CAILE	C,"Z"-"A"	;WITHIN BOUNDS?
	JRST	ERRCM		;NO, ERROR
	MOVE	RC,[POINT 4,BYTAB]
	IBP	RC
	SOJGE	C,.-1		;MOVE TO PROPER BYTE
	LDB	C,RC		;PICK UP BYTE
	JUMPE	C,ERRCM		;TEST FOR VALID SWITCH
	CAIG	C,SWTABT-SWTAB	;LEGAL ON SOURCE?
	JUMPL	P,ERRCM	;NO, TEST FOR SOURCE
	XCT	SWTAB-1(C)	;EXECUTE INSTRUCTION
	POPJ	P,		;EXIT

	DEFINE	SETSW		(LETTER,INSTRUCTION) <
	INSTRUCTION
J=	<"LETTER"-"A">-^D9*<I=<"LETTER"-"A">/^D9>
	SETCOD	\I,J>

	DEFINE	SETCOD		(I,J)
	<BYTAB'I=BYTAB'I!<.-SWTAB>B<4*J+3>>

BYTAB0=	0			;INITIALIZE TABLE
BYTAB1=	0
BYTAB2=	0

SWTAB:
	SETSW	Z,<TLO	TIO,TIOCLD	>
SWTABT:
	SETSW	A,<ADDI	CS,1		>
	SETSW	B,<SUBI	CS,1		>
	SETSW	K,<TLZ	IO,IOSYM	>
	SETSW	M,<TLZ	IO,IOMAC	>
	SETSW	O,<TLO	IO,IOOP		>
	SETSW	S,<TLO	IO,IOLST	>
	SETSW	T,<TLO	TIO,TIOLE	>
	SETSW	W,<TLO	TIO,TIORW	>
	SETSW C,<TRO IO,IOCMB>
	SETSW L,<TRO IO,IOJLST>
	SETSW Q,<TRO IO,IOSOUT>

	SETSW R,<SETOM FIRSTL>

BYTAB:
	+BYTAB0
	+BYTAB1
	+BYTAB2

INSETF:	SKIPN	ACDEV
	MOVE	ACDEV,INDEV	;USE LAST DEVICE
	MOVEM	ACDEV,INDEV	;SAVE DEVICE FOR ERR MESSAGES
	SKIPN	ACFILE
	MOVE	ACFILE,[SIXBIT /CREF/]
	MOVEM	ACFILE,INDIR	;STORE FILE IN DIRECTORY

	MOVEI ACDEV-1,A		;INIT DEVICE IN "A" MODE
	MOVEI ACDEV+1,INBUF	;SET UP ARG FOR BUFFER HEADER
	OPEN CHAR,ACDEV-1	;OPEN CHANNEL
	 JRST ERRAVI		;FAILED

	TLZE	TIO,TIORW	;REWIND?
	MTAPE	CHAR,1		;YES
	JUMPGE	CS,INSET2
	MTAPE	CHAR,17
	MTAPE	CHAR,17
	AOJL	CS,.-1
	WAIT	CHAR,
	STATO	CHAR,1B24
	MTAPE	CHAR,16
INSET2:	SOJGE	CS,.-1

INSET3:	MOVEI ACDEV,INPT	;SET UP INPUT BUFFER POINTER
	EXCH ACDEV,JOBFF
	INBUF	CHAR,2
	MOVEM ACDEV,JOBFF	;RESTORE JOBFF
	JUMPN	ACEXT,INSET4	;TAKE USER'S EXTENSION IF NON-BLANK
	MOVE ACEXT,[SIXBIT /CRFLST/]	;TRY CRF FIRST, THEN LST
	JSP ACDEV,INSETI		;LOOKUP FILE (DON'T RETURN IF FOUND)
	JUMPN ACEXT,.-1			;KEEP LOOKING UNTIL EXT'S GONE
	HRLOI ACEXT,(SIXBIT /TMP/)	;FINALLY TRY TMP THEN STOP
	JSP ACDEV,INSETI
INSET4:	MOVEI ACDEV,ERRFND		;RETURN IS CONTINUE OR JRST ERRFND

INSETI:	HLLM	ACEXT,INDIR+1	;STORE EXTENSION
	LSH	ACEXT,^D18	;SLIDE NEXT EXT INTO PLACE
	LOOKUP	CHAR,INDIR
	JRST (ACDEV)		;NOT FOUND

				;FOUND
	SKIPN FIRSTL		;HAS INITIAL PRINTING LINE BEEN REQUESTED?
	JRST LSTS7		;NO
	TLNE IO,IORPG
	JRST LSTS4		;NO MESSAGE OUTPUT FOR RPG SYSTEM
	MOVEI TEMP,[ASCIZ /Restart cross reference at CREF line no. /]
	DDTOUT TEMP,		;TYPE THE ANSWER
	INPUT CTLI,		;INPUT THE ANSWER
LSTS4:	MOVEI AC0,0		;INIT DECIMAL NUMBER ASSEMBLER
LSTS5:	PUSHJ P,TTYIN	;GET CHARACTER
	CAIL C,"0"	;IS IT A DIGIT?
	CAILE C,"9"
	JRST LSTS6	;NO
	IMULI AC0,12	;YES
	ADDI AC0,-"0"(C)
	JRST LSTS5

LSTS6:	MOVEM AC0,FIRSTL	;SAVE DECIMAL NUMBER
LSTS7:	POPJ P,		;TO HERE IF NO INITIAL LINE SPECIFIED


CRLF:	MOVEI	C,15		;OUTPUT CARRIAGE RETURN
	PUSHJ	P,TYO
	MOVEI	C,12		;AND LINE FEED

TYO:	LSH C,^D29		;TELETYPE CHARACTER OUTPUT
				;GET CHAR LEFT JUSTIFIED
	HRRI C,C		;SET UP ADR OF CHARACTER
	DDTOUT C,		;OUTPUT (NULL IS THE 2ND CHAR)
	POPJ P,

TTYIN:		;COMMAND CHARACTER INPUT SUBROUTINE
RPGIN:	SOSG CTIBUF+2
	JRST CKRPGI
RPGIN1:	IBP CTIBUF+1
	MOVE C,@CTIBUF+1
	TRNN C,1
	JRST RPGIN2
	AOS CTIBUF+1
	MOVNI C,5
	ADDM C,CTIBUF+2
	JRST RPGIN

RPGIN2:	LDB C,CTIBUF+1
	JUMPE C,RPGIN
	CAIE	C," "		;SKIP BLANKS
	CAIN	C,"	"
	JRST	TTYIN
	CAIE	C,175
	CAIN	C,176
	MOVEI	C,33		;CHANGE ALL ALT MODES TO 033
	CAIN	C,32
	JRST	TTYIN		;IGNORE ^Z (EOF)
	CAIL	C,140
	TRZ	C,40		;CHANGE LOWER CASE TO UPPER CASE
	POPJ	P,		;NO, EXIT

CKRPGI:
IFN TEMPC,<	SKIPE TMPFLG	;IS TMPCOR UUO IN ACTION
	JRST TMPDON		;YES, EXIT>
	IN CTLI,0
	JRST RPGIN1
	STATO CTLI,740000
	JRST RPGCK2
	JSP RC,ERRMSG
	SIXBIT /?DATA ERROR READING COMMAND FILE@/
IFN TEMPC,<
TMPDON:	MOVE AC0,[XWD 2,TEMP]
	MOVSI TEMP,(SIXBIT /CRE/)
	MOVEI TEMP1,0
	CALLI AC0,TMPCOR	;DELETE TMPCOR FILE "CRE"
	JFCL			;FAILED, SO WHO CARES>
LEAVE:	CALLI 1,12		;EXIT
	JRST CREF

RPGCK2:	TLNN IO,IORPG		;IN CCL MODE?
	JRST CREF		;NO, START OVER
	RENAME CTLI,ZEROS
	JFCL
	JRST LEAVE

; HERE TO READ A CHAR FROM CURRENT CREF FILE
; READ - READS ONE CHARACTER INTO 'C' IGNORING NULLS (0)
; READXX - READS ONE CHARACTER INTO 'C' NOT IGNORING NULLS
;	(PRIMARILY FOR USE WITH CODE 110)
READXX:	SETZM	%IGNULL		;SET NOT TO IGNORE NULL
	JRST	READ0		;AND GO TO MAIN ROUTINE
READ:	SETOM	%IGNULL		;IGNORE NULLS
READ0:	SOSG	INBUF+2		;BUFFER EMPTY?
	JRST	READ3		;YES
READ1:	ILDB	C,INBUF+1	;PLACE CHARACTER IN C
	SKIPE	%IGNULL		;SKIP IF NOT IGNORING NULLS
	JUMPE C,READ0		;IF A NULL, LOOP TO GET NEXT CHAR
	POPJ	P,

READ3:	INPUT	CHAR,0		;GET NEXT BUFFER
	STATO	CHAR,762000	;ERROR?
	JRST	READ1		;NO, GET CHARACTER
	TLO IO,IOEOF	;FLAG EOF SEEN
	STATO	CHAR,742000
	JRST	READ4

	MOVEI CS,INDEV
	JSP RC,DVFNEX
	SIXBIT /?INPUT DATA ERROR, @/

DMPLST:	OUTPUT	LST,0		;OUTPUT BUFFER
TSTLST:	STATO	LST,740000	;ANY ERRORS?
	POPJ	P,		;NO, EXIT

	MOVEI CS,LSTDEV
	JSP RC,DVFNEX
	SIXBIT /?OUTPUT DATA ERROR, @/

READ4:	MOVE C,SVLET	;SEE WHAT LETTER LAST ONE ENDED WITH
	CAIE C,","	;IF NOT COMMA
	JRST R0		;PRINT CREF
	RELEASE CHAR,0	;LET GO OF INPUT
	TLZ IO,IOEOF	;NOT END OF FILE AFTER ALL
	PUSHJ P,NAME1	;GET A NAME
	PUSHJ P,INSETF	;AND SET UP INPUT
	JRST READ0	;READ FIRST CHR

; SUBROUTINE - OUTNWT
; C = A 7-BIT ASCII CHARACTER TO BE OUTPUT TO TERMINAL
; USES AUXCAL UUO TO OUTPUT CHARACTER - IF USER'S TERMINAL
; IS DETACHED, CHARACTERS ARE LOST
; NORMALLY USED ONLY IN PRINTING NAMES OF FILES BEING PROCESSED
OUTNWT:	PUSH	P,TEMP		;ONE REGISTER NEEDED
	HRROI	TEMP,3		;AUXCAL FCN:3 - IONEOU
	AUXCAL	TEMP,C		;OUTPUT CHARACTER
	 JFCL
	POP	P,TEMP		;RESTORE REGISTER
	POPJ	P,		;RETURN****

ERRAVI:	TLNE IO,IORPG	;IF IN RPG MODE
	JRST RPGIGN	;IGNORE FACT THAT FILE WAS NOT THERE
	SKIPA CS,[INDEV]	;INPUT DEVICE INIT FAILURE
ERRAVL:	MOVEI CS,LSTDEV		;LISTING DEVICE INIT FAILURE
	JSP RC,DVFNEX
	SIXBIT /?DEVICE NOT AVAILABLE, @/


ERRENT:	MOVEI CS,LSTDEV
	JSP RC,DVFNEX
	SIXBIT /?CANNOT ENTER FILE @/

ERRFND:	TLNE IO,IORPG	;IF IN RPG
	JRST RPGIGN	;IGNORE NOT THERE
	MOVEI CS,INDEV
	JSP RC,DVFNEX
	SIXBIT /?CANNOT FIND FILE @/

ERRCOR:	JSP RC,ERRMSG
	SIXBIT /?INSUFFICIENT MEMORY AVAILABLE@/


ERRMSG:	PUSHJ P,PNTMSG		;FOR SIMPLE ERROR MESSAGES
	JRST ERRFIN

DVFNEX:	PUSHJ P,PNTMSG		;PRINT MESSAGE DEV:FILENAME.EXT
	PUSHJ P,PNTSIX		;PRINT DEVICE
	MOVEI C,":"
	PUSHJ P,TYO		;PRINT COLON
	ADDI CS,1		;ADVANCE POINTER TO FILENAME
	SKIPN (CS)		;IS FILENAME 0?
	JRST ERRFIN		;YES, NO FILENAME
	PUSHJ P,PNTSIX		;NO, PRINT FILENAME
	ADDI CS,1		;ADVANCE POINTER TO EXTENSION
	HLLZS C,(CS)		;ZERO OUT OTHER HALF. EXTENSION=0?
	JUMPE C,ERRFIN		;EXTENSION 0?
	MOVEI C,"."		;NO
	PUSHJ P,TYO		;PRINT DOT
	PUSHJ P,PNTSIX		;PRINT EXTENSION

ERRFIN:	PUSHJ P,CRLF
	JRST CREF		;START CREF OVER

PNTSIX:	HRLI CS,(POINT 6,0)	;PRINT 1 WORD OF SIXBIT
PNTSX1:	TLNN CS,770000		;NEXT ILDB GO OVER WORD BOUNDARY?
	POPJ P,		;YES, FINISHED
	ILDB C,CS
	JUMPE C,.-2		;STOP AT A 0
	ADDI C,40		;CONVERT TO ASCII
	PUSHJ P,TYO
	JRST PNTSX1

PNTMSG:	PUSHJ P,CRLF		;PRINT SIXBIT MESSAGE
	HRLI RC,(POINT 6,0)
PNTM1:	ILDB C,RC
	CAIN C,40		;STOP AT @
	POPJ P,
	ADDI C,40		;CONVERT TO ASCII
	PUSHJ P,TYO
	JRST PNTM1

;;WHEN INIT FAILURE ON LISTING DEVICE,
;;IF LPT LET'S WAY 'WAITING' AND LET'S WAIT !
;;
WATLPT:	MOVE	CS,LSTDEV	;;GET LISTING DEVICE NAME
	CAME	CS,[SIXBIT/LPT   /];;IS IT LPT??
	JRST	[POP P,CS	;;NO--CLEAR PDL
		JRST ERRAVL]	;;AND COMPLAIN
	OUTSTR	[ASCIZ /LPT Busy--waiting/]

;;NOW WAIT
WAITL:	MOVEI	CS,^D30		;SLEEP FOR 30 SECONDS
	SLEEP	CS,		;;AS SO
	OPEN	LST,FLAG	;;RETRY OPENING OUTPUT DEVICE
	JRST	WAITL		;;CANT OPEN--KEEP LOOPING
	OUTSTR	[ASCIZ /
/]				;;C.R. INDICATES LISTING STARTED
	POPJ	P,		;;RETURN AFTER OPEN

	XLIST
LIT
	LIST


SVJFF:	BLOCK	1
CTIDEV:	BLOCK	1
TMPFLG:	BLOCK	1
CHOLD:	BLOCK	1
LINEX:	BLOCK	1
SBTBUF:	BLOCK	1
LN2COM:	BLOCK	1
%IGNULL:BLOCK	1

CTIBUF:	BLOCK	3
INBUF:	BLOCK	3
LSTBUF:	BLOCK	3
CTIDIR:	BLOCK	4
TMPFIL:	BLOCK	2
INPT:	BLOCK	203*2+1
SONAM:	BLOCK	4
SOBUF:	BLOCK	3

INDEV:	BLOCK	1
STCLR=INDEV

ZEROS:	BLOCK	4
INDIR:	BLOCK	4
LSTDIR:	BLOCK	4

PPSET:	BLOCK	PDL
TIBUF:	BLOCK	^D205/5

LSTDEV:	BLOCK	1
LPP:	BLOCK	1
PPTEMP:	BLOCK	1
FIRSTL:	BLOCK	1
LOWLIM:	BLOCK	1
UPPLIM:	BLOCK	1
LEVEL:	BLOCK	1
SVLAB:	BLOCK	1
BLKST:	BLOCK	1
FSTPNT:	BLOCK	1

OPTBL:	BLOCK	HASH
SYMTBL:	BLOCK	HASH
MACTBL:	BLOCK	HASH

BLKND:	BLOCK	1
ENDCLR=BLKND

END CREF
 9U)è