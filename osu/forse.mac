TITLE FORSE. 	 FORTRAN IV OPERATING SYSTEM 
SUBTTL	V31(224)	30-JUN-71	/DMN
;COPYRIGHT 1971, DIGITAL EQUIPMENT CORP. MAYNARD,MASS.,U.S.A.

SEARCH	DEF40		;TO GET RIGHT CPU


;REENT==1 GIVES RE-ENTRANT FORTRAN OP SYSTEM /DMN
IFNDEF REENT,<REENT==0>
IFN REENT,<	HISEG	>


IFE REENT,<IFNDEF FORSE.,<PRINTX ASSEMBLE WITH EITHER DATBS OR HPAR>>


;POSSIBLE SPR FIXES NOT YET WORKING %XXX WHERE XXX ISCCO NUMBER

IFNDEF %352,<%352==0		;FIX FOR CHANNEL ASSIGNMENT BUG>
SUBTTL	GLOBAL SYMBOLS


ENTRY		BINWR.
EXTERN	DUMER.			;**V31/01** CHAIN
SEXTERN	CHNIN.,CHAIN.			;**V31/01** CHAIN
EXTERN	DEBUG.,NXTCT.,FRSTM.,NXTFL.,TRPFL.	;**V31/01**DEBUG*
EXTERNAL	.JBFF,.JBREL,.JBUUO,.JBREN
EXTERNAL	ERROR.,LOGEN.,ILLCH.,INIER.,DEVER.,TBLER.,MSNG.,NOROM.
EXTERNAL	LISTB.,REDER.,ENDTP.,ILUUO.,BPHSE.,ILLMG.,ILLFN.,ILLPS.
EXTERNAL	DEVTB.,IOADR.,DEVND.,ILRED.,PARER.,BTLER.,AROPN.
EXTERNAL	WLKER.,NMLST.,TFMT.,TPFCN.,BUFER.,RANER.,FMTER.
EXTERNAL	NEG1.,NEG2.,NEG3.,NEG5.,DVTOT.,EXITP.
EXTERNAL	ERRIN.,TRPIN.,INTAB.,TRUCK.
IFN REENT,<	ENTRY	UUOP.>
IFE REENT,<INTERN	UUOL.,UUOH.>
INTERN		DEPOT.,CHINN.,IIB.,ENDLN.,INP.,INPT.
INTERN		XIO.,OUTT.,RIN.,CLOS.,FI.,FNCTN.,CLRSY.
INTERN		CLROU.,LOOK.,CLOSI.,SETOU.,STAT.,SESTA.
INTERN		NXTCR.,NXTLN.,WAIT.,BUFCA.,INP.,IORTR.,EOFTS.
INTERN		USETI.,USETO.,FCM1.,GETDV.
INTERN		MTPZ.,IOERR.
INTERN		DYDVL.,DISAB.,ENAB.
IFN REENT,<
EXTERNAL	ASVAR.,BLOCK.,CHARS.,WORDS.,RANAC.,RECNO.
EXTERNAL	ALPHA.,OMEGA.
EXTERNAL	DYNND.,FILNUM,VADDR.,UUOL.,PDLST.
EXTERN	FILE1.,FILE2.,FILE3.,FILE4.,FILE5.,UNITC.,FILPS.,FILSZ.
EXTERNAL	EOL.,DADDR.,TCNT1.,TCNT2.,ONLY1.,EOFFL.
EXTERNAL	TPNTR.,ILLEG.,DELIM.,INIT.
EXTERNAL	TEMP.,UUOH.,DEVIC.,FMTEN.,FMTBG.,FRPTC.
EXTERNAL	BUFHD.,DYNDV.,DYNCH.,DYPNT.,DYCHR.,DYEND.,DEVNO.,TYPE.,OVFLS.
EXTERNAL	RERDV.,INPDV.,DVNUM.,END.,ERR.
EXTERNAL	MTABF.,MBFBG.,TABPT.,TABP1.,DATTB.
EXTERN	VAR.,DMPIO.,LEVEL.,RANDV.,WDPREC
EXTERN	DECHDR,DEVNAM,DIGPTR,DNAME,EDERR,LINK.,RLINK.,BUFSZ.
EXTERN	ENCHDR,FOBPDP,GRPRPT,HDRADD,INCNT.,INIFLG,INPDEV
EXTERN	LASTLP,LINBUF,LINHDR,RCNT1,RCNT2,RERDN.
EXTERN	RPTR1,RPTR2,SAVEAC,SAVFAC,SAVSCN,LBPTR
EXTERN	PAKFL.,TNAME.,ITMCNT,TTYCH.,REE.
>
SUBTTL	  ;ACCUMULATORS
A=1		;UTILITY
B=2		;UTILITY
C=3		;UTILITY
D=4		;UTILITY
E=5		;FORMAT DESCRIPTOR
F=6		;FLAG REGISTER (USED IN I/O ROUTINES)
M=7		;ADDR. OF BUFFER HEADER(RH);DEV. NO. (LH)
H=10		;SLIST AOBJN WORD
I=11		;FLAG REGISTER
J=12		;NOT USED
K=13		;FORMAT POINTER
L=14		;PARENTHESIS COUNT
G=15		;INPUT BUFFER HDR ADDR.(LH);DEV. NAME ADDR.(RH)
N=16		;FLAGS IN LEFT
P=17		;PUSHDOWN POINTER
IFN REENT,<LOW=16>
IFE REENT,<LOW=0>

	;UUO DEFINITIONS

OPDEF	FLIST.	[07B8]
OPDEF	FNM.	[10B8]
OPDEF	OPE.	[11B8]
OPDEF	POS.	[12B8]
;*********DEBUG & CHAIN PATCH****28-FEB-72****V31/01******************
OPDEF	CHN.	[13B8]
OPDEF	STL.	[14B8]
;********************END OF PATCH***************************************
OPDEF	RESET.	[15B8]
OPDEF	IN.	[16B8]
OPDEF	OUT.	[17B8]
OPDEF	DATA.	[20B8]
OPDEF	FIN.	[21B8]
OPDEF	RTB.	[22B8]
OPDEF	WTB.	[23B8]
OPDEF	MTOP.	[24B8]
OPDEF	SLIST.	[25B8]
OPDEF	INF.	[26B8]
OPDEF	OUTF.	[27B8]
OPDEF	RERED.	[30B8]
OPDEF	NLI.	[31B8]
OPDEF	NLO.	[32B8]
OPDEF	DEC.	[33B8]
OPDEF	ENC.	[34B8]
OPDEF	FCALL.	[35B8]

OPDEF	ERROR	[PUSHJ	P,]	;NEVER RETURNS
OPDEF	PJRST	[JRST]		;POPJ RETURN AT JUMP
OPDEF	DEVSIZ	[CALLI	101]
		MLON

    ;PARAMETER ASSIGNMENTS

LSTBYT==1		;++ LAST BYTE POSN
DQ==42			;DOUBLE QUOTE
SL==17			;SLASH(SIXBIT)
LF==12			;LINE FEED
VT==13			;VERTICAL TAB
FF==14			;FORM FEED
CR==15			;CARRIAGE RETURN
LINCH==5*LINWDS-1	;NO. OF CHARACTERS IN LINE BUFFER
DYDVL.==20		;LENGTH OF DYNAMIC DEVICE TABLE
ESC==175		;**V31/01**ESCAPE*

;DEVCHR BITS

DSKBIT==(1B1)		;DSK
CRDBIT==(1B2)		;CARD I/O
LPTBIT==(1B3)		;LPT
USRTTY==(1B4)		;TTY IS USER'S CONSOL
AVABIT==(1B12)		;DEVICE IS AVAILABLE
MTABIT==(1B13)		;MTA
TTYBIT==(1B14)		;TTY
DIRBIT==(1B15)		;DEVICE HAS A DIRECTORY

;FLAGS STORED IN RIGHT OF DYNCH.

ASSCON==1B18		;ASSIGNED BY CONSOL
DFLBIT==1B19		;THIS DEVICE WAS A DEFAULT DEVICE (-1 TO -5)
SPLBIT==1B20		;THIS DEVICE IS SPOOLED
DMPBIT==1B21		;DEV. IS IN RANDOM ACCESS DUMP MODE

;DEVTYP BITS

.TYSPL==(1B13)		;DEVICE IS SPOOLED TO DSK

;FLAGS IN LEFT OF N, PREVIOUSLY FULL WORDS

TTYFL.==1		;TTY OR LPT
CDSFL.==2		;CARD I/O
DOLFL.==4		;NO CR AFTER TEXT
RRDFL.==10		;REREAD
RDWFL.==20		;FORMAT READ TO WRITE ATTEMPT
ENCFL.==40		;ENCODE/DECODE
SPLFL.==100		;SPOOLING TO DSK FOR THIS DEVICE
FKNFL.==200		;DOING RANDOM ACCESS LOOKUP/ENTER FOR UPDATING
DFLFL.==400		;DEFAULT DEVICE
ASSFL.==1000		;ASSIGNED  LOGICAL NAME FOR THIS DEVICE
RELFL.==2000		;DOING RELEAS UUO (FCALL. 0)
SMTTY.==4000		;DOING SIMULATE TTY UUO (FCALL. 2,)
TERMF.==10000		;TERMINAL
UUOFL.==(1B0)		;STILL DOING UUO'S  (DON'T SAVE ACCS AGAIN)

;FLAGS CLEARED BY FIN UUO.
FINFL.==-1

;INTERRUPT CHANNEL ASSIGNMENTS
ESCCHN==2
TRUCHN==1
INTERN	TTYFL.
;THE FOLLOWING ASSIGNMENTS ARE USED AS ARGUMENTS IN
;TLO INSTRUCTIONS WHICH GENERATE UUO'S.

NMTAPE==(MTAPE)
NCLOSE==(CLOSE)
NINPUT==(INPUT)
NOUTPT==(OUTPUT)
NSETST==(SETSTS)
NINBUF==(INBUF)
NOUBUF==(OUTBUF)
NUSETI==(USETI)
NUSETO==(USETO)
NLOKUP==(LOOKUP)

;STATUS CHECK FLAGS

IOWERR==400000        ;WRITE PROTECTION ERROR
IODERR==200000	     ;DATA MISSED ERROR
IOPERR==100000        ;PARITY OR CHECKSUM ERROR
IOBKTL==40000         ;BLOCK TOO LARGE ON INPUT
IODEND==20000         ;END OF FILE
IOTEND==2000          ;END OF TAPE
IOCON==40             ;CONTINUOUS I-O

;   FLAG		MEANING			ON/OFF

IOF.==	400000		;OUTPUT/INPUT		OUTPUT/INPUT
SFSF.==	200000		;SCALE FACTOR SIGN	-/+
RTNF.==	100000		;RETURN SWITCH		ON/OFF
POSS.== 100000		;POSITION STATEMENT	ON/OFF
POSF.==	 40000		;POSITION FUNCTION	YES/NO
TFF.==	 20000		;T FORMAT		YES/NO
SIZF.==	 20000		;SIZE FUNCTION		YES/NO
SLIOF.== 10000		;SLIST I-O		YES/NO
OPF.==	  4000		;OPEN STATEMENT		YES/NO
OPDV.==   2000		;DEVICE IN OPEN STRING	YES/NO
NLIOF.==  2000		;NAMELIST I-O		YES/NO
SQF.==	  1000		;"TEXT" IN FORMAT	YES/NO
STPFF.==   400		;SPECIAL TAPE FUNCTION	YES/NO
FCF.==	   200		;FILE COMMAND		YES/NO
FIOF.==	   100		;FORMAT I-O		YES/NO
DDF.==	    40		;DECTAPE OR DISC	YES/NO
DPSF.==	    20		;DBL. PREC. IN SLIST.	YES/NO
RRF.==	    10		;REREAD UUO		YES/NO
TFBF.==	     4		;T FORMAT BACKSPACE	YES/NO
RPF.==	     2		;() REPEAT FOR LEVEL 0,1YES/NO
DF.==	     1		;DIGIT FLAG		YES/NO

ETYP.==	400000		;E TYPE CONVERSION
GTYP.==	200000		;G TYPE CONVERSION
DTYP.==	100000		;D TYPE CONVERSION
SUBTTL	UUO EXTRY AND EXIT

;RETURN TO USER...RESTORE USER'S AC'S

UXIT.:	HLRZ	B,@UUOH.(LOW)	;LOOK AHEAD
	CAIG	B,(FCALL.)	;IS IT A FORTRAN UUO
	CAIG	B,(FLIST.)
	JRST	FINUX		;NO
	TRNE	B,(@)		;TOO COMPLEX TO HANDLE?
	JRST	FINUX		;YES, YOU LOSE
	MOVE	A,@UUOH.(LOW)	;PICK UP NEW UUO
	TLZN	A,17		;INDIRECTING?
	JRST	NOINDX		;NO, UUO IS COMPLETE
	HRRZ	C,B		;GET LEFT HALF OF UUO
	ANDI	C,17		;INDEX ONLY
IFN REENT,<ADDI	C,(LOW)>	;DON'T FORGET THE OFFSET
	MOVE	C,SAVEAC(C)	;GET VALUE OUT OF STORE
	ADDI	C,(A)		;GET EFFECTIVE ADDRESS
	HRR	A,C		;TO THE UUO WITHOUT CARRY
NOINDX:	LSH	B,-9		;MOVE INTO RIGHTMOST QUARTER
	MOVEM	A,.JBUUO	;SET UUO UP
	AOS	UUOH.(LOW)	;ADVANCE TO NEXT INST.
	TLO	N,UUOFL.	;SET FLAG SO WE DON'T SAVE ACCS AGAIN
	JRST	@TABU-7(B)	;DISPATCH TO UUO VALUE


FINUX:	TLZ	N,UUOFL.	;ENSURE FLAG IS CLEAR
IFN REENT,<MOVEI 0,SAVFAC+E(LOW)	;SAVE OP SYS AC'S
	HRLI	0,E		;BUT NOT THE TEMP. ONES>
IFE REENT,<MOVE 0,[E,,SAVFAC+E]>
	BLT	0,SAVFAC+P(LOW)
	MOVSI	17,SAVEAC(LOW)	;SET UP BLT TO RESTORE USER'S AC'S
	BLT	17,15
IFE REENT,<
UUOL.:	EXCH	N,SAVEAC+N	;RESTORE USER AC16>
	MOVE	17,SAVEAC+17(LOW)
RERTN:	MOVE	0,SAVEAC+0(LOW)	;RESTORE AC0
IFE REENT,<JRSTF @UUOH.		;RETURN TO USER>
IFN REENT,<JRST UUOL.(LOW)>



;ENTRY FROM USER

IFE REENT,<UUOH.:	0
	MOVEM	0,SAVEAC+0	;SAVE AC 0
	EXCH	A,.JBUUO	;PICK UP UUO
	LDB	0,[POINT 9,A,8]	;PICK UP UUO OP CODE
	CAIN	0,14		;**V31/01**DEBUG* CHECK FOR STL.
	JRST	DEBUG.		;**V31/01**DEBUG
	CAIE	0,15		;RESET. ?>
IFN REENT,<UUOP.:>
	JRST	NRES		;NO
				;YES, FALL INTO RESET.
SUBTTL	RESET. UUO

;RELEASE ALL DEVICES IN CASE ANY BUFFERS STILL FULL

	MOVEI	0,17		;CHANNELS 17-0
IFN REENT,<	REL==A
	MOVSI	REL,(RELEAS)	;SET UP UUO>
	DPB	0,[POINT 4,REL,12];DEPOSIT CHANNEL NO.
IFN REENT,<XCT	REL		;IN ACC>
IFE REENT,<
REL:	RELEAS			;****   MODIFIED>
	SOJGE	0,.-2

	RESET			;RESET I/O
IFE REENT,<SETO	0,		;STANDARD CPU TEST
	AOBJN	0,.+1		;TEST HARDWARE FOR HALF-WORD ADDER
IFN KI10,<JUMPE	0,.+3		;ON A KI-10
	OUTSTR	[ASCIZ /?KI-10 CODE WILL NOT RUN ON A KA-10/]
	EXIT			;FATAL, BUT CONTINUE SHOULD WORK>
	SETZM	SAVEAC+N	;CLEAR ALL FLAGS INITIALLY>
	MOVE	A,FOBPDP(LOW)	;SAVE START OF PUSHDOWN
	MOVEM	A,SAVFAC+P(LOW)	;SAVE POINTER FOR NEXT UUO
	SETZM	ALPHA.(LOW)	;CLEAR DATA BLOCK
IFE REENT,<MOVE	0,[XWD ALPHA.,ALPHA.+1]>
IFN REENT,<HRLI	0,ALPHA.(LOW)
	HRRI	0,ALPHA.+1(LOW)>
	BLT	0,OMEGA.(LOW)	;ZERO DATA BASE
	MOVE	17,PDLST.(LOW)	;INITIALIZE FORTRAN
				;FUNCTION PUSHDOWN POINTER
	SETO	0,		;SET KA-10/KI-10 FLAG
	AOBJN	0,.+1
	MOVEM	0,KA10.(LOW)
	PUSHJ	P,ERRIN.	;V.021- INITIALIZE ERROR HANDLER
	PUSHJ	P,TRPIN.(LOW)	;V.021- INITIALIZE TRAP HANDLER
	HRRZS	UUOH.(LOW)	;V.021- CLEAR ARITHMETIC FLAGS
IFE REENT,<MOVEI 0,EXITP.(LOW)	;GET ADDRESS OF EXIT ROUTINE>
IFN REENT,<MOVEI 0,REE.(LOW)	;OR REENTER ADDRESS>
	SKIPN	.JBREN		;IS USER USING REENTER ALREADY
	MOVEM	0,.JBREN	;NO, SET UP SO WE CAN CLOSE I/O
IFN REENT,<HRLI	0,(MOVEI LOW,)	;SET UP MOVEI 16,(16)
	HRR	0,LOW		;SO THAT (LOW) IS CORRECT
	MOVEM	0,REE.(LOW)	;EACH RESET
	MOVE	0,[JRST	EXITP.(LOW)]
	MOVEM	0,REE.+1(LOW)	;ENSURES 16 IS SET UP CORRECTLY>
	MOVE	0,[POPJ 17,]	;**V31/01**CHAIN
	PUSHJ	17,CHNIN.	;**V31/01**CHAIN
	MOVSI	0,NXTFL.	;**V31/01**DEBUG* SET FLAGS FOR DEBUG
	TLO	0,FRSTM.	;**V31/01**DEBUG
	MOVEM	0,TRPFL.	;**V31/01**DEBUG
	MOVEI	0,1		;**V31/01**DEBUG
	MOVEM	0,NXTCT.	;**V31/01**DEBUG
	MOVE	0,[17,,11]	;STATES WORD
	GETTAB	0,		;GET IT
	  SETZ	0,		;ERROR RETURN
	TLNN	0,(7B9)		;TEST FOR LEVEL D OR LATER
	TDZA	0,0		;NOT LEVEL D
	HRROI	0,-2		;USED FOR EXTENDED LOOKUPS (FUTURE USE)
	MOVEM	0,LEVEL.(LOW)	;STORE RESULT
	JRST	RERTN		;RETURN TO USER

SUBTTL	UUO'S OTHER THAN RESET. COME HERE

NRES:	CAIG	0,35		;CHECK UUO LIMITS
	CAIG	0,6		;**V31/01** CHAIN
	PUSHJ	P,ILUUO.	;ILLEGAL UUO VALUE
	MOVE	0,A		;SAVE UUO
	MOVE	A,ACBLT		;SET UP BLT FOR USER'S AC'S
IFN REENT,<ADDI	A,(LOW)>
	BLT	A,SAVEAC+15(LOW)
IFE REENT,<EXCH	N,SAVEAC+N>
	MOVEM	17,SAVEAC+17(LOW)
	MOVE	P,SAVFAC+P(LOW)	;SET UP OP SYS PUSHDOWN POINTER
;SAVE USER'S ACCUMULATORS AND DISPATCH ON UUO

	LDB	A,[POINT 9,0,8]	;**V31/01** CHAIN
	CAIE	A,13		;**V31/01** CHAIN
	JRST	.+3		;**V31/01** CHAIN
	MOVE	0,[JRST DUMER.]	;**V31/01** CHAIN
	JRST	CHAIN.		;**V31/01** CHAIN
	MOVE	B,A		;SAVE UUO NUMBER
	MOVE	A,0		;UUO
	MOVE	0,.JBUUO	;USER'S AC A
	MOVEM	0,SAVEAC+A(LOW)	;USER'S AC A
	SKIPG	TRAPF.(LOW)	;ARE THERE ANY TRAPS SET
	JRST	@TABU-7(B)	;NO
	PUSH	P,C		;NEED A REGISTER
	PUSHJ	P,DISAB.	;DISABLE ESCAPE AND TRU CHANNELS
	MOVEI	C,FORESC	;FORSE ESCAPE PROCESSOR
	EXCH	C,INTAB.+<ESCCHN-1>*2+1
	MOVEM	C,NRMESC(LOW)	;SAVE OLD VALUE
	MOVEI	C,FORTRU	;FORSE TRU PROCESSOR
	EXCH	C,INTAB.+<TRUCHN-1>*2+1
	MOVEM	C,NRMTRU
	SETZM	TRPLOC(LOW)	;CLEAR LOCATION TO GO TO IF TRAP IN FORSE
	HRROS	TRAPF.(LOW)	;SET NEGATIVE SO TRAP LOCS ONLY CHANGED FIRST TIME
	POP	P,C
	JRST	@TABU-7(B)	;DISPATCH TO UUO ROUTINES


;DISPATCH TABLE FOR INCOMING UUO'S..IN ORDER OF NUMERIC VALUE.

TABU:	FLIST.	FLIST		;FLIST.
	FNM.	FNM		;FNM.
	OPE.	OPENF		;OPE.
	POS.	POSS		;POS.
	CHN.	ILUUO.		;NOT THRU TABLE
	STL.	ILUUO.		;NOT THRU TABLE
	RESET.	ILUUO.		;NOT THRU TABLE
	IN.	INP		;IN.
	OUT.	OUTP		;OUT.
	DATA.	DATA		;DATA.
	FIN.	FIN		;FIN.
	RTB.	RTB		;RTB.
	WTB.	WTB		;WTB.
	MTOP.	RRBBW		;REW.,REWUN.,BSR.,WEF.,SPR.
	SLIST.	SLIST		;SLIST.
	INF.	INF		;INF.
	OUTF.	OUTF		;OUTF.
	RERED.	ILUUO.		;RERED. UUO NOT SUPPORTED
	NLI.	NLI		;NAMELIST INPUT
	NLO.	NLO		;NAMELIST OUTPUT
	DEC.	DEC		;DECODE
	ENC.	ENC		;ENCODE
	FCALL.	FCALLI		;FORTRAN CALLI

;CALCULATE BUFFER HEADER INFORMATION
;WORDS TO BE SKIPPED IN BUFFER BEFORE DESIRED RECORD= WORDS.
;CHARACTERS TO BE SKIPPED IN BUFFER BEFORE RECORD   = CHARS.
;THE BLOCK TO BE ACCESSED IN WHICH THE RECORD LIES  = BLOCK.
;THIS IS FOR ASCII INPUT

RANASC:	PUSH	P,A		;NEED TWO REGISTERS
	PUSH	P,B
	MOVE	A,ASVAR.(LOW)	;CHAR # IN FILE TO BE ACCESSED NEXT
	CAMN	A,[-1]		;-1 IS SPECIAL
	JRST	[MOVEM	A,BLOCK.(LOW)
		SETZM	CHARS.(LOW)
		JRST	TSTBLK]	;SET ON EOF
	IDIVI	A,5*200		;FIND BLOCK NUMBER
	AOJ	A,		;CONVERT BLOCK NUMBER TO 1-INDEXED
	MOVEM	A,BLOCK.(LOW)
	MOVEM	B,CHARS.(LOW)	;NUMBER OF CHARS FROM BLOCK START
TSTBLK:	LDB	C,[POINT 4,M,12]
IFN REENT,<ADDI	C,(LOW)>
	HRRE	B,RANDV.(C)	;GET INCORE BLOCK
	CAME	B,BLOCK.(LOW)	;IS IT THE ONE WE WANT?
	PUSHJ	P,RINP.		;NO
	PUSHJ	P,FIXBF		;RESET WORD COUNT AND BYTE POINTER
	JUMPL	I,.+2		; *301* IF INPUT
	XCT	IIB.		; *301* MUST ADVANCE BYTE POINTER TO READ FIRST CHAR.
	SKIPN	B,HDRADD(LOW)	;MIGHT BE USING LINE BUFFER
	MOVE	B,M		;WASN'T
	MOVE	0,2(B)		;GET CHAR COUNT
	SUB	0,CHARS.(LOW)	;SUBTRACT THOSE TO BE SKIPPED
	MOVEM	0,2(B)		;RESET CHAR COUNT
	MOVE	0,CHARS.(LOW)	;CHARS FROM BLOCK START
	IDIVI	0,5		;GET WORDS FROM BLOCK START
	ADDM	1(B)		;ADJUST POINTER
	JUMPE	A,.+3		;ANY EXTRA CHARS
	IBP	1(B)		;YES. ADJUST POINTER FOR EACH CHAR
	SOJG	A,.-1		;ANY MORE
	POP	P,B
	POP	P,A
	TLNE	I,POSS.		;CHECK IF POSITION STATEMENT
	JRST	FIB.		;IF SO, NO I/O TO DO
	JRST	FMTOUT		;AND RETURN
SUBTTL	FORMAT SCAN INITIALIZATION ROUTINE

IORET:	SKIPGE	RANAC.(LOW)	;DIRECT ACCESS CALLED FOR?
	JRST	RANASC		;YES,GO OFF TO ASCII BLOCK CALC
	JUMPGE	I,D0		;JUMP INOUTPUT
FMTOUT:	;SKIPN	C,HDRADD(LOW)	IS LINE BUFFER IN USE
	JRST	GETAC		;NO
	;MOVE	K,1(C)		YES. GET BYTE POINTER TO REAL BUFFER
	;TLNN	K,760000	DOES IT START ON WORD BOUNDRY
	;JRST	GETAC		YES
	;AOS	1(M)		NO. ADJUST LINE BUFFER POINTER TO FIRST WORD
	;HLLM	K,1(M)		SET TO POINT TO SAME BYTE AS REAL BUFFER POINTER
	;MOVE	0,@1(C)		GET PARTIAL WORD OF REAL BUFFER
	;MOVEM	0,@1(M)		PUT IN LINE BUFFER
	;HRLI	K,010700	SET REAL BUFFER POINTER TO START OF WORD
	;SOJ	K,		DECREMENT WORD ADDRESS
	;MOVEM	K,1(C)		RESTORE BYTE PINTER
	;JRST	GETAC
D0:	MOVE	0,DEVIC.(LOW)	;GET DEVICE NAME
	MOVEM	0,RERDV.(LOW)	;SAVE INPUT DEVICE NAME
	TLNN	I,RRF.		;REREAD UUO?
	JRST	GETAC		;NO
	LDB	C,[POINT 4,M,12]	;CHANNEL NUMBER
IFN REENT,<ADDI	C,(LOW)>
	MOVE	0,RINC1(LOW)	;BLOCK POSITION OF PREVIOUS LINE
	CAMN	INCNT.(C)	;IS IT THE SAME AS THE CURRENT LINE
	JRST	D1		;YES
	MOVEM	0,INCNT.(C)	;NO. MAKE PREV BLOCK THE CURRENT ONE
	HLL	0,M		;CHANNEL NUMBER FOR USETI
	TLO	0,NUSETI	;OP CODE
	XCT	0
	SOS	INCNT.(C)	;POINT TO PREVIOUS BLOCK
	PUSHJ	P,DOINP	;GET BLOCK
D1:	HRRZ	0,(M)		;START OF BUFFER
	ADD	0,RPTR1(LOW)	;ADDJUST POINTER TO BUFFER
	MOVEM	0,1(M)
	MOVE	0,RCNT1(LOW)	;ORIGINAL ITEM COUNT
	MOVEM	0,2(M)		;IN BUFFER HEADER
GETAC:	LDB	C,PTRU		;AC CONTAINING POINTER TO FMT
	ADDI	C,SAVEAC(LOW)	;ADDRESS OF AC BLOCK
	MOVSI	0,350700
	MOVEM	0,FMTEN.(LOW)	;SET UP POINTER TO END OF FMT
	HRRZ	K,(C)		;POINTS TO BEG. OF FORMAT
	HRLI	K,700		;BYTE SIZE
	HLRZ	0,(K)		;SEE IF JRST AROUND FORMAT
	TRZ	0,777		;**V31/01**DEBUG* ZER POSSIBLE BREAK
	CAIN	0,14000		;**V31/01**DEBUG* STL.?
	AOS	K		;**V31/01**DEBUG* YES  BUMP PAST
	HLRZ	0,(K)		;**V31/01**DEBUG* TEST FOR JRST
	CAIN	0,(JRST)
	JRST	HRS		;YES,THERE IS A JRST
	SUBI	K,1		;NOT A JRST BUT 1ST WORD OF FMT
	HLRZ	0,(C)		;LENGTH OF FORMAT ARRAY
	JUMPN	0,.+2
	MOVEI	0,^D251		;MAX. NO OF WORDS ALLOWED
	ADD	0,K		;UPPER BOUND ON FORMAT
	MOVEM	K,LASTLP(LOW)	;POINTER TO BEG. OF FORMAT
	MOVEM	K,GRPRPT(LOW)	;POINTER TO BEGINNING OF FMT FOR REPEAT
	AOJA	0,.+2		;POINT TO LAST WORD
HRS:	HRRZ	0,@K		;SET END ADR. FOR COMPARE
	HRRM	0,FMTEN.(LOW)	;END ADDR. OF FORMAT
	MOVEM	K,FMTBG.(LOW)	;POINTER TO BEGINNING OF FORMAT
	TLZ	I,-1-<IOF.!FIOF.!DDF.>	;CLEAR ALL BUT INPUT/OUTPUT, FMT,DIR/DEV
	SETOM	EOL.(LOW)	;SET END OF LINE FLAG AND CHAR. COUNT
	HRRI	E,0		;SCALE FACTOR=0
	CLEARB	L,OVFLS.(LOW)	;() COUNT AND LINE OVERFLOW
RIN.:	HRRI	I,0		;CLEAR ROUTINE FLAG
	CLEARB	A,FRPTC.(LOW)	;INITIALIZE COUNTERS
	HRLI	E,0		;INITIALIZE FIELD WIDTH
SUBTTL	CHARACTER SCAN AND DISPATCH

IN:	MOVEM	K,SAVSCN(LOW)
	ILDB	B,K		;NEXT FORMAT CHARACTER
;	CAIN	B,11		;CCO 30-15
;	MOVEI	B,40		;CCO 30-15
	CAMGE	K,FMTEN.(LOW)	;CHECK FOR END OF FORMAT
        JRST    IN2             ;NOT END
        JUMPE   L,PARL          ;( ) PAIRS MATCHED
        ERROR   FMTER.          ;( ) NOT MATCHED
        JRST    EDFIN           ;QUIT I/O
IN2:    TRZ	B,100		;CLEAR HIGH ORDER BIT
	TRC	B,40		;CONVERT TO SIXBIT ASCII
	MOVE	C,B		;SAVE FORMAT CHARACTER
	IDIVI	C,7		;SET FOR DISPATCH TABLE ENTRY
	LDB	C,PTRTAB(D)	;PICK UP DISPATCH INDEX
	JRST	@DISTAB(C)	;DISPATCH TO CHARACTER ROUTINE

;CHARACTER IS 0-9

DIG:	TLOE	I,DF.		;SET DIG FLG, SKIP IF IT WASN'T SET
	JRST	.+3
	MOVE	D,SAVSCN(LOW)	;GET PTR POSN BEFORE DIGITS
	MOVEM	D,DIGPTR(LOW)	;SAVE IT FOR RESCAN
	SUBI	B,20		;OCTAL DIGIT
	IMULI	A,12		;ACCUMULATE THE NUMBER
	ADD	A,B
	JRST	IN

; CHARACTER IS .

DECPT:	TSO	E,A		;SET FIELD WIDTH
	TLZ	I,DF.		;CLEAR DIG FLG
	MOVEI	A,0
	SETOM	,DECFLG		;**V31/01**MONEY* SET DEC PT FLG
	JRST	IN


;CHARACTER IS (

PARLF:	PUSH	P,A		;SAVE COUNT
	PUSH	P,K		;SAVE POINTER TO ( IN FORMAT
	TLNN	I,2		;LAST ( ALREADY STORED?
	CAILE	L,1		;SAVE LEVEL 0 OR 1 ONLY
	JRST	PARLF1		;LEVEL 2  DON'T SAVE FOR RESCAN
	TLZN	I,DF.		;CLEAR DIG FLG, SKIP IF IT WAS SET
	JRST	PARLF0		;NO DIGS BEFORE GROUP
	MOVE	A,DIGPTR(LOW)	;DIGS BEFORE GROUP
	MOVEM	A,GRPRPT(LOW)	;SAVE PTR TO 1ST LEVEL GROUP FOR RESCAN
	JRST	PARLF2		;SKIP
PARLF0:	MOVEM	K,GRPRPT(LOW)	;SAV PTR TO ( IN GROUP REPEAT
PARLF2:	MOVEM	K,LASTLP(LOW)	;SAVE POINTER TO (
PARLF1:	MOVEI	A,0
	AOJA	L,IN		;ADD ONE TO () COUNT

;CHARACTER IS )

PARR:	PUSHJ	P,COMMA		;DO CONVERSION IF NECESSARY
	HRRI	I,0		;PREVENT FURTHER CONVERSION
	SOJG	L,PARG		;OFFSET (
	TLON	I,RPF.		;CHECK FOR AUTO. FORMAT REPEAT
	JUMPL	L,PARL
	SKIPLE	-1(P)		;CHECK () COUNT
	JRST	PARG

PARL:	PUSHJ	P,COMMA		;PERFORM CONVERSION
	PUSHJ	P,ENDLN.	;TERMINATE THIS LINE
	HRRZ	0,INIFLG(LOW)
	CAIL	0,2
	SUB	P,[XWD 2,2]	;COMPENSATE FOR () PUSH
	TLO	I,RTNF.		;RETURN SWITCH ON
	MOVE	K,GRPRPT(LOW)	;RESET SCAN AT LAST 1ST LEVEL GROUP
	TLZ	I,1		;CLEAR GRP PEPEAT FLG

;RETURN TO USER FOR DATRESS OR TERMINATION OF SCAN

IORTR.:	TLNE	I,SLIOF.	;SLIST?
	JRST	NAS		;YES
NASBAK:	SKIPGE	EDERR(LOW)	;++ ENCODE DECODE ERROR?
	JRST	EDERRM		;++ YES,TYPE OUT MESSAGE SKIP TO FIN.
	JRST	UXIT.

;RESET SCAN AT LAST LEFT ( AND DROP COUNT

PARG:	SOSLE	-1(P)		;DROP () COUNT
	JRST	MSP
	SUB	P,[XWD 2,2]	;RESET P TO POINT TO LAST (
	JRST	RIN.		; *233* GET NEXT FORMAT CHARACTER
MSP:	MOVE	K,(P)		;RESET SCAN AT LAST (
	AOJA	L,RIN.		; *233* BUMP COUNT FOR RESCAN

;CHARACTER IS -

NEGSC:	TLO	I,SFSF.		;SCALE FACTOR SIGN
	TLZ	I,DF.		;DIG FLAG
	JRST	IN
;CHARACTER IS /

SLASH:	TLNE	N,ENCFL.	;/ IS ILLEGAL IN ENCODE-DECODE
	TTCALL	3,[ASCIZ ?WARNING! / IS ILLEGAL IN ENCODE-DECODE, END OF FORMAT ASSUMED
?]
	PUSHJ	P,COMMA		;CONVERSION,IF ANY
	PUSHJ	P,ENDLN.	;TERMINATE LINE
	JRST	RIN.

    ;CHARACTER IS SINGLE QUOTE

SQUOTE:	SETO	A,		;NO LIMIT TO CHARACTER COUNT
	TLO	I,SQF.		;SINGLE QUOTE FLAG

;CHARACTER IS H

HIO:	TLZ	I,DF.		;CLEAR DIG FLAG
	JUMPE	A,RIN.
	HRRZ	B,FMTEN.(LOW)	;END OF FORMAT
	SUBI	B,(K)		;BEG OF FORMAT
	IMULI	B,5
	JUMPGE	I,HINPT		;JUMP ON INPUT
HLDB:	ILDB	0,K		;CHARACTER FROM FORMAT
	SOJE	B,PARL		;TEST FOR END
	TLNN	I,SQF.		;SINGLE QUOTE?
	JRST	HDPB		;NO
	CAIN	0,"'"		;SINGLE QUOTE IN FORMAT?
	PUSHJ	P,DBLQTE	;TEST FOR TWO SINGLE QUOTES
HDPB:	PUSHJ	P,DEPOT.	;DEPOSIT CHARACTER
	SOJN	A,HLDB		;DROP COUNT
	JRST	RIN.
HINPT:	TLNE	I,SQF.		; *227* SINGLE QUOTE METHOD?
	JRST	.+5		; *227* YES, TEST FORMAT FOR ' FIRST
	PUSHJ	P,CHINN.	;GET A CHARACTER
	SKIPN	OVFLS.(LOW)	;DON'T ADVANCE IF END OF LINE
	XCT	IIB.
	SOJE	B,PARL		;TEST FOR END
	ILDB	C,K		;CHARACTER FROM FORMAT
	TLNN	I,SQF.		;SINGLE QUOTE?
	JRST	HINDPB		;NO
	CAIN	C,"'"		;SINGLE QUOTE IN INPUT?
	PUSHJ	P,DBLQTE	;YES,TEST FOR TWO SINGLE QUOTES
	PUSHJ	P,CHINN.	; *227* GET A CHARACTER
	SKIPN	OVFLS.(LOW)	; *227* DON'T ADVANCE IF END OF LINE
	XCT	IIB.		; *227*
	SOJE	B,PARL		; *227* TEST FOR END
	CAIN	0,"'"		; *227* SINGLE QUOTE IN INPUT?
	MOVEI	0,DQ		; *227* CHANGE TO "
HINDPB:	CAIE	0,15		;IS CHAR. A CARRIAGE RETURN?
	JRST	.+3		;NO
	SKIPE	OVFLS.(LOW)	;YES, END OF LINE SEEN?
	MOVEI	0,40		;YES, SUBSTITUTE A BLANK
	DPB	0,K		;PUT CHARACTER IN FORMAT
	SOJN	A,HINPT		;DROP COUNT
	JRST	RIN.

DBLQTE:	PUSH	P,K		;SAVE FORMAT POINTER
	ILDB	C,K		;LOOK FOR SINGLE QUOTE
	CAIE	C,"'"
	JRST	ET		;END OF TEXT
	POP	P,(P)		;RESET STACK
	POPJ	P,
ET:	POP	P,K		;RESTORE FORMAT POINTER
	POP	P,0
	TLZ	I,SQF.		;CCO 30-12, CLEAR SINGLE QUOTE FLG
	JRST	RIN.		;RETURN TO SCAN
;CHARACTER IS X

XIO.:	TLZ	I,DF.		;CLEAR DIG FLG
	JUMPGE	I,XINPT		;JUMP IF INPUT
	MOVEI	0," "		;BLANK
	PUSHJ	P,DEPOT.	;OUTPUT A BLANK
	SOJG	A,.-1
	JRST	RIN.
XINPT:	PUSHJ	P,CHINN.	;SKIP A CHARACTER
	SKIPN	OVFLS.(LOW)	;DON'T ADVANCE IF END OF LINE
	XCT	IIB.		;ADVANCE INPUT POINTER
	SOJG	A,XINPT
	JRST	RIN.


;CHARACTER IS P

PIO:	TLZ	I,DF.		;CLEAR DIG FLAG
	TLZE	I,SFSF.		;TEST FOR SCALE SIGN
	MOVNS	A		;SCALE NEGATIVE
	HRR	E,A		;SET SCALE FACTOR
	JRST	RIN.

;CHARACTER IS T

TIO:	TLOA	I,TFF.		;T FORMAT AND SKIP

;CHARACTER IS $

DOLSGN:	TLO	N,DOLFL.	;$ CARRIAGE CONTROL CHAR.
	TLZ	I,DF.		;CLEAR DIG FLG
	JRST	RIN.		;RETURN TO SCAN

;CHARACTER IS A,D,E,F,G,I,L,O

;CHARACTER IS G

GCONV:	TLOA	E,GTYP.		;G FLAG

AEIOU:	PUSHJ	P,RTNSET	;PICK UP CONV. ROUTINE ADDRESS
AEIOU1:	MOVEM	A,FRPTC.(LOW)	;SAVE DATA COUNT
	SETZ	A,		;CLEAR DECIMAL DIGIT AC
	TLZ	I,DF.		;CLEAR DIG FLAG
	JRST	IN		;RETURN TO FORMAT SCAN

RTNSET:	LDB	C,[POINT 6,DISTAB(C),11];ROUTINE INDEX
	JUMPGE	I,.+2		;INPUT OR OUTPUT ROUTINE NEEDED?
	ADDI	C,1		;OUTPUT
	HRR	I,IOADR.(C)	;PICK UP ROUTINE ADDRESS
	POPJ	P,

;CHARACTER IS ,

COMA:	PUSHJ	P,COMMA		;CONVERSION,IF ANY
	JRST	RIN.

;CHARACTER IS E

ECONV:	TLOA	E,ETYP.		;SET E FLAG AND SKIP

;CHARACTER IS D

DCONV:	TLO	E,DTYP.		;SET D FLAG
	JRST	AEIOU
;ROUTINE TO SET FORMAT WORD & GO TO CONVERSION SUBPROGRAMS

COMMA:	TLZ	I,DF.		;CLEAR DIG FLAG
	TLZE	I,TFF.		;T FORMAT?
	JRST	TFMT.		;YES
	TLNE	E,GTYP.		; G TYPE?
	JRST	COMMA1		;YES
	TRNN	I,-1		;CONVERSION NECESSARY?
	JRST	.+2		;**V31/01**MONEY* 
	JRST	COMMA1		;**V31/01**MONEY*
	SETZM	,DECFLG		;**V31/01**MONEY* CLEAR DEC PT FLG
	POPJ	P,		;NO CONVERSION
COMMA1:	ANDI	A,177		;W AND D MOD 128
	MOVSS	A
	SKIPE	,DECFLG		;**V31/01**MONEY* DEC PT READ?
;**	TLNE	E,177		;IS THERE A FIELD WIDTH?
	ASH	A,7		;SHIFT TO D FIELD
	IOR	E,A
	SETZM	,DECFLG		;**V31/01**MONEY* CLEAR DEC PT FLG
	TLZN	I,RTNF.		;RETURN SWITCH ON?
	JRST	IORTR.		;GET AN ADDRESS
	JRST	CNVT		;DO CONVERSION
SUBTTL	DATA. UUO

DATA:	JUMPL	N,DATA1		;ALREADY RESTORED?
IFN REENT,<MOVSI 0,SAVFAC+E(LOW)	;RESTORE OP SYS AC'S
	HRRI	0,E		;BUT ONLY THE USEFUL ONES>
IFE REENT,<MOVS	0,[E,,SAVFAC+E]>
	BLT	0,15		;ALL BUT 16 AND 17
DATA1:	HRRZ	C,A		;UUO ADDRESS
	CAIGE	C,20		;SEE IF DATUM IN AC
	ADDI	C,SAVEAC(LOW)	;YES,PICK UP FROM SAVE LOC.
	MOVEM	C,DADDR.(LOW)	;SAVE DATA ADDRESS
	LDB	C,PTRU		;AC FIELD CONTAINS TYPE CODE
	MOVEM	C,TYPE.(LOW)	;SAVE TYPE
	CAIGE	C,6		;IF DATA IS NEITHER COMPLEX NOR
	JRST	TFB		;DOUBLE PRECISION, GO TO TFB
	CAIN	C,7		;IF DATA IS COMPLEX,
	JRST	TFBM3		;OR
	HRRZ	0,I		;IF DATA IS DOUBLE PRECISION
	CAIE	0,14		;AND THE MODE IS BINARY, GO
	JRST	TFB3		;TO TFBM3.
TFBM3:	TLO	I,SLIOF.	;SET SLIST FLAG
	MOVSI	H,-2		;ARRAY OF LENGTH 2
	HRR	H,A		;ARRAY ADDRESS
TFB:	HRRZ	0,I		;PICK UP MODE
	CAIN	0,14		;BINARY MODE?
	JRST	BINDT.		;YES
TFB3:	TLNE	I,RTNF.		;RETURN SWITCH ON?
	JRST	RIN.		;YES,GO TO FORMAT SCAN
CNVT:	SKIPGE	FRPTC.(LOW)	;CHECK REPEAT COUNT
	POPJ	P,
	TLNN	E,GTYP.		;G FORMAT?
	JRST	NOTGTY		;NO
	MOVE	C,TYPE.(LOW)	;PICK UP DATUM TYPE
	CAIN	C,6		;CHECK FOR DOUBLE WORD
	TLO	E,DTYP.		;SETS DOUBLE PRECISION
	PUSHJ	P,RTNSET	;PICK UP CONV. ROUTINE ADDRESS
NOTGTY:	PUSH	P,E		;FORMAT SPECIFICATION
	MOVE	C,DADDR.(LOW)	;ADDRESS OF DATUM
	JUMPL	I,OUTCNV	;JUMP IF OUTPUT
	PUSHJ	P,(I)		;INPUT CONVERSION
	JRST	CHECK		;ILLEGAL CHAR IN INPUT
	MOVEM	0,(C)		;STORE HIGH ORDER WORD
	TLNE	E,DTYP.		;IS THERE A LOW ORDER PART?
	MOVEM	A,1(C)		;YES ,STORE IT
SOSO:	POP	P,0		;ACCOUNT FOR FORMAT WORD
	SOSLE	FRPTC.(LOW)
	JRST	IORTR.		;GET NEXT ADDRESS
	TLZ	E,GTYP.		; CLEAR G FORMAT FLAG
	POPJ	P,		;REPEAT COUNT IS ZERO

OUTCNV:	MOVE	0,(C)		;PICK UP HIGH ORDER PART
	MOVE	A,1(C)		;PICK UP LOW ORDER PART
	PUSHJ	P,(I)		;OUTPUT CONVERSION
	JRST	SOSO


CHECK:	SKIPN	ERR.(LOW)	;DOES THE USER DESIRE PROGRAM CONTROL?
	JRST	ILLCH.		;NO, PRINT ERROR MESSAGE AND FAIL
	XCT	IIB.		;ADVANCE TO NEXT CHARACTER
	PUSHJ	P,NXTCR		;YES,FINISH UP THIS LINE
	JRST	FI.		;GO TO POSITION SPECIFIED

SUBTTL	SLIST. UUO    SHORT LIST I/O

;THE AC OF THE SLIST UUO CONTAINS THE TYPE CODE--0 FOR INTEGER,
;6 FOR DOUBLE PRECISION, AND 7 FOR COMPLEX.  FOR DOUBLE
;PRECISION TWO WORDS ARE PASSED AT A TIME. THE ADDRESS OF
;THE UUO CONTAINS THE ARRAY BASE ADDRESS. THE WORD FOLLOWING
;THE SLIST. UUO CONTAINS THE LENGTH OF THE ARRAY.
;ADDRESS OF THE ARRAY IN THE RIGHT HALF.



SLIST:	JUMPL	N,SLIST1	;ALREADY RESTORED?
IFN REENT,<MOVSI 0,SAVFAC+E(LOW)	;RESTORE OP SYS AC'S
	HRRI	0,E		;BUT ONLY THE USEFUL ONES>
IFE REENT,<MOVS 0,[E,,SAVFAC+E]>
	BLT	0,15		;ALL BUT 16 AND 17
SLIST1:	TLO	I,SLIOF.	;SLIST FLAG
	LDB	C,PTRU		;AC FIELD OF UUO
	MOVEM	C,TYPE.(LOW)	;SAVE TYPE CODE
	HRLZ	H,@UUOH.(LOW)	;ARRAY LENGTH
	AOS	UUOH.(LOW)	;UPDATE RETURN ADDRESS
	HRRZ	0,I
	CAIN	0,14		;SKIP IF NOT BINARY MODE
	JRST	SLISTB		;CAN DO BLT'S FOR BINARY MODE ARRAYS
	MOVNS	H		;NEGATE LENGTH
	CAIN	C,7		;IS ARRAY COMPLEX?
	ASH	H,1		;YES,MULTIPLY BY 2
	CAIN	C,6		;IS ARRAY DOUBLE PRECISION?
	TLO	I,DPSF.		;YES,SET FLAG
	HRR	H,A		;BASE ADDRESS
HRS1:	HRRZM	H,DADDR.(LOW)	;SAVE SLIST ADDRESS
	JRST	TFB		;DO CONVERSION OR SCAN

;CONTROL TRANSFERRED HERE FOR EACH ADDRESS
;ALSO USED FOR SINGLE COMPLEX ITEMS.

NAS:	TLNE	I,DPSF.		;IS ARRAY DOUBLE PRECISION?
	ADDI	H,1		;ACCOUNT FOR 2 WORDS
	AOBJN	H,HRS1		;SET FOR NEXT DATUM
	TLZ	I,SLIOF.!DPSF.	;RESET SLIST FLAGS
	JRST	NASBAK		;RETURN TO USER

;HERE FOR BINARY MODE ARRAYS

SLISTB:	HRRZM	A,DADDR.(LOW)	;ADDRESS OF ARRAY
	HLRZS	H		;LENGTH OF ARRAY
	CAIE	C,6		;DOUBLE PRECISION?
	CAIN	C,7		;OR COMPLEX?
	ASH	H,1		;YES, DOUBLE NUMBER OF WORDS
	ADDM	H,ASVAR.(LOW)	;ADJUST FILE POSITION
SLISB0:	SKIPLE	2(M)		;SKIP IF I/O NEEDED
	JRST	SLISB2		;NO I/O REQUIRED
	JUMPGE	I,SLISB1	;JUMP IF INPUT
	PUSHJ	P,OUTPT		;OUTPUT BUFFER
	JRST	SLISB2
SLISB1:	PUSHJ	P,INPT.		;FILL BUFFER
SLISB2:	MOVE	C,H		;C=WORDS STILL NEEDED
	CAMLE	C,2(M)		;SKIP IF FITS IN BUFFER
	MOVE	C,2(M)		;NO, CUT DOWN TO BUFFER SIZE
	SUB	H,C		;SUBTRACT WORDS TO BE TRANSFERRED
	SUBM	C,2(M)		;SUBTRACT WORDS TRANSFERRED FROM WORDS LEFT IN BUFFER
	MOVNS	2(M)		;EXCEPT ITS NEGATIVE THAT WAY
	HRLZ	A,DADDR.(LOW)	;ADDRESS IN ARRAY OF NEXT DATUM
	HRR	A,1(M)		;ADDR OF BUFFER - 1
	ADDI	A,1		;BLT POINTER
	JUMPGE	I,SLISB4	;JUMP IF INPUT
	ADDM	C,DADDR.(LOW)	;ADDR PAST END OF THIS BLT FROM ARRAY
	ADDB	C,1(M)		;AND LAST ADDRESS IN BUFFER FOR BLT
	AOJA	C,SLISB5	;+1 FOR OUTPUT - ALL SET FOR BLT
SLISB4:	ADDM	C,1(M)		;ADDR IN BUFFER AFTER BLT FOR INPUT
	ADDB	C,DADDR.(LOW)	;ADDR PAST END OF BLT IN ARRAY FOR INPUT
	MOVSS	A		;SWAP BLT POINTER FOR INPUT
SLISB5:	BLT	A,-1(C)		;TRANSFER DATA TO/FROM BUFFER
	JUMPN	H,SLISB0	;LOOP IF MORE DATA IN ARRAY
	TLZ	I,SLIOF.!DPSF.	;ALL DONE, CLEAR SLIST FLAGS
	JUMPGE	I,NASBAK	;EXIT IF INPUT
	SKIPL	RANAC.(LOW)	;IS IT RANDOM ACCESS OUTPUT
	JRST	NASBAK		;NO. EXIT
	LDB	C,[POINT 4,M,12]	;YES. GET CHANNEL NUMBER
	HRROS	RANDV.(C)	;MARK AS NEEDS TO BE OUTPUTTED
	JRST	NASBAK		;AND EXIT
SUBTTL	TABLE OF POINTERS FOR CHARACTER DISPATCH

PTRTAB:	REPEAT 7,<	POINT 5,IRTAB(C),34-<.-PTRTAB>*5>


;TABLE OF DISPATCHING INDICES

IRTAB:	BYTE (5) 0,0,26,0,0,0,10
	BYTE (5) 6,13,10,0,12,11,24
	BYTE (5) 7,7,7,7,7,1,5
	BYTE (5) 0,0,7,7,7,7,7
	BYTE (5) 0,16,0,0,0,0,0
	BYTE (5) 20,2,14,17,15,23,0
	BYTE (5) 3,21,0,27,22,0,0	;**V31/01**MONEY*
	BYTE (5) 0,0,0,25,0,0,0
	BYTE (5) 0,0,0,0,0,0,4
	BYTE (5) 0,0,0,0,0,0,0
SUBTTL	DISPATCH TABLE USED FOR CHARACTER DISPATCH
;AND INDICES FOR CONVERSION ROUTINE NAMES.
;THE LEFT HALF OF THE FIRST 8 ENTRIES CONTAINS AN INDEX
;TO ENTRIES IN THE TABLE OF CONV. ROUTINE ADDRESSES,IOADR.,
;FOR G FORMAT.
;THE LEFT HALF OF THE ENTRIES FOR E,A,F,I,O,L,D CONTAINS
;AN INDEX TO THE ENTRIES IN IOADR. CORRESPONDING TO E,A,F,I,O,L,D.

DISTAB:	XWD	400,ERROR1	; ILLEGAL
	XWD	000,SLASH	;/
	XWD	200,HIO		;H
	XWD	1000,PIO	;P
	XWD	600,XIO.	;X
	XWD	000,DECPT	;.
	XWD	1200,NEGSC	;-
	XWD	200,DIG		;0-9
	XWD	000,IN		;BLANK OR +
	XWD	0,PARLF		;(
	XWD	0,PARR		;)
	XWD	0,COMA		;,
	XWD	000,GCONV	;G
	XWD	200,ECONV	;E FLOATING
	XWD	000,AEIOU	;A ALPHANUMERIC
	XWD	200,AEIOU	;F FLOATING
	XWD	400,AEIOU	;I FIXED
	XWD	600,AEIOU	;O OCTAL
	XWD	1000,AEIOU	;L LOGICAL
	XWD	1200,DCONV	;D    DOUBLE PRECISION
	XWD	000,SQUOTE	;'   TEXT
	XWD	000,TIO		;T  COLUMN SETTING
	XWD	000,DOLSGN	;$ CARRIAGE CONTROL
	XWD	1400,AEIOU	;**V31/01**MONEY*

ERROR1:	PUSHJ	P,ERROR.	;ILLEGAL CHARACTER IN FORMAT
SUBTTL	OUTPUT ROUTINES

;DEPOT. IS CALLED BY ALL OUTPUT ROUTINES FOR DEPOSITING
;CHARACTERS IN THE OUTPUT BUFFER AND DOING OUTPUTS. THE
;CHARACTER IS SENT IN AC 0 AND AC M IS USED.DEPOT. IS 
;CALLED BY   PUSHJ P,DEPOT.

DEPOT.:	TLNE	N,ENCFL.	;++ ENCODE?
	JRST	ENCOUT		;++ DON'T MESS AROUND WITH CRLF STUFF
;       THE FOLLOWING LINES WERE ADDED BYB CLC 02-05-74 TO FIX BUG
;       24694 RANDOUT,SYMBOLIC FILE.
        CAIE    0,CR            ; IS IT A CR CLC:02-05-74
        JRST    DEPOT1          ; NO IT ISN'T CLC:02-05-74
        TLNN    N,DOLFL.        ;SHOULD IT BE SUPRESSED CLC:02-05-74
DEPOT1: AOS     ASVAR.(LOW)     ; NOT TO BE DEPRESSED SO INCREMENT CTR.
	AOSG	EOL.(LOW)	;IS THIS THE FIRST CHARACTER?
	JRST	FRSTCH		;YES, MAKE SOME CHECKS
				;NOT FIRST CHARACTER SO FALL INTO CO

;OUTPUT ROUTINE CALLED BY DEPOT. FOR DEPOSITING CHARACTERS
;IN PROPER BUFFER,CHECKING LINES FOR OVERFLOW, DOING OUTPUTS
;AND ERROR CHECKING.

CO:	SKIPG	HDRADD(LOW)	;LINE BUFFER IN USE?
	JRST	DLB		;NO
	TLNN	N,DOLFL.	;SHOULD CR BE SURPRESSED
	JRST	CO1		;NO
	CAIE	0,CR		;YES. IS IT A CR
	JRST	CO1		;NO
	TLZ	N,DOLFL.	;YES. RESET SURPRESSION FLAG
	PUSH	P,0		;SAVE OUTPUT CHARACTER
	JRST	STLF2		;AND GO DUMP BUFFER
CO1:	SKIPE	OVFLS.(LOW)	;LINE OVERFLOW?
	JRST	LBCRCK		;YES,LOOK FOR CR
	IDPB	0,1(M)		;NO,DEPOSIT CHARACTER
	SOSG	2(M)		;BUFFER FULL?
	JRST	LBXCD		;YES,STASH CR,LF
LBCRCK:	CAIE	0,CR		;CARRIAGE RETURN?
	POPJ	P,		;NO,KEEP LOOKING
STLF:	PUSH	P,0		;SAVE OUTPUT CHARACTER
	MOVEI	0,LF		;PICK UP A LINEFEED
	IDPB	0,1(M)		;DEPOSIT IT
	AOS	ASVAR.(LOW)	;ACCOUNT FOR LINEFEED
	SOS	2(M)
STLF2:	PUSH	P,A		;GET AN AC. TO PLAY WITH
	PUSH	P,B
	PUSH	P,C
	SETZM	OVFLS.(LOW)	;CLEAR LINE OVERFLOW SWITCH
	HRR	A,HDRADD(LOW)	;ADDRESS OF REAL BUFFER HEADER
	MOVE	C,2(M)		;COUNT OF CHARS. LEFT IN LINE BUFFER
	SUBI	C,LINCH		;LENGTH OF LINE BUFFER
	MOVE	B,LBPTR(LOW)	;GET INTIAL BUFFER POINTER
STLF1:	ILDB	0,B		;GET NEXT CHAR FROM LINE BUFF
	IDPB	0,1(A)		;STORE IN REAL BUFFER
	SOSG	2(A)		;BUFFER FULL
	PUSHJ	P,OUTOK		;YES. DUMP BUFFER
	AOJL	C,STLF1		;LOOP ON CHARS IN LINE BUFFER
	SKIPL	RANAC.(LOW)	;RANDOM OUTPUT?
	JRST	STLF3		;NO
	LDB	C,[POINT 4,M,12]	;GET CHANNEL NUMBER
	HRROS	RANDV.(C)	;MAKE AS NEEDS TO BE OUTPUTTED
STLF3:	SETZM	LINBUF(LOW)	;CLEAR LINE BUFFER
IFE REENT,<MOVE	0,[XWD LINBUF,LINBUF+1]>
IFN REENT,<MOVSI 0,LINBUF(LOW)
	HRRI	0,LINBUF+1(LOW)>
	BLT	0,@1(M)		;CLEAR UP TO LAST WORD USED
	MOVEI	0,LINCH		;RESET ITEM COUNT
	MOVEM	0,2(M)	
	MOVE	0,LBPTR(LOW)	;RESET POINTER
	MOVEM	0,1(M)		;TO BEGINNING OF LINE BUFFER
	POP	P,C
	POP	P,B
	POP	P,A		;RESTORE A
	POP	P,0		;RESTORE CHARACTER
	POPJ	P,		;RETURN
LBXCD:	CAIN	0,CR		;WAS LAST CHAR. A CR?
	JRST	STLF		;YES,STASH LF
	PUSH	P,0		;SAVE CHAR.
	HRLI	0,170700	;NO,SET POINTER FOR CR
	HLLM	0,1(M)
	MOVEI	0,CR		;PICK UP CR
	IDPB	0,1(M)		;STASH IT
	SETOM	OVFLS.(LOW)	;SET LINE OVERFLOW FLAG
	POP	P,0		;RESTORE CHAR.
	POPJ	P,

DLB:	IDPB	0,1(M)		;DEPOSIT CHARACTER
	SOSLE	2(M)		;DROP ITEM COUNT
	CAIN	0,CR
	JRST	.+2
	POPJ	P,
	PUSH	P,0		;SAVE CHAR.
	TLNE	N,DOLFL.	;CHECK FOR $
	MOVEI	0,0		;YES,CLEAR OUT CR
	DPB	0,1(M)		;DEPOSIT CHARACTER
	SKIPG	2(M)		; *232* IS BUFFER FULL?
	JRST	DLB1		; *232* YES, ALWAYS DO OUTPUT
	TLNN	N,SPLFL.	;BUT NOT IF SPOOLING AND BUFFER NOT FULL
	TLNE	I,DDF.		; *232* OR DSK
	JRST	DLB3		; *232* SKIP OUTPUT FOR NOW
DLB1:	SKIPE	TRAPF.(LOW)	;ARE TAPS SET
	TLNN	N,TERMF.		;AND IS OUTPUT TO TERMINAL
	JRST	DLB2		;NO
	MOVEI	0,DLB4		;WHERE TO GO IF TRAP DURING I/O
	MOVEM	0,ESCCLR(LOW)
	PUSHJ	P,ENAB.	;ENABLE ESCAPES
	PUSHJ	P,OUTOK		;DO OUTPUT
	PUSHJ	P,DISAB.	;DISABLE TRAPS
	JRST	DLB3
DLB4:	HRR	0,0(M)		;ADDRESS OF BUFFER START
	HRLI	0,(POINT 7,,35)	;BYTE POINTER
	ADDI	0,1		;TO START OF BUFFER
	MOVEM	0,1(M)		;STORE IN BUFFER
	MOVEI	0,^D80		;SIZE OF TERMINAL BUFFER
	MOVEM	0,2(M)
	SETZM	OVFLS.(LOW)
	JRST	EDFIN		;EXIT FROM FORSE
DLB2:	PUSHJ	P,OUTOK		;DO OUTPUT AND CHECK STATUS
DLB3:	POP	P,0		;RESTORE CHAR.
	POPJ	P,		;RETURN

OUTOK:	PUSHJ	P,OUTT.		;DO OUTPUT
	PUSH	P,F		;SAVE F-USED FOR STATUS
	PUSHJ	P,STAT.		;GET STATUS
	TRNE	F,IOWERR!IODERR!IOPERR!IOBKTL!IOTEND
	PUSHJ	P,IOERR.	;I/O ERRORS
	SETZM	OVFLS.(LOW)	;CLEAR LINE OVERFLOW SWITCH
	POP	P,F		;RESTORE F
	POPJ	P,
;HERE FOR FIRST CHARACTER ON A LINE

FRSTCH:	TLNE	N,CDSFL.	;CARDS...FORCE LF ON OUTPUT
	JRST	[PUSH	P,0	;SAVE CHAR
		MOVEI	0,LF	;GET LINE FEED
		PUSHJ	P,CO	;OUTPUT IT
		POP	P,0	;GET THE CHAR
		JRST	CO]	;OUTPUT THAT CHAR
	TLNN	N,SPLFL.	;SPOOLING ALWAYS GOES TO DSK
	TLNN	N,TTYFL.	;TTY OR LPT?
	JRST	CO		;NO
	PUSH	P,0		;SAVE 0
	PUSH	P,A		;SAVE AC
	MOVE	A,0		;CONTROL CHARACTER
	MOVEI	0,LF		;LINE FEED
	CAIN	A,"0"		;0?
	JRST	ZE		;YES
	CAIN	A," "		;BLANK?
	JRST	POPA		;YES
	CAIN	A,"-"		;-  SKIP TWO LINES
	JRST	MI		;MINUS SIGN
	HRRI	A,-52(A)	;LOOK FOR CODE
	JUMPL	A,POPA		;SKIP A LINE IF NOT IN RANGE
	CAILE	A,11		;NOT IN RANGE
	JRST	POPA		;THEN ISSUE LF
	HRRZ	0,TABLE(A)	;SELECT CONTROL CHARACTER
	JRST	POPA		;DEPOSIT CONTROL CHARACTER
MI:	PUSHJ	P,CO		;DEPOSIT CHARACTER
ZE:	PUSHJ	P,CO		;DEPOSIT CHARACTER
	PUSHJ	P,OUTOK		;OUTPUT EXTRA LF NOW
				;HELPS T FORMAT COUNT CORRECTLY
	MOVEI	0,LF		;RESTORE LF IN AC0

POPA:	POP	P,A		;RESTORE A
	PUSHJ	P,CO		;DEPOSIT CHARACTER
NOLOK1:	POP	P,0
CPOPJ:	POPJ	P,


;++ THIS REPLACES THE OUTPUT STUFF FOR REGULAR OUTPUT. DOES NO CRLF
;++ INSERTS, JUST DEPOSITS CHAR.

ENCOUT:	SKIPGE	OVFLS.(LOW)	;++LINE END. FMT OR CHAR CNT.
	JRST	ENCOU1		;++OVFLS. SET.
	IDPB	0,1(M)		;++DEPOSIT BYTE
	SOSG	2(M)		;++ DROP CHAR COUNT
ENCLND:	SETOM	OVFLS.(LOW)	;++END OF RECORD OR BUFFER.
	POPJ	P,		;++RETURN FOR MORE

ENCOU1:	SKIPG	2(M)		;WAS OVFLS. FMT OR COUNT?
	SETOM	EDERR(LOW)	;++COUNT TO ZERO. FATAL ERROR .
	POPJ	P,		;++IF FMT END LINE IGNORE. RETURN.

TABLE:	OCT 23			;*,CR WITH NO FF AFTER 60 LINES
	OCT 0			;+, NULL
	OCT 21			;,,THIRTIETH
	OCT 0			;-,SKIP 2 LINES
	OCT 22			;.,TWENTIETH
	OCT 24			;/,SIXTH
	OCT 0			;0,SKIP 1 LINE FF AFTER 60 LINES
	OCT 14			;1,TOP OF FORM
	OCT 20			;2, HALF
	OCT 13			;3, THIRD OR V.T.
;END OF FORMAT ROUTINES
SUBTTL	END OF LINE

ENDLN.:	TLZN	I,TFBF.		;T FORMAT THIS LINE
	JRST	NOTTL		;NO
	MOVS	0,1(M)		;GET CURRENT POINTER
	TRC	0,-1		;BYTE POINTERS COUNT BACKWARDS
	PUSH	P,0		;SOMEWHERE TO SAVE IT
	MOVS	0,TPNTR.(LOW)	;BACKUP POINTER
	TRC	0,-1		;CONVERT IT ALSO
	CAMG	0,(P)		;HAS THERE BEEN A BACKUP?
	JRST	ENDLN1		;NO, BUT POP OFF STORE POINTER
	MOVE	0,TPNTR.(LOW)	;RESTORE SAVED POINTER AND ITEM COUNT
	MOVEM	0,1(M)
	MOVE	0,TCNT2.(LOW)
	MOVEM	0,2(M)
ENDLN1:	POP	P,0		;GET RID OF MODIFIED POINTER
NOTTL:	JUMPGE	I,BUFST		;JUMP IF INPUT
	TLNE	N,ENCFL.	;++ ENCODE?
	JRST	ENCLND		;++ SET LIN END FLG - ENCODE!
	MOVEI	0," "		; *350* LOAD UP BLANK
	JUMPLE	L,.+2		;YES,IS IT END OF FMT?
	CAIN	B,SL		;THIS CHAR. A /?
	SKIPL	EOL.(LOW)	; *231* YES, CHARACTER COUNT = 0?
	JRST	CRTN1		;NO,DELIMIT WITH CR
	PUSHJ	P,DEPOT.	;DEPOSIT A BLANK
CRTN1:	SKIPL	RANAC.(LOW)	; *230* RANDOM ACCESS?
	JRST	CRTN		; *230* NO
	PUSH	P,A		; *230* BETTER SAVE IT
	MOVE	A,DVNUM.(LOW)	; *230* GET DEVICE
IFN REENT,<ADDI	A,(LOW)>	; *230*
	MOVE	A,FILE2.(A)	; *350* CHARS. PER RECORD
	SUB	A,EOL.(LOW)	; *350* MINUS WHAT WE HAVE
	SUBI	A,2		;LEAVE ROOM FOR CR & LF
	JRST	.+2		; *350* NOT FIRST TIME
	PUSHJ	P,DEPOT.	; *230* OUTPUT THAT MANY SPACES
	SOJG	A,.-1		; *230* TO FILL RECORD
	POP	P,A		; *230* RESTORE
CRTN:	MOVEI	0,CR		;CARRIAGE RETURN
	PUSHJ	P,DEPOT.	;DEPOSIT C.R.
	SETOM	EOL.(LOW)	;SET END OF LINE FLAG
	POPJ	P,
BUFST:	TLNE	N,ENCFL.	;++DECODE?
	JRST	LINEND		;++ YES TERMINATE LINE
	CAIN	B,SL		;LAST CHAR. A /?
	SKIPLE	2(M)		;YES,BUFFER EMPTY?
	JRST	PPN		;NO,ADVANCE TO NEXT RECORD
	SKIPE	OVFLS.(LOW)	;CCO 30-14CHECK LINE OVERFLOW
	JRST	PPN+1		;CCO 30-14
PPN:	PUSHJ	P,NXTCR		;ADVANCE TO NEXT LINE
	SETZM	OVFLS.(LOW)	;CLEAR LINE OVERFLOW
	SETOM	EOL.(LOW)	;SET END OF LINE FLAG
	POPJ	P,		;RETURN

;++ FINISH UP ENCODE DECODE LINE END

LINEND:	SETOM	EOL.(LOW)	;++ END OF LINE FLG
LINEN1:	LDB	0,[POINT 6,1(M),5]	;++ GET PTR
	CAIN	0,LSTBYT		;++ IS THIS THE LAST BYTE?
	POPJ	P,		;++ YES, RETURN
	XCT	IIB.		;++ BUMP POINTER
	JRST	LINEN1		;++ TEST THIS BYTE
SUBTTL	FIN. UUO TERMINATE FORTRAN I-O STATEMENT

FIN:	JUMPL	N,FIN1		;ALREADY RESTORED
IFN REENT,<MOVSI 0,SAVFAC+E(LOW)	;RESTORE OP SYS AC'S
	HRRI	0,E		;BUT ONLY THE USEFUL ONES>
IFE REENT,<MOVS	0,[E,,SAVFAC+E]>
	BLT	0,15		;ALL BUT 16 AND 17
FIN1:	TLNE	I,OPF.		;DON'T OUTPUT IF OPEN STATEMENT
	JRST	FIB.
	HRRZ	0,I		;PICK UP MODE
	CAIN	0,14		;BINARY MODE?
	JRST	FIB.		;YES
	AOSE	EOL.(LOW)	;END OF LINE SEEN?
	PUSHJ	P,ENDLN.	;NO,TERMINATE LINE
	TLNE	N,ENCFL.	;++ENCODE/DECODE?
	JRST	ENCEND		;++FINISH UP ARRAY IF ENCODE
FIB.:	SETZM	END.(LOW)	;CLEAR END OF FILE FLAG
FIEND:	SETZM	ERR.(LOW)	;CLEAR INPUT ERROR FLAG
	SKIPL	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	FI.		;NO
	MOVE	D,FILNUM(LOW)	;GET F4 DEVICE NO.
IFN REENT,<ADDI	D,(LOW)>
	MOVE	C,FILE1.(D)	;GET ADR OF ASSOC VARIABLE
	MOVE	0,ASVAR.(LOW)	;GET INTERNAL ASSOC VAR VALUE
	SKIPN	B,FILE2.(D)	;IS IT FIXED LENGTH RECORD
	JRST	FI2		;NO
	IDIV	0,B		;GET RECORD NUMBER
	JUMPE	A,FI2		;ANY REMAINDER
	AOJ	0,		;YES. ROUND UP
FI2:	CAMLE	0,FILSZ.(D)	;HAS FILE SIZE BEEN INCREASED
	MOVEM	0,FILSZ.(D)	;YES. SET TO NEW SIZE
	AOJ	0,		;CONVERT TO ONE-INDEXED
	MOVEM	0,(C)		;PUT VALUE IN REAL ASSOC VAR
	SKIPGE	END.(LOW)	;WAS END OF FILE DETECTED?
	PUSHJ	P,CLOSI.	;SET UP FOR ANOTHER INPUT IF EOF.
FI.:	SETZM	RANAC.(LOW)	;CLEAR RANDOM ACCESS FLG
	MOVE	0,FOBPDP(LOW)	;INITIALIZE PUSHDOWN POINTER
	MOVEM	0,SAVFAC+P(LOW)	;RESTORE PUSHDOWN PTR
	TLZ	N,FINFL.	;CLEAR FLAGS
	SETZM	INIFLG(LOW)	;CLEAR FLAGS FOR NXT I/O
IFE REENT,<MOVE	0,[XWD INIFLG,INIFLG+1]>
IFN REENT,<HRLI 0,INIFLG(LOW)
	HRRI	0,INIFLG+1(LOW)>
	BLT	0,INPDEV(LOW)	;...
	MOVSI	17,SAVEAC(LOW)	;SET UP BLT TO RESTORE USERS ACS
	BLT	17,15
IFE REENT,<EXCH	N,SAVEAC+N	;RESTORE USER AC16>
	MOVE	17,SAVEAC+17(LOW)
	MOVE	0,SAVEAC+0(LOW)	;RESTORE AC0
	SKIPN	TRAPF.(LOW)	;ARE TRAPS SET
	JRST	ERRTST		;NO. CHECK FOR ERROR EXIT
	HRRZS	TRAPF.(LOW)	;MAKE POSITIVE
	MOVE	A,NRMESC(LOW)	;NORMAL ESCAPE PROCESSOR
	MOVEM	A,INTAB.+<ESCCHN-1>*2+1
	MOVE	A,NRMTRU(LOW)	;NORMAL TRU PROCESSOR
	MOVEM	A,INTAB.+<TRUCHN-1>*2+1
	PUSHJ	P,ENAB.	;ENABLE TRAPS
	SKIPE	TRPLOC(LOW)	;HAS A TRAP OCCURRED
	JRST	@TRPLOC(LOW)	;YES. GO TO IT
ERRTST:	SKIPN	A,ERR.(LOW)	;USER PROGRAM CONTROL IF INPUT ERROR
	JRST	ENDTST		;NO ERROR OR CONTROL NOT DESIRED
	SETZM	ERR.(LOW)	;CLEAR ERROR FLAG
	SETZM	END.(LOW)	;CLEAR POSSIBLE END FLAG
	HLL	A,UUOH.(LOW)	;GET FLAGS TO RESTORE
IFN REENT,<XCT	UUOL.(LOW)	;RESET OFFSET>
	JRSTF	@A		;GO TO POSITION SPECIFIED
ENDTST:	SKIPN	A,END.(LOW)	;USER PROGRAM CONTROL IF END-OF-FILE
IFE REENT,<JRSTF @UUOH.		;NO END OF FILE OR CONTROL NOT DESIRED>
IFN REENT,<JRST UUOL.(LOW)>
	SETZM	END.(LOW)	;CLEAR EOF FLAG
	HLL	A,UUOH.(LOW)	;GET FLAGS TO RESTORE
IFN REENT,<XCT	UUOL.(LOW)>
	JRSTF	@A		;GO TO POSITION SPECIFIED

;FORSE ESCAPE AND TRU PROCESSORS

FORESC:	CLRBFO			;CLEAR TTY OUTPUT BUFFER
	CLRBFI			;CLEAR TTY INPUT BUFFER
	PUSH	P,A
	MOVE	A,NRMESC(LOW)	;NORMAL ESCAPE PROCESSOR
	MOVEM	A,TRPLOC(LOW)	;SAVE FOR EXIT
	POP	P,A
	JRST	@ESCCLR

FORTRU:	JSA	16,TRUCK.	;HAS TRU LIMIT BEEN EXCEEDED
	PUSH	P,A		;YES
	MOVE	A,NRMTRU(LOW)	;NORMAL TRU PROCESSOR
	MOVEM	A,TRPLOC(LOW)	;SAVE FOR EXIT
	POP	P,A
	JRST	@ESCCLR

DISAB.: PUSH	P,A
        MOVEI   A,0
	JRST	DISENB
ENAB.:	PUSH	P,A
	MOVE	A,[1B0]
DISENB: SKIPN   DSESC.(LOW)     ;ARE ESCAPES DISABLED BY PROGRAM
        IOR     A,[1B<ESCCHN>]  ;NO.
        IOR     A,[1B<TRUCHN>]
	INTENB	A,
	HALT
	POP	P,A
	POPJ	P,
SUBTTL	CHINN.
;CHINN. IS CALLED BY ALL INPUT ROUTINES TO GET A CHARACTER.
;THE CHARACTER IS RETURNED IN AC 0. AC M IS USED.

CHINNN:	XCT	IIB.		;IGNORE CHAR.
	SOS	2(M)		;FIX COUNT
				;PROCESS NEXT CHARACTER
CHINN.:	SKIPE	OVFLS.(LOW)	;SWITCH ON IF ALL CHARS. USED
	JRST	RETCR		;IN WHICH CASE, RETURN A C.R.
	SKIPG	2(M)		;IS BUFFER EMPTY?
	PUSHJ	P,DOINP		;YES,DO INPUT
IOK:	LDB	0,1(M)		;PICK UP A CHARACTER
	JUMPE	0,CHINNN	;IGNORE NULLS
	AOS	EOL.(LOW)	;INCREMENT COLUMN COUNT
	CAIG	0,CR		;IS IT AN END OF LINE CHAR.?
	CAIGE	0,LF		;TEST FOR LF,VT,FF OR CR
	JRST	.+2		;NO
	JRST	NXTLN.		;YES,SKIP TO NEXT LINE
	CAIE	0,"Z"-100	;^Z ON TTY IS EOF MARK
	JRST	.+3		;NOT ^Z
	TLNE	N,TTYFL.	;BUT IS IT ON TTY
	JRST	EOFTS.
	SOS	2(M)		;DROP CHARACTER COUNT
	AOS	ASVAR.(LOW)	;INCREMENT CHAR COUNT IN FILE
	POPJ	P,		;RETURN

DOINP:	TLNE	N,ENCFL.	;++ DECODE?
	JRST	DECERR		;++ YES DON'T DO INPUT
	SKIPE	TRAPF.(LOW)	;ARE TRAPS SET
	TLNN	N,TERMF.	;AND IS INPUT FROM TERMENAL
	JRST	DOINP1		;NO
	MOVEI	0,ESCFIN		;WHERE TO GO IF TRAP DURING I/O
	MOVEM	0,ESCCLR(LOW)	;SAVE IF TRAP
	PUSHJ	P,ENAB.	;ENABLE ESCAPES
	PUSHJ	P,INP.		;DO INPUT
	PUSHJ	P,DISAB.	;DISABLE TRAPS
	JRST	IIB.
DOINP1:	PUSHJ	P,INP.		;GET NEXT BUFFERFUL
IIB.:	IBP	1(M)		;ADVANCE POINTER
	SKIPG	RCNT2(LOW)	;HAS CURRENTLINE POINTERS BEEN SAVED
	PUSHJ	P,SAVPTR	;NO. SAVE THEM
	PUSH	P,F		;SAVE F - USED IN I/O ROUTINES
	PUSHJ	P,STAT.		;GET ERRORS NOT ASSOCIATED WITH A BUFFER
	TRNE	F,IODEND
	JRST	EOFTS.		;END OF FILE
	TRNE	F,IOTEND!IOWERR
	ERROR	IOERR.		;EOT OR IMPROPER MODE
	HRRZ	F,(M)		;PICK UP 1ST WORD BUFFER
	MOVE	F,-1(F)		;TO GET STATUS
	TRNE	F,IODERR!IOPERR!IOBKTL
	ERROR	IOERR.
POPF:	POP	P,F		;RESTORE F
	POPJ	P,		;RETURN WITH CHARACTER

DECERR:	MOVEI	0,CR		;++TELLS CONVERSION ROUTINE END OF LINE
	SKIPE	EDERR(LOW)	;++ HAVE WE BEEN HERE BEFORE?
	SETOM	EDERR(LOW)	;++YES, SET 2ND TIME ERROR FLAG
	HLLOS	EDERR(LOW)	;++ NO SET 1ST TIME FLG(NON 0 R.H.)
	POP	P,(P)		;++GO RIGHT BACK TO CONVERSION RTN
	POPJ	P,		;++RETURN


ENCEND:	SKIPGE	I		;++ENCODE?
	SKIPN	A,2(M)		;++BUFFER EMPTY?
	JRST	ENCEN1		;++DECODE OR BUFFER EMPTY.
	SETZM	OVFLS.(LOW)	;++CLEAR OVERFLOW FLG
	MOVEI	0," "		;++BLANK
	PUSHJ	P,ENCOUT	;++FILL UP ARRAY.
	SOJG	A,.-1		;++
ENCEN1:	SETZM	OVFLS.(LOW)	; *267* CLEAR OVERFLOW FLAG
	JRST	FIB.		;++RETURN WHEN THROUGH.

;SEARCH TO END OF CURRENT LINE

NXTCR:	SKIPE	OVFLS.(LOW)	;END OF LINE ALREADY SEEN?
	POPJ	P,		;YES
	SKIPG	2(M)		;IS BUFFER EMPTY
	PUSHJ	P,DOINP		;YES. FILL IT
	JRST	NXTCR1		; *354* CHECK THIS CHARACTER

NXTCR.:	XCT	IIB.
	AOS	ASVAR.(LOW)
	SOSG	2(M)		;DROP ITEM COUNT
	PUSHJ	P,DOINP		;DO INPUT
NXTCR1:	LDB	0,1(M)		;GET NEXT CHARACTER
	CAIG	0,CR		;VERTICAL PAPER MOTION?
	CAIGE	0,LF
	JRST	NXTCR.		;NO,KEEP LOOKING
;	JRST	NXTLN.		;YES...GO TO NEXT LINE

SUBTTL	ADVANCE TO NEXT LINE IN BUFFER (IF THERE IS ONE)

NXTLN.:	SETOM	OVFLS.(LOW)	;SET END-OF-LINE SWITCH
	AOS	ASVAR.(LOW)	;YUP, INCREMENT VALUE OF ASSOC VAR
	XCT	IIB.		;IGNORE CR
	SOSG	2(M)		;DROP ITEM COUNT
	PUSHJ	P,DOINP		;FILL BUFFER IF NEEDED
	AOS	ASVAR.(LOW)	;INCREMENT ASSOC VAR
	XCT	IIB.		;IGNORE LF
NXTLN1:	SOSG	2(M)		;DROP ITEM COUNT
	JRST	NXTLN2
	LDB	0,1(M)
	CAIG	0,FF		;IGNORE LEADING FORM FEEDS
	CAIGE	0,VT		;AND VERTICAL TABS
	JUMPN	0,NXTLN2
	AOS	ASVAR.(LOW)
	XCT	IIB.
	JRST	NXTLN1
NXTLN2:	TLNE	N,RRDFL.	;HAS THERE BEEN A REREAD?
	JRST	RETCR		;YES,LEAVE POINTERS AS THEY ARE
	MOVE	0,RPTR2(LOW)	;MAKE OLD CURRENT PREV LINE
	MOVEM	0,RPTR1(LOW)
	MOVE	0,RCNT2(LOW)	;SAME FOR ITEM COUNT
	MOVEM	0,RCNT1(LOW)
	MOVE	0,RINC2(LOW)	;SAME FOR BLOCK NUMBER
	MOVEM	0,RINC1(LOW)
	PUSHJ	P,SAVPTR	;SAVE NEW CURRENT LINE
RETCR:	MOVEI	0,CR		;RETURN A C.R.
	POPJ	P,		;RETURN

;I/O ERROR ROUTINE

IOERR.:	TRNE	F,IODERR
	JRST	REDER.		;DATA ERROR
	TRNE	F,IOPERR
	JRST	PARER.		;PARITY ERROR
	TRNE	F,IOWERR
	JRST	WLKER.		;WRITE PROTECTION ERROR
	TRNE	F,IOBKTL	;ILL BLK. NUMBER OR QUOTA EXCEEDED
	JRST	BTLER.		;BLOCK TOO LARGE ERROR
	TRNE	F,IOTEND
	JRST	ENDTP.		;END OF TAPE
	POPJ	P,		;JUST INCASE ERROR TYPE NOT FOUND

SUBTTL	END OF FILE TESTING

EOFTS.:	TLNN	I,DDF.		;DON'T CLOSE FOR DSK/DTA
	PUSHJ	P,CLOSI.	;TURN OFF THE EOF BIT
	LDB	A,[POINT 4,M,12];GET CHAN #
IFN REENT,<ADDI A,(LOW)>	;SET UP INDEX
	SKIPL	EOFFL.(A)	;HAS THE EOFTST PROGRAM BEEN CALLED
	JRST	[SKIPN	END.(LOW);NO,DOES USER WANT PROGRAM CONTROL?
		JRST	LOGEN.	;NO,PRINT ERROR MESSAGE AND FAIL
		JRST	FIEND]	;YES,GO TO POSITION SPECIFIED
	MOVEI	A,4		;SET UP EOF SWITCH 
	IORM	A,(G)		;                  IN DEVICE NAME
EDFIN:	SOS	UUOH.(LOW)	;SET UP FOR CHECKING FOR FIN.
	MOVSI	B,(FIN.)	;PUT FIN.'S OP CODE IN  AC B
MOVUUO:	MOVE	A,@UUOH.(LOW)	;GET FORTRAN UUO FROM PROGRAM
	AOS	UUOH.(LOW)	;INCREMENT PASSED THE FIN. OP CODE
	CAME	A,B		;IS  THE UUO A FIN. 00,0
	JRST	MOVUUO		;NO,GET NEXT UUO
	JRST	FIEND		;EXECUTE FIEND AND GO TO NXT UUO AFTER FIN.
ESCFIN:	SETZM	END.(LOW)	;CLEAR END FLAG
	JRST	EDFIN


SUBTTL	IN. OR OUT. UUOS

OUTP:	MOVSI	I,IOF.		;OUTPUT,ASCII
	JRST	SFMTFL		;SET THE FORMAT FLAG

INP:	SETZ	I,		;INPUT,ASCII
	SETOM	INPDEV(LOW)	;SET ASCII INPUT DEVICE FLAG
SFMTFL:	TLO	I,FIOF.		;SET FORMAT FLAG
	SKIPL	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	NFI		;NO
	MOVE	B,RECNO.(LOW)	;GET NEXT RECORD FROM FORTRAN PROGRAM
	MOVEM	B,ASVAR.(LOW)	;PUT IN ASSOCIATED VARIABLE (INTERNAL)
NFI:	AOS	INIFLG(LOW)
RELI:	HRRE	0,A		;DEVICE NO.
	JUMPGE	0,POSDEV	;DEFAULT DEVICES?
	CAMLE	0,[-6]		;DEFAULT DEVICE?
	JRST	DFLDEV		;YES
	CAME	0,[-6]		;REREAD?
	JRST	PDERR		;ILLEGAL DEVICE NUMBER
	PUSHJ	P,REREAD	;YES, GET DEVICE
	MOVE	0,DVNUM.(LOW)	;NUMBER INTO 0
	JRST	POSDEV		;OK NOW
DFLDEV:
IFN %352,<MOVE	C,0		;SAVE ACTUAL DEVICE NUMBER>
	PUSHJ	P,MAKPOS	;YES, GET THE DEVICE
IFE %352,<TLO	N,DFLFL.	;SET DEFAULT DEVICE FLAG
POSDEV:>
IFN %352,<TLOA	N,DFLFL.	;SET DEFAULT DEVICE FLAG
POSDEV:	MOVE	C,0		;SAVE DEVICE NUMBER FOR POINTER>
	JUMPE	0,PDERR		;DEVICE 0 IS ILLEGAL
	CAILE	0,77		;CHECK RANGE OF DEVICE NO.
PDERR:	ERROR	DEVER.		;ILLEGAL DEVICE NO.
	MOVEM	0,DVNUM.(LOW)	;SAVE F4 DEV NUM
IFE %352,<MOVE	C,DEVNO.(LOW)	;HIGHEST DEVICE NUMBER IN USE
	JUMPE	C,NFI2		;JUMP IF NO DEVICES IN USE
	MOVEI	D,DYNCH.(LOW)	;BEGINNING OF CHARACTERISTICS TABLE
	ADD	D,C		;ADDRESS OF LAST DEVICE IN USE
NFI1:	HRRZ	E,0		;RH E=DEVICE NUMBER FROM USER'S JOB
	XOR	E,(D)		;CHECK WITH DEVICE NUMBER IN TABLE
	SUBI	D,1		;ADDR OF NEXT IN CHAR TABLE
	TRNN	E,-1-<SPLBIT!DMPBIT>	;CHECK DEVICE NUMBER BITS
	JRST	MATFND		;COMPLETE MATCH
	TRNE	E,-1-<ASSCON!DFLBIT!SPLBIT!DMPBIT>
	JRST	MATNFD		;NO, LOOP FOR ALL OF TABLE
	TLNE	N,DFLFL.	;IS IT A DEFAULT DEVICE?
	TRNN	E,ASSCON	;AND TEST DEVICE LOGICALLY ASSIGNED
	JRST	.+2		;NOT BOTH TRUE
	JRST	MATNFD		;BOTH TRUE SO NOT SAME DEVICE
	TRNN	E,DFLBIT	;IS DEVICE IN TABLE A DEFAULT?
	JRST	MATFND		;NO, SO DOESN'T MATTER IF NEW ONE IS ASSIGNED
	PUSHJ	P,LDEVCH	; *307* DO DEVCHR FOR LOGICAL DEVICE
	MOVE	0,DVNUM.(LOW)	; *307* RESTORE DEVICE NUMBER TO 0
	JUMPN	E,MATNFD	; *307* IT WAS, YOU LOSE, TRY NEXT ENTRY
	SKIPA	E,1(D)		; *307* ALL IS WELL, SO RESTORE DEVCHR BITS
MATNFD:	SOJG	C,NFI1		;LOOP FOR ALL IN TABLE>
IFN %352,<ADDI	C,5		;MAKE ROOM FOR NEGATIVES.
	IDIVI	C,9
	ASH	D,2
	SUBI	D,^D32
	MOVM	D,D		;MAKE IT POSITIVE
	LSH	D,^D30		;ALLIGN IT.
	TLO	D,400		;4-BIT BYTES
	HRR	D,C
	ADDI	D,DYCHR.(LOW)
	MOVEM	D,DYPNT.(LOW)	;SAVE POINTER
	LDB	C,D		;GET CHANNEL NUMBER FOR THIS DEVICE.
MATSET:	MOVEI	D,DYNCH.(LOW)	;BEGINNING OF CHARACTERISTICS TABLE
	ADD	D,C		;ADDRESS OF DEVICE
	MOVE	E,(D)		;GET CHARACTERISTICS.>
MATFND:	JUMPE	C,NFI2		;JUMP IF NOT IN TABLE, NEW DEVICE
	TLNE	N,RELFL.	;DOING RELEAS?
	JRST	RELES		;YES
	TLNE	N,SMTTY.	;IS SIMULATE TTY BEING DONE
	JRST	[HRLZI	0,TTYBIT	;YES. SET TTYBIT
		IORM	0,1(D)
		JRST	FI.]
	TLNE	I,OPF.		;OPEN STATEMENT?
	ERROR	AROPN.		;ERROR. UNIT IN USE
	TLNN	I,POSS.!POSF.!SIZF. ;IS THIS A POSITION OR SIZE
	JRST	FNDTTY		;NO
	PUSH	P,B
	MOVE	B,DVNUM.(LOW)	;YES. GET F4 UNIT CHARACTERISTICS
IFN REENT,<ADDI	B,(LOW)>
	IOR	I,UNITC.(B)	;MERGE IN CHARACTERISTICS
	POP	P,B
FNDTTY:	PUSHJ	P,FIDLDV	;LOOK AT DEVCHR BITS
	ADD	D,C		;RETURNED D=ADDR OF DYNDV., SET D=ADDR OF ENTRY
	MOVE	0,(D)		;AND 0=CONTENTS FOR THIS DEVICE
	TRZ	0,77		;CLEAR SIXTH CHAR OF DEVICE NAME
	JRST	DEVFND		;FOUND THE DEVICE
;HERE WHEN DEVICE NOT YET INITED

NFI2:	TLNE	N,RELFL.!SMTTY.	;DOING RELEAS OR SIMULATE TTY UUO
	JRST	FI.		;YES, JUST RETURN (NO-OP)
	TLNE	N,DFLFL.	;DEFAULT DEVICE?
	JRST	NEGNUM		;YES, BYPASS CHECK FOR LOGICAL ASSIGNMENT
	MOVE	B,DVNUM.(LOW)	;GET FORTRAN UNIT NUMBER
IFN REENT,<ADDI	B,(LOW)>
	SKIPN	TTYUN.(B)	;IS THIS UNIT THE TTY
	JRST	NFI3		;NO
	SKIPE	C,TTYCH.(LOW)	;YES. USE TTY CHANNEL
	JRST	FNDTTY
NFI3:	PUSHJ	P,LDEVCH	; *307* TRY DEVCHR FOR LOGICAL DEVICE
	MOVE	B,0
	MOVEM	0,DEVNAM(LOW)
	TLNN	E,USRTTY	;CONTROLLING TTY?
	JRST	.+3		;NO
	SKIPE	C,TTYCH.(LOW)	;YES, GET TTY CHAN. IF SET UP
	JRST	FNDTTY		;IT IS SET UP , SO USE IT
	TRNE	E,ASSCON	;HAS THE DEVICE BEEN ASIGNED BY CONSOL?
	TLOA	N,ASSFL.	;YES, SET FLAG SO DYNCH. CAN BE SET
NEGNUM:	PUSHJ	P,GETDV.	;NO, GET NAME FROM DEVTB
	TLNE	I,RRF.		;COMPARE FOR REREAD
	ERROR	ILRED.		;ILLEGAL REREAD
	TLNN	E,USRTTY	; *327* CONTROLLING TTY?
	JRST	.+3		; *307* NO
	SKIPE	C,TTYCH.(LOW)	; *327* YES, GET TTY CHAN. IF SET UP
	JRST	FNDTTY		; *327* IT IS SET UP , SO USE IT
	PUSHJ	P,FNDSLT	;FIND A SOFTWARE CHANNEL
	HRLZ	M,C		;SAVE DEVICE NO.
	ASH	M,5		;DEVICE NO. IN AC FIELD
	MOVEM	B,(D)		;PUT DEVICE NAME IN TABLE
	HRR	G,D		;SAVE ADDR. FOR THIS NAME
	PUSHJ	P,BUFCA.	;GET A BUFFER HEADER
	MOVEM	G,DNAME(LOW)	;SAVE DEV NAME ADDR
	SKIPGE	RANAC.(LOW)	;IF RANDOM ACCESS
	ADD	0,[3,,0]	;SET UP BUFFER HEADERS TO BE ADDRESS CHECKED
	MOVEM	0,INIT.+2(LOW)	;BUFFER HEADER ADDRESS
	SETZM	INIT.(LOW)	;V.007  ZERO THE ADDRESS PART
	MOVE	0,DEVNAM(LOW)
	MOVEM	0,INIT.+1(LOW)	;DEVICE NAME
	SKIPL	RANAC.(LOW)	;RANDOM ACCESS
	JRST	.+5		;NO
	MOVEI	0,16		;DUMP MODE
	MOVEM	0,INIT.(LOW)	;YES, SET DUMP MODE
	TLNN	E,DSKBIT	;MUST BE DSK
	ERROR	RANER.		;IT WASN'T SO FATAL ERROR
IFN REENT,<OPEN.==0
	MOVSI	OPEN.,(OPEN )	;SET UP UUO>
	DPB	C,[POINT 4,OPEN.,12]	;CHANNEL NO.
	TLNN	E,LPTBIT!TTYBIT	;BUT MAY NOT BE IN "N" YET. SO TEST "E"
	TLNE	N,TTYFL.	;TTY OR LPT?
	HRRI	I,1		;YES,ASCII LINE
	TLNE	E,MTABIT	;V.007  DEVICE MTA?
	PUSHJ	P,MGINIT	;V.007  YES, GO SET UP MODE BITS
	PUSH	P,I		;SAVE I
	HRRZS	I		;MODE BITS ONLY
	SKIPL	RANAC.(LOW)	;SETUP ALREADY IF RANDOM ACCESS
	IORM	I,INIT.(LOW)	;SET MODE ETC
	POP	P,I		;RESTORE I
IFN REENT,<HRRI	OPEN.,INIT.(LOW)
	XCT	OPEN.		;DO OPEN UUO>
IFE REENT,<
OPEN.:	OPEN	,INIT.		;INIT THE DEVICE>
	  ERROR	INIER.		;NOT AVAILABLE OR UNDEFINED
	TRZ	0,77		;CLEAR SIXTH CHAR OF DEVICE NAME
	MOVEM	B,DEVIC.(LOW)	;CURRENT DEVICE NAME
	PUSHJ	P,CLROU.	;CLEAR OUTPUT-LAST BIT
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	PUSHJ	P,SNGLBF	;YES, GET BUFFER SPACE
	MOVEI	B,DYNCH.(LOW)	;ADDR OF DEVICE CHARACTERISTICS TABLE
	ADD	B,C		;INDEX FOR THIS DEVICE
	HRR	E,DVNUM.(LOW)	;LH=DEVCHR, RH=FTN DEVICE
	PUSH	P,C		;SAVE CHAN.
	DEVTYP	C,		;NEW DEVCHR TYPE UUO
	  JRST	NOTSPL		;NEED 5.03 TO SPOOL
	TLNE	C,.TYSPL	;TEST FOR SPOOLING
	TRO	E,SPLBIT	;YES, SET SPOOL FLAG
NOTSPL:	POP	P,C		;RESTORE CHAN.
	TLNE	N,ASSFL.	;TEST FOR FLAGS AND SET IN DYNCH.
	TRO	E,ASSCON	;LOGICALLY ASSIGNED
	TLNE	N,DFLFL.	;WAS IT A FORTRAN DEFAULT DEVICE
	TRO	E,DFLBIT	;YES
	SKIPE	RANAC.(LOW)	;RANDOM ACCESS?
	TRO	E,DMPBIT	;YES, WILL USE DUMP MODE
	MOVEM	E,(B)		;THOUGH REALLY ONLY NEED 7 BITS
	PUSHJ	P,FIDLDV	;LOOK AT DEVCHR BITS
	SKIPE	RANAC.(LOW)	;IS IT A RANDOM FILE
	JRST	[MOVE	B,[1,,203]
		JRST	NOTSP1]
	MOVEI	B,INIT.(LOW)	;ADDRESS OF OPEN DATA
	DEVSIZ	B,		;GET BUFFER SIZE
	PUSHJ	P,DSKSIZ	;FAILED. SEE IF DSK
NOTSP1:
IFN REENT,<ADDI	C,(LOW)		;SO INDEXING WILL WORK>
	MOVEM	B,BUFSZ.(C)	;STORE INFO
IFN REENT,<SUBI	C,(LOW)>
	MOVE	B,DVNUM.(LOW)	;GET DEV NUMBER
                        ;TYM  THE FOLLOWING TWO LINES HAVE
                        ;TYM  REMOVED TO CORRECT REREADING OF WRONG FILE
                        ;TYM  AFTER OPEN OF A FILE, AND TO GET THE
                        ;TYM  REREAD POINTERS WITHIN REASONABLE
                        ;TYM  BOUNDS FOR AN INCORRECTLY EXECUTED REREAD
;	JUMPL	I,.+2		;SKIP ON OUTPUT
;	MOVEM	B,RERDN.(LOW)	;SAVE DEV. # FOR REREAD.
	MOVEM	B,FILNUM(LOW)	;SAVE FOR FILE NAME
IFN REENT,<ADDI	B,(LOW)>
	MOVE	0,I		;GET FILE CHARACTERISTICS
	TLZ	0,-1-<IOF.!FIOF.> ;SAVE ONLY MODE AND ACCESS
	MOVEM	0,UNITC.(B)	;SAVE FOR LATER FILE ACCESS
	SKIPE	B,DATTB.(B)	;IF BUFFER WAS CALLED,
	PUSHJ	P,SETBFS	;GO SET UP RINGS.
	JRST	DVF

;HERE TO TRY DEVCHR FOR LOGICAL ASSIGNMENT
;EXPECTS FORTRAN DEVICE NUMBER IN AC0, RETURNS DEVCHR BITS IN AC E

LDEVCH:	TLNN	I,OPF.		;OPEN STATEMENT?
	JRST	LDEVC1		;NO
	MOVE	0,OPNDEV(LOW)	;USE OPEN DEVICE
	MOVE	E,0		;RETURN THIS DEVICE NUMBER
	DEVCHR	E,
	TRO	E,ASSCON	;THIS DEVICE ASSIGNED BY OPEN STATEMENT
	POPJ	P,
LDEVC1:	PUSH	P,A		;SAVE AC
	IDIVI	0,12		;CONVRT TO 6-BIT
	LSH	0,6
	OR	0,1		;CAN HAVE UP TO 77 OCT DEVICES THIS WAY
	IORI	0,2020
	TRNN	0,700		;TWO DIGITS?
	LSH	0,6		;ONE DIGIT
	LSH	0,30		;LEFT JUSTIFY
	MOVE	E,0
	POP	P,A		;RESTORE AC
	DEVCHR	E,
	POPJ	P,

;HERE TO TEST FOR DSK AND SIMULATE DEVSIZ UUO 
;IF DEVICE IS NOT DSK RETURN -1
;IF DSK IN DUMP MODE RETURN 0
;IF DSK IN BUFFERED MODE REURN 2,,203

DSKSIZ:	SETZ	B,		;CLEAR B FOR RETURN
	TLNN	E,DSKBIT	;IS IT A DSK?
	SOJA	B,CPOPJ		;NO, RETURN -1
	TRNN	E,DMPBIT	;DSK, BUT IN DUMP MODE?
	MOVE	B,[2,,203]	;NO, STANDARD  DOUBLE BUFFERING
	POPJ	P,

;AS ABOVE BUT USES AC0, NO NEED TO TEST FOR DUMP MODE THOUGH

DSKSZ0:	SETO	0,		;ASSUME NOT A DSK (RETURN -1)
	TLNE	E,DSKBIT	;IS IT A DSK?
	MOVE	0,[2,,203]	;YES, STANDARD BUFFER SIZE RETURN
	POPJ	P,
SUBTTL	FORTRAN CALLI UUO

;FCALLI 0, WHICH EXPECTS DEVICE NUMBER IN AC0
;FCALLI 1, WHICH RELEASES ALL CHANNELS IN USE
;FCALLI 2,N WHICH CAUSES CARRIAGE CONTROL TO BE USED ON UNIT N
;FCALLI 3, WHICH STOPS MEMORY BEING RELEASED WHEN BUFFERS ARE RELEASED

FCALLI:	LDB	B,PTRU		;GET ACC FIELD
	CAILE	B,3		;FUNCTION <=3?
	PUSHJ	P,ILUUO.	;NO
	JRST	.+1(B)		;GO TO CORRECT FUNCTION
	JRST	FCALL0
	JRST	FCALL1
	JRST	FCALL2
;	JRST	FCALL3

FCALL3:	SETOM	NRMEM.(LOW)	;SET NO RELESE MEMORY SWITCH
	JRST	FI.		;RETURN TO PROGRAM

FCALL2:	TLO	N,SMTTY.	;SET SIMULATE TTY BIT
	JRST	RELI		;GO GET CHANNEL NUMBER

FCALL0:	HRRZM	A,CLSBIT(LOW)	;SAVE CLOSE BITS
	MOVE	A,SAVEAC+0(LOW)	;GET DEVICE #
	TLO	N,RELFL.	;SET RELEAS ONLY FLAG
	JRST	RELI		;GET CHAN # ETC

FCALL1:	MOVE	C,DEVNO.(LOW)	;START AT HIGHEST CHANNEL IN USE
	SETZM	ERR.(LOW)	;CLEAR ERR AND END IN CASE STILL ON
	SETZM	END.(LOW)	;AS WE MIGHT GET ERROR ON CLOSE
;	JRST	RELES		;RELEASE IT

;RELEASE UUO -  FCALLI 0

RELES:	HRLZ	M,C		;CHAN. #
	ASH	M,5		;IN AC FIELD
	PUSHJ	P,BUFCA.	;GET HEADER
	HLR	M,G		;PUT INPUT BUFFER ADDRESS IN M FOR SURE
IFN REENT,<ADDI	C,(LOW)>
	MOVE	B,DYNDV.(C)	;GET DEVICE NAME
	TRZ	B,77		;CLEAR I/O FLAGS
	CAMN	B,RERDV.(LOW)	;SAME AS LAST READ-DEV?
	SETZM	RERDV.(LOW)	;YES, CLEAR IT.
	CAMN	B,INPDV.(LOW)	;SAME AS LAST ASCII-INPUT DEV?
	SETZM	INPDV.(LOW)	;YES, CLEAR IT.
	MOVEI	A,TABPT.(LOW)	;POINTER TO MTABF.
CLRMTA:	CAIGE	A,MTABF.(LOW)	;DONE WITH MTABF.?
	JRST	DONMTA		;YES
	MOVE	D,(A)		;GET NAME FROM MTABF.
	TRZ	D,77		;CLEAR I/O FLAGS
	CAME	D,B		;THE ONE WE WANT?
	SOJA	A,CLRMTA	;NO, GET NEXT
	SETZM	(A)		;YES, CLEAR IT
DONMTA:	MOVE	B,DYNCH.(C)	;GET DEVCHR WORD
	TRNN	B,DMPBIT	;RANDOM ACCESS DEVICE?
	JRST	CHKCLS		;NO
	SETOM	RANAC.(LOW)	;SET RANDOM ACCESS FLAG
	SKIPL	RANDV.(C)	;MUST WE OUTPUT LAST BLOCK.
	JRST	CHKCLS		;NO
	SETZM	BLOCK.(LOW)	;INHIBIT INPUT OF NEXT BLOCK
	MOVSI	I,IOF.		;ASSUME OUTPUT FILE
	MOVE	B,1(M)		;GET STRING POINTER
	TLNN	B,4000		;IS IT SYMBOLIC OR BINARY
	TLO	I,FIOF.		;SYMBOLIC
	PUSHJ	P,ROUTP.	;OUTPUT LAST BLOCK
CHKCLS:	TLNE	N,RELFL.	;IS IT A SINGLE UNIT RELEASE
	SKIPN	B,CLSBIT(LOW)	;AND IS THERE ANY CLOSE BITS
	JRST	OPNABT		;BOTH NOT TRUE
	HLL	B,M		;GET CHANNEL NUMBER
	TLO	B,NCLOSE
	XCT	B
OPNABT:	HLLZ	0,M		;GET CHAN #
	TLO	0,(RELEAS)	;SET UP RELEAS UUO
	XCT	0		;DO RELEAS UUO
	PUSHJ	P,LNKBUF	;LINK THE BUFFERS INTO CHAIN
	SETZM	DYNDV.(C)	;CLEAR DYNDV. ENTRY
	SETZM	DYNCH.(C)	;CLEAR DEVCHR BITS
	SETZM	BUFSZ.(C)	;CLEAR BUFFER DATA
	SETZM	INCNT.(C)
	SETZM	EOFFL.(C)
	SETZM	ONLY1.(C)	;CLEAR EOF ANS ONLY1 FLAGS FOR CHANNEL
IFN REENT,<SUBI	C,(LOW)>
	CAMN	C,TTYCH.(LOW)		;ARE WE RELEASING THE TTY?
	SETZM	TTYCH.(LOW)		;YES, FORGET ALL ABOUT TTY
IFN %352,<MOVE	D,[POINT 4,DYCHR.(LOW)]	;CLEAR DEVICE VS. CHANNEL TABLE.
	MOVEI	B,DYEND.(LOW)
	ILDB	M,D
	CAMN	M,C		;IS THIS ON SAME CHANNEL?
	DPB	0,D		;YES, CLEAR ENTRY.
	CAILE	B,(D)		;ARE WE DONE?
	JRST	.-4		;NO.>
	ASH	C,1		;2 ENTRIES/CHANNEL
IFN REENT,<ADDI	C,(LOW)>
	SETZM	TNAME.(C)	;CLEAR FILE NAME INPUT/OUTPUT
	SETZM	TNAME.+1(C)	;
	TLNE	N,RELFL.	;FCALLI 0?
	JRST	[MOVE D,DVNUM.(LOW)	;GET F4 UNIT NUMBER
		IFN REENT,<ADDI D,(LOW)>
		SETZM FILE2.(D)	;CLEAR UNIT DEPENDENT FLAGS
		SETZM FILE4.(D)
		SETZM FILE5.(D)
		SETZM UNITC.(D)
		SETZM TTYUN.(D)
		JRST FI.]
	SOSL	C,DEVNO.(LOW)	;FCALLI 1
	JRST	RELES		;MORE TO GO
	SETZM	DEVNO.(LOW)	; *355* RESTORE TO ZERO INCASE  START OR REENTER
	JRST	FI.		;ALL DONE
;RELEASED BUFFER SPACE IS LINKED TOGETHER HERE
;LINK. CONTAING THE MASTER POINTERS
;XWD FIRST LINK ,, LAST LINK
;LINK. POINTS TO THE FIRST WORD OF THE BUFFER AREA RECOVERED
;IN THAT AREA THE FIRST WORD IS A LINK TO THE PREVIOUS AND NEXT AREAS
;POINTER IS XWD PREVIOUS AREA ,, NEXT AREA
;SECOND WORD IS DEVSIZ RETURN
;XWD NUMBER OF BUFFERS IN RING ,, BUFFER SIZE
;A POINTER OF ZERO IS THE END OF THE CHAIN

LNKBUF:	SKIPG	A,BUFSZ.(C)	;GET BUFFER INFO.
	POPJ	P,		;NOT AVAILABLE, OR DONE
	PUSH	P,E		;BETTER SAVE E
	SKIPE	D,(M)		;INPUT BUFFER USED?
	PUSHJ	P,LINKUP	;YES, RECLAIM IT
	SETZM	(M)		;CLEAR INPUT BUFFER POINTER
	SKIPE	D,3(M)		;OUTPUT BUFFER USED?
	PUSHJ	P,LINKUP	;YES
	SETZM 	3(M)		;CLEAR OUTPUT BUFFER POINTER
	POP	P,E		;RESTORE IT
	POPJ	P,		;RETURN

LINKUP: HRRZ    D,D             ;INSURE ONLY ADDRESS SET
	HRRZ	E,(D)		;GET NEXT BUFFER IN RING
	JUMPE	E,CPOPJ		;IS THERE ACTUALLY A RING
LNKUP1:	CAIN	E,(D)		;BEEN ROUND RING?
	SOJA	D,LINK1		;YES
	CAIG	E,(D)		;NEARER ZERO?
	HRRZ	D,E		;YES
	HRRZ	E,(E)		;NEXT BUFFER IN RING
	JRST	LNKUP1		;TRY AGAIN

LINK1:	MOVEM	A,1(D)		;SET BUFFER SIZE OF RETURNED BUFFERS
	MOVE	B,LINK.(LOW)	;GET FREE LIST POINTER
	PUSHJ	P,RELMEM	;TRY TO RETURN MEMORY OF RETURNED BUFFER
	JRST	LINK5		;NOT RELEASED. PUT ON FREE LIST
	JUMPE	B,CPOPJ		;NOTHING ON FREE LIST. RETURN
	HRRZ	D,B		;SEARCH FREE LIST FOR ANYTHING TO RELEASE

LINK2:	HLRZ	A,(D)		;NEXT BUFFER FROM END OF FREE LIST
	PUSHJ	P,RELMEM	;CAN MEMORY BE RELEASED
	JRST	LINK3		;NO. FIX FREE LIST AND EXIT
	JUMPE	A,LINK4		;ANYMORE BUFFERS ON FREE LIST
	MOVE	D,A		;YES. TRY TO RELEASE IT
	JRST	LINK2

LINK3:	HRRM	D,LINK.(LOW)	;SET NEW END OF FREE LIST
	HLLZS	(D)		;CLEAR NEXT POINTER OF LAST BUFFER ON FREE LIST
	POPJ	P,		;RETURN

LINK4:	SETZM	LINK.(LOW)	;CLEAR FREE LIST
	POPJ	P,		;AND RETURN

LINK5:	JUMPN	B,LINK6		;ARE THERE ANY ENTRIES ON FREE LIST
	SETZM	(D)		;NO PREV OR NEXT POINTERS
	HRRM	D,LINK.(LOW)	;SET LAST POINTER OF FREE LIST
	HRLM	D,LINK.(LOW)	;SET FIRST POINTER OF FREE LIST
	POPJ	P,		;AND RETURN

LINK6:	HLRZ	A,B		;SEARCH FREE LIST FOR POSITION OF RETURNED BUFFER

LINK7:	CAMGE	D,A		;DOES NEW BUFFER GO BEFORE THIS SPACE
	JRST	LINK8		;YES. GO INSERT
	HRRZ	A,(A)		;GET ADDRESS OF NEXT BUFFER
	JUMPN	A,LINK7		;ANYMORE ENTRIES ON FREE LIST
	HRLZM	B,(D)		;NO. MAKE RETURNED BUFFER LAST ON FREE LIST
	HRRM	D,(B)		;MAKE OLD LAST POINT TO NEW LASE
	HRRM	D,LINK.(LOW)	;NEW LAST ON FREE LIST
	POPJ	P,	I;RETURN

LINK8:	HLL	0,(A)		;CONSTRUCT POINTER FOR NEW BUFFER
	HRR	0,A		;PREV IS PREV OF OLD. NEXT IS OLD POINTER
	MOVEM	0,(D)		;STORE IN RETURNED BUFFER
	HRLM	D,(A)		;MAKE OLD PREV POINT TO NEW
	TLNN	0,-1		;IS INSERT BEFORE FIRST
	JRST	[HRLM	D,LINK.(LOW)	;YES. MAKE NEW, NEW FIRST
		POPJ	P,]
	HLRZ	A,0		;MAKE OLD PREV POINT TO NEW
	HRRM	D,(A)
	POPJ	P,		;RETURN

RELMEM:	PUSH	P,A		;SAVE TO DO SIZE COMPUTATION
	HRRZ	0,1(D)		;GET SIZE OF ONE BUFFER
	HLRZ	A,1(D)		;GET NUMBER OF BUFFERS
	IMUL	0,A		;GET NUMBER OF WORDS
	ADD	0,D		;GET ADDRESS OF WORD AFTER BUFFERS
	SKIPL	NRMEM.(LOW)	;SHOULD MEMORY BE RELEASED
	CAMGE	0,.JBFF		;OR IS IT END OF MEMORY
	JRST	RLMN1		;NO
	HRRM	D,.JBFF		;YES. SET NEW END OF MEMORY
	HRRZ	0,D		;MOVE NEW LAST ADDRESS FOR CORE CALL
	PUSHJ	P,XPAND		;DECREASE MEMORY
	AOS	-1(P)		;SET SKIP RETURN
RLMN1:	POP	P,A
	POPJ	P,


SUBTTL INBUF AND OR OUTBUF FOR DEVICE JUST INITED
;EXPECTS:	(B)=RING DATA FROM DATTB. 
;		(C)=CHAN. NUM

SETBFS:	PUSH	P,B		;SAVE DATA
	HLRZS	B		;GET BUFFER SIZE
				;SKIP IF NOT DETERMINED,DO NUMBER/NOT SIZE
	JUMPN	B,SETUP1	;GO SET UP ODD SIZED BUFFERS,EXPAND IF NECESSARY
	LDB	B,[POINT 4,(P),31]	;GET "IN"DATA
	JUMPE	B,CHKOT1	;SEE IF RING SPEC.
	DPB	C,[POINT 4,B,12]
	TLO	B,NINBUF	;SETUP INBUF UUO.
	XCT	B		;EXECUTE INBUF ON CHAN.(LOW) (C)

CHKOT1:	LDB	B,[POINT 4,(P),35]	;GET "OUT" DATA
	JUMPE	B,BFDONE	;SEE IF RING SPEC.
	DPB	C,[POINT 4,B,12]
	TLO	B,NOUBUF	;SET UP OUTBUF UUO
	XCT	B		;EXECUTE OUTBUF

BFDONE:	POP	P,(P)		;PUT STACK BACK IN SYNK.
	JRST	CLRBFZ		;CLEAR BUFSZ.(LOW)

;THE FOLLOWING CODE SETS UP NON-STANDARD SIZE BUFFERS FOR THE DEVICE INITED
;ON CHAN. # FOUND IN AC(C).  CORE IS EXPANDED IF NEEDED.  IF THE
;USER HAS SPECIFIED NUMBER AND SIZE SUCH THAT THE BUFFERS WILL NOT FIT IN
;CORE, THE NUMBER OF BUFFERS IS FIRST CUT TO TWO , THEN ONE.

SETUP1:	TLNE	I,IOF.		;IF OUTPUT
	SUBI	M,3		;MAKE M POINT TO INPUT BUFFER HEADER
	ADDI	B,2		;TOTAL AREA/BUFFER
	PUSH	P,B		;STORE TOTAL SIZE
	EXCH	C,-1(P)		;SAVE CHAN # FOR FUTURE USE
	PUSH	P,C		;DATA ON TOP OF STACK AGAIN
	LDB	C,[POINT 4,(P),31]	;GET # BUFFERS INPUT
	JUMPE	C,.+2		;WAS IT INPUT?
	PUSHJ	P,SETUPB	;YES, SET UP BUFFER RING
	ADDI	M,3		;POINT TO OUTPUT BUFFER HEADER
	LDB	C,[POINT 4,(P),35]	;GET # BUFFERS OUTPUT
	JUMPE 	C,.+2		;NOT OUTPUT
	PUSHJ	P,SETUPB	;YES, SET UP BUFFERS
	SUB	P,[2,,2]	;STACK BACK IN SYNK.
	TLNN	I,IOF.		;OUTPUT?
	SUBI	M,3		;NO, WAS INPUT
	POP	P,C		;RESTORE CHAN
	POPJ	P,

SETUPB:	MOVE	B,.JBFF		;GET JOBFF
	PUSH	P,C		;SAVE NUM BUFFERS
TRYAGN:	IMUL	C,-3(P)		;CALCULATE SPACE NEEDED
	ADD	C,B		;GET HIGEST LOCATION NEEDED
	CAML	C,.JBREL	;WILL IT FIT?
	JRST	GETCOR		;NO, GO GET MORE CORE
GOTCOR:	MOVEM	C,.JBFF		;YES,NOW IT FITS.SET UP NEW JOBFF
	MOVEI	C,2(B)		;PICK UP FIRST DATA WORD ADDRESS
	HRRM	C,1(M)		;STORE IT IN RING HEADER
	MOVEI	C,1(B)		;1ST BUFFER 2ND WD
	TLO	C,(1B0)		;SET USE BIT
	MOVEM	C,(M)		;PUT IN 1ST WD RING HEADER
	HLL	C,-2(P)		;SET UP 2ND WD BUFFER
	MOVE	0,C		;SAVE POINTER
NXTBUF:	SOSG	(P)		;IS THIS LAST BUF TO BE SETUP?
	JRST	LASTBF		;YES,GO SET IT UP
	ADD	0,-3(P)		;NO,CALCULATE 2ND WD NEXT BUFFER
	MOVEM	0,(C)		;STORE IT IN 2ND WD THIS BUFFER
	MOVE	C,0		;
	JRST	NXTBUF		;FIXUP NEW BUFFER

LASTBF:	HRRI	0,1(B)		;SETUP POINTER TO 2ND WD 1ST BUFFER
	MOVEM	0,(C)		;STORE IT IN 2ND WD LAST BUUFER
	POP	P,C		;RESTORE CHAN. #
	MOVE	C,-3(P)		;RESTORE CHAN. #
CLRBFZ:
IFN REENT,<ADDI	C,(LOW)		;DOUBLE INDEXING>
	SETZM	BUFSZ.(C)	;CLEAR BUFFER RING DATA
IFN REENT,<SUBI	C,(LOW)		;BACK AS IT WAS>
	POPJ	P,		;RETURN

;C CONTAINS NEW JOBFF NEEDED

GETCOR:	MOVE	0,C		;SAV AC
	CALLI	0,11		;EXPAND CORE
	JRST	LESCOR		;FAILED
	JRST	GOTCOR		;PASSED

LESCOR:	JUMPLE	0,NOCORE	;FAIL IF NO CORE AVAILABLE
	MOVE	C,(P)		;GET # BUFFERS DESIRED
	SOJLE	C,NOCORE	;TRIED ONE AND FAILED - TOTAL FAILURE
	CAIE	C,1		;IF =1,LEAVE IT ALONE
	MOVEI	C,2		;IF>=2,MAKE IT 2
	MOVEM	C,(P)		;SAVE NUM BUFFERS
	JRST	TRYAGN		;TRYAGAIN

NOCORE:	ERROR	BUFER.		;FATAL ERROR MESSAGE

SUBTTL	SUBROUTINE TO LOOK AT DEVCHR BITS
;IN E AND SET APPROPRIATE FLAGS
;ARGS	E=LH DEVCHR BITS
;VALUES	D=ADDRESS OF DYNDV. TABLE
;	SEVERAL FLAGS SET

FIDLDV:	TLNE	E,DIRBIT	;DECTAPE OR DISK?
	TLO	I,DDF.		;YES
	TLNE	E,LPTBIT!TTYBIT	;LPT OR TTY?
	TLO	N,TTYFL.	;YES,SET LPT OR TTY FLAG
	TLNE	E,TTYBIT		;TTY
	TLO	N,TERMF.
	TLNE	E,CRDBIT	;CARDS I/O?
	TLO	N,CDSFL.	;SET CARD READER/PUNCH FLAG
	TRNE	E,SPLBIT	;IS DEVICE SPOOLING TO DSK?
	TLO	N,SPLFL.	;YES
	TLNN	E,USRTTY	;IS THIS THE USERS TELETYPE ?
	JRST	FIDL1		;NO
	MOVSI	B,(SIXBIT ?TTY?);YES, MOVE TTY INTO DYNDV. TABLE
	MOVEM	C,TTYCH.(LOW)	;SAVE TTY CHAN. NUMBER
	MOVE	D,DVNUM.(LOW)	;GET FORTRAN UNIT NUMBER
IFN REENT,<ADDI	D,(LOW)>
	SETOM	TTYUN.(D)	;SET UNIT IS TTY FLAG
FIDL1:	MOVEI	D,DYNDV.(LOW)	;ADDR. OF DYNAMIC DEVICE TABLE
	SKIPE	RANAC.(LOW)	;MAKE TEST TO SEE IF MODE HAS CHANGED
	JRST	[TRNN	E,DMPBIT
		PJRST	FXMODE
		POPJ	P,]
	TRNN	E,DMPBIT	;SHOULD NOT BE ON
	POPJ	P,
	SETOM	RANAC.(LOW)	;SET TO RANDOM ACCESS
	PUSH	P,A
	MOVE	A,DVNUM.(LOW)	;GET F4 UNIT NUMBER
IFN REENT,<ADDI	A,(LOW)>
	MOVE	A,@FILE1.(A)	;GET CURRENT POSITION
	MOVEM	A,ASVAR.(LOW)	;MAKE THAT THE NEW POSITION
	POP	P,A
	POPJ	P,

GETDV.:	MOVE	0,DVNUM.(LOW)	;RESTORE DEVICE LOGICAL NUMBER
;       CAILE	0,DVTOT.	;LEGAL DEVICE?
;	ERROR	DEVER.		;NO
        CAIG    0,DVTOT.        ;LARGER THAN DEVICE TOTAL NUM :CLC:
        JRST    .+3             ;NO THEN IS LEGAL DEVICE :CLC: 1-25-74
        CAIE    0,NEG1.         ;IS IT THE TTY DEVICE :CLC: 1-25-74
        ERROR   DEVER.          ;NO IT AIN'T SO PUNT :CLC: 1-25-74
	TLNE	I,OPF.		;IF OPEN STATEMENT
	JRST	USEOPN		;THEN  USE OPEN DEVICE
	SKIPGE	RANAC.(LOW)	;IF RANDOM ACCESS
	JRST	USEDSK		;THEN ALWAYS USE DISK
	MOVNI	C,DEVTB.	;CALCULATE ADDR. OF DEVICE NAME
	ADDI	C,1(LOW)
	SKIPG	B,0		;DEVICE NO. NEGATIVE?
IFN REENT,<JRST	[	>
	ADDI	B,DEVND.(C)	;YES,GO TO END OF TABLE
IFN REENT,<JRST	.+2]
	ADDI	B,(LOW)	>
	SKIPE	TTYUN.(B)	;IS THIS UNIT THE TTY
	JRST	USETTY		;YES
	MOVE	B,DEVTB.(B)	;PICK UP DEVICE NAME
	CAMN	B,[SIXBIT /REREAD/]
	JRST	REREAD		;SET UP TO REREAD 
SAVDNM:	SKIPN	E,B		;GET DEV NAME AND
	ERROR	ILRED.		;FAIL IF IT WAS RELEASED.
	TLC	E,'DSK'		;TEST FOR DSK
	TLCN	E,'DSK'		;AS FIRST 3 CHARS.
	TLNE	E,-1-'DSK'	;TEST FOR D OR DS
	JRST	SAVDN2		;NO, USE ENTIRE ENTRY
	TRZ	E,007777	;STRIP OFF CHARS. 5 & 6
	TRNN	E,400000	;CHAR. 4 A LETTER?
	TRZ	E,770000	;NO, STRIP IT TOO
SAVDN2:	MOVEM	E,DEVNAM(LOW)	;SAVE DEVICE FOR INITIALIZATION
	DEVCHR	E,
	CAME	B,[SIXBIT .DSK.] ;HAS DISK BEEN TRIED
	TLNE	E,AVABIT	;IS DEVICE AVAILABLE FOR USE
	POPJ	P,		;YES
USEDSK:	MOVSI	B,(SIXBIT .DSK.) ;NO. USE DISK AS DEVICE
	JRST	USEOTH
USEOPN:	MOVE	B,OPNDEV(LOW)	;GET DEVICE FROM OPEN STATEMENT
USEOTH:	MOVE	E,B
	JRST	SAVDN2
USETTY:	MOVSI	B,(SIXBIT .TTY.)
	JRST	USEOTH

DEVFND:	MOVE	B,DVNUM.(LOW)
	MOVEM	B,FILNUM(LOW)	;SAVE F4 DEVICE NUMBER
        SKIPGE  INPDEV(LOW)     ;TYM  MOVED UP TWO
        PUSHJ   P, CKDVEQ       ;TYM  MOVED UP TWO
	JUMPL	I,.+2		;SKIP ON OUTPUT
	MOVEM	B,RERDN.(LOW)	;SAVE DEV. # FOR REREAD
	MOVEM	0,DEVIC.(LOW)	;SAVE DEVICE NAME
;	SKIPGE	INPDEV(LOW)	;IS THIS AN ASCII INPUT DEVICE ?
;	PUSHJ	P,CKDVEQ	;YES, SEE IF THE SAME AS LAST INPUT DEV.
	HRLZ	M,C		;DEVICE NUMBER
	ASH	M,5		;DEVICE NO. IN AC FIELD
	PUSHJ	P,BUFCA.	;GET HEADER ADDRESS
	HRR	G,D		;ADDR. FOR THIS DEVICE NAME
	MOVEM	G,DNAME(LOW)	;SAVE DEVICE NAME ADDR
	SKIPLE	INPDEV(LOW)	;IS THIS A NEW INPUT DEVICE ?
	PUSHJ	P,SAVPTR	;YES,SAVE NEW POINTER FOR REREAD
	TLNN	N,TTYFL.	;IS THE DEVICE THE TTY OR LPT ?
	PUSHJ	P,JSB		;NO,CHECK FOR CHANGE IN MODE
	JUMPGE I,DVF		;DONT CHECK ON INPUT FOR CHANGE IN I/O
	SKIPG	-3(M)		;HAS AN INPUT BEEN DONE YET?
	JRST	DVF		;NO,CONTINUE
	MOVE	D,(D)		;
	TRNN	D,2		;OUTPUT LAST?
	TLO	N,RDWFL.	;SET READ TO WRITE FLAG
DVF:	TLNE	I,FCF.		;FILE COMMAND?
	JRST	FCM		;YES
	TLNE	I,OPF.		;OPEN STATEMENT
	JRST	OPCM		;YES
	TLNN	I,STPFF.	;SPECIAL TAPE FUNCTION?
	TLNN	I,DDF.		;DSK OR DECTAPE?
	JRST	FTST1
	MOVE	D,C		;YES,GET DEV. NO.
	ASH	D,1		;SET INDEX FOR FILE NAME
	JUMPG	I,.+2		;SKIP ON INPUT
	ADDI	D,1		;INDEX FOR OUTPUT FILE
IFN REENT,<ADDI	D,(LOW)>
	SKIPE	TNAME.(D)	;ANY NAME THERE?
	JRST	FTST1		;FILE NAME ALREADY SET
	PUSH	P,A
	SETZM	TEMP.+4(LOW)	;CLEAR DATE, TIME AND PROTECTION
	MOVE	B,FILNUM(LOW)
IFN REENT,<ADDI	B,(LOW)>
	CAILE	B,DYDVL.(LOW)	;INDEX TOO BIG?
	JRST	FTST5		;YES, USE DEFAULT NAMES
	SKIPE	A,FILE5.(B)	;IS THERE A FILE NAME?
	JRST	SETNAM		;YES, GO PUT IT IN TEMP FOR LOOKUP ETC.
FTST5:	LDB	0,[POINT 6,FILNUM(LOW),35]    ;NO, GET POSITIVE F4 DEVICE NO
	IDIVI	0,12		;CONVERT TO 6BIT
	LSH	0,6
	OR	0,1
	IOR	0,FORZRO	;SIXBIT FOR00
	LSH	0,6
	MOVEM	0,TEMP.+2(LOW)
	MOVSI	A,444164	;SIXBIT 'DAT'
	MOVEM	A,TEMP.+3(LOW)	;SET 'DAT' UP FOR EXTENSION
	CAILE	B,DYDVL.(LOW)	;
	JRST	DEFALT
SETPPN:	SKIPE	A,FILE3.(B)	;IS THERE A PPN FOR LOOKUPS OR ENTER?
	MOVEM	A,TEMP.+1(LOW)	;YES, SET IT UP
DEFALT:	POP	P,A		;NO,FORGET IT
	PUSHJ	P,FCM1.		;DO LOOKUP OR ENTER
FTST1:	TLNE	N,RDWFL.	;TRYING TO READ THEN WRITE?
	JRST	RDWR		;YES,GO SET UP BUFFERS ETC
FTST0:	JUMPGE	I,FTST2		;OUTPUT?
	TLNN	N,TTYFL.	;AND NOT THE TERMINAL
	PUSHJ	P,CLOSI.	;YES,DO INPUT CLOSE FOR LAST READ
	SKIPG	(M)		;DUMMY OUTPUT NEC. ?
	PUSHJ	P,OUTT.		;YES
				;IT INTO THE OUTPUT BUFFER
FTST2:	TLNE	I,NLIOF.	;NAMELIST?
	JRST	NAMEL		;YES
	TLNE	I,STPFF.	;SPECIAL TAPE FUNCTION?
	JRST	TPFCN.		;YES,GO TO FUNCTION DISPATCH
	SKIPL	RANAC.(LOW)	;RANDOM FILE
	JRST	FTST3		;NO
	MOVE	C,FILNUM(LOW)	;F4 UNIT NUMBER
IFN REENT,<ADDI	C,(LOW)>
	SOSGE	ASVAR.(LOW)	;CONVERT FILE POSITION TO 0-INDEXING
	ERROR	ILLPS.		;ILLEGAL POSITION
	SKIPE	C,FILE2.(C)	;IS IT A FIXED LENGTH RECORD
	IMULM	C,ASVAR.(LOW)	;YES. CONVERT TO WORD OR CHAR COUNT
FTST3:	TLNN	I,FIOF.		;FORMAT?
	JRST	BINWR.		;NO,GO TO BINARY READ & WRITE
	TLNN	N,TTYFL.	;TTY OR LPT?
	JRST	FTST4		;NOT TTY OR LPT SO USE LINE BUFFER
	TLNN	N,SPLFL.	;IF SPOOLING USE LINE BUFFER
	JRST	IORET		;YES
FTST4:	LDB	C,[POINT 9,@(M),17];PICK UP BUFFER WORD-SIZE
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	MOVEI	C,201		;DSK  BUFFER SIZE
	SUBI	C,LINWDS+1
	JUMPL	C,IORET		;DON'T USE LINE BUFFER IF
         			;DEVICE BUFFER SIZE TOO SMALL
	HRRZM	M,HDRADD(LOW)	;ADDRESS OF REAL BUFFER HEADER
	JUMPGE	I,IORET		;ON INPUT,DON'T SET UP LINE BUFFER
	PUSHJ	P,SETOU.	;SET OUTPUT BIT
	MOVEI	C,LINBUF-2(LOW)	;INITIALIZE LINE BUFFER HEADER
	MOVEM	C,LINHDR(LOW)
	MOVE	C,LBPTR(LOW)	;POINTER TO LINE BUFFER
	MOVEM	C,LINHDR+1(LOW)
	MOVEI	C,LINCH		;ITEM COUNT
	MOVEM	C,LINHDR+2(LOW)
	HRRI	M,LINHDR(LOW)	;HEADER ADDRESS
	LDB	C,[POINT 4,M,12]	;GET CHAN #
IFN REENT,<ADDI C,(LOW)	>
	SETOM	PAKFL.(C)	;SET PACK FLAG ON CHANNEL
	JRST	IORET		;GO TO FORMAT SCAN
;SET UP PROJ,PROG NO,  FILENAME,  EXT FOR I/O.

SETNAM:	MOVEM	A,TEMP.+2(LOW)	;SET UP DESIRED FILENAME
	SKIPE	A,FILE4.(B)	;GET EXT IF ANY & SET IT UP
	HLLZM	A,TEMP.+3(LOW)
	DPB	A,[POINT 9,TEMP.+4(LOW),8]	;PROTECTION CODE
	JRST	SETPPN		;SET UP PPN IF ANY


;CHECK TO SEE IF CURRENT INPUT DEVICE IS THE SAME AS LAST ONE
CKDVEQ:	SKIPN	INPDV.(LOW)	;IS THIS THE FIRST INPUT DEV. ?
        JRST    CKDVQ1          ;YES,THEREFORE NOT SAME DEVICE (TYM:DMQ)
	CAMN	0,INPDV.(LOW)	;ARE THE TWO DEVICES THE SAME ?
        JRST    CKDVQ2          ;TYM  NEED TO TEST MORE
;	POPJ	P,		;YES, RETURN
CKDVQ1: MOVEM   0,INPDV.(LOW)   ;NO,MOVE NEW DEV. INTO HOLDING AREA
	XORM	0,INPDEV(LOW)	;SET UP FLAG TO SAY THEY ARE DIFF.
	POPJ	P,		;RETURN
CKDVQ2: CAMN    B, RERDN.(LOW)  ;TYM  TEST AGAINST LAST VALUE OF
                                ;TYM  REREAD F4 DEV NUMBER
        POPJ    P,              ;TYM  IT IS ALSO THE SAME
        JRST    CKDVQ1          ;TYM  NOT THE SAME, ACT AS DIFF. DEV.

;SAVE THE CURRENT POINTER AND ITEM COUNT FOR REREAD

SAVPTR:	HRRZ	0,(M)		;GET BUFFER HEADER
	MOVEM	0,RPTR2(LOW)	;SAVE IN RPTR2
	MOVE	0,1(M)		;GET POINTER
	SUBM	0,RPTR2(LOW)	;ADJUST RPTR2
	MOVE	0,2(M)		;GET ITEM COUNT
	MOVEM	0,RCNT2(LOW)	;SAVE IN RCNT2
	PUSH	P,C
	LDB	C,[POINT 4,M,12]	;CHANNEL NUMBER
IFN REENT,<ADDI	C,(LOW)>
	MOVE	0,INCNT.(C)	;BLOCK NUMBER
	MOVEM	0,RINC2(LOW)
	POP	P,C
	POPJ	P,		;RETURN
;RESET STATUS FOR CURRENT DEVICE

JSB:	TLNN	I,FIOF.		;IS THE MODE ASCII ?
	POPJ	P,		;NO, RETURN
	LDB	0,[POINT 6,1(M),11];YES, GET POINTER SIZE
	CAIE	0,44		;IS THE POINTER BINARY ?
	POPJ	P,		;NO,RETURN
	MOVEI	0,0700		;YES,SET UP ASCII POINTER
	HRLM	0,1(M)		;PUT NEW POINTER INTO BUFFER HEADER
	MOVE 	0,2(M)		;ADJUST WORD COUNT
	IMULI	0,5		;FOR ASCII MODE
	MOVEM	0,2(M)		;REPLACE WITH NEW COUNT
	POPJ	P,		;RETURN WITH MODE CHANGED

;SET BUFFER HEADER ADDRESS FOR CURRENT DEVICE

BUFCA.:	LDB	0,[POINT 4,M,12];DEVICE NUMBER
	IMULI	0,6		;SIX WORDS FOR EACH DEVICE
	ADDI	0,BUFHD.(LOW)	;BASE ADDRESS
	HRLS	0		;IN BOTH HALVES
	HLL	G,0		;ADDRESS OF INPUT BUFFER HEADER
	SKIPL	RANAC.(LOW)	;ONLY ONE BUFFER IF RANDOM ACCESS
	ADD	0,[XWD 3,0]	;OUTPUT ADDR.,INPUT ADDR.
	HLR	M,0		;HEADER ADDRESS
	JUMPL	I,CPOPJ		;SKIP ON OUTPUT
	HRR	M,0		;HEADER ADDRESS
	POPJ	P,

;HERE TO SET UP DUMP MODE BUFFER FOR RANDOM ACCESS

SNGLBF:	PUSH	P,B		;SAVE FOR FNDSPC
	PUSHJ	P,FNDSPC	;CAN ANY SPACE BE REUSED
	JRST	.+2		;NO. ALLOCATE NEW SPACE
	JRST	SNGLB1		;LOCATION OF BUFFER REUSED
	HRRZ	0,.JBFF		;TOP OF FREE CORE
	ADDI	0,202		;BUFFER SPACE
	CAMLE	0,.JBREL	;WILL IT FIT
	PUSHJ	P,XPAND		;NO
	ADDI	0,1		;POINT TO FIRST FREE WORD
	EXCH	0,.JBFF		;ALLOCATE SPACE
	MOVE	B,0		;MOVE BUFFER ADDRESS START
SNGLB1:	ADDI	B,1		;POINT TO SECOND WORD OF BUFFER
	HRRZM	B,(M)		;STORE BUFFER POINTER
	HRLI	B,201		;SET UP BUFFER SIZE FOR ANYONE WHO NEEDS IT
	MOVEM	B,(B)		;MAKE BUFFER POINT TO SELF
	SETZM	-1(B)		;ZERO STATUS WORD
	ADDI	B,1		;POINT TO WORD BEFORE DATA
	MOVSI	B,(POINT 7,,35)	;ASSUME ASCII
	TRNE	I,17		;WAS IT
	MOVSI	B,(POINT 36,,35)	;NO, BINARY
	MOVEM	B,1(M)		;STORE BYTE POINTER
	SETZM	2(M)		;CLEAR WORD COUNT
        POP	P,B		;RESTORE REGISTER
	POPJ	P,		;RETURN

;HERE TO EXPAND CORE

XPAND:	PUSH	P,A		;SAVE AN AC
	MOVE	A,0		;CORE NEEDED
	CORE	A,		;TRY
	ERROR	BUFER.		;FAILED, PRINT MESSAGE
	POP	P,A
	POPJ	P,

;HERE TO CHANGE MODE FOR RANDOM ACCESS/SEQUENTIAL CHANGE

FXMODE:	TLNE	I,STPFF.	;AN MTOP. UUO?
	POPJ	P,		;YES, RANAC IS NEVER SETUP
	HRLZ	M,C		;DEVICE NUMBER
	ASH	M,5		;PUT IN ACC FIELD
	PUSHJ	P,BUFCA.	;GET BUFFER HEADER INTO M (RH)
	MOVE	0,G		; *356* BUFFER HEADER
	HRR	0,C		; *356* DEVICE NUMBER
	ADDI	0,DYNDV.(LOW)	; *356* DEVICE TABLE PLUS OFFSET
	MOVEM	0,DNAME(LOW)	; *356* SET UP DNAME (EXPECTED LATER)
IFN REENT,<ADDI	C,(LOW)>
	SKIPN	RANAC.(LOW)	;DO WE WANT DUMP MODE NOW?
	JRST	FX2ASC		;NO
	PUSHJ	P,CLOS.		;OUTPUT LAST BLOCK IF NEED BE
	HLR	M,G		;PUT INPUT BUFFER IN M
	PUSH	P,A		;SAVE SOME ACCS
	PUSH	P,B
	PUSH	P,D
	PUSHJ	P,LNKBUF	;LINK THE BUFFERS
	POP	P,D
	POP	P,B
	POP	P,A
	HLLZ	0,M		;GET CHAN. #
	HRRI	0,16		;DUMP MODE
	TLO	0,NSETST	;FORM UUO
	XCT	0		;DO IT
	MOVE	0,[1,,203]
        MOVEM	0,BUFSZ.(C)	;SIGNAL NO BUFFERS
	PUSHJ	P,SNGLBF	;GET A DUMP MODE BUFFER
	JRST	FXDRET		;RETURN

	JUMPGE	I,.+2		;SKIP IF INPUT
	SUBI	M,3		;USE INPUT HEADER FOR OUTPUT
FX2ASC:	SETZM	BLOCK.(LOW)	;CLEAR WANTED BLOCK. #
	SKIPGE	RANDV.(C)	;ANYTHING TO GO OUT?
	PUSHJ	P,ROUTP.	;YES, DUMP LAST BLOCK
	HLLZ	0,M		;GET CHAN. #
	TLO	0,NSETST	;SETSTS UUO 
	XCT	0		;CHANGE MODE TO ASCII
	PUSHJ	P,LNKBUF	;RELEASE BUFFERS
	MOVEI	0,INIT.(LOW)	;DEVICE NAME
	DEVSIZ	0,		;GET BUFFER SIZE
	  SETO	0,		;FAILED
	MOVEM	0,BUFSZ.(C)	;STORE INFO.
FXDRET:	SETZM	RANDV.(C)	;CLEAR INCORE BLOCK
	MOVE	E,DYNCH.(C)	;GET DEVCHR WORD
	TRC	E,DMPBIT	;PUT BIT RIGHT WAY 
	MOVEM	E,DYNCH.(C)	;IN TABLE
IFN REENT,<SUBI	C,(LOW)>
	JUMPGE	I,CPOPJ		;INPUT?
	SKIPN	RANAC.(LOW)	;SAME BUFFER IF RANDOM ACCESS
	ADDI	M,3		;NO
	POPJ	P,		;RETURN

SUBTTL	INF. AND OUT. UUOS

OUTF:	MOVSI	I,IOF.!FCF.	;OUTPUT,FILE COMMAND,ASCII
	JRST	INF+1		;GET NAME AND DO INIT

INF:	MOVSI	I,FCF.		;FILE COMMAND,ASCII
	MOVE	0,SAVEAC(LOW)	;**V31/01**
	HRRZM	0,FNM.(LOW)	;SAVE FILE NAME ADDRESS
	LDB	0,[POINT 4,0,12]	;GET TYPE CODE
	MOVEI	B,777777	;ASSUME HOLLERITH
	CAIGE	0,5		;IS IT ONE WORD LONG
	MOVEI	B,1*5		;YES
	CAILE	0,5		;IS IT TWO WORDS LONG
	MOVEI	B,2*5		;YES
	MOVEM	B,FNMCNT(LOW)	;SAVE MAXIMUM FILE NAME SIZE
	PUSHJ	P,FLNAM		;**V31/01**
	JRST	NFI		;**V31/01**

SUBTTL	REREAD UUO--FORMAT SIMILAR TO READ

REREAD:	TLO	I,RRF.		;REREAD , ASCII
	TLO	N,RRDFL.	;SET REREAD USE FLAG ON
	MOVE	B,RERDN.(LOW)	;PICK UP LAST INPUT DEVICE NUMBER
	MOVEM	B,DVNUM.(LOW)	;MAKE IT THIS DEVICE NUMBER
	MOVE	B,RERDV.(LOW)	;PICK UP LAST INPUT DEVICE NAME
	JRST	SAVDNM		;RETURN

SUBTTL	NAMELIST (NLIN.,NLOUT.) UUO'S

NLI:	MOVSI	I,NLIOF.	;NAMELIST
	JRST	NFI		;INITIALIZE DEVICE

NLO:	MOVSI	I,IOF.!NLIOF.	;OUTPUT,NAMELIST,ASCII
	JRST	NFI

;NAMELIST SET UP

NAMEL:	LDB	A,PTRU		;AC FIELD OF NAMELIST UUO
IFN REENT,<ADDI	A,(LOW)>
	MOVEI	A,@SAVEAC(A)	;POINTER TO NAMELIST TABLE
	PUSHJ	P,NMLST.	;GO OFF TO NAMELIST ROUTINE
	JRST	IORTR.		;RETURN TO USER

SUBTTL	BINARY TAPE READ(RTB) / WRITE(WTB)  UUO
;DEVICE NO. IN RIGHT HALF OF UUO


WTB:	SKIPA	I,[XWD IOF.,14]	;OUTPUT BINARY
RTB:	MOVEI	I,14		;INPUT BINARY
	SKIPL	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	NFI		;NO, SEQUENTIAL I/O
	MOVE	0,RECNO.(LOW)	;YES SET UP ASSOCIATED VARIABLE
	MOVEM	0,ASVAR.(LOW)	;
	TLZ	N,FKNFL.	;CLEAR ASCII RANDOM ACCESS FLAG
	JRST	NFI		;DO INITIALIZATION

SUBTTL	SPECIAL TAPE FUNCTIONS
;DEVICE NO. IN RIGHT HALF OF UUO
;FUNCTION IN AC FIELD OF UUO

RRBBW:	LDB	I,PTRU		;AC FIELD OF UUO
	TRO	I,STPFF.	;SPECIAL FUNCTION
	HRLZS	I		;SWAP AND ZERO RH FOR ASCII
	JRST	NFI		;DO INITIALIZATION

SUBTTL	ENCODE/DECODE

;++ ENCODE COMES HERE

ENC:	HRLI	I,IOF.!FIOF.	;++ FORMAT, OUTPUT.
	MOVEI	M,ENCHDR(LOW)	;++ SET UP ENCODE BUFFER HEADER
	PUSHJ	P,DECENC	;++ SET UP HEADER WORDS
	JRST	GETAC		;++ GO TO FORMAT SCAN

;++ DECODE COMES HERE

DEC:	HRLI	I,FIOF.		;++ INPUT ASCII
	AOS	INIFLG(LOW)	;++ ??
	MOVEI	M,DECHDR(LOW)	;++ SET UP DECODE BUFFER HDR
	PUSHJ	P,DECENC	;++SET UP HEADER WORDS
	XCT	IIB.		;++ MOVE POINTER UP ONE
	JRST	GETAC		;++ GO TO FORMAT SCAN

DECENC:	TLO	N,ENCFL.	;++ SET ENCODE/DECODE FLAG
	HRRZM	A,2(M)		;++ GET # CHARS PUT IN HDR
	HRLI	0,700		;++ SET UP HEADER
	HRR	0,VADDR.(LOW)	;++ GET ADR OF 1ST WORD
	MOVEM	0,1(M)		;++ SET UP BYTE PTR
	SOS	1(M)		;++POINT TO WORD BEFORE DATA FOR ENC.
	POPJ	P,		;++ RETURN

EDMESS:	ASCIZ /
ENCODE - DECODE ERROR!
/
EDERRM:	TTCALL	3,EDMESS	;++ TYPE OUT ERROR MESSAGE
	SETZM	EDERR(LOW)	;++ CLEAR ERROR FLAG
	JRST	EDFIN		;++ GO TO FIN UUO DIRECTLY SKIPPING OTHERS



SUBTTL	POSITION STATEMENT

POSS:	MOVSI	I,POSS.		;SET POSITION STATEMENT FLAG
	SETOM	RANAC.(LOW)	;IS A RANDOM FILE OPERATION
	LDB	0,PTRU		;GET ACC FIELD OF UUO
	ADDI	0,SAVEAC(LOW)	;ADDRESS IN AC SAVE BLOCK
	MOVE	0,@0		;GET NEW POSITION
	MOVEM	0,ASVAR.(LOW)	;NEW FILE POSITION
	JRST	NFI		;GO GET CHANNEL AND POSITION

SUBTTL	OPEN STATEMENT

FNM:	HRRZ	B,A		;GET ADDRESS OF UUO
	CAIGE	B,20		;IS FILE NAME IN REGISTER
	ADDI	B,SAVEAC(LOW)	;YES. REFERENCE REGISTER SAVE BLOCK
	MOVEM	B,FNM.(LOW)	;SAVE ADDRESS OF FILE NAME
	LDB	B,PTRU		;GET VARIABLE TYPE CODE
	MOVEI	C,777777	;ASSUME HOLLERITH. INFINITE COUNT
	CAIGE	B,5		;IS IT A ONE WORD FILE NAME
	MOVEI	C,1*5		;YES. FIVE CHARACTERS
	CAILE	B,5		;IS IT A TWO WORD FILE NAME
	MOVEI	C,2*5		;YES. TEN CHARACTERS
	MOVEM	C,FNMCNT(LOW)	;SAVE COUNT FOR FILE NAME SCAN
	JRST	FI.		;RETURN TO PROGRAM

FLIST:	HRRZ	B,A		;ADDRESS OF START OF FILE NAME
	MOVEM	B,FNM.(LOW)	;SAVE FOR SCAN OF FILE NAME
	HRRZ	B,@UUOH.(LOW)	;ARRAY LENGTH
	AOS	@UUOH.(LOW)	;SKIP ON EXIT OVER ARRAY LENGTH
	LDB	C,PTRU		;GET VARIABLE TYPE
	CAIL	C,6		;TWO WORD ENTRIES
	ASH	B,1		;YES. DOUBLE ARRAY LENGTH
	IMULI	B,5		;COMPUTE NUMBER OF CHARACTERS
	MOVEM	B,FNMCNT(LOW)	;SAVE FOR SCAN
	JRST	FI.		;RETURN TO PROGRAM

OPENF:	LDB	0,PTRU		;GET AC FIELD
	ADDI	0,SAVEAC(LOW)
	MOVE	0,@0		;GET REGISTER ZERO
	MOVSI	I,FIOF.		;ASSUME SYMBOLIC FILE
	TRNE	0,1		;IS IT SYMBOLIC
	MOVEI	I,14		;NO. BINARY
	TLNE	0,5		;OUTPUT FILE
	TLO	I,IOF.		;YES
	TLNE	0,6		;RANDOM FILE
	SETOM	RANAC.(LOW)	;YES
	TLO	I,OPF.		;SET OPEN STATEMENT FLAG
        MOVE    0,DFPPN.(LOW)   ;GET DEFAULT PPN
        MOVEM   0,TEMP.+1(LOW)  ;USER NAME
	MOVSI	0,(SIXBIT .DSK.)	;ASSUME DEVICE IS DISK
	MOVEM	0,OPNDEV(LOW)
	TLZ	I,OPDV.		;ASSUME NO DEVICE IN OPEN STRING
	PUSHJ	P,FLNAM		;GET FILE NAME
	TLZ	I,OPDV.		;CLEAR DEVICE IN OPEN STRING BIT
	JRST	NFI		;GET CHANNEL

OPCM:	MOVE	0,RLEN.(LOW)	;RECORD LENGTH
	MOVE	A,FILNUM(LOW)	;F4 UNIT NUMBER
IFN REENT,<ADDI	A,(LOW)>
	MOVEM	0,FILE2.(A)	;SAVE RECORD LENGTH
	MOVEI	0,FILPS.(A)	;LOCATION OF POSITION WORD
	MOVEM	0,FILE1.(A)	;SAVE TO SAVE NEW POSITION
	MOVEI	0,1		;START FILE AT POSITION 1
	MOVEM	0,FILPS.(A)	;STORE STARTING POSITION
	SETZM	ASVAR.(LOW)	;INITIALIZE POSITION
	PUSHJ	P,FCM1.		;OPEN FILE
        SKIPN   USRNAM(LOW)
        JRST    OPCM12
        MOVE    A,USRNAM(LOW)
        MOVEM   A,PRVUSN(LOW)
        MOVE    A,USRNAM+1(LOW)
        MOVEM   A,PRVUSN+1(LOW)
        MOVE    A,TEMP.+1(LOW)
        MOVEM   A,PRVPPN(LOW)
OPCM12: SKIPL	RANAC.(LOW)	;RANDOM FILE
	JRST	IORTR.		;RETURN TO PROGRAM
	SKIPE	A,TEMP.+5(LOW)	;YES. IS FILE SIZE NONZERO
	TLNN	I,FIOF.		;AND IS IT A SYMBOLIC FILE
	JRST	OPCM11		;NO. COUNT OK
	SOJ	A,		;CONVERT COUNT TO 0-INDEX
	IDIVI	A,200		;DETERMINE BLOCK NUMBER
	AOJ	A,		;BLOCK # IS 1-INDEXED
	MOVEM	A,BLOCK.(LOW)	;SAVE BLOCK
	PUSHJ	P,RINP.		;READ LAST BLOCK OF FILE
	ADD	B,1(M)		;BYTE POINTER TO LAST WORD OF BLOCK
	MOVE	A,TEMP.+5(LOW)	;GET WORD COUNT
	SOJ	A,		;REMOVE LAST WORD
	IMULI	A,5		;CONVERT TO CHAR COUNT
	MOVEI	C,5		;LOOK AT CHARS IN LAST WORD
OPCM10:	ILDB	0,B		;GET NEXT CHAR
	JUMPE	0,OPCM11	;TERMINATE ON NULL
	AOJ	A,		;INCREMENT CHAR COUNT
	SOJG	C,OPCM10	;ONLY CHECK FIVE CHARS
OPCM11:	LDB	C,[POINT 4,M,12]	;GET CHANNEL NUMBER
IFN REENT,<ADDI	C,(LOW)>
	SETZM	RANDV.(C)	;CLEAR CURRENT BLOCK
	MOVE	D,A		;GET FILE SIZE IN ELEMENTS (WORDS OR CHARACTERS)
	MOVEI	B,200		;IF BINARY, 200 WORDS/BLOCK
	TLNE	I,FIOF.		;IS IT SYMBOLIC
	MOVEI	B,5*200		;YES. 5*200 CHARACTERS/BLOCK
	IDIV	D,B		;GET BLOCK NUMBER
	AOJ	D,		;BLOCK NUMBERS START FROM 1
	MOVEM	D,RLBNO(C)	;SAVE BLOCK NUMBER OF LAST BLOCK
	MOVEM	E,RLBSIZ(C)	;SAVE NUMBER OF ELEMENTS IN LAST BLOCK
	MOVE	C,DVNUM.(LOW)	;F4 UNIT NUMBER
IFN REENT,<ADDI	C,(LOW)>
	SKIPE	B,FILE2.(C)	;IS IT A FIXED LENGTH RECORD
	IDIV	A,B		;YES. CONVERT TO # OF RECORDS
	MOVEM	A,FILSZ.(C)	;STORE FILE SIZE
	JRST	IORTR.		;RETURN TO PROGRAM

FLNAM:	PUSH	P,A		;SAVE REGISTER
	MOVE	B,FNM.(LOW)	;ADDRESS OF FILE NAME
	HRLI	B,(POINT 7)	;POINT TO CHAR BEFORE FIRST
        SETZM   USRNAM(LOW)     ;SET USER NAME TO NULLS
        SETZM   USRNAM+1(LOW)     ;SET USER NAME TO NULLS
	PUSHJ	P,FNMNBK	;GET FIRST NON BLANK
	JRST	OPCME		;ERROR. EMPTY FILE NAME
	CAIE	0,"("-40	;IS THERE A USER NAME BEFORE FILE NAME
	JRST	OPCM3		;NO
	TLNN	I,OPF.		;OPEN STATEMENT
	JRST	OPCME		;NO. DO NOT ALLOW USER NAME
	HRLI	D,(POINT 6)	;POINTER FOR SIXBIT USER NAME
	MOVEI	A,14		;ONLY ALLOW 12 CHARACTERS IN USER NAME
OPCM1:	PUSHJ	P,FNMCHR	;GET NEXT CHAR OF USER NAME
	JRST	OPCME		;PREMATURE TERMINATION. ERROR
	CAIN	0,")"-40	;IS IT THE END OF THE USER NAME
	JRST	OPCM1A		;YES
	SOJL	A,OPCM1		;IGNORE IF MORE THAN 12 CHARS
	IDPB	0,D		;STORE CONVERTED CHAR
	JRST	OPCM1		;GET NEXT CHAR
OPCM1A: MOVE    D,USRNAM(LOW)
        CAME    D,PRVUSN(LOW)
        JRST    OPCM1B
        MOVE    D,USRNAM+1(LOW)
        CAME    D,PRVUSN+1(LOW)
        JRST    OPCM1B
        MOVE    D,PRVPPN(LOW)
        MOVEM   D,TEMP.+1(LOW)
        JRST    OPCM2
OPCM1B: MOVEI   D,USRNAM(LOW)
        MOVEM   D,TEMP.+1(LOW)
OPCM2:	PUSHJ	P,FNMNBK	;GET FIRST NONBLANK
	JRST	[TLNE I,OPDV.	;HAS DEVICE BEEN SPECIFIED
		JRST OPCM9	;YES. FILE NAME NOT REQUIRED
		JRST OPCME]	;ERROR. EMPTY FILE NAME
OPCM3:	SETZM	TEMP.+2(LOW)	;SET FILE NAME TO NULLS
	SETZM	TEMP.+3(LOW)	;SET EXTENTION TO NULLS
	MOVEI	D,TEMP.+2(LOW)	;ADDRESS OF FILE NAME WORD
	HRLI	D,(POINT 6)	;MAKE IT A SIXBIT POINTER
	MOVEI	A,6		;LIMIT FILE NAME TO 6 CHARS
OPCM4:	CAIN	0,"."-40	;IS IT THE BEGINNING OF AN EXTENSION
	JRST	OPCM5		;YES
	TLNE	I,OPF.		;OPEN STATEMENT
	CAIE	0,":"-40	;DEVICE NAME
	JRST	OPCM41		;BOTH NOT TRUE. NO DEVICE NAME
	MOVE	0,TEMP.+2(LOW)	;GET DEVICE NAME
	JUMPE	0,OPCME		;NULL DEVICE NAME
	MOVEM	0,OPNDEV(LOW)	;SAVE AS OPEN DEVICE
	TLO	I,OPDV.		;INDICATE DEVICE IN OPEN STRING
	JRST	OPCM2		;GET FILE NAME
OPCM41:	JUMPE	0,OPCM9		;TERMINATE ON BLANK
	PUSHJ	P,FNMCHK	;CHECK FOR ALLOWED CHARACTERS
	SOSL	A		;IGNORE IF MORE THAN SIX CHARS
	IDPB	0,D		;STORE CHAR IN FILE NAME
	PUSHJ	P,FNMCHR	;GET NEXT CHAR OF FILE NAME
	JRST	OPCM9		;END OF FILE NAME
	JRST	OPCM4		;GO GET NEXT CHAR
OPCM5:	MOVEI	D,TEMP.+3(LOW)	;EXTENTION WORD ADDRESS
	HRLI	D,(POINT 6)	;MAKE A SIXBIT POINTER
	MOVEI	A,3		;LIMIT EXTENTION TO THREE CHARACTERS
OPCM6:	PUSHJ	P,FNMCHR	;GET NEXT CHAR
	JRST	OPCM9		;END OF FILE NAME
	JUMPE	0,OPCM9		;TERMINATE ON A BLANK
        SOJL    A, OPCM9        ;TYM CHECK FOR MORE THAN 3 CHARS
                                ;TYM INTERCHANGED ORDER WITH 
                                ;TYM .+1
	PUSHJ	P,FNMCHK	;CHECK FOR ALLOWED CHARACTERS
;	SOJL	A,OPCM9		;TERMINATE IF MORE THAN THREE CHARS
	IDPB	0,D		;STORE CHAR OF EXTENSION
	JRST	OPCM6		;GO GET NEXT CHAR
OPCM9:	POP	P,A		;RESTORE REGISTER
	POPJ	P,

FNMCHK:	CAIL	0,"0"-40	;IS CHAR<"0"
	CAILE	0,"Z"-40	;OR IS CHAR>"Z"
	JRST	OPCME		;YES. ILLEGAL CHAR
	CAILE	0,"9"-40	;IS CHAR<="9" (HENCE A DIGIT)
	CAIL	0,"A"-40	;OR IS CHAR>="A" (HENCE A LETTER)
	POPJ	P,		;YES. LEGAL CHAR
OPCME:	TLNE	I,OPF.		;OPEN STATEMENT
	SKIPN	ERR.(LOW)	;ERROR SWITCH SET
	ERROR	ILLFN.		;ILLEGAL FILE NAME
	JRST	FI.

FNMNBK:	PUSHJ	P,FNMCHR	;GET NEXT FILE NAME CHAR
	POPJ	P,		;NO MORE CHARS
	JUMPE	0,FNMNBK	;IGNORE BLANKS
	AOS	(P)		;SKIP RETURN
	POPJ	P,

FNMCHR:	SOSGE	FNMCNT(LOW)	;ANYMORE CHARS IN FILE NAME
	POPJ	P,		;NO. TERMINATE FILE NAME
	ILDB	0,B		;GET NEXT CHAR
	JUMPE	0,CPOPJ		;TERMINATE ON NULL
	SUBI	0,40		;CONVERT TO SIXBIT
	JUMPL	0,FNMCHR		;IGNORE CONTROL CHARS
	AOS	(P)		;SKIP RETURN
	POPJ	P,


SUBTTL	DO LOOKUP AND ENTER FOR FILE NAMES ON TAPE.
;DEVICE NO. IN ACZ AND FILE NAME IN TEMP

FCM:	PUSHJ	P,CLOSI.	;DO INPUT CLOSE ON DEVICE
	PUSH	P,D		;JUST TO BE SAFE
	LDB	D,[POINT 4,M,12] ;GET CHANNEL
IFN REENT,<ADDI	D,(LOW)>
	SETZM	PAKFL.(D)	;ZERO FLAG FOR THIS CHANNEL
	POP	P,D		;RESTORE D
	SKIPE	TEMP.+3(LOW)
	JRST	.+3
	MOVSI	0,(SIXBIT /DAT/)
	MOVEM	0,TEMP.+3(LOW)	;SET EXTENSION
	PUSHJ	P,FCM1.		;DO LOOKUP OR ENTER
	JRST	FI.		;RETURN



FCM1.:	MOVEI	0,5		;FIVE WORDS IN LOOKUP/ENTER BLOCK
	MOVEM	0,TEMP.(LOW)
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	RFCM		;YES, USE UPDATE MODE
FCM2:	HLLZ	0,TEMP.+3(LOW)	;GET EXTENSION
	MOVEM	0,INIT.+1(LOW)	;SAVE FOR ERROR TYPEOUT
	MOVE	0,TEMP.+2(LOW)	;GET FILE NAME
	ASH	C,1		;SET INDEX FOR LOC. OF NAME
IFN REENT,<ADDI	C,(LOW)>
	JUMPL	I,OENTER	;JUMP ON OUTPUT
	PUSHJ	P,CLOS.		;DO CLOSE BEFORE LOOKUP
	MOVE	0,TEMP.+2(LOW)	;INPUT,GET FILE NAME
	MOVEM	0,TNAME.(C)	;SAVE THE NAME
	MOVE	0,[LOOKUP 0,TEMP.(LOW)]
IFN REENT,<SUBI	C,(LOW)>
	DPB	C,[POINT 5,0,13];DEPOSIT CHAN. NO.
	XCT	0		;DO LOOKUP
	JRST	RETRY		;DO ANOTHER LOOKUP WITHOUT THE EXT.
	POPJ	P,

OENTER:	MOVEM	0,TNAME.+1(C)	;SAVE NAME
IFN REENT,<SUBI	C,(LOW)>
	MOVE	0,[ENTER 0,TEMP.(LOW)]
	DPB	C,[POINT 5,0,13];   CHAN. NO.
	XCT	0		;DO ENTER
	JRST	FCM3		;DIRECTORY FULL
	POPJ	P,

FCM3:	TLNE	I,OPF.		;IS AN OPEN STATEMENT BEING EXECUTED
	SKIPN	ERR.(LOW)	;AND IS AN ERROR EXIT SET
	ERROR	NOROM.		;NO. TAKE SYSTEM ERROR EXIT
	ASH	C,-1		;RESTORE CHANNEL NUMBER
	TLO	N,RELFL.	;SET TO RELEASE CHANNEL
	JRST	OPNABT		;GO RELEASE CHANNEL AND RETURN TO USER


;HERE TO ENTER UPDATE MODE
;LOOKUP FOLLOWED BY ENTER
;IF INPUT THEN LOOKUP MUST SUCCEDE

RFCM:	JUMPGE	I,RFCMO		;JUST DO LOOKUP/ENTER,DON'T CREATE NEW FILE(ENTER)
	TLZ	I,IOF.		;SET INPUT FLG
	TLO	N,FKNFL.	;FORCE LOOKUP/ENTER. CREATE NEW FILE IF LOOKUP FAILS
RFCMO:	PUSH	P,TEMP.+4(LOW)	;SAVE PROTECTION
	PUSH	P,C		;SAV AC
	PUSHJ	P,FCM2		;DO LOOKUP
	POP	P,C		;RESTORE AC
	POP	P,TEMP.+4(LOW)	;RESTORE PROTECTION
	TLNN	N,FKNFL.	;NEED ENTER FOR OUTPUT?
	POPJ	P,		;NO, ONLY UPDATE IF REALLY NEEDED
	TLO	I,IOF.		;SET OUTPUT FLG
	PUSHJ	P,FCM2		;DO ENTER
	TLZN	N,FKNFL.	;LOOKUP DONE FOR OUTPUT?
	TLZ	I,IOF.		;NO, ENTER FOR INPUT.  RESET INPUT FLAG
	POPJ	P,		;RETURN

;DO ANOTHER LOOKUP ON DECTAPE OR DISC---THIS TIME WITHOUT
;EXTENSION "DAT" .

RETRY:	TLNN	N,FKNFL.	;IS THIS A LOOKUP FOR AN OUTPUT FILE?
	JRST	RETRY2		;NO, REAL LOOKUP FAILURE.
	MOVE	C,-1(P)		;RESTORE AC C
	TLO	I,IOF.		;SET OUTPUT FLAG--FORCE ENTER.
	PUSHJ	P,FCM2		;DO ENTER
	TLZ	I,IOF.		;RESET FOR INPUT
	MOVE	C,-1(P)		;RESTORE AC C
	JRST	FCM2		;DO CLOSE,LOOKUP/ENTER

;FOR REAL LOOKUP FAILURE.  NOT CREATING NEW RANDOM WRITE FILE

;**********FILENAME PATCH****01-MAR-72****V31/01**********************
RETRY2:	TLNE	I,OPF.		;IS IT AN OPEN STATEMENT
	JRST	RETRY3		;DON'T TRY DAT EXTENSION
	PUSH	P,0
	MOVSI	0,(SIXBIT/DAT/)	;TRY LOOKUP WITH DAT EXT
	MOVEM	0,TEMP.+3(LOW)
	POP	P,0
	XCT	0
	JRST	RETRY1
	POPJ	P,

;*****************END OF PATCH*******************************************
RETRY1:	SETZM	TEMP.+3(LOW)	;CLEAR EXTENSION
	XCT	0		;LOOKUP 0,TEMP. IN AC 0
	ERROR	MSNG.		;COMPLETE FAILURE
	POPJ	P,		;SUCCEED

RETRY3:	SKIPN	ERR.(LOW)	;AND IS AN ERROR EXIT SET
	ERROR	MSNG.		;NO. TAKE SYSTEM ERROR EXIT
	ASH	C,-1		;RESTORE CHANNEL NUMBER
	TLO	N,RELFL.	;SET TO RELEASE CHANNEL
	JRST	OPNABT		;GO RELEASE CHANNEL AND RETURN TO USER

;DO SPECIAL MAG TAPE OPERATION

FNCTN.:	HLLZ	0,M		;DEVICE NO.
	TLO	0,NMTAPE+D	;MTAPE UUO
	XCT	0
;I/O WAIT FOR MAG TAPE

MTPZ.:	HLLZ	0,M		;CHAN NO
	TLO	0,NMTAPE	;MTAPE AC,0 UUO
	XCT	0
	POPJ	P,		;RETURN

;SET OUTPUT LAST FLAG IN WORD CONTAINING SIXBIT DEVICE NAME

SETOU.:	PUSH	P,G
	MOVE	G,DNAME(LOW)
	MOVEI	0,2
	IORM	0,(G)
SETOU1:	POP	P,G
	POPJ	P,

;CLEAR OUTPUT LAST FLAG

CLROU.:	PUSH	P,G
	MOVE	G,DNAME(LOW)
	MOVEI	0,2	
	ANDCAM	0,(G)
	JRST	SETOU1

;CLEAR ITEM COUNT IN INPUT BUFFER HEADER
;     ITEM COUNT USED AS USER-SYSTEM SYNC FLAG

CLRSY.:	PUSH	P,G
	HLRZ	G,DNAME(LOW)
	SETZM	2(G)
	JRST	SETOU1

;DO STATUS CHECK FOR CURRENT DEVICE
STAT.:	HLLZ	0,M		;DEVICE NO.
	IOR	0,[GETSTS F]	;GET STATUS
	XCT	0
	POPJ	P,
;DO CLOSE FOR CURRENT DEVICE

CLOSI.:	SKIPGE	0,RANAC.(LOW)	;DONT WANT TO CLOSE ON RANDOM ACCESS
	POPJ	P,
	EXCH	0,D
	LDB D,[POINT 4,M,12]	;GET CHAN #
IFN REENT,<ADDI	D,(LOW)>
	SETZM	INCNT.(D)	;CLEAR "INPUT"TALLY
	EXCH	0,D
	MOVEI	0,1		;INHIBIT OUTPUT CLOSE
	JRST	CLOSI1

CLOS.:	PUSH	P,D		;GET AN ACC TO PLAY WITH
	LDB	D,[POINT 4,M,12]
IFN REENT,<ADDI	D,(LOW)>
	SKIPL	RANDV.(D)	;ANY OUTPUT STILL TO DO
	JRST	CLOSO1		;NO
	SETZM	BLOCK.(LOW)	;INHIBIT INPUT OF NEXT BLOCK
	PUSHJ	P,ROUTP.	;DUMP CURRENT BUFFERFUL
CLOSO1:	SETZM	RANDV.(D)	;CLEAR INCORE BLOCK
	SETZM	PAKFL.(D)	;CLEAR PACKED I/O FLAG FOR THIS CHAN.
	POP	P,D
	SETZ	0,		;CLOSE BOTH INPUT AND OUTPUT
CLOSI1:	HLL	0,M		;DEVICE NO.
	TLO	0,NCLOSE	;CLOSE UUO
	XCT	0
	JRST	CLRSY.		;CLEAR SYNC FLAG

SUBTTL	DO INPUT FOR CURRENT DEVICE

INP.:	SKIPGE	RANAC.(LOW)	;@@@ARE WE DOING DIRECT ACCESS?
	PJRST	NXRINP		;YES, DO DUMP MODE INPUT
	HLLZ	0,M		;DEVICE NO.
	TLO	0,NINPUT	;INPUT UUO
	SKIPN	(M)		;BUFFERS SET UP
	PUSHJ	P,GETSPC	;NO, TRY TO RECLAIN SOME SPACE
	  XCT	0
	LDB	0,[POINT 4,M,12]	;GET CHAN#
	ADDI	0,INCNT.(LOW)	;POINT TO COUNT
	AOS	@0		;TALLY UP # OF "INPUTS" DONE
	JRST	CLROU.		;CLEAR FLAGS.
SUBTTL	DO OUTPUT FOR CURRENT DEVICE

OUTT.:	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	PJRST	NXROUT		;YES, DO DUMP MODE OUTPUT
	HLLZ	0,M		;DEVICE NO.
	TLO	0,NOUTPT	;OUTPUT UUO
	SKIPN	(M)		;HAVE BUFFERS BEEN SET UP?
	PUSHJ	P,GETSPC	;FIND SOME SPACE FOR THEM
	  XCT	0
	PUSHJ	P,SETOU.	;SET OUTPUT LAST FLAG
	JRST	CLRSY.		;CLEAR USER-SYS SYNCH FLAG


USETI.:
IUSET:	HLLZ	0,M		;CHAN #
	TLO	0,NUSETI	;USETI OPCODE
	JRST	USETIO		;COMMON CODE

USETO.:
USET:	HLLZ	0,M		; CHAN #
	TLO	0,NUSETO	;USETO UUO OPCODE
USETIO:	SKIPN	BLOCK.(LOW)	;BLOCK 0 ?
	AOS	BLOCK.(LOW)	;YES, DON'T ALLOW USETO TO  IT
	HRR	0,BLOCK.(LOW)	;BLOCK WHERE RECORD STARTS
	XCT	0		;
	POPJ	P,
	
SUBTTL	RANDOM ACCESS DUMP MODE INPUT/OUTPUT ROUTINES

NXRINP:	AOS	BLOCK.(LOW)	;GET NEXT BLOCK
RINP.:	PUSH	P,C		;SAVE AN ACC
	LDB	C,[POINT 4,M,12]
IFN REENT,<ADDI	C,(LOW)>
	SKIPL	RANDV.(C)	;DO WE NEED TO OUTPUT INCORE BLOCK
	JRST	RINP1		;NO, JUST DO INPUT
	PUSHJ	P,ROUTPF	;YES, OUTPUT IT BEFORE NEXT INPUT
	HRRE	0,RANDV.(C)	;RECOVER REQUIRED BLOCK
	MOVEM	0,BLOCK.(LOW)	;SET IT UP AGAIN
RINP1:	PUSHJ	P,IUSET		;SET ON REQUIRED BLOCK
ROUTP1:	HRREM	0,RANDV.(C)	;INCORE BLOCK (SOON TO BE)
	PUSHJ	P,RINPF		;DO INPUT
POPC:	POP	P,C		;RESTORE C
	POPJ	P,		;RETURN

RINPF:	SKIPE	HDRADD(LOW)	;LINE BUFFER IN USE?
	JRST	[MOVE	0,@HDRADD(LOW)	;GET REAL BUFFER ADDRESS
		JRST	.+2]		;SKIP RETURN
	HRRZ	0,(M)		;POINT TO DATA-2
	ADDI	0,1		;FORM I/O ADDRESS
	HRLI	0,-200		;ALWAYS WRITE A FULL BLOCK
	MOVEM	0,DMPIO.(LOW)	;STORE ADDRESS IN IOWD
	HLL	0,M		;CHAN. #
	HRRI	0,DMPIO.(LOW)	;POINT TO I/O LIST
	TLO	0,NINPUT	;SET UP UUO
	XCT	0		;DUMP MODE INPUT
	PUSHJ	P,CHKSTS	;CHECK STATUS
	SETZM	RANBM(C)	;BUFFER IS AN INPUT BUFFER
	PJRST	FIXBF		;FIXUP BUFFER HEADERS

NXROUT:	AOS	BLOCK.(LOW)	;GET NEXT BLOCK
ROUTP.:	PUSH	P,C		;SAVE AN AC
	LDB	C,[POINT 4,M,12]
IFN REENT,<ADDI	C,(LOW)>
	PUSHJ	P,ROUTPF	;OUTPUT BLOCK
	SKIPN	RANDV.(C)	;IS REQUIRED BLOCK = 0?
	PJRST	POPC		;YES, MEANS DON'T DO INPUT (CLOSE ONLY)
	PUSHJ	P,IUSET		;SET ON NEXT BLOCK
	HRRE	0,RANDV.(C)	;GET SAVED BLOCK NUMBER
	EXCH	0,BLOCK.(LOW)	;RESTORE BLOCK NUMBER
	JRST	ROUTP1		;DO INPUT OF REQUIRED BLOCK

ROUTPF:	HRRE	0,RANDV.(C)	;GET INCORE BLOCK #
	EXCH	0,BLOCK.(LOW)	;MAY NOT BE SAME
	MOVEM	0,RANDV.(C)	;SAVE REQUIRED BLOCK
	PUSHJ	P,USET		;SET ON THIS BLOCK
	PUSH	P,D		;GET A REGISTER
	SKIPN	D,HDRADD(LOW)	;LINE BUFFER IN USE
	MOVE	D,M		;NO
	MOVE	0,BLOCK.(LOW)	;NUMBER OF BLOCK TO BE WRITTEN
	CAMGE	0,RLBNO(C)	;IS IT THE LAST OR AFTER THE LAST BLOCK
	JRST	[MOVNI	0,200	;NO. WRITE A FULL BUFFER
		JRST	RTPF1]
	PUSHJ	P,SAVSIZ	;SAVE LAST BLOCK SIZE AND NUMBER
	MOVE	0,RLBSIZ(C)	;GET NUMBER OF ELEMENTS TO BE WRITTEN
	TLNE	I,FIOF.		;IS IT A CHARACTER FILE
	JRST	[PUSH	P,A	;YES. CONVERT TO WORDS
		IDIVI	0,5
		SKIPE	A	;ROUND UP TO FULL WORDS
		AOJ	0,
		POP	P,A
		JRST	.+1]
	MOVN	0,0		;NEGATE NUMBER OF WORDS TO WRITE FOR IOWD
RTPF1:	HRL	0,0		;WORD COUNT TO LEFT HALF
	HRR	0,(D)		;GET BUFFER ADDRESS
	ADDI	0,1		;GET ADDRESS OF DATA-1
	MOVEM	0,DMPIO.(LOW)	;STORE IOWD
	AOS	BLOCK.(LOW)	;SET TO INPUT NEXT BLOCK
	POP	P,D
	HLL	0,M		;CHAN. #
	HRRI	0,DMPIO.(LOW)	;POINT TO I/O LIST
	TLO	0,NOUTPT
	XCT	0		;DO OUTPUT
	PJRST	CHKSTS		;CHECK STATUS

SAVSIZ:	SKIPL	RANBM(C)	;IS BUFFER AN OUTPUT BUFFER
	POPJ	P,		;NO. DON'T SAVE SIZE
	CAME	0,RLBNO(C)	;IS IT THE LAST BLOCK
	JRST	[MOVEM	0,RLBNO(C)	;NO. SET NEW LAST BLOCK
		SETZM	RLBSIZ(C)	;ASSUME NO WORDS IN NEW LAST BLOCK
		JRST	.+1]
	MOVEI	0,200		;IF BINARY, 200 WORDS/BLOCK
	TLNE	I,FIOF.		;IS IT SYMBOLIC
	MOVEI	0,5*200		;YES. 5*200 CHARACTERS/BLOCK
	SUB	0,2(D)		;CALCULATE NUMBER OF ELEMENTS TO BE WRITTEN
	CAMLE	0,RLBSIZ(C)	;IS IT MORE THAN WAS PREVIOUSLY IB LAST BLOCK
	MOVEM	0,RLBSIZ(C)	;YES. SET NEW VALUE
	POPJ	P,

;HERE TO CHECK STATUS OF DUMP MODE I/O

CHKSTS:	PUSH	P,F		;SAVE F-USED FOR STATUS
	PUSHJ	P,STAT.		;GET STATUS
CHKST1:	TRNE	F,IOWERR!IODERR!IOPERR!IOBKTL!IOTEND
	ERROR	IOERR.		;I/O ERRORS
	TRNN	F,IODEND	;END OF FILE?
	PJRST	POPF		;NO RESTORE F AND RETURN
	MOVE	0,BLOCK.(LOW)	;GET THE NUMBER WE TRIED
	CAMN	0,[-1]		;-1 IS SPECIAL
	JRST	GOTOM1		;IT WAS
	JUMPGE	I,REOFTS	;TRUE EOF IF INPUT
	SKIPL	LEVEL.(LOW)	;HOPE ITS LEVEL D
	JRST	LCALOC		;NO SUCH LUCK
	PUSHJ	P,ZBUFR		;CLEAR BUFFER
	TRZ	F,IODEND	;CLEAR EOF
	PUSHJ	P,SESTA.	;IS STATUS WORD
	PJRST	POPF		;NO, ALL IS WELL
REOFTS:	SETZM	RANDV.(C)	;CLEAR INCORE BLOCK # SINCE IT NEVER MADE IT
	JRST	EOFTS. 		;AND GIVE UP

;HERE IF BLOCK # IS -1

GOTOM1:	PUSHJ	P,ZBUFR		;CLEAR BUFFER
	HRRZM	0,RANDV.(LOW)	;SET IN CORE BLOCK TO BE -1
	TRZ	F,IODEND	;CLEAR EOF
	PUSHJ	P,SESTA.	;IN STATUS WORD
	JRST	CHKST1		;RETURN

ZBUFR:	PUSH	P,A		;NEED SOME ACCS
	PUSH	P,B
	HRRZ	B,DMPIO.(LOW)	;ADDRESS OF DATA -1
	SETZM	1(B)		;ZERO FIRST WORD
	HRLI	A,1(B)		;FORM ALT WORD
	HRRI	A,2(B)
	BLT	A,200(B)
	POP	P,B		;RESTORE B
	POP	P,A		;AND A
	POPJ	P,

;HERE TO CREATE NEW FILE IF LEVEL C, A VERY SLOW LOOP 

LCALOC:	PUSHJ	P,ZBUFR		;CLEAR BUFFER
ALOCMR:	PUSHJ	P,USET		;SET ON BLOCK WE NEED
	TLC	0,012000	;USETO TO OUTPUT
	HRRI	0,DMPIO.(LOW)	;I/O LIST ADDRESS
	XCT	0		;DUMP ONE BLOCK
	TRZ	F,IODEND	;CLEAR EOF
	PUSHJ	P,SESTA.	;IN STATUS WORD
	PUSHJ	P,IUSET		;BACK ON BLOCK
	TLC	0,012000	;USETI TO INPUT
	HRRI	0,DMPIO.(LOW)	;PUT ADDRESS BACK ALSO
	XCT	0		;TRY INPUT
	PUSHJ	P,STAT.		;SEE IF WE WON
	TRNE	F,IOWERR!IODERR!IOPERR!IOBKTL!IOTEND
	ERROR	IOERR.		;I/O ERRORS
	TRNE	F,IODEND	;EOF STILL?
	JRST	ALOCMR		;NOT DONE YET
	JRST	CHKST1		;CONTINUE

;HERE TO SETUP FAKE BUFFER COUNT AND BYTE POINTER

FIXBF:	PUSH	P,D		;GET AN ACC
	SKIPN	D,HDRADD(LOW)	;LINE BUFFER IN USE?
	MOVE	D,M		;NO
	MOVE	0,1(D)		;GET BYTE POINTER
	TLZ	0,770077	;CLEAR OUT REST OR IT
	JUMPN	0,.+2		;IF NOT SET UP YET
	MOVSI	0,(POINT 7,,35)	;ASSUME ASCII
	HRR	0,(D)		;GET ADDRESS
	ADDI	0,1		;POINT TO DATA
	MOVEM	0,1(D)		;STORE BYTE POINTER
	MOVE	0,BLOCK.(LOW)	;CURRENT BLOCK
	CAML	0,RLBNO(C)	;IS IT BEFORE THE LAST BLOCK ON INPUT
	JRST	[PUSHJ	P,SAVSIZ	;NO. SAVE LAST BLOCK INFO
		TLNE	I,IOF.	;INPUT OR OUTPUT
		JRST	.+1	;OUTPUT. USE FULL BLOCK SIZE
		MOVE	0,RLBSIZ(C)	;INPUT. USE LAST BLOCK SIZE
		JRST	FIXBF1]
	MOVEI	0,200		;YES. SET FULL BUFFER ELEMENT COUNT
	TLNE	I,FIOF.		;SYMBOLIC FILE?
	MOVEI	0,5*200		;YES
FIXBF1:	MOVEM	0,2(D)		;STORE ELEMENT COUNT IN BUFFER HEADER
	MOVEM	I,RANBM(C)	;SAVE STATE OF BUFFER
	POP	P,D
	POPJ	P,
RDWR:	SKIPL	RANAC.(LOW)	;RETURN IF RANDOM ACCESS
	TLNN	I,FIOF.		;FORMAT I/O?
	JRST	FTST0		;NO,BINWR TAKES CARE OF THIS FOR BINARY
	TLNN	N,TTYFL.	;TTY IS OK.
	TLNE	I,NLIOF.!STPFF.	;NAMELIST OR TAPE FUNCTION?
	JRST	FTST0		;YES,DON'T SET UP BUFFERS ETC
	TLNN	E,DSKBIT!MTABIT	;MTA?OR DSK?
	JRST	RDWRER		 ;NO,PRINT ERROR MESSAGE
	MOVE	0,-1(M)		;GET NO OF CHARS.(LOW)
	MOVEM	0,CHARS.(LOW)	;STORE IT
	HRRZ	0,-2(M)		;BYTE PTR
	HRRZ	B,-3(M)		;BUFFER PTR
	SUB	0,B		;GET NO WORDS USED
	SUBI	0,2		;MAKE UP FOR 3RD WORD & IN/OUT DIFFERENCES
	MOVEM	0,WORDS.(LOW)	;STORE IT
	SKIPG	(M)		;OUTPUT RING SETUP?
	PUSHJ	P,OUTT.		;NO DO DUMMY OUTPUT
	HRRZ	B,@(M)		;GET 2ND WD IN BUFFER
	HLRZ	B,(B)		;# WORDS IN THIS BUFFER
	HRRZ	D,(M)		;GET BUFFER ADDRESS
	ADDM	B,D		;GET FINAL ADDRESS
IFE REENT,<HRRM	D,BLOTZ		;SET UP BLT>
IFN REENT,<MOVSI 0,(BLT D,)
	HRR	0,D>
	HRLZ	D,-3(M)		;-FROM- INPUT BUFFER
	HRR	D,(M)		;-TO-   OUTPUT BUFFER
	AOBJP	D,.+1		;ST DATA WORD
IFE REENT,<BLOTZ: BLT	D,0	;***THIS INST GETS CHANGED, DO BLT>
IFN REENT,<XCT	0>
	MOVE	0,CHARS.(LOW)	;PICK UP CHAR COUNT
	MOVEM	0,2(M)		;SET IT UP FOR OUTPUT
	HRRZ	0,1(M)		;OUTPUR POINTER
	ADD	0,WORDS.(LOW)	;SKIP OVER WORDS USED ALREADY
	HRRM	0,1(M)		;SET UP OUTPUT POINTER
	TLNN	I,DDF.		;DSK?
	JRST	[MOVEI	D,7	;BACKSPACE CODE
		PUSHJ	P,FNCTN.;NO,MTA. DO A BACKSPACE
		PUSHJ	P,CLOSI. ;CLOSE INPUT
		JRST	FTST2]	;CONTINUE,SET UP LINE BUFFERS ETC.
	LDB	D,[POINT 4,M,12];CHANNEL NUMBER
IFN REENT,<ADDI	D,(LOW)>
	MOVE	0,INCNT.(D)	;GET COUNT OF # OF INPUTS DONE
	MOVEM	0,BLOCK.(LOW)	;SET UP BLOCK#
	PUSHJ	P,CLOSI.	;CLOSE INPUT
	PUSHJ	P,USET		;DO USETI ON 'BLOCK'
	JRST	FTST2		;CONTINUE,SET UP LINE BUFFERS ETC
;THE USER HAS ATTEMPTED TO CHANGE FROM READ TO WRITE WHILE DOING FORMATTED
;I/O, BUT THE DEVICE CANNOT BE BACKSPACED AND THE OUTPUT MAY BE GARBELED

RDWRER:	TTCALL	3,[ASCIZ /
WARNING! FORMATTED READ FOLLOWED BY WRITE MAY FAIL.
/]
	JRST	FTST0		;CONTINUE
SUBTTL	SET STATUS FOR CURRENT DEVICE

SESTA.:	HLLZ	0,M		;DEVICE NO.
	TLO	0,NSETST+F	;SET STATUS UUO
	XCT	0
	POPJ	P,

;I-O WAIT FOR CURRENT DEVICE

WAIT.:	HLLZ	0,M		;DEVICE NO.
	IOR	0,[WAIT]	;WAIT
	XCT	0
	POPJ	P,
;DUMMY LOOKUP FOR CURRENT DEVICE-CLEARS SYSTEM CLOSE BIT

LOOK.:	HLLZ	0,M		;DEVICE NO.
	TLO	0,NLOKUP	;LOOKUP UUO
	XCT	0
	JFCL			;ERROR RETURN
	POPJ	P,
SUBTTL	MAGTAPE ROUTINES
; WE ARE ABOUT TO INIT A MAG TAPE UNIT
; SEE IF MAGDEN HAS BEEN CALLED FOR THIS UNIT, IF SO SET
; THE APPROPRIATE MODE BITS IN THE RIGHT HALF OF THE INIT.

MGINIT:	PUSH	P,G		;SAVE
	PUSH	P,C		;AC'S
	PUSH	P,D		;G,C,D
	SETZ	D,		;INIT
	MOVEI	G,TABPT.(LOW)	;POINTERS
FINDLP:	MOVE	C,(G)		;GET A NAME
	TRZ	C,77		;CLEAR FLAG BITS
	CAMN	C,B		;IS IT THE ONE WE WANT?
	JRST	SETMOD		;YES, GO SET MODE
	JUMPN	C,MGNDTS	;NO, IS IT AN EMPTY SLOT?
	MOVE	D,G		;YES, SAVE POINTER
MGNDTS:	SUBI	G,1		;NO, DECREMENT POINTER AND
	CAIE	G,MBFBG.(LOW)	;SEE IF DONE WITH TABLE
	JRST	FINDLP		;NOT DONE, GET NEXT NAME
	JUMPE	D,TBLER.	;IF NOT ENTERED & NO ROOM, FAIL!
	JRST	SETRET		;RETURN
SETMOD:	LDB	C,[POINT 6,(G),35]	;GET MODE BITS
	LSH	C,6		;POSITION THEM
	HRRM	C,INIT.(LOW)	;PUT THEM IN INIT.
SETRET:	MOVEI	C,IOCON		;SYNC MODE BIT
	IORM	C,INIT.(LOW)	;SET SYNC MODE FOR INIT
	POP	P,D		;RESTORE
	POP	P,C		;AC'S D,C,G
	POP	P,G
	POPJ	P,		;RETURN

;THIS ROUTINE CONVERTS A NEG F4 DEV NUM TO A POS DEV NUM.
;EXPECTS (0)=DEV NUM, RETURNS DEV NUM IN 0.


MAKPOS:	CAMG	0,[-6]		;LEGAL NUM?
	ERROR	ILRED.		;NO, PROBABLY "REREAD".
	ADDI	0,POSTAB+5	;GET ADDRESS IN TABLE
	HRRZ	0,@0		;GET POSITIVE DEV. NUM. IN 0
	POPJ	P,		;RETURN.

POSTAB:	EXP	NEG5.		;CDR
	EXP	NEG1.		;TTY
	EXP	NEG3.		;LPT
	EXP	NEG2.		;PTP
	EXP	NEG1.		;TTY
SUBTTL	ROUTINES TO RE-USE OLD BUFFER SPACE
;LINK.:	CONTAINS ADDRESS OF CHAIN OF BUFFERS (LEFT HALF)
;BUFFERS CONTAIN XWD BACKWARDS LINK,, FORWARDS LINK
;SET UP BY RELEAS SUBROUTINE
;SECOND WORD IS RETURN FROM DEVSIZ UUO (NUMBER OF BUFFERS ,, SIZE OF BUFFER)

GETSPC:	PUSH	P,B		;SAVE FOR FNDSPC RETURN
	PUSHJ	P,FNDSPC	;CAN SPACE BE REUSED
	JRST	[POP	P,B	;NO. LET I/O OPERATION GET SPACE
		POPJ	P,]
	PUSH	P,.JBFF		;SAVE END OF MEMORY
	HRRZM	B,.JBFF		;SET END OF MEMORY TO REUSABLE SPACE
	XCT	0		;DO I/O OPERATION TO GET SPACE
	POP	P,.JBFF		;RESTORE END OF MEMORY
	POP	P,B
	AOS	(P)		;SET SKIP RETURN
	POPJ	P,		;RETURN

FNDSPC:	SKIPN	LINK.(LOW)	;ANY SPACE TO RECOVER?
	POPJ	P,		;NO, JUST RETURN
	PUSH	P,C
	LDB	C,[POINT 4,M,12];GET CHANNEL NUMBER
IFN REENT,<ADDI	C,(LOW)>
	MOVE	C,BUFSZ.(C)	;GET REQUIRED BUFFER SIZE AND NUMBER
	HLRZ	B,LINK.(LOW)	;START OF CHAIN
	CAMN	C,1(B)		;WILL THIS SPACE DO
	JRST	GOTSPC		;YES
	HRRZ	B,(B)		;TRY NEXT
	JUMPN	B,.-3		;UNLESS FINISHED
SPCRET:	POP	P,C		;RESTORE ACCS
	POPJ	P,

GOTSPC:	PUSH	P,B		;SAVE REG FOR LINKING
	MOVE	B,(B)		;GET POINTER WORD
	TRNN	B,-1		;LAST LINK IN CHAIN?
	JRST	[HLRM	B,LINK.(LOW)	;YES, BACKUP LINK.
		JRST	.+2]		;SKIP NEXT INST
	HLLM	B,(B)		;REMOVE THIS SPACE FROM CHAIN
	MOVSS	B
	TRNN	B,-1		;FIRST LINK IN CHAIN?
	JRST	[HLLM	B,LINK.(LOW)	;YES, ADVANCE LINK.
		TLNN	B,-1		;ONLY WORD IN LINK.
		SETZM	LINK.(LOW)	;YES
		JRST	.+2]		;SKIP NEXT INST.
	HLRM	B,(B)		;BY REPLACING POINTERS
	AOS	-2(P)		;SET FOR SKIP RETURN
	POP	P,B
	JRST	SPCRET		;AND RETURN

SUBTTL	BINARY ROUTINES
;BINARY DATA TRANSMISSION

BINDT.:	AOS	ASVAR.(LOW)	;INCREMENT WORD COUNT
	JUMPGE	I,BININ		;JUMP ON INPUT
	SKIPG	2(M)		;DO OUTPUT NOW?
	PUSHJ	P,OUTPT		;YES
	SKIPL	RANAC.(LOW)	;IS IT RANDOM OUTPUT
	JRST	BINDT1		;NO
	LDB	C,[POINT 4,M,12]	;GET CHANNEL NUMBER
	HRROS	RANDV.(C)	;MARK AS NEEDS TO BE OUTPUTTED
BINDT1:	MOVE	C,@DADDR.(LOW)	;DATA
	IDPB	C,1(M)		;DEPOSIT DATA
	SOS	2(M)		;DECREMENT COUNT
	JRST	IORTR.		;GET DATA OR FIN
;BINARY OUTPUT

OUTPT:	PUSHJ	P,OUTT.		;DO OUTPUT
	SKIPGE	RANAC.(LOW)	;ALREADY CHECKED IF RANDOM ACCESS
	POPJ	P,		;YES
	PUSHJ	P,STAT.		;STATUS CHECK
	TRNE	F,IODERR!IOPERR!IOWERR!IOTEND!IOBKTL
	PUSHJ	P,IOERR.	;ERRORS
	POPJ	P,

;BINARY TAPE INITIALIZATION BEFORE DATA

BINWR.:	SKIPGE	(M)		;CLOSE DONE LAST?
	JUMPL	I,.+2		;OUTPUT?
	JRST	.+2		;NO, NO
	PUSHJ	P,OUTT.		;DO DUMMY OUTPUT
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	PUSHJ	P,RANBIN	;YES SET UP BLOCK# ETC
	TLNE	I,POSS.		;IS IT THE POSITION STATEMENT
	JRST	FIB.		;YES. NO IO REQUIRED
	PUSHJ	P,BUFCA.	;GET BUFFER HEADER ADDRESS
	LDB	A,[POINT 4,M,12]	;GET CHAN #
IFN REENT,<ADDI A,(LOW)		;LOW SEGMENT OFFSET>
	SKIPL	PAKFL.(A)	;PACKED INPUT/OUTPUT LAST?
	JRST	SETPTR		;NO,GO DO BINARY READ/WRITE
	SETZM	PAKFL.(A)	;YES,RESET FLAG
	JUMPGE	I,BINPU		;SEE IF INPUT OR OUTPUT
	PUSHJ	P,OUTT.		;OUTPUT DONE LAST,FORCE OUTPUT
	JRST	SETPTR		;DON'T DO INPUT
BINPU:	PUSHJ	P,INPT.		;DO INPUT
SETPTR:	LDB	0,[POINT 6,1(M),11]; GET POINTER SIZE
	CAIN	0,44		;INIT AS BINARY?
	JRST	IORTR.		;YES
	MOVEI	0,4400		;NO,SET UP POINTER
	HRLM	0,1(M)		;POINTER
	MOVE	0,2(M)		;ADJUST WORD COUNT
	JUMPE	0,IORTR.	;JUMP IF NO ITEM COUNT
	IDIVI	0,5
	MOVEM	0,2(M)		;RESTORE WORD COUNT
	JRST	IORTR.		;GET DATA

;CALCULATE BLOCK # WHERE BINARY RECORD STARTS. THIS IS FOR BINARY INPUT

RANBIN:	MOVE	A,ASVAR.(LOW)	;GET WORD #
	IDIVI	A,200		;GET BLOCK WHERE RECORD STARTS
	AOJ	A,		;POINT TO 1ST BLOCK OF RECORD
	MOVEM	A,BLOCK.(LOW)	;STORE IT
	MOVEM	B,WORDS.(LOW)	;SAVE WORDS FROM START OF BLOCK
	LDB	C,[POINT 4,M,12]
IFN REENT,<ADDI	C,(LOW)>
	HRRZ	B,RANDV.(C)	;GET INCORE BLOCK
	CAME	B,BLOCK.(LOW)	;IS IT THE ONE WE WANT?
	PUSHJ	P,RINP.		;NO
	JUMPGE	I,.+3		;OUTPUT?
	TLNN	I,POSS.		;AND NOT POSITION STATEMENT
	HRROS	RANDV.(C)	;YES, SIGNAL OUTPUT FOR THIS BLOCK
	PUSHJ	P,FIXBF		;RESET WORD COUNT AND BYTE POINTER
	MOVE	A,WORDS.(LOW)	;ADJUST BYTE POINTER AND COUNT
	ADDM	A,1(M)
	SUB	A,2(M)		;DECREMENT COUNT
	MOVNM	A,2(M)
	POPJ	P,

;BINARY DATA INPUT

BININ:	SKIPG	2(M)		;DROP WORD COUNT
	JRST	[PUSHJ	P,INPT.	;FILL BUFFER
		JRST	BININ]	;SEE IF ANYTHING IN BUFFER
	SOS	2(M)		;DECREMENT WORD COUNT
	ILDB	C,1(M)		;GET WORD
	MOVEM	C,@DADDR.(LOW)	;STORE DATA
	JRST	IORTR.		;RETURN

;BINARY INPUT

INPT.:	PUSHJ	P,INP.		;DO INPUT
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	POPJ	P,		;YES, STATUS CHECKED ALREADY
	PUSHJ	P,STAT.		;DO STATUS CHECK
	TRNE	F,IODEND
	JRST	EOFTS.		;END OF FILE
	TRNE	F,IOTEND!IODERR!IOPERR!IOBKTL
	ERROR	IOERR.		;ERRORS
	POPJ	P,

; CALLED BY: PUSHJ P,FNDSLT
; FINDS AN AVAILABLE SLOT IN DYNDV.
; BAD RETURN: TBLER.---DYNDV. IS REALLY FULL.
; GOOD RETURN: (C)=THE NUMBER OF THIS CHANNEL,(D)=PTR TO SLOT IN DYNDV.

        EXTERNAL        JOBJDA,JOBHCU         ;JOBDAT LOCATION JOBJDA(0-17) **
FNDSLT:	MOVEI	D,DYNDV.+1(LOW)	;PTR TO FIRST USABLE SLOT
IFN %352,<
SLLOP1:	MOVE	C,(D)
	TRZ	C,77		;CLEAR I/O BITS
	CAMN	C,DEVNAM(LOW)	;IS IT SAME DEVICE UNDER A DIFFERENT NUMBER?
	JRST	GOTSLT		;YES
	CAIGE	D,DYNND.(LOW)	;END OF LIST
	AOJA	D,SLLOP1	;NO.
	MOVEI	D,DYNDV.+1(LOW)	;NOT THERE, FIND A VACANCY>
SLLOOP:	SKIPN	(D)		;IS SLOT EMPTY?
; ** FIX FOR FORSE./IOCS CONFLICT WHILE LOOKING UP CHANNEL
        JRST    [MOVEI C,DYNDV.(LOW)    ;C=OFFSET OF (D)
                SUBM D,C        ;COMPUTE CHANNEL NUMBER FOR JOBJDA
		CAMG C,JOBHCU	;SKIP IF IT IS GOOD
                SKIPN JOBJDA(C) ;SKIP IF THE CHANNEL IS BUSY
                JRST GOTSLT     ;CHANNEL IS FREE, GO TO IT
                JRST .+1]       ;CHANNEL IS NOT FREE, TRY NEXT CHANNEL
	CAIGE	D,DYNND.(LOW)	;DONE?
	AOJA	D,SLLOOP	;NO, LOOP BACK.
	ERROR	TBLER.		;YES, FAIL!

GOTSLT: ; ** END OF FIX FOR FORSE./IOCS CONFLICT
IFN %352,<DPB	C,DYPNT.(LOW)	;MARK THE DEVICE ON THIS CHANNEL.
	SKIPE	(D)		;NEW DEVICE?
	JRST	[POP	P,(P)	;NO
		JRST	MATSET]>
	CAMLE	C,DEVNO.(LOW)	;HIGHER THAN PREVIOUS NUMBER?
	MOVEM	C,DEVNO.(LOW)	;YES, UPDATE
	POPJ	P,		;RETURN

XVAR:	XWD	VAR.,VAR.	;LENGTH OF PUSHDOWN LIST
ACBLT:	XWD	B,SAVEAC+B	;BLT POINTER FOR AC SAVE
PTRU:	POINT	4,A,12		;AC FIELD OF UUO
FORZRO:	SIXBIT	/ FOR00/
	END
 5pd