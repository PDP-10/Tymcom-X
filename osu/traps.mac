TITLE TRAPS	OVER/UNDERFLOW TRAP ROUTINE
SUBTTL	V32/01	14-SEP-72	/DLH

;FROM V.32(305)	6-OCT-1971	T. EGGERS/DMN/TWE
;***COPYRIGHT 1969,1970,1971,1972 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

REENT==0	;TRAPS WILL NOT LOAD INTO HIGH SEGMENT

T=14	;WORKING ACCUMULATOR
TT=1
IFE REENT,<LOW=0>
IFN REENT,<LOW=16>
P=17	;PUSH DOWN POINTER

FXU=1B11	;FLOATING EXPONENT UNDERFLOW FLAG
FOV=1B3		;FLOATING OVERFLOW BIT
NDV=1B12	;NO DIVIDE BIT

OVE=10		;ENABLE INTEGER OVERFLOW TRAPS

;RESTRICTIONS ON OVTRAP ROUTINE:
;	1- NO ANSWER FOR A TRAPPING INSTRUCTION MUST BE STORED,
;	   INDEXED BY 17, OFF THE END OF THE PUSH DOWN LIST WHOSE
;	   POINTER IS IN 17.
;	2- OVTRAP DOES NOT TRACE XCT OR UUO CHAINS
;	3- THERE ARE NO FIXUPS FOR INTEGER TRAPS
;	4- MOVNX AND MOVMX ARE CONSIDERED INTEGER INSTRUCTIONS
;	5- TRAPPING INSTRUCTION MUST NOT BE IN ACCUMULATOR T=14
;	6- CRY0 AND CRY1 WILL BE PRESERVED
;	7- THE UN-NORMALIZING OF UNDERFLOWS WILL NOT WORK FOR THE
;	   FLOATING "LONG" MODE OR KI10 D.P. INSTRUCTIONS.

IF1,<OPDEF KADFN [DFN]>	;THIS PRESERVES THE KA10 "DFN"
			;   SINCE SEARCH DEF40 REDIFINES IT FOR THE KI10

SEARCH	DEF40
ENTRY	TRPIN.,TIMER,INTAB.
	EXTERN	.JBCNI
EXTERN	OVPC.,OVCNT.
EXTERN	.JBTPC,.JBAPR,.JBREL,ITYPM.,UUOL.,KA10.

MLON	;ENABLE MULTI LINE LITERALS

			;PUSHJ P,TRPINI	TO INITIALIZE ALL TRAPPING
TRPIN.:	SKIPE	KA10.(LOW)	;KA-10 OR KI-10 PROCESSOR
	JRST	KATRAP		;KA-10 INTERRUPT SYSTEM
	MOVEI	TT,INTAB.	;BASE ADDRESS OF INTERRUPT TABLE
	HRLI	TT,4		;CLEAR INTERRUPT SYSTEM
	INTADR	TT,		;INIT INTERRUPT SYSTEM
	HALT
	HRLZI	TT,2		;REENABLE INTERRUPT SYSTEM
	INTADR	TT,
	HALT
	HRLOI	TT,777777
	INTENB	TT,		;ENABLE ALL CHANNELS
	HALT
	MOVE	TT,[JSR OVTRAP]	;TRAP1 INSTRUCTION
	SETTR1 TT,		;INIT OVERFLOW TRAPPING
	HALT
	SETZM OVCNT.(LOW)	;INIT # OVERFLOWS TO 0
	POPJ	P,		;RETURN
KATRAP:	MOVEI TT,OVTRAP+1
	HRRZM TT,.JBAPR		;INIT OVERFLOW TRAP ADDRESS
	MOVEI TT,OVE+400000
	JRSTF @[XWD 004000,.+1]		;CLEAR APR FLAGS
	APRENB TT,		;INIT OVERFLOW TRAPPING
	SETZM OVCNT.(LOW)	;INIT # OVERFLOWS TO 0
	POPJ	P,		;RETURN

OVTRAP:	0
	JRSTF	@[XWD 004000,.+1]
	MOVEM T,TSAVE		;SAVE AC T
	SKIPN	KA10.(LOW)	;KA-10 OR KI-10
	JRST	CONT		;KI-10. TIMER NOT ON SAME INTERRUPT
	MOVE	0,.JBTPC	;PROGRAM COUNTER AT INTERRUPT TIME
	MOVEM	0,OVTRAP	;PUT WHERE KI-100 PUTS IT
	SKIPN	MAXTIM		;TEST IF CLOCK TRAPPING
	JRST	CONT		;NO - NORMAL PATH
	MOVE	T,.JBCNI	;GET APR STATUS
	TRNE	T,200110	;OVERFLOW?
	JRST	CONT		;YES - NORMAL PATH
	AOS	T,NOWTIM	;INCREMENT TICK COUNTR
	CAML	T,MAXTIM	;TIME ELAPSED?
	JRST	NOTIME		;YES - ERROR MSG
	JRSTF	@[XWD 004000,.+1] ;CLEAR APR FLAGS
	HRRI	T,401010	;SET CLOCK AND OVERFLOW TRAPS
	APRENB	T,		;ENABLE
	JRST	GO
CONT:	SOS T,OVTRAP		;MAKE JOBTPC POINT TO INSTRUCTION
	MOVEM T,OVPC.(LOW)	;SAVE PC WORD
	TLNN T,(FXU)		;FLOATING POINT UNDERFLOW?
	JRST OVTRP1		;NO

	HLL T,1(T)		;YES
	TLC T,(JFCL (2))	; IS NEXT INSTRUCTION
	TLNN T,777002		;   A JFCL (2) ?
	JRST OVTRP2		;YES

	LDB T,[POINT 9,(T),8]	;GET INSTRUCTION
	CAILE T,177		;POSSIBLE FLOATING POINT?
	JRST TJFCL1		;NO
	CAIGE T,140		;BETWEEN 140 AND 177?
	JRST	[CAIN T,(<FSC>_-9)	;NO, FSC?
		JRST UAC		;YES
					;(UFA AND DFN CAN'T CAUSE UNDERFLOW)
	IFN KI10,<TRZ T,003		;CHANGE ALL KI10 D.P. ARITH TO DFAD
		CAIN T,(<DFAD>_-9)
		JRST UACLNG >		;DFAD, DFSB, DFMP, DFDV
		JRST TJFCL1]		;NO, PRINT ERROR MESSAGE
	ANDI T,7		;MASK TO MODE BITS
	JRST UTBL(T)		;DISPATCH ON INSTRUCTION TYPE


OVTRP1:	TLNN T,(FOV)		;FLOATING OVERFLOW OR FLOATING DIVIDE CHECK?
	JRST TJFCL1		;NO, INTEGER OVERFLOW OR DIVIDE CHECK
OVTRP2:	LDB T,[POINT 4,@OVTRAP,12]	;GET AC FIELD
	MOVEM T,ACFLD		;SAVE AC FIELD
	MOVE T,@OVTRAP		;GET INSTRUCTION
	MOVEM T,INST
	MOVE T,TSAVE
	MOVEI T,@INST		;GET EFFECTIVE ADDRESS
	EXCH T,INST		; AND SAVE. PICK UP INSTRUCTION
	TLC T,(042B8)		;CHANGE "MODE 2" TO "MODE 0"
				; AND CHANGE 140-177
				;   TO 100-137
	HLR T,OVTRAP		;GET FLAGS IN RIGHT HALF
	TDNE T,[643B8+<NDV_-^D18>]	;SKIP FOR "TO MEMORY" AND NO NDV
				; NO SKIP FOR INSTRUCTIONS OUTSIDE 140-177
				;  (E.G. FSC,XCT,UFA,DFAD,DFSB,DFMP,DFDV)
	SKIPA T,ACFLD		;GET CORRECT SIGN FROM AC
	MOVE T,INST		;GET CORRECT SIGN FROM MEMORY
	MOVEM T,ACDATA		;SAVE ADDRESS FOR SIGN OF CORRECT RESULT
	MOVE T,OVTRAP		;IS THIS AN UNDERFLOW THAT
	TLNE T,(FXU)		;  NEEDS TO BE UNNORMALIZED?
	JRST	[MOVE T,TSAVE	;YES, RESTORE T AND
		MOVE T,@ACDATA	;  GET ANSWER THAT NEEDS UN-NORMALIZING
		PUSH P,TT	;SAVE ANOTHER AC
		HLRE TT,T	;GET EXPONENT WITH EXTENDED SIGN INTO
		ASH TT,-9	;  RIGHT 8 BITS
		TSCE TT,TT	;FOR NEGATIVE ARG, GET 1'S COMPLEMENT
				;OF EXPONENT AND DON'T SKIP
		TLOA T,777000	;FOR NEG. ARG, SET EXP TO ALL ONES
		TLZ T,777000	;FOR POS. ARG, SET EXP TO ALL 0'S
		CAMGE TT,[346,,346]	;WILL ALL FRACTION BITS GO AWAY?
		TDZA T,T		;YES, FRACTION SHOULD BE ZERO
		ASH T,400000(TT)	;UN-NORMALIZE FRACTION TO BRING EXP
				;BACK INTO RANGE
		POP P,TT	;RESTORE THE AC
		JRST OVTRP3]	;GO STORE RESULT
	MOVE T,TSAVE
	SKIPGE @ACDATA		;SKIP IF CORRECT RESULT IS POSITIVE
	SKIPA T,[XWD 400000,1]	;NO, NEGATIVE
	HRLOI T,377777		;YES
OVTRP3:	PUSH P,T		;SAVE FIX UP
	LDB T,[POINT 9,@OVTRAP,8]	;GET INSTRUCTION
	CAIG T,177
	CAIGE T,140		;NORMAL FLOATING POINT INSTRUCTION
	JRST	[CAIN T,(<FSC>_-9)	;NO, FSC?
		JRST AC		;YES
		CAIN T,(<UFA>_-9)	;UFA?
		JRST AC1
		POP P,ACDATA	;GET SIGN OF RESULT OFF PDL
	IFN KI10,<TRZ T,003	;CHANGE ALL KI10 D.P. ARITHMETIC TO DFAD
		CAIN T,(<DFAD>_-9)
		JRST ACDOUB >	;KI10 DFAD, DFSB, DFMP, OR DFDV
		JRST TJFCL1]	;PROBABLY AN XCT
	ANDI T,7
	JRST TBL(T)
;THIS PAGE FOR OVERFLOWS, DIVIDE CHECKS, AND UN-NORMALIZING UNDERFLOWS

TBL:	JRST AC
	JRST ACLONG
	JRST MEMORY
	JRST BOTH
	JRST AC
	JRST AC
	JRST MEMORY
	;JRST BOTH

BOTH:	PUSH P,(P)		;SAVE ANOTHER COPY
BOTH1:	MOVE T,TSAVE
	POP P,@ACFLD		;LOAD AC
	POP P,@INST		;LOAD MEMORY
	JRST TJFCL

AC1:	AOS T,ACFLD
	ANDI T,17		;MASK AC+1 TO 4 BITS
	MOVEM T,ACFLD
AC:	MOVE T,TSAVE
	POP P,@ACFLD		;LOAD AC
	JRST TJFCL

ACLONG:	MOVE T,ACFLD		;GET AC
	ADDI T,1
	ANDI T,17
	MOVEM T,INST		;PUT AC+1 INTO MEMORY ADDRESS
	POP P,ACDATA		;GET SIGN OF ANSWER INTO BETTER PLACE
	PUSH P,[XWD 344777,-1]	;SAVE A POS LOW WORD
	HRLOI T,377777		;ASSUME A POSITIVE HIGH WORD
	SKIPGE ACDATA		;SHOULD RESULT BE POSITIVE?
	KADFN T,(P)		;NO, NEGATE IT WITH KA10 DFN
	PUSH P,T		;PUT OTHER ARG ON PDL
	JRST BOTH1

MEMORY:	MOVE T,TSAVE
	POP P,@INST
	JRST TJFCL

IFN KI10,<
ACDOUB:	MOVSI T,(Z 17,)		;GET ONES IN AC FIELD
	AND T,@OVTRAP		;EXTRACT AC FIELD FROM FAULTING D.P. INST
	IOR T,[DMOVE 0,[EXP <377777,,777777>,<377777,,777777>]]
	SKIPGE ACDATA		;WAS OVERFLOW RESULT POSITIVE?
	TLC T,1000		;NO, CHANGE THE DMOVE TO DMOVN
	JRST UAC2 >		;GO FIXUP THE TWO AC'S
;THIS PAGE ONLY FOR ZEROING UNDERFLOWS

UTBL:	JRST UAC		;ZERO AC
	JRST UACLNG		;ZERO AC, AC+1
	JRST UMEMRY		;ZERO E
	JRST UBOTH		;ZERO AC,E
	JRST UAC
	JRST UAC
	JRST UMEMRY
	;JRST UBOTH

UBOTH:	MOVE T,@OVTRAP		;GET OFFENDING INSTRUCTION
	TLZ T,777000		;ZERO OP CODE
	TLO T,(SETZB)		;CHANGE TO "SETZB AC,E"
	JRST UAC2

UMEMRY:	MOVE T,@OVTRAP
	TLZ T,777740		;ZERO OP CODE, AC FIELD
	TLO T,(SETZM)		;CHANGE TO "SETZM E"
	JRST UAC2

UACLNG:
IFE KI10,<LDB T,[POINT 4,@OVTRAP,12]	;GET AC FIELD
	DPB T,[POINT 4,T,12]	;COPY INTO AC FIELD
	ADDI T,1		;CHANGE AC TO AC+1
	TRZ T,20		;MASK TO 4 BITS
	TLO T,(SETZB) >		;CHANGE TO "SETZB AC,AC+1"
IFN KI10,<MOVSI T,(Z 17,)	;GET ONES IN AC FIELD
	AND T,@OVTRAP		;EXTRACT AC FIELD FROM FAULTING INST
	IOR T,[DMOVE 0,[EXP 0,0]] >	;SET UP A DMOVE TO CLEAR 2 AC'S
	JRST UAC2

UAC:	HLLZ T,@OVTRAP		;GET OFFENDING INSTRUCTION
	TLZ T,777037		;ZERO OP CODE, XR,@, LEAVE AC
	TLO T,(SETZ)		;CHANGE TO "SETZ AC,"
UAC2:	EXCH T,TSAVE		;SAVE INSTRUCTION, RESTORE T
	XCT TSAVE		;CLEAR THE REQUIRED REGISTERS

TJFCL:	MOVEM T,TSAVE		;SAVE T AGAIN
TJFCL1:	AOS OVTRAP		;JOBTPC POINTS TO NEXT INSTRUCTION
	MOVE T,@OVTRAP		;GET NEXT INSTRUCTION
	TLC T,(<JFCL>)		;COMPLEMENT "JFCL" BITS
	TLNE T,777000		;JFCL INSTRUCTION?
	JRST ERRPNT		;NO, PRINT ERROR MESSAGE
	TRNE T,-1		;ADDRESS SPECIFIED ON JFCL?
	HRRM T,OVTRAP		;YES, GO THERE
	TLNE T,(<Z 10,(1)>)	;IS OVERFLOW BIT (OR XR1) SET IN JFCL?
	JRST ERRPNT		;YES, TYPE ERROR MESSAGE
RETURN:	JRSTF	@[XWD 004000,.+1] ;CLEAR APR FLAGS
GO:	HRLOI T,337600		;MASK OUT SOME FLAGS
	ANDM T,OVTRAP		;BUT LEAVE CRY0, CRY1, AND USER IOT SET
	MOVE T,TSAVE		;RESTORE T
	JRSTF @OVTRAP
%OP==(7B2)
IFE REENT,<%L==0>
IFN REENT,<%L==(1B5)>
%O==5
%E==10
%%CR==3

ERRPNT:	MOVE T,OVPC.(LOW)	;GET FLAGS
	TLNN T,(FXU)
	AOS OVCNT.(LOW)		;COUNT OVERFLOWS AND DIVIDE CHECKS
	TLNN T,(FOV)		;FLOATING POINT TRAP?
	JRST	[HRRI T,1	;NO, ASSUME INTEGER OVERFLOW
		TLNE T,(NDV)	;INTEGER DIVIDE CHECK?
		MOVEI T,2	;YES
		JRST MSG2]
	HRRI T,3		;ASSUME FLOATING POINT OVERFLOW
	TLNE T,(NDV)		;FLOATING DIVIDE CHECK?
	MOVEI T,5		;YES
	TLNE T,(FXU)		;FLOATING UNDERFLOW?
	MOVEI T,4		;YES
MSG2:	HRRZS	T		;MAKE SURE LEFT HALF IS CLEAR
	PUSH	P,1
	PUSH	P,2
	PUSH	P,3
	HRRZ	1,OVPC.(LOW)	;GET ADDRESS
	CAMG	1,.JBREL	;SKIP IF FROM HIGH SEGMENT
	XCT	UUOL.(LOW)	;SET UP AC16 IF REENT OP SYSTEM
	PUSHJ	P,ITYPM.
	%E,	T	(%OP)
	%O,	@OVPC.	(%OP+%L+%%CR)
	HRRZ	1,OVPC.(LOW)	;GET ADDRESS
	CAMG	1,.JBREL	;SKIP IF FROM HIGH SEGMENT
	XCT	UUOL.(LOW)	;RESTORE AC16 AGAIN
	POP	P,3
	POP	P,2
	POP	P,1
	JRST	RETURN

TIMCHN=3 ;INTERRUPT CHANNEL USED FOR TIMER

;ROUTINE TO ALLOW USER TO SPECIFY A MAXIMUM CPU TIME IN SECONDS.
;CALLING SEQUENCE IS 
;	CALL TIMER (TIME)
;WHERE TIME IS THE MAX RUN TIME IN INTEGER SECONDS.

TIMER:	0
	MOVE	0,@0(16)	;GET TIME ARGUMENT
	IMULI	0,^D60		;CONVERT TIME TO TICKS
	MOVEM	0,MAXTIM	;STORE
	SETZM	NOWTIM		;CLEAR TO DATE TIME
	SKIPE	KA10.(LOW)
	JRST	KATIME
	MOVEI	0,TIMINT	;TIMER INTERRUPT ROUTINE
	MOVEM	0,INTAB.+<TIMCHN-1>*2+1 ;STORE IN INTERRUPT TABLE
	MOVEI	0,TIMCHN
	HRLI	0,1		;INTERRUPT CAUSE IS CLOCK INTERRUPT
	INTASS	0,		;ASSIGN CHANNEL(3) TO CAUSE(1)
	HALT
	MOVE	0,[1B0+1B<TIMCHN>]
	INTENB	0,		;ENABLE TIMER CHANNEL
	HALT
	JRA	16,0(16)	;RETURN
KATIME:	JRSTF	@[XWD 004000,.+1];CLEAR APR FLAGS
	MOVEI	0,401010	;SET CLOCK AND OVERFLOW TRAPS
	APRENB	0,		;ENABLE
	JRA	16,0(16)	;RETURN

TIMINT:	MOVEM	T,TSAVE		;NEED A REGISTER
	AOS	T,NOWTIM	;INCREMENT TICK COUNTER
	CAML	T,MAXTIM	;TIME ELAPSED?
	JRST	NOTIME		;YES - ERROR MESSAGE
	MOVE	T,TSAVE		;RESTORE REGISTER
	DISMIS			;RETURN TO PROGRAM
NOTIME:	TTCALL	3,[ASCIZ/
MAXIMUM RUN TIME EXCEEDED
/]
	CALLI	1,12		;EXIT WITH CHANNELS OPEN
MAXTIM:	BLOCK	1		;MAXIMUM RUN TIME IN TICKS
NOWTIM:	BLOCK	1		;RUN TIME TO DATE IN TICKS
TSAVE:	BLOCK 1		;TEMP FOR AC T
ACFLD:	BLOCK 1		;ADDRESS OF ACCUMULATOR
ACDATA:	BLOCK 1		;HOLDS SIGN OF CORRECT ANSWER
INST:	BLOCK 1		;HOLDS INSTRUCTION OR "E"
INTAB.:	BLOCK ^D70	;INTERRUPT SYSTEM TABLE


REPEAT 0,<

DESCRIPTION OF "TRAPS" PROGRAM FOR LIB40-

I. THE PURPOSE OF THE TRAPS PROGRAM IS DO ERROR DETECTION
   AND CORRECTION WHEN ARITHMETIC FAULTS OCCUR DURING THE
   EXECUTION OF FORTRAN PROGRAMS.

II. THE TRAPS PROGRAM CONSISTS OF THREE DISTINCT PARTS:

	A. TRPINI
		1. CALLING SEQUENCE- PUSHJ P,TRPINI
						;RETURN
		2. THE OVERFLOW COUNTER, OVCNT, (USED BY THE OVERFL
		      FUNCTION) AND THE PC WORD FLAGS ARE CLEARED
		3. PROCESSOR AND MONITOR TRAPPING ON OVERFLOW (PC WORD
		      BIT 0) IS ENNABLED

	B. OVERFL IS THE STANDARD FORTRAN OVERFLOW FUNCTION
		AND EXISTS IN LIB40 AS OVERFL.
		1. CALLING SEQUENCE-	JSA 16,OVERFL
					ARG	J
						;RETURN
		2. IF OVCNT=0, THEN J_1
		3. IF OVCNT=/0, THEN J_2
		4. THE OVERFLOW COUNTER, OVCNT, IS CLEARED TO 0

	C. OVTRAP IS A USER-MODE INTERRUPT ROUTINE WHICH IS STARTED
	  BY THE MONITOR WHEN AN ARITHMETIC FAULT OCCURS
		1. THE PC WORD (WITH THE ADDRESS OF THE INSTRUCTION
		      CAUSING THE TRAP) IS STORED IN OVPC.
		2. FOR FLOATING POINT INSTRUCTIONS
			A. FOR OVERFLOWS AND DIVIDE CHECKS,
			    THE FAULTY ANSWER IS PATCHED
			   TO BE PLUS OR MINUS (THE SIGN WILL BE THAT
			   OF THE CORRECT ANSWER)THE LARGEST POSSIBLE
			   NUMBER.
			B. FOR UNDERFLOWS, THE FAULTY ANSWER IS NORMALLY
			   PATCHED TO BE 0. HOWEVER, IF THE INSTRUCTION
			   FOLLOWING THE TRAPPING INSTRUCTION IS A JFCL
			   WITH BIT 16 (XR2) SET, THE ANSWER WILL BE
			   UN-NORMALIZED ENOUGH TO BRING THE EXPONENT
			   BACK INTO RANGE.
		3. (FOR INTEGER INSTRUCTIONS, NO PATCHING OF ANSWERS
		      IS DONE.)
		4. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS JFCL
		      A. DO NOT TYPE AN ERROR MESSAGE
			 UNLESS BIT 9 (AR OV TEST BIT) OR 17 (XR1) IS 1
		      B. DO NOT INDEX THE OVERFLOW COUNTER OVCNT
		      C. IF THE ADDRESS (BITS 18-35) OF THE JFCL
			 ARE NON-ZERO, THE INTERRUPTED PROGRAM WILL
			 BE RESTARTED AT THE ADDRESS OF THE JFCL
			  (THE @ AND INDEX FIELDS ARE IGNORED).
		      D. IF THE ADDRESS OF THE JFCL IS ZERO, THE
			 INTERRUPTED PROGRAM WILL BE RESTARTED AT
			 THE JFCL
			E. IF BIT 16 (XR2) IS A 1, UN-NORMALIZE THE
			   FRACTION BITS FOR UNDERFLOWS IN ORDER TO
			   BRING THE EXPONENT BACK INTO RANGE.
		5. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS NOT JFCL
		      A. INDEX THE OVERFLOW COUNTER, OVCNT
		      B. TYPE AN ERROR MESSAGE, USING SUBROUTINE "ERRMSG",
			 OF THE FOLLOWING FORM:

			INTEGER     OVERFLOW
			FLOATING    UNDERFLOW	PC=NNNNNN
			FLOATING    DIVIDE CHECK

		      C. THE INTERRUPTED PROGRAM WILL BE RESTARTED AT
			 THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		6. THE PROCESSOR FLAGS (PC WORD FLAGS) ARE CLEARED
			EXCEPT FOR CRY0 AND CRY1.
		7. THE INTERRUPTED PROGRAM IS RESTARTED

III. LIMITATIONS

	A. OVTRAP FIXUPS WILL NOT WORK ON THE PDP-6 FOR-
		1. THE LOW ORDER WORD OF FXXRL OR FXXL INSTRUCTIONS
		2. EXPONENT UNDERFLOW OR DIVIDE CHECK TRAPS

	B. FLOATING POINT FIX UPS WILL NOT OCCUR FOR INSTRUCTIONS
	   THAT ARE EXECUTED BY AN XCT OR A UUO, OR FOR INSTRUCTIONS
	   THAT ARE IN ACCUMULATOR T=14


	C. THE MEMORY FIX UPS FOR THE FLOATING POINT INSTRUCTIONS
	   WILL NOT WORK PROPERLY IF THE ANSWER IS STORED INDEXED
	   BY 17 (THE PUSH DOWN POINTER). EXAMPLES:

			FADRM AC,(17)
			FMPRB AC,-2(17)
			FDVM  AC,+1(17)

	D. MOVNX AND MOVMX ARE INTEGER INSTRUCTIONS AND WILL HAVE
	   NO FLOATING POINT FIX UPS IF THEY CAUSE OVERFLOW
	E. TRAPPING INSTRUCTION MUST NOT BE IN ACCUMULATOR T=14
	F. THE SIGN OF F.P. DIVIDE CHECK FIX UPS WILL BE CORRECT
	    ONLY WHEN DIVIDING BY ZERO. (THIS IMPLIES THAT THE
	    ARGUMENTS FOR DIVIDE CHECKS SHOULD BE NORMALIZED.)

>	;END REPEAT 0

PRGEND
TITLE ONINT  ON/OFF INTERRUPT PROCESSING

REENT==0
IFE REENT,<LOW=0>
IFN REENT,<LOW=16>

ESCCHN=2 ;CHANNEL FOR ESCAPE INTERRUPT

ENTRY ONINT,OFFINT
EXTERN INTAB.,TRAPF.,DSESC.

;THE ROUTINE ONINT(LABEL) ASSIGNS 'LABEL' AS THE LOCATION TO GO TO
;WHEN AN ESCAPE IS HIT.  THE CALL OFFINT OF NO ARGUMENTS REMOVES THIS
;ASSIGNMENT.

ONINT:	0
	HRRZ	0,0(16)	;GET ESCAPE LABEL
	MOVEM	0,ESCLAB	;SAVE FOR WHEN ESCAPE IS HIT
	MOVEI	0,ESCINT	;ADDRESS OF ESCAPE PROCESSOR
	MOVEM	0,INTAB.+<ESCCHN-1>*2+1 ;STORE IN CHANNEL TABLE
	SETZM	DSESC.(LOW)	;CLEAR DISABLED FLAG
	MOVE	0,TRAPF.(LOW)	;SIGNAL THAT TRAP ARMED
	TRO	0,1B<36-ESCCHN>	;SET BIT IN RIGHT HALF OF TRAP WORD
	MOVEM	0,TRAPF.(LOW)
	MOVEI	0,-1		;ASSIGN ESCAPE TO COMMAND PORT
	HRLI	0,0_9+ESCCHN	;ASSIGN CAUSE 0 (ESCAPE) TO ESCAPE CHANNEL
	TINASS	0,		;ASSIGN ESCAPE INTERRUPT
	HALT
	MOVE	0,[1B0+1B<ESCCHN>]	;ENABLE ESCAPE CHANNEL
	INTENB	0,
	HALT
	JRA	16,0(16)

OFFINT:	0
	HRRZI	0,-1
	TINASS	0,		;REMOVE ESCAPE FROM ESCAPE CHANNEL
	HALT
	SETZM	DSESC.(LOW)	;CLEAR DISABLED FLAG
	MOVE	0,TRAPF.(LOW)	;SIGNAL ESCAPE NO LONGER TRAPPED
	TRZ	0,1B<36-ESCCHN>	;CLEAR BIT
	MOVEM	0,TRAPF.(LOW)
	JRA	16,0(16)

ESCINT:	CLRBFO			;CLEAR TTY OUTPUT BUFFER
	CLRBFI			;CLEAR TTY INPUT BUFFER
	MOVE	0,ESCLAB	;GET ESCAPE LABEL
	HRRM	0,INTAB.+<ESCCHN-1>*2 ;SET IT AS WHERE TO GO AFTER ESCAPE PROCESSING
	DISMIS

ESCLAB:	BLOCK	1
PRGEND
TITLE TRULIMIT  LIMIT NUMBER OF TRU'S A PROGRAM CAN USE,

REENT==0
IFE REENT,<LOW=0>
IFN REENT,<LOW=16>

P=17

TRUCHN==1 ;INTERRUPT CHANNEL USED FOR TRU TRAPPING
TIME==^D60 ;AN INTERRUPT EVERY 60 UNITS
UNITS==1 ;WHERE UNITS ARE SECONDS

ENTRY TRULIMIT,TRUCK.
EXTERN INTAB.,TRAPF.

;THE CALL
;	CALL TRULIMIT(TRUS,LABEL)
;
;WHERE LABEL IS WHERE TO GO TO WHEN THE PROGRAM HAS USED TRUS TRU'S.

TRULIMIT: 0
	MOVE	0,@0(16)	;GET NUMBER OF TRU'S TO LIMIT PROGRAM TO
	IMULI	0,^D10000	;SCALE TO RANGE RETURNED BY MONITOR
	MOVEM	0,LIMIT		;AND SAVE FOR COMPARISON
	HRRZ	0,1(16)		;GET LABEL TO GO TO ON TRU LIMIT EXCEEDED
	MOVEM	0,TRULAB
	MOVE	0,[XWD -1,4]	;GET NUMBER OF TRU'S USED SO FAR
	GETTAB	0,
	HALT
	ADDM	0,LIMIT		;COMPUTE TOTAL JOB LIMIT ON TRU'S FOR COMPARISON
	MOVEI	0,TRUINT	;ADDRESS OF TRU INTERRUPT ROUTINE
	MOVEM	0,INTAB.+<TRUCHN-1>*2+1
	MOVE	0,TRAPF.(LOW)	;SIGNAL THE A TRAP IS SET FOR FORSE
	TRO	0,1B<36-TRUCHN>
	MOVEM	0,TRAPF.(LOW)
	MOVEI	0,0		;CLEAR ANY CURRENT TIMER
	SETTIM	0,
	HALT
	MOVEI	0,TRUCHN	;INTERRUPT CHANNEL FOR TRU TRAPPING
	HRLI	0,4		;INTERRUPT CAUSE IF TIMER (4)
	INTASS	0,		;ASSIGN INTERRUPT CHANNEL TO CAUSE
	HALT
	MOVE	0,[1B0+1B<TRUCHN>]
	INTENB	0,		;ENABLE TIMER INTERRUPT
	HALT
	MOVEI	0,TIME		;SET TIMER FOR 'TIME' 'UNITS'
	HRLI	0,UNITS
	SETTIM	0,
	HALT
	JRA	16,0(16)

TRUCK.:	0
	MOVEM	0,SAVE		;SAVE A REGISTER
	MOVE	0,[XWD -1,4]	;GET NUMBER OF TRU'S
	GETTAB	0,
	HALT
	CAML	0,LIMIT		;HAS LIMIT BEEN EXCEEDED
	JRST	EXCEED		;YES
	MOVE	16,TRUCK.	;RESTORE REGISTER USED FOR CALL
	MOVEI	0,TIME
	HRLI	0,UNITS
	SETTIM	0,		;RESET TIMER
	HALT
	MOVE	0,SAVE		;RESTORE REGISTER
	DISMIS			;RETURN TO PROGRAM
EXCEED:	MOVE	0,TRAPF.(LOW)	;SIGNAL THAT TRU TRAP NOLONGER ARMED
	TRZ	0,1B<36-TRUCHN>
	MOVEM	0,TRAPF.(LOW)
	MOVE	0,SAVE		;RESTORE REGISTER
	JRA	16,0(16)

TRUINT:	JSA	16,TRUCK.	;IS LIMIT EXCEEDED
	MOVE	0,TRULAB	;LABEL TO GO TO ON LIMIT EXCEEDED
	HRRM	0,INTAB.+<TRUCHN-1>*2
	DISMIS

TRULAB:	BLOCK	1
SAVE:	BLOCK	1
LIMIT:	BLOCK	1

PRGEND
TITLE INTENA	ENABLE AND DISABLE INTERRUPTS

ENTRY	INTENA,INTDIS
EXTERNAL	DSESC.

REENT==0
IFE REENT,<LOW=0>
IFN REENT,<LOW=16>
P==17	;PUSHDOWN POINTER
ESCCHN=2 ;ESCAPE CHANNEL

; CALL INTDISABLE      DISABLE THE ESCAPE AND TRU INTERRUPTS
;
; CALL INTENABLE       ENABLE BOTH INTERRUPTS

INTENA:	0
        SETZM   DSESC.(LOW)     ;SIGNAL NOLONGER DISABLED ESCAPE     MOVE    1,[1B0+1B<ESCCHN>]
        INTENB  1,              ;ENABLE ESCAPE
        HALT
	JRA	16,0(16)

INTDIS:	0
        MOVE    1,[1B<ESCCHN>]
        INTENB  1,              ;DISABLE ESCAPE
        HALT
        SETOM   DSESC.(LOW)
	JRA	16,0(16)

	END
W0U