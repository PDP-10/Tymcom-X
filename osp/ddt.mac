TYMSPC==33	;TYMSHARE SPECIFICATION NUMBER
TYMREL==7	;TYMSHARE BUGFIX NUMBER
DECSPC==22	;DEC SPECIFICATION NUMBER
DECREL==0	;DEC BUGFIX NUMBER

SUBTTL /AAA/EVS/ELB/WRS/DSB

COMMENT %

DDT ASSEMBLY SWITCHES

XMOD	EXEC MODE DDT - OFF IN USER VERSION/FILE DDT
FLDDT	FILE DDT - OFF IN EXEC/USER DDT
HI	HISEG VERSION OF DDT
FAILSW	INCLUDE FAIL-STYLE SYMBOL GOODIES - NORMALLY ON
DDTST	TEST MODE DDT - NO GLOBAL DEFS
XTAP	PAPER TAPE FEATURES
DDTTY	DDTIN/DDTOUT INSTEAD OF TTCALLS
DDTLOC	IF DEFINED, ABSOLUTE ORIGIN OF DDT
CMDFIL	IF DEFINED, CONTROL-Y READS COMMAND FILE.

%
IFNDEF XMOD,<XMOD==0>
IFNDEF FRMDDT,<FRMDDT==0>
IFNDEF FLDDT,<FLDDT==0>
IFNDEF HI,<HI==0>
IFNDEF FAILSW,<FAILSW==1>
IFNDEF DDTST,<DDTST==0>
IFNDEF XTAP,<XTAP==0>
IFNDEF DDTTY,<DDTTY==0>
IFNDEF CMDFIL,<CMDFIL==1>

DEFINE XP (X.,Y.),<
	IF2,<X.=Y.
IFE DDTST,<INTERN X.>>>

IFN XMOD,<DEFINE HEADER (TS,TR,DS,DR),<
  IFE DDTST,<
	TITLE EDDT	VERSION TS'.'TR'-'DS'.'DR	-EXEC MODE DDT>
IFN DDTST,<TITLE TEDDT	VERSION TS'.'TR'-'DS'.'DR	-TEST EXEC MODE DDT>
	XJOBSYM==36
	XZLOW==40
>>

IFE XMOD,<DEFINE HEADER (TS,TR,DS,DR),<
IFE FRMDDT,<
IFE FLDDT,<
IFE DDTST,<
IFE HI,<
	TITLE UDDT	VERSION TS'.'TR'-'DS'.'DR	-USER MODE DDT>
IFN HI,<
	TITLE HIDDT	VERSION TS'.'TR'-'DS'.'DR	-HISEG DDT>>>
IFN DDTST,<
	TITLE TDDT	VERSION TS'.'TR'-'DS'.'DR	-TEST MODE DDT>>
IFN FLDDT,<
	TITLE FILDDT	VERSION TS'.'TR'-'DS'.'DR	-FILE DDT>
>;END IFE FRMDDT
IFN FRMDDT,<
IFE DDTST,<
	TITLE FRMDDT VERSION TS'.'TR'-'DS'.'DR	-FRAME DDT>
IFN DDTST,<
	TITLE TFRDDT VERSION TS.'TR'-'DS'.'DR	-TEST MODE FRAME DDT>
>>
EXTERN JOBREL,JOBSA,JOBHRL,JOBSYM
	ZLOW==140

;DO NOT SET LOWER CORE IF EXEC DDT(OK USER OR FILDDT)
IFE XMOD,<
JOBVER==137
	LOC JOBVER
	BYTE(9)DECSPC,TYMSPC,DECREL,TYMREL
>
JOBDDT==74
IFE DDTST,<	LOC JOBDDT
	XWD DDTEND,DDT>
RELOC 0

IFDEF DDTLOC,<
DEFINE	XLOC (Q) <LOC Q>
	LOC DDTLOC>
IFNDEF DDTLOC,<
DEFINE	XLOC (Q) <RELOC Q>
>

HEADER (\TYMSPC,\TYMREL,\DECSPC,\DECREL)
		;THE HEADER MACRO CONSTRUCTS THE TITLE AND VERSION #
IFN XMOD,<
	OPDEF SKPUSR [SKIPL USRFLG]
	OPDEF SKPEXC [SKIPGE USRFLG]
>

;?????HUH???? SEXTERN	OVTAB.
SUBTTL MODIFICATION HISTORY

COMMENT @

33.7-22.0	8/10/83		/WRS
	Changed some questionable syntax to allow assembly under new
	MACRO (as well as old).
33.4-22.0	8/8/83		/WRS
	Added CCL entry code so FILDDT can be called by CRSHID.
33.3-22.0	7/1/82		/WRS
	Changed HALT$X in FRMDDT to preserve the PC.  Note that this
	is a lesser of two evils situation since it should really set
	the PC to the effective address of the HALT instruction.  At
	some point, we'll want to change this somehow.
33.2-22.0	12/30/81	/CARL
	Removed SEXTERN OVTAB. statement since this symbol is never
	referenced anywhere else.
33.1-22.0	???		???
	Fixed Start address + 1 problem.  Allow typeout in HEX from radix
	type routine.
32.0-22.0	12/23/80	/WRS
	JOBSYM is now updated to point to symbols loaded from a file.
	-1$0G will use virtual PEEK/POKE in monitor.  Always uses new
	PEEK so error returns will be detected.
31.0-22.0	7-NOV-80	/GL/EVS
	Modifications for the F3.
30.0-22.0	7-NOV-80	/GL
	Added the $88o and $$88o commands to look at 8 bit bytes which
	are in the KMC style format as in IRING & ORING on most KSs.
27.0-22.0	19-NOV-79	/EVS
	FRMDDT capability added. $U sets frame to look at,
	control-V loads a symbol file like in FILDDT.
	New switch CMDFIL added, command file code seperated
	from FILDDT code so that all flavors of DDT
	can have command files.
	Simulated paging in FILDDT will now work for the EPT
	when peeking at the monitor. This is necessary to look
	at exec virtual locations >= page 400. Just use n$0G as you
	would in a crash file.
26.0-22.0	18-Sep-79	ELB/DSB/WRS
	Understands KS differences, prints out correct mnemonics
	for I/O instructions, corrects DDTLOC definition
@

SUBTTL	ACTUAL CODE AND THINGS

IFN FLDDT!FRMDDT,<;DEFINE SOFTWARE CHANS.
		DP=3
	CRS==1	;CRASH FILE
	HCRS==4	;HIGH SEG OF CRASH FILE
>
IFN CMDFIL,<CM==2>	;CHANNEL FOR COMMAND FILES
;DEFINE ACCUMULATORS

F=0		;FLAGS
P=1		;PUSH DOWN
R=<A=2>		;POINTERS TO TABLES, CORE, ETC.
S=<B=3>
W=<C=4>		;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
T=5		;TRANSFER DATA
W1=6
W2=7
SCH=10		;MODE CONTROL SWITCH FOR OUTPUT
AR=11		;MODE CONTROL SWITCH FOR OUTPUT
ODF=12		;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
TT=13		;TEMPORARY
TT1=14	;TEMPORARY
TT2=15

;DEFINE PUSH DOWN LENGTH
LPDL=50		;MAX LENGTH PUSH DOWN LIST

;DEFINE BITS FOR USE IN LEFT HALF OF ACCUMULATOR F
COMF==200000		;COMMA TYPED FLAG
TIF==100000		;TRUNCATE TO 18 BITS -  SET BY SPACE OR COMMA
PTF==100		; +, -, OR * HAS BEEN TYPED
CTF==400
SF==4		;SYLLABLE FLAG
QF==1		;QUANTITY TYPED IN TO WORD ASSEMBLER

CF==40		; $  TYPED
CCF==10000	; $$  TYPED
MF==2		;MINUS SIGN TYPED IN
LTF==20		;LETTER TYPED IN TO CURRENT SYLLABLE
ROF==10		;REGISTER OPEN FLAG
STF==4000
FAF==1000		; < TYPED
SAF==2000		; > TYPED

FPF==20000		; . TYPED IN
FEF==400000		; E FLAG

MLF==200		;*FLAG
DVF==40000		;DIVIDE FLAG

;PID IS 20 IF SYM TAB POINTER IS INDIRECT JOBSYM
PID==0		;=0 IF SYMBOL TABLE POINTER IS IN JOBSYM

;DEFINE BITS FOR USE IN RIGHT HALF OF ACCUMULATOR F

ITF==2	;INSTRUCTION TYPED IF ITF=1
OUTF==4	;OUTPUT IF OUTF=1
CF1==400		;OUTPUT 1 REGISTER AS CONSTANT
LF1==2000		;OUTPUT 1 REGISTER AS FORCED SYMBOLIC OR CONSTANT
Q2F==1		;NUMBER TYPED AFTER ALT MODE 
R20F==10	;TEMP FLAG USED IN SETUP
SBF==20
NAF==200		;NEGATIVE ADDRESSES PERMISSABLE
POWF==4000		;ARGUMENT FOR EXPONENT COMING
TTCLF==10000		;TYPED A TTCALL
CLLIF==20000		;TYPED A CALLI

;DEFINE SYMBOL TABLE SYMBOL TYPES
GLOBAL==040000		;GLOBAL SYMBOL
LOCAL==100000
PNAME==740000		;PROGRAM NAME
DELI==200000		;DELETE INPUT
DELO==400000		;DELETE OUTPUT

	IFE DDTST,<INTERN DDTEND	>;DECLARE END OF DDT AS INTERNAL, FOR
			; USER TO SEE (USER MODE) AND ONCE ONLY CODE
			; (MONITOR)
	IFE XMOD,<IFE DDTST,<	ENTRY DDT
		IFE FLDDT,<ENTRY DDTCH.>>
		>
	IFN XMOD,<IFE DDTST,<	INTERNAL DDT
			ENTRY DDTX		;NEEDED BY MONITOR>>

;DEFINE $ SYMBOLS INTERNAL TO DDT
OPDEF	NPEEK	[calli -136]	;virtual/physical peek with fail return
OPDEF 	DDTINT 	[Z 0,]		;address flag for internal registers
OPDEF	VPGSTS	[CALLI -71]

RADIX 10
NBP==8	;NUMBER OF BREAKPOINTS
IFN XMOD,<NBP=16>
DEFINE DBPNT (Z.)<XP $'Z.'B,<DDTINT B1ADR+4*Z.-4>>
ZZ==0
REPEAT NBP,<DBPNT \<ZZ==ZZ+1>>
RADIX 8

XP $M,<DDTINT MSK>
XP $I,<DDTINT SAVPI>

TABPRV==6		;GETTAB FOR JBTPRV

TYMEX==200		;BIT FOR TYMEX MODE

TTYMOD==-31		;GETTAB TO GET TTY MODE
;FRMOP DEFINITIONS

OPDEF FRMOP [044000,,0]

.FORVA==2		;READ VIRTUAL ADDRESS
.FOWVA==3		;WRITE VIRTUAL ADDRESS
.FOSAA==4		;START AT ABSOLUTE ADDRESS
.FOHLT==5		;HALT THE FRAME.
.FORPC==6		;READ PC
.FOHST==23		;READ HALT STATUS BLOCK
;OPDEFS FOR KS10 INSTRUCTIONS

	OPDEF	APRID	[700000000000]	;READ SERIAL NO, ETC.
	  KSMSK==30000		;IF THESE ON, ITS A KS.
	OPDEF	WRPI	[700600000000]	;CONO PI.
	OPDEF	RDPI	[700640000000]	;CONI PI.
	OPDEF	WRAPR	[700200000000]	;CONO APR.
	OPDEF	RDAPR	[700240000000]	;CONI APR.
	OPDEF	CLRPT	[701100000000]	;BLKO PAG.
	OPDEF	WREBR	[701200000000]	;CONO PAG.
	OPDEF	RDEBR	[701240000000]	;CONI	PAG.
	OPDEF	WRUBR	[701140000000]	;DATAO PAG.
	OPDEF	RDUBR	[701040000000]	;DATAI	PAG.

;DEFINE I/O DEVICE MNEMONICS

IFN XMOD,<
NXM==1B29
APRCLK==1B26
XTU==2
XFU==1
X.MEM==4
MAP.FL==1B18
MAP.W==1B20
MAP.M==1B22

TRPENB==1B22		;PAGING ON

;KL APR AND MAP INSTRUCTION FLAGS.

LP.IOR==1B19
LP.ESF==1B20
LP.DSF==1B21
LP.CSF==1B22
LP.SSF==1B23

LP.NXM==1B25
LP.PAR==1B27

SP.808==1B25		;INTERRUPT 8080
SP.NXM==1B27		;KS NXM
SP.PAR==1B28		;KS HARD PARITY ERROR

PFW.U==(1B0)		;USER/EXEC ADDRESS SPACE BIT
PFW.H==(1B1)		;"HARDWARE" REASON FOR PAGE FAIL.

;THE FOLLOWING DEFINITIONS APPLY IF PFW.H IS ZERO:

PFW.A==(1B2)		;COPY OF A BIT FROM MAP SLOT
PFW.W==(1B3)		;W BIT FROM MAP SLOT
PFW.S==(1B4)		;S BIT
PFW.T==(1B5)		;ON IF WRITE WAS ATTEMPTED.
			; (DOESN'T SAY THATS WHY IT FAILED, THOUGH.)
PFW.P==(1B6)		;PUBLIC BIT FROM MAP SLOT
PFW.C==(1B7)		;CACHE BIT
PFW.R==(1B8)		;PAGED REFERENCE (MAP INSTRUCTION)

DEFINE IOGLOB,<IF2,<
	;CALL THIS MACRO ON PASS2 AT END SO DDT CAN USE REGULAR IO CODES.
XP PAG,10B11
XP PI,4B11
XP PTP,100B11
XP PTR,104B11
XP CDR,114B11
XP TTY,120B11
XP LPT,124B11
XP DC,200B11
XP DIS,130B11
XP PLT,140B11
XP CR,150B11
XP TIM,20B11
XP MTR,24B11
XP DTE,200B11
XP DTE0,200B11
XP MTC,220B11
XP MTS,224B11
XP MTM,230B11
XP DLS,240B11
XP MDF,260B11
XP DTC,320B11
XP DTS,324B11
XP TMC,340B11
XP TMS,344B11	>
>;END IF2
>;END IOGLOB MACRO DEFINITION.

IFN FLDDT!XMOD,<
PC.UIO==1B24
PGE.W==1B20
PGE.A==1B18>

;DEFINE EXTENDED OPERATIONS

XP JOV,2554B11
XP JEN,2545B11
XP HALT,2542B11

IFE FLDDT,<
DDTX:
DDT:	JRST	[SETZM CCL	;remember - don't clobber any registers
		JRST .+2]
	 SETOM	CCL#
	IFN XMOD,<SETZM BCOMM>
	JSR SAVE
	PUSHJ P,REMOVB
IFE FRMDDT,<	PUSHJ P,CHKSYM>
>
	JRST	DD1	;GO TO PARSER
IFN FLDDT,<
DDT:	TDZA	1,1
	 SETO	1,
	MOVEM	1,CCL#		; flag to indicate CCL entry
>
RDSYMF:
IFN FLDDT!FRMDDT,<
	RELEAS CRS,
	MOVEI P,PS
	INIT CRS,17
	 SIXBIT .DSK.
	 Z
	 HALT .-3
IFN FLDDT,<E T,[JSR UUO0]
	MOVEM T,41>
	SETZM CODMOD
	SETZM WENB
	SETZM XPNFLG		;NOT AN EXPANDED CORE IMAGE
	SETZM CRASHS		;ASSUME NO CRASH (PEEK AT CURRENT MONITOR)
	SETOM HISIZ
	SETZM JSTFIL
	SETZM PRGM		;IN CASE ITS LEFT OVER FROM LAST TIME
IFN FLDDT,<
	OUTSTR [ASCIZ /Input file: /]
>
IFN FRMDDT,<
	OUTSTR [ASCIZ /Symbol file: /]
>
	PUSHJ P,FILNAM
	 JRST NOCRS1		;BAD FILE NAME
	SKIPE NOEXT
	SETOM JSTFIL
CRSLK:	PUSH P,W1
CRSLK2:	CAIN W1,12
	 JRST CRSLK1
	PUSHJ P,FILINC		;SKIP THROUGH LINE FEED
	JRST CRSLK2
CRSLK1:	POP P,W1
	CAIN W1,"X"		;should we exit?
	 JRST	[PUSHJ P,CMDCLS
		RESET
		EXIT ]		
	CAIN W1,"F"
	 SETOM JSTFIL
	CAIN W1,"C"
	 SETZM JSTFIL
	SKIPN CRASH
	 JRST MODSET		;IF NO FILE NAME, LOOK AT MON
	SKIPN NOEXT
	 JRST CKEXTN		;LOOK FOR EXTENSIONS
	LOOKUP CRS,CRASH
	 JRST NOCRS1
FNDFIL:	SETOM CRASHS
	USETI CRS,1
	INPUT CRS,RSILST
	STATZ CRS,740000
	HALT .-3
	SKIPE JSTFIL
	JRST .+3
	SKIPGE RSIDNT
	JRST SZXPN
	SETOM RSAVE
	HLRE T,CRASH+3
	JUMPGE T,BLKFD
	MOVNS T
	SKIPA
BLKFD:	IMULI T,200
	MOVEM T,FILSIZ
	JRST CKSYM
CKEXTN:	MOVSI T,'SAV'
	MOVEM T,CRASH+1
	PUSH P,CRASH+3
	LOOKUP CRS,CRASH
	 JRST TRYLOW
	POP P,T
	JRST FNDFIL
TRYLOW:	POP P,CRASH+3
	MOVSI T,'LOW'
	MOVEM T,CRASH+1
	PUSH P,CRASH+3
	LOOKUP CRS,CRASH
	 JRST NOLOW
	POP P,T
	EXCH T,CRASH+3
	PUSH P,T
	PUSHJ P,SRCHI
	 JFCL
	POP P,CRASH+3
	JRST FNDFIL

NOLOW:	POP P,CRASH+3
	SETOM FILSIZ
	PUSHJ P,SRCHI
	 JRST NOCRS1
	SETOM CRASHS
	JRST CKSYM

SRCHI:	INIT HCRS,17
	SIXBIT /DSK/
	Z
	HALT .-3
	MOVSI T,'SHR'
	MOVEM T,CRASH+1
	PUSH P,CRASH+3
	LOOKUP HCRS,CRASH
	 JRST TRYHGH
	POP P,T
HBKFND:	HLRE T,CRASH+3
	JUMPGE T,HBKFN1
	MOVNS T
	SKIPA
HBKFN1:	IMULI T,200
	MOVEM T,HISIZ
	SETOM HRSAVE
	AOS (P)
	POPJ P,
TRYHGH:	POP P,CRASH+3
	MOVSI T,'HGH'
	MOVEM T,CRASH+1
	LOOKUP HCRS,CRASH
	 POPJ P,
	JRST HBKFND

SZXPN:	MOVEI T,1
	MOVEM T,RSAVE	;BLOCK WE ARE ON
	MOVE T,[XPNTAB,,XPNTAB+1]
	SETZM	XPNTAB
	BLT	T,XPNTAB+XPNTBL-1	;CLEAR XPN MEMORY
	SETZM XPNFLR
	SETZM XPNCNT	;THE NUMBER OF WDS LEFT AND POSIT
	SETOM XPNFLG
	SETZB R,TT1	;HIGHEST SEEN, AND XPNTAB INDEX.
SZGET:	USETI CRS,@RSAVE
	INPUT CRS,XPNCOM
	MOVEI T,RSIDNT
	MOVE W,XPNCNT
SZLNK:	ADD W,T		;SEE WHERE NEXT IOWD IS
	CAILE W,RSIDNT+4777	;ARE WE BEYOND END?
	JRST SZBLK	;YES
	SKIPL (W)	;AN IOWD
	JRST SZLST	;NO, FOUND END
	MOVE T,W
	HLRE W,(T)	;GET SIZE
	MOVNS W
	HRRZ R,(T)	;AND LOCATION
	ADD R,W		;GIVES TOP WORD IN IOWD
	AOJA T,SZLNK	;TO FIRST WORD OF BLOCK

SZBLK:	ADDI TT1,1	;NEXT LOC IN XPNTAB.
	SUBI W,RSIDNT+5000	;GET COUNT IN NEXT BLOCK
	MOVEM W,XPNCNT
	HRLM W,XPNTAB(TT1)	;SAVE IN XPNTAB TOO.
	MOVEI T,1(R)	;FIND FIRST WORD OF THAT BLOCK
	SUB T,W
	HRRZM T,XPNFLR
	HRRM T,XPNTAB(TT1)	;SAVE FLR IN RH XPNTAB.
	MOVEI T,24
	ADDM T,RSAVE
	JRST SZGET

SZLST:	ADDI R,1
	HRRZM R,FILSIZ
	MOVEI	R,1
	MOVEM	R,RSAVE
	SETZM	XPNFLR
	SETZM	XPNCNT
	USETI	CRS,@RSAVE
	INPUT	CRS,XPNCOM
CKSYM:
IFE FRMDDT,<	CAIN W1,"S">
	JRST SYMSET	;GO SET SYMBOL TABLE
MODSET:	MOVEI W1,1000
	SETMOD W1,
	JRST DD1
NOCRS1:	CLRBFI
	OUTSTR [ASCIZ /?input file not found
/]
	JRST DDT		;TRY AGAIN

ENBWT:	SETCMM WENB
	SKIPE WENB
	OUTSTR [ASCIZ /
[write enabled]/]
	SKIPN WENB
	OUTSTR [ASCIZ /
[write disabled]/]
	JRST DD1		;ENABBLE FOR WRITTING
>;END IFN FRMDDT!FLDDT
IFN CMDFIL,<
NOCSH:	MOVEI T,0
	SETMOD T,
	OUTSTR [ASCIZ /
Commands file: /]
	PUSHJ P,FILNAM
	 JRST NOCMDF	;CAN NOT READ IT
	INIT CM,0
	 SIXBIT /DSK/
	 CBUF
	 JRST NOCMDF
	LOOKUP CM,CRASH
	 JRST NOCMDF
	SETOM COMAND
	JRST NOCMD2	;now have comands file open

NOCMDF:	OUTSTR [ASCIZ /?command file not found
/]
	SETZM COMAND
	RELEASE CM,
NOCMD2:	CLRBFI
	MOVEI T,1000	;break on punctuation
	SETMOD T,
	JRST DD1
>;END IFN CMDFIL
IFN CMDFIL,<
	array	TMPBF[4]

INRPG:	SETZM	CCL
	HRRZ	T,JOBFF##
	MOVEI	TT,-1(T)
	HRLI	TT,-200
	MOVEM	TT,TMPBF+1
	MOVSI	TT,(<SIXBIT /DDT/>)
	MOVEM	TT,TMPBF
	HRRM	T,CBUF+1
	ADDI	T,200		;CHECK TO SEE IF ENOUGH CORE
	CAMLE	T,JOBREL##
	 JRST	[IORI T,1777
		CORE T,
		 JRST	DDT
		JRST .+1]
	MOVE	T,[XWD 2,TMPBF]
	TMPCOR	T,		;GET THE FILE
	 JRST	RPGDSK		;NO, TRY DSK
	ADDM	T,JOBFF##	;REMEMBER NEW END OF WORLD
	IMULI	T,5		;GET NUMBER OF CHRS
	MOVEM	T,CBUF+2
	MOVSI	T,(<POINT 7,0>)	;SET INPUT POINTER
	HLLM	T,CBUF+1
	MOVEI	T,1
	MOVEM	T,COMAND	;COMAND .gt. 0 MEANS INPUT FROM TMPCOR
	POPJ	P,
RPGDSK:	INIT	CM,1		;GET THE COMMAND DEVICE
	 SIXBIT /DSK/
	 CBUF
	 JRST	DDT
	PJOB	TT,		;JOB NUMBER
	MOVEI	T,3		;NUMBER OF DIGITS
INRPG1:	IDIVI	TT,12		;CONVERT TO DECIMAL
	ADDI	TT1,20		;USING T1,T2,T3, WHICH MUST BE
	LSHC	TT1,-6		;CONTIGUOUS
	SOJG	T,INRPG1
	HRRI	TT2,(<SIXBIT /DDT/>)	;REST OF COMMAND FILE NAME
	MOVEM	TT2,TMPBF
	MOVSI	TT2,'TMP'	;EXTENTION
	MOVEM	TT2,TMPBF+1
	SETZM	TMPBF+3		;DEFAULT PPN
	LOOKUP	CM,TMPBF
	 JRST	DDT
	MOVE	T,[sixbit "DELETE"]
	MOVEM	T,COMAND	;flag to delete comand file when done
	POPJ	P,
>; CMDFIL

IFN CMDFIL!FLDDT,<

FILINC:	PUSH	P,T
	PUSHJ	P,TIN
	MOVEM	T,W1
	POP	P,T
	POPJ	P,

FILNAM:	SETZM CRASH
	SETZM NOEXT
	SETZM CRASH+1
	SETZM CRASH+3
	MOVE T,[INCHWL]
	HLLM T,TTYINS
	PUSHJ P,FILINC
	CAIN W1,"("
	JRST CKUNM
RFNM:	MOVEI T,6
	MOVE W,[POINT 6,CRASH]
	PUSHJ P,INSIX1		;READ NAME
	CAIE W1,"."		;IF AN EXT
	JRST CPOPJ1		;NO
	SETOM NOEXT
	MOVE W,[POINT 6,CRASH+1]
	MOVEI T,3
	PUSHJ P,INSIX
	JRST CPOPJ1

CKUNM:	SETZM UNM
	SETZM UNM+1
	MOVEI T,UNM
	MOVEM T,CRASH+3
	MOVE W,[POINT 6,UNM]
	MOVEI T,^D12
	PUSHJ P,INSIX
SRRP:	CAIN W1,")"
	JRST	[PUSHJ P,FILINC
		JRST RFNM]
	PUSHJ P,FILINC
	CAIL W1,40
	JRST SRRP
	POPJ P,

INSIX:	PUSHJ P,FILINC
INSIX1:	CAIE W1,"."
	CAIGE W1,40
	POPJ P,			;. OR TERMINATOR (I HOPE)
	CAIN W1,")"
	POPJ P,
	CAIN W1,"/"
	JRST [	PUSHJ P,FILINC
		CAIL W1,140
		  SUBI W1,40
		POPJ P,]
	SUBI W1,40
	CAILE W1,77
	SUBI W1,40		;THIS WILL CATCH LOWER CASE
	JUMPE W1,INSIX		;IGNORE SPACE (REALLY IGNORE THEM)
	SOJL T,INSIX		;NOT TOO MANY
	IDPB W1,W
	JRST INSIX
>;END IFN CMDFIL!FLDDT
REPEAT 0,<
HOW TO COPY MONITOR SYMBOL TABLE INTO FILDDT
1) USE FDDD10 TO LOAD AN UNRUN VERSION OF YOUR MONITOR
   AS SAVED AFTER BUILDING OR LOADING.
2) RENAME IT AS CRASH.SAV
3) LOAD A PRISTINE VERSION OF FILDDT AND START IT TO SET
   REENTER ADDRESS.
4) TYPE ^C   REENTER
5) FILDDT WILL EXPAND AS NECESSARY AND COPY THE SYMBOL
   TABLE FROM CRASH.SAV INTO ITSELF
6) AFTER CARRIAGE RETURN IS TYPED FILDDT IS DONE.
7) SAVE FILDDT WITH A NEW NAME SO AS NOT TO CONFUSE IT WITH THE
   ORIGINAL FILDDT.SAV

THE MONITOR CAN BE LOADED IN ANY OF THREE WAYS(IN ORDER OF PREFERENCE):
   1. UNDER TIME SHARING WITH REGULAR LOADER AND COMMON
   2. UNDER REGULAR 10/30 MONITOR WITH REGULAR 10/30 LOADER & COMMON
   3. UNDER SPECIAL 10/30 MONITOR(SPMON) WITH BUILD

THE 3 WAYS LEAVE DDTSYM(36),JOBSYM(116) & T30SYM(131) IN DIFFERENT STATES:

       DDTSYM          JOBSYM          T30SYM

   1.  JUNK            S.T.PTR         JUNK
   2.  JUNK            JUNK(NON-NEG)   S.T.PTR
   3.  S.T.PTR         S.T.PTR         JUNK
>

DDTSYM=36

T30SYM=131
IFN FRMDDT!FLDDT,<
EXTERNAL JOBFF,JOBREN

SYMSET:	MOVEI R,116
	PUSHJ P,FCHFIL
	JRST NOSYM
	JUMPGE T,NOSYM		;NOT A SYMBOL TABLE POINTER
REGT30:	MOVEM T,JOBSYM		;SAVE IT OVER OLD JOBSYM
	ADD T,LOCSYM
	HLRES T,T
	MOVMS T,T		;LENGTH OF SYMBOL TABLE
	MOVE W,JOBFF
	ADDI W,1300		;LEAVE SPACE FOR COMMAND & LPT BUFFERS
				; OR DSK BUFFERS AND EXTRA SYMBOL DEFNS.
	HRRZ W1,W		;SAVE LOC FOR COPY
	ADD W,T			;ADD TABLE LENGTH
	IORI W,1777		;REQUEST INTEGRAL # OF K.
	CORE W,			;GET CORE
	HALT			;UGH!
	MOVE R,JOBSYM		;WHEREABOUTS OF MONITOR SYMBOLS
	HRRM W1,JOBSYM		;NOW POINT TO FILDDT SYMBOLS
TCOPY:	PUSHJ P,FCHFIL		;GET A WORD
	JRST NOSYM
	MOVEM T,0(W1)		;STASH IT
	AOS W1
	AOBJN R,TCOPY
	MOVE R,LOCSYM
	MOVE T,(R)
	MOVEM T,(W1)
	ADDI W1,1
	AOBJN R,.-3
	HLLZ R,LOCSYM
	ADDM R,JOBSYM
	JRST DDT		;GO TRY IT

NOSYM:	OUTSTR [ASCIZ /
CAN NOT LOAD SYMBOLS FROM FILE
/]
	JRST DDT

LOCSYM:	XWD LOCEND-LOCSYS,LOCSYS

LOCSYS:	RADIX50 4,%%PAT
	PATCH
	RADIX50 4,%%FETU
	2B8
	RADIX50 4,%%FET
	1B8
	RADIX50 4,%%END
	3B8
	RADIX50	4,HALT
	HALT
LOCEND:
>
DD1:	PUSHJ P,CRF
DD1.5:	TLZ F,ROF		;CLOSE ANY OPEN REGISTER
	MOVE T,[XWD SCHM,SCH]
	BLT T,ODF		;LOAD ACS
DD2:	CLEARM PRNC		;PARENTHESES COUNT
	SETZM ARAYOK
	SETZM ARAYLP
	SETZM ARAYRS
	SETZM BYIDSP	;FLAG FOR BYTE INPUT
	MOVEI P,PS
LIS:	MOVE T,ESTU
	MOVEM T,ESTUT		;INIT UNDEFINED SYM ASSEM
	TDZ F,[XWD 777777-ROF-STF,LF1+CF1+SBF+2+Q2F]
LIS0:	TDZ F,[XWD 777777-ROF-STF-FAF-SAF,NAF]
	CLEARM,WRD
LIS1:	CLEARM,FRASE
	MOVE T,[INCHWL]
	HLLM T,TTYINS	;SET TO READ IN LINE MODE
LIS2:	MOVEI T,1
	MOVEM T,FRASE1
	TLZ F,MLF+DVF
L1:	TLZ F,CF+CCF+SF+FPF		;TURN OFF CONTROL, SYL, PERIOD FLAG
	CLEARM,SYL
L1RPR:	CLEARM,SYM
	MOVEI T,6
	MOVEM T,TEM		;INIT SYMBOL COUNTER
	MOVE T,[POINT 7,TXT]
	MOVEM T,CHP		;SETUP FOR OPEVAL SYMBOL
	MOVE T,[POINT 6,TXT6]
	MOVEM T,CHP6
	CLEARM,DEN
	CLEARM,WRD2
	SETZM WRD3	;ACCUMULATE OCTAL FOR $$#&
	SETZM TXT6

L2:	PUSHJ P,TIN		;PICK UP CHARACTER
	CAIL T,"A"+40		;LOWER CASE A
	CAILE T,"Z"+40		;LOWER CASE Z
	JRST .+2
	TRC T,40		;CHANGE LOWER CASE TO UPPER CASE
	TLNE F,CF		;CONTROL FLAG
	JRST L21
	CAIG T,"Z"		;Z
	CAIGE T,"A"		;A
	JRST .+2
	JRST LET
L21:	MOVE R,T
	CAILE T,137	;DISPATCH TABLE HAS ENTRIES ONLY .LE. 137
	JRST ERR
	IDIVI R,3		;REMAINDER GIVES COLUMN, QUOTIENT GIVES ROW
	LDB W,BDISP(R+1)	;GET 12 BIT ADDRESS FROM DISPATCH TABLE
DSPR2:	CAIGE W,MULT-DDT	;FIRST EVAL ROUTINE
	JRST DDT(W)
	MOVE T,SYL
	TLZN F,LTF
	JRST POWER
	MOVE T,[XWD OPEVAL,EVAL]	;GET ADDRESSES OF LOOKUP ROUTINES
	SKIPN WRD		;IF C(WRD)=0, CALL OPEVAL FIRST, OTHERWISE EVAL FIRST
	MOVSS T
	MOVEM T,SAVE
	JRST L213

L212:	HLRZS T,SAVE		;GET ADDRESS OF THE OTHER LOOKUP ROUTINE
	JUMPE T,UND1		;IF ADR=0, THEN SYMBOL UNDEFINED
L213:	PUSHJ P,(T)	;CALL OPEVAL OR EVAL
	JRST L212		;SYMBOL NOT FOUND
L4:	TLZE F,MF
	MOVN T,T
	TLNN F,SF
	CAIE W,LPRN-DDT
	JRST .+2
	JRST LPRN

	EXCH T,FRASE1
	TLNN F,DVF
	IMULB T,FRASE1
	TLZE F,DVF
	IDIVB T,FRASE1
	CAIGE W,ASSEM-DDT
	JRST DDT(W)		;MULTIPLY OR DIVIDE
	ADDB T,FRASE
	CAIGE W,SPACE-DDT
	JRST DDT(W)		; + - @ ,

	ADD T,WRD
	TLNE F,TIF		;TRUNCATE INDICATOR FLAG
	HLL T,WRD		;TRUNCATE
	MOVEM T,WRD
	TLNN F,QF
	MOVE T,LWT
	CLEARM,R
	MOVE W1,ESTUT
	CAMN W1,ESTU
	JRST L5
	CAILE W,CARR-DDT
	JRST ERR
L5:	CAIG W,RPRN-DDT
	JRST DDT(W)
	PUSH P,KILRET
	SKIPN PRNC
	JRST DDT(W)
	SKIPE ARAYRS	;/ IN ARRAY DEF IS SPECIAL
	CAIE W,SLASH-DDT
	SKIPA
	JRST ARYSLD

ERR:	MOVEI W1,"?"
	JRST WRONG1
UNDEF:	MOVEI W1,"U"
	JRST WRONG1
WRONG:	MOVE W1,[ASCII /XXX/]
WRONG1:	MOVEI P,PS
	PUSHJ P,TEXT
	PUSHJ P,LCT		;TYPE TAB
	PUSHJ P,LISTEN		;GOBBLE ANY INPUT CHARACTER
	JFCL
	JRST DD2
RET:	MOVEI P,PS
	PUSHJ P,LCT		;COMMON RETURN FOR TAB;,JRST LIS
	JRST DD2

UND1:	MOVE R,ESTUT		;UNDEFINED SYM ASSEMBLER
	PUSHJ P,EVAL2
	CAIN W,ASSEM-DDT
	TLNN F,ROF
	JRST UNDEF
	SKIPE PRNC
	JRST UNDEF
IFN HI,<PUSHJ P,WPSET>	;ALLOW WRITE
	MOVEI T,"#"
	CAIE W,ASSEM-DDT
	PUSHJ P,TOUT

	MOVN R,[XWD 2,2]
	ADDB R,ESTUT
	MOVE T,SYM
	TLO T,GLOBAL
	MOVEM T,(R)
	HRRZ T,LLOCO
	TLNE F,MF
	TLO T,400000
	MOVEM T,1(R)
	MOVEI T,0
	JRST L4

QUESTN:	IFE XMOD,<HRROI T,TABPRV
	GETTAB T,
	 MOVEI T,0
	TRNN T,TYMEX
	JRST QUEST0
	TLNN F,CF
	JRST WRONG>
QUEST0:	PUSHJ P,CRF		;LIST UNDEFINED SYMBOLS
	MOVE R,ESTU
QUEST1:	JUMPGE R,DD1
	MOVE T, (R)
	SKIPA W1,ESTU

QUEST2:	ADD W1,[XWD 2,2]
	CAME T,(W1)
	JRST QUEST2
	CAME R,W1
	JRST QUEST4
	PUSHJ P,SPT
	PUSHJ P,CRF
QUEST4:	ADD R,[XWD 2,2]
	JRST QUEST1
NUM:	ANDI T,17		;T HOLDS CHARACTER
	TLNE F,CF+FPF
	JRST NM1
	MOVE W,SYL
	LSH W,3
	ADD W,T
	MOVEM W,SYL
	MOVE W,DEN
	IMULI W,12		;CONVERT TO DECIMAL
	ADD W,T
	MOVEM W,DEN
	AOJA T,LE1A

PERC:	TRZE F,Q2F
	JRST BYTI
	SKIPA T,[47+101-13]
DOLLAR:	MOVEI T,46+101-13	;RADIX 50 $ TO BE
LET:	TLC F,SF+FPF		;EXPONENT IFF LTF'*FEF'*(T=105)*SF*FPF=1
	TLZN F,LTF+FEF+SF+FPF
	CAIE T,105		; E
	TLOA F,LTF
	TLOA F,FEF
	JRST LET1
	TLZN F,MF
	SKIPA W1,SYL
	MOVN W1,SYL
	MOVEM W1,FSV
	CLEARM DEN
LET1:	SUBI T,101-13		;FORM RADIX 50 SYMBOL
LE1A:	TLO F,SF+QF
LE2:	MOVE W,SYM
	MOVEI R,101-13(T)
	IMULI W,50		;CONVERT TO RADIX 50
	ADD W,T
	SOSGE TEM		;IGNORE CHARACS AFTER 6
	JRST L2
	MOVEM W,SYM
	CAIGE R,100	;WORRY ABOUT NUMBERS
	SUBI R,7
	IDPB R,CHP
	MOVEI T,-40(R)
	IDPB T,CHP6
	MOVEM W,SYM
	JRST L2
CHKSYM:	HLRZ T,ESTU
	SUB T,ESTU
	MOVE W,@SYMP
	ADD T,W		;IF THE TOP OF THE UNDEF TAB DOES
	TRNE T,-1	;NOT POINT TO BOTTOM OF REG SYM TAB
	HRRZM W,ESTU	;THEN RE-INIT UNDEF SYM TAB
CKSY1:	SKIPN T,PRGM	;IF NOT PRGM SET
	JRST NWPRG
	SUB T,W	;SEE IF SYM TBL POINT AND PRGM
	TSC T,T		;MATCH
	MOVE W1,PRGM
	XOR W1,W	;AND BOTH EVEN OR ODD
	TRNE W1,1
	JRST CKSY2
	SKIPN T
	SKIPL PRGM
	SKIPA
	POPJ P,
CKSY2:	SKIPN W,1(W)	;GET LINK
	JRST NWPRG	;NONE THERE
CKSY3:	SUB W,[2,,2]	;FIND THE BOTTOM OF THIS LINK
	MOVE T,(W)
	CAME T,[-1]
	JRST CKSY3
	JRST CKSY1	;HIT BOTTOM, SEE IF PRGM IS IN THIS LINK
NWPRG:	SETZM PRGM
IFN FAILSW,<SETZM BLOCK>
	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	HRRZ R,R
CKNM:	CAMN R,@SYMP
	POPJ P,		;RAN OUT OF SYMBOLS
	SUB R,[XWD 2,2]
	MOVE W,(R)	;GET SYMBOL NAME
	JUMPE W,CKNM
	CAMN W,[-1]	;IS IT A LINK?
	JRST	[SKIPN R,1(R)	;YES, GET NEW POINTER
		POPJ P,		;LOSE BIG IF NULL
		JRST CKNM]
	TLNN W,740000	;IS IT A PROGRAM NAME?
IFN XMOD,<IFE DDTST,<CAMN W,[RADIX50 0,EDDT]>>
IFN XMOD,<IFN DDTST,<CAMN W,[RADIX50 0,TEDDT]>>
IFE XMOD,<
IFE FLDDT,<IFE DDTST,<CAMN W,[RADIX50 0,UDDT]>
	IFN DDTST,<CAMN W,[RADIX50 0,TDDT]>>
IFN FLDDT,<CAMN W,[RADIX50 0,FILDDT]>>
	JRST CKNM	;EITHER DDT OR NOT A NAME, TRY AGAIN
FNDPRM:	MOVEM R,PRGM
IFE FAILSW,<POPJ P,
>
IFN FAILSW,<MOVEM W,SYM
	JRST SBLKST>
NUM1:	EXCH T,WRD3
	IMULI T,10
	EXCH T,WRD3
	ADDM T,WRD3
	EXCH T,WRD2		;FORM NUMBER AFTER $
	IMULI T,12
	ADDM T,WRD2
	TRO F,Q2F
	JRST L2

NM1:	TLNE F,CF
	JRST NUM1
	MOVEI W1,6		;FORM FLOATING POINT NUMBER
	AOS NM1A
NM1A:	MOVEI W2,0
	MOVSI R,201400
NM1A1:	TRZE W2,1
	FMPR R,FT(W1)
	JUMPE W2,NM1B
	LSH W2,-1
	SOJG W1,NM1A1
NM1B:	MOVSI W1,211000(T)
	FMPR	R,W1		;COMPUTE VALUE OF NEW DIGIT
	FADRB	R,FH		;ADD VALUE INTO FLOATING NO.
	MOVEM R,SYL
	AOJA T,LE1A

POWER:	TLNN F,FEF
	JRST L4		;NO EXPONENT
	CAIE W,PLUS
	CAIN W,MINUS
	TROE F,POWF
	TRZA F,POWF
	JRST (W)		; E+-

	MOVE W2,DEN
	CLEARM FRASE
	MOVEI W1,FT-1
	TLZE F,MF
	MOVEI W1,FT01
	SKIPA T,FSV
POW2:	LSH W2,-1
	TRZE W2,1
	FMPR T,(W1)
	JUMPE W2,L4
	SOJA W1,POW2
PERIOD:	MOVE T,LLOC
	TLNE F,SF		;SYLLABLE STARTED
	MOVE T,DEN
	MOVEM T,SYL
	TLNE	F,FPF		;HAS A PERIOD BEEN SEEN BEFORE?
	TLO	F,LTF		;YES, TWO PERIODS MAKES A SYMBOL
	TLON F,FPF+SF+QF
	MOVEI T,0
	IDIVI T,400
	SKIPE T
	TLC T,243000
	TLC W1,233000
	FAD	T,[0]		;NORMALIZE T AND W1
	FAD	W1,[0]
	FADR	T,W1
	MOVEM T,FH
	HLLZS NM1A
	MOVEI T,45		;RADIX 50 PERIOD
	JRST LE2

QUAN:	TLNE F,CCF	;IS IT DOUBLE ALTMODE??
	JRST QUANSW	;YES
	MOVE T,LWT
	JRST QUAN1

PILOC:	MOVEI T,SAVPI		;ADR SETUP FOR $I
QUANIN:	TLOA T,(DDTINT)		;MARK FOR ADR INTERNAL TO DDT
QUANSW:	MOVS T,LWT	;SET FOR SWAPPED $Q
QUAN1:	MOVEM T,SYL
QUAN2:	TLO F,SF+QF		;WRD,SYL STARTED
	TLZ F,CF+CCF
	MOVE T,[INCHWL]
	HLLM T,TTYINS	;SET TO READ IN LINE MODE AGAIN
	JRST L2

CONTRO:				;SOME KIND OF ALTMODE
IFN XMOD,<	MOVEI T,"$"	;$
	SKPUSR
	PUSHJ P,TOUT		;TYPE OUT $
>
	TLOE F,CF
	TLO F,CCF
	SKIPE BYIDSP
	JRST @BYIDSP	;HANDLE BYTE INPUT
	PUSH P,[INCHRW T]	;MUST NOW READ CHR AT A TIME
	POP P,TTYINS
	JRST L2

SEMIC:	IFE XMOD,<HRROI A,TABPRV
	GETTAB A,		;CHECK HIS JBTPRV ENTRY
	 MOVEI A,0
	TRNE A,TYMEX
	JRST CONTROL	;IN TYMEX MODE, LINE ALTMODE>
	MOVEI W,SEMIC1-DDT
	JRST DSPR2		;SO EVAL WILL HAPPEN
IFN FAILSW,<
EVAL:	MOVEI W1,0
	SKIPL R,TBLK
	JRST EVL1
	SETZM TBLK
	JRST EVL2
EVL1:	SKIPL R,BLOCK
	JRST EV5
EVL2:	MOVE T,1(R)
	MOVEM T,BLVL
EVL3:	MOVEM R,FRSTR
	JRST EV11

EV3:	CAMN R,@SYMP
	JRST EV4
EV1:	CAMN R,FRSTR
	POPJ P,		;BACK WHERE WE STARTED
EV11:	SUB R,[XWD 2,2]
	SKIPN T,(R)
	JRST EV11
	CAMN T,[-1]
	JRST EV4A	;LINK
	TDNE T,W1
	JRST EV3
	LDB T,[POINT 4,(R),3]
	CAIN T,3
	JRST EV2
	SKIPN T
	TLOA W1,LOCAL
	SKIPA T,(R)
	JRST EV3
	XOR T,SYM
	TDNE T,[XWD 37777,777777]	;NAMES MATCH??
	JRST EV3
	MOVE W1,T
	MOVE T,1(R)
	TLNE W1,200000	;ARRAY REF??
	HRRZ T,(T)
	MOVEM R,ARAYOK
	JRST CPOPJ1	;AND EXIT

EV4A:	SKIPE R,1(R)	;PICK UP LINK
	JRST EV3	;JUMP IF GOOD ONE
EV4:	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	HRRZ R,R
	JRST EV1

EV2:	MOVE T,1(R)
	CAMGE T,BLVL
	JRST EV2A
EV2B:	SUB R,[XWD 2,2]
	LDB T,[POINT 4,(R),3]
	CAIE T,3
	JRST EV2B
	JRST EV2
EV2A:	MOVEM T,BLVL
	JRST EV3

EV5:	MOVEI T,1
	MOVEM T,BLVL
	SKIPL R,TPRG	;TEMP PROGRAM NAME
	SKIPGE R,PRGM
	JRST EV1A
	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	HRRZ R,R
	JUMPE R,CPOPJ	;NO SYMBOLS
	JRST EVL3

EV1A:	SETZM TPRG
	JRST EVL3
>

CTLA:	MOVEI T,"$"
	PUSHJ P,TOUT
	PUSHJ P,TOUT
	MOVEI T,":"
	PUSHJ P,TOUT
	TLO F,CCF!CF
	JRST TAG
IFE FAILSW,<EVAL:	SKIPL R,TPRG	;TEMP NAME
	MOVE R,PRGM		;LOOK UP SYMBOL>
EVAL0:	HRLOI W1,37777
	JRST EVAL3

EVAL1:	ADD R,[XWD 2,2]
EVAL2:	JUMPGE R,CPOPJ
EVAL3:	MOVE T,(R)
	XOR T,SYM
	TLNN T,PNAME
	TLOA W1,LOCAL
	TDNE T,W1
	JRST EVAL1
	TLNN T,340000
	JRST EVAL1
	MOVE W1,T
	MOVE T,1(R)
	TLNE W1,200000
	HRRZ T,(T)
	MOVEM R,ARAYOK
CPOPJ1:	AOS (P)		;FOUND SYMBOL, SKIP
CPOPJ:	POPJ P,

;BIT 40 - DELETE OUTPUT
; 20 - DELETE INPUT
; 10 - LOCAL
; 04 -GLOBAL
; NO BITS - PROGRAM NAME

TEXI:	MOVE T,[INCHWL]	;OK TO READ IN LINE MODE
	HLLM T,TTYINS
	PUSHJ P,TEXIN		;INPUT TEXT
	MOVEM T,SYL
	MOVEI W1,5
	MOVEI T-1,0
	PUSHJ P,TEXIN
	TLNE F,CCF	;IF DOUBLE ALTMODE
	JRST TEXI4	;SPECIAL CHECK
	CAIN T,33		;NEW ALT MODE, ESCAPE
	JRST QUAN2
TEXI4:	TLNN F,CCF
	JRST TEXI5	;NOT DOUBLE ALTMODE
	MOVE R,WRD2
	CAIE R,7
	JRST SIXBIN
	JRST TEXI6	;SIXBIT OR ASCII
TEXI5:	TLNE F,CF
	JRST SIXBIN
	SKIPA
TEXI2:	PUSHJ P,TEXIN
TEXI6:	CAMN T,SYL
	SOJA W1,TEXI3
	ROT T,-7
	LSHC T-1,7
	SOJG W1,TEXI2
	TLNN F,CCF	;DOUBLE IS SPECIAL
	JRST TEXI2
	LSHC T-1,-43
	PUSH P,F
	TLZ F,CF
	TLO F,QF
	PUSHJ P,DEPRA	;DEPOSIT IT
	POP P,F
	AOS LLOCO	;INCREASE LOCATION
	MOVEI T-1,0
	MOVEI W1,5
	JRST TEXI2	;ACCUMULATE MORE

TEXI3:	LSHC T-1,-43
	JUMPL W1,TEXI7
	JUMPL W1,QUAN1	;DONE SHIFTING
	LSH T,7
	SOJA W1,.-2
TEXI7:	TLNN F,CCF
	JRST QUAN1
	LSHC T-1,-43	;MAKE SURE A ZERO IS STORED
	PUSH P,F
	TLZ F,CF
	TLO F,QF
	PUSHJ P,DEPRA
	POP P,F
	AOS LLOCO
	MOVEI T,0
	JRST QUAN1
SIXBI1:	PUSHJ P,TEXIN    ; INPUT TEXT (SIXBIT)
SIXBIN:	CAMN T,SYL
	JRST SIXBI2
	CAIL T,"A"+40		;IS CHAR BETWEEN LOWER CASE "A" AND
	CAILE T,"Z"+40		; LOWER CASE "Z"?
	SKIPA			;NO
	TRC T,40		;YES, CONVERT TO UPPER CASE
	CAIL T," "		;IS CHAR IN SIXBIT SET?
	CAILE T,"_"
	JRST ERR		;NO
	ANDI T,77		;YES, MASK TO 6 BITS
	TRC T,40		;CONVERT TO SIXBIT FORM
	ROT T,-6
	LSHC T-1,6
	SOJGE W1,SIXBI1
	TLNN F,CCF	;SPECIAL FOR DOUBLE ALTMODE
	JRST SIXBI1
	MOVE T,T-1
	PUSH P,F
	TLZ F,CF
	TLO F,QF
	PUSHJ P,DEPRA
	POP P,F
	AOS LLOCO
	MOVEI T-1,0
	MOVEI W1,5
	JRST SIXBI1
SIXBI2:	MOVE T,T-1
	JUMPL W1,QUAN1
	LSH T,6
	SOJA W1,.-2

KILL:	TLNN F,LTF		;DELETE SYMBOLS
	JRST ERR
IFN HI,<PUSHJ P,WPSET>
	PUSHJ P,EVAL
	JRST KILL1
	MOVEI T,DELO/200000		;DELETE OUTPUT
	TLNE F,CCF
	SETZM (R)	;MAKE NAME NOT MATCH ANYTHING
	DPB T,[POINT 2,(R),1]	;LEFT 2 BITS IN SYMBOL
KILRET:	JRST RET		;USED AS A CONSTANT

KILL1:	MOVE R,ESTU		;REMOVE UNDEFINED SYMS
	JUMPGE R,UNDEF
KILL2:	PUSHJ P,EVAL0
	JRST RET
	PUSHJ P,REMUN
	JRST KILL2

REMUN:	MOVE S,[XWD 2,2]	;REMOVE ONE UNDEFINED SYMBOL
	ADDB S,ESTU
	MOVE W,-2(S)
	MOVEM W,(R)
	MOVE W,-1(S)
	MOVEM W,1(R)
	POPJ P,
TAG:	TLNE F,FAF   ; DEFINE SYMBOLS
	JRST DEFIN		;A<B:
	TLNE F,CF		;DEFINE SYMBOL AS OPEN REGISTER
	JRST SETNAM
	MOVE W,LLOCO
	HRRZM W,DEFV

DEFIN:	TLNN F,LTF	;NO LETTERS IS ERROR
	JRST ERR
	PUSHJ P,EVAL		;DEFINED SYMBOL?
	JRST DEF1		;NO - DEFINE
	MOVE T,(R)
	TLNE T,PNAME		;DO NOT REDEFINE PROGRAM NAME
	JRST DEF2		;YES, REDEFINE
DEF1:	MOVN R,[XWD 2,2]
	ADDB R,@SYMP	;MOVE UNDEFINED TABLE 2 REGISTERS
	HRRZ T,ESTU
	SUBI T,2
	HRL T,ESTU
	HRRM T,ESTU
	SKIPGE ESTU
	BLT T,-1(R)
	MOVE T,2(R)
	AOJN T,DEF2	;JUMP IF BOTTOM ENTRY NOT A LINK
	SETOM (R)	;IT IS A LINK, MOVE IT DOWN
	MOVE T,3(R)
	MOVEM T,1(R)
	ADD R,[XWD 2,2]	;AND POINT ABOVE IT
DEF2:	MOVE T,DEFV
	MOVEM T,1(R)		;PUT IN NEW VALUE
	MOVSI T,GLOBAL
	IORB T,SYM
	MOVEM T,(R)		;PUT IN NEW SYM AS GLOBAL
	MOVE R,ESTU

DEF3:	JUMPGE R,RET		;PATCH IN VALUE FOR UNDEF SYM ENTRY
	MOVE T,SYM
	CAME T,(R)
	JRST DEF4
	MOVE S,DEFV
	SKIPGE, 1(R)
	MOVN S,S
	PUSH P,R
	MOVE R,1(R)
	PUSHJ P,FETCH
	JRST ERR
	ADD S,T
	HRRM S,T
	PUSHJ P,DEP
	 JFCL
	POP P,R
	PUSHJ P,REMUN
DEF4:	ADD R,[XWD 2,2]		;REMOVE THE NOW DEFINED SYMBOL
	JRST DEF3
IFN FAILSW,<
SETNAM:	TLNN F,LTF
	JRST TELNAM	;NO NAME GIVEN, TYPE CURRENT NAME
	HLRE R,@SYMP
	MOVN R,R
	ADD R,@SYMP
	HRRZ R,R	;POINT TO TOP OF SYMBOL TABLE
SET1:	CAMN R,@SYMP
	JRST UNDEF	;RAN OUT
	SUB R,[XWD 2,2]	;OK, GET NEXT ENTRY
	MOVE T,(R)
	CAMN T,[-1]
	JRST	[SKIPN R,1(R)	;LINK, GET NEXT POINTER
		JRST UNDEF	;LOSE IF NONE
		JRST SET1]
	CAME T,SYM
	JRST SET1
SET2:	TLNE F,CCF
	JRST SET2A	;SET AS TEMP
	MOVEM R,PRGM
	SETZM BLOCK
	PUSHJ P,SET3
	JRST RET
SBLKST:
SET3:	CAMN R,@SYMP
	POPJ P,
	SUB R,[XWD 2,2]
	MOVE T,(R)
	CAMN T,[-1]
	POPJ P,		;QUIT IF LINK
	LSH T,-^D32	;GET CODE BITS
	JUMPE T,CPOPJ
	CAIE T,3
	JRST SET3
	MOVE T,(R)
	XOR T,SYM
	TLZ T,740000
	JUMPN T,SET3
	TLNE F,CCF
	JRST NOTB
	MOVEM R,BLOCK
	POPJ P,

SET2A:	MOVEM R,TPRG
	SETZM TBLK
	PUSHJ P,SET3
	TLZ F,CF!CCF!LTF
	JRST L1RPR
NOTB:	MOVEM R,TBLK
	POPJ P,

SETBK1:	SKIPL R,TPRG
	SKIPGE R,PRGM
	SKIPA
	JRST ERR
SB1:	CAMN R,@SYMP
	JRST UNDEF
	SUB R,[XWD 2,2]
	MOVE T,(R)
	CAMN T,[-1]
	POPJ P,		;QUIT IF LINK
	LSH T,-^D32
	JUMPE T,UNDEF
	CAIE T,3
	JRST SB1
	MOVE T,(R)
	XOR T,SYM
	TLZ T,740000
	JUMPN T,SB1
	TLNE F,CF
	JRST SBPRM
	MOVEM R,TBLK
	JRST L1RPR
SBPRM:	MOVEM R,BLOCK
	JRST RET
>

SETBLK:	TLZN F,LTF	;MUST BE A NAME TYPED
	JRST ERR
	TLNN F,CCF	;DOUBLE ALTMODE FOR RADIX50
IFN FAILSW,<JRST SETBK1>
IFE FAILSW,<JRST ERR>
	TRNE F,Q2F	;GET A NUMBER IF PRESENT
	SKIPA T,WRD3
	MOVEI T,0
	ANDI T,74	;ONLY IMPORTANT BITS
	ROT T,-6	;INTO CODE BITS
	IOR T,SYM	;AND RADIX50 FOR NAME
	JRST QUAN1

TELNAM:	SKIPL W1,PRGM	;GET PROGRAM NAME PTR
	JRST ERR
	PUSHJ P,LCT
	PUSHJ P,SPT1W	;TYPE NAME
	JRST RET
IFE FAILSW,<
SETNAM:	MOVE R,@SYMP		;SET PROGRAM NAME - DOLLAR COLON
SET1:	MOVE W,R
SET2:	JUMPGE R,UNDEF
	MOVE T,(R)
	ADD R,[XWD 2,2]
	TLNE T,PNAME
	JRST SET2
	CAME T,SYM
	JRST SET1
	JRST SET2A
	MOVEM W,PRGM
	JRST RET

SET2A:	MOVEM W,TPRG
	TLZ F,CF!CCF!LTF
	JRST L1RPR>

;***ROUTINES BEYOND HERE EVALUATE THEIR ARGUMENT***
MULT:	TLOA F,PTF+MLF		;*
DIVD:	TLO F,DVF+PTF		;SINGLE QUOTE
	JRST L1

ASSEM:	JRST PLUS		;#
MINUS:	TLO F,MF
PLUS:	TLO F,PTF
	JRST LIS2

LPRN:	SKIPE S,ARAYOK	;IS THIS ARAY
	JRST DOARY	;YES
LPRN1:	CAML P,[XWD LPDL-4,0]	;LEFT PARENTHESIS
	JRST ERR
LPRT1:	PUSH P,F		;RECURSE FOR OPEN PAREN
	PUSH P,WRD
	PUSH P,FRASE
	PUSH P,FRASE1
	AOS,PRNC
	JRST LIS

INDIRECT:	HRLZI W,20		;@
	IORB W,WRD
	TLO F,QF
	JRST LIS2

ACCF:	MOVE R,T		;COMMA PROCESSOR
	TLOE F,COMF	;WAS IT DOUBLE
	JRST ACCCF	;YES
	ADD T,WRD	;ACCUMULATE FOR S 40,,S
	SKIPE BYIDSP
	JRST @BYIDSP	;HANDLE BYTE INPUT
	SKIPE ARAYLP
	JRST ARYEL	;GO CALC ARRAY LOC
	HRRM T,ACCCF	;SAVE IT
	HLLZ T,R
	SETZ	W1,		;CLEAR W1
	SKIPE	KSFLAG		;SPECIAL CASE IO INS FOR KS
	JRST	ACCF1		; AND DON'T PROCESS DEVICE FIELD
	LDB W1,[POINT 3,WRD,2]	;CHECK FOR IO INSTRUCTION
	IDIVI W1,7
ACCF1:	LSH R,27(W1)
	ADD T,R
	ADDB T,WRD
	JRST SPACE+1
BYTI:	TLZ F,CF	;NURN OFF ALTMODE FLAG FOR FINISH OF OP
	SKIPN T,WRD2	;GET NUMBER OF BITS/BYTE
	JRST BYTIM	;IF ZERO THEN USE BYTE MASK
	MOVEM T,SVBTI	;SAVE
	SETZM SVBTI1	;ASSEMBLED WORD
	MOVEI T,^D36	;TOTAL NUMBER OF BITS
	MOVEM T,SVBTI2
	MOVEI T,BYTI1
	MOVEM T,BYIDSP	;SET UP TO COME BACK ON , OR $
	JRST LPRN1

BYTI1:	TLZE F,CF
	JRST	[MOVEI W,BYTI2-DDT
		JRST DSPR2]	;TO FORCE EVAL
	PUSHJ P,BYTI1A
	JRST LIS
BYTI1A:	MOVE T+1,T	;VALUE IN T
	MOVN T+2,SVBTI	;GET SIZE
	ROT T+1,(T+2)	;GET THAT MANY BITS INTO LEFT END
	MOVE T,SVBTI1	;NOW THE PARTIALLY ASSEMBLED WORD
	MOVE T+2,SVBTI	;SIZE
	CAMLE T+2,SVBTI2	;MORE THAN WE NEED?
	MOVE T+2,SVBTI2	;YES, TAKE SMALLER
	LSHC T,(T+2)	;SHIFT BITS IN
	MOVNS T+2	;UPDATE NUUMBER OF BITS STILL NEEDED
	ADDM T+2,SVBTI2
	MOVEM T,SVBTI1	;SAVE WORD
	POPJ P,
BYTI2:	PUSHJ P,BYTI1A
	MOVE T,SVBTI1	;GET WORD
	LSH T,@SVBTI2	;SHIFT REST OF WAY
	SETZM BYIDSP
	JRST RPRN2	;GO PUT IT AWAY
BYTIM:	MOVEI T,^D36	;36 BITS TOTAL
	MOVEM T,SVBTI	;SAVE FOR INPUT CHECK
	SETZM SVBTI1	;BUILD WORD HERE
	MOVE T,BMASK	;GET MASK BITS
	MOVEM T,BYTMSK
	MOVEI T,BYTIM1
	MOVEM T,BYIDSP
	JRST LPRN1

BYTIM1:	TLZE F,CF
	JRST	[MOVEI W,BYTIM6-DDT
		JRST DSPR2]
	PUSHJ P,BYTIM4
	JRST LIS
BYTIM4:	SKIPG SVBTI	;ROOM FOR MORE?
	POPJ P,	;NO, QUIT
	MOVE T+1,T
	SETZM SVBTI2	;COUNT NUMBER OF BITS THIS POSITION
	SKIPL T+2,BYTMSK	;START WITH 1 BITS IN LEFT
	SETCA T+2,0	;COMPLIMENT
BYTIM5:	LSH T+2,1	;GET NEXT BIT
	ROT T+1,-1	;MOVE ANOTHHER BIT OF NUMBER TO LEFT END
	AOS SVBTI2	;SAVE COUNT
	SOSLE SVBTI	;CHECK TO SEE IF WORD FULL
	JUMPL T+2,BYTIM5	;NEXT BIT PART OF SAME FIELD?
	MOVE T,SVBTI1	;NO, GET WORD
	LSHC T,@SVBTI2	;SHIFT CORRECT NUMBER OF BITS
	MOVEM T,SVBTI1	;AND SAVE AGAIN
	MOVEM T+2,BYTMSK
	POPJ P,		;RETURN

BYTIM6:	PUSHJ P,BYTIM4	;PROCESS LAST NUMBER TYPED
	MOVE T,SVBTI1	;GET WORD
	LSH T,@SVBTI	;FINISH  SHIFTING
	SETZM BYIDSP
	JRST RPRN2	;ALL DONE
SVBTI:	0
SVBTI1:	0
SVBTI2:	0
BYIDSP:	0
BYTMSK:	0
ACCCF:	MOVSI T,.-.
	MOVEM T,WRD
	JRST SPACE+1

SPACE:	TLNE F,QF
	TLO F,TIF
	TLZ F,MF+PTF
	JRST LIS1

RPRN:	SKIPE S,ARAYLP
	JRST ARYFIN
	TLNN F,QF		;)
	MOVEI T,0
	MOVS T,T
RPRN2:	SOSGE,PRNC
	JRST ERR
	POP P,FRASE1
	POP P,FRASE
	POP P,WRD
	POP P,F
	TLNE F,PTF
	TLNE F,SF
	JRST RPRN1
	MOVEM T,SYL
	TLO F,QF+SF
	JRST L1RPR
RPRN1:	ADDB T,WRD
	TLO F,QF
	JRST L1RPR-1

DOARY:	SKIPE ARAYLP
	JRST ERR	;ONE ALREADY IN PROGRESS
	TLNE F,CF
	JRST ARAYDF	;GO DEFINE AN ARAY
	MOVE T,(S)	;CHECK TO SEE IF AN ARAY
	TLNN T,200000
	JRST LPRN1	;NO, SO GO ON
	MOVE S,1(S)	;GET POINTER TO ARRAY INFO
	MOVEI T,@(S)	;GET TRUE ADDRESS
	SUB T,(S)	;MINUS FAKE ADDRESS
	HRREM T,ARAYNM	;SAVE AS BASE
	ADDI S,1
	HRLI S,(POINT 18,)
	MOVEM S,ARAYLP	;SET UP BYTE POINTER FOR MULTS
	SETZM ARAYOK
	JRST LPRT1	;AND GO

ARYEL:	SKIPE ARAYRS	;IS THIS DEF
	JRST ARYDFC	;YES
	ILDB S,ARAYLP	;GET MULTIPLIER
	JUMPE S,ERR	;OUT OF SUBSCRIPTS TOO SOON
	IMUL T,S
	ADDM T,ARAYNM	;ACCUM
	JRST LIS	;GO ON

ARYFIN:	SKIPE ARAYRS	;DEF??
	JRST ARYDFN
	ILDB S,ARAYLP
	JUMPE S,ERR	;OUT OF SUBSCRIPTS TOO SOON
	IMUL T,S
	ADDM T,ARAYNM
	ILDB T,ARAYLP
	JUMPN T,ERR	;NO ENOUGH
	ILDB T,ARAYLP
	ADD T,ARAYNM	;THE NUMBER
	HRRES T		;EXTEND
	SETZM ARAYLP
	JRST RPRN2

ARAYDF:	HLRE T,ARSP	;GET POINTER TO FREE SPACE
	ADDI T,1
	JUMPGE T,ERR	;NO ENOUGH ROOM
	ROT T,1		;MULTIPLY BY 2 AND ADD 1
	MOVEM T,ELCNT	;SAVE AS AMOUNT OF HALF-WORD SPACE
	MOVE S,ARAYOK
	SETZM ARAYOK
	MOVE W,(S)
	HRRZ T,1(S)	;THE ADDRESS
	TLNE W,200000
	HRRZ T,(T)	;IN CASE OF REDEF OF AN ARAY
	MOVEM S,ARAYRS	;SAVE FOR FINISH
	TLNE F,CCF
	HRLI T,(Z @)	;IN CASE IN SUBROUTINE AND ARRAY IS ARG
	HRRZ S,ARSP	;GET READY TO PUT IT IN
	MOVEM T,(S)	;THE ADDRESS
	HRLI S,(POINT 18,0,35)	;SO WE WILL INDEX WORD NEXT TIME
	MOVEM S,ARAYLP
	MOVEI T,1
	MOVEM T,ARYLOW	;ASSUME LOWER BOUND OF 1
	MOVEM T,ARMLT	;MULTIPLIER SO FAR
	IDPB T,ARAYLP	;FIRST MULT
	SETZM ARAYNM
	JRST LPRT1

ARYSLD:	MOVEM T,ARYLOW	;A LOWER BOUND
	JRST LIS

ARYDFC:	SOSL ELCNT	;ENOUGH ROOM??
	JRST ERR
	SUB T,ARYLOW
	ADDI T,1	;SIZE
	IMUL T,ARMLT	;NEXT MULT
	IDPB T,ARAYLP
	EXCH T,ARMLT	;SAVE MULT
	IMUL T,ARYLOW
	ADDM T,ARAYNM
	MOVEI T,1
	MOVEM T,ARYLOW
	JRST LIS

ARYDFN:	SOSL ELCNT
	JRST ERR
	MOVEI T,0	;END OF MULTS
	IDPB T,ARAYLP
	MOVE T,ARYLOW
	IMUL T,ARMLT
	ADD T,ARAYNM
	MOVNS T
	SOSL ELCNT
	JRST ERR
	IDPB T,ARAYLP	;SAVE OFFSET
	MOVE S,ARAYRS
	MOVSI T,200000
	IORM T,(S)	;MARK AS ARAY
	HRRZ T,ARSP
	MOVEM T,1(S)	;POINT TO US
	AOS T,ARAYLP
	SUB T,ARSP
	HRLS T
	ADDM T,ARSP
	JRST DD1	;GO (WILL RESET ARAYLP
;REGISTER EXAMINATION LOGIC

LINEF:	PUSHJ P,DEPRA	;NEXT REGISTER
IFN XMOD,<SKPUSR
	JRST LI0>
	PUSHJ P,CRNRB
	JRST .+2
LI0:	PUSHJ P,CRF
	AOS T,LLOC
LI1:		;PUSHJ P,LINCHK		;TRUNCATE ADRS (UNLESS INSIDE DDT)
	HRRZM T,LLOC
	HRRZM T,LLOCO
IFN XMOD!FLDDT,<HLLZ W1,USRSAV
	HLLZM W1,USRNOW		;SET USER MAPPING FLAG>
	PUSHJ P,PAD
IFN XMOD!FLDDT,<MOVEI T,"$"
	SKIPGE USRNOW
	PUSHJ P,TOUT>
	MOVEI T,"/"
	TLNE F,STF
	MOVEI T,"!"
	PUSHJ P,TOUT
LI2:	TLZ F,ROF
	PUSHJ P,LCT
	MOVE R,LLOCO
	PUSHJ P,FETCHU
	JRST ERR
	TLO F,ROF
	TLNE F,STF
	JRST DD2
	JRST CONSYM		;RETURN IS A POPJ

REPEAT 0,<
LINCHK:	CAML T,[DDTINT SAVPI]	;TRUNCATE ADDRESSES
	CAMLE T,[DDTINT BNADR+2]
	HRRZS T
	MOVEM T,LLOC
	MOVEM T,LLOCO
	POPJ P,
>

VARRW:	PUSHJ P,DEPRA		;^
	PUSHJ P,CRF
	SOS T,LLOC
	JRST LI1

CARR:	PUSHJ P,DEPRA		;CLOSE REGISTER
	IFN XMOD,<SKPUSR
	JRST DD1>
		PUSHJ P,TIN
	CAIN T,15
	JRST .-2
	JRST DD1.5

OCON:	TROA F,LF1+CF1		;OPEN AS CONSTANT
OSYM:	TRZ F,CF1		;OPEN SYMBOLICALLY
	TROA F,LF1
SUPTYO:	TLOA F,STF		;SUPPRESS TYPEOUT
SLASH:	TLZ F,STF		;TYPE OUT REGISTER
	PUSHJ P,SETADR
	 JRST ERR
	TLNN F,QF		;WAS ANY QUANTITY TYPED?
	JRST SLAS1		;NO. DO NOT CHANGE MAIN SEQUENCE
	MOVE R,LLOC		;YES. SAVE OLD SEQUENCE AND
	MOVEM R,SAVLOC
IFN XMOD!FLDDT,<MOVSS USRSAV
	HLLM T,USRSAV>
	HRRZM T,LLOC	;PUSHJ P,LINCHK		;TRUNCATE ADRS- SET UP NEW SEQUENCE
SLAS1:	HRRZM T,LLOCO
IFN XMOD!FLDDT,<HLLZM T,USRNOW>
	JRST LI2

ICON:	TLNN F,ROF	;REGISTER OPENED OR ERR
	JRST ERR
	PUSHJ P,DEPRS
	PUSHJ P,SETADR
	 JRST ERR
	JRST SLAS1
SETADR:	TLNN F,CF
	TLZA T,-1	;WILL NOT NEED LEFT HALF. GET RID OF IT
IFN XMOD!FLDDT,<SKIPA R,WRD2	;GET READY TO DISPATCH>
IFE XMOD!FLDDT,<JRST EFFECA	;IN USER, MUST BE EFFECTIVE ADR>
	JRST CPOPJ1	;DONE
IFN XMOD!FLDDT,<
	CAIL R,MAXADR
	POPJ P,		;ERROR
	XCT ADRTAB(R)
	JRST CPOPJ1

ADRTAB:	JRST EFFECA	;$X OR $0X, EFFECTIVE ADDRESS
	HRROS T		;$1X USER MODE
	JRST ADRCON	;$2X FOR XCT XTU,[MOVE 1,ZOT]
	JRST ADREXC	;$3X REALLY FOR = EXEC ADR
MAXADR==.-ADRTAB

ADRCON:	PUSHJ P,EFFECA
	 POPJ P,	;ERROR
	HRRZ R,T	;GET CONTENTS
	PUSHJ P,FETCH
	 POPJ P,
	PUSHJ P,EFFECA
	 POPJ P,
	HRROS T		;NOW SET TO USER MODE
	JRST CPOPJ1

ADREXC:	PUSHJ P,EFFECA
	 POPJ P,
	MOVE R,T
	PUSHJ P,MAPEXC	;DO AN EXEC MAP
	 POPJ P,	;NOT REAL
	JRST CPOPJ1>

IFN XMOD,<
MAPEXC:	MAP R,(T)
PRINTX FOONLY HACK MACRO DEF HERE.
MAPCOM:	SKIPE	KLMAPF		;KL STYLE MAP?
	JRST	[TLNN	R,PFW.R	;MAPPED REF?
		JRST	MAPCM1	;NO, OK
		TLNN	R,PFW.H	;HARD PAFE FAIL?
		TLNN	R,PFW.A	;OR NO ACCESS
		POPJ	P,	;YES
		JRST	MAPCM1]
	TRNE R,MAP.FL	;DID IT FAIL?
	TRNN R,MAP.M	;AND NOT MATCHH
	SKIPA	;NO PROBABLY NO WRITE
	POPJ P,		;YES
MAPCM1:	ANDI R,17777	;GET PAGE NUMBER
	LSH R,9
	ANDI T,777
	ADD T,R
	JRST CPOPJ1

MAPUS1:	SKIPE	KLMAPF
	JRST	[XCT	X.MEM,[MAP R,(T)]
		JRST	MAPCOM]
	XCT XTU,[MAP R,(T)]
	JRST MAPCOM	;THESE ARE IN FETCH FOR FILDDT
>
TAB:	PUSHJ P,DEPRS	;OPEN REGISTER OF Q
	PUSHJ P,SETADR
	 JRST ERR
IFN XMOD!FLDDT,<MOVSS USRSAV	;SAVE OLD POSITION
	HLLM T,USRSAV	;AND CURRENT>
	MOVEI T,-1(T)
	EXCH T,LLOC	;NOW SAVE ADDRESS
	MOVEM T,SAVLOC
IFN XMOD,<HRROI T,700000
	SKPUSR
	PUSHJ P,TEXTT>		;3 RUBOUTS IF EXEC MODE
	JRST LI0

DEPRA:	MOVE R,SAVLOC
	TLNE F,CF		;RESTORE OLD SEQUENCE IF $CR,$CF, OR
	EXCH R,LLOC		;IF $^ OR $BS WAS TYPED
	MOVEM R,SAVLOC		;SETUP "NEW" OLD SEQUENCE
IFN XMOD!FLDDT,<TLNE F,CF
	MOVSS USRSAV>
	TLNE F,ROF		;IF REGISTER IS BEING CHANGED
	TLNN F,QF		;REMOVE ALL PREVIOUS UNDEFINED
	JRST DEPRS		;SYMBOL REFERENCES TO IT
	MOVE R,ESTU
	MOVEM W1,ESTU
DEPRA2:	JUMPGE R,DEPRS
IFN HI,<PUSHJ P,WPSET>
	HRRZ W,1(R)
	CAMN W,LLOCO
	PUSHJ P,REMUN
	ADD R,[XWD 2,2]
	JRST DEPRA2

EQUAL:	MOVEM T,TEM2	;SAVE (REALLY LEFT HALF)
	PUSHJ P,SETADR
	 JRST ERR
IFN XMOD!FLDDT,<JUMPGE T,EQL2	;NO NEED TO MAP USER
	PUSHJ P,MAPUS1	;GET USER ADDRESS
	 JRST ERR
EQL2:>
	TLNN T,-1	;DID SOMETHING GET RETURNED HERE?
	HLL T,TEM2	;RESTORE T
	JRST EQL1	;AND GO

PSYM:	TLNE F,CCF
	JRST PBYPT
	TLNE F,CF
	JRST SEMIC1	;MAKE $_ AS OLD ;
	TRZA F,CF1
EQL1:	TROA F,CF1+LF1
	TRO F,LF1
	PUSHJ P,CONSYM
	JRST RET

R50PNT:	LSH T,-36	;RADIX 50 SYMBOL PRINTER
	TRZ T,3
	PUSHJ P,TOC
	PUSHJ P,TSPC
IFN FAILSW,<SETZM SVFB>
	MOVEI W1,LWT	;SETUP FOR SPT
	JRST SPT

SIXBP:	MOVNI W2,6		;SIXBIT PRINTER
	MOVE W1,LWT
SIXBP1:	MOVEI T,0
	ROTC T,6
	ADDI T,40
	PUSHJ P,TOUT
	AOJL W2,SIXBP1
	POPJ P,
;MODE CONTROL SWITCHES

TEXO:	MOVEI R,TEXTT-HLFW	;$T ASSUME 7 BIT ASCII
	MOVE T,WRD2
	CAIN T,6		;CHECK FOR $6T
	MOVEI R,SIXBP-HLFW	;SET MODE SWITCH FOR SIXBIT
	CAIN T,5		;CHECK FOR $5T
	MOVEI R,R50PNT-HLFW	;SET MODE SWITCH FOR RADIX 50
HWRDS:	ADDI R,HLFW-TFLOT		;H
SFLOT:	ADDI R,TFLOT-PIN		;F
SYMBOL:	ADDI R,PIN-FTOC		;S
CON:	ADDI R,FTOC		;C
	HRRZM R,SCH
	JRST BASE1

RELA:	TRZE F,Q2F		;CHANGE ADDRESS MODE TO RELATIE
	JRST BASECH
	MOVEI R,PADSO-TOC
ABSA:	ADDI R,TOC		;A
	HRRZM R,AR
	JRST BASE1

BASECH:	MOVE T,WRD2		;$NR  CHANGE OUTPUT RADIX TO N, N>1
	CAIGE T,2
	JRST ERR
	HRRZM T,ODF
BASE1:	MOVS S,[XWD SCHM,SCH]
	TLNN F,CCF
	JRST LIS1
	BLT S,ODFM	;WITH $$, MAKE MODES PERMANENT
	JRST RET

SEMIC1:	MOVEM T,LWT
	JRST @SCH	;TYPE OUT IN CURRENT MODE
IFN FLDDT!XMOD!FRMDDT,<

SETBUF:	PUSHJ P,MAKBPT	;GET A POINTER TO THE BUFFER
	MOVEI R,SIZBUF*5
	PUSHJ P,TEXIN
	MOVEM T,SYL
BFINLP:	PUSHJ P,TEXIN
	SOJLE R,BFINLP
	CAMN T,SYL
	JRST BFINLD
	IDPB T,W1
	JRST BFINLP

BFINLD:	MOVEI T,0
	IDPB T,W1
	JRST DD1

PRTBUF:	PUSHJ P,MAKBPT
PRTBF1:	ILDB T,W1
	JUMPE T,DD1
	CAIN T,33
	MOVEI T,"$"
	PUSHJ P,TOUT
	JRST PRTBF1

USEBUF:	IFN FLDDT,<JUMPE T,RUNCOD>
	PUSHJ P,MAKBPT
	MOVEM W1,STRING
	PUSHJ P,LISTEN
	JRST DD1
	SETZM STRING
	JRST DD1

MAKBPT:	CAIG T,NUMBUF
	CAIGE T,1
	JRST ERR
	IMULI T,SIZBUF
	MOVEI W1,BUFLOC(T)
	HRLI W1,(POINT 7,0)
	POPJ P,

NUMBUF==^D8
SIZBUF==^D20
BUFLOC=.-SIZBUF		; BUFFER 0 DOESN'T REALLY EXIST

DEFINE 	MAKBUF (BUFNO,TEXT) <XLOC BUFLOC+BUFNO*SIZBUF
	ASCIZ |TEXT|>

IFN FLDDT,<
	MAKBUF 1,<PAGDTI1GCRSHAC2G%UPT+UPTACP5G>
	MAKBUF 2,<PAGDTI9GPAGCNI7GCRSHAC2G>
> ; END OF FLDDT BUFFER DEFINITIONS
IFN XMOD,<
	MAKBUF 1,<SCNSER:SCNTIC1B1B+1!%%SS0
SYSCRS+1(SYSCRS)B
>
	MAKBUF 2,<CTYDO!1
CTYBRKBSYSCRS+1(SYSCRS)BDRDO!0
>
	MAKBUF 3,<DZKON:DZBRKBDZDO!1
SYSCRS+1(SYSCRS)BDRDO!0>
> ; END OF XMOD BUFFER DEFINITIONS
XLOC	BUFLOC+NUMBUF*SIZBUF+SIZBUF
>	; END IFN FLDDT!XMOD
IFN FLDDT,<
CHGMOD:	SETCMM CODMOD
	SKIPE CODMOD
	SKIPA W1,[POINT 7,[ASCIZ /
CODE MODE/]]
	MOVE W1,[POINT 7,[ASCIZ /
FILE MODE/]]
	JRST PRTBF1

UUO0:	0
	MOVEM 17,AC0+17
	MOVEI 17,AC0
	BLT 17,AC0+16
	LDB T,[POINT 9,40,8]
	CAIE T,2
	CAIN T,1
	SOJA T,FETUUO
	HRRZ T,40
	JUMPN T,END1
	SETZM STRING
END1:	MOVSI 17,CODAC0
	BLT 17,17
	JRST DD1

CODAC0:	BLOCK 20

RUNCOD:	MOVEM 17,CODAC0+17
	MOVEI 17,CODAC0
	BLT 17,CODAC0+16
	MOVSI 17,AC0
	BLT 17,17
	JRST PATCH

FETUUO:	MOVNM T,FDPUSR
	MOVSI 17,CODAC0
	BLT 17,17
	HRRZ R,40
	PUSHJ P,FLDDFT
	JRST UUOXIT
	AOS UUO0
	LDB R,[POINT 4,40,12]
	MOVEM T,AC0(R)
UUOXIT:	MOVE 17,CODAC0+17
	MOVEI 17,CODAC0
	BLT 17,CODAC0+16
	MOVSI 17,AC0
	BLT 17,17
	JRST @UUO0
>
IFN XMOD,<
;DEFINE TESTS ON SENSE SWITCHHS TO PUT IN COND BRKPNTS

DEFINE TSTS (A)
<%%SS'A=<JSR TSTSW'A>
IFE DDTST,<
INTERNAL %%SS'A>

TSTSW'A: 0
	MOVEM 17,SS7'A
	CONI APR,17
	AOS TSTSW'A
	TLNN 17,1_<6-A>
	AOS TSTSW'A
	MOVE 17,SS7'A
	JRSTF @TSTSW'A

SS7'A:	0
>

XXQ==1
REPEAT 6,<TSTS (\XXQ)
XXQ==XXQ+1>

TSTSW0:	0
	AOS TSTSW0
	AOS TSTSW0	;SET FOR NO BREAK
	MOVEM	17,SS70	;save 17 for KI/KL/KS check
	SETZ	17,
	BLT	17,	;if non-zero, then it's a KL or KS
	JUMPN	17,TSTSWK	; KL or KS - go see which
	CONSO TTY,40		; KI - get character
	JRST	TSSW02	;NO INPUT, NO BREAK.
	DATAI TTY,17
TSSW01:	ANDI 17,177
	CAIN 17,"Z"-100	;CHECK FOR CONTROL Z
	SOS TSTSW0	;AND BREAK IF IT WAS
TSSW02:	MOVE 17,SS70
	JRSTF @TSTSW0	;GO

TSTSWK:	APRID	17
	TRNE	17,KSMSK	;SEE IF KS SERIAL NUMBER
	  JRST	TSTSWS		; This is a KS - go get char
	CONI	PAG,17	;GET EBR; This is a KL ...
	ANDI	17,1777
	LSH	17,^D9	;GET ADDRESS OF EBR
	MOVE	17,DTEF11(17)	;GET CHAR
				; DON'T CHECK MTD - DDT CLEARS IT.
	JRST	TSSW01	;AND CHWECK TO SEE IF ^Z.

TSTSWS:	SETZ	17,
	EXCH	17,CTYIWD	; Get character and zero it
	JRST 	TSSW01		; Go check for ^Z

SS70:	0

%%SS0=<JSR TSTSW0>
IFE DDTST,<INTERNAL %%SS0>
>
IFN HI,<
	INTERN SEGINI
	EXTERN SEGTAB,JOBJDA

JOBHSM=400006	;HISEG SYMBOL TABLE POINTER

COMMENT %

SPECIAL HIGH SEGMENT DDT (HIDDT).

HIDDT IS A VERSION OF DDT WHICH IS USED WITH PROGRAMS WHICH
CONSIST OF MULTIPLE HIGH SEGMENTS.  DEBUGGING THE
PROGRAM BEGINS WITH A GET ON THE HIGH SEGMENT WHICH NORMALLY
RUNS FIRST, AND THEN A CALL TO DDT.  THE LOW SEGMENT AND THE
INITIAL HIGH SEGMENT ARE THEN AVAILABLE FOR DEBUGGING.  A
COMMAND IS PROVIDED TO BRING ANY OTHER HIGH SEGMENT INTO CORE
TEMPORARILY FOR DEBUGGING.  CHANGES MAY BE MADE AND BREAKPOINTS
SET IN THE HIGH SEGMENT IN CORE.  CHANGES WILL BE STORED
ON THE .HGH FILE FOR THE HISEG, AND BREAKPOINTS WILL BE REMEMBERED
DURING EXECUTION AND SET UP PROPERLY WHEN THE GIVEN HISEG COMES
INTO CORE TO BE EXECUTED (SETTING BREAKPOINTS DOES NOT CAUSE
MODIFICATION OF THE .HGH FILE).  BREAKPOINTS MAY BE SAVED FOR
SUBSEQUENT RUNS BY DOING AN EXIT;X AND A SAVE COMMAND.  THIS
SHOULD BE DONE ONLY IF EXECUTION HAS NOT BEGUN.  CHANGES TO
ANY HISEG AND BREAKPOINTS IN ANY HISEG MAY BE SET ANY
TIME DDT HAS CONTROL.  THE CORRECT SEGMENT WILL RETURN
WHEN EXECUTION IS RESUMED.

SOME SPECIAL INTERFACE IS REQUIRED IN THE PROGRAM TO BE USED
WITH HIDDT, AS DESCRIBED BELOW.  THE SFORTRAN FILE GITSEG.MAC
IS AN EXAMPLE OF THIS INTERFACE.

THE PROGRAM RUN WITH HIDDT MUST CONTAIN A TABLE IN THE LOW
SEGMENT CALLED SEGTAB. THE FORMAT OF THE TABLE IS:

SEGTAB:	0,,(LOC IN TABLE OF NAME OF CURRENT SEGMENT)
	DEFAULT PPN (FOR ENTRIES BELOW WITH 0 IN PPN FIELD)
THE FOLLOWING TWO WORDS REPEATED FOR EACH HIGH SEGMENT:
	SIXBIT NAME OF SEGMENT
	PPN WHERE SEGMENT LIVES (IF 0, DEFAULT ABOVE IS ASSUMED)

AFTER A NEW HIGH SEGMENT IS BROUGHT INTO CORE, THE PROGRAM SHOULD
DO A JSP 17,SEGINI TO TELL DDT WHAT IS GOING ON (AFTER SETTING UP
THE RH OF SEGTAB FOR THE NEW SEGMENT).  ALL REGISTERS MAY BE CLOBBERED.

ANY MODIFICATIONS MADE THROUGH DDT TO CODE IN THE HIGH SEGMENT WILL
BE SAVED ON THE .HGH FILE FOR THAT SEGMENT WHENEVER POSSIBLE.
THE FIRST TIME AN ATTEMPT IS MADE TO STORE SOMETHING INTO A HIGH
SEGMENT, THE .HGH FILE FOR THE SEGMENT IS OPENED ON CHANNEL 0
IN UPDATE MODE.  IF THIS FAILS (OR IF THE SEGMENT IS SHARABLE)
THE STORE IS NOT ALLOWED AND A ? IS TYPED.  STUFF STORED
INTO THE HIGH SEGMENT IS THEN WRITTEN OUT THE NEXT TIME EXECUTION IS
RESUMED (;G ;P ;X) OR A ;Y IS GIVEN.
BREAKPOINTS MAY BE SET IN ANY HIGH SEGMENT (IF THE DESIRED SEGMENT
IS NOT IN CORE, IT MAY BE GOTTEN WITH NAME;Y).  SEGINI TAKES
CARE OF SETTING UP THE PROPER BREAKPOINTS WHEN A NEW HIGH SEGMENT
IS RUN.

ADDED DDT COMMANDS:

;Y	FORCES ANY MODIFICATIONS MADE TO THE CURRENT HIGH SEGMENT
	TO BE WRITTEN TO ITS .HGH FILE.
NAME;Y	DOES THE ABOVE, AND THEN BRINGS INTO CORE THE NAMED
	SEGMENT (NAME IS THE ADDRESS OF THE SEGMENT'S ENTRY IN
	SEGTAB).  IF EXECUTION IS RESUMED, THE PROPER HIGH SEGMENT
	(POINTED TO BY THE RH OF SEGTAB) WILL BE RESTORED FIRST
	AUTOMATICALLY.

%

SEGINI:	HRRM 17,SGINIR	;SAVE RETURN
	SETZM SEGPTR	;ZAP LOCAL SEG PTR
	SETZM SEGOK	;MARK SEGMENT AS UNOPENED
	SETZM PRGM	;FORCE SYMBOL TABLE INITIALIZATION
	MOVEI P,PS
	PUSHJ P,SEGSYM	;FIX UP SYMBOLS
	MOVE S,[JSR BP1]
SGBCK:	SKIPE R,B1ADR-BP1(S)
	TRNN R,400000	;CHECK ALL HISEG BREAKPOINTS
	JRST SGBNXT	;THIS WASN'T ONE
	HRRZ T,SEGTAB
	CAMN T,3(S)	;GOT A HISEG BP, IS IT IN THIS SEG?
	PUSHJ P,FETCH	;YES, GOT TO SET IT UP
	  JRST SGBNXT	;EITHER NOT THIS SEG OR FETCH FAILURE
	MOVEM T,B1INS-BP1(S)
	MOVE T,S
	PUSHJ P,DEPB
	  JFCL
SGBNXT:	ADDI S,4
	CAMG S,[JSR BPN]
	JRST SGBCK
SGINIR:	JRST .-.

;ROUTINE TO HANDLE [NAME];Y

HISTUF:	PUSHJ P,SEGUPD	;UDPATE .HGH FOR CURRENT SEGMENT
	TLNN F,QF
	JRST RET	;DONE IF NO NAME PRESENT
	PUSHJ P,GTSEG
	HRRZM T,SEGPTR	;REMEMBER IT
	JRST RET

;ROUTINE TO WRITE OUT CHANGED BLOCKS OF HIGH SEGMENT INTO .HGH
;FILE.  A BIT MAP IS KEPT WHERE EACH BIT CORRESPONDS TO 200 OCTAL
;WORDS OF THE HIGH SEGMENT, AND ONLY THOSE BLOCKS MARKED IN THE
;MAP ARE WRITTEN.

SEGUPD:	SKIPN SEGOK	;IS THERE ANYTHING TO DO?
	POPJ P,		;NO, FORGET IT
	PUSH P,T
	MOVSI T,-^D30*^D36	;# OF BITS IN MAP
	MOVEI W1,400000		;BASE OF CURRENT PAGE
	MOVE W2,[POINT 1,HIMAP]	;MAP BIT PTR
UPDLP:	ILDB TT,W2	;CHECK NEXT BIT
	JUMPE TT,UPDOK	;JUMP IF NOTHING TO DO
	USETO 1(T)	;GOT TO WRITE IT, SET THE BLOCK RIGHT
	MOVS TT,W1
	HRRI TT,HIBUF	;SET UP TO MOVE INTO BUFFER (SINCE CAN'T DO
	BLT TT,HIBUF+177;I/O IN THE HIGH SEGMENT)
	OUT HBFPT	;WRITE THE BLOCK FROM THE BUFFER
	JRST UPDOK
	OUTSTR [ASCIZ/
OUTPUT ERROR/]
	JRST WRONG1
UPDOK:	ADDI W1,200	;NEXT BLOCK IN CORE
	AOBJN T,UPDLP	;GO DO IT
	SETZM HIMAP
	MOVE T,[HIMAP,,HIMAP+1]
	BLT T,HIMAP+^D29	;ZAP THE MAP, AS THE BOZOS SAY
	POP P,T
	POPJ P,

;ROUTINE CALLED BY DEP BEFORE STORING INTO THE HISEG. MAKES SURE
;THE SEGMENT IS NOT SHARABLE, AND OPENS UP THE .HGH FILE FOR THE
;SEGMENT.  THIS IS DONE NOW INSTEAD OF LATER TO SEE IF THE STORE
;REALLY CAN BE SAVED LATER.  KISS CHANNEL 0 GOODBYE, BUT WHAT CAN
;YOU REALLY DO?  BY THE WAY, THIS RETURNS NONSKIPPING
;IF THE SEGMENT IS SHARABLE OR THE .HGH FILE CAN'T BE UPDATED, AND
;SKIPPING IF THE OPPOSITE IS TRUE.

SEGOPN:	SKIPE SEGOK
	JRST CPOPJ1	;FORGET IT IF ALREADY OPEN
	SKIPE JOBJDA
	POPJ P,		;BAD NEWS IF CHANNEL 0 IS BUSY
	HRROI TT,14
	GETTAB TT,	;FIND OUT IF SHARABLE
	  POPJ P,
	MOVEI TT1,0	;SET THIS REGISTER UP CLEVERLY NOW
	TLNN TT,200000	;SKIP (AND RETURN) IF SHARABLE
	SETUWP TT1,	;IF NOT, TRY TO FLEX OUR MUSCLES
	  POPJ P,	;SHARABLE OR NOT OURS TO MESS WITH, FORGET IT
	SETUWP TT1,	;MADE IT THROUGH THAT, PUT IT BACK THE WAY IT WAS
	  JFCL		;CAN'T GET HERE AND WHO CARES ANYWAY?
	INIT 17
	SIXBIT/DSK/
	0
	  POPJ P,	;IT'S EASY TO GIVE UP
	SKIPN TT,SEGPTR	;GET OUR SEG PTR
	HRRZ TT,SEGTAB	;OR THE USER'S IF WE DIDN'T CHANGE IT
	MOVE TT1,(TT)	;GET SEGMENT NAME
	MOVEM TT1,SGNAM	;SAVE FOR LOOKUP
	SKIPN TT1,1(TT)	;USE LOCAL PPN
	MOVE TT1,SEGTAB+1	;OR DEFAULT PPN
	JUMPN TT1,.+4
	HRROI TT1,-25
	GETTAB TT1,	;OR WHERE WE WERE RUN FROM
	  SETZ TT1,
	MOVEM TT1,SGPPN	;SAME WITH PPN
	MOVSI TT,'HGH'
	MOVEM TT,SGEXT
	SETZM SGEXT+1
	LOOKUP SGNAM	;LOOKUP THE .HGH FILE
	  JRST SGER
	HLLZS SGEXT
	SETZM SGEXT+1
	MOVEM TT1,SGPPN
	ENTER SGNAM	;ENTER IT TOO
	  JRST SGER
	SETZM HIMAP
	MOVE TT,[HIMAP,,HIMAP+1]
	BLT TT,HIMAP+^D29	;I WON'T SAY IT AGAIN
	SETOM SEGOK	;REMEMBER THAT WE DID OUR JOB AND DID IT WELL
	JRST CPOPJ1

SGER:	RELEAS		;GET RID OF CHANNEL ON ERRORS AFTER INIT
	POPJ P,

;ROUTINE TO ACTUALLY DO THE GETSEG. CALLED WITH T=SEGTAB PTR.

GTSEG:	MOVEI TT1,1	;RECOVERY COUNT
	SETZM SEGOK
	PUSH P,JOBSA	;CORE UUO ALSO ZAPS JOBSA IF IN HISEG
	MOVSI TT,1
	CORE TT,	;DELETE HISEG
	  JFCL
GTSEG1:	MOVE TT,(T)
	MOVEM TT,SGNAM	;SET UP NAME
	SKIPN TT,1(T)	;GET ITS PPN
	MOVE TT,SEGTAB+1	;OR THE DEFAULT
	JUMPN TT,.+4
	HRROI TT,-25
	GETTAB TT,	;OR WHERE WE WERE RUN FROM
	  SETZ TT,
	MOVEM TT,SGPPN
	SETZM SGEXT
	SETZM SGEXT+1
	SETZM SGPPN+1
	MOVEI TT,GTSG
	GETSEG TT,
	  JRST [HRRZ T,SEGTAB
		SOJE TT1,GTSEG1
		OUTSTR [ASCIZ/LOST HISEG!/]
		EXIT]
	POP P,JOBSA
	PUSH P,T
	SETZM PRGM
	PUSHJ P,SEGSYM	;FIX UP SYMBOL PTRS
	PUSHJ P,CHKSYM	;INITIALIZE SYMBOL TABLE
	POP P,T
	POPJ P,

;ROUTINE TO INSURE THAT PROPER SEGMENT FOR EXECUTION IS IN CORE

CHKSEG:	PUSHJ P,SEGUPD	;SAVE ANY CHANGES TO CURRENT SEG
	HRRZ T,SEGTAB	;GET SEGMENT TO BE EXECUTED
	SKIPE SEGPTR
	CAMN T,SEGPTR	;SEE IF A DIFFERENT ONE IS IN CORE
	JRST .+2
	PUSHJ P,GTSEG	;GET RIGHT SEGMENT IN CORE
	SETZM SEGPTR
	POPJ P,

;ROUTINES TO SET (ALLOW) HISEG WRITE AND UNSET SAME

WPSET:	SKIPE UWP
	POPJ P,		;FORGET IT IF ALREADY SET
	HRROI T,14
	GETTAB TT,
	  JRST ERR
	MOVEI TT1,0
	TLNN TT,200000	;SKIP IF SHARABLE
	SETUWP TT1,	;NO, TRY TURNING OFF WP
	  JRST ERR
	HRROM TT1,UWP
	POPJ P,

WPUNS:	SKIPE TT1,UWP
	SETUWP TT1,
	  JFCL
	SETZM UWP
	POPJ P,

;ROUTINE TO CHECK SYMBOL PTR AND LINK UP HI AND LO

SEGSYM:	SKIPE T,@SYMP	;GET OLD SYMBOL PTR
	TRNE T,400000	;CHECK HI/LO
	JRST SGS1	
	HLRE TT,JOBHSM	;HAD A LOW PTR, LINK IT TO NEW HI PTR
	MOVNS TT
	ADD TT,JOBHSM
	HRRZM TT,1(T)
	POPJ P,
SGS1:	MOVE T,JOBHSM	;OLD WAS HI OR ZERO, JUST SET UP NEW HI PTR
	MOVEM T,@SYMP
	POPJ P,

;FINALLY SOME DATA AND LO YO STUFF

HBFPT:	IOWD 200,HIBUF
	0

HIBUF:	BLOCK 200

HIMAP:	BLOCK ^D30

SEGOK:	0		;NONZERO IF .HGH FILE IS OPEN
SEGPTR:	0		;PTR TO NAME OF SEG IF CHANGED WITH NAME;Y

GTSG:	SIXBIT/DSK/
SGNAM:	0
SGEXT:	0
	0
SGPPN:	0
	0

UWP:	0

>;END IF IFN HI WAY BACK WHEN
;GO AND EXECUTE LOGIC

GO:	IFN FLDDT!XMOD,<TRNE F,Q2F	;IS IT $<N>G
	JRST FLGO	;YES>
	HRLI T,(JRST)             ;G
IFN XMOD,<
	SKPUSR
	JRST XEC>
	TLOE F,QF
	JRST XEC0
	HRR T,JOBSA
	TRNN T,-1		;IF NONE, THEN ERR
	JRST ERR

XEC:	TLNN F,QF		;X
	TDZA	T,T	;ZAP QUANTITY JUST IN CASE
	TLNN	T,777000	;MAKE SURE IT'S A LEGAL INSTRUCTION
	JRST	$X		;ELSE SINGLE STEP
XEC0:	MOVEM T,TEM
	PUSHJ P,CRF
IFN HI,<PUSHJ P,CHKSEG>
	PUSHJ P,INSRTB
IFN XMOD,<HLRZ T,BCOMM
	SKIPN T
	MOVEI T,XCTSAV-BPIDT+BPISA	;SET TO SAVE INFO
	ADDI T,BPIDT-BPISA
	MOVSI S,-XCTLEN
	MOVE W,@XCTSVT(S)
	MOVEM W,(T)
	ADDI T,1
	AOBJN S,.-3
	MOVE T,BCOMM
	MOVEM T,BCOMX
	SETZM BCOMM
	SETZM XSKP>
IFE FRMDDT,<	JSP T,RESTORE>
XEC1:	IFN FRMDDT,<
	SKIPE	FRAME
	JRST	XECFRM
	JSP T,RESTORE
>;END IFN FRMDDT
	XCT TEM
IFE XMOD,<JRST DDT		;USED  AT PROC0>
IFN XMOD,<SKIPA
	AOS XSKP>
	JSR SAVE
	PUSHJ P,REMOVB
	MOVE W1,[ASCII /SKIP/]
IFN XMOD,<	SKIPE XSKP>
	PUSHJ P,TEXT2
IFN XMOD,<	MOVE T,BCOMX
	MOVEM T,BCOMM
	HLRZS T
	SKIPN T
	MOVEI T,XCTSAV-BPIDT+BPISA
	ADDI T,BPIDT-BPISA
	MOVSI S,-XCTLEN
	MOVE W,(T)
	MOVEM W,@XCTSVT(S)
	ADDI T,1
	AOBJN S,.-3>
	PUSHJ P,CRF
	JRST DD1

IFN XMOD,<
XCTSVT:	LEAV
	BCOM
	BCOMX
	PROC0
	BCOM2
	BCOM3
	XSKP
	TEM
XCTLEN==.-XCTSVT
XCTSAV:	BLOCK XCTLEN
>

IFN FRMDDT,<
FRXLOC==20		;HOPEFULLY EXISTENT AND UNUSED LOCATIONS.
XECFRM:	MOVE	T,FRAME
	HRLZ	TT1,T		;GET FRAME,,0 (JBTSTS TABLE)
	GETTAB	TT1,		;GET JBTSTS FOR FRAME
	  JRST	ERR		;CANOT
	MOVEM	TT1,FRMSJS	;SAVE FOR LATER.
	JUMPGE	TT1,XECFR0	;IF STOPPED, JUST GO.
	HRLI	T,.FOHLT	;STOP THE FRAME FIRST
	FRMOP	T,
	  JRST	ERR		;CANNOT STOP IT
XECSTF:	HRLZ	TT1,T		;NOW WAIT FOR HALT TO TAKE EFFECT
	GETTAB	TT1,
	  JRST	ERR		;WHAT HAPPENED?
	JUMPGE	TT1,XECST1	;GO IF ITS STOPPED NOW.
	MOVE	TT1,[10,,^D500] ;WAIT HALF A SEC OR UNTIL CHAR ARRIVES
	HIBER	TT1,
	  JRST	ERR		;HIBER NOT WORKING?
	SKPINL			;IF ANYTHING THERE, 
	JRST	XECSTF		;CHECK AGAIN.
	JRST	XECFR3		;THEN RETURN.
XECST1:	HRLI	T,.FORPC	;WE'VE STOPPED IT, SAVE ITS PC.
	FRMOP	T,FRMSPC	;INTO FRMSPC
	  JRST	ERR		;DIDN'T WORK
	HLRZ	TT1,TEM		;GET INSTRUCTION
	ANDI	TT1,777740	;JUST OPCODE AND AC
	CAIN	TT1,(HALT)	;IF HE'S EXECUTING HALT,
	  JRST	XECFR3		;THEN NOTHING ELSE TO DO!
XECFR0:	HRLI	T,.FORVA	;SAVE FRXLOC-FRXLOC+2
	MOVE	TT1,[-3,,FRXLOC]
XECFR1:	FRMOP	T,TT1
	  JRST	ERR
	MOVEM	TT2,SAVFRX-FRXLOC(TT1)
	AOBJN	TT1,XECFR1
	HRLI	T,.FOWVA
	MOVEI	TT1,FRXLOC
	MOVE	TT2,TEM		;DEPOSIT IN LOCATION FRXLOC
	FRMOP	T,TT1
	  JRST XFRERR
	AOS	TT1
	MOVE	TT2,[HALT]
	FRMOP	T,TT1
	  JRST	XFRERR
	AOS	TT1
	FRMOP	T,TT1
	  JRST	XFRERR
	HRLI	T,.FOSAA
	MOVE	TT1,[1B0+FRXLOC]
	FRMOP	T,TT1
	  JRST	XFRERR		;CAN'T DO IT, RESTORE FRXLOC AND RETURN
XECWAT:	MOVE	TT1,[10,,^D500]	;WAIT .5 SEC. OR FOR CHAR. DON'T ENABLE FOR FRAME EXIT, WIPES OUT INTERRUPT.
	HIBER	TT1,
	  JRST	XFRERR
	SKPINL			;IF ANY CHARS WAITING,
	JRST	.+2		;NONE
	JRST	[SETZM FRMSJS	;DON'T TRY TO START FRAME
		 JRST RSTFRX]	;AND RESTORE FRXLOC S.
	HRLZ	TT1,FRAME
	GETTAB	TT1,		;GET JBTSTS, TABLE 0
	  JRST	XFRERR
	JUMPGE	TT1,XECHST	;IF STOPPED, SEE WHAT HAPPENED.
	HRLI	T,.FORPC	;READ PC, STILL RUNNING
	FRMOP	T,TT1
	  JRST	XFRERR		;CAN'T GET IT
	HRRZS	TT1		;JUST RH
	JUMPE	TT1,XECWAT	;IF NO KNOWN PC, START DID NOT HAPPEN YET.
	CAIL	TT1,FRXLOC	;IF FRXLOC TO FRXLOC+3,
	CAILE	TT1,FRXLOC+3	;THEN
	JRST	RSTFRX		;MUST HAVE JUMPED, JUST RETURN.
	JRST	XECWAT
XECHST:	HRLI	T,.FOHST	;READ HALT STATUS BLOCK
	FRMOP	T,HSTADR		;READ HALT STATUS BLOCK
	  JRST	XFRERR
	HRRZ	TT1,HSTADR+3	;GET PC
	CAIN	TT1,FRXLOC+3	;IF IT SKIPPED,
	OUTSTR	[ASCIZ /<SKIP>/]
RSTFRX:	MOVE	T,FRAME		;SETUP FD AGAIN.
	HRLI	T,.FOWVA
	MOVE	TT1,[-3,,FRXLOC]
XECFR2:	MOVE	TT2,SAVFRX-FRXLOC(TT1)
	FRMOP	T,TT1
	  JRST	ERR		;CAN'T RESTORE, NOTHING LEFT TO DO.
	AOBJN	TT1,XECFR2
	SKIPL	FRMSJS		;WAS FRAME RUNNING?
	  JRST	XECFR3		;NO.
	MOVE	TT1,FRMSPC	;YES, GET PC
	TLO	TT1,(1B0)	;NOT THRU FRAME'S ADDRESS SPACE
	HRLI	T,.FOSAA	;START FRAME UP
	FRMOP	T,TT1
	  JRST	ERR
XECFR3:	PUSHJ	P,CRF
	JRST	DD1

XFRERR:	OUTCHI	"?"
	JRST	RSTFRX		;PRINT ? AND RESTORE FRXLOCS.

SAVFRX:	BLOCK	3
FRMSJS:	0		;SIGN BIT SAYS WHETHER FRAME NEEDS TO BE RESTARTED OR NOT
FRMSPC:	0		;WHERE TO RESTART FRAME IF NEED TO.
HSTADR:	3		;READ 3 WORDS OF HALT STATUS BLOCK IN.
	BLOCK	3
>;END IFN FRMDDT

IFN FLDDT!XMOD,<
FLGO:	MOVE R,WRD2
	CAIL R,MAXGO
	JRST ERR
	JRST @GOTAB(R)

IFN FLDDT,<
GOTAB:	EXP LOADP0,LOADP1,LODAC,LODAC2,LODMP1,LODAXP>
IFN XMOD,<
GOTAB:	EXP ERR,ERR,ERR,ERR,LODMP1>	;MOST ARE ERRORS IN EXECDDT
MAXGO==.-GOTAB
>	;END IFN FLDDT!XMOD

IFE FRMDDT,<STFRM==ERR>
IFN FRMDDT,<
DEFINE MSG(A)<OUTSTR [ASCIZ\'A\]>

STFRM:	MOVE	T,FRAME
	PUSHJ	P,OCTOUT
	MSG	<	>
	MOVS	T,FRAME
	HRRI	T,3		;PROGRAM NAME
	GETTAB	T,
	  MOVE T,[SIXBIT /??????/]
	PUSHJ	P,SIXOUT
	MSG	< >
	MOVS	R,FRAME
	HRRI	R,0		;GET JBTSTS
	GETTAB	R,
	  JRST ERR
	LDB	T,[POINT 5,R,14]	;GET STATE CODE
	IDIVI	T,3		;T GETS WORD, P3 REMAINDER
	MOVSS	T		;INDEX IN LH
	HRRI	T,25		;WAIT STATE NAMES
	GETTAB	T,		;GET XXYYZZ
	  JRST ERR
	LDB	T,[POINT 12,T,11
		    POINT 12,T,11+12
		    POINT 12,T,11+24](W1)
	JUMPL	R,STFR1
	MSG	<^C (>
STFR1:	PUSHJ	P,SIXOUT
	SKIPL	R
	MSG	<)>
	MSG	<	>
	MOVS	T,FRAME
	HRRI	T,-22
	GETTAB	T,
	  MOVE T,[SIXBIT /??????/]
	PUSHJ	P,SIXOUT
	MOVS	T,FRAME
	HRRI	T,-21
	GETTAB	T,
	  MOVE T,[SIXBIT /??????/]
	PUSHJ	P,SIXOUT
	MSG	< PC:>
	MOVE	T,FRAME
	HRLI	T,.FORPC
	FRMOP	T,T
	  SETZ	T,
	PUSHJ	P,HWORD
	PUSHJ	P,CRF
	JRST	DD2
SUBTTL ROUTINES

OCTOUT:	SKIPA	W2,[^D8]	;OCTAL
DECOUT:	MOVEI	W2,^D10
RADOUT:	IDIVI	T,(W2)
	HRLM	W1,(P)
	SKIPE	T
	PUSHJ	P,RADOUT
	HLRZ	TT,(P)
	OUTCHI	"0"(TT)		;OUTPUT AS ASCII.
	POPJ	P,

HWORD:	PUSH	P,T
	HLRZS	T
	PUSHJ	P,OCTOUT
	MSG	<,,>
	POP	P,T
	HRRZS	T
	JRST	OCTOUT

SIXOUT:	MOVE	W1,[POINT 6,T]
SIXOU1:	TLNN	W1,770000	;ANYTHING LEFT?
	POPJ	P,		;NO
	ILDB	W2,W1		;GET CHAR
	ADDI	W2,"0"-'0'	;GET DIFFERENCE BETWEEN ASCII AND SIXBIT
	OUTCHR	W2
	JRST	SIXOU1		;AND LOOP
>;END IFN FRMDDT


	SUBTTL	SINGLE STEP EXECUTE LOGIC

IFN	FLDDT,<$X==ERR>
IFE	FLDDT,<

;$X IS A  FEATURE THAT OPERATES AS FOLLOWS:
;	$X OR N$X OR $$X OR N$$X, WHERE N .LT. 2^27, WILL DISPATCH TO
;	THIS CODE.  THE FOLLOWING ACTIONS WILL BE PERFORMED:
;
;   $X EXECUTE A SINGLE INSTRUCTION, THEN INCREMENT THE PC.  THE
;	OPERANDS TO THE INSTRUCTION WILL BE PRINTED OUT AS THEY
;	EXIST **AFTER** EXECUTION OF THE INSTRUCTION.  AN EXTRA
;	LINE FEED WILL BE PRINTED IF THE INSTRUCTION SKIPPED OR
;	JUMPED.  THE NEXT INSTRUCTION WILL THEN BE PRINTED.
;	$P WILL ALWAYS DO THE RIGHT THING AFTER ANY NUMBER OF $X'S.
;
;  N$X REPEAT THE $X CYCLE N TIMES.
;
; N$$X SAME AS N$X EXCEPT THAT ALL PRINTOUT IS SUPPRESSED FOR
;	ALL BUT THE LAST $X CYCLE.
;
;  $$X PERFORM A NON-PRINTING $X CYCLE UNTIL THE PC REACHES EITHER
;	.+1 OR .+2; I.E. UNTIL ONE OF THE NEXT 2 INSTRUCTIONS IS
;	EXECUTED.  THIS IS USEFUL FOR TREATING A SUBROUTINE CALL
;	AS A SINGLE INSTRUCTION FOR THE PURPOSES OF $X.


SKPMAX==4			;MAX # OF SKIPS WE TRY TO CATCH

;FLAGS USED IN $X LOGIC ONLY

	FAC== 1			;SIGNALS AC TO BE PRINTED
	DFAC== 2		;SIGNALS INST THAT USES 2 AC'S
	FLG== 4			;INST MODIFIES FLAGS (JRST,JFCL)
	IMM== 10		;SIGNALS IMMEDIATE MODE INST
	EA== 20			;SIGNALS MEMORY REFERENCE INST
	DEA== 40		;SIGNALS INST THAT REFERENCES 2 MEM LOCS
	FLA== 100		;SIGNALS FLOATING AC OPERAND
	FLE== 200		;SIGNALS FLOATING MEM OPERAND
	TWOPA==	400		;INSTRUCTION HAS 2 PART ADR COMPUTATION
	BPE==	1000		;BYTE MANIPULATION INSTRUCTION
	IMM2==	2000		;SECOND EA IS IMMEDIATE

;COME HERE FROM $X COMMAND, WITH T SET TO ZERO IF NO QUANTITY WAS
;   TYPED.

$X:	MOVEM	T,XTEM		;STORE REPETITION COUNT
	JUMPG	T,$X00		;JUMP IF POSITIVE COUNT
	HRRZ	T,PROC0		;ZERO, FETCH CURRENT PC
	MOVEM	T,LOCSAV	;AND REMEMBER IT
	SETOM	XTEM		;SET REPETITION COUNT NEGATIVE
	TLNN	F,CCF		;$$X WITH NO ARG?
	MOVNS	XTEM		;NO, ONLY $X. TREAT AS 1$X
$X00:	PUSHJ	P,CRF		;OUTPUT CRLF TO START

;HERE ON REPEATED $X CYCLES

$X01:	SOSN	XTEM		;DECREMENT AND TEST COUNTER
	TLZ	F,CCF		;CLEAR $$ FLAG TO END REPETITIONS
	TLZ	F,QF!CF!STF	;TURN OFF QUANT, $, ! FLAGS
	MOVEM	F,FLAGS		;SAVE REGULAR DDT FLAGS
	HRRZI	T,100		;SETUP MAX XCT DEPTH
	HRRZM	T,XCTS
	HRRZ	R,PROC0		;FETCH ADR OF CURRENT INST
	CAIN	R,XEC1		;JUST HIT BREAKPOINT OR DID $X LAST?
	JRST	ERR		;NO, JUST ENTERED DDT, SO ERROR
	SKIPL	XTEM		;INDEFINITE $$X BEING EXECUTED?
	MOVEM	R,LOCSAV	;NO, REMEMBER OLD PC FOR THIS INST
$X02:	PUSHJ	P,FETCH		;FETCH CURRENT INSTRUCTION
	 JRST ERR		;ERROR
$XO3:	MOVEM	T,I.NST		;STORE CURRENT INSTRUCTION
	JSR	SWAP		;SWAP TO USER CONTEXT
	MOVEM	T,SAFETY	;SAVE T

	SKIPN	KSFLAG		;SPECIAL EA CALC. FOR KS
	JRST	$X05		;JUMP IF NOT KS

;FOR KS EXTERNAL IO INSTRUCTIONS USE A 24 BIT EFFECTIVE ADDRESS.
;  THEREFORE IT NEEDS TO BE TREATED SPECIALLY
	HLRZ	T,I.NST		;GET THE OPCODE
	CAIG	T,710000	;TEST FOR EXTERNAL IO INSTRUCTION
	JRST	$X05		;NOT EXTERNAL IO INS
	MOVE	T,I.NST		;GET INSTRUCTION
	PUSH	P,W1		;SAVE W1
	MOVE	W1,I.NST	;SET W1 TO INST
	TLNN	T,17		;SEE IF INDEX SPECIFIED
	JRST	$X03B		;NO
	MOVS	T,T		;GET INDEX NO. IN LOWER HALF
	ANDI	T,17		;EXTRACT INDEX NUMBER
	TLNE	W1,20		;SEE IF INDERECT BIT SET
	JRST	$X03A		;YES

;INDEX REG. SPECIFIED AND NOT INDIRECT
	HLRZ	W1,(T)		;IF NOT SEE IF C(X)L IS POSITIVE
	JUMPLE	W1,$X03A		;JUMP IF NOT GT 0

;INDEX REG. SPECIFIED, NOT INDIRECT, AND XR LEFT GT. 0
	MOVE	W1,(T)
	HRRZ	T,I.NST		;COMPUTE EFFECTIVE ADDRESS
	ADD	W1,T		;EA=XR6-35+Y
	JRST	$X04		;GO SAVE EA

;INDEX REG SPECIFIED, AND (INDIRECT BIT SET OR XR LEFT LE 0)
$X03A:	HRRZ	W1,I.NST	;GET Y
	HRRZ	T,(T)		;GET C(XR) 18-35
	ADD	W1,T		;EA=XR 18-35 + Y
	MOVE	T,I.NST		;SET T FOR EFFECTIVE ADDR. CALC.

;NO INDEX REGISTER SPECIFIED FOR EA CALCULATION
$X03B:	TLNN	T,20		;SEE IF INDIRECT SET
	JRST	$X03C		;NOT INDIRECT ADDRESS

;NO INDEX REGISTER, BUT INDIRECT BIT SET
	HRRZ	T,W1
	MOVE	W1,(T)		;EA=14-35 OF INDIRECT WORD
	JRST	$X04		;GO SAVE EA

;NO INDEX REGISTER, NO INDIRECT BIT SET
$X03C:	HRRZ	W1,W1	;EA=Y 18-35
$X04:	MOVEM	W1,I.NSTEA	;SAVE EA
	POP	P,W1		;RESTORE W1
	JRST	$X06		;CONTINUE NORMALLY

$X05:	MOVEI	T,@I.NST	;COMPUTE EFFECTIVE ADR OF INST
	DPB	T,[POINT 23,I.NST,35]	;STORE COMPUTED ADR IN CURRENT INST
	HRRZM	T,I.NSTEA	;REMEMBER IT AGAIN
$X06:	MOVE	T,SAFETY	;RESTORE T
	JSR	SWAP		;SWAP BACK TO DDT CONTEXT
	LDB	W1,[POINT 4,I.NST,12]	;EXTRACT AC FIELD
	MOVEM	W1,I.NSTAC	;STORE IT AWAY
	MOVSI	T,777000	;MASK FOR OPCODE
	AND	T,I.NST		;FETCH OPCODE
	HLRZ	F,T		;SAVE IN RH FOR LATER
	CAMLE	T,$XTBL(T)	;IN RANGE OF CURRENT TABLE ENTRY?
	AOJA	T,.-1		;NO, KEEP SEARCHING
	JRST	@$XTBL(T)	;YES, DISPATCH

IFE	XMOD,<
	MONUI== JUSTI		;IF USER DDT, TREAT MONITOR UUOS
	MONUE== JUSTE		;  AS HARDWARE INSTRUCTIONS
	MONUAI==SETI
	MONUAE==SETEA
	MONINI==ERR		;CANNOT TRACE INIT
>

;OPCODE DISPATCH TABLE.
;   LH OF EACH ENTRY CONTAINS LARGEST OPCODE COVERED BY THAT ENTRY,
;   RH CONTAINS DISPATCH ADDRESS.

$XTBL:	SETZB	SET		; 400-403  SETZX
	ORCBB	CHECKI		; 404-473  ALL LOGICAL EXCEPT SETX
	SETOB	SET		; 474-477  SETOX
	HLRES	CHEKIS		; 500-577  HALFWORD
	TSON	TESTS		; 600-677  TEST CLASS
	777000,,IOTS		; 700-777  I/O INSTRUCTIONS
	0 ,, ERR		;     000  ALWAYS ILLEGAL
	037000,,USRUUO		; 001-037  USER UUOS
	CALL	MONUAE		;     040  CALL
	INIT	MONINI		;     041  INIT
	CALLI	MONUAI		; 042-047  UNDEFINED AND CALLI
	TTCALL	MONUE		; 050-051  OPEN,TTCALL
	054000,,MONUAI		; 052-054  UNDEFINED
	OUT	MONUE		; 055-057  RENAME,IN,OUT
	STATO	MONUI		; 060-061  SETSTS,STATO
	GETSTS	MONUE		;     062  GETSTS
	OUTBUF	MONUI		; 063-065  STATZ,INBUF,OUTBUF
	OUTPUT	MONUE		; 066-067  INPUT,OUTPUT
	USETO	MONUI		; 070-075  CLOSE,RELEAS,MTAPE,UGETF,USETI,USETO
	ENTER	MONUE		; 076-077  LOOKUP,ENTER
	103000,,SETI		; 100-103  UNDEFINED
	104000,,DOIT		;     104  JSYS
	107000,,SETI		; 105-107  UNDEFINED
	DFDV	DFLOT		; 110-113  DFAD,DFSB,DFMP,DFDV		*** KI10
	117000,,SETI		; 114-117  UNDEFINED
	DMOVN	DMOV		; 120-121  DMOVE,DMOVN			*** KI10
	FIX	FXAFLE		;     122  FIX				*** KI10
	123000,,SETI		;     123  UNDEFINED
	DMOVNM	DMOV		; 124-125  DMOVEM,DMOVNM		*** KI10
	FIXR	FXAFLE		;     126  FIXR				*** KI10
	FLTR	FLAFXE		;     127  FLTR				*** KI10
	UFA	IUFA		;     130  UFA
	DFN	IDFN		;     131  DFN
	FSC	IFSC		;     132  FSC
	IBP	IIBP		;     133  IBP
	ILDB	IIXBP		;     134  ILDB
	LDB	IXBP		;     135  LDB
	IDPB	IIXBP		;     136  IDPB
	DPB	IXBP		;     137  DPB
	FDVRB	FLOAT		; 140-177  FADXX,FSBXX,FMPXX,FDVXX

;CONTINUATION OF OPCODE DISPATCH TABLE.

	MOVMS	CHEKIS		; 200-217  MOVXX
	IMULB	CHECKI		; 220-223  IMULX
	DIVB	MULDIV		; 224-237  MULX,XDIVX
	LSH	SETI		; 240-242  ASH,ROT,LSH
	JFFO	IJFFO		;     243  JFFO
	LSHC	DBLI		; 244-246  ASHC,ROTC,LSHC
	247000,,SETI		;     247  UNDEFINED
	EXCH	SETEA		;     250  EXCH
	BLT	SETI		;     251  BLT
	AOBJN	IAOBJ		; 252-253  AOBJP,AOBJN
	JRST	IJRST		;     254  JRST
	JFCL	IJFCL		;     255  JFCL
	XCT	IIXCT		;     256  XCT
	MAP	SETI		;     257  MAP				*** KI10
	PUSHJ	IIPUSHJ		;     260  PUSHJ
	POP	SETEA		; 261-262  PUSH,POP
	POPJ	IPOPJ		;     263  POPJ
	JSR	I.JSR		;     264  JSR
	JSP	I.JSP		;     265  JSP
	JSA	I.JSA		;     266  JSA
	JRA	IAOBJ		;     267  JRA
	SUBB	CHECKI		; 270-277  ADDX,SUBX
	CAIG	SETI		; 300-307  CAIXX
	CAMG	SETEA		; 310-317  CAMXX
	SOSG	JMPSKP		; 320-377  JUMPXX,SKIPXX,AOJXX,AOSXX,SOJXX,SOSXX

;MONITOR UUO HANDLER

IFN	XMOD,<
MONUAI:	TLO	F,FAC		;REMEMBER TO PRINT AC
MONUI:	SKPEXC			;SKIP IF EXEC MODE
	JRST	JUSTI		;USER MODE, TREAT UUO AS SINGLE INST
	JRST	MONUE		;EXEC MODE, TRACE THE UUO

MONUAE:	TLO	F,FAC		;REMEMBER TO PRINT AC
MONUE:	SKPEXC			;SKIP IF EXEC MODE
	JRST	JUSTE		;USER MODE, TREAT UUO AS SINGLE INST
	JRST	ERR		;PUNT IF EXEC MODE

MONINI:	SKPEXC			;SKIP IF EXEC MODE
	JRST	ERR		;USER MODE, CAN'T FOLLOW AN INIT
				;EXEC MODE, TRACE NORMALLY
>
;USER UUO HANDLER

USRUUO:	MOVEI	R,40		;SETUP JOBUUO
	EXCH	F,FLAGS		;RESTORE REGULAR FLAGS
	MOVE	T,I.NST		;FETCH INST WITH EFF ADR COMPUTED
	PUSHJ	P,DEP	;STORE USER UUO IN JOBUUO
	 JRST ERR		;ERROR
	EXCH	F,FLAGS		;RESTORE $X FLAGS
	MOVE	T,[XCT 41]	;PRETEND INSTRUCTION WAS AN XCT
	JRST	$XO3

;INTERPRET UFA

IUFA:	TLOA	F,FLA+FLE+DFAC	;REMEMBER FLTG PT, USES 2 AC'S

;INTERPRET DFN

IDFN:	TLO	F,FLA!FLE	;DFN, REMEMBER AC AND E FLOAT
	JRST	SETEA

;INTERPRET FLOATING POINT INSTRUCTIONS

FLOAT:	ANDI	F,7000		;FLOATING PT, GET MODE
	CAIN	F,1000		;LONG MODE?
	TLOA	F,DFAC		;YES, PRINT 2 AC'S
	CAIE	F,5000		;IMMEDIATE MODE?
	TLOA	F,FLA+FLE+FAC+EA	;NO, PRINT AC AND E BOTH FLOATING
FLOATI:	TLO	F,FLA+FLE+FAC+IMM	;YES, PRINT AC AND E IMMEDIATE FLTG
	JRST	DOIT

;INTERPRET JRST

IJRST:	TLO	F,IMM		;REMEMBER TO PRINT E
	TRNE	W1,2		;IS INSTRUCTION JRSTF?
	TLO	F,FLG		;YES, REMEMBER TO PRINT FLAGS
IJRST0:	PUSHJ	P,FETCH		;FETCH INST OR INDIRECT WORD
	 JRST ERR		;ERROR
	MOVE	W1,T		;COPY INTO W1
	LDB	R,[POINT 4,T,17]	;LOAD INDEX FIELD
	JUMPE	R,IJRST1	;JUMP IF NO INDEXING TO PERFORM
	MOVE	T,AC0(R)	;FETCH CONTENTS OF INDEX REGISTER
	TLZ	T,(Z @(17))	;CLEAR I AND X FIELDS IN INDEX REG
	ADDI	T,(W1)		;COMPUTE INDEXED ADDRESS
	TLZ	T,(Z @(17))	;CLEAR ANY OVERFLOW
IJRST1:	MOVEI	R,(T)		;COPY RESULTING ADDRESS
	TLNE	W1,(@)		;INDIRECT?
	JRST	IJRST0		;YES, FOLLOW NEXT LEVEL OF INDIRECTION

;LH OF T NOW CONTAINS FLAGS THAT WILL BE RESTORED

IFN	XMOD,<
	SKPEXC			;NOW IN EXEC MODE?
	JRST	IJRST3		;NO, USER MODE
	MOVE	W1,I.NSTAC	;YES, FETCH AC FIELD OF JRST INST
	TRNE	W1,1		;JUMP TO USER MODE?
	JRST	JRSPRC		;YES, CAN'T TRACE. GO DO $P
	TRNE	W1,2		;JRSTF?
	TLNN	T,(1B5)		;YES, GOING TO ENTER USER MODE?
	JRST	IJRST3		;NO TO EITHER, HANDLE NORMALLY
JRSPRC:	EXCH	F,FLAGS		; $X OPERATION IMPOSSIBLE. RESTORE FLAGS
	TLZ	F,QF+CCF	;CLEAR QUANT AND $$ FLAGS
	JRST	PROCD1		;AND EXECUTE $P TO GO INTO USER MODE
>

IJRST3:	HRRI	T,NOSKIP	;MODIFY THE JRST EFFECTIVE ADR
	MOVEM	T,BCOM		;STORE NEW FLAGS,,NOSKIP
	MOVE	T,I.NST		;FETCH INST AGAIN
	HRRM	T,PROC0		;STORE EFF ADR AS NEW PC
	HRRI	T,BCOM		;TURN INTO JRST @BCOM
	TLO	T,(@)
	MOVEM	T,I.NST		;AND STORE
	JRST	DOIT		;DO IT

;INTERPRET XCT

IIXCT:
IFN	XMOD,<
	DPB	W1,[POINT 4,I.XCT,12]>	; USE IN XCT PAGED
	MOVE	F,FLAGS		;GET BACK NORMAL DDT FLAGS
	SOSG	XCTS		;CHECK XCT COUNTER
	JRST	ERR		;ERROR - DEPTH EXCEEDED
	TLNE	F,CCF		;$$X?
	JRST	IIXCT1		;YES, DON'T PRINT ANYTHING
	HRRZ	T,I.NSTEA	;GET EFF ADR OF XCT
	PUSHJ	P,PINST		;PRINT INST BEING XCT'ED
	PUSHJ	P,CRF		;OUTPUT CRLF AFTER INST
IIXCT1:	HRRZ	R,I.NSTEA	;GET EFF ADR OF XCT AGAIN
	JRST	$X02		;PROCESS EXECUTED INST

;INTERPRET PUSHJ

IIPUSHJ:AOS T,PROC0		;GET CURRENT PC +1
	HLL	T,SAVPI		;PUT FLAGS IN LH
	MOVEM	T,I.NSTPC	;STORE AWAY TO BE STACKED
	MOVSI	T,(1B4)		;CLEAR BIS FLAG IN NEW PC WORD
	ANDCAM	T,SAVPI
	SOS	T,I.NST		;GET EFF ADR OF PUSHJ, -1 TO FOOL DOIT
	HRRM	T,PROC0		;STORE NEW PC -1
	HRLZI	T,(<PUSH>-<PUSHJ>)	;WANT TO TURN PUSHJ INTO A PUSH
	DPB	T,[POINT 5,I.NST,17]	;CLEAR I AND AC FIELD
	JRST	IPOPJ2		;REST OF CODE COMMON WITH POPJ

;INTERPRET POPJ

IPOPJ:	EXCH	F,FLAGS		;POPJ, RESTORE NORMAL DDT FLAGS
	HRRZ	R,AC0(W1)	;FETCH CONTENTS OF CORRECT USER AC
	PUSHJ	P,FETCH		;FETCH PCWORD IT POINTS TO
	 JRST ERR		;ERROR
	EXCH	F,FLAGS		;RESTORE $X FLAGS
	HRRI	T,-1(T)		;DECREMENT PC TO FOOL CODE AT DOIT
	HRRM	T,PROC0		;STORE AS CURRENT PC
	HRLZI	T,(<POP>-<POPJ>)	;SETUP TO TURN POPJ INTO POP

;COMMON CODE FOR PUSHJ, POPJ

IPOPJ2:	ADDM	T,I.NST		;TURN PUSHJ INTO PUSH OR POPJ INTO POP
	HRRZI	T,I.NSTPC	;SETUP ADR OF PC WORD FOR PUSHJ
	HRRM	T,I.NST
	TLOA	F,FAC		;REMEMBER TO PRINT AC

;INTERPRET FSC

IFSC:	TLO	F,FAC+FLA+IMM	;FLOATING AC, FIXED IMMEDIATE E
	JRST	DOIT

;INTERPRET JSA

I.JSA:	AOS	T,PROC0		;JSA, SETUP RETURN PC
	HRL	T,I.NSTEA	;PUT EFF ADR IN LH LIKE JSA DOES
	EXCH	T,AC0(W1)	;STORE IN USER AC, GET OLD CONTENTS
	JRST	I.JSR2		;STORE OLD CONTENTS LIKE JSR, THEN JUMP

;INTERPRET JSR

I.JSR:	AOS	T,PROC0		;JSR, GET CURRENT PC
	HLL	T,SAVPI		;SETUP LH OF PC WORD
	TLO	F,FAC		;REMEMBER NOT TO PRINT AC FIELD
	MOVSI	W1,(1B4)	;CLEAR BIS FLAG IN NEW PC WORD
	ANDCAM	W1,SAVPI
I.JSR2:	TLO	F,EA		;PRINT E NORMALLY
	EXCH	F,FLAGS		;RESTORE NORMAL DDT FLAGS
	HRRZ	R,I.NSTEA	;FETCH EFF ADR OF JSR OR JSA
	PUSHJ	P,DEP	;STORE PC WORD
	 JRST ERR		;ERROR
	EXCH	F,FLAGS		;RESTORE $X FLAGS
	HRRZ	T,I.NSTEA	;GET EFF ADR AGAIN
	AOJA	T,I.JSR4	;INC PAST STORED PC WORD

;INTERPRET JSP

I.JSP:	AOS	T,PROC0		;JSP, SETUP RETURN PC
	HLL	T,SAVPI		;SETUP LH OF PC WORD
	MOVEM	T,AC0(W1)	;STORE IN USER AC
	MOVSI	T,(1B4)		;CLEAR BIS FLAG IN NEW PC WORD
	ANDCAM	T,SAVPI
	HRRZ	T,I.NSTEA	;GET BACK EFF ADR
I.JSR4:	HRRM	T,PROC0		;STORE NEW PC
	TLC	F,FAC		;REMEMBER TO PRINT AC
	JRST	TELL		;GO PERFORM PRINTOUT
;INTERPRET KI10 INSTRUCTIONS

DFLOT:	TLO	F,FLA+FLE	;REMEMBER THAT AC AND E ARE FLOATING
DMOV:	TLO	F,DFAC+DEA	;REMEMBER AC AND E BOTH DOUBLE
	JRST	SETEA

FXAFLE:	TLOA	F,FLE		;REMEMBER THAT E FLOATS (FIX,FIXR)
FLAFXE:	TLO	F,FLA		;REMEMBER THAT AC FLAOATS (FLTR)
	JRST	SETEA

;HERE TO INTERPRET BYTE MANIPULATION INSTRUCTIONS
;TREAT ILDB/IDPB AS IBP THEN LDB/DPB

IIXBP:	MOVSI	T,(1B8)		;CONVERT TO LDB/DPB
	IORM	T,I.NST		; . . .
	JSR	SWAP		;GET USER CONTEXT
	IBP	@I.NSTEA	;INCREMENT POINTER
	JRST	IXBP1		; COMMON CODE
IIBP:	TLO	F,IMM2!FAC	;FOR IBP NO AC, 2ND EA IMMEDIATE
IXBP:	JSR	SWAP		;GET USER CONTEXT
IXBP1:	MOVEM	T,I.EA2		;SAVE USER'S AC
	MOVSI	T,(@)		;GET INDIRECT BIT
	IORM	T,I.NSTEA	;SET IN EA OF INSTR
	MOVE	T,I.EA2		;GET AC FOR ADDR COMUTATION
	MOVEI	T,@I.NSTEA	;GET EFF ADDR OF POINTER
	EXCH	T,I.EA2		;RESTORE USER'S ACS
	JSR	SWAP		;CONTEXT SWITCH BACK TO DDT
	HRRZS	I.NSTEA		;CLEAR INDIRECT BIT IN E FIELD
	TLC	F,FAC!EA!TWOPA!BPE	;SET FLAGS (CLEAR FAC IF IBP)
	JRST	DOIT		;AND GO DO GRUNDGE

;INTERPRET JFFO

IJFFO:	TLO	F,DFAC		;REMEMBER JFFO USES 2 AC'S

;INTERPRET JUMP AND SKIP INSTRUCTIONS

JMPSKP:	TRNE	F,10000		;JUMP/SKIP, WHICH IS IT?
	JRST	SKP		;SKIP CLASS

;INTERPRET AOBJN AND AOBJP

IAOBJ:	TLOA	F,FAC+IMM	;HANDLE AS IMMEDIATE MODE INST WITH AC

;INTERPRET JFCL

IJFCL:	TLO	F,FLG		;REMEMBER TO PRINT FLAGS
	MOVEI	T,JMP		;JUMP CLASS OR AOBJ, COME BACK TO $X
	HRRM	T,I.NST		;STORE MODIFIED INST
	JRST	DOIT		;GO EXECUTE CONDITIONAL INST

;HERE AFTER EXECUTING CONDITIONAL JUMP INSTRUCTION THAT ACTUALLY
;   DOES JUMP

JMP:	EXCH	T,I.NSTEA	;SAVE T, GET EFF ADR OF JUMP
	HRRM	T,PROC0		;STORE EFF ADR AS NEW PC
	EXCH	T,I.NSTEA
	JRST	NOSKIP		;NOW DO PRINTOUT

;HERE FOR ALL SKIP INSTRUCTIONS

SKP:	JUMPN	W1,SETEA	;SKIP CLASS - AC FIELD ZERO?
JUSTE:	TLOA	F,EA		;YES, JUST PRINT E

;INTERPRET SHIFT COMBINED INSTRUCTIONS

DBLI:	TLO	F,FAC+DFAC+IMM	;REMEMBER 2 AC'S USED, IMMEDIATE
	JRST	DOIT		;EXECUTE NORMALLY

;INTERPRET TEST CLASS INSTRUCTIONS

TESTS:	TRNN	F,10000		;SKIP ON TD OR TS BUT NOT ON TR OR TL
	TLOA	F,FAC+IMM	;IMMEDIATE MODE
	TLO	F,FAC+EA	;NORMAL MODE
	JRST	DOIT

;I/O INSTRUCTIONS

IOTS:	SKIPE	KSFLAG
	 JRST	IOTS1	;JUMP IF KS
	TRNE	W1,4		;SKIP IF BLKI,DATAI,BLKO,DATAO
	CAIN	W1,5		;SKIP IF NOT CONI
	TLOA	F,EA		;MEM REF INSTRUCTION
JUSTI:	TLO	F,IMM		;IMMEDIATE INST
	JRST	DOIT

;KS IO INSTRUCTION FORMAT DIFFERENT FROM KL/KI

IOTS1:	CAIL	T,71000		;SKIP IF INTERNAL IO INSTRUCTION
	 JRST	IOTS2		;TREAT EXTERNAL IO INS AS IMMED.
	TRNN	W1,4		;SKIP IF A READ FORMAT
	CAIL	T,702000	;IF LESS THEN 702000 ADDR IS IMMED.
	TLOA	F,EA		;MEM REF INSTRUCTION
IOTS2:	TLO	F,IMM		;IMMEDIATE INST
	JRST	DOIT

;ALL PATHS CONVERGE HERE

CHEKIS:	TRC	F,3000		;HERE TO TEST FOR IMMEDIATE OR SELF MODE
	TRCE	F,3000		;SKIP IF SELF MODE
	JRST	CHECKI		;NO, CHECK IMMEDIATE
	JRST	SKP		;YES, GO TEST FOR NONZERO AC FIELD
SET:	ANDI	F,3000		;HERE FOR SETZX,SETOX
	CAIE	F,2000		;SETZM,SETOM?
	TLO	F,FAC		;NO, AC IS ALWAYS AFFECTED
	TRNE	F,2000		;SETZM,SETZB,SETOM,SETOB?
	TLO	F,EA		;YES, MEM IS ALWAYS AFFECTED
	JRST	DOIT

;FIXED POINT MULTIPLY AND DIVIDE (NOT INCLUDING IMULX)

MULDIV:	ANDI	F,3000		;MASK MODE BITS
	CAIE	F,2000		;TO MEMORY ONLY?
	TLO	F,DFAC		;NO, INST USES 2 AC'S
CHECKI:	TRNE	F,1000		;TEST FOR IMMEDIATE MODE INST
	TRNE	F,2000
SETEA:	TLOA	F,FAC+EA	;MEM REF INSTRUCTION
SETI:	TLO	F,FAC+IMM	;IMMEDIATE MODE INSTRUCTION
DOIT:	EXCH	F,FLAGS		;RESTORE NORMAL DDT FLAGS
	PUSHJ	P,TTYLEV	;RESTORE STATUS OF CTY (EXEC MODE)
	SETZM	XSKP		;[211] NOTE NUMBER OF SKIPS
	JSR	SWAP		;SWAP TO USER CONTEXT
I.XCT:	XCT	I.NST		;EXECUTE THE INSTRUCTION (IF IN EXEC MODE
				; ON A KI10 THIS MAY BE EXECUTIVE XCT)
	REPEAT	SKPMAX,<AOS XSKP>	;[211] NOTE COUNT OF SKIPS
	MOVEM	T,SAFETY	;SAVE USER T
	MOVEI	T,SKPMAX + 1	;[211] MAX AMOUNT CAN BE SKIPPED
	SUB	T,XSKP		;[211] MINUS THOSE NOT SKIPPED
	ADDM	T,PROC0		;[211] IS THOSE SKIPPED, UPDATE PC
	SETZM	XSKP		;[211] CLEAR COUNTER
	MOVE	T,SAFETY	;[211] RESTORE T

;HERE AFTER SIMULATING OR EXECUTING INSTRUCTION.
;  PERFORM REQUIRED PRINTOUT.

NOSKIP:	JSR	SWAP		;RESTORE DDT CONTEXT
	PUSHJ	P,TTYRET	;RESTORE DDT TTY MODES
	JRST	.+2
TELL:	EXCH	F,FLAGS		;GET DDT'S FLAGS
IFN	XMOD,<
	MOVEI	T,0		;CLEAR THE AC FIELD OF I.XCT
	DPB	T,[POINT 4,I.XCT,12]	;SO NEXT INSTRUCTION HAPPENS OK
>
	TLNE	F,CCF		;IF $$X, DON'T PRINT ANYTHING
	JRST	NXTIT
	EXCH	F,FLAGS		;RESTORE $X'S FLAGS
	PUSH	P,SCH		;SAVE CURRENT OUTPUT MODE
	TLNE	F,FLA		;FLOATING AC?
	MOVEI	SCH,TFLOT	;YES, SETUP TO OUTPUT IN FLOATING PT
	TLNE	F,FAC		;AC TO BE PRINTED?
	PUSHJ	P,FAC0		;YES, DO IT
	TLNE	F,DFAC		;INST USE 2 AC'S?
	PUSHJ	P,DBL0		;YES, PRINT LOW-ORDER AC
	TLNE	F,FLG		;INSTRUCTION ACCESS THE FLAGS?
	PUSHJ	P,FLG0		;YES, PRINT FLAGS
	MOVE	SCH,(P)		;RESTORE OLD MODE
	TLNE	F,FLE		;FLOATING MEMORY OPERAND?
	MOVEI	SCH,TFLOT	;YES, SETUP FLTG OUTPUT
	TLNE	F,BPE		;C(E) A BYTE POINTER
	MOVEI	SCH,PBYPT1	;YES - TYPE AS SUCH
	TLNE	F,IMM		;IMMEDIATE MODE?
	PUSHJ	P,IMM0		;YES, JUST PRINT E
	TLNE	F,EA		;MEM REF INST?
	PUSHJ	P,EA0		;YES, PRINT C(E)
	TLNE	F,DEA		;DOUBLE-WORD MEM OPERAND?
	PUSHJ	P,DEA0		;YES, OUTPUT 2ND WORD
	POP	P,SCH		;RESTORE CURRENT OUTPUT MODE
	TLNN	F,TWOPA		;TWO-PART ADDRESS COMPUTATION?
	JRST	NOSKIQ		;NO
	MOVE	T,I.EA2		;YES - GET E(C(E))
	EXCH	T,I.NSTEA	;E:=E(C(E))
	MOVEM	T,I.EA2		;REMEMBER E
	TLNE	F,IMM2		;SECOND E IMMEDIATE?
	PUSHJ	P,IMM0		;YES - TYPE E(C(E))
	TLNN	F,IMM2		;SECOND E IMMEDIATE?
	PUSHJ	P,EA0		;NO - TYPE E(C(E))/C(E(C(E)))
	MOVE	T,I.EA2		;GET FIRST E BACK
	MOVEM	T,I.NSTEA	;AND RESTORE TO RIGHTFUL PLACE
NOSKIQ:	EXCH	F,FLAGS		;RESTORE DDT FLAGS
	PUSHJ	P,CRF		;OUTPUT CRLF

;NOW TEST WHETHER TO CONTINUE, AND PRINT NEXT INST IF REQUIRED.

NXTIT:	HRRZ	T,PROC0		;FETCH NEW PC
	MOVEI	W1,1(T)		;COMPUTE PC+1
	HRRZM	W1,BCOM		;STORE FOR $P
	HRRZ	W1,LOCSAV	;FETCH OLD PC
	SKIPL	XTEM		;INDEFINITE $$X IN PROGRESS?
	JRST	NXT0		;NO
	CAIL	T,1(W1)		;[211] YES - AT OLD-PC+1
	CAILE	T,SKPMAX+1(W1)	;[211] TO OLD-PC+1+SKPMAX?
	CAIA			;[211] NO.
	JRST	$XQUIT		;YES, STOP ITERATION NOW
NXT0:	PUSHJ	P,LISTEN	;NO, HAS USER TYPED ANYTHING?
	 JRST NXT1		;NO, CONTINUE
$XQUIT:	SETZM	XTEM		;YES, STOP ITERATION BY ZEROING COUNTER
	TLZ	F,CCF		;  AND CLEARING CONTROL FLAG
NXT1:	TLNE	F,CCF		;$$ STILL IN EFFECT?
	JRST	NXT2		;YES, DON'T PRINT ANYTHING
	HRRZ	T,PROC0		;NO, GET CURRENT PC AGAIN
	CAIN	T,1(W1)		;DOES IT EQUAL OLD PC +1?
	JRST	NXT1A		;YES--JUST CONTINUE
	CAIN	T,2(W1)		;SKIP OR JUMP
	SKIPA	W1,[ASCII "<SKP>"]	;SKIP
	MOVE	W1,[ASCII "<JMP>"]	;JUMP
	PUSHJ	P,TEXT2		;SAY SKIP OR JUMP
	PUSHJ	P,CRF		;ADD CRLF
NXT1A:	HRRZ	T,PROC0		;FETCH CURRENT PC AGAIN
	PUSHJ	P,PINST		;PRINT INSTRUCTION ABOUT TO BE EXECUTED
	SKIPE	XTEM		;ARE WE STILL LOOPING?
	PUSHJ	P,CRF		;YES, PRINT CRLF AFTER INST
NXT2:	SKIPE	XTEM		;SKIP IF REPEAT COUNTER IS ZERO
	JRST	$X01		;NONZERO, REPEAT $X CYCLE AGAIN
	JRST	TTYCLR		;ZERO, FLUSH ANY WAITING INPUT CHARACTERS
				;   AND RETURN FROM $X INSTRUCTION

;OUTPUT ROUTINES

;ROUTINE TO PRINT SECOND ACCUMULATOR

DBL0:	AOS	T,I.NSTAC	;INCREMENT AC NUMBER
	TRZA	T,777760	;ENSURE 17 WRAPS AROUND TO 0

;ROUTINE TO PRINT CONTENTS OF ACCUMULATOR

FAC0:	MOVE	T,I.NSTAC	;FETCH AC NUMBER
	JRST	EA2

;ROUTINE TO PRINT THE FLAGS

FLG0:	PUSHJ	P,LCT		;PRINT TAB
	HLRZ	T,SAVPI		;GET LH OF PC WORD
	JRST	IMM1		;PRINT FLAGS

;ROUTINE TO PRINT JUST E FOR AN IMMEDIATE MODE INSTRUCTION

IMM0:	PUSHJ	P,LCT		;PRINT TAB
	HRRZ	T,I.NSTEA	;FETCH E
	TLNE	F,FLE		;FLTG PT MEM OPERAND?
	MOVS	T,T		;YES, IMMEDIATE SWAPS HALVES
IMM1:	EXCH	F,FLAGS		;RESTORE DDT FLAGS
	PUSHJ	P,CONSYM	;OUTPUT CONTENTS OF T
	JRST	EA6		;RESTORE $X FLAGS AND RETURN

;ROUTINE TO PRINT 2ND MEMORY OPERAND

DEA0:	AOS	I.NSTEA		;INC TO ADR OF 2ND OPERAND

;ROUTINE TO PRINT MEMORY OPERAND

EA0:	MOVE	T,I.NSTEA	;FETCH ADR OF MEM OPERAND
EA2:	EXCH	F,FLAGS		;HERE FROM DBL0,FAC0
	PUSH	P,T		;SAVE ARG
	PUSHJ	P,LCT		;OUTPUT TAB
	POP	P,T		;RESTORE ADR OF LOC TO BE PRINTED
	PUSHJ	P,LI1		;PRINT ADR/ CONTENTS
EA6:	EXCH	F,FLAGS		;RESTORE $X FLAGS
	POPJ	P,

;ROUTINE TO PRINT INSTRUCTION ALWAYS IN SYMBOLIC DESPITE CURRENT MODE

PINST:	PUSH	P,SCH		;SAVE CURRENT OUTPUT MODE
	MOVEI	SCH,PIN		;SET TO PRINT SYMBOLIC INST MODE
	PUSHJ	P,LI1		;OUTPUT INST
	POP	P,SCH		;RESTORE CURRENT MODE
	POPJ	P,

;ROUTINE TO SWAP BETWEEN DDT AND USER CONTEXTS.
;   AC'S AND FLAGS ARE SWAPPED, BUT BREAKPOINTS AND OTHER STUFF
;   ARE NOT TOUCHED, SINCE CONTROL IS EXPECTED TO RETURN TO DDT SOON.

SWAP:	0
	EXCH	0,AC0		;SWAP AC 0
	MOVEM	0,SAV0		;SAVE 0 FOR WORK
	HLLZ	0,SWAP		;GET CURRENT FLAGS
	HLR	0,SAVPI		;GET SAVED FLAGS
	HRLM	0,SWAP		;SWITCH FLAGS
	HLLM	0,SAVPI
	MOVE	0,[EXCH 1,AC0+1]	;SETUP INST FOR SWAPPING AC'S
SWAPL:	XCT	0		;SWAP AN AC
	ADD	0,[Z 1,1]	;INC AC AND MEM FIELDS
	TLNN	0,1000		;AC 20 REACHED?
	JRST	SWAPL		;NO, LOOP
	MOVE	0,SAV0		;YES, RESTORE SAVED AC
	JRSTF	@SWAP		;RETURN, RESTORING NEW FLAGS
;VARIABLES

XSKP:	0
I.NST:	0			;INSTRUCTION BEING EXECUTED
SAV0:	0			;SAVES AC 0 IN SWAP ROUTINE
XCTS:	0			;XCT DEPTH COUNTER
I.NSTAC: 0			;AC FIELD OF INSTR BEING EXECUTED
I.NSTEA: 0			;E FIELD OF INSTR BEING EXECUTED
I.EA2:	0			;SECOND EA FIELD FOR TWO PART ADDR COMPUTATION
XTEM:	0			;$X REPEAT COUNTER
I.NSTPC: 0			;PC OF INST BEING EXECUTED
FLAGS:	0			;SAVES DDT FLAGS
LOCSAV:	0			;SAVES LOC OF INST BEING EXECUTED
SAFETY:	0			;SAVES T
>				;END IFE FLDDT

IFN FLDDT,<
LODAC:	MOVEI W1,AC0
	HRRZ R,T
	MOVEM R,ACSPTR	;SAVE FOR ALTERNATE AC BLOCK USE
	HRLI R,-20
	PUSHJ P,MOVSTF	;MOVE INTO ACS OR AC BLOCK 2
	 JRST ERR	;ERROR IN FETCHING
	JRST DD1

MOVSTF:	PUSHJ P,FETCH
	 POPJ P,
	MOVEM T,(W1)
	ADDI W1,1
	AOBJN R,MOVSTF
	JRST CPOPJ1

LOADP1:	HRRZ R,T
	PUSHJ P,FETCH
	 JRST ERR
LOADP0:	PUSH P,T	;SAVE REQUESTED
	CAMN T,[-1]		;-1 is flag to do Virtual Peek
	 JRST MAPDON
	JUMPE T,MAPDON	;DONE IF 0
	SETZM MAPWRD
	HLRZ R,(P)
	LSH R,9		;GET USER PAGE INFO
	HRLI R,-420	;AND SOME EXEC
	MOVEI W1,MAP
	PUSHJ P,MOVSTF
	 JRST ERRLP	;GIVE UP AND ZERO PAGE WORD
	HRRZ R,(P)
	LSH R,9
	HRLI R,-200
	ADDI R,200
	PUSHJ P,MOVSTF	;REMAINDER OF EXEC TABLE
	 JRST ERRLP
MAPDON:	POP P,MAPWRD
	JRST DD1

ERRLP:	POP P,T		;JUST GET RID OF IT (MAPWRD IS 0)
	JRST ERR

LODMP1:	SKIPN MAPWRD
	JRST ERR	;NOT MAPPING, CAN NOT DO IT
	HRRZ W1,T
	LSH W1,-9	;THIS IS THE PAGE TO SET UP MAP FOR
	CAIL W1,400
	CAILE W1,777
	JRST ERR	;MUST BE IN RANGE
	ROT W1,-1
	ADDI W1,MAP+420-200	;POINT TO START OF EXEX MAP
	TLZN W1,(1B0)
	TLOA W1,(POINT 18,0,17)
	HRLI W1,(POINT 18,0,35)
	HLRZS T
	ANDI T,17777
	TRO T,PGE.A!PGE.W
	DPB T,W1
	JRST DD1

LODAXP:	HRRZ R,T
	PUSHJ P,FETCH
	 JRST ERR
	MOVEM T,ACXSPT	;STORE IN AC STACK POINTER
	JRST DD1

LODAC2:	SUBI T,20
	MOVEM T,ACSPTR	;STORE FOR ALTERNATE AC BLOCKS
	JRST DD1>
IFN XMOD,<
LODMP1:	HRRZ W1,T
	LSH W1,-9	;GET PAGE
	CAIL W1,400
	CAILE W1,777	;MUST BE MAPPED THROUGH EPT
	JRST ERR
	ROT W1,-1
	TLZN W1,(1B0)
	TLOA W1,(POINT 18,0,17)
	HRLI W1,(POINT 18,0,35)
	HLRZS T
	ANDI T,17777
	TRO T,PGE.A!PGE.W	;SET UP PAGE
	SKIPE	KSFLAG		;SKIP IF NOT KS
	 JRST	[RDEBR	R	;GET EBR
		JRST	LODMP2]
	SKIPE	KLMAPF		;SKIP IF NOT KL MAP (KS CHECKED FOR ALREADY)
	 JRST	[CONI	PAG,R	;GET EBR
		JRST	LODMP2]
	DATAI	PAG,R		;GET EBR FOR KI
LODMP2:	PUSH P,R
	ANDI R,17777	;GET PAGE OF EPT
	CAIGE R,340	;IF NOT IN MAPPED AREA
	CAIG R,0	;OR 0
	JRST ERR	;FORGET IT
	LSH R,9
	ADD W1,R
	DPB T,W1	;SET UP SLOT IN EPT
	POP P,R
	SKIPE	KSFLAG		;SKIP IF NOT A KS
	 JRST	[WREBR	R
		JRST	LODMP3]
	SKIPE	KLMAPF		;SKIP IF NOT KL MAP (KI)
	 JRST	[CONO	PAG,R
		JRST	LODMP3]
	TRO R,[1B0+1B18]
	DATAO PAG,R
LODMP3:	JRST DD1>

IFN FRMDDT,<
SETFRM:	HRRZM	T,FRAME
	JRST	DD1
>;END IFN FRMDDT
IFE FRMDDT,<SETFRM==ERR>
;ROUTINE CALLED BY MIGHTYCHAIN WHEN IT DOES AN OVERLAY
;AC1=HIGHEST UNCHANGED LOCATION, AC2-AC5 AVAILABLE

IFE XMOD!FLDDT,<	;ONLY IN USER DDT
DDTCH.:	MOVEI 2,B1ADR
DDTCH1:	HRRE 3,(2)	;CHECK BREAKPOINTS
	CAIG 3,(1)	;THIS CLEVERLY IGNORES HISEG STUFF
	JRST DDTCH2
	SETZM (2)	;BREAKPOINT IN OVERLAY, ZAP IT
	SETZM 1(2)
	SETZM 2(2)
	SETZM 3(2)
DDTCH2:	ADDI 2,4
	CAIG 2,BNADR
	JRST DDTCH1
	POPJ 17,	;STUPID DDT HAS P DEFINED AS AC1 - NO ONE DOES THAT!
>
;BREAK POINT LOGIC
%%BPL==0
BP1:	REPEAT NBP,<	0		;JSR TO HERE FOR BREAKPOINT
IFE XMOD,<	JSA T, BCOM>
IFN XMOD,<	JSA T,BPZOT+1+%%BPL*BPILEN
%%BPL==%%BPL+1>
	0		;HOLDS INSTRUCTION WHILE BREAKPOINT IS IN PLACE
	0		;HISEG PTR FOR BREAKPOINT IN HISEG
>

B1INS=BP1+2
BPN=.-4

IFN XMOD,<
BPZOT:	REPEAT NBP,<BPISC==.
	0
	BPISA==.
	0
	SKPEXC
	JRST .+3
	CONI PI,BPISC
	CONO PI,1B27
	JSA T,BCOMM
BPIBC==.
	CONO PI,0
	0
	SKIPA
	AOS .+1
	JRST 0
	BPIDT==.
REPEAT XCTLEN,<0>
BPILEN==.-BPISC>

BCOMM:	0			;JSA HERE FROM BP1BC+N,
				; STORES BPZOT+<BPISA*N>,,BP1+N+2
	MOVE T,BPISA-BPIBC(T)	;PICKUP PROGRAMS AC T
	MOVEM T,BCOM		;SAVE IN BCOM, JUST LIKE JSA BCOM
	HRRZ T,BCOMM		;GET BP1+N+2 IN T
	HRLI T,BCOM		;GET ADDR TO RESTORE FROM IN LH(T)
				; (LIKE JSA T,BCOM ONLY RETURNS TO BCOMM)
	JRST BCOM+1
BCOMX:	0	;SAVE BCOMM HERE ON $X
>
BCOM:	0
	POP T,LEAV		;MOVE INSTRUCTION TO LEAV
	MOVEI T,B1SKP-B1INS+1(T)
	HRRM T,BCOM3		;CONDITIONAL BREAK SETUP
	MOVEI T,B1CNT-B1SKP(T)
	HRRM T,BCOM2		;PROCEDE COUNTER SETUP
	MOVE T,BP1-B1CNT(T)
IFN XMOD,<SKPUSR
	TLZ T,010000		;TURN OFF USER MODE BIT>
	HLLM T,LEAV1		;SAVE FLAGS FOR RESTORING
	EXCH T,BCOM

BCOM3:	SKIPE B1SKP		;ADDR MOD TO LOOK AT COND. INST.
	XCT @.-1
BCOM2:	SOSG B1CNT		;ADDR MOD TO LOOK AT PROCEED COUNTER
	JRST BREAK

	MOVEM T,AC0+T
	LDB T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIL T,264	;JSR
	CAILE T,266	;JSA,JSP
	TRNN T,700	;UUO
	JRST PROC1		;MUST BE INTERPRETED
	CAIE T,260	;PUSHJ
	CAIN T,256	;XCT
	JRST PROC1		;MUST BE INTERPRETED
IFN XMOD,<SKPEXC
	JRST BCOMUS
	MOVEM W,AC0+W
	HLRS W,BCOMM
	ADDI W,BPIBC-BPISA
	MOVE T,BPISC-BPIBC(W)
	ANDI T,1B28
	HRRM T,(W)	;SET CONO TO PI SYSTEM
	MOVE T,LEAV
	MOVEM T,1(W)
	HRRZ T,BCOM
	HRRM T,4(W)
	HRRM W,LEAV1
	MOVE W,AC0+W
BCOMUS:>
	MOVE T,AC0+T
	JRST 2,@LEAV1		;RESTORE FLAGS, GO TO LEAV

LEAV1:	XWD 0,LEAV

RETB:	HRRZ T,BCOM2
	SKIPE T,1(T)	;STRING THERE??
	HRLI T,(POINT 7,0)
	MOVEM T,STRING	;SET IT UP
	JRST RET
BREAK:	JSR SAVE		;SAVE THE WORLD
	PUSHJ P,REMOVB		;REMOVE BREAKPOINTS
	PUSHJ P,CHKSYM	;SEE IF SYMBOLS HAVE MOVED
	PUSHJ P,TTYCLR
	SOS A,BCOM3
	HRRZS A			;GET ADR OF CONDITIONAL BREAK INST
	SUBI A,B1ADR-4		;CHANGE TO ADDRESS OF $0B
	IDIVI A,4		;QUOTIENT IS BREAK POINT NUMBER
	HRRM A,BREAK2		;SAVE BREAK POINT #
	MOVEI T,"$"
	PUSHJ P,TOUT
	PUSHJ P,FP7		;PRINT BREAKPOINT NUMBER
	MOVSI W1,(ASCII /B>/)
	PUSHJ P,TEXT2		;PRINT $NB>
	SKIPG @BCOM2		;TEST PROCEED COUNTER
	PUSHJ P,TOUT		;T STILL HAS > IN IT FROM TEXT2
	MOVE T,BCOM
	HLLM T, SAVPI		;SAVE PROCESSOR FLAGS
	MOVEI T,-1(T)
	PUSHJ P,PAD		;TYPE PC AT BREAK
	HRRZ T,@BCOM3
	HRRM T,PROC0		;SETUP ADDRESS OF BREAK
	HLRZ T,@BCOM3
	JUMPE T,BREAK1		;TEST FOR REGISTER TO EXAMINE
	PUSHJ P,LCT		;PRINT TAB
	HLRZ T,@BCOM3
IFN FLDDT!XMOD,<HRRZS USRSAV>
	PUSHJ P,LI1		;EXAMINE REGISTER C($NB)LEFT
BREAK1:	MOVSI S,400000
BREAK2:	ROT S,.-.		;ROT BY # OF BREAK POINT
	PUSHJ P,LISTEN		;DONT PROCEED IF TTY KEY HIT
	TDNN S,AUTOPI		;DONT PROCEED IF NOT AUTOMATIC
	JRST RETB		;DONT PROCEED
	MOVEI T,2	;TO COMPENSATE FOR SOS
	ADDB T,@BCOM2	;KEEP COUNT
	JUMPL T,PROCD1	;GO
	ANDCAM S,AUTOPI	;TURN OFF AUTO PROCEED
	JRST RETB

PROCEDE: TLNE F,QF		;N$P	;PROCEED AT A BREAKPOINT
	JRST PROC3
	MOVEI T,1
	TLNE F,CCF	;IS IT $$
	MOVSI T,200000
PROC3:	TLNE F,CCF	;IF $$ THEN NEGATE
	MOVNS T
	MOVEM T,@BCOM2
	HRRZ R,BCOM3
	PUSHJ P,AUTOP
PROCD1:	PUSHJ P,CRF
IFN HI,<PUSHJ P,CHKSEG>
PROC0:	HRRZI R,XEC1		;MODIFIED TO ADDR OF BREAKPOINT
	PUSHJ P,FETCH
	JRST BPLUP1		;ONLY GET HERE IF MEMORY SHRANK
	MOVEM T,LEAV
	PUSHJ P,INSRTB
	JRST PROC2

PROC1:	MOVE T,AC0+T
	JSR SAVE
	JFCL
PROC2:	MOVEI W,100
	MOVEM W,TEM1		;SETUP MAX LOOP COUNT
	JRST IXCT5
IXCT4:	IFN XMOD,<SKPUSR
	JRST IXCT41>
	SUBI T,041
	JUMPE T,IINIT
	AOJGE T,IXCT6				;DONT PROCEDE FOR INIT
				;DONT INTERPRET FOR SYSTEM UUOS
IXCT41:	MOVEM R,40		;INTERPRET FOR NON-SYSTEM UUOS
	MOVEI R,41
IXCT:	SOSL TEM1
	PUSHJ P,FETCH
	JRST BPLUP		;BREAKPOINT LOOPING OR FETCH FAILED
	MOVEM T,LEAV
IXCT5:	IFN XMOD,<
	SKPUSR
	JRST IXCT51
	LDB T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIN T,254		;DON'T DO ANYTHING TO JRST IN EXEC MODE
	JRST IXCT6>
IXCT51:	HRLZI 17,AC0
	BLT 17,17
	SKIPN	KSFLAG		;SKIP IF KS
	 JRST	IXCT52		;GO EVALUATE EA
	HLRZ	T,LEAV		;GET THE OP CODE
	CAIL	T,710000	;SKIP IF NOT EXTERNAL IO INS.
	JRST	IXCT53		;FOR EXTERNAL IO BY PASS EA EVALUATION
IXCT52:	MOVEI T,@LEAV
	DPB T,[POINT 23,LEAV,35]	;STORE EFFECTIVE ADDRESS
IXCT53:	LDB W1,[POINT 4,LEAV,12]	;PICK UP AC FIELD
	LDB T,[POINT 9,LEAV,8]		;PICK UP INSTRUCTION FIELD
	MOVEI P,PS
	CAIN T,260
	JRST  IPUSHJ		;INTERPRET PUSHJ

	CAIN T,264
	JRST IJSR		;INTERPRET JSR
	CAIN T,265
	JRST IJSP		;INTERPRET JSP
	CAIN T,266
	JRST IJSA		;INTERPRET JSA
	MOVE R,LEAV
	TRNN T,700
	JRST IXCT4		;INTERPRET UUO
	CAIE T,256
	JRST IXCT6		;INTERPRET XCT
	JUMPE W1,IXCT	;DONT INTERP EXC XCT

IXCT6:	JSP T,RESTORE
LEAV:	0			;INSTRUCTION MODIFIED
	JRST @BCOM
	AOS BCOM
	JRST @BCOM

BPLUP:	PUSHJ P,REMOVB		;BREAKPOINT PROCEED ERROR
BPLUP1:	JSR SAVE
	JFCL
	JRST ERR
IINIT:	MOVE T,LEAV
	MOVEM T,INITL
	MOVEI R,@BCOM	;SET UP TO EXECUTE THE INIT
	PUSHJ P,FETCH
	JRST BPLUP
	MOVEM T,INITL+1
	ADDI R,1
	PUSHJ P,FETCH
	JRST BPLUP
	MOVEM T,INITL+2
	MOVEI T,2
	ADDM T,BCOM	;ADDJUST THE PC
INITL:	0
	0
	0
	SKIPA
	AOS BCOM	;SUCCESS BUMP PC
	MOVEI T,@BCOM
	JRST RESTORE	;TREAT AS JSR
IPUSHJ:	SETZM TEM3		;TELL RESTORE THIS IS A PUSHJ
	MOVE T,[PUSH TEM2]	;WHERE THE SUBR ADDRESS WILL BE
	DPB W1,[POINT 4,T,12]	;STORE USERS POINTER AC 
	EXCH T,LEAV		;MAKE THIS THE INST TO EXECUTE,
				; GET THE PUSHJ P,EA
	EXCH T,BCOM		;BCOM GETS EA OF PUSHJ, PICKUP
				; PC TO PUSH ON STACK IN T, WHICH
				; WILL BE SAVED IN TEM2
	JRST RESTR1		;AND RETURN TO USER.

IJSA:	MOVE T,BCOM		;INTERPRET JSA
	HRL T,LEAV
	EXCH T,AC0(W1)
	JRST IJSR2

IJSR:	MOVE T,BCOM		;INTERPRET JSR
	HLL T,SAVPI
IJSR2:	MOVE R,LEAV
	PUSHJ P,DEP
	 JRST BPLUP		;ERROR, CAN'T STORE
	AOS LEAV		;MAKE LEAV POINT TO SUBROUTINE NOW.
IJSR3:
IFN XMOD,<MOVSI T,(JFCL)	;BPZOT INSTRUCTION SHOULD BE JFCL
	EXCH T,LEAV		;PUT IT INTO LEAV, GET SUBR LOCATION
	HRRM T,BCOM		;PUT EA+1 INTO BPZOTS JRST
	JRST RESTORE>		;DISMISS.
IFE XMOD,<MOVE T,LEAV		;JUST GET PLACE TO DISMISS TO IN T
	JRST RESTORE>		;AND GO THERE.

IJSP:	MOVE W,BCOM		;INTERPRET JSP
	HLL W,SAVPI
	MOVEM W,AC0(W1)
	JRST IJSR3		;DO IT LIKE JSR, ONLY DON'T INCREMENT.

;INSERT BREAKPOINTS

INSRTB:	MOVE S,[JSR BP1]
INSRT1:	SKIPN R,B1ADR-BP1(S)
	JRST INSRT3	;BP NOT SET
IFN HI,<HRRZ T,SEGTAB
	TRNE R,400000	;ALWAYS DO LOSEG BP
	CAMN T,3(S)	;DO HISEG BP ONLY IF RIGHT SEG IN CORE
>
INSRT2:	PUSHJ P,FETCH
	JRST INSRT3
	MOVEM T,B1INS-BP1(S)
	MOVE T,S
	PUSHJ P,DEPB
	 JFCL			;HERE ONLY IF CAN'T WRITE IN HIGH SEG
INSRT3:	ADDI S,4
	CAMG S,[JSR BPN]
	JRST INSRT1
	POPJ P,

;REMOVE BREAKPOINTS

REMOVB:	MOVEI S,BNADR
REMOV1:	MOVE T,B1INS-B1ADR(S)
	SKIPN R,(S)
	JRST REMOV2	;BP NOT SET
IFN HI,<HRRZ TT,SEGTAB
	TRNE R,400000	;CHECK IF IN HISEG (LOSEG ALWAYS OK)
	CAMN TT,BP1-B1ADR+3(S)	;CHECK HISEG BP FOR RIGHT SEGMENT
>
	PUSHJ P,DEPB
	 JFCL			;HERE IF SKIPPING IT OR NO WRITE ALLOWED
REMOV2:	SUBI S,4
	CAIL S,B1ADR
	JRST REMOV1
	POPJ P,
;ALL $B COMMANDS GET HERE IN FORM: <A>$<N>B

BPS:	TLZE F,QF		;HAS <A> BEEN TYPED?
	JRST BPS1		;YES
	TRZE F,Q2F		;NO, HAS <N> BEEN TYPED?
	JRST BPS2		;YES
	MOVE T,[XWD B1ADR,B1ADR+1]	;NO, COMMAND IS $B - CLEAR ALL BREAKPOINTS
	CLEARM B1ADR
	BLT T,AUTOPI		;CLEAR OUT ALL BREAKPOINTS AND AUTO PROCEDE REGESTER
	JRST RET

BPS1:	TRZN F,Q2F		;HAS <N> BEEN TYPED?
	JRST BPS3		;NO
	MOVE R,T		;YES, PROCESS THE COMMAND A$NB
	TRO F,2
BPS2:	MOVE T,WRD2
	CAIL T,1
	CAILE T,NBP
	JRST ERR
	IMULI T,4
	ADDI T,B1ADR-4
	TRZN F,2
	JRST MASK2
	EXCH R,T
	JRST BPS5

BPS3:	MOVEI R,B1ADR		;PROCESS THE COMMAND A$B
BPS4:	HRRZ W,(R)
	CAIE W,(T)
	SKIPN (R)
	JRST BPS5
	ADDI R,4
	CAIG R,BNADR
	JRST BPS4
	JRST ERR
BPS5:	MOVEM T,(R)
	CLEARM,1(R)
	CLEARM,2(R)
	SETZM 3(R)
IFN HI,<
	TRNN T,400000	;IS BP IN HISEG?
	JRST BPS6
	SKIPN S,SEGPTR	;YES, GET HISEG PTR
	MOVE S,SEGTAB	;(WHICHEVER ONE IS VALID)
	HRRZM S,BP1-B1ADR+3(R)	;REMEMBER IT
BPS6:>

AUTOP:	SUBI R,B1ADR		;AUTO PROCEDE SETUP SUBROUTINE
	IDIVI R,4
	MOVEI S,1
	LSH S,(R)
	ANDCAM S,AUTOPI
	TLNE F,CCF
	IORM S,AUTOPI
	POPJ P,
;FETCH AND DEPOSIT INTO MEMORY

DEPRS:	MOVEM T,LWT		;DEPOSIT REGISTER AND SAVE AS LWT
	MOVE R,LLOCO		;QUAN TYPED IN REGIS EXAM
	TLZE F,ROF
	TLNN F,QF
	POPJ P,0
;;	CAIL R,DDT
;;	CAILE R,DDTEND-1
	PUSHJ P,DEPU		;STORE AWAY
	 JRST ERR		;CAN'T STORE (IN DDT OR OUT OF BOUNDS)
	POPJ P,			;RETURN

;DEPOSIT INTO MEMORY SUBROUTINE

IFE FRMDDT,<
DEPB:
IFN HI,<SETOM DEPBFL#	;ENTRY TO NOT BOTHER UPDATING .HGH FILE
	JRST .+2>
DEP:
IFN HI,<
	SETZM DEPBFL
>
IFN XMOD!FLDDT,<
	TDZA TT1,TT1
DEPU:	MOVE TT1,USRNOW
	MOVEM TT1,FDPUSR
>
IFE XMOD!FLDDT,<
DEPU: >
IFN FLDDT,<
	SKIPN CODMOD
	JRST FLDDDP
>
	JSP TT1,CHKADR		;LEGAL ADDRESS?
	JRST DEP4		;YES BUT IN HI SEGMENT
IFN XMOD,<
	SKIPGE FDPUSR
	JRST USRXDP	;DO A USER DEPOSIT
USRNDC: >
>;END IFE FRMDDT
IFN FRMDDT,<
DEP:
DEPB:
DEPU:
	SKIPN	WENB		;MAKE SURE HE HAS WRITE ENABLED
	POPJ	P,		;HE HASN'T, GIVE ERROR.
	MOVE	TT2,FRAME		;GET FRAME DESCRIPTOR
	JUMPE	TT2,DEPUS		;IF ZERO, ITS US.
	TLC	TT2,700000
	TLCN	TT2,700000
	JRST	DEPUS		;IF SELF DESCRIPTOR, GO TO DEPUS
	EXCH	T,TT2		;GET FRAME IN T, DATA IN TT2
	HRLI	T,.FOWVA
	HRRZ	TT1,R		;GET ADDRESS IN TT1
	FRMOP	T,TT1		;DEPOSIT
	  POPJ	P,		;ERROR
	JRST	CPOPJ1		;OK, RETURN.
DEPUS:>;END IFN FRMDDT
	TRNN R,777760
	JRST DEPAC		;DEPOSIT IN AC

	MOVEM T,(R) 
	JRST CPOPJ1		;SKIP RETURN

DEPAC:	MOVEM T,AC0(R)		;DEPOSIT IN AC
	JRST CPOPJ1		;SKIP RETURN
DEP4:	
IFN XMOD,<
	SKPUSR
	POPJ P,
>
IFN HI,<	;MARK BIT MAP SO THIS BLOCK OF .HGH FILE WILL BE UPDATED
	SKIPE DEPBFL
	JRST DEP5	;SKIP ALL THIS IF NOT MARKING HISEG
	PUSHJ P,SEGOPN	;OPEN HISEG FILE (.HGH) IF NOT ALREADY
	  POPJ P,	;ERROR, FORGET IT
	MOVEI TT,-400000(R)
	LSH TT,-7	;GET HISEG BLOCK #
	IDIVI TT,^D36	;TT=MAP WORD #, TT1=BIT #
	MOVNS TT1
	MOVEI W,1
	LSH W,^D35(TT1)	;W=BIT TO TURN ON
	IORM W,HIMAP(TT)	;MARK MAP BIT FOR THIS BLOCK
DEP5:>
	MOVEI W,0
	SETUWP W,		;IS HI SEGMENT PROTECTED? TURN OFF
	 POPJ P,		;PROTECTED, NO SKIP RETURN
	MOVEM T,(R)		;STORE WORD IN HI SEGMENT
	TRNE W,1		;WAS WRITE PROTECT ON?
	SETUWP W,		;YES, TURN IT BACK ON
	 JFCL
	JRST CPOPJ1		;SKIP RETURN

IFN FLDDT,<
FLDDDP:	SKIPL 	FDPUSR
	 SKIPE 	JSTFIL
	  POPJ 	P,		;IF JUST LOOKING AT PLAIN FILE, NO GOOD
	TRNN 	R,777760
	 JRST 	DEPAC		;ALLOW STORE IN ACS
	SKIPN 	CRASHS
	 SKIPN 	WENB
	  POPJ 	P,		;IF A FILE OR NO WRITE ENB, FORGET IT
	MOVEM 	T,POKSTR	;save data for poke
	SKIPN	MAPWRD		;is pageing on?
	 JRST	FLDDP1		;no, unmapped
	SETO	T,
	CAMN	T,MAPWRD	;-1 is flag for virtual peek/poke
	 JRST	FLDDP0
	PUSHJ	P,MAPEXC	;do fake mapping
	 POPJ	P,
	JRST	FLDDP1
FLDDP0:	MOVE	T,R
	TLO	T,(1B0)		;do real mapping (virtual poke)
	MOVEM	T,POKLOC
	JRST	FLDDP2
FLDDP1:	HRRZM 	R,POKLOC
FLDDP2:	MOVEI 	W,POKSTR
	POKE 	W,
	 POPJ 	P,		;ERROR RETURN
	JRST 	CPOPJ1

POKSTR:	0
POKLOC:	0
>
IFN XMOD,<
USRXDP:	SKPEXC
	JRST USRNDC
	SKIPE	KLMAPF
	JRST	[XCT	X.MEM,[MOVEM T,(R)]
		JRST	CPOPJ1]
	XCT XTU,[MOVEM T,(R)]
	JRST CPOPJ1
>

SUBTTL FETCH FROM MEMORY SUBROUTINE

IFE FRMDDT,<
FETCH:	IFN FLDDT!XMOD,<TDZA TT1,TT1
FETCHU:	MOVE TT1,USRNOW
	MOVEM TT1,FDPUSR>
IFE FLDDT!XMOD,<FETCHU:>
IFN FLDDT,<SKIPN CODMOD
	JRST FLDDFT	;FETCH FROM FILE>
>;END IFE FRMDDT
IFN FRMDDT,<
FETCH:
FETCHU:	MOVE	T,FRAME		;GET INVOLVED FRAME
	JUMPE	T,FETCUS	;IF ZERO, JUST OUR OWN IMAGE
	MOVE	TT2,T		;GET COPY
	TLC	TT2,700000
	TLCN	TT2,700000
	JRST	FETCUS		;IF TYP 7, IS OWN FRAME
	HRLI	T,.FORVA
	HRRZ	TT1,R		;
	FRMOP	T,TT1		;GET DATA IN TT2
	  POPJ	P,		;COULD NOT GET IT
	MOVE	T,TT2		;GET DATA IN T
	JRST	CPOPJ1
FETCUS:>;END IFN FRMDDT
	JSP TT1,CHKADR
	 JFCL
IFN XMOD,<SKIPGE FDPUSR
	JRST USRXFT
USRNXC:>
	TRNN R,777760
FLDACS:	SKIPA T,AC0(R)	;LOAD FROM ACS
	MOVE T,(R)
	JRST CPOPJ1

IFN XMOD,<
USRXFT:	SKPEXC
	JRST USRNXC	;NOT REALLY IN EXEC MODE
	SKIPE	KLMAPF
	JRST	[XCT	X.MEM,[MOVE T,(R)]
		JRST	CPOPJ1]
	XCT XFU,[MOVE T,(R)]
	JRST CPOPJ1>

IFN FLDDT,<
FLDDFT:	SKIPE JSTFIL
	JRST FCHFIL	;JUST FETCH FROM FILE
	SKIPN CRASHS
	JRST	[TRNE R,777760
		JRST MONPEK	;NOT AC'S GO PEEK AT MON
		JRST FLDACS]	;LOAD FROM ACS
	SKIPGE FDPUSR
	JRST FLDUS	;TRY TO LOAD FROM USER AREA
FLDNUS:	TRNN R,777760	;NOT USER
	JRST FLDACS
	SKIPN MAPWRD	;IS A MAP SET
	JRST FCHFIL	;NO, JUST FETCH
	PUSHJ P,MAPEXC	;MAP THE EXEC REF
	 JRST RPOPJ	;ERROR
	JRST FCHFL1

FLDUS:	MOVSI TT,PC.UIO
	SKIPE MAPWRD
	TDNN TT,SAVPI	;IS USER-IO SET AND MAP SET
	JRST FLDNU1	;NO, NOT REALLY A USER REF
	TRNN R,777760
	JRST FLDUAC	;LOAD USER ACS
FLDUMP:	PUSHJ P,MAPUSR
	 JRST RPOPJ
	JRST FCHFL1
FLDUAC:	LDB T,[POINT 2,MAPWRD,2]	;GET USER AC BLOCK
	JUMPE T,FLDUMP		;JUST DO THE USER MAP (SHADOW)
	IMULI T,20
	ADD T,ACSPTR
	MOVEM R,TEM4
	ADD R,T
	JRST FCHFL0

MAPUS1:	HRRZ R,T	;CALLED FROM =
MAPUSR:	TDZA T,T
MAPEXC:	MOVEI T,400-160
	MOVEM R,TEM4
	HRRZS TT,R	;GET THE PAGE
	LSH TT,-9
	CAIGE TT,340
	JUMPN T,[HRRZ T,R	;UNMAPPED EXEC LOAD T IN CASE $3=
		JRST CPOPJ1]
	ROT TT,-1
	ADD T,TT	;GET CORRECT INDEX INTO TABLE
	TLNE T,400000
	SKIPA T,MAP(T)
	MOVS T,MAP(T)
	TRNN T,PGE.A	;IS ACCESS ALLOWED?
	POPJ P,		;NO
	ANDI T,17777
	LSH T,9
	HRRZ R,TEM4
	ANDI R,777
	ADDB R,T	;BOTH FOR =
	JRST CPOPJ1	;NOW HAVE REAL ADDRESS

FLDNU1:	TRNE R,777760
	JRST FLDNUS	;NOT ACS
	HLRZ T,MAPWRD	;GET UPT
	LSH T,9
	HLRZ TT,ACXSPT	;GET THE AC STACK POINTER
	LSH TT,-9
	ANDI TT,760
	ADD T,TT
	MOVEM R,TEM4
	ADD R,T
	JRST FCHFL0>
IFN FLDDT!FRMDDT,<
FCHFIL:	MOVEM R,TEM4		;SAVE THE AOBJN POINTER
FCHFL0:	HRRZ R,R		;STRIP OFF POSSIBLE COUNT
FCHFL1:	CAML R,FILSIZ	;IS IT IN RANGE
	JRST CHKHI	;SEE IF IN HI SEG
	SKIPE XPNFLG	;IS IT COMPRESSED?
	JRST FTCXPN	;YES, UNCOMPRESS
	IDIVI R,4000		;R HAD LOCATION
	TRNN S,777000		;S=R+1
	JUMPE R,RSDNT		;LOC IS IN RESIDENT BLOCK
	CAMN R,RSAVE		;IS LOC INCORE ?
	JRST INCORE		;S=LOC
	MOVEM R,RSAVE		;INPT NO.
	IMULI R,20		;16/INPT
	USETI 1,1(R)		;BLK 0 DOES NOT EXIST
	INPUT 1,CURLST		;GET 16 BLKS
	STATZ 1,740000
	HALT .-2		;YEP
INCORE:	SKIPA T,CURENT(S)
RSDNT:	MOVE T,RSIDNT(S)
	JRST RPOPJ1		;RESTORE R AND RETURN
TEM4:	0			;HOLD AOBJN POINTER
MONPEK:	IFN FLDDT,<
	SETO	T,
	CAMN	T,MAPWRD
	 JRST	MONPK0
	SKIPN	MAPWRD		;PAGING IN EFFECT?
	 JRST	MONPK1		;NO
	PUSHJ	P,MAPEXC	;YES, GET EXEC LOCATION
	 POPJ	P,		;BAD REF
>;END IFN FLDDT
MONPK0:	HRRZ	T,R
	TLOA	T,(1B0)
MONPK1:	 HRRZ 	T,R		;REMOVE COUNT
	NPEEK 	T,		;DO NEW PEEK UUO
	 POPJ	P,		;BAD NEWS
	JRST 	CPOPJ1		;RETURN VALUE IN AC T

CHKHI:	TRZE R,400000
	CAML R,HISIZ
	JRST RPOPJ
	IDIVI R,2000
	CAMN R,HRSAVE
	JRST HIINC	;ALMOST LIKE ABOVE
	IMULI R,10
	USETI HCRS,1(R)
	INPUT HCRS,HICOM
	STATZ HCRS,740000
	HALT .-3
HIINC:	MOVE T,HIBLK(S)
RPOPJ1:	AOS (P)
RPOPJ:	MOVE R,TEM4
	POPJ P,
FTCXPN:	PUSH P,R
	SETZB	TT,TT1	;START WITH XPNTAB+0, HAS ZERO IN IT.
	JRST	FTCBK3	;LET FIRST ZERO IN TABLE GO THRU.
FTCBK2:	SKIPG	TT1,XPNTAB(TT)	;GET DATA
	JRST	FTCBK4		;END OF TABLE,MUST BE LAST ONE.
FTCBK3:	CAIL	R,(TT1)		;WAIT TILL WE SEE ONE PAST WHAT WE WANT.
	AOJA	TT,FTCBK2	;NOT YET.
FTCBK4:	SUBI	TT,1		;LAST BUFFER IS WHAT WE WANT.
	MOVE	TT1,XPNTAB(TT)	;GET XPNCNT,,XPNFLR FOR BUFFER
	HRRZM	TT1,XPNFLR
	HLRZM	TT1,XPNCNT	;SAVE
	IMULI	TT,5*4		;GET BLOCK NUMBER RELATIVE TO 0
	MOVEI	R,1(TT)		;BLOCK NUMBER
	CAMN	R,RSAVE		;BLOCK ALREADY HERE?
	JRST	FTCLC1		;YES, JUST SETUP R AND RETURN.
	MOVEM	R,RSAVE		;THIS IS NEXT BLOCK.
FTCLCM:	USETI CRS,@RSAVE
	INPUT CRS,XPNCOM
FTCLC1:	HRRZ R,(P)

FTCXLP:	MOVEI TT,RSIDNT
	MOVE TT1,XPNCNT	;TT1 HAS COUNT OF WORDS PAST LAST IOWD OR BEG
			; OF BUFFER IF STARTING (THIS INSTRUCTION).
	SUB R,XPNFLR	;R ALWAYS HAS # WORDS PAST CURRENT IOWD DESIRED DATA IS AT
FTCLOK:	CAML R,TT1	;IN THIS LINK?
	JRST FTCLNK	;NO, TRY NEXT
	ADD TT,R	;POSITION
	CAILE TT,RSIDNT+4777
	HALT	.	;WE SHOULD HAVE FOUND A LATER BUFFER.
	MOVE T,(TT)
	POP P,R
	JRST RPOPJ1

FTCLNK:	ADD TT1,TT	;POSITION OF NEXT LINK
	CAILE TT1,RSIDNT+4777	;TOO FAR
	JRST FTCZRO	;XPNTAB SAID NEXT BUFFER TOO BIG, MUST NOT BE
			; COVERED IN ANY IOWD.
	MOVE TT,TT1
	HRRZ TT1,(TT)
	HRRZ R,(P)
	SUBI R,1(TT1)	;SEE IF TOO FAR
	JUMPL R,FTCZRO	;HIT IOWD WITH BIGGER ADDRESS, MUST BE ZERO.
	HLRE TT1,(TT)
	MOVNS TT1
	AOJA TT,FTCLOK	;GO LOOK SOME MORE

FTCZRO:	MOVEI T,0	;RETURN ZERO WORD
	POP P,R
	JRST RPOPJ1
>
CHKADR:	IFN XMOD,<SKPUSR
	JRST XMDCHK>
	HRRZ	TT,R		;ADDR INTO TT
	LSH	TT,-11		;CONVERT TO PAGE #
	VPGSTS	TT,		;READ PAGE STATUS WORD
	JRST	CHKOLD		;NOSKIP - ASSUME UUO NOT IMPLEMENTED
	TRNN	TT,7		;PAGE EXISTS IF PROT NEQ 0
	POPJ	P,		;ELSE FAIL RETURN
	TRNE	R,400000	;IN HIGH SEG?
	JRST	(TT1)		;YES
	JRST	1(TT1)

CHKOLD:	HRRZ TT,JOBREL
	CAIL TT,(R)	;IS IT IN LOW SEG?
	JRST 1(TT1)	;YES
	HRRZ TT,JOBHRL
	TRNE R,400000
	CAIGE TT,(R)
	POPJ P,		;NOT IN HIGH SEG EITHER
	JRST (TT1)	;IN HIGH SEG

IFN XMOD,<
XMDCHK:	SKIPE	KSFLAG		;SKIP IF NOT A KS
	 JRST	[WRAPR	@RSTNXM	;RESET NXM FLAG
		JRST .+2]		;SKIP NEXT INS
	CONO APR,@RSTNXM	;RESET NXM FLAG. LEAVE CLOCK ON
	SKIPE	KLMAPF		;KL?
	 JRST	XMDLCK		;YES, GO DO KL STUFF.
	SKIPE FDPUSR
	JRST XMDUSC
	MAP TT,(R)
	TRNE TT,MAP.FL
	TRNN TT,MAP.M
	SKIPA
	POPJ P,		;FAILURE
	TRNN TT,MAP.M
	TRNE TT,MAP.W
	ADDI TT1,1
	MOVE TT,(R)
XMDCOM:	CONSO APR,NXM
	JRST (TT1)
	POPJ P,

XMDUSC:	XCT XTU,[MAP TT,(R)]
XMUSC1:	TRNE TT,MAP.FL
	TRNN TT,MAP.M
	SKIPA
	POPJ P,
	TRNN TT,MAP.M
	TRNE TT,MAP.W
	ADDI TT1,1	;UNMAPPED OR WRITEABLE
	XCT XFU,[MOVE TT,(R)]	;IN CASE OF NXM
	JRST XMDCOM

XMDLCK:SKIPE	FDPUSR		;USER MODE REF?
	JRST	[XCT X.MEM,.+1
		 JRST .+2]
	MAP	TT,(R)
	TLNN	TT,PFW.R	;UNPAGED?
	AOJA	TT1,XMDLC1	;YES, ALLOW WRITE UNLESS ITS NXM
	TLNN	TT,PFW.H	;HARD ERROR OR
	TLNN	TT,PFW.A	;ACCESS BIT OFF?
	POPJ	P,		;YES, GIVE UP
	TLNE	TT,PFW.W	;WRITE BIT ON?
	AOS	TT1		;YES, CAN WRITE THEN.
XMDLC1:	SKIPE	FDPUSR
	JRST	[XCT X.MEM,.+1
		 JRST .+2]
	SKIP	(R)		;MAKE SURE ITS NOT NXM
	SKIPE	KSFLAG		;SKIP IF NOT A KS
	 JRST	[CONSO	APR,SP.NXM	;SEE IF NXM
		JRST	(TT1)	;CAN REF IT, GIVE PROPER RETURN
		POPJ	P,]	;DOESN'T EXIST, ABORT OPERATION
	SKIPN	F3FLAG		;IF F3, NO NXM FLAG EXISTS.
	CONSO	APR,LP.NXM
	JRST	(TT1)		;CAN REF IT, GIVE PROPER RETURN.
	POPJ	P,		;DOESN'T EXIST, ABORT OPERATION.
>;END IFN XMOD
SUBTTL SYMBOL TABLE HACKING
FIRARG:	MOVEM T,DEFV
	TLO F,FAF
	JRST ULIM1
ULIM:	TLO F,SAF
	HRRZM T,ULIMIT
ULIM1:	TLNN F,QF
	JRST ERR
	JRST LIS0

IFE FAILSW,<
LOOK:	SKIPL R,PRGM	;LOOK UP SYMBOL
	MOVE R,@SYMP
	HLRE S,@SYMP
	ASH S,-1	;SETUP COUNT FOR LENGTH OF SYM TABLE
	TLZ F,400000
	HRLZI W2,DELO
	MOVEM T,TEM

LOOK1:	TDNE W2,(R)
	JRST LOOK3
	MOVE T,(R)
	MOVE W,1(R)
	TRNE T,200000
	HRRZ W,(W)
	MOVEM W,SYMTM
	TLNN T,PNAME	;NAME
	TLOA W2,LOCAL
	SKIPA T,TEM
	JRST LOOK3
	XOR W,T
	JUMPL W,LOOK3
	SUB T,SYMTM
	JUMPL T,LOOK3
	JUMPGE F,LOOK2
	MOVE W,SYMTM
	SUB W,SYMTM1
	JUMPLE W,LOOK3
LOOK2:	HRR W1,R		;POINTER BEST VALUE SO FAR
	MOVE W,SYMTM
	MOVEM W,SYMTM1	;BEST SO FAR
	TLO F,400000
	JUMPE T,SPT0
LOOK3:	ADD R,[XWD 2,2]
	SKIPL R
	MOVE R, @SYMP
	AOJLE S,LOOK1	;TERMINATING CONDITION
	MOVE T,TEM
	TLNE F,400000
	SUB T,SYMTM1
	JRST CPOPJ1
>
IFN FAILSW,<
LOOK:	SETZM SVFB
	SETZM SVTB
	SETZM BLVL
	TLZ F,600000
	MOVEM F,SVF
	HRLZI W2,DELO
	MOVEM T,TEM
	SKIPL R,PRGM
	JRST TOPDWD
LOOKA:	MOVEM R,FRSTR
LOOK1:	SUB R,[XWD 2,2]
	SKIPN T,(R)
	JRST LOOK1
	CAMN T,[-1]
	JRST	[SKIPE R,1(R)	;LINK, GET NEXT TABLE
		JRST LOOK3	;JUMP IF A GOOD PTR
		JRST TOPDWN]	;NOT SO GOOD
	TDNE W2,(R)
	JRST LOOK3
	LDB T,[POINT 4,(R),3]
	CAIN T,3
	JRST BLNME
	JUMPE T,PNAM
	MOVE W,1(R)
	TRNE T,4	;ARRAY TYPE
	HRRZ W,(W)	;GET INFO FROM TABLE
	MOVEM W,SYMTM
	MOVE T,TEM	;GET DESIRED VALUE
	XOR W,T
	JUMPL W,LOOK3
	SUB T,SYMTM
	JUMPL T,LOOK3
	JUMPGE F,LOOK2
	MOVE W,SYMTM
	SUB W,SYMTM1
	JUMPLE W,LOOK3
LOOK2:	HRR W1,R
	MOVE W,SYMTM
	MOVEM W,SYMTM1
	TLO F,400000
	TLNE F,200000
	JRST LOOK2A
	MOVE W,SVTB
	MOVEM W,SVFB
LOOK2A:	TLNE W2,LOCAL
	SETZM SVFB
	JUMPE T,LOOK4
LOOK3:	CAMN R,@SYMP
	JRST TOPDWN
LOOK3A:	CAME R,FRSTR
	JRST LOOK1
	MOVE T,TEM
	TLNE F,400000
	SUB T,SYMTM1
	JUMPE T,SPT0
	JRST CPOPJ1

TOPDWD:	MOVEI T,LOOKA
	TLOA W2,LOCAL
TOPDWN:	MOVEI T,LOOK3A
	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	HRRZ R,R
	JUMPE R,CPOPJ	;NO SYMBOLS
	JRST (T)

BLNME:	MOVEM R,SVTB
	MOVE T,1(R)
	CAMN R,BLOCK
	JRST BLNM1
	CAML T,BLVL
	JRST BLNM2
BLNM1:	MOVEM T,BLVL
	TLNE F,200000
	JRST LOOK3
	PUSHJ P,XCH
	TLO F,200000
	JRST LOOK3

BLNM2:	TLNN F,200000
	JRST LOOK3
PNAM1:	PUSHJ P,XCH
	JRST LOOK3

PNAM:	TLO W2,LOCAL
	TLNN F,200000
	JRST LOOK3
	JUMPGE F,LOOK5
	PUSHJ P,XCH
	JUMPGE F,PNAM2
	MOVE T,SYMTM2
	CAMGE T,SYMTM1
	JRST LOOK5A
PNAM2:	PUSHJ P,XCH
	SETZM SVFB
	TLO F,400000
	TLZ F,200000
	JRST LOOK3

LOOK4:	TLZN F,200000
	JRST LOOK3
	SETZM SVFB
	JRST SPT0

LOOK5:	PUSHJ P,XCH
LOOK5A:	MOVE T,SYMTM1
	CAMN T,TEM
	JRST SPT0
	JRST LOOK3

XCH:	EXCH F,SVF
	EXCH W1,SW1
	EXCH W1,SYMTM1
	EXCH W1,SYMTM2
	EXCH W1,SYMTM1
	POPJ P,
>
CONSYM:	MOVEM T,LWT
	TRNN F,LF1
	JRST @SCH		;PIN OR FTOC
	TRNE F,CF1
	JRST  FTOC

LFPIN:	JFCL	;MUST BE DIFFERENT THAN PIN
RFPIN:	JFCL	;AND FROM THIS
PIN:				;PRINT INSTRUCTION
	TLC T,700000
	TLCN T,700000
	JRST INOUT		;IN-OUT INSTRUCTION OR NEG NUM
	AND T,[XWD 777000,0]	;EXTRACT OPCODE BITS
	JUMPE T,HLFW		;TYPE AS HALF WORDS
	PUSHJ P,OPTYPE
	MOVSI	T,777000
	AND 	T,LWT
	TRNN F,ITF		;HAS INSTRUCTION BEEN TYPED?
	PUSHJ P,LOOK		;NO, LOOK IN SYMBOL TABLE
KSIO2:	TROA F,NAF		;INSTRUCTION TYPED, ALLOW NEG ADDRESSES
	JRST HLFW		;NOT FOUND, OUTPUT AS HALFWORDS
	PUSHJ P,TSPC
	TRZE F,TTCLF
	JRST PI4		;IF TTCALL, NO AC
	LDB T,[XWD 270400,LWT]	;GET AC FIELD
	PUSHJ P,PAC
	JUMPE T,PI4	;IF NUMBER WAS 0 AND NO AC REF, NO COMMA
PI3A:	MOVEI W1,","
	PUSHJ P,TEXT
PI4:	TRZE F,CLLIF
	POPJ P,			;IF CALLI, NO ADR
PI4A:	MOVE W1,LWT
	MOVEI T,"@"
	TLNE W1,20		;CHECK FOR INDIRECT BIT
	PUSHJ P,TOUT
	HRRZ T,LWT
	LDB W,[XWD 331100,LWT]	;INSTRUCTION BITS
	CAIL W,240
	CAILE W,247
	JRST PI8		;ALL (EXCEPT ASH,ROT,LSH) HAVE SYMBOLIC ADRS
	TLNN W1,20
	CAIN W,<JFFO>_-33
	JRST PI8		;JFFO AND @ GET SYMBOLIC ADDRESSES
	PUSHJ P,PADS3A	;ONLY ABSOLUTE ADDRESSING FOR LSH, ASH, AND ROT
PI7:	TRZ F,NAF	
	LDB R,[XWD 220400,LWT]	;INDEX REGISTER CHECK
	JUMPE R,PADS1		;EXIT
	MOVEI T,"("
	PUSHJ P,TOUT
	MOVE T,R
	PUSHJ P,PAC
	JFCL	;NEVER GETS A ZERO
	MOVEI T,")"
	JRST TOUT		;EXIT

PI8:	CAIN SCH,LFPIN
	JRST LFFLG
	CAIN SCH,RFPIN
	JRST RFFLG
PI8A:	PUSHJ P,PAD
	JRST PI7
HLFW:	REPEAT 0,<	MOVE T,LWT
	CAML T,[DDTINT SAVPI]
	CAMLE T,[DDTINT BNADR+2]
	SKIPA
	JRST PAD>
	HLRZ T,LWT		;PRINT AS HALF WORDS
	JUMPE T,HLFW1		;TYPE ONLY RIGHT ADR IF LEFT ADR=0
	TRO F,NAF		;ALLOW NEGATIVE ADDRESSES
	PUSHJ P,PAD
	MOVSI W1,(ASCII /,,/)
	PUSHJ P,TEXT2		;TYPE ,,
HLFW1:	HRRZ T,LWT
	JRST PAD	;THE ADDRESS

;PRINT ADDRESSES (ARG USUALLY 18 BITS BUT CAN BE 36 BITS)

PAC:	SKIPE W1,ACPNTR
	CAIE AR,PADSO
	JRST PAD0	;NOT SYMBOLIC OR NO POINTER
	ADDI W1,(T)	;GET RIGHT AC
	SKIPE (W1)	;IF THERE
	JRST SPT1Q	;GO PRINT AND SKIP RETURN
PAD0:	JUMPE T,CPOPJ	;DO NOT PRINT IF 0

PAD:	ANDI T,-1
	JRST @AR		;PADSO OR PAD1
PADSO:	JUMPE T,FP7B		;PRINT A ZERO
	PUSHJ P,LOOK
PADS1:	POPJ P,0
	MOVE W2,1(W1)
	CAMGE T,MXINC
	CAIGE W2,60
	JRST PADS3
	MOVEM T,TEM
	JUMPGE F,PAD1
	PUSHJ P,SPT0
	MOVEI T,"+"
PADS1A:	PUSHJ P,TOUT
	HRRZ T,TEM
PAD1:	JRST TOC		;EXIT

PADS3:	MOVE T,TEM
PADS3A:	TRNE F,NAF
	CAIGE T,776000
	JRST TOC
PADS3B:	MOVNM T,TEM
	MOVEI T,"-"
	JRST PADS1A

SPT1Q:	AOS(P)
	JRST SPT1W
INOUT:	TDC T,[XWD -1,400000]	;IO INSTRUCTION OR NEG NUM
	TDCN T,[XWD -1,400000]
	JRST PADS3B		;TYPE AS NEG NUM
	SKIPE KSFLAG		;KS-10?
	 PUSHJ P,KSIO		;YES, TRY ITS I/O FMT.  ADJSP P,-1, RET IF OK.
	LDB R,[POINT 7,T,9]	;PICK OUT IO DEVICE BITS
	CAIL R,700_-2		;IF DEVICE .L. 700, THEN TYPE
	JRST HLFW		;TYPE AS HALF WORDS
	LDB R,[POINT 3,T,12]
	DPB R,[POINT 6,T,8]	;MOVE IO BITS OVER FOR OP DECODER
	PUSHJ P,OPTYPE
	PUSHJ P,TSPC
	MOVSI T,077400
	AND T,LWT
	JUMPE T,PI4
	PUSHJ P,LOOK		;LOOK FOR DEVICE NUMBER
	JRST PI3A
	MOVE T,TEM
	LSH T,-30
	PUSHJ P,TOC
	JRST PI3A
MASK:	TLNE F,QF
	JRST MASK1
	MOVEI T,MSK
MASK2:	MOVEI W,1
	MOVEM W,FRASE1
	JRST QUANIN
MASK1:	TRNE F,Q2F	;NUMBER TYPED??
	JRST MASK3
	MOVEM T,MSK
	JRST RET
MASK3:	MOVE W,WRD3	;GET NUMBER
	MOVEM T,MSK(W)	;AND PUT WORD THERE
	JRST RET
;HERE WITH WHAT WE BELIEVE IS A KS-10 I/O INSTRUCTION IN T.
;IF IT IS, PRINT IT OUT AS SUCH.  OTHERWISE RETURN TO INOUT WHICH
;WILL TREAT IT LIKE ANOTHER PROCESSOR'S I/O INSTRUCTION.
;SEE KS TECHNICAL MANUAL, PAGE 4-9FF FOR TABLES USED TO PRODUCE THIS CODE.
KSIO:	TRZ F,CLLIF+TTCLF
	LDB R,[POINT 6,T,8]	;SECOND 2 DIGITS.
	CAILE R,25
	 POPJ P,
	CAIGE R,3
	 JRST KSIO1		;JUMP IF MAYBE INTERNAL.
	SKIPN T+1,KSXIO-3(R)
	 POPJ P,
	PUSHJ P,OPTYPX
	TRO F,ITF
KSIO3:	POP P,(P)		;DON'T RETURN TO INOUT--INSTR FOUND.
	JRST KSIO2		;JOIN NORMAL INSTRUCTION TYPEOUT CODE.
KSIO1:	LDB R,[POINT 6,T,12]	;HERE ON POSSIBLE INTERNAL I/O INSTR.
	CAIG R,56
	 SKIPN T+1,KSAPR(R)
	  POPJ P,
	PUSHJ P,OPTYPX
	TRO F,ITF+TTCLF		;SAY TTCALL (I.E. DON'T PRINT AC FIELD).
	JRST KSIO3
KSAPR:	SIXBIT/APRID/
	EXP 0,0,0
	SIXBIT/WRAPR/
	SIXBIT/RDAPR/
	EXP 0,0,0,0,0,0
	SIXBIT/WRPI/
	SIXBIT/RDPI/
	EXP 0,0
	0
	SIXBIT/RDUBR/
	SIXBIT/CLRPT/
	SIXBIT/WRUBR/
	SIXBIT/WREBR/
	SIXBIT/RDEBR/
	EXP 0,0,0,0,0,0,0,0,0,0
	SIXBIT/RDSPB/
	SIXBIT/RDCSB/
	SIXBIT/RDPUR/
	SIXBIT/RDCSTM/
	SIXBIT/RDTIME/
	SIXBIT/RDINT/
	SIXBIT/RDHSB/
	0
	SIXBIT/WRSPB/
	SIXBIT/WRCSB/
	SIXBIT/WRPUR/
	SIXBIT/WRCSTM/
	SIXBIT/WRTIME/
	SIXBIT/WRINT/
	SIXBIT/WRHSB/
KSXIO:	0
	SIXBIT/UMOVE/
	SIXBIT/UMOVEM/
	EXP 0,0
	SIXBIT/TIOE/
	SIXBIT/TION/
	SIXBIT/RDIO/
	SIXBIT/WRIO/
	SIXBIT/BSIO/
	SIXBIT/BCIO/
	EXP 0,0
	SIXBIT/TIOEB/
	SIXBIT/TIONB/
	SIXBIT/RDIOB/
	SIXBIT/WRIOB/
	SIXBIT/BSIOB/
	SIXBIT/BCIOB/

EFFEC:	TLO F,LTF
	HRRZ T,T
WORD:	MOVEI R,322000-326000	;JUMPE-JUMPN
NWORD:	ADDI R,326000+40*T	;JUMPN T,
	HRLM R,SEAR2
	TLZN F,QF
	JRST ERR
	SETCAM T,WRD
	MOVSI T,FRASE-DEN-1		;PREVENT TYPE OUT OF DDT PARTS
	SETCMM FRASE(T)
	AOBJN T,.-1
	PUSHJ P,SETUP
	PUSHJ P,CRF
SEAR1:	PUSHJ P,FETCH
	JRST SEAR2B
	TLNE F,LTF	;CHECK FOR EFFECTIVE ADDRESS SEARCH
	JRST EFFEC0
	EQV T,WRD
	AND T,MSK
SEAR2:	JUMPE T,SEAR3		;OR JUMPN T
SEAR2A:	AOS R,DEFV	;GET NEXT LOCATION
	PUSHJ P,LISTEN	;ANYTHING TYPED?
IFE XMOD,<SKIPA
	JRST SEARF1	;YES, STOP THIS NONSENCE>
	CAMLE R,ULIMIT	;OR END OF SEARCH?
	JRST SEARFN	;YES
	JRST SEAR1	;NO, LOOK SOME MORE

SEAR2B:	MOVEI R,400000-1	;MOVE UP TO HI SEGMENT
	IORB R,DEFV		;PUT IN MEMORY TOO
	TRNN R,400000		;ALREADY IN HI SEGMENT?
	JRST SEAR2A		;NO
SEARFN:	SETCMM LWT		;COMPLEMENT BITS BACK AND STOP SEARCH
	JRST DD1

IFE XMOD,<
SEARF1:	CLRBFO
	JRST SEARFN>
SEAR3:	MOVE R,DEFV
	PUSHJ P,FETCH
	JRST ERR
	TLZ F,STF	;GET RID OF SUPPRESS TYPEOUT MODE
	MOVE T,DEFV
IFN FLDDT!XMOD,<HRRZS USRSAV>
	PUSHJ P,LI1	;CALL REGISTER EXAMINATION LOGIC TO TYPE OUT
	PUSHJ P,CRF
	SETCMM LWT
	SETCMM TEM
SEAR4:	JRST  SEAR2A

EFFECA:	MOVEI W,100
	MOVEM W,TEM
EFFEC1:	MOVE W,T
	LDB R,[POINT 4,T,17]	;GET IR FIELD
	JUMPE R,EFFEC2
	PUSHJ P,FETCH
	POPJ P,	;ERROR RETURN
	HRRZS T		;PREVENT AROV HERE
	ADDI T,(W)
EFFEC2:	HRR R,T
	TLNN W,20		;INDIRECT BIT CHECK
	JRST EFFEC3
	SOSE,TEM
	PUSHJ P,FETCH
	POPJ P,	;ERROR RETURN
	JRST EFFEC1
EFFEC3:	HRRZS T
	JRST CPOPJ1

EFFEC0:	PUSHJ P,EFFECA
	JRST SEAR4	;ERROR RETURN
	EQV T,WRD
	ANDI T,-1
	JRST SEAR2
SETUP:	MOVEI T,777777	;SET UPPER LIMIT VERY LARGE
	TLNN F,SAF	;AND USE IF NONE GIVEN
	HRRZM T,ULIMIT		;SAVE LAST ADDRESS OF SEARCH
	HRRZS R,DEFV		;GET 1ST ADDRESS
	TLNN F,FAF		;WAS A 1ST ADR SPECIFIED?
	SETZB R,DEFV		;NO, MAKE IT ZERO
	CAMLE R,ULIMIT		;LIMITS IN A REASONABLE ORDER?
	JRST ERR		;NO
	POPJ P,		;YES, RETURN

ZERO:	TLNN F,CCF
	JRST ERR
	TLNE F,QF
	SKIPA W2,T
	MOVEI W2,0	;PUT SOMETHING THERE
	PUSHJ P,SETUP
	HRRZ S,@SYMP	;GET 1ST ADR OF SYMBOL TABLE
	MOVE W1,(S)
	CAMN W1,[-1]
	SETZM 1(S)	;IF BOTTOM ENTRY IS A LINK, ZAP IT
	HLRE W1,@SYMP	;GET LENGTH OF SYM TABLE
	SUB W1,S	;GET NEG OF LAST ADR
	MOVNS W1	;GET POS LAST ADR
ZERO1:	TRNN R,777760
	JRST ZEROR	;OK TO ZERO AC'S
IFN XMOD,<SKPUSR
	JRST	[CAIGE R,XZLOW
		MOVEI R,XZLOW
		JRST ZERO3]>
	CAIGE R,ZLOW
	MOVEI R,ZLOW	;DON'T ZERO 20 THRU ZLOW
ZERO3:	CAIL R,DDT
	CAILE R,DDTEND
	JRST .+2
	MOVEI R,DDTEND	;DON'T ZERO DDT
	CAML R,S
	CAMLE R,W1
	JRST .+2
	HRRZ R,W1	;DON'T ZERO SYMBOL TABLE
ZEROR:	CAMLE R,ULIMIT	;ABOVE LIMITS?
	JRST DD1	;YES, STOP
	MOVE T,W2	;THE THING TO INSERT
	PUSHJ P,DEP	;DEPOSIT T
	 TROA R,377777	;
	AOJA R,ZERO1
	TRNN R,400000	;HI SEGMENT?
	AOJA R,ZERO1	;NO, KEEP GOING
	JRST DD1	;FINISH
FTOC:		;NUMERIC OUTPUT SUBROUTINE
TOC:	HRRZ W1,ODF
	CAIN W1,10		;IS OUPUT RADIX NOT OCTAL, OR
	TLNN T,-1		;ARE THERE  NO LEFT HALF BITS?
	JRST TOCA		;YES, DO NOTHING SPECIAL
	HRRM T,TOCS		;NO, TYPE AS HALF WORD CONSTANT
	HLRZS T			;GET LEFT HALF
	PUSHJ P,TOC0		;TYPE LEFT HALF
	MOVSI W1,(ASCII /,,/)
	PUSHJ P,TEXT2		;TYPE ,,
TOCS:	MOVEI T,.-.		;GET RIGHT HALF BACK
TOCA:	HRRZ W1,ODF		;IS OUTPUT RADIX DECIMAL?
	CAIN W1,12
	JRST TOC4		;YES,TYPE SIGNED WITH PERIOD
TOC0:	LSHC T,-43
	LSH W1,-1		;W1=T+1
	DIVI T,@ODF
	HRLM W1,0(P)
	SKIPE T
	PUSHJ P,TOC0
	HLRZ T,0(P)
	ADDI T,"0"
	CAILE T,"9"
	 ADDI T,7
	JRST TOUT

TOC4:	MOVM A,T		;TYPE AS SIGNED DECIMAL INTEGER
	JUMPGE T,TOC5
	MOVEI T,"-"
	PUSHJ P,TOUT
TOC5:	PUSHJ P,FP7		;DECIMAL PRINT ROUTINE
TOC6:	MOVEI T,"."
	JRST TOUT

;SYMBOL OUTPUT SUBROUTINE

SPT0:	HRRZM W1,SPSAV		;SAVE POINTER TO TYPED SYM
SPT:		;RADIX 50 SYMBOL PRINT
IFN FAILSW,<MOVE T,SVFB
	JUMPE T,SPT1W
	CAMN T,BLOCK
	JRST SPT1W
	PUSH P,W1
	LDB T,[POINT 32,(T),35]
	PUSHJ P,SPT1
	MOVEI T,"&"
	PUSHJ P,TOUT
	POP P,W1>
SPT1W:	LDB T,[POINT 32,0(W1),35]	;GET SYMBOL
SPT1:	IDIVI T,50
	HRLM W1,0(P)
	JUMPE T,SPT2
	PUSHJ P,SPT1
SPT2:	HLRZ T,0(P)
	JUMPE T,CPOPJ		;FLUSH NULL CHARACTERS
	ADDI T,260-1
	CAILE T,271
	ADDI T,301-272
	CAILE T,332
	SUBI T,334-244
	CAIN T,243
	MOVEI T,256
	JRST TOUT
SYMD:	MOVEI T,DELO/200000	;$D ;DELETE LAST SYM & PRINT NEW
	HRRZ R,SPSAV		;PICK UP POINTER TO LAST SYM
	JUMPE R,ERR
	DPB T,[POINT 2,(R),1]	;STORE SEMI-DELETE BITS IN SYMBOL
	PUSHJ P,LCT		;SPACE BEFORE IT
	MOVE T,LWT
	JRST CONSYM		;PRINT OUT NEXT BEST SYMBOL
;FLOATING POINT OUTPUT

TFLOT:	MOVE A,T
	JUMPGE A, TFLOT1
;	JUMPE A,FP1A
	MOVNS A
	MOVEI T,"-"
	PUSHJ P,TOUT
	TLZE A,400000
	JRST FP1A
TFLOT1:	TLNN A, 400
	JRST TOC5		;IF UNNORMALIZED, TYPE AS DECIMAL INTEGER

FP1:	MOVEI B,0
	CAMGE A,FT01
	JRST FP4
	CAML A,FT8
	AOJA B,FP4
FP1A:	MOVEI C,0

FP3:	MULI A,400
	ASHC B,-243(A)
	SETZM TEM1	;INIT 8 DIGIT COUNTER
	SKIPE A,B	;DON'T TYPE A LEADING 0
	PUSHJ P,FP7	;PRINT INTEGER PART OF 8 DIGITS
	PUSHJ P,TOC6		;PRINT DECIMAL POINT
	MOVNI A,10
	ADD A,TEM1
	MOVE W1,C
FP3A:	MOVE T,W1
	MULI T,12
	PUSHJ P,FP7B
	SKIPE,W1
	AOJL A,FP3A
	POPJ P,

FP4:	MOVNI C,6
	MOVEI W2,0
FP4A:	ASH W2,1
	XCT,FCP(B)
	JRST FP4B
	FMPR A,@FCP+1(B)
	IORI W2,1
FP4B:	AOJN C,FP4A
	PUSH P,W2	;SAVE EXPONENT
	PUSH P,FSGN(B)	;SAVE "E+" OR "E-"
	PUSHJ P,FP3	;PRINT OUT FFF.FFF PART OF NUMBER
	POP P,W1	;GET "E+" OR "E-" BACK
	PUSHJ P,TEXT
	POP P,A		;GET EXPONENT BACK
FP7:	IDIVI A,12		;DECIMAL OUTPUT SUBROUTINE
	AOS,TEM1
	HRLM B,(P)
	JUMPE A,FP7A1
	PUSHJ P,FP7

FP7A1:	HLRZ T,(P)
FP7B:	ADDI T,260
	JRST TOUT

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0=FT01+1

FCP:	CAMLE A, FT0(C)
	CAMGE A, FT(C)
	Z FT0(C)

FSGN:	ASCII .E-.
	ASCII .E+.

TEXTT:	MOVE W1,T
TEXT:	TLNN W1,774000		;LEFT JUSTIFIED UNLESS LEFT CHAR IS NULL
	LSH W1,35
TEXT2:	MOVEI T,0		;7 BIT ASCII TEXT OUTPUT SUBROUTINE
	LSHC T,7
	PUSHJ P,TOUT
	JUMPN W1,TEXT2
	POPJ P,
IFN FAILSW,<
TBLK:	0
BLOCK:	0
SVF:	0
SW1:	0
SVFB:	0
SVTB:	0
SYMTM2:	0
BLVL:	0>
FLGPNT:	0
FLGNUM:	0
EXFLAG:	0
WRD:	0
WRD2:	0
WRD3:	0
PRNC:	0

FRASE:	0	;DONT CHANGE ORDER, SEE  SEARC+3
SYL:	0
LWT:	0
TEM2:	0
FRASE1:
TEM3:	0
DEN:	0
ARAYOK:	0
ARAYLP:	0
ARAYNM:	0
ARMLT:	0
ARSPB:	BLOCK 60
SYMTM1:	0
SYMTM:	0
ELCNT:	0
ARYLOW:	0
ARAYRS:	0

PRGM:	0
TPRG:	0
ESTU:	0
ESTUT:	0
FSV:	0
FH:	0
SYM:	0
SPSAV:	0	;POINTER TO LAST SYMBOL TYPED
DEFV:	0
ULIMIT:	0
LLOC:	0
LLOCO:	0
SAVLOC:	0		;THE ADR OF OLD REGISTER EXAMINATION SEQUENCE
SYMP:	XWD PID,JOBSYM
FRSTR:	0	;STARTING POINT OF SYMBOL SEARCHES
RSTNXM:	0		;SET TO CLEAR NXM AND LEAVE CLOCK
FILCNT:	-1		;NUMBER OF FILLS AFTER RETURN (-1 NOT SET)
SAVAPR:	0		;SAVE APR IN EXEC MODE
KLMAPF:	0		;NON-ZERO IF RUNNING ON KL10 OR KS2020  CPU.
F3FLAG:	0		;NON-ZERO IF RUNNING ON F3
KLFLAG:	0		;NON-ZERO IF RUNNING ON KL10 CPU
KSFLAG:0		;NON-ZERO IF RUNNING ON A KS2020 CPU
SVKPAF:0		;SAVE KEEP ALIVE FLAG ON KS
SAVPI:	IFN FLDDT,<XWD PC.UIO,0>
	IFE FLDDT,<0>
	1037	;DO NOT TURN OFF CHANNELS 1 AND 2
SAVTTY:	0
OUTRTN:	0	;OUTPUT ROUTINE
STRING:	0	;STRING POINTER FOR INPUT
MSK:	XWD -1,-1
MXINC:	100	;BREAK FROM REL TO ABS
BMASK:	0	;BYTE POINTER MASK
FLGPTR:	0	;POINTER TO FLAG TABLES
ACPNTR:	0	;POINTER TO ACTABLE
ARSP:	XWD -60,ARSPB
B1ADR:	0
B1SKP:	0
B1CNT:	0
B1STR:	0

REPEAT NBP*4-4, <	0>

BNADR=.-4
AUTOPI:	0

IFE FLDDT,<
AC0:	BLOCK 17

AC17:	0
>

SCHM:	EXP PIN			;DO NOT CHANGE ORDER
ARM:	EXP PADSO
ODFM:	EXP 10

SARS:	0
TEM:	0
TEM1:	0
IFN FLDDT!FRMDDT,< OFFSET:	0 
WENB:	0		;NON-ZERO IF WRITES ENABLED
	FILSIZ:	0>
IFN XMOD,<USRFLG:	0>
IFN FRMDDT,<FRAME:	0>		;FRAME TO LOOK AT
IFN XMOD&XTAP,<

PUNCH:	TLC F,FAF+QF
	TLCE F,FAF+QF
	JRST ERR		;ONE ARGUMENT MISSING
PUN2:	ADDI T,1
	HRRZM T,TEM1
	SUB T,DEFV
	JUMPLE T,ERR

PUN1:	MOVEI T,4		;PUNCH 4 FEED HOLES
	PUSHJ P,FEED
	TLNE F,CF		;PUNCH NON-ZERO BLOCKS?
	JRST PUNZ		;YES
	HRRZ R,DEFV
	IORI R,37
	ADDI R,1
	CAMLE R,TEM1
	MOVE R,TEM1
	EXCH R,DEFV
	MOVE T,R
	SUB T,DEFV
	HRL R,T
	JUMPGE R,RET		;EXIT OR PUNCH

PBLK:	MOVE T,R
	SOS W,T		;INIT CHECKSUM
	PUSHJ P,PWRD
PBLK1:	PUSHJ P,FETCH
	JRST ERR
	ADD W,T
	PUSHJ P,PWRD
	AOBJN R,PBLK1
	MOVE T,W
	PUSHJ P,PWRD
	JRST PUN1

;PUNCH NON-ZERO BLOCKS

PUNZ0:	AOS DEFV		;LOOK AT NEXT WORD
PUNZ:	HRRZ W,DEFV		;ENTER HERE - GET STARTING ADDRESS
	MOVE R,W
	SUB W,TEM1		;CALCULATE NEGATIVE LENGTH
	HRL R,W			;SET UP AOBJN POINTER
	JUMPGE R,RET		;FINISHED?
	CAMG R,[XWD -40,0]	;BLOCK LONGER THAN 40?
	HRLI R,-40		;YES, FIX IT UP
	MOVSI W1,400000		;W1 NEGATIVE MEANS FLUSH 0 WORDS
PUNZ2:	PUSHJ P,FETCH		;GET WORD FROM MEMORY
	JRST ERR
	JUMPE T,[AOJA W1,PUNZ4]	;IF WORD IS 0, INDEX 0 WORD COUNTER
	MOVEI W1,0		;CLEAR 0 WORD COUNTER
PUNZ4:	JUMPL W1,PUNZ0		;FLUSH 0 WORD, GET ANOTHER
	CAIL W1,3		; NOSKIP FOR 3RD 0 WORD AFTER NON 0 WORD
	AOSA R			;ADVANCE R TO LAST ADR+1
	AOBJN R,PUNZ2
	ADD W1,DEFV		;CALCULATE DEFV-R+W1=-WORD COUNT
	SUB W1,R
	HRLM W1,DEFV		;PUT -WC IN LEFT HALF OF FA
	EXCH R,DEFV		;SAVE ADR FOR NEXT BLOCK, GET POINTER
	JRST PBLK


LOADER:	TLNE F,QF
	JRST ERR
	MOVEI T,400
	PUSHJ P,FEED
	MOVE R,LOADE
LOAD1:	MOVE T,0(R)
	PUSHJ P,PWRD
	AOBJN R,LOAD1
	MOVEI T,20
LOAD2:	PUSHJ P,FEED
	JRST RET

BLKEND:	TLNN F,QF		;BLOCK END
	MOVE T,[JRST 4,DDT]
	TLNN T,777000		;INSERT JRST IF NO OPCODE
	TLO T,(JRST)
	PUSH P,T
	MOVEI T,20
	PUSHJ P,FEED
	POP P,T
	PUSHJ P,PWRD
	PUSHJ P,PWRD	;EXTRA WORD FOR READER TO STOP ON
	MOVEI T,400
	JRST LOAD2

PWRD:	MOVEI W1,6
PWRD2:	ROT T,6
	CONSZ PTP,20
	JRST .-1
	CONO PTP,50
	DATAO PTP,T
	SOJG W1,PWRD2
	POPJ P,0

FEED:	CONSZ PTP,20
	JRST .-1
	CONO PTP,10
	DATAO PTP,FEED1
	SOJN T,FEED
FEED1:	POPJ P,0	;ADDRESS USED AS A CONSTANT


LOADB:

PHASE 0			;RIM10B CHECKSUM LOADER
	XWD -16,0
BEG:	CONO PTR,60
	HRRI AA,RD+1
RD:	CONSO PTR,10
	JRST .-1
	DATAI PTR,@TBL1-RD+1(AA)
	XCT	TBL1-RD+1(AA)
	XCT	TBL2-RD+1(AA)
AA:	SOJA AA,

TBL1:	CAME CKSM,ADR
	ADD CKSM,1(ADR)
	SKIPL CKSM,ADR

TBL2:	JRST 4,BEG
	AOBJN ADR,RD
ADR:	JRST BEG+1
CKSM=ADR+1

DEPHASE

LOADE:	XWD LOADB-.,LOADB
>	;END OF IFN EDDT$1&<EDDT>B36
	;FOR PAPER TAPE IO
SAVE:	0		;SAVE THE ACS AND PI SYSTEM
IFN XMOD,<MOVEM T,TEM	;GET AN AC
	JSP T,.+1
	XOR T,SAVPI
	TLNE T,(1B5)	;IS BIT SAME AS BEFORE
	SETZM SARS	;YES, SAY NOT STORED
	JSP T,.+1
	ROT T,5
	MOVEM T,USRFLG	;SAVE WITH USER MODE BIT AS BIT 0
	HRRI T,XJOBSYM
	SKIPGE T
	HRRI T,JOBSYM	;SET CORRECT JOBSYM
	HRRM T,SYMP
	MOVE T,TEM>
	SKIPN SARS
	JRST SAV1
	AOS SAVE
	JRST SAV5
SAV1:	IFN XMOD,<
	SKPEXC
	JRST SAV11
	CONI PI,SAVPI
	CONO PI, @SAVPI+1
	MOVS T,BCOMM
	JUMPE T,SAVBP1
	MOVE T,-1(T)
	ANDI T,1B28
	IORM T,SAVPI
	CONO PI,(T)	;TURN THINGS BACK ON IF NECESSARY
SAVBP1:	MOVE T,TEM>
SAV11:	MOVEM 17,AC17
	HRRZI 17,AC0
	BLT 17,AC0+16
	MOVE T, SAVE
	HLLM T, SAVPI
SAV5:
IFN XMOD,<SKPEXC
	JRST SAV12
;;;CARL: new wonderful FOO only caries across halves on stack stuff
;;; You wouldn't want to do this in non-0 section (global stack and all)
	SETOM	KLMAPF		; Assume KL MAPPING IN EFFECT
	MOVEI	T,-1		; 0,,top-of-memory
	PUSH	T,0		; 1,,0 if no carry, 2,,0 elsewise (and 0 {- 0)
	TLZ	T,1		; Make DEC machines return 0
;;	SETOB	T,KLMAPF	;SETUP T FOR FOONLY TEST, ASSUME KL MAPPING IN EFFECT
;;	AOBJN	T,.+1		;FOONLY DOES KA STYLE AOBJN
;;^^ end-of-change ^^
	JUMPN	T,[SETOM F3FLAG
		   JRST SAVF3]  ;AND SKIP AROUND OTHER TESTING
	BLT	T,
	JUMPE	T,SAVKIA	;GO IF ITS KI10
	APRID	T		;GET THE SERIAL NUMBER
	TRNE	T,KSMSK		;SKIP IF KL
	JRST	SAVKS
	SETOM	KLFLAG		;FLAG KL CPU
SAVF3:	CONI	APR,T		;GET APR STATUS
	TRZ	T,LP.IOR+LP.ESF+LP.DSF+LP.CSF+LP.SSF ;CLEAR BITS THAT DO THINGS
	MOVEM	T,SAVAPR	;JUST SAVE FOR INFO AND TO RESTORE PI ASSIGNMENT.
	MOVEI	T,LP.CSF+LP.NXM+LP.PAR	;FOR CLEARING NXM+PAR FLAG.
				;NOTE THAT F3 DOESNT HAVE WORKING NXM FLAG, BUT BIT IS RESERVED ANYWAY.
	MOVEM	T,RSTNXM	;IN KI/KL INDEPENDENT CODE.
	CONO	APR,0		;CLEAR PI ASSIGNMENT SO DON'T GET INTERRUPTS OUT OF DDT
	JRST	SAV12

SAVKS:	SETOM	KSFLAG		;FLAG KS CPU
	RDAPR	T
	TRZ	T,LP.IOR+LP.ESF+LP.DSF+LP.CSF+LP.SSF ;CLEAR BITS THAT DO THINGS
	MOVEM	T,SAVAPR	;JUST SAVE FOR INFO AND TO RESTORE PI ASSIGNMENT.
	MOVEI	T,LP.CSF+SP.NXM+SP.PAR	;FOR CLEARING NXM+PAR FLAG.
	MOVEM	T,RSTNXM	;IN KI/KL/KS INDEPENDENT CODE.
	WRAPR	0		;CLEAR PI ASSIGNMENT SO DON'T GET INTERRUPTS OUT OG DDT
	SETZM	SVKPAF	;CLEAR SAVED KEEP ALIVE FLAG
	MOVE	T,RLWORD	;GET THE RELOAD WORD
	TLZE	T,KPACT_<-^D18>;SEE IF KEEP ALIVE BIT SET
	SETOM	SVKPAF		;REMEMBER IF KEEP ALIVE FLAG WAS SET
	MOVEM	T,RLWORD	;BE SURE KEEP ALIVE FLAG OFF WHILE IN EDDT
	JRST	SAV12

SAVKIA:	SETZM	KLMAPF		;INDICATE KI MAP AND APR STATUS WORD
	CONI APR,T
	TLZ T,37
	TRNE T,NXM	;CHECK FOR NXMEM BIT
	TLO T,(1B0)
	MOVEM T,SAVAPR	;SAVE AS HIGH ORDER BIT
	ANDI T,7
	CONO APR,(T)	;TURN OFF ALL BUT CLOCK CHANNEL
	TRO T,NXM
	MOVEM T,RSTNXM	;SET FLAG TO RESET NXM AND LEAVE CLOCK
SAV12:>
	MOVEI P,PS
	PUSHJ P,TTYRET

	SETOM SARS			;FLAG PROTECTING SAVED REGISTERS
	MOVEI P,PS
	MOVE T,[XWD SCHM,SCH]
	BLT T,ODF		;LOAD THE ACS WITH MODE SWITCHES
	JRST @SAVE

RESTORE: SETOM TEM3	;RESTORE ACS AND PI SYSTEM
RESTR1:	MOVEM T,TEM2	;SAVE RETURN PC TO PUSH IN CASE OF PUSHJ
	SKIPGE TEM3	;IF NOT PUSHJ, DON'T DO THIS
	JRST RESTRX
IFN XMOD,<SKPUSR	;IF USER MODE OR
	SKIPN BCOMM>	;EXEC MODE AND NOT GOING THRU BPZOT
	MOVEI T,LEAV	;THIS IS WHERE THE PUSH XX,TEM2 IS
RESTRX:	HRRM T,SAVE
IFN HI,<PUSHJ P,WPUNS>	;FIX UP WP IF DIDDLED WITH IT
	PUSHJ P,TTYLEV
	MOVE T,SAVPI
	HLLM T, SAVE
IFN XMOD,<
	SKPEXC
	JRST RESTR2
	HRROI T,52177
	SKIPE	KLMAPF
	MOVEI	T,7
	ANDM T,SAVAPR	;GET RID OF EXTRA BITS
	MOVE T,SAVPI
	ANDI T,177	;BECAUSE OF 1000 IN SAVPI
	AND T, SAVPI+1
	IORI T, 2000	;TURN ON CHANNELS
	MOVEM T, SAVPI
	HLRZ W,BCOMM	;GET ADDR OF EXEC SAVE BLOCK (BPZOT+XXX)
	JUMPE W,RESTR2	;JUMP IF ITS BEEN CLEARED
	ADDI W,BPIBC-BPISA	;GET PLACE TO FILLIN RETURN CODE
	HRRM T,(W)	;STORE BITS TO TURN PI SYS BACK ON
	MOVE T,LEAV	;GET INSTRUCTION TO DO TO LEAVE.
	SKIPL TEM3	;SKIP IF NOT PUSHJ
	HRRI T,5(W)	;FOR PUSHJ, FILL IN DIFFERENT EA, SET BELOW
	MOVEM T,1(W)	;SAVE THE INSTRUCTION IN THE RETURN BLOCK
	HRRZ T,BCOM	;GET ADDRESS TO DISMISS TO (RETURN PC)
	HRRM T,4(W)	;STUFF IT INTO THE JRST INSTRUCTION
	MOVE T,TEM2	;GET THE PC OF THE PUSHJ
	MOVEM T,5(W)	;SAVE SO THE PUSH ABOVE WILL PUSHJ THE RETURN PC
	HRRM W,SAVE>	;DISMISS TO THE BP'S RETURN BLOCK
RESTR2:	HRLZI 17,AC0
	BLT 17,17
	SETZM SARS
IFN XMOD,<SKPEXC
	JRST RESTR3
	SKIPE	KSFLAG		;SKIP IF NOT KS
	JRST	REST2A
	CONO APR,@RSTNXM
	CONO APR,@SAVAPR	;RESET APR
	SKIPN BCOMM
	CONO PI,@SAVPI
	JRST	RESTR3

REST2A:	WRAPR	@RSTNXM		;PROCESS FOR KS CPU
	WRAPR	@SAVAPR		;RESET APR
	SKIPN	SVKPAF		;SKIP IF NEED TO RESET KEEP ALIVE FLAG
	JRST	REST2B		;JUMP IF NOT
	MOVE	T,RLWORD	;GET RELOAD WORD
	TLO	T,KPACT_<-^D18>	;SET KEEP ALIVE FLAG
	MOVEM	T,RLWORD	;RESTORE RELOAD WORD
REST2B:	SKIPN	BCOMM
	WRPI	@SAVPI
RESTR3:>
	JRST 2,@SAVE
CRN:	MOVEI T,15		;CARRIAGE RETURN
	JRST TOUT

CRNRB:	PUSHJ P,CRN
	MOVEI T,177
	JRST TOUT

CRF:	PUSHJ P,CRN
	MOVEI T,12		;LINE FEED
	JRST TOUT

LCT:	PUSHJ P,TSPC
	PUSHJ P,TSPC

TSPC:	MOVEI T,40		;SPACE
	JRST TOUT
FLGOUT:	SKIPN R,FLGPNT
	JRST HLFW	;IF NO POINTER USE HALFWORD
	MOVSI W1,400000	;SET FOR HIGH ORDER BIT
FLGLP2:	PUSHJ P,PRNTIT
	JUMPE W1,[SKIPE EXFLAG	;WAS THERE SOMETHING PRINTED
		POPJ P,		;YES, EXIT
		MOVEI T,"0"	;NO, PRINT A 0
		JRST TOUT]
	SKIPN EXFLAG
	JRST FLGLP2
	PUSH P,T
	MOVEI T,","
	PUSHJ P,TOUT
	PUSHJ P,TOUT
	POP P,T
	JRST FLGLP2

GETPTR:	SKIPN R,FLGPTR
	POPJ P,
FLGSLP:	HRRZM R,FLGPNT
	TRNE F,Q2F
	SOSGE WRD2
	JRST CPOPJ1
	HLRZS R
	JUMPE R,CPOPJ
	SKIPE R,(R)
	JRST FLGSLP
	POPJ P,

PRNTIT:	HRLI R,-^D18	;SET FOR HALF WORD
	SETZM FLGNUM
	SETZM EXFLAG	;NO ! AND NO NUMERIC
FLGLP:	TDNN T,W1
	JRST NOBIT
	SKIPN (R)	;TEST FOR NAME
	JRST	[IORM W1,FLGNUM	;SAVE BIT
		JRST NOBIT]
	PUSH P,T
	PUSH P,W1
	MOVEI T,"!"
	SKIPE EXFLAG
	PUSHJ P,TOUT
	MOVE T,(R)
	PUSHJ P,SPT1
	SETOM EXFLAG	;WE HAVE PUT OUT SOMETHING
	POP P,W1
	POP P,T
NOBIT:	LSH W1,-1
	AOBJN R,FLGLP
	SKIPE FLGNUM
	JRST	[PUSH P,T
		PUSH P,W1
		MOVEI T,"!"
		SKIPE EXFLAG
		PUSHJ P,TOUT
		MOVE T,FLGNUM
		TRNN T,-1	;CHECK TO SEE IF LEFT HALF
		MOVSS T
		PUSHJ P,TOC
		POP P,W1
		POP P,T
		SETOM EXFLAG
		POPJ P,]
	POPJ P,

FLGMOD:	PUSHJ P,GETPTR
	SETZM FLGPNT
	MOVEI SCH,FLGOUT
	JRST BASE1
LFTT:	PUSHJ P,GETPTR
	SETZM FLGPNT
	MOVEI SCH,LFPIN
	JRST BASE1
RFTT:	PUSHJ P,GETPTR
	SETZM FLGPNT
	MOVEI SCH,RFPIN
	JRST BASE1

LFFLG:	SKIPN R,FLGPNT
	JRST PI8A	;NONE THERE
COMFLG:	MOVEI W1,400000
	PUSHJ P,PRNTIT
	MOVEI T,"0"
	SKIPN EXFLAG
	PUSHJ P,TOUT
	JRST PI7
RFFLG:	SKIPN R,FLGPNT
	JRST PI8A
	ADDI R,^D18
	JRST COMFLG
;PRINT BYTE POINTERS

PBYPT:	PUSHJ P,EFFECA	;GET THE EFFECTIVE ADDRESS OF WATS IN T
	 JRST ERR
	HRRZ R,T
	PUSHJ P,FETCH
	 JRST ERR
	SKIPE WRD2	;T NOW HAS BYTE POINTER
	JRST PBYPT1	;PRINT AS BYTE POINTER
	MOVE W1,T	;SAVE BYTE POINTER PART
	PUSHJ P,EFFECA
	 JRST ERR
	HRRZ R,T
	PUSHJ P,FETCH
	 JRST ERR
	HRRI W1,T	;T NOW HAS WORD OF BYTE
	TLZ W1,37
	LDB T,W1
	MOVEM T,LWT
	JRST TOCA	;PRINT BYTE

PBYPT1:	MOVEM T,LWT	;SAVE BYTE POINTER
	MOVE W1,[ASCII /POINT/]
	PUSHJ P,TEXT2
	MOVEI T," "
	PUSHJ P,TOUT
	LDB A,[POINT 6,LWT,11]	;SIZE FIELD
	PUSHJ P,FP7
	MOVEI T,","
	PUSHJ P,TOUT
	TRZ F,CLLIF
	PUSHJ P,PI4	;PRINT ADDRESS PART
	LDB B,[POINT 6,LWT,5]	;GET POSITION
	MOVEI A,^D35
	SUB A,B
	JUMPL A,CPOPJ
	MOVEI T,","
	PUSHJ P,TOUT
	JRST FP7	;PRINT POSITION

BITO:	MOVEI	R,BITT	;BYTE OUTPUT SUBROUTINE
	TLNE F,CCF
	MOVEI R,BITTP	;PERMENENT IS DIFF
	TRZN	F,Q2F
	JRST	ERR
	MOVE	T,WRD2
	SETZM	KMCBYP	;TURN OFF KMCBYTE OUTPUT MODE
	CAIL	T,^D80	;IF BYTESIZE > 80 SET KMCSTYLE BYTE OUTPUT
	  JRST [SUBI  T,^D80
		MOVEM T,WRD2
		SETOM KMCBYP
		JRST  .+1]
	MOVEM	T,SVBTS
	TLNE F,CCF
	MOVEM T,SPBTS
	MOVEI	T,^D36
	IDIV	T,WRD2
	SKIPE	T+1
	ADDI	T,1
	MOVEM	T,SVBTS2
	TLNE F,CCF
	MOVEM T,SPBTS2
	HRRZ	SCH,R
	JRST	BASE1

BITTP:	MOVE T+1,SPBTS
	MOVEM T+1,SVBTS
	MOVE T+1,SPBTS2
	MOVEM T+1,SVBTS2
BITT:	MOVE T+1,T
	SKIPE	KMCBYP	;SKIP UNLESS KMCBYTE OUTPUT MODE IS SET
	  JRST [LSH T+1,2
		HRR T,T+1	;PACK THE TWO HALFS TOGETHER
		LSH T,2		;SHIFT LEFT TWO MORE
		MOVE T+1,T	;COPY TO T+1
		JRST .+1]
	SKIPN SVBTS
	JRST BITTM	;USE MASK FOR OUTPUT
	MOVE	T,SVBTS2
	MOVEM	T,SVBT2
	MOVEM	T+1,SVBT3
BITT2:	MOVEI	T,0
	MOVE	T+2,SVBTS
	LSHC	T,(T+2)
	MOVEM	T+1,SVBT3
	PUSHJ	P,TOCA
	SOSG	SVBT2
	POPJ P,
	MOVEI	T,","
	PUSHJ	P,TOUT
	MOVE	T+1,SVBT3
	JRST	BITT2

KMCBYP:	0
SPBTS:	0
SPBTS2:	0
SVBTS:	0
SVBTS2:	0
SVBT3:	0
SVBT2:	0
BITTM:	MOVEI T,^D36	;SET OUTPUT COUNT
	MOVEM T,SVBT3
	MOVE T+2,BMASK	;GET MASK BITS
BITTM1:	MOVEI T,0	;SET TO SHIFT WORD
	SKIPL T+2	;START WITH 1 BITS
	SETCA T+2,
BITTM2:	LSHC T,1	;NEXT BIT
	LSH T+2,1	;SHIFT MASK
	SOSLE SVBT3	;ALL BITS GONE?
	JUMPL T+2,BITTM2	;PART OF SAME FIELD
	MOVEM T+2,SVBT2	;SAVE MASK
	MOVEM T+1,SVBT4	;AND PARTIAL MASK
	PUSHJ P,TOCA
	SKIPG SVBT3	;ANY MORE?
	POPJ P,		;NO, RETURN
	MOVEI T,","	;COMMA
	PUSHJ P,TOUT
	MOVE T+1,SVBT4	;GET WORD BACK
	MOVE T+2,SVBT2	;AND MASK
	JRST BITTM1	;PRINT NEXT FIELD

SVBT4:	0
IFN XMOD,<	;EXECUTIVE MODE TELETYPE I/O

SUBTTL TELETYPE IO LOGIC


	DTE==200
	DTEII=142		;DTE20 INTERRUPT INST
	DTEUNS=143		;UNUSED
	DTEEPW=144		;EXAMINE PROTECTION WORD
	DTEERW=145		;EXAMINE RELOCATION WORD
	DTEDPW=146		;DEPOSIT PROTECTION WORD
	DTEDRW=147		;DEPOSIT RELOCATION WORD
	DTEFLG=444
	DTEF11=450
	DTECMD=451
	DTEMTD=455
	DTEMTI=456
	.DTMTO==10B27
	.DTMMC==11B27
	.DTNMC==12B27

	DTEN==4			;MAX NUMBER OF DTE'S
	TO11DB==1B22		;TO 11 DOORBELL
	CL11PT==1B26		;CLEAR TO 10 DOORBELL
	PI0ENB==1B32		;PI CHANNEL 0 ENABLE
	PIENB==1B31		;ENABLE PI SETTING
	DTEPRV==1B20		;RESTRICTED BIT

;KS TERMINAL INTERFACE

	RLWORD==31		;CTY RELOAD WORD
		KPACT==1B5	;KEEP ALIVE ACTIVE
	CTYIWD==32		;CTY INPUT WORD
	CTYOWD==33		;CTY OUTPUT WORD
		CTYVAL==1B27	;VALID FLAG
		CTYCHR==377B35	;CHARACTER

;APR INTERNAL CLOCK SERVICE

;CONI/CONO MTR,

MTR==024			;DEVICE CODE

MTRLOD==1B18			;LOAD  BITS 21-23
;	19-20			;UNUSED, MBZ
MTREPA==1B21			;ENABLE EXEC PI ACCOUNTING
MTRENA==1B22			;ENABLE EXEC NON-PI ACCOUNTING
MTRAMN==1B23			;ACCOUNTING METERS ON
MTRTBF==1B24			;TIME BASE OFF
MTRTBN==1B25			;TIME BASE ON
MTRCTB==1B26			;CLEAR TIME BASE
;	27-32			;UNUSED, MBZ
MTRPIA==7B35			;PI ASSIGNMENT

;CONI/CONO TIM

TIM==020			;DEVICE ASSIGNMENT

TIMCIC==1B18			;CLEAR INTERVAL COUNTER
;	19-20			;UNUSED, MBZ
TIMITO==1B21			;INTERVAL TIMER ON
TIMDON==1B22			;DONE/CLEAR DONE
TIMICO==1B23			;COUNTER OVERFLOW

TINSTR:	ILDB T,STRING	;READ FROM USER SUPPLIED STRING
	JUMPE T,XTIN3	;DONE
	SKIPE	KSFLAG	;SKIP IF NOT ON A 2020
	 JRST	[SKIPN CTYIWD 	;TEST FOR INPUT WAITING
		JRST	TINST1	;NO, CONTINUE PROCESSING STRING
		JRST	XTIN3]	;YES, GO GET CTY INPUT

	CONSZ TTY,40	;INPUT WAITING
PRINTX WHAT ABOUT KL10?
	 JRST XTIN3	;STOP
TINST1:	CAIE T,15
	 JRST XTIN2	;RETURN IS SPECIAL
	ILDB T,STRING	;SEE IF FOLLOWED BY A LF
	CAIN T,12
	 JRST XTIN4	;YES, IGNORE LF
	MOVSI T,70000	;DECREMENT BYTE POINTER
	ADDM T,STRING
XTIN4:	MOVEI T,15
	JRST XTIN2
XTIN3:	SETZM STRING

XTIN:	SKIPE STRING	;ANY STRING INPUT WAITING
	JRST TINSTR
	PUSHJ P,XLISTE		;TELETYPE CHARACTER INPUT
	 JRST .-1
XTIN2:	CAIE T,175
	CAIN T,176
	MOVEI T,33	;CHANGE ALL ALT MODES TO NEW
	CAIN T,177	;RUBOUT?
	JRST WRONG	;YES, TYPE XXX
	TRNE T,140	;DON'T ECHO CR,LF,ALT,TAB,BACK SPACE,ETC
XTOUT:	CAIG T,04	;DON'T TYPE EOT OR LOWER CHARS
	POPJ P,
	SKIPE OUTRTN	;SPECIAL OUTPUT ROUTINE??
	JRST @OUTRTN	;YES, GO TO IT
	SKIPE	KLFLAG		;KL CPU?
	 JRST	KLXTYO	;YES
	SKIPE	KSFLAG		;KS CPU
	 JRST	KSXTYO		; YES
	HRLM T,(P)
	IMULI T,200401		;GENERATE PARITY
	AND T,[11111111]
	IMUL T,[11111111]
	HLR T,(P)
	TLNE T,10
	TRC T,200		;MAKE PARITY EVEN
	CONSZ TTY,20
	JRST .-1
	DATAO TTY,T
	ANDI T,177		;FLUSH PARITY
	CAIN T,15		;IF THIS IS RETURN
	SKIPN FILCNT		;AND THERE ARE FILLS TO SEND
	POPJ P,0
	PUSH P,W2
	MOVE W2,FILCNT
	MOVEI T,177
	PUSHJ P,XTOUT
	SOJG W2,.-1
	POP P,W2
	MOVEI T,15
	POPJ P,

KLXTYO:	PUSHJ	P,EBRIDX	;GET INDEX OF EPR IN TT2
	MOVEI	T,.DTMTO(T)	;GET MONITOR OUTPUT COMMAND AND CHAR IN T
	MOVEM	T,DTECMD(TT2)	;PUT IN COMMAND WORD
	SETZM	DTEMTD(TT2)	;CLEAR DONE FLAG.
	XCT	DING11		;RING THE DOORBELL
	SKIPN	DTEMTD(TT2)	;DONE YET?
	JRST	.-1		;NO, LOOP
	ANDI	T,377		;CLEAN UP CHARACTER IN T
	POPJ	P,0		;RETURN

KSXTYO:	SKIPE	CTYOWD		;WAIT TIL EMPTY
	JRST	.-1
	TRO	T,CTYVAL	;SET VALID FLAG
	MOVEM	T,CTYOWD
	WRAPR	LP.SSF+SP.808	;WHAP THE 8080
	SKIPE	CTYOWD		;WAIT UNTIL THE CHAR IS TAKEN
	JRST	.-1		;LOOP UNTIL TAKEN
	ANDI	T,CTYCHR	;CLEAR UP CHAR
	POPJ	P,

XLISTE:	SKIPE	KLFLAG
	JRST	KLXLIS
	SKIPE	KSFLAG		;SKIP IF NOT A KS
	JRST	KSXLIS
	CONSO TTY,40	;LISTEN FOR TTY
	POPJ P,
	DATAI TTY,T
XLIST1:	ANDI T,177
	JRST CPOPJ1

KLXLIS:	PUSHJ	P,EBRIDX	;GET EPT INDEX IN TT2
	SKIPN	DTEMTI(TT2)	;ANY INPUT YET?
	POPJ	P,		;NO
	MOVE	T,DTEF11(TT2)	;GET IT
	SETZM	DTEMTI(TT2)	;YES
	JRST	XLIST1

KSXLIS:	SKIPN	CTYIWD		;SKIP IF THERE IS INPUT
	POPJ	P,		;ELSE RETURN
	MOVE	T,CTYIWD	;GET THE CHARACTER
	SETZM	CTYIWD		;CLEAR THE INPUT WORD
	JRST	XLIST1	


XTTYRE:	SKIPE	KLFLAG
	JRST	LTTYRE		;YES.
	SKIPE	KSFLAG
	JRST	STTYLE		;JUMP IF KS CPU
	MOVEI  T,3410
TTY1:	MOVEI W2,400000
	CONSZ TTY,120
	SOJG W2,.-1
	CONI TTY,SAVTTY
	DATAI TTY,W2
	HRLM W2,SAVTTY
	CONO TTY,(T)
	SKIPN	F3FLAG		;NO FILLS IF F3
	SKIPL FILCNT
	POPJ P,
	MOVEI T,0	;NOW MUST DETERMINE SPEED
	CONO APR,APRCLK
	CONSO APR,APRCLK	;WAIT FOR A CLOCK TICK
	JRST .-1
	CONO APR,APRCLK	;RESET
	DATAO TTY,T	;SEND A NULL
	CONSO TTY,20
	JRST .+5	;FINISHED
	CONSO APR,APRCLK
	JRST .-3	;AND WATCH FOR CLOCK TICK
	CONO APR,APRCLK	;RESET
	AOJA T,.-5	;COUNT CLOCK TICKS
	MOVEI W2,0
	CAIGE T,5
	MOVEI W2,2	;AT LEAST 15 CPS
	CAIGE T,3
	MOVEI W2,5	;30 CPS
	MOVEM W2,FILCNT
	POPJ P,

XTTYLE:	SKIPE	KLFLAG
	JRST	LTTYLE
	SKIPE	KSFLAG
	JRST	STTYLE
	MOVE T,SAVTTY
	TRZ T,160
	TRO T,3600
	TRNE T,10
	TRZ T,200
	JRST TTY1

;ROUTINES TO SAVE AND RESTORE KL10 TTY STATUS
; WHICH AMOUNTS TO SAVING AND RESTORING DTE INTERRUPT 
; INSTRUCTION IN LOCATION DTEII

LTTYLE:	MOVE	T,MSTRDT	;GET ID OF MASTER DTE
	LSH	T,3		;FIND EPT CHUNK
	MOVE	W2,SAVEBR	;THE OLD EBR
	LSH	W2,^D9		;MAKE IT A CORE ADDRESS
	ADDI	W2,0(T)		;POINT TO BEGINNING OF EPT CHUNK
	MOVEI	T,DTEII(W2)	;WHERE TO DO RESTORE
	HRLI	T,SAVII		;WHERE TO RESTORE FROM
	BLT	T,DTEDRW(W2)	;UP THROUGH DEPOSIT, LAST WORD
	SETZM	SAVII		;NOTE PGM MODES NOW IN EFFECT
	CONSZ	PAG,TRPENB	;IS PAGGING NOW ENABLED?
	SKIPN	DTEEPW(W2)	;YES SECONDARY PROTOCOL IN EFFECT,
	POPJ	P,		;JUST RETURN, DON'T TURN IT OFF
	MOVEI	T,.DTNMC	;WE WERE IN REGULAR PROTOCOL, SETUP OFF COMMAND
	JRST	DTEDCM		;DO COMMAND



;CODE TO SAVE TTY STATE (I.E. THE DTE STATE FOR THE MASTER -11)

LTTYRE:	CONI	PAG,T		;READ EBR
	ANDI	T,017777
	LSH	T,^D9
	CONO	APR,@RSTNXM
	SKIP	(T)
	TLNN	T,-1		;IF GREATER THAN 256K, DON'T USE IT.
	CONSZ	APR,LP.NXM
	JRST	[CONO PAG,0
		 SETZ T,
		 JRST .+1]
	LSH	T,-^D9		;BACK TO PAGE NUMBER
	MOVEM	T,SAVEBR
	SKIPE	SAVII		;PGM MODES IN EFFECT?
	JRST	LTTYR1		;NO, DON'T SAVE
	MOVSI	T,-DTEN		;POLL ALL DTES
	MOVE	W2,[CONSO DTE,DTEPRV]	;GET TEST WORD
	MOVE	W1,[CONSO DTE,PI0ENB+7]	;TEST FOR PI0 ENABLED
				;   OR PI ASSIGNMENT UP
	MOVE	W,[CONO DTE,0]	;PROTOTYPE CONO
LTTYR2:	XCT	W1		;PI 0 UP ON THIS GUY?
	JRST	[HRRI W,PIENB+PI0ENB	;NO. SET PI0
		XCT W
		XCT W1		;NOW UP?
		JRST LTTYR4	;NO. DOESN'T EXIST THEN
		TRZ W,PI0ENB	;TURN OFF ZERO
		XCT W		;DO IT
		JRST .+1]	;AND PROCEED
	XCT	W2		;THIS THE MASTER?
	JRST	[MOVEI T,0(T)	;YES. GET ITS NUMBER
		MOVEM T,MSTRDT	;SAVE IT
		LSH T,^D<35-9>	;POSITION CODE IN B9
		ADD T,[CONO DTE,TO11DB] ;GET THE INSTRUCTION
		MOVEM T,DING11	;SAVE IT
		JRST LTTYR3]	;AND DONE
LTTYR4:	ADD	W2,[1B9]	;NEXT DTE
	ADD	W,[1B9]
	ADD	W1,[1B9]	;ADJUST ALL I/O INSTRUCTIONS
	AOBJN	T,LTTYR2	;POLL ALL OF THEM
	HALT	.		;CAN'T HAPPEN!!!!!!!!!!!!!
LTTYR3:	MOVE	T,SAVEBR	;GET EBR AGAIN
	LSH	T,^D9		;MAKE IT A CORE ADDRESS
	MOVE	W2,MSTRDT	;GET MASTER'S NUMBER
	LSH	W2,3		;HIS CHUNK
	ADD	T,W2		;THE POSITION IN THE EPT
	MOVE	W2,T		;SAVE EBR FOR INDEXING
	MOVSI	T,DTEII(T)	;START OF EPT LOCATIONS TO SAVE
	HRRI	T,SAVII	;WHERE TO SAVE THEM
	BLT	T,SAVDRW
	SKIPN	DTEEPW(W2)	;USING PRIMARY PROTOCAL?
	JRST	LTTYR1		;NO. GO ON
	MOVE	T,MSTRDT	;GET MASTER'S ID
	LSH	T,^D<35-9>	;POSITION CODE IN B9
	ADD	T,[CONSZ DTE,TO11DB]	;GET TEST INSTRUCTION
	XCT	T		;WAIT FOR -11 TO ANSWER ALL DOORBELLS
	JRST	.-1		;THE WAIT
LTTYR1:	MOVSI	T,(HALT)
	MOVEM	T,DTEII(W2)	;NO INTERRUPTS
	SETZM	DTEEPW(W2)	;CLEAR EXAMINE PROTECTION WORD
	MOVEI	T,.DTMMC	;TURN ON SECONDARY TTY I/O SYSTEM
DTEDCM:	PUSHJ	P,EBRIDX	;GET EPT INDEX IN TT2
	SETZM	DTEFLG(TT2)	;CLEAR DONE FLAG
	MOVEM	T,DTECMD(TT2)	;STORE COMMAND FOR 11
	XCT	DING11		;RING HIS DOORBELL
	SKIPN	DTEFLG(TT2)	;WAIT FOR FINISH
	JRST	.-1
	POPJ	P,		;RETURN

;ROUTINE TO LOAD EPT ADDRESS IN TT2. CALLED BY ROUTINES WISHING
;TO LOCATE THE MONITOR PROTOCOL LOCATIONS

EBRIDX:	MOVE	TT2,SAVEBR	;GET EBR ADDRSSS
	LSH	TT2,^D9		;MAKE IT A CORE ADDRESS
	POPJ	P,		;AND DONE

XTEXIN:	PUSHJ P,XTIN	;INPUT SUBROUXTINE FOR TEXT MODES
	TRNN T,140
	JRST XTOUT	;ECHO CHARACTERS (0-37) NOT ECHOED
	POPJ P,

SAVII:	0
SAVUNS:	0
SAVEPW:	0
SAVERW:	0
SAVDPW:	0
SAVDRW:	0
SAVEBR:	0
MTRCNI:	0
TIMCNI:	0
MSTRDT:	0
DING11:	0
; ROUTINES TO SAVE AND RESTORE THE KS2020 TTY STATUS

STTYLE:				;SAME CODE FOR LEAVE AND RESTORE
STTYRE:	MOVE	W2,SAVCTY	;GET SAVED CTY INPUT AND OUTPUT CHAR
	SKIPN	CTYOWD		;SKIP IF OUTPUT
	JRST STTYR2		;JUMP AND CHEK INPUT
	MOVE	T,SAVAPR	;TEST IF 8080 HAS BEEN INTERRUPTED
	TRZN	T,SP.808	;SKIP IF IT HAS
	JRST	STTYR2
	SKIPE	CTYOWD		;WAIT TIL CHAR. TAKEN
	JRST	.-1
STTYR2:	MOVE	T,CTYOWD	
	MOVEM	T,SAVCTY	;SAVE THE OUTPUT WORD
	HRRM	W2,CTYOWD		;RESTORE THE OUTPUT CHAR
	MOVE	T,CTYIWD
	HRLM	T,SAVCTY		;SAVE THE INPUT CHAR
	HLRM	W2,CTYIWD	;RESTORE THE INPUT CHAR
	POPJ	P,

SAVCTY:	0
>
TEXIN:	IFN XMOD,<SKPUSR
	JRST XTEXIN>
TIN:	IFN XMOD,<SKPUSR
	JRST XTIN>
	SKIPN STRING
	JRST TIN4	;NO STRING INPUT
	ILDB T,STRING
	JUMPE T,TIN3	;DONE
	CAIE T,175
	CAIN T,176
	MOVEI T,"$"
	CAIN T,33
	MOVEI T,"$"
	PUSHJ P,TOUT
	LDB T,STRING
	JRST TIN2
TIN3:	SETZM STRING
TIN4:
IFE CMDFIL,<	XCT TTYINS		;GET NEXT CHARACTER INTO T >
IFN CMDFIL,<	PUSHJ P,INCHR >

TIN2:	CAIE T,175
	CAIN T,176
	MOVEI T,33		;CHANGE OLD ALT MODES TO NEW
	CAIN T,177
	JRST WRONG		;TYPE XXX FOR A RUBOUT
	POPJ P,

TOUT:	CAIL	T,40		;check for control char
	 JRST	TOUTOK
	CAIE	T,15		;let crlf pass
	 CAIN	T,12
	  JRST	TOUTOK
	JUMPE	T,TOUTOK	;nulls go through okay too
TOUTCC:	PUSH	P,T
	MOVEI	T,"^"
 	PUSHJ	P,TOUTOK
	MOVE	T,(P)
	ADDI	T,100
	PUSHJ	P,TOUTOK
	POP	P,T
	POPJ	P,
TOUTOK:
IFN XMOD,<
	SKPUSR
	 JRST 	XTOUT
>
	SKIPE	OUTRTN
	 JRST	@OUTRTN
	OUTCHR	T		;OUTPUT A CHARACTER
	POPJ	P,

LISTEN:	IFN XMOD,<SKPUSR
	JRST XLISTE>
IFN FLDDT!FRMDDT,<SKIPN COMAND>
	INCHRS T		;GET NEXT CHAR, NO IO WAIT
	POPJ P,			;NO CHARACTER EXISTED, RETURN
	JRST CPOPJ1		;CHARACTER WAS THERE, SKIP RETURN

TTYRET:	IFN XMOD,<
	SKPUSR
	JRST XTTYRE>
	PUSH P,T
	HRROI T,TTYMOD
	GETTAB T,
	 MOVEI T,0
	MOVEM T,SAVTTY	;SAVE TTY MODE
	MOVEI T,1000	;SET FOR BREAK2 MODE
	SETMOD T,
	POP P,T
	POPJ P,


TTYCLR:	IFN XMOD,<SKPEXC>
	CLRBFI
	POPJ P,

TTYLEV:	IFN XMOD,<
	SKPUSR
	JRST XTTYLE>
	PUSH P,T
	MOVE T,SAVTTY
	SETMOD T,	;RESTORE TTY MODE
	POP P,T
	POPJ P,

TTYINS:	INCHWL T
IFN CMDFIL,<
INCHR:	SKIPE	CCL	;unread CCL file waiting?
	 PUSHJ	P,INRPG
	SKIPE	COMAND	;see if command file
	 PUSHJ	P,GETCHR;do terminal input if error or EOF
	  XCT	TTYINS	;input from terminal
	POPJ P,		;character returned in T

GETCHR:	PUSHJ P,GETCH1	;get character from command file
	 POPJ P,	;error or EOF
	CAIE T,15	;CR - okay
	 CAIN T,12	;LF too
	  JRST COPCHR
	CAIN T,"Y"-100	;check for ^Y comment character
	 JRST GETLFD	; ^Y in command file is a comment
	CAIE T,33	;check for all the escapes
	 CAIN T,175
	  MOVEI T,"$"
	CAIN T,176
	 MOVEI T,"$"
COPCHR:	PUSHJ P,TOUT	;echo command file commands
	LDB T,CBUF+1	;get original character back
	JRST CPOPJ1

GETLFD:	PUSHJ P,GETCH1
	 POPJ P,	;EOF
	CAIE T,12
	 JRST GETLFD	;SKIP TO LFD (no echo)
	JRST COPCHR

GETCH1:	SOSL	CBUF+2	;check for more chars in this buffer
	 JRST	GETOK
	SKIPL	COMAND	;skip if disk (not tempcore)
	 JRST	CMDCLR
	MOVEI	T,CM
	DEVNAM	T,	;skip if channel is open
	 JRST	CMDCLR
	IN	CM,	;get next buffer
	 JRST	GETCH1
CMDCLS:	MOVE	T,COMAND
	JUMPE	T,CPOPJ
	CAMN	T,[sixbit "DELETE"]
	 JRST	[MOVEI	T,CM
		DEVNAM	T,	; skip if channel is open
		 JRST	CMDCLR
		SETZM	TMPBF
	 	RENAME	CM,TMPBF
		 JFCL
		JRST	.+1]
	RELEAS	CM,
CMDCLR:	SETZM	COMAND
	POPJ	P,

GETOK:	IBP CBUF+1
	MOVEI T,1
	TDNE T,@CBUF+1	;check for SOS line number
	 JRST GETLIN
	LDB T,CBUF+1
	JUMPE T,GETCH1	;ignore nulls
	JRST CPOPJ1

GETLIN:	MOVNI T,4	;skip SOS line number
	ADDM T,CBUF+2	;adjust byte count
	REPEAT 4,<IBP CBUF+1>;adjust byte pointer
	PUSHJ P,GETCH1	;skip the tab
	 POPJ P,
	JRST GETCH1	;return with next character on line in T
>;END IFN CMDFIL
BDISP:	POINT 12,DISP(R),11
	POINT 12,DISP(R),23
	POINT 12,DISP(R),35
DISP:	
DEFINE DCHK(ARG),<IRP ARG,<IFGE 'ARG-DDT-10000,<PRINTX OFFSET OF ROUTINE 'ARG FROM START OF DDT TOO LARGE
QQQQQQ>>>
DEFINE D (Z1,Z2,Z3)<DCHK(<Z1,Z2,Z3>)
		<Z1-DDT>_30+<Z2-DDT>_14+Z3-DDT>
	;THIS MACRO PACKS 3 ADDRESSES INTO ONE WORD; EACH ADR IS 12 BITS

IFE XMOD&XTAP,<	PUNCH==ERR
	BLKEND==ERR
	LOADER==ERR>
IFE CMDFIL,<NOCSH==ERR>
IFE FLDDT,<IFN FRMDDT,<CHGMOD==RDSYMF>
IFE FRMDDT,<	CHGMOD==ERR>>
IFE FLDDT!FRMDDT,<	ENBWT==ERR
IFE XMOD,<USEBUF==ERR
	SETBUF==ERR
	PRTBUF==ERR>>
IFE HI,<HISTUF==ERR>

D ERR,CTLA,USEBUF
D ERR,ERR,SETBUF
D WRONG,ERR,VARRW
D TAB,LINEF,ERR
D ERR,CARR,ERR
D ERR,PRTBUF,ERR
D PUNCH,ERR,STFRM
D ERR,CHGMOD,ENBWT
D ERR,NOCSH,ERR
D CONTROL,ERR,ERR
D ERR,ERR,SPACE
D SUPTYO,TEXI,ASSEM
D DOLLAR,PERC,SETBLK
D DIVD,LPRN,RPRN
D MULT,PLUS,ACCF
D MINUS,PERIOD,SLASH
D NUM,NUM,NUM
D NUM,NUM,NUM
D NUM,NUM,NUM
D NUM,TAG,SEMIC
D FIRARG,EQUAL,ULIM
D QUESTN,INDIRECT,ABSA
D BPS,CON,SYMD
D EFFEC,SFLOT,GO
D HWRDS,PILOC,FLGMOD
D KILL,LFTT,MASK
D NWORD,BITO,PROCEDE
D QUAN,RELA,SYMBOL
D TEXO,SETFRM,RFTT
D WORD,XEC,HISTUF
D ZERO,OCON,ICON
D OSYM,VARRW,PSYM

;THIS TABLE DOES NOT HAVE ENTRIES FOR CHARS .GE. 140; THESE
; ARE DETECTED AS ERRORS NEAR L21:

;DESCRIPTION OF OP DECODER FOR DDT:
;
;         THE ENTIRE INSTRUCTION SET FOR THE PDP-6 CAN BE COMPACTED INTO
;A SPACE MUCH SMALLER THAN ONE REGISTER FOR EVERY SYMBOL.  THIS OCCURS
;BECAUSE OF THE MACHINE ORGANIZATION AND INSTRUCTION MNEMONICS CHOSEN
;FOR THE PDP-6.  FOR EXAMPLE, IF BITS (0-2) OF AN INSTRUCTION EQUAL
;101(2) THE INSTRUCTION IS A HALF WORD INSTRUCTION AND AN "H" MAY
;BE ASSUMED. "T" MAY BE ASSUMED FOR ALL TEST INSTRUCTIONS (WHICH
;BEGIN WITH 110(2).
;
;     	THE TABLE TBL IN DDT CONSISTS OF 9 BIT BYTES, 4 TO A WORD.
;THE NUMBERS IN THE BYTES HAVE THE FOLLOWING SIGNIFICANCE:
;0-37(8):	THIS IS A DISPATCH COMMAND FOR THE OP-DECODER INTERPRETER.
;	LET THE RIGHT MOST TWO BITS EQUAL N; LET THE NEXT 3 BITS
;	EQUAL P.
;
;	THE CONTENTS OF INST (INSTRUCTION) CONTAIN IN THE RIGHT
;	MOST NINE BITS THE BINARY FOR THE MACHINE INSTRUCTION.
;	P AND N REFER TO THE CONTENTS OF INST, AND THE OP DECODER
;	WILL PRODUCE AN ANSWER D GIVEN P, N, AND THE CONTENTS
;	OF INSTX N+1 GIVES THE NUMBER OF BITS IN INST; P GIVES THE
;	POSITION (FROM THE RIGHT EDGE) OF THE N+1 BITS.
;
;	EXAMPLE: P = 6
;	         N = 2
;
;;	C(INST) = .010 101 100(2)
;
;	THE RESULT = D = 010(2) = 2(8)
;
;	D IS USED AS A DISPATCH ON THE NEXT BYTES IN THE TABLE.
;	IF D = 5, 5 BYTES IN THE TABLE (DON'T COUNT THE BYTES WHICH
;	PRINT TEXT, 41-72(8)) ARE SKIPPED OVER AND THE 6TH BYTE RESUMES
;	THE INTERPRETATION.
;
;40(8)	THIS IS A STOP CODE; WHEN THIS IS REACHED INTERPRETATION
;	IS FINISHED.
;41(8)-72(8)      THE ALPHABET IS ENCODED INTO THIS RANGE.
;	        41- A
;	        42- B
;	        72- Z
;	        WHEN A BYTE IN THIS RANGE IS REACHED, ITS CORRESPONDING
;	        LETTER IS TYPED.
;
;73(8)-777(8)     THIS IS A TRANSFER BYTE.  IF THE BYTE IN THIS RANGE IS
;	        CONSIDERED TO BE A, TRANSFER INTERPRETATION TO THE A-73(8)RD
;	        BYTE IN THE TABLE.
;
;MACROS ASSEMBLE THE TABLE TBL:
; 1.   A NUMBER FOLLOWED BY ^ ASSEMBLES A DISPATCH BYTE.  THE FIRST
;      DIGIT IS THE POSITION; THE SECOND DIGIT IS THE SIZE.
; 2.   A POINT (.) ASSEMBLES A STOP CODE.
; 3.   A NAME FOLLOWED BY A SLASH ASSEMBLES A TRANSFER TO THE
;      SYMBOLICALLY NAMED BYTE.
; 4.   A STRING OF LETTERS TERMINATED BY A SPACE, COMMA, OR POINT,
;      ASSEMBLE INTO A STRING OF BYTES, EACH BYTE BEING ONE LETTER.
;
;EXAMPLE OF BINARY TO SYMBOLIC DECODING:
;      THE MACHINE CODE FOR JRST IS 254
;          INST    0  1  0  1  0  1  1  0  0
;      THE INTERPRETER STARTS WITH THE FIRST BYTE IN THE TABLE (63^).
;      THE RESULT OF APPLYING THIS TO C(INST) GIVES 2.  SKIPPING OVER
;      2 BYTES IN THE TABLE AND INTERPRETING THE THIRD RESULTS IN
;      HAK/ BEING INTERPRETED.  AT HAK:, THERE IS A 33^.  APPLYING
;      THIS TO C(INST) RESULTS IN 5 NON PRINTING BYTES BEING SKIPPED
;      OVER:
;          1.  MV/
;               MOV      PRINTING TEXT
;          2.  MO/
;          3.  ML/
;          4.  DV/
;          5.  SH/
;
;H1/ IS THE NEXT BYTE INTERPRETER.  AT H1: 03^ IS FOUND SO
;4 BYTES ARE SKIPPED OVER:
;              EXC      PRINTING TEXT
;          1.  S3/
;              BL       PRINTING TEXT
;              T        PRINTING TEXT
;          2.  .
;          3.  AO/
;          4.  AOB/
;          THE NEXT LETTERS JRS ARE TYPED OUT.  THEN T/ IS FOUND.  AT
;T; A T IS TYPED OUT; THEN A "." IS FOUND AND EVERYTHING STOPS.
;
;          THE TABLE IS ALSO USED GOING FROM SYMBOLIC TO BINARY BUT A
;	TREE SEARCH METHOD IS USED.
REPEAT 0,<

DEFINE REDEF (XX)<
DEFINE INFO (AA,BB)<
AA XX'BB>>

DEFINE BYT9 (L)<
XLIST
REDEF %
 ZZ==0
 ZZZ==0
 ZZM==1

 IRPC L,<
	Z=="L"
	IFE Z-":",<INFO <>,<==CLOC>
		IFNDEF FIR.,<FIR.==CLOC>
		IFGE CLOC+73-1000-FIR.,<PRINTX OPTABLE TOO LONG>
		Z==0>
	IFE Z-"/",<IF1 <OUTP 1>
		IF2,<INFO OUTP,+73-FIR.>
		Z==0>
 IFE Z-"^",<OUTP <ZZ&70/2+ZZ&7-1>
	Z==0>
 IFE <Z-",">*<Z-".">*<Z-40>,<IFN ZZZ,<
				REPEAT 5,<ZZ==ZZZ&77
					IFN ZZ,<OUTP ZZ>
					ZZZ==ZZZ/100>>
				IFE Z-".",<OUTP 40>
				Z==0>
 IFN Z,<INFO REDEF,L
	ZZ==ZZ*10+Z&7
	ZZZ==ZZZ+<Z-40>*ZZM
	ZZM==ZZM*100>
 IFE Z,<REDEF %
	ZZ==0
	ZZZ==0
	ZZM==1>>
LIST>

DEFINE OUTP (A)<
	BINRY==BINRY*400+BINRY*400+A
	BINC==BINC-1
	IFE BINC,<EXP BINRY
		BINRY==0
		BINC==4>
	CLOC==CLOC+1>
TBL:		;OPDECODER BYTE TABLE

BINRY==0
CLOC==0		;SET BYTE LOCATION COUNTER TO 0
BINC==4		;INIT BYTES/WORD COUNTER

BYT9 <63^UUO/FLO/HAK/ACCP/BOOLE/H HWT/T ACBM/>

;IO INSTRUCTIONS
BYT9 <21^BD/CON,11^OI/S,01^Z/O/>
BYT9 <BD:01^BLK,IO/DATA,IO:11^I/O/OI:01^O/I/>

;UUOS
BYT9 <UUO:51^.,32^U40/U50/U60/21^U703/11^USET/01^>
BYT9 <LOOKU,P/ENTE,R/USET:USET,01^I/O/>
BYT9 <U40:03^CAL/INI T/AUXCA L/CHANI O/FRMO P/..,CALL I/>
BYT9 <U60:21^U603/01^IN,BPUT/OUT,BPUT:11^BU,F:F.,PU,T/>
BYT9 <U603:01^U6062/STAT,11^O:O.,Z:Z.,U6062:11^S,U62/G,U62:ETST,S/>
;BYTE AND FLOATING INSTRUCTIONS

BYT9 <FLO:51^BYTE/F 32^ AD A/SB A/MP A/DV A:>
BYT9 <21^LMB/R,IMB/LMB:02^.,L:L.,M:M.,B:B.,BYTE:32^...,03^UF,PA/DF,N/>
BYT9 <FS C/IB P:P.,I LD/LD:LD B/I DP/DP:DP B/>

;FWT,FIXED POINT ARITH,MISC.

BYT9 <HAK:33^MV/MV:MOV MO/ML/DV/SH/H1/JP/>
BYT9 <21^ADD IMB/SU BIMB:B IMB:02^.,I:I.,M/B/MO:22^>
BYT9 <EIMS:E IMS/S IMS/N IMS/M IMS:02^.,I/M/S:S.,>
BYT9 <ML:21^I ML1/ML1:MUL IMB/DV:21^I DV1/DV1:>
BYT9 <DI DV2:V IMB/H1:03^EXC S3/BL T:T.,AO/AO:AOBJ,>
BYT9 <AOB/JRS T/JFC L/XC T/.AOB:01^P/N/>
BYT9 <JP:03^PU/PU:PUSH PUS/PO/PO:POP POP/JS,R:R.,>
BYT9 <JS P/JS PA:A.,JR PA/PUS:01^J:J..,POP:>
BYT9 <01^.,J/SH:02^A S2/ROT S1/L S2:S S3:H S1/JFF O/S1:21^.,C:C.,>

;ARITH COMP,SKIP,JUMP

BYT9 <ACCP:42^CA CA1/SJ/A JS/S JS:O 31^>
BYT9 <J COMP/S COMP/CA1:31^I COMP/M COMP/>
BYT9 <SJ:31^JUM PSJ/SKI PSJ:P COMP:>
BYT9 <03^.,L/E:E.,L E/PA/G E/N:N.,G.,>
;HALF WORDS

BYT9 <HWT:51^HW1/21^R HW2/L HW2:R HW3/HW1:>
BYT9 <21^L HW4/R HW4:L HW3:32^IMS/Z IMS/O IMS/EIMS/>

;TEST INSTRUCTIONS

BYT9 <ACBM:31^AC1/01^D AC2/S AC2/AC1:01^R AC2/L,>
BYT9 <AC2:42^N EAN/Z EAN/C EAN/O EAN:12^.,E/PA/N/>

;BOOLEAN

BYT9 <BOOLE:24^ST/AN:AND B2/AN/ST/AN/ST/>
BYT9 <X OR:OR B2/I OR/AN/EQ DV2/ST/OR/ST/OR/OR/>
BYT9 <ST:SET B2:24^Z IMB/IMB/CA:C TA/TM:M IMB/>
BYT9 <CM:C TM/TA:A IMB/IMB/IMB/CB:C BIMB/IMB/CA/>
BYT9 <CA/CM/CM/CB/O IMB/>

;MORE UUO'S
BYT9 <U50:03^OPE,N/TT,CAL:CAL L/...,RENAM,E/I,N/OU,T/>
BYT9 <U703:02^CLOS,E/RELEA,S/MTAP,E/UGET,F/>

REPEAT BINC,<BINRY==BINRY*400+BINRY*400>
IFN BINRY,<EXP BINRY>
>	;END OF REPEAT 0
IFN CMDFIL!FLDDT,<
CRASH:	SIXBIT .CRASH.		;CANONICAL NAME FOR CRASH
	SIXBIT .SAV.
	Z
	Z
CBUF:	BLOCK 3			;RING HEADERS
COMAND:	Z			;-1 IF COMMAND FILE ,0 IF NOT
NOEXT:	BLOCK 1
UNM:	BLOCK 2
>;END IFN CMDFIL!FLDDT
IFN FRMDDT!FLDDT,<
CRASHS:	Z			;-1 IF CRASH.SAV ON DISK ,0 IF PEEK AT MONITOR
IFN FLDDT,<
AC0:	BLOCK 20
AC17=AC0+17>;END IFN FLDDT
RSIDNT:	BLOCK 1000		;LOCS 0-777 ALWAYS IN CORE
CURENT:	BLOCK 4000		;WINDOW TO THE FILE ON DISK
RSAVE:	BLOCK 1			;INDEX OF THE CURRENT BLOCK. 0,1,...
RSILST:	IOWD 1000,RSIDNT
	Z
CURLST:	IOWD 4000,CURENT
	Z
HISIZ:	BLOCK 1
HRSAVE:	BLOCK 1
JSTFIL:	BLOCK 1
XPNTAB:	BLOCK	^D512+4/5	;5 PAGE BUFFERS, 512 POSSIBLE PAGES.
	XPNTBL==.-XPNTAB	;LENGTH
	-1			;END OF TABLE MARKER
XPNFLG:	BLOCK 1
XPNFLR:	BLOCK 1
XPNCNT:	BLOCK 1
XPNCOM:	IOWD 5000,RSIDNT
	Z
HIBLK:	BLOCK 2000
HICOM:	IOWD 2000,HIBLK
	Z
CODMOD:	0		;NON-ZERO IF LOOKING AT REAL CORE
PATCH:	BLOCK 200	;PLACE TO WRITE PROGRAMS
MAPWRD:	0		;DATA FOR PAGING
ACXSPT:	0		;FOR EXEC AC STACK POINTER
ACSPTR:	0		;POINTER TO SAVED ACS FOR ALT AC BLOCKS
MAP:	BLOCK 1000-160	;STORE MAP HERE
>
IFN FLDDT!XMOD!FRMDDT,<
USRSAV:	0
USRNOW:	0
FDPUSR:	0
>
SUBTTL	OP DECODER

DEFINE BYT9 (A) <IRP A,<
A>>

TOPNUM==700

IF1,<

DEFINE	.ADR	(A) <
%'A==	CLOC
FIR.==	CLOC
OVRNUM==TOPNUM-73+FIR.
DEFINE	.ADR	(B) <
IFGE CLOC+73-FIR.-TOPNUM,<%'B=OVRNUM
	OVRNUM==OVRNUM+1>
IFL CLOC+73-FIR.-TOPNUM,<%'B=CLOC>
IFGE <LASTB==%'B+73-FIR.>-1000,<PRINTX OPTABLE TOO LONG>>>

DEFINE	.TRA	<
CLOC==	CLOC+1 ;>

SYN	.TRA,	.DIS

DEFINE	.TXT	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>
CLOC==	CLOC+1>

>	;END OF IF1
IF2,<
	XLOC OVRTBL
	XLOC
	OVRNUM==TOPNUM-73+FIR.

DEFINE .ADR (A)
<IFGE CLOC+73-FIR.-TOPNUM,<%%Q==OVRNUM
	XLOC
	CLOC
	XLOC
	OVRNUM==OVRNUM+1>
IFL CLOC+73-FIR.-TOPNUM,<%%Q==CLOC>
IFN %'A-%%Q,<PRINTX PHASE ERR AT: A>>

DEFINE	.TRA	(A) <
OUTP	%'A+73-FIR.>

DEFINE	.DIS	(A) <
OUTP	A&70/2+A&7-1>

DEFINE	.TXT	(A) <
IFNB	<A>,	<IRPC A,<OUTP "A"-40>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<OUTP "A"-40>>
OUTP	40>

DEFINE OUTP (A)<
BINRY==	BINRY+<A>_<BINC==BINC-9>
IFE BINC, <
		+BINRY
BINRY==0
BINC==^D36 >
CLOC==CLOC+1 >

>
TBL:  ;OPDECODER BYTE TABLE

BINRY== 0
CLOC== 0 ;SET BYTE LOCATION COUNTER TO 0
BINC== ^D36 ;INIT BYTES/WORD COUNTER

;**********THE ARGUMENT FOR THE FOLLOWING "BYT9" MACRO
;**************TERMINATES AT THE NEXT COMMENT WITH: **************

BYT9 <

.DIS 63,.TRA UUO,.TRA FLO,.TRA HAK,.TRA ACCP,.TRA BOOLE
	.TXT H,.TRA HWT,.TXT T,.TRA ACBM

;IO INSTRUCTIONS

.DIS 21,.TRA BD,.TXT CON,.DIS 11,.TRA OI,.TXT S,.DIS 01,.TRA Z,.TRA O
.ADR BD,.DIS 01,.TXT BLK,.TRA IO,.TXT DATA,.ADR IO,.DIS 11,.TRA I,.TRA O
	.ADR OI,.DIS 01,.TRA O,.TRA I
;UUOS

.ADR UUO,.DIS 51,.END,.TXT,.DIS 32,.TRA U40,.TRA U50,.TRA U60
	.DIS 21,.TRA U703,.DIS 11,.TRA USET,.DIS 01
.TXT LOOKU,.TRA P,.TXT ENTE,.TRA R,.ADR USET,.TXT USET,.DIS 01,.TRA I,.TRA O
.ADR U40,.DIS 03,.TRA CAL,.TXT INI,.TRA T,.TXT AUXCA,.TRA L,.TXT CHANI,.TRA O,.TXT FRMO,.TRA P,.END,.END,.TXT CALL,.TRA I
.ADR U60,.DIS 21,.TRA U603,.DIS 01,.TXT IN,.TRA BPUT,.TXT OUT
	.ADR BPUT,.DIS 11,.TXT BU,.ADR F,.END F,.TXT,.TXT PU,.TRA T
.ADR U603,.DIS 01,.TRA U6062,.TXT STAT,.DIS 11,.ADR O,.END O,.TXT,.ADR Z,.END Z,.TXT
	.ADR U6062,.DIS 11,.TXT S,.TRA U62,.TXT G,.ADR U62,.TXT ETST,.TRA S

;BYTE AND FLOATING INSTRUCTIONS

.ADR FLO,.DIS 51,.TRA BYTE,.TXT F,.DIS 32,.TXT,.TXT AD,.TRA A,.TXT SB
	.TRA A,.TXT MP,.TRA A,.TXT DV,.ADR A
.DIS 21,.TRA LMB,.TXT R,.TRA IMB,.ADR LMB,.DIS 02,.END,.TXT
	.ADR L,.END L,.TXT,.ADR M,.END M,.TXT
.ADR B,.END B,.TXT,.ADR BYTE
	.DIS 32,.END,.TRA DFLT,.TRA DMOV,.TXT
	.DIS 03,.TXT UF,.TRA PA,.TXT DF,.TRA N
.TXT FS,.TRA C,.TXT IB,.ADR P,.END P,.TXT,.TXT I,.TRA LD
	.ADR LD,.TXT LD,.TRA B,.TXT I,.TRA DP,.ADR DP,.TXT DP,.TRA B
.ADR DFLT,.DIS 21,.TRA DFLT2,.END,.ADR DFLT2,.TXT DF
	.DIS 02,.END AD,.TXT S,.TRA B,.TXT M,.TRA P,.END DV
.ADR DMOV,.DIS 11,.TXT DMOV,.TRA DMOV2,.DIS 01,.TXT FIX,.TRA FIXR
	.DIS 21,.END,.TXT FLT,.TRA R,.ADR FIXR,.DIS 21
	.END,.TRA R,.ADR DMOV2,.DIS 01,.TXT E,.TRA DMOV3,.TXT N
	.ADR DMOV3,.DIS 21,.END,.TRA M

;FWT-FIXED POINT ARITH-MISC

.ADR HAK,.DIS 33,.TRA MV,.ADR MV,.TXT MOV,.TRA MO,.TRA ML,.TRA DV
	.TRA SH,.TRA H1,.TRA JP
.DIS 21,.TXT ADD,.TRA IMB,.TXT SU,.ADR BIMB,.TXT B,.ADR IMB,.DIS 02,.END,.TXT
	.ADR I,.END I,.TXT,.TRA M,.TRA B,.ADR MO,.DIS 22
.ADR EIMS,.TXT E,.TRA IMS,.TXT S,.TRA IMS,.TXT N,.TRA IMS,.TXT M
	.ADR IMS,.DIS 02,.END,.TXT,.TRA I,.TRA M,.ADR S,.END S,.TXT
.ADR ML,.DIS 21,.TXT I,.TRA ML1,.ADR ML1,.TXT MUL,.TRA IMB
	.ADR DV,.DIS 21,.TXT I,.TRA DV1
.ADR DV1,.TXT DI,.ADR DV2,.TXT V,.TRA IMB,.ADR H1,.DIS 03,.TXT EXC,.TRA S3,.TXT BL
	.ADR T,.END T,.TXT,.TRA AO,.ADR AO,.TXT AOBJ
.TRA AOB,.TXT JRS,.TRA T,.TXT JFC,.TRA L,.TXT XC,.TRA T,.TXT MA,.TRA P
	.ADR AOB,.DIS 01,.TRA P,.TRA N
.ADR JP,.DIS 03,.TRA PU,.ADR PU,.TXT PUSH,.TRA PUS,.TRA PO
	.ADR PO,.TXT POP,.TRA POP,.TXT JS,.ADR R,.END R,.TXT
.TXT JS,.TRA P,.TXT JS,.ADR PA,.END A,.TXT,.TXT JR,.TRA PA
	.ADR PUS,.DIS 01,.ADR J,.END J,.END,.TXT,.ADR POP
.DIS 01,.END,.TXT,.TRA J,.ADR SH,.DIS 02,.TXT A,.TRA S2,.TXT ROT,.TRA S1,.TXT L
	.ADR S2,.TXT S,.ADR S3,.TXT H,.TRA S1,.DIS 21,.TXT JFF,.TRA O,.END
	.ADR S1,.DIS 21,.END,.TXT,.ADR C,.END C,.TXT

;ARITH COMP-SKIP-JUMP

.ADR ACCP,.DIS 42,.TXT CA,.TRA CA1,.TRA SJ,.TXT A,.TRA JS,.TXT S
	.ADR JS,.TXT O,.DIS 31
.TXT J,.TRA COMP,.TXT S,.TRA COMP,.ADR CA1,.DIS 31,.TXT I,.TRA COMP,.TXT M,.TRA COMP
.ADR SJ,.DIS 31,.TXT JUM,.TRA PSJ,.TXT SKI,.ADR PSJ,.TXT P,.ADR COMP
.DIS 03,.END,.TXT,.TRA L,.ADR E,.END E,.TXT,.TXT L,.TRA E,.TRA PA,.TXT G,.TRA E
	.ADR N,.END N,.TXT,.END G,.TXT

;HALF WORDS

.ADR HWT,.DIS 51,.TRA HW1,.DIS 21,.TXT R,.TRA HW2,.TXT L,.ADR HW2,.TXT R,.TRA HW3
.ADR HW1,.DIS 21,.TXT L,.TRA HW4,.TXT R,.ADR HW4,.TXT L
	.ADR HW3,.DIS 32,.TRA IMS,.TXT Z,.TRA IMS,.TXT O,.TRA IMS,.TRA EIMS

;TEST INSTRUCTIONS

.ADR ACBM,.DIS 31,.TRA AC1,.DIS 01,.TXT D,.TRA AC2,.TXT S,.TRA AC2
	.ADR AC1,.DIS 01,.TXT R,.TRA AC2,.TXT L
.ADR AC2,.DIS 42,.TXT N,.TRA EAN,.TXT Z,.TRA EAN,.TXT C,.TRA EAN,.TXT O
	.ADR EAN,.DIS 12,.END,.TXT,.TRA E,.TRA PA,.TRA N

;BOOLEAN

.ADR BOOLE,.DIS 24,.TRA ST,.ADR AN,.TXT AND,.TRA B2,.TRA AN,.TRA ST,.TRA AN,.TRA ST
.TXT X,.ADR OR,.TXT OR,.TRA B2,.TXT I,.TRA OR,.TRA AN,.TXT EQ
	.TRA DV2,.TRA ST,.TRA OR,.TRA ST,.TRA OR,.TRA OR
.ADR ST,.TXT SET,.ADR B2,.DIS 24,.TXT Z,.TRA IMB,.TRA IMB
	.ADR CA,.TXT C,.TRA TA,.ADR TM,.TXT M,.TRA IMB
.ADR CM,.TXT C,.TRA TM,.ADR TA,.TXT A,.TRA IMB,.TRA IMB,.TRA IMB
	.ADR CB,.TXT C,.TRA BIMB,.TRA IMB,.TRA CA
.TRA CA,.TRA CM,.TRA CM,.TRA CB,.TXT O,.TRA IMB

;MORE UUO'S

.ADR U50,.DIS 03,.TXT OPE,.TRA N,.TXT TT,.ADR CAL,.TXT CAL,.TRA L,.END,.END,.END
	.TXT,.TXT RENAM,.TRA E,.TXT I,.TRA N,.TXT OU,.TRA T
.ADR U703,.DIS 02,.TXT CLOS,.TRA E,.TXT RELEA,.TRA S
	.TXT MTAP,.TRA E,.TXT UGET,.TRA F

;**********THIS TERMINATES THE "BYT9" MACRO ARGUMENT******
>

IF1,<	BLOCK	<CLOC+3>/4>
IF2,<	IFN BINC-^D36,<	+BINRY>>
OVRTBL:	BLOCK OVRNUM-TOPNUM+73-FIR.


IFNDEF CLOC.,<CLOC.==CLOC>
IFN CLOC.-CLOC,<PRINTX PHASE ERROR IN OPTABLE>

PNTR:	EXP INST	;POINTER TO BITS IN INST
INST:	0		;BINARY FOR INSTRUCTION
CHP:	0		;CHAR POINTER INTO TXT, TXT+1
TXT:	BLOCK 2		;STORE INPUT TEXT FOR OPEVAL
CHP6:	0
TXT6:	0
SAVPDL:	0		;SAVE PUSH DOWN LIST POINTER

BTAB:	POINT 9,TBL	;TABLE USED TO GET NEXT BYTE POINTER
	POINT 9,TBL,8	;FOR TRANSFER BYTE
	POINT 9,TBL,17
	POINT 9,TBL,26

OPEVAL:	MOVEI T,0		;EVALUATE FOR AN OP CODE
	IDPB T,CHP		;INSERT NULL IN TEXT FOR SYMBOL
	MOVEM P,SAVPDL
	TRZ F,OUTF
	LSH T,-33
OPTYP1:	MOVEM T,INST		;GET OPCODE INTO RIGHT 9 BITS
	MOVE T,[XWD 440700,TXT]
	MOVEM T,CHP		;FOR OPEVAL,SETUP POINTER TO INPUT TEXT
	TRZ F,ITF!TTCLF!CLLIF	;CLEAR INSTRUCTION TYPED FLAG
	CLEARB R,W1
	MOVE W2,BTAB
DC1:	ILDB T,W2		;GET NEXT BYTE IN TBL
	CAILE T,40
	CAIL T,73
	SOJGE R,DC1		;SKIP OVER # BYTES = C(R)
	JUMPG R,DC1		;SKIP OVER ALPHA TEXT WITHOUT COUNTING
	SUBI T,40
	JUMPE T,DECX		;TRANSFER ON ASTOP CODE
	JUMPG T,DC2
	DPB T,[XWD 340500,PNTR]	;SETUP R ON A DISPATCH BYTE
	TRZ T,-4
	AOS T
	DPB T,[XWD 300600,PNTR]
	TRNN F,OUTF
	JRST DC6		;FOR OPEVAL ONLY
	LDB R,PNTR		;GET # BYTES TO SKIP OVER
	JRST DC1

DC2:	HRREI T,-33(T)
	JUMPL T,DECT		;TYPE OUT A LETTER
	MOVEI W1,FIR.(T)		;BYTE IS A TRANSFER
	CAIL W1,TOPNUM-73+FIR.
	MOVE W1,OVRTBL-TOPNUM+73-FIR.(W1)
	IDIVI W1,4
	MOVE W2,BTAB(W2)	;CALCULATE POINTER TO NEXT BYTE
	ADDI W2,(W1)
	JRST DC1

DECT:	TRNE F,OUTF
	JRST DC8	;TYPE OUT A LETTER
	ILDB W1,CHP	;GET NEXT INPUT LETTER
	CAIE W1,133(T)	;COMPARE WITH ASSUMED NEXT LETTER
	JRST NOMAT	;DOESNT MATCH
	JRST DC1	;MATCHES, TRY NEXT

DECX:	TRNE F,OUTF	;STOP (CODE 40) HAS BEEN SEEN
	POPJ P,		;IF FOR OUTPUT, RETURN
	ILDB W1,CHP	;GET NEXT INPUT CHAR IF ANY
	JUMPE W1,DC7	;DOES # OF CHARS MATCH
NOMAT:	POP P,R		;NO, BACK UP AND TRY SOME MORE
	POP P,W2
	POP P,PNTR
	POP P,CHP
NOMAT1:	AOS R		;ASSUME NEXT NUMBER FOR BIN VALUE
	DPB R,PNTR	;STUFF INTO ANSWER
	LDB R,PNTR
	JUMPN R,DC6AA	;IF =0, BYTE WAS TOO BIG
	CAME P,SAVPDL
	JRST NOMAT	;NOT AT TOP LEVEL
IFE XMOD,<
IFN FLDDT,<SKIPN CODMOD		;RECOGNIZE TTCALL AND CALLI IN CODE MODE ONLY
	POPJ P,>
	MOVE T,TXT6		;GET THE SYMBOL
	HRLZI W1,-MAXTTC-1
	CAMN T,TTCALS(W1)	;LOOK FOR A TTCALL
	JRST OPVTTC		;FOUND ONE
	AOBJN W1,.-2
	MOVE W1,[NEGCLI-POSCLI-1,,NEGCLI]
	CAMN T,CALLIS(W1)	;LOOK FOR A CALLI
	JRST OPVCLI		;FOUND ONE
	AOBJN W1,.-2>
	POPJ P,			;REALLY IS UNDEFINED

OPVTTC:	LSH W1,5
	HRLZI T,<(TTCALL)>(W1)	;SET UP TTCALL N,
	JRST CPOPJ1

OPVCLI:	HRLZI T,(CALLI)
	HRR T,W1		;SET UP CALLI N
	JRST CPOPJ1

DC6:	MOVEI R,0	;ASSUME 0 FOR INITIAL BINARY VALUE
	DPB R,PNTR
DC6AA:	CAMN P,SAVPDL
	JRST DC6BB
	LDB T,-2(P)	;OLD VALUE OF PNTR
	CAME T,(P)
	JRST NOMAT1
DC6BB:	PUSH P,CHP
	PUSH P,PNTR
	PUSH P,W2
	PUSH P,R
	JRST DC1
DC7:	MOVE P,SAVPDL		;RESTORE PUSH DOWN POINTER
	MOVE T,INST
	LSH T,33		;PUSH BINARY INTO POSITION FOR OPEVAL
	LDB R,[POINT 3,T,8]
	TLC T,700000
	TLCN T,700000
	DPB R,[POINT 10,T,12]	;ONLY DONE FOR IO INSTRUCTIONS
	JRST CPOPJ1		;SYMBOL FOUND, SKIP RETURN

DC8:	TRO F,ITF		;SET INSTRUCTION TYPED FLAG
	MOVEI T,133(T)
	PUSHJ P,TOUT		;OUTPUT A LETTER
	CLEARM SPSAV		;SO $D WONT TRY TO DELETE OP CODES
	JRST DC1

OPTYPE:	TRO F,OUTF
	LSH T,-33		;GET OPCODE
	CAIN T,47
	JRST OPTCLI		;IT'S A CALLI
	CAIE T,51
	JRST OPTYP1		;IT'S NOTHING AT ALL
	LDB W1,[POINT 4,LWT,12]	;IT'S A TTCALL, GET AC
	CAILE W1,MAXTTC
	JRST OPTYP1		;TOO MUCH
	MOVE W1,TTCALS(W1)	;OK, GET NAME
	TRO F,TTCLF!ITF
OPTYP6:	SETZM SPSAV
OPTYPX:	MOVEI T,0
	LSHC T,6
	JUMPE T,CPOPJ
	ADDI T,40		;TYPE IT OUT
	PUSHJ P,TOUT
	JRST OPTYPX

OPTCLI:	LDB W1,[POINT 5,LWT,17]
	JUMPN W1,OPTYP1		;INDIRECT OR INDEXED
	HRRE W1,LWT		;GET CALLI NUMBER
	CAML W1,[NEGCLI]
	CAILE W1,POSCLI
	JRST OPTYP1		;OUT OF RANGE
	MOVE W1,CALLIS(W1)	;OK
	JUMPE W1,OPTYP1		;IT'S ZERO, FORGET IT
	TRO F,CLLIF!ITF
	JRST OPTYP6
TTCALS:	SIXBIT/INCHRW/	;0
	SIXBIT/OUTCHR/	;1
	SIXBIT/INCHRS/	;2
	SIXBIT/OUTSTR/	;3
	SIXBIT/INCHWL/	;4
	SIXBIT/INCHSL/	;5
	SIXBIT/GETLCH/	;6
	SIXBIT/SETLCH/	;7
	SIXBIT/RESCAN/	;10
	SIXBIT/CLRBFI/	;11
	SIXBIT/CLRBFO/	;12
	SIXBIT/SKPINC/	;13
	SIXBIT/SKPINL/	;14
	SIXBIT/IONEOU/	;15
	SIXBIT /OUTCHI/	;16
	SIXBIT /OUTPTR/	;17
MAXTTC==.-TTCALS-1

CALLIN:
	SIXBIT /SETSTV/ ;-137 SET START VECTOR
	SIXBIT /NPEEK/ ;-136 PEEK WITH ERROR RETURN
	SIXBIT /RETACH/ ;-135 MOVE A TTY
	SIXBIT /EVITC/ ;-134 CAUSE NTQ SOFT. INT.
	SIXBIT /PGRSTS/ ;-133 GET REF BIT FAULT INFO
	SIXBIT /PGISTS/ ;-132 GET ILL MEM REF/ADDR BREAK FAULT INFO
	SIXBIT /SETABK/ ;-131 SET ADDRESS BREAK
	SIXBIT /LOGOFF/ ;-130 RUN ALT. LOGOUT PROGRAM
	SIXBIT /SETALP/ ;-127 SET ALT. LOGOUT PROGRAM
	SIXBIT /SETOTF/ ;-126 SET "OTHER" FRAME UUO FOR VUUOS
	SIXBIT /CONT/ ;-125 PUT TERMINAL IN USER MODE
	SIXBIT /PUTROY/ ;-124 PUT ROYALTY STREAM RECORD
	SIXBIT /BLTPAG/ ;-123 BLT DATA TO A LOCKED PAGE
	SIXBIT /PIDSET/ ;-122 SET PROGRAM'S PID
	0		;-121
	SIXBIT /BITPOK/ ;-120 POKE WITH MASK
	SIXBIT /RDHIST/ ;-117 READ SNOOP HISTOGRAM
	SIXBIT /SNOOPU/ ;-116 START/STOP SNOOP HISTOGRAM
	SIXBIT /POLPRT/ ;-115 POLL PORTS
	SIXBIT /CLBADD/ ;-114 ADD SELF TO CLUB.
	SIXBIT /CLBLEV/ ;-113 REMOVE SELF FROM CLUB.
	SIXBIT /CLBINW/ ;-112 GET CLB INTRLK (WAIT).
	SIXBIT /CLBINI/ ;-111 GET CLB INTRLK (IMMED).
	SIXBIT /CLBRLI/ ;-110 RELEASE CLB INTRLK.
	SIXBIT /CLBMEM/ ;-107 GET INFO ABOUT CLB MBR.
	SIXBIT /CLBSTS/ ;-106 GET STATUS OF CLB MBR.
	SIXBIT /CLBWAK/ ;-105 WAKE JOB IN SAME CLB.
	SIXBIT /CLBHNG/ ;-104 HANG JOB IN SAME CLUB.
	SIXBIT /VPGFIL/ ;-103 GET FILENAME ETC FOR VP
	SIXBIT /VDSKPT/ ;-102 GET DISK POINTER FOR VP
	SIXBIT /PGFSTS/	;-101
	SIXBIT /PERSTS/	;-100
	SIXBIT /VFSTAT/	;-77
	SIXBIT /VALPAG/	;-76
	SIXBIT /PREREF/	;-75
	SIXBIT /WSCTL/	;-74
	SIXBIT /REFBIT/	;-73
	SIXBIT /PERSET/	;-72
	SIXBIT /VPGSTS/	;-71
	SIXBIT /VPROT/	;-70
	SIXBIT /VCREAT/	;-67
	SIXBIT /VCLEAR/	;-66
	SIXBIT /VREMOV/	;-65
	SIXBIT /VREPLC/	;-64
	SIXBIT /LSAUUO/	;-63
	SIXBIT /PUTSAR/	;-62
	SIXBIT /CHPJC/	;-61
	SIXBIT /XCHARG/	;-60
	SIXBIT /SETRFC/	;-57
	SIXBIT /TYMCHG/	;-56
	SIXBIT /DATUUO/	;-55
	SIXBIT /DDT620/	;-54
	SIXBIT /VALRMT/	;-53
	SIXBIT /INTRMT/	;-52
	SIXBIT /IDLRMT/	;-51
	SIXBIT /ZAPRMT/	;-50
	SIXBIT /CRERMT/	;-47
	SIXBIT /AUXRED/	;-46
	SIXBIT /ZAPCIR/	;-45
	SIXBIT /CREAUX/	;-44
	SIXBIT /REDPIP/	;-43
	SIXBIT /TINASS/	;-42
	SIXBIT /SETTR2/	;-41
	SIXBIT /SETTR1/	;-40
	SIXBIT /SETTIM/	;-37
	SIXBIT /INTASS/	;-36
	SIXBIT /INTACT/	;-35
	SIXBIT /INTENB/	;-34
	SIXBIT /INTADR/	;-33
	SIXBIT /HANG/	;-32
	SIXBIT /CHKLIC/	;-31
	SIXBIT /LEVDEF/	;-30
	SIXBIT /MOVBUF/	;-27
	SIXBIT /SETMOD/	;-26
	SIXBIT /RUNSEG/	;-25
	SIXBIT /SYSDVF/	;-24
	SIXBIT/DISMIS/	;-23
	SIXBIT/DSKCLR/	;-22
	SIXBIT/SETJAL/	;-21
	SIXBIT/ONEJOB/	;-20
	SIXBIT/SETMAL/	;-17
	SIXBIT/GETTMC/	;-16
	SIXBIT/SETTMC/	;-15
	SIXBIT/REDNXT/	;-14
	SIXBIT/WAITCH/	;-13
	SIXBIT/POKE/	;-12
	SIXBIT/SETPRV/	;-11
	SIXBIT/SETLIC/	;-10
	SIXBIT/SETE/	;-7
	SIXBIT/ATTACH/	;-6
	0		;-5
	0		;-4
	0		;-3
	0		;-2
	SIXBIT/LIGHTS/	;-1
CALLIS:	SIXBIT/RESET/	;0
	SIXBIT/DDTIN/	;1
	SIXBIT/SETDDT/	;2
	SIXBIT/DDTOUT/	;3
	SIXBIT/DEVCHR/	;4
	SIXBIT/DDTGT/	;5
	SIXBIT/GETCHR/	;6
	SIXBIT/DDTRL/	;7
	SIXBIT/WAIT/	;10
	SIXBIT/CORE/	;11
	SIXBIT/EXIT/	;12
	SIXBIT/UTPCLR/	;13
	SIXBIT/DATE/	;14
	SIXBIT/LOGIN/	;15
	SIXBIT/APRENB/	;16
	SIXBIT/LOGOUT/	;17
	SIXBIT/SWITCH/	;20
	SIXBIT/REASSI/	;21
	SIXBIT/TIMER/	;22
	SIXBIT/MSTIME/	;23
	SIXBIT/GETPPN/	;24
	SIXBIT/TRPSET/	;25
	SIXBIT/TRPJEN/	;26
	SIXBIT/RUNTIM/	;27
	SIXBIT/PJOB/	;30
	SIXBIT/SLEEP/	;31
	SIXBIT/SETPOV/	;32
	SIXBIT/PEEK/	;33
	SIXBIT/GETLIN/	;34
	SIXBIT/RUN/	;35
	SIXBIT/SETUWP/	;36
	SIXBIT/REMAP/	;37
	SIXBIT/GETSEG/	;40
	SIXBIT/GETTAB/	;41
	SIXBIT/SPY/	;42
	SIXBIT/SETNAM/	;43
	SIXBIT/TMPCOR/	;44
	SIXBIT/DSKCHR/	;45
	SIXBIT/SYSSTR/	;46
	SIXBIT/JOBSTR/	;47
	SIXBIT/STRUUO/	;50
	SIXBIT/SYSPHY/	;51
	SIXBIT/FRECHN/	;52
	SIXBIT/DEVTYP/	;53
	SIXBIT/DEVSTS/	;54
	SIXBIT/DEVPPN/	;55
	SIXBIT/SEEK/	;56
	SIXBIT/RTTRP/	;57
	SIXBIT/LOCK/	;60
	SIXBIT/JOBSTS/	;61
	SIXBIT/LOCATE/	;62
	SIXBIT/WHERE/	;63
	SIXBIT/DEVNAM/	;64
	SIXBIT/CTLJOB/	;65
	SIXBIT/GOBSTR/	;66
	0		;67
	0		;70
	SIXBIT/HPQ/	;71
	SIXBIT/HIBER/	;72
	SIXBIT/WAKE/	;73
	SIXBIT/CHGPPN/	;74
	SIXBIT/SETUUO/	;75
	SIXBIT/DEVGEN/	;76
	SIXBIT/OTHUSR/	;77
	SIXBIT/CHKACC/	;100
	SIXBIT/DEVSIZ/	;101
CALLIP:

POSCLI==CALLIP-CALLIS-1
NEGCLI==CALLIN-CALLIS
LIT

PS:	BLOCK LPDL

;REDEFINE IO CODES HERE ON PASS2 SO DDT CAN USE REGULAR ONES.

IFN XMOD,< IOGLOB>

DDTEND:		;ONLY STARTING ADDRESS FOR FILDDT
		;NO START ADDRESS FOR EXEC OR USER DDT
		;BECAUSE MONITOR IS LOADED WITH BOTH EXEC AND USER DDTS
		;BUT STILL WANTS TO BE STARTED AT ITS OWN START ADDRESS
		;USER DDT IS LOADED LAST. - T.H.
IFN FLDDT!FRMDDT,<END DDT>

END
    t >r