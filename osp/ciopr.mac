TITLE CIOPR UUO TO FIDDLE WITH COMMUNICATIONS INTERFACE.

; **jms4480** KMC SUPPORT FOR NODLOD.SAI ADDED 4-4-1980 /JMS
; **gl 7180** PROTECTIVE CODE FOR UNEXPECTED INTERRUPTS
; **lb 7780** SET/CLEAR MANUAL DOWN FLAG WHEN LOADING DRS


					; Default definition to JFCL
	DEFINE KMCMDN,<JFCL 0>
	DEFINE KMCMUP,<JFCL 0>

IFKMC<					; If this is for a KMC system
  IFDEF KMCVEC,<			;   and the KMC is defined
    External KMCSMN,KMCCMN
	DEFINE KMCMDN,<PUSHJ P,KMCSMN>
	DEFINE KMCMUP,<PUSHJ P,KMCCMN>>>

IFCPU (KS),<	;ENDS ON LAST PAGE.
;DR11C hardware parameters.

DEFINE IOREG(REGISTERNAME,OFFSET,BITNAMES,MSB)
<BIT==100000
IFNB <MSB>,<BIT==MSB>
DR'REGISTERNAME==OFFSET
IRP BITNAMES,<REGISTERNAME'BITNAMES==BIT
BIT==BIT/2
>>

IOREG(CSR,0,<RB,,,,,,,,RA,IEA,IEB,,,,1,0>)
 DRFN==CSR0   ;Data ready for node (set by KS10 after loading OB).
 ODOFS==1	;High vector = dispatch when node's read OB.
 KRFMD==CSR1  ;KS10 ready for more data (set by KS10 after reading IB).
 IROFS==0	;Low vector = dispatch when node's written IB.
IOREG(OB,2)
IOREG(IB,4)

;Macro to make a DR11c known to the system.
;Since the concatenation operator can't be used outside of
; macro definitions, we have to use the SETxxx macros.

DEFINE SETBASEADDRESS(N,ADDRESS) <
DR'N'BA==ADDRESS
>

DEFINE SETVECTORADDRESS(N,ADDRESS) <
DR'N'VL==ADDRESS
>

DEFINE DR11C(BASEADDRESS,VECTORBASE) <
SETBASEADR(\NUMDR,BASEADDRESS)
SETVECTORADDRESS(\NUMDR,VECTORADDRESS)
IF1,<BLOCK 8>
IF2,<DRINTH(\NUMDR)>
NUMDR==NUMDR+1
>

NUMDR==0

;macro to protect against & count unexpected dr interrupts. /GL 7-1-80
;  and to move a JSR DX#INT into EPT+base+vec.
DEFINE DRXJSR(N,UBA,VEC)<
	JRST	DY'N'CNT+1
DX'N'INT: EXP 0
	AOS DX'N'CNT
	JEN @DX'N'INT
DX'N'CNT: EXP 0
DY'N'INT: EXP 0
	AOS DY'N'CNT
	JEN @DY'N'INT
DY'N'CNT: EXP 0
	MOVE	T2,EPT+100+UBA	;T2/ BASE VECTOR ADDRESS
	MOVE	T1,[JSR DX'N'INT]
	MOVEM	T1,VEC'/4(T2)
	HRRI	T1,DY'N'INT
	MOVEM	T1,VEC'/4+1(T2)
>;end_define drxjsr

;Insert definitions here.
DR11C(767770,300/4)
DR11C(767760,310/4)		; **jms4480**
DR11C(767750,320/4)		; **jms4480**
DR11C(767740,330/4)		; **jms4480**

;Macro to generate DR11C interrupt handlers for DR11C number N.
DEFINE DRINTH(N) <
DR'N'IRF:0
DR'N'IR:0
	SETOM DR'N'IRF
	JEN @DR'N'IR
DR'N'ODF:-1
DR'N'OD:0
	SETOM DR'N'ODF
	JEN @DR'N'OD
>;DEFINE DRINTH

DRIVTB:
DEFINE DRVECL(N) <
	DR'N'VL
>

IF1,<BLOCK NUMDR>
IF2,<
ZZ==0
REPEAT NUMDR,<
	DRVECL(\ZZ)
ZZ==ZZ+1
>>

DRFLTB:
DEFINE DRFLAG(N) <
	DR'N'IRF,,DR'N'ODF
>
IF1,<BLOCK NUMDR>
IF2,<
ZZ==0
REPEAT NUMDR,<
	DRFLAG(\ZZ)
ZZ==ZZ+1
>>

DRBATB:
DEFINE DRBADR(N) <
	3,,DR'N'BA
>
IF1,<BLOCK NUMDR>
IF2,<
ZZ==0
REPEAT NUMDR,<
	DRBADR(\ZZ)
ZZ==ZZ+1
>>
CIOPR:: UMOVE T1,(W)		;FUNCTION,,ADR OF ARG BLOCK
	HLRZ T2,T1		;T2:=FUNCTION CODE
	CAILE T2,DLFTL-1	;IN RANGE?
	 JRST [	SETO T1,
		JRST DLEE]
	XCT DLFT(T2)		;YES, PERFORM FUNCTION.
	 AOSA (P)
DLEE:	  UMOVEM T1,(W)		;ERROR CODE FOR USER.
	POPJ P,

;FUNCTION HANDLERS ARE PASSED ADR OF ARG BLOCK IN T1.RH.
;SINGLE RETURN IF FUNCTION EXECUTED NORMALLY.
;ON ERROR, SKIP RETURN WITH ERROR CODE IN T1.
DLFT:	PUSHJ P,DLSCI	;SELECT COMMUNICATIONS INTERFACE.
	PUSHJ P,DLSEDR	;PREPARE DR11C FOR DATA.
	PUSHJ P,DLWDR	;WRITE WORD TO DR11C.
	PUSHJ P,DLRDR	;READ WORD FROM DR11C.
	PUSHJ P,DLDDR	;RELEASE DR11C TO KMC & NEXILIS NODE.
	PUSHJ P,DLKMCD	;GIVES ERROR RETURN IF KMCDO IS 0
DLFTL==.-DLFT

DLKMCD:	SKIPN	KMCDO
	  AOS	(P)
	POPJ	P,

;DLSCI FUNCTION: SELECT COMMUNICATIONS INTERFACE.
; ARG 0: INTERFACE TYPE: 0 - CTYSIM, 1 - DZKON, 2 - TYMBASE
; NODE.
; **jms4480** THIS FUNCTION DOES NOT ALLOW  FOR MULTIPLE
; **jms4480** DR'S (ALSO DR0 MUST BE USED). TO USE MORE THAN
; **jms4480** 1 DR, THE KMC IS REQUIRED IN WHICH CASE THE (KMC)
; **jms4480** INTERFACE SHOULD BE CLEARED FROM USER LEVEL.
DLSCI:	PUSHJ P,DLREI		;REMOVE EXISTING INTERFACES.
	UHRRZ T2,(T1)		;GET INTERFACE TYPE.
	CAILE T2,3
	 JRST DLE0		;ILLEGAL INTERFACE TYPE.
	JRST @.+1(T2)
	DLICTY
	DLIDZ
	DLINN
	DLIDR
;	DLREI

;DLREI.  REMOVE LINKS BETWEEN DZKON, CTYSIM AND SYSTEM.
DLREI:	SKIPE CTYDO
	 JFCL	;**D*	 PUSHJ P,DLRCTY
	SKIPE DZDO
	 PUSHJ P,DLRDZ
	SKIPE DRDO
	 PUSHJ P,DLRDRI
	POPJ P,

EXTERNAL CTYDO,CTYSET,CH6LK,CH6KST,CH7LK,NOWIN
EXTERNAL DZDO,DZINI,DZREM,PERINT,CONINT,DZPINT
EXTERNAL DRDO,DRINI,CLKDR
EXTERNAL KMCDO
EXTERNAL CH6,CH7,EPT,CPOPJ1

DLRDRI:	MOVEI T2,0
	MOVE T3,DRBATB		; **jms4480** ONLY DR0 SUPPORTED
				; **jms4480** AT THIS LEVEL.
	WRIO T2,DRCSR(T3)
	MOVEI T3,CH7
	MOVEI T2,CLKDR
	WRPI LI.PIF
	PUSHJ P,DLUIR
	 STOPCD
	WRPI LI.PIN
	POPJ P,

DLRCTY:	MOVEI T3,CH7
	MOVEI T2,CH7LK
	WRPI LI.PIF
	PUSHJ P,DLUIR
	 STOPCD
	MOVEI T3,CH6
	MOVEI T2,CH6LK
	PUSHJ P,DLUIR
	 STOPCD
	MOVEI T3,CH6
	MOVEI T2,CH6KST
	PUSHJ P,DLUIR
	 STOPCD
	SETZM CTYDO
	WRPI LI.PIN
	POPJ P,

DLRDZ:	WRPI LI.PIF
	PUSHJ P,DZREM		;TURN OFF DZ11S.
	MOVEI T3,CH7
	MOVEI T2,DZPINT
	PUSHJ P,DLUIR
	 STOPCD
	MOVEI T3,CH6
	MOVEI T2,PERINT
	PUSHJ P,DLUIR
	 STOPCD
	MOVEI T3,CH6
	MOVEI T2,CONINT
	PUSHJ P,DLUIR
	 STOPCD
	SETZM DZDO
	WRPI LI.PIN
	POPJ P,

;DLUIR.  UNLINK INTERRUPT ROUTINE WHOSE ADDRESS IS IN
; T2 FROM CHAIN ON CHANNEL IN T3.
;SINGLE RETURN IF COULDN'T FIND THE ROUTINE.  OTHERWISE
; SKIP AFTER UNLINKING IT.
DLUIR:	SKIPA P2,T3
DLUIR0:	 SKIPA T3,T4		;PREVIOUS:=CURRENT
	  HRRZI T4,(T3)		;T3:=PREVIOUS
	HRRZ T4,1(T4)		;T4:=CURRENT
	CAIN T4,(P2)		;LOOPED AROUND?
	 POPJ P,		;YEP, DIDN'T FIND IT.
	CAIE T4,(T2)
	 JRST DLUIR0
DLUIR1:	MOVE T4,1(T4)		;PREVIOUS.NEXT:=CURRENT.NEXT.
	MOVEM T4,1(T3)
	JRST CPOPJ1

;INSTALL DR11C INTERFACE TO NEXILIS NODE.
DLIDR:	WRPI LI.PIF
	SETOM DRDO
	PUSHJ P,DRINI
	WRPI LI.PIN
	POPJ P,

;INSTALL CTY INTERFACE
DLICTY:	WRPI LI.PIF
	SETOM CTYDO
	SETOM NOWIN		;SAY PORT LOGGED IN.
	PUSHJ P,CTYSET
	WRPI LI.PIN
	POPJ P,

;INSTALL DZ-11 DRIVER INTERFACE.
DLIDZ:	WRPI LI.PIF
	SETOM DZDO
	PUSHJ P,DZINI
	WRPI LI.PIN
	POPJ P,

;INSTALL NEXILIS NODE INTERFACE.  DOES NOTHING.
DLINN:	POPJ P,

;DLWDR FUNCTION: WRITE WORD TO SELECTED DR11C.
; ARG 0: DR11C#,,16 BIT WORD TO SEND
DLWDR:	PUSHJ P,DLSDR		;GET DR11C BASE ADDRESS.
	 JRST CPOPJ1		;ERROR.
	HRRZ T4,DRFLTB(T2)	;SEE IF PREVIOUS OUTPUT TAKEN.
	SKIPN (T4)
	 JSP T1,DLWAIT
	WRPI LI.PIF
	SETZM (T4)		;CLEAR TAKEN FLAG.
	WRIO T3,DROB(P1)	;SEND WORD
	MOVEI T3,DRFN
	BCIO T3,DRCSR(P1)
	BSIO T3,DRCSR(P1)	;IR INT FOR OTHER SIDE
	WRPI LI.PIN
	POPJ P,

;DLRDR FUNCTION: READ WORD FROM SELECTED DR11C.
; ARG 0: DR11C #,,ADR TO RECEIVE WORD READ.
DLRDR:	PUSHJ P,DLSDR		;GET DR11C BASE ADDRESS.
	 JRST CPOPJ1		;ERROR.
	HLRZ T4,DRFLTB(T2)
	SKIPN (T4)
	 JSP T1,DLWAIT
	WRPI LI.PIF
	SETZM (T4)		;CLEAR FLAG.
	RDIO T4,DRIB(P1)	;GET WORD
	UMOVEM T4,(T3)		;GIVE IT TO USER
	MOVEI T4,KRFMD
	BCIO T4,DRCSR(P1)
	BSIO T4,DRCSR(P1)
	WRPI LI.PIN
	POPJ P,

;DLSDR FUNCTION: SELECT DR11C FOR USE BY THE -20.
; ARG 0: DR11C #,,0
DLSEDR:	PUSHJ P,DLSDR		;GET HANDLES ON DR11C
	 JRST CPOPJ1		;ERROR.
	MOVE T1,T2		;SET UP T1 FOR SETTING MANUAL DOWN FLAG
	SKIPE KMCDO		;DONT SET IF NO KMC
	  KMCMDN		;SET DR MANUALLY DOWN
	HRRZ T4,EPT+103		;SETUP INTERRUPT VECTORS.
	ADD T4,DRIVTB(T2)
	HLRZ T1,DRFLTB(T2)
	ADD T1,[JSR 1]
	MOVEM T1,IROFS(T4)
	HRRZ T1,DRFLTB(T2)
	ADD T1,[JSR 1]
	MOVEM T1,ODOFS(T4)
	MOVEI T1,CSRIEA+CSRIEB	;ENABLE BOTH INTERRUPTS
	WRIO T1,DRCSR(P1)
	MOVEI T1,^D1000		;GIVE IT A CHANCE TO INTERRUPT
	SOJG T1,.		;ASSUME NO INT PENDING AFTER THIS.
	HLRZ T4,DRFLTB(T2)	;CLEAR INPUT READY FLAG
	SETZM (T4)
	HRRZ T4,DRFLTB(T2)	;SET DR11C READY FOR OUR OUTPUT FLAG
	SETOM (T4)
	POPJ P,

;DLDDR FUNCTION.  DESELECT DR11C.
; ARG 0: DR11C #,,0
DLDDR:	PUSHJ P,DLSDR		;GET HANDLES ON DR11C
	 JRST CPOPJ1		;ERROR.
	HRRZ T4,DRFLTB(T2)	;MAKE SURE LAST OUTPUT TAKEN.
	MOVEI P2,-1		;SET COUNT OF 777777
DLDDR1:	SKIPN (T4)		;CHECK FOR DATA ACCEPTED
	 SOJG P2,DLDDR1		;KEEP TRYING
	MOVEI T1,0		;DISABLE INTERRUPTS
	WRIO T1,DRCSR(P1)
	SKIPN (T4)
	 JSP T1,DLWAIT
	MOVE T1,T2		
	SKIPE	CTYDO
	  POPJ	P,		;IF RUNNING FORM CONSOLE QUIT NOW.
	SKIPN KMCDO		;DONT REINSTALL DR DRIVER IF KMC ACTIVE
	 PUSHJ P,DLIDR		;REINSTALL DR11C DRIVER
	SKIPE KMCDO		;DO CLEAR MANUAL DOWN FLAG IF KMC ACTIVE
	 KMCMUP			;"MANUALLY UP"
	POPJ P,			;WITH OR WITHOUT KMC
	POPJ P,

;DLSDR.  LOAD P1 WITH BASE ADDRESS OF DR11C SPECIFIED BY USER.
; IN ARG 0.  SKIP IF LEGAL DR11C, SINGLE RETURN OTHERWISE.
; T3.RH HAS ARG0.RH.  T2 HAS DR11C NUMBER.
DLSDR:	UMOVE T3,(T1)
	HLRZ T2,T3		;DR11C NUMBER
	CAILE T2,NUMDR-1
	 JRST DLE0		;ILLEGAL DR11C NUMBER.
	MOVE P1,DRBATB(T2)	;T2:=DR11C BASE ADDRESS.
	JRST CPOPJ1

;DLWAIT.  WAIT UNTIL PREDICATE TRUE (SKIPS).  PUT PREDICATE
; BEFORE JSP T1,DLWAIT.  IF PREDICATE FAILS, SLEEPS FOR
; A WHILE, THEN TRIES AGAIN.  UP TO 100 TRIES ARE ALLOWED.
DLWAIT:	MOVEI P2,-1
DLWT1:	MOVEI P3,2		;RESCHEDULE
;	SLEEP P3,	;**D* REMOVED ??
	XCT -2(T1)		;EXECUTE TEST INSTRUCTION
	 SOJG P2,DLWT1		;RE EXECUTE LOOP IF TEST FAILED
	JUMPE P2,DLE1		;GO HANDLE ERROR IF P2 WENT TO ZERO
	JRST (T1)		;TEST SUCCEEDED-  RETURN TO CALLER

;ROUTINES FOR RETURNING ERROR CODES.
DLE0:	JSP T1,DLERR
DLE1:	JSP T1,DLERR
DLE2:	JSP T1,DLERR
DLERR:	HRRZI T1,-DLE0+1(T1)
	JRST CPOPJ1OUTINE TO SETUP EPT FOR DR INTERRUPT PROTECTION. /GL 7-1-80
DRPROT::	;DESTORYS T1
	DRXJSR(1,3,300)		;DR#,UBA#,11VECTOR
	DRXJSR(2,3,310)
	DRXJSR(3,3,320)
	DRXJSR(4,3,330)
	POPJ P,

>;END IFCPU (KS) STARTING PAGE 1.
IFNCPU (KS),<
IFNCPU (<KS,F3>),<
	CIOPR::POPJ P,
>;IFNCPU(KS,F3).END

IFCPU (F3),<

EXTERNAL CPOPJ,CPOPJ1

CIOPR::
	UMOVE T1,(W)	;FUNCTION,,ADR OF ARG BLOCK
	HLRZ T2,T1		;T2:=FUNCTION CODE
	CAILE T2,DLFTL-1	;IN RANGE?
	 JRST [	SETO T1,
		JRST DLEE]
	XCT DLFT(T2)		;YES, PERFORM FUNCTION.
	 AOSA (P)
DLEE:	  UMOVEM T1,(W)		;ERROR CODE FOR USER.
	POPJ P,
;FUNCTION HANDLERS ARE PASSED ADR OF ARG BLOCK IN T1.RH.
;SINGLE RETURN IF FUNCTION EXECUTED NORMALLY.
;ON ERROR, SKIP RETURN WITH ERROR CODE IN T1.
DLFT:	PUSHJ P,DLSCI	;SELECT COMMUNICATIONS INTERFACE.
	PUSHJ P,DLSEDR	;PREPARE DR11C FOR DATA.
	PUSHJ P,DLWDR	;WRITE WORD TO DR11C.
	PUSHJ P,DLRDR	;READ WORD FROM DR11C.
	PUSHJ P,DLDDR	;RELEASE DR11C TO KMC & NEXILIS NODE.
	PUSHJ P,DLKMCD	;GIVES ERROR RETURN IF KMCDO IS 0
DLFTL==.-DLFT

;ERROR CODE RETURNS
ERRET0:	JSP T1,ERRETN	;ERROR RETURN WITH T1/ ERROR CODE
ERRET1:	JSP T1,ERRETN
ERRET2:	JSP T1,ERRETN
ERRETN:	HRRZI T1,-ERRET0+1(T1)
	JRST CPOPJ1



DLSCI:	UHRRZ T2,(T1)	;GET INTERFACE TYPE
	SETZM	T1
	CAIE	T2,2	;ONLY TYMBASE IS LEGAL
	  JRST ERRET0	;ERROR RETURN 0
	POPJ	P,	;NON-ERROR RETURN
repeat 10,<jfcl>

DLSEDR:	UMOVE T3,(T1)
	SETZM	T1
	HLRZ	T2,T3	;/T2 INTERFACE NUMBER
	CAIE	T2,0
	  JRST ERRET0
	POPJ P,
repeat 10,<jfcl>

DLWDR:	UMOVE T3,(T1)
	SETZM	T1
	HLRZ	T2,T3	;/T2 INTERFACE NUMBER
	CAIE	T2,0
	  JRST ERRET0
	POPJ P,
repeat 10,<jfcl>

DLRDR:	UMOVE T3,(T1)
	SETZM	T1
	HLRZ	T2,T3	;/T2 INTERFACE NUMBER
	CAIE	T2,0
	  JRST ERRET0
	POPJ P,
repeat 10,<jfcl>

DLDDR:	UMOVE T3,(T1)
	SETZM	T1
	HLRZ	T2,T3	;/T2 INTERFACE NUMBER
	CAIE	T2,0
	  JRST ERRET0
	POPJ P,
repeat 10,<jfcl>

DLKMCD:	SETOM	T1	;T1/ -1
	JRST CPOPJ1	;SKIP RETURN FOR ERROR (NO KMC ON F3s)
repeat 10,<jfcl>

>;END.OF.IFCPU(F3)
>;IFNCPU(KS).END
END
(@
