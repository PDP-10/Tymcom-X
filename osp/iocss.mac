TITLE IOCSS - IO COMMON SUBROUTINES

;THIS MODULE CONTAINS MOST OF THE CODE FOR THE STANDARD
; SYSTEM IO UUOS.

IOCSS:	ENTRY	IOCSS

;GENERAL EXTERNALS

EXTERNAL UPTACP,UPTHCU,UPTJDA,%UPT
EXTERNAL ABTUUO,ADRERR,ERRIDM,ERRIUC
EXTERNAL PGYDIO,PGPDIO
EXTERNAL PUUOAC,WAIT1,WSYNC
EXTERNAL PJOBN,NWATRP,PDNMUP
EXTERNAL JOBFF,JOBSA,JBTABT,JBTLIC,JOB,JOBREL
EXTERNAL DEVFLO,DEVHNG,DEVPOS,DIOMAX
EXTERNAL CPOPJ,TSTKTJ


;TABLE OF M DISPATCH ADDRESSES
;IN FORMAT:
;	XWD 40,41
;	XWD 42,43
;	.
;	XWD 76,77
EXTERN TTYUUO,AUXTUU,FRMOPD,UUOMNR,UCALL,UCALLI

UUOTAB::XWD UCALL,UINIT		;(40,41)CALL,INIT
	XWD AUXTUU,CHANIO	;(42,43)FIVE UUOS FOR EACH INSTALLATION
	XWD FRMOPD,UUOMNR	;(44,45)FRMOP,RESERVED FOR TYMSHARE
	XWD UUOMNR,UCALLI	;(46,47),CALLI
	XWD UOPEN,TTYUUO	;(50,51)OPEN, TTCALL
	XWD UUOMNR,UUOMNR	;(52,53)
	XWD UUOMNR,URENAM	;(54,55),RENAME
XP IOUUO,55			;LOWEST IO M(RENAME)
	XWD TIN,TOUT		;(56,57)IN,OUT
	XWD SETIOS,USTATO	;(60,61)SETSTS,STATO
	XWD USTATS,USTATZ	;(62,63)GETSTS,STATZ
	XWD UINBF,UOUTBF	;(64,65)INBUF,OUTBUF
	XWD IN,UOUT		;(66,67)INPUT,OUTPUT
	XWD CLOSE0,RELEAS	;(70,71)CLOSE,RELEASE
XP LNGUUO,72			;LOWEST LING DISPATCH TABLE M
	XWD UMTAPE,UDGF		;(72,73)MTAPE,GETF
	XWD UDSI,UDSO		;(74,75)SETI,SETO
	XWD UDLK,UDEN		;(76,77)LOOKUP,ENTER

;UUOS 42, 43, 44, 45, AND 46 ARE FOR CUSTOMERS TO DEFINE AS THEY PLEASE
;UUOS 40, 41 AND 47 THROUGH 77 ARE DEFINED BY DIGITAL
;UUOS 51,52,53 AND 54 ARE RESERVED FOR EXPANSION BY DIGITAL

;CHANIO CODE. AC HAS FUNCTION,,CHANNEL NUMBER
;ADDRESS IS NORMAL UUO ADDRESS

CHANIO:	UMOVE T1,(W)	;GET FUNCTION AND CHANNEL
	HRRZ W,T1
	CAIN	W,-1	;
	JRST	.+3
	CAILE W,MAXCHN
	JRST ERRIUC
	HLRZS T1
	CAIL T1,CHOTBL*2
	JRST	CHNIER
	ROT T1,-1
	TLNE T1,(1B0)
	SKIPA T1,CHNOTB(T1)
	MOVS T1,CHNOTB(T1)	;HERE IS THE DISPATCH
	HRRZI	T1,(T1)		;
	JUMPE	T1,CHNIER
	CAIE	T1,COPEN
	CAIN	T1,NXTCHN
	SKIPA
	CAIE	W,-1
	JRST (T1)	;AND GO
	JRST	ERRIUC

CHNIER:	CAIN W,-1
	JRST ERRIUC
	POPJ P,		;JUST IGNORE EXTRA FUNCTIONS


CHNOTB:	XWD RELEAS,CLOSE0	;0 RELEASE 1 CLOSE
	UOUT,,IN	;2 OUTPUT 3 INPUT
	UDLK,,UDEN	;4 LOOKUP 5 ENTER
	UDSI,,UDSO	;6 USETI 7 USETO
	UDGF,,URENAM	;10 UGETF 11 RENAME
	UMTAPE,,COPEN	;12 MTAPE 13 OPEN
	TIN,,TOUT	;14 IN 15 OUT
	SETIOS,,USTATS	;16 SETSTS 17 GETSTS
	USTATZ,,USTATO	;20 STATS 21 STATO
	UINBF,,UOUTBF	;22 INBUF 23 OUTBUF
	UUOSK1,,WAIT	;24 SEEK 25 WAIT
	MOVBF2,,FWUSI	;26 MOVBUF 27 FULL WORD USETI
	FWUSO,,PGUSI	;30 FULL WORD USETO 31 PAGE USETI
	PGUSO,,UFDRD	;32 PAGE USETO 33 READ UFD
	MGNBIT,,VMAPUU	;34 MAGNUM BIT 35 VMAP
	FDELUU,,FEXCHU	;36 FDEL 37 FEXCHANGE
	FCREAU,,USDEN	;40 FCREATE 41 SIMULTANEOUS UPDATE
	FVLRBU,,VSMAPU	;42 VALIDATE FILE'S RIBS 43 SUPER MAP
	FFIFPU,,FTRNCU	;44 FFIFP AND FRIENDS 45 FILE TRUNC
	NXTCHN,,VMOVPG	;46 Find next free channel 47 Move VP to file

CHOTBL==.-CHNOTB	;LENGTH
CHNCHK::
CHNCK1::CAMG W,%UPT+UPTHCU	;IS THIS CHANNEL GREATER THE
				; HIGHEST ASSIGNED?
	SKIPN F,%UPT+UPTJDA(W)	;NO.  SEE IF REALLY ASSIGNED.
	POPJ P,			;NO CHANNEL ASSIGNED.
	MOVE S,DEVIOS(F)	;GET DATA BLOCK STATUS WORD.
	AOS (P)
CHNCK2:	MOVE T4,DEVSER(F)	;SETUP TO SERVICE DISPATCH.
	CAMG T1,DDXZ(T4)	;SEE IF IN DISPATCH TABLE
	AOS (P)			;YES.  DOUBLE SKIP RETURN.
	POPJ P,			;SINGL OR DOUBLE SKIP RETURN


;ENTER HERE FOR READ UFD CHANIO

UFDRD:	MOVEI T1,DUFD
	PUSHJ P,CHNCHK
	 JRST ERRIUC
	 POPJ P,
	JRST DUFD(T4)

;SEEK UUO ENTER HERE

UUOSK1::MOVEI T1,DSEK		;SEEK NUMBER
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	POPJ P,			;NOT THERE, GOOD RETURN
	JRST DSEK(T4)		;T4 SET BY CHNCHK, GO UUO



;WAIT FOR IO TO BECOME INACTIVE ON CHANNEL AC

WAIT::	MOVEI T1,0
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 POPJ P,		;RETURN IF NO CHANNEL.
	JFCL			;NO-OP IF SHORT DISPATCH TABLE.
	JRST WAIT1		;WAIT TILL INACTIVE BEFORE
				; RETURNING TO USER.

SUBTTL CLOSE UUO
;FOR PURPOSES OF COMMENTING THIS SUBROUTINE THE
;TERM 'BUFFER HEADER' SHALL REFER TO THE 3 WORD HEADER
;WHICH IS USED BY THE USER PROGRAM AND THIS EXEC FOR
;REFERING TO THE RING BUFFERS.

;THE CONTENTS OF THE 3 WORD HEADER (AS SET BY THE MONITOR
;		ON EACH INPUT AND OUTPUT M).
;		BIT 18-35=ADDRESS OF SECOND WORD OF THE
;		CURRENT BUFFER IN RING WHICH USER IS REFERENCING
;	WORD 2:	BYTE POINTER TO CURRENT ITEM.
;	WORD 3:	POSITIVE J COUNT (NO. OF ITEMS LEFT ON
;		INPUT, NO. OF FREE ITEMS TO GO ON OUTPUT).

;EACH BUFFER IN THE RING HAS FOLLOWING FORMAT (AS THE USER SEES IT)

;	WORD 1:	RESERVED FOR BLOCK NUMBER FOR FIXED ADDRESS DEVICES
;	WORD 2:	BIT 0=USE BIT FOR THIS BUFFER
;		BIT 1-17=NO. OF WORDS WHICH FOLLOW (LENGTH OF BUFFER)/
;		BIT 18-35=ADDRESS OF SECOND WORD OF NEXT BUFFER IN RING
;	WORD 3:	LH=LINK TO NEXT BLOCK (SET BY MONITOR FOR DECTAPE)
;		RH=NO. OF WORDS OF DATA WHICH FOLLOW (USUALLY
;		SET BY EXEC EXCEPT IF THE USER HAS SPECIFIED
;		THAT HE WANTS TO COMPUTE WORD COUNT
;		HIMSELF INSTEAD OF HAVING THE MONITOR DO IT
;		USING THE BYTE POINTER IN THE 3 WORD HEADER).

;CALLING SEQUENCE
;	CLOSE D,
;	EXIT		ALWAYS RETURNS HERE
; THIS ROUTINES PROCESSES THE CLOSE M AND DETERMINES WHETHER THE
;OUTPUT ROUTINE SHOULD BE CALLED IF OUTPUT WERE ACTIVE, CLEARS
;THE INPUT BUFFER AREA IF INPUT WERE ACTIVE, AND CLEARS THE 
;J COUNTS OF BOTH INPUT AND OUTPUT HEADERS SERVING TO BOTH
;TERMINATE THE USE OF THE DEVICE AND SET THE I/O ROUTINES TO
;ACCEPT ANOTHER INPUT OR OUTPUT COMMAND IN A CLEAR STATE.
;IN THE CASE OF OUTPUT DEVICES, THE CLOSE ROUTINE OF THE DEVICE HANDL-
;ING ROUTINE IS CALLED IN CASE ANY SPECIAL HANDLING IS REQUIRED.

INTERNAL CLOSE1,CLOSE0
EXTERNAL PIOMOD,DEVECK

CLOSE0:	MOVEI T1,DCL
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	POPJ P,			;NO OPERATION IF NO CHANNEL.
	POPJ P,			;NOT IN DISPATCH TABLE?

;***** NOTE *****  This code plays with the "previous context user"
;***** NOTE *****  bit in the PC.  In order for this bit to be properly
;***** NOTE *****  restored to it's original state, the 2-instruction
;***** NOTE *****  pseudo-POPJ MUST be used to exit, since normal POPJ
;***** NOTE *****  does not restore this flag from the PC on the stack.	
;***** NOTE *****  Buffered IO cannot be done from the monitor because
;***** NOTE *****  previous context is set to user.
CLOSE1:	PUSHJ	P,.+1		;SAVE STATE OF "PREVIOUS CONTEXT USER"
	TLNE	F,INBFB+INPB+OUTBFB+OUTPB	;DOING BUFFERED IO?
	JRSTF	@[PC.UIO,,.+1]	;YES, SET PREVIOUS CONTEXT TO USER
	PUSHJ P,WAITIO		;WAIT UNTIL DEVICE IS INACTIVE
	TRNN M,CLSIN		;SUPPRESS INPUT CLOSE?
	TLOE F,ICLOSB	;NO. INPUT ALREADY BEEN CLOSED?
	JRST UCLS2		;YES
	LDB T1,PIOMOD		;NO
	CAIGE T1,SD		;DUMP MODE?
	JRST UCLSBI		;NO. CLOSE BUFFERED INPUT.
UCLS5:	MOVEI T1,DCLI
	PUSHJ P,CHNCK2
	 SKIPA		;NOT IN DISPATCH TABLE
	PUSHJ P,DCLI(T4)	;YES. DISPATCH TO DEVICE DEP. ROUTINE
	JRST UCLS2		;MUST NOT DESTROY M,F,W
UCLSBI:	MOVE	T1,DEVMOD(F)
	HRRZ T4,DEVSER(F)	;RESTORE T4 AFTER DCLI
	TLNE F,INBFB+INPB	;WAS AN INPUT BUFFER SETUP?
	JRST UCLS4		;YES
	TLNE	T1,DVDSK	;CLOSING A DISK FILE ?
	JRST	UCLS5		;YES, DO DEVICE DEPENDENT CLOSE ANYWAY.
	JRST	UCLS2		;NO, CLOSE NOT NECESSARY.
UCLS4:	MOVEI T1,DCLI
	PUSHJ P,CHNCK2
	 SKIPA
	PUSHJ P,DCLI(T4)	;YES, CLOSE INPUT
	PUSHJ P,BFICLN
UCLS2:	MOVE S,[XWD IOEND,IODEND]
	ANDCAB S,DEVIOS(F)
	TRNN M,CLSOUT		;SUPPRESS OUTPUT CLOSE?
	TLOE F,OCLOSB	;NO. OUTPUT ALREADY CLOSED?
	JRST UCLS3		;YES
	LDB T1,PIOMOD		;NO.
	CAIGE T1,SD		;DUMP MODE?
	JRST UCLSBO		;NO. CLOSE BUFFERED OUTPUT
UCLS7:	HRRZ T4,DEVSER(F) ;RESTORE T4
	PUSHJ P,DCL(T4)	;YES. DISPATCH TO DEVICE DEP. ROUTINE
	JRST UCLS3
UCLSBO:	TLNN F,OUTBFB+OUTPB	;WAS AN OUTPUT BUFFER SET UP?
	JRST UCLS6		;NO
	HLRZ U, DEVBUF(F)	;VIRGIN OUBPUT BUFFER?
	XCTBU <SKIPG (U)>
	JRST UCLS6		;YES, DO NOT CLOSE UNLESS IT IS A DISK FILE
UCLS2A:
	HRRZ T1,DEVOAD(F)
	XCTBU <SKIPL (T1)>	;NO, HAS SERVICE ROUTINE WRITTEN
				; ITS NEXT BUFFER YET?
	JRST UCLS2B		;YES
	LDB T1,DEYCLS	
	XCT CLA(T1)		;CALL CLASS DEPENDENT ROUTINE TO DUMP BUFFER TO MONITOR BUFFER
	JFCL
	TRZ	S,760000	;NO,CLEAR ERROR BITS AND START OUTPUT DEVICE
	PUSH P,M
	LDB	T2,DEYCLS	;GET CLASS
	XCT	CLOBUF(T2)		;CALL CLASS DEPENDENT ROUTINE
	JRST	UCLS2C		;ROUTINE DID IT ALL, FINISH UP
	HRRZ T4,DEVSER(F) ;RESTORE T4
	PUSHJ	P,DOU(T4)	;CALL SERVICE ROUTINE TO DO OUTPUT
UCLS2C:	POP P,M
	PUSHJ	P,WAIT1	;WAIT TILL MOST BUFFERS FILLED
	TRNN	S,760000	;ERROR?
	JRST UCLS2A		;NO,RETURN WHEN ALL EMPTIED
				; OR SHUFFLING REQUIRED STOPS DEVICE


UCLS2B:	HLRZ	T2,DEVBUF(F)	 ;OUTPUT LAST BUFFER LOC OF HEADER
	XCTFU <SKIPG	T3,(T2)>		;VIRGIN RING?
	JRST	UCLS2D		;YES. NOTHING TO OUTPUT
	TLNE T3,IOADVB		;IS BUFFER IN ADVANCED STATE
	JRST UCLS3C	;OF ROT
	XCTFU <HRRZ	T4,1(T2)>		;LAST WORD FILLED
	SKIPE	T4		;IGNORE IT IF 0
	SUBI	T4,1(T3)		;-1ST WORD=LENGTH OF LAST BUFFER
	TRNE	S,IOWC		;USER COMPUTING OWN WORD COUNT?
	XCTFU <HRRZ	T4,1(T3)>		;YES. GET IT
	JUMPE	T4,UCLS2D	;DONT OUTPUT IF LENGTH=0
UCLS3C:	PUSHJ	P,OUT		;WRITE THE LAST BUFFER
	PUSHJ	P,WAIT1	;WAIT FOR IT
UCLS2D:	MOVE T4,DEVSER(F)
	PUSHJ P,DCL(T4)	;CLOSE OUTPUT BUFFER
	LDB	T4,DEYCLS
	XCT	CLA(T4)	;CALL CDR TO ADVANCE LAST BUFFER
	JFCL
	HLRZ U,DEVBUF(F)
	HRLZI T1,IOUSE
	XCTBU <IORM T1,(U)>
	MOVSI T1,IOADVB
	XCTBU <ANDCAM T>	;MAKE SURE ITS OFF
	XCTBU <SETZM 2(U)>		;JBFCTR:=0
	PUSHJ P,WAIT1
	TLO F,OCLOSB	;SET OCLOSB AFTER OUTPUT IS COMPLETE
;
; !!!!! NO TOUCH NEXT THREE INSTRUCTIONS !!!!!
;
UCLS3:	POP	P,T1		;Get back saved PC from PUSHJ at CLOSE1
	HRRI	T1,.+2		;SET TO RET TO INST AFTER JRSTF
	JRSTF	@T1		;RESTORE OLD "PREVIOUS CONTEXT USER"
;
; O.K., all kosher now.
;
	HLLM F,%UPT+UPTJDA(W)
	MOVE	T1,DEVMOD(F)	;IS THIS A
	TLNN	T1,DVDSK	;DISK FILE?
	JRST	DEVECK		;NO.
	TLNE	F,ICLOSB	;YES,  IF BOTH INPUT AND
	TLNN	F,OCLOSB	;OUTPUT HAVE BEEN CLOSED,
	JRST	DEVECK		;THEN
	SETZM	DEVPOS(F)	;CLEAR SOME
	SETOM	DEVFLO(F)	;STUFF BEFORE
	JRST	DEVECK		;EXITING WITH ERROR CHECK.

UCLS6:	MOVSI	T1,DVDSK
	TDNE	T1,DEVMOD(F)	;CLOSING A DISK FILE ?
	JRST	UCLS7		;YES, DO DISK CLOSE ROUTINE IN ANY EVENT
	JRST	UCLS3

BFICLN:	LDB T2,DEYCLS	;GET TYPE
	XCT BFICLS(T2)	;ZERO DEVABC FOR DIRECT IO DEVICES
	HRRZ T2,DEVBUF(F)
	XCTBU <HRRZ U,(T2)>		;FIRST WORD OF 3 WORD BUFFER HEADER
	MOVE T2,U		;REMEMBER CURRENT BUFFER IN T2
	HRLZI T1,IOUSE		;USED BOTH FOR HEADER AND EACH BUFFER
	JUMPE U,UCLS1		;HAS A RING BEEN SETUP?(NO IF 0)
	MOVEI P2,10000		;ONLY ALLOW 10000 BUFFERS IN A RING
				; SETUP COUNT IN CASE USER HAS MESSED
				; BUFFER RING INTO A FIGURE SIX
	SETZM P1
UCLS0:	XCTBU <HRR U,(U)>		;ADVANCE CURRENT INPUT BUFFER ADDRESS
	CAIN P1,(U)		;IS THIS THE SAME BUFFER AS LAST ONE?
	JRST UCLS1		;YES. BAD RING. LOOPING ON ITSELF.
	XCTBU <ANDCAM T1,(U)>		;YES, CLEAR USE BIT.
	CAME T2,U		;DONE?
	SOJG P2,UCLS0		;NO, HAVE WE SCANNED 1000 BUFFERS?
				; (WHICH MAY BE THE SAME)
				; YES
UCLS1:	HRR U,DEVBUF(F)
	XCTBU <IORM T1,(U)>		;FLAG AS VIRGIN BUFFER IN 3 WORD HEADER
	MOVSI T1,IOADVB
	XCTBU <ANDCAM T1,(U)>	;MAKE SURE ITS OFF
	XCTBU <SETZM 2(U)>		;CLEAR INPUT J COUNT.
	POPJ	P,

BFICLS:	JFCL	;TTY
	JFCL	;I/O BUS DEVICE
	JFCL	;DSK. SIMIO TAKES CARE OF PAGE RELEASE
	SETZM DEVABC(F)	;TAPE

SUBTTL INBUF,OUTBUF UUOS
;CALLING SEQUENCE
;	INBUF D,N
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
;CALLING SEQUENCE
;	OUTBUF D,N
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
; SETS UP AN N BUFFER RING FOLLOWING THE USER'S PROGRAM FOR DEVICE
; D AND INITIALIZES THE JOB BUFFER AREA HEADER:
;	JBFADR0:=1,	JBFADR 1-17:=0
;	JBFADR 18-35:=ADDRESS OF FIRST BUFFER IN RING
;INPUT SETS DEVIAD:=ADDRESS OF FIRST BUFFER IN RING
;OUTPUT SET DEVOAD:=ADDRESS OF FIRST BUFFER IN RING
;W IS RESTORED.


UOUTBF:	MOVEI T1,0
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	 JRST ERRIUC		;NOT IN DISPATCH TABLE
	TLO F,OUTBFB	;FLAG OUTBUF M DONE
	PUSH P,W		;SAVE W ON STACK
	PUSHJ P,BUFCLC	;SET UP BUFFER RING
	HLR T1,DEVBUF(F)	;T1:=OUTPUT BUFFER AREA HEADER ADDRESS
	HRRM W,DEVOAD(F)	;DEVOAD:=ADDRESS OF FIRST BUFFER
				; IN RING
UOBF1:	UMOVEM W,(T1)	;JBFADR:=IOUSE,ADDRESS OF FIRST BUFFER
				; IN RING
	POP P,W		;RESTORE W FROM STACK
	MOVEM F,%UPT+UPTJDA(W)
	POPJ P,		;EXIT THIS M
UINBF:	MOVEI T1,0
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	 JRST ERRIUC		;NOT IN DISPATCH TABLE
	TLO F,INBFB	;FLAG INBUF M DONE
	PUSH P,W		;SAVE W ON STACK
	PUSHJ P,BUFCLC	;SET UP BUFFER RING
	HRRM W,DEVIAD(F)	;DEVIAD:=ADDRESS OF FIRST BUFFER
				; IN RING
	HRR T1,DEVBUF(F)	;T1:=INPUT BUFFER AREA HEADER ADDRESS
	JRST UOBF1
SUBTTL NXTCHN, CHNNXT

;CHANIO TO RETURN THE NUMBER OF THE NEXT AVAIL CHANNEL
NXTCHN:	PUSHJ	P,CHNNXT	;FIND NEXT CHAN AND TELL USER
	 JRST	[SKIPE	%UPT+UPTJDA(W)	;IS USER SPECIFIED CHAN IN USE?
		 POPJ	P,		;YES
		 JRST	CPOPJ1]		;NO
	JRST	CPOPJ1		;FOUND A CHAN AND TOLD USER WHAT IT IS

;ROUTINE TO FIND NEXT FREE CHAN
CHNNXT:	CAIE	W,-1		;USER ASKS US TO FIND A CHANNEL?
	POPJ	P,		;NO.
	MOVEI	W,1		;YES, START LOOKING AT 1.
	SKIPN	%UPT+UPTJDA(W)	;CHANNEL IN USE ALREADY?
	JRST	CHNNX1		;NO.
	CAIGE	W,MAXCHN	;YES, ALL IN USE?
	AOJA	W,.-3		;NO, TRY NEXT.
	JRST	TPOPJ		;YES, REPORT NO CHANNEL.
CHNNX1:	LDB	T2,PUUOAC	;HERE ON FOUND W/ CHANNEL.
	XCTBU	<HRRM W,(T2)> 	;REPORT IT TO USER.
	JRST	CPOPJ1		;SKIP RETURN
SUBTTL OPEN,CHANIO OPEN, INIT UUOS
;HERE FOR CHANIO OPEN, POSSIBLY WITH CHANNEL = -1.
COPEN:	PUSHJ	P,CHNNXT	;GET NUMBER OF NEXT AVAIL CHAN
	 JRST	UOPEN		;USER SUPPLIED THE CHAN NUMBER
	CAMLE	W,%UPT+UPTHCU	;NEED TO UPDATE UPTHCU?
	MOVEM	W,%UPT+UPTHCU	;YES, DO SO.
	JRST	UOPEN		;
;OPEN M - PERFORMS SAME OPERATION AS INIT
;MAY BE USED EASILY BY REENTRANT PROGRAMS
;CALLING SEQUENCE FROM USER AREA
;	OPEN D,ADR
;	ERROR RETURN
;	DEVICE INITED

;LH(ADR)=0,RH(ADR)=DATA MODE THIS INIT
;C(ADR+1) = SIXBIT /NAME/
;LH(ADR+2)=OUTPUT BUFFER HEADER ADDRESS
;RH(ADR+2)=INPUT BUFFER HEADER ADDRESS


UOPEN:	UMOVE T1,(M)		;SET T1 TO CONTENTS OF FIRST ARG(IO STATUS BITS)
	AOJA M,UINIT0		;MAKE M POINT TO ARG+1(WITH R STILL
				; IN INDEX FIELD)

;CALLING SEQUENCE
;	INIT D,MODUS	D=JOB DEVICE CHANNEL
;			MODUS=IORDEL,IOCON,IOWC,MODE.
;	SIXBIT/NAME/	DEVICE NAME
;	XWD OBUF,IBUF	BUFFER AREA HEADER ADDRESSES
;	EXIT1		DEVICE NOT AVAILABLE
;	EXIT2		DEVICE PROPERLY ASSIGNED
;THE LEFT HALF OF NAME CONTAINS THE THREE LETTER DEVICE MNEMONIC,
;   THE RIGHT HALF IS EITHER ZERO (SYSTEM WILL ASSIGN AN ARBITRARY
;   UNIT) OR NON-ZERO TO REQUEST A SPECIFIC UNIT (LEFT JUSTIFIED).
;IF THE SELECTED DEVICE IS NOT AVAILABLE, CONTROL RETURNS TO EXIT1.
;OTHERWISE, THE DEVICE IS ASSIGNED TO THE USER AND ATTACHED TO HIS
;CHANNEL D.  THE DEVICE IS INITIALIZED IN THE FOLLOWING MANNER AFTER
;IOACT IS ZERO:
;	IOBEG:=1
;	DATA MODE:=BITS 32-35 OF AC M
;	IOCON:=BIT 31 OF AC M
;	IOWC:=BIT 30 OF AC M
;	IORDEL:=BIT 29 OF AC M
;	IOACT:=IODEND:=IOBKTL:=IODTER:=IODERR:=IOIMPM:=0
;	JBFADR:=JBFCTR:=0 FOR THE SPECIFIED BUFFERS.
;	DEVBUF:=OBUF,IBUF
EXTERNAL TPOPJ,TPOPJ1,DOXCT

UINIT:	HRRZ T1,M		;SAVE FIRST ARG(IO STATUS BITS) IN T1
	HRR M,PDNMUP(P)		;SET M TO ADR+1 OF USER ARGS
	AOS PDNMUP(P)		;SET RETURN SKIP THE 2 ARGUMENTS
	AOS PDNMUP(P)
UINIT0:	PUSH P,M		;HERE ON OPEN M, SAVE ADR+1 OF USER ARGS
	PUSH P,T1		;SAVE IO STATUS BITS(FIRST ARG)
	SKIPE F,%UPT+UPTJDA(W)	;IS A DEVICE ALREADY ASSIGNED TO THIS CHAN?
	CAMLE W,%UPT+UPTHCU	;YES, IS THIS CHAN. LESS OR EQUAL TO HIGHEST
				; CHAN. FOR THIS USER?
	JRST UINITA		;NO, NO PREVIOUS DEVICE TO RELEASE
	PUSHJ P,RELEAS	;RELEASE PREVIOUS DEVICE ON THIS CHAN.
UINITA:	MOVE M,-1(P)	;RESTORE M (ADR+1 OF 3 ARGS)
	UMOVE T1,(M)		;C(T1)=DEVICE NAME IF IN BOUNDS.
				; DO NOT RETURN IF OUT OF BOUNDS(PRINT ERR AND STOP)
	MOVE J,JOB		;GET THE CURRENT JOB NO.
	SKIPGE (P)		;SEE IF WANTS PHYSICAL ONLY
	HRLI W,PHONLY		;YES
	PUSHJ P,DEVSRC	;SEARCH FOR DEVICE NAME
				; (SET SYSDEV BIT IN LH OF
				; F IF THIS IS SYSTEM TAPE)
	JRST UINITE		;NO SUCH DEVICE
	HRRZ M,(P)		;RESTORE USER'S MODE SETTING
	PUSH P,T1		;SAVE NAME USER SUPPLIED
	PUSHJ	P,CHKMOD	;CHECK FOR LEGAL MODE, IF NOT RIGHT DONT RETURN
UINIT1:	POP P,T1		;RESTORE NAME
	MOVEI T2,ASSPRG	;TRY TO ASSIGN IT BY PROGRAM
	PUSHJ P,ASSASG
	JRST UINITE		;NOT AVAILABLE, GIVE ERROR RETURN(POP T1)
	POP P,M		;RESTORE USER'S MODE SETTING
	PUSHJ P,SETIO2	;SET DDB S STATUS WORD FROM RT. HALF OF AC M
				; WAIT FOR DEVICES TO BECOME INACTIVE IN CASE IT IS
				; INITED ON A DIFFERENT CHANNEL(OR MONITOR COMMAND
				; RESPONSE ON TTY)
	HRRZ T1,F
EXTERN ACTDDB,ACTDED
	CAIN T1,ACTDDB
	JRST [MOVSI T1,ACTDED	;ACT DEVICE REQUIRES THIS RESET
		ANDCAM T1,DEVSTS(F); ON INIT
		MOVSI S,0	;DO NOT SET IOBEG FOR ACT DEVICE
		JRST .+2]
	MOVSI S,IOBEG		;IOBEG CAUSES MONITOR BUFFER TO BE CLEARED
	IORB S,DEVIOS(F)
	HRRZS W			;CLEAR FOR UNITL LOOP
UINITL:	CAMG W,%UPT+UPTHCU	;IS THIS CHAN. .GT. HIGHEST CHAN. IN USE?
	JRST UINITC		;NO
	AOS T1,%UPT+UPTHCU	;YES, BUMP HIGHEST SO FAR BY ONE
	SETZM %UPT+UPTJDA(T1)	;AND CLEAR IT OUT
	CAILE	T1,17
	JRST	UINITL	;PAST END OF USER JOBJDA ARRAY
	UXCTBU <SETZM JOBJDA(T1)>
	JRST UINITL	;KEEP LOOKING

UINITC:	MOVEM F,%UPT+UPTJDA(W)	;STORE FOR MONITOR
	SKIPE %UPT+UPTSIM(W)	;DEBUG AAA. RELEASE SHOULD
	STOPCD		;HAVE CLEARED THIS IF THIS WAS DSK BEFORE
	CAILE	W,17
	JRST	UINIC1	;PAST END USER JOBJDA ARRAY
			;KEEP USER UPTODATE WITH THIS MOVEM:
	UXCTBU <MOVEM F,JOBJDA(W)>
UINIC1:
	MOVE T1,%UPT+UPTHCU	;HIGHEST CHAN IN USE
	UXCTBU <MOVEM T1,JOBHCU>
	TLO F,INITB+ICLOSB+OCLOSB;SET INIT M BIT
				;PREVENT SUPERFLUOUS CALLS TO CLOSE (SEE LOOKUP,ENTER)
	AOS M,(P)		;ADVANCE TO 3RD ARG(BUFFER HEADER)
	UMOVE T1,(M)		;C(T1)=BUFFER HEADER ARG
	HLRZ T2,T1		;OUTPUT BUFFER HEADER FROM USER
	JUMPE T2,UINIT4	;WAS ONE SPECIFIED?
	HRLM T2,DEVBUF(F);YES, SET DEVICE DATA BLOCK
	TLO F,OBUFB	;SET OUTPUT BUFFER SPECIFIED BIT
	PUSHJ P,UINITZ	;INITIALIZE OUTPUT BUFFER HEADER
UINIT4:	UMOVE T1,(M)	;C(T1)=BUFFER HEADER ARG FROM USER
	HRRZ T2,T1		;INPUT BUFFER HEADER
	JUMPE T2,UINIT5	;WAS ONE SPECIFIED?
	HRRM T2,DEVBUF(F)	;YES, SET DEVICE DATA BLOCK
	TLO F,IBUFB	;SET INPUT BUFFER SPECIFIED BIT
	MOVSI S,IOEND		;CLEAR END OF FILE FLAG
	ANDCAB S,DEVIOS(F)	;AND RETAIN S
	PUSHJ P,UINITZ	;INITIALIZE INPUT BUFFER HEADER
UINIT5:	MOVEM F,%UPT+UPTJDA(W)	;STORE M BITS AND  DEVICE
				; DATA BLOCK ADDRESS
EXTERNAL JOBHCU,JOBJDA
EXTERN TST1UN
	PUSHJ	P,TST1UN	;SEE IF SPECIAL DSK UNIT.
	JRST TPOPJ1		;SUCCESSFUL RETURN(POP T1)

UINITE:	POP P,T1		;REMOVE IO STATUS ARG
	JRST TPOPJ		;AND GIVE ERROR RETURN AND POP T1

;CALLING SEQUENCE
;	PUSHJ P,UINITZ
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED.
;SETS JBFADR:=JBFCTR:=0 FOR THE BUFFER AREA HEADER WHOSE ADDRESS
;IS IN AC TAC1.  ALSO,JBFPTR 0-5:=JBFPTR 12-17:=0,JBFPTR 6-11:=BYTE SIZE

UINITZ:	XCTBU <SETZM (T2)>	;CLEAR FIRST WORD (CURRENT BUFFER) OF 3 WORD HEADER
	AOS T2		;POINT TO SECOND WORD (BYTE POINTER)
	PUSH P,T2
	AOS T2		;POINT TO THIRD WORD (J COUNT)
	XCTBU <SETZM (T2)>	;SET J COUNT TO ZERO
	PUSHJ P,SETBYT	;SET BYTE SIZE ACCORDING TO MODE AS SET IN AC S
	TLZ T1,770077
	POP P,T2
	XCTBU <HLLM T1,(T2)>	;AND STORE IN SECOND WORD
	POPJ P,		;RETURN

SUBTTL ENTER,SIMULATNEOUS ENTER, LOOKUP

;LONG DISPATCH TABLE UUOS - GET HERE ONLY IF DEVICE HAS LONG
;DISPACTH TABLE
;DISPACTH TO DEVICE DEPENDENT SERVICE ROUTINE
;ENTER M - ENTER FILE NAME IN DIRECTORY

USDEN:	SKIPA	T1,[DSIM]	;HERE FOR SIMULTANEOUS UPDATING ENTER
UDEN:	MOVEI T1,DEN
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	JRST CPOPJ1		;SHORT DISPATCH TABLE OKAY.
	ADD	T4,T1		;GET PROPER DISPATCH ADDRESS.
	PUSH P,W
	MOVEI T1,CLSIN
	TLNN F,OCLOSB	;FILE OPEN?
	PUSHJ P,UDLKC		;YES. CLOSE IT[OCLOSB_1]
	MOVE T1,DEVMOD(F)
	TLNN T1,DVDSK		;EXCEPT FOR DSK,
	TLO S,IOBEG		;SET IOBEG EVEN ON UPDATING ENTER
	TRZ S,IOIMPM!IODERR!IODTER!IOBKTL!IODEND!IOBOT!IOTEND
	PUSHJ P,ARGCHK	;ADDRESS CHECK ARG.
	PUSHJ P,(T4)	;ATTEMPT AN ENTER
	 JRST WPOPJ	;FAILURE
	TLZ F,OCLOSB!OUTPB
	TLO F,ENTRB	;NOTE SUCCESSFUL ENTER
	JRST DLKDEN		;STORE THE PROGRESS BITS

;LOOKUP M - LOOKUP FILE NAME IN DIRECTORY

UDLK:	MOVEI T1,DLK
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	JRST CPOPJ1		;SHORT DISPATCH TABLE OKAY.
	PUSH P,W
	MOVEI T1,CLSOUT		;INHIBIT OUTPUT CLOSE BIT
	TLNN F,ICLOSB	;FILE OPEN?
	PUSHJ P,UDLKC		;YES. CLOSE IT[ICLOSB_1]
	TDZ S,[XWD IOEND,IOIMPM!IODERR!IODTER!IOBKTL!IODEND!IOBOT!IOTEND]
	PUSHJ P,ARGCHK	;ADDRESS CHECK ARG.
	MOVE	T4,DEVSER(F)
	PUSHJ P,DLK(T4)	;ATTEMPT A LOOKUP
	 JRST WPOPJ	;FAILURE
	TLZ F,ICLOSB!INPB!MAPB
	TLO F,LOOKB	;NOTE SUCCESSFUL LOOKUP
DLKDEN:	POP P,W
	HLLM F,%UPT+UPTJDA(W) ;STORE M PROGRESS BITS
	JRST CPOPJ1		;SUCCESS RETURN TO USER (CALL+2)


UDLKC:	PUSH P,M
	PUSH P,T4
	HRRI M,(T1)
	PUSHJ P,CLOSE1
	POP P,T4
	POP P,M
	JRST	WAIT1

ARGCHK:	MOVEM S,DEVIOS(F);STORE S & M BITS
	HLLM F,%UPT+UPTJDA(W)
	POPJ P,

WPOPJ:	POP P,W
	POPJ P,

SETMOD::PUSHJ P,TTYFND
	HRR M,T1
	JRST SETIO2		;JUST DO A SETSTS

MOVBUF::LDB W,[POINT 4,T1,17]	;GET CHANNEL
MOVBF3:	PUSH P,T1	;SAVE T1 FROM CHNCHK
	MOVEI T1,0	;ALWAYS OK
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	JFCL			;NO-OP ON SHORT DISPATCH TABLE.
	POP P,T1
	PUSHJ P,WAIT1
	TLNN T1,20
	JRST MOVOBF		;NOT INPUT RING
	HRRZ T2,DEVIAD(F)
	JUMPE T2,MOVOBF		;NOT REALLY AN INPUT RING
	ADD T2,T1
	HRRM T2,DEVIAD(F)
MOVOBF:	TLNN T1,40
	JRST MOVIHD
	HRRZ T2,DEVOAD(F)
	JUMPE T2,MOVIHD
	ADD T2,T1
	HRRM T2,DEVOAD(F)
MOVIHD:	TLNN T1,100
	JRST MOVOHD
	HRRZ T2,DEVBUF(F)
	JUMPE  T2,MOVOHD
	ADD T2,T1
	HRRM T2,DEVBUF(F)
MOVOHD:	TLNN T1,200
	POPJ P,
	HLRZ T2,DEVBUF(F)
	JUMPE T2,CPOPJ
	ADD T2,T1
	HRLM T2,DEVBUF(F)
	POPJ P,

MOVBF2:	UMOVE T1,(M)
	JRST MOVBF3

SUBTTL CHANIO DISPATCH VARIOUS FUNCTIONS
;CHANIO VMAP FUNCTION.
;
;CALL HAS THE FORM:
;
;    MOVE AC,[XWD 35,CHANNEL NO.]
;    CHANIO AC,LOC
;    ERROR RETURN
;    SUCCESS RETURN
;
;WHERE LOC HAS THE FORM:
;    BYTE (1)0(4)0(3)PROTECT(^D10)CONTIG PGS(8)0(10)START VM PAGE #
;
;AND LOC+1 HAS THE FORM:
;    START FILE PAGE #


INTERN UUYCPR,UUYSVM,UUYCTG
UUYCTG: POINT ^D10,T1,17
UUYCPR: POINT ^D3,T1,7
UUYSVM: POINT ^D10,T1,^D35


VMAPUU::MOVEI	T1,DVMAP	;
	JRST	KERCHN		;






;CHANIO VSMAP FUNCTION.
;
;CALL HAS THE FORM:
;
;    MOVE AC,[XWD 43,CHANNEL NO.]
;    CHANIO AC,LOC
;    ERROR RETURN
;    SUCCESS RETURN
;
;WHERE LOC HAS THE FORM:
;    BYTE (1)0(4)0(3)PROTECT(^D10)CONTIG PGS(8)0(10)START VM PAGE #
;
;AND LOC+1 HAS THE FORM:
;    START UNIT/STR PAGE #


VSMAPU::MOVEI	T1,DVSMAP	;
	JRST	KERCHN		;

;CHANIO MOVE VP TO FILE FUNCTION.
;
;CALL:
;
;	MOVE	AC,[XWD 47,CHANNEL NO.]
;	CHANIO	AC,LOC
;	  <ERROR RETURN>
;	<SUCCESS RETURN>
;
;LOC:	VP NUMBER
;LOC+1:	FP NUMBER OR -1 FOR FIRST PAGE PAST END OF FILE.

VMOVPG:	MOVEI	T1,DMOVPG	;DDB DISPATCH NUMBER
	JRST	KERCHN		;DISPATCH TO THE CALL.




;CHANIO DELETE FILE PAGE FUNCTION.
;
;CALL HAS THE FORM:
;
;    MOVE AC,[XWD 36,CHANNEL NO.]
;    CHANIO AC,LOC
;    ERROR RETURN
;    SUCCESS RETURN
;
;WHERE LOC HAS THE FORM:
;	FILE PAGE NUMBER.


FDELUU:	MOVEI	T1,DFDEL	;
	JRST	KERCHN		;



;CHANIO CREATE FILE PAGE FUNCTION.
;
;CALL HAS THE FORM:
;
;    MOVE AC,[XWD 40,CHANNEL NO.]
;    CHANIO AC,LOC
;    ERROR RETURN
;    SUCCESS RETURN
;
;WHERE LOC HAS THE FORM:
;	FILE PAGE NUMBER.


FCREAU:	MOVEI	T1,DFCRE	;
	JRST	KERCHN		;




;CHANIO TRUNCATE FILE WITHIN LAST PAGE FUNCTION.
;
;CALL HAS THE FORM:
;
;    MOVE AC,[XWD 45,CHANNEL NO.]
;    CHANIO AC,LOC
;    ERROR RETURN
;    SUCCESS RETURN
;
;WHERE LOC HAS THE FORM:
;	NEW FILE SIZE IN WORDS.


FTRNCU:	MOVEI	T1,DFTRN	;
	JRST	KERCHN		;




;CHANIO EXCHANGE FILE PAGES FUNCTION.
;
;CALL HAS THE FORM:
;
;    MOVE AC,[XWD 37,CHANNEL NO.]
;    CHANIO AC,LOC
;    ERROR RETURN
;    SUCCESS RETURN
;
;WHERE LOC AND LOC+1 CONTAIN THE NUMBERS OF THE FILE PAGES TO
;BE EXCHANGED.

FEXCHU:	MOVEI	T1,DFEXC	;
	JRST	KERCHN		;




;CHANIO FIND INTERESTING RET PNTR FUNCTION (FFIFP AND FRIENDS.).
;
;CALL HAS THE FORM:
;
;    MOVE AC,[XWD 44,CHANNEL NO.]
;    CHANIO AC,
;    ERROR RETURN
;    SUCCESS RETURN
;
;WHERE LOC CONTAINS THE FILE PAGE NUMBER TO START SEARCHING
;AT (INCLUSIVE), AND LOC+1 CONTAINS THE CONDITION OF INTEREST,
;AS:
;	0	FIND FIRST HOLE.
;	1	FIND FIRST REAL PAGE.

FFIFPU:	MOVEI	T1,DFFIF	;
	JRST	KERCHN




;CHANIO VALIDATE RIBS FUNCTION.
;
;CALL HAS THE FORM:
;
;    MOVE AC,[XWD 42,CHANNEL NO.]
;    CHANIO AC,LOC
;    ERROR RETURN
;    SUCCESS RETURN

FVLRBU:	MOVEI	T1,DFVLR	;
	JRST	KERCHN

COMMENT #
@@SUBROUTINE KERCHN
@@PURPOSE
PLACE TO DISPATCH FROM SOME CHANIOS TO THE KERNEL ROUTINES
IN MAPIOX.
SETS UP T1 AS 1ST USER AC AND POSSIBLY T2 AS SECOND USER AC.
SETS USER-EXEC FLAG IN BIT 0 OF T1 FOR MAP, BIT 0 OF T3 FOR
EXCH/DEL/CRE/FFFF (TO AVOID CONFLICTS WITH -1, ETC.).
NOTE THAT THE FCREATE AND FFIFP KERNELS EXPECT M TO BE SET UP,
SO THAT THEY CAN STORE THRU IT.
SETS J/ JOB NUMBER.
@@ENTRY
EXPECTS T1/ DVMAP, DVSMAP, DFDEL, DFCRE, DFVRL, DFFIF, DFEXC,
OR DFTRN.
@@ACCUM
DESTROYS ALL BUT M.
@@EXIT
@@ #

KERCHN:	PUSHJ	P,CHNCHK	;CHK CHAN AND SET F, S, AND T4.
	JRST	ERRIUC		;NO CHANNEL ASSIGNED.
	POPJ	P,		;SHORT DISPATCH TABLE.
	MOVE	J,JOB		;IN CASE ITS NOT MAP
	MOVE	P1,T4		;GET KERNEL ROUTINE ADDRESS IN P1
	ADD	P1,T1
	CAIN	T1,DFVLR	;SKIP LOTS OF STUFF IF
	JRST	KERCH4		;VAL RIBS.
	HLLZ	T3,PDNMUP(P)	;GET UUO CALLER'S PC OFF STACK
				; (NOT FROM UPTMUP, MAY BE MONITOR DOING UUO)
	TLNN	T3,PC.USR	;FIND OUT IF THIS IS USER OR
	TDZA	T3,T3		;EXEC
	HRLZI	T3,400000	;MODE.
	MOVE	T2,T1		;SAVE ROUTINE FLAG IN T2.
	UMOVE	T1,(M)		;T1/ 1ST ARG.
	CAIE	T2,DVMAP	;BIT TO GO TO T1?
	CAIN	T2,DVSMAP	;
	JRST	.+2		;
	JRST	KERCH2		;NO, IT STAYS IN T3.
	TLZ	T1,400000	;T1 TO USER/EXEC
	IORM	T3,T1		;
	TLO	F,MAPB		;KEEP ATB AROUND
	MOVEM	F,%UPT+UPTJDA(W) ;AFTER CLOSE.
	MOVEI	P3,.ARCHM	;MAPPING IS CERTAINLY CHANGING THE MAP
	PUSHJ	P,SWRUPX	;WRITE LOCK %UPX AND SETUP J
	  JRST	[MOVSS T1	;GET VP # IN LH
		 HRRI T1,FALOFF
		 DPB P3,FDEERP<T1> ;PUT SUB ERROR CODE IN
		 LDB M,PUUOAC	;GET USER'S AC NUMBER
		 UMOVEM T1,(M)
		 POPJ P,]	;GIVE ERROR RETURN.
KERCH2:	CAIN	T2,DFTRN	;FTRUNC,
	JRST	KERCH4		;
	CAIE	T2,DFCRE	;FCREATE AND
	CAIN	T2,DFDEL	;FDELETE ONLY NEED 1 ARG.
	JRST	.+2		;
	UMOVE	T2,1(M)		;VMAP, VSMAP, FFIFP, AND FEXCH TAKE TWO.
KERCH4:	PUSH	P,M		;SAVE M.
	PUSHJ	P,(P1)		;DISPATCH TO KERNEL.
	JRST	KERERR		;ERROR RETURN.
	POP	P,M		;RESTORE M.
	JRST	CPOPJ1		;SUCCESS RETURN.


    ;HERE ON ERROR.
KERERR:	POP	P,M		;RESTORE M.
	LDB	T2,PUUOAC	;GET T2/ USER'S AC ADDRESS.
	UMOVEM	T1,(T2)		;RETURN ERROR INFO TO USER.
	POPJ	P,

COMMENT #
HERE FOR .FOREP, FRAME REPLICATE PAGE.
 GIVES SAME ERROR CODES AS VREPLC.
 CALL IS

	MOVE	AC,[FN,,FD]
	FRMOP	AC,[<DESTINATION DESCRIPTOR>
		    <SOURCE DESCRIPTOR>]
	  <ERROR RETURN>	;ERRO CODE SAME AS REPLICATE
	<SUCCESS RETURN>
#


FRMREP::HRRZ	T1,M		;GET THIS INTO T1 FOR XREPLU
	JRST	XREPLU		;FD IS IN P4 ALREADY.

;HERE FOR .FOVCL AND .FOVRM FRMOP FUNCTIONS - DO VCLEAR AND VREMOV
; FOR SPECIFIED FRAME. CALL IS
COMMENT #
	MOVE	AC,[FN,,FD]
	FRMOP	AC,[PAGE DESCRIPTOR]
	  <ERROR>		;RETURNS SAME FUNCTION CODES AS VREMOV OR VCLEAR
	<SUCCESS>
#

EXTERNAL FDWUPX

FRMVCL::SKIPA	P1,[KCLEAR]	;SET UP FOR CLEAR
FRMVRM::MOVEI	P1,[KREMOV]	;REMOV
	MOVEI	P3,.ARCHM	;NEED CHANGE MAP ACCESS FOR THIS
	PUSHJ	P,FDWUPX	;LOCK PAGES, CHECK RIGHTS
	  JRST	FRMNVC		;CAN'T DO IT, RETURN ERROR
	UMOVE	T1,(M)		;GET THE ARG TO REMOVE
	TLO	T1,(1B0)	;ALWAYS LOOK LIKE USER - DON'T ALLOW
				; MONITOR TO REMOVE ANOTHER FRAME'S PER PROCESS PAGES
	MOVE	M,W		;SET M TO ADDRESS FOR ERROR CODE
	PJRST	KERUUO		;ALL SET, GO DO IT.

FRMNVC:	XCTFU	<HRLZS T1,(M)>	;GET VP NUMBER IN LH
	HRRI	T1,FALOFF	;"OTHER FRAME FAILURE"
	DPB	P3,FDEERP<T1>	;PUT SUB ERROR CODE IN
	UMOVEM	T1,(W)		;PUT IN AC
	POPJ	P,		;AND GIVE NON-SKIP ERROR RETURN.

SUBTTL REPLICATE,REMOVE,CLEAR,VFSTAT---VM PAGE UUO DISPATCHES
;UUO VREPLICATE VM PAGE FUNCTION.
;
;CALL HAS THE FORM:
;
;    MOVEI	AC,ADDR
;    VREPLC	AC,
;    ERROR RETURN
;    SUCCESS RETURN
;
;WHERE ADDR CONTAINS:
;    BYTE (1)0(4)0(3)PROTECT(^D10)CONTIG PGS(8)0(10)1ST DEST VP
;
;AND ADDR+1 CONTAINS:
;    1ST SOURCE VP.

EXTERNAL UPTJOB,OTFFLG,WLKUPT,ULDUPX,UNWUPT,UNIUPT,FALOFF,CPRRED
EXTERNAL FD2FNO,UPTOFD,WLKUPX,CHEKAR,FECLP%


EXTERN KREPLC,KREMOV,KCLEAR,KFILCK,SWRUPX,SRDUPX

VREPLU::
	UMOVE	T2,(T1)		;USER ARG:  DOES IT HAVE
	TLNE	T2,OTFFLG	;"OTHER FRAME" FLAG?
	SKIPA	P4,%UPT+UPTOFD	;YES,PICK UP THE FD
	MOVEI	P4,.FDSLF	;NO,DOING REPLICATE TO SELF

;HERE FROM FRMOP REPLICATE FUNCTION WITH FD IN P4, ADDRESS IN T1

XREPLU:	PUSH	P,W		;SAVE M FOR ERROR CODE STORE.
	UMOVE	M,1(T1)		;GET USER'S ARGS IN M AND W FOR NOW
	UMOVE	W,(T1)
	HLLZ	T3,PDNMUP-1(P)	;GET T3/ EXEC VS. USER FLAG.
	TLNN	T3,PC.USR	;SET USER-
	TLZA	W,400000	;EXEC
	TLO	W,400000	;FLAG.
	PUSHJ	P,FD2FNO	;GET FRAME NUMBER IN J FOR SELF CHECK
	  JRST	REPRL0		;OTHER FRAME DESCRIPTOR IS BAD.
	CAME	J,%UPT+UPTJOB	;SAME AS CALLER?
	JRST	VREPL1		;NO, DON'T WORRY.
	TLZ	W,OTFFLG	;YES, DON'T TRY TO LOCK SAME CTX PAGES IN 2 PLACES
	TLZ	M,OTFFLG	;MAKE BELIEVE CALLER SAID BOTH FROM HIS SPACE
	JRST	VREPL2		;GO DIRECTLY TO LOCK UPT.
VREPL1:	TLNE	W,OTFFLG	;IF EITHER SOURCE OR DEST IS SELF,
	TLNN	M,OTFFLG	;
	JRST	VREPL2		;NEED TO LOCK UPT
	JRST	VREPL5		;BOTH "OTHER", MUST LOCK UPX.
VREPL2:	TLNN	W,OTFFLG	;IF EITHER SOURCE OR DEST IS OTHER
	TLNE	M,OTFFLG	; NEED UPX
	JRST	VREPL6		;NEEDED
	JRST	VREPL7		;NOT NEEEDED
VREPL6:	MOVE	T1,%UPT+UPTJOB	;GET JOB NUMBER OF RUNNING JOB
	CAML	J,T1		;GET LOCKS IN CANNONICAL ORDER
				; TO AVOID DEADLOCK
	JRST	[PUSHJ	P,WLKUPT	;GET WRITE LOCK FOR OWN 
					; CONTEXT PAGES.
		   STOPCD		;CAN'T LOCK CONTEXT PAGES
					; (SHOULD NEVER HAPPEN).
		 JRST	VREPL5]		;NOW GET UPX LOCK
	PUSHJ	P,VREPLX	;GET UPX LOCK
VREPL7:	PUSHJ	P,WLKUPT	;GET OWN CTX PGS WRITE LOCK
	  STOPCD		;CAN'T, SHOULD NEVER HAPPEN
	JRST	VREPL4		;NOW HAVE REQUIRED LOCKS
VREPL5:	PUSHJ	P,VREPLX	;GET UPX LOCK

VREPL4:	MOVE	T1,W		;GET ARGS BACK IN T1 AND T2
	MOVE	T2,M
	PUSH	P,T1		;SAVE ARGS SO KNOW WHAT TO GIVE BACK
	PUSH	P,T2
	PUSHJ	P,KREPLC	;CALL KERNEL ROUTINE, ALWAYS 
	  JRST	REPLER
	POP	P,M
	POP	P,W		;GET ARGS BACK
	POP	P,U		;GET USER'S AC NUMBER
	AOS	(P)		;GIVE SKIP RETURN.

REPRLS:	TLNN	W,OTFFLG
	TLNE	M,OTFFLG	;IF EITHER WAS A REAL OTHER FRAME,
	PUSHJ	P,ULDUPX	;RELEASE WRITE LOCK AND LOCKDOWN OF %UPX.
REPRS1:	TLNE	W,OTFFLG	;IF EITHER WAS SELF,
	TLNN	M,OTFFLG
	PJRST	UNWUPT		;GIVE BACK WRITE LOCK OF UPT AND RETURN.
	POPJ	P,		;DIDN'T HAVE UPT LOCK SO JUST RETURN.

;GET UPX LOCK
VREPLX:	PUSHJ	P,WLKUPX	;TRY TO GET CONTEXT PAGES IN
	  JRST	[MOVEI P3,FECLP% ;CAN'T LOCK CONTEXT PAGE ERROR IN P3
		 POP	P,T1	;FLUSH RETURN ADDR
		 JRST REPRLU]	;AND GIVE ERROR
	MOVEI	P3,.ARCHM	;GET READY
	TLNN	W,OTFFLG	;REPLICATING TO OTHER FRAME?
	JRST	VREP3A		;NO, DON'T NEED CHANGE MAP STATUS
	PUSH	P,P4		;SAVE OFD IN CASE ITS FRMOP CALL
	PUSHJ	P,CHEKAR	;YES, CAN HE CHANGE THE MAP FOR C(P4)?
	  JRST	[POP P,P4
		 POP	P,T1	;FLUSH RETURN ADDR
		 JRST REPRLX]	;NO
	POP	P,P4		;RESTORE
VREP3A:	TLNN	M,OTFFLG	;IS HE REPLICATING FROM OTHER FRAME?
	POPJ	P,		;NO, DONE CHECKING.
	MOVEI	P3,.ARVAW	;ASSUME HE'S TRYING MAX WRITE
	LDB	T4,[POINT 2,W,7] ;GET PROTECTION
	CAIG	T4,CPRRED	;SKIP IF WRITING.
	MOVEI	P3,.ARVAR	;NO, JUST READING
	PUSHJ	P,CHEKAR	;CHECK ACCESS, SET UP J AND %UPX WRITE LOCKED
	  JRST	[POP	P,T1	;FLUSH RETURN ADDR
		 JRST	REPRLX]	;SOMETHING WENT WRONG.
	POPJ	P,

REPLER:	POP	P,M
	POP	P,W
	POP	P,U
	UMOVEM	T1,(U)		;STORE ERROR CODE (ITS AC, SO BETTER NOT FAULT)
	JRST	REPRLS		;AND GO RELEASE ANY LOCK WE HAVE

;HERE FOR ERRORS WHILE SETTING UP LOCKS.

;HERE IF POSSIBLY GOT UPT LOCK BUT CAN'T GET UPX LOCK.

REPRLX:	PUSHJ	P,ULDUPX	;WE KNOW WE HAVE THIS IF WE COME HERE.
REPRLU:	PUSHJ	P,UNIUPT	;GET RID OF UPT IF HAVE IT.
REPRL0:	POP	P,U		;GET AC NUMBER OFF STACK
	MOVEI	T1,FALOFF	;CAN'T LOCK CONTEXT PAGES
	HRL	T1,W		;GET W IN LH
	DPB	P3,FDEERP<T1> ;PUT SUB ERROR CODE IN.
	UMOVEM	T1,(U)		;STORE IN USER'S AC
	POPJ	P,		;RETURN.

;REMOVE A PAGE AND CLEAR PAGE FUNCTIONS.
;
;CALL HAS THE FORM:
;
;    MOVE AC,[BYTE (1)0(6)0(1)CLR REF(10)CONTIG PGS(8)0(10)START PAGE]
;    VREMOV	AC, OR VCLEAR AC,
;    ERROR RETURN
;    SUCCESS RETURN
;

EXTERNAL SWRUPX,FALOFF


VCLEAU::SKIPA	P1,[KCLEAR]	;ENTRY FOR VCLEAR
VREMOU::MOVEI	P1,KREMOV	;
VREMV2:	MOVE	T2,PDNMUP(P)	;GET CALLER'S PC
	TLNN	T2,PC.USR	;IF EXEC,
	TLZA	T1,(1B0)	;TURN OFF USER FLAG TO KERNEL ROUTINE
	TLO	T1,(1B0)	;IS USER.
	MOVEI	P3,.ARCHM	;MUST BE ABLE TO CHANGE MAP TO DO THIS.
	PUSHJ	P,SWRUPX	;CALL CO-ROUTINE TO WRITE LOCK UPX
	  JRST	[MOVSS T1	;PAGE #,,
		 HRRI T1,FALOFF ;CAN'T LOCK CONTEXT PAGES IN RH
		 DPB P3,FDEERP<T1>
		 UMOVEM T1,(M)  ;STORE ERROR CODE
		 POPJ P,]	;AND RETURN WITH ERROR.
KERUUO:	PUSH	P,M		;SAVE M.
	PUSHJ	P,(P1)		;
	JRST	KERUER		;ERROR RETURN.
	POP	P,M		;RESTORE M.
	JRST	CPOPJ1		;

KERUER:	POP	P,M		;RESTORE M.
	UMOVEM	T1,(M)		;STORE ERROR FLAGS.
	POPJ	P,		;FAIL RETURN.

;UUO SEE IF THE F BIT IS ON FOR THIS PAGE.
;
;CALL HAS THE FORM:
;
;    MOVEI AC, VP NUMBER
;    VFSTAT	AC,
;    ERROR RETURN
;    SUCCESS RETURN
;


VFLCKU::MOVEI	P1,KFILCK	;
	TLO	T1,(1B0)	;ALWAYS LOOKS LIKE USER CALLED
	JRST	KERUUO		;AND DISPATCH.

SUBTTL CLUB UUOS
;UUO ADD A JOB TO A CLUB.
;
;CALL HAS THE FORM:
;
;	MOVEI	AC,VP NUMBER
;	CLBADD	AC,
;	ERROR RETURN
;	SUCCESS RETURN


EXTERN KCBADD,KCBKER

UCBADD::MOVEI	P1,KCBADD
	JRST	KCBKER



;UUO REMOVE MY JOB FROM THE CLUB.
;
;CALL HAS THE FORM:
;
;	MOVEI	AC,VP NUMBER
;	CLBLEV	AC,
;	ERROR RETURN
;	SUCCESS RETURN


EXTERN KCBLEV

UCBLEV::MOVEI	P1,KCBLEV
	JRST	KCBKER



;UUO GET CLUB INTERLOCK (WAIT IF NECESSARY.).
;
;CALL HAS THE FORM:
;
;	MOVEI	AC,VP NUMBER
;	CLBINW	AC,
;	ERROR RETURN
;	SUCCESS RETURN


EXTERN KCBINW

UCBINW::MOVEI	P1,KCBINW
	JRST	KCBKER



;UUO GET CLUB INTERLOCK (IMMED.).
;
;CALL HAS THE FORM:
;
;	MOVE	AC,ADDR
;	CLBINI	AC,
;	ERROR RETURN
;	SUCCESS RETURN
;
;WHERE ADDR CONTAINS THE VP NUMBER.


EXTERN KCBINI

UCBINI::UMOVE	T1,(T1)		;GET T1/ USER'S ARG.
	MOVEI	P1,KCBINI
	JRST	KCBKER



;UUO RELEASE CLUB INTERLOCK.
;
;CALL HAS THE FORM:
;
;	MOVEI	AC,VP NUMBER
;	CLBRLI	AC,
;	ERROR RETURN
;	SUCCESS RETURN


EXTERN KCBRLI

UCBRLI::MOVEI	P1,KCBRLI
	JRST	KCBKER



;UUO GET COUNT OF AND ID NUMBERS OF THE MEMBERS OF THE CLUB.
;
;CALL HAS THE FORM:
;
;	MOVE	AC,ADDR
;	CLBMEM	AC,
;	ERROR RETURN
;	SUCCESS RETURN
;
;WHERE ADDR CONTAINS THE VP NUMBER, AND ADDR+1 CONTAINS THE
;NUMBER OF ID NUMBERS OF MEMBERS OF THE CLUB THAT ARE TO BE
;RETURNED (STARTING AT ADDR+1.).


EXTERN KCBMEM

UCBMEM::UMOVE	T2,1(T1)	;GET T1/ 1ST ARG AND
	UMOVE	T1,(T1)		;T2/ 2ND ARG FROM USER.
	MOVEI	P1,KCBMEM
	JRST	KCBKER



;UUO GET STATUS INFO ABOUT A MEMBER OF THE CLUB.
;
;CALL HAS THE FORM:
;
;	MOVE	AC,ADDR
;	CLBSTS	AC,
;	ERROR RETURN
;	SUCCESS RETURN
;
;WHERE ADDR CONTAINS THE VP NUMBER, AND ADDR+1 CONTAINS THE
;"ID NUMBER" OF THE OTHER JOB.


EXTERN KCBSTS

UCBSTS::UMOVE	T2,1(T1)	;GET T1/ 1ST ARG AND
	UMOVE	T1,(T1)		;T2/ 2ND ARG FROM USER.
	MOVEI	P1,KCBSTS
	JRST	KCBKER



;UUO WAKE JOB IN SAME CLUB.
;
;CALL HAS THE FORM:
;
;	MOVE	AC,ADDR
;	CLBWAK	AC,
;	ERROR RETURN
;	SUCCESS RETURN
;
;WHERE ADDR CONTAINS THE VP NUMBER AND ADDR+1 CONTAINS THE
;ID NUMBER OF THE JOB TO WAKE UP.


EXTERN KCBWAK

UCBWAK::UMOVE	T2,1(T1)	;GET T1/ 1ST ARG AND
	UMOVE	T1,(T1)		;T2/ 2ND ARG FROM USER.
	MOVEI	P1,KCBWAK
	JRST	KCBKER



;UUO HANG JOB IN SAME CLUB.
;
;CALL HAS THE FORM:
;
;	MOVE	AC,ADDR
;	CLBHNG	AC,
;	ERROR RETURN
;	SUCCESS RETURN
;
;WHERE ADDR CONTAINS THE VP NUMBER AND ADDR+1 CONTAINS THE
;ID NUMBER OF THE JOB TO HANG.


EXTERN KCBHNG

UCBHNG::UMOVE	T2,1(T1)	;GET T1/ 1ST ARG AND
	UMOVE	T1,(T1)		;T2/ 2ND ARG FROM USER.
	MOVEI	P1,KCBHNG
	JRST	KCBKER

SUBTTL VARIOUS UUOS
;RENAME M - HERE ON SHORT DISPATCH TABLE DEVICES TOO

EXTERNAL CPOPJ1

URENAM:	MOVEI T1,DRN
	PUSHJ P,CHNCHK		;2-SKIP IF LONG DISPATCH. T4/DEVSER(F)
	 JRST ERRIUC		;NO CHANNEL.
	JRST CPOPJ1		;SHORT DISPATCH TABLE. SKIP RETURN.
	PJRST DRN(T4)	;ATTEMPT A RENAME. SKIP RTN TO USER IF
			;SUCCESS

;GETF M - GET NEXT FREE BLOCK

UDGF:	MOVEI T1,DGF
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	POPJ P,			;NO-OP ON SHORT DISPATCH TABLE.
	JRST DGF(T4)

;MTAPE M - MAGTAPE OPERATIONS

UMTAPE:	MOVEI T1,DMT
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	POPJ P,			;SHORT DISPATCH TABLE.  NO OPERATION.
	PUSHJ P,DMT(T4)
	JRST DEVECK	;AND CHECK ERROR WHEN FINISHED

;MAGNUM BIT CHANIO
;
;ARGUMENT 34
;
;CHANIO AC,LOC
;ERROR RETURN
;SUCCESS RETURN

;LOC: RH IS FUNCTION
;	1 UPDATER WANTS TO SET/CLEAR FLAG IN ALL DDBS ON THIS 
;	  ATB.
;	2 READ AND CLEAR BIT IN OWN DDB.
;	3 IS THIS FILE BEING UPDATED?
;	4 I HAVE THIS FILE OPEN FOR UPDATE; IS THERE ALSO
;	  A READER OF IT?
;
;	LH HAS MEANING ONLY FOR FUNCTION 1, IN WHICH CASE IT
;	MEANS 0(1) CLEAR(SET).

;ON SUCCESS RETURN FOR FN 2, LOC+1 IS 0(1) IF BIT
;WAS OFF(ON).
;ON SUCCESS RETURN FOR FN 3, LOC+1 IS 0(1) IF THE FILE
;IS NOT OPEN (OPEN) FOR SINGLE UPDATE.
;ON SUCCESS RETURN FOR FN 4, LOC+1 IS 0(1) IF THE FILE
;IS NOT BEING (BEING) ALSO READ.
;ON SUCCESS RETURN FOR FN 5, LOC+1 IS # UPDATE CHANNELS IN LH,
;# VPS MAPPED FROM FILE FOR ALL USERS OF FILE WITH
;MAX WRITE ON IN RH.
;
;THIS CHANIO IS A NO-OP FOR NON-DISK DEVICES AND ALWAYS TAKES
;THE 1-SKIP RETURN FOR THEM.

EXTERN ATBFNB,ATBSTS,ATPUPD,DEPMGN,DEVBTS,DEVATB,DEVDBL,FNBDBL
EXTERN ATYCNT,ATBMWC,FNBUPD

MGNBIT:	SETZ	T1,		;SET UP F AND
	PUSHJ	P,CHNCHK	;FRIENDS.
	JRST	ERRIUC		;NO CHANNEL ASSIGNED.
	JRST	.+1		;NO WAY TO GET HERE.
	MOVE	T1,DEVMOD(F)	;IS THIS A
	TLNN	T1,DVDSK	;DISK?
	JRST	CPOPJ1		;NO.
	UMOVE	T3,(M)		;GET T1/ POSSIBLE ARG
	HLRZ	T1,T3		;FOR FN 1, AND
	HRRZI	T3,(T3)		;T3/ FUNCTION NUMBER.
	CAILE	T3,MGNTLN	;FUNCTION DEFINED?
	POPJ	P,		;NO.
	JUMPE	T3,CPOPJ	;MAYBE STILL NO.
	MOVE	T3,MGNTBL-1(T3)	;GET DISPATCH ADDRESS AND
	JRST	(T3)		;GO.

MGNTBL:	MGNUPD
	MGNRAC
	MGNCKU
	MGNCKR
	MGNSUD		;SIMULTANEOUS UPDATE INFO

MGNTLN==.-MGNTBL


;FUNCTION ONE.
;SET OR CLEAR FLAGS IN ALL DDBS ON THIS ATB.
MGNUPD:	CAILE	T1,1		;FLAG MUST SAY
	POPJ	P,		;CLEAR OR SET.
	PUSHJ	P,MEUPDR	;AM I THE UPDATER OF THIS FILE?
	POPJ	P,		;NO.
	HRRZ	T4,ATBFNB(T3)	;YES.  GET FNB TO
	HRRZ	F,FNBDBL(T4)	;GET FIRST DDB ADDRESS.
	HRLZI	T4,DEPMGN	;T4 HOLDS FLAG BIT.
MGNBT4:	HRRZ	T2,DEVATB(F)	;DOES THIS DDB POINT TO
	CAME	T2,T3		;OUR ATB?
	JRST	MGNTB6		;NO, SKIP IT.
	JUMPE	T1,.+3		;YES. DO WE WANT TO CLEAR THE FLAG?
	IORM	T4,DEVBTS(F)	;NO, SET THE FLAG.
	JRST	MGNTB6		;
	ANDCAM	T4,DEVBTS(F)	;YES, CLEAR THE FLAG.
MGNTB6:	HRRZ	F,DEVDBL(F)	;GET NEXT DDB.
	JUMPN	F,MGNBT4	;JUMP IF ANOTHER.
	JRST	CPOPJ1		;ALL DONE.

;FUNCTION TWO.
;READ AND THEN CLEAR THE BIT IN OUR DDB.
MGNRAC:	MOVE	T1,DEVBTS(F)	;GET THE BIT.
	SETZ	T2,		;SET LOC+1 TO
	TLNE	T1,DEPMGN	;ZERO UNLESS THE
	MOVEI	T2,1		;BIT IS
	UMOVEM	T2,1(M)		;SET.
	HRLZI	T2,DEPMGN	;TURN OFF
	ANDCAM	T2,DEVBTS(F)	;THE BIT.
	JRST	CPOPJ1		;RETURN.

;FUNCTION THREE.
;IS THIS FILE BEING UPDATED?
MGNCKU:	HRRZ	T2,DEVATB(F)	;BETTER BE A
	JUMPE	T2,CPOPJ	;FILE OPEN FOR US.
	SETZ	T4,		;
	MOVE	T1,ATBSTS(T2)	;IS THE FILE BEING
	TRNE	T1,ATPUPD	;UPDATED IN SINGLE MODE?
	MOVEI	T4,1		;YES.
	UMOVEM	T4,1(M)
	JRST	CPOPJ1

;FUNCTION FOUR.
;I AM UPDATING THIS FILE; DOES IT ALSO HAVE A READER?
MGNCKR:	PUSHJ	P,MEUPDR	;AM I UPDATING THIS FILE?
	POPJ	P,		;NO.
	EXCH	P2,T3		;SAVE P2 AND SET IT UP FOR
	LDB	T4,ATYCNT	;ATYCNT.
	MOVE	P2,T3		;RESTORE P2.
	CAIGE	T4,2		;A READER?
	TDZA	T3,T3		;NO.
	MOVEI	T3,1		;YES.
	UMOVEM	T3,1(M)
	JRST	CPOPJ1

;FUNCTION FIVE.
;RETURN # UPDATING CHANNELS,,# VPS FOR ALL FILE USERS MAPPED WRITABLE FROM THIS FILE.

MGNSUD:	HRRZ	T2,DEVATB(F)	;GET ATB
	JUMPE	T2,CPOPJ	;MUST HAVE A FILE OPEN ON THIS CHAN
	HRRZ	T1,ATBMWC(T2)	;CHANNELS PLUS PAGES
	HRRZ	T2,ATBFNB(T2)	;GET FNB ADDRESS
	HRRZ	T2,FNBUPD(T2)	;GET UPDATING CHANNEL COUNT
	SUB	T1,T2		;T1 = 0,,PAGES
	HRL	T1,T2		;T1 = CHANNELS,,PAGES
	UMOVEM	T1,1(M)		;RETURN ARG TO USER
	JRST	CPOPJ1		;GOOD RETURN.




MEUPDR:	TLNE	F,ENTRB		;IF WE ARE THE UPDATER,
	TLNN	F,LOOKB		;THEN BOTH ENTRB AND LOOKB
	POPJ	P,		;MUST BE SET, AND NEITHER OF
	TLNN	F,ICLOSB	;THEM CAN HAVE BEEN
	TLNE	F,OCLOSB	;CLOSED.
	POPJ	P,		;
	HRRZ	T3,DEVATB(F)	;SAVE OUR ATB FOR COMPARE.
	MOVE	T4,ATBSTS(T3)	;MAKE SURE OF
	TRNE	T4,ATPUPD	;UPDATE MODE.
	AOS	(P)		;YES.
	POPJ	P,

;USETI UUO - SET NEXT INPUT BLOCK NUMBER

FWUSI:	XCTBU <SKIPA M,(M)>	;GET FULL WORD ARGUMENT
UDSI:	HRRZS M			;CLEAR (FOR 2 KINDS OF USETI
UDSIP:	MOVEI T1,0
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	POPJ P,			;NO-OP ON SHORT DISPATCH TABLE.
UDSIP0:	PUSHJ P,WAITIO
	LDB T1,PIOMOD
	CAIGE T1,SD
	TLNE F,ICLOSB
	JRST UDSI1		;NO BUFFERS TO CLEAN UP
	TLNE F,INBFB+INPB	;AND BUFFERS?
	PUSHJ P,BFICLN		;CLEAR THEM
UDSI1:	MOVEI T1,DSI
	PUSHJ P,CHNCK2
	 POPJ P,		;NOT IN TABLE (ALWAYS CLEAR BUFFERS)
	PUSHJ P,DSI(T4)
	JRST DEVECK		;EXIT WITH ERROR CHECK

PGUSI:	UMOVE M,(M)
	JUMPLE	M,UDSIP
	SETZ	T1,
	PUSHJ	P,CHNCHK	;SET UP ACS.
	JRST	ERRIUC
	POPJ	P,
	LSH	M,2
IOSUPR=100000
	TLNN	S,IOSUPR
	TLNN	F,LOOKB!ENTRB
	JRST	UDSIP0
	SUBI	M,3
	JRST UDSIP0

PGUSO:	UMOVE M,(M)
	JUMPLE	M,UDSOP
	SETZ	T1,
	PUSHJ	P,CHNCHK
	JRST	ERRIUC
	POPJ	P,
	LSH	M,2
	TLNN	S,IOSUPR
	TLNN	F,ENTRB
	JRST	UDSOP0
	SUBI	M,3
	JRST UDSOP0	;AND FOR USETO

;USETO UUO - SET NEXT OUTPUT BLOCK NUMBER

FWUSO:	XCTBU <SKIPA M,(M)>	;FULL WORD ARGUMENT
UDSO:	HRRZS M
UDSOP:	MOVEI T1,0
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	POPJ P,			;NO-OP ON SHORT DISPATCH TABLE.
UDSOP0:	PUSHJ P,WAITIO	;WAIT FOR DEVICE TO STOP
	LDB T1,PIOMOD		;MUST CLEAN UP BUFFERS
	CAIGE T1,SD
	TLNE F,OCLOSB		;IF DUMP OR CLOSED
	JRST UDSO4		;NO BUFFERS TO CLEAN
	TLNN F,OUTBFB+OUTPB	;AND BUFFERS?
	JRST UDSO4		;NO
	HLRZ U,DEVBUF(F)
	XCTBU <SKIPG (U)>	;VIRGIN RING?
	JRST UDSO4		;YES
UDSO2:	HRRZ T1,DEVOAD(F)
	XCTBU <SKIPL (T1)>	;IS THIS BUFFER TO BE DUMPED?
	JRST UDSO3		;NO PROCEED
	TRZ S,760000		;CLEAR ERROR BITS
	TLO S,IO		;MUST BE ON FOR DSK,OUTPUT
	PUSH P,M
	LDB T2,DEYCLS
	XCT CLOBUF(T2)	;WORRY ABOUT SETTIN UP A COMMAND LIST
	JRST UDSO2C	;CLASS DEPENDENT CODE DID IT ALL
	HRRZ T4,DEVSER(F)	;MAKE SURE STILL AROUND
	PUSHJ P,DOU(T4)		;START DEVICE
	PUSHJ P,WAIT1
UDSO2C:	POP P,M
	TRNN S,760000		;CHECK FOR ERRORS
	JRST UDSO2		;NONE- SEE IF MORE TO BE DUMPED
UDSO3:	HLRZ T2,DEVBUF(F)
	UMOVE T3,(T2)		;NOW SEE IF LAST BUFFER TO BE WRITTEN
	TLNE T3,IOADVB
	JRST UDSO3A		;ADVANCED, JUST CALL OUT
	XCTBU <HRRZ U,1(T2)>		;GET BYTE POINTER
	SKIPE U			;IGNORE IF NONE
	SUBI U,1(T3)		;COMPUTE WORD COUNT
	TRNE S,IOWC		;COMPUTING OWN WORD COUNT?
	XCTBU <HRRZ U,1(T3)>		;YES, GET IT
	JUMPE U,UDSO1		;NOTHING TO DUMP
UDSO3A:	PUSH P,M
	HLLZS M			;MAKE SURE OF 0 SO DON'T THINK A BUFFER CHANGE
	PUSHJ P,OUT		;DUMP LAST BUFFER
	PUSHJ P,WAIT1
	POP P,M
UDSO1:	HRRZ T4,DEVSER(F)
UDSO4:	MOVEI T1,DSO
	PUSHJ P,CHNCK2
	 POPJ P,		;DONE

	PUSHJ P,DSO(T4)
	JRST DEVECK	;AND AN ERROR CHECK

SUBTTL IN,INPUT		OUTPUT,OUT

XP STDRNG,4	;NUMBER OF BUFFERS IN STANDARD RING

;INPUT UUO


;1)  IF OUTPUT ACTIVE ON THIS CHANNEL, WAIT FOR IT TO COMPLETE.
;2)  IF DUMP MODE, WAIT FOR DEVICE INACTIVE, CALL SERVICE
;	ROUTINE TO START INPUT, WAIT TILL COMPLETE, THEN RETURN TO USER.
;3)  IF NO BUFFER RING SETUP, SET UP 2 RING BUFFER.
;4)  IF FIRST REFERENCE, START SERVICE ROUTINE, GO TO
;5)  FLAG CURRENT BUFFER AS FREE TO RECEIVE MORE INPUT
;	(USE BIT SET TO 0).
;	START SERVICE ROUTINE FILLING FIRST BUFFER WITH USE BIT 0
;	(NEXT BUFFER OR ONE AHEAD OF IT)
;	(SERVICE ROUTINE WILL SET USE BIT WHEN IT FINISHES FILLING
;	BUFFER).
;7)  IF NEXT INPUT BUFFER IS FULL OF DATA, GO TO 10).
;8)  PUT JOB IN IO WAIT TILL NEXT BUFFER FILLED.
;9)  IF NEXT INPUT BUFFER STILL NOT FILLED, CHECK FOR END
;	OF FILE OR ERROR BITS SET BY SERVICE ROUTINE.
;10) CONVERT WORD COUNT AS STORED BY SERVICE ROUTINE IN THIRD
;	WORD OF BUFFER TO J COUNT AND STORE IN THIRD WORD
;	OF HEADER (J COUNT) ALSO SET BYTE POINTER (SECOND
;	WORD OF HEADER) AND RETURN TO USER.

CNGIN:	TRNN M,-1	;IS USER CHANGING RINGS
	POPJ P,		;NO - RETURN IMMEDIATELY
	PUSHJ  P,WAIT1	;WAIT FOR I/O TO COMPLETE
	TRNN T2,-1		;DID HE HAVE A PREVIOUS BUFFER?
	JRST SETNEW		;NO - SKIP NEXT
	TLO T1,IOADVB	;THIS ONE OFF TOO
	XCTBU <ANDCAM T1,(T2)>	;AND THEN MAKE IT AVAILABLE
	TLZ T1,IOADVB	;AND CLEAR IT AGAIN
SETNEW:	XCTBU <HRRM M,(U)>		;POINT HEADER TO NEW RING
	HRLI T2,IOUSE		;GET SET TO SET BIT
	HRR T2,M		;AND LOAD NEW POINTER
	XCTBU <IORM T1,(U)>		;VIRGIN BIT FOR NEW RING
	MOVE S,DEVIOS(F)	;LOAD S JUST IN CASE
	POPJ P,0		;RETURN WITH TRANSPARENT CHANGES
EXTERNAL DEYCLS,DEYMCT,DEYTCT,GET4WD,FCWAIT,FCREQ
EXTERNAL GIV4WD,DEVEC1

IN:	MOVEI T1,DIN
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	JFCL			;SHORT DISPATCH TABLE OK.
	PUSHJ P,INCOM
	PUSHJ	P,GETSTS	;GET STATUS
	HRR	S,T1
	JRST 	DEVEC1

INCOM:	TLNE S,IO		;IS THIS DEVICE ALREADY DOING OUTPUT?
	PUSHJ P,WAITO		;YES, WAIT TILL IT IS FINISHED.
	TLO F,INPB		;FOR THIS DEVICE.
	TLZ F,ICLOSB
	HLLM F,%UPT+UPTJDA(W)	;IN LH OF CURRENT JOB DEVICE CHANNEL
	LDB T1,PIOMOD		;IO MODE
	CAIL T1,SD		;IT THE IO MODE DUMP(SD,D,DR)?
	JRST INDMP		;YES
IN1:	HRR U,DEVBUF(F)	;NO, GET ADDRESS OF BUFFER HEADER
	HRLZI T1,IOUSE		;BUFFER INUSE BIT
	MOVE S,DEVIOS(F)	;SETUP IO STATUS AGAIN FORM FROM MEMORY
				; AC S IS CLOBBERED BY AUTOMATIC CORE EXPANSION
				; ON AN IMPLICIT INBUF ON FIRST INPUT
	UMOVE T2,(U)		;GET WORD 1 OF 3 WORD BUFFER HEADER.
	PUSHJ P,CNGIN		;GO SEE IF USER CHANGING RINGS
	JUMPLE T2,INPUTF		;THIS IS STILL HERE
	MOVE	S,DEVIOS(F)
	TLNE T2,IOADVB		;IS BUFFER ALREADY ADVANCED?
	JRST INPUT4	;YES
	XCTBU <ANDCAB T1,(T2)>	;FLAG CURRENT BUFFER AS FREE TO
				; RECEIVE MORE INPUT, CLEAR USE BIT
				; AND GET POINTER TO NEXT BUFFER
	XCTBU <HRRM T1,(U)>		;SET WORD 1 IN 3 WORD HEADER TO NEXT BUFFER
	MOVSI P1,IOADVB
	XCTBU <IORM P1,(U)>	;NOW WE HAVE IT SET IN CASE INTERUPT
INPUT4:	LDB	P1,DEYCLS	;GET CLASS INDEX
	XCT	CLAI(P1)	;CALL CLASS DEP. CODE
	JRST	INPUT2
	TRNE S,IOACT		;IS THE DEVICE ALREADY ACTIVE
	JRST INPT0C		;YES
	XCTBU <HRRZ T1,(U)>	;MAKE SURE THIS POINTS TO CURRENT

	MOVE P1,DEVMOD(F)	;GET DEVICE CHARACTERISTIC WORD
	TLNN P1,DVTTY!DVRMT		;IS IT A TTY?
	TRNE S,IOCON		;DO NOT LOOK AHEAD IF SYNC MODE
	SKIPA
	XCTBU <HRR T1,(T1)>		;GET POINTER 1 BUFFER AHEAD OF NEXT BUFFER
				; IF NOT TTY.
	XCTBU <SKIPGE (T1)>		;IS THE USE BIT SET?
	JRST	INPT0C		;BUFFER IIS FULL
	TRNN	S,760000	;ANY ERRORS?
	JRST	INPT0B		;NO. HANDLE NORMALLY
	XCTBU <HRRZ T1,(U)>		;ADDRESS OF NEXT BUFFER
	XCTBU <SKIPGE (T1)>	;CURRENT BUFFER FULL?
	JRST	INPT0C		;YES
INPT0B:	PUSHJ P,CALIN		;NO, START SERVICE ROUTINE FILLING EMPTY BUFFER
INPT0C:	XCTBU <HRR T2,(U)>		;GET USE BIT FOR NEXT BUFFER
INPT0A:	XCTBU <SKIPGE (T2)>		;IS USE BIT SET YET?(BUFFER FILLED YET?)
	JRST INPUT2		;YES, RETURN IMMEDIATELY TO USER
INPT2:	PUSHJ P,WSYNC		;NO, PUT JOB IN IO WAIT TILL BUFFER FILLED.
	XCTBU <SKIPL (T2)>		;RETURN WHEN BUFFER FILLED. CHECK TO MAKE SURE.
	JRST INEOF1		;NO, MUST BE EOF OR ERROR
INPUT2:	UMOVE J,1(T2)		;RH OF 3RD WORD(FIRST SO-CALLED DATA WORD)
	MOVSI T1,IOADVB
	XCTBU <ANDCAM T1,(U)>	;CLEAR THE BIT SO ADVANCE NEXT TIME
	JRST IOSETC	;SET J COUNT AND BYTE POINTER
				; IN 3 WORD HEADER AND RETURN TO USER

INEOF1:	LDB 	T1,DEYCLS
	XCT	CLAI(T1)	;NEED TO ADV SINCE CALIN STARTED DEVICE
	JRST	INPUT2
	XCTBU <SKIPGE (T2)>
	JRST	INPUT2
	TDNN S,[XWD IOEND,IODERR+IOBKTL+IODTER+IOIMPM]
				; EOF OR ERROR BIT SET BY SERVICE ROUTINE
	JRST INEOF2	;POSSIBLY FT DOING SKIP
	MOVSI T1,IOADVB
	XCTBU <ANDCAM T1,(U)>
	TLNE S,IOEND		;IS THIS EOF?
	TRO S,IODEND		;YES, SET USER EOF BIT.
	IORM S,DEVIOS(F)
	POPJ P,		;RETURN TO USER'S PROGRAM


INEOF2:	HRRZ U,DEVBUF(F)
	XCTBU <HRR T2,(U)>	;GET REGISTERS RESET
	TRNE S,IOACT	;IS DEVICE ACTIVE?
	JRST INPT0A	;YES, WAIT FOR IT TO STOP IF BUFFER NOT FULL
	LDB T1,DEYCLS
	XCT CLAI(T1)	;DEVICE STOPPED, MAY NEED TO FINISH ADVBFF
	JRST INPUT2	;DEVICE ROUTINE DID IT, RETURN
	XCTBU <SKIPGE (T2)>	;IS BUFFER FULL NOW?
	JRST INPUT2	;YES, RETURN TO USER
	HRRM T2,DEVIAD(F)	;MAKE SURE USER POINTS TO THIS RING
	JRST INPT0B	;AND CONTINUE

;HERE ON FIRST INPUT AFTER INIT, INIT & LOOKUP, OR INIT & LOOKUP & INPUT
INPUTF:	TLO T1,IOADVB	;MAKE SURE THIS IS CLEARED TOO
	XCTBU <ANDCAB T1,(U)>	;MARK THAT BUFFERS HAVE BEEN REFER
				; BY CLEARING SIGN BIT OF 1ST WORD IN 3 WORD
				; IN 3 WORD BUFFER HEADER
	JUMPE T1,INPUT3	;HAS A RING BEEN SET UP YET?
	PUSHJ P,WAIT1		;WAIT FOR I/O TO STOP
	HRRM T1,DEVIAD(F)	;YES, STORE ADR. OF 2ND WORD OF
				; A BUFFER FOR SERVICE ROUTINE
	MOVSI T1,IOADVB		;IN CASE CLAI(T1) TRAPS & WE
	XCTBU <IORM T1,(U)>	;RE-EXECUTE THE INPUT. AAA DEC 76
	LDB	T1,DEYCLS	; CLASS INDEX
	XCT	CLAI(T1)	;CALL CLASS DEPENDENT ROUTINE
	JRST	INPUT2
	JRST INPT0B
INPUT3:	HRRI M,STDRNG	;RING NOT SETUP YET,SETUP STD SIZE RING
	PUSHJ P, UINBF
	HLLZS M		;CLEAR RIGHT HALF
	JRST IN1

INDMP:	PUSHJ P,WSYNC		;INPUT DUMP
	MOVSI S,IO
	ANDCAB S,DEVIOS(F)	;FORCE TO INPUT STATE
	LDB	T1,DEYCLS	;CLASS INDEX
	XCT	CLIDMP(T1)	;CALL DUMP CLASS ROUTINE
	POPJ P,		;DUMP MODE IS FINISHED
	HRRZ	T4,DEVSER(F)
	PUSHJ P,DDI(T4)	;CALL SERVICE ROUTINE
	JRST WAIT1		;THEN WAIT TILL IO  FINISHED BEFORE
				; RETURNING TO USER.

; WAIT FOR I/O TO COMPLETE AND MAKE SURE BUFFERS HAVE BEEN ADVANCED
INTERNAL WAITIO
WAITIO:	TLNE S,IO	;OUTPUT?
	JRST WAITO	;NO. INPUT- SO WAIT FOR OUTPUT TO FINISH
WAITI:	PUSHJ P,WAIT1
	LDB T1,DEYCLS
	XCT WCLAI(T1)	;CALL CLASS DEPENDENT ROUTINE TO ADVANCE BUFFERS
	JFCL
	POPJ P,
WAITO:	PUSHJ P,WAIT1
	LDB T1,DEYCLS
	XCT WCLA(T1)
	JFCL
	POPJ P,

WCLAI:	SKIPA		;NO NEED TOCALL CLASS ROUTINE 
	SKIPA
	XCT CLAI(T1)	;CALL CLASS ROUTINE FOR DSK
	XCT CLAI(T1)	;AND MT

WCLA:	SKIPA
	SKIPA
	XCT CLA(T1)
	XCT CLA(T1)

;
;  CLASS DEPENDENT CALL TABLE - INPUT
;
CLAI:	PUSHJ P,[PUSHJ P,MBICDR
		SKIPA
		AOS (P)
		XCTBU <HRRZ T2,(U)>
		POPJ P,]
	SKIPA
	SKIPA		;DSK. SIMIO PKG DOES ALL BUFF ADV
	PUSHJ	P,DTIDR1
CLIBUF:	SKIPA
	SKIPA
	PUSHJ P,SIMBIN	;SIMULATED BUFFERED INPUT
	PUSHJ	P,DTIDR2
CLIDMP:	STOPCD
	STOPCD
	PUSHJ P,SIMDMP
	PUSHJ	P,DTIDR3


;EXTERNS FROM SIMIO MODULE
EXTERN SIMBIN,SIMBOU,SIMDMP
EXTERN UPTSIM ;FOR DEBUG. LIVES IN COMMON & UPT. DELETE EVENTUALLY
;OUTPUT
;	DISPATCH TABLE FOR CLASS DEPENDENT ROUTINES- SKIPA'S
;	TO BE REPLACED BY PUSHJ'S FOR DEVICES THAT NEED IT
;
CLA:	PUSHJ	P,MBCDR
	SKIPA
	SKIPA		;DSK. SIMIO PKG DOES ALL BUFF ADVANCE
	PUSHJ	P,DTODR1
CLOBUF:	SKIPA
	SKIPA
	PUSHJ P,SIMBOU
	PUSHJ	P,DTODR2
CLODMP:	STOPCD
	STOPCD
	PUSHJ P,SIMDMP
	PUSHJ	P,DTIDR3


CALIN:	TLNE S,IOEND
	POPJ P,
	PUSH P,U
	MOVSI S,IOSTBL!IO		;RESET ERROR FLAG
	ANDCAB S,DEVIOS(F)
	LDB	T1,DEYCLS	;CLASS INDEX
	XCT	CLIBUF(T1)	;CALL BUFFER INPUT CLASS ROUTINE
	JRST	CALIN1
	HRRZ	T4,DEVSER(F)
	PUSHJ P,DIN(T4)	;DISPATCH TO IO SERVICE ROUTINE
CALIN1:	POP P,U
	POPJ P,


;
;	MONITOR BUFFER CLASS DEPENDENT INPUT ROUTINE
;
MBICDR:	
	TLNN	S,IOBEG		;VIRGIN DEVICE?
	JRST	MBICD1		;NO
	HRRZ	T1,DEVCLS(F)	;BUFFER POINTER
	HRLM	T1,-2(T1)	;SET IN=FIRST
	HRRM	T1,-2(T1)	; AND OUT=FIRST
	HLLZS	DEVPWC(F)	;CLEAR PARTIAL WORD COUNT
	MOVE	T2,-1(T1)	;END OF BUFFER +1
	SETZM	(T1)		;CLEAR FIRST WORD OF BUFFER
	HRLS	T1		;START ADDRESS TO CLEAR
	ADDI	T1,1
	BLT 	T1,-1(T2)	;CLEAR ALL OF MONITOR BUFFER
MBICD1:	PUSHJ	P,CBLEMB	;GET LENGGTH AND ADDR OF NEXT BLOCK IN MB
	JUMPE	T1,MBICD2	;IF MB IS EMPTY
MBICD9:	PUSHJ	P,CBLEUB	;GET LENGTH AND ADR OF NEXT BLOCK IN UB
	JUMPE	T4,MBICD3	;IF UB IS FULL
	HRL	P3,T2		;SET UP FOR XFER - FROM
	HRR	P3,T3		; - TO
	MOVE	P1,T1		;LENGTH OF MB DATA
	CAMLE	P1,T4		;COMPARE TO SPACE IN UB
	MOVE	P1,T4		;USE MINIMUM
	ADD	P1,T3		;ENDING ADDRESS+1
	HRR	P2,DEVSER(F)	;TRANSFER ROUTINE
	TLZ	P2,200000	;CLEAR DONE WITH BUFFER FLAG
	PUSHJ	P,DXFR(P2)	;CALL XFER ROUTINE
	JRST	MBICD3		;END OF BLOCK- DON'T PUT MORE IN THIS BUFFER
	SUB	P1,T3		;RECOVER LENGTH OF XFER
	HRR	P2,DEVCLS(F)	;GET MB ADDRESS
	HRRZ	T1,-2(P2)	;GET OUT POINTER
	ADD	T1,P1		;ADD WORD COUNT TRANSFERRED
	CAMN	T1,-1(P2)	;END OF BUFFER?
	MOVE 	T1,P2		;YES, LOOP AROUND
	HRRM	T1,-2(P2)	;UPDATE OUT
	HRRZ	T1,DEVIAD(F)	;BUFFER ADDRESS
	ADDB	P1,DEVPWC(F)	;ADVANCE PARTIAL WORD COUNT
	XCTBU <HRRZM P1,1(T1)>	;STORE BUFFER WORD COUNT
	XCTBU <HLRZ T2,(T1)>	;GET BUFFER SIZE
	HRRZS	P1		;EXTRACT WORD COUNT
	TRZ	T2,400000	;EXTRACT BUFFER SIZE
	CAIGE	P1,-1(T2)	;BUFFER FULL?
	JRST	MBICD6		;NO.
MBICD3:	HRRZ	T1,DEVIAD(F)	;GET BUFFER ADDRESS
	HLLZS	DEVPWC(F)	;CLEAR PARTIAL WORD COUNT
	HRLZI	T2,IOUSE	;GET USE BIT
	XCTBU <ORM T2,(T1)>	;SET IT IN USER BUFFER HEADER
	XCTBU <HRR T1,(T1)>	;ADVANCE TO NEXT BUFFER IN RING
	HRRM	T1,DEVIAD(F)	;SET NEW BUFFER ADDRESS
	XCTBU <SKIPGE (T1)>	;IS THIS BUFFER FULL?
	POPJ	P,		;YES. RETURN
	PUSHJ	P,BUFCLR	;CLEAR NEXT BUFFER
	JFCL			;IGNORE ADDRESS ERRORS
	PUSHJ	P,CTMBS		;COMPUTE SPACE IN BUFFER
	HLRZ	T2,DEVPWC(F)	;WAKE UP COUNT
	CAMG	T1,T2		;TIME TO RETURN TO USER?
	POPJ	P,		;YES.
	JRST	MBICD1		;AND GO FILL IT
MBICD2:	TLNE	S,IOEND		;EOF?
	JRST	MBICD4		;YES.
MBICD8:	TRNE	S,IOACT		;NO. I/O ACTIVE?
	JRST	MBICD5		;YES
	HRRZ	T4,DEVSER(F)	;GET DEVICE DEPENDENT ROUTINE
	PUSHJ	P,DIN(T4)	;AND CALL IT
	HRR	U,DEVBUF(F)	;HNGSTP MAY HAVE CLOBBERED U
MBICD5:	MOVE T1,DEVBUF(F)
	UMOVE T1,(T1)		;GET BUFFER HEADER WORD
	XCTBU <SKIPGE(T1)>	;CURRENT BUFFER FULL?
	POPJ P,			;YES. LET HIM HAVE IT
	LDB T1,NWATRP		;IO WAIT TRAP CHANNEL
	PUSHJ P,TSTKTJ		;TEST AND TAKE?
	JRST ABTUUO		;TRAP TAKEN- ABORT INPUT
	PUSHJ	P,WSYNC		;NO. WAIT FOR MORE I/O
	JRST	MBICD1		;AND XFER SOME MORE
MBICD4:	HRRZ	T2,DEVPWC(F)	
	JUMPN	T2,MBICD7	;IF THERE IS A PARTIAL BUFFER AND EOF
	XCTBU <HRRZ T2,(U)>		;GET USERS CURRENT BUFFER ADDRESS
	XCTBU <SKIPGE (T2)>	;CURRENT BUFFER EMPTY?
	POPJ	P,		;NO. LET HIM EMPTY IT
	TRO	S,IODEND	;YES. SET USER EOF BIT
	IORM 	S,DEVIOS(F)	;IN DDB
	POPJ	P,
MBICD7:	HRLZI	T2,IOUSE	;SET USE BIT IN BUFFER
	HRRZ	T1,DEVIAD(F)
	XCTBU <ORM T2,(T1)>
	HRRZ	T2,DEVPWC(F)	;SET FINAL WORD COUNT
	UMOVEM T2,1(T1)
	HLLZS	DEVPWC(F)	;CLEAR PARTIAL WORD COUNT
	POPJ	P,
MBICD6:	PUSHJ	P,CBLEMB
	JUMPN	T1,MBICD9	;JUMP IF MB IS NOT EMPTY
	TLNE	S,IOEND		;EOF?
	JRST	MBICD7		;YES
	JRST	MBICD8		;NO

;
INTERNAL CTMBS
;	COMPUTE TOTAL SPACE LEFT IN MONITOR BUFFER
;
CTMBS:	HRRZ	T1,DEVCLS(F)	;POINTER TO BUFFER
	HRRZ	T3,-2(T1)	;GET OUT
	HLRZ	T2,-2(T1)	;GET IN
	CAMGE	T2,T3		;SKIP IF IN .GE. OUT
	JRST	CTMBS1
	SUB	T2,-1(T1)	;SP=LAST-IN+OUT-FIRST-1
	MOVNS	T2
	ADD	T2,T3
	SUB	T2,T1
	MOVE	T1,T2		
	JRST	CTMBS2
CTMBS1:	SUB	T3,T2		;SP = OUT-IN-1
	MOVE	T1,T3		;OUT-IN
CTMBS2:	SUBI	T1,1	
	POPJ	P,

;
;	COMPUTE ADDRESS AND LENGTH OF NEXT BLOCK OF DATA IN MB
;	RETURNS ADDRESS IN T2 AND LENGTH IN T1
;
	INTERNAL CBLEMB
;
CBLEMB:	HRRZ	T3,DEVCLS(F)	;ADDR OF BUFFER
	HRRZ	T2,-2(T3)	;OUT=ADDRESS
	HLRZ	T1,-2(T3)	;GET IN
	CAMGE	T1,T2		;IN .GE. OUT?
	HRRZ	T1,-1(T3)	;NO.
	SUB	T1,T2		;LEN = IN-OUT
	POPJ	P,
;
;	COMPUTE LENGTH AND ADDRESS OF REMAINING SPACE IN 
;	CURRENT USER BUFFER
;	T3 RETURNS ADDRESS AND T4 RETURNS LENGTH
;
CBLEUB:	HRRZ	T3,DEVIAD(F)	;ADDRESS OF BUFFER
	MOVEI	T4,0
	XCTBU <SKIPGE (T3)>	;SKIP IF USE BIT IS CLEAR
	POPJ	P,		;RETURN WITH 0 SPACE REMAINING
	XCTBU <HLRZ T4,(T3)>	;GET BUFFER SIZE
	PUSH	P,P1		;SAVE REGISTER
	HRRZ	P1,DEVPWC(F)	;GET PARTIAL COUNT
	SUBI	T4,1(P1)		;COMPUTE SPACE REMAINING
	ADDI	T3,2(P1)		;COMPUTE ADDRESS
	POP	P,P1		;RESTORE P1
	POPJ	P,		;AND RETURN


INTERNAL MBBXFR
;	DEVICE DEPENDENT ROUTINE TO XFER DATA FROM
;	THE MONITOR TO THE USER BUFFER.
;	ON NETRY LH(P3)=START OF BLOCK IN MB
;		 RH(P3)=START OF BLOCK IN UB
;		   (P1)=ENDING ADDRESS IN UB OF SUGGESTED XFER
;	ON EXIT    (P1)=ACTUAL ENDING ADDRESS OF XFER
;
MBBXFR:	PUSH	P,P2		;SAVE REGISTER
	LDB	P2,PIOMOD	;GET MODE
	CAIN	P2,B		;BINARY?
	JRST	PTRXF1		;YES. REQUIRES SPECIAL HANDLING
	XCTTU	<BLT P3,-1(P1)>;  CAN XFER DIRECTLY
	POP	P,P2	;RESOTRE REGISTER 
	AOS	(P)	;SKIP RETURN FOR BUFFER THAT CAN BE FILLED
	POPJ	P,		;AND RETURN
PTRXF1:	HLRZ	T1,P3		;GET ADDR IN MB
	HRRZS	P3		;GET ADDR  IN UB
	MOVE	T2,(T1)		;GET WORD  COUNT OF BLOCK
	XCTBU	<MOVEM T2,-1(P3)>; STORE CKSUM AND COUNT
	XCTBU <HLRZ T3,-2(P3)>	;GET BUFFER SIZE
	TLZ	T3,400000	;CLEAR  USE  BIT IFSET
	HRRZS	T2		;EXTRACT BLOCKWORD  COUNT
	CAIG	T2,-1(T3)	;WILL BLOCK FIT?
	JRST	PTRXF2		;YES.
	TRO	S,IOBKTL	;NO. SET BLOCKINCOMPLETE  FLAG
	HRRZI	T2,-1(T3)	;WORD COUNT  TO BE XFERRED
PTRXF2:	HRRZ	T3,DEVCLS(F)	;BUFFER POINTER
PTRXF4:	ADDI	T1,1		;ADVANCE OUT POINTER
	CAMN	T1,-1(T3)	;ENDOF BUFFER?
	HRRZ	T1,T3		;YES.  LOOPAROUND
PTRXF7:	HLRZ	T4,-2(T3)	;GET IN POINTER
	CAMN	T4,T1		;BUFFER EMPTY?
	JRST	PTRXF3		;YES
	MOVE 	T4,(T1)	;NO. GET DATA
	UMOVEM	T4,(P3)		;STORE  IN  UB
	ADDI	P3,1		;ADVANCE UB POINTER
	SOJG	T2,PTRXF4	;LOOP TOEND  OF WORD COUNT
	HRRZ	T2,DEVIAD(F)	;ADDR OF UB
	ADDI	T1,1		;ADVANCE OUT POINTER
	HRRM	T1,-2(T3)	;STORE IT
	TRNE	S,IOBKTL	;LENGTH ERROR ON BLOCK?
	JRST	PTRXF9		;YES. DO NOT CHECKSUM.
	PUSHJ	P,CKS12	;COMPUTE CHECKSUM
	HRRZ	T2,DEVIAD(F)	;POINTER TO CKSUM UN UB
	XCTBU <HLLZ T2,1(T2)>;GET IT
	CAME	T1,T2		;COMPARE  IT
	TRO 	S,IODTER	;SET ERROR FLAG
PTRXF9:	IORB	S,DEVIOS(F)	;ALSO IN DDB
	JRST	PTRXF8		;RETURN
PTRXF3:	TLNE	S,IOEND	;EOF??
	JRST	PTRXF5	;YES
	TRNN	S,IOACT		;NO.  I/O ACTIVE?
	JRST	PTRXF6		;NO
	PUSHJ	P,PTRWT		;YES. WAITFOR MORE DATA
	JRST	PTRXF7		;AND GOXFER IT
PTRXF6:	HRRZ	T4,DEVSER(F)	;START DEVICE
	PUSH	P,T1
	PUSH	P,T2		;SAVE REGISTERS
	PUSH	P,T3
	PUSHJ	P,DIN(T4)	;START THE DEVICE
	POP	P,T3		;RESTORE REGISTERS
	POP	P,T2	
	POP	P,T1
	JRST	PTRXF7
PTRXF5:	TRO	S,IOBKTL	;SET ERROR FLAG
PTRXF8:
	POP	P,P2		;RESTORE P2
	POPJ	P,

PTRWT:	PUSH	P,P3		;SAVE P3 AND CALL WSYNC
	PUSHJ	P,WSYNC	
	POP	P,P3
	POPJ	P,


SUBTTL OUT,OUTPUT
;CALLING SEQUENCE
;     OUTPUT D,
;     EXIT
;OR
;     OUTPUT D, ADR
;     EXIT

;IF INPUT IS ACTIVE, WAIT FOR IT TO COMPLETE.
;IF DUMP MODE WAS SELECTED BY THE LAST INIT M OR SETSTS M
;   THE PROGRAM WAITS UNTIL THE DEVICE IN INACTIVE AND THEN
;   WRITES THE DUMPFILE AND RETURNS CONTROL TO THE USER'S PROGRAM
;   WHEN IO HAS COMPLETED.
;IF THE MODE IS NOT DUMP, THEN
;1) IF ADR IS NOT ZERO, WAIT FOR DEVICE TO BECOME INACTIVE THEN SET THE
;   CURRENT BUFFER ADDRESS EQUAL TO ADR AND AN INDICATOR (JBFADR0)
;   SPECIFYING THAT THIS BUFFER RING HAS NEVER BEEN REFERENCED FROM THE
;   USER'S PROGRAM BY AN INPUT OR AN OUTPUT UUO.  OTHERWISE, GO TO
;   2) DIRECTLY.

;2) IF THE BUFFER RING HAS NEVER BEEN REFERENCED (JBFADR0=1), THE
;   BUFFER IS CLEARED, IOUSE SET TO ZERO AND
;      IF THE CURRENT BUFFER ADDRESS IS ZERO, A TWO BUFFER RING IS SET UP.
;      THEN GO TO 8
;
;3) IF THE BUFFER RING HAS BEEN REFERENCED (JBFADR0=0	,THEN A CHECK IS
;   MADE TO DETERMINE IF THE WORD COUNT IS TO BE COMPUTED.
;      IF THE WORD COUNT IS TO BE COMPUTED (IOWC=0), IT IS SET EQUAL
;      TO THE ADDRESS FOR THE LAST DATA WORD MINUS THE ADDRESS OF THE
;      BUFFER MINUS ONE.

;4) IOUSE IS SET TO ONE, INDICATING THAT THE BUFFER IS FULL OR BEING
;   EMPTIED, AND THE CURRENT BUFFER ADDRESS IS ADVANCED.

;5) IF THE DEVICE IS NOT ACTIVE (IOACT=0), OUTPUT IS STARTED.
;6) IF THE CURRENT BUFFER IS FULL OR BEING EMPTIED (IOUSE=1),
;   THE PROGRAM WAITS UNTIL THE DEVICE FINISHES THE BUFFER
;   (THE OUTPUT SERVICE ROUTINE CLEARS THE USE BIT WHEN
;   IT FINISHES OUTPUTTING A BUFFER).
;7) THE CURRENT BUFFER IS CLEARED.
;8) THE J POINTER IS INITIATED TO THE CURRENT BUFFER ADDRESS+1
;   AND THE J COUNT IS SET TO THE PRODUCT OF THE BUFFER SIZE
;   MINUS ONE AND THE INTEGER PART OF 36/BYTE SIZE.
;9) RETURN TO THE USER'S PROGRAM

;HERE ON OUTPUT M

UOUT:	MOVEI T1,DOU
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR. NO CHANNEL.
	JFCL			;SHORT DISPATCH TABLE OK.
	PUSHJ P,UOUT1
	JRST DEVECK

UOUT1:	TLO F,OUTPB	;SET OUTPUT M BIT
	TLZ F,OCLOSB	;CLEAR CLOSE OUTPUT BIT

;HERE FROM DEVICE SERVICE ROUTINES ON CLOSE M

INTERNAL OUT

OUT:	HRRZ T4,DEVSER(F) ;RESTORE T4
	TLNN S,IO		;IS THIS DEVICE ALREADY DOING INPUT?
	PUSHJ P,WAITI		;YES, WAIT TILL IT BECOMES INACTIVE
	HLLM F,%UPT+UPTJDA(W);SAVE NEW BIT SETTINGS.
	LDB T1,PIOMOD		;GET DATA MODE SET BY INIT OR SETSTS.
	CAIL T1,SD		;IS IT DUMP MODE(SD,DR,D)?
	JRST OUTDMP		;YES.
	MOVSI S,IO
	IORB S,DEVIOS(F)	;SET IO IN S,MEMORY
	PUSHJ P,OUTA		; CHECK FOR NON-ZERO ADDRESS(USER
				; CHANGING RING)
	HLRZ U,DEVBUF(F)	;REL. ADDR. OF OUTPUT BUFFER HEADER
	XCTBU <SKIPG T2,(U)>	; CHECK FIRST WORD OF BUFFER HEADER
	JRST OUTF		;RING NOT SET UP OR FIRST REFERENCE TO RING
	TLNN T2,IOADVB	;SEE IF OK TO ADVANCE
	XCTBU <SKIPGE (T2)>		;AND IS USE BIT ON
	JRST OUT3		;DO NOT ADVANCE, START DEVICE
	XCTBU <HRRZ T1,1(U)>		;GET RH OF BYTE POINTER.
	TRNE S,IOWC		;USER COMPUTING OWN WC?
	MOVEI T1,0		;YES, SET POINTER TO 0
	SKIPE	T1
	SUBI T1,1(T2)		;NOW HAVE SIZE
	JUMPL T1,ADRERR		;TRYING TO PUT ONE OVER ON US
	TRNN S,IOWC		;DO NOT STORE IF OWN WC.
	XCTBU <HRRM T1,1(T2)>		;YES, STORE WORD COUNT IN 3RD WORD OF BUFFER.

	HRLZI T1,IOUSE		;FLAG CURRENT BUFFER CONTAINS ACTIVE DATA.
	XCTBU <IORB T1,(T2)>
	XCTBU <HRRM T1,(U)>		;ADVANCE CURRENT BUFFER ADDRESS
	MOVSI T1,IOADVB
	XCTBU <IORM T1,(U)>	;HAVE ALREADY ADVANCED IT
OUT3:	MOVSI S,IOSTBL
	ANDCAB S,DEVIOS(F)
	LDB T2,DEYCLS	;CLASS DEPENDENT ROUTINE INDEX
	XCT CLA(T2)		;CALL CLASS DEPENDENT ROUTINE
	JRST OUTS1			;NO SKIP MEANS CDR DID IT ALL
	TRNN S,IODTER!IODERR!IOBKTL!IOIMPM	;DO NOT START IF ERR
OUT3A:	TRNE S,IOACT
	JRST	OUT5
	LDB T1,DEYCLS
	XCT CLA(T1)	;MAKE SURE BUFFERS ALL ADVANCED
	JFCL
	HLRZ U,DEVBUF(F)
	UMOVE T2,(U)
	XCTBU <SKIPGE (T2)>	;NEXT BUFFER EMPTY?
	HRRM T2,DEVOAD(F)	;NO, MAKE SURE OUTPUT POINTS HERE BEFORE CONTINUING
	LDB	T1,DEYCLS	;CLASS INDEX
	XCT	CLOBUF(T1)	;CALL OUTPUT BUFFER CLASS ROUTINE
	JRST	OUT5		;UNABLE TO BUILD LIST
OUT4:	HRRZ	T4,DEVSER(F)
	PUSHJ P,DOU(T4)	;NO,START OUTPUT.
OUT5:	HLRZ U,DEVBUF(F)	;U TO REL. ADDR. OF BUFFER HEADER
	UMOVE T2,(U)		;T2 TO REL. ADDR. OF 2ND WORD OF BUFFER.
	XCTBU <HLLZS	1(U)>
	XCTBU <SKIPL (T2)>		;HAS SERVICE ROUTINE EMPTIED NEXT BUFFER
	JRST OUTS		;YES, RETURN TO USER
	PUSHJ P,WSYNC		;NO, WAIT
	TLZE S,IOSTBL		;RECOVERABLE ERROR?
	JRST OUT3		;YES
	LDB	T1,DEYCLS
	XCT	CLA(T1)		;CALL CLASS ROUTINE TO ADVANCE BUFFERS IF NEEDED
	JFCL
OUTS1:	HLRZ	U,DEVBUF(F)	;RELOAD U INCASE CAME FROM CLA
	UMOVE T2,(U)
	XCTBU <SKIPGE (T2)>	;SEE IF BUFFER FULL
	JRST OUT3A	;YES, TRY AGAIN
	JRST OUTS		;RETURN TO USER.

OUTF:	;HERE T2/USERS HEADER WORD 0 (PTR TO NEXT BUFFER)
	;EITHER NO RING YET OR FIRST REFERENCE TO RING
	JUMPN T2,OUTF1	;JUMP IF ALREADY SET UP RING
	HRRI M,STDRNG	;SETUP BUFFER RING USING STANDARD
	PUSHJ P,UOUTBF
	HLRZ U,DEVBUF(F)
OUTF1:	HRLZI T1, IOUSE!IOADVB
	XCTBU <ANDCAB T1, (U)>	;IOUSE:=0
	HRRM T1,DEVOAD(F)
OUTS:	XCTBU <HRRZ T1,(U)>		;CLEAR NEXT OUTPUT BUFFER.
	PUSHJ P,BUFCLR	;BEING CLEARED.
	JRST ADRERR		;ADDRESS CHECK
	MOVSI T2,IOADVB
	XCTBU <ANDCAB T2,(U)>
	XCTBU <LDB J,[POINT 17,(T2),17]>
	SOJA J,IOSETC
				; ADDRESS+1
				; JBFCTR:=(BUFFER SIZE-1)*[36/BYTE
				; SIZE]
				; RETURN TO USER'S PROGRAM


OUTDMP:	PUSHJ P,WSYNC
	MOVSI S,IO
	IORB S,DEVIOS(F)	;MAKE SURE FLAG IS SET
	LDB	T1,DEYCLS	;CLASS INDEX
	XCT	CLODMP(T1)	;CALL CLASS DUMP OUTPUT ROUTINE
	POPJ P,
	HRRZ	T4,DEVSER(F)
	PUSHJ P,DDO(T4)
	JRST WAIT1		;WAIT BEFORE RETURNING TO USER

;CALLING SEQUENCE:
;	PUSHJ P,OUTA
;	EXIT		ALWAYS RETURNS HERE
;IF THE ADDRESS FIELD OF AC M IS ZERO,EXIT. OTHERWISE,CHECK IOACT.
;IF IOACT=1, WAIT FOR IOACT=0.
;SET JBFADR18-35:=ADDRESS FIELD OF AC UUO. JBFADR0:=1 AND EXIT.

OUTA:	TRNE M,-1		;IS BUFFER ADDRESS SPECIFIED?
	TLNE F,OCLOSB		;DOES NOT APPLY DURING CLOSE
	POPJ P,		;NO
	PUSHJ P,WAIT1
	HLRZ U,DEVBUF(F)
	XCTBU <HRRM M,(U)>
	HRRM M,DEVOAD(F)
	HRLZI T1,IOUSE
	XCTBU <ANDCAM T1,(U)>
	POPJ P,		;RETURN

;	MOINTOR BUFFER CLASS DEPENDENT ROUTINE - OUTPUT
;
MBCDR:	TLNN	S,IOBEG		;FIRST OUTPUT?
	JRST	MBCDR5		;NO.
	HRR	T1,DEVCLS(F)	;YES. GET ADDRESS OF MON. BUFFER
	HRLS	T1		;SET IN=OUT=FIRST
	MOVEM	T1,-2(T1)	;STORE IN POINTER WORD
	HLRZI	T1,		;CLEAR PARTIAL WORD COUNT
	HRRM	T1,DEVPWC(F)	;STORE IT
MBCDR5:	PUSHJ	P,CBLAUB		;GET LENGTH OF USER DATA
	JUMPE	T4,MBCDR3		;JUMP IF UB IS EMPTY
MBCDR4:	PUSHJ	P,CBLAMB		;GET SPACE LEN. OF MB
	JUMPE	T1,MBCDR2		;JUMP IF FULL
	CAMLE	T1,T4		;COMPUTE MIN(UB,MB)
	MOVE	T1,T4		;PUT MIN IN T1
	HRL	T2,T3		;SET UP FOR BLT-START
	HRRZ	T3,T2		;SET UP FROM
	ADD	T3,T1		; AND END+1
	HRRZ	P1,DEVSER(F)		;SET TO CALL XFER ROUTINE
	PUSHJ	P,DXFR(P1)		;CALL IT
	JRST	MBCDR3		;XFER ROUTINE HAS DONE IT ALL
	HRRZ	P1,DEVCLS(F)		;MON. BUFFER POINTER
	HLRZ	P2,-2(P1)		;GET IN POINTER
	ADD	P2,T1		; ADD AMOUNT ADDED TO BUFFER
	CAMN	P2,-1(P1)	; IN = LAST ?
	MOVE	P2,P1		; P2:=FIRST
	HRLM	P2,-2(P1)	;YES, IN := FIRST
	ADDM	T1,DEVPWC(F)	;COMPUTE TOTAL XFRD SO FAR
	JRST	MBCDR5		;XFER SOME MORE IF NEEDED
MBCDR3:
	HLLZS	T2,DEVPWC(F)	;RESET PARTIAL WORD COUNT
	PUSHJ	P,ADVBFE	;ADVANCE TO NEXT USER BUFFER
	JRST	MBCDR1		;BUFFER IS EMPTY
	JRST	MBCDR5		;BUFFER IS FULL
MBCDR1:	TRNE	S,IOACT	;DEVICE ACTIVE?
	POPJ	P,		;YES
	HRRZ	T1,DEVCLS(F)		;NO CHECK MON. BUFFER
	MOVS	T2,-2(T1)	; COMPARE IN TO OUT AND OUT TO IN
	CAMN	T2,-2(T1)	; IN = OUT?
	POPJ	P,		;YES. BUFFER EMPTY
	HRRZ	T4,DEVSER(F)	;NO. SET TO CALL DEVICE DEPENDENT CODE
	PJRST	DOU(T4)		;CALL IT AND RETURN
MBCDR2:	HLRZ	T1,DEVPWC(F)	;GET WAKE UP COUNT
	MOVNM	T1,DEVWUC(F)	;SET IT
	PUSHJ	P,WSYNC		;WAIT FOR ROOM IN MON. BUFFER
	TRNE	S,IOACT		;CHECK IF WE GOT HERE WITH FULL
	JRST	MBCDR4		;  BUFFER BUT DEV. STOPPED
	HRRZ	T1,DEVCLS(F)	;IF SO WE MUST START DEVICE
	MOVS	T2,-2(T1)	;BUFFER FULL CHECK
	CAMN	T2,-2(T1)	;BUFFER EMPTY?
	JRST	MBCDR4		; YES. CAN'T START DEVICE
	HRRZ	T4,DEVSER(F)	;NO. SO START DEVICE
	PUSHJ	P,DOU(T4)	; BY CALLING DEV. DEPENDENT ROUTINE
	JRST	MBCDR5		;XFER MORE IF POSSIBLE


; TAPE CLASS DEPENDENT INPUT ROUTINE #1
;  CALLED TO CLEANUP AND ADVANCE BUFFERS
;
;(THIS WAS DSK/TAPE COMMON CODE AT ONE TIME)
DTIDR1:	PUSH	P,T1
	PUSH	P,T2		;SAVE REGISTERS
	TLZN	S,IOBEG		;FIRST TIME?
	JRST	DTID11		;NO.
	MOVSI	S,IOBEG		
	ANDCAB	S,DEVIOS(F)	;CLEAR BEGIN BIT IN MEMORY TOO
	JRST DTID12	;RESET COUNT AND RETURN
DTID11:	SOSGE	T3,DEVABC(F)	;ADVANCE BUFFER COUNTER
	JRST	DTID14		;ALL DONE. COUNT WAS 0
	HLRZ	T1,DEVBWC(F)	;CURRENT COUNT ADDRESS
	JUMPE T1,[SKIPN DEVABC(F)	;FOR DISK, ANYTHING LAST BUFFER?
		SKIPN T1,DEVBWC(F)	;ANYTHING
		MOVEI T1,200	;ON DISK ALL ARE 200 EXCEPT LAST
		JRST DTID15]
	ADDI	T1,1
	HRLM	T1,DEVBWC(F)	;ADVANCE ADDRESS
	MOVE T1,-1(T1)	;WORD COUNT FOR RECORD
DTID15:	HRRZ	T2,DEVIAD(F)	;BUFFER ADDRESS
	UMOVEM T1,1(T2)	;INSTALL WORD COUNT IN BUFFER HEADER
IFCPU (KL),<;IF KL10, HAVE TO MAKE SURE EDGES OF BUFFER WEREN'T DRAGGED
; INTO THE CACHE WHILE I/O WAS IN PROGRESS BY REFERENCE TO ADJACENT
; WORD. IF USER REFS BUFFER ITSELF, TOUGH ON HIM.

	MOVEI	T1,2(T2)	;FIRST DATA WORD IN BUFFER
	CSHREF			;MAKE SURE ITS NOT IN THE CACHE
	XCTFU	<HLRZ T1,(T2)>	;GET BUFFER SIZE IN T1
	TRZ	T1,400000	;GET RID OF USE BIT
	ADDI	T1,(T2)		;GET ADDRESS OF LAST DATA WORD IN BUFFER
	CSHREF			;MAKE SURE ITS NOT IN CACHE
>;END IFCPU (KL)
IFCPU (KS),<CSHIVL>		;INVALIDATE THE CACHE (ITS WRITE THRU)
	PUSHJ	P,ADVBFF	;ADVANCE BUFFER THAT DEV IS DONE WITH
	JFCL		;IGNORE END OF RING
	TRNE	S,760000	;ERRORS?
	JRST	DTID13		;YES. ADVANCE ONLY 1 BUFFER
	JRST	DTID11
DTID14:	AOSA	DEVABC(F)
DTID12:	SETZM	DEVABC(F)
DTID13:	POP	P,T2
	POP	P,T1
	JRST CPOPJ1


; TAPE INPUT CLASS DEPENDENT ROUTINE #2
;  CALLED TO BUILD COMMAND LIST FOR DEVICE.
; (THIS ROUTINE USED TO BE COMMON TO DISK & TAPE DEFORE
;  VM SYSTEM. ENTRY WAS DTIDR2: TDZA P4,P4 ; FOR TAPE
;   DTIDK2: MOVEI P4,200  ;FOR DSK.

;


DTIDR2:
IFCPU (KL),<CSHUNL			;DO SWEEP, RETURNS OLD NUMBER IN T1.
	CAMN T1,CSUCNT		;WAIT TILL ITS DONE
	JRST	.-1>
	MOVEI P4,0		;MAG TAPE CANNOT SPLIT RECORDS
	PUSHJ	P,DTIDR1	;MAKE SURE ALL ADVANCED
	JFCL
	HRRZ	T3,DEVIAD(F)	;NEXT BUFFER
	XCTBU <SKIPGE T1,(T3)>	;BUFFER FULL?
	POPJ	P,		;YES. NO LIST TO SET UP
	PUSHJ	P,GELSTA	;GET LIST SPACE IF NEEDED
	HRLM	T2,DEVBWC(F)	;SET UP WORD COUNT POINTER
	HRRM	T2,DEVBWC(F)
	HRRZ T4,DEVSER(F)
	PUSHJ P,DGTRD(T4)	;MAKE SURE DEVICE READY FOR I/O
DTID2:	PUSH P,T1		;SAVE ADDRESS OF NEXT BUFFER
	XCTBU <HLRZ T1,(T3)>	;GET USER BUFFER SIZE
	SKIPE P4	;CAN WE SPLIT RECORDS?
	SKIPA T1,P4	;YES, ENFOCE BUFFER SIZE (ONLY DISK FOR NOW)
	SOJLE T1,DTID1	;DIE OF 0 OR NEG (T2 IS NEG)
	CAILE T1,37777
	JRST DTID1	;TOO BIG A TRANSFER, BOMB OUT
	MOVNS T1
	HRLS T1
	HRRI T1,1(T3)	;NOW SET USER ADDRESS
	PUSHJ	P,BLDLST	;BUILD LIST IN LIST AREA
	JRST	DTID1		;NOT ENOUGH ROOM OR ERROR
	POP P,T3	;RESTORE BUFFER ADDRESS
	TRNE	S,IOCON		;DISCONTINUOUS MODE?
	JRST	CLNLS1		;YES. QUIT AFTER FIRST BUFFER
	XCTBU <SKIPGE T1,(T3)>	;FULL?
	JRST	CLNLS1		;YES. DONE.
	HLL	T3,DEVIAD(F)
	CAMN	T3,DEVIAD(F)	;LOOPED AROUND?
	JRST	CLNLS1		;YES. DONE WITH RING
	JRST	DTID2		;NO. SET UP LIST FOR IT IF POSSIBLE
DTID1:	POP P,T3	;RESTORE BUFFER ADDRESS
	JUMPLE	T2,ADRCLS	;JUMP IF BAD PAGE REFERNCE
	JRST MAPLS1	;JUST RAN OUT OF LIST, GO MAP IT

CLNLS1:	PUSHJ P,CLNLST	;GET RID OF EXTRA LIST
MAPLS1:	AOS (P)		;SKIP RETURN
MAPLST:	LDB	J,PJOBN		;GET JOB NUMBER IN J
	MOVEI	T2,MAPLUZ	;SET UP JBTABT
	MOVEM	T2,JBTABT(J)
	JRSTF @[PC.UIO,,.+1]	;MAKE SURE IN USER I/O MODE
	HRRZ T2,DEVCLS(F)	;START LOOKING AT LIST
MAPLSR:	SKIPN T3,(T2)		;T3/ ADDR-1
	JRST	[SKIPE 1(T2)	;IS THIS END OF WHOLE LIST?
		AOJA T2,MAPLSR	;NO, LOOK AT NEXT TRANS
		SETZM	JBTABT(J) ;WE ARE NOT OUR BROTHER'S KEEPERS
		POP	P,T2	;GET RETURN ADDRESS
	IFNCPU (KI),<WRUBR %UPT+UPTACP> ;RESTORE PROPER AC BLOCKS,
				;THE PAGEFAULT AT SKIPA(T3) OR
				;MOVES(T3) BELOW SETS USRACB BACK
				;TO PREVIOUS. /AA
		JRSTF	@T2]	;DONE, RETURN
	ADDI	T3, 1		;T3/ ADDR
	TLNE S,IO		;DO PROPER INSTRUCTION
	XCTBU <SKIPA (T3)>	;MAKE SURE CAN READ FOR OUTPUT
	XCTBU <MOVES (T3)>	;MAKE SURE CAN WRITE THERE FOR INPUT.
IFCPU (KL),<
	MOVE T1,T3		;FORCE THIS BACK OUT OF CACHE
	CSHREF
>;END IFCPU (KL)
	TRNN	T3,-17-1	;REF TO ACS?(KL MAP DOESN'T CHECK THIS)
	JRST MAPLSE		;YES -- BOMB
	XCTBU <MAP PG,(T3)>
IFNCPU (KI),<LSH PG,-^D9>		;IF KL, MAP GIVES ADDRESS, NOT PAGE NUMBER.
	DPB PG,[POINT 13,T3,26]	;CONVERT TO PHYSICAL ADDRESS
	ANDI	PG,17777	;GET PAGE NUMBER ONLY
	LDB	T1,PGYDIO	;GET CURRENT DIO COUNT
	CAIL	T1,DIOMAX	;HAS TO BE LESS THAN MAX
	JRST	MAPLSE		;CAN'T DO THIS I/O, GIVE ADDRESS ERROR
				; (POOR USER WON'T KNOW WHATS GOING ON)
	MOVSI	T1,PGPDIO	;INCREMENT DIRECT I/O COUNT,
	ADDM	T1,@PGYDIO	;BEING CAREFUL OF INTRPTS.
	SUBI T3,1
	MOVEM T3,(T2)
	AOJA T2,MAPLSR	;CONTINUE

MAPLSE:	HRRZ T1,DEVCLS(F)	;ERROR, MUST DECREMENT EVERYTHING
MAPLE1:	CAIN T1,(T2)		;GET TO FAILING LOC YET?
	JRST ADRCLS		;YES, GO DO ADDRESS CHECK THING
	SKIPN T3,(T1)		;GET DATA
	AOJA T1,MAPLE1		;CAN'T BE END OF LIST, OR WE WOULDN'T BE HERE.
	ADDI T3,1		;IT IS ONE TOO SMALL.
	LDB PG,[POINT 13,T3,26] ;GET PAGE NUMBER
	WRPI	LI.PIF
	LDB T4,PGYDIO
	SOSGE T4
	STOPCD
	DPB T4,PGYDIO
	WRPI	LI.PIN		;WATCH OUT FOR INTERRUPT LEVEL
	AOJA T1,MAPLE1		;KEEP GOING TILL HIT THE BAD ONE.

;HERE IF MAPLST BLOWS UP (PAGE FAULT AND NO ROOM FOR NEW PAGE)
;CAN'T USE MAPLSE BECAUSE CONTEXT MAYBE CHANGED OUT FROM UNDER US

MAPLUZ:	UMOVE	F,F		;GET DDB ADDR
	UMOVE	T2,T2		;AND WHERE WE WERE IN THE LIST
	HRRZ	T1,DEVCLS(F)	;GET START OF LIST
MAPLZ1:	CAIN	T1,(T2)		;UNDONE ALL OF THE DAMAGE?
	POPJ	P,		;YES, RETURN
	SKIPN	T3,(T1)		;GET ADDRESS
	AOJA	T1,MAPLZ1	;THIS INSTRUCTION UNLIKELY TO HAPPEN
	ADDI	T3,1		;ACTUALLY, IT WAS ADDR-1
	LDB	PG,[POINT 13,T3,26] ;GET PAGE NUMBER
	WRPI	LI.PIF		;NO PIES HERE
	LDB	T4,PGYDIO	;GET DIO COUNT (SCREWED UP)
	SOSGE	T4		;NOW IT'S ALL BETTER, WE HOPE
	STOPCD			;OOPS
	DPB	T4,PGYDIO	;NOW ALL WONDERFUL
	WRPI	LI.PIN		;NO MUONS HERE
	AOJA	T1,MAPLZ1	;CONTINUE

; TAPE BUFFERED OUTPUT CLASS DEP ROUTINE #2. USED TO BE
; COMMON DSK/TAPE ROUTINE WITH ENTRY 
;DTODR2: TDZA P4,P4 ;TAPE. DO NOT SPLIT RECORDS
;DTODK2: MOVEI P4,200 ;DSK CAN SPLIT RECORDS

;  CALLED TO BUILD COMMAND LIST IN LIST AREA.

IFCPU (KL),<EXTERNAL CSVCNT,CSUCNT,CSHSAV>

;
DTODR2:
IFCPU (KL),<CSHVAL		;START A VALIDATE
	CAMN T1,CSVCNT
	JRST	.-1>
	MOVEI P4,0	;TAPE CANT SPLIT RECORDS
	PUSHJ	P,DTODR1	;MAKE SURE BUFFERS HAVE BEEN ADVANCED
	JFCL
	HRRZ	T3,DEVOAD(F)	;NEXT BUFFER
	XCTBU <SKIPL T1,(T3)>	;BUFFER FULL?
	POPJ	P,		;NO. NO LIST TO SET UP
	MOVSI S,IO
	IORB S,DEVIOS(F)	;MAKE SURE I/O FLAG IS SET
	PUSHJ	P,GELSTA
	HRRZ T4,DEVSER(F)
	PUSHJ P,DGTRD(T4)	;MAKE SURE DEVICE READY FOR I/O
DTOD2:	PUSH P,T1	;SAVE NEXT BUFFER ADDRESS
	XCTBU <HRRZ T1,1(T3)>	;GET WORD  COUNT
	JUMPE P4,DTOD5	;NOT SPLITABLE (FORCED)
	CAMLE T1,P4	;IS THIS AN ACCEPTABLE SIZE?
	XCTBU <HRRM P4,1(T3)>	;NO RESET IT IN USER AREA
	MOVEM T1,DEVBWC(F)	;STORE REQUESTED USER COUNT
	MOVE T1,P4	;AND SET NORMAL SIZE (DEVBWC IS COUNT OF LAST BUFFER)
DTOD5:	CAILE T1,37777
	JRST DTOD1	;DIE IF TRANSFER TOO BIG
	MOVNS T1
	HRLS T1
	HRRI T1,1(T3)	;SET ADDRESS
DTOD4:	PUSHJ	P,BLDLST	;BUILD LIST IN LIST AREA
	JRST	DTOD1		;BUILD FAILED
	POP P,T3	;RESTORE BUFFER ADDRESS
	TRNE	S,IOCON		;DIS CONTINUOUS MODE?
	JRST	CLNLS1		;YES. QUIT AFTER 1 BUFFER
	XCTBU <SKIPL T1,(T3)>	;FULL?
	JRST	CLNLS1		;YES.
	HLL	T3,DEVOAD(F)
	CAMN	T3,DEVOAD(F)	;LOOPED AROUND?
	JRST	CLNLS1		;YES. DONE WITH RING
	JRST DTOD2
DTOD1:	POP P,T3	;RESTORE BUFFER ADDRESS
	JUMPLE	T2,ADRCLS	;JUMP IF BAD PAGE REFERNECE
	JRST	MAPLS1

COMMENT ; TAPE BUFFERED OUTPUT CLASS DEP ROUTINE #1 - DTODR1
  (WAS COMMON TO DSK/TAPE BEFORE VM SYSTEM)  ;
;  CALLED TO ADVANCE BUFFERS
;
DTODR1:	TLZN	S,IOBEG		;FIRST TIME?
	JRST	DTOD11		;NO..
	SETZM	DEVABC(F)	;YES. CLEAR COUNTER
	MOVSI	S,IOBEG
	ANDCAB	S,DEVIOS(F)		;CLEAR STATUS IN CORE
DTOD11:	SOSGE	T3,DEVABC(F)	;DECREMENT BUFFER COUNT
	JRST	DTOD14		;NO MORE BUFFERS
	PUSHJ	P,ADVBFE	;ADVANCE TO NEXT BUFFER
	JFCL		;IGNORE END OF RING
	JRST	DTOD11		;DO NEXT BUFFER
DTOD14:	AOSA	DEVABC(F)
DTOD12:	SETZM	DEVABC(F)
	JRST	CPOPJ1

COMMENT ! TAPE DUMP IO CLASS DEP ROUTINE DTIDR3
FUNCTION: FOR EACH USER IOWD, BUILD COMMAND LIST IN SPACE
 RETURNED BY GELSTA, MAP ALL THE ADDRESSES TO MAKE SURE,
 GET THE DEVICE GOING,WAIT. QUIT ON END OF USER LIST OR ERROR
NOTE: THIS WAS ONCE COMMON DSK/TAPE CODE BEFORE VM SYSTEM
EXPECTS: M/ USER ADDR OF IOWDS
	F/ DDB		S/DEVIOS
!

DTIDR3:
IFCPU (KL),<
	CSHUNL		;START AN UNLOAD
	CAMN	T1,CSUCNT
	JRST	.-1>		;WAIT TILL ITS DONE.
	LDB P4,[POINT 4,DEVIOS(F),35]	;GET MODE (FOR TAPE)
	CAIE P4,DR
	TDZA P4,P4	;IF NOT DUMP RECORD, CAN NOT SPLIT
	MOVEI P4,200	;MTA DUMP RECORD CAN SPLIT
DTID36:	MOVSI S,IOBEG
	IORB S,DEVIOS(F)	;SET IOBEG IN CASE DUMP RECORDS
			;INDICATES FIRST PART OF IOWD
	MOVNI P3,3	;THIS IS A COUNTER FOR GO/TO WORDS
DTID33:	UMOVE T3,(M)	;GET A WORD FROM COMMAND LIST
IFCPU (KL),<
	MOVEI T1,(M)	;ADDRESS FOR CACHE-REF
	CSHREF
>;END IFCPU (KL)
	MOVE T1,T3	;REALLY WANT COMMAND WORD HERE
	JUMPE T1,CPOPJ	;TERMINATE
	TLNE T1,-1
	JRST DTID32	;NOT A GO TO, PROCESS
	AOJGE P3,ADRERR	;TO MAANY GO TO WORDS, DO NOT LOOP
	HRR M,T1	;PICK UP ADDRESS OF NEXT WORD
	JRST DTID33	;AND CONTINUE

DTID32:	PUSHJ P,GELSTA		;COMMAND, NEED TO GET LIST SPACE
	HRRZ T4,DEVSER(F)
	PUSHJ P,DGTRD(T4)	;MAKE SURE DEVICE READY FOR I/O
	PUSHJ P,BLDLST	;BUILD A COMMAND LIST
	 SKIPA		;IT WOULD NOT ALL FIT
	TDZA T1,T1	;IT ALL FIT, 0 T1 FOR END OF COMMAND
	JUMPL T2,ADRCLS	;IF NOT ALL FIT AND T2 NEG, ADRESS CHECK
	XCTBU <HLLZ T3,(M)>	;GET UUO COUNT
	SUB T1,T3		;DETERMINE AMOUNT TRNAFERED
	HLRZM T1,DEVBWC(F)	;AND SAVE IT
	PUSHJ P,MAPLST		;NOW MAP THE I/O LIST
	PUSHJ P,GODEV	;GET THE DEVICE TO GO, WAIT FOR FINISH
	TRNE S,IODTER!IODERR!IOBKTL!IODEND
	POPJ P,		;ERROR RETURN, ABORT
	HRLZ T1,DEVBWC(F)	;COUNT ACTUALLY DONE
	XCTBU <ADD T1,(M)>
	TLNN T1,-1		;IS THERE ANY COUNT LEFT?
	AOJA M,DTID31	;NO, CONTINUE
	ADD T1,DEVBWC(F)	;ADJUST ADDRESS
	JRST DTID32	;AND CONTINUE

IFCPU (<KI,F3>),<DTID31==DTID36>
IFCPU (KL),<
;NOTE - SINCE USER CANNOT REFER TO ADJACENT WORDS TO DUMP MODE
; BUFFER (DUMP ALWAYS GOES INTO IO WAIT) THIS CODE SEEMS UNNECESSARY -
; HOWEVER, ANOTHER JOB MAY HAVE THE BUFFER PAGE MAPPED IN AND
; MAY REFERENCE ADJACENT WORDS, SO WE NEED TO DO THIS.

DTID31:	TLNE	S,IO		;IF THIS IS OUTPUT,
	JRST	DTID36		;NO NEED TO DUMP CACHE AFTER IO
	UMOVE	T2,-1(M)	;GET LAST IOWD
	MOVEI	T1,1(T2)	;GET 1ST XFER ADDRESS
	CSHREF			;MAKE SURE THAT ADDRESS IS OUT OF CACHE NOW.
	HLRE	T1,T2		;GET COUNT IN T1
	SUBM	T2,T1		;GET LAST XFER ADDRESS
	CSHREF			;MAKE SURE ITS OUT OF THE CACHE
	JRST	DTID36		;GO FOR NEXT IOWD IF ANY.
>;END IFCPU (KL)

IFCPU (KS),<
DTID31:	TLNE	S,IO		;TEST IF OUTPUT
	JRST	DTID36		;JUMP IF OUTPUT NO NEED TO INVALIDATE THE CACHE
	CSHIVL			;INVALIDATE THE CACHE
	JRST	DTID36
>;END IFCPU (KS)


GODEV:	PUSHJ P,CLNLST	;REMOVE EXTRA LIST SPACE
	HRRZ T4,DEVSER(F)
	MOVEI T3,DDI(T4)
	TLNE S,IO
	MOVEI T3,DDO(T4)
	PUSHJ P,(T3)
	PUSHJ P,WAIT1	;START DEVICE AND WAIT FOR END
	SETZM DEVABC(F)	;MAKE SURE ADVANCE COUNT 0 FOR GETSTS
	POPJ P,

; BUILD COMMAND LIST FOR BUFFER
;  ON ENTRY (T1)= -BUFSIZE AND BUF ADDRESS-1
;           (T2)= -LEN OF LIST BUF AND ADDR OF LIST BUF
;		(P4)= 0 IF CAN NOT BREAK REQ, SIZE OF BREAK OTHERWISE
;
;ON EXIT
;	SKIP RETURN, COMMAND FIT AND MORE CAN GO IN
;	NON-SKIP RETURN
;		T2<0 ERROR DISCOVERED WITH MAP
;		T2>=0
;		 T1=0 ALL OF COMMAND ENTERED BUT NO MORE LIST SPACE
;		 T1<>0 NOT ALL OF COMMAND IN LIST, T1 IS REMAINDER

BLDLST:	PUSH P,T2	;SAVE ORIGINAL POINTER IN CASE OF ABORT
	AOBJP T2,BLDLE0	;NOT ENOUGHG ROOM, ABORT
	JUMPN P4,BLDLS1	;IF WE CAN SPLIT, DO NOT WORRY ABOUT SIZE
	HLRZ T3,T1	;GET SIZE
	JUMPE T3,BLDLS1	;0 IS ALWAYS OK (OUTPUT)
	CAIG T3,740000
	JRST BLDLE0	;THIS IS TOO BIG A TRANSFER
BLDLS1:	MOVEI P1,0	;AMOUNT TRANSFERED SO FAR THIS LIST
BLDLS2:	HLRO P3,T1
	MOVNS P3
	HRRZS P3
	CAILE P3,37777	;MAX IS AMOUNT IN 14 BIT COUNT FIELD
	MOVEI P3,37777	;P3 HAS TRANSFER TO TRY THIS TIME
	HRRM T1,-1(T2)	;STORE IN LIST
	MOVEI P2,1(T1)
	IORI P2,777
	SUB P2,T1
	HRRZS P2	;P2 NOW HAS COUNT TO END OF PAGE
BLDLM1:	CAML P2,P3	;IS SPACE TO END OF PAGE MORE THAN WANTED
	MOVE P2,P3	;YES, SET COUNT FOR THIS COMMAND TO DESIRED

BLDLM3:	MOVN P3,P2	;SET TO STORE COUNT
	DPB P3,[POINT 14,-1(T2),13]
	ADD P1,P2	;UNDATE COUNT THIS TRANSFER
	MOVS P3,P2	;GET COUNT IN LEFT HALF
	ADDM P3,T1	;THIS UPDATES COUNT OF REQUEST
	ADD P2,T1	;THIS UPDATES ADDRESS (IN CASE OF CARRY)
	HRRM P2,T1	;RESTORE IN REQUEST
	JUMPGE T1,BLDLND	;END NO MORE REQUESTED
	AOBJN T2,BLDLS2	;IS THERE ROOM FOR MORE?

;HERE WHEN THE TRANSFER IS NOT COMPLETED AND THERE IS NO
;MORE LIST ROOM. WE MUST SHORTEN THE TRANSFER TO A MULTIPLE OF
;THE BREAK COUNT. IF THE BREAK COUNT IS 0, REMOVE THE WHOLE TRANSFER

	JUMPE P4,BLDLB1	;BACKUP BY ENTIRE TRANSFER
	CAMG P1,P4	;HAVE WE TRANSFERED AT LEAS 1 RECORD
BLDLB1:	SKIPA P2,P1	;NO, USE WHAT WE HAVE
	IDIV P1,P4	;REMAINDER (IN P2) IS AMOUT TO BACKUP
	MOVN P1,P2
	HRLZS P1
	ADDM P1,T1
	MOVSS P1
	ADD P1,T1	;READJUST TRANSFER
	HRRM P1,T1
BLDLB4:	SUBI T2,1	;NO BACK UP COMMAND LIST
	LDB T3,[POINT 14,-1(T2),13]	;EXTRA AOBJN TO FIND OUT OF ROMM
	TDO T3,[-1,,740000]
	MOVNS T3	;COUNT IN THAT WORD
	CAMLE T3,P2	;ENOUGH?
	JRST BLDLB2	;YES, JUST FINISH UP
	SUB P2,T3	;FIND OUT HOW MUCH MORE TO GO
	SETZM -1(T2)	;REMOVE ENTIRE COMMAND WORD
	JUMPE P2,BLDLB3	;FINISHED IF NOW 0
	JRST BLDLB4	;OTHERWISE DO ANOTHER

BLDLB2:	ROT P2,-^D14	;GET AMOUNT TO SUTRACT TO COUNT FIELD
	ADDM P2,-1(T2)	;ADJUST COMMAND
	SETZM 1(T2)	;MAKE SURE 2 ZEROS AT END
BLDLB3:	SETZM (T2)	;MAKE SUURE OF A 0 (ACTUALLY 2'ND ZERO)
	POP P,T4	;CLEAR SAVED POINTER FROM STACK
	POPJ P,

BLDLE0:	EXCH T2,(P)	;NORMAL EXIT. LEAVE WIITH SAME CONDITION OF T2. GET OLD
	SETZM (T2)
	SETZM 1(T2)	;MAKE SURE 2 ZEROS
	POP P,T2	;AND GET BACK ENDING POINTER (NEG FOR ADRS CHECK
	POPJ P,		;ALL FINISHED

BLDLND:	SETZM (T2)	;THIS IS IT, ALL REQUEST IS IN
	SETZM 1(T2)	;MAKE SURE DOUBLE 0 AT END
	POP P,T1	;CLEAR SAVED POINTER OFF STACK
	MOVEI T1,0	;MAKE T1 ALL ZERO TO SAY DONE (IN CASE
			 ;OF A 0 COUNT REQUEST AND NO ROOM)
	AOBJP T2,CPOPJ	;IF WE ARE OUT OF ROOM, JUST EXIT
	JRST CPOPJ1

;  GET LIST AREA IF NEEDED. ENTRY GELSTA.
;  ON ENTRY (T2)=ADDRESS OF EXISTING LIST OR 0 IF NONE
;  ON EXIT  RH(T2)=ADDRESS OF LIST AREA
;            LH(T2)=-LENGTH OF LIST AREA-1
;  T2 RETURNS  0 IF MAX LIST IS ALREADY IN USE
;
GELSTA:	HRRZ T2,DEVCLS(F)	;PICK UP CURRENT
	JUMPN	T2,GELST1	;JUMP IF HAVE FIXED LIST
	SKIPGE	FCREQ		;ANYBODY ELSE WAITING FOR A LIST?
	JRST	GELST2		;NO.
GELST5:	AOS	FCREQ		;YES. WE WAIT TOO
	PUSHJ	P,FCWAIT
	SOS FCREQ		;NOW ONE LESS WAITER
GELST2:	LDB	T2,DEYMCT	;TRY FOR MAX ALLOWED
GELST6:	MOVE 	P1,T2		;SAVE SIZE OF REQUEST
	PUSH P,T1		;SAVE T1 (CALLERS NEED IT)
	PUSH P,T3	;SAVE T3 (AN ADDRESS)
	PUSHJ	P,GET4WD	;GET 4 WORD BLOCKS
	JRST	GELST3		;NOT ENOUGH AVAILABLE
	DPB	P1,DEYTCT	;STORE COUNT WE HAVE
	MOVN	T2,P1		;NEGATE COUNT
	ASH	T2,2		;CONVERT TO WORDS
	ADDI	T2,1		;-1
	HRL	T2,T1
	MOVSS	T2		;FORM POINTER
	POP P,T3
	POP P,T1
	HRRM T2,DEVCLS(F)	;SET LIST POINTER
	POPJ	P,
GELST3:	POP P,T3	;RESTORE THE ADDRESS
	POP P,T1
	JUMPN	T2,GELST6	;IS SOME FREE CORE LEFT?
	JRST	GELST5		;NO. WAIT FOR IT
GELST1:	HRLI	T2,-LENFXL+1	;LENGTH OF FIXED LIST
	POPJ	P,

;THE FOLLOWING ROUTINE GIVES BACK UNUSED LIST SPACE

CLNLST:	LDB T3,DEYTCT	;AMOUNT WE HAVE
	JUMPE T3,CPOPJ	;MUST BE FIXED LIST DEVICE (MTA)
	MOVEI T4,2+3(T2)	;2(T2) IS END +3 FOR ROUND UP
	SUB T4,DEVCLS(F)
	HRRZS T4
	LSH T4,-2	;NUMBER OF 4 WORD BLOCKS USED
	CAMG T3,T4	;DO WE HAVE MORE THAN USED?
	POPJ P,		;NO
	DPB T4,DEYTCT	;YES, SAVE NEW NUMBER USED
	MOVE T1,T3
	SUB T1,T4	;NUMBER TO GIVE BACK
	HRRZ T2,DEVCLS(F)
	LSH T4,2
	ADD T2,T4	;THIS IS THE FIRST WORD TO GIVE BACK
	PJRST GIV4WD

ADRCLS:	HRRZ T2,DEVCLS(F)	;CLEAR ENTIRE LIST
	SUBI T2,2	;FAKE IT FOR THE +2 IN CLNLST
	PUSHJ P,CLNLST
	MOVE	J,JOB	;SETUP J
	SETZM	JBTABT(J)	;AND MAKE SURE JBTABT NOT CALLED NOW, CALLER HAS FIXED THINGS UP.
	JRST ADRERR	;AND THEN OFF TO ADDRESS ERROR

;
	INTERNAL CBLAMB,CBLAUB
;
;  COMPUTE CURRENT ADDRESS AND LENGTH OF NEXT
;  CONTIGUOUS BLOCK OF EMPTY SPACE IN THE MONITOR
;  BUFFER ASSOCIATED WITH THE CURRENT DDB.
;   ON EXIT (T1)=LENGTH
;           (T2)=ADDRESS
;
CBLAMB:	PUSH	P,P1		;WILL NEED A REGISTER
	HRRZ	P1,DEVCLS(F)	; FOR BUFFER POINTER
	HRRZ	T1,-2(P1)	;GET THE OUT POINTER
	CAMN	T1,P1		;HAS OUT WRAPPED AROUND?
	HRRZ	T1,-1(P1)	;YES, PRETEND IS HAS NOT
	HLRZ	T2,-2(P1)	; AND THE IN POINTER=ADDRESS OF BLOCK
	SUB	T1,T2		;COMPUTE LENGTH
	SOJGE	T1,CBLAM1	;IF IN .GT. OUT
	HRRZ	T1,-1(P1)	; BLOCK GOES TO EOB
	SUB	T1,T2		;COMPUTE BLOCK LENGTH
CBLAM1:	POP	P,P1		;RESTORE REGISTER
	POPJ	P,		; AND RETURN
;
;  COMPUTE ADDRESS AND LENGTH OF NEXT FULL BLOCK IN
;  USER BUFFER.
;   ON EXIT (T3)=ADDRESS (IN USER SPACE)
;           (T4)=LENGTH
;
CBLAUB:	HLRZI	T4,		;CLEAR LENGTH
	HRRZ	T3,DEVOAD(F)	;CURRENT BUFFER ADDRESS
	XCTBU <SKIPL (T3)>	;GET USE BIT
	JRST	CBLAU1	;IF BUFFER IS EMPTY
	XCTBU <HRRZ T4,1(T3)>	;GET BUFFER WORD COUNT
	HRRZ	T2,DEVPWC(F)	
	SUB	T4,T2		;COMPUTE REMAINING COUNT
	ADDI	T3,2(T2)		;START OF DATA AREA
CBLAU1:	POPJ	P,		;AND RETURN

;RELEASE A DEVICE

INTERNAL RELEA5,RELEA6,RELEA9,RELEAX
RELEAX:
RELEAS:	MOVEI T1,0
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	POPJ P,			;NO OPERATION IF NO CHANNEL ASSIGNED.
	JFCL			;SHORT DISPATCH TABLE OKAY.
	TRZ M,-1		;CLOSE BOTH INPUT AND OUTPUT
	PUSHJ P,CLOSE1
	PUSHJ P,WAIT1		;WAIT FOR DEVICE TO BECOME INACTIVE
	HRRZ T4,DEVSER(F) ;RESTORE T4
RELEA5:	PUSHJ P,DRL(T4)	;DISPATCH TO DEVICE SERVICE ROUTINE
	MOVEI S,IOACT		;CLEAR IO ACTIVE BIT
	ANDCAB S,DEVIOS(F)	;AND RETURN WITH S SET
	SETZB U,%UPT+UPTJDA(W)	;CLEAR DEVICE ASSIGNMENT
	CAILE	W,17
	JRST .+3		;PAST END USER JOBJDA
	UXCTBU <SETZM JOBJDA(W)>
	MOVE T1,%UPT+UPTHCU	;HIGHEST IO CHANNEL IN USE
RELEA4:	HRRZ T2,%UPT+UPTJDA(T1)
	JUMPN U,RELE4A	;NON-ZERO CHAN. ALREADY?
	MOVE U,T2		;NO, SET U WHEN FIRST(HIGHEST) FOUND
	MOVEM T1,%UPT+UPTHCU	;STORE HIGHEST IN USE CHANNEL
	UXCTBU <MOVEM T1,JOBHCU>
RELE4A:	CAIE T2,(F)	;IS THIS DEVICE SAME AS ONE BEING RELEASED?
	SOJGE T1,RELEA4
	JUMPGE T1,CPOPJ	;EXIT IF ON ANOTHER CHANNEL
	HLLZS DEVIAD(F)	;CLEAR INPUT BUFFER ADDRESS
	HLLZS DEVOAD(F)	;AND OUTPUT BUFFER ADDRESS.

;CALLED FROM ERROR STOP ROUTINE(ESTOP)
RELEA9:	MOVE T1,DEVNAM(F)	;IS THIS SYSTEM TAPE?
RELEA7:	MOVEI T2,ASSPRG	;CLEAR ASSIGNED BY PROGRAM BIT
RELEA6:	ANDCAB T2,DEVMOD(F)	;CALLED FROM DEASSIGN
	TRZ T2,777		;CLEAR JOB NO. FIELD
EXTERNAL CLRDDB,IPOPJ
	TDNE T2,[XWD TTYATC,ASSCON+ASSPRG]
	POPJ P,		;DEVICE ASSIGNED BY OTHER MEANS TOO
	TLNE T2,DVTTY!DVRMT
	JRST	[HRRZ T4,DEVSER(F)
		JRST DZAP(T4)]	;GO ZAP AUX CIR OR RMT
	DPB T2,PJOBN		;CLEAR JOB NUMBER
	PUSH P,J		;SAVE JOB NO.
	MOVEI J,ASSCON
	TLNN T2,DVDSK!DVTTY	;DO NOT ASSIGN TO JOB 0
	IORM J,DEVMOD(F)	;OTHERWISE DO
	TLNE T2,DVDSK		;IS DEVICE A DSK
	PUSHJ P,CLRDDB	;YES-RETURN DDB TO STORAGE
	JRST IPOPJ		;RESTORE JOB NO. & RETURN.


;CALLING SEQUENCE
;	STATO D,MASK
;	EXIT1		ALL SELECTED BITS ARE 0
;	EXIT2		SOME SELECTED BITS ARE 1
;TESTS BITS OF I/O STATUS WORD OF DEVICE ON USER'S CHANNEL D WHICH
;ARE SELECTED BY MASK.

USTATO:	PUSHJ	P,GETSTS	;GET STATUS
	TRNE T1,(M)		;SKIP IF ANY INDICATED BITS ARE ONE
	AOS (P)
	POPJ P,		;RETURN TO USER

;CALLING SEQUENCE
;	STATUS D,ADR
;	EXIT		ALWAYS RETURNS HERE
;STORES I/O STATUS WORD OF DEVICE ON CHANNEL D IN LOCATION ADR.


USTATS:	PUSHJ	P,GETSTS
	UMOVEM T1,(M)		;MOVE STATUS TO USER AREA.
	POPJ P,			;AND RETURN.

;CALLING SEQUENCE
;	STATZ D,MASK
;	EXIT1		SOME SELECTED BITS ARE 1
;	EXIT2		ALL SELECTED BITS ARE 0

;TESTS BITS OF I/O STATUS WORD OF DEVICE ON USER'S
;CHANNEL D WHICH ARE SELECTED BY MASK.


USTATZ:	PUSHJ	P,GETSTS
	TRNN	T1,(M)
	AOS (P)
	POPJ P,		;RETURN TO USER

GETSTS:	MOVEI T1,0
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	JFCL			;SHORT DISPATCH TABLE OK.
	LDB	T1,DEYCLS	;GET CLASS CODE
	XCT	STCLTB(T1)	;GET CORRECT STATUS
	POPJ	P,		;RETURN HERE IF STATUS SHOULD BE RETURNED AS IS
	TLNE S,IO
	JRST GETST2		;ALWAYS RETURN ALL BITS FOR OUTPUT
	TRNN	S,IOACT
	SKIPE	DEVABC(F)	;ALL BUFFERS ADVANCED?
	TRZ	T1,760000	;NO. DO NOT RETURN ERROR BITS
GETST2:	HRRZS	T1
	POPJ	P,

STCLTB:	HRRZ	T1,S
	HRRZ	T1,S
	HRRZ 	T1,S	;DSK NOW USES SIMIO. RETURN DEVIOS AS IS
	SKIPA	T1,S

;IN M - LIKE INPUT	SKIPS IF  EOF OR ERRORS


TIN:	MOVEI T1,DIN
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR -- NO CHANNEL.
	JFCL			;SHORT DISPATCH TABLE OK.
	PUSHJ P,INCOM		;DO INPUT UUO
	PUSHJ	P,GETSTS
	TRNE T1,IOBKTL+IODTER+IODERR+IOIMPM+IODEND
	AOS (P)
	POPJ P,

;OUT M - LIKE OUTPUT  -  SKIPS IF ERRORS


TOUT:	MOVEI T1,DOU
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	JFCL			;SHORT DISPATCH TABLE OK.
	PUSHJ P,UOUT1		;DO OUTPUT UUO
	MOVE T1,DEVMOD(F)	;GET CHRS.
	TLNE T1,DVMTA		;IS IT A MAG TAPE?
	TRNN S,IOTEND		;YES, ALSO CHECK FOR END OF TAPE
	TRNE S,IOBKTL+IODTER+IODERR+IOIMPM
	AOS (P)
	POPJ P,

;5 UUOS FOR EACH INSTALLATION TO DEFINE
;OPCODES 42-46

SUBTTL	IOCSS - COMMON IO SUBROUTINES

;ROUTINE TO ADVANCE OUTPUT BUFFER AT INTERRUPT LEVEL

;CALL:	PUSHJ P,ADVBFE
;	EXIT1		RETURN IF NEXT BUFFER IS EMPTY
;	EXIT2		RETURN IF NEXT BUFFER IS FULL
;CLEARS THE USE BIT (IOUSE:=0) OF THE BUFFER POINTED TO BY THE
;OUTPUT BUFFER ADDRESS (DEVOAD) OF THE CURRENT DEVICE DATA BLOCK
;AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
;UPON RETURN, SKIPS IF THE NEXT BUFFER IS FULL.
;SECOND WORD OF NEXT BUFFER IS ADDRESS CHECKED TO
;MAKE SURE IT IS NOT IN JOB DATA AREA OR ABOVE USER AREA
;THE SECOND WORD OF CURRENT BUFFER WAS CHECKED AT M LEVEL
;OR PREVIOUS CALL TO ADVBFE

INTERNAL ADVBFE

ADVBFE:	HRRZ T2,DEVOAD(F)	;ABS. ADR. OF 2ND WORD OF LAST BUF.
	JUMPE T2,CPOPJ	;HAS DEVOAD BEEN CLEARED BY RELEASE?
	UMOVEM S,-1(T2)	;NO. STORE IO STATUS WORD(ERROR BITS)
				; IN FIRST WORD OF BUFFER
	MOVSI T1,IOUSE		;IOUSE:=0
	XCTBU <ANDCAB T1,(T2)>;  CLEAR USE BIT IN 2ND WORD
				; ADDRESS CHECKED WHEN STORED IN DEVOAD
				; DEVICE ACTIVE SINCE THEN
	HRRM T1,DEVOAD(F)	;NOW STORE NEXT BUFFER ADDRESS
	XCTBU <SKIPL (T1)>	;IS IOUSE=0?
	POPJ P,		;EXIT1. BUFFER IS EMPTY
	JRST ADVBF1	;GO SEE IF USER TYPED CONTROL C
				; OR EXEC IS WAITING TO SHUFFLE JOB


;ROUTINE TO ADVANCE INPUT BUFFER AT INTERRUPT LEVEL

;CALL:	PUSHJ P,DEVBFF
;	EXIT1		RETURN IF NEXT BUFFER IS FULL
;	EXIT2		RETURN IF NEXT BUFFER IS EMPTY
;SETS THE USE BIT (IOUSE:=1) OF THE BUFFER POINTED TO BY THE
;INPUT BUFFER ADDRESS (DEVIAD) OF THE CURRENT DEVICE DATA BLOCK
;AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
;UPON RETURN, SKIPS IF THE NEXT BUFFER IS EMPTY.
;SECOND WORD OF NEXT BUFFER IS ADDRESS CHECKED TO MAKE SURE
;IT IS NOT IN IO PROTECTED PART OF JOB DATA AREA OR ABOVE
;USER AREA
;ALSO END OF BUFFER IS CHECKED TO MAKE SURE NOT ABOVE JOB AREA

INTERNAL ADVBFF

ADVBFF:	HRRZ T2,DEVIAD(F)	; ABS. ADR. OF LAST INPUT BUFFER
	JUMPE T2,CPOPJ	;HAS DEVIAD BEEN CLEARED BY RELEASE?
	UMOVEM S,-1(T2)	;NO. STORE S WORD IN FIRST WORD OF BUF.
	MOVSI T1,IOUSE		;IOUSE:=1
	XCTBU <IORB T1,(T2)>	;FLAG THAT DATA HAS BEEN INPUT
	HRRM T1,DEVIAD(F)	;YES, SAFELY STORE ADDRESS OF NEXT BUFFER
	XCTBU <SKIPGE T2,(T1)> ;IS NEXT INPUT BUFFER STILL FULL?
	POPJ P,		;YES, GIVE STOP RETURN
	TRZ T2,-1		;XWD LENGTH OF BUFFER,0
	ADD T1,T2		;ADD LENGTH TO REL. ADR. OF SECOND WORD
				; LENGTH=NO. WORDS WHICH FOLLOW SECOND
ADVBF1:	TRNN S,IOCON		;NEXT BUFFER AVAILABLE. DISCONTINUOUS MODE?
	AOS (P)		;NO
	POPJ P,		;YES

INTERNAL ASSASG

;ASSIGN DEVICE IF UNASSIGNED
;CALL:	MOVE J, JOB NUMBER
;	MOVE F, ADDR. OF DDB
;	MOVEI T2, EITHER ASSPRG OR ASSCON
;	PUSHJ P, ASSASG
;	CAN'T ASSIGN RETURN
;	ASSIGNED RETURN

ASSASG:	EXTERNAL SETDDB
	HLL T2,DEVMOD(F)	;IS IT A DISK?
	TLNN T2,DVDSK
	JRST ASSAS0
	PUSHJ P,SETDDB	;YES, BUILD DEVICE DATA BLOCK
	 JRST ASSAS2	;NO SPACE FOR DDB
ASSAS0:	TLZ T2,-1		;HAVE A DDB -ZERO LH(T2)
	NOSCHEDULE		;DISABLE SCHEDULING
	LDB T1,PJOBN		;GET JOB NUMBER IN DEV DATA BLOCK
	CAMN T1,J		;IS IT ALREADY ASSIGNED TO THIS JOB
	JRST ASSAS1		;YES
	MOVEI T1, ASSPRG+ASSCON	;NO, IS IT ASSIGNED TO ANOTHER JOB?
	TDNN T1, DEVMOD(F)	;ARE EITHER ASSIGNED BITS SET?
	JRST ASSAS3		;NO
	LDB T1,PJOBN
	JUMPN T1,ASSAS2		;NOT JOB 0, CAN NOT GET IT
	MOVEI T1,ASSPRG		;IS IT ASSIGNED BY PROGRAM
	TDNE T1,DEVMOD(F)
	JRST ASSAS2		;YES, CAN NOT GET IT
	MOVSI T1,LICGDV
	TRNE T2,ASSCON		;IS HE TRING TO ASSIGN BY CONSOLE
	MOVEI T1,LICGDV		;YES, USE JOB FIELD, ELSE PROCESS FIELD
	TDNN T1,JBTLIC(J)
	JRST ASSAS2		;DOES NOT HAVE LICENSE
	MOVEI T1,ASSCON		;MUST CLEAR ASS BY CONSOLE BIT
	ANDCAM T1,DEVMOD(F)
ASSAS3:	DPB J,PJOBN		;STORE JOB NUMBER
ASSAS1:	IORM T2,DEVMOD(F)	;SET ONE OF ASSIGN BITS
	AOS (P)
ASSAS2:	SCHEDULE		;SCHEDULING
	POPJ P,

;ROUTINE TO SEARCH FOR A DEVICE
;CALL:	HRR J,JOB NUMBER
;	MOVE T1,[SIXBIT .DEVICE NAME.]
;	PUSHJ P, DEVSRC
;	NOT FOUND
;	FOUND

	INTERNAL DEVLG,DEVSRC,DEVPHY
	EXTERNAL DEVOPR,TTYFND,DEVLST,GETDDB,MAXCHN

DEVSRC:
	PUSHJ P, DEVLG	;SEARCH LOGICAL NAMES FIRST
	JRST DEVPHY		;NOT FOUND, SEARCH PHYSICAL NAMES
	JRST CPOPJ1		;FOUND

;SEARCH LOGICAL NAMES

DEVLG:	HLRZ T2,W
	CAIN T2,PHONLY
	POPJ P,			;DO NOT SEARCH LOGICAL NAMES
	HLRZ F,DEVLST	;BEGINNING OF DDB CHAIN
DEVLP0:	CAME T1,DEVLOG(F)	;COMAPRE WITH LOGICAL NAME
	JRST DEV0		;NO MATCH
	LDB T2,PJOBN		;DOES THE LOGICAL NAME BELONG TO THIS JOB?
	CAMN T2,J
	JUMPN T1,CPOPJ1	;YES, GIVE SUCCESSFUL RET. IF NAME NOT 0
DEV0:	HLRZ F,DEVSER(F)	;NO, KEEP LOOKING
	JUMPN F,DEVLP0
	POPJ P,		;FINISHED AND NOT FOUND

;DVCNSG -- ROUTINE TO FIND DDB FOR THOSE UUOS
;		WHICH HAVE DUAL STYLE ARGUMENT:
;		(1) 0-17 = CHANNEL NUMBER (INITED)
;		(2) ELSE = SIXBIT DEVICE NAME (GENERIC,...)
;CALL:	MOVE T1,ARGUMENT
;	PUSHJ P,DVCNSG
;RETURN CPOPJ IF NO SUCH DEVICE
;SKIP RETURN WITH F = DDB ADDRESS IF FOUND

INTERN DVCNSG

DVCNSG:	SKIPL	T1		;IF NEGATIVE
	CAILE	T1,MAXCHN		;  OR .GT. 17,
	PJRST	DEVSRC		;  MUST BE SIXBIT
	EXCH W,T1		;MOVE CHANNEL NO. INTO W
	PUSHJ P,CHNCK1		;CHECK FOR CHANNEL ASSIGNED.
	 JRST .+3		;ERROR, NO CHANNEL.
	JFCL			;NO-OP ON SHORT DISPATCH TABLE.
	AOS (P)			;PREPARE FOR SKIP RETURN.
	EXCH W,T1		;RESTORE ACCUMULATORS.
	POPJ P,			;AND RETURN.


;SEARCH PHYSICAL NAMES

DEVPHY:
	EXTERN TSTDSK
	PUSHJ P,TSTDSK	;IS DEVICE A DISK?
	JRST CPOPJ1		;YES. RETURN WITH RH(F)=PROTOTYPE DISK DDB
	CAMN T1,[SIXBIT /OPR/]	;IS IT "OPR"?
	MOVE T1,DEVOPR		;YES, CHANGE TO OPERATOR'S TTY
        PUSH P,T3               ;SAVE T3
        SETZ T3,                ;IF T3=-1 USER IS ASKING FOR SYS
	CAMN T1,[SIXBIT /SYS/]	;IS IT "SYS"?
        JRST [  SETO T3,        ;USER IS ASKING
        	SKIP T1,[SIXBIT /DSK/]	;CHANGE TO SYSTEM TAPE DEVICE NAME
                JRST .+2 ]      ;SKIP NEXT IN-LINE INSTRUCTION
	TDZA T2,T2		;NO, CLEAR SYSTEM TAPE FLAG
	MOVEI T2,SYSDEV	;YES, SET SYSTEM TAPE FLAG
	HLRZ F,DEVLST	;SEARCH DEVICE DATA BLOCKS
DEVLP1:
	TLO F,(T2)	;SET SYSTEM TAPE BIT IF SEARCHING FOR SYS
	CAMN T1,DEVNAM(F)	;MATCH OF PHYSICAL NAME?
	JUMPN T1,DEVLP2	;YES, GIVE OK RET. IF NAME IS NOT 0, AND NOT A DISK
	HLRZ F,DEVSER(F)
	JUMPN F,DEVLP1
        SKIPE T3                ;USER REQUESTED SYS?
        STOPCD                  ;YES. AND IT DOES NOT EXIST!!!
        POP P,T3                ;RESTORE ORIGINAL T3
	CAME T1,[SIXBIT /TTY/]	;IS THIS PUBLIC LOGICAL NAME TTY?
	JRST	GETDDB		;SEE IF IT'S A TTY.
	PUSH P,U		;SAVE OUTPUT BYTE POINTER(TTY) OR INIT. ARG. ADR.
	PUSHJ P,TTYFND	        ;YES, FIND TTY JOB IS ATTACHED TO
	POP P,U		        ;RESTORE
	JRST CPOPJ1		;AND GIVE SUCCESSFUL RETURN
DEVLP2: POP P,T3                ;RESTORE ORIGINAL T3
	MOVE T2,DEVMOD(F)       ;DEVICE CHAR.
	AOS (P)		        ;NO, OK
	POPJ P,		        ;RETURN

;ROUTINE TO SETUP N-RING IO BUFFER IN USER AREA

;EXPECTS: M/ COUNT OF BUFFERS DESIRED = N. (IF 0, USE STDRNG)
;FUNCTION: SET UP AN N-BUFFER RING AT JOBFF IN USER SPACE,
;AND ADVANCE JOBFF. DO CORUUO'S IF NEEDED. IF NO CORE
;AVAILABLE, THIS ROUTINE WILL GENERATE "UUO SPECIFIES
;ILLEGAL ADDRESS" CONDITION.
; THE BUFFER RING FORMAT IS AS FOLLOWS:
;	LOCATION		LH   CONTENTS   RH
; C(JOBFF) + 1              BUFFER         C(JOBFF) +1
;    + 0(BUFFER SIZE+2)      SIZE               + 1(BUFFER SIZE+2)
; C(JOBFF) +1               BUFFER         C(JOBFF) +1
;     +1(BUFFER SIZE+2)      SIZE                + 2(BUFFER SIZE+2)
;         .		.		     .
;	.		.		     .
;	.		.		     .
; C(JOBFF) + 1	        BUFFER	   C(JOBFF) + 1
;    + (N-2)(BUFFER SIZE+2)  SIZE               +(N-1)(BUFFER SIZE+2)
; C(JOBFF) + 1	        BUFFER	   C(JOBFF) + 1
;    + (N-1)(BUFFER SIZE+2)  SIZE		   
;THEN SET 	W:=IOUSE,C(JOBFF) + 1
; AND		JOBFF:=C(JOBFF) + N(BUFFER SIZE + 2)
; P4 IS RESTORED.

BUFCLC:	PUSH P,P4		;SAVE P4 ON STACK
	LDB T1,[POINT 12,DEVCHR(F),35];T1:=BUFFER SIZE
	XCTBU <HRRZ W,JOBFF>	;W:=FIRST FREE LOCATION + 1
	ADDI W,1
	HRRZ P4,W
	HRL P4,T1		;P4:=BUFFER SIZE,FIRST FREE LOC + 1
	ADDI T1,2		;T1:=BUFFER SIZE + 2
	HRRZ T2,M		;T2:=N=ADDRESS FIELD OF AC M
	SKIPN T2	;MAKE A DEFAULT CASE
	MOVEI T2,STDRNG		;NONE,N:=SYSTEM STD RING
	HRRZ P1,T1		;BUFFER SIZE+2
	IMUL P1,T2		;TIME NO. OF BUFFERS
	ADD P1,P4		;LOC. OF FIRST BUFFER
	HRRZ P1,P1		;MAKE SURE POSITIVE
	SUBI P1,2		;READJUST FOR UPTREL COMPARISON
	UXCTBU <CAMG P1,JOBREL>	;WILL THIS SPACE FIT IN USER CORE?
	JRST BUFC1		;YES, FO DO INBUF CODE
				; NO, AUTOMATICALLY EXPAND SIZE OF USER CORE

	CORE P1,		;TRY TO ASSIGN CORE
	JFCL			;ERROR RETURN-LET ADR CHECK HAPPEN AND STOP JOB
BUFC1:	ADD P4,T1		;P4:=C(P4) + C(T1)
	UMOVEM P4,(W)	;BUFFER HEADER+1:=C(P4)
	HRR W,P4	;W 18-35:=C(P4 18-35)
	SOJG T2,BUFC1		;N:=N-1.  IS N GR 0?
	XCTBU <HRR P4,JOBFF>
	ADDI P4,1
	SUB W,T1
	UMOVEM P4,(W)	;LINK LAST BUFFER TO FIRST BUFFER
	ADDI W,-1(T1)
	XCTBU <HRRM W,JOBFF>	;JOBFF:=C(JOBFF)+1+N(BUFFER SIZE+2)
	HRR W,P4	;W:=IOUSE,ADDRESS OF FIRST BUFFER
				; IN RING.
	HRLI W,IOUSE
	POP P,P4		;RESTORE P4 FROM STACK.
	POPJ P,		;RETURN

;ROUTINE TO CLEAR IO BUFFER IN USER AREA
;CALLED AT INTERRUPT AND M LEVEL

;CALL:	HRRZ T1,REL. ADR. OF 2ND WORD OF USER BUFFER
;	PUSHJ P,BUFCLR
;	ERROR RETURN MEMORY EXCEEDED
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
; CLEARS THE WORD COUNT AND DATA AREA OF THE BUFFER WHOSE ADDRESS
; IS IN T1 18-35.

	INTERNAL BUFCLR

BUFCLR:
	PUSH P,T1		;SAVE FIRST BUFFER ADR.
	XCTBU <HLRZ T2,(T1)>		;T2 18-35=SIZE
	TRZ T2,400000
	ADD T1,T2		;LAST ADR=2ND ADR+SIZE
	TLZ T1,-1		;CLEAR LEFT HALF
	POP P,T2		;RESTORE FIRST ADR.
	HRL T2,T2
	AOBJN T2,.+1		;THIRD WORD IN BUFFER
	XCTBU <SETZM (T2)>		;CLEAR THIRD WORD
	AOS T2		;SET DEST. ADR. TO 4TH WORD
	XCTBU <BLT T2,(T1)>		;CLEAR BUFFER
	JRST CPOPJ1		;SUCESSFUL RETURN


;ROUTINE TO COMPUTE 12 BIT FOLDED CHECKSUM

;CALL:	PUSHJ P,CKS12
;	EXIT		ALWAYS RETURNS HERE
;CALCULATES FOLDED 12 BIT CHECKSUMS OF THE DATA WORDS IN THE
;BUFFER WHOSE ADDRESS IS IN AC TAC1.  TWO ALGORITHMS ARE USED.
;ON RETURN, THE LEFT HALF OF AC T1 CONTAINS A CHECKSUM OBTAINED
;BY ACCUMULATING, IN ONE'S COMPLEMENT, THE DATA WORDS AND FOLDING IT.
;THE LEFT HALF OF AC U CONTAINS A CHECKSUM OBTAINED BY ACCUMULATING,
;IN TWO'S COMPLEMENT, THE DATA WORDS AND FOLDING IT.  AC T2
;CONTAINS A 1.

	INTERN CKS12

CKS12:			;T2:=-WORD COUNT,ADDRESS OF FIRST DATA WORD
	AOS T2
	XCTBU <HRRZ T1,0(T2)>
	MOVNS T1
	AOS T2
	HRL T2,T1
	CLEARM T1		;INITIALIZE TWO'S COMPLEMENT SUM
CKS12A:	XCTBU <ADD T1,0(T2)>		;TWO'S COMPLEMENT ADD
	AOBJN T2,CKS12A	;DONE?
	LSHC T1,-30
	LSH T2,-14
	ADD T1,T2
	LSHC T1,-14
	LSH T2,-30
	ADD T1,T2
	TRZE T1,770000
	AOS T1
	HRLZS T1
	MOVEI T2,1		;T2:=1
	POPJ P,

;ROUTINE TO CLEAR RESIDUE OF WORD POINTED TO BY A BYTE POINTER

;CALL:	PUSHJ P,CLRBYT
;	EXIT		ALWAYS RETURNS HERE
;CALLED WITH A BYTE POINTER IN AC T1, IT CLEARS THE REST OF THE
;WORD POINTED TO BY THE BYTE POINTER.


CLRBYT:	LDB T2,[POINT 6,T1,5]	;T2:=P
	DPB T2,[POINT 12,T1,11]	;T1 0-5:=0,T1 6-12:=P
	SETZM T2
	DPB T2,T1		;CLEAR BITS 36-P THROUGH 35
	POPJ P,		;RETURN

;ROUTINE TO PUT EVEN PARITY IN ( OR TAKE IT OUT OF ) BIT 28 OF
;AC TEM. ASSUMING CHARACTER IS IN BITS 28-35 OF T3, REST CLEAR.
;T1 IS DESTROYED. CALLED FROM PTP AND TTY SERVICE ROUTINES

;CALL:	PUSHJ	P,PEVEN8
;	EXIT HERE WITH T3 SET TO EVEN PARITY

	INTERNAL PEVEN8

PEVEN8:	PUSH P,T1+1		;SAVE AC FOR DIVIDE
	LDB T1,[POINT 7,T3,35]	;GET ARGUMENT TO T1
	IMUL T1,[2010040201]	;COMPUTE PARITY
	AND T1,[21042104377]	; ..
	IDIVI	T1,3600	;ANSWER IN T1+1 LOW 8 BITS
	LDB T3,[POINT 8,T1+1,35]	;BACK INTO T3
	POP P,T1+1		;RESTORE AC
	POPJ P,0		;RETURN

;ROUTINE TO RELEASE ALL DEVICES ASSIGNED TO JOB


IORELS::MOVEI T1,RELEAS	;RELEASE ALL IO DEVICES(DON'T CLOSE)

;ROUTINE TO DO IO FOR ALL DEVICES ASSIGNED TO JOB
;CALL	MOVEI T1,ADR. OF IO SUB.
;	PUSHJ P,IOALL
;	RETURNS WITH J=CURRENT JOB # ,M PRESERVED


IOALL:	PUSH P,T1		;SAVE ADR. OF SUB.
	PUSH P,W
	PUSH P,M		;SAVE M
	HRRZ W,%UPT+UPTHCU
	CAILE W,MAXCHN
	STOPCD .		;JOB DATA AREA BAD
	MOVEI M,0
IOALL0:	SKIPN F,%UPT+UPTJDA(W)	;GET NEXT DDB ADR., IS IT IN USE?
	JRST IOALL1	;NO, KEEP GOING
	MOVE S,DEVIOS(F)
	DPB W,PUUOAC
	MOVE T4,DEVSER(F)	;SETUP ADR. OF DEV. DISP. TABLE
	PUSH P,W
	LDB T1,PJOBN		;GET JOB NUMBER WHICH JOB IS ASSIGNED TO
	CAMN T1,JOB		;IS IT SAME AS CURRENT JOB(SHOULD BE EXCEPT FOR 140
				; RESTART WHILE THIS JOB WAS SWAPPED OUT)
				; DEVICE DATA BLOCKS JOB NUMBERS ARE SET TO 0 ON
				; 140 RESTART,BUT THE JOB DATA AREA DEVICE ASSIGNMENTS
				; FOR SWAPPED OUT JOBS HAVE NOT
	PUSHJ P,@-3(P)	;YES,CALL THE SUB.
	POP P,W
IOALL1:	SOJGE W,IOALL0	;INCREMENT USER CHAN. NO.
	POP P,M		;RESTORE M & RETURN RESTORING T1 TOO
	POP P,W
	MOVE J,JOB		;GET JOB NO.
	JRST TPOPJ

;WAIT TILL ALL DEVICES ARE INACTIVE

INTERNAL IOWAIT

IOWAIT:	MOVEI T1,WAIT1
	JRST IOALL


;KILL ALL DEVICES(RELEASE WITHOUT WAITING FOR DEVICE INACTIVE)


IOKILL::MOVEI T1,RELEA5
	PUSHJ P,IOALL		;RELEASE ALL DEVICES WITHOUT WAITING

COMMENT ! ROUTINE SETUSR -- TO RECLAIM BUFFER AREA ABOVE USER
	PROG BY RESETTING  JOBFF TO LH(JOBSA), WHERE IT BEGAN.
	CLEAR JDA ARRAY IN UPT..NO CHANNELS IN USE
!


EXTERNAL UPTENB
SETUSR:
	UXCTBU <HLRZ T1,JOBSA>		;WE'RE GOING TO RESET JOBFF W/THIS
				;NOW WRITE ON USER'S JOBFF:
	UXCTBU <MOVEM T1,JOBFF>
	SETZM %UPT+UPTENB	;INITIALIZE APR TRAPPING (I.E., NONE)
	MOVEI T1,%UPT+UPTJDA+1	;FIRST LOC+1 TO CLEAR
	HRLI T1,%UPT+UPTJDA	;FIRST LOC.
	SETZM %UPT+UPTJDA
	BLT T1,%UPT+UPTJDA+MAXCHN
	SETZM %UPT+UPTHCU	;CLEAR HIGHEST USER IO CHAN. IN USE
	POPJ P,


;ROUTINE TO FLAG DEVICE ACTIVE
;CALL	MOVE S,IO STATUS BITS
;	MOVE F,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,SETACT
;CALLED BY ALL IO SERVICE ROUTINES AT M AND INTERRUPT LEVELS

INTERNAL SETACT,CLRACT,STOIOS,SETHNG
EXTERNAL PDVTIM,PDVCNT

ORACT:	TRO S,IOACT
	IORB S,DEVIOS(F)
	JRST SETHNG
SETACT:	TRO S,IOACT
	TLZA	S,IOW
CLRACT:	TRZ S,IOACT
STOIOS:	MOVEM S,DEVIOS(F)
SETHNG:	LDB T1,PDVTIM		;GET CODE FOR NO. OF SECONDS
	PUSH P,T1		;STACK THE CODE
	MOVEI T1,1		;COMPUTE 2**N-1
	LSH T1,@0(P)		; ..
	SUBI T1,1
	DPB T1,PDVCNT		;PUT TIME INTO THE COUNTER
	JRST TPOPJ		;RESTORE T1 AND RETURN

INTERNAL DEVCHK

DEVCHK:	HLRZ F,DEVLST
DEVCK0:	MOVE S,DEVIOS(F)	;IS DEVICE ACTIVE?
	TRNN S,IOACT
	JRST DEVCK1		;NO
IFCPU (F3),<;HACK FOR F3 TAPES UNTIL CONTROL IS FIXED
	MOVE	T1,DEVMOD(F)	;SEE IF ITS A TAPE ON F3
	TLNE	T1,DVMTA	;IS IT?
	PUSHJ	P,F3TRWC##	;CHECK FOR REWINDING TAPE.
>;END IFCPU (F3)
	LDB T1,PDVCNT		;YES,DECREMENT
	SOJL T1,DEVCK1		;0 MEANS IGNORE DEVICE
	DPB T1,PDVCNT
	JUMPN T1,DEVCK1	;HAS COUNT GONE TO 0?
	MOVE T4,DEVSER(F);YES, GET DISPATCH TABLE ENTRY
	PUSH P,F
	PUSHJ P,DHNG(T4)	;DISPATCH TO SERVICE ROUTINES TO 
				; UNHANG DEVICE
	PUSHJ P,DEVHNG	;PRINT ERROR MESSAGE AND STOP JOB
	POP P,F		;DO NOT PRINT MESS. AND STOP JOB RETURN
DEVCK1:	HLRZ F,DEVSER(F)
	JUMPN F,DEVCK0
	POPJ P,

;ROUTINE TO SETUP R AND J FOR INTERRUPT SERVICE ROUTINE

;CALL	PUSHJ P,IOSET
;	EXIT	ALWAYS RETURNS HERE
;THIS PROGRAM IS CALLED FROM AN INTERRUPT SERVICE ROUTINE.
;IT PUTS THE J POINTER (C(DEVCTR)) OF THE DEVICE SPECIFIED 
;BY AC F INTO AC ITEM.


	INTERNAL IOSET

IOSET:	MOVE J,DEVCTR(F)	;J:=J POINTER=C(DEVCTR)
	MOVE S,DEVIOS(F)	;GET IO STATUS FROM THE DDB
	POPJ P,		;RETURN

;CALLING SEQUENCE
;	PUSHJ P,IOSETC
;	EXIT		ALWAYS RETURNS HERE

;SETS JBFPTR18-35:=C(T2 18-35)
;	JBFCTR:=C(J)*[WORD LENGTH/BYTE SIZE]
;WHERE	WORD LENGTH:=36 DECIMAL
;	BYTE SIZE:=C(JBFPTR6-11)
;	[X]:= INTEGER PART OF X


IOSETC:	ADDI U,1		;JBFPTR12-18:=0
	HRLZI T1,7777		;JBFPTR18-35:=C(T2 18-35)+1
	XCTBU <ANDM T1,(U)>
	XCTBU <HRRM T2,(U)>
	XCTBU <AOS (U)>
	XCTBU <LDB T2,[POINT 6,(U),11]>	;T2:=BYTE SIZE
	PUSHJ P,ITMCT1	;JBFCTR:=C(J)*[36/BYTE SIZE]
	ADDI U,1
	XCTBU <MOVEM J,(U)>
	POPJ P,		;EXIT

;ROUTINE TO RETURN NO. OF ITEMS IN BUFFER

;CALL:	PUSHJ P,ITMSET
;	EXIT		ALWAYS RETURNS HERE
;SETS AC J:=(BUFFER SIZE-1)*[WORD LENGTH/BYTE SIZE]
;WHERE BUFFER SIZE:=BITS 1-17 OF THE BUFFER HEADER WORD POINTED TO
;		BY C(DEVADR)
;	WORD LENGTH:=36 DECIMAL
;	BYTE SIZE:=INTEGER PART OF X.

;CALLING SEQUENCE
;	PUSHJ P,ITMCNT
;	EXIT		ALWAYS RETURNS HERE
;SETS AC J:=C(J)*[WORD LENGHT/BYTE SIZE]

;CALLING SEQUENCE
;	PUSHJ P,ITMCT1
;	EXIT		ALWAYS RETURNS HERE
;SETS AC J:=C(J)*[WORD LENGHT/C(T2)]

	INTERN ITMCT1
ITMSET:	XCTBU <LDB J,[POINT 17,@DEVADR(F),17]>;J:=BUFFER SIZE-1
	SUBI J,1
ITMCNT:	LDB T2,[POINT 6,DEVPTR(F),11];T2:=BYTE SIZE
ITMCT1:	JUMPL J,ITMCT2	;BIT COUNT
	MOVEI T1,44		;J:=C(J)*[WORD LENGTH/C(T2)]
	IDIV T1,T2
	IMUL J,T1
	POPJ P,

ITMCT2:	TLZ J,(1B0)
	PUSH P,J+1
	IDIVI J,^D36	;GET WHOLE WORDS
	MOVE T1,J+1	;NUMBER OF EXTRA BITS
	POP P,J+1
	ADDI T1,-1(T2)	;ROUND
	PUSH P,T2
	IDIV T1,T2
	POP P,T2
	PUSH P,T1
	MOVEI T1,^D36
	IDIV T1,T2	;NUMBER OF BYTES/WORD
	IMUL J,T1
	ADDM J,(P)
	POP P,J
	POPJ P,		;DONE

;ROUTINE TO SET UP CONDITIONS FOR RETURN FROM INTERRUPT LEVEL ON
;DEVICE ERROR (UNIT RECORD)
;SERVICE ROUTINES USING THIS FACILITY MUST FOLLOW THE FOLLOWING PROTOCOL

;A.  AT INTERRUPT LEVEL,
;       IF NO ERROR AT END OF DATA: CLEAR IOSTBL IN LH(S)
;       IF ERROR:
;	1. STOP DEVICE
;	2. PUSHJ P,DEVERR
;	3. SET INTERNAL FLAGS TO REMEMBER ERROR CONDITION TO EFFECT
;	   RESTART AT A LATER TIME
;	4. DISMISS INTERRUPT

;B. AT UUO LEVEL ENTRANCES THE FOLLOWING MUST BE DONE

;	1. INIT/RELEASE - RESET INTERNAL ERROR FLAGS
;	2. INPUT/OUTPUT - IF ERROR FLAGS (INTERNAL) SET:
;	   A. CALL HNGSTP
;	   B. SEE IF DEVICE OK NOW (CALL HNGSTP AGAIN IF NOT)
;	   C. SET DEVICE FOR RESTART FROM INFO SAVED IN INTERNAL FLAGS
;	      AND RESET FLAGS
;	   NOTE: IOSTBL WILL ALWAYS BE CLEARED AT UUO ENTRANCE TO SERVICE ROUTINE

;	   IF NO ERROR FLAGS SET, NORMAL EXECUTION

	INTERN	DEVERR
	EXTERN	SETIOD

DEVERR:	TLO	S,IOSTBL	;SET ERROR FLAG
	TLZE	S,IOW		;IN I/O WAIT?
	PUSHJ	P,SETIOD	;YES - WAKE UP
	PJRST	CLRACT		;CLEAR I/O ACTIVE AND RETURN

;ROUTINE TO SET DEVICE STATUS WORD FROM M
;AND SETUP S


SETIOS:	MOVEI T1,0
	PUSHJ P,CHNCHK		;CHECK FOR CHANNEL ASSIGNED.
	 JRST ERRIUC		;ERROR, NO CHANNEL.
	JFCL			;SHORT DISPATCH TABLE OK.
SETIO2:	PUSHJ	P,WAIT1	;WAIT FOR DEVICE (INCLUDING TTY MONITOR COMMAND
				; RESPONSE WHEN USER INITS TTY)

	PUSHJ	P,CHKMOD	;CHECK FOR LEGAL MODE, IF NOT RIGHT DONT RETURN
	TRZ M,IOACT		;LET USER SET ALL BITS EXCEPT IOACT
	HRRM M,DEVIOS(F)
	POPJ P,

;CHECK FOR A LEGAL MODE FOR DEVICE


CHKMOD:	LDB T2,[POINT 4,M,35] ;GET DEVICE DATA MODE
	MOVEI T1,1		;AND CHECK FOR LEGALITY
	LSH T1,(T2)
	TDNE T1,DEVMOD(F)
	POPJ	P,		;OK
	JRST ERRIDM		;AND GIVE ILLEGAL MODE ERROR

;SETUP BYTE POINTER AND J COUNT
;CALL	PUSHJ P,NEWBUF
;	ADDRESS CHECK WHEN SETTING UP BUFFER
;	OK RETURN

INTERNAL NEWBF1,SETIO2

NEWBF1:
NEWBUF:	HRRZ T1,DEVADR(F)	;T1:=INPUT BUFFER HEADER ADDRESS
	PUSHJ P,BUFCLR	;CLEAR INPUT BUFFER.
	POPJ P,		;ADDRESS CHECK
	HRLZI T1,7737
	AND T1,DEVPTR(F)	;DEVPTR 0-5:=0, DEVPTR 12:=0
	HRR T1,DEVADR(F)	;DEVPTR 18-35:=C(DEVADR 18-35) + 1
	AOS T1
	MOVEM T1,DEVPTR(F)
	PUSHJ P,ITMSET	;J:=(BUFFER SIZE-1)*[36/BYTE SIZE]
	MOVEM J,DEVCTR(F)	;DEVCTR:=J COUNT
	JRST CPOPJ1		;RETURN

;ROUTINE TO SETUP BYTE POINTER ACCORDING TO DATA MODE

;CALL:	PUSHJ P,SETBYT
;	EXIT		ALWAYS RETURNS HERE
;SETS	T1 0-5:=0
;	T1 6-11:=S
;	T1 12-13:=0
;WHERE S=36 IF DATA MODE (S 32-25) IS BINARY (B)
;	OR DUMP (SD,D,DR)
;S SET FROM DISPATCH TABLE IF IMAGE (I) OR IMAGE BINARY (IB)
;      S=7  IF DATA MODE IS 	ASCII PACKED (A)
;			ASCII U (AL)
;	S=9 IF DATA MODE IS EXTENDED ASCII (XA)

	INTERN SETBYT

SETBYT:	TRNN S,10	;CHECK FOR A OR AL
	JRST	[HRLI T1,700	;YES, BYTE SIZE 7
		TRNE S,2
		HRLI T1,1100
		POPJ P,]
	TRNE S,4	;NO GET B, SD, D, DR
	JRST	[HRLI T1,4400	;BYTE SIZE 36
		POPJ P,]
	PUSH P,T1
	HRRZ T1,DEVSER(F)
	MOVE T1,DBYT(T1)	;GET BYTE SIZES
	TRNE S,3	;CHECK FOR IB
	MOVSS T1	;IT IS, USE RIGHT HALF
	TLZ T1,37		;CLEAR INDEX FIELD OF POINTER
	HLLM T1,(P)
	JRST TPOPJ	;AND RETURN THE INFORMATION


	LIT
	END


	LIT
	END
   o% 