TITLE	SWAMP	WHERE THE DISK PAGE ALLOCATORS AND FRIENDS LIVE

ENTRY SWAMP

SWAMP:


;EXTERNALS

EXTERN DEVATB,DEVDRB,DEV1UN

EXTERN DRBALC,DRBMXA

EXTERN PGYDRT,PGYERR

EXTERN ATBALP,ATBDUM

EXTERN UNIMCT,UNIPPU,UNISTR,UNISTT,UNITAL,UNYSPU,UNVRSF
EXTERN UNINAM

EXTERN STRDDB,STRTAL,STRUNI,STRNAM,STROVR,STRBTS,SRPRPT,SRPNDS

EXTERN MAPWTL,MAPWTU,MAPRLS,PCBLNK,PCBPTR,PCISTS,RELSAT,PCBPAG
EXTERN STDPRE,%CTLST,%CTUPT,%SAT.C,PPCBIO,SATWRT,STDREA,PSREQ,STDWAG,STDWRT
EXTERN SIREQ,GETLRS,%CTLRU,SIAVAL,PCMLCC,PCBLCC,PCBSTS,STPREA

EXTERN RBREAL,RBYUNI,RBYPNO,RBSPAR,RBYUN1,RBMASK

EXTERN STTAOB,STTFPC,STTLEN,STTPTR,STYBAD,STYINC,STPBAD,STPCHK
EXTERN STTSTS,STPINC,STPRPT

EXTERN CPOPJ,CPOPJ1,GETER2,IOSALC,UNTTBL,UNPSER,INLMES,PRNAME
EXTERN TTYFUW,TTYSTR,STOIOS,DSKPIF,DSKPIN,WRDSPP,CURUPT,EPT
EXTERN SATBAD,DBLMSG,NCTXPG,SATBRD,JBYWPT,UNTLEN,DFRLST

EXTERN SLOCLE



;SOME DEFINITIONS

DEFINE DSKOFF <WRPI DSKPIF>
DEFINE DSKON <WRPI DSKPIN>

	SUBTTL	DISK ALLOCATION AND DEALLOCATION.

COMMENT #
@@SUBROUTINE GETPAG/GETAPG/KEPPAG
@@PURPOSE
SUBROUTINE TO GET A PAGE ON THE DISK.
@@ENTRY
THERE ARE THREE ENTRY POINTS:

	GETPAG		GET A PAGE, CONTIGUOUS IF POSSIBLE.
	KEPPAG		IDENTICAL TO GETPAG EXCEPT SUCCESS
			RETURN HAS SAT IN %SAT.
	GETAPG		GET A PAGE ANYWHERE.

THE GETPAG ENTRY POINT EXPECTS T2/DISK PNTR TO BE CONTIGUOUS
WITH ON THE UNIT.  IF T2=0, GETPAG WILL JUST DISPATCH TO GETAPG.
BOTH ENTRY POINTS EXPECT:

	T1/ BITS 0 TO 33 TO BE ZERO, BIT 34 TO BE THE REQUESTED
	    SETTING OF THE F BIT, AND BIT 35 TO BE THE REQUESTED
	    SETTING OF THE M BIT.
	T3/ ATB ADDRESS OR ZERO.  ZERO IS ONLY FOR REAL FILES
	    THAT DO NOT HAVE AN ATB.
	F/ DDB IF THIS IS A REAL FILE.  F IS IGNORED FOR OTHERS.
	S/ DEVIOS IF THIS IS A REAL FILE.
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@EXIT
IF GET A PAGE, SKIP RETURN WITH T2/ DISK POINTER TO GOTTEN PAGE.
NON-SKIP RETURN ON CAN'T GET A PAGE.
@@ #

INTERN FBIT,MBIT
FBIT==2
MBIT==1

INTERNAL GETPAG,GETAPG,KEPPAG

KEPPAG:	MOVEI	T4,SRPNDS	;DSKCLN NEEDED?
	TDNE	T4,STRDDB+STRBTS ;
	POPJ	P,		;YES, TREAT LIKE QUOTA EXCDED.
	PUSH	P,[-1]		;FLAG TO KEEP THE SAT.
	JUMPE	T2,GETA00	;GETAPG+1.
	JRST	GETPA0		;

GETPAG:	MOVEI	T4,SRPNDS	;DSKCLN NEEDED AND ASKING FOR A
	TDNE	T4,STRDDB+STRBTS ;
	TRNN	T1,FBIT		;FILE PAGE?
	JRST	.+2		;NO.
	POPJ	P,		;YES, PRETEND QUOTA EXCDED.
	PUSH	P,[0]		;FLAG TO NOT KEEP THE SAT.
	JUMPE	T2,GETA00	;GETAPG+1.
GETPA0:	TLNN	T2,RBMASK-RBREAL
	TLNN	T2,RBREAL	;
	STOPCD
	CAIL	T1,1		;MAKE SURE AT LEAST ONE OF THE F
	CAILE	T1,3		;& M BITS IS REQUESTED SET.
	STOPCD
	PUSH	P,P1		;
	PUSH	P,P2		;
	PUSH	P,PG		;
	PUSH	P,U		;SAVE U.
	PUSH	P,T3		;SAVE ATB.
	PUSH	P,T1		;SAVE REQ SETTING OF F AND M.
	SETO	P2,		;FLAG TO ZAP AOBJN POINTER.
	LDB	T3,RBYUNI	;SEE IF
	MOVE	T3,UNTTBL(T3)	;WE ARE
	LDB	T4,RBYPNO	;GOING OVER
	CAML	T4,UNIPPU(T3)	;THE EO UNIT.
	JRST	[PUSHJ P,GETSTT	;YES.  GET T2/ STT ENTRY.
		JRST GETPG1]	;
	ADDI	T2,1		;NO. GET T1/ STT ADR, T2/ ADR
	PUSHJ	P,GETSTT	;OF STT ENTRY, T3/# PGS INTO SAT, U/UNIT.
	JUMPN	T3,GETPG2	;OKAY IF NOT 1ST IN A SAT.
    ;HERE TO LOOK AT THE SAT FOR THE PREVIOUS PAGE.
	SUBI	T2,STTLEN	;BACK UP A SAT.
GETPG1:	MOVE	T1,STTPTR(T2)	;ROOM IN THE
	PUSHJ	P,LOKSAT	;SAT?
	JRST	GETP24		;NO.
	JRST	SEARCH		;YES, GET IT.

    ;HERE TO LOOK AT THE SAT FOR THIS PAGE.
GETPG2:	MOVE	T1,STTPTR(T2)	;ROOM ON THIS PAGE'S
	PUSHJ	P,LOKSAT	;SAT?
	JRST	GETP24		;FAIL.
	JRST	GETP26		;WIN.
GETP24:	SKIPN	T3,-1(P)	;NO. REAL FILE?
	JRST	.+3		;YES.
	SKIPGE	ATBDUM(T3)	;STILL MAYBE.
	JRST	GETPG4		;NO, CAN'T BE SINGLE UNIT.
	SKIPN	DEV1UN(F) 	;SINGLE UNIT STUFF?
	JRST	GETPG4		;NO.
	JRST	GETPGU		;YES.
GETP26:	PUSH	P,T3		;YES,
	IDIVI	T3,^D36		;IS
	ADDI	T3,%SAT		;THE
	MOVNS	T4		;PAGE
	MOVSI	T1,400000	;WE
	LSH	T1,(T4)		;WANT
	TDNE	T1,(T3)		;FREE?
	TDNN	T1,400(T3)	;
	JRST	[POP P,T3	;NO.  GET THE BIRD IN HAND.
		JRST SEARCH]
	EXCH	T1,T3		;YES, FINISH
	SETZ	P2,		;PROTECT AOBJN POINTER.
	JRST	SEADON		;UP.

    ;ROOM ON AN IN-CORE SAT FOR SAME UNIT?
GETPG4:	MOVEI	T3,1		;ROOM ON AN IN CORE SAT
	PUSHJ	P,LOKUNI	;FROM THIS SAME UNIT?
	JRST	GETAP0		;NO.
	JRST	SEARCH		;YES, GO FIND IT.

    ;HERE TO GET SPACE ANYPLACE.
    ;FIND THE UNIT WITH THE MOST FREE SPACE AND SEE IF THERE IS
    ;A SAT IN CORE FROM IT.
GETAPG:	MOVEI	T4,SRPNDS	;DSKCLN NEEDED AND ASKING FOR A
	TDNE	T4,STRDDB+STRBTS ;
	TRNN	T1,FBIT		;FILE PAGE?
	JRST	.+2		;OKAY.
	POPJ	P,		;YES, PRETEND QUOTA EXCEEDED.
	PUSH	P,[0]		;FLAG TO NOT KEEP THE SAT.
GETA00:	CAIL	T1,1		;CHECK REQUESTED SETTINGS
	CAILE	T1,3		;OF F AND M.
	STOPCD
	PUSH	P,P1		;
	PUSH	P,P2		;
	PUSH	P,PG		;
	PUSH	P,U		;
	PUSH	P,T3		;
	PUSH	P,T1		;SAVE REQ SETTING OF F AND M.
	SETO	P2,		;FLAG TO ZAP AOBJN POINTER.
	JUMPE	T3,.+3		;NO. REAL FILE?
	SKIPGE	ATBDUM(T3)	;STILL MAYBE.
	JRST	GETAP0		;NO.
	SKIPE	DEV1UN(F)	;NO, SPECIAL UNIT STUFF?
	JRST	GETPGU		;YES.
GETAP0:	PUSHJ	P,MOSPAU	;U/UNIT WITH MOST FREE SPACE.
	JRST	GETFAL		;NO SPACE.
	MOVEI	T3,1		;ROOM ON A SAT IN CORE FROM
	PUSHJ	P,LOKUNI	;THE UNIT WITH THE
	JRST	GETAP5		;MOST FREE SPACE?  NO.
	JRST	SEARCH		;YES.

    ;NO SAT IN CORE FROM THE UNIT WITH THE MOST FREE SPACE.
    ;ARE ALL THE SAT PCBS "IN USE"?
INTERN SATFUL
SATFUL:	 Z	;SET <>0 WHEN ALL THE SAT PCBS ARE FULL.
		;=0 MEANS MAY OR MAY NOT BE FULL.
GETAP5:	SKIPE	SATFUL		;ARE THE SAT PCBS FULL?
	JRST	GETAP6		;YES.
	HRRZ	T2,%SAT.C+%CTLST ;MAYBE. T2/ ADDR OF A SAT PCB.
GETA51:	SKIPN	PCBPTR(T2)	;HAS A DISK POINTER?
	JRST	GETAP8		;NO--NOT "IN USE".
	HRRZ	T2,PCBLNK(T2)	;PROBABLY "IN USE". CONTINUE
	JUMPN	T2,GETA51	;IF THERE IS A NEXT PCB.
	SETOM	SATFUL		;MARK THE SAT PCBS FULL.

    ;HERE WHEN ALL SAT PCBS ARE IN USE.  TRY TO GET SPACE ON THE
    ;ONE WITH THE MOST FREE SPACE.
GETAP6:	PUSH	P,P2		;SAVE P2 AND
	PUSH	P,P3		;P3.
	SETZ	P1,		;P1/ MOST SPACE FOUND SO FAR.
	HRRZ	P3,%SAT.C+%CTLST ;ADDR OF A SAT PCB.
GETA62:	MOVE	T2,PCBPTR(P3) 	;GET ITS
	PUSHJ	P,GSATST	;STT ENTRY TO T2.
	HLRZ	T3,STTSTS(T2)	;IN
	TRNE	T3,STPINC	;CORE?
	TRNE	T3,STPBAD	;IGNORE BAD ONES.
	JRST	GETA65		;
	CAML	P1,STTFPC(T2)	;YES. MORE SPACE THAN PREVIOUS?
	JRST	GETA65		;NO.
	MOVE	P1,STTFPC(T2)	;YES-P1/ MOST SPACE FOUND AND
	MOVE	P2,T2		;P2/ WHERE FOUND.
GETA65:	HRRZ	P3,PCBLNK(P3)	;GET NEXT PCB ADDRESS.
	JUMPN	P3,GETA62	;JUMP ON ANOTHER
	POP	P,P3		;RESTORE P3.
	JUMPN	P1,GETA69	;SPACE FOUND IN IN CORE SATS?

    ;HERE ON NO SPACE IN IN-CORE SATS.  READ IN 1ST PARTLY
    ;EMPTY SAT ON THE EMPTIEST UNIT.
	POP	P,P2		;RESTORE P2.
GETA66:	PUSHJ	P,MOSPAU	;FIND UNIT WITH MOST FREE SPACE.
	JRST	GETFAL		;NO SPACE.
	SETZ	T3,		;FIND ITS FIRST PARTLY EMPTY
	PUSHJ	P,LOKUNI	;SAT (IN-CORE OR OUT.).
	JRST	GETA66		;NONE.
	JRST	SEARCH		;

    ;HERE ON SPACE FOUND ON IN-CORE SAT.
GETA69:	MOVE	T1,STTPTR(P2)	;SET UP T1 AND T2
	MOVE	T2,P2		;FOR LOKSAT.
	POP	P,P2		;RESTORE P2.
	PUSHJ	P,LOKSAT	;GET PAGE FROM
	JRST	GETAP6		;SAT IN CORE
	JRST	SEARCH		;WITH MOST SPACE.

    ;HERE WHEN NOT ALL THE SAT PCBS ARE IN USE.
    ;TRY TO READ IN A SAT FROM UNIT WITH THE MOST FREE SPACE.
GETAP8:	HRRZ	T2,UNISTT(U)	;IS THERE A SAT
GETA82:	HLRZ	T3,STTSTS(T2)	;ON THIS UNIT
	TRNN	T3,STPBAD	;THAT IS NOT
	TRNE	T3,STPINC	;IN CORE?
	JRST	GETA83		;
	MOVE	T1,STTPTR(T2)	;YES,
	PUSHJ	P,LOKSAT	;IS THERE SPACE IN IT?
	JRST	GETA83		;FAILED.  GO TRY AGAIN.
	JRST	SEARCH		;
GETA83:	ADDI	T2,STTLEN	;
	SKIPE	STTPTR(T2)	;
	JRST	GETA82		;
	JRST	GETAP0		;NO.

;HERE WHEN THERE IS A FREE PAGE IN A SAT THAT WE HAVE MAP WRT LOCKED.
;ENTER WITH T2/ ADDRESS OF STT ENTRY.

SEARCH:	SKIPN	T1,STTAOB(T2)	;IF NOT IN MIDDLE OF THIS SAT,
SEARC1:	MOVE	T1,[XWD -400,%SAT] ;START AT ITS BEGINNING.
	MOVE	T4,T1		;SAVE FOR CHECK BELOW.
SEAR13:	SKIPE	T3,(T1)		;ANY BITS FREE IN THIS WORD?
	SKIPN	P1,400(T1)	;
	AOBJN	T1,SEAR13	;NO, GO TO NEXT WORD.
	AND	T3,P1		;
	JUMPN	T3,SEARC2	;
	AOBJN	T1,SEAR13	;
SEAR15:	CAMN	T4,[XWD -400,%SAT] ;OUT OF WORDS. GO TO
	STOPCD	(SLO)		;BEGINNING, UNLESS THAT IS
	JRST	SEARC1		;WHERE WE STARTED.

    ;HERE ON A FREE BIT IN THIS WORD.
SEARC2:	JFFO	T3,.+2		;GET T4/ NO. OF BITS INTO WORD.
	STOPCD
	HRRZI	T3,(T1)		;CALC THE
	SUBI	T3,%SAT		;NO. OF
	IMULI	T3,^D36		;PAGES INTO
	ADDI	T3,(T4)		;THIS SAT, AND SAVE FOR
	PUSH	P,T3		;DISK PNTR CALC BELOW.
	MOVNS	T4		;SET THE
	HRLZI	T3,400000	;GOTTEN
	LSH	T3,(T4)		;BITS.
SEADON:	MOVE	T4,-1(P)	;GET REQUESTED F&M SETTING.
	TDNE	T3,(T1)		;DEBUGGING
	TDNN	T3,400(T1)	;CHECK.
	STOPCD
	TRNN	T4,FBIT!MBIT	;DEBUGGING CHECK.
	STOPCD
	TRNE	T4,FBIT		;WANT TO SET F BIT?
	ANDCAM	T3,(T1)		;YES, DO SO.
	TRNE	T4,MBIT		;WANT TO SET M BIT?
	ANDCAM	T3,400(T1)	;YES, DO SO.
	SOSGE	STTFPC(T2)	;ADJUST THE FREE PAGE COUNT.
	STOPCD (SLO)
	JUMPE	P2,SEARC4	;DON'T TOUCH AOBJN IF GOT SPECIFIC PAGE.
	AOBJP	T1,SEARC3	;
	AOBJP	T1,SEARC3	;SO ADJUST IT
	AOBJN	T1,.+2		;UP THREE
SEARC3:	SETZ	T1,		;WORDS.
	MOVEM	T1,STTAOB(T2)	;STORE IT.

    ;HERE TO GET THE DISK POINTER TO THE GOTTEN PAGE INTO T2.
SEARC4:	PUSHJ	P,GETPNO	;T2/ BASE DISK POINTER.
	POP	P,T3		;RESTORE NO. OF WORDS INTO THIS SAT.
	ADDI	T2,(T3)		;T2/ DISK PNTR TO GOTTEN PAGE.
	TLO	T2,RBREAL	;
	MOVEM	T2,(P)		;SAVE T2 FROM MAPRLS, F&M UNNECC.
	MOVE	T1,-6(P)	;FLAG FOR KEEPING SAT.
	JUMPN	T1,.+3	MOVEI	PG,%SAT.C	;RELEASE THE
	PUSHJ	P,MAPRLS	;SAT.
	MOVEI	T1,1		;ARG FOR UPDCNT (ALLOC.).
	MOVE	T2,(P)		;
	LDB	U,RBYUNI	;
	MOVE	U,UNTTBL(U)	;
	MOVE	T2,-1(P)	;T2/ ATB ADDB OR 0.
	PUSHJ	P,UPDACT	;UPDATE COUNTS.
	POP	P,T2		;RESTORE T2/ DISK POINTER.
	POP	P,T3		;
	POP	P,U		;RESTORE U.
	POP	P,PG		;
	POP	P,P2		;
	POP	P,P1		;
	POP	P,T1		;CLEAR PDL.
	JRST	CPOPJ1		;SUCCESS RETURN.




;HERE FOR ALL ON A SPECIAL UNIT.
GETPGU:	MOVE	U,DEV1UN(F)	;THIS IS THE UNIT.
	MOVEI	T3,1		;FIRST LOOK AT ITS IN-CORE SATS.
	PUSHJ	P,LOKUNI	;
	TDZA	T3,T3		;NOT FOUND, SO LOOK AT ALL OF
	JRST	SEARCH		;
	PUSHJ	P,LOKUNI	;ITS SATS.
	JRST	GETFAL		;
	JRST	SEARCH		;FOUND.


GETFAL:	POP	P,T1
	POP	P,T3		;
	POP	P,U
	POP	P,PG
	POP	P,P2		;
	POP	P,P1		;
	POP	P,T1		;CLR PDL.
	POPJ	P,

COMMENT #
@@SUBROUTINE GTSPAG/GTSAPG
@@PURPOSE
SUBROUTINE TO GET A BLOCK OF CONTIGUOUS PAGES FOR THE SWAPPER
ON THE DISK.
@@ENTRY
THERE ARE TWO ENTRY POINTS:

	GTSPAG		GET A BLOCK OF PAGES, STARTING IMMED
			AFTER THE SPECIFIED PAGE, IF POSSIBLE.
	GTSAPG		GET A BLOCK OF PAGES ANYWHERE.

THE GTSPAG ENTRY POINT EXPECTS T2/DISK PNTR TO BE CONTIGUOUS
WITH ON THE UNIT;  IF T2=0, GTSPAG WILL DISPATCH TO GTSAPG.
BOTH ENTRY POINTS EXPECT T1 BITS 0 TO 33 TO BE ZERO, BIT 34
TO BE THE REQUESTED SETTING OF THE F BIT, AND BIT 35 TO BE THE
REQUESTED SETTING OF THE M BIT.
BOTH ENTRY POINTS EXPECT LH(T3)=NO. OF CONTIGUOUS PAGES TO TRY
TO GET.
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@EXIT
IF GET AT LEAST ONE PAGE, SKIP RETURN WITH T2/ DISK POINTER TO
FIRST PAGE GOTTEN AND T3/ NO. OF PAGES GOTTEN.
NON-SKIP RETURN ON CAN'T GET A PAGE, WITH T1/ STRTAL (SO=0 MEANS
NO DISK SPACE AVAILABLE, <>0 MEANS WAITING FOR SAT, ETC.).
@@ #

INTERNAL GTSPAG,GTSAPG

    ;CHECK THE ARGS FOR VALIDITY.
GTSPAG:	MOVEI	T4,SRPNDS	;DSKCLN NEEDED AND ASKING FOR A
	TDNE	T4,STRDDB+STRBTS ;
	TRNN	T1,FBIT		;FILE PAGE?
	JRST	.+2		;OKAY.
	JRST	[SETZ T1,	;YES, PRETEND QUOTA
		POPJ P,]	;EXCEEDED.
	JUMPE	T2,GTSAPG	;
	TLNN	T2,RBMASK-RBREAL ;BE SURE THE RETRIEVAL PNTR
	TLNN	T2,RBREAL	;IS LEGAL.
	STOPCD
	CAIL	T1,1		;BE SURE T1 HAS ONLY THE F AND
	CAILE	T1,3		;M BITS SET.
	STOPCD
	TLNN	T3,-1		;CHECK COUNT OF PAGES.
	STOPCD

	PUSH	P,P1		;
	PUSH	P,P2		;
	PUSH	P,PG		;
	PUSH	P,U		;
	PUSH	P,T1		;SAVE F AND M BITS.
	PUSH	P,T3		;SAVE COUNT, ATB ADDRESS.
	LDB	T3,RBYUNI	;GOING
	MOVE	T3,UNTTBL(T3)	;OVER
	LDB	T4,RBYPNO	;END OF
	CAML	T4,UNIPPU(T3)	;UNIT?
	JRST	[SETZ P1,	;YES, CAN'T BE CONTIG.
		PUSHJ P,GETSTT	;
		JRST GTSPG2]	;
	ADDI	T2,1		;NO, GOING OVER END
	PUSHJ	P,GETSTT	;OF
	MOVE	P1,T3		;
	JUMPN	T3,GTSPG2	;SAT?
	SUBI	T2,STTLEN	;
    ;HERE WITH STT ENTRY ADDR IN T2 AND, IF WE CAN TRY FOR
    ;CONTIGUITY, NO. OF BITS INTO SAT IN P1, ELSE P1/0.
GTSPG2:	SKIPG	STTFPC(T2)	;
	JRST	GTSAP0		;MAYBE BAD, MAYBE NO ROOM.
	LDB	T1,STYINC	;FORGET IT IF NOT
	JUMPE	T1,GTSAP0	;IN CORE.
    ;HERE WITH THE SAT WE WANT IN CORE, AND WITH SOME
    ;SPACE.  T2/ HAS STT ENTRY ADDR AND P1/ HAS CONTIG COUNT,
    ;GET PG/ CORE PAGE NUMBER.
    ;CHECK FOR GOODNESS.
	HRRZ	P2,%SAT.C+%CTLST ;FIND
	HLRZ	T1,PCBPAG(P2)	;THE
	JUMPN	T1,GTSPG3	;CORE
	HRRZ	P2,PCBLNK(P2)	;PAGE
	JUMPN	P2,.-3		;NUMBER
	STOPCD
GTSPG3:	MOVE	T1,STTPTR(T2)	;AND
	CAMN	T1,PCBPTR(P2)	;STORE
	JRST	GTSPG4		;IT
	HRRZ	P2,PCBLNK(P2)	;IN
	JUMPN	P2,.-3		;PG.
	STOPCD
GTSPG4:	HLRZ	PG,PCBPAG(P2)	;
	HRLZI	T1,PCMLCC	;CHECK THAT THE
	TDNE	T1,PCBLCC(P2)	;SAT IS NOT LOCKED
	JRST	GTSAP0		;UP BY SOMEBODY.

	PUSHJ	P,SSTCHK	;CHECK SAT FOR GOODNES.
	JRST	GTSA52		;OKAY.
	JRST	GTSAP0		;BAD.  FORGET IT.

    ;CHECK THE ARGS FOR VALIDITY.
GTSAPG:	MOVEI	T4,SRPNDS	;DSKCLN NEEDED AND ASKING FOR A
	TDNE	T4,STRDDB+STRBTS ;
	TRNN	T1,FBIT		;FILE PAGE?
	JRST	.+2		;OKAY.
	JRST	[SETZ T1,	;YES, PRETEND QUOTA
		POPJ P,]	;EXCEEDED.
	CAIL	T1,1		;BE SURE T1 HAS ONLY THE F AND
	CAILE	T1,3		;M BITS SET.
	STOPCD
	TLNN	T3,-1		;CHECK COUNT OF PAGES.
	STOPCD


	PUSH	P,P1		;SAVE
	PUSH	P,P2		;SOME
	PUSH	P,PG		;ACS.
	PUSH	P,U		;WORKING

	PUSH	P,T1		;SAVE F AND M BITS.
	PUSH	P,T3		;SAVE COUNT, ATB ADDRESS.

    ;SET UP P1/ 0 AND P2/ ADDR OF 1ST PRIMARY PCB.
GTSAP0:	SETZ	P1,		;
	HRRZ	P2,%SAT.C+%CTLST ;SKIP OVER THE
	DSKOFF
	HLRZ	T3,PCBPAG(P2)	;SECONDARY PCBS.
	JUMPN	T3,GTSAP4	;JUMP IF A PRIMARY.
	HRRZ	P2,PCBLNK(P2)	;GET THE NEXT PCB.
	JUMPN	P2,.-3		;MUST BE SOME PRIMARIES.
	STOPCD

    ;LOOK THRU THE PRIMARY PCBS FOR A GOOD, PARTLY EMPTY, IN
    ;CORE SAT, OR FAILING THAT, ONE GOOD, PARTLY EMPTY, AND ON
    ;ITS WAY IN.
GTSA40:	HRRZ	P2,PCBLNK(P2)	;GET NEXT PCB.
	JUMPE	P2,GTSAP7	;JUMP IF NONE LEFT.
      ;HERE WITH A PCB.  SEE IF ITS SAT HAS ANY ROOM.
GTSAP4:	SKIPN	T1,PCBPTR(P2)	;IS THERE A SAT IN THIS PCB?
	JRST	GTSAP7		;NO, NO MORE SATS IN PCBS.
	LDB	U,RBYUN1	;YES.  GET
	MOVE	U,UNTTBL(U)	;T3/
	MOVE	T3,UNISTT(U)	;ITS
GTSA42:	CAMN	T1,STTPTR(T3)	;STT
	JRST	GTSA45		;ENTRY
	ADDI	T3,STTLEN	;ADDR.
	SKIPN	STTPTR(T3)	;
	STOPCD (SLO)
	JRST	GTSA42		;
GTSA45:	SKIPN	STTFPC(T3)	;ROOM IN IT?
	JRST	GTSA40		;NO, LOOK AT NEXT PCB.
	HRLZI	T1,PCMLCC	;UUNLOCKED?
	TDNE	T1,PCBLCC(P2)	;
	JRST	GTSA40		;NO.
      ;IS THE SAT IN CORE?
	HRRZ	T2,P2		;
	LDB	T1,PCISTS	;DATA
	TRNE	T1,STDPRE	;PRESENT?
	JRST	GTSA48		;YES, GO CHECK IT FOR GOODNESS.
      ;SAT ISN'T IN CORE.  IS IT ON ITS WAY IN?
	TRNE	T1,STDREA	;COMING IN?
	JRST	[MOVEI P1,1	;YES, REMEMBER THAT.
		JRST GTSA40]	;
	CAIGE	P1,1		;NO, REMEMBER THAT, TOO,
	MOVEI	P1,(P2)		;UNLESS ANOTHER ONE ON ITS
	JRST	GTSA40		;WAY IN.
      ;HERE WITH A PARTLY EMPTY IN CORE SAT.  CHECK IT FOR
      ;GOODNESS.
GTSA48:	HRRZI	T2,(T3)		;T2/ STT ENTRY ADDR FOR SSTCHK.
	HLRZ	PG,PCBPAG(P2)	;PG/ CORE PAGE NUMBER.
	PUSHJ	P,SSTCHK	;CHECK THIS SAT.
	JRST	GTSAP5		;OKAY.
	SKIPLE	T1,STRDDB+STRTAL ;BAD.  ENOUGH SPACE LEFT TO
	JRST	GTSA40		;KEEP LOOKING?
	DSKON
	JRST	GTSNRM		;NO.

    ;HERE ON GOOD, PARTLY EMPTY IN CORE SAT FOUND.
GTSAP5:	DSKON
	SETZ	P1,		;FLAG TO SSERCH FOR NO CONTIG.
GTSA52:	HLL	U,(P)		;GET U/ COUNT REQ,, UNIT DDB.
	POP	P,T4		;
	EXCH	P2,(P)		;GET P2/ F AND M BITS.
	PUSHJ	P,SSERCH	;GET T2/RET PNTR, T3/NO. GOTTEN.
      ;IF THIS PCB IS CLEAN AND ON THE LRU-MRU LIST, WE MUST
      ;TAKE IT AS A RESOURCE, AS FINPCB CANNOT TELL THIS
      ;FROM A DIRTY SAT RELEASED BY ITS LAST USER, AND FINPCB
      ;WILL GIVE IT BACK AS A RESOURCE.
	POP	P,P2		;P2/ PCB ADDRESS, AGAIN.
	MOVEI	T4,3		;ADJUST THE SAT WRITE WAIT
	MOVEM	T4,SATWRT	;COUNT.
	LDB	T1,PGYDRT	;IS THIS PCB ALREADY
	JUMPN	T1,GTSWIN	;DIRTY?
	DPB	T4,PGYDRT	;NO.  IT IS NOW.
	MOVE	T1,%SAT.C+%CTLRU ;IS THIS FORMERLY CLEAN PCB
	SKIPN	(T1)		;ON
	JRST	GTSWIN		;THE
	CAME	P2,(T1)		;LRU-MRU
	AOJA	T1,.-3		;LIST?
	AOSG	SIREQ		;YES, PRETEND WE
	JRST	GTSWIN		;HAVE
	SKIPE	SIAVAL		;A
	AOS	SIAVAL		;RESOURCE.
	JRST	GTSWIN		;

    ;HERE WHEN NO ROOM IN A SAT IN CORE.  NOW, UNLESS WAITING,
    ;NEED BOTH A FREE PCB AND A PARTLY EMPTY OUT OF CORE
    ;SAT TO PULL IN.
GTSAP7:	CAIN	P1,1		;WAIT IF SOMEBODY ON
	JRST	GTSWAT		;THEIR WAY IN.
	JUMPE	P1,GTSA70	;IF SOMEBODY LAYING AROUND,
	MOVEI	T2,(P1)		;DOING NOTHING, BOOT THEM
	LDB	T1,PCISTS	;AWAKE.
	TRO	T1,STDREA	;
	DPB	T1,PCISTS	;
	SETZ	T4,		;
	PUSHJ	P,PPCBIO	;THIS TURNS ON THE DISK.
	JRST	GTSWAT		;
      ;CAN WE GET A PCB?
GTSA70:	HRRZ	P2,%SAT.C+%CTLST ;NOT IF
	HLRZ	T1,PCBPAG(P2)	;ANY
	JUMPE	T1,GTSWAT	;SECONDARIES
	MOVE	T1,PSREQ	;OR
	AOJG	T1,GTSWAT	;PS FULL
	MOVE	T1,SIREQ	;OR
	AOJG	T1,GTSWAT	;SI FULL.
      ;FIND AN OUT OF CORE PARTLY EMPTY SAT.
	HLRZ	U,STRDDB+STRUNI ;
GTSA71:	MOVE	T2,UNISTT(U)	;FIND
GTSA72:	SKIPN	STTPTR(T2)	;A
	JRST	GTSA75		;PCB
	SKIPN	STTFPC(T2)	;WITH ROOM
	JRST	GTSA74		;AND
	LDB	T1,STYINC	;OUT
	JUMPN	T1,GTSA74	;OF CORE.
	MOVE	T1,%SAT.C+%CTLST ;AS WELL, IT
GTSA73:	SKIPN	T3,PCBPTR(T1)	;CAN'T ALREADY
	JRST	GTSA77		;BE IN
	CAMN	T3,STTPTR(T2)	;A
	JRST	GTSA74		;PCB.
	HRRZ	T1,PCBLNK(T1)	;LOOK AT NEXT PCB.
	JUMPN	T1,GTSA73	;
	JRST	GTSA77		;
GTSA74:	ADDI	T2,STTLEN	;
	JRST	GTSA72		;
GTSA75:	HLRZ	U,UNISTR(U)	;NEXT UNIT.
	JUMPN	U,GTSA71	;
	JRST	GTSWAT		;
      ;FIND A PCB WE CAN READ IN.
GTSA77:	PUSH	P,STTPTR(T2)	;
	MOVEI	PG,%SAT.C	;GET T2/
	PUSHJ	P,GETLRS	;PCB ADDR.
	STOPCD
	POP	P,T1		;
	TLNE	T1,RBREAL	;DEBUGGING
	TLNE	T1,RBMASK-RBREAL	;CHECK.
	STOPCD
	MOVEM	T1,PCBPTR(T2)	;
	LDB	T1,PCISTS	;SET STATUS
	TRNE	T1,STDWRT!STDWAG!STDREA ;DEBUGGING CHECK.
	STOPCD
	TRO	T1,STDREA	;TO
	DPB	T1,PCISTS	;READING, AND
	SETZ	T4,		;START
	PUSHJ	P,PPCBIO	;THE READ.
	JRST	GTSWAT		;



GTSWAT:	DSKON
GTSNRM:	SOS	-6(P)		;
	SUB	P,[XWD 2,2]	;CLR JUNK FROM PDL.
GTSWIN:	POP	P,U		;
	POP	P,PG		;
	POP	P,P2		;
	POP	P,P1		;
	JRST	CPOPJ1		;

COMMENT #
@@SUBROUTINE SSERCH
@@PURPOSE
SUBR TO FIND SOME CONTIGUOUS PAGES FOR GTSAPG/PAG.  SETS F AND M
BITS FOR ALL THE PAGES AS REQUESTED BY CALLER.  ADJUSTS
STTFPC, UNITAL, AND STRTAL.
@@ENTRY
EXPECTS T2/ STT ENTRY ADDR,
U/ COUNT OF PAGES TO TRY FOR,, UNIT DB ADDR, P2/ F AND M
BIT SETTINGS.  IF P1 IS NON-ZERO, IT IS A COUNT OF THE NUMBER OF
BITS INTO THE SAT FOR A CONTIGUITY TRY.
%SWP SLOT IS ALREADY SET ON ENTRY.
@@ACCUM
DESTROYS T1-T4 AND P1-P2.
@@EXIT
RETURNS T2/ RETRIEVAL PNTR TO FIRST PAGE GOTTEN AND T3/ NO. OF
PAGES GOTTEN.
@@ #

SSERCH:	PUSH	P,U		;SAVE REQUESTED COUNT,,UNIT DB.
	HLRZS	U		;U/ REQUESTED COUNT.
	SKIPN	T1,P1		;ASKING FOR CONTIGUITY?
	JRST	SSERC0		;NO.
	PUSH	P,T2		;YES, SAVE T2 FROM IDIVI.
	IDIVI	T1,^D36		;GET T1/ NO. OF WORDS
	ADDI	T1,%SWP		;INTO
	MOVNS	T2		;SAT.
	HRLZI	T3,400000	;BUILD THE MASK IN
	LSH	T3,(T2)		;T3.
	MOVE	T4,(T1)		;GET THE ANDED WORD IN
	AND	T4,400(T1)	;T4.
	TDNN	T4,T3		;THIS PAGE FREE?
	JRST	[POP P,T2	;NO.
		JRST SSERC0]	;
	POP	P,T2		;
	PUSH	P,P1		;YES.  SAVE PAGES INTO THE SAT.
	MOVE	P1,T4		;SET P1/ "AND" WORD FOR BELOW.
	HRLI	T1,-400-%SWP(T1) ;T1/ "AOBJN" WORD. T3/MASK.
	JRST	SSERC3		;JUMP INTO CODE BELOW.

    ;HERE WHEN WE CAN'T START WITH CONTIGUITY.
SSERC0:	SKIPN	T1,STTAOB(T2)	;IF NOT IN MIDDLE OF THIS SAT,
SSERC1:	MOVE	T1,[XWD -400,%SAT] ;START AT ITS BEGINNING.
	ADDI	T1,-%SAT+%SWP	;T1/ "AOBJN" WORD.
	HLRZ	T4,T1		;SAVE FOR CHECK BELOW.
SSER13:	SKIPE	T3,(T1)		;ANY BITS FREE IN THIS WORD?
	SKIPN	P1,400(T1)	;
	AOBJN	T1,SSER13	;NO, GO TO NEXT WORD.
	ANDB	T3,P1		;
	JUMPN	T3,SSERC2	;
	AOBJN	T1,SSER13	;
	CAIN	T4,-400		;OUT OF WORDS. GO TO
	STOPCD	(SLO)		;BEGINNING, UNLESS THAT IS
	JRST	SSERC1		;WHERE WE STARTED.

    ;HERE ON A FREE BIT IN THIS WORD.
SSERC2:	JFFO	T3,.+2		;GET T4/ NO. OF BITS INTO WORD.
	STOPCD
	HRRZI	T3,(T1)		;CALC THE
	SUBI	T3,%SWP		;NO. OF
	IMULI	T3,^D36		;PAGES INTO
	ADDI	T3,(T4)		;THIS SAT, AND SAVE FOR
	PUSH	P,T3		;DISK PNTR CALC BELOW.
	MOVNS	T4		;GET T3/
	HRLZI	T3,400000	;THE
	LSH	T3,(T4)		;MASK.
SSERC3:	TDNE	T3,(T1)		;DEBUGGING
	TDNN	T3,400(T1)	;CHECK.
	STOPCD
	CAIE	P2,MBIT		;*******DEBUGGING CHECK. CURRENT
	STOPCD			;******IMPLEMENTATION ONLY ASKS MBIT.
	TRNE	P2,FBIT		;WANT TO SET F BIT?
	ANDCAM	T3,(T1)		;YES, DO SO.
	TRNE	P2,MBIT		;WANT TO SET M BIT?
	ANDCAM	T3,400(T1)	;YES, DO SO.
	SOJLE	U,SSEFIN	;JUMP IF ALL DONE.
	LSH	T3,-1		;ELSE SHIFT MASK TO NEXT BIT.
	JUMPE	T3,SSERC4	;JUMP IF RAN OFF END OF WORD.
      ;LOOK AT NEXT BIT IN THE SAME WORD.
SSER34:	TDNN	P1,T3		;IS THE BIT(PAIR) AVAIL?
	JRST	SSEFIN		;NO.
	JRST	SSERC3		;YES, GO SET THEM AS REQUESTED.
      ;HERE WHEN EO WORD.
SSERC4:	AOBJP	T1,SSEFIN	;JUMP IF NO MORE WORDS IN SAT.
	MOVE	P1,(T1)		;ELSE SET UP P1
	AND	P1,400(T1)	;TO THE AND OF THE F AND M BITS,
	HRLZI	T3,400000	;AND GET T3/ MASK OF FIRST BIT.
	JRST	SSER34		;GO SEE IF THIS BIT PAIR AVAIL.
      ;HERE WHEN DONE.
SSEFIN:	HLRZ	T4,-1(P)	;GET
	SUBI	T4,(U)		;T4/
	JUMPLE	T4,.+2		;DEBUGGING
	CAILE	T4,NCTXPG	;CHECK.
	STOPCD
	MOVNS	T4		;-COUNT DONE.
	ADDM	T4,STTFPC(T2)	;ADJUST THE FREE PAGE COUNT.
	SKIPGE	STTFPC(T2)	;BETTER NOT HAVE GONE NEGATIVE.
	STOPCD (SLO)
	HRRZ	U,-1(P)		;
	ADDM	T4,UNITAL(U)	;
	ADDM	T4,STRTAL+STRDDB ;
	AOBJP	T1,.+3		;ADJUST
	AOBJP	T1,.+2		;"AOBJN"
	AOBJN	T1,SSERC6	;UP THREE
	SETZ	T1,		;WORDS.
	JRST	.+3
SSERC6:	TRZ	T1,%SWP		;
	ADDI	T1,%SAT		;
	MOVEM	T1,STTAOB(T2)	;STORE IT.
	PUSH	P,T4		;SAVE -COUNT DONE.
	PUSHJ	P,GETPNO	;
	POP	P,T4		;
	POP	P,T3		;CREATE THE
	ADDI	T2,(T3)		;FIRST RETRIEVAL PNTR
	TLO	T2,RBREAL	;IN T2.
	POP	P,U		;
	MOVM	T3,T4		;RETURN ALSO T3/ COUNT DONE.
	POPJ	P,		;

COMMENT #
@@SUBROUTINE GETSTT
@@PURPOSE
GIVEN A DISK POINTER, FIND THE ADDRESS OF ITS SAT'S STT ENTRY.
@@ENTRY
EXPECTS T2/ DISK POINTER.
@@ACCUM
DESTROYS T1, T2, T3, AND U.
@@EXIT
RETURNS T1/ STT ADDRESS, T2/ ADDRESS OF STT ENTRY, T3/ NO. OF PAGES INTO SAT, AND
U/ UNIT DB.
@@ #

INTERN GETSTT
GETSTT:	LDB	U,RBYUNI	;GET U/ UNIT.
	MOVE	U,UNTTBL(U)	;
	LDB	T2,RBYPNO	;T2/ PAGE NUMBER.
	IDIVI	T2,400*^D36	;CALC NO. OF THE SAT WE WANT.
	IMULI	T2,STTLEN	;T2/ADDR OF SAT'S
	HRRZ	T1,UNISTT(U)	;INFO IN
	ADDI	T2,(T1)		;STT.
	POPJ	P,


COMMENT #
@@SUBROUTINE GSATST
@@PURPOSE
GIVEN THE RET PNTR TO A SAT, FIND THE ADDRESS OF ITS STT ENTRY.
@@ENTRY
EXPECTS T2/ RET PNTR OF SAT.
@@ACCUM
DESTROYS T1, T2, AND U.
@@EXIT
RETURNS T2/ ADDRESS OF STT ENTRY AND U/ UNIT DDB.
@@ #

INTERN GSATST

GSATST:	LDB	U,RBYUNI	;GET U/ UNIT.
	MOVE	U,UNTTBL(U)	;
	HRRZ	T1,UNISTT(U)	;
	SKIPN	STTPTR(T1)	;
	STOPCD (SLO)
GSATS2:	CAMN	T2,STTPTR(T1)	;
	JRST	GSATS4		;MATCH FOUND.
	ADDI	T1,STTLEN	;NO, TRY NEXT ONE.
	JRST	GSATS2		;
GSATS4:	MOVE	T2,T1		;
	POPJ	P,


COMMENT #
@@SUBROUTINE GETPNO
@@PURPOSE
GIVEN AN STT ENTRY ADDRESS, FIND THE BASE DISK POINTER.
@@ENTRY
EXPECTS T2/ STT ENTRY ADDRESS.
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@EXIT
RETURNS T2/ BASE DISK POINTER.
@@ #

GETPNO:	PUSH	P,T2		;SAVE THE STT ENTRY ADDRESS.
	MOVE	T2,STTPTR(T2)	;GET THE
	LDB	T4,RBYUNI	;UNIT.
	MOVE	T1,UNTTBL(T4)	;
	HRRZ	T1,UNISTT(T1)	;T2/ NO. OF
	POP	P,T2		;WORDS IN STT TABLE TO
	SUBI	T2,(T1)		;THE ENTRY.
	IDIVI	T2,STTLEN	;T2/ SAT NO.
	IMULI	T2,400*^D36	;T2/ BASE PAGE NUMBER +
	DPB	T4,RBYUNI	;UNIT = POINTER.
	POPJ	P,

COMMENT #
@@SUBROUTINE MOSPAU
@@PURPOSE
FIND THE UNIT WITH THE MOST FREE SPACE.
@@ACCUM
DESTROYS T1 AND T2 AND U.
@@EXIT
NON-SKIP RETURNS IF COMPLETELY OUT OF SPACE.
SKIP RETURN WITH U/ UNIT DB ADDR FOR UNIT WITH MOST SPACE.
@@ #

MOSPAU:	HLRZ	T1,STRUNI+STRDDB ;GET UNIT DB ADDR OF 1ST
	MOVE	T2,UNITAL(T1)	;UNIT ON STR.  T2/ MAX
	MOVE	U,T1		;SPACE FOUND.  U/ WHERE FOUND.
	JRST	MOSSP4		;
MOSSP2:	CAML	T2,UNITAL(T1)	;MORE SPACE ON THIS UNIT?
	JRST	MOSSP4		;NO.
	MOVE	T2,UNITAL(T1)	;YES, REMEMBER
	MOVEI	U,(T1)		;IT.
MOSSP4:	HLRZ	T1,UNISTR(T1)	;CONTINUE IF
	JUMPN	T1,MOSSP2	;ANOTHER UNIT.
	JUMPG	T2,CPOPJ1	;OKAY IF SPACE.
	HRRZ	T1,UNISTT(U)	;SEE IF ANY
MOSSP5:	SKIPE	STTFPC(T1)	;SPACE ON THIS UNIT.
	JRST	CPOPJ1		;YES.
	ADDI	T1,STTLEN	;
	SKIPE	STTPTR(T1)	;
	JRST	MOSSP5		;
	POPJ	P,		;


COMMENT #
@@SUBROUTINE LOKSAT
@@PURPOSE
SUBR TO GET A SAT AND SEE IF IT HAS ANY FREE PAGES.
@@ENTRY
EXPECTS T1/ DISK POINTER TO THE SAT, T2/ ADDRESS IN STT OF
INFO ABOUT THE SAT.
@@ACCUM
DESTROYS T1.
@@EXIT
IF THE SAT HAS A FREE PAGE:  KEEP THE SAT AND SKIP RETURN.
ELSE: RELEASE THE SAT AND NON-SKIP RETURN.
@@#


LOKSAT:	SKIPN	STTFPC(T2)	;ATTEMPT TO AVOID MAPPING A BAD
	POPJ	P,		;SAT, OR ONE WITH NO ROOM.
	PUSH	P,T4		;SAVE T4.
	PUSH	P,T3		;SAVE T3 AND
	PUSH	P,T2		;T2.
	MOVEI	PG,%SAT.C	;GET
	PUSHJ	P,MAPWTL	;THE SAT.
	MOVE	T2,(P)		;RESTORE ENTRY ADDRESS IN STT.
	SKIPN	STTFPC(T2)	;ANY FREE PAGES IN THIS SAT?
	JRST	LOKST4		;NO.
	PUSHJ	P,SATCHK	;
	AOSA	-3(P)		;YES, SKIP RETURN.
LOKST4:	PUSHJ	P,MAPRLS	;NO OR BAD SAT. RELEASE THE SAT.
	POP	P,T2		;RESTORE T2
	POP	P,T3		;AND T3
	POP	P,T4		;AND T4.
LOKSTB:	POPJ	P,

COMMENT #
@@SUBROUTINE LOKUNI
@@PURPOSE
SUBR TO SEE IF THERE IS ROOM ON ANY SAT FROM THE SAME UNIT.
THE SATS CONSIDERED HERE ARE ALL IN CORE OR ALL.
@@ENTRY
EXPECTS U/ UNIT DDB AND T3/1 (LOOK AT INCORE SATS) OR 0 (LOOK
AT ALL SATS.).
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@EXIT
IF WE FIND ROOM, KEEP THAT SAT AND SKIP RETURN WITH T2/ STT
ENTRY ADDRESS.  ELSE NON-SKIP RETURN.
@@ #

LOKUNI:	PUSH	P,P1
	PUSH	P,P2
	HRRZ	P1,UNISTT(U)	;GET ADDRESS OF STT TABLE.
	MOVE	P2,T3		;
LOKUN1:	MOVE	T2,P1		;SET UP T2 FOR STY PNTRS.
	JUMPE	P2,LOKUN2	;DEPENDING ON P2,
	LDB	T1,STYINC	;LOOK ONLY AT IN CORE SATS OR
	JUMPE	T1,LOKUN3	;AT ALL SATS.
LOKUN2:	SKIPN	STTFPC(P1)	;DON'T BOTHER TO LOOK AT BAD OR
	JRST	LOKUN3		;EMPTY SATS.
	MOVE	T1,STTPTR(P1)	;THIS QUALIFIES, SO
	MOVEI	PG,%SAT.C	;GO MAP
	PUSHJ	P,MAPWTL	;WRITE LOCK IT.
	SKIPN	STTFPC(P1)	;DOES IT STILL HAVE FREE PAGES?
	JRST	LOKU35		;NO.
	MOVE	T2,P1		;
	PUSHJ	P,SATCHK	;YES, IS THE SAT GOOD?
	JRST	LOKUN4		;FOUND SPACE.
LOKU35:	PUSHJ	P,MAPRLS	;NO.  RELEASE IT.
LOKUN3:	ADDI	P1,STTLEN	;GO TO NEXT ENTRY.
	SKIPE	STTPTR(P1)	;ANY NEXT ENTRY?
	JRST	LOKUN1		;YES, CONTINUE.
	JRST	LOKUN5		;
LOKUN4:	AOS	-2(P)		;FOUND SPACE.
LOKUN5:	POP	P,P2		;
	POP	P,P1		;
	POPJ	P,

COMMENT #
@@SUBROUTINE UPDACT/UPDAC0
@@PURPOSE
SUBRS TO UPDATE VARIOUS COUNTS WHEN ALLOCATING/DEALLOCATING A
PAGE ON THE DISK.  UPDACT UPDATES UNITAL AND STRTAL, UPDAC0
DOES NOT.
@@ENTRY
BOTH SUBRS EXPECTS U/ UNIT, T1/ +1 WHEN ALLOCATING, T1/ -1
WHEN DEALLOCATING, T2/ EITHER 0,,ATB OR 0, ALSO IF THIS IS
A REAL FILE, F/ DDB.  IN ADDITION,
UPDAC0 EXPECTS IN T3 THE NEGATIVE OF THE CONTENTS OF T1.
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@ #

UPDACT:	MOVN	T3,T1		;
	ADDM	T3,UNITAL(U)	
	ADDM	T3,STRTAL+STRDDB ;
UPDAC0::TLNE	S,IOSALC	;
	POPJ	P,		;
UPDAC2:	JUMPE	T2,UPDCN1	;JUMP IF A REAL FILE WITHOUT AN ATB.
	SKIPGE	ATBDUM(T2)	;REAL FILE?
	POPJ	P,		;NO, DON'T TOUCH OTHER COUNTS.
	ADDM	T1,ATBALP(T2)	;YES, ADJUST ATBALP.
UPDCN1:	HLRZ	T2,DEVDRB(F)	;
	MOVE	T4,DRBALC(T2)	;
	ADDB	T3,DRBALC(T2)	;
	JUMPLE	T4,UPDCN3	;WAS DRBALC ORIGINALLY POSITIVE
	JUMPGE	T1,UPDCN3	;AND T3 POS (T1 <=0)?
	SKIPG	DRBALC(T2)	;YES, MAYBE OVERFLOWED FROM
	JRST	UPDCN5		;POSITIVE TO NEGATIVE.
UPDCN3:	CAMGE	T3,DRBMXA(T2)	;
	MOVEM	T3,DRBMXA(T2)	;
	POPJ	P,

UPDCN5:	MOVEM	T4,DRBALC(T2)	;
	POPJ	P,

COMMENT #
@@SUBROUTINE UPDADS
@@PURPOSE
SUBR TO UPDATE THE DISK COUNTS (STRTAL, UNITTAL, AND STTFPC)
WHEN DEALLOCATING A PAGE.  (CALLED FROM REMOVE.).
@@ENTRY
EXPECTS T2/ RETRIEVAL PNTR TO PAGE.
@@ACCUM
DESTROYS T1, T3, AND T4.
@@ #

INTERN UPDADS,UPDAC2

UPDADS:	PUSH	P,T2		;SAVE T2 AND
	PUSH	P,U		;U.
	PUSHJ	P,GETSTT	;GET T2/ STT ENTRY ADDR AND
	AOS	STTFPC(T2)	;U/ UNIT DDB.
	AOS	UNITAL(U)	;
	AOS	STRDDB+STRTAL	;
	POP	P,U		;RESTORE U AND
	POP	P,T2		;T2.
	POPJ	P,

COMMENT ;@@SUBROUTINE DNDADS
@@PURPOSE TO DECREMENT STRTAL, STTFPC, AND UNITAL
FOR A FREE PAGE WE ARE ABOUT TO ALLOCATE. USED
WHEN PUTTING A FREE PAGE INTO BAT BLOCKS (HAPPENS
WHEN REMOVING A SUPER PAGE THAT HAS HAD AN ERROR)
@@ENTRY T2/RETRIEVAL POINTER TO PAGE
@@ACCUM USES T1,T3,T4
@@;

DNDADS::PUSH	P,T2		;SAVE POINTER
	PUSH	P,U		;SAVE THIS, WILL BE UDB
	PUSHJ	P,GETSTT	;GET STT ENTRY IN T2, UNIT IN U
	SOSL	STTFPC(T2)	;ONE LESS PAGE IN THIS SAT.
	SOSGE	UNITAL(U)	;AND IN THIS UNIT
	STOPCD (SLO)		;SOMETHING ISN'T RIGHT.
	SOS	STRDDB+STRTAL	;THIS CAN GO NEGATIVE LEGALLY.
	POP	P,U		;RESTORE AND
	POP	P,T2
	POPJ	P,		;RETURN.

COMMENT #
@@SUBROUTINE SATCHK
@@PURPOSE
SUBR TO CHECK THE GOODNESS OF A SAT WHICH HAS JUST BEEN LOCKED
INTO %SAT.
@@ENTRY
EXPECTS T2/ ADDR OF SAT ENTRY IN STT AND U/ UNIT DB.
@@ACCUM
DESTROYS T1, T3, AND T4.
@@EXIT
NON-SKIP RETURNS IF SAT IS OKAY, ELSE SKIP RETURNS.
@@ #

SATCHK:	HLLZ	T1,STTSTS(T2)	;SKIP RETURN IF THE
	TLNE	T1,STPBAD	;SAT IS
	JRST	CPOPJ1		;BAD.
	TLNE	T1,STPCHK	;ALL DONE IF SAT HAS ALREADY
	POPJ	P,		;BEEN CHECKED.
	MOVE	T1,%SAT		;FORCE IN THE SAT.
	HRLZI	T1,STPCHK	;
	IORM	T1,STTSTS(T2)	;
	PUSHJ	P,GETER2	;JUMP IF ERRORS WERE SEEN
	JUMPN	T1,[AOS SATBRD	;ON THE READ.
		JRST SATMRK]	;
	PUSH	P,T2		;ELSE CHECK FOR CONSISTENCY.
	MOVE	T1,[XWD -400,%SAT] ;GET T4/ NO. OF ONE (AVAIL)
	PUSHJ	P,SATCNT	;BITS IN THE SAT.
	POP	P,T2		;RESTORE STT ENTRY ADDR.
	CAMN	T4,STTFPC(T2)	;
	POPJ	P,
SATMRK:	HRLZI	T1,STPBAD!STPRPT ;HERE TO MARK SAT BAD AND
	IORM	T1,STTSTS(T2)	;NEEDS REPORT.
	SETZ	T1,
	DPB	T1,STYINC	;
	HRRZI	T1,SRPRPT	;MARK STR NEEDS
	IORM	T1,STRDDB+STRBTS ;REPORT.
	MOVE	T1,STTPTR(T2)	;SET SATBAD TO
	TLZ	T1,RBMASK-RBREAL ;THE FIRST
	SKIPN	SATBAD		;BAD
	MOVEM	T1,SATBAD	;SAT.
	PUSHJ	P,SLOCLE	;NEXT TIME DO A SLOW DSKCLN
	MOVSI	T1,UNPSER	;
	ADDM	T1,UNIMCT(U)	;
	SKIPN	T1,STTFPC(T2)	;
	JRST	CPOPJ1
	MOVNS	T1		;
	ADDM	T1,UNITAL(U)	;
	ADDM	T1,STRTAL+STRDDB ;
	SETZM	STTFPC(T2)	;
	JRST	CPOPJ1

COMMENT #
@@SUBROUTINE SSTCHK
@@PURPOSE
SUBR TO CHECK THE GOODNESS OF A SAT VIA %SWP.
ALSO SETS UPT SLOT FOR GOOD SATS.
GUARANTEED THAT SAT IS IN CORE AND THAT STYBAD IS NOT SET ON
ENTRY.
@@ENTRY
EXPECTS T2/ ADDR OF SAT ENTRY IN STT, U/ UNIT DB, AND PG/
CORE PAGE NUMBER.
@@ACCUM
DESTROYS T1, T3-T4, AND PG.
@@EXIT
NON-SKIP RETURNS IF SAT IS OKAY, ELSE SKIP RETURNS.
@@ #

SSTCHK:	HLLZ	T1,STTSTS(T2)	;HAS THIS SAT ALREADY BEEN
	TLOE	T1,STPCHK	;CHECKED?
	TLZA	T1,STPCHK	;YES, REMEMBER THAT BACKWARDS.
	IORM	T1,STTSTS(T2)	;WILL BE CHECKED NOW.
	LDB	T3,PGYERR	;
	JUMPN	T3,[AOS SATBRD	;
		JRST SATMRK]	;
	MOVEI	T3,PGE.A!PGE.W!PGE.C(PG) ;SET
	DPB	T3,[EPTPTR(%SWP.N)] ;%SWP SLOT.
	CLRPTO	%SWP
	TLNN	T1,STPCHK	;SAT ALREADY CHECKED?
	POPJ	P,		;YES.
	PUSH	P,T2		;ELSE CHECK FOR CONSISTENCY.
	MOVE	T1,[XWD -400,%SWP] ;GET T4/ NO. FREE PAGES.
	PUSHJ	P,SATCNT	;SAT.
	POP	P,T2		;RESTORE STT ENTRY ADDR.
	CAMN	T4,STTFPC(T2)	;
	POPJ	P,
	SETZ	T1,		;CLEAR THE
	DPB	T1,[EPTPTR(%SWP.N)] ;%SWP SLOT.
	CLRPTO	%SWP
	JRST	SATMRK		;

COMMENT #
@@SUBROUTINE RPTSAT
@@PURPOSE
SUBR CALLED ONCE A SECOND, TO SEE IF THERE ARE ANY NEWLY
DISCOVERED BAD SATS TO REPORT TO THE OPER.
@@ENTRY
EXPECTS
@@ACCUM
DESTROYS T1, T2, AND T4.
@@ #

INTERN RPTSAT

RPTSAT:	SKIPN	SATBAD		;ANY BAD SAT SEEN EVER?
	POPJ	P,		;NO.
	HRRZI	T1,SRPRPT	;YES, ANY NEW ONES
	TDNN	T1,STRDDB+STRBTS ;SEEN?
	POPJ	P,		;NO.
	ANDCAM	T1,STRDDB+STRBTS ;YES.  CLEAR THE BIT.
	PUSH	P,U		;
	PUSH	P,T3		;
	HLRZ	U,STRDDB+STRUNI ;U/ UNIT DB.
	HRLZI	T2,STPRPT	;T2/ MASK FOR STT REPORT BIT.
RPTST1:	HRRZ	T3,UNISTT(U)	;LOOK THRU THIS UNIT'S SATS.
    ;LOOP FOR EACH SAT FOR THE UNIT.
RPTST2:	SKIPN	T4,STTPTR(T3)	;ANOTHER SAT FOR THIS UNIT?
	JRST	RPTST6		;NO.
	TDNN	T2,STTSTS(T3)	;YES, IS IT NEWLY BAD?
	JRST	RPTST4		;NO.
	ANDCAM	T2,STTSTS(T3)	;YES, CLEAR ITS REPORT BIT.
	PUSHJ	P,CPLSAT	;REPORT THIS NEW BAD SAT.
RPTST4:	ADDI	T3,STTLEN	;TRY FOR
	JRST	RPTST2		;ANOTHER SAT FOR THIS UNIT.
RPTST6:	HLRZ	U,UNISTR(U)	;TRY FOR
	JUMPN	U,RPTST1	;ANOTHER UNIT ON THIS STR.
	POP	P,T3		;FINISH
	POP	P,U		;UP.
	POPJ	P,

COMMENT #
@@SUBROUTINE CPLSAT
@@PURPOSE
SUBROUTINE CALLED BY RPTSAT, TO COMPLAIN TO OPR AND CTY THAT
THERE IS A BAD SAT ON UNIT N AT PAGE M.
@@ENTRY
EXPECTS T4/ RETRIEVAL PNTR OF SAT AND U/ UNIT DB ADDR.
@@ACCUM
DESTROYS NO ACS.
@@ #

CPLSAT:	PUSH	P,P1		;
	PUSH	P,P2		;
	PUSH	P,F		;
	PUSH	P,T1		;
	PUSH	P,T2		;
	PUSH	P,T3		;
	PUSH	P,T4		;THIS MUST BE AT TOP-1 OF PDL.
	PUSH	P,U		;THIS MUST BE AT TOP OF PDL.
	MOVEI	T1,[ASCIZ/ ?
? BAD SAT ON /]
	PUSHJ	P,DBLMSG	;
    ;NOW OUTPUT THE UNIT NAME.
	HRRZ	U,(P)		;
	MOVE	T1,[POINT ^D6,UNINAM(U)] ;
	MOVE	T2,[POINT ^D7,P1] ;
	SETZB	P1,P2		;
CPLST2:	ILDB	T3,T1		;GET SIX BIT CHAR.
	JUMPE	T3,CPLST3	;
	ADDI	T3,40		;MAKE SEVEN BIT.
	IDPB	T3,T2		;STORE IT.
	JRST	CPLST2		;
CPLST3:	MOVEI	T1,P1		;
	PUSHJ	P,DBLMSG	;
	MOVEI	T1,[ASCIZ/ AT PAGE /]
	PUSHJ	P,DBLMSG	;
    ;THEN OUTPUT THE PAGE NUMBER.
	MOVE	T2,-1(P)	;GET T1/
	LDB	T1,RBYPNO	;PAGE NUMBER.
	MOVE	T3,[POINT ^D7,P1] ;BYTE PNTR TO P1 AND P2.
	SETZB	P1,P2		;
	PUSHJ	P,CPLST4	;
	JRST	CPLST6		;
CPLST4:	IDIVI	T1,10		;
	JUMPE	T1,CPLST5	;
	PUSH	P,T2		;
	PUSHJ	P,CPLST4	;
	POP	P,T2		;
CPLST5:	MOVEI	T2,60(T2)	;
	IDPB	T2,T3		;
	POPJ	P,		;
CPLST6:	MOVEI	T1,P1
	PUSHJ	P,DBLMSG	;
	MOVEI	T1,[ASCIZ/
/]
	PUSHJ	P,DBLMSG	;FINISH UP WITH CRLF.
	POP	P,U	
	POP	P,T4		;
	POP	P,T3		;
	POP	P,T2		;
	POP	P,T1		;
	POP	P,F		;
	POP	P,P2		;
	POP	P,P1		;
	POPJ	P,

COMMENT #
@@SUBROUTINE GIVPGK
@@PURPOSE
GIVPGK TURNS OFF THE F BIT FOR A DISK PAGE AND ADJUSTS SOME
COUNTS.  IT MAY OR MAY NOT 
HAVE A SAT IN %SAT ON ENTRY.  IF IT DOES, IT CHECKS IT AND
RELEASES IT IF IT IS NOT THE RIGHT ONE.  THEN, IF NECESSARY,
IT GETS THE CORRECT SAT.
@@ENTRY
EXPECTS T2/ DISK POINTER AND F /DDB.
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@ #

INTERN GIVPGK

GIVPGK:	PUSH	P,U		;SAVE U FROM FNDSBT.
	MOVEI	T1,MAPWTU	;
	PUSHJ	P,FNDSBT	;GET SAT, FIND BIT LOC.
	JRST	GIVPG6		;BAD SAT.
	TDNE	T1,%SAT(T3)	;F BIT BETTER BE ON.
	STOPCD (SLO)
	IORM	T1,%SAT(T3)	;TURN THE F BIT OFF.
	TDNN	T1,%SAT+400(T3)	;IS THE M BIT OFF?
	JRST	GIVPG6		;NO.
	AOS	STTFPC(T2)	;ONE MORE PAGE IS FREE.
	SETO	T1,		;UPDATE ALL
	HRRZ	T2,DEVATB(F)	;T2/ ATB OR ZERO FOR UPDACT.
	PUSHJ	P,UPDACT	;THE COUNTS.
	POP	P,U		;RESTORE U.
	POPJ	P,		;RETURN.

      ;HERE IF SAT IS BAD, JUST ADJUST A FEW COUNTS.
GIVPG6:	SETO	T1,		;UPDATE JUST
	MOVEI	T3,1		;A FEW
	HRRZ	T2,DEVATB(F)	;T2/ ATB OR ZERO FOR UPDAC0.
	PUSHJ	P,UPDAC0	;COUNTS.
	POP	P,U		;RESTORE U.
	POPJ	P,		;RETURN.





COMMENT ;@@SUBROUTINE FRMGVP
@@PURPOSE DEALLOCATE A DISK PAGE WHICH HAS BEEN ALLOCATED
WITH JUST THE M BIT ON. CALLED BY ERROR CODE IN CREFRM UUO
WHEN COULDN'T ALLOCATE ALL THE CONTEXT PAGES FOR A NEW JOB.
@@ENTRY T2/RBREAL+PAGE TO DEALLOCATE (F MUST BE OFF, M MUST BE ON)
@@ACCUM T1-T4, PG
@@EXIT ALWAYS NON-SKIP
RETURNS WITH SAT IN %SAT - CALLER MUST CALL RELSAT AFTER FINISHED CALLING FRMGVP.
@@;

EXTERNAL ADRDUM

FRMGVP::CAMN	T2,ADRDUM	;IF ITS A DUMMY DISK PAGE,
	POPJ	P,		;JUST RETURN.
	PUSH	P,U		;REAL WORK TO DO, SAVE U
	MOVEI	T1,MAPWTU	;GET SAT WRITE UNLOCKED
	PUSHJ	P,FNDSBT	;GET SAT, FIND BIT LOC.
	  JRST	FRMGVB		;BAD SAT, LEAVE COUNTS DOWN AND RETURN.
	TDNN	T1,%SAT(T3)	;F BIT HAS TO BE OFF
	STOPCD (SLO)		;CALLER MUST HAVE GIVEN WRONG PAGE
	TDNE	T1,%SAT+400(T3)	;MAKE SURE M BIT WAS ALREADY ON
	STOPCD (SLO)		;WAS OFF ALREADY, FOO.
	IORM	T1,%SAT+400(T3)	;OK, WAS ON, TURN IT OFF (SET TO 1)
	AOS	STTFPC(T2)	;ONE MORE FREE PAGE IN THIS SAT
	AOS	UNITAL(U)	;ONE MORE PAGE ON THE UNIT
	AOS	STRTAL+STRDDB	;AND ONE MORE ON THE STRUCTURE
FRMGVB:	POP	P,U		;RESTORE U FOR CALLER
	POPJ	P,		;DONE.

COMMENT #
@@SUBROUTINE FNDSBT
@@PURPOSE
SUBR TO GET A SAT FOR A GIVEN DISK POINTER, AND THEN SET UP
T1/ MASK FOR THAT PAGE'S F BIT, U/ UNIT DB, AND T3/ NO. OF
PAGES INTO THE SAT OF THE F BIT.  ALSO T2/ STT ENTRY ADDRESS.
@@ENTRY
EXPECTS T2/ DISK RET PNTR AND T1/ ADDRESS OF A MAP ROUTINE.
(DOES NOT CHANGE THE LOCKING IF IT ALREADY HAS THE
CORRECT SAT.).
@@ACCUM
DESTROYS T1-T4, PG, AND U.
@@EXIT
SEE PURPOSE.
NON-SKIP RETURNS IF SAT IS BAD, WITH T4/ DISK ADDRESS OF
SAT.  ELSE SKIP RETURNS WITH T1, T2, T3, AND U SET UP.
@@ #

FNDSBT:	JUMPE	T2,.+2		;CHECK THE RET PNTR
	TLNN	T2,RBREAL	;A LITTLE.
	STOPCD
	PUSH	P,T1		;SAVE MAP ROUTINE ADDR.
	PUSHJ	P,GETSTT	;GET T2/ STT ENTRY ADDR & T3/ #
	HRRZ	T1,@%SAT.C+%CTUPT ;OF PAGES INTO SAT.  JUMP
	JUMPE	T1,FNDSB2	;UNLESS ALREADY HAVE A SAT.
	MOVE	T1,PCBPTR(T1)	;IS THE SAT THAT WE HAVE, THE
	MOVE	T4,STTPTR(T2)	;SAT THAT WE
	CAME	T1,T4		;WANT?
	JRST	FNDSB1		;NO.
	POP	P,T1		;YES.  CLEAR PDL.
	LDB	T1,STYBAD	;IS IT BAD?
	JUMPN	T1,CPOPJ	;JUMP IF BAD.
	JRST	FNDSB5		;NO, EASY.
      ;HERE TO RELEASE THE CURRENT SAT.
FNDSB1:	MOVEI	PG,%SAT.C	;RELEASE
	PUSH	P,T3		;
	PUSH	P,T2		;
	PUSHJ	P,MAPRLS	;IT.
	POP	P,T2		;
	POP	P,T3		;
      ;HERE TO GET A NEW SAT.
FNDSB2:	POP	P,T4		;T4/ MAP ROUTINE ADDR.
	LDB	T1,STYBAD	;IS THE SAT WE WANT BAD?
	JUMPN	T1,FNDBAD	;JUMP IF BAD.
	MOVEI	PG,%SAT.C	;THE
	MOVE	T1,STTPTR(T2)	;SAT
	PUSH	P,T3		;MAY BE
	PUSH	P,T2		;GOOD,
	PUSHJ	P,(T4)		;SO GET IT.
	MOVE	T2,(P)		;CHECK
	PUSHJ	P,SATCHK	;THE SAT.
	JRST	FNDSB4		;OKAY.
	POP	P,T2		;BAD.
	POP	P,T3		;
FNDBAD:	MOVE	T4,STTPTR(T2)	;SET T4/ BAD SAT'S ADDRESS.
	POPJ	P,		;
FNDSB4:	POP	P,T2		;GOOD SAT.
	POP	P,T3		;

    ;HERE WITH OUR GOOD SAT.
FNDSB5:	IDIVI	T3,^D36		;GET T3/ NO. OF WORDS INTO SAT,
	MOVNS	T4		;AND
	MOVSI	T1,400000	;T1/
	LSH	T1,(T4)		;MASK FOR F BIT.
	JRST	CPOPJ1		;

COMMENT #
@@SUBROUTINE GIVPAG
@@PURPOSE
GIVPAG IS A "STAND ALONE" SUBR TO TURN OFF A PAGE'S F BIT.
IT GETS AND RELEASES THE SAT.
@@ENTRY
EXPECTS T2/ DISK POINTER AND F/ DDB.
@@ACCUM DESTROYS
@@ #

INTERN GIVPAG
GIVPAG:	PUSHJ	P,GIVPGK	;
	PJRST	RELSAT

COMMENT #
@@SUBROUTINE SATCNT
@@PURPOSE
SUBR TO COUNT THE NUMBER OF AVAILABLE BIT PAIRS IN A SAT.
@@ENTRY EXPECTS T1/ AOBJN POINTER TO THE SAT.
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@EXIT
RETURNS COUNT IN T4.
@@ #

INTERN SATCNT

SATCNT:	SETZ	T4,		;COUNT IS RETURNED IN T4.
SATCT2:	SKIPE	T2,(T1)		;IS THE WORD ENTIRELY ZERO?
	JRST	SATCT3		;NO.
	AOBJN	T1,SATCT2	;YES.
	POPJ	P,
SATCT3:	AND	T2,400(T1)	;
	SKIPE	T2
SATC34:	JFFO	T2,SATCT4	;GET T3/ NO. OF LEADING ZEROES.
	AOBJN	T1,SATCT2
	POPJ	P,
SATCT4:	LSH	T2,1(T3)	;SHIFT OFF THAT BIT.
	AOJA	T4,SATC34	;INC COUNT.

COMMENT #
@@SUBROUTINE GETSAT
@@PURPOSE
SUBR TO GET INTO %SAT THE SAT FOR THE PAGE SPECIFIED BY THE
RETRIEVAL PNTR IN T2.  (N.B., T2 HAS THE ADDRESS OF SOME
PAGE IN THE SAT, NOT THE ADDRESS OF THE SAT ITSELF.).
SAT WILL BE LOCKED ACCORDING TO T1 UNLESS IT IS ALREADY IN %SAT.
(MAY OR MAY NOT BE A SAT IN %SAT ON ENTRY.).
@@ENTRY
EXPECTS T2/ RETRIEVAL PNTR (RBMASK-RBREAL OFF) AND T1/ ADDR OF A MAP
ROUTINE (MAPCML, ETC.).
@@ACCUM
DESTROYS T1, T3, T4, AND PG.
@@EXIT
ON SUCCESS RETURN, SKIP RETURNS AND RETURNS MASK FOR F BIT IN
T1 AND NO. OF WORDS INTO %SAT OF WORD WITH F BIT IN T3.  HAS
SAT IN %SAT.
ON FAIL RETURN, NON-SKIPS AND RETURNS RETRIEVAL PNTR TO BAD
SAT IN T4.  DOES NOT HAVE SAT.
@@ #

INTERNAL GETSAT

GETSAT:	PUSH	P,T2		;SAVE T2 AND
	PUSH	P,U		;U.
	PUSHJ	P,FNDSBT	;THIS DOES ALL THE WORK.
	SOS	-2(P)		;TAKE ERROR RETURN.
	POP	P,U		;RESTORE U AND
	POP	P,T2		;T2.
	JRST	CPOPJ1		;

COMMENT #
@@SUBROUTINE FPCSET
@@PURPOSE
SUBR FOR USE BY DSKCLN'S UUO, TO SET STTFPC FOR ALL SATS
ON ALL UNITS.
@@ENTRY
EXPECTS T1/ ADDR OF AC CONTAINING AOBJN PNTR OF THE FORM
-NO. OF ARGS,,ADDR OF FIRST ARG.
@@ACCUM
DESTROYS T1 THRU T4.
@@EXIT
NON-SKIP RETURNS IF NOT THE RIGHT NO. OF VALUES SENT OR IF NO
UNITS IN STRUCTURE.
ELSE, SKIP RETURNS.
@@ #

INTERN FPCSET

    ;FIRST, BE SURE WE HAVE BEEN GIVEN THE CORRECT NO. OF ARGS.
FPCSET:	MOVE	T4,%SAT.C+%CTLST ;DEBUGGING CHECK
	SKIPE	(T4)		;FOR DSKCLN.
	STOPCD
	PUSH	P,U		;SAVE U.
	UMOVE	T1,(T1)		;GET T1/ AOBJN PNTR.
	HLRZ	U,STRDDB+STRUNI	;BETTER BE AT LEAST ONE
	JUMPE	U,FPCPOP	;UNIT IN THE STR.
	SETZ	T4,		;COUNT
	LDB	T3,UNYSPU	;THE NUMBER
	SUB	T4,T3		;OF SATS ON ALL
	HLRZ	U,UNISTR(U)	;UNITS IN
	JUMPN	U,.-3		;THE STRUCTURE.
	HLRE	T3,T1		;GET NO. OF ARGS USER HAS SENT.
	CAME	T3,T4		;DO THEY MATCH?
	JRST	FPCPOP		;NO, ERROR RETURN.

    ;SET THE STTFPC ENTRIES.
	SETZM	STRDDB+STRTAL	;
	HLRZ	U,STRDDB+STRUNI	;U/ UNIT.
FPCST3:	SETZM	UNITAL(U)	;
	HRRZ	T2,UNISTT(U)	;T2/ STT ENTRY ADDR.
FPCST4:	SKIPE	STTPTR(T2)	;AT END OF THIS UNIT'S STT?
	JRST	FPCST6		;NO.
FPCST5:	PUSH	P,T1		;
	MOVE	T1,UNIPPU(U)	;CALCULATE SAFETY FACTOR.
	PUSH	P,T2		;
	IDIVI	T1,UNVRSF	;
	POP	P,T2		;
	LDB	T4,UNYSPU	;
	IMULI	T1,(T4)		;
	MOVNS	T1		;
	ADDB	T1,UNITAL(U)	;
	JUMPGE	T1,.+3		;
	SETZM	UNITAL(U)	;
	JRST	.+2		;
	ADDM	T1,STRDDB+STRTAL ;
	POP	P,T1		;
	HLRZ	U,UNISTR(U)	;YES, GO TO
	JUMPN	U,FPCST3	;NEXT UNIT.
	JRST	FPCPP0
FPCST6:	UMOVE	T3,(T1)		;GET USER'S ARG, AND
	MOVEM	T3,STTFPC(T2)	;STORE IT IN STTFPC.
	ADDM	T3,UNITAL(U)	;
	ADDI	T2,STTLEN	;
	AOBJN	T1,FPCST4	;
	JRST	FPCST5		;
FPCPP0:	AOS	-1(P)		;SUCCESS RETURN.
	MOVEI	T1,SRPNDS	;CLEAR THE NEED DSKCLN FLAG
	ANDCAM	T1,STRDDB+STRBTS ;FOR THIS STR.
	SKIPE	DFRLST		;DEBUGGING CHECK.
	STOPCD
FPCPOP:	POP	P,U		;RESTORE U.
	POPJ	P,		;RETURN.

COMMENT #
@@SUBROUTINE CHKQTA
@@PURPOSE
SUBR TO SEE IF THE USER CAN ALLOCATE ONE DISK PAGE.
@@ENTRY
EXPECTS F/ DDB.
@@ACCUM
DESTROYS T1 AND T4.
@@EXIT
SKIP RETURNS IF OKAY TO GET A PAGE.
ELSE NON-SKIP RETURNS.
@@ #

INTERN CHKQTA

CHKQTA:	SKIPG	STRDDB+STRTAL
	JRST	ERRFUL
	SKIPN	T4,DEV1UN(F)	;SPECIAL UNIT STUFF?
	JRST	CKQOT3		;NO.
	SKIPG	UNITAL(T4)	;YES.  ROOM LEFT ON UNIT?
	JRST	ERRFUL		;NO.
CKQOT3:	HLRZ	T4,DEVDRB(F)	;CHECK AGAINST QUOTA
	MOVE	T1,DRBALC(T4)
	CAIL	T1,1		;BELOW QUOTA?
	JRST	CPOPJ1		;YES. OKAY.
	SUB	T1,STROVR+STRDDB ;CHK MAX OVRDRW ALLOWED IN STR.
	JUMPLE	T1,ERRFUL	;
	JRST	CPOPJ1		;

COMMENT #
@@SUBROUTINE ERRFUL/ERRBDR/ERRIMP
@@PURPOSE
SUBRS TO SET AN ERROR FLAG IN S AND STORE S IN DEVIOS.
@@ #

INTERN ERRFUL,ERRIMP,ERRBDR

ERRBDR:	TROA	S,IODTER	;ANY BIT IN A STORM.
ERRFUL:	TRO	S,IOBKTL
	PJRST	STOIOS

ERRIMP:	TRO	S,IOIMPM
	PJRST	STOIOS

	END
   A	9³