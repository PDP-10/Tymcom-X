TITLE REFSTR - ROUTINE TO REFRESH A FILE STRUCTURE



;ENTRY POINTS.

ENTRY REFSTR,PAKREF


;SOME INTERNALS.

INTERN REFSTT,REFLNP,REFLNR


;EXTERNALS.

EXTERN RIBALP,RIBCOD,RIBUNM,RIBRPS,RBYPNO,RBYUNI,RIBUN1
EXTERN RIBEXT,RIBNAM,RIBPPN,RIBQTF,RIBQTO,RIBSIZ
EXTERN RIBSLF,RIBSTS,RIBUSD,RIBVER,RIPDIR,RIPNDL,RIPNFS
EXTERN RIBLST,RIBSNM,RIBSFS,RIBRIB,CODRIB
EXTERN RBREAL,RIBSZS,RIBPFS,RBLVPR,RBLVSP,RIBMXA,RBSPAR,RIBPRV

EXTERN UNISTT,UNISTR,UNIPPU
EXTERN UNYSPU,UNYLUN

EXTERN HOMTAB,HOMREF,HOMHSH,HOMRAN

EXTERN STRREF,STRP4C,STRUNI,STRHSH,STRDDB

EXTERN STTAOB,STTLEN,STTPTR,STTFPC,STTSTS

EXTERN %HOM.P,%HMR.P,%STR.P,%STA.P,%BAT.P,%TMP.P,%T2P.P

EXTERN CPOPJ1,REFLAG,SAVT,MFDRIB,CORZER,CORONZ
EXTERN RIBEX1,RIBEX2,RIBEX3,RIBEX4
EXTERN BATFIR,BAYNBB,SPLPPN,FSFPPN,MFDPPN,MFDPRV
EXTERN OPAGIN,OPAGOT,WTBOTH,GETBAT,GETHOM
EXTERN SAVE1,SAVE4,OCONM,OPOUT
EXTERN SYNRPR,SYRDPR,SYSPPN,SYSPRV,UNTTBL,UFDHSI



REFSTT:
PHASE %REF

STNVER:	XWD	0,1	;STANDARD VERSION NUMBER.


;QUOTAS FOR UFD'S WE CREATE

QF==377777777777	;FIRST COME, FIRST SERVED QUOTA.
QO==377777777777	;LOGGED OUT QUOTA.
QUOTAF: EXP QF
QUOTAO: EXP QO

;SOME DEFINITIONS FOR HOME AND BAT PAGES AND BOOTS AND SAT.SYS RIB:
;(ALL MUST BE IN THE 1ST SAT ON THE UNIT.).

XP LPNHOM,1		;LOG. PAGE NO. OF FIRST HOME PAGE.
XP LPNBAT,2		; " OF FIRST BAT PAGE.
IFCPU (<KI,KL,F3>),<
XP FBOOTB,3		; " OF FIRST PAGE OF BOOTS.  (IF YOU
			;CHANGE THIS, YOU MUST ALSO CHANGE
			;BOTLOD AND COMMON (SYSCRS).).

XP NBOOTP,3		;NO. OF PAGES IN BOOTS.
XP LPNSAT,10		;LOG. PAGE # OF PRIME RIB OF SAT.SYS.
>;END IFCPU (<KI,KL,F3>)
XP LP2HOM,6		;LOG. PAGE NO. OF SECOND HOME PAGE.
XP LP2BAT,7		; " OF SECOND BAT PAGE.
IFCPU (KS),<
XP FBOOTB,10		;START OF FE FILE/BOOTSTRAP AREA
XP NBOOTP,100		;LENGTH IN PAGES OF SAID AREA
XP LPNSAT,110		;LOG. PAGE # OF PRIME RIB OF SAT.SYS
>;KS10	

;SOME INTERNS FOR ONCDSK.

XP RB1UN,6	;REFSTR CREATES 6 RIBS ON FIRST UNIT (OF MFD,
		;SYS UFD, SAT.SYS, HOME.SYS,
		;PRINT UFD, AND CRASH.SAV.).
XP NMUFDS,3	;REFSTR CREATES 3 UFDS (MFD, SYS UFD, AND
		;PRINT.UFD) ON THE FIRST UNIT.
XP HBBPGS,4+NBOOTP	;NO. OF PAGES TAKEN UP BY HOME AND BAT
			;PAGES AND BOOTS AND PAGE 0.

DEFINE MSGDIE (A)
<PUSHJ P,[MOVEI T1,A
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	STOPCD ()]>

DEFINE MSGSFE (A)
<PUSHJ P,[MOVEI T1,A
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	MOVEI T1,SOFERR
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	STOPCD ()]>

DEFINE MSGLIV (A)
<PUSHJ P,[MOVEI T1,A
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	POP P,T2
	POPJ P,]>

IOFAL:	ASCIZ /
ERROR ON DISK TRANSFER.
/

OGTPG: ASCIZ /
OUT OF ROOM ON DISK.
/

BATBAD:	ASCIZ /
BAT PAGE CONSISTENCY ERROR.
/

RBNOUT:	ASCIZ /
OUT OF RETRIEVAL POINTER SPACE IN NON-EXTENDED FILE.
/

RBEOUT:	ASCIZ /
OUT OF RETRIEVAL POINTER SPACE IN EXTENDED FILE.
/

UFDERR:	ASCIZ /
OUT OF ROOM IN A ONE PAGE UFD.
/

NOTAVL:	ASCIZ /
RESERVED PAGE HAS ALREADY BEEN ALLOCATED.
/

RIBFAL:	ASCIZ/
FAULTY RIB STRUCTURE.
/

SOFERR:	ASCIZ /
SOFTWARE ERROR.
CALL PDP-10 OPERATING SYSTEMS GROUP.
/

SUBTTL REFSTR
;ROUTINE TO REFRESH A FILE STRUCTURE
;ARGS	P2=ADDR OF STR DATA BLOCK
;	F=ADDR OF DDB

REFSTR:	JSP	T4,SAVE4	;SAVE PERMANENT ACS
	HLRZ	U,STRUNI(P2)	;U=ADDR OF FIRST UNIT IN STR
	MOVEM	U,FSTUNI	;REMEMBER FIRST UNIT.
	SETZM  FSTPG		;ZERO OUT LOCS RECORDING FIRST PAGE NOS.
	MOVE	T1,[XWD FSTPG,FSTPG+1] ;NEVER ON PAGE 0 SO WE KNOW
	BLT	T1,FSTPG+LSTPGL-1 ;IF REALLY SET UP.
	MOVEI	T1,SYRDPR	;STANDARD ACCESS CODE FOR HOME,
	MOVEM	T1,CURPRT	;AND SAT
	MOVEM	T1,SATPRT	;(NEEDED BY
	MOVEM	T1,HOMPRT	;RIBSET.).
	MOVSI	T1,-LSTALP	;CLEAR NO. OF
	SETZM	FSTALP(T1)	;PAGES ALLOCATED FOR
	AOBJN	T1,.-1		;EACH FILE OF INTEREST.
	SETZM	SATDSK		;MARK NO SAT IN CORE IN %STA.

;HERE TO SET UP RIB IN CORE FOR HOME.SYS.

	MOVE	T1,HOMFNM	;NAME OF HOME.SYS FILE
	MOVSI	T2,(SIXBIT .SYS.)
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%HMR		;PNTR TO HOME.SYS RIB IN CORE.
	MOVEI	P4,RIPNDL!RIPNFS ;NO DELETE, NO CHANGE NAME, NO FAILSAFE BITS
	PUSHJ	P,RIBSET	;SET UP RIB FOR HOME.SYS.
	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD TO
	HRRI	T1,%HMR+RIBPFS-1
	MOVEM	T1,HOMRBP	;RETREVIAL AREA.

;HERE TO SET UP RIB IN CORE FOR SAT.SYS.

	MOVE	T1,SATFNM	;NAME OF SAT.SYS FILE
	MOVSI	T2,(SIXBIT .SYS.)
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%STR		;PNTR TO SAT.SYS RIB IN CORE.
	MOVEI	P4,RIPNDL!RIPNFS ;ALL STATUS BITS
	PUSHJ	P,RIBSET	;SET UP RIB FOR SAT.SYS.
	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD TO
	HRRI	T1,%STR+RIBPFS-1
	MOVEM	T1,SATRBP	;RETREVIAL POINTER AREA+1.

;HERE IS THE LOOP FOR EACH UNIT IN THE STR.

NXUNIT:	PUSHJ	P,GETBAT	;READ BAT PAGE(S).
	JRST	REFFAL
	PUSHJ P,SATCLC		;SET BEGSAT, SVSBTL, LPGSAT, AND SATIND.

;HERE IS THE LOOP FOR EACH SAT ON THE UNIT.

NXTSAT:	PUSHJ	P,INISAT	;INIT SAT BITS(0=BAD,HOME,
	JRST	REFFAL

	PUSHJ	P,NXCLC		;ANOTHER SAT FOR THIS UNIT?
	JRST	NXTSAT		;YES, GO DO IT.

	HLRZ	U,UNISTR(U)	;NEXT UNIT IN STR.
	JUMPN	U,NXUNIT	;LOOP FOR ALL UNITS IN STR.

;HERE AFTER ALL SATS ON ALL UNITS ARE WRITTEN.

	MOVE	U,FSTUNI	;RESET TO FIRST UNIT IN STR


;HERE TO WRITE RIBS FOR SAT.SYS AND HOME.SYS ON FIRST UNIT.

    ;ALLOCATE RIB FOR SAT.SYS.
	MOVEI	T1,%STR		;
	PUSHJ	P,CNVSIZ	;
	SETZ	T2,		;STORE THE EOF AND
	PUSHJ	P,SATRBS	;COUNT THE PRIME RIB IN ALP.
	MOVEI	T2,LPNSAT	;BUILD THE RETRIEVAL POINTER TO
	TLO	T2,RBREAL	;THE SAT.SYS RIB AND
	MOVEM	T2,%STR+RIBSLF	;STORE IT.
	MOVEI	T4,LPNSAT	;T4/ LOG. PAGE NO. OF RIB.
	TLO	T4,RBREAL
	MOVEM	T4,SATRBD	;REMEMBER LOGICAL PAGE NUMBER OF SAT.SYS RIB
	TLZ	T4,RBREAL
	MOVEI	PG,%STR.P	;WRITE OUT THE RIB OF
	PUSHJ	P,OPAGOT	;SAT.SYS.
	JRST	REFFAL
	MOVE	T1,%STR+RIBALP
	MOVEM	T1,SATALP

    ;ALLOCATE RIB FOR HOME.SYS.
	MOVEI	T1,%HMR		;
	PUSHJ	P,CNVSIZ	;
	SETZ	T2,		;STORE THE EOF AND
	PUSHJ	P,HOMRBS	;COUNT THE PRIME RIB IN ALP.
	PUSHJ	P,OGETPG	;ALLOCATE A PAGE FOR HOME.SYS RIB.
	JRST	REFFAL
	MOVEM	T2,%HMR+RIBSLF
	MOVEM	T2,HOMRBD	;REMEMBER LOG. PAGE NUMBER OF RIB FOR HOME.SYS.
	LDB	T4,RBYPNO	;PAGE NO. OF RIB.
	MOVEI	PG,%HMR.P	;WRITE OUT THE RIB OF
	PUSHJ	P,OPAGOT	;HOME.SYS.
	JRST	REFFAL
	MOVE	T1,%HMR+RIBALP	;
	MOVEM	T1,HOMALP	;

;HERE TO ALLOCATE SPACE FOR CRASH.SAV - SPACE TO WRITE OUT A CRASH FILE.

CRSCRE:	MOVE	P2,UNISTR(U)	;SEE IF A
	SKIPN	T4,STRP4C(P2)	;CRASH FILE.
	JRST	NORCV		;NO
	MOVEI	T1,SYNRPR	;STANDARD ACCESS CODE
	MOVEM	T1,CURPRT	;FOR
	MOVEM	T1,CRSPRT	;CRASH.SYS.
	MOVE	U,FSTUNI	;PUT IT ON FIRST UNIT.
	MOVE	T1,CRSFNM	;ARGS
	MOVSI	T2,(SIXBIT .SAV.) ;FOR
	MOVE	T3,SYSPPN	;RBNFIL.
	MOVEI	P4,RIPNDL!RIPNFS ;SET UP THE RIB IN %TMP AND
	PUSHJ	P,RBNFIL	;THE FILE.
	JRST	REFFAL		;
	MOVE	T2,%TMP+RIBALP	;SAVE THE NO. OF PAGES IN THIS
	MOVEM	T2,CRSALP	;FILE + RIB PAGES FOR RIBUSD.
	MOVE	T2,%TMP+RIBSLF	;
	MOVEM	T2,CRSRBD	;


;HERE TO CREATE PRINT UFD.

NORCV:	MOVE	U,FSTUNI	;
	MOVEI	T1,754000	;INFINITLY WRITEABLE PRIVILEGES
	MOVEM	T1,CURPRT
	MOVEM	T1,PRTPRT
	SETZ	P2,		;NO FILES= SUM OF ALPS=0.
	MOVE	T1,SPLPPN	;PRINT UFD
	MOVEM	T1,PRTUFD
	SETZ	P1,		;
	PUSHJ	P,UFDSET	;
	JRST	REFFAL		;
	MOVEM	T2,PRTRBD	;SAVE LOGICAL PAGE NUM OF RIB.
	MOVE	T4,%TMP+RIBALP
	MOVEM	T4,PRTALP

;HERE TO CREATE SYS UFD AND ITS RIB.

	MOVEI	T1,SYSPRV	;SET ACCESS CODE FOR
	MOVEM	T1,CURPRT	;SYS UFD.
	MOVEM	T1,SYSPRT
	MOVE	U,FSTUNI	;FIRST UNIT ON STR
	SETZ	P2,
	MOVSI	T1,-LSTFL	;FIND SUM OF
	ADD	P2,FSTALP(T1)	;ALPS FOR
	AOBJN	T1,.-1		;ITS FILES.
	MOVE	T1,SYSPPN
	MOVEM	T1,SYSUFD	;SAVE IN NAME PAGE.
	MOVSI	P1,-LSTFL	;
	HRRI	P1,FSTFL	;
	PUSHJ	P,UFDSET	;SET UP & WRITE OUT INFO IN THE RIB FOR SYS.UFD.
	JRST	REFFAL
	MOVEM	T2,SYSRBD	;
	MOVE	T4,%TMP+RIBALP
	MOVEM	T4,SYSALP
	SETZ	P3,		;MAKE THE UFD ENTRIES AND
	MOVSI	P1,-LSTFL	;
	HRRI	P1,FSTFL	;
	PUSHJ	P,SETUFD	;SET UP AND WRITE OUT THE UFD ITSELF.
	JRST	REFFAL


;HERE TO CREATE (1,1).UFD (MFD) AND ITS RIB.

	MOVEI	T1,MFDPRV	;SET ACCESS CODE FOR
	MOVEM	T1,CURPRT	;MFD.
	MOVEM	T1,MFDPRT	;
	SETZ	P2,		;
	MOVSI	T1,-LSTUF+1	;SUM OF THE
	ADD	P2,FSTALP+LSTFL(T1) ;ALPS
	AOBJN	T1,.-1		;FOR ITS FILES FOR RIBUFD.
	ADDI	P2,2		;COUNT MFDALP ALSO.
	MOVE	T1,MFDPPN	;NAME OF MFD
	MOVEM	T1,MFDUFD	;SAVE IN NAME PAGE.
	MOVE	P1,[XWD -LSTUF,SYSUFD]
	PUSHJ	P,UFDSET	;SET UP AND WRITE OUT INFO IN THE RIB FOR MFD.
	JRST	REFFAL
	MOVEM	T2,MFDRBD	;
	MOVEM	T2,MFDRIB	;
	MOVE	T4,%TMP+RIBALP	;
	MOVEM	T4,MFDALP
	MOVEI	P3,LSTFL	;NOW DO UFD'S IN MFD
	MOVE	P1,[XWD -LSTUF,SYSUFD]
	PUSHJ	P,SETUFD	;SET UP AND WRITE OUT THE UFD ITSELF.
	JRST	REFFAL

	PUSHJ	P,CNDSWT	;IF THERE IS A SAT IN CORE, WRITE IT.
	JRST	REFFAL

;HERE TO UPDATE THE HOME PAGES ON EACH UNIT OF THE STR.

	INTERN	RANNO		;Set at GETRAN in ONCDSK

	MOVE	U,FSTUNI	;START WITH THE FIRST UNIT.
HOMUPD:	PUSHJ	P,GETHOM	;READ HOME PAGES.
	JRST	REFFAL
	SETZM	%HOM+HOMREF	;CLEAR NEEDS REFRESHING FLAG
	MOVEI	T1,UFDHSI	;
	HRLZM	T1,%HOM+HOMHSH	;
	HRRZ	T1,RANNO
	HRRM	T1,%HOM+HOMRAN	;
	HRRZI	T2,%HOM+HOMTAB	;ADDR OF TABLE OF 1ST LOGICAL PAGES.
	HRLI	T2,FSTPG	;FIRST SUCH WORD
	HRRZI	T3,LSTPGL-1(T2)	;
	BLT	T2,(T3)		;STORE THIS STUFF IN HOME PAGE.
	PUSHJ	P,WTBOTH	;P4 & PG STILL SET UP FROM GETHOM.).
	STOPCD		;WTBOTH HAS TYPED AN ERR MSG.
	HLRZ	U,UNISTR(U)
	JUMPN	U,HOMUPD	;LOOP FOR ALL UNITS IN STR
	PUSHJ	P,CLSAOB

;HERE WHEN ALL DO
	MOVE	T1,FSFPPN	;FAILSAFE PROJ-R
	MOVEM	T1,REFLAG	;SET REFLAG NON-ZERO
	MOVE	U,FSTUNI	;RESET U TO FIRST UNIT
	HRRZ	P2,UNISTR(U)	;TO RESET P2 WHICH WAS CLOBBERED FIXING HOME PAGES.
	MOVEI	T1,UFDHSI	;
	HRRM	T1,STRHSH(P2)
	HRRZS	STRREF(P2)	;CLEAR NEEDS REFRESHING FLAG IN CORE
	JRST	CPOPJ1		;SKIP RETURN


REFFAL:	POPJ	P,		;ERROR EXIT.

SUBTTL PAKREF

;HERE TO REFRESH A SINGLE PACK WHICH IS BEING ADDED TO A STR.
;ENTER WITH U/ UNIT DB AND P2/ STR DB.

REFUNI:	Z	;STORAGE FOR PAKREF.  (UNIT CURRENTLY BEING
		;REFRESHED.).

PAKREF:	MOVEM	U,REFUNI	;SAVE UNIT BEING REFRESHED.
	SETZM	FSTUNI		;FLAG FOR INISAT.
	HRRM	P2,UNISTR(U)	;PUT STR HERE, SOME LOOK FOR IT.
	HLRZ	U,STRUNI(P2)	;GET THE 1ST UNIT IN THE STR.
	SETZM	SATDSK		;MARK NO SAT IN CORE IN %STA.
	PUSHJ	P,GETHOM	;GET HOME PAGES FROM FIRST UNIT.
	JRST	PAKLEV		;ERROR.
	HRLI	T2,%HOM+HOMTAB	;BUILD THE TABLE OF
	HRRI	T2,FSTPG	;PAGE NOS. OF RIBS FOR
	BLT	T2,FSTPG+LSTPGL-1 ;FILES OF INTEREST.

  ;NOW GET THE CURRENT RIBS FOR HOME AND SAT INTO %HMR AND %STR.
	MOVSI	P4,-PAKFIL	;P4/ LOOP INDEX.
PREF2:	SKIPN	T4,FSTPG(P4)	;T4/ PAGE NO. OF PRIME RIB WRS UNIT.
	JRST	PAKLEV		;
	TLZ	T4,RBREAL	;

	HRRZ	PG,FSTCTL(P4)	;PG/ %XXX.P.
	HLRZ	P1,FSTCTL(P4)	;P1/ %XXX.
	MOVE	U,REFUNI	;
	HRRZ	P2,UNISTR(U)	;
	HLRZ	U,STRUNI(P2)	;
	PUSHJ	P,OPAGIN	;
	JRST	PAKLEV
	MOVE	P2,RIBSIZ(P1)	;CALC NO. OF THE LAST PAGE IN
	IDIVI	P2,1000		;FILE. (NB NOT TRUE IN GENERAL.)
PREF3:	MOVE	T3,RIBSZS(P1)	;FOUND RIGHT RIB IF
	CAIE	T3,1		;AT LOWEST LEVEL.
	JRST	PREF4		;
	ADDI	P2,RIBPFS(P1)	;P2/ ADDR OF EOF PNTR.
	SKIPE	RIBRIB(P1)	;
	ADDI	P2,RIBSFS-RIBPFS ;
	JRST	PREF11		;
PREF4:	IDIV	P2,RIBSZS(P1)	;ELSE P2/ #PRECED SPARE PNTRS
	ADDI	P2,RIBPFS(P1)	;P2/ ADDR OF NEXT PNTR.
	SKIPE	RIBRIB(P1)	;
	ADDI	P2,RIBSFS-RIBPFS ;
	MOVE	T2,(P2)		;IS THE PNTR
	TLNN	T2,RBSPAR	;A SPARE RIB PNTR?
	JRST	PREF5		;NO, WE ARE IN THIS RIB.
	MOVE	P2,P3		;YES, WE MUST READ
	LDB	U,RBYUNI	;IN
	MOVE	U,UNTTBL(U)	;THE
	LDB	T4,RBYPNO	;LOWER
	PUSHJ	P,OPAGIN	;RIB.
	JRST	PAKLEV		;
	JRST	PREF3		;
PREF5:	ADDI	P2,(P3)		;

    ;HERE WITH ADDR OF EOF PNTR IN P2.
PREF11:	MOVE	T1,P2		;BUILD
	SUB	P2,P1		;AN
	SUBI	P2,RIBLST+2	;AOBJN
	HRLM	P2,T1		;POINTER
	HRRI	T1,-1(T1)	;IN T1.
	MOVEM	T1,FSTPRT(P4)	;SAVE T1 IN A STRANGE PLACE.
PRFNST:	AOBJN	P4,PREF2

    ;READ THE BAT PAGE INTO %BAT.
	MOVE	U,REFUNI	;READ THE
	PUSHJ	P,GETBAT	;BAT PAGE.
	JRST	PAKLEV		;

  ;HERE FOR THE SATS FOR THIS UNIT.
	PUSHJ	P,SATCLC	;CALC BEGSAT, SVSBTL, LPGSAT, AND SATIND.
	MOVE	T1,HOMPRT	;SET
	MOVEM	T1,HOMRBP	;THE
	MOVE	T1,SATPRT	;PNTRS WE JUST FOUND
	MOVEM	T1,SATRBP	;TO

    ;THIS IS THE LOOP FOR EACH SAT.
RFNXST:	PUSHJ	P,INISAT	;SET UP A SAT AND PART OF HOME.SYS.
	STOPCD

	PUSHJ P,NXCLC		;CALC INFO FOR NEXT SAT.
	JRST	RFNXST		;GO.


    ;HERE TO SET NEW RIBSIZ'S IN THE RIBS FOR HOME.SYS
    ;AND SAT.SYS.

	MOVEI	T1,%HMR		;
	PUSHJ	P,CNVSZM	;
	SETZ	T2,		;STORE THE
	PUSHJ	P,HOMRBS	;EOF POINTER.

	MOVEI	T1,%STR		;
	PUSHJ	P,CNVSZM	;
	SETZ	T2,		;
	PUSHJ	P,SATRBS	;

    ;NOW FIX UP THE HOME PAGES ON THIS UNIT.

FIXHOM:	MOVE	U,REFUNI	;
	PUSHJ	P,GETHOM	;
	STOPCD
	SETZM	%HOM+HOMREF	;
	HRRZ	T1,STRDDB+STRHSH
	HRLZM	T1,%HOM+HOMHSH	;
	HRRZ	T1,RANNO	;
	HRRM	T1,%HOM+HOMRAN	;
	HRLI	T2,FSTPG	;
	HRRI	T2,%HOM+HOMTAB	;
	MOVEI	T1,LSTPGL-1(T2)	;
	BLT	T2,(T1)		;
	PUSHJ	P,WTBOTH	;NOW WRITE THEM OUT.
	STOPCD
	HRRZ	P2,UNISTR(U)	;
	MOVEI	T1,UFDHSI	;
	HRRM	T1,STRHSH(P2)	;

    ;NOW WRITE OUT THE RIBS FOR HOME AND SAT.
	MOVSI	P4,-PAKFIL	;
PAKRB1:	HLRZ	T3,FSTCTL(P4)	;
	MOVE	T2,RIBSLF(T3)	;
	LDB	T4,RBYPNO	;
	LDB	U,RBYUNI	;
	MOVE	U,UNTTBL(U)	;
	HRRZ	PG,FSTCTL(P4)	;
	PUSHJ	P,OPAGOT
	STOPCD
PKRB1A:	AOBJN	P4,PAKRB1
	PUSHJ	P,CNDSWT	;
	STOPCD
	PUSHJ	P,CLUAOB
	AOS	(P)			;SUCCESS RETURN

PAKLEV:	MOVE	U,REFUNI
	HRRZ	P2,UNISTR(U)	;
	POPJ	P,

SUBTTL VARIOUS SUBROUTINES.

COMMENT #
@@SUBROUTINE SCNBAT
@@PURPOSE
SUBR TO SCAN BAT AREA AND EXECUTE AN INSTRUCTION FOR
EACH BAD PAGE.
@@ENTRY
EXPECTS T2/ INSTRUCTION TO EXECUTE (AND IF CALLING SETBTS,
T3/ ADDR OF STT ENTRY.).
@@ACCUM
DESTROYS T1, T2, AND T4.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

	INTERN	SCNBAT

SCNBAT:	JSP	T4,SAVE4	;SAVE P1-P4
	MOVE	P2,T2		;P2=INSTRUCTION TO EXECUTE.
	MOVEI	P4,%BAT		;P4/ -NO. OF WORDS IN AREA,,
	ADD	P4,%BAT+BATFIR	;ADDR OF 1ST ENTRY.
	SKIPN	T1,(P4)		;AT END?
	JRST	CPOPJ1		;YES.

    ;HERE FOR EACH ENTRY.
SCNBT2:	MOVE	T2,P4		;ADDR OF BAD REGION PTR FOR LDB.
	LDB	P3,BAYNBB	;NUMBER BAD PAGES-1.
	HRRZ	P1,1(P4)	;P1=1ST BAD PAGE.
	JRST	.+2
    ;HERE FOR EACH BAD PAGE.
SCNBT4:	ADDI	P1,1		;P1=NEXT BAD PAGE.
	MOVE	T1,P1		;ARG FOR INSTRUCTION.
	XCT	P2		;MARK THIS PAGE IN SAT.
	SOJGE	P3,SCNBT4	;LOOP FOR ALL BAD PAGES THIS REGION.
	AOBJN	P4,.+2		;COMPENSATE FOR 2 WORD ENTRIES.
	MSGLIV	BATBAD
	SKIPE	1(P4)		;END OF NON-ZERO ENTRIES?
	AOBJN	P4,SCNBT2	;LOOP FOR ALL ENTRIES
	JRST	CPOPJ1

COMMENT #
@@SUBROUTINE SETBTS
@@PURPOSE
SUBR TO CLEAR AN F BIT IN %STA AND DECREMENT STTFPC.
@@ENTRY
EXPECTS T1/ PAGE NO. OF BIT AND T3/ ADDR OF STT ENTRY.
@@ACCUM
DESTROYS T1, T2, AND T4.
@@ #

SETBTS:	CAML	T1,BEGSAT	;SKIP IF BEFORE BEGINNING OF CURRENT SAT.
	CAMLE	T1,LPGSAT	;SKIP IF WITHIN CURRENT SAT (NOT PAST END)
	POPJ	P,		;PAGE NOT IN CURRENT SAT.
	SUB	T1,BEGSAT	;
	IDIVI	T1,^D36		;T1=INDEX IN PAGE OF BIT.
	MOVNS	T2		;T2=BITS TO SHIFT RIGHT
	MOVSI	T4,400000	;SET LEFTMOST BIT
	LSH	T4,(T2)		;POSITION BIT
	TDNN	T4,%STA(T1)	;SKIP IF BIT SET.
	POPJ	P,		;ALREADY CLEAR, JUST RETURN.
	XORM	T4,%STA(T1)	;SO CLEAR IT.
	SOS	STTFPC(T3)	;NOTE ONE LESS FREE PAGE.
	POPJ	P,

COMMENT #
@@SUBROUTINE INISAT
@@PURPOSE
SET ALL THE BITS IN %STA TO REPRESENT AVAILABLE PAGES,
EXCEPT THOSE FOR BAD PAGES, THE
HOME & BAT & BOOT PAGES, NON-EXISTENT PAGES, AND PAGE 0.
ALSO MAKE THE STT ENTRY AND WRITE OUT THE SAT.
@@ENTRY
EXPECTS BEGSAT, SVSBTL, LPGSAT, AND SATIND TO BE SET UP
U/ UNIT DB, AND F/ DDB.
@@ACCUM
DESTROYS T1 THRU T4, P1 THRU P4, AND PG.
@@CALLS
CORONZ, SCNBAT, SETBTS, GETHMP, SATSRH, SATRBS, OPAGOT, AND CPOPJ1.
@@EXIT
NON-SKIP RETURNS IF SOMETHING IS WRONG, ELSE SKIP RETURNS.
@@ #

    ;HERE TO MAKE THE STT ENTRY.
INISAT:	PUSHJ	P,CNDSWT	;WRITE OUT ANY SAT IN CORE BEFORE
	POPJ	P,		;WE WIPE IT OUT.
	AOS	T1,SATIND	;GET INTO T1 THE
	IMULI	T1,STTLEN	;ADDR OF THE
	HRRZ	T2, UNISTT(U)	;STT
	ADDI	T1,(T2)		;ENTRY.
	SETZM	STTAOB(T1)	;CLEAR AOBJN POINTER.
	MOVE	T2,SVSBTL	;SET THE COUNT OF
	MOVEM	T2,STTFPC(T1)	;FREE PAGES.
	SETZM	STTSTS(T1)	;CLEAR THE STATUS.
	PUSH	P,T1		;SAVE ENTRY ADDR FOR BELOW.

    ;HERE TO SET ALL SAT BITS AND THEN CLEAR BITS OF NON-EXISTENT PAGES.
	HRRZI	T1,%STA		;SET THE ENTIRE
	SETOM	%STA		;AREA REPRESENTED IN THIS
	PUSHJ	P,CORONZ	;SAT TO AVAILABLE.
	MOVE	T2,SVSBTL	;ANY NON-EXISTENT PAGES
	CAIL	T2,400*^D36	;AT THE END OF THE SAT?
	JRST	INISA3		;NO.
	SETZ	T1,		;YES, DOES A PARTIAL
	IDIVI	T2,^D36		;WORD IN THE SAT HAVE
	JUMPE	T3,INISA2	;TO BE SET?
	MOVSI	T1,400000	;YES.  SET
	MOVNI	T3,-1(T3)	;THE PARTIAL
	ASH	T1,(T3)		;WORD.
INISA2:	MOVEM	T1,%STA(T2)	;SET PARTIAL WORD OR NEXT WORD.
	CAIL	T2,377		;ANY MORE WORDS TO SET?
	JRST	INISA3		;NO.
	SETZM	%STA+1(T2)	;YES, PREPARE TO BLT.
	CAIL	T2,376		;BUT NOT IF ONLY ONE
	JRST	INISA3		;WORD TO DO.
	HRRZI	T2,%STA+2(T2)	;SET THE REST OF
	HRLI	T2,-1(T2)	;THE SAT TO
	BLT	T2,%STA+377	;UNAVAILABLE.

    ;HERE TO SCAN BAT AREA AND MARK BAD PAGES IN SAT.
INISA3:	POP	P,T3		;RESTORE STT ENTRY ADDRESS.
	MOVE T2,[PUSHJ P,SETBTS] ;INSTRUCTION TO EXECUTE
	PUSHJ P,SCNBAT		;FOR EACH BAD PAGE.
	POPJ	P,

INISA5:	SKIPE	BEGSAT		;SKIP IF THIS IS 1ST SAT ON THIS UNIT
	JRST INISA6

    ;HERE TO ALLOCATE PAGES (HOME, BAT, AND BOOTS) IN HOME.SYS FILE
    ;AND PAGE FOR SAT.SYS RIB.
    ;(DONE ONLY IF THIS IS THE FIRST SAT ON THIS UNIT.).
	MOVSI	P3,-LBNLEN
	MOVE	T1,LBNLST(P3)
	PUSHJ	P,GETHMP	;GET NEXT PAGE IN THE GROUP.
	POPJ	P,		;CAN'T GET IT.
	AOBJN	P3,.-3		;LOOP FOR ALL OF THE GROUP
	MOVE	P3,[XWD -NBOOTP,FBOOTB]	;P3=-# PAGES FOR BOOTS, 1ST PAGE.
	HRRZ	T1,P3		;NEXT PAGE TO ALLOCATE.
	PUSHJ	P,GETHMP	;ALLOCATE THE PAGE.
	POPJ	P,
	AOBJN	P3,.-3		;LOOP FOR ALL PAGES TO ALLOCATE FOR BOOTS.
	CAME	U,FSTUNI	;
	JRST	INISA6		;
	MOVEI	T1,LPNSAT	;ALLOCATE THE PAGE FOR THE SAT.SYS
	PUSHJ	P,TAKPAG	;RIB, SO NOBODY ELSE GETS IT.
	POPJ	P,		;

    ;HERE TO WRITE THIS SAT PAGE OUT TO THE DISK.
INISA6:	MOVE	P1,T3		;P1 HAS INDEX FOR SATSRH AND SAFETY.
	SKIPLE	STTFPC(P1)	;ROOM IN THIS SAT FOR ITSELF?
	JRST	INISA8		;YES.
	HRRZ	T1,UNISTT(U)	;NO.  TRY TO
	CAIN	P1,(T1)		;FIND ROOM
	MSGLIV	OGTPG		;IN AN EARLIER SAT, IF THERE IS ONE.
	MOVE	T1,[XWD %STA,%T2P] ;MEANWHILE, SAVE US
	BLT	T1,%T2P+777	;IN %T2P.
	SETZM	STTPTR(P1)	;DON'T LET OGETPG GET PAST US.
	PUSHJ	P,OGETPG	;TRY TO GET A PAGE IN AN EARLIER SAT.
	POPJ	P,		;
	MOVEI	PG,%T2P.P	;REMEMBER WE WANT TO WRITE OUT %T2P.
	JRST	INISA9		;
INISA8:	MOVEI	P2,1		;HERE TO GET A PAGE
	PUSHJ	P,SATSRH	;IN OURSELVES.
	POPJ	P,
	MOVEI	PG,%STA.P	;REMEMBER WE WANT TO WRITE OUT %STA.
INISA9:	MOVEM	T2,STTPTR(P1)	;STORE THE DISK PNTR TO THE SAT.
	PUSHJ	P,SATRBS	; " IN SAT.SYS RIB.
	LDB	T4,RBYPNO	;WRITE OUT THE
	PJRST	OPAGOT		;SAT PAGE.

LBNLST:	Z
	LPNHOM
	LP2HOM
	LPNBAT
	LP2BAT
LBNLEN==.-LBNLST

COMMENT #
@@SUBROUTINE NXCLC
@@PURPOSE
SUBR TO SEE IF THIS UNIT NEEDS MORE SATS THAN WE HAVE ALREADY
CREATED.
@@ENTRY
EXPECTS U/ UNIT DB AND BEGSAT AND SVSBTL TO BE SET UP.
@@ACCUM
DESTROYS T2.
@@EXIT
SKIP RETURNS IF NO MORE SATS FOR THIS UNIT.  ELSE NON-SKIP
RETURNS WITH BEGSAT, LPGSAT, AND SVSBTL SET UP.
@@ #

NXCLC:	MOVE	T2,SVSBTL	;PAGES IN THIS SAT.
	ADD	T2,BEGSAT	;LAST PAGE IN THIS SAT+1. NEXT
	CAML	T2,UNIPPU(U)	;SAT WOULD BE PAST E O UNIT?
	JRST	CPOPJ1		;YES, NO MORE SATS THIS UNIT.
	MOVEM	T2,BEGSAT	;NO, ANOTHER SAT FOR THIS UNIT.
	ADD	T2,SVSBTL	;COMPUTE END OF NEXT
	SUBI	T2,1		;SAT.
	MOVEM	T2,LPGSAT	;REMEMBER LAST PAGE NEW SAT.
	ADDI	T2,1		;SKIP IF NEW SAT WOULD GO
	CAMG	T2,UNIPPU(U)	;PAST END OF UNIT.
	POPJ	P,		;NO, KEEP GOING.
	SUB	T2,UNIPPU(U)	;YES. FIND OUT HOW
	MOVNS	T2		;MUCH OVER.
	ADDM	T2,SVSBTL	;CORRECT SIZE OF SAT
	ADDM	T2,LPGSAT	;AND LAST PAGE.
	POPJ	P,		;MORE SATS THIS UNIT.



COMMENT #
@@SUBROUTINE SATCLC
@@PURPOSE
A LITTLE SUBR TO SET BEGSTA, SVSBTL, LPGSAT, AND SATIND FOR THE
FIRST SAT ON A UNIT.
@@ACCUM
DESTROYS T1.
@@ #

SATCLC:	SETZM	 BEGSAT		;BEGSAT/ 1ST SAT ON A UNIT.
	MOVEI	T1,400*^D36	;SVSBTL/ NO. OF REAL
	MOVEM	T1,SVSBTL	;ENTRIES IN THIS SAT.
	SUBI	T1,1		;LPGSAT/ LAST PAGE IN
	MOVEM	T1,LPGSAT	;THE FIRST SAT.
	SETOM	SATIND		;SAT INDEX,
	POPJ	P,		;SET TO -1 (BECAUSE WE AOS.).

COMMENT #
@@SUBROUTINE GETHMP
@@PURPOSE
SUBR TO ALLOCATE 1 HOME.SYS PAGE IN CURRENT SAT WHILE CREATING SATS.
(ONLY WORKS FOR FIRST SAT ON A UNIT.).
@@ENTRY
EXPECTS  T1/ LOGICAL PAGE NO. TO ALLOCATE,
T3/ STT ENTRY ADDRESS, AND U/ UNIT DB.
@@ACCUM
DESTROYS T1 AND T2.
@@CALLS
TAKPAG AND HOMRBS.
@@EXIT
NON-SKIP RETURN IF CAN'T HAVE PAGE.
SKIP RETURN IF GET PAGE, WITH THE RETRIEVAL POINTER TO THE
PAGE STORED IN THE HOME.SYS RIB IN CORE.
@@ #

GETHMP:	PUSHJ	P,TAKPAG	;
	POPJ	P,		;NOT AVAILABLE.
	PUSHJ	P,HOMRBS	;
	JRST	CPOPJ1




COMMENT #
@@SUBROUTINE TAKPAG
@@PURPOSE
SUBR TO MARK A PAGE TAKEN AND ADJUST SSTFPC IN THE FIRST SAT IN
A UNIT.
@@ENTRY
EXPECTS  T1/ LOGICAL PAGE NO. TO ALLOCATE,
T3/ STT ENTRY ADDRESS, AND U/ UNIT DB.
@@ACCUM
DESTROYS T1 AND T2.
@@EXIT
NON-SKIP RETURN IF CAN'T HAVE PAGE.
SKIP RETURN IF GET PAGE, WITH THE RETRIEVAL POINTER TO THE
PAGE IN T2.
@@ #

TAKPAG:	JSP	T4,SAVE1	;SAVE P1
	PUSH	P,T1		;SAVE PAGE NEEDED (FOR PNTR.).
	IDIVI	T1,^D36
	ADDI	T1,%STA		;
	MOVNS	T2		;
	MOVSI	P1,400000
	LSH	P1,(T2)		;SHIFT BIT INTO POSITION
	POP	P,T2		;
	TDNN	P1,(T1)		;SKIP IF AVAILABLE.
	MSGLIV	NOTAVL		;NOT AVAILABLE.
	XORM	P1,(T1)		;MARK THE PAGE UNAVAILABLE.
	TLO	T2,RBREAL	;MAKE T2
	LDB	T1,UNYLUN	;A
	DPB	T1,RBYUNI	;RETRIEVAL POINTER.
	SOS	STTFPC(T3)	;
	JRST	CPOPJ1


COMMENT #
@@SUBROUTINE UFDSET
@@PURPOSE
SUBR TO SET UP INFORMATION IN A UFD RIB IN %TMP AND THEN
WRITE IT OUT.
@@ENTRY
EXPECTS T1/ FILENAME OF UFD, U/ UNIT DB, P1/ AOBJN PNTR TO
FILENAMES, AND P2/ ARG. FOR RIBUSD.
@@CALLS
HASH, RIBSET, OGETPG, AND TMPOUT.
@@ACCUM
DESTROYS
@@EXIT
NON-SKIP RETURNS IF ERROR, ELSE SKIP RETURNS WITH
T2/ DISK PNTR TO RIB ITSELF.
@@ #

UFDSET:	PUSH	P,P2		;
	MOVSI	T2,(SIXBIT .UFD.)
	MOVE	T3,MFDPPN
	MOVEI	T4,%TMP		;
	MOVEI	P4,RIPDIR	;SET DIRECTORY BIT IN STATUS
	PUSHJ	P,RIBSET	;SET UP INFO IN RIB IN CORE.
	POP	P,T2		;STORE NO. OF PAGES IN ALL THE
	MOVEM	T2,%TMP+RIBUSD	;FILES THIS UFD POINTS TO.
	MOVEM	T2,%TMP+RIBMXA	;
    ;SET UP UFDHSI NON-EXISTENT PNTRS.
	MOVEI	T1,UFDHSI	;SET UP UFDHSI
	MOVEI	T2,(SIXBIT/CAT/) ;NON-EXISTENT PNTRS
	MOVEM	T2,%TMP+RIBPFS-1(T1) ;IN THE PRIME
	SOJG	T1,.-1		;RIB.
    ;SET UP THE REAL PNTRS.
	MOVEI	P3,1		;COUNT FOR RIBALP.
	JUMPE	P1,UFDST3	;
UFDST1:	MOVE	T1,(P1)		;GET T1/ FIRST FILENME.
	PUSHJ	P,HASH		;HASH IT TO T1.
	MOVE	T2,%TMP+RIBPFS-1(T1) ;PNTR FOR THIS FILE'S PAGE.
	TLNE	T2,RBREAL	;HAS IT ALREADY BEEN MADE REAL?
	JRST	UFDST2		;YES.
	MOVE	P2,T1		;SAVE PLACE.
	PUSHJ	P,OGETPG	;NO, GET A PAGE FOR IT.
	POPJ	P,		;LOST.
	ADDI	P3,1		;COUNT FOR RIBALP.
	MOVEM	T2,%TMP+RIBPFS-1(P2) ;STORE THE REAL PNTR.
UFDST2:	AOBJN	P1,UFDST1	;CONTINUE FOR ALL FILES.
UFDST3:	MOVEM	P3,%TMP+RIBALP	;STORE RIBALP.
	MOVEI	P3,UFDHSI*1000	;CALC AND
	MOVEM	P3,%TMP+RIBSIZ	;STORE RIBSIZ.

	PUSHJ	P,OGETPG	;GET A PAGE FOR THE
	POPJ	P,
	MOVEM	T2,%TMP+RIBSLF	;RIB.
	PUSHJ	P,TMPOUT	;WRITE OUT THE RIB.
	POPJ	P,
	MOVE	T2,%TMP+RIBSLF	;
	JRST	CPOPJ1

COMMENT #
@@SUBROUTINE SETUFD
@@PURPOSE
SUBR TO SET UP INFO IN THE PAGES OF A UFD AND THEN WRITE THEM
OUT.
@@ENTRY
EXPECTS P3/ INDEX IN FSTPG OF FIRST FILE AND
AND P1/ -LOOP COUNTER,,ADDRESS OF FIRST FILENAME.
EXPECTS PRIME RIB TO BE SET UP IN %TMP.
@@ACCUM
DESTROYS 
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

SETUFD:	PUSH	P,P2		;SAVE P2.
	MOVEI	P2,1		;P2/ CURRENT HASH NUMBER.

SETUF1:	MOVE	T2,%TMP+RIBPFS-1(P2) ;T2/ ASSOCIATED RIB PNTR.
	TLNE	T2,RBREAL	;ANY FILE WITH THIS HASH?
	JRST	SETUF2		;YES, GO MAKE ENTRIES.

    ;HERE TO TRY NEXT HASH NUMBER, OR TO FINISH UP.
SETUFN:	CAIGE	P2,UFDHSI	;ALL DONE?
	AOJA	P2,SETUF1	;NO, CONTINUE.
	POP	P,P2		;YES, RESTORE P2.
	JRST	CPOPJ1		;

    ;HERE TO MAKE ENTRIES IN ONE PAGE OF THE UFD.
SETUF2:	MOVEI	T1,%T2P		;CLEAR AN AREA FOR
	PUSHJ	P,CORZER	;THE UFD IN CORE, IN %T2P.
	MOVE	T1,[XWD -776,%T2P] ;776 DIVIDES EVENLY BY 5.
	MOVEM	T1,UFDSTP	;SET UP AOBJN PNTR FOR ENTUFD.
	PUSH	P,P3		;SAVE P3 AND
	PUSH	P,P1		;P1.
SETUF4:	MOVE	T1,(P1)		;GET T1/ CURRENT FILENAME.
	PUSHJ	P,HASH		;GET HASH TO T1.
	CAIN	T1,(P2)		;MATCH FOR THIS BLOCK?
	PUSHJ	P,ENTUFD	;YES, MAKE THE UFD
	ADDI	P3,1		;ENTRY.
	AOBJN	P1,SETUF4	;
SETUF5:	POP	P,P1		;RESTORE P1 AND
	POP	P,P3		;P3.
	MOVEI	PG,%T2P.P	;WRITE
	MOVE	T2,%TMP+RIBPFS-1(P2)	;OUT
	LDB	T4,RBYPNO	;THE
	LDB	U,RBYUNI	;PAGE
	MOVE	U,UNTTBL(U)	;OF THE
	PUSHJ	P,OPAGOT	;UFD.
	POPJ	P,
	JRST	SETUFN		;




COMMENT #
@@SUBROUTINE HASH
@@PURPOSE
LITTLE SUBR TO HASH A FILENAME FOR A UFD.
@@ENTRY
EXPECTS FILENAME IN T1.
@@ACCUM
DESTROYS T1 AND T2.
@@EXIT
RETURNS HASH IN T1.
@@ #

HASH:	TLZ	T1,(1B0)
	IDIVI	T1,UFDHSI
	MOVEI	T1,1(T2)	;
	POPJ	P,




COMMENT #
@@SUBROUTINE ENTUFD
@@PURPOSE
SUBR TO MAKE AN ENTRY IN A UFD.
@@ENTRY
EXPECTS P3/ TABLE INDEX OF FILE TO ENTER AND UFDSTP/ AOBJN
POINTER TO UFD IN CORE.
@@ACCUM
DESTROYS T1 THRU T4 AND U.
@@ #

ENTUFD:	SKIPN	T1,FSTPG(P3)	;CFP.
	POPJ	P,
    ;CALC THE COMPRESSED FILE POINTER.
	SKIPL	T4,UFDSTP	;SKIP IF STILL ROOM IN THIS PAGE.
	MSGSFE	UFDERR
	MOVEM	T1,4(T4)	;STORE CFP.
	MOVE	T1,FSTFL(P3)	;FILE NAME
	HRLI	T2,(SIXBIT .SYS.) ;MOST EXTENSIONS ARE SYS
	CAMN	T1,CRSFNM	;CRASH.SAV HAS A STRANGE EXTENSTION
	HRLI	T2,(SIXBIT .SAV.)
	CAIL	T1,0		;SKIP IF ASCII NAME, NOT OCTAL NUMBER
	HRLI	T2,(SIXBIT .UFD.) ;OCTAL NUMBERS ARE UFDS
	MOVEM	T1,(T4)		;STORE FILE NAME
	HLLM	T2,1(T4)	;AND EXTENSION.
	LDB	T2,[POINT 9,FSTPRT(P3),^D26]
	HRRM	T2,1(T4)
	MOVE	T2,FSTALP(P3)
	HRLZM	T2,3(T4)
	SETZM	2(T4)
	ADD	T4,[XWD 5,5]	;BUMP POINTER
	MOVEM	T4,UFDSTP	;RESTORE POINTER
	POPJ	P,

COMMENT #
@@SUBROUTINE RBNFIL
@@PURPOSE
SUBR TO SET UP A RIB IN CORE IN %TMP.P, GET A SPECIFIED
NO. OF PAGES ON A UNIT, STORE THEIR RETRIEVAL PNTRS
IN THE RIB(S), AND WRITE OUT THE RIB(S).
@@ENTRY
EXPECTS:
	T1/ FILE NAME
	T2/ EXT
	T3/ PPN
	T4/ NUMBER OF PAGES TO ALLOCATE (NOT INCLUDING RIBS).
	P4/ BITS TO SET IN STATUS WORD
	U/ UNIT DB
@@ACCUM
DESTROYS
@@CALLS
RIBSET, OGETPG, OPAGOT, SATSRH, GETSAT, GETPRM, AND PTREXT.
@@EXIT
IF ERROR, NON-SKIP RETURNS, ELSE SKIP
RETURNS WITH PRIME RIB IN %TMP (ALREADY WRITTEN OUT)
AND PGSRIB INCREMENTED FOR EACH RIB (OTHER THAN THE PRIME RIB)
GENERATED.
@@ #

    ;SET UP THE PRIME RIB IN CORE.
RBNFIL:	MOVEM	T4,PAGNED	;SAVE NO. OF PAGES REQUESTED.
	SETZM	PGSRIB		;PGSRIB HOLDS NO. OF SPARE RIBS GENERATED.
	MOVEI	T4,%TMP		;SET UP THE
	PUSHJ	P,RIBSET	;RIB AREA.
	MOVEI	T4,1		;SET NO. OF PAGES
	ADD	T4,PAGNED	;PLUS ONE
	MOVEM	T4,%TMP+RIBALP	;RIB.
	PUSHJ	P,OGETPG	;GET A DISK PAGE FOR THE RIB.
	POPJ	P,
	MOVEM	T2,%TMP+RIBSLF	;STORE SELF RIB PNTR.
	HRLI	T1,-RBLVPR-1	;SET UP
	HRRI	T1,%TMP+RIBPFS-1
	MOVEM	T1,TMPRBP	;PNTR TO RIB AREA.

    ;LOOK FOR DISK SPACE.  SEARCH FOR THE SAT ON THIS UNIT WITH
    ;THE MOST SPACE.
RBNFL1:	SETZB	P1,P2		;CLR MAX FOUND AND INDEX.
	HRRZ	T1,UNISTT(U)	;T1/ INDEX INTO STT.
RBNFL2:	SKIPN	T2,STTPTR(T1)	;AT E O TABLE?
	JRST	RBNFL4		;YES.
	SKIPN	T3,STTFPC(T1)	;NO. ANY FREE PAGES IN THIS SAT?
	JRST	RBNFL3		;NO.
	CAML	T3,PAGNED	;YES. ENOUGH TO SATISFY REQUEST?
	JRST	RBNFL6		;YES.
	CAMG	T3,P2		;NO. FOUND MORE THAN MAX SEEN ALREADY?
	JRST	RBNFL3		;NO.
	MOVE	P2,T3		;YES, SAVE IT AS
	MOVE	P1,T1		;MAX.
RBNFL3:	ADDI	T1,STTLEN	;NO.  LOOK AT NEXT
	JRST	RBNFL2		;SAT ENTRY IN STT.

      ;HERE AT END OF TABLE.
RBNFL4:	JUMPN	P2,.+2		;BETTER HAVE FOUND SOMETHING.
	MSGLIV	OGTPG
	PUSH	P,P1		;SAVE SAT'S INDEX IN STT.
	SKIPA	T2,STTPTR(P1)	;T2/ SAT'S DISK POINTER.

    ;HERE TO READ IN THE SAT.
RBNFL6:	PUSH	P,T1		;SAVE SAT'S INDEX IN STT.
	PUSHJ	P,GETSAT	;
	JRST	[POP P,T1
		POPJ P,]
	MOVE	P2,PAGNED	;SET UP ARGS
	POP	P,P1		;FOR SATSRH. (CLRS BITS & RETURNS

    ;HERE TO GET SOME SPACE IN THE SAT.
RBNFL7:	PUSHJ	P,SATSRH	;T2/ DISK PNTR AND T1/ COUNT.).
	POPJ	P,
	MOVE	P3,T1		;P3/ # PAGES GOTTEN.
	MOVE	P2,PAGNED	;CALC NO.
	SUB	P2,P3		;LEFT TO
	MOVEM	P2,PAGNED	;GET.
RBNFL8:	PUSHJ	P,PTREXT 	;STORE THE
	POPJ	P,
	SOJLE	P3,.+2		;DISK POINTERS
	AOJA	T2,RBNFL8	;TO GOTTEN SPACE.

	JUMPLE	P2,RBNFL9	;MORE PAGES TO GET?
	SKIPLE	STTFPC(P1)	;YES.  MORE ROOM IN THIS SAT?
	JRST	RBNFL7		;YES.
	JRST	RBNFL1		;NO.

    ;HERE WHEN DONE STORING PNTRS (EXCEPT FOR EOF PNTR).
RBNFL9:	SETZ	T2,		;STORE
	PUSHJ	P,PTREXT	;EOF PNTR.
	POPJ	P,
	SKIPN	PGSRIB		;MORE THAN JUST A PRIME RIB?
	JRST	RBNF10		;NO.
	PUSHJ	P,GETPRM	;YES, GET IT AND
	POPJ	P,
	MOVE	P1,PGSRIB	;ADJUST
	ADDM	P1,%TMP+RIBALP	;RIBALP.
RBNF10:	MOVE	T2,%TMP+RIBSLF	;
	LDB	T4,RBYPNO	;WRITE
	MOVEI	PG,%TMP.P	;IT
	PUSHJ	P,OPAGOT	;OUT.
	POPJ	P,
	JRST	CPOPJ1

PAGNED: Z		;TEMP STORAGE FOR RBNFIL.

COMMENT #
@@SUBROUTINE SATSRH
@@PURPOSE
SUBR TO GET SOME CONTIGUOUS FREE PAGES ON A SAT IN %STA, AND SET
THEM IN USE.
SAT IS GUARANTEED TO HAVE SOME PAGES FREE ON ENTRY.
@@ENTRY
EXPECTS P1/ STT ENTRY ADDR OF SAT, P2/ MAX NO. OF PAGES
TO GET, U/ UNIT NO., AND F/ DDB.
@@ACCUM
DESTROYS T1 THRU T4 AND P2.
@@EXIT
IF ERROR, NON-SKIP RETURNS, ELSE SKIP
RETURNS WITH T2/ DISK POINTER TO FIRST PAGE GOTTEN, T1/ NO. OF
PAGES ACTUALLY GOTTEN, AND THE SAT HAS THE PAGES TAKEN MARKED
IN USE.  STTFPC AND STTAOB ARE ALSO ADJUSTED.
@@ #

SATSRH:	SKIPN	T1,STTAOB(P1)	;T1/ CURRENT AOBJN POINTER.
	JRST	SATSR2		;START AT START OF SAT IF NONE.
	SKIPE	T2,(T1)		;ANY FREE BITS IN THIS WORD?
	JRST	SATSR3		;YES.
	AOBJN	T1,.-2		;NO, TRY NEXT WORD.

SATSR2:	MOVE	T1,[XWD -400,%STA] ;T1/ AOBJN PNTR TO START OF SAT.
	SKIPE	T2,(T1)		;ANY FREE BITS IN THIS WORD?
	JRST	SATSR3		;YES.
	AOBJN	T1,.-2		;NO, TRY NEXT WORD.
	MSGLIV	OGTPG

    ;HERE ON FOUND FIRST FREE PAGE.
      ;BUILD THE DISK POINTER TO IT.
SATSR3:	JFFO	T2,.+2		;GET T3/ NO. OF BITS INTO WORD.
	STOPCD
	HRRZI	T4,-%STA(T1)	;PAGE NO. IS
	IMULI	T4,^D36		;(NO. OF WORDS INTO SAT *
	ADDI	T4,(T3)		;^D36) +
	HRRZ	T2,UNISTT(U)	;(NO. OF BITS INTO WORD) +
	SUB	T2,P1		;
	MOVNS	T2		;
	PUSH	P,T3		;
	IDIVI	T2,STTLEN	;(NO. OF SAT *
	IMULI	T2,400*^D36	;NO. OF PAGES
	POP	P,T3		;
	ADDI	T4,(T2)		;PER SAT.).
	SETZ	T2,		;BUILD THE
	DPB	T4,RBYPNO	;DISK
	LDB	T4,UNYLUN	;PNTR
	DPB	T4,RBYUNI	;AND
	TLO	T2,RBREAL	;
	PUSH	P,T2		;SAVE IT.

      ;NOW FIND ALL THE CONTIGUOUS PAGES WE CAN/WANT, AND
      ;MARK THEM TAKEN.
	MOVE	T2,(T1)		;T2/ SAT WORD AGAIN.
	HRLZI	T4,400000	;BUILD THE
	MOVNS	T3		;MASK IN
	LSH	T4,(T3)		;T4.
	MOVEM	T1,STTAOB(P1)	;SAVE THE AOBJN POINTER.
	SETZ	T1,		;T1/ # OF FREE PAGES.
	ADDI	T3,^D36		;T3/ MAX NO.
	CAMLE	T3,P2		;OF BITS TO LOOK
	MOVE	T3,P2		;AT IN THIS WORD.
SATSR5:	TDZN	T2,T4		;NEXT PAGE IS FREE?
	JRST	SATSR8		;NO, DONE.
	ADDI	T1,1		;YES, COUNT IT.
	LSH	T4,-1		;ADJUST THE MASK.
	SOJG	T3,SATSR5	;CONTINUE IN THIS WORD.
	CAML	T1,P2		;NEED MORE?
	JRST	SATSR8		;NO.
	MOVE	T3,STTAOB(P1)	;YES, TRY TO GET
	AOBJN	T3,.+2		;NEXT WORD.  IS THERE ONE?
	JRST	SATSR8		;NO.  DONE.
	MOVEM	T2,-1(T3)	;YES.
	SKIPN	T2,(T3)		; ANY FREE PAGES IN IT?
	JRST	SATSR9		;NO.  DONE.
	MOVEM	T3,STTAOB(P1)	;YES.  SAVE AOBJN PNTR.
	HRLZI	T4,400000	;SET UP MASK FOR NEW WORD.
	MOVE	T3,P2		;SET UP T3 TO
	SUB	T3,T1		;MAX. NO. OF
	CAILE	T3,^D36		;BITS TO LOOK AT
	MOVEI	T3,^D36		;IN THIS WORD.
	JRST	SATSR5		;GO LOOK AT THIS WORD.
    ;HERE ON DONE.
SATSR8:	MOVE	T3,STTAOB(P1)	;
	MOVEM	T2,(T3)		;
SATSR9:	MOVE	T3,STTFPC(P1)	;ADJUST THE
	SUB	T3,T1		;FREE PAGE
	MOVEM	T3,STTFPC(P1)	;COUNT.
	POP	P,T2		;RESTORE T2/ DISK POINTER.
	JRST	CPOPJ1

COMMENT #
@@SUBROUTINE OGETPG
@@PURPOSE
SUBR TO GET ONE PAGE ON THE DISK.
@@ENTRY
EXPECTS F/ DDB AND U/ UNIT DB.
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@CALLS
SATSRH AND GETSAT.
@@EXIT
NON-SKIP RETURNS IF NO PAGE AVAILABLE, ELSE SKIP
RETURNS WITH T2/ DISK PNTR TO THE PAGE.
@@ #

OGETPG:	PUSH	P,P1		;SAVE P1 AND
	PUSH	P,P2		;P2.
	MOVEI	P2,1		;TELL SATSRH WE WANT ONE PAGE.
	HRRZ	P1,UNISTT(U)	;P1/ STT ENTRY ADDR.
OGETP2:	SKIPE	T2,STTPTR(P1)	;AT END OF STT?
	JRST	OGETP3
	POP	P,P2
	POP	P,P1
	MSGLIV	OGTPG
OGETP3:	SKIPE	STTFPC(P1)	;NO.  ANY FREE PAGES IN THIS SAT?
	JRST	OGETP4		;YES.
	ADDI	P1,STTLEN	;NO, CONTINUE.
	JRST	OGETP2		;

OGETP4:	PUSHJ	P,GETSAT	;
	JRST	OGETP5
	PUSHJ	P,SATSRH	;GET T2/ DISK PNTR TO 1ST FREE PAGE.
	JRST	OGETP5
	POP	P,P2		;RESTORE P2 AND
	POP	P,P1		;P1.
	JRST	CPOPJ1

OGETP5:	POP	P,P2
	POP	P,P1
	POPJ	P,




COMMENT #
@@SUBROUTINE CNDSWT
@@PURPOSE
SUBR TO CONDITIONALLY WRITE OUT A SAT IN CORE.
@@ACCUM
DESTROYS U, PG,
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE, NON-SKIP RETURNS.
@@ #

CNDSWT:	SKIPN	T2,SATDSK	;IS THERE A SAT IN %STA?
	JRST	CPOPJ1		;NO, NO NEED TO DO ANYTHING.
	LDB	T4,RBYPNO	;YES,
	LDB	U,RBYUNI	;WRITE
	MOVE	U,UNTTBL(U)	;IT
	MOVEI	PG,%STA.P	;OUT.
	PUSHJ	P,OPAGOT	;
	MSGLIV	IOFAL
	SETZM	SATDSK		;MARK NO SAT IN CORE.
	JRST	CPOPJ1		;SUCCESS RETURN.




COMMENT #
@@SUBROUTINE GETSAT
@@PURPOSE
SUBR TO GET A SAT INTO CORE, POSSIBLY WRITING OUT
A SAT FIRST.
@@ENTRY
EXPECTS T2/ DISK ADDRESS OF DESIRED SAT, U/ UNIT DB, AND
F/ DDB.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE, NON-SKIP RETURNS.
@@ #

GETSAT:	CAMN	T2,SATDSK	;ALREADY HAVE THIS SAT IN CORE?
	JRST	CPOPJ1		;YES.  JUST TAKE SUCCESS RETURN.
	MOVEI	PG,%STA.P	;NO, IS THERE
	EXCH	T2,SATDSK	;A SAT
	JUMPE	T2,GTSAT6	;IN CORE?
	LDB	T4,RBYPNO	;YES.  WRITE IT
	PUSH	P,U		;
	LDB	U,RBYUNI	;
	MOVE	U,UNTTBL(U)	;
	PUSHJ	P,OPAGOT	;OUT.
	PUSHJ	P,[POP P,T2	;
		EXCH T2,(P)	;
		MSGLIV 	IOFAL]
	POP	P,U		;
GTSAT6:	MOVE	T2,SATDSK	;HERE TO READ OUR SAT
	LDB	T4,RBYPNO	;INTO CORE.
	PUSHJ	P,OPAGIN	;
	MSGLIV	IOFAL
	JRST	CPOPJ1		;

COMMENT #
@@SUBROUTINE SATRBS/HOMRBS
@@PURPOSE
VARIOUS SUBRS TO STORE A RETRIEVAL POINTER AND INC RIBALP.
@@ENTRY
EXPECTS T2/ RETRIEVAL POINTER TO STORE AND XXXRBP TO BE
AN AOBJN POINTER.
@@ACCUM
DESTROYS T1.
@@EXIT
STOPCDS IF AOBJN POINTER RUNS OUT.
ELSE RETURNS WITH NEW AOBJN POINTER STORED AND RIBALC
ADJUSTED.
@@ #

SATRBS:	MOVE	T1,SATRBP
	AOBJN	T1,SATRS1
	MSGSFE	RBNOUT
SATRS1:	MOVEM	T1,SATRBP
	PUSHJ	P,SAVT		;SAVE T2,T3,T4
	MOVEI	T3,%STR
	JRST	HOMRS2


HOMRBS:	MOVE	T1,HOMRBP
	AOBJN	T1,HOMRS1
	MSGSFE	RBNOUT
HOMRS1:	MOVEM	T1,HOMRBP
	PUSHJ	P,SAVT
	MOVEI	T3,%HMR
HOMRS2:	MOVEM	T2,(T1)
	AOS	RIBALP(T3)	;COUNT NO. OF PAGES IN THIS FILE.
	POPJ	P,



SATRBP:	Z	;PNTR TO SPACE IN SAT.SYS RIB FOR RETRIEVAL PNTRS.
HOMRBP:	Z	;  "              HOM.SYS        "
TMPRBP:	Z	;  "              XXXXXX        "

COMMENT #
@@SUBROUTINE CLUAOB/CLSAOB
@@PURPOSE
SUBRS TO CLEAR OUT THE STTAOB ENTRIES FOR A UNIT (CLUAOB)
OR FOR ALL UNITS IN A STR (CLSAOB).
@@ENTRY
CLUAOB EXPECTS UNIT DB ADDR IN REFUNI.  CLSAOB EXPECTS
DB ADDB OF FIRST UNIT ON THE STR IN FTSUNI.
@@ACCUM
DESTROYS U AND T1.
@@ #

CLUAOB:	MOVE	U,REFUNI
CLUAB1:	HRRZ	T1,UNISTT(U)	;
CLUAB2:	SKIPN	STTPTR(T1)	;
	POPJ	P,
	SETZM	STTAOB(T1)	;
	ADDI	T1,STTLEN
	JRST	CLUAB2		;

CLSAOB:	MOVE	U,FSTUNI	;
	PUSHJ	P,CLUAB1	;
	HLRZ	U,UNISTR(U)	;
	JUMPN	U,.-2		;
	POPJ	P,


COMMENT #
@@SUBROUTINE TMPIN/TMPOUT
@@PURPOSE
LITTLE SUBRS TO SET UP ARGS AND CALL OPAGIN/OT FOR IO TO/FROM
%TMP.
@@ENTRY
EXPECT T2/ DISK POINTER OF PAGE TO BE TRANSFERRED.
@@CALLS
OPAGIN AND OPAGOT.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURN IFF OPAGOT/IN DO.  ELSE NON-SKIP RETURN.
@@ #

TMPIN:	MOVEI	T3,OPAGIN	;
	JRST	.+2
TMPOUT:	MOVEI	T3,OPAGOT	;
	LDB	T4,RBYPNO	;GET PAGE NO. FROM T2.
	LDB	U,RBYUNI	;GET UNIT DB
	MOVE	U,UNTTBL(U)	;ADDR FROM T2 AND UNTTBL.
	MOVEI	PG,%TMP.P	;IO TO/FROM %TMP.
	PUSHJ	P,(T3)		;READ OR WRITE THE PAGE.
	MSGLIV	IOFAL
	JRST	CPOPJ1		;WON.

COMMENT #
@@SUBROUTINE PTREXT
@@PURPOSE
SUBR TO STORE A RETRIEVAL POINTER IN %TMP ACCORDING TO
TMPRBP, TAKING INTO ACCOUNT AN EXTENDED RIB STRUCTURE.
(THIS REALLY DOESN'T NEED THREE LEVELS; ALSO PERHAPS THE
OGETPG CALLS SHOULD LOOK AT MORE THAN ONE UNIT.).
@@ENTRY
EXPECTS TMPRBP AND THE RIB IN %TMP TO BE SET UP, T2/ THE
RETRIEVAL POINTER TO BE STORED, AND F/ DDB.
@@CALLS
RIBEX1, RIBEX2, RIBEX3, RIBEX4, OGETPG, TMPOUT, TMPIN, CORZER,
AND MOROOM.
@@ACCUM
DESTROYS T1, T3, T4, AND PG.
PRESERVES U.
@@EXIT
IF ERROR, NON-SKIP RETURNS, ELSE SKIP RETURNS.
ON EXIT, THE RIB IN %TMP MAY NOT BE THE RIB THAT WAS THERE
ON ENTRY.  ON SUCCESSFUL EXIT, TMPRBP WILL BE SET UP PROPERLY
AND PGSRIB IS INCREMENTED FOR EACH ADDITIONAL RIB GENERATED.
@@ #

PTREXT:	MOVE	T1,TMPRBP	;GET THE AOBJN PNTR TO THE
	AOBJN	T1,PTROT2	;RETRIEVAL PNTR STORAGE AREA.
	PUSH	P,U		;PRESERVE U.
	JRST	PTREX1		;OUT OF ROOM.

PTROU0:	POP	P,P2		;
	POP	P,P1
PTROUT:	POP	P,T2		;RESTORE THE RETRIEVAL POINTER.
	POP	P,U		;RESTORE U.
PTROT2:	MOVEM	T1,TMPRBP	;STORE THE AOBJN
	MOVEM	T2,(T1)		;PNTR & RETRIEVAL PNTR.
	JRST	CPOPJ1

    ;HERE WHEN WE MUST GET ANOTHER RIB.
PTREX1:	PUSH	P,T2		;SAVE RET PNTR WE WANT TO STORE.
	SKIPE	T2,%TMP+RIBSLF	;GET A DISK PAGE TO WRITE US
	JRST	PTREX2		;OUT TO, UNLESS
	PUSHJ	P,OGETPG	;WE HAVE
	JRST	PTRFAL		;ONE
	MOVEM	T2,%TMP+RIBSLF	;ALREADY.
PTREX2:	MOVE	T1,%TMP+RIBSZS	;IF NOT AT LOWEST LEVEL
	SOJG	T1,PTREX3	;AND EO RIB WITH REAL PNTR,
	SKIPN	%TMP+RIBRIB	;OR IF ONLY ONE RIB, WE
	JRST	PTREX3		;HAVE TO EXPAND.

    ;HERE WHEN WE ARE AT LOWEST LEVEL AND THERE IS A HIGHER RIB.
      ;WE MAY OR MAY NOT HAVE TO EXPAND.
	PUSH	P,%TMP+RIBRPS	;SAVE OUR POSITION FOR MOROOM.
	PUSHJ	P,TMPOUT	;(WE HAVE ALREADY SET UP T2), SO
	JRST	PTRFL1		;WRITE US OUT.
	MOVE	T2,%TMP+RIBRIB	;READ IN THE
	PUSHJ	P,TMPIN		;HIGHER RIB.
	JRST	PTRFL1
	POP	P,T1		;RESTORE OUR POINTER.
	PUSHJ	P,MOROOM	;ROOM FOR ANY MORE PNTRS IN IT?
	JRST	PTROUT		;YES.
	SKIPN	T2,%TMP+RIBRIB	;NO. IF THIS IS THE HIGHEST,
	JRST	PTREX3		;GO EXPAND.
	PUSH	P,%TMP+RIBRPS	;SAVE OUR POSITION FOR MOROOM.
	PUSHJ	P,TMPIN		;READ IN THE HIGHER
	JRST	PTRFL1		;RIB.
	POP	P,T1		;RESTORE OUR POSITION.
	PUSHJ	P,MOROOM	;ROOM FOR ANY MORE PNTRS?
	JRST	PTROUT		;YES.
	MSGSFE	RBEOUT

    ;HERE TO EXPAND THE RIB STRUCTURE.
PTREX3:	MOVEI	T1,%T2P		;CLEAR OUT A SPARE RIB
	PUSHJ	P,CORZER	;IN %T2P.
	AOS	PGSRIB		;COUNT IT.
	PUSHJ	P,OGETPG	;GET A PAGE
	JRST	PTRFAL		;FOR
	MOVEM	T2,%T2P+RIBSLF	;IT.
	MOVEI	T1,CODRIB	;SET ITS
	MOVEM	T1,%T2P+RIBCOD	;RIBCOD.
	PUSH	P,P1		;SET UP THE
	PUSH	P,P2		;ARGS
	MOVEI	P1,%TMP		;FOR
	MOVEI	P2,%T2P		;THE RIBEX? SUBRS.
	MOVE	T1,%TMP+RIBLST	;JUMP UNLESS LAST PNTR IN OUR
	JUMPGE	T1,PTREX4	;SOURCE RIB IS A SPARE RIB PNTR.

    ;HERE TO EXPAND FROM TWO LEVELS TO THREE.
	PUSHJ	P,RIBEX1	;SET UP INFO IN BOTH RIBS.
	MOVEI	T4,RIBSFS+RBLVPR-1 ;
	JRST	PTRE45		;


    ;HERE ON ALL RIB EXPANSION EXCEPT FROM TWO LEVELS TO THREE.
PTREX4:	PUSHJ	P,RIBEX2	;SET UP INFO IN BOTH RIBS.
	JRST	PTRE45		;NEED NO INTERMED RIB.
	PUSH	P,T4		;NEED INTERMED RIB.  SAVE RPS.
	PUSHJ	P,OGETPG	;
	JRST	PTRFL2
	AOS	PGSRIB		;COUNT THE INTERMEDIATE RIB.
	PUSHJ	P,RIBEX3	;LINK IT IN.
	MOVE	T2,%TMP+RIBSLF	;
	PUSHJ	P,TMPOUT	;WRITE OUT THE
	JRST	PTRFL2		;HIGHEST RIB.
	MOVEI	T1,%TMP		;CLEAR SPACE FOR THE
	PUSHJ	P,CORZER	;INTERMEDIATE RIB.
	JSP	T4,RIBEX4	;SET UP MORE STUFF.
	POP	P,T4		;RESTORE RPS.


PTRE45:	HRLZI	P1,-RIBLST(T4)	;SET UP THE AOBJN PNTR
	HRRI	P1,%TMP+1(T4)	;FOR PTROU0.
	MOVE	T2,%TMP+RIBSLF	;WRITE OUT
	PUSHJ	P,TMPOUT	;A RIB.
	JRST	PTRFL0
	MOVE	T1,[XWD %T2P,%TMP] ;COPY THE NEW RIB TO
	BLT	T1,%TMP+777	;THE CURRENT RIB AREA.
	MOVE	T1,P1		;GET AOBJN PNTR FOR PTROUT.
	JRST	PTROU0		;


PTRFL2:	POP	P,T1		;VARIOUS
PTRFL0:	POP	P,P2
	POP	P,P1		;ERROR
	JRST	PTRFAL

PTRFL1:	POP	P,T1		;EXITS.
PTRFAL:	POP	P,T2
	POP	P,U
	POPJ	P,

COMMENT #
@@SUBROUTINE MOROOM
@@PURPOSE
LITTLE SUBR TO SEE IF THERE IS ANY MORE ROOM IN A RIB IN
%TMP TO STORE POINTERS.
@@ENTRY
EXPECTS T1/RIBRPS FROM LOWER RIB.
@@ACCUM
DESTROYS T1 AND T2.
@@EXIT
SKIP RETURNS IF NO MORE ROOM.  NON-SKIP RETURNS IF THERE IS
MORE ROOM, WITH T1/ AOBJN POINTER TO ROOM.
@@ #

MOROOM:	ADDI	T1,%TMP+1	;GET ADDR OF NEXT POINTER.
	CAILE	T1,%TMP+RIBLST	;PAST E O RIB?
	JRST	CPOPJ1		;YES, RETURN.
	MOVEI	T2,(T1)		;NO.  MAKE THE USED AOBJN
	SUBI	T2,%TMP+RIBLST	;PNTR IN T1,
	HRLI	T1,-1(T2)	;AND TAKE THE
	POPJ	P,		;SUCCESSFUL RETURN.

COMMENT #
@@SUBROUTINE GETPRM
@@PURPOSE
SUBR TO WRITE OUT THE RIB IN CORE IN %TMP AND THEN GET
ITS PRIME RIB INTO %TMP.
@@CALLS
TMPIN AND TMPOUT.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

GETPRM:	SKIPN	%TMP+RIBRIB	;
	JRST	CPOPJ1		;
	MOVEI	P1,2		;CHECK FOR 3 LEVELS.
GETPR4:	PUSH	P,%TMP+RIBRIB	;SAVE ADDR OF HIGHER RIB.
	SKIPE	T2,%TMP+RIBSLF	;IF NECESSARY, GET
	JRST	.+3		;
	PUSHJ	P,OGETPG	;A PAGE FOR THE
	JRST	[POP P,T1
		POPJ P,]
	MOVEM	T2,%TMP+RIBSLF	;CURRENT RIB.
	PUSHJ	P,TMPOUT	;
	JRST	[POP P,T1
		POPJ P,]
	POP	P,T2		;READ IN THE
	PUSHJ	P,TMPIN		;HIGHER RIB.
	POPJ	P,
	SKIPN	%TMP+RIBRIB	;DONE?
	JRST	CPOPJ1		;YES
	SOJG	P1,GETPR4	;NO, DON'T DO MORE THAN 3 LEVELS.
	MSGSFE	RIBFAL

COMMENT #
@@SUBROUTINE RIBSET
@@PURPOSE
SUBR TO SET UP PRIME RIB INFORMATION IN A SPECIFIED AREA IN CORE.
@@ENTRY
EXPECTS:
	T1=NAME OF FILE
	T2=EXT
	T3=PPN
	T4=ADDR OF CORE AREA TO BE SET UP.
	P4=BITS TO SET IN STATUS WORD
CURPRT/ BITS FOR RIYPRV.
STNVER/ STANDARD VERSION NO.
@@ACCUM
DESTROYS T1 AND T2.
@@CALLS
CORZER.
@@ #

RIBSET:	PUSH	P,T1		;SAVE T1 AND
	PUSH	P,T2		;T2 FROM CORZER.
	MOVE	T1,T4		;ARG FOR CORZER.
	PUSHJ	P,CORZER	;CLEAR OUT THE RIB AREA.
	POP	P,T2		;RESTORE T2 AND
	POP	P,T1		;T1.
	MOVEM	T1,RIBNAM(T4)
	HRRI	T2,0		;SET ACCESS DATE.
	MOVEM	T2,RIBEXT(T4)
	MOVEM	T3,RIBPPN(T4)
	MOVE	T3,CURPRT	;
	HRLZM	T3,RIBPRV(T4)	;
	MOVE	T3,STNVER	;STANDARD VERSION NUMBER
	MOVEM	T3,RIBVER(T4)
	MOVEI	T3,1		;
	MOVEM	T3,RIBSZS(T4)	;
	MOVEI	T3,CODRIB	;UNLIKELY CODE
	MOVEM	T3,RIBCOD(T4)	;FOR RIB.
	MOVEM	P4,RIBSTS(T4)	;
	TRNN	P4,RIPDIR	;UFD  OR MFD?
	POPJ	P,		;NO, RETURN.

    ;HERE ONLY FOR MFD OR UFDS.
	MOVE	T3,QUOTAF	;YES, SET FCFS
	MOVEM	T3,RIBQTF(T4)	;AND
	MOVE	T3,QUOTAO	;LOGGED OUT
	MOVEM	T3,RIBQTO(T4)	;QUOTAS.
	MOVE	T2,[SIXBIT /UFD/] ;SET UP
	CAMN	T1,MFDUFD	;RIBUNM
	JRST	RIBST8		;WITH
	MOVE	T2,[SIXBIT /SYS/] ;THE
	CAMN	T1,SYSUFD	;APPROPRIATE
	JRST	RIBST8		;
	MOVE	T2,[SIXBIT /ING/] ;MFD OR UFD
	MOVEM	T2,RIBUN1(T4)	;
	MOVE	T2,[SIXBIT /SPOOL/] ;
RIBST8:	MOVEM	T2,RIBUNM(T4)	;NAME.
	POPJ	P,

CURPRT:	Z	;STORAGE FOR RIBSET.

COMMENT #
@@SUBROUTINE CNVSIZ/CNVSZM
@@PURPOSE
LITTLE SUBRS TO SET RIBSIZ.
@@ENTRY
EXPECTS T1/ ADDR OF RIB IN CORE.
@@ACCUM
DESTROYS T2.
@@ #

CNVSZM:	SOSA	T2,RIBALP(T1)	;ADJUST ALP FOR STORING EOF LATER.
CNVSIZ:	MOVE	T2,RIBALP(T1)	;
	IMULI	T2,1000		;
	MOVEM	T2,RIBSIZ(T1)	;
	POPJ	P,

;NAMES OF FILES WE CREATE
FSTFL:
SATFNM:	SIXBIT	.SAT.		;SAT FILE.
HOMFNM:	SIXBIT	.HOME.		;FILE OF HOME, BAT, AND BOOTS.
PAKFIL==.-FSTFL
	BLOCK	1		;Place holder for obsolete entry
CRSFNM:	SIXBIT	.CRASH.		;FILE FOR SAVING MONITOR CRASHES.
LSTFL==.-FSTFL
SYSUFD:	BLOCK	1
PRTUFD:	BLOCK	1
MFDUFD:	BLOCK	1
LSTUF==.-LSTFL-FSTFL


;*** THE FOLLOWING LISTS MUST BE IN THE SAME ORDER AS FILE NAMES.

;LOGICAL PAGE NOS.(REALLY RETRIEVAL PNTRS FOR UNIT 0) OF PRIME RIBS.
;*** This table MUST be identical to the home page, no variations
FSTPG:
SATRBD:	BLOCK	1		;LOGICAL PAGE NO. OF PRIME RIB FOR HOME.SYS.
HOMRBD:	BLOCK	1		;LOGICAL PAGE NO. OF PRIME RIB FOR HOME.SYS.
	BLOCK	1		;Place holder for obsolete entry.
CRSRBD:	BLOCK	1		;LOGICAL PAGE NO. OF PRIME RIB FOR CRASH.SAV.
SYSRBD:	BLOCK	1		;LOGICAL PAGE NO. OF PRIME RIB FOR SYS (1,4) UFD.
PRTRBD:	BLOCK	1		;LOGICAL PAGE NO. OF PRIME RIB FOR PRINT UFD.
MFDRBD:	BLOCK	1		;LOGICAL PAGE NO. OF PRIME RIB FOR MFD (1,1 UFD).
LSTPGL==.-FSTPG


FSTCTL:
SATCTL:	XWD %STR,%STR.P
HOMCTL: XWD %HMR,%HMR.P


;BITS SET IN RIYPRV FOR EACH FILE.
FSTPRT:
SATPRT:	BLOCK 1
HOMPRT:	BLOCK 1
	BLOCK	1		;Place holder for obsolete entry.
CRSPRT:	BLOCK 1
SYSPRT:	BLOCK 1
PRTPRT:	BLOCK 1
MFDPRT:	BLOCK 1


;NO. OF PAGES (INCLUDING RIBS) WRITTEN IN EACH FILE.
FSTALP:
SATALP:	BLOCK 1
HOMALP:	BLOCK 1
	BLOCK	1		;Place holder for obsolete entry.
CRSALP:	BLOCK 1
SYSALP:	BLOCK 1
PRTALP:	BLOCK 1
MFDALP:	BLOCK 1
LSTALP==.-FSTALP




;MISC. LOCATIONS.

RANNO:	BLOCK	1	;Holder for RANDOM # for REFRESH
UFDSTP:	BLOCK	1	;PNTR TO SPACE IN UFD RIB FOR PNTRS.

BEGSAT:	BLOCK	1
SVSBTL:	BLOCK	1
LPGSAT:	BLOCK	1	;LAST CLUSTER IN CURRENT SAT.

FSTUNI:	BLOCK	1	;ADDR OF FIRST UNIT IN STR.

SATIND:	BLOCK 1		;USED AS A TEMPORARY.

SATDSK:	Z		;FLAG TO PREVENT UNNECESSARY IO ON SAT
			;PAGES.

PGSRIB:	Z		;USED BY RBNFIL, ETC. TO KEEP TRACK OF COUNT OF
			;RIBS AND MAYBE OF PAGES.

	LIT
	VAR


REFLNR=.-%REF+1
REFLNP=<REFLNR!777>+1

ONSZCK(REFSTR,REF)	;CHECK TO SEE IF ENOUGH PAGES ALLOCATED

DEPHASE

	END
@æ