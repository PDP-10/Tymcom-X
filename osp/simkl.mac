TITLE SIMKL MODULE TO ALLOW USER MODE DEBUG OF ONCE CODE
SUBTTL E. SOCCI 3/13/79

IFCPU (KL),<

	Entry	KL$SIM
KL$SIM:	Z

>	; End IFCPU (KL)

REPEAT 0,<	;; KL-Simulator module commented OUT
		;; If for any reason, it is wanted for a particular
		;; system - then add a configuration symbol which
		;; will turn the code "ON" and re-assemble at that
		;; time.  /CARL  24-Mar-83

DEFINE ERROR(MSG)<JRST [MESS([SIMKL:'MSG])
		MOVEM T1,ERRPC
		MOVEI T1,.-1
		EXCH T1,ERRPC
		JRST DDT##]>;END ERROR MACRO DEFINITION
DEFINE MESS(MSG)<OUTSTR [ASCIZ\'MSG\]>
DEFINE MESSCR(MSG)<OUTSTR [ASCIZ\'MSG
\]>

	CCA==14

;I/O CHANNELS

PHY==1		;PHYSICAL CORE FILE
DAT==2
IDX==3

;CHANIO DEFINITIONS

.CHMAP==35
.CHCFP==40

;ERROR RETURNS

FALHOL==15
FALPHP==6

;INTENB CODES

.IAUUO==(0B17)
.IAILM==(2B17)
.IATIM==(4B17)

;TINASS CODES
.IACHR==(1B8)

;JACCT2 DEFINITION

JACCT2==1B20
.GTSTS==0

.AXI8S==1
.AXSI==33

OPDEF SXCT [UJEN]		;OPCODE TO REPLACE XCT AC, BY

PC.FPD==(1B4)			;FIRST PART DONE.
EXTERNAL UPT			;USE THIS FOR PEEKING AT UPTS, ITS ON PAGE BOUNDARY.
;GET ALL LITERALS FROM PREVIOUS CODE PUT HERE BEFORE THE MONDEB
; LABEL SO MONDEB AND MONDBE ENCOMPASS ONLY MONITOR SIMULATOR
	LIT
	VAR

;FROM UUOCON.MAC.
DEFINE CNAMES <
	X PGRSTS,UPRSTS		; (-133) GET REF BIT FAULT INFO
	X PGISTS,UPISTS		; (-132) GET ILL MEM REF/ADDR BREAK FAULT INFO
	X SETABK,ABKUUO		; (-131) SET ADDRESS BREAK
	X LOGOFF,LOGOFF		; (-130) RUN ALT. LOGOUT PROGRAM
	X SETALP,SETALP		; (-127) SET ALT. LOGOUT PROGRAM
	X SETOTF,OTFSET		; (-126) SET "OTHER" FRAME UUO FOR VUUOS
	X CONT,CONTUU		; (-125) PUT TERMINAL IN USER MODE
	X PUTROY,PUTROY		; (-124) PUT ROYALTY STREAM RECORD
	X BLTPAG,BLTPAG		; (-123) BLT DATA TO A LOCKED PAGE
	X PIDSET,SETPID		; (-122) SET PROGRAM'S PID
	X FOO,CPOPJ		; (-121) DEFUNCT GET PAGE FAULT WORD UUO
	X BITPOK,BITPOK		; (-120) POKE WITH MASK
	X RDHIST,RDHIST		; (-117) READ SNOOP HISTOGRAM
	X SNOOPU,SNOOPU		; (-116) START/STOP SNOOP HISTOGRAM
	X POLPRT,POLPRT		; (-115) POLL PORTS
	X CLBADD,UCBADD		; (-114) ADD SELF TO CLUB.
	X CLBLEV,UCBLEV		; (-113) REMOVE SELF FROM CLUB.
	X CLBINW,UCBINW		; (-112) GET CLB INTRLK (WAIT).
	X CLBINI,UCBINI		; (-111) GET CLB INTRLK (IMMED).
	X CLBRLI,UCBRLI		; (-110) RELEASE CLB INTRLK.
	X CLBMEM,UCBMEM		; (-107) GET INFO ABOUT CLB MBR.
	X CLBSTS,UCBSTS		; (-106) GET STATUS OF CLB MBR.
	X CLBWAK,UCBWAK		; (-105) WAKE JOB IN SAME CLB.
	X CLBHNG,UCBHNG		; (-104) HANG JOB IN SAME CLUB.
	X VPGFIL,VPGFIL		;(-103) GET FILENAME ETC FOR VP
	X VDSKPT,UVDSKP		;(-102) GET DISK POINTER FOR VP
	X PGFSTS,UPFSTS		;(-101) GET AND CLEAR PAGE FAULT STATUS
	X PERSTS,UPESTS		;(-100) GET AND CLEAR PAGE ERROR STATUS
	X VFSTAT,VFLCKU		;(-77) SEE IF THE F BIT IS ON.
	X VALPAG,UVALID		;(-76) VALIDATE AND WAIT
	X PREREF,UPRERF		;(-75) PRE REFERENCE A VIRTUAL PAGE
	X WSCTL,UWSCTL		;(-74) WORKING SET CONTROL
	X REFBIT,URFBIT		;(-73) REFERENCE BIT CONTROL
	X PERSET,UPESET		;(-72) SET/CLEAR IGNORE ERROR BIT
	X VPGSTS,UPGSTS		; (-71) GET PAGE STATUS
	X VPROT,UPROT		; (-70) SET VM PAGE PROTECTION
	X VCREAT,UCREAT		; (-67) CREATE PRIVATE VM PAGE
	X VCLEAR,VCLEAU		; (-66) CLEAR VM PAGE.
	X VREMOV,VREMOU		; (-65) REMOVE VM PAGE.
	X VREPLC,VREPLU		; (-64) REPLICATE VM PAGE.
	X LSAUUO,LSAUUO		;- (-63) GENERATE LOCAL STR ACCTG REC
	X PUTSAR,PUTSAR		;- (-62) PUT STREAM ACCT'G RECORD
	X CHPJC,CHPJC		;- (-61) CHANGE PROJ CODE
	X XCHARG,XCHARG	;(-60) SAVE (ETC) CHARGING
	X RECMFL,RECMFL		;(-57)DEFINE RESTRICTED COMMAND FILE AND PPN
	X SOAKEM,SOAKEM		;(-56) ADD TRU CHARGES
	X DATUUO,DATUUO		;(-55) CONVERT DATES AND TIMES
	X DDT620,DDT620		;(-54) INTERROGATE REMOTE 620
	X VALRMT,VALRMT		;(-53) VALIDATE REMOTE PASSWORD
	X INTRMT,INTRMT		;(-52) SET REMOTE INTERRUPTS
	X IDLRMT,IDLRMT		;(-51) SET REMOTE IDLE
	X ZAPRMT,ZAPRMT		;(-50) ZAP REMOTE
	X CRERMT,CRERMT		;(-47) CREATE REMOTE PORT
	X AUXRED,AUXRED		;(-46) READ AUX CIRCUIT INFO
	X ZAPCIR,ZAPCIR		;(-45) ZAP AUX CIR
	X CREAUX,CREAUX		;(-44) CREATE AUX CIR
	X REDPIP,REDPIP		;(-43) READ PI IN PROGRESS BITS
	X TINASS,TINASS		;(-42) ASSIGN TTY INTERRUPTS
	X SETTR2,SETTR2		;(-41) SET TRAP 2 INSTR (PDLOV)
	X SETTR1,SETTR1		;(-40) SET TRAP 1 INSTR (OVERFLOW)
	X SETTIM,SETTIM		;(-37) SET INTERRUPT TIMER
	X INTASS,INTASS		;(-36) ASSIGN APR INTERRUPTS
	X INTACT,INTACT		;(-35) CAUSE PSEUDO INTERRUPT
	X INTENB,INTENB		;(-34) ENABLE INTERUTP CHANNELS
	X INTADR,INTADR		;(-33) TURN ON NEW INTERRUPT SYSTEM
SIXSTP==-1
	X HANG,HNGUUO		;(-32) HANG A JOB
	X CHKLIC,CHKLIC		;(-31) CHECK SETTABLE LICENSE
	X LEVDEF,LEVDEF		;(-30) LEAVE DEFERED ECHO MODE
	X MOVBUF,MOVBUF		;(-27) MOVE I/O BUFFER
	X SETMOD,SETMOD		;(-26) SET TTY MODE (SETSTS BUT NO INIT)
	X RUNSEG,URUNHI		;(-25) RUN A HIGH SEG
	X SYSDVF,SYSDVF		;(-24) GET DEVICE INFO
	X DISMIS,DISMIS		;(-23) DISMAISS TRAP
	X DSKCLR,DSKCLR		;(-22) CLEAR DSK CORE INFO
	X SETJAL,SETJAL		;(-21) SET JACCT, LOGIN
	X ONEJOB,ONEJOB		;(-20) SEE IF ONLY JOB ON SYSTEM
	X SETMAL,SETMAL		;(-17) SET MAIL WAITING
	X GETTMC,GETTMC		;(-16) GET TERM CHRS
	X SETTMC,UUOMNR	;(-15) SET TERM CHRS
	X REDNXT,REDNXT		;(-14) READ NEXT CHR
	X WAITCH,WAITCH		;(-13) WAIT FOR CHARACTER
	X POKE,POKE		;(-12) POKE M
	X SETPRV,SETPRV		;(-11) MOVING SETPRV HERE
	X SETLIC,SETLIC		;(-10) SET JBTLIC
	X SETE,SETE		;(-7) SETE WITH SYS PASSWORD
	X ATTACH,ATTUUO		;(-6) ATTACH, DETACH M
	X UUOERR,UUOMNR		;(-5) PLACE FOR CUSTOMERS TO PATCH UUOS
	X UUOERR,UUOMNR		;(-4) 
	X UUOERR,UUOMNR		;(-3)SET BITS IN JBTPRV
	X 6WDBLK,UUOMNR		;(-2) FOR COMPATABILITY
	X LIGHTS,LIGHTS		;(-1) SET LIGHTS (EXAMPLE OF CUSTOMER DEFINED M)
>

DEFINE NAMES,<
	X RESET,RESET		;(0)RESET IO
	X DDTIN,DDTIN		;(1)EXT-GET DDT CHAR.
	X SETDDT,SETDDT		;(2)SETDDT LOC IN PROTECTED JOB DATA
	X DDTOUT,DDTOUT		;(3)EXT:SEND DDT CHAR.
	X DEVCHR,DVCHR		;(4)DEVICE CHARACTISTICS
	X DDTGT,CPOPJ		;(5)GET DDT MODE
	X GETCHR,DVCHR		;(6)DEVICE CHAR.(DIFF. NAME)
	X DDTRL,CPOPJ		;(7)RELEASE DDT MODE
	X WAIT,WAIT		;(10)WAIT TILL DEVICE INACTIVE
	X CORE,CORUUO		;(11)CORE M
	X EXIT,EXIT		;(12)EXIT
	X UTPCLR,CPOPJ		;(13)CLEAR DEC TAPE DIRECTORY 
	X DATE,DATE		;(14)GET DATE
	X LOGIN,LOGIN		;(15)LOGIN
	X APRENB,APRENB		;(16)ENABLE APR FOR TRAPPING
	X LOGOUT,LOGOUT		;(17)LOGOUT
	X SWITCH,SWITCH		;(20)RETURN DATA SWITCHES
	X REASSIGN,REASSIGN	;(21)REASSIGN DEVICE TO ANOTHER JOB
	X TIMER,TIMER		;(22)RETURN JIFFY CLOCK TIME
	X MSTIME,MSTIME		;(23)RETURN TIME OF DAY IN MS
	X GETPPN,GETPPN		;(24)RETURN PROJECT-PROGRAMMER NUMBER
	X TRPSET,UTRPST		;(25)SET USER-IOT
	X TRPJEN,UUOMNR		;(26)DISMISS INTERRUPT TO EXEC MODE(SUPERCEDED BY UJEN)
	X RUNTIM,JOBTIM		;(27)RETURN TOTAL JOB RUNNING TIME
	X PJOB,JOBNO		;(30)RETURN JOB NUMBER
	X SLEEP,SLEEP		;(31)SLEEP FOR N SECONDS, THEN RETURN TO USER
	X SETPOV,SETPOV		;(32)SET PUSH DOWN OVERFLOW TRAP
				; (FOR COMPATIBILITY ONLY)
	X PEEK,UPEEK		;(33)TO PEEK AT CERTAIN MONITOR PARAMETERS
	X GETLIN,GETLN		;(34) GET TTY UNE NUMBER
	X RUN,URUN		;(35) RUN DEV:FILE
	X SETUWP,SETUWP		;(36) SET OR CLEAR USER MODE WRITE PROTECT
	X REMAP, REMAP		;(37) REMAP TOP OF LOW SEGMENT INTO HIGH SEG
	X GETSEG,UGTSEG		;(40) GET SHARABLE HIGH SEG
	X GETTAB,GETTAB		;(41) GET EXEC ADDRESS OF A JOB TABLE
	X FOO,CPOPJ		;(42) OBSOLETE SPY UUO
	X SETNAM,SETNAM		;(43) SETNAME OF THIS PROGRAM
	X TMPCOR,TMPUUO		;(44) TEMPORARY FILE STORAGE M (CCL)
	X DSKCHR,DSKCHR		;(45) DISK CHARACTERISTICS
	X SYSSTR,SYSTUU		;(46)RETURN NEXT STR IN SYSTEM
	X JOBSTR,JOBSTR		;(47) RETURN NEXT STR IN JOB
	X STRUUO,STRUUO		;(50) VARIOUS FUNCTION FOR STRS
	X SYSPHY,SYSPHY		;(51) RETURN ALL PHYSICAL DEVS AND UNITS IN SYSTEM
	X FRECHN,CPOPJ		;(52) RETURN 1ST FREE USER CHAN IN AC, STARTING FROM C(AC)
	X DEVTYP,CPOPJ		;(53) EXTENDED DEVICE CHARACTERISTICS AND BUFFER SIZE
	X DEVSTS,DEVSTA		;(54) DEVSTS
	X DEVPPN,DEVPPU		;(55) RETURN PPN FOR DEVICE
	X SEEK,UUOSK1		;(56) SEEK
	X RTTRP,CPOPJ		;(57) REAL TIME TRAP
	X LOCK,CPOPJ		;(60) LOCK JOB IN CORE
	X JOBSTS,CPOPJ		;(61) RETURN STATUS OF JOB AND ITS PTY
	X LOCATE,CPOPJ		;(62) FOR REMOTE COMM
	X WHERE,CPOPJ		;(63) FOR REMOTE COMM
	X DEVNAM,UDEVNM		;(64) GET PHYSICAL DEVICE NAME
	X CTLJOB,CPOPJ		;(65) FIND CONTROLLER OF THIS JOB (IF BY PTY)
	X GOBSTR,GOBSTR		;(66) GENERALIZED JOBSTR (ANY JOB'S SEARCH LIST)
	X FOO,CPOPJ		;(67) RESERVED
	X FOO,CPOPJ		;(70) RESERVED
	X HPQ,CPOPJ		;(71) SET HIGH PRIORITY QUE
	X HIBER,HIBER		;(72) HIBERNATE
	X WAKE,WAKUUO		;(73) WAKE SLEEPING JOB
	X CHGPPN,CHGPPN	;(74) CHANGE PPN
	X SETUUO,SETUUO		;(75) SET
	X DEVGEN,CPOPJ		;(76) GENERIC NUMBER
	X OTHUSR,CPOPJ		;(77) SEE IF OTHER USER
	X CHKACC,CPOPJ		;(100) SEE IF ACCESS ALLOWED
	X DEVSIZ,DVSIZU		;(101) BUFFER SIZE AND NUMBER
	X CPOPJ,CPOPJ		;2 SPARE M'S FOR PATCHING - DIGITAL ONLY
	X CPOPJ,CPOPJ		;ALWAYS ADD NEW M'S ABOVE THESE
				;CUSTOMERS SHOULD ADD M'S ABOVE
				;IN CNAMES MACRO RATHER THAN NAMES MACRO
				; SO THAT THEIR CALLI INDECES WILL
				; BE NEGATIVE
>

;GENERATE CALLI OPDEFS SO CAN USE THEM FROM EDDT IF OPEN SIMKL.

ZZ==0
DEFINE X(NAME,ADDR)<
ZZ==ZZ-1
>
	CNAMES			;;COUNT NEGATIVE CALLIS
DEFINE X(NAME,ADDR)<
IFDIF <NAME> <6WDBLK> <OPDEF NAME [CALLI ZZ]>
ZZ==ZZ+1>
	CNAMES			;;GENERATEOPDEFS
ZZ==0
	NAMES			;NOW GENERATE OPDEFS FOR DEC UUOS

COMMENT # SIMULATOR OPERATING INSTRUCTIONS

SETTING UP A MONITOR FOR SIMULATION
-----------------------------------

DO A GET COMMAND ON THE MONITOR TO BE DEBUGGED, WHICH HAS THE SIMULATOR
LOADED WITH IT.

ENTER DDT VIA THE DDT COMMAND.

INSTALL THE NECESSARY PATCHES TO RUN SIMULATOR BY TYPING "DEBPAT$G"

DO A 2^B TO ESTABLISH EDDT'S BREAKPOINTS, AND CTYSIM OPERATION.

(OPTIONAL) EXECUTE AN EXIT UUO (DDT DOES NOT RECOGNIZE THE CALLI
MNEMONICS, SO IT WILL BE NECESSARY TO TYPE "CALLI 12$X") AND SAVE
THE MONITOR. DO NOT SAVE IT SO THAT IT WILL BE ATTEMPTED TO BE
RUN AS A REAL MONITOR, SINCE THE SIMULATOR PATCHES WILL PREVENT
IT FROM DOING SO. (E.G., DON'T SAVE IT AS SYSTEM.SAV IN (SYS),
37X05.SAV IN M33, ETC.)

IF RUNNING A SAVED SIMULATOR MONITOR AS SAVED IN THE OPTIONAL STEP
ABOVE, GET THE SAVED MONITOR WITH A GET COMMAND AND ENTER DDT
VIA A DDT COMMAND.

SAY "MONDEB$G". THIS INITIALIZES THE SIMULATOR.

AT THIS POINT, THE SIMULATED MONITOR IS SUPPOSED TO LOOK EXACTLY
LIKE AN EXEC MODE MONITOR AFTER IT WAS LOADED FROM BOOTS WITH
A <MONITOR NAME>/L AND /141 /G.
SO, JUST START THE MONITOR UP WITH "140$G".


OPERATING A SIMULATED MONITOR
-----------------------------

THE SIMULATOR PROVIDES AN ENVIRONMENT FOR THE MONITOR WHICH
LOOKS LIKE KL10 HARDWARE WITH AN SA-10 CONNECTED TO IT, WITH
BP TYPE DISKS ON CHANNEL 1. THERE ARE THREE FILES THAT THE SIMULATOR
USES TO HELP PROVIDE THIS ENVIRONMENT. ONE OF THE FILES IS
PHYMEM.MAP, WHICH IS THE PHYSICAL MEMORY FOR THE SIMULATED SYSTEM.
PAGES FROM THIS FILE ARE MAPPED INTO THE SIMULATED EXEC VIRTUAL ADDRESS
SPACE WHEN THE EXEC MODE PROGRAM DOES A CLEAR PAGING MEMORY OPERATION.
THE FILES IDX.MAP AND DAT.MAP PROVIDE SIMULATED DISK PACK SPACE
FOR THE SIMULATED BP UNITS. IDX.MAP HAS TWO WORD ENTRIES, THE FIRST
ENTRY CONTAINING THE UNIT NUMBER AND PAGE WITHIN UNIT, AND THE SECOND
WORD CONTAINING THE PAGE IN THE DAT.MAP FILE IN WHICH THE DATA FOR
THAT UNIT/PAGE PAIR APPEARS.

AFTER BRINGING UP A SIMULATED MONITOR FOR THE FIRST TIME, IT
IS A GOOD IDEA TO DO AN EXIT UUO TO MAKE THESE FILES APPEAR
IN YOUR DIRECTORY. THEN, SUBSEQUENT SIMULATION RUNS WILL
USE THE OLD FILES, RESULTING IN LESS TIME WAITING FOR THE
SIMULATOR TO CREATE THE FILES, AND ALSO RESULTING IN
ELIMINATING THE NECESSITY OF SETTING UP THE FILE STRUCTURE
EACH TIME.

THE ENVIRONMENT THAT THE SIMULATOR PROVIDES HAS ONE VERY GREAT
DIFFERENCE FROM THE REAL KL10 ENVIRONMENT - IT DOES NOT HAVE
A USER ADDRESS SPACE. THE SIMULATOR WILL ACTUALLY USE
THE EXEC ADDRESS SPACE AS IT APPEARS AT THE TIME OF
DISMISSAL TO USER MODE AS THE OPERATING ENVIRONMENT FOR THE
SIMULATED USER MODE PROGRAM. THUS, IT IS POSSIBLE TO RUN
EDDT IN "SIMULATED USER MODE" BY ASSIGNING SOME CORE AND TYPING
"ST 141". USE PROGRAMS CAN ALSO BE WRITTEN IN THE PATCH AREA,
AND IF SOME CORE IS ASSIGNED (NECESSARY FOR THE ST COMMAND TO
WORK) ONE CAN START UP THE USER PROGRAM BY TYPING
"ST <ADDRESS OF PATCH AREA>".

SINCE THE EXEC ADDRESS SPACE IS USED AS THE USER MODE ADDRESS SPACE,
EXECUTIVE XCT INSTRUCTIONS ARE SIMULATED TO ALWAYS FETCH
FROM THE EXEC ADDRESS SPACE. (EXEC XCTS DO FETCH FROM THE
CORRECT PREVIOUS CONTEXT AC BLOCK, HOWEVER.) THIS CAN CAUSE
DISASTROUS EFFECTS WITH CERTAIN COMMANDS, FOR EXAMPLE, GET AND SAVE.
SO DON'T DO COMMANDS THAT WILL CAUSE THE EXEC PROGRAM TO DO MASSIVE
DAMAGE TO THE EXEC ADDRESS SPACE.

NORMALLY, USING THE SIMULATOR SHOULD BE TRANSPARENT TO THE DEBUGGER.
HOWEVER, IF A BUG IS ENCOUNTERED IN THE SIMULATOR, AN ERROR MESSAGE
WILL PRINT OUT. THE LOCATION ERRPC WILL CONTAIN THE LOCATION
OF THE CODE IN THE SIMULATOR IN WHICH THE ERROR OCCURRED.

"EXEC" DDT: SINCE DDT HAS NOT BEEN MODIFIED TO NOT LOOK AT THE
USER MODE BIT IN THE PC, THE SIMULATOR EXECUTES "EXEC" DDT
IN "REAL" USER MODE. ANY UUOS COMING FROM DDT WHEN THE
SIMULATED PC BITS ARE EXEC MODE ARE EXECUTED BY THE REAL MONITOR,
NOT THE SIMULATED ONE.
THE SIMULATOR DOES NOT ALLOW SIMULATED PRIORITY INTERRUPTS
TO OCCUR IF THE SIMULATED PC WAS EXEC MODE AND INSIDE DDT.
HOWEVER, ANY ILLEGAL INSTRUCTIONS (I/O, JEN, MAP) ARE SIMULATED
BYE THE SIMULATOR EVEN IF EXECUTED FROM DDT. THIS ALLOWS
ONE TO SAY THINGS LIKE "CONI PAG,PAT$X" INSIDE "EXEC" DDT
AND HAVE THEM WORK AS IF EXECUTED FROM REAL EXEC DDT.
[5/31/79] MUUOS EXECUTED FROM SIMULATED EXEC MODE INSIDE DDT
WILL ALSO BE SIMULATED INSTEAD OF EXECUTED IF LOCATION DDXLOC
IS SET TO THE ADDR+1 OF DDT'S XCT INSTRUCTION. THE DEBPAT
ROUTINE WILL NORMALLY SET DDXLOC SO THAT THIS WILL HAPPEN.
ON THE OTHER HAND, IF THE SIMULATED PC BITS HAVE USER MODE SET,
THERE IS NO SPECIAL CHECKING DONE FOR DDT, AND SIMULATED UUO TRAPS ARE GENERATED.

CHARACTER AND TIMER INTERRUPTS DO OCCUR OUT OF SIMULATED EXEC
DDT, BUT THE RETURN PC IS NEVER CHANGED. THEREFORE, BEWARE
IF YOU ARE PATCHING THIS CODE WHILE RUNNING THE SIMULATOR.


THE HALT INSTRUCTION IS SIMULATED TO PRINT OUT THE PC AND "VMA"
(PC OF THE HALT INSTRUCTION ITSELF) AND THEN EXIT TO THE REAL
MONITOR IF PERFORMED IN SIMULATED EXEC MODE. TYPING
"CONTINUE" TO THE REAL MONITOR WILL START THE SIMULATION
AT THE EFFECTIVE ADDRESS OF THE HALT INSTRUCTION.

NOTE ON ENTERING EXEC DDT FOR THE FIRST TIME:
THE SYMBOL TABLE POINTER IN 116 GETS CLOBBERED IN ONCE ONLY.
TO SET IT UP AGAIN AFTER THE SIMULATED MONITOR STARTS THE NULL
JOB, ENTER DDT VIA ^X, THEN LEAVE EITHER WITH $P IF GOT TO DDTBAK
BREAKPOINT OR DDTBAK$G IF SIMULATOR SAID "<DDT>".
THIS WILL RESET THE POINTER IN .JBSYM FROM DDTSYM (36).

IT IS EASY TO THINK THAT WHEN THE SIMULATED CONSOLE IS AT
MONITOR LEVEL (. PROMPT) THAT THE SIMULATOR ISN'T WASTING
MACHINE TIME. HOWEVER, YOUR REAL JOB RUNNING THE SIMULATOR
IS EXECUTING THE SIMULATED NULL JOB, AND THUS IS VERY COMPUTE BOUND.
IF YOU ARE GOING TO DO A LOT OF THINKING ABOUT SOMETHING,
DON'T LEAVE THE SIMULATOR RUNNING - JUST TYPE ^ZB OR
^X AND GET INTO DDT, WHICH WILL PUT YOU INTO TI WAIT.
[5/31/79] ONE OF THE REASONS WE DON'T PATCH EXEC DDT TO RUN
IN SIMULATED EXEC MODE IS SO THAT DDT WILL GO INTO TI WAIT
WHEN THE SIMULATOR IS NOT BEING USED, SOAS NOT TO HOG THE SYSTEM.

THE MONITOR REENTER COMMAND CAN BE USED TO REENTER DDT
IN "SIMULATED EXEC DDT" MODE AFTER THE SIMULATOR HAS
CRASHED OR THE SIMULATED MACHINE HAS HALTED. THIS IS SOMETIMES
NECESSARY FOR EXAMINING THE DEAD MONITOR AND MANIPULATE IT
(E.G. TURN PAGING ON/OFF, LOOK AT PHYSICAL PAGES THRU MAP SLOTS).

IF IT IS NECESSARY OR DESIRABLE TO RUN THE EXEC DDT IN SIMULATED EXEC
MODE, CHANGE THE TWO JSP T,.+1'S IN DDT'S "SAVE" ROUTINE TO
MOVE T,SIMPC. CHANGE THE CHRINT ROUTINE IN THE SIMULATOR TO
NOT DISMISS IF THE PC IS INSIDE DDT. HOWEVER, NOTE THAT
SOME THINGS WERE OBSERVED NOT TO WORK IN EXEC DDT RUNNING
IN SIMULATED EXEC MODE, SO IT LOOKS LIKE THAT SETUP IS NOT
FULLY DEBUGGED.

INTERESTING SIMULATOR LOCATIONS
-------------------------------
LASPC		PC OF LAST ILLEGAL INSTRUCTION TRAP NOT IN EXEC DDT OR SIMULATOR
LASPI		PI STATUS DURING LAST NON-EXEC DDT OR SIMULATOR ILLEGAL INSTRUCTION
DDTPC		RETURN PC OF LAST ^X INTERRUPT
RETPC		LAST PC OF ILLEGAL INSTRUCTION SOFTWARE INTERRUPT -
		SIMULATED PRIORITY INTERRUPTS CHANGE THIS LOCATION.
DDTBAK		"DDTBAK$G" RETURNS TO MONITOR AFTER ENTERING DDT WITH ^X
SIMPC		LH HAS PC FLAGS OF SIMULATED VIRTUAL MACHINE
UBRST		DATAI PAG WORD STORED IN SIMULATOR
EBRST		CONI PAG WORD STORED IN SIMULATOR
<DEV>ST		<DEV> = PI,APR,DTE,SAX,TIM,MTR CONI WORDS FOR <DEV>
BPA<N>CB	LOCAL TO SIMULATOR - UNIT DATA BLOCK TABLE FOR SIMULATED DISK UNITS
  UNIONL	IF -1, SIMULATED UNIT IS ON LINE
		IF 1, SIMULATED UNIT IS ON LINE AND WRITE PROTECTED.
  UNISND	LAST SENSE DATA STORED IN BYTES 0 AND 7
  UNINAM	SIXBIT NAME OF UNIT
UNTTBL		LOCAL TO SIMULATOR - MAP BETWEEN SA-10 DEVICE ADDRESSES AND SIMULATED UNITS
#; END SIMULATOR OPERATING INSTRUCTIONS

;SIMULATOR NOTES

COMMENT #
THERE ARE MANY WAYS IN WHICH THIS SIMULATION OF EXEC MODE
ARE NOT LIKE THE REAL MACHINE. HERE IS A LIST OF WAYS IN
WHICH THE SIMULATION IS DIFFERENT:

ADDRESS SPACE, EXEC XCT, PC
---------------------------

SINCE THE EXEC MODE PROGRAM IS REALLY RUNNING IN USER MODE,
THERE IS NO WAY TO STOP IT FROM SEEING THE USER MODE BIT
ON IN THE PC WORD. THIS CAUSES THE EXEC MODE PROGRAM TO TO
JENS TO USER MODE WHEN IT REALLY WANTED TO DO JENS TO
EXEC MODE. THE SOLUTION TO THIS PROBLEM IS TO PATCH THE
EXEC MODE PROGRAM TO TURN OFF PC.USR+PC.PUB IN ANY PC WORD
THAT IT IS GOING TO STORE WHICH IT WILL LATER DO A JEN THRU.
IN THE TYMCOM-X MONITOR, THERE ARE THREE PLACES WHICH MUST BE PATCHED.
THE DEBPAT ROUTINE WILL PATCH THESE PLACES TO CLEAR PC.USER+PC.PUB.

USER IOT: THE PC BIT PC.UIO IS MAINTAINED IN THE SIMULATED PC
WORD. IT IS USED BY THE MAP INSTRUCTION WHEN IT IS EXECUTED
UNDER AN EXEC XCT TO DETERMINE WHICH ADDRESS SPACE THE MAP
IS TO BE DONE FOR. PC.UIO IS ALSO USED BY THE SIMULATOR'S
PAGE FAIL GENERATOR TO FIGURE OUT WHICH ADDRESS SPACE TO CLAIM
THE PAGE FAULT IS FROM. IF PC.UIO IS ON AND PX.MEM IS ON IN
THE SIMULATOR'S EXEC XCT FLAG WORD AND THE SIMULATED PC IS
IN EXEC MODE, THEN THE REFERENCE IS DEEMED TO BE TO USER SPACE.
SEE PAGING AND TRAPS SECTION FOR A DISCUSSION OF PUSH, POP, BLT, AND
BYTE INSTRUCTIONS UNDER PXCTS.

TO MAINTAIN THE PROPER STATE OF PC.UIO, THE SIMULATOR REPLACES
ALL JRSTF INSTRUCTIONS WITH JEN INSTRUCTIONS, WHICH THE SIMULATOR
CAN THEN TRAP TO MAINTAIN THE SIMULATED PC WORD CORRECTLY.
NOTE THAT THE MONITOR UNDER SIMULATION CANNOT SEE PC.UIO BY
DOING PC READING INSTRUCTIONS. ALSO NOTE THAT IT IS ASSUMED
THAT INTERRUPT ROUTINES DO NOT DO JRSTFS.

THE SIMULATOR GOES THRU THE ENTIRE CORE IMAGE
DURING ITS INITIALIZATION AND REPLACES ALL EXEC XCTS WITH AN
LUUO. THE SIMULATION OF EXEC XCTS IS LIMITED TO SELECTING
PREVIOUS CONTEXT AC BLOCK IF THE EFFECTIVE ADDRESS CALLS FOR
THAT. OTHERWISE, ALL FETCHES COME FROM EXEC SPACE.

JOB DATA AREA: IT IS ASSUMED THAT THE EXEC MOE PROGRAM WLL
LEAVE LOCATION 66, THE PLACE WHERE THE UUO TRAP ROUTINE STORES
THE TRAPPED INSTRUCTION, ALONE. THIS CAN BE CHANGED LATER IF
WE PROVIDE A NEW UUO TO RETURN THE INSTRUCTION.

NOTE: USER DDT EXPECTS THE SYMBOL TABLE POINTER TO LIVE IN 116,
BUT IN THE SIMULATION, UNTIL DDT IS STARTED UP, THE POINTER
LIVES IN LOCATION 36. TYPING ^X (GOING INTO SIMULATOR EXEC DDT AT
NON-SOFTWARE PI LEVEL) WILL START DDT AND SET THE SYMBOL TABLE POINTER
IN 116 UP AGAIN, WHICH THE MONITOR IS FOND OF CLOBBERING)

THE EXECUTIVE XCT FLAGS PX.BYT AND PX.EA ARE NOT IMPLEMENTED.

PI SYSTEM
---------

IN THE REAL HARDWARE, THE DEVICE MAINTAINS A SIGNAL WHICH
KEEPS INTERRUPTING THE PROCESSOR UNTIL THE PROCESSOR CLEARS THE
DEVICE'S INTERRUPT FLAG. IN THE SIMULATION, WHEN A SIMULATED DEVICE
CAUSES AN INTERRUPT, IT SETS A COUNT, AND THE PROCESSOR ALWAYS
GETS C(COUNT) INTERRUPTS, REGARDLESS OF WHETHER OR NOT
THE EXEC MODE PROGRAM SERVICES ALL INTERRUPTS ON THE FIRST AND CLEARED
ALL INTERRUPT FLAGS. THIS COULD CAUSE FREE INTERRUPTS, BUT IF THE
EXEC MODE PROGRAM IGNORES FREE INTERRUPTS, EVERYTHING WILL BE OK


PAGING AND TRAPS
----------------

THE PAGING SYSTEM WORKS ON THE ASSUMPTION THAT ALL CODE
THAT CHANGES A MAP SLOT WILL CLEAR THE PAGING MEMORY FOR THAT
SLOT. THIS IS NOT STRICTLY NECESSARY WHEN THE MACHINE FIRST COMES
UP, SINCE THE PAGING MEMORY IS CLEAR WHEN PAGING IS FIRST TURNED ON.
HOWEVER, IT IS NECESSARY FOR THE SIMULATOR SINCE THE ONLY WAY
IT KNOWS THAT A MAP SLOT HAS BEEN CHANGED IS IF THE EXEC MOE
PROGRAM CLEARS THE PAGE TABLE.

THE PAGE FAULT WORD IS BEING SIMULATED UNTIL THE GETPFW UUO IS FIXED.
IT IS ASSUMED THAT THE STACK WORD IS NOT THE SOURCE
OF THE PAGE FAULT FOR PUSH AND POP.
IN BYTE INSTRUCTIONS, IT IS ASSUMED THE FAULT WAS NOT THE POINTER ITSELF OR ANYTHING IN THE EA OF THE POINTER.
FOR ALL OTHER INSTRUCTIONS, INCLUDING BLT, THE STATE OF THE PC.UIO SIMULATED
PC FLAG IS USED TO DETERMINE WHICH ADDRESS SPACE THE PAGE FAULT
IS FOR. THIS IS PROVIDED SO THAT THE PROGRAMMER CAN GENERATE
EITHER ILL MEM REFS TO USER SPACE OR TO EXEC SPACE (WHICH CRASH THE
MONITOR).

NOTE - SIMULATOR WILL GET ILL MEM REF IN PFWGET IF THE INACCESSIBLE
PAGE WAS ENCOUNTERED DURING THE EFFECTIVE ADDRESS CALCULATION
IN THE INSTRUCION - IT DOES MOVEI @MEMINS.


TRAPS: ONLY PDL OVERFLOW, NOT ARITH OVERFLOW, IS SUPPORTED
IN THE SIMULATION. IN THE HARDWARE TRAP INSTRUCTIONS
THAT STORE PC STORE THE PC OF THE TRAP, BUT IN THE SIMULATION
ONLY MUUOS DO THIS. A NON-MUUO INSTRUCTION AS A TRAP INSTRUCTION
WILL STORE THE PC FROM WHICH IT IS EXECUTED INSIDE THE SIMULATOR.

ILLEGAL INSTRUCTIONS (UNIMPLEMENTED OPCODES) ABOVE 100 WILL NOT
WORK PROPERLY IF SET AS TRAP (PDL OVERFLOW) INSTRUCTIONS - I.E.,
WILL CAUSE THE NO-TRAP RATHER THAN THE TRAP PC WORD TO BE USED
IN THE MUUO SIMULATION. (TOO LAZY TO COMPARE AGAINST ALL THOSE
OPCODES).

WARNING- THE SIMULATOR REMOVES PAGE 1 (UPT) TO ADDRESS
THE CURRENT UPT POINTED TO BY THE UBR. IF THE SIMULATOR SHOULD
BLOW UP BEFORE IT RESTORES PAGE 1, THINGS MIGHT BE A LITTLE
CONFUSING IF YOU ARE NOT AWARE OF THIS. UPTFLG LOCATION CONTAINS
THE CURRENT PHYSICAL PAGE CONTAINED IN VIRTUAL PAGE 1.

THE UNMAPPED AREA OF THE ADDRESS SPACE, 0-337777, HAS
PAGE MAP POINERS ON THE KL10, BUT THESE ARE NOT SUPPORTED
BY THE PAGING SIMULATOR. IT IS ASSUMED THE POINTERS ARE
SETUP TO BE A ONE TO ONE MAPPING WITH PHYSICAL MEMORY.

INTERNAL DEVICES
----------------
THE CACHE SWEEP DONE FLAG IS ALWAYS UP REGARDLESS OF ATTEMPTS TO
CLEAR IT. THIS IS BECAUSE THE MONITOR CODE STARTS A CACHE SWEEP
AND THEN CLEARS CACHE SWEEP DONE, IN CASE THERE WAS A SWEEP
IN PROGRESS THAT HAD JUST COMPLETED BEFORE THE CURRENT ONE
STARTED. SINCE THE SWEEP INSTRUCTION ITSELF CAUSES AN INTERRUPT
TO BE PENDING, THE CLEARING OF THE SWEEP DONE FLAG CANNOT
BE DONE.


IT IS NOT GUARANTEED THAT THE EFFECTS OF DOING A CONO TO A SIMULATED
DEVICE WHICH REQUESTS MORE THAN ONE ACTION TO BE PERFORMED (I.E.
CLEAR PI SYSTEM AND ENABLE CHANNELS) WILL ACT THE SAME WAY
AS THE REAL HARDWARE DOES.

OVERFLOW IN THE INTERVAL TIMER IS NOT IMPLEMENTED.

THE ACCOUNTING METERS AND TIME BASE ARE INOPERATIVE, ALTHOUGH
CONO MTR, WILL LOOK LIKE IT SET THE ENABLES PROPERLY.

SA10 SIMULATOR
--------------
THE SA-10 SIMULATOR ONLY WORKS FOR IOWDS THAT ARE MULTIPLES OF 200
WORDS. ALSO, IT ASSUMES ONLY ONE DATA CHAIN WORD FOLLOWS EACH
CHANNEL COMMAND (OK, SINCE MULTIPLE DATA CHAIN WORDS DON'T WORK
FOR FAST DEVICES ANYWAY).

THE SA-10 SIMULATOR EXPECTS MOST COMMANDS TO BE EXECUTED ONLY
IN BYTE MODE. NATURAL AND WORD MODE DO THE SAME THING.
DATA TRANSFER COMMANDS CAN ONLY BE IN NATURAL AND WORD MODE, NOT
BYTE MODE. TAPE COMPATIBILITY MODE IS NOT SUPPORTED AT ALL.

ONLY SENSE BYTES 0 AND 7 ARE SETUP ON ERRORS - THE OTHER INFORMATION
IS NOT UPDATED IN THE SIMULATOR'S UNIT TABLES.

ALL I/O IS COMPLETED AFTER THE I/O INSTRUCTION THAT STARTED IT,
SINCE THIS IS THE ONLY CHANCE THE SIMULATOR GETS TO DO IT.
ANY CODE THAT DEPENDS ON A 1 OR MORE INSTRUCTION DELAY BEFORE
GETTING THE I/O DONE INTERRUPT WILL NOT WORK.
#;END OF COMMENT

COMMENT # NOTES ON HOW TO SIMULATE USER ADDRESS SPACE
          -------------------------------------------

LET USER BE UP TO START OF SIMULATOR IN SIZE
EXECUTIVE XCT SIMULATOR MUST SWITCH TO USER ADDRESS SPACE IF
SIMULATED USER IOT BIT IS ON IN THE SIMPC WORD

EXECUTIVE XCT OF MAP, CLRPTO MUST WORK

MEM, UUO, AND XCT TRAP ROUTINES MUST LOOK AT THE SIMPC
WORD ON EXITING AND SWITCH TO ADDRESS SPACE SPECIFIED
BY THE PC.USR BIT.

MUST WATCH OUT TO SAVE 66 FROM ONE ADDRESS SPACE'S PAGE 0 AND
PUT IT INTO THE OTHER ADDRESS SPACE'S PAGE ZERO.

CLRPTO DOESN'T HAVE TO WORK - WHEN EXEC PROGRAM EXECUTES IT,
THEN DOES EXEC XCT, THE EXEC XCT WILL HAVE TO SCAN THE USER'S MAP
ANYWAY (RESTORE USER ADDRESS SPACE)

HAVE TO ALLOW FOR HIGH SEGMENT TOO.

MAYBE STILL ALLOW TO START UP USER CODE IN EXEC ADDRESS SPACE
BECAUSE OF INEFFICIENCY OF MAPPING AND REMOVING ALL THOSE PAGES.

PAGE FAULT WORD SIMULATOR WOULD HAVE TO WORK FOR USER PAGES

MUST BE A SEPARATE FLAG IN THE SIMULATOR THAT SAYS WHICH ADDRESS
SPACE IS SETUP, SINCE THE SIMPC BITS COULD SAY EXEC MODE
DURING AN EXEC XCT WHILE USER SPACE IS MAPPED.

HAVE TO WATCH OUT WHEN SETTING UP USER MA TO DO PAGE 1 LAST,
SINCE SIMULATOR USES PAGE 1 TO READ A UPT WITH. MUST MAP ALL USER'S
PAGES OTHER THAN 1, THEN MAP PAGE 1. FIXUPT MUST NOT BE CALLED,
OR MUST CHECK ADDRESS SPACE FLAG AND NOT DO ANYTHING.

WHEN RESTORING EXEC, JUST FORGET WHAT WAS IN PAGE 1 BEFORE
AND PUT WHAT BELONGS THERE IN. THIS MEANS THAT SETTING UP
USER ADDRESS SPACE SHOULD SET UPTFLG TO 1, THEN FIXUPT
WON'T DO ANYTHING WHEN RETURN.

PROVIDE A FEW LUUOS TO TRANSFER FILES OVER TO SIMULATED SYSTEM.

AS OF 3/26/79, ONE CAN ONLY DO A VCLEAR ON ENTIRE ADDRESS SPACE
AND THEN MAP ALL OF ADDRESS SPACE FROM A FILE 4 TIMES A SECOND.
THIS WOULD MAKE SIMULATING USER ADDRESS SPACE TOO SLOW FOR
SIMULATION. WILL HAVE TO WAIT UNTIL WE GET FRAMING WORKING.
WILL NEED TO CREATE FRAMES, MANIPULATE ADDRESS SPACES,
GET TRAPS. MANY NOTES ABOVE HAVE TO DO WITH USING
SIMULATED MONITOR ADDRESS SPACE TO MAP USER INTO WHEN HE
IS RUNNING; THESE NOTES ARE OBSOLETE.
#;END OF COMMENT

MONPAT::HRLI	T2,(POINT 7,)	;MAKE INTO BYTE POINTER
	MOVE	T3,T2		;COPY OF POINTER
	MOVE	T4,T2		;ANOTHER.
MONPTL:	ILDB	T1,T3		;GET CHAR
MONPL0:	CAIN	T1,12		;LF
	JRST	MONPTL		;YES, IGNORE.
	CAIN	T1,"Y"-100	;TURN ^Y INTO LINE FEED
	JRST	[MOVEI T1,12
		 IDPB T1,T4
		 ILDB T1,T3	;GET NEXT CHAR
		 CAIN T1,15	;AND IGNORE CR AFTER ^Y
		 JRST MONPTL
		 JRST MONPL0]
	IDPB	T1,T4
	JUMPN	T1,MONPTL	;GO IF MORE CHARS
MONPL1:	CAMN	T3,T4		;MUST CATCH UP
	JRST	MONPL2		;DONE
	IDPB	T1,T4		;ZERO THE REST
	JRST	MONPL1
MONPL2:	HRROI	T1,.AXSI	;STUFF INPUT BUFFER.
	AUXCAL	T1,T2
	  HALT
	JRST	DDT##

DEBPAT::JSP	T2,MONPAT
	ASCIZ &
CLOCK1:
WSCHD2/Q<ZZ:JRST PAT	ZZ
HLL T1,SIMPC
HLLM T1,%UPT+UPTPC
JRST WSCHD2+1
PAT:
SIMKL:
KL$SIM/-1
PATCH4G
&				; ** Match <> bracket above with ">"
PATCH4:	JSP	T2,MONPAT
	ASCIZ &
""PATCH TO SPEED UP MEMORY CHECK IN ONCE"
ONCE:
-%ONC+ONCSTT+PGSLP+1/CAILE T1,777
-%ONC+ONCSTT+PGSLP+3/JRST PGECNT
SIMKL:BPA0CB UNIONL[-1
BPA1CB UNIONL[-1
DDTBAKB
REFLAG/1,,2
PATCH5G

&

PATCH5:	JSP	T2,MONPAT
	ASCIZ &
""PATCH TO MAKE $X WORK IN EDDT"
SIMKL:
JSP T1,DDTX
HRRZM T1,DDXLOCX
120/Q,,MONDEB
PATCH6G
&

PATCH6:	JSP	T2,MONPAT
	ASCIZ &
""PATCH TO MAKE 3^B SET USER ACS TO GET TO EXEC DDT"
UUOCON:
LIGHTS/JRST DDT
3"%UPS+UPTUAC+1!CALLI -1
HALT
CALLI 1,12
"
SIMKL:
&


;SETUP TRAPS

MONDEB::RESET
	SETZM	SIMPC		;MAKE SURE WE DON'T THINK INIT UUOS ARE FROM USER.

	MOVEI	P1,MONDEB	;LAST LOC
XCTLUP:	HLRZ	T1,(P1)		;GET DA
	ANDI	T1,774000	;JUST OPCODE
	CAIE	T1,254000	;IS IT XCT OR JRST?
XCTMOR:	SOJG	P1,XCTLUP	;NO
	JUMPLE	P1,XCTDON	;GO IF DONE
	MOVE	T1,(P1)		;IS XCT OR JRST, LOOK FOR AC FIELD
	TLNN	T1,000740	;IS IT NON-ZERO?
	JRST	XCTMOR		;NO, LEAVE VANILLA JRST AND XCT ALONE
	LDB	T2,[POINT 9,T1,8] ;GET OPCODE
	CAIE	T2,<JRST>_-^D27 ;IS IT JRST?
	JRST	ZAPXCT		;NO, GO DO XCT
	LDB	T2,[POINT 4,T1,12] ;GET AC FIELD
	CAIE	T2,2		;IS IT A JRSTF?
	JRST	XCTMOR		;NO, FORGET IT
	MOVEI	T2,11		;USE UNUSED COMBO OF BITS THAT TRAP ON ALL MACHINES.
	DPB	T2,[POINT 4,(P1),12] ;YES, MAKE IT INTO A JEN
	JRST	XCTMOR		;AND GO FOR ANOTHER
ZAPXCT:	CAIE	T2,<XCT>_-^D27	;THIS AN XCT?
	JRST	XCTMOR		;NO, SOME OTHER 25X OTHER THAN JRST OR XCT.
	MOVEI	T1,<SXCT>_-^D27 ;TURN THIS INTO AN LUUO
	DPB	T1,[POINT 9,(P1),8]
	JRST	XCTMOR		;AND GO FOR MORE.

XCTDON:	OPEN	PHY,[EXP 17,SIXBIT/DSK/,0]
	  ERROR (CAN'T INIT DSK)
	LOOKUP	PHY,PHYFNM	;GET IT IN UPDATE MODE IF POSSIBLE
	  JFCL			;IF NOT, JUST ENTER
	ENTER	PHY,PHYFNM
	  ERROR (CAN'T ENTER PHYSICAL CORE FILE)
FUINIT:	OPEN	IDX,[EXP 17,SIXBIT/DSK/,0]
	  ERROR	(CAN'T OPEN DISK)
	OPEN	DAT,[EXP 17,SIXBIT/DSK/,0]
	  ERROR (CAN'T OPEN DISK)
	LOOKUP	IDX,IDXFNM	;GET INDEX FILE IN UPDATE MODE
	  JFCL
	ENTER	IDX,IDXFNM
	  ERROR (CAN'T ENTER INDEX FILE)
	LOOKUP	DAT,DATFNM
	  JFCL
	ENTER	DAT,DATFNM
	  ERROR (CAN'T ENTER DATA FILE)
	HRRZ	T2,.JBREL##	;GET CURRENT SIZE
	ADDI	T2,1000		;ROUND UP
	TRZ	T2,777
	SUBI	T2,200	;FIRST LOC TO TO IO TO
	MOVN	T2,T2
	HRL	T2,T2		;MAKE AN IOWD
	HRRI	T2,200-1	;SAVE FROM HERE
	MOVE	T1,[IOWD 200,200] ;FAKE JOB DATA AREA TO MAKE FILE EVEN BOUNDARY FOR PAGE
	SETZ	T3,
	OUT	PHY,T1
	JRST	FILOUT		;OK.
	ERROR	(OUTPUT ERROR FOR PHYSICAL CORE FILE)
FILOUT:	USETO	PHY,1000*4	;MAKE THE REST OF THE PAGES EXIST
	MOVE	T1,[IOWD 1000,FUBUF]
	SETZ	T2,
	OUT	PHY,T1		;MAKE ALL THE PAGES FROM 0 TO 512 EXIT
	  JRST	.+2		;OK
	ERROR (OUTPUT ERROR FILLING PHYSICAL CORE FILE TO 512 P)
ONCFK1:	MOVSI	17,MAPCOD	;GET CODE TO BLT TO ACS
	BLT	17,17
	JSR	0		;MAP SELF FROM FILE
	MOVE	0,[1,,2]
	SETZ	1,
	BLT	0,17		;DON'T LEAVE EXECUTABLE STUFF IN ACS JUST IN CASE.

	MOVEI	T1,REEADR	;REENTER ADDRESS
	MOVEM	T1,.JBREN##	;STORE
	JSR	FAKSYM		;SETUP 36.
;CALL FAKJDA IF NECESSARY TO SETUP JOB DATA AREA FOR 'USER' PROGRAM


	SKIPE	T1,[ONCGO]	;SKIP IF LOADED WITH THE MONITOR
	CAIN	T1,DDTEND##	;IF EQUAL TO DDTEND, THEN NOTHING IS LOADED.
	JRST	REEADR		;NOT MONITOR SIMULATION, FORGET IT
	MOVEI	P,USRCDE-40	;TEMPORARY STACK
	PUSHJ	P,FAKJDA	;SETUP JOB DATA AREA AND PATSIZ

REEADR:	MOVE	T1,[4,,IVEC]	;CLEAR = 4.
	INTADR	T1,		;CLEAR INTERRUPT SYSTEM
	  ERROR (INTADR TO CLEAR INTERRUPT SYSTEM FAILED)
	MOVE	T1,[.IAILM,,1]	;CHANNEL 1 GETS ILL MEM REFS
	INTASS	T1,
	  ERROR (INTASS FOR ILL MEM REFS FAILED)
	HRLOI	T1,.IACHR+2	;ENABLE FOR CHAR INTERRUPTS FOR COMMAND PORT ON UUO CHANNEL
	TINASS	T1,
	  ERROR (TINASS FOR CHAR INTERRUPT FAILED)
	MOVE	T1,[.IATIM,,2]  ;TIMER INTERRUPT FOR CLOCK TICKS ON 2
	INTASS	T1,
	  ERROR (INTASS FOR TIMER INTERRUPTS FAILED)
	MOVSI	T1,700000	;ENABLE CHANNEL 1 AND 2
	INTENB	T1,
	  ERROR (INTENB CHANNEL 1 AND 2 FAILED)
	MOVE	T1,[.IAUUO,,2]  ;UUO AND ILLEGAL INSTRUCTION ON NEXT HIGHEST
	INTASS	T1,		;DO IT LAST TO AVOID CONFUSION.
	  ERROR (INTASS FOR UUO TRAP FAILED)
	SETOM	66		;SET FLAG THAT SAYS THAT INTERRUPT IS NOT FROM UUO TRAP.
	MOVE	T1,[2,,IVEC]
	INTADR	T1,
	  ERROR (INTADR TO ENABLE INTERRUPT SYSTEM FAILED.)
	MOVE	T1,[JSR PDLOVF] ;PDL OVERFLOW INSTRUCTION
	SETTR2	T1,		;DO IT HERE SO INTADR DOESN'T CLEAR IT.
	  ERROR (SETTR2 FAILURE IN INITIALIZATION)
	SETZM	SIMPC		;START OUT WITH EXEC MODE SIMULATED PC
	CONO	PAG,@EBRST	;SETUP UNMAPPED STUFF.
	JRST	DDT##		;GO TO DDT.


MAPCOD:
	PHASE	0
	0			;JSR HERE.
	VCLEAR	14,
	  HALT
	CHANIO 15,16
	  JFCL
	JRST	@0
	EXP 0,0,0,0,0,0
	777,,1
	.CHMAP,,PHY
	6777,,1
	2
	DEPHASE


;HERE IF GET PDL OVERFLOW, JSR FROM TRAP INSTRUCTION

PDLOVF:	0
	MOVEM	T1,PDLT1#
	MOVEM	T2,PDLT2#
	HRRZ	T1,PDLOVF
	CAIL	T1,MONDEB
	CAILE	T1,MONDBE
	JRST	.+2
	ERROR	(PDL OVERFLOW FROM SIMULATOR)
	HLL	T1,SIMPC	;GET SIM PC FLAGS
	MOVEM	T1,TRPPC	;SET PC, CLEARED IF NOT DOING AN MUUO AS TRAP INSTRUCTION
	TLNN	T1,PC.USR	;USER?
	JRST	PDLEXC		;NO, EXEC
	JSR	GETUPT		;GET UPT
	MOVE	T2,UPTPOV(T1)	;THE INSTRUCTION
DOTRP:	MOVEM	T2,TRPINS	;EXECUTE IT FROM HERE
	LDB	T2,[POINT 9,T2,8] ;GET OPCODE
	CAILE	T2,<UJEN>_-^D27	;OTHER ILGGAL INSTRUCTIONS WON'T WORK AS TRAPS
	SETZM	TRPPC		;ASSUME IS NOT GOING TO TRAP, NO TRAP CYCLE FOR NEXT UUO!
	MOVEI	T1,UPT/1000	;FIX UPT BACK IF WE SMASHED IT
	JSR	FIXUPT
	MOVE	T1,PDLT1
	MOVE	T2,PDLT2
TRPLOC:	XCT	TRPINS		;DO IT
	JRST	@PDLOVF		;AND RETURN IF EVER COME BACK.

;EXEC MODE
PDLEXC:	JSR	GETEPT		;GET EPT
	MOVE	T2,EPTPOV(T1)
	JRST	DOTRP

TRPINS:	0			;PLACE TO EXECUTE TRAP INSTRUCTION
TRPPC:	0			;IF NON-ZERO, SAYS WE'RE IN TRAP CYCLE.

;NOTE THAT TRAP CYCLES DON'T WORK QUITE RIGHT, WE DO NOT SIMULATE
; THE EFFECT OF PC FOR PUSHJ, JSR, ETC. COMING FROM OVERFLOWED
; INSTRUCTION RATHER THAN THIS ROUTINE.

;LUUO SERVICE

LUUO:	0
LUUOH:	0
	JSR	LUOSAV		;SAVE ACS
	MOVE	T1,SIMPC	;GET SIMULATED PC FLAGS
	HLLM	T1,LUUOH	;PUT IN RETURN ADDRESS
	LDB	T1,[POINT 9,LUUO,8] ;GET OPCODE
	CAIE	T1,<SXCT>_-^D27
	ERROR	(ILLEGAL LUUO IN SIMULATOR)
	JSR	LUORST		;GET ACS BACK IN CASE INSTRUCTION IS IN ACS
	MOVE	M,@LUUO		;GET INSTRUCTION IN M FOR MODIFICATION
	MOVE	P1,LUUO		;PXCT BITS IN LH OF P1 FOR TESTING
	MOVEM	P1,SXFLG	;STORE FOR I/O INSTRUCTIONS TO USE
	MOVE	P,LUOPDP	;GET P BACK.
				;EXEC XCT OF CLRPT WILL ALWAYS CLEAR EXEC MAP.
	LDB	T1,[POINT 9,M,8] ;GET OPCODE

DEFINE INSDSP(ARG)<
IRP ARG,<
	CAIN	T1,<'ARG>_-^D27
	JRST	EX'ARG
>>;END INSDSP MACRO

	INSDSP(<BLT,PUSH,POP,LDB,ILDB,DPB,IDPB>)

;HERE IF NOT SPECIAL INSTRUCTION

	TLNN	P1,(<PX.MEM>B12)	;ONLY BIT THAT MATTERS FOR REGULAR INSTLUCTIONS (PX.EA NOT SUPPORTED)
	JRST	XCTGO
	MOVE	T1,M		;GET I,X,Y IN T1
	JSR	PRCEA		;IF EA IS ACS, CONVERT TO PROPER AC BLOCK
	TLZ	M,17(@)		;CLEAR INDEX AND INDIRECT
	HRR	M,T1		;REPLACE WITH THIS E.A.
XCTGO:	MOVEM	M,LUUO		;XCT IT FROM HERE
	JSR	LUORST		;RESTORE ACS FIRST
LUUXCT:	XCT	LUUO
	  SKIPA
	AOS	LUUOH		;GIVE SKIP TO THE INSTRUCTION
	SETZM	SXFLG		;NO LONGER UNDER EXEC XCT
	JRST	@LUUOH		;RETURN FROM SXCT INSTRUCTION

SXFLG:	0			;PLACE FOR I/O INSTRUCTIONS TO CHECK EXEC XCT FLAGS

;HERE FOR BLT INSTRUCTION

EXBLT:	LDB	T1,[POINT 4,M,12]
	JSR	LUFETC		;GET POINTER DATA IN T2
	MOVE	P2,T2		;GET INTO SAFE PLACE
	TLNN	P1,(<PX.MEM>B12)	;DESTINATION IS PREVIOUS CONTEXT?
	JRST	BLTNME		;NO MEM FIELD
	MOVE	T1,M		;GET I,X,Y
	JSR	PRCEA		;GET PROPER EFFECTIVE ADDRESS
	TLZ	M,17(@)
	HRR	M,T1		;REPLACE WITH NEW ONE
	HRRZ	T1,P2		;GET DESTINATION
	JSR	PRCEA		;CONVERT IT
	HRR	P2,T1		;GET INTO RH
BLTNME:	TLNN	P1,(<PX.SRC>B12)	;SOURCE FROM PREVIOUS CONTEXT TOO?
	JRST	BLTEND		;NO, STORE AC AND GO EXECUTE IT
	HLRZ	T1,P2		;GET SOURCE
	JSR	PRCEA		;CONVERT TO GOOD EFFECTIVE ADDRESS
	HRL	P2,T1		;PUT BACK IN POINTER
BLTEND:	LDB	T1,[POINT 4,M,12] ;GET AC NUMBER AGAIN
	MOVE	T2,P2		;GET DATA INTO T2
	JSR	LUSTOR		;PUT BACK INTO USER'S AC
	MOVSI	T1,(17,)	;CLEAR AC FIELD, MAKE PAGE FAULT ATTRIBUTE
	ANDCAM	T1,SXFLG	; THIS FAULT TO EXEC - OR ELSE PAGE FAIL
				; ROUTINE WILL SEE PX.MEM AND THINK THAT
				; FAULT WAS FOR USER SPACE.
				;(ACS WON'T FAULT, SO WORKS OK.)
	JRST	XCTGO		;AND GO EXECUTE THE INSTRUCTION


EXDPB:
EXLDB:
EXILDB:
EXIDPB:	MOVE	T1,M		;GET I,X,Y OF BYTE POINTER
	TLNE	P1,(<PX.MEM>B12) ;BYTE POINTER FROM USER?
	JRST	[JSR PRCEA	;YES, GET PLACE TO GET IT FROM
		 JRST .+2]
	JSR	COMPEA		;COMPUTE EA OF BYTE POINTER
	JSR	LUFETC		;GET IT
	TLOE	M,001000	;INCREMENT INSTRUCTIONS HAVE LOW BIT OFF IN OPCODE
				;ALSO, MAKE IT INTO LDB OR DPB SINCE WE INCREMENT PTR BY HAND
	JRST	EXBP1		;LDB OR DPB
	IBP	T2		;INCREMENT IT
	JSR	LUSTOR		;STORE IT
EXBP1:	MOVE	T1,T2		;GET EA
	MOVE	P2,T2		;SAVE IT FROM ROUTINS THAT SMASH T2
	TLNE	P1,(<PX.SRC>B12) ;WANT SOURCE OF BYTE FROM PREVIOUS?
	JRST	[JSR PRCEA	;YES, GET EA FOR PREVIOUS
		 JRST .+2]
	JSR	COMPEA		;NO, GET EA IN BYTE POINTER
	TLZ	P2,17(@)	;GET RID OF INDEX AND INDIRECT
	HRR	P2,T1		;GET PROPER EA
	MOVEM	P2,SBYTEP	;AND STORE
	TLZ	M,17(@)		;CLEAR OUT THESE FIELDS
	HRRI	M,SBYTEP	;EXECUTE FROM HERE
	JRST	XCTGO		;AND DO IT.

SBYTEP:	0			;PLACE TO STORE BYTE POINTER

EXPOP:	LDB	T1,[POINT 4,M,12] ;GET AC NUMBER
	JSR	LUFETC		;GET THE STACK POINTER
	MOVE	P2,T2		;SAVE IT IN P2
	SUB	T2,[1,,1]	;DECREMENT IT
	JSR	LUSTOR		;PUT IT BACK
	HRRZ	T1,P2		;GET JUST RH
	TLNE	P1,(<PX.SRC>B12) ;WANTS IT FROM PREVIOUS CONTEXT?
	JRST	[JSR PRCEA	;YES, CONVERT IT
		 JRST .+2]
	JSR	COMPEA		;NO, JUST WATCH OUT FOR ACS
	HRR	P2,T1		;PUT ADJUSTED ADDRESS IN
	MOVEM	P2,SPDP		;PUT WHERE CAN GET IT
	MOVE	T1,M		;GET I,X,Y OF POP
	TLNE	P1,(<PX.MEM>B12) ;WANTS IT STORED TO PREVIOUS?
	JRST	[JSR PRCEA
		 JRST .+2]
	JSR	COMPEA		;NO, JUST WATCH FOR ACS LUUO SAVED
	EXCH	T1,P2		;GET STACK POINTER ADDRESS IN T1, MEM TO P2
	JSR	LUFETC		;GET STACK DATA
	MOVE	T1,P2		;GET ADDRESS TO STORE INTO
	JSR	LUSTOR		;AND PUT IT THERE.
	JSR	LUORST		;RESTORE REGISTERS
	JRST	@LUUOH		;AND RETURN.

EXPUSH:	LDB	T1,[POINT 4,M,12] ;GET AC NUMBER
	JSR	LUFETC		;GET THE STACK POINTER
	MOVE	P2,T2		;SAVE IT IN P2
	AOBJN	T2,.+1		;INCREMENT IT
	JSR	LUSTOR		;PUT IT BACK
	MOVEI	T1,1(P2)	;GET ADDRESS TO STORE DATA TO
	TLNE	P1,(<PX.SRC>B12) ;WANTS IT STORED TO PREVIOUS CONTEXT?
	JRST	[JSR PRCEA	;YES, CONVERT IT
		 JRST .+2]
	JSR	COMPEA		;NO, JUST WATCH OUT FOR ACS
	HRR	P2,T1		;PUT ADJUSTED ADDRESS IN
	MOVEM	P2,SPDP		;PUT WHERE CAN GET IT
	MOVE	T1,M		;GET I,X,Y OF PUSH
	TLNE	P1,(<PX.MEM>B12) ;WANTS IT FETCHED FROM PREVIOUS?
	JRST	[JSR PRCEA
		 JRST .+2]
	JSR	COMPEA		;NO, JUST WATCH FOR ACS LUUO SAVED
	JSR	LUFETC		;GET MEMORY WORD
	MOVE	T1,P2		;T1 GETS ADDRESS OF STACK WORD
	JSR	LUSTOR		;PUT IT ON STACK
	JSR	LUORST		;RSTORE SMASHED AC
	JRST	@LUUOH		;AND RETURN.

SPDP:	0			;PLACE TO SAVE PDP BEFORE RESTORING ACS

;ROUTINE TO CONVERT I,X,Y IN T1 TO AN EFFECTIVE ADDRESS IN
; THE PREVIOUS CONTEXT (SAME AS CURRENT EXCEPT FOR ACS, WHERE
; IT USES THE PREVIOUS CONTEXT AC BLOCK. EXECUTIVE XCTS
; THAT CHANGE FROM PREVIOUS ACS TO REAL MEMORY DO NOT WORK.)

PRCEA:	0
	JSR	COMPEA		;GET THE EFFECTIVE ADDRESS IN THIS CONTEXT
	TRNE	T1,-17-1	;IN ACS?
	JRST	@PRCEA		;NO, JUST WHAT IT IS (USER SPACE = EXEC SPACE)
	MOVEM	T1,CUREAW	;SAVE FOR A WHILE
	LDB	T1,[POINT 3,UBRST,8] ;GET CURRENT AC BLOCK SETTING
	LDB	T2,[POINT 3,UBRST,11] ;GET PREVIOUS AC SETTING
	CAMN	T1,T2		;CURRENT AND PREVIOUS SAME?
	JRST	[MOVE T1,CUREAW ;GET BACK, JUST USE ACS
		 JRST @PRCEA]
	MOVE	T1,CUREAW	;GET IT BACK
	IMULI	T2,20
	ADDI	T2,ACDTAB	;GET LOCATION OF AC BLOCK
	ADD	T1,T2		;ADJUST EFFECTIVE ADDRESS SO CALLER GETS PREVIOUS AC
	JRST	@PRCEA		;AND RETURN.

;ROUTINE TO TAKE THE I,X,Y FIELDS FROM AN INSTRUCTION IN T1
; AND COMPUTE THE EFFECTIVE ADDRESS, RETURNING IT IN T1

COMPEA:	0
COMPE1:	TLZ	T1,-37-1	;JUST INDEX AND INDIRECT IN LH
	TLNN	T1,17		;ANY INDEXING?
	JRST	COMPE2		;NO, LOOK AT @ BIT
	MOVEM	T1,CUREAW#	;SAVE
	HLRZS	T1
	TRZ	T1,(@)		;GET JUST INDEX AC
	JSR	LUFETC		;GET ITS CONTENTS IN T2
	HRRZ	T1,T2		;JUST RH
	ADD	T1,CUREAW	;GET C(X)+Y
	TLZ	T1,17		;TURN OFF INDEX FIELD
COMPE2:	TLZN	T1,(@)		;WAS THIS INDIRECT?
	JRST	@COMPEA		;NO, THIS IS THE EA
	JSR	LUFETC		;YES, GET CONTENTS OF NEXT WORD IN T2
	MOVE	T1,T2		;GET INTO T1
	JRST	COMPE1		;AND GO AGAIN.

;ROUTINES TO FETCH AND STORE FOR LUUO HANDLER

LUFETC:	0
	TRNN	T1,-17-1	;IN ACS?
	SKIPA	T2,@LUACTB(T1)	;YES, FROM AC OR STORED PLACE
	MOVE	T2,(T1)		;NO, JUST THIS
	JRST	@LUFETC

LUSTOR:	0
	TRNN	T1,-17-1	;IN ACS?
	JRST	LUSTO1		;YES.
	MOVEM	T2,(T1)		;NO
	JRST	@LUSTOR

LUSTO1:	MOVEM	T2,@LUACTB(T1)
	JRST	@LUSTOR

DEFINE LSVMAC(ACS)<
LUOSAV:	0
IRP ACS,<
	MOVEM	ACS,@LUACTB+'ACS
>
	MOVE	P,LUOPDP
	JRST	@LUOSAV
>;END LSVMAC

DEFINE LRSMAC(ACS)<
LUORST:	0
	MOVEM	P,LUOPDP
IRP ACS,<
	MOVE	ACS,@LUACTB+'ACS
>
	JRST	@LUORST
>;END LRSMAC

DEFINE LATMAC(ACS)<
ZZ==0
LUACTB:
REPEAT 20,<ZZ
ZZ==ZZ+1>
IRP ACS,<LUSV'ACS:	0
	ZZ==.
	RELOC	LUACTB+'ACS
	EXP LUSV'ACS
	RELOC	ZZ
>>;END

DEFINE LUAGEN(ACS)<
LSVMAC('ACS)
LRSMAC('ACS)
LATMAC('ACS)
>
LUAGEN(<<P,T1,T2,P1,P2,M>>)

LUOPLN==^D20
LUOPDL:	BLOCK	LUOPLN
LUOPDP:	IOWD LUOPLN,LUOPDL

IVEC::
MEMPC:	0
	MEMINT
RETPC:	0
	UUOINT



UUOINT:	EXCH	T1,66		;GET INSTRUCTION
	MOVEM	T2,SAVET2
	MOVEI	T2,REEADR	;IN CASE IT GETS SMASHED
	MOVEM	T2,.JBREN##
	CAMN	T1,[-1]		;WAS IT INSTRUCTION TRAP?
	JRST	CHRINT		;NO, CHECK FOR CHARACTER.
	HRRZ	T2,RETPC	;GET PC
	CAIN	T2,USRHIB	;IF FROM HIBER LOOP STRETCHER
	JRST	UUODO		;DO IT.
	MOVE	T2,SIMPC	;GET "SIMULATED PC"
	TLNE	T2,PC.USR	;IF USER MODE AND
	TLNE	T2,PC.UIO	;NO I/O INSTRUCTIONS ALLOWED
	JRST	.+2
	JRST	UUOSIM		;USER MODE AND NO USER IOT, ALWAYS TRAPS.
	TLC	T1,700000
	TLCE	T1,700000	;IF NOT I/O INSTRUCTION,
	JRST	UUOUUO
	LDB	T2,[POINT 9,T1,11]
	ANDI	T2,774
	CAIN	T2,DTE		;IF DTE,
	JRST	DTESER		;GO FAKE A TTY
	CAIN	T2,PI
	JRST	PISER		;DO PI.
	CAIN	T2,APR		;IF ITS APR,
	JRST	APRSR		;GO FAKE CACHE SWEEPS, ETC.
	CAIN	T2,CCA		;IF CACHE,
	JRST	CCASER		;GO CALL APRINT.
	CAIN	T2,PAG		;PAGING?
	JRST	PAGSER		;YES, GO DO IT.
	CAIN	T2,SAX0		;SA-10?
	JRST	SAXSER		;YES.
	CAIN	T2,TIM
	JRST	TIMSER
	CAIN	T2,MTR
	JRST	MTRSER
BYE1::	HRRZ	T1,RETPC	;REMEMBER LAST I/O OR UUO PC
	CAIL	T1,MONDEB	;DON'T STORE IF IN SIMULATOR
	CAILE	T1,MONDBE	;END OF SIMULATOR
	JRST	.+2		;OK, NOT IN
	JRST	BYE2		;IN, DON'T STORE
	CAIL	T1,DDT##	;AND STORE IF IT WASN'T IN DDT
	CAILE	T1,DDTEND##-1
	JRST	.+2
	JRST	BYE2
	MOVEM	T1,LASPC	;SAVE LAST "REAL" PC
NOTSPC:	MOVE	T1,PIST		;GET PI STATUS
	MOVEM	T1,LASPI	;SAVE FOR PRINTOUT
BYE2:	MOVE	T1,TIMINT
	SETTIM	T1,
	  ERROR (SETTIM FAILURE IN SIMULATOR)
	HRRZ	T1,RETPC	;GET RETURN PC
	CAILE	T1,17		;IF PC IS IN ACS,
	JRST	BYE3		;ITS NOT, DISMISS NORMALLY.
	AOS	T1,LASPCC#	;GET NUMBER OF TIMES SEEN PC IN ACS
	CAIGE	T1,PCCMAX	;LOOPING TOO LONG?
	JRST	BYE3		;NO, JUST DISMISS
	SETZM	LASPCC		;TIME TO SLEEP. CLEAR COUNTER
	HRLOI	T1,(1B8+0B17)	;TURN OFF THIS INTERRUPT SO HIBER WILL WAKE ON IT.
	TINASS	T1,
	  ERROR	(TINASS FAILURE IN LOOP STRETCHER)
	JSP	T1,[EXCH T1,RETPC ;GET OLD PC AND SAVE ONE TO DISMIS TO
		   HLL T1,SIMPC ;GET SIMPC FLAGS
		   MOVEM T1,SLPPC# ;SAVE FOR RETURN TO USER
		   JRST BYE3]	;AND DISMISS NORMALLY
	MOVEM	T1,SLPT1#	;SAVE THIS
	MOVSI	T1,10		;WAIT FOR CHAR OR
	HRR	T1,TIMINT	;THIS MANY MS
	HIBER	T1,
USRHIB::  ERROR	(HIBER FAILURE IN LOOP STRETCHER)
	SETZM	SIMPC		;CLEAR THIS OUT SO TINASS WILL WORK
	HRLOI	T1,.IACHR+2	;ENABLE FOR THE INTERRUPTS AGAIN
	TINASS	T1,		;REENABLE
	  ERROR (TINASS FAILURE AFTER USRHIB)
	MOVE	T1,SLPPC	;GET SAVED SLEEP PC
	MOVEM	T1,SIMPC
	MOVE	T1,SLPT1	;RESTORE T1
	JRST	@SIMPC		;AND RETURN.

BYE3:	MOVE	T2,SAVET2
	SETO	T1,		;MARK THAT NO MORE TRAP INSTRUCTION
	EXCH	T1,66
	DISMIS
	ERROR	(SIMULATOR DID DISMIS WITH NO PI IN PROGRESS)
SAVET2:	0
LASPC:	0			;LAST NON-DDT ILLEGAL INSTRUCTION OR UUO PC.
LASPI:	0
ERRPC:	0			;PC OF AN ERROR MACRO CALL.
DDTPC::	0			;TRAP PC WHOSE TRAP RESULTED IN DDT GETTING CALLED.
DDXLOC:	0			;PC WHEN DDT DOES AN $X.
LASUUO:	0			;TEMP PLACE TO SAVE UUO


UUOUUO:	LDB	T2,[POINT 9,T1,8]
	CAIN	T2,<JRST>_-^D27
	JRST	JRSTSR
	CAIN	T2,<MAP>_-^D27	;IS IT MAP INSTRUCTION?
	JRST	MAPINS		;YES.
	CAIN	T2,<UJEN>_-^D27	;UJEN? (USED FOR EXEC XCT)
	JRST	UJEINS
	CAIN	T2,<DADD>_-^D27 ;IS IT DADD?
	JRST	SIMDAD		;YES, MUST SIMULATE IN CASE WERE ON A KI10
	HRRZ	T2,RETPC	;SEE WHERE REGULAR UUO CAME FROM
	HLL	T2,SIMPC	;GET FAKE PC BITS
	TLNE	T2,PC.USR	;IF USER MODE SET, ALWAYS SIMULATE
	JRST	UUOSIM
	HRRZS	T2		;JUST ADDRESS
	CAIE	T2,LUUXCT+1	;IF DOING SXCT OF UUO, ALWAYS SIMULATE.
	CAIN	T2,TRPLOC+1	;MAKE SURE NOT DOING A TRAP
	JRST	UUOSIM		;WE ARE, SIMULATE THE MUUO
	CAIL	T2,MONDEB	;EXECUTION OF NON-SOFT PI LEVEL SIMULATOR CODE
				; IS DONE TO THE REAL MONITOR IF SIMULATED
				; PC IS IN EXEC MODE.
	CAILE	T2,MONDBE
	JRST	.+2		;NOT FROM SIMULATOR
	JRST	UUODO		;FROM SIMULATOR, DO IT
	CAMN	T2,DDXLOC	;IF FROM DDT EXCEPT $X, DO IT.
	JRST	UUOSIM		;FROM DDT'S $X ROUTINE, SIMULATE IT.
	CAIL	T2,DDT##	;IF FROM DDT, REALLY EXECUTE IT, ELSE SIMULATE.
	CAILE	T2,DDTEND##-1
	JRST	UUOSIM		;NOT FROM DDT, FROM MONITOR, SIMULATE UUO TRAP.
UUODO:	EXCH	T1,66
	MOVE	T2,SAVET2
	XCT	66
	  JRST	.+2
	AOS	RETPC
	EXCH	T1,66
	MOVEM	T2,SAVET2
	JRST	BYE		;GO CHECK FOR PIS


ILLINS:	MESS	(ILLEGAL INSTRUCTION AT )
	MOVE	T1,RETPC
	JSR	OCTOUT
	MESS	<, LAST UUO PC WAS >
	MOVE	T1,LASPC
	JSR	OCTOUT
	MESS	<: PI STATUS WAS >
	MOVE	T1,LASPI
	JSR	OCTOUT
DDTBYE:	MOVEI	T1,DDTBAK	;BREAKPOINT AT DDTBAK.
	LDB	T2,[POINT 9,DDTBAK,8] ;SEE IF BP THERE
	CAIE	T2,<JSR>_-^D27 ;IS IT?
	JRST	[MOVEI T1,DDT##
		 MESS <<DDT>>
		JRST .+1]
	HLL	T1,RETPC	;FLAGS
	EXCH	T1,RETPC
	HLL	T1,SIMPC	;GET SIMULATED PC FLAGS
	MOVEM	T1,DDTPC	;PC THAT DDT REPLACED
	SETZM	SIMPC		;RUN AS IF IN EXEC MODE. DDTBAK RESTORES.
	MOVE	T1,DDTSYM##	;SETUP 116 FOR UDDT
	MOVEM	T1,.JBSYM##
	JRST	BYE		;AND DISMISS BACK TO DDT SO PI SYSTEM STAYS OK.

;HERE FROM DDT TO RESUME THE SIMULATION AFTER ^X

DDTBAK::EXCH	T1,DDTPC	;GET PC
	MOVEM	T1,SIMPC	;SAVE IT
	EXCH	T1,DDTPC	;RESTORE T1
	JRST	@DDTPC		;AND RETURN.


UUOSIM:	MOVEM	T1,LASUUO	;SAVE THIS HERE
	JSR	GETUPT		;GET UPT ADDRESS
	MOVE	T2,LASUUO	;GET IT BACK
	MOVEM	T2,UPTMUU(T1)	;STORE THE UUO
	SKIPN	T2,TRPPC	;USE THIS PC IF ITS A TRAP.
	MOVE	T2,RETPC	;GET PC IT CAME FROM
	HLL	T2,SIMPC	;GET PC FLAGS FROM SIMULATED WORD
	MOVEM	T2,UPTMUP(T1)	;SAVE IT
	SKIPE	TRPPC		;IS THIS "TRAP CYCLE" (PDL OVERFLOW)
	JRST	[SETZM TRPPC	;YES, WE'VE SEEN IT NOW
		 TLNE T2,PC.USR
		 SKIPA T2,UPTPTR(T1)
		 MOVE T2,UPTKTR(T1)
		 JRST UUOSI1]
	TLNE	T2,PC.USR	;IF FROM USER MODE, MUST
	SKIPA	T2,UPTPNT(T1)	;DISPATCH FROM PNT
	MOVE	T2,UPTKNT(T1)	;GET KERNEL NO TRAP PC WORD
UUOSI1:	HRRM	T2,RETPC	;DISMISS TO UUO ROUTINE IN MONITOR
	HLLM	T2,SIMPC	;SET NEW SIMULATED PC FLAGS TO THE ONES FROM UPT.
	JRST	BYE		;TAKE CARE OF PIS, THEN RESTORE ACS AND RETURN.
JRSTPC:	0			;PC OF LAST JRST
SIMPC::	0			;LH HAS PC FLAGS OF VIRTUAL MACHINE

;HERE FOR EXEC XCT - THE XCT IS REPLACED WITH UJEN INSTRUCTION
; USED TO BE LUUO, BUT CHANGED SO EXEC MODE PROGS COULD
; USE LUUO THEMSELVES.

UJEINS:	HRRZ	T2,RETPC	;WHERE IT CAME FROM
	MOVEM	T2,LUUOH	;MAKE BELIEVE IT CAME FROM HERE
	MOVEM	T1,LUUO		;STORE THE INSTRUCTION HERE
	MOVEI	T1,LUUOH+1	;RETURN TO LUUOH+1
	HRRM	T1,RETPC	;
	JRST	BYE		;AND GO.

SIMDAD:	MOVEM	T1,SAVDAD#	;SAVE THE INSTRUCTION
	MOVEI	T1,1(T1)	;GET ADDRESS OF LO ORDER WORD IN T1
	JSR	FETCH
	MOVEM	T2,DADDAT#	;SVE THE DATA
	LDB	T1,[POINT 4,SAVDAD,12] ;GET HI AC NUMBER
	ADDI	T1,1		;GET LO ORDER AC NUMBER
	JSR	FETCH		;GET DATA INTO T2
	ADD	T2,DADDAT	;GET LO ORDER SUM INTO T2
	SETZM	DADCRY#		;CLEAR FLAG
	TLZE	T2,(1B0)	;IF SIGN BIT SET
	AOS	DADCRY		;SET IT TO 1
	JSR	STORE		;STORE DATA BACK
	HRRZ	T1,SAVDAD	;GET HI ADDR
	JSR	FETCH
	MOVEM	T2,DADDAT	;SVE IT
	LDB	T1,[POINT 4,SAVDAD,12]
	JSR	FETCH
	ADD	T2,DADDAT
	ADD	T2,DADCRY
	JSR	STORE
	JRST	BYE		;AND RETURN.

DTESER:	LDB	T2,[POINT 3,T1,12] ;GET CODE
	XCT	DTETAB(T2)		;DISPATCH

DTETAB:	JRST	BYE		;BLKI
	JRST	BYE		;DATAI
	JRST	BYE		;BLKO
	JRST	BYE		;DATAO
	JRST	DTECNO
	JRST	DTECNI
	JRST	DTECSZ		;CONSZ
	JRST	DTECSO		;CONSO

DTECNI:	MOVE	T2,DTEST
	JSR	STORE
	JRST	BYE

DTECSZ:	HRRZS	T1
	TDNN	T1,DTEST
	AOS	RETPC		;ALL ARE ZERO, SKIP
	JRST	BYE

DTECSO:	HRRZS	T1
	TDNE	T1,DTEST
	AOS	RETPC
	JRST	BYE


DTECNO:	MOVEM	T1,SAVDTC	;SAVE DTE CONO INSTRUCTION
	MOVE	T2,T1
	ANDI	T2,17
	TRNE	T1,PILDEN	;IF BIT SAYS TO LOAD IT,
	DPB	T2,[POINT 4,DTEST,35] ;SET PI ASSIGNMENT AND PI0 ENABLE.
	TRNN	T1,TO11DB	;IS CALLER HITTING DOORBELL?
	JRST	DTECO1		;NO, CHECK CL11PT
	JSR	GETEPT		;GET EPT ADDRESS
	MOVE	T1,SPCCMW(T1)	;GET CODE
	MOVE	T2,T1		;GET CODE
	ANDI	T2,777400	;JUST COMMAND

	CAIE	T2,.DTCTO
	JRST	DTESR1
	ANDI	T1,177
	OUTCHR	T1
	JSR	GETEPT
	SETOM	SPCMTD(T1)
	JSR	DTEIRP		;SET DOORBELL, GIVE IRP IF ENABLED.
	JRST	DTECO1

DTESR1:	CAIE	T2,.DTRSW
	JRST	DTESR2		;GO CHECK FOR ENTER MONITOR MODE
	MOVE	T2,DTESWT	;GET DTE SWITCHES
	JSR	GETEPT
	MOVEM	T2,SPCF11(T1)
	SETOM	SPCFLG(T1)	;SET FLAG WORD
	JSR	DTEIRP		;SET DOORBELL, GIVE IRP IF ENABLED.
	JRST	DTECO1

DTESR2:	CAIE	T2,.DTESP
	JRST	DTECO1
	JSR	GETEPT
	SETOM	SPCFLG(T1)
	JSR	DTEIRP		;SET DOORBELL, GIVE IRP IF ENABLED.

;HERE ON CHARACTER INTERRUPT OR WHEN CONO DTE,CL11PT HAPPENS.

DTECO1:	MOVE	T1,SAVDTC
	TRNN	T1,CL11PT	;CLEARING TO-10 DOORBELL?
	JRST	BYE		;NO, JUST RETURN.
	MOVEI	T1,TO10DB
	ANDCAM	T1,DTEST	;CLEAR IT
	JRST	BYE		;AND EXIT. TIMER INTERRUPT WILL SEE WHEN MTI GOES OFF AND START
				; ANOTHER CHAR.

DTEIRP:	0
	MOVEI	T1,TO10DB	;SET DOORBELL
	IORB	T1,DTEST
	ANDI	T1,7		;GET JUST PI ASSIGNMENT
	JUMPE	T1,@DTEIRP	;GO IF NO INTERRUPT
	HRLI	T1,EPTDT0+DTEDII ;VECTOR ADDRESS
	JSR	VECTPI		;GENERATE A VECTOR INTERRUPT
	JRST	@DTEIRP		;AND RETURN.

CHRINT:	HRRZ	T1,RETPC	;GET PC
	TLNE	T1,PC.USR	;DDT IN USER MODE IS OK
	JRST	CHRIN0
	CAIL	T1,DDT##	;IF IN DDT, DON'T EAT CHARACTER
	CAILE	T1,DDTEND##-1
	JRST	.+2		;NOT FROM DDT
	JRST	BYE		;FROM DDT, LET IT READ CHAR AND DON'T CHECK TIMER (NO IRPS OUT OF DDT)
CHRIN0:	MOVEI	T1,200		;NO ECHO
	SETMOD	T1,
	HRROI	T1,.GTSTS	;GETTAB JBTSTS
	GETTAB	T1,
	  ERROR (GETTAB FOR JBTSTS FAILED)
	TRO	T1,JACCT2	;NO CONTROL CS
	SETJAL	T1,
	  ERROR (SETJAL FAILURE)
GETICH:	SKPINC			;ANY CHARS WAITING IN MONITOR'S BUFFER OR
	SKIPE	CBUCHR		;OURS?
	JRST	.+2		;YES, ONE OR THE OTHER
	JRST	TIMCHK		;NO CHARS AT ALL, CHECK TIMER.
	HRROI	T2,.AXI8S	;INPUT IMAGE CHAR AND SKIP IF THERE
	AUXCAL	T2,T2
	  JRST	CHRIN1		;MUST BE CHARS IN OUR BUFFER THEN.
	
	ANDI	T2,177		;NO PARITY BIT
	MOVE	T1,LASCHR#	;GET LAST CHARACTER
	MOVEM	T2,LASCHR
	CAIN	T2,12		;IF ITS LINE FEED AND
	CAIE	T1,15		;LAST INPUT WAS A CR,
	JRST	.+2		;(NOT)
	JRST	GETICH		;THEN IGNORE THE LINE FEED.
	CAIE	T2,"X"-100	;CONTROL X IS ESCAPE
	JRST	GETIC1
	HLRZ	T1,DDTBAK
	ANDI	T1,777000
	CAIN	T1,(JSR)	;SKIP IF NOT INSIDE DDT, HALT AND CONTINUE WILL RESUME.
	JRST	DDTBYE		;IF PC WASN'T IN DDT, OK TO GO
	MESS	([SIMKL:DDT ALREADY ENTERED OR NO BREAKPOINT AT DDTBAK - TYPE CONT (OR DDT IF DESPERATE)])
	HALT	.+1
GETIC1:	AOSLE	CBUCHK		;MAKE SURE NO OVERFLOW
	ERROR	(CHARACTER BUFFER OVERFLOW)
	AOS	CBUCHR		;OK, ONCE MORE IN BUFFER
	IDPB	T2,CBUPUT	;PUT IT INTO BUFFER
CHRIN1:	JSR	GETEPT		;GET EPT ADDRESS IN T1
	SKIPE	CBUCHR		;IF NO CHARS WAITING OR
	SKIPE	SPCMTI(T1)	;HE HAS NOT CLEARED FLAG
	JRST	TIMCHK		;THEN NOTHING TO DO
	ILDB	T2,CBUTAK	;OK, GET NEXT CHAR
	MOVEM	T2,SPCF11(T1)	;GIVE CHAR TO HIM
	SETOM	SPCMTI(T1)	;SET INPUT DONE FLAG
	JSR	DTEIRP		;SET DOORBELL, GIVE IRP IF ENABLED
	SOSLE	CBUCHR		;ONE LESS IN BUFFER. EMPTY NOW?
	JRST	TIMCHK		;NO, CHECK TIMER
	SETZM	CBUCHR		;IN CASE WENT NEGATIVE
	MOVNI	T1,CBUSIZ	;GET NUMBER OF CHARS
	MOVEM	T1,CBUCHK	; BUFFER HOLDS FOR OVERFLOW CHECK LOC
	MOVE	T1,[POINT 7,CBUBUF] ;RE-INIT POINTERS
	MOVEM	T1,CBUPUT
	MOVEM	T1,CBUTAK	;FOR BOTH PUT AND TAKE.
	JRST	TIMCHK		;AND RETURN.

CBUSIZ==^D80			;HOW MANY CHARACTERS WE CAN BUFFER BEFORE BARFING.
CBUCHR:	0			;COUNT OF CHARS IN BUFFER
CBUTAK:	POINT 7,CBUBUF		;TAKE POINTER
CBUPUT:	POINT 7,CBUBUF		;PUT POINTER
CBUCHK:	-CBUSIZ			;OVERFLOW CHECKING LOCATION
CBUBUF:	BLOCK	<CBUSIZ+5>/5		;ROOM FOR 80 CHARACTERS
DTESWT:	4			;SWITCHES.

;HERE AFTER TAKE CARE OF INPUT CHARACTERS TO CREATE INTERVAL TIMER
; INTERRUPT IF NECESSARY.
TIMCHK:	MOVS	T1,TIMST	;GET STATUS,,INTERVAL
	TLNN	T1,TI.TIO	;IS TIMER ON
	JRST	BYE		;NO, JUST DISMISS
	TLZ	T1,-1		;YES, LEAVE CURRENT INTERVAL IN T1
	ADD	T1,TIMFAC	;THIS MANY COUNTS PER TRIP THRU HERE
REPEAT 0,<
	MOVEI	T2,TI.TOV	;OVERFLOW?
	TRNE	T1,770000
	IORM	T2,TIMST	;YES.
>;END REPEAT 0
	DPB	T1,[POINT 12,TIMST,17] ;PUT IT BACK
	HRRZ	T2,TIMST	;GET PERIOD REGISTER
	ANDI	T2,7777		;JUST PERIOD REGISTER CONTENTS
	CAMGE	T1,T2		;TIME TO INTERRUPT?
	JRST	BYE		;NO.
	MOVEI	T1,TI.ITD
	IORM	T1,TIMST
	MOVE	T1,MTRST	;GET PI ASSIGN
	ANDI	T1,7
	JUMPE	T1,BYE		;NONE, GO AWAY
	HRLI	T1,EPTITI	;PLACE TO VECTOR TO
	JSR	VECTPI		;SET THE INTERRUPT
	JRST	BYE		;AND RETURN.

SAVDTC:	0			;SAVE CONO DTE, HERE
DTEST:	0			;DTE CONI WORD

;HERE WITH I/O INSTRUCTION FOR APR IN T1

AB.USR==40			;USER ADDRESS BREAK FLAG

APRSR:	LDB	T2,[POINT 3,T1,12] ;GET CODE
	XCT	APRTAB(T2)		;DISPATCH

APRTAB:	JRST	BYE		;BLKI
	JRST	BYE		;DATAI
	JRST	BYE		;BLKO
	JRST	ADRBRK		;DATAO - DO ADDRESS BREAK
	JRST	APRCNO
	JRST	APRCNI
	JRST	APRCSZ		;CONSZ
	JRST	APRCSO		;CONSO

APRCNI:	MOVE	T2,APRST	;DATA TO STORE
	JSR	STORE		;STORE IT
	JRST	BYE		;AND RETURN.

APRCSZ:	HRRZS	T1		;GET BITS
	TDNN	T1,APRST	;ARE THE BITS ALL OFF?
	AOS	RETPC		;YES, SKIP
	JRST	BYE		;RETURN.

APRCSO:	HRRZS	T1
	TDNE	T1,APRST	;ARE ANY BITS ON?
	AOS	RETPC		;YES, SKIP
	JRST	BYE		;RETURN.

APRCNO:	TRNN	T1,LP.CSF	;CLEAR FLAGS?
	JRST	APRCO1		;NO
	MOVE	T2,T1		;GET FLAGS HE WANTS CLEARED
	ANDI	T2,7760
	ANDCAM	T2,APRST	;CLEAR THEM
APRCO1:	TRNN	T1,LP.SSF	;SET FLAGS?
	JRST	APRCO2		;NO
	MOVE	T2,T1
	ANDI	T2,7760
	IORM	T2,APRST

APRCO2:	TRNN	T1,LP.ESF	;ENABLE?
	JRST	APRCO3		;NO
	MOVE	T2,T1
	ANDI	T2,7760
	MOVSS	T2
	IORM	T2,APRST

APRCO3:	TRNN	T1,LP.DSF	;DISABLE?
	JRST	APRCO4		;NO
	MOVE	T2,T1
	ANDI	T2,7760
	MOVSS	T2
	ANDCAM	T2,APRST

APRCO4:	TRNN	T1,APRIOB	;I/O BUS RESET?
	JRST	APRSPI		;NO
	SETZM	APRST		;YES, CLEAR OUT APR STATUS
	SETZM	DTEST		;AND DTE STATUS
	SETZM	SAXST		;AND SA-10 STATUS
APRSPI:	ANDI	T1,7
	DPB	T1,[POINT 3,APRST,35]
	MOVEI	T1,LP.CSD	;ALWAYS LEAVE CACHE SWWP DONE SET.
	IORM	T1,APRST
	JRST	BYE



ADRBRK:	JSR	FETCH		;GET DATAO WORD
	MOVEM	T2,ABKST	;REMEMBER IT
	TLO	T2,AB.USR	;SET USR FOR UUO.
	SETABK	T2,		;SET IT
	  JFCL		;WON'T WORK ON KI 10S.
	JRST	BYE		;AND RETURN.

ADRBRI:	MOVE	T2,ABKST
	JSR	STORE
	JRST	BYE		;RETURN A LITTLE MORE THAN KL DOES.
APRST:	0
ABKST:	0

CCASER:	MOVEI	T2,LP.CSD
	IORB	T2,APRST	;GET APR STATUS IN T2 ALSO
	TLNN	T2,LP.CSD	;ENABLED FOR SWEEP DONE?
	JRST	BYE		;NO, JUST RETURN
	ANDI	T2,7
	MOVE	T1,T2		;GET PI CHANNEL INTO T1
	JSR	MAKPI		;AND GO DO A PRIORITY INTERRUPT
	JRST	BYE

;SERVICE FOR DEVICES MTR AND TIM


TIMSER:	LDB	T2,[POINT 3,T1,12] ;GET CODE
	XCT	TIMTAB(T2)		;DISPATCH

TIMTAB:	JRST	BYE		;BLKI
	JRST	BYE		;DATAI
	JRST	BYE		;BLKO
	JRST	BYE		;DATAO
	JRST	TIMCNO
	JRST	TIMCNI
	JRST	TIMCSZ		;CONSZ
	JRST	TIMCSO		;CONSO

TIMCNO:	DPB	T1,[POINT 12,TIMST,35] ;SET PERIOD REGISTER
	TRNE	T1,TO.CIT	;CLEAR TIMER?
	SETZM	TIMST		;YES.
	MOVEI	T2,TI.ITD	;TIMER DONE FLAG
	TRNE	T1,TO.CTD
	ANDCAM	T2,TIMST
	MOVEI	T2,TI.TIO
	TRNN	T1,TO.SIT	;START?
	JRST	BYE		;NO.
	IORM	T2,TIMST	;YES.
	JRST	BYE		;EXIT.
	JRST	BYE		;AND RETURN.

	PCCMAX==^D2		;HOW LONG PC STAYS IN ONE PLACE BEFORE WE DECIDE TO HIBERNATE FOR A TIMINT INTERVAL.
TIMFAC:	^D1667			;HOW MUCH TO DECREMENT TIMER BY ON ONE SOFTWARE INTERRUPT
TIMINT:	^D56			;MS BETWEEN DECREMENTING INTERVAL BY TIMFAC.
				;IF TOO SHORT, CAN SATURATE SIMULATION WITH
				; CLOCK INTERRUPTS. IF TOO LONG,
				; GET JERKY RESPONSE. SET BY EXPERIMENT ON
				; KL10 AND 2020.

TIMCNI:	MOVE	T2,TIMST	;GET TIMER
	JSR	STORE		;GIVE IT TO HIM
	JRST	BYE		;RETURN.

TIMCSO:	HRRZS	T1
	TDNE	T1,TIMST
	AOS	RETPC
	JRST	BYE

TIMCSZ:	HRRZS	T1
	TDNN	T1,TIMST
	AOS	RETPC
	JRST	BYE

TIMST:	0

;SERVICE FOR MTR DEVICE

MTRSER:	LDB	T2,[POINT 3,T1,12] ;GET CODE
	XCT	MTRTAB(T2)		;DISPATCH

MTRTAB:	JRST	GIVMBC		;BLKI (RETURN MBOX CYCLES)
	JRST	GIVEBC		;DATAI (RETURN EBOX CYCLES)
	JRST	BYE		;BLKO
	JRST	BYE		;DATAO
	JRST	MTRCNO
	JRST	MTRCNI
	JRST	MTRCSZ		;CONSZ
	JRST	MTRCSO		;CONSO

MTRCNO:	ANDI	T1,MI.AIP+MI.AEN+MI.AO+MI.TON+MI.IPI
	MOVEM	T1,MTRST
	JRST	BYE

MTRCNI:	MOVE	T2,MTRST
	JSR	STORE
	JRST	BYE

MTRCSZ:	HRRZS	T1
	TDNN	T1,MTRST
	AOS	RETPC
	JRST	BYE

MTRCSO:	HRRZS	T1
	TDNE	T1,MTRST
	AOS	RETPC
	JRST	BYE

EBXCPR==200000		;COUNTS PER READ
MBXCPR==100000		; CHOSEN TO APPROXIMATE KL MICROCYCLE RATE.
GIVMBC:	MOVEM	T1,SAVMTI#	;SAVE THE INSTRUCTION
	JSR	GETUPT		;GET USER'S UPT
	ADDI	T1,UPTHMC	;GET ADDRESS OF 2 WORD THING
	MOVSI	T2,MBXCPR	;GET COUNTS PER READ
	JRST	GIVCYC		;AND GIVE IT.

GIVEBC:	MOVEM	T1,SAVMTI	;SAVE PLACE TO RETURN VALUE TO
	JSR	GETUPT
	ADDI	T1,UPTHEC	;ADDRESS OF TWO WORD THINGY
	MOVSI	T2,EBXCPR	;GET EBOX COUNTS PER READ
;	JRST	GIVCYC		;FALL INTO GIVCYC
GIVCYC:	ADD	T2,1(T1)	;GET NEW TOTAL
	TLZE	T2,(1B0)	;OVERFLOW?
	AOS	0(T1)		;YES
	MOVEM	T2,1(T1)	;SAVE.
	EXCH	T1,SAVMTI	;GET ADDRESS TO STORE BACK IN T1, SAVE UPT ADDRESS
	AOS	T1		;STORE IN 2ND WORD
	JSR	STORE
	SOS	T1		;BACK TO 1ST WORD
	EXCH	T1,SAVMTI
	MOVE	T2,0(T1)	;GET HI ORDER WORD
	EXCH	T1,SAVMTI
	JSR	STORE		;SAVE THAT AT FIRST ADDRESS
	JRST	BYE		;AND RETURN. BYE FIXES UPT BACK.

MTRST:	0

;HERE WITH I/O INSTRUCTION FOR PI IN T1

PISER:	LDB	T2,[POINT 3,T1,12] ;GET CODE
	XCT	PITAB(T2)		;DISPATCH

PITAB:	JRST	BYE		;BLKI
	JRST	BYE		;DATAI
	JRST	BYE		;BLKO
	JRST	BYE		;DATAO
	JRST	PICNO
	JRST	PICNI
	JRST	PICSZ		;CONSZ
	JRST	PICSO		;CONSO

PICNO:	TRNN	T1,LI.CPS	;CLEAR PI SYSTEM?
	JRST	PISER1		;NO
	MOVE	T2,[PICLR,,PICLR+1]
	SETZM	PICLR
	BLT	T2,PICLE	;CLEAR OUT EVERYTHING.
	JRST	BYE		;RETURN

PISER1:	MOVEI	T2,LI.PIN	;GET READY
	TRNE	T1,LI.PIN
	IORM	T2,PIST
	TRNE	T1,LI.PIF
	ANDCAM	T2,PIST
	MOVE	T2,T1
	ANDI	T2,177		;JUST CHANNELS
	TRNE	T1,LI.COF
	ANDCAM	T2,PIST
	TRNE	T1,LI.CON
	IORM	T2,PIST
	MOVSS	T2		;GET BITS IN LH
	TRNE	T1,LI.REQ	;PROGRAM REQUEST?
	IORM	T2,PIST		;YES, SET THEM
	TRNE	T1,LI.CPP	;CLEAR PROGRAM REQUEST?
	ANDCAM	T2,PIST		;YES, CLEAR.
	JRST	BYE

PICNI:	MOVE	T2,PIST		;DATA
	JSR	STORE		;STORE INTO CALER AREA
	JRST	BYE

PICSZ:	HRRZS	T1		;JUST BITS
	TDNN	T1,PIST		;IF ALL BITS ARE OFF,
	AOS	RETPC		;SKIP
	JRST	BYE

PICSO:	HRRZS	T1
	TDNE	T1,PIST
	AOS	RETPC
	JRST	BYE

;ROUTINE TO GENERATE A VECTOR INTERRUPT. VECTOR IS SET IN
; PIVECT+CHANNEL NUMBER. ONLY ONE PENDING VECTOR INTERRUPT
; PER PI CHANNEL IS ALLOWED.
; T1/EPT RELATIVE ADDRESS OF JSR,,CHANNEL NUMBER

VECTPI:	0
	SKIPN	T2,PIVECT-1(T1)	;ALREADY ONE WAITING?
	JRST	VECTP1		;NO
	TSC	T2,T1		;RH(T2)GETS ZERO IF THE SAME VECTOR ADDRESS
	TRNE	T2,-1		;OK IF SAME ADDRESS, JUST GET 2 INTERRUPTS
	ERROR	(TWO PENDING VECTOR INTERRUPT ADDRESSES NOT SUPPORTED)
	JRST	@VECTPI		;ALREADY PENDING, JUST DISMISS.
VECTP1:	HLRZM	T1,PIVECT-1(T1)	;SET VECTOR ADDRESS
	JSR	MAKPI		;SET PIPEND FOR CHANNEL
	JRST	@VECTPI		;AND RETURN.
;ROUTINE TO CAUSE AN INTERRUPT ON CHANNEL IN (T1)
; USES T1, T2

MAKPI:	0
	AOS	PICNT-1(T1)	;NUMBER OF REQUESTS WAITING.
	MOVEI	T2,1B35_7
	MOVNS	T1
	LSH	T2,(T1)
	IORM	T2,PIPEND	;MAKE IT PENDING
	JRST	@MAKPI

BYE:	HRRZ	T1,RETPC	;GET RETURN PC
	CAIL	T1,DDT##	;DON'T NTERRUPT OUT OF DDT
	CAILE	T1,DDTEND##-1
	JRST	.+2		;OK
	JRST	BYE2		;EXIT REAL QUICK.
	MOVE	T1,PIPEND	;GET PENDING PI BITS
	AND	T1,PIST		;GET ONLY CHANNELS THAT ARE ON
	HLRZ	T2,PIST		;GET CURRENT PROGRAM REQUESTS
	IOR	T1,T2		;THESE COME IN EVEN IF CHANEL IS OFF.
				; (THATS THE WAY THE HARDWARE WORKS!)
	ANDI	T1,177		;JUST CHANNEL STUFF
	MOVE	T2,PIST		;GET PIST
	TRNN	T2,LI.PIN	;PI ON?
	JRST	BYE1		;NO, DON'T INTERRUPT
	JFFO	T1,.+2		;GET CHANNEL NUMBER IF ANY
	JRST	BYE1		;NONE, RETURN.
	MOVEI	T1,-^D35+^D7(T2) ;GET CHANNEL NUMBER
	MOVEM	T1,HICHAN	;REMEMBER CHANNEL WE ARE CREATING IRP FOR.
	MOVN	T2,T1		;GET -VE PI CHANNEL NUMBER
	MOVE	T1,[17,,700000]	;MAKE MASK FOR PI IN PROGRESS
	LSH	T1,(T2)		;GET BIT FOR THIS PI CHANNEL.
	ANDI	T1,077400	;JUST PENDING BITS
	TDNE	T1,PIST		;SKIP IF NO PIS GREATER OR EQUAL IN PROGRESS
	JRST	BYE1		;ALREADY ONE OF AT LEAST PRIORITY OF HIGHEST PENDING.
	ANDCMI	T1,-1(T1)	;GET LOWEST 1 BIT (OUR PENDING)
	IORM	T1,PIST		;IS NOW IN PROGRESS
	LSH	T1,-^D8		;TURN IT INTO THE BIT FOR PIPEND (1B35 = CH7)
	MOVE	T2,HICHAN	;GET CHANNEL NUMBER
	SOSG	PICNT-1(T2)	;IF THIS IS LAST REQUEST ON CHANNEL,
	ANDCAM	T1,PIPEND	;CAN SET ITS NO LONGER PENDING
	SKIPE	T1,PIVECT-1(T2)	;IS THERE A VECTOR INTERRUPT WAITING?
	JRST	[SETZM PIVECT-1(T2) ;YES.
		 MOVEI T2,-40(T1) ;WILL ADD 40 BELOW
		 JRST .+2]	;USE EPT RELATIVE VECTOR ADDRESS INSTEAD.
	LSH	T2,1		;*2
	JSR	GETEPT		;GET EPT ADDRESS
	ADDI	T2,40(T1)	;GET INTERRUPT CELL ADDRESS.
	MOVE	T1,RETPC	;GET OLD RETURN PC
	HLL	T1,SIMPC	;GET PC FLAGS FROM SIMULATE WORD
	SETZM	SIMPC		;WE ARE NOW IN EXEC MODE
	MOVEM	T1,@(T2)	;PUT IN INTERRUPT JSR PLACE
	MOVSI	T1,PC.FPD!PC.ADR	;COPY THESE BITS FROM REAL PC
	AND	T1,RETPC	;AND IF EITHER OF THEM ARE ON,
	IORM	T1,@(T2)	;MUST TURN THEM ON FOR INTERRUPT DISMISS
	MOVEI	T2,@(T2)	;GET ADDRESS OF INTERRUPT ROUTINE
	ADDI	T2,1		;SKIP OVER PC WORD
	HRRZM	T2,RETPC	;AND WHEN RETURN, DO INTERRUPT JSR
	JRST	BYE1		;RETURN.

PICLR:				;FIRST LOC TO CLEAR TO CLEAR PI SYSTEM
PIST:	0			;CONI WORD FOR PI SYSTEM
PIPEND:	0
PIVECT:	BLOCK	7		;ONE LOCATION PER PI CHANNEL FOR VECTOR ADDRESS
PICNT:	BLOCK	7		;NUMBER OF REQUESTS ON CHANNEL.
HICHAN:	0			;PLACE TO STORE CHANNEL TO GENERATE INTERRUPT ON
PICLE==.-1

;HERE ON A JRST INSTRUCTION, INSTRUCTION IN T1
; IMPORTANT! - THIS CODE ASSUMES THE EXEC MODE PROGRAM HAS BEEN
; PATCHED TO TURN OFF PC.USR+PC.PUB IN ALL CASES WHERE IT USES
; THAT PC TO DO A JEN THRU. ALSO ASSUMES EXEC PROGRAM NEVER
; TRIES TO SET USER MODE VIA A JRSTF (DOESN'T TRAP), ONLY THRU JEN.

;PC TRANSITIONS (PAGE FAIL, UUO, INTERRUPTS)
; OLD PC _ LH(SIMPC) + RH(REAL PC) + PC.FPD!PC.ADR(REAL PC)
; SIMPC _ LH(NEW PC WORD) (NEVER HAS PC.FPD OR PC.ADR ON)
; REAL PC _ PC.USR+PC.PUB+ NEW PC WD

;FOR JEN AND JRSTF (DIRECT PC REPLACEMENT)
; SIMPC _ LH(NEW PC WORD) - PC.FPD - PC.ADR (IF JRSTF, -PC.USR-PC.PUB)
; REAL PC _ PC.USR+PC.PUB+LH(NEW PC WORD)+RH(NEW PC WORD)

;WE TURN PC.USR AND PC.PUB OFF IN JRSTF SO MONITOR CAN USE IT TO TURN
; PC.UIO ON AND OFF, AND NO WAY TO TRAP JSP TO HIDE PC.USR AND PUB.
;PC.FPD AND PC.ADR NEVER GET TURNED ON IN SIMPC, ELSE THERE WOULD BE NO WAY
; TO CLEAR THEM AFTER THE INSTRUCTION COMPLETED. INSTEAD, THEY ARE SAVED
; FROM THE REAL PC INTO THE OLD PC, AND WHEN JEN IS DONE TO RESTORE TO
; THE OLD PC IT IS TURNED ON IN THE NEW PC FROM THE OLD PC ARG, BUT
; NOT IN SIMPC. IF AN INTERRUPT INTERVENES, PC.FPD AND PC.ADR WILL BE SAVED FROM
; THE REAL PC.

JRSTSR:	LDB	T2,[POINT 4,T1,12] ;GET AC FIELD
	CAIE	T2,4		;UNLESS HALT,
	JRST	JRSTS1
	MESS	<KL10 HALTED PC />
	JSR	OCTOUT
	EXCH	T1,RETPC	;PUT NEW PC IN
	HLLM	T1,RETPC
	MESS	< VMA/>
	JSR	OCTOUT
	EXIT	1,
	JRST	BYE

JRSTS1:	HRRZM	T1,SIMPC	;SET RH OF SIMPC TO NEW PC, JRSTPC GETS OLD, FOR DEBUGGING.
	EXCH	T1,RETPC	;SET NEW PC, GET OLD ONE
				;FLAGS GET SET BELOW.
	SUBI	T1,1		;POINT TO ACTUAL PLACE OF JRST
	MOVEM	T1,JRSTPC	;REMEMBER PC OF LAST JEN

JRSTS2:	JSR	FETCH		;GET C(T1) IN T2
	TLNN	T2,(@)		;INDIRECT?
	JRST	JRSTS3		;NO, EITHER GET FROM INDEX AC OR INSTRUCTION
	HLRZ	T1,T2
	ANDI	T1,17
	SKIPE	T1
	MOVE	T1,@ACTAB(T1)	;GET INDEX AC
	ADDI	T1,(T2)		;GET NEXT WORD TO FETCH
	JRST	JRSTS2
JRSTS3:	HLRZ	T1,T2		;GET INDEX AC NUMBER
	ANDI	T1,17
	JUMPE	T1,JRSTS4	;IF NO INDEXING EITHER, USE INSTRUCTION WORD (IN T2)
				;LIKE REAL MACHINE DOES
	MOVE	T2,@ACTAB(T1)	;PC COMES FROM INDEX AC
JRSTS4:	MOVE	T1,T2		;GET COPY OF NEW FLAGS
	TLZ	T1,PC.ADR+PC.FPD ;THESE NEVER APPEAR IN SIMPC
	HLLM	T1,SIMPC	;PUT THOSE IN SIMPC.
	TLO	T2,PC.USR+PC.PUB	;MAKE IT A GOOD PC TO RETURN THRU
	HLLM	T2,RETPC	;STORE SO THE NEW FLAGS REALLY GET SET.
	LDB	T2,[POINT 4,@JRSTPC,12] ;GET AC FIELD OF JRST AGAIN.
	CAIE	T2,12		;JEN?
	JRST	JRSTFX		;NO, DO A JRSTF, CLEAR USER FLAGS
	MOVE	T1,PIST		;GET PI STATUS
	LSH	T1,-^D8		;GET IN PROGRESS FLAGS RIGHT JUSTIFIED
	ANDI	T1,177
	JFFO	T1,.+2		;JUMP IF A PI WAS IN PROGRESS
	JRST	BYE		;WASN'T, JUST RETURN.
	MOVNS	T2
	MOVSI	T1,(1B0)
	LSH	T1,^D8(T2)	;GET PI IN PROGRESS BIT FOR CHANNEL IN PROGRESS
	ANDCAM	T1,PIST		;THIS ONE NO LONGER IN PROGRESS
	JRST	BYE

;HERE FOR NON-JEN, MUST CLEAR PC.USR AND PC.PUB IN CASE MONITOR
; DOES JSP AC, THEN JRSTF (AC). ASSUMES MONITOR NEVER USES JRSTF
; INSTEAD OF JEN TO DISMISS BACK TO USER MODE.

JRSTFX:	MOVSI	T1,PC.USR+PC.PUB
	ANDCAM	T1,SIMPC
	JRST	BYE

;PAGING SIMULATOR. SIMULATES PAGING FROM 340 TO 777, USING
; PAGES BELOW 340 IN SIMULATOR ADDRESS SPACE TO REPLICATE FROM.
OPDEF VCLEAR [CALLI -66]
OPDEF VREPLC [CALLI -64]
OPDEF GETPFW [CALLI -121]
PAGSER:	LDB	T2,[POINT 3,T1,12]	;I/O DISPATCH
	XCT	PAGTAB(T2)

PAGTAB:	JRST	BYE		;BLKI
	JRST	PAGDTI		;DATAI
	JRST	PAGCPT		;BLKO (CLRPT)
	JRST	PAGDTO		;DATAO
	JRST	PAGCNO		;CONO
	JRST	PAGCNI		;CONI
	JRST	PAGCSZ		;CONSZ
	JRST	PAGCSO		;CONSO

PAGDTI:	MOVE	T2,UBRST	;GET DATAI PAG WORD
	TLO	T2,700000	;ALL LOAD BITS ARE SET BY HARDWARE.
	JSR	STORE		;GIVE TO SER
	JRST	BYE

PAGCNI:	MOVE	T2,EBRST
	JSR	STORE
	JRST	BYE

PAGDTO:	JSR	FETCH		;GET C(T1) INTO T2
	TLZ	T2,200077	;CLEAR SECTION BITS
	TRZ	T2,LG.IAM	;AND INHIBIT ACCT SOTRE
	MOVEM	T2,PAGDTW#	;REMEMBER BIT SETTINGS FOR LATER
	TLZE	T2,(LG.LUB)	;SET UBR?
	HRRM	T2,UBRST	;YES
	TLZN	T2,(LG.LAB)	;SET AC BLOCKS?
	JRST	PAGDO1
	HLLM	T2,NUBRST	;YES, THIS WILL BE THE NEW ONE.
	MOVE	T2,UBRST	;GET OLD SETTING OF CURRENT AC BLOCK
	LSH	T2,-^D18-^D9	;GET OLD CURRENT AC BLOCK SETTING
	ANDI	T2,7
	IMULI	T2,20		;HOW FAR INTO ACDTAB
	ADDI	T2,ACDTAB+17	;PLACE TO STORE 17
	MOVEM	T2,ACDPTR	;SO DON'T NEED AC
	MOVE	T1,66
	MOVE	T2,SAVET2	;RESTORE ACS
	MOVEM	17,@ACDPTR	;SAVE 17
	MOVE	17,ACDPTR	;GET POINTER
	SUBI	17,17		;ADDRESS TO STORE 0 INTO
	MOVEM	16,16(17)	;STORE 16 TOO
	MOVEI	16,15(17)	;LAST ADDRESS TO STORE INTO
	BLT	17,(16)		;SAVE OLD AC BLOCK
	MOVE	17,NUBRST	;GET NEW
	HLLM	17,UBRST	;SET IT
	LSH	17,-^D18-^D9	;JUST NEW CURRENT BLOCK SETTING
	ANDI	17,7
	IMULI	17,20
	MOVSI	17,ACDTAB(17)	;WHERE TO BLT NEW ACS FROM
	BLT	17,17		;GET THEM
	MOVEM	T1,66
	MOVEM	T2,SAVET2
PAGDO1:	MOVE	T2,PAGDTW	;GET BITS AGAIN
PAGDO2:	TLNN	T2,(LG.LUB)	;HAVE TO CLEAR PAGE TABLE?
	JRST	BYE		;NO, RETURN.
	JRST	FIXMAP		;YES.

PHYOFS==1			;VP+PHYOFS=FP IN PHYSICAL MEM FILE

PAGCNO:	HRRZM	T1,EBRST	;JUST SET
;	JRST	FIXMAP		;AND FALL INTO FIXMAP

FIXMAP:	MOVEI	T1,777000	;ADDRESS TO CALL CLRPT WITH
FIXMP1:	MOVEM	T1,FIXADR
	JSR	FCLRPT		;DO FOR 777 TO 340
	HRREI	T1,-1000
	ADDB	T1,FIXADR
	CAIL	T1,340000
	JRST	FIXMP1
	JRST	BYE		;OK, DONE

PAGCPT:	MOVE	T2,SXFLG	;SEE IF XCT UNDER AN EXEC XCT
	TLNN	T2,(<PX.MEM>B12) ;TO USER SPACE? IF SO IGNORE IT.
	JSR	FCLRPT		;THIS ROUTINE DOES THE WORK
	JRST	BYE

FCLRPT:	0			;JSR HERE FROM CLRPT AND DATAO, CONO PAG
	HRRZS	T1		;CLEAR OUT JUNK IN LH
	LSH	T1,-^D9		;CONVERT TO PAGE NUMBER
	MOVEM	T1,FCLPNO	;REMEMBER PAGE NUMBER
	CAIGE	T1,340		;MAKE SURE ITS IN RANGE
	ERROR (ATTEMPT TO PAGE BELOW EV 340)
	MOVE	T2,EBRST
	TRNN	T2,LG.TEN	;IS PAGING ON?
	JRST	NOPAG		;NO, CLEAR OUT 340-777.
	SETZM	NPGFLG		;IF -1, UNPAGEDNESS HAS BEEN SETUP.
	LSH	T1,^D9		;CONVERT BACK TO ADDRESS
	JSR	GETSLT		;GET SLOT FOR C(T1) IN T1
	MOVEM	T2,MSLTBP	;SAVE BP
	TRZ	T2,777000	;JUST WORD WITHIN THE MAP
	ADDI	T2,MSLOTS-200	;GET WORD WITHIN MSLOTS TABLE
	EXCH	T2,MSLTBP	;GET OUR POINTER BACK, PUT MSLOTS ONE IN MSLTBP
	LDB	T2,MSLTBP	;GET LAST SLOT WE SAW
	CAMN	T1,T2		;DIFFERENT?
	JRST	@FCLRPT		;NO, JUST LEAVE IT ALONE.
	DPB	T1,MSLTBP	;PUT NEW SLOT IN OUR PAGING MEMORY.
	TRNN	T1,PGE.A	;IS ACCESS BIT ON?
	JRST	NOACC		;NO, GO REMOVE THE VP
	TRC	T2,PGE.W	;SEE IF ITS JUST W GOING ON OR OFF
	CAMN	T1,T2		;SKIP IF STILL DIFFERENT
	JRST	FCLRWB		;GO MAKE NEW PROTECTION CORRECT
	MOVE	T2,FCLPNO	;GET VIRTUAL PAGE NUMBER
	HRLI	T2,1		;COUNT OF 1
	VCLEAR	T2,
	  ERROR(VCLEAR FAILURE IN PAGE SIMULATOR)
	MOVSI	T2,2001		;ASSUME READ ONLY
	TRNE	T1,PGE.W	;SKIP IF RIGHT
	MOVSI	T2,6001
	HRR	T2,FCLPNO
	ANDI	T1,17777	;JUST PHYSICAL PAGE
	CAML	T1,SZPMEM	;IS IT OUT OF RANGE?
	JRST	NOACC		;YES, NO ACCESS, PAGE FAULT WILL GIVE NXM.
	MOVEM	T2,MAPARG
	ADDI	T1,PHYOFS	;GET OFFSET INTO PHYSICAL FILE
	MOVEM	T1,MAPARG+1	;STORE INTO ARG BLOCK
	JSR	DOMAP
	JRST	@FCLRPT

FCLRWB:	MOVSI	T2,2001
	TRNE	T1,PGE.W
	MOVSI	T2,6001		;SET READ ONLY OR WRITE DEPENDING ON BIT
	HRR	T2,FCLPNO
	VPROT	T2,		;DO IT.
	  ERROR	(VPROT FAILURE WHEN PGE.W CHANGING)
	JRST	@FCLRPT

DOMAP:	0
DOMAP1:	MOVE	T1,[.CHMAP,,PHY]
	CHANIO	T1,MAPARG
	  JRST	FIXHOL		;MAYBE PAGE DOESN'T EXIST IN FILE YET, SO MAKE IT.
	JRST	@DOMAP

FIXHOL:	HLRZ	T2,T1		;GET VP IT FAILED ON
	HRRZS	T1		;JUST ERROR CODE
	CAIE	T1,FALHOL
	CAIN	T1,FALPHP	;IF HOLE OR EOF, MAKE THE PAGE
	JRST	.+2
	ERROR (CAN'T MAP FROM PHYSICAL MEMORY FILE)
	HRRZ	T1,MAPARG
	SUB	T2,T1		;GET NUMBER OF PAGES DONE ALREADY
	ADDM	T2,MAPARG	;SET FIRST VP TO START NEXT TIME
	ADDM	T2,MAPARG+1	;AND NEXT FP
	LDB	T1,[POINT 10,MAPARG,17] ;GET COUNT
	SUB	T1,T2		;DECREMENT BY AMOUNT DONE
	DPB	T1,[POINT 10,MAPARG,17] ;PUT IT BACK
	MOVE	T1,[.CHCFP,,PHY]
	MOVE	T2,MAPARG+1
	CHANIO	T1,T2		;MAKE THE PAGE
	  ERROR (CAN'T CREATE PAGE IN PHYSICAL MEMORY FILE)
	JRST	DOMAP1		;AND RESTART THE MAP.

;HERE IF ACCESS BIT IS OFF, T2 HAS MAP SLOT
NOACC:	MOVE	T2,FCLPNO
	HRLI	T2,1
	VCLEAR	T2,
	  ERROR (VCLEAR FAILURE IN PAGE SIMULATOR: A BIT OFF)
	JRST	@FCLRPT

NOPAG:	AOS	T1,NPGFLG	;GET FLAG+1
	SETOM	NPGFLG		;SET BACK TO -1
	JUMPE	T1,@FCLRPT	;DONE IF IT WAS -1 ALREADY.
	SETOM	MSLOTS		;SETUP SO NEVER MATCHES WHEN PAGING COMES ON.
	MOVE	T1,[MSLOTS,,MSLOTS+1]
	BLT	T1,MSLOTS+MSLTLN-1
	MOVE	T1,[<1000-340>,,340]	;CLEAR OUT ALL PAGED AREA.
	VCLEAR	T1,
	  ERROR (VCLEAR FAILED WHILE TURNING OFF PAGING)
	MOVE	T1,[3B7+<1000-340>B17+340] ;MAP DIRECTLY FROM PHYS FILE
	MOVEM	T1,MAPARG
	MOVEI	T2,340+PHYOFS
	MOVEM	T2,MAPARG+1
	JSR	DOMAP		;DO THE MAP
	JRST	@FCLRPT		;AND RETURN.
PAGCSZ:	HRRZS	T1
	TDNN	T1,EBRST
	AOS	RETPC
	JRST	BYE

PAGCSO:	HRRZS	T1
	TDNE	T1,EBRST
	AOS	RETPC
	JRST	BYE

SAVE0:	0

EBRST:	0
UBRST:	0
FCLPNO:	0
FIXADR:	0
NUBRST:	0
ACDPTR:	0
ACDTAB:	BLOCK 10*20
MAPARG:	BLOCK	2
PHYFNM:	3
	0
	SIXBIT/PHYMEM/
	SIXBIT/MAP/
NPGFLG:	0
MSLTLN==<777-400+1>+<377-340+1>
MSLOTS:	BLOCK	MSLTLN		;0-177 HAS EXEC 400-777, 200-217 HAS PER PROCESS 340-377.
MSLTBP:	0			;BYTE POINTER TO MSLOTS USED TO FREE REGISTER.
SZPMEM:	^D512			;SIZE OF PHYSICAL MEMORY IN PAGES.

;PAGE FAIL SIMULATOR

MEMINT:	MOVEM	T1,MEMT1
	MOVEM	T2,MEMT2	;WHERE BYE EXPECTS TO RESTORE THEM FROM
	HRRZ	T1,MEMPC	;GET PC
	MOVE	T2,LUUOH	;GET LUUO PC IN CASE ITS FROM THERE
	SKIPE	SXFLG		;IF FAULT FROM EXEC XCT INSTRUCTION,
	JRST	[SUBI T2,1	;POINT TO THE LUUO
		 HRRM T2,MEMPC	;YES, MAKE BELIEVE INSTRUCTION IS FROM THERE.
		 JRST MEMIN1]   ;AND DON'T CHECK FOR INSIDE SIMULATOR.
	CAIL	T1,MONDEB
	CAILE	T1,MONDBE
	JRST	MEMIN1		;OK
	ERROR	<ILL MEM REF IN SIMULATOR - SEE MEMPC>
MEMIN1:	JSR	PFWGET		;GET PAGE FAIL WORD IN T1
	  JRST	MEMNXM		;GIVE HIM A NXM.
	MOVEM	T1,MEMPFW#	;SAVE IT
	JSR	GETUPT		;GET UPT ADDRESS IN T1
	MOVE	T2,MEMPFW	;RESTORE PFW
	MOVEM	T2,UPTPFW(T1)	;STORE IT
	MOVE	T2,MEMPC	;THIS IS RETURN PC
	HLL	T2,SIMPC	;GET SIMULATED FLAGS IN LH
	MOVEM	T2,UPTOPP(T1)	;STORE IT IN UPT ALSO
	MOVSI	T2,PC.FPD!PC.ADR ;COPY THESE FROM FAULT PC TO "OLD" PC
	AND	T2,MEMPC
	IORM	T2,UPTOPP(T1)	;BUT THEY ARE NEVER IN SIMPC.
	MOVE	T2,UPTNPP(T1)	;GET NEW PC
	MOVEM	T2,MEMPC	;AND STORE IT THERE (USER IOT IS OFF)
	MOVEM	T2,SIMPC	;SAVE NEW SIMULATED PC FLAGS.
MEMBYE:	SETZM	SXFLG		;NO LONGER UNDER AN EXEC XCT.
	MOVE	T1,MEMT1
	MOVE	T2,MEMT2
	DISMIS			;AND RETURN.

MEMNXM:	MOVEI	T1,LP.NXM+LP.PAR
	IORM	T1,APRST	;SET NXM FLAG
	AOS	MEMPC		;IGNORE THE NXM INSTRUCTION
	JRST	MEMBYE		;AND RETURN. (INTERRUPTS NOT IMPLEMENTED)

MEMT1:	0
MEMT2:	0


;VERY TEMPORARY, TILL GETPFW FIXED - DOESN'T WORK IN SOM CASES.
PFWGET:	0
	MOVE	T1,MEMPC	;GET PC
	HLL	T1,SIMPC	;GET PC FLAGS (SPACE INSTRUCTION CAME FROM)
	MOVEM	T1,MEMPCI#	;LOCATION (PSEUDO PC) OF INST AT END OF XCT CHAIN.
PFWGT0:	TLZ	T1,PC.USR	;CHECK EXEC MAP, EVEN IF USER PC
	JSR	DOMAPI		;DO A MAP INSTRUCTION FOR RH(T1)
	TLNE	T1,PFW.H	;IF HARD FAIL,
	JRST	[HRR T1,MEMPC	;FILL IN RH FROM WHERE INSTRUCTION IS
		 JRST PFWOKR]	;AND RETURN THAT AS FAULT WORD.
	TLNN	T1,PFW.R	;IF NOT PAGED REF,
	JRST	PFWGT1		;CAN'T BE FAULT OR NXM, A BIT NOT VALID
	TLNN	T1,PFW.A	;IF A BIT IS OFF,
	JRST	[HRR T1,MEMPC	;FILL IN RH
		 JRST PFWOKR]	;AND RETURN THAT AS FAULT, ON INST FETCH.
	MOVE	T2,T1
	TLZ	T2,777740		;GET PHYSICAL ADDRESS
	LSH	T2,-^D9		;CONVERT TO PAGES
	CAML	T2,SZPMEM	;OVER LIMIT?
	JRST	@PFWGET		;YES, GIVE NXM RETURN.
PFWGT1:	MOVE	T1,@MEMPCI	;THATS OK, GET INSTRUCTION
PFWGT2:	MOVEM	T1,MEMINS	;SAVE IT
	MOVSI	T2,(<PX.MEM>B12)	;DEFAULT FLAG TO TEST
	MOVEM	T2,SXTST#	;IF SPECIAL INSTRUCTION, MODIFY SXTST
	LDB	T1,[POINT 9,T1,8] ;OPCODE
	SETZM	MEMWRT		;ASSUME NOT A WRITE
	CAIE	T1,<SXCT>_-^D27	;WATCH FOR FAKE EXEC XCTS.
	CAIN	T1,<XCT>_-^D27	;ASSUME THERE IS ANOTHER INSTRUCTION
	JRST	PFWXCT		;DO XCT
	CAIN	T1,<DPB>_-^D27
	JRST	PFWBYW
	CAIN	T1,<IDPB>_-^D27
	JRST	PFWBYW
	CAIN	T1,<LDB>_-^D27
	JRST	PFWBYR
	CAIN	T1,<ILDB>_-^D27
	JRST	PFWBYR
	CAIN	T1,<POP>_-^D27 ;BET THAT NO ONE USES PAGED STACK POINTER
	JRST	PFWWRT
	CAIN	T1,<DMOVEM>_-^D27
	JRST	PFWWRT
	CAIN	T1,<DMOVNM>_-^D27
	JRST	PFWWRT
	CAIN	T1,<EXCH>_-^D27
	JRST	PFWWRT
	CAIN	T1,<BLT>_-^D27
	JRST	PFWBLT
	

	SETZ	T2,		;CLEAR OUT T2 SO 0-3 OF T1 ARE 0 AFTER ROTC
	ROTC	T1,-3		;FIRST 2 DIGITS IN T1, 3RD IN T2 0-2
	CAIE	T1,35
	CAIN	T1,37
	JRST	PFWWRT		;AOSX AND SOSX

DEFINE COMP(A,B)<
	CAIL	T1,A
	CAILE	T1,B
	JRST	.+2
	JRST	PFWRED
>
	COMP	(30,37)
	COMP	(24,26)
	COMP	(60,67)
	SETZ	T1,
	ROTC	T1,^D3		;GET LOW ORDER OPCODE DIGIT
	CAIE	T1,2		;TO MEMORY
	CAIN	T1,6		;TO MEMORY
	JRST	PFWWRT
	CAIE	T1,3		;BOTH
	CAIN	T1,7		;BOTH
PFWWRT:	SETOM	MEMWRT#		;ITS A WRITE
PFWRED:	MOVE	T1,MEMT1
	MOVE	T2,MEMT2	;RESTORE THESE
	MOVEI	T1,@MEMINS	;GET EFFECTIVE ADDRESS IN INSTRUCTION
	MOVEM	T1,MEMEA#	;SAVE IT FOR RETURN AFTER NXM CHECK
PFWRDB:	HLL	T1,SIMPC	;GET PC FLAGS FOR DOMAPI.
	MOVE	T2,SXFLG	;GET SXCT FLAGS
	TLNE	T1,PC.UIO	;IF UIO IS ON AND
	TDNN	T2,SXTST	;SPECIAL PX.MEM OR PX.SRC IS ON
	CAIA			;UIO NOT ON OR PX.MEM NOT ON
	TLO	T1,PC.USR	;THIS IS CONSIDERED USER FAULT.
				;(ASSUMING FAULT ONLY FOR USER SPACE).
	JSR	DOMAPI		;GET MAP WORD FOR IT
	TLNE	T1,PFW.H	;HARD PAGE FAIL?
	JRST	PFWHPF		;YES, FILL IN RH AND RETURN.
	SKIPE	MEMWRT
	TLO	T1,PFW.T	;HE'S TRYING TO WRITE
	TLNN	T1,PFW.A	;DID WE GET BACK A VALID SLOT?
	JRST	PFWHPF		;NO, DON'T HAVE CP, JUST RETURN
	MOVE	T2,T1
	TLZ	T2,777740
	LSH	T2,-^D9		;CONVERT TO PAGE NUMBER
	CAML	T2,SZPMEM
	JRST	@PFWGET		;NXM FOR THIS
				;THIS DOESN'T WORK FOR LDB PUSH POP BLT ETC.
PFWHPF:	HRR	T1,MEMEA
PFWOKR:	AOS	PFWGET
	JRST	@PFWGET


PFWBLT:	LDB	T1,[POINT 4,MEMINS,12] ;GET BLT AC
	MOVEM	T1,MEMIAC#	;NEED TO RESTORE T1 AND T2
	MOVE	T1,MEMT1
	MOVE	T2,MEMT2
	MOVE	T1,@MEMIAC	;GET BLT AC POINTER
	MOVSM	T1,MEMEA	;USED FOR NORMAL INSTRUCTIONS AT PFWRED, CAN USE IT HERE
	HLRZS	T1		;GET SOURCE ADDRESS TO CHECK FIRST
	HLL	T1,SIMPC	;GET PC FLAGS IN LH FOR DOMAPI
	MOVE	T2,SXFLG	;GET SXCT FLAGS
	TLNE	T2,(<PX.SRC>B12) ;IF PX.SRC IS ON
	TLNN	T1,PC.UIO	;AND USER IO IS TOO,
	JRST	.+2		;NOT, JUST USE ADDRESS SPACE WERE IN
	TLO	T1,PC.USR	;THEN FORCE USER MAP
	JSR	DOMAPI		;DO MAP INSTRUCTION FOR SOURCE
	TLNN	T1,PFW.H	;IF HARD PAGE FAIL(ADDR BREAK)
	TLNN	T1,PFW.A	;OR NO A BIT SET,
	JRST	PFWHPF		;THEN THIS IS IT. SOURCE ADDR IS IN RH MEMEA FROM ABOVE, SO FAULT WORD SETS OK
	TLZ	T1,777740	;CLEAR OUT ALL BUT PAGE NUMBER
	LSH	T1,-^D9		;TURN INTO PAGE NUMBER
	CAML	T1,SZPMEM	;MAKE SURE NOT OUT OF BOUNDS
	JRST	@PFWGET		;IT IS, GIVE NXM RETURN.
	MOVSS	T1,MEMEA	;PUT DEST IN RH MEMEA, GET INTO RH T1
	HLL	T1,SIMPC	;GET PC FLAGS IN LH
	SETOM	MEMWRT		;DEST FALTED, TRYING TO WRITE
	MOVSI	T2,(PX.MEM,)	;THIS IS FLAG TO TEST
	MOVEM	T2,SXTST
	JRST	PFWRDB		;GO REJOIN MAIN CODE.

PFWXCT:	MOVE	T1,MEMT1
	MOVE	T2,MEMT2
	MOVEI	T1,@MEMINS	;GET THE PLACE TO CHECK
	HLL	T1,SIMPC	;GET PC FLAGS
	MOVEM	T1,MEMPCI	;THIS IS PLACE TO LOOK FOR REAL INSTRUCTION
	JRST	PFWGT0		;AND LOOP. C(MEMPCI) IN T1.

PFWBYR:	SKIPA			;NOT A WRITE
PFWBYW:	SETOM	MEMWRT		;THIS IS A WRITE, ASSUME FAULT NOT ON BYTE POINTER
	MOVE	T1,MEMT1
	MOVSI	T1,(<PX.SRC>B12)	;THIS BIT CONTROLLS THE REF IN BYTE INSTRUCTIONS
	MOVEM	T1,SXTST
	MOVE	T2,MEMT2
	MOVE	T1,@MEMINS	;GET BYTE POINTER
	MOVEM	T1,MEMINS	;SAVE IT AS "INSTRUCTION"
	JRST	PFWRED		;AND GIVE THAT BACK.

MAPINS:	LDB	T2,[POINT 4,T1,12] ;GET AC NUMBER TO RETURN DATA TO
	MOVEM	T2,MAPAC
	HRRZS	T1		;JUST E.A.
;NEXT 2 INSTRUCTIONS COMMENTED OUT TO EMULATE ACTUAL BUG IN KL10 MAP INSTRUCTION
; WHICH CAUSES MAP TO TELL USER THAT ACS ARE PAGED REFS, GIVING PAGE TABLE
; INFO FROM PAGE ZERO.
;	CAIGE	T1,20		;ACS?
;	JRST	MAPIN1		;YES, JUST RETURN ADDRESS
	HLL	T1,SIMPC	;GET PC FLAGS
	MOVE	T2,SXFLG	;GET SXCT FLAGS
	TLNE	T1,PC.UIO	;IF UIO ON AND
	TLNN	T2,(<PX.MEM>B12) ;UNDER EXEC XCT,
	JRST	.+2		;NOT FOR USER SPACE.
	TLO	T1,PC.USR	;THEN THIS IS FOR USER SPACE.
	MOVE	T2,EBRST	;SEE IF TRAP ENABLE IS ON
	TRNN	T2,LG.TEN	;NO PAGING?
	TLZA	T1,-1		;YES, RETURN EFFECTIVE ADDRESS IN RH
	JSR	DOMAPI		;DO THE WORK
MAPIN1:	MOVE	T2,T1		;GET DATA IN T2 FOR STORE
MAPIEX:	MOVE	T1,MAPAC	;GET MAP AC BACK.
	JSR	STORE		;GIVE IT BACK.
	JRST	BYE


DOMAPI:	0
	TLNE	T1,PC.USR	;IF USER CALLED,
	JRST	USRMPI		;DO MAP FOR USER SPACE.
	HRRZS	T1		;JUST ADDRESS
	MOVE	T2,ABKST	;GET ADDRESS BREAK STUFF
	TLNN	T2,AB.USR	;IF USER ADDRESS SPACE, NOT FOR US.
	CAIE	T1,(T2)		;DO ADDRESS BREAK?
	JRST	DOMAPA		;NO
	MOVSI	T1,PF.ABK*10000 ;RETURN THIS
	JRST	@DOMAPI
DOMAPA:	JSR	GETSLT		;GET MAP SLOT FOR C(T1)
	MOVE	T2,T1		;GET BITS IN T2
	ANDI	T1,17777	;GET PHYS PAGE NUMBER
	LSH	T1,^D9		;CONVERT TO PHYS ADDRESS

DEFINE COPYMP(ARG)<
IRP ARG,<
	TRNE	T2,PGE.'ARG
	TLO	T1,PFW.'ARG
>>;END COPYMP DEFINITION

	COPYMP <A,P,W,C,S>
	TLO	T1,PFW.R	;ALWAYS PAGED REF, NEVER USER MAP.
	JRST	@DOMAPI

;GETSLT CALL WITH ADDRESS IN T1, RETURN WITH SLOT IN T1, POINTER TO SLOT
; IN T2.
GETSLT:	0
	TRZ	T1,777		;CLEAR OUT WORD WITHIN PAGE
	ROT	T1,-^D10	;USUAL SIGN BIT TRICK
	MOVE	T2,T1		;GET INTO T2
	JSR	GETEPT		;ASSUME EXEC
	TRZE	T2,400_-1	;IS IT (CLEAR IT)
	JRST	GETSL0		;IS EXEC MAP, DON'T FOOL.
	TRC	T2,340_-1	;SEE IF IN "UNMAPPED" AREA
	TRCE	T2,340_-1	;IF ALL 3 BITS ARE ON, IS EXEC PER PROCESS
	JRST	[ADDI T2,400	;NO, PAGE 0 STARTS AT 600
		 JRST GETSL0]	;AND GET SLOT FROM THERE.
	MOVEM	T2,SAVSLT#	;SAVE THIS A MINUTE
	JSR	GETUPT		;NO, GET UPT
	MOVE	T2,SAVSLT	;OK, GET POSITION IN MAP BACK
	ADDI	T2,<<1000-340>/2>-200
				;STARTS AT 400 IN MAP (CONVENIENT, EXEC MAP ENDS THERE).
				;SUBTRACT 200 BECAUSE OF ADDI BELOW.
GETSL0:	ADDI	T2,200(T1)	;GET PROPER WORD IN PROPER MAP
	JUMPL	T2,GETSL1	;GO IF ODD
	HRLI	T2,(POINT 18,0,17) ;EVEN
	JRST	GETSL2
GETSL1:	HRLI	T2,(POINT 18,0,35) ;ODD
GETSL2:	LDB	T1,T2		;GET SLOT CONTENTS
	JRST	@GETSLT		;AND RETURN.

USRMPI:	HRRZS	T1		;JUST ADDRESS, THROW AWAY PC BITS
	MOVE	T2,ABKST	;GET ADDRESS BREAK SETTING
	TLNE	T2,AB.USR	;IF EXEC MODE,
	CAIE	T1,(T2)		;OR NO MATCH,
	JRST	USRMP0		;NOT FOR US.
	MOVSI	T1,PF.ABK*10000
	JRST	@DOMAPI		;RETURN THIS.
USRMP0:	JSR	GETUSL		;GET SLOT FROM UPT
	MOVE	T2,T1		;GET COPY IN T2 SO WE CAN
	ANDI	T1,17777	;MASK OFF PAGE NUMBER IN RH
	LSH	T1,^D9		;CONVERT TO ADDRESS (22 BITS)
	COPYMP <A,P,W,C,S>	;COPY ALL THE BITS
	TLO	T1,PFW.U+PFW.R ;USER MAP, PAGED REFERENCE
	JRST	@DOMAPI		;AND RETURN.

GETUSL:	0			;GET USER MAP SLOT
	ANDI	T1,777000	;GARBAGE,,ADDRESS WAS IN T1, GET PAGE NUMBER
	ROT	T1,-^D10	;/2 IN RH, LOW BIT IN 1B0
	MOVEM	T1,SAVSLT	;SAVE IT
	JSR	GETUPT		;GET CURRENT UPT
	MOVE	T2,SAVSLT	;GET SLOT DESCRIPTOR BACK
	JUMPL	T2,GETUS1	;GO IF ODD
	HRLI	T2,(POINT 18,0,17) ;EVEN.
	JRST	GETUS2
GETUS1:	HRLI	T2,(POINT 18,0,35) ;ODD
GETUS2:	LDB	T1,T2		;GET MAP SLOT POINTER IN T1
	JRST	@GETUSL		;AND RETURN.

MAPAC:	0
MEMINS:	0			;PLACE TO PUT PAGE FAILING INSTRUCTION WHILE RESTORE ACS.

;SA-10 SIMULATOR

DEFINE X(A)<IRP A,<'A==ZZ
ZZ==ZZ_-1>>
ZZ==(1B8)
X <ATTEN,STSMOD,CUEND,BUSY,CHNEND,DEVEND,UCHK,UXCP>
NOMEMT==200
XCTCMD==40
CHAIN==20
IGNLEN==2
OFFSET==1

BPERT==^D<18*19>&777774

SELER==(1B2)

IRF0==1B21
GOF0==1B25
STF0==1B29

;DEFINE BASE ADDRESS OF DISKS AND NUMBER OF THEM WE SUPPORT

BPA==300
BPNUM==^D16

SAXSER:	LDB	T2,[POINT 3,T1,12] ;GET CODE
	XCT	SAXTAB(T2)		;DISPATCH


SAXTAB:	JRST	BYE		;BLKI
	JRST	BYE		;DATAI
	JRST	BYE		;BLKO
	JRST	BYE		;DATAO
	JRST	SAXCNO		;CONO
	JRST	SAXCNI		;CONI
	JRST	SAXCSZ		;CONSZ
	JRST	SAXCSO		;CONSO

SAXCNI:	MOVE	T2,SAXST
	TLO	T2,1		;ALWAYS NON-ZERO SO MONITOR KNOWS ITS THERE.
	JSR	STORE
	JRST	BYE

SAXCSZ:	HRRZS	T1
	TDNN	T1,SAXST
	AOS	RETPC
	JRST	BYE

SAXCSO:	HRRZS	T1
	TDNE	T1,SAXST
	AOS	RETPC
	JRST	BYE

;CONO FOR SA-10. SCAN ALL COMMAND LISTS AND EXECUTE THEM ALL TO COMPLETION,
; THEN GIVE INTERRUPT ON SA-10'S PI CHANNEL.
; THUS, ALWAYS LOOKS LIKE SA-10 IS DONE IMMEDIATELY AFTER GO FLAG IS SET.
SAXCNO:	JSR	SAXSAC		;NEED PLENTY OF ACS FOR THIS
	MOVE	P,[IOWD PDLLEN,SAXPDL]
	LDB	P4,[POINT 2,T1,32] ;GET CHANNEL NUMBER
	LDB	T2,[POINT 3,T1,29] ;GET FUNCTION CODE
	LDB	P1,[POINT 1,T1,30] ;SET/CLEAR FLAG
	TRNE	T1,400000	;RESET ALL SA10S?
	JRST	SAXMRR		;YES.
	ANDI	T1,7		;GET PI CHANNEL ASSIGNMENT
	DPB	T1,[POINT 3,SAXST,35] ;SET IT
	XCT	SAXFTB(T2)	;DISPATCH ON FUNCTION
				;WITH CHANNEL NUMBER IN P4

SAXFTB:	JRST	CHNBYE		;NO-OP
	JRST	CHNBYE		;NO-OP
	JRST	CHNBYE		;NO-OP
	JRST	CHNRST		;RESET A SINGLE CHANNEL
	JRST	CHNGOF		;SET/CLEAR GO FLAG (DO I/O)
	JRST	CHNSTR		;SET/CLEAR STATUS REQUEST FLAG
	JRST	CHNSTS		;SET/CLEAR STATUS FLAG
	JRST	CHNINE		;SET/CLEAR INTERRUPT ENABLE

SAXMRR:	SETZM	SAXST		;CLEAR CONI WORD AND
	JRST	CHNBYE		;AND RETURN.

;HERE TO SET INTERRUPT ENABLE FOR CHANNEL (# IN P4)

CHNINE:	MOVEI	T1,IRF0		;ENABLE FLAG FOR CHANNEL 0
	MOVNS	P4		;GET -VE CHANNEL NUMBER
	LSH	T1,(P4)
	XCT	[ANDCAM T1,SAXST
		 IORM T1,SAXST](P1) ;SET OR CLEAR
	JUMPE	P1,CHNBYE	;IF CLEARING, LEAVE STATUS FLAG AONE
	MOVEI	T1,STF0		;SETTING, CLEAR STATUS FLAG
	LSH	T1,(P4)		;(MONITOR APPEARS TO NEED THIS)
	ANDCAM	T1,SAXST
	JRST	CHNBYE

;HERE IF SET/CLEAR STATUS FLAG

CHNSTS:	JUMPN	P1,[PUSHJ P,SAXPIS ;WANTS TO SET, SET IT AND CAUSE INTERRUPT IF ENABLED
		    JRST CHNBYE]
	MOVEI	T1,STF0		;STATUS FLAG FOR CHANNEL 0
	MOVN	T2,P4	;GET NEGATIVE CHANNEL NUMBER
	LSH	T1,(T2)	;GET STATUS FLAG FOR THIS CHANNEL
	ANDCA	T1,SAXST	;GET COPY OF SAXST CLEARED IN T1
	TRNN	T1,17*<STF0_-3>	;ANY MORE STATUS FLAGS ON?
	TRZ	T1,400000	;NO, CLEAR OUT PI REQ FLAG
	MOVEM	T1,SAXST	;NEW STATUS.
	MOVEI	T3,GOF0
	LSH	T3,(T2)		;GO FOR THIS CHANNEL
	TDNE	T1,T3	;IF GO FLAG IS ON,
	JRST	CHNGO		;THEN START THE CHANNEL.
	JRST	CHNBYE		;NOTHING TO DO.
;HERE IF SET/CLEAR STATUS REQUEST FLAG.

CHNSTR:	JUMPE	P1,CHNBYE	;CLEARING IT IS A NO-OP
	MOVEI	T2,STF0		;FLAG FOR CHANNEL 0
	MOVN	T1,P4		;GET AMOUNT TO SHIFT
	LSH	T2,(T1)
	TDNE	T2,SAXST	;STATUS ALREADY STORED?
	JRST	CHNBYE		;YES.
	PUSHJ	P,SAXPIS	;SET PI REQ IF CHAN IS ENABLED.
	PUSHJ	P,GETICB	;GET INITIAL COMMAND BLOCK IN M
	MOVSI	T1,<(3B1)>+CHNEND	;DUMMY STATUS CODE, CHANNEL END
	MOVEM	T1,1(M)	;STORE IT
	JRST	CHNBYE		;CHNBYE WILL SEE THE INTERRUPT REQUEST FLAG AND MAKE AN INTERRUPT.

CHNRST:	MOVEI	T1,IRF0+GOF0+STF0 ;BITS TO CLEAR
	MOVNS	P4
	LSH	T1,(P4)		;POSITION
	ANDCAM	T1,SAXST	;TURN OFF IN CONI WORD
	JRST	CHNBYE

CHNGOF:	JUMPE	P1,CHNBYE	;IGNORE CLEARING IT.
	MOVNS	P4
	MOVEI	T1,GOF0		;GO FLAG FOR CHANNEL 0
	LSH	T1,(P4)		;FOR CORRECT CHANNEL
	MOVMS	P4
	IORM	T1,SAXST		;SET GO FLAG
	LSH	T1,-4		;CHANGED INTO STATUS FLAG
	TDNE	T1,SAXST	;IS IT STILL SET?
	JRST	CHNBYE		;YES, START UP WHEN HE CLEARS IT.
	JRST	CHNGO		;NO, START CHANNEL NOW.

;HERE WHEN SET/CLEAR GO FLAG FUNCTION IS EXECUTED. IGNORE CLEAR GO FLAG,
; BECAUSE ITS ALWAYS CLEAR WHEN WE EXIT BECAUSE WE DO ALL REQUESTED I/O.
; USE OF REGISTERS: W/BLOCK MUX LIST POINTER, P4/CHANNEL #,
; M/INITIAL CONTROL BLOCK POINTER, J/CHANNEL PROGRAM POINTER

CHNGO:	PUSHJ	P,GETICB	;GET CONTROL BLOCK IN M
	SETZM	1(M)		;INITIAL STATUS IS ZERO
	SETZM	2(M)		;CLEAR OUT TERINATION WORD
	MOVE	W,0(M)		;GET INITIAL COMMAND
	TLNN	W,400000	;BLOCK MUX MODE?
	JRST	[SETZ J,	;W WILL BE ZERO AS NO BMX FLAG
		 EXCH J,W	;J POINTS TO PROGRAM
		 PUSHJ P,CHNCMD ;DO CHANEL COMMANDS
		 JRST CHNBYE]	;AND RETURN.
CHNBMX:	MOVE	J,(W)		;GET BLOCK MUX WORD
	LDB	T2,[POINT 4,J,11] ;GET CODE
	JUMPE	T2,CHNBYE	;ZERO IS END OF BLOCK MUX LIST
	CAIN	T2,15		;START DEVICE?
	PUSHJ	P,CHNCMD	;YES, DO THE COMMAND LIST
	AOJA	W,CHNBMX	;AND LOOP THRU THE BLOCK MUX LIST.

;HERE WITH J POINTING TO FIRST WORD OF CHANNEL COMMAND

CHNCMD:
CHNLUP:	SETZ	T1,
	MOVE	T2,(J)		;GET CURRENT COMMAND
	TLNE	T2,(1B4)	;GET BITS 1,2,4 INTO 33,34,35 FOR DISPATCH
	TRO	T1,1B35
	TLNE	T2,(1B2)
	TRO	T1,1B34
	TLNE	T2,(1B1)
	TRO	T1,1B33
	MOVEM	T1,MODE		;SAVE MODE INDICATOR.
	XCT	SAXCMD(T1)	;DISPATCH

SAXCMD:	JRST	CMDHLT		;HALT
	JRST	CMDHLT		;ANOTHER HALT
	JRST	CMDWRD		;WORD DATA TRANSFER
	JRST	CMDBYT		;CHNBYE DATA TRANSFER
	JRST	CMDTIC		;TRANSFER IN CHANNEL
	JRST	CMDTIC		;ANOTHER TRANSFER IN CHANNEL
	JRST	CMDNAT		;NATURAL MODE DATA TRANSFER
	JRST	CMDTAP		;TAPE COMPAT DATA TRANSFER


WRD==2
BYT==3
NAT==6

NXTCMD:	AOJA	J,CHNLUP	;DONE WITH THIS COMMAND, DO NEXT.
CMDHLT:
CHNHLT:	AOS	J		;TERMINATE WORD IS ONE MORE THAN LAST COMMAND
	HRRM	J,2(M)		;STORE LAST COMMAND ADDRESS
	MOVEI	T1,17		;GET READY TO STORE TERMINATED STATUS
	SKIPE	W
	DPB	T1,[POINT 8,(W),11] ;ITS TERMINATED NOW
	PUSHJ	P,SAXPIS	;SET INTERRUPT FLAG IF NEEDED
	MOVSI	T1,DEVEND+CHNEND
	IORM	T1,1(M)		;ALWAYS SET THESE
	MOVE	T1,DEVADD
	DPB	T1,[POINT 8,1(M),23] ;PUT DEVICE ADDRESS IN STATUS WORD.
	HRROS	DEVADD		;FLAG IS INVALID.
	POPJ	P,		;AND RETURN TO BMX LIST SCAN OR DONE.

CHNBYE:	JSR	SAXRAC		;RESTORE ACS
	JRST	BYE		;AND EXIT THRU BYE.

CMDTAP:
	ERROR <TAPE OR NATURAL MODE NOT SUPPORTED BY SA-10 SIMULATOR>

CMDNAT:
CMDWRD:
CMDBYT:	LDB	U,[POINT 8,(J),23] ;GET DEVICE ADDRESS FOR THIS COMMAND
	SKIPG	DEVADD		;IF NOT SETUP YET,
	MOVEM	U,DEVADD	;FIRST D.A. SEEN IN THIS CHAN PROG
	CAME	U,DEVADD	;MAKE SURE NO CHANGES.
	ERROR (DIFFERENT DEVICE ADDRESSES IN SAME CHANNEL PROGRAM)
	CAIL	U,BPA
	CAILE	U,BPA+BPNUM-1
	JRST	SELERR		;GIVE SELECT ERROR
	SUBI	U,BPA		;GET UNIT NUMBER IN U
	MOVE	U,UNTTBL(U)	;GET "UNIT DATA BLOCK" ADDRESS
	LDB	T1,[POINT 8,(J),15] ;GET COMMAND
	MOVSI	T2,-DSKCML	;DISK COMMAND LENGTH
CMDDSP:	CAMN	T1,DSKCMT(T2)	;THIS COMMAND?
	JRST	@DSKCMD(T2)	;YES, GO DO IT.
	AOBJN	T2,CMDDSP	;NO.
	JRST	CMDRJC		;NOT RECOGNIZED, DO COMMAND REJECT

SELERR:	MOVSI	T1,SELER	;GIVE SELECT ERROR
	IORM	T1,1(M)
	JRST	CHNHLT
DEFINE BPCMD<
X 3,BPNOOP
X 4,BPSENS
X 5,BPWRIT
X 6,BPREAD
X 7,BPSEEK
X 13,BPSEKC
X 23,BPRECL
X 43,BPSETS
X 61,BPSID
X 244,BPBUFL
>
DEFINE X(A,B)<A>
DSKCMT:	BPCMD
	DSKCML==.-DSKCMT
DEFINE X(A,B)<B>
DSKCMD:	BPCMD

CMDTIC:	HRRZ	J,(J)		;GET NEXT ADDRESS
	JRST	CHNLUP		;DON'T INCREMENT ADDRESS, JUST JUMP TO IT.

;SENSE. ASSUME ALWAYS DONE TO VIRTUAL ADDRESS.

BPSENS:	PUSHJ	P,SETDAT
	MOVE	T3,[POINT 8,UNISND(U)]
	HRLI	T1,(POINT 8,0)
BPSENL:	AOJG	T2,NXTCMD
	ILDB	T4,T3		;GET DATA TO SEND
	IDPB	T4,T1		;AND GIVE IT TO HIM
	JRST	BPSENL

BPSEEK:
BPSEKC:	PUSHJ	P,CHKOFL	;MAKE SURE ITS ON LINE
	  JRST	CHNHLT		;NOT, UNIT CHECK ON IN STATUS, AND SENSE BYTES.
	PUSHJ	P,SETDAT	;GET DATA IN T1, T2 AND T3
	MOVMS	T2		;GET + COUNT
	CAIGE	T2,6		;SHOULD BE
	JRST	NXTCMD		;JUST IGNORE THE COMMAND.
	TRNN	T3,OFFSET	;GET BYTE POINTER FOR CYL
	SKIPA	T3,[POINT 16,(T1),31]
	MOVE	T3,[POINT POINT 16,1(T1),15]
	LDB	T2,T3		;GET CYLINDER NUMBER
	CAIG	T2,^D808	;TOO HIGH?
	JRST	NXTCMD		;NO, JUST DO NEXT COMMAND.
CMDRJC:	MOVSI	T1,UCHK		;SET UNIT CHECK
	IORM	T1,1(M)		;IN THIS CHANNEL'S STATUS WORD
	MOVEI	T1,200		;SET COMMAND REJECT IN SENSE BYTE 0
	DPB	T1,SBYTE0
	MOVEI	T1,4		;FORMAT 0, MESSAGE 4 (DATA VALUE INCORRECT)
	DPB	T1,SBYTE7 ;INTO SENSE BYTE 7
	JRST	CHNHLT		;AND GO HALT THE CHANNEL.

BPSETS:
BPBUFL:	AOS	J		;SKIP OVER DATA CHAIN WORD
BPNOOP:
BPRECL:	PUSHJ	P,CHKOFL	;MAKE SURE UNIT IS THERE
	  JRST	CHNHLT		;NOT, STOP RIGHT HERE.
	JRST	NXTCMD		;DO NEXT COMMAND.

BPSID:	PUSHJ	P,CHKOFL	;MAKE SURE ITS ON LINE
	  JRST	CHNHLT		;NOT, TURN ON SENSE BITS AND UNIT CHECK.
	PUSHJ	P,SETDAT	;GET STUFF
	TRNE	T3,OFFSET
	MOVE	T4,T1		;GET ADDRESS IN T4
	HRLI	T4,(POINT 8,0,0) ;ASSUME NO OFFSET
	TRNE	T3,OFFSET
	HRLI	T4,(POINT 8,0,15) ;IS, GET BYTE FROM THERE
	ILDB	T1,T4
	ILDB	T2,T4
	LSH	T1,^D8
	ADD	T1,T2		;GET CYLINDER
	IMULI	T1,BPERT	;GET BLOCK
	MOVEM	T1,UNIBLK(U)	;SAVE IN UNIT DATA BLOCK
	ILDB	T1,T4
	ILDB	T2,T4		;GET HEAD
	LSH	T1,^D8
	ADD	T1,T2
	IMULI	T1,^D18		;SURFACE NUMBER * RECS/SURFACE
	ADDM	T1,UNIBLK(U)	;UPDATE BLOCK NUMBER
	ILDB	T1,T4		;GET RECORD NUMBER
	SUBI	T1,1		;SKIP RECORD ZERO, ITS NOT DATA RECORD
	ADDM	T1,UNIBLK(U)
	AOJA	J,NXTCMD	;SKIP OVER TIC AND GET NEXT COMMAND.

BPREAD:	PUSHJ	P,SETWRD	;BITS IN T3, T2/-COUNT, T1/ADDR
	  JRST	NXTCMD		;IGNORE TRANSFER
	PUSHJ	P,FUREAD
	JRST	NXTCMD

BPWRIT:	SKIPL	UNIONL(U)	;IS IT WRITE ENABLED?
	JRST	BPWRPT		;NO, WRITE PROTECT.
	PUSHJ	P,SETWRD
	  JRST	NXTCMD		;IGNORE
	PUSHJ	P,FUWRIT
	JRST	NXTCMD

BPWRPT:	MOVSI	T1,UCHK		;SET UNIT CHECK IN END STATUS
	IORM	T1,1(M)
	MOVEI	T1,200		;COMMAND REJECT
	DPB	T1,SBYTE0	; IN BYTE 0
	MOVEI	T1,2		;WRITE INHIBIT IN BYTE 1
	DPB	T1,SBYTE1
	MOVEI	T1,0		;FOR BYTE 7, MESSAGE 0,0
	DPB	T1,SBYTE7
	JRST	CHNHLT		;AND GO STOP CHANNEL PROGRAM.

SAXPIS:	MOVN	T1,P4
	MOVEI	T2,STF0
	LSH	T2,(T1)
	IORM	T2,SAXST	;SET STATUS FLAG
	MOVEI	T2,IRF0		;SEE IF ENABLED FOR INTERRUPT
	LSH	T2,(T1)
	TDNN	T2,SAXST	;SKIP IF ENABLED
	POPJ	P,
	MOVEI	T1,400000
	IORB	T1,SAXST
	ANDI	T1,7
	JUMPE	T1,CPOPJ
	JSR	MAKPI		;SET A PI REQUEST.
	POPJ	P,

;ROUTINE TO TAKE COMMAND POINTED TO BY J AND RETURN
;T3/BITS, T1/ADDRESS, T2/COUNT
; ASSUMES ONLY ONE DATA CHAIN WORD IN GROUP.
; LEAVES J POINTING TO DATA CHAIN WORD.

SETDAT:	MOVE	T1,MODE		;MAKE SURE ITS BYTE MODE
	CAIE	T1,BYT
	ERROR <COMMAND MUST BE BYTE MODE - SA-10 SIMULATOR>
	LDB	T3,[POINT 8,(J),7]
	AOS	J		;GET NEXT WORD, DATA CHAIN WORD
	MOVE	T1,(J)		;GET DATA
	LDB	T2,[POINT 12,T1,11] ;GET COUNT IN T2
	HRROI	T2,770000(T2)	;GET NEGATIVE COUNT IN BYTES
	TLZ	T1,777700	;JUST ADDRESS IN T1
	TLNE	T1,-1		;MAKE SURE NOT TRYING FOR OVER 256K
	ERROR <BYTE MODE XFER ADDRESSES MUST BE UNDER 256K>
	POPJ	P,		;OK, RETURN.



;SETWRD. CALL WITH UNIT IN U, J POINTS TO COMMAND.
; LOKE SETDAT, ONLY SETS UP UNIIOW, INCREMENTS LH OF
; TERMINATION WORD
SETWRD:	LDB	T3,[POINT 8,(J),7]
	AOS	J
	MOVE	T1,(J)
	LDB	T2,[POINT 12,T1,11] ;GET COUNT -VE
	HRROI	T2,770000(T2)	;REALLY MAKE IT NEGATIVE
	TLZ	T1,777700	;JUST ADDRESS IN T1
	MOVM	T4,T2		;GET + COUNT
	MOVSI	T4,(T4)		;GET INTO LH
	ADDM	T4,2(M)		;PUT INTO TERMINATION LH SUM
	MOVE	T4,T1
	HRL	T4,T2		;GET IOWD
	MOVEM	T4,UNIIOW(U)	;PUT INTO FAKE UNIT DATA BLOCK
	MOVE	T4,MODE		;GET MODE
	CAIE	T4,WRD
	CAIN	T4,NAT		;ONLY SKIP (DO XFER) IF WRD OR NAT MODE
	AOS	(P)
	POPJ	P,		;RETURN.

SAXSAC:	0
	MOVEM	17,SAXS+17
	MOVEI	17,SAXS
	BLT	17,SAXS+16
	JRST	@SAXSAC

SAXRAC:	0
	MOVSI	17,SAXS
	BLT	17,17
	JRST	@SAXRAC
SAXS:	BLOCK	20

GETICB:	MOVE	M,P4		;GET CHANNEL NUMBER
	LSH	M,2		;TIMES 4
	ADDI	M,SAXBAS##		;BASE ADDRESS
	POPJ	P,

CHKOFL:	SKIPE	UNIONL(U)	;IS UNIT ONLINE?
	JRST	CPOPJ1		;YES.
	MOVSI	T1,UCHK
	IORM	T1,1(M)
	MOVEI	T1,100
	DPB	T1,SBYTE0 ;INTERVENTION REQUIRED
	POPJ	P,		;RETURN.
CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,

SUBTTL FAKUNI ROUTINES TO SIMULATE LARGE DISK IN SMALL FILES
.CHPSO==32
.CHFSO==30

HSHNUM==^D40		;NUMBER OF INDEX PAGES TO START BEFORE LINKING

IDXNUM==1000/2-1		;TWO WORDS AT END FOR LINK
IDXLNK==IDXNUM*2		;POSITION OF LNK.

FUSIZ==1000			;ONE PAGE BIG.

FUREAD:	TDZA	S,S		;FLAG ITS A READ
FUWRIT:	MOVSI	S,IO		;FLAG ITS A WRITE
	PUSHJ	P,CLRBUF	;CLEAR OUT BUFFER
	HRRZ	T1,UNIIOW(U)	;GET ADDRESS
	LSH	T1,-^D7		;MAKE INTO PHYSICAL BLOCK NUMBER
	ADDI	T1,PHYOFS	;OFFSET INTO PHYS FILE
	MOVEM	T1,PHYBLK#	;SAVE IN CASE HAVE TO DO IT AGAIN.
	MOVE	T2,[.CHFSO,,PHY] ;USETO TO IT
	CHANIO	T2,T1

	PUSHJ	P,GETIDX	;GET PAGE NUMBER OF DATA FILE IN T1
	LSH	T1,2		;TURN INTO BLOCK NUMBER IN DATA FILE
	SUBI	T1,3		;PAGE 2=BLOCK 5
	MOVE	T2,UNIBLK(U)	;GET BLOCK NUMBER
	ANDI	T2,3		;JUST BLOCK WITHIN PAGE
	ADD	T1,T2		;GET CORRECT FAKE BLOCK NUMBER
	MOVE	T2,[.CHFSO,,DAT] ;USETO THERE TOO
	CHANIO	T2,T1

	MOVE	T1,UNIIOW(U)	;GET IOWD
	HLRE	T2,T1		;GET -COUNT
	MOVMS	T2		;GET +COUNT
	CAILE	T2,200		;MUST BE .LEQ. 200
	ERROR	(SA-10 SIMULATOR MUST TRANSFER 200 WORD RECORDS)
	HRRI	T1,FUBUF-1	;MAKE IOWD TO CORE
	MOVEM	T1,PHYIOW	;SET IT.
				;LEAVE IOWD COUNT,FUBUF AS IOWD FOR DAT UNLESS
	MOVE	T2,UNIIOW(U)	;ON BLOCK BOUNDARY?
	TRNN	T2,177		;SKIP IF NOT
	JRST	FUWRI1		;OK
	TRZ	T2,-177-1	;GET WORD WITHIN BLOCK
	ADDI	T1,(T2)		;THIS IS DATA COMES FROM/GOES TO IN PHYS MEM
	MOVSI	T2,-400		;MUST READ 2 BLOCKS IN, WRITE OUT 2 BLOCKS
	HLLM	T2,PHYIOW
	IN	PHY,PHYIOW	;SINCE NOT EVEN BLOCK, MUST READ, COPY, THEN WRITE
	  JRST	.+2
	ERROR	(PHYSICAL FILE INPUT ERROR)
	MOVE	T2,[.CHFSO,,PHY]
	CHANIO	T2,PHYBLK	;GET BACK TO PLACE IN CASE HAVE TO OUTPUT.
FUWRI1:	MOVEM	T1,DATIOW	;STORE IOWD FOR DATA.
	TLNN	S,IO		;SKIP IF DOING OUTPUT - PHY TO DAT
	JRST	FUINPT		;NO, DAT TO PHY.
	MOVE	T1,UNIIOW(U)	;SEE IF HAVE TO INPUT
	TRNE	T1,177		;SKIP IF HAVE TO INPUT THE DATA STILL
	JRST	PINOK		;ALREADY IN.
	IN	PHY,PHYIOW	;GET DATA IN
	  JRST	PINOK		;OK
	ERROR	(PHYSICAL FILE INPUT ERROR)
PINOK:	OUT	DAT,DATIOW	;WRITE TO "DISK"
	  POPJ	P,		;DONE.
	ERROR	(FAKE UNIT FILE OUTPUT ERROR)

FUINPT:	IN	DAT,DATIOW	;GET A PAGE OF DISK DATA
	  JRST	DINOK		;OK
	ERROR	(FAKE UNIT FILE INPUT ERROR)
DINOK:	OUT	PHY,PHYIOW	;WRITE TO "MEMORY"
	  POPJ	P,		;DONE
	ERROR	(PHYSICAL MEMORY FILE OUTPUT ERROR)

;ROUTINE TO FIND INDEX INTO DATA FILE FROM INDEX FILE GIVEN
; UNIBLK(U)

GETIDX:	MOVE	T1,UNIBLK(U)	;GET BLOCK REQUESTED
	IDIVI	T1,4		;GET PAGE NUMBER
	MOVE	T2,UNINUM(U)	;GET PHYSICAL UNIT NUMBER (NOT THE ONE WITHIN STR)
	DPB	T2,[POINT 9,T1,8]	;PUT IT IN LEFT 9 BITS
	MOVE	F,T1		;GET INTO SAFE PLACE
	IDIVI	T1,HSHNUM	;GET INDEX PAGE TO START
	AOS	T2		;CONVERT TO PAGE NUMBER, STARTS AT 1.
IDXUSO:	MOVEM	T2,IDXPAG	;SAVE PAGE FOR USETO LATER.
	MOVE	T1,[.CHPSO,,IDX]
	CHANIO	T1,T2		;GET THERE
	IN	IDX,IDXIOW
	  JRST	IDXIOK
	STATO	IDX,IODEND	;END OF FILE?
	ERROR	(INPUT ERROR FOR IDX FILE)
	SETSTS	IDX,17		;YES, CLEAR IT, AND CODE BELOW WILL WRITE PAGE OUT.

IDXIOK:	MOVE	T4,[XWD -IDXNUM,FUBUF] ;SEARCH POINTER

IDXLUP:	CAMN	F,(T4)		;HAVE A MATCH?
	JRST	IDXMAT		;YES.
	MOVE	T1,1(T4)	;NO MATCH, GET PAGE NUMBER IF ANY.
	JUMPE	T1,IDXFRE	;FREE SPACE, ADD IT
	ADDI	T4,1		;THEY ARE 2 WORD ENTRIES
	AOBJN	T4,IDXLUP	;KEEP LOOKING

;OUT OF POINTERS TO LOOK AT, SEE IF OVERFLOW

	SKIPE	T2,FUBUF+IDXLNK	;ANOTHER PAGE TO SEARCH?
	JRST	IDXUSO		;YES, GO LOOK.
	SETO	T1,		;MAKE ONE AT EOF
IDXCRE:	MOVE	T2,[.CHCFP,,IDX] ;MUST CREATE LINK PAGE
	CHANIO	T2,T1
	  ERROR (CAN'T CREATE NEW INDEX PAGE)
	CAIG	T1,HSHNUM	;MAKE SURE ITS OVER THE HASH PAGES
	JRST	[MOVEI T1,HSHNUM+1
		 JRST IDXCRE]	;AND GO CREATE THE RIGHT ONE.
	MOVEM	T1,FUBUF+IDXLNK	;NEW LINK
	OUT	IDX,IDXIOW	;OUTPUT IT
	  JRST	IDXUSO		;AND INPUT THE NEW INDEX PAGE, PLENTY OF FREE SPACE
	ERROR	(OUTPUT ERROR FOR INDEX FILE)

IDXFRE:	MOVEM	F,(T4)		;OK, FREE ENTRY SO SET THIS
	MOVE	T2,[.CHCFP,,DAT]
	SETO	T1,		;CREATE NEW DATA PAGE IN DAT FILE
	CHANIO	T2,T1
	  ERROR (CAN'T CREATE FILE PAGE IN DATA FILE)
	MOVEM	T1,1(T4)	;SET IN SECOND WORD OF ENTRY
	MOVE	T3,[.CHPSO,,IDX]
	MOVE	T2,IDXPAG	;USETO OUT AGAIN, DON'T WRITE NEXT PAGE
	CHANIO	T3,T2
	OUT	IDX,IDXIOW	;OUTPUT THE NEW DATA
	  POPJ	P,		;RETURN WITH T1 THE PAGE IN DATA FILE.
	ERROR	(OUTPUT ERROR FOR INDEX FILE.)

IDXMAT:	MOVE	T1,1(T4)	;GET PAGE IN DAT FILE TO GET
	JUMPN	T1,CPOPJ	;GO IF GOOD ONE.
	JRST	IDXFRE		;ITS FREE AND FAKE PAGE NUMBER MATCHES, GO INSERT.

CLRBUF:	SETZM	FUBUF
	MOVE	T1,[FUBUF,,FUBUF+1]
	BLT	T1,FUBUF+FUSIZ-1
	POPJ	P,

FUBUF:	BLOCK	FUSIZ		;FOR READING IN IDX, DAT, AND PHY DATA

DATIOW:	0			;PLACE TO FILL IN IOWD FOR DISK DATA FILE
	0
PHYIOW:	0			;FILLED IN FROM CHAN PROG COUNTER, RH=FUBUF-1
	0
IDXIOW:	IOWD	FUSIZ,FUBUF
	0

IDXFNM:	3
	0
	SIXBIT/IDX/
	SIXBIT/MAP/

DATFNM:	3
	0
	SIXBIT/DAT/
	SIXBIT/MAP/

IDXPAG:	0			;CURRENT INDEX PAGE.

PDLLEN==20
SAXPDL:	BLOCK	PDLLEN
DEVADD:	0
MODE:	0
SAXST:	0

DEFINE UNITCB(N)<
BPA'N'CB:	PHASE	0
UNINAM:!	SIXBIT/BPA'N/
UNINUM:!	EXP	'N
UNIIOW:!	BLOCK	2
UNISND:!		BLOCK	30
UNIBLK:!	0
UNIONL:!	0
	DEPHASE
>;END UNITCB MACRO DEFINITION

DEFINE X(A)<ZZ==0
REPEAT BPNUM,<'A(\ZZ)
ZZ==ZZ+1>>
X(UNITCB)
DEFINE UNTBL(N)<
IRP N,<EXP BPA'N'CB>>
UNTTBL:X(UNTBL)
SBYTE0:	POINT 8,UNISND(U),7
SBYTE1:	POINT 8,UNISND(U),15
SBYTE7:	POINT 8,UNISND+1(U),31

GETUPT:	0
	MOVE	T1,UBRST	;GET CORRECT WORD
	ANDI	T1,17777
	CAIN	T1,UPT/1000	;IS HE ASKING FOR THE REAL NULL UPT?
	CAMN	T1,UPTFLG	;YES, SKIP IF NEED TO GET IT BACK
	CAIL	T1,340		;NOT NULL UPT OR IS AND HAVE IT. ISS
				; DESIRED UPT IN UNACCESSIBLE PHYS MEM?
	JSR	FIXUPT		;MAKE IT ACCESSIBLE
	LSH	T1,^D9		;CAN USE IT WHERE IT REALLY IS.
	JRST	@GETUPT		;NO, JUST RETURN WITH UNPAGED ADDRESS
FIXUPT:	0			;HERE WITH T1/PAGE NUMBER TO STICK IN UPT, RETURNS WITH
				; PAGE NUMBER TO ACCESS IT IN.
	CAMN	T1,UPTFLG	;IS IT ALREADY THERE?
	JRST	FIXUP1		;YES, JUST TELL HIM UPT AND EXIT
	MOVEM	T1,UPTFLG	;REMEMBER WHICH PHYS PAGE IS REALLY IN THERE.
	MOVE	T2,[1,,<UPTBUF+777>/1000] ;YES, BORROW UPT AGE
	VCLEAR	T2,
	  ERROR (VCLEAR FAILURE BORROWING UPT)
	MOVE	T2,[6001,,<UPTBUF+777>/1000]
	MOVEM	T2,MAPARG	;MAP INTO UPT PAGE
	ADDI	T1,PHYOFS	;GET PAGE IN PHYS FILE TO MAP
	MOVEM	T1,MAPARG+1
	MOVE	T2,[.CHMAP,,PHY]
	CHANIO	T2,MAPARG	;MAP DESIRED PAGE IN
	  ERROR (CANNOT MAP UPT PAGE IN)
FIXUP1:	MOVEI	T1,<UPTBUF+777>/1000	;THIS IS WHERE TO DEAL WITH IT
	JRST	@FIXUPT		;RETURN WITH PAGE NUMBER IN T1

UPTFLG:	UPT/1000		;CONTAINS WHICH PHYSICAL PAGE IS IN UPT RIGHT NOW
UPTBUF:	BLOCK	2000		;BUFFER FOR UPT MAPPING.

GETEPT:	0
	MOVE	T1,EBRST	;GET EBR SETTING
	ANDI	T1,17777
	LSH	T1,^D9
	JRST	@GETEPT

FAKSYM:	0
	MOVE	T1,.JBSYM##
	MOVEM	T1,DDTSYM##	;SO WHEN MONITOR UPDATES IT, PATSY2 WILL PICK IT UP
	MOVE	T1,DDT##
	MOVEM	T1,DDTINS
	MOVE	T1,[JRST PATSY2]
	MOVEM	T1,DDT##
	JRST	@FAKSYM

PATSY2:	EXCH	T1,DDTSYM##
	MOVEM	T1,.JBSYM##
	EXCH	T1,DDTSYM##
DDTINS:	0
	JRST	DDT##+1

OCTOUT:	0
	MOVEM	T1,OCTVAL	;SAVE IT
	MOVE	T1,[POINT 3,OCTVAL,17] ;TYPE OUT RIGHT 6 BITS
OCTOU1:	ILDB	T2,T1
	OUTCHI	"0"(T2)
	TLNE	T1,770000	;GO TILL LOADED LAST BYE
	JRST	OCTOU1
	MOVE	T1,OCTVAL	;GET ARG BACK
	JRST	@OCTOUT

OCTVAL:	0

;CALL WITH DATA IN T2, ADDRESS IN T1

STORE:	0
	TRNN	T1,-17-1
	JRST	STORAC
	MOVEM	T2,(T1)
	JRST	@STORE
STORAC:	MOVEM	T2,@ACTAB(T1)
	JRST	@STORE

FETCH:	0
	TRNE	T1,-17-1
	SKIPA	T2,(T1)
	MOVE	T2,@ACTAB(T1)
	JRST	@FETCH

ACTAB:	EXP 0,1,2,3,4,5,66,SAVET2,10,11,12,13,14,15,16,17

	LIT
	VAR			;GET ALL LITS IN BEFORE MONDBE LABEL.

COMMENT \

THIS ROUTINE WILL HELP RUN A WELL BEHAVED USER PROGRAM WHICH IS
LOADED WITH THE MONITOR UNDER THE SIMULATOR. THE WELL BEHAVEDNESS
MUST BE AS FOLLOWS:

NO HISEG (CAN BE ACCOMPLISHED WITH HISEG PROGS BY LOADER SWITCH TO LOAD STUFF INTO LOSEG INSTEAD)
NO LOC PSEUDO OPS OTHER THAN TO THE JOB DATA AREA
RESTARTABLE (OR ELSE MUST RUN NEW SIMULATION EACH TIME)
NO MAPPING OR REMOVING (ONLY SIMIO)

THE MAXIMUM SIZE OF THE PROGRAM IN PAGES MUST BE KNOWN. THIS CAN
BE OBSERVED WHEN THE PROGRAM IS NORMALLY RUNNING, A SAFETY FACTOR ADDED,
AND ENTERED WHEN THIS ROUTINE IS STARTED UP. IF THE SIZE ENTERED IS TOO
LARGE, THE SIMULATED MONITOR MAY NOT BE ABLE TO COME UP.

OPERATING INSTRUCTIONS
----------------------

RUN THE TARGET PROGRAM TO SEE HOW BIG IT GETS WHEN ALL POSSIBLE
DYNAMIC STORAGE HAS BEEN ALLOCATED

EDIT THE MONITOR BUILDING COMMAND FILE AND PUT THE NAME OF THE PROGRAM
RIGHT AFTER DDT. (USE %S IF YOU WANT LOCAL SYMBOLS, WHICH IS NORMALLY
DESIRED)

LOAD THE MONITOR, DO THE DEBPAT THING, 2 CONTROL B TO SETUP SIMULATION

RUN THE SIMULATED MONITOR OBJECT FILE. THE SIMULATOR WILL NOTICE
THAT THERE IS SOMETHING LOADED BETWEEN DDT AND ONCE, AND WILL
ASK FOR A MAXIMUM SIZE. ENTER THE NUMBER OF PAGES WHICH WILL
BE USED BY THE PROGRAM AT ITS LARGEST.

BRING UP THE SIMULATED MONITOR

DO A "CORE 1" COMMAND UNDER THE SIMULATED MONITOR'S COMMAND PROCESSOR
TO GET SOME CORE. THEN GET INTO SIMULATED USER DDT (ST 141)
AND SAY "USRSET$G", THEN SAY <TEST PROG START ADDRESS>$G.
\

	CH==M			;PLACE FOR CHARACTER
EXTERNAL PATSIZ,ONCGO		;INCASE LOADED WITH THE MONITOR

FAKJDA::JFCL
	MESSCR	<[SIMKL:TEST PROGRAM IS LOADED WITH THIS MONITOR.>
GETFSZ:	MESS	<MAXIMUM SIZE OF PROGRAM IN PAGES:>
	MOVEI	CH,-1		;SO DOESN'T THINK THERE IS BREAK
	PUSHJ	P,DECIN
	  JRST	[MESSCR <BAD ARGUMENT ENTERED>
		 JRST GETFSZ]
	LSH	T1,^D9		;TURN INTO WORDS
	ADDI	T1,DDTEND	;SIZE PLUS PROGRAM ORIGIN GIVES END.
	TRO	T1,777		;ROUND UP TO PAGE BOUNDARY
	MOVEM	T1,PATSIZ	;SAVE. PROG MUST BE LOADED RIGHT AFTER
	HRRM	T1,.JBCOR##	;SAVE HERE AS IF CORE ARG WAS GIVEN ON SVE.
	MOVEM	T1,.JBREL##	;AND SAVE IN PLACE WHERE PROGS LOOK AT IT.
	MOVEM	T1,SAVREL	;SAVE SO CAN SET IT BACK UP LATER.
	MOVEI	T1,ONCGO	;GET WHAT JOBFF SHOULD BE
	MOVEM	T1,.JBFF##
	HRLM	T1,.JBSA##	;AND SETUP LH OF .JBSA TO BE WHAT JOBFF SHOULD BE ON A RESET
	MESS	<JOB DATA AREA SETUP.]>
	POPJ	P,		;AND RETURN

SAVREL:	0			;SET IT BACK UP FROM HERE.

DECIN:	SETZ	T1,		;CLEAR RESULT
	PUSHJ	P,ISBRK		;WAS LAST SEP CHAR A BREAK?
	  POPJ	P,		;YES, FIELD IS BLANK
DECIN0:	PUSHJ	P,GTCHR		;SCAN TO FIRST DIGIT IF ANY
	PUSHJ	P,ISBRK		;IS IT BLANK?
	  POPJ	P,		;YES, ERROR
	CAIL	CH,"0"		;IS IT NUMERIC
	CAILE	CH,"9"
	JRST	DECIN0		;NO, SKIP THE NUMBERS
	SKIPA			;OK, HAVE FIRST ONE.
DECIN1:	PUSHJ	P,GTCHR		;GET CHAR
	CAIL	CH,"0"		;MUST BE NUMBER
	CAILE	CH,"9"
	JRST	CPOPJ1
	IMULI	T1,^D10
	ADDI	T1,-"0"(CH)	;GET IT IN
	JRST	DECIN1		;AND GO FOR MORE

ISBRK:	CAIE	CH,176
	CAIG	CH,37
	POPJ	P,
	JRST	CPOPJ1

GTCHR:	INCHWL	CH		;GET IT
	CAIN	CH,15		;IGNORE CR
	JRST	GTCHR
	POPJ	P,		;AND RETURN WITH IT IN CH


REPEAT 0,<;NOT NEEDED RIGHT NOW.
SCANER:	SETZM FNAME
 	SETZM FEXT
S1:	MOVE T1,[POINT 6,FNAME]
	MOVEI T2,6
	SETZM FNAME
S2:	INCHWL T3
	CAIN T3,15	; IF <CR> EAT LF
	  INCHWL T3
	CAIL T3,140
	  SUBI T3,40
	CAIN T3,"("
	  JRST [MOVE T1,[POINT 6,USRNAM]
		 MOVEI T3,USRNAM
		 MOVEM T3,FPPN
		MOVEI T2,14
		SETZM USRNAM
		SETZM USRNAM+1
		JRST S2]
	CAIN T3,")"
	  JRST S1
	CAIN T3,"."
	  JRST [MOVE T1,[POINT 6,FEXT]
		MOVEI T2,3
		SETZM FEXT
		JRST S2]
	SUBI T3,40
	JUMPL T3,CPOPJ
	JUMPE T3,S2
	SOJL T2,S2
	IDPB T3,T1
	JRST S2

USRNAM:	BLOCK	2

FBLOCK:	3
FPPN:	0
FNAME:	BLOCK	1
FEXT:	BLOCK	1
>;END REPEAT 0

    Entry KL$SIM	; For ONCE.	*** Note: inside repeat 0 ***
KL$SIM:: Z

	LIT
	VAR			;GET LITERALS AND VARIABLES OUT BEFORE END OF SIMULATOR PROTECTED AREA

MONDBE:				;LAST LABEL IN MONDEB SIMULATOR.
USRSET::EXCH	T1,SAVREL	;GET JOBREL
	MOVEM	T1,.JBREL##	;AND SET IT BACK UP
	EXCH	T1,SAVREL	;GET T1 BACK AGAIN
	JRST	DDT##		;GO BACK TO DDT.

USRCOD::
	MOVE	0,[JRST 0]
	JRST	0
	BLOCK	200		;PLACE TO WRITE "USER" PROGRAMS.
USRCDE:

>	;; End of REPEAT 0
	;; End of commenting OUT the entire KL-Simulator

	END
 { t