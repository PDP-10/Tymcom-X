TITLE COMCON - COMMAND DECODER PAGING SYS
SUBTTL /RCC/PFC 	29 OCT 70
XP VCOMCN,513
				;THIS MACRO PUTS VERSION NO. IN STORAGE MAP AND GLOB

	ENTRY COMCON	;ALWAYS LOAD COMCON IF LIBRARY SEARCH
COMCON:

;CALLED FROM CLOCK ROUTINE WHEN 'COMCNT' IS GREATER THAN 0
;AS SET BY COMMAND SERVICE ROUTINE
;ALL AC'S HAVE BEEN SAVED BY CLOCK CHANNEL
;THE COMMAND DECODER CALLS FRMCOM WHICH SCANS FOR FRAME WHICH REQUESTED
;THE COMMAND AND THEN DISPATCHES(PUSHJ) TO APPROPRIATE
;COMMAND SETUP ROUTINE WITH AC'S SET AS:
;J = JOB NUMBER
;F = ADDRESS OF DEVICE DATA BLOCK TYPING COMMAND, IF ANY
;R = ADDRESS OF JOB AREA, = 0 IF NO JOB AREA
;R = ADDRESS OF PROGRAM AREA, 0 MEANS NOT IN CORE OR NO CORE
;S IS SET TO 0, USED FOR ADDRESS OF SUBSEQUENT CALLS
;U = ADDRESS OF U DATA BLOCK OF TTY TYPING COMMAND (IF ANY)
;P3 = DISPATCH ROUTINE ADDRESS AND BITS
;P4 = JOB STATUS WORD (C(JBTSTS(J)))
;UPON RETURN FROM COMMAND SETUP ROUTINE, A CR-LF IS ADDED TO
;MESSAGE AND TTY IS STARTED ON TTY SPECIFIED BY -1(P)
;SEVERAL COMMAND FLAGS ARE CHECKED BEFORE DISPATCHING TO
;COMMAND SETUP ROUTINES TO SEE IF COMMAND IS LEGAL AT THIS TIME
;SEVERAL MORE FLAGS ARE CHECKED UPON RETURN FROM COMMAND SETUP
;ROUTINES(UNLESS AN ERROR HAS OCCURRED) FOR STANDARD
;COMMAND RESPONSE

;SINCE THE COMMAND DECODER IS CALLED FROM THE CLOCK ROUTINE
;COMMAND SETUP ROUTINE MUST RUN TO COMPLETION QUICKLY
;IF A COMMAND FUNCTION CANNOT DO THIS, IT MUST JUST SET
;THE JOB TO RUNABLE STATUS AND RETURN IMMEDIATELY
;OR DELAY THE COMMAND FOR LATER EXECUTION

INTERNAL COMMAND,FCONRQ
EXTERNAL COMCNT,JBTSTS,JOBMAX,JBTUPM,JOBHRL
EXTERNAL UPTHCU,UPTJDA,UPTPC,UPTPDL,UPTREL,NOCORQ,%UPT,%UPS
EXTERNAL UPTPID,UPTSPD
EXTERNAL TTYSET,DVCNSG,TTYSTC
EXTERNAL DEVOPR,LDBLOG,UPTRNM,UPTRPN,MAPUPS
EXTERNAL JBTPRV,JBTNAM,JBTLIC,JBTSLC
EXTERNAL HIGHJB
EXTERNAL STRTAL,STRDDB
EXTERNAL TTYSTR,TTYUSR,TTYUSW
EXTERNAL TTYFUW,SGSET,SGSETD,STRTAD,UPTSTS,ACTWRT,STRTCL
EXTERNAL ANYACT,ASSASG,DEVLG,DEVPHY,DEVSRC
EXTERNAL DLYCOM,ESTOP,KSTOP,MONJOB,DECP1,TRHALT
EXTERNAL MONSTR,MSTART,OCTPNT,PHOLD,PRNAME,RADX10,RELEA5
EXTERNAL RELEA6,RESET,SETRUN,ERRFCL,STOP1
EXTERNAL USRXIT,USTART,UUOERR

EXTERNAL JBTCNK
EXTERNAL PVYMOD
EXTERN KILLHS,HSEXIS,LSSIZE,SAVJOB,GETJOB,RUNJOB,RUNJB2,UPTHRL
EXTERN HSSIZE,KILLLS
;EXTERNS IN COMMON FOR SWAPPER
EXTERN JBTICT,JBTCTX,JBTINA

COMMENT ! ROUTINE "COMMAND" -- CLOCK LEVEL COMMAND DECODER !

COMMAND:PUSHJ	P,FRMCOM	;SETUP F,U,AND J FOR ANY FRAME
				; WHICH HAS TYPED A COMMAND
	  POPJ	P,		;NONE FOUND
	HLLZS	JBTINA(J)	;RESET INACTIVITY TIMEOUT
	MOVEM	J,COMJSV	;Save job number from FRMCOM
				; since some commands (ATTACH,etc.)
				; change job # in mid-command.
	PUSH	P,U		;Save TTY LDB address, if any
	LDB	T1,CMDCMX	;GET FORCED COMMAND INDEX, IF ANY
	MOVSI	T2,CMDCMF	;IS COMMAND FORCED?
	TDNE	T2,TTYTAB(J)	; ..
	  SKIPA	T2,CMFCOM(T1)	;YES. GET SIXBIT NAME OF COMMAND
	  PUSHJ	P,CTEXT		;SCAN COMMAND NAME, RETURN IT IN T2
	MOVE	T1,T2		;COPY COMMAND.
	MOVNI	T4,1		;SET MASK ALL ONES
	LSH	T4,-6		;CLEAR OUT ONE MORE CHAR.
	LSH	T1,6		;SHIFT 1 COMMAND CHAR OFF
	JUMPN	T1,.-2		;IF NOT END OF COMMAND, GO AROUND
	MOVEI	S,0		;CLEAR FLAG REGISTER
	LDB	P4,PVYMOD	;GET MODE
	MOVE	P4,CMDMOD(P4)
	MOVE	T1,JBTPRV(J)
	JUMPL	T1,.+2		;LogoutOnStop implies RCM
	 TRNE	T1,PVRCMD	;RESTRICTED COMMAND MODE?
	  MOVE	P4,CMDRES	;YES. USER RESTRICTED COMMAND LIST
COMLP1:	MOVE	T1,(P4)		;GET AOBJN FOR THIS SECTION
	TLO	T1,700000	;THESE USED FOR TYPE INFO
COMLP:	MOVE	T3,COMTAB(T1)	;GET COMMAND
	TDZ	T3,T4	;MASK
	CAMN	T2,COMTAB(T1)	;EXACT MATCH
	  JRST	COMFND
	CAME	T2,T3		;OR MASKED MATCH
	  JRST	COMNEQ		;NO
	TROE	S,1
	 TRO	S,2		;FLAG SECOND MATCH
	HRR	P3,T1		;SAVE TABLE POINTER
	HRL	P3,P4		;AND AOBJN POINTER FOR TYPE
COMNEQ:	AOBJN	T1,COMLP	;MORE OF THIS SECTION
	AOBJN	P4,COMLP1	;NEXT SECTION
	CAIE	S,1
	  JRST	@(P4)		;NOT FOUND OR MULTI MATCH
	HRRZ	T1,P3		;RESTORE COMMAND POINTERS
	HLRZ	P4,P3
COMFND:	LDB	P3,[POINT 3,(P4),2] ;GET TYPE
	XCT	MDSP(P3)	;AND ACT ON IT
COMFN1:	MOVE	T3,T1		;SAVE NUMBER FOR PRGRUN

	PUSH	P,T3		;SAVE COMMAND ADDRESS
	MOVE	P4,JBTSTS(J)	;JOB STATUS WORD FOR THIS JOB
	TLNN	P4,JLOG		;IS JOB LOGGED IN?
	  TLNE	P3,NOLOGIN	;NO, CAN CMND PROCEED WITH NO LOGIN?
	  JRST	CHKRUN		;YES
	JSP	T1,COMER	;NO, TYPE "LOGIN PLEASE"
	ASCIZ /?login please
/
CHKRUN:	MOVEI	W,0		;PHYSICAL I/O FLAG
	TLNE	P4,RUN		;RUN BIT ON IN JOB STATUS?
	  TLNN	P3,NORUN	;YES, DOES THIS COMMAND REQUIRE A JOB?
	  JRST	CHKACT		;NO
	LDB	T1,PVYMOD	;YES, DECIDE ON MESSAGE
	XCT	CKRCER(T1)
	JRST	COMER

CKRCER:	MOVEI	T1,TYPCC
	MOVEI	T1,TYPESC
	MOVEI	T1,TYPESC
	MOVEI	T1,TYPCC

TYPCC:	ASCIZ	/?please type ^C first
/

TYPESC:	ASCIZ /?please type ESC first
/

CHKACT:	TLNN	P3,INCOR!MINCOR	;NEED AT LEAST CONTEXT PGS IN CORE?
	  JRST	CHKCO2		;NO
	TRNE	P4,SWPINP	;ANY SWAPPING GOING ON?
	  JRST	[HRRI P3,DLYCM1	;Wait to finish swap,don't set cmnd wait
		 JRST COMDIS]
	MOVEI	T1,PRF		;MAKE SURE NONE STARTS UP
	ANDCAM	T1,JBTSTS(J)
	SKIPGE	JBTCTX(J)	;ARE CONTEXT PAGES IN CORE?
	  JRST	CHKCO2		;YES, EVERYTHING IS OK.
	MOVSI	T1,MRQ		;FORCE JOB TO COME IN
	IORM	T1,JBTSTS(J)	; BY MAKING SWAPPER SEE IT
	MOVSI	T1,JSTCTX	;GOING TO THROW AWAY USER'S ADDRESS
	TLNE	P3,MINCOR	; SPACE ANYWAY?
	  IORM	T1,JBTCTX(J)	;YES, TELL SWAPPER JUST DO CNTXT PAGES.
	HRRI	P3,DLYCM	;PUT JOB INTO COMMAND WAIT QUEUE
	JRST	COMDIS		;AND COME BACK LATER

CHKCO2:	TLNE	P3,NOACT	;CAN CMND BE PERFORMED WITH ACTIVE DEVICES?
	SKIPL	JBTCTX(J)	;No, does job have any core assigned?
	  JRST	.+3		;No core/no devices active or don't care
	PUSHJ	P,ANYACT##	;May be active devices, go check
	  JRST	DLYCM		;Devices active, delay command

	TLNN	P3,HVCORE	;DOES THIS COMMAND NEED CORE?
	  JRST	COMGO		;NO. GO DISPATCH
	HLRZ	T1,JBTUPM(J)	;YES, DOES THE JOB HAVE ANY EXISTENT
	JUMPN	T1,COMGO	;PAGES? IF SO, OK
	JSP	T1,COMER	;NO, PRINT "NO CORE ASSIGNED"
	ASCIZ /?no core assigned
/
				; ALL GONE, NEXT TIME UPTHCU WILL BE 0

COMER:	HRRZI	P3,ERRMES

COMGO:
	TLNN	P4,CMWB		;CLEAR CMWB; WAS JOB IN COMM WAIT
	  TLZ	P3,CMWRQ	;No, clear req. bit in disp. flags
	MOVSI	S,CMWB
	ANDCAB	S,JBTSTS(J)

COMDIS:	MOVEI	S,0		;CLEAR S FOR SETTING DISPATCH ADDRESSES
	POP	P,T3		;RESTORE COMMAND POINTER
	PUSHJ	P,(P3)		;DISPATCH TO COMMAND SETUP ROUTINE.

;RETURN FROM COMMAND SETUP ROUTINE

	POP	P,U		;RESTORE TTY LDB ADDRESS
	SKIPN	J		;If anyone fucked with job #
	  JSR	SYSCRS		;Become extremely pissed off
	HRRZ	F,TTYTAB(J)	;Restore TTY DDB address
	EXCH	J,COMJSV	;Restore original job # from FRMCOM
	PUSHJ	P,COMCMR	;INDICATE COMMAND IS COMPLETED
	MOVE	J,COMJSV	;Restore current job number
	TLNE	P3,ERRFLG	;Did an error occur?
	  MOVSI	P3,ERRFLG+CMWRQ ;YES, JOB NUMBER REQUIRED, BUT
				; NONE IN ITEM. PRINT ERROR MESSAGE
				; ONLY, AND REQUEUE JOB IF NECESSARY.

PCRLF:	MOVEI	T1,JDCON
	TLNE	P3,TTYRNU!TTYRNC!TTYRNW
	ANDCAM	T1,JBTSTS(J)	;STARTING CLEAR JCONT BIT
	TLNE	P3,NOMESS	;MESSAGE SUPPRESSED?
	JRST	PCRLF0		;YES, SKIP WATCH STUFF TOO
	TLNE	P3,TTYRNU!TTYRNC!TTYRNW	
			;COMMAND START JOB UP (TTY IN EITHER MODE)?
	PUSHJ	P,WCHBEG	;YES, PRINT [HH:MM:SS] STARTED TO WAIT
				; FOR RESPONSE
PCRLF0:	TLNN	P3,NOCRLF	;SUPPRESS CRLF?
	  PUSHJ	P,CRLF		;NO
	TLNN	P3,NOPER	;SUPPRESS PRINTING PERIOD?
	  PUSHJ	P,PRPER		;NO
	TLNE	P3,ERRFLG	;Job does not run if error
	  JRST	PCRLF1
	TLNE	P3,TTYRNU	;JOB TO RUN WHEN TTY FINISHED TYPING?
				; COMMAND RESPONSE (TTY TO USER MODE)?
	  PUSHJ	P,TTYUSR	;YES, CALL SCANNER/SCHEDULER ROUTINES
	TLNE	P3,TTYRNW	;CMND RESTART TTY RESPECTING IO WAIT?
	  PUSHJ	P,TTYUSW	;YES,CALL SCANNER ROUTINE AND SCHEDULER
	TLNE	P3,TTYRNC	;NO, RUN JOB AND STAY IN MONITOR MODE?
	  PUSHJ	P,SETRUN	;YES, CALL SCHEDULER ROUTINE
PCRLF1:	TLNE	P3,NOMESS	;IS THERE A MESSAGE?
	  JRST	.+3		;Skip around if message suppress
	PUSHJ	P,TTYSTR	;YES, START TTY TYPING IT OUT
	PUSHJ	P,CHKKIL	;Also see if job needs killing
	JUMPE	U,.+3		;Skip buffer clear if no LDB
	TLNE	P3,ERRFLG	;WAS THERE AN ERROR?
	  PUSHJ	P,TSETBI	;YES, CLEAR INPUT BUFFER

	EXTERN	PJOBN,REQUE

	CAME	J,JOB		;NEVER SET JRQ FOR CURRENT JOB!
	TLNN	P3,CMWRQ	;REQUEUE JOB AFTER CMND WAIT OR ERROR?
	  POPJ	P,		;NO -CURRENT JOB OR DON'T REQUEUE
	JRST	REQUE		;YES

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	Routine CHKKIL - See if a job needs to be killed.	;;
;;								;;
;;	Called at command finish-up unless NOMESS=1 (message	;;
;;	suppress - used for FCONT & KJOB).			;;
;;								;;
;;	Entered with J=job/frame number, F=DDB address		;;
;;								;;
;;	Cheerfully clobbers T1, T4, and U.			;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHKKIL:
	MOVSI	T4,CMDCMK!CMDCK2 ;Job kill bits
	TDNN	T4,TTYTAB(J)	;Any set?
	  POPJ	P,		;No, no need to kill
	MOVSI	T1,RUN
	TDNN	T1,JBTSTS(J)	;Is job/frame running?
	  JRST	SETKIL		;No, just kill it
;;
;; Job is running, therefore must be halted before killing.
;;
	HRRZ	U,DDBLDB(F)	;Set up Line Data Block address
	SKIPE	U		;Skip if detached
	  PUSHJ	P,TTYHLT##	;Put TTY in command mode (^C)
	MOVEI	T1,CMFCHT	;Forced command index for .HALT
	PJRST	COMWCM		;Set forced halt for job/frame

SETKIL:
	MOVE	T1,TTYTAB(J)	job kill bits
	ANDCAM	T4,TTYTAB(J)	;Clear any that may be set
IFDEF .PVHKJ,<
	TLNE	T1,CMDCK2	;"Really Kill" set?
	  JRST	KJBIT		;If so, really kill it
	LDB	T4,PVYHNG##	;Get HANG/ZAP action field
	XCT	[JRST KJBIT	;0 .PVHKJ KJOB
		 JRST KJBT1	;1 .PVHDT DETACH
		 STOPCD		;2 .PVHCN CCONT DETACH
		 JRST KJBT3](T4) ;3 .PVHTM DETACH TIMEOUT KJOB

KJBT3:	SETZ	T1,
	DPB	J,CLKJOB##
	PUSHJ	P,CHGCLK##	;Remove any type 0 on list
	MOVE	T1,TIMSET##	;And replace with type .SLHNG
	DPB	J,CLKJOB##
	PUSHJ	P,CHGCLK##
KJBT1:	SKIPA	T1,[CMFCDT]
KJBIT:> ;End IFDEF .PVHKJ
	MOVEI	T1,CMFCKJ	;Cmd index for KJOB
	PUSHJ	P,COMWCM	;Set command for job/frame
	POPJ	P,

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	Routine COMKJB - Kill a detached job/frame		;;
;;								;;
;;	Calling parameters -					;;
;;		J - job/frame number				;;
;;								;;
;;	Clobbers T1.						;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COMKJB::
	MOVSI	T1,CMDCMK	;Action determined by JBTPRV<PVYHNG>
	IORM	T1,TTYTAB(J)	;Set into command port word
	MOVEI	T1,JACCT2	;User-JACCT
	ANDCAM	T1,JBTSTS(J)	;Clear it out
	SETZM	JBTLIM(J)	;Also clear TRU limit
	MOVEI	T1,CMFCHT	;Forced command index for HALT
	PUSHJ	P,COMWCM	;Command dispatcher will do the rest
	POPJ	P,

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	Routine COMWCM - Set Command Request For a Job/Frame	;;
;;								;;
;;	Calling Parameters:					;;
;;		AC J - Job/Frame Number (not checked, must be	;;
;;			valid).					;;
;;		AC T1 - Command Index (or zero if none - zero	;;
;;			means command input from TTY).		;;
;;								;;
;;	Registers Used:						;;
;;		T1 - Clobbered					;;
;;		T2,T3 - Saved, used, & restored			;;
;;		All other ACs preserved.			;;
;;								;;
;;	Calling Sequence:					;;
;;		MOVE J,[job/frame number]			;;
;;		MOVEI T1,<command index>			;;
;;		PUSHJ P,COMWCM					;;
;;		<only return>					;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COMWCM::
	SKIPL	TTYTAB(J)	;Command request already set?
	  AOS	COMCNT		;No, count one waiting
	JUMPE	T1,.+3		;If no index, command is from TTY
	DPB	T1,CMDCMX	;Set command index into LH(TTYTAB(J))
	MOVSI	T1,CMDCMF	;And indicate that command is forced
	TLO	T1,CMDCMR	;Command Request bit
	IORM	T1,TTYTAB(J)	;Set into LH(TTYTAB(J))
	PUSH	P,T2		;Get some scratch space
	PUSH	P,T3		;And some more
	MOVEI	T2,(J)		;Copy job/frame number
	IDIVI	T2,^D36		;T2 gets index into bit table, T3 gets
				; number of relative bit in word
	MOVE	T3,BITTBL##(T3)	;Convert to actual bit (reverse JFFO)
	IORM	T3,COMFLG##(T2)	;Set bit in command table
	POP	P,T3		;Thank you very much
	POP	P,T2		; for your kind assistance
	POPJ	P,		;Exit

	CMDCMR=400000		;0 - Command Request (must be sign bit)
	CMDCMF=200000		;1 - Command Forced via CMDCMX
	CMDCMK=100000		;2 - Forcing KJOB command
	CMDCK2=040000		;3 - Really KJOB (never DETACH)
				;10-13 - Forced Command Index

CMDCMX:	POINT	4,TTYTAB(J),13	;Byte pointer for Forced Command Index
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	CMFIDX - Find command index				;;
;;	Calling sequence:					;;
;;		MOVE	T1,[SIXBIT /6chars/]			;;
;;		PUSHJ	P,CMFIDX##				;;
;;		  error return	/T1 clobbered			;;
;;		success return	/T1=CMFCOM index		;;
;;	All other AC's preserved.				;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CMFIDX::JUMPE	T1,CPOPJ	;Zero is always illegal
	PUSH	P,T2		;Work space
	MOVSI	T2,-CMFSIZ	;AOBJN pointer
	CAMN	T1,CMFCOM(T2)	;Exact match?
	  AOSA	-1(P)		;Yes, give success return
	AOBJN	T2,.-2
	HRRZ	T1,T2		;Either found it or overran
	POP	P,T2
	POPJ	P,

; Forced command table

CMFCOM:
PHASE 0
	0	;Dummy illegal entry
CMFCXN::! SIXBIT /.LOGIN/
CMFCKJ:! SIXBIT /KJOB/
CMFCDT:! SIXBIT /DETACH/
CMFCHT::! SIXBIT /HALT/
CMFCXI::! SIXBIT /INITIA/
CMFCXJ:! SIXBIT /.FCONT/
CMFCKM::! SIXBIT /.KMCLO/
CMFSTA::! SIXBIT /.USEST/
	CMFSIZ=CMFCKM	;Size of command table
DEPHASE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	Routine COMCMR - Command Return (clean-up)		;;
;;								;;
;;	Called after command has been processed to clean	;;
;;	up the command dispatch database (mostly adjusting	;;
;;	LH(TTYTAB) and the COMFLG bitmap table)			;;
;;								;;
;;	Entered with J=job/frame number, F=TTY DDB address	;;
;;								;;
;;	Clobbers T1, T2.					;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COMCMR:
	MOVSI	T2,CMDCMF	;Forced command?
	TDNN	T2,TTYTAB(J)	;??
	  PUSHJ	P,TTYCMR##	;No, from TTY, tell terminal service
	TLO	T2,CMDCMR	;Command request flag
	ANDCAM	T2,TTYTAB(J)	;Clear request and force bit
	SOS	COMCNT		;One less frame with command pending
CMDRST:
	MOVEI	T1,(J)		;Copy job number
	IDIVI	T1,^D36		;Get COMFLG index and relative bit #
	MOVE	T2,BITTBL##(T2)	;Get appropriate bit
	ANDCAM	T2,COMFLG##(T1)	;Clear it out
	POPJ	P,

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	Routine CMDCKW - Check for job in command wait		;;
;;								;;
;;	Called with U=LDB address of port in question.		;;
;;								;;
;;	Skip returns if job associated with given port has	;;
;;	command pending, non-skip otherwise.			;;
;;								;;
;;	Calling sequence:					;;
;;		MOVE U,[LDB address]				;;
;;		PUSHJ P,CMDCKW					;;
;;		  <job has command pending>			;;
;;		<no job or no command pending>			;;
;;								;;
;;	Clobbers F.						;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CMDCKW::
	HRRZ	F,LDBDDB(U)	;Get DDB address
	JUMPE	F,CPOPJ1	;No job, success return
	LDB	F,PJOBN		;Job/Frame number from DDB
	JUMPE	F,CPOPJ1	;No job??
	SKIPL	TTYTAB(F)	;Command request pending?
	AOS	(P)		;No - give success return
	POPJ	P,		;Non-skip - CMR pending
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	Routine FRMCOM - Find a frame with Command Request	;;
;;			 pending.				;;
;;								;;
;;	Calling parameters: none.				;;
;;								;;
;;	Registers used:						;;
;;		AC's T1, T2, T3 - scratch (clobbered)		;;
;;		AC J - returns job/frame number			;;
;;		AC F - returns DDB address of frame's command	;;
;;			port.					;;
;;		AC U - returns LDB address of frame's command	;;
;;			port or zero if detached.		;;
;;								;;
;;	Calling sequence:					;;
;;		PUSHJ	P,FRMCOM				;;
;;		  <error return> - no frames with CMD REQ	;;
;;		<success> - J, F, and U set up			;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FRMCOM:
	SKIPGE	T2,COMSAV	;Starting a new scan?
	  JRST	CMDRCM		;No - continue from middle of table
	MOVSI	T2,NCMFLG##	;Set to scan all frames
CMDSC1:	SKIPN	U,COMFLG(T2)	;Any bits set?
	  JRST	NOCOM2		;No - try next word in bit-map table
	MOVE	T3,BITNTB##(T2)	;Get frame number for first bit
CMDSC2:	JFFO	U,.+2		;Find first "1" bit
	  JRST	NOCOM2		;None - try next word
	LSH	U,1(T1)		;Answer in T1, get rid of first bit
	MOVEM	U,COMFSV	;Save for later inspection
	ADD	T3,T1		;Get frame number
	MOVEM	T3,COMPNM	;Save frame number of first bit in
				; 'COMFSV'
	MOVEM	T2,COMSAV	;Save COMFLG AOBJN word
	HRRZ	J,T3		;Get frame number
	MOVSI	T2,CMDCMR	;"Command Request"
	TDNN	T2,TTYTAB(J)	;Really set for this frame?
	  JRST	CMDSCE		;No - clear COMFLG bit and continue
CMDSC3:	HRRZ	F,TTYTAB(J)	;Set up Device Data Block address
	SKIPE	U,F		;If none, skip and clear LDB also
	  HRRZ	U,DDBLDB(F)	;Else set up Line Data Block address
	HLLZ	T3,TTYTAB(J)	;Get command bits to left half
	HRRI	T3,12		;Set up command delimiter in case forced
	TLNE	T3,CMDCMF	;Is this a forced command?
	  JRST	CMDSC4		;If so, skip TTY diddling
	JUMPE	U,CMDSCE	;Only forced commands can be detached
	PUSHJ	P,TRESCN	;Set up terminal command input
	SKIPA
CMDSC4:	  HRRZM	T3,TTCMCH	;If forced command, force no more input
	PJRST	CPOPJ1		;Give good return

;;
;; Error exit from FRMCOM
;;
CMDSCE:
	PUSHJ	P,CMDRST	;Reset bit in COMFLG table
	MOVE	T2,COMSAV	;Get ready to rescan
CMDRCM:	AOS	T3,COMPNM	;Set up next frame to scan
	SKIPE	U,COMFSV	;Any bits left in this word?
	  JRST	CMDSC2		;If yes, pick up in the middle
NOCOM2:	AOBJN	T2,CMDSC1	;Else loop to next COMFLG word
	SETZM	COMSAV		;End of table - none there
	POPJ	P,		;Give non-skip return

;;
;; Save area for FRMCOM routine
;;
COMSAV:	0
COMFSV:	0
COMJSV:	0
COMPNM:	0
;TABLE OF CONSOLE COMMANDS


;BITS CHECKED BEFORE DISPATCHING TO COMMAND SETUP ROUTINE

HVCORE==400000	;JOB MUST HAVE AT LEAST ONE EXISTENT PAGE IN ITS SPACE.
NOLOGIN==100000	;JOB DOES NOT NEED TO BE ALREADY LOGGED IN.
NOACT==40000	;COMMAND MUST BE DELAYED IF JOB HAS ACTIVE DEVICES.
MINCOR==20000	;DO NOT SWAP IN MWS, JUST CONTEXT PAGES.
NORUN==10000	;AN EXPLICIT ^C MUST BE TYPED BY USER BEFORE COMMAND
		; IS EXECUTED IF JOB IS RUNNING
		; JOB MUST BE SWAPPED IN IF IT HAS LOGICAL CORE
INCOR==4000	;NEED AT LEAST UPT IN CORE
PLSXPN==4	;CORE MUST BE EXPANDED IF STILL COMPRESSED BY SAVE NOT GOING
		; TO COMPLETION(CONTROL C OR DEVICE OK?)
		; MUST BE USED IN CONJUNCTION WITH COMMANDS WHICH
		; NEED CORE AND NEED IT IN CORE

;BITS CHECKED AFTER RETURN FROM COMMAND SETUP ROUTINE

CMWRQ==2000	;REQUEUE JOB AFTER COMMAND WAIT

NOCRLF==200	;NO PRINTING OF CRLF
NOPER==100	;NO PRINTING OF PERIOD
TTYRNU==40	;SET TTY TO USER MODE AND START JOB
		; WHEN COMMAND RESPONSE STOPS TYPING
TTYRNC==20	;KEEP TTY IN COMMAND MODE AND START JOB
		; WHEN COMMAND RESPONSE STOPS TYPING
TTYRNW==10	;SET TTY TO USER LEVEL AND IO WAIT IF IT WAS IN IOW BEFORE
NOMESS==2	;NO COMMAND RESPONSE EVER, DO NOT CALL TTYSTR

		;4 TAKEN ABOVE BY 'PLSXPN' BIT


ERRFLG==1	;COMMAND ERROR

RPGBITS==NOPER!TTYRNU!NOCRLF!MINCOR!NOACT!NORUN
NOTIC==NOLOGIN!NOPER!NOCRLF!NOACT!NORUN

;DEFINE NAMES FOR COMMANDS HANDLED BY COMCON


DEFINE NAMES <
	CP LP101
	CP LP941
	CP LPGE1
	C R,RCOM,RPGBITS
	C RUN,RUNCOM,RPGBITS
	C PCOM,PCOM,RPGBITS
	C DCOM,PCOM,RPGBITS
	C SSAVE,SSAVE,HVCORE!NOCRLF!NOPER!TTYRNU!INCOR!NOACT!NORUN!PLSXPN
	C RESOURCES,FREDEV
	C FINISH,CFINI,HVCORE!TTYRNU!NOACT!INCOR!NORUN!NOPER!NOCRLF!PLSXPN
	C SAVE,SAVE,HVCORE!NOCRLF!NOPER!TTYRNU!INCOR!NOACT!NORUN!PLSXPN
	CP LPSUD1
	C DAYTIME,DAYTIM
	C SET,SETCMD,INCOR
	C TTY,TTYCMD
	C CLOSE,CLSCOM,HVCORE!TTYRNU!NOACT!INCOR!NORUN!NOPER!NOCRLF!PLSXPN
	C REENTER,REENTER,HVCORE!TTYRNU!NOPER!INCOR!NORUN!PLSXPN
	C CORE,CORE,NORUN!CMWRQ!INCOR!NOACT
	C VMINFO,VMINFO,INCOR
	C .USEST,USESTAT,NOPER
	C TIME,RUNTIM
	CP LPRES1
	C EXIT,KJB1,NOTIC!NOMESS!MINCOR
	C HALT,STOP,NOLOGIN!CMWRQ
	C DETACH,DETACH,NOPER!NOCRLF
	C .FCONT,FCONT,HVCORE!NOPER!NOCRLF!NOMESS!NORUN!INCOR!NOLOGIN
	C .LOGIN,CLOGIN,NOTIC!TTYRNU!MINCOR
	C CONTINUE,CONT,HVCORE!NOPER!TTYRNW!INCOR!NORUN
	C INI,INITIA,NOTIC!TTYRNU!MINCOR
	C INITIA,INITIA,NOTIC!TTYRNU!MINCOR
IFKMC<	C .KMCLO,KMCLOD,NOTIC!TTYRNU!MINCOR>
	C <>,CBLANK,NOLOGIN!NOCRLF
	C LOGOUT,KJOB,NOTIC!NOMESS!MINCOR
	C KJOB,KJOB,NOTIC!NOMESS!MINCOR
	C BYE,KJOB,NOTIC!NOMESS!MINCOR
	C POP,KJOB,NOTIC!NOMESS!MINCOR
	CP LPRES2
	C START,START,HVCORE!NOPER!TTYRNU!INCOR!NOACT!NORUN!PLSXPN
	C GET,GET,RPGBITS
	C JCONTINUE,JCONT,NOLOGIN
	C D,DCOM,HVCORE!CMWRQ!INCOR!PLSXPN!NORUN!NOPER!NOACT
	C E,ECOM,HVCORE!CMWRQ!INCOR!PLSXPN!TTYRNU!NOTIC!NOACT
	C ADRBRK,SETABK,INCOR!MINCOR!HVCORE!NORUN
	C PJOB,PJOB,0
	C ASSIGN,ASSIGN,0
	C DEASSIGN,DEASSIG
	C DDT,DDTGO,HVCORE!NOPER!TTYRNU!INCOR!NORUN!PLSXPN
	C CSTART,STARTC,HVCORE!TTYRNC!INCOR!NOACT!NORUN!PLSXPN
	C CCONTINUE,CONTC,HVCORE!TTYRNC!INCOR!NORUN
	C ATTACH,ATTACH
	C WATCH,WATCH,0
	C DSK,DSKCOM
	C SCHEDULE,SKEDUL
	C REASSIGN,REASS,NOACT!INCOR!CMWRQ!NORUN!PLSXPN
	C VERSION,VERPR,HVCORE!CMWRQ!INCOR!PLSXPN!TTYRNU!NOTIC
	C GO,RUNCOM,RPGBITS
	CP LPGE2
	C TALK,SEND
	CP LP102
	CP LP942
	C SAVEBIN,SAVE,HVCORE!NOCRLF!NOPER!TTYRNU!INCOR!NOACT!NORUN!PLSXPN
	C SAVBIN,SAVE,HVCORE!NOCRLF!NOPER!TTYRNU!INCOR!NOACT!NORUN!PLSXPN
	CP LPSUD2
>


;GENERATE TABLE OF SIXBIT COMMAND NAMES

DEFINE C(A,B,D) <
	<SIXBIT /A/>
>

DEFINE CP(A)
<A==.-COMTAB>

COMTAB:	NAMES

DEFINE C(A)
<	<SIXBIT /A/>
>
;NAMES WHICH CALL PROGRAMS
	CP LP103
	CP LP943
	CP LPSUD3
	C HELLO
	CP LPSUD4
	CP LPGE3
	C GEXEC
	C XBASIC
	C AID
	C CT1
	C CT2
	C CT3
	C CT4
	C CT5
	C CT6
	C CT7
	C CT8
	C CT9
	C PASSWORD
	C PROJEC
	C SPOOL
	C MAGNUM
	C FTMAGN
	C XMAGNU
	C TBA
	C SFORTRAN
	C TAPE
	C DEFER
	C NEWS
	C SETE
	C OPER
	C NBASIC
	C CAL
	C CFORTRAN
	C PERFORM
	C GFD
	C APL
	C TERMIN
	C UNDELETE
	C PEAK
	CP LP104
	CP LP944
	CP LPGE4

;NAMES WHICH CALL RPG

	CP LP105
	CP LP945
	C TYMEX
	C XEXEC
	C MAIL
	C POSTMAN
	C SEND
	C PDP10
	C CTEST
	C DO
	CP LPGE5
	C COMPILE
	C CREATE
	C CDEBUG
	C CREF
	C DEBUG
	C TRY
	C CROSS
	C CRE
	C DIRECT
	C EDITOR
	C EXECUTE
	C LIST
	C LOAD
	C MAKE
	C RENAME
	C TE;			; make TE unambiguous with TERMIN
	C TECO
	C TYPE
	C PRINT
	C FILES
	C FDEBUG
	C HELP
	C FI
	C DIFFERENCES
	C FDC
	C PFDC
	C PPN
	C DECLARE
	C DELETE
	C COPY
	C MODIFY
	C VUE
	CP LP106
	CP LPGE6
	C DATE
	C 10EDIT
	CP LP946
	CP LPGE7
	C OPNOTICE
	CP LPGE8

;NAMES WHICH CALL SYSTAT

	CP LP947
	CP LP107
	CP LPGE9
	C WHO
	C SYSTAT
	C SYSNO
	C PSP
	C SYS
	C WHERE
	C USERS
	CP LP948
	CP LP108
	CP LPGE10
;(NOTE: "TVEDIT" WILL BE SUPPORTED SOMEDAY. /WRS 6/4/79) REMOVED/CAB 18-NOV-81
;(NOTE: "VUE" May one day be supported? someday! /CAB 18-Nov-81)


;GENERATE THE DISPATCH TABLE PLUS SPECIAL BITS

DEFINE C(A,B,D) <
Z	B	(D)
>
	DEFINE CP (A)
<>

DISP:	NAMES

MDSP:	MOVE P3,DISP(T1)
	MOVE P3,[XWD RPGBITS,PRGRUN]
	MOVE P3,[XWD RPGBITS,CCLRUN]
	MOVE P3,[XWD RPGBITS,SUDRUN]
	MOVE P3,[XWD RPGBITS,SYSRUN]
	JRST NCMD
	JRST NCMD
	JRST NCMD

NCMD:	MOVE	P3,[XWD NOLOGIN,NOCOM]	;get ready for command error message
	MOVE	T3,JBTPRV(J)
	TLNE	T3,PVSCMD		;but if in Special Command Mode...
	 MOVE	P3,[XWD RPGBITS,RESRUN]	;...then run Restricted Command Program
	JRST	COMFN1

PRGRUN:	MOVE T1,COMTAB(T3)	;GET THE PROGRAM NAME
	JRST ARCOM

	DEFINE PTR (A,B,C)
<BYTE (3) A (15) B (18) C>

PDP10P:	PTR 0,LP101-LP102,LP101
	PTR 1,LP103-LP104,LP103
	PTR 2,LP105-LP106,LP105
	PTR 4,LP107-LP108,LP107
P10SZ==.-PDP10P
	NCMD

TYMP:	PTR 0,LP941-LP942,LP941
	PTR 1,LP943-LP944,LP943
	PTR 2,LP945-LP946,LP945
	PTR 4,LP947-LP948,LP947
TYMSZ==.-TYMP
	NCMD

GENP:	PTR 0,LPGE1-LPGE2,LPGE1
	PTR 1,LPGE3-LPGE4,LPGE3
	PTR 2,LPGE5-LPGE6,LPGE5
	PTR 2,LPGE7-LPGE8,LPGE7
	PTR 4,LPGE9-LPGE10,LPGE9
GENSZ==.-GENP
	NCMD

SUDP:	PTR 0,LPSUD1-LPSUD2,LPSUD1
	PTR 1,LPSUD3-LPSUD4,LPSUD3
SUDSZ==.-SUDP
	NCMDS

RESP:	PTR 0,LPRES1-LPRES2,LPRES1
RESSZ==.-RESP
	NCMRES
NCMRES:	MOVE P3,[XWD RPGBITS,RESRUN]
	JRST COMFN1

NCMDS:	MOVE P3,[XWD RPGBITS,SUDRUN]
	JRST COMFN1

CMDMOD:	XWD -P10SZ,PDP10P
	XWD -TYMSZ,TYMP
	XWD -GENSZ,GENP
	XWD -SUDSZ,SUDP

CMDRES:	XWD -RESSZ,RESP


;COMMANDS WHICH ARE IN OTHER MODULES (IE NOT IN COMCON)
;BECAUSE THEY ARE DEPENDENT ON THESE MODULES(SCNSER,FILSER)

	EXTERN DSKCOM


COMMENT ! ENTRY COR0 - CLOCK LEVEL
FUNCTION: SET UP MONJOB TO KILL ALL USER CORE (IF NONE, RETURN
	RIGHT NOW).
EXPECTS: J/JOB  U/LDB OF TTY WHOSE COMMAND WE'RE PROCESSING
	F/ ADDR OF TTY DDB IF ANY
DESTROYS: MANY AC'S
NEW FEATURE: RESET EXO BIT WHEN CLEARING ALL CORE. AAA 5/77
!
	EXTERN TTYFNU,KILPGS,LMPNER,%UPLMA,INIARB

;HERE FROM CLEAR FRAME FRMOP
CLRFRM::MOVEI T2,ERRFCL		;INSTEAD OF ESTOP, GO TO PLACE THAT STORES STATUS AND INTERRUPTS PARENT
	JRST COR00
COR0:
	HLRZ T1,JBTUPM(J)	;EXISTENT PAGES
	JUMPE T1,CPOPJ
	JSP T2,MONJOB	;SET UP TO RUN MONITOR JOB
		;RETURN AT NEXT INSTR UUO LEVEL, NO ACS SETUP
	MOVEI T2,ESTOP	;JOB STOP ADDR
COR00:	JSP T1,MONSTR	;START MONITOR JOB BY SETTING UP ACS

; ROUTINE JOB1:  KILL ALL USER DEVICES AND CORE. USED
;	BY KJOB , PARITY ERROR CODE, AND COR0
JOB1::
	MOVSI T1,LMPNER	;SET "IGNORE PAGING ERRORS" IN CASE SWAP
	IORM T1,%UPLMA+0;ERR ON VP 0. WE WANT JOBDAT REFS
			;IN RESET TO COMPLETE. WE ARE GOING TO
			;THROW THIS PAGE 0 AWAY RIGHT AWAY ANYWAY,
			;WHICH RESETS LMPNER.
	PUSHJ P,RESET	;RELEASE DEVICES, MUCK W/JOBDATA AREA

	PUSHJ P,TTYFNU	;SET UP J/JOB, GET PROPER U/LDB,F/DDB,S/DEVIOS
	MOVEI T2,PVEXO
	ANDCAM T2,JBTPRV(J)	;SO NO "PROG IS RUN ONLY" AFTER "CORE 0"
	MOVEI T1,0	;KILL FROM PAGE 0,
	MOVEI T2,777	;TO PAGE 777
	PUSHJ P,KILPGS	;IN SEGCON
	HLLZS	%UPT+UPTREL	;MARK "NO LOW SEG"
	HLLZS	%UPT+UPTHRL	;AND "NO HI SEG"
	PUSHJ	P,INIARB	;SET ACCESS RIGHTS TO VIRGIN STATE.
	POPJ P,


; "PJOB" PRINT JOB NUMBER OF JOB TTY IS ATTACHED TO

INTERNAL PJOB,DECLF

PJOB:	MOVE T1,J		;JOB NO.
DECLF:	PUSHJ P,RADX10	;PRINT T1 AS DEC. THEN CRLF
	JRST CRLF

EXTERNAL TTYKIL,CPOPJ,CURUPT,EPT,DSKKJB,LGONAM,JBTFTR


; "KJOB" KILL ATTACHED JOB

KJB1:	MOVSI S,1	;SET UP FOR CALL AT SA+1
KJOB:
	TLNN	P4,JLOG	
	JRST	KJOB2		;IF JOB NOT LOGGED IN
	TLC	P3,TTYRNU+NOMESS ;Set TTYRNU and clear NOMESS for COMRET
	MOVSI 	W,PHONLY	;PHYSICAL DEVS ONLY
	MOVE	T1,LGONAM	;NAME OF CUSP
	SETZM	JBTLIM(J) ;MAKE SURE MONJOB CAN RUN
	JRST	ARCOM

COMMENT ! KJOB2 - HERE IF KJOB COMMAND FORCED ON LINE
	WHICH HAS NOT YET LOGGED IN (HAPPENS IF NOT ENOUGH
	ROOM TO RUN LOGINN). JUST CLEAN UP MONITOR DATA BASE.
!
KJOB2:
	JSP T2,MONJOB		;YES, SCHEDULE MONITOR JOB(PC IN EXEC MODE)
				; RETURN HERE AT M LEVEL WHEN SCHEDULED


COMMENT ! MONITOR JOB JOBKL
FUNCTION: DATABASE CLEANUP FOR LOGOUT UUO OR
	WHEN (SYS)LOGOUT.SHR IS NOT TO BE RUN.
EXPECTS: J/JOB
!
EXTERNAL NOPRNT,TKCHLD
JOBKL::	MOVEI T2,ESTOP		;PUT ESTOP ON END OF PDL
	JSP T1,MONSTR		;GO SETUP ACS AND PD LIST AT M LEVEL
				;RETURN HERE AT M LEVEL AFTER BEING SCHEDULED
	PUSHJ P,DSKKJB		;CLEAR UP CORE BLOCKS ON A KJOB COMMAND
				; MAY GO INTO WAIT, SO DO BEFORE GIVING
				; UP USER CORE
	HLRZ T1,JBTUPM(J)	;DOES HE HAVE ANY USER CORE?
	SKIPE	T1		;Skip if not
	PUSHJ P,JOB1		;DO RESET, KILL CORE AS WELL
	PUSHJ P,DEASTY		;DEASSIGN ALL BUT TTY
	PUSHJ P,NOPRNT		;ORPHAN ALL THE FRAMES CHILDREN
	PUSHJ P,TKCHLD		;TAKE THIS FRAME AWAY FROM ITS PARENT.
	PUSHJ P,KILUPT		;KILL UPT -- RETURN CORE & VM
	PUSHJ	P,TTYFND	;Set up F=DDB,U=LDB,S=DEVIOS(F)
	PUSHJ P,TTYKIL		;RETURN TTY TO VIRGIN STATE
;***Note*** TTYKIL must follow KILUPT, because job may be rescheduled
;***Note*** while killing UPT, leaving job with TTYTAB(J)=0, but with
;***Note*** JNA still set.
	JRST KSTOP		;CLEAR JOB STATUS WORD AND STOP JOB

;ROUTINE TO KILL THE CONTEXT PAGES FOR A JOB THAT
; IS LOGGING OFF. FIRST, CHECK TO MAKE SURE NO
; PAGES EXIST EXCEPT THE CONTEXT PAGES. NEXT, LOCK
; DOWN THE PHYSICAL CORE PAGES FOR THE CONTEXT PAGES
; IN CASE REMOVE HAS TO RESCHEDULE. THEN CALL REMOVE,
; WHICH WILL CHECK SPECIALLY FOR CONTEXT PAGES AND
; LEAVE THE MAP ENTRIES SO THAT WE CAN STILL ACCESS
; THE CONTEXT PAGE CORE. THEN UNLOCK THE CORE PAGES
; (DECREMENT THE USE COUNTS) AND CLEAR THE JBTCTX
; ENTRIES. ZERO JBTUPM, PUT JOB ON NULL QUEUE AND
; RETURN.

EXTERNAL KCLEAR,NCTXPG,%UPT.N,UXYPTM,LMMEXS,VPUMAX,GETLMA,CTXTAB
EXTERNAL GETCPA,INCUSE,DECUSE,UPSJOB
EXTERNAL WLKUPX,ULDUPX

KILUPT:	PUSHJ	P,WLKUPX	;LOCK UPX SO NO ONE WILL GET THEM WHILE THEY ARE GOING AWAY
	  STOPCD		;HAVE TO BE ABLE TO GET OUR OWN.
	HLRZ	T1,JBTUPM(J)	;GET NUMBER OF EXISTENT PAGES IN
				; USER SPACE.
	SKIPE	T1		;MUST BE NO MORE PAGES
	STOPCD			;THERE ARE, CRASH.
	MOVE	W,[-<VPUMAX-1000+1>,,340+CNVVPN] ;GET AOBJN POINTER
KILUP1:	PUSHJ	P,GETLMA	;GET LMAP SLOT CONTENTS
	TLNE	P3,LMMEXS	;MAKE SURE IT DOESN'T EXIST
	STOPCD
	AOBJN	W,KILUP1	;AND CHECK ANOTHER
	MOVEI	T1,SWPINP	;MAKE SURE SWAPPER DOESN'T TRY TO
	IORM	T1,JBTSTS(J)	;SWAP US OUT WHILE WE'RE IN STRANGE STATE.

	PUSHJ	P,LOKUPT	;MAKE SURE PAGES DON'T GO AWAY
	MOVE	T1,[NCTXPG,,%UPT.N+CNVVPN] ;ARG TO REMOV
	PUSHJ	P,KCLEAR	;REMOVE ALL CONTEXT PAGES.
	  STOPCD		;HAD TO BE ABLE TO DO IT.
	PUSHJ	P,ULKUPT	;DON'T RESCHEDULE AFTER THIS.
	SETZM	JBTUPM(J)	;NO LONGER ANY UPT.
	CAMN	J,UPSJOB	;IF WE WERE IN %UPS
	SETZM	UPSJOB		;WE ARE NO LONGER.
	MOVEI	T1,SWPINP	;OK TO TURN THIS OFF NOW.
	ANDCAM	T1,JBTSTS(J)
	PUSHJ	P,ULDUPX	;RELEASE WRITE LOCK AND LOCKDOWN.
	PJRST	NOCORQ		;PUT JOB INTO NULL QUEUE AND RETURN.

;ROUTINE TO INCREMENT AND DECREMENT USE COUNTS FOR
; CONTEXT PAGES SO THAT THEY DON'T GO AWAY WHILE
; THEY ARE BEING REMOVED.

ULKUPT:	SKIPA	P1,[[SETZM @CTXTAB(W) ;CLEAR JBTCTX ENTRY
		     PJRST DECUSE]]	;DECREMENT USE COUNT AND RETURN.
LOKUPT:	MOVEI	P1,INCUSE	;JUST INCREMENT USE COUNT.
LKUUPT:	MOVSI	W,-NCTXPG	;AOBJN POINTER
	MOVE	P2,UXYPTM	;TO GET CP NUMBERS [UPXPTR(%UPT.N-1,%UPT)]
LKUUP1:	ILDB	PG,P2		;GET UPT MAP SLOT CONTENTS
	ANDI	PG,17777	;JUST THE CORE PAGE NUMBER.
	PUSHJ	P,(P1)		;INCREMENT OR DECREMENT
	AOBJN	W,LKUUP1	;AND LOOP
	POPJ	P,		;DONE.


; "START L" OR "START" - START AT LOC. L OR STARTING ADDRESS
EXTERNAL JOBSA,JOBSDD,JOBS41,JOBREN,USYPSR

XP STARDI,(1B0)		;(MUST BE SIGN) IF ON, MEANS ADDRESS WAS SPECIFIED DIRECTLY
			; RATHER THAN REFERRING TO LOCATION IN JOBDAT
XP STARCL,(1B1)		;IF ON (STARDI MUST BE OFF) USE C(LOC)+1 AS ADDRESS
START:				;SAME AS CSTART, DIFF BY COMTAB BITS
			; WHICH PUT TTY IN MONITOR OR USER MODE

; "CSTART L" OR  "CSTART" - START AT LOC. L(TTY IN COMMAND MODE)

STARTC:	PUSHJ	P,OCTIN1	;CONVERT POSSIBLE OCTAL NO ARG.
	JRST	SNOARG		;NO ARG SPECIFIED RETURN
	JRST	COMERA		;ILLEGAL CHARACTER
				;T2/USER TYPED OCTAL START LOC
	PUSHJ P,PROPRG
	HRLS T1,JBTLIC(J)
	HRLM T1,JBTSLC(J)
	TLZ	T2,-1		;CLEAR JUNK
	TLOA T2,400000		;SET ADDRESS TYPED FLAG
SNOARG:	MOVEI T2,JOBSA		;USE JOBSA IF NO ADDRESS TYPED
	MOVEI P4,4		;WRITE ACCOUNTING RECORD TYPE 4
SNOAR1:	;ENTER HERE ALSO FROM REENTER, DDT CMDS NEXT PG.
	;T2/ USER ADDR; P4/ STREAM RECORD TYPE TO WRITE
	PUSHJ P,MAPUPS		;SET UP %UPS. CLOB T1,T3,T4 ONLY
	TLNN T2,400000		;WAS ADDRESS TYPED IN?
	JRST SNOAR2		;NO, NO NEED TO CLEAR PID
	SETZM %UPS+UPTPID	;CLEAR OUT PID AND SAVED PID
	SETZM %UPS+UPTSPD
SNOAR2:	MOVE T1,%UPS+UPTPC	;GET OLD PC
	TLNN T1,PC.USR		;USER MODE?
	JRST STARC1		;NO.
STARC2:	MOVEM T2,%UPS+UPTXAC+T3	;YES. SAVE ARGUMENT ADDRESS
	MOVEM T1,%UPS+UPTXAC+T4	;AND PC
	MOVEM P4,%UPS+UPTXAC+P4	;SAVE ACCOUNTING CODE
	JSP T2,MONJOB

;HERE FOR A FRAME THAT HAS HAD A MONITOR JOB STARTED FOR IT BY
; THE START FRAME UUOS. T3,T4, AND P4 SETUP AS PER ABOVE.

STARTX::SETZ F,		;IN CASE OF ILL MEM REF, DON'T PRINT ADDRESS CHECK.
	MOVE T2,%UPT+UPTPDL	;SAME STARTING ADDRESS
	JSP T1,MONSTR		;SET UP AT START OF MONITOR JOB
	SKIPGE	T2,T3		;ADDRESS OR INDIRECT?
	JRST	STARX1		;DIRECT
	XCTBU <HRRZ T2,(T3)>	;INDIRECT. GET ADDRESS
	TLNE	T3,STARCL	;WANTS CCL START ADDRESS?
	AOS	T2		;YES, THIS IS THE CCL ADDRESS.
STARX1:	TLZ T2,STARDI!STARCL	;CLEAR SO CAN CHECK FOR 0
	MOVE T1,T4
	JUMPE T2,ERRNSA		;DON'T ALLOW 0 START ADDRESS
	PUSH P,T2
	PUSH P,T1
	MOVE T1,P4	;RECORD TYPE TO WRITE
	PUSHJ P,ACTWRT	;DO IT, CLOB T1-T4
	POP P,T1
	POP P,T2
	JRST USTART




STARC1:	;CH7 LEVEL. HERE WHEN JOB WAS STOPPED IN MONITOR.
	;T2/START ADDR, P4/STREAM REC TYPE.  IF HE
	;STOPPED OUTOF SLEEP/TIOW STATE OR HAD JERR, START
	;HIM UP NOW AT HIS START/REEN/DDT ADDRESS. ELSE
	;SET UTRP (START/REEN/DDT PENDING FLAG),STORE
	;THE STREAM TYPE TO WRITE & LET WHATEVER
	;MONITOR ROUTINE WAS RUNNING FINISH UP. AT USRXIT
	;THE START ETC WILL REALLY BE DONE.
	MOVE P1,JBTSTS(J)	;STOPED INEXEC. GET STATUS
	TDNE P1,[XWD JERR,JDCON];ERROR?
	JRST STARC2		;YES. START AT USER
	LDB P1,PJBSTS	;GET WAIT STATE
	CAIE P1,TIOWQ
	CAIN P1,SLPQ
	JRST STARC2		;START AT USER IF TIOW OR SLEEPING
	HRRM T2,%UPS+UPTSTS	;OTHERWISE SET UP TRAP FOR USRXIT
	MOVE P1,%UPS+UPTSTS	;ADDRESS FOR USER START
	TLO P1,STRTAD	;SET ADDRESS FLAG
	SKIPL	T2		;REALLY AN ADRESS?
	TLZ P1,STRTAD		;NO. FLAG INDIRECT
	MOVEM P1,%UPS+UPTSTS
	TLZ P1,STRTCL		;NO CCL START ADDRESS, ALREADY ADJUSTED.
	MOVEI T1,UTRP		;SET UP TRAP
	ORM T1,JBTSTS(J)
	DPB P4,USYPSR		;SAVE
		;TYPE OF RECORD TO WRITE IN UPTSTS IN %UPS
	POPJ P,		;RTN TO CMD PROCESSING. JOB RUNNABLE,
		;WILL CONTINUE IN EXEC.


;"REENTER" - REENTER USER PROGRAM

EXTERNAL TIOWQ,SLPQ,ERRNSA
REENTE:	MOVEI T2,JOBREN		;ADDRESS OF REENTER ADDRESS
	MOVEI P4,5		;ACCOUNTING RECORD TYPE 5
	JRST SNOAR1


; "DDT" - START EXECUTION AT DDT IN USER AREA

	EXTERN	JOBDDT,JOBSV
DDTGO:	MOVEI T2,JOBDDT		;ADDRESS OF START OF DDT
	MOVEI P4,6		;ACCOUNTING RECORD TYPE 6
	JRST SNOAR1
; "PCOM"/"DCOM" - both run SYS:PCOM

PCOM:	MOVE	T1,[SIXBIT /PCOM/]
	JRST	ARCOM

; "HALT" OR "<CONTROL>C"
;SCANNER ROUTINES DUMMY UP HALT WHEN CONTROL C TYPED IN
;STOP MUST BE DELAYED IF THIS JOB IS SYSTEM TAPE USER
;AND SYSTEM TAPE IS ACTIVE. OTHERWISE, THE JOB WILL NOT BE
;STOPPED WHEN DONE USING THE SYSTEM TAPE.
;IF JOB IS IN MONITOR MODE AND NOT IN TTY WAIT THIS JOB CANNOT BE STOPPED YET
;IN THIS CASE SET A BIT IN JOB STATUS WORD (CNTRLC) WHICH WILL BE CHECKED
;WHEN JOB RETURNS TO USER MODE

EXTERNAL JOB,PJBSTS

STOP:
	MOVEI T1,JDCON	;CLEARE JCONT ABLE
	ANDCAM T1,JBTSTS(J)	;SO ONCE A MINUTE STOPS

	LDB T1,PJBSTS		;GET JOB STATUS CODE
	MOVEI T2,1		;BIT POS. IN DELAYN FOR STATE CODE 0
	LSH T2,(T1)		;MOVE LEFT ACCORDING TO STATE CODE
	SKIPL T1,JBTSTS(J)	;JOB STATUS. IS RUN BIT OFF?
	JRST STOPAA		;YES, STOP JOB BUT DO NOT PRINT WATCH STATUS
	TLNE T1,JERR		;NO, IS ERROR BIT ON?
	JRST STOPA		;YES. STOP JOB EVEN IF IN EXEC MODE
	TLNE T1,JACCT
	JRST DLYCM1	;DO NOT TRY TO STOP IF JACCT
	TRNN T1,SWPINP		;SWAP IN PROGRESS?
	SKIPL	JBTCTX(J)	;CONTEXT PAGES IN CORE?
	JRST	STOPC		;NO. ASSUME PC IN EXEC MODE
	PUSHJ	P,MAPUPS
	MOVE T1,%UPS+UPTPC	; GET PC AND FLAGS FOR CURRENT JOB
	TLNN T1,PC.USR		;JOB PC IN USER MODE?
STOPC:	TDNN T2,DELAYN	;NO, IS JOB IN A STATE(IN EXEC) WHICH
				; CAN BE STOPPED IMMEDIATELY
	JRST STOPA		;YES, STOP JOB
	MOVSI T1,CNTRLC	;NO, FLAG THAT USER MUST BE STOPPED WHEN
	IORB T1,JBTSTS(J)	; RETURNING TO USER MODE IN M HANDLER
	TLNN T1,CMWB		;IS JOB IN COMMAND WAIT?
	JRST DLYCM1		;NO. JUST DELAY COMMAND
	MOVSI T1,CMWB		;CLEAR COMMAND WAIT BIT
	ANDCAM T1,JBTSTS(J)	;SO REQUE WILL CHANGE JOB QUEUE
	CAME J,JOB		;NEVER REQUEUE CURRENT JOB
	PUSHJ P,REQUE		;YES. PUT HIM BACK IN RUNNABLE QUEUE
	JRST DLYCM1		;THEN DELAY COMMAND (IE ECHO CR-LF, DOT)
				;UNTIL SWAPPED IN


STOPA:	PUSHJ P,WCHEND	;PRINT [XXXX] CRLF IF USER IS WATCHING RESPONSES
	PUSHJ P,TRHALT		;STOP JOB
STOPAA:	SKIPGE	JBTPRV(J)	;check for LogoutOnStop (PV.LOS)
	 JRST	TTKJOB		; if set, kill frame
	MOVE T1,JBTSTS(J)	;GET JOB STATUS
	TLNE T1,JLOG		;IS JOB LOGGED IN?
	  POPJ	P,		;If not, don't force kill
;	fall in to TTKJOB

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; General entry point for forcing "must kill"
; J/ job #
; T1 mutilated
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TTKJOB::MOVSI	T1,CMDCK2	;"Must kill" (never detach) flag
	IORM	T1,TTYTAB(J)	;Set into command port table
	JRST	COMKJB		;Set command waiting stuff, etc.

;DEFINE A BIT FOR EACH STATE CODE
; WHICH IS 1(DJ) MEANS DELAY JOB(IF PC IN EXEC MODE) WHEN CONTROL C TYPED
; IF 0(SJ), OK TO STOP JOB(IN EXEC MODE)

DEFINE X(A,B,C)
<	IFIDN <C><DJ>,<QQ==1>
	IFIDN <C><SJ>,<QQ==0>
	YY==ZZ*QQ	;;SET THIS STATE CODE BIT TO 0 OR 1
	XX==XX!YY	;;ACCUMULATE VALUES IN XX
	ZZ==ZZ*2	;;MOVE MASK BIT LEFT ONE PLACE
>

QQ==0	;MAKE SURE INTERMEDIATE VALUE IS 0
XX==0	;START FINAL VALUE AT 0
ZZ==1	;START OFF BIT FOR STATE 0

	QUEUES
	CODES

	INTERN DELAYN

DELAYN:	EXP XX		;GENERATE THE DELAY WORD BIT 35=STATE 0,
			; BIT 34=STATE 1, ETC.
			; BIT 35-I=1 IF STATE I MUST BE DELAYED ON CONTROL C


;MONITOR COMMAND LEVEL RESPONSE ROUTINES
;FIVE MULTIPLE ENTRY SUBROUTINES TO PRINT SYSTEM RESPONSE DATA FOR A JOB
;CONTROL REACHES ONE OF THESE ROUTINES ON ANY OF THE FOLLOWING:
;1. USER TYPES CONTROL C
;2. PROGRAM HALTS
;3. PROGRAM CALLS EXIT, OR CALL N,EXIT
;4. DEVICE BECOMES UNREADY  DEVICE XXX OK?
;5. ERROR IN JOB MESSAGE

;PRRSP1 - PRINT CRLF CRLF
;PRRSP3 - PRINT [XXXX] CRLF IF USER WATCHING SYSTEM DATA RESPONSE
;PRRSP4 - PRINT CRLF
;PRRSP5 - PRINT PERIOD

	INTERN PRRSP1,PRRSP3,PRRSP4,PRRSP5

PRRSP1:	PUSHJ P,CRLF		;PRINT CR-LF
PRRSP3:
	PUSHJ P,WCHEND	;PRINT SYSTEM RESPONSE DATA IF USER IS WATCHING IT.
PRRSP4:	PUSHJ P,CRLF		;PRINT CR-LF
PRRSP5:	PJRST PRPER		;PRINT PERIOD


;COMMAND TO WATCH RESPONSE DATA
;TYPE:	WATCH DAY,RUN,WAIT,READ,WRITE
;TYPE	WATCH <CRLF> TO TURN OFF ALL

	INTERN WATCH

WATCH:	MOVSI T1,WCHALL	;CLEAR ALL WATCH DATA OPTIONS
	ANDCAM T1,JBTWCH(J)	;FOR THIS JOB
;LOOP - GET NEXT ARGUMENT AND LOOK FOR TABLE MATCH
WATLOP:	PUSHJ P,CTEXT		;GET NEXT USER ARGUMENT
	JUMPE T2,CPOPJ	;0 IF FINISHED (OR NONE)
	MOVSI T1,-WATLEN	;NO. OF ARGUMENTS
	CAME T2,WATTAB(T1)	;MATCH?
	AOBJN T1,.-1		;NO. KEEP LOOKING
	JUMPL T1,WATCH1	;FOUND ONE?
	JSP T1,ERRMES		;NO, TELL USER THE LEGAL ONES
	ASCIZ /?args are: DAY,RUN,WAIT,READ,WRITE
/
WATCH1:	MOVNI T1,(T1)		;-NO. OF ENTRY IN TABLE
	MOVSI T2,JBPWDY	;FIRST BIT
	ROT T2,(T1)		;ROTATE RIGHT TO PROPER POSITION
	IORM T2,JBTWCH(J)	;SET BIT TO INDICATE USER WISHES TO
				; WATCH THIS DATUM
	JRST WATLOP		;GO GET NEXT ARG

WATTAB:	SIXBIT /DAY/
	SIXBIT /RUN/
	SIXBIT /WAIT/
	SIXBIT /READ/
	SIXBIT /WRITE/
;ADD NEW ITEMS HERE AND IN ERROR COMMENT
WATLEN==.-WATTAB


;SUBROUTINE TO PRINT TIME OF DAY USER STARTS TO WAIT FOR RESPONSE
; IF HE HAS ENABLED IT WITH "WATCH DAY"
;CALL:	MOVE J,JOB NO.
;	PUSHJ P,WCHBEG
;	ALWAYS RETURN HERE

;THIS SUBROUTINE IS ALWAYS CALLED FROM THE COMMAND DECODER
;WHEN USER IS ABOUT TO WAIT FOR A RESPONSE

	EXTERN JBYWCH,GETUDT
	EXTERN	TIME,JBTWCH

WCHBEG:	MOVE T1,TIME		;TIME OF DAY IN JIFFIES
	DPB T1,JBYWCH		;STORE FOR JOB
	MOVSI T1,JBPWDY	;DOES USER WANT TO SEE THIS TIME PRINTED?
	TDNN T1,JBTWCH(J)	; ..
	POPJ P,		;NO.
	PUSHJ P,PRLBK		;YES, PRINT LEFT BRACKET
	PUSHJ P,GETUDT		;GET TIME OF DAY AND DATE
	 MOVEI T1,0		;BAD DATE
	PUSHJ P,PRTIME		;PRINT HH:MM:SS(NO CRLF)
				;FALL INTO PRRBKC
;SUBROUTINE TO PRINT RIGHT BRACKET,CRLF

PRRBKC:	PJSP T1,CONMES
	ASCIZ /]
/
;SUBROUTINE TO PRINT LEFT BRACKET

PRLBK:	PJSP T1,CONMES
	ASCIZ /[/


;SUBROUTINE TO PRINT SYSTEM RESPONSE STATISTICS EACH TIME
;USER FINISHES WAITING FOR SYSTEM
;PRINT INCREMENTAL RUN TIME, WAIT TIME, # DISK BLKS READ, #DISK BLKS WRITTEN
;CALL:	MOVE J,JOB NUMBER
;	PUSHJ P,WCHEND
;	ALWAYS RETURN HERE


WCHEND:	MOVSI T1,JBPWRN!JBPWWT!JBPWDR!JBPWDW	;USER WANT ANY RESPONSE DATA?
	TDNN T1,JBTWCH(J)	; ..
	POPJ P,		;NO.
	PUSH	P,P3		;Make a work AC
	PUSHJ P,PRLBK		;YES, PRINT LEFT BRACKET
	MOVSI P3,-WCHLEN	;LOOP THRU ALL RESPONSE DATA ITEMS
WCHLOP:	HLLZ T1,WCHTAB(P3)	;GET BIT ASSOCIATED WITH THIS FIELD
	TDZE T1,JBTWCH(J)	;DOES USER WANT TO WATCH IT?
	PUSHJ P,@WCHTAB(P3)	;YES, PRINT IT OUT
	AOBJP P3,WCH1		;FINISHED ALL FIELDS?
	PUSHJ P,PRSPC		;NO, PRINT A SPACE
WCH1:	JUMPL P3,WCHLOP		;LOOP IF MORE BITS TO CONSIDER
	PUSHJ	P,PRRBKC	;Append right bracket, CRLF
	POP	P,P3		;Restore work AC
	POPJ	P,		;Return

;TABLE OF ROUTINES TO PRINT RESPONSE DATA

WCHTAB:
	XWD JBPWRN,PRTWRN	;PRINT RUN TIME
	XWD JBPWWT,PRTWWT	;PRINT WAIT TIME
EXTERN PRTWDR,PRTWDW
	XWD JBPWDR,PRTWDR	;PRINT # DISK BLOCKS READ
	XWD JBPWDW,PRTWDW	;PRINT # DISK BLOCKS WRITTEN
				;ADD NEW DATA HERE
WCHLEN==.-WCHTAB


;ROUTINE TO PRINT INCREMENTAL RUNTIME(NO CRLF)
;CALL:	MOVEI T1,0
;	PUSHJ P,PRTWRN


PRTWRN:	PUSHJ P,TIMADJ		;MAKE SURE COUNTS ARE UP TO DATE
	PUSHJ P,CLKTRU		;FIND TRU'S
	EXCH T1,RTIME(J)
	SUB T1,RTIME(J)
	MOVNS T1
	PJRST PRTDC1		;PRINT AS #.##

;ROUTINE TO PRINT WAIT TIME (NO CRLF)
;CALL:	PUSHJ P,PRTWWT

	EXTERN MIDNIT,TIMADJ,CLKTRU

PRTWWT:	LDB T1,JBYWCH		;TIME OF DAY USER STARTED TO WAIT
	SUB T1,TIME		;-CURRENT TIME OF DAY = -WAIT TIME
	SKIPL T1		;IS IT REALLY MINUS?
	SUB T1,MIDNIT		;NO. MUST HAVE BEEN WAITING ACROSS MIDNIGHT
				; SO SUBTRACT A DAY TO GET IT NEGATIVE
	MOVNS T1		;NOW MAKE IT PLUS WAIT TIME
	PJRST PRTIM		;TYPE OUT TIME (NO CRLF)
; "CONTC" - CONTINUE EXECUTION(TTY REMAINS IN COMMAND MODE)

CONTC:				;SAME AS CONT

; "CONT" - CONTINUE EXECUTION FROM WHERE LEFT OFF

CONT:
	TLNN P4,JERR		;IS JOB ERROR BIT SET?
	POPJ P,		;COMMAND DECODER WILL DO REST
	JSP T1,ERRMES		;YES, PRINT CANT CONTINUE

	ASCIZ /?can't continue
/

FCONT:	PUSHJ P,CKFCN		;SEE IF FCONT OK FOR THIS JOB
	POPJ P,			;NO
	TLZ	P3,NOCRLF!NOMESS ;Yes, set up for message
	TLO	P3,TTYRNW	;And to start him
	PUSHJ P,INLMES
	ASCIZ /[continued by operator]/
	POPJ P,

CKFCN:	MOVE P4,JBTSTS(J)
	TLNN P4,JERR
	TRNN P4,JDCON		;FCONT ABLE IF NOT ERR AND JDCON
	POPJ P,
	JRST CPOPJ1		;YES, OK

FCONRQ:	PUSH P,U
	PUSH P,J
	MOVE J,T1		;THE JOB TO DO IT FOR
	PUSHJ P,CKFCN
	 JRST FCNCNT		;CAN NOT DO IT, IGNORE
	PUSHJ P,TTYFND		;GET USERS TTY
	JUMPE U,FCNNOW		;DETACHED, GO NOW
	MOVSI T1,CMDCMF
	TDNE T1,TTYTAB(J)
	JRST FCNSKP		;ALREADY HAS COMMAND WAITING
	MOVEI T1,CMFCXJ
	PUSHJ P,COMWCM		;FORCE FCONT COMMAND
FCNCNT:	POP P,J
	POP P,U
	POPJ P,

FCNNOW:	PUSHJ P,SETRUN		;JUST SET HIM TO RUN
	MOVEI T1,JDCON
	ANDCAM T1,JBTSTS(J)	;CLEAR JCONT BIT
	JRST FCNCNT

FCNSKP:	AOS -2(P)
	JRST FCNCNT


JCONT:	MOVEI T2,LICOPR
	TDNN T2,JBTLIC(J)	;ONLY AN OPR
	JRST COMERA
	PUSHJ P,DECIN1
	 JRST NOTENF
	 JRST COMERA
	CAIE T2,0
	CAIL T2,JOBN
	JRST ATT1		;ILL JOB NO
	MOVE T3,JBTSTS(T2)
	TLNN T3,JNA
	JRST ATT4		;NOT IN
	EXCH J,T2	;SET UP FOR TEST
	PUSHJ P,CKFCN
	 JRST JCER2		;ERROR
	CAMN T2,J		;FOR US?
	JRST FCONT		;GO
	MOVE T1,J		;SET UP TO START
	MOVE J,T2	;RESTORE OUR JOB NUMBER
	PUSHJ P,FCONRQ
	 POPJ P,	;ALL OK
	JRST SNDBSI		;BUSY

JCER2:	MOVE J,T2	;RESTORE JOB NUMBER
	JSP T1,ERRMES
	ASCIZ /?job not waiting/


COMMENT ! "CORE" COMMAND.
"CORE ### OR ###K" - ASSIGN ###*1024 WORDS CORE TO JOB
"CORE ###P" - ASSIGN ###*512 WORDS CORE TO JOB"
" CORE CR" - PRINT CURRENT PAGES ASSIGNED & MAX ALLOWED
!

CORE:	PUSHJ P,DECIN1	;GET T2/NUMBER, T3/TERMINAL CHAR
	JRST COR3		;NO ARG. SPECIFIED
	JRST COMERA		;ILLEGAL DECIMAL CHARACTER 
	JUMPE T2,COR0		;USER SAID "CORE 0". GET RID
		;OF EVERYTHING EXCEPT HIS CONTEXT PAGES.

	PUSHJ P,PROPRG		;CHECK EX ONLY. CLOB T1
	HRLS T1,JBTLIC(J)
	HRLM T1,JBTSLC(J)
	MOVEI T4,^D9
	CAIN T3,"P"		;SHIFT BY ^D9 IF HE SAID ##P
	JRST COR1
	CAIE T3,"K"		;IF HE SAID ##K
	CAIG T3," "		;OR JUST ##
	SKIPA T4,[^D10]		;SHIFT BY 10 TO MAKE WORDS
	JRST COMERA		;SAID SOME OTHER CHAR
COR1:	LSH T2,(T4)		;CONVERT TO WORDS
	SUBI T2,1		;HIGHEST ADDRESS
	PUSH P,T2		;PROTECT FROM MAPUPS
	PUSHJ P,MAPUPS		;GET HIS UPT IN %UPS
	SETZM	%UPS+UPTPID	;CLEAR OUT PID AND SAVED PID, HE'S MEDDLING
	SETZM	%UPS+UPTSPD
	POP P,T2
	HRRZ T1,%UPS+UPTHRL	;LAST ADDR IN HISEG OR 0 IF NONE
	JUMPE T1,COR5		;NO HISEG,T2/SIZE OK ALREADY
	SUBI T2,377777(T1)	;LOWSEG SIZE:=ARG-SIZE HISEG
	JUMPGE T2,COR5
	PUSHJ P,INLMES		;TOO SMALL ARG
	ASCIZ /?try larger argument
/
	JRST COR2

COR5:	;ENTER HERE T2/HI ADDR DESIRED. SET UP
	;MONJOB AND DO CORE UUO WHEN RUN.

	MOVEM T2,%UPS+UPTXAC+T3	;SAVE CORE ADDR REQ IN T3
	TLO	P3,NOPER!NOCRLF	;PHOLD will print period
	JSP T2,MONJOB
	JSP T1,MONSTR
	PUSHJ P,TTYFUW	;SET UP TO PRINT
	CALLI T3,11		;CORE T3,
	PUSHJ P,COR3	;PRINT MSG FOR INSUFFICIENT CORE
	JRST HOLD


COR2:	;COME HERE TO PRINT HIS SIZE WHEN HE GIVES A CORE
	;ARG WHICH WOULD REQUIRE DELETING HIS HISEG, OR
	;FROM LOGIN CODE WHEN NOT ENOUGH CORE TO RUN LOGINN.

	MOVE U,-1(P)		;RESTORE TTY LDB ADDR
	PUSHJ P,COR3
	TLO	P3,ERRFLG	;INDICATE AN ERROR CONDITION
	POPJ P,


; COR3: THIS CODE RUNS EITHER AT UUO OR CLOCK LEVEL. IT PUTS
; THE CONTEXT PAGES FOR THE JOB IN J INTO %UPS.
;EXPECTS J/JOB

COR3:	;PRINT "EE: NN+MM/ZZZ PAGES" ETC.
	PUSHJ P,MAPUPS	;EXPECTS J/JOB TO MAP
	HLRZ T1,JBTUPM(J)	;EXISTENT PGS BTW 0,777
	PUSHJ P,RADX10
	PUSHJ P,INLMES
	ASCIZ /:/
	HRRZ T1,%UPS+UPTREL
	ADDI T1,777
	LSH T1,-9	;PGS IN LOSEG=[HI ADDR+777] LSH -9
	PUSHJ P,RADX10
	PUSHJ P,INLMES
	ASCIZ /+/
	HRRZ T1,%UPS+UPTHRL
	SKIPE T1
	SUBI T1,400000-777
	LSH T1,-9
	PUSHJ P,RADX10
	PUSHJ P,INLMES
	ASCIZ "/"
	LDB T1,PVYCOR		;GET CORE PERMITTED THIS USER
	LSH T1,2			;CONVERT TO PAGES
	ADDI T1,4		;AM'T == ((PVYCOR+1)*4)+1
				;ALLOWING FOR THE UPT
	PUSHJ P,RADX10	;PRINT NO. OF PAGES AVAILABLE
	PUSHJ P,INLMES
	ASCIZ / pages
VIR. CORE LEFT=/
	MOVE T1,STRTAL+STRDDB	;AMOUNT OF FREE DSK PAGES
	JUMPGE T1,DECLF		;IF POSITIVE, JUST PRINT IT
	PUSHJ P,INLMES
	ASCIZ /-/		;NEGATIVE
	MOVM T1,STRTAL+STRDDB	;GET MAGNITUDE OF INDEBTEDNESS
	PJRST DECLF		;PRINT DECIMAL AND CRLF
	PJRST DECLF		;PRINT DECIMAL AND CRLF

	EXTERNAL PVYCOR,JBYUWS,USYUWL,USYUWM



COMMENT ! VMINFO - COMMAND TO PRINT WORKING-SET INFO
!

VMINFO::
	PUSHJ P,MAPUPS	;EXPECTS J. GET %UPS ETC SET UP
	PUSHJ P,INLMES
	ASCIZ /WS,EXS: /
	LDB T1,JBYUWS
	PUSHJ P,RADX10
	PUSHJ P,INLMES
	ASCIZ /,/
	HLRZ T1,JBTUPM(J)
	PUSHJ P,RADX10	;CURRENT SIZE
	PUSHJ P,INLMES
	ASCIZ /  LIM,MAX: /
	LDB T1,USYUWL	;LIMIT
	PUSHJ P,RADX10
	PUSHJ P,INLMES
	ASCIZ /,/
	LDB T1,USYUWM	;MAX ALLOWED FOR LIMIT
	PUSHJ P,RADX10
	POPJ P,


; "SAVE FILE-NAME[PROJ.,PROG.] CORE" - SAVES JOB AREA ON RETRIEVABLE DEVICE
;ONLY A SAVE OR A GET IN PROGRESS FOR EACH JOB
;NO ATTEMPT IS MADE TO SAVE DEVICE ASSIGNMENTS, AC'S, OR PC

; "SSAVE FILNAM.EXT [PROJ,R] CORE"
;WORKS LIKE SAVE, EXCEPT THAT HIGH SEG IS SAVED AS SHARABLE(EXT=SHR)
;INSTEAD OF NON-SHARABLE(EXT=HGH)

SAVE:	TLO 	S,NSRBIT	;SET FLAG FOR NON-SHARABLE EXT(HGH)
SSAVE:	HRRI 	S,SAVJOB	;SETUP TO RUN SAVJOB (S CLEARED BEFORE)
	PUSHJ 	P,PROPRG	;CHECK EX ONLY
	SETZM 	JBTNAM(J)	;CLEAR JOB'S PROGRAM NAME FOR RCOM
	JRST 	SGSETD		; assume DSK:

; "GET DEVICE:FILE-NAME[PROJ.,PROG.] CORE" - SETS UP JOB AREA FROM RETREIVABLE
;DEVICE AND ASSIGNS CORE.

GET:	MOVEI 	S,GETJOB	;SETUP TO RUN GETJOB
	SETZM	JBTNAM(J)	; CLEAR NAME FOR RCOM
	JRST	SGSETD		; assume DSK:

;AUTOMATIC LOGIN AFTER DSK REFRESH OR WHEN REFLAG SET

EXTERN	REFLAG

LOGREF:	MOVEM	T1,JBTPPN(J)	;PRJ,PRG NRS. IN REFLAG
	SETCMI 	T1,LICUNU
	HRRZM 	T1,JBTLIC(J)
	MOVE 	T1,[177,,177]
	MOVEM 	T1,JBTPRV(J)	;SET CORE ALLOWED TO INFINITE
	MOVSI	T1,JLOG
	IORM	T1,JBTSTS(J)
	SETZ	P3,		;Clear all flags for COMRET
	SETZM	REFLAG		;ONLY ONCE
	PUSHJ 	P,INLMES
	ASCIZ 	/Remember to set date,time/
	POPJ	P,

PROPRG:	MOVEI 	T1,PVEXO
	TDNN 	T1,JBTPRV(J)
	POPJ 	P,
	PUSHJ 	P,INLMES
	ASCIZ 	/?program is run only/
	PUSHJ 	P,CRLF
	JRST 	COMERP
;"HELP" -HELP COMMAND

EXTERNAL HELPPP
HELP1:
	MOVE 	T1,HELPPP
	TLNN 	P4,JLOG
	 JRST	ALOGIN
	POPJ	P,

;SYSTEM JOB STARTUP COMMAND

INITIA:	PUSHJ 	P,HELP1		;CREATE JOB'S PPN IF NEEDED
	MOVE 	T1,[SIXBIT /INITIA/]	;CUSP NAME
	JRST 	ARCOM		;RUN IT

IFKMC<
;KMC LOAD PROGRAM STARTUP

KMCLOD: PUSHJ	P,HELP1		;CREATE JOB'S PPN IF NEEDED
	MOVE	T1,[SIXBIT /KMCLOD/]	;CUSP NAME
	JRST	ARCOM
>;END IFKMC

ALOGIN:
EXTERN	JBTPPN
	SKIPN	JBTPPN(J)	;If PPN already set, don't change it
	MOVEM 	T1,JBTPPN(J)
	MOVE 	P4,[JLOG,,SCHPRV]	
	ANDCAB 	P4,JBTSTS(J)	;CLEAR THESE SO COMRET DOES GOOD THINGS
	POPJ 	P,




SYSRUN:	MOVE T1,[SIXBIT /SYSTAT/]
	JRST ARCOM

SUDRUN:	SKIPA T1,[SIXBIT /SUDS/]
CCLRUN:	MOVE	T1,[SIXBIT /RPG/]	;CUSP NAME
	JRST	ARCOM	;RUN IT

;"LOGIN" - LOGIN COMMAND

LOGDET:	JSP	T1,ERRMES
	ASCIZ	/?please KJOB or DETACH
/
CLOGIN:	TLNE	P4,JLOG		;FORCE USER TO LOGOUT BEFORE
	JRST	LOGDET		; LOGGING IN ANEW.
	SKIPE	T1,REFLAG	;REFLAG SET NON-ZERO FOR AUTOMATIC LOGIN?
	JRST	LOGREF		;YES, LOG USER IN WITHOUT RUNNING CUSP
				; SO HE CAN RELOAD THE DISK AFTER REFRESH
	MOVE T1,HELPPP		;SET JBTPPN TO HELPPP
	PUSHJ P,ALOGIN		;AUTOMATIC LOGIN
	MOVE	T1,PRVLOG	;CUSP NAME
	JRST	ARCOM		;RUN IT
				;HOPEFULLY THERE WILL BE ENOUGH
				;ROOM TO DO THE RUN (SYS)LOGINN,
				;BUT IF NOT, SEGCON WILL JSP PHOLD
			;WITH A NO ROOM MESSAGE AND A KJOB
			;WILL BE FORCED SINCE JLOG WILL NOT HAVE
			;BEEN TURNED ON BY LOGINN.

; NAME OF CUSP TO RUN TO LOG USER IN

PRVLOG:	SIXBIT /LOGINN/


; "R CUSPNAME CORE" - DOES "RUN SYS:CUSPNAME"

EXTERNAL TTCMCH

RCOM:	MOVEI	T1,0		;NO FILE NAME. TTY WILL SUPPLY IT
	JRST	ARCOM1

ARCOM:	MOVEI 	T3,12		;MAKE SURE NO MORE ARGS SCANNED
	MOVEM 	T3,TTCMCH	; ..
ARCOM1:	MOVEM	T1,JBTNAM(J)	;STORE FILE NAME
	MOVSI	T2,(SIXBIT /SYS/) ;READ FROM SYS DEVICE
	JRST	RUNCO2

; "RUN DEVICE:FILE[PROJ.,PROG.] (CORE)"
;DOES A CORE,GET,START ALL IN ONE
;IF CORE ARG IS MISSING, SIZE IN DIRECTORY IS USED
;JOB ON DISK OR IN CORE OR NO CORE, BUT NOT IN MIDDLE OF SWAP

EXTERNAL JOBDA,JOBFDV,JOBEXM,JOB41,JOBCOR,JOBFF

RUNCOM: SETZM	JBTNAM(J)	;CLEAR FILE NAME
RUNCO3:	MOVSI 	T2,'DSK'
RUNCO2:	HRRI 	S,RUNJOB
	TLNE 	S,1
	MOVEI 	S,RUNJB2	;FOR SA+1
	JRST 	SGSET

; RUN RESTRICTED COMMAND USER FILE
;
RESRUN:	PUSH	P,T2		;save sixbit command name
	PUSHJ 	P,MAPUPS	;GET SPECIAL FILE NAME
	POP	P,%UPS+UPTUAC##+1;return command name in user AC 1
	MOVE 	T1,%UPS+UPTRNM
	TLO 	S,2		;FLAG RUN SPECIAL FILE
	MOVEM 	T1,JBTNAM(J)	;SET NAME
	MOVEI 	T3,12
	MOVEM 	T3,TTCMCH
	JRST 	RUNCO3


; "ASSIGN DEV:NAME" - ASSIGN DEVICE TO JOB AND GIVE IT LOGICAL NAME

EXTERNAL DEVLST

ASSIGN:	PUSHJ P,CTXDEV	;GET FIRST ARGUMENT TO T2 "DEV"
	JUMPE T2,NOTENF	;NO ARGUMENT TYPED IF 0

	MOVE P4,T2		;SAVE DEVICE NAME
	PUSH P,U		;SAVE TTY LDB
	MOVE T1,T2		;DEVICE NAME IN T1
	PUSHJ P,DEVPHY	;DO SOMETHING (LOOK FOR TTY MAYBE)
	JRST ASSG3		;NOT A PHYSICAL NAME
	JRST ASSG4		;A SPECIFIC PHYSICAL NAME

ASSG3:	MOVEI T2,ASSCON	;SET UP ASSIGNED BY CONSOLE BIT
	HLRZ F,DEVLST	;PREPARE TO SEARCH DDB'S
ASSG0:	MOVE T1,DEVNAM(F)	;GET DEVICE NAME FROM DDB
	CAMN P4,DEVNAM(F)	;DOES PHYSICAL NAME WITH "DEV"?
	JRST ASSG4		;YES
	LDB W,PJOBN		;SAVE OLD JOB# FOR THIS DEVICE
	TRZ T1,-1		;COMPARE LEFT HALF ONLY (DTA,MTA,DPC)
	CAMN T1,P4		;DOES IT MATCH?
	PUSHJ P,ASSASG	;MATCH, TRY TO ASSIGN DEVICE
	JRST ASSG2		;KEEP LOOKING
	JUMPE W,ASSFIN		;SUCCESS IF OLD JOB# 0, DEVICE PREVIOUSLY UNASSIGNED

ASSG2:	HLRZ F,DEVSER(F)	;GET ADDRESS OF NEXT DDB
	JUMPN F,ASSG0	;KEEP LOOKING
	POP P,U		;RESTORE TTY LDB
	JRST NOTDEV		;PRINT "NO SUCH DEVICE"

;PHYSICAL NAME MATCHES IF HERE

ASSG4:	MOVE T2,DEVMOD(F) ;DEVMOD WORD
	TLNN T2,DVDSK		;IS THIS A DISK?
	JRST ASSG5		;NO.
	SETZM DEVLOG(F)	;YES. CHECK FOR LOGICAL NAME
	POP P,U		;RESTORE TTY LDB ADDRESS
	PUSH P,F		;AND SAVE DEVICE'S DDB
	PUSH P,T1		;SAVE PHYSICAL NAME
	PUSHJ P,CTEXT1	;GET LOGICAL NAME ARGUMENT OF "ASSIGN DEV:NAME"
	MOVE T1,T2		;COPY TO T1 FOR DEVLG
	JUMPE T1,ASSG8		;NO LOGICAL NAME SPECIFIED, IF 0
	PUSHJ P,DEVLG		;SEE IF LOGICAL NAME IN USE
	JRST .+2		;NO
	JRST ASSG7		;YES, ERROR! SO NO ASSIGNMENT
	POP P,T2		;GET PHYSICAL NAME BACK
	POP P,F		;RESTORE DDB ADDRESS
	PUSH P,T1		;SAVE LOGICAL NAME
	MOVE T1,T2		;SET T1= PHYSICAL NAME FOR ASSASG
	MOVEI T2,ASSCON
	PUSHJ P,ASSASG	;ASSIGN BY CONSOLE
	JRST ASSER0		;NO MORE CORE FOR DISK DDB'S
	POP P,T1		;RESTORE LOGICAL NAME
	JRST ASSF2		;FINISH LOGICAL ASSIGNMENT

ASSG5:	MOVEI T2,ASSCON
	PUSHJ P,ASSASG	;TRY TO ASSIGN DEVICE
	JRST ASSER1		;ALREADY ASSIGNED TO ANOTHER JOB
	JRST ASSFIN		;SUCCESSFULLY ASSIGNED

ASSG8:	POP P,T2		;REMOVE GARBAGE FROM PD LIST
	JRST ASSF1

ASSG7:	POP P,T2		;REMOVE PHYSICAL OAME FROM PD LIST
	JRST ASSF0


;ALREADY ASSIGNED TO ANOTHER JOB

ASSER0:	MOVEM U,0(P)		;DISCARD LOGICAL NAME VIA NEXT POP INSTR
ASSER1:	POP P,U		;GET LDB ADDRESS
ASSER2:	JSP T1,ERRMES
	ASCIZ /?device not available
/


;DEVICE ASSIGNED, GIVE IT A LOGICAL NAME
ASSFIN:	SETZM	DEVLOG(F)	;CLEAR LOGICAL NAME
	POP P,U		;RESTORE TTY LDB ADDR
	PUSH P,F		;SAVE DEVICE'S DDB
	PUSHJ P,CTEXT1	;GET SECOND ARG, LOGICAL DEVICE NAME
	SKIPE T1,T2		;IS THERE A LOGICAL NAME SPECIFIED?
	PUSHJ P, DEVLG	;YES, SEE IF IT IS ALREADY IN USE
				; BY THIS USER
	JRST ASSF1		;NO
ASSF0:
	TLO	P3,ERRFLG	;Equivalent to calling ERRMES
	PUSHJ	P,INLMES
	ASCIZ	/?logical name already in use, /
	MOVEI T1,0		;CLEAR LOGICAL NAME FOR THIS DEVICE
ASSF1:	POP P,F		;DDB OF THE NEWLY ASSIGNED DEVICE
ASSF2:	MOVEM T1,DEVLOG(F);STORE IN DEVICE DATA BLOCK
	MOVSI T2,DVDIRIN	;CLEAR DIRECTORY IN CORE BIT
	ANDCAM T2,DEVMOD(F)	;
	MOVE T2,DEVNAM(F)	;PHYSICAL NAME
	PUSHJ P,PRNAME	;PRINT IT
	JSP T1,CONMES

	ASCIZ / assigned
/


;"DEASSIGN DEV" - DEASSIGNS DEVICE FROM CONSOLE


DEASSI:
	PUSHJ P,CTXDEV		;GET DEVICE NAME
	JUMPE T2,DEASTY 	;NO ARG. IF 0, DEASSIGN ALL BUT TTY
	MOVE T1, T2		;DEVICE NAME
	PUSHJ P, DEVSRC		;SEARCH FOR DEVICE
	 JRST DEAER1		;NOT FOUND
	PUSHJ P, DEASG		;FOUND, DEASSIGN IT
	 JRST DEAER2		;NOT PREVIOUSLY ASSIGNED
	POPJ P,			;DEVICE DEASSIGNED

NOTDEV:
DEAER1:	MOVE U,-1(P)		;RESTORE TTY U DATA BLOCK
	JSP T1,ERRMES		;PRINT NO SUCH DEVICE
	ASCIZ /?no such device
/

DEAER2:	PUSHJ P,INLMES
	 ASCIZ "?"
	MOVE T2,DEVNAM(F)	;PRINT PHYSICAL DEVICE NAME
	MOVE U,-1(P)		;RESTORE TTY LDB
	PUSHJ P,PRNAME
	JSP T1,ERRMES
	ASCIZ / wasn't assigned
/


;REASSIGN M
;CALL	MOVE AC,JOB NUMBER
;	MOVE AC+1,SIXBIT /DEVICE/
;	CALL AC,[SIXBIT /REASSIGN/]
;IF C(AC)=0, JOB HAS NOT BEEN INITIALIZED
;IF C(AC+1)=0, DEVICE NOT ASSIGNED TO THIS JOB OR DEVICE IS A TTY

INTERNAL REASSIGN
EXTERNAL PUUOAC

REASSI:	PUSH P,T1		; PUSH JOB #
	HRRI M,1(M)
	UMOVE T2,(M)		; GET DEVICE DESCRIPTOR
	SOS M
	JUMPN T1,REASS1		; IF JOB#0 THEN REASSIGN TO JOB
				; ELSE, DEASSIGN THE DEVICE
	PUSHJ P,DVCNSG		; LOOKUP DEVICE
	 JRST REASE2		; NOT FOUND
	PUSHJ P,DEASG		; GO DEASSIGN IT
	 JRST REASE3		; NOT ASSIGNED TO THIS JOB
	POPJ P,			; ONLY RETURN (SICK)

;"REASSIGN DEV:JOB" - REASSIGN DEVICE "DEV" TO JOB "JOB"

REASS:	PUSHJ P,CTXDEV		;GET DEVICE NAME
	JUMPE T2,NOTENF		;NULL NAME?
	MOVE M,T2		;SAVE IT IN M
	PUSHJ P,DECIN1		;GET NEW JOB NUMBER
	 JRST NOTENF		;NONE SPECIFIED. DOESN'T RETURN IF ERROR
	JRST COMERA		;ILLEGAL CHARACTER
	PUSH P,T2		;PUT JOB NUMBER ON STACK, DEVICE
	MOVE T2,M		;NAME IN T2
	SETZM M			;SET COMMAND SWITCH

;ROUTINE COMMON TO REASSIGN M AND COMMAND


REASS1:	EXCH J,(P)		;NEW JOB NO. IN J
	CAIL J,JOBN		;IS JOB NUMBER OUT OF RANGE?
	 JRST REASE1		;YES, DO NOT REASSIGN
	MOVE T1,JBTSTS(J)	;NEW JOB STATUS
	EXCH J,(P)		;RESTORE J AND STACK
	TLNN T1,JNA		;DOES NEW JOB EXIST?
	 JRST REASE1		;NO.
	MOVE T1,T2
	PUSHJ P,DVCNSG		;SEARCH FOR DEV
	 JRST REASE2		;NOT FOUND
	LDB T1,PJOBN
	CAME T1,J		;ASSIGNED TO THIS JOB
	 JRST REASE3		;NO
	MOVSI T1,LICTDV
	SKIPG M			;M NEGATIVE IF FROM CMD
	 MOVEI T1,LICTDV
	TDNE T1,JBTLIC(J)
	 JRST REASS5		;HE CAN DO IT
	MOVE T1,(P)		;NEW JOB NUMBER
	MOVE T1,JBTAUN(T1)	;SEE WHO IT IS
	XOR T1,JBTAUN(J)
	TLNE T1,-1		;IS IT SAME ACCOUNT
	 JRST REASE6		;NO, CAN NOT BE REASSIGNED
REASS5:	MOVE T1,DEVMOD(F)
	TLNE T1,DVTTY!DVRMT	;IS IT A TTY?
	 JRST REASE6		;YES. CAN'T BE REASSIGNED.
	TRNN T1,ASSPRG		;IS DEVICE INITED?
	 JRST REASS3		;NO.
	LDB T1,PJOBN		;AAA. IF REASSIGN TO OWN JOB,
	CAMN T1,JOB		;SKIP THE RELEASE. AAA
	 JRST REASS3		;AAA JAN 77
	JUMPN M,REASS4		;YES. COMMAND LEVEL?
	HRL F,(P)		;YES. SCHEDULE RELEASE
	PUSHJ	P,MAPUPS	;SET UP UPS
	MOVEM F,%UPS+UPTXAC+F	;SAVE F IN EXEC ACS
	POP P,T2
	TLO	P3,TTYRNC	;Set TTYRNC so job will run
	JSP T2,MSTART
	JSP T1,MONSTR
	HLRZ T1,F
	PUSH P,T1
	HRRZS F
	MOVE J,JOB
	SETOM M			;SET FLAG TO STOP JOB
REASS4:	HRRZ T4,DEVSER(F)
	XCTBU <HRRZM F,JOBFDV>
	MOVE W,%UPT+UPTHCU


REASS2:	MOVE F,%UPT+UPTJDA(W)	;GET XWD M BITS,DDB ADDRESS
	XCTBU <HRRZ T1,JOBFDV>	;GET ADDR. OF DDB SAVED BY COMMAND
	PUSH P,W		;SAVE USER CHANNEL
	CAIN T1,(F)	;IS CHOSEN DEVICE ON THHS CHANNEL?
	PUSHJ P,RELEA5	;YES, RELEASE DEVICE
	POP P,W
	SOJGE W,REASS2
	UMOVE F,JOBFDV
	MOVE J,JOB		;CURRENT JOB NUMBER
REASS3:	MOVEI T1,ASSCON	;ASSIGN IT BY CONSOLE
	IORM T1,DEVMOD(F)
	;MOVSI	T1,DVDIRIN	;CLEAR DIRECTORY IN CORE BIT
	;ANDCAM	T1,DEVMOD(F)  ;..
	;EXCH J,(P)
	;SETZM DEVLOG(F)	;ZERO LOGICAL NAME WHEN REASSIGNING
;AAA. LEAVE DDB ALONE IF DEVICE REASS TO OWN JOB, STILL INITTED
	MOVSI T1,DVDIRIN	;DIR IN CORE BIT GETS
	EXCH T1,DEVMOD(F)	;CLEARED ONLY IF ASSPRG=0
	TRNN T1,ASSPRG	;SKIP IF DEV INITTED (REASS TO ANOTHER JOB)
	ANDCM T1,DEVMOD(F);TURN OFF DVDIRIN IN T1
	MOVEM T1,DEVMOD(F)
	EXCH J,(P)
	TRNN T1,ASSPRG	;SKIP IF DEV INITTED STILL
	SETZM DEVLOG(F)	;ZERO LOGICAL NAME IF REASS TO
			 ;ANOTHER JOB. OTHERWISE LEAVE
	DPB J,PJOBN		;PUT IN NEW JOB NUMBER
	POP P,J
	JUMPL M,ESTOP
	POPJ P,

REASE1:	POP P,T1
	JUMPE M,ATT4		;JOB NEVER WAS INITIATED
REASE4:	 XCTBU <SETZM (M)>		;CLEAR C(AC)
	POPJ P,

REASE2:	MOVEI T1,NOTDEV	;NO SUCH DEVICE
REASE5:	POP P,T2
	JUMPE M,(T1)
	AOJA M,REASE4

REASE3:	MOVEI T1,DEAER2	;WASN'T ASSIGNED
	JRST REASE5

REASE6:	MOVEI T1,REASE7
	JRST REASE5
REASE7:	PUSHJ P,INLMES
	 ASCIZ "?"
	MOVE T2,DEVNAM(F)
	MOVE U,-1(P)		;RESTORE TTY LDB
	PUSHJ P,PRNAME
	JSP T1,ERRMES
	ASCIZ / can't be reassigned
/


;"ATTACH <DEVICE>"    OR
;"ATTACH <JOB NUMBER>

INTERNAL ATT1
EXTERNAL JOBN,TTYFND,JBTAUN,LICMSK,TTYATT

CHKATT:	; check to see if okay to attach TTY: for job J to job T2
	EXCH	T1,T2		;free up T2 for LICMSK
	HRL	T2,JBTLIC(T1)	;desired license
	HRR	T2,JBTLIC(J)	;current license
	PUSHJ	P,LICMSK	;compute allowed from desired,,current
	HLL	T2,JBTLIC(T1)	;only compare RH
	CAME	T2,JBTLIC(T1)	;see if desired license is allowed
	 POPJ	P,
	EXCH	T1,T2		;restore target job number to T2
	MOVEI 	P2,LICJAL
	TDZE 	P2,JBTLIC(J)	;JL license allows attach to any user
	 JRST 	CHKAT1
	MOVE 	P2,JBTAUN(J)
	XOR 	P2,JBTAUN(T2)	;check on job he wants to go to
	MOVEI 	T1,PVACTS	;is he an account supervisor?
	TDNE 	T1,JBTPRV(J)
	 TRZ 	P2,-1		;yes, user number need not match
	JUMPN 	P2,CPOPJ	;not okay to do it
CHKAT1:	AOS 	(P)		;all okay
	POPJ 	P,

ATTACH:	PUSHJ P,DECIN1		;GET JOB NO. IN T2 OR 0 IF NONE TYPED
	 JRST NOTENF		;NOT A NUMBER OR NONE SPECIFIEED
	 JRST DEVATT		;WANTS TO ATTACH A DEVICE
	JUMPE T2,DEVATT		;0 ILLEGAL JOB, SEE IF <DEVICE>
	CAIL T2, JOBN		;IS JOB NUMBER TOO BIG?
	 JRST ATT1		;ILLEGAL JOB NUMBER
	MOVSI T1,JNA		;HAS THIS JOB NO BEEN ASSIGNED?
	TDNN T1,JBTSTS(T2)
	 JRST ATT4		;NO, PRINT ERROR
	PUSHJ P,CHKATT		;is attach okay?
	 JRST ATT3		;can not attach
	PUSH P,J
	MOVE J,T2		;JOB NUMBER TO J
	PUSHJ P,TTYATT		;NO, ATTACH TTY
	 JRST ATT2A		;ERROR CAN'T ATTACH
	EXCH J,(P)		;GET OLD JOB #
	PUSHJ P,DETMSG		;NO. TYPE MESSAGE
	POP P,J			;RESTORE J
	JRST TTYFND		;ATTACHED. GO SET UP OUTP. BYTE PTR.

DEVATT:	PUSHJ P,CTXDEV		;GET DEVICE ARGUMENT
	JFCL			;SHOULD NEVER RETURN
	MOVE T1,JBTLIC(J)
	TRC T1,LICGDV!LICOPR
	TRCE T1,LICGDV!LICOPR	;MUST HAVE OPR AND GET DEV
	JRST ATT5		;NO - ERROR
	MOVE T1,T2		;YES-SET UP DEVICE NAME
	PUSHJ P,DEVSRC		;SEARCH FOR DEVICE
	JRST DEAER1		;NOT FOUND
	MOVSI T1,DVDSK!DVTTY!DVRMT	;DO NOT GET THESE
	TDNE T1,DEVMOD(F)
	JRST ATT5
	LDB T1,PJOBN		;SEE WHO HAS IT
	JUMPN T1,ATDV1		;NOT JOB 0, TRYING TO GET IT BACK
	MOVEI T1,ASSPRG
	ANDCAM T1,DEVMOD(F)	;GET IT OUT OF 'INITED STATE'
ATDV2:	DPB J,PJOBN		;AND ASSIGN TO THIS JOB
	POPJ P,

ATDV1:	MOVEI T1,ASSPRG
	TDNN T1,DEVMOD(F)
	JRST ATDV2		;NOT, INITED, GRAB IT
	JRST ATT5		;INITED, CAN NOT GET IT

ATT2A:	POP P,J			;REMOVE JUNK FROM STACK
	JUMPE F,ATT3		;NO DDB IN F, USE DIFF MSG
	PUSHJ P,INLMES
	 ASCIZ "?"
	MOVE T2,DEVNAM(F)	;PRINT PHYSICAL NAME
	PUSHJ P,PRNAME
	JSP T1,ERRMES
	ASCIZ " already attached
"

ATT3:	JSP T1,ERRMES
	ASCIZ "?unable to attach to frame
"

ATT5:	JSP T1,ERRMES
	ASCIZ "?unable to attach device
"

ATT4:	JSP T1,ERRMES
	ASCIZ "?frame not assigned
"

ATT1:	JSP T1,ERRMES
	ASCIZ "?illegal frame number
"

;"DETACH" - DETACH CONSOLE FROM JOB
;"DETACH DEVNAM" - DETACHES DEVICE FROM THE SYSTEM SOFTWAREWISE

EXTERNAL TTYDET,LDBDDB

DETACH: PUSHJ P,CTXDEV		;GET ARGUMENT
	JUMPE T2,DETAC1		;ONLY "DET" TYPED
	MOVE T1,JBTLIC(J)
	TRC T1,LICGDV!LICOPR
	TRCE T1,LICGDV!LICOPR	;MUST HAVE BOTH
	 JRST LOGER1		;NO-PRINT ERROR MSG.
	MOVE T1,T2		;YES-SET UP DEVICE NAME
	PUSHJ P,DEVSRC	;SEARCH FOR DEVICE
	 JRST DEAER1		;DEVICE NOT FOUND
	MOVE T1,DEVMOD(F)	;CHECK TO SEE IF THIS IS DSK
	TLNE T1,DVDSK!DVTTY		;IS IT THE DSK?
	 JRST DEAER1		;YES-PRINT ERROR MSG.
	MOVE U,-1(P)		;RESTORE U FOR ASSER2 AND LOGER1
	MOVEI T2,ASSCON		;FOUND-SET UP ASSIGNED BY CONSOLE
	PUSHJ P,ASSASG		;TRY TO ASSIGN
	 JRST ASSER2		;CAN'T ASSIGN
	TLNE F,SYSDEV		;IS THIS SYSTEM DEVICE?
	 JRST DEAER1		;YES-PRINT ERROR MSG.
	MOVEI T1,ASSPRG
	TDNE T1,DEVMOD(F)	;ALREADY ASSIGNED BY PROGRAM?
	 JRST LOGER1		;YES, CAN NOT DETACH
	IORM T1,DEVMOD(F)	;NO, SET BIT
	DPB T1,PJOBN		;SET JOB NUMBER TO 0
	PUSHJ P,CRLF
	PJRST PRPER		;SUCCESS: PRINT A PROMPT

DETAC1:	HRRZ F,LDBDDB(U)	;IS THERE A JOB ATTACHED?
	PJUMPE F,CRLF		;IF NONE, DONE NOW
	PUSHJ P,DETMSG
	JRST TTYDET		;YES. GO DETACH IT FROM U

DETMSG:	PUSHJ P,INLMES		;TELL USER WHERE HE WAS
	ASCIZ "from frame "
	PJRST PJOB

LOGER1:	JSP T1,ERRMES
	ASCIZ "?unable to detach device
"

;"DAYTIME" - PRINT TIME OF DAY

EXTERNAL THSDAT,MONTAB,JFYMIN,COMTMS,JFYHR,GETGMT,DATCOM,DSTCHK,PVYTIM
INTERNAL	DAYTIM

SETTIM:	PUSHJ P,DECIN1	;FROM SET TIME COMMAND
	JRST COMERA		;NO ARG, ERROR
	JRST COMERA		;ERROR
	MOVEI T1,LICOPR	;IS IT OPER
	TDNN T1,JBTLIC(J)
	JRST COMERA		;NO OPR LIC, ERROR
	MOVE T1,T2		;YES, RESET TIME ACCORDING TO ARGUMENT
	IDIVI T1,^D100
	IMULI T1,^D60		;
	ADD T1,T2		;COMPUTE MINUTES
	PUSHJ P,COMTMS
	 JRST COMERR
	POPJ P,

DAMESS:	ASCIZ	/-JAN-/

STZONE:	ASCIZ	/Y/	;  4
	ASCIZ	/BST/	;  5 BERING STANDARD TIME
	ASCIZ	/HST/	;  6 HAWAII-ALASKA STANDARD TIME
	ASCIZ	/YST/	;  7 YUKON STANDARD TIME
	ASCIZ	/PST/	; 10 PACIFIC STANDARD TIME
	ASCIZ	/MST/	; 11 MOUNTAIN STANDARD TIME
	ASCIZ	/CST/	; 12 CENTRAL STANDARD TIME
	ASCIZ	/EST/	; 13 EASTERN STANDARD TIME
	ASCIZ	/AST/	; 14 ATLANTIC STANDARD TIME
	ASCIZ	/P/	; 15
	ASCIZ	/O/	; 16
	ASCIZ	/N/	; 17
	ASCIZ	/GMT/	; 20 GREENWICH MEAN TIME (Western European)
	ASCIZ	/CET/	; 21 CENTRAL EUROPEAN TIME
	ASCIZ	/EET/	; 22 EASTERN EUROPEAN TIME
	ASCIZ	/C/	; 23
	ASCIZ	/D/	; 24
	ASCIZ	/E/	; 25
	ASCIZ	/F/	; 26
	ASCIZ	/G/	; 27
	ASCIZ	/H/	; 30
	ASCIZ	/JST/	; 31 TOKYO
	ASCIZ	/K/	; 32 BRISBANE
	ASCIZ	/L/	; 33
	ASCIZ	/M/	; 34

DSZONE:	ASCIZ	/Y +/	; 44
	ASCIZ	/BDT/	; 45 BERING DAYLIGHT TIME
	ASCIZ	/HDT/	; 46 HAWAII-ALASKA DAYLIGHT TIME
	ASCIZ	/YDT/	; 47 YUKON DAYLIGHT TIME
	ASCIZ	/PDT/	; 50 PACIFIC DAYLIGHT TIME
	ASCIZ	/MDT/	; 51 MOUNTAIN DAYLIGHT TIME
	ASCIZ	/CDT/	; 52 CENTRAL DAYLIGHT TIME
	ASCIZ	/EDT/	; 53 EASTERN DAYLIGHT TIME
	ASCIZ	/ADT/	; 54 ATLANTIC DAYLIGHT TIME
	ASCIZ	/P +/	; 55
	ASCIZ	/O +/	; 56
	ASCIZ	/N +/	; 57
	ASCIZ	/WEST/	; 60 WESTERN EUROPEAN SUMMER TIME
	ASCIZ	/CEST/	; 61 CENTRAL EUROPEAN SUMMER TIME
	ASCIZ	/EEST/	; 62 EASTERN EUROPEAN SUMMER TIME
	ASCIZ	/C +/	; 63
	ASCIZ	/D +/	; 64
	ASCIZ	/E +/	; 65
	ASCIZ	/F +/	; 66
	ASCIZ	/G +/	; 67
	ASCIZ	/H +/	; 70
	ASCIZ	/JST+/	; 71 TOKYO + DAYLIGHT  (Not normally used)
	ASCIZ	/K +/	; 72 BRISBANE + DAYLIGHT
	ASCIZ	/L +/	; 73
	ASCIZ	/M +/	; 74


DAYTIM:	PUSHJ P,GETGMT		; GET T1=TIME T2=DATE (GMT)
	MOVSI P4,400020		; SET DEFAULT OF TYM-GMT TO DEC-CURRENT
	LDB T4,PVYTIM		; GET OUR CURRENT TIME ZONE
	TRNN T4,40		; DAYLIGHT SAVINGS EFFECTIVE FOR ME?
	  JRST DAYTI0		; NO! DON'T BOTHER, ONLY CONVERT ONCE
	MOVE P4,[400020,,400000]; CONVERT FROM TYMSHARE GMT
	PUSHJ P,DATCOM		;    TO TYMSHARE CURRENT USER
	  SETZB T1,T2		;BAD DATE ?
	PUSH P,T2		;SAVE DATE (TYM-FORMAT) AND
	PUSH P,T1		;SAVE TIME (TYM-FORMAT) FOR DST CHECK
	MOVSI P4,400000		; CONVERT FROM TYMSHARE CURRENT
DAYTI0:	PUSHJ P,DATCOM		;    TO DEC CURRENT
	  SETZB T1,T2		;BAD DATE ?
	PUSH P,T1		;SAVE TIME
	MOVE T1,T2
	IDIVI T1,^D31
	EXCH T1,T2		;YEAR AND MONTH IN T2
	PUSHJ P,DECP1		;ADD 1 TO DAY(IN T1) AND PRINT DECIMAL
	MOVEI T1,0
	DIVI T1,^D12
	EXCH T1,T2
	MOVE T1,MONTAB(T1)	;MONTH
	DPB T1,[POINT 21,DAMESS,27]
	MOVEI T1,DAMESS
	PUSHJ P,CONMES		;PRINT DAY
	MOVEI T1,^D1964(T2)
	PUSHJ P,RADX10		;PRINT YEAR
	PUSHJ P,PRSPC
	POP P,T1		;RESTORE DAYTIME
	PUSHJ P,PRTIME		;PRINT TIME AS HH:MM:SS
	PUSHJ P,INLMES		;PRINT A SPACE
	 ASCIZ / /
	LDB T4,PVYTIM		;GET OUR CURRENT TIME ZONE
	TRNN T4,40		;DAYLIGHT SAVINGS EFFECTIVE FOR ME?
	  JRST DAYTI1		;NO! DON'T BOTHER WITH CHECKING. (STACK OK!)
	POP P,T1		;YES! RESTORE TIME (STACK HAS 2 ITEMS ON IT)
	IDIV T1,JFYHR		;DIVIDE TO GET HOURS
	POP P,T2		;RESTORE DATE SINCE JAN 1 1964 (STACK OK)
	IMULI T2,^D24		;MULTIPLY TO MAKE HOURS
	ADD T1,T2		;ADD TO GET HOURS SINCE JAN 1 1964
	PUSHJ P,DSTCHK		;DO WE FALL WITHIN DAYLIGHT SAVINGS?
	  TDZA T3,T3		;YES--CLEAR FLAG
DAYTI1:	SETO T3,		;NO---SET FLAG
	TRZ T4,40		; T4 STILL OK, CLEAR DST IF WAS ON
	MOVEI T1,STZONE-4(T4)	;GET ASCIZ STRING TO TYPE
	SKIPN T3		; SKIP IF WE'RE OK
	  MOVEI T1,DSZONE-4(T4)	;  ELSE USE DAYLIGHT STRING
	PUSHJ P,CONMES		; TYPE IT.
	PJRST CRLF		;AND ADD CRLF


;"TIME (JOB NO.)" - PRINT TOTAL AND INCREMENTAL RUNNING TIME FOR A JOB
;FOLLOWED BY KILO-CORE TICKS
;"TIME 0" IMPLIES RUNTIME FOR NULL JOB
;	IF NO JOB NO. GIVEN-TIME WILL BE FOR CURRENTLY LOGGEN IN JOB NO.

EXTERNAL RTIME,CLRWRD,CHKSGJ

RUNTIM:	PUSHJ P,DECIN1		;GET JOB NO. ARG
	 JRST RUN1		;NO ARG
	 JRST COMERA		;BAD ARG
	CAIL T2,JOBN		;IS IT OK?
	JRST ATT1		;NO
	EXCH J,T2	;SET J
	PUSH P,T2	;SAVE JOB NUMBER
	PUSHJ P,CHKSGJ	;SEE IF HE CAN HAVE THAT INFO
	 JRST	[POP	P,J	;No
		 JRST	COMERA]
	PUSHJ P,RUNT2		;GET TIME SET UP
	POP P,T1	;GET TRU'S
	POP P,T2
	PUSHJ P,PRTTM1		;SKIP PRINTING INCREMENTAL
	POP P,J		;GET J BACK SO NO ERROR ON TIME 0
	POPJ P,

RUN1:	PUSHJ P,RUNT2
	MOVE T1,(P)		;THIS IS WHEREE TRU'S END UP
	EXCH T1,RTIME(J)
	SUB T1,RTIME(J)
	MOVNS T1
	PUSHJ P,PRTDC1
	PUSHJ P,INLMES
	ASCIZ / TRU
/
	POP P,T1
	POP P,T2
PRTTM1:	PUSHJ P,PRTDC2
	PUSHJ P,INLMES
	ASCIZ / TRU
/
	PUSHJ P,INLMES
	ASCIZ /terminal time: /
	MOVE T1,JBTCNK(J)
	IMUL T1,JFYSEC		; MAKE PRINTER WORK RIGHT
	PJRST PRTIM		; ROUTINE IS AT END OF COMCON

RUNT2:	PUSHJ P,TIMADJ
	PUSHJ P,CLKTRU
	EXCH T2,(P)
	PUSH P,T1
	JRST (T2)

PRTDC1:	MOVEI T2,0
PRTDC2:	EXCH T1,T2
	DIVI T1,^D10000
	PUSH P,T2
	PUSHJ P,RADX10
	PUSHJ P,INLMES
	ASCIZ /./
	POP P,T1
	IDIVI T1,^D100
	PUSH P,T1
	MOVEI T3,"0"
	CAIGE T1,^D10
	PUSHJ P,COMTYO	;MAKE SURE 2 DIGITS
	POP P,T1
	JRST RADX10
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	USESTA - Routine to process the .USESTAT command	;;
;;								;;
;;	Types a string on the command port terminal in the	;;
;;	following format -					;;
;;								;;
;;"elapsed:HH:MM:SS tru:d.dd blks in:xx out:yy state:zz mws:qq" ;;
;;								;;
;;	The display elements are elapsed time since the last	;;
;;	.USESTAT command in hours, minutes, and seconds; cpu	;;
;;	time (microcycles) in minutes, seconds, and jiffies;	;;
;;	disk blocks read; disk blocks written; the current	;;
;;	state of the calling job; and the current monitor	;;
;;	working set size.					;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	EXTERNAL JBTSTA
USESTA:	PUSHJ	P,INLMES	;Preliminary type-out
	ASCIZ	/elapsed:/
	MOVE	T1,JBTCNK(J)	;Connect time
	EXCH	T1,JBTSTA(J)	;Previous (saved) connect time
	SUB	T1,JBTSTA(J)	;Negative difference
	MOVNS	T1		;Positive difference
	IMULI	T1,^D60		;Convert to jiffies for type-out routine
	PUSHJ	P,PRTIME	;Type out time (no CR-LF)
	PUSHJ	P,INLMES
	ASCIZ	/ tru:/
	PUSHJ	P,PRTWRN	;Type out incremental TRU's
	PUSHJ	P,INLMES
	ASCIZ	/ blks in:/
	PUSHJ	P,PRTWDR
	PUSHJ	P,INLMES
	ASCIZ	/ out:/
	PUSHJ	P,PRTWDW
	PUSHJ	P,INLMES
	ASCIZ	/ state:/
	LDB	T2,PJBSTS	;Wait state code from JBTSTS
	IDIVI	T2,3		;Make index into STSTBL, which has
	MOVE	T2,STSTBL##(T2)	;3 2-SIXBIT-char entries per word
	IMULI	T3,^D12		;Has 0,1, or 2 remainder from divide
	LSH	T2,(T3)		;Get proper code to high-order T2
	SKIPL	JBTSTS(J)	;Is the run bit on?
	  MOVSI	T2,'^C '	;If not, indicate special case
	ROTC	T2,6		;Get first SIXBIT char into low-order T3
	ADDI	T3,40		;Convert to ASCII
	PUSHJ	P,COMTYO##	;Type one character
	MOVEI	T3,0		;Clear out previous char
	ROTC	T2,6		;Second SIXBIT character
	ADDI	T3,40
	PUSHJ	P,COMTYO##
	MOVEI	T3,"*"		;In case we are currently running
	CAMN	J,JOB		;Are we the current job?
	  PUSHJ	P,COMTYO	;Yes, say so
	PUSHJ	P,INLMES
	ASCIZ	/ mws:/
	LDB	T1,JBYMWS##
	PUSHJ	P,RADX10
	POPJ	P,
;ROUTINE TO SEND A U OF INFORMATION TO ANOTHER TTY, OR
; TO BROADCAST IT TO ALL TTY'S

EXTERNAL COMTYT		;GET UNSHIFTED CHAR IN T3

EXTERNAL TTYPHY		;GET U AND DDB FOR TTY NAMED IN T1
EXTERNAL TTYNAM		;GET NAME INTO T2 FOR TTY ON U (EVEN IF NO DDB)

EXTERNAL OPRLDB,LDLCOM

SEND:   PUSH P,P1 		;WE MIGHT NEED 2 MORE REGISTERS
	PUSH P,S		;SAVE THE CONTENTS OF R AND S
	SETZ S			;SET FLAG TO ZERO
	PUSHJ P,CTXDEV		;GET ARGUMENT DEVICE OF SEND
	JUMPE T2,[POP P,S
                  POP P,P1
                  JRST NOTENF]  ;MUST BE ONE
	MOVS T1,T2		;GET IT SWAPPED FOR COMPARES
	CAIN T1,(SIXBIT /JOB/)	;PARTICULAR JOB NUMBER?
	JRST SENDJ		;YES. GO FIND IT
	CAIN T1,(SIXBIT /ALL/)	;BROADCAST TO ALL TTY'S?
	JRST SENDA		;YES.
	CAIN T1,(SIXBIT /GAN/)	;BROADCAST ONLY TO SENDER'S GAN?
	JRST SNDGAN		;YES
	PUSH P,U		;SAVE U ADDRESS OF SENDER
	MOVE T1,T2		;GET DEVICE NAME TO SEARCH FOR
	PUSHJ P,TTYPHY		;SEE IF IT'S A TTY
	  JRST SENDF		;NO. FAILURE.
SENDT:	HRRZ T1,0(P)		;SEE IF EITHER GUY IS THE OPR
	SKIPL LDBLOG(U)
	JRST SNDBSY		;CHECK FOR LOGGED IN
	CAME U,OPRLDB	; ..
	CAMN T1,OPRLDB		; ..
	JRST SENDT1		;YES. DONT BUSY CHECK
	MOVE T1,LDBDCH(U)	;NO. SEE IF DEST IS AT COMMAND LEVEL
	TLNE T1,LDLCOM		; ..
	JRST SENDT1
	MOVEI T1,LICOPR
	TDNN T1,JBTLIC(J)
	JRST SNDBSY		;NOT BUSY IF FROM OPR LICENSE JOB
SENDT1:				;OK CAN SEND TO HIM
	PUSHJ P,SENDHD		;SEND HEADER (CRLF, SEMI, TTY NAME)

SEND1:	PUSHJ P,SNDTYI		;GET CHARACTER TO SEND OUT
	  JRST SEND2		;END OF U
	PUSHJ P,COMTYO		;SEND IT (DEST IN U)
	JUMPN T3,SEND1		;LOOP FOR MORE

SEND2:	PUSHJ P,SNDEOL		;SEND CRLF, MAYBE DOT TO DEST
SENDX:	POP P,U			;RESTORE STACK, GET SENDER LDB
	POP P,S
	POP P,P1
	POPJ P,0		;AND RETURN FROM SEND COMMAND

SNDBSY:	POP P,U		;RESTORE TALKERS LDB ADDR
	POP P,S			;RESTORE STACK
	POP P,P1
SNDBSI:	JSP T1,ERRMES		;TYPE ERROR AND RETURN
	ASCIZ /?busy
/



;MORE OF SEND COMMAND

EXTERNAL TTYTAB,DDBLDB,LDPLNO,LINTAB,MXLIN

SENDJ:	PUSHJ P,DECIN1		;GET DESIRED JOB NUMBER
	JRST ENFERR		;MUST HAVE ARGUMENT
	JRST ERRSTR		;NOT A DECIMAL NUMBER
	CAIL T2,JOBN		;LEGAL JOB NUMBER?
	JRST JNERR		;NO. SAY SO AND QUIT
	MOVE T1,JBTSTS(T2)	;OK. SEE IF JOB EXISTS
	TLNN T1,JNA		; ..
	JRST ATT4		;THAT JOB NOT ASSIGNED
	PUSH P,U		;OK. SAVE SENDER'S LDB
	HRRZ F,TTYTAB(T2)	;GET TTY DDB OF DEST JOB
	JUMPE F,SENDF	;MUST BE ONE
	HRRZ U,DDBLDB(F)	;GET LDB ADDRESS
	SKIPGE LDBLOG(U)
	JUMPN U,SENDT	;AND GO SEND IT (IF NOT DETACHED
SENDF:	POP P,U		;OOPS. NO SUCH GUY. GET SENDER
	POP P,S			;RESTORE STACK
	POP P,P1
	JSP T1,ERRMES		;GIVE SENDER THE BAD NEWS
	ASCIZ /?no such port
/

SENDA:	MOVEI T1,LICOPR
	TDNN T1,JBTLIC(J)
	JRST ERRSTR		;NO. BAD COMMAND
GANBGN:	PUSH P,U		;YES. STACK LDB ADR OF OPR
	MOVNI U,1		;START AT U 0
	JRST SENDA2		; ..
SENDAL:	LDB U,LDPLNO		;GET CURRENT U NUMBER
	CAIL U,MXLIN    	;DONE THEM ALL?
	JRST SENDA3		;YES.

SENDA2:	HRRZ U,LINTAB+1(U)	;GET LDB ADDRESS
	SKIPL LDBLOG(U) 	;POTENTIAL SENDEE
	JRST SENDAL		;NO, ON TO NEXT PERSON
	TRNE S,1		;IS THIS A GAN CMD?
	PUSHJ P,GANTST		;YES, SEE IF U IS IN SENDER'S GAN
	PUSHJ P, SENDHD		;SEND HEADER TO SENDEE
	JRST SENDAL		;GET ANOTHER ONE

SENDA3:	PUSHJ P, SNDTYI		;GET A CHAR FROM SENDER
        JRST SENDAX		;NO MORE.
	PUSHJ P,TYOALL		;SEND TO ALL LINES
	JRST SENDA3		;LOOP TILL END OF U
GANTST:	PUSHJ P, GANGET		;GET AUN OF POTENTIAL SENDEE
	CAMN T1, P1		;IS SENDEE IN GAN?
	POPJ P,			;SENDEE FOUND, NORMAL RETURN
	AOS (P)			;SORRY, NOT IN GAN
	POPJ P,			;RETURN

GANGET:	HRRZ F, LDBDDB(U)	;GET ADDRESS OF ATTACHED JOB
	LDB T1, PJOBN		;GET JOB NUMBER
	HLRZ T1, JBTPPN(T1)	;GET AUN NUMBER
	POPJ P,			;RETURN

SENDAX:	MOVNI U,1		;SEND EOL AND MAYBE DOT TO ALL DESTS
	JRST SENDX1		; ..
SENDX2:	LDB U,LDPLNO		;GET NEXT U NUMBER
	CAIL U,MXLIN	;THROUGH WITH ALL?
	JRST SENDX		;YES.
SENDX1:	HRRZ U, LINTAB+1(U)	;NO, GET LDB ADDRESS OF NEXT U
	SKIPL LDBLOG(U)		;POTENTIAL SENDEE?
	JRST SENDX2		;NO, CONTINUE LOOPING
	TRNE S,1		;IS THIS A GAN COMMAND?
	PUSHJ P,GANTST		;YES, SEE IF U IS IN SENDER'S GAN
	PUSHJ P, SNDEOL		;SEND CRLF (DOT)
	JRST SENDX2		;LOOP TILL DONE

SNDGAN:	MOVEI T1,LICOPR		;IF SENDER HAS OPER LICENSE
	TDNE T1, JBTLIC(J)	;THEN IT'S OK TO USE GAN CMD
	JRST SNDGN1		;SENDER HAS LICENSE
	MOVE T1,JBTPRV(J)	;DOES SENDER HAVE ACCT SUPR PRIV?
	TRNN T1,20000
	JRST GANERR		;SENDER HAS NOTHING. TYPE ERROR AND RETURN
SNDGN1:	HLRZ P1, JBTPPN(J)	;OK TO USE GAN. STORE SENDER'S AUN
	SETO S			;SET FLAG TO TELL SENDA THAT THIS IS 
	JRST GANBGN		;A GAN COMMAND	

GANERR:	POP P,S			;RESTORE STACK
	POP P,P1
	JSP T1, ERRMES		;PRINT ERROR MESSAGE AND RETURN
	ASCIZ /?gan cmnd not permitted
/


;MORE OF SEND COMMAND

;SUBROUTINE TO GET CHARACTER FROM SENDER, WHOSE LDB IS ON STACK

SNDTYI:	EXCH U,-1(P)		;GET SENDER'S LDB
	PUSHJ P,COMTYT		;GET HIS CHARACTER AND ITS BITS
	  JFCL			;DON'T CARE IF LOWER CASE
	EXCH U,-1(P)		;RESTORE U OF SENDEE
	CAIE T3,12
	CAIN T3,3
	POPJ P,		;BREAK CHARACTER
	JRST CPOPJ1	;NON-BREAK CHARACTER

SENDHD:	PUSHJ P,INLMES		;SEND START OF SEND MESSAGE
	ASCIZ /
;;/
	EXCH U,-1(P)		;GET SENDER'S LDB ADR
	PUSHJ P,TTYNAM		;CONVERT TO REAL NAME IN SIXBIT
	HRRZ T1,U		;ONLY RH SHOULD COMPARE TO OPRLDB
	CAMN T1,OPRLDB	;IS IT THE OPR?
	MOVSI T2,(SIXBIT /OPR/)	;YES. SAY OPR INSTEAD
	EXCH U,-1(P)		;RESTORE U ADDRESSES
	PUSHJ P,PRNAME		;OUTPUT THE NAME TO SENDEE
	PUSHJ P,INLMES		;AND SPACER
	ASCIZ /: - /		; ..
	POPJ P,0		;RETURN FROM SENDHD

SNDEOL:	PUSHJ P,CRLF		;SEND CR LF TO (U)
	MOVE T1,LDBDCH(U)	;SEE IF DEST IS AT COM LEVEL
	TLNE T1,LDLCOM		; ..
	PUSHJ P,PRPER		;YES. SEND A DOT TOO
	POPJ P,0		;RETURN FROM SNDEOL

TYOALL:	MOVNI U,1		;START AT U 0
	JRST TYOAL2		; ..

TYOAL1:	LDB U,LDPLNO		;GET CURRENT U
	CAIL U,MXLIN	;ALL REAL TTY'S DONE YET?
	POPJ P,0		;YES. QUIT
TYOAL2:	HRRZ U, LINTAB+1(U)	;GET LDB ADDRESS
	SKIPL LDBLOG(U)		;POTENTIAL SENDEE?
	JRST TYOAL1		;NO. ON TO NEXT PERSON
	TRNE S,1		;IS THIS A GAN COMMAND?
	PUSHJ P,GANTST		;YES, SEE IF U IS IN SENDER'S GAN
	PUSHJ P, COMTYO		;SEND CHARACTER
	JRST TYOAL1		;LOOP AGAIN

ERRSTR: POP P,S			;RESTORE STACK BEFORE LEAVING
	POP P,P1
	JRST COMERA

ENFERR: POP P,S			;RESTORE STACK BEFORE LEAVING
	POP P,P1
	JRST NOTENF

JNERR:  POP P,S			;RESTORE STACK BEFORE LEAVING
	POP P,P1
	JRST ATT1


COMMENT	$
;  START MONITOR JOB AND SAVE USER PC AND ARGUMENTS
;  ON ENTRY T2=ADDR OF MONITOR JOB
;            J=JOB NUMBER
;        P1-P4=UP TO 4 ARGUMENTS
;
UMONJB:	
	PUSHJ	P,MAPUPS		;SETUP EXEC MAP
	MOVE T3,[IOWD EPLLEN,%UPT+UPTPDL]	;NEW PDL
	MOVE 	T1,%UPS+UPTPC	;GET PC
	TLNN	T1,PC.USR	;USER MODE
	MOVE	T3,%UPS+UPTXAC+P	;NO. SET UP NEW LIST
	HRRI	T3,%UPS-%UPT(T3)	;ADJUST POINTER TO UPS
	PUSH	T3,P1		;SAVE ARGUMENTS
	PUSH	T3,P2
	PUSH	T3,P3
	PUSH	T3,P4
	PUSH	T3,T1		;SAVE OLD PC
	HRRI	T3,%UPT-%UPS(T3)	;RELOCATE TO UPT
	MOVEM	T3,%UPS+UPTXAC+P	;STORE UPDATED P
	PUSHJ	P,MONJOB		;SET UP FOR MOITOR JOB
	POPJ	P,		;RETURN

;  SET UP WORLD FOR START OF MONITOR JOB WITH USER PC AND
;  ARGUMENTS SAVED.  MUST BE CALLED AS THE FIRST ROUTINE 
;  IN THE MONITOR JOB.  RETURNS ARGUMENTS IN P1-P4.

UMONST:	PUSH	P,0		;SAVE REGISTER 0.  (NO NEED TO
				;SAVE P SINCE WE KNOW WHAT IT WAS
	MOVE	0,-2(P)		;GET SAVE DPC
	HLRE	0,P		;-LENGTH OF PDL
	CAIL	0,-^D15		;ENOUGH ROOM FOR AC S?
	JSR	SYSCRS		;NO.
	HRLI	0,1		;START WITH REG 1
	HRRI	0,1(P)		;TO TOP OF PDL
	ADD	P,[XWD ^D15,^D15]	;FAKE PUSH
	BLT	0,(P)
	MOVE	J,JOB		;SET UP J
	MOVE	T1,-^D16(P)	;RETURN ADDRESS
	MOVE	P4,-^D18(P)	;LOAD UP ARGS
	MOVE	P3,-^D19(P)
	MOVE	P2,-^D20(P)
	MOVE	P1,-^D21(P)
	PUSH	P,T1		;SAVE THE AC
	PUSHJ	P,TTYFUW		;SET UP FOR TTY OPS
	POP	P,T1		;RESTORE AC
	JRST	(T1)		;RETURN TO CALLER
					$



COMMENT  $
;  END SPECIAL MONITOR JOB. ALLOW USER TO CONTINUE
;  MUST BE CALLED WITH STATCK INSAME STATE AS WHEN UMONST
;  WAS CALLED.
;
ENDUMJ:	PUSHJ	P,PRPER	;PRINT ENDING PERIOD
	MOVE	T1,-^D17(P)	;GET OLD PC
	MOVEM	T1,%UPT+UPTPC	;RESTORE IT
	HRLI	0,-^D13(P)
	HRRI	0,2
	MOVE	1,P
	BLT	0,17		;RESTORE AC'S 2-15
	MOVE	0,-^D15(1)	;RESTORE AC 0
	MOVE	1,-^D14(1)	;RESTORE AC 1
	SUB	P,[XWD ^D22,^D22] ;RESET STACK TO THE WAY WE WERE CALLED
	PUSH	P,%UPT+UPTPC	;USCHED EXPECTS PC ON TOP OF STACK
	PUSHJ	P,STOP1		;STOP MONITOR JOB
EXTERNAL USCHED
	JRST	USCHED
					$


EXTERNAL EPLLEN,SYSCRS,UPTXAC

; VERSION COMMAND.
;
VERPR:	MOVEI	T2,VMERPR
	PUSHJ	P,MONJOB	;START MONITOR JOB
	POPJ	P,

VMERPR:	MOVEI	T2,ESTOP
	JSP	T1,MONSTR
	PUSH P,[1]		;INDICATE VERSION COMMAND TO ECOMC
	XCTFU <PUSH P,137>	;GET VERSION NUMBER FROM USER SPACE
	PUSHJ P,TTYFUW		;SET UP FOR TTYP OUTPUT
	JRST	ECOMC	;GO PRINT IT


;"EXAMINE LOC" - LOOKS A CONTENTS OF LOC AND PRINTS IN OCTAL
;IF LOC IS MISSING, NEXT LOC IS PRINTED
;IF PREVIOUS WAS E COMMAND, SAME LOC IF PREVIOUS WAS D COMMAND
;TAB. IS PRINTED INSTEAD OF CRLF(LIKE DDT)

EXTERNAL TPOPJ

ECOM:	PUSHJ	P,PROPRG	;RUN ONLY CHECK
	PUSHJ	P,OCTIN1	;GET LOCATION
	TLOA	T2,400000	;FLAG NOTHING ENTERED
	JRST	COMERA		;BAD OCTAL NUMBER
	MOVE	P1,T2		;SET UP AS ARGUMENT FOR MONITOR JOB
	MOVEI	T2,EMCOM	;START ADDRESS OF MONITOR JOB
	PUSHJ	P,MONJOB	;START MONITOR JOB
	JRST	DMCOM1

EMCOM:	MOVEI	T2,ESTOP	;ENDING ADDRESS
	JSP	T1,MONSTR
	SETZ	F,		;DON'T PRINT ADDRESS CHECK ON ILL MEM REF
	XCTBU <SKIPGE JOBEXM>
	XCTBU <AOS JOBEXM>
	XCTBU <HRROS JOBEXM>
	SKIPGE	T1,P1		;ARGUMENT ENTERED?
	XCTBU <HRRZ T1,JOBEXM>	;NO. USE JOBEXM
	XCTBU <HRRM T1,JOBEXM>	;SAVE NEW JOBEXM
	PUSH P,[0]		;INDICATE D COMMAND TO ECOMC
	XCTFU <PUSH P,(T1)>	;WORD TO BE PRINTED
	PUSH P,T1		;SAVE ADDRESS
	PUSHJ	P,TTYFUW	;SET UP SO CAN PRINT
	POP P,T1		;RECOVER ADDRESS FOR PRINTING
	PUSHJ	P,OCTPNT	;PRINT ADDRESS
	PUSHJ P,INLMES	;PRINT SLASH TAB
	ASCIZ */	*
ECOMC:	HLRZ T1,(P)		;PRINT LEFT HALF
	PUSHJ P,OCTPNT
	PUSHJ P,INLMES	;PRINT SPACE
	ASCIZ / /
	HRRZ T1,(P)		;PRINT RIGHT HALF
	PUSHJ P,OCTPNT
	PUSHJ P,INLMES	;PRINT FINAL TAB
	ASCIZ /	/
	POP	P,T1
	POP P,T1		;RECOVER VERSION/D FLAG
	SKIPE T1		;VERSION?
	PUSHJ P,CRLF		;YES. PRINT CRLF
	PUSHJ P,PRPER
	JRST TTYSTC		;BACK TO COMMAND MODE


;"DEPOSIT LH RH LOC" - DEPOSITS XWD LH,RH IN LOCATION LOC
;IF LOC IS MISSING, ASSUME NEXT LOC IF PREVIOUS D, SAME LOC IF PREVIOUS E


DCOM:	MOVEI	T1,LICWCR	;MUST HAVE WC TO DO THIS
	TDNN	T1,JBTLIC(J)
	JRST	COMERR		;NO GOOD.
	PUSHJ	P,OCTIN1	;GET LEFT HALF
	JRST	NOTENF		;NEED ARGUMENT
	JRST	COMERA		;BAD CHARACTER
	HRLM	T2,P1		;SAVE LEFT HALF
	PUSHJ	P,OCTIN1		;GET RIGHT HALF
	JRST	NOTENF
	JRST	COMERA
	HRRM	T2,P1		;SAVE RIGHT HALF
	PUSHJ	P,OCTIN1	;GET LOCATION
	TLOA	T2,400000	;FLAG NONE TYPED
	JRST	COMERA
	MOVE	P2,T2		;SAVE LOCATION
	MOVEI	T2,DMCOM	;ADDR. OF MONITOR JOB
DMCOM1:	PUSHJ	P,MAPUPS		;SET UP UPT SLOT IN EXEC MAP
	MOVEM	P1,%UPS+UPTXAC+P1	;STORE ARGUMENT
	MOVEM	P2,%UPS+UPTXAC+P2
	PUSHJ	P,MONJOB	;START MONITOR JOB
	POPJ	P,

DMCOM:	MOVEI	T2,ESTOP
	JSP	T1,MONSTR
	SETZ	F,		;IF ILL MEM REF, DON'T PRINT ADDRESS CHECK.
	XCTBU	<SKIPL JOBEXM>
	XCTBU	<AOS JOBEXM>
	XCTBU	<HRRZS JOBEXM>
	SKIPGE	P2		;LOC TYPED?
	XCTBU 	<HRRZ P2,JOBEXM> ;NO. USE JOBEXM
	XCTBU	<MOVEM P1,(P2)>	;STORE VALUE
	XCTBU <HRRM P2,JOBEXM>  ;STORE NEW ADDRESS
	PUSHJ	P,TTYFUW	;GET STUFF FOR TTY TO PRINT THE PERIOD.
	PJRST	PRPER




;"SCHEDULE OCTN" - SETS RH OF STATES TO OCTN, IF TYPED FROM
; THE OPERATOR CONSOLE (C(DEVOPR)), OTHERWISE ILLEGAL
;"SCHEDULE" WITH NO ARGUMENT TYPES OUT RH OF STATES, LEGAL FOR ALL.

	EXTERN STATES,SETSHT,DWNFLG
	INTERNAL SKDCOM

SKEDUL:	PUSHJ	P,OCTIN1	;GET THE ARGUMENT IF ANY
	JRST	SKED1		;NO ARGUMENT
	JRST	COMERA		;BAD SYNTAX IN OCTAL NUMBER
	MOVEI T1,LICOPR
	TDNN T1,JBTLIC(J)
	JRST	COMERR		;NO. THIS IS ILLEGAL, THEN.
	SKIPE DWNFLG
	POPJ P,		;IGNORE IF TAKING DOWN
	PUSHJ	P,SKDCOM
	JRST	COMERR
	POPJ	P,

EXTERN SRPNDS,STRBTS
SKDCOM:	MOVEI	T1,SRPNDS	;IF DSKCLN NEEDS TO BE RUN,
	TDNN	T1,STRDDB+STRBTS ;
	JRST	SKDCM2		;
	TRNE	T2,STSUPR	;TRYING TO CLEAR SHUT
	TRNN	T2,STSHUT	;IS A NO-NO.
	POPJ	P,
SKDCM2:	MOVEI T1,ALRSCH		;IN CASE NEED TO SET ALARM CELL
	HLL T2,STATES		;GET CONSTANT PART
	TLZE T2,1		;RESET INITIALIZE BIT
	IORM T1,ALR620		;AND SEND ALARM THAT RESET
	EXCH T2,STATES	;SAVE OLD FOR CHANGE COMPARE
	XOR T2,STATES
	TRNE	T2,STSHUT	;CHECK UP-SHUT BIT
	PUSHJ	P,SETSHT	;CHANGED, CALL SCNSER TO SET
	JRST	CPOPJ1

SKED1:	HRRZ	T1,STATES	;SCHEDULE WITH NO ARGUMENTS.
	PUSHJ	P,OCTPNT	;PRINT RH OF STATES.
	JRST	CRLF		;AND RETURN WITH A CRLF
;"BLANK" OR NO ALPHA NUMERIC BEFORE BREAK CHAR COMMAND
;DISPATCHED TO LIKE ANY OTHER COMMAND(O IN COMMAND TABLE)

CBLANK:	SKIPN T3,TTCMCH		;GET BACK CHARACTER CAUSING BRK
	POPJ P,		;NULL ENTIRELY
	CAIE T3,12		;WAS BREAK A LINEFEED?
	CAIN T3,";"		;NO, IS IT SEMI COLON(MONITOR COMMENT)
	POPJ P,		;YES, IGNORE
				; FALL IN UNKNOWN COMMAND

;COMMAND NOT IN COMMAND DIRECTORY

NOCOM:	JRST COMERR	;NO, APPEND ? TO WHAT HE TYPED IN


;TTY [DEV[:]] [NO] WORD	;SETS OR CLEARS BITS IN LDBDCH FOR TTY U
;DEV ARGUMENT LEGAL ONLY IF ASSIGNED TO YOU AOR YOU ARE OPR

EXTERN LDBDCH

TTYCMD:	PUSH P,U			;SAVE TYPING TTY'S LDB
	HRRZ P1,U			;ASSUME HIS WILL BE OBJECT
	PUSHJ P,CTEXT1			;GET AN ARGUMENT
	CAIE T3,":"			;DEVICE?
	JRST TTYC1			;NO. A WORD.
	MOVE T1,T2			;GET THE DEVICE.
	PUSHJ P,TTYPHY			;AND FIND OUT WHERE IT IS
	  JRST TTYCE			;NOT A TTY. ERROR.
	HRRZ P1,U			;STORE AS OBJECT OF COMMAND
	MOVE U,0(P)			;RESTORE LDB FOR TYPER
	PUSHJ P,SKIPS			;DISCARD THE COLON
	  JRST TTYCE			;SHOULDNT BE END OF U
	HRRZ T1,U			;SEE IF THIS IS OPR
	CAIE T1,0(P1)			;MODIFYING OWN TTY?
	JRST TTYCE		;NO, ERROR AT LEAST FOR NOW
TTYCL:	MOVE U,0(P)			;RESET U TO TYPER
	PUSHJ P,SKIPS1			;SEE IF ANY MORE ON LINE.
	  JRST TTCEXI			;NO. DONE.
	PUSHJ P,CTEXT1			;YES. SEE WHAT IT IS
TTYC1:	PUSHJ P,SCNTCD		;CALL TTYCMD IN SCNSER
	 JRST TTYCL		;NEXT COMMAND
				;ERROR IS SKIP RETURN

TTYCE:	POP P,U			;RESTORE U FROM STACK
	JRST COMERR			;AND GO COMPLAIN.

TTCEXI:	POP P,U			;RESTORE U FROM STACK
	POPJ P,0			;AND RETURN TO COMCON

EXTERNAL SCNTCD,ALR620,OPRTIM


;SET COMMAND. MAY EVENTUALLY SET A VARIETY OF THINGS

SETCMD:	PUSHJ P,CTEXT1	;GET THING TO SET
	MOVE	T1,[-SETBLL,,SETBL]
	PUSHJ	P,TABSRC	;FIND A MATCH
	  JRST	COMERR		;NO GOOD
	MOVE T1,SETDSP(T1)
	JRST (T1)

TABSRC:	MOVE T3,T2	;COPY
	PUSH	P,T1	;SAVE ORIGINAL AOBJN POINTER TO COMPUTE INDEX.
	SETO	T4,	;MASK
	SETZ	S,
	LSH	T4,-6
	LSH	T3,6		;AT LEAST 1 CHAR
	JUMPN	T3,.-2
TABFLP:	MOVE	T3,(T1)	;GET NEXT ITEM.
	CAMN	T2,T3	;EXACT MATCH
	JRST	TABFND	;YES
	TDZ	T3,T4
	CAME	T2,T3	;MASKED MATCH
	JRST	TABNEQ	;NO.
	TROE	S,1	;YES. 1 MEANS SAW ONE, 3 MEANS SAW TWO.
	TRO	S,2	;SAW TWO
	HRL	S,T1	;SAVE LAST INDEX IN LH OF S.
TABNEQ:	AOBJN T1,TABFLP	;SEARCH FOR MATCH
	TRNN	S,2	;IF SAY TWO OR
	TRNN	S,1	;ZERO,
	JRST	TPOPJ	;GET GARBAGE OFF STACK AND RETURN.
	HLRZ	T1,S	;OK, GET INDEX.
TABFND:	POP	P,T3	;GET ORIGINAL POINTER
	TLZ	T3,-1	;JUST ADDRESS
	SUB	T1,T3	;COMPUTE INDEX
	JRST	CPOPJ1	;AND RETURN.

	DEFINE SETCMS
<	X OPR,SETOPR,LICOPR
	X NOTOPR,SETNOP,LICJAL
	X DATE,SETDAT,LICOPR
	X TIME,SETTIM,LICOPR
	X LOGOUT,SETLOG,.PVHKJ
	X DETACH,SETLOG,.PVHDT
	X CONTIN,SETLOG,.PVHCN
	X TIMOUT,SETLOG,.PVHTM
	X HAPPY,SETHAP,LICOPR
	X LIMIT,SETLIM,0
	X SCHPRV,SETSPR,LICJAL
	X CLRSPR,CLRSPR,0
	X WSMAX,SETWSL,0
	X NOATT,SNOATT,0
	X ATTACH,SETATT,0
	X LOCK,SETLOK,LICWCR
	X NOLOCK,CLRLOK,0
	X AUTOLO,SETAUT,0
	X NOAUTO,CLRAUT,0
>

	DEFINE X (A,B,C)
<	<SIXBIT /A/>>

SETBL:	SETCMS

SETBLL==.-SETBL

	DEFINE X (A,B,C)
<	XWD C,B>

SETDSP:	SETCMS

SETOPR:	PUSHJ P,CKSLC
	HRRZ T1,LDBDDB(U)	;MUST BE ATTACHED
	JUMPE T1,COMERR
COMSOP:	MOVE T1,DEVNAM(T1)
	MOVEM T1,DEVOPR
	HRRZM U,OPRLDB
	PUSHJ P,OPRFRE
	SETZM OPRTIM	;NO MORE TIMING NEEDED
	MOVEI T1,ALROPR
	ANDCAM T1,ALR620	;TURN OFF ALARM BIT
	POPJ P,


SETNOP:	;AAA JUL 77  UN-SET OPR
	PUSHJ P,CKSLC
	HRRZ T1,LDBDDB(U)
	JUMPE T1,COMERR
	HRRZ T1,U
	CAME T1,OPRLDB
	JRST COMERR	;CANT UN-SET IF NOT THE CURRENT OPR
	SETZM DEVOPR
	SETZM OPRLDB
	PUSHJ P,OPRFRE	;UNWAIT OPR SETUUO WAITERS
	MOVEI T2,^D90
	MOVEI T1,STSHUT
	TDNN T1,STATES
	MOVEM T2,OPRTIM		;SET 90 SEC TIMEOUT IF NOT SHUT
	POPJ P,
SETDAT:	PUSHJ P,CKSLC
	PUSHJ P,DECIN
	 JRST NOTENF
	 JRST COMERR
	MOVEI P2,-1(T2)
	IMULI P2,^D31
	PUSHJ P,DECIN
	 JRST NOTENF
	 JRST COMERR
	ADDI P2,-1(T2)
	PUSHJ P,DECIN
	 JRST NOTENF
	 JRST COMERR
	SUBI T2,^D1964
	IMULI T2,^D31*^D12
	ADD T2,P2
	PUSHJ P,COMDAS
	 JRST COMERR
	POPJ P,

	EXTERNAL COMDAS

COMMENT ! SETWSL - SET WORKING-SET MAXIMUM. INIT'ZD TO 512 ON LOGIN
NOTE: THIS SET COMMAND REFERS TO CONTEXT PAGES, HENCE
	SET COMMAND AS A WHOLE NEEDS INCOR ON IN COMCON DISPATCH
EXPECTS: J/JOB
DESTROYS T1-T4
!

SETWSL:
	PUSHJ P,MAPUPS	;GET %UPS & FREINDS SETUP. TAKES J/JOB
	PUSHJ P,DECIN	;GET T2/NUMBER, T3/TERM CHAR
	JRST COMERA	;NO NUMBER
	JRST COMERA	;ILLEG DECIMAL CHAR
	CAILE T3," "	;THIS COMMAND ASSUMES PAGES
	CAIN T3,"P"	;UNLESS THE USER SAYS "K"
	JRST SWSL1
	CAIE T3,"K"
	JRST COMERA	;DIDNT SAY K,P OR BLANK
	LSH T2,1	;CONVERT K TO PAGES
SWSL1:	CAIL T2,3	;CANT SET BELOW 3 ELSE SYTEM CAN HANG
	CAILE T2,^D512	;IN I/O BLTS, ETC.
	JRST SWSL2
	DPB T2,USYUWM	;CONSOLE-SETTABLE MAX
	LDB T3,USYUWL	;PROGRAM-SETTABLE LIMIT
	CAMLE T3,T2	;SKIP IF PROGRAMMABLE LIMIT OK.
	DPB T2,USYUWL	;GOTTA CUT IT DOWN TO MAX
	POPJ P,

SWSL2:	JSP T1,ERRMES	;BE NICE, GIVE HIM A MESSAGE
	ASCIZ /?size too big or too small/


EXTERNAL JBTLIM,OPRFRE,CTYBLF

SETHAP:	PUSHJ P,CKSLC
	MOVEI T1,ALROPR
	ANDM T1,ALR620		;TURN OFF ALL BITS BUT OPR ALARM
	SETZM CTYBLF	;AAA JAN 77. STOP CTY BELLS
	POPJ P,

SETLIM:	PUSHJ P,DECIN		;GET A NUMBER FOR TRU LIMIT
	 JRST NOTENF
	 JRST COMERR
	IMULI T2,^D10000	;CONVERT TO INTERNAL FORM
	MOVEM T2,JBTLIM(J)
	POPJ P,

EXTERN	JBYLIM,JBLMSK

SETAUT:	PUSHJ	P,DECIN		;GET A NUMBER FOR INACTIVITY TIMEOUT
	 JRST	NOTENF		;NO PARAMETER
	 JRST	COMERR		;BAD PARAMETER
	SETCMI	T1,JBLMSK
	TDNE	T2,T1		;LIMIT TOO BIG?
	JRST	COMERR		;YES
	DPB	T2,JBYLIM	;SET LIMIT
	POPJ	P,

CLRAUT:	MOVEI	T1,0
	DPB	T1,JBYLIM	;TURN OFF INACTIVITY TIMEOUT
	POPJ	P,

CKSLC:	HLRZ T2,T1	;GET REQUIRED LICENSE
	TDNE T2,JBTLIC(J)	;DOES HE HAVE IT?
	POPJ P,		;YES
	POP P,T2	;GET RID OF EXTRA CALL
	JRST COMERR	;AND TAKE AN ERROR

SETLOG:	HLRZ T2,T1	;GET BITS TO SET
	LSH T2,<^D35-PVNHNG>
	IORM T2,JBTPRV(J)	;SET ONES THAT SHOULD BE ON
	TRC T2,PVMHNG
	ANDCAM T2,JBTPRV(J)	;AND RESET THOSE THAT SHOULD BE OFF
	POPJ P,

;  SET OR CLEAR SPECIAL PRIVILEGES

SETSPR:	PUSHJ P,CKSLC
	MOVEI T1,SCHPRV
	ORM T1,JBTSTS(J)
	POPJ P,
CLRSPR:	MOVEI T1,SCHPRV
	ANDCAM T1,JBTSTS(J)
	POPJ P,

EXTERNAL LOKJOB

SETLOK:	PUSHJ P,CKSLC
	MOVEM J,LOKJOB
	POPJ	P,

CLRLOK:	CAME	J,LOKJOB
	JRST	COMERR
	SETZM	LOKJOB
	POPJ	P,

SETATT:	MOVSI	T1,PVNOAT	;TURN OFF NO ATTACH BIT
	ANDCAM	T1,JBTPRV(J)
	POPJ	P,

SNOATT:	MOVSI	T1,PVNOAT	;TURN ON NO ATTACH BIT
	IORM	T1,JBTPRV(J)
	POPJ	P,



;ADRBRK COMMAND. "ADRBRK <ADDRESS> <READ> <WRITE> <FETCH> <NONE> <MONITO> <ALL>"
IFNCPU (KL),<
SETABK:	JRST	COMERR>		;ERROR ON KI10 MONITORS.
IFCPU (KL),<;ONLY FOR KL PEOPLE - LITES ON KI SCARE OPRS.
	AB.RED==(1B10)
	AB.WRT==(1B11)
	AB.FET==(1B9)
	AB.USR==:(1B12)

EXTERNAL UPTABK,ABKSET

ABKTAB:	SIXBIT/READ/
	SIXBIT/WRITE/
	SIXBIT/FETCH/
	SIXBIT/NONE/
	SIXBIT/ALL/
	SIXBIT/MONITO/
ABKLEN==.-ABKTAB

ABKINS:	TLO	P1,AB.RED
	TLO	P1,AB.WRT
	TLO	P1,AB.FET
	SETZ	P1,
	TLO	P1,AB.RED+AB.WRT+AB.FET ;ALL
	JSP	T3,MONABK	;MAKE SRE ALL IS OK.


SETABK:	PUSHJ	P,OCTIN		;GET ADDRESS
	  JRST	PRTABK		;PRINT ADDRESS BREAK.
	  TDZA	P1,P1		;CLEAR P1, NO ADDRESS TYPED.(FOR NONE)
	MOVE	P1,T2		;SAVE ADDRESS.
	TLO	P1,AB.USR	;ASSUME USER.
	PUSHJ	P,CTEXT1	;GET FIRST THING
	  JUMPE	T2,[TLO P1,AB.RED+AB.WRT+AB.FET ;ASSUME ALL
		    JRST SETABD]	;DO IT THIS WAY.
	MOVE	T1,[-ABKLEN,,ABKTAB]
	PUSHJ	P,TABSRC	;GET MATCH
	  JRST	COMERR		;NO GOOD.
	XCT	ABKINS(T1)	;DO IT TO IT.
SETABL:	PUSHJ	P,CTEXT1	;DON'T HAVE TO GIVE ARGS NOW.
	  JUMPE	T2,SETABD	;DONE.
	MOVE	T1,[-ABKLEN,,ABKTAB]
	PUSHJ	P,TABSRC	;GET MATCH
	  JRST	COMERR		;NO GOOD.
	XCT	ABKINS(T1)	;DO SOMETHING TO P1
	JRST	SETABL		;GO FOR MORE.

SETABD:	PUSHJ	P,MAPUPS	;GET UPT IN %UPS
	MOVEM	P1,%UPS+UPTABK	;STORE
	TLNE	P1,AB.USR	;IF USER, RETURN NOW.
	POPJ	P,		;AND RETURN.
	MOVE	T1,ABKSET	;GET INSTRUCTION
	CAME	T1,[DATAO APR,%UPT+UPTABK] ;IF PATCHED OUT,
	DATAO	APR,P1		;MAKE IT TAKE EFFECT NOW
	MOVEM	P1,ABKMON	;REMEMBER LAST ONE DONE.
	POPJ	P,		;RETURN.

MONABK:	MOVSI	T1,LICWCR
	PUSHJ	P,CKSLC		;NEVER COME BACK IF NOT.
	TLZ	P1,AB.USR	;HAS WC IN JOB, LET HIM BREAK IN MONITOR.
	JRST	(T3)		;AND RETURN FROM JSP T3,

PRTABK:	PUSHJ	P,MAPUPS	;GET UPTABK IN %UPS
	MOVE	P1,%UPS+UPTABK	;GET INTO PERMANENT PLACE
	MOVEI	T1,[ASCIZ/NONE/]
	TRNN	P1,-1		;ANY AT ALL
	JRST	CONMES		;NO, PRINT NONE AND RETURN
	MOVEI	T1,[ASCIZ/AT /]
	PUSHJ	P,CONMES
	HRRZ	T1,P1
	PUSHJ	P,OCTPNT
	MOVEI	T1,[ASCIZ/(EXEC)/]
	TLNN	P1,AB.USR
	PUSHJ	P,CONMES
	MOVEI	T1,[ASCIZ/ READ/]
	TLNE	P1,AB.RED
	PUSHJ	P,CONMES
	MOVEI	T1,[ASCIZ/ WRITE/]
	TLNE	P1,AB.WRT
	PUSHJ	P,CONMES
	MOVEI	T1,[ASCIZ/ FETCH/]
	TLNE	P1,AB.FET
	PJRST	CONMES
	POPJ	P,
>;END IFCPU (KL)

ABKMON::0			;CONTAINS LAST ADDRESS BREAK SETTING FOR MONITOR.
IFCPU (KL),<
;SET ADDRESS BREAK UUO.

ABKUUO::JUMPE	T1,ABKUU1	;ZERO MEANS CLEAR.
	TLNE	T1,AB.USR	;IF MONITOR, CHECK LICENSE
	JRST	ABKUU1
	MOVSI	T2,LICWCR	;NEED WC TO DO IT
	TDNN	T2,JBTLIC(J)
	POPJ	P,		;NO PRIVS
ABKUU1:	EXCH	T1,%UPT+UPTABK	;SET NEW SETTING
	XCT	ABKSET		;MAKE IT GO INTO EFFECT
	UMOVEM	T1,(W)		;RETURN OLD SETTING
	JRST	CPOPJ1		;AND RETURN.
>;END IFCPU (KL)

IFNCPU (KL),<XP ABKUUO,CPOPJ>	;UNIMPLEMENTED ON KI


; "FINISH DEVICE" - CLOSES,RELEASE AND DEASSIGNS DEVICE
;JOB MUST HAVE CORE

	EXTERNAL HOLD,CLOSE0,RELEAX
CFINI:	TDZA T2,T2	;ZERO FOR FINISH
CLSCOM:	MOVNI T2,1	;NEGATIVE FOR CLOSE
	PUSHJ	P,MAPUPS
	MOVEM	T2,%UPS+UPTXAC+F	;SAVE FLAG IN EXEC AC F
	PUSHJ P,CTXDEV
	HRLS T1,JBTLIC(J)
	HRLM T1,JBTSLC(J)
	SETZM %UPS+UPTPID
	SETZM %UPS+UPTSPD	;CLEAR PID AND SAVED PID
	JUMPE T2,FINALL
	MOVE T1,T2		;SEARCH FOR SIXBIT DEVICE NAME
				; DO A FINISH SYS COMMAND FOR HIM
	PUSHJ P,DEVSRC
	JRST NOTDEV		;PRINT NOT A DEVICE
	HRRM F,%UPS+UPTXAC+F	;STORE DDB ADR. IN JOB DATA AREA
	MOVE U,-1(P)		;RESTORE TTY U DATA BLOCK
	JSP T2,MSTART		;SETUP MONITOR JOB AND RETURN
				; RETURN HERE AT M LEVEL WHEN SCHEDULED
	JSP T1,MONSTR		;SETUP ACS,R,R,P
	PUSHJ P,CFIN
	JRST CFINIX	;DDNE

CFIN:	UMOVEM F,JOBFDV
CFIN1:	MOVE W,%UPT+UPTHCU	;HIGHEST USER IO CHANNEL IN USE
FDV1:	HRR F,%UPT+UPTJDA(W)	;GET NEXT DEVICE
	XCTBU <HLL F,JOBFDV>
	MOVEI M,0
	MOVEI T1,RELEAX		;SET UP TO CALL RELEASE
	SKIPG F
	MOVEI T1,CLOSE0		;JUST CLOSE
	DPB W,PUUOAC		;WITH CHANNEL NO.
	PUSH P,W
	XCTBU <CAMN F,JOBFDV>	;IS THIS DEV. THE ONE TO RELEASE?
	PUSHJ P,(T1)		;YES, RELEASE IT(AND CLOSE)
	POP P,W
	SOJGE W,FDV1		;FINISHED?
	MOVE J,JOB		;GET JOB NUMBER
	XCTBU <SKIPL F,JOBFDV>	;RESET F
	PUSHJ P,DEASG		;DEASSIGN DEVICE
	JFCL			;IGNORE IF NOT ASSIGNED BY CONSOLE
	POPJ P,

;HERE TO FIN ALL DEVICES JOB OWNS
FINALL:	JSP	T2,MSTART	;SETUP MONITOR JOB, RETURN AT UUO LEVEL
	JSP	T1,MONSTR	;SETUP R, R,P
	UMOVEM F,JOBFDV		;SO LEFT HALF IS SAVED FOR CLOSE OR FIN
	HLRZ	F,DEVLST	;START OF DDB CHAIN
FINAL1:	LDB	T1,PJOBN	;JOB WHICH OWNS DEVICE
	XCTBU <HRRM	F,JOBFDV>;SAVE DDB ADDR IN CASE CFIN IS CALLED
	CAMN	T1,JOB		;THIS JOB OWN DEVICE?
	PUSHJ	P,CFIN1		;YES, FIN (OR CLOSE) IT
	HLRZ	F,DEVSER(F);SKIP TO NEXT DDB IN CHAIN
	JUMPN	F,FINAL1	;TEST IT IF NON-0
CFINIX:	PUSHJ	P,TTYFNU	;DONE. FIND TTY LINE FOR JOB
	PJRST	HOLD		;STOP JOB


;"RESOURCES" - PRINT OUT AVAILABLE DEVICES AND FREE BLOCKS ON THE DISK

FREDEV:

	EXTERN	DSKRES
	PUSHJ	P,DSKRES	;PRINT DISK INFO

	HLRZ W,DEVLST	;GET DDB POINTER
	MOVEI P2,0		;SET DEVICE NAME 0 FOR FIRST COMPARE
LOP01:	MOVE T1,DEVMOD(W)	;DEVICE CHARACTERISTICS
	TRNN T1,ASSCON!ASSPRG	;DEVICE ASSIGNED BY CONSOLE OR PROGRAM?
	TLNE T1,DVTTY!DVDSK!DVRMT	;NO, IS IT A TTY OR DSK?
	JRST LOP02		;YES DO NOT PRINT
	HLRZ T1,DEVNAM(W)	;GET NAME OF NEXT DEVICE IN CHAIN
	CAIN T1,(SIXBIT /PTY/)	;A PSEUDO TELETYPE?
	JRST LOP02		;YES. DONT MENTION IT.
	JUMPE P2,LOP01B	;SUPPRESS LEADING COMMA
	PUSHJ P,INLMES	;PRINT ,(INSTEAD OF CRLF SO WILL FIT IN 1 BUFFER)
	ASCIZ /,/
LOP01B:	MOVS P1,DEVNAM(W)	;GET DEVICE NAME
	HLLZ T2,P1		;ASSUME SAME TYPE AS LAST ONE, PRINT
				; ONLY RH OF NAME (UNIT NUMBER)
	CAIN P2,0(P1)		;IS IT REALLY THE SAME?
	JRST LOP01A		;YES. PRINT THE UNIT NUMBER.
	MOVS T2,P1		;NO. MUST PRINT WHOLE NAME,
	HRRZ P2,P1		; AND GET THE NEW DEVICE IN FLAG AC.
LOP01A:	PUSHJ P,PRNAME	;AS BEING FREE
LOP02:	HLRZ W,DEVSER(W)	;GET NEXT DEVICE IN CHAIN
	JUMPN W,LOP01	;IS THERE ONE?
	JRST CRLF		;NO. DONE. PRINT CR, LF AND THEN POPJ

;ROUTINE TO DELAY A COMMAND

;DELAYS COMMAND TO BE EXECUTED WHEN JOB IN CORE MEMORY
;AND CAUSES JOB TO BE SWAPPED IN(COMMAND WAIT BIT IS SET IN JBTSTS)
;AND POPS LEVEL UP ONE.


DLYCM:	PUSHJ	P,DLYCOM	;SET COMMAND WAIT BIT IN JOB STATUS AND PUT 
				; JOB IN COMMAND WAIT QUEUE 
				; SO JOB IS NOT RUNNABLE ANY MORE
;ROUTINE TO DELAY A COMMAND IF A SWAP OUT OR IN IS IN PROGRESS
;DIFFERS FROM DLYCM IN THAT JOB IS NOT MADE TO BE SWAPPED IN
;REQUIRED FOR DELAYING COMMAND IF SYSTEM
;TAPE USER TYPES ^C (HALT COMMAND)

DLYCM1:	POP	P,T1		;Discard dispatch return address
	POP	P,T2		;Discard saved LDB address
	JRST	COMMAND		;Loop back to beginning of COMCON

SUBTTL	COMCSS - COMMON COMMAND SUBROUTINES

;ROUTINE TO RETURN NEXT ALPHANUMERIC STRING
; IN COMMAND U (SIXBIT)
;CALL:	PUSHJ P, CTEXT
; SIXBIT STRING RETURN LEFT JUSTIFIED IN AC T2

INTERNAL CTEXT,COMSOP
INTERNAL CTEXT1

CTEXT:	PUSHJ	P,SKIPS	;CALL HERE IF AT START OF U
	  JRST CTEXTA		;NOTHING THERE. MAYBE ^C.

CTEXT1:	PUSHJ P,SKIPS1		;SKIP LEAD SPACES,TABS,NULLS AND CLEAR T2
	  JRST CTEXTA		;NOTHING THERE.
	SKIPA W,[POINT 6,T2]
CTEX0:	PUSHJ	P,COMTYS	

	PUSHJ P, CTEX		;IS IT ALPHANUMERIC
	  POPJ P,0		;NO
	TRC T3,40		;CONVERT TO SIXBIT
	TLNE W,770000	;SIX CHARS YET?
	IDPB T3,W		;NO. BUILD WORD
	JRST CTEX0		;LOOP FOR MORE

CTEXTA:	CAIN T3,3		;CONTROL C?
	MOVSI T2,(SIXBIT /HAL/)
	POPJ P,0		;RETURN FROM CTEXT


;SCAN FOR ALPHANUMERIC CHAR IN T3
CTEX:	CAILE	T3,"Z"+40	;GREATER THAN LC Z?
	POPJ	P,0		;YES. NOT SIXBIT.
	CAIL	T3,"A"+40	;LOWER CASE LETTER?
	TRZ	T3,40		;YES. MAKE UPPER CASE.
	CAIL T3, "0"
	CAILE T3, "Z"	;LETTERS ARE LARGER THAN NOS.
	POPJ P,0	;NEITHER
	CAILE T3, "9"
	CAIL T3, "@"
	JRST CPOPJ1		;LETTER OR NUMBER RETURN
	POPJ P,0		;NOT-LETTER/NUMBER RETURN

CTXDEV:	PUSHJ P,CTEXT1		;GET A WORD
	CAIN T3,":"		;AND IF TERM IS A COLON,
	PUSHJ P,COMTYS		;DISCARD IT
	POPJ P,0		;RETURN FROM CTXDEV

COMTYS::	PUSHJ P,COMTYI	;IN SCNSER. PICK UP CHAR.
	CAIN T3,";"
	MOVEI T3,12		;TREAT ; AS EOL
	MOVEM T3,TTCMCH
	POPJ P,


;ROUTINE TO IGNORE LEADING SPACES, TABS,
;ALSO CLEARS T2
;CALL:	PUSHJ P,SKIPS1	;TO CONSIDER CURRENT CHARACTER
;	PUSHJ P,SKIPS		;TO DISCARD CURRENT CHARACTER
;NON-SKIP RETURN MEANS END OF U
;SKIP RETURN MEANS SOMETHING THERE, IN T3 AND TTCMCH

INTERNAL SKIPS1,SKIPS

EXTERN COMTYI

;ROUTINE TO IGNORE LEADING SPACES AND TABS. ALSO, CLEARS T2
;FOR USE BY ANYRIN AND CTEXT

SKIPS:	PUSHJ P,COMTYS			;DISCARD CURRENT CHARACTER
SKIPS1:	MOVEI T2,0		;CLEAR ANSWER FOR NUMERIC AND TEXT INPUTS
	MOVE T3,TTCMCH		;GET CURRENT CHARACTER
	CAIE T3,11		;TAB?
	CAIN T3,40		;OR SPACE?
	JRST SKIPS		;YES. DISCARD IT
	CAIL T3,40		;BREAK CHARACTER?
	AOS 0(P)		;NO. SKIP RETURN
	POPJ P,0		;RETURN.


;ROUTINE TO APPEND A "?" TO INPUT STRING AND SET AS OUTPUT
;CALLED FROM OCTIN, RETURNS TO SECOND LEVEL ON PDL
;CALL:	MOVE T1, BYTE POINTER TO LAST CHAR. IN INPUT STRING
;	PUSHJ P, COMERA

INTERNAL COMERA

COMERP:	POP P,0(P)		;REMOVE SUB. RETURN BEFORE CALLING COMERA
COMERA:	PUSHJ P,COMTYI		;SKIP ONE MORE CHARACTER

;ROUTINE TO TYPE ALL OF A COMMAND ACCEPTED, FOLLOWED BY
;A QUESTION MARK
;CALL:	PUSHJ P, COMERR

INTERNAL COMERR

EXTERN TRESCN,TSETBI,TTCMCA

COMERR:	PUSH	P,TTCMCA	;SAVE ERROR POSITION IN SCAN ON STACK
	PUSHJ	P,TRESCN	;BACK UP TO START OF COMMAND
	PUSHJ	P,PRQM	;TYPE ? FOR BATCH
COMERL:	PUSHJ	P,COMTYI	;GET A CHAR FROM COMMAND
	MOVE	T1,TTCMCA	;PASS BAD CHAR YET?
	CAMN	T1,0(P)	; ..
	JRST	COMER1		;YES
	PUSHJ	P,COMTYO	;NO. TYPE CHAR.
	JUMPN	T3,COMERL	;LOOP IF NOT OUT OF CHARACTERS

COMER1:	POP	P,T1		;REMOVE OLD POSITION FROM STACK
	PUSHJ	P,TSETBI		;CLEAR ANY MORE TYPEIN
	PUSHJ	P,PRQM	;APPEND ? TO ERRONEOUS WORD
	JSP	T1,ERRMES	;Drop into error message routine
	ASCIZ	/
/				; with CR-LF

;ROUTINE TO PRINT A COMMAND ERROR MESSAGE
;SAME CALL AS CONMES

INTERNAL ERRMES

ERRMES:
	TLOA	P3,ERRFLG	;Flag error and skip into CONMES

;ROUTINE TO PRINT CARRIAGE RETURN-U-FEED
;CALL:	MOVE U,LDB ADDRESS OF TTY
;	PUSHJ P,CRLF

INTERNAL CRLF

				; COMERR SKIPS TO HERE(SEE ABOVE)
CRLF:	MOVEI T1,[ASCII /
/]

;ROUTINE TO MOVE ASCII CHAR. STRING TO CONSOLE OUTPUT BUFFER
; CALL:	MOVE U,LDB ADDRESS OF TTY
;	MOVEI T1,  ADDRESS OF ASCII MESSAGE
;	PUSHJ P, CONMES
; STRING TERMINATED BY NULL
;CONMS1 - SAME CALLING SEQUENCE AS CONMES,EXCEPT LH IS BYTE POINTER

INTERNAL CONMES
EXTERNAL COMTYO

CONMES:	HRLI T1,440700		;FORM ASCIZ BYTE POINTER
	PUSH P,T1		;SAVE BYTE POINTER
CON0:	ILDB T3,(P)		;GET NEXT CHAR.
	JUMPE T3,TPOPJ		;IS IT NULL?(IF YES, DO POP T1, POPJ)
	PUSHJ	P,COMTYO	;NO, STORE TTY OUTPUT BUFFER
	JRST CON0		;KEEP GOING


;ROUTINE TO PRINT INLINE ASCIZ MESSAGE
;CALL:	PUSHJ P,INLMES
;	ASCIZ /THE MESSAGE/
;RETURN TO NEXT LOC AFTER MESSAGE

INTERNAL INLMES,PRPER

INLMES:	POP P,T1		;SETUP PRINT ADRESS FOR CONMES
	PUSHJ P,CONMES
	JRST 1(T1)		;RETURN TO NEXT LOC AFTER MESSAGE

;ROUTINE TO APPEND ? TO ERROR MESSAGE
;CALL	PUSHJ P,PRQM
;	RETURN

INTERNAL PRQM

PRQM:	MOVEI T3,"?"
	JRST COMTYO

;SUBROUTINE TO PRINT A SPACE

PRSPC:	MOVEI T1,[ASCIZ / /]
	JRST CONMES

;ROUTINE TO PRINT "TOO FEW ARGUMENTS"
;CALL:	MOVE U,BYTE POINTER
;	PUSHJ P,NOTENF

INTERNAL NOTENF

NOTENF:	JSP T1,ERRMES

ASCIZ /?too few arguments
/

;PRINT PERIOD (OR OTHER PROMPT) PLUS "[MAIL] WAITING" ETC.
;CALL:	PUSHJ P,PRPER

PRPER:	PUSH P,F
	JUMPE U,RELPR1		;IF NO LDB, NO DIDDLE MAIL WAITING
	HRRZ F,LDBDDB(U)	;U IS SET UP
	JUMPE F,RELPR1		;GIVE ".", CANT GET TTYDDB FOR
				;JOB NUMBER TO TEST MODE OR RESET PVMAIL
	LDB T1,PJOBN
	MOVEI F,PVMAIL		;IS MAIL WAITING?
	TDNN F,JBTPRV(T1)
	 JRST PRPER2
	ANDCAM F,JBTPRV(T1)	;TURN OFF BIT

	PUSH	P, T1		; SAVE JOB NUMBER
	LDB	T1,PVZMOD	;JOB IN T1, GET T1/HIS MODE
	CAIN	T1,JAPMOD	;DONT CALL IT MAIL IF JAPANESE
	 SKIPA	T1,[EXP [ASCIZ/opnotice waiting
/] ]
	  MOVEI	T1,[ASCIZ/mail waiting
/]
	PUSHJ P,CONMES
PRMW1:	POP	P, T1		; RESTORE JOB NUMBER

PRPER2:	HRLZI	F,PVNMAI	; [dws] (new) mail waiting?
	TDNN	F,JBTPRV(T1)	; [dws] bit on?
	  JRST	NOMLMS		; [dws] no
	ANDCAM	F,JBTPRV(T1)	; [dws] yes, turn bit off
	PUSH	P,T1		; [dws] save t1
	MOVEI	T1,[ASCIZ /[mail waiting]
/]
	PUSHJ	P,CONMES	; [dws] announce new mail
	POP	P,T1		; [dws] restore t1

NOMLMS:	LDB F,PVZMOD
	MOVE T1,PRMPT(F)	; GET PROMPT ADDRESS FROM (RH)
	JUMPN	F,NOTPDP	; PDP mode gets special check
	HRRZ	F,JBTLIC(J)	; Does user have any license set ?
	SKIPE	F		; If not, give usual dot prompt
	MOVEI	T1,[ASCIZ /!/]	; If so, give special prompt
NOTPDP:	POP P,F			; RESTORE F
	JRST CONMES		; TYPE ASCIZ AT (T1) AND POPJ

PRMPT:	[ASCIZ "."]	; PDP MODE
	[ASCIZ "-"]	; XEXEC MODE
	[ASCIZ "-"]	; JXEXEC MODE
	[ASCIZ "READY
"]			; SUDS (SIC) MODE

RELPR1:	POP P,F
RELPR::	JSP T1,CONMES
	 ASCIZ "."		; TYPE DOT FOR OTHER ROUTINES

EXTERNAL PVZMOD
JAPMOD==2



;ROUTINE TO DEASSIGN A DEVICE EXCEPT CONTROLLING TTY
;CALL:	MOVE F, DEVICE DATA BLOCK
;	MOVE J, JOB NUMBER
;	PUSHJ P, DEASG
;	 ERROR NOT PREVIOUSLY ASSIGNED
;	OK RETURN WITH DEVICE DEASSIGNED, EXCEPT CONTROLLING 
;		TELETYPE (LOGICAL NAME CLEARED)

EXTERNAL CPOPJ1,IPOPJ,IPOPJ1

DEASG:	LDB T1,PJOBN		;WAS DEVICE ASSIGNED TO THIS JOB?
	CAME T1,J
	 POPJ P,		;NO, RETURN
	PUSH P,J		;SAVE JOB NUMBER
	MOVSI T2,DVDIRI		;CLEAR DIRECTORY IN CORE BIT
	ANDCAB T2,DEVMOD(F)	;SET UP FOR TLNE , TOO
	SETZM DEVLOG(F)		;CLEAR LOGICAL NAME
	TLNE T2,TTYATC		;BUT DON'T DEASS CONTROLLING TTY
	 JRST IPOPJ1
	TRNE T2,ASSCON		;IS DEVICE ASSIGNED BY CONSOLE?
	 AOS -1(P)		;YES, DO OK RETURN
	MOVEI T2,ASSCON		;SETUP ASSIGNED BE CONSOLE BIT FOR RELEA6
	PUSHJ P,RELEA6		;CLEAR JOB NO. IN DDB IF DDB NOT NEEDED
	JRST IPOPJ		;RESTORE JOB NUMBER AND RETURN

;DEASTY--ROUTINE TO DEASSIGN ALL DEVICES EXCEPT CTRLING (ATTACHED) TTY
;CALL:	MOVE J, JOB NUMBER
;	PUSHJ P, DEASTY

DEASTY:	PUSH P,F		;SAVE TTY DDB ADDRESS
	HLRZ F,DEVLST		;SEARCH ALL DDB'S
DEA1:	PUSHJ P, DEASG		;TRY TO DEASSIGN IT
	 JFCL			;IGNORE IF CAN'T
	HLRZ F, DEVSER(F)
	JUMPN F, DEA1
	POP P,F			;RESTORE TTY DDB ADDRESS
	POPJ P,
 


;ROUTINES TO READ NUMBERS FROM COMMAND STRING
;CALL:	MOVE P4,DESIRED INPUT RADIX
;	PUSHJ P, ANYRIN
;	NO ARG. TYPED RETURN, T2=0
;	ILLEGAL CHARACTER RETURN
;	NORMAL EXIT	;AC T2 CONTAINS NUMBER
;SCAN STOPS ON FIRST CR,DASH,SPACE,OR TAB OR ILLEGAL CHAR.
;SKIPS LEADING SPACES AND TABS

INTERNAL OCTIN,OCTIN1,DECIN,DECIN1
EXTERNAL CPOPJ2

DECIN:	PUSHJ P,SKIPS		;SKIP CURRENT CHARACTER
	  POPJ P,0		;NOTHING LEFT
DECIN1:	MOVEI P4,12		;DECIMAL INPUT
	JRST ANYRIN

OCTIN:	PUSHJ P,SKIPS		;SKIP CURRENT CHARACTER
	  POPJ P,0		;NOTHING LEFT
	PUSHJ P,ANYR1
	 POPJ P,
	 JRST .+2
	 POPJ P,
OCTIN1:	MOVEI P4,10		;OCTAL INPUT
ANYRIN:	PUSHJ P,SKIPS1	;SKIP LEADING SPACES, TABS, NULLS
	  POPJ P,0		;NOTHING LEFT. RETURN.
OCT0:	CAIL T3,"0"		;IS CHARACTER .GE. A ZERO?
	CAIL T3,"0"(P4)	;AND WITHIN RADIX BOUNDS?
	JRST ANYR1		;NO. NOT A LEGAL DIGIT
	IMUL T2,P4		;YES. SCALE INPUT SO FAR
	ADDI T2,-"0"(T3)	;AND ADD IN THIS DIGIT
	PUSHJ P,COMTYS		;GET ANOTHER CHARACTER
	JRST OCT0		;AND LOOP FOR MORE.

ANYR1:	CAILE T3,40		;CHECK FOR LEGAL TERMINATORS
	CAIN T3,","		;USED IN VARIOUS ROUTINES
	JRST CPOPJ2		;OK
	CAIE T3,"["		;MORE
	CAIN T3,"]"		; ..
	JRST CPOPJ2		;OK.
	CAIN T3,"K"		;FOR "CORE 55K"
	JRST CPOPJ2
	CAIN T3,"P"		;OR "CORE 55P"
	JRST CPOPJ2
	CAIN T3,"-"		;HYPHEN?
	JRST CPOPJ2		;OK.
	JRST CPOPJ1		;NO GOOD. GIVE "BAD CHARACTER RETURN"


;GET PROJECT-PROGRAMMER NUMBERS
;CALL:	MOVE T1,INPUT BYTE POINTER
;	PUSHJ P,PJPGNO
;
;(P2)LH _ PROJECT NUMBER
;(P2)RH _ PROGRAMMER NUMBER
;(P2) = 0 IF NO [ ]'S TYPED
;THE TERMINAL ] IS OPTIONAL

PJPGNO::	MOVEI P2,0
	TLNE S,2		;SPECIAL FILE?
	MOVE P2,%UPS+UPTRPN	;YES. GET SPECIAL FILE PPN
	PUSHJ	P,SKIPS1
	 POPJ P,
	CAIE	T3,"["		;IS IT A "[" ?
	POPJ P,
	PUSHJ P,OCTIN		;GET FIRST ARG.-PROJ. NO.
	JRST COMERP		;NO ARG. GIVEN
	JRST COMERP		;ILLEGAL OCTAL CHARACTER GIVEN
	JUMPE T2,COMERP
	HRL P2,T2		;ENTER
	CAIN T3,","
	PUSHJ P,OCTIN		;GET SECOND ARG.-PROG. NO.
	JRST COMERP		;
	JRST COMERP		;
	JUMPE T2,COMERP
	HRR P2,T2		;ENTER
	CAIN T3,"]"		;IS USUAL ENDING A "]"?
	PUSHJ P,COMTYS	;YES, SKIP IT SO FINAL ] IS OPTIONAL
	JUMPL P2,COMERP
	POPJ P,		;RETURN TO CALL


;ROUTINE TO PRINT TIME AS HOURS,MINUTES,SECONDS, AND HUNDRETHS (NO CRLF)
;FORMAT IS HHMM:SS.HH, MM:SS, OR SS.HH IF HH AND MM ARE 0
;CALL:	MOVE T1,TIME		; IN JIFFIES(60THS,50THS OR MILLISECONDS)
;	PUSHJ P,PRTIME		; IF TOU WANT [H]H:MM:SS
;	PUSHJ P,PRTIM		; IF YOU WANT [[[H]H:]MM:]SS.HH
;SCALEING IS DONE USING THE FOLLOWING GLOBAL SYMBOLS DEFINED IN COMMON
;THUS ANY INSTALLATION MAY HAVE ANY RATE CLOCK

EXTERNAL JFYSEC

;JFYMIN=NO. OF JIFFIES(CLOCK TICKS) PER MINUTE
;JFYSEC=NO. OF JIFFIES PER SECOND

INTERNAL PRTIM

PRTIME:	TDZA	T2,T2		;*ENTRY FOR HH:MM:SS
PRTIM:	SETO	T2,		;*ENTRY FOR [[HH:]MM:]SS.HH
	PUSH	P,T2		; SAVE ENTRY FLAG
	IDIV	T1,JFYMIN	; FORM MINUTES
	PUSH	P,T2		; SAVE REMAINDER IN JIFFIES
	IDIVI	T1,^D60		; HOURS, MINUTES IN T1,T2
	SKIPE	-1(P)		;* NOTE: POSITION ON STACK OF FLAG!!!
	 JUMPE	T1,PR0		; SUPPRESS 0 HOURS (ONLY FOR PRTIM ENTRY)
	PUSHJ	P,RADX10	; PRINT "HH" OR "H" OR "0"
	PUSHJ	P,INLMES	; PRINT ":"
	ASCIZ	/:/
	SETO	T1,		; FLAG THAT WE PRINTED SOMETHING
PR0:	EXCH	T1,T2		; GET MINUTES - PUT FLAG INTO T2
	SUB	T2,T1		; SUBTRACT MINUTES FROM FLAG
	SKIPE	-1(P)		;*DO NOT SUPRESS 0 MINUTES UNLESS 0 HRS SUPP.
	 JUMPE	T2,PR1		;  IF NO MINUTES 0-0=0 ELSE (-1)-? = -N
	PUSHJ	P,PRT2		; PRINT "MM"
	PUSHJ	P,INLMES	; PRINT ":"
	ASCIZ	/:/
PR1:	POP	P,T1		; RESTORE SECONDS (IN JIFFIES)
	IDIV	T1,JFYSEC	; JIFFIES PER SECOND
	PUSHJ	P,PRT2		; PRINT SECONDS AS "SS"
	POP	P,T1		; RESTORE ENTRY POINT FLAG
	SKIPN	T1		;*SKIP IF WE WANT ...SS.HH
	  POPJ	P,		; ELSE RETURN
	PUSHJ	P,RELPR		; PRINT PERIOD
	MOVE	T1,T2		; NO OF JIFFIES(HUNDRETHS)
	IMULI	T1,^D100	; CONVERT TO HUNDRETHS
	IDIV	T1,JFYSEC	; (T1 * 100) / 60 = HUNDREDTHS OF A SEC.
PRT2:	MOVEI	T3,"0"		; BEGIN WITH A ZERO
	PUSH	P,T1		; SAVE T1 OVER I/O
	CAIGE	T1,^D10		; DO WE NEED A SECOND DIGIT?
	PUSHJ	P,COMTYO	; PUT LEADING 0 IF LESS THAN 10
	POP	P,T1		; RESTORE T1
	JRST	RADX10		; PRINT REST OF NUMBER


END
   
 H7