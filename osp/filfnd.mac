TITLE FILFND  HANDLE CORE TABLES FOR FILE OPERATIONS
;-AAA CHKNRD FIX FOR UFD WPJ RENAME

ENTRY FILFND
FILFND:
;EXTERNALS FROM OTHER PARTS OF THE MONITOR

EXTERNAL CBAVAL,CBREQ,CBSWT,CBWAIT,CPOPJ1,CPOPJ2,JBTFPN
EXTERNAL JBTLIC,JBTPPN,JBYRPT,JBYWPT,JOB,PJOBN,SAVE4,TPOPJ,JBTAUN
EXTERNAL TPOPJ1,CPOPJ

COMMENT ;@@MODULE FILFNX
@@PURPOSE HANDLE ALL MANIPULATION OF IN-CORE TABLES AND
DIRECTORY MANIPULATION FOR
FILE ROUTINES. HANDLES LOOKUP, ENTER, RENAME PROCESSES WHICH
DO NOT INVOLVE THE FORMAT OF THE UUO ITSELF
@@;

INTERNAL FREATB,CHKACC,RMVATB,SRCNAM,RELLOK,LOKPPB,NLKPPB
INTERNAL GIVCB1,GIVCBR,GUFBT,SRCFIL,LKDATB,GETCBR,DIRSRC,CHKPRV
INTERNAL TSTWRT,FNDDRB
;EXTERNALS IN COMMOD.MAC

EXTERNAL ACTPPN,MFDPPN,SYSPPN,SPLPPN,INDPPN
EXTERNAL CBADR,CBUSER
EXTERNAL MFDRIB

EXTERNAL ATBALP,ATBCNT,ATBDOR,ATBFNB,ATBLCW,ATBLNK,ATBMSC
EXTERNAL ATBPVW,ATBRIB,ATBSIZ,ATBSTS,ATBPID
EXTERNAL ATMCNT,ATPCRE,ATPDEL,ATPDIR,ATPNDL,ATPREN,ATPSUP,ATPUPD
EXTERNAL ATPALC
EXTERNAL ATYPRV

EXTERNAL CMBLNK,CMBNAM

EXTERNAL DEVDBL,DEVATB,DEVDRB,DEVRIB
EXTERNAL PIDACC
EXTERN DEVREL,DEVBLK ;*************

EXTERNAL DRBALC,DRBCNT,DRBFNB,DRBLNK,DRBLOG,DRBMXA,DRBNX
EXTERNAL DRBRIB,DRBSTS,DRBLOK,DRBNAM,DRBUNM
EXTERNAL DRMCNT,DRPLOG,DRPLOK,DRPNX,DRPMXC
EXTERNAL DRYPRV

EXTERNAL FNBATB,FNBDBL,FNBDRB,FNBEXT,FNBLNK,FNBLOK,FNBALT,FNBNX
EXTERNAL FNBRIB
EXTERNAL FNPLOK,FNPNX
EXTERNAL FNYUFP

EXTERNAL FNCAPP,FNCCPR,FNCCRE,FNCDEL,FNCEXC,FNCLOK,FNCRED,FNCUPD
EXTERNAL UFRXLK,UFRXRD,UFRXCR

EXTERNAL PTRLEN

EXTERNAL RIBALP,RIBLCW,RIBMSC,RIBMXA,RIBPVW,RIBQTF,RIBSIZ,RIBSLF
EXTERNAL RIBSTS,RIBUSD,RIBUNM,RIBPID,RIBALT
EXTERNAL RIPDIR,RIPNDL
EXTERNAL RIYPRV,RIBPFS,RIBLST,RBMASK,RBREAL,RELRB2,RELRIB

EXTERNAL SYSCOR,SYSDOR,SYSDRB

EXTERNAL UFDRIB,UFDNAM,UFDEXT,UFDSIZ,UFDLNK

EXTERNAL SAVE2,ATBMWC,ATMMWC,ATPMXU,ATPDUM,LM3SPT,LMPMXW
EXTERNAL LMPSUP,%UPT,UPTPID
EXTERNAL PCDTIM,SLOCRS
COMMENT ;
THE FOLLOWING INDICATIONS ARE USED IN COMMENTS:
% THE JOB HAS CB RESOURCE AT THIS POINT
+ THE JOB HAS DRBCNT INCREMENTED AT THIS POINT
! THE JOB HAS A BLOCK LOCKED AT THIS POINT
;

;EXTERNALS IN OTHER PARTS OF FILSER

EXTERNAL IOSRIB,%RIB.C,MAPRDL,UUOLUK,UUOREN,UUOENT,UUOUFD
EXTERN GIVPAG,FALAQA
EXTERNAL UUOMLK,MAPWTL,MAPRLS,%RB2.C,IOSRBE,MAPWLN
EXTERNAL GETER1,DIRFST,PRMCHK,DIRNXT,NCSERR,SNFERR
EXTERNAL RIBDIR,DIRBLK,MAPXCH,RIBCKD,%RB2.C,GETAPG,MAPWTL,IOSALC
EXTERNAL UFDATB		;FROM FILUUO, FILLS IN ATB FROM UFD ENTRY
EXTERNAL UUOIRE		;IGNORE RIB ERROR BIT SET BY RENAME CODE THAT CALLS SRCFIL
COMMENT ;@@SUBROUTINE LOKPPB
@@PURPOSE TEST AND SET DRPLOK BIT IN DIRECTORY BLOCK (DRB)
FOR LOGINN AND LOGOUT. USED TO AVOID HAVING TWO USERS MANIPULATING
THE DIRECTORY AT THE SAME TIME.
@@ENTRY P1 CONTAINS THE STRUCTURE NAME (MUST BE DSKB)
P2 CONTAINS THE PPN
@@ACCUM P1,T2,T3,P2,T1
@@TABLES DRB TABLES IN CORE (MAY CREATE NEW DRB BLOCK)
@@GLOBAL SYSDRB
@@ERRORS MAY EXIT TO SNFERR OR NCSERR IF WRONG FILE
STRUCTURE OR NO CORE TO CREATE NEW DRB RESPECTIVELY.
@@CALLS PPBBIT (SETS CB INTERLOCK)
GIVCBR,GIVCB1
@@EXIT NON-SKIP RETURN IF DPRLOK ALREADY SET
SKIP RETURN IF DRPLOK WAS NOT SET, IT IS SET NOW.
@@FUNCTION IF PPBBIT() NON-SKIP [TAKE ERROR EXIT SET BY PPBBIT]
	IF DRPLOK IS ON GO TO GIVCBR
	SET DRPLOK AND GO TO GIVCB1@@;

LOKPPB:	PUSHJ	P,PPBBIT	;GET L(UFB), BIT TO TEST
	 PJRST (P1)		;P1 SET FOR CORRECT ERROR RETURN
	TDNE	P2,DRBLOK(T2)	;% LOCKED?
	PJRST	GIVCBR		;% YES - NON SKIP RETURN
	ORM	P2,DRBLOK(T2)	;% NO. NOW IT IS
	PJRST	GIVCB1		;% GIVE UP CB AND SKIP-RETURN

COMMENT ;@@SUBROUTINE NLKPPB
@@PURPOSE RESET DRPLOK BIT IN DIRECTORY BLOCK (DRB)
@@ENTRY P1 CONTAINS THE STRUCTURE NAME P2 THE PPN
@@ACCUM P1,T2,T3,P2,T1
@@TABLES DRB TABLES
@@GLOBAL SYSDRB
@@ERRORS NONE, INCORRECT STR NAME OR NO FREE CORE IS NOT CONSIDERED
AN ERROR
@@CALLS PPBBIT,GIVCBR
@@EXIT NON-SKIP ONLY
@@FUNCTION IF PPBBIT() NON-SKIP [RETURN]
	CLEAR DRPLOK AND GO TO GIVCBR
@@;

NLKPPB:	PUSHJ	P,PPBBIT	;GET UFB, BIT TO CLEAR
	  POPJ	P,		;NOT AN STR NAME
	ANDCAM	P2,DRBLOK(T2)	;% CLEAR THE BIT
	PJRST	GIVCBR		;% GIVE UP CB AND RETURN

COMMENT ;@@SUBROUTINE PPBBIT
@@PURPOSE FIND A DRB AND RETURN A POINTER TO IT FOR LOKPPB AND NLKPPB
@@ENTRY P1 HAS STR NAME, P2 PPN
@@ACCUM P1,P2,T2,T3,T1
@@TABLES DRB TABLES
@@GLOBAL SYSDRB (NOT MODIFIED)
@@EXIT NON-SKIP RETURN IF NO CORE TO CREATE DRB OR STR NAME
INCORRECT. P1 SET TO ADDRESS OF APPROPRIATE ROUTINE
SKIP RETURN WITH T2 THE ADDRESS OF THE DRB AND P2 DRPLOK
@@ERRORS NOT ENOUGH CORE FOR DRB OR STR NAME NOT DSKB
@@CALLS SRCNAM,GETCBR,GIVCBR
@@FUNCTION  P1_@SNFERR
	IF STR#'DSKB' RETURN
	CALL GETCBR
	P1_@NCSERR
	IF SRCNAM(SYSDRB) NON-SKIP RETURN AND T2<0 (NO CORE)
		GO TO GIVCBR
	P2_DRPLOK
	SKIP-RETURN
@@;

PPBBIT:	MOVE	T1,P1	;STR NAME
	MOVEI P1,SNFERR		;ERROR RETURN, NOT F/S NAME
	CAME T1,[SIXBIT /DSKB/]	;ONLY ONE PERMITTED
	  POPJ	P,		;NOT AN STR
	MOVE	T1,P2		;PRJ-PRG
	PUSHJ P,GETCBR
	MOVEI P1,NCSERR		;ERROR RETURN, NOT ENOUGH CORE
	HLRZ	T2,SYSDRB	;% 1ST PPB IN SYSTEM
	MOVEI	T3,SYSDRB-CMBLNK	;% IN CASE THIS CREATES 1ST PPB BLOCK
	PUSHJ	P,SRCNAM	;% FIND PPB FOR THIS USER (MAY CREATE ONE)
	 JUMPLE T2,GIVCBR	;% CREATED ONE IF ENOUGH CORE
	MOVEI P2,DRPLOK		;% THE BIT TO USE
	PJRST	CPOPJ1		;% RETURN
COMMENT ;@@SUBROUTINE GUFBT
@@PURPOSE DETERMINE NUMBER OF BLOCKS LEFT IN QUOTA FOR A GIVEN
UFD
@@ENTRY NONE
@@ACCUM T2,T4
@@TABLES DRB TABLES,JBTPPN
@@GLOBAL SYSDRB,JOB
@@EXIT T2 CONTAINS THE REMAINING QUOTA. IF QUOTA IS UNKNOWN
(BECAUSE DRB BLOCK NOT FOUND) T2 CONTAINS 1B0
@@RESTRICTIONS MUST BE CALLED AT UUO LEVEL FOR THE CURRENT JOB
@@CALLS NONE
@@FUNCTION SEARCH DRB TABLE FOR DRB WITH NAM=JBTPPN(JOB)
	IF NOT FOUND RETURN (1B0)
	RETURN (DRBALC(DRB TABLE))
@@ ;

GUFBT:	MOVE	T2,JOB		;% T2=JOB NUMBER
	MOVE	T4,JBTPPN(T2)	;% GET PROJ-R # FOR THIS JOB
	MOVEI T2,SYSDRB-DRBLNK	;%READ TO LOOK AT FIRST DRB IN SYS
GUFBT1:	HLRZ	T2,DRBLNK(T2)	;% GET ADR. OF NEXT PPB
	JUMPE	T2,GUFBT3	;% NONE LEFT - RETURN WITH T2=0
	CAME	T4,DRBNAM(T2)	;% IS THIS PPB # SAME AS JOB'S?
	JRST	GUFBT1		;% NO - REPEAT
	SKIPA	T2,DRBALC(T2)	;% YES - GET # FREE + RESERVED BLOCKS LEFT IN THIS UFB
GUFBT3:	MOVSI	T2,400000	;% RETURN MOST NEGATIVE NUMBER IF NO UFB BLOCK
	POPJ	P,		;% GO DEPOSIT IT IN TABLE
SUBTTL	SRCFIL - MANIPULATE DIRECTORIES, ACCESS TABLES
;IN THIS MODULE P3=LOC OF FNB, P4=LOC OF DRB, P2=LOC OF ATB

COMMENT ;@@SUBROUTINE SRCFIL
@@PURPOSE DOES MANIPULATION OF CORE TABLES AND EXAMINATION
OF DIRECTORIES FOR LOOKUP, ENTER, AND RENAME.
@@ENTRY F POINTS TO DSK DDB, DEVFIL(F),DEVEXT(F), AND DEVPPN(F)
CONTAIN THE FILE NAME, EXTENSION, AND PPN DESIREC.
M HAS UUOLUK FOR LOOKUP, UUOENT OF ENTER OR UUOREN FOR RENAME.
ONLY ONE OF THESE MAY BE ON. M MAY HAVE UUOMLK FOR MULTIPLE LOOKUP.
@@ACCUM T1,T2,T3,T4
@@TABLES ALL IN-CORE TABLES (DRB, FNB, ATB) ARE USED AND POSSIBLY
MODIFIED.
@@GLOBAL SYSDRB,SYSCOR,SYSDOR
@@EXIT NON-SKIP RETURN ON ERROR, T1 CONTAINS ERROR CODE
SKIP RETURN IF OK, DEVACC(F) POINTS TO THE ATB. IOSRIB IN S
IS ON IF AND ONLY IF %RIB HAS THE FILE RIB IN IT (LOOKUP ONLY)
FOR MULTIPLE LOOKUP, DEVEXT(F) IS SET TO THE CORRECT EXTENION.
ERROR BITS MAY BE SET IF THERE WERE RIB ERRORS
@@ERRORS SEE EXIT CONDITIONS
@@RESTRICTIONS CALLED AT UUO LEVEL ONLY MAY WAIT FOR RESOURCES
@@CALLS GETCBR,GIVCBR,GIVCB1,SRCNAM,RELLOK,DIRSRC,LOKDIR
SETDDB,MAPRDL,PRMCHK,SRCAT,ULDATB,FREATB,GETCOR
@@ ;
SRCFIL:	JSP T4,SAVE4
	TLZ S,IOSRIB!IOSRBE!IO	;DO NOT HAVE RIB IN %RIB
	PUSHJ P,GETCBR	;FOR THE INITIAL DRB SEARCH
	HLRZ T2,SYSDRB		;%SEARCH FOR THIS DRB, FIRST IN T2
	MOVEI T3,SYSDRB-DRBLNK
	MOVE T1,DEVPPN(F)
	PUSHJ P,SRCNAM	;%SEARCH FOR THE APPROPRIATE NAME
	 JUMPLE T2,ERRNEC	;%COULD NOT GET FREE CORE TO CREATE
	MOVEI T3,DRPNX
	TDNE T3,DRBNX(T2)	;% DO WE KNOW ITS NOT THERE?
	JRST ERRIPP		;% YES, NO UFD
	MOVE P4,T2
	AOS T1,DRBCNT(P4)	;%+ NOW ANOTHER USING IT
	TRNE T1,DRPMXC		;%+ IS COUNT NOW TOO BIG (OVERFLOW)
	STOPCD(SLO)			;%+ YES
	SKIPE DRBRIB(P4)	;%+ DO WE KNOW WHERE IT IS?
	JRST DRBFND		;%+ YES, READY TO LOOK FOR FILE
	PUSHJ P,GIVCBR
	PUSH P,DEVFIL(F)	;+ SAVE NAME TO SET FOR DIR
	MOVE T1,DEVEXT(F)
	TLZN M,UUOMLK	;+ USE RH TO SAVE MLK BIT
	TRZA T1,-1
	TRO T1,-1
	PUSH P,T1
	MOVE T1,DEVPPN(F)
	MOVEM T1,DEVFIL(F)
	MOVE T1,MFDPPN
	MOVEM T1,DEVPPN(F)
	MOVSI T1,'UFD'
	HLLM T1,DEVEXT(F)
	MOVE T1,MFDRIB		;+ GET RIB POINTER FOR MFD
	PUSHJ P,DIRFST		;+ GET THE FIRST DIRECTORY BLOCK
	 JRST SRCNUF		;+ NONE THERE
SRCULP:	PUSHJ P,GETCBR		;+! NEED TO LOOK AT DRB IN CASE COMPLETED BY ANOTHER JOB
	MOVEI T1,DRPNX
	TDNE T1,DRBNX(P4)
	JRST SRCNU2		;%+! NOW KNOW ITS NOT THERE
	SKIPE DRBRIB(P4)
	JRST DRBFN1		;%+! SOMEONE ELSE FOUND IT
	PUSHJ P,GIVCBR
	PUSHJ P,DIRSRC		;+! NOW SEARCH. MUST GIVE UP CB IN CASE PAGE FAULT
	 JRST DRBFN2		;+! FOUND
	PUSHJ P,DIRNXT		;+! GO ON TO THE NEXT DIR BLOCK
	 JRST SRCNUF		;+! THAT WAS THE LAST
	JRST SRCULP		;+! FOLLOWES LINKED HASH FORMAT
;+ HERE ON END OF FILE FOR THE MFD

SRCNUF:	PUSHJ P,GETCBR
	SKIPE DRBRIB(P4)	;%+ WAS IT REALLY FOUND BY SOMEONE ELSE (OR CREATED)
	JRST DRBFN3		;%+ YES
	MOVEI T1,DRPNX
	IORM T1,DRBNX(P4)	;%+ MARK NON-EXISTANT
SRCNU1:	SOS DRBCNT(P4)
	POP P,T1
	HLLM T1,DEVEXT(F)
	TRNE T1,-1
	TLO M,UUOMLK	;%+ RESET BIOP P,T1
	EXCH T1,DEVFIL(F)
	MOVEM T1,DEVPPN(F)
	JRST ERRIPP		;% NO UFD

SRCNU3:	PUSHJ P,GETCBR		;+! HERE ON A RIB ERROR
SRCNU2:	PUSHJ P,RELLOK		;%+! NOW KNOWN NX
	JRST SRCNU1		;%+ CLEAN UP AND GIVE IPP ERROR

DRBFN2:	MOVE T1,%RIB+UFDRIB(T2)	;+! GET POINTER
	MOVEM T1,DEVRIB(F)	;+! SAVE IT
	PUSHJ P,RELLOK		;+! RELEASE CURRENT BLOCK
	MOVE T1,DEVRIB(F)	;+ MAP IN RIB FOR DIRECTORY
	PUSHJ P,MAPRDL
	PUSHJ P,PRMCHK		;+! DO A PRIME RIB CHECK
	 JRST SRCNU3		;+! RIB ERROR, SAY NO UFD
	PUSHJ P,GETCBR
	SKIPE DRBRIB(P4)	;%+! SOMEONE ELSE GOT IT
	JRST DRBFN1
	MOVE T1,%RIB+RIBSLF
	MOVEM T1,DRBRIB(P4)
	MOVE T1,%RIB+RIBQTF
	SUB T1,%RIB+RIBUSD
	MOVEM T1,DRBALC(P4)
	MOVE T1,%RIB+RIBQTF
	SUB T1,%RIB+RIBMXA
	MOVEM T1,DRBMXA(P4)
	DMOVE T1,%RIB+RIBUNM
	DMOVEM T1,DRBUNM(P4)
	LDB T1,RIYPRV
	DPB T1,DRYPRV
DRBFN1:	PUSHJ P,RELLOK	;%+! ALL SET UP NOW
DRBFN3:	POP P,T1		;%+
	HLLM T1,DEVEXT(F)
	TRNE T1,-1
	TLO M,UUOMLK	;%+ RESET BIT
	POP P,T1
	EXCH T1,DEVFIL(F)
	MOVEM T1,DEVPPN(F)
	TLZ S,IOSRBE	;FORGET ERROR FLAG
;%+ HERE WHEN WE HAVE A DRB ALL SET UP

DRBFND:	MOVEI T1,DRPLOG		;%+ GET READY TO MARK LOGGED IN (DO NOT GARBAGE COLLECT)
	MOVE T2,DEVPPN(F)
	MOVE T3,JOB
	CAME T2,JBTPPN(T3)
	CAMN T2,MFDPPN
	IORM T1,DRBLOG(P4)
	CAME T2,SYSPPN		;%+ SYS, MFD, SPOOLING ALWAYS SAVED
	CAMN T2,SPLPPN
	IORM T1,DRBLOG(P4)
	MOVE T1,DEVFIL(F)	;%+ SEARCH FOR THE FNB
	MOVEI T3,DRBFNB-FNBLNK(P4)	;%+ DOWN POINTER
	HLRZ T2,DRBFNB(P4)
	HLRZ T4,DEVEXT(F)		;%+ USE T4 FOR EXT
	PUSHJ P,SRCNAM		;%+ GO LOOK FOR IT
	 JRST CREFNB		;%+ NOT FOUND, SHOULD HAVE BEEN CREATED
SRCFNB:	HRRZ T3,FNBEXT(T2)	;%+ SAME EXT? (T3 NOT NEEDED NOW)
	TLNE M,UUOMLK		;%+ FOO MULTIPLE LOOKUP
	JRST SRCMFB		;%+ SPECIAL CODE REQUIRED
	CAMN T4,T3
	JRST FNDFNB		;%+ YES FOUND
SRCFN0:	PUSHJ P,SRCNM0		;%+ NO CONTINUE
	 JRST CREFNB
	JRST SRCFNB		;%+ CHECK NEXT

CREFNB:	JUMPLE T2,ERRNC1	;%+ NOT ENOUGH CORE TO CREATE FNB
	HRRM P4,FNBDRB(T2)	;%+ ALSO NEED DRB POINTER
	TLNE M,UUOMLK
	JRST CREMFB	;%+ NEED MULTIPLE FNB BLOCKS
	HRRM T4,FNBEXT(T2)	;%+ SAVE EXT
FNDFNB:	MOVE P3,T2		;%+ GET POINTER WHERE IT BELONGS
	TLNN M,UUOLUK		;%+ IS IT LOOKUP?
	JRST SRCENT	;%+ NO, DO ENTER CODE
	MOVSI T1,FNPNX
	TDNE T1,FNBNX(P3)	;%+ IS THE FNB FOR NX FILE?
	JRST ERRFNM		;%+ YES
	MOVEI T1,ATPDEL!ATPSUP
	MOVEI T3,ATPCRE!ATPREN	;%+ IGNORE DEL SUP, STOP ON CRE OR REN
	PUSHJ P,SRCAT		;%+ LOOK FOR ACCESS TABLE
	 JRST ERRFNM		;%+ ONE OF THE PROHIBITED AT ENTRIES
	 JRST ERRNC1		;%+ NO ROOM
	AOS ATBCNT(P2)		;%+ SET READ COUNT UP
	SKIPE ATBDOR(P2)	;%+ IF IT IS DORMANT
	PUSHJ P,ULDATB		;%+ REMOVE FROM DORMANT LIST
	TLNN M,UUOMLK
	JRST SRCLU1		;%+ NORMAL
	HRRM P3,1(T4)		;%+ SAVE P2 AND P3 IN CORE BLOCK
	HRLM P2,1(T4)
	HLRZ T4,DEVEXT(F)	;%+ RELOAD
	SOS (T4)		;%+ AND MARK ONE MORE FOUND
SRCLU1:	SKIPE ATBRIB(P2)	;%+ DO WE KNOW WHERE THE RIB IS
	PJRST SRCLK1	;%+ YES, DONE, GIVE UP CB AND SKIP
	SKIPE T1,FNBRIB(P3)	;%+ RIB KNOW IN FNB?
	JRST FILRIB		;%+ YES, MUST READ RIB TO SET AT
	TLNN M,UUOMLK
	JRST SRCLU2
	HRRZ T1,(T4)		;%+ SEE IF ANY WITH NO FNB
	JUMPE T1,SRCLU2
	MOVE T2,P3		;%+ YES, CONTINUE SEARCH
	MOVE T1,DEVFIL(F)
	JRST SRCFN0
CREMFB:	HLL T4,(T4)		;%+ NEED TO CREATE ANOTHER, GET COUNT
CREMF0:	MOVS P1,1(T4)
	TLNE P1,-1		;%+ RH (NO LH) 0 IF NO FNB YET
	JRST	[AOBJN T4,CREMF0	;%+ MORE
		STOPCD(SLO)
		]	;%+ ERROR IF OUT
	HRRM P1,FNBEXT(T2)	;%+ SAVE EXTENSION
	JRST FNDFNB		;%+ AND GO

SRCMFB:	HLL T4,(T4)		;%+ GET COOUNT TO SEARCH EXT
SRCMF0:	MOVS P1,1(T4)
	TLNN P1,-1
	CAIE T3,(P1)
	SKIPA			;%+ ALREADY FNB OR NO MATCH
	JRST FNDFNB		;%+ FOUND IT
	AOBJN T4,SRCMF0
	HLRZ T4,DEVEXT(F)	;RELOAD
	JRST SRCFN0		;%+ NONE MATCH, CONTINUE SEARCH

SRCDLM:	HLRZ T4,DEVEXT(F)	;%+! NEED TO CHECK ALL FNB'S
SRCDL0:	HLL T4,(T4)
SRCDM1:	MOVE T2,1(T4)		;%+! GET ATB FNB PNTR
	TDNE T1,FNBNX(T2)	;%+! NOW NX?
	JRST SRCDMD		;%+! YES, REMOVE
	SKIPE FNBRIB(T2)
	JRST SRCDMC		;%+! FOUND ONE
	AOBJN T4,SRCDM1
	JRST SRCDMR		;%+! JUST CONTINUE

SRCDMC:	HRRZ P3,T2
	HLRZ P2,T2		;%+! JUST LOAD POINTERS
	JRST SRCCFP		;%!+ AND GO

SRCDMD:	HRRZ P3,T2
	HLRZ P2,T2		;%+! LOAD POINTERS
	HLRZ T1,DEVEXT(F)
	HLRO T2,(T1)		;%!+ GET SET TO REMOVE
	MOVNS T2
	ADD T2,T1
	MOVE T3,(T2)
	MOVEM T3,1(T4)		;%+! REPLACE CURRENT WITH END
	MOVSI T2,1
	ADDM T2,(T1)		;%+! AND REDUCE COUNT
	SOS T1,ATBCNT(P2)	;%+! DEC COUNT ON DELETED ONE
	TDNN T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
	PUSHJ P,FREATB		;%+! MAY FREE IT
	HLRZ T4,DEVEXT(F)
	SKIPL (T4)
	JRST ERRFNF		;%+! RAN OUT, NO FILE
	MOVSI T1,FNPNX
	JRST SRCDL0		;%+! CONTINUE THE SEARCH
ERRFNM:	TLNN M,UUOMLK		;%+ IF NOT MULTIPLE LOOKUP, NO FILE
	JRST ERRFNF
	HLRZ T1,DEVEXT(F)
	HLRO T2,(T1)
	MOVNS T2
	ADD T2,T1
	MOVE T3,(T2)
	MOVEM T3,1(T4)		;%+ REPLACE CURENT WITH LAST
	MOVSI T2,1
	ADDB T2,(T1)
	JUMPGE T2,ERRFNF	;%+ ALL OUT, FORGET IT
	SOS T2,(T1)	;DECREMNT UNFOUND COUNT
	TRNN T2,-1
	JRST SRCLU2		;%+ ALL FOUND, GO
	MOVE T4,T1
	MOVE T2,P3
	MOVE T1,DEVFIL(F)
	JRST SRCFN0	;%+ GO ON

MULCLN:	TLZN M,UUOMLK		;% (AND POSSIBLY MORE)
	POPJ P,			;% NOTING EXCEPT FOR MULTIPL
	HLRZ T4,DEVEXT(F)	;% POINTER TO EXTENSION LIST
	HLL T4,(T4)		;% REMOVE ALL ATBS
	JUMPGE T4,CPOPJ		;% IN CASE ALL GONE ALREADY
	PUSH P,P3
	HRLM P2,(P)		;% SAVE FNB AND ATB PNTRS
SRCLL0:	MOVE T1,1(T4)
	TRNE T1,-1		;% NOTHING THERE
	CAIN P3,(T1)		;% OR SAME AS CURRENT
	JRST [HRRZ T1,FNBEXT(P3)	;SET EXTENSION FROM THIS
		HRLM T1,DEVEXT(F)
		JRST SRCLL1]
	HRRZ P3,T1
	HLRZ P2,T1
	SOS T1,ATBCNT(P2)
	TDNN T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
	PUSHJ P,FREATB		;% GET RID OF ATB
	HRRZ P3,(P)		;% FOR ABOVE CHECK
SRCLL1:	AOBJN T4,SRCLL0
	POP P,P3
	HLRZ P2,P3
	HRRS P3			;% JUST IN CASE
	POPJ P,
;%+ NOW SEARCH THE UFD FOR THIS FILE

SRCLU2:	MOVE T1,DRBRIB(P4)	;%+ GET POINTER TO UFD RIB
	PUSHJ P,GIVCBR
	PUSHJ P,DIRFST		;+ NOW GET FIRST DIRECTORY BLOCK
	 JRST SRCDEF
SRCDLP:	PUSHJ P,GETCBR
	MOVSI T1,FNPNX
	TLNE M,UUOMLK
	JRST SRCDLM
	TDNE T1,FNBNX(P3)	;%+! IS FILE NOW KNOWN NX?
	JRST SRCFNX		;%+! YES
	SKIPE FNBRIB(P3)	;%+! OR DO WE NOW KNOW RIB LOC?
	JRST SRCCFP		;%+! YES
SRCDMR:	PUSHJ P,GIVCBR		;%+! GIVE UP CB BEFORE FAULT ON PAGE
	PUSHJ P,DIRSRC		;+! LOOK FOR THE FILE NAME
	 JRST SRCDFD		;+! FOUND
	PUSHJ P,DIRNXT		;+! CONTINUE TO NEXT LINKED BLOCK
	 JRST SRCDEF		;+ EOF (BLOCK UNLOCKED)
	JRST SRCDLP		;+ TRY NEXT BLOCK

SRCFNX:	PUSHJ P,RELLOK	;%+! KNOWN NX, DON'T NEED DIR
	TLZ S,IOSRBE	;%+! FORGET ABOUT ANY ERROS SO FAR
SRCFN1:	SOS T1,ATBCNT(P2)	;%+ NOT GOING TO WANT ATB ANY MORE
	TLNN M,UUOLUK		;%+ LOOKUP DIFFERENT THAN ENTER-RENAME
	JRST SRCNX0		;%+ HANDLE ENTER AND RENAME
	TDNN T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]		;%+ ANY ONE ELSE USING THIS
	PUSHJ P,FREATB		;%+ NO, RETURN TO FREE STORAGE
	JRST ERRFNF		;%+ AND SAY NOT FOUND

SRCNX0:	MOVEI T1,ATPUPD		;%+ MUST RESET UPD ON ENTER-RENAME
	ANDCAM T1,ATBSTS(P2)
SRCENX:	TLNE S,IOSRBE
	JRST ERRTR1		;%+ SAY BAD TRANSFER
	MOVE T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
	TDNN T1,ATBCNT(P2)	;%+ ANYONE ELSE USING IT?
	JRST SRCNX1		;%+ NO, CAN USE THIS ATB
	PUSHJ P,GETCOR		;%+ YES, MAKE A NEW ATB
	JUMPLE T2,ERRNC1	;%+ IF THERE IS ROOM
	MOVE P2,T2
	PUSHJ P,LNKATB		;%+ LINK IT IN
SRCNX1:	MOVEI T1,ATPCRE		;%+ SET TO CRE
	TLNE M,UUOREN
	MOVEI T1,ATPREN		;%+ OR RENAME
	IORM T1,ATBSTS(P2)
	JRST SRCFNI		;%+ SET DEVATB AND DRB

SRCDEF:	PUSHJ P,GETCBR		;+ COME HERE ON EOF FOR UFD
	SKIPE FNBRIB(P3)	;%+ HAS SOMEONE ELSE FOUND IT
	JRST SRCCF1		;%+ YES, FINISH UP
	MOVSI T1,FNPNX
	TLNN S,IOSRBE		;%+ MAY HAVE JUST BEN ERROR. NOT NX
	IORM T1,FNBNX(P3)	;%+ NO MARK NX
	JRST SRCFN1		;%+ AND TREAT AS IF WE FOUND NX SET
SRCCFP:	PUSHJ P,RELLOK		;%+! HERE IF SOMEONE ELSE FOUND IT
SRCCF1:	TLNE M,UUOLUK
	JRST SRCLU1		;%+ FINISH LOOKUP
SRCSUP:	TLNE M,UUOREN
	JRST ERRFB1		;%+ RENAME NOT PERMITTED, GIVE ERR
	SKIPN ATBRIB(P2)	;%+ DO WE ALREADY HAVE RIB DATA?
	JRST FILRB1		;%+ NO, NEED PROTECTION ETC.
SRCSP0:	MOVEI T1,ATPUPD	;%+ HAVE RIB, RESET
	ANDCAM T1,ATBSTS(P2)
	SOS T1,ATBCNT(P2)
	TDNN T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]		;%+ ANYONE ELSE STILL USING IT?
	JRST SRCSP1		;%+ NO, WE CAN USE IT
	PUSHJ P,GETCOR		;%+ MUST GEN A NEW ONE
	JUMPLE T2,ERRNC1
	MOVE T1,ATBPVW(P2)
	MOVEM T1,ATBPVW(T2)	;%+ KEEP OLD PROTECTION
	MOVE T1,ATBLCW(P2)	;%+ IN CASE WE WANT TO PRESERVE LIC
	MOVEM T1,ATBLCW(T2)
	MOVE P2,T2
	PUSHJ P,LNKATB
SRCSP1:	MOVEI T1,ATPSUP
	IORM T1,ATBSTS(P2)
	JRST SRCFNI

SRCDFD:	PUSHJ P,GETCBR		;+! FOUND FILE IN DIR
	SKIPE FNBRIB(P3)
	JRST SRCCFP		;%+! SOMEONE ELSE DID TOO
	MOVE T1,%RIB+UFDRIB(T2)
	MOVEM T1,FNBRIB(P3)
	MOVE T1,DEVREL(F)	;%+! GET POSITION FOUND IN
	DPB T1,FNYUFP		;%+! AND SAVE PAGE NUMBER IN UFD
	PUSHJ	P,UFDATB	;%+! FILL IN ATB FROM UFD ENTRY
				;%+!  IN CASE THERE IS A RIB ERROR, WILL KNOW WHETHER OR NOT OK TO DELETE.
				;%+! (UNFORTUNATELY WE WILL LOSE RIPNDL IN RIB ERROR)
	JRST SRCCFP		;%+! GO AFTER SETTING RIB PTR

SRCENT:	MOVEI T1,ATPDEL
	MOVEI T3,ATPMXU!ATPCRE!ATPSUP!ATPUPD!ATPREN
	PUSHJ P,SRCAT		;%+ ANY UPDATE ETC ILL FOR REN OR ENT
	 JRST ERRFBM		;%+ FOUND PROHIBITED ATB
	 JRST ERRNC1		;%+ NO ROOM FOR ATB
	SKIPE ATBDOR(P2)
	PUSHJ P,ULDATB	;MAKE UN-DORMANT
	MOVSI T1,FNPNX
	TDNE T1,FNBNX(P3)	;%+ IS FILE KNOWN NX
	JRST SRCENX	;%+ YES, THIS IS A CREATE
	AOS ATBCNT(P2)
	MOVEI T1,ATPUPD
	IORM T1,ATBSTS(P2)	;%+ SET COUNT AND UPD AND GO
	SKIPE FNBRIB(P3)	;%+ IF RIB POSITION KNOWN
	JRST SRCSUP		;%+ ITS A SUPERCEDE
	JRST SRCLU2
;%+ HERE WHEN WE NEED TO READ IN THE RIB FOR THIS FILE

FILRB1:	MOVE T1,FNBRIB(P3)
FILRIB:	MOVEM T1,DEVRIB(F)	;STORE IT (MULCLN MAY DESTRY)
	PUSHJ P,MULCLN	;GETS DEVEXT SET RIGHT
	PUSHJ P,GIVCBR		;%+ TO GET READY FOR A MAP OP
	MOVEI PG,%RIB.C
	MOVE T1,DEVRIB(F)	;+ RESTORE RIB PNTR
	PUSHJ P,MAPRDL
	PUSHJ P,PRMCHK
	  JRST [TLNN M,UUOIRE	;+! SOMETHING WRONG WITH RIB.
		JRST ERRTRN	;+! GIVE RIB ERROR RETURN IF NOT IGNORING
		PUSHJ P,GETCBR	;+! NEED CB SO NO ONE WILL FILL IT IN BEHIND OUR BACKS
		JRST FILRBD]	;+! GO WITH INFO FROM UFD COLLECTED EARLIER, CALLER KNOWS
				;+! WHAT HE'S DOING WE HOPE.
	PUSHJ P,GETCBR
	SKIPE ATBRIB(P2)	;%+! DID SOMEONE BEAT US TO IT
	JRST FILRBD
	MOVE T1,%RIB+RIBSLF	;%+! NOW MOVE THE STUFF TO ATB
	MOVEM T1,ATBRIB(P2)
	MOVE T1,%RIB+RIBPVW
	MOVEM T1,ATBPVW(P2)
	MOVE T1,%RIB+RIBLCW
	MOVEM T1,ATBLCW(P2)
	MOVE T1,%RIB+RIBPID
	MOVEM T1,ATBPID(P2)
	MOVE T1,%RIB+RIBMSC
	HRLM T1,ATBMSC(P2)
	MOVE T1,%RIB+RIBALP
	MOVEM T1,ATBALP(P2)
	MOVE T1,%RIB+RIBALT	;GET DIRTY TIMER
	MOVEM T1,FNBALT(P3)	;SETUP IN FNB.
	MOVE T1,%RIB+RIBSIZ
	TRNE T1,177
	ADDI T1,200		;%+! INC BLOCK COUNT IF EXTRA WDS IN LAST BLOCK
	MOVEM T1,ATBSIZ(P2)
	MOVEI T1,0
	MOVE T2,%RIB+RIBSTS	;%+! GET STATUS WORD
	TRNE T2,RIPDIR
	TRO T1,ATPDIR
	TRNE T2,RIPNDL
	TRO T1,ATPNDL	;%+! AND SET A COUPLE OF STATUS BITS
	IORM T1,ATBSTS(P2)
FILRBD:	TLNN M,UUOLUK	;%+! IS THIS A LOOKUP?
	JRST	[PUSHJ P,RELLOK	;%+! ENTER, RELEASE BLOCK
		JRST SRCSP0]	;%+ AND GO
	TLO S,IOSRIB	;%+! HAVE RIB
SRCLK1:	PUSHJ P,MULCLN		;%+! GET RID OF EXTRA ATBS
SRCFNI:	HRRM P2,DEVATB(F)	;%+! (OR %+ IF IOSRIB=0)
	HRLM P4,DEVDRB(F)
	TLNE M,UUOREN
	PJRST GIVCB1	;DON'T FIDDLE IF RENAME
	HRRZ T1,FNBDBL(P3)
	HRRM F,FNBDBL(P3)
        CAIE T1,(F)             ;PREVENT LINK FROM POINTING TO ITSELF
	HRRM T1,DEVDBL(F)	;%+! SET DDB LINK (FOR INSERT AND DELETE)
	PJRST GIVCB1
;ERROR ROUTINES FOR SRCFIL

ERRNC1:	PUSHJ P,MULCLN	;%+ REMOVE EXTRA ATBS IF ANY
	SOS T1,DRBCNT(P4)	;%+ NOT ENOUGH CORE
	TRNE T1,DRPMXC		;% UNDERFLOW?
	STOPCD(SLO)
ERRNEC:	MOVEI T1,NECERR		;%
	PJRST GIVCBR

ERRIPP:	MOVEI T1,IPPERR		;% CAN NOT FIND UFD
	PJRST GIVCBR

ERRTRN:	PUSHJ	P,GETCBR	;
	PUSHJ P,MULCLN
	PUSHJ P,RELLOK		;%+! (ACTUALLY RIB ERROR)
	MOVEI T1,ATPUPD		;%+ UPD SET IF ENTER OR RENAME
	TLNN M,UUOLUK
	ANDCAM T1,ATBSTS(P2)	;%+ SO RESET
	SOSA T1,ATBCNT(P2)
ERRTR1:	MOVE T1,ATBCNT(P2)	;%+ SOME RIB OR UFD ERROR
	TDNN T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]		;%+ STILL HAVE USERS?
	PUSHJ P,FREATB		;%+ NO, RETURN TO FREE CORE
	SOS T1,DRBCNT(P4)	;%+
	TRNE T1,DRPMXC
	STOPCD(SLO)			;% UNDEFLOW
	MOVEI T1,TRNERR		;% FINALLY THE ERROR
	PJRST GIVCBR

ERRFB1:	MOVEI T1,ATPUPD		;%+ FILE IN USE ON RENAME
	ANDCAM T1,ATBSTS(P2)
	SOS T1,ATBCNT(P2)
	TDNN T1,[ATMUMC,,ATPMXU!ATMCNT!ATPCRE!ATPSUP!ATPUPD!ATPREN]
	PUSHJ P,FREATB		;%+ RETURN ATB IF NO OTHER USERS
ERRFBM:	SOS T1,DRBCNT(P4)	;%+ FBM ON ENTER OR RENAME
	TRNE T1,DRPMXC
	STOPCD(SLO)		;% UNDEFLOW
	MOVEI T1,FBMERR
	TLNE M,UUOREN
	MOVEI T1,AEFERR		;% DIFFERENT FOR ENTER
	PJRST GIVCBR

ERRFNF:	PUSHJ P,MULCLN
	SOS T1,DRBCNT(P4)	;%+ CAN NOT FIND FILE
	TRNE T1,DRPMXC
	STOPCD(SLO)			;% UNDEFLOW
	MOVEI T1,FNFERR		;% FINALLY THE ERROR
	PJRST GIVCBR
;THIS ROUTINE RELEASES A LOCKED BLOCK (%RIB)

RELLOK:	MOVEI PG,%RIB.C
	PJRST MAPRLS

;SEARCH A DIRECTORY BLOCK IN %RIB. USE DEVNAM AND DEVEXT
; TO DECIDE WHAT TO LOOK FORR

; NON-SKIP RETURN IF FOUND. T2 POINTS TO UFD ENTRY
;SKIP RETURN - NOT FOUND

DIRSRC:	MOVSI T2,-<^D512/UFDSIZ>	;NUMBER OF ENTRIES
	MOVE T1,DEVFIL(F)
	HLL T3,DEVEXT(F)
DIRSR1:	CAMN T1,%RIB+UFDNAM(T2)
	JRST DIRSC1
DIRSR2:	ADDI T2,UFDSIZ-1
	AOBJN T2,DIRSR1
	PUSHJ P,GETER1
	JUMPN T1,DIRSCE		;SOME ERROR THERE
	JRST CPOPJ1		;NOT FOUND

DIRSC1:	HRR T3,%RIB+UFDEXT(T2)
	CAME T3,%RIB+UFDEXT(T2)
	JRST DIRSR2	;NOT THIS ONE
DIRSC5:	PUSHJ P,GETER1	;LOAD THE ERROR BITS
	JUMPE T1,CPOPJ	;FOUND NO ERROR
DIRSCE:	TLO S,IOSRBE	;SET ERROR BIT
	JRST CPOPJ1	;AND GO
COMMENT ;@@SUBROUTINE DRRSRC
@@PURPOSE SEARCH UFD PAGE FOR A FILE'S
PRIME RIB POINTER.
@@ENTRY ATB ADDRESS IN P2, UFD PAGE IN %RIB.
@@ACCUM T1-T4.
@@EXIT SKIP RETURN WITH INDEX INTO %RIB IN T2
FOR UFD ENTRY IF FOUND, ELSE NON-SKIP RETURN.
@@;

DRRSRC::MOVSI	T2,<-^D512/UFDSIZ> ;NUMBER TO SEARCH
	PUSHJ	P,GETER1	;ERRORS?
	JUMPN	T1,CPOPJ	;JUMP IF YES.
	SKIPN	T1,ATBRIB(P2)	;HAS FILE'S RIB DISAPPEARED?
	POPJ	P,		;YES, GO HOME.

DRRSR1:	SKIPN	%RIB+UFDNAM(T2)	;THIS THE END?
	POPJ	P,		;YES NOT FOUND
	CAMN	T1,%RIB+UFDRIB(T2) ;CORRECT POINTER?
	JRST	CPOPJ1		;YES, GIVE INDEX BACK IN T2
	ADDI	T2,UFDSIZ-1	;ADD ALL BUT ONE AND
	AOBJN	T2,DRRSR1	;AOBJN AROUND.
	POPJ	P,		;OUT OF ENTRIES, ITS NOT THERE.
;REMOVE A NAME FROM THE DIRECTORY

INTERNAL DLTNAM

UFDLST==<1000/UFDSIZ-1>*UFDSIZ

DLTNAM:	TLO S,IO
	PUSHJ P,RIBDIR	;GET DIRECTORY RIB
	 JRST RELLOK	;ERROR, CAN NOT GET IT
	LDB T1,FNYUFP
	PUSHJ P,DIRBLK
	 POPJ P,	;ALSO FAILED TO GET IT
	TLZ M,UUOMLK	;MAKE SURE
	PUSHJ P,DIRSRC
	 SKIPA
	JRST RELLOK	;NOT THERE
	HRRZS T2
	CAIN T2,UFDLST	;JUST IN CASE LAST NAME
	JRST DLTNM1
	HRLI T1,%RIB+UFDSIZ(T2)
	HRRI T1,%RIB(T2)
	BLT T1,%RIB+UFDLST-1
DLTNM1:	SETZM %RIB+UFDLST
	MOVE T1,[%RIB+UFDLST,,%RIB+UFDLST+1]
	BLT T1,%RIB+UFDLST+UFDSIZ-1
	PJRST RELLOK	;FINISHED ZEROING, RELEASE BLOCK
;NOW INSERT A NAME IN THE DIRECTORY.
;EXPECTS T2/ 0 OR RET PNTR SUPPLIED BY CALLER IN CASE WE HAVE TO
;EXTEND THE DIRECTORY.
;SKIP RETURNS ON SUCCESS, WITH T2/ POINTER TO THE EMPTY ENTRY
;WE FOUND.
;NON-SKIP RETURNS ON FAILURE, WITH T1/ FALAQA IF WE RAN OUT
;OF ROOM, ELSE T1/ 0.

INTERN INSNAM

INSNAM:	JUMPE	T2,INSNM0	;CHECK THE FORM OF
	TLNN	T2,RBMASK-RBREAL ;THE RETRIEVAL
	TLNN	T2,RBREAL	;PNTR.
	STOPCD(SLO)
INSNM0:	PUSH	P,T2		;SAVE RET PNTR.
	TLO	S,IO			;MAKE SURE WE WRITE LOCK
	MOVE T1,DRBRIB(P4)
	PUSHJ P,DIRFST
	 JRST INSNML		;MIGHT BE A NX BLOCK HERE
INSNLP:	PUSHJ P,FNDFRE
	 JRST INSNM1		;HERE WE HAVE A SPOT TO PUT IT
	PUSHJ P,DIRNXT
	 JRST INSNML		;TRY AGAIN TO INSERT A BLOCK
	JRST INSNLP		;KEEP LOOKING FOR A FREE SPOT

    ;TINY SUBR TO SEE IF THERE IS AN EMPTY ENTRY IN THIS PAGE OF
    ;THE DIRECTORY.
FNDFRE:	SKIPE %RIB+UFDLST
	JRST CPOPJ1		;NONE FREE IF LAST NOT FREE
	MOVSI T2,-1000/UFDSIZ
FNDFR1:	SKIPN %RIB(T2)
	POPJ P,			;FOUND THE FIRST EMPTY ONE
	ADDI T2,UFDSIZ-1
	AOBJN T2,FNDFR1
	STOPCD(SLO)			;THERE WAS ONE FREE

INSNML:	MOVE T1,DRBRIB(P4)	;NEED TO ADD A BLOCK
	MOVEI PG,%RB2.C
	PUSHJ P,MAPWTL
	PUSHJ P,MAPXCH	;FOR CHECKING
	PUSHJ P,RIBCKD
	JRST	[PUSHJ P,MAPXCH
		PJRST INSFER]	;REL RB2, DISK PAGE, FAIL EXIT.
	PUSHJ P,MAPXCH
	TLO S,IOSRIB		;NEED TO SEARCH AGAIN WITH RIB LCCKED
	MOVE T1,DRBRIB(P4)
	PUSHJ P,DIRFST
	 JRST INSFAK		;THIS MUST BE A NX PNTR
INSNL2:	PUSHJ P,FNDFRE		;THERE MAY NOW BE FREE SPACE
	 JRST INSGOT		;YES, OR NEW BLOCK OR SOMETHING
	PUSHJ P,DIRNXT
	 JRST INSLNK		;INSERT A NEW LINK
	JRST INSNL2		;KEEP LOOKING

INSGOT:	PUSH P,T2	;SAVE DIRECTORY SLOT FOUND THIS TIME
	PUSHJ	P,RELRB2	;RELEASE %RB2.
	POP P,T2

INSNM1:	MOVE T1,DEVBLK(F)
	DPB T1,FNYUFP		;REMEMBER WHERE IT IS IN UFD
	EXCH	T2,(P)		;SAVE FOUND SLOT, GET DISK PAGE.
	JUMPE	T2,INSNM4	;IF HAVE A DISK PAGE,
	PUSH	P,PG		;WE HAVE
	PUSH	P,GIVPAG	;TO GIVE TI
	POP	P,PG		;BACK.
INSNM4:	POP	P,T2		;RESTORE PNTR TO SLOT FOUND.
	JRST CPOPJ1

INSFAK:	TLNE S,IOSRBE	;WAS THERE REALLY AN ERROR?
	JRST	INSFER		;YES.
INSFK2:	POP	P,T2		;
	JUMPN	T2,INSFK4	;
	TLO S,IOSALC	;NO, NEED TO ADD A NEW BLOCK
EXTERN FBIT
	MOVEI	T1,FBIT
	HRRZ	T3,DEVATB(F)	;T3/ ATB ADDR OR ZERO.
	PUSHJ P,GETAPG
	JRST	INSFQ2		;
	TLZ S,IOSALC
INSFK4:	MOVE T1,DEVBLK(F)
	DPB T1,FNYUFP
	MOVEM T2,%RB2+RIBPFS(T1)	;DEVBLK IS POINTER
	MOVE T1,T2
	MOVEI PG,%RIB.C
	PUSHJ P,MAPWLN		;A NEW BLOCK
	AOS %RB2+RIBALP	;COUNT A NEW DIRECTORY PAGE
	SETZM %RIB
	MOVE T1,[%RIB,,%RIB+1]
	BLT T1,%RIB+777
	PUSHJ	P,RELRB2	;RELEASE %RB2.
	MOVEI T2,0
	JRST CPOPJ1	;HAVE IT ALL DONE

    ;HERE ON A HOLE, EOF, OR RIB ERROR FOR THE DIRECTORY.
INSLNK:	TLNE S,IOSRBE
	JRST	INSFER		;ERROR.
	TLNN S,IOSRIB
	JRST INSFK2	;REALLY A NX PNTR
	SKIPE	T2,(P)		;MAKE SURE WE HAVE A DISK
	JRST	INSL00		;PAGE BEFORE WE GO TO THE
	MOVEI	T1,FBIT		;TROUBLE OF
	HRRZ	T3,DEVATB(F)	;UPDATING THE
	PUSHJ	P,GETAPG	;COUNTS.
	JRST	INSFQO		;
	MOVEM	T2,(P)		;
INSL00:	MOVSI T1,RIBPFS-RIBLST-1
INSLK0:	SKIPN %RB2+RIBPFS(T1)	;LOOK FOR A PLACE TO PUT ONE
	JRST INSEOF
	AOBJN T1,INSLK0
	JRST	INSFER		;DIRECTORY FULL.

INSEOF:	HRRZM T1,DEVBLK(F)	;STORE AS POINTER
	HRRZM T1,%RIB+UFDLNK
	DPB T1,FNYUFP	;SLOT ALSO
	PUSHJ	P,RELRIB	;RELEASE %RIB.
	MOVEI T1,1000
	ADDM T1,%RB2+RIBSIZ
	PUSHJ P,GETCBR		;MAY BE BEING READ AS A FILE
	HLRZ T2,SYSDRB
	MOVNI T3,1
	MOVE T1,MFDPPN
	PUSHJ P,SRCNAM
	 JRST INSNAT
	HLRZ T2,DRBFNB(T2)
	MOVE T1,DEVPPN(F)
	PUSHJ P,SRCNAM
	 JRST INSNAT
	HLRZ T2,FNBATB(T2)
INSXAT:	MOVE T1,ATBSTS(T2)
	TRNE T1,ATPREN!ATPCRE!ATPUPD!ATPSUP!ATPDEL
	JRST INSIAT	;IGNORE THIS
	MOVEI T1,1000
	ADDM T1,ATBSIZ(T2)
INSIAT:	HLRZ T2,ATBLNK(T2)
	JUMPN T2,INSXAT
INSNAT:	PUSHJ P,GIVCBR
	JRST INSFK2	;NOW TREAT LIKE OTHER

    ;ERROR EXITS.
INSFER:	TDZA	T2,T2		;HERE ON RIB ERROR.
INSFQO:	MOVEI	T2,FALAQA	;HERE ON ALLOCATION ERROR.
	EXCH	T2,(P)		;SAVE ERR CODE, GET RET PNTR.
	PUSH	P,T2		;SAVE RET PNTR.
	PUSHJ	P,RELRB2	;RELEASE RIB FIRST, TO SPEED
	POP	P,T2		;UP SYSTEM. GET RET PNTR AGAIN.
	JUMPE	T2,INSFR4	;GIVE BACK THE DISK PAGE, IF
	PUSH	P,PG		;WE
	PUSHJ	P,GIVPAG	;HAVE
	POP	P,PG		;IT.
INSFR4:	POP	P,T1		;RESTORE T1/ ERROR CODE.
	POPJ	P,

INSFQ2:	PUSHJ	P,RELRB2	;
	MOVEI	T1,FALAQA	;
	POPJ	P,		;
;TWO ROUTINES TO SEARCH CORE TABLES

;SRCNAM SEARCHES FOR FNB AND DRB BLOCKS
;	ALWAYS CALL WITH CB RESOURCE
;	T1 NAME TO SEARCH FOR
;	T2 CURRENT POINTER (POSSIBLY 0)
;	T3 PRVIOUS POINTER
;	T3 LH NEG IF DO NOT CREATE NEW TABLE
;
;	WILL CONSTRUCT A NEW ENTRY AND LINK TO END OF LIST IF NOT FOUND

; NON-SKIP RETURN IF NOT FOUND T2<=0 IF NO CORE FOR NEW TABLE
;	T2>0 POINTS TO NEW TABLE
; SKIP RETURN, FOUND, T2 HAS POINTER

SRCNAM:	JUMPE T2,SRCNMC	;NEED A NEW ONE
SRCNM1:	CAMN T1,CMBNAM(T2)
	JRST CPOPJ1	;FOUND
SRCNM0:	HRR T3,T2	;CONTINUE BY PUSHJ TO HERE
	HLRZ T2,CMBLNK(T2)	;NEXT
	JUMPN T2,SRCNM1	;THERE IS ONE
SRCNMC:	JUMPL T3,CPOPJ	;DO NOT CREATE NEW TABLE
	PUSHJ P,GETCRL	;GET SPACE FOR IT (DON'T GC T3)
	 POPJ P,	;NO ROOM, T2=0
	MOVEM T1,CMBNAM(T2)	;STORE NAME
	HRLM T2,CMBLNK(T3)	;LINK TO END OF CHAIN
	POPJ P,

;SRCAT SEARCHES FOR ACCESS TABLES
;	ALWAYS CALL WITH CB RESOURCE
;	P3 HAS POINTER TO FNB
;	T1 HAS BITS TO BE CHECKED IN ATBSTS, IF ON IGNORE AT
;	T3 HAS BITS TO BE CHECK IN ATBSTS, IF ON, ERROR
;
; NON-SKIP RETURN IF ANY ERROR BITS ON
; SKINGLE SKIP RETURN IF NO CORE TO CREATE NEW AT
; DOUBLE SKIP RETURN IF ALL OK, P2 HAS ATB POINTER

SRCAT:	HLRZ T2,FNBATB(P3)
	JUMPE T2,SRCATC	;NONE THERE, NEED A NEW ONE
	MOVEI P2,0	;NONE FOUND YET
SRCAT0:	TDNE T3,ATBSTS(T2)	;ANY PROHIBITED BITS?
	POPJ P,		;YES
	TDNN T1,ATBSTS(T2)	;IGNORE THIS ONE?
	MOVE P2,T2	;NO, SAVE IT
	HLRZ T2,ATBLNK(T2)	;NEXT
	JUMPN T2,SRCAT0	;CONTINUE IF MORE
	JUMPN P2,CPOPJ2		;DID WE FIND ONE, YES GOOD
SRCATC:	MOVSI T1,FNPLOK
	IORM T1,FNBLOK(P3)	;LOCK FNB SO NO GARBAGE COLLECT
	PUSHJ P,GETCOR
	 JFCL	;IGNORE ERROR (T2 WILL BE 0)
	MOVSI T1,FNPLOK
	ANDCAM T1,FNBLOK(P3)	;UNLOCK
	SKIPN P2,T2
	JRST CPOPJ1	;ERROR
	AOS (P)
	AOS (P)
	JRST LNKATB	;LINK INTO RING
;ROUTINES TO DO LINKING AND UNLINKING

;LNKATB LINKS AN ACCESS ATBLE TO THE FNB RING
;	P3 POINTER TO FNB
;	P2 POINTER TO ATB

;WILL SET FNBATB,ATBLNK,ATBFNB
;	SHOULD BE CALLED WITH CB RESOURCE

LNKATB:	HRRM P3,ATBFNB(P2)
	HLLZ T1,FNBATB(P3)	;GET OLD LINK
	HLLM T1,ATBLNK(P2)	;POINT NEW ONE TO IT
	HRLM P2,FNBATB(P3)	;AND POINT FNB TO NEW ONE
	POPJ P,

;RMVATB RETURNS AN ATB TO FREE CORE
;IF THE ATB IS DORMANT, IT UNLINKS IT FROM THE DORMANT LIST
;	P2 POINTER TO ATB
;	P3 POINTER TO FNB

;SHOULD BE CALLED WITH CB RESOURCE

RMVATB:	SKIPE ATBDOR(P2)
	PUSHJ P,ULDATB		;UNLIK ATB FROM DORMANT LIST

;FREATB IS LIKE RMVATB BUT ATB IS KNOWN NOT TO BE DORMANT

FREATB:	MOVEI T1,FNBATB-ATBLNK(P3)	;SET PRED.
FREAT1:	HLRZ T2,ATBLNK(T1)
	SKIPN T2		;SHOULD NOT REACH END OF LIST
	STOPCD(SLO)
	CAME T2,P2
	SKIPA T1,T2	;NOT SAME, GET PRED=THIS
	SKIPA T2,ATBLNK(T2)	;SAME, GET LINK
	JRST FREAT1	;NO SAME, CONTINUE SEARCH
	HLLM T2,ATBLNK(T1)	;LINK AROUND THIS ONE
	MOVE T1,SYSCOR
	HLLM T1,CMBLNK(P2)	;LINK TO FREE CORE LIST
	HRLZM P2,SYSCOR
	POPJ P,

;ROUTINE TO REMOVE DDB FROM FNBDBL LINK

INTERNAL ULKDBL

ULKDBL:	MOVEI T2,FNBDBL-DEVDBL(P3)	;FOR A START
ULKDB0:	HRRZ T1,DEVDBL(T2)
	CAIN T1,(F)	;HAVE WE FOUND THIS ONE YET?
	JRST ULKDB1	;YES
	SKIPN T2,T1	;NO, BETTER NOT BE AT END
	STOPCD(SLO)
	JRST ULKDB0

ULKDB1:	HRRZ T1,DEVDBL(F)	;ONE WE POINT TO
	HRRM T1,DEVDBL(T2)	;LINK AROUND THIS DDB
	HLLZS DEVDBL(F)		;JUST TO MAKE SURE
	POPJ P,
;ULDATB REMOVES AN ATB FROM THE DORMANT LIST.. SEE COMMOD
;FOR A DESCRIPTION OF THE DORMANT LIST.
;	P2=POINTER TO ATB

;SHOULD BE CALLED WITH THE CB RESOURCE

ULDATB:	MOVE T1,ATBDOR(P2)
	HLLM T1,ATBDOR(T1)	;RESET FORWARD POINTER OF PREVIOUS
	CAIN T1,SYSDOR-ATBDOR
	JRST ULDAT1		;THIS IS THE ONLY DORMAT AT IF SO
	MOVSS T1		;NO RH IS NEXT IN CHAIN
	TRNN T1,-1		;MIGHT BE LAST
	HRRI T1,SYSDOR-ATBDOR	;IF SO, POINT BACK TO START
ULDAT1:	HLRM T1,ATBDOR(T1)	;RESET PREVIOS PNTR OF NEXT
	SETZM ATBDOR(P2)	;NOT DORMANT ANY MORE
	POPJ P,

;LKDATB PUTS AN ATB ON THE DORMANT LIST
;	P2=POINTER TO ATB

;SHOULD BE CALLED WITH CB RESOURCE

LKDATB:	SKIPE ATBDOR(P2)	;MUST NOT ALREADY BE DORMANT
	STOPCD(SLO)
	HLRZ T1,SYSDOR
	HRLM P2,SYSDOR	;PUT ON END OF LIST
	HRLI T1,SYSDOR-ATBDOR
	MOVSM T1,ATBDOR(P2)	;SET BACK LINK TO OLD LAST
	TRNN T1,-1
	MOVSS T1	;THIS WILL HAPPEN ONLY IF NO PREVIOUS ENTRIES
	HRRM P2,ATBDOR(T1)	;STORE AS FORWARD LINK FOR OLD LAST ENTRY
	POPJ P,

;HERE WITH CB TO FIND A DRB IF IT EXISTS
;T1 HAS PPN

FNDDRB:	HLRZ T2,SYSDRB
	MOVNI T3,1	;DO NOT CREATE
	PJRST SRCNAM	;THAT WAS EASY

;ROUTINE TO TEST TO SEE IF THERE IS SOMEONE WRITING THIS FILE
;T3 HAS ATBSTS IN IT
; ENTER AT TSTWRS TO CHECK FOR NON-SIMULTANEOUS WRITERS.

TSTWRS::SKIPA	T3,[ATPUPD!ATPCRE!ATPSUP!ATPREN]
TSTWRT:	MOVEI T3,ATPMXU!ATPUPD!ATPCRE!ATPSUP!ATPREN
	HRRZ T2,ATBFNB(P2)
	HLRZ T2,FNBATB(T2)
TSTWRL:	TDNE T3,ATBSTS(T2)
	POPJ P,
	HLRZ T2,ATBLNK(T2)
	JUMPN T2,TSTWRL
	JRST CPOPJ1
GETCBR:	PUSH P,T1
	MOVE T1,JOB
	CAMN T1,CBUSER	;MAKE SURE WE DO NOT ALREADY HAVE IT
	STOPCD(SLO)	;YES WE DO
	AOSE	CBREQ
	PUSHJ	P,CBWAIT
	SETZM CBSWT
	MOVEM T1,CBUSER
	HRRZ T1,-1(P)
	HRL T1,F
	MOVEM T1,CBADR
	PJRST TPOPJ

GIVCB1:	AOS (P)		;SKIP RETURN
GIVCBR:	PUSH P,T1	;HE MUST BE THE ONE WHO HAS IT
	MOVE T1,JOB
	CAME T1,CBUSER
	STOPCD(SLO)
	SOSL	CBREQ
	SETOM	CBAVAL
	SETZM CBUSER
	PJRST TPOPJ
;% SUBROUTINE TO GET FREE CORE BLOCK
; NON-SKIP RETURN, NONE AVAILABLE T2=0
; SKIP RETURN, BLOCK FOUND T2 IS POINTER
;% JOB MUST HAVE CB RESOURCE WHEN ROUTINE IS CALLED
;% T1 RESPECTED
;%GETCOR ZEROS T3, GETCRL T3 IS SOMETHING TO NOT GARBAGE COLLECT
;% EITHER A DRB OR AN FNB
GETCOR:	MOVEI T3,0		;NOTHING TO SAVE
GETCRL:	PUSH P,T1	;SAVE FOR A WORK REGISTER
GTCOR0:	HLRZ	T2,SYSCOR	;% 1ST FREE BLOCK ON LIST
	JUMPN	T2,GTCOR2	;% THER IS FREE CORE IF NON-0
	HRRZ T2,SYSDOR
	JUMPE T2,CORGR4	;NO DORMANT ATB'S
	PUSH P,P2
	PUSH P,P3
	HRRZ P2,T2
	HRRZ P3,ATBFNB(P2)	;NEED TO GET IT OUT OF FNB LIST ALSO
	PUSHJ P,RMVATB
	POP P,P3
	POP P,P2
	JRST GTCOR0
	JRST GTCOR3	;JUST GET THE BLOCK ZEROED OUT

CORGR4:	PUSH P,P3	;ANOTHER REGISTER TO WORK IN
	HRRZ P3,SYSDRB	;THE ONE TO SEARCH
	SKIPN P3	;MAY BE NONE
	HLRZ P3,SYSDRB	;FOR EXAMPLE, THE FIRST TIME THOOUGH, USE FIRST IN SYSTEM
	JUMPE P3,CORGR9	;THERE IS NO FREE CORE
	HRRM P3,SYSDRB	;SAVE IT HERE IN CASE IT WAS 0
CORGR5:	HLRZ T2,DRBFNB(P3)	;DOES DRB HAVE ANY FNB'S
	JUMPN T2,CORGR6	;YES, SEE ABOUT ONE OF THEM
	MOVEI T1,DRMCNT
	CAME P3,T3		;DON'T TAKE SPECIAL ONE
	TDNE T1,DRBCNT(P3)
	JRST CORG5A	;THIS DRB IS IN USE, FORGET IT
	MOVEI T1,DRPLOG!DRPLOK
	TDNE T1,DRBSTS(P3)
	JRST CORG5A	;ALSO FORGET THAT ONE
	MOVEI T1,SYSDRB-DRBLNK	;NOW NEED TO RECLAIM THIS DRB
CORG5B:	HLRZ T2,DRBLNK(T1)
	CAMN T2,P3	;FIND THE ONE WE CURRENTLY POINT TO
	JRST CORG5C	;FOUND IT
	SKIPN T1,T2	;NOT THIS ONE, SET PREDECESSOR
	STOPCD(SLO)		;END AND NOT FOUND, SOMETHING IS WRONG
	JRST CORG5B	;CONTINUE

CORG5C:	MOVE T2,P3	;THIS IS THE ONE TO GRAB
	HLL P3,DRBLNK(P3)	;THIS IS THE NEXT ONE
	HLLM P3,DRBLNK(T1)	;RELINK
CORG5D:	HLRM P3,SYSDRB	;LOOK HERE NEXT TIME
	POP P,P3
	JRST GTCOR3	;GO ZERO BLOCK
CORG5A:	HLRZ P3,DRBLNK(P3)	;NEED TO LOOK AT NEXT DRB
	SKIPN P3	;AT END?
	HLRZ P3,SYSDRB	;START OVER (MAY HAVE STARTED IN MIDDLE)
	HRRZ T2,SYSDRB	;THIS WAS WHERE WE STARTED
	CAME T2,P3
	JRST CORGR5	;MORE TO LOOK AT
CORGR9:	POP P,P3
	MOVEI T2,0
	JRST TPOPJ	;NONE FOUND, GIVE ERROR RETURN

;HERE TO LOOK AT FNBS ON A DRB

CORGR6:	HRLI P3,DRBFNB-FNBLNK(P3)	;REMEMBER PRED.. FNB
	PUSH P,T4	;ANOTHER REGISTER TO WORK IN
	MOVEI T4,0	;THIS IS THE FIRST FNB FOUND WITH NO ATBS BUT WITHOUT NX
CORG6B:	HLRZ T1,FNBATB(T2)
	JUMPN T1,CORG6A	;CAN NOT TAKE ONE WITH ATBS
	MOVSI T1,FNPLOK
	CAME T2,T3	;NOT SPECIAL ONE
	TDNE T1,FNBLOK(T2)	;CAN NOT TAKE IT IF LOCKED
	JRST CORG6A
	MOVSI T1,FNPNX
	TDNN T1,FNBNX(T2)	;JUST NX
	JRST CORG6C	;NO, WILL TAKE IF HAVE TO, BUT RATHER FIND AN NX
	HLRZ T4,P3	;GET PRED
CORG6D:	HLRZ T1,FNBLNK(T2)
	HRLM T1,FNBLNK(T4)	;LINK AROUND THIS ONE
	POP P,T4
	HLL P3,DRBLNK(P3)	;GET READY TO SET TO LOOK AT NEXT
	JRST CORG5D

CORG6C:	SKIPN T4	;HAVE WE ALREADY FOUND FNB NOT NX?
	HLR T4,P3	;NO, SAVE THE PRED TO THE ONE TO GRAB
CORG6A:	HRL P3,T2	;SAVE THIS AS PRED
	HLRZ T2,FNBLNK(T2)	;NEXT FNB
	JUMPN T2,CORG6B	;NOT OUT YET
	JUMPN T4,[HLRZ T2,FNBLNK(T4)	;GET THE ONE NO NX BUT GRABABLE
		JRST CORG6D]	;AND GO GRAB IT
	POP P,T4
	JRST CORG5A	;MUST GO TO NEXT DRB

GTCOR2:	MOVE T1,CMBLNK(T2)	;FOUND ONE IN CORE LIST, UNLINK
	HLLM T1,SYSCOR
GTCOR3:	SETZM (T2)	;ZERO OUT NEWLY FOUND BLOCK
	HRL T1,T2
	HRRI T1,1(T2)
	BLT T1,CMBSIZ-1(T2)
	JRST TPOPJ1	;TAKE GOOD RETURN

;SUBROUTINE TO CHECK ACCESS PRIVILIGES
;ENTER WITH T1=DESIRED FUNCTION
; F=DDB ADDRESS
; P2=ATB ADDRESS
;EXIT CPOPJ IF PRIVS DON'T1 ALLOW OPERATION
;EXIT CPOPJ1 IF OK, T1=FUNCTION

CHKPRV:	PUSH P,J		;CHECK, MAY NOT HAVE STORED HIGHEST
	LDB J,PJOBN
	HLRZ T3,DEVEXT(F)
	CAIE T3,(SIXBIT .UFD.)	;IS IT UFD??
	JRST CKNUFD		;NO
	MOVE T3,DEVPPN(F)
	CAME T3,MFDPPN
	JRST CKNUFD
	TLO M,UUOUFD		;MARK AS A UFD
	LDB T4,ATYPRV
	IOR T4,[XWD 400000,700]	;SET ALL FOR OWN AND MARK UFD
	MOVE T2,DEVFIL(F)		;UFD NAME
	PUSHJ P,CHKPRJ		;CHECK FOR LICENSED JOB
	JRST CPOPK1	;IS SPECIAL
	PUSHJ P,GETPTR	;NOT SPECIAL
	LDB T2,T3
	CAIG T1,FNCLOK	;WANT TO DO MORE THAN READ??
	TRNN T2,UFRXRD	;CAN WE READ
	JRST CPOPK	;NO TO ONE. CHG PROT CAUGHT IN CHKPRJ
	JRST CPOPK1

CKNUFD:	MOVE T2,DEVPPN(F)	;USE FILE PPN NOT NAME FORCHECK
	LDB T4,ATYPRV
	TRC T4,700		;IF OWNER FIELD IS 7
	TRCN T4,700
	TRZ T4,100		;MAKE IT 6
	PUSHJ P,CHKPRJ
	 JRST CPOPK1
	PUSHJ P,GETPTR
	LDB T4,DRYPRV
	IORI T4,700		;CAN ALWAYS USE OWN
	LDB T2,T3		;GET IT
	CAIE T1,FNCCRE		;CREATE IS SPECIAL
	JRST CKNCRE
	TRNE T2,UFRXCR
CPOPK1:	AOS -1(P)		;GOOD RETURN
CPOPK:	POP P,J
	POPJ P,		;ALL DONE
CKNCRE:	TRNN T2,UFRXLK	;IS UFD TRANSPARENT??
	JRST CPOPK	;NO
	LDB T4,ATYPRV	;GET BACK FILE PROT
	TRC T4,700
	TRCN T4,700
	TRZ T4,100
	LDB T2,T3	;STILL HAVE POINTER IN T3
	MOVE T2,TRNSTB(T2)	;TRANSLATE TO INTERNAL FORM
	CAMGE T2,T1
	JRST CPOPK		;NO GOOD
	JRST CPOPK1

TRNSTB:	EXP FNCDEL,FNCCPR,FNCUPD,FNCAPP,FNCRED,FNCEXC,FNCLOK,0

;THIS SUBROUTINE CHECKS THE LICENSE BITS TO SEE IF A JOB
;HAS SPECIAL ACCESS TO A FILE. ENTER WITH
;T1=FUNCTION DESIRED
;T2=PPN OF FILE (NAME IF UFD)
;T4=PROTECTION BITS. BIT 0=1 IF UFD
;J=JOB NUMBER
;P2=ATB ADDRESS
;RETURNS CALL+1 IF OK
;RETURNS CALL+2 IF NOT OK
;CHECKS ALL CHANGE PROTECTION OPERATIONS

INTERN CHKPRJ
CHKPRJ:	CAME T2,ACTPPN	;IS IT FOR AN ACCOUNTING FILE??
	JRST CHKNAC	;NO
	MOVSI T3,LICJAL
	TDNN T3,JBTLIC(J)
	JRST CHKNAC	;JACCT NOT ON
	POPJ P,			;YES, ALL OPS OK (KLUDGE)

CHKNAC:	CAILE T1,FNCRED
	JRST CHKNRD	;NOT A READ
	LDB T3,JBYRPT
	CAILE T3,1	;CAN HE READ ALL FILES??
	POPJ P,
	CAIE T3,1	;READ IN PROJ??
	JRST CHKWRT	;NO, CHECK WRITE ABILITIES (IMPLY READ)
	MOVE T3,JBTAUN(J)
	XOR T3,T2
	TLNE T3,-1
	JRST CHKWRT	;NOT IN PROJECT
	POPJ P,

CHKWRT:	JUMPGE T4,CHKWR1	;WRITE OF UFDS IS SPECIAL
	MOVE T3,JBTLIC(J)
	TLNE T3,LICJAL
	POPJ P,		;OK SINCE HAS JL
	CAIN T1,FNCCPR		;-AAA. IF RENAME(CH PROT)
	JRST CHKWR1		;-SEE ABOUT WF,WPJ
	TLC T3,LICWFL+LICWPJ	;WRITE ABSOLUTE
	TLCE T3,LICWFL+LICWPJ	;SUPER USETO MAKE IT OK TOO
	AOS (P)
	POPJ P,
CHKWR1:	LDB T3,JBYWPT	;GET HIS WRITE LICENSES WFL, WPJ
	CAILE T3,1
	POPJ P,		;HAS WF
	CAIE T3,1
	JRST CHRMT		;TRY FOR A REMOTE BIT
	MOVE T3,JBTAUN(J)
	XOR T3,T2
	TLNE T3,-1
	JRST CHRMT		;NOT FORM HERE, TRY REMOTE
	POPJ P,		;ALL FUNCTIONS ARE OK
CHKNRD:	CAIE T1,FNCCPR	;IS IT CHANGE PROTECTION??
	JRST CHKWRT	;NO
			;OWNER CAN ALWAYS CHANGE PROTECTION EXCEPT WHEN
			; FILE HAS PID - THEN NO ONE EXCEPT PROCESSOR CAN.
	SKIPN	T3,ATBPID(P2)	;THIS FILE HAVE A PID?
	JRST	CHKNR1		;NO.
	CAME	T3,%UPT+UPTPID	;YES. PUNT IF DOESN'T MATCH REQUESTOR'S PID
	JRST	CHKWRT		;TREAT HF PROGRAM JUST LIKE OWNER - ELSE
				; OWNER COULD WRITE HF PROG TO CHANGE PROTECTION
				; ON FILES WITH PIDS IN HIS AREA.
	MOVSI	T3,PIDACC	;ALSO PUNT IF JOB DIDN'T REQUEST PID ACCESS
	TDNN	T3,DEVIAD(F)	;SKIP IF ASKED FOR PID ACCESS
	JRST	CHKWRT		;DID NOT.
CHKNR1:	MOVE T3,JBTPPN(J)
	XOR T3,T2
	TDNN T3,[XWD INDPPN,-1]
	POPJ P,		;OK, BUUT STORE NOTHING
	PUSHJ P,RMTCHK	;IS IT A REMOTE PROGRAM
	JRST CHKWRT	;NO, CHECK WRITE
	POPJ P,		;YES, TREAT LIKE OWNER

CHRMT:	PUSHJ P,RMTCHK	;IS IT A REMOTE PROGRAM??
	JRST CHKPID	;NO, SEE IF THIS IS A PROCESSOR FOR FILE'S PID
	LDB T3,[POINT 3,T4,29]	;GET OWNERS PROTECTION
	SKIPL T4	;IS IT UFD??
	SKIPA T3,TRNSTB(T3)	;NO, TRANSLATE
	MOVEI T3,FNCRED	;YES, READ (PROTECTION CH. CAUGHT ABOVE)
	CAML T3,T1
	POPJ P,		;YES, HE DID

;HERE TO SEE IF THIS IS THE PROCESSOR FOR FILE'S PID

CHKPID:	SKIPE	T3,ATBPID(P2)	;IF FILE DOES NOT HAVE A PID,
	CAME	T3,%UPT+UPTPID	;OR IF NOT THE PROCESSOR
	JRST	CPOPJ1		;THEN NO ACCESS TO BE GIVEN.
	MOVSI	T3,PIDACC	;IS THE PROCESSOR, DID HE ASK FOR PID ACCESS?
	TDNN	T3,DEVIAD(F)	;SKIP IF HE DID.
	AOS	(P)		;THEN NO ACCESS TO BE GIVEN.
	POPJ	P,		;ELSE ALL FUNCTIONS ARE OK.

;SUBROUTINE TO SET T3 AS A BYTE POINTER TO T4 DEPENDING ON
;WHETHER THIS IS OWNER, SAME PROJ, OTHER
;T2 HAS PPN OF FILE (OR UFD). CHANGES T2

GETPTR:	CAMN T2,JBTAUN(J)
	TDZA T2,T2	;ALLOW ACCESS TO HOME DIR IF GFD'D
	XOR T2,JBTPPN(J)
	MOVE T3,[POINT 3,T4,29]
	TDNN T2,[XWD INDPPN,-1]	;OWNER??
	POPJ P,		;YES
	TLNE T2,-1	;SAME PROJ??
	IBP T3		;NO 2 IBPS
	IBP T3	;YES 1 IBP
	POPJ P,

;CHECK TO SEE IF REMOTE BIT ON AND PROGRAM CAME FROM
;CORRECT FILE DIRECTORY. WORKS ONLY ON SHR SEG FOR NOW
;SKIP RETURN IF REMOTE SO TREAT AS OWNER

RMTCHK:	MOVSI T3,LICRMT
	TDNN T3,JBTLIC(J)
	POPJ P,		;BIT NOT EVEN ON
	MOVE T3,JBTFPN(J)	;WHERE HE CAME FROM
	CAMN T3,T2		;SAME AS T2
	AOS (P)		;YES SKIP
	POPJ P,

COMMENT ! ROUTINE CHKACC
PURPOSE: CHECK PROTECTION VS. DESIRED FUNCTION IN GET/RUN CODE.
FUNCTION: SKIP IF THE T1/FUNCTION IS ALLOWED ON THE FILE
EXPECTS: F/DDB  T1/FUNCTION J/JOB T2/DEVPPN(F) 
	T4/PROT FIELD RETURNED BY LOOKUP ON THE FILE
DESTROYS: T2,T3
!

CHKACC:
	PUSH P,P2	;SAVE P2, AND SETUP ATB ADDRESS
	HRRZ P2,DEVATB(F)
	PUSHJ P,CHKPRJ	;SEE IF LICENSES ALLOW T1/FUNC
	JRST [POP P,P2	;YES, RESTORE P2 AND RETURN
	      JRST CPOPJ1]
	POP P,P2	;GET OLD P2 BACK.
	PUSHJ P,GETPTR
	LDB T2,T3
	MOVE T2,TRNSTB(T2)
	CAMG T1,T2
	JRST CPOPJ1
	POPJ P,
SUBTTL ATB ADDRESS AND POINTER MANIPULATION

;ROUTINES TO HANDLE ATB POINTERS AND ADDRESSES
;ROUTINE TO CONVERT ATB POINTER TO ATB ADDRESS. CALLED WITH
; ATB POINTER IN T1

EXTERNAL CMBSIZ,CORBAS,DABSIZ,JBTDAB,DABOFS

XP DABBIT,10000		;THE THIRTEENTH BIT FLAGS A DUMMY POINTER
XP OFSATP,1		;OFFSET SO THAT NO ATB POINTER IS ZERO

CNVATP::SKIPN	T1		;MUST BE NON-ZERO
	STOPCD(SLO)			;BAD POINTER
	TRZE	T1,DABBIT	;IS THIS A DUMMY ATB POINTER
	PJRST	JB1ATB		;YES, GO GET THE DUMMY ADDRESS
	SUBI	T1,OFSATP	;OFFSET BY SOME AMOUNT
	IMULI	T1,CMBSIZ	;GET OFFSET FROM START OF FILSER CORE
	ADD	T1,CORBAS	;GET ACTUAL ATB ADDRESS
	POPJ	P,		;AND RETURN WITH IT IN T1.

;ROUTINE TO RETURN JOB'S ATB ADDRESS IN T1

JOBATB::MOVE	T1,J		;GET JOB NUMBER IN T1
JB1ATB:	SUBI	T1,1		;NONE FOR JOB 0
	IMULI	T1,DABSIZ	;SIZE OF ONE DUMMY ATB
	ADDI	T1,JBTDAB-DABOFS ;ADD ADDRESS OF JOB TABLE, SUBTRACT
				; FUDGE FACTOR SO IT LOOKS LIKE REAL ADDRESS
	POPJ	P,		;RETURN WITH ADDRESS IN T1

;ROUTINE TO CONVERT A REAL ATB ADDRESS INTO ATB POINTER

INTERN CNVATB

CNVATB:	SUB	T1,CORBAS	;RELATIVE TO START
	IDIVI	T1,CMBSIZ	;MAKE CORE BLOCK NUMBER
	ADDI	T1,OFSATP	;MUST BE OFFSET FROM ZERO
	POPJ	P,		;RETURN.

;TO CONVERT DUMMY ATB ADDRESS TO POINTER, JUST
; DO MOVEI T1,DABBIT(J).
COMMENT ;@@SUBROUTINE DECRMV
@@PURPOSE MANIPULATE THE ATB/SPT/DRB DATA WHEN A PAGE
IS BEING VREMOVED. DECREMENTS ATB UNSHARED MAP COUNTI AND MAX WRITE COUNT
(ATBUMC AND ATBMXW) IF NECESSARY, GETS RID OF ATB IF NECESSARY,
REMOVES SPT ENTRY FOR THE PAGE IF NECESSARY
@ENTRY P3,P4 CONTAIN LMAP SLOT DATA.  MUST BE INACTIVE.
CALLER HAS THE SAT FOR THE SLOT'S DP LOCKED. NOT NECESSARY
FOR THIS ROUTINE, BUT NECESSARY FOR CALLER.
@ACCUM USES T1-T4, PRESERVES ALL OTHERS.
@@EXIT P3 AND P4 UNCHANGED.
SKIP RETURN IF THIS IS THE LAST SLOT USING THE DP, OTHERWISE
NON-SKIP.
@@CALLS SRCSPT, REMSPT, DECUMC, GETCBR,GIVCB?
@@FUNCTION IF LMAP SLOT IS ACTIVE OR SUPER, CRASH.
GET THE ATB ADDRESS IN P2. DECREMENT MAX WRITE COUNT AND
IF IT GOES TO ZERO, CLEAR ATPMXU IN ATBSTS.
IF SLOT IS UNSHARED, SEARCH SPT
FOR THE DP. IF NOT IN THE SPT, DECREMENT ATBUMC (DECUMC)
AND GIVE THE SKIP RETURN (LAST USER).
IF IN THE SPT, DECREMENT THE USE COUNT. IF IT GOES
TO ZERO, REMOVE THE SPT ENTRY AND GIVE THE SKIP RETURN.
IF SPT COUNT STILL NON-ZERO, GIVE NON-SKIP RETURN.
@@;

EXTERNAL LMPACT,GETATB,LM3SPB,LM3SPO,SPTEN1,GETDPA,SPTUSC
EXTERNAL SPMUSC

DECRMV::JSP	T4,SAVE2	;! SAVE P1 AND P2
	TLNE	P3,LMPACT!LMPSUP ;! SLOT MUST BE INACTIVE, BECAUSE
	STOPCD(SLO)			;! WE'RE DECREMENTING UMC OR SPTUSC
	PUSHJ	P,GETATB	;! GET ATB ADDRESS IN T1
	MOVE	P2,T1		;! SAVE IT IN P2 FOR LATER
	PUSHJ	P,GETCBR	;! GET CB, DIDDLING WITH ATBS
	TLZN	P3,LMPMXW	;%! MAX WRITE ON FOR THIS SLOT?
	JRST	DECRM4		;%! NO, LEAVE ATB MWC ALONE.
	SOS	T2,ATBMWC(P2)	;%! YES, DECREMENT COUNT, ONE LESS WRITER
	TRC	T2,ATMMWC	;%! HAS IT OVERFLOWED?
	TRCN	T2,ATMMWC	;%! (ALL BITS GO TO 1)
	STOPCD(SLO)			;%! YES, CRASH
	MOVEI	T3,ATPMXU	;%! GET READY TO CLEAR THE UP BIT
	TRNN	T2,ATMMWC	;%! IF COUNT WENT TO ZERO,
	ANDCAM	T3,ATBSTS(P2)	;%! CLEAR THE UP BIT IN ATBSTS
DECRM4:	JUMPGE	P3,DECRM1	;%! JUMP IF SLOT IS UNSHARED
	LDB	T1,LM3SPB	;%! SLOT SHARED, GET SPT TABLE BASE
	LDB	T2,LM3SPO	;%! AND OFFSET
	ADDI	T1,SPTEN1(T2)	;%! GET ADDRESS OF ENTRY
	LDB	T4,LM3SPT	;%! REMSPT NEEDS POINTER IN T4
	JRST	DECRM2		;%! AND GO DECREMENT SPT COUNT

DECRM1:	PUSHJ	P,GETDPA	;%! GET DP ADDRESS TO SEARCH SPT FOR
	PUSHJ	P,SRCSPT	;%! SEE IF ITS THERE
	  JRST	DECRM3		;%! NO, GO DECREMENT ATBUMC
DECRM2:	SOS	T2,SPTUSC(T1)	;%! ONE LESS USER,
	TRNE	T2,SPMUSC	;%! SKIP IF ITS THE LAST
	PJRST	GIVCBR		;%! NOT THE LAST, JUST RETURN
	PUSHJ	P,REMSPT	;%! LAST USER, DELETE ENTRY
	PJRST	GIVCB1		;%! AND TELL CALLER THIS WAS LAST.

DECRM3:	PUSHJ	P,DECUMC	;%! WASN'T IN SPT, UMC WAS UP FOR IT
	PJRST	GIVCB1		;%! SO DECREMENT AND RETURN.
SUBTTL SPT HANDLING ROUTINES

COMMENT ;@@SUBROUTINE INSSPT
@@PURPOSE CREATE AN SPT ENTRY. ONLY HAPPENS WHEN
A USER DOES A MAP AND FINDS THE "M" BIT IN THE SAT ON.
@@ENTRY T1/ATB ADDRESS
T2/ DISK PAGE ADDRESS (RBMASK OFF)
@@ACCUM PRESERVES T2, SMASHES T1,T3,T4.
@@EXIT T1/SPT ENTRY ADDRESS
T4/SPT ENTRY POINTER (BASE AND OFFSET)
NON-SKIP RETURN WHEN ENTRY IS INSERTEC SUCCESSFULLY.
@@CALLS GETWDS
@@RESTRICTIONS CALLER MUST BE SURE THAT AN SPT ENTRY DOES NOT
ALREADY EXIST FOR DP. UMC MUST BE INCREMENTED FOR DP DUE
TO OTHER USER OF DP. MAY RESCHEDULE TO GET FREE CORE.
@@FUNCTION TRY TO FIND AN SPT TABLE WITH A FREE ENTRY SLOT.
IF FIND ONE, STORE DISK ADDRESS IN SPT ENTRY, SET USE COUNT
TO 2 (ONE FOR THE CALLER, ONE FOR THE USER WHO CAUSED THE M
BIT TO BE SET). DECREMENT ATBUMC (CALL DECUMC) SO THAT
THE UNSHARED USER WILL NOT HAVE TO DECREMENT IT. RETURN
THE ENTRY ADDRESS AND POINTER, GIVE SKIP RETURN.
IF NO FREE SPT SLOTS, ALLOCATE A NEW SPT TABLE, INITIALIZE IT,
AND USE THE FIRST FREE SPT ENTRY IN IT. IF THIS NEW
SPT TABLE IS THE ONLY ONE LINKED TO THE ATB, LEAVE ATBUMC INCREMENTED,
SINCE MUST DECREMENT IT FOR THE ORIGINAL USER AND THEN INCREMENT
IT BECAUSE AN SPT CAME INTO EXISTENCE. ELSE, DECREMENT
ATBUMC WITH DECUMC. GIVE SKIP RETURN WITH ENTRY ADDRESS IN T1
AND POINTER IN T4. (ERROR RETURN IS GIVEN IF COULD NOT
CREATE ANOTHER SECTION OF SPT).
@@;

EXTERNAL ATBSPT,SPTLNK,SPYNFE,SPTEN1,SPTNME,SPTUSC,SPTPNO
EXTERNAL SPTNFE,SPTEN1,SPNBAS,SPTSIZ,GETWDS,SPTATB,SPTNMM
EXTERNAL SPNNFE,SPTBLN
EXTERNAL FCWAIT,FCREQ,RBMASK

INSSPT::TLNE	T2,RBMASK	;BAD BITS OFF?
	STOPCD	(SLO)		;NO
	PUSHJ	P,GETCBR	;GET CB
	MOVEI	T4,ATBSPT-SPTLNK(T1) ;% GET FAKE PREDECESSOR ADDR.

INSSP1:	HLRZ	T4,SPTLNK(T4)	;% GET NEXT SPT SECTION ADDRESS
	JUMPE	T4,CRESPT	;% COULDN'T FIND FREE ENTRY, GO CREATE NEW SECTION
	LDB	T3,SPYNFE	;% GET NUMBER OF FREE ENTRIES IN THIS SECTION
	JUMPE	T3,INSSP1	;% NONE FREE, THEN LOOK AT NEXT SECTION

;FOUND A SECTION WITH A FREE ENTRY IN IT. DECREMENT ATBUMC BY
; CALLING DECUMC AND FIND THE FREE ENTRY

INSSP2:	PUSH	P,P2		;% SAVE P2
	MOVE	P2,T1		;% GET ATB ADDRESS INTO P2 FOR DECUMC
	PUSHJ	P,DECUMC	;% DECREMENT ATBUMC. ATB WILL NOT GO AWAY
				;%  BECAUSE UMC IS UP FOR THE SPT
	POP	P,P2		;% P2 COMES BACK

	MOVEI	T1,SPTEN1(T4)	;% GET ADDRESS OF FIRST ENTRY
	HRLI	T1,-SPTNME	;% HAVE TO LOOK AT ALL ENTRIES

INSSP3:	SKIPN	SPTUSC(T1)	;% IS THIS A FREE ONE?
	JRST	INSSP4		;% YES, GO STUFF DATA INTO IT
	AOBJN	T1,INSSP3	;% NO, KEEP GOING
	STOPCD(SLO)			;% BUT THE COUNT SAID THERE WAS A FREE ONE!

;HERE WHEN WE HAVE FOUND BOTH SECTION AND THE FREE ENTRY

INSSP4:	MOVEM	T2,SPTPNO(T1)	;% PUT IN THE DP
	MOVEI	T3,2		;% USE COUNT SET TO 2 ONE FOR US,
	MOVEM	T3,SPTUSC(T1)	;% AND ONE FOR ORIGINAL MAPPER.
	SOS	SPTNFE(T4)	;% ONE LESS FREE ENTRY IN HERE
	AOS	(P)		;% SKIP RETURN
	PUSHJ	P,GIVCBR	;GIVE BACK CB

;HERE ALSO FROM SRCSPT TO RETURN SPT ENTRY ADDR AND POINTER IN
; T1 AND T4, RESPECTIVELY, AND GIVE SKIP OR NON-SKIP RETURN

SPTRET:	HRRZS	T1		;GET RID OF -VE COUNT
	MOVEI	T3,SPTEN1(T4)	;GET ADDRESS OF FIRST ENTRY
	LSH	T4,^D35-SPNBAS	;POSTION SECTION ADDRESS PROPERLY
	SUBM	T1,T3		;GET OFFSET FROM FIRST ENTRY
	ADD	T4,T3		;T4 IS POINTER, HAS BASE AND OFFSET
	POPJ	P,		;RETURN TO CALLER.
;MORE OF INSSPT

;HERE WHEN ALL SPT SECTIONS ARE FULL. CREATE A NEW SPT
; SECTION. SPT SECTIONS COME FROM THE SAME FREE CORE
; THAT DDBS COME FROM, NOT FROM FILSER FREE CORE.

;T1 HAS ATB ADDRESS

CRESPT:	PUSH	P,T1		;SAVE ATB ADDRESS
	PUSH	P,T2		;AND CALLER'S DP ADDRESS
CRESP0:	MOVEI	T2,SPTSIZ	;HOW BIG AN SPT IS
	SKIPGE	FCREQ		;NEED TO WAIT? IF SO, SKIP AND WAIT
	PUSHJ	P,GETWDS	;GET THE CORE
	 JRST	[POP	P,T2
		POP	P,T1
		JRST	GIVCBR]
	POP	P,T2		;GET T2 BACK OFF STACK
	POP	P,T4		;GET ATB ADDRESS IN T4
	EXCH	T1,T4		;ATB IN T1, BASE OF SECTION IN T4

	HLRZ	T3,ATBSPT(T1)	;GET OLD FIRST SPT SECTION
	JUMPE	T3,CRESP1	;GO IF WE'RE CREATING FIRST ONE
				; LEAVE ATBUSC INCREMENTED TO REPRESENT
				; THE SPT'S EXISTENCE.
	PUSH	P,P2		;ALREADY AN SPT, DECREMENT
	MOVE	P2,T1		;ATB IN P2 FOR DECUMC
	PUSHJ	P,DECUMC	;DECREMENT THE COUNT THAT ORIGINAL
	MOVE	T1,P2		;GET ATB ADDRESS BACK IN T1
	HLRZ	T3,ATBSPT(T1)	;AND SPT OLD FIRST IN T3
	POP	P,P2		; MAPPER INCREMENTED IN ATB
CRESP1:	HRL	T3,T1		;T3/ ATB ADDR,,OLD FIRST SECTION
	MOVSM	T3,SPTLNK&SPTATB(T4) ;SET FORWARD LINK AND ATB BACK POINTER
	TRNE	T3,-1		;IF THERE IS AN OLD FIRST,
	HRLM	T4,SPTBLN(T3)	;IT SHOULD POINT BACK TO NEW FIRST.
	MOVSI	T3,ATBSPT-SPTLNK(T1) ;GET PHONEY BACK POINTER
	HRRI	T3,SPTNMM	;MAKE ALL ENTRIES FREE (SPTNME<B>SPNNFE)
	MOVEM	T3,SPTNFE&SPTBLN(T4)     ;SET NO. FREE ENTRIES AND BACK LINK
	HRLM	T4,ATBSPT(T1)	;AND FINALLY POINT THE ATB TO IT.

;NOW CLEAR THE ENTRIES

	HRLI	T3,SPTEN1(T4)	;FIRST ADDRESS
	HRRI	T3,SPTEN1+1(T4)	;1ST,,2ND
	SETZM	-1(T3)		;CLEAR 1ST (2ND-1)
	BLT	T3,SPTEN1+SPTNME*2-1(T4) ;ZERO ALL
	MOVEI	T1,SPTEN1(T4)	;GET ENTRY ADDRESS (BASE IS IN T4)
	JRST	INSSP4		;AND GO STICK DATA INTO ENTRY.
COMMENT ;@@SUBROUTINE REMSPT
@@PURPOSE DELETE AN SPT ENTRY
@@ENTRY T4 CONTAINS SPT POINTER (BASE AND OFFSET)
@@ACCUM PRESERVES T2, SMASHES T1,T3,T4.
@@EXIT ALWAYS NON-SKIP
@@CALLS DECUMC
@@RESTRICTIONS CALLER MUST HAVE CB
@@FUNCTION CLEAR USE COUNT WORD OF ENTRY, MAKING IT FREE.
INCREMENT COUNT OF FREE ENTRIES. IF ALL ENTRIES IN THIS
SPT SECTION ARE NOW FREE, SO UNLINK THIS SECTION AND GIVE
THE FREE CORE BACK.
@@;

EXTERNAL SP4BAS,SP4OFS,SPTEN1,SPTUSC,SPTVIR,SPTPNO
EXTERNAL SPMNFE,SPTBLN,SPTLNK,SPTATB,ATBSPT,SPTSIZ,GIVWDS

REMSPT::LDB	T1,SP4BAS	;% GET SECTION ADDRESS
	LDB	T3,SP4OFS	;% AND OFFSET
	MOVE	T4,T1		;% T4 HAS SECTION ADDRESS NOW
	ADDI	T1,SPTEN1(T3)	;% T1 GETS ADDRESS OF ENTRY

	SETZM	SPTUSC&SPTVIR(T1) ;% CLEAR OUT WHOLE COUNT WORD
	SETZM	SPTPNO(T1)	;% MAKE SURE DP IS ZERO FOR SRCSPT
	AOS	T3,SPTNFE(T4)	;% INCREMENT NUMBER OF FREE ENTRIES
	TRCN	T3,SPMNFE	;% IF FIELD WENT TO 0, WE HAVE
	STOPCD(SLO)			;%  AN OVERFLOW
	TRCE	T3,SPMNFE	;% OK. ALL BITS SET? (ZERO)
	POPJ	P,		;% NO, STILL SOME ENTRIES HERE.

;HERE WHEN THE SPT SECTION IS NOW DEVOID OF ANY ENTRIES.

	HLRZ	T3,SPTBLN(T4)	;% GET PRED. ADDR (MAY POINT TO ATBSPT)
REMSP1:	HLL	T3,SPTLNK(T4)	;% T3/NEXT(MAYBE 0),,LAST(MAY BE ATBSPT)
	HLLM	T3,SPTLNK(T3)	;% PRED. FORWARD LINK TO NEXT
	MOVSS	T3		;% T3/LAST,,NEXT
	TRNE	T3,-1		;% IS THERE REALLY A NEXT?
	HLLM	T3,SPTBLN(T3)	;% YES, POINTS BACK TO LAST

;NOW SEE IF THIS WAS THE LAST SPT SECTION ON THE ATB. IF SO,
; MUST DECREMENT ATBUMC BECAUSE THERE IS NO MORE SPT.

	HRRZ	T1,SPTATB(T4)	;% GET ATB ADDRESS FROM OLD SECTION
	HLRZ	T3,ATBSPT(T1)	;% ALL THE SPT SECTIONS GONE?
	JUMPN	T3,REMSP2	;% JUMP IF NOT
	PUSH	P,P2		;% ALL GONE, CAL DECUMC
	MOVE	P2,T1		;% IT WANTS ATB IN P2
	PUSHJ	P,DECUMC	;% MAYBE ATB WILL GO AWAY.
	POP	P,P2		;% BURMA SHAVE

REMSP2:	PUSH	P,T2		;% SAVE T2 FROM GIVWDS, WHICH DESTOROYS EVERYTHINK
	MOVEI	T1,SPTSIZ	;% NUMBER OF WORDS TO GIVE BACK
	MOVE	T2,T4		;% GET ADDRESS IN T2
	PUSHJ	P,GIVWDS	;% GIVE BACK CORE
	POP	P,T2		;% RESTORE PRECIOUS DISK ADDRESS
	POPJ	P,		;% AND RETURN.
COMMENT ;@@SUBROUTINE SRCSPT
@@PURPOSE SEE IF A DP HAS AN SPT ENTRY.
@@ENTRY T1/ATB ADDRESS
T2/ DP ADDRESS TO SEARCH FOR (RBMASK OFF)
@@ACCUM PRESERVES T2, USES T1,T3,T4.
@@EXIT NON-SKIP IF DP IS NOT IN SPT. SKIP RETURN IF DP IS IN SPT,
WITH T1 CONTAINING ENTRY ADDRESS AND T4 CONTAINING ENTRY POINTER.
@@FUNCTION SEARCH EACH SPT SECTION FOR AN ENTRY THAT HAS
A MATCHING DISK ADDRESS. DON'T FORGET THAT SPTS ARE SPARSE.
SEARCH ASSUMES THAT SEARCH WILL FAIL WITHIN MOST SPT
SECTIONS, SO THAT WE WILL HAVE TO LOOK AT SPTNME WORDS
AT LEAST, MOST OF THE TIME. ASSUME TABLE ENTRIES ARE NOT
GROUPED TOGETHER, BUT ARE SEPERATED, SO THAT IT WOULD
NOT HELP BY CUTTING OFF SEARCH AFTER WE HAVE FOUND
<NUMBER OF ENTRIES> VALID ENTRIES.
@@;

EXTERNAL ATBSPT,SPTLNK,SPYNFE,SPTEN1,SPTPNO,RBMASK

SRCSPT::TLNE	T2,RBMASK	;BAD BITS OFF?
	STOPCD(SLO)			;NO
	MOVEI	T4,ATBSPT-SPTLNK(T1) ;START OFF WITH THIS THING
SRCSPA:	HLRZ	T4,SPTLNK(T4)	;GET NEXT SECTION ADDRESS
	JUMPE	T4,CPOPJ	;NOT IN SPT.
	MOVSI	T1,-SPTNME	;SEARCH WHOLE TABLE, ASSUMING ITS
				; USUALLY BEEN FILLED, MAYBE MADE SPARSE
	HRRI	T1,SPTEN1(T4)	;GET FIRST ENTRY ADDRESS
SRCSP2:	CAMN	T2,SPTPNO(T1)	;ONE WE'RE LOOKING FOR?
	JRST	SRCSP4		;GO MAKE SURE ITS A REAL ENTRY
SRCSP3:	AOBJN	T1,SRCSP2	;NO, LOOK SOME MORE.
	JRST	SRCSPA		;NOT IN THIS SECTION, CHECK NEXT SECTION

;HERE WHEN DISK ADDRESS AND SPT ENTRY DISK ADDRESS MATCH.
; IF THE PAGE IS PAGE 0, MAKE SURE USE COUNT IS
; NON-ZERO (A REAL ENTRY)

SRCSP4:	JUMPN	T2,SRCSP5	;NON-ZERO, ITS REAL
	SKIPN	SPTUSC(T1)	;IS THE ENTRY REAL?
	JRST	SRCSP3		;NO, KEEP LOOKING
SRCSP5:	AOS	(P)		;GIVE SKIP RETURN, WE FOUND IT.
	PJRST	SPTRET		;YES, RETURN WITH IT.
SUBTTL UNSHARED MAP COUNT HANDLING

COMMENT ;@@SUBROUTINE INCUMC
@@PURPOSE INCREMENT ATBUMC, AND IF IT WAS ZERO INCREMENT
DRBCNT.
@@ENTRY T1/ATB ADDRESS
@@ACCUM PRESERVES T1,T2,T4 SMASHES T3
@@EXIT NON-SKIP RETURN.
@@FUNCTION INCREMENT ATBUMC, CRASH IF OVERFLOW. IF
ATBUMC WENT FROM 0 TO 1 AND ATB IS FOR A FILE,
INCREMENT DRBCNT. RETURN.
@@;

EXTERNAL ATPUMC,ATBUMC,ATMUMC,ATBFNB,FNBDRB,DRBCNT,DRPMXC
EXTERNAL ATBDUM

INCUMC::MOVSI	T3,ATPUMC	;GET COUNT BIT
	ADDB	T3,ATBUMC&ATBDUM(T1)
				;INCREMENT UMC
	TLNN	T3,ATMUMC	;IF ALL WENT TO 0,
	STOPCD(SLO)			;ITS AN OVERFLOW
	TLNE	T3,ATPDUM!ATMUMC-1 ;COUNT NOW = 1 AND FILE ATB?
	POPJ	P,		;NO, JUST RETURN
	HRRZ	T3,ATBFNB(T1)	;YES, GET DRB ADDRESS
	HRRZ	T3,FNBDRB(T3)
	AOS	T3,DRBCNT(T3)	;INCREMENT DRB COUNT
	TRNE	T3,DRPMXC	;OVERFLOW?
	STOPCD(SLO)
	POPJ	P,		;NO, RETURN.
COMMENT ;@@SUBROUTINE DECUMC
@@PURPOSE DECREMENT ATBUMC WHEN AN SPT IS DESTROYED,
WHEN SPT ENTRY IS CREATED AND SPT ALREADY EXISTED, OR
WHEN A PAGE IS REMOVED THAT IS NOT IN AN ATB'S SPT.
@@ENTRY P2/ ATB ADDRESS
CALLER GOT CB RESOURCE. CALLER ALSO HAS SAT FOR THE DP
HE IS REMOVING LOCKED, ALTHOUGHT THIS IS NOT NECESSARY
FOR DECUMC.
@@ACCUM USES T1,T3. PRESERVES T2,T4.
@@EXIT ATB ADDRESS STILL IN P2
STILL HAVE CB
@@CALLS FREATB OR LKDATB
@@FUNCTION DECREMENT ATBUMC, CRASH IF IT UNDERFLOWS.
IF ATB IS A DUMMY ATB OR COUNT IS NOT ZERO, RETURN.
OTHERWISE DECREMENT DRB COUNT, CRASH IF UNDERFLOW.
IF ATB IS MARKED FOR DELETION AND THERE ARE NO MORE
USERS OF ATB, GIVE IT BACK TO FREE CORE. ELSE IF NO
MORE USERS OF ATB, PUT ATB ON DORMANT LIST.
@@;

DECUMC::MOVSI	T1,-ATPUMC	;%! GET DECREMENTING VALUE
	ADDB	T1,ATBUMC&ATBSTS&ATBDUM(P2)
				;%! (WILL USE THIS AS ATBSTS LATER,
				;%! SO GET ATBSTS INTO CREF)
				;%! DECREMENT THE COUNT
	TLC	T1,ATMUMC	;%! SEE IF ALL BITS WENT TO 1
	TLCN	T1,ATMUMC	;%! DID THEY?
	STOPCD(SLO)			;%! YES, UNDERFLOW
	HLRZ	T3,ATBSPT(P2)	;%! GET POSSIBLE SPT SECTION ADDRESS
	JUMPE	T3,DECUM0	;%! IF NONE, OK
	TLNN	T1,ATMUMC	;%! IF STILL AN SPT AND COUNT IS 0
	STOPCD(SLO)			;%! CRASH.
DECUM0:	TLNE	T1,ATPDUM!ATMUMC ;%! IF THIS IS DUMMY ATB OR COUNT STILL UP
	POPJ	P,		;%! JUST RETURN.
	HRRZ	T3,ATBFNB(P2)	;%! GET DRB ADDRESS
	HRRZ	T3,FNBDRB(T3)	;%! HAVE IT NOW
	SOS	T3,DRBCNT(T3)	;%! DECREMENT IT, SINCE UMC WENT TO ZERO
	TRNE	T3,DRPMXC	;%! UNDERFLOW?
	STOPCD(SLO)			;%! YES.
	TRNE	T1,ATPMXU!ATMCNT!ATPUPD!ATPREN!ATPSUP!ATPCRE
				;%! ANY USERS OF ATB LEFT?
	POPJ	P,		;%! YES, DON'T TOUCH ATB
	PUSH	P,T2		;%! SAVE T2 AND P3
	PUSH	P,P3		;%! AS WE SAY WE PRESERVE THEM
	HRRZ	P3,ATBFNB(P2)	;%! P3 GETS FNB ADDR IN CASE CALL FREATB
	MOVEI	T2,LKDATB	;%! ASSUME IT GOES ON DORMANT LIST
	TRNE	T1,ATPDEL	;%! MARKED FOR DELETION?
	MOVEI	T2,FREATB	;YES, GOES BACK TO FREE CORE
	PUSHJ	P,(T2)		;%! PUT ON DORMANT OR FREE LIST
	POP	P,P3		;%! RESTORE THESE AND
	POP	P,T2		;%!
	POPJ	P,		;%! RETURN.
COMMENT ;@@SUBROUTINE DECUNS
@@PURPOSE TO DECREMENT ATBUMC,MXW, AND REMOVE SPT ENTRY FOR AN
UNSHARED DP SO THAT IT CAN BE MOVED TO ANOTHER FILE.
@@ENTRY P3,P4 CONTAIN LMAP SLOT DATA, ACTIVE OR INACTIVE.
T2/ DP
P2/ ATB OF OLD FILE (OR DUMMY ATB ADDRESS IF PRIVATE PAGE)
@@ACCUM USES T1-T4.
@@EXIT P3,P4 STILL CONTAINLMAP SLOT DATA - STATUS SET TO UNSHARED IF
ENTERED AS SHARED. LMYATB NO LONGER VALID.
SKIP IF PAGE WAS NOT BEING SHARED BY ANYONE. NON-SKIP IF PAGE WAS BEING
SHARED.
@@FUNCTION IF SLOT IS UNSHARED, SEARCH SPT FOR DP. IF DP IS IN SPT OR SLOT
IS SHARED, AND SPT SHARE COUNT IS NOT 1, GIVE NON-SKIP RETURN (MUST BE
GREATER THAN 1). ELSE DELETE SPT ENTRY (CALL REMSPT).
IF DP IS NOT IN SPT, DECREMENT ATBUMC.
DECREMENT ATBMXW IF MAX WRITE IS ON FOR SLOT.
(NOTE %=CB, !=SAT)
@@;
EXTERNAL ATBSTS,ATPMXU,ATMMWC,ATBMWC
EXTERNAL LMPMXW,LMPSHR,GETSPT


DECUNS::PUSHJ	P,GETCBR	;! GET CB WHILE MESSING WITH ATB AND SPT
	JUMPGE	P3,DECUN1	;%! IF SHARED, DON'T HAVE TO CHECK FOR SPT
				;%! EVEN IF ITS ACTIVE UNSHARED CAN'T GUARANTEE
				;%!  THAT IT DOESN'T HAVE AN SPT ENTRY,
				;%!  ACTLMA DOESN'T CHECK - ONLY PAGE FAULT.
	PUSHJ	P,GETSPT	;%! GET SPT ENTRY ADDRESS IN T1 FOR SHARED SLOT.
	JRST	DECUN2		;%! AND GO SEE IF ANYONE ELSE IS REALLY USING IT.
DECUN1:	MOVE	T1,P2		;%! GET ATB ADDRESS IN T1 FOR SRCSPT
	PUSHJ	P,SRCSPT	;%! SEE IF IT HAS AN SPT ENTRY
	  JRST	DECUN3		;%! NO SPT ENTRY, JUST DECREMENT COUNTS
DECUN2:	MOVE	T3,SPTUSC(T1)	;%! GET USE COUNT
	TRNE	T3,SPMUSC-1	;%! EQUAL TO 1? (CAN'T BE ZERO)
	PJRST	GIVCBR		;%! NO, JUST GIVE BACK CB AND GIVE NON SKIP RETURN.
	PUSHJ	P,REMSPT	;%! YES, GET RID OF ENTRY (MAYBE WHOLE SPT TABLE)
	TLNE	P3,LMPMXW	;%! MAX WRITABLE ON FOR THIS SLOT?
	PUSHJ	P,DECMXW	;%! YES, DECREMENT MAX WRITE COUNT
	TLZ	P3,LMPSHR	;%! SLOT NO LONGER SHARED (IF WAS AND WAS INACTIVE,
				;%!  LMYSPT IS NOW GARBAGE.
	JRST	GIVCB1		;%! GIVE SKIP RETURN.

DECUN3:	TLNE	P3,LMPMXW	;%! MAX WRITE ON?
	PUSHJ	P,DECMXW	;%! YES, DECREMENT MAX WRITE COUNT
	PUSHJ	P,DECUMC	;%! WASN'T IN SPT, DECREMENT ATBUMC, DRBCNT
				;%! ETC.
	PJRST	GIVCB1		;%! AND RETURN.

DECMXW:	SOS	T3,ATBMWC(P2)	;%! YES, DECREMENT IT
	TRC	T3,ATMMWC	;%! HAS IT OVERFLOWED?
	TRCN	T3,ATMMWC	;%!  (ALL BITS GO TO 1)
	STOPCD	(SLO)		;%! YES, CRASH
	MOVEI	T4,ATPMXU	;%! GET READY TO CLEAR MAX WRITE UP BIT
	TRNN	T3,ATMMWC	;%! COUNT STILL NON-ZERO?
	ANDCAM	T4,ATBSTS(P2)	;%! NOT ANYMORE, CLEAR THE BIT.
	POPJ	P,		;%! RETURN.


	END
4@5\a