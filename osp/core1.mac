TITLE CORE1 - LOGICAL AND PHYSICAL CORE ALLOCATION ROUTINES


ENTRY CORE1
CORE1:


	SALL		;CLEAN MACRO LISTINGS, GET AROUND
			; MACRO BUG THAT CAUSES COMMENTS AFTER
			; MACRO CALLS NOT TO COME OUT UNDER XALL.
DEFINE CALMAP
<>

;DEFINE PAGSTS UUO HERE UNTIL ITS INTO MACRO

OPDEF PAGSTS [CALLI -71]

;ERROR CODE MACRO

DEFINE ERRCOD(N,SYM,LABEL)<
	XP SYM,N
IFGE <7-N>,<XP LABEL,ERR0'N>
IFL <7-N>,<XP LABEL,ERR'N>
>;END ERRCOD MACRO DEFINITION.

	XP FL.USR,(1B0)		;FLAG IN UUOS THAT SAYS DO
				; PROTECTION CHECK ON VP FOR USER, NOT EXEC.

DEFINE LSTCHK<JFCL>	;MAKE SURE CORE LISTS ARE OK
;SMALL ROUTINE TO CLEAR ONCE MODULES OUT OF EXEC MAP.
INTERNAL CLRONC

CLRONC:	MOVEI	T1,3		;THREE MODULES.
	SETZ	T2,		;
CLRLOP:	MOVE	U,TBLSIZ-1(T1)	;GET U/ NO.
	LSH	U,-9		;OF PAGES IN THIS MODULE.
	MOVE	T3,TBLPTR-1(T1)	;T3/ SLOT BYTE PNTR.
	IDPB	T2,T3		;CLEAR A SLOT.
	SOJG	U,.-1		;CONTINUE FOR THIS MODULE.
	SOJG	T1,CLRLOP	;CONTINUE FOR ALL THREE MODULES.
	CLRPTA			;CLEAR ENTIRE PAGING MEMORY
	POPJ	P,		;RETURN.

DEFINE TBLS
< X ONC
  X OND
  X REF>

DEFINE X(A)
<A'LNP
EXTERN A'LNP>
TBLSIZ: TBLS

DEFINE X(A)
<EPTPGP (%'A'.N-1)>
TBLPTR: TBLS
;EXTERNAL DECLARATIONS

;EXTERNALS IN THE SWAPPER

EXTERNAL CAPPGN,RIPPGN,SWPIO,PROT
EXTERNAL PFLCNT,PFWCNT,PFICNT,VRACNT,TOTACT

;EXTERNALS IN COMMON FOR PGY TABLES

EXTERNAL PAGWAK	
EXTERN PGYADR,PGYBPL,PGYFPL,PGYCHT,PGYDIO,PGYDRT,PGYERR
EXTERNAL PGYLMJ,PGYLMV,PGYLST,PGYSIP,PGYSOP,PGYSPB,PGYSPO,PGYSPT,PGYUSE
EXTERNAL PGYATB,PGYPGO,PGYSIO
EXTERNAL PGYSTS,PGPSIP,PGPSOP,PGPDRT
EXTERNAL USRMAX

;EXTERNALS IN PICON

EXTERNAL TSTKTP,TAKTRP

;EXTERNALS IN COMMON FOR UPT

EXTERNAL UPTMWB,UPTUFI,UPTXFI,UPTUEI,UPTXEI,UPTUWB,VPUMAX,%SAT.C,%RIB.C
EXTERNAL UPTAGE, UPTELD, UPTMAT
EXTERNAL AGECPW, AGEMAX, AGESIZ
EXTERNAL AGEHST, AGEPTR
EXTERNAL %RB2.C,%UPS,%UPT,%UPLMS,%UPS.N,NCTXPG,%UPLMA,%COW,%COW.N
EXTERNAL %UPT.N,JBYSAL,JBYSLL,JBYPER,JBYREF
EXTERNAL UPTRPT,UPYUWL,UPYUWM,JBYPPP,JBYUWS,UPTLDC
EXTERNAL UPTURI,UPTXRI,UPTUII,UPTXII

;EXTERNALS IN COMMOD FOR SPT DEFINITIONS

EXTERNAL SPTATB,SPTEN1,SPTVIR,SPPVIR,SPTPNO

;EXTERNALS IN COMMON FOR LMAP DEFINITIONS

EXTERNAL LMYCUR,UP4LDA,LM3ATB,LM3CUR
EXTERNAL LM3CUR,LM3HDA,LM3LMJ,LM3LMV,LM3SPB
EXTERNAL LM3SPO,LM3SPT,LMASRP,LMMEXS,LMPACT,CLKCHL
EXTERNAL LMPREF,LMPSHR,LMPSUP,LMPVIR,LMPNER,UPTNTV
EXTERNAL CPRRDW,CPRCOW,CPRRED,MAXCPR
EXTERNAL LMPSHR,LMPACT,LM3ERR,LMMERR,LMPDER,LMPDTE
EXTERNAL LMPVIR,LMPMXW

;EXTERNALS IN CLOCK1, SCHED1

EXTERNAL WSCHED,SWQ,CALSWP,SIOCNT,SIOBOM,SIPTOT
EXTERNAL STLBTM		;BIT MAP FOR STOLEN PAGES.
EXTERNAL TIMEF

;MISCELLANEOUS IN COMMON

EXTERNAL SAVE3,BITTBL,JOB,CPOPJ,CPOPJ1,SAVE2,SAVE1
EXTERNAL TPOPJ1,WRTCHP,TPOPJ
EXTERNAL CURUPT,EPT,CTXTAB
IFCPU (KI),<EXTERNAL TIMCHN>
EXTERNAL PJBSTS,MWSLIM,USEMAX,ADRNCT,ADRDUM

;JOB TABLE DEFINITIONS IN COMMON

EXTERNAL JBTSTS,JBYMWL,JBYMWS,JBTCTX,JBTMPC,JBYRPT
EXTERNAL JBTPGO,JBTIOA,JBTPIP,JBYACT
EXTERNAL JBTAJF

;EXTERNALS IN FILE SYSTEM

EXTERNAL CNVATP,DABBIT,KREPLC,ATBSTS
EXTERNAL SRCSPT,ATPMXU,ATBMWC,ATMMWC,INCUMC
EXTERNAL RBMASK
EXTERNAL OHTNUM,SRCOHT,OHTDER,OHTDTE,OHTPAR,OHTTAB

;EXTERNALS IN ERRCON

;EXTERNALS IN COMMOD

EXTERNAL STRDDB,STRBTS,SRPNDS
SUBTTL CORUUO FOR VM SYSTEM

EXTERN IOWAIT,TIMADJ,HSEXIS,UPTREL,UPTHRL,KILLHS
EXTERN JOBREL,JOBHRL,STRTAL,CORXPN,KILPGS,STRDDB
EXTERN SG.SWR,UPTSTS,JBTUPM,PVYCOR

COMMENT ! ROUTINE CORUUO - KERNEL OF VM SYSTEM CORE UUO
PURPOSE: EXPAND/CONTRACT HIS CORE IMAGE BETWEEN 0 & JOBREL
	400000 & JOBHRL, ADJUST JOBREL/JOBHRL AND UPT COPIES,
	AND RETURN (AC)=ALLOWED CORE, IN 1K UNITS

EXPECTS:	T1/ HIARG,,LOARG	J/JOB   M/USER AC #
	UPTREL/ AS LEFT BY LAST CORE/RUN/RUNSEG (NOT 
		NECESSAIRILY LAST EXISTING ADDRESS IN "LOWSEG"--
		HE MAY HAVE VCREATED PAGES HIMSELF)
	UPTHRL/ AS LEFT BY LAST CORE/RUN/RUNSEG/REMAP ETC. 
	UPTSTS/ SG.SWR SET IF IMAGE MAPPED FROM .SWR FILE

FUNCTION:
1. JUST RETURN AVAIL CORE IN 1K IF T1= 0 ARG FROM USER
2. WAIT FOR ALL IO (MAG TAPE) TO STOP
3. USER WANTS LOWSEG SIZE CHANGED IF LOARG .NE. 0; ROUND
   IT TO NEXT 1K, EXPAND/CONTRACT AS NECESSARY. EXPAND MEANS
   VCREATE PAGES FROM PRESENT TOP OF SEGMENT UP TO ROUNDED
   LOARG VALUE. ANY FAILURE MEANS USER HAS A PAGE IN THERE 
   ALREDY OR IS GOING OVER SIZE LIMITS.  CONTRACT MEANS
   VCLEAR PAGES FROM ROUNDED LOARG+1 TO PRESENT END OF SEGMENT.
 SOULDNT   EVER FAIL
4. HE WANTS HISEG SIZE CHANGED IF HIARG.NE. 0; ROUND
IT UP; IF NO HISEG EXISTS BY HAVING DONE A REMAP,RUN,
GET,ETC., QUIT ERROR RETURN NOW. IF ROUNDED HIARG.LT.400000,
KILL (VCLEAR) ENTIRE HISEG & RETURN SIZE IN 1K.
5. IF HE WANTS TO EXPAND OR CONTRACT HIS HISEG, HE MAY ONLY
DO SO IF HE HAS MAX-WRITE PRIV TO ALL THE PAGES (BUT ONLY
PAGE 400 IS CHECKED). IF THE HISEG CAME FROM A .SWR FILE,
ERROR RETURN BECAUSE CORE UUO CANNOT CREATE SHAREABLE PAGES
WHICH IS WHAT OLD CORUUO DID; EXPAND/CONTRACT HIS PRIVATE
HISEG BY VCREATING OR VCLEARING PRIVATE PAGES.
6. RETURN SIZE IN 1K. SKIP RTN,SUCCESS

!

CORUUO::
	JUMPE T1,SIZCOR
	PUSH P,T1
	PUSHJ P,IOWAIT	;WAIT FOR ALL IO TO STOP
	PUSHJ P,TIMADJ	;ADJUST CHARGE & UPDATE SPACE-TIME COUNTS
	HRRZ T1,(P)	;T1_LOARG
	JUMPE T1,CORUHI	;NO CHANGE TO LOW SEG
	IORI T1,1777
	HRRM T1,(P)
	CAIGE T1,400000
	JRST CORLO1
	PUSHJ P,HSEXIS	;SKIP IF NO HS
	JRST CORERR	;HAS HS ALREADY, CANT ASK FOR >128K
CORLO1:	HRRZ T1,(P)	;T1/ REQUESTED HIGHEST ADDR
	HRRZ	T2,%UPT+UPTREL	;GET CURRENT HIGHEST ADDRESS
				;TRIED TO USE JOBREL, BUT DUMB LOADER WIPES IT OUT BEFORE DOING CORE UUO.
CORLO2:	PUSHJ P,CORXK	;EXPAND/CONTRACT 
	 JRST CORERR	;SOME TROUBLE
	HRRZ T1,(P)	;T1/NEW END LOW SEG
	HRRM T1,%UPT+UPTREL
	UXCTTU <MOVEM T1,JOBREL> ; XCT THIS
	
CORUHI:	HLRZ T1,(P)	;T1/HIARG
	JUMPE T1,COROK	;NO CHANGE TO HS
	IORI T1,1777
	HRLM T1,(P)
	PUSHJ P,HSEXIS	;SKIP IF NO HS
	JRST .+2
	JRST CORERR	;MAY NOT CREATE HS WITH CORUUO
	HLRZ T1,(P)
	CAIGE T1,400000
	 JRST [	PUSHJ P,KILLHS	;ZAP WHOLE HS
		JRST COROK]
	MOVE T2,%UPT+UPTSTS
	TLNE T2,SG.SWR	;CAN NEVER EXPAND/CONTRACT ".SWR" SEGMENT
	JRST CORERR
	HRRZ T2,%UPT+UPTHRL	;T2/CURRENT HIGHEST HS ADDR
			;T1/STILL HAS REQUESTED HIGHEST HS ADDR
	PUSHJ P,CORXK	;EXPAND/CONTRACT 
		;NOTE THAT ANY ADDED PAGES ARE PRIV RDW !
	 JRST CORERR	;SOME TROUBLE
	HLRZ T1,(P)	;NEW END OF HISEG
	HRRM T1,%UPT+UPTHRL	
	UXCTBU <HRRM T1,JOBHRL>	;LEAVE LH ALONE
COROK:	AOS -1(P)	;RETURN IS BEHIND HIARG,,LOARG AT (P)
CORERR:	POP P,T1	;FIX STACK. DO NOT NEED USERS ARG
SIZCOR:	MOVE J,JOB	;PROBABLY UNNECESSARY
	LDB T1,PVYCOR	;HIS CORE SIZE LIMIT
	ADDI T1,1	;CONVERT TO PAGES..
	LSH T1,2	;4*(PVYCOR+1)
	HLRZ T2,JBTUPM(J)	;HIS PRESENT SIZE . NOTE !!!
		;18 MAY 77 EVS & AA AGREE TO KEEP LH(JBTUPM)
		;=NUMBER OF EXISTENT PAGES BETWEEN 0 & 777
	ADD T2,STRDDB+STRTAL	;HOPEFULLY IN PAGES. CHECK THIS OUT
	CAMGE T2,T1
	MOVE T1,T2
	LSH T1,-1	;RETURN IN 1K
	UMOVEM T1,(M)
	LSTCHK
	POPJ P,
COMMENT @ ROUTINE CORXK
FUNCTION: TO EXPAND OR KILL CORE, WHERE T1/ NEW REQUESTED
	HIGHEST ADDR FOR THE (HI/LO) SEGMENT, AND T2/ CURRENT
	HIGHEST ADDR FOR THE SAME SEGMENT.
CALL:	MOVE T1,REQUEST
	MOVE T2,CURRENT END
	PUSHJ P,CORXK
	 ERROR RETURN	;CORXPN COULDNT SUCCEED
	SUCCESS RETURN
DESTROYS: T1,T2,T3,T4,PG,W
RESTRICTIONS:

@

CORXK:	LSH T1,-9	;LAST REQUESTED PAGE
	LSH T2,-9	;CURRENT LAST PAGE
	CAMN T1,T2
	JRST CPOPJ1
	CAMG T1,T2
	JRST [	ADDI T1,1
		AOS (P)
		PJRST KILPGS]	;KILL FROM REQUEST+1 TO CURRENT
	EXCH T1,T2	;T1/CURRENT END; T2/REQUESTED END
	SKIPE T1	;IF CURRENT=0 CREATE FROM 0 TO REQUEST,
	ADDI T1,1	;ELSE CREATE FROM CURRENT+1 TO REQUEST
	PUSH P,T1	;EXPAND FROM T1 TO T2. SAVE T1 INCASE FAILURE
	PUSHJ P,CORXPN
	TDZA T3,T3	;FAILED. T3/0
	MOVEI T3,1	;SUCC, T3/1
	POP P,T1	;START PG
	JUMPN T3,CPOPJ1	;SUCCESS,SKIP RTN
	HLRZ T2,W	;ERROR VP #
	SUBI T2,1	;T2/LAST VP CREATED
	CAMG T2,T1	;CREATED AT LEAST ONE?
	POPJ P,		;NO, NO CLEANUP TO DO
	PJRST KILPGS	;YES, KILL T1 TO T2--ALL PAGES WHICH
			;DID GET CREATED. NON-SKIP RTN FROM CORXK

COMMENT ;@@SUBROUTINE DOXCT
@@PURPOSE PERFORM AN EXECUTIVE EXECUTE TO USER SPACE REGARDLESS
OF THE SETTING OF PC.UIO
@@ENTRY CALLED VIA UXCTFU, UXCTTU, AND UXCTBU MACROS. DO NOT CALL
DIRECTLY.
@@ACCUM PRESERVES ALL ACS
@@EXIT ALWAYS SKIP RETURNS (OVER THE EXECUTIVE EXECUTE).
@@FUNCTION IF PC.UIO ALREADY SET, JUST RETURN. ELSE
TURN ON PC.UIO, IF KL SET PREVIOUS AC BLOCKS TO USER,
XCT THE EXECUTIVE XCT, IF KL SET ORIGINAL AC BLOCKS BACK,
AND RETURN, RESTORING PC FLAGS.
@@;

EXTERNAL UPTACP

DOXCT::	PUSH	P,T1
	JSP	T1,.+1
	TLNE	T1,PC.UIO	;ALREADY ON?
	JRST	TPOPJ		;YES, JUST RETURN AND DO THE INSTRUCTION.
IFNCPU (KI),<HLLZ T1,%UPT+UPTACP;GET AC BLOCK INFO
	TLZ	T1,(LG.PAC)	;MAKE PREVIOUS BLOCK BE USER
	WRUBR	T1
>;END IFCPU (KI)
	POP	P,T1		;RESTORE T1 IN CASE INSTRUCTION INVOLVES IT.
	JRSTF	@[PC.UIO,,.+1]	;SET USER IOT
	XCT	@(P)		;DO THE EXEC XCT
	  JRST	.+2		;NOT A SKIP
	AOS	(P)		;SKIP, GO YET ONE FURTHER
	AOS	(P)		;SKIP OVER THE ARGUMENT
IFNCPU (KI),<WRUBR %UPT+UPTACP>	;IF KL, RESET AC BLOCKS
	PUSH	P,T1		;save T1
	MOVE	T1,-1(P)	;get flags in LH
	HRRI	T1,[ POP P,T1	;put addr of code to do return in RH
		     POPJ P, ]
	JRSTF	@T1		;restore flags and return

SUBTTL KCREATMMENT ! ENTRY UCREAT -- COME HERE FROM UUOCON ON USER UUO
FUNCTION: SET UP AC'S FOR KERNEL CALL, CALL VCREAT KERNEL,
	 RETURN ERRORS TO USER IF ANY, EXIT
USER UUO CALL: MOVE AC,[<PROT>B7+<COUNT>B17+VP#]
	VCREAT AC,
	 ERROR RETURN, AC/ VP#,,ERROR CODE
	SUCCESS RETURN, AC UNCHANGED
EXPECTS: J/ JOB; W/ USER AC#; T1/CONTENTS USER AC
!

UCREAT::JSP T4,DOUUO	;PUSHJ TO KCREAT WITH ARGS IN RIGHT PLACES.
	MOVEI	P3,.ARCHM	;VCREAT NEEDS CHANGE MAP ACCESS
	PUSHJ P,SWRUPX	;WRITE LOCK %UPX FOR CORRECT JOB
	  JRST	[MOVSS T1
		 HRRI  T1,CROFF%
		 DPB P3,FDEERP<T1> ;PUT IN SUB CODE
		 POPJ P,] ;GIVE ERROR RETURN.

COMMENT ! ROUTINE KCREAT -- KERNEL
FUNCTION: CREATE PRIVATE,VIRGIN,MAXIMALLY-WRITEABLE,
	UNVIOLATED,UNSHARED,INACTIVE,NO-ERROR PAGES NOT IN
	USER OR MONITOR WORKING SET, BEGINNING AT <VP#>
	& CONTINUING FOR <COUNT> PAGES. IF AN ERROR OCCURRS,
	RETURN NO-SKIP T1/VP#,,CODE WHERE VP# IS THE PAGE
	NUMBER BEING PROCESSED WHEN ERROR OCCURRED.
EXPECTS: T1/ <USER BIT>,<PROT>,<COUNT>,VP#
	J/JOB
DESTROYS: T1-T4,P1-P4,1B0 IN F
RESTRICTIONS: MONITOR ROUTINES WHICH PUSHJ TO KCREAT SHOULD
 BEWARE OF AC'S AND SET 1B0 OF T1 TO 1 IF IT WANT USER PROTECTION.

CALL:	PUSHJ P,KCREAT
	 ERROR RETURN, T1/ VP#,,CODE
	SUCCESS RETURN
ERROR CODES:
!
	ERRCOD(0,CRBCN%,KCEBCN)	;BAD COUNT ARGUMENT
	ERRCOD(1,CRBVP%,KCEBVP)	;BAD VP ARGUMENT, OUT OF RANGE.
	ERRCOD(2,CRBPR%,KCEBPR)	;BAD PROTECTION ARGUMENT
	ERRCOD(3,CREXV%,KCEEXV)	;VP ALREADY EXISTS
	ERRCOD(4,ZZ,ZZ)		;(VP DOES NOT EXIST GLOBAL CODE)
	ERRCOD(5,CRLIM%,KCELIM)	;EXCEEDED EXISTING PAGE LIMIT (PVYCOR)
	ERRCOD(6,CRDFL%,KCEDFL)	;DISK FULL
	ERRCOD(7,CROFF%,KCEOFF) ;"OTHER FRAME" FAILURE.
EXTERN GETPAG,MBIT,UUYCTG,UUYCPR

KCREAT:: NOCHARGE	;TURN OFF THE CLOCK.
	TLNE T1,FL.USR	;COPY USER BIT INTO SIGN BIT OF F FROM
	TLOA F,FL.USR	;SIGN BIT OF T1
	TLZ F,FL.USR
	LDB T2,UUYCPR		;T2/PROT FROM T1 ARG.
	SKIPE T2
	CAILE T2,MAXCPR
	JRST KCEBPR	;FAIL BAD PROT

	MOVE P1,T2

	LDB T2,UUYCTG		;T2/COUNT FROM T1 ARG.
	JUMPE T2,KCEBCN		;0 COUNT ILLEGAL
	HRRZ P2,T1
	MOVNS T2		;T2/-COUNT
	HRL P2,T2		;P2/-COUNT,,START VP#
	LDB T1,PVYCOR	;MAX 2K BLOCKS CORE ALLOWED
	ADDI T1,1	;CONVERT TO PAGES ALLOWED..
	LSH T1,2	;PGS=4*(PVYCOR+1)
	HRL P1,T1	;KEEP IN LH(P1) DURING LOOP BELOW
	SETZ	M,		;DSK RET PTR FOR GETPAG CALLS.

VCREA1:	;WHILE AOBJN P2, ALLOCATE DISK PG FOR W=RH(P2)
	;AND SETUP LMAP SLOT--UNLESS PAGE ALREADY EXISTS
	;OR IS INVALID OR NO DSK AVAILABLE.
	;J/JOB; F/USER AC# +(1B0) IF USER CALL
	;P1/ PVYCOR,,PROTECTION;  W/ VP# IN PROCESS
	
	HRRZ W,P2
	JSP T4,VPCHK		;LEGITIMATE PG NO?
	 JRST KCEBVP		;NO
	CAILE W,777	;IF EXEC CALLED TO CREATE A PER-
	JRST VCREA2	;PROCESS PG, NO NEED TO CK. (JBTUPM LH
			;COUNTS USER PGS 0 - 777 ONLY)
	HLRZ T4,P1	;PERMISSABLE MAX NO. PAGES
	HLRZ T3,JBTUPM(J)	;T3/CURRENT COUNT OF EXISTENT PGS
	ADDI T3,1		;T3/TOTAL PGS AFTER THIS ALLOCATED
	CAMLE T3,T4		;IN BOUNDS?
	JRST KCELIM		;CREATED TOO MANY PAGES
VCREA2:	PUSHJ	P,REDLMX	;GET P3, P4 SLOT. (NEED REF BIT)
	TLNE P3,LMMEXS
	JRST	KCEEXV		;TRYING TO CREATE PAGE THAT ALREADY EXISTS.
	MOVEI T1,DABBIT(J) ;GET DUMMY ATB POINTER
	DPB T1,LM3ATB	;PUT INTO LMAP SLOT
	MOVEI T2,SRPNDS	;IF DSKCLN HASN'T RUN YET,
	TDNE T2,STRDDB+STRBTS
	JRST [MOVE T2,ADRDUM
	      JRST VCREA3]	;CREATE VP TO "DUMMY" DISK ADDRESS.
	PUSHJ P,CNVATP	;CONVERT ATB POINTER INTO ADDRESS
	PUSHJ P,INCUMC	;INCREMENT UNSHARED MAP COUNT
	MOVEI T3,ATPMXU	;MAX WRITE COUNT WILL GO TO NON-ZERO
	IORM T3,ATBSTS(T1)
	AOS T3,ATBMWC(T1) ;INCREMENT AND GET MAX WRITE COUNT
	TRNN T3,ATMMWC	;OVERFLOW?
	STOPCD		;YES. CRASH.
	MOVE T3,T1	;GET ATB ADDRESS INTO T3 FOR GETPAG
	MOVEI T1,MBIT
	MOVE T2,M		;TRY TO BE CONTIGUOUS WITH LAST ONE.
				;WITH; ON T2/0,JUST CALL GETAPG
				;ALLOCATE DISK EVEN IF STRTAL IS .LE. 0.
				; SO OPERS CAN CLEAN UP DISK.
	PUSHJ P,GETPAG	;ALLOCATE & RETURN T2/NEXT RETREIVAL PTR.
	JRST KCEDFL	;FULL..SOMEBODY SNUCK IN
	MOVEM T2,M		;REMEMBER FOR NEXT VP CREATED.
VCREA3:	HRRZ P4,T2	;P4/ LOW 17 BITS + EXTRA BIT OF RETR. PTR.
	ANDI P4,377777	;P4/LOW 17 BITS
	LSH T2,-LMASRP	;HIGH 10 BITS IN POSITION
	DPB T2,LM3HDA	;FOR DEPOSIT IN P3
	TLZ P3,LMMERR!LMPSHR!LMPACT
	TLO P3,LMPVIR!LMPMXW
	DPB P1,LM3CUR	;PROTECTION
	PUSHJ P,SETLMX	;EXPECTS W,P3,P4 - LDC COUNT IS NOT INCREMENTED
	MOVSI T1,1	;INCREMENT COUNT OF 
	CAIG W,777	;EXISTENT PAGES IN 0 - 777
	ADDM T1,JBTUPM(J);EXISTENT PAGES FOR USER
	AOS JBTMPC(J)	;CHARGE FOR IT. 1/4 THE RATE FOR MAPPING
	AOS JBTMPC	;SYSTEM TOTAL
	AOS VCRECT	;PERFORMANCE COUNTER
	SKIPE	TIMEF	;MAKE SURE THAT WE GO THRU SCHEDULER IF CLOCK HAS TICKED,
	PUSHJ	P,WSCHED	;SO THAT BIG ARGS WON'T TIE THINGS UP.
	AOBJN P2,VCREA1
	JRST CPOPJ1

VCRECT:: EXP 0		;COUNT OF VCREATE'D PAGES.
SUBTTL KREMOV/KCLEAR

COMMENT #
@@SUBROUTINE KREMOV/KCLEAR
@@PURPOSE
KERNEL SUBROUTINE TO REMOVE VM PAGES.
KREMOV COMPLAINS ABOUT NON-EXISTENT PAGES, KCLEAR DOES NOT.
BOTH ROUTINES ERROR RETURN ON AN IO ERROR.
@@ENTRY
EXPECTS T1/ USER'S ARG, PLUS BIT 0 IS SET IFF CAME FROM 
USER MODE. J CONTAINS FRAME NUMBER OF TARGET FRAME, %UPX ITS CONTEXT PAGES.
@@ACCUM
DESTROYS P1-P4, T1-T4, S, F, W, U, AND PG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON NON-SKIP RETURN, LH(T1) CONTAINS THE NO. OF THE VM PAGE
ON WHICH THE FAILURE OCCURRED, AND RH(T1) CONTAINS THE ERROR
CODE AS FOLLOWS:  FALCTG,FALDVR,FALNEX,FALOPE,FALOFF.
@@ #

INTERN KREMOV,KCLEAR
EXTERNAL DNDADS,IOSERR,IOSHRE,IOSHWE,IOSSAE,CBREMV,JBTCLB
EXTERNAL LMPDER,LMPDTE
EXTERNAL PRRCHK,OHTNUM,REMOHT,RIBELB,UFRCHK
EXTERNAL MAPRWL,ATBLIC,DNDADS

;FLAGS IN LH(F)

MF.VCL==(1B0)			;ON IF VCLEAR. MUST BE SIGN BIT.
MF.CRF==(1B1)			;CLEAR REF BIT FLAG.
MF.NEL==(1B2)			;NO ERROR LOGGING. IF SET, GUARANTEED
				; NOT TO USE %RIB OR %RB2.
MF.OTF==(1B3)			;USE "OTHER FRAME" TO DO THE REMOVE.

RM.CRF==(1B7)			;CLEAR REFERENCE BIT ARGUMENT
RM.NEL==(1B6)			;NO ERROR LOGGING (USED BY EXEC ONLY)
RM.OTF==(1B1)			;"OTHER FRAME" BIT FROM UUO ARG


EXTERN ATBDUM,ATBRIB,ATPCRE,ATPSUP,ATPUFE,DECRMV,DECUPM
EXTERN DRBRIB,FALNEX,FALOPE,FNYUFP,GETSAT,MAPCML,FALOFF
EXTERN MAPRLS,MAPWTL,MAPXCH,RBREAL,RELLOK,RELSAT,RIBLCW
EXTERN RIBSTS,RIPUFE,SETARR,UFDERR,UFPERR,UPDADS,VUOOUT
EXTERN STRDDB,STRBTS,SRPNDS,IPOPJ
EXTERNAL UPTLKJ,%UPLMX,UPTLKC,OTFFLG



KREMOV:	TDZA	F,F		;INIT FLAGS IN LH(F)
KCLEAR:	MOVSI	F,MF.VCL	;FLAG THAT THIS IS VCLEAR.

    ;GET AND CHECK THE ARGS.
	PUSHJ	P,SETARR	;P2/CONTIG, W/1ST DEST PAGE NO.
	  POPJ	P,		;GIVE ERROR RETURN, CODE IN T1.
	TLNE	P1,RM.CRF	;CLEAR REF BIT BIT ON?
	TLO	F,MF.CRF	;FLAG TO CLEAR REF BITS.
	TLNE	P1,RM.NEL	;IF NO ERROR LOGGING,
	TLO	F,MF.NEL	;NO BAT BLOCKS, MARK FILE, OR ANYTHING.
	TLNE	P1,RM.OTF	;USER WANTS OTHER FRAME?
	TLO	F,MF.OTF	;YES, SET THE FLAG.
	PUSH	P,P2		;SAVE CONTIG ON STACK, DECREMENT IT THERE.

    ;START THE PAGES OUT.
	PUSH	P,W		;SAVE W AND M FROM VALID.
	PUSH	P,M		; NEED W, AND CLAIM TO PRESERVE M.
				; VALID LEAVES J SETUP TO C(JOB).
	JUMPGE	F,REMV14	;JUMP IF REMOVE.

      ;HERE FOR CLEAR.  SKIP OVER NON-EXISTENT PAGES, BECAUSE
      ;WE DON'T CARE ABOUT THEM.
REMOV1:	HRLZI	T4,LMMEXS	;DON'T CARE ABOUT
REMV11:	TDNE	T4,%UPLMX(W)	;NON-EXIST PAGES.
	JRST	REMV14		;THIS PAGE EXISTS.
	MOVEI	W,1(W)		;TRY THE NEXT
REMV12:	SOJG	P2,REMV11	;PAGE.
	JRST	REMV18		;ALL DONE. NO EXISTENT PAGES.
      ;HERE TO START VALIDATION/START.
REMV14:	HRRZI	T1,(W)		;SET UP T1/ CONTIG,, START PAGE
	HRLM	P2,T1		;NO., FOR VALID.
	TLNE	F,MF.OTF	;USE OTHER CONTEXT?
	TLO	T1,OTFFLG	;YES, TELL VALID
	PUSH	P,P2		;SAVE THE ACS THAT WE CARE ABOUT
	PUSH	P,F		;INSIDE THIS LOOP, THAT
	PUSH	P,W		;VALID DESTROYS.
	PUSHJ	P,VALID		;TRY TO VALID ALL THE REST.
	  JRST	REMV16		;FAILED.
	POP	P,W		;WON, ALL THE REST
	POP	P,F		;ARE
	POP	P,P2		;DONE.
	JRST	REMV18		;
REMV16:	POP	P,W		;HERE ON VALIDATION FAILED.
	POP	P,F		;
	POP	P,P2		;
	HRRZI	T2,(T1)		;WHAT WAS
	CAIN	T2,VLIOE%	;I/O ERROR?
	JRST	REMV17		;YES, CATCH IT LATER.
	CAIE	T2,VLNVP%	;ERROR?
	STOPCD
	JUMPGE	F,REMV18	;NON-EXS ON REMOV WILL BE FATAL,
REMV17:	ADDI	P2,(W)		;CLEAR, AND WE SAW A NON-
	HLRZ	W,T1		;EXIST PAGE.  GO SEE
	MOVEI	W,1(W)		;WHETHER THE REST
	SUBI	P2,(W)		;EXIST OR
	JUMPG	P2,REMOV1	;NOT.
REMV18:	POP	P,M		;RESTORE M AND W NOW.
	POP	P,W		;

    ;HERE TO REMOVE EACH PAGE.

      ;DO A VALIDATE/WAIT.
REMOV2:	MOVSI	T1,LMMEXS	;IF PAGE EXISTS,
	TDNE	T1,%UPLMX(W)	;THEN GO AND
	JRST	REMV21		; VALIDATE/WAIT IT.
	JUMPL	F,REMOV9	;NON-EXISTENT. JUMP TO CONTINUE IF VCLEAR.
	MOVEI	T2,VLNVP%	;FATAL IF
	JRST	REMFAL		;REMOVE.
REMV21:	HRRZI	T1,(W)		;BUILD ARG
	HRLI	T1,1		;FOR A ONE PAGE
	TLNE	F,MF.OTF	;OTHER CONTEXT?
	TLOA	T1,VL.WAT+OTFFLG ;YES, SET WAIT AND OTHER FLAG
	TLO	T1,VL.WAT	;NO, JUST SET WAIT.
	PUSHJ	P,GVALID	;DO THE VALIDATE/WAIT FOR CORRECT FRAME.
	  JRST	.+2		;ERROR.
	JRST	REMV23		;OKAY.
	HRRZI	T2,(T1)		;WHAT WAS THE ERROR TYPE?
	CAIE	T2,VLIOE%	;IO ERROR?
	STOPCD
	JUMPGE	F,REMFAL	;I/O ERRORS ARE FATAL IF NOT VCLEAR.
				; (IF LMPNER SET, WON'T GET THIS.)
REMV23:	SKIPE	JBTCLB(J)	;THIS JOB IN A CLUB?
	PUSHJ	P,CBREMV	;IF CLB PAG, PUNT JOB FROM CLB.
	PUSHJ	P,GETLMX	;GET LMAP SLOT IN P3 AND P4.

      ;DEACTIVATE THE LMAP SLOT.
	CAILE	W,VPUMAX	;CONTEXT PAGE?
	PUSH	P,P4		;YES, SAVE FOR BELOW.
	PUSHJ	P,DEALMA	;DEACTIVATE LMAP SLOT.
	CAILE	W,VPUMAX	;CONTEXT PAGE?
	JRST	[SOS %UPT+UPTLDC
		 JRST REMV24]	;WILL STORE IT LATER SO %UPT WILL STILL BE SETUP
	TLNE	F,MF.CRF	;IF CLEARING REF BIT,
	TLZ	P3,LMPREF	;MAY AS WELL DO IT NOW.
	PUSHJ	P,STOLMX	;NO.  STORE IN CASE RESCHEDULED.

;NOTE: CODE BELOW CHANGES P3, AND P4 WHEN UPTLDC IS 0.
; ASSUMES THAT INACTIVE SLOTS ARE NEVER CHANGED!
; OTHER JOBS CAN'T CHANGE, SINCE WE HAVE CONTEXT PAGE WRITE LOCK.

	PUSHJ	P,RMXMWS	;TAKE OUT OF MWS.
	CAIG	W,777		;ALSO MABE OUT OF
	PUSHJ	P,RMXUWS	;UWS.

;CALL THE REMOVE KERNEL ROUTINE

REMV24:	PUSHJ	P,REMKRN
	CAILE	W,VPUMAX	;CONTEXT PAGE?
	POP	P,P4		;YES.  RESTORE SLOT.
	PUSHJ	P,SETLMX	;COUNT IS ZERO THRUOUT THIS CODE, JUST SET LMAP CONTENTS.

    ;IS THERE ANOTHER PAGE TO DO?
REMOV9:	SOSLE	(P)		;CONTIG IS ON STACK. FINISHED?
	AOJA	W,REMOV2	;NO, DO NEXT PAGE.
	POP	P,T1		;YES, GET STACK RIGHT AND FALL
				; INTO REMOUT.

    ;HERE TO FINISH UP SUCCESSFULLY.
REMOUT:	PUSHJ	P,RELSAT	;POSSIBLY RELEASE A SAT.
	PUSHJ	P,TIMADJ	;SIZE HAS CHANGED, DUMP CHARGE STUFF.
	JRST	CPOPJ1		;RETURN.

    ;ERROR EXIT.
REMFAL:	POP	P,P4		;TAKE CONTIG OFF THE STACK.
	MOVEI	T1,FALNEX	;
	CAIE	T2,VLNVP%	;
	MOVEI	T1,FALOPE	;
	PUSH	P,T1		;
	PUSHJ	P,TIMADJ
	PUSHJ	P,RELSAT	;
	POP	P,T1		;
	JRST	VUOOUT
COMMENT ;@@SUBROUTINE REMKRN
@@PURPOSE LMAP SLOT LOCATION DEPENDENT PART OF REMOVE
@@ENTRY	P3,P4/LMAP SLOT (MUST BE INACTIVE AND NOT IN MWS)
	J/ FRAME NUMBER OF FRAME TO REMOVE A PAGE FROM
	W/ VP NUMBER OF PAGE TO REMOVE
	F/ MF.NEL SET IN LH IF NO ERROR LOGGING

UPTLDC FOR MAP WHERE P3 AND P4 CAME FROM MUST BE ZERO (REMKRN RESCHEDULES)
MUST ENTER WITH C(J)'S CONTEXT PAGES LOCKED, UNLESS CALLER KNOWS
NO ONE ELSE WILL TRY TO REMOVE OR CREATE THEM (%UPX CASE).
IF PAGE REMOVED IS A CONTEXT PAGE, CALL WITH USE COUNT INCREMENTED
(PGYUSE).
CALLER RESPONSIBLE FOR DOING VALIDATE IF NECESSARY, CHECKING
EXISTENCE OF LMAP SLOT VP, REMOVING FRAME FROM THE VP'S CLUB
CLEARING REFERENCE BIT.
@ACCUM P1-P4, T1-T4, S, U, PG. (J, F, W NOT CHANGED)
@@EXIT MAY HAVE A SAT ON EXIT (MUST CALL RELSAT).
NON-EXISTENT SLOT IN P3 AND P4 TO STORE BACK INTO LMAP.
JBTUPM DECREMENTED IF NECESSARY.
@@;

REMKRN::PUSHJ	P,GETDPA	;GET DISK ADDRESS IN T2
	CAMN	T2,ADRDUM	;THIS A "DUMMY" DISK PAGE?
	JRST	REMOV8		;YES, JUST BREAK SLOT APART.
	MOVE	P1,T2		;REMEMBER IT IN P1
	TLNN	P3,LMPSUP	;IF SUPER, DON'T CALL THIS.
	PUSHJ	P,GETATB	;GET ATB ADDRESS IN T1
	MOVE	P2,T1		;REMEMBER IT IN P2
	TLNN	P3,LMPDER	;COPY EXISTING ERROR BITS INTO S
	TDZA	S,S		;NOT SET
	MOVEI	S,IODERR	;IS SET, SET IN S
	TLNE	P3,LMPDTE	;DATA ERROR?
	TRO	S,IODTER	;YES.
	PUSHJ	P,UPDERS	;SET BITS IN S, LOOKING AT PGY IF ANY AND OHT
	TLNE	P3,LMMERR	;IF LMAP HAS SEEN ERROR AND
	TLNE	S,IOSHWE	;THERE HASN'T BEEN ANOUTPUT ERROR
	JRST	.+2
	TLO	S,IOSHRE	;THEN THERE MUST HAVE BEEN READ ERROR.
	TLNN	S,IOSERR	;ANY ERRORS?
	JRST	REMOV3		;NO.
	MOVEI	T1,SRPNDS	;IF DSKCLN HASN'T FINISHED OR
	TDNN	T1,STRDDB+STRBTS
	TLNE	F,MF.NEL	;NO ERROR LOGGING,
	JRST	REMOV3		;THEN DON'T LOG - IT TOUCHES RIBS.

;HERE IF PAGE BEING REMOVED HAD ERRORS. MUST SET BITS IN RIB
; AND UFD AND UFD RIB IF PAGE IS STILL IN FILE IT CAME FROM.
; MUST UPDATE BAT BLOCK IF PAGE HAD A DATA ERROR.

	TRNN	S,IODERR	;IF ONLY DATA ERROR
	TRNN	S,IODTER	;
	JRST	.+2
	PUSHJ	P,UPERBT	;THEN MAKE ENTRY IN BAT BLOCK IF NOT ALREADY THERE.

	TLNE	P3,LMPSUP	;SUPER PAGE?
	JRST	REMV25		;YES, DON'T MUCK WITH RIBS.

	SKIPL	ATBDUM(P2)	;IF PRIVATE PAGE OR
	SKIPN	T1,ATBRIB(P2)	;FILE HAS BEEN DELETED,
	JRST	REMOV3		;DON'T MARK RIB OR UFD

	TLO	T1,RBREAL	;MAKE IT HOLY
	TLO	S,IO		;MAP IT WRITE LOCKED.
	PUSHJ	P,MAPRWL	;GET RIB IN %RIB
	PUSHJ	P,PRRCHK	;CHECK IT AGAINST DRB,FNB,ATB
	  JRST	REMOV3		;FORGET IT (MAY HAVE BEEN DELETED)
;EITHER THIS IS SUPER PAGE OR RIB IS LOCKED DOWN. GET SAT
; SO EITHER WE SET "F" BIT FOR SUPER PAGE IF PAGE WAS FREE
; AND JUST HAD DATA ERROR, OR IF NOT SUPER CHECK TO SEE IF
; PAGE IS STILL IN THE FILE.

REMV25:	MOVE	T2,P1		;GET DP
	TLO	T2,RBREAL	;MAKE IT ACCEPTABLE
	MOVEI	T1,MAPCML	;GET SAT COMPLETELY LOCKED
	PUSHJ	P,GETSAT	;GET IT
	  TLO	S,IOSSAE	;BAD SAT. FLAG THIS IN S
	PUSH	P,T1		;SAVE MASK
	PUSH	P,T3		; AND INDEX
	PUSH	P,ATBDUM(P2)	;SAVE, SO STACK IS RIGHT AT REMOV31
	PUSHJ	P,UPDERS	;FILL US IN ON NEW ERRORS
	MOVE	T1,-2(P)
	MOVE	T3,-1(P)	;RESTORE THESE, UPDERS MASHED THEM.
	TLNN	P3,LMPSUP	;IS THIS A SUPER PAGE?
	JRST	REMV26		;NO, HANDLE NORMALLY
	TRNN	S,IODERR!IODTER	;ANY ERRORS?
	JRST	REM25A		;NO, JUST NORMAL SUPER PAGE.
	TRNN	S,IODERR	;YES. IF DEVICE ERR ON, FORGET IT
	TLNE	S,IOSSAE	;JUST DATA ERROR. IF SAT OK,
	JRST	REM25A		;SO MUCH FOR THAT.
				;ALLOCATE PAGE AND PUT IN BAT BLOCKS.
	TDNE	T1,%SAT(T3)	;IF PAGE IS STILL USED,
	TDNN	T1,%SAT+400(T3)	;THEN FORGET IT
	JRST	REM25A
	ANDCAM	T1,%SAT(T3)	;ELSE SET "F" BIT. THIS IS SO
				; PROGRAM CAN CAUSE FREE PAGE TO GET INTO
				; BAT BLOCKS AND GET "F" BIT SET BY DOING SUPER I/O
	PUSHJ	P,DNDADS	;DECREMENT DISK COUNTS - 1 LESS PGE
REM25A:	SUB	P,[3,,3]	;GET STUFF OFF STACK
	JRST	REMOV8		;AND JUST BREAK SLOT APART.
;HERE FOR A NON-SUPER PAGE WITH AN ERROR. SEE IF ITS STILL
; IN THE FILE, AND MARK RIB AND UFD IF SO.

REMV26:	TLNN	S,IOSSAE	;IF BAD SAT, ASSUME ITS IN THE FILE
	TDNN	T1,%SAT(T3)	;"F" BIT STILL SET (0) ?
	JRST	.+2		;YES, MARK RIB
	JRST	REMV31		;NO, SKIP THIS STUFF

	HLRZ	T1,S		;GET BITS OF INTEREST IN T1
	ANDI	T1,IOSERR	;ONLY RELEVANT ONES
	IORM	T1,%RIB+RIBSTS	;
	MOVSI	T1,RIPUFE	;SET THIS IN RIBLIC
	IORM	T1,%RIB+RIBLCW	;SO NO  ONE BELIEVES LICENSE.
	MOVE	T1,P1		;GET COPY OF DISK ADDRESS SO WE CAN
	TLO	T1,RBREAL	; TURN RBREAL ON IN IT
	MOVEM	T1,%RIB+RIBELB	;THIS IS THE BAD PAGE, PUT IT HERE
				; SO ITS NOT GIVEN BACK WHEN FILE IS DELETED.
	MOVSI	T1,ATPUFE	;SET THIS IN ATBLIC
	IORM	T1,ATBLIC(P2)	;SO CURRENT USERS KNOW OF THE ERROR
	PUSHJ	P,RELLOK	;RELEASE RIB NOW, WE'RE DONE.
	MOVE	T1,ATBSTS(P2)	;IF FILE IS STILL IN UFD,
	TRNN	T1,ATPDEL!ATPCRE!ATPSUP ;THESE WON'T BE SET.
	PUSHJ	P,UPERUF	;UPERUF WON'T FIND IT IF IT DISAPPEARS AFTER THIS.
	SUB	P,[3,,3]	;SAT WAS RELEASED, FALL THRU AND
				; GET IT AGAIN.


;HERE FOR PAGE WITHOUT ERROR, TO GET THE SAT.

REMOV3:	TLNE	P3,LMPSUP	;IF SUPER SLOT,
	JRST	REMOV8		;JUST GO BREAK SLOT APART.
				; (SUPER MUST NOT TOUCH SAT, IN CASE ITS DSKCLN TIME)
	MOVE	T2,P1		;GET DISK ADDRESS
	TLO	T2,RBREAL	;MAKE IT HOLY
	MOVEI	T1,MAPCML	;GET SAT COMPLETELY LOCKED SO NO ONE
				; CAN RUN IN THIS CODE FOR SAME PAGE TOGETHER.
	PUSHJ	P,GETSAT
	  TLO	S,IOSSAE	;BAD SAT, FLAG IT
	PUSH	P,T1		;SAVE MASK AND
	PUSH	P,T3		;INDEX
	PUSH	P,ATBDUM(P2)	;SAVE STATE OF PRIVATE/FILE,
				; SINCE ATB CAN GO AWAY AFTER DECRMV.

;PAGES THAT HAD ERRORS, THEREFORE GET THE SAT, REJOIN HERE.

REMV31:	PUSHJ	P,DECRMV	;DECREMENT ATB, SPT COUNTS, ETC.
	  JRST	[SUB P,[3,,3]	;NOT LAST USER,
		 JRST REMOV8]	;SO ADJUST STACK POINTER AND GO.
;HERE WHEN LAST USER OF THIS PAGE, WITH SAT COMPLETELY LOCKED
; SO WE KNOW IT WILL STAY THAT WAY.

	PUSHJ	P,UPDERS	;SEE IF ANY NEW ERRORS LATELY.
	POP	P,T4		;GET ATBDUM BIT IN T4
	POP	P,T3		;SAT INDEX IN T3
	POP	P,T1		;SAT MASK IN T1

	JUMPL	T4,REMOV4	;IF PAGE IS NOT FROM A FILE, SKIP THIS STUFF.
	TLNE	S,IOSSAE	;IF SAT ERROR, ASSUME ITS IN THE FILE.
	JRST	REMV36		;(RIBELB WILL NOT MATCH ANY POINTERS IN THE RIB)
	TDNE	T1,%SAT(T3)	;IS PAGE STILL IN FILE?
	JRST	REMOV4		;NOT ANYMORE, SKIP THIS AND TREAT LIKE A PRIVATE PAGE.
	TDNE	T1,%SAT+400(T3)	;CLEAR "M" BIT NOW.
	STOPCD (SLO)			;WAS ALREADY CLEAR!
				;MAKE FULL DSKCLN RUN, IN CASE THIS WAS BECAUSE OF MULTIPLE USE IN 2 OR MORE FILES
	IORM	T1,%SAT+400(T3)	;(CLEAR MEANS MAKE BIT = 1)

;HERE FOR FILE PAGE. IF ANY READ ERRORS, AND NO WRITE ERRORS,
; TAKE PAGE OUT OF CHT. MAYBE NEXT GUY WILL BE LUCKIER AND
; GET GOOD DATA FROM THE DISK.

REMV36:	TLNN	S,IOSERR	;ANY ERRORS TO SPEAK OF?
	JRST	REMOV7		;NO.
	JUMPE	PG,REMOV7	;ALREADY OUT OF CORE?
	TLNE	S,IOSHWE	;IF WRITE ERROR, LEAVE IN CORE.
	JRST	REMV71		;(TAKE OUT OF OHT).
	PUSHJ	P,REMWAT	;WAIT FOR I/O TO STOP ON PAGE.
	PUSHJ	P,UPDERS	;GET ANY NEW HAPPENINGS IN S
	TLNE	S,IOSHWE	;WRITE ERROR NEWLY MADE?
	JRST	REMV71		;YES. DON'T TAKE IT OUT OF CHT
	JUMPE	PG,REMOV8	;JUMP IF SNUCK OUT OF CORE DURING REMWAT.
	PUSHJ	P,REMCHR	;OK, TAKE CP OUT OF CHT.
	JRST	REMOV8		;NO WRITE ERRORS, SO ITS NOT IN OHT.
;HERE FOR PRIVATE PAGE, LAST USER IS REMOVING IT.
; TAKE IT OUT OF CHT SO WE DON'T BOTHER WRITING IT
; OUT IF ITS DIRTY.

REMOV4:	TRNE	S,IODERR!IODTER	;IF ONLY DATA ERROR IS ON,
	TRNN	S,IODTER	;
	JRST	REMV41		;(NO ERRORS OR DEVICE ERROR IS ON.)
	TLNN	F,MF.NEL	;IF DOING ERROR LOGGING,
	PUSHJ	P,UPERBT	;PUT INTO BAT BLOCKS AND CONVENIENTLY
	JRST	REMOV5		; FORGET TO TURN "M" BIT OFF.

REMV41:	TLNE	S,IOSSAE	;IF BAD SAT, CAN'T TOUCH %SAT OR UPDADS
	JRST	REMOV5
	TDNE	T1,%SAT+400(T3)	;MAKE SURE "M" BIT IS NOT OFF ALREADY
	STOPCD (SLO)		;IN CASE THIS WAS MULTIPLY USED PAGE, RUN SLOW DSKCLN TO CHECK ALL FILES
	IORM	T1,%SAT+400(T3)	;TURN IT OFF (SET TO 1)
	PUSHJ	P,UPDADS	;INCREMENT DISK ALLOCATIONS COUNTS.

REMOV5:	PUSHJ	P,UPDERS	;GET NEW ERROR STATUS, PG
	JUMPE	PG,REMOV7	;GO IF NOT IN CORE ANYMORE.
	PUSHJ	P,REMWAT	;WAIT FOR I/O TO STOP
	PUSHJ	P,UPDERS	;GET PG AGAIN.
	JUMPE	PG,REMOV7	;GO IF SNUCK AWAY.
        HRRZ    T1,W            ;CLEAR LEFT HW FOR COMPARE
	CAIL	T1,VPUMAX-NCTXPG;IF ITS CONTEXT PAGE AND
	JRST  [ LDB T1,PGYUSE	;USE COUNT INCREMENTED
		JUMPN T1,REMOV6	;DO IT A LITTLE DIFFERENTLY
		JRST .+1 ]
	PUSHJ	P,REMCHR	;TAKE CP OUT OF CHT
	JRST	REMOV7		;AND DO THE REST.

;IF ITS A CONTEXT PAGE, HAVE TO DECREMENT USE COUNT, WHICH
; IS ARTIFICALLY INCREMENTED BY KILUPT SO THE CORE PAGE
; IS LOCKED IN CORE WHILE CONTEXT PAGES ARE GOING AWAY.

REMOV6:	PUSHJ	P,DECUSE	;REMCHR WILL CHOKE ON NON-ZERO PGYUSE
	PUSHJ	P,REMCHR	;TAKE CP OUT OF CHT
	PUSHJ	P,INCUSE	;CORE PAGE WILL NOT BE USED IF THIS IS UP.

REMOV7:	TLNE	S,IOSHWE	;IF IN THE OHT,
REMV71:	PUSHJ	P,[MOVE T2,P1	;GET DP IN T2
		   PJRST REMOHT] ;TAKE DP OUT OF OHT NOW.

;WHETHER LAST USER OR NOT, FINISH THIS PAGE UP HERE.

REMOV8:	AND	P3,[(LMPREF)]	;CLEAR ALL BUT REF BIT.
	PJRST	DECUPM		;DECREMENT JBTUPM IF NECESSARY AND RETURN.
;QUICK AND DIRTY TINY SUBR TO SAVE ACS FROM VALIDATE KERNEL ROUTINE.
;REPLACES VALPAG T1,.


GVALID:	PUSH	P,W
	PUSH	P,F
	PUSH	P,M
	PUSHJ	P,VALID
	JRST	.+2
	AOS	-3(P)
	POP	P,M
	POP	P,F
	POP	P,W
	POPJ	P,
COMMENT ;@@SUBROUTINE UPDERS/PAGERR
@@PURPOSE AFTER KNOWN RESCHEDULE POINTS IN REMOVE, UPDATE
AC S TO REFLECT THE CURRENT STATE OF THE FOLLOWING BITS:
IODERR,IODTER,IOSHWE,IOSHRE.
@@ENTRY UPDERS -  P1 CONTAINS DISK PAGE FOR VP, S CONTAINS ERROR BITS
UP TO NOW.
PAGERR - PG CONTAINS CORE PAGE, T2 CONTAINS DISK ADDRESS,
 S CONTAINS ERROR BITS UP TO NOW.
@@ACCUM USES T1-T4
@@EXIT UPDERS -  PG RETURNED ZERO IF DP NOT IN CORE, ELSE CORE PAGE NUMBER
OF DP.  BOTH -  IOSHDW AND IOSHRE IN LH(S) UPDATED, AND
IODERR AND IODTER IN RH(S) UPDATED FROM OHT AND PGY
TABLE.
@@RESTRICTIONS
@@FUNCTION UPDERS - SEARCH CHT FOR DP, GO TO PAGERR OR PAGER1
DEPENDING ON WHETHER PAGE IS IN CORE OR NOT, RESPECTIVELY.
PAGERR - UPDATE PROPER BITS FROM PGY TABLE AND OHT.
@@;

EXTERNAL SRCOHT,OHTTAB,OHTPAR,OHTDER,OHTDTE
EXTERNAL PGYERR

UPDERS:	MOVE	T2,P1		;GET DP INTO RIGHT AC
	PUSHJ	P,SRCCHT	;SEE IF IN CORE
	  JRST	PAGER1		;NOT IN CORE, DON'T BOTHER WITH PGYERR
				;FALL THRU INTO PAGERR

PAGERR::LDB	T1,PGYERR	;GET ERROR BITS FOR INPUT ERRORS
	JUMPE	T1,PAGER1	;GO IF NONE
	LSH	T1,^D35-^D20	;GET INTO 1B19 AND 1B20.
	IOR	S,T1
	TLO	S,IOSHRE	;AND FLAG THAT A HARD READ ERROR HAPPENED.

PAGER1:	SKIPE	OHTNUM		;JUST RETURN IF NO OUTPUT ERRORS.
	PUSHJ	P,SRCOHT	;YES, IS OUR DP ONE OF THEM?
	  POPJ	P,		;NO, S OK.
	HLRZ	T1,OHTTAB(T4)	;YES. GET BITS
	TRNE	T1,OHTPAR!OHTDER ;THESE BOTH SET 
	TRO	S,IODERR	;DEVICE ERROR BIT.
	TRNE	T1,OHTDTE	;THIS SETS
	TRO	S,IODTER	;DATA ERROR
	TLO	S,IOSHWE	;FLAG A HARD WRITE ERROR.
	POPJ	P,
COMMENT ;@@SUBROUTINE UPERUF
@@PURPOSE MARK UFD RIB AND UFD ENTRY FOR FILE THAT
HAS GONE BAD.
@@ENTRY ATB ADDRESS IN P2
NOTHING IN %RIB
IOSHWE, IOSHRE SET IN LH(S)
@@ACCUM SETS IO IN S
USES T1-T4
@@EXIT ALWAYS NON-SKIP RETURN. PROPER BITS UPDATED IF POSSIBLE.
@@RESTRICTIONS DRB COUNT FOR UFD MUST BE UP.
CALLER MUST SET ATPUFE.
@@FUNCTION GET UFD RIB, SET IOSERR BITS IN RIBSTS IN
LH OF UFD'S RIBSTS. SEARCH UFD FOR ENTRY FOR BAD FILE,
SET UFPERR BIT.
@@;

EXTERNAL FNBDRB,DRRSRC,DRRBLK

UPERUF:	HRRZ	T1,ATBFNB(P2)	;FNB
	HRRZ	T1,FNBDRB(T1)	;DRB
	MOVE	T1,DRBRIB(T1)	;GET RIB FOR UFD
	TLO	T1,RBREAL	;MAKE IT HOLY.
	TLO	S,IO		;GET IT WRITE LOCKED
	PUSHJ	P,MAPRWL	; SO NO ONE DELETES THE FILE
	PUSHJ	P,UFRCHK	;CHECK THE RIB
	  POPJ	P,		;ITS BAD, RIB IS RELEASED, RETURN.
	HLLZ	T1,S		;COPY IOSERR BITS
	TLZ	T1,-1-IOSERR	;JUST IOSERR BITS
	IORM	T1,%RIB+RIBSTS	;SET IN LH OF UFD'S RIBSTS
	PUSH	P,P3		;SAVE THIS.
	HRRZ	P3,ATBFNB(P2)	;GET FNB IN P3
	LDB	T1,FNYUFP	;GET PAGE TO SEARCH
	POP	P,P3
	PUSHJ	P,DRRBLK	;GET THAT PAGE
	  POPJ	P,		;DRRBLK RELEASED UFD RIB, JUST RETURN.
	PUSHJ	P,DRRSRC	;SEARCH UFD FOR FILE WHOSE ATB IS IN P2
	  PJRST	RELLOK		;COULD NOT FIND IT. RELEASE THE BLOCK AND RETURN.
	MOVEI	T1,UFPERR	;OK, HAVE IT
	IORM	T1,%RIB+UFDERR(T2) ;SET THE BIT FOR THE FILE.
	PJRST	RELLOK		;GIVE PAGE BACK AND RETURN.
;UPDATE BAT BLOCKS IF THEY NEED IT

EXTERNAL LPNBAT,LP2BAT,BATSLF,BATFIR,BASNBB,BANNBB,BATNBB,BATELB,BATPAT
EXTERNAL BATCNT,BATCOD,CODBAT,BATNAM,GETER1,BA1NBB,RBYPN1,RB1PNO,THSDAT

UPERBT:	MOVE	T1,P1		;GET DISK ADDRESS
	TLO	T1,RBREAL	;MAKE IT ACCEPTABLE.
	MOVEI T2,LPNBAT		;GET FIRST BAT PAGE NUMBER
	DPB T2,RBYPN1	;SET PAGE NUMBER (EXTRACT UNIT FILED)
	MOVEI PG,%RB2.C
	PUSHJ P,MAPWTL
	MOVE T1,P1	;AGAIN
	TLO	T1,RBREAL
	MOVEI T2,LP2BAT
	DPB T2,RBYPN1
	MOVEI PG,%RIB.C
	PUSHJ P,MAPWTL	;GET BOT BAT BLOCKS
	MOVEI T2,LP2BAT	;THIS IS WHAT IT SHOULD BE
	PUSHJ P,BATCHK	;CHECK TO SEE IF ITS GOOD
	 JRST FSTBAD	;IT IS NOT
	MOVEI T2,LPNBAT
UPRBT1:	MOVE T1,%RIB+BATSLF	;GET SLF FROM GOOD BLOCK (IN %RIB)
	DPB T2,RBYPN1	;PUT IN PAGE NUMBER OF OTHER
	MOVEM T1,%RB2+BATSLF	;AND PUT IN SECOND BLOCK
	MOVE T1,%RIB+BATFIR	;GET AOBJN PNTR
	LDB T4,RB1PNO		;GET PAGE
UPRBT0:	SKIPN %RIB(T1)	;ARE WE AT FIRST BLANK SPOT?
	JRST UPRBT2	;YES, JUST INSERT
	LDB T2,BA1NBB		;NUMBER
	MOVE T3,%RIB+BATELB(T1)	;FIRST PAGE
	ADD T2,T3	;THIS IS LAST PAGE
	SUBI T3,1
	ADDI T2,1	;NOW T3 IS PAGE BEFORE FIRST, T2 PAGE AFTER LAST
	CAML T4,T3
	CAMLE T4,T2
	JRST UPRBT3	;NOT IN THIS REGION AT ALL
	CAME T4,T3
	CAMN T4,T2
	SKIPA
	JRST BATUPD	;MUST BE IN REGION, NOT AT END
	LDB T2,BA1NBB
	CAIL T2,<-1-<-1_BASNBB>>	;IS IT ALREADY MAX?
	JRST UPRBT3	;YES, CAN NOT UPUT IN THIS REGION
	ADDI T2,1
	DPB T2,BA1NBB	;UPDATE
	CAMN T3,T4	;IS IT AT START?
	SOS %RIB+BATELB(T1)	;YES, DEC STARTING BLOCK
BATUP2:	AOS %RIB+BATPAT	;ONE MORE PAGE BAD
	MOVE T1,[%RIB,,%RB2]
	BLT T1,%RB2+BATSLF-1	;TRANSFER
BATUPD:	MOVEI PG,%RB2.C
	PUSHJ P,MAPRLS
	PJRST RELLOK	;ALL DONE
UPRBT2:	AOBJP T1,BATUPD	;IN CASE NOT ROOM FOR BOTH WORDS
	MOVEM T4,%RIB+BATELB-1(T1)	;FIRST NULL REGION, ENTER NEW
	MOVE T4,THSDAT
	MOVEM T4,%RIB+BATNBB-1(T1)
	AOS %RIB+BATCNT
	JRST BATUP2	;AND GO WRITE
UPRBT3:	AOBJP T1,BATUPD	;GIVE UP IF AOBJN RUNS OUT
	AOBJN T1,UPRBT0	;TAKE 2 WORDS, DOUBLE INCR ADDRESS
	JRST BATUPD	;RAN OUT OF ROOM

FSTBAD:	PUSHJ P,MAPXCH	;FIRST ONE IS BAD, GET 2ND INTO %RIB
	MOVE T2,LPNBAT
	PUSHJ P,BATCHK	;CHECK IT
	 JRST BATUPD	;BOTH BAD, JUST RELEASE
	MOVEI T2,LP2BAT
	JRST UPRBT1	;GET READY TO UPDATE AND REWRITE BOTH

BATCHK:	MOVE T1,P1
	TLO	T1,RBREAL
	DPB T2,RBYPN1	;USE UNIT FIELD
	MOVE T2,%RIB+BATCOD
	CAMN T1,%RIB+BATSLF
	CAIE T2,CODBAT
	POPJ P,		;SOMETHING IS WRONG, QUIT
	PUSHJ P,GETER1
	JUMPN T1,CPOPJ	;ALSO IF READ ERROR
	MOVS T1,%RIB+BATNAM
	CAIN T1,'BAT'	;THIS SHOULD BE IN LEFT HALF
	AOS (P)		;GOOD RETURN
	POPJ P,
SUBTTL VALIDATE/WAIT

;FORMAT OF UUO CALL:
;
;	MOVE	AC,[BITS+COUNT,,PAGE NUMBER] ;1B7 = WAIT
;					;1B0 = USER BIT
;	VALPAG	AC,
;	  <ERROR RETURN>	;AC/VP#,,ERROR CODE
;	<SUCCESS RETURN>

;BIT DEFINITIONS FOR UUO CALL

	XP VL.OTF,(1B1)		;OTHER FRAME
	XP VL.WAT,(1B7)		;WAIT.
	XP VL.VPP,(1B6)		;VALIDATE EVEN IF ITS PRIVATE.
	XP VL.CNT,1777		;MASK FOR COUNT.
;ERROR CODES

	ERRCOD(0,VLBCN%,VLEBCN)	;BAD COUNT
	ERRCOD(1,VLBVP%,VLEBVP)	;BAD VIRTUAL PAGE ARG
	ERRCOD(2,ZZ,ZZ)		;(BAD PROTECTION, UNUSED FOR VALIDATE)
	ERRCOD(3,ZZ,ZZ)		;(VP ALREADY EXISTS, UNUSED)
	ERRCOD(4,VLNVP%,VLENVP)	;VP DOES NOT EXIST
	ERRCOD(5,VLIOE%,VLEIOE)	;I/O ERROR TRYING TO WRITE VP OUT.
	ERRCOD(6,VLOFF%,VLEOFF)	;"OTHER FRAME" FAILURE, SUBCODE IN 0-5.
UVALID::JSP	T4,DOUUO	;SAVE USER AC NUMBER, PUSHJ TO .+1
	MOVEI	P3,.ARCHM	;VALPAG NEEDS CHANGE MAP ACCESS.
	PUSHJ	P,SRDUPX	;READ LOCK %UPX ACCORDING TO C(P1)
	  JRST	[MOVSS T1
		 HRRI T1,VLOFF%
		 DPB P3,FDEERP<T1>
		 POPJ P,]

VALID::	NOCHARGE	;TURN OFF CHARGING CLOCK.
	SKIPGE	T1		;IS THIS FOR EXEC OR USER
	TLOA	F,FL.USR		;USER.
	TLZ	F,FL.USR		;EXEC.
	MOVE	P1,T1		;GET ARG IN SAFE PLACE
	LDB	P2,[POINT 10,P1,17] ;GET COUNT
	JUMPE	P2,VLEBCN	;BAD COUNT
	HRLOI	P2,-1(P2)	;GET COUNT-1,,-1
	EQVI	P2,(P1)		;COMPLEMENT COUNT, PUT ADDR IN RH

	MOVE	W,P2		;GET POINTER IN W SO VP IS IN RH(W)

VALID0:	SETZ	PG,		;IN CASE THIS IS PRIVATE PAGE.
				; ONLY REPORT OUTPUT ERRORS.
	HRRZ	T1,W		;GET VP
	CAILE	T1,VPUMAX	;IF ITS A CONTEXT PGE,
	CAILE	T1,VPMAX	;THEN DO NOTHING.
	JRST	.+2		;ILLEGAL OR NOT CONTEXT PGE.
	JRST	VALD4A
	JSP	T4,VPCHK	;IS VP OK?
	  JRST	VLEBVP		;NO, GIVE ERROR CODE
	PUSHJ	P,GETLMX	;GET CONTENTS OF LMAP SLOT
	TLNN	P3,LMMEXS	;EXISTS?
	JRST	VLENVP		;NO, GIVE AN ERROR.
	TLNE	P3,LMPSUP	;THIS A SUPER SLOT?
	JRST	VALD0A		;YES, ALWAYS TRY TO WRITE.
	PUSHJ	P,GETATB	;GET ATB ADDRESS
	TLNE	P1,VL.VPP	;TREAT PRIVATE LIKE FILE PAGES?
	JRST	VALD0A		;YES, DO EVERYTHING.
	SKIPGE	ATBSTS(T1)	;FILE PAGE?
	JRST	VALID4		;NO, DO NOTHING, STEP TO NEXT VP
VALD0A:	TLO	F,(1B1)		;FLAG THAT THIS IS THE FIRST TIME
VALID1:	PUSHJ	P,GETCPX	;GET CORE PAGE NUMBER, EVEN IF
				; THIS SLOT IS INACTIVE.
	  JRST	VALID4		;NOT IN CORE, DON'T START IT. CHECK FOR ERRORS.
	LDB	T1,PGYSTS	;GET PAGE STATUS BITS
	TRNN	T1,PGPSIP	;IF SWAPPED IN, GOOD COPY IS ON THE DISK.
	TRNN	T1,PGPDRT	;IF CLEAN, NOTHING TO DO.
	JRST	VALID4		;THE EASY WAY OUT
	LDB	T2,PGYDIO	;GET DIO COUNT. MUST WAIT FOR
	JUMPN	T2,VALD2A	; DIO TO STOP ELSE THE DIO WILL MAKE
				; THE PAGE DIRTY WITHOUT SETTING PGYDRT NONZERO.
	TRNN	T1,PGPSOP	;SWAP OUT GOING AND ITS DIRTY?
				; IF SO, HAVE TO WAIT FOR IT BEFORE CAN DO ANYTHING.
	JRST	VALID3		;NO, JUST START IT OUT.
	TLZN	F,(1B1)		;FIRST TIME? IF NOT AND SWAP OUT
	JRST	VALID4		; IS IN PROG, SOMEONE STARTED IT OUT
				; AFTER WE WAITED, SO ITS OK.
VALD2A:	SOSGE	%UPT+UPTLDC	;"THROW AWAY" LMAP DATA IN P3 AND P4
	STOPCD			;BAD COUNT
	PUSH	P,J		;Save current target frame
	MOVE	J,JOB		;Set up for PAGWAT
	PUSHJ	P,PAGWAT	;HAVE TO WAIT FOR IT TO FINISH BEFORE
	POP	P,J		;Restore target frame
	PUSHJ	P,GETLMX	;GET SLOT DATA AGAIN.
	JRST	VALID1		;CHECKING IT OUT AGAIN.
VALID3:	PUSHJ	P,PERCHK	;UPDATE SLOT FOR ERRORS,
	  JRST	VLEIOE		;WAS ONE AND HE'S NOT IGNORING.
	SETO	T1,		;OK, START IT OUT
	DPB	T1,PGYSOP
	LDB	T1,PGYUSE	;DO WE HAVE TO CHANGE COUNTS?
	JUMPN	T1,VALD3A	;NO IF USED STILL.
	SOSGE	DFRPGN		;YES, WAS DIRTY FREE, NOW CAP
	STOPCD
	AOS	CAPPGN		;ONE MORE CLEAN AVAIL IN PROGRESS
VALD3A:	PUSHJ	P,STOLMX	;STORE SLOT BACK, IN CASE ERROR BITS ARE ON.
	PUSHJ	P,SWPIO		;MAKING IT CLEAN.
	PUSHJ	P,GETLMX	;GET NEW SLOT, WITH W BIT CLEAR.
VALID4:	PUSHJ	P,PERCHK	;UPDATE ERRORS
	  JRST	VLEIOE		;GIVE ERROR, STOLMX ALREADY CALLED.
	PUSHJ	P,STOLMX	;STORE SLOT BACK IN CASE ERROR BITS CHANGED.
VALD4A:	TLNE	F,FL.USR	;USER ASKED?
	PUSHJ	P,WRTCHP	;YES, CHARGE FOR THIS.
	AOBJN	W,VALID0	;AND LOOP FOR NEXT PAGE

	TLNN	P1,VL.WAT	;OK, ALL STARTED OUT. NEED TO WAIT?
	PJRST	CPOPJ1		;NO, GIVE GOOD RETURN.
				;YES, GO DO IT.
;ROUTINE TO WAIT
; NOTE THAT CANNOT TELL THE DIFFERENCE BETWEEN PAGE WE JUST
; STARTED OUT IN THE VALIDATE LOOP AND A PAGE THAT WAS DIRTY
; WHICH SOMEONE (PERIODIC CLEANER OR SWAP RESERVER)
; STARTED OUT. SINCE WE PERSONALLY STARTED OUT ALL DIRTY
; PAGES ABOVE, THE ONLY ONES THAT COULD HAVE SOP ON AND
; ARE CLEAN ARE THOSE THAT GOT WRITTEN IN SINCE WE
; STARTED VALIDATING, AND WE DON'T HAVE TO WAIT FOR THOSE.
; BUT WE DO ANYWAY, SINCE CAN'T TELL THESE FROM ONES WE STARTED
; OUT OURSELVES. NOTE THAT THE PAGE CAN BE DEACTIVATED BY THE SWAP
; OUT ROUTINE, BUT THIS IS OK BECAUSE IF WE CATCH IT N CORE
; AND WAIT WE ARE GUARANTEED TO BE AWAKENED, SINCE
; DEACTIVATION DOES NOT TOUCH THE PGYPGO CHAIN.

	MOVE	W,P2		;SETUP AOBJN POINTER AGAIN.

VALID5:	PUSHJ	P,GETLMX	;GET LMAP SLOT DATA
	TLNE	P3,LMPSUP	;IF THIS IS A SUPER SLOT
	JRST	VALID6		;THEN GO WAIT.
	PUSHJ	P,GETATB	;GET ATB ADDRESS
	TLNE	P1,VL.VPP	;VALIDATE PRIVATE PAGES TOO?
	JRST	VALID6		;YES, DON'T SKIP.
	SKIPGE	ATBSTS(T1)	;FILE PAGE
	JRST	VALID7		;NO, DON'T WORRY ABOUT IT.
VALID6:	PUSHJ	P,GETCPX	;IN CORE?
	  JRST	VALID7		;NO, DON'T HAVE TO WAIT FOR IT. CHECK FOR
				; ERRORS AND DO NEXT PAGE.
	LDB	T1,PGYSIP	;YES. COMING IN?
	JUMPN	T1,VALID7	;YES, DON'T WAIT
	LDB	T1,PGYSOP	;ON ITS WAY OUT
	JUMPE	T1,VALID7	;YES, EITHER WE DIDN'T START IT OUT
				; OR IT IS FINISHED NOW.
	SOSGE	%UPT+UPTLDC	;THROW AWAY LMAP DATA
	STOPCD
	PUSH	P,J		;Save current target frame
	MOVE	J,JOB		;Set up for PAGWAT
	PUSHJ	P,PAGWAT	;MAY NOT HAVE BEEN STARTED OUT BY
				; US, BUT WAIT IN CASE IT WAS.
				;MAY BE DIRTY, BUT IF IT IS,
				; CALLER DIDN'T DIRTY IT.
	POP	P,J		;Restore target frame
	PUSHJ	P,GETLMX	;GET SLOT AGAIN.
	PUSHJ	P,GETCPX	;GET CP AGAIN TO SEE IF ERRORS HAPPENED.
	  JFCL			;PG RETURNED ZERO HERE.
VALID7:	PUSHJ	P,PERCHK	;UPDATE SLOT'S ERROR BITS
	  JRST	VLEIOE		;GIVE ERROR, SLOT STORED ALREADY
	PUSHJ	P,STOLMX	;STORE SLOT IN CASE ERRORS CAME ON.
VALID8:	AOBJN	W,VALID5	;STEP TO NEXT PGE
	PJRST	CPOPJ1		;AND GIVE GOOD RETURN.
COMMENT ;@@SUBROUTINE PERCHK
@@PURPOSE USED BY VALIDATE UUO TO UPDATE LMYERR BITS IN
LMAP SLOT, AND TO INDICATE WHETHER OR NOT TO GIVE USER
ERROR RETURN.
@@ENTRY P3,P4 CONTAIN LMAP SLOT CONTENTS
W CONTAINS VP NUMBER
PG CONTAINS EITHER 0 IF DP NOT IN CORE OR CP NUMBER.
@@ACCUM USES T1-T4, S
@@EXIT P3, P4 CONTAIN NEW LMAP DATA (ERROR BITS MAY HAVE CHANGED)
NON-SKIP IF THERE IS AN ERROR, PAST OR PRESENT, FOR THE
 VP, WITH LMAP SLOT CONTENTS ALREADY STORED (CALLER JUST GIVES ERROR RETURN)
SKIP RETURN IF NO ERRORS OR IF THERE ARE ERRORS AND CALLER IS
 IGNORING THEM (LMPNER). SLOT CONTENTS NOT STORED.
@@RESTRICTIONS
@@FUNCTION IF PG IS NON-ZERO, GET PGYERR BITS.
SEARCH OUTPUT ERROR HASH TABLE FOR DISK ADDRESS, UPDATE
ERROR BITS. GET SLOT'S ERROR BITS, OR IN ANY NEWLY FOUND
ERROR BITS, STORE ERROR BITS BACK IN SLOT. IF ANY ERROR
BITS ARE ON AND SLOT NOT IGNORING ERRORS, CALL STOLMA
AND GIVE NON-SKIP RETURN. ELSE GIVE SKIP RETURN WITH
SLOT DATA STILL IN P3,P4.
@@;

EXTERNAL OHTTAB,OHTDER,OHTPAR,OHTDTE

PERCHK:	SETZ	S,		;CAN'T USE SKIPE S, TRICK
	SKIPE	PG		;IF DP IS IN CORE,
	LDB	S,PGYERR	;GET ERROR BITS FROM PGY
	SKIPN	OHTNUM		;ANY OHT ENTRIES AT ALL? (USUALLY NOT)
	JRST	PERCK1		;NORMAL CASE, GO OR INTO LMAP SLOT
	PUSHJ	P,GETDPA	;SOME ENTRIES, SEARCH FOR DP IN T2
	PUSHJ	P,SRCOHT	;THERE?
	  JRST	PERCK1		;NO.
	MOVE	T1,OHTTAB(T4)	;YES, GET BITS IN T1
	TLNE	T1,OHTDER!OHTPAR ;PARITY SAME AS DEVICE ERROR
	TRO	S,IODERR_-^D15
	TLNE	T1,OHTDTE	;DATA ERROR? (COULDN'T READ RECORD HEADER)
	TRO	S,IODTER_-^D15
PERCK1:	LDB	T1,LM3ERR	;GET BITS ALREADY SET
	IOR	T1,S		;OR IN NEW ONES
	DPB	T1,LM3ERR	;PUT BACK INTO P3
	TLNN	P3,LMPNER	;CALLER'S SLOT IGNORING ERROR?
	PJUMPN	T1,STOLMA	;YES, STORE SLOT AND GIVE ERROR RETURN
	JRST	CPOPJ1		;NO, GIVE SKIP RETURN.
SUBTTL PRE-REFERENCE

;UUO CALL:
;	MOVEI	AC,<PAGE NUMBER>
;	PREREF	AC,
;	  <ERROR RETURN>	;AC/VP#,,ERROR CODE.
;	<SUCCESS RETURN>	AC/1B0 SET IF PAGE READY TO TOUCH
;				AC/1B0 RESET IF TOUCHING PG WOULD CAUSE BLOCKING

	ERRCOD(0,ZZ,ZZ)		;UNUSED
	ERRCOD(1,PRBVP%,PREBVP)	;BAD VP ARG
	ERRCOD(2,ZZ,ZZ)		;(PROTECTION)
	ERRCOD(3,ZZ,ZZ)		;(VP ALREADY EXISTS)
	ERRCOD(4,PRNVP%,PRENVP)	;NON-EXISTENT VIRTUAL PAGE.
	ERRCOD(5,PRNIW%,PRENIW)	;NOT IN USER WORKING SET.
	ERRCOD(6,PROFF%,PREOFF)	;"OTHER FRAME" FAILURE, SUBCODE IN 0-5.

;PURPOSE: PRE-LOADS A PAGE SO USER'S CHANCES
; OF FAULTING FOR THE PAGE ARE LESS
;FUNCTION: SEE IF PAGE IS IN USER WORKING SET. IF NOT, GIVE
; ERROR RETURN. IF SO, PUT PAGE IN MONITOR WORKING SET.
; IF PAGE IS ACTIVE (MAY STILL HAVE SWAP IN IN PROGRESS
; OR MAY STILL BE VIRGIN), JUST RETURN. IF PAGE WAS OK TO
; REFERENCE, USER WILL BE ABLE TO ACCESS THE PAGE.
; IF PAGE WAS NOT IN CORE, TURN ON PRE-REFERENCE BIT
; SO THAT SWAPPER WILL BRING THE PAGE, ALONG WITH ALL THE
; OTHER INACTIVE MWS PAGES, INTO CORE AND ACTIVATE
; THEM. RETURN. WHETHER USER WILL FAULT FOR THE PAGE IN THAAT
; CASE DEPENDS ON WHETHER OR NOT SWAPPER ACTIVATES IT BEFORE
; USER REFERENCES IT.

;NOTE: PREREF EXPECTS AC M TO CONTAIN USER AC# AT ALL
;TIMES.


UPRERF::JSP	T4,DOUUO	;PUSHJ TO PREREF, GIVE PROPER RETURN.
	MOVEI	P3,.ARVAR	;DOESN'T DO ANYTHING THAT REPLICATE READ ONLY DOESN'T DO
	PUSHJ	P,SRDUPX	;MUST MAKE SURE DON'T GET INTO REMOVE CODE WHILE ACTIVATING.
				; REMOVE ASSUMES NO ONE ELSE ACTIVATES THE PAGE.
	  JRST	[MOVSS T1	;GET VP IN LH
		 HRRI T1,PROFF% ;ERROR CODE
		 DPB P3,FDEERP<T1>
		 POPJ P,]

PREREF::SKIPGE	T1		;TRANSFER EXEC/USER BIT TO 1B0 OF F
	TLOA	F,FL.USR
	TLZ	F,FL.USR
	HRRZ	W,T1		;GET ADDRESS IN W
	JSP	T4,VPCHK	;IS IT IN RANGE
	  JRST	PREBVP		;NO, GIVE ERROR RETURN, NOT IN RANGE
	CAIL	W,777		;EXEC PER PROCESS PAGE
	JRST	PRERF1		;YES, SKIP UWS CHECK
	PUSHJ	P,TSTUWS	;USE PAGE. MUST BE IN UWS
	  JRST	PRENIW		;IS NOT, GIVE ERROR CODE.

PRERF1:	PUSHJ	P,GETLMX	;GET LMAP SLOT DATA
	TLNN	P3,LMMEXS	;EXISTS
	JRST	PRENVP		;NO.
	PUSHJ	P,PRFMWS	;PUT IT INTO MWS, DON'T WAIT FOR SWAP
	PUSHJ	P,STOLMX	;SET LMAP SLOT DATA, NEW A BIT MAYBE
	TLNE	P3,LMPACT	;PAGE ACTIVE NOW
	JRST	PRERF2		;CHECK WHETHER TO RETURN 1B0 TO USER
	MOVEI	T1,PRF		;NO, MAKE SWAPPER BRING IT IN
	IORM	T1,JBTSTS(J)
	SETOM	CALSWP		;MAYBE SWAPPER CAN DO IT NOW.
	JRST	PRERF3		;SRETURN & RESET 1B0 USER AC

PRERF2:	PUSHJ	P,GETCPA	;GET PG/PHYS PAGE
	LDB	T1,PGYSIP	;IF SWAP-IN NOT IN PROGRESS
	JUMPE	T1,.+2		;RETURN 1B0 SET
PRERF3:	TLZA	W,-1		;RETURN LH USER AC ALL ZEROS
	HRLI	W,(1B0)		;SWAP NOT GOING, PAGE NOW AVAILABLE
	UMOVEM	W,(M)		;<BIT>,,VP
	JRST	CPOPJ1
SUBTTL WORKING SET CONTROL UUOS

;UUO CALL:
;
;	MOVE	AC,[FUNCTION #,,ADDR]
;	WSCTL	AC,
;	  <ERROR RETURN>	;AC/ VP#(IF RELEVANT, ELSE 0),,ERROR CODE.
;	<SUCCESS RETURN>
;
;ADDR CONTAINS DIFFERENT THINGS FOR THE DIFFERENT FUNCTIONS.

;FUNCTION CODES:

	XP .WSRBM,0		;READ BIT MAP OF WS, LIMIT AND SIZE TOO.
	  XP .WSBTM,0		;FIRST WORD OF BIT MAP

	XP .WSRNG,1		;ADD/REMOVE BY RANGE
	  XP WS.ADD,(1B7)	;IF ON SAYS TO ADD, IF OFF, REMOVE.

	XP .WSSTL,2		;SET WS LIMIT
				;ADDR CONTAINS THE LIMIT.

	XP .WSRSZ,3		;READ SIZE

	XP .WSRLM,4		;READ LIMIT

	XP .WSRMX,5		;READ MAX LIMIT (SET BY CONSOLE COMMAND)

;ERROR CODES:

	ERRCOD(0,WSBCN%,WSEBCN)	;BAD COUNT
	ERRCOD(1,WSBVP%,WSEBVP)	;BAD VP NUMBER
	ERRCOD(2,ZZ,ZZ)		;PROTECTION
	ERRCOD(3,ZZ,ZZ)		;(VP ALREADY EXISTS)
	ERRCOD(4,WSNVP%,WSENVP)	;VP DOES NOT EXIST AND SHOULD
	ERRCOD(5,WSBFN%,WSEBFN)	;BAD FUNCTION NUMBER
	ERRCOD(6,WSRTM%,WSERTM)	;TRYING TO READ TOO MUCH OF BIT MAP
	ERRCOD(7,WSATM%,WSEATM);ADDED TOO MUCH, EXCEEDED LIMIT
	ERRCOD(10,WSLOM%,WSELOM);ATTEMPT TO SET LIMIT OVER MAX LIMIT
	ERRCOD(11,WSLUS%,WSELUS);ATTEMPT TO SET LIMIT BELOW MINIMUM (3P) SIZE.
UWSCTL::JSP	T4,DOUUO	;DO THE PUSHJ, SAVE ERROR CODE

;CANNOT PUSHJ TO WSCTL UNLESS PC.UIO IS OFF, SINCE IT DOES
; UMOVES TO GET ARGS.
;Upon entry at WSCTL, T1 contains caller's argument address in RH,
; LH has WSCTL function code plus sign bit (bit 0) if PC.USR was
; on at call to DOUUO.

WSCTL:	NOCHARGE	;TURN OFF THE CLOCK.
	SETZ	W,		;IN CASE W NOT SETUP.
	TLZE	T1,FL.USR	;SKIP IF CALLED FOR EXEC
	TLOA	F,FL.USR	;SET SIGN BIT OF IF IF USER WAS ON
	TLZ	F,FL.USR	;EXEC, SO CLEAR THE BIT.
	HRRZ	M,T1		;GET BLOCK ADDRESS
	HLRES	T1		;GET FUNCTION NUMBER IN T1
	JUMPL	T1,WSEBFN	;ERROR, BAD FUNCTION CODE
	CAILE	T1,MAXWSF	;TOO BIG?
	JRST	WSEBFN		;YES, GIVE ERROR
	MOVE	T2,BITTBL(T1)	;Get bit corresponding to fn code
	TDNN	T2,WSMAP	;Does this function clear MWS adj?
	  JRST	WSCTL1		;No, not ever
	MOVEI	T2, JWSADJ
	TLNE	F, FL.USR	;IF BEING CALLED BY USER,
	ANDCAM	T2, JBTSTS(J)	;  TURN OFF MWS ADJUSTMENT
WSCTL1:
	ROT	T1,-1		;DIVIDE BY 2
	SKIPGE	T1		;USE RH IF FUNCTION IS ODD
	SKIPA	T2,WSDSP(T1)	;ELSE
	MOVS	T2,WSDSP(T1)	;USE LEFT HALF
	AOS	(P)		;ASSUME SKIP RETURN
	PUSHJ	P,(T2)		;DO THE FN
	  SOS	(P)		;GIVE ERROR RETURN
	POPJ	P,		;AND RETURN.

;DISPATCH TABLE FOR WSCTL UUO

WSDSP:	RDWSMP,,WSRNGE		;(0,1)READ BIT MAP, SET BY RANGE
	STWSLM,,WSRDSZ		;(2,3)SET LIMIT, READ SIZE
	WSRDLM,,WSRDMX		;(4,5)READ LIMIT, READ MAX LIMIT

MAXWSF==<.-WSDSP>*2-1		;MAXIMUM FUNCTION NUMBER

;;
;; Bit map which indicates which of the WSCTL functions should
;; clear JBTSTS<JWSADJ>.  If bit is zero, JBTSTS<JWSADJ> should
;; not be changed.  Note: this will obviously work only for 36 or
;; fewer WSCTL function codes.
;;

WSMAP:	EXP 1B<.WSRNG>+1B<.WSSTL>
;FUNCTION .WSRBM, READ WORKING SET BIT MAP INTO USER'S ARG BLOCK.

RDWSMP:	UMOVE	P1,(M)		;GET COUNT
	HRRI	M,1(M)		;ADVANCE TO NEXT USER LOC
	JUMPLE	P1,CPOPJ1	;IF USER'S COUNT WAS .LE. 0,
				;JUST GIVE GOOD RETURN
	CAILE	P1,<<^D512+^D35>/^D36> ;IF TOO LARGE,
	JRST	WSERTM		;GIVE ERROR.

;NOW RETURN HIM THE BIT MAP FOR UWS

	MOVSI	T1,%UPT+UPTUWB	;SOURCE
	HRRI	T1,(M)		;DESTINATION IN USER AREA
	ADDI	P1,-1(M)	;LAST WORD TO TRANSFER TO
	XCTTU	<BLT T1,(P1)> ;PUT INTO USER'S AREA
	JRST	CPOPJ1		;AND RETURN.
;FUNCTION .WSRNG, ADD OR REMOVE PAGES FROM UWS BY RANGES.
;
;USER LOCATION CONTAINS COUNT,,FIRST PAGE. BIT 7 IS ON IF
; PAGES ARE TO BE ADDED TO WORKING SET, OFF IF TO
; BE REMOVED.

WSRNGE:	PUSHJ	P,TIMADJ	;RECORD SIZE CHARGING ELEMENTS
				;BEFORE JBYUWS CHANGES.
	UMOVE	T1,(M) 		;GET USER ARG
	LDB	W,[POINT 10,T1,17] ;NUMBER PAGES TO DO
	JUMPE	W,WSEBCN	;BAD COUNT
	HRLOI	W,-1(W)		;GET COUNT-1,,-1
	EQVI	W,(T1)		;COMPLEMENT LH, GET ADDR IN RH
	TLNN	T1,WS.ADD	;ADD OR REMOVE?
	JRST	WSREMV		;REMOVE.

	LDB	P1,UPYUWL	;GET LIMIT FOR CHECKING
	MOVSI	P2,LMMEXS	;TO CHECK FOR EXISTENCE
	HRRZ	U,W		;REMEMBER START VP FOR CHARGING.
WSRAD1:	LDB	T1,JBYUWS	;GET NEW SIZE
	CAML	T1,P1		;STILL BELOW?
	JRST	[PUSHJ P,WSTCHG ;NO, ERROR, CAN'T ADD MORE
		JRST WSEATM]	;
	JSP	T4,VPCHK	;ALLOWED TO MESS WITH THIS?
	JRST	[PUSHJ P,WSTCHG	;
		JRST WSEBVP]	;
	TDNN	P2,%UPLMA(W)	;EXISTS?
	JRST	[PUSHJ P,WSTCHG ;NO, ERROR
		JRST WSENVP]	;
	PUSHJ	P,TSTUWS	;THERE ALREADY?
	  JRST	.+2		;NO
	JRST	WSRAD2		;YES, DO NEXT ONE.
	PUSHJ	P,SETUWS	;OK, ADD IT TO UWS
	PUSHJ	P,GETLMA	;GET LMAP SLOT DATA IN P3,P4
	TLNE	P3,LMPSUP	;IF SUPER PAGE
	JRST	WSRA1A		;THEN DON'T MESS WITH ATB
	TLNE	P3,LMPVIR	;IF ITS VIRGIN, MAY BE A FREE ONE
	JRST	[PUSHJ P,GETATB
		 SKIPGE ATBDUM(T1) ;IS IT A PRIVATE PAGE?
		 AOJA U,.+1	;YES, CHARGE FOR ONE LESS
		 JRST .+1]	;RETURN BACK.
WSRA1A:	PUSHJ	P,CINMWS	;TRY TO PUT INTO MWS
	PUSHJ	P,STOLMA	;PUT LMAP SLOT DATA BACK.
WSRAD2:	AOBJN	W,WSRAD1	;AND CONTINUE
	PUSHJ	P,WSTCHG	;CHARGE IF USER CALLED.
	JRST	CPOPJ1		;OK, RETURN.

WSREMV:	JSP	T4,VPCHK	;OK FOR CALLER TO CHANGE?
	  JRST	WSEBVP		;NO, GIVE ERROR
	PUSHJ	P,GETLMA	;GET LMAP SLOT DATA
	TLNN	P3,LMMEXS	;IF SLOT DOES NOT EXIST,
	JRST	WSREM1		;SKIP THE WORK.
	PUSHJ	P,REMUWS	;POSSIBLY TAKE OUT OF MWS
	PUSHJ	P,STOLMA	;PUT SLOT DATA BACK
WSREM1:	AOBJN	W,WSREMV	;AND TO WHOLE RANGE
	JRST	CPOPJ1		;GIVE SUCCESS RETURN
;FUNCTION .WSSTL, SET WORKING SET LIMIT.

STWSLM:	UMOVE	T1,(M) 		;GET DESIRED LIMIT
	LDB	T2,UPYUWM	;GET MAX IT CAN BE SET TO
	CAMLE	T1,T2		;UNDER OR = TO THE MAX?
	JRST	WSELOM		;NO, ERROR
	CAIGE 	T1,3		;CANT SET BELOW 3 ELSE
	JRST 	WSELUS		;SYSTEM CAN HANG IN I/O BLTS,ETC.
	DPB	T1,UPYUWL	;OK, SET NEW LIMIT
	LDB	T2,JBYUWS	;GET SIZE NOW
	CAMLE	T2,T1		;IF SIZE IS NOW GREATER THAN LIMIT,
	PUSHJ	P,UWSRPL	;MAKE IT LESS ( DOES ONE TOO MANY PAGES, BUT TOO BAD.)
	PJRST	CPOPJ1		;AND RETURN.

;FUNCTION .WSRSZ READ WORKING SET SIZE
; AC HAS FN,,ADDR TO RETURN SIZE IN

WSRDSZ:	LDB	T1,JBYUWS	;GET UWS SIZE
	UMOVEM	T1,(M)		;RETURN IT
	JRST	CPOPJ1		;AND GO BACK.

;FUNCTION .WSRLM READ WORKING SET LIMIT

WSRDLM:	LDB	T1,UPYUWL	;GET LIMIT
	UMOVEM	T1,(M)		;RETURN IT
	JRST	CPOPJ1		;AND RETURN

;FUNCTION .WSRMX READ MAX LIMIT SET BY CONSOLE COMMAND

WSRDMX:	LDB	T1,UPYUWM	;GET MAX LIMIT
	UMOVEM	T1,(M)
	JRST	CPOPJ1
;ROUTINE TO CALL TO CHARGE FOR PAGES ADDED TO USER WORKING SET.
; U CONTAINS "ADJUSTED" FIRST PAGE NUMBER ADDED TO WORKING SET.
; ADJUSTMENT IS MADE BY INCREMENTING IT FOR EVERY VIRGIN PRIVATE
; PAGE WE ADD TO UWS, THEREBY CHARGING FOR ONE LESS PAGE.
; NOTE THAT ONLY VIRGIN BIT IS CHECKED, SO IF WE REPLICATE
; A VIRGIN PAGE AND THEN VIOLATE IT, THE ORIGINAL COPY
; STILL HAS VIRGIN BIT ON AND CAN BE ADDED TO UWS FREE.
; THIS IS FOR SAKE OF SAVING TIME. (TSTVIR TOO LONG TO CALL).
;DESTROYS T1-T4.

WSTCHG:	TLNN	F,FL.USR	;DON'T CHARGE IF MONITOR IS PUTTING PAGES INTO UWS
	POPJ	P,		;BYE.
	MOVN	T4,U		;GET -START
	ADDI	T4,(W)		;GET -START+END (END-START)
	PJRST	CHGPWS		;AND CHARGE, RETURN.


COMMENT #
@@SUBROUTINE CHGPWS
@@PURPOSE
SUBR TO CHARGE FOR ADDING N PAGES TO THE UWS.
@@ENTRY
EXPECTS T4/ NO. OF PAGES ADDED, AND J/ JOB NUMBER.
@@ACCUM
DESTROYS T1-T4.
@@ #

EXTERN JBTPWS,JBTPWL,JBTPWH,GTCGSZ


CHGF==^D100			;F.
CGF104: <CHGF+1>*23420		;23420=10000.

CHGPWS:: ADDM	T4,JBTPWS(J)
	ADDM	T4,JBTPWS
	PUSHJ	P,GTCGSZ	;GET T1/ CHARGING SIZE OF JOB.
	IMULI	T1,(T4)		;T1/WSS*P.
	IMUL	T1,CGF104	;T1/WSS*P*(F+1)*10000.
	ADDI	T4,CHGF		;T4/(F+P).
	IDIVI	T1,(T4)		;(WSS*P*(F+1)*10000.)/(F+P).
CHGPW4:	MOVE	T2,JBTPWL(J)	;ADD TO THE COUNT FOR
	ADD	T2,T1		;THE JOB, TAKING
	TLZE	T2,400000	;CARE
	AOS	JBTPWH(J)	;OF OVERFLOW.
	MOVEM	T2,JBTPWL(J)	;
	MOVE	T2,JBTPWL	;DITTO FOR THE
	ADD	T2,T1		;SYSTEM COUNT.
	TLZE	T2,400000	;
	AOS	JBTPWH		;
	MOVEM	T2,JBTPWL	;
	POPJ	P,



COMMENT #
@@SUBROUTINE CHGUPA
@@PURPOSE
SUBR TO CHARGE FOR MAKING US DO THE UPRA FOR N PAGES.
@@ENTRY
EXPECTS T4/ NO. OF PAGES AND J/ JOB NUMBER.
@@ACCUM
DESTROYS T1-T4.
@@ #

CHGUPA:	PUSHJ	P,GTCGSZ	;GET T1/ CHARGING SIZE OF JOB.
	IMULI	T1,(T4)		;TIMES NO. OF TIMES WE DID UPRA.
	IMULI	T1,^D100	;1% OF ADD TO UWS SIZE.
	JRST	CHGPW4		;
;ERROR RETURNS

ERR00:	JSP	T1,ECOD		;(0)
ERR01:	JSP	T1,ECOD		;(1)
ERR02:	JSP	T1,ECOD		;(2)
ERR03:	JSP	T1,ECOD		;(3)
ERR04:	JSP	T1,ECOD		;(4)
ERR05:	JSP	T1,ECOD		;(5)
ERR06:	JSP	T1,ECOD		;(6)
ERR07:	JSP	T1,ECOD		;(7)
ERR10:	JSP	T1,ECOD		;(10)
ERR11:	JSP	T1,ECOD		;(11)
ECOD:	SUBI	T1,ERR00+1	;COMPUTE ERR CODE
	HRL	T1,W		;T1/ VP#,,CODE
	POPJ	P,		;RETURN.

;ROUTINE TO INTERFACE BETWEEN UUOCON AND NEW VIRTUAL PAGE
; UUO KERNALS. SAVES USER AC NUMBER, SETS SIGN BIT OF T1
; TO 0 IF EXEC MODE CALL, 1 IF USER MODE CALL, CALLS THE
; UUO KERNAL. IF UUO KERNAL GIVES ERROR CODE, IT WILL BE
; IN T1, SO RESTORE USER AC NUMBER AND STORE THE ERROR CODE
; IN USER'S AC. IF UUO KERNAL GIVES SKIP RETURN, JUST
; POP M OFF STACK AND GIVE SKIP RETURN TO UUOCON. CALL:
;
;
;	JSP	T4,DOUUO
;UUO:	<UUO CODE TO PUSHJ TO>
;
;
EXTERNAL PDNMUP

DOUUO:	MOVSI	T3,PC.USR	;IS THE CALL FROM USER?
	TDNE	T3,PDNMUP(P)	;GET PC FROM DEFINED PLACE ON STACK RELATIVE TO HERE.
	TLOA	T1,FL.USR	;YES, SET THIS IS USER BIT
	TLZ	T1,FL.USR	;NO, IS EXEC CALL.
	PUSH	P,M		;SAVE USER AC NUMBER
	PUSHJ	P,(T4)		;CALL THE UUO KERNAL WITH USER ARG IN T1
	  JRST	[POP P,M
		 UMOVEM T1,(M)	;SAVE VP,,ERROR CODE IN USER AC
		 POPJ P,]	;RETURN
	PJRST	TPOPJ1		;GET M OFF STACK AND GIVE SUCCESS
SUBTTL PAGSTS UUO

COMMENT ! ENTRY UPGSTS -- COME HERE FROM UUOCON DISPATCH

EXPECTS: M & W/ USER AC #
	J/JOB
	T1/ C(USER AC) = <OTFFLG>B1+VP#
FUNCTION: CALL KERNEL VIA LOCAL INTERFACE ROUTINE WHICH SETS
	UP AC'S ETC.

UUO CALLED: MOVE AC,[<OTFFLG>B1+VP#]
	    PAGSTS AC,
		ERR RETURN, AC/VP#,,0 (ILLEGAL VP#)
	    SUCCESS RETURN, AC/ DATA
!

UPGSTS::
	JSP T4,DOUUO
	MOVEI P3,.ARRDM	;NEED READ MAP ACCESS TO SEE PAGE STATUS.
	PUSHJ P,SWRUPX	;GET CORRECT CONTEXT PAGES IN %UPX
	  JRST [MOVSS T1
		HRRI T1,PSOFF%
		DPB P3,FDEERP<T1>
		POPJ P,]

COMMENT ! ROUTINE VPGSTS -- KERNEL
EXPECTS: T1/<USER>,,VP#  J/JOB, M/USER AC#
FUNCTION: RETURN T1/ STATUS INFO FOR VP TO USER LOC (M)
RESTRICTION: MONITOR ROUTINES WISHING TO PUSHJ DIRECTLY HERE
	MUST SET 1B0=<USER> IN T1 IF USER PROTECTION IS
	DESIRED (VP>777 ILLEGAL) OR CLEAR IT IF MONITOR
	PROTECTION DESIRED (VP > VPUMAX ILLEGAL). ALSO
	WATCH OUT FOR P3,P4 CLOBBERED AND NOTE THIS ROUTINE
	STORES IN USER SPACE AT (M)
DESTROYS: T1-T4,PG,P1,P3,P4, 1B0 IN F
CALL:	MOVEI T1,VP#  OR MOVE T1,[<USER>,,VP#]
	MOVE J,JOB
	PUSHJ P,VPGSTS
	 ERR RETURN, VP# ILLEGAL, T1/VP#,,0
	SUCCESS RETURN, T1/DATA AS FOLLOWS:
!

;THE NAMES OF PAGSTS BITS, DEFINED GLOBALLY FOR OTHER MODULES
XP PS.UWS,(1B0)		;IN USER WORKING SET
XP PS.REF,(1B1)		;THE REFERENCE BIT
XP PS.MXW,(1B2)		;ON IF THE PAGE CAN BE PROTECTED READ/WRITE
XP PS.SUP,(1B3)		;ON IF THE PAGE IS A SUPER PAGE
XP PS.DER,(1B4)		;DEVICE ERROR
XP PS.DTE,(1B5)		;DATA ERROR
  XP PS.DDE,(1B4!1B5)	;MASK.
XP PS.DRT,(1B6)		;ON IF PAGE NOT DIRTY OR SWAP OUT GOING.
XP PS.NER,(1B7)		;IGNORE ERRORS IN EFFECT FOR THIS PAGE
XP PS.OER,(1B8)		;PAGE HAS AN OUTPUT ERROR - STATUS BITS
			; ARE THE OR OF OUTPUT AND INPUT ERROR STATUS.
XP PS.PAR,(1B9)		;PARITY ERROR ON DIRTY PAGE. SOMETIMES
			; PS.DER IS ALSO SET WITH THIS.
XP PS.FIL,1B32		;ON IF THE PAGE WAS ORIGINALLY MAPPED FROM A FILE
			; (MAY NOT BE IN THE FILE ANYMORE).
XP PS.CPR,7B35		;CURR PROT (CPRRED,CPRCOW,CPRRDW) OR
			;ZERO IF PG NON-EXISTENT


;ERROR CODES:

	ERRCOD(0,ZZ,ZZ)		;(BAD COUNT)
	ERRCOD(1,PSBVP%,PSEBVP)	;BAD VP NUMBER
	ERRCOD(7,PSOFF%,PSEOFF) ;"OTHER FRAME" FAILURE, SUBCODE IN 0-5.
VPGSTS::HRRZ W,T1	;VP
	TLZ F,FL.USR	;THIS WILL GET SET IF USER LIMITATIONS 
	TLNE T1,FL.USR	;DESIRED ON VP#
	TLO F,FL.USR	;SEE VPCHK
	JSP T4,VPCHK	;LEGIT VP# IN W?
	 JRST PSEBVP	;GRONK
	PUSH P,M
	PUSHJ P,REDLMX	;RETURN P3,P4 LMAP SLOT DATA
	MOVEI P1,0
	TLNN P3,LMMEXS	;IF PG DOESNT EXIST, RETURN
	JRST VPGSX	;ONLY PS.REF AND PS.CPR=0
;BEGIN CODE FOR EXISTENT SLOTS ONLY
	TLNE P3,LMPSUP	;IF SUPER, NO ATB ADDR
	JRST VPGST2
	PUSHJ P,GETATB	;RETURN T1/ATB ADDR
	SKIPL ATBSTS(T1)	;FILE PAGE ? (ATBDUM=1B0)
	TRO P1,PS.FIL	;NOTE THE FACT
VPGST2:	PUSHJ P,TSXUWS	;SKIP IF UWS BIT ON
	  SKIPA
	TLO P1,PS.UWS
	TLNE P3,LMPSUP
	TLO P1,PS.SUP
	LDB T2,LM3ERR	;BOTH ERROR BITS
	DPB T2,[POINT 2,P1,5]	;PS.DDE ARE 1B4 1B5
	TLNE P3,LMPMXW
	TLO P1,PS.MXW
	TLNE P3,LMPNER	;COPY IGNORE ERROR BIT TO RETURN ARG
	TLO P1,PS.NER
	LDB T2,LM3CUR	;T2/CURR PROT
	IOR P1,T2
	PUSHJ P,GETDPA	; GET T2/DISK RETR. PTR.
	SKIPN OHTNUM	;ANY OUTPUT ERRORS INSYSTEM?
	JRST VPGS2A	;NO
	PUSHJ P,SRCOHT	;SEE IF THIS PAGE IS IN OHT
	  JRST	VPGS2A	;NO, OK.
	TLO P1,PS.OER	;YES, TELL USER
	MOVE T1,OHTTAB(T4)	;GET OHT DATA
	TLNE T1,OHTPAR	;PARITY ERROR?
	TLO P1,PS.PAR	;YES, SET RETURN ARG BIT FOR IT
	LDB T1,[POINT 2,T1,1] ;GET ERROR STATUS BITS
	LSH T1,^D35-^L<PS.DTE>+^D18 ;POSITION FOR RETURN ARG
	IOR P1,T1	;OR THESE INTO EXISTING ERROR BITS.
VPGS2A:	PUSHJ P,GETCPX	;IN CORE?
	  JRST VPGSX	;NOT IN CORE, DONT SET PS.DRT
VPGST3:	LDB T3,PGYSTS
	TRNE T3,PGPSOP!PGPDRT	;IF EITHER DRT OR SOP SET,
	TLO P1,PS.DRT	;TELL USER NO GOOD DISK COPY
;END OF CODE FOR DEFINITELY EXISTENT VP SLOTS
VPGSX:	TLNE P3,LMPREF
	TLO P1,PS.REF
	POP P,M		;USER AC# TO RETURN DATA INTO
	UMOVEM P1,(M)
	JRST CPOPJ1
SUBTTL VPGFIL UUO

COMMENT ! ENTRY VPGFIL -- COME HERE FROM UUOCON DISPATCH

UUO CALLED BY USER:
	MOVE AC,[-COUNT,,BLOCK]
	VPGFIL AC,
	 ERROR AC/VP#,,CODE
	SUCCESS AC UNCHANGED, BLOCK HAS NEW DATA
BLOCK:	VP#	(ARGUMENT; REST OF BLOCK IS RETURN DATA)
	<BITS>   1B0 SET IF FILE MARKED FOR DELETION
	SIXBIT /STRUCTURE/
	SIXBIT /FILENAME/
	SIXBIT /EXT/
	ZERO
	PPN
	ZERO

FUNCTION: RETURN THE FILENAME,ETC. FROM WHICH VP WAS MAPPED.
	(RETURN AS MUCH OF THE INFO AS <COUNT> ALLOWS IN BLOCK.)

EXPECTS: M/ USER AC #
	J/ JOB
	T1/ <-COUNT>,,<BLOCK ADDR>
CALL THE UUO KERNEL VIA DOUUO INTERFACE.

!

;ERR CODES
	ERRCOD (0,ZZ,ZZ)		;NOT USED
	ERRCOD (1,PFBVP%,VPFBVP)	;BAD VP#
	ERRCOD (2,ZZ,ZZ)		;NOT USED
	ERRCOD (3,ZZ,ZZ)		;NOT USED
	ERRCOD (4,PFNEX%,VPFNEX)	;NON-EXISTENT PG
	ERRCOD (5,ZZ,ZZ)		;NOT USED
	ERRCOD (6,PFNFP%,VPFNFP)	;NOT FILE PAGE
	
; NOTE: FOR SUPER PAGES, THE STRUCTURE-NAME & ZEROS ARE RETURNED

VPGFIL::
	MOVE P1,T1	;P1/USER AOBJN DURING WHOLE UUO
	AOBJP P1,CPOPJ1	;SUCCEED NO DATA WRITTEN IF COUNT=-1
	UHRRZ W,-1(P1)	;W/VP#
	JSP T4,DOUUO	;PUSHJ TO .+1

COMMENT ! KPGFIL -- UUO KERNAL VPGFIL UUO
EXPECTS: T1/1B0 SET FOR USER PAGE PROTECTION, ELSE EXEC
	W/ VP#
	P1/ USER AOBJN FOR DATA TO BE WRITTEN
DESTROYS: PRACTICALLY EVERYTHING: S,U,W,P1-P4,T1-T4,PG,..
RESTRICTIONS: WRITES ON USER SPACE AT (P1). PC.UIO MUST BE ON.
	ANYBODY PUSHJ'ING HERE MUST SET PC.UIO AND 1B0 IN T1
	UNLESS EXEC PAGE PRIVS DESIRED.
!

KPGFIL:
	TLNE T1,FL.USR
	TLOA F,FL.USR	;TRANSFER <USER> TO F, FOR VPCHK
	TLZ F,FL.USR
	JSP T4,VPCHK
	 JRST VPFBVP	;CRUMMY VP
	PUSHJ P,GETLMA	;RETURN P3,P4 SLOT DATA
	TLNN P3,LMMEXS	;EXISTS?
	 JRST VPFNEX
	TLNE P3,LMPSUP	;SUPER PAGE?
	 JRST [	SETZB S,P2	;YES,RETURN ALL ZEROS 
		SETZB P3,P4	;EXCEPT STRNAM
		JRST KPFSP]	;GO PICK UP IN U
		;BESIDES, SUPER PAGES HAVE NO ATB
	PUSHJ P,GETATB		;GET T1/ATB, CLOB PG
	SKIPGE ATBSTS(T1)	;ATBDUM SET?
	 JRST KPFUU1	;YES,PRIVATE PAGE. ERROR
	HRRZ T2,ATBFNB(T1)	;T2/FNB
	HRRZ T3,FNBDRB(T2)	;T3/DRB
	MOVE S,ATBSTS(T1)	;PREPARE TO RETURN <BITS>
	TRNN S,ATPDEL		;MARKED FOR DELETION?
	TDZA S,S		;NO
	MOVSI S,(1B0)
	MOVE P2,FNBNAM(T2)	;SIXBIT/FILENAME/
	HRLZ P3,FNBEXT(T2)	;SIXBIT/EXT/
	MOVE P4,DRBNAM(T3)	;PPN
KPFSP:	;COME HERE ALSO IF SUPER PAGE
	MOVE U,STRDDB+STRNAM
	;DONE WITH SLOT DATA
	SOSGE %UPT+UPTLDC
	STOPCD
	;NOW U/STR S/<BITS> P2/FILENAME P3/EXT P4/PPN
	;RETURN AS MUCH OF THIS AS POSSIBLE
	UMOVEM S,(P1)
	AOBJP P1,CPOPJ1
	UMOVEM U,(P1)
	AOBJP P1,CPOPJ1
	UMOVEM P2,(P1)
	AOBJP P1,CPOPJ1
	UMOVEM P3,(P1)
	AOBJP P1,CPOPJ1
	XCTBU <SETZM (P1)>
	AOBJP P1,CPOPJ1
	UMOVEM P4,(P1)
	AOBJP P1,CPOPJ1
	XCTBU <SETZM (P1)>
	JRST CPOPJ1



KPFUU1:	;VP WAS PRIVATE
	SOSGE %UPT+UPTLDC
	STOPCD
	JRST VPFNFP	;ERROR EXIT NOT FILE PAGE

EXTERN ATBFNB,ATPDEL,DRBNAM,FNBDRB,FNBEXT,FNBNAM,STRNAM
SUBTTL REFBIT UUO
COMMENT ! ENTRY URFBIT -- ENTER HERE FROM UUOCON DISPATCH
EXPECTS: T1/FUNCTION,,LOC    M/ USER AC#
!
URFBIT::	JSP T4,DOUUO	;SAVES M,SETS <USER> IN T1 ACCORDING TO CALLER
			;& CALLS KERNEL,FOLLOWING IMMEDIATELY.

COMMENT ! ROUTINE VRFBIT -- REFBIT UUO KERNL
FUNCTION: DECODE REFBIT FUNCTION NOS., DISPATCH TO REQUIRED
	CODE. 0: READ REFBITS INTO BITMAP; 1: SET REFBITS
	FROM USER BITMAP; 2: SET/CLEAR REFBITS BY PAGE RANGE.
EXPECTS: T1/<USER>1B0+<FUNCTION>B17+USERLOC
RESTRICTIONS: MONITOR ROUTINES WISHING TO PUSHJ HERE SHOULD SET
	<USER> PROPERLY IN T1. NOTE THAT THESE ROUTINES READ/WRITE
	ON USER SPACE.
!

;FUNCTION CODES

	XP .RFRBM,0	;RETURN BIT MAP

	XP .RFSBM,1	;SET REF BITS BY A BIT MAP.

	XP .RFRNG,2	;SET/CLEAR BY RANGE
	  XP RF.SET,(1B7) ;IF ON, SET, IF OFF, CLEAR.

;ERROR CODES:

	ERRCOD(0,RFBCN%,RFEBCN)	;BAD COUNT
	ERRCOD(1,RFBVP%,RFEBVP)	;BAD VP NUMBER
	ERRCOD(2,ZZ,ZZ)		;PROTECTION IS BAD
	ERRCOD(3,ZZ,ZZ)		;(VP ALREADY EXISTS)
	ERRCOD(4,ZZ,ZZ)		;(VP DOES NOT EXIST)
	ERRCOD(5,RFBFN%,RFEBFN)	;BAD FUNCTION NUMBER
VRFBIT:
	TLZ F,FL.USR	;KEEP <USER> IN F. SEE VPCHK
	TLZE T1,FL.USR	;TEST & CLEAR <USER> IN T1
	TLO F,FL.USR	;USER PROT IN FORCE
	HRRZ M,T1	;M/LOC
	HLRZS T1		;T1/FUNCTION #
	CAILE T1,MAXRUF
	JRST RFEBFN
	ROT T1,-1
	MOVE T2,%RUTB(T1)	;
	TLNN T1,(1B0)		;FUNCTION # ODD? NO NEED TO SWAP
	MOVSS T2
	JRST (T2)

%RUTB:	RFBT0,,RFBT1
	RFBT2,,RFEBFN
MAXRUF==<.-%RUTB>*2-1


COMMENT ! ROUTINE RFBT2 - REFBIT FUNCTION 2, SET/CLEAR BY RANGE
EXPECTS: M/ USER LOC, F/<USER> IN 1B0
	LOC/ <SET/CLEAR>B7+<COUNT>B17+<START VP#>
FUNCTION: SET OR CLEAR THE REFBITS FOR COUNT PAGES BEGINNING
	WITH START VP. ERROR 10 IF COUNT=0. ERROR 6 IF BAD VP.
DESTROYS: T1,T4,F,W,P3,P4,T2
!

RFBT2:
	UMOVE T1,(M)
	HRRI F,0	;RH(F) WILL BE 0 FOR CLEAR,
	TLNE T1,RF.SET	;OR 1 FOR SET
	HRRI F,1
	HRRZ W,T1	;VP
	LDB T1,[POINT 10,T1,17]
	JUMPE T1,RFEBCN	;COUNT 0 ILLEG
	MOVNS T1
	HRL W,T1	;W/ -COUNT,,VP#  AOBJN
	HRRZ T2,F	;NOW T2/0 OR 1 FOR CLEAR/SET ARG REFBC
RFBT2A:
	JSP T4,VPCHK	;W/VP# LEGIT?
	JRST RFEBVP
	PUSHJ P,REFBC	;CHANGE REFBIT. TAKES T2/ 0 OR 1. CLOB P3,P4
	AOBJN W,RFBT2A		;LOOP FOR COUNT PAGES
	JRST CPOPJ1

COMMENT ! REFBC - LITTLE ROUTINE TO CHANGE REFBIT & PGE.A
EXPECTS: T2/ 0 OR 1, TO CLEAR OR SET REFBIT
	W/ VP#
DESTROYS: P3,P4,T1
NOTE: RESETS PGE.A WHEN RESETTING REFBIT FOR A SLOT. DOESNT
	HURT IF SLOT IS INACTIVE/NON-EXISTENT PG.
!

REFBC:
	PUSHJ P,GETLMA	;GET P3,P4 SLOT
	TLNN P3,LMMEXS	;IF DOESNT EXIST,
	AOS 	%UPT+UPTLDC	;AOS FOR STOLMA
	JUMPN T2,REFBC1
	TRZ P4,PGE.A
	TLZA P3,LMPREF
REFBC1:
	TLO P3,LMPREF
	PUSHJ P,STOLMA
	POPJ P,
COMMENT ! ROUTINE RFBT0 - REFBIT FUNCTION 0 RETURN BITMAP TO USER
FUNCTION: RETURN A BITMAP TO USER FOR VP 0 TO 777 STOPPING
	SOONER IF USER <COUNT> OF BITMAP WORDS RUNS OUT.
EXPECTS: M/LOC
	LOC/ <COUNT> OF WORDS FOLLOWING
	LOC+1/ BITMAP TO BE WRITTEN BEGINNING HERE..
	..
	LOC+COUNT/ BITMAP QUITS HERE
DESTROYS: T1,U,W,P1,P3,P4
!

RFBT0:
	UMOVE P1,(M)	;COUNT
	IMULI P1,^D36
	HRR U,M		;CONSTRUCT BYTE PTR IN U FOR
	HRLI U,(POINT 1,0,35)	;DEPOSITING 1 BIT AT A TIME
	MOVSI W,-777	;W/AOBJN FOR VP 0 THRU 777
RFBT0A:
	SOJL P1,CPOPJ1	;RAN OUT OF BITMAP SPACE YET?
	XCTBU <ILDB T1,U> ;TOUCH USER PAGE. MAY FAULT & SET REFBIT
	MOVSI T2,LMPREF
	TDNN T2,%UPLMA(W)
	TDZA T1,T1	;SLOT REFBIT=0, T1:=0
	MOVEI T1,1	;SLOT BIT=1
	XCTBU <DPB T1,U> ; GIVE TO USER, SHOULDNT FAULT
	AOBJN W,RFBT0A	;CONTINUE UNTIL PG 777 DONE
	JRST CPOPJ1

COMMENT ! ROUTINE RFBT1 - FUNC 1 SET REFBITS FROM BITMAP
RUNCTION: READ A BITMAP LIKE DESCRIBED ABOVE & SET REFBITS
	FOR PAGES 0 TO 777. IF BITMAP RUNS OUT SOONER,
	CLEAR REFBITS FOR PAGES FROM THERE TO 777.
EXPECTS: M/LOC, LOC THRU LOC+COUNT AS ABOVE
DESTROYS: T1,T2,U,W,P1,P3,P4
!

RFBT1:
	UMOVE P1,(M)	;COUNT
	IMULI P1,^D36
	MOVEI U,1	;TRAVELLING BIT, CYCLES AROUND U
	MOVSI W,-777	;W/ AOBJN FOR VP 0 TO 777
RFBT1A:
	TRNE U,1	;TIME TO ADVANCE (M)? DO BEFORE ROT BIT TO SIGN POSN
	HRRI M,1(M)
	ROT U,-1	;CYCLE BIT AROUND
	SOJL P1,RFBT1B	;BITMAP RAN OUT, FORCE REFBIT_0
	XCTBU <TDNN U,(M)>	;SKIP IF USER BITMAP=1 THIS PAGE
				;MAY FAULT & SET REFBIT.
RFBT1B:	TDZA T2,T2	;USER BIT WAS 0,T2_0 AND SKIP
	MOVEI T2,1
	PUSHJ P,REFBC	;TAKE T2,CLOB T1,P3,P4
	AOBJN W,RFBT1A
	JRST CPOPJ1
SUBTTL VPROT UUO

EXTERNAL FD2FNO,FD2WLK,FD2WL1,SRDUPX,SWRUPX,UPTOFD
COMMENT ! ENTRY UPROT -- COME HERE FROM UUOCON DISPATCH
EXPECTS: T1/<OTFFLG>B1+<PROT>B7+<COUNT>B17+<START VP>
	M/ USER AC#	J/JOB
FUNCTION: CALL KERNEL VIA DOUUO INTERFACE WHICH
	SAVES M IN PDL AND SETS <USER> PROPERLY
	IN 1B0 OF T1.
	WILL NOT TRY TO GET UPX IF OWN CONTEXT PAGES, SO UPX ROUTINES
	CAN DO VPROT UUOS.
!

UPROT::
	JSP T4,DOUUO	;CALL KERNEL, FOLLOWS DIRECTLY
	MOVE	P2,T1	;GET OTF FLAG IN SAFE PLACE.
	TLNN	P2,OTFFLG	;WANTS "OTHER" PAGES?
	JRST	UPROT1		;NO, GO LOCK UPT.
	MOVE	P4,%UPT+UPTOFD	;GET FRAME DESCRIPTOR IN P4
	PUSHJ	P,FD2FNO	;GET OTHER FRAME'S IDENTITY
	  JRST	[MOVS T1,P2	;VP,,?
		 HRRI T1,PTOFF%
		 DPB P3,FDEERP<T1> ;PUT SUB ERROR CODE IN
		 POPJ P,]
	CAMN	J,%UPT+UPTJOB	;IF OTHER IS SAME AS US,
	JRST	UPROT2		;GO TURN OFF OTFFLG IN P2 AND USE UPT
	MOVEI	P3,.ARCHM	;NEED CHANGE MAP ACCESS TO DO VPROT
	PUSHJ	P,FD2WL1	;DO ACCESS CHECKING, SETUP J, LOCK %UPX
	  JRST	[MOVS T1,P2
		 HRRI T1,PTOFF%
		 DPB P3,FDEERP<T1> ;PUT SUB ERROR CODE IN.
		 POPJ P,] ;ERROR RETURN.
	JRST	UPROT3
UPROT2:	TLZ	P2,OTFFLG	;USING UPT INSTEAD.
UPROT1:	PUSHJ	P,WLKUPT	;GET UPT WRITE LOCKED
	  STOPCD		;ALWAYS CAN GET OUR OWN.
UPROT3:	MOVE	T1,P2		;GET ARG BACK INTO T1
	PUSHJ	P,KVPROT	;CALL THE KERNEL
	  SKIPA			;ERROR RETURN
	AOS	(P)		;INDICATE SUCCESS TO CALLER
	PUSH	P,T1		;SAVE POSSIBLE ERROR CODE
	TLNN	P2,OTFFLG	;IF HAVE UPX LOCK,
	JRST	[PUSHJ P,UNWUPT
		 JRST TPOPJ]	;DON'T, RELEASE UPT LOCK
	PUSHJ	P,ULDUPX	;THEN RELEASE WRITE LOCK AND LOCKDOWN.
	POP	P,T1		;IN CASE WE'RE GIVING ERROR RETURN
	POPJ	P,		;BYE.

COMMENT ! ROUTINE VPROT - KERNEL
FUNCTION: SET <PROT> ON <COUNT> PAGES BEGINNING
	AT <START VP>. ON ERROR RETURN, VP#,,ERROR CODE RETURNED
	IN AC.

EXPECTS: T1/<USER>B0+<OTFFLG>B1+<PROT>B7+<COUNT>B17+VP#
	%UPT OR %UPX HAS PROPER CONTEXT PAGES WRITE LOCKED,
	OTFFLG SET IF IN %UPX, ELSE IN %UPT.
DESTROYS: W,F,T1-T4,P1,P3-P4
RESTRICTIONS: MONITOR CALLERS WISHING TO PUSHJ TO VPROT
	SHOULD SET <USER>B0 IN T1 IF USER RESTRICTIONS
	DESIRED ON VP RANGE. THIS ROUTINE
	DOES NOT WRITE ON USER SPACE.
!


;BITS

	XP PT.PRT,(1B7)		;LAST BIT OF PROTECTION FIELD.
	XP PT.CNT,(1B17)	;LAST BIT OF COUNT FIELD.

;ERROR CODES

	ERRCOD(0,PTBCN%,PTEBCN)	;BAD COUNT
	ERRCOD(1,PTBVP%,PTEBVP)	;BAD VP NUMBER
	ERRCOD(2,PTBPR%,PTEBPR)	;BAD PROTECTION CODE
	ERRCOD(3,ZZ,ZZ)		;(VP ALREADY EXISTS)
	ERRCOD(4,PTNVP%,PTENVP)	;VP DOES NOT EXIST, HAS TO.
	ERRCOD(5,PTPRF%,PTEPRF)	;PROTECTION FAILURE
	ERRCOD(6,ZZ,ZZ)		;UNUSED.
	ERRCOD(7,PTOFF%,PTEOFF)	;"OTHER FRAME" FAILURE, SUBCODE IN 0-5.


KVPROT::TLNE T1,FL.USR	;KEEP <USER> IN SIGN BIT OF F,
	TLOA F,FL.USR	;SEE VPCHK ROUTINE
	TLZ F,FL.USR
	TLNN T1,OTFFLG	;NEEDS OTHER CONTEXT?
	TLZA F,OTFFLG	;YES, PUT THE BIT IN F
	TLO F,OTFFLG
	HRRZ W,T1	;W/VP#
	LDB P1,UUYCPR	;GET PROTECTION WANTED IN P1
	SKIPE P1
	CAILE P1,MAXCPR
	JRST PTEBPR	;BAD PROT
	LDB T1,UUYCTG	;GET COUNT IN T1.
	JUMPE T1,PTEBCN	;COUNT 0 ILLEGAL
	MOVNS T1
	HRL W,T1	;W/-COUNT,,VP#

VPROT1:	;AOBJN LOOP ON W.  P1/PROT; P3,P4/LMAP SLOT DATA;
	;IF PAGE NON-EXISTENT,ERROR;
	; IF REQUESTED PROT SAME
	;AS OLD PROT, NEXT PAGE. IF MAX-WRITE OFF BUT WANTS
	;RDW PROT, ERROR 4; SET PROT. CLEAR PGE.W &SET A.M. FLAG
	;IF VP ACTIVE. RETURN DATA TO LMAP SLOT;
	;(CLEARING PGE.W BECAUSE MAY BE SETTING NON-RDW
	;PROT ON PREVIOUSLY-RDW PAGE, OR MAY BE SETTING RDW
	;ON PAGE WHICH IS STILL CLEAN.)

	JSP T4,VPCHK
	PJRST PTEBVP		;GIVE BVP ERR CODE AND RETURN ERROR.
	TLNE F,OTFFLG
	JRST	[PUSHJ P,GETLMX
		 JRST .+2]
	PUSHJ P,GETLMA
	TLNN P3,LMMEXS
	PJRST PTENVP		;BAD VIRTUAL PAGE ERROR.
	LDB T1,LM3CUR
	CAME T1,P1
	JRST VPROT5	;CHANGING THE PROT
	SOSGE %UPT+UPTLDC	;NOT CHANGING, THROW AWAY SLOT DATA
	STOPCD
	JRST VPROT3	;DO NEXT PAGE

VPROT5:	TLNN P3,LMPMXW
	CAIE P1,CPRRDW
	JRST .+2
	JRST VPROT4
	DPB P1,LM3CUR	;DEPOSIT PROT IN P3
	TLNE P3,LMPACT	;IF ACTIVE,
	TRZ P4,PGE.W	;RESET PGE.W AND
	TLNE F,OTFFLG
	JRST	[PUSHJ P,STOLMX
		 JRST .+2]
	PUSHJ P,STOLMA
VPROT3:	AOBJN W,VPROT1
	JRST CPOPJ1

VPROT4:	SOSGE %UPT+UPTLDC	;THROW AWAY LMAP DATA
	STOPCD
	PJRST PTEPRF		;SETUP PROT FAILURE ERR CODE
SUBTTL TRAP INFORMATION UUOS

;UUOS TO READ AND CLEAR PAGE FAIL STATUS, PAGE ERROR STATUS.
; CALL FOR THIS CLASS OF UUOS:
;
;	MOVE	AC,[-COUNT,,ADDR]
;	PGFSTS	AC,		;OR PGRSTS, PERSTS, PILSTS
;	  <ERROR RETURN>
;	<SUCCESS RETURN>
;
;CURRENTLY, TWO LOCATIONS CAN BE RETURNED.
	XP .PFUWD,0		;USER INFORMATION WORD
	XP .PFXWD,1		;EXEC INFORMATION WORD

;THE USER WORD IS ALWAYS USED JUST PRIOR TO GIVING THE USER
; A TRAP WE KNOW HE CAN TAKE IMMEDIATELY WHEN THE
; RELEVANT CONDITION OCCURS. THE EXEC WORD IS ALWAYS USED
; IF THE RELEVANT CONDITION OCCURS BUT THE USER CANNOT
; BE GIVEN A TRAP FOR SOME REASON (INCLUDING NOT
; ENABLED). THE EXEC INFORMATION WORD IS ALWAYS THE MOST
; RECENT INFORMATION STORED.

;FORMAT OF THE TWO WORDS IS IDENTICAL. RH CONTAINS PAGE NUMBER.
; LH CONTAINS BITS.

;BITS FOR PGFSTS:

	XP FI.VAL,(1B0)	;FOR QUICK CHECKING, MEANS VALID INFO (MAKES IT NON-ZERO)
	XP FI.SAL,(1B1)	;SIZE AT LEAST LIMIT

;BITS IN LH FOR PERSTS:

	XP EI.VAL,(1B0)	;MEANS IT MEANS SOMETHING.
	XP EI.PAR,(1B14)	;PARITY ERROR ON DIRTY PAGE.
	XP EI.OER,(1B15) ;OUTPUT ERROR HAS OCCURED.
	XP EI.DER,(1B16) ;DEVICE ERROR
	XP EI.DTE,(1B17) ;DATA ERROR

;FORMAT OF PGISTS WORDS IS ADDRESS IN LEFT HALF, SOFT PAGE FAIL
; WORD BITS IN RH (SEE S.MAC, SPFW.? DEFINITIONS).

;FORMAT OF PGRSTS: RH CONTAINS ADDRESS (NOT PAGE NUMBER) AND
; LH CONTAINS FOLLOWING BITS:

	XP	RI.VAL,(1B0)	;JUST VALID BIT, NO OTHERS NEEDED

;ERROR CODES FOR THIS CLASS OF UUOS

ERRCOD(0,FIBCN%,PGSBCN)	;BAD COUNT.


UPISTS::MOVEI	P1,%UPT+UPTUII
	JRST	UPPSTS
UPRSTS::MOVEI	P1,%UPT+UPTURI
	JRST	UPPSTS
UPESTS::SKIPA	P1,[%UPT+UPTUEI]	;ADDRESS OF TWO WORD VECTOR.
UPFSTS::MOVEI	P1,%UPT+UPTUFI		;DITTO.
UPPSTS:	SETZ	W,		;SO ERROR CODE WORKS RIGHT
	JUMPGE	T1,UPFSTE	;BAD COUNT IF POSITIVE.
	SETZ	T2,		;READ AND CLEAR
	EXCH	T2,.PFUWD(P1)	;GET USER INFO WORD
	UMOVEM	T2,(T1)		;GIVE IT TO USER.
	AOBJP	T1,CPOPJ1	;JUMP IF DONE, ELSE NEXT LOC.
	SETZ	T2,
	EXCH	T2,.PFXWD(P1)	;GET AND CLEAR EXEC INFO WORD
	UMOVEM	T2,(T1)		;GIVE TO USER.
	AOBJP	T1,CPOPJ1	;JUMP IF COUNT NOT TOO BIG.

UPFSTE:	MOVEI	T1,FIBCN%	;GIVE THIS ERROR CODE
	UMOVEM	T1,(M)		;BACK INTO USER AC
	POPJ	P,		;AND GIVE HIM ERROR RETURN.
;UUO TO SET/CLEAR THE IGNORE ERROR BITS ON VIRTUAL PAGES.
;
;CALL:
;
;	MOVE	AC,[PE.NER+<COUNT>B17,,START PAGE]
;	PERSET	AC,
;	  <ERROR RETURN>
;	<SUCCESS RETURN>
;BITS:
;
	XP PE.NER,(1B7)		;SAYS SET THE IGNORE ERROR BIT. IF OFF, CLEAR THE IGNORE BITS.

; ERROR CODES:

ERRCOD(0,PEBCN%,PERBCN)		;BAD COUNT
ERRCOD(1,PEBVP%,PERBVP)		;BAD VP ARG
ERRCOD(2,ZZ,ZZ)			;UNUSED
ERRCOD(3,ZZ,ZZ)			;UNUSED
ERRCOD(4,PENVP%,PERNVP)		;VP DOESN'T EXIST AND SHOULD

UPESET::JSP	T4,DOUUO	;SETUP THINGS
	TLNE	T1,FL.USR	;USER FLAG ON?
	TLOA	F,FL.USR	;YES
	TLZ	F,FL.USR	;NO
	LDB	T2,[POINT 10,T1,17] ;GET COUNT
	HRLOI	W,-1(T2)	;GET COUNT-1,,-1 IN W
	EQVI	W,(T1)		;GET PAGE NUMBER IN RH, -COUNT IN LH
	JUMPE	T2,PERBCN	;BAD COUNT, GIVE ERROR RETURN IF 0
	MOVE	P1,[PUSHJ P,PERSE2]	;ASSUME CLEAR
	TLNE	T1,PE.NER	;WANTS THEM SET?
	MOVE	P1,[IORM P3,%UPLMA(W)] ;YES, THIS WILL DO IT.
	MOVSI	P3,LMPNER	;THE BIT TO DO.
	MOVSI	P2,LMMEXS	;FOR QUICK CHECKING.

PERSE1:	JSP	T4,VPCHK	;THIS PAGE OK?
	  JRST	PERBVP		;NO, GIVE ERROR
	TDNN	P2,%UPLMA(W)	;EXISTS?
	JRST	PERNVP		;NO, TELL HIM ABOUT IT.
	XCT	P1		;OK, SET OR CLEAR THE BIT
	AOBJN	W,PERSE1	;AND DO NEXT VP
	JRST	CPOPJ1		;DONE, GIVE GOOD RETURN.

;HERE TO CLEAR IGNORE ERROR BIT. CLEAR "A" BIT SO NEXT REF WILL
; FAULT, DISCOVERING THE ERROR, IF ANY.

PERSE2:	PUSHJ	P,GETLMA	;ALREADY KNOW IT EXISTS
	TLZ	P3,LMPNER	;CLEAR THE BIT
	TLNE	P3,LMMERR	;ANY ERRORS ON SLOT?
	TRZ	P4,PGE.A!PGE.P	;YES, GIVE TRAP OR ERROR MSG NEXT TIME.
	PUSHJ	P,STOLMA	;PUT NEW DATA BACK
	MOVSI	P3,LMPNER	;RESTORE THIS
	POPJ	P,		;RETURN.
SUBTTL UUO TO RETURN VP'S DISK POINTER

;UUO USED BY DSKCLN TO FIND OUT WHOSE FILE PAGES HAVE BEEN
; WIPED OUT BY ALLOCATING CORE TO RUN DSKCLN'S CORE IMAGE,
; USED BY SIMIO TO ALLOW UPDATING OF I/O STATISTICS.
;
;REQUIRES RA OR EXEC MODE CALLER.
;
;CALL:
;
;	MOVEI	AC,VP#
;	VDSKPT	AC,
;	  <ERROR RETURN>
;	<NORMAL RETURN>		;RETRIEVAL POINTER RETURNED IN AC.
;
;FORMAT OF RETRIEVAL POINTER SAME AS THAT FOUND IN RIBS AND THROUGHOUT
; THE SYSTEM.
;
;ERRORS:

ERRCOD(0,ZZ,ZZ)		;UNUSED
ERRCOD(1,VDBVP%,VDEBVP)		;BAD VP NUMBER
ERRCOD(2,ZZ,ZZ)			;UNUSED
ERRCOD(3,ZZ,ZZ)			;UNUSED
ERRCOD(4,VDNVP%,VDENVP)		;VP DOES NOT EXIST, SHOULD
ERRCOD(5,VDNEL%,VDENEL)		;NOT ENOUGH LICENSE

UVDSKP::JSP	T4,DOUUO	;SETUP T1, STACK
KVDSKP:	JUMPGE	T1,[TLZ F,FL.USR ;IF EXEC MODE CALLED, CLEAR FLAG
		    JRST KVDSK1];AND HE'S OK
	TLO	F,FL.USR	;NOT EXEC CALLER, HAS TO HAVE RA
	LDB	T2,JBYRPT	;GET PROCESS READ LICENSE
	CAIE	T2,3		;IF HAS RA, OK
	JRST	VDENEL		;USER MODE AND NO LICENSE, BOMB OUT

KVDSK1:	HRRZ	W,T1		;OK, GET VP IN W
	JSP	T4,VPCHK	;IN RANGE?
	  JRST	VDEBVP		;NO, THIS CALLER CAN'T SAY THAT PAGE.
	PUSHJ	P,GETLMA	;GET LMAP DATA IN P3 AND P4
	TLNN	P3,LMMEXS	;MUST EXIST
	JRST	VDENVP		;DOES NOT
	PUSHJ	P,GETDPA	;OK, GET DISK POINTER IN T2
	SOSGE	%UPT+UPTLDC	;THROW AWAY LMAP DATA NOW
	STOPCD			;UNDERFLOW
	UMOVEM	T2,(M)		;RETURN IT TO USER
	JRST	CPOPJ1		;OK, RETURN
SUBTTL BLTPAG UUO

;THE PURPOSE OF THE BLTPAG UUO IS TO ALLOW A SET OF MODIFICATIONS
; TO A PAGE TO OCCUR SIMULTANEOUSLY (I.E. NO RESCHEDULE HAPPENS)
; AND IN SUCH A WAY THAT IF THE SYSTEM CRASHES, THE PAGE EITHER
; CONTAINS ALL THE CHANGES OR NONE OF THE CHANGES.

;CALL IS:
;	MOVEI	AC,[1ST SOURCE WORD,,1ST DESTINATION WORD
;		    LAST DESTINATION WORD]
;	BLTPAG	AC,
;	  <ERROR>
;	<SUCCESS>

;ALL SOURCE DATA MUST COME FROM ONE VIRTUAL PAGE, AND ALL DESTINATION
; LOCATIONS MUST BE IN THE SAME PAGE, OR AN ERROR RETURN IS GIVEN.

;ERROR CODES:

	ERRCOD(0,BUCBB%,BUECBB)	;CAN'T BLT BACKWARDS (LAST DEST LESS THAN OR EQUAL TO FIRST DEST ADDR)
	ERRCOD(1,BUNWP%,BUENWP)	;SOURCE OR DESTINATION DATA NOT WITHIN ONE PAGE.
	ERRCOD(2,BUCLP%,BUECLP)	;CAN'T LOCK DESTINATION PAGE (TOO MANY LOCKERS)

EXTERNAL PGPDIO,DIOMAX

BLTPAG::PUSHJ	P,BLTPG0	;DO THE REAL WORK
	SKIPA
	JRST	CPOPJ1		;SUCCESS.
	XCTTU	<HRRZM T1,(M)>	;STORE ERROR CODE
	POPJ	P,		;AND GIVE ERROR RETURN.

;NOTE CODE BELOW MUST SAVE M FOR STORING ERROR CODE.

BLTPG0:	UMOVE	P1,(T1)		;1ST SOURCE,,1ST DESTINATION
	UMOVE	P2,1(T1)	;LAST DESTINATION ADDRESS
	CAIG	P2,(P1)		;MAKE SURE LAST DESTINATION ADDRESS IS GREATER
				; THAN FIRST DESTINATION ADDRESS
	JRST	BUECBB		;CAN'T BLT BACKWARDS.
	HRRZ	T1,P2		;LAST DESTINATION ADDR
	XOR	T1,P1		;SEE IF PAGE NUMBERS OF DESTINATION 1ST AND LAST MATCH
	TRNE	T1,777000	;SKIP IF SAME PAGE
	JRST	BUENWP		;NOT IN SAME PAGE.
	MOVE	P3,P2		;COMPUTE TRANSFER COUNT
	SUBI	P3,(P1)		;GET COUNT-1
	HLRZ	T1,P1		;GET FIRST SOURCE ADDR
	ADD	T1,P3		;COMPUTE END SOURCE ADDR
	TSC	T1,P1		;DO XOR OF RH(T1) AND LH(P1) IN RH(T1)
	TRNE	T1,777000	;SKIP IF SAME PAGE NUMBER.
	JRST	BUENWP		;SOURCE NOT WITHIN ONE PAGE

;NOW LOCK DESTINATION PAGE IN CORE, AND LOOP TILL GET SOURCE
; PAGE IN CORE WITH DESTINATION PAGE NO I/O IN PROGRESS.
; THEN COPY AND RETURN.

BLTUU1:	HRRZ	W,P2		;GET VIRTUAL PAGE NUMBER
	LSH	W,-^D9		;
	XCTFU	<MOVES (P2)>	;DRAG IT INTO CORE, WRITE ON IT SO
				; IT GETS CONVERTED IF ITS COW
	PUSHJ	P,REDLMA	;READ LMAP SLOT.
	PUSHJ	P,GETCPA	;GET CP NUMBER IN PG
	LDB	T1,PGYDIO	;GET DIO COUNT
	CAIL	T1,DIOMAX	;MAKE SURE ITS NOT TOO HIGH
	JRST	BUECLP		;CAN'T LOCK PAGE
	MOVSI	T1,PGPDIO	;INCREMENT DIO COUNT, LOCKS IT IN CORE
	ADDM	T1,@PGYDIO
	MOVEI	T1,BLTULP	;IN CASE WE GET I/O ERROR OR SOMETHING,
	MOVEM	T1,JBTABT(J)	;SETUP JBTABT TO DECREMENT DIO FOR C(PG)

BLTUU2:	HLRZ	T2,P1		;GET SOURCE ADDRESS
	XCTFU	<MOVE T1,(T2)>	;MAKE SURE ITS IN CORE SO NO RESCHEDULE
				; (OTHERWISE SOMEONE COULD START DEST OUT)
	LDB	T1,PGYSOP	;DEST PAGE GOING OUT NOW?
	JUMPE	T1,BLTUU3	;NO, CAN COPY NOW.
	PUSHJ	P,PAGWAT	;YES, MUST WAIT FOR CURRENT I/O TO CEASE
	JRST	BLTUU2		;AND TRY AGAIN.

BLTUU3:	XCTBU	<BLT P1,(P2)>	;DO THE LONG AWAITED BLT
	AOSA	(P)		;GIVE GOOD RETURN AND FALL INTO BLTULP+1

;HERE FROM JBTABT OR SUCCESSFUL END OF BLTPAG UUO TO UNLOCK DESTINATION

BLTULP:	UMOVE	PG,PG		;GET BACK CP TO UNLOCK
	WRPI	LI.PIF	;MAKE SURE NO ONE CHANGES
	LDB	T1,PGYDIO	;GET COUNT
	SOSGE	T1
	STOPCD			;ITS BAD
	DPB	T1,PGYDIO	;OK, STORE IT BACK
	WRPI	LI.PIN
	SETZM	JBTABT(J)	;OK TO CLEAR THIS NOW.
	SKIPN	T1		;WAKE JOBS WAITING ON
	PUSHJ	P,PAGWAK	; DIO UP
	POPJ	P,
SUBTTL %UPX HANDLERS
COMMENT ;@@SUBROUTINE OTFSET
@@PURPOSE ROUTINE FOR SETOTF UUO.
@@ENTRY T1 CONTAINS USER'S AC (FRAME DESCRIPTOR)
@@ACCUM ALL ACS USED (UUO ROUTINE)
@@EXIT LEAVES THE DESCRIPTOR IN %UPT+UPTOFD
@@;

OTFSET::MOVE	T2,T1		;GET COPY
	ANDI	T2,700000	;JUST DESCRIPTOR TYPE
	CAIN	T2,.FDOTF	;DO NOT ALLOW ENDLESS LOOPS
	POPJ	P,		;BAD.
	EXCH	T1,%UPT+UPTOFD	;SET NEW ONE, GET OLD VALUE
	UMOVEM	T1,(M)		;PUT OLD VALUE BACK IN USER AC
	JRST	CPOPJ1		;AND GIVE SUCCESS RETURN.
COMMENT ;@@SUBROUTINE WLKUPX/WLKUPT
@@PURPOSE GET FRAME'S CONTEXT PAGES INTO %UPX/%UPT WRITE LOCKED
@@ENTRY ENTER AT WLKUPX TO WRITE LOCK AND MAP C(J) CONTEXT PAGES IN %UPX.
	ENTER AT WLKUPT TO WRITE LOCK CURRENT JOBS CONTEXT PAGES.
@@ACCUM T1-T4,PG
@@EXIT NON-SKIP RETURN IF CANNOT GET PAGES INTO %UPX
	SKIP RETURN IF PAGES IN %UPX/%UPT AND INTERLOCKED.
@@RESTRICTIONS ENTRY AT WLKUPX ASSUMES PAGES ARE NOT LOCKED DOWN YET.
IF THEY ARE, LKDUPX WILL GO THRU EXTRA WORK FOR NOTHING, BUT ALL
ELSE WILL WORK OK.
@@RESTRICTIONS RESCHEDULES FOR CONTEXT PAGE WRITE INTERLOCK.
NOTE: MUST NOT RESCHEDULE OUT OF THIS ROUTINE, ELSE INTERLOCK WON'T
WORK. HENCE, DEPENDS ON PAGE FAULT NOT RESCHEDULING WHEN FAULT FOR WRITE INTO UPX.
@@FUNCTION IF ENTER AT WLKUPX, GET CONTEXT PAGES LOCKED DOWN FOR C(J). WRITE ENABLE %UPX
IN ANTICIPATION OF STORING CURRENT FRAME NUMBER INTO %UPX+UPTLKJ
OR UPDATING %UPX+UPTLKW.
FOR WLKUPX AND WLKUPT: IF NO ONE OWNS THE LOCK, JUST STORE
THE CURRENT FRAME'S NUMBER INTO %UPX/%UPT+UPTLKJ. IF SOMEONE OWNS
THE LOCK, ADD CURRENT FRAME TO END OF CONTEXT PAGE WAIT QUEUE
FOR THESE CONTEXT PAGES AND GO INTO CW WAIT. ON WAKEUP, 
HAVE THE LOCK, SO STORE CURRENT FRAME NUMBER INTO %UPX/%UPT+UPTLKJ AND
RETURN.
@@;

EXTERN %UPX,UPTJOB,UPTLKW,UPTLKJ,JBTPGO,WSCHED,CWQ,JBTSTS

WLKUPX::MOVE	T1,%UPT+UPTJOB	;GET CALLER'S FRAME NUMBER
	CAMN	T1,%UPX+UPTLKJ	;IF CALLER ALREADY HAS THE LOCK,
	CAMN	J,%UPX+UPTJOB	;HE IS NOT ALLOWED TO ASK FOR DIFFERENT CONTEXT PAGES
	JRST	WLKUX0		;OK, JUST RE-LOCKING (NESTED CALLS)
	CAME	T1,%UPX+UPTJOB	;EXCEPTION IS IF CALLER HAS UPT LOCKED AND
				;IS TRYING TO LOCK SOMETHING ELSE IN UPX.
				; (CASE WHERE HE HAS OWN UPT LOCKED IN UPX AND TRIES TO LOCK SOMEONE
				; ELSE IN UPX IS NOT CAUGHT.)
	STOPCD			;ALREADY HAD SOMEONE ELSE WRITE LOCKED IN UPX OTHER THAN SELF.
WLKUX0:	PUSHJ	P,LKDUPX	;LOCKDOWN C(J)'S CONTEXT PAGES FIRST
	  POPJ	P,		;CAN'T EVEN GET THEM LOCKED DOWN
	PUSHJ	P,WENUPX	;WRITE ENABLE %UPX AND GROUP
	MOVEI	T4,%UPX		;GO LOCK THE CONTEXT PAGES IN %UPX
	PJRST	WLKUPN

WLKUPT::MOVEI	T4,%UPT		;HERE TO WRITE LOCK THE CONTEXT PAGES IN %UPT (SELF)
WLKUPN:	MOVE	T2,%UPT+UPTJOB	;GET CURRENT FRAME NUMBER IN T2
	SKIPN	T3,UPTLKJ(T4)	;SKIP IF CANNOT HAVE LOCK YET
	JRST	WLKUP2		;CAN HAVE IT.
	CAMN	T2,T3		;HAVE IT FROM PREVIOUS LEVEL?
	JRST	WLKUP2		;YES, GO INCREMENT COUNT.
	MOVS	T1,UPTLKW(T4)	;FIRST,,OLD LAST
	JUMPE	T1,WLKUP1	;JUMP IF NO ONE ON THE LIST.
				; (USUAL CASE, WE HOPE)
				;(CURRENT FRAME NUMBER STILL IN T2)
	HRRM	T2,JBTPGO(T1)	;OLD LAST POINTS TO NEW LAST
	HLLZS	JBTPGO(T2)	;NEW LAST INDICATES END WITH 0.
	HRR	T1,T2		;NEW LAST,,FIRST
	MOVSM	T1,UPTLKW(T4)	;STORE NEW LAST,,FIRST HERE.
	JRST	WLKUWT		;GO WAIT FOR LOCKER BEFORE US TO WAKE US UP.

WLKUP1:	HRL	T2,T2		;US,,US
	MOVEM	T2,UPTLKW(T4)
	HLLZS	JBTPGO(T2)	;NO ONE IS AFTER US YET.

;HERE WITH C(T2) EQUAL TO CURRENT FRAME NUMBER.

WLKUWT:	MOVEI	T1,CWQ		;CONTEXT PAGE WAIT QUEUE
	DPB	T1,[POINT JWSIZ,JBTSTS(T2),JWPOS]
	AOS	(P)		;WE WILL GET IT
	PJRST	WSCHED		;RETURN WITH THE LOCK. UNWUP? WILL SET UPTLKJ AND UPTLKW.

;HERE WITH THE CONTEXT PAGE WRITE LOCK.

WLKUP2:	AOS	UPTLKC(T4)	;INCREMENT # TIMES WE LOCKED
	HRRZM	T2,UPTLKJ(T4)	;REMEMBER THAT WE ARE OWNER OF WRITE LOCK.
	JRST	CPOPJ1		;OK TO WRITE IN THEM NOW.
COMMENT ;@@SUBROUTINE UNWUPX/UNWUPT
@@PURPOSE RELEASE WRITE LOCK FOR CONTEXT PAGES (IN UPT OR UPX).
@@ENTRY ENTER AT UNWUPX TO RELEASE LOCK ON %UPX CONTEXT PAGES.
	ENTER AT UNWUPT TO RELEASE LOCK FOR %UPT CONTEXT PAGES.
CURRENT FRAME MUST HAVE CONTEXT PAGES WRITE LOCKED.
	ENTER AT UNIUPT TO RELEASE LOCK FOR %UPT CONTEXT PAGES AND
	  JUST RETURN IF LOCK NOT HELD BY CURRENT FRAME.
@@ACCUM T1-T4
@@EXIT UNWUPX: CURRENT FRAME HAS %UPX LOCKED DOWN
	UNWUPT, UNIUPT: WRITE LOCK ON CURRENT CONTEXT PAGES RELEASED.
@@FUNCTION CRASH IF CALLING FRAME DOESN'T OWN THE WRITE LOCK FOR
CONTEXT PAGES (IF NOT UNIUPT).  IF NO WAITERS FOR LOCK, JUST CLEAR UPTLKJ
AND RETURN. IF WAITERS, WAKE NEXT ONE UP.
IF NEXT FRAME TO GET LOCK GETS CONTEXT PAGE SWAP ERROR ON THE WAY IN,
THE SWAP ERROR RECOVERY CODE WILL WAKE NEXT
@@;

EXTERNAL REQUE,PJBSTS,RNQ

UNIUPT::MOVE	T1,%UPT+UPTJOB
	CAME	T1,%UPT+UPTLKJ	;DOES CALLER HAVE LOCK?
	POPJ	P,		;NO, JUST RETURN
UNWUPT::SKIPA	T3,[%UPT]
UNWUPX::MOVEI	T3,%UPX		;INDEX BY T3
	SETZ	T1,		;MAKE SURE WE HAD IT, CLEAR IT
	EXCH	T1,UPTLKJ(T3)
	CAME	T1,%UPT+UPTJOB
	STOPCD

	SOSE	UPTLKC(T3)	;ONE LESS LEVEL NEEDS LOCK
	JRST	[MOVEM T1,UPTLKJ(T3) ;HIGHER LEVEL NEEDS IT, PUT LOCK FRAME NUMBER BACK
		 POPJ P,]	;AND RETURN DOING NOTHING BUT SOS COUNT.
				; HERE IF ALL LEVELS HAVE RELEASED IT

;HERE TO WAKE UP POSSIBLE NEXT JOB IN CONTEXT PAGE WAIT QUEUE

	MOVE	T4,J		;SAVE J IN T4
	MOVE	J,UPTLKW(T3)
	JUMPE	J,RELUW2	;NO ONE TO WAKE UP, JUST WRITE PROTECT %UPX AND RETURN.
	TSC	J,J
	JUMPE	J,RELUW1	;GO IF ONE JOB ON QUEUE
	MOVE	J,UPTLKW(T3)	;GET CONTENTS BACK AGAIN
	HRR	J,JBTPGO(J)	;GET NEXT WAITER
RELUW1:	EXCH	J,UPTLKW(T3)	;NO MORE WAITERS
	HRRZM	J,UPTLKJ(T3)	;SAY THAT HE HAS IT NOW.
	AOS	UPTLKC(T3)	;INCREMENT LOCK COUNT FOR HIM.
	
	MOVEI	T1,RNQ
	DPB	T1,PJBSTS	;PUT INTO SATISFIED STATE
	PUSHJ	P,REQUE
RELUW2:	MOVE	J,T4		;RESTORE J
	CAIN	T3,%UPT		;IF RELEASING %UPT LOCK,
	POPJ	P,		;JUST RETURN, UPT ALWAYS WRITE ENABLED.
;	JRST	WPRUPX		;%UPX, FALL INTO WPRUPX TO WRITE PROTECT %UPX.
COMMENT ;@@SUBROUTINE WPRUPX/WENUPX
@@PURPOSE WRITE PROTECT/WRITE ENABLE %UPX GROUP
@@ENTRY
@@ACCUM DESTROYS T1-T4
@@EXIT ALWAYS NON-SKIP RETURN
@@FUNCTION IF PAGES MAPPED IN %UPX ARE ANOTHER FRAME'S PAGES,
JUST DO VPROT TO WRITE ENABLE/DISABLE THEM. ELSE, THEY ARE CURRENT
FRAMES, SO SET/CLEAR PGE.W BIT APPROPRIATELY AND CLEAR THE PAGE
TABLE FOR THOSE VIRTUAL PAGES WHOSE MAP SLOTS WE CHANGED.
@@;

OPDEF VPROT [CALLI -70]


EXTERNAL NCTXPG,CPRRDW,CPRRED,%UPX.N

WPRUPX:	TDZA	T4,T4		;INDICATE WRITE PROTECT
WENUPX:	MOVEI	T4,1		;INDICATE WRITE ENABLE

	MOVE	T1,%UPX+UPTJOB	;SEE IF %UPX CONTEXT PAGES SAME AS
	CAMN	T1,%UPT+UPTJOB	;%UPT
	POPJ	P,		;YES, DON'T NEED TO WRITE ENABLE OR PROTECT THEM, ALWAYS WRITE ENABLED TO SAVE CLRPT EXECUTIONS,
				; WHICH ARE SLOW ON THE 2020.

;HERE IF CURRENT JOB'S CONTEXT PAGES NOT IN %UPX.

	MOVE	T1,[<CPRRED>B7+<NCTXPG>B17+%UPX.N+CNVVPN
		    <CPRRDW>B7+<NCTXPG>B17+%UPX.N+CNVVPN](T4)
				;GET APPROPRIATE ARG
	VPROT	T1,
	  STOPCD
	POPJ	P,		;RETURN.

;HERE IF %UPX SAME PAGES AS %UPT. CAN'T DO VPROT, PAGES DON'T REALLY EXIST.

WPRUX1:	MOVE	T3,UPYPXM	; [UPTPTR(%UPX.N-1)]
	SETZ	T2,
WPRUX2:	ILDB	T1,T3		;GET NEXT SLOT
	XCT	[TRZ T1,PGE.W
		 TRO T1,PGE.W](T4) ;EITHER SET OR CLEAR W BIT.
	DPB	T1,T3		;PUT SLOT BACK
	CLRPTO	%UPX(T2)	;AND SAY MAP HAS CHANGED.
	ADDI	T2,1000		;NEXT ADDRESS
	CAIGE	T2,<NCTXPG*1000> ;NO MORE TO DO?
	JRST	WPRUX2		;YET ANOTHER
	POPJ	P,		;DONE.
COMMENT ;@@SUBROUTINE ABTCPL
@@PURPOSE CALLED FROM CHKABT AFTER JBTABT ROUTINE CALL
TO GIVE UP ANY CONTEXT PAGE LOCKS THE FRAME MIGHT HAVE
@@ENTRY J/ FRAME NUMBER
@@ACCUM T1-T4
@@EXIT ALWAYS NON-SKIP RETURN
@@RESTRICTIONS THE CALLER MUST BE PREPARED TO LOSE THE CONTEXT
PAGE LOCK IF HE GETS IT THEN GETS AN I/O ERROR, ILL MEM REF, ETC.
IF THE CALLER HAS LEFT THE STATE OF THE CONTEXT PAGES INVOLVED
IN AN INCONSISTENT STATE, THEY WILL REMAIN IN THAT STATE UNLESS
HE HAS SETUP A JBTABT ROUTINE TO FIX THEM UP AGAIN.
@@FUNCTION FOR ALL CONTEXT PAGE LOCKS THE JOB MIGHT HAVE,
SET THE LOCK LEVEL COUNT (UPTLKC) TO 1, AND CALL UNWUP? FOR
THE LOCK TO GET RID OF IT.
@@;

ABTCPL::CAME	J,%UPT+UPTLKJ	;WE ARE LOCKING?
	JRST	ABTCP1		;NO, CHECK %UPX
	MOVEI	T1,1
	MOVEM	T1,%UPT+UPTLKC	;MAKE THE COUNT 1 SO WE WILL GET RID OF THE LOCK
	PUSHJ	P,UNWUPT	;RELEASE IT
ABTCP1:	CAME	J,%UPX+UPTLKJ	;WE ARE LOCKING %UPX?
	POPJ	P,		;NO, DONE
	MOVEI	T1,1
	MOVEM	T1,%UPX+UPTLKC	;MAKE COUNT 1 SO LOCK WILL GO AWAY
	PJRST	ULDUPX		;AND GIVE THE LOCK BACK.
COMMENT ;@@SUBROUTINE LKDUPX
@@PURPOSE LOCKDOWN THE CONTEXT PAGES FOR C(J) IN %UPX.
GUARANTEES THAT REFERENCING THE PAGES
IN THE %UPX GROUP WILL NOT CAUSE RESCHEDULING. THIS IS
NECESSARY TO READ TWO OR MORE RELATED ITEMS WITHOUT
INTERRUPTION.
@@ENTRY C(J) HAS THE FRAME NUMBER WHOSE CONTEXT PAGES ARE TO BE LOCKED DOWN
@@ACCUM USES T1-T4,PG
@@EXIT SKIP RETURN IF CONTEXT PAGES LOCKED OK, NON-SKIP IF NOT.
IF ERROR RETURN GIVEN, J DOES NOT CONTAIN ORIGINAL VALUE.
@@FUNCTION IF PAGES ALREADY IN, RETURN. ELSE CALL MAPUPX TO GET
CORRECT PAGES MAPPED INTO %UPX. IF CANNOT, GIVE ERROR RETURN.
IF CAN, AND CURRENT JOB'S PAGES ARE NOT IN %UPX, RETURN. ELSE
SET ALL LOCK BITS FIRST, SO SUBSEQUENT CALL TO SETMWS
DOESN'T REPLACE ANY OF THE %UPX PAGES IF THEY ARE ALREADY IN
THE MWS. CALL SETMWS FOR ALL %UPX PAGES TO GET THEM INT MWS
SO SWAPPER WILL BRING THEM IN.  THEN REFERENCE ALL %UPX PAGES WITH A READ INSTRUCTION,
(AFTER THE FIRST REFERENCE, THE SWAPPER SHOULD HAVE THEM ALL READY
TO GO, BUT IN CASE IT DOESN'T, READING ALL THE PAGES SHOULD
LOCK THEM ALL IN FOR SURE.)
CHECK I/O ERROR BITS. IF THEY ARE ALL CLEAR,  GIVE SUCCESS RETURN.
ELSE, IF I/O ERROR BITS ON FOR ANY %UPX PAGE, GIVE ERROR RETURN,
LEAVE CURRENT JOB'S CONTEXT PAGES IN %UPX.
@@;

EXTERNAL LMPLOK,LMMERR,%UPLMA,NCTXPG,%UPX.N

LKDUPX::PUSH	P,W		;SAVE W
	CAMN	J,%UPX+UPTJOB	;ALREADY MAPPED?
				; (UPTJOB HAS -1 IF JOB LOGGED OUT, SO NO MATCH.)
	JRST	LKDUX0		;YES.
	PUSHJ	P,MAPUPX	;MAKE SURE RIGHT CONTEXT PAGES ARE IN %UPX
	  JRST	WPOPJ		;I/O ERROR OR SOMETHING
LKDUX0:	CAMN	J,%UPT+UPTJOB	;OUR OWN CONTEXT PAGES MAPPED?
	JRST	WPOPJ1		;YES, NO NEED TO MESS WITH LOCK BITS OR ANYTHING.
	MOVE	W,[-NCTXPG,,%UPX.N+CNVVPN]
	MOVSI	T1,LMPLOK	;BIT TO LOCK THINGS.
LKDUX1:	IORM	T1,%UPLMA(W)	;SET LOCK BIT
	AOBJN	W,LKDUX1	;FOR ALL PAGES IN %UPX GROUP
	MOVE	W,[-NCTXPG,,%UPX.N+CNVVPN] ;SET ALL LOCK BITS BEFORE
				; CALLING SETMWS SO REPLACER DOESN'T TAKE
				; THE ONES WE'RE GOING TO LOCK
				; IF THEY ARE ALREADY IN THE MWS.
	PUSH	P,J		;SAVE TARGET JOB'S NUMBER
	MOVE	J,%UPT+UPTJOB	;GET CURRENT JOB'S NUMBER FOR SETMWS
LKDUX2:	PUSHJ	P,TSTMWS	;IN MWS ALREADY
	  PUSHJ	P,SETMWS	;NO, PUT IT IN MWS
	AOBJN	W,LKDUX2	;FOR ALL %UPX PAGES
	POP	P,J		;GET TARGET JOB NUMBER BACK.

;HAD TO PUT THEM ALL IN MWS SO WE DON'T GO THRU THE SWAPER NCTXPG TIMES.

	MOVE	W,[-NCTXPG,,%UPX.N] ;LAST TIME
	MOVEI	T2,%UPX		;TO GET AT LMAP SLOT
	MOVSI	T3,LMMERR	;ERROR BITS TO TEST
LKDUX3:	MOVE	T1,(T2)		;REFERENCE THE PAGE
	TDNE	T3,%UPLMA(W)	;ANY ERROR BITS COME ON?
	JRST	LKDUX4		;GO GET CURRENT JOBS PAGES BACK AND GIVE ERROR RETURN.
	ADDI	T2,1000		;NEXT REFERENCE ADDRESS
	AOBJN	W,LKDUX3	;FOR ALL %UPX PAGES
WPOPJ1:	AOS	-1(P)		;THEY ARE ALL NOW LOCKED IN.
WPOPJ:	POP	P,W
	POPJ	P,

LKDUX4:	MOVE	J,%UPT+UPTJOB
	PUSHJ	P,MAPUPX	;GET THEM IN %UPX
	  STOPCD		;SHOULD ALWAYS BE ABLE TO GET THEM
	JRST	WPOPJ		;POP OFF W AND GIVE ERROR RETURN.
COMMENT ;@@SUBROUTINE ULDUPX
@@PURPOSE RELEASE LOCKDOWN ON %UPX
@@ENTRY
@@ACCUM T1-T4
@@EXIT
@@FUNCTION RELEASE WRITE LOCK IF CALLER HAS IT. IF CALLER STILL HAS LOCK
AFTER RELEASEING IT, AN UPPER LEVEL HAS THE LOCK, SO JUST REURN. ELSE
IF CALLER'S CONTEXT PAGES ARE IN %UPX, RETURN, ELSE CLEAR THE LOCK BITS FOR THE %UPX PAGES AND RETURN.
QUESTION: SHOULD %UPX PAGES BE TAKEN OUT OF MWS AT THIS POINT?
@@;

ULDUPX::MOVE	T1,%UPT+UPTJOB
	CAME	T1,%UPX+UPTLKJ	;WE HAVE THIS LOCKED?
	JRST	ULDUX1		;NO, DON'T MESS WITH LOCK
	PUSHJ	P,UNWUPX	;YES, GET RID OF ONE LEVEL OF THE LOCK
	MOVE	T1,%UPT+UPTJOB	;GET CALLER'S FRAME NUMBER BACK
	CAMN	T1,%UPX+UPTLKJ	;IF CALLER STILL HAS LOCK,
	POPJ	P,		;DON'T TAKE THE LOCKDOWN OFF, STILL NEED IT.
ULDUX1:	CAMN	T1,%UPX+UPTJOB	;IF CALLER'S OWN CONTEXT PAGES ARE IN %UPX,
	POPJ	P,		;THERE IS NOTHING TO DO.
	MOVE	T4,[-NCTXPG,,%UPX.N+CNVVPN]
	MOVSI	T3,LMPLOK
RELUR1:	ANDCAM	T3,%UPLMA(T4)	;CLEAR LOCK BIT
	AOBJN	T4,RELUR1	;FOR ALL PAGES IN %UPX GROUP
	POPJ	P,		;AND RETURN.
COMMENT ;@@SUBROUTINE MAPUPX
@@PURPOSE SETUP %UPX WITH ANOTHER FRAME'S CONTEXT PAGES
@@ENTRY J CONTAINS FRAME NUMBER FOR DESIRED CONTEXT PAGES.
	CALLER SHOULD CHECK TO SEE IF CORRECT PAGES ALREADY THERE
	BY CHECKING %UPX+UPTJOB.
@@ACCUM USES T1-T4,W,PG
@@EXIT ERROR RETURN IF FRAME NO LONGER EXISTS (?)
	(CURRENT JOB'S CTX PAGES MAPPED IN %UPX ON ERRORS).
	SKIP RETURN IF FRAME'S CONTEXT PAGES SUCCESSFULLY MAPPED
	INTO %UPX.
@@FUNCTION IF OTHER JOB'S CONTEXT PAGES ARE IN %UPX, REMOVE THEM
BY CALLING UPXRMV (AVOID RECURSION). IF MAPPING OWN CONTEXT PAGES INTO %UPX, COPY
SLOTS FROM %UPT'S SLOTS CLEARING PAGE TABLE AND RETURN.
ELSE MAP OTHER JOB'S SLOTS IN WITH MAPKRN. IF MAPKRN FAILS,
REMOVE %UPX GROUP, MAP OWN SLOTS INTO %UPX, AND GIVE ERROR RETURN.
ELSE SET IGNORE I/O ERROR BITS FOR %UPX, RETURN.
@@;

EXTERN %UPT,UPTJOB,%UPX.N,%UPT.N,JOBATB,CTXTAB,CPRRED,LMPMXW,LMPNER
EXTERN UPYPTM,UPYPXM,USYPTN,EPYPSM
EXTERN MAPKRN,%UPLMA,NCTXPG,RBREAL,LMMRED,SAVE4


MAPUPX::JSP	T4,SAVE4	;SAVE P1-P4.
	MOVE	T1,%UPX+UPTJOB	;SEE IF FOREIGN CTX PAGES ARE IN %UPX
	CAMN	T1,%UPT+UPTJOB	;SKIP IF SO
	JRST	MAPUX0		;OUR OWN, JUST OVERWRITE SLOTS.
	PUSHJ	P,UPXRMV	;REMOVE %UPX PAGES, AVOIDING USE OF %UPX.
MAPUX0:	CAMN	J,%UPT+UPTJOB	;SET TO CURRENT JOB'S?
	JRST	MAPUPC		;YES, GO REMOVE %UPX AND COPY MAP SLOTS
	MOVE	W,[-NCTXPG,,%UPX.N+CNVVPN] ;AOBJN POINTER

;CODE BELOW HAS TO CHECK CTX STATUS BITS IN CASE JOB GOES AWAY BETWEEN MAPS.
MAPUX1:	PUSHJ	P,JOBATB	;GET ATB ADDRESS IN T1
	MOVE	T2,JBTCTX(J)	;GET STATUS BITS AGAIN
	TLNN	T2,CTXVIR+CTXSWE;IF NOTHING THERE YET OR SWAP ERROR, NO GOOD.
	TLNN	T2,CTXCEX	;OK SO FAR, IF THEY EXIST, GIVE THEM.
	JRST	MAPUXE		;NO GOOD, RETURN.
	LDB	T2,CTXTAB-<%UPX.N+CNVVPN>(W) ;GET DISK ADDRESS
	TLO	T2,RBREAL	;MAKE IT TASTY TO MAPKRN
	MOVSI	P3,LMMRED	;MAX WRITE, READ ONLY.
	PUSHJ	P,MAPKRN	;MAP IN NEXT CONTEXT PAGE.
	  JRST	MAPUXE		;ERROR FROM MAPKRN, GET OWN PAGES IN%UPX AND ERROR RETURN.
	TLO	P3,LMPNER	;IGNORE I/O ERRORS.
	PUSHJ	P,SETLMA	;STORE LMAP SLOT BACK.
	AOBJN	W,MAPUX1	;AND DO NEXT %UPX PAGE.
	MOVE	T1,JBTCTX(J)	;MAKE SURE DIDN'T GO AWAY BEFORE LAST MAPKRN CALL
	TLNN	T1,CTXVIR+CTXSWE
	TLNN	T1,CTXCEX	;NOT VIRGIN, NO ERRORS, AND MUST EXIST
	JRST	MAPUXE		;NO GOOD, GET RID OF THEM AND RETURN.
	AOS	(P)		;GIVE GOOD RETURN, AND 
	PJRST	RELSAT		;GIVE BACK SAT IF WE HAVE IT.

MAPUXE:	PUSHJ	P,RELSAT	;GIVE BACK SAT IF WE HAVE IT.
	PUSHJ	P,UPXRMV	;CLEAR EVERYTHING MAPKRN DID.
	SOS	(P)		;GET OWN PAGES IN AND GIVE ERROR RETURN.
;	JRST	MAPUPC


;HERE TO MAP CURRENT JOBS CONTEXT PAGES INTO %UPX

MAPUPC:	MOVE	T4,UPYPXM	; [UPTPTR(%UPX.N-1)]
	MOVE	T3,UPYPTM	; [UPTPTR(%UPT.N-1)]
	MOVE	W,[-NCTXPG,,%UPX.N+CNVVPN]
MAPUC1:	ILDB	T1,T3
	IDPB	T1,T4
	CLRPTW			;CLEAR PT FOR PAGE WHOSE NUMBER IS IN W
	AOBJN	W,MAPUC1
	JRST	CPOPJ1
COMMENT ;@@SUBROUTINE UPXRMV
@@PURPOSE REMOVE %UPX PAGES WITHOUT REQUIRING CURRENT FRAME'S
CONTEXT PAGES TO BE IN %UPX.
@@ENTRY ONE OR MORE PAGES MAPPED INTO %UPX. (NON-EXISTENT ONES
WILL BE IGNORED).
%UPX PAGES MUST NOT BE LOCKED DOWN (LMPLOK).
@@ACCUM W, PG, P1-P4.
@@EXIT J STILL HAS FRAME NUMBER.
@@;

EXTERNAL SAVE4,RELSAT

UPXRMV:	PUSH	P,S
	PUSH	P,U
	PUSH	P,F
	PUSH	P,J
	MOVE	J,%UPT+UPTJOB	;GET CALLER'S JOB NUMBER, REMMWS NEEDS IT.

	SETZ	F,		;CLEAR NO ERROR LOGGING FLAG IN LH OF F
	MOVE	W,[-NCTXPG,,%UPX.N+CNVVPN] ;AOBJN POINTER FOR PAGES TO REMOVE

UPXRM1:	PUSHJ	P,REDLMA	;GET LMAP SLOT - LEAVE LDC COUNT ZERO FOR REMKRN.
	TLNN	P3,LMMEXS	;EXISTS?
	JRST	UPXRMN		;NO, GO DO NEXT ONE.
	PUSHJ	P,REMMWS	;TAKE PAGE OUT OF MWS, DEACTIVATE IT
	PUSHJ	P,REMKRN	;REMOVE THE SLOT
	PUSHJ	P,SETLMA	;STORE IT BACK, COUNT WAS ZERO
UPXRMN:	AOBJN	W,UPXRM1	;DO NEXT

	POP	P,J
	POP	P,F
	POP	P,U
	POP	P,S
	PJRST	RELSAT		;GIVE SAT BACK.
SUBTTL MISC. ROUTINES

;ROUTINE TO CHECK VALIDITY OF PAGE CONTAINED IN RH(W).
; CALLED  WITH SIGN BIT OF F = 0 IF UUO DONE BY USR,
; SIGN BIT 0 IF CALLED BY EXEC. CALLED BY JSP T4,VPCHK.

VPCHK:	MOVEI	T1,777		;ASSUME USER CALLED
	TLNN	F,FL.USR	;SKIP IF TRUE
	MOVEI	T1,VPUMAX	;NO, EXEC LIMIT
	CAIGE	T1,(W)		;IS MAX EQUAL OR GREATER THAN PAGE?
	JRST	(T4)		;NO, ERROR
	JRST	1(T4)		;YES, OK.

IFNCPU (KI),<
;ROUTINE TO INVALIDATE PGE TABLE ENTRY FOR PAGE WHOSE NUMBER
; IS IN RH(W). PRESERVES ALL ACS. NEVER CALL DIRECTLY -
; USE CLRPTW MACRO.

CLPTW::	TRNN	W,777000	;USER PAGE?
	JRSTF	@[PC.UIO,,CLPTW1] ;YES,GO CLEAR FOR USER MAP
	ROT	W,^D9		;MAKE INTO ADDRESS
	CLRPTO	<-<CNVVPN*1000>(W)>		;CLEAR 1 LINE OF PAGE TABLE
	ROT	W,-^D9		;BACK TO ORIGINAL
	POPJ	P,		;RETURN.

CLPTW1:	ROT	W,^D9		;CONVERT TO ADDRESS
	XCTBU	<CLRPT (W)>	;CLEAR LINE OF PAGE TABLE FOR USER.
	ROT	W,-^D9		;BACK TO ORIGINAL VALUE.
	POP	P,(P)		;MUST RESTORE USER IOT
	JRSTF	@1(P)		;RETURN WITH ORIGINAL SETTING OF USER IOT
>;END IFNCPU (KI)
SUBTTL PAGE FAULT HANDLER

COMMENT;@@SUBROUTINE PAGFLU/PAGFLE
@@PURPOSE HANDLE ALL NON-SPECIAL PAGE FAULTS FOR SYSTEM
@@ENTRY PAGE FAULT WORD IN T1 (KI HARDWARE FORMAT)
FAULT PC ON STACK
@@ACCUM T1-T4, P1-P4, F, J (SETUP TO CURRENT JOB NUMBER)
@@EXIT NON-SKIP IF REFERENCE WAS SUCCESSFUL OR IF
TRAP IS TO BE TAKEN FOR WORKING SET.  USER PAGE FAULTS
SHOULD ALWAYS DISMISS THRU USRXIT SO TRAPS WILL HAPPEN
IMMEDIATELY, IF NON-SKIP IS GIVEN.
SKIP RETURN IF REFERNCE DID NOT SUCCEED FOR SOME REASON.

ERROR CODE RETURNED IN RH OF T1, VP RETURNED IN LH OF T1
AND IN W. 0-777 ARE CORRESPONDING USER PAGES,
1000-1037 ARE EXEC PER PROCESS PAGES 340-377.
VP NUMBER UNSPECIFIED FOR EXEC PAGES GEQ 400.
F CONTAINS THE SOFT PAGE FAULT WORD
M CONTAINS THE ADDRESS (PAGE BOUNDARY ON KI) OF THE
OFFENDING REFERENCE.
@@RESTRICTIONS GUARANTEED NOT TO RESCHEDULE IF JUST FAULTING FOR
A WRITE AND PAGE IS ALREADY IN CORE. (SOME ROUTINES DEPEND ON THIS.)
@@FUNCTION 1) GIVE ERROR IF ITS FOR EXEC PAGE 400 OR GREATER.
2) DISPATCH TO PCBFLT IF VIRTUAL PAGE IS ONE RESERVED FOR PCBS.
3) SET REFERENCE BIT
4) HANDLE USER WORKING SET - GIVE TRAP IF POSSIBLE AND NECESSARY
5) GET PAGE INTO MWS IF NOT THERE, ACTIVATE IT IF NECESSARY
6) FOR UNSHARED FILE PAGES, SEARCH SPT TO SEE IF IT BECAME SHARED
 WHILE THIS SLOT WAS INACTIVE. IF SO, SET THIS SLOT
 TO SHARED SO ALL ACTIVE SLOTS ARE CORRENT W.R.T. SHARED BIT.
7) FOR PRIVATE PAGES, CHECK TO SEE IF ITS VIRGIN. IF SO,
 CLEAR VIRGIN BIT IN SPT AND ZERO OUT CORE PAGE. SKIP ERROR CHECKING,
 SINCE PAGE SHOULD HAVE NEVER BEEN READ OR WRITTEN YET.
8) CHECK ERRORS, HANDLE ERROR TRAP STUFF.
9) SET ACCESS BIT IF ALL OK SO FAR.
10) IF USER IS NOT TRYING TO WRITE OR IS AND "W" BIT IS ON, RETURN.
11) (USER TRYING TO WRITE AND "W" BIT IS OFF) GIVE ERROR RETURN
 (SKIP) IF PROTECTION IS READ ONLY. IF ITS COW,
 DO COW STUFF (REPLICATE, REMOVE, VCREAT, COPY, REMOVE)
IF READ WRITE, MARK PAGE DIRTY AND SET "W" BIT.
12) RETURN.

NOTE: IT IS IMPORTANT THAT IF THE LMAP SLOT IS IN P3 AND 4 AND
A ROUTINE IS CALLED THAT UPDATES THE SLOT AND THE PGY INFORMATION
TOGETHER, THE SLOT MUST BE STORED, OR ELSE THE SLOT AND PGY
TABLE STUFF WILL BE INCONSISTENT (E.G. LMA CHAIN, PGY POINTING
TO INACTIVE SLOT, SINGLE UNSHARED ACTIVE SLOT WITH PGYATB ZERO
BECAUSE SETSHR WAS CALLED BUT SLOT NEVER STORED BACK).
@@;

;ERROR CODES RETURNED IN RH(T1) IF SKIP RETURN:

ERRCOD(0,PFBER%,PFEBER)		;BAD EXEC REF - FAULT FOR EPT OR CONTEXT PGE.
ERRCOD(1,PFNXP%,PFENXP)	;NON-EXISTENT USER OR EXEC PER PROCESS PAGE REFERENCE
ERRCOD(2,PFWRT%,PFEWRT)	;WRITE FAILURE FOR USER OR EXEC PER PROCESS PAGE
ERRCOD(3,PFSWE%,PFESWE)	;SWAP OR PARITY ERROR
ERRCOD(4,PFDFC%,PFEDFC)	;DISK FUL DURING WRITE IN COW PAGE.
ERRCOD(5,PFCWS%,PFECWS)	;ATTEMPT TO WRITE INTO COW SUPER PAGE.
ERRCOD(6,PFABK%,PFEABK)	;ADDRESS BREAK. FAULT WORD RETURNED IN F.
ERRCOD(7,PFHPF%,PFEHPF)	;HARDWARE PAGE FAULT ERROR. FAULT WORD RETURNED IN F.
ERRCOD(10,PFNEC%,PFENEC)	;NOT ENOUGH CORE TO MWSRPL (DUE TO DIO LOCKS)

;MACRO TO SHORTEN KEYSTROKES:

DEFINE PGFERR(ERR)<	SALL
	JRST	[PUSHJ P,PFE'ERR
		 JRST FLTBRF]
	XALL>
PAGFLE::TDZA	F,F		;INDICATE THAT ITS EXEC REF
PAGFLU::MOVSI	F,FL.USR	;INDICATE THAT USER CAUSED PAGE FAULT
	MOVE	J,JOB		;SETUP J.
	CHGSTS	T2	;SAVE CLOCK STATE
	NOCHARGE		;DON'T CHARGE FOR UCYCLES
	PUSH	P,T2		;
IFCPU (KI),<
	LDB	W,[POINT 9,T1,17] ;GET PAGE NUMBER
	MOVE	M,W		;GET ADDRESS OF PAGE BOUNDARY IN M
	LSH	M,^D9
	DPB	T1,[POINT 6,F,23] ;GET 0AWST IN 18-23.
	TLNE	T1,(PFW.U)	;TRANSFER MAP SELECT BIT TO
	TRO	F,SPFW.U	;PROPER PLACE
	TRNE	F,SPFW.H	;ADDRESS BREAK OR HARD FAIL?
	JRST	SPCFLT		;YES.
	TRNN	F,SPFW.U	;IF TO EXEC MAP, GO TO EXCFLT.
	JRST	EXCFLT		;ITS TO EXEC SPACE, GO CHECK IT.
>;END IFCPU (KI)

IFNCPU (KI),<
	LDB	W,[POINT 9,T1,26] ;GET VIRTUAL PAGE NUMBER IN W
	HRRZ	M,T1		;GET ADDRESS IN M
	HLR	F,T1		;THIS IS EASY - JUST GET INTO RH SO BIT 0
				; IS FREE FOR COPY OF PC.USR
	TRNE	F,SPFW.H	;ADDRESS BREAK OR HARD PAGE FAIL?
	JRST	SPCFLT		;YES, HANDLE EARLY.
	TRNN	F,SPFW.U	;REF IS TO USER ADDR SPACE?
	JRST	EXCFLT		;NO, HAVE TO SEE WHATS GOING ON.
>;END IFNCPU (KI)

;BACK HERE FROM EXCFLT IT FAULT WAS FOR REGULAR EXEC PER PROCESS
; VP. 1000 = 340.

USRFLT:	AOS	PFLCNT		;COUNT TOTAL PAGE FAULTS
	SKIPE	J		;NO FAULTS FROM NULLJOB
	SKIPE	%UPT+UPTLDC	;NO SLOTS AROUND, WE HOPE
	STOPCD
	POP	P,P1		;GET CLOCK WORD OFF STACK
	JSP	P2,[PUSHJ P,WLKUPT
		     STOPCD		;NEVER SHOULD HAPPEN.
		   PUSHJ P,(P2) ;RETURN TO CALLER
		     SKIPA
		   AOS (P)
		   PUSH P,T1	;SAVE POSSIBLE ERROR CODE
		   PUSHJ P, UNWUPT
		   POP P,T1
		   POPJ P,]  ;GET RID OF LOCK AND RETURN.
	PUSH	P,P1		;PUT CLOCK WORD BACK ONTO STACK.
	PUSHJ	P,GETLMA	;GET LMAP CONTENTS FROM %UPT
	TLNN	P3,LMMEXS	;DOES VP EXIST?
	PGFERR(NXP)		;NO. BAD REF, GIVE ERROR RETURN.
	TLON	P3,LMPREF	;IS REF BIT ON ALREADY? (SET IT)
	TRNN	F,SPFW.U	;NOT ON, IF EXEC'S MAP, FORGET TRAPS
	JRST	USRRBO		;EXEC MAP OR REF BIT ON.
	MOVE	P1,M		;CONSTRUCT FAULT INFO WORD IN P1
	TLO	P1,RI.VAL	;VALID INFO BIT
	LDB	T1,JBYREF	;GET INTERRUPT CHANEL IF ANY
	JUMPE	T1,USRRB2	;IF NONE, GO STORE IN EXEC WORD AND LEAVE BIT ON
	PUSHJ	P,TSTKTP	;TRY TO SET THE TRAP, SKIP IF CAN'T TAKE IT
	  JRST	USRRB1		;OK, TRAP IF THIS FAULT IS FROM SER MODE PC
	PUSHJ	P,TAKTRP	;CAN'T TRAP NOW, SET IT FOR LATER
	JRST	USRRB2		;AND GO STORE INTO EXEC FAULT WORD
USRRB1:	JUMPGE	F,USRRB2	;IF EXEC MODE, STORE INTO EXECC FAULT WORD
	TLZ	P3,LMPREF	;USER MODE, CLEAR REF BIT, LET USER SET IT HIMSELF
	MOVEM	P1,%UPT+UPTURI	;USER IS GETTING TRAP, STORE THAT
	JRST	FLTGRF		;AND RETURN TO USER'S TRAP ROUTINE.
USRRB2:	MOVEM	P1,%UPT+UPTXRI	;TELL USER THAT SOMETHING WENT ON BEHIND
				; HIS BACK AND CONTINUE FAULT PROCESSING
USRRBO:	CAILE	W,777		;PAGES IN THE EXEC PER PROCESS AREA
	JRST	USRIUW		;ARE NOT PART OF UWS SYSTEM
	HRRZ	T1, W
	IDIVI	T1, AGECPW	;T1/ AGE CELL WD#, T2/ AGE CELL # IN WD
	SETZ	T3,
	DPB	T3, AGEPTR(T2)	;SET AGE = 0
	TRNE	F,SPFW.A	;IF A BIT IS ON, MUST BE IN UWS AND ACCESSIBLE
	JRST	USRCWR		;SO GO CHECK WRITE.
	PUSHJ	P,TSTUWS	;IS PAGE IN UWS ALREADY?
	  JRST	USRFL1		;NO
	JRST	USRIUW		;YES. SEE WHATS GOT TO BE DONE.
				;NO. PUT PAGE IN UWS FIRST. FALL THRU
;HERE IF FAULT PAGE WAS NOT IN UWS. TRAP TO USER IF CAN, AND
; USER WILL DETERMINE WHICH PAGE TO REPLACE TO GET THIS ONE
; IN UWS.  IF CANNOT TRAP TO USER OR TRAPS NOT ENABLED,
; USE MONITOR USER WORKING SET PAGE REPLACEMENT ALGORITHM

USRFL1:	LDB	P2,JBYUWS	;INTO P2 WITH SIZE SO WILL HANG AROUND
	LDB	T1,UPYUWL	;LIMIT
	SUB	P2,T1		;P2 GETS SIZE-LIMIT
	MOVE	P1,W		;GET FAULT WORD STARTED WITH VP NUMBER
	LSH	P1,^D9		;CONVERT TO ADDRESS
	TLO	P1,FI.VAL!FI.SAL	;ASSUME SIZE .GE. LIMIT
	LDB	T1,JBYSAL	;GETUP CHANNEL NUMBER FOR THAT
	JUMPGE	P2,USRFL2	;JUMP IF SIZE .GE. LIMIT
	TLZ	P1,FI.SAL	;NO, SIZE UNDER LIMIT
	LDB	T1,JBYSLL	;GET CHANNEL FOR THAT TRAP
USRFL2:	JUMPE	T1,USRFL4	;SAVE SOME TIME IF NO CHANNEL ASSIGNED

	PUSHJ	P,TSTKTP	;CAN WE TAKE THE TRAP NOW?
	  JRST	USRFL3		;YES, OK
	PUSHJ	P,TAKTRP	;NO. MAKE IT HAPPEN WHEN IT CAN
	JRST	USRFL4		;GO DO REPLACEMENT IN MONITOR

USRFL3:	JUMPGE	F,USRFL4	;GO IF FAULT WAS IN EXEC MODE, CAN'T TRAP
	MOVEM	P1,%UPT+UPTUFI	;STORE AS THE USER INFO WORD.
	JRST	FLTGRF		;AND RETURN, USER GETS TRAP NOW.

;HERE IF CAN'T TAKE THE TRAP FOR ANY REASON. STORE FAULT
; INFO WORD IN THE EXEC INFO SLOT, EVEN IF NOTHING IS ENABLED.
; THIS IS PRIMARILY USEFUL FOR SHOWING USER THAT MONITOR
; CHANGED HIS WORKING SET.

USRFL4:	MOVEM	P1,%UPT+UPTXFI	;STORE IN EXEC INFO SLOT
	JUMPE	P2,USRFL5	;IF SIZE EQUAL TO LIMIT, DON'T CALL TIMADJ,
				; SIZE IS STAYING THE SAME
	PUSHJ	P,TIMADJ	;SIZE IS CHANGING, ADJUST CHARGES
	JUMPL	P2,USRFL6	;IF SIZE IS ALREADY UNDER LIMIT, NO REPLACEMENT.
USRFL5:	PUSHJ	P,STOLMA	;PROTECT LMAP SLOT FROM UWSRPL
	PUSHJ	P,UWSRPL	;SIZE WAS AT LEAST LIMIT, REPLACE UNTIL ITS UNDER.
	PUSHJ	P,GETLMA	;GET IT BACK AGAIN.
USRFL6:	PUSHJ	P,SETUWS	;SET THE UWS BIT FOR PAGE
	TLNE	P3,LMPVIR	;IF ITS VIRGIN,
	JRST	[TLNE P3,LMPSUP	;IF SUPER SLOT, DON'T TRY TO GET ATB,
		 JRST USRAUW	; JUST MAKE IT FREE.
		 PUSHJ P,GETATB ;GET ATB TO SEE IF ITS PRIVATE.
		 SKIPGE ATBDUM(T1) ;SKIP IF ITS A FILE PAGE
		 JRST USRAUW	;VIRGIN PRIVATE, ITS FREE.
		 JRST .+1]	;VIRGIN FILE PAGE, CHARGE.
	MOVEI	T4,1		;CHARGE THE USER FOR
	PUSHJ	P,CHGPWS	;THIS .
	JRST	USRAUW
;HERE IF PAGE WAS ALREADY IN UWS (USRIUW)

USRIUW:

;HERE IF PAGE WAS IN UWS (USRIUW) OR WAS JUST ADDED TO UWS (USRAUW)

USRAUW:	TRNE	F,SPFW.A	;FAULT WORD SAYS ACCESS FAILURE?
	JRST	USRCWR		;NO, CHECK WRITE BIT

;PUT PAGE IN MWS, ACTIVATE IT, AND MAKE SURE SWAPIN NOT IN PROGRESS

	PUSHJ	P, FLTMWS
	  JRST	[		;NO BUMPABLE PAGES & AT MWS LIMIT
		PUSHJ	P, STOLMA
		PGFERR(NEC)
	  ]

;PAGE IS NOW ACTIVE, READY FOR USER TO REFERENCE. IF
; ITS A FILE PAGE, UPDATE STATUS FROM UNSHARED TO SHARED IF
; SPT ENTRY EXISTS. IF ITS A PRIVATE PAGE, DON'T NEED TO DO
; THAT SINCE WHEN PRIVATE PAGES BECOME SHARED THE ORIGINAL
; UNSHARED SLOT GETS UPDATED. BUT HAVE TO SEE IF THE PRIVATE
; PAGE IS VIRGIN. IF SO, MUST CLEAR VIRGIN AND ZERO THE
; PAGE.

USRIU2:	TLNE	P3,LMPSUP	;IS THIS A SUPER SLOT?
	JRST	USRIU5		;YES, NO MESSING AROUND.
	PUSHJ	P,GETATB	;GET ATB ADDR IN T1
	SKIPGE	ATBSTS(T1)	;IS THIS A FILE PGE?
	JRST	USRIU3		;NO, GO CHECK FOR VIRGIN
	JUMPL	P3,USRIU5	;IF SHARED LMPSHR, DON'T SEARCH SPT

;UNSHARED FILE PAGE. SEE IF DP IS IN SPT. IF SO, CHANGE THIS
; SLOT'S STATUS TO SHARED

	PUSHJ	P,GETDPA	;GET DP ADDRESS IN T2
	PUSHJ	P,SRCSPT	;SEE IF DP IS IN SPT
	  JRST	USRIU5		;NO, GO CHECK LMMERR, DON'T UPDATE.
	PUSHJ	P,SETSHR	;YES. UPDATE STATUS TO SHARED
	PUSHJ	P,SETLMA	;STORE SO PGY AND LMAP AGREE IN CASE WE ERROR EXIT
				;BUT STILL KEEP SLOT DATA OUT.
	JRST	USRIU5		;AND GO CHECK PGYERR

;HERE IF PAGE IS PRIVATE, IT MAY BE VIRGIN.

USRIU3:	TLZN	P3,LMPVIR	;PRIVATE VIRGIN? (ACTLMA UPDATED LMPVIR)
	JRST	USRIU5		;NO.
	JUMPGE	P3,USRIU6	;YES. IF UNSHARED, DON'T NEED TO CLEAR SPT VIRGIN BIT.
	PUSHJ	P,GETSPT	;GET SPT ENTRY
	MOVSI	T2,SPPVIR	;CLEAR VIRGIN BIT
	ANDCAM	T2,SPTVIR(T1)	;SO OTHERS WILL KNOW WE FIXED IT UP.
USRIU6:	TRO	P4,PGE.A!PGE.P!PGE.C!PGE.W ;SO WE CAN CLEAR IT
	PUSHJ	P,SETLMA	;PUT P4 IN UPT
	MOVE	T1,W		;GET VP NUMBER IN T1
	TRNE	F,SPFW.U	;WAS FAULT TO USER ADDR SPACE?
	JRSTF	@[PC.UIO,,.+2]	;YES, MAKE SURE WE REFERENCE THAT
	SUBI	T1,CNVVPN	;NO, CONVERT TO REAL EXEC PAGE NUMBER
				; AND LEAVE USER I/O OFF.
	HRLS	T1		;GET PAGENUMBER,,PAGENUMBER
	LSH	T1,^D9		;GET ADDRESS,,ADDRESS
	MOVEI	T2,777(T1)	;GET END ADDRESS
	SKIPN	T1		;IF PAGE 0,
	SKIPA	T1,[20,,21]	;THIS IS POINTER TO USE
	ADDI	T1,1		;ELSE GET ADDRESS,,ADDRESS+1
	XCTBU	<SETZM -1(T1)> ;CLEAR FIRST WORD
	XCTBU	<BLT T1,(T2)> ;CLEAR THE REST
	MOVEI	T1,1		;NOW MARK THE PAGE DIRTY
	PUSHJ	P,GETCPA	;SETUP PG
	DPB	T1,PGYDRT	;MAKE IT DIRTY SO DISK PAGE GETS ZEROED
	TRZ	P4,PGE.W	;TURN OFF W BIT AGAIN
	PUSHJ	P,SETLMA	;PUT GOOD SLOT DATA BACK
				; IN CASE FAULT STILL FAILS WRITE PROTECT)
	JRST	USRCWR		;CANNOT BE ERRORS, BITS ALREADY SET.
USRIU5:	SETZ	P1,		;START OUT WITH ZERO.
	SKIPN	OHTNUM		;ANY OHT ENTRIES?
	JRST	USRI5D		;NO, SKIP CHECK THEN.
	PUSHJ	P,GETDPA	;GET DP ADDRESS
	PUSHJ	P,SRCOHT	;IS DP IN OHT?
	  JRST	USRI5D		;NO, ITS OK SO FAR.
	TLO	P1,EI.OER
	MOVE	T1,OHTTAB(T4)	;GET ENTRY, SO CAN CHECK BITS
	TLNE	T1,OHTDER	;DEVICE ERROR
	TLO	P1,EI.DER
	TLNE	T1,OHTDTE	;DATA ERROR
	TLO	P1,EI.DTE
	TLNE	T1,OHTPAR	;PARITY ERROR ON OUTPUT (PAGE IS GONE FROM CORE.)
	TLO	P1,EI.PAR	;YES, FLAG THAT.
USRI5D:	PUSHJ	P,GETCPA	;GET CP NUMBER IN PG
	LDB	T1,PGYERR	;GET INPUT ERROR BITS
	JUMPE	T1,[JUMPE P1,USRIU7 ;IF NO INPUT ERROR OR OUTPUT ERRORS, SKIP THIS
		    JRST .+1]	;ELSE CONTINUE.
	TRNE	T1,IODERR_-^D15	;COPY DEVICE AND DATA TO P1
	TLO	P1,EI.DER
	TRNE	T1,IODTER_-^D15
	TLO	P1,EI.DTE
	TLNE	P1,EI.PAR!EI.DER ;PARITY OR DEVICE CAUSES
	TLO	P3,LMPDER	;DEVICE ERROR TO GET SET IN SLOT
	TLNE	P1,EI.DTE	;DATA ERROR SETS
	TLO	P3,LMPDTE	;DATA ERROR.
				;NO NEED TO CHECK LMAP ERROR BITS - 
				; DP WILL BE IN OHT UNTIL LAST USER,
				; IF CP ERROR BITS GO AWAY, LET HIM HAVE GOOD DATA.
	IORI	P1,(W)		;GET PAGE NUMBER IN RH
	TLO	P1,EI.VAL	;PUT VALID DATA BIT ON
	TLNE	P3,LMPNER	;IGNORE ERRORS ON THIS PAGE?
	JRST	[MOVEM P1,%UPT+UPTXEI ;YES, STORE INFO INTO EXEC WORD
		 JRST USRIU7]	;AND IGNORE THE ERROR
	CAILE	W,777		;USER'S PAGE?
	JRST	USRI5B		;NO, DON'T GIVE TRAP TO USER FOR MONITOR'S PROBLEM.
	LDB	T1,JBYPER	;GET CHANNEL NUMBER FOR I/O ERRORS
	JUMPE	T1,USRI5B	;JUMP IF NOT ENABLED
	PUSHJ	P,TSTKTP	;TRY TO TAKE TRAP
	  JRST	USRI5A		;OK, GO GIVE IT TO HIM NOW.
	PUSHJ	P,TAKTRP	;CAN'T TAKE NOW, GIVE IT LATER.
	JRST	USRI5B

USRI5A:	JUMPL	F,USRI5C	;IF USER MODE, JUST GO TRAP.
	PUSHJ	P,SWEDRS	;CAN WE STOP HERE?
	  JRST	.+2		;YES. LMAP SLOT STORED NOW.
	JRST	USRI5B		;NO. RE-DO CODE, STORE PAGE IN XEI FOR USRSWE IN UUOCON
	MOVEM	P1,%UPT+UPTUEI	;CAN GIVE TRAP NOW, STORE FOR USER
	PGFERR	(SWE)		;AND LET ERRCON HANDLE THE TRAP.
USRI5C:	MOVEM	P1,%UPT+UPTUEI	;OK, STORE FOR THE USER
	JRST	FLTGRF		;AND DISMISS, GIVING TRAP.

USRI5B:	MOVEM	P1,%UPT+UPTXEI	;PUT INTO EXEC FAULT WORD IN CASE HE
				; RESTARTS PROGRAM OR SOMETHING.
	PUSHJ	P,SWEDRS	;MAKE SURE NOT IN BAD PLACE TO ILL MEM REF (LOOKUP, ETC)
	  PGFERR(SWE)		;GIVE "PAGE I/O ERROR"
;	JRST	USRFL7		;IGNORE ERROR. FALL THRU.
				; CAN'T STOP ANYONE WITH RESOURCE AND JBTABT NOT SETUP.
USRIU7:	TRO	P4,PGE.A!PGE.P	;OK TO SET ACCESS NOW, SINCE ITS IN UWS,
				; AND MWS, LMPREF=1, ACTIVE, NO SWAP INS,
				; NOT VIRGIN, AND NO SWAP ERRORS.

;HERE IF PAGE IS ACCESSIBLE. MAYBE CAN'T WRITE.

USRCWR:	TRNE	F,SPFW.T	;TRIED TO WRITE AND
	TRNE	P4,PGE.W	;WRITE BIT OFF?
	JRST	FLTGRF		;NO, JUST RETURN

	LDB	T1,LM3CUR	;GET CURRENT PROTECTION
	JRST	@[.+1		;ILLEGAL, CRASH
		 USRBWR		;BAD REF, TRIED TO WRITE.
		 USRCOW		;COPY ON WRITE
		 USRRDW](T1)	;READ/WRITE. MAKE IT DIRTY

	STOPCD			;PROTECTION FIELD WAS ZERO

USRBWR:	SOSGE	%UPT+UPTLDC	;THROW AWAY LMAP DATA NOW.
	STOPCD			;COUNT WENT BAD.
	PGFERR(WRT)		;SAY ILL WRITE REF OR WHATEVER.
;HERE TO MAKE PRIVATE UNSHARED PAGES AND SUPER PAGES
; READ/WRITE FROM COPY-ON-WRITE.

USRRD0:	MOVEI	T1,CPRRDW	;NEW PROTECTION CODE
	DPB	T1,LM3CUR	;NEW PROTECTION IS READ/WRITE
				; FALL THRU AND MAKE IT DIRTY TOO.

;HERE IF GOT A WRITE FAULT TRYING TO WRITE INTO A READ/WRITE
; PAGE. IT MUST HAVE BEEN CLEAN WHEN ACTIVATED. MARK IT DIRTY
; (MAY BE DIRTY NOW IF SOMEONE ELSE DIRTIED IT AFTER THIS SLOT
; WAS ACTIVATED).

USRRDW:	TLNN	P3,LMPACT	;MAKE SURE ITS ACTIVE
	STOPCD			;PAGE TABLE DIDN'T GET CLEARED.
	TRO	P4,PGE.W	;ALLOW WRITE
	MOVE	PG,P4		;GET CORE PAGE ADDRESS, BITS
	ANDI	PG,17777	;JUST CORE PAGE NUMBER
	SETO	T1,
	DPB	T1,PGYDRT	;MAKE CORE PAGE DIRTY IF IT WASN'T BEFORE
	JRST	FLTGRF		;AND DISMISS

;HERE IF TRYING TO WRITE INTO A COPY-ON-WRITE PAGE
; WARNING!!! UUOS THAT WRITE INTO COW PAGES HAD BETTER NOT
; HAVE CB, RIB, OR SAT, OR ANYTHING ELSE KCREAT, KCLEAR,
; OR KREPLC MIGHT WANT. DO SETMM FIRST IF UUO HAS THESE RESOURCES.

USRCOW:	TLNE	P3,LMPSUP	;WRITING INTO COW SUPER SLOTS
	JRST	NOSCOW		;THIS IS A NO NO.
	PUSHJ	P,GETATB	;GET ATB ADDRESS IN T1
	SKIPGE	ATBSTS(T1)	;SKIP IF A FILE PAGE
	JUMPGE	P3,USRRD0	;JUMP IF UNSHARED PRIVATE. JUST MAKE READ/WRITE

	PUSHJ	P,STOLMA	;SAVE SLOT CONTENTS IN UPT
	PUSH	P,W		;SAVE VP NUMBER
	PUSH	P,F		;SAVE FAULT WORD
	PUSH	P,M		;AND ADDRESS
	MOVE	J,%UPT+UPTJOB	;GET OWN CTX PAGES IN %UPX FOR KERNEL ROUTINES
	PUSHJ	P,WLKUPX
	  STOPCD		;SHOULD ALWAYS BE ABLE TO GET OUR OWN.
	MOVE	T1,[<CPRRED>B7!1B17!%COW.N+CNVVPN] ;ARG FOR REPLICATE
	MOVE	T2,W		;PAGE TO BE THE SOURCE
	PUSHJ	P,KREPLC	;MAP SAME PAGE IN %COW
	  STOPCD		;COULDN'T FOR SOME REASON
	MOVE	T1,-2(P)		;GET VP NUMBER AGAIN
	HRLI	T1,(1B17)	;COUNT OF 1
	PUSHJ	P,KCLEAR	;REMOVE IT
	  STOPCD		;SHOULD HAVE BEEN THERE
	MOVE	T1,-2(P)		;GET USER'S VP NUMBER AGAIN
	HRLI	T1,<<CPRRDW>B7!1B17>_-^D18 ;NOW CREATE A NEW ONE THERE
	PUSHJ	P,KCREAT	;MAKE
	  JRST	NOCREA		;MAYBE DISK IS FULL . . .
	PUSH	P,%UPLMA+%COW.N+CNVVPN ;SAVE LMPNER FOR OLD PAGE.
	MOVSI	T2,LMPNER
	IORM	T2,%UPLMA+%COW.N+CNVVPN ;IGNORE ERRORS WHEN WE FAULT
	HRRZ	T1,-3(P)	;GET VP NUMBER
	IORM	T2,%UPLMA(T1)	;ALSO IGNORE ERRORS IN USER'S NEW PAGE.
				;USER PAGE NUMBER ALREADY IN T1
	CAIGE	T1,1000		;IF THIS IS A USER PAGE,
	JRSTF	@[PC.UIO,,.+2]	;MAKE SURE WE REFERENCE USER SPACE.
	SUBI	T1,CNVVPN	;EXEC SPACE, CONVERT TO REAL PAGE NUMBER.
	LSH	T1,^D9		;ADDRESS TO BLT TO
	HRLI	T1,%COW		;ADDRESS TO BLT FROM (OLD PAGE)
	MOVE	T2,T1		;GET COPY OF DESTINATION START
	TRNN	T1,-1		;IF ITS PAGE 0,
	ADD	T1,[20,,20]	;DON'T SMASH REAL ACS WITH SHADOW ACS.
	XCTTU	<BLT T1,777(T2)> ;DO WHOLE PAGE (WILL FAULT)
	MOVSI	T1,LMMERR	;GET ERROR MASK
	MOVSI	T2,LMPNER	;AND IGNORE ERROR BIT
	TDNE	T1,%UPLMA+%COW.N+CNVVPN
				;ANY ERRORS HAPPEN ON %COW?
				; (IGNORE THOSE ON USER PGE, HE'LL SEE THEM LATER)
	TDNE	T2,(P)		;YES, IGNORING?
	JRST	USRCO1		;NO ERRORS OR IGNORING.
	PUSHJ	P,SWEDR0	;UH-OH. MAKE SURE WE CAN STOP
	  JRST	COWERR		;CAN. UNDO THIS MESS AND RETURN.
USRCO1:	MOVE	T1,[1B17!%COW.N+CNVVPN] ;REMOVE %COW NOW
	PUSHJ	P,KCLEAR	;TAKE IT AWAY
	  STOPCD		;COULDN'T!
	PUSHJ	P,ULDUPX	;UNLOCKDOWN AND RELEASE UPX.
	POP	P,T1		;GET ORIGINAL LMPNER SETTING BACK
	POP	P,M
	POP	P,F
	POP	P,W		;RESTORE VIRTUAL PAGE
	MOVSI	T2,LMPNER	;GET READY TO SET IT
	TLNN	T1,LMPNER	;WAS IT ON?
	ANDCAM	T2,%UPLMA(W)	;NO, ITS ALWAYS ON HERE, JUST TURN IT OFF.
	MOVSI	T2,LMMERR	;CHECK FOR ERRORS
	TDNN	T2,%UPLMA(W)	;ANY? IF NOT, JUST
	JRST	FLTGR1		; RETURN, DON'T CALL STOLMA.
	PUSHJ	P,GETLMA	;AN ERROR HAPPENED,
	TRZ	P4,PGE.A!PGE.P	;FORCE FAULT ON NEW COW PAGE.
	JRST	FLTGRF		;STORE SLOT AND REFAULT.
;HERE WHEN TRYING TO WRITE INTO A SUPER COW PAGE.

NOSCOW:	SOSGE	%UPT+UPTLDC	;THROW AWAY LMAP SLOT
	STOPCD
	PGFERR(CWS)

;HERE IF WE GET I/O ERROR DURING COW PAGE PROCESSING.
;(P) IS USER'S ORIGINAL LMPNER SETTING, -3(P) IS VP NUMBER.

COWERR:	PUSH	P,%UPLMA+%COW.N+CNVVPN ;SAVE ERROR BITS
	MOVSI	T1,(1B17)	;COUNT OF 1
	HRR	T1,-4(P)	;GET VP NUMBER
	PUSHJ	P,KCLEAR	;GET RID OF PRIVATE USER PAGE.
	  STOPCD		;SHOULD HAVE WORKED.
	MOVSI	T1,<<CPRCOW>B7!1B17>_-^D18
	HRR	T1,-4(P)	;GET READY TO REPLICATE
	MOVEI	T2,%COW.N+CNVVPN ;THE ORIGINAL USER PAGE
	PUSHJ	P,KREPLC
	  STOPCD		;WE ARE INTOLERANT HERE.
	MOVE	T1,[1B17!%COW.N+CNVVPN]
	PUSHJ	P,KCLEAR	;GOODBYE COW
	  STOPCD		;GOODBYE SYSTEM
	PUSHJ	P,ULDUPX	;RELEASE UPX LOCK NOW.
	POP	P,T1		;GET ERROR BITS
	AND	T1,[<LMMERR>B17]
	POP	P,T2		;LMPNER SETTING
	POP	P,M
	POP	P,F		;ADDRESS AND FAULT WORD OFF STACK.
	POP	P,W		;AND VP NUMBER
	IOR	T1,%UPLMA(W)	;SET ERROR BITS IN SLOT.
	TLZ	T1,LMPNER	;IF THIS WASN'T OFF, WE WOULDN'T BE HERE
	MOVEM	T1,%UPLMA(W)	;NEW SLOT CONTENTS.
	JRST	FLTGR1		;AND GO REDO THE FAULT. THIS TIME,
				; ERROR BITS ARE SET IN USERS PAGE,
				; SO HE'LL GET I/O ERROR MESSAGE.

;HERE ON VCREAT ERROR RETURN DURING COW PROCESSING
; USER'S VP NUMBER IS IN -2(P).

NOCREA:	HRRZS	T1
	CAIE	T1,CRDFL%	;DISK FULL?
	STOPCD			;NO, STOP
	SKIPN	JBTABT(J)	;IF INSIDE BAD PLACE,
	PUSHJ	P,DRSCHK	;WE SHOULD HAVE WRITTEN FIRST.
	JRST	.+2
	STOPCD			;OR ELSE THIS WILL HAPPEN.
	MOVSI	T1,<<CPRCOW>B7!1B17>_-^D18
	HRR	T1,-2(P)	;GET DESTINATION VP (USER'S)
	MOVEI	T2,%COW.N+CNVVPN	;WHERE HIS ORIGINAL DP IS.
	PUSHJ	P,KREPLC
	  STOPCD		;CAN'T GET BACK
	MOVE	T1,[1B17!%COW.N+CNVVPN]
	PUSHJ	P,KCLEAR	;GET RID OF %COW
	  STOPCD
	PUSHJ	P,ULDUPX	;RELEASE UPX LOCK.
	POP	P,M		;GET ADDRESS AD
	POP	P,F		;SOFTWARE FAULT WORD OFF STACK.
	POP	P,W		;GET VP OFF STACK
	PGFERR(DFC)		;GIVE DISK FULL ERROR RETURN.
COMMENT;@@SUBROUTINE SWEDRS/SWEDR0
@@PURPOSE TELL WHEN TO IGNORE I/O ERRORS. IF GET AN I/O ERROR
DURING LOOKUP, RENAME, AND ENTER, JBTABT IS NOT SETUP,
SO IF WE GIVE PAGE FAIL ERROR AND STOP JOB, IT STILL HAS
RIB. ASSUMPTION IS THAT IT IS TOO DIFFICULT
TO BACK OUT OF THESE UUOS. SO WE IGNORE THE ERROR
FOR NOW AND SET A UPTSTS BIT AND UTRP, SO JOB GETS
STOPPED BEFORE RETURNING TO USER IN USRXIT. UUO COULD
DO SOMETHING USER DIDN'T WANT IT TO IN THIS CASE-
POTENTIAL SECURITY PROBLEM.
@@ENTRY ENTER AT SWEDRS IF HAVE LMAP SLOT, SWEDR0 IF NOT.
J HAS JOB NUMBER.
@@ACCUM USES T1
@@EXIT NON-SKIP IF OK TO GIVE ERROR, SKIP IF NOT OK
@@RESTRICTIONS CALLED ONLY IN CONTEXT OF JOB IN (J)
@@FUNCTION IF JBTABT NOT SETUP AND JOB HAS DISK RESOURCE,
SET UPSSWE AND UTRP, GIVE SKIP RETURN, ELSE
STORE LMAP SLOT BACK AND GIVE NON-SKIP RETURN.
@@;

EXTERN JBTABT,DRSCHK,UPSSWE,UPTSTS,JBTSTS

SWEDRS:	PUSHJ	P,SWEDR0	;DO THE WORK
	  PJRST	STOLMA		;AND STORE SLOT SO CAN GO TO FLTBRF
	JRST	CPOPJ1		;GIVE SKIP RETURN LIKE SWEDR0 DID.

SWEDR0:	SKIPN	JBTABT(J)
	PUSHJ	P,DRSCHK	;
	  POPJ	P,		;CAN FAIL.
	MOVSI	T1,UPSSWE	;HAVE TO IGNORE NOW, BOMB LATER.
	IORM	T1,%UPT+UPTSTS
	MOVEI	T1,UTRP
	IORM	T1,JBTSTS(J)	;SO USRXIT WILL SEE UPSSWE
	JRST	CPOPJ1		;GIVE SKIP RETURN, BETTER CONTINUE.
FLTGRF:	PUSHJ	P,STOLMA	;RETURN SLOT DATA TO SLOT
FLTGR1:
FLTGR2:	LSTCHK
	POP	P,T2		;GET CLOCK STATE OFF STACK
	TRNE	T2,CHGON	;IS CLOCK TO BE BACK ON
	CHARGE		;YES, TURN IT BACK ON.
	POP	P,T2		;IN CASE SOMEONE TOUCHED PC.UIO
	JRSTF	@T2		;RETURN TO CALLER

FLTBRF:	AOS	-1(P)		;GIVE ERROR RETURN
	JRST	FLTGR1		;AND RETURN

;HERE ON ADDRESS BREAK AND OTHER 20+X FAULTS

SPCFLT:	LDB	T1,[POINT 5,F,23]	;GET CODE
	CAIE	T1,PF.ABK	;ADDRESS BREAK
	PGFERR(HPF)		;NO, HARDWARE FAILURE, ETC.
	PGFERR(ABK)		;YES, ADDRESS BREAK RETURN.

;HERE IF CAN'T ACTIVATE SLOT AT PAGE FAULT LEVEL. MUST
; WAIT FOR SWAPPER TO ACTIVATE IT, AND THEN CONTINUE WITH
; THE REST OF PAGE FAULT.

SWPWAT:	PUSHJ	P,STOLMA	;SAVE SLOT CONTENTS
	MOVSI	T1,MRQ		;SET SWAPPER ATTENTION BIT
	IORM	T1,JBTSTS(J)
	AOS	PFWCNT		;COUNT OF TIMES HAD TO CALL SWAPPER.
	SETOM	CALSWP		;TELL SCHEDULER TO CALL SWAPPER.
	PUSHJ	P,WSCHED	;GO WAIT FOR SWAPPER TO DO US
	PJRST	GETLMA		;AND SETUP SLOT CONTENTS AGAIN

;HERE FROM BEGINNING OF PAGFLT IF FAULT WAS TO EXEC SPACE.
; SEE IF LEGAL. IF LEGAL, SEE IF PCBS. IF NOT, ADJUST THE VP
; NUMBER FROM 340+X TO 1000+X

EXCFLT:	ADDI	W,CNVVPN	;YES, ADJUST VP NUMBER
	CAIG	W,VPUMAX	;JUST EXEC PER PROCESS NORMAL SLOT?
	JRST	USRFLT		;AND GO REJOIN

EXCFL1:	CAIG	W,1037		;IF EXEC EPT PAGE OR
	CAIG	W,VPMAX		;CONTEXT PAGE
	PGFERR(BER)		;THEN ITS BAD, GO CRASH.
	MOVE	PG,[%RB2.C
		    %RIB.C
		    %SAT.C]-<%RB2.N+CNVVPN>(W) ;OTHERWISE, ITS A PCB.
;	JRST	PCBFLT		;GO DO PCB STUFF.
;HERE ON PCB PAGE FAULTS.

EXTERN PPCBIO,PCBPAG
EXTERN STACML,STAWLN,STAWTL,STAWTU,STDPRE,STDREA,STDWAG,STDWRT
EXTERN WAIT1,%CTBYP,%CTSTS,%SAT.C,%RIB.C,%RB2.C,%CTUPT
EXTERN DSKPIN,DSKPIF,PCISTS,PGYERR

DEFINE DSKOFF <WRPI DSKPIF>
DEFINE DSKON <WRPI DSKPIN>

;HERE WITH CONTROL BLOCK ADDRESS IN PG AND JOB NUMBER IN J.
; SOFT PAGE FAIL WORD IN F.
;DESTROYS T1-T4.

    ;SET UP T2/ PCB ADDRESS AND T3/ REQUEST STATUS.
PCBFLT:	PUSH	P,P1		;SAVE P1.
	HRRZ	T1,J
	LDB	T3,%CTSTS(PG)	;REQUEST STATUS.
	SKIPN	T2,@%CTUPT(PG)	;T2/ PCB ADDRESS.
	STOPCD

    ;IF FAULT TO WRITE, CHECK USER ASKED PERMISSION.
	TRNN	F,SPFW.T	;FAULT TO WRITE?
	JRST	PCBFL4		;NO.
	CAIE	T3,STAWTU	;YES.  IS
	CAIN	T3,STAWTL	;IT
	JRST	PCBFL4		;OKAY
	CAIE	T3,STACML	;TO
	CAIN	T3,STAWLN	;WRITE?
	JRST	PCBFL4		;YES, IF WTU/WTL/CML/ OR WLN.
	STOPCD			;NO.

    ;BRANCH ON DATA PRESENT.
PCBFL4:	DSKOFF
	LDB	T1,PCISTS	;T1/ PCB STATUS.
	LDB	P1,%CTBYP(PG)	;P1/ MAP SLOT CONTENTS.
	TRNN	T1,STDPRE	;IS DATA PRESENT?
	JRST	PCBFL6		;NO.
	DSKON

      ;HERE ON DATA PRESENT.
PCBFL5:	TRO	P1,PGE.A	;SET THE SLOT ACCESSIBLE.
	TRNN	F,SPFW.T	;WAS IT A FAULT TO WRITE?
	JRST	PCBFDN		;NO.
	TRO	P1,PGE.W	;YES, ALSO SET SLOT WRITEABLE.
PCBFD0:	MOVEI	T4,1		;SET
	PUSH	P,PG		;THE
	HLRZ	PG,PCBPAG(T2)	;PAGE
	DPB	T4,PGYDRT	;TO
	POP	P,PG		;DIRTY.  (DATA MODIFIED.).
PCBFDN:	DPB	P1,%CTBYP(PG)	;
	POP	P,P1		;
	CLRPTW			;CLEAR PAGE TABLE ENTRY FOR THIS PAGE.
	PJRST	FLTGR1		;GO RESTORE CLOCK, CLEAR PAGING MEMORY FOR THIS PAGE AND DISMISS
    ;HERE ON DATA NOT PRESENT.
PCBFL6:	CAIE	T3,STAWLN	;IS THIS WRITE LOCK NEW?
	JRST	PCBFL7		;NO.
	TRNN	T1,STDWRT!STDWAG!STDREA ;YES. NEED TO WAIT FOR IO?
	JRST	[TRO T1,STDPRE	;NO.
		DPB T1,PCISTS
		PUSH P,PG	;CLEAR PGYERR.
		HLRZ PG,PCBPAG(T2) ;
		SETZ T3,	;
		DPB T3,PGYERR	;
		POP P,PG	;
		DSKON
		JRST PCBFL9]	;SET SLOT AND DATA PRESENT.
	MOVE	P1,T1		;NEED TO WAIT FOR IO.
	JRST	PCBFL8		;

    ;HERE TO REQUEST THE PAGE CONTENTS.
PCBFL7:	MOVE	P1,T1		;SAVE THE OLD PCB STATUS.
	TRO	T1,STDREA	;SET DATA
	DPB	T1,PCISTS	;READ IN THE PCB.
       ;POSSIBLY REQUEST THAT THE PAGE BE READ IN.
PCBFL8:	PUSH	P,T3		;SAVE T3 FROM PPCBIO AND PAGWAT.
	TRNE	P1,STDREA!STDWRT!STDWAG ;IO IN PROG FOR THIS PCB?
	JRST	PCBF85		;YES, NO NEED TO START IT.
	SETZ	T4,		;FLAG READ.
	PUSH	P,PG		;CLEAR PGYERR.
	HLRZ	PG,PCBPAG(T2)	;
	DPB	T4,PGYERR	;
	POP	P,PG		;
	PUSHJ	P,PPCBIO	;REQ THE READ. (EXPECTS T2&T4).
PCBF85:	DSKON
	PUSH	P,T2		;
	PUSH	P,PG		;WAIT FOR
	HLRZ	PG,PCBPAG(T2)	;FINPCB TO
	PUSHJ	P,PAGWAT	;WAKE US UP.
	POP	P,PG		;
	POP	P,T2		;RESTORE PCB ADDRESS.
	POP	P,T3		;RESTORE STATUS.
	LDB	P1,%CTBYP(PG)	;RESTORE THE MAP SLOT.
	CAIE	T3,STAWLN	;
	JRST	PCBFL5		;GO PROCESS DATA PRESENT.
	DSKOFF
	LDB	T1,PCISTS	;
	IORI	T1,STDPRE	;
	DPB	T1,PCISTS	;
	DSKON
PCBFL9:	TRO	P1,PGE.A!PGE.W	;
	JRST	PCBFD0		;
COMMENT ;@@SUBROUTINE TSTVIR
@@PURPOSE CHECK TO SEE IF A VIRTUAL PAGE IS VIRGIN. UPDATE
LMPVIR BIT. IF A PRIVATE PAGE IS VIRGIN, IT MEANS THAT
THE FIRST PERSON TO REFERENCE IT WILL CONNECT A PAGE OF
ZEROES TO THE DP. IF A FILE PAGE IS VIRGIN, IT MEANS TO
TRY TO START THE FILE PAGE DATA INTO CORE WITHOUT
CALLING THE SWAPPER.
@@ENTRY P3,P4 HAVE LMAP DATA.
@@ACCUM USES T1-T4.
@@EXIT RETURNS P3, P4 UPDATED (LMPVIR UPDATED.)
NON-SKIP IF PAGE IS NOT VIRGIN. SKIP RETURN IF PAGE IS VIRGIN,
WITH C(T1) NEGATIVE IS VP IS A FILE PGE OR SUPER PAGE, POSITIVE IF
VP IS PRIVATE.
@@FUNCTION GIVE NON-SKIP RETURN IF LMPVIR IS OFF.
ELSE GET ATB FOR VP, SKIP RETURN T1 NEGATIVE IF VP IS A FILE
PAGE. ELSE IF VP IS PRIVATE UNSHARED, GIVE SKIP
RETURN WITH C(T1) POSITIVE. ELSE GET SPT ENTRY ADDRESS FROM GETSPT,
AND IF SPT VIRGIN BIT IS ON IN SPT ENTRY, GIVE SKIP RETURN
WITH C(T1) POSITIVE (SPT ENTRY ADDRESS). IF SPT VIRGIN BIT
IN SPT IS OFF, CLEAR LMPVIR IN P3 AND GIVE NON-SKIP RETURN.
@@;

TSTVIR::TLNN	P3,LMPVIR	;ANY POSSIBILITY OF BEING VIRGIN?
	POPJ	P,		;NO, JUST NON-SKIP RETURN.
	TLNE	P3,LMPSUP	;IF ITS A SUPER SLOT,
	JRST	[SETO T1,	;RETURN T1 NEGATIVE, ITS LIKE A FILE PAGE
		 JRST CPOPJ1]	;ITS VIRGIN, TOO.
	PUSHJ	P,GETATB	;GET ATB ADDRESS IN T1
	SETCM	T1,ATBSTS(T1)	;ATPDUM MUST BE 1B0! T1 -VE IF FILE PAGE
	JUMPL	T1,CPOPJ1	;IF ITS VIRGIN FILE PAGE, WE'RE DONE.
	JUMPGE	P3,CPOPJ1	;IF UNSHARED PRIVATE PAGE, DONE.
	PUSHJ	P,GETSPT	;SHARED PRIVATE. GET SPT ENTRY
	SKIPL	SPTVIR(T1)	;VIRGIN BIT ON? (MUST BE 1B0)
	TLZA	P3,LMPVIR	;NO, CLEAR LMPVIR AND GIVE NON-SKIP
	AOS	(P)		;YES, GIVE SKIP RETURN, T1 IS POSITIVE.
	POPJ	P,		;ADIOS, AMIGOS.
SUBTTL USER WORKING SET PAGE REPLACEMENT

COMMENT ;@@SUBROUTINE UWSRPL
@@PURPOSE FIND A PAGE IN THE UWS TO GET RID OF WHEN
USER PAGE FAULTS FOR A PAGE NOT IN HIS UWS AND UWS SIZE
= UWS LIMIT.
@@ENTRY J HAS JOB NUMBER, %UPT+UPTRPT CONTAINS CURRENT REPLACEMENT
POINTER. PAGE WE ARE REPLACING FOR MUST NOT ALREADY BE IN UWS,
ELSE IT MAY GET TAKEN OUT.
@@ACCUM USES T1-T4, P3,P4. PRESERVES J AND W.
@@TABLES UWS TABLE
@@EXIT J AND W SETUP AS CALLED.
%UPT+UPTRPT HAS NEW REPLACEMENT POINTER. UWS SIZE GUARANTEED
TO BE UNDER LIMIT.  CALLER MUST CLEAR THE ASSOCIATIVE MEMORY.
@@FUNCTION
	LASTPAGE := (UPT.RPT + 1) MOD 777
AGAIN:	DEJAVU := -1
	MAXAGE := -1
	OLDPAGE := -1
	PRESTEP P := FIRST PAGE IN UWS >= LASTPAGE
		IF NO SUCH P
			LASTPAGE := 0
			CONTINUE
		IF DEJAVU = -1
			DEJAVU := P
		ELSEIF P = DEJAVU
			BREAK
		IF P.AGE > MAXAGE
			MAXAGE := P.AGE
			OLDPAGE := P
	REMOVE OLDPAGE FROM UWS
	IF UWS SIZE >= UWS LIMIT
		GOTO AGAIN
	UPT.RPT := OLDPAGE
@@;

UWSRPL:	JSP	T4, SAVE2	;SAVE P1 AND P2
	JSP	T4, SAVFMU	;AND F AND M AND U
	PUSH	P, W		;AND W
	PUSH	P, S		;AND S

	LDB	T4, JBYUWS
	LDB	T1, UPYUWL
	SUBI	T4, -1(T1)
	PUSHJ	P, CHGUPA	;CHARGE FOR THE REPLACEMENTS

UWSRP1:	SETOB	P1, P2		;P1/ OLDEST PAGE SEEN, P2/ DEJAVU PAGE
	SETO	S,		;S/ AGE OF OLDEST PAGE SEEN
	AOS	W, %UPT+UPTRPT	;W/ NEXT PAGE TO TRY BUMPING
	ANDI	W, 777		;(MOD 777)
UWSRP2:	JSP	F, NXTUWS	;F/ NEXT UWS PAGE
	JRST	[		;IF NONE,
		SETZ	W,
		JRST	UWSRP2	; RETRY FROM PAGE 0
	]

    ;HERE WITH W/ A UWS PAGE

	JUMPGE	P2, UWSRP3	;IF THIS IS THE FIRST PAGE SEEN,
	HRRZ	P2, W		;  REMEMBER THE PAGE NUMBER
	JRST	UWSRP4
UWSRP3:	CAIN	P2, 0(W)	;ELSEIF WE'VE BEEN HERE BEFORE,
	JRST	UWSRP5		;  THE SEARCH IS DONE

UWSRP4:	HRRZ	T1, W
	IDIVI	T1, AGECPW	;T1/ AGE CELL WORD, T2/ CELL # IN WORD
	LDB	T2, AGEPTR(T2)	;T2/ AGE OF PAGE W
	CAMG	T2, S		;IF AGE <= MAXAGE,
	JRST	(M)		;  GO TRY ANOTHER PAGE
	JSP	T3,REPOK	;SEE IF PAGE IS BUMPABLE
	MOVEM	T2, S		;S/ MAXIMUM AGE SEEN SO FAR
	HRRZM	W, P1		;P1/ OLDEST PAGE SEEN SO FAR
	JRST	(M)		;GO LOOK FOR AN OLDER ONE

    ;HERE WITH P1/ THE OLDEST PAGE'S PAGE NUMBER

UWSRP5:	MOVEM	W, %UPT+UPTRPT	;UPDATE POINTER
	JSP	F, FINXWS	;UNDO NXTUWS'S DAMAGE
	SKIPGE	W, P1		;W/ OLDEST PAGE
	  STOPCD
	PUSHJ	P, GETLMA	;GET PAGE W'S SLOT
	PUSHJ	P, REMUWS	;REMOVE PAGE P FROM UWS
	PUSHJ	P, STOLMA
	LDB	T1, JBYUWS	;T1/ UWS SIZE
	LDB	T2, UPYUWL	;T2/ UWS LIMIT
	CAML	T1, T2		;IF SIZE >= LIMIT
	JRST	UWSRP1		;  GO BUMP ANOTHER PAGE

	POP	P, S
	POP	P, W		;RESTORE S AND W
	POPJ	P,		;AND P1-P2 AND F AND M AND U
SUBTTL REMOVE FROM UWS

COMMENT ;@@SUBROUTINE REMUWS
@@PURPOSE TAKE VP OUT OF UWS, GIVE MWS HANDLERS A CHANCE TO
TAKE IT OUT OF MWS IF THEY WANT TO. CALLED BY USER WORKING SET
PAGE REPLACEMENT, REMOVE FROM UWS UUO.
@@ENTRY P3, P4 CONTAIN LMAP SLOT DATA, W CONTAINS VP NUMBER
@@ACCUM PRESERVES P1-P4, USES T1-T4.
@@EXIT P3 AND P4 HAVE NEW LMAP SLOT DATA. CALLER MUST STORE
THEM BACK. PAGE IS OUT OF UWS, MAY OR MAY NOT BE IN MWS. ACCESS
BIT IS CLEARED. CALLER RESPONSIBLE FOR CLEARING A.M.
@@RESTRICTIONS
@@FUNCTION CLEAR UWS BIT FOR PAGE, DECREMENT UWS SIZE.
TURN OFF ACCESS BIT. CALL CRMMWS TO GIVE MWS HANDLERS A CHANCE
TO REMOVE IT FROM MWS IF THEY DESIRE TO DO SO.
@@;

REMUWS::PUSHJ	P,TSTUWS	;IS IT IN UWS?
	  POPJ	P,		;NO, NOTHING TO DO.
	PUSHJ	P,CLRUWS	;CLEAR UWS BIT IN TABLE, DECRMENT SIZE
	TRZ	P4,PGE.A	;CLEAR ACCESS BIT IN UPT
	PJRST	CRMMWS		;AND TAKE OUT OF MWS POSSIBLY.

;RMXUWS IS THE SAME AS REMUWS EXCEPT IT OPERATES IN %UPX, AND DOESN'T
; CALL CONDITIONAL REMOVE FROM MWS ROUTINE.

RMXUWS::PUSHJ	P,TSXUWS	;IS IT IN UWS?
	  POPJ	P,		;NO, NOTHING TO DO
	PUSHJ	P,CLXUWS	;TURN OFF UWS BIT
	TRZ	P4,PGE.A	;MAKE SURE ACCESS BIT TURNED OFF
	POPJ	P,		;LET CALLER DO SOMETHING ABOUT MWS
SUBTTL MWS HANDLING

COMMENT ;@@SUBROUTINE FLTMWS
@@PURPOSE PUT A PAGE IN THE MWS FOR SURE, ACTIVATE THE PAGE,
AND MAKE SURE SWAP IN IS NOT IN PROGRESS, I.E. MAKE PAGE
READY TO BE REFERENCED BY THE USER. CALLED FROM PAGE FAULT
CODE. SKIP-RETURNS IF IT SUCCEEDED, NONSKIP-RETURNS IF MWSRPL
COULDN'T MAKE ROOM FOR THE PAGE (AND WE NEEDED ROOM).
@@ENTRY J,W,P3,P4 SETUP FOR SLOT TO BE PUT INTO MWS.
@ACCUM PRESERVES P1-P2. USES T ACS.
@@EXIT P3,P4 CONTAIN UPDATED LMAP SLOT DATA.
DOES NOT AFFECT THE ACCESS BIT IN UPT, CALLER MUST SET IT IF
DESIRED.
CALLER MUST CLEAR THE A.M.
@@RESTRICTIONS ONLY CALLED FROM UUO LEVEL FOR CURRENT JOB
WHEN %UPT IS ADDRESSABLE SO STOLMA AND GETLMA CAN BE
CALLED.
@@FUNCTION IF PAGE IS IN MWS ALREADY, TO SEE IF ITS ACTIVE
IF PAGE IS NOT IN MWS AND MWS SIZE IS UP TO MWS LIMIT
(MWSLIM)
THEN DO MWS PAGE REPLACEMENT ALGORITHM. INSERT NEW PAGE
IN MWS BIT TABLE, INCREMENT MWS SIZE. IF PAGE IS NOT ACTIVE,
TRY TO ACTIVATE IT. IF CANNOT, CALL SWAPPER, AND ON RETURN,
CHECK TO SEE IF ITS ACTIVE AGAIN. IF ITS ACTIVE, MAKE
SURE SWAP IN IS NOT IN PROGRESS (USER NOT ALLOWED TO TOUCH
PAGE IF SO).
IF MWSRPL CAN'T MAKE ROOM NONSKIP-RETURN OTHERWISE SKIP-RETURN.
@@;

FLTMWS:	PUSHJ	P,TSTMWS	;IN MWS ALREADY?
	  JRST	.+2
	JRST	FLTMW4		;YES, GO SEE IF ITS ACTIVE
	CAILE	W, 777		;IS IT A USER PAGE?
	JRST	FLTMW3		;NO -- ALWAYS ADD IT
	AOS	JBTAJF(J)	;BUMP MWS-FAULT COUNT
	MOVE	T1, JBTSTS(J)
	TRNN	T1, JWSADJ	;IF MWS ADJUST IN EFFECT
	JRST	FLTMW1
	SKIPE	%UPT+UPTMAT	;AND THERE'RE REPLACEABLE PAGES,
	JRST	FLTMW2		;  THROW THEM OUT
FLTMW1:	LDB	T1, JBYMWS	;T1/ # MWS PAGES
	MOVE	T2, MWSLIM
	CAIGE	T1, -NCTXPG(T2)	;IF OVER GLOBAL MWS LIMIT
	JRST	FLTMW3
FLTMW2:	PUSHJ	P,MWSRPL	;THROW PAGES OUT TO MAKE ROOM
	  POPJ	P,		;CAN'T MAKE ROOM
FLTMW3:	PUSHJ	P,SETMWS	;SET THE MWS BIT, INCREMENT SIZE
FLTMW4:	AOS	(P)		;PREPARE FOR SUCCESS-RETURN

FLTMW5:	TLNE	P3,LMPACT	;ACTIVE?
	JRST	FLTMW6		;YES, MAKE SURE NO SWAP INS.
	AOS	PFICNT		;TIMES FAULTED FOR INACTIVE PGE
	PUSHJ	P,ACTLMA	;NO, TRY TO ACTIVATE.
	  JRST	[PUSHJ P,SWPWAT	;WASN'T IN CORE, MAKE SWAPPER WORK
		 JRST FLTMW5]	;AND MAKE SURE ITS STILL THERE
FLTMW6:	PUSHJ	P,GETCPA	;GET CORE PAGE ADDRESS FROM LMAP SLOT
	LDB	T1,PGYSIP	;GET SWAP IN IN PROGRESS BIT
	JUMPE	T1,CPOPJ	;READY TO GO IF NO SWAP IN
	PUSHJ	P,STOLMA	;STORE IN CASE IT CHANGES
	PUSHJ	P,PAGWAT	;GO WAIT FOR SWAP IN TO STOP
	PUSHJ	P,GETLMA	;GET LMAP SLOT AGAIN
	JRST	FLTMW5		;AND MAKE SURE ITS STILL AROUND BEFORE
				;CHECKING PGYSIP AGAIN.
COMMENT ;@@SUBROUTINE PRFMWS
@@PURPOSE PUT A PAGE IN THE MWS FOR SURE, TRY TO ACTIVATE PAGE,
IF CAN'T JUST GIVE UP. CALLED FROM PREREFERENCE.
@@ENTRY J,W,P3,P4 SETUP FOR SLOT TO BE PUT INTO MWS
@@ACCUM PRESERVES P1-P2. USES T ACS
@@EXIT P3,P4 CONTAIN UPDATED LMAP SLOT DATA, CALLER MUST
CLEAR THE A.M. ACCESS BIT MAY BE CHANGED.
@@FUNCTION IF PAGE IS ALREADY IN MWS, GO SEE IF ITS ACTIVE, AND
IF NOT, TRY TO ACTIVATE IT. GIVE UP IF NOT IN CORE. IF
PAGE IS NOT IN MWS, PUT INTO MWS, REPLACING A  MWS PAGE
IF NECESSARY, AND TO THE ABOVE.
@@;

PRFMWS:	PUSHJ	P,TSTMWS	;IN MWS YET
	  JRST	CINMW1		;NOT YET, PUT IT THERE.
	JRST	CINMW5		;YES, TRY TO ACTIVATE IT.
COMMENT ;@@SUBROUTINE CINMWS, CINMW1, CINMW5
@@PURPOSE GIVE PAGE A CHANCE TO GET INTO THE MWS, MAY OR MAY
NOT GET INTO MWS. CALLED FROM INSERT IN UWS UUO
@@ENTRY P3,P4 CONTAIN LMAP DATA, J,W SETUP TO JOB AND VP.
@@ACCUM PRESERVES P1,P2. USES T1-T4, CHANGES P3,P4
@@EXIT CALLER MUST CLEAR A.M. P3 AND P4 CONTAIN NEW LMAP SLOT
DATA.
@@FUNCTION IF NOT IN MWS ALREADY, DECIDE WHETHER OR NOT
TO PUT IT INTO THE MWS. IF DECIDE NOT TO, JUST RETURN.
NEXT CHECK IF PAGE IS ACTIVE. IF NOT, TRY TO ACTIVATE IT.
IF CANNOT, JUST RETURN. IF PAGE IS ACTIVE, AND NO SWAP IN
IN PROGRESS, IS IN UWS, REF BIT IS ON AND ERROR BIT AND VIRGIN
BIT ARE OFF, SET ACCESS AND PUBLIC IN UPT WORD IN P4.
@@;

CINMWS:	PUSHJ	P,TSTMWS	;IN ALREADY?
	  JRST	.+2		;NO, SEE IF IT SHOULD GO IN
	JRST	CINMW5		;IN ALREADY, SEE IF ITS ACTIVE

;HERE IF NOT IN MWS YET. MAYBE IT WILL GO IN, MAYBE NOT.

;	JFCL			;CALL ROUTINE TO SEE IF IT SHOULD GO IN
;	  POPJ	P,		;NO, JUST RETURN.

CINMW1:	CAILE	W, 777		;IS IT A USER PAGE?
	JRST	CINMW4		;NO -- ALWAYS PUT IT IN
	MOVE	T1, JBTSTS(J)
	TRNN	T1, JWSADJ	;IF MWS IS IN EFFECT
	JRST	CINMW2
	SKIPE	%UPT+UPTMAT	;AND THERE'RE REPLACEABLE PAGES,
	JRST	CINMW3		;  THROW THEM OUT
CINMW2:	LDB	T1, JBYMWS	;T1/ # MWS PAGES
	MOVE	T2, MWSLIM
	CAIGE	T1, -NCTXPG(T2)	;IF SIZE >= LIMIT
	JRST	CINMW4
CINMW3:	PUSHJ	P, MWSRPL	;THROW PAGES OUT TO MAKE ROOM
	  POPJ	P,		;CAN'T MAKE ROOM
CINMW4:	PUSHJ	P,SETMWS	;SET THE MWS BIT AND INCREMENT SIZE

;HERE IF PAGE IS IN MWS. SEE IF ITS ACTIVE

CINMW5:	TLNE	P3,LMPACT	;IS IT ACTIVE?
	JRST	CINMW6		;YES, GO SEE IF CAN SET THE ACCESS BIT
	PUSHJ	P,ACTLMA	;TRY TO ACTIVATE IT
	  POPJ	P,		;CANNOT, FORGET THE A BIT.

;HERE TO TRY TO SET THE ACCESS BIT AND AVOID A FAULT

CINMW6:	PUSHJ	P,GETCPA	;GET CORE PAGE ADDRESS IN PG
	LDB	T1,PGYSIP	;IS SWAP IN IN PROGRESS?
	JUMPN	T1,CPOPJ	;FORGET IT IF SO
	PUSHJ	P,TSTUWS	;OK, IS IT IN UWS?
	  POPJ	P,		;NO, MAKE HIM FAULT
	SKIPN	OHTNUM		;ANYTHING IN OHT?
	JRST	CINMW7		;NO, CONTINUE
	PUSHJ	P,GETDPA	;SEARCH IT
	PUSHJ	P,SRCOHT	;IF ITS HAD AN OUTPUT ERROR,
	  JRST	CINMW7		;NO
	POPJ	P,		;THEN DON'T SET "A" BIT, FORCE FAULT.
CINMW7:	TLNE	P3,LMPREF	;IS REF BIT ON AND
	TLNE	P3,LMMERR!LMPVIR	;ERROR AND VIRGIN OFF?
	POPJ	P,		;NOT READY TO TURN ACCESS BIT ON
	TRO	P4,PGE.A!PGE.P	;OK TO LET USER REFERENCE RIGHT AWAY.
	POPJ	P,		;RETURN.
COMMENT ;@@SUBROUTINE CRMMWS
@@PURPOSE CONDITIONALLY REMOVE PAGE FROM MWS. MAYBE WE'RE FEELING
GENEROUS AND WILL LEAVE IT IN ANYWAY. CALLED BY REMOVE FROM UWS
UUO.
@@ENTRY THE USUAL - P3,P4 CONTAIN LMAP SLOT DATA, J AND W
CONTAIN JOB AND VP NUMBER OF PAGE.
@@ACCUM USES T1-T4, PG, CHANGES P3,P4
@@EXIT CALLER SHOULD NOT RELY ON THIS ROUTINE TO CLEAR
THE ACCESS BIT, ALTHOUGH IT WILL IF THE PAGE IS
AACTUALLY REMOVED FROM THE MWS.
@@FUNCTION IF PAGE IS NOT IN MWS, JUST RETURN.
DECIDE WHETHER OR NOT TO TAKE THIS PAGE OUT OF MWS.
IF NOT, JUST RETURN. IF SO, GO DEACTIVATE SLOT AND
CLEAR MWS BIT FOR PAGE, DECREMENT MWS SIZE AND RETURN.
@@;

CRMMWS:	PUSHJ	P,TSTMWS	;IN MWS ALREADY?
	  POPJ	P,		;NO, DO NOTHING
;	JFCL			;TAKE OUT OF MWS?
;	  POPJ	P,		;NO, DON'T TAKE IT OUT.
	PJRST	REMMW1		;YES, TAKE IT OUT.
COMMENT ;@@SUBROUTINE REMMWS
@@PURPOSE MAKE SURE PAGE COMES OUT OF MWS. CALLED BY REMOVE,
MWS REPLACEMENT ALGORITHM
@@ENTRY P3, P4 CONTAIN LMAP SLOT DATA, J AND W CONTAIN
JOB AND VP NUMBER.
@@ACCUM DESTROYS PG, T1-T4. PRESERVES P1,P2. CHANGES P3,P4
@@EXIT DEACTIVATED SLOT DATA IN P3,P4. CALLER MUST STORE
SLOT DATA BACK INTO UPT, CLEAR THE A.M.
@@FUNCTION IF PAGE IS NOT IN MWS, JUST RETURN.
IF PAGE IS IN MWS, DEACTIVATE THE SLOT, CLEAR THE MWS BIT
AND DECREMENT THE MWS SIZE. CALL A ROUTINE TO SEE
IF MWS SHOULD HAVE ANOTHER PAGE ADDED TO REPLACE THE ONE JUST
TAKEN OUT, AND RETURN.
@@;

REMMWS::PUSHJ	P,TSTMWS	;IN MWS ALREADY?
	  POPJ	P,		;NOT THERE, DO NOTHING.

;HERE FROM CONDITIONAL REMOVE FROM MWS

REMMW1:	PUSHJ	P,DEALMA	;DEACTIVATE THE SLOT
	PUSHJ	P,CLRMWS	;TURN OFF MWS BIT AND DECREMENT SIZE
	PJRST	CPOPJ		;AND FINISH UP BY CALLING ROUTINE TO
				; POSSIBLY ADD ANOTHER PAGE TO MWS.

RMXMWS::PUSHJ	P,TSXMWS	;IN MWS ALREADY?
	  POPJ	P,		;NO, NOTHING TO DO
	PUSHJ	P,DEALMA	;CAN'T HAVE ACTIVE SLOT NOT IN MWS
	PUSHJ	P,CLXMWS	;TURN OFF MWS BIT, ADJUST COUNTS
	PJRST	CPOPJ		;AND POSSIBLY ADD ANOTHER PAGE TO MWS.
SUBTTL	MONITOR WORKING SET PAGE REPLACEMENT

;MWSREP FUNCTION CODES

.MRFNA==0	;PAGE FAULT, DON'T DO MWS ADJUSTMENT
.MRFDA==1	;PAGE FAULT, DO DO MWS ADJUSTMENT
.MRADJ==2	;DO MWS ADJUSTMENT

COMMENT #
@@SUBROUTINE MWSRPL
@@PURPOSE CALLED WHEN A PAGE WANTS OR NEEDS TO GET INTO THE MWS
AND EITHER (1) MWS SIZE >= MWSLIM (THERE'S NO ROOM), OR (2)
MWS ADJUSTMENT IS IN EFFECT AND UPT.MAT > 0 (THERE'RE PAGES IN
THE MWS THAT OUGHT TO BE REPLACED).
@@ENTRY	P3,P4/ LMAP SLOT FOR THE PAGE THAT WANTS IN
	W/ ITS VP NUMBER
	J/ JOB NUMBER
@@ACCUM	DESTROYS T1-T4, PRESERVES J AND W, POSSIBLY MODIFIES P4.
@@TABLES (SEE MWSREP)
@@EXIT SKIP-RETURNS IF THERE'S ROOM FOR THE NEW PAGE
(MWS SIZE < MWSLIM), NONSKIP-RETURNS IF THERE'S NOT
@@ #

MWSRPL:	PUSHJ	P, STOLMA	;SAVE P3 AND P4
	PUSH	P, P1
	PUSH	P, P2
	PUSH	P, W		;AND P1, P2, AND W
	MOVEI	P1, JWSADJ
	TDNE	P1, JBTSTS(J)	;IF DOING MWS ADJUSTMENT,
	SKIPA	P1, [.MRFDA]	;SAY SO,
	MOVEI	P1, .MRFNA	;ELSE SAY NO
	PUSHJ	P, MWSREP	;DO THE ACTUAL WORK
	JRST	.+2
	AOS	-3(P)		;RECORD THE SUCCESS (IF ANY)
	POP	P, W
	POP	P, P2
	POP	P, P1
	PJRST	GETLMA		;RESTORE W AND P3 AND P4
COMMENT	#
@@SUBROUTINE MWSREP
@@PURPOSE THROWS OLDEST PAGES OUT OF J'S MWS ACCORDING TO THE
FUNCTION CODE PASSED IN P1 BY THE CALLER:
	.MRFNA	(FAULTED, NO ADJUSTMENT)
		THROW OUT PAGES UNTIL MWSSIZE < MWSLIM
	.MRADJ	(ADJUST MWS)
		THROW OUT PAGES UNTIL MWSSIZE < MWSLIM
		AND ALL "ELDERLY" PAGES HAVE BEEN DISCARDED
	.MRFDA	(FAULTED, DO ADJUSTMENT)
		THROW OUT PAGES UNTIL MWSSIZE < MWSLIM
		AND ALL "ELDERLY" PAGES HAVE BEEN DISCARDED
		AND THE OLDEST "MATURE" PAGE HAS BEEN DISCARDED
@@ENTRY	P1/ FUNCTION CODE (SEE ABOVE), J/ JOB NUMBER.
@@ACCUM	DESTROYS T1-T4 AND P1-P4 AND W.
@@TABLES UPTMWB (MWS BIT TABLE) AND UPTAGE (PAGE AGE TABLE).
@@EXIT SKIP-RETURNS IF MWSSIZE < MWSLIM, NONSKIP-RETURNS OTHERWISE
@@FUNCTION
	LASTPAGE := (UPT.RPT + 1) MOD 777
AGAIN:	IF MWS SIZE = 0
		IF MWS LIMIT = 0
			NONSKIP:RETURN
		ELSE
			SKIP-RETURN
	DEJAVU := -1
	MAXAGE := IF MWS SIZE > MWS LIMIT {0}
		  ELSE CASE FUNCTION OF
		  {.MRFNA: -1; .MRFDA: AGEMAT-1; .MRADJ: AGEELD-1}
	OLDPAGE := -1
	PRESTEP P := FIRST PAGE IN MWS >= LASTPAGE
		IF NO SUCH P OR P > 777
			LASTPAGE := 0
			CONTINUE
		IF DEJAVU = -1
			DEJAVU := P
		ELSEIF P = DEJAVU
			BREAK
		IF P.DIO > 0
			CONTINUE
		IF P.AGE > MAXAGE
			MAXAGE := P.AGE
			OLDPAGE := P
	IF OLDPAGE NEQ -1
		REMOVE OLDPAGE FROM MWS
		IF FUNCTION = .MRFDA AND MAXAGE >= AGEELD
		ORIF MWS SIZE >= MWS LIMIT
			GOTO AGAIN
		UPT.RPT := OLDPAGE
		SKIP-RETURN
	ELSEIF MWS SIZE >= MWS LIMIT
		NONSKIP-RETURN
	ELSE
		SKIP-RETURN
@@ #
MWSREP:	JSP	T4, SAVFMU	;SAVE F AND M AND U
	PUSH	P, PG		;SAVE PG
	PUSH	P, S		;SAVE S
	MOVE	T1, MWSLIM
	SUBI	T1, NCTXPG
	PUSH	P, T1		;0(P)/ MWS SIZE UPPER BOUND

MWSRP1:	LDB	T1, JBYMWS	;T1/ MWS SIZE
	LDB	T2, JBYPPP	;T1/ # MWS PAGES FOR SIMIO
	SUBM	T1, T2		;T2/ # MWS PAGES SUBJECT TO REPLACEMENT
	JUMPE	T2, MWSRP8	;LEAVE IF THERE AREN'T ANY
	CAML	T1, 0(P)	;IF OVER LIMIT OR AT LIMIT,
	TDZA	S, S		;DISCARD ANY PAGE
	MOVE	S, @[		;ELSE SET MINIMUM AGE FROM FUNCTION:
		[0]		;.MRFNA -- THROW OUT ANY PAGE
		AGEMAT		;.MRFDA -- MATURE PAGES ONLY
		AGEELD		;.MRADJ -- ELDERLY PAGES ONLY
	](P1)
	SOS	S		;S/ OLDEST UNBUMPABLE PAGE AGE
	HRROS	P1		;P1/ OLDEST PAGE SEEN,,FUNCTION CODE
	SETO	P2,		;P2/ DEJAVU PAGE
	AOS	W, %UPT+UPTRPT	;W/ NEXT PAGE TO TRY BUMPING
	ANDI	W, 777		;(MOD 777)

MWSRP2:	JSP	F, NXTMWS	;W/ NEXT MWS PAGE
	JRST	[		;IF NONE,
		SETZ	W,
		JRST MWSRP2	;  RETRY FROM PAGE 0
	]
	CAILE	W, 777		;IF NOT USER PAGE,
	JRST	[
		JSP	FINXWS
		SETZ	W,
		JRST	MWSRP2	;  RETRY FROM PAGE 0
	]
	JUMPGE	P2, MWSRP3	;IF THIS IS THE FIRST PAGE SEEN,
	HRRZ	P2, W		;  REMEMBER THE PAGE NUMBER
	JRST	MWSRP4
MWSRP3:	CAIN	P2, 0(W)	;ELSEIF WE'VE BEEN HERE BEFORE,
	JRST	MWSRP6		;  THE SEARCH IS DONE

    ;HERE WITH W/ A USER MWS PAGE, TO CHECK IF IT'S THE OLDEST
    ;SO FAR AND, IF SO, IF IT'S BUMPABLE

MWSRP4:	HRRZ	T1, W
	IDIVI	T1, AGECPW	;T1/ AGE CELL WORD, T2/ CELL # IN WORD
	LDB	T2, AGEPTR(T2)	;T2/ AGE OF PAGE W
	CAMG	T2, S		;IF AGE <= MAXAGE,
	JRST	(M)		;  GO TRY ANOTHER PAGE
	JSP	T3,REPOK	;SEE IF PAGE IS BUMPABLE
    ;HERE WHEN AN OLDEST-SO-FAR BUMPABLE PAGE HAS BEEN FOUND,
    ;TO LEAVE THE LOOP EARLY IF IT'S AN ELDERLY PAGE AND WE'RE
    ;DISCARDING ALL ELDERLY PAGES

MWSRP5:	MOVEM	T2, S		;S/ MAXIMUM AGE SEEN SO FAR
	HRLM	W, P1		;P1.LH/ OLDEST PAGE SEEN SO FAR
	MOVEI	T1, .MRFNA
	CAIE	T1, 0(P1)	;IF FUNCTION = FAULT-NO-ADJUST
	CAMGE	T2, AGEELD	;OR AGE < ELDERLY,
	JRST	(M)		;  KEEP LOOKING FOR THE OLDEST

    ;HERE WHEN WE EXIT FROM THE OLDEST-PAGE SEARCH
    ;P1.LH/ THE PAGE # OF THE OLDEST PAGE, OR -1
    ;IF NO BUMPABLE PAGE WAS FOUND

MWSRP6:	JSP	F, FINXWS	;  UNDO NXTMWS'S DAMAGE
	JUMPL	P1, MWSRP8	;IF WE FOUND A BUMPABLE PAGE,
	HLRZ	W, P1		;  W/ OLDEST PAGE
	MOVEM	W, %UPT+UPTRPT	;  UPDATE POINTER
	PUSHJ	P, GETLMA	;  GET PAGE W'S SLOT
	PUSHJ	P, REMMWS	;  REMOVE PAGE W FROM MWS
	PUSHJ	P, STOLMA
	LDB	T1, JBYMWS	;  T1/ MWS SIZE
	CAML	T1, 0(P)	;  IF SIZE >= LIMIT,
	JRST	MWSRP1		;    TRY TO BUMP ANOTHER PAGE
	MOVEI	T1, .MRFNA
	CAIN	T1, 0(P1)	;  IF FN WASN'T FAULT-WITH-NO-ADJUST
	JRST	MWSRP7
	CAML	S, AGEELD	;  AND AGE >= ELDERLY,
	JRST	MWSRP1		;    TRY TO BUMP ANOTHER PAGE
MWSRP7:	POP	P, T1		;  ELSE SUCCESS-RETURN
	POP	P, S
	POP	P, PG
	JRST	CPOPJ1

    ;HERE WHEN THE OLDEST-PAGE SEARCH FOUND NO BUMPABLE PAGE

MWSRP8:	POP	P, T2		;T2/ MWS SIZE LIMIT
	POP	P, S
	POP	P, PG
	LDB	T1, JBYMWS	;T1/ MWS SIZE
	CAMGE	T1, T2		;IF WE'RE UNDER THE LIMIT,
	AOS	(P)		;  SUCCESS-RETURN
	POPJ	P,		;ELSE FAIL-RETURN
SAVFMU:	PUSH	P,F
	PUSH	P,M
	PUSH	P,U
	PUSHJ	P,(T4)
	  JRST	.+2
	AOS	-3(P)
	POP	P,U
	POP	P,M
	POP	P,F
	POPJ	P,
COMMENT ;@@SUBROUTINE REPOK.
@@PURPOSE CHECK TO SEE IF PAGE SELECTED BY WS ALG IS OK TO REPLACE.
@@ENTRY T3-<SUCCESS RETURN ADDR, M<-FAIL RETURN ADDR, W, PG,
  DESIRED LMAP SELECTED.
@@ACCUM T1.
@@CALLS GETLMA.
@@FUNCTION CHECK TO SEE IF PAGE SELECTED FOR REPLACEMENT HAS DIO
  UP OR IS LOCKED.  RETURN TO CALLER ACCORDINGLY.
@@;

REPOK:
	PUSHJ	P, REDLMA	;P3, P4/ LMAP SLOT FOR W
				;(WE'RE JUST LOOKING)
	TLNN	P3, LMPACT	;IF IT'S NOT ACTIVATED,
	JRST	(T3)		;  IT'S OK TO REPLACE
	TLNE	P3,LMPLOK	;CAN'T TOUCH IT IF ITS LOCKED
	JRST	(M)		;SORRY CHARLIE.
	HRRZ	PG, P4
	ANDI	PG, 17777	;PG/ CORE PAGE #
	LDB	T1, PGYDIO	;T1/ DIRECT I/O COUNT: IF NONZERO,
	JUMPN	T1, (M)		;  GO TRY ANOTHER PAGE
	JRST	(T3)		;PAGE IS OK TO REPLACE
SUBTTL ACTIVATE LMAP SLOT

COMMENT ;@@SUBROUTINE ACTLMS
@@PURPOSE ACTIVATES AN LMAP SLOT FOR THE SWAPPER. JUST
LIKE ACTLMA EXCEPT CORE PAGE NUMBER IS IN PG AND %UPS IS
PRESERVED
@@ENTRY P3,P4 HAVE LMAP SLOT, PG HAS CORE PAGE NUMBER,
JOB NUMBER IN J, VP NUMBER IN RH(W). LH(W) CAN BE ANYTHING.
ENTER AT ACTLMS FOR NORMAL ACTIVATION.
ENTER AT ACTLMS-1 FOR SETTING THE "STOLEN BIT MAP" BIT. (USED BY
  NAILIT IN THE SWAPPER FOR MARKING PAGE AS STOLEN.)
@@ACCUM USES T1-T4.
@@EXIT SLOT NOW ACTIVE, CALLER MUST STORE BACK
INTO LMAP EVENTUALLY. PG STILL HAS CORE PGE NUMBER.
ALWAYS NON-SKIP RETURNS.  %UPS PRESERVED.
@@FUNCTION SEE ACTLMA.
@@;

	PUSHJ	P,SETSTL	;SET SWAPPER'S STOLEN BIT.
ACTLMS::TLNE	P3,LMPACT	;ALREADY ACTIVE?
	POPJ	P,		;YES, THEN JUST RETURN.
	TLNE	P3,LMMEXS	;CRASH IF NON-EXISTENT
	PUSHJ	P,ACTLM0	;DO THE WORK
	  STOPCD		;SOMETHING WENT WRONG
	PJRST	MAPUPS		;MAKE SURE UPS HAS C(J)'S LMAP
COMMENT ;@@SUBROUTINE ACTLMA
@@PURPOSE ACTIVATE LMAP SLOT FOR FLTMWS, CINMWS
@@ENTRY P3, P4 CONTAIN LMAP SLOT, JOB IN J, VP NUMBER
IN RH(W), LH(W) CAN BE ANYTHING.
MUST HAVE UPT WRITE LOCKED, SO THAT WE DON'T ACTIVATE A SLOT WHILE
ANOTHER FRAME IS REMOVING IT. (CALLER'S RESPONSIBILITY).
@@ACCUM USES T1-T4, PG
@@EXIT NON-SKIP RETURN IF CANNOT ACTIVATE PAGE NOW.
SKIP RETURN IF PAGE IS ACTIVATED. PG CONTAINS CP NUMBER
FOR ACTIVE LMAP SLOT, P3, P4 CONTAIN NEW LMAP SLOT CONTENTS,
MUST BE STORED BACK INTO LMAP. VIRGIN BIT STATE IS CORRECTED
(MUST BE RE-CORRECTED IF RESCHEDULING TAKES PLACE, BUT THEN
LMAP SLOT MAY NO LONGER BE ACTIVE IF RESCHEDULING TAKES PLACE.)
@@FUNCTION CRASH IF PAGE OUT OF RANGE OR DOES NOT EXIST.
JUST RETURN IF PAGE IS ALREADY ACTIVE. ELSE, GET DP ADDRESS
FROM SLOT AND SEARCH CHT FOR THE CP NUMBER. IF NOT IN CHT,
AND NOT VIRGIN PAGE, GIVE NON-SKIP RETURN. IF IS A VIRGIN PGE,
TRY TO GET A FREE PGE. IF CAN PUT CP INTO CHT FOR DP, CONTINUE
WITH ACTIVATION. (ACTLMS ENTERS AT THIS POINT).
IF SWAP IN IN PROGRESS, USE COUNT UP, CP IS DIRTY, CONTINUE.
IF SWAP OUT NOT IN PROGRESS, AND CLEAN AVAIL PAGE COUNT IS UP,
CONTINUE, ELSE GIVE ERROR RETURN. IF SWAP OUT IN PROGRESS,
AND CLEAN IN PROGRESS COUNT IS UP, CONTINUE, ELSE ERROR RETURN.
(VIRGIN PAGE ENTERS AT THIS POINT). INCREMENT CP'S
USE COUNT, CHANGE CP'S LIST, ADJUST NECESSARY COUNTS BY
CALLING INCUSE. IF SUPER SLOT, JUST PUT ONTO LMA CHAIN.
IF NOT SUPER SLOT, SET EITHER PGYATB OR PGYSPT DEPENDING ON WHETHER
THE SLOT IS UNSHARED OR SHARED. IF SLOT IS SHARED
AND PGYATB IS SET, SCAN LMA CHAIN FOR SINGLE UNSHARED ACTIVE
LMAP SLOT AND CHANGE ITS STATUS TO SHARED.
(SUPER SLOT REJOINS HERE). PUT SLOT ON LMA CHAIN, INCREMENT
JBYACT AND TOTACT, IF PAGE IS DIRTY AND PROTECTION
IS READ/WRITE, SET PGE.W IN P4 (UPT CONTENTS).
SKIP RETURN WITH P3,P4 CONTAINING NEW LMAP SLOT DATA FOR ACTIVE
SLOT.
@@;
ACTLMA::HRRZ	T1,W		;GET VP NUMBER
	TLNE	P3,LMMEXS	;CRASH IF SLOT NON-EXISTENT.
	CAILE	T1,VPMAX	;ANY GOOD?
	STOPCD			;NO.
	TLNE	P3,LMPACT	;ALREADY ACTIVE?
	JRST	CPOPJ1		;YES, NOTHING TO DO.
	PUSHJ	P,GETDPA	;GET DISK ADDRESS OF SLOT IN T2
	PUSHJ	P,SRCCHT	;IN CORE ALREADY?
	  JRST	ACTNC1		;NO
	PUSHJ	P,TSTVIR	;MAKE SURE LMPVIR IS CORRECTED ON RETURN
	  JRST	ACTLAS		;NOT VIRGIN, GO ACTIVEATE SOME MORE.
	SKIPGE	T1		;IF THIS IS A FILE PAGE IN CORE,
	TLZ	P3,LMPVIR	;DOESN'T NEED A VIRGIN START.
	JRST	ACTLAS		;GO DO THE REST.

;HERE IF DP WAS NOT IN CHT. IF ITS NOT VIRGIN, CAN'T DO
; ANYTHING. ELSE IF ITS PRIVATE, TRY TO GET A FREE PAGE
; SO THAT PAGE FAULT CAN FIX IT UP. IF NOT, ACTIVATE FAILS.
; IF ITS A FILE PAGE, TRY TO GET A FREE PAGE. IF NOT,
; ACTIVATE FAILS, ELSE START I/O INTO THE PAGE.

ACTNC1:	PUSHJ	P,TSTVIR	;IS IT VIRGIN?
	  POPJ	P,		;NO, CAN'T DO ANYTHING FOR HIM.
	JUMPL	T1,ACTNCF	;JUMP IF THIS IS A FILE PAGE.
	SKIPG	CAVPGN		;PRIVATE. ANY FREE PAGES?
	POPJ	P,		;NO, CAN'T DO THE ACTIVATE NOW.
	AOS	VRACNT		;CAN DO IT, COUNT ONE MORE DONE.
	PUSHJ	P,GETFRE	;GET A FREE PAGE
	  STOPCD		;BUT CAVPGN WAS >0!
	PUSHJ	P,GETDPA	;GET DP FOR VP
	PUSHJ	P,INSCHT	;PUT INTO CHT SO OTHERS FIND IT.
	JRST	ACTLAS		;AND GO TO DO THE REST.

;HERE FOR "VIRGIN" FILE PAGE, WHICH MEANS TRY TO START IT
; IN WITHOUT THE SWAPPER'S HELP.

ACTNCF:	SKIPG	CAVPGN		;TRY TO TAKE A CLEAN AVAIL PAGE
	JRST	[AOS SIOBOM	;KEEP TRACK OF FAILURES
		 POPJ P,]	;CAN'T DO ACTIVATE RIGHT NOW.
				;(LEAVE LMPVIR ON IN CASE WE GET ANOTHER CHANCE (PRFMWS))
	TLZ	P3,LMPVIR	;SUCCESS.
	AOS	SIOCNT		;PROCLAIM SUCCESS TO THE WATCHFUL EYE.
	AOS	SIPTOT		;SWAP IN DONE DECREMENTS THIS
	PUSHJ	P,GETFRE	;GET THE PAGE WE WERE PROMISED
	  STOPCD		;CAVPGN WAS >0 . . .
	SOSGE	CAVPGN		;OK, DECREMENT THIS NOW
	STOPCD			;BUT WAS JUST POSITIVE.
	PUSHJ	P,GETDPA	;GET DP FOR VP
	PUSHJ	P,INSCHT	;PUT IT INTO CHT
	SETO	T1,
	DPB	T1,PGYSIP	;SET SWAP IN IN PROGRESS
	PUSHJ	P,SWPIO		;START THE I/O

ACTLAS:	PUSHJ	P,ACTLM0	;DO THE REAL WORK
	  POPJ	P,		;SORRY, COULDN'T DO IT
	PUSHJ	P,SETLMA	;VALIDATE SLOT SO CALLERS CAN THROW IT AWAY
				;BUT SLOT IS STILL CONSIDERED TO BE OUT
	JRST	CPOPJ1		;GOOD RETURN.
;COMMON ACTIVATE ROUTINE FOR ACTLMA AND ACTLMS.

ACTLM0:	LDB	T1,PGYSTS	;GET CP STATUS BITS
	TRNE	T1,PGPSIP!PGPDRT ;IF SIP OR DIRTY,
	JRST	ACTLM2		;CAN ALWAYS HAVE IT
	LDB	T2,PGYUSE	;IF USE COUNT UP, CAN
	JUMPN	T2,ACTLM2	; CAN ALWAYS HAVE IT
	TRNN	T1,PGPSOP	;IF SWAP OUT IN PROGRESS,
	JRST	ACTLM1		;(NOT, ITS CLEAN FREE PAGE)
	SKIPG	CAPPGN		;CAN HAVE IT IF CAPPGN IS UP
	POPJ	P,		;SORRY, CAN'T HAVE IT.
	JRST	ACTLM2		;OK, GO ACTIVATE.

ACTLM1:	SKIPG	CAVPGN		;CP IS CLEAN FREE, CAN GRAB IF CAVPGN IS UP
	POPJ	P,		;SORRY, CAN'T HAVE IT.

ACTLM2:	PUSHJ	P,INCUSE	;INCREMENT USE COUNT, CHANGE LISTS,
				; ADJUST COUNTS
;HERE WHEN PAGE IS IN CORE, ALL READY TO PUT ON LMA CHAIN, ETC.

ACTLM3:	TLNE	P3,LMPSUP	;IF ITS A SUPER SLOT,
	JRST	ACTLM5		;JUST PUT IT ON LMA CHAIN.
	JUMPL	P3,ACTLM4	;JUMP IF SHARED (LMPSHR)
	LDB	T3,LM3ATB	;GET ATB POINTER
	DPB	T3,PGYATB	;REMEMBER ATB POINTER
	JRST	ACTLM5		;AND GO PUT INTO CHAIN

;HERE IF WE'RE ACTIVATING A SHARED SLOT. REMEMBER THE SPT
; ADDRESS IN PGYSPT. IF PGYATB SET, MUST FIND
; THE SINGLE UNSHARED ACTIVE SLOT AND CHANGE ITS STATUS TO SHARED.

ACTLM4:	LDB	T3,LM3SPT	;GET SPT POINTER
	DPB	T3,PGYSPT	;SAVE IN PGY TABLE
	LDB	T3,PGYATB	;IF NO SINGLE UNSHARED MEMBER,
	JUMPE	T3,ACTLM5	;JUST PUT ONTO LMA CHAIN

;LMA CHAIN CONSISTS OF ONE UNSHARED LMAP SLOT, AND POSSIBLY
; OTHER SUPER SLOTS. (FIRST ACTIVE SHARED SLOT TO GO
; ON LMA CHAIN ALWAYS UPDATES AN ACTIVE UNSHARED SLOT
; ON THE CHAIN). UPDATE THE UNSHARED SLOT'S LMAP SLOT AND
; MAKE IT SHARED.

	PUSH	P,P3		;SAVE P3,P4,J,W
	PUSH	P,P4
	PUSH	P,J
	PUSH	P,W
	PUSH	P,F		;MUST PRESERVE F,M,U
	PUSH	P,M
	PUSH	P,U
	JSP	F,SCNLMC	;SCAN THE LMA CHAIN
	  STOPCD		;WE HAVE TO FIND HIM
	TLNE	P3,LMPSHR	;IF ITS SHARED,
	STOPCD			;WE'RE IN BIG TROUBLE.
	TLNE	P3,LMPSUP	;THIS HIM?
	JRST	(M)		;NO, CHECK THE NEXT ONE.
	LDB	T4,PGYSPT	;YES, GET SPT POINTER FOR SETSHR.
	PUSHJ	P,SETSHR	;YES. CHANGE HIS STATUS
	JSP	F,FINLMC	;FIX STACK UP
	POP	P,U
	POP	P,M
	POP	P,F
	POP	P,W
	POP	P,J
	POP	P,P4		;RESTORE ORIGINAL LMAP SLOT CONTENTS
	POP	P,P3

ACTLM5:	LDB	T1,PGYLMJ	;GET OLD FIRST MEMBER OF LMA CHAIN
	LDB	T2,PGYLMV	;JOB AND VP NUMBERS
	DPB	T1,LM3LMJ	;SLOT WE'RE DOING POINTS
	DPB	T2,LM3LMV	; TO OLD FIRST ELEMENT
	DPB	J,PGYLMJ	;THIS SLOT IS NEW FIRST MEMBER
	DPB	W,PGYLMV	;VP NUMBER TOO
	TLO	P3,LMPACT	;SLOT IS ACTIVE NOW
	LDB	T1,JBYACT	;ONE MORE ACTIVE PGE
	AOS	T1
	CAILE	T1,VPMAX+1	;TOO HIGH?
	STOPCD			;YES, SOMEONE MADE A MISTAKE.
	AOS	TOTACT		;ONE MORE SYSTEM WIDE ACTIVE PAGE.
	DPB	T1,JBYACT
	MOVEI	P4,PGE.C(PG)	;SETUP UPT CONTENTS
	LDB	T1,PGYDRT	;IF DIRTY AND
	JUMPE	T1,CPOPJ1	;(DON'T SET W BIT, SKIP RETURN)
	LDB	T1,LM3CUR	;PROTECTION IS READ/WRITE
	CAIN	T1,CPRRDW	;THEN
	TRO	P4,PGE.W	;CAN SET "W" BIT TOO.
	JRST	CPOPJ1		;SKIP RETURN.
SUBTTL DEACTIVATE LMAP SLOT
COMMENT ;@@SUBROUTINE DEALMS
@@PURPOSE DEACTIVATE AN LMAP SLOT FOR THE SWAPPER
@@ENTRY P3,P4 CONTAIN LMAP SLOT DATA,
RH(W) CONTAINS VP NUMBER  (LH(W) CAN BE NON-ZERO),
J CONTAINS JOB NUMBER
@@ACCUM USES T1-T4
@@EXIT RETURNS WITH P3, P4 DEACTIVATED LMAP SLOT DATA,
PG CONTAINS FORMER CORE PAGE NUMBER. %UPS
HAS LMAP OF C(J).
@@FUNCTION CRASH IF PGYDIO SET OR PAGE OUT OF RANGE.
SEE DEALMA FOR REMAINING FUNCTION.
@@;

DEALMS::HRRZ	T1,W		;GET PAGE NUMBER
	CAILE	T1,VPMAX	;IS IT IN RANGE?
	STOPCD			;AFRAID NOT.
	TLNN	P3,LMPACT	;ALREADY INACTIVE?
	POPJ	P,		;YES, NO WORK TO DO.
	PUSHJ	P,GETCPA	;GET CORE PAGE NUMBER
	LDB	T1,PGYDIO	;DIRECT I/O IN PROGRESS?
	SKIPE	T1		;IF SO, CALLER GOOFED
	STOPCD			;SO HE DID.
	PUSHJ	P,DEALM1	;DO THE WORK
	SKIPL	JBTCTX(J)	;THIS WILL BE OFF IF CALLED FROM
	POPJ	P,		;SWOCTX, WHICH WILL RESTORE IT ITSELF.
	PJRST	MAPUPS		;RESTORE %UPS AND RETURN


COMMENT ;@@SUBROUTINE DEALMA
@@PURPOSE DEACTIVATE AN LMAP SLOT THAT CAME FROM %UPT
@@ENTRY P3,P4 CONTAIN LMAP SLOT DATA, RH(W) CONTAINS
VP NUMBER, LH(W) CAN BE NON-ZERO, J CONTAINS JOB NUMBER.
@@ACCUM USES T1-T4,PG
@@EXIT RETURNS WITH FORMER CORE PAGE NUMBER IN PG, LMAP DATA
OF DEACTIVATED SLOT IN P3,P4.
@@FUNCTION CRASH IF PAGE OUT OF RANGE. IF ALREADY DEACTIVATED,
RETURN. GO INTO SW WAIT IF DIO IS STILL IN PROGRESS FOR
CP. IF INACTIVE WHEN DIO FINISHES, RETURN. IF NOT, TURN
OFF ACTIVE BIT IN LMAP DATA, DECREMENT JBYACT AND TOTACT.
TAKE PAGE OFF LMA CHAIN, MAKE LMAP DATA LOOK LIKE
INACTIVE SLOT AGAIN. CLEAR PGYATB IF THIS
IS AN UNSHARED SLOT. FINISH BY CALLING DECUSE
FOR CP, WHICH MAY CHANGE CP LIST AND COUNTS. ALWAYS NON-SKIP RETURN.
@@;

DEALMA::HRRZ	T1,W		;GET VP NUMBER
	CAILE	T1,VPMAX	;ANY GOOD?
	STOPCD			;NO.
DEALM0:	TLNN	P3,LMPACT	;ALREADY INACTIVE?
	POPJ	P,		;YES, ALL DONE.
	PUSHJ	P,GETCPA	;LOAD CORE PAGE ADDRESS
	LDB	T1,PGYDIO	;ANY DIRECT I/O IN PROGRESS?
	JUMPE	T1,DEALM1	;IF NO DIRECT I/O, CONTINUE.
	PUSHJ	P,STOLMA	;STORE IN CASE IT CHANGES
	PUSHJ	P,PAGWAT	;YES, WAIT UNTIL THE DIRECT I/O  FINISHES.
	PUSHJ	P,GETLMA	;GET LMAP (MAYBE NEW) CONTENTS AGAIN
	JRST	DEALM0		;AND SEE IF ITS STILL ACTIVE.
DEALM1:	TLZ	P3,LMPACT	;NO LONGER ACTIVE NOW
	LDB	T1,JBYACT	;DECREMENT ACTIVE COUNT
	TLNN	P3,LMPLOK	;MAKE SURE NOT TRYING TO DEACTIVATE LOCKED VP
	SOSGE	T1
	STOPCD			;TOO MANY DEACTIVATES.
	DPB	T1,JBYACT
	SOS	TOTACT		;ONE LESS SYSTEM WIDE ACTIVE PAGE
;FIRST TAKE THIS SLOT OUT OF LMA CHAIN. EASY IF ITS THE FIRST ON
; THE CHAIN, OTHERWISE HAVE TO TRAVERSE CHAIN TO FIND ITS
; PREDECESSOR.


	LDB	T3,LM3LMJ	;GET NEXT SLOT ON LMA CHAIN
	LDB	T4,LM3LMV	;FOR LATER
	LDB	T1,PGYLMJ	;GET FIRST LMAP POINTER
	LDB	T2,PGYLMV	;IN T1 AND T2
	CAMN	J,T1		;IS THE FIRST ON CHAIN THE ONE
	CAIE	T2,(W)		; WE'RE REMOVING?
	JRST	DEALM2		;NO, GO SEARCH CHAIN
	DPB	T3,PGYLMJ	;YES, ONE AFTER ONE WE'RE REMOVING
	DPB	T4,PGYLMV	;IS NEW FIRST ONE
	JRST	DEALM5		;FIX SLOT UP AND RETURN.
;HERE IF SLOT IS SHARED AND NOT THE FIRST ON THE LMA CHAIN.
; FIND THE SLOT BEFORE THE ONE WE'RE REMOVING AND POINT IT
; TO THE ONE AFTER THE ONE WE'RE REMOVING. T1 AND T2 CONTAIN
; LMAP POINTER FOR FIRST LMAP SLOT ON CHAIN, J AND W STILL
; CONTAIN LMAP POINTER FOR SLOT WE'RE REMOVING, P3 AND P4
; STILL CONTAIN DEACTIVATING SLOT'S DATA.

DEALM2:	EXCH	T3,P1		;GET NEXT SLOT ON CHAIN INTO BETTER
	EXCH	T4,P2		;ACS
	PUSH	P,T3		;SAVE P1
	PUSH	P,T4		;SAVE P2
	PUSH	P,P3		;SAVE GOOD LMAP DATA
	PUSH	P,P4		;SAVE POSSIBLE CORE ADDRESS
	PUSH	P,J		;SAVE LMAP POINTER TO LMAP WE'RE
	PUSH	P,W		; TAKING OUT OF CHAIN

DEALM3:	JUMPN	T1,.+2		;IF RAN OUT OF CHAIN MEMBERS
	STOPCD			; CRASH, NO ONE POINTED TO SLOT
	MOVE	J,T1		;GET READY TO LOOK AT THIS SLOT
	MOVE	W,T2
	PUSHJ	P,MAPUPS	;MAKE LMAP ADDRESSABLE
	MOVE	P3,%UPLMS(W)	;GET LMAP WORD WE NEED
	LDB	T1,LM3LMJ	;GET LMAP SLOT IT POINTS TO
	LDB	T2,LM3LMV
	MOVE	T3,(P)		;GET GARBAGE,,PAGE NUMBER
	CAMN	T1,-1(P)	;DOES IT POINT TO ONE WE'RE REMOVING?
	CAIE	T2,(T3)
	JRST	DEALM3		;NO, STEP TO NEXT SLOT
	DPB	P1,LM3LMJ	;YES, POINT PREVIOUS TO NEXT
	DPB	P2,LM3LMV
	MOVEM	P3,%UPLMS(W)	;STORE LMAP CONTENTS
	POP	P,W		;RESTORE OLD REMOVED LMAP POINTER
	POP	P,J
	POP	P,P4		;RESTORE POSSIBLE CORE PAGE ADDRESS
	POP	P,P3		;RESTORE OLD LMAP CONTENTS
	POP	P,P2		;AND P2 AND P1
	POP	P,P1
;HERE AFTER SLOT HAS BEEN REMOVED FROM LMA CHAIN.
; CORE PAGE NUMBER IS IN PG, PREVIOUS SLOT JOB AND VP
; ARE IN P1 AND P2, SLOT CONTENTS IN P3 AND P4, JOB
; AND VP OF SLOT WE'RE DEACTIVATING IN J AND W.
; FIX SLOT CONTENTS BACK UP ACCORDING TO WHAT KIND
; OF SLOT IT IS.
; (MAKE SURE WE DON'T DESTROY POSSIBLE CORE PAGE ADDRESS IN
; P4 SO THAT REMOVE CAN TURN THE A AND W BITS BACK ON
; IF ITS REMOVING THE CONTEXT PAGES)

DEALM5:
DEALM6:	JUMPL	P3,DEALM7	;JUMP IF SHARED
	LDB	T1,PGYATB	;GET ATB POINTER
	TLNE	P3,LMPSUP	;SUPER SLOT?
	SETO	T1,		;YES, MAKE IT UNREASONABLE
	DPB	T1,LM3ATB	;SET ATB FIELD
	SETZ	T1,		;GET READY TO CLEAR PGYATB
	TLNN	P3,LMPSUP	;BUT NOT IF ITS SUPER SLOT
	DPB	T1,PGYATB	;CLEAR IT.
	LDB	T2,PGYADR	;GET DISK ADDRESS
	CAMN	T2,ADRDUM	;DUMMY PAGE?
	JRST	[DPB T1,PGYDRT	;YES, CLEAN IT UP SO DOESN'T TRY TO GO OUT
		 SETO T1,
		 DPB T1,PGYADR	;BACK TO NOTHING IN CP
		 JRST .+1]
	DPB	T2,UP4LDA	;STORE LOW ORDER
	LSH	T2,-LMASRP	;RIGHT JUSTIFY HI ORDER
	DPB	T2,LM3HDA	;HI ORDER
	TRZ	P4,PGE.A	;TURN OFF "A" BIT
	PJRST	DECUSE		;DECREMENT PG USE COUNT AND RETURN.

DEALM7:	LDB	T2,PGYSPT	;GET SPT POINTER
	DPB	T2,LM3SPT	;PUT BACK INTO SLOT
	TRZ	P4,PGE.A	;MAKE SURE ACCESS BIT IS OFF
	PJRST	DECUSE		;DECREMENT PG USE COUNT AND RETURN.
SUBTTL CHANGE LMAP STATUS

COMMENT ;@@SUBROUTINE SETSHR
@@PURPOSE CHANGE AN UNSHARED LMAP SLOT'S STATUS TO SHARED
USED WHEN ACTIVATING THE FIRST SHARED SLOT SHARING DP WITH
AN ALREADY ACTIVE UNSHARED SLOT.
USED IN REPLICATE TO CHANGE THE STATUS OF "SOURCE" PAGE TO
SHARED, TO DECREASE NUMBER OF TIMES ACTIVATE HAS TO
SEARCH SPT.
@@ENTRY T4 CONTAINS SPT POINTER (BASE+OFFSET), P3 AND
P4 CONTAIN LMAP SLOT DATA, J CONTAINS JOB NUMBER.
@@ACCUM DESTROYS PG, T ACS
@@EXIT P3, P4 CONTAIN MODIFIED LMAP SLOT DATA, NOW SHARED
T4 STILL CONTAINS SPT POINTER.
@@RESTRICTIONS LMAP SLOT IN P3, P4 MUST NOT BE SHARED ALREADY
SLOT MUST NOT BE SUPER-SLOT.
@@CALLS GETDPA, SRCCHT
@@FUNCTION CRASH IF SLOT IS SUPER OR SHARED.
IF SLOT IS ACTIVE (UNSHARED), CLEAR OUT PGYATB
(THERE IS NO LONGER AN UNSHARED SLOT ON LMA CHAIN), SET
PGYSPT FROM ARG IN T4.  IF SLOT IS INACTIVE, JUST SET
SPT POINTER IN SLOT AND RETURN.
@@;

SETSHR::TLNN	P3,LMPSUP	;CRASH IF SLOT IS SUPER.
	TLOE	P3,LMPSHR	;SET SHARED BIT.
	STOPCD			;WAS SUPPOSED TO BE UNSHARED
	TLNN	P3,LMPACT	;IS IT ACTIVE UNSHARED?
	JRST	SETSH1		;NO
	PUSHJ	P,GETCPA	;GET CORE PGE NUMBER IN PG
	SETZ	T1,		;CLEAR PGYATB (CAN ONLY BE ONE
	DPB	T1,PGYATB	; SLOT THAT NEEDS IT)
	DPB	T4,PGYSPT	;STORE SPT POINTER IN PGYSPT
	POPJ	P,		;AND RETURN.
;HERE IF SLOT IS INACTIVE.

SETSH1:	DPB	T4,LM3SPT	;JUST PUT SPT POINTER IN SLOT
	POPJ	P,		;AND RETURN.
SUBTTL CHT HANDLERS

COMMENT ;@@SUBROUTINE SRCCHT
@@PURPOSE IF THE SPECIFIED DISK PAGE IS IN CORE, GET ITS CORE
PAGE NUMBER FROM THE CORE HASH TABLE
@@ENTRY T2 CONTAINS DISK ADDRESS
@@ACCUM PRESERVES T2, DESTROYS ALL OTHER T ACS.
@@TABLES CHT BUCKET TABLE, PGY TABLES
@@GLOBAL
@@EXIT GIVES SKIP RETURN IF DISK ADDRESS IS IN CORE, WITH
CORE PAGE NUMBER IN AC PG. T4 CONTAINS EITHER NEGATIVE OFFSET
INTO CHT BUCKET TABLE OR POSITIVE CORE PAGE NUMBER OF CORE PAGE THAT
PRECEDES THE ONE IN PG IN THE CHT HASH CHAIN.
GIVES ERROR RETURN IF THE DISK PAGE IS NOT IN CORE, WITH PG
CONTENTS ZERO AND T4 CONTAINING EITHER NEGATIVE OFFSET INTO
CHT BUCKET TABLE OR POSITIVE PAGE NUMBER OF LAST
CORE PAGE IN DP'S CHT HASH CHAIN.
@@CALLS
@@FUNCTION SEE ABOVE
@@;

SRCCHT::TLNE	T2,RBMASK	;MAKE SURE NO BAD BITS ON
	STOPCD			;CALLER LEFT THEM ON
	MOVE	T4,T2		;GET COPY OF DISK ADDRESS
	AND	T4,CHTMSK	;GET BUCKET NUMBER
	ROT	T4,-1		;TURN INTO INDEX
	JUMPL	T4,[HRRZ PG,@CHTPTR ;ODD, GET RH
		    JRST .+2]
	HLRZ	PG,@CHTPTR	;EVEN, GET LH
	ROT	T4,1		;BACK TO BUCKET NUMBER
	MOVNS	T4		;T4 GETS -VE OFFSET INTO CHT BUCKET TABLE
	JUMPE	PG,CPOPJ	;IF NULL ENTRY, GIVE NON-SKIP

SRCCH1:	LDB	T1,PGYADR	;GET DISK ADDRESS OF THIS CORE PAGE
	CAMN	T1,T2		;IS THIS THE ONE WE WANT
	JRST	CPOPJ1		;YES, GIVE GOOD RETURN
	MOVE	T4,PG		;NO, T4 GETS PREVIOUS PAGE
	LDB	PG,PGYCHT	;NEXT CP ON CHAIN
	JUMPN	PG,SRCCH1	;AND CHECK NEXT ONES DISK ADDRESS
	POPJ	P,		;WE'VE RUN OUT, GIVE NON-SKIP RETURN



CHTPTR::.-.(T4)			;FILLED IN BY ONCE TO ADDRESS OF CHT BUCKET TABLE
CHTMSK::.-.			;FILLED IN BY ONCE TO MASK TO TURN DP INTO BUCKET NUMBER
COMMENT ;@@SUBROUTINE REMCHT/REMCHR
USED TO TERMINATE THE ASSOCIATION BETWEEN A CORE PAGE AND
A DISK PAGE.
CALLED FROM GETFRE, GETRES, REMOVE AFTER DEALLOCATING THE
DISK PAGE.
@@PURPOSE REMOVE CORE PAGE FROM CORE HASH TABLE
@@ENTRY CORE PAGE NUMBER IN PG
CALL AT REMCHT IF NO USERS OF CP ALLOWED.
CALL AT REMCHR (REMOVE ENTRY POINT) IF MAY BE SUPER MAPPER AROUND.
@@ACCUM SMASHES ALL T ACS
@@TABLES PGY TABLES
@@GLOBAL
@@EXIT CORE PAGE NUMBER CALLED WITH IN PG
@@RESTRICTIONS USE COUNT FOR CP MUST BE ZERO.
CALLER RESPONSIBLE FOR VALIDATING BEFORE CALL IF NECESSARY
TO WRITE DATA BACK TO DISK. I/O MUST NOT BE IN PROGRESS.
@@CALLS SRCCHT
@@FUNCTION IF CALLED AT REMCHR, IF PGYUSE NON-ZER, MAKE SURE PGYJOB
IS ALSO NON-ZERO, ELSE CRASH. IF PGYUSE WAS NON-ZERO, JUST RETURN DOING
NOTHING. FALL INTO REMCHT.
(REMCHT) CALL SRCCHT TO GET THE PREVIOUS CORE PAGE ON THE HASH CHAIN. FIX UP
PGYCHT POINTER OF PREVIOUS PAGE TO POINT TO PAGE AFTER THE
ONE THAT IS BEING REMOVED. IF THERE IS NO PREVIOUS
CORE PAGE, THEN PUT PAGE NUMBER OF CORE PAGE AFTER ONE
BEING REMOVED IN CHT BUCKET TABLE.  ZERO PGYADR FOR CORE PAGE.
IF PAGE IS DIRTY, MAKE IT CLEAN AVAILABLE.
@@;

REMCHR::LDB	T1,PGYUSE	;GET COUNT
	JUMPE	T1,REMCH0	;IF ZERO, NORMAL CHT REMOVE
	LDB	T2,PGYLMJ	;NON-ZERO, MAKE SURE SOMEONE ON HERE
	JUMPN	T2,CPOPJ	;IF SO, JUST RETURN DOING NOTHING.
	STOPCD			;PGYUSE INCREMENTED BUT NO ONE ON LMA CHAIN.
REMCHT::LDB	T1,PGYUSE	;USE COUNT SHOULD BE ZERO
REMCH0:	LDB	T2,PGYSTS	;MAKE SURE I/O NOT IN PROGRESS
	TRNN	T2,PGPSIP!PGPSOP
	SKIPE	T1
	STOPCD
	LDB	T2,PGYADR	;GET DISK ADDRESS IN T2 FOR SRCCHT
	CAMN	T2,ADRNCT	;IS THIS IN THE CHT?
	POPJ	P,		;NO, JUST RETURN.
	PUSH	P,PG		;SAVE PG FROM SRCCHT.
	PUSHJ	P,SRCCHT	;GET CORE PAGE ADDR BEFORE ONE IN PG
	  STOPCD		;NO, CP HAD VALID DP ADDR BUT NOT IN CHT!
	POP	P,T1		;GET CORE PAGE NUMBER OFF STACK
				; (SRCCHT RETURNED IT IN PG)
	CAME	T1,PG		;MAKE SURE ITS THE SAME
	STOPCD			;TWO PAGES WITH SAME PGYADR?
	LDB	T1,PGYCHT	;GET NEXT CORE PAGE NUMBER
	JUMPLE	T4,REMCH1	;JUMP IF NO PREVIOUS MEMBER OF HASH CHAIN
	EXCH	T4,PG		;POINT TO PREVIOUS CP'S PGY TABLE
	DPB	T1,PGYCHT	;PREVIOUS POINTS TO NEXT AFTER ONE
				; BEING REMOVED
	EXCH	T4,PG		;GET RIGHT PAGE BACK IN PG
	JRST	REMCH2		;CLEAR PGYADR AND RETURN

REMCH1:	MOVMS	T4		;CONVERT BACK TO CHT BUCKET TABLE INDEX
	ROT	T4,-1		;TURN BUCKET NUMBER INTO INDEX
	JUMPL	T4,[HRRM T1,@CHTPTR ;ODD, LH
		    JRST .+2]
	HRLM	T1,@CHTPTR	;EVEN, RH.
REMCH2:	SETO	T1,		;SET ALL PGYADR BITS AS A FLAG
	DPB	T1,PGYADR	;MAKE PGYADR ILLEGAL
	SETZ	T1,		;ZERO THIS SO WE CAN
	DPB	T1,PGYERR	;CLEAR OUT ERROR BITS, TOO
	LDB	T1,PGYDRT	;IS THIS PAGE DIRTY?
	SOJL	T1,CPOPJ	;JUMP IF NOT.
	DPB	T1,PGYDRT	;WAS DIRTY, MAKE IT CLEAN
	PUSHJ	P,INCCAV	;EITHER AVAILABLE OR ONE MORE I/O CORE PAGE.
	SOS	DFRPGN		;NOT DIRTY ANYMORE.
	MOVEI	T4,CFR.N	;PUT ONTO BEGINNING OF CLEAN FREE LIST
	PJRST	PUTLSB		;AND RETURN.
COMMENT ;@@SUBROUTINE INSCHT
@@PURPOSE INSERT DISK PAGE INTO CORE HASH TABLE FOR A CORE PAGE
AND SET PGYADR FROM DISK ADDRESS ARG.
@@ENTRY T2 CONTAINS DISK PGE NUMBER, PG CONTAINS CORE PAGE NUMBER
@@ACCUM PRESERVES T2, USES OTHER T ACS, PRESERVES PG
@@TABLES PGY TABLES, CHT START TABLE
@@GLOBAL
@@EXIT RETURNS WITH DISK PAGE IN T2, CORE PAGE IN PG
@@CALLS SRCCHT
@@FUNCTION PUT DISK PAGE NUMBER IN PGYADR
CALL SRCCHT TO FIND THE LAST CORE PAGE IN HASH CHAIN
CRASH IF DISK PAGE ALREADY IN CORE HASH TABLE. PUT CORE PAGE
AT THE END OF THE DISK PAGE'S CHT HASH CHAIN. ZERO PGYCHT
FOR CORE PAGE TO INDICATE THE END OF THE HASH CHAIN.
@@;

INSCHT::DPB	T2,PGYADR	;SET NEW DISK PAGE NUMBER FOR CORE PAGE
	CAMN	T2,ADRDUM	;IF DUMMY DISK PAGE,
	POPJ	P,		;JUST RETURN.
	PUSH	P,PG		;SAVE NEW CORE PAGE NUMBER
	PUSHJ	P,SRCCHT	;GET LAST CORE PAGE ON DP'S HASH CHAIN
	  JRST	.+2		;HAD BETTER NOT BE IN CHT
	STOPCD			;DP WAS ALREADY IN CHT!
	POP	P,PG		;RESTORE NEW CORE PAGE
	JUMPLE	T4,INSCH1	;JUMP IF CHAIN WAS EMPTY
	EXCH	PG,T4		;OLD LAST CHAIN ELEMENT IN PG, NEW IN T4
	DPB	T4,PGYCHT	;OLD LAST ONE NOW POINTS TO NEW LAST ONE
	MOVE	PG,T4		;NEW CORE PAGE BACK IN PG
	JRST	INSCH2		;GO ZERO PGYCHT AND RETURN

INSCH1:	MOVMS	T4		;GET INDEX INTO SYSCHT
	ROT	T4,-1		;GET FROM BUCKET # TO INDEX
	JUMPL	T4,[HRRM PG,@CHTPTR
		    JRST .+2]	;ODD, RH
	HRLM	PG,@CHTPTR	;EVEN, LH.

INSCH2:	SETZ	T1,		;CLEAR OUT PGYCHT TO INDICATE
	DPB	T1,PGYCHT	;THE END OF THE HASH CHAIN
	POPJ	P,		;RETURN.
SUBTTL CONTEXT PAGE MAPPING AND REFERENCING
COMMENT ;@@SUBROUTINE MAPUPS
@@PURPOSE MAKE A JOB'S LMAP AND UPT ADDRESSABLE IN SWAPPER CODE
THROUGH EXEC (NOT PER PROCESS) MAP SLOT.
@@ENTRY J CONTAINS JOB NUMBER
@@ACCUM T1,T3,T4.  PRESERVES T2, LIKE GSLOT USED TO.
@@GLOBAL
@@EXIT J CONTAINS JOB NUMBER, EXEC ADDRESS %UPS CONTAINS
LMAP AND UPT. %UPT ACCESSES ARE NOT LIMITED TO %UPT+777, I.E.
THE LMAP TAKES UP MORE THAN ONE PAGE AND THIS ROUTINE SETS UP
ALL REQUIRED PAGES IN JOB'S CONTEXT PAGES.
@@RESTRICTIONS 
@@CALLS
@@FUNCTION IF CURRENT CONTEXT PAGES IN %UPS ARE ALREADY SET
UP FOR JOB IN J, RETURN. ELSE PICKUP CORE PAGE NUMBER
OF HARDWARE UPT FROM JBTUPM. CRASH IF ITS 0.
ELSE MAKE IT ADDRESSABLE THRU %UPS+0. CLEAR THE A.M.,
MAKE THE REST OF THE PAGES ADDRESSABLE BY COPYING
MAP SLOTS FOR %UPT+1,2, . . . FROM %UPS INTO THE EPT.
CLEAR THE A.M., SETUP UPSJOB AND RETURN.
@@ ;

MAPUPS::CAMN	J,UPSJOB	;ALREADY THERE?
	POPJ	P,		;YES, JUST RETURN
	PUSH	P,T2		;SAVE PRECIOUS T2 FOR COMCON
	HRRZ	T4,JBTUPM(J)	;GET CORE PAGE NUMBER OF HARDWARE UPT
	ANDI	T4,17777	;JUST THE PAGE NUMBER
	SKIPN	T4		;MAKE SURE ITS SETUP
	STOPCD			;CONTEXT PAGES NOT AROUND
	TRO	T4,PGE.A!PGE.W!PGE.C	;MAKE ACCESSIBLE, WRITABLE, CACHED.
	MOVE	T1,EPYPSM	;POINTER TO PUT SLOT ENTRIES [EPTPTR(%UPS.N-1)]
	IDPB	T4,T1		;PUT INTO EPT MAP SLOT
	CLRPTO	%UPS		;CAUSE NEW MAPPING TO GO INTO EFFECT

;ASSUME NCTXPG IS ALWAYS GREATER THAN 1

	MOVE	T3,USYPTN	;GET POINTER TO OTHER MAP SLOTS [UPSPTR(%UPT.N)]
	MOVEI	T2,NCTXPG-1	;NUMBER OF OTHERS TO DO
MAPUP1:	ILDB	T4,T3		;GET NEXT CONTEXT PAGE MAP SLOT
	IDPB	T4,T1		;PUT IT INTO EPT FOR %UPS+?
	SOJG	T2,MAPUP1	;AND LOOP FOR ALL REMAINING CONTEXT PAGES

	MOVEM	J,UPSJOB	;STORE JOB NUMBER OF NEW UPS
	MOVEI	T1,<NCTXPG-2>*1000
MAPUP2:	CLRPTO	%UPS+1000(T1)
	SUBI	T1,1000		;NEXT LOWER PAGE
	JUMPGE	T1,MAPUP2	;KEEP GOING TILL DONE.
	POP	P,T2		;RESTORE
	POPJ	P,		;RETURN.

UPSJOB::0			;JOB NUMBER WHOSE CONTEXT PGES
				; ARE MAPPED IN %UPS
COMMENT ;@@SUBROUTINE GETLMA/GETLMS/GETLMX
	   REDLMA/REDLMS/REDLMX
@@PURPOSE GET THE CONTENTS OF AN LMAP SLOT INTO P3 AND P4
@@ENTRY AC W CONTAINS VIRTUAL PAGE NUMBER OF
DESIRED SLOT, %UPT/%UPS/%UPX IS SETUP TO ADDRESS THE DESIRED LMAP
ENTER AT GETLM? TO GET LMAP SLOT FOR MODIFICATION,
ENTER AT REDLM? IF ONLY WANT TO READ THE SLOT, AND WON'T BE
  RESCHEDULING AND USING THE DATA.
@@ACCUM T1. PRESERVES ALL OTHERS.
@@TABLES
@@GLOBAL
@@EXIT P3 CONTAINS LMAP SLOT DATA, P4 CONTAINS EXTENSION OF LMAP
DATA FROM THE UPT (USUALLY THE LOW ORDER DISK ADDRESS)
@@RESTRICTIONS CALLER MUST EITHER CALL STOLMA OR DECREMENT
UPTLDC BY HAND WHEN HE IS DONE WITH THE SLOT AND IT REPRESENTS
AN EXISTENT VP. IF CALLER FETCHED A NON-EXISTENT VP SLOT AND
TURNED IT INTO AN EXISTENT SLOT (VCREAT, MAP, REPLICATE)
CALLER MUST INCREMENT UPTLDC BEFORE CALLING STOLMA/STOLMS.
@@CALLS
@@FUNCTION GETS LMAP SLOT DATA FROM LMAP SLOT INTO P3 AND P4.
IF THE SLOT'S VP EXISTS, INCREMENT THE COUNT OF EXISTENT
VP SLOTS THAT ARE CURRENTLY BEING KEPT IN P3 AND P4 BY
ANYONE.
@@ ;

DEFINE GETLM(MAP,LDC,%A)<
IFIDN <MAP> <T> <GETLMA::>
IFIDN <MAP> <S> <GETLMS::>
IFIDN <MAP> <X> <GETLMX::>
	MOVE	P3,%UP'MAP+UPTLMA##(W)
	TLNE	P3,LMMEXS	;;IF SLOT DOESN'T EXIST, DON'T INCREMENT
	AOSA	%UP'LDC+UPTLDC	;;LDC. DON'T DO MOVE AGAIN MOST OF THE TIME.
IFIDN <MAP> <T> <REDLMA::>
IFIDN <MAP> <S> <REDLMS::>
IFIDN <MAP> <X> <REDLMX::>
	MOVE	P3,%UP'MAP+UPTLMA##(W)
	HRRZ	T1,W
	CAILE	T1,VPMAX	;;CHECK HERE, DON'T SMASH LOCATIONS IN REST OF UPT.
	STOPCD
	ROT	T1,-1
	JUMPL	T1,%A
	HLRZ	P4,%UP'MAP(T1)
	POPJ	P,
%A:	HRRZ	P4,%UP'MAP(T1)
	POPJ	P,
>;END GETLM MACRO DEFINITION

;GENERATE THE ROUTINES

GETLM(T,T)
GETLM(S,S)
GETLM(X,T)			;;GETTING FROM %UPX INCREMENTS OWN LDC COUNT.
COMMENT ;@@SUBROUTINE STOLMA/STOLMS/STOLMX
@@PURPOSE PUT THE CONTENTS OF LMAP SLOT STORED IN P3 AND P4 BACK
INTO THE LMAP
@@ENTRY AC  CONTAINS VIRTUAL PAGE NUMBER OF DESIRED SLOT,
%UPT/%UPS/%UPX IS SETUP TO ADDRESS THE DESIRED LMAP
@@ACCUM T1. PRESERVES ALL OTHERS.
@@TABLES
@@GLOBAL
@@EXIT
@@CALLS
@@FUNCTION
@@ ;

DEFINE STOLM(MAP,LDC,%A)<
IFIDN <MAP> <T> <STOLMA::>
IFIDN <MAP> <S> <STOLMS::>
IFIDN <MAP> <X> <STOLMX::>
	SOSGE	%UP'LDC+UPTLDC
	STOPCD
IFIDN <MAP> <T> <SETLMA::>
IFIDN <MAP> <S> <SETLMS::>
IFIDN <MAP> <X> <SETLMX::>
	MOVEM	P3,%UP'MAP+UPTLMA##(W) ;STORE BACK P3.
	HRRZ	T1,W
	CAILE	T1,VPMAX
	STOPCD
	ROT	T1,-1
	JUMPL	T1,%A
	HRLM	P4,%UP'MAP(T1)
	CLRPTW			;;IN CASE ITS IN CURRENT MAP
				;;(HAVE TO DO IT AFTER IN CASE INST FETCH DRAGS SLOT INTO PAGING MEMORY)
	POPJ	P,
%A:	HRRM	P4,%UP'MAP(T1)
	CLRPTW			;;IN CASE IST IN CURRENT MAP
	POPJ	P,
>;END STOLM MACRO DEFINITION

;NOW GENERATE THE ROUTINES

STOLM(T,T)
STOLM(S,S)
STOLM(X,T)			;%UPX USES %UPT+UPTLDC.
SUBTTL LMAP DATA ACQUISITION

COMMENT ;@@SUBROUTINE GETDPA
@@PURPOSE OBTAIN THE DISK ADDRESS ASSOCIATED WITH AN LMAP
SLOT, WHICH IS OBTAINED IN DIFFERENT WAYS DEPENDING ON
THE STATE OF THE LMAP SLOT.
@@ENTRY JOB NUMBER IN J, LMAP SLOT CONTENTS IN P3, P4
@@ACCUM PRESERVES T1 (IN CASE ATB ADDRESS IS IN IT)
ALL OTHER ACS EXCEPT T2-T4, PG.
@@TABLES SPT, PGY
@@GLOBAL
@@EXIT RETURNS DISK PAGE ADDRESS IN T2
@@RESTRICTIONS LMAP SLOT MUST NOT HAVE NON-EXISTENT STATUS.
@@FUNCTION IF SLOT NON-EXISTENT, CRASH.  IF SLOT IS ACTIVE,
GET DISK ADDRESS FROM PGYADR OF CORE ADDRESS IN P4.
IF SLOT IS NOT ACTIVE, GET DISK ADDRESS FROM SPT IF SLOT
HAS SHARED STATUS, FROM LMAP SLOT IF SLOT IS NON-SHARED.
@@ ;

GETDPA::TLNN	P3,LMMEXS	;EXISTS?
	STOPCD			;NO, CRASH
	TLNE	P3,LMPACT	;ACTIVE?
	JRST	GETDP3		;YES, GO GET FROM PGY TABLE

GETDP1:	JUMPGE	P3,GETDP2	;JUMP IF NON-SHARED
	LDB	T3,LM3SPB	;SHARED. GET SPT BASE
	LDB	T2,LM3SPO	;AND OFFSET
	ADDI	T3,SPTEN1(T2)	;COMPUTE SPT ENTRY ADDRESS
	MOVE	T2,SPTPNO(T3)	;GET DISK ADDRESS FROM SPT ENTRY
	JRST	GETDP4		;CHECK IT AND RETURN.

GETDP2:	LDB	T3,LM3HDA	;GET HIGH DISK ADDRESS FROM LMAP SLOT
	LDB	T2,UP4LDA	;GET LOW ORDER DISK ADDRESS
	LSH	T3,LMASRP	;POSITION HIGH ORDER
	IOR	T2,T3		;GET WHOLE ADDRESS IN T2
	JRST	GETDP4		;CHECK IT AND RETURN.

GETDP3:	HRRZ	PG,P4		;GET UPT SLOT CONTENTS
	ANDI	PG,17777	;JUST CORE ADDRESS
	LDB	T2,PGYADR	;GET DISK ADDRESS FROM PGY TABLE

GETDP4:	CAMN	T2,ADRNCT	;IF NO REAL DATA IN CP, THEN CRASH
	STOPCD			;TRYING TO GET GARBAGE DATA.
	POPJ	P,		;RETURN.
COMMENT ;@@SUBROUTINE GETATB
@@PURPOSE OBTAIN ACCESS TABLE ADDRESS FROM AN LMAP SLOT
@@ENTRY P3,P4 CONTAIN LMAP SLOT POINTER DATA
@@ACCUM PRESERVES ALL ACS EXCEPT T1 AND PG.
@@TABLES
@@GLOBAL
@@EXIT ATB ADDRESS IN T1. IF SLOT IS ACTIVE, PG HAS CP, ELSE IS UNCHANGED.
@@RESTRICTIONS LMAP SLOT MUST EXIST. CANNOT BE SUPER SLOT.
@@CALLS
@@FUNCTION IF SLOT IS UNSHARED AND NOT ON I/O CHAIN,
PICKUP ATB POINTER FROM LMAP SLOT.  IF SLOT IS ON I/O CHAIN,
FIND SLOT AT THE END OF THE I/O CHAIN AND USE THAT INSTEAD
OF CALLER'S SLOT TO FIND ATB ADDRESS. IF SLOT IS NOT IN I/O
CHAIN AND IS SHARED, GET ATB ADDRESS FROM PGYSPT AND SPT
IF ACTIVE, ELSE GET IT FROM LM3SPT AND SPT IF INACTIVE.
@@;

GETATB::TLNN	P3,LMPSUP	;CAN'T BE SUPER SLOT
	TLNN	P3,LMMEXS	;SLOT EXISTS?
	STOPCD			;NO, ERROR.

GETAT1:	JUMPGE	P3,GETAT3	;IF UNSHARED, GET FROM SLOT OR PGYATB.
	TLNN	P3,LMPACT	;SHARED. ACTIVE?
	JRST	GETAT2		;NO, GO GET FROM SLOT, THEN SPT
	HRRZ	PG,P4		;GET UPT SLOT
	ANDI	PG,17777	;JUST CORE PAGE ADDRESS
	LDB	T1,PGYSPB	;GET SPT TABLE BASE
	HRRZ	T1,SPTATB(T1)	;GET ATB ADDRESS FROM SPT
	POPJ	P,		;AND RETURN.

;SHARED, INACTIVE

GETAT2:	LDB	T1,LM3SPB	;GET SPT BASE ADDRESS FROM SLOT
	HRRZ	T1,SPTATB(T1)	;GET ATB ADDRESS FROM SPT
	POPJ	P,		;RETURN WITH ATB ADDR IN T1

;HERE IF UNSHARED.

GETAT3:	TLNN	P3,LMPACT	;ACTIVE?
	JRST	GETAT4		;NO, JUST GET FROM SLOT
	HRRZ	PG,P4		;YES, GET CORE PAGE ADDRESS
	ANDI	PG,17777
	LDB	T1,PGYATB	;GET ATB POINTER
	PJRST	CNVATP		;CONVERT TO ADDRESS AND RETURN.

GETAT4:	LDB	T1,LM3ATB	;GET ATB POINTER FROM LMAP SLOT
	PJRST	CNVATP		;CONVERT TO ADDRESS AND RETURN.
COMMENT ;@@SUBROUTINE GETCPA
@@PURPOSE GET CORE PAGE ADDRESS FROM AN ACTIVE LMAP SLOT
@@ENTRY P3,P4 CONTAIN LMAP SLOT CONTENTS
@@ACCUM PRESERVES ALL ACS
@@TABLES
@@GLOBAL
@@EXIT CORE PAGE NUMBER IN PG
@@RESTRICTIONS SLOT MUST BE ACTIVE
@@CALLS
@@FUNCTION IF SLOT IS INACTIVE, CRASH. ELSE GET CORE PAGE
ADDRESS FROM P4.
@@ ;

GETCPA::TLNN	P3,LMPACT	;ACTIVE?
	STOPCD			;NO, CRASH
	HRRZ	PG,P4		;GET UPT CONTENTS
	ANDI	PG,17777	;JUST CORE PAGE ADDRESS
	POPJ	P,		;RETURN WITH IT.

COMMENT ;@@SUBROUTINE GETCPX
@@PURPOSE GET CORE PAGE ADDRESS FROM AN LMAP SLOT (ACTIVE OR INACTIVE).
(IF LMAP SLOT IS ACTIVE, CAN TAKE A SHORT CUT AND AVOID CHT SEARCH.)
THIS ROUTINE EXISTS SEPARATELY FROM GETCPA BECAUSE THERE ARE
CALLERS OF GETCPA THAT KNOW SLOT IS SUPPOSED TO BE ACTIVE.
@@ENTRY P3,P4 CONTAIN LMAP SLOT CONTENTS
@@ACCUM DESTROYS T1-T4.
@@EXIT IF SLOT'S DP IS IN CORE, RETURNS SKIP WITH CP # IN PG.
IF SLOT'S DP IS NOT IN CORE, RETURNS NON-SKIP WITH C(PG) ZERO.
@@CALLS GETDPA, SRCCHT.
@@FUNCTION IF SLOT IS ACTIVE, PICKUP CP FROM P4 AND RETURN.
IF SLOT IS INACTIVE, CALL GETDPA TO GET DP, CALL SRCCHT
TO GET POSSIBLE CP NUMBER.
@@;

GETCPX::TLNN	P3,LMPACT	;SLOT ACTIVE?
	JRST	GETCP1		;NO, MUST DO IT THE HARD WAY.
	HRRZ	PG,P4		;GET MAP SLOT CONTENTS.
	ANDI	PG,17777	;JUST CP ADDRESS
	JRST	CPOPJ1		;AND GIVE SKIP RETURN.

GETCP1:	PUSHJ	P,GETDPA	;GET DP ADDRESS FOR SRCCHT
	PJRST	SRCCHT		;AND MAYBE GET CP IN PG, RETURN SKIP OR NON-SKIP.
COMMENT ;@@SUBROUTINE GETSPT
@@PURPOSE GET SPT ENTRY ADDRESS AND SPT POINTER FROM AN LMAP SLOT
@@ENTRY P3 AND P4 CONTAIN LMAP DATA
@@ACCUM USES T2. IF SLOT IS ACTIVE, PG GETS CP NUMBER, ELSE IS UNCHANGED.
@@EXIT SPT ENTRY ADDRESS IN T1, SPT POINTER IN T4.
@@RESTRICTIONS SLOT MUST NOT BE A SUPER SLOT
@@FUNCTION IF SUPER OR NOT SHARED, CRASH. ELSE IF ACTIVE,
GET SPT INFORMATION FROM PGY TABLE OF THE CORE PAGE.
IF NOT ACTIVE, GET THE SPT INFORMATION FROM THE LMAP SLOT.
@@;

GETSPT::SKIPGE	P3		;IF NOT SHARED SLOT OR
	TLNE	P3,LMPSUP	;ITS A SUPER SLOT,
	STOPCD			;BAD.
	TLNN	P3,LMPACT	;IF NOT ACTIVE,
	JRST	GETSP1		;GO GET THE STUFF FROM THE SLOT
	HRRZ	PG,P4		;GET CORE PAGE AND OTHER BITS
	ANDI	PG,17777	;JUST THE CORE PAGE NUMER IN PG
	LDB	T4,PGYSPT	;GET POINTER IN T4
	LDB	T1,PGYSPB	;GET BASE ADDRESS IN T1
	LDB	T2,PGYSPO	;OFFSET INTO ENTRIES IN T2
	ADDI	T1,SPTEN1(T2)	;COMPUTE ENTRY ADDRESS
	JUMPN	T4,CPOPJ	;AND GIVE RETURN IF IT WAS THERE.
	STOPCD			;SOMEONE FORGOT TO SET PGYSPT

GETSP1:	LDB	T4,LM3SPT	;GET POINTER IN T4
	LDB	T1,LM3SPB	;BASE OF SECTION IN T1
	LDB	T2,LM3SPO	;OFFSET INTO ENTRIES IN T2
	ADDI	T1,SPTEN1(T2)	;COMPUTE ENTRY ADDRESS
	JUMPN	T4,CPOPJ	;RETURN IF THERE WAS A POINTER
	STOPCD			;BAD SLOT FORMAT.
SUBTTL CORE PAGE GETTERS

COMMENT ;@@SUBROUTINE GETRES
@@PURPOSE USED BY SWAPPER TO GET A RESERVED PAGE TO START A SWAP IN
@@ENTRY CRSPGN, CAVPGN, ARSPGN SETUP.
@@ACCUM SMASHES T1-T4.
@@TABLES
@@GLOBAL
@@EXIT RETURNS WITH PAGE TO USE IN PG
@@RESTRICTIONS ONLY CALLED IF CALLER HAS PREVIOUSLY RESERVED
AT LEAST ONE PAGE BY CALLING SWPRES AND STILL HAS AT LEAST
ONE RESERVED PAGE LEFT.  CALLER MUST CAUSE PAGE TO CHANGE LISTS,
OR ELSE SOMEONE ELSE COULD GET SAME PAGE.
@@CALLS
@@FUNCTION IF CRSPGN NON-ZERO, DECREMENT IT,
INCREMENT CAVPGN, TAKE FIRST PAGE
ON CLEAN FREE LIST, TAKE OUT OF CHT AND GIVE GOOD RETURN.
IF CRSPGN IS ZERO AND CAVPGN IS NON-ZERO, ABANDON A RESERVED IN
PROGRESS PAGE (MUST BE ONE SINCE CALLER HAS RESERVED PAGES)
TAKE A CLEAN AVAILABLE PAGE, TAKE IT OUT OF CHT,
LEAVE CAVPGN INCREMENTED FOR IT AND RETURN.
@@;

GETRES::SKIPG	CRSPGN		;ANY CLEAN RESERVED PAGES?
	JRST	GETRE1		;NO, TRY FOR AN AVAILABLE ONE
	SOS	CRSPGN		;TAKE IT
	AOS	CAVPGN		;LEAVE THIS INCREMENTED, INCUSE DECREMENTS IT.
	HRRZ	PG,CFRLST	;GET FIRST PAGE ON CLEAN FREE LIST
	AOS	(P)		;GIVE GOOD RETURN AND
	JUMPN	PG,REMCHT	;TAKE OUT OF CHT AND RETURN.
	STOPCD			;SOMETHING IS NOT RIGHT.

GETRE1:	SKIPG	CAVPGN		;CAN WE USE A CLEAN AVAILABLE?
	POPJ	P,		;NO, FAIL.
				;YES, LEAVE IT INCREMENTED
	AOS	CAPPGN		;AND TRANSFER A PAGE FROM RES SOP TO
				; CLEAN AVAIL SOP.
	SOSGE	RIPPGN
	STOPCD			;COUNTS AND LIST DID NOT MATCH
	HRRZ	PG,CFRLST	;GIVE CALLER FIRST PAGE ON LIST
	AOS	(P)		;GIVE SUCCESS RETURN
	JUMPN	PG,REMCHT	;TAKE PAGE OFF CHT IF ITS THERE
				; AND RETURN
	STOPCD			;SOMETHING WENT WRONG.
COMMENT ;@@SUBROUTINE GETFRE
@@PURPOSE GET NEXT CLEAN AVAILABLE PAGE NUMBER IN PG
@@ENTRY CAVPGN SETUP CORRECTLY
@@ACCUM SMASHES T1-T4.
@@TABLES
@@GLOBAL
@@EXIT RETURNS CORE PAGE NUMBER IN PG, CAVPGN STILL INCREMENTED FOR IT.
@@RESTRICTIONS CALLER MUST CHANGE RETURNED CORE PAGE'S LIST
IMMEDIATELY, OR ELSE ANOTHER CALLER WILL GET SAME PAGE.
@@CALLS
@@FUNCTION IF NO CLEAN AVAILABLE PAGES LEFT, ERROR RETURN.
ELSE RETURN FIRST CORE PAGE ON CLEAN FREE LIST IN PG.
@@ ;

GETFRE::SKIPG	CAVPGN		;ANY TO GET?
	POPJ	P,		;NO, ERROR
				;LEAVE CAVPGN INCREMENTED.
	HRRZ	PG,CFRLST
	AOS	(P)		;SET FOR SUCCESS RETURN AND
	JUMPN	PG,REMCHT	;TAKE OFF CHT IF ITS THERE.
	STOPCD			;LIST WAS EMPTY, BUT COUNT WAS UP.


COMMENT;@@SUBROUTINE INCCAV
@@PURPOSE EITHER RETURN CLEAN FREE PAGE TO I/O PAGE POOL
OR CLEAN AVAILABLE POOL, DEPENDING ON STATE OF IOPPGN.
CALLED FROM DECUSE, REMCHT, SODCHK, SIDCHK. SWIBAD DOES NOT
CALL (SEE COMMENT THERE.)
@@ENTRY IOPPGN, CAVPGN SETUP
@@ACCUM USES T1.
@@EXIT RETURN WITH EITHER IOPPGN OR CAVPGN ADJUSTED.
ALWAYS NON-SKIP RETURN.
@@FUNCTION IF NUMBER OF CORE PAGES RESERVED FOR "I/O"
NOT UP TO QUOTA, DECREMENT IOPPGN (ONE MORE IO PAGE AVAIL)
AND RETURN, ELSE INCREMENT CAVPGN AND RETURN.
@@;

INCCAV::MOVM	T1,IOPPGN	;GET NUMBER OF IO PAGES HAVE NOW.
	CAMGE	T1,IOPQTA	;SKIP IF HAVE ENOUGH ALREADY.
	SOSA	IOPPGN		;NOT ENOUGH, GIVE ONE TO I/O POOL.
	AOS	CAVPGN		;ENOUGH, GIVE ONE TO AVAILABLE POOL.
	POPJ	P,		;RETURN.
SUBTTL CORE PAGE LIST HANDLING

COMMENT \
AT ANY GIVEN TIME, A PAGE CAN BE IN ONE OF THE FOLLOWING LISTS:

CFRLST - CLEAN FREE LIST. THIS LIST IS DIVIDED INTO TWO SETS,
  WHOSE MEMBERS ARE REPRESENTED IN THE COUNTS CAVPGN AND
  CRSPGN. CAVPGN REPRESENTS THE CLEAN AVAILABLE PAGES, AND
  CRSPGN REPRESENTS THE CLEAN RESERVED PAGES, THAT IS, THOSE
  PAGES SET ASIDE FOR SWAPPING ACTIVITY.  THERE IS ONLY
  ONE CLEAN FREE LIST INSTEAD OF A CLEAN ACTIVE AND A CLEAN
  RESERVED LIST, SINCE IT IS NOT USEFUL TO DISTINGUISH
  ACTIVE FROM RESERVED PAGES ON A PAGE BY PAGE BASIS.  ALL THAT
  MATTERS IS THAT A CERTAIN NUMBER OF CLEAN FREE PAGES
  BE SET ASIDE FOR USE BY JOBS THAT HAVE BEEN PROMISED PAGES TO
  SWAP THINGS INTO.

DFRLST - DIRTY FREE LIST.  PAGES GET ONTO THE DIRTY FREE LIST
  WHEN SOMEONE THAT WAS USING THEM MADE THEM DIRTY AND THEN
  EVERYONE REMOVED THE PAGE FROM THEIR WORKING SETS, MAKING
  THE PAGE FREE. (FILE PAGES THAT ARE REMOVED, RATHER THAN
  JUST TAKEN OUT OF THE WORKING SET, ARE NOT FOUND HERE, SINCE
  THEY MUST BE WRITTEN BACK TO THE DISK BEFORE THE REMOVE CALL
  RETURNS TO THE CALLER. PRIVATE PAGES REMOVED FROM ALL JOBS'
  ADDRESS SPACES ARE NOT FOUND HERE EITHER, SINCE THE DATA
  THEY CONTAIN IS JUST THROWN AWAY BY MARKING THE CORE PAGE CLEAN.
  DFRPGN CONTAINS THE NUMBER OF PAGES ON THIS LIST.

USELST - THIS IS WHERE PAGES, BOTH CLEAN AND DIRTY, ARE FOUND IF
  THERE IS NO SWAP OUT IN PROGRESS AND THE USE COUNT FOR
  THE CORE PAGE IS NON-ZERO.

SPRLST - SWAP IN PROGRESS LIST. BOTH SWAP IN IN PROGRESS AND
  SWAP OUT IN PROGRESS PAGES ARE FOUND HERE.

SODLST - SWAP OUT DONE LIST. DISK INTERRUPT LEVEL TRANSFERS
  PAGES FROM SPRLST TO HERE WHEN A SWAP OUT COMPLETES FOR THEM.

SIDLST - SWAP IN DONE LIST. SAME AS SWAP OUT DONE LIST, BUT FOR
  SWAP IN COMPLETE PAGES.

\
;DEFINITIONS OF LIST HEADERS, COUNTS

DEFINE NXTLST(A)<
	XP A'.N,ZZ
	ZZ==ZZ+1
A'LST::0>

	ZZ==0		;START WITH LIST 0

LSTLST::
NXTLST(CFR)
NXTLST(DFR)
NXTLST(USE)
NXTLST(SOD)
NXTLST(SID)
NXTLST(SPR)

	PURGE SPRLST	;ORIGINATES IN UNIT DATA BLOCK, NOT HERE.

;COUNTS

CAVPGN::0		;CLEAN AVAILABLE COUNT
CRSPGN::0		;CLEAN RESERVED COUNT
DFRPGN::0		;DIRTY FREE COUNT

;I/O CORE PAGE LOCATIONS.

EXTERN M.IQTA

IOPQTA::EXP M.IQTA		;NUMBER OF I/O PAGES TO RESERVE
IOPPGN::EXP -M.IQTA		;-VE NUMBER OF I/O PGES AVAILABLE.
COMMENT ;@@SUBROUTINE PUTLST/PUTLSB
@@PURPOSE TAKE A PHYSICAL CORE PAGE OFF ONE LIST AND PUT
IT ONTO THE BACK/FRONT OF A NEW LIST.
@@ENTRY ENTER AT PUTLST TO PUT PAGE AT END OF LIST,
AT PUTLSB TO PUT PAGE AT BEGINNING OF LIST.
T4 CONTAINS CORE PAGE LIST CODE (???.N, WHERE ???
REPRESENTS USE, CFR, DFR, SPR, SOD, SID.), PG CONTAINS
CORE PAGE NUMBER TO TRANSFER.
@@ACCUM DESTROYS ALL T ACS. PRESERVES PG, ALL OTHER ACS.
@@TABLES PGY TABLES, LSTLST (TRANSLATION FROM LIST CODE
TO LIST HEAD ADDRESS TABLE)
@@GLOBAL
@@EXIT CORE PAGE NUMBER STILL IN PG. CORE PAGE ON THE NEW LIST.
@@RESTRICTIONS CANNOT BE USED TO PUT PAGE ON SWAP IN PROGRES
LIST OR TAKE IT OFF SWAP IN PROGRESS LIST, SWPENQ AND
SWPINT DO THIS BY HAND.
@@CALLS REMLST (REMOVE CORE PGE FROM A LIST)
@@FUNCTION CALLS REMLST TO REMOVE THE PAGE FROM ITS OLD
LIST. INSERT THE CORE PAGE AT THE END OF THE NEW LIST
(IMPORTANT SO THAT FREE CORE PAGES CIRCULATE, IN CASE A JOB
MAPS AND REMOVES A SINGLE PAGE, SO THAT SAME CORE
PAGE DOES NOT GET USED OVER AND OVER AGAIN)
@@;

PUTLST::CAIN	T4,SPR.N	;TRYING TO PUT ONTO SPR LIST?
	STOPCD			;YES, ONLY SWPENQ DOES THAT.
	PUSHJ	P,REMLST	;TAKE CORE PAGE OFF OLD LIST
	DPB	T4,PGYLST	;SET NEW LIST NUMBER

	HLRZ	T1,LSTLST(T4)	;GET OLD LAST MEMBER
	JUMPE	T1,PUTLS2	;JUMP IF LIST IS EMPTY
	DPB	T1,PGYBPL	;NEW LAST POINTS BACK TO OLD LAST
	EXCH	T1,PG		;ADDRESS OLD LAST
	DPB	T1,PGYFPL	;OLD LAST POINTS FORWARD TO NEW LAST
	EXCH	T1,PG		;NEW PAGE BACK INTO PG
	HRLM	PG,LSTLST(T4)	;NEW LAST POINTED TO BY LH OF LSTLST
	SETZ	T1,		;CLEAR OUT FORWARD LINK OF NEW LAST
	DPB	T1,PGYFPL	;
	POPJ	P,		;AND RETURN.

PUTLSB::CAIN	T4,SPR.N	;ERROR IF MESSING WITH I/O LIST
	STOPCD
	PUSHJ	P,REMLST
	DPB	T4,PGYLST	;NEW LIST NUMBER
	HRRZ	T1,LSTLST(T4)	;GET OLD FIRST
	JUMPE	T1,PUTLS2	;IF EMPTY, MAKE THIS THE ONLY ENTRY
	DPB	T1,PGYFPL	;OK,NEW FIRST POINTS TO OLD FIRST
	EXCH	T1,PG		;ADDRESS OLD FIRST
	DPB	T1,PGYBPL	;OLD FIRST POINTS BACK TO NEW FIRST
	EXCH	T1,PG		;GET NEW PAGE BACK INTO PG
	HRRM	PG,LSTLST(T4)	;NEW FIRST IS FIRST POINTER
	SETZ	T1,		;CLEAR OUT BACK LINK IN NEW FIRST
	DPB	T1,PGYBPL
	POPJ	P,		;AND RETURN


;HERE IF LIST WAS EMPTY. BOTH HALVES OF HEADER POINT TO ONLY PAGE
; ON THE LIST, BOTH FPL AND BPL ARE ZERO

PUTLS2:	DPB	T1,PGYFPL	;T1 IS ZERO. ZERO PGYFPL
	DPB	T1,PGYBPL	; AND PGYBPL, THIS IS FIRST AND LAST MEMBER
	MOVE	T1,PG		;COPY OF PAGE NUMBER
	HRLS	T1		;NUMBER,,NUMBER
	MOVEM	T1,LSTLST(T4)	;STORE THIS PAGE AS FIRST AND LAST
	POPJ	P,		;AND RETURN.
;ROUTINE TO REMOVE A CORE PAGE FROM THE LIST IT IS ON
; CURRENTLY.  ENTER WITH PG CONTAINING THE CORE PAGE NUMBER,
; PGYLST CONTAINING THE CURRENT LIST CODE.  SMASHES
; ALL T ACS EXCEPT T4, WHICH IS PRESERVED.

REMLST::LDB	T1,PGYBPL	;GET OLD LAST IN T1
	LDB	T2,PGYFPL	;GET OLD NEXT IN T2
	LDB	T3,PGYLST	;GET LIST NUMBER IN T3
	CAIN	T3,SPR.N	;TRYING TO TAKE OFF SWAP IN PROG LIST?
	STOPCD			;YES, ERROR, THIS IS DONE SPECIALLY

;FIRST POINT OLD LAST PAGE FORWARD TO OLD NEXT PAGE.  IF THERE IS
; NO OLD LAST PAGE (PAGE BEING REMOVED IS THE FIRST IN THE
; LIST) THEN POINT FORWARD HEADER POINTER AT OLD NEXT.
; (IF OLD NEXT DOES NOT EXIST, I.E. REMOVED PAGE IS ONLY ONE,
; WILL STORE A ZERO IN FORWARD HEADER POINTER).

	JUMPN	T1,REMLS1	;JUMP IF OLD LAST EXISTS.
	HRRM	T2,LSTLST(T3)	;DOESN'T. HEADER FORWARD POINTER
	JRST	REMLS2		; POINTS TO OLD NEXT PAGE.

REMLS1:	EXCH	T1,PG		;MAKE OLD LAST "ADDRESSABLE"
	DPB	T2,PGYFPL	;OLD LAST POINTS FORWARD TO OLD NEXT
	EXCH	T1,PG		;GET PAGES BACK WHERE THEY BELONG

;NOW POINT OLD NEXT PAGE BACKWARD TO OLD LAST PAGE. IF THERE
; IS NO OLD NEXT PAGE, THEN POINT BACKWARD HEADER POINTER
; TO OLD LAST PAGE, WHICH IS THE NEW LAST PAGE ON THE LIST.
; IF THERE IS NO OLD LAST PAGE EITHER, BACKWARD HEADER
; POINTER IS SET TO ZERO.

REMLS2:	JUMPN	T2,REMLS3	;JUMP IF THERE IS AN OLD NEXT PGE
	HRLM	T1,LSTLST(T3)	;NOT ONE. BACKWARD HEADER POINTER
	POPJ	P,		; POINTS TO OLD LAST PAGE, IF THERE
				; IS ONE. RETURN.

REMLS3:	EXCH	T2,PG		;MAKE OLD NEXT PAGE "ADDRESSABLE"
	DPB	T1,PGYBPL	;OLD NEXT POINTS BACK TO OLD LAST
	EXCH	T2,PG		;RESTORE REMOVED PAGE TO PG
	POPJ	P,		;AND RETURN.
SUBTTL CORE PAGE USE COUNT HANDLING
COMMENT ;@@SUBROUTINE INCUSE
@@PURPOSE INCREMENT CORE PAGE USE COUNT, TRANSFER CORE PAGE
TO NEW LIST IF NECESSARY, ADJUST CAVPGN, DFRPGN, RIPPGN, CAPPGN
@@ENTRY PG CONTAINS THE PHYSICAL CORE PAGE NUMBER (INDEX TO ITS
PGY ENTRY), CAVPGN (NUMBER OF CLEAN AVAILABLE PAGES)
CONTAINS NUMBER OF CLEAN AVAILABLE PAGES, DFRPGN CONTAINS
NUMBER OF DIRTY FREE PAGES, RIPPGN CONTAINS NUMBER OF SWAP
OUT IN PROGRESS PAGES THAT ARE RESERVED, CAPPGN CONTAINS
NUMBER OF CLEAN AVAILABLE SWAP OUT IN PROGRESS PAGES.
@@ACCUM
@@TABLES
@@GLOBAL
@@EXIT RETURNS WITH PG PRESERVED
@@RESTRICTIONS IF SWAP OUT IS IN PROGRESS AND PGYRES IS SET,
CALLER IS RESPONSIBLE FOR MAKING SURE CAPPGN IS NOT ZERO.
IF PAGE IN PG IS CLEAN FREE, CALLER IS RESPONSIBLE FOR
MAKING SURE CAVPGN IS NON-ZERO.
@@CALLS
@@FUNCTION INCREMENT USE COUNT. IF USE COUNT IS GREATER THAN ONE,
JUST RETURN (PAGE IS ALREADY IN USE, SO OK). IF SWAP IN
IS IN PROGRESS, JUST RETURN. IF SWAP OUT IN PROGRESS
AND PAGE IS DIRTY, ITS AVAILABLE SO RETURN. IF SWAP OUT
IS IN PROGRESS AND PAGE IS CLEAN, AND CAPPGN IS NON-ZERO,
DECREMENT CAPPGN AND RETURN. IF PAGE IS FREE WITH NO SWAPPING
IN PROGRESS, IF ITS DIRTY, DECREMENT DFRPGN, PUT ON
USE LIST AND RETURN. IF ITS CLEAN AND CAVPGN IS NON-ZERO,
DECREMENT CAVPGN PUT ON USE LIST AND RETURN.
@@ ;

INCUSE::AOS	T1,@PGYUSE	;INCREMENT PGYUSE DIRECTLY
	TRNN	T1,USEMAX	;OVERFLOW TO ZERO?
	STOPCD			;YES, CRASH
	TRNE	T1,USEMAX-1	;IS IT EQUAL TO 1?
	POPJ	P,		;NO, WE'RE THRU.
	LDB	T1,PGYSTS	;GET CP STATUS
	TRNE	T1,PGPSIP	;SWAP IN IN PROGRESS?
	POPJ	P,		;YES, JUST RETURN.
	TRNE	T1,PGPSOP	;SWAP OUT?
	JRST	INCUS1		;YES, SEE IF ITS DIRTY TOO
	TRNN	T1,PGPDRT	;WAS FREE.
	SOSA	CAVPGN		;CLEAN FREE
	SOS	DFRPGN		;DIRTY FREE
	MOVEI	T4,USE.N	;PUT CP ONTO USE LIST AND 
	PJRST	PUTLST		;RETURN.

INCUS1:	TRNE	T1,PGPDRT	;SWAP OUT IN PROG. DIRTY?
	POPJ	P,		;YES, CAN JUST TAKE IT.
	SOSGE	CAPPGN		;CLEAN, CAN ONLY HAVE IT IF CAPPGN
	STOPCD			; IS UP. ELSE CALLER GOOFED.
	POPJ	P,		;RETURN.
COMMENT ;@@SUBROUTINE DECUSE
@@PURPOSE DECREMENT CORE PAGE USE COUNT, TRANSFER CORE PAGE TO
FREE LIST IF COUNT GOES TO ZERO.
@@ENTRY PG CONTAINS CORE PAGE NUMBER OF CORE PAGE
@@ACCUM USES T1-T4.
@@TABLES
@@GLOBAL
@@EXIT PG CONTAINS CORE PAGE NUMBER DECUSE WAS CALLED WITH
@@RESTRICTIONS PAGE MUST NOT HAVE DIRECT I/O IN PROGRESS OR
HAVE ANY SLOTS STILL ON LMA CHAIN.
@@CALLS
@@FUNCTION DECREMENT CORE PAGE USE COUNT. IF SWAP IN
IN PROGRESS, RETURN. IF CORE PAGE IS NOW FREE, ZERO PGYATB AND
PGYSPT. IF SWAP OUT IS IN PROGRESS AND PAGE IS
DIRTY, JUST RETURN. IF SWAP OUT IS IN PROG AND PAGE IS
CLEAN, INCREMENT CLEAN AVAILABLE IN PROGRESS COUNT AND
RETURN.  IF CORE PAGE USE COUNT STILL NON-ZERO,
RETURN. ELSE, PAGE IS NOW FREE. IF CLEAN, INCREMENT CLEAN
AVAILABLE COUNT AND PUT ONTO CLEAN FREE LIST. IF DIRTY,
INCREMENT DIRTY FREE COUNT AND PUT ONTO DIRTY FREE LIST.
RETURN.
@@ ;

DECUSE::SOS	T2,@PGYUSE	;DECREMENT PGYUSE DIRECTLY
	TRCN	T2,USEMAX	;IF WENT TO ZERO,
	JRST	DECUS0		;THEN FIX THINGS.
	TRCN	T2,USEMAX	;DID IT GO TO ALL ONES?
	STOPCD			;YES, UNDERFLOW.
	POPJ	P,		;NO, JUST RETURN, USE COUNT STILL UP.

DECUS0:	SETZ	T2,		;ZERO OUT
	DPB	T2,PGYATB	;PGYATB AND PGYSPT
	DPB	T2,PGYSPT
	LDB	T1,PGYDIO	;CRASH IF DIO ON OR
	LDB	T2,PGYLMJ	;STILL AN ACTIVE SLOT
	SKIPN	T1
	SKIPE	T2
	STOPCD
	LDB	T1,PGYSTS	;GET CP STATUS BITS
	TRNE	T1,PGPSIP	;SWAP IN GOING?
	POPJ	P,		;YES, DON'T TOUCH LISTS AND COUNTS
	ANDI	T1,PGPSOP!PGPDRT ;THESE MUST BE 1B34 AND 1B35!
	XCT	[JRST DECUS1	;CLEAN FREE
		 JRST DECUS2	;DIRTY FREE
		 AOS  CAPPGN	;CLEAN IN PROGRESS
		 POPJ P,](T1)	;DIRTY IN PROGRESS
	POPJ	P,		;FOR THE AOS.

;HERE FOR CLEAN FREE PAGES

DECUS1:	MOVEI	T4,CFR.N
	PUSHJ	P,INCCAV	;EITHER MAKE AVAILABLE OR IN I/O POOL.
	PJRST	PUTLST

;HERE FOR DIRTY FREE PGES

DECUS2:	MOVEI	T4,DFR.N
	AOS	DFRPGN
	PJRST	PUTLST
SUBTTL WORKING SET BIT HANDLING

;ROUTINES TO SET, CLEAR, TEST EITHER USER WORKING SET OR
; MONITOR WORKING SET BITS.  INCREMENT OR DECREMENT THE
; CORRECT COUNT, IF APPROPRIATE.
; CALL WITH VP NUMBER IN RH(W) (LH CAN BE ANYTHING), JOB IN J, UPT ADDRESSABLE THRU %UPT.
; ROUTINE NAMES:
; SET - SETUWS, SETMWS, SETSTL
; CLEAR - CLRUWS, CLRMWS
; TEST - TSTUWS, TSTMWS


SETUWS::LDB	T3,JBYUWS	;GET SIZE
	AOS	T3
	CAILE	T3,1000		;TOO HIGH?
	STOPCD			;YES, CRASH.
	DPB	T3,JBYUWS
	MOVE	T4,[IORM T2,%UPT+UPTUWB(T1)]
	JRST	FBITWS

SETMWS::TRNN	W,777000		;USER PAGE?
	JRST	SETMW1			;YES.
	LDB	T3, JBYPPP	;NO -- ADJUST JBYPPP TOO
	AOS	T3
	CAILE	T3, 77
	  STOPCD
	DPB	T3, JBYPPP
	JRST	SETMW2
SETMW1:	HRRZ	T1, W
	IDIVI	T1, AGECPW	;T1/ AGE CELL WD #, T2/ CELL IN WD #
	LDB	T2, AGEPTR(T2)	;T2/ AGE
	CAML	T2, AGEELD
	AOS	%UPT+UPTELD
	CAML	T2, AGEMAT
	AOS	%UPT+UPTMAT	;ADJUST AGE COUNTS
SETMW2:	LDB	T3, JBYMWS
	AOS	T3
	CAILE	T3, 1777
	  STOPCD
	DPB	T3, JBYMWS
	MOVE	T4,[IORM T2,%UPT+UPTMWB(T1)]
	JRST	FBITWS

SETSTL::MOVE	T4,[IORM T2,STLBTM(T1)] ;SET BIT IN STOLEN BIT MAP.
	JRST	FBITWS

CLXUWS::SKIPA	T4,[%UPX]
CLRUWS::MOVEI	T4,%UPT
	LDB	T3,JBYUWS
	SOSGE	T3
	STOPCD
	DPB	T3,JBYUWS
	ADD	T4,[ANDCAM T2,UPTUWB(T1)] ;MAKE INTO BIT CLEARING INSTRUCTION
	JRST	FBITWS

CLXMWS::SKIPA	T4,[%UPX]		;DO EVERYTHING TO UPX
CLRMWS::MOVEI	T4,%UPT		;DO EVERYTHING TO %UPT
	TRNN	W,777000		;USER PAGE?
	JRST	CLRMW1		;YES.
	LDB	T3, JBYPPP	;NO -- ADJUST JBYPPP TOO
	SOSGE	T3
	  STOPCD
	DPB	T3, JBYPPP
	JRST	CLRMW2
CLRMW1:	HRRZ	T1, W
	IDIVI	T1, AGECPW	;T1/ AGE CELL WD #, T2/ AGE CELL IN WD
	LDB	T2, AGEPTR(T2)	;T2/ AGE
	CAML	T2, AGEMAT
	SOS	UPTMAT(T4)
	CAML	T2, AGEELD
	SOS	UPTELD(T4)	;ADJUST AGE COUNTS
CLRMW2:	LDB	T3,JBYMWS
	SOSGE	T3
	STOPCD
	DPB	T3,JBYMWS
	ADD	T4,[ANDCAM T2,UPTMWB(T1)]
	JRST	FBITWS

TSXUWS::SKIPA	T4,[TDNN T2,%UPX+UPTUWB(T1)]
TSTUWS::MOVE	T4,[TDNN T2,%UPT+UPTUWB(T1)]
	JRST	FBITWS

TSXMWS::SKIPA	T4,[TDNN T2,%UPX+UPTMWB(T1)]
TSTMWS::MOVE	T4,[TDNN T2,%UPT+UPTMWB(T1)]
	JRST	FBITWS

FBITWS:	HRRZ	T1,W		;GET VP NUMBER
	CAILE	T1,VPUMAX	;CONTEXT PGES NOT ALLOWED
	STOPCD			;NOT IN RANGE
	IDIVI	T1,^D36		;GET WORD INDEX IN T1, BIT IN T2
	MOVE	T2,BITTBL(T2)	;FROM BIT NUMBER TO ACTUAL BIT
	XCT	T4		;SET CLEAR OR TEST
	POPJ	P,		;NON-SKIP
	JRST	CPOPJ1		;SKIP.
;ROUTINE TO SCAN ADDRESS SPACE BIT TABLE
; AND RETURN FIRST PAGE GREATER THAN OR EQUAL TO
; VIRTUAL PAGE NUMBER IN W. CALLED AS FOLLOWS:
;	JSP	F,NXTUWS	;THE FIRST TIME
;	  <NO MORE PAGES IN RANGE>
;	<NEXT PAGE IN W>
;		.
;		.
;	JRST	(M)		;GO FOR NEXT PAGE
;	   OR
;	JSP	F,FINXWS	;IF DON'T WANT TO SCAN ANYMORE
;
;IF THE CALLER DOES NOT DESIRE TO SCAN ANY MORE PAGES
; AFTER HAVING RECEIVED A PAGE FROM NXTUWS, CALLER MUST
; CALL FINXWS (JSP F,FINXWS) TO FIX UP STACK, UPON WHICH
; SOME THINGS ARE SAVED.  NO NEED TO CALL FINXWS AFTER
; GETTING NON-SKIP RETURN.

NXTSTL::MOVE	T3,[STLBTM(T4)]	;EFFECTIVE ADDRESS OF STOLEN BIT TABLE.
	MOVSI	T4,-<VPMAX+^D35>/^D36 ;AOBJN POINTER
	JRST	NXTWS1		;GO TO IT.

NXTUWS:	MOVE	T3,[%UPT+UPTUWB(T4)] ;EFFECTIVE ADDRESS OF BITS
	MOVSI	T4,-<^D512+^D35>/^D36 ;GET AOBJN POINTER TO TABLE
	JRST	NXTWS1		;JOIN COMMON CODE

NXTMWS::SKIPA	T3,[%UPT+UPTMWB(T4)]	;E FOR MWS
NXSMWS::MOVE	T3,[%UPS+UPTMWB(T4)]	;IF UPT IS IN %UPS
	MOVSI	T4,-<VPMAX+^D35>/^D36 ;GET AOBJN POINTER

NXTWS1:	JUMPE	W,NXTWS2	;JUMP IF SCANNING FROM PAGE 0
	MOVE	T1,W		;GET COPY OF STARTING PAGE
	IDIVI	T1,^D36		;GET WORD AND BIT NUMBER OF THAT PAGE
	HRLS	T1		;GET WORD NUMBER,,WORD NUMBER
	ADD	T4,T1		;ADJUST AOBJN POINTER (DO A FEW AOBS)
	MOVE	U,@T3		;GET THE RIGHT WORD FULL OF BITS
	LSH	U,(T2)		;REPOSITION TO THE VP CALLED WITH
	SOJA	W,NXTWS6	;W MUST BE ONE LESS THAN PAGE WHOSE
				; BIT IS IN BIT 0 OF U. GO SEE
				; IF ANY MORE 1S LEFT AT ALL.

NXTWS2:	SKIPN	U,@T3		;PICKUP A WORD FULL OF BITS
	JRST	NXTWS5		;NO ONES IN IT
	MOVE	W,PGENUM(T4)	;GET PAGE NUMBER - 1 THIS WORD STARTS WITH
NXTWS3:	JFFO	U,.+2		;FIND A ONE
	JRST	NXTWS5		;RAN OUT
	LSH	U,1(T1)		;GET RID OF THE ONE WE JUST FOUND
	ADDI	W,1(T1)		;ADJUST W TO REPRESENT BIT JUST FOUND
NXTWS4:	PUSH	P,T3		;SAVE BIT WORD EFFECTIVE ADDRESS
	PUSH	P,T4		;SAVE AOBJN POINTER
	PUSH	P,U		;SAVE SHIFTED BIT WORD
	JSP	M,1(F)		;CALL THE CALLER BACK
	POP	P,U		;RESTORE BIT WORD, ETC.
	POP	P,T4
	POP	P,T3
NXTWS6:	JUMPN	U,NXTWS3	;IF MORE BITS TO LOOK AT, LOOK.
NXTWS5:	AOBJN	T4,NXTWS2	;STEP TO NEXT WORD
	JRST	(F)		;NO BITS LEFT, JUST GIVE NON-SKIP RETURN

;JSP F, HERE IF THROUGH SCANNING FOR NOW

FINXWS::POP	P,U
	POP	P,T4		;THESE WERE LEFT ON STACK
	POP	P,T3		;WHEN NXT?WS CALLED BACK
	JRST	(F)		;RETURN.

;TABLE TRANSLATING BIT TABLE WORD NUMBER TO PAGE NUMBER -1

	ZZ==-1		;START WITH -1

PGENUM:
REPEAT <VPMAX+^D35>/^D36,<
	ZZ
	ZZ==ZZ+^D36
>
;CO-ROUTINE TO SCAN THROUGH THE LMA CHAIN FOR CORE PAGE WHOSE
; NUMBER IS IN PG. RETURNS WITH P3,P4 SET TO LMAP SLOT CONTENTS
; OF NEXT LMAP ON CHAIN, J JOB NUMBER, W VIRTUAL PAGE NUMBER.
; CALLER IS REQUIRED TO CONTINUE CALLING SCNLMC UNTIL THE
; NON-SKIP RETURN IS GIVEN, SINCE SCNLMC LEAVES THINGS ON THE
; STACK WHEN IT CALLS THE CALER BACK.

SCNLMC::LDB	J,PGYLMJ	;GET FIRST JOB NUMBER IN CHAIN
	JUMPE	J,(F)		;NON-SKIP IF LMA CHAIN EMPTY
	LDB	W,PGYLMV	;GET VP NUMBER
	SETZM	UPSJOB		;FORCE NEW SETUP OF %UPS

SCNLM1:	PUSHJ	P,MAPUPS	;MAKE NEXT LMAP ADDRESSABLE
	PUSHJ	P,GETLMS	;GET LMAP SLOT DATA IN P3,P4
	LDB	T1,LM3LMV	;GET NEXT ON CHAIN NOW IN CASE THIS
	PUSH	P,T1		;CHANGES
	LDB	T1,LM3LMJ	;AND J
	PUSH	P,T1
	JSP	M,1(F)		;CALL THE CALLER, GIVE SKIP RETURN
	PUSHJ	P,STOLMS	;WHO MUST RETURN HERE (WE HAVE STUFF
				; ON THE STACK) STORE P3,P4
	POP	P,J		;GET NEXT LMAP SLOT
	POP	P,W		;DESCRIPTOR IN J AND W
	JUMPN	J,SCNLM1	;GO IF THERE IS ONE
	JRST	(F)		;NO MORE, GIVE NON-SKIP RETURN

;HERE IF DON'T WANT TO SCAN LMA CHAIN ANYMORE

FINLMC::PUSHJ	P,STOLMS	;PUT BACK POSSIBLY MODIFIED LMAP SLOT
	POP	P,T1		;TAKE JUNK OFF STACK
	POP	P,T1
	JRST	(F)		;AND RETURN.
SUBTTL I/O WAITING FOR PAGES

COMMENT ;@@SUBROUTINE REMWAT
@@PURPOSE WAIT UNTIL ALL I/O IS CLEAR FOR A CORE PAGE.
CALLED FROM REMOVE. CALLERS THAT ONLY NEED I/O OF
A CERTAIN TYPE TO FINISH, MAYBE ONLY ONCE (VALIDATE) SHOULD
CALL PAGWAT THEMSELVES, CHECKING FOR
THE CORRECT I/O CONDITION THAT THEY NEED TO FINISH.
@@ENTRY CORE PAGE NUMBER IN PG, JOB NUMBER IN J
@@ACCUM USES T1.
@@EXIT ALL I/O FOR CP GUARANTEED TO BE OFF.
@@RESTRICTIONS CALLER MUST STORE LMAP SLOT CONTENTS BACK
IN CASE SWAPPER DEACTIVATES THE SLOT.
@@FUNCTION IF ALL I/O CLEAR FOR PAGE, RETURN. ELSE
CALL PAGWAT. UPON RETURN FROM WAIT, CHECK I/O AGAIN.
@@;

REMWAT::LDB	T1,PGYSIO	;ANY SWAP I/O?
	JUMPN	T1,REMWT1	;YES, GO WAIT
	LDB	T1,PGYDIO	;OR DIRECT I/O?
	JUMPE	T1,CPOPJ	;NO, ALL I/O GONE, RETURN.
REMWT1:	PUSH	P,J		;Save target frame
	MOVE	J,JOB		;Make sure right job goes into page wait
	PUSHJ	P,PAGWAT	;WAIT FOR WHATEVER IS GOING TO FINISH
	POP	P,J		;Restore target frame
	JRST	REMWAT		;AND MAKE SURE NO OTHER I/O IS GOING.

COMMENT ;@@SUBROUTINE PAGWAT
@@PURPOSE WAIT UNTIL ALL I/O IS INACTIVE FOR A CP.
CALLED FROM DEALMS, REMOVE.
@@ENTRY CORE PAGE IN PG, JOB IN J
@@ACCUM USES T1. PRESERVES PG,J.
@@EXIT RETURNS WHEN I/O THAT WAS IN PROGRESS FOR PAGE
@@RESTRICTIONS ONLY CALLED FOR CURRENTLY RUNNING JOB AT
UUO LEVEL.
AT TIME OF CALL COMPLETES. MAY BE ANOTHER I/O OPERATION IN
PROGRESS AGAIN, SO CALLER MUST CHECK ALL I/O FLAGS
AGAIN. WHEN THEY ARE CLEAR, CALLER CAN PROCEED.
@@RESTRICTIONS CALLER MUST NOT RESCHEDULE
AFTER FINALLY GETTING THE PAGE WITH NO I/O.
CALLER MUST STORE LMAP SLOT CONTENTS BACK IN CASE
SWAPPER DEACTIVATES THE SLOT.
@@FUNCTION TURN PIS OFF AND MAKE SURE SOME KIND OF I/O IS
STILL GOING FOR THE PAGE (COULD INTERRUPT AND CALL PAGWAK
AFTER CALLER CHECKS I/O AND BEFORE WE GET HERE).
PUT JOB ON PAGE I/O WAIT QUEUE FOR
CP. CALL WSCHED. JOB WILL WAKE UP WHEN CURRENT (OR
NEXT, IF NO CURRENT) I/O OPERATION ON THE PAGE COMPLETES.
@@;

PAGWAT::CAME	J,JOB		;Current job going onto PGO list?
	  STOPCD		;Wrong
	WRPI	LI.PIF	;KEEP INTERRUPT LEVEL FROM SNEAKING IN
	LDB	T1,PGYSIO	;ANY SWAPPING GOING ON
	JUMPN	T1,PAGWT1	;YES, GO PUT JOB ON LIST
	LDB	T1,PGYDIO	;NO, ANY DIRECT I/O
	JUMPE	T1,[WRPI LI.PIN ;NO, JUST TURN PI BACK ON AND DISMISS
		    POPJ P,]
PAGWT1:	LDB	T1,PGYPGO	;GET OLD FIRST ON QUEUE
	DPB	J,PGYPGO	;MAKE THIS THE FIRST
	HRRM	T1,JBTPGO(J)	;NEW FIRST POINTS TO OLD FIRST
	MOVEI	T1,SWQ		;PUT INTO SWAP WAIT
	DPB	T1,PJBSTS	;DO NOT CALL REQUE, CURRENT JOB.
	WRPI	LI.PIN		;TURN PI BACK ON.
	PJRST	WSCHED	;RETURN WHEN THIS OPERATION IS DONE.
;ROUTINE TO TEST FOR ANY ACTIVE DEVICES

;CALL:	MOVE	J,JOB NUMBER OR HIGH SEG NUMBER
;	PUSHJ	P,ANYACT
;	DEVICES	ACTIVE
;	DEVICES	NOT ACTIVE EXCEPT POSSIBLY TTY


	INTERN	ANYACT

ANYACT:	HRRZ T4,JBTIOA(J)
	JUMPE T4,CPOPJ1	;ZERO, NO LOCK IN CORE ACTIVITY
	POPJ P,		;SOME I/O IN PROGRESS
	INTERN	GET4WD,GIV4WD,GETWDS,GIVWDS,SETZRS
	EXTERN	SAVE4,FREPTR,LOCORE,FCREQ,FCAVAL

;SUBROUTINE TO GET "FREE" CORE
;ENTER GET4WD: T2=# 4 WORD BLOCKS TO GET
;ENTER GETWDS: T2=# WORDS TO GET
;RETURN CPOPJ IF NOT AVAILABLE, WITH T2=LARGEST HOLE AVAILABLE
;RETURN CPOPJ1 IF GOTTEN, WITH T1=LOC OF CORE
GETWDS:	ADDI	T2,3		;CONVERT TO 4 WORD BLOCKS
	ASH	T2,-2
GET4WD:	JSP	T4,SAVE4	;SAVE P1-P4
GET4W1:	MOVE	P1,FREPTR	;SET AOBJN WORD FOR FREE-CORE TABLE
	SETZ	P2,		;BEST-SO-FAR =0
	HRRZ	P3,T2		;P3=HOW MUCH WE WANT
	PUSHJ	P,GETZ		;GET C(P3) ZERO BITS
	  JRST	GETCR1		;NOT AVAILABLE - ERROR RETURN
	HRRZ	T1,P4		;LOC OF 1ST WORD WITH 0'S
	HRRZ	T2,FREPTR	;LOC OF START OF TABLE
	SUB	T1,T2		;T1=RELATIVE LOC OF 1ST 0
	IMULI	T1,^D36		;36 BITS PER WORD
	HLRZ	T2,P4		;LOC OF 1ST 0 IN WORD
	MOVNS	T2		;-LOC OF 1ST BIT
	ADDI	T1,^D36(T2)	;COMPUTE STARTING BIT LOCATION
	LSH	T1,2		;*4=ADDRESS
	CAMLE	T1,MAXCOR	;GET ROUGH ESTIMATE OF MAX
	MOVEM	T1,MAXCOR	; FREE CORE USED
	ADD	T1,LOCORE	;+START OF TABLE=ACTUAL LOC
	PUSHJ	P,SETOS		;SET 1'S IN TABLE FOR THIS CORE
	 SKIPA T2,P3		;SOMEONE SNUCK IN AN TOOK CORE - RESET T2
	JRST	CPOPJ1		;GOT THE CORE - GOOD RETURN
	JRST GET4W1		;AND TRY AGAIN

MAXCOR:	0			;HIGHEST FREE CORE BLOCK ASSIGNED

MCRHDR:	1,,0			;FOR GETLNK GETTAB
	MAXCOR,,MCRNAM		;VALUE,,NAME
MCRNAM:	SIXBIT "MAXCOR"
	.LINK	1,MCRHDR

;HERE WHEN COULDN'T1 GET ENOUGH FREE CORE
GETCR1:
	JFFO	P3,.+1		;Get log(base 2) of request size
	AOS	NOCORE(P4)	;Log the log of the failure
	SKIPN T2,P2		;SET T2 TO LARGEST HOLE FOUND
	POPJ P,			;IF NOTHING JUST TAKE ERROR RETURN
	SKIPL FCREQ		;GOT SOMETHING, WAS THERE A WAITER?
	SETOM FCAVAL		;YES, START HIM
	POPJ P,

NOCORE:	BLOCK	^D37		;Enough for all powers of 2 (plus one)
				; in a word

DMPHDR:	1,,0			;For GETLNK GETTAB
	DMPVAL,,DMPNAM
DMPNAM:	SIXBIT	"NOCORE"
DMPVAL:	NOCORE
	.LINK	1,DMPHDR

;SUBROUTINE TO RETURN "FREE" CORE
;ENTER GIVWDS: T1=# WDS. TO RETURN, T2=START ADR. OF CORE
;ENTER GIV4WD: T1=# 4 WRD. BLOCKS TO RETURN, T2=START ADR. OF CORE
GIVWDS:	ADDI	T1,3		;CONVERT TO # 4WD. BLOCKS
	ASH	T1,-2
GIV4WD:	SUB	T2,LOCORE	;GET ADR. RELATIVE TO START OF TABLE
	LSH	T2,-2		;/4 TO CONVERT TO BITS
	IDIVI	T2,^D36		;COMPUTE WORD LOC, STARTING BIT
	HRLS	T2		;WORD POSITION IN BOTH HALVES
	ADD	T2,FREPTR	;SET AOBJN WORD FOR TABLE
	SKIPL FCREQ	;AANY CORE WAITERS?
	SETOM FCAVAL	;YES, GET THEM STARTED
				;FALL INTO SETZRS

;SUBROUTINE TO SET ZEROS IN A TABLE
;ARG	T1=HOW MANY BITS TO CLEAR
;	T2=AOBJN POINTER FOR TABLE
;	T3=POSITION IN WORD OF FIRST BIT TO CLEAR
;	(0=BIT 0, 1=BIT 1, ETC.)

INTERN	SETZRS
SETZRS:	CAIG T1,2		;MARK SIZE OF CLEAR
	SKIPA T4,T1
	MOVEI T4,3
	AOS ZERS-1(T4)
	MOVSI	T4,400000	;SET A BIT
	MOVNS	T3
	LSH	T4,(T3)		;POSITION TO 1ST BIT TO RETURN
GIVCR2:	TDNN T4,(T2)	;BIT REALLY SET?
	STOPCD
	ANDCAM T4,(T2)		;YES,CLEAR A BIT
	SOJLE	T1,CPOPJ		;THROUGH IF T1=0
	ROT	T4,-1		;POSITION TO NEXT BIT
	JUMPG	T4,GIVCR2	;GO CLEAR IT IF IN SAME WORD
	AOBJN	T2,GIVCR2	;STEP TO NEXT WORD
	STOPCD	CPOPJ		;PAST TOP OF TABLE - ERROR

ZERS:	BLOCK 3
ONES:	BLOCK 3

ZNMTAB:	SIXBIT /ZERO1/
	SIXBIT /ZERO2/
	SIXBIT /ZEROM/
	SIXBIT /ONE1/
	SIXBIT /ONE2/
	SIXBIT /ONEM/

	6,,0
	.LINK 1,.-1
	ZERS,,ZNMTAB
	INTERN	GETZ,GETZR,SETOS
STRTAD==200000

;SUBROUTINE TO FIND N CONSECUTIVE 0'S IN A TABLE
;ENTER WITH P1 = AOBJN WORD TO THE TABLE
;P2 = PREVIOUS BEST SO FAR
;RH(P3)= HOW MANY,  BIT STRTAD =1 IF START LOC SPECIFIED
;EXIT CPOPJ1 IF FOUND, WITH P4 = WHERE THE HOLE IS
;EXIT CPOPJ IF UNSUCCESSFUL, P2 = LARGEST HOLE FOUND
;P1-P4 CHANGED
GETZ:	TLNE	P3,STRTAD	;START LOC SPECIFIED?  (NOTE THAT ENTRY TO ROUTINE
				; IS AT GETZR IF START LOC SPECIFIED)
	POPJ	P,		;YES, ERROR RETURN
	MOVEI	T4,^D36		;NO. SET UP COUNT
	SETCM	T1,(P1)		;WORD TO INVESTIGATE
	JUMPE	T1,GETZ4		;FULL IF 0
	JUMPG	T1,GETZ3		;1ST BIT UNAVAILABLE IF POSITIVE
GETZ1:	SETCA	T1,		;SET TO REAL CONTENTS
	JFFO	T1,.+2		;COUNT THE NUMBER OF 0'S
	MOVEI	T2,^D36		;36 OF THEM
GETZR:	MOVE	T3,T2		;SHIFT COUNT (T3 CAN BE >36 AT GETZ2)
	MOVEM	P1,P4		;SAVE POSITION IN P4
	HRLM	T4,P4		;LOC OF HOLE
GETZ2:	CAIL	T3,(P3)		;FOUND ENOUGH?
	JRST	CPOPJ1		;YES. GOOD RETURN
	CAILE	T3,(P2)		;NO. BEST SO FAR?
	HRRI	P2,(T3)		;YES. SAVE IT
	SUBI	T4,(T2)		;DECREASE POSITION COUNTER
	JUMPLE	T4,GETZ5	;0'S ON END
	TLNE	P3,STRTAD	;THIS HOLE NOT GOOD ENOUGH
	POPJ	P,		;ERROR RETURN IF START ADDRESS GIVEN
	SETCA	T1,		;NOW WE WANT TO COUNT 1'S
	LSH	T1,1(T2)		;REMOVE BITS WE ALREADY LOOKED AT
GETZ3:	JFFO	T1,.+1		;NUMBER OF (REAL) 1'S
	LSH	T1,(T2)		;GET RID OF THEM
	CAIN	T4,^D36		;1ST POSITION IN WORD?
	ADDI	T4,1		;YES, SUBTRACT REAL JFFO COUNT
	SUBI	T4,1(T2)	;DECREASE POSITION COUNT
	JUMPG	T4,GETZ1	;TRY NEXT 0 - HOLE
GETZ4:	AOBJN	P1,GETZ		;1'S ON END - START FRESH AT NEXT WORD

;HERE IF THE DESIRED SIZE NOT YET FOUND, BUT THE WORD HAD 0'S ON THE END
GETZ5:	AOBJP	P1,CPOPJ	;THROUGH IF END OF SAT
	SKIPGE	T1,(P1)		;NEXT WORD POSITIVE?
	JRST	GETZ		;NO. THIS HOLE NOT GOOD ENOUGH
	JFFO	T1,.+2		;YES. COUNT THE 0'S
	MOVEI	T2,^D36		;36 0'S
	ADDI	T3,(T2)		;ADD TO PREVIOUS ZERO-COUNT
	MOVEI	T4,^D36		;RESET T4
	JRST	GETZ2		;AND TEST THIS HOLE
;SUBROUTINE TO MARK BITS AS TAKEN IN TABLE
;USES ACS AS RETURNED FROM GETZ
;CHANGES P4, RESPECTS T1
SETOS:	MOVEI	T3,(P3)		;NUMBER OF CLUSTERS TO MARK
	CAILE T3,2
	MOVEI T3,3
	AOS ONES-1(T3)
	MOVEI T3,(P3)	;RECORD SIZE OF FIELD
	MOVEI	T2,1		;SET A BIT
	HLRZ	T4,P4		;LOC OF FIRST BIT TO MARK
	LSH	T2,-1(T4)	;POSITION IT
SETO1:	TDNE	T2,(P4)		;BIT ALREADY =1?
	STOPCD			;YES,SOMEONE SNUCK IN,SHOULDNT HAPPEN
	ORM	T2,(P4)		;MARK A BIT 
	ROT	T2,-1		;STEP TO NEXT BIT
	SKIPG	T2		;NEXT WORD?
	AOS	P4		;YES
	SOJG	T3,SETO1	;GO MARK NEXT
	JRST	CPOPJ1		;AND RETURN

COMMENT ! THIS CODE IS NOW OBSOLETE. USED TO COME HERE FROM SETO1+1
;HERE IF ONE OF THE BITS WE ARE TRYING TO SET IS ALREADY A 1
;THIS CAN HAPPEN BY INTERRUPTING OUT OF GET4WD, AND TAKING BLOCKS
;FOR AN EXTENDED PUSH DOWN LIST
SETO2:	SUBI	T3,(P3)		;T3=-# OF BITS ALREADY SET
SETO3:	JUMPGE	T3,CPOPJ	;RETURN IF ALL SET BITS CLEARED
	SKIPG	T2		;BIT IN PREVIOUS WORD?
	SOS	P4		;YES
	ROT	T2,1		;STEP TO PREVIOUS BIT
	ANDCAM	T2,(P4)		;CLEAR IT
	AOJA	T3,SETO3	;AND TEST NEXT BIT
!
SUBTTL CORE PAGE LIST CHECKER

;CALLED FROM VARIOUS PLACES TO MAKE SURE PHYSICAL CORE
; PAGE LISTS AND COUNTS ARE OK.

EXTERNAL MAXPCB,MEMSZP

CHKLST::PUSH	P,T1
	PUSH	P,T2
	PUSH	P,T3
	PUSH	P,T4
	PUSH	P,PG
	RDPI	T1		;GET PI STATUS
	PUSH	P,T1		;SAVE STATE OF LI.PIN/LI.PIF

	SETZM	CHKCNT		;ZERO THE COUNT TABLE
	MOVE	T1,[CHKCNT,,CHKCNT+1]
	BLT	T1,CHKCNT+SPR.N
	SKIPN	PG,MAXPCB	;GET
	STOPCD
	ADDI	PG,1		;FIRST CORE PAGE IN SYSTEM
	WRPI	LI.PIF	;TURN OFF PI SYSTEM WHILE CHECKING.

CHKLP1:	CAML	PG,MEMSZP	;DONE?
	JRST	CHKL1A		;YES.
	LDB	T1,PGYLST	;GET LIST NUMBER
	AOS	CHKCNT(T1)	;COUNT IT
	MOVEI	T4,PTRPGL-1	;GET HIGHEST TABLE ENTRY
	XCT	PTRPGY(T4)	;PICK UP PGY DATA
	XCT	@INSTYP(T1)	;CHECK FOR VALIDITY
	STOPCD			;NO GOOD.
	AOJA	PG,CHKLP1	;NO, DO NEXT

CHKL1A:	MOVEI	T1,DFR.N	;NOW CHECK COUNTS
CHKLP2:	MOVE	T2,CAVPGN	;GET TOTAL NUMBER OF CFRLST PAGES
	ADD	T2,CRSPGN
	CAIE	T1,CFR.N	;DOING CFRLST?
	MOVE	T2,DFRPGN	;NO, DOING DFRLST
	CAME	T2,CHKCNT(T1)	;MATCHES WHAT WE COUNTED?
	STOPCD			;NO
	SOJGE	T1,CHKLP2	;DO NEXT LIST

	MOVEI	T1,SID.N+1	;GET 1 + LAST LIST TO DO
	JRST	CHKLP4

CHKLP3:	LDB	T2,PGYLST	;GET LIST
	CAME	T2,T1		;ON THE LIST IT CAME FROM?
	STOPCD			;NO
	LDB	T2,PGYBPL	;GET LAST PAGE
	CAME	T2,T3		;BACK LINK ANY GOOD?
	STOPCD			;NO
	MOVE	T3,PG		;NEW PREVIOUS FOR NEXT TIME.
	LDB	PG,PGYFPL	;GET NEXT PAGE ON THIS LIST
	JUMPN	PG,CHKLP3	;JUMP IF MORE ON THIS LIST

	HLRZ	PG,LSTLST(T1)	;GET WHAT HEADER SAYS IS LAST PAGE
	CAME	PG,T3		;IS IT REALLY?
	STOPCD			;NO, CONFUSION ABOUT LAST MEMBER
CHKLP4:	SOJL	T1,CHKLP5	;GO IF DONE
	HRRZ	PG,LSTLST(T1)	;GET FIRST IN NEXT LIST
	SETZ	T3,		;FIRST PREVIOUS IS ZERO
	JUMPN	PG,CHKLP3	;AND GO CHECK THE LIST IF ANYTING IN IT
	JRST	CHKLP4		;NOTHING THERE, DO NEXT LIST

CHKLP5:	POP	P,T1		;GET PI STATUS
	TRNE	T1,LI.PIN		;WAS SYSTEM ON?
	WRPI	LI.PIN		;YES, TURN IT BACK ON.
	POP	P,PG
	POP	P,T4
	POP	P,T3
	POP	P,T2
	POP	P,T1
	POPJ	P,
;TABLES FOR CHKLST

;TABLE OF LDB INSTRUCTIONS TO GET VARIOUS DATA THINGS OUT OF
; PGY TABLES

PTRPGY:	LDB	T1,PGYSIP
	LDB	T1,PGYSOP
	LDB	T1,PGYDIO
	LDB	T1,PGYSPT
	LDB	T1,PGYATB
	LDB	T1,PGYLMJ
	LDB	T1,PGYPGO
	LDB	T1,PGYUSE
	LDB	T1,PGYDRT

PTRPGL==.-PTRPGY		;LENGTH

;PARALLEL TABLES FOR EACH CORE PAGE TYPE TO CHECK ABOVE DATA.

;TABLE OF THE TABLES, INDEXED BY CORE PAGE LIST NUMBER

INSTYP:	CFRPGY(T4)
	DFRPGY(T4)
	USEPGY(T4)
	SOPPGY(T4)
	SIPPGY(T4)
	[HALT]
	[HALT]

CFRPGY:	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1

DFRPGY:	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	JFCL		;PGY COULD BE SET
	SKIPE	T1
	SKIPN	T1

USEPGY:	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	SKIPN	T1		;USE COUNT MUST BE NON-ZERO.
	JFCL

SIPPGY:	SKIPN	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1

SOPPGY:	SKIPE	T1
	SKIPN	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1
	SKIPE	T1


CHKCNT:	BLOCK	SPR.N+1
SUBTTL PAGE AGEING

COMMENT @

THERE IS AN AGE CELL FOR EACH OF A JOB'S PAGE SLOTS (ONE FOR EACH
VIRTUAL PAGE NUMBER). THE CELLS ARE STORED IN THE TABLE UPTAGE
IN THE JOB'S UPT. THE AGE CELLS RECORD THE TIME SINCE THE LAST
REFERENCE TO THE CORRESPONDING VIRTUAL PAGES.

WHEN A JOB IS CREATED, ALL ITS PAGE SLOTS ARE GIVEN AN AGE OF 0.

EVERY TIME AN ACCESS-BIT FAULT OCCURS FOR A PAGE, ITS AGE IS
SET TO 0.

EVERY C(AGENTV) TICKS A JOB RUNS, AGEPAG IS CALLED TO INCREMENT
THE AGE CELLS. IT ADDS ONE TO THE AGE OF EVERY PAGE, AND
CLEARS THE PAGE'S ACCESS BIT IF ITS AGE WENT FROM 0 TO 1.

A PAGE WHICH HASN'T BEEN ACCESSED IN C(AGEMAT) AGEPAG CALLS
IS TERMED A "MATURE" PAGE. A PAGE WHICH HASN'T BEEN ACCESSED
IN C(AGEELD) AGEPAG CALLS IS TERMED AN "ELDERLY" PAGE. ALL
ELDERLY PAGES ARE ALSO MATURE PAGES.

IN A JOB SUBJECT TO MWS ADJUSTMENT (JBTSTS JWSADJ BIT SET),
MWSRPL WILL REMOVE ALL THE ELDERLY PAGES AND THE OLDEST
MATURE PAGE EACH TIME IT IS CALLED.

IN A JOB SUBJECT TO MWS ADJUSTMENT, AGEPAG WILL CALL MWSREP
AT THE END OF ITS COMPUTATIONS IF IT FOUND MORE THAN C(ADJNAP)
ELDERLY PAGES, AND MWSREP WILL REMOVER THEM ALL FROM THE MWS.

THUS (WITH MWS ADJUSTMENT IN EFFECT), A "YOUNG" (RECENTLY-
ACCESSED) PAGE WILL NEVER BE REMOVED FROM THE MWS, A "MATURE"
BUT NOT "ELDERLY" PAGE WILL BE REMOVED ONLY TO MAKE ROOM FOR
A PAGE THE JOB HAS FAULTED FOR, AND AN "ELDERLY" PAGE WILL
BE REMOVED AT THE EARLIEST CONVENIENT TIME.

THIS PAGE REPLACEMENT STRATEGY IS DESCRIBED BY ALAN JAY SMITH
IN "A MODIFIED WORKING SET PAGING ALGORITHM", IEEETC V. C-25,
NO. 9 (SEPTEMBER 1976), AND WAS USED, MORE OR LESS, IN A
TIME-SHARING SYSTEM FOR THE SPECTRA 70, DESCRIBED BY MARC
FOGEL IN "THE VMOS PAGING ALGORITHM", SIGOPS V. 8, NO. 1
(JANUARY 1974).

@
;VARIOUS CELLS FOR PAGE AGEING AND PAGE REPLACEMENT CODE

AGECAL:	0		;NUMBER OF CALLS TO AGEPAG
AGEADJ:	0		;NUMBER OF CALLS FROM AGEPAG TO MWSREP

AGENTV::^D120		;PAGE AGE UNIT IN TICKS WHILE RUNNING
AGEMAT:	^D6		;"MATURE" PAGE MINIMUM AGE
AGEELD:	^D6		;"ELDERLY" PAGE MINIMUM AGE

ADJNAP:	^D10		;IF AGEPAG FINDS MORE THAN THIS MANY
			;ELDERLY PAGES IN MWS, IT CALLS MWSREP

ADJMWS::0		;SET TO -1, TURNING ON MWS ADJUSTMENT,
			;BY DSKCLN'S CALL TO DSKCLR. ON EVERY
			;RESET UUO, THE JOB'S JWSADJ BIT IS
			;SET ACCORDING TO ADJMWS.
COMMENT #
@@SUBROUTINE AGEPAG
@@PURPOSE ADJUST THE AGE FIELDS OF THE CURRENT JOB'S PAGES, AND
(IF MWS ADJUST IN EFFECT) THROW OUT THE OLD ONES:

	FOR F FROM 0 TO 777
		IF P.AGE < AGEMAX
			P.AGE :+ 1
		IF P EXISTS
			AGEHST [P.AGE] :+ 1
			IF P.AGE = 1
				P.ACCESS := 0
			IF P.AGE = AGEELD AND P IN MWS
				UPT.ELD :+ 1
			IF P.AGE = AGEMAT AND P IN MWS
				UPT.MAT :+ 1
	IF ADJMWS AND UPT.ADJ AND UPT.ELD > ADJNAP
		CALL MWSRPL

@@ENTRY CALLED ONLY AT UUO LEVEL (FROM RESCHEDULING CODE WHEN
%UPT+UPTNTV GETS DECREMENTED TO 0)
@@ACCUM DESTROYS T1-T4
@@EXIT NONSKIP-RETURNS
@@ #

AGEPAG::JUMPE	J, CPOPJ
	PUSH	P, P1
	PUSH	P, P2
	PUSH	P, P3
	PUSH	P, P4
	PUSH	P, W		;SAVE P1-P4 AND W

	AOS	AGECAL		;COUNT NUMBER OF CALLS
	HRLZI	W, -777		;W/ PAGE # AOBJN POINTER
	MOVEI	T4, AGECPW	;T4/ # AGE CELLS PER WORD
	MOVEI	P1, %UPT+UPTAGE	;P1/ ADDR OF 1ST AGE CELL WORD
	MOVE	T2, 0(P1)	;T2/ OLD AGE CELL WORD	

AGEPG1:	LSH	T3, AGESIZ	;MAKE ROOM FOR NEW AGE CELL
	SETZ	T1,
	LSHC	T1, AGESIZ	;T1/ OLD AGE CELL (FROM T2)
	CAIGE	T1, AGEMAX	;IF P.AGE < AGEMAX,
	AOS	T1		;  P.AGE :+ 1
	IORM	T1, T3		;DEPOSIT THE NEW AGE CELL
	MOVE	P3, %UPLMA(W)
	TLNN	P3, LMMEXS	;IF PAGE DOESN'T EXIST,
	JRST	AGEPG4		;  GO ON TO THE NEXT ONE
	AOS	AGEHST(T1)	;UPDATE HISTOGRAM
	CAIE	T1, 1		;IF AGE = 1,
	JRST	AGEPG2
	PUSHJ	P, GETLMA	;  P3,P4/ LMAP SLOT
	TLNN	P3, LMMEXS	;  IF IT DOESN'T EXIST
	  STOPCD		;    WE SHOULDN'T BE HERE
	TRZ	P4, PGE.A	;  CLEAR ACCESS BIT
	PUSHJ	P, STOLMA	;  PUT THE SLOT BACK
	MOVEI	T1, 1
AGEPG2:	CAMN	T1, AGEMAT	;IF PAGE JUST BECAME MATURE
	JRST	AGEPG3
	CAME	T1, AGEELD	;OR ELDERLY,
	JRST	AGEPG4
AGEPG3:	HRRZ	P3, W
	IDIVI	P3, ^D36
	MOVE	P3, %UPT+UPTMWB(P3)
	TDNN	P3, BITTBL(P4)	;AND IT'S IN THE MWS,
	JRST	AGEPG4
	CAMN	T1, AGEELD
	AOS	%UPT+UPTELD
	CAMN	T1, AGEMAT
	AOS	%UPT+UPTMAT	;  BUMP THE APPROPRIATE COUNT(S)

AGEPG4:	SOJG	T4, AGEPG5	;IF AGE CELL WORD EXHAUSTED,
	MOVEM	T3, 0(P1)	;  STORE THE NEW WORD
	AOS	P1		;  ADVANCE THE POINTER
	MOVE	T2, 0(P1)	;  GET THE NEXT AGE CELL WORD
	MOVEI	T4, AGECPW	;  RESET COUNTER
AGEPG5:	AOBJN	W, AGEPG1	;LOOP UNTIL NO MORE PAGES

	MOVE	T1, JBTSTS(J)
	TRNN	T1, JWSADJ	;IF MWS ADJUST IS IN EFFECT
	JRST	AGEPG6
	MOVE	T1, %UPT+UPTELD
	CAMG	T1, ADJNAP	;AND THERE'RE TOO MANY OLD PAGES,
	JRST	AGEPG6
	AOS	AGEADJ		;COUNT NUMBER OF MWS ADJUSTMENTS
	MOVEI	P1, .MRADJ
	PUSHJ	P, MWSREP	;  CALL MWSREP TO THROW THEM OUT
	  JFCL

AGEPG6:	MOVE	T1, AGENTV
	MOVEM	T1, %UPT+UPTNTV	;RESTORE RECOMPUTATION INTERVAL
	POP	P, W
	POP	P, P4
	POP	P, P3
	POP	P, P2
	POP	P, P1
	POPJ	P,		;RESTORE P1-P4 AND W, AND RETURN
END
    - ~ 