2	;
	PUSHJ	P,RELSAT	;
	POP	P,T1		;
	POPJ	P,




COMMENT #
@@SUBROUTINE DELCRE
@@PURPOSE
LITTLE COMMON SUBR FOR HANDLING ONE SLOT IN AN ISOLATED RIB.
@@ENTRY
EXPECTS F/ DDB AND M/ FILE PAGE NUMBER OF INTEREST (<=HPW).
@@ACCUM
DESTROYS T1-T4, U, AND PG.
@@EXIT
ON SUCCESS, SKIP RETURNS WITH DDB
SET UP, RIB LOCKED IN CORE, ALL DDBS FLUSHED INTO RIB, AND
T2/ RETRIEVAL PNTR.
NON-SKIP RETURNS ON RIB ERROR AND HAS KILLED THE FILE.
@@ #

DELCRE:	PUSHJ	P,USETST	;POINT TO PAGE M IN THE DDB.
	POPJ	P,		;
	MOVE	T1,DEVRIB(F)	;GET THE RIB FOR PAGE M
	PUSHJ	P,MWLRIB	;WRITE LOCKED.
	PJRST	KILFIL		;
	SKIPG	T2,@DEVRET(F)	;LEGAL POINTER?
	STOPCD
	SETZ	T1,		;WRITE OUT THE OTHER DDBS WITH
	PUSHJ	P,FLUSH		;PTRCHG ON, AND THEN
	PUSHJ	P,PTROU0	;WRITE US OUT, TOO.
	MOVE	T2,@DEVRET(F)	;
	JRST	CPOPJ1		;


COMMENT #
@@SUBROUTINE DELXCH
@@PURPOSE
SMALL SUBR CALLED AT START OF FDEL, FEXCH, FTRNC, AND FCREATE
TO BE SURE THE FILE IS WRITEABLE AND TO SET SOME STUFF UP.
@@ENTRY
EXPECTS F/ DDB AND T3/ KFDEL, KFCREE, KFEXC, OR KFTRN.
@@ACCUM
SUCCESS RETURN DESTROYS ONLY T3 AND T4.
FAIL RETURN DESTROYS ALSO T1.
@@EXIT
NON-SKIP RETURNS ON ERROR, WITH ERROR FLAG IN T1.
SKIP RETURNS IF OKAY, WITH T4/ NUMBER OF HPW.
@@ #


DELXCH:	TLNN	F,ENTRB!LOOKB	;IS THERE A FILE ON THIS CHANNEL?
	JRST	[MOVEI T1,FALNOF ;NO.
		POPJ P,]	;
	TLNE	S,IOBDRB	;
	JRST	[MOVEI T1,FALRBE ;
		POPJ P,]	;
	HLLZ	T4,DEVIAD(F)	;YES.
	TLNN	F,ENTRB		;HAS IT BEEN ENTERED?
	JRST	[MOVEI T1,FALNWT ;NO.
		POPJ P,]
	TLNN	T4,NOWRT	;YES.  IS IT APPEND ONLY?
	JRST	DELXC4		;NO.
	CAIN	T3,KFTRN	;YES, NOT CORRECTLY
	JRST	DELXC2		;WRITEABLE IF
	CAIE	T3,KFDEL	;DELETE,
	CAIN	T3,KFEXC	;EXCH, OR TRUNCATE.
				;KMOVPG CHECKS FOR ITSELF.
DELXC2:	JRST	[MOVEI T1,FALNWT ;
		POPJ P,]	;
DELXC4:	CAIN	T3,KFTRN	;DON'T LOCK IF TRUNCATE
	JRST	[PUSHJ P,LOKMOD ;KFTRN NEEDS THE MODIFY LOCK
		 JRST .+2]
	PUSHJ	P,LOKUNM	;LOCK FOR UNMODIFYING.
	MOVE	S,DEVIOS(F)	;
	TLNE	S,IOBDRB	;
	JRST	[PUSHJ P,UNLFIL	;
		MOVEI T1,FALRBE ;
		POPJ P,]	;
	PUSH	P,T2		;SAVE T2.
	HRRZ	T2,DEVATB(F)	;GET
	JUMPN	T2,.+2		;T4/
	STOPCD
	LDB	T4,ATYBSZ	;THE
	ADDI	T4,3		;NUMBER OF THE
	LSH	T4,-BLKSPP	;HPW.
	POP	P,T2		;RESTORE T2.
	CAIE	T3,KMOVPG	;DON'T CHECK THIS IF ITS KMOVPG.
	CAIN	T3,KFCREE	;CHECK FILE NO. ARG?
	JRST	CPOPJ1		;NO.
	JUMPLE	T1,[MOVEI T1,FALFPZ ;YES.  BETTER NOT BE <= 0
		JRST UNLFIL]	;
	CAMG	T1,T4		;OR > HPW
	JRST	CPOPJ1		;SUCCESS RETURN.
	MOVEI	T1,FALPHP	;
	JRST	UNLFIL		;
COMMENT #
@@SUBROUTINE KFEXC
@@PURPOSE
KERNEL SUBR TO EXCH TWO FILE PAGES.
@@ENTRY
EXPECTS USER'S ARGS IN T1 AND T2, AND T3/ BIT 0 ON IFF CALLED
FROM USER MODE,
AND ALSO F/ DDB AND S/ DEVIOS.
@@ACCUM
DESTROYS T1-T4, P1-P4, U, M, AND PG.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE IT NON-SKIP RETURNS.
ON NON-SKIP RETURN, T1 CONTAINS THE ERROR FLAG AS FOLLOWS:
FALFPZ,FALPHP,FALRBE,FALSAM,FALNOF,FALNWT.
@@ #

INTERN KFEXC

KFEXC:	MOVEI	T3,KFEXC	;
	PUSHJ	P,DELXCH	;CHK & LOCK FILE, GET T4/ HPW
	POPJ	P,		;AND CHK T1/ 1ST ARG.
	JUMPLE	T2,[MOVEI T1,FALFPZ ;2ND ARG MUST ALSO BE >0
		JRST UNLFIL]	;AND
	CAMLE	T2,T4		;<= HPW.
	JRST	[MOVEI T1,FALPHP ;
		JRST UNLFIL]	;
	CAMN	T1,T2		;REQ PAGES THE SAME PAGE?
	JRST	[MOVEI T1,FALSAM ;YES.
		JRST UNLFIL]	;

    ;DO WE NEED ONE RIB, OR TWO?
	PUSH	P,M		;SAVE M.
	MOVE	M,T1		;CARRY FILE PAGE NOS. IN
	MOVE	P1,T2		;SAFE ACS.
	SUBI	T1,1		;ARE THE PAGES
	SUBI	T2,1		;IN
	IDIVI	T2,RBLVSP	;THE
	MOVE	T3,T2		;
	IDIVI	T1,RBLVSP	;SAME
	CAMN	T1,T3		;RIB?
	TDZA	P2,P2		;YES, P2=0 IS FLAG FOR ONLY
	SETO	P2,		;NEED 1 RIB, ELSE NEED 2 RIBS.

    ;ORDER FILE PAGE NOS. TO AVOID DEADLOCK.
	CAMLE	M,P1		;
	EXCH	M,P1		;

    ;HERE TO GET MIN RIB.  FILE PAGE NOS. ARE IN M AND P1.
EXCHH3:	JUMPE	P2,EXCH35	;IF NEED TWO RIBS IN CORE
	PUSHJ	P,SETACH	;AND SET UFPALC, WAIT FOR UFD TO GO OUT
	PUSH	P,J		;SIMULTANEOUSLY,
	MOVE	J,JOB		;THEN
	PUSHJ	P,GETM2		;FIRST GET
	POP	P,J		;M2 RESOURCE.
EXCH35:	PUSHJ	P,USETST	;SET OUR DDB AND %RIB
	JRST	EXCDR4		;TO MIN PAGE.
	JUMPN	P2,EXCHH6	;JUMP IF NEED TWO RIBS.

    ;HERE ON NEED ONLY ONE RIB.  MIN RIB WILL BE IN %RIB.
      ;MAKE THE ONE RIB CURRENT AND GET THE "DEYRPSES" INTO
      ;M AND P1.
	MOVE	T1,DEVRIB(F)	;BE SURE THE
	PUSHJ	P,MWLRIB	;RIB IS IN
	JRST	EXCDRB		;%RIB.
	SETZ	T1,		;UPDATE THE RIB
	PUSHJ	P,FLUSH		;FROM THE DDB AREAS,
	PUSHJ	P,PTROU0	;INCLUDING MAYBE OUR OWN.
	PUSH	P,P1		;SAVE FILE PAGE NOS. FOR
	PUSH	P,M		;ONESLTS BELOW.
	SUB	P1,M		;GET
	LDB	M,DEYRPS	;M/
	SUBI	M,DEVRBN-%RIB(F) ;"DEYRPS" OF
	ADD	M,DEVRET(F)	;MIN OF THE PAGES AND
	ADD	P1,M		;P1/ "DEYRPS" OF MAX PAGE.
	JRST	EXCHH7		;

    ;HERE ON NEED TWO RIBS.  GET THEM BOTH LOCKED INTO CORE
      ;SO WE CAN MAKE THEM CURRENT AND THEN CHANGE THE SLOTS.
EXCHH6:	LDB	T1,DEYRPS	;SAVE
	SUBI	T1,DEVRBN-%RIB(F) ;"DEYRPS"
	ADD	T1,DEVRET(F)	;OF
	PUSH	P,T1		;MIN.
	PUSH	P,DEVRIB(F)	;SAVE DEVRIB OF MIN.
	PUSHJ	P,RELRIB	;DON'T BLOCK USETST.
	EXCH	M,P1		;GET
	PUSHJ	P,USETST	;THE
	JRST	EXCDR3		;MAX FILE
	SETOM	DEVFLO(F)	;PAGE
	MOVE	T1,DEVRIB(F)	;NO.
	PUSHJ	P,MWLRIB	;RIB
	JRST	EXCDR1		;INTO
	PUSHJ	P,SMMPXC	;%RB2.
	LDB	T1,DEYRPS	;SAVE AWAY "DEYRPS" OF MAX
	SUBI	T1,DEVRBN-%RB2(F) ;WHILE WE HAVE
	ADD	T1,DEVRET(F)	;THE
	EXCH	T1,(P)		;INFO.
	MOVEM	T1,DEVRIB(F)	;GET THE MIN RIB INTO
	PUSHJ	P,MWLRIB	;%RIB.
	JRST	EXCDR3		;
	SETZ	T1,		;NOW THAT WE
	PUSHJ	P,FLUSH		;HAVE BOTH
	PUSHJ	P,SMMPXC	;THE RIBS LOCKED
	MOVE	T1,%RIB+RIBSLF	;INTO CORE, WE
	MOVEM	T1,DEVRIB(F)	;CAN
	SETZ	T1,		;UPDATE THEM
	PUSHJ	P,FLUSH		;BOTH.
	EXCH	M,-1(P)		;SAVE FILE PAGE NOS. FOR
	EXCH	P1,(P)		;ONESLTS AND GET DEYRPSES.
	PUSHJ	P,SMMPXC	;GET THE
	HRRZI	T4,(M)		;MIN SLOT
	SUBI	T4,%RIB+1	;PNTR BACK
	DPB	T4,DEYRPS	;INTO
	MOVE	T4,(P)		;%RIB.
	MOVE	T1,%RIB+RIBSLF	;
	MOVEM	T1,DEVRIB(F)	;
	PUSHJ	P,PTRINN	;
	STOPCD


    ;HERE WITH 1 OR 2 RIBS, TO EXCHANGE THE PNTRS EVERYWHERE,
      ;AND THEN FINISH UP.  PDL HAS MIN FPN ON TOP, MAX
      ;FPN JUST BELOW.  %RIB AND DDB PNTR AREA HOLD MIN FPN.
      ;M/ "DEYRPS" OF MIN, P1/ "DEYRPS" OF MAX.
EXCHH7:	SKIPLE	P3,(M)		;BOTH RET PNTRS
	SKIPG	P4,(P1)		;LEGAL?
	STOPCD
	HRLZI	T2,PTRCHG	;
	IORM	T2,DEVIAD(F)	;
	MOVEM	P4,(M)		;2ND PNTR TO 1ST SLOT IN RIB.
	MOVE	T2,P4		;UPDATE
	POP	P,M		;THE
	PUSHJ	P,ONESLT	;OTHER DDBS.
	MOVEM	P3,(P1)		;STORE 1ST PNTR INTO 2ND
	POP	P,M		;SLOT IN %RIB AND
	PUSHJ	P,RONDUP	;UPDATE THE
	MOVE	T2,P3		;
	JUMPE	P2,EXCH73	;
	MOVE	T1,%RB2+RIBSLF	;
	PUSH	P,DEVRIB(F)	;
	MOVEM	T1,DEVRIB(F)	;
EXCH73:	PUSHJ	P,ONESLT	;OTHER DDBS.
	MOVEM	P4,@DEVRET(F)	;OLD MAX TO MIN DDB SLOT.
	JUMPE	P2,.+3		;
	POP	P,DEVRIB(F)	;
	JRST	EXCHOT		;
	MOVE	T1,F		;IF ONLY ONE RIB,
	MOVE	T3,DEVFLO(F)	;POSSIBLY WE HAVE
	PUSHJ	P,FINDM		;TO
	JRST	.+3		;UPDATE THE OTHER
	JUMPN	T2,.+2		;SLOT IN
	MOVEM	P3,(T3)		;OUR DDB.
EXCHOT:	PUSHJ	P,RELRIB	;JUST ABOUT DONE. REL THE RIB,
	PUSHJ	P,RELRB2	;MAYBE ALSO RELEASE %RB2,
	PUSHJ	P,UNLFIL	;RELEASE THE FILE,
	POP	P,M		;CLR PDL, AND THEN
	JRST	CPOPJ1		;TAKE THE SUCCESS RETURN.



EXCDR1:	POP	P,T1
	POP	P,T1
EXCDRB:	JUMPE	P2,+2		;
	PUSHJ	P,RELM2		;
	POP	P,M		;
	PUSHJ	P,RELSAT	;
	PJRST	KILFIL

EXCDR3:	POP	P,T1
	POP	P,T1
EXCDR4:	JUMPE	P2,DLXDR0	;
	PUSHJ	P,RELM2		;
	PJRST	DLXDR0
COMMENT #
@@SUBROUTINE SWEEP/SWEPHO/SWEPPG
@@PURPOSE
SUBR TO SWEEP A FILE PAST ITS CURRENT EOF.
@@ENTRY
EXPECTS F/ DDB, S/ DEVIOS, M/ NO. OF FIRST PAGE TO CREATE,
T4/ TOTAL NUMBER OF PAGES TO CREATE (INCLUDING M).
SWEEP WILL EXTEND THE FILE OUT TO M-1, IF NECESSARY, WITH
HOLES.  THEN FROM M TO M+T4-1 IT WILL CREATE (A) HOLES OR
(B) ZERO DISK PAGES, DEPENDING ON WHETHER IT WAS CALLED AT
SWEPHO OR SWEPPG RESPECTIVELY.
SWEEP EXPECTS THE FILE TO BE MODIFIED LOCKED ON ENTRY.
THERE MAY BE A RIB IN %RIB AND A SAT IN %SAT ON ENTRY.
THE FILE SIZE IS ALWAYS SET TO THE NEW EOF ON EITHER SUCCESS
OR ERROR RETURN.
THIS ROUTINE DOES NOT SET DEVPOS AND FRIENDS AS IT IS CALLED BY
BOTH OLD AND NEW STYLE IO ROUTINES.
IF T1/0 (-1) SWEEP WILL STOP (NOT STOP) ON CONTROL C.
@@ACCUM
DESTROYS T1-T4, PG, U,
@@EXIT
ON A SUCCESS RETURN OR A FAIL RETURN OTHER THAN FOR A BAD RIB,
THERE MAY BE A RIB IN %RIB AND A SAT IN %SAT, AND THE FILE IS
NOT UNLOCKED.  ON A FAIL RETURN DUE TO A BAD RIB, THE FILE IS
MARKED BAD, UNLOCKED, AND THE RIBS ARE GIVEN AWAY.
SUCCESS RETURN IS A SKIP RETURN.  ERROR RETURN IS A NON-SKIP 
RETURN.  ERROR CODE RETURNED IN T1 IS:
	FALCTL    CONTROL C IS WAITING
	FALAQA    QUOTA EXCEEDED (NOTE THAT IT IS THE CALLER'S
		    RESPONSIBILITY TO TYPE OUT THE EXCEEDING
		    QUOTA MSG.).
	FALRBE    RIB ERROR
ON AN ERROR RETURN, T4 HAS BEEN DECREMENTED BY THE NO. OF PAGES
AT AND FOLLOWING M THAT HAVE BEEN SUCCESSFULLY CREATED;
EVEN IF T4 IS UNCHANGED, PAGES MAY
STILL HAVE ALLOCATED IF M WAS ORIGINALLY >HPW+1;  (IN THIS
CASE THE FILE SIZE REFLECTS THESE PAGES.).
@@ #

FLG.PG==1
FLG.ER==4
FLG.CC==10
;ENTER AT SWEPRH TO DO HOLES IN SPITE OF TITO CROCK.
	TITO==1	;WHEN =1, TITO CROCK IS IN EFFECT.
INTERN SWEPHO,SWEPRH
IFE TITO,<SWEPHO:>
SWEPRH:	TDZA	T2,T2		;
IFN TITO,<SWEPHO:>
SWEPPG:	MOVEI	T2,FLG.PG	;

SWEEP:	PUSH	P,P1		;SAVE SOME
	PUSH	P,P2		;ACS WE
	PUSH	P,P3		;WILL BE USING.
	MOVE	P1,T2		;THIS WILL BE OUR FLAG WORD.
	JUMPE	T1,SWEEP0	;WANT TO STOP ON CL C?
	TRO	P1,FLG.CC	;NO.
	AOJE	T1,SWEEP0	;T1 HAD TO BE 0 OR -1.
	STOPCD
SWEEP0:	MOVE	P2,T4		;COUNTER OF PAGES.

    ;MUST WE EXTEND THE FILE BEFORE WE SWEEP?
	HRRZ	T2,DEVATB(F)	;
	JUMPN	T2,.+2		;
	STOPCD
	LDB	T4,ATYBSZ	;
	ADDI	T4,3		;
	LSH	T4,-2		;
	ADDI	T4,1		;T4/ OLD HPW+1.
	CAMG	M,T4		;MUST EXTEND FILE BEFORE SWEEP?
	JRST	SWEEP2		;NO.
      ;HERE TO EXTEND THE FILE OUT TO REQUESTED STARTING PAGE.
	PUSH	P,M		;YES.
	EXCH	M,T4		;
	SUB	T4,M		;
	SETZ	T1,		;
	TRNE	P1,FLG.CC	;
	SETO	T1,		;
	PUSHJ	P,SWEPHO
	JRST	[POP P,M	;ERROR.  RESTORE M.
		TRO P1,FLG.ER	;TAKE THE SWEPD4 ERROR
		JRST SWEPD4]	;RETURN.
	POP	P,M		;SUCCESS RETURN.
SWEEP2:	TRNE	P1,FLG.PG	;IF DOING HOLES OR
	CAIE	P2,1		;MORE THAN 1 PAGE,
	JRST	SWEP2A		;GO DO IT THE NORMAL WAY.

;WE ARE DOING 1 REAL PAGE. USE VMOVPG TO SAVE ON I/O
	PUSHJ	P,RELRIB
	PUSHJ	P,RELSAT
	PUSHJ	P,UNLFIL	;GET RID OF ALL THE LOCKS
	PUSH	P,P4
	PUSH	P,M
	PUSH	P,W
	MOVE	T1,[6001,,%COW.N+CNVVPN]
	VCREAT	T1,
	  JRST	SWEP3E
	MOVE	T1,[1,,%COW.N+CNVVPN]
	MOVE	T2,M		;SETUP ARGS
	PUSHJ	P,DOMVPG	;DO VMOVPG AND FIX PC.UIO
	  HRL	P1,T1		;SORRY, IT FAILED.
	MOVE	T1,[2001,,%COW.N+CNVVPN]
	VCLEAR	T1,		;NOW GET RID OF THE PAGE
	  STOPCD
	JRST	.+2

SWEP3E:	HRRZ	T1,T1
	SKIPA
	HLRZ	T1,P1		;GET ERROR CODE (IF ANY) INTO T1
	MOVEI	P2,1		;HAD TO BE 1 OR ELSE WE WOULDNT BE HERE
	POP	P,W
	POP	P,M
	POP	P,P4		;RESTORE ESSENTIAL ACS
	JRST	SWEPD4

DOMVPG:	JRSTF	@[.+1]		;CLEAR PC.UIO
	PUSHJ	P,KMOVPG
	  SKIPA
	AOS	(P)		;SKIP RETURN
	POP	P,T2		;GET PC OFF STACK
	JRSTF	(T2)		;AND RETURN, RESTORING STATE OF PC,UIO.


SWEP2A:	SUBI	M,1		;POINT @DEVRET TO
	PUSHJ	P,USETST	;M-1 PAGE.
	JRST	[TRO P1,FLG.ER
		AOJA M,SWEPD4]	;
	ADDI	M,1		;

    ;HERE WITH EOF JUST BEFORE M, AND DEVRET POINTING TO
    ;M-1 PAGE.  P2/ NO. OF PAGES TO DO, P1/ VARIOUS FLAGS.

SWEEP3:	PUSH	P,P2		;SAVE FOR FILE SIZE CALC.
	MOVEI	T1,DEVRBN(F)	;T1/ NO. OF PAGES LEFT IN
	SUB	T1,DEVRET(F)	;THIS DDB.
	CAIG	P2,(T1)		;ROOM ENOUGH IN THIS DDB?
	JRST	SWEEP4		;YES.
	PUSH	P,T1		;NO, WILL NEED AT LEAST OUR RIB.
	MOVE	T1,DEVRIB(F)	;
	PUSHJ	P,MWLRIB	;
	JRST	[TRO P1,FLG.ER	;RIB ERROR.
		HRLI P1,FALRBE
		POP P,T1
		JRST SWEPDN]
	POP	P,T1		;
	LDB	T3,DEYRPS	;FIND OUT IF NEED >THIS
	MOVNS	T3		;RIB.  CALC T1/ TOTAL
	ADDI	T3,RIBLST	;NO. OF
	ADDI	T1,(T3)		;PAGES LEFT IN THIS DDB + RIB.
	CAIG	P2,(T1)		;ENOUGH?
	JRST	SWEEP5		;YES, IN THIS RIB.
	JRST	SWEEP6		;IN >1 RIB.

    ;HERE WHEN NO NEED TO GET RIB, ALL NEW PNTRS WILL FIT IN
    ;OUR DDB.
SWEEP4:	PUSH	P,DEVRET(F)	;SAVE M-1 LOC ADDR FOR BELOW.
	MOVSI	T1,PTRCHG	;
	IORM	T1,DEVIAD(F)	;
	MOVEI	T2,(SIXBIT /CAT/) ;
	TRNN	P1,FLG.PG	;
	JRST	SWEP44		;
	SETZ	T2,		;
	MOVE	T3,DEVRET(F)	;FOR
	CAIL	T3,DEVRB1(F)	;
	MOVE	T2,(T3)		;
      ;SET UP INFO IN OUR DDB.
SWEP42:	TRNN	P1,FLG.PG	;DOING HOLES?
	JRST	SWEP44		;YES.
	PUSHJ	P,CREPAG	;NO. ALLOC, 0, CHRG, IN T2.
	JRST	SWEP46		;ERR, DIDN'T ALLOC.
SWEP44:	AOS	DEVRET(F)	;
	MOVEM	T2,@DEVRET(F)	;
	SOJG	P2,SWEP42	;
      ;NOW UPDATE OTHER DDBS.
SWEP46:	MOVE	S,DEVIOS(F)	;DID THE FILE GO BAD WHILE
	TLNN	S,IOBDRB	;WE WERE IN CREPAG?
	JRST	SWEP47		;NO, OKAY.
	HRLI	P1,FALRBE	;YES, OVERRIDE OTHER
	TRO	P1,FLG.ER	;ERRORS.
SWEP47:	POP	P,P3		;SET UP ARGS FOR UPDDDB.
	ADDI	P3,1		;P3/ DEVRET TO
	SUB	P2,(P)		;PAGE M.
	MOVMS	P2		;P2/ NO. OF
	JUMPE	P2,.+2		;PAGES WE DID.
	PUSHJ	P,UPDDDB	;UPDATE OTHER DDBS.
	SUB	P2,(P)		;SET UP P2/ NO. PAGES NOT DONE
	MOVMS	P2		;FOR SWEPDN.
	JRST	SWEPDN		;

    ;HERE WHEN NEED OUR RIB, AND ALL POINTERS WILL BE WITHIN IT.
      ;OUTPUT ALL INTERESTING DDBS WITH PTRCHG ON.
SWEEP5:	SETZ	T1,		;T1= DON'T INVALIDATE DDBS WHEN
	PUSHJ	P,FLUSH		;WRITE THEM INTO %RIB.
	PUSHJ	P,PTROU0	;MAYBE OUTPUT US TOO.
      ;GET PNTR TO PLACE IN RIB.
	MOVEI	T1,DEVRBN(F)	;GET P3/
	SUB	T1,DEVRET(F)	;PNTR TO
	LDB	P3,DEYRPS	;FIRST NEW LOC IN THE
	SUBI	P3,-1(T1)	;RIB.
	TRNN	P1,FLG.PG	;DOING HOLES?
	JRST	SWEP55		;YES, GO TO EASY BLT.
	SETZ	T2,		;
	MOVE	T3,DEVRET(F)	;FOR
	CAIL	T3,DEVRB1(F)	;
	MOVE	T2,(T3)		;
SWEP54:	PUSHJ	P,CREPAG	;NO, GO ONE BY ONE.
	JRST	SWEP56		;ERROR, DIDN'T ALLOCATE.
	MOVEM	T2,%RIB(P3)	;
	ADDI	P3,1		;
	SOJG	P2,SWEP54	;
	MOVE	S,DEVIOS(F)	;DID THE FILE GO BAD WHILE WE
	TLNN	S,IOBDRB	;WERE IN CREPAG?
	JRST	SWEP56		;NO.
	HRLI	P1,FALRBE	;YES.
	TRO	P1,FLG.ER	;
	JRST	SWEP56		;
      ;HERE TO BLT HOLES INTO RIB.
SWEP55:	MOVEI	T2,(SIXBIT/CAT/) ;SETUP T2, WE'RE DOING HOLES
	MOVEM	T2,%RIB(P3)	;STORE FIRST HOLE.
	MOVEI	T4,%RIB+1(P3)	;T4 IS THE
	HRLI	T4,-1(T4)	;BLT AC.
	ADDI	P3,(P2)		;POINT P3 TO 
	CAIE	P2,1		;If just one, we've done it
	BLT	T4,%RIB-1(P3)	;
	MOVEI	P2,0		;No hole pages left undone
      ;HERE TO FIX UP THE DDBS FOR THIS RIB.
SWEP56:	PUSH	P,F		;SAVE F.
	SETZ	T1,		;GET THE NEXT DDB ADDR
SWEP57:	PUSHJ	P,FNDDDB	;INTO T1.
	JRST	SWEP58		;NO MORE DDBS.
	MOVE	F,T1		;GET
	LDB	T2,DEYRPS	;DEYRPS.
	HRLZI	T2,%RIB-PTRLEN+1(T2) ;COPY THE (NEW?) PNTRS
	HRRI	T2,DEVRB1(T1)	;FROM THE AREA IN THE RIB TO THE
	BLT	T2,DEVRBN(T1)	;DDB AREA.
	JRST	SWEP57		;GO TO NEXT DDB.
SWEP58:	POP	P,F		;RESTORE F.
	SUBI	P3,2		;NOW, UPDATE
	DPB	P3,DEYRPS	;OUR DDB AREA TOO:
	MOVE	T4,(P)		;(CALC
	SUB	T4,P2		;T4/
	ADD	T4,M		;DEVFLO
	SUBI	T4,1		;FOR PTRINN.).
	PUSHJ	P,PTRINN	;
	STOPCD
	JRST	SWEPDN		;

    ;HERE WHEN WE NEED >1 RIB.
      ;OUTPUT ALL INTERESTING DDBS WITH PTRCHG ON.
SWEEP6:	SETO	T1,		;INVALIDATE DDBS AND WRITE THEM
	PUSHJ	P,FLUSH		;INTO %RIB.
SWEP63:	MOVEI	T2,(SIXBIT /CAT/) ;
	MOVSI	P3,PTRCHG	;
	TRNN	P1,FLG.PG	;DOING HOLES?
	JRST	SWEP64		;
	SETZ	T2,		;
	MOVE	T3,DEVRET(F)	;NO, PAGES.
	CAIL	T3,DEVRB1(F)	;
	MOVE	T2,(T3)		;
SWEP64:	PUSHJ	P,GETRET	;
	JRST	[TRO P1,FLG.ER	;
		HRLI P1,(T1)	;
		JRST SWEPDN]	;
	TRNN	P1,FLG.PG	;DOING HOLES?
	JRST	SWEP65		;YES.
	PUSHJ	P,CREPAG	;
	JRST	SWEPDN		;ERROR, DIDN'T ALLOCATE.
SWEP65:	MOVEM	T2,@DEVRET(F)	;
	IORM	P3,DEVIAD(F)	;
	SOJG	P2,SWEP64	;
	JRST	SWEPDN		;

    ;HERE TO FINISH UP.  (ENTER WITH P2/NO. OF PAGES NOT DONE.).
SWEPDN:	POP	P,T1		;T1/ NO. PAGES REQUESTED TO DO.
	SUB	T1,P2		;SUBTRACT NUMBER NOT DONE.
	ADD	T1,M		;ADD NO. DONE TO FIRST-1
	SUBI	T1,1		;TO GET NEW HPW.
	LSH	T1,2		;CONVERT TO HBW.
	HRRZ	T2,DEVATB(F)	;SET
	DPB	T1,ATYBSZ	;THE
	SETZ	T1,		;ATBSIZ
	DPB	T1,ATYWSZ	;FIELDS.
	HLRZ	T1,P1		;DITTO T1.  (MAY BE ERROR FLAG.).
	CAIN	T1,FALRBE	;WAS THERE A RIB
	TRNN	P1,FLG.ER	;ERROR?
	JRST	SWEPD4		;NO.
	PUSHJ	P,KILFIL	;YES, KILL THE FILE.
SWEPD4:	MOVE	T4,P2		;SET T4 UP FOR CALLER.
	POP	P,P3		;
	POP	P,P2		;
	TRNN	P1,FLG.ER	;
	AOS	-1(P)		;
	POP	P,P1		;
	POPJ	P,		;
COMMENT #
@@SUBROUTINE UPDDDB
@@PURPOSE
SUBR TO UPDATE DDBS OTHER THAN OUR OWN, FROM THE NEW POINTERS
ADDED TO THE EOF IN OUR DDB.
@@ENTRY
EXPECTS F/ DDB, M/ LOGICAL NO. IN FILE OF 1ST NEW PAGE, P3/ OUR
DEVRET TO PAGE M, AND P2/ NO. OF NEW PAGES.
@@ACCUM
DESTROYS T1-T4 AND P3.
@@ #

UPDDDB:	HRLZI	P3,(P3)		;P3 WILL BE BLT AC.
	SETZ	T1,		;GET A DDB OF
UPDDLP:	PUSHJ	P,FNDDDB	;INTEREST.
	POPJ	P,		;NONE LEFT.
    ;SEE IF ANY OF OUR NEW PNTRS BELONG ALSO IN THIS DDB.
	PUSHJ	P,FINDM		;IS M IN THIS DDB?
	JRST	UPDDLP		;NO.
	JUMPN	T2,UPDDLP	;NOR IF IN SPARE RIB PNTR.
    ;COPY SOME OF OUR NEW PNTRS TO THIS DDB.
	MOVEI	T4,DEVRBN(T1)	;T3/ ADDR OF PAGE M RET PNTR.
	SUBI	T4,-1(T3)	;GET T4/ ROOM LEFT IN THIS DDB.
	CAMLE	T4,P2		;CALC T4/ MAX NO.
	MOVEI	T4,(P2)		;OF PNTRS TO TRANSFER.
	ADDI	T4,-1(T3)	;T4/ BLT DESTINATION AC.
	HLL	T3,P3		;T3/ BLT AC.
	BLT	T3,(T4)		;COPY SOME PNTRS.
	JRST	UPDDLP		;
COMMENT #
@@SUBROUTINE ONESLT
@@PURPOSE
SUBR TO UPDATE OTHER DDBS WHEN WE HAVE FILLED OR MADE A HOLE
<= HPW.
@@ENTRY
EXPECTS T2/ NEW RETRIEVAL PNTR, M/ PAGE NUMBER OF INTEREST,
AND F/ DDB.
EXPECTS RIB WRITE LOCKED IN %RIB.
@@ACCUM
DESTROYS T1, T3, AND T4.  DOES NOT DESTROY T2.
@@ #


ONESLT:	PUSH	P,P1		;SAVE P1.
	MOVE	P1,T2		;P1 CARRIES NEW RETRIEVAL PNTR.
	SETZ	T1,		;T1 CARRIES DDB BEING UPDATED.
ONESL2:	PUSHJ	P,FNDDDB	;GET ANOTHER DDB TO T1.
	JRST	[MOVE T2,P1	;NONE LEFT.  RESTORE T2 FOR
		POP P,P1	;CALLER. RESTORE P1.
		POPJ P,]	;RETURN.
	PUSHJ	P,FINDM		;IS OUR SLOT IN THIS DDB?
	JRST	ONESL2		;NO, GO TO NEXT.
	JUMPN	T2,ONESL2	;NOT IF ONLY SPARE, EITHER.
	MOVEM	P1,(T3)		;FOUND ONE.
	JRST	ONESL2		;GO TO NEXT.
COMMENT #
@@SUBROUTINE FINDM
@@PURPOSE
SUBR TO FIND OUT IF PAGE M IS IN THE DDB WHOSE ADDR IS IN T1,
AND, IF SO, TO RETURN SOME INFO ABOUT WHERE IT IS.  (DOES NOT
CHECK ANYTHING ABOUT THE LEGALITY OF M'S RETRIEVAL PNTR.).
@@ENTRY
EXPECTS M/ NO. OF FILE PAGE OF INTEREST,  T1/ DDB ADDR, AND
T3/ DEVFLO(T1).  EXPECTS THE DDB TO BE VALID.
@@ACCUM
DESTROYS T2 THRU T4. MUST NOT DESTROY T1.
@@EXIT
NON-SKIP RETURNS IF M IS NOT IN THE DDB.  ELSE, SKIP RETURNS
WITH EITHER (A) T2/ 0 AND T3/ ADDR OF REAL RET PNTR, OR (B)
T2/ DEVSZS(T1) AND T3/ ADDR OF SPARE RIB PNTR.
@@ #

INTERN FINDM

FINDM:	ADDI	T3,3		;CONVERT DEVFLO
	LSH	T3,-BLKSPP	;TO PAGES.
	CAMGE	M,T3		;M BELOW 1ST PAGE IN THIS DDB?
	POPJ	P,		;YES.
	MOVEI	T4,PTRLEN	;NO.  T3 HAS DEVFLO.  LOOK
	MOVEI	T2,DEVRB1-1(T1)	;FIRST AT THE LEADING SPARE
FINDM1:	ADDI	T2,1		;
	SKIPL	(T2)		;RIB PNTRS, IF ANY.
	JRST	FINDM4		;FOUND FIRST NON-SPARE PNTR.
	ADD	T3,DEVSZS(T1)	;INC T3 BY ONE SPARE RIB SIZE.
	CAML	M,T3		;M DOWN WITHIN THIS SPARE RIB?
	JRST	FINDM2		;NO, GO TO NEXT.
	MOVEI	T3,(T2)		;YES, RETURN T2/ DEVSZS(T1) AND
	MOVE	T2,DEVSZS(T1)	;T3/ ADDR OF SPARE RIB PNTR.
	JRST	CPOPJ1		;SUCCESS RETURN.
FINDM2:	SOJG	T4,FINDM1	;CONTINUE LOOKING AT PNTRS?
	STOPCD
FINDM4:	ADDI	T3,-1(T4)	;HERE ON 1ST NON-SPARE RIB PNTR.
	CAMLE	M,T3		;M WITHIN THIS DDB?
	POPJ	P,		;NO.
	SETZ	T2,		;YES, RETURN T2/ 0 AND
	SUB	T3,M		;T3/ ADDR OF RET PNTR FOR
	MOVNS	T3		;PAGE
	ADDI	T3,DEVRBN(T1)	;M.
	JRST	CPOPJ1		;SUCCESS RETURN.
COMMENT #
@@SUBROUTINE FNDDDB
@@PURPOSE
SUBR TO GET THE NEXT VALID DDB ON THIS FNB WITH OUR DEVRIB.
(DOES NOT RETURN OUR DDB.).
@@ENTRY
EXPECTS F/ DDB AND T1/ ADDR OF PREVIOUS DDB (0 IF NO PREVIOUS).
@@ACCUM
DESTROYS T1, T2, AND T3.  MUST NOT DESTROY T4.
@@EXIT
ON SUCCESS, SKIP RETURNS WITH T1/ ADDR OF REQUESTED DDB AND
T3/ THAT DDB'S DEVFLO.  ON NO NEXT DDB, NON-SKIP RETURNS.
@@ #

INTERN FNDDDB

FNDDDB:	MOVE	T2,DEVRIB(F)	;(FOR COMPARE BELOW.).
	JUMPN	T1,FNDDD4	;WANT FIRST DDB?
	HRRZ	T1,DEVATB(F)	;YES.
	JUMPN	T1,.+2		;
	STOPCD
	HRRZ	T1,ATBFNB(T1)	;
	HRRZ	T1,FNBDBL(T1)	;T1/ FIRST DDB ON THIS FNB.
FNDDD2:	SKIPLE	T3,DEVFLO(T1)	;VALID?
	CAME	T2,DEVRIB(T1)	;YES.  HAS OUR DEVRIB?
	JRST	FNDDD4		;NOT INTERESTING DDB.
	CAIE	T1,(F)		;DON'T WANT OUR PRIME DDB.
	JRST	CPOPJ1		;FOUND ONE.
FNDDD4:	HRRZ	T1,DEVDBL(T1)	;TRY NEXT DDB.
	JUMPN	T1,FNDDD2	;
	POPJ	P,
COMMENT #
@@SUBROUTINE FNDADB
@@PURPOSE
SUBR TO GET THE NEXT VALID DDB ON THIS FNB WITH OUR ATB.
(DOES NOT RETURN OUR DDB.).
@@ENTRY
EXPECTS F/ DDB AND T1/ ADDR OF PREVIOUS DDB (0 IF NO PREVIOUS).
@@ACCUM
DESTROYS T1, T2, AND T3.  MUST NOT DESTROY T4.
@@EXIT
ON SUCCESS, SKIP RETURNS WITH T1/ ADDR OF REQUESTED DDB AND
T3/ THAT DDB'S DEVFLO.  ON NO NEXT DDB, NON-SKIP RETURNS.
@@ #

INTERN FNDADB

FNDADB:	HRRZ	T2,DEVATB(F)	;(FOR COMPARE BELOW.).
	JUMPN	T1,FNDAD4	;WANT FIRST DDB?
	HRRZ	T1,DEVATB(F)	;YES.
	JUMPN	T1,.+2		;
	STOPCD
	HRRZ	T1,ATBFNB(T1)	;
	HRRZ	T1,FNBDBL(T1)	;T1/ FIRST DDB ON THIS FNB.
FNDAD2:	CAIN	T1,(F)		;DON'T WANT OUR PRIME DDB.
	JRST	FNDAD4		;NOT INTERESTING DDB.
	HRRZ	T3,DEVATB(T1)	;HAS OUR ATB?
	CAIE	T3,(T2)		;
	JRST	FNDAD4		;
	SKIPLE	T3,DEVFLO(T1)	;
	JRST	CPOPJ1		;FOUND ONE.
FNDAD4:	HRRZ	T1,DEVDBL(T1)	;TRY NEXT DDB.
	JUMPN	T1,FNDAD2	;
	POPJ	P,
COMMENT #
@@SUBROUTINE FLUSH
@@PURPOSE
SUBR TO WRITE OUT ANY DDB PNTR AREAS THAT NEED WRITING OUT
FOR THE RIB THAT WE PRESENTLY HAVE IN %RIB.  ASSUMES DEVRIB(F)
IS THE ADDRESS OF THIS RIB.  OPTIONALLY INVALIDATES ALL THE
DDBS FOR THIS RIB.  DOES NOT FLUSH OR TOUCH OUR OWN DDB.
@@ENTRY
EXPECTS F/ OUR DDB AND DEVRIB(F) TO BE THE RIB IN %RIB.
INVALIDATES ALL THE DDBS FOR THIS RIB IFF T1/-1; ELSE T1 MUST
BE 0.
@@ACCUM
DESTROYS T1-T4.
@@ #

INTERN FLUSH

FLUSH:	SKIPG	T4,T1		;CHECK THAT T1 IS -1 OR 0 AND
	AOJGE	T1,.+2		;GET IT INTO SEMI-SAFE T4.
	STOPCD
	SETZ	T1,		;GET T1/ ADDR OF NEXT
FLUSH2:	PUSHJ	P,FNDDDB	;INTERESTING DDB.
	POPJ	P,		;NONE LEFT.
	EXCH	F,T1		;WRITE THE DDB PNTRS INTO
	PUSHJ	P,PTROU0	;%RIB, IFF PTRCHG IS ON (TURN
	EXCH	F,T1		;PTRCHG OFF.).
	IORM	T4,DEVFLO(T1)	;POSSIBLY INVALIDATE THIS DDB.
	JRST	FLUSH2		;GO TO NEXT DDB.
COMMENT #
@@SUBROUTINE FLUSHA
@@PURPOSE
SUBR TO WRITE OUT ALL DDB PNTR AREAS THAT NEED WRITING OUT
FOR THIS VERSION OF A FILE.  INVALIDATES ALL THE DDBS FOR
THIS RIB.  OUR OWN DDB DOES NOT NEED TO BE FLUSHED, SO IT IS
JUST MARKED INVALID.
@@ENTRY
EXPECTS F/ OUR DDB.
@@ACCUM
DESTROYS T1-T4, U, AND PG.
@@EXIT
SKIP RETURNS ON SUCCESS.
NON-SKIP RETURNS ON BAD RIB.
@@ #

INTERNAL FLUSHA

FLUSHA:	SETOM	DEVFLO(F)	;INVALIDATE US.
	PUSH	P,P1		;SAVE P1.
	PUSH	P,F		;SAVE F.

    ;FIND THE NEXT VALID DDB FOR THIS FILE, WITH PTRCHG ON.
	HRRZ	P1,DEVATB(F)	;GET P1/ OUR
	JUMPN	P1,.+2		;ATB.
	STOPCD
	HRRZ	F,ATBFNB(P1)	;
	HRRZ	F,FNBDBL(F)	;
FLSHA2:	SKIPG	DEVFLO(F)	;VALID?
	JRST	FLSHA4		;NO, DON'T BOTHER WITH IT.
	HRRZ	T1,DEVATB(F)	;YES, ON OUR
	CAIE	T1,(P1)		;VERSION OF THE FILE?
	JRST	FLSHA4		;NO, IGNORE IT.
	HLLZ	T1,DEVIAD(F)	;YES, NEED TO
	TLNE	T1,PTRCHG	;WRITE IT OUT?
	JRST	FLSHA5		;YES.
FLSHA3:	SETOM	DEVFLO(F)	;NO.  JUST INVALIDATE.
FLSHA4:	HRRZ	F,DEVDBL(F)	;GET THE NEXT DDB
	JUMPN	F,FLSHA2	;ON THE FILE.
	POP	P,F		;
	POP	P,P1		;
	JRST	CPOPJ1		;

    ;HERE WITH A DDB THAT NEEDS WRITING.  WRITE IT AND ANY
    ;OTHER DDBS FOR THE SAME RIB.
FLSHA5:	MOVE	T1,DEVRIB(F)	;
	PUSHJ	P,MWLRIB	;
	JRST	[POP P,F	;ERROR IN RIB.
		POP P,P1	;
		POPJ P,]	;
	PUSHJ	P,PTROU0	;FLUSH THIS DDB.
	SETO	T1,		;THEN DO ANY
	PUSHJ	P,FLUSH		;OTHER DDBS FOR THIS RIB.
	PUSHJ	P,RELRIB	;RELEASE THE RIB.
	JRST	FLSHA3		;GO TO NEXT DDB.
COMMENT #
@@SUBROUTINE CREPAG
@@PURPOSE
SUBR TO ALLOCATE A DISK PAGE AND ZERO IT.
@@ENTRY
EXPECTS T2/ RETRIEVAL PNTR WITH WHICH TO TRY TO BE CONTIGUOUS,
F/ DDB, AND S/ DEVIOS.  T2 MAY BE A HOLE, REAL, OR 0.
CHECKS FOR CONTROL C WAITING UNLESS P1 HAS FLG.CC ON.
@@ACCUM
DESTROYS T1-T4 AND PG.
@@EXIT
ON SUCCESS, SKIP RETURNS WITH T2/ THE RETRIEVAL PNTR OBTAINED.
NON-SKIP RETURNS IF CNTRL C WAITING OR ON ALLOCATION ERROR.
NON SKIP RETURN TURNS ON FLG.ER IN THE RH OF P1 AND STORES
THE ERROR CODE IN LH OF P1.  (ERROR CODES ARE FALCTL (CONTROL
C WAITING) AND FALAQA(CAN'T ALLOCATE DISK PAGE).
@@ #

OPDEF VREMOV [CALLI -65]

CREPAG:	TRNE	P1,FLG.CC	;USER WANTS CNTRL C CHECK?
	JRST	CREPG1		;NO.
	MOVE	T1,JOB		;FIRST CHECK
	MOVE	T1,JBTSTS(T1)	;FOR CONTROL
	TLNE	T1,CNTRLC	;C WAITING.
	JRST	[HRLI P1,FALCTL	;YES, WAITING.
		JRST CREFL4]	;

CREPG1:	PUSH	P,P2		;COUNT OF TIMES TO TRY
	MOVEI	P2,^D10		;DESPITE BAD DISK PAGES.
	PUSH	P,T2		;SAVE OLD RET PNTR.
CREPG2:	PUSHJ	P,CHKQTA	;OKAY TO ALLOC A DISK PAGE?
	JRST	CREFAL		;NO.
	POP	P,T2		;YES, RESTORE OLD RET PNTR.
	TLNN	T2,RBREAL	;A REAL PAGE?
	SETZ	T2,		;NO, TAKE CARE OF HOLES.
	TLZ	T2,RBMASK-RBREAL ;
	MOVEI	T1,FBIT		;SET ARG IN T1 FOR KEPPAG.
	HRRZ	T3,DEVATB(F)	;T3/ ATB ADDR OR ZERO.
	PUSHJ	P,KEPPAG	;TRY TO GET A PAGE AND ITS SAT.
	JRST	[TRO S,IOBKTL	;ERROR RETURN, DON'T HAVE SAT.
		MOVEM S,DEVIOS(F)	;
		JRST CREFL1]	;
	PUSH	P,T2		;SAVE GOTTEN RETRIEVAL PNTR.
	MOVSI	T4,LMPVIR	;SET UP ARGS
	SETZ	T1,		;FOR
	MOVEI	T3,777		;CLRCOW.
	PUSHJ	P,CLRCOW	;CLEAR A PAGE.
	JRST	.+2		;FAIL.
	JRST	CREPDN		;SUCCESS.
	HRRZI	T1,(T1)		;ANYTHING BUT IN OR OUT
	CAIE	T1,FALIPE	;IO ERROR
	CAIN	T1,FALOPE	;IS
	JRST	.+2		;A BUG.
	STOPCD
	SETO	T1,		;ADJUST THE USER'S
	MOVEI	T3,1		;COUNTS TO REFLECT THAT HE
	HRRZ	T2,DEVATB(F)	;DOESN'T OWN THIS PAGE
	PUSHJ	P,UPDAC2	;ANYMORE.  LEAVE DSK CNTS ALONE.
	SETZM	(P)		;ZERO PNTR FOR NEXT CONTIG TRY.
	SOJG	P2,CREPG2	;TRY AGAIN.
	JRST	CREFAL		;
CREPDN:	MOVEI	T1,4		;CHARGE FOR THE
	PUSHJ	P,WRTCHG	;FOUR BLOCKS WRITTEN.
	POP	P,T2		;RETURN T2/ RETRIEVAL PNTR.
	POP	P,P2		;
	JRST	CPOPJ1		;


    ;SOME ERROR EXITS.
CREFAL:	POP	P,T2
CREFL1:	POP	P,P2		;
	HRLI	P1,FALAQA 	;
CREFL4:	TRO	P1,FLG.ER
	POPJ	P,
COMMENT #
@@SUBROUTINE CLRCOW
@@PURPOSE
SUBR TO MAP A DISK PAGE INTO %COW, CLEAR PART OF IT, AND THEN
REMOVE IT.
@@ENTRY
EXPECTS T1/ REL NO. OF 1ST WORD TO CLEAR, T3/ REL NO. OF LAST
WORD TO CLEAR, T2/ RET PNTR, T4/ ARG FOR MAPKRN, F/ DDB, AND
S/ DEVIOS.
@@ACCUM
DESTROYS T1-T4 AND PG.
@@EXIT
SKIP RETURNS IF ALL SUCCESSFUL, ELSE NON-SKIP RETURNS WITH
RH OF T1 THE ERROR CODE AS FOLLOWS: FALBDS, FALIPE, OR FALOPE.
@@ #

OPDEF PERSET [CALLI -72]
OPDEF VPGSTS [CALLI -71]

INTERN CLRCOW
EXTERNAL SAVE4

CLRCOW:	JSP	T4,SAVE4	;SAVE P3 AND P4 (AND P1,P2 ALSO)
	PUSH	P,T1		;SAVE START OF CLEARING.
	PUSH	P,T3		;SAVE LAST TO CLEAR.
	CAIG	T1,777		;DEBUGGING
	CAILE	T3,777		;CHECK.
	STOPCD
	JUMPL	T1,.+2		;THIS
	JUMPGE	T3,.+2		;TOO.
	STOPCD
	CAMLE	T1,T3		;ALSO THIS.
	STOPCD
	HRRZ	T1,DEVATB(F)	;SET UP
	MOVSI	P3,LMMRDW	;PROTOTYPE LMAP SLOT
	PUSH	P,W		;SAVE W.
	MOVEI	W,%COW.N+CNVVPN	;FOR MAPKRN.
	PUSHJ	P,MAPKRN	;MAP THE PAGE INTO %COW.
	JRST	[POP P,W	;RESTORE W.
		PUSHJ P,RELSAT	;WE DON'T WANT THE SAT.
		POP P,T3	;CLEAR JUNK
		POP P,T1	;FROM PDL.
		MOVEI T1,FALBDS	;SAY SAW A
		POPJ P,]	;BAD SAT.
	PUSHJ	P,SETLMA	;STORE BACK INTO THE SLOT.
	POP	P,W		;RESTORE W.
	PUSHJ	P,RELSAT	;DON'T WANT THE SAT.
	MOVE	T1,[PE.NER+1,,%COW.N+CNVVPN] ;SET IGNORE
	PERSET	T1,		;ERROR BIT.
	STOPCD
	MOVE	T1,%COW		;REF %COW.
	MOVEI	T1,%COW.N+CNVVPN
	VPGSTS	T1,		;GET PAGE STATUS
	  STOPCD
	TLNN	T1,PS.DER!PS.DTE ;DEVICE OR DATA ERROR?
	JRST	CLRCW4		;NO.
	POP	P,T3		;YES, CLEAR FROM
	POP	P,T1		;PDL.
	JUMPE	T1,.+2		;IF WE WERE CLEARING THE WHOLE
	TDZA	T1,T1		;PAGE, FORGET ABOUT LOGGING
	HRLZI	T1,004000	;ERRORS.
	IOR	T1,[XWD 1,%COW.N+CNVVPN] ;REMOVE
	VREMOV	T1,		;THE
	  STOPCD		;NOT SUPPOSED TO FAIL, IGNORE ERROR IS ON.
CLRCFL:	HRRZI	T1,FALIPE	;
	POPJ	P,
CLRCW4:	POP	P,T3		;RESTORE REL LAST TO CLEAR.
	MOVE	T1,(P)		;GET 1ST TO CLEAR.
	SETZM	%COW(T1)	;CLEAR 1ST.
	CAIN	T1,777		;DON'T BLT IF ONLY
	JRST	CLRCW6		;ONE WORD TO CLEAR.
	ADDI	T1,%COW+1	;MAKE A BLT
	HRLI	T1,-1(T1)	;AC.
	BLT	T1,%COW(T3)	;CLEAR.
CLRCW6:	POP	P,T1		;IF WE WANTED A WHOLE 0 PAGE,
	JUMPE	T1,.+2		;DON'T LOG ERRORS IN THE BATS
	TDZA	T1,T1		;SINCE WE STILL HAVE THE RIB AND
	HRLZI	T1,004000	;NO ONE WILL GET THIS PAGE AGAIN.
	IOR	T1,[XWD  1,%COW.N+CNVVPN] ;REMOVE THE
	VREMOV	T1,		;PAGE.
	  STOPCD		;THIS REALLY OUGHT TO DETECT IO ERRORS.
	JRST	CPOPJ1		;SUCCESS.
COMMENT #
@@SUBROUTINE WRTCHG
@@PURPOSE
SUBR TO CHARGE FOR WRITING BLOCKS.
@@ENTRY
EXPECTS T1/ NO. OF BLOCKS TO CHARGE FOR.
@@ACCUM
DESTROYS T1 AND T2.
@@ #

INTERN WRTCHG

WRTCHG:	PUSH	P,J		;
	LDB	J,PJOBN		;
	ADDM	T1,JBTWCT(J)	;INCREMENT COUNT OF
	ADDM	T1,JBTWCT	;BLOCKS WRITTEN.
	PUSH	P,T1		;
	PUSHJ	P,GTCGSZ	;GET T1/ CHARGING SIZE OF JOB IN K.
	POP	P,T2		;
	IMUL	T2,T1		;INCREMENT NO. OF
	ADDM	T2,JBTSOT(J)	;BLOCKS TIMES
	ADDM	T2,JBTSOT	;SIZE IN K.
	POP	P,J		;
	POPJ	P,




COMMENT #
@@SUBROUTINE WRTCHP
@@PURPOSE
SUBR TO CHARGE FOR WRITING ONE PAGE.
@@ENTRY
EXPECTS J/ JOB NUMBER.
@@ACCUM
DESTROYS T1.
@@ #

INTERN WRTCHP

WRTCHP:	MOVEI	T1,4		;
	ADDM	T1,JBTWCT(J)	;INCREMENT COUNT OF
	ADDM	T1,JBTWCT	;BLOCKS WRITTEN.
	PUSHJ	P,GTCGSZ	;GET CHARGING SIZE IN
	LSH	T1,2		;K TIMES 4 BLOCKS.
	ADDM	T1,JBTSOT(J)	;
	ADDM	T1,JBTSOT	;
	POPJ	P,
COMMENT #
@@SUBROUTINE GETRET
@@PURPOSE
SUBR TO GET A PLACE FOR THE NEXT RETRIEVAL PNTR.
@@ENTRY
EXPECTS DEVRET(F) TO POINT TO THE PREVIOUS RETRIEVAL PNTR,
(POSSIBLY "IN" DEVRB1-1).
@@ACCUM
DESTROYS T1, T4, AND PG.  MUST NOT DESTROY T2 OR T3.
@@EXIT
NON-SKIP RETURNS ON RIB ERROR OR ALLOCATION (OF RIB) ERROR,
WITH FLAG SET IN T1 ACCORDINGLY (FALRBE OR FALAQA).  DOES NOT
OUTPUT THE EXCEEDING QUOTA MSG.  SUCCESS RETURN IS A SKIP
RETURN WITH DEVRET(F) POINTING TO THE NEW PLACE.
@@ #


GETRET:	AOS	T1,DEVRET(F)	;ROOM LEFT IN THE
	CAIG	T1,DEVRBN(F)	;CURRENT DDB?
	JRST	CPOPJ1		;YES.  SUCCESS RETURN.
	PUSH	P,T2		;NO.  SAVE T2 AND
	PUSH	P,T3		;T3 FOR CALLERS.
	PUSH	P,U		;SAVE U.
	MOVE	T1,DEVRIB(F)	;MAKE SURE WE HAVE THE
	PUSHJ	P,MWLRIB	;CORRECT RIB.
	JRST	[POP P,U	;RIB ERROR.
		POP P,T3	;
		POP P,T2	;
		MOVEI T1,FALRBE	;
		POPJ P,]	;
	POP	P,U		;RESTORE U.
	MOVE	T1,DEVIAD(F)	;SEE IF WE HAVE TO
	TLNE	T1,PTRCHG	;OUTPUT THE CURRENT PNTRS.
	PUSHJ	P,PTROU2	;OUTPUT THE PNTRS.
	PUSHJ	P,NXTPT0	;TRY TO GET MORE PNTRS.
	SOS	-2(P)		;FAIL RETURN.
	POP	P,T3		;SUCCESS, RESTORE T2
	POP	P,T2		;AND T3 FOR CALLERS.
	JRST	CPOPJ1		;
COMMENT #
@@SUBROUTINE MWLRIB
@@PURPOSE
SUBR TO GET THE DISK PAGE WHOSE RETRIEVAL PNTR IS IN T1 INTO
%RIB, WRITE LOCKED.  (TAKES CARE OF ALREADY HAVING A RIB.).
CHECKS THE NEW RIB FOR CONSISTENCY, ALSO.
@@ENTRY
EXPECTS T1/ RET PNTR TO DESIRED PAGE.
@@ACCUM
DESTROYS T1-T4, PG, AND U.
@@EXIT
NON-SKIP RETURNS ON CONSISTENCY CHECK(HAS RELEASED RIB); ELSE,
SKIP RETURNS WITH RIB IN %RIB.
@@ #

INTERN MWLRIB

MWLRIB:	MOVEI	PG,%RIB.C	;
	SKIPN	T2,@%RIB.C+%CTUPT ;ALREADY HAVE A RIB?
	JRST	MWLRB3		;NO.
	CAMN	T1,PCBPTR(T2)	;YES, IS IT THE ONE WE WANT?
	JRST	CPOPJ1		;YES, SUCCESS RETURN.
	PUSH	P,T1		;NO, SO
	PUSHJ	P,MAPRLS	;RELEASE IT
	SKIPA	T1,(P)		;KEEP POINTER ON STACK, RESTORE IT TO T1.
MWLRB3:	PUSH	P,T1		;SAVE POINTER TO PRIME RIB FOR RIBCON
	PUSHJ	P,MAPWTL	;GET THE NEW RIB.
	MOVE	T1,%RIB		;PREREFERENCE RIB SO NO RESCHEDULING
				; (OTHERWISE SOMEONE COULD GET FILE LOKMOD
				; AND BELIEVE DEVFLO AND DEVRIB TOGETHER)
	MOVE	T1,DEVRIB(F)	;GET CURRENT POINTER
	EXCH	T1,(P)		;SAVE IT ON STACK, GET ONE WE NEED TO CHECK
	MOVEM	T1,DEVRIB(F)	;SAVE IN DEVRIB SO CAN CHECK AGAINST RIBSLF
	PUSHJ	P,RIBCON	;RIB OKAY?
	  PJRST	[POP P,DEVRIB(F) ;NO, BAD. RESTORE DEVRIB
		 PJRST RELRIB]	;RELEASE RIB AND RETURN.
	POP	P,DEVRIB(F)	;RESTORE GOOD DEVRIB.
	MOVE	S,DEVIOS(F)	;FILE WENT BAD WHILE
	TLNN	S,IOBDRB	;WE WAITED FOR THIS RIB?
	JRST	CPOPJ1		;NO, RETURN WITH RIB.
	PJRST	RELRIB		;YES, REL RIB AND FAIL RETURN.
COMMENT #
@@SUBROUTINE KILFIL
@@PURPOSE
SUBR TO FLAG A FILE WITH A BAD RIB AND INVALIDATE THE FILE
FOR EVERYBODY.
@@ENTRY
EXPECTS F/ DDB AND S/ DEVIOS.
EXPECTS THE FILE TO BE LOCKED.
EXPECTS A LOOKUP OR ENTER TO BE IN FORCE.
@@ACCUM
DESTROYS T1-T4, AND PG.
@@EXIT
RETURNS T1/FALRBE.
RELEASES BOTH RIBS BEFORE RETURN.
ALSO UNLOCKS THE FILE.
@@ #


INTERN KILFIL

    ;GET THE FILE LOCKED DOWN.
KILFIL:	TLNN	F,LOOKB!ENTRB	;DEBUGGING CHECK.
	STOPCD
	PUSHJ	P,RELRB2	;DUMP M2, SINCE WON'T NEED IT.
	TLNE	S,IOBDRB	;FILE ALREADY MARKED BAD?
	JRST	KILOUT		;YES, LITTLE FOR US TO DO.
	SKIPN	DEVLOK(F)	;ARE WE LOCKED ON THE FILE?
	STOPCD
	HLLZ	T1,DEVBTS(F)	;IS THIS FILE ALREADY
	TLNE	T1,DEPFLK	;LOCKED MODIFY BY US?
	JRST	KILFL2		;YES.
	PUSHJ	P,RELRIB	;NO, CAN'T
	PUSHJ	P,UNLFIL	;LOCK WHEN HAVE RIB.
	MOVEM	S,DEVIOS(F)	;
	PUSHJ	P,LOKMOD	;
	MOVE	S,DEVIOS(F)	;HAS SOMEBODY ELSE SET THE
	TLNE	S,IOBDRB	;ERROR BIT WHILE WE WAITED?
	JRST	KILOT4		;YES, CLEAN UP AND EXIT.

    ;TRY TO LOG THIS FILE.
KILFL2:	MOVEI	T1,KILBUF	;MAYBE LOG IT.
	SKIPN	(T1)		;
	JRST	KILF24		;ROOM TO LOG FIRST.
	ADDI	T1,LOGLEN	;
	SKIPE	(T1)		;ROOM TO LOG 2ND?
	JRST	KILFL4		;NO.
KILF24:	MOVE	T2,DEVPPN(F)	;
	MOVEM	T2,(T1)		;
	MOVE	T2,DEVFIL(F)	;
	MOVEM	T2,1(T1)	;
	HLLZ	T2,DEVEXT(F)	;
	HLLZM	T2,2(T1)	;
	MOVE	T2,DEVRIB(F)	;
	MOVEM	T2,3(T1)	;
	HRRZ	T2,DEVATB(F)	;
	MOVE	T2,ATBRIB(T2)	;
	MOVEM	T2,4(T1)	;
	MOVE	T3,JOB		;
	MOVE	T2,JBTNAM(T3)	;
	MOVEM	T2,5(T1)	;
	MOVE	T2,JBTUNM(T3)	;
	MOVEM	T2,6(T1)	;

    ;HERE TO MARK THE FILE AS BAD.
      ;SET RIPUFE IN RIBLCW AND RIPBDR IN RIBSTS.
KILFL4:	HRRZ	T1,DEVATB(F)	;GET THE PRIME RIB
	MOVE	T1,ATBRIB(T1)	;(WITHOUT CHECKING
	MOVEI	PG,%RIB.C	;CONSISTENCY.).
	SKIPN	T2,@%RIB.C+%CTUPT ;ALREADY HAVE A RIB?
	JRST	KILF42		;NO.
	CAME	T1,PCBPTR(T2)	;YES.  IS IT THE ONE WE WANT?
	JRST	KILF41		;NO.
	MOVE	T1,JOB		;YES.  IS IT
	LDB	T1,%CTSTS(PG)	;WRITEABLE?
	CAIE	T1,STAWTU	;
	CAIN	T1,STAWTL	;
	JRST	KILF43		;YES.
	CAIE	T1,STACML	;
	CAIN	T1,STAWLN	;
	JRST	KILF43		;YES.
KILF41:	PUSHJ	P,MAPRLS	;HERE TO RELEASE CURRENT RIB,
	HRRZ	T1,DEVATB(F)	;AND GET
	MOVE	T1,ATBRIB(T1)	;THE
KILF42:	PUSHJ	P,MAPWTL	;PRIME RIB WRITEABLE.
KILF43:	HRRZI	T1,RIPBDR	;SET RIPBDR
	IORM	T1,%RIB+RIBSTS	;AND
	MOVSI	T1,RIPUFE	;RIPUFE.
	IORM	T1,%RIB+RIBLCW	;
	PUSHJ	P,RELRIB	;
      ;SET ATPUFE IN ATBLCW.
	HRRZ	T2,DEVATB(F)	;
	MOVSI	T1,ATPUFE	;
	IORM	T1,ATBLCW(T2)	;
      ;ZERO ATBSIZ AND ATBALP, ADJUST DRBALC.
	LDB	T1,ATYALP	;
	HLRZ	T4,DEVDRB(F)	;
	ADDM	T1,DRBALC(T4)	;
	SETZ	T1,		;
	DPB	T1,ATYALP	;
	SETZM	ATBSIZ(T2)	;
      ;MARK ALL OF THE DDBS ON THIS VERSION OF THE FILE BAD.
	HRLZI	T1,IOBDRB	;T1/ BAD BIT.
	HRRZ	T4,ATBFNB(T2)	;T4/
	HRRZ	T4,FNBDBL(T4)	;DDB.
KILF44:	HRRZ	T3,DEVATB(T4)	;IS THIS DDB ON THE SAME
	CAIE	T3,(T2)		;VERSION OF THE FILE?
	JRST	KILF45		;NO, FORGET IT.
	SETOM	DEVFLO(T4)	;YES, MARK IT INVALID AND
	IORM	T1,DEVIOS(T4)	;BAD.
KILF45:	HRRZ	T4,DEVDBL(T4)	;GET T4/ NEXT DDB.
	JUMPN	T4,KILF44	;JUMP IF ONE THERE.
      ;SET RIPBDR IN LH OF UFD'S RIBSTS, AND UFPERR IN UFDERR.
	HRRZ	T2,ATBSTS(T2)	;MAKE SURE THIS
	TRNN	T2,ATPSUP!ATPCRE ;HAS
	TRNE	T2,ATPDEL	;A UFD ENTRY.
	JRST	KILF49		;IT DOESN'T.
	HLRZ	T1,DEVDRB(F)	;GET THE RETRIEVAL
	MOVE	T1,DRBRIB(T1)	;PNTR TO THE UFD.
	MOVEI	PG,%RIB.C	;GET THE PRIME
	PUSHJ	P,MAPWTL	;RIB OF THE UFD.
	MOVSI	T1,RIPBDR	;MARK "A FILE IN THIS
	IORM	T1,%RIB+RIBSTS	;UFD IS BAD.
	HRRZ	T2,DEVATB(F)	;GET T1/
	HRRZ	T2,ATBFNB(T2)	;THE
	EXCH	T2,P3		;NUMBER OF
	LDB	T1,FNYUFP	;THE PAGE THIS
	MOVE	P3,T2		;ENTRY IS IN.
	SKIPLE	T1,%RIB+RIBPFS(T1) ;GET RET PNTR
	TLNN	T1,RBREAL	;TO THAT PAGE.
	JRST	KILF49		;THIS RIB BAD, TOO.
	LDB	T2,RBYUN1	;PROTECT FILIO
	CAIGE	T2,UNTLEN	;A LITTLE.
	SKIPN	UNTTBL(T2)	;
	JRST	KILF49		;
	PUSH	P,T1		;
	PUSHJ	P,RELRIB	;DUMP UFD RIB.
	POP	P,T1		;RESTORE T1/ RET PNTR.
	MOVEI	PG,%RIB.C	;GET THAT
	PUSHJ	P,MAPWTL	;PAGE INTO %RIB.
	MOVEI	T2,<^D512/UFDSIZ> ;T2/ NO. OF ENTRIES.
	MOVE	T1,DEVFIL(F)	;T1/ FILENAME.
	HLL	T3,DEVEXT(F)	;T3/ EXTENSION.
	SETZ	T4,		;INDEX INTO PAGE.
KILF46:	CAMN	T1,%RIB+UFDNAM(T4) ;MATCH ON FILENAME?
	JRST	KILF48		;YES.
KILF47:	ADDI	T4,UFDSIZ	;NO, NO MATCH, TRY
	SOJG	T2,KILF46	;NEXT.
	JRST	KILF49		;NONE LEFT, ERROR OF SOME TYPE.
KILF48:	HRR	T3,%RIB+UFDEXT(T4) ;EXT MATCHES
	CAME	T3,%RIB+UFDEXT(T4) ;ALSO?
	JRST	KILF47		;NO, TRY NEXT.
	MOVEI	T1,UFPERR	;YES.  SET
	IORM	T1,%RIB+UFDERR(T4) ;UFPERR IN OUR ENTRY.
	HRRZS	%RIB+UFDALP(T4)	;ZERO UFDALP.

KILF49:	MOVE	S,DEVIOS(F)	;RESTORE S FOR US.
KILOUT:	PUSHJ	P,RELRIB	;
KILOT4:	PUSHJ	P,UNLFIL	;
	MOVEI	T1,FALRBE	;
	POPJ	P,		;


;LOGGING AREA.
; ROOM FOR TWO ENTRIES.
LOGLEN==7
KILBUF: REPEAT LOGLEN*2,<Z>
COMMENT #
@@SUBROUTINE MAPKRN
@@PURPOSE
KERNEL SUBROUTINE TO MAP ANY DISK FILE PAGE TO A VM PAGE, GIVEN
THE RETRIEVAL PNTR TO THE DISK PAGE.  DOES NOT ALLOCATE.
ASSUMES CALLER HAS INSURED THAT VP IS NON-EXISTENT.
@@ENTRY
MAPKRN EXPECTS T1/ ATB ADDRESS, T2/ RETRIEVAL PNTR
	P3 CONTAINS PROTOTYPE LMAP SLOT (PROTECTION, LMPMXW)
W/ VP NO.
THERE MAY OR MAY NOT BE A SAT IN %SAT ON ENTRY.
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@EXIT
SKIP RETURNS WHEN SUCCESSFUL
NON-SKIP RETURNS WHEN SAT FOR REQUESTED PAGE IS BAD AND IT IS
NOT THE ONE BAD SAT WE CAN USE.
IN EITHER TYPE OF RETURN, MAY OR MAY NOT HAVE A SAT IN
%SAT-- CALL RELSAT TO CLEAN UP.
ON SUCCESS RETURN, LMAP SLOT IS IN P3 AND P4, READY TO STORE INTO DESTINATION
@@#


INTERN SATBAD,SATBRD
SATBAD: Z	;RETRIEVAL PNTR TO 1ST BAD SAT FOUND ON SYSTEM.
SATBRD:	Z	;NUMBER OF BAD SATS DUE TO READ ERRORS.



  ;BUILD SOME OF THE LMAP SLOT.
MAPKRN::TLNN	P3,LMPMXW	;MAX WRITE SET?
	JRST	MAPKN2		;NO, DON'T INCREMENT UMC.
	AOS	T4,ATBMWC(T1)	;YES, INC THE ATB WRITE COUNT.
	TRNN	T4,ATMMWC	;IF WE OVRFLWD, FIELD GOES TO 0.
	STOPCD
	HRRZI	T4,ATPMXU	;MAKE SURE OTHERS KNOW THAT THE
	IORM	T4,ATBSTS(T1)	;COUNT IS >=1.

  ;FIND OUT IF THIS DP IS SHARED OR UNSHARED.
MAPKN2:	PUSH	P,T1		;SAVE ATB ADDR FROM GETSAT.
MAPK21:	MOVEI	T1,MAPCML	;GET THE SAT FOR T2 COMPLETELY
	TLZ	T2,RBMASK-RBREAL ;
	PUSHJ	P,GETSAT	;LOCKED.
	  JRST	MAPK24		;BAD SAT.
	JRST	MAPK26		;OKAY.
MAPK24:	CAME	T4,SATBAD	;IS THIS THE BAD SAT WE CAN USE?
	JRST	MAPFAL		;NO, MAP FAILURE.
	TLZ	T2,RBREAL	;CLEAR FLGS FOR SRCSPT AND OTHERS.
	MOVE	T1,(P)		;T1/ ATB ADDRESS.
	PUSHJ	P,SRCSPT	;ALREADY IN SPT?
	JRST	[MOVE T1,(P)	;NO, TREAT LIKE MAPPED.
		PUSHJ P,INCUMC	;
		JRST MAPKN7]	;
	POP	P,T3		;YES, CLEAR PDL.
	JRST	MAPKN3		;

;HERE IF SAT IS GOOD.

MAPK26:	PUSH	P,T1		;SAVE MASK FOR AND POSITION
	PUSH	P,T3		;OF F BIT IN SAT.
	MOVE	T1,-2(P)	;GET ATB FOR & SAVE FROM SRCSPT.
	TLZ	T2,RBMASK	;CLEAR FLGS FOR SRCSPT AND OTHERS.
	PUSHJ	P,SRCSPT	;T2 IN THE SPT ALREADY?
	JRST	MAPKN6		;NO.
	SUB	P,[XWD 3,3]	;YES, CLEAR JUNK FROM PDL.

  ;HERE WHEN ALREADY IN THE SPT.
MAPKN3:	DPB	T4,LM3SPT	;SET SPT ENTRY PNTR IN LMAP.
	AOS	T3,SPTUSC(T1)	;INC THE SPT USE
	TRNN	T3,SPMUSC	;COUNT.
	STOPCD

MAPKN4:	TLO	P3,LMPSHR	;SET LMAP SLOT STATUS TO SHRD.
	SETZ	P4,
	JRST	CPOPJ1

  ;HERE ON MAP FAILURE.
MAPFAL:	POP	P,T1		;
	TLNN	P3,LMPMXW	;DID WE INC THE ATB WRITE COUNT?
	POPJ	P,		;NO.
	MOVEI	T4,ATMMWC	;YES.  FIRST CHECK THAT DECING
	TDNN	T4,ATBMWC(T1)	;IT WONT MAKE IT LESS THAN ZERO.
	STOPCD
	SOS	ATBMWC(T1)	;OKAY, DEC IT, AND IF IT WENT TO
	TDNE	T4,ATBMWC(T1)	;ZERO, CLEAR
	POPJ	P,		;HASN'T GONE TO ZERO.
	HRRZI	T4,ATPMXU	;ATPMXU.
	ANDCAM	T4,ATBSTS(T1)	;
	POPJ	P,

  ;HERE WHEN NOT IN SPT.  (MAY BE BECOMING SHARED.).
MAPKN6:	POP	P,T3		;RESTORE MASK FOR AND POSITION
	POP	P,T1		;OF F BIT IN SAT.
	TDNN	T1,%SAT+400(T3)	;IS THE MAPPED BIT ON?
	JRST	MAPKN7		;YES.

  ;HERE WHEN UNSHARED.
	ANDCAM	T1,%SAT+400(T3)	;SET THE MAPPED BIT IN THE SAT.
	POP	P,T1		;GET T1/ ATB ADDRESS.
	PUSH	P,T2		;SAVE RET PNTR.
	PUSHJ	P,INCUMC	;INC THE ATB USC COUNT, ETC.
	PUSHJ	P,CNVATB	;SET
	DPB	T1,LM3ATB	;LM3ATB.
	POP	P,T2		;RESTORE RET PNTR.
	MOVE	P4,T2		;GET LOW ORDER DISK ADDRESS
	TRZ	P4,PGE.A	;USES ALL BITS BUT PGE.A
	LSH	T2,-LMASRP	;GET HI ORDER RIGHT JUSTIFIED
	DPB	T2,LM3HDA
	JRST	CPOPJ1		;GIVE GOOD RETURN.

  ;HERE WHEN BECOMING SHARED.
MAPKN7:	MOVE	T1,(P)		;GET T1/ ATB ADDRESS.
	PUSHJ	P,INSSPT	;MAKE AN SPT ENTRY.
	 JRST	MAPKN8		;LOSE, GO WAIT FOR FREECORE.
	DPB	T4,LM3SPT	;SET LM3SPT.
	MOVSI	T3,SPPVIR	;VIRGIN
	TLNE	P3,LMPVIR	;BIT?
	IORM	T3,SPTVIR(T1)	;YES.
	POP	P,T2		;GET T2/ATB ADDR.
	JRST	MAPKN4

MAPKN8:	PUSH	P,T2
	PUSHJ	P,RELSAT
	POP	P,T2
	AOS	FCREQ##
	PUSHJ	P,FCWAIT##
	SOS	FCREQ##
	TLO	T2,RBREAL
	JRST	MAPK21
COMMENT #
@@SUBROUTINE UNLFIL
@@PURPOSE
SUBR TO UNLINK A FILE FROM THE ATOMIC FILE LOCKING QUEUE.
MUST BE CALLED FOR THE RUNNING JOB.  DOES NOT CARE IF THE
FILE IS NOT IN THE QUEUE.
@@ENTRY
EXPECTS F/ DDB.
@@ACCUM
DESTROYS NO ACS.
@@ #
INTERN UNLFIL

UNLFIL:	SKIPN	DEVLOK(F)	;NOTHING TO DO IF WE ARE
	POPJ	P,		;NOT IN THE QUEUE AT ALL.
	PUSH	P,T1		;
	PUSH	P,T3		;
	HLRE	T1,DEVLOK(F)	;T1/ PREVIOUS.
	HRRZ	T3,DEVLOK(F)	;T3/ NEXT.
	SETZM	DEVLOK(F)	;
	CAMN	T1,[-1]		;JUMP IF WE ARE
	JRST	UNLFL4		;FIRST IN THE QUEUE.

    ;HERE WHEN WE ARE NOT 1ST IN THE QUEUE.
	HRRM	T3,DEVLOK(T1)	;JUST
	JUMPE	T3,UNLOT6	;HAVE
	HRLM	T1,DEVLOK(T3)	;TO
	JRST	UNLOT6		;RELINK.

    ;HERE WHEN WE ARE FIRST IN QUEUE.
UNLFL4:	HRRZ	T1,DEVATB(F)	;
	HRRM	T3,ATBLOK(T1)	;POINT ATB TO NEXT.
	JUMPE	T3,UNLOT6	;DONE IF NO ONE IN QUEUE.
	HRRZI	T1,-1		;
	HRLM	T1,DEVLOK(T3)	;POINT NEXT TO ATB.
	HLLZ	T1,DEVBTS(F)	;UNLESS BOTH WE
	TLNE	T1,DEPFLK	;AND THE NEXT
	JRST	UNLFL6		;ARE READERS, WE
	HLLZ	T1,DEVBTS(T3)	;HAVE TO START SOME
	TLNN	T1,DEPFLK	;JOBS.
	JRST	UNLOT6		;NO NEED TO START ANY.
UNLFL6:	PUSH	P,J		;
	PUSH	P,F		;
	MOVE	F,T3		;START
	LDB	J,PJOBN		;THIS
	MOVEI	T1,RNQ		;NEXT
	DPB	T1,PJBSTS	;JOB.
	PUSHJ	P,SETRUN	;
	HLLZ	T1,DEVBTS(T3)	;
	TLNE	T1,DEPFLK	;IS IT A READER?
	JRST	UNLOUT		;NO, DONE.
	HRRZ	T3,DEVLOK(T3)	;YES, GET NEXT IN QUEUE.
	JUMPE	T3,UNLOUT	;JUMP ON NO MORE IN QUEUE.
	PUSHJ	P,STRSOM	;

UNLOUT:	POP	P,F		;
	POP	P,J		;
UNLOT6:	POP	P,T3		;
	POP	P,T1		;
	POPJ	P,


COMMENT #
@@SUBROUTINE LOKLES
@@PURPOSE
SUBR TO CHANGE A FILE WHICH IS QUEUED LOCK MODIFIED TO LOCK
UNMODIFIED, AND TO START UP ANYBODY AFTER IT IN THE QUEUE THAT
WE CAN.
MUST BE CALLED FOR THE RUNNING JOB.
@@ENTRY
EXPECTS F/ DDB.
@@ACCUM
DESTROYS NO ACS.
@@ #


LOKLES:	SKIPN	DEVLOK(F)	;WE BETTER BE
	STOPCD
	PUSH	P,T3		;LOCK
	MOVSI	T3,DEPFLK	;MODIFIED WHEN WE
	TDNN	T3,DEVBTS(F)	;ENTER HERE.
	STOPCD
	ANDCAM	T3,DEVBTS(F)	;NOW WE ARE LOCK UNMODIFIED.
	HRRZ	T3,DEVLOK(F)	;IS THERE A JOB BEHIND US
	JUMPE	T3,[POP P,T3	;TO START, MAYBE?
		POPJ P,]	;
	PUSH	P,T1		;
	PUSH	P,J		;
	PUSH	P,F		;
	PUSHJ	P,STRSOM	;
	POP	P,F		;
	POP	P,J		;
	POP	P,T1		;
	POP	P,T3		;
	POPJ	P,


;TINY SUBR FOR USE BY BOTH UNLFIL AND LOKLES, USED TO START UP
;JOBS AFTER US IN THE QUEUE.  DESTROYS T1, F, J, AND USES T3.
STRSOM:	HLLZ	T1,DEVBTS(T3)	;IS THIS A
	TLNE	T1,DEPFLK	;READER, TOO?
	POPJ	P,		;NO, DONE.
	MOVE	F,T3		;START
	LDB	J,PJOBN		;THIS
	MOVEI	T1,RNQ		;NEXT
	DPB	T1,PJBSTS	;JOB.
	PUSHJ	P,SETRUN	;
	HRRZ	T3,DEVLOK(T3)	;
	JUMPN	T3,STRSOM	;
	POPJ	P,
COMMENT #
@@SUBROUTINE LOKUNM/LOKMOD
@@PURPOSE
LOKUNM(LOKMOD) ARE SUBRS TO GET OUR DDB LOCK UNMODIFIED
(MODIFIED) ONTO THE ATOMIC FILE LOCKING QUEUE.  MUST BE CALLED
FROM THE RUNNING JOB.
THE ATOMIC FILE LOCKING QUEUE PREVENTS DDB POINTERS FROM CHANGING
OR BEING BELIEVED ERRONEOUSLY WHEN THE RIB STRUCTURE IS CHANGING,
SINCE PCB LOCKING IS NOT SUFFICIENT WHEN THE ALLOCATION CODE
IS JUGGLING MORE THAN TWO RIBS. ALL ROUTINES THAT ACCESS
THE DDB POINTER AREA ARE REQUIRED TO GET THE FILE LOCK
UNMODIFIED. ALL ROUTINES THAT CHANGE THINGS IN SUCH A WAY
THAT PCB LOCKING IS NOT SUFFICIENT GET THE FILE LOCK MODIFIED.
IT IS NOT PERMISSIBLE TO JUST GET A RIB LOCKED DOWN AND THEN READ OR MESS
WITH THE DDB POINTERS - IT IS ABSOLUTELY REQUIRED THAT THE FILE
BE LOCKED.
@@ENTRY
EXPECTS F/ DDB.
@@ACCUM
DESTROYS NO ACS.
@@ #

INTERN LOKMOD,LOKUNM

LOKUNM:	PUSH	P,P1
	SETZ	P1,
	JRST	LOKUM2

LOKMOD:	PUSH	P,P1
	MOVSI	P1,DEPFLK

LOKUM2:	SKIPE	DEVLOK(F)	;BETTER NOT BE LOCKED ALREADY.
	STOPCD
	PUSH	P,T3		;
	PUSH	P,T2		;
	MOVSI	T3,DEPFLK	;SET THE
	ANDCAM	T3,DEVBTS(F)	;STATUS
	JUMPE	P1,.+2		;FLAG
	IORM	T3,DEVBTS(F)	;APPROPRIATELY.
	HRRZ	T2,DEVATB(F)	;T2/ ATB ADDRESS.
	HRRZ	T3,ATBLOK(T2)	;T3/ 1ST IN QUEUE.
	JUMPN	T3,LOKUM4	;JUMP IF SOMEBODY IS IN QUEUE.

    ;HERE ON NO ONE IN QUEUE.
LOKUM3:	HRRM	F,ATBLOK(T2)	;POINT ATB TO US.
	HRRZI	T3,-1		;POINT US TO ATB
	HRLZM	T3,DEVLOK(F)	;AND AHEAD TO EOQ.
	JRST	LOKUT4		;DONE.

    ;HERE ON OTHERS IN THE QUEUE ALREADY.
LOKUM4:	JUMPN	P1,LOKUM6	;JUMP IF MODIFYING.
	PUSH	P,T1		;(UNMOD CAN START IF NO MODI-
	PUSH	P,T4		;FIERS AHEAD OF IT IN Q.).
	SETZ	T1,		;T1/ FLG IF SOMEBODY IN
LOKUM5:	HLLZ	T4,DEVBTS(T3)	;QUEUE
	TLNE	T4,DEPFLK	;IS A
	SETO	T1,		;MODIFIER.
LOKUM6:	HRRZ	T2,DEVLOK(T3)	;T2/ NEXT IN QUEUE.
	JUMPE	T2,LOKUM7	;ANYONE THERE?
	HRRZI	T3,(T2)		;YES.
	JUMPN	P1,LOKUM6	;
	JRST	LOKUM5		;
LOKUM7:	HRRM	F,DEVLOK(T3)	;FOUND EOQ. POINT PREV LAST
	HRLZM	T3,DEVLOK(F)	;TO US, AND WE TO IT AND EOQ.
	JUMPN	P1,.+2		;CAN'T START IF MODIFIER, OR IF
	JUMPE	T1,LOKUOT	;UNMOD & A PRECEEDING MODIFIER.
	PUSH	P,J		;PUT THIS JOB INTO
	MOVE	J,JOB		;THE ATOMIC
	MOVEI	T2,FLWQ		;FILE
	DPB	T2,PJBSTS	;WAITING
	POP	P,J		;QUEUE.
	PUSHJ	P,WSCHED	;
	JUMPN	P1,LOKUT4	;
LOKUOT:	POP	P,T4		;
	POP	P,T1		;
LOKUT4:	POP	P,T2		;
	POP	P,T3		;
	POP	P,P1
	POPJ	P,
	END
    OJÞ