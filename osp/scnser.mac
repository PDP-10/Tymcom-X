TITLE SCNSER - TYMNET VERSION OF SCNSER

;THE 620 AND PDP-10 SHARE CORE AS A MEANS OF COMMUNICATION.
;THE 620 PUTS THINGS DESTINED FOR THE PDP-10 INTO A RING
;BUFFER AND VICE VERSA. THE PDP-10 EXAMINES THE STATE OF THE
;RING BUFFER EVERY CLOCK TICK. FOR OUTPUT, THE PDP-10 NEVER
;PUTS OUT MORE THAN 40 (=%CHRMX) CHARACTERS ON A GIVEN LINE
;WITHOUT CHECKING THE INPUT RINGS IN CASE THE 620 REQUESTS
;THE PDP-10 TO STOP DOING OUTPUT ON THAT LINE.

;NOTE VERY CAREFULLY THAT THESE ROUTINES DEPEND ON THE FACT THAT
;CLOCK LEVEL NEVER INTERRUPTS UUO LEVEL AND VICE VERSA.
;FOR THIS REASON THERE ARE NO INTERLOCKS BETWEEN THE TWO
;LEVELS. ANYONE WHO CHANGES THIS BEWARE!!!!!!!!!!

;A COUPLE OF DEFS

STDALT==33		;STANDARD ALTMODE

TTCHKS==4		;SIZE OF TELETYPE BUFFERLETS
TT2CHK==TTCHKS*2

IMGDIM==2		;TIME TO WAIT IN IMAGE AFTER FIRST CHR
IMGTIM==^D10		;TIME TO WAIT IN IMAGE MODE FOR FIRST CHR
TIWKC==^D72		;#CHARS TO WAKE UP JOB ON INPUT
TIRSVD==3		;NUMBER OF BUFFERLETS TO SAVE FOR EMERGENCY
OWTIM==^D20		;1/2 OF ORANGE-BALL-WAIT TIMEOUT ON ZAP
			;(SEE TTYZAP)

CTY==120		;FOR SPECIAL TYPOUT ON PARITY ERR

%CHRMX==40		;MAX NUMBER OF CHRS TO OUTPUT ON LINE WITHOUT
			;RETURNING TO INPUT RING CODE (THE EFFECT IS
			;THAT %CHRMX IS THE NUMBER OF CHARACTERS OF
			;"DELAY" IN GETTING BACKPRESSURE APPLIED
			;TO THE LINE)

%PBTIM==^D15		;PTY BLOCK INPUT TIMEOUT

;CONDITIONAL ASSEMBLY FLAGS

YLBUG==0		;1 IF BASE TURNS ALL ORANGE BALLS INTO YELLOW
OPCRET==1		;1 IF PROGRAMS THINK TTCALLS IGNORE IMAGE
SUBTTL TERMINAL CHARACTERISTICS DEFINITIONS

;TERMINAL CHARACTERISTICS

DEFINE TCHARS = <
Z(CRD,1,TYMTC,TMCCRD)
Z(IR,17,TYMTC,TMCIR)
Z(OR,17,TYMTC,TMCOR)
Z(PAR,1,TYMTC,TMCPAR)
Z(HDX,1,TYMTC,TMCHDX)
Z(PA,7,TYMTC,TMCPA)
Z(PB,7,TYMTC,TMCPB)
Z(PC,17,TYMTC,TMCPC)
Z(XON,1,TYMTC,TMCXON)
Z(ECH,1,TYMTC,TMCECH)
Z(RXE,1,TYMTC,TMCRXE)
Z(TYP,17,TYMTC,TMCTYP)
Z(NXO,1,BYTTC,LDPNXO)
Z(WID,377,ACWIDC,0)
Z(FC1,3,BYTTC,LDPFC1)
Z(FC2,3,BYTTC,LDPFC2)
Z(BSP,1,ACBSPC,0)
Z(ERA,1,ACERAC,0)
Z(DEF,1,ACDEFC,0)
Z(LCO,1,BYTTC,LDPLCO)
Z(TAB,1,BYTTC,LDPTAB)
Z(FRM,1,BYTTC,LDPFRM)
Z(LCT,1,BYTTC,LDPLCT)
Z(NFC,1,BYTTC,LDPNFC)
Z(PTP,1,ACPTPC,0)
Z(BSD,1,BYTTC,LDPBSD)
Z(TTP,377777777777,ACTTPC,0)	; [dws]
Z(RTC,1,BYTTC,LDPRTC)
>

ZZN==0
DEFINE Z(NAME,MAXVAL,TYPE,ARG) = <
	TCN'NAME==ZZN
	ZZN==ZZN+1
>
TCHARS
TCNN==ZZN
IFG <TCNN-^D36>,<
	PRINTX MORE THAN 36 TYMCOM-X TERMINAL CHARACTERISTICS
	QQQQQQ
>
TCBALL:	<-1 _ <^D36-TCNN>>
SUBTTL TYMNET TERMINAL CHARACTERISTICS

;DEFINE NAMES AND FIELD WIDTHS

DEFINE TERCHR = <
TC(ECO,1)	;ECHO
TC(CIE,1)	;ECHO CONTROL-I
TC(ELF,1)	;ECHO LF AS LF/CR/DELAY
TC(ECR,1)	;ECHO CR AS CR/LF
TC(CRD,1)	;CR DELAY
TC(IR,4)	;INPUT BAUD RATE CODE
TC(OR,4)	;OUTPUT BAUD RATE CODE
TC(PAR,1)	;PARITY
TC(HDX,1)	;HALF DUPLEX
TC(PA,3)	;PARAMETER A
TC(PB,3)	;PARAMETER B
TC(PC,4)	;PARAMETER C
TC(XON,1)	;X-ENABLE FOR REMOTE
TC(ECH,1)	;ECHO CONTROL-H
TC(RXE,1)	;REVERSE X-ENABLE
TC(TYP,4)	;TERMINAL TYPE (KATAKANA)
>

;DEFINE TERMINAL CHARACTERISTICS CODES

ZZN==0
DEFINE TC(N,Z)  <TMC'N==ZZN
ZZN==ZZN+1>

TERCHR

TMCALL==77	;PROBE CODE TO GET ALL TERMINAL CHARACTERISTICS
;DEFINE RECEIVED CHARACTERISTICS BYTE POINTERS

ZZWORD==0
ZZPOS==-1
DEFINE TC(N,W) <IFG <ZZPOS+W>-^D35,<ZZPOS==-1
ZZWORD==ZZWORD+1>
ZZPOS==ZZPOS+W
LDP'N:	POINT W,LDBTMR+ZZWORD(U),ZZPOS>

TABTMR:	TERCHR
;DEFINE SENT CHARACTERISTICS BYTE POINTERS

ZZWORD==0
ZZPOS==-1
DEFINE TC(N,W) <IFG <ZZPOS+W>-^D35,<ZZPOS==-1
ZZWORD==ZZWORD+1>
ZZPOS==ZZPOS+W
LDS'N:	POINT W,LDBTMS+ZZWORD(U),ZZPOS>

TABTMS:	TERCHR

MAXTMC==.-TABTMS-1
TMCSLP==^D21	;IF MAXTMC < TMC <= MAXTMC+TMCSLP, WE WILL
		;IGNORE TYMNET MESSAGES FOR THE <TMC> RATHER
		;THAN CRASHING (THIS LETS TYMNET GET AHEAD OF US)
TMCSIZ==ZZWORD+1
IFG MAXTMC-^D35,<PRINTX MORE THAN 36 TERMINAL CHARACTERISTICS
QQQQQQ>

INTERNAL LDSRXE		;CTYSIM NEEDS IT
SUBTTL OUTPUT REQUEST BITS

;WHEN A PORT WANTS SOMETHING SENT TO TYMNET, IT SETS ONE OF
;THESE BITS IN ITS LDBOUT WORD. MESSAGES CORRESPONDING TO
;HIGH-ORDER BITS ARE SENT FIRST.

DEFINE OUTBIT, <
ZZZ(HSH)	;HUSH - SUPRESS MESSAGES FROM INITIALIZATION ROUTINE
ZZZ(TRO)	;TERMINATE BLOCK OUTPUT
ZZZ(CGB)	;CHARACTER GOBBLER
ZZZ(BIN)	;BLOCK INPUT
ZZZ(TRI)	;TERMINATE BLOCK INPUT
ZZZ(BPN)	;BACKPRESSURE ON
ZZZ(BPF)	;BACKPRESSURE OFF
;-------messages above this line may be output on a backpressured port
ZZZ(BOP)	;BLOCK OUTPUT IN PROGRESS (PTYS ONLY)
ZZZ(SRD)	;RED BALL
ZZZ(SEC)	;ECHO MODE
ZZZ(STP)	;TERMINAL CHARACTERISTICS PROBE
ZZZ(STC)	;SET TERMINAL CHARACTERISTICS
ZZZ(SBL)	;SEND BELL (!)
ZZZ(FIL)	;FILLER CHARACTERS
ZZZ(RUB)	;RUBOUT CHARACTERS
ZZZ(OUT)	;OUTPUT CHARACTERS
ZZZ(BOT)	;BLOCK OUTPUT
ZZZ(SYL)	;YELLOW BALL
ZZZ(HNG)	;SOFT ZAP
ZZZ(ZAP)	;HARD ZAP
ZZZ(ECO)	;ECHO CHARACTERS
ZZZ(GBF)	;GREEN BALL
ZZZ(SOG)	;ORANGE BALL
>

ZZN==0
DEFINE ZZZ(NAME), <
	IFE <ZZN-36>, <
		PRINTX MORE THAN 36 OUTPUT BITS
		QQQQQQ
	>
	LOP'NAME:POINT 1,LDBOUT(U),ZZN
	ZZN==ZZN+1
>
OUTBIT

BPOKBN==LOPBPF-LOPHSH	;BIT# OF LOWEST-PRIORITY MESSAGE TYPE
			;THAT CAN BE SENT ON A BACKPRESSURED PORT
NUMECO==LOPECO-LOPHSH	;BIT # OF ECHO
LAPBIT==LOPSOG-LOPHSH   ;LAST LEGAL PRIORITY BIT
SUBTTL LINE DATA BLOCK

;LINTAB:	ONE WORD PER PORT. RH = ADR OF U DATA BLOCK
;		LH 13-17 =0 FOR @ LINTAB

;LDBDDB		ONE LINE DATA BLOCK PER PORT. LINK BETWEEN
;		THE LINE DATA BLOCK AND THE TTY F IS THE
;		THING MANIPULATED BY ATTACH AND DETACH.

;TTY LDB PROTOTYPE

SCNLDB:
PHASE 0

LDICLR:!
LDBDDB:! 0	;(RH)	ADDR OF ATTACHED DDB, IF ATTACHED
LDBLIN:! 0	;28-35	PORT NUMBER (LDPLNO)
LNLZIN==400000	;0	ZAPPER RECEIVED FROM TYMNET & NOT ECHOED
LDBOPB:! 0	;BYTE POINTER TO SET NEED-OUTPUT BIT
LDBOUT:! 0	;BITS SPECIFYING WHAT WANTS TO BE OUTPUT
LDBTCB:! 0	;(PTYS) BITS INDICATING CHANGED TERMINAL CHARACTERISTICS

LDBBIO:! 0	;(LH)	BLOCK OUTPUT BUFFER ADDR
		;(RH)	BLOCK INPUT BUFFER ADDR

LDBBKP:! 0	;^U POINTER, RESET TO HERE
LDBBKI:! 0	;(RH)	# INPUT CHARACTERS SINCE LBBBKP
		;(LH)	# BREAK2 CHARACTERS SINCE LDBBKP

LDBTIP:! 0	;INPUT PUTTER
LDBTIT:! 0	;INPUT TAKER
LDBTIC:! 0	;# CHARACTERS IN INPUT BUFFER
LDBECT:! 0	;ECHO TAKER
LDBECC:! 0	;# CHARACTERS IN ECHO BUFFER
LDBBKC:! 0	;(RH)	# BREAK CHARACTERS IN INPUT BUFFER
		;(LH)	# BREAK CHARACTERS IN ECHO BUFFER
LDBBK2:! 0	;(RH)	# BREAK2 CHARACTERS IN INPUT BUFFER
		;(LH)	# BREAK2 CHARACTERS IN ECHO BUFFER

LDBTOP:! 0	;OUTPUT PUTTER
LDBTOT:! 0	;OUTPUT TAKER
LDBTOC:! 0	;# CHARACTERS IN OUTPUT BUFFER

LDBFLP:! 0	;OUTPUT FILLER POINTER (FOR HT/VT/FF PADDING)

LDBRBI:! 0	;RUBOUT ECHO PUTTER
LDBRBO:! 0	;RUBOUT ECHO TAKER
LDBRBC:! 0	;# RUBOUT ECHO CHARACTERS
LDBLOG:! 0	;TYMNET LOGIN DATA

		;< 0	LOGGED-IN, BITS 4-35 HOLD DATA FROM SUPERVISOR
		;= 0	NOT IN USE
		;> 0	IN THE PROCESS OF LOGGING IN

LLLZAP==200000	;1	ZAPPER RECEIVED OR HANG UUO DONE ON PORT
LLLNLN==100000	;2	NO LINE, I.E., LLLZAP FROM ZAPPER, NOT HANG UUO
LLLHDX==004000	;6	HALF-DUPLEX
		;8-11	TERMINAL IDENTIFIER CODE
		;14-19	ORIGINATING NODE # (HIGH-ORDER 6 BITS)
		;22-27	ORIGINATING NODE # (LOW-ORDER 6 BITS)
		;29-35	ORIGINATING PORT #
LDBBYT:! 0	;RANDOM BYTES

L2LOEX==400000	;0	(MUST BE SIGN BIT) OUTPUT SHOULD BE
		;	GIVEN MORE ROOM (TO KEEP FROM TRAPPING
		;	DURING AN OUTSTR)
L2LCCS==200000	;1	SEEN 1 ESCAPE/^C
L2LTBK==100000	;2	(LDPTBK) TABS ARE BREAKS (BREAKSET 2 MODE)
L2LBBP==040000	;3	(LDPBBP) BACKSPACE IS PUNCTATION, NOT A BREAK
L2LNTB==020000	;4	(LDPNTB) DON'T ECHO HT, VT, FF
L2LLDF==010000	;5	JOB WANTS TO LEAVE DEFERRED ECHO MODE
L2LDEL==004000	;6	DELETE IN PROGRESS (I.E., WE HAVE TYPED
		;	A SLASH AND ARE ECHOING DELETED CHARS)
L2LOWS==002000	;7	ONCE-IN-20-SECOND LOGIC HAS FOUND
		;	L2LOWT SET
L2LBSP==001000	;8	(LDPBSP) SEND BACKSPACE FOR CHARACTER-DELETES
L2LOWT==000400	;9	LOGOUT LOGIC HAS SENT A YELLOW BALL AND
		;	IS WAITING FOR AN ORANGE BALL BACK
		;10-11	(LDPMOD) MONITOR MODE
		;12-13	(LDPFC2) FILLER CLASS 2 (HT)
		;14-21	(LDPWID) LINE WIDTH
		;22-23	(LDPFC1) FILLER CLASS 1 (VT FF)
		;24-27	(LDPTIM) IMAGE-INPUT-TIMEOUT TIMER
		;28-35	(LDPPOS) CURRENT LINE POSITION
LDBMOD:! 0	;BYTES TO INDICATE THE MODE LINE IS IN

LMLTBI==400000	;0	TRMI REQUESTED BUT TRMIHR NOT RECEIVED
LMLPSP==200000	;1	1 IF PORT STATUS RECEIVED BUT NOT READ
		;2-5	LAST PORT STATUS MESSAGE RECEIVED
LMLBIO==001000	;8	PORT ENABLED FOR BLOCK I/O
		;9-15	IMAGE COUNT FOR CHARGING
		;16-22	LINE MODE BITS FOR INPUT
		;16-18	ECHO MODE
		;19-22	INPUT MODE
		;23-31	IMAGE MODE BREAK CHARACTER
		;32-35	(UNUSED)
LDBDCH:! 0	;DEVICE CHARACTERISTICS

;BITS IN LH

LDLNOP==400000	; *0	TYMNET REQUESTS NO MORE OUTPUT
		;	(MUST BE SIGN BIT)
LDLSOX==200000	;  1	SUPPRESS OUTPUT TRANSLATION
LDLECS==100000	; *2	EAT COMMAND SYNC
LDLPTY==040000	;  3	PSEUDO-TTY
LDLCOM==020000	;! 4	IN COMMAND MODE
LDLBKA==010000	;! 5	SINGLE CHARACTER ACTIVATES
LDLBK2==004000	;! 6	IN BREAK2 MODE
LDLIMI==002000	;! 7	IN IMAGE MODE
LDLDEF==001000	;!*8	DEFERRED ECHO MODE
LDLOSU==000400	; *9	OUTPUT SUPRESS (^O)
LDLNFC==000200	; *10	NO FREE CRS ON LONG LINES
LDLNEC==000100	; *11	NO ECHO
LDLAUX==000040	; *12	AUX CIRCUIT
LDLLCT==000020	; *13	LOWER CASE TO UPPER CASE
LDLTAB==000010	; *14	TTY DOES TABS
LDLLCP==0000045	LOCAL COPY (2741)
LDLPTP==000002	; *16	IN PAPER TAPE MODE
LDLFRM==000001	; *17	TTY DOES FORMS AND VTABS

;! -- REFERENCED THROUGH LDPMDF TO SET LINE MODE
;* -- GIVEN TO USER IN SAME BIT POSITION BY GETLCH

;BITS IN RH

LDRBPS==400000	;BACKPRESSURE HAS BEEN SENT
LDRXOS==200000	;XOFF HAS BEEN SENT
LDRNXO==100000	;(LDPNXO) DON'T SEND XON/XOFF
LDRDEM==040000	;STAY IN DEFERRED ECHO MODE
LDRFCS==020000	;FULL CHARACTER SET MODE
LDRBIP==010000	;PTY BLOCK INPUT IN PROGRESS
LDBDCX:! 0	;DEVICE CHARACTERISTICS EXTENSION

;BITS IN LH

LXL120==400000	;1 IF FAST LINE, 0 IF SLOW (MUST BE SIGN BIT)
;LXLxx==200000	;(UNUSED 2-6-81)
LXLBSD==100000	;BACKSPACE == RUBOUT/^A (LPDBSD)
LXLERA==040000	;IF L2LBSP SET: SEND <BS><SP><BS> NOT JUST <BS>
		;FOR CHARACTER DELETE (LDPERA)
LXLDLR==020000	;SUPPRESS $ ECHO ON ALTMODES
LXLLCO==010000	;SET FOR CONV OF UPPER TO LOWER CASE ON OUTPUT (LDPLCO)
LXLOOK==004000	;OK TO SEND ORANGE BALL -- SET WHEN A YELLOW BALL
		;ARRIVES THAT THE MONITOR DIDN'T REFLECT (BECAUSE
		;THE USER WAS TRAPPING YELLOW BALLS)
LXLRTC==002000	;[Darren] Half-assed ^R/^T compatibility - says to
		; treat ^T as .USESTAT command if set.

;BITS IN RH -- SET WHEN EVENTS THAT COULD CAUSE INTERRUPTS
;	       HAPPEN TO A PORT FOR LATER POLLING WITH
;	       GETLCH OR THE POLPRT UUO (WHICH CLEAR
;	       THE BITS READ)

LXRESC==400000	;ESCAPE SEEN
LXROBS==200000	;ORANGE BALL SEEN
LXRPSS==100000	;PORT STATUS MESSAGE SEEN
LXRICL==040000	;INPUT CHARACTERS LOST
LXROCL==020000	;OUTPUT CHARACTERS LOST
LXRCHR==010000	;CHARACTER SEEN
LXRBRK==004000	;BREAK CONDITION SEEN:
		;1) BREAK CHARACTER READ IN NORMAL STATE
		;2) IMAGE BREAK HAPPENED IN IMAGE STATE
		;3) BREAK2 CHARACTER READ WITH BK2 SET
		;4) BLOCK RECEIVED IN BLOCK INPUT MODE
LXRYBS==002000	;YELLOW BALL SEEN
LXRCGS==001000	;CHARACTER GOBBLER SEEN
LXRIOS==000400	;OUTPUT DONE
LXRTCC==000200	;TERMINAL CHARACTERISTIC CHANGED OR PORT JUST ATTACHED

LDBTTP:! 0	; [dws] Optional sixbit terminal type.
		; [dws] Note! this is mechanism.  Policy is another matter.
LDBTMR:! BLOCK TMCSIZ	;TERMINAL CHARACTERISTICS RECEIVED
LDBTMS:! BLOCK TMCSIZ	;TERMINAL CHARACTERISTICS TO BE SENT
LDBTMT:! 0		;BIT N=1 TO SEND T.C. N

;LDBTMT BIT DEFINITIONS

ZZN==0
DEFINE TC(N,Z) <LTS'N==1B<ZZN>
ZZN==ZZN+1>
;TTY LDB. THERE IS ONE OF THESE PER PORT.
TERCHR

LDICLE==.-1
DEPHASE
LDBLEN==.-SCNLDB
;RANDOM LDB BYTE POINTERS

TRMBYP:	POINT 5,LDBLOG(U),11	;TERMINAL ID CODE

LDPLNO:	POINT 9,LDBLIN(U),35	;PORT NUMBER

LDPTBK:	POINT 1,LDBBYT(U),2	;TABS-AS-BREAKS
LDPBBP:	POINT 1,LDBBYT(U),3	;BACKSPACE-AS-PUNCTUATION
LDPNTB:	POINT 1,LDBBYT(U),4	;NO SPECIAL TAB HANDLING
LDPBSP:	POINT 1,LDBBYT(U),8	;BS OR ERASE FOR CHAR DELETE
LDPMOD:	POINT 2,LDBBYT(U),11	;MONITOR MODE
LDPFC2:	POINT 2,LDBBYT(U),13	;FILLER CLASS 2
LDPFA2:	POINT 2,LDBBYT(P1),13
LDPWID:	POINT 8,LDBBYT(U),21	;LINE WIDTH
LDPWDA:	POINT 8,LDBBYT(P1),21
LDPFC1:	POINT 2,LDBBYT(U),23	;FILLER CLASS 1
LDPFA1:	POINT 2,LDBBYT(P1),23
LDPTIM:	POINT 4,LDBBYT(U),27	;IMAGE INPUT TIMEOUT TIMER
LDPPOS:	POINT 8,LDBBYT(U),35	;ESTIMATED POSITION ON LINE

LDPPSM: POINT 4,LDBMOD(U),5	;LAST PORT-STATUS MSG
LDPCHG:	POINT 7,LDBMOD(U),15	;IMAGE COUNT FOR CHARGING
LDPLMD:	POINT 7,LDBMOD(U),22	;ALL THE LINE MODE (INPUT AND ECHO)
LDPMEC:	POINT 3,LDBMOD(U),18	;ECHO LINE MODE
LDPMIN:	POINT 4,LDBMOD(U),22	;INPUT LINE MODE
LDPIMB:	POINT 9,LDBMOD(U),31	;IMAGE MODE BREAK CHARACTER
LDPMOU:	POINT 4,LDBMOD(U),35	;OUTPUT LINE MODE

LDPSOX:	POINT 1,LDBDCH(U),1	;SUPPRESS OUTPUT TRANSLATION
LDPCOM:	POINT 1,LDBDCH(U),4	;COMMAND MODE BIT
LDPMDF:	POINT 5,LDBDCH(U),8	;SOURCE OF LINE MODE INFO
LDPNFC:	POINT 1,LDBDCH(U),10	;NO FREE CRLFS
LDPLCT:	POINT 1,LDBDCH(U),13	;LOWER CASE TRANSLATION (TO UPPER)
LDPTAB:	POINT 1,LDBDCH(U),14	;HARDWARE TABS
LDPPTP:	POINT 1,LDBDCH(U),16	;PAPER TAPE MODE
LDPFRM:	POINT 1,LDBDCH(U),17	;HARDWARE FF/VT
LDPNXO:	POINT 1,LDBDCH(U),20	;DON'T SEND XON/XOFF
LDPDEM:	POINT 1,LDBDCH(U),21	;PERPETUAL DEFERRED ECHO MODE

LDPBSD:	POINT 1,LDBDCX(U),2	;BACKSPACE == RUBOUT/^A
LDPERA:	POINT 1,LDBDCX(U),3	;ERASE ON CHAR DEL
LDPLCO:	POINT 1,LDBDCX(U),5	;LOWER CASE OUTPUT ONLY
LDPRTC:	POINT 1,LDBDCX(U),7	;[Darren] special ^T mode
LDPTTP: POINT 36,LDBTTP(U),35	;[dws] terminal type word
SUBTTL DEVICE DATA BLOCK

;TTY DDB INTERRUPT-TO-CHANNEL BYTE POINTERS

ZZWORD==0
ZZBIT==-1
DEFINE ZZZ(N) = <IFG <ZZBIT+6>-^D35,<ZZBIT==-1
ZZWORD==ZZWORD+1>
ZZBIT==ZZBIT+6
DDPT'N:	POINT 6,DDBTRP+ZZWORD(F),ZZBIT>

DDPTAB:

ZZZ(SC)	;ESCAPE/^C RECEIVED
ZZZ(CH)	;CHARACTER RECEIVED
ZZZ(LN)	;BREAK RECEIVED
ZZZ(TI)	;I/O WAIT
ZZZ(TS)	;I/O WAIT SATISFIED
ZZZ(LC)	;LOST CHARACTERS
ZZZ(OB)	;ORANGE BALL RECEIVED
ZZZ(ZP)	;ZAPPER RECEIVED
ZZZ(PS)	;PORT STATUS MESSAGE RECEIVED
ZZZ(YB)	;YELLOW BALL RECEIVED
ZZZ(CG)	;CHARACTER GOBBLER RECEIVED
ZZZ(TC)	;TERMINAL CHARACTERISTIC CHANGED AT OTHER END OF PTY

TRPLEN==.-DDPTAB

;TRAP NUMBER INTERNALS

TTNESC==DDPTSC-DDPTAB
TTNCHR==DDPTCH-DDPTAB
TTNLIN==DDPTLN-DDPTAB
TTNYLB==DDPTOB-DDPTAB

;OTHER DDB BYTE POINTERS

DDPBBP:	POINT 1,DDBDCH(F),0	;BACKSPACE AS PUNCTUATION
DDPTBK:	POINT 1,DDBDCH(F),1	;TABS ARE BREAKS
DDPNTB:	POINT 1,DDBDCH(F),2	;NO SPECIAL TAB ACTION
DDPIMB: POINT 9,DDBDCH(F),35	;IMAGE MODE BREAK CHARACTER
DDPMOD: POINT 4,DEVIOS(F),35	;DATA MODE
DDPCOM: POINT 1,DDBDCH(F),3	;SAVED STATE OF LDLCOM
DDPNZP:	POINT 1,DEVMOD(F),5	;NO-ZAP BIT
;TTY DDB. ONCE CREATES ONE OF THESE PER JOB FOR TTYTAB TO POINT TO.

TTYLST:		;LABEL FOR FIRST TTY DDB IN CHAIN
SCNDDB:		;GLOBAL LABEL

PHASE 0

	SIXBIT /TTY0/		;DEVNAM (PHYSICAL NAME)
	XWD 0,STTYBF+1		;DEVCHR. SIZE OF USER BUFFER
	0			;DEVIOS
	XWD 0,SCNDSP		;DEVSER
	XWD DVTTY+DVIN+DVOUT,<<1_B>+<1_A>+<1_AL>+<1_I>+<1_IB>+<1_XA>>
				;DEVMOD
	0			;DEVLOG (LOGICAL NAME)
	0			;DEVBUF
	0			;DEVIAD
	0			;DEVOAD
DEVCLS:! XWD 200000,0		;CLASS
DDBDCH:! 0	;PROCESS-RELATED DEVICE CHARACTERISTICS NOT IN DEVIOS
	DCLBBP==400000	;0	BACKSPACE IS PUNCTATION (DDPBBP)
	DCLTBK==200000	;1	TABS ARE BREAKS (DDPTBK)
	DCLNTB==100000	;2	DON'T ECHO HT/VT/FF (DDPNTB)
	DCLCOM==040000	;3	SAVED STATE OF LDLCOM (DDPCOM)
			;27-35	IMAGE MODE BREAK CHARACTER (DDPIMB)
DDBBLK:!			;(LH) BACK LINK (PREVIOUS TTY DDB)
DDBLDB:! 0			;(RH) LDB ADDR
DDBTRP:! BLOCK <TRPLEN+5>/6	;INTERRUPT-TO-CHANNEL ASSIGNMENTS

DEPHASE

SCNDDS==.-SCNDDB
;TTY FILE STATUS BITS

;LEFT HALF

TTYOUW==400000	;0	TI MEANS OUTPUT WAIT, NOT INPUT WAIT
TWTSPC==200000	;1	TI BECAUSE SYSTEM OUT OF BUFFERLETS
IOSBKA==100000	;2	BREAK ON ALL CHARACTERS
TINFIO==040000	;3	CAUSE AN OUTPUT-DONE INTERRUPT WHEN OUTPUT DONE
TIOUSE==020000	;4	UUO IN PROGRESS, DON'T ZAP DDB

;RIGHT HALF

BK2IOS==001000	;26	BREAK ON PUNCTUATION
DLRSUP==000400	;27	NO ESCAPE ECHO
NOECHO==000200	;28	NO ECHO
FCS==000100	;29	FULL CHARACTER SET
SUBTTL TYMNET MESSAGES

;BUFFER RING MESSAGE FORMATS

;EACH LOGICAL RECORD IN THE BUFFER RING IS SOME NUMBER
;OF 8-BIT BYTES LONG. A LOGICAL RECORD ALWAYS STARTS
;ON A WORD BOUNDARY AND NEVER WRAPS AROUND THE BUFFER.

;IF BIT 0 OF A RECORD IS ONE, IT IS A FORMAT G RECORD AND
;BITS 1-7 ARE A CHARACTER COUNT; IF BIT 0 IS ZERO, BITS 1-7
;ARE AN OP CODE (MESSAGE TYPE NUMBER), AND THE FORMAT DEPENDS
;ON THE OPERATION.

;THE FORMATS ARE:

;FORMAT		0 1-7	8-15	16-23	24-31

;A		0 OP

;B		0 OP	PORT#

;C		0 OP	PORT#	DATA

;D		0 OP	PORT#	DATA1	DATA2

;E		0 OP	PORT#	COUNT	CHAR1
;		CHAR2	CHAR3	...

;F		0 OP	PORT#	DATA1	DATA2
;		DATA3	DATA4

;G		1 COUNT	PORT#	CHAR1	CHAR2
;		CHAR3	CHAR4	...

;H		0 OP	PORT#	COUNT1	COUNT2
;		ADDR1	ADDR2	ADDR3
;MESSAGE TYPES 0-17

;0	UNUSED, ERROR

;1	SYSTEM IS ANSWERED (FORMAT A), IGNORED ON INPUT
TYPANS==1

;2	SYSTEM IS SHUT (FORMAT A), IGNORED ON INPUT
TYPSHT==2

;3	THE SENDER HAS CRASHED (FORMAT A)
TYPCRS==3

;4	THE RECIPIENT SHOULD CRASH (FORMAT A)
TYPDIE==4

;5	THE 620 HAS BEEN TAKEN OVER BY A NEW SUPERVISOR
;	(FORMAT A)
TYPNSP==5

;6	LOGIN, NEXT 4 DATA CHRS ARE THE INFO ABOUT TERMINAL
;	TYPE AND PORT OF ORIGIN, THEN NAME, ETC.
;	(FORMAT B)
TYPLOG==6

;7	SUPERVISOR RESPONSE TO ESTABLISHING AN AUX CIRCUIT
;	SHOULD BE FOLLWED BY 4 CHRS AS IN TYPE 5 (FORMAT B)
TYPAUX==7

;10	BACKPRESSURE ON (FORMAT B)
TYPNOP==10

;11	BACKPRESSURE OFF (FORMAT B)
TYPOUP==11

;12	CHARACTER GOBBLER (FORMAT B), IGNORED ON INPUT
TYPGOB==12

;13	CIRCUIT ZAPPER (FORMAT B)
TYPZAP==13

;14	ENTER DEFERED ECHO MODE (FORMAT B)
TYPEDC==14

;15	LEAVE DEFERRED ECHO MODE (FORMAT B)
TYPLDC==15

;16	GREEN BALL (FORMAT B)
TYPGRN==16

;17	RED BALL (FORMAT B)
TYPRED==17
;MESSAGE TYPES 20-27

;20	YELLOW BALL (FORMAT B)
TYPYEL==20

;21	ORANGE BALL (FORMAT B)
TYPORG==21

;22	HANG CHARACTER (FORMAT B), NEVER USED FOR NOW
TYPHNG==22

;23	ENTER 2741 TRANSPARENT MODE (FORMAT B)
TYPETM==23

;24	LEAVE 2741 TRANSPARENT MODE (FORMAT B)
TYPLTM==24

;25	LOST BALL (FORMAT C). DATA HAS BEEN LOST FROM BUFFERS
;	DATA FIELD 0 IF ZAPPED TOWARD TERMINAL 377 TOWARD HOST
TYPLOS==25

;26	SUPERVISOR REQUEST PORT NUMBER -1 IF DETACHED JOB
;	(FORMAT C) 3RD BYTE NOT USED FOR NOW
TYPSUP==26

;27	SUPERVISOR RESPONSE (FORMAT C) 3RD BYTE IS ERROR CODE
TYPSUR==27
;MESSAGE TYPES 30-37

;30	SUPERVISOR STRING CHARACTER (FORMAT C) 3RD
;	BYTE IS CHARACTER FOR SUPERVISOR
TYPAXC==30

;31	TEST PATTERN PROBE (FORMAT F)
TYPTSP==31

;32	TEST PATTERN RESPONSE (FORMAT F)
TYPTSR==32

;33	HOST SAD (FORMAT F) UNHAPPY BITS IN BYTE 3-6
TYPSAD==33

;34	ECHO ON (FORMAT B)
TYPECN==34

;35	ECHO OFF (FORMAT B)
TYPECF==35

;36	TERMINAL CHARACTERISTICS (FORMAT D). FIRST DATA BYTE
;	INDICATES WHICH CHARACTERISTICS. SECOND DATA BYTE
;	INDICATES VALUE TO SET TO
TYPTCS==36

;37	TERMINAL CHARACTERISTICS PROBE (FORMAT C). DATA BYTE
;	INDICATES WHICH TERMINAL CHARACTERISTICS WERE REQUESTED
TYPTCP==37
;MESSAGE TYPES 40-47

;40	TERMINAL CHARACTERISTICS RESPONSE (FORMAT D). DATA
;	IS JUST LIKE TYPTCS. COMES IN IN RESPONSE TO A
;	PROBE (TYPTCP) ALSO IS REFLECTED BY REMOTE (PRESUMABLY)
;	WHEN TERMINAL CHARACTERISTICS ARE SENT (TYPTCS)
TYPTCR==40

;41	TELL SUPERVISOR NUMBER OF PORTS AND HOST NUMBER
;	FORMAT C THE PORT NUMBER IS THE HIGHEST TO USE
;	THE DATA BYTE IS THE HOST NUMBER
TYPHSI==41

;42	REQUEST FOR SUPERVISOR CLOCK INFO (FORMAT A)
TYPCLP==42

;43	RESPONSE WITH SUPERVISOR CLOCK INFO IN SECONDS SINCE
;	JANUARY 1,1974 (FORMAT F)
TYPCLR==43

;44	INITIATE BLOCK OUTPUT (FORMAT H)  <OUT>
TYPBKO==44

;45	BLOCK OUTPUT COMPLETE (FORMAT B)  <IN>
TYPBOC==45

;46	INITIATE BLOCK INPUT (FORMAT H)  <OUT>
TYPBIN==46

;47	BLOCK INPUT TERMINATED -- OUT OF BUFFER  <IN>
;	(FORMAT D)
TYPINB==47
;MESSAGE TYPES 50-57

;50	BLOCK INPUT TERMINATED -- END OF TRANSMISSION  <IN>
;	(FORMAT D)
TYPINE==50

;51	BLOCK INPUT TERMINATED -- TIMEOUT BY BASE  <IN>
;	(FORMAT D)
TYPINT==51

;52	REQUEST BLOCK INPUT TERMINATION  (FORMAT B)  <OUT>
TYPIRQ==52

;53	BLOCK INPUT TERMINATED -- BY HOST REQUEST  <IN>
;	(FORMAT D)
TYPIHR==53

;54	REQUEST BLOCK OUTPUT TERMINATION.	(FORMAT B)  <OUT>
TYPORQ==54

;55	BLOCK OUTPUT TERMINATED -- BY HOST REQUEST.  (FORMAT B) <IN>
TYPOHR==55

;56	NEGOTIATE FOR NUMBER OF BLOCK I/O PORTS   <IN/OUT>
;	(FORMAT C)
TYPNEG==56

;57	BREAK RECIEVED (FORMAT B) <IN>
TYPBRK==57
;MESSAGE TYPES 60-

;60	PORT STATUS RECEIVED. (FORMAT C) <IN>
TYPPSR==60

IFKMC<
	BYP1==^D9		;RIGHTMOST BIT POSITION OF FIRST BYTE
	BYP2==^D17	;   0F SECOND BYTE OF A BUFFER RING WORD
	BYP3==^D27	;      THIRD BYTE
	BYP4==^D35	;      LAST BYTE POSITION IN A BUF RING WD
	OPDEF	UUILDB	[101000,,0]	;KMC ILDB
	OPDEF	UUIDPB	[102000,,0]	;KMC IDPB
	OPDEF	EXTEND	[123000,,0]	;EXTENDED INSTRUCTION OPCODE
	OPDEF	MOVSLJ	[016000,,0]	;MOVE STRING LEFT JUSTIFIED
	DEFINE	TYPI(TYPE)		;FOR LOADING TYPES WITH A
	<TYPE_^D8>			;	MOVSI INSTR
	>;END IFKMC
IFNKMC<
	BYP1==^D7		;RIGHTMOST BIT POSITION OF FIRST BYTE
	BYP2==^D15	;   0F SECOND BYTE OF A BUFFER RING WORD
	BYP3==^D23	;      THIRD BYTE
	BYP4==^D31	;      LAST BYTE POSITION IN A BUF RING WD
	OPDEF	UUILDB	[ILDB 0]	;NORMAL ILDB
	OPDEF	UUIDPB	[IDPB 0]	;NORMAL IDPB
	DEFINE	TYPI(TYPE)		;FOR LOADING TYPES WITH A
	<TYPE_^D10>			;	MOVSI INSTR
	>;END IFNKMC
;BUFFER RING BYTE POINTERS

INPTYP:	POINT 8,IRING(P4),BYP1	;TYPE
INPLIN:	POINT 8,IRING(P4),BYP2	;LINE NUMBER
INPCHR:	POINT 8,IRING(P4),BYP3	;CHARACTER
INPCH2:	POINT 8,IRING(P4),BYP4	;SECOND DATA CHARACTER
INPDL1:	POINT 16,IRING(P4),BYP2	;FIRST TWO CHRS
INPDL2:	POINT 16,IRING(P4),BYP4	;SECOND TWO CHRS

;POINTER FOR PUTTING THINGS IN THE OUTPUT RING

OUPTYP:	POINT 8,ORING(P4),BYP1	;TYPE
OUPLIN:	POINT 8,ORING(P4),BYP2	;PORT NUMBER

;POINTERS FOR ASSEMBLING FULL WORDS FOR OUTPUT (IN P3)

WRPLIN:	POINT 8,P3,BYP2		;PORT NUMBER
WRPCHR:	POINT 8,P3,BYP3		;DATA CHARACTER
WRPCH2:	POINT 8,P3,BYP4		;SECOND DATA CHARACTER

SUBTTL CHARACTER TABLES

;HERE IS THE CHARACTER TABLE. IT INCLUDES A CHARACTER MODE FOR
;EACH OF INPUT, OUTPUT, ECHO, AND READ (BY PROGRAM). IT ALSO
;INCLUDES A SPECIAL ACTION CODE FOR EACH OF THESE.

DEFINE CHRATR (INP,OUT,RED,ECH,SPAI,SPAO,SPAR,SPAE)
	<BYTE (2) INP,OUT (3) SPAO,RED,ECH,SPAR (5) SPAI (4) SPAE>

CHPINP:	POINT 2,P3,1	;POINTER TO THE INPUT FIELD
CHPOUT:	POINT 2,P3,3	;POINTER TO THE OUTPUT FIELD
CHPSPO:	POINT 3,P3,6	;POINTER TO THE OUTPUT SPECIAL ACTION FIELD
CHPRED:	POINT 3,P3,9	;POINTER TO THE READ FIELD
CHPECH:	POINT 3,P3,12	;POINTER TO THE ECHO FIELD
CHPSPR:	POINT 3,P3,15	;POINTER TO THE READ SPECIAL ACTION FIELD
CHPSPI:	POINT 5,P3,20	;POINTER TO THE INPUT SPECIAL ACTION FIELD
CHPSPE:	POINT 4,P3,24	;POINTER TO THE ECHO SPECIAL ACTION FIELD

SALL
CHRTAB:
;CONTROL CHARACTERS

CHRATR 0,2,2,2,0		;NULL
CHRATR 0,2,2,2,13		;^A
CHRATR 2,2,2,2			;^B
CHRATR 0,2,0,0,1,0,0,0		;^C
REPEAT 3,<
CHRATR 2,2,2,2>			;^D,^E,^F
CHRATR 2,2,2,3			;^G
CHRATR 0,0,0,0,17,4,6,11	;BACKSPACE
CHRATR 0,0,0,0,6,1,5,3		;^I
CHRATR 2,2,2,3			;LINE FEED
CHRATR 2,0,2,0,0,2,0,5		;VERTICAL TAB
CHRATR 2,0,2,0,0,3,0,6		;FORM FEED
CHRATR 0,0,1,0,2,0,0,1		;RETURN
CHRATR 2,2,2,2			;^N
CHRATR 0,2,2,2,3		;^O
CHRATR 2,2,2,2			;^P
CHRATR 0,2,2,2,4		;^Q
REPEAT 2,<
CHRATR 2,2,2,2>			;^R,^S
CHRATR 0,2,2,2,20		;^T
CHRATR 0,2,2,0,5,0,0,2		;^U
REPEAT 4,<
CHRATR 2,2,2,2>			;^V,^W,^X,^Y
CHRATR 2,2,0,0,0,0,3,7		;^Z
CHRATR 0,2,0,0,7,0,1,4		;ESCAPE (33)
CHRATR 0,2,2,2,16		;^\
CHRATR 2,2,2,2			;^]
CHRATR 0,2,2,2,10		;^^
CHRATR 0,2,0,2,11,0,2,0		;^_
;NUMBERS AND PUNCTUATION

REPEAT 20,<
CHRATR 3,1,3,4>			;PUNCTUATION
REPEAT 12,<
CHRATR 1,1,1,1>			;0-9
REPEAT 7,<
CHRATR 3,1,3,4>			;PUNCTUATION
;UPPER CASE

REPEAT 32,<
CHRATR 1,3,1,1>			;A-Z
REPEAT 4,<
CHRATR 3,1,3,4>			;PUNCTUATION
CHRATR 0,1,3,4,15		;_ (FOR TYMEX2 MODE)
CHRATR 3,1,3,4			;^
;LOWER CASE

REPEAT 32,<
CHRATR 1,1,4,1>			;a-z
REPEAT 2,<
CHRATR 3,1,3,4>			;PUNCTUATION
CHRATR 0,1,0,0,14,0,4,10	;ALTMODE (175) OR }
CHRATR 0,1,0,0,14,0,4,10	;ALTMODE (176) OR ~
CHRATR 0,2,2,2,12		;RUBOUT (177)
COMMENT ;
SUMMARY OF MEANING OF FIELDS

INPUT
	0-SPECIAL ACTION
	1-NORMAL CHARACTER
	2-BREAK CHARACTER
	3-CLASS 2 BREAK CHARACTER

OUTPUT
	0-SPECIAL ACTION
	1-OUTPUT AND COUNT FOR FREE RETURN
	2-OUTPUT BUT DO NOT COUNT
	3-UPPER CASE CHARACTER

REMOTE ECHO
	0-SPECIAL ACTION
	1-COUNT FOR FREE RETURN
	2-DO NOT COUNT FOR FREE RETURN
	3-SAME AS 2
	4-SAME AS 1

DEFERED ECHO
	0-SPECIAL ACTION
	1-PRINT CHARACTER AND COUNT FOR FREE RETURN
	2-BREAK CHARACTER, DO NOT PRINT, DO NOT COUNT
	3-BREAK CHARACTER, PRINT, DO NOT COUNT
	4-CLASS 2 BREAK CHARACTER, PRINT AND COUNT
	5-IMAGE CHARACTER
	6-BREAK CHARACTER, PRINT AND COUNT

READ
	0-SPECIAL ACTION
	1-NORMAL CHARACTER
	2-BREAK CHARACTER
	3-CLASS 2 BREAK CHARACTER
	4-LOWER CASE CHARACTER
;

;DEFINE STOP CHARACTERS (ESCAPES) FOR VARIOUS MODES

STOP10==3	;^C
STOP9==37	;^_
SUBTTL INPUT RING DISPATCHER

;HERE EVERY TICK FROM CHANNEL 7

SCNSER:
SCNINT:

    ;KEEP TRACK OF MAXIMUM INTER-CALL DELAY

	MOVE T4,UPTIME		;CHECK ON HOW LONG IT HAS BEEN
	EXCH T4,THSTIM##
	JUMPL T4,SCNNT1
	SUB T4,THSTIM##
	MOVNS T4
	CAMLE T4,MXTIM##
	MOVEM T4,MXTIM##	;CALC MAXIMUM SO FAR

    ;CHECK FOR CTY OUTPUT

SCNNT1:	SETZ	W,	;LET OUTPUT CODE KNOW IT'S REAL NOT PTY OUTPUT
	SKIPG	SCNLDB+LDBTOC	;IF THERE'RE CHARACTERS FOR THE CTY
	SKIPGE	CTYBLF		;OR IF SOMEONE WANTS TO RING THE BELL,
	PUSHJ	P, OPRCTY	;  GO DO IT

    ;CHECK OTHER UNUSUAL OUTPUT REQUESTS

	PUSHJ P,SETOUT
	 JRST SCNIN	;NO ROOM FOR CHARACTERS
	SKIPN P3,UPSHUT	;IS THERE A SHUT OR ANSWERED MESSAGE
	JRST SCNNT2
IFNKMC<	PUSHJ P,CLSCHR	;JUST FOR THE SAKE OF GOOD FORM
	 JRST SCNIN	;DON'T UNDERSTAND HOW WE GOT HERE BUT OK
	SETZM UPSHUT	;WILL SEND NOW, MARK NO MORE MSG
	PUSHJ P,WRDOUT	;SEND IT
	 JRST SCNIN	;THE LAST OF THE SPACE
>;END IFNKMC
IFKMC<	PUSHJ	P,MDRUP		;GET 3-BIT UP FLAGS
	HLRZ	P3,P3
	CAIN	P3,TYPI TYPSHT
	  MOVEM	T1,DRMSHT
	CAIN	P3,TYPI TYPANS
	  MOVEM	T1,DRMANS
	SETZM	UPSHUT>;END IFKMC
SCNNT2:	PUSHJ P,SNDSAD	;SEND A SAD MESSAGE IF APPROPRIATE
	 JRST SCNIN
IFKMC	<PUSHJ P,SNDHSI	;SEE IF ANY DRs NEED A TYPHSI MSG ETC.
	  JRST SCNIN>;END IFKMC
	PUSHJ P,SNDAUX	;ANY AUX CIRCUIT STUFF
	 JRST SCNIN	;OUT OF ROOM NOW
IFCPU (<KI,KL>), <	;TYMNET BASES REQUIRE BIO PORT NEGOTIATION,
			; NEXNET BASES DO NOT
	SKIPGE BIOCNT+0	;ANY CHANGE IN THE NUMBER OF BIO PORTS?
	PUSHJ P,SNDBIO	;REQUEST TO THE BASE.
	 JRST SCNIN
> ;END IFCPU (<KI,KL>)
;HERE TO PROCESS ALL THE MESSAGES IN THE INPUT RING, THEN
;JUMP TO OUTPUT CODE. FSCN GETS SET TO -1 IF ANY MESSAGES
;WERE PROCESSED.

SCNTIC:
SCNIN:	MOVE P4,IRPPDP
	CAMN P4,IRP620		;ANTHING IN INPUT RING?
	JRST SCNOUT		;NO, TRY OUTPUT
	SETOM FSCN
	MOVE	T1,IRP620	;ONLY PROCESS CURRENT DATA
	MOVEM	T1,IRPSTP#	; IN INPUT RING SO THAT BACKPRESSURE
				; CAN BE APPLIED IN TIME IF NECESSARY
SCNIN0:	CAMN	P4,IRPSTP	;PROCESSED ALL DATA PRESENT IN RING AT
				; START OF PASS?
	JRST	SCNOUT		;YES, TRY OUTPUT
;;;;;;;;BEGIN DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKMC<
	MOVE P1,IRPMB2		;SAVE PREVIOUS BASE POINTER
	MOVEM P1,IRPMB3
	MOVE P1,IRPMB1		;SAVE PREVIOUS BASE POINTER
	MOVEM P1,IRPMB2
	MOVE P1,IRP620
	MOVEM P1,IRPMB1		;SAVE CURRENT BASE POINTER TOO

	MOVE P1,IRPMP2		;SAVE PREVIOUS MESSAGE POINTER
	MOVEM P1,IRPMP3
	MOVE P1,IRPMP1		;SAVE PREVIOUS MESSAGE POINTER
	MOVEM P1,IRPMP2
	MOVEM P4,IRPMP1		;SAVE MESSAGE POINTER TOO

	MOVE P1,IRPMS2		;SAVE PREVIOUS MESSAGE
	MOVEM P1,IRPMS3
	MOVE P1,IRPMSG		;SAVE PREVIOUS MESSAGE
	MOVEM P1,IRPMS2
	MOVE P1,IRING(P4)	;SAVE FIRST WORD OF MESSAGE IN IRPMSG
	MOVEM P1,IRPMSG
>;END_IFKMC
;;;;;;;;END DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	LDB P1,INPTYP		;P1/ MESSAGE TYPE
	LDB U,INPLIN		;U/ PORT #
	CAILE U,RMXLIN
	JRST BADPRT		;BAD PORT
	MOVE U,LINTAB(U)	;U/ PORT LDB
	HLL U,LDBDCH(U)
	TRZE	P1, 200		;IF 200 BIT SET, IT'S DATA
	JRST	CHRMLT
	CAILE	P1, MXTYP
	  STOPCD		;BAD TYPE
CNTPRT:	XCT TYPTRN(P1)		;DISPATCH TO IT
SCNIN1:	ANDI P4,MSKIRG		;MASK FOR WRAP AROUND
	MOVEM P4,IRPPDP		;PUT IT AWAY FOR 620
	JRST SCNIN0		;GO SEE IF MORE INPUT

BADPRT:	CAIN	P1, TYPSUR	;BAD PORT # OK FOR THIS MESSAGE
	  JRST	CNTPRT
IFKMC<	CAIN	P1,TYPANS	;ALSO THESE MESSAGES W/KMC
	  JRST	CNTPRT
	CAIN	P1,TYPCRS
	  JRST	CNTPRT>;END IFKMC
	STOPCD			;CRASH ON BAD PORT NUMBER
;INPUT MESSAGE DISPATCH TABLE

TYPTRN:	PHASE 0
	STOPCD		;0 ILLEGAL
TYPANS:	JRST KMCANS	;1 ANSWERED, IGNORED BY KL & KI
TYPSHT:	AOJA P4,SCNIN1	;2 SHUT, IGNORE
TYPCRS:	JRST KMCRES	;3 BASE CRASH, IGNORED BY KL & KI
TYPDIE:	STOPCD		;4 BASE WANT US TO CRASH
TYPNSP:	JRST RCVNSP	;5 TAKEOVER OF BASE, RESET AUX CIRS
TYPLOG:	JRST LOGIN	;6 START LOGIN PROCESS ON THIS PORT
TYPAUX:	JRST RCVAUX	;7 AUX CIRCUIT PORT ESTABLISHED
TYPNOP:	PUSHJ P, NOOUT	;10 BACKPRESSURE ON
TYPOUP:	PUSHJ P, DOOUT	;11 BACKPRESSURE OFF
TYPGOB:	PUSHJ P,GOBCHR	;12 CHR. GOBBLER, CLEAR INPUT BUFFER
TYPZAP:	PUSHJ P,RCVZAP	;13 CIRCUIT ZAPPER
TYPEDC:	PUSHJ P,EDEC	;14 ENTER DEFFERED ECHO MODE
TYPLDC:	PUSHJ P,LDEC	;15 LEVAE "
TYPGRN:	JRST GREEN	;16 GREEN BALL
TYPRED:	JRST RED	;17 RED BALL
TYPYEL:	PUSHJ P,YELLOW	;20 YELLOW BALL
TYPORG:	PUSHJ P,ORANGE	;21 ORANGE BALL
TYPHNG:	AOJA P4,SCNIN1	;22 HANG, IGNORE
TYPETM:	AOJA P4,SCNIN1	;23 ENTER 2741 TRANSPARENT MODE
TYPLTM:	AOJA P4,SCNIN1	;24 LEAVE "
TYPLOS:	PUSHJ P, RCVLOS	;25 LOST BALL (CHARACTERS LOST ON INPT)
TYPSUP:	STOPCD		;26 SUPERVISOR REQUEST
TYPSUR:	JRST RCVSUR	;27 SUPERVISOR RESPONSE
TYPAXC:	STOPCD		;30 AUX CIRCUIT CHARACTER
TYPTSP:	STOPCD		;31 TEST PROBE
TYPTSR:	STOPCD		;32 TEST RESPONSE
TYPSAD:	STOPCD		;33 HOST SAD
TYPECN:	STOPCD		;34 ECHO ON, SHOULD NOT COME IN
TYPECF:	STOPCD		;35 ECHO OFF, SHOULD NOT COME IN
TYPTCS:	STOPCD		;36 SEND TERMINAL CHRS. SHOULD NOT COME IN
TYPTCP:	STOPCD		;37 TERM CHRS PROBE. SHOULD NOT COME IN
TYPTCR:	JRST RCVTMC	;40 TERM CHRS RESPONSE
TYPHSI:	STOPCD		;41 PORT AND SYSTEM NUMBER
TYPCLP:	STOPCD		;42 REQUEST FOR SUPERVISOR TIME
TYPCLR:	JRST CLKRSP	;43 CLOCK RESPONSE FROM SUP.
TYPBKO:	STOPCD		;44 INITIATE BLOCK OUTPUT
TYPBOC:	PUSHJ P,BLKOHR	;45 BLOCK OUTPUT COMPLETE SAME AS TERMINATED
TYPBIN:	STOPCD		;46 INITIATE BLOCK INPUT
TYPINB:	PUSHJ P,BLKIBF	;47 BLOCK INPUT TERMINATED: OUT OF BUFFER
TYPINE:	PUSHJ P,BLKEOT	;50 BLOCK INPUT TERMINATED: END OF TRANSMISSION
TYPINT:	PUSHJ P,BLKITM	;51 BLOCK INPUT TERMINATED: TIMEOUT BY BASE
TYPIRQ:	STOPCD		;52 REQUEST BLOCK INPUT TERMINATION
TYPIHR:	PUSHJ P,BLKIHR	;53 BLOCK INPUT TERMINATED: BY HOST REQUEST
TYPORQ:	STOPCD		;54 REQUEST BLOCK OUTPUT TERMINATION.
TYPOHR:	PUSHJ P,BLKOHR	;55 BLOCK OUTPUT TERMINATED: BY HOST REQUEST
IFCPU (<KI,KL>), <
TYPNEG:	JRST BLKNEG	;56 NEGOTIATE FOR NUMBER OF BLOCK I/O PORTS
>; END IFCPU(<KI,KL>)
IFNCPU (<KI,KL>), <
TYPNEG:	STOPCD		;56 NEG FOR # BLOCK I/O PORTS NOT USED
>; END IFNCPU (<KI,KL>)
TYPBRK:	AOJA P4,SCNIN1	;57 BREAK IGNORE FOR NOW
TYPPSR:	JRST RCVPS	;60 PORT STATUS RECEIVED

	DEPHASE

MXTYP==.-TYPTRN-1
SUBTTL NON-CHARACTER INPUT HANDLER ROUTINES

GOBCHR:	HRRZ	F, LDBDDB(U)
	JUMPE	F, SIMRZP	;IF NO JOB, TREAT AS ZAPPER
	LDB	J, PJOBN
	MOVE	T2, JBTSTS(J)
	TLNN	T2, JLOG	;IF NOT LOGGED-IN,
	JRST	SIMRZP		;  TREAT AS ZAPPER
	AOJ	P4, GOBCH1
FRCCGB:	HRRZ	F, LDBDDB(U)
	JUMPE	F, GOBCH2	;IF IT'S ATTACHED
	LDB	J, PJOBN
GOBCH1:	LDB	T1, DDPTCG
	JUMPE	T1, GOBCH2	;AND IT'S TRAPPING GOBBLERS,
	PUSHJ	P, TAKTRP	;  TAKE THE TRAP
GOBCH2:	MOVEI	T1, LXRCGS
	IORM	T1, LDBDCX(U)	;SET CHARACTER-GOBBLER SEEN
	PJRST	TSETBI		;CLEAR THE INPUT BUFFERS

NOOUT:	AOJ	P4,
FRCNOO:	LDB	T1, LOPZAP
	JUMPN	T1, CPOPJ	;IF ABOUT TO SEND ZAPPER, DO NOTHING
	MOVSI	T1, LDLNOP
	IORM	T1, LDBDCH(U)	;SET BACKPRESSURE FLAG
	DPB	T1, LDBOPB(U)	;CLEAR NEED-OUTPUT
	POPJ	P,

DOOUT:	AOJ	P4,
FRCDOO:	MOVSI	T1, LDLNOP
	ANDCAM	T1, LDBDCH(U)	;CLEAR BACKPRESSURE FLAG
	MOVEI	T1, 1
	DPB	T1, LDBOPB(U)	;SET NEED-OUTPUT
	POPJ	P,

LOGIN:	MOVE T1, LDBLIN(U)
	TLNE T1, LNLZIN	;IF THERE'S AN UNECHOED ZAPPER,
	JRST [
		MOVEI T1, NZAPLG
		PUSHJ P, ZAPBUG	;NOTE IT
		JRST .+1
	]
	SKIPE LDBLOG(U)	;IF LOGGED-IN OR LOGGING IN,
IFNKMC<	JRST ZAPLOG>	;  TREAT AS CIRCUIT ZAPPER
IFKMC<	JRST	[AOS LOGZAP	;NOTE THE ZAP
		MOVEM U,ZAPLPT	;SAVE THE PORT LDB ADDRESS
		PUSHJ P,FRCZAP
		AOJA P4,SCNIN1]>;END IFKMC
	MOVEI T1,10	;START GOING. WILL GET TO SIGN BIT AFTER 4 CHRS
	MOVEM T1,LDBLOG(U)
	SETZM LDBMOD(U)	;NOTHING SO FAR
	AOJA P4,SCNIN1

LDEC:	SKIPE LDBECC(U)	;ARE WE STILL ECHOING?
	JRST ZAPDFR	;YES, TREAT AS CIRCUIT ZAPPER
	MOVSI T1,LDLDEF
	TLNN U,LDLAUX	;NOT FOR AUX CIRCUITS
	ANDCAM T1,LDBDCH(U)	;RESET DEFERED ECHO FLAG
	AOJA P4,SETLMD		;AND RESET LINE MODE

EDEC:	MOVSI T1,LDLDEF
	TLNN U,LDLAUX
	IORM T1,LDBDCH(U)	;ENTER DEFFERED ECHO MODE
	AOJA P4,SETLMD
GREEN:	MOVEI	T1, 1
	DPB	T1, LOPGBF	;SET SEND-GREEN-BALL FLAG
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT BIT
	AOJA	P4, SCNIN1

RED:	MOVEI	T1, 0
	DPB	T1, LOPGBF	;CLEAR SEND-GREEN-BALL FLAG
	MOVEI	T1, 1
	DPB	T1, LOPSRD	;SET SEND-RED
	DPB	T1, LDBOPB(U)	;AND WANNA-OUTPUT
	AOJA	P4, SCNIN1

ORANGE:	AOJ	P4,
FRCORG:	PUSHJ	P, OBREC	;HANDLE INTERRUPT OR HIBER
	JFCL
OBFND:	MOVSI	T1, L2LOWT
OBFND1:	ANDCAM	T1, LDBBYT(U)	;CLEAR ORANGE-WAIT FLAG
	MOVEI	T1, 1
	DPB	T1, LDBOPB(U)	;SET NEED-OUTPUT (ZAP CODE MAY WAIT)
	POPJ	P,

YELLOW:	AOJ	P4,
FRCYEL:	IFN YLBUG, <
	PUSHJ	P, OBREC	;WAS JOB WAITING FOR AN ORANGE BALL?
	  JRST	.+2		;NO
	JRST	OBFND		;YES, TREAT AS ORANGE BALL
	MOVSI	T1, L2LOWT
	TDNE	T1, LDBBYT(U)	;IS ZAP LOGIC WAITING FOR ORANGE?
	JRST	OBFND1		;YES, TREAT AS ORANGE
	>
	MOVEI	T1, LXRYBS
	IORM	T1, LDBDCX(U)	;SET YELLOW-BALL-RECEIVED BIT
	HRRZ	F, LDBDDB(U)
	JUMPE	F, YELLW1	;IF IT'S ATTACHED,
	LDB	T1, DDPTYB
	JUMPE	T1, YELLW1	;AND IT'S TRAPPING YELLOW BALLS,
	PUSHJ	P, TAKTRJ	;  TAKE THE TRAP
	MOVSI	T1, LXLOOK
	IORM	T1, LDBDCX(U)	;  AND ALLOW JOB TO SEND 1 ORANGE BALL
	POPJ	P,		;OTHERWISE,
YELLW1:	MOVEI	T1, 1
	DPB	T1, LOPSOG	;  SET SEND-ORANGE
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
	POPJ	P,

ZAPDFR:	AOSA	DFRZAP		;RECORD NUMBER
ZAPLOG:	AOS	LOGZAP		; NOTE THE ZAP
	MOVEM	U, ZAPLPT	; SAVE PORT LDB ADDRESS
	PJRST	SIMRZP
;BLKIBF -- HERE WHEN A TYPE 47 (INPUT BUFFER FULL) IS RECEIVED
;	   FROM THE BASE.

BLKIBF:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCIBF:	PUSHJ	P, BLKICK	; EVERYTHING OK?
	  STOPCD		; NO
	JUMPE	F, FREBUF	; DETACHED: GIVE UP

    ;STORE THE CHARACTER COUNT INTO THE USER'S BUFFER

BLKIB1:	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDR
	HRRZM	T4, BIOCHR(T1)	; STORE THE COUNT

    ;WAKE/INTERRUPT THE JOB

BLKIB2:	PUSHJ	P, BIOWAK	; WAKE UP JOB
	MOVEI	T1, LXRBRK
	IORM	T1, LDBDCX(U)	; SET BIT FOR POLPRT
	LDB	T1, DDPTLN	; IF INTERRUPT-ON-BREAK ENABLED
	PUSHJ	P, TAKTRJ	; TAKE IT

    ;FREE THE BUFFER (AND, IF NO OUTPUT PENDING, THE BASE PORT)
    ;IF THE PORT HAS LEFT BLOCK MODE

BLKIB3:	MOVSI	T2, LMLBIO
	TDNN	T2, LDBMOD(U)	; BLOCK I/O ENABLED?
	PJRST	FREBUF		; NO: FREE THE BUFFER
	POPJ	P,

;BLKEOT -- HERE WHEN A "INPUT TERMINATED - END OF TRANSMISSION"
; (TYPE 50) IS RECEIVED FROM THE BASE.

BLKEOT:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCEOT:	PUSHJ	P, BLKICK	; EVERYTHING OK?
	  STOPCD		; NO
	PJUMPE	F, FREBUF	; DETACHED: GIVE UP
	LDB	T1, DDPMOD	; T1/ DATA MODE
	CAIN	T1, B
	JRST	BLKIB1		; BINARY: JUST RETURN THE DATA
IMGITM:	PUSHJ	P, BLKTRQ	; REQUEST INPUT TERMINATION
IMGIT2:	MOVSI	S, IOEND
	IORB	S, DEVIOS(F)	; SET IOEND
	JUMPN	T4, BLKIB1	; COUNT > 0: RETURN THE DATA
	PUSHJ	P, RELBI	; COUNT = 0: DONE WITH BLOCK INPUT
	JRST	BLKIB2		; WAKE THE JOB AND RETURN
;BLKITM -- HERE WHEN AN "INPUT TERMINATED -- TIMEOUT BY BASE"
; (TYPE 51) MESSAGE IS RECEIVED FROM THE BASE.

BLKITM:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCITM:	PUSHJ	P, BLKICK	; EVERYTHING OK?
	  POPJ	P,		; NO: IGNORE THE MESSAGE
	PJUMPE	F, FREBUF	; DETACHED: GIVE UP
	MOVEI	S, IOBKTL
	IORB	S, DEVIOS(F)	; SET IO.BKT
	LDB	T1, DDPMOD	; T1/ DATA MODE
	CAIN	T1, I
	JRST	IMGITM		; IMAGE: REQ TRM, RETURN DATA
	JUMPN	T4, BLKIB1	; COUNT>0: WAKE JOB, RETURN DATA

    ;HERE WHEN NOT IN IMAGE MODE, TO REPEAT THE REQUEST

	MOVE	T1, LDBMOD(U)
	TLNE	T1, LMLTBI	; TERMINATE PENDING?
	POPJ	P,		; YES: DON'T REREQUEST INPUT
	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	HRRZ	T2, BIOCHR(T1)	; T2/ SAME COUNT AS BEFORE
	PJRST	BLKIRQ		; REQUEST INPUT

;FREBUF -- CALLED WHEN A PORT WITH LMLBIO CLEAR RECEIVES
;	   A BLOCK INPUT TERMINATED MESSAGE

FREBUF:	PUSHJ	P, RELBI	; DONE WITH BLOCK INPUT
	JUMPN	T1, CPOPJ	; IF NO PENDING OUTPUT,
	PJRST	DECBC		;   FLAG 1 FEWER BLOCK PORT

; BLKICK -- COMMON SUBROUTINE FOR BLOCK-INPUT-TERMINATED
;	    MESSAGES.

BLKICK:	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	SKIPE	T1		; IF NO BUFFER
	SKIPL	BIOCHR(T1)	; OR NO REQUEST PENDING
	POPJ	P,		; FAIL-RETURN
	HRRZ	F, LDBDDB(U)	; F/ DDB
	AOS	(P)
	POPJ	P,
;BLKIHR -- HERE WHEN "INPUT TERMINATED -- BY HOST REQUEST"
; (TYPE 52)MESSAGE IS RECEIVED FROM THE BASE.

BLKIHR:	LDB	T4, INPDL2	; T4/ COUNT
	AOJ	P4,
FRCIHR:	MOVSI	T1, LMLTBI
	ANDCAM	T1, LDBMOD(U)	; CLEAR TERMINATE-PENDING FLAG
	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	SKIPN	T1		; IF THERE'S NONE THERE,
	POPJ	P,		;   NOTHING MORE TO DO
	MOVE	T2, BIOCHR(T1)	; T2/ IN-PROGRESS FLAG,,COUNT
	JUMPGE	T2, BLKIB3	; NO BLOCK INPUT IN PROGRESS
	HRRZ	F, LDBDDB(U)	; F/ DDB
	PJUMPE	F, FREBUF	; DETACHED: FREE THE BUFFER
	JRST	IMGIT2		; SET IOEND, RETURN DATA

;BLKOHR -- HERE WHEN AN "OUTPUT TERMINATED" (TYPE 52)
;	   OR AN "OUTPUT TERMINATED BY HOST REQUEST" (TYPE 53)
;	   MESSAGE IS RECEIVED FROM THE BASE

BLKOHR:	AOJ	P4,
	MOVSI T1,LDLNOP
	ANDCAM T1,LDBDCH(U)	;CLEAR OUTPUT BACKPRESSURE
	MOVEI T1,1
	DPB T1,LDBOPB(U)	;AND SET NEED-OUTPUT BIT
FRCOHR:	HLRZ T1,LDBBIO(U)	;T1/ OUTPUT BUFFER
	JUMPE T1,BLKOH1		;IF NONE, DO (ALMOST) NOTHING
	PUSHJ P,RELBO		;DONE WITH BLOCK OUTPUT
	JUMPN T1,BLKOH1		;IF NO ACTIVE BLOCK I/O
	MOVE T2,LDBMOD(U)
	TLNN T2,LMLBIO		;AND PORT WANTS OUT OF BLOCK MODE,
	PUSHJ P,DECBC		;  GET IT OUT
BLKOH1:	HRRZ F,LDBDDB(U)
	JUMPE F, CPOPJ		;IF ATTACHED,
	PJRST XMTWAK		;WAKE THE JOB
IFCPU (<KI,KL>), <
;SNDBIO -- HERE AT CHANNEL 7 LEVEL FROM SCNINT WHEN THERE ARE
;ANY BLOCK I/O PORT REQUESTS (EITHER INCREASE OR DECREASE)
;PENDING.  

SNDBIO:	PUSHJ P,CLSCHR		;FINISH PREVIOUS MESSAGE AND
	 POPJ P,		; RETURN IF NO MORE SPACE.
	MOVSI P3,TYPI TYPNEG	;PORT REQUEST TYPE FOR
;Following code commented out since there are no KMC's on
; KI's and KL's.
;IFKMC<	PUSHJ P,MDRUP		;GET UP DRs
;	JUMPE T1,CPOPJ		;IF NO NODES ARE UP THEN GIVEUP
;	SKIPA			;Don't shift the first time
;SNDBI1: LSH	T1,-3
;	TRNN  T1,7		;NO SKIP IF LOW 3 BITS ARE ALL 0s
;	  JRST SNDBI1		;Go try the next one
;	SUBI	T1,1
;	ANDI	T1,3
;	LSH	T1,6
;	DPB	T1,WRPLIN	;STUFF THE UP DR NUMBER IN PORT
;>;IFKMC.END
	HRRZS T1,BIOCNT+0		;GET THE NEW REQUEST COUNT
	DPB T1,WRPCHR		;AND WRITE INTO 1ST DATA CHAR
	AOS BIOANS		;INC RESP COUNT EXPECTED OF BASE
	JRST WRDOUT		;SEND THE REQUEST AND RETURN.

;BLKNEG -- AT SNDBIO, WE SENT A TYPE 54, ASKING FOR <BIOCNT+0>
;BLOCK I/O PORTS. WE GET HERE WHEN WE GET A TYPE 54 BACK FROM
;THE BASE, TELLING US HOW MANY WE CAN HAVE.

BLKNEG:	SKIPG	BIOANS		;IF WE DIDN'T SEND A REQUEST
	JRST	[
		AOS ERRBNG
		AOJA P4, SCNIN1	;  IGNORE THE "RESPONSE"
	]
	SOSG	BIOANS		;IF THERE'RE MORE RESPONSES COMING
	SKIPGE	T2, BIOCNT+0	;OR THERE'S ANOTHER REQUEST PENDING,
	AOJA	P4, SCNIN1	;  IGNORE THE RESPONSE
	LDB	T4, INPCHR	;T4/ # OF PORTS WE CAN HAVE
	MOVN	T1, T4
	ADD	T1, BIOPRT	;T1/ #PORTS BEFORE - #PORTS NOW
	JUMPE	T1, BLKNG4
	JUMPLE	T1, BLKNG2
	CAML	T2, BIOPRT	;IF NOW .LT. BEFORE .LE. #JOBS
	  STOPCD		;  SOMEONE'S GOING THE WRONG WAY
BLKNG2:	MOVE	T2, BPREQ	;T2/ OLD BLOCK-PORT-REQ
	ADDM	T1, BPREQ	;UPDATE BPREQ
	JUMPLE	T2, BLKNG3	;IF SOMEONE WAS IN BLOCK-PORT WAIT
	SKIPG	T1		;AND THERE'RE MORE PORTS NOW,
	SETOM	BPAVAL		;  TELL THE SCHEDULER
BLKNG3:	MOVEM	T4, BIOPRT	;SET THE NEW # OF PORTS
BLKNG4:	SKIPN	J, BIOJOB	;IF THERE'S A JOB IN AX WAIT,
	AOJA	P4, SCNIN1
	SETZM	BIOJOB
	MOVEI	T1, RNQ
	DPB	T1, PJBSTS
	PUSHJ	P, SETRUN	;  WAKE IT UP
	AOJA	P4, SCNIN1
> ;END IFCPU (<KI,KL>)
;HERE WHEN A "CHARACTERS LOST" MESSAGE (BUFFER ZAP) IS
;RECEIVED: IF THE DATA BYTE IS 0, OUTPUT CHARACTERS WERE
;LOST; OTHERWISE, INPUT CHARACTERS WERE LOST

RCVLOS:	AOJ	P4,
	AOS	TTYLOS		;RECORD CHARACTER LOST BY TYMNET
	LDB	T1, INPCHR	;T1/ DIRECTION
FRCLOS:	SKIPN	T1
	TROA	T1, LXROCL	; 0 => OUTPUT LOST
	MOVEI	T1, LXRICL	; 1 => INPUT LOST
	IORM	T1, LDBDCX(U)
	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ		;NOTHING TO DO IF NO DDB
	MOVEI T1,IOBKTL
	IORM T1,DEVIOS(F)	;SET ERROR FLAG
	LDB T1,DDPTLC
	PJRST TAKTRJ		;SET TO INTERRUPT

;HERE WHEN A TERMINAL CHARACTERISTICS VALUE IS RECEIVED

RCVTMC:	LDB T1,INPCH2	;VALUE
	LDB T2,INPCHR	;AND TYPE NUMBER
	CAILE T2,MAXTMC	;CHECK RANGE
	JRST RCVTCX	;(BAD)
	DPB T1,TABTMR(T2)
	AOJA P4,SCNIN1	;FINISHED

RCVTCX:	CAILE T2,<MAXTMC+TMCSLP>
	  STOPCD	;AMAZINGLY BAD
	AOS TMCOOR	;SLIGHTLY BAD -- BUMP OUT-OF-RANGE COUNT
	AOJA P4,SCNIN1
;HERE WHEN THE TIME AND DATE ARE RECEIVED

CLKRSP:	LDB T2,INPDL2	;GET HIGH ORDER BITS OF TIME
	ADDI P4,1
	ANDI P4,MSKIRG
	LDB T1,INPDL1		;GET LOW ORDER BITS
	DPB T2,[POINT 16,T1,19]
	SKIPL THSDAT
	AOJA P4,SCNIN1		;IGNORE IF ALREADY SET
	IDIVI T1,^D<24*60*60>	;DAYS IN T1, SEC IN T2
	IMUL T2,JFYSEC
	MOVEM T2,TIME
	ADDI T1,^D3653		;TO CONVERT TO JAN 1,1964
	MOVEM T1,THSDAT
	AOJA P4,SCNIN1

;HERE WHEN A PORT STATUS MESSAGE IS RECEIVED

RCVPS:	LDB	T1, INPCHR
	DPB	T1, LDPPSM	; STORE PORT STATUS MSG
	MOVEI	T1, LXRPSS
	IORM	T1, LDBDCX(U)	; AND NOTE THAT IT'S BEEN SEEN
	MOVSI	T1, LMLPSP
	IORM	T1, LDBMOD(U)
	HRRZ	F, LDBDDB(U)
	JUMPE	F, PSDONE	; NO TRAP IF NO DDB
	LDB	T1, DDPTPS
	PUSHJ	P, TAKTRJ	; SET TO INTERRUPT
PSDONE:	AOJA	P4, SCNIN1	; DONE
;HERE WHEN A CIRCUIT ZAPPER IS RECEIVED

RCVZAP:	AOS	NZAPIN		;# REAL, TRUE ZAPPERS IN
	MOVE	T1, LDBLIN(U)
	TLOE	T1, LNLZIN	;IF THERE'S ONE ALREADY IN,
	JRST	[
		MOVEI T1, NZAPN2
		PUSHJ P, ZAPBUG	;NOTE IT
		JRST SIMRZP
	]
	MOVEM	T1, LDBLIN(U)
SIMRZP:	ADDI	P4, 1
FRCZAP:	SKIPL	LDBLOG(U)	;IF PORT'S NOT LOGGED-IN,
	JRST	[
		SETZM LDBLOG(U)		;MARK IT TOTALLY NOT THERE
		MOVEI T1, 1
		DPB T1, LOPZAP		;SET SEND-ZAPPER
		DPB T1, LDBOPB(U)	;AND NEED-OUTPUT
		MOVSI T1, LDLNOP
		ANDCAM T1, LDBDCH(U)	;IGNORE BACKPRESSURE
		POPJ P,
	]
	MOVSI	T1, LLLNLN!LLLZAP
	IORM	T1, LDBLOG(U)	;MARK PORT AS EXTERNALLY ZAPPED
	MOVE	T1, LDBMOD(U)
	TLNN	T1, LMLBIO	;IF BLOCK-MODE SET,
	SKIPE	LDBBIO(U)	;OR BLOCK I/O'S STILL IN PROGRESS,
	PUSHJ	P, BIOZAP	;  RELEASE BUFFERS & CLEAR BLOCK-MODE
	TLNE	U, LDLAUX	;IF IT'S AN AUX PORT
	PJRST	ZAPAUX
	HRRZ	F, LDBDDB(U)
	JUMPE	F, CPOPJ
	MOVSI	T1, TTYATC
	TDNN	T1, DEVMOD(F)	;OR AT ANY RATE NOT A COMMAND PORT,
	PJRST	ZAPAUX		;  DETACH & TRY TO FREE DDB

    ;HERE WHEN A ZAPPER IS RECEIVED ON A JOB'S COMMAND PORT

	LDB	J,PJOBN		;J/ DON't FORCE,,JOB#
	PUSHJ	P,HNGTTY	;Force hangup for job/frame
	POPJ	P,
SUBTTL INPUT CHARACTER HANDLER

CHRMLT:	SKIPN LDBLOG(U)		;MIGHT BE LINE WE HAVE JUST
	JRST MLTNDB		;SENT ZAPPER ON, FIX INPUT RING
	MOVEI T1,IRING(P4)
	HRLI T1,(POINT 8,0,BYP2)	;SET UP A BYTE POINTER
	MOVEM T1,CHRRDP
CHRML1:	UUILDB T3,CHRRDP
	PUSHJ P,MOVCHR
	 SOJG P1,CHRML1		;CONTINUE
	JUMPG P1,CHRML3		;HERE AT END OR DEF ECHO MODE
CLRMLT:
;;;;;;;; MORE KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKMC<	MOVE P1,IRPMSG
	CAME P1,IRING(P4)
	  STOPCD		;CRASH ON KMC IRING OVERWRITE or bad P4
>;END_IFKMC
;;;;;;;; END KMC DEBUG CODE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	LDB P1,INPTYP		;NOW CLEAR OUT THE INPUT RING
	TRZ P1,200		;GET COUNT BACK
	HRRZ F,LDBDDB(U)	;CHARGE
	JUMPE F,MLTNDB
	LDB T1,PJOBN
	ADDM P1,JBTCIN(T1)
	ADDM P1,JBTCIN
MLTNDB:	ADDI P1,5	;GET NUMBER OF WORDS USED (2 BYTES FOR COUNT AND PORT)
	LSH P1,-2
	ADD P4,P1	;INCREMENT POINTER BY NUMBER USED
	JRST SCNIN1

CHRML2:	UUILDB T3,CHRRDP
	PUSHJ P,MOVCHR	;THIS IS THE DEFERED ECHO LOOP
	 JFCL		;SHOULD NOT BE GETTING HERE
CHRML3:	SOJG P1,CHRML2
	MOVEI	T1, 1
	DPB	T1, LOPECO	;SET SEND-ECHO
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	JRST CLRMLT
;CALLED WITH CHARACTER IN T3. DISPATCH ON CHARACTER TYPE AND LINE MODE

MOVCHR:	LDB P2,LDPMIN	;GET THE INPUT ODE
	TRNN T3,200
MOVCH2:	SKIPA P3,CHRTAB(T3)
	MOVE P3,CHRTAB-200(T3)	;GET CHR BITS
	LDB T2,CHPINP	;GET INPUT TYPE
MOVCH1:	XCT CIMTAB(P2)	;DO THE RIGHT THING FOR THE LINE MODE
	JRST (T1)	;THIS WILL USUALLY LOAD AN ADDRESS IN T1

;LINE MODE DISPATCH TABLE

CIMTAB:	JRST LOGCHR		;LOGIN
	JRST IMGDEF		;IMAGE,DEF ECHO
	JRST IMGRMA		;IMAGE,REM ECHO,BKA=1
	JRST IMGRMT		;IMAGE,REM ECHO,BKA=0
	HLRZ T1,MD0405(T2)	;NORMAL,DEF ECHO,BK2=0
	HRRZ T1,MD0405(T2)	;NORMAL,DEF ECHO,BK2=1
	HLRZ T1,MD0607(T2)	;NORMAL,REM ECHO,BKA=1,BK2=0
	HRRZ T1,MD0607(T2)	;NORMAL,REM ECHO,BKA=1,BK2=1
	HLRZ T1,MD1011(T2)	;NORMAL,REM ECHO,BKA=0,BK2=1
	HRRZ T1,MD1011(T2)	;NORMAL,REM ECHO,BKA=0,BK2=0
	HLRZ T1,MD1213(T2)	;COMMAND,REM ECHO
	HRRZ T1,MD1213(T2)	;COMMAND,DEF ECHO

;CHARACTER TYPE DISPATCH TABLES

; CHARACTER TYPES FOR INPUT
;
; 0 -> SPECIAL ACTION
; 1 -> NORMAL CHARACTER
; 2 -> BREAK (CONTROL) CHARACTER
; 3 -> BREAK2 (PUNCTUATION) CHARACTER

MD0405:	IACT0,,IACT0	; 0,, 0
	IACT1,,IACT1	; 1,, 1
	IACT2,,IACT2	; 2,, 2
	IACT3,,IACT4	; 3,, 4

MD0607:	IACT0,,IACT0	; 0,, 0
	IACT5,,IACT5	; 5,, 5
	IACT6,,IACT6	; 6,, 6
	IACT7,,IACT10	; 7,,10

MD1011:	IACT0,,IACT0	; 0,, 0
	IACT11,,IACT11	;11,,11
	IACT6,,IACT6	; 6,, 6
	IACT10,,IACT12	;10,,12

MD1213:	IACT0,,IACT0	; 0,, 0
	IACT13,,IACT21	;13,,21
	IACT14,,IACT22	;14,,22
	IACT15,,IACT17	;15,,17
;THIS ROUTINE IS CALLED BY ALMOST EVERYONE TO PUT A CHR INTO
;THE INPUT BUFFER

RCVCHR:	MOVE T4,TTFREN
	CAIG T4,TIRSVD
	JRST RECHLT	;OUT OF BUFFERLETS. GIVE HIM BELL
	MOVE T4,LDBTIC(U)
	ADD T4,LDBECC(U)
	CAML T4,TIWRNN		;OVER SMALL QUOTA?
	JRST RWARN		;TRY TO STOP HIS INPUT
RCVCH1:	PUSHJ P,CHRTRP	;TAKE A CHARACTER TRAP
	SKIPN T2,LDBTIP(U)
	PUSHJ P,RECVRG	;MUST SET UP THE INPUT POINTERS
	PUSHJ P,TTPUTC	;PUT THE CHR IN THE BUFFER
	MOVEM T2,LDBTIP(U)
	AOS LDBBKI(U)
	MOVSI T1,L2LDEL	;SHOULD WE RESET THE \ FLAG?
	TDNN T1,LDBBYT(U)
	JRST RCVCH2	;NOT ON
	PUSH P,T2
	MOVEI T3,"\"
	PUSHJ P,ENTRUB
	MOVEI	T1, 1
	DPB	T1, LOPRUB	;SET SEND-RUBOUT
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	POP P,T2
RCVCH2:	MOVSI T1,L2LDEL!L2LCCS
	ANDCAM T1,LDBBYT(U)
	AOS (P)
	POPJ P,

RECVRG:	PUSHJ P,GETCHK
	MOVEM T2,LDBTIP(U)	;SET UP INPUT POINTERS
	MOVEM T2,LDBTIT(U)
	MOVEM T2,LDBECT(U)
	SETZM LDBBKI(U)
	SETZM LDBBKP(U)
	SETZM LDBTIC(U)
	SETZM LDBECC(U)
	SETZM LDBBKC(U)
	SETZM LDBBK2(U)
	POPJ P,
RWARN:	CAML	T4, TIHLTN	;OVER LARGE QUOTA?
	JRST	RWARN1		;YES: GO SEE HOW BADLY WE LOST
	MOVEI	T1, 1
	DPB	T1, LOPBPN	;NO: SET BACKPRESSURE-ON
	DPB	T1, LDBOPB(U)	;    AND NEED-OUTPUT
	JRST	RCVCH1

RWARN1:	LDB	T1, LOPBPN	;STILL WAITING TO SEND BACKPRESSURE?
	SKIPE	T1
	AOSA	LOSPDP		;YES: WE'RE TOO SLOW
	AOS	LOS620		;NO: BACKPRESSURE BROKEN
;	JRST	RECHLT		;SEND BELL AND DROP CHARACTERS

RECHLT:	AOS	TTYRHT		;RECORD CHARACTER LOST
	MOVEI	T1, LXRICL
	IORM	T1, LDBDCX(U)	;NOTE THE DIRECTION
	HRRZ	F, LDBDDB(U)
	JUMPE	F, RECHT1
	MOVEI	T1, IOBKTL	;SET IO.BKT
	IORM	T1, DEVIOS(F)
	LDB	T1, DDPTLC	;IF CHARACTERS-LOST ENABLED
	PUSHJ	P, TAKTRJ	;TAKE IT
RECHT1:	MOVEI	T1, 1
	DPB	T1, LOPSBL	;SET SEND-BELL
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,
;HERE ON A LOGIN CHARACTER (ONE OF FIRST 4 ON LINE)

LOGCHR:	SKIPG T4,LDBLOG(U)	;ARE WE REALLY LOGGING HIM IN?
	POPJ P,			;NO, RETURN FROM MOVCHR
	LSH T4,10
	IOR T4,T3
	MOVEM T4,LDBLOG(U)
	JUMPGE T4,CPOPJ		;MORE TO COME

	;WE'VE RECEIVED THE 32 BITS OF LOGIN DATA FROM
	;TYMNET -- NOW LOG THE LINE IN

	AOS	INTERM		;COUNT 1 MORE LINE LOGGED-IN
	LDB	T1, TRMBYP	;T1/ TERMINAL ID CODE
	MOVE	T1, TRMTAB(T1)	;T1/ IBM,FAST,FC1,FC2,WIDTH CODES
	TLNN	T1, 200000	;FAST TERMINAL?
	TDZA	T3, T3		;NO
	MOVSI	T3, LXL120	;YES
	MOVEM	T3, LDBDCX(U)	;SET LDBDCX (0 EXCEPT FOR FAST BIT)
	MOVSI	T3, LDLDEF!LDLLCT!LDLCOM
	SKIPG	T1		;IS IT A 2741?
	TLO	T3, LDLLCP	;YES: SET LOCAL-COPY FLAG
	SETZM	LDBBYT(U)	;MOST FIELDS ARE 0
	DPB	T1, LDPFC1	;SET FC1
	LSH	T1, -2
	DPB	T1, LDPFC2	;AND FC2
	LSH	T1, -2
	DPB	T1, LDPWID	;AND LINE WIDTH
	MOVSI	T1, LLLHDX
	TDNN	T1, LDBLOG(U)	;HALF-DUPLEX?
	TDZA	T1, T1		;NO
	MOVEI	T1, 1		;YES
	DPB	T1, LDPHDX	;SET THE CHARACTERISTIC
	SKIPN	T1		;IF IT'S HALF DUPLEX
	TLNE	T3, LDLLCP	;OR LOCAL-COPY (2741)
	TLZ	T3, LDLDEF	;DON'T SET DEFERRED ECHO
	MOVEM	T3, LDBDCH(U)
	SETZM	LDBTTP(U)	;[dws] clear terminal type
	HLL	U,T3		;Make sure this matches LH<LDBDCH>
				; or aux cir test on next page fails

	;CLEAR RECEIVED CHARACTERISTICS

	ZZN==0
	REPEAT TMCSIZ,<
	SETZM	LDBTMR+ZZN(U)
	ZZN==ZZN+1>
	;SET TO ECHO CR AS CRLF, NOT ECHO CTRL-I,
	;NOT ECHO LF AS CRLF

	MOVEI	T1, 0
	DPB	T1, LDSELF
	DPB	T1, LDSCIE
	MOVEI	T1, 1
	DPB	T1, LDSECR
	MOVE	T1, [LTSELF!LTSCIE!LTSECR]
	MOVEM	T1, LDBTMT(U)

	SETZM	LDBOUT(U)	;CLEAR ALL SEND BITS BUT...
	MOVEI	T1, 1
	DPB	T1, LOPSTC	;SET SEND-CHARACTERISTICS
	DPB	T1, LOPSTP	;AND SEND-PROBE
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	HRRZS	LDBDDB(U)	;CLEAR KJOB ETC. BITS
	MOVEI	T1, 200000
	TDNE	T1, STATES
	JRST	LOGCH1		;System is super-shut, zap always
	TLNE	U,LDLAUX	;Is this an AUX circuit ?
	SKIPL	STATES		;Yes, is system plain shut ?
	JRST	LOGCH2		;No, o.k. to log in
LOGCH1:	MOVEM T1,LDBLOG(U)	;Must be non-zero and non-negative
	SOS INTERM		;Leave INTERM alone in case
	JRST TTYZAP		; of Auto-Restart

LOGCH2:	PUSHJ	P, SETLMD	;Set the line mode
;;
;; Here (finally!) to assign a frame for this port and initiate
;; LOGIN.
;;
	SETZ	F,		;Indicate no DDB assigned yet
	PUSHJ	P,FRMASN##	;Assign a free frame number
	  JRST	NEWJER		;No free frames...
	PUSHJ	P,TTYATI	;Attach a TTY DDB to this LDB
	  JRST	NEWTER		;No free TTY DDB's
	MOVEI	T1, CMFCXN##	;Forced command index for LOGIN
	PJRST	TTFORC		;Force a LOGIN command on this port

NEWJER:	MOVEI	T1,[ASCIZ /
frame capacity exceeded
/]
	PUSHJ	P,CONMES##	;Type out error message
	PJRST	TTYZAP		;Kill off TTY

NEWTER:	MOVEI	T1,[ASCIZ /
port capacity exceeded
/]
	PUSHJ	P,CONMES##	;Type out error message
	PJRST	FRMKJF##	;Free up frame slot and kill off TTY

;TERMINAL ID CODE -> INITIAL TERMINAL CHARACTERISTICS TABLE

DEFINE TERCH (IBM,FAST,F1,F2,WIDTH)
	<BYTE (1) IBM,FAST (22) 0 (8) WIDTH (2) F2,F1>

TRMTAB:	TERCH (0,1,0,0,^D72)	;0  AUX CIR
	TERCH (0,0,0,0,^D72)	;1  A
	TERCH (0,0,3,2,^D120)	;2  C
	TERCH (0,0,1,1,^D72)	;3  E
	TERCH (0,0,3,0,^D120)	;4  G
	TERCH (0,0,1,1,^D72)	;5  B
	TERCH (0,0,3,2,^D120)	;6  F
	TERCH (0,0,1,1,^D72)	;7  J
	TERCH (0,0,1,1,^D72)	;8 N
	TERCH (1,0,2,1,^D80)	;9 CR
	TERCH (0,0,1,1,^D72)	;10 D
	TERCH (0,0,1,1,^D72)	;11 I
	TERCH (0,1,3,0,^D80)	;12 ASCII 1200 BAUD (GOUGING=1)
	TERCH (0,1,0,0,^D80)	;13 BURROUGHS 1200
	TERCH (0,1,0,0,^D72)	;14 AUX THROUGH GATEWAY
	TERCH (0,0,0,0,^D72)	;15 BAUDOT
	TERCH (0,1,3,0,^D80)	;16 ASCII 2400 (GOUGING=2)
	TERCH (0,1,0,0,^D80)	;17 3270
	TERCH (0,1,0,0,^D132)	;18 3270 PRINTER
	TERCH (0,1,3,0,^D80)	;19 ASCII 4800 (GOUGING=2)
	TERCH (0,1,3,0,^D80)	;20 ASCII 9600 (GOUGING=3)
	TERCH (0,1,3,0,^D80)	;21 multiplexed PVC
	TERCH (0,1,3,0,^D80)	;22 audio response
	TERCH (0,1,3,0,^D80)	;23 75 baud in 1200 out (VideoText)
	TERCH (0,1,3,0,^D80)	;24
	TERCH (0,1,3,0,^D80)	;25
	TERCH (0,1,3,0,^D80)	;26
	TERCH (0,1,3,0,^D80)	;27
	TERCH (0,1,3,0,^D80)	;28
	TERCH (0,1,3,0,^D80)	;29
	TERCH (0,1,3,0,^D80)	;30
	TERCH (0,1,3,0,^D80)	;31

TRMAUX==0	;CODE FOR AUX CIRCUIT
;HERE ON IMAGE MODE IN DEFERRED ECHO

IMGDEF:	TRO T3,400	;FLAG AS IMAGE CHARACTER
	MOVEI T1,IMGDIM
	DPB T1,LDPTIM	;RESET INPUT TIMER
	PUSHJ P,RCVCHR	;GET CHR INTO BUFFER
	 POPJ P,
	PUSHJ P,IMGCNT	;COUNT. IF T3 = IMAGE BREAK, T4 := TIWKC
DEFCHR:	CAIL T4,TIWKC	;IF IT'S A LINE'S WORTH,
DEFBRK:	PUSHJ P,LINTRP	;SET LINE TRAP BITS
DEFNBK:	AOS LDBECC(U)
	AOS (P)
	POPJ P,		;SKIP-RETURN TO START ECHOING

;HERE ON IMAGE MODE, REMOTE ECHO, BREAK ON ALL CHRS

IMGRMA:	TRO T3,400
	MOVEI T1,IMGDIM
	DPB T1,LDPTIM
	PUSHJ P,RCVCHR
	 POPJ P,
	PUSHJ P,IMGCHG	;CHARGE FOR AN IMAGE BREAK CHR
	PUSHJ P,USRWAK	;WAKE JOB IF ASLEEP
	LDB T1,LDPIMB
	CAME T1,T3	;IF IT'S THE IMAGE BREAK CHARACTER,
	CAIL T4,TIWKC	;OR IF THERE'S A LINEFULL,
	PUSHJ P,LINTRP	;  SET TRAP BITS
	JRST IMGRM1

;HERE ON IMAGE MODE, REMOTE ECHO, NOT BREAK ON ALL

IMGRMT:	TRO T3,400
	MOVEI T1,IMGDIM
	DPB T1,LDPTIM
	PUSHJ P,RCVCHR
	 POPJ P,
	PUSHJ P,IMGCNT	;COUNT. IF T3 = IMAGE BREAK CHAR, T4 := TIWKC
	CAIGE T4,TIWKC	;IF IMAGE BREAK OR A LINE'S WORTH,
	JRST IMGRM1
	PUSHJ P,USRWAK	;  WAKE UP JOB IF ASLEEP
	PUSHJ P,LINTRP	;  SET TRAP BITS
IMGRM1:	MOVEM T2,LDBECT(U)	;FIX ECHO POINTER
	AOS LDBTIC(U)
	POPJ P,
;NORMAL CHR DEF ECHO

IACT1:	PUSHJ P,RCVCHR
	 POPJ P,
	JRST DEFCHR

;BREAK CHR DEF ECHO

IACT2:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKC(U)	;RECODR BREAK CHR
IACT2A:	SETZM LDBBKI(U)		;RESET ^U POINTERS
	MOVEM T2,LDBBKP(U)
	JRST DEFBRK

;BREAK2 CHR DEF ECHO, NOT BREAK2 MODE

IACT3:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)
	ADDM T1,LDBBK2(U)	;COUNT BREAK2 AND IN ^U INFO
	JRST DEFCHR

;BREAK2 CHR DEF ECHO, BREAK2 MODE OR BREAK ON ALL AND BREAK2

IACT4:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBK2(U)	;RECORD BREAK2
	JRST IACT2A		;GO RESET ^U POINTER

;NORMAL CHR, RMT ECHO, BREAK ON ALL

IACT5:	PUSHJ P,RCVCHR
	 POPJ P,
IACT5A:	CAIL T4,TIWKC
	JRST IAC11B
	JRST IAC11C

;BREAK CHR, RMT ECHO, ANY BREAK MODE

IACT6:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBKC(U)	;COUNT BREAK
	JRST IAC10A
;BREAK2 CHR, RMT ECHO, BREAK ON ALL, NOT BREAK2

IACT7:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBK2(U)	;COUNT BREAK2
	MOVSI T1,1
	ADDM T1,LDBBKI(U)	;AND IN ^U INFO
	JRST IACT5A

;BREAK2 CHR, RMT ECHO, BREAK2 OR BREAK ALL AND BREAK2

IACT10:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBK2(U)
IAC10A:	SETZM LDBBKI(U)
	MOVEM T2,LDBBKP(U)
	JRST IAC11B

;BREAK CHR, RMT ECHO, BREAK OR BREAK2 MODE

IACT11:	PUSHJ P,RCVCHR
	 POPJ P,
IAC11A:	CAIGE T4,TIWKC	;COUTN BIG ENOUGH?
	JRST IAC11D	;NO
IAC11B:	PUSHJ P,LINTRP
IAC11C:	PUSHJ P,USRWAK
IAC11D:	MOVEM T2,LDBECT(U)
	AOS LDBTIC(U)

;NOW FALL INTO THE REMOTE ECHO CODE
;REMOTE ECHO CODE

	LDB T1,CHPECH	;GET THE ECHO TYPE FIELD
	XCT RMTECT(T1)
RMTCNT:	ADDI T4,1	;SEVERAL JUST LDB T4,LDPPOS
	TRNN T4,400	;TOO BIG?
	DPB T4,LDPPOS	;NO RESET
	TLNE U,LDLLCP!LDLPTP
	POPJ P,		;NEVER A FREE RETURN FOR THEM
	LDB T1,LDPWID
	TLNN U,LDLNFC	;IF NO FREE RETURN WANTED
	CAMG T4,T1	;OR NOT ENOUGH CHRS
	POPJ P,		;FINISHED
RMTECR:	MOVEI T1,0
	DPB T1,LDPPOS	;RESET POSITION TO 0
	MOVE T4,CRPTR
	PJRST RUBSTR	;PUT INTO "RUBOUT" STRING

RMTECT:	JRST RMTSPA	;SPECIAL ACTION FOR THESE
	LDB T4,LDPPOS	;COUNT
	POPJ P,		;DO NOT COUT THIS ONE
	POPJ P,		;"
	LDB T4,LDPPOS	;COUNT

RMTSPA:	LDB T1,LDPMOD	;GET THE MODE WE ARE IN
	LDB T2,CHPSPE	;ECHO SPECIAL ACTION TYPE
	XCT @RMTSPT(T1)

RMTSPT:	XCT RMTS10(T2)
	XCT RMTS94(T2)
	XCT RMTS94(T2)
	XCT RMTS10(T2)	;10 AND SUDS SAME

RMTS10:	JRST RMTEXC	;^C ECHO ^C RETURN
	JRST RMTCR	;RETURN
	JRST RMTEXU	;^U  ECHO ^U
	JRST RMTTAB	;TAB
	JRST RMTALT	;ALTMODE POSSIBLE $ ECHO
	JRST RMTVT	;V. TAB
	JRST RMTFF	;FF
	JRST RMTEXC	;^Z  ECHO ^Z RETURN
	JRST RMTAL1	;175-176 POSSIBLE ALTMODE
	JRST RMTBSP	;BACKSPACE
RMTS94:	POPJ P,		;^C
	JRST RMTCR	;RETURN
	POPJ P,		;^U
	JRST RMTTAB	;TAB
	POPJ P,		;ALTMODE
	JRST RMTVT	;V. TAB
	JRST RMTFF	;F.F.
	POPJ P,		;^Z
	JRST RMTPAT	;175-176 POSSIBLE ALTMODE
	JRST RMTBSP	;BACKSPACE
RMTPAT:	TLNE U,LDLLCT
	POPJ P,		;ALTMODE, IGNORE
RMTCN1:	LDB T4,LDPPOS
	JRST RMTCNT	;ASSUME PRINTING CHR

RMTAL1:	TLNN U,LDLLCT
	JRST RMTCN1	;ASSUME PRINTING CHR
RMTALT:	TLNE U,LDLPTP!LDLLCP	;NOTHING FOR THESE NUTS
	POPJ P,
	MOVSI T3,LXLDLR
	TDNE T3,LDBDCX(U) ;IF USER SUPPRESSING $ ECHO
	TLNE U,LDLCOM	;OR WE'RE AT COMMAND LEVEL
	SKIPA		;ECHO A $
	POPJ P,
	MOVEI T3,"$"
	JRST RMTRUB	;PUT IN RBS STRING

RMTCR:	MOVEI T1,0
	DPB T1,LDPPOS
	POPJ P,		;RETURN, JUST SET POSITION TO 0

RMTEXC:	TLNE U,LDLLCP!LDLPTP	;NOTHING FOR THESE NUTS
	POPJ P,		;NOTHING WE CN DO
	PUSHJ P,RMTEU1	;ECHO THE ^X
	JRST RMTECR	;AND THE RETURN
RMTEXU:	TLNE U,LDLLCP!LDLPTP	;NOTHING FOR THESE NUTS
	POPJ P,
RMTEU1:	MOVEI T3,"^"
	PUSHJ P,ENTRUB
	LDB T3,LDBECT(U)	;GET BACH CHR
	TRO T3,100
RMTRUB:	PUSHJ P,ENTRUB
	MOVEI	T1, 1
	DPB	T1, LOPRUB	;SET SEND-RUBOUT-CHARACTERS
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,

RMTVT:	MOVSI	T4, L2LNTB
	TDNN	T4, LDBBYT(U)		; NO VT ECHO??
	TLNE	U, LDLLCP!LDLPTP!LDLFRM	; DONE BY TERMINAL?
	POPJ	P,			; THEN NO FILLERS
	MOVE T4,VTFLP
	PJRST RUBSTR	;GO

RMTFF:	MOVSI	T4, L2LNTB
	TDNN	T4, LDBBYT(U)		; NO FF ECHO??
	TLNE	U, LDLLCP!LDLPTP!LDLFRM	; DONE BY TERMINAL?
	POPJ	P,			; THEN NO FILLERS
	MOVE T4,FFFLP
	PJRST RUBSTR

RMTTAB:	MOVSI T4,L2LNTB	;SEE IF WE SHOULD JUST IGNORE
	TDNE T4,LDBBYT(U)
	TLNE U,LDLCOM
	SKIPA		;TABS AS USUAL IN COMMAND MODE
	POPJ P,		;YES, DO NOTHING
	LDB T4,LDPPOS
	TLNE U,LDLLCP!LDLTAB!LDLPTP
	JRST RMTTB1		;MUST ADJUST POSITION BUT NO SPACES
	ANDI T4,7
	MOVE T4,TABPTR(T4)
	PJRST RUBSTR		;OUT OF SPACES ADJUSTS POS

RMTTB1:	MOVE T1,T4		;SAVE SIZE
	TRO T4,7
	ADDI T4,1
	TRNN T4,400
	DPB T4,LDPPOS		;PUT BACK IF NOT OUT OF RANGE
	POPJ P,		;FINISHED

RMTBSP:	PJRST SPOBSP	;UPDATE CHAR COLUMN COUNTER
;SOME ROUTINES TO HANDLE PUTTING THINGS IN THE RUBOUT STRING

ENTRUB:	SKIPN TTFREE	;GIVE UP IF NO FREE BUFFERLETS
	POPJ P,
	SKIPN T2,LDBRBI(U)
	JRST STRUB	;MUST SET THINGS UP
STRUB1:	PUSHJ P,TTPUTC
	MOVEM T2,LDBRBI(U)
	AOS LDBRBC(U)
	POPJ P,

STRUB:	PUSHJ P,GETCHK
	MOVEM T2,LDBRBI(U)
	MOVEM T2,LDBRBO(U)
	SETZM LDBRBC(U)
	JRST STRUB1

;PUT IN A WHOLE STRING, BYTE POINTER IN T4

RUBSTR:	ILDB T3,T4
	JUMPE	T3, [		;IF WE'RE DONE WITH THE STRING,
		MOVEI	T1, 1
		DPB	T1, LOPRUB	;SET SEND-RUBOUT-CHARACTERS
		DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
		POPJ	P,
	]
	PUSHJ P,ENTRUB
	JRST RUBSTR
;BREAK2 CHR, RMT ECHO, BREAK MODE

IACT12:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)	;COUNT BREAK2
	AOS LDBBK2(U)
	JRST IAC11A

;NORMAL CHARACTER, COMMAND MODE, REMOTE ECHO

IACT13:	PUSHJ P,RCVCHR
	 POPJ P,
	JRST IAC16B

;BREAK CHR, COMMAND MODE, REMOTE ECHO

IACT14:	PUSHJ P,RCVCHR
	 POPJ P,
	AOS LDBBKC(U)
	MOVEM T2,LDBBKP(U)
	SETZM LDBBKI(U)	;RESET ^U POINTER
	JRST IAC16C

;BREAK2 CHR, COMMAND MODE, REMOTE ECHO, NOT BREAK2 MODE

IACT15:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)
	AOS LDBBK2(U)
IAC16B:	CAIL T4,TIWKC
IAC16C:	PUSHJ P,CMDWAK
	JRST IAC11D
;BREAK2 CHR, COMMAND MODE, DEF ECHO, NOT BREAK2 MODE

IACT17:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKI(U)
	ADDM T1,LDBBK2(U)	;COUNT BREAK2
	JRST DEFNBK

;BREAK2 CHR, COMMAND MODE, DEF ECHO, BREAK2 MODE


;NORMAL CHR, COMMAND MODE, DEF ECHO

IACT21:	PUSHJ P,RCVCHR
	 POPJ P,
	JRST DEFNBK

;BREAK CHR, COMMAND MODE, DEF ECHO

IACT22:	PUSHJ P,RCVCHR
	 POPJ P,
	MOVSI T1,1
	ADDM T1,LDBBKC(U)
	SETZM LDBBKI(U)
	MOVEM T2,LDBBKP(U)
	JRST DEFNBK
;SPECIAL ACTION CHRACTER, ALMOST ANY MODE

IACT0:	LDB T1,LDPMOD
	LDB T2,CHPSPI	;GET SPECIAL ACTION CODE
	XCT @INPACT(T1)

INPACT:	XCT INPA10(T2)
	XCT INPA94(T2)
	XCT INPA94(T2)
	XCT INPA10(T2)

INPA10:	POPJ P,		;NULL, IGNORE
	JRST INPESC	;ESCAPE (^C)
	JRST INPRET	;RETURN
	JRST INPGOB	;OUTPUT SUPPRESS (^O)
	JRST INPBRK	;PUT IN AS A BREAK CHR (^Q)
	JRST INPDLN	;DELETE LINE (^U)
	JRST INPTAB	;TAB (DECIDE IF BREAK OR BREAK2)
	JRST INPBRK	;ALTMODE
	JRST INPBRK	;JUST A BREAK CHR ^^
	JRST INPBRK	;^_
	JRST INPRUB	;RUBOUT
	JRST INPBRK	;^A
	JRST INPBRK	;POSSIBLE ALTMODE
	JRST INPBK2	;_
	JRST INPBRK	;^\
	JRST INPBSP	;BACKSPACE
	JRST INPSTA	;^T

INPA94:	POPJ P,		;NULL, IGNORE
	JRST INPBRK	;^C
	JRST INPRET	;RETURN
	JRST INPBRK	;^O, BREAK CHR
	JRST INPDLN	;DELETE LINE (^Q)
	JRST INPBRK	;^U
	JRST INPTAB	;TAB
	JRST INPESC	;ALTMODE (ESCAPE CHR)
	JRST INPCLD	;CONVERT TO ^D (^^)
	JRST INPESC	;^_
	POPJ P,		;RUBOUT, IGNORE
	JRST INPRB1	;^A, DELETE CHR
	JRST INPAL1	;POSSIBLE ALTMODE
	JRST INPBK2	;_
	JRST INPGOB	;^\
	JRST INPBS1	;BACKSPACE
	JRST INPBRK	;^T
;JUST SET AS A BREAK CHARACTER (MODE 2) AND GO

INPBRK:	MOVEI T2,2
	JRST MOVCH1	;P2 (LINE MODE) STILL SETUP

;DECIDE IF TAB IS A BREAK OR BREAK2 CHARACTER

INPTAB:	MOVEI T2,3	;NORMALLY BREAK2
	MOVSI T1,L2LTBK
	TDNE T1,LDBBYT(U)
	MOVEI T2,2	;BIT IS ON, AS A BREAK CHARACTER
	JRST MOVCH1

;DECIDE IF BACKSPACE IS A BREAK OR BREAK2 CHARACTER

INPBSP:	MOVEI T2,INPRUB
	SKIPA
INPBS1:	MOVEI T2,INPRB1
	MOVE T1,LDBDCX(U)
	TLNE T1,LXLBSD	;DELETE ON BACKSPACE?
	  JRST	(T2)	; YES
	MOVEI T2,2	;NORMALLY BREAK
	MOVSI T1,L2LBBP
	TDNE T1,LDBBYT(U)
	MOVEI T2,3	;BIT IS ON, AS A BREAK2 CHARACTER
	JRST MOVCH1

;CONVERT ^A INTO _ FOR TYMEX2 MDDE

INPTCA:	MOVEI T3,"_"
	JRST INPBK2

;RETURN HANDLER

INPRET:	MOVEI T2,1	;GET SET TO TREAT AS TYPE 1(NORMAL) CHR
	TLNE U,LDLPTP	;IF IN PAPER TAPE MODE
	JRST MOVCH1	;JUST PUT IN THE CHR
	PUSHJ P,MOVCH1	;ELSE PUT IT IN
	 JFCL		;IGNORE SKIP-NON SKIP
	MOVEI T3,12
	JRST MOVCHR	;AND THEN PUT IN A LINE FEED

;HANDLE ^^ IN 940 MODE (CONVERT TO ^D)

INPCLD:	MOVEI T3,4
	JRST MOVCH2

INPBK2:	MOVEI T2,3
	JRST MOVCH1
;POSSIBLE ALTMODE (175-176) IN 940 MODE

INPAL1:	TLNN U,LDLLCT
	JRST INPBRK	;IN LOWER CASE MODE, JUST CALL BREAK
	JRST INPESC

;^O IN PDP-10 MDDE

INPGOB:	MOVSI T1,LDLOSU
	XORM T1,LDBDCH(U)	;CHANGE FLAG
	PUSHJ P,TSETBO		;CLEAR OUTPUT BUFFER
	LDB T4,LDPMOD
	MOVE T4,@IGOBEC(T4)
INPOTP:	TLNE U,LDLLCP
	POPJ P,			;BUT NEVER ANYTHING TO 2741
	MOVSI T1,L2LDEL
	TDNN T1,LDBBYT(U)	;ALREADY IN \'S
	IBP T4			;NO, SKIP \ IN OUTPUT STRING
	ANDCAM T1,LDBBYT(U)	;NOT THERE NOW IN ANY CASE
	PJRST RUBSTR

;^U IN PDP-10 OR ^Q IN 940

INPDLN:	PUSHJ P,FULLCQ		;COMMAND OR FULL CHARACTER SET?
	 JRST INPBRK		;YES, BREAK CHARACTER
	PUSHJ P,RIDLIN		;THIS DOES ALL THE WORK
	 POPJ P,		;NOTHING TO ECHO
	LDB T1,LDPMOD		;GET MODE WE ARE IN
	MOVE T4,@IDLNEC(T1)	;AND GET APPROPRIATE ECHO STRING
	PJRST INPOTP

IDLNEC:	CUPTR
	UPARPT
	UPARPT
	CUPTR

IGOBEC:	COPTR
	FLLBSC
	FLLBSC
	COPTR
;GET RID OF A LINE OF TEXT. ADJUST ALL POINTERS

RIDLIN:	SKIPN T1,LDBBKP(U)	;IS THERE A ^U POINTER
	PJRST RIDLN3		;NO, DELETE ALL FROM BUFFER
	MOVEM T1,LDBTIP(U)
	HRRZ T2,LDBBKI(U)	;NUMBER OF CHRS SINCE ^U POINTER
	MOVNS T2
	ADD T2,LDBECC(U)
	JUMPGE T2,RIDLN1	;NONE ECHOED
	ADDM T2,LDBTIC(U)	;REMOVE SOME FROM INPUT
	MOVEI T2,0
	MOVEM T1,LDBECT(U)	;RESET ECHO POINTER
	AOS (P)			;SKIP RETURN FOR ECHO ^U
RIDLN1:	MOVEM T2,LDBECC(U)
	HLRZ T2,LDBBKI(U)	;GET NUMBER OF BREAK2 CHRS
	SETZM LDBBKI(U)		;AND GET RID OF OLD COUNTS
	MOVNS T2
	HRLZS T2
	ADD T2,LDBBK2(U)	;FIX NUMBER NOT ECHOED
	JUMPGE T2,RIDLN2	;ALL IN NOT ECHOED
	HLROS T2
	ADD T2,LDBBK2(U)	;FIX NUMBER ECHOED
	HRRZM T2,LDBBK2(U)
	POPJ P,

RIDLN2:	MOVEM T2,LDBBK2(U)
	POPJ P,

RIDLN3:	SKIPE LDBECC(U)		;ALSO ECHO IF NOT CHRS AT ALL
	SKIPE LDBTIC(U)		;ANY CHARACTERS ECHOED?
	AOS (P)			;SET SKIP RETURN
	PJRST TSETBI
;RUBOUT FROM PDP-10 MODE. 940 ^A JUST DOES NOT CHECK XON

INPRUB:	TLNE U,LDLPTP
	POPJ P,			;IGNORE RUBOUTS IN XON MODE
INPRB1:	PUSHJ P,FULLCQ
	 JRST INPBRK		;JUST CALL IT A BREAK CHR
	PUSHJ P,INPRBC		;COMMON RUBOUT ROUTINE
	 JRST INPRB2	;NO CHRS, GIVE RETURN
	 POPJ P,		;NOT ECHOED
	MOVEI T3,"\"
	MOVE	T4, LDBBYT(U)
	TLNN	T4, L2LBSP	;BACKSPACE FOR CHAR DELETE?
	JRST	INPRB7		;NO
	MOVE	T1,INPCH
	CAIE	T1, 10		;IS IT BACKSPACE?
	CAIN	T1, 210
	JRST	INPRB9		;YES
	MOVE	T4, LDBDCX(U)
	TLNN	T4, LXLERA	;<BS><SP><BS> OR JUST <BS>?
	JRST	INPRB6
	MOVEI	T3, 10		;<BS>
	PUSHJ	P, ENTRUB
	MOVEI	T3, 40		;<SP>
	PUSHJ	P, ENTRUB
INPRB6:	MOVEI	T3, 10		;<BS>
	JRST	INPRB8
INPRB7:	TLON T4,L2LDEL
	PUSHJ P,ENTRUB		;NO, ENTER
	MOVEM T4,LDBBYT(U)	;AND MAKE SURE WE REMEMBER IT
	MOVE T3,INPCH
	ANDI	T3, 177		;STRIP OFF PARITY BIT
	CAIE	T3, 10		;IS IT BACKSPACE?
	JRST	INPRB8		;NO
INPRB9:	MOVEI	T3,40		;YES, SUBSTITUTE <SP> FOR <BS>
	LDB	T1, LDPECH
	SKIPE	T1		;PRINT NOTHING IF NO REM BS ECHO
INPRB8:	PUSHJ P,ENTRUB
	MOVEI	T1, 1
	DPB	T1, LOPRUB		;SET SEND-RUBOUT-CHARACTERS
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,

;HERE FROM _ IN TYMEX2 MODE

INPRT2:	PUSHJ P,FULLCQ
	 JRST INPBK2	;JUST TREAT AS A CHR
	PUSHJ P,INPRBC
	 POPJ P,
	 POPJ P,
	POPJ P,		;NEVER ANY ECHO
INPRBC:	HRRZ T1,LDBBKI(U)
	JUMPE T1,CPOPJ		;JUST GIVE RETURN
	AOS (P)
	LDB T3,LDBTIP(U)	;GET LAST CHARACTER INPUT
	MOVEM T3,INPCH	;AND SAVE
	SOS LDBBKI(U)
	SOS T2,LDBTIP(U)	;NOW REALLY BACK UP
	REPEAT 2,<IBP T2>	;NOW GET READY TO ADVANCE ON PREV.
	PUSHJ P,TTGETC
	 JFCL			;DO NOT CARE IF PASS OVER LINK
	MOVEM T2,LDBTIP(U)	;THAT WAS JUST IN CASE WE BACKED OVER LINK
	SOSL LDBECC(U)
	JRST [MOVSI T4,-1	;WAITING TO BE ECHOED, FORGET IT
		JRST INPRB4]
	SETZM LDBECC(U)
	SOS LDBTIC(U)
	MOVEM T2,LDBECT(U)	;RESET ECHO POINTER TO INPUT
	TLNN U,LDLCOM	;IF AT COMMAND IGNORE ECHO
	TLNN U,LDLNEC	;IF NOT ECHOING, NO ECHO
	TLNE U,LDLLCP	;BUT NEVER ECHO LOCAL COPY
	JRST INPRB3		;DUMP CHR
	AOS (P)
INPRB3:	MOVNI T4,1		;T4 WILL HAVE THING TO ADD TO BK2
INPRB4:	MOVE T3,INPCH
	TRZ T3,200
	TRNE T3,400
	POPJ P,		;IMAGE MODE CHRS NEVER COUNT
	MOVE P3,CHRTAB(T3)
	LDB T1,CHPINP
	XCT INPRTB(T1)		;WANT ONLY BREAK2 CHRS
INPRB5:	MOVSI T1,-1		;WILL HAV SOS'ED CORRECT HALF OF LDBBK2
	ADDM T1,LDBBKI(U)
	POPJ P,

INPRTB:	JRST INPRAC	;MUST WORRY ABOUT TAB
	POPJ P,		;NORMAL CHR
	POPJ P,		;BREAK CHR
	ADDM T4,LDBBK2(U) ;BREAK 2
INPRAC:	LDB T1,CHPSPI
	XCT INPRTA(T1)
	TDNE T1,LDBBYT(U)	;HERE ONLY FOR TAB WITH T1=L2LTBK
	POPJ P,			;TREAT AS BREAK
INPRA1:	ADDM T4,LDBBK2(U)
	JRST INPRB5

INPRTA:	REPEAT 6,<POPJ P,>
	MOVSI T1,L2LTBK
	REPEAT 6,<POPJ P,>
	MOVEI T1,0	;_ ALWAYS BREAK2
	POPJ P,		;^\
	JRST	[MOVSI T1,L2LBBP
		 TDNN T1,LDBBYT(U)	;TEST BACKSPACE BREAK FLAG
		 POPJ P,		;TREAT AS BREAK
		 JRST INPRA1]		;TREAT AS BREAK2

INPRB2:	MOVE T4,FLLBSC
	JRST INPOTP

;;
;; Here on ^T in PDP-10 mode, to see if it should be interpreted as
;; a .USESTAT command.
;;
INPSTA:	MOVSI	T1,LXLRTC
	TDNN	T1,LDBDCX(U)	;Special ^T mode set?
	  JRST	INPBRK		;No, just treat as break
	MOVEI	T1,CMFSTA##	;Forced command code for .USESTAT
	PJRST	TTFORC
;ESCAPE CHARACTER 940 IS ^_ OR POSSIBLY ALTMODE, PDP-10 IS ^C

INPESC:	PUSHJ P,ESCTRP		;CHECK ESCAPE TRAP
				;DOES DOUBLE RETURN
				;(OUT OF INPESC) IF TRAP TAKEN
	SKIPE LDBBKI(U)
	PUSHJ P,RIDLIN		;REMOVE U IF ANY
	 JFCL			;NEVER ECHO ANYTHING
	MOVSI T1,L2LCCS
	TDNN T1,LDBBYT(U)	;SECOND?
	JRST INPES1		;NO, JUST STORE IT
	PUSHJ P,CNCCHK		;SEE IF CMD LEVEL, SLAVED, ETC.
	 JRST INPES0		;JUST STORE IT
	PUSHJ P,TSETBI		;CLEAR INPUT
	PUSHJ P,TSETBO		;AND OUTPUT BUFFERS
	MOVSI T1,LDLOSU	;SUPRESS OUTPUT (UNTIL WE HAVE HALTED)
	IORM T1,LDBDCH(U)
	HLL U,LDBDCH(U)	;MAKE SURE U KNOWS ABOUT IT
	LDB T1,LDPMOD
	MOVE T4,@INPEST(T1)	;GET CORRECT THING TO PRINT
	PJRST INPOTP

INPEST:	CCPTR
	FLLBSC
	FLLBSC
	CCPTR

INPES0:	TLNE U,LDLCOM	;IF COMMAND MODE
	PUSHJ P,TSETBO	;CLEAR OUTPUT BUFFER
INPES1:	PUSHJ P,INPBRK	;PUT IT IN AS A BREAK CHR
	 SKIPA
	AOS (P)		;TRANSFER SKIP RETURN TO US
	MOVSI T1,L2LCCS
	IORM T1,LDBBYT(U)	;SET FLAG
	POPJ P,
SUBTTL MODE CONVERSION TABLE

	DEFINE LMOD (ECH,INP)
	<BYTE (29)0(3)ECH(4)INP>

MDFLMD:	LMOD 2,11
	LMOD 2,4
	LMOD 2,3
	LMOD 2,1
	LMOD 3,10
	LMOD 3,5
	LMOD 3,3
	LMOD 3,1
	LMOD 1,6
	LMOD 1,4
	LMOD 1,2
	LMOD 1,1
	LMOD 1,7
	LMOD 1,5
	LMOD 1,2
	LMOD 1,1
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
	LMOD 0,12
	LMOD 0,13
SUBTTL OUTPUT DISPATCHER

;HERE AT CH7 TO SCAN LINTAB FOR PORTS NEEDING OUTPUT, SCAN
;LDBOUT FOR THOSE PORTS, AND DISPATCH TO THE APPROPRIATE
;OUTPUT ROUTINES

SCNOUT:	PUSHJ	P, SETOUT	;PREPARE FOR TYMNET OUTPUT
	  SKIPLE MULCNT+1	;IF NO ROOM FOR TYMNET OR PTY OUTPUT,
	JRST	.+2
	JRST	FINOUT		;  DO NOTHING THIS CYCLE

    ;FIND THE NEXT PORT (IN A ROUND-ROBIN FASHION) THAT WANTS
    ;TO DO OUTPUT

	SKIPL	T1, LINPTR	;IF NO ROUND-ROBIN PTR EXISTS,
	MOVSI	T1, NMXFLG	;  SET TO START AT PORT 0
SCOLP1:	MOVEM	T1, LINPTR
	SKIPN	U, LINFLG(T1)	;IF NO NEED-OUTPUT BITS IN THIS WORD,
	JRST	NOLIN2		;  GO ON TO THE NEXT ONE
	MOVE	T4, BITNTB(T1)	;T4/ PORT# CORRESPONDING TO BIT 0
SCOLP:	JFFO	U, .+2		;T1/ BIT# OF FIRST. IF NONE,
	JRST	NOLIN2		;  GO ON TO THE NEXT WORD
	LSH	U, 1(T1)	;GET RID OF THE BIT WE JUST FOUND
	MOVEM	U, LINFSV	;SAVE THE REST OF THE WORD
	ADD	T1, T4		;T1/ PORT# FOR THE BIT WE JUST FOUND
	MOVEM	T1, LINPNM	;SAVE THAT TOO
	MOVE	U, LINTAB(T1)	;U/ LDB ADDR
	HLL	U, LDBDCH(U)	;U/ DCH BITS,,LDB ADDR
	TLNN	U, LDLPTY	;P(SEUDO)TY OR R(EAL)TY?
	JRST	SCORTY
   ;PREPARE TO DO OUTPUT ON A PSEUDO-PORT

SCOPTY:	MOVE	T1, TTFREN
	CAILE	T1, TIRSVD	;IF NO SYSTEM BUFFERLETS
	SKIPG	MULCNT+1	;OR PTY "FLOW" QUOTA EXCEEDED,
	JRST	NOLIN		;  MAYBE THE NEXT PORT'S A REAL TTY
	PUSHJ	P, SETPTL	;T1/ MAX CHARS TO XFER
	MOVEI	W, 1		;W = 1 => PTY
	JRST	SCOTTY

    ;PREPARE TO DO OUTPUT ON A REAL PORT

SCORTY:	SKIPG	MULCNT+0	;IF NO ROOM FOR REAL TTY OUTPUT,
	JRST	NOLIN		;  MAYBE THE NEXT PORT'S A PTY
	MOVEI	T1, %CHRMX	;T1/ MAX CHRS TO XMIT
	SETZ	W,		;W = 0 => REAL TTY
	;JRST	SCOTTY

    ;LOOK FOR THE HIGHEST-PRIORITY OUTPUT REQUEST ON THE LINE

SCOTTY:	MOVEM	T1, CHQTA
	MOVEM	T1, CHCNT
	MOVE	T1, LDBOUT(U)	;T1/ OUTPUT BITS
	JFFO	T1, GOLIN
	JRST	MORLN2		;NOTHING (THAT'S FUNNY...)
GOLIN:	JUMPGE	U, GOLIN1	;IF PORT'S BACKPRESSURED
	CAIG	T2,BPOKBN	; AND OUTPUT TYPE IS HIGH ENOUGH PRI
	JRST	GOLIN1		; THEN OUTPUT IS OK
        CAILE   T2,LAPBIT       ;BEYOND LAST LEGAL PRIORITY BIT?
         JRST   MORLN2          ;YES.  ASSUME NO OUTPUT
	LDB	T1,LOPECO
	JUMPN	T1,GOLIN2	;ATTEMPT ECHO EVEN IF BACKPRESSURE ON
Golin3:	SETZ	T1,
	DPB	T1, LDBOPB(U)	;  CLEAR NEED-OUTPUT
	JRST	FULLIN		;  AND SAY WE'RE THROUGH
GOLIN2:	MOVEI	T2,NUMECO	;ECHO BIT NUMBER
GOLIN1:	MOVEM	T2, SVOJFF	;SAVE THE BIT NUMBER
	JUMPE	W, @OUTTRN(T2)	;REAL TTY DISPATCH
	JRST	@PTYTRN(T2)	;PSEUDO-TTY DISPATCH
    ;OUTPUT SUCCESSFUL, ROOM FOR MORE

MORLIN:	MOVN	T2, SVOJFF	;T2/ -(BIT# WE DISPATCHED FOR)
	MOVSI	T1, (1B0)
	LSH	T1, (T2)	;T1/ BIT WE DISPATCHED FOR
	ANDCAB	T1, LDBOUT(U)	;CLEAR IT AND PICK UP THE REST
	JFFO	T1, GOLIN	;IF THERE'S MORE TO DO, DO IT

    ;FINISHED WITH THE LAST OUTPUT REQUEST FOR THIS PORT

MORLN2:	DPB	T1, LDBOPB(U)	;CLEAR NEED-OUTPUT BIT
	PUSHJ	P, XMTWAK	;WAKE UP THE JOB FOR GOOD MEASURE
	JRST	FULLIN

    ;OUTPUT SUCCESSFUL, NO ROOM FOR MORE

FINLIN:	MOVN	T2, SVOJFF
	MOVSI	T1, (1B0)
	LSH	T1, (T2)
	ANDCAB	T1, LDBOUT(U)
	JUMPE	T1, MORLN2
	JRST	FULLIN

    ;OUTPUT NOT DONE BECAUSE WE'RE WAITING FOR SOMETHING
    ;(E.G., CAN'T OUTPUT ECHO CHARACTERS IF THE PORT'S NOT
    ;IN INPUT WAIT). CODE FOR "SOMETHING"S MUST TURN
    ;THE NEED-OUTPUT BIT BACK ON

WATLIN:	MOVEI	T1, 0
	DPB	T1, LDBOPB(U)
	PUSHJ	P, XMTWAK
	JRST	FULLIN
    ;OUTPUT NOT DONE AND/OR FINISHED WITH THIS PORT

FULLIN:	HRRZ	F, LDBDDB(U)
	JUMPE	F, FULLN2
	LDB	T1, PJOBN
	MOVE	T4, CHQTA
	SUB	T4, CHCNT
	ADDB	T4, JBTCOT(T1)
	MOVEM	T4, JBTCOT
FULLN2:	JUMPN	W, FULLN3

    ;DONE WITH A REAL TTY

	PUSHJ	P, CLSCHR	;FINISH CHARACTER-OUTPUT MESSAGE
	  SKIPLE MULCNT+1	;IF NO TYMNET OR PTY ROOM,
	JRST	NOLIN
	JRST	FINOUT		;  QUIT

    ;DONE WITH A PTY

FULLN3:	CAIE	W, 1
	  STOPCD
	PUSHJ	P, CLSPTL	;FINISH CHARACTER OUTPUT
	SKIPG	MULCNT+0	;IF THERE'S ROOM FOR REAL PORTS
	SKIPLE	MULCNT+1	;OR PTYS,
	JRST	NOLIN		;  GO ON
	JRST	FINOUT		;ELSE QUIT

    ;GO ON TO THE NEXT PORT

NOLIN:	AOS	T4, LINPNM
	MOVE	U, LINFSV
	JUMPN	U, SCOLP	;TRY TO FIND ANOTHER IN GROUP
NOLIN2:	MOVE	T1, LINPTR
	AOBJN	T1, SCOLP1	;TRY ANOTHER GROUP
	SETZM	LINPTR		;(START FROM BEGINNING NEXT TIME)
FINOUT:	AOSG	FSCN	;(IF IT WAS 0 (NOW 1), THERE WAS NO I/O)
	JRST	SCNIN	;IF I/O DONE THIS CYCLE, GO CHECK INPUT AGAIN
	SETZM	FSCN	;OTHERWISE, CLEAR FSCN
	POPJ	P,	;AND RETURN (FROM SCNINT) TO THE TICK LOGIC
;OUTPUT DISPATCH TABLES

DEFINE ZZZ(NAME), <GO'NAME>
OUTTRN:	OUTBIT

DEFINE ZZZ(NAME), <PG'NAME>
PTYTRN:	OUTBIT
SUBTTL PTY "OUTPUT" ROUTINES

PTBSIZ==^D120
ARRAY PTYBUF[<PTBSIZ+4>/5]
INTEGER PBDISC
INTEGER DIDPBI

;SETPTL -- CALLED WITH U/ PTY LDB TO SET UP FOR OUTPUT THENCE
;	IF THE OTHER END IS IN BLOCK INPUT WAIT, IT SETS
;	CHRWRP+1 TO POINT TO THE NEXT FREE BYTE IN THE
;	BLOCK INPUT BUFFER
;	OTHERWISE, IT SETS CHRWRP+1 TO POINT TO THE
;	PTY BUFFER
;	SETS T1/ MAX # CHARS TO MOVE

SETPTL:	SETZM	PBDISC		;CHARIO DISCOUNT FOR BLOCK OUTPUT
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNE	T1, LDBDCH(U)	;IF BLOCK INPUT IS IN PROGRESS,
	JRST	SETPTB		;  DO THINGS DIFFERENTLY

    ;HERE WHEN OTHER END IS NOT IN BLOCK INPUT WAIT

	SETZM	DIDPBI
	MOVE	T1, [POINT 8, PTYBUF]
	MOVEM	T1, CHRWRP+1
	MOVE	T1, TIWRNN	;T1/ # CHARS ALLOWED BEFORE BACKPRESSURE
	SUB	T1, LDBTIC(U)
	SUB	T1, LDBECC(U)	;T1/ # MORE CHARS THAT WILL FIT
	SKIPGE	T1		;IF WE'LL BE BACKPRESSURED,
	MOVEI	T1, %CHRMX	;  T1/ NORMAL (REAL TTY) LIMIT
	CAILE	T1, PTBSIZ
	MOVEI	T1, PTBSIZ	;MUSTN'T BE > THAN THE PTY BUFFER SIZE
	POP	P, U
	POPJ	P,

    ;HERE WHEN THE OTHER END IS IN BLOCK INPUT WAIT

SETPTB:	SETOM	DIDPBI
	HRRZ	T1, LDBBIO(U)	;T1/ BLOCK INPUT BUFFER ADDR
	SKIPE	T1		;IF NONE,
	SKIPL	BIOCHR(T1)	;OR IF NO INPUT PENDING,
	  STOPCD		;  DIE
	MOVE	T2, BIOPBP(T1)	;T2/ BLOCK IDPB POINTER
	MOVEM	T2, CHRWRP+1
	MOVE	T1, BIOPBC(T1)	;T1/ # BYTES LEFT THERE
	POP	P, U
	POPJ	P,
;CLSPTL -- CALLED WITH U/ PTY LDB TO FINISH UP OUTPUT THITHER
;	IF OTHER END WAS DOING BLOCK INPUT, THE CHARACTERS ARE
;	ALREADY MOVED -- WE JUST NEED TO UPDATE THE BUFFER
;	POINTER&COUNT AND SEE IF WE'VE FILLED IT YET
;	OTHERWISE WE NEED TO MOVE THE CHARACTERS TO THE
;	OTHER END

CLSPTL:	MOVE	T1, PBDISC
	ADDM	T1, CHCNT	;ADJUST CHARIO COUNT FOR BLOCK OUTPUT
	SKIPE	DIDPBI		;IF OTHER END WAS DOING BLOCK INPUT,
	JRST	CLSPTB		;  HANDLE THINGS DIFFERENTLY

	MOVE	T1, CHRWRP+1	;T1/ BYTE POINTER
	CAMN	T1, [POINT 8, PTYBUF]
	POPJ	P,		;(NOTHING TO OUTPUT)

	PUSH	P, U
	PUSH	P, [0]
	PUSH	P, T1
	PUSH	P, [POINT 8, PTYBUF]

    ;-2(P) = 0 IF REM. ECHO, -1 IF DEFERRED
    ;-1(P) IS ORIGINAL ENDING BYTE POINTER
    ;  (P) IS SOURCE BYTE POINTER

	PUSHJ	P, PTYBUD	;U/ BUDDY'S LDB
CLSLP1:	UUILDB	T3, (P)		;T3/ CHAR
	PUSHJ	P, MOVCHR	;DEPOSIT IT
	  JRST	.+2
	SETOM	-2(P)		;(ENTERED DEFERRED ECHO MODE)
	MOVE	T1, (P)
	CAME	T1, -1(P)
	JRST	CLSLP1

	SKIPN	T1, -2(P)	;IF IT ENTERED DEFERRED ECHO MODE,
	JRST	CLSLP2
	DPB	T1, LOPECO	;  SET NEED-ECHO
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
CLSLP2:	SUB	P, [3,,3]	;DISCARD THE THREE LOCALS
	POP	P, U		;RESTORE U
	POPJ	P,
    ;HERE WHEN THE OTHER END WAS DOING BLOCK INPUT

CLSPTB:	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IF BLKI NO LONGER IN PROGRESS,
	JRST	UPOPJ		;  NOTHING TO DO
	HRRZ	T1, LDBBIO(U)	;T1/ BLOCK INPUT BUFFER ADDRESS
	SKIPN	T1
	  STOPCD
	MOVE	T3, CHRWRP+1
	MOVEM	T3, BIOPBP(T1)	;UPDATE BYTE POINTER
	MOVE	T3, CHCNT
	SUB	T3, CHQTA	;T3/ - # OF CHARACTERS MOVED
	ADDB	T3, BIOPBC(T1)	;UPDATE BYTES-LEFT COUNT
	JUMPE	T3, CLSPBF	;(BUFFER FILLED)

    ;HERE WHEN WE HAVEN'T FINISHED FILLING THE BUFFER YET

	SKIPG	T3
	  STOPCD		;(WENT TOO FAR)
	MOVEI	T1, %PBTIM
	DPB	T1, LDPTIM	;RESET BLOCK-INPUT TIMER
UPOPJ:	POP	P, U
	POPJ	P,

    ;HERE WHEN WE'VE JUST FILLED A BLOCK INPUT BUFFER

CLSPBF:	HRRZ	T4, BIOCHR(T1)	;T4/ (PRESUMABLY) # CHARS MOVED
	PUSHJ	P, FRCIBF	;SIMULATE BUFFER-FULL MESSAGE
	SETZ	T1,
	DPB	T1, LDPTIM	;CLEAR BLOCK-INPUT TIMER
	MOVEI	T1, LDRBIP
	ANDCAM	T1, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	POP	P, U
	PUSHJ	P, FRCNOO	;BACKPRESSURE OURSELVES
	POPJ	P,
    ;IMPOSSIBLE OUTPUT BITS

PGSRD:	;RED BALL
PGGBF:	;GREEN BALL
	STOPCD

    ;IGNORED OUTPUT BITS

PGSEC:	;SET ECHO MODE (SHOULD ALWAYS BE OFF)
PGSTP:	;TERMINAL CHARACTERISTICS PROBE
PGHNG:	;HANG UP DATA SET
	JRST	MORLIN

    ;NOT IMPLEMENTED YET -- IGNORE

PGSTC:	;SET TERMINAL CHARACTERISTICS
	JRST	MORLIN
;MSGSIM -- SIMULATE INPUT-MESSAGE ARRIVAL
;	CALLED WITH T1/ ADDR OF A FRC--- ROUTINE
;	CALLS <T1> WITH U/ THE CURRENT PTY'S "BUDDY"

MSGSIM:	PUSH	P, U		;SAVE U
	PUSHJ	P, PTYBUD	;U/ "BUDDY" LDB
	HLL	U, LDBDCH(U)
	PUSHJ	P, (T1)		;SIMULATE A <T1>-ARRIVAL
	POP	P, U
	JRST	MORLIN

;CHARACTER GOBBLER

PGCGB:	MOVEI	T1, FRCCGB
	PJRST	MSGSIM


;ORANGE BALL

PGSOG:	MOVSI	T2, L2LDEL
	TDNN	T2, LDBBYT(U)	;IF WE'RE IN \...
	PUSHJ	P, WTCHK	;OR WE'RE IN INPUT WAIT,
	JRST	WATLIN		;  WAIT
	MOVEI	T1, FRCORG
	PJRST	MSGSIM

;BACKPRESSURE ON

PGBPN:	MOVEI	T1, LDRXOS
	TDNE	T1, LDBDCH(U)	;IF WE'VE ALREADY SENT AN XOFF,
	JRST	MORLIN		;  DON'T SEND ANOTHER
	IORM	T1, LDBDCH(U)
	MOVEI	T1, FRCNOO
	PJRST	MSGSIM

;BACKPRESSURE OFF

PGBPF:	MOVEI	T1, LDRXOS
	ANDCAM	T1, LDBDCH(U)	;CLEAR BACKPRESSURE-SEND FLAG
	MOVEI	T1, FRCDOO
	PJRST	MSGSIM
;YELLOW BALL

PGSYL:	PUSH	P, U
	PUSHJ	P, PTYBUD
	HLL	U, LDBDCH(U)
	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IS OTHER END DOING BLOCK INPUT?
	JRST	PGSYLN		;(NO)

    ;HERE WHEN THE OTHER END'S DOING BLOCK INPUT

	ANDCAM	T1, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	HRRZ	T1, LDBBIO(U)
	SKIPE	T1
	SKIPL	T2, BIOCHR(T1)
	  STOPCD
	HRRZ	T4, T2		;T4/ # CHARS TO TRANSFER
	SUB	T4, BIOPBC(T1)	;T4/ # CHARS TRANSFERRED
	PUSHJ	P, FRCEOT	;FAKE A BLKI-EOT
	POP	P, U
	PUSHJ	P, FRCNOO	;BACKPRESSURE OURSELVES
	JRST	WATLIN		;(SEND YLB WHEN BKP RELIEVED)

    ;HERE IN THE NORMAL CASE

PGSYLN:	MOVSI	T1, L2LOWT
	IORM	T1, LDBBYT(U)	;SAY WE'RE WAITING
	MOVSI	T1, L2LOWS
	ANDCAM	T1, LDBBYT(U)	;AND THAT WE HAVEN'T SEEN ONE
	PUSHJ	P, FRCYEL
	POP	P, U
	JRST	MORLIN
;WHEN THE PTY OUTPUT CODE FILLS UP A BLOCK INPUT BUFFER, IT
;FORCES BACKPRESSURE ON THE LINE DOING THE OUTPUT -- THE
;REQUEST-BLOCK-INPUT AND REQUEST-BLOCK-INPUT-TERMINATION
;OUTPUT ROUTINES CLEAR THE BACKPRESSURE

;TERMINATE BLOCK INPUT

PGTRI:	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IF BLOCK INPUT'S IN PROGRESS,
	JRST	PGTRI1
	ANDCAM	T1, LDBDCH(U)	;  CLEAR IN-PROGRESS FLAG
	HRRZ	T1, LDBBIO(U)	;  T1/ BLOCK INPUT BUFFER ADDR
	SKIPE	T1
	SKIPL	T2, BIOCNT(T1)
	  STOPCD
	HRRZ	T4, T2		;  T4/ # OF CHARS TO TRANSFER
	SUB	T4, BIOPBC(T1)	;  T4/ # OF CHARS TRANFERRED
	JRST	.+2		;OTHERWISE
PGTRI1:	SETZ	T4,		;  T4/ 0 CHARS
	PUSHJ	P, FRCIHR	;FAKE A TERMINATED-BY-REQUEST
	JRST	PGBIN1		;CLEAR BACKPRESSURE ON THE OTHER END

;REQUEST BLOCK INPUT

PGBIN:	MOVEI	T1, LDRBIP
	IORM	T1, LDBDCH(U)	;MARK INPUT IN PROGRESS
	MOVEI	T1, %PBTIM
	DPB	T1, LDPTIM	;SET BLOCK-INPUT TIMEOUT
	HRRZ	T1, LDBBIO(U)	;T1/ INPUT BUFFER ADDRESS
	SKIPN	T1
	  STOPCD
	HRRZ	T2, BIOCHR(T1)	;T2/ # CHARS TO TRANSFER
	MOVEM	T2, BIOPBC(T1)	;STORE PTY COUNT
	MOVE	T2, [POINT 8,BIODAT]
	ADD	T2, T1
	MOVEM	T2, BIOPBP(T1)	;STORE PTY BYTE POINTER

    ;HERE FROM ABOVE AND FROM PGTRI TO CLEAR BACKPRESSURE

PGBIN1:	PUSH	P, U
	PUSHJ	P, PTYBUD
	HLL	U, LDBDCH(U)
	PUSHJ	P, FRCDOO	;CLEAR BACKPRESSURE ON OTHER END
	POP	P, U
	JRST	MORLIN
;PBTIMO -- CALLED BY SCNSEC WHEN A PORT DOING BLOCK INPUT
;	   TIMES OUT.
;	   SAVES P1-P4.
;	   ASSUMES THAT FRCITM PRESERVES U AND F.

PBTIMO:	PUSH	P, P1
	PUSH	P, P2
	PUSH	P, P3
	PUSH	P, P4

	HRRZ	T1, LDBBIO(U)
	SKIPE	T1
	SKIPL	T4, BIOCHR(T1)
	  STOPCD		;NO BUFFER OR NO INPUT PENDING
	MOVEI	T2, LDRBIP
	ANDCAM	T2, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	HRRZ	T4, T4		;T4/ # BYTES REQUESTED
	SUB	T4, BIOPBC(T1)	;T4/ # BYTES TRANSFERRED
	PUSHJ	P, FRCITM	;FAKE A TIMEOUT MESSAGE
	PUSH	P, U
	PUSHJ	P, PTYBUD
	PUSHJ	P, FRCNOO	;BACKPRESSURE OTHER END
	POP	P, U

	POP	P, P4
	POP	P, P3
	POP	P, P2
	POP	P, P1
	POPJ	P,
;BLOCK OUTPUT

PGBOT:	SKIPN	DIDPBI		;IF THE OTHER END WAS DOING BLOCK INPUT,
	JRST	PGBOTC
	MOVE	T1, CHCNT
	CAME	T1, CHQTA	;AND IT HASN'T GOTTEN ANY CHARS YET,
	JRST	PGBOTC
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNE	T1, LDBDCH(U)	;AND IT'S STILL IN BLOCK INPUT WAIT,
	JRST	PGBOT1
	POP	P, U
	JRST	PGBOTC
PGBOT1:	HRRZ	T1, LDBBIO(U)	;  T1/ ITS BLOCK INPUT BUFFER
	SKIPN	T1
	  STOPCD
	HRRZ	T2, (P)		;  T2/ OUR LDB ADDR
	HLRZ	T3, LDBBIO(T2)	;  T3/ OUR BLOCK OUTPUT BUFFER
	SKIPN	T3
	  STOPCD
	HRRM	T3, LDBBIO(U)	;  OUR OUTPUT => ITS INPUT
	HRLM	T1, LDBBIO(T2)	;  ITS INPUT => OUR OUTPUT
	MOVE	T4, BIOREQ(T1)
	EXCH	T4, BIOREQ(T3)
	MOVEM	T4, BIOREQ(T1)	;  BUT KEEP THE OLD BIOREQ'S
	SKIPL	T1, BIOCHR(T1)	;  T1/ -1,,# CHARS "TRANSMITTED"
	  STOPCD
	MOVEM	T1, BIOCHR(T3)	;  INPUT SIDE WANTS THE -1 FLAG
	HRRZS	BIOCHR(T1)	;  OUTPUT SIDE DOESN'T
	HRRZM	T1, PBDISC	;  ALREADY CHARGED (JBTBIO), SO DISCOUNT
	POP	P, U
	SETZM	CHCNT		;  WE'VE FILLED ITS BUFFER
	PUSHJ	P, FRCOHR	;  WE'VE DONE OUR BLOCK OUTPUT
	JRST	FINLIN		;  NO MORE THIS CYCLE

    ;HERE WHEN THE OTHER END'S NOT COOPERATING BY DOING BLOCK INPUT

PGBOTC:	HLRZ	T1, LDBBIO(U)	;T1/ BLOCK OUTPUT BUFFER
	SKIPN	T1
	  STOPCD
	HRRZ	T2, BIOCHR(T1)	;T2/ TOTAL CHARS TO TRANSFER
	MOVEM	T2, BIOPBC(T1)	;STORE IT
	MOVE	T3, [POINT 8,BIODAT]
	ADD	T3, T1		;T3/ BYTE POINTER
	MOVEM	T3, BIOPBP(T1)	;STORE IT
	MOVEI	T1, 1
	DPB	T1, LOPBOP	;SET BLOCK-OUTPUT-IN-PROGRESS
	JRST	MORLIN		;(DISPATCH WILL GO DO IT)
;BLOCK OUTPUT IN PROGRESS

PGBOP:	HLRZ	T1, LDBBIO(U)
	SKIPN	T1
	  STOPCD
	MOVE	T2, BIOPBC(T1)	;T2/ COUNT
	MOVE	T3, BIOPBP(T1)	;T3/ POINTER
	MOVE	T4, MULCNT+1
	CAMLE	T4, CHCNT
	MOVE	T4, CHCNT	;T4/ MIN(MULCNT+1,CHCNT)
	PUSH	P, T4		;SAVE IT
	CAMLE	T2, T4
	MOVE 	T2, T4		;T4/ MIN(# TO XFER,# THAT'LL FIT)
	PUSH	P, T2		;SAVE IT

	JUMPE	T2, PGBOP2
PGBOP1:	UUILDB	T4, T3
	UUIDPB	T4, CHRWRP+1
	SOJG	T2, PGBOP1

PGBOP2:	POP	P, T2
	ADDM	T2, PBDISC	;(TO BE DISCOUNTED FROM CHARIO CHARGE)
	MOVN	T4, T2
	ADDM	T4, MULCNT+1	;DECREMENT MULCNT
	ADDM	T4, CHCNT	;AND CHCNT
	ADDM	T4, (P)		;AND SAVED # THAT'LL FIT
	ADDB	T4, BIOPBC(T1)	;AND BLOCK-BUFFER COUNT
	JUMPG	T4, PGBOP3	;IF WE'RE DONE
	PUSHJ	P, FRCOHR	;  FAKE AN OUTPUT-TERMINATED
	POP	P, T1
	JUMPLE	T1, FINLIN
	JRST	MORLIN
				;OTHERWISE,
PGBOP3:	MOVEM	T3, BIOPBP(T1)	;  UPDATE CHARACTER POINTER
	POP	P, T1
	JRST	FULLIN
;TERMINATE BLOCK OUTPUT

PGTRO:	SETZ	T1,
	DPB	T1, LOPBOP	;CLEAR BLKO-IN-PROGRESS
	PUSHJ	P, FRCOHR	;FAKE AN OUTPUT-TERMINATED
	JRST	MORLIN
;CIRCUIT ZAPPER

PGZAP:	MOVSI	T1, L2LOWT
	TDNN	T1, LDBBYT(U)	;IF WAITING FOR ORANGE BALL,
	SKIPE	LDBBIO(U)	;OR IF BLOCK I/O NEEDS CLEANING-UP,
	JRST	WATLIN		;  WAIT
	SETZM	LDBLOG(U)	;MARK THIS PORT GONE
	SETZM	LDBMOD(U)
	PUSHJ	P, TSETBO
	PUSHJ	P, TSETBI
	SETZ	T1,
	DPB	T1, LDBOPB(U)	;CLEAR NEED-OUTPUT
	PUSH	P, U
	PUSHJ	P, PTYBUD	;U/ "BUDDY" LDB
	SKIPN	LDBLOG(U)	;IF IT'S ALREADY GONE,
	JRST	PGZAP1		;  THERE'S NOTHING MORE TO DO
	HLL	U, LDBDCH(U)
	PUSHJ	P, FRCZAP	;FAKE A ZAPPER THERE
PGZAP1:	POP	P, U
	JRST	FINLIN

;BELL (SHOULDN'T REALLY HAPPEN) -- SIMULATE BLACK BALLS

PGSBL:	AOS	PTYLOS		;COUNT CHARACTER LOST BY US
	MOVEI	T1, 1
	PUSHJ	P, FRCLOS	;"INPUT LOST" TO BELL SENDER
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, 0
	PUSHJ	P, FRCLOS	;"OUTPUT LOST" TO OTHER END
	POP	P, U
	POPJ	P,
SUBTTL TYMNET OUTPUT ROUTINES

;THIS ROUTINE IS CALLED TO SET THINGS UP FOR CHARACTER
;OUTPUT. NON-SKIP RETURN MEANS NO ROOM IN OUTPUT BUFFER

SETOUT:	SETOM MXMCNT		;FLAG THAT NO ROOM THERE
	MOVE P4,ORP620
	SUB P4,ORPPDP	;SIZE OF SPACE IN OUTPUT RING
	SOJL P4,[MOVEI P4,MSKORG+1
		SKIPN ORP620	;IF 620 AT 0 CAN NOT
		MOVEI P4,MSKORG	;USE LAST WORD
		SUB P4,ORPPDP	;FIND SPACE TO END OF BUFFER
		JUMPN P4,.+2	;SOME REALLY THERE
		POPJ P,]	;NOT REALLY ANY THERE
	JUMPE P4,CPOPJ		;REALLY NO ROOM
	LSH P4,2	;CONVERT TO NUMBER OF CHARACTERS
	SUBI P4,2	;TAKES TWO FOR COUNT AND PORT
	CAILE P4,177	;COUNT MUST FIT IN BYTE SIZE-1
	MOVEI P4,177
	MOVEM P4,MULCNT+0	;SAVE COUNT
	MOVEM P4,MXMCNT	;AND ORIGINAL (SO KNOW HOW MANY SENT)
	MOVE P4,ORPPDP
	MOVEI T1,ORING(P4)
	HRLI T1,(POINT 8,0,BYP2);SET TO PUT FIRST IN 3RD BYTE
	MOVEM T1,CHRWRP+0	;SET BYTE POINTER
	JRST CPOPJ1

;THIS ROUTINE IS CALLED TO FINISH UP OUTPUT. IT NONSKIP-RETURNS
;IF THERE IS NO BUFFER SPACE NOW.

CLSCHR:	SKIPGE T1,MXMCNT
	JRST SETOUT	;WE REALLY DON'T THINK ANY CHRS THERE
	SUB T1,MULCNT+0	;COMPUTE NUMBER OUTPUT
	JUMPE T1,CPOPJ1	;NONE SO MUST STILL BE SPACE
	SKIPG MULCNT+0	;DID WE RUN OUT OF ROOM IN RING
	SOS CHCNT+0		;YES, ACTUALLY 1 MORE CHR OUT
	SETOM FSCN	;FLAG AS SOME OUTPUT
	TRO T1,200	;SET BIT TO FLAG AS DATA TYPE
	DPB T1,OUPTYP	;SET IN TYPE FIELD
	LDB T3,LDPLNO
	DPB T3,OUPLIN	;AND THE PORT NUMBER
	SUBI T1,200-5	;COMPUT NUMBER OF WORDS USED
	LSH T1,-2
	ADD P4,T1
ADVPTR:	ANDI P4,MSKORG
	MOVEM P4,ORPPDP	;SET FOR 620 TO FIND
	PJRST SETOUT	;AND FIND OUT ABOUT MORE SPACE
COMMENT !
TO OUTPUT A CHARACTER INTO THE RING (OR TO A PTY), USE THE CODE:
	UUIDPB T3,CHRWRP(W)	;CHR. IN T3
	SOSLE MULCNT(W)		;SEE IF OUT OF ROOM
	SOSG CHCNT		;OR TIME TO STOP AND CHECK INPUT RING
	 HERE IF WE SHOULD STOP
	 HERE IF WE SHOULD NOT STOP
!

;OUTPUT A FULL WORD FOR SPECIAL TYPES

WRDOUT:	JUMPE W, .+2		;IF IT'S A PTY,
	  STOPCD		;  THERE SHOULD BE ONLY CHAR. OUTPUT
	MOVEM P3,ORING(P4)	;PUT THE WORD IN THE OUTPUT BUFFER
	SETOM FSCN
	MOVNI P3,4
	ADDM P3,MULCNT+0	;UPDATE REAMAINING COUNTS
	ADDB P3,MXMCNT	;IN CASE WE GO TO CHR OUTPUT
	JUMPL P3,[AOJA P4,ADVPTR]	;WILL GET TO SETOUT
	AOS CHRWRP+0
	AOS P4,ORPPDP	;JUST ADVANCE OUTPUT POINTER
	JRST CPOPJ1

;OUTPUT 2 WORDS FOR SPECIAL TYPES.

WRDOT2:	JUMPE W,.+2	;IF IT'S A PTY,
	  STOPCD	;  THERE SHOULD BE ONLY CHARACTER OUTPUT
	MOVEM P3,ORING(P4) ;PUT 2ND WORD IN THE OUTPUT BUFFER.
	SETOM FSCN	;FLAG THAT THERE'S SOMETHING TO DO.
	MOVNI P3,8	;2 WDS (8 CHARS) TO OUTPUT.
	ADDM P3,MULCNT+0	;UPDATE REMAINING COUNTS
	ADDB P3,MXMCNT	;IN CASE WE GO TO CHR OUTPUT
	JUMPL P3,[AOJA P4,ADVPTR]	;WILL GET TO SETOUT.
	AOS CHRWRP+0	;INCREMENT CHAR BYTE POINTER.
	AOS CHRWRP+0	;INCREMENT IT AGAIN (PAST 2 WORDS).
	ADDI P4,1	;INCREMENT P4
	MOVEM P4,ORPPDP	;AND INFORM THE BASE.
	JRST CPOPJ1	;SKIP RETURN.
SUBTTL NON-CHARACTER OUTPUT MESSAGE HANDLERS

;DON'T SEND ANY MESSAGES FROM THIS LINE

PGHSH:	STOPCD			;HSH NOT USED ON PTYs
GOHSH:	LDB	T1,LOPZAP	;SEE IF ZAP SET
	SKIPN	T1
	  JRST	[AOS BADGUY	;COUNT BADGUYS THAT TRY TO SEND MESSAGES
		JRST WATLIN]	;	FROM THIS PORT
	PUSHJ	P,CLRTTY	;DO FALSE ZAP STUFF
	JRST	FINLIN

;SEND TERMINAL CHARACTERISTIC(S)

GOSTC:	PUSHJ	P, CLSCHR
	  JRST	FULLIN		;NO ROOM
GOSTC1:	MOVE	T3, LDBTMT(U)	;T3/TRANSMIT BITS
	JFFO	T3, .+2		;T4/T.C # TO SEND THIS TIME
	JRST	MORLIN		;NONE OR NO MORE
	MOVSI	P3, TYPI TYPTCS	;MESSAGE TYPE
	DPB	T4, WRPCHR	;CHARACTERISTIC NUMBER
	LDB	T1, TABTMS(T4)
	DPB	T1, WRPCH2	;CHARACTERISTIC VALUE
	MOVSI	T1, (1B0)
	MOVNS	T4
	LSH	T1, (T4)
	ANDCAM	T1, LDBTMT(U)	;CLEAR THE TRANSMIT BIT
	LDB T3,LDPLNO
	DPB T3,WRPLIN		;SET PORT NUMBER IN OUTPUT WORD
	PUSHJ P,WRDOUT		;SEND IT. IF THERE'S ROOM FOR MORE,
	JRST .+2
	JRST GOSTC1		;  GO SEE IF THERE'S MORE TO SEND.
	SKIPE LDBTMT(U)		;(NO ROOM) IF THERE WERE MORE TO DO,
	JRST FULLIN		;  SAY WE'RE NOT DONE
	JRST FINLIN
;SEND A RED BALL

GOSRD:	MOVSI P3,TYPI TYPRED
	JRST FMTB

;SEND A CHARACTER GOBBLER

GOCGB:	MOVSI P3,TYPI TYPGOB
	JRST FMTB

;SEND A TERMINAL CHARACTERISTICS PROBE

GOSTP:	MOVSI P3,TYPI TYPTCP	;PROBE
	MOVEI T3,TMCALL		;FOR ALL
	DPB T3,WRPCHR
	JRST FMTB

;SET ECHO MODE

GOSEC:	MOVSI P3,TYPI TYPECN	;ECHO ON
	MOVE T1,LDBDCH(U)	;GET BOTH HALVES OF DCH
	TDNE T1,[LDLNEC,,LDRDEM];DO WE WANT IT OFF INSTEAD?
	MOVSI P3,TYPI TYPECF	;(YES)
	JRST FMTB

;SEND SOFT ZAP (HANG UP PHONE, KEEP CIRCUIT)

GOHNG:	MOVSI	P3, TYPI TYPHNG
	JRST	FMTB

;FMTB -- CALLED WITH P3/ BYTE (8) TYPE, 0, XXX, XXX
;	 CLOSES CHARACTER MODE, RETURNING TO FULLIN IF NO ROOM,
;	 DEPOSITS PORT# INTO SECOND BYTE, TRANSMITS THE
;	 1-WORD MESSAGE, AND RETURNS TO THE OUTPUT DISPATCH
;FMTB1 -- ASSUMES CALLER HAS ALREADY DONE A CLSCHR

FMTB:	PUSHJ	P, CLSCHR	;LEAVE CHARACTER MODE. IF NO MORE ROOM,
	JRST	FULLIN		;  RETURN TO OUTPUT DISPATCH
FMTB1:	LDB	T3, LDPLNO	;T3/ PORT #
	DPB	T3, WRPLIN	;DEPOSIT IT
	PUSHJ	P, WRDOUT	;SEND IT. ROOM FOR MORE?
	  JRST	FINLIN		;NO
	JRST	MORLIN		;YES
;SEND BELL

GOSBL:	MOVE	T2, LDBDCH(U)
	TLNN	U, LDLIMI	;IF IN IMAGE STATE,
	TRNE	T2, LDRNXO	;OR USER SAYS NO XOFF/XON,
	JRST	MORLIN		;  AVOID SENDING BELLS
	MOVEI	T3, 7		;T3/ ASCII BELL
	;JRST	COMXON

;COMXON -- CALLED WITH T3/ A CHARACTER AND THE PORT OPEN FOR
;	   CHARACTER OUTPUT. DEPOSIT THE CHARACTER IN THE BUFFER
;	   RING AND RETURN TO THE OUTPUT DISPATCH

COMXON:	UUIDPB	T3, CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	 JRST	FINLIN		;NO ROOM FOR MORE
	JRST	MORLIN		;ROOM FOR MORE

;BACKPRESSURE OFF

GOBPF:	MOVEI	T2, LDRXOS
	TDNE	T2, LDBDCH(U)	;IF WE SENT AN XOFF,
	JRST	GOXON		;  GO SEND AN XON
	PUSHJ	P, CLSCHR
	  JRST	FULLIN		;NO ROOM FOR MESSAGE
	MOVEI	T2, LDRBPS
	ANDCAM	T2, LDBDCH(U)	;TURN OFF BACKPRESSURE-SENT FLAG
	MOVSI	P3, TYPI TYPOUP	;P3/ MESSAGE TYPE
	JRST	FMTB1

    ;HERE TO SEND AN XON

GOXON:	ANDCAM	T2, LDBDCH(U)	;CLEAR BACKPRESSURE-SENT FLAG
	MOVEI	T3, 21		;T3/ ASCII XON
	JRST	COMXON		;GO SEND IT

;BACKPRESSURE ON

GOBPN:	LDB	T1, TRMBYP	;T1/ TERMINAL ID #
	JUMPE	T1, GOBPN1	;IF AUX CIRCUIT (0), BACKPRESSURE
	TLNN	U, LDLIMI	;OTHERWISE, IF NOT IMAGE STATE,
	JRST	GOXOFF		;  SEND AN XOFF
GOBPN1:	PUSHJ	P, CLSCHR
	  JRST	FULLIN		;NO ROOM FOR MESSAGE
	MOVEI	T2, LDRBPS
	IORM	T2, LDBDCH(U)	;SET BACKPRESSURE-SENT FLAG
	MOVSI	P3, TYPI TYPNOP	;P3/ MESSAGE TYPE
	JRST	FMTB1

   ;HERE TO SEND AN XOFF

GOXOFF:	MOVEI	T1, LDRNXO
	MOVEI	T3, LDRXOS
	TDNN	T3, LDBDCH(U)	;IF WE'VE ALREADY SENT ONE XOFF
	TDNE	T1, LDBDCH(U)	;OR IF WE MUSTN'T SEND ANY,
	JRST	MORLIN		;  JUST SAY WE'VE DONE IT
	IORM	T3, LDBDCH(U)	;SET XOFF-SENT FLAG
	MOVEI	T3, 23		;T3/ ASCII XOFF
	JRST	COMXON		;GO SEND IT
;SEND CIRCUIT ZAPPER

GOZAP:	MOVSI	T1, L2LOWT
	TDNN	T1, LDBBYT(U)	;IF SOMEONE'S WAITING FOR ORANGE BALL
	SKIPE	LDBBIO(U)	;OR IF BLOCK I/O NEEDS CLEEANING-UP,
	JRST	WATLIN		;  WAIT
	PUSHJ P,CLSCHR		;LEAVE CHAR MODE. SKIP IF ROOM.
	JRST FULLIN		;  MUST WAIT OR NO ROOM
	HRRZ T1,U
	CAME T1,OPRLDB
	JRST NOTOPR
	SETZM OPRLDB
	SETZM DEVOPR
	PUSHJ P,OPRFRE
	MOVEI T1,400000
	TDNE T1,STATES		;IS SYSTEM SHUT?
	JRST NOTOPR		;YES
	MOVEI T1,^D90
	MOVEM T1,OPRTIM		;NO, SET TIMER FOR UNHAPPY MSG
NOTOPR:	TLNN U,LDLAUX!LDLPTY	;THIS ONE WAS NOT COUNTED ANYWAY
	SKIPL LDBLOG(U)
	JRST NOTLIN		;NOT REALLY IN
	MOVEI T1,200000
	SOSG INTERM
	SKIPE DWNFLG
	SKIPA			;DO NOT RESET IF COMING DOWN
	ANDCAM T1,STATES	;CAN'T BE SUPER SHUT WITH EVERYONE GONE
NOTLIN:	SETZM LDBLOG(U)		;CLEAR LOGGED IN INFO
	SETZM LDBMOD(U)		;RESET MODE TO LOGIN MODE
	PUSHJ P,TSETBO
	PUSHJ P,TSETBI		;ALSO CLEAR INPUT
	MOVE T1,LDBLIN(U)
	TLZE T1,LNLZIN
	AOS NZAPOT		;AN IN-ZAP WAS RESPONDED TO
	MOVEM T1, LDBLIN(U)
	MOVEI T1,0
	DPB T1,LDBOPB(U)	;NOTHING MORE TO DO ON OUTPUT
	MOVSI P3,TYPI TYPZAP
	LDB T2,LDPLNO
	DPB T2,WRPLIN
	CAILE T2,RPORTN
	  STOPCD		;CRASH- ZAPPING BEYOND HIGHEST REAL PORT
	PUSHJ P,WRDOUT
	 JRST FINLIN
	JRST FINLIN		;NOBODY LEFT TO TALK TO

CLRTTY:	HRRZ T1,U		;FALSE ZAP STUFF FOR REAL TTYs
	CAME T1,OPRLDB
	JRST NTTOPR
	SETZM OPRLDB
	SETZM DEVOPR
	PUSHJ P,OPRFRE
	MOVEI T1,400000
	TDNE T1,STATES		;IS SYSTEM SHUT?
	JRST NTTOPR		;YES
	MOVEI T1,^D90
	MOVEM T1,OPRTIM		;NO, SET TIMER FOR UNHAPPY MSG
NTTOPR:	TLNN U,LDLAUX		;THIS ONE WAS NOT COUNTED ANYWAY
	SKIPL LDBLOG(U)
	JRST CLRPTY		;NOT REALLY IN
	MOVEI T1,200000
	SOSG INTERM
	SKIPE DWNFLG
	SKIPA			;DO NOT RESET IF COMING DOWN
	ANDCAM T1,STATES	;CAN'T BE SUPER SHUT WITH EVERYONE GONE
CLRPTY:				;FALSE ZAP ENTRY FOR PTYs
	SETZM LDBLOG(U)		;CLEAR LOGGED IN INFO
	SETZM LDBMOD(U)		;RESET MODE TO LOGIN MODE
	PUSHJ P,TSETBO
	PUSHJ P,TSETBI		;ALSO CLEAR INPUT
	MOVE T1,LDBLIN(U)
	TLZE T1,LNLZIN
	AOS NZAPOT		;AN IN-ZAP WAS RESPONDED TO
	MOVEM T1, LDBLIN(U)
	SETZM	LDBOUT(U)	;CLEAR 'SEND SPECIAL MESSAGE' FLAGS
	MOVEI T1,0
	DPB T1,LDBOPB(U)	;NOTHING MORE TO DO ON OUTPUT
	POPJ	P,
;HERE ON A DETECTED ZAPPER ANOMALY TO STORE STUFF ABOUT THE PORT

ZBGBUG:	0	;ADDRESS OF THE COUNT INCREMENTED

ZBGLIN:	0	;LDBLIN OF THE OFFENDING PORT
ZBGDCH:	0	;LDBDCH
ZBGDDB:	0	;LDBDDB
ZBGOUT:	0	;LDBOUT
ZBGBIT:	0	;OUTPUT BIT
ZBGBYT:	0	;LDBBYT
ZBGMOD:	0	;LDBMOD
ZBGDCX:	0	;LDBDCX
	0
	0
	0
	0

ZAPBUG:	PUSH	P, T2
	HRRZI	T2, ZBGBUG-1	;(PDL POINTER)
	PUSH	T2, T1		;STORE THE COUNTER'S ADDRESS
	AOS	(T1)		;INCREMENT THE COUNTER
	PUSH	T2, LDBLIN(U)
	PUSH	T2, LDBDCH(U)
	PUSH	T2, LDBDDB(U)
	PUSH	T2, LDBOUT(U)
	LDB	T1, LDBOPB(U)
	PUSH	T2, T1
	PUSH	T2, LDBBYT(U)
	PUSH	T2, LDBMOD(U)
ZAPBG1:	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	POP	P, T2
	POPJ	P,
SUBTTL BLOCK I/O MESSAGE ROUTINES

;BLOCK INPUT

GOBIN:	PUSHJ	P, GOBIO1	;INITIAL SETUP
	  JRST	FULLIN		;NO ROOM
	HRRZ	T3, LDBBIO(U)	;T3/ INPUT BUFFER ADDR
IFCPU (KL),<
	MOVE	T1, BIOCSH(T3)	;T1/ SWEEP NUMBER
	CAME	T1, CSUCNT	;UNLOAD ALREADY DONE?
	JRST	[
		AOS CSHSAV	;PAT OURSELVES ON THE BACK
		JRST GOBIN1
	]
	CSHUNL			;UNLOAD THE CACHE
	CAMN	T1, CSUCNT
	JRST	.-1		;WAIT 'TIL IT'S DONE
GOBIN1:>;END IFCPU (KL)
IFKMC	<CSHIVL>		;INVALIDATE 2020 CACHE
	MOVSI	P3, TYPI TYPBIN	;P3/ MESSAGE TYPE
	PUSHJ	P, GOBIO2	;OUTPUT THE MESSAGE
	  JRST	FINLIN		;(NO ROOM FOR MORE)
	JRST	MORLIN		;(ROOM FOR MORE)

;BLOCK OUTPUT

GOBOP:	STOPCD		;(PTYS ONLY)

GOBOT:	PUSHJ	P, GOBIO1	;INITIAL SETUP
	  JRST	FULLIN		;NO ROOM
	HLRZ	T3, LDBBIO(U)	;T3/ OUTPUT BUFFER ADDR
IFCPU (KL),<
	MOVE	T1, BIOCSH(T3)	;T1/ SWEEP NUMBER
	CAME	T1, CSVCNT	;IF A SWEEP'S ALREADY BEEN DONE,
	JRST	[
		AOS CSHSAV	;PAT OURSELVES ON THE BACK
		JRST GOBOT1
	]
	CSHVAL			;START VALIDATE
	CAMN	T1, CSVCNT
	JRST	.-1		;AND WAIT 'TIL IT'S DONE
GOBOT1:>;END IFCPU (KL)
	MOVSI	T1, LDLNOP
	IORM	T1, LDBDCH(U)	;PREVENT FUTURE OUTPUT UNTIL
				;BLOCK OUTPUT IS COMPLETE
	MOVSI	P3, TYPI TYPBKO	;P3/ MESSAGE TYPE
	PUSHJ	P, GOBIO2	;OUTPUT THE MESSAGE
	  JRST	FINLIN		;(NO ROOM FOR MORE)
	JRST	FINLIN		;(ROOM FOR MORE BUT CLAIM THERE ISN'T)
;GOBIO1 -- CLOSE CHARACTER OUTPUT, THEN SKIP IF THERE ARE
;	   AT LEAST 2 FREE WORDS IN THE OUTPUT RING

GOBIO1:	PUSHJ	P, CLSCHR	;CLOSE CHARACTER MODE
	  POPJ	P,		;NO ROOM
	MOVE	T1, ORPPDP
	ADDI	T1, 2
	ANDI	T1, MSKORG	;T1/ (PDP PTR + 2) MOD RING SIZE
	CAME	T1, ORP620
	AOS	(P)		;ENOUGH ROOM
	POPJ	P,

;GOBIO2 -- CALLED WITH T3/ BUFFER ADDR
;		       P3/ BYTE (8) TYPE, 0, 0, 0
;	   DEPOSIT THE PORT# AND BUFFER ADDRESS APPROPRIATELY,
;	   OUTPUT THE BLOCK INPUT/OUTPUT MESSAGE,
;	   SKIP-RETURN IF THERE'S ROOM FOR MORE

GOBIO2:	LDB	T1, LDPLNO	;T1/ PORT#
	DPB	T1, WRPLIN	;DEPOSIT IT
	HRRZ	T1, BIOCHR(T3)	;T1/ CHARACTER COUNT
	DPB	T1, [POINT ^D16, P3, BYP4]
	MOVEM	P3, ORING(P4)
	ADDI	P4, 1
	ANDI	P4, MSKORG
	SETZ	P3,
IFKMC<
	MOVEI	T1,(T3)		;T1/ BUFFER ADDRESS
	PUSHJ	P,SCANBB	;FIND UBA PAGE MATCHING T1
		STOPCD		;THERE HAS TO BE ONE AT THIS POINT
	ADDI	T2,UBABIO&77	;UBAPAG# + Low 6 BITS OF UBA ADDRESS 
	DPB	T2,[POINT 11,T1,26]	;PAGE # OVERLAYS HIGH 11 BITS
	ADDI	T1,BIODAT		;Offset to first Char address
	DPB	T1,[POINT 8,P3,BYP3]	;LOW 8 BITS TO 3RD BYTE POS.
	LSH	T1,-8			;SHIFT TO HIGH 10 BITS
	DPB	T1,[POINT 10,P3,BYP2]	;THE REST IN BYTES 1 & 2
	>;END IFKMC
IFNKMC<
	MOVEI	T1, BIODAT(T3)	;T1/ FIRST-CHARACTER ADDR
IFNCPU (KI),<MAP	T1,(T1)	;GET PHYSICAL ADDRESS
	DPB	T1,[POINT 18,P3,23] ;PUT IT IN
>;END IFNCPU (KI)
>;END IFNKMC
IFCPU (KI),<DPB	T1,[POINT 9,P3,23] ;PUT IN LOW 9 BITS, MAP SMASHES THEM
	MAP	T1,(T1)		;GET PAGE NUMBER
	DPB	T1,[POINT 9,P3,14] ;PUT IN HIGH 9 BITS.
>;END IFCPU (KI)
	PJRST	WRDOT2

;TERMINATE BLOCK OUTPUT

GOTRO:	PUSHJ	P, CLSCHR	;LEAVE CHARACTER MODE. IF NO ROOM,
	JRST	FULLIN		;  RETURN TO OUTPUT DISPATCH
	MOVSI	T1, LDLNOP
	IORM	T1, LDBDCH(U)	;SET BACKPRESSURE
	MOVSI	P3, TYPI TYPORQ	;SEND OUTPUT TERMINATION REQUEST
	JRST	FMTB1

;TERMINATE BLOCK INPUT

GOTRI:	MOVSI P3,TYPI TYPIRQ	;SET UP BLOCK TERMINATION REQ
	JRST	FMTB
SUBTTL RUBOUT STRING/OUTPUT CHARACTER HANDLERS

;SEND RUBOUT CHARACTERS

PGRUB:
GORUB:	SKIPN	LDBRBC(U)
	JRST	MORLIN		;NO RUBOUT CHARACTERS
	TDZA	P1, P1		;P1 := -1 IF PRCOUT RUNS OUT OF ROOM
	JRST	FULLIN		;OUT OF ROOM
CNTRUB:	MOVE	T2, LDBRBO(U)
	PUSHJ	P, TTGETC	;GET A CHAR. IF DONE WITH THE CHUNK,
	PUSHJ	P, FRECHK	;  FREE IT
	MOVEM	T2, LDBRBO(U)
	PUSHJ	P, PRCOUT	;PRINT THE CHARACTER
	  JRST	[		;NO ROOM
		ADDM	T3, LDBRBO(U)
		JRST	FULLIN
	  ]
	SOSLE	LDBRBC(U)	;IF THERE'RE MORE CHARACTERS,
	JRST	CNTRUB(P1)	;  KEEP GOING IF THERE'S ROOM

    ;HERE WHEN THERE'RE NO MORE RUBOUT CHARACTERS

	SETZM	LDBRBI(U)
	SKIPE	T2, LDBRBO(U)
	PUSHJ	P, FREUP
	SETZM	LDBRBO(U)	;CLEAN UP THE BUFFERLETS
	JUMPL	P1, FINLIN	;NO ROOM
	JRST	MORLIN		;MORE ROOM
;SEND OUTPUT CHARACTERS

PGOUT:
GOOUT:	SKIPN	LDBTOC(U)
	JRST	MORLIN
	TDZA	P1, P1		;P1 := -1 IF PRCOUT RUNS OUT OF ROOM
	JRST	CLNOC
CNTOUT:	MOVE	T2, LDBTOT(U)
	PUSHJ	P, TTGETC	;GET A CHAR. IF DONE WITH BUFFERLET,
	 PUSHJ	P, FRECHK	;  FREE IT
	MOVEM	T2, LDBTOT(U)
	PUSHJ	P, PRCOUT	;PRINT THE CHARACTER
	 JRST	[		;OUT OF ROOM
		ADDM T3, LDBTOT(U)
		JRST CLNOCP
	 ]
	SOSLE	T2, LDBTOC(U)	;IF THERE'RE MORE CHARACTERS,
	JRST	CNTOUT(P1)	;  CONTINUE IF THERE'S ROOM

    ;HERE WHEN THERE'RE NO MORE OUTPUT CHARACTERS

	PUSHJ	P, XMTWAK	;WAKE THE JOB UP
	HRRZ	T2, U
	CAMN	T2, OPRLDB	;IS THIS OPR?
	PUSHJ	P, OPRFRE	;RESTART WAITERS FOR SETUUO
	JUMPL	P1, FINLIN	;NO MORE ROOM
	JRST	MORLIN		;MORE ROOM

    ;HERE WHEN CHARACTER OUTPUT RUNS OUT OF ROOM TO DECIDE
    ;WHETHER TO WAKE THE JOB UP NOW

CLNOCP:	MOVE	T2, LDBTOC(U)
CLNOC:	SKIPGE	LDBDCX(U)	;IF IT'S A FAST LINE,
	CAML	T2, OWK120	;AND UNDER THE FAST MINIMUM,
	CAMGE	T2, OWK30	;OR IF IT'S UNDER THE SLOW MINIMUM,
	PUSHJ	P, XMTWAK	;  WAKE THE JOB UP
	JRST	FULLIN
SUBTTL ECHO LOGIC

;YELLOW BALL

GOSYL:	PUSHJ P,CLSCHR		;LEAVE CHARACTER MODE
	 JRST FULLIN		;NO ROOM
	MOVSI T1,L2LOWT
	IORM T1,LDBBYT(U)	;SAY WE'RE WAITING
	MOVSI T1,L2LOWS
	ANDCAM T1,LDBBYT(U)	;AND THAT WE HAVEN'T SEEN ONE
	MOVSI P3,TYPI TYPYEL
	JRST FMTB1

;GREEN (GOGBF) AND ORANGE (GOSOG) BALLS

GOGBF:	MOVSI	P3, TYPI TYPGRN
	SKIPA
GOSOG:	MOVSI	P3, TYPI TYPORG
	MOVSI	T2, L2LDEL
	TDNN	T2, LDBBYT(U)	;IF WE'RE IN \...
	PUSHJ	P, WTCHK	;OR IF WE'RE NOT IN INPUT WAIT,
	JRST	WATLIN		;  WAIT
	JRST	FMTB		;GO SEND IT

;WTCHK -- SKIP IF TTY IN INPUT WAIT

WTCHK:	TLNE U,LDLCOM
	  JRST	CMDCKW##	;SPECIAL CHECK IF AT COMMAND LEVEL
;	HRRZ T1,LDBBIO(U)
;	JUMPN T1,CPOPJ
	MOVSI F,L2LLDF
	TDNE F,LDBBYT(U)	;IF LEAVE DEF ECHO BIT ON
	JRST CPOPJ1		;ALWAYS GET OUT
	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ1	;NO JOB, TAKE A CHANCE
	MOVE S,DEVIOS(F)
	TRNE S,IOACT
	TLNE S,TTYOUW
	POPJ P,	;NOT IN WAIT OR IN OUTPUT WAIT
	JRST CPOPJ1

;ECHO CHARACTER OUTPUT

PGECO:
GOECO:	SKIPN	LDBECC(U)
	JRST	MORLIN	;NO CHARACTERS
	PUSHJ P,WTCHK	;IF WE AREN'T IN INPUT WAIT,
	JRST	[Jumpl	U,Golin3	;Don't wake if backpressured
		 JRST WATLIN]		;  WAIT UNTIL WE ARE
	TDZA P1,P1	;THIS USED THE SAME TRICK AS OUTPUT
	JRST FULLIN	;WILL GET HERE WHEN OUT OF ROOM
CNTECO:	MOVE T2,LDBECT(U)
	PUSHJ P,TTGETC
	 JFCL		;DON'T CARE ABOUT BOUNDARIES
	MOVEM T2,LDBECT(U)
	TRNE T3,400
	JRST [MOVEI T1,5	;SET MODE 5 FOR IMAGE CHR
		JRST ECHRPT]
	TRNE T3,200
	SKIPA P3,CHRTAB-200(T3)
	MOVE P3,CHRTAB(T3)
	LDB T1,CHPECH	;GET ECHO TYPE
ECHRPT:	LDB T2,LDPMEC	;AND LINE MODE
	XCT ECHTAB(T1)	;USUALLY LOADS T1 WITH ADDRESS
	JRST (T1)	;GO THERE

;HERE WHEN THERE'S NOT ENOUGH OUTPUT RING SPACE: BACK UP
;THE ECHO POINTER AND REPORT NON-COMPLETION TO THE DISPATCHER

ECHBAK:	ADDM T3,LDBECT(U)	;BACK UP POINTER
	JRST FULLIN

;HERE TO SEE IF THERE ARE MORE CHARACTERS TO BE ECHOED

ECHLST:	SOSLE LDBECC(U)	;IF THERE ARE MORE TO ECHO,
	JRST CNTECO(P1)	;  CONTINUE
	JUMPL P1,FINLIN	;OTHERWISE, IF THERE'S OUTPUT RING SPACE,
	PUSHJ P,BPXOFF	;  CLEAR BACKPRESSURE (WHY NOW?)
	JRST MORLIN	;  AND RETURN TO OUTPUT DISPATCH
;ECHO DISPATCH TABLES

ECHTAB:	JRST ECHSPA		; 0->SPECIAL ACTION
	HLRZ T1,ECHT12(T2)	; 1->NONBREAK: PRINT & COUNT
	HRRZ T1,ECHT12(T2)	; 2->BREAK: NO PRINT, NO COUNT
	HLRZ T1,ECHT34(T2)	; 3->BREAK: PRINT, NO COUNT
	HRRZ T1,ECHT34(T2)	; 4->BREAK2: PRINT & COUNT
	HLRZ T1,ECHT56(T2)	; 5->IMAGE MODE CHARACTER
	HRRZ T1,ECHT56(T2)	; 6->BREAK: PRINT & COUNT
	HRRZ T1,ECHT7(T2)	; 7->BREAK2: NO PRINT, NO COUNT

ECHT12:	EACT1,,EACT2	; 0 -> COMMAND MODE
	EACT6,,EACT12	; 1 -> BREAK-ON-ALL
	EACT10,,EACT12	; 2 -> BREAK NORMALLY
	EACT10,,EACT12	; 3 -> BREAK-ON-PUNCTUATION

ECHT34:	EACT3,,EACT4
	EACT13,,EACT14
	EACT13,,EACT15
	EACT13,,EACT14

ECHT56:	EACT5,,EACT16
	EACT7,,EACT17
	EACT11,,EACT17
	EACT11,,EACT17

ECHT7:	EAC4A
	EAC14A
	EAC15A
	EAC14A
;COMMAND MODE

;NONBREAK: PRINT & COUNT

EACT1:	PUSHJ P,EPCOUT	;DO THE NORMAL OUTPUT THING
	 JRST ECHBAK	;MUST BACK UP
EACT1B:	AOS T4,LDBTIC(U)
	CAIGE T4,TIWKC	;ENOUGH TO WAKE UP
	JRST ECHLST	;NO, CHECK MORE CHRS
EACT1A:	PUSHJ P,CMDWAK	;WAKE COMMAND
	SOS LDBECC(U)	;DECREASE COUNT
	JRST WATLIN	;NO MORE ECHO UNTIL WE'RE IN WAIT AGAIN

;BREAK: PRINT & COUNT

EACT16:	PUSHJ P,EPCOUT
	 JRST ECHBAK

;BREAK: NO PRINT, NO COUNT

EACT2:	HRROI T1,1	;-1 FOR LEFT HALF 1 FOR RIGHT HALF
	ADDM T1,LDBBKC(U)
	AOS LDBTIC(U)
	JRST EACT1A	;GO WAKE UP

;BREAK: PRINT, NO COUNT

EACT3:	PUSHJ	P,E1IDPB	;OUTPUT IF NOT BACKPRESSURED
	JRST EACT2

;(EACT4)  BREAK2: PRINT & COUNT
;(EACT4A) BREAK2: NO PRINT, NO COUNT

EACT4:	PUSHJ P,EPCOUT
	 JRST ECHBAK
EAC4A:	HRROI T1,1
	ADDM T1,LDBBK2(U)
	JRST EACT1B

;IMAGE

EACT5:	PUSHJ	P,E2IDPB	;OUTPUT IF NOT BACKPRESSURED
	MOVNI P1,1	;OUT OF ROOM
	JRST EACT1B
;NONBREAK: PRINT & COUNT; NORMAL OR BREAK2 MODE

EACT10:	TLNE U,LDLNEC		;WORRY ABOUT ECHO
	JRST EAC10A		;NO ECHO
	PUSHJ P,EPCOUT
	 JRST ECHBAK
EAC10A:	AOS T4,LDBTIC(U)
	CAIG T4,TIWKC
	JRST ECHLST	;DO NOT WAKE UP
EAC10B:	PUSHJ P,USRWAK
	SOS LDBECC(U)
	JRST WATLIN	;NO MORE ECHO UNTIL WE'RE IN WAIT AGAIN

;NONBREAK: PRINT & COUNT; BREAK-ON-ALL MODE

EACT6:	TLNE U,LDLNEC
	JRST EACT6A
	PUSHJ P,EPCOUT
	 JRST ECHBAK
EACT6A:	AOS LDBTIC(U)
	JRST EAC10B

;IMAGE; NORMAL OR BREAK2 MODE

EACT11:	TLNE U,LDLNEC
	JRST EAC11A
	PUSHJ	P,E2IDPB	;OUTPUT IF NOT BACKPRESSURED
	MOVNI P1,1
EAC11A:	LDB T1,LDPIMB
	CAME T1,T3
	JRST EAC10A	;WAK IF COUNT BIG ENOUGH
	JRST EACT6A	;SPECIAL BREAK, WAKE

;IMAGE; BREAK-ON-ALL MODE

EACT7:	TLNE U,LDLNEC
	JRST EACT6A
	PUSHJ	P,E1IDPB	;OUTPUT IF NOT BACKPRESSURED
	JRST EACT6A
;BREAK: PRINT & COUNT; NOT COMMAND MODE

EACT17:	TLNE U,LDLNEC
	JRST EACT12	;DO NOT ECHO
	PUSHJ P,EPCOUT
	 JRST ECHBAK

;BREAK: NO PRINT, NO COUNT; NOT COMMAND MODE

EACT12:	HRROI T1,1
	ADDM T1,LDBBKC(U)
	JRST EACT6A

;BREAK: PRINT, NO COUNT; NOT COMMAND MODE

EACT13:	TLNE U,LDLNEC
	JRST EACT12
	PUSHJ	P,E1IDPB	;OUTPUT IF NOT BACKPRESSURED
	JRST EACT12

;(EACT14)  BREAK2: PRINT & COUNT; BREAK-ON-ALL OR BREAK2 MODE
;(EACT14A) BREAK2: NO PRINT, NO COUNT; BREAK-ON-ALL OR BREAK2 MODE

EACT14:	TLNE U,LDLNEC
	JRST EAC14A
	PUSHJ P,EPCOUT
	 JRST ECHBAK
EAC14A:	HRROI T1,1
	ADDM T1,LDBBK2(U)
	JRST EACT6A

;(EACT15)  BREAK2: PRINT & COUNT; NORMAL MODE
;(EACT15A) BREAK2: NO PRINT, NO COUNT; NORMAL MODE

EACT15:	TLNE U,LDLNEC
	JRST EAC15A
	PUSHJ P,EPCOUT
	JRST ECHBAK
EAC15A:	HRROI T1,1
	ADDM T1,LDBBK2(U)
	JRST EAC10A
;SPECIAL ACTION

ECHSPA:	LDB T1,LDPMOD
	LDB T2,CHPSPE
	XCT @ECHSPT(T1)

ECHSPT:	XCT SPEPDP(T2)
	XCT SPE940(T2)
	XCT SPE940(T2)
	XCT SPEPDP(T2)

SPEPDP:	JRST SPEUXC	;ECHO ^X RETURN (^C)
	JRST SPECR	;RETURN
	JRST SPEUX	;ECHO ^X (^U)
	JRST SPETAB	;TAB
	JRST SPEALT	;33
	JRST SPEVM	;V. TAB
	JRST SPEVM	;FF
	JRST SPEUXC	;ECHO ^X RETURN (^Z)
	JRST SPEALP	;175-176
	JRST SPEBS	;BACKSPACE

SPE940:	JRST SPEBRK	;TYPE 2
	JRST SPECR	;RETURN
	JRST SPEBRK
	JRST SPETAB	;TAB
	JRST SPEBRK	;33
	JRST SPEVM	;V. TAB
	JRST SPEVM	;FF
	JRST SPEBRK	;TYPE 2
	JRST SPEAP1	;175-176
	JRST SPEBS	;BACKSPACE
;TREAT AS NONBREAK: PRINT & COUNT

SPECR:	MOVEI T1,1
	JRST ECHRPT	;JUST TURN INTO TYPE 1

;TREAT AS BREAK: NO PRINT, NO COUNT

SPEBRK:	MOVEI T1,2
	JRST ECHRPT	;TYPE 2

;TREAT AS BREAK: PRINT, NO COUNT

SPEBK3:	MOVEI T1,3
	JRST ECHRPT	;TYPE 3

;TREAT AS BREAK: PRINT & COUNT

SPEBK6:	MOVEI T1,6
	JRST ECHRPT	;TYPE 6

;RIGHT BRACE OR TILDE IN 940 MODE

SPEAP1:	TLNN U,LDLLCT	;175-176
	JRST SPEBK6	;TTY LC, BREAK: PRINT & COUNT
	JRST SPEBRK	;TTY NO LC, BREAK: NO PRINT, NO COUNT

;RIGHT BRACE OR TILDE IN PDP10 MODE

SPEALP:	TLNN U,LDLLCT
	JRST SPEBK6	;TTY LC, BREAK: PRINT & COUNT
	;JRST SPEALT	;TTY NO LC, EQUIVALENT TO ESC

;ESCAPE IN PDP10 MODE

SPEALT:	MOVSI T3,LXLDLR
	TDNE T3,LDBDCX(U) ;IF USER SUPPRESSING $ ECHO
	TLNE U,LDLCOM	;OR WE'RE AT COMMAND LEVEL
	SKIPA		;ECHO A $
	JRST SPEBRK
	MOVEI T3,"$"
	JRST SPEBK6	;YES, SAY IT WAS A $
;HORIZONTAL TAB

SPETAB:	MOVE	T1, LDBBYT(U)
	TLNE	T1, L2LNTB	; NO ECHO?
	JRST	SPETB1
	TLNE	T1, L2LTBK	; BREAK ?
	JRST	SPEBK6		; BREAK & ECHO
	MOVEI	T1, 4
	JRST	ECHRPT		; BREAK2 & ECHO

SPETB1:	TLNE	T1, L2LTBK	; BREAK ?
	JRST	SPEBRK		; BREAK & NO ECHO
	MOVEI	T1, 7
	JRST	ECHRPT		; BREAK2 & NO ECHO

;VERTICAL TAB OR FORMFEED

SPEVM:	MOVSI	T1, L2LNTB
	TDNN	T1, LDBBYT(U)	; ECHO?
	JRST	SPEBK6		; YES
	JRST	SPEBRK		; NO

;BACKSPACE

SPEBS:	MOVE	T1,LDBBYT(U)
	LDB	T2,LDPECH	;REMOTE BS ECHO SET
	JUMPE	T2,SPEBS1	;NO, DON'T ECHO
	TLNN	T1,L2LBBP	;BREAK
	JRST	SPEBK6		;BREAK & ECHO
	MOVEI	T1,4
	JRST	ECHRPT		;BREAK2 & ECHO

SPEBS1:	TLNN	T1,L2LBBP	;BREAK
	JRST	SPEBRK		;BREAK & NO ECHO
	MOVEI	T1,7
	JRST	ECHRPT		;BREAK2 & NO ECHO
;ECHO <CONTROL CHAR> AS ^<CONTROL CHAR + 100>

SPEUX:	TLNN U,LDLCOM
	TLNN U,LDLNEC	;ALWAYS DO IT IN COMMAND MODE
	SKIPA
	JRST SPEBRK	;OTHERWISE NOT IF NO ECHO
	PUSHJ P,SPEUCM	;COMMON ^X ECHO CODE
	 JRST ECHBAK
	JRST SPEBRK

;ECHO <CONTROL CHAR> AS ^<CONTROL CHAR + 100><CR><LF>

SPEUXC:	TLNN U,LDLCOM	;SAME AS SPEUX BUT ADD RETURN
	TLNN U,LDLNEC
	SKIPA
	JRST SPEBRK
	PUSHJ P,SPEUCM	;ECHO THE ^X
	 JRST ECHBAK	;DID NOT MAKE IT
	MOVE T4,CRPTR	;GET READY FOR THE RETURN LF
	JUMPL P1,SPEUX1	;OUT OF ROOM, MUST USE RUBOUT STRING
	MOVEI T3,0
	DPB T3,LDPPOS	;RESET POSITION
	PUSHJ P,SPOFIL
	 JRST SPEBRK	;HAVE PUT OUT THE CRLF (OR TO FILLER)
	JRST SPEBRK	;SAME

SPEUX1:	PUSHJ P,RUBSTR
	JRST SPEBRK

;COMMON CODE FOR SPEUX AND SPEUXC

SPEUCM:	JUMPL	U,EPCOU1	;CAN'T OUTPUT NOW
	LDB T4,LDPPOS
	ADDI T4,2	;MAKE SURE BOTH FIT ON SAME LINE
	MOVEI T3,"^"	;THE ^
	PUSHJ P,PRCCR	;THIS WILL PUT IN A CRLF IF NEEDED
	 POPJ P,	;^ NOT SENT, OUT OF ROOM, BACK UP
	CAIN T4,1	;^ SEND, T4 IS LDPPOS, IF 1 CRLF SENT
	AOJA T4,[DPB T4,LDPPOS	;MUST SET TO 2
		JRST .+1]
	LDB T3,LDBECT(U)	;GET BACK CHARACTER
	TRO T3,100
	JUMPL P1,SPEUC1	;ALREADY OUT OF ROOM, INTO RUBOUT STRING
	PUSHJ	P,E2IDPB	;OUTPUT IF NOT BACKPRESSURED
	MOVNI P1,1
	JRST CPOPJ1	;FINISHED

SPEUC1:	PUSHJ P,ENTRUB
	MOVEI T1,1
	DPB T1,LOPRUB	;SET TO SEND RUBOUT STRING
	JRST CPOPJ1	;P1 IS NEG SO WILL FINISH
;DON'T ECHO IF PORT BACKPRESSURED

EPCOUT:	JUMPGE	U,PRCOUT	;DO OUTPUT IF NOT BACKPRESSURED
EPCOU1:	POP	P,T1		;FLUSH RETURN ADDR
	SETZ	T1,
	DPB	T1,LDBOPB(U)	;TURN OFF NEED OUTPUT
	MOVSI	T3,110000
	ADDM	T3,LDBECT(U)	;BACK UP BYTE POINTER
	JRST	FULLIN		;GO ON TO NEXT LINE

E1IDPB:	JUMPL	U,EPCOU1	;CAN'T ECHO NOW
	UUIDPB	T3,CHRWRP(W)
	SOSLE	MULCNT(W)
	SOS	CHCNT
	POPJ	P,

E2IDPB:	JUMPL	U,EPCOU1	;CAN'T ECHO NOW
	UUIDPB	T3,CHRWRP(W)
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	POPJ	P,
	JRST	CPOPJ1
SUBTTL OUTPUT FILLER LOGIC

;SEND FILLER CHARACTERS

PGFIL:
GOFIL:	ILDB	T3, LDBFLP(U)	;T3/ NEXT CHAR, OR 0 IF LDBFLP=0
	JUMPE	T3, [		;IF NO (MORE) CHARACTERS,
		SETZM	LDBFLP(U)	;CLEAR THE POINTER
		JRST	MORLIN
	]
	TRZ	T3, 200		;WHAT IS THIS FOR???
	UUIDPB	T3, CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	JRST	FULLIN		;NO MORE ROOM
	JRST	GOFIL		;BACK FOR MORE
;PRCOUT -- CALLED WITH T3/ THE CHARACTER TO PRINT,
;	   PRINTS THE CHARACTER (MAPPING UPPER CASE TO LOWER
;	   CASE IF SO ENABLED), INSERTS FREE CRLFS AND
;	   HT/VT/FF PADDING/SIMULATION CHARACTERS IF NECESSARY.
;	   IF IT CAN'T PRINT THE CHARACTER, IT NONSKIP-RETURNS
;	   WITH T3/ 110000,,0 (WITH WHICH THE CALLER CAN BACK UP
;	   A BYTE POINTER). OTHERWISE, IT SKIP-RETURNS. IT MAY
;	   SET THE NEED-FILLER BIT, AND IT WILL SET P1 = -1 IF
;	   THERE'S NO CHARACTER SPACE LEFT.

PRCOUT:	TRNN	T3, 400		;IF IT'S AN IMAGE CHARACTER
	TLNE	U, LDLSOX	;OR SUPPRESSING OUTPUT TRANSLATION,
	JRST	PRCOT3		;  JUST SEND IT
	TRNE	T3, 200
	SKIPA	P3, CHRTAB-200(T3)
	MOVE	P3, CHRTAB(T3)	;P3/ CHARACTER-TYPE BITS
	LDB	T1, CHPOUT	;T1/ CHARACTER PRINT MODE
	XCT	[
		JRST PROACT	;0 SPECIAL ACTION
		LDB T4, LDPPOS	;1 PRINT AND COUNT 1 CHARACTER-WIDTH
		JRST PRCOT3	;2 PRINT BUT DON'T COUNT
		JRST PROUCC	;3 UPPER CASE ACTION
	](T1)

    ;HERE ON 1-CHARACTER-WIDE CHARACTERS

PRCOCW:	AOJ	T4,	;T4/ POSITION ON LINE

    ;HERE WITH T4/ POSITION, FROM ABOVE AND FROM ECHO CODE,
    ;TO PRINT A FREE CR IF ONE IS NEEDED, THEN THE CHAR IN T3

PRCCR:	LDB	T1, LDPWID	;T1/ LINE WIDTH
	CAMLE	T4, T1		;IF THE LINE ISN'T FULL
	TLNE	U, LDLNFC!LDLSOX;OR THE USER DOESN'T WANT FREE CRLFS
	JRST	PRCOT1		;  JUST PRINT THE CHARACTER
    ;HERE TO PRINT A CRLF

	MOVE	T4, CRPTR
PRCFIL:	ILDB	T2, T4		;T2/ NEXT CHARACTER
	JUMPE	T2, [		;IF WE'RE DONE,
		MOVEI	T4, 1		;LINE POSITION WILL BE 1
		JRST	PRCOT2		;GO PRINT THE CHARACTER
	]
	UUIDPB	T2, CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	JRST	.+2		;(NO MORE ROOM)
	JRST	PRCFIL		;BACK FOR MORE
	MOVE	T3, T4
	ILDB	T3, T3		;T3/ THE NEXT CHAR
	JUMPE	T3, PRCFL1	;IF IT WASN'T THE TERMINATING NUL,
	MOVEM	T4, LDBFLP(U)	;  SET THE REST AS FILLER
	MOVEI	T4, 1
	DPB	T4, LOPFIL	;  SET THE NEED-FILLER BIT
PRCFL1:	MOVSI	T3, 110000	;(MAGIC SO CALLER CAN BACKUP BYTE PTR)
	DPB	T3, LDPPOS	;LINE POSITION := 0
	POPJ	P,

PRCOT1:	CAIG	T4, 377
PRCOT2:	DPB	T4, LDPPOS
PRCOT3:	UUIDPB	T3, CHRWRP(W)
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	SETO	P1,
	JRST	CPOPJ1
;HERE ON SPECIAL-ACTION CHARACTERS

PROACT:	LDB T2,CHPSPO
	XCT SPOTBL(T2)	;DO CORRECT OUTPUT THING FOR CHR

SPOTBL:	JRST SPOCR	;RETURN
	JRST SPOTAB	;TAB
	JRST SPOVT	;VERTICAL TAB
	JRST SPOFF	;FORM FEED
	JRST SPOBS2	;BACKSPACE

;CARRIAGE RETURN

SPOCR:	MOVEI T4,0
	JRST PRCOT2	;OUTPUT BUT SET POS TO 0

;HORIZONTAL TAB

SPOTAB:	LDB T1,LDPPOS	;GET CURRENT POSITION
	TRO T1,7
	ADDI T1,1	;WHERE IT WILL BE
	LDB T4,LDPWID
	TLNN U,LDLNFC
	CAMGE T1,T4	;WILL WE OVERFLOW?
	JRST SPOTB0	;NO OR NO CR WANTED
	MOVEI T1,0
	DPB T1,LDPPOS	;SET TO 0 POSITION
	MOVE T4,CRPTR
	JRST SPOFIL

SPOTB0:	LDB T4,LDPPOS	;NO CR, GET CURRENT POSITION
	TRNN T1,400
	DPB T1,LDPPOS	;SAVE NEW
	TLNE U,LDLTAB
	JRST SPOTB1	;TTY DOES TABS, JUST FILL
	ANDI T4,7
	MOVE T4,TABPTR(T4)	;GET CORRECT NUMBER
	JRST SPOFIL	;AND SEND

SPOTB1:	LDB T1,LDPFC2
	TRNN T4,4
	SKIPA T4,TBFL2(T1)	;USE LONG FILL
	MOVE T4,TBFL(T1)	;OR SHORT FILL
	JRST SPOFL1
;FORM FEED

SPOFF:	TLNE U,LDLFRM	;IF TTY DOESN'T DO FORMS,
	JRST SPOFF1
	MOVE T4,FFFLP
	JRST SPOFIL	;  SEND LINEFEEDS
SPOFF1:	LDB T1,LDPFC1	;IF IT DOES,
	MOVE T4,FLLFFS(T1)
	JRST SPOFL1	;  SEND PAD CHARACTERS

;VERTICAL TAB

SPOVT:	TLNE U,LDLFRM	;IF TTY DOESN'T DO VERTICAL TABS,
	JRST SPOVT1
	MOVE T4,VTFLP
	JRST SPOFIL	;  SEND LINEFEEDS
SPOVT1:	LDB T1,LDPFC1	;IF IT DOES,
	MOVE T4,FLLVTS(T1)
	JRST SPOFL1	;  SEND PAD CHARACTERS

;BACKSPACE

SPOBS2:	PUSHJ	P, SPOBSP	;UPDATE CHAR COLUMN COUNTER
	JRST	PRCOT3

SPOBSP:	MOVSI	T1, L2LBSP	;IF NEITHER BS FOR CHAR DELETE
	TDNE	T1, LDBBYT(U)
	JRST	SPOBS1
	LDB	T1, LDPECH	;NOR REMOTE BS ECHO
	JUMPE	T1, CPOPJ	;THEN DON'T COUNT IT
SPOBS1:	LDB	T1, LDPPOS
	SOSL	T1
	DPB	T1, LDPPOS	;IF POS-1 >= 0, POS:=POS-1
	POPJ	P,

;SPOFIL -- CALLED WITH T4/ FILL POINTER. OUTPUT THE FILL CHARACTERS.
;	   IF THERE'S NOT ENOUGH OUTPUT RING SPACE, SET UP LDPFLP
;	   TO POINT TO WHAT'S LEFT, SET P1 = -1, AND LET GOFIL
;	   DO THE REST. SKIP-RETURNS ALWAYS.
;SPOFL1 -- OUTPUT THE CHAR IN T3, THEN THE T4 STRING

SPOFIL:	ILDB	T3, T4		;T3/ NEXT CHAR
	JUMPE	T3, CPOPJ1	;DONE
SPOFL1:	UUIDPB	T3, CHRWRP(W)	;DEPOSIT IT
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	JRST	.+2		;(NO ROOM)
	JRST	SPOFIL		;BACK FOR MORE
	SETO	P1,		;SET NO-MORE-ROOM FLAG
	MOVE	T3, T4
	ILDB	T3, T3		;T3/ NEXT CHAR
	JUMPE	T3, CPOPJ1	;IF IT WASN'T THE TERMINATING NUL,
	MOVEM	T4, LDBFLP(U)	;  SET THE REST AS FILLER
	MOVEI	T3, 1
	DPB	T3, LOPFIL	;  AND SET NEED-FILLER
	JRST	CPOPJ1
;FILLER	POINTERS AND VARIOUS ECHO POINTERS

CCPTR:	POINT 7,CCASC
CCASC:	ASCIZ /\^C
/

CRPTR:	POINT 7,CCASC,20	;JUST THE RETURN FROM ABOVE

CUPTR:	POINT 7,CUASC
CUASC:	ASCIZ /\^U
/

UPARPT:	POINT 7,UPASC
UPASC:	ASCIZ /\^
/

COPTR:	POINT 7,COASC
COASC:	ASCIZ /\^O
/

FLLBSC:	POINT 7,BSLASC
BSLASC:	ASCIZ /\
/

FFFLP:	POINT 7,FFLP0		;FILLER FOR SIMULATING FORM FEED
FFLP0:	BYTE (7) 12,12,12,12,12,12,12,12,0

VTFLP:	POINT 7,FFLP0,27	;FILLER FOR SIMULATING VERTICAL TAB

	DEFINE FILLP(N)
<IF1,<IFG N-FLMX,<FLMX==N>
	0>
IF2,< XXXQ==<FLMX-N>/5
XXXR==FLMX-N-<XXXQ*5>

IFE XXXR,<POINT 7,FILERS+XXXQ>
IFN XXXR,<POINT 7,FILERS+XXXQ,<7*XXXR>-1>>>

;THE ABOVE MACRO DEFINES POINTERS INTO A LIST OF FILLERS (377)
IF1,<FLMX==0>

FLLFFS:	0
	FILLP ^D12
	FILLP ^D15
	FILLP ^D40

FLLVTS:	0
	FILLP 6
	FILLP 5
	FILLP ^D20

TBFL:	0
	FILLP 1
	FILLP 3
	FILLP 3

TBFL2:	0
	FILLP 2
	FILLP 5
	FILLP 5

;NOW GENERATE FILLERS

	DEFINE GENFL(X)
<XXQ==X/5
	REPEAT XXQ,<BYTE (7) 177,177,177,177,177>
XXQ==X-<XXQ*5>
IFE XXQ,<0>
IFE XXQ-1,<BYTE (7) 177>
IFE XXQ-2,<BYTE (7) 177,177>
IFE XXQ-3,<BYTE (7) 177,177,177>
IFE XXQ-4,<BYTE (7) 177,177,177,177>
>

FILERS:	GENFL (FLMX)
TABPTR:	POINT 7,SSPT
	POINT 7,SSPT,6		;FILLERS TO SIMULATE TABS WITH SPACES
	POINT 7,SSPT,13
	POINT 7,SSPT,20
	POINT 7,SSPT,27
	POINT 7,SSPT+1
	POINT 7,SSPT+1,6
	POINT 7,SSPT+1,13

SSPT:	BYTE (7) 40,40,40,40,40,40,40,40,0

;HERE IF CHARACTER IS UPPER CASE

PROUCC:	HLRZ	T1,LDBDCX(U)	;GET LEFT HALF OF DEV CHR EXT WORD
	TRNE	T1,LXLLCO	;SKIP IF U TO L CASE CONV NOT DESIRED
	ADDI	T3,40		;CONVERT CHAR TO LOWER CASE
	LDB	T4,LDPPOS
	JRST	PRCOCW		;PRINT AND COUNT 1 CHARACTER-WIDTH

SUBTTL ONCE A SECOND LOGIC

;THIS ROUTINE IS CALLED EVERY SECOND TO WORRY ABOUT IMAGE MODE
;TIME OUTS AND TO MAKE SURE THAT SOMEONE WHO IS JUST WAITING
;FOR SOME SPACE TO FILL HIS OUTPUT BUFFER GETS RESTARTED

SCNSEC:
IFKMC<	MOVEI P4,MXLIN	;FOR EACH LINE
	AOS	DRMTIM	;INC MESSAGE TIMER
	SOSGE TIMMIN	;KMC MINUTE COUNTER
	JRST 	[MOVEI T1,^D60
		MOVEM T1,TIMMIN	;SET FOR ONE MINUTE
		PUSHJ P,SCNMIN	;CALLED EVERY MINUTE
		JRST .+1]
	SOSGE TIMDRD	;COUNTER FOR SERVICING DOWN DRs
	JRST 	[MOVEI T1,^D60
		MOVEM T1,TIMDRD	;SET FOR ONE MINUTE
		PUSHJ P,SCNDRD	;TIMING VARIES BUT IS USUALLY 60
		JRST .+1]
	>;END IFKMC
	MOVE	T1, PTYFLO
	MOVEM	T1, MULCNT+1	;LET PTYS OUTPUT SOME MORE
	SKIPLE	OPRTIM
	SOSLE	OPRTIM		;IF OPER TIMEOUT HAS GONE OFF,
	JRST	SCNSC1
	MOVEI	T1, ALROPR
	IORM	T1, ALR620	;  SET THE ALARM CELL
SCNSC1:	SOSL	TIMOW		;IF ORANGE-BALL-WAIT HAS GONE OFF,
	JRST	SCNSC2
	MOVEI	T1, OWTIM
	MOVEM	T1, TIMOW	;  RESET IT
SCNSC2:	MOVEI	P4, MXLIN	;(LOOP THROUGH ALL PORTS)

SECLOP:	MOVE	U, LINTAB(P4)
	HLL	U, LDBDCH(U)	;U/ DCH BITS,,LDB ADDR
	HRRZ	F, LDBDDB(U)	;F/ DDB ADDR
	MOVE	T1, LDBMOD(U)
	TLNE	T1, LMLBIO	;IF PORT'S IN BLOCK MODE,
	JRST	[
		PUSHJ	P, BIOCHG	;CHARGE FOR ELAPSED TIME
		MOVEI	T1, LDRBIP	;CHECK TIMEOUT IF PTY BLKI
		JRST	SECLP1
	]
	MOVSI	T1, LDLIMI	;ELSE CHECK TIMEOUT IF IN IMAGE STATE
SECLP1:	TDNN	T1, LDBDCH(U)	;IF WE DON'T CARE ABOUT TIMEOUTS,
	JRST	SECLP2		;  SKIP THIS STUFF
    ;CODE TO CHECK THE PER-PORT TIMEOUT FIELD

	LDB	T3, LDPTIM	;T3/ SECONDS REMAINING, OR 0
	SOSL	T3		;IF IT WASN'T 0,
	DPB	T3, LDPTIM	;  DECREMENT IT
	JUMPN	T3, SECLP2	;IF IT JUST RAN OUT,
	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;  IF PTY BLOCK INPUT IS IN PROGRESS,
	JRST	SECTM1
	PUSHJ	P, PBTIMO	;    TIME IT OUT
	JRST	SECLP2
SECTM1:	JUMPE	F, SECTM3	;  IF NO DDB, FORCE OUT OF IMAGE STATE
	LDB	T1, LDPIMB	;  T1/ 0, OR IMAGE BREAK CHAR
	JUMPN	T1, SECTM2	;  IF THERE'S NO BREAK CHAR,
	PUSHJ	P, IMGCHG	;    CHARGE FOR A WAKEUP
	PUSHJ	P, LINTRP	;    SIGNAL A BREAK
	PUSHJ	P, USRWAK	;    WAKE THE JOB
SECTM2:	TLNE	U, LDLAUX	;  IF IT'S NOT AN AUX CIRCUIT,
	JRST	SECLP2
	SKIPN	LDBTIC(U)
	SKIPE	LDBECC(U)	;    IF THERE'RE NO CHARACTERS,
	JRST	SECLP2
	MOVSI	S, IOEND
	IORB	S, DEVIOS(F)	;      SET EOF
	TRNE	S, 10
	TRNE	S, 7
	JRST	SECLP2		;      IF IMAGE MODE,
SECTM3:	MOVSI	T1, LDLIMI
	ANDCAM	T1, LDBDCH(U)	;        FORCE OUT OF IMAGE STATE
	PUSHJ	P, BPOFF	;        CLEAR BACKPRESSURE
	PUSHJ	P, SETLMD	;        FIX LINE MODE
    ;THE REST OF THE PER-PORT ONCE-A-SECOND CODE

SECLP2:	MOVSI	T1, L2LOWT
	SKIPN	TIMOW		;IF ORANGE-BALL-WAIT TIMER'S GONE OFF
	TDNN	T1, LDBBYT(U)	;AND PORT'S WAITING FOR ORANGE BALL,
	JRST	SECLP3
	MOVSI	T1, L2LOWS
	TDNN	T1, LDBBYT(U)	;  IF WE HAVEN'T BEEN HERE BEFORE,
	JRST	[
		IORM	T1, LDBBYT(U)	;SET THE ONCE-BEFORE FLAG
		JRST	SECLP3
	]
	PUSHJ	P, OBFND	;  IF WE HAVE, FAKE AN ORANGE BALL
SECLP3:	JUMPE	F, SECLP4	;IF THERE'S A DDB
	MOVSI	S, TWTSPC
	TDNN	S, DEVIOS(F)	;AND IT'S WAITING FOR BUFFERLETS
	JRST	SECLP4
	MOVE	T1, TTFREN
	CAIG	T1, TIRSVD	;AND THERE'RE ENOUGH NOW,
	JRST	SECLP4
	ANDCAM	S, DEVIOS(F)	;  CLEAR BUFFERLET-WAIT BIT
	PUSHJ	P, XMTWAK	;  AND AWAKEN JOB
SECLP4:	SOJG	P4, SECLOP	;(CONTINUE WITH NEXT PORT)
	POPJ	P,


BIOCHG:	JUMPE F,CPOPJ		;CHECK FOR DETACHED JOB.
	LDB T1,PJOBN		;PICK UP HIS JOB NUMBER.
	AOS JBTBET(T1)		;INCREMENT HIS ELAPSED BIO TIME.
	AOS JBTBET		;INCR TOTAL ELAPSED BIO TIME.
	POPJ P,			;AND RETURN.
SUBTTL MISC STUFF FOR INPUT AND OUTPUT
;SUBROUTINE TO WAKE UP JOB IF IT IS IN TTY INPUT WAIT. CALL WITH
;U SET UP. IT WILL SET F AND S AS NEEDED.

USRWAK:	HRRZ	T1, LDBBIO(U)	; DOING BLOCK INPUT ?
	JUMPE	T1, USRWK1	; NO
	SKIPGE	BIOCHR(T1)	; YES. REQUEST IN PROGRESS ?
	POPJ	P,		; YES. LEAVE IT ALONE.
BIOWAK:
IFCPU (KL),<
	TLNE	S,IO		;IF BLOCK INPUT,
	JRST	USRWK1		;(OUTPUT, FORGET IT)
	HRRZ	T1,LDBBIO(U)	;THEN MUST MAKE SURE EDGES OF DATA NOT IN CACHE
	JUMPE	T1,USRWK1
	ADDI	T1,BIODAT	;GET ADDRESS OF 1ST DATA WORD
	CSHREF			;TAKE THAT 4 WD CHUNK OUT OF THE CACHE
	HRRZ	T1,LDBBIO(U)	;GET ADDRESS AGAIN
	ADDI	T1,BIOCOR*4-1 ;ADDRESS OF LAST WORD
	CSHREF			;THAT TAKES CARE OF ADJACENT REFS DURING I/O
>;END IFCPU (KL)
USRWK1:	MOVSI T1,L2LLDF
	ANDCAM T1,LDBBYT(U)	;TURN OFF WHEN USER IS AWAKENED
	HRRZ F,LDBDDB(U)		;GET ADDRESS OF ATTACHED F
	JUMPE F,RCVWK1		;IF NONE,SKIP THIS CODE
	MOVE S,DEVIOS(F)		;GET STATUS OF TTY FROM F
	TRNE S,IOACT	;SINCE IOW MAY NOT BE SET YET
	TLNE S,TTYOUW			;YES. FOR INPUT WAIT?
	JRST RCVWK1			;NO. DONT WAKE JOB.
TIWAKE:	TLNN S,IOW	;IS IOW REALLY SET
	JRST TIWAKN	;NO
	MOVE S,[XWD IOW,IOACT]		;YES. CLEAR WAIT BITS
	ANDCAB S,DEVIOS(F)		;IN F FOR THIS JOB
	PUSH P,T1			;SAVE VOLATILE AC'S
	PUSH P,T2			; ..
	PUSHJ P,STTIOD			;SET JOB TO TS STATE
	POP P,T2			;RESTORE AC'S
	POP P,T1			; ..
RCVWK1:	POPJ P,0			;RETURN FROM RCVWAK

TIWAKN:	MOVEI S,IOACT
	ANDCAB S,DEVIOS(F)	;JUST RESET IOACT
	POPJ P,

FULLCQ:	MOVE T1,LDBDCH(U)
	TLNN T1,LDLCOM		;IF NOT CMND MODE
	TDNN T1,[LDLBKA,,LDRFCS];AND HE WANTS TO SEE EDIT CHARS,
	AOS (P)
	POPJ P,			;  NONSKIP-RETURN
;SUBROUTINE TO SEE IF A CONTROL C SHOULD BE ACTED ON OR STORED.
;NON-SKIP MEANS STORE IT.
;SKIP MEANS DO IT.

CNCCHK:	TLNE	U,LDLCOM	;SHOULD ^C BE RETURNED?
	  POPJ	P,0		;YES.
	PUSH	P,T1		;MAYBE NOT. SAVE TAC.
	HRRZ	F,LDBDDB(U)	;GET U'S JOB
	JUMPE	F,CNCCK1	;IF NO F ATTACHED, ASSUME SHOULD DO ^C
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	  JRST	TPOPJ		;THIS IS A SLAVED TTY
	LDB	T1,PJOBN	; ..
	MOVE	T1,JBTSTS(T1)	;GET JOB STATUS WORD
	TDNE	T1,[XWD JACCT,JACCT2] ;IS ^C LEGAL?
	  JRST	TPOPJ		;NO. GIVE IT TO CUSP
CNCCK1:	PUSHJ	P,CNCMOD	;FORCE U TO BE AT COMMAND LEVEL
	MOVEI	T1,CMFCHT##
	PUSHJ	P,TTFORC	;FORCE HALT COMMAND
	JRST	TPOPJ1		;RESTORE T1, SKIP RETURN

;THIS ROUTINE TRACES BACKWARDS DOWN A LINKED LIST TO THE START
;AND THEN ADDS THE WHOLE LIST TO THE FREE LIST. IT IS USED
;TO KEEP 'UNUSED' CHUNKS FROM SITTING AROUND COLLECTING DUST
;AND DECREASING THE AMMOUNT OF FREE STORAGE.

FREUP:	TRZ T2,3		;GET BASE ADDRESS
FREST:	HLRZ T1,(T2)		;LOOK FOR BACK LINKS
	JUMPE T1,STLST		;FOUND START
	MOVE T2,T1		;TRY SOME MORE
	JRST FREST

STLST:	MOVE T1,TTFREE
	EXCH T1,(T2)		;CHANGE EL POINTER
	HRRZM T2,TTFREE		;AND FREE POINTER
	AOS  TTFREN		;MARK ONE MORE FREE
	HRRZ T2,T1		;ANY MORE?
	JUMPN T2,STLST		;YES
	POPJ P,			;ALL DONE

XMTWAK:	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ		;NO JOB HOOKED TO IT
	MOVSI S,L2LOWT		;IF WAITING FOR ORANGE BALL
	TDNE S,LDBBYT(U)
	POPJ P,			;DON'T WAKE UP OUTPUT
	MOVE S,DEVIOS(F)
	TLNN S,TINFIO
	JRST XMTWK1
	LDB T1,DDPTTS	;NOW TRAP ON READY FOR MORE OUTPUT
	PUSH P,J
	PUSHJ P,TAKTRJ
	MOVSI S,TINFIO
	ANDCAB S,DEVIOS(F)
	MOVEI J,LXRIOS
	IORM J,LDBDCX(U)
	POP P,J
XMTWK1:	TRNE S,IOACT	;SINCE IOW MAY NOT BE SET YET
	TLNN S,TTYOUW
	POPJ P,			;NOT WAITING SO DONE
	PJRST TIWAKE		;WAKE HIM UP
SUBTTL CHUNK HANDLERS

;SUBROUTINE TO READ A CHARACTER FROM A TELETYPE BUFFER
;CALL WITH T2 CONTAINING A BYTE POINTER TO THE LIST
;THIS ROUTINE WILL IBP T2 WHICH MAY POINT IT INTO A LINK WORD
;ALSO WE MAY BE CALLED WITH THE POINTER DECREMENTED SO THAT
;IBP WILL POINT TO THE CURRENT CHUNKS LINK WORD
;THIS ROUTINE WILL CORRECTLY FOLLOW THE LINKS. THE ROUTINE
;WILL NORMALLY SKIP RETURN. THE NON-SKIP RETURN IS TAKEN IF
;IT WAS NECESSARY TO FOLLOW A LINK. IN THIS CASE, T1
;CONTAINS THE BASE ADDRESS OF THE NEW CHUNK.
;ON RETURN, T2 CONAINS THE BYTE POINTER TO THE CHARACTER
;JUST OBTAINED, AND T3 THE CHARACTER

TTGETC:	ILDB T3,T2	;IF WE GET INTO A LINK WORD, T3 WILL NOT
			;BE WHAT WE WANT BUT NOTHING WILL HAVE
			;BEEN CLOBBERED
	TRNE T2,3	;ALL LINK WORDS ARE IN WORDS AT AN ADDRESS
			;WHICH IS A MULTIPLE OF 4
	JRST CPOPJ1	;ALL OK, JUST RETURN
	HRRZ T1,-4(T2)	;THIS WILL BE THE FORWARD LINK TO NEXT CHUNK
	TLNN T2,770000	;IF WE ARE AT THE RIGHT END OF THE WORD
			;WE MUST HAVE BACKED UP
	HLRZ T1,(T2)	;SO GET BACK LINK (T2 POINTS TO FIRST WORD OF CHUNK)
	JUMPE T1,TTGC1		;NO LINK THERE
	HRR T2,T1	;NOW POINT TO CORRECT WORD
	TLNE T2,770000
	AOSA T2		;IF FORWARD, POINT TO FIRST CHR
	ADDI T2,3	;IF BACKWARD, TO LAST
	LDB T3,T2	;NOW GET THE CHARACTER
	POPJ P,		;AND RETURN SAYING PASSED A LINK

TTGC1:	TLNE T2,770000		;IS THIS A BACKUP
	STOPCD .		;NOT GOOD IF GOING FORWARD
	MOVEI T3,0		;GIVE BACK 0
	JRST CPOPJ1
;SUBROUTINE TO PLACE A CHARACTER IN A BUFFER.
;CHARACTER IS IN T3. T2 CONTAINS A BYTE POINTER TO LAST
;CHARACTER PLACED IN BUFFER. WE WANT TO DO AN IDPB T3,T2 BUT
;MUST WATCH FOR LINKS. WILL FOLLOW A FORWARD LIST IF IT
;EXISTS OR GET A NEW CHUNK IF NECESSARY

TTPUTC:	IBP T2		;MUST NOT IDPB SINCE MIGHT CLOBBER SOMETHING
	TRNE T2,3	;ARE WE IN A LINK?
	JRST TTPC1	;NO, ALL OK
	HRRZ T1,-4(T2)	;GET LINK
	TLNN T2,770000
	STOPCD	;SOMEONE CALLED US AFTER BACKING UP
	JUMPN T1,TTPC2	;HAVE A FORWARD LINK ALREADY
	SKIPG T1,TTFREE	;GET A NEW CHUNK
	STOPCD	;NONE THERE. SHOULD HAVE BEEN CHECKED
	PUSH P,P1	;GET A REGISTER TO WORK WITH
	HRRZ P1,(T1)
	HRRZM P1,TTFREE	;UPDATE FREE POINNTER
	SKIPE P1
	HRRZS (P1)	;MAKE SURE NO BACK LINE IF A CHUNK LEFT
	SOS TTFREN	;COUNT CHUNK TAKEN
	HRLZI P1,-4(T2)	;GET A BACK LINK
	MOVEM P1,(T1)	;TO PUT IN NEW CHUNK
	HRRM T1,-4(T2)	;AND PUT IN FORWARD LINK
	POP P,P1
TTPC2:	HRRI T2,1(T1)	;NOW RESET BYTE POINTER
TTPC1:	DPB T3,T2	;STORE AWAY CHARACTER
	POPJ P,		;ALL DONE
;ROUTINE TO FREE UP A CHUNK OF THE CHARACTER LIST BY LINKING IT
;ONTO THE FRONT OF THE FREE-LIST. ASSUMES THAT TTGETC HAS JUST BEEN
;CALLED SO T1 CONTAINS THE ADDRESS OF THE CHUNK AFTER THE ONE
;AFTER THE ONE TO REETURN TO THE FREE LIST

FRECHK:	PUSH P,T2
	HLRZ T2,(T1)	;RETRIEVE THE LINK TO THE ONE TO PUT BACK
	HRRZS (T1)	;NO BACK LINK IN THIS CHUNK NOW
	EXCH T2,TTFREE	;PUT OLD ON FREE LIST
	HRRZM T2,@TTFREE	;RELINK REST OF FREE LIST
	AOS TTFREN
	POP P,T2
	POPJ P,

;ROUTINE TO GET A FREE CHUNK FROM THE FREELIST. SETS UP
;A BYTE POINTER IN T2. CLOBBERS T1

GETCHK:	SKIPN T2,TTFREE
	STOPCD	;NONE THERE, SHOULD HAVE BEEN CHECKED
	HRRZ T1,(T2)	;THE NEXT ELEMENT
	MOVEM T1,TTFREE	;RESET FREE LIST
	SETZM (T2)	;NO LINKS IN THIS ONE
	HRLI T2,(POINT 9,0,35)	;POINT SO THAT IBP POINT TO 1ST CHR
	SOS TTFREN	;ONE LESS
	POPJ P,
;TSETBI -- CLEAR INPUT BUFFER

TSETBI:	MOVSI T1,LLLZAP
	TDNE T1,LDBLOG(U)	;DO NOT ZAP IF TRYING TO GET RID OF HIM
	POPJ P,
	SKIPE T2,LDBTIP(U)	;CLEAR THIS LIST
	PUSHJ P,FREUP		;BUT ONLY IF ONE IS THERE
	SKIPE T2,LDBRBI(U)	;AND THIS ONE TOO
	PUSHJ P,FREUP
	SETZM LDBTIP(U)
	SETZM LDBTIT(U)
	SETZM LDBTIC(U)
	SETZM LDBBKC(U)
	SETZM LDBBK2(U)
	SETZM LDBBKI(U)
	SETZM LDBBKP(U)
	SETZM LDBECT(U)
	SETZM LDBECC(U)
	SETZM LDBRBC(U)
	SETZM LDBRBO(U)
	SETZM LDBRBI(U)
	MOVSI T2,LDLECS
	ANDCAM T2,LDBDCH(U)	;MUST CLEAR COMMAND SYNC BIT
	HLL U,LDBDCH(U)		;LET PEOPLE KNOW ABOUT IT
	MOVSI T2,L2LDEL!L2LCCS
	ANDCAM T2,LDBBYT(U)
	PJRST BPXOFF		;GET OUT OF BACKPRESSURE OR XOFF

;TSETBO -- CLEAR OUTPUT BUFFER

TSETBO:	SKIPN T2,LDBTOP(U)
	JRST TSTBO1
	TRNN T2,777776		;TO CATCH SPECIAL CASE OF SPARE LINE
	POPJ P,
	PUSHJ P,FREUP
TSTBO1:	SETZM LDBTOP(U)
	SETZM LDBTOC(U)
	SETZM LDBTOT(U)
	SETZM LDBFLP(U)		;AND FILLERS CURRENTLY GOING
	HRRZ T1,U
	CAMN T1,OPRLDB		;IS THIS OPR
	PUSHJ P,OPRFRE		;YES, MAY NEED TO RESTART JOBS
	MOVSI T1,L2LOWT
	MOVEI T2,1
	TDNN T1,LDBBYT(U)	;IF WE'RE WAITING FOR AN ORANGE BALL,
	JRST TSTBO2
	ANDCAM T1,LDBBYT(U)	;  STOP WAITING
	DPB T2,LOPSYL		;  SEND YELLOW BALL
TSTBO2:	DPB T2,LOPCGB		;SEND GOBBLER
	MOVSI T1,LDLNOP		;SEND EVEN IF SAYS SHOULD NOT
	ANDCAM T1,LDBDCH(U)
	DPB T2,LDBOPB(U)
	POPJ P,
SUBTTL BUFFERED I/O UUO-LEVEL ROUTINES

;DISPATCH TABLE FOR M'S AND INITIALIZATION

SCNDSP:	PHASE 0
DDXZ:	DSPSIZ
DDINT:	POPJ P,
DBYT:	1000,,1000
DVSIZ:	MOVEI T1,SCNDDS
DINI:	JRST TTYINI
DHNG:	JRST CPOPJ1
DRL:	POPJ P,
DCL:	JRST OUT
DOU:	JRST TTYOUT
DIN:	JRST TTYIN
DZAP:	JRST AUXZAP
	DSPSIZ==.-1
	DEPHASE
;INPUT UUO PROCESSOR - CALLED FROM UUOCON ON INPUT M, F SET UP

TTYIN:	PUSHJ P,CKATTI			;MAKE SURE ATTACHED. SET S.
	 JRST ABTUUO		;WAITING FOR AN INTERRUPT. ABORT
	JUMPE U,[MOVSI S,IOEND
		JRST TTYINX]	;ZAPPED AUX CIRCUIT GIVE EOF
	NOCHARGE
	PUSHJ	P, FIXIMI	;SET IMAGE STATE FROM DATA MODE
	PUSHJ P,TWAITL			;BECOME ATTACHED, WAIT FOR U
					; OR FULL BUFFER CONDITION
	TLNN U,LDLIMI		;IMAGE HAS ALREADY CHARGED
	PUSHJ P,SETBRK		;CHARGE FOR A BREAK CHR
TTYIN5:	HRRZ T1,DEVIAD(F)		;PREPARE AND ADDR CHECK THE
	PUSHJ P,BUFCLR			; USER'S BUFFER
	  JRST ADRERR			;OUT OF BOUNDS. STOP JOB.
	HRRZ P1,DEVIAD(F)		;PREPARE BYTE POINTER TO STORE
					; THE CHARACTERS IN HIS BUFFER
	XCTFU <LDB P2,[POINT 17,(P1),17]>	;BUFFER SIZE IN WORDS
	SUBI P2,1			;MINUS LINK
	HRRZ U,DDBLDB(F)		;RESTORE U, CLOBBERED IN UUOCON
	HLL U,LDBDCH(U)	;ALSO GET BITS
	HRRZ T1,DEVBUF(F)	;BUFFER POINTER FOR SIZE
	PUSHJ P,TTYSZS			;SET SIZES
					;FALL INTO MAIN PART OF ROUTINE
TTYIN1:	PUSHJ P,TYI			;GET A CHARACTER
	  JRST TTYIN3			; END OF BUFFER.
	ANDI T3,377
	XCTFU <IDPB T3,P1>			;AND STORE IN USER AREA
	CAIE T2,%CHBRK		;A BREAK?
	SOJG P2,TTYIN1			;NO. LOOP FOR MORE, IF ROOM.
TTYIN3:	MOVE P2,DEVIAD(F)		;COMPUTE WORD COUNT FOR UUOCON
	SUBI P1,1(P2)			; TO PUT IN BUFFER HEADER.
	XCTFU <HRRM P1,1(P2)>			;STORE WITH THE DATA IN RING
	PUSHJ P,ADVBFF			;ON TO NEXT BUFFER
	SKIPA				;NO MORE THERE.
	JRST TTYIN6			;MORE TO GO. USE IF IMAGE.
TTYIN8:	MOVSI S,IOFST			;SET VIRGIN BUFFER BIT
TTYINX:	IORB S,DEVIOS(F)		;IN DEV S WORD IN F
	PJRST NOCTRO			;CLEAR CONTROL O. END OF M

TTYIN6:	TRNE S,I			;IMAGE MODE?
	SKIPG LDBTIC(U)		;AND MORE CHARACTERS TO READ?
	JRST TTYIN8			;NO. QUIT.
	JRST TTYIN5			;YES. GO PASS SOME MORE

SETBRK:	TLNE U,LDLIMI
	POPJ P,			;IMAGE IS ALREADY CHARGED FOR
	LDB J,PJOBN
	PUSHJ	P,GTCGSZ	;GET THE JOB'S CHARGING SIZE.
	ADDM T1,JBTBCS(J)	;ONE BREAK CHR
	ADDM T1,JBTBCS
	POPJ P,

IMGCNT:	LDB T1,LDPIMB	;GET IMAGE BREAK CHR
	CAMN T1,T3	;IS IT THIS ONE?
	JRST IMGCH1	;YES, GO CHARGE
	LDB T1,LDPCHG
	ADDI T1,1
	CAIL T1,TIWKC	;ENOUGH GONE BY TO CHARGE?
	JRST IMGCHG	;YES
	DPB T1,LDPCHG	;NO, JUST RECORD
	POPJ P,

IMGCH1:	MOVEI T4,TIWKC	;SO CALLER WILL THINK MANY CHRS
IMGCHG:	MOVEI T1,0
	DPB T1,LDPCHG	;SET CHARGE COUNTER TO 0
	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ	;NO LINE
	JRST SETBRK	;GO CHARGE FOR 1 BCS

TTYSZS:	XCTBU <LDB T2,[POINT 6,1(T1),11]>	;GET POINTER SIZE
	DPB T2,[POINT 6,P1,11]	;SET IN P1 POINTER
	MOVEI T1,^D36
	IDIV T1,T2		;NUMBER OF CHRS/WORD
	IMUL P2,T1		;NUMBER OF CHRS IN BUFFER
	AOJA P1,CPOPJ	;ADD 1 TO POINT TO FIRST DATA WORD
;OUTPUT UUO
;CALLED ON OUTPUT OR OUTPUT CLOSE, FROM UUOCON, WITH F SET UP.

TTYOUT:	PUSHJ P,CKATTO		;FIRST, MAKE SURE THERE'S A LINE
	 JRST ABTUUO		;WAITING FOR AN INTERRUPT
	JUMPE U,TTYOUS		;ZAPPED AUX CIRCUIT
	PUSHJ P,CHKROM		;MAKE SURE ROOM FOR THIS CHR
	JRST TTYOUT		;NO ROOM.
	NOCHARGE
	PUSHJ P,CLRIMI		;CLEAR IMAGE INPUT STATE
	MOVSI S,IOBEG		;IS THIS THE FIRST BUFFER AFTER INIT?
	MOVSI T1,LDLOSU		;IF SO, WILL KILL ^O ACTION
	TDNN S,DEVIOS(F)	;CHECK F
	JRST TTOUT1		;NO.
	ANDCAM S,DEVIOS(F)	;YES. CLEAR BEG BIT,
	ANDCAM T1,LDBDCH(U)	; AND CONTROL O BIT
TTOUT1:	TDNE T1,LDBDCH(U)	;IS CONTROL O ON NOW?
	JRST TTOUT5		;YES. SKIP THIS WHOLE BUFFER.
	MOVSI S,IO+IOFST	;MARK OUTPUT, AND FIRST OF BUFFER
	IORB S,DEVIOS(F)	;IN DEVICE DATA BLOCK
	HRRZ P1,DEVOAD(F)	;CHECK ADDRESSES OF OUTPUT BLOCK
	XCTFU <HRRZ P2,1(P1)>	;GET WORD COUNT
	HLRZ T1,DEVBUF(F)	;GET POINTER TO BUFFER HEADER
	PUSHJ P,TTYSZS
TTOUT2:	TRNE	P2, 777		;TIME TO LET SOMEONE ELSE RUN?
	JRST	TTOUT3		;NO
	PUSHJ	P, WSCHED	;YES -- RESCHEDULE
	HRRZ	U, DDBLDB(F)	;STILL ATTACHED?
	JUMPN	U, TTOUT3	;YES -- GO AHEAD
	PUSHJ	P, CKATTF	;NO -- WAIT FOR REATTACH
TTOUT3:	XCTFU <ILDB T3,P1>	;GET A USER'S CHARACTER
	TRNE S,I		;SEE IF IMAGE MODE
	TROA T3,400		;YES. SET BIT FOR SUPPRESSING FILLERS
	TRZ T3,400		;ELSE CLEAR IN CASE EXTENDED
	JUMPE T3,TTOUT4		;DON'T OUTPUT NULLS
	PUSHJ P,TYO		;OUTPUT THIS CHARACTER (WAIT IF NEEDED)
	 JRST XPNOUT		;TYO WANTS AN INTERRUPT (SEE TYO)
TTOUT4:	SOJG P2,TTOUT2		;COUNT USER'S ITEMS.
TTOUT5:	PUSHJ P,ADVBFE		;ADVANCE HIS BUFFERS
	  JFCL			;JUST SINGLE BUFFER FOR NOW
	MOVEI S,IOACT		;CLEAR ACTIVE BIT.
	ANDCAB S,DEVIOS(F)	;IN DEVICE DATA BLOCK FOR THE JOB
	MOVEI T1,1
	DPB T1,LOPOUT
	DPB T1,LDBOPB(U)
	POPJ P,
XPNOUT:	PUSHJ P,CKATTF		;HE MUST BE ATTCHED
	MOVSI T1,L2LOEX
	IORM T1,LDBBYT(U)	;SET FOR EXPANDED OUTPUT
	MOVE T1,LDBTOC(U)
	CAML T1,TOEMAX		;ALREADY TOO MANY FOR EXPANDED?
	AOS (P)			;YES SKIP RETURN (TO TYO)
				;WILL GET US INTO OUTPUT WAIT
	POPJ P,			;NON-SKIP RETURN (TO TYO) GO NOW

TTYOUS:	PUSHJ P,ADVBFE	;SKIP THIS BUFFER
	 JFCL
	MOVEI S,IOACT
	ANDCAB S,DEVIOS(F)	;JUST TO MAKE SURE
	POPJ P,
SUBTTL DDT MODE CALLI'S

;INPUT TO DDT	- CALL AC,[SIXBIT /DDTIN/]  WHERE AC/ ADDR
;ADDR GETS UP TO 21 WORDS OF ASCIZ, BREAKING ON ANY CHARACTER

DDTIN:	PUSHJ P,TTYFNU			;SET U AND F FOR THIS TTY
	PUSHJ P,CKATTI		;CHECK FOR ATTACHED
	 JRST ABTUUO		;INTERRUPT, GET OUT OF UUO
	NOCHARGE
	XCTFU <HRRZ P2,(M)>
	HRLI P2,440700		;SEVEN BIT BYTES, RELOCATED.
	MOVEI P1,<21*5>-1		;NUMBER OF BYTES ALLOWED
	PUSHJ P,TWAITC			;GET AT LEAST ONE CHARACTER
	PUSHJ P,SETBRK		;ONE BREAK CHR
DDTINL:	SKIPG LDBTIC(U)		;ANY MORE TO COME?
	JRST DDTINX			;NO.
	PUSHJ P,TYI			;YES. GO GET ONE
	  JRST DDTINX			;WASNT ANY. I'M CONFUSED.
	TRNE T3,177			;NULL?
	XCTFU <IDPB T3,P2>			;NO. STORE IN USER AREA
	SOJG P1,DDTINL			;IF MORE SPACE, GET ANOTHER CHARACTER
DDTINX:	MOVEI T3,0			;FLAG END OF STRING
	XCTFU <IDPB T3,P2>			; IN USER AREA
	PJRST NOCTRO			;AND RETURN TO USER, CLEARING ^O FLAG

;DDTOUT - CALL AC,[SIXBIT /DDTOUT/], AC/ ADDR, ADDR/ ASCIZ /XXX/

DDTOUT:	UMOVE M,(M)	;GET ADDRESS
	MOVEI W,3
	JRST TTYUUO	;HANDLE LIKE OUTSTR
SUBTTL HANG UUO

COMMENT @

HANG UUO -- HANG A PORT, A JOB, OR ALL JOBS

	T1/	BITS,,PORT OR JOB #

	<BITS>  = 1B13 SAME AS 1B16 EXCEPT DON'T DETACH CMD PORT (LET
		       LOGOUT DO IT)
		  1B14 TO HANG A PORT OSTENSIBLY NOT TIED TO
		       A CIRCUIT
		  1B15 TO HANG ALL JOBS THEN GO TO BOOTS LOADED
		  1B16 TO FORCE A LOGOUT EVEN FOR JOBS WITH
		       DETACH OR TIMEOUT SET
		  1B17 IF SPECIFYING A JOB RATHER THAN A PORT
@

EXTERNAL FDRUPX

HNGUUO::TLNN	T1, (1B15)	;IF HANGING THE SYSTEM
	TLNN	T1, (1B17)	;OR SPECIFYING A PORT,
	JRST	HNGUUL		;  NEED LICENSE

    ;HANGING A SPECIFIC FRAME -- CHECK ACCESS RIGHTS

	HRR	P1, J		;SAVE CALLER JOB#
	HLL	P1, T1		;SAVE <BITS>
	HRRZ	P4, T1		;P4/ FRAME DESC
	HRRZI	P3, .ARHNG	;P3/ HANG-FRAME ACCESS
	PUSHJ	P, FDRUPX	;J/ TARGET JOB#
	  POPJ	P,		;(NO JOB OR INSUFFICIENT ACCESS)
	HLL	T1, P1		;T1/ <BITS>,,
	HRR	T1, J		;T1/ <BITS>,,TARGET JOB#
	HRRZ	J, P1		;J/ CALLER JOB#
	JRST	HNGMON

    ;HANGING A PORT OR HANGING SYSTEM -- NEED WC LICENSE

HNGUUL:	MOVSI	T2, LICWCR
	TDNN	T2, JBTLIC(J)
	POPJ	P,

    ;HERE WHEN ACCESS IS OK, TO DO THE ACTUAL STUFF

HNGMON::HRRZ T2,T1	;GET JOB OR PORT NUMBER
	TLNE T1,(1B15)
	JRST HNGALL	;HANG ALL JOBS
	TLNE T1,(1B17)
	JRST HNGJOB	;HANG A JOB
	CAIL T2,RPORTN
	POPJ P,			;BAD PORT
	HRR U,LINTAB(T2)

	SKIPN LDBLOG(U)	;THERE?
	TLCE T1,(1B14)	;SKIP IF DESIRE TO HANG ACTIVE PORTS
	TLNE T1,(1B14)	;SKIP IF WANT TO HANG INACTIVE PORTS
	POPJ P,		;ERROR RETURN
	AOS (P)		;SET TO SKIP RETURN

    ;HERE FROM ABOVE AND FROM ZAPCIR UUO
    ;U/ ---,,LDB ADDR
    ;T1/1B16 if ignoring continue-on-disconnect

HNGPRT:	PUSH	P,T1		;Save the "kill flag"
	MOVSI	T2,LMLBIO
	TDNE	T2,LDBMOD(U)
	PUSHJ	P,BIOREL	;RESET BIO ON THIS PORT
	POP	P,T1		;Restore "kill flag"

;HERE WITH U/ LDB ADDR TO HANG THAT PORT

	HLL	U,LDBDCH(U)
	MOVSI	T2,LLLZAP
	IORM	T2,LDBLOG(U)	;MARK PORT INTERNALLY "ZAPPED"
	TLNE	U,LDLAUX	;IS IT AN AUX CIRCUIT?
	JRST	HNGAUX		;YES, SO IT'S NOT A COMMAND PORT
	HRRZ	F,LDBDDB(U)	;F/ DDB ADDR
	JUMPE	F,TTYZAP	;Detached, just zap the port
	MOVSI	T2,TTYATC
	TDNN	T2,DEVMOD(F)	;IS IT A COMMAND PORT?
	JRST	HNGAUX		;NO
	LDB	J,PJOBN		;Get number of controlling job/frame
	HLL	J,T1		;Set up J for general hang code
	;JRST HNGTTY
; Here from above or by PUSHJ.  At entry, F=DDB address, U=LDB
; address (if any), J=job/frame # in RH, LH has bit 16 set if
; continue-on-disconnect is to be ignored.

HNGTTY:
	TLNE	J,(1B13)	;WANT TO DETACH?
	JRST	HNGTT1		;NO, LET LOGOUT HANDLE IT
	HLLZS	DDBLDB(F)	;Clear DDB-to-LDB pointer
	HRRZS	DEVNAM(F)	;Clear "TTY" from device name
	JUMPE	U,HNGTT1	;Skip port code if no port
	HLLZS	LDBDDB(U)	;Clear LDB-to-DDB pointer
	PUSHJ	P,TTYZAP	;ZAP the port
	LDB	T1,LDPCOM	;Command mode from LDB
	DPB	T1,DDPCOM	;Copy into DDB

; Here job/frame is detached and TTY is gone

HNGTT1:	TLZE	J,(1B13!1B16)	;"Really kill"?
	  JRST	HNGTT2		;Yes, kill him good
	LDB	T1,PVYHNG##	;HANG/ZAP action field
	CAIE	T1,.PVHCN	;Continue-on-disconnect?
	  JRST	HNGTT3		;No, go kill it dead

; Here for continue-on-disconnect

	LDB	T1,DDPTZP
	PUSHJ	P,TAKTRP	;"Jab the job"
	MOVE	S,DEVIOS(F)
	TLNE	S,TIOUSE	;If the DDB is in use,
	  PUSHJ	P,TIWAKE	; wake the job
	POPJ	P,

; Here to kill job dead

HNGTT2:	PUSHJ	P,TTKJOB##	;"Really kill" (no questions)
HNGTT3:	MOVSI	T1,DCLCOM
	IORM	T1,DDBDCH(F)	;In command mode at detach time
	PUSHJ	P,COMKJB##	;The MAGIC INVOCATION which kills jobs
	POPJ	P,		;Less magical, returns to caller
;HERE TO HANG A JOB
;T1/ BITS,,JOB#  T2/ 0,,JOB#

HNGJOB:	CAIL	T2,JOBN
	POPJ	P,		;BAD JOB NUMBER
	HRRZ	F,TTYTAB(T2)
	JUMPE	F,CPOPJ		;NO JOB THERE
	HRRZ	U,DDBLDB(F)
	MOVE	J,T1		;Copy BITS,,JOB#
	PUSHJ	P,HNGTTY	;Force hang for this job/frame
	JRST	CPOPJ1

;HERE TO HANG EVERYONE AND BRING DOWN THE SYSTEM

	INTERN HNGALL
	EXTERN CRSHWD
HNGALL:	SETZM CRSHWD		; THIS KEEPS US FROM NESTING
	SETOM DWNFLG
	MOVEI T1,600000
	IORM T1,STATES	;SET SUPER SHUT
	PUSHJ P,SETSHT	;LET SUPERVISOR KNOW
	MOVE T1,HIGHJB
	PUSH P,T1
HNGAL1:	HRLI T1,(1B16!1B17)	;HANG JOB AND FORCE LOGOUT
	HRRZ	T2,T1		;Copy job #
	PUSHJ P,HNGJOB
	 JFCL
	SOSLE T1,(P)
	JRST HNGAL1
	JRST TPOPJ1
SUBTTL RESET UUO

TTYRES:	HRRZ F,TTYTAB(J)	;CALLED AT RESET TIME
	JUMPE F,CPOPJ		;NO DDB
	MOVE S,[XWD TWTSPC!IOSBKA,BK2IOS!DLRSUP!NOECHO!FCS!17]
	ANDCAB S,DEVIOS(F)	;RESET TTY TO NORMAL STATE
	HRRZ U,DDBLDB(F)
	JUMPE U,TTYRS1		;NO LINE
	MOVE T1,LDBMOD(U)	;CHECK FOR BLOCK I/O MODE SET
	TLNE T1,LMLBIO		;FOR THE PORT AND RELEASE
	PUSHJ P,BIOREL		;BUFFERS AND RESET, IF SO.
	MOVSI T1,L2LNTB
	ANDCAM T1,LDBBYT(U)	;RESET THE NO TAB FUNCTION
	HRRZI T1,L2LTBK
	PUSHJ P,SETTBK	;NOW MAKE SURE TABS ARE BREAK2
	HRRZI T1,L2LBBP
	PUSHJ P,SETTBK	;MAKE SURE THAT BACKSPACES ARE BREAK
	PUSHJ P,UUOLDB		;MAKE LINE AGREE WITH S
TTYRS1:	PUSHJ P,NXTTTY		;GET NEXT DDB
	 POPJ P,		;NONE
	MOVSI T2,DVNZP
	TDNE T2,DEVMOD(F)	;SHOULD WE ZAP ON RESET?
	JRST TTYRS1		;NO
	MOVEI T2,ASSCON
	PUSHJ P,RELEA6		;YES
	JRST TTYRS1
SUBTTL .STTLK SETUUO FUNCTION

COMMENT @

CALLED BY SETUUO TO DO THE .STTLK FUNCTION (TALK COMMAND CLONE):

	MOVE	J, [TALKER JOB #]
	MOVE	T1, [TALKEE JOB #]
	MOVE	T2, [ILDB POINTER TO ASCIZ MESSAGE IN USER SPACE]
	PUSHJ	P, STTLK
	  ERROR RETURN	;T1/ ERROR CODE (SEE DEFINITIONS BELOW)
	NORMAL RETURN

ADVANCES T2 AS IT GOES, SO T2 IS CORRECTLY UPDATED IF THE MESSAGE
CAN ONLY BE PARTIALLY OUTPUT.

DESTROYS T1 T3 T4.

@

TKROM%==:0	;NO ROOM FOR MORE OUTPUT CHARACTERS
TKEXS%==:1	;JOB DOESN'T EXIST
TKATT%==:2	;JOB NOT ATTACHED
TKBSY%==:3	;JOB BUSY (NO OPER LICENSE & NOT AT CMND LEVEL)

STTLK::	MOVSI	T3, JNA
	CAIGE	T1, JOBN	;IF BAD JOB #
	TDNN	T3, JBTSTS(T1)	;OR JOB NOT ASSIGNED,
	JRST	[
		MOVEI	T1, TKEXS%
		POPJ	P,	;  ERROR-RETURN
	]

	HRRZ	T3, TTYTAB(T1)	;T3/ TALKEE DDB
	SKIPN	T3
	  STOPCD
	HRRZ	T3, DDBLDB(T3)	;T3/ TALKEE LDB
	JUMPE	T3, [		;IF JOB NOT ATTACHED,
		MOVEI	T1, TKATT%
		POPJ	P,	;  ERROR-RETURN
	]

	CAIN	T3, OPRLDB	;IF IT'S NOT TO OPER CONSOLE,
	JRST	STTLK1
	MOVSI	T4, LICOPR
	TDNE	T4, JBTLIC(J)	;AND CALLER DOESN'T HAVE OPER LICENSE,
	JRST	STTLK1
	MOVSI	T4, LDLCOM
	TDNN	T4, LDBDCH(T3)	;AND PORT'S NOT AT COMMAND LEVEL,
	JRST	[
		MOVEI	T1, TKBSY%
		POPJ	P,	;  ERROR-RETURN
	]
    ;HERE WITH T2/ ILDB POINTER, T3/ TALKEE LDB TO SEND A MESSAGE

STTLK1:	PUSH	P, U		;SAVE U
	HRRZ	U, T3
	TLZ	T2, 37		;CLEAR INDEX AND INDIRECT FIELDS
	PUSH	P, T2		;AND SAVE BYTE POINTER

STTLK2:	MOVE	T1, LDBTOC(U)
	SKIPLE	TTFREE		;IF NO CHUNK ROOM,
	CAIL	T1, ^D200	;OR TOO MUCH OUTPUT FOR THIS GUY,
	JRST	[
		MOVEI	T1, TKROM%
		POP	P, T2
		POP	P, U
		POPJ	P,	;  RESTORE T2 AND U AND ERROR-RETURN
	]
	XCTFU	<ILDB T3, (P)>	;GET NEXT BYTE OF MESSAGE
	JUMPE	T3, STTLK3	;(END OF MESSAGE)
	PUSHJ	P, COMTYO	;PRINT THE CHARACTER
	JRST	STTLK2

STTLK3:	POP	P, T2
	POP	P, U
	JRST	CPOPJ1		;RESTORE T2 AND U AND SUCCESS-RETURN
SUBTTL TTCALL UUO
;TTCALL AC,E - VALUE OF AC DETERMINES ACTION OF UUO (051)

TTYUUO:	PUSHJ P,TTYFNU
	MOVE T3,TTUUOT(W)	;GET DIPACTH ADRS AND BITS
	TLNN T3,TUUATO
	JRST TTYUU1
	PUSHJ P,CKATTO
	 JRST ABTUUO	;ABORT THE UUO FOR INTERRUPT
	JUMPN U,TTYUU1
	PUSHJ P,CKATO2	;FORCE ATTACH EVEN IF "SPECIAL"
	 JRST ABTUUO
	JUMPE U,.-2	;JUST TO MAKE SURE
TTYUU1:	TLNN	T3, TUUATI	; ATTACH FOR INPUT ?
	JRST	TTYUU2		; NO
	PUSHJ	P, CKATTI	; YES -- CHECK IF ATTACHED
	  JRST	ABTUUO		; ABORT FOR INTERRUPT
TTYUU2:	TLNE  T3, TUUATR!TUUAIR	; RETURN IF DETACHED ?
	JUMPE U,CPOPJ	;YES
	TLNN T3,TUUATO!TUUATI
	PUSHJ P,UUOLDB	;MUST GET THROUGH UUOLDB
	TLNN T3,TUUROM
	JRST .+3
	PUSHJ P,CHKROM		;SEE IF WILL GO INTO IOW FOR INTERRUPT
	JRST TTYUUO
	TLNE T3,TUUAIR		;MUST IT BE AT USER LEVEL TOO?
	TLNN U,LDLCOM
	SKIPA			;NEED NOT BE OR IS
	POPJ P,
	TLNE T3,TUUEAT
	PUSHJ P,TYIEAT		;MUST EAT COMMAND BEFORE INPUT
IFE OPCRET,<	; KLUDGE TIL OPERATIONS CAN WRITE 10 CODE
	TLNE	T3,TUUFXI
	PUSHJ	P, FIXIMI	;SET IMAGE STATE FROM DATA MODE
>
	JRST (T3)
;BITS FOR THE TTY UUOS

TUUATI==400000	;NEED TO BE ATTACHED -- INPUT
TUUATO==200000	;NEED TO BE ATTACHED -- OUTPUT
TUUATR==100000	;RETURN IF NOT ATTACHED
TUUAIR==040000	;RETURN IF NOT AT USER LEVEL
TUUROM==020000	;CHECK FOR ROOM FOR AT LEAST 1 CHR BEFORE OUTPUT
TUUEAT==010000	;EAT COMMAND
TUUFXI==004000	;SET IMAGE STATE FROM DATA MODE
TUUIMI==002000	;TURN ON IMAGE STATE (REGARDLESS OF DATA MODE)

;THERE ARE SOME NEGATIVE DISPATCHES FAKED BY UUOCON

	XWD TUUAIR,LEVDEF		;-5 LEAVE DEFERED ECHO MODE
	XWD TUUAIR!TUUEAT!TUUFXI,RDNXT	;-4 READ NEXT CHR AND SKIP
	CPOPJ				;   NO LONGER IMPLEMENTED
	XWD 0,GETMC			;-2 GET U CHRS
	XWD TUUATI!TUUEAT!TUUFXI,TWAITC	;-1 WAIT FOR CHR
TTUUOT:	XWD TUUATI!TUUEAT!TUUFXI,INCHRW	;00 INPUT CHR AND WAIT
	XWD TUUATO!TUUROM,ONEOUT	;01 OUTPUT 1 CHR
	XWD TUUAIR!TUUEAT!TUUFXI,INCHRS	;02 INPUT CHR AND SKIP
	XWD TUUATO!TUUROM,OUTSTR	;03 OUTPUT STRING
	XWD TUUATI!TUUEAT!TUUFXI,INCHWL	;04 INPUT CHR AND WAIT U MODE
	XWD TUUAIR!TUUEAT!TUUFXI,INCHSL	;05 INPUT CHR AND SKIP U MODE
	XWD 0,GETLIN			;06 GET U CHRS.
	XWD TUUATO,SETLIN		;07 SET U CHRS.
	XWD TUUATR,TRESCU		;10 INHIBIT COMMAND LINE EATING
	XWD TUUATR,TSETBI		;11 CLEAR INPUT BUFFER
	XWD TUUATR,TSETBO		;12 CLEAR OUTPUT BUFFER
	XWD TUUAIR!TUUEAT!TUUFXI,SKPINC	;13 SKIP IF CHR TO BE INPUT
	XWD TUUAIR!TUUEAT!TUUFXI,SKPINL	;14 SKIP IF U TO BE INPUT
	XWD TUUATO!TUUROM,IONEOU	;15 IMAGE ONE-CHAR OUTPUT
	XWD TUUATO!TUUROM,OUTCHI	;16 OUTPUT CHR IMMEDIATE
	XWD TUUATO!TUUROM,OUTPTR	;17 OUTPUT FROM POINTER
;SUBROUTINES FOR TTCALL

;ONEOUT OUTPUTS ONE CHARACTER FROM C(E)

OUTCHI:	SKIPA T3,M	;GET THE CHARACTER FROM ADDRESS FILED
ONEOUT:	UMOVE T3,(M)	;GET CHR FROM ADDRESS
	NOCHARGE
	PUSHJ P,CLRIMI			;CLEAR IMAGE INPUT STATE
	TRNN S,10		;IF MODES 10,13,14
	TRNN S,2		;OR 0,1
	TRZA T3,600		;SAME AS ANDI 177 SINCE TTGETC GETS 9 BIT BYTE
	ANDI T3,377		;8 BITS IN MODE 2
	JUMPE T3,CPOPJ			;IF NOT NULL,
ONEOU2:	PUSHJ P,TYO
	 JRST XPNOUT		;SET BIGGER OUTPUT AND GO TO TYO
ONEOU3:	MOVEI T1,1
	DPB T1,LOPOUT
	DPB T1,LDBOPB(U)
	POPJ P,

;IONEOU OUTPUTS ONE CHARACTER FROM LOW 8 BITS OF C(E)
ACOTCI:	SKIPA T3,M	;GET CHR IMMEDIATE (AUXCAL)
IONEOU:	UMOVE T3,(M)	;GET CHR
	NOCHARGE
	PUSHJ P,CLRIMI			;NOT IN INPUT WAIT ANY MORE
	JUMPE F,ONEOUT		;IF NO F, SEND 7 BITS
	TRO T3,400			;FLAG AS IMAGE CHARACTER (NO FILLER)
	PJRST ONEOU2		;OUTPUT CHARACTER

;OUTSTR OUTPUTS A STRING OF ASCIZ CHARACTERS


OUTSTR:	PUSHJ P,CLRIMI			;CLEAR IMAGE INPUT STATE
	NOCHARGE
	HRLI M,(POINT 7,0)			;POINT TO USER AREA
OUTST1:	XCTFU <ILDB T3,M>	;GET CHR
	JUMPE T3,ONEOU3			;NULL MARKS END OF STRING, START PTY
	PUSHJ P,TYO			;TYPE OUT CHARACTER WITH PARITY
	 JRST XPNOUT		;TRY BIGGER OUTPUT BUFFER
	JRST OUTST1			;AND GO BACK FOR MORE.

;TRESCU IS FOR COMPIL TO READ COMMAND WHICH STARTED IT

TRESCU:	MOVSI T1,LDLECS		;CLEAR BIT IN U DATA BLOCK WHICH
	ANDCAM T1,LDBDCH(U)		; WOULD CAUSE COMMAND TO BE SKIPPED
	POPJ P,0			;AND RETURN TO USER
;SKPINC -- SKIP IF INCHRW WOULDN'T WAIT (TOO LONG)

SKPINC:	SKIPG LDBECC(U)
	SKIPLE LDBTIC(U)
	AOS (P)
NOCTRO:	MOVSI T1,L2LLDF
	ANDCAM T1,LDBBYT(U)	;TURN OFF LEVDEF FLAG TOO
	MOVSI T1,LDLOSU	;TURN OFF CONTROL O BIT
	ANDCAM T1,LDBDCH(U)
	POPJ P,

;SKPINL -- SKIP IF INCHWL WOULDN'T WAIT

SKPINL:	MOVE T1,LDBTIC(U)	;T1/ # READABLE CHARACTERS
	TLNE U,LDLIMI		;IF IMAGE MODE
	SKIPG T1		;AND THERE'RE ANY,
	CAIL T1,TIWKC		;OR OF THERE'S A LINEFULL,
	JRST SKPIN1		;  SKIP
	TLNE U,LDLBK2		;IF BREAK-ON-PUNCTUATION
	SKIPG LDBBK2(U)		;AND THERE'RE PUNCTUATION CHARS,
	SKIPLE LDBBKC(U)	;OR IF THERE'RE BREAK CHARACTERS,
SKPIN1:	AOS (P)			;  SKIP
	PJRST NOCTRO
;OUTPTR -- OUTPUT FROM BYTE POINTER

OUTPTR:	PUSHJ P,CLRIMI
	NOCHARGE
	XCTFU <MOVE W,(M)>	;GET BYTE POINTER
	TLZ W,37		;GET RID OF INDEX AND INDIRECT
OUTPT1:	XCTFU <ILDB T3,W>	;GET NEXT CHARACTER
	JUMPE T3,ONEOU3		;DONE -- SET OUTPUT BITS&RETURN
	PUSHJ P,TYO
	 SKIPA			;TYO WANTS TO TAKE INTERRUPT
	JRST OUTPT1		;TYO DONE, NEXT CHR
	LDB T3,[POINT 6,W,11]	;GET SIZE FIELD
	ROT T3,-6		;MOVE TO POSITION FILED
	ADDM T3,W		;BACK UP POINTER 1 POSITION
	XCTTU <MOVEM W,(M)>	;PUT IT BACK
	MOVEI T1,1
	DPB T1,LOPOUT
	DPB T1,LDBOPB(U)
	JRST ABTUUO		;AND DUMP THIS UUO

;OUTPTC -- OUTPUT FROM BYTE POINTER + COUNT

OUTPTC:	PUSHJ	P, CLRIMI
	NOCHARGE
	XCTFU	<HRRZ P1, 0(M)>	;P1/ COUNT
	JUMPE	P1, CPOPJ	;IF 0, DONE
	XCTFU	<MOVE W, 1(M)>	;W/ BYTE POINTER
	TLZ	W, 37		;W/ BYTE POINTER - INDEX&INDIRECT BITS
OUTPC1:	XCTFU	<ILDB T3, W>	;T3/ NEXT CHARACTER
	PUSHJ	P, TYO		;OUTPUT IT
	  JRST	OUTPC2		;(TYO WANTS AN INTERRUPT)
	SOJG	P1, OUTPC1	;IF MORE CHARACTERS, CONTINUE
	PJRST	OUTPCF		;FINISH UP

OUTPC2:	LDB	T3, [POINT 6,W,11]
	ROT	T3, -6		;POSITION FIELD := SIZE FIELD
	ADDM	T3, W		;DECREMENT BYTE POINTER BY 1 BYTE
	PUSHJ	P, OUTPCF	;FINISH UP
	JRST	ABTUUO		;AND DUMP THIS UUO

	;OUTPCF ALSO USED BY OUTSNW...BELOW
OUTPCF:	XCTBU	<HRRM P1, 0(M)>	;STORE THE UPDATED COUNT
	XCTTU	<MOVEM W, 1(M)>	;AND BYTE POINTER
	MOVEI	T1, 1
	DPB	T1, LOPOUT
	DPB	T1, LDBOPB(U)
	POPJ	P,

;OUTSNW -- OUTPUT STRING, NEVER WAIT

OUTSNW:	PUSHJ	P,CLRIMI
	NOCHARGE
	HLRZ	T1,LDBBIO(U)	;BLOCK OUTPUT IN PROGRESS?
	JUMPN	T1,CPOPJ	;IF SO, CAN'T DO ANYTHING
	XCTFU	<HRRZ P1,(M)>	;P1/ COUNT
	JUMPE	P1,CPOPJ1	;NOTHING TO DO
	XCTFU	<MOVE W,1(M)>	;W/ BYTE POINTER
	TLZ	W,37		;W/ BYTE POINTER - INDEX & IND BITS
OUTSN1:	PUSHJ	P,IFROOM	;IS THERE ROOM FOR A CHARACTER?
	 JRST	OUTSN2		;NO ROOM - SET FIO GO AWAY
	XCTFU	<ILDB T3,W>	;YES ROOM - GET CHARACTER
	PUSHJ	P,CMDTYO	;AND OUTPUT IT
	SOJG	P1,OUTSN1	;DO IT AGAIN, IF MORE
	AOS	(P)		;RAN OUT - SKIP RETURN
	JRST	OUTPCF		;GO AWAY
OUTSN2:	PUSHJ	P,SETFIO	;SO HE'LL GET ROOM AVAILABLE TRAP
	JRST	OUTPCF		;NO ROOM - GO AWAY

;GETLCH -- READ LINE CHARACTERISTICS

GETLIN:	XCTFU <MOVE T1,(M)>
	PUSHJ P,CHKLN2	;SEE IF THIS USER CAN HAVE THIS INFO
	 JRST GETLNZ	;NO
	LDB T1,LDPLNO		;GET NUMBER
	HLL	T1,LDBDCH(U)	; GET BITS FROM LH WHICH ARE SAME
	TLZ	T1,-1-GTLMSK	; CLEAR ALL BITS IN LH WHICH ARN'T
	LDB T3,LDPHDX	;GET HALF DUPLEX BIT FROM CHRS READ
	SKIPE T3	;SEE IF ON
	TLO T1,GTLHDX
	MOVE	T3, LDBDCX(U)
	TRZE	T3, LXRESC	;READ AND CLEAR "ESCAPE SEEN"
	TLO	T1, GTLESC	;RETURN ITS OLD VALUE
	TRZE	T3, LXROBS	;READ AND CLEAR "ORANGE BALL SEEN"
	TLO	T1, GTLOBS	;RETURN ITS OLD VALUE
	MOVEM	T3, LDBDCX(U)
	MOVSI	T3, LMLPSP
	TDNE	T3, LDBMOD(U)	;CHECK FOR UNREAD PORT-STATUS MSG
	TLO	T1, GTLPSP	;AND SET IF THERE IS ONE
	LDB T3,LDPCRD	;GET RETURN DELAY BIT
	SKIPE T3
	TLO T1,GTLCRD
	HLL U,LDBDCH(U)	;THE OTHERS FROM NORMAL BITS
	MOVE T3,LDBBKC(U)	;GET BREAK COUNTER
	TLNE U,LDLBK2	;IF IN BREAK 2 MODE
	ADD T3,LDBBK2(U)	;ADD IN THESE
	TRNE T3,-1
	TLOA T1,GTLLRD		;SET U READY BIT
	TLZ T1,GTLLRD		;OR TURN IT OFF
	TLC T1,GTLLCT		;SENSE OF THIS BIT IS WRONG
	XCTTU <MOVEM T1,(M)>
	POPJ P,

GETLNZ:	XCTBU <SETZM (M)>
	POPJ P,

; THE FOLLOWING BITS ARE IN THE SAME PLACE IN LDBDCH AS IN GETLCH...
GTLMSK==LDLNOP!LDLDEF!LDLECS!LDLOSU!LDLNFC!LDLNEC!LDLAUX!LDLLCT!LDLTAB!LDLLCP!LDLPTP!LDLFRM

GTLECS==100000	;EAT COMMAND SYNCH (CMD AVAIL FOR RESCAN)
GTLPSP==40000	;PORT STATUS PENDING (UNREAD)
GTLOBS==20000	;ORANGE BALL SEEN
GTLHDX==10000	;HALF DUPLEX
GTLESC==4000	;ESCAPE SEEN
GTLCRD==2000	;CARRIAGE-RETURN(NOT LF) PADDING
GTLDEF==1000	;DEFERRED ECHO MODE
GTLNFC==200	;NO FREE CRLF (ON LONG LINES)
GTLLRD==100	;LINE (BREAK) IN BUFFER
GTLLCT==20	;NO CASE MAPPING
GTLTAB==10	;HARDWARE HT
GTLPTP==2	;PAPER TAPE MODE
GTLFRM==1	;HARDWARE FF/VT
;SETLCH -- SET LINE CHARACTERISTICS

SLCTAB:	GTLHDX,,TCNHDX
	GTLCRD,,TCNCRD
	GTLNFC,,TCNNFC
	GTLLCT,,TCNLCT
	GTLTAB,,TCNTAB
	GTLPTP,,TCNPTP
	GTLFRM,,TCNFRM
SLCTBN==.-SLCTAB

SETLIN:	XCTFU	<HLRZ P1,(M)>	;P1/ 0,,USER BITS
	TRC	P1, GTLLCT	;INVERT SENSE OF CASE-MAP BIT
	MOVE	P2, [-SLCTBN,,SLCTAB]
SETLN1:	HLL	T3, (P2)	;T3/ THE BIT
	TLNN	T3, (P1)	;SET IT OR CLEAR IT?
	TDZA	T2, T2		;(CLEAR)
	MOVEI	T2, 1		;(SET)
	HRRZ	T1, (P2)	;T1/ THE TC#
	PUSHJ	P, SETTCN
	  STOPCD		;WHAT ERROR?
	AOBJN	P2, SETLN1
	POPJ	P,
;CHARACTER INPUT TTCALLS

INCHRS:	NOCHARGE
	PUSHJ P,SKPINC			;CAN I GET A CHARACTER (CLEAR ^O)
ICS1:	  JRST NOCTRO			;NO. GIVE NON-SKIP RETURN
	PUSHJ P,TWAITS
	  POPJ	P,			;DETACHED
	PUSHJ P,TYI			;GET A CHARACTER
	  JRST ICS1			;NONE THERE. SKPINC LIED?
	AOS 0(P)			;GIVE SKIP RETURN
	JRST ICW1A			;AND RETURN THE CHARACTER
INCHSL:	NOCHARGE
	PUSHJ P,SKPINL			;IS THERE A U AVAILABLE?
	  POPJ P,0			;NO. NON-SKIP RETURN TO USER
	PUSHJ P,TWAITL
	PUSHJ P,TYI		;GET THE CRH.
	 JRST ICS1		;REALLY NONE THERE
	AOS (P)			;SET FOR SKIP RETURN
	JRST ICW1B		;GO (REMEMBER TO CHARGE

I1CHWL:	AOS (P)		;FROM AUXCAL
INCHWL:	NOCHARGE
INWL1:	TLNE U,LDLIMI	;CHECK IMAGE MODE
	TLNN S,IOEND
	SKIPA
	JRST ICH0		;SEND A 0 CHRACTER
	PUSHJ P,TWAITL			;WAIT FOR A U TO APPEAR
	PUSHJ P,TYI			;GO GET A CHARACTER
	  JRST INWL1			;IMPOSSIBLE. NO CHARACTERS.
ICW1B:	CAIN T2,%CHBRK		;A BREAK?
ICW1A:	PUSHJ P,SETBRK		;YES, CHARGE
ICW1:	TRNN S,10		;IF MODES 10,13,14
	TRNN S,2		;OR 0,1
	TRZA T3,600		;SAME AS ANDI 177 SINCE TTGETC GETS 9 BIT BYTE
	ANDI T3,377		;8 BITS IN MODE 2
	XCTTU <MOVEM T3,(M)>			;GIVE HIM THE CHARACTER
	JRST NOCTRO			;AND NON-SKIP RETURN

ICH0:	MOVEI T3,0
	JRST ICW1

I1CHRW:	AOS (P)		;FROM AUXCAL
INCHRW:	NOCHARGE
INRW1:	PUSHJ P,TWAITC			;WAIT FOR A CHARACTER TO APPEAR
	PUSHJ P,TYI			;GO GET THE CHARACTER
	  JRST INRW1			;IMPOSSIBLE. NONE THERE
	JRST ICW1A			;GIVE HIM T3 AND RETURN
GETLOG:	PUSHJ P,CHKLIN
	 POPJ P,	;ERROR, CAN NOT HAVE INFO
	SKIPA T1,LDBLOG(U)
RETZRO:	MOVEI T1,0		;NO U THERE, RETURN 0
STOTC1:	UMOVEM T1,(M)		;RETURN ARGUMENT TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

CHKLN2:	SKIPA U,T1
CHKLIN:	HLRE U,T1
	JUMPL U,CKLN1	;WANTS OWN LINE
	CAILE U,MXLIN
	POPJ P,		;ILLEGAL LINE NUMBER
	SKIPA U,LINTAB(U)	;GET CORRECT LINE
CKLN1:	PUSHJ P,TTYFNU
	JUMPE U,CPOPJ		;NO LINE NUMBER THERE
	HRRZ F,LDBDDB(U)	;GET THE DDB
	JUMPE F,CPOPJ		;IF NONE, NO ONE CONNECTED
	LDB J,PJOBN		;GET THE JOB NUMBER
	JRST CHKSEG		;AND GO CHECK

LINJOB:	PUSHJ P,CHKLIN
	 POPJ P,	;CAN NOT HAVE INFO
	HRRZ F,LDBDDB(U)
	JUMPE F,RETZRO
	LDB T1,PJOBN	;GET THE JOB NUMBER
	JRST STOTC1

GETLPS:	PUSHJ P,CHKLIN
	 POPJ P,
	LDB T1,LDPPOS
	JRST STOTC1

GETMOD:	PUSHJ P,CHKLIN
	 POPJ P,
	HRRZ F,LDBDDB(U)
	JUMPE F,RETZRO
	MOVE T1,DEVIOS(F)
	JRST STOTC1
RDNXT:	NOCHARGE
	SKIPG LDBECC(U)	;MAKE SURE A CHR IS THERE
	SKIPLE LDBTIC(U)
	AOSA (P)
	POPJ P,			;NO, RETURN
	MOVE T2,LDBTIT(U)
	PUSHJ P,TTGETC
	 JFCL
	TRNN S,10		;IF MODES 10,13,14
	TRNN S,2		;OR 0,1
	TRZA T3,600		;SAME AS ANDI 177 SINCE TTGETC GETS 9 BIT BYTE
	ANDI T3,377		;8 BITS IN MODE 2
	XCTTU <MOVEM T3,(M)>	;GIVE IT TO HIM
	POPJ P,

LEVDEF:	MOVSI T1,L2LLDF
	IORM T1,LDBBYT(U)
	PUSHJ P,BPLVD	;TURN OFF BACKPRESSURE IF APPROPRIATE
	MOVEI T1,1
	DPB T1,LOPECO
	DPB T1,LDBOPB(U)
	POPJ P,
;READ TERMINAL CHARACTERISTICS

GETMC:	UMOVE T1,(M)	;GET THE LINE HE WANTS THESE FOR
	PUSHJ P,CHKLN2
	 JRST GETLNZ	;CAN NOT HAVE THEM
	SETZM	T1	;MAKE UNFILLED FIELDS 0 (ARE THERE ANY?)
	LDB T3,LDPFC1	;FILLER CLASS 1
	DPB T3,GEPMC1
	LDB T3,LDPFC2	;FILLER CLASS 2
	DPB T3,GEPMC2
	LDB T3,LDPWID	;WIDTH
	DPB T3,GEPMC3
	LDB T3,GEPMC4	;NO XON, NO TAB, TAB AS BREAK BITS
	DPB T3,GEPMC5
	LDB T3,LDPIR
	DPB T3,GEPMC6
	LDB T3,LDPOR
	DPB T3,GEPMC7
	LDB T3,LDPPAR
	DPB T3,GEPMC8
	LDB T3,LDPPA
	DPB T3,GEPMC9
	LDB T3,LDPHDX
	DPB T3,GEPM10
	LDB T3,LDPPB
	DPB T3,GEPM11
	LDB T3,LDPPC
	DPB T3,GEPM12
	UMOVEM T1,(M)
	POPJ P,

GEPMC1:	POINT 2,T1,16	;FILLER CLASS 1
GEPMC2:	POINT 2,T1,14	;FILLER CLASS 2
GEPMC3:	POINT 8,T1,12	;WIDTH
GEPMC4:	POINT 3,LDBBYT(U),4	;GET NO XON, NO TAB, TAB AS BRK
GEPMC5:	POINT 3,T1,4	;LOCATION OF ABOVE IN GETTMC WORD
GEPMC6:	POINT 3,T1,19	;IR
GEPMC7:	POINT 3,T1,22	;OR
GEPMC8:	POINT 1,T1,23	;PAR
GEPMC9:	POINT 3,T1,26	;PA
GEPM10:	POINT 1,T1,27	;HDX
GEPM11:	POINT 3,T1,30	;PB
GEPM12:	POINT 5,T1,35	;0 BIT + PC
;FIXIMI CALLED ON INPUT UUOS OTHER THAN AUXCALS 0,1,2 TO SET
;IMAGE STATE FROM DATA MODE

FIXIMI:	MOVE	T1, LDBDCH(U)
	TLNN	T1, LDLAUX	;AUX CIRCUIT?
	TRNE	S, I		;OR DATA MODE = I, IB, B?
	TLOA	T1, LDLIMI	;YES: SET IMAGE STATE
	TLZ	T1, LDLIMI	;NO: CLEAR IMAGE STATE
	CAMN	T1, LDBDCH(U)	;DID IT CHANGE?
	POPJ	P,		;NO
	MOVEM	T1, LDBDCH(U)	;YES
	PJRST	SETLMD

;CLRIMI CALLED ON OUTPUT UUOS TO CLEAR IMAGE STATE IF DATA
;MODE IS NOT IMAGE AND TO TURN OFF BACKPRESSURE (IN GENERAL,
;TO NOTE THAT THE LINE IS NO LONGER SIMPLY IN INPUT WAIT)

CLRIMI:	HRRZ F,LDBDDB(U)		;GET ATTACHED JOB, IF ANY
	JUMPE F,CLRIM1		;IF NONE, SKIP PART OF THIS
	MOVE S,DEVIOS(F)		;JOB'S IO STATUS FOR TTY
	TRNE S,I			;IS IT STILL IN IMAGE MODE?
	POPJ P,0			;YES. FORGET IT.
CLRIM1:	MOVSI T1,LDLIMI		;NO. CLEAR IMAGE BIT AND TIME
	TLNN U,LDLAUX	;AUX ALWAYS IN IMAGE MODE
	TDNN T1,LDBDCH(U)	;IS IT ON?
	POPJ P,			;NO
	ANDCAM T1,LDBDCH(U)		; ..
	PUSHJ	P,BPTEST	;WANT TO TURN OFF BACKPRESSURE?
	  PUSHJ P,BPOFF		;YES, NOW TURN OFF BACKPRESSURE
	;PJRST SETLMD

SETLMD:	LDB T1,LDPMDF		;GET LINE MODE FLAGS
	MOVE T1,MDFLMD(T1)	;DO TRANSLATION INTO MODE
	DPB T1,LDPLMD		;AND SET INPUT AND ECHO MODES
	POPJ P,0			; AND RETURN
	
;SETTBK -- CALLED WITH
;	T1/ L2LTBK,,L2LTBK	SET TAB-AS-BREAK
;	T1/	 0,,L2LTBK	SET TAB-AS-PUNCTUATION
;	T1/ L2LBBP,,L2LBBP	SET BS-AS-PUNCTUATION
;	T1/	 0,,L2LBBP	SET BS-AS-BREAK
;BREAKS T1-T4

SETTBK:	MOVE	T2, T1
	XOR	T1, LDBBYT(U)
	TLNN	T1, 0(T2)	;IF THE BIT DIDN'T CHANGE,
	POPJ	P,		;  JUST RETURN
	HRLZ	T1, T2
	XORM	T1, LDBBYT(U)	;INVERT THE LDB BIT
	MOVEI	T1, 11		;(ASSUME IT'S TAB-AS-BREAK)
	TRNN	T2, L2LBBP	;IF IT'S BS-AS-PUNCTUATION,
	JRST	SETTB1
	MOVEI	T1, 10		;  CHAR := 10
	TLC	T2, L2LBBP	;  INVERT SENSE (TO BS-AS-BREAK)
SETTB1:	TLNE	T2, -1		;WHICH WAY?
	PJRST	PNTOBK		;(PUNCTUATION => BREAK)
	PJRST	BKTOPN		;(BREAK => PUNCTUATION)
;BKTOPN -- CALLED WITH U/ LDB ADDR, T1/ <CHAR>
;	   MAKE <CHAR> GO FROM A BREAK TO A PUNCTUATION CHARACTER
;	   BY ADJUSTING COUNTS
;	   DESTROYS T1 T2 T3 T4

BKTOPN:	PUSHJ	P, CHRCNT	;T1/ #UNECHOED,,#ECHOED
	ADDM	T1, LDBBK2(U)	;ADD TO PUNCTUATION COUNT
	MOVNS	T1
	ADDM	T1, LDBBKC(U)	;SUBTRACT FROM BREAK COUNT
	POPJ	P,

;PNTOBK -- CALLED WITH U/ LDB ADDR, T1/ <CHAR>
;	   MAKE <CHAR> GO FROM A PUNCTUATION TO A BREAK CHARACTER
;	   BY ADJUSTING COUNTS, LINE DELETE POINTER
;	   DESTROYS T1 T2 T3 T4

PNTOBK:	PUSHJ	P, CHRCNT	;P2/ #UNECHOED,,#ECHOED
	ADDM	T1, LDBBKC(U)	;ADD TO BREAK COUNT
	MOVNS	T1
	ADDM	T1, LDBBK2(U)	;SUBTRACT FROM PUNCTUATION COUNT
	JUMPE	T1, PNTOB1	;IF THERE ARE ANY NEW BREAK CHARACTERS,
	MOVE	T2, LDBTIP(U)
	MOVEM	T2, LDBBKP(U)	;  SET LINE-DELETE POINTER TO NOW
	SETZM	LDBBKI(U)	;  (NO DELETABLE CHARACTERS)
PNTOB1:	POPJ	P,
;CHRCNT -- CALLED WITH U/ LDB ADDR, T1/ CHAR
;	   RETURNS T1/ #UNECHOED,,#ECHOED <CHAR>S IN THE INPUT BUFFER
;	   DESTROYS T1 T2 T3 T4

CHRCNT:	PUSH	P, P1
	PUSH	P, P2
	MOVE	P1, T1		;P1/ CHAR
	SETZ	P2,		;P2/ COUNT
	MOVE	T2, LDBECT(U)	;T2/ ECHO-TAKER BYTE POINTER
	SKIPE	T4, LDBECC(U)	;T4/ #UNECHOED,UNREAD CHARACTERS
	PUSHJ	P, CNTCHR	;IF ANY, COUNT #<CHAR>S
	HRLZS	P2		;P2/ UNECHOED,,ECHOED
	MOVE	T2, LDBTIT(U)	;T2/ CHAR-TAKER BYTE POINTER
	SKIPE	T4, LDBTIC(U)	;T4/ #ECHOED,UNREAD CHARACTERS
	PUSHJ	P, CNTCHR	;IF ANY, COUNT #<CHAR>S
	MOVE	T1, P2		;T1/ COUNT
	POP	P, P2
	POP	P, P1
	POPJ	P,

    ;T2/ BUFFERLET BYTE POINTER, T4/ COUNT
    ;P1/ <CHAR> TO LOOK FOR, P2/ COUNT TO INCREMENT

CNTCHR:	PUSHJ	P, TTGETC	;T3/ NEXT CHAR
	  JFCL			;(EH?)
	ANDI	T3, 177		;T3/ ASCII PART OF THE CHAR
	CAMN	T3, P1		;IF IT'S THE <CHAR>,
	AOS	P2		;  COUNT IT
	SOJG	T4, CNTCHR
	POPJ	P,
;SETPTP -- SETS PAPER-TAPE-MODE BIT (SIMILAR CODE IN SETLIN)
;	   T1/ 0 TO CLEAR PTP, LDLPTP,,0 TO SET PTP MODE
;	   (DESTROYS T1)

SETPTP:	XOR	T1, LDBDCH(U)
	TLNN	T1, LDLPTP	;IF IT'S NOT CHANGING,
	POPJ	P,		;  JUST RETURN
	XORB	T1, LDBDCH(U)	;SET DCH BIT
	TLNE	T1, LDLPTP	;IN PTP MODE?
	TDZA	T1, T1		;YES: ECHO CR AS CR
	MOVEI	T1, 1		;NO: ECHO CR AS CRLF
	DPB	T1, LDSECR
	MOVE	T1, [LTSECR]
	IORM	T1, LDBTMT(U)
	MOVEI	T1, 1
	DPB	T1, LOPSTC	;SET SEND-CHARACTERISTICS
	DPB	T1, LDBOPB(U)	;SET WANT-OUTPUT
	POPJ	P,
SUBTTL PSEUDO-TTYS

;CREPTY UUO -- CREATE A PTY
;
;	CREPTY	AC,
;	  ERROR RETURN	;AC/ ERROR CODE
;	NORMAL RETURN	;AC/ PORT1#,,PORT2#

CPNPT%==1	;OUT OF PTYS (OR THERE NEVER WERE ANY)
CPNRM%==2	;NO ROOM FOR PTYS (OUT OF DDBS)

CREPTY::PUSHJ	P, GETPP	;GET A PORT# PAIR. T1/ EVEN SIDE #
	  JRST	[
		MOVEI	T1, CPNPT%
		JRST	CPERR
	  ]
	MOVEM	T1, P1
	PUSHJ	P, PTYLDB	;SET UP ITS LDB. U/ LDB ADDR
	HRLM	U, P2		;P2/ EVEN-SIDE LDB,,---
	PUSHJ	P, PTYDDB	;SET UP ITS DDB. F/ DDB ADDR
	  JRST	[
		MOVEI	T1, CPNRM%
		JRST	CPERR
	  ]
	HRRM	F, P2		;P2/ EVEN-SIDE LDB,,DDB
	MOVEI	T1, 1(P1)	;T1/ ODD-SIDE PORT#
	PUSHJ	P, PTYLDB	;SET UP ITS LDB. U/ LDB ADDR
	PUSHJ	P, PTYDDB	;SET UP ITS DDB. F/ DDB ADDR
	  JRST	[
		HRRZ	F, P2
		PUSHJ	P, TTYKDB	;FREE EVEN DDB
		HLRZ	U, P2
		HLLZS	LDBDDB(U)	;DETACH EVEN LDB
		SETZM	LDBLOG(U)	;FREE EVEN LDB
		MOVEI	T1, CPNRM%
		JRST	CPERR
	  ]
	HRLS	P1		;P1/ EVEN PORT#,,EVEN PORT#
	TRO	P1, 1		;P1/ EVEN PORT#,,ODD PORT#
	UMOVEM	P1, (M)		;GIVE USER THE PORT #S
	JRST	CPOPJ1		;SUCCESS!

CPERR:	UMOVEM	T1, (M)		;GIVE USER THE ERROR CODE
	POPJ	P,		;FAILURE!
;GETPP -- GET AN EVEN/ODD PTY PORT # PAIR
;	  NONSKIP-RETURN IF NONE
;	  SKIP-RETURN WITH T1/ THE EVEN # ON SUCCESS
;DESTROYS T2 U

GETPP:	SKIPA	T1, [<<PORTN-PPORTN+1>&<-1-1>>]
GETPP1:	ADDI	T1, 2		;GO ON TO THE NEXT PAIR
	CAILE	T1, PORTN-2	;IF WE'RE PAST THE TOP PAIR,
	POPJ	P,		;  FAIL
	HRRZ	T2, LINTAB(T1)	;T2/ EVEN-SIDE LDB ADDR
	SKIPE	LDBLOG(T2)	;IF IT'S LOGGED-IN,
	JRST	GETPP1		;  TRY THE NEXT PAIR
	HRRZ	T2, LINTAB+1(T1);T2/ ODD-SIDE LDB ADDR
	SKIPE	LDBLOG(T2)	;IF IT'S LOGGED-IN,
	JRST	GETPP1		;  TRY THE NEXT PAIR
	JRST	CPOPJ1		;SUCCESS!

;PTYBUD -- GET PTY BUDDY
;	CALLED WITH U/ PTY LDB
;	RETURNS U/ PTY LDB OF ITS OTHER END

PTYBUD:	LDB	U, LDPLNO
	TRC	U, 1
	HRRZ	U, LINTAB(U)	;U/ "BUDDY" LDB ADDR
	POPJ	P,
;PTYLDB -- SET UP A PTY LDB
;	   CALLED WITH T1/ PTY PORT #
;	   RETURN WITH U/ THE LDB

PTYLDB:	HRRZ	U, LINTAB(T1)	;U/ LDB ADDR
	SKIPN	U
	  STOPCD
	LDB	T2, LDPLNO	;T2/ LDB'S IDEA OF ITS PORT #
	CAME	T1, T2
	  STOPCD

    ;NOW THAT WE'VE GOT THE LDB, INITIALIZE IT
    ;THIS CODE SHOULD REMAIN ALMOST IDENTICAL WITH
    ;THE CODE AT AUXINP FOR NEW AUX CIRCUITS

	MOVSI	T1, 400000	;"LOGGED-IN" BIT
	LDB	T2, LDPLNO
	TRC	T2, 1
	DPB	T2, [POINT 8,     T1, 35]
	MOVEM	T1, LDBLOG(U)
	SETZM	LDBOUT(U)
	SETZM	LDBBYT(U)
	SETZM	LDBMOD(U)
	MOVEI	T1, ^D80
	DPB	T1, LDPWID
	SETZM	LDBTMT(U)
	ZZN==0
	REPEAT TMCSIZ, <SETZM LDBTMR+ZZN(U)
	ZZN==ZZN+1>
	MOVSI	T1, LDLDEF!LDLPTY
	MOVEM	T1, LDBDCH(U)	;DIFFERENT FROM AUX CIRCUITS!
	MOVSI	T1, LXL120
	MOVEM	T1, LDBDCX(U)	;BUFFER AS A FAST LINE
	SETZM	LDBTCB(U)	;NO CHANGED TERMINAL CHARACTERISTICS
	PUSHJ	P, SETLMD	;SET THE LINE MODE
	POPJ	P,
;PTYDDB -- ALLOCATE, LINK IN, ATTACH, INITIALIZE A PTY DDB
;	   CALLED WITH U/ LDB ADDRESS, J/ ATTACHEE JOB #
;	   NONSKIP-RETURNS IF THERE ARE NO FREE DDBS
;	   SKIP-RETURNS WITH F/ DDB ADDR ON SUCCESS

PTYDDB:	HRRZ	T1, TTYTAB(J)	;T1/ CMND PORT DDB
	SKIPN	T1
	  STOPCD		;(THERE MUST BE ONE)
	PUSHJ	P, DDBSR1	;F/ NEW DDB, LINKED AFTER CMND PORT
	  POPJ	P,		;FAIL-RETURN

	DPB	J, PJOBN	;SET JOB # OF OWNER
	PUSHJ	P, SCNNAM	;SET PHYSICAL NAME
	MOVEI	T1, ASSCON
	IORM	T1, DEVMOD(F)	;MARK IT ASSIGNED-BY-CONSOLE
	MOVEI	T1, TTYATC
	ANDCAM	T1, DEVMOD(F)	;AND NOT THE COMMAND PORT

	AOS	(P)		;SET TO SKIP-RETURN
	PJRST	COMATT		;AND ATTACH IT
SUBTTL AUXCAL UUO

;AUXCAL UUO

AUXTUU:	XCTFU	<HLRE F, (W)>	;F/ PORT DESCRIPTOR
	MOVE	J, JOB		;J/ JOB #
	PUSHJ	P, FNDPRT	;F := DDB ADDR.
	  POPJ	P,		;(NO PORT OR NOT THIS JOB'S PORT)
	HRRZ	U, DDBLDB(F)	;U/ LDB ADDR
	JUMPE	U, CPOPJ	;IF DETACHED, JUST RETURN
	XCTFU	<HRRZ T1, (W)>	;T1/ FUNCTION CODE
	CAILE	T1, MAXAXC	;IF IT'S OUT OF RANGE,
	POPJ	P,		;  JUST RETURN
	MOVE	T3, AXCTAB(T1)
	MOVE	S, DEVIOS(F)	;S/ FILE STATUS BITS
	PUSHJ	P, UUOLDB	;SET UP LDB
	TLNN	T3, TUUROM
	JRST	AUXTU0
	PUSHJ	P, CHKROM
	JRST	AUXTUU
AUXTU0:	TLNE	T3, TUUAIR
	TLNN	U, LDLCOM	;INPUT NOT ALLOWED IF AT COMMAND LEVEL
	SKIPA
	POPJ	P,
	TLNE	T3, TUUEAT
	PUSHJ	P, TYIEAT
IFE OPCRET,<	; KLUDGE TIL OPERATIONS CAN WRITE 10 CODE
	TLNE	T3, TUUFXI
	PUSHJ	P, FIXIMI	;SET IMAGE STATE FROM DATA MODE
>
	TLNN	T3, TUUIMI
	JRST	AUXTU1
	MOVSI	T1, LDLIMI
	IORM	T1, LDBDCH(U)	;SET IMAGE STATE ALWAYS
	PUSHJ	P, SETLMD
AUXTU1:	JRST	(T3)
AXCTAB:	TUUAIR!TUUEAT!TUUIMI,,ACINWC	;0 INPUT CHRS AND WAIT
	TUUAIR!TUUEAT!TUUIMI,,ACINSC	;1 INPUT CHRS AND SKIP
	TUUAIR!TUUEAT!TUUIMI,,ACINWB	;2 INPUT CHRS ELSE AWAIT BREAK
	TUUROM,,IONEOU	;3 OUTPUT CHARACTER
	TUUROM,,ACOTCI	;4 OUTPUT CHARACTER IMMEDIATE
	TUUROM,,OUTPTR	;5 OUTPUT FROM POINTER
	TSETBI		;6 CLEAR INPUT BUFFER
	TSETBO		;7 CLEAR OUTPUT BUFFER
	tuuair!tuueat!TUUFXI,,SKPINC	;10 SKIP IF CHRS PRESENT
	TUUFXI,,LEVDEF	;11 LEAVE DEFERRED ECHO MODE
	ACSYL		;12 SEND YELLOW BALL
	ACBRKC		;13 SET BREAK CHARACTER
	TCNCRD,,ACTMC	;14 CR DELAY (NOT LF)
	TCNIR,,ACTMC	;15 INPUT RATE
	TCNOR,,ACTMC	;16 OUTPUT RATE
	TCNPAR,,ACTMC	;17 PARITY
	TCNHDX,,ACTMC	;20 HALF DUPLEX
	TCNPA,,ACTMC	;21 PARAMETER A
	TCNPB,,ACTMC	;22 PARAMTER B
	TCNPC,,ACTMC	;23 PARAMETER C
	TCNNXO,,ACTMC	;24 SET NO XON-XOFF
	ACNTB		;25 SET NO SPECIAL TAB HANDLING
	ACTBK		;26 SET TABS AS BREAKS
	TCNWID,,ACTMC	;27 SET WIDTH
	TCNFC1,,ACTMC	;30 SET FILLER CLASS 1
	TCNFC2,,ACTMC	;31 SET FILLER CLASS 2
	SETIO2		;32 SET FILE STATUS, DON'T FIXIMI
	FRCINP		;33 FORCE INPUT
	BLKIO		;34 ENABLE BLOCK INPUT/OUTPUT
	TUUAIR!TUUEAT,,BLKINP ;35 INPUT A BLOCK
	TUUAIR!TUUEAT,,BLKINS ;36 INPUT BLOCK &SKIP IF DATA
	BLKOUT		;37 OUTPUT A BLOCK
	BLKXIN		;40 REQUEST BLOCK INPUT TERMINATION
	BLKXOT		;41 REQUEST BLOCK OUTPUT TERMINATION.
	BLKXIO		;42 TERMINATE BLOCK I/O MODE
	MAKDET		;43 TURN COMMAND PORT TO "AUX"PORT
	TUUEAT!TUUFXI,,I1CHRW		;44 INPUT CHRS AND WAIT
	TUUAIR!TUUEAT!TUUFXI,,INCHRS	;45 INPUT CHRS AND SKIP
	TUUEAT!TUUFXI,,I1CHWL		;46 INPUT CHRS AND WAIT LINE
	TUUAIR!TUUEAT!TUUFXI,,INCHSL	;47 INPUT CHRS AND SKIP LINE
	TUUAIR!TUUEAT!TUUFXI,,SKPINL	;50 SKIP IF LINE PRESENT
	TUUROM,,OUTCHI	;51 OUTPUT CHR IMMEDIATE (NOT IMAGE 
	TUUROM,,OUTSTR	;52 OUTPUT STRING
	TCNXON,,ACTMC	;53 SET XON-XOFF PARAMETER
	TCNECH,,ACTMC	;54 SET ECHO CONTROL H PARAMETER
	TCNRXE,,ACTMC	;55 SET REVERSE XON-XOFF PARAMTER
	TCNTYP,,ACTMC	;56 SET TERMINAL TYPE INFO PARAMTER
	TCNBSP,,ACTMC	;57 SEND BACKSPACE FOR RUBOUT SEQ
	ACHNG		;60 SEND HANGUP
	ACPSM		;61 READ PORT STATUS MESSAGE
	TCNERA,,ACTMC	;62 ERASE FOR CHAR DELETE
	TCNDEF,,ACTMC	;63 DEFERRED-ECHO MODE
	ACSFS		;64 SET FILE STATUS, THEN FIXIMI
	TCNLCO,,ACTMC	;65 SET/CLEAR LOWER CASE ONLY OUTPUT FLAG
	ACBBP		;66 SET BACKSPACE AS BREAK2
	TUUROM,,OUTPTC	;67 OUTPUT FROM POINTER+COUNT
	ACSOB		;70 SEND ORANGE BALL
	ACSOX		;71 SET/CLEAR SUPPRESS-OUTPUT-TRANSLATION
	FRCRSC		;72 FORCE A RESCAN LINE (COUNT/POINTER 
	ACTCN		;73 SET TERMINAL CHARACTERISTIC BY NUMBER
	ACTCP		;74 READ CHANGED TC #,,VAL FOR A PTY
	ACNZP		;75 NO-ZAP-ON-RESET BIT
	OUTSNW		;76 OUTPUT STRING, NEVER WAIT
	TCNBSD,,ACTMC	;77 BACKSPACE == RUBOUT/^A
	TCNTTP,,ACTMC	;100 Set/Read Terminal Type
	TCNRTC,,ACTMC	;101 Set/Clear LXLRTC (Special ^T Mode)
MAXAXC==.-AXCTAB-1
;READ/SET TERMINAL CHARACTERISTICS BY NUMBER

ACTCN:	XCTFU	<HLRZ T1, (M)>	;T1/ CHAR #
	XCTFU	<HRRE T2, (M)>	;T2/ NEW VALUE OR -1 TO READ
	PUSHJ	P, SETTCN	;TRY TO DO IT
	POPJ	P,		;(BAD TC# OR BAD NEW VALUE)
	XCTBU	<HRRM T3, (M)>	;GIVE USER THE OLD VALUE
	AOS	(P)
	POPJ	P,

;READ CHANGED TERMINAL CHARACTERISTIC FROM PTY

ACTCP:	HLL	U, LDBDCH(U)
	TLNN	U, LDLPTY	;IF IT'S NOT A PTY,
	POPJ	P,		;  ERROR-RETURN
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVE	T1, LDBTCB(U)	;T1/ CHANGED-TC BITS
	JFFO	T1, ACTCP1	;IF NONE,
	XCTTU	<SETOM (M)>	;  GIVE CALLER A -1 WORD
	JRST	ACTCP2
ACTCP1:	MOVN	T1, T2
	MOVSI	T4, (1B0)
	LSH	T4, (T1)
	ANDCAM	T4, LDBTCB(U)	;CLEAR THE "UNREAD" BIT
	MOVE	T1, T2		;T1/ TC#
	XCTBU	<HRLM T1,(M)>	;GIVE CALLER THE TC#
	SETO	T2,		;-1 => READ TC
	PUSHJ	P, SETTCN
	  STOPCD
	XCTBU	<HRRM T3,(M)>	;GIVE CALLER THE TC VALUE
ACTCP2:	POP	P, U
	JRST	CPOPJ1
;SETTCN -- READ/SET TERMINAL CHARACTERISTICS BY NUMBER
;	   CALLED WITH T1/ CHARACTERISTIC #
;		       T2/ NEW VALUE (-1 TO JUST READ)
;		       U/ LDB ADDR
;	   NONSKIP-RETURNS IF TC# OR NEW VALUE IS OUT OF BOUNDS
;	   SKIP-RETURNS WITH T3/ OLD VALUE OTHERWISE
;
;SETTC1 -- ASSUMES TC# IS IN BOUNDS

SETTCN:	CAIGE	T1, TCNN	;IF TC# OUT OF BOUNDS
SETTC1:	CAMLE	T2, TCVMAX(T1)	;OR NEW VALUE TOO BIG,
	POPJ	P,		;  ERROR-RETURN
	HRRZ	T3, TCNDSP(T1)
	PUSH	P, T1
	HRLM	T2, (P)		;(P)/ (NEW VALUE OR -1),,TC#
	PUSHJ	P, (T3)		;DISPATCH
	  JRST	TPOPJ		;  ERROR-RETURN
	MOVSI	T1, LDLPTY
	SKIPL	(P)		;IF WE WERE JUST READING
	TDNN	T1, LDBDCH(U)	;OR IT'S NOT A PTY,
	JRST	TPOPJ1		;  JUST SKIP-RETURN
	HRRZ	T1, (P)
	MOVN	T1, T1		;T1/ - TC#
	MOVSI	T2, (1B0)
	LSH	T2, (T1)	;T2/ LDBTCB BIT FOR THE TC
	IORM	T2, LDBTCB(U)	;SET IT
	MOVEM	T3, (P)
	PUSH	P, U
	PUSH	P, F
	PUSH	P, J
	PUSHJ	P, PTYBUD	;U/ BUDDY LDB ADDR
	MOVEI	T1, LXRTCC
	IORM	T1, LDBDCX(U)	;NOTE THAT A TC WAS CHANGED
	HRRZ	F, LDBDDB(U)
	JUMPE	F, SETTC2	;IF THE OTHER END IS ATTACHED
	LDB	T1, DDPTTC
	JUMPE	T1, SETTC2	;AND TRAPPING TC CHANGES
	PUSHJ	P, TAKTRJ	;  SIGNAL THE CHANGE
SETTC2:	POP	P, J
	POP	P, F
	POP	P, U
	POP	P, T3
	JRST	CPOPJ1

DEFINE Z(NAME,MAXVAL,TYPE,ARG) = <ARG,,TYPE>
TCNDSP:	TCHARS
; [dws] DEFINE Z(NAME,MAXVAL,TYPE,ARG) = <0,,MAXVAL>
DEFINE Z(NAME,MAXVAL,TYPE,ARG) = <MAXVAL>	; [dws]
TCVMAX:	TCHARS

BYTTC:	HLRZ	T1, TCNDSP(T1)	;T1/ BYTE POINTER ADDR
	LDB	T3, (T1)
	SKIPL	T2
	DPB	T2, (T1)
	JRST	CPOPJ1
;SETTCN ROUTINES

;TYMTC -- READ/SET TYMNET TERMINAL CHARACTERISTICS
;	  CALLED WITH T1/ CHARACTERISTIC #
;		      T2/ -1 (TO JUST READ) OR NEW VALUE
;	  SKIP-RETURNS WITH T3/ THE OLD VALUE
;TYMTC1 -- CALLED WITH T1/ TYMNET'S TC#

TYMTC:	HLRZ	T1, TCNDSP(T1)	;USER TC# => TYMNET TC#
TYMTC1:	CAILE	T1, MAXTMC	;IF OUT-OF-RANGE,
	  STOPCD		;  CRASH
	LDB	T3, TABTMR(T1)	;T3/ OLD VALUE
	JUMPL	T2, CPOPJ1	;IF JUST LOOKING, SUCCESS-RETURN
	DPB	T2, TABTMS(T1)	;STORE NEW VALUE
    ;1) MOST NODES DON'T UNDERSTAND (HENCE DON'T REFLECT) TERM. TYPE
    ;2) TYMNET TRANSMITS THE 4-BIT TERM. TYPE AS A 1-BIT FIELD
	CAIE	T1, TMCTYP	;IF IT'S TERMINAL TYPE,
	JRST	TYMTC2
	TRNN	T2, 1		;  SIMULATE TYMNET 1 BIT FIELD
	TDZA	T2, T2		;  EVEN => 0
	MOVEI	T2, 17		;  ODD => 17
	DPB	T2, TABTMR(T1)	;  PRETEND THE NODE REFLECTED IT
TYMTC2:	MOVNS	T1
	MOVSI	T2, (1B0)
	LSH	T2, (T1)	;GET BIT POSITIONED
	IORM	T2, LDBTMT(U)	;SET TRANSMIT BIT
	MOVEI	T1, 1
	DPB	T1, LOPSTC	;SET SEND-CHARACTERISTICS
	AOS	(P)		;skip return
SETOPB:	DPB	T1, LDBOPB(U)	;SET NEED-OUTPUT
	POPJ	P,
;SETTCN ROUTINES

;WIDTH

ACWIDC:	LDB	T3, LDPWID
	JUMPL	T2, CPOPJ1
	CAIL	T2, ^D20	;IF IT'S TOO SMALL
	CAILE	T2, ^D199	;OR TOO LARGE,
	POPJ	P,		;  ERROR-RETURN
	DPB	T2, LDPWID	;ELSE SET IT
	JRST	CPOPJ1

;BACKSPACE FOR DELETE

ACBSPC:	LDB	T3, LDPERA
	TRZN	T3, 1		;IF ERASE IS SET, SAY BS ISN'T
	LDB	T3, LDPBSP
	JUMPL	T2, CPOPJ1
	DPB	T2, LDPBSP
	SETZ	T2,
	DPB	T2, LDPERA	;ALWAYS CLEAR ERASE
	JRST	CPOPJ1

;ERASE FOR DELETE

ACERAC:	LDB	T3, LDPERA
	JUMPL	T2, CPOPJ1
	DPB	T2, LDPERA
	DPB	T2, LDPBSP	;EITHER SET BOTH OR CLEAR BOTH
	JRST	CPOPJ1

;DEFERRED ECHO

ACDEFC:	LDB	T3, LDPDEM
	JUMPL	T2, CPOPJ1
	MOVE	T1, LDBDCH(U)
	TRNE	T2, 1
	TROA	T1, LDRDEM
	TRZ	T1, LDRDEM
	EXCH	T1, LDBDCH(U)
	CAME	T1, LDBDCH(U)	;IF THE BIT CHANGED
	TLNE	T1, LDLNEC	;AND NO ECHO NOT SET,
	JRST	CPOPJ1
	MOVEI	T1, 1
	DPB	T1, LOPSEC	;  SET SEND-ECHO
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
	JRST	CPOPJ1
;SETTCN ROUTINES

;PAPER TAPE MODE

ACPTPC:	LDB	T3, LDPPTP
	JUMPL	T2, CPOPJ1
	DPB	T2, LDPPTP	;SET PAPER-TAPE BIT TO USER VALUE
	PUSH	P, T3
	TRC	T2, 1
	MOVEI	T1, TMCECR
	PUSHJ	P, TYMTC1	;AND CR-AS-CRLF TO ITS COMPLEMENT
	  STOPCD
	POP	P, T3
	JRST	CPOPJ1

;[dws] Terminal Type

ACTTPC:	LDB	T3,LDPTTP	; T3 := old value
	CAME	T2,[-1]		; Don't store if only reading
	  DPB	T2,LDPTTP	;  new valued := T2
	JRST	CPOPJ1
;NO SPECIAL TAB HANDLING

ACNTB:	LDB	T2, LDPNTB
	XCTBU	<EXCH T2,(M)>
	JUMPL	T2, CPOPJ
	DPB	T2, DDPNTB
	DPB	T2, LDPNTB
	POPJ	P,

;TABS AS BREAKS

ACTBK:	LDB	T2, LDPTBK
	XCTBU	<EXCH T2,(M)>
	JUMPL	T2, CPOPJ
	DPB	T2, DDPTBK
	MOVEI	T1, L2LTBK
	TRNE	T2, 1		;CHECK LOW ORDER BIT
	HRLI	T1, L2LTBK
	PJRST	SETTBK		;GO SET IT

;BACKSPACE AS PUNCTUATION

ACBBP:	LDB	T2, LDPBBP
	XCTBU	<EXCH T2,(M)>
	JUMPL	T2, CPOPJ
	DPB	T2, DDPBBP
	MOVEI	T1, L2LBBP
	TRNE	T2, 1		;CHECK LOW ORDER BIT
	HRLI	T1, L2LBBP
	PJRST	SETTBK		;GO SET IT
;SUPPRESS-OUTPUT-TRANSLATION (FOR PTYS ONLY)

ACSOX:	HLL	U, LDBDCH(U)
	TLNN	U, LDLPTY	;IF IT'S NOT A PTY,
	POPJ	P,		;  JUST RETURN
	PUSH	P, U
	PUSHJ	P, PTYBUD	;U/ "BUDDY" LDB ADDR
	LDB	T1, LDPSOX	;T1/ CURRENT SOX VALUE
	XCTBU	<EXCH T1,(M)>	;SWAP WITH ARGUMENT
	JUMPL	T1, .+2		;IF USER SUPPLIED A NEW VALUE,
	DPB	T1, LDPSOX	;  SET IT
	POP	P, U
	POPJ	P,

;READ/SET DVNZP BIT

ACNZP:	LDB	T1, DDPNZP	;T1/ CURRENT VALUE
	XCTBU	<EXCH T1, (M)>	;SWAP WITH USER'S
	JUMPL	T1, CPOPJ	;(JUST READING)
	DPB	T1, DDPNZP	;SET IT
	POPJ	P,
;OLD AUXCAL TERMINAL-CHARACTERISTICS DISPATCH

ACTMC:	HLRZ	T1, T3		;T1/ CHARACTERISTIC #
	XCTFU	<MOVE T2, (M)>	;T2/ USER'S ARGUMENT
	PUSHJ	P, SETTC1	;T3 := OLD VALUE
	  JFCL			;(NEW VALUE WAS BAD)
	XCTTU	<MOVEM T3, (M)>	;STORE IT
	POPJ	P,

;SET FILE STATUS BITS, THEN FIX IMAGE STATE

ACSFS:	PUSHJ	P, SETIO2
	HRR	U, DDBLDB(F)
	MOVE	S, DEVIOS(F)
	PJRST	FIXIMI

;SEND YELLOW BALL

ACSYL:	MOVEI T1,1
	DPB T1,LOPSYL		;SET SEND-YELLOW
	PJRST SETOPB

;SEND ORANGE BALL

ACSOB:	MOVE	T1, LDBDCX(U)
	TLZN	T1, LXLOOK	;IF IT'S OK TO SEND 1,
	  POPJ	P,
	MOVEM	T1, LDBDCX(U)	;  (NOT 2, JUST 1)
	MOVSI	T1, L2LLDF
	IORM	T1, LDBBYT(U)	;  FAKE INPUT WAIT SO BALL'LL GO
	MOVEI	T1, 1
	DPB	T1, LOPSOG	;  SET SEND-ORANGE
	PJRST	SETOPB

;SEND HANGUP (SOFT ZAPPER)

ACHNG:	MOVEI	T1, 1
	DPB	T1, LOPHNG	;SET SEND-HANG
	PJRST	SETOPB

;READ LAST PORT STATUS MESSAGE

ACPSM:	LDB	T1, LDPPSM	; GET LAST PORT STATUS MSG
	UMOVEM	T1, (M)		; GIVE IT TO HIM
	MOVSI	T1, LMLPSP
	ANDCAM	T1, LDBMOD(U)	; AND NOTE IT'S BEEN READ
	POPJ	P,
;SET IMAGE BREAK CHARACTER

ACBRKC:	UMOVE	T1, (M)
	TRNN	T1, 400		;IF IMAGE BIT NOT ON,
	SETZ	T1,		;  CLEAR THE CHARACTER
	DPB	T1, LDPIMB
	DPB	T1, DDPIMB
	POPJ	P,
;IMAGE-STATE INPUT AUXCALS

ACINWC:	NOCHARGE
ACIN1:	PUSHJ P,TWAITC	;THIS WILL SET MODE TO IMAGE
	PUSHJ P,TYI
	 JRST ACIN1	;TRY AGAIN
ACIN2:	ANDI T3,377
	UMOVEM T3,(M)
	AOS (P)		;SKIP RETURN (AS OPPOSED TO NO PORT)
	JRST NOCTRO

ACINSC:	NOCHARGE
	SKIPG LDBECC(U)	;ANY CHRS?
	SKIPLE LDBTIC(U)
	SKIPA		;YES
	JRST SETLMD	;NO, SET TO IMAGE ANYWAY
	PUSHJ P,TWAITS
	  POPJ	P,	;DETACHED
	PUSHJ P,TYI
	 JRST NOCTRO	;NONE THERE
	JRST ACIN2	;GIVE IT TO HIM

ACINWB:	NOCHARGE
	PUSHJ P,TWAITL	;WAIT FOR IMAGE-MODE BREAK CHARACTER OR TIMEOUT
	PUSHJ P,TYI
	 POPJ P,	;PROBABLY END OF FILE SET
	JRST ACIN2	;GIVE HIM CHR
;STUFF INPUT BUFFER

FRCINP:	UMOVE M,(M)	;GET BYTE POINTER
	TLZ M,37	;GET RID OF INDEX AND INDIRECT
FRCLP1:	XCTFU <ILDB T3,M>
	ANDI T3, 377	; USE ONLY THE RIGHT 8 BITS
	JUMPE T3,CPOPJ1		;FINISHED
	PUSHJ P,MOVCHR	;PUT CHR IN INPUT RING
	 JRST FRCLP1
FRCLP2:	XCTFU <ILDB T3,M>	;LOOP HERE FOR DEFERED ECHO MODE
	ANDI T3, 377	; USE ONLY THE RIGHT 8 BITS
	JUMPE T3,FRCLP3	;REMEMBER TO SET FOR OUTPUT
	PUSHJ P,MOVCHR
	 JRST FRCLP2
	JRST FRCLP2	;LOOP IN EITHER CASE
FRCLP3:	AOS (P)		;SKIP RETURN
	MOVEI T1,1
	DPB T1,LOPECO	;SET NEED-ECHO
	DPB T1,LDBOPB(U);AND NEED-OUTPUT
	POPJ P,
;FORCE A RESCAN LINE

INTEGER FRSFLG	;FLAG FOR CMDWAK (SO IT'LL KNOW IT'S NOT A REAL CMND)
INTEGER FRSDEF	;FLAG TO REMEMBER DEFERRED-ECHO STATE

%FROK==0	;NO ERROR
%FRAUX==1	;PORT IS AN AUX CIRCUIT
%FRBIG==2	;COMMAND STRING IS TOO BIG
%FRCMD==3	;PORT IS IN COMMAND STATE
%FRBRK==4	;BREAK BEFORE END OF COMMAND STRING (BYTE PTR UPDATED)
%FRNBK==5	;NO BREAK ENCOUNTERED IN STRING
%FRFUL==6	;RESCAN COMMAND ALREADY PRESENT

FRCRSC:	HLL	U, LDBDCH(U)
	TLNE	U, LDLAUX	;IF PORT IS AN AUX CIRCUIT,
	JRST	[
		MOVEI	P1, %FRAUX
		JRST	FRCRSX	;  ERROR-RETURN
	]
	TLNE	U, LDLCOM	;IF PORT IS IN COMMAND STATE,
	JRST	[
		MOVEI	P1, %FRCMD
		JRST	FRCRSX	;  ERROR-RETURN
	]
	XCTFU	<MOVE P1, 0(M)>	;P1/ COUNT
	CAIL	P1, TIWKC	;IF IT'S TOO BIG,
	JRST	[
		MOVEI	P1, %FRBIG
		JRST	FRCRSX	;  ERROR-RETURN
	]
FRCRS1:	MOVE	T1, P1
	ADDI	T1, <<<TTCHKS-1>*4>-1>
	IDIVI	T1, <<TTCHKS-1>*4>	;T1/ # CHUNKS NEEDED
	MOVE	T2, TTFREN
	SUBI	T2, TIRSVD	;T2/ # CHUNKS AVAILABLE
	CAMG	T1, T2		;IF THERE AREN'T ENOUGH,
	JRST	FRCRS2
	MOVSI	S, TWTSPC
	IORB	S, DEVIOS(F)	;  NOTE THAT WE NEED MORE ROOM
	LDB	T1, DDPTTI	;  T1/ IOW-INTERRUPT ASSIGNMENT
	PUSHJ	P, TSTKTJ	;  IF HE TRAPPED IT,
	JRST	[
		PUSHJ	P, SETFIO	;SET TO GIVE I/O DONE TRAP
		PJRST	ABTUUO		;AND GET OUT
	]
	PUSH	P, P1
	PUSHJ	P, TOWAT1	;  GO INTO OUTPUT WAIT
	POP	P, P1
	JRST	FRCRS1		;  THEN TRY AGAIN
FRCRS2:	PUSHJ	P, TSETBI	;CLEAR THE INPUT BUFFER (!)
	HLL	U, LDBDCH(U)
	SKIPE	FRSFLG
	  STOPCD
	SETOM	FRSFLG		;SET FLAG FOR CMDPGAK
	TLO	U, LDLCOM	;SET COMMAND STATE
	SETZM	FRSDEF
	TLZE	U, LDLDEF	;CLEAR DEFERRED-ECHO
	SETOM	FRSDEF		;(REMEMBER PGHAT IT PGAS)
	HLLM	U, LDBDCH(U)
	PUSHJ	P, SETLMD	;FIX LINE-MODE FIELD

    ;HERE TO ACTUALLY FORCE THE INPUT
    ;P1/ COUNT

	XCTFU	<MOVE PG, 1(M)>	;PG/ BYTE POINTER
	TLZ	PG, 37		;CLEAR INDEX AND INDIRECT BITS
	PUSH	P, P1		;0(P)/ COUNT

FRCRS3:	SOSGE	0(P)		;DONE?
	JRST	FRCRS4		;(YES)
	XCTFU	<ILDB T3, PG>	;T3/ NEXT CHARACTER
	ANDI	T3, 377		;(ONLY 8 BITS)
	PUSHJ	P, MOVCHR	;DEPOSIT IT
	JRST	.+1		;(REMOTE-ECHO RETURN)
	SKIPE	FRSFLG		;IF CMDPGAK NOT CALLED YET,
	JRST	FRCRS3		;  TRY THE NEXT CHARACTER

    ;HERE PGHEN A "COMMAND LINE" HAS BEEN FORCED

	POP	P, T1		;T1/ COUNT LEFT
	JUMPE	T1, FRCRS5	;IF THERE'RE CHARS AFTER THE BREAK,
	XCTTU	<MOVEM PG, 1(M)>;  STORE BACK THE MODIFIED BYTE POINTER
	MOVEI	P1, %FRBRK	;  ERROR-RETURN
	JRST	FRCRS6

    ;HERE WHEN WE RAN OUT OF CHARACTERS BEFORE A "COMMAND LINE"
    ;WAS FINISHED

FRCRS4:	POP	P, T1
	SETZM	FRSFLG		;CLEAR FLAG
	MOVEI	P1, %FRNBK	;ERROR-RETURN
	JRST	FRCRS6

    ;HERE WHEN THINGS WERE JUST RIGHT

FRCRS5:	MOVEI	P1, %FROK
	;JRST	FRCRS6
    ;CLEAN THINGS UP

FRCRS6:	SKIPN	FRSDEF		;IF PORT WAS IN DEFERRED ECHO MODE,
	JRST	FRCRS7
	MOVSI	T1, LDLDEF
	IORM	T1, LDBDCH(U)	;  SET DEFERRED-ECHO AGAIN
FRCRS7:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	;CLEAR COMMAND MODE
	MOVSI	T1, LDLECS
	IORM	T1, LDBDCH(U)	;SET EAT-COMMAND-SYNC
	PUSHJ	P, SETLMD	;FIX LINE-MODE FIELD

FRCRSX:	SKIPN	P1		;IF NO ERROR OCCURRED,
	AOSA	(P)		;  PREPARE FOR SKIP-RETURN, ELSE
	XCTTU	<MOVEM P1, (W)>	;  USER AC := RETURN CODE
	POPJ	P,
SUBTTL AUXILIARY CIRCUITS

;ONLY ONE AUXILIARY CIRCUIT IS IN THE PROCESS OF BEING BUILT
;AT ANY ONE TIME. JOBS WANTING TO BUILD AN AUX.
;CIRCUIT ARE QUEUED ON THE AX QUE. ONCE A CIRCUIT IS READY TO
;BE BUILT, THE COMMUNICATION WITH THE SUPERVISOR IS
;CONTROLED BY A STATE CELL (AUXSTA). THE FOLLOWING ARE THE STATES

.ASIDL==0	;NOT BUILDING A CIRCUIT
.ASRQ1==1	;READY TO SEND SUPERVISOR REQUEST
.ASWR1==2	;WAITING FOR SUPERVISOR RESOPNSE
.ASRQ2==3	;READY TO RE-SEND SUPERVISOR REQUEST
		;(BECAUSE OF ERROR ON FIRST TRY -- PROBABLY
		;COMMUNICATION IS OUT OF SYNC)
.ASWR2==4	;WAITING FOR SUPERVISOR RESPONSE TO RE-SEND
.ASLOG==5	;SENDING LOGIN STRING TO SUPERVISOR
.ASWPT==6	;WAITING FOR A PORT AND A SUPERVISOR RESPONSE

;ERROR NUMBERS FROM THE PDP-10

CX2AX%==1	;TOO MANY AUX CIRCUITS FOR THIS JOB AND NO
		;AC LICENSE

CXLOG%==2	;USER NAMES DO NOT MATCH AND NO AC LICENSE
CXDCB%==3	;NO DDB'S AVAILABLE
CXNRR%==4	;NO RESPONSE TO FIRST REQUEST
CXNRL%==5	;NO RESPONSE AFTER STRING SENT
CXNCH%==6	;NO PORT RECEIVED
CXERR%==7	;ERROR FROM FIRST RESPONSE

;SPECIAL ROUTINE WHEN COMMING OUT OF IO WAIT FINDS
;AN AUX CIRCUIT ZAPPED

AUXRID:	MOVEI T1,ASSCON!ASSPRG
	TDNN T1,DEVMOD(F)	;STILL ASSIGNED?
	PUSHJ P,TTYKDB		;NO, REMOVE DDB
	JRST ABTUUO		;IN ANY CASE, ABORT
;TURN THE COMMAND PORT INTO SOMETHING LIKE AN "AUX" PORT

MAKDET:	MOVSI T1,TTYATC
	TDNN T1,DEVMOD(F)
	POPJ P,
	JUMPE U,CPOPJ	;DO NOT ALLOW IF NOT COMMAND OR DET
	MOVSI T1,LLLZAP
	TDNE T1,LDBLOG(U)
	POPJ P,		;OR IF WAITING TO LOG OUT
	MOVSI T1,LICAC
	TDNE T1,JBTLIC(J)
	JRST MAKDLC	;MUST HAVE LIC OR ONLY ONE OTHER PORT
	PUSHJ P,FRSTTY
	 JRST MAKDLC
	PUSHJ P,NXTTTY
	 JRST MAKDLC
	PUSHJ P,NXTTTY
	 JRST MAKDLC
	POPJ P,
MAKDLC:	HRRZ F,TTYTAB(J)
	HLRZ T1,DDBBLK(F)
	PUSHJ P,DDBSR1	;GET ONE AND LINK IT IN
	 POPJ P,		;CAN NOT
	HRRZ T2,TTYTAB(J)
	HRRM F,TTYTAB(J)	;MAKE A NEW COMMAND PORT
	MOVSI T1,DVNZP
	IORM T1,DEVMOD(T2)	;DO NOT ALLOW TTY TO BE ZAPPED
	MOVSI T1,TTYATC
	ANDCAM T1,DEVMOD(T2)
	HRRI T1,ASSCON
	IORM T1,DEVMOD(F)
	DPB J,PJOBN
	PUSHJ P,SCNNAM	;THAT SHOULD BE ENOUUHH
	HRRZS DEVNAM(F)		;SO LOOKS DETACHED
	HRRZ F,T2
	MOVE S,DEVIOS(F)
	HRRZ U,DDBLDB(F)
	MOVSI T2,LDLCOM
	ANDCAM T2,LDBDCH(U)
	AOS (P)
	LDB T1,LDPLNO
	UMOVEM T1,(M)
	PJRST UUOLDB
;HERE FROM HANG UUO WHEN HANGING AN AUX CIRCUIT

HNGAUX:	HRRZ	F, LDBDDB(U)
	JUMPE	F, HNGAXD	;IF IT'S ATTACHED,
HNGAX1:	LDB	T1, DDPTZP
	PUSHJ	P, TAKTRJ	;  INTERRUPT ITS OWNER
	MOVEI	T2, ASSCON
	PJRST	RELEA6		;  AND CLEAR ASSIGNED-BY-CONSOLE

    ;HERE WHEN PORT IS ALREADY DETACHED

HNGAXD:	PUSHJ	P, TTYZAP	;SET TO SEND A ZAPPER BACK
	HRRZS	U		;CLEAR LDBDCH BITS
	CAME	U, AUXRCP	;IF IT'S THE RECEIVED AUX PORT,
	JRST	HNGAX4
	SETOM	AUXRCP		;  SAY WE HAVEN'T RECEIVED ONE
	AOS	ZRPCNT		;  AND NOTE THAT WE DID SO
HNGAX4:	POPJ	P,

;HERE WHEN A ZAPPER IS RECEIVED ON AN AUX PORT

ZAPAUX:	HRRZ	F, LDBDDB(U)	;F/ DDB ADDR
	JUMPE	F, HNGAXD	;IF DETACHED, JUST CHECK "RECEIVED" PORT
	PUSHJ	P, TTYZAP	;SET TO SEND ZAPPER
	HLLZS	DDBLDB(F)	;DETACH IT
	HLLZS	LDBDDB(U)
	JRST	HNGAX1		;INTERRUPT JOB, CLEAR ASSCON

;HERE FROM RELEA6 WHEN BOTH ASSCON AND ASSPRG GO OFF

AUXZAP:	HRRZ	U, DDBLDB(F)
	JUMPE	U, AXZP1	;IF DDB HAS A PORT ATTACHED,
	PUSHJ	P, TTYZAP	;  SET TO SEND ZAPPER
	HLLZS	DDBLDB(F)
	HLLZS	LDBDDB(U)	;  DETACH IT
AXZP1:	HRRZS	DEVNAM(F)	;MARK NAME AS DETACHED
	MOVSI	T1, TIOUSE
	TDNN	T1, DEVIOS(F)	;IF NO UUO IS IN PROGRESS,
	PJRST	TTYKDB		;  KILL THE DDB
	MOVE	S, DEVIOS(F)	;OTHERWISE,
	PJRST	TIWAKE		;  JUST WAKE THE JOB
;ON RECEIPT OF A TAKEOVER MESSAGE, RESET AND TRY AGAIN

RCVNSP:	SKIPN AUXSTA
	AOJA P4,SCNIN1	;IN IDLE STATE, JUST IGNORE
	SKIPL U,AUXRCP	;PORT RECEIVED?
	PUSHJ P,TTYZAP	;YES, ZAP IT
	MOVEI T1,.ASRQ1
	MOVEM T1,AUXSTA
	AOJA P4,SCNIN1	;READY TO SEND FIRST REQUEST
;SUPERVISOR RESPONSE RECIVED

RCVSUR:	MOVE T1,AUXSTA
	XCT ARSTAB(T1)

ARSTAB:	AOJA P4,SCNIN1	;.ASIDL IGNORE
	AOJA P4,SCNIN1	;.ASRQ1 IGNORE
	JRST RCVS2	;.ASWR1 RESPONSE TO 1ST REQUEST
	AOJA P4,SCNIN1	;.ASRQ2 IGNORE
	JRST RCVS4	;.ASWR2 RESPONSE TO 2ND REQUEST
	AOJA P4,SCNIN1	;.ASLOG IGNORE
	JRST RCVS6	;.ASWPT RESPONSE TO LOGIN

    ;SUPERVISOR RESPONSE TO FIRST REQUEST

RCVS2:	LDB T1,INPCHR	;GET ERROR CODE
	JUMPN T1,[AOS AUXSTA	;ON ERROR, STATE:=.AXRQ2 (RETRY)
		AOJA P4,SCNIN1]
RCVS2A:	MOVE T1,[POINT 7,AUXSTR]
	MOVEM T1,AUXSTP
	MOVEI T1,.ASLOG
	MOVEM T1,AUXSTA	;SUCCESSFUL RESPONSE: SEND LOGIN STRING
	AOJA P4,SCNIN1

  ;SUPERVISOR RESPONSE TO RE-REQUEST

RCVS4:	LDB T1,INPCHR	;LIKE 1ST REQUEST BUT ERROR IS FATAL
	JUMPE T1,RCVS2A	;NO ERROR
	HRLI T1,CXERR%	;SET ERROR TYPE
	PUSHJ P,ERRXIT	;AND CLEAN UP
	AOJA P4,SCNIN1

    ;SUPERVISOR RESPONSE TO LOGIN STRING

RCVS6:	LDB T1,INPCHR
	JUMPN T1,[PUSHJ P,ERRXIT;ERROR, TELL USER
		AOJA P4,SCNIN1]	;AND CLEAN UP
	PUSHJ P,AUXWAK	;WAKE UP THE USER
	AOJA P4,SCNIN1

ERRXIT:	MOVEM T1,AUXERR	;SAVE ERROR
	SKIPL U,AUXRCP	;IS THERE A PORT
	PUSHJ P,TTYZAP	;YES, ZAP IT
AUXWAK:	SETZM AUXSTA	;STATE:=.ASIDL (IDLE)
	MOVE J,AUXJOB	;JOB WAITING
	MOVEI T1,RNQ
	DPB T1,PJBSTS
	PJRST SETRUN	;RESTART HIM FOM MLOWQ
; MESSAGE 7 -- AN AUX CIRCUIT HAS BEEN BUILT TO <U> FOR
;	       THE JOB WHOSE COMMAND PORT IS <INPCHR>

RCVAUX:	SKIPE	LDBLOG(U)	; LOGGING OR LOGGED IN?
	JRST	ZAPLOG		; SHOULDN'T BE
	MOVE	T1, AUXSTA	; T1/ STATE
	CAIN	T1, .ASWPT	; IF WE'RE NOT EXPECTING A TYPE 7,
	JRST	AUXINP
	;JRST	AUXWST		;   NOTE THE ERROR

AUXWST:	; MESSAGE RECEIVED IN WRONG STATE
	AOS	AUXWSC		; NOTE THE FACT
	JRST	AUXZPT		; TREAT MSG AS A ZAPPER

AUXWPN:	; MESSAGE RECEIVED BUT WITH THE WRONG PORT NUMBER
	AOS	AUXWPC		; NOTE THE FACT
	MOVEM	T1, AUXWPT	; SAVE THE (BAD) PORT'S LDB ADDR
       ;JRST	AUXZPT		; TREAT MSG AS A ZAPPER

AUXZPT:	PUSHJ	P, TTYZAP	; ARRANGE TO SEND ZAPPER
	AOJA	P4, SCNIN1

AUXINP:	LDB	T1, INPCHR	; T1/ CREATING JOB'S PORT #
	CAME	T1, AUXPRT	; IS IT CORRECT?
	JRST	AUXWPN		; NO
	HRRZM	U, AUXRCP	; SAVE THE LINE POINTER
	MOVSI	T1, 400000
	MOVEM	T1, LDBLOG(U)	; SET LOGGED-IN BIT

	; INITIALIZE THE LINE
	SETZM	LDBOUT(U)
	SETZM	LDBBYT(U)
	SETZM	LDBMOD(U)
	SETZM	LDBTMT(U)
	ZZN==0
	REPEAT TMCSIZ,<SETZM LDBTMR+ZZN(U)
	ZZN==ZZN+1>
	MOVSI	T1, LDLDEF!LDLIMI!LDLAUX!LDLNEC!LDLNFC
	MOVEM	T1, LDBDCH(U)
	MOVSI	T1, LXL120
	MOVEM	T1, LDBDCX(U)

	PUSHJ	P, SETLMD	; SET THE INPUT MODE
	AOJA	P4, SCNIN1
;CALLED ONCE A TICK FROM SCNINT TO PROCESS AUX CIRCUIT BUILDS

SNDAUX:	MOVE T1,AUXSTA	;SEE WHAT WE SHOULD DO
	XCT AXSNTB(T1)
	JRST AUXTOV	;TIME OUT
	JRST CPOPJ1	;JUST RETURN

AXSNTB:	JRST CPOPJ1	;.ASIDL  DO NOTHING
	JRST SNDSRQ	;.ASRQ1  SEND 1ST REQUEST
	SOSG AUXTIM	;.ASWR1  TIME THE RESPONSE
	JRST SNDSRQ	;.ASRQ2  SEND 2ND REQUEST
	SOSG AUXTIM	;.ASWR2  TIME THE RESPONSE
	JRST AUXCHR	;.ASLOG  SEND LOGIN STRING
	SOSG AUXTIM	;.ASWPT  TIME THE RESPONSE

AUXTMR:	^D150*^D60	;REQUEST RESPONSE TIMEOUT
AUXTMP:	^D150*^D60	;PORT RESPONSE TIMEOUT

    ;HERE TO SEND A SUPERVISOR REQUEST

SNDSRQ:	PUSHJ P,CLSCHR
	 POPJ P,	;NOT REALLY ANY ROOM
	MOVSI P3,TYPI TYPSUP	;SEND REQUEST
	MOVE T1,AUXPRT	;GET THE PORT NUMBER
	DPB T1,WRPLIN
	MOVE T1,AUXTMR	;SET TIMER
	MOVEM T1,AUXTIM
	AOS AUXSTA	;ADVANCE STATE (.ASRQX => .ASWTX)
	JRST WRDOUT	;AND SEND REQUEST
    ;HERE TO SEND CHARACTERS FROM THE LOGIN STRING

AUXCHR:	PUSHJ P,CLSCHR
	 POPJ P,	;NO ROOM
	MOVSI P3,TYPI TYPAXC
	MOVE T1,AUXPRT
	DPB T1,WRPLIN	;SET UP TO SEND
AXCLP1:	MOVE T2,MXMCNT	;SPACE LEFT
	ADDI T2,2
	LSH T2,-2
AUXCLP:	ILDB T1,AUXSTP
	JUMPE T1,AXCDON	;FINISHED
	DPB T1,WRPCHR
	MOVEM P3,ORING(P4)	;PUT IN RING
	SOJLE T2,AXCLP2		;RAN OUT OF ROOM
	AOJA P4,AUXCLP	;ADVANCE POINTER AND CONTINUE

AXCLP2:	ADDI P4,1	;ADVANCE POINTER
	ANDI P4,MSKORG
	MOVE T1,AUXSTP
	ILDB T1,T1	;GET NEXT CHARACTER
	JUMPE T1,AXCDON	;HAVE REALLY SENT THEM ALL
	MOVEM P4,ORPPDP	;SAVE POINTER FOR 620
	PUSHJ P,SETOUT
	 POPJ P,	;OUT OF ROOM
	JRST AXCLP1	;MORE ROOM, SEND MORE

AXCDON:	MOVEM P4,ORPPDP
	MOVE T1,AUXTMP
	MOVEM T1,AUXTIM	;SET TIMER
	AOS AUXSTA	;STATE:=.ASWPT (WAIT FOR PORT RESPONSE)
	PJRST SETOUT	;RESET ROOM COUNTERS AND EXIT

    ;HERE ON ANY TIMEOUT

AUXTOV:	AOS (P)		;SET FOR SKIP RETURN
	MOVE T1,AUXSTA
	XCT AXTOTB(T1)	;RESPOND ACCORDING TO WHAT GOT TIMED-OUT

AXTOTB:	STOPCD		;.ASIDL  CAN'T TIME OUT
	STOPCD		;.ASRQ1  CAN'T TIME OUT
	JRST AXNRR	;.ASWT1  1ST REQUEST TIMED OUT
	STOPCD		;.ASRQ2  CAN'T TIME OUT
	JRST AXNRR	;.ASWT2  2ND RESPONSE TIMED OUT
	STOPCD		;.ASLOG  CAN'T TIME OUT
	JRST AXNRL	;.ASWPT  PORT RESPONSE TIMED OUT

AXNRR:	MOVSI T1,CXNRR%	;SET ERROR CODE
	PJRST ERRXIT

AXNRL:	MOVSI T1,CXNRL%
	PJRST ERRXIT
;CODE TO HANDLE THE CREAT AUX CIR UUO

EXTERN	ACTWRT
INTERN  AUXSTR,AUXEND,AUXSTM
AUXSTM==^D29			;MAX NUMBER OF CHRS ALLOWED IN STRING
IFCPU(<KI,KL>),<CXDTP==0>
IFCPU(<KS,F3>),<CXDTP==1>

CREAUX:	AOSE AXREQ
	PUSHJ P,AXWAIT	;WAIT FOR RESOURCE
	SETZM AXSWT
	MOVEI T2,AXGIV
	MOVEM T2,JBTABT(J)	;SET ERROR LOCATION
	SETZM AUXERR	;NO ERROR YET
	SETOM AUXRCP	;AND NO PORT
	HRRZ	F, TTYTAB(J)
	JUMPE	F, AUXDET	;IF NO JOB (!)
	HRRZ	U, DDBLDB(F)
	JUMPE	U, AUXDET	;OR NOT ATTACHED
	MOVSI	T2, LDLPTY
	TDNE	T2, LDBDCH(U)	;OR CONTROLLED BY A PTY,
	JRST	AUXDET
IFNKMC<	LDB	U, LDPLNO
	SKIPA>;IFNKMC.END	;DON'T SET TO CMD PORT IF KMC.
AUXDET:	MOVEI	U, CXDTP	;  FAKE A PORT NUMBER
	MOVEM U,AUXPRT
	MOVEM J,AUXJOB	;SET JOB NUMBER
	MOVE P1,T1	;SAVE ARGUMENT
	HRLI T1,(POINT 7,0)	;GET POINTER TO THE STRING
	MOVE P4,[POINT 7,AUXSTR]	;SET TO SAVE IT
	MOVEI P3,AUXSTM	;MAX WE CAN HAVE
	MOVE T4,[POINT 6,AUXUNM]	;SET TO ACCUMULATE A USER NAME
	MOVEI P2,^D12	;MAX CHRS IN USER NAME
	SETZM AUXUNM
	SETZM AUXUNM+1
AUXSLP:	XCTFU <ILDB T2,T1>	;GET CHR
	JUMPE T2,AXSFN1		;END OF STRING
	IDPB T2,P4		;PUT IT AWAY
	CAIE T2,15
	CAIN T2,";"		;TERMINATE ON RETURN OR ;
	JRST AXSFIN
	CAIN T2,":"	;TERMINATE USER NAME ON :
	MOVEI T4,0	;BY ZAPPING POINTER
	SOJL P2,AUXNSB	;ALREADY TOO MANY CHRS IN USER NAME
	SUBI T2,40	;CONVERT TO SIXBIT
	IDPB T2,T4	;AND SAVE IT
AUXNSB:	SOJG P3,AUXSLP	;SEE IF ROOM FOR MORE
AXSFN1:	MOVEI T2,15
	IDPB T2,P4	;TOO MANY, FINISH WITH RETURN
AXSFIN:	MOVEI T2,0
	IDPB T2,P4	;TERMINAT STRING WITH 0
        HRRZM   P4,AUXEND#      ;SAVE POINTER TO LAST WORD OF LOGIN STRING
        HRRZ    T3,P4           ;ZERO OUT LAST WORD OF LOGIN
        IDPB    T2,P4           ; STRING TO RIGHT OF NULL
        CAIN    T3,(P4)         ; SO THAT CREAUX STREAM
        JRST    .-2             ; RECORDS LOOK GOOD
	MOVSI T2,LICAC
	TDNE T2,JBTLIC(J)	;SEE IF HE HAS LICENSE
	JRST AUXLIC	;YES
	MOVE T2,AUXUNM
	MOVE T3,AUXUNM+1
	CAMN T2,JBTUNM(J)	;CHECK USER NAME MATCH
	CAME T3,JBTUN1(J)
	JRST	[MOVSI T2,CXLOG%
		JRST AXERGV]	;ERROR
	PUSHJ P,FRSTTY	;NOW SEE HOW MANY CIRCUITS
	 JRST AUXLIC
	PUSHJ P,NXTTTY
	 JRST AUXLIC	;NONE
	PUSHJ P,NXTTTY
	 JRST AUXLIC	;ONE
	MOVSI T2,CX2AX%
	JRST AXERGV
AUXLIC:
IFKMC<	LDB T3,[POINT 2,P1,2]	;GET TYMBASE NUMBER
	PUSHJ P,KMCGUP		;T1/ TYMBASE "UP" BITS
	MOVSI T2,^D8		;TYMBASE DOWN MESSAGE
	XCT	TSTDRU(T3)	;SKIP IF IT'S UP
	  JRST AXERGV		;ELSE RETURN TYMBASE DOWN MESSAGE
	JRST AUXDRU

TSTDRU:	TRZN	T1,DR1BIT
	TRZN	T1,DR2BIT
	TRZN	T1,DR3BIT
	TRZN	T1,DR4BIT

AUXDRU:	LSH T3,6
	IORM T3,AUXPRT
>;END_IFKMC
	MOVEI T1,MLOWQ
	DPB T1,PJBSTS
	AOS AUXSTA	;SET STATE TO 1
	PUSHJ P,WSCHED	;AND RESCHEDULE
	SKIPE T2,AUXERR	;ANY ERRORS
	JRST AXERGV
	SKIPGE AUXRCP	;PORT THERE?
	JRST	[
		AOS	NRPCNT	;BUMP COUNT
		MOVSI	T2, CXNCH%
		JRST	AXERGV	;ERROR-RETURN
	]
	HRRZ T1,TTYTAB(J)	;WHERE TO LINK. REALLY SHOULD BE A DDB
	SKIPE T1
	PUSHJ P,DDBSR1
	 JRST	[MOVSI T2,CXDCB%	;NO DDB SPACE
		JRST AXERGV]
	DPB J,PJOBN
	MOVEI T1,ASSCON
	TLNE P1,1
	TLO T1,DVNZP	;SET NO ZAP BIT
	IORM T1,DEVMOD(F)
	MOVE U,AUXRCP
	LDB T1,LDPLNO	;GET LINE NUMBER
	UMOVEM T1,(W)
	HRRM U,DDBLDB(F)
	HRRM F,LDBDDB(U)
	PUSHJ P,SCNNAM
	MOVEI	T1,22		;WRITE CREAUX
	PUSHJ	P,ACTWRT	; STREAM RECORD
	AOS (P)
	JRST AUXGV1	;FINISHED
AXERGV:	UMOVEM T2,(W)
AXELOG:	JRST	AXGIV		;JFCL IF WANT ACT REC FOR ERRS
	MOVEM	T2,AUXERR	;SAVE ERR TYPE FOR ACTSER
	MOVEI	T1,22		;CREAUX REC TYPE
	HLRZS	T2		;WRITE REC ONLY
	SKIPE	T2		; FOR EXTRA
	CAIN	T2,CXNCH%	; HOST ERRORS
	PUSHJ	P,ACTWRT
AXGIV:	SKIPL U,AUXRCP
	PUSHJ P,TTYZAP
AUXGV1:	SETZM JBTABT(J)
	SETZM AUXSTA
	SOSL AXREQ
	SETOM AXAVAL
	POPJ P,
;READ INFO ON PORTS IN USE

AUXRED:	MOVEI T2,0	;NUMBER OF PORTS SO FAR
	JUMPGE T1,[XCTTU <SETOM (W)>
		POPJ P,]	;FLAG ERROR
	AOBJN T1,.+1
	PUSHJ P,FRSTTY	;THIS WILL GET COMMAND PORT
	 JRST AUXRN1	;OH WELL
	MOVSI T4,DVTTY	;TO TEST FOR TTY
AUXRL1:	PUSHJ P,NXTTTY	;NEXT IN CHAIN
	 JRST AUXRN1	;FINISHED
	TDNN T4,DEVMOD(F)
	JRST AUXRL1	;IGNORE ALL BUT TTYS
	HRRZ U,DDBLDB(F)	;GET LINE
	JUMPE U,AUXRL1	;IGNORE IF NO LINE
	JUMPGE T1,AUXRL2	;NO ROOM TO PUT IT
	LDB T3,LDPLNO
	UMOVEM T3,-1(T1)
	AOBJN T1,.+1
AUXRL2:	AOJA T2,AUXRL1	;COUNT 1
AUXRN1:	XCTTU <SETOM -1(T1)>	;FLAG END OF LIST
	UMOVEM T2,(W)
	JRST CPOPJ1	;FINISHED

;ZAP AUX CIRCUITS

ZAPCIR:	JUMPL T1,ZAPALL	;ALL OF THEM
	MOVE F,T1
	PUSHJ P,FNDPRT	;FIND THE PORT
	 POPJ P,	;NOT THERE
	HRRZ U,DDBLDB(F)
	JUMPE U,CPOPJ	;NO LINE, IGNORE
	SETZ	T1,	;Don't cause any confusion
	JRST HNGPRT	;GO HANG HIM

ZAPALL:	PUSHJ P,FRSTTY
	 POPJ P,	;NOT COMMAND
ZAPAL1:	PUSHJ P,NXTTTY
	 POPJ P,	;DONE
	MOVSI T1,DVTTY
	TDNN T1,DEVMOD(F)
	JRST ZAPAL1	;NOT A TTY
	HRRZ U,DDBLDB(F)
	JUMPE U,ZAPAL1
	SETZ	T1,
	PUSHJ P,HNGPRT
	JRST ZAPAL1	;ON TO NEXT
SUBTTL  POLL PORTS UUO

; POLPRT -- POLL PORTS FOR INTERRUPT-CAUSING EVENTS
;
;	MOVE	AC, [BITS,,ADDR]
;	POLPRT	AC,
;	  ERROR RETURN (TABLE TOO SMALL)
;	NORMAL RETURN
;
;	(AC/ # OF PORTS RETURNED ON EITHER RETURN)
;
; ADDR:	WORD COUNT (# WORDS, INCLUDING THIS ONE)
;	BITS,,PORT (SET BY UUO)
;	...
;
; WHERE <BITS> IS A MASK FOR THE EVENT BITS IN RH(LDBDCX)

POLPRT:	XCTFU	<MOVN T2, (T1)>
	MOVSS	T2
	HRR	T2, T1		; T2/ AOBJN POINTER
	SETZ	T4,		; T4/ COUNT OF PORTS RETURNED
	PUSHJ	P, FRSTTY
	  JRST POLPT4

	; GOT A PORT
POLPT1:	MOVE	T3, DEVMOD(F)
	TLNE	T3, DVTTY
	SKIPN	U, DDBLDB(F)
	JRST	POLPT3		; NOT TTY OR NO LDB

	; CHECK THE EVENTS FOR THIS PORT
	HLRZ	T3, T1		; T3/ 0,,MASK BITS
	AND	T3, LDBDCX(U)	; T3/ 0,,MASKED EVENTS
	ANDCAM	T3, LDBDCX(U)	; TURN OFF WHAT WE'VE READ
	JUMPE	T3, POLPT3	; NOTHING HAPPENED: TRY NEXT PT
	AOBJP	T2, POLPT5	; NO ROOM: ERROR-RETURN
	AOS	T4		; T4/ COUNT OF PORTS RETURNED
	XCTBU	<HRLM T3, (T2)>	; STORE THE EVENT BITS
	LDB	T3, LDPLNO
	XCTBU	<HRRM T3, (T2)>	; AND THE PORT NUMBER

	; GET ANOTHER PORT
POLPT3:	PUSHJ	P, NXTTTY
	  JRST POLPT4
	JRST	POLPT1
POLPT4:	AOS	(P)		; NORMAL RETURN: PORTS EXHAUSTED
POLPT5:	UMOVEM	T4, (W)		; AC := COUNT OF PORTS RETURNED
	POPJ	P,
SUBTTL BLOCK INPUT/OUTPUT (BIO) ROUTINES

;THE FORMAT OF A BLOCK I/O BUFFER IS:

BIOLNK==0	;PTR TO LINKED LIST OF BIO BUFFERS.
BIOCSH==1	;CACHE SWEEP NUMBER AT TIME REQUEST WAS QUEUED.
BIOPBP==2	;PTY BLOCK I/O: ILDB/IDPB POINTER FOR NEXT BYTE
BIOPBC==3	;PTY BLOCK I/O: # BYTES LEFT TO TRANSFER
BIOREQ==4	;CHAR COUNT OF LAST INPUT REQUEST BY THIS PORT.
BIOCHR==5	;COUNT OF CHARACTERS TO TRANSFER. (IN OR OUT).
BIODAT==6	;BEGINNING OF USER DATA.

;HERE FROM ENABLE BLOCK I/O AUXCAL

BLKIO:	MOVSI	T1, LMLBIO
	TDNE	T1, LDBMOD(U)	;IF ALREADY IN BLOCK MODE,
	POPJ	P,		;  ERROR-RETURN
	SKIPN T3,LDBBIO(U)	;DOES THE BIO PORT HAVE ANY
	JRST BLKIO2		;ACTIVE BUFFERS?
	HLRZ T1,T3		;YES.  OUTPUT ACTIVE?
	JUMPE T1,BLKIO1		;NO - GO CHECK FOR INPUT.
	PUSHJ P,OQUEUE		;YES. QUEUE JOB UNTIL DONE.
	 POPJ P,		;LINE IS GONE.  HE LOSES.
	JRST BLKIO
BLKIO1:	HRRZ T1,T3		;INPUT BUFFER ACTIVE?
	SKIPE T1		;
	PUSHJ P,IQUEUE		;YES. WAIT FOR CH7 TO RELEASE IT
	 POPJ P,		;NO.  DON'T WORRY ABOUT IT.
	JRST BLKIO
BLKIO2:	PUSHJ P,INCBC		;SET UP FOR 1 MORE JOB. IF CAN'T,
	POPJ P,			;  NONSKIP-RETURN
	MOVSI T1,LMLBIO		;SET FLAG IN THE LDB INDICATING
	IORM T1,LDBMOD(U)	;PORT IS IN BIO MODE.
	AOS (P)			;MADE IT!  SKIP RETURN TO USER
	POPJ P,
;BLKXIO -- HERE FROM THE LEAVE BLOCK MODE AUXCAL

BLKXIO:	MOVE	T1, LDBMOD(U)
	TLNN	T1, LMLBIO	;IF PORT'S NOT IN BLOCK MODE,
	POPJ	P,		;  JUST RETURN
	SKIPN	T3, LDBBIO(U)	;IF THERE'S NOTHING IN PROGRESS,
	JRST	BIORES		;  GET OUT NOW
	HLRZ	T1, T3
	JUMPE	T1, BLKX1	;IF THERE'S OUTPUT IN PROGRESS,
	PUSHJ	P, OQUEUE	;  WAIT FOR IT. IF ZAPPED,
	  POPJ	P,		;    JUST RETURN
	JRST	BLKXIO

    ;HERE FROM BLKXIO AND BIOREL -- TERMINATE/DISCARD CURRENT BLK INPUT

BLKX1:	HRRZ	T1, T3
	JUMPE	T1, BLKX2	;IF THERE'S INPUT IN PROGRESS,
	PUSHJ	P, BLKXIN	;  REQUEST INPUT TERMINATION
	HRRZ	T1, LDBBIO(U)
	SKIPL	BIOCHR(T1)	;  IF THE BASE IS DONE WITH THE BUFFER,
	PUSHJ	P, RELBI	;    THROW IT AWAY NOW
BLKX2:	SKIPN	LDBBIO(U)	;IF NO BUFFERS,
	PJRST	BIORES		;  GET OUT NOW
	MOVSI	T1, LMLBIO
	ANDCAM	T1, LDBMOD(U)	;ELSE, CLEAR THE BLOCK MODE BIT
	POPJ	P,		;  CH7 WILL DO THE REST

;BIOREL -- HERE FROM RESET UUO FOR EACH PORT IN BLOCK MODE
;	   TERMINATE BLOCK INPUT AND OUTPUT

BIOREL:	SKIPN	T3, LDBBIO(U)	;IF NO ACTIVE I OR O,
	PJRST	BIORES		;  GET OUT NOW
	HLRZ	T1, T3
	JUMPE	T1, BLKX1	;IF OUTPUT ACTIVE,
	PUSHJ	P, BLKXOT	;  REQUEST OUTPUT TERMINATION
	JRST	BLKX1
;BIOZAP -- CALLED WHEN A CIRCUIT IN BLOCK MODE IS ZAPPED

BIOZAP:	MOVSI	T1, LMLTBI
	ANDCAM	T1, LDBMOD(U)	;CLEAR "TERMINATE PENDING" FLAG
	DPB	T1,LOPBOP	;Clear PTY "Block-output-in-progress"
	PUSHJ	P, RELBI	;MUST BE DONE WITH INPUT
	PUSHJ	P, RELBO	;MUST BE DONE WITH OUTPUT
	;PJRST	BIORES		;MUST BE DONE WITH BLOCK I/O

;BIORES -- CLEAR BLKIO BIT AND FLAG NEGOTIATOR THAT WE'RE DONE

BIORES:	MOVSI T1,LMLBIO		;TAKE PORT OUT OF BLKIO MODE
	ANDCAM T1,LDBMOD(U)	;
	PJRST	DECBC		;ONE FEWER PORT DOING BLOCK I/O
; BLKINP -- BLOCK INPUT-AND-WAIT AUXCAL

BLKINP:	PUSHJ	P, BIOCHK	; EVERYTHING OK?
	  POPJ	P,		; NO
	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	JUMPE	T1, [		; NO INPUT BUFFER
		TLNE	S, IOEND	; IOEND SET?
		JRST	BLKEOF		; RETURN EOF
		MOVE	T2, LDBMOD(U)
		TLNE	T2, LMLTBI	; TERMINATE PENDING?
		JRST	BLKIP1		; WAIT FOR IT
		PUSHJ	P, REQBUF	; GET BUF & REQ. INPUT
		  POPJ	P,		; FAILED (PORT ZAPPED)
		JRST	BLKIP1		; MADE REQ.: NOW WAIT
	]
	MOVE	T2, BIOCHR(T1)	; T2/ IN-PROGRESS FLAG,,COUNT
	JUMPL	T2, BLKIP1	; IN-PROGRESS: WAIT FOR IT
	PUSHJ	P, GOTBUF	; COMPLETE: TRANSFER DATA
	  JFCL			; COUNT=0
	JRST	CPOPJ1		; OR COUNT>0: SKIP-RETURN

    ; HERE TO WAIT FOR "BLOCK INPUT TERMINATED" MESSAGE
    ; OF SOME SORT

BLKIP1:	PUSHJ	P, IQUEUE
	  POPJ	P,		; PORT GONE
	JRST	BLKINP		; RETRY
; BLKINS -- BLOCK INPUT-AND-SKIP AUXCAL

BLKINS:	PUSHJ	P, BIOCHK	; EVERYTHING OK?
	  POPJ	P,		; NO
	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	JUMPE	T1, [		; NO INPUT BUFFER
		TLNE	S, IOEND	; IOEND SET?
		JRST	BLKEOF		; RETURN EOF
		MOVE	T2, LDBMOD(U)
		TLNE	T2, LMLTBI	; TERMINATE PENDING?
		POPJ	P,		; NONSKIP-RETURN
		PUSHJ	P, REQBUF	; GET BUF & REQ. INPUT
		  POPJ	P,		; FAILED (PORT ZAPPED)
		POPJ	P,		; MADE REQ.: NOW RETURN
	]
	MOVE	T2, BIOCHR(T1)	; T2/ IN-PROGRESS FLAG,,COUNT
	JUMPL	T2, CPOPJ	; IN-PROGRESS: NONSKIP-RETURN
	PUSHJ	P, GOTBUF	; INPUT COMPLETE: TRANSFER DATA
	  POPJ	P,		; COUNT=0: NONSKIP-RETURN
	JRST	CPOPJ1		; COUNT>0: SKIP-RETURN

; BLKEOF -- COMMON CODE TO SET IO.END
;	    FOR BLOCK INPUT AUXCALS

BLKEOF:	XOR	S, [IOEND,,IODEND]
	MOVEM	S, DEVIOS(F)	; SET IO.EOF, CLEAR IOEND
	AOS	(P)
	PJRST	RELBI		; DONE WITH INPUT BUFFER
; BIOCHK -- COMMON SETUP CODE FOR BLOCK INPUT AUXCALS

BIOCHK:	MOVE	T1, LDBMOD(U)
	TLNN	T1, LMLBIO	; BLOCK I/O ENABLED?
	POPJ	P,		; NO -- FAIL
	TRNE	S, IODEND	; IO.EOF SET?
	POPJ	P,		; YES -- FAIL
	PUSHJ	P, BPXOFF	; IS THIS NECESSARY?
	NOCHARGE		; TURN OFF THE CLOCK
	JRST	CPOPJ1		; SUCCEED

; GOTBUF -- COMMON BUFFER-TRANSFER CODE FOR BLOCK INPUT AUXCALS
;	    ENTER WITH T1/ INPUT BUFFER ADDRESS
;		       T2/ CHARACTER COUNT

GOTBUF:
	PUSH	P,P1		;Needed in one irritating place
	PUSH	P,T2		; SAVE CHARACTER COUNT
	ADDM	T2, JBTBIO(J)	; CHARGE JOB FOR CHARACTERS
	ADDM	T2, JBTBIO	; RECORD TOTAL CHARACTERS
	ADDI	T2, 3
	LSH	T2, -2		; T2/ # OF WORDS
	HRLI	T3, BIOCHR(T1)	; T3/ START OF MON DATA,,
	HRR	T3, M		; T3/ ",,START OF USER BUFFER
IFNKMC<
	ADDI	T2, (T3)	; T2/ STOP LOCATION
	XCTTU <BLT T3, (T2)>	; TRANSFER THE COUNT&DATA
>;END IFNKMC
IFKMC<
	;T2/# OF WORDS
	;T3/MONITOR BUFFER,,USER BUFFER
	PUSH	P,T1		;SAVE T1
	PUSH	P,T4		;TO HOLD DESTINATION BYTEPOINTER
	LSH	T2,1		;T2/# OF HALF WORDS
	HRRZ	T4,T3		;T4/0,,USER BUFFER
	HLRZ	T3,T3		;T3/0,,MONITOR BUFFER
	MOVE T1,(T3)		;GET FIRST WORD FOR USER BUFFER
	XCT 4,[MOVEM T1,(T4)]	;PUT IT IN USER BUF
	ADDI T4,1
	ADDI T3,1
	HRLI	T3,(POINT 18,0)	;PACK HALFWORD BYTES INTO
	HRLI	T4,(POINT 16,0)	;	FULLWORD BYTES
GBXLUP:	ILDB	T1,T3		;GET MONITOR HALF WORD
	XCT	1,[IDPB T1,T4]	;PUT TWO BYTES IN USER BUF
	SOJG	T2,GBXLUP
	POP	P,T4		;RESTORE THEM REGISTERS
	POP	P,T1		;RESTORE T1
>;END IFKMC
	MOVE	T2, LDBMOD(U)
	TLNN	T2, LMLTBI	; TERMINATE-INPUT PENDING?
	TLNE	S, IOEND	; IOEND SET?
	JRST	[
		PUSHJ	P, RELBI	; DONE WITH INPUT BUFFER
		JRST	GOTBF1		; GO FINISH UP
	]
	PUSHJ	P, KEPBI	; IF SOMEONE ELSE WANTS A BUFFER,
	  SKIPA			;By all means let 'em have it
	JRST	GOTBF0		;No competition
	MOVE	P1,BIOREQ(T1)	;Save count in a safe place (!)
	PUSHJ	P,RELBI		;Give up the buffer/port
	PUSHJ	P,GETBI		;Get a new one
	  JRST	GOTBF1		;Not needed...
	MOVEM	P1,BIOREQ(T1)	;Set count in new buffer
GOTBF0:
	MOVE	T2, BIOREQ(T1)	; T2/ OLD REQUEST COUNT
	PUSHJ	P, BLKIRQ	; REQUEST INPUT
GOTBF1:	POP	P, T1		; T1/ COUNT BLT'ED
	POP	P,P1		;Remember him?
	JUMPN	T1, CPOPJ1	; SKIP IF > 0
	POPJ	P,
; REQBUF -- ALLOCATE A BUFFER FOR BLOCK INPUT
;	    STORE ITS ADDRESS IN RH(LDBBIO(U))
;	    SAVE THE USER'S BYTE COUNT IN BIOREQ(RH(LDBBIO(U)))
;	    AND SEND AN INPUT REQUEST
;	    SKIP-RETURN NORMALLY
;	    NONSKIP-RETURN IF ZAPPED WHILE IN "EXTRA" WAIT

REQBUF:	PUSHJ	P, GETBI	; SET UP FOR BLOCK INPUT
	  POPJ	P,		; FAILED (ZAPPED)

	; SUCCEEDED: T1/ INPUT BUFFER ADDRESS

	XCTFU <HRRZ T2, (M)>	; T2/ USER'S BYTE COUNT
	CAILE	T2, ^D400
	MOVEI	T2, ^D400	; T2/ USER'S COUNT .MIN. 400
	MOVEM	T2, BIOREQ(T1)	; SAVE FOR READAHEAD CODE
	AOS	(P)		; PREPARE FOR SKIP-RETURN
	PJRST	BLKIRQ		; REQUEST INPUT

; BLKIRQ -- REQUEST BLOCK INPUT
;	    ENTER WITH T1/ BUFFER ADDRESS
;		       T2/ CHARACTER COUNT

BLKIRQ:
IFCPU (KL),<MOVE	T3,CSUCNT	;WHEN I/O STARTS, SWEEP NUMBER
				;MUST BE DIFFERENT THAN THIS.
	MOVEM	T3,BIOCSH(T1)>
	MOVE	T3, LDBMOD(U)
	TLNE	T3, LMLTBI	; TERMINATE PENDING?
	STOPCD			; IMPOSSIBLE!
	HRROM	T2, BIOCHR(T1)	; IN-PROG := -1, COUNT := T2.RH
	MOVEI	T1, 1
	DPB	T1, LOPBIN	;SET BLOCK INPUT
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,
;BLKOUT -- HERE FROM BLOCK OUTPUT AUXCAL.  SKIPS ON SUCCESS.

BLKOUT:	MOVE T1,LDBMOD(U)	;TEST TO SEE IF BLOCK I/O
	TLNN T1,LMLBIO		;MODE HAS BEEN SET.
	 POPJ P,		;ERROR RETURN IF NOT.
	NOCHARGE		;TURN OFF THE CLOCK.
	HLRZ T1,LDBBIO(U)	;IS THERE A BLOCK OUTPUT
	JUMPE T1,BLKOT1		; ALREADY IN PROGRESS?
	PUSHJ P,OQUEUE		;I/O WAIT OR INTERRUPT
	 POPJ P,		;NO.  ERROR RETURN TO THE USER.
	JRST BLKOUT		;MAKE SURE BUFFER WAS RELEASED.
BLKOT1:	PUSHJ	P, GETBO	;SET UP FOR BLOCK OUTPUT
	  POPJ	P,		;  ZAPPED
	XCTBU <HRRZ T2,(M)>	;GET USER'S WORD COUNT
	CAIG	T2,^D400	;IF < 0 OR > 400
	SKIPN	T2		;OR = 0
	PJRST	RELBO		;  GET OUT AND ERROR-RETURN
	CAILE T2,^D80		;MIN. NO. OF CHARS FOR CHARGING
	SKIPA T3,T2		;PURPOSES IS EIGHTY.
	MOVEI T3,^D80
	ADDM T3,JBTBIO(J)	;ADD TO BIO CHRS XFER'D FOR JOB.
	ADDM T3,JBTBIO		;ADD TO TOTAL BIO CHARS XFERRED.
	ADDI T2,3
	LSH T2,-2
	XCTBU <MOVSI T3,(M)>	;GET ADDRESS OF USER BUFFER
	HRRI T3,BIOCHR(T1)	;PREPARE FOR BLT TO MONITOR
IFNKMC<
	ADDI T2,BIOCHR(T1)	;ADD IN BASE LOC FOR XFER
	XCTFU <BLT T3,(T2)>	;BUFFER.
IFCPU (KL),<MOVE	T2,CSVCNT	;MUST DO ONE VALIDATE BEFORE CAN START
	MOVEM	T2,BIOCSH(T1)>	;I/O.
>;END IFNKMC
IFKMC<
	;T2/# OF WORDS
	;T3/USER BUFFER,,MONITOR BUFFER
	PUSH	P,T4		;TO HOLD DESTINATION BYTEPOINTER
	LSH	T2,1		;T2/# OF HALF WORDS
	HRRZ	T4,T3		;T4/0,,MONITOR BUFFER
	HLRZ	T3,T3		;T3/0,,USER BUFFER
	XCT	4,[MOVE T1,(T3)]	;GET FIRST WORD OF USER BUFFER
	MOVEM	T1,(T4)		;PUT IT IN MON BUF
	ADDI T4,1
	ADDI T3,1
	HRLI	T3,(POINT 16,0)	;UNPACK FULLWORD BYTES INTO
	HRLI	T4,(POINT 18,0)	;		HALFWORD BYTES
XCTLUP:	XCT 1,[ILDB T1,T3]	;GET TW0 USER BYTES
	IDPB	T1,T4
	SOJG	T2,XCTLUP
	POP	P,T4		;RESTORE THEM REGISTERS
>;END IFKMC
	MOVEI T1,1
	DPB T1,LOPBOT		;SET BLOCK OUTPUT
	DPB T1,LDBOPB(U)	;AND NEED-OUTPUT
	JRST CPOPJ1		;AND SUCCESS-RETURN
COMMENT %

There are (presently) three block i/o mechanisms, one for
620 bases, one for PTYs, and one, as yet uncoded, for Nexilis
bases. For the sake of everyone's sanity, there must be a
level in the block i/o code at which the distinction between
these three becomes invisible.

In particular, the UUOs should use only the following routines,
which will acquire and release the appropriate resources
regardless of the mechanism being used:

	GETBI	sets up a port to do block input
	RELBI	called when a port's done with block input
	KEPBI	skips if it's ok for this port to keep
		its block-input resources; if it nonskips,
		caller should do a RELBI/GETBI sequence
	GETBO	sets up a port for block output
	RELBO	called when a port's done with block output
	INCBC	enables the block i/o mechanism for 1 more
		job (1 more PDP10 port), and skip-returns
		if 1 more is ok
	DECBC	called when a port is disabled for block i/o

%
;INCBC -- CALLED WHEN 1 MORE PORT IS TO BE ENABLED FOR BLOCK I/O
;	  SKIP-RETURNS IF 1 MORE IS OK
;	  CALLED WITH U/ LDB ADDR, J/ JOB #

INCBC:	HLL	U, LDBDCH(U)
	TLNE	U, LDLPTY	;IF IT'S A PTY,
	JRST	INCPBC		;  THINGS ARE SIMPLER

    ;HERE FOR REAL TTYS

	NOCHARGE		;TURN OFF THE CLOCK.
IFCPU (<KI,KL>), <
	AOSE AXREQ		;INC REQUEST COUNT FOR AUX QUEUE
	PUSHJ P,AXWAIT		;QUEUE JOB IF REQ IN PROGRESS
	AOS BIOCNT+0		;INCREMENT COUNT OF BIO JOBS
	HRROS BIOCNT+0		;FLAG FOR CH7 TO SEND REQUEST.
	MOVEM J,BIOJOB		;BIOJOB_JOB NO W REQ IN PROGRESS
	MOVEI T1,MLOWQ		;PLACE THIS JOB IN THE ML QUEUE
	DPB T1,PJBSTS		;AND WAIT UNTIL AN ANSWER IS
	PUSHJ P,WSCHED		;RECEIVED FROM THE BASE.
	SKIPLE BIOPRT		;IF THERE7S AT LEAST ONE SLOT,
	AOS (P)			;  SET TO SKIP-RETURN
	SOSL AXREQ
	SETOM AXAVAL
	POPJ P,
> ;END IFCPU (<KI,KL>)
IFNCPU (<KI,KL>), <
	AOS	BIOCNT		;ONE MORE BIO JOB
	SOSL	BPREQ		;AND ONE MORE BUFFER
	SETOM	BPAVAL		;ACTIVATE JOB WAITING FOR A BUFFER
	JRST	CPOPJ1
> ;END IFNCPU (<KI,KL>)

    ;HERE FOR PTYS

INCPBC:	AOS	BIOCNT+1	;1 MORE BLOCK-MODE PTY
	JRST	CPOPJ1		;SKIP-RETURN
;DECBC -- CALLED WHEN A PORT HAS BEEN DISABLED FOR BLOCK I/O
;	  AND ALL BLOCK I/O ACTIVITY FOR IT HAS STOPPED
;	  CALLED WITH U/ LDB ADDR

DECBC:	HLL	U, LDBDCH(U)
	TLNE	U, LDLPTY	;IF IT'S A PTY,
	JRST	DECPBC		;  THINGS ARE A BIT EASIER

    ;HERE FOR A REAL TTY

	HRRE	T1, BIOCNT+0	;T1/ REAL TTY BLOCK I/O USER COUNT
	SOJGE	T1, .+2
	  STOPCD
IFCPU (<KI,KL>), <
	HRROM	T1, BIOCNT+0	;BIOCNT+0/ "CHANGED",,NEW COUNT
> ;END IFCPU (<KI,KL>)
IFNCPU (<KI,KL>), <
	MOVEM	T1,BIOCNT+0	;ONE LESS BIO JOB
	AOS	BPREQ		;ONE LESS BUFFER
> ;END IFNCPU (<KI,KL>)
	ADD	T1, BIOCNT+1	;T1/ TOTAL BLOCK USER COUNT
	JRST	DECBC1

    ;HERE FOR A PTY

DECPBC:	SOSGE	T1, BIOCNT+1	;T1/ PTY BLOCK USER COUNT
	  STOPCD
	HRRE	T2, BIOCNT+0
	ADD	T1, T2		;T1/ TOTAL BLOCK USER COUNT
	;JRST	DECBC1

    ;HERE FOR EITHER -- FREE UP UNNECESSARY BUFFERS

DECBC1:	ASH	T1, 1		;T1/ MAX # OF BUFFERS NEEDED (2*PORTS)
	SUB	T1, BIOBUF	;T1/ -# OF UNNEEDED BUFFERS IN POOL
	PUSH	P, T1
DECBC2:	AOSLE	(P)
	JRST	DECBC3
	PUSHJ	P, GETBBP	;GET A BUFFER FROM THE BLOCK I/O POOL
	PUSHJ	P, RELBBF	;RELEASE IT TO FREECORE
	JRST	DECBC2
DECBC3:	POP	P, T1
	POPJ	P,
;GETBI -- SET UP A PORT FOR BLOCK INPUT
;	  NONSKIP IF LEFT BLOCK MODE
;	  ELSE SKIP WITH T1 AND LDBBIO(U).RH SET TO BUFFER

GETBI:	PUSHJ	P, GETBIO
	POPJ	P,
	HRRM	T1, LDBBIO(U)
	JRST	CPOPJ1

;GETBO -- SET UP A PORT FOR BLOCK OUTPUT

GETBO:	PUSHJ	P, GETBIO
	POPJ	P,
	HRLM	T1, LDBBIO(U)
	JRST	CPOPJ1

;RELBI -- CALLED WHEN A PORT'S DONE WITH BLOCK INPUT
;	  RETURNS T1/ LDBBIO(U)

RELBI:	HRRZ	T1, LDBBIO(U)
	JUMPE	T1, RELB0
	HLLZS	LDBBIO(U)
	PJRST	RELBIO

;RELBO -- CALLED WHEN A PORT'S DONE WITH BLOCK OUTPUT
;	  RETURNS T1/ LDBBIO(U)

RELBO:	HLRZ	T1, LDBBIO(U)
	JUMPE	T1, RELB0
	HRRZS	LDBBIO(U)
	PJRST	RELBIO

RELB0:	MOVE	T1, LDBBIO(U)
	POPJ	P,
;KEPBI -- SKIP-RETURNS IF IT'S OK FOR THIS PORT (U/ LDB ADDRESS)
;	  TO KEEP ITS BLOCK INPUT RESOURCES, NONSKIPS IF
;	  SOMEBODY ELSE WANTS THEM

KEPBI:	PUSH	P, T1
	MOVSI	T1, LDLPTY
	TDNE	T1, LDBDCH(U)	;IF IT'S NOT A PTY
	JRST	KEPBI1
	MOVE	T1, LDBBIO(U)
	SKIPLE	BPREQ		;AND SOMEONE'S WAITING FOR PORTS
	TLNE	T1, 777777	;AND WE CAN FREE ONE,
KEPBI1:	SKIPLE	FCREQ		;OR IF SOMEONE'S WAITING FOR FREECORE,
	JRST	.+2		;  DON'T SKIP
	AOS	-1(P)
	POP	P, T1
	POPJ	P,
;GETBIO -- GET A BLOCK I/O BUFFER FOR U
;	   NONSKIP-RETURN IF PORT LEFT BIO MODE WHILE WAITING
;	   SKIP-RETURN WITH T1/ THE BUFFER ADDRESS OTHERWISE

GETBIO:	MOVSI	T1, LDLPTY
	TDNN	T1, LDBDCH(U)	;IF IT'S NOT A PTY
	SKIPE	LDBBIO(U)	;AND THERE'S NO BLOCK I/O IN PROGRESS,
	JRST	GTBIO1
	AOSLE	BPREQ
	PUSHJ	P, BPWAIT	;  GET A BASE PORT
GTBIO1:	PUSHJ	P, GETBB	;T1/ BUFFER ADDRESS
	MOVE	T2, LDBMOD(U)
	TLNE	T2, LMLBIO	;IF PORT'S STILL IN BLOCK MODE,
	JRST	CPOPJ1		;  SKIP-RETURN
	;PJRST	RELBIO

;RELBIO -- RELEASE A BLOCK I/O BUFFER FOR U
;	   CALLED WITH T1/ THE BUFFER ADDRESS
;	   FREES THE PORT IF NO BUFFERS REMAIN
;	   RETURNS T1/ LDBBIO(U)

RELBIO:	PUSHJ	P, RELBB	;FREE THE BUFFER
	MOVSI	T1, LDLPTY
	TDNE	T1, LDBDCH(U)	;IF IT'S NOT A PTY
	JRST	RLBIO1
	SKIPN	T1, LDBBIO(U)	;AND NO BLOCK I OR O IN PROGRESS,
	SOSL	BPREQ		;  FREE THE BASE PORT
	SETOM	BPAVAL
	POPJ	P,

RLBIO1:	MOVE	T1, LDBBIO(U)	;T1/ LDBBIO
	POPJ	P,
;GETBB -- GET A BLOCK I/O BUFFER AND RETURN ITS ADDRESS IN T1
;GETBBP -- GET ONE FROM THE POOL (NOT FREECORE) OR CRASH

GETBB:	SKIPE	BBFREE		;IF NO FREE BLOCK BUFFERS,
	JRST	GETBB1
	MOVEI	T2, BIOCOR
	SKIPGE	FCREQ		;  GET ANOTHER. IF OTHER JOBS IN FC WAIT
	PUSHJ	P, GET4WD	;  OR NO FREE CORE,
	JRST	[
		AOS FCREQ
		PUSHJ P,FCWAIT
		SOS FCREQ
		JRST GETBB	;    WAIT, THEN TRY AGAIN
	]
IFKMC<
	EXTERNAL UBANXT,UBAEND	;OUR UBA SPACE IS BETWEEN THESE TWO
	UBABIO==<763000!<<UBANXT+1>&776>>;START UBA's BLOCK I/O PAGING RAM
	PUSH	P,T1		;SAVE UNMAPPED T1
	PUSHJ	P,SCANBB	;RETURNS T2 WITH UBA PAGE # OF T1
	  JRST [CAILE T2,UBAEND-<UBABIO&777> ;GUESS WE DIDN'T MATCH. ANY ROOM LEFT?
		  STOPCD	;GIVE UP IF NO ROOM.
		HRLI T2,3	;T2/3,,AVAILABLE PAGE #
		LSH T1,-9	;T1/HIGH 11 BITS OF MAPPED ADDRESS
		TRO T1,1B21	;SET VALID BIT
		WRIO T1,UBABIO(T2)
		MOVEM T1,BBPAGE(T2)
		ADDI T1,1	;ALSO INIT NEXT PAGE
		WRIO T1,UBABIO+1(T2)
		MOVEM T1,BBPAGE+1(T2)
		HRRZ T2,T2	;T2/0,,PAGE #
		AOS	BBCRE	;;;COUNT BIO BUFFERS CREATED
		JRST .+1]	;CONTINUE
	LSH	T2,-1		;T2/PAGE PAIR #
	AOS	BBCNTS(T2)	;BUMP THE USE COUNT
	POP	P,T1		;RESTORE UNMAPPED T1
>;END IFKMC
	AOS	BIOBUF		;  1 MORE BUFFER IN POOL
	POPJ	P,		;  RETURN THE BUFFER

    ;HERE IF THERE ARE FREE BUFFERS IN THE BLOCK I/O POOL

GETBBP:	SKIPN	BBFREE
	  STOPCD
GETBB1:	SOS	BBFREE
	AOS	BBPOOL		;COUNT USE OF FREE BIO BUFFERS
	HRRZ	T1, BUFLST
	SKIPN	T1
	  STOPCD
	HRRZ	T2, (T1)
	HRRM	T2, BUFLST	;MAKE NEXT-LINK THE NEW HEADER
	POPJ	P,

;RELBB -- RELEASE THE BLOCK I/O BUFFER POINTED TO BY T1
;RELBBF -- ALWAYS RETURN IT TO FREECORE

RELBB:	SKIPGE	FCREQ		;IF OTHER JOBS ARE WAITING FOR FREECORE,
	JRST	RELBB1
RELBBF:	SKIPN	T2, T1
	  STOPCD
	SOS	BIOBUF
	MOVEI	T1, BIOCOR
IFKMC<	PUSHJ P,RELKMC>		;RELEASE UBA SLOT
	PJRST	GIV4WD		;  JUST RELEASE THE BUFFER

    ;HERE TO ADD THE BUFFER TO THE BLOCK I/O POOL

RELBB1:	SKIPN	T1
	  STOPCD
	HRRZ	T2, BUFLST	;T2/ HEAD OF FREE CHAIN
	MOVEM	T2, (T1)
	MOVEM	T1, BUFLST	;MAKE T1 THE NEW HEAD
	AOS	BBFREE
	POPJ	P,

IFKMC<
RELKMC:	PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;SAVE UNMAPPED T2
	MOVE	T1,T2		;T1/BUFFER ADDRESS
	PUSHJ	P,SCANBB	;RETURNS T2 WITH UBA PAGE # OF T1
		STOPCD		;NO MATCH IS BAD NEWS!
	LSH	T2,-1		;T2/PAGE PAIR NUMBER
	SOSN	BBCNTS(T2)	;DEC PAGE PAIR USE COUNT
	  JRST [LSH T2,1	;;IF COUNT WENT TO 0 RESTORE T2 &
		SETZ T1,	;;INVALIDATE THE PAGE PAIR
		HRLI T2,3	;;UBA #3,,EVEN PAGE #
		WRIO T1,UBABIO(T2)
		WRIO T1,UBABIO+1(T2)
		HRROS BBPAGE(T2)	;;;;DEBUG
		HRROS BBPAGE+1(T2)	;;;;DEBUG CODE
		AOS BBREL		;;;;INFO
		JRST .+1]
	POP	P,T2		;RESTORE UNMAPPED T2
	POP	P,T1		;RESTORE T1
	POPJ	P,		;RETURN


SCANBB:	;RETURNS T1 MAPPED
	;SKIP RETURNS WHEN T2/0,,MATCHED UBA PAGE
	;NON-SKIP RETURNS WITH T2/0,,-1 OR T2/0,,AVAILABLE UBA PAGE #
	MAP T1,(T1)
	PUSH	P,T1		;SAVE MAPPED T1 FOR RETURN
	PUSH	P,T3
	PUSH	P,T4
	AND	T1,[3777B26]	;MASK OUT ALL BUT HIGH 11 BITS
	TLO	T1,(1B8)	;SET VALID BIT
	MOVEI	T4,-1		;T4/0,,-1
	HRLZI	T2,3		;T2/3,,0
SBBLUP:	RDIO	T3,UBABIO(T2)	;T3/EVEN PAGE # CONTENTS
	AND T3,[<1B8!3777B26>]	;MASK OUT ALL BUT VALID BIT & HIGH 11
	CAMN	T1,T3		;DOES IT MATCH?
	  JRST [POP P,T4	;IF IT DOES THEN SKIP RETURN
		POP P,T3
		POP P,T1	;RESTORE MAPPED T1
		HRRZ T2,T2	;T2/0,,MATCHED PAGE #
		JRST CPOPJ1	;DO SKIP RETURN
		]
	TLZN	T3,(1B8)	;IS THE VALID BIT ON?
		MOVEI T4,(T2)	;T4/0,,LATEST AVAILABLE PAGE #
	ADDI	T2,2		;T2/3,,NEXT PAGE PAIR
	CAMGE	T2,[3,,UBAEND-<UBABIO&777>]	;ARE WE STILL LESS THAN 30?
		JRST SBBLUP	;IF SO GO BACK TO SBB LOOP
	MOVE T2,T4		;T2/0,,-1 OR 0,,AVAILABLE SLOT NUMBER
	POP	P,T4
	POP	P,T3
	POP	P,T1		;RESTORE MAPPED T1
	POPJ	P,		;NON-SKIP RETURN


;MISC KMC RELATED ROUTINES

EXTERNAL KMCRST,KMCCAC,KMCSUP,KMCGUP,KMCGAC,KMCGAV

SCNMIN: PUSHJ	P,MDRUP		;T1/ FLAG DRs WE THINK ARE UP
	MOVEM	T1,DRMBRK	;FLAG TO SEND DR PILLS
	POPJ	P,

SCNDRD:			;WILL SKIP A MINUTE WHEN KMCRES IS CALLED
	SKIPE	T1,DRDOW
	  JRST	SCNMI2		;SET DRMHSI ON 2ND MINUTE
	PUSHJ P,KMCRST		;T1/ DOWN DR BITS
	PUSHJ	P,DRFLAG	;T1/ 3-BIT DR NUMBERS NEEDING TYPHSI MSG
	MOVEM	T1,DRDOW	;START DELAY FOR 41 TO NODE(S)
	MOVEI	T1,^D60
	MOVEM	T1,TIMDRD
	POPJ	P,
SCNMI2:	MOVEM	T1,DRMHSI	;SET DRMHSI FLAG WITH DOWN DR NUMBERS
	SETZM	DRDOW		;CLEAR DRDOW
	POPJ	P,		;ACTUAL MESSAGES GET SENT FROM SNDHSI

SNDHSI:	SKIPN	T1,DRMHSI	;T1/DOWN DR NUMBERS
	  JRST	MDRSHT		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMHSI
	MOVSI	P3,TYPI TYPHSI
	PUSHJ	P,MDRMSG	;SEND TO ALL DR NUMs IN T1
	JUMPN	T1,[		;IF NO ROOM IN THE RING TO FINISH THEN
		MOVEM T1,DRMHSI ; SET DRMHSI TO DO THE REST NEXT TIME
		POPJ	P,]   	; AND NON-SKIP RETURN
MDRSHT:	SKIPN	T1,DRMSHT	;T1/DRs THAT NEED A SHUT MESSAGE
	  JRST	MDRBRK		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMSHT
	MOVSI	P3,TYPI TYPSHT
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMSHT	; SET DRMSHT TO DO THE REST NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRBRK:	SKIPN	T1,DRMBRK	;T1/DRs THAT NEED A 57 PILL
	  JRST	MDRCLP		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMBRK
	MOVSI	P3,TYPI TYPBRK	;WE USE A 51 "BRK" MSG FOR THE PILL
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMBRK	; SET DRMBRK TO DO THE REST NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRCLP:	SKIPN	T1,DRMCLP	;T1/DRs THAT NEED A CLOCK REQ MSG
	  JRST	MDRANS		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMCLP
	MOVSI	P3,TYPI TYPCLP
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMCLP	; SET DRMCLP TO DO THE REST NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRANS:	SKIPN	T1,DRMANS	;T1/DRs TO SEND AN ANSWERED MSG TO
	  JRST	MDRNXT		;CHECK NEXT MULTI DR MESSAGE
	SETZM	DRMANS
	MOVSI	P3,TYPI TYPANS
	PUSHJ	P,MDRMSG
	JUMPN	T1,[		;IF WE COULDN'T FINISH THEN
		MOVEM T1,DRMANS	; SET UP FOR NEXT TIME
		POPJ P,]	; AND NON-SKIP RETURN
MDRNXT:	
	MOVE	T1,DRMTIM	;;;;;;;START KMC DEBUG CODE
	SUBI	T1,1
	JUMPE	T1,CPOPJ1	;IGNORE FOR THE FIRST SECOND
	PUSHJ	P,KMCGAV
	MOVE	T2,T1
	ANDI	T2,377
	LSH	T2,8
	PUSHJ	P,KMCGAC
	ANDI	T1,377
	IOR	T1,T2
	CAMN	T1,KMCLAS	;SAME AS LAST TIME?
	  JRST	CPOPJ1		;YES, BYE...
	MOVEM	T1,KMCLAS
	HRL	T1,DRMTIM
	MOVE	T2,KMCPDP
	MOVEM	T1,KMCFLG(T2)
	ADDI	T2,1
	ANDI	T2,77
	MOVEM	T2,KMCPDP	;;;;;;;;END KMC DEBUG CODE
	JRST	CPOPJ1	;END OF MDR CHAIN FOR NOW. SKIP RET

MDRMSG:	;MSG TO ALL UP DRs	;P3/ MOVSI P3,TYPI TYPmsg
	;T1/ 3-BIT UP DR NUMBERS;RET:T1/0 or DRs NOT SENT TO
;;;;;;;	MOVE	T2,SYSNUM	;PUT THE SYSNUM IN THE MESSAGES JUST
	MOVE	T2,DRMTIM ;USE UP TIME FOR NOW
;;;;;;;	ANDI	T2,377		;INCASE THE NODE WANTS IT IN THE FUTURE
	ANDI	T2,1777 ;SHOW 10 BITS FOR NOW
	LSH	T2,8		; OFCOURSE WE CAN ONLY SEND 8 BITS OF IT
	ANDCM	P3,[377,,-1]
	IOR	T2,P3		;T2 HOLDS THE MESSAGE
MDRLUP:	SKIPN	P3,T1
	  JRST	CPOPJ		;RETURN WHEN T1=0
	ANDI	P3,3		;ISOLATE A DR NUMBER
	JUMPE	P3,MDRL1	;IF IT'S 0 GO TRY THE NEXT ONE
	SUBI	P3,1		;1-4 GOES TO 0-3
	MAXDR==PORTN/LPERDR	;HIGHEST DR = # OF PORTS/LINES PER DR
	CAILE	P3,MAXDR	;P3 MUST BE .LE. PORTS/LINES PER DR
	  JRST	MDRLUP
	LSH	P3,6		;MAKE IT A PORT NUMBER
	IORI	P3,LPERDR&77	;P3/(DRNUM*100) ! LINES PER DR
	CAILE	P3,<MAXDR*100>!<PORTN-<MAXDR*LPERDR>>
	  JRST	[ANDCMI P3,77
		IORI	P3,PORTN-<MAXDR*LPERDR>
		JRST	.+1]
	ANDCMI	P3,3		;MUST BE A MULTIPLE OF 4
	HRL	P3,P3		;P3/MAX PORT NUM,,MAX PORT NUM
	ANDCMI	P3,77		;P3/MAX PORT NUM,,DR NUM
	HLRZ	T3,T2		;TEST FOR TYPHSI
	CAIE	T3,TYPI TYPHSI	;TYPHSI USES MAX PORT,,DRNUM
	  HRLZ	P3,P3		;TYPE A MESSAGES DON'T USE MAX PORT
	IOR	P3,T2		;OR IN THE MESSAGE AND SYS NUMBER
	PUSH	P,T1
	PUSH	P,T2
	PUSHJ	P,CLSCHR	;MAKE SURE THE RING IS READY
	  JRST MDRRET		;IF NOT DO A NON-SKIP RETURN
	PUSHJ	P,WRDOUT	;PUT THE MESSAGE IN THE RING
	  JRST MDRRET		;THIS SHOULDN'T HAPPEN!
	POP	P,T2
	POP	P,T1
	HLRZ	T3,T2		;TEST FOR TYPHSI
	CAIE	T3,TYPI TYPHSI
	  JRST	MDRL1		;IF NOT HSI THEN SKIP TO MDRL1
	MOVE	T3,T1
	ANDI	T3,3
	SUBI	T3,1
	SETOM	SENT41(T3)	;FLAG THAT WE SENT A 41 TO THAT DR
MDRL1:	LSH	T1,-3		;THROW OUT 3-BIT DR NUM JUST PROCESSED
	JRST	MDRLUP		;GO DO THE NEXT ONE
MDRRET:	POP	P,T2
	POP	P,T1
	JRST	CPOPJ

DR1BIT==1B35
DR2BIT==1B34
DR3BIT==1B31
DR4BIT==1B28

MDRUP:	PUSHJ	P,KMCGUP
DRFLAG: HRLZ	T1,T1		;MOVE FLAGS TO LEFT HALF
	TLZE	T1,DR1BIT	;TEST AND CLEAR THE FIRST FLAG
	IORI	T1,0001		;IF A DRs FLAG IS SET PUT ONE PLUS IT'S
	TLZE	T1,DR2BIT	;    NUMBER IN A 3-BIT OCTAL DIGIT SLOT
	IORI	T1,0020
	TLZE	T1,DR3BIT
	IORI	T1,0300
	TLZE	T1,DR4BIT
	IORI	T1,4000
	HRRZ	T1,T1		;T1/ 0,,3-BIT DR NUMBERS FLAGGED
	POPJ	P,		;RETURN
>;END IFKMC

KMCRES:			;CALLED WHEN KMC DETECTS A DR HAS GONE SOUTH
IFNKMC	<AOJA P4,SCNIN1>;IGNORE ANSWERED MESSAGE
IFKMC<
	MOVEI	T1,^D60
	MOVEM	T1,TIMDRD	;RESET KMC CHECKUP TIMER
	MOVE	T1,DRMTIM ;;;;;;;TEMP STUFF UP TIME IN IRING 3 MSG
	DPB	T1,INPDL2 ;;;;;;;  "    "    "   "   "   "   "  "
	LDB	U,INPLIN
	ANDI	U,300		;U/FIRST PORT NUMBER OF FAILING DR
	CAILE	U,PORTN		;THIS TEST WORKS ONLY WHEN LPERDR=^D64
	  AOJA	P4,SCNIN1	;IGNORE BAD PORT NUMBERS
	MOVE	T1,U
	LSH	T1,-6		;T1/DR NUMBER
	SETZM	SENT41(T1)	;RESET "WAITING FOR RESPONSE TO 41"
	PUSHJ	P,KMCCAC	;CLEAR DR'S ACTIVE BIT & UP BIT
DRZAP:	PUSH	P,U		;SAVE U
	MOVE	U,LINTAB(U)	;U/ PORT LDB
	HLL	U,LDBDCH(U)	;U/DEVICE CHARARTERISTICS,,PORT LDB
	SKIPL	LDBLOG(U)	;SKIP IF PORT NOT LOGGED IN
	  JRST	DRZNXT
	PUSHJ	P,FRCZAP	;ZAP THE PORT
	PUSHJ	P,CLRTTY	;DO FALSE ZAP STUFF
DRZNXT:	POP	P,U		;RESTORE PORT NUMBER
	ADDI	U,1
	LPERDR==<^D16>*4	;ONE OF 64. 32. or 16. LINES PER DR
	MOVE	T1,U
	ANDI	T1,LPERDR-1	;ONE OF 77, 37, or 17
	CAIG	U,PORTN		;THIS TEST ONLY WORKS FOR LPERDR=64.
	  JUMPN	T1,DRZAP	;GO DO THE NEXT PORT
	AOJA P4,SCNIN1		;EXIT
	>;END IFKMC

KMCANS:			;CALLED WHEN KMC/DR RESPONDS TO A 41 WE SENT IT
IFNKMC	<AOJA P4,SCNIN1>;IGNORE BASE CRASH MESSAGE
IFKMC<
	MOVE	T1,DRMTIM ;;;;;;;TEMP PUT TIME IN IRING 1 MSG
	DPB	T1,INPDL2 ;;;;;;;  "   "    "   "   "   "  "
	LDB	T1,INPLIN	;T1/ PORT LDB
	LSH	T1,-6		;T1/DR NUMBER
	SKIPN	SENT41(T1)	;DON'T SET ANSWERED BIT UNLESS WE SENT 41
	  AOJA	P4,SCNIN1
	SETZM	SENT41(T1)	;RESET "WAITING FOR RESPONSE TO 41"
	PUSH	P,T1
	PUSHJ	P,KMCSUP	;SET DR'S ANSWERED BIT
	POP	P,T1
	ANDI	T1,3
	ADDI	T1,1
	MOVE	T2,DRMCLP
	LSH	T2,3
	IOR	T2,T1
	MOVEM	T2,DRMCLP
	MOVEI	T2,400000
	TDNE	T2,STATES	;ARE WE SHUT?
	  JRST	KMCSHT		;YES, GO SET UP DRMSHT
	MOVE	T2,DRMANS	;NO, SET UP DRMANS INSTEAD
	LSH	T2,3
	IOR	T2,T1
	MOVEM	T2,DRMANS
	AOJA	P4,SCNIN1	;EXIT
KMCSHT:	MOVE	T2,DRMSHT
	LSH	T2,3
	IOR	T2,T1
	MOVEM	T2,DRMSHT
	AOJA P4,SCNIN1
>;END IFKMC
;IQUEUE -- TAKES AN INPUT WAIT TRAP IF SET, OTHERWISE PLACES
; THE JOB IN TTY INPUT WAIT.

IQUEUE:	LDB T1,DDPTTI		;CHECK FOR TRAP WANTED.
	PUSHJ	P, TSTKTJ	;IF INPUT WAIT INTERRUPT WANTED
	 JRST ABTUUO		;YES, ABORT.
	SKIPGE	JBTAWQ(J)	;IF INTERRUPT PENDING
	 JRST ABTUUO		; ABORT
	PUSHJ P,TIWAIT		;NO.  QUEUE JOB FOR TIO WAIT.
	PJRST BIOATT

;OQUEUE -- TAKES AN OUTPUT WAIT TRAP IF SET, OTHERWISE PLACES
; THE JOB IN TTY OUTPUT WAIT.

OQUEUE:	LDB T1,DDPTTI		;CHECK FOR TRAP WANTED.
	PUSHJ P,TSTKTJ		;SEE IF INTERRUPT ON IOW
	 PUSHJ P,SETFIO		;NEEDS WAKUP LATER
	SKIPGE JBTAWQ(J)	;CHECK FOR TRAPS WAITING
	 JRST ABTUUO		;AND ABORT IF ANY.
	PUSHJ P,TOWAT1		;NO.  QUEUE JOB FOR TIO WAIT.

;HERE TO CHECK IF LINE FOR THIS PORT IS STILL ATTACHED.

BIOATT:	SKIPE JBTAWQ(J)
	JRST ABTUUO
	HRRZ U,DDBLDB(F)	;IS LINE STILL ATTACHED?
	JUMPN U,CPOPJ1		;YES.  HE WINS.
	MOVSI T1,TTYATC		;IS THIS THE CONTROLLING TTY
	TDNN T1,DEVMOD(F)	;OR AN AUXILIARY CIRCUIT?
	 JRST AUXRID		;AN AUXCIR ... HE LOSES.
	POPJ P,			;CONTROLLING TTY: HE STILL LOSES
; BLKXIN -- TERMINATE BLOCK INPUT AUXCAL

BLKXIN:	MOVE	T1, LDBMOD(U)
	TLNN	T1, LMLBIO	; BLOCK I/O ENABLED?
	POPJ	P,
	HRRZ	T1, LDBBIO(U)	; T1/ INPUT BUFFER ADDRESS
	JUMPE	T1, BLKXI1	; NO BUFFER
	PUSHJ	P, BLKTRQ	; REQUEST INPUT TERMINATION
	HRRZ	T1, LDBBIO(U)
	SKIPGE	BIOCHR(T1)	; CHECK IN-PROGRESS FLAG
	POPJ	P,		; IN-PROGRESS: DO NOTHING NOW
	MOVSI	S, IOEND	; COMPLETE: SET IOEND
	SKIPA
BLKXI1:	MOVEI	S, IODEND	; NO BUFFER: SET IO.EOF
	IORB	S, DEVIOS(F)
	POPJ	P,

; BLKTRQ -- ROUTINE TO REQUEST BLOCK INPUT TERMINATION

BLKTRQ:	MOVSI	T1, LMLTBI
	TDNE	T1, LDBMOD(U)	; TERMINATION PENDING?
	POPJ	P,		; YES: DO NOTHING
	IORM	T1, LDBMOD(U)	; NO: SET THE FLAG
	MOVEI	T1, 1
	DPB	T1, LOPTRI	;    SET TERMINATE-INPUT
	DPB	T1, LDBOPB(U)	;    AND NEED-OUTPUT
	POPJ	P,

;BLKXOT -- HERE TO TERMINATE BLOCK OUTPUT FOR A PORT IN BIO MODE

BLKXOT:	MOVE	T1, LDBMOD(U)
	TLNN	T1, LMLBIO	;IF BLKIO NOT ENABLED,
	POPJ	P,		;  JUST RETURN
	HLLZ	T1, LDBBIO(U)
	JUMPE	T1, CPOPJ	;IF NO BLK OUTPUT IN PROGRESS, RETURN
	MOVSI	T1, LDLNOP
	ANDCAM	T1, LDBDCH(U)	;IGNORE BACKPRESSURE
	LDB	T1, LOPBOT
	SOJL	T1, BLKXT1	;IF WE'RE ABOUT TO REQUEST BLK OUTPUT,
	DPB	T1, LOPBOT	;  FORGET IT (T1/ 0)
	PJRST	FRCOHR		;  BUT SIMULATE THE OUTPUT-COMPLETE
				;ELSE
BLKXT1:	DPB	T1, LOPTRO	;  SET TO SEND BLKO-TERMINATE (T1/ -1)
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
	POPJ	P,
SUBTTL INPUT AND OUTPUT SUBROUTINES

TYI:	PUSHJ P,TYIEAT	;GET RID OF COMMAND LINE
	SOSGE LDBTIC(U)	;ANY INPUT CHRS LEFT?
	JRST	[SETZM LDBTIC(U)
		POPJ P,]	;NO, NON-SKIP RETURN
	PUSHJ P,BPFTYI		;RESET BACKPREASURE
	MOVE T2,LDBTIT(U)
	PUSHJ P,TTGETC
	 PUSHJ P,FRECHK
	MOVEM T2,LDBTIT(U)
	SKIPN T1,LDBBKP(U)	;ANYTHING IN ^U POINTER
	SOS LDBBKI(U)		;YES, 1 FEWER CHRS
	CAMN T1,T2		;IS THIS THE POINTER NOW
	SETZM LDBBKP(U)		;YES, NOTHING THERE NOW
	TRNE T3,400
	JRST CPOPJ1		;IMAGE CHR
	TRNN T3,200
	SKIPA P3,CHRTAB(T3)
	MOVE P3,CHRTAB-200(T3)	;GET INFORMATION BITS
	LDB T2,CHPRED	;GET READ CODE
TYIRPT:	XCT TYIATB(T2)		;AND DO IT
	SUBI T3,40		;HERE IN LOWER CASE, CONVERT TO UPPER
	JRST CPOPJ1		;DONE

TYIATB:	PHASE 0
	JRST SPRTYI	;SPECIAL ACTION NEEDED
	JRST CPOPJ1	;NORMAL CHR
%CHBRK:! SOSA LDBBKC(U)	;BREAK, FLAGGED SO CALLERS KNOW
	JRST TYIC	;BREAK2
	TLNE U,LDLLCT	;LOWER CASE, SHOULD WE CONVERT?
	DEPHASE

TYIC:	TLNE U,LDLBK2	;IN BREAK2 MODE?
	MOVE T2,%CHBRK	;YES, FLAG AS BREAK FOR CALLERS
	AOS (P)
TYID:	SOS LDBBK2(U)
	JUMPN T1,CPOPJ	;DON'T WORRY IF NO ^U POINTER
	MOVSI T1,-1
	ADDM T1,LDBBKI(U)
	POPJ P,

SPRTYI:	LDB T2,CHPSPR	;GET ACTION CODE
	LDB P3,LDPMOD	;AND LINE MODE
	XCT @SPRTTB(P3)

SPRTTB:	XCT TYIPDP(T2)
	XCT TYI940(T2)
	XCT TYI940(T2)
	XCT TYIPDP(T2)
TYIPDP:	JRST TYICC	;^C
	JRST TYIALT	;33
	JRST TYIBRK	;^_
	JRST TYICZ	;^Z
	JRST TYIPAL	;175-176
	JRST TYITAB	;TAB
	JRST TYIBSP	;BACKSPACE

TYI940:	JRST TYIBRK	;^C
	JRST TYICC	;33 POSSIBLE ESCAPE
	JRST TYICC	;^_
	JRST TYIBRK	;^Z
	JRST TYICCP	;175-176
	JRST TYITAB	;TAB
	JRST TYIBSP	;BACKSPACE

TYITAB:	MOVSI T2,L2LTBK
	TDNN T2,LDBBYT(U)	;TREAT TAB AS BREAK?
	JRST TYIC	;NO AS BREAK2
TYIBRK:	MOVEI T2,%CHBRK	;YES, TREAT AS BREAK
	JRST TYIRPT

TYIBSP:	MOVSI T2,L2LBBP
	TDNE T2,LDBBYT(U)	;TREAT BSP AS BREAK
	JRST TYIC	;NO, AS BREAK2
	JRST TYIBRK	;YES

TYIPAL:	TLNN U,LDLLCT	;IN TTY LC
	JRST TYIBRK	;YES, JUST A BREAK CHARACTER
TYIALT:	MOVEI T2,LDRFCS	;ALTMODE. IN FULL CHR SET MODE?
	TDNN T2,LDBDCH(U)
	MOVEI T3,STDALT	;NO, STANDARD
	JRST TYIBRK

TYICZ:	HRRZ F,LDBDDB(U)
	JUMPE F,TYIBRK	;NO DDB, JUST BREAK CHR
	MOVSI T4,IOEND
	IORM T4,DEVIOS(F)	;SET END OF FILE
	JRST TYIBRK
TYICCP:	TLNN U,LDLLCT	;IN TTY LC
	JRST TYIBRK	;YES, TRAT AS BREAK
TYICC:	SOS LDBBKC(U)
	MOVE J,JOB	;ALSO FALL HERE FROM ABOVE
	PUSHJ P,ESCTR1	;TRY TRAPPING
	PUSHJ P,CNCCHK	;CHECK SPECAIL CONDITIONS
	JRST [
		LDB	P3, LDPMOD	; GET MONITOR MODE
		MOVEI	T3, 3		; ^C FOR 10'S
		CAIE	P3, 1		; GE MODE?
		CAIN	P3, 2		; TYMEX MODE?
		MOVEI	T3, 33		; ESC FOR 940'S
		AOS	LDBBKC(U)	; SOS'D IN TYIBRK
		JRST	TYIBRK		; PASS TO PROGRAM
	]
	PUSHJ P,TIWAIT	;HALT COMMAND ALREADY SET
	PUSHJ	P, CKATTI	;MAKE SURE IT'S STILL ATTACHED
	JRST	ABTUUO		;(S)HE WANTS AN INTERRUPT
	JUMPN	U, TYI		;TRY AGAIN (FOR CONTINUE)
	  STOPCD		;HORRORS! NOT A COMMAND PORT!
;GET RID OF COMMAND LINE

TYIEAT:	TLNN U,LDLECS	;ALREADY DONE THIS?
	POPJ P,		;YES
	PUSH P,T3
	PUSH P,P3	;ALSO SAVE THIS (TTYSTR AND FRIENDS)
TYIL:	SOSGE LDBTIC(U)
	JRST [SETZM LDBTIC(U)
		JRST TYIET2]
	MOVE T2,LDBTIT(U)
	PUSHJ P,TTGETC
	 PUSHJ P,FRECHK
	MOVEM T2,LDBTIT(U)
	SKIPN T1,LDBBKP(U)
	SOS LDBBKI(U)	;SAME AS IN TYI
	CAMN T1,T2
	SETZM LDBBKP(U)
	TRNE T3,400
	JRST TYIL	;IMAGE, TRY NEXT
	TRNN T3,200
	SKIPA P3,CHRTAB(T3)
	MOVE P3,CHRTAB-200(T3)
	LDB T2,CHPRED
	XCT EATTAB(T2)
	JRST TYIL	;TRY NEXT

EATTAB:	JRST SPREAT	;SPECIAL ACTION
	JRST TYIL	;NOMAL CHR
	JRST TYIET3	;BREAK CHR, FINISHED
	PUSHJ P,TYID	;BREAK2
	JRST TYIL	;LOWER CASE, JUST LIKE NORMAL

SPREAT:	LDB T2,CHPSPR
	XCT SPRETB(T2)	;SAME IN ALL MODES
	XCT -5+[TDNE T3,LDBBYT(U)	;FROM TAB
	        TDNN T3,LDBBYT(U)](T2)	;FROM BACKSPACE
	JRST TYIET3	;TREAT AS BREAK
	PUSHJ P,TYID	;TREAT AS BREAK2
	JRST TYIL

SPRETB:	JRST TYIET3	;^C
	JRST TYIET3	;33
	JRST TYIET3	;^_
	JRST TYIET3	;^Z
	JRST TYIET3	;175-176
	MOVSI T3,L2LTBK	;TAB, CHECK BREAK OR BREAK2
	MOVSI T3,L2LBBP	;BACKSPACE, CHECK BREAK OR BREAK2

TYIET3:	SOS LDBBKC(U)	;A BREAK CHR FINISHED
TYIET2:	MOVSI T1,LDLECS	;FINISHED BECAUSE OUT OF CHRS
	ANDCAM T1,LDBDCH(U)	;TURN OFF FLAG IN ANY CASE
	POP P,P3
	POP P,T3
	HLL U,LDBDCH(U)
	POPJ P,
COMMENT %
@@SUBROUTINE TYO, CMDTYO
@@PURPOSE TYO -- CHECK FOR SPACE, PLACE CHAR IN OUTPUT BUFFER
	  CMDTYO -- ASSUME SPACE, PLACE CHAR IN OUTPUT BUFFER
@@ENTRY	T3/ CHAR, F/ DDB ADDR, U/ (NONZERO) LDB ADDR
@@ACCUM	T1-T2 DESTROYED
@@EXIT	ON A SKIP-RETURN, THE CHARACTER HAS BEEN DEPOSITED.
THE NONSKIP-RETURN IS NOT ACTUALLY A RETURN BUT RATHER A
PUSHJ TO ITS CALLER. IT IS TAKEN WHEN THERE IS NO ROOM FOR
THE CHARACTER AND THE JOB WANTS A TRAP. THE CALLER HAS
THREE CHOICES:
	1) ABORT THE UUO, GIVING THE JOB ITS TRAP
	2) MAKING ROOM FOR THE CHARACTER, THEN POPJ-ING,
	   CAUSING TYO TO RETRY THE DEPOSIT
	3) AOS (P) / POPJ -ING, CAUSING TYO TO GO INTO
	   OUTPUT WAIT
%

TYO:	MOVE	T1, TTFREN	;T1/ # FREE CHUNKS
	CAIL	T1, TIRSVD	;IF #FREE < #SAVED,
	JRST	TYO1
	MOVSI	T1, TWTSPC
	IORM	T1, DEVIOS(F)	;  MARK NO-CHUNKS WAIT
	JRST	TYOW2		;  AND GO WAIT
TYO1:	MOVE	T1, LDBTOC(U)	;T1/ # CHARS LEFT TO OUTPUT
	SKIPGE	LDBDCX(U)	;IF IT'S FAST
	CAML	T1, OMX120	;AND UNDER THE FAST MAXIMUM,
	CAMGE	T1, OMX30	;OR IF IT'S UNDER THE SLOW MAXIMUM,
	JRST	TYO2		;  CONTINUE OUTPUT.
	SKIPGE	LDBBYT(U)	;IF IT'S NOT EXTENDED-MODE
	CAML	T1, TOEMAX	;OR IT'S OVER THAT LIMIT,
	JRST	TYOW		;  GO TRAP OR WAIT
TYO2:	AOS	(P)		;PREPARE FOR SKIP-RETURN
	HLL	U, LDBDCH(U)
	TLNE	U, LDLOSU	;IF SUPPRESSING OUTPUT,
	POPJ	P,		;  JUST (SKIP-)RETURN
CMDTYO:	SKIPE	T2, LDBTOP(U)	;IF NO CHUNK ALLOCATED,
	JRST	TYO3
	PUSHJ	P, GETCHK	;  T2/ CHUNK BYTE POINTER
	MOVEM	T2, LDBTOP(U)	;  SET OUTPUT PUTTER
	MOVEM	T2, LDBTOT(U)	;  SET OUTPUT TAKER
	SETZM	LDBTOC(U)	;  SET OUTPUT COUNT
TYO3:	PUSHJ	P, TTPUTC	;STORE CHAR.; T2 := NEW PUTTER
	MOVEM	T2, LDBTOP(U)	;STORE NEW PUTTER
	AOS	LDBTOC(U)	;UPDATE COUNT
	POPJ	P,
TYOW:	LDB	T1, DDPTTI	;T1/ IOW TRAP CHANNEL
	PUSHJ	P, TSTKTJ	;SETUP TRAP IF ENABLED. IF IT WAS,
	PUSHJ	P, SETFIO	;  MARK DDB FOR OUTPUT-DONE TRAP
	LDB	T1, PJOBN
	SKIPL	JBTAWQ(J)	;IF AWAITING A TRAP,
	JRST	TYOW1
	PUSHJ	P, @(P)		;  RETURN TO CALLER AS COROUTINE
	JRST	TYO		;  (NONSKIP FROM RECALLED CALLER)
TYOW1:	JUMPE	U, TYOW3	;IF ATTACHED,
TYOW2:	MOVEI	T1, 1
	DPB	T1, LOPOUT	;  SET CHARACTER-OUTPUT
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
TYOW3:	PUSHJ	P, TOWAT1	;GO INTO OUTPUT WAIT
TYOW4:	HRRZ	U, DDBLDB(F)	
	JUMPN	U, TYO		;IF STILL ATTACHED, TRY AGAIN
	MOVSI	T1, TTYATC
	TDNN	T1, DEVMOD(F)	;IF IT'S NOT THE COMMAND PORT,
	PJRST	AUXRID		;  DISCARD DDB AND ABORT UUO
	JRST	TYOW		;OTHERWISE, WAIT FOR ATTACH
;MAKE SURE TTY IS ATTACHED, NO CHANCE FOR INTERRUPT

CKATTF:	MOVE S,DEVIOS(F)
	HRRZ U,DDBLDB(F)
	JUMPN U,UUOLDB
	MOVSI T1,TTYATC
	TDNN T1,DEVMOD(F)
	JRST AUXRID	;CAN GET RID OF DDB FOR AUX CIRCUIT
	PUSHJ P,TOWATA
	JRST CKATTF		;TRY AGAIN

;CHECK TO SEE THAT THERE IS ROOM FOR AT LEAST ONE CHARACTER TO BE OUTPUT

CHKROM:	HLRZ T1,LDBBIO(U)	;BLOCK OUTPUT NOW IN PROGRESS?
	JUMPN T1,CHKRM1		;YES. QUEUE JOB FOR OUTPUT WAIT.
	MOVE 	T1,TTFREN
	CAIGE 	T1,TIRSVD	;IS THERE BUFFER SPACE?
	JRST	CHKRM3
	MOVE 	T1,LDBTOC(U)	;NUMBER NOW IN OUTPUT BUFFER
	SKIPGE	LDBDCX(U)	;IF IT'S FAST
	CAML	T1, OMX120	;AND UNDER THE FAST MAXIMUM,
	CAMGE	T1, OMX30	;OR IF IT'S UNDER THE SLOW MAXIMUM,
	JRST	CPOPJ1		;  SAY THERE'S ROOM
CHKRM1:	LDB J,PJOBN
	SKIPGE JBTAWQ(J)
	JRST ABTUUO
	LDB T1,DDPTTI
	PUSHJ P,TSTKTP		;SEE IF WE CAN TAKE AN INTERRUPT
	 SKIPA			;YES, MUST MAKE SURE WE SET OUTPUT ROOM FLAG
	JRST TOWAT1		;QUEUE JOB FOR OUTPUT WAIT.
CHKRM2:	PUSHJ P,SETFIO
	JRST ABTUUO		;NOW GET OUT OF UUO

	;HERE WHEN THERE'RE NO BUFFERLETS AVAILABLE FOR
	;THE OUTPUT
CHKRM3:	LDB	T1, DDPTTI
	PUSHJ	P, TSTKTJ	;DOES HE GET AN I/O WAIT TRAP?
	JRST	CHKRM2		;YES: DO IT
	MOVSI	T1, TWTSPC
	IORM	T1, DEVIOS(F)	;NO: MARK REASON FOR WAIT
	PJRST	TOWAT1		;    AND DO IT


; CALL TO SEE IF ROOM FOR A CHARACTER
; F/DDB U/LDB
; PUSHJ P,IFROOM
;  <NO ROOM>
; <ROOM>

IFROOM:	MOVE 	T1,TTFREN
	CAIGE 	T1,TIRSVD	;IS THERE BUFFER SPACE?
	POPJ	P,
	MOVE 	T1,LDBTOC(U)	;NUMBER NOW IN OUTPUT BUFFER
	SKIPGE	LDBDCX(U)	;IF IT'S FAST
	CAML	T1, OMX120	;AND UNDER THE FAST MAXIMUM,
	CAMGE	T1, OMX30	;OR IF IT'S UNDER THE SLOW MAXIMUM,
	AOS	(P)		;  SAY THERE'S ROOM
	POPJ	P,

;SUBROUTINES TO SET UP LINE AND MAKE SURE ATTACHED.
;CALL WITH F SET UP, FROM M LEVEL ONLY.
;RETURN WHEN ATTACHED AND AT USER LEVEL, WITH U SET UP.

;ONE ROUTINE FOR INPUT, ONE FOR OUTPUT.

CKATTI:	MOVE S,DEVIOS(F)		;SET UP STATUS WORD
	HRRZ U,DDBLDB(F)		;GET U BLOCK ADDR
	JUMPN U,CKATI2		;IF THERE, GO ON
	MOVSI T1,TTYATC
	TDNN T1,DEVMOD(F)
	JRST CPOPJ1	;AUX CIRCUIT, SPECIAL
CKATI2:	LDB T1,PJOBN		;NOW CHECK IF JOB WAITING FOR
	SKIPGE JBTAWQ(T1)	;AN INTERRUPT
	POPJ P,			;YES
	JUMPN U,CKATI1
CKATIW:	SKIPE	SKPFLG		;DON'T WAIT FOR ATTACH IF INC AND SKP AUXCAL
	POPJ	P,
	LDB T1,DDPTTI
	PUSHJ P,TSTKTJ		;IS THIS AN IOW INTERRUPT
	 POPJ P,		;YES
	MOVSI S,IO+TTYOUW		;MUST WAIT FOR ATTACH
	ANDCAM S,DEVIOS(F)		;CLEAR DIRECTION BIT
	MOVEI S,IOACT			;AND SET WAIT BIT FOR INPUT
	IORB S,DEVIOS(F)		; ..
	PUSHJ P,WSYNCS			;WAIT FOR ATTACH
	JRST CKATTI			;GET U SET UP AND RETURN.

CKATI1:	HLL U,LDBDCH(U)		;GET DEVICE BITS
	TLNE U,LDLCOM		;AT COMMAND LEVEL?
	JRST CKATIW			;YES. CAN'T1 DO INPUT.
	PUSHJ P,TYIEAT			;NO. SKIP ANY COMMANDS
	AOS (P)
	PJRST UUOLDB			;AND GO ADJUST U BITS.

CKATTO:	MOVE S,DEVIOS(F)		;SET UP STATUS WORD
	HRRZ U,DDBLDB(F)		;GET U ADDR IF ANY
	JUMPN U,CKATO2		;IF HAVE ONE, SEE IF TOP LEVEL
	MOVSI T1,TTYATC
	TDNN T1,DEVMOD(F)
	JRST CPOPJ1
CKATO2:	LDB T1,PJOBN
	SKIPGE JBTAWQ(T1)
	POPJ P,		;WAITING FOR INTERRUPT
	JUMPN U,CKATO1
	LDB T1,DDPTTI
	PUSHJ P,TSTKTJ
	  PJRST  SETFIO		; INTERRUPT ON IOW
	PUSHJ P,TOWATA			;WAIT FOR OUTPUT DONE. (WHICH
					; IS FORCED ON ATTACH)
	JRST CKATTO			;AND SET UP U, TO RETURN.
CKATO1:	AOS (P)
	MOVSI T1,L2LOEX
	ANDCAM T1,LDBBYT(U)	;TURN OFF EXTENDED OUTPUT
;	PJRST UUOLDB			;FALL INTO UUOLDB
;UUOLDB -- MAKE LDB (ADDR IN U) AGREE WITH FILE STATUS BITS (IN S)

UUOLDB:	JUMPE U,CPOPJ	;JUST IN CASE
	HLL U,LDBDCH(U)	;MAKE SURE LEFT HALF SET
	TLNE U,LDLAUX
	POPJ P,		;DO NOTHING FOR AN AUX CIRCUIT

    ;SET MONITOR MODE BITS

	PUSH P,J
	LDB J,PJOBN
	LDB T4,PVYMOD
	DPB T4,LDPMOD
	POP P,J		;SET MODE

    ;SET LDBDCX BITS

	MOVE	T1, LDBDCX(U)
	TRNE	S, DLRSUP
	TLOA	T1, LXLDLR	;SUPPRESS-$
	TLZ	T1, LXLDLR	;DON'T SUPPRESS $
	MOVEM	T1, LDBDCX(U)

    ;GET LDB BITS FROM FILE STATUS BITS

	SETZ T1,
	TRNE S,FCS
	TRO T1,LDRFCS
	TRNE S,NOECHO
	TLO T1,LDLNEC
	TLNE S,IOSBKA
	TLO T1,LDLBKA
	TRNE S,BK2IOS
	TLO T1,LDLBK2

    ;SET THE LDBDCH BITS

	MOVE T4,T1
	XOR T4,LDBDCH(U)	;T4/ THE BITS THAT CHANGED
	IORM T1,LDBDCH(U)
	TDC T1,[LDLNEC!LDLBKA!LDLBK2,,LDRFCS]
	ANDCAB T1,LDBDCH(U)
	HLL U,T1		;UPDATE LH(U)

    ;FINISH UP

	MOVE S,DEVIOS(F)	;UPDATE S
	TLNE T4,LDLNEC	;IF WE'RE CHANGING ECHO MODE
	TRNE T1,LDRDEM	;AND LDRDEM NOT SET,
	PJRST SETLMD
	MOVEI T1,1	;  SET TO CHANGE ECHO MODE
	DPB T1,LOPSEC
	DPB T1,LDBOPB(U)
	PJRST SETLMD	;AND GO SET LINE MODE
TWAITL:	MOVSI S,IOSBKA
	ANDCAB S,DEVIOS(F)
	MOVSI T1,LDLBKA
	ANDCAM T1,LDBDCH(U)	;SET FOR U MODE INPUT
	PUSHJ P,SETLMD
	MOVE T1,LDBTIC(U)
	HLL U,LDBDCH(U)	;MAKE SURE U IS OK
	MOVE T4,LDBBKC(U)	;GET BREAK COUNT
	TLNE U,LDLBK2	;IF IN BREAK2 MODE
	ADD T4,LDBBK2(U)	;NUMBER IS SUM
	CAIGE T1,TIWKC
	TRNE T4,-1		;IF A BREAK OR ENOUGH CHRS
	POPJ P,			;GO NOW
	TLNN U,LDLIMI	;IN IMAGE MODE?
	JRST TWTL1		;NO, MUST WAIT
	SKIPN LDBTIC(U)	;YES, ANY CHRS?
	TLNE S,IOEND		;OR END OF FILE SET
	POPJ P,			;IF END FLAGGED, THEN DONE
	SKIPE LDBECC(U)	;ARE THERE ANY CHRS THERE AT ALL?
	JRST TWTL2	;YES, I/O WAIT BUT NO TRAP
	JRST TWTL3	;NO, I/O WAIT WITH POSSIBLE TRAP
TWTL1:	JUMPN T4,TWTL2	;IF UNECHOED BREAK CHRS, I/O WAIT NO TRAP
	ADD T1,LDBECC(U)
	CAIL T1,TIWKC	;OR POSSIBLEY TOO MANY TOTAL
	JRST TWTL2	;I/O WAIT NO TRAP
TWTL3:	LDB T1,DDPTTI	;CHECK FOR TRAP WANTED
	PUSHJ P,TSTKTJ		;SEE IF INTERRUPT ON IOW
	 JRST ABTUUO		;YES, ABORT
TWTL2:	PUSHJ P,TIWAIT
	PUSHJ P,CKATTI
	 JRST ABTUUO
	JUMPN U,TWAITL
	JRST AUXRID	;ZAPPED AUX CIRCUIT

TWAITS:	;AOS	SKPFLG	;CALLED BY AN INPUT AND SKIP AUXCAL
	JFCL		;FOR NOW UNTIL CAN FIND OUT WHY SKPFLG STAYS SET
			;WHEN SHOULDN'T
	AOS	(P)	;SET TO SKIP RETURN
TWAITC:	MOVSI S,IOSBKA
	IORB S,DEVIOS(F)
	MOVSI T1,LDLBKA
	IORM T1,LDBDCH(U)
	PUSHJ P,SETLMD
	HLL U,LDBDCH(U)	;MAKE SURE U OK FOR CALLERS
	SKIPLE LDBTIC(U)	;ANY CHARACTERS PRESENT?
	POPJ P,
	SKIPE LDBECC(U)
	JRST TWTC1	;SOME CHRS SO NO I/O TRAP
	LDB T1,DDPTTI
	PUSHJ P,TSTKTJ		;CHECK IOW WAIT INTERRUPT
	 JRST 	TWABT		;GET OUT
TWTC1:	PUSHJ P,TIWAIT
	PUSHJ P,CKATTI
	 JRST 	TWABT	;WAITING FOR INTERRUPT
	MOVE	T1,SKPFLG
	SETZM	SKPFLG
	JUMPN	U,TWTC2		;JUMP IF LINE ATTACHED
	MOVSI	T1,TTYATC
	TDNN	T1,DEVMOD(F)
	JRST	AUXRID		;ZAPPED AUX CIRCUIT
	SOS	(P)		;ZAPPED CMD PORT FROM INC AND SKP AUXCAL
	POPJ	P,
TWTC2:	JUMPGE	T1,TWAITC	;GET ENOUGH INPUT CHARS?
	POPJ	P,		;NO

TWABT:	SETZM	SKPFLG
	JRST	ABTUUO
TIWAIT:	MOVSI S,IO!TTYOUW
	ANDCAM S,DEVIOS(F)	;SET DIRECTION
	MOVEI S,IOACT
	IORB S,DEVIOS(F)	;SET WAIT BIT
	MOVEI T1,IMGTIM
	TLNE U,LDLIMI
	DPB T1,LDPTIM		;SET TIMER IF IN IMAGE MODE
	MOVEI T1,1
	DPB T1,LOPECO		;SET ECHO-NEEDED
	DPB T1,LDBOPB(U)	;AND NEED-OUTPUT
	JRST WSYNCS

;ROUTINE TO WAIT FOR NEARLY EMPTY OUTPUT BUFFER. CALL ONLY AT M LEVEL
TOWAIT:	MOVE T1,LDBTOC(U)		;GET COUNT OF TYPE-OUT CHARACTERS WAITING.
	CAIGE T1,10			;OVER 7?
	POPJ P,0			;NO. JUST RETURN.
TOWAT1:	MOVE S,[XWD TTYOUW+IO,IOACT]	;FLAG OUTPUT WAIT ACTIVITY
	IORM S,DEVIOS(F)		;IN THE DEVICE DATA BLOCK
WSYNCS:	MOVSI S,TIOUSE
	IORB S,DEVIOS(F)
	PUSH P,P1			;HAVE TO SAVE AC'S TO WAIT
	PUSH P,P2			; BECAUSE WSYNC USES THESE
	PUSH P,T3
	PUSH P,F
	PUSH P,W
	PUSHJ P,SCNINT		;GIVE HIM A CHANCE TO ECHO BEFORE PUTTING HIM IN WAIT
	POP P,W
	POP P,F
	POP P,T3
	MOVE	S,DEVIOS(F)	
	TRNN	S,IOACT		;DO WE NEED TO GO INTO WAIT?
	JRST	WSYNC1		;NO
	SKIPN	SKPFLG		;INPUT AND SKIP CALL IN PROGRESS?
	JRST	WSYNC2		;NO
	SETOM	SKPFLG		;COULDN'T GET ENOUGH INPUT CHARS
	PUSHJ	P,TIWAKN	;DON'T BLOCK
	SKIPA
WSYNC2:	PUSHJ P,WSYNC			;WAIT
WSYNC1:	POP P,P2			;RESTORE AC'S
	POP P,P1			; ..
	MOVSI S,TIOUSE
	ANDCAB S,DEVIOS(F)
	POPJ P,0			;AND RETURN FROM TOWAIT
SUBTTL BACKPRESSURE ADJUSTERS

;BPLVD -- CALLED BY LEVDEF UUO

BPLVD:	MOVEI	T1, LDRXOS!LDRBPS
	TDNE	T1, LDBDCH(U)	;IF WE'VE SENT BACKPRESSURE OR AN XOFF
	JRST	.+3
	LDB	T1, LOPBPN
	JUMPE	T1, CPOPJ	;OR WE'RE PLANNING TO,
	MOVE	T1, LDBECC(U)
	ADD	T1, LDBTIC(U)
	CAIL	T1, TIWKC	;AND WE DON'T HAVE GOBS OF CHARACTERS,
	POPJ	P,
	JRST	BPFCOM		;  SET TO CLEAR BACKPRESSURE

;BPFTYI -- CALLED AT THE START OF TYI

BPFTYI:	MOVEI	T1, LDRXOS!LDRBPS
	TDNE	T1, LDBDCH(U)	;IF WE'VE SENT BACKPRESSURE OR AN XOFF
	JRST	.+3
	LDB	T1, LOPBPN
	JUMPE	T1, CPOPJ	;OR WE'RE PLANNING TO,
	MOVE	T1, LDBECC(U)
	ADD	T1, LDBTIC(U)
	CAIL	T1, 10		;AND WE HAVE HARDLY ANY CHARACTERS,
	POPJ	P,
	JRST	BPFCOM		;  SET TO CLEAR BACKPRESSURE

;BPXOFF -- CALLED WHEN DONE ECHOING, ON CLRBFI, BEFORE DOING
;	   BLOCK INPUT, AFTER READING COMMAND LINE
;BPOFF -- CALLED WHEN ENTERING COMMAND LEVEL, WHEN FORCED
;	  OUT OF IMAGE STATE BY SCNSEC OR CLRIMI

BPXOFF:	SKIPA	T1, [LDRBPS!LDRXOS]
BPOFF:	MOVEI	T1, LDRBPS
	TDNE	T1, LDBDCH(U)	;IF WE'VE SEND BACKPRESSURE (OR XOFF)
	JRST	BPFCOM
	LDB	T1, LOPBPN	;OR WE'RE ABOUT TO,
	JUMPE	T1, CPOPJ
	;JRST	BPFCOM		;  SET TO CLEAR BACKPRESSURE

BPFCOM:	MOVEI	T1, 1
	DPB	T1, LOPBPF	;SET BACKPRESSURE-OFF
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	POPJ	P,

;ROUTINE TO CHECK TO SEE IF BACKPRESSURE SHOULD BE TURNED OFF.  SKIP RETURNS
;IF SHOULD NOT BE TURNED OFF ELSE NON-SKIP RETURNS
;
BPTEST:	PUSH	P,T1
	MOVE	T1,LDBTIC(U)	;COMPUTE TOTAL NUMBER
	ADD	T1,LDBECC(U)	; OF CHARACTERS WAITING
	CAMG	T1,TIWRNN	;GREATER THAN BACKPRESSURE ON THRESHOLD?
	JRST	TPOPJ		;NO, TURN OFF BACKPRESSURE
	JRST	TPOPJ1		;YES, LEAVE BACKPRESSURE ON
SUBTTL COMMAND ROUTINES

;ROUTINE TO MAKE THIS TTY VISIBLE TO COMMAND DECODER, IF AT COM LEVEL
;CALL WITH U SET UP

CMDWAK:	SKIPN	FRSFLG		;IF IT'S JUST THE RESCAN-STUFFER,
	  JRST	CMDWK1
	SETZM	FRSFLG		;  TELL IT WE GOT HERE
	POPJ	P,
CMDWK1:	TLNN	U,LDLCOM	;IS U AT COMMAND LEVEL?
	  POPJ	P,0		;NO. JUST RETURN
	MOVSI	T1,L2LLDF
	ANDCAM	T1,LDBBYT(U)	;RESET FLAG, USER AWAKE
	SETZ	T1,		;Indicate to COMWCM that command comes
				;from terminal
; Enter here with command index in T1 (or 0 if not forced command)
TTFORC:	PUSH	P,F		;Preserve
	LDB	F,LOPZAP	;If we're going to ZAP it,
	JUMPN	F,FPOPJ		; ignore the command
	HRRZ	F,LDBDDB(U)	;Set up DDB pointer
	JUMPE	F,FPOPJ		;None there, just exit
	PUSH	P,J
	LDB	J,PJOBN		;Find job/frame number
	SKIPE	J		;None there...
	PUSHJ	P,COMWCM##	;Set command request for this job/frame
	POP	P,J
FPOPJ:	POP	P,F
	POPJ	P,

;;
;; Routine to set up command input pointer to accept command
;;  input from TTY.  Clobbers T2.
;;
TRESCN:	MOVE	T2,LDBTIT(U)	;TTY input buffer pointer
	MOVEM	T2,TTCMCA	;Copy into command input pointer
	MOVEI	T3,40		;Delimiter
	MOVEM	T3,TTCMCH
	POPJ	P,

COMTYO:	PUSH P,T2			;SAVE AC
	PUSHJ P,@COMTOA			;CALL CCTYO OR ONCE ROUTINE
	POP P,T2			;RESTORE AC
	POPJ P,0			;AND RETURN.

CCTYI:	SKIPE T2,TTCMCA		;REAL INPUT ROUTINE FOR COMMAND
	CAMN T2,LDBTIP(U)	;NOTHING OR AT END OF BUFFER
	JRST CCTYI1		;GO FAKE A BREAK
	PUSHJ P,TTGETC
	 JFCL
	MOVEM T2,TTCMCA
	POPJ P,

CCTYI1:	MOVEI T3,12
	POPJ P,
;COMMAND INPUT ROUTINE

COMTYI:	PUSHJ P,COMTYT	;FETCH A CHARACTER
	  SUBI T3,40	;UPSHIFT LOWER CASE
	POPJ P,

COMTYT:	MOVE T3,TTCMCH
	CAIE T3,3
	CAIN T3,12	;THESE ARE FINISHED FLAGS
	JRST CPOPJ1	;DO NOT TRY TO READ FURTHER
	PUSH P,T2
	PUSH P,P3	;SAVE REGISTERS FOR CALLERS
	HLL U,LDBDCH(U)
COMTI1:	PUSHJ P,@COMTIA	;GET A CHR
	ANDI T3,177	;NOT INTERESTED IN EXTRA BITS
	MOVE P3,CHRTAB(T3)
	LDB T1,CHPRED
	XCT COMATB(T1)
	CAIN T3,15	;RETURN IS SPECAIL
	JRST COMTI1	;GO GET LF AND SAY NOTHIGN ABOUT RETURN
COMTI2:	MOVEM T3,TTCMCH	;REMEMBER CHR FOR REREAD
	POP P,P3
	POP P,T2
	JRST CPOPJ1

COMATB:	JRST SPRCOM	;SPECIAL ACTION
	JFCL		;NORMAL CHR
	MOVEI T3,12	;TURN ALL BREAKS TO LINE FEEDS
	JFCL		;BREAK2
	SOS -2(P)	;NON-SKIP RETURN ON LOWER CASE CHAR

SPRCOM:	LDB T1,CHPSPR	;GET CHR TYPE
	LDB T2,LDPMOD	;AND LINE MODE
	XCT @SPRCTB(T2)
	JRST COMTI2	;FINISH UP
SPRCTB:	XCT COMPDP(T1)
	XCT COM940(T1)
	XCT COM940(T1)
	XCT COMPDP(T1)

COMPDP:	MOVEI T3,3	;^C
	MOVEI T3,12	;33
	MOVEI T3,12	;^_
	MOVEI T3,12	;^Z
	MOVEI T3,12	;175-176
	JRST COMTAB	;TAB
	JRST COMBSP	;BACKSPACE

COM940:	MOVEI T3,12	;^C
	MOVEI T3,3	;33
	MOVEI T3,3	;^_
	MOVEI T3,12	;^Z
	JRST COMPA	;175-176
	JRST COMTAB	;TAB
	JRST COMBSP	;BACKSPACE

COMTAB:	MOVSI T1,L2LTBK
	TDNE T1,LDBBYT(U)
	MOVEI T3,12	;TREAT AS BREAK
	JRST COMTI2	;TREAT AS BREAK2

COMBSP:	MOVSI T1,L2LBBP
	TDNN T1,LDBBYT(U)
	MOVEI T3,12	;TREAT AS BREAK
	JRST COMTI2	;TREAT AS BREAK2

COMPA:	MOVEI T3,3
	TLNN U,LDLLCT
	MOVEI T3,12
	JRST COMTI2	;EITHER AN ESCAPE OR JUST A BREAK CHR
;ROUTINE TO SWITCH TTY TO USER PROGRAM LEVEL AND START USER RUNNING

TTYUSW:	TDZA S,S			;DON'T1 CLEAR WAIT BITS
TTYUSR:	MOVE S,[XWD IOW,IOACT]		;CLEAR WAIT BITS
	PUSHJ P,TTYUS0			;PUT TTY IN USER
	PJRST SETRUN			;MAKE HIM RUN AND RETURN

;CALL TTYUSM TO SIMPLY PUT TERM IN USER MODE

TTYUSM::SETZ S,				;DON'T CLEAR WAIT BITS
TTYUS0:	JUMPE	U,CPOPJ			;Exit if no LDB
	HRRZ F,LDBDDB(U)		;GET ATTACHED F IF ANY
	JUMPE F,TTYUS1			;JUMP IF NOT ATTACHED
	ANDCAB S,DEVIOS(F)		; ..
	PUSHJ P,UUOLDB			;MAKE U AND DEVIOS AGREE
TTYUS1:	MOVSI T1,LDLCOM			;PUT TTY IN USER MODE
	ANDCAM T1,LDBDCH(U)		;MAY BE DETACHED, BUT WILL WAIT
					; AT M LEVEL IF NEEDED
	PUSHJ P,SETLMD
	POPJ P,

;; Here when terminal-originated command has completed

TTYCMR::
	MOVSI	T1,LDLECS		;Set EAT-COMMAND-SYNC bit
	IORM	T1,LDBDCH(U)		; in Line Data Block
	POPJ	P,

TTYSTC:	JUMPE U,CPOPJ
	MOVSI T1,LDLIMI			;FORCE OUT OF IMAGE MODE
	PUSHJ P,CNCMD1			;WILL ALSO SET COMMAND BIT
TTYSTR:	JUMPE	U,CPOPJ			;Exit if no LDB
	HLL U,LDBDCH(U)
	TLNN U,LDLCOM			;AT COMMAND LEVEL?
	  PJRST NOCTRO			;NO. JUST CLEAR ^O BIT
	PUSHJ P,TYIEAT			;CLEAR THE COMMAND IN CASE MORE
	HRRZ T1,LDBBKC(U)		;NUMBER OF DEF ECHO BREAK CHARS
	JUMPE T1,CKSXON			;NO BREAKS WAITING
	PUSHJ P,CMDWAK			;SET FOR COMMAND
	JRST NOCTRO			;AND GO CLEAR BIT
MONHNG:	HRLI T1,3
	PUSHJ P,HNGMON
	 JFCL
	POPJ P,
;SUBROUTINE FOR COMMAND LEVEL OUTPUT

CCTYO:	JUMPE U,CPOPJ	;IGNORE IF U NOT SET UP
	MOVE T1,LDBTOC(U)		;GET COUNT
	SKIPLE TTFREE			;SPACE IN STRINGS?
	CAIL T1,^D200			;YES. SPACE IN THIS GUY'S AREA?
	POPJ P,0			;NO. QUIT.
	PUSHJ P,CMDTYO	;TYPE CHR
	PJRST ONEOU3	;AND START OUTPUT

CTYTYP:	MOVSI P3,440700!P1		;POINTER FOR ASCIZ
CTYTYL:	ILDB T3,P3			;GET CHARACTER
CTYTYX:	JUMPE T3,(T1)			;RETURN
	PUSHJ P,CTYTYO
	JRST	CTYTYL

IFCPU (<KI,F3>),<
CTYTYO:	CONSZ CTY,TT.OB			;WAIT FOR CTY TO BE IDLE
	JRST .-1			; ..
	DATAO CTY,T3			;SEND (WITHOUT PARITY, DONT TRUST P)
	CAIN T3,15
	SKIPN T3,CTYFIL		;SEE IF NEED FILL FOR CR
	POPJ	P,
	CONSZ CTY,TT.OB
	JRST .-1
	DATAO CTY,[377]
	SOJG T3,.-3
	POPJ	P,	;FINISHED SENDING FILL CHARS
>;END IFCPU (<KI,F3>)
IFCPU (KL),<
;ROUTINES TO RUN CTY THROUGH DTE

SPHNGI:	0	;INSTRUCTION TO XCT IF DTE HANGS UP
SPCST1:	0	;FOR SAVING T1
SPCTRY:	0	;# OF REMAINING TRIES
SPCTRN==10	;# TO INIT SPCTRY TO

CTYTYO:	PUSHJ	P,CTYCHR	;TYPE OUT CHAR
	SKIPN	CTYFIL		;HAVE TO DO FILLERS?
	POPJ	P,		;NO, RETRN.
	PUSH	P,T3		;SAVE CHAR AC
	PUSH	P,T1		;ANOTHER
	MOVE	T1,CTYFIL	;NUMBER OF RUBOUTS TO DO
CTYTY1:	MOVEI	T3,377		;RUBOUT IS FILL CHAR
	PUSHJ	P,CTYCHR
	SOJG	T1,CTYTY1	;DO THIS MANY
	POP	P,T1
	POP	P,T3
	POPJ	P,
CTYCHR:	MOVEM	T3,SPCTRY	;SAVE CHAR AMINUTE
	MOVEI	T3,100000	;NUMBER OF TIMES TO TRY
				;THIS NUMBER DETERMINED BY EXPERIMENT WITH CACHE ON.
	EXCH	T3,SPCTRY	;GET CHAR BACK, STORE TRY COUNT.
	ANDI	T3,377		;JUST CHARACTER.
	MOVEI	T3,.DTCTO(T3)	;MAKE DTE COMMAND WORD
	MOVEM	T3,EPT+SPCCMW
	SETZM	EPT+SPCMTD
	CONO	DTE,TO11DB	;RING DOORBELL
	ANDI	T3,377
CTYCH1:	SKIPN	EPT+SPCMTD
	SOSGE	SPCTRY		;MUST LEAVE SPCMTD SET SO WE DON'T LOSE
	POPJ	P,		;MTD NOW SET OR COUNT RAN OUT.
	JRST	CTYCH1		; AN INTERRUPT IF RUNNING CTYSIM.

;ENTER SECONDARY PROTOCOL
SPCINI:	0
	MOVEM	T1,SPCST1	;SAVE T1
	MOVE	T1,[EPT+SPCDBG,,EPT+SPCDBG+1]
	SETZM	EPT+SPCDBG
	BLT	T1,EPT+SPCDND	;INIT COMM AREA TO ZEROES
	RDPI	SPCCMD	;SAVE PI STATE
	WRPI	LI.PIF
	MOVE	T1,[JSR DTEHLT]
	MOVEM	T1,EPT+EPTDT0+DTEDII
	MOVEM	T1,SPHNGI
	MOVE	T1,[EPT+EPTDT0+DTEEPW,,EPT+EPTDT0+DTEEPW+1]
	SETZM	EPT+EPTDT0+DTEEPW
	BLT	T1,EPT+EPTDT0+DTEDRW
	CONO	DTE,CL11PT	;CLEAR INTERRUPT JUST IN CASE
	MOVE	T1,SPCCMD	;RESTORE PI
	TRNE	T1,LI.PIN
	WRPI	LI.PIN
	MOVEI	T1,.DTESP
	JSR	SPCCMD
	MOVE	T1,SPCST1
	JRST	@SPCINI
;READ SWITCHES.

SPCGSW::MOVEI	T1,.DTRSW
	JSR	SPCCMD
	MOVE	T1,EPT+SPCF11
	POPJ	P,

;SEND SECONDARY PROTOCOL COMMAND
SPCCMD:	0			;JSR HERE
	SETZM	EPT+SPCFLG	;CLEAR FLAG FIRST.
	MOVEM	T1,EPT+SPCCMW	;STUFF COMMAND
	MOVEI	T1,SPCTRN	;GET # OF TIMES TO TRY
	MOVEM	T1,SPCTRY
SPCCM1:	CONO	DTE,TO11DB	;RING DOORBELL
	MOVEI	T1,40000
	SKIPN	EPT+SPCFLG
	SOJG	T1,.-1
	JUMPG	T1,@SPCCMD	;WORKED, RETURN.
	SOSL	SPCTRY
	JRST	SPCCM1
	XCT	SPHNGI

DTEHLT:	0
	STOPCD
>;END IFCPU (KL)

IFCPU (KS),<
CTYTYO:	ANDI	T3,CTYOCH	;GET JUST CHARACTER
	MOVEM	T3,ST380	;SAVE T3
	MOVEI	T3,CTYOVL(T3)	;ADD VALID FLAG
	MOVEM	T3,CTYOWD##	;STORE
	RDAPR	T3		;GET PROGRAM STATES
	ANDI	T3,LP.PIA	;LEAVE ONLY THE PIA
	WRAPR	LP.SSF+LP.I8C(T3)	;WHAP THE 8080
	SKIPE	CTYOWD##	;LOOP TILL TAKEN
	JRST	.-1
	MOVE	T3,ST380	;RESTORE T3
	POPJ	P,		;RETURN

ST380:	0			;SAVE T3
>;END IFCPU (KS)
TTYHLT::		;Global entry point to put TTY in cmd mode
CNCMOD:	MOVSI T1,LDLIMI!LDLECS
CNCMD1:	ANDCAM T1,LDBDCH(U)	;FORCE USER TO COMMAND LEVEL, RESET
	PUSHJ	P,BPTEST	;WANT TO TURN OFF BACKPRESSURE?
	  PUSHJ P,BPOFF		;YES, MAKE SURE BACKPRESSURE OFF
	MOVSI T1,LDLCOM
	IORM T1,LDBDCH(U)
	PJRST SETLMD

CKSXON:	PUSHJ	P,BPTEST	;WANT TO TURN BACKPRESSURE OFF?
	  PUSHJ P,BPXOFF	;YES
	JRST NOCTRO
;SETUUO TO SET INITIA ON LINS MARKED

INISET:	MOVSI T1,1
	TDNN T1,STATES
	POPJ P,		;NOT IF ALREADY OUT OF THIS STATE
	MOVEI T1,[ ASCIZ /SETUUO forcing INITIA on TTY1,TTY2,TTY3 & TTY4
/ ]
	MOVEI U,SCNLDB		;ON CONSOLE
	PUSHJ P,CONMES##	;TELL OPERATOR WHAT IS HAPPENING
	 JFCL			;ERROR RETURN IF THERE IS ONE
	MOVSI	P3,-PORTN	;CHECK ALL LINES
	MOVE T2,[LLLNLN,,LDLCOM]	;FOR LDBLOG AND LDBDCH
INISLP:	MOVE U,LINTAB(P3)
	SKIPN LDBLOG(U)		;NOT IF LOGGED IN
	TLNN U,TTVIN2		;OR NOT MARKED
	JRST INISL2
	HLLZM T2,LDBLOG(U)	;MARK IN
	HRLZM T2,LDBDCH(U)	;AND COMMAND MODE
	SETZM LDBDCX(U)		;NO EXTENDED BITS ON
	PUSHJ P,SETLMD
	PUSHJ	P,FRMASN##	;Assign a frame slot
	  POPJ	P,	;None there? Quit loop now, why bother?
	PUSHJ	P,TTYATI	;Attach TTY DDB to this LDB
	  PJRST	FRMKJF##	;No DDB's - free up frame slot,kill TTY
	MOVEI T1,CMFCXI##
	PUSHJ P,TTFORC		;MARK FORCED COMMAND
INISL2:	AOBJN P3,INISLP
	JRST CPOPJ1
;SOME ROUTINES TO FIND TELETYPES FOR VARIOUS PURPOSES

;SUBROUTINE TO FIND TTY FOR A JOB IN J (TTYFND) OR FOR
; CURRENT JOB (TTYFNU)
;RETURN WITH F AND U SET UP.
;GOES TO ERROR IF NO TTY F FOR THE JOB.

TTYFNU:	MOVE J,JOB			;GET CURRENT M LEVEL JOB NUMBER
TTYFND:	PUSHJ P,TTYSRC			;FIND THE JOB'S TTY F, ALSO U AND S
	  STOPCD		;JOB ZERO, OR OTHERWISE NO DDB. COMPLAIN.
	POPJ P,0			;SUCCESS. RETURN.

;ROUTINE TO FIND A TTY F WHICH IS ATTACHED TO, I.E.
;CONTROLLING, A PARTICULAR JOB NUMBER.

;CALLED AT COMMAND LEVEL BY ATTACH COMMAND, AND AT M LEVEL
;BY REFERENCES TO DEVICE "TTY" OR TTCALLS, ETC.

;CALL:	MOVE J,JOB NUMBER DESIRED
;	PUSHJ P,TTYSRC
;	  ERROR RETURN.	;NOT FOUND. AC'S U,F,S NOT GUARANTEED
;	NORMAL RETURN	;U, S AND F SET UP. NOTE THAT THIS DOES
;			;!NOT! IMPLY THAT ANYONE IS ATTACHED. THAT IS,
;			; U MAY CONTAIN A ZERO


TTYSRC::JUMPE J,CPOPJ		;NOBODY CONTROLS JOB ZERO. YOU ARE CONFUSED.
	HRRZ F,TTYTAB(J)	;REALLY MUST BE HERE
	JUMPE F,CPOPJ
	HRRZ U,DDBLDB(F)
	MOVE S,DEVIOS(F)	;SET UP I/O STATUS AND LINE
	JRST CPOPJ1
;SUBROUTINE TTYERP TO FIND TTY F FOR A MONITOR ERROR MSG
;CALL WITH J SET TO JOB NUMBER. IF JOB IS ZERO OR JOB
;IS DETACHED USER OPRLDB. IF NOT EVEN THAT IS THERE,
;GIVE RETURN. NORMAL RETURN IS SKIP

TTYERP:	PUSHJ P,TTYSRC		;FIND F
	 JRST GETOPR		;NO, USE OPER
	JUMPN U,CPOPJ1	;RETURN IF ATTACHED
;GETOPR DESTROYS U,F, T1-T4. ALL OTHER ACS ARE SAVED.
GETOPR:	HRRZ U,OPRLDB	;IS OPER THERE
	JUMPN U,GETOP1	;YES, GET F SET UP
;GETCTY USED BY CHKPNT WATCHDOG TO FORCE MSG TO CTY
;GETOPR DESTROYS U,F, T1-T4. ALL OTHER ACS ARE SAVED.
	INTERNAL GETCTY
GETCTY:	MOVEI U,SCNLDB	;TRY FOR THE FAKE ONE
	PUSH P,T1
	PUSH P,T2
	MOVE T1,LDBTOC(U)	;CHECK CURRENT COUNT
	CAILE T1,^D140
	PUSHJ P,TSETBO		;TOO BIG, CLEAR
	POP P,T2
	POP P,T1
GETOP1:	HRRZ F,LDBDDB(U)
	POPJ P,
;FIND A USER AND WAIT FOR ATTACH OR OUTPUT WAIT TO FINISH

TTYFUW:	PUSHJ P,TTYFNU
TTYFW1:	PUSHJ P,CKATTF		;WAIT FOR ATTACH
	MOVE T1,LDBTOC(U)	;HAVE TO PUT IT IN HERE SO
	CAIG T1,10		;DOES OT CALL SCNINT
	POPJ P,
TOWATA:	MOVE S,[XWD TTYOUW+IO+TIOUSE,IOACT]
	IORB S,DEVIOS(F)
	PUSH P,P1
	PUSH P,P2
	PUSHJ P,WSYNC
	POP P,P2
	POP P,P1
	MOVSI S,TIOUSE
	ANDCAB S,DEVIOS(F)
	POPJ P,

TTYSOW:	MOVE S,[XWD TTYOUW+IO,IOACT]
	IORB S,DEVIOS(F)
	POPJ P,

;AAA JAN 77 ROUTINE TO GET OPER TTY & SKIP RETURN WITH U,F.
; & RETURN NON-SKIP WITH CTY LDB DDB IN U,F IF NO OPR TTY EXISTS

GTOPER::PUSHJ P,GETOPR
	CAIE U,SCNLDB
	JRST CPOPJ1	;SKIP, GOT OPR
	POPJ P,
;(GTOPER USED BY CHKPNT WATCHDOG TO SEND MSGS TO BOTH CTY & OPR)
;SUBROUTINE TO FIND LDB FOR A PHYSICAL NAME, IF ITS A TTY
;AND LOAD F WITH LINKED DATA BLOCK, IF ANY, BUT DONT MAKE ONE IF NONE YET
;SKIP RETURN IF ITS A TTY

TTYPHY:	CAMN T1,[SIXBIT /OPR/]		;TALK TO OPERATOR?
	MOVE T1,DEVOPR			;YES. GET REAL DEVICE NAME
	HLLZ U,T1			;GET FIRST THREE CHARACTERS
	CAMN U,[SIXBIT /TTY/]	;ARE THEY TTY?
	TRNN T1,770000			;AND ALSO IS FOURTH CHAR NON-BLANK?
	POPJ P,0			;NO. NOT A LEGAL NAME.
	PUSH P,T1			;YES. MAY BE LEGAL.
	HRLZS 0(P)			;PUT THE RIGHT THREE CHARS ON STACK
	PUSH P,[POINT 6,-1(P)]		;POINTER TO READ CHARS
	MOVEI U,0			;INITIALIZE U TO 0
TTYPH4:	ILDB T1,0(P)			;GET A SIXBIT CHARACTER FROM NAME
	JUMPE T1,TTYPH2		;JUMP IF END OF NAME.
	TRC T1,"0"-40			;CONVERT SIXBIT TO BINARY
	CAILE T1,7			;IS IT AN OCTAL DIGIT?
	JRST TTYPH3			;NO. BAD CHAR IN NAME
	ASH U,3			;MULTIPLY BY 8
	ADDI U,0(T1)		;ADD IN THIS DIGIT
	JRST TTYPH4			;LOOP FOR MORE DIGITS

TTYPH3:	POP P,T1			;HERE ON BAD CHAR. CLEAR OUT STACK
	JRST TPOPJ			;AND RETURN TO ERR RET

TTYPH2:	POP P,T1			;HAVE AN OCTAL NUMBER. DISCARD
	POP P,T1			; TWO ITEMS FROM STACK
	CAIL U,PORTN		;IS IT A LEGAL HARDWARE U #
	POPJ P,0			;NO. TOO BAD.
	HRRZ U,LINTAB(U)		;GET U DATA BLOCK ADDRESS
	HRRZ F,LDBDDB(U)		;GET ATTACHED F, IF ANY.
	JRST CPOPJ1			;GOOD RETURN

;ROUTINE TO GET A DDB. CALLED IN DEVSRCH ROUTINES

GETDDB:	PUSHJ P,TTYPHY		;FIND THE TELETYPE BY NUMBER
	 POPJ P,		;NOT A REAL TTY
	JUMPE F,CPOPJ		;NOT REALLY THERE YET
	MOVE T1,DEVNAM(F)	;IF SOMEONE ELSES WILL BE
	JRST CPOPJ1		;ASSIGNED BY CONSOLE SO CAN'T1 HAVE IT ANYWAY
;SUBROUTINE TO PUT PHYSICAL NAME INTO T2 FOR U WHOSE LDB IS IN U
;EVEN THOUGH THERE MAY BE NOTHING IN F OR LDBDDB

TTYNAM:	LDB T1,LDPLNO			;GET U NUMBER
	PUSH P,[SIXBIT /TTY/]		;PUT NAME ON STACK
	MOVEI T3,0(P)			;PREPARE ARG FOR SCNNMR
	HRLI T3,220600			;POINT 6,0,17
	PUSHJ P,SCNNMR			;AND CALL SAME ROUTINE AS SCNNAM DOES
	POP P,T2			;PUT ANSWER IN T2
	POPJ P,0			;AND RETURN FROM TTYNAM

;SUBSIDIARY ROUTINE TO DO RADIX PRINT TO CORE.

SCNNMR:	IDIVI T1,10			;DEVICE NAMES ARE OCTAL
	HRLM T1+1,0(P)			;STORE A DIGIT ON STACK
	SKIPE T1			;NEED MORE DIGITS?
	PUSHJ P,SCNNMR			;YES. GO MAKE THEM.
	HLRZ T1,0(P)			;RETRIEVE A DIGIT FROM STACK
	ADDI T1,"0"-40			;CONVERT TO SIXBIT
	IDPB T1,T3			;STORE IN OBJECT WORD (DEVNAM)
	POPJ P,0			;POP UP TO SCNNMR OR BACK TO SCNNAM

;OUTPUT OPR MSGS TO THE CTY. 
;(AAA JAN 77. IF CTYBLF=-1 THEN SEND BELL CHAR THIS TICK
;  INSTEAD OF THE NEXT CHAR IN MSG. RESET THE FLAG.)
	INTERNAL CTYBLF
CTYBLF:	EXP 0	;USED BY MINUTE,SECOND (CLOCK1) & OPRCTY CODE


OPRCTY:
IFCPU (<KI,F3>),<CONSZ TTY,TT.OB	;IS OUTPUT BUSY?
	POPJ P,>		;YES, IGNORE FOR NOW
	MOVEI T3,ALRCTY		;SET ALARM
IFNCPU(KS),<IORM T3,ALR620>;11 NODES DON'T CARE TO KNOW ABOUT ALRCTY
	SKIPL CTYBLF	;AAA. IF -1 RING BELL THIS TIME
	JRST OPRCT2
	HRRZS CTYBLF	;RESET TO 0,,-1
	MOVEI	T3,7
	PJRST	CTYTYO	;RING BELL.
OPRCT2:	SKIPLE CTYFLN	;ARE THERE FILLS NEEDED
	JRST OPRFIL	;YES
	MOVE T2,SCNLDB+LDBTOT
	PUSHJ P,TTGETC
	 PUSHJ P,FRECHK	;GET CHR
	MOVEM T2,SCNLDB+LDBTOT
	PUSHJ P,PEVEN8	;GENERATE PARITY JUST IN CASE
IFCPU (<KI,F3>),<DATAO TTY,T3>	;SEND IT
IFCPU (<KS,KL>),<PUSHJ P,CTYTYO> ;SEND IT.
	ANDI T3,177
	CAIE T3,14
	CAIN T3,13	;HANDLE FF AND VTB
	JRST CTYFRM
	CAIN T3,15
	SKIPN T3,CTYFIL	;CR AND NEED FILLS?
	JRST CTYNFL	;NO
CTYSFL:	MOVEM T3,CTYFLN	;YES, SET COUNT (DO NOT DEC CHR CNT
	POPJ P,

CTYFRM:	MOVEI T3,^D40
	JRST CTYSFL	;SET LARGE NUMBER OF FILLS

CTYNFL:	SOSLE SCNLDB+LDBTOC
	POPJ P,		;NOT ALL OUTPUT YET
	PUSHJ P,OPRFRE	;RESTART SETUUO WAITERS
	MOVEI U,SCNLDB
	PUSHJ P,TSETBO
	POPJ P,		;DONE

OPRFIL:	IFCPU (<KI,F3>),<DATAO TTY,[377]>	;<KI,F3>10 DOESN'T NEED 'EM.
	SOSLE CTYFLN
	POPJ P,
	JRST CTYNFL	;DEC CHR COUNT
;SETUUO OUTPUT MESSAGE TO OPR TTY & CTY *BOTH*, IF POSSIBLE.
;OTHERWISE JUST TO CTY.

OPRSND:	HRRZ M,T1
	HRLI M,(POINT 7,0)
OPRSN2:	SKIPN U,OPRLDB	;GET OPR
	MOVEI U,SCNLDB	;NONE, GO TO CTY ONLY
	MOVE T1,LDBTOC(U)
	IOR T1,SCNLDB+LDBTOC	;WAIT IF EITHER OPR TTY OR CTY
	JUMPN T1,OPRWAT		;IS BUSY (OUTPUT BUFF NOT-EMPTY)
				;UNWAIT WHEN ONE OR THE OTHER
				;BECOMES EMPTY
OPSND1:	XCTFU <ILDB T3,M>
	JUMPE T3,CPOPJ1		;DONE
	PUSHJ P,CCTYO	;SAME OUTPUT RESTRICTIONS AS COMMAND
	SKIPN OPRLDB	;SKIP IF GOING TO BOTH
	JRST OPSND1	;JUST TO CTY, ALREADY DONE
	MOVEI U,SCNLDB
	XCTFU <LDB T3,M>	;GET SAME CHAR JUST SENT,
	PUSHJ P,CCTYO	;& PUT IT ON CTY
	MOVE U,OPRLDB	;RESTORE U
	JRST OPSND1

OPRWAT:	MOVEI T1,MLOWQ
	DPB T1,PJBSTS	;SET TO MON WAIT QUE
	HRRZ T1,OPRWJB	;GET WAITING JOB IF ANY
	MOVEM T1,QUEPCB(J)	;PUT ON QUE
	HRRZM J,OPRWJB	;AND SET CURRENT
	PUSHJ P,WSCHED
	JRST OPRSN2	;RESTARTED. ONE OF THEM JUST BECAME
		;FREE. GO CHECK AGAIN MAKE SURE BOTH FREE.

OPRFRE:	SKIPN T2,OPRWJB
	POPJ P,		;NONE WAITING
	SETZM OPRWJB	;RESTART ALL WAITERS
	PUSH P,J
OPRFR1:	MOVE J,T2
	MOVEI T1,RNQ
	DPB T1,PJBSTS
	PUSHJ P,SETRUN
	HRRZ T2,QUEPCB(J)
	SETZM QUEPCB(J)		;ZERO OLD ENTRY
	JUMPN T2,OPRFR1	;ANY MORE?
	POP P,J
	POPJ P,		;DONE
;SUBROUTINE FOR THE TTY COMMAND

;ON ENTRY P1 HAS LDB TO DO THINGS FOR, T2 HAS COMMAND

SCNTCD:	MOVSI T1,-TTCWDN	;GET LENGTH OF COMMAND TABLE
	CAME T2,TTCWDT(T1)
	AOBJN T1,.-1
	JUMPG T1,CPOPJ1	;NOW FOUND, TAKE ERROR RETURN
	HRRZ T2,TTCWDD(T1)	;GET DISPATCH
	JRST (T2)		;AND GO

TTCWDT:	SIXBIT /NO/
	SIXBIT /TAB/
	SIXBIT /FORM/
	SIXBIT /LC/
	SIXBIT /FILL/
	SIXBIT /ECHO/
	SIXBIT /CRLF/
	SIXBIT /WIDTH/
	SIXBIT /XON/
	SIXBIT /TAPE/
	SIXBIT /FILL1/
	SIXBIT /FILL2/
	SIXBIT /IN/
	SIXBIT /OUT/
	SIXBIT /A/
	SIXBIT /B/
	SIXBIT /C/
	SIXBIT /TYPE/
	<SIXBIT /BACKSPACE/>
	SIXBIT /ERASE/
	SIXBIT /RXE/
	SIXBIT /DEF/
	SIXBIT /UCO/
	SIXBIT /BSD/
	SIXBIT /RBS/
	SIXBIT /CLASS/		; [dws]
	SIXBIT /RTCOMP/		;[Darren]
TTCWDN==.-TTCWDT

TTCWDD:	XWD 0,TTCNO		;LH MAY HAVE A BIT TO SET/RESET
	XWD TCNTAB,TTCSET
	XWD TCNFRM,TTCSET
	XWD TCNLCT,TTCCLR
	XWD 0,TTCFIL
	XWD TCNHDX,TTCCLR
	XWD TCNNFC,TTCCLR
	XWD TCNWID,TTCVAL
	XWD TCNPTP,TTCSET
	XWD TCNPTP,TTCSET
	XWD TCNFC1,TTCVAL
	XWD TCNFC2,TTCVAL
	XWD TCNIR,TTCVAL
	XWD TCNOR,TTCVAL
	XWD TCNPA,TTCVAL
	XWD TCNPB,TTCVAL
	XWD TCNPC,TTCVAL
	XWD TCNTYP,TTCVAL
	XWD TCNBSP,TTCSET
	XWD TCNERA,TTCSET
	XWD TCNRXE,TTCSET
	XWD TCNDEF,TTCSET
	XWD TCNLCO,TTCCLR
	XWD TCNBSD,TTCSET
	XWD TCNECH,TTCSET
	XWD TCNTTP,TTCSIX	; [dws]
	XWD TCNRTC,TTCSET	;[Darren]
;"NO"

TTCNO:	TLC	P1, -1		;COMPLEMENT YES-NO FLAG
	POPJ	P,

;BIT-VALUED CHARACTERISTICS

TTCCLR:	TLC	P1, -1		;OPPOSITE OF SET
TTCSET:	HLRZ	T1, TTCWDD(T1)	;T1/ TC# FOR SETTCN
	JUMPL	P1, TTCDO1	;RESETTING THE BIT
	MOVEI	T2, 1
	PUSHJ	P, TTCGO
	  AOS	(P)
	POPJ	P,
TTCDO1:	SETZ	T2,
	PUSHJ	P, TTCGO
	  AOS (P)
TTCFIN:	HRRZS	P1		;CLEAR NO FLAG
	POPJ	P,

;DECIMAL-VALUED CHARACTERISTICS

TTCVAL:	PUSH	P, T1
	JUMPL	P1, TTCVL0	;"NO" => 0
	PUSHJ	P, DECIN1	;T2 := DECIMAL NUMBER
	  JRST	TPOPJ1	
	  JRST	TPOPJ1		;NO NUMBER OR BAD NUMBER
	JRST	TTCVL1
TTCVL0:	SETZ	T2,
TTCVL1:	POP	P, T1		;T1/ VALUE FROM DISPATCH
	HLRZ	T1, TTCWDD(T1)	;T1/ TC# FOR SETTCN
	PUSHJ	P, TTCGO
	  AOS	(P)
	POPJ	P,

;[dws] Sixbit-valued characteristics

TTCSIX:	PUSH	P,T1		; save T1
	SKIPGE	P1		; skip if "No" not seen
	 TDCA	T2,T2		;  "No" --> blanks
	PUSHJ	P,CTEXT1##	; T2 := sixbit text
	POP	P,T1		; T1/ value from dispatch
	HLRZ	T1,TTCWDD(T1)	; T1/ TC# for SETTCN
	PUSHJ	P,TTCGO		; try to set the characteristic
	 AOS	(P)		;  failed, transfer the skip
	POPJ	P,		; return

TTCGO:	PUSH	P, U
	HRR	U, P1		;U/ LDB ADDR
	HLL	U, LDBDCH(U)
	PUSHJ	P, SETTC1	;GO SET THE TC
	  JRST	.+2
	AOS	-1(P)		;TRANSFER THE SKIP-RETURN
	POP	P, U
	POPJ	P,
;FOR OLD TIME'S SAKE (SET FC1 AND FC2 FROM THE SAME VALUE)

TTCFIL:	JUMPL	P1, TTCFL0
	PUSHJ	P, DECIN1
	  JRST	CPOPJ1
	  JRST	CPOPJ1
	JRST	TTCFL1
TTCFL0:	SETZ	T2,
TTCFL1:	MOVEI	T1, TCNFC1
	PUSHJ	P, TTCGO
	  JRST	CPOPJ1
	MOVEI	T1, TCNFC2
	PUSHJ	P, TTCGO
	  AOS	(P)
	POPJ	P,
;CALLED FROM COMCON TO SET TO SEND SHUT OR ANSWERED MESSAGE

SETSHT:	MOVSI T1,TYPI TYPSHT	;SET TO SAY SHUT
	MOVEI T2,400000
	TDNN T2,STATES	;IS THAT THE STATE
	MOVSI T1,TYPI TYPANS	;YES, SO SAY ANSWERED
	MOVEM T1,UPSHUT
	TDNN T2,STATES	;UP OR DOWN?
	JRST CKOPR	;UP, SEE IF DEVOPR SET
	SETZM OPRTIM	;DOWN, TURN OFF TIMER
	MOVEI T2,ALROPR
	ANDCAM T2,ALR620	;AND ALARM
	POPJ P,

CKOPR:	SKIPE DEVOPR
	POPJ P,		;DEVOPR SET, ALL OK
	MOVEI T2,^D90	;SET FOR 90 SEC TILL ALARM
	MOVEM T2,OPRTIM
	POPJ P,

;CALLED TO SEE IF WAITING FOR LOGOUT SO CAN NOT SET JACCT2

CKLGO:	HRRZ F,TTYTAB(J)
	JUMPE F,CPOPJ1		;NO DDB, SAY OK TO SET
	HRRZ U,DDBLDB(F)
	JUMPE U,CPOPJ1		;NO LINE, CAN NOT BE WAITING
	MOVSI T4,LLLZAP
	TDNN T4,LDBLOG(U)	;SEE IF ZAPPER RECEIVED FLAG SET
	AOS (P)		;NO, OK
	POPJ P,
;SEND A SAD MESSGE

SNDSAD:	MOVE T1,ALR620
	CAMN T1,ALRSNT
	JRST CPOPJ1	;NOT SENT
	PUSH P,T1	;SAVE T1 FROM BEING CLOBBERED.
	PUSHJ P,CLSCHR		;FINISH UP CHARACTER OUTPUT.
	 JRST TPOPJ	;NO MORE ROOM.
	MOVE T2,ORPPDP	;PICK UP THE OUTPUT RING POINTER.
	ADDI T2,2	;THIS OPERATION REQUIRES 2 WORDS.
	ANDI T2,MSKORG	;MASK FOR WRAP AROUND.
	CAMN T2,ORP620	;MAKE SURE THERE'S ROOM.
	JRST TPOPJ		;NO MORE ROOM.  FINISH SCANNING LINE.
	POP P,T1	;RESTORE T1
	MOVEM T1,ALRSNT	;SAY WE SENT THAT ONE
	MOVSI P3,TYPI TYPSAD
	LDB T1,[POINT 16,ALR620,15]
	DPB T1,[POINT 16,P3,BYP4]
	MOVEM P3,ORING(P4)
	ADDI P4,1
	ANDI P4,MSKORG	;POINT TO CORRECT LOCATION (POSSIBLE WRAP)
	LDB T1,[POINT 16,ALR620,31]
	DPB T1,[POINT 16,P3,BYP2]
	PUSHJ P,WRDOT2	;WRITE 2ND WORD AND CLEAN UP
	 POPJ P,	;NO MORE ROOM.  CALL FINOUT.
	JRST CPOPJ1	;CONTINUE SCAN.
SUBTTL ATTACH/DETACH

;TTYKIL -- ACTUALLY TWO ROUTINES
;
;1)	CALLED WITH F/ 0, U/ LDB ADDR TO ZAP U WHENEVER A
;	COMMAND HAS JUST BEEN FORCED ON A NON-JOB (E.G., 
;	WHEN JOB CAPACITY IS EXCEEDED), AND, BY SOME QUIRK
;	OF FATE, AFTER EVERY DETACH COMMAND (BECAUSE COMCON
;	RELOADS F FROM LDBDDB(U) AND INCORRECTLY THINKS
;	F/ 0 => NO JOB)
;
;2)	CALLED WITH F/ DDB ADDR, U/ ANYTHING TO ZAP THE
;	ATTACHED PORT, IF ANY, AND FREE THE COMMAND PORT DDB
;	OF A JOB BEING KILLED.

TTYKIL:	JUMPE	F,TTYZAP	;IF THERE'S NO JOB (CASE 1): ZAP IT

;(CASE 2) FREE THE DDB, THEN ZAP THE CIRCUIT

	SETZM	DEVNAM(F)
	SETZM	DEVLOG(F)
	LDB	T1,PJOBN
	SKIPE	T1
	SETZM	TTYTAB(T1)	;MAKE SURE MARKED AS NO DDB
	MOVSI	T1,IOFST
	MOVEM	T1,DEVIOS(F)
	DPB	T1,PJOBN	;THIS WILL SET TO JOB 0
	HRRZ	U,DDBLDB(F)	;CHECK FOR A LINE ATTACHED
	JUMPE	U,TTYKDB	;DETACHED ALREADY?

    ; U/ 0,,LDB ADDR
    ;HERE WHEN WE'RE TTYKILLING AN ATTACHED DDB

	HLLZS	LDBDDB(U)	;DISCONNECT U FROM F
	PUSHJ	P,TTYZAP	;ELSE ZAP THE CIRCUIT
	;PJRST	TTYKDB
;TTYKDB -- CLEAR LDB PTR AND ASSIGNMENT & USE BITS FOR A TTY DDB
;	   (ADDR IN F), AND RETURN IT TO THE FREE POOL

TTYKDB:	JUMPE F,CPOPJ
	HLLZS DDBLDB(F)	;NO F FROM U
	MOVE T1,[XWD TTYATC,ASSCON!ASSPRG]
	ANDCAM T1,DEVMOD(F)	;CLEAR OUT ALL USE AND ASSIGN BITS
	HLRZ T2,DDBBLK(F)	;GET BACK LINK
	HLRZ T1,DEVSER(F)	;AND FORWARD LINK
	HRLM T1,DEVSER(T2)	;LINK AROUND DDB
	PUSH P,T3
	MOVE T3,DEVMOD(T1)	;IS NEW DEST. ALSO A TTY?
	TLNE T3,DVTTY!DVRMT
	HRLM T2,DDBBLK(T1)	;YES, SET ITS BACK POINTER
	POP P,T3
	MOVE T1,FRETTY
	HRLM T1,DEVSER(F)	;AND LINK INTO FREE POOL
	HRRZM F,FRETTY
	HRRZ F,T2	;POINT TO PRED FOR LINKING
	POPJ P,
;TDTUUO -- HERE FROM ATTACH UUO WHEN DETACHING THE COMMAND PORT
;	   (J/ JOB NUMBER)

TDTUUO:	PUSHJ P,TTYSRC	;FIND F
	 POPJ P,		;NONE THERE
	JUMPE U,CPOPJ		;MUST NOT BE WAITING FOR LOGOUT
	MOVSI T1,LLLZAP
	TDNE T1,LDBLOG(U)
	POPJ P,
	;PJRST TTYDET

;TTYDET -- DETACH A TTY DDB (ADDR IN F)

TTYDET:	HRRZ U,DDBLDB(F)	;GET LDB ADDR
	HLLZS DDBLDB(F)		;AND CLEAR LINK
	HRRZS DEVNAM(F)		;SAVE PORT # BUT CLEAR "TTY"
				;SO DEVICE SEARCH DOESN'T FIND IT
	MOVEI	T1, 1
	DPB	T1, DDPCOM	;SHOULD RE-ATTACH IN CMND MODE
	JUMPE U,CPOPJ		;NO LINE TO SEND ZAPPER ON
	HLLZS LDBDDB(U)		;CLEAR LDB TO DDB LINK
	PJRST TTYZAP		;  SEND A ZAPPER ON IT

;TYCIOS -- called by CLOCK1 to clear ALL tty's IOS

TYCIOS:	PUSHJ P,FRSTTY
	 POPJ P,	
	JRST TYIOS2		;include command port

TYIOS1:	PUSHJ P,NXTTTY	;THIS WILL BE AUX CIR OR RMT
	 POPJ P,	;FINISHED, NONE THERE
TYIOS2:	MOVSI T1,DVRMT
	TDNE T1,DEVMOD(F)
	JRST	[MOVE S,[IOW,,IOACT]	;RESET BITS FOR RMT
		ANDCAM S,DEVIOS(F)
		JRST TYIOS1]	;NEXT
	MOVE S,[IOW+TIOUSE,,IOACT]
	ANDCAM S,DEVIOS(F)	;RESET ALL BITS INCLUDING USE
	MOVE T1,[TTYATC,,ASSCON+ASSPRG]
	TDNN T1,DEVMOD(F)	;ANY REASON TO KEEP IT
	PUSHJ P,TTYKDB		;NO, GET RID OF IT
	JRST TYIOS1

;IFDET -- CALLED FROM EXIT UUO: IF DETACHED, SKIP, ELSE DO A
;	  TTYFUW AND NONSKIP-RETURN

IFDET:	PUSHJ P,TTYFND
	JUMPE U,CPOPJ1	;IS DETACHED
	JRST TTYFW1	;FINISH THE TTYFUW
;TTYZAP -- ZAP A CIRCUIT (U/ LDB ADDR).

TTYZAP:	MOVEI	T2, 1
	MOVSI	T1, LLLNLN
	TDNN	T1, LDBLOG(U)	;IF IT'S A HANGUP NOT AN INCOMING ZAP,
	DPB	T2, LOPSYL	;  SET SEND-YELLOW-BALL
	DPB	T2, LOPZAP	;SET SEND-ZAPPER
	DPB	T2, LDBOPB(U)	;SET NEED-OUTPUT
	MOVSI	T1, LDLNOP
	ANDCAM	T1, LDBDCH(U)	;IGNORE BACKPRESSURE
	MOVSI	T1, LMLBIO
	TDNE	T1, LDBMOD(U)	;IF IT'S IN BLOCK I/O MODE,
	PUSHJ	P, BIOREL	;  GET IT OUT
	POPJ	P,
;TTYATT -- ATTACH LDB TO JOB
;	   U/ LDB  J/ JOB#
;	   SKIP-RETURNS ON SUCCESS WITH F/ CMND PORT DDB
;	   NONSKIP-RETURNS ON FAILURE WITH F/ 0

TTYATT:	PUSH P,U
	MOVEI F,0	;RET 0 IN CASE DONT FIND TTY DDB
	PUSHJ P,TTYSRC	;FIND THE F FOR THAT JOB
	 JRST LPOPJ	;NONE, SHOULD NOT HAVE GOTTEN HERE
	JUMPE U,TTYAT1	;WAS THERE ANYONE ATTACHED
LPOPJ:	POP P,U	;YES, NOONE CAN DO THIS FOR NOW
	POPJ P,

COMMENT ! TTYATI--CALLED TO DO INITIAL ATTACH WHEN
	PROCESSING LOGIN.
EXPECTS:  U/ LDB ON WHICH LOGIN APPEARED
	  J/ JOB SLOT TO WHICH WE WANT TO ATTACH IT
CLOBBERS: T1 - T4
RETURNS: CPOPJ IF CANNOT ATTACH. F/0 IF NO TTYDDB'S, F/DDB IF
		BECAUSE ALREADY ATTACHED
	 CPOPJ1 IF SUCCESS, F/DDB
!


TTYATI:	PUSH P,U
	PUSHJ P,TTYSRC	;CHECK FOR A F FOR THIS JOB
	 PUSHJ P,DDBSRC	;NONE, FIND A FREE ONE
	  JRST LPOPJ	;NO FREE F OR JOB ALREADY HAS ONE, GIVE ERROR RETURN
TTYAT1:	MOVE U,0(P)	;RESTORE U USER IS NOW ON
	PUSH P,F
	HRRZ F,LDBDDB(U)	;DOES IT HAVE A F?
	JUMPE F,TTYAT2	;NO, JUST DO THE ATTACH
	HLLZS DDBLDB(F)	;GET RID OF LINK TO U SO
	HRRZS DEVNAM(F)	;MAKE SURE LEFT OF NAME ZEROED
TTYAT2:	POP P,F		;NOW RESTORE F HE GOES TO
	POP P,U
	MOVE T1,[XWD TTYATC,ASSCON]	;ASSIGN IT
	IORM T1,DEVMOD(F)
	DPB J,PJOBN		;SET JOB ASSIGNED TO
	MOVE T1,TIMRST##	;RESET ANY WAITING HANG
	DPB J,CLKJOB##		;WHICH MAY EXIST IN CLOCK QUEUE
	PUSHJ P,CHGCLK		;FOR PREVIOUS OWNERS OF THIS JOB SLOT
	HRRZM F,TTYTAB(J)	;SET TTYTAB UP
	PUSHJ P,SCNNAM		;FILL IN NAME OF TTY F
	PUSHJ	P, COMATT	;JOIN F AND U
	JRST CPOPJ1		;AND TAKE GOOD RETURN
; HERE FROM THE ATTACH UUO IF IT'S ATTACHING
; T1/ USERMODE,,JOB# WHERE USERMODE IS 1 TO
; ATTACH THE PORT IN USER MODE AND 0 TO ATTACH
; IT IN COMMAND MODE

TATUUO:	PUSH P,T1
	PUSHJ P,TTYSRC	;FIND F FOR THIS JOB
	 JRST TPOPJ	;CAN NOT ATTACH, NO F
	HRRZ U,DDBLDB(F)
	JUMPE U,TPOPJ	;GIVE UP
	MOVSI T1,LLLZAP
	TDNE T1,LDBLOG(U)
	JRST TPOPJ	;DO NOT ALLOW IF WAITING FOR LOGUT
	HRRZ	J, 0(P)	; J/ 0,,TARGET JOB#
	PUSHJ P,TTYATT
	  JRST TPOPJ		;CANNOT ATTACH
	POP	P,T1		;T1/USERMODE,,TARGET JOB#
	AOS (P)
	PUSH	P,T1
	TLNE	T1,(1B15)	;does user want frame continued?
	 PUSHJ	P,RTCONT	;yes - do it
	POP	P,T1
	TLNE	T1,(1B17)	;WANTS USER MODE?
	 JRST	TATUU1		;YES.
	PUSHJ P,PRPER	;GIVE HIM A PERIOD OR -
	PUSHJ P,CNCMOD	;FORCE TO COMMAND LEVEL
	JRST TTYSTC	;AND GO

TATUU1:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	; PUT INTO USER MODE
	PUSHJ	P, SETLMD
	POPJ	P,	; SKIP-RETURN ((P) AOS'D ABOVE)
COMMENT @

RETACH UUO -- MOVE A TTY SOMEWHERE ELSE

	MOVE	AC, [
		SOURCE FRAME,,TARGET FRAME
		BITS,,PORT
	]
	RETACH	AC,
	  ERROR RETURN	;AC/ ERROR CODE
	NORMAL RETURN	;AC/ PORT# OF PORT MOVED (FROM RH(DEVNAM))

	<BITS> = 1B0 TO ATTACH AS AUX/SLAVE PORT RATHER THAN
		     AS CMND PORT (MUST BE SIGN BIT)
	       + 0B2 TO ATTACH ACCORDING TO SAVED CMND MODE STATE
		 1B2 TO ATTACH IN CURRENT COMMAND MODE STATE
		 2B2 TO FORCE COMMAND MODE
		 3B2 TO FORCE USER MODE
	       + 1B3 TO SIGNAL A HANGUP ON THE SOURCE FRAME

	<ERROR CODE> = (SEE DEFINITIONS BELOW)
@

RT.SLV==400000
RT.MOD==300000
  DEFINE RTYMOD(X) = <[POINT 2,X,2]>
  .RTMSV==0
  .RTMCU==1
  .RTMCO==2
  .RTMUS==3
RT.SIG==040000
RT.CON==020000

RTSAC%==1	;INSUFFICIENT ACCESS TO SOURCE FRAME
RTSNX%==2	;SOURCE FRAME DOES NOT EXIST
RTTAC%==3	;INSUFFICIENT ACCESS TO TARGET FRAME
RTTNX%==4	;TARGET FRAME DOESN'T EXIST
RTSNA%==5	;PORT NOT ATTACHED TO SOURCE FRAME
RTTAT%==6	;PORT ALREADY ATTACHED TO TARGET FRAME
RTSCP%==7	;FORCED COMMAND PENDING ON PORT
RTAUX%==10	;ATTACHING AUX CIRCUIT AS CMND PORT
RTNRM%==11	;NO ROOM FOR NEW DDB
EXTERN IPOPJ, IPOPJ1
EXTERN FARCHK

RETACH::XCTFU <MOVE P1,0(T1)>	;P1/ SOURCE,,TARGET
	XCTFU <MOVE P2,1(T1)>	;P2/ BITS,,PORT

    ;CHECK ACCESS TO SOURCE FRAME

	HLRZ	P4, P1		;P4/ SOURCE FRAME DESC
	HRRZI	P3, .ARDET
	PUSHJ	P, FARCHK	;MAY WE DETACH FROM THE SOURCE?
	JRST	[
		MOVEI	T1, RTSAC%
		JRST	RTERR
	]
	MOVSI	T1, JNA
	TDNN	T1, JBTSTS(J)	;IS THE SOURCE JOB THERE?
	JRST	[
		MOVEI	T1, RTSNX%
		JRST	RTERR
	]
	HRLM	J, P1

    ;CHECK ACCESS TO TARGET FRAME

	HRRZ	P4, P1		;P4/ TARGET FRAME DESC
	HRRZI	P3, .ARATT
	PUSHJ	P, FARCHK	;MAY WE ATTACH TO THE TARGET?
	JRST	[
		MOVEI	T1, RTTAC%
		JRST	RTERR
	]
	MOVSI	T1, JNA
	TDNN	T1, JBTSTS(J)	;IS THE TARGET JOB THERE?
	JRST	[
		MOVEI	T1, RTTNX%
		JRST	RTERR
	]
	HRRM	J, P1
    ;SAVE THE CALLER'S JOB #

	PUSH	P, J

    ;GET THE PORT BEING MOVED

	HLRZ	J, P1		;J/ SOURCE FRAME #
	HRRE	F, P2		;F/ SOURCE PORT DESCRIPTOR
	PUSHJ	P, FNDPRT	;SET F/ DDB ADDR. IF NO DDB
	JRST	RETCH1
	HRRZ	U, DDBLDB(F)
	JUMPN	U, RETCH2	;OR IF IT IS DETACHED
RETCH1:	MOVEI	T1, RTSNA%
	JRST	RTERJ		;  RESTORE J AND ERROR-RETURN

    ;J/ SOURCE FRAME#  F/ SOURCE DDB  U/ LDB

RETCH2:	SKIPGE	LDBDDB(U)	;IF LINE HAS PENDING COMMANDS,
	JRST	[
		MOVEI	T1, RTSCP%
		JRST	RTERJ	;  RESTORE J AND ERROR-RETURN
	]
	LDB	T1, LDPCOM
	DPB	T1, DDPCOM	;SAVE CMND MODE STATE
	PUSHJ	P, NAMSCN	;T1 := PORT # FROM RH(DEVNAM)
	UMOVEM	T1, (M)		;GIVE IT TO CALLER
	HRRZ	J, P1		;J/ TARGET FRAME #
	HRRM	F, P2		;P2/ BITS,,SOURCE DDB
	JUMPL	P2, RTATS	;<0 TO ATTACH AS AUX/SLAVE PORT
    ;HERE TO ATTACH AS TARGET'S COMMAND PORT
    ;J/ TARGET JOB #  U/ LDB ADDR

RTATC:	HRRZ	J, P1		;J/ TARGET FRAME #
	HRRZ	F, TTYTAB(J)	;F/ 0,,DDB ADDR
	SKIPN	F		;IF THERE'S NO DDB,
	  STOPCD		;  CRASH
	HLL	U, LDBDCH(U)
	TLNE	U, LDLAUX	;IF IT'S AN AUX CIRCUIT,
	JRST	[
		MOVEI T1, RTAUX%
		JRST RTERJ	;  RESTORE J AND ERROR-RETURN
	]
	HRRZ	T1, DDBLDB(F)
	JUMPN	T1, [		;IF JOB'S ATTACHED ALREADY,
		MOVEI	T1, RTTAT%
		JRST	RTERJ	;  RESTORE J AND ERROR-RETURN
	]

	MOVE	T1,TIMRST##
	DPB	J,CLKJOB##
	PUSHJ	P, CHGCLK	;RESET TIMEOUT-ON-DISCONNECT TIMER
	PUSHJ	P, SCNNAM	;DEVNAM(F) := "TTY" & CVOS(LINE#)
	PUSHJ	P, COMATT	;JOIN F AND U

	TLNE	P2,RT.CON	;User want us to force CONTINUE on target?
	 PUSHJ	P,RTCONT	;yes - go do it

	LDB	T1, RTYMOD<P2>	;T1/ LDLCOM "MODE"
	JRST	@[
		RTCSV		;0  .RTCSV  FORCE SAVED MODE
		RTFIN		;1  .RTCCU  RETAIN CURRENT MODE
		RTCCO		;2  .RTCCO  FORCE COMMAND MODE
		RTCUS		;3  .RTCUS  FORCE USER MODE
	](T1)

RTCSV:	MOVSI	T1, DCLCOM
	TDNN	T1, DDBDCH(F)	;CHECK SAVED LDLCOM SETTING
	JRST	RTCUS		;WAS 0 -- FORCE USER MODE
	JRST	RTCCO		;WAS 1 -- FORCE CMND MODE

RTCUS:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	;CLEAR COMMAND MODE
	PUSHJ	P, SETLMD	;FIX LINE MODE FIELD
	JRST	RTFIN

RTCCO:	MOVSI	T1, LDLCOM
	TDNE	T1, LDBDCH(U)	;IF NOT ALREADY AT CMND MODE,
	JRST	RTFIN
	PUSHJ	P, PRPER	;  PRINT A PROMPT
	PUSHJ	P, CNCMOD	;  FORCE TO CMND MODE
	JRST	RTFIN
    ;HERE TO ATTACH AS A SLAVE PORT TO TARGET
    ;J/ TARGET JOB #  U/ LDB ADDR

RTATS:	LDB	F, LDPLNO	;F/ PORT #
	PUSHJ	P, FNDPRT	;F/ DDB FOR PORT. IF THERE ISN'T ONE,
	JRST	RTATS1		;  GO ALLOCATE A DDB
	HRRZ	T1, P2		;T1/ SOURCE DDB
	CAIN	T1, (F)		;IF IT'S THE SAME AS THE TARGET,
	JRST	RTATS1		;  ALWAYS ALLOCATE A NEW ONE


; RTCONT - call here to make sure target frame is running.
; Called in response to user request by ATTACH UUO and RETACH UUO.
; Expects J/ target JOB #.
; Clobbers T1 alot.
RTCONT:	SKIPGE	T1,JBTSTS(J)	;check if its already running
	 POPJ	P,		;yep! nothing to do
	TLNE	T1,JERR		;can't continue if JERR set
	 POPJ	P,
	PJRST	SETRUN		;resume execution in target and return


    ;USING EXISTING DDB

	HRRZ	T1, DDBLDB(F)
	JUMPN	T1, [		;IF ALREADY ATTACHED,
		MOVEI	T1, RTTAT%
		JRST	RTERJ	;RESTORE J AND ERROR-RETURN
	]
	MOVEI	T1, (SIXBIT/TTY/)
	HRLM	T1, DEVNAM(F)
	JRST	RTATS2

    ;ALLOCATING NEW DDB

RTATS1:	HRRZ	T1, TTYTAB(J)	;T1/ TARGET CMND PORT DDB
	SKIPN	T1		;IF THERE IS NONE,
	  STOPCD		;  CRASH
	PUSHJ	P, DDBSR1	;F/ NEW DDB, LINKED AFTER CMND PORT.
	  JRST	[		;IF THERE'S NO ROOM FOR ONE,
		MOVEI T1, RTNRM%
		JRST RTERJ	;  RESTORE J AND ERROR-RETURN
	]
	DPB	J, PJOBN	;SET JOB #
	PUSHJ	P, SCNNAM	;AND PHYSICAL NAME
	MOVEI	T1, ASSCON
	IORM	T1, DEVMOD(F)	;MARK IT ASSIGNED-BY-CONSOLE

    ;ATTACH IT

RTATS2:	MOVSI	T1, LDLCOM
	ANDCAM	T1, LDBDCH(U)	;MAKE SURE IT'S NOT IN COMMAND MODE
	MOVSI	T1, TTYATC
	ANDCAM	T1, DEVMOD(F)	;MARK IT AS A NONCOMMAND PORT
	PUSHJ	P, COMATT	;JOIN F AND U
	;JRST	RTFIN
    ;DETACH THE SOURCE END

RTFIN:	HLRZ	J, P1		;J/ SOURCE FRAME #
	HRRZ	F, P2		;F/ SOURCE DDB
	HLLZS	DDBLDB(F)	;DETACH SOURCE
	HRRZS	DEVNAM(F)	;MAKE IT LOOK DETACHED
	MOVSI	T1, TTYATC
	TDNN	T1, DEVMOD(F)	;WAS SOURCE A COMMAND OR A SLAVE PORT?
	JRST	RTFIN1		;(AUX/SLAVE)

    ;HERE WHEN WE'VE DETACHED SOURCE'S COMMAND PORT

	TLNN	P2, RT.SIG	;IF WE'RE SIGNALLING A HANGUP,
	JRST	IPOPJ1
	PUSHJ	P, HNGTTY	;  FORCE A DETACHED-JOB HANGUP
				; J has job #
	JRST	IPOPJ1

    ;HERE WHEN WE'VE DETACHED AN AUX/SLAVE PORT

RTFIN1:	TLNN	P2, RT.SIG	;IF WE'RE SIGNALLING A HANGUP,
	JRST	RTFIN2
	LDB	T1, DDPTZP
	PUSHJ	P, TAKTRJ	;  CAUSE A ZAPPED INTERRUPT
RTFIN2:	MOVEI	T2, ASSCON
	PUSHJ	P, RELEA6	;TRY TO FREE THE DDB
	JRST	IPOPJ1
	
    ;ERROR-RETURNS

RTERJ:	POP	P, J		;RESTORE J
RTERR:	UMOVEM	T1, (M)		;STORE ERROR CODE
	POPJ	P,
;COMATT -- PERFORMS THE FUNCTIONS COMMON TO ALL ATTACH FUNCTIONS:
;	     LINKS LDBDDB(U) AND DDBLDB(F)
;	     SETS NEED-OUTPUT BIT OF LDB SO ATTACHEE WILL BE AWAKENED
;	     SETS NON-DEVIOS LDB DEVICE CHARACTERISTIC BITS
;	     CALLS UUOLDB TO SET DEVIOS DEVICE CHARACTERISTIC BITS
;	   F/ DDB ADDR  U/ LDB ADDR
;	   DESTROYS T1-T4

COMATT:	TRNE	F, -1
	TRNN	U, -1
	  STOPCD		;MUST HAVE A DDB AND AN LDB
	HRRM	U, DDBLDB(F)
	HRRM	F, LDBDDB(U)	;DO THE ATTACH
	MOVEI	T1, 1
	DPB	T1, LDBOPB(U)	;SET NEED-OUTPUT
	LDB	T1, DDPIMB
	DPB	T1, LDPIMB	;SET IMAGE-MODE BREAK CHARACTER
	MOVE	T3, DDBDCH(F)
	MOVE	T1, LDBBYT(U)
	TLNN	T3, DCLNTB	;NO HT/VT/FF ECHO
	TLZA	T1, L2LNTB
	TLO	T1, L2LNTB
	MOVEM	T1, LDBBYT(U)
	MOVEI	T1, L2LTBK	;TABS-AS-BREAKS
	TLNE	T3, DCLTBK
	HRLI	T1, L2LTBK
	PUSHJ	P, SETTBK
	MOVEI	T1, L2LBBP	;BACKSPACE-AS-NONBREAK
	TLNE	T3, DCLBBP
	HRLI	T1, L2LBBP
	PUSHJ	P, SETTBK
	MOVE	S, DEVIOS(F)
	PJRST	UUOLDB		;SET DEVIOS-DEPENDENT LDB BITS
;ROUTINE TO FIND A FREE TTY DEVICE DATA BLOCK

;CALL FROM CLOCK LEVEL TO DO AN ATTACH ON A NEW JOB, OR
;FROM M LEVEL ON AN INIT OF A NEW LINE.

;CALL:	NO ARGUMENTS
;	PUSHJ P,DDBSRC
;	  ERROR RETURN		;NONE AVAILABLE. F=0. T1 CLOBBERED
;	OK RETURN		;ADDRESS IN F, TTYUSE SET IN DEVMOD
;				;RESPECTS J,U,CH.
;				;IF YOU DECIDE NOT TO USE F, YOU BETTER
;				;FREE IT UP AGAIN.

DDBSRC:	MOVE T1,TTYFLK	;WHERE TO LINK IN
DDBSR1:	HRRZ F,FRETTY	;HERE IF TO LINK AT SPECIAL SPOT WITH T1 SET
	JUMPE F,CPOPJ		;NO DDB'S AVAILABLE
	HLRZ F,DEVSER(F)	;GET NEXT FREE
	EXCH F,FRETTY		;RESTORE F AND UPDATE FREE LIST
	PUSH P,DEVSER(T1)
	HRLM F,DEVSER(T1)	;LINK INTO DDB CHAIN
	HRLM T1,DDBBLK(F)	;PUT IN THE BACK LINK
	POP P,T1
	HLLM T1,DEVSER(F)	;NOW LINK IT IN
	MOVSS T1
	PUSH P,T3
	MOVE T3,DEVMOD(T1)	;IS THE NEXT ONE DOWN
	TLNE T3,DVTTY		;ALSO A TTY?
	HRLM F,DDBBLK(T1)	;YES, RESET ITS BACK LINK
	POP P,T3
	MOVE T1,[XWD TTYATC,ASSCON+ASSPRG]
	ANDCAM T1,DEVMOD(F)	;TURN OFF USE BITS
	SETZM DEVLOG(F)		;NO LOGICAL NAME

ZZ0==0
REPEAT <TRPLEN+5>/6,<
	SETZM	DDBTRP+ZZ0(F)
ZZ0==ZZ0+1>

	MOVSI T1,IOFST
	DPB T1,PJOBN		;SET JOB TO 0 (GO FOR IT, BILL!)
	MOVEM T1,DEVIOS(F)
	SETZM	DDBDCH(F)	;CLEAR NONDEVIOS DEVICE CHARACTERISTICS
	JRST CPOPJ1
;TTYNFR -- CALLED WITH J/ FRAME # TO ALLOCATE A NEW
;	   (DETACHED) TTY DDB FOR THE FRAME AND STORE A
;	   POINTER TO IT IN TTYTAB(J)
;	   (DEVNAM WILL BE 0,,SIXBIT /TTY/)
;	   NONSKIP-RETURNS IF NO DDB FREECORE, OTHERWISE SKIP-RETURNS

TTYNFR::PUSHJ	P, TTYSRC	;IF IT ALREADY HAS A COMMAND PORT DDB,
	  PUSHJ	P, DDBSRC	;OR THERE'S NO ROOM TO ALLOCATE ONE,
	    POPJ P,		;  ERROR-RETURN
	HLLZS	DDBLDB(F)	;MAKE SURE IT KNOWS IT'S DETACHED
	MOVEI	T1, (SIXBIT /TTY/)
	MOVEM	T1, DEVNAM(F)	;SET ITS NAME
	MOVE	T1, [TTYATC,,ASSCON]
	IORM	T1, DEVMOD(F)	;MARK IT AS A COMMAND PORT
	DPB	J, PJOBN	;SET ITS OWNER
	HRRZM	F, TTYTAB(J)
	JRST	CPOPJ1
;SCNNAM -- SET DEVNAM(F) TO "TTYNNN" WHERE NNN IS
;	   LDPLNO (FETCHED THROUGH U) IN OCTAL
;	   BREAKS T1 T3

SCNNAM:	LDB T1,LDPLNO
	DPB T1,PUNIT
	MOVSI T3,(SIXBIT /TTY/)
	MOVEM T3,DEVNAM(F)
	MOVE T3,[POINT 6,DEVNAM(F),17]
	PUSH P,T2		;SCNNMR CLOBBERS THIS ONE
	PUSHJ P,SCNNMR		;RADIX PRINT TO CORE
	POP P,T2
	POPJ P,

;NAMSCN -- CALLED WITH F/ TTY DDB
;	   RETURNS WITH T1/ PORT# FROM RH(DEVNAM)

NAMSCN:	PUSH	P, T2
	SETZ	T1,
	HRLZ	T2, DEVNAM(F)
NAMSC1:	CAML	T2, [200000,,000000]
	CAMLE	T2, [272727,,000000]
	JRST	NAMSC2
	LSH	T2, 3
	LSHC	T1, 3
	JRST	NAMSC1
NAMSC2:	POP	P, T2
	POPJ	P,
SUBTTL TRAP CODE

;CHECK FOR CHARACTER TRAP

CHRTRP:	TLNE U,LDLCOM
	POPJ P,		;NEVER AT COMMAND MODE
	MOVEI T1,LXRCHR
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ	;NO TRAP IF NO DDB
	LDB T1,DDPTCH
	MOVEI T2,FLGCHR	;AND SET THE FLAG IN CASE OLD TYPE
	PJRST TAKOTJ

;NOW FOR A LINE TRAP

LINTRP:	HRRZ F,LDBDDB(U)	;NEVER CALLED AT COMMAND LEVEL
	JUMPE F,CPOPJ
	MOVEI T1,LXRBRK
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	PUSH P,T2	;MUST PRESERVE T2
	LDB T1,DDPTLN
	MOVEI T2,FLGLIN
	PUSHJ P,TAKOTJ
	POP P,T2
	POPJ P,
;CALLED ON AN ESCAPE TO SEE IF WE SHOULD SET TRAP

ESCTRP:	TLNE U,LDLCOM
	POPJ P,		;NEVER IN COMMAND MODE
	MOVEI T1,LXRESC
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	HRRZ F,LDBDDB(U)
	JUMPE F,CPOPJ
	PUSH P,T1		;JUST LIKE CODE ABOVE
	LDB T1,DDPTSC
	MOVSI T2,FLGESC
	PUSHJ P,TAKNZJ		;TAKE THIS TRAP IF REALLY ENABLED
	 JRST TPOPJ		;NOT ENABLED
	POP P,T1		;ENABLED
	JRST TPOPJ		;RETURN UP A LEVEL TO IGNORE CHR

;CALLED FROM TYI WHEN AN ESCAPE IS READ TO CHECK ABOUT TRAPPING

ESCTR1:	PUSH P,T1		;FOUND ESCAPE READING CHRS
	MOVEI T1,LXRESC
	IORM T1,LDBDCX(U)	;SET BIT FOR POLPRT
	LDB T1,DDPTSC
	MOVSI T2,FLGESC
	PUSHJ P,TAKNZJ		;TRY THE TRAP
	 JRST TPOPJ	;NOT ENEABLED
	JRST ABTUUO		;ABORT THE UUO. IF ALREADY IN
			;HIGHER TRAP WE WILL JUST DO THE INPUT
			;AGAIN

;CALLED WHEN AN ORANGE BALL IS RECEIVED TO CHECK ON TRAPS

OBREC:	MOVEI	T1, LXROBS
	IORM	T1, LDBDCX(U)	; SET "ORANGE BALL SEEN" BIT
	HRRZ F,LDBDDB(U)	;GOT AN ORANGE BALL. DDB THERE?
	JUMPE F,CPOPJ		;NO
	LDB T1,DDPTOB		;GET THE CHANNEL NUMBER
	JRST TAKNZJ		;AND SET UP TO TRAP
;ROUTINE TO TAKE A JOB OUT OF TIOW FOR A TRAP

TTYWAK:	PUSH P,F
	PUSH P,S
	PUSHJ P,FRSTTY	;FIND THE FIRST TTY FOR THIS JOB
	 JRST TTYWK1	;NONE THERE, MUST NOT RALLY BE IN IOW
TTYWK2:	MOVE S,DEVIOS(F)
	PUSHJ P,TIWAKE	;WAKE HIM UP IF IN IOW
	PUSH P,U
	HRRZ U,DDBLDB(F)
	JUMPE U,TTYWK3	;NOT ATTACHED, NOTHING WE CAN DO
	MOVSI S,L2LOEX	;SET EXTENDED OUTPUT BUFFER ING SO
	IORM S,LDBBYT(U)	;JOB CAN FINISH UUO
TTYWK3:	POP P,U
	PUSHJ P,NXTTTY
	 SKIPA		;NEXT TTY NOT THERE
	JRST TTYWK2	;TRY THE NEXT ONE
TTYWK1:	POP P,S		;FINISHED
	POP P,F
	POPJ P,
;ROUTINES TO FIND A JOB'S TTY DDBS

FRSTTY:	HRRZ F,TTYTAB(J)	;FIRST ONE SHOULD BE THE CONTROLING TTY
	SKIPA
NXTTTY:	HLRZ F,DEVSER(F)	;IF WANT THE NEXT, FOLLOW CHAIN
	JUMPE F,CPOPJ		;DONE
	MOVE S,DEVMOD(F)
	TLNN S,DVTTY!DVRMT	;IS IT STILL A TTY OR RMT
	POPJ P,			;NO
	LDB S,PJOBN
	CAMN S,J		;FOR THIS JOB?
	AOS (P)		;YES, SKIP RETURN
	POPJ P,			;NO, FOUND THEM ALL
;ROUTINE TO CLEAR SLEEP CONDITIONS FOR ALL TTYS

EXTERN	JBYWAK,JBYEXC

TTSCLR:	PUSH P,F
	PUSH P,S
	MOVEI T2,0
	LDB	S,JBYWAK	;GET WAKE CHANNEL
	CAIN	S,^D36		;HIBER CODE?
	DPB	T2,JBYWAK	;YES, CLEAR IT
	LDB	S,JBYEXC	;GET EXIT IN CHILD CHANNEL
	CAIN	S,^D36		;HIBER CODE?
	DPB	T2,JBYEXC	;YES, CLEAR IT
	PUSHJ P,FRSTTY
	 JRST TTYWK1	;ALL DONE, (NO TTYS)
TTSCL2:	MOVSI S,DVRMT
	TDNE S,DEVMOD(F)
	JRST TTSCL3		;DO NOT CLEAR FOR RMTS
	LDB S,DDPTCH
	CAIN S,^D36	;IS THIS A SLEEP CODE?
	DPB T2,DDPTCH	;YES, CLEAR IT
	LDB S,DDPTLN
	CAIN S,^D36
	DPB T2,DDPTLN	;NOW FOR LINE
	PUSH P,U
	HRRZ U,DDBLDB(F)	;GET LINK TO LDB
	JUMPE U,TTSCL1	;NONE THERE, FINISHED THIS TTY
	LDB S,DDPTOB	;WAITING FOR ORANGE BALL
	CAIN S,^D36
	DPB T2,DDPTOB		;CCLEAR SLEEP
	LDB S,DDPTLN		;LINE
	CAIN S,^D36
	DPB T2,DDPTLN
	LDB S,DDPTCH	;CHARACTER
	CAIN S,^D36
	DPB T2,DDPTCH
TTSCL1:	POP P,U
TTSCL3:	PUSHJ P,NXTTTY
	 JRST TTYWK1	;FINISHED, GET F AND S BACK AND GO
	JRST TTSCL2	;MORE TO CLEAR
;ROUTINE TO CLEAR ALL TRAP CONDITIONS FOR ALL TTYS

TTTCLR:	PUSH P,F
	PUSH P,S
	PUSHJ P,FRSTTY
	 JRST TTYWK1	;NO MORE TTYS THERE
TTTCL1:	MOVSI S,DVRMT
	TDNE S,DEVMOD(F)
	JRST	[PUSHJ P,RMTRSI	;RESET FOR REMOET
		JRST TTTCL2]

ZZ0==0
REPEAT <TRPLEN+5>/6,<
	SETZM	DDBTRP+ZZ0(F)
ZZ0==ZZ0+1>

TTTCL2:	PUSHJ P,NXTTTY		;FIND THE NEXT ONE FOR THIS JOB
	 JRST TTYWK1		;DONE
	JRST TTTCL1		;CLEAR IT ALSO
;THIS ROUTINE ASSIGNES TRAP CHANNELS TO TTY TRAP CONDS
;CALLED WITH T3 CHANNEL NUMBER
;	T2 TRAP NUMBER
;	F TTY DDB
;	SKIP RETURN IF TRAP CONDITION NOW SATISFIED

TINAS1:	LDB T1,DDPTAB(T2)	;GET CURRENT
	CAILE T3,^D35		;REAL INTERRUPT CHANNEL?
	JUMPN T1,CPOPJ		;NO, SLEEP. DON'T CLEAR IF INT. THERE
	DPB T3,DDPTAB(T2)	;SET TRAP CONDITION IN DDB
	JUMPE T3,CPOPJ		;IF ENABLING, NOT DISABLING,
	HRRZ U, DDBLDB(F)	;  GET LDB IF THERE IS ONE
	XCT INTSET(T2)		;  AND CHECK IF IT'S ALREADY TRUE
	POPJ P,			;IN CASE WE DO NOT TRANSFER

;INTERRUPT TEST TABLE -- MUST BE IN THE SAME ORDER AS DDPTAB

INTSET:	POPJ P,		;ESCAPE, WILL GET IT LATER
	JUMPN U, CHKCHR	;IF LINE PRESENT, CHECK FOR CHARACTERS
	JUMPN U, CKLNTR	;IF LINE PRESENT, CHECK FOR BREAKS
	POPJ P,		;IOW, NEVER PRESET
	POPJ P,		;FINISH IO
	JRST CHKLOS	;LOST CHARACTERS
	POPJ P,		;ORANGE BALL, NEVER KNOW
	POPJ P,		;CIRCUIT ZAPPED
	JUMPN U, CHKPSP	;IF LINE PRESENT, CHECK FOR UNREAD PORT-STATUS
	JUMPN U, CHKYEL	;YELLOW BALL, PERHAPS ONE IS PENDING
	POPJ P,		;CHARACTER GOBBLER, NOT BUFFERED
	JUMPN U, CHKTCC	;IF LINE PRESENT, CHECK FOR CHANGED TC'S
;ROUTINES TO CHECK IF TRAP CONDITION ALREADY SATISFIED

; CHECK IF CHARACTERS LOST (BY READING IO.BKT)

CHKLOS:	MOVE S,DEVIOS(F)
	TRNE S,IOBKTL
	AOS (P)		;BIT ALREADY SET CAN TRAP NOW
	POPJ P,

; CHECK IF CHARACTERS PRESENT (BY READING LDB COUNTS)

CHKCHR:	HLL U,LDBDCH(U)
	TLNE U,LDLCOM
	POPJ P,		;NOT SAT AT INTERRUPT LEVEL
	SKIPG LDBECC(U)	;CHRS TO BE ECHOED
	SKIPLE LDBTIC(U)	;OR ALREDY ECHOED
	AOS (P)		;YES
	POPJ P,

; CHECK IF A BREAK CHARACTER IS PRESENT (BY READING LDB COUNTS)

CKLNTR:	HLL U,LDBDCH(U)
	TLNE U,LDLCOM
	POPJ P,
	MOVE T1,LDBTIC(U)
	ADD T1,LDBECC(U)	;ENOUGH?
	CAIL T1,TIWKC
	JRST CPOPJ1		;YES
	TLNE U,LDLBK2	;WHICH BREAK SET
	SKIPG LDBBK2(U)
	SKIPLE LDBBKC(U)	;TEST CORRECT ONE(S)
	AOS (P)
	POPJ P,

; CHECK IF A PORT STATUS MESSAGE IS WAITING TO BE READ

CHKPSP:	MOVSI	T1, LMLPSP
	TLNE	T1, LDBMOD(U)	; IS THERE A MESSAGE WAITING?
	AOS	(P)		; YES
	POPJ	P,

; CHECK IF ANY TERMINAL CHARACTERISTICS HAVE CHANGED

CHKTCC:	HLL	U, LDBDCH(U)
	TDNN	U, LDLPTY	;IF IT'S NOT A PTY,
	POPJ	P,		;  OF COURSE NOT
	PUSH	P, U
	PUSHJ	P, PTYBUD
	SKIPE	LDBTCB(U)	;ANY UNREAD CHANGES?
	AOS	-1(P)		;(YES)
	POP	P, U
	POPJ	P,


; Test for Yellow ball interrupt condition satisfied:
;   Skip return if a Yellow ball has been received and no Orange ball
;   has yet been sent.  If an Orange ball is waiting to be output, it
;   must be due to a Yellow ball being received while the interrupt
;   was not enabled.  If the interrupt was enabled, the user will have 
;   already taken the trap.

CHKYEL:	LDB	T1,LOPSOG	;is OB waiting to be output?
	TRZN	T1,1		;if so, recall it...
	 POPJ	P,
	DPB	T1,LOPSOG	;its now the user's responsibility
	MOVSI	T1,LXLOOK	
	IORM	T1,LDBDCX(U)	;okay for user to send an orange ball
	AOS	(P)		
	POPJ	P,

;SEND A YELLOW BALL

TTYYLS:	HRRZ	U, DDBLDB(F)
	JUMPE	U, CPOPJ
	PUSH	P, T1		;SAVE T1
	MOVEI	T1, 1
	DPB	T1, LOPSYL	;SET SEND-YELLOW
	DPB	T1, LDBOPB(U)	;AND NEED-OUTPUT
	JRST	TPOPJ		;RESTORE T1 AND RETURN

SETFIO:	MOVSI S,TINFIO
	IORB S,DEVIOS(F)	;SET A FLAG SO WE KNOW WE TRAPPED
				;INSTEAD OF GOING INTO IOW
	POPJ P,
;FNDPRT -- CALLED WITH J/ JOB #, F/ -1 OR PORT #
;	   LOOKS FOR A DDB FOR THAT PORT/JOB (-1 IS CMND PORT)
;	   NONSKIP-RETURNS IF THERE IS NONE
;	   SKIP-RETURNS WITH F/ DDB ADDR IF THERE IS

FNDPRT:	JUMPL F,[HRRZ F,TTYTAB(J)	;COMMAND PORT
		JRST FNDPT1]
	CAIL F,PORTN
	POPJ P,		;MUST NOT BE THERE
	MOVE F,LINTAB(F)
	HRRZ F,LDBDDB(F)
FNDPT1:	JUMPE F,CPOPJ	;NO DDB ATTACHED
	PUSH P,T1
	LDB T1,PJOBN
	CAME T1,J	;THIS JOB?
	JRST TPOPJ	;NO
	JRST TPOPJ1	;YES
;TINASS UUO -- ASSIGN TTY INTERRUPTS
;(MOST OF THE WORK IS DONE IN TINAS1)

TINASS:	LDB T3,[POINT 9,T1,17]	;GET THE CHANNEL NUMBER
	CAIG T3,^D35
	SKIPGE JBTPIP(J)	;IF TOO LARGE OR NO INTADR
	POPJ P,			;TAKE ERROR RETURR
	HRRZ F,TTYTAB(J)
	HRRZ F,DDBLDB(F)
	JUMPE F,TINDET		;DETACHED, OK
	MOVSI T2,LLLZAP
	TDNE T2,LDBLOG(F)
	POPJ P,		;CAN NOT SET IF WAITING FOR LOGUT
TINDET:	HRRE F,T1
	PUSHJ P,FNDPRT
	 POPJ P,		;BAD PORT NUMBER
	LDB T2,[POINT 9,T1,8]	;GET INTERRUPT NUMBER
	CAIL T2,TRPLEN		;TOO LARGE?
	POPJ P,		;YES
	PUSHJ P,TINAS1		;GO ASSIGN
	 JRST STOTC1		;GOT IT, GIVE BACK OLD
	PUSH P,T1		;CONDITION SAT, SAVE OLD CHANNEL
	MOVE T1,T3
	PUSHJ P,TAKTRP	;TAKE THE TRAP
	POP P,T1
	JRST STOTC1		;AND RETURN THE ANSWER
SUBTTL	INITIALIZE
;INITIALIZE THE WORLD. THIS ROUTINE DOES NOT MAKE PROPER 
;PROVISION FOR 140 RESTART SINCE THAT ABILITY IS NO LONGER
;OF ANY IMPORTANCE

;Beware, this routine (between TTYINI and TTIEND) is overwritten by
;hackers to patch running monitors on the assumption that the
;code is never reentered after system initialization.  Beware
;if this ever changes!  The CONFIG gettab points to TTYINI as
;the dynamic patch area.

EXTERN SYSNUM

TTYINI:
	SETZM INTERM
	SETZM BPREQ		;INITIALLY NO BLOCK PORTS
	SETZM OPRTIM		;START WITH NO ALARM FLAGS SET
	SETOM THSTIM##		;TIMER FLAGS
	SETZM MXTIM##
	MOVEI T1,CCTYI
	MOVEM T1,COMTIA		;SET UP COMMAND READ AND WRITE
	MOVEI T1,CCTYO
	MOVEM T1,COMTOA
	MOVE P1,[POINT 1,LINFLG]	;READY TO SET BYTE PTRS
	MOVSI P2,NMXLIN-1	;NOW ALL LINES
TTINI2:	HRRZ U,LINTAB(P2)	;POINT TO LDB
	MOVSI T1,LDICLR(U)	;CLEAR IT OUT
	HRRI T1,LDICLR+1(U)
	SETZM LDICLR(U)
	BLT T1,LDICLE(U)
	DPB P2,LDPLNO		;RESTORE U NUMBER
	IBP P1		;TO POINT TO NEXT BIT
	MOVEM P1,LDBOPB(U)
	SETZM (P1)		;MAKE SURE FLAG WORD IS 0
	MOVE T3,LINTAB(P2)	;CHECK INITIALIZE BITS
	SKIPN REFLAG		;BUT NOT IF REFRESING
	TLNN T3,TTVINI
	JRST TTINI3		;NOT RUN INITIA
	MOVSI T1,1
	TDNN T1,STATES
	JRST TTINI3		;DO NOT RUN IF NOT AUT-RESTART
	MOVE T1,[LLLNLN,,LDLCOM]
	HLLZM T1,LDBLOG(U)
	HRLZM T1,LDBDCH(U)	;SET LOGGED IN AND COMMAND MODE
	MOVEI	T1,1
	DPB	T1,LOPHSH	;SET HUSH BIT TO SUPRESS OUT MESSAGES
	SETZM LDBDCX(U)		;NO EXTENDED BITS ON
	PUSHJ P,SETLMD
	PUSHJ	P,FRMASN##	;Assign a Job/frame slot
	  STOPCD		;Strictly Fatal
;;***NOTE*** Can't call TTYATI here since it calls DDBSRC, which
;;***NOTE*** uses TTYFLK, which points at DEVLST-DEVSER.  This
;;***NOTE*** in turn means that DEVLST gets smashed when DDB is
;;***NOTE*** allocated, thus causing TTYINI to get called twice.
;;***NOTE*** Go please the world.
	MOVEI	T1,TTYLST	;Start DDB search from here
	PUSHJ	P,DDBSR1	;Get a TTY DDB
	  STOPCD		;No errors allowed here
	PUSHJ	P,[PUSH P,U
		   JRST TTYAT1]	;IT'S NOT SUCH A BAD HACK...
	  STOPCD		;Last chance for fatal error...
	MOVEI T1,CMFCXI##	;Forced command index for INITIA
IFKMC<
	SKIPGE KMCDO		;GREATER OR EQUAL 0 NOT KMC MANUAL MODE
	 MOVEI T1,CMFCKM##	;DO FORCE KMC LOAD
>;END IFKMC
	PUSHJ P,TTFORC
TTINI3:	AOBJN P2,TTINI2
	SETZM DEVOPR		;NO OPER YET
	SETZM OPRLDB		;AND HAS NOLDB
	HRRZ T1,TTCLST	;SET UF FREE LIST
	SETZM (T1)		;ZERO OUT FREE LIST
	MOVEI J,TTCHKS(T1)	;SET FREE POINTER TO FIRST
	MOVEM J,TTFREE
	MOVEI J,1(T1)
	HRL J,T1
	HLRZ T3,TTCLST		;GET SIZE
	MOVEM T3,TTFREN
	SOS TTFREN		;ONE LESS SINCE NO CHUNCK 0
	IMULI T3,TTCHKS
	ADDI T3,(T1)
	BLT J,-1(T3)		;ZERO ALL OF IT
	MOVEI T3,TT2CHK(T1)	;NOW LINK UP
	MOVE J,TTFREN	;NUMBER TO LINK
TTINI4:	MOVEM T3,TTCHKS(T1)
	ADDI T1,TTCHKS		;MOVE FORWARD
	HRLI T3,(T1)		;SET BACK LINK
	HRRI T3,TT2CHK(T1)	;AND FORWARD
	SOJG J,TTINI4	;STORE IF NOT DONE
	HLLZS (T1)		;ZERO FORWARD LINK OF LAST ONE
	SETZM IRPPDP	;RESET ALL POINTERS
	SETZM IRP620
	SETZM ORP620
IFCPU (F3),<
	PUSHJ	P,FNSYNC	;SYNCHRONIZE WITH THE NODE
>;END IFCPU F3
	MOVEI T1,2
	MOVEM T1,ORPPDP	;EXCEPT OUTPUT WHICH STARTS WITH SHUT
	MOVE T3,[POINT 7,CONFIG,6]
	MOVSI P3,TYPI TYPHSI
	SETZ	T1,	;T1 WILL GET SYSTEM NUMBER FROM SYSTEM NAME
	MOVE	T1,SYSNUM	;GET SYSTEM NUMBER WE ARE
IFCPU (<KI,KL>),<
	TDNE	T1,[-377-1]	;ONCE AND MONITOR PEOPLE SHOULD NOT ALLOW NUMBERS
	STOPCD			;BEYOND 255.
>;END IFCPU (<KI,KL>) HOST NUMBERS .GT. 255 ALLOWED ON 11 BASE

	DPB T1,WRPCHR
	MOVEI T1,RPORTN	;# OF REAL (NONPTY) PORTS
	TRZ T1,3	;MUST HAVE A MULTIPLE OF 4 (REALLY?)
IFKMC<	CAIL	T1,LPERDR	;DETERMINE LINES ON 1ST NODE
	  MOVEI	T1,<LPERDR-1>&74	;MUST BE A MULTIPLE OF 4 .LT. ^D64
>;END IFKMC
	DPB T1,WRPLIN
	MOVEM P3,ORING
	MOVSI P3,TYPI TYPCLP
	MOVEM P3,ORING+1	;ASK FOR TIME FROM SUP
IFKMC<	MOVEI	T1,<4320000&<7777_<3*MAXDR>>>_-9
		;T1/4320 or 320 or 20 or 0 (SEE DRFLAG:) SO AS TO PUT
		;OUT 41 MESSAGES TO DRs 2,3 & 4 IF THEY ARE THERE
	SETZ W,			;INITIALIZE W FOR NON-PTY OUTPUT
	MOVSI	P3,TYPI TYPHSI	;41 MESSAGES
	PUSHJ	P,MDRMSG
	HRLZI T1,10000
	MOVE T1,31 ;NOOP;MOVEM T1,31	;TELL 8080 TO READ KEEPALIVE
>;END IFKMC
	POPJ P,

TTIEND:	;;end of area used for dynamic patches, see comment at TTYINI:

IFCPU(F3),<
;ROUTINE TO RESYNC WITH NEXILIS BASE.
; CALLED FROM TTYINI BEFORE SENDING MESSAGES THRU RING.

EXTERN CTYDO,INLMES

OPDEF TNCONO [744000,,0]
OPDEF TNOUT [745000,,0]
OPDEF TNIN [746000,,0]

	NZEROS==300		;NUMBER OF ZEROES HAVE TO BE ACCEPTED
	NACCEP==^D24*30000	;APPROX 24 SECONDS OF WAITING FOR ACCEPTANCE.
				;ORIGINAL SPEC WAS 20, ADD 4 FOR GOOD MEASURE
				; BECAUSE WERE NOT USING A CLOCK.


FNSYNC:	TNCONO	0		;RESET THE INTERFACE.
	SKIPE	CTYDO		;ONLY IF CTYSIM NOT GONG TO RUN.
	POPJ	P,		;RETURN.
FNSYNR:	MOVEI	T3,NZEROS	;NUMBER OF ZEROES TO TRY TO SEND.
	TNCONO	0		;TURN OFF INPUT AND OUTPUT TO THE 11

FNSYN0:	MOVE	T4,[NACCEP]	;NUMBER OF TIMES TO LOOK FOR ACCEPTANCE OF ZERO
	TNOUT	0		;SEND A ZERO
FNSYN1:	IMULI	T1,1
	IMULI	T1,1
	IMULI	T1,1		;WASTE TIME FOR MICROCODE
	TNIN	T2		;GET DATA
	TLNE	T2,(1B5)	;SKIP IF NOT ACCEPTED
	JRST	FNSYN2		;OK, GOT ONE
	SOJG	T4,FNSYN1	;KEEP WAITING
	MOVEI	P1,[ASCIZ	/CANNOT RESYNC WITH TYMBASE
/]
	JSP	T1,CTYTYP	;TYPE THE MESSAGE OUT ON CONSOLE
	JRST	FNSYNR		;AND RETRY

FNSYN2:	SOJG	T3,FNSYN0	;KEEP GOING UNTIL WE GET ENOUGH ACKNOWLEDGED ZEROES
	TNCONO	1B34!1B35	;OK, TURN ON THE INTERRUPTS FROM THE 11.
	POPJ	P,		;AND RETURN.
>;END IFCPU(F3)
;THE INTERNALS AND EXTERNALS FOR SCNSER

;FROM COMMON
EXTERNAL MXLIN,NMXLIN,TTFREE,TTCLST,PORTN,PJBSTS,EPT
EXTERNAL RMXLIN,RPORTN,PPORTN
EXTERNAL BITNTB,LINFLG,NMXFLG,ALR620,JBTABT,JBTUNM,JBTUN1
EXTERNAL JBTCIN,JBTCOT,JBTBCS,JBTLIC,JBTAWQ,JBTBET,JBTBIO
EXTERNAL IRING,ORING,ORPPDP,IRPPDP,ORP620,IRP620,MSKIRG,MSKORG
EXTERNAL JOBN,HIGHJB,CONFIG,QUEPCB

;GENERAL EXTERNALS
EXTERNAL TPOPJ,TPOPJ1,CPOPJ,CPOPJ1,STTIOD,JBTSTS,LINTAB,JBTPRV
EXTERNAL PJOBN,WSYNC,SETRUN,PEVEN8,JOB,REFLAG
EXTERNAL TTYTAB,PUNIT,STATES,UPTIME,PVYMOD
EXTERNAL DEVOPR,THSDAT,JFYSEC,TIME	;NAME OF OPER CONSOLE
EXTERNAL GET4WD,GIV4WD,BIOCOR
IFCPU (KL),<EXTERNAL CSUCNT,CSVCNT,CSHSAV>

;EXTERNALS USED BY M ROUTINES
EXTERNAL OUT,BUFCLR,ADRERR,ADVBFF,ADVBFE
EXTERNAL PRPER,GTCGSZ,RMTRSI,RELEA6
EXTERNAL CHKSEG,SETIO2

EXTERNAL TTVINI,TTVIN2		;BIT IN LINTAB (LH) TO SAY SHOULD RUN INITIA

;FOR ONCE (ALSO USES COMTYI,TTCMCH)
INTERNAL COMTOA,COMTIA,TTYINI,TTIEND
IFKMC<EXTERNAL KMCDO>

;FOR COMMON. ALSO USES TTYLNO
INTERNAL SCNDDB,SCNDDS,LDBLEN,SCNLDB,FRETTY,TTYFLK
ENTRY SCNSER

;FOR COMCON (AND MAYBE ERRCON)
INTERNAL TTYNAM,TTYKIL,COMTYO,TTYFND,LDBLOG
INTERNAL SCNTCD,LDPLNO,LDLCOM,TTYUSR
INTERNAL TTYUSW,TTYSTR,TTYFUW,DDBLDB
INTERNAL LDBDCH,LDBDDB,TSETBI,TRESCN,TTCMCA
INTERNAL TTYFNU,TTYPHY,TTCMCH,COMTYI,OPRLDB,TTYDET
INTERNAL COMTYT
INTERNAL TTYATT,SETSHT,OPRTIM,CTYFIL

;UUOCON ALSO USES TTYFND,LDLCOM,TTYU;STC,TTYFUW
;AND DDBLDB,LDBDCH,LDBDDB
INTERNAL POLPRT
INTERNAL DDTIN,DDTOUT,GETDDB,TTYUUO,TTYOUW,TATUUO,TDTUUO
INTERNAL GETLOG,LINJOB,CKLGO,TTYRES,AUXTUU,DDBBLK
INTERNAL GETOPR,GETLPS,GETMOD,HNGUUO,CREAUX
INTERNAL AUXRED,ZAPCIR,IFDET,OPRSND,OPRFRE,INISET
;FROM COMCON (TTY COMAND)
EXTERNAL DECIN1,OCTIN1

;FOR CLOCK1
INTERNAL TTYSTC,TTYSET,CTYTYP,SCNINT,SCNSEC,TTYSOW,TYCIOS,MONHNG
INTERNAL DWNFLG,INTERM
INTERNAL CTYTYO
IFCPU (KL),<INTERNAL SPCINI>
EXTERNAL AXAVAL,AXREQ,AXSWT,AXWAIT,MLOWQ,RNQ,WSCHED,CHGCLK
EXTERNAL FCREQ,FCWAIT
EXTERNAL BPAVAL,BPREQ,BPWAIT
TTYSET==NOCTRO	;OLD CLOCK1 FUNCTION

;FILSER ALSO USES TTYFUW,TTYSTR

;ERRCON
INTERNAL TTYERP

;PICON
EXTERNAL ABTUUO,TAKTRJ,TAKNZJ,TAKOTJ,TSTKTJ,TSTKTP,TSTTRJ,JBTPIP,TAKTRP
INTERNAL TTSCLR,TTYWAK,TTTCLR,TINAS1,TTNCHR,TTNESC,TTNLIN,TTNYLB
INTERNAL TTYYLS,FNDPRT,TINASS
; VARIABLES

IFKMC<
BBCNTS:	EXP	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	;16 WORDS
BBPAGE:	EXP	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       	EXP	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	;32 WORDS
TIMMIN:	EXP ^D60
TIMDRD:	EXP ^D60
DRMHSI:	0
DRMSHT:	0
DRMBRK:	0
DRMANS:	0
DRMCLP:	0
DRMTIM::	0 ;SECONDS OF UP TIME
DRDOW:	0
SENT41:	EXP 0,0,0,0	;SET ON SENDING 41, RESET ON RECIEVING 3 OR 1
KMCLAS:	0	;LAST KMCGAV,KMCGAC
KMCPDP::	0
KMCFLG::	REPEAT ^D64,<EXP 0>;KMC ACTIVE FLAG HISTORY
IRPMSG::	0
IRPMS2::	0
IRPMS3::	0
IRPMP1::	0
IRPMP2::	0
IRPMP3::	0
IRPMB1::	0
IRPMB2::	0
IRPMB3::	0
	>;END IFKMC
BADGUY:	0	;COUNTER INCREMENTED IN GOHSH:
FSCN:	0
TTFREN:	0	;NUMBER OF FREE CHUNKS LEFT
INPCH:	0
LINPTR:	0	;OUTPUT SCAN POINTER
CHCNT:	0	;# REMAINING CHARS TO OUTPUT AT A TIME ON A PORT
CHQTA:	0	;VALUE THAT CHCNT WAS SET TO AT START OF CYCLE
SVSPC:	0
TTCMCH:	0	;HERE IS CHARACTER FOR COMMAND DECODER
TTCMCA:	0	;INPUT POINTER FOR COMMAND BEING DECODED
COMTIA:	0	;ADRESS OF COMMAND IN ROUTINE (CHANGED BY ONCE FOR ONCE DIALOGUE)
COMTOA:	0	;SAME FOR OUTPUT
OPRLDB:	0	;LDB FOR OPER CONSOLE FOR MSGS ETC
UPSHUT:	0	;PLACE FOR UP-SHUT COMMAND TO BE STORED

LINPNM:	0	;SAVE U NUMBER FROM JFFO
LINFSV:	0	;SAVE FLAG WORD
SVOJFF: 0	;SAVE OUTPUT BIT NO FROM LDBOUT
INTERM:	0
OPRTIM:	0
FRETTY:	0	;POINTER TO FREE TTY DDBS
TTYFLK:	0	;POINTER TO WHERE TO LINK IN TTY BLOCKS
CHRRDP:	0	;BYTE POINTER TO INPUT RING FOR CHARACTER INPUT
CHRWRP:	0	;REAL TTY: BYTE POINTER TO OUTPUT RING
	0	;PTY: BYTE POINTER TO PTY BUFFER
MULCNT:	0	;REAL TTYS: # CHARS MORE WILL FIT IN OUTPUT RECORD
	0	;PTYS: # CHARS MORE PTY OUTPUT THIS SECOND
MXMCNT:	0	;REAL TTYS: ORIGINAL VALUE OF MULCNT
TIMOW:	0	;TIMER FOR ORANGE-BALL WAIT ON CIRCUIT ZAPS
ALRSNT:	0
AUXRCP:: -1	;RECEIVED AUX PORT
AUXSTA:	0	;AUX CIRCUIT STATE
AUXSTR:	BLOCK 1+<AUXSTM+6>/5	;SPACE FOR STRING
AUXSTP:	0	;STRING POINTER
AUXERR:: 0	;ERROR FROM AUX CIRCUIT BUILD
AUXJOB:	0	;JOB BUILDING AUX CIRCUIT
AUXWSC: 0	;# OF AX-BUILTS RECEIVED IN WRONG STATE
AUXWPC: 0	;# OF AX-BUILTS RECEIVED GIVING WRONG PORT
AUXWPT:	-1	;PORT LDB ADDRESS OF THE LAST ONE
NRPCNT: 0	;# TIMES WE GAVE "NO PORT RECEIVED" ERROR
ZRPCNT: 0	;# TIMES WE ZAPPED THE RECEIVED PORT
BIOJOB:	0	;JOB INITIATING BLOCK I/O FOR PORT.
AUXPRT:	0	;PORT BEING BUILT FROM
AUXTIM:	0	;AUX CIRCUIT TIMER
AUXUNM:	BLOCK 2	;SPACE TO BUILD UP A USER NAME
BUFLST:	0	;HEADER FOR LIST OF BLOCK INPUT/OUTPUT BUFFERS
BIOCNT:	0	;REAL TTYS: # OF JOBS ENABLED TO DO BLOCK I/O
		;	    LH := -1 AS A FLAG TO BLKNEG CODE
	0	;PTYS: # OF JOBS ENABLED TO DO PSEUDO-BLOCK I/O
BIOPRT: 0	;# OF BLOCK I/O PORTS, I.E., THE LAST RESPONSE
		;FROM THE BASE TO A NEGOTIATE MESSAGE
BIOBUF: 0	;# OF MONITOR BLOCK I/O BUFFERS
BBFREE:	0	;# OF FREE MONITOR BLOCK I/O BUFFERS
BBCRE:	0	;# OF BIO BUFFERS CREATED SINCE MONITOR LOADED (KS ONLY)
BBREL:	0	;# OF BIO BUFFERS RELEASED (KS ONLY)
BBPOOL:	0	;COUNT OF BIO BUFFER RE-USE SINCE MONITOR LOADED
BIOANS: 0	;# OF BLOCK I/O NEGOTIATE MESSAGES SENT BUT NOT
		;YET REPLIED-TO
ERRBNG: 0	;# OF UNSOLICITED BLOCK I/O NEGOTIATE MESSAGES
DWNFLG:	0	;WANT TO TAKE SYSTEM DOWN
CTYFIL:	0	;NUMBER OF FILLS NEEDED BY CTY
CTYFLN:	0	;COUNTER WHEN SENDING FILLS TO CTY
OPRWJB:	0	;JOB WAITING FOR SETUUO OPR MSG
TTYLOS: 0	;COUNT OF CHARACTERS LOST BY TYMNET
		;(BLACK BALLS -- BUFFER ZAPS)
PTYLOS:	0	;COUNT OF CHARACTERS LOST BY PTYS
TILOW==^D80	;VALUE FOR SMALL QUOTA OF UNREAD INPUT CHARACTERS
TIWRNN: TILOW	;SMALL QUOTA FOR UNREAD INPUT CHARACTERS
		;(BACKPRESSURE WHEN IT'S EXCEEDED)
TIHLTN:		;LARGE QUOTA FOR UNREAD INPUT CHARACTERS
		; MUST BE AT LEAST AS LARGE AS THE MAX NUMBER OF CHARS THE
		; INPUT RING CAN HOLD * 2 + TIWRNN,
		;  OTHERWISE CHARS COULD BE LOST
  IFDEF SIZIRG, <<1_SIZIRG>*4*2+TILOW>
  IFNDEF SIZIRG, <^D512*2+TILOW>
  ;IFNKMC	<^D500>	;LARGE QUOTA FOR UNREAD INPUT CHARACTERS
  ;IFKMC	<^D2000>;(LOSE CHARACTERS WHEN IT'S EXCEEDED)
TTYRHT: 0	;# TIMES MONITOR OUT OF BUFFERLETS AT RCVCHR
		;+ LOSPDP + LOS620
LOSPDP: 0	;# TIMES A PORT EXCEEDED ITS LARGE QUOTA
		;BEFORE WE COULD GET BACKPRESSURE SENT
LOS620: 0	;# TIMES A PORT EXCEEDED ITS LARGE QUOTA
		;AFTER WE HAD SENT BACKPRESSURE
OMX30:	^D120	;TTY OUTPUT HIGH-WATER MARK FOR SLOW DEVICES
OWK30:	^D60	;TTY OUTPUT LOW-WATER MARK FOR SLOW DEVICES
OMX120:	^D480	;TTY OUTPUT HIGH-WATER MARK FOR FAST DEVICES
OWK120:	^D240	;TTY OUTPUT LOW-WATER MARK FOR FAST DEVICES
TOEMAX:	^D500	;EXPANDED-MODE TTY OUTPUT LIMIT
LOGZAP:	0	;# OF LOGINS TO LOGGED-IN PORTS
ZAPLPT:	-1	;PORT LDB ADDRESS OF LAST LOGZAP OR DFRZAP
DFRZAP:	0	;# OF LDECS RECEIVED WHILE STILL ECHOING
NZAPIN: 0	;# ZAPPERS IN FROM TYMNET
NZAPN2: 0	;# TIMES WE GOT A ZAPPER ON A PORT W/ AN UNECHOED ZAP
NZAPLG: 0	;# TIMES WE GOT A LOGIN ON A PORT W/ AN UNECHOED ZAP
NZAPOT: 0	;# ZAPPERS OUT IN RESPONSE TO ZAPPERS IN
TMCOOR: 0	;# OF UNKNOWN TERMINAL CHARACTERISTICS SET BY TYMNET
PTYFLO:	^D1000	;CHARS/SEC TOTAL MAXIMUM PTY FLOW
	3,,0		;LINK IT IN
	.LINK 1,.-1
	TTYLOS,,[SIXBIT /TTYLOS/
		SIXBIT /TTYLGZ/
		SIXBIT /TTYDFZ/]
SKPFLG:	0	;SET TO INDICATE INPUT AND SKIP AUXCAL IN PROGRESS
	END
    o C