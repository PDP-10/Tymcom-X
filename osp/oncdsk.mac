TITLE	ONCDSK	OPTIONAL & MANDATORY ONCE ONLY CODE

INTERN FILOPT,FILMAN,TYPONL,ONDSTT,ONDLNP,ONDLNR
INTERN MIN,MAX,LNGMES,DECLOP,CMDSCN,CMDSCF,ASKQMM,OPAGIN,OPAGOT
INTERN GETHOM,WTBOTH,GETBAT

EXTERN CONMES,CRLF,CTEXT,DECIN,GETLIN,OCONM,OCTIN,OPOUT,DSKDDB
EXTERN CORZER,SCNBAT,STTPTR,UNTTBL,WRDSPP,STTFPC,BLKSPP,UNTLEN
EXTERN STTLEN,SATCNT,UFDHSI
EXTERN NMRBPC,CPOPJ,CPOPJ1,MFDRIB
EXTERN %HOM.P,%BAT.P,%STR.P,%STA.P
EXTERN COMTYO,BRMAX,INLMES,NMSTPC
EXTERN CLRSND,PRNAME,RADX10,TPOPJ,CMPLOG,RB1UN,NMUFDS
EXTERN PAGIN,PAGOUT,PCISTS,PGYUNI,PGYPNO,STDREA,PGYERR,OHTNUM,OHTINI
EXTERN PCBPAG,PAKREF,HBBPGS,STDWRT,GETPEV
EXTERN BATFIR,BATREG,BAYNBB,PAGCOD,PAGNAM,PAGSLF
EXTERN CODBAT,CODHOM,CODRIB,DDBLEN,DDSTAR,ONCDDB
EXTERN ICPFAC,JFYSEC,KONDWN,KONUPA,KOPDWN,KONLTM,KONCPY
EXTERN LPNHOM,LP2HOM,LPNBAT,LP2BAT,LPNSAT,SYSUNI,SYSSIZ,EVASIZ
EXTERN PROT,PROT0,CLRDDB,YESNO
EXTERN REFSTR,SAVE4,SETDDO,IOSEL,CCOD,CWCOD

EXTERN HOMEND,HOMDAT,HOMMFD,HOMHSH,HOMRAN
EXTERN HOMHID,HOMP4C,HOMLOG,HOMLUN,HOMNXT,HOMOVR
EXTERN HOMPRV,HOMREF,HOMSNM,HOMSPU

EXTERN RIBLST,RIBPFS,RIBNAM,RBSPAR,RBREAL,RBINDX,RBMASK
EXTERN RBYUNI,RBYPNO
EXTERN RBYUN4,RBYUN1,RBLVPR,RBLVSP

EXTERN STRPPU,STRP4C,STRUNI,STRUNM,STRDDB,STRLEN,STRHSH
EXTERN STRNAM,STROVR,STRREF,STRTAL,SRPNDS,STRBTS

EXTERN UNIPPU,UNIDES,UNIERR,UNIHID,UNISYS
EXTERN UNINAM,UNISTT,UNISTR
EXTERN UNITAL,UNPCHG,UNPHWP,UNPMSB,UNPOFL,UNVRSF,UNYPPY
EXTERN UNYKTP,UNYLN1,UNYLUN,UNYSPU,UNYUTP
EXTERN UNIBLK,UNIKON,UNILOG,UNICHN,UNPPRV,UNISTS

EXTERN DCN,STRPID,REPSID,RE.DCD,HOMDCT,HOMDCV

EXTERN CH7
ENTRY ONCMOD

ONCMOD:

ONDSTT:
PHASE %OND

;MACRO TO DEFINE ONCE RESTART SYMBOLS AND BYTE POINTERS
;
DEFINE DCNDEF (DCD)<
  INTERN  REONCE
	REONCE:	0
	DCNUM==0
	IRP DCD, <DCNUM==DCNUM+1>
	DCNTAB:
	DCXX==0
	IRP DCD, <DCN.'DCD==(1B<DCXX>)
		  DCNY'DCD: POINT DCSIZ,DCN,35-DCSIZ*<DCNUM-1-DCXX>
		  Intern DCN.'DCD,DCNY'DCD
		  DCXX==DCXX+1>
>
DCSIZ==DC.SIZ			;(FROM S).
DCNDEF (<OP,ON,UR,MN,HM,DF>)	;DSKCLN TYPE CAN BE SPECIFIED BY:
				; 'OP' - OPER in ONCE (FULL COMMAND)
				; 'ON' - OPER IN ONCDSK
				; 'UR' - USER PROG VIA .REST SETUUO
				; 'MN' - MONITOR IN CRASH CODE
				; 'HM' - HOME BLOCKS
				; 'DF' - DEFAULT
INTERN DCNDFT			;IN THAT ORDER OF PRIORITY
DCNDFT==DCN.HM!DCN.DF		; SETUP DEFAULT TO HOME-BLOCKS ! DEFAULT

SUBTTL

FILMAN:	SETOM	BATMAN		;MANDATORY CODE.
	PUSHJ	P,RDHOME	;READ HOME PAGES OF ALL UNITS.
	JRST	MANOK		;ALL OK.
	JRST	MANQST		;MINOR ERRORS.
	MOVEI	T1,[ASCIZ /
ERRORS which prevent bringing the system UP/]
MANCM1:	PUSHJ	P,CONMES
MANCOM:	PUSHJ	P,FILOPT
	JRST	FILMAN

MANREF:	MOVEI	T1,[ASCIZ /
File structure NEEDS refreshing/]
	JRST	MANCM1

MANQST:	MOVEI	T1,[ASCIZ /
MINOR ERRORS - Bring system UP anyway? /]
	PUSHJ	P,ASKQUE
	JRST	MANCOM		;NO.
MANOK:	PUSHJ	P,REDBAT	;READ THE BAT PAGES OF ALL UNITS.
	HLLZ	T1,STRDDB+STRREF
	JUMPN	T1,MANREF	;NEEDS REFRESH.


    ;HERE TO REWRITE HOME PAGES, WITH INCREMENTED PACK SET ID.
	HLRZ	U,STRDDB+STRUNI	;
	AOS	T1,RANHOM	; Increment save'd copy of HOMRAN
	TLNN	T1,-1
	JRST	.+3
	MOVEI	T1,(SIXBIT/CAT/)	;
	HRRZM	T1,RANHOM	; If zero - save sixbit CAT
	HRLM	T1,STRDDB+STRPID
	PUSHJ	P,UPDHOM	;
	HLRZ	U,UNISTR(U)	;
	JUMPN	U,.-2		;
	PUSHJ	P,SPCDKP	;GET CURRENT DC MODE AND PRIORITY
	CAIE	T3,^L<(DCN.DF)>	;IS MODE DEFAULT
	JRST	.+4		;NO, DON'T QUERY OPER FOR MODE
	MOVE	T1,STRDDB+STRBTS	;DOES STR REQUIRE
	TRNE	T1,SRPNDS	; DSKCLN TO BE RUN
	PUSHJ	P,SPCDKN	;YES, ASK OPER TO SELECT MODE
	LDB	T1,DCNYON	;GET MODE
	MOVEM	T1,DCN		; AND SAVE IT FOR DSKCLN TO GETTAB

;HERE TO READ THE RIB FOR SAT.SYS AND SET UP THE STTPTR
;ENTRIES IN STT.

	HLRZ	U,STRDDB+STRUNI	;GET THE PRIME (AND ONLY)
RDRBS1:	PUSHJ	P,GETSRB	;RIB INTO %STR.
	STOPCD
	MOVEI	P4,RIBPFS	;P4/ REL ADDR OF RETRIEVAL POINTERS.
	HLRZ	U,STRDDB+STRUNI	;

      ;HERE FOR EACH UNIT.
RDRBS2:	LDB	T4,UNYLUN	;
	HRRZ	P2,UNISTT(U)	;P2/ STT ENTRY ADDRESS.
	LDB	P3,UNYSPU	;P3/ # SATS ON THE UNIT.

      ;HERE FOR EACH SAT.
RDRBS3:	CAIG	P4,RIBLST	;MUSTN'T RUN OUT OF RIB ROOM.
	SKIPN	T1,%STR(P4)	;NOT EXPECTING EOF HERE.
	STOPCD
	TLNN	T1,RBSPAR!RBINDX ;CHECK THAT THE POINTER IN T1
	TLNN	T1,RBREAL	;IS A CORRECT POINTER.
	STOPCD
	LDB	T3,RBYUN1	;IS THIS THE UNIT
	CAME	T3,T4		;THAT WE EXPECT TO SEE?
	STOPCD
	TLZ	T1,RBMASK-RBREAL ;
	MOVEM	T1,STTPTR(P2)	;YES.  SET STTPTR.
	ADDI	P4,1		;INC PNTR TO PNTRS.
	ADDI	P2,STTLEN	;ADJUST P2 TO NEXT STT ENTRY.
	SOJG	P3,RDRBS3	;LOOP AGAIN IF MORE SATS ON THIS UNIT.
	SETZM	STTPTR(P2)	;

	HLRZ	U,UNISTR(U)	;IS THERE ANOTHER
	JUMPN	U,RDRBS2	;UNIT?
	SKIPE	%STR(P4)	;NO.  CHECK THAT EOF IS PRESENT.
	STOPCD

;NOW READ ALL THE SATS ON EACH UNIT IN THE STR, AND SET STTFPC
;IN THE SATS.

RDSATS:	SETZM	STRDDB+STRTAL	;CLEAR THE TOTAL COUNT FOR THE STR.
	HLRZ	U,STRDDB+STRUNI	;
RDSTS1:	HRRZ	P3,UNISTT(U)	;P3/PNTR INTO STT FOR THIS UNIT.
RDSTS4:	SKIPN	T2,STTPTR(P3)	;OUT OF SATS ON THIS UNIT?
	JRST	RDSTS5		;YES, GO TO NEXT UNIT.
	LDB	T4,RBYPNO	;SAT
	MOVEI	PG,%STA.P	;INTO
	PUSHJ	P,OPAGIN	;%STA.
	JRST	.+2		;ERROR ON READ.
	JRST	RDST45		;READ OKAY.
	SETZM	%STA		;PRETEND ALL F BITS IN USE,
	MOVE	T1,[XWD %STA,%STA+1] ;AND LET
	BLT	T1,%STA+377	;DSKCLN WORRY.
RDST45:	SETOM	%STA+400	;SET ALL THE
	MOVE	T1,[XWD %STA+400,%STA+401] ;M BITS
	BLT	T1,%STA+777	;FREE.
	MOVE	T1,[XWD -400,%STA] ;AOBJN PNTR FOR SATCNT.
	PUSHJ	P,SATCNT	;T4/ NO. FREE PAGES IN THIS SAT.
	MOVEM	T4,STTFPC(P3)	;
	ADDM	T4,UNITAL(U)	;
	MOVE	T2,STTPTR(P3)	;WRITE  OUT THE SAT
	LDB	T4,RBYPNO	;SO THE CLEARED M BITS
	MOVEI	PG,%STA.P	;GET
	PUSHJ	P,OPAGOT	;OUT THERE.
	STOPCD
	ADDI	P3,STTLEN	;ADJUST PNTR TO STT.
	JRST	RDSTS4

    ;COMPUTE SAFETY FACTOR FOR UNIT AND ADJUST STRTAL.
RDSTS5:	MOVE	T1,UNIPPU(U)	;COMPUTE THE SAFETY FACTOR FOR
	IDIVI	T1,UNVRSF	;THE UNIT.
	LDB	T2,UNYSPU	;
	IMULI	T1,(T2)		;
	MOVNS	T1		;
	ADDB	T1,UNITAL(U)	;ADD TO UNIT'S COUNT.
	JUMPGE	T1,.+3		;DO NOT ALLOW
	SETZM	UNITAL(U)	;UNITAL TO GO
	JRST	RDSTS6		;NEGATIVE.
	ADDM	T1,STRDDB+STRTAL ;ADJUST STRTAL.

RDSTS6:	HLRZ	U,UNISTR(U)	;
	JUMPN	U,RDSTS1	;

	HLRZ	U,STRDDB+STRUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN STR
	LDB	T3,UNYKTP	;FORM INDEX FOR TABLES
	LSH	T3,2
	LDB	T1,UNYUTP
	ADD	T3,T1
	MOVEI	T1,^D400	;COMPUTE AV. TRANSFER TIME IN JIFFIES FOR 1P.
	IDIV	T1,BKPREV(T3)
	IMUL	T1,MSPREV(T3)
	IMUL	T1,JFYSEC
	SUBI	T1,1
	IDIVI	T1,^D100000
	ADDI	T1,1
	IMULI	T1,ICPFAC	;TIMES IN CORE PROTECT TIME FACTOR
	MOVEM	T1,PROT		;SAVE FOR SWAPPER
	MOVE	T1,MSPREV(T3)	;COMPUTE AV. SEEK TIME IN JIFFIES
	LSH	T1,-1
	ADD	T1,AVSEEK(T3)
	IMUL	T1,JFYSEC
	SUBI	T1,1
	IDIVI	T1,^D1000
	ADDI	T1,1
	IMULI	T1,ICPFAC
	ADD	T1,PROT
	MOVEM	T1,PROT0	;SAVE FOR SWAPPER.
	MOVSI	T1,UNPCHG
	HLRZ	U,SYSUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN SYSTEM
	ANDCAM	T1,UNIDES(U)	;CLEAR CHANGE BIT
	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN SYSTEM
	JUMPN	U,.-2		;REPEAT IF ANY LEFT
	SKIPE	F,DDSTAR		;IF A DDB SETUP
	PUSHJ	P,CLRDDB		;THEN CLEAR IT.
	POPJ	P,		;NO - RETURN

;BLOCKS PER REVOLUTION TABLE

BKPREV:	0	;NEW DRUM
	0	;DITTO
	0
	0
	^D20	;RD10
	^D30	;RM10B
	0	;?
	0	;?
	^D5	;RP01
	^D10	;RP02
	^D10	;RP07
	^D10	;RP03
	^D11	;DUAL POSITIONER MD10
	^D11	;SINGLE POSITIONER MD10
	0	;?
	0	;?
	^D18	;3330
	0
	0
	0
	^D30	;RM03
	^D20	;RP06
	^D32	;F3
	0

;MILLESECONDS PER REVOLUTION TABLE

MSPREV:	0	;NEW DRUM
	0	;DITTO
	0
	0
	^D33	;RD10
	^D17	;RM10B
	0	;?
	0	;?
	^D25	;RP01
	^D25	;RP02
	^D25	;RP07
	^D25	;RP03
	^D50	;DUAL POSITIONER MD10
	^D50	;SINGLE POSITIONER MD10
	0	;?
	0	;?
	^D17	;3330
	0
	0
	0
	^D17	;RM03
	^D17	;RP06
	^D17	;F3
	0

;AV. SEEK TIME(MS) TABLE

AVSEEK:	0	;NEW DRUM
	0	;DITTO
	0
	0	;?
	0	;RD10
	0	;RM10B
	0	;?
	0	;?
	^D50	;RP01
	^D35	;RP02
	^D25	;RP07
	^D35	;RP03
	^D110	;DUAL POSITIONER MD10
	^D110	;SINGLE POSITIONER MD10
	0	;?
	0	;?
	^D30	;3330
	0
	0
	0
	^D30	;RM03
	^D29	;RP06
	^D30	;F3
	0


COMMENT #
@@SUBROUTINE GETSRB
@@PURPOSE
SUBR TO READ THE RIB BLOCK FOR SAT.SYS INTO %STR.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
@@ACCUM
DESTROYS
@@CALLS
RDCHEK.
@@EXIT
SKIP RETURNS IF THE PAGE READ SUCCESSFULLY.
@@ #


GETSRB:	MOVEI	T4,LPNSAT	;T4/ LOG. PAGE NO. ON UNIT.
	MOVEI	P3,CODRIB	;GET CODE WORD FOR RIB PAGES.
	MOVSI	P2,(SIXBIT .SAT.)
	MOVEI	PG,%STR.P	;
	SETOM	WHICH		;INDICATE READING FIRST (AND
	SETZM	NOERH		;ONLY) PAGE.
	PJRST	RDCHEK		;READ & VERIFY RIB PAGES.

;SOME MACROS FOR COMMAND WORK

	DEFINE SCAN (A,B) <
IFB <B>,<
PRINTX	SCANNER TABLE 'A' Has an undefined SETxM statement
>
	MOVEI	P1,SCN'A		; Get address of Scan Table
	SET'B'M	CMDSCF			; Specify NO STR/UNIT stuff
	PUSHJ	P,CMDSCN		; Call Scanning routine
	  JRST	HLP'A			; No good!
	XCT DSP'A'(P3)			; Yes?
	JRST	A'CMD			; Return as if cr typed.

A'HLP:	Move	P3,-2(P1)		; Setup AOBJN pointer for messages
A'HL1:	Hrrz	T1,(P3)			; Get address of message
	Pushj	P,LNGMES		; Print a long message
	Aobjn	P3,A'HL1		; Next?
	Jrst	A'CMD			; Return.
>

;MACRO TO MAKE SCAN TABLE
;UNI IS PLACE TO JRST TO IF UNIT
;STR IS PLACE TO JRST TO IF STR
;NAM IS TABLE NAME  Generates SCN'NAM, DSP'NAM, TXT'NAM, SIZ'NAM
; Assumes MK'NAM as the macro defining the X arguments
; JRST to NUL'NAM on <CR> and HLP'NAM on error
; Defines NAM'HLP fstandard typeout of help texts

	Extern Ab.Ack,Ab.Nak,Ab.Ver,Ab.Tcv,Ab.Cvr ; Bits - See ONCE.MAC
	DEFINE SCNTB (UNI,STR,NAM) <

	DEFINE X(SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	INS>	;INSTRUCTION TO EXECUTE

	JRST UNI		;FOR -3 RETURN
	JRST STR		;FOR -2 RETURN
	JRST NUL'NAM		;FOR -1 RETURN
DSP'NAM: MK'NAM			;GENERATE DISPATCH TABLE
	SIZ'NAM==.-DSP'NAM
	-SIZ'NAM,,TXT'NAM	;AOBJN POINTER TO HELP
	-SIZ'NAM,,SCN'NAM	;AOBJN POINTER TO NAMES
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	<SIXBIT /SYM/>>
SCN'NAM: MK'NAM			; Define Table to read

	$XZ==0			; Need a counter
	define xz$(argh)<lit$'argh==.>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	xz$(\$XZ)
Ifnb <TEXT>,<ASCIZ \TEXT'TEXT1'TEXT2'TEXT3\>
	$XZ==$XZ+1>
	MK'NAM

	$XZ==0
	define xz$(argh)<lit$'argh>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	<Xwd	Bit,xz$(\$XZ)>
	$XZ==$XZ+1>
TXT'NAM: MK'NAM

>

;P1 IS A POINTER TO THE NAMES TABLE
;The command scanning routine - Copied and munged from ONCDSK

CMDSCN:	PUSHJ	P,SETRAN	; Start number generator on any question.
	PUSHJ	P,CTEXT		; Get text (up to 6 chars) in T2
	PUSHJ	P,GETRAN	; Stop generator (KI,F3) and get number
	 JUMPE	T2,[CAIL T3,40	;  EOL?
		    POPJ P,	;NOT NULL LINE, SPC CHR
		    MOVNI P3,1	;RETURN P3=-1 FOR NULL STRING
		    JRST CPOPJ1]
	MOVE	T1,T2		;GET TEXT IN T1
	SKIPN	CMDSCF		; Skip IF we want to do UNI/STR stuff
	  Jrst	CMDSC1		; NO!  Don't Bother.
	MOVEM	U,SVU
	PUSHJ	P,FNDSTR	;IS IT A STR?
	JRST	[MOVNI P3,2	;-2 FOR STR WITH P2 TO STR BLOCK
		 JRST CPOPJ1]
	PUSHJ	P,FNDUNI	;CHECK ON UNIT
	  SKIPA			;NO
	JRST	[MOVNI P3,3	;-3 WITH U POINTING TO UNIT BLOCK
		 JRST CPOPJ1]
	MOVE	U,SVU
CMDSC1:	MOVE	P2,-2(P1)	;GET AOBJN POINTER TO HELP TABLE
	MOVE	P3,-1(P1)	;GET AOBJN POINTER TO NAME TABLE
	MOVEI	P4,0		;NOTHING SEEN SO FAR
	MOVSI	T3,770000	;MAKE A MASK
CMDSC2:	TDNE	T1,T3		; Did we type something?
	TDO	T1,T3		; If something there, set mask bits
	LSH	T3,-6		; Shift
	  JUMPN	T3,CMDSC2	; While we have more to check...
CMDSC3:	CAMN	T2,(P3)		; Compare !
	  JRST	CMDSC5		; Exact match
	Move	T3,(P2)		; Get Bits,,Text-Adr
	TLNE	T3,AB.NAK	; See if we can abbreviate it
	  JRST	CMDSC4		; No! -- Don't bother
	MOVE	T3,(P3)		;NO - CHECK MORE
	AND	T3,T1		;MASK OUT UN-TYPED STUFF
	CAME	T3,T2		;CHECK AFTER MASK
	  JRST	CMDSC4		;NO
	JUMPN	P4,[MOVEI P4,1	;SET POSITIVE FOR MULTI MATCH
		    JRST   CMDSC4]
	MOVE	P4,P3		;SAVE MATCH
CMDSC4:	Aoj	P2,		; Increment text pointer
	AOBJN	P3,CMDSC3	; Loop through the table
	SKIPL	P3,P4		;ANY MASKED MATCHES
	  POPJ	P,		;NONE OR MORE THAN 1
CMDSC5:	SUB	P3,P1		;CONVERT TO RELATIVE INDEX
	Hrrz	P2,-2(P1)	; Get AOBJN Pointer for
	Add	P2,P3		; Add offset
	Move	P2,(P2)		; Get Bits,,Text-Addr
	Skipe	CMDMSG		; See if debugging?
	  Jrst	CPOPJ1		;  Yes!  Don't bother to verify!
	TLNN	P2,AB.VER	; Should we Verify?
	  JRST	CPOPJ1		; No! Just Return "SAFE"
	TLNN	P2,AB.CVR	; Ignore verify for CONSOLE?
	  CAIA			; No.. Don't bother to check!
	SKIPN	CTYDO##		;  Setup for CTY?
	  CAIA			; No.. Keep going!
	 Jrst	CPOPJ1		; YES! Don't verify.
	TLNN	P2,AB.TCV	; Is it a TYPE/CHANGE item?
	  CAIA			; No.. Don't worry!
	SKIPL	TYPONL		;  Type ONLY?
	  CAIA			; No.. Keep going!
	 Jrst	CPOPJ1		; YES! Don't verify.
	Hrrz	T1,P2		; Get Text Address
	Pushj	P,LNGMES	; No -- Type it out.
	Movei	T1,[Asciz\

Are you SURE you want to do this? \]
	PUSHJ	P,YESNO		; A "Y" will skip, else assume NO.
	  MOVNI P3,1		; Set for null-command return
	JRST	CPOPJ1		; Always skip return.


CMDMSG:	0			; Debugging flag. 0=Type long messages.
CMDSCF:	0			; Flag for checking UNI/STR Stuff
				; 0==No checking, -1==Check!
SVP2:	0
SVU:	0

FILOPT:	MOVEI	T1,[ASCIZ /
Entering the FILES dialogue...
  Type "GO" to return to ONCE./]
	PUSHJ	P,CONOUT
	SETZM BATMAN
        SETZM EVASIZ            ;ENSURE EVMINI GETS CALLED IN EVMALC
	PUSHJ P,RDHOME
	 JFCL
	 JFCL
	PUSHJ	P,REDBAT	;READ BAT PAGES.

HLPFIL:	MOVEI T1,[ASCIZ /
  Type "HELP" for a list of options.
/]
HLPTY1:	PUSHJ P,OCONM
	PUSHJ P,OPOUT

TYPCMD:
CHGCMD:
SRPCMD:
NULFIL:
FILCMD:	MOVEI T1,[ASCIZ /
FILES* /]
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	SETOM KNOUNI
	SETOM DBLSTD
	PUSHJ P,GETLIN
	 JRST FILCMD	;NOTHING THERE
	SCAN (FIL,Z)

	DEFINE MKFIL <
	X DSKCLN,<PUSHJ P,SPCDKN>,Ab.Nak!Ab.Ver,<
DSKCLN  Query or Select DSKCLN mode.
        List the current mode and allow the operator to change it.>
	X TYPE,<JRST TYPIT>,Ab.Ack,<
TYPE    List information about the structure.
        Type "TYPE HELP" for a list of options.>
	X CHANGE,<JRST CHGIT>,Ab.Ack,<
CHANGE  Change information about the structure.
        Type "CHANGE HELP" for a list of options.>
	X ADD,<PUSHJ P,ADDUNI>,Ab.Nak!Ab.Ver,<
ADD     Add a unit to the structure.
        Reconfigure the disk structure and add another pack.>
	X DISOLVE,<PUSHJ P,STSDSL>,Ab.Nak!Ab.Ver,<
DISOLVE Disolve the structure.
        Remove all units from the system structure.>
	X DEFINE,<PUSHJ P,STSDEF>,Ab.Nak!Ab.Ver,<
DEFINE  Define a NEW structure.
        Create a completely new system structure.>
	X REFRESH,<PUSHJ P,STSREF>,Ab.Nak!Ab.Ver,<
REFRESH Refresh the structure.
        Erase the current file system and start over
        with a "FRESH" disk.>
	X GO,<JRST FILGO>,Ab.Ack,<
GO      Leave the FILES dialogue and return to the ONCE
        dialogue.>
	X HELP,<JRST FILHLP>,Ab.Ack,<
HELP    Type this message.
>
>
	SCNTB (HLPFIL,HLPFIL,FIL)

TYPIT:	SETOM TYPONL	;ONLY TYPEOUT
	SCAN (TYP,O)

NULTYP:
HLPTYP:	MOVEI T1,[ASCIZ /
Type "TYPE HELP" for a list of options.
/]
	JRST HLPTY1

	DEFINE MKTYP <
	X STR,<PUSHJ P,TYPSTR>,Ab.Nak,<
STR     Name of the STRUCTURE and UNITS on it.>
	X UNITS,<PUSHJ P,TYPUNS>,Ab.Nak,<
UNITS   Names of all units NOT in a file structure.>
	X BAT,<PUSHJ P,TYPBAT>,Ab.Nak,<
BAT     Number of BAD pages and regions for a unit.>
	X SATPCBS,<PUSHJ P,TYPSPC>,Ab.Nak,<
SATPCBS Number of SAT PCBs.>
	X RIBPCBS,<PUSHJ P,TYPRPC>,Ab.Nak,<
RIBPCBS Number of RIB PCBs.>
	X ALL,<JRST TYPALL>,Ab.Nak,<
ALL     All of the above.>
	X HELP,<JRST TYPHLP>,Ab.Ack,<
str-name  Type information about the structure.
unit-name Type information about the unit.
HELP    Type this message.
>
>
	SCNTB (TYPUIP,TYPSRP,TYP)
CHGIT:	SETZM TYPONL
	SCAN (CHG,O)
NULCHG:
HLPCHG:	MOVEI T1,[ASCIZ /
Type "CHANGE HELP" for a list of options.
/]
	JRST HLPTY1

	DEFINE MKCHG <
	X SATPCBS,<PUSHJ P,CHGSPC>,Ab.Nak!Ab.Ver,<
SATPCBS   Change the number of SAT PCBs.>
	X RIBPCBS,<PUSHJ P,CHGRPC>,Ab.Nak!Ab.Ver,<
RIBPCBS   Change the number of RIB PCBs.>
	X BAT,<PUSHJ P,CHGBAT>,Ab.Nak!Ab.Ver,<
BAT       Refresh the BAT pages for a UNIT.>
	X HELP,<JRST CHGHLP>,Ab.Ack,<
str-name  Change parameters for the structure
unit-name Change parameters for a unit.
HELP    Type this message.
>
>
	SCNTB (TYPUIP,TYPSRP,CHG)

TYPUIP:	HRRZ	P2,UNISTR(U)	;IN CASE IN FS
	MOVEM	P2,UIPSVU	;SAVE IT!
	MOVEI	P1,SCNUIP	; Get address of Scan Table
	SETOM	CMDSCF		; Specify STR/UNIT stuff
	PUSHJ	P,CMDSCN	; Call Scanning routine
	  JRST	HLPUIP		; No good!
	MOVE	P2,UIPSVU	;RESTORE in case needed.
	XCT	DSPUIP(P3)	; Yes?
	JRST	FILCMD		; Return as if cr typed.
UIPSVU:	0

UIPHLP:	Move	P3,-2(P1)	; Setup AOBJN pointer for messages
UIPHL1:	Hrrz	T1,(P3)		; Get address of message
	Pushj	P,LNGMES	; Print a long message
	Aobjn	P3,UIPHL1	; Next?
	Jrst	FILCMD		; Return.
NULUIP:
HLPUIP:	MOVEI T1,[ASCIZ /
Type "TYPE unit-name HELP" for a list of options./]
	SKIPL TYPONL
	MOVEI T1,[ASCIZ /
Type "CHANGE unit-name HELP" for a list of options./]	;WAS A CHANGE
	JRST HLPTY1

	DEFINE MKUIP <
	X ID,<PUSHJ P,UNITID>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... ID    Unit ID.>
	X HELP,<JRST UIPHLP>,Ab.Ack,<
... HELP  Type this message.
>
>
	SCNTB (HLPUIP,HLPUIP,UIP)

UNCHKA:	SKIPN UNIHID(U)
	PUSHJ P,UNITID
	PJRST	UNITST


TYPSRP:	SCAN (SRP,O)
NULSRP:
HLPSRP:	MOVEI T1,[ASCIZ /
Type "TYPE str-name HELP" for a list of options./]
	SKIPL TYPONL
	MOVEI T1,[ASCIZ /
Type "CHANGE str-name HELP" for a list of options./]
	JRST HLPTY1

	DEFINE MKSRP <
	X OVERDRAW,<PUSHJ P,STRTOV>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... OVERDRAW  The number of pages for overdraw.>
	X CRASH,<PUSHJ P,STRTCH>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... CRASH     The number of pages for CRASH.SAV.>
	X ALL,<JRST STRTPA>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... ALL       All of the ABOVE.
              The number of pages for Overdraw, for CRASH.SAV.>
	X HELP,<JRST SRPHLP>,Ab.Ack,<
... HELP      Type this message.
>
>
	SCNTB (HLPSRP,HLPSRP,SRP)

STRTPA:	PUSHJ P,STRTOV
	PUSHJ P,STRTCH
	JRST SRPCMD

;HELP INFORMATION

LNGMES:	HRLI T1,(POINT 7,0)
LNGMS1:	ILDB T3,T1
	JUMPE T3,CPOPJ
	PUSHJ P,COMTYO
	CAIE T3,12
	JRST LNGMS1
	PUSH P,T1
	PUSHJ P,OPOUT
	POP P,T1
	JRST LNGMS1

COMMENT #
@@SUBROUTINE RDHOME
@@PURPOSE
SUBR TO READ & VERIFY HOME PAGES FOR ALL UNITS AT SYSTEM
INITIALIZATION.  BUILDS THE SYSTEM STR.
SETS INFO IN THE STR DB AND IN THE UNIT DBS.
@@CALLS

@@EXIT
NON-SKIP RETURNS IF AN ERROR WAS DETECTED WHILE READING THE
HOME PAGES OF 1 OR MORE UNITS AND/OR NO STR WAS CREATED
AND/OR MORE THAN ONE STR WAS CREATED.
SKIP RETURNS IF ALL HOME PAGES THAT WERE NOT DOWN READ OK.
@@ #

RDHOME:	SETZM	DSKDDB+DEVIOS	;
	WRPI	LI.PIN		;TURN PI SYSTEM ON FOR WAITS
	SKIPE	F,DDSTAR	;IS THERE A DDB SETUP?
	PUSHJ	P,CLRDDB	;YES, CLEAR IT
	MOVE	T1,ONCDDB	;GET LOCATION OF ONCE ONLY DDB
	MOVEM	T1,DDSTAR
	PUSHJ	P,SETDDO	;CREATE A DDB FOR ONCE ONLY I/O
	 STOPCD .
	PUSH	P,STRDDB+STRBTS	;PRESERVE NEED DSKCLN FLAG.
	PUSHJ	P,CLRSTR	;INITIALLY THERE IS NO STR.
	POP	P,T3		;RESTORE THE STATE
	MOVEI	T1,SRPNDS	;OF THE NEED DSKCLN
	TDNE	T1,T3		;FLAG FOR
	IORM	T1,STRDDB+STRBTS ;THIS STR.
	SETZM	RANHOM		; Clear so pack-set id check works
	HLRZ	U,SYSUNI	;GET ADR. OF 1ST UNIT DATA BLOCK IN SYSTEM.
	JUMPE	U,RDHOM2	;
	MOVSI	T3,UNPPRV	;
RDHOM1:	IORM	T3,UNIDES(U)	;SET UNIT TO BE A PRIVATE PACK.
	HLRZ	U,UNISYS(U)	;
	JUMPN	U,RDHOM1	;
RDHOM2:	HLRZ	U,SYSUNI	;
	SETZM	ERRHOM		;CLEAR ERROR(S) WHILE READING HOME PAGES FLAG
	SETZM	ERRHM2
	TDZA	T1,T1
SCNUNI:	MOVE	T1,J		;SAVE OLD KON
	HRRZ	J,UNIKON(U)	;GET ADR. OF KONTROLLER DATA PAGE FOR THIS UNIT
	SKIPGE	KONUPA(J)	;HAS KONTROLLER BEEN FLAGGED AS DOWN?
	JRST	FLGDWN		;YES - FLAG UNIT AS DOWN ALSO
	CAMN	T1,J		;IS IT THE SAME
	JRST	KONTOK		;YES, DO NOT NEED TO TRY AGAIN
TRYKON:	PUSHJ	P,@KONUPA(J)	;SEE IF KONTROLLER IS UP
	  SKIPA	P1,UNINAM(U)	;IT'S DOWN
	JRST	KONTOK		;NOW SEE IF UNIT IS OK

;HERE IF KONTROLLER IS DOWN.
	HLLZS	P1		;GET SIXBIT KONTROLLER NAME
	MOVEI	T3,[ASCIZ .DO YOU WANT IT TO BE 1)ON-LINE, OR 2)DOWN? (TYPE #)
.]
	PUSHJ	P,MCKKON	;PRINT MSG & GET ANSWER
	  JRST	TRYKON		;ILLEGAL RESPONSE
	CAIE	T2,2		;WAS "2" TYPED?
	JRST	TRYKON		;NO - CHECK AGAIN IF "1" OR ANYTHING ELSE WAS TYPED
	MOVSI	T1,KOPDWN	;KONTROLLER DOWN BIT(SIGN BIT)
	IORM	T1,KONDWN(J)	;FLAG KONTROLLER AS DOWN
	JRST	FLGDWN		;FLAG UNIT DOWN AS WELL

;HERE IF KONTROLLER ON-LINE - TO CHECK IF UNIT OK
KONTOK:
IFCPU (F3),<	MOVSI	T1,UNPOFL
	TDNE	T1,UNIDES(U)	;IS UNIT OFF-U OR DOWN?
	JRST	SCNUN1		;YES - CONTINUE SCAN ON NEXT UNIT
>;END IFCPU (F3)
	PUSHJ	P,DSKCPY	;GET CAPACITY AND SEE IF UP
	SKIPL	T4,UNIBLK(U)
	JRST	WCKUNI		;IF POSITIVE, UNIT IS UP
	PUSHJ	P,UNTDWN

;HERE TO FLAG UNIT AS DOWN & OFF-U.
FLGDWN:	MOVEI	T2,SYSUNI-UNISYS ;SYSUNI - UNISYS
FLGDN1:	HLRZ	T1,UNISYS(T2)	;NEXT UNIT IN SYSTEM
	CAMN	T1,U		;SKIP IF NOT FOUND DOWN UNIT
	JRST	FLGDN2
	HLRZ	T2,UNISYS(T2)	;NEXT UNIT IN SYSTEM
	JUMPN	T2,FLGDN1
	JRST	FLGDN3		;NOT THERE?
FLGDN2:	HLRZ	T1,UNISYS(T1)	;LINK TO NEXT UNIT
	HRLM	T1,UNISYS(T2)	;STORE IN PREVIOUS
FLGDN3:	SKIPA	T2,U		;T2 = THIS UNIT
FLGDN4:	HLRZ	T2,UNIKON(T2)	;NEXT UNIT IN KONTROLLER RING
	HLRZ	T1,UNIKON(T2)	;NEXT BACK TO US?
	CAME	T1,U
	JRST	FLGDN4		;NO
	HLRZ	T1,UNIKON(T1)	;YES, LINK TO NEXT
	HRLM	T1,UNIKON(T2)	;STORE IN PREVIOUS
	SKIPA	T2,U		;T2 = THIS
FLGDN5:	HLRZ	T2,UNICHN(T2)	;T2 = NEXT UNIT IN CHANNEL RING
	HLRZ	T1,UNICHN(T2)
	CAME	T1,U		;BACK TO US?
	JRST	FLGDN5		;NO
	HLRZ	T1,UNICHN(T1)	;LINK TO NEXT
	HRLM	T1,UNICHN(T2)	;STORE IN PREVIOUS
	MOVSI	T1,UNPOFL	;OFF-U BIT
	IORM	T1,UNIDES(U)	;SET BIT IN LH. OF UNIDES WORD
	JRST	SCNUN1		;CONTINUE SCAN ON NEXT UNIT

;HERE IF UNIT ON-LINE - TO CHECK IF UNIT WRITE ENABLED
WCKUNI:	MOVSI T1,UNPHWP
	TDNN T1,UNIDES(U)
	TLNN T4,(1B1)		;IS IT WRITE PROTECTED?
	JRST CHKHOM		;UNIT IS OK OR HAVE BEEN HERE BEFORE
	MOVEI	T3,[ASCIZ .DO YOU WANT IT TO BE 1)WRITE-ENABLED, OR 2)WRITE-PROTECTED? (TYPE #)
.]
	PUSHJ	P,WRPUNM	;PRINT MSG & GET ANSWER
	  JRST	TRYKON		;ILLEGAL RESPONSE
	CAIE	T2,2		;WAS "2" TYPED?
	JRST	TRYKON		;NO - CHECK AGAIN IF "1" OR ANYTHING ELSE WAS TYPED
	MOVSI	T1,UNPHWP	;HARDWARE WRITE-PROTECT BIT
	IORM	T1,UNIDES(U)	;FLAG UNIT AS WRITE PROTECTED

;HERE IF UNIT ON-LINE & LEGALLY WRITE PROTECTED OR ENABLED - CHECK ITS HOME PAGES

CHKHOM:	PUSHJ	P,GETHOM	;GET HOME PAGE INTO CORE.
	  CAIA			;ERROR(S) ON BOTH HOME PAGES - T3 RETURNED NON 0.
	JRST	HMBOK		;AT LEAST ONE HOME PAGE OK
				;FORCE TO BE A NULL PAGE, NO OPTIONS
	MOVEI	T1,%HOM		;
	PUSHJ	P,CORZER	;
	MOVEM	P2,%HOM+PAGNAM	;STORE SIXBIT "HOM"
	MOVEM	P3,%HOM+PAGCOD	;STORE HOME PAGE CODE
	PUSHJ	P,SETCHG	;FLAG THAT THIS UNIT'S HOME PAGE MUST BE REWRITTEN
	PUSHJ	P,MOVUNI	;MOVE PARAMS FROM HOME PAGE TO UNIT DATA BLOCK.
	JRST	NTISTR		;

;HERE IF HOME PAGE(S) READ INTO CORE OK
; GENERATE STR DB & LINK UNIT DBS CORRECTLY.

HMBOK:	JUMPE	T3,.+2		;ERR WHILE READING HOME PAGES?
	PUSHJ	P,SETCHG	;YES. FLAG THEY NEED REWRITING.
	PUSHJ	P,MOVUNI	;MOVE PARAMS FROM HOME PAGE TO UNIT DB
	MOVEI	P2,0		;SET STR DB ADR. = 0 IN CASE NO STR FOUND
	MOVE	T1,%HOM+HOMSNM	;GET STR NAME FROM HOME PAGE.
	JUMPE	T1,NTISTR	;DON'T LOOK FOR OR CREATE A ZERO STR NAME.
HMBOK2:	PUSHJ	P,FNDSTR	;DOES THIS STR EXIST?
	JRST	NOTPRV		;YES. UNIT IS NOT A PRIVATE PACK.
	SKIPE	STRNAM(P2)	;NO, DOES ANY STR EXIST?
	JRST	NOSTR		;YES, ONLY ONE STR IS LEGAL. DIE.
				;NO, THIS IS THE SYSTEM STR.
	PUSHJ	P,MOVSTR	;MOVE PARAMS FROM HOME PAGE TO STR DB.
	MOVE	T2,REONCE	;GET ONCE COPY OF RESTRT WORD
	TLZ	T2,DCN.UR!DCN.MN	;IN CASE STR IS MODIFIED
	HRRZ	T1,%HOM+HOMRAN	;GET PACK SET ID
	CAME	T1,REPSID	;HAS NEW PACK SET BEEN MOUNTED?
	JRST	HMBOK3		;YES: IGNORE RESTRT
	SETZ	T1,		;ZERO DSKCLN TYPE SPEC FLAG WORD
	TRNE	T2,RE.DCD	;DID USER SELECT A DSKCLN TYPE?
	TLO	T1,DCN.UR	;YES: SO INDICATE
	TLO	T1,DCN.MN	;IND MON SELECTED A DSKCLN TYPE
	IORM	T1,DCN
HMBOK3:	MOVE	T1,%HOM+HOMDCT	;INITIALIZE FOR VERIFICATION OF
	DPB	T1,DCNYHM	; HOME BLOCK DSKCLN TYPE VALIDITY
NOTPRV:	PUSHJ	P,SETPUB	;SET THE UNIT PUBLIC.

    ;HERE WHEN STR UNIT BELONGS IN EXISTS
OLDSTR:	JUMPE	P2,OLDST8	;SKIP OVER RAN & HSH CHK IF NO STR.
	LDB	T1,DCNYHM	;SET UP TO VERIFY THAT HOME
	HRLI	T1,HOMDCV	; DSKCLN TYPE IS VALID/CONSISTENT
	HRLZI	T2,DCN.HM
	CAME	T1,%HOM+HOMDCT	;IS TYPE GOOD?
	ANDCAM	T2,DCN		;NO: SO INDICATE
	HLRZ	T1,%HOM+HOMHSH	;T1/ UNIT'S HASH CONSTANT.
	JUMPE	T1,OLDST1	;MUST BE NON-ZERO.
OLDST2:	HRRZ	T2,STRHSH(P2)	;T2/ STR'S HASH CONSTANT SET
	JUMPN	T2,.+3		;YET?
	HRRM	T1,STRHSH(P2)	;NO, JUST STORE FIRST FOUND.
	JRST	OLDST4		;GO TO RAN LOOK.
	CAIN	T1,(T2)		;YES, BETTER MATCH OTHERS'.
	JRST	OLDST4		;OKAY.
OLDST1:	MOVEI	T1,[ASCIZ /MISSING OR INCONSISTENT HASH CONSTANT FOR UNIT /]
	PUSHJ	P,MSGUNI	;
OLDST4:	HRRZ	T1,%HOM+HOMRAN	;T1/ UNIT'S PACK SET ID.
	JUMPE	T1,OLDST5	;CAN'T BE ZERO.
OLDST6:	SKIPE	T2,RANHOM	;ALREADY SEEN ID?
	JRST	.+3		;YES.
	HRRZM	T1,RANHOM	;NO, JUST STORE FIRST FOUND.
	JRST	OLDST8		;
	CAIN	T1,(T2)		;YES, BETTER MATCH OTHERS'.
	JRST	OLDST8		;OKAY.
OLDST5:	MOVEI	T1,[ASCIZ /MISSING OR INCONSISTENT PACK SET ID FOR UNIT /]
	PUSHJ	P,MSGUNI	;
OLDST8:	

	JUMPE	P2,NTISTR	;IF UNIT NOT IN STR, JUMP OVER THIS.
	LDB	T2,UNYLUN	;GET LOGICAL UNIT # WITHIN STR
	SKIPE	%HOM+HOMNXT	;IS THIS LAST UNIT IN STR?
	JRST	NLSUNI		;NO - GO LINK UNIT DATA BLOCK INTO STR
	HRRZ	T1,STRUNM(P2)	;HAVE WE ALREADY SEEN A LAST UNIT FOR THIS STR?
	JUMPE	T1,LSTUNI	;NO - NOW WE HAVE
	PUSH	P,T2		;SAVE LOG. UNIT #
	MOVEI	T1,[ASCIZ .
MORE THAN ONE LAST UNIT IN STR .]
	PUSHJ	P,MSGSTR	;PRINT MSG FOLLOWED BY SIXBIT STR NAME
	POP	P,T2		;RESTORE LOG. UNIT #

;HERE WHEN UNIT READ IS THE LAST IN A STR.

LSTUNI:	ANDI	T2,77		;MAX. OF 64 UNITS IN STR!!!!!!!
	HRRM	T2,STRUNM(P2)	;STORE LOG. # OF LAST UNIT IN STR
	AOS	STRUNM(P2)	;LEAVE T2 ALONE BUT MAKE MEMORY OK

;HERE WHEN UNIT READ ISN'T LAST IN THE STR
; LINK UNIT TO STR & OTHER UNITS IN STR

NLSUNI:	MOVEI	T4,STRUNI(P2)	;GET ADR. OF LINK TO 1ST. UNIT DATA BLOCK IN STR
	JRST	LINKT1
LINKIT:	LDB	T3,UNYLN1	;YES - GET LOG. UNIT # OF NEXT UNIT
	CAMLE	T3,T2		;IS IT GREATER THAN UNIT JUST READ?
	JRST	INSERT		;YES - INSERT UNIT DATA BLOCK HERE
	MOVEI	T4,UNISTR(T1)	;GET ADR. OF LINK TO NEXT UNIT
LINKT1:	HLRZ	T1,(T4)		;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	T1,LINKIT	;MORE DATA BLOCKS?
INSERT:	HRLM	T1,UNISTR(U)	;SAVE LINKS TO STR & NEXT UNIT DATA BLOCK
	HRRM	P2,UNISTR(U)	; IN THIS UNIT DATA BLOCK
	HRLM	U,(T4)		;SAVE THIS UNIT ADR. IN PREVIOUS UNIT DATA BLOCK
				; (OR STR DATA BLOCK)
	JRST	CRESTT		;TRY & SETUP SAB RING & SPT TABLE FOR THIS UNIT

NOSTR:	MOVEI T1,[ASCIZ /
TOO MANY STR'S /]
	PUSHJ P,OCONM
	MOVE	T2,%HOM+HOMSNM
	PUSHJ P,NAMFLO
	STOPCD



NTISTR:	SETZM	UNILOG(U)	;INDICATE UNIT NOT IN A STR.

;HERE TO CREATE STT TABLE FOR THIS UNIT.
;(EVEN IF NOT IN STR, MAY ADD TO STR LATER.).

CRESTT:	PUSHJ	P,SPUCLC	;CALC NO. SATS ON UNIT.
	LDB	P3,UNYSPU	;
	IMULI	P3,STTLEN	;COMPUTE LENGTH OF
	ADDI	P3,1		;STT TABLE.
	MOVE	T2,P3		;GET TOTAL NO. OF WORDS NEEDED
	PUSHJ	P,EVMALC##	;FOR STT 
	HRRM	T1,UNISTT(U)	;STORE ADR OF STT IN UNIT DB.
	SETZM	(T1)		;
	HRLZI	T2,(T1)		;BUILD A
	HRRI	T2,1(T1)	;BLT AC.
	ADDI	T1,-1(P3)	;ADR OF LAST WORD IN STT TABLE.
	BLT	T2,(T1)		;CLEAR THE STT.

SCNUN1:	HLRZ	U,UNISYS(U)	;GET NEXT UNIT DB ADR IN SYSTEM.
	JUMPN	U,SCNUNI	;AROUND AGAIN IF ANY LEFT




    ;HERE TO CREATE UNTTBL.
	SETZM	UNTTBL		;CLEAR OUT
	HRLI	T1,UNTTBL	;ALL
	HRRI	T1,UNTTBL+1	;OF
	BLT	T1,UNTTBL+UNTLEN-1 ;UNTTBL.

	HLRZ U,SYSUNI		;GET SET TO GENERATE UNTTBL
	MOVEI T1,UNTLEN-1
SETUNT:	JUMPE U,SCNSTR	;DONE
	SKIPE UNILOG(U)		;IS IT IN A STR?
	JRST SETUTS		;YES
	MOVEM U,UNTTBL(T1)
	DPB T1,UNYLUN
	HLRZ U,UNISYS(U)
	SOJA T1,SETUNT		;AND GO

SETUTS:	LDB T2,UNYLUN
	MOVEM U,UNTTBL(T2)
	HLRZ U,UNISYS(U)
	JRST SETUNT

;HERE WHEN ALL UNITS IN SYSTEM HAVE TRIED TO BE READ &
; THE STR DATA BLOCK HAS BEEN CREATED IF IT CAN BE.  NOW
; CHECK THAT ALL UNITS THAT SHOULD BE ARE PRESENT IN THE STR.

SCNSTR:	MOVEI	P2,STRDDB	;GET ADR. OF STR DATA BLOCK.
	SKIPN	STRNAM(P2)	;IS THERE A STR?
	JRST	SCNSTD		;NO, NON-SKIP RETURN
	HRRZ	T1,STRUNM(P2)
	JUMPN	T1,LSTRED	;WAS THE LAST UNIT IN THIS STR FOUND?
	MOVEI	T1,[ASCIZ .
LAST UNIT WASN'T FOUND IN STR .]
	PUSHJ	P,MSGSTR	;NO - PRINT MSG. FOLLOWED BY SIXBIT STR NAME
	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN STR
	JRST	.+2		;
SCNST2:	MOVE	U,T1
	HLRZ	T1,UNISTR(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	T1,SCNST2	;REPEAT UNTIL LAST ONE FOUND
	LDB	T1,UNYLUN	;GET ITS LOG. UNIT # IN STR
	ADDI	T1,1		;MAKE INTO # UNITS IN STR
	HRRM	T1,STRUNM(P2)	; & STORE IT

;HERE TO CHECK FOR THE PRESENCE OF ALL UNITS BUT THE LAST IN A STR.

LSTRED:	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN THIS STR
	SETOM	P4		;SETUP FAKE PREVIOUS LOG. UNIT #
CHKUNI:	LDB	P1,UNYLUN	;GET LOG. UNIT # OF THIS UNIT WITHIN STR
	EXCH	P1,P4		;PUT THIS & PREVIOUS LOG. UNIT #'S IN PROPER ACS
	CAME	P4,P1		;ARE LOG. UNIT #'S THE SAME?
	JRST	MISUNI		;NO - CHECK FOR MISSING UNITS
	MOVEI	T3,[ASCIZ .
TWO LOGICAL UNIT .]
	MOVEI	T1,[ASCIZ .'S FOUND IN STR .]
	PUSHJ	P,MSGLNG	;PRINT MSGS FOLLOWED BY SIXBIT STR NAME
	JRST	CHKUN1		;CHECK NEXT PAIR OF UNITS

MISUNI:	CAIN	P4,1(P1)	;IS THIS UNIT 1 GREATER THAN LAST ONE?
	JRST	CHKUN1		;YES - CHECK NEXT PAIR OF UNITS
	ADDI	P1,1		;INCREMENT TO GET CORRECT MISSING LOG. UNIT #
	MOVEI	T3,[ASCIZ .
LOGICAL UNIT .]
	MOVEI	T1,[ASCIZ . MISSING FROM STR .]
	PUSHJ	P,MSGLNG
	JRST	MISUNI		;REPEAT UNTIL ALL MISSING ARE TYPED OUT

CHKUN1:	HLRZ	U,UNISTR(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	U,CHKUNI
	JRST	SCNSD2

;HERE WHEN THROUGH CHECKING ALL UNITS WITHIN A STR.

SCNSTD:	MOVEI	T1,[ASCIZ .
?NO SYSTEM STRUCTURE.]
	PUSHJ	P,SVMOT2	;NO, TYPE MESSAGE
SCNSD2:	SKIPE	ERRHOM		;ANY ERRORS?
	AOS	(P)		;NO - SKIP RETURN
	SKIPE ERRHM2
	AOS (P)
	POPJ	P,

ERRHOM:	0			;FLAG FOR ERRORS WHILE READING A HOME PAGE.
ERRHM2:	0			;"BAD" ERROR DETECTED.

RANHOM:	Z			; Holds PACK-SET ID info (random #)

WRPUNM:	MOVEI	T4,[ASCIZ . IS WRITE PROTECTED.]

	MOVE	P1,UNINAM(U)	;GET SIXBIT UNIT NAME
	MOVEI	T1,[ASCIZ .
.]
	PJRST	NASTYP		;TYPE MSGS. & GET USER'S RESPONSE

;SUBROUTINE TO PRINT "CONTROLLER" FOLLOWED BY A "NAME" FOLLOWED BY "IS OFF-U"
; FOLLOWED BY A MESSAGE ASKING WHAT STATE OF THE KONTROLLER IS DESIRED
; THEN IT WAITS FOR OPERATOR TO TYPE AN OCTAL NUMBER TERMINATED BY CRLF
;CALL	MOVE	P1,SIXBIT KONTROLLER NAME
;	MOVEI	T3,MSG. ADR.
;	PUSHJ	P,MCKKON
;	  ERROR RETURN	MSG. PRINTED BUT RESPONSE WASN'T AN OCTAL #
;	OK RETURN	 "      "    T2 CONTAINS OCTAL # TYPED

MCKKON:	MOVEI	T1,[ASCIZ .
.]
	MOVEI	T4,[ASCIZ . IS OFF-LINE.]
NASTYP:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	PUSH	P,T3		;SAVE 2ND. MSG ADR.
	PUSH	P,T4		;SAVE 1ST. MSG. ADR.
	PUSHJ	P,OCONM		;PUT MSG IN BUFFER
	MOVE	T2,P1		;GET UNIT/KONTROLLER SIXBIT NAME
	PUSHJ	P,PRNAME	;PUT IT IN BUFFER
	POP	P,T1		;RESTORE 1ST. MSG. ADR.
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	PUSHJ	P,CRLFOP	;ADD CRLF & O/P MSG.
	POP	P,T1		;RESTORE 2ND. MSG ADR.
	PUSHJ	P,CONOUT	;O/P MSG. & ADD CRLF
	PUSHJ	P,GETLIN	;GET USER'S RESPONSE
	  POPJ	P,		;CR TYPED
	PUSHJ	P,OCTIN		;READ IT AS AN OCTAL NO.
	  POPJ	P,		;NOTHING BUT A BREAK CH.
	  POPJ	P,		;ILLEGAL CH.
	JRST	CPOPJ1		;OK RETURN WITH NO. IN T2

UNTDWN:	JSP T2,SVOTAC
IFKMC<
	MOVE T1,UNIBLK(U)
	CAIGE T1,4		;IF NO RESPONSE DON'T GIVE MESSAGE
	  POPJ P,
>;END.IFKMC
	MOVEI T1,[ASCIZ .
.]
	PUSHJ P,CONMES
	MOVE T2,UNINAM(U)
	PUSHJ P,PRNAME
	MOVEI T1,[ASCIZ . IS OFF-LINE.]
	PUSHJ P,CONOUT
	MOVE T1,UNIBLK(U)
	SKIPE T1,OFLTAB(T1)
	PJRST CONOUT
	POPJ P,

	%%ZZQ==.
OFLTAB:	PHASE 0
	0
%OFLER:! [ASCIZ /HARDWARE ERROR INDICATIONS ON DRIVE/]
%OFLFM:! [ASCIZ /INCORRECTLY FORMATTED PACK ON DRIVE/]
%OFLMT:! [ASCIZ /DRIVE IN MAINT. MODE/]
%OFLRS:! [ASCIZ /NO RESPONSE ON DRIVE/]
	PHASE .+%%ZZQ

INTERNAL %OFLER,%OFLFM,%OFLMT,%OFLRS

COMMENT #
@@SUBROUTINE FNDSTR
@@PURPOSE
SUBR TO SET UP THE STR DB ADDRESS IN P2 IF THE STR HAS THE
SIXBIT NAME IN T1.
@@ENTRY
EXPECTS SIXBIT STR NAME IN T1.
@@ACCUM
DESTROYS T1 AND P2.
@@EXIT
NON-SKIP RETURNS ONLY IF THE SYSTEM STR HAS BEEN SET UP AND IT
HAS THE NAME IN T1.  ELSE SKIP RETURNS.
@@ #

FNDSTR:	MOVEI	P2,STRDDB	;GET ADDR OF STR DB TO P2.
	TRZ	T1,7777		;STR NAMES ARE A MAX OF 4 CHARS.
	CAME	T1,STRNAM(P2)	;
	AOS	(P)		;
	POPJ	P,

;SUBROUTINE TO MOVE PARAMETERS FROM HOME PAGE TO UNIT DATA BLOCK

MOVUNI:	MOVE	T1,%HOM+HOMLOG
	MOVEM	T1,UNILOG(U)
	MOVE	T1,%HOM+HOMHID
	MOVEM	T1,UNIHID(U)
	MOVE	T1,%HOM+HOMLUN
	DPB	T1,UNYLUN
	MOVE	T1,%HOM+HOMSPU
	DPB	T1,UNYSPU
	MOVSI	T2,UNPMSB
	ANDCAM	T2,UNIDES(U)
	CAIE	T1,1
	IORM	T2,UNIDES(U)
	POPJ	P,

;SUBROUTINE TO MOVE PARAMETERS FROM HOME PAGE TO STR DB.

MOVSTR:	MOVE	T1,%HOM+HOMSNM
	MOVEM	T1,STRNAM(P2)
	MOVE	T1,%HOM+HOMP4C
	MOVEM	T1,STRP4C(P2)
	MOVE	T1,%HOM+HOMMFD	;SAVE RETRIEVAL
	TLO	T1,RBREAL	;POINTER TO
	MOVEM	T1,MFDRIB	;MFD (IT'S ON UNIT 0).
	MOVE	T1,UNIPPU(U)
	CAMLE	T1,STRPPU(P2)
	MOVEM	T1,STRPPU(P2)
	MOVE	T1,%HOM+HOMOVR
	MOVEM	T1,STROVR(P2)
	MOVE	T1,%HOM+HOMREF
	HLLM	T1,STRREF(P2)
	POPJ	P,

MSGLNG:	JSP	T2,REFSAV	;SAVE P4,T3,F,U & J AND INDICATE STR NEEDS REFRESHING
	PUSH	P,T1		;SAVE 2ND. MSG ADR. IN T1
	MOVE	T1,T3		;GET ADR OF 1ST. MSG
	PUSHJ P,CLRSND
	PUSHJ	P,TYPDEC	;PUT MSG. & UNIT # IN BUFFER
	PUSHJ	P,OPOUT		;O/P BUFFER
	POP	P,T1		;RESTORE 2ND. MSG ADR.
	CAIA

MSGSTR:	JSP	T2,REFSAV	;SAVE P4,T3,F,U & J AND INDICATE STR NEEDS REFRESHING
	PUSHJ	P,OCONM		;PUT MSG. IN BUFFER
	SETOM	ERRHOM		;INDICATE ERROR IN "RDHOME"
	SETOM ERRHM2		;"BAD" ERROR
	MOVE	T2,STRNAM(P2)	;GET SIXBIT STR NAME
NAMFLO:	PUSHJ	P,PRNAME	;PUT IT IN THE BUFFER FOLLOWED BY CRLF & START O/P
	PJRST	CRLFOP


MSGUNI:	JSP	T2,REFSAV
	PUSH	P,UNINAM(U)
	PUSHJ	P,OCONM
	SETOM	ERRHOM
	SETOM	ERRHM2
	POP	P,T2
	PJRST	NAMFLO

COMMENT #
@@SUBROUTINE GETHOM
@@PURPOSE
SUBR TO TRY TO READ BOTH OF A UNIT'S HOME PAGES SUCCESSFULLY
INTO %HOM.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS IF AT LEAST ONE OF THE PAGES READ SUCCESSFULLY.
@@ #

GETHOM:	MOVSI	P2,(SIXBIT .HOM.)
	MOVEI	P3,CODHOM	;CODE WORD FOR HOME PAGES.
	MOVE	P4,[XWD LPNHOM,LP2HOM]	;P4/ NO. 1ST PAGE,,2ND PAGE.
	MOVEI	PG,%HOM.P
	PJRST	RDBOTH		;READ & VERIFY HOME PAGES.




COMMENT #
@@SUBROUTINE GETBAT
@@PURPOSE
SUBR TO TRY TO READ BOTH OF A UNIT'S BAT PAGES SUCCESSFULLY
INTO %BAT.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS IF AT LEAST ONE OF THE PAGES READ SUCCESSFULLY.
@@ #

GETBAT:	PUSHJ	P,SETBAT	;
	PJRST	RDBOTH		;




COMMENT #
@@SUBROUTINE SETBAT
@@PURPOSE
LITTLE SUBR TO SET UP SOME PARAMETERS FOR HANDLING BAT PAGES.
@@ #

SETBAT:	MOVSI	P2,(SIXBIT .BAT.)
	MOVEI	P3,CODBAT
	MOVE	P4,[XWD LPNBAT,LP2BAT]
	MOVEI	PG,%BAT.P	;
	POPJ	P,

COMMENT #
@@SUBROUTINE RDBOTH
@@PURPOSE
SUBROUTINE TO READ SPECIAL REDUNDANT PAGES ON THE DISK (HOME
AND BAT) INTO CORE.
@@ENTRY
EXPECTS U/ UNIT DB, P2/ SIXBIT BAT, HOM, OR SAT, P3/ AP-
PROPRIATE CODE WORD FOR PAGES, P4/ PAGE NO. ON THE
DISK OF 1ST PAGE,, 2ND PAGE, AND PG/ PCB ADDRESS.
PRINTS NO ERROR MESSAGES IF NOERH <>0.
@@ACCUM
DESTROYS
@@CALLS
RDCHEK.
@@EXIT
NON-SKIP RETURNS ONLY IF BOTH PAGES ARE BAD.
T3/ 0 IF NO ERRORS, O'E LH(T3)<>0 IF ERROR ON 1ST PAGE AND
RH(T3)<>0 IF ERROR ON 2ND PAGE.
S=0 IF NO ERRORS, ELSE S HAS THE STANDARD RH ERROR BITS SET.
NOERH = 0 ON EXIT.
@@ #

RDBOTH:	MOVE	F,DDSTAR	;F/ DDB.
	SETZM	REDERR		;CLEAR ERR FLAG FOR BOTH PAGES.
FIROK:	SETOM	WHICH		;INDICATE READING 1ST PAGE.
	HLRZ	T4,P4		;T4/ DISK PAGE NO.
	PUSHJ	P,RDCHEK	;READ PAGE & CHECK FOR ERRORS.
	JRST	REDSEC		;ERR DETECTED - GO TRY 2ND PAGE.
	JUMPG	T3,RDBSKP	;NO ERR. JUMP TO SUCCESS IF WE
				;ARE HERE FROM A BAD 2ND PAGE.

REDSEC:	SETZM	WHICH		;INDICATE READING 2ND PAGE.
	HRRZ	T4,P4		;T4/ DISK PAGE NUMBER.
	PUSHJ	P,RDCHEK	;READ PAGE & CHECK FOR ERRORS.
	JUMPL	T3,RDBNON	;ERROR(S) DETECTED.  IF ON 1ST
				;PAGE AS WELL, GIVES ERR RETURN.
	JUMPG	T3,FIROK	;IF 2ND BAD 1ST OK GO RETRY 1ST.
RDBSKP:	AOS (P)			;SET FOR SKIP RETURN.
RDBNON:	SETZM NOERH		;CLR NO ERR MSG FLAG.
	POPJ P,

COMMENT #
@@SUBROUTINE RDCHEK
@@PURPOSE
SUBR CALLED BY RDBOTH AND OTHERS TO READ A SPECIAL PAGE
INTO CORE AND CHECK FOR ERRORS.
@@ENTRY
EXPECTS  T4/ PAGE NO. ON UNIT, F/ FILE DB, PG/ PCB ADDRESS,
U/ UNIT DB, P2/ SIXBIT BAT, HOM, OR
SAT, AND P3/ CODE WORD FOR PAGES.
WHICH <>0 FOR FIRST PAGE, =0 FOR 2ND.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@CALLS
OPAGIN AND RDWMSG.
@@ACCUM
DESTROYS
@@EXIT
FOR 1ST PAGE, LH(T3)=0 UNLESS ERROR, IN WHICH CASE LH(T3)<>0.
FOR 2ND PAGE, RH(T3)=0 UNLESS ERROR, IN WHICH CASE RH(T3)<>0.
NON-SKIP RETURN IF ERROR, ELSE SKIP-RETURN.
IF NO ERROR, S=0 ELSE S HAS RH ERROR BITS SET.
@@ #

RDCHEK:	SETZM	CHKFLG		;CLR FLG FOR USE OF RDCHEK ONLY
				;(NEEDED SINCE S ACCUMULATES.).
	PUSHJ	P,OPAGIN	;READ THE PAGE.
	SKIPA	T3,UNINAM(U)	;ERROR	- GET SIXBIT UNIT NAME.
	JRST	CONCHK		;GO MAKE CONSISTANCY CHECKS.
IFCPU (KI),<DATAO	PI,UNIERR(U)>	;FLASH OPER WITH KONT. STATUS.
	MOVEI	T1,[ASCIZ . PAGE HARDWARE READ ERROR.]
	PUSHJ	P,RDWMSG	;PRINT ERROR MSG. FOR PAGE TYPE.
	SETOM	CHKFLG		;SAW ERROR ON THIS PAGE.
CONCHK:	PUSHJ	P,GETPEV	;GET VIRTUAL ADDR FOR PCB IN PG IN T2
	CAMN	P2,[SIXBIT /SAT/] ;READING SAT.SYS RIB PAGE?
	CAME	P2,RIBNAM(T2)	;YES. NAME IN RIB = 'SAT'?
	CAMN	P2,PAGNAM(T2)	;NO - CHECK BLOCK NAME(THIS ALWAYS FAILS WITH RIB)
	CAME	P3,PAGCOD(T2)	;OK - CHECK CODE WORD
	SKIPA	T3,UNINAM(U)	;NO CHECK - GET SIXBIT UNIT NAME
	JRST	TSTCHK		;EXIT CHECKING ERRORS ON THE WAY
	MOVEI	T1,[ASCIZ . PAGE CONSISTENCY ERROR.]
	PUSHJ	P,RDWMSG	;PRINT ERROR MSG. FOR PAGE TYPE
	SETOM	CHKFLG		;SAW ERROR ON THIS PAGE.
TSTCHK:	MOVE	T3,REDERR	;ERR WRD FOR CHECKING BY CALLER.
	SKIPN	CHKFLG		;SKIP RETURN IF
	AOS	(P)		;NO ERRORS.
	POPJ	P,

CHKFLG: Z	;FLAG FOR USE BY RDCHEK ONLY.

COMMENT #
@@SUBROUTINE WTBOTH
@@PURPOSE
SUBR TO WRITE SPECIAL REDUNDANT PAGES TO THE DISK (HOM
AND BAT) FROM CORE.
@@ENTRY
EXPECTS F/ FILE DB, U/ UNIT DB, P4/ PAGE NO. ON
DISK OF 1ST PAGE,, 2ND PAGE, AND PG/ PCB ADDRESS.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@ACCUM
DESTROYS
@@CALLS
OPAGOT AND RDWMSG.
@@EXIT
RETURNS WITH S = 0 IF NO ERRORS. OTHERWISE S HAS STANDARD
RH ERROR BITS SET.
T3/ 0 IF NO ERRORS, OTHERWISE RH(T3)<>0 IF ERROR ON 2ND PAGE 
AND LH(T3)<>0 IF ON 1ST PAGE.
@@ #

WTBOTH:	SETZM	REDERR		;CLR ERR SWITCH FOR BOTH PAGES.
	SETOM	WHICH		;INDICATE WRITING 1ST PAGE.
	PUSHJ	P,GETPEV	;GET VIRTUAL ADDRESS OF DATA FROM C(PG)
	MOVE	P1,T2		;GET IN MORE PERMANENT PLACE THAN T2

WRTRN1:	LDB T1,UNYLUN	;ALSO WORKS FOR ONES NOT IN STR
	MOVSI	T2,RBREAL	;
	DPB	T1,RBYUNI	;
	HLRZ	T4,P4		;
	DPB	T4,RBYPNO	;
	MOVEM	T2,PAGSLF(P1)	;
	HRLZS	P4		;SETUP P4 FOR PAGE #2.
	PUSHJ	P,WTCHEK	;GO WRITE OUT PAGE.
	SETZM	WHICH		;INDICATE WRITING 2ND PAGE.
	JUMPN	P4,WRTRN1	;HAVE WE WRITTEN BOTH PAGES?
	SKIPN	T3,REDERR	;ERR WRD FOR CHECKING BY CALLER.
	AOS	(P)		;SKIP RETURN IF NO ERRORS.
	POPJ	P,		;

WTCHEK:	PUSHJ	P,OPAGOT	;TRY TO WRITE THE PAGE.
	JRST	.+2		;ERRORS.
	POPJ	P,		;WON.
IFCPU (KI),<DATAO	PI,UNIERR(U)>	;FLASH OP. WITH ERROR STATUS
	MOVEI	T1,[ASCIZ .HARDWARE WRITE ERROR.]
	MOVE	T3,UNINAM(U)	;PICK UP UNIT NAME AND PRINT
	PUSHJ	P,RDWMSG	;ERROR MSG. FOR PAGE TYPE.
	POPJ	P,

COMMENT #
@@SUBROUTINE RDWMSG
@@PURPOSE
SUBR TO PRINT ERROR MSG. FOR RDCHEK AND WTCHEK, AND TO SET
REDERR APPROPRIATELY.
(REDERR IS AN INTERNAL FLAG FOR RDBOTH AND WTBOTH.).
@@ENTRY
EXPECTS T1/ MSG. ADR. AND T3/ SIXBIT UNIT NAME.
IF NOERH <>0, DOES NOTHING AND RETURNS IMMEDIATELY.
@@ACCUM
DESTROYS
@@CALLS
SVOTAC, CLRSND, PRNAME, CONMES, AND CRLFOP.
@@EXIT
RETURNS LH. OR RH. OF REDERR = -1, DEPENDING ON WHETHER 1ST
OR 2ND PAGE, RESPECTIVELY, HAS ERROR.
@@ #

RDWMSG:	SKIPE	NOERH
	POPJ	P,		;DO NOT PRINT ERR MSG.
	JSP	T2,SVOTAC	;SAVE T3,F,U & J
	PUSH	P,PG		;SAVE PG.
	PUSH	P,T1		;SAVE ADDR OF MESSAGE
	PUSHJ	P,CLRSND
	MOVE	T2,T3		;SIXBIT UNIT NAME
	PUSHJ	P,PRNAME	;PUT NAME IN BUFFER
	MOVEI	T1,[ASCIZ . FIRST .] ;PRESUME ERROR ON 1ST PAGE.
	SKIPE	WHICH		;2ND. PAGE WAS READ?
	JRST	FSTERR		;NO - 1ST. PAGE.
	HLLOS	REDERR		;INDICATE ERROR ON 2ND. PAGE.
	SKIPA	T1,[[ASCIZ . SECOND .]]
FSTERR:	HRROS	REDERR		;INDICATE ERROR ON 1ST. PAGE.
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	MOVE	T2,P2		;GET SIXBIT PAGE TYPE(HOME OR "BAT")
	CAMN	P2,[SIXBIT .SAT.] ;IF THIS WAS A RIB PAGE
	MOVSI	T2,(SIXBIT .RIB.) ; TYPE RIB INSTEAD OF "SAT"
	PUSHJ	P,PRNAME	;PUT IT IN BUFFER
	POP	P,T1		;ADDR OF MESSAGE
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	PUSHJ	P,CRLFOP	;CRLF AND TYPE MESSAGE
	POP	P,PG		;RESTORE PG.
	POPJ	P,

REDERR:	0			;ERR WORD FOR RDBOTH AND WTBOTH.
				; RH=-1 IF ERROR ON 2ND. PAGE,
				; LH "  "    "   "  1ST.   "
WHICH:	0			;FLAG TO INDICATE WHETHER 2ND
				;OR 1ST PAGE BEING READ.

NOERH:	0			;FLAG TO NOT PRINT ERROR FROM UPDHOM.

COMMENT #
@@SUBROUTINE OPAGIN/OPAGOT
@@PURPOSE
ONCE-TIME SUBR TO READ OR WRITE A PAGE.
@@ENTRY
ENTRY POINT OPAGOT IS TO WRITE A PAGE, ENTRY POINT OPAGIN IS TO
READ A PAGE.
EXPECTS U/ UNIT DB, T4/ PAGE NUMBER ON THE UNIT,
PG/ ONCE-TIME PCB ADDRESS, AND F/ DDB.
@@ACCUM
DESTROYS T1-T4 AND S.
@@EXIT
SKIP RETURNS IF NO ERRORS, ELSE NON-SKIP RETURNS AND T3 HAS
THE PGYERR BITS.
@@ #

    ;HERE TO READ A PAGE.
OPAGIN:	MOVEI	T3,PAGIN	;FILIO SUBR TO CALL.
	MOVEI	T1,STDREA
	JRST	OPAGIO

    ;HERE TO WRITE A PAGE.
OPAGOT:	MOVEI	T3,PAGOUT	;FILIO SUBR TO CALL.
	MOVEI	T1,STDWRT

OPAGIO:	PUSH	P,PG		;SAVE PG.
	MOVE	T2,PG		;SET UP T2/ PCB ADDR AND
	DPB	T1,PCISTS	;SET FLAG FOR INTRPT LEVEL.
	HLRZ	PG,PCBPAG(T2)	;PG/ IN-CORE PAGE NUMBER.
	SETZ	T1,		;CLEAR ANY
	DPB	T1,PGYERR	;ERROR BITS.
	PUSHJ	P,OHTINI	;CLEAR OUT ALL OUTPUT ERRORS (SHOULD BE 1 AT THE MOST.)
	DPB	T4,PGYPNO	;SET THE "UNIT NUMBER" AND
	LDB	T1,UNYLUN	;PAGE NUMBER IN PGYADR.
	CAME	U,UNTTBL(T1)	;STRANGE CROCK TO
	MOVEM	U,UNTTBL(T1)	;HELP SWPENQ AND FINPCB, WHICH
	DPB	T1,PGYUNI	;EXPECT UNTTBL TO BE SET UP.
	PUSH	P,T2		;SAVE PCB ADDR.
	PUSHJ	P,(T3)		;CALL PAGIN OR PAGOUT.
	POP	P,T2		;RESTORE PCB ADDRESS.
	LDB	T3,PCISTS	;WAIT FOR
	TRNE	T3,STDWRT!STDREA ;THE INTRPT ON COMPLETION TO
	JRST	.-2		;HAPPEN.
	LDB	T3,PGYERR	;GET ERRORS.
	POP	P,PG		;RESTORE PG/ PCB ADDR.
	SKIPN	OHTNUM		;SKIP IF GOT AN OUTPUT ERROR.
	JUMPE	T3,CPOPJ1	;SKIP RETURN IF NO ERRORS
	POPJ	P,		;
;CHECK ON DISK CAPACITY
DEFINE DSKOFF<WRPI DSKPIF##>
DEFINE DSKON<WRPI DSKPIN##>


DSKCPY:	HRRZ J,UNIKON(U)
	SKIPE UNISTS(U)	;MUST BE IDLE
	POPJ P,		;OR JUST RETURN
	SKIPGE KONLTM(J)	;DOES NOT USE CHANNEL
	JRST CPYNOW	;THEN CAN DO IT NOW
	MOVEI T1,CWCOD	;SET TO CPY WAIT
	MOVEM T1,UNISTS(U)
	PUSHJ P,IOSEL	;START IT GOING
	PJRST CPYWAT	;AND WAIT FOR IT TO FINISH

CPYNOW:	MOVEI T1,CCOD
	MOVEM T1,UNISTS(U)
	DSKOFF
	HRRZ T1,KONCPY(J)
	PUSHJ P,(T1)
	DSKON
CPYWAT:	SKIPE UNISTS(U)	;DONE?
	JRST .-1		;NO.
	POPJ P,

;SUBROUTINE TO EXECUTE AN INSTRUCTION FOR ALL UNITS WITHIN A STR.
; USUALLY STORES A BYTE
;T1=INSTRUCTION TO BE EXECUTED, P1=ARG., P2=STR DATA BLOCK ADR.

STOUNI:	HLRZ	U,STRUNI(P2)
	PUSH	P,T1
STOUN1:	XCT	(P)		;EXECUTE INSTRUCTION SUPPLIED IN AC T1
	HLRZ	U,UNISTR(U)
	JUMPN	U,STOUN1
	JRST	TPOPJ






DECLOP:	JSP	T2,SVOTAC
	PUSHJ	P,TYPDEC
	PJRST	CRLFOP

TYPMSN:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	PUSHJ P,CLRSND
	PUSHJ	P,TYPDEC	;PUT MSG. IN THE BUFFER FOLLOWED BY DECIMAL #
	PJRST	OPOUT		;O/P THE BUFFER

TYPDEC:	PUSHJ	P,CONMES
	MOVE	T1,P1
	PJRST	RADX10




SPSNAM:	SKIPA	T2,STRNAM(P2)
SPUNAM:	MOVE	T2,UNINAM(U)
	PJRST PRNAME

SVMOT2:	SETOM ERRHM2
SVMOTE:	SETOM	ERRHOM
	PUSHJ P,CLRSND
SVMOUT:	JSP	T2,SVOTAC
CONOUT:	PUSHJ	P,CONMES
CRLFOP:	PUSHJ	P,CRLF
	PJRST	OPOUT

ASKQUE:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	PJRST	YESNO		;GET USER'S RESPONSE - SKIP RETURN IF 1ST.
				;T3="Y" NON SKIP RETURN IF ANYTHING ELSE TYPED



;T2 & T3 ARE RESPECTED

SETCHG:	MOVSI	T1,UNPCHG	;PREPARE TO FLAG HOME PAGES NEED REWRITING
	MOVSI	T4,UNPOFL!UNPHWP
	TDNN	T4,UNIDES(U)	;IS UNIT WRITE PROTECTED OR OFF-U?
	IORM	T1,UNIDES(U)	;SET UNPCHG FLAG
	POPJ	P,		;RETURN



;SUBR TO MARK A UNIT AS A PRIVATE/PUBLIC PACK.
SETPUB:	MOVSI	T3,UNPPRV	;
	ANDCAM	T3,UNIDES(U)	;
	POPJ	P,		;

SETPRV:	MOVSI	T3,UNPPRV	;
	IORM	T3,UNIDES(U)	;
	POPJ	P,		;
	

GETUNI:	PUSHJ	P,GETLIN	;GET USER'S RESPONSE
	  POPJ	P,		;JUST CR TYPED - NON SKIP RETURN
	PUSHJ	P,CTEXT		;GET SIXBIT UNIT NAME
	SETZM	U		;ASSUME "ALL" WAS TYPED
	HLRZ	T1,T2		;MAKE AC LOOK GOOD FOR COMPARE
	PUSHJ	P,FNDUNI	;SEE IF UNIT EXISTS & RETURN WITH UNIT DATA BLOCK
	  SKIPA	T1,[[ASCIZ .NOT A PHYSICAL UNIT-TRY AGAIN.]]
	JRST	CPOPJ1		;UNIT EXISTS - SKIP RETURN
	PUSHJ	P,SVMOUT	;ADD CRLF & O/P MSG.
	JRST	GETUNI		;TRY AGAIN

FNDUNI:	HLRZ	U,SYSUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN SYSTEM
FNDUN1:	CAMN	T2,UNINAM(U)	;MATCH?
	JRST	CPOPJ1		;YES - SKIP RETURN
	HLRZ	U,UNISYS(U)	;GET NEXT UNIT DATA BLOCK ADR. IN SYSTEM
	JUMPN	U,FNDUN1	;REPEAT IF THERE IS ONE
	POPJ	P,		;NONE FOUND - NON SKIP RETURN

;SUBROUTINE TO PRESERVE AC'S P4,F,U & J

REFSAV:	HRROS	STRREF(P2)	;INDICATE STR NEEDS REFRESHING
SVOTAC:	PUSH	P,P4
	PUSH	P,T3
	PUSH	P,F
	PUSH	P,U
	PUSH	P,J
	PUSHJ	P,(T2)
	  CAIA
	AOS	-5(P)
	POP	P,J
	POP	P,U
	POP	P,F
	POP	P,T3
	POP	P,P4
	POPJ	P,

COMMENT #
@@SUBROUTINE REDBAT
@@PURPOSE
SUBR TO READ AND VERIFY THE BAT PAGES ON ALL UNITS IN THE SYSTEM.
@@ENTRY
EXPECTS
@@CALLS
CHKBAT AND SCNBAT.
@@ACCUM
DESTROYS
@@ #

REDBAT:	HLRZ	U,SYSUNI	;GET ADR. OF 1ST UNIT DB IN THE SYSTEM.
	MOVSI	P4,UNPOFL
RDBAT1:	TDNE	P4,UNIDES(U)	;UNIT OFF-LINE?
	JRST	RDBAT6		;YES, GO READ NEXT BAT PAGE
	PUSHJ	P,CHKBAT	;NO - GO CHECK "BAT" PAGES FOR THIS UNIT
	  JFCL			;IGNORE ERRORS
RDBAT6:	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA PAGE IN SYSTEM
	JUMPN	U,RDBAT1	;REPEAT IF THERE IS ONE
	POPJ	P,		;NONE LEFT - EXIT

COMMENT #
@@SUBROUTINE CHKBAT/BATREF
@@PURPOSE
SUBR TO READ THE BAT PAGES AND ALLOW THE USER TO REINITIALIZE
THEM IF THEY ARE BAD.
@@ENTRY
THE ENTRY POINT CHKBAT READS THE BAT PAGES AND IF ERRORS ARE
FOUND, ASKS THE USER IF HE/SHE WISHES TO REINITIALIZE THE BAT
PAGES.  IF YES, IT FALLS INTO BATREF, WHICH DOES.
EXPECTS U/ UNIT DB AND F/ DDB.
@@ACCUM
DESTROYS
@@CALLS
SVOTAC, GETBAT, ASKQUE, CORZER, SETBAT, AND WTBOTH.
@@EXIT

@@ #

CHKBAT:	JSP	T2,SVOTAC	;SAVE P4,F,U & J.
	SETZM	BATBAD		;CLEAR BAT PAGE BAD FLAG.
	PUSHJ	P,GETBAT	;READ BOTH BAT PAGES & VERIFY THEM.
	  JFCL			;ERROR(S)
	SKIPN	T1,REDERR	;ANY ERRORS FOUND AT ALL IN EITHER BAT PAGE?
	POPJ	P,		;NO.
	MOVEM	T1,BATBAD	;YES. BAD BAT PAGE.
	SKIPE BATMAN		;DO NOT GET TO REFRESH IF FORCED(
	POPJ P,			;I.E. FROM FILMAN).
	MOVEI	T1,[ASCIZ .
Do you want to initialize the BAT pages on this UNIT?
.]
	MOVSI	T2,UNPHWP
	TDNN	T2,UNIDES(U)	;DON'T INITIALIZE IF UNIT HARDWARE WRITE-PROTECT
	PUSHJ	P,ASKQUE	;TYPE QUESTION & GET USER'S RESPONSE
	  POPJ	P,		;HE DOESN'T WANT TO
	MOVEI	T1,[ASCIZ .
THIS is not normally done, are you SURE?
.]
	PUSHJ	P,ASKQUE	;ASK AGAIN
	  POPJ	P,		;HE SAVED HIMSELF SOME BOTHER
	MOVE T3,P1		;GET CORE PNTR IN CORRECT AC.

BATREF:	MOVEI	T1,%BAT
	PUSHJ	P,CORZER	;
	PUSHJ	P,SETBAT	;
	MOVEM	P2,%BAT+PAGNAM	;PUT SIXBIT 'BAT' IN THE PAGE.
	MOVSI	T1,-BRMAX	;SETUP AOBJN PTR. TO BE STORED IN PAGE
	HRRI	T1,BATREG
	MOVEM	T1,%BAT+BATFIR ;SAVE IT IN THE PAGE
	MOVEM	P3,%BAT+PAGCOD ;SAVE THE CODE FOR BAT PAGES IN THE PAGE
	PJRST	WTBOTH		;

BATBAD:	0			;0 INDICATES VIRGIN BAT PAGES(INITIALIZED)
				; LH = -1 INDICATES ERROR(S) DETECTED WHILE READING
				; RH = # BAD REGIONS ON UNIT
BATMAN:	0			;0=OPTIONAL, -1=MANDATORY

;SUBROUTINE TO TYPE SIXBIT UNIT NAME FOLLOWED BY (ID)
; ENTER WITH U = UNIT DATA BLOCK ADR.

TYPUNI:	MOVEI	P1,[ASCIZ .,.]
TYPUN1:	MOVE	T1,P1		;GET MSG. ADR. INTO KOSHER AC
	PUSHJ	P,CONMES	;PUT "," OR MSG. IN BUFFER
	JUMPE	U,OPOUT	;JUST O/P MSG.
	PUSHJ	P,SPUNAM	;PUT SIXBIT UNIT NAME IN BUFFER
	MOVEI	T1,[ASCIZ .(.]
	PUSHJ	P,CONMES	;PUT "(" IN BUFFER
	SKIPE	T2,UNIHID(U)	;GET SIXBIT UNIT ID - IF ANY
	PUSHJ	P,PRNAME	;PUT IT IN THE BUFFER
	MOVEI	T1,[ASCIZ .).]
	PUSHJ	P,CONMES	;PUT ")" IN THE BUFFER
	PJRST	OPOUT		;O/P BUFFER

;SUBROUTINE TO TYPE STR NAME IN "SYS" SEARCH LIST.

TYPSYS:	MOVEI	T1,[ASCIZ .
STR IN "SYS" SEARCH LIST:.]
	PUSHJ	P,CONOUT
	PUSHJ	P,SPSNAM	;PUT SIXBIT STR NAME IN BUFFER
	PJRST	OPOUT		;O/P BUFFER & EXIT
TYPSR1:	PJRST	CRLFOP		;O/P CRLF

;SUBROUTINE TO TYPE ALL UNITS IN SYSTEM THAT ARE NOT IN ANY STR
; RETURN WITH P1,P4,F,U & J DESTROYED

TYPUNS:	MOVEI	P1,[ASCIZ .
UNITS NOT IN A FILE STRUCTURE:
.]
	HLRZ	U,SYSUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN SYSTEM
	TDZA	P4,P4		;INDICATE UNIT ID TO BE TYPED IN TYPUNI
TYPNS1:	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN SYSTEM
	JUMPE	U,CPOPJ		;EXIT IF NONE LEFT
	SKIPE	UNILOG(U)	;IS THIS UNIT IN A STR?
	JRST	TYPNS1		;YES - CHECK NEXT UNIT
	PUSHJ	P,TYPUN1	;NO - TYPE MSG., UNIT NAME & (ID)

TYPNS2:	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN SYSTEM
	JUMPE	U,TYPSR1	;O/P CRLF & EXIT IF NONE LEFT
	SKIPN	UNILOG(U)	;IS THIS UNIT IN A STR?
	PUSHJ	P,TYPUNI	;YES - TYPE "," UNIT NAME & (ID)
	JRST	TYPNS2		;REPEAT

;SUBROUTINE TO TYPE THE STR & ITS UNITS.
; RETURN WITH P1,P4,F,U & J DESTROYED

TYPSTR:	SETZM	P4		;INDICATE UNIT ID TO BE PRINTED IN TYPUNI
	MOVEI	P2,STRDDB	;ADR. OF STR DATA BLOCK.
	SKIPN	STRNAM(P2)	;ANY STR?
	POPJ	P,		;NO.
    ;TYPE STR NAME & ALL ITS UNITS.

	HLLZ	T2,STRREF(P2)
	JUMPE	T2,NOREF	;DOES STR NEED REFRESHING?
	MOVEI	T1,[ASCIZ .NEEDS REFRESHING .]		;YES
	PUSHJ	P,CONMES	;PUT MSG IN BUFFER
NOREF:	PUSHJ	P,SPSNAM	;PUT SIXBIT STR NAME IN BUFFER
	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT IN STR
	JUMPE	U,CRLFOP	;IF NO UNITS IN STR - O/P BUFFER WITH CRLF & EXIT
	PUSHJ	P,OPOUT	;O/P BUFFER
	MOVEI	P1,[ASCIZ .:.]
	PUSHJ	P,TYPUN1	;TYPE ":" UNIT NAME & (ID) [IST. TIME THRU]
TYPST1:	HLRZ	U,UNISTR(U)	;GET NEXT UNIT DATA BLOCK IN STR
	JUMPE	U,TYPSR1	;IF NO MORE UNITS - ADD CRLF & EXIT
	PUSHJ	P,TYPUNI	;TYPE "," UNIT NAME & (ID)
	JRST	TYPST1		;REPEAT UNTIL NO MORE UNITS IN STR

TYPALL:	PUSHJ P,TYPSTR
	PUSHJ P,TYPUNS
	PUSHJ P,TYPSYS
	JRST FILCMD

;ROUTINE TO TYPE VALUE AND MESSAGE OR ASK FOR NEW
;VALUE USING MIN AND MAX
;ONLY TYPE IF TYPONL NON-0
;DBLSTD MAY HAVE 2 VALUES TO TRY WITHOUT ASKING
;VALUE IN P1, MSG IN T1, RESULT IN T2
;NON-SKIP RETURN IF UNCHANGED OR ONLY TYPING

ASKQMM:	SKIPGE TYPONL
	JRST DECLOP	;JUST TYPE IT
	MOVEM T1,MSGSAV	;SAVE MESSAGE
	MOVEM P1,VALSAV	;AND VALUE
	MOVE T2,MIN
	CAMN T2,MAX
	JRST RETFIX	;ONLY ONE POSSIBLE VALUE
ASKRPT:	SKIPL DBLSTD
	JRST QSTSTD	;TRY A STANDARD ANSWER
	PUSHJ P,FTYUNI	;FORCED TYPE OF UNIT?
	 JRST KNNUNI	;NO
	MOVE T1,MSGSAV
	MOVE P1,VALSAV	;MAKE SURE RESTORED
KNNUNI:	PUSHJ P,DECLOP	;TYPE VALUE AND MESSAGE
	MOVEI T1,[ASCIZ /MIN = /]
	MOVE P1,MIN
	PUSHJ P,TYPDEC
	MOVEI T1,[ASCIZ / MAX = /]
	MOVE P1,MAX
	PUSHJ P,DECLOP
	PUSHJ P,GETLIN
	 JRST KEPSAM	;DOES NOT WANT IT CHANGED
	PUSHJ P,DECIN
	 JFCL
	 JRST ASKRP1	;ASK FOR IT AGAIN, WAS BAD
	CAIN	T3,"-"	;IS HYPHEN TERMINATOR?
	JRST	ASKRP1	;YES, NEGATIVE RESPONSE ILLEGAL
CHKANS:	CAMG T2,MAX
	CAMGE T2,MIN
	JRST ASKRPQ	;NOT IN RANGE
RETFIX:	CAME T2,VALSAV
	AOS (P)
	SETOM DBLSTD	;SO NOTHING THERE NEXT TIME
	POPJ P,

QSTSTD:	HLRZ T2,DBLSTD	;GET FIRST TRY
	CAIN T2,377777
	MOVE T2,MAX	;FLAG FOR MAX
	JRST CHKANS

KEPSAM:	MOVE T2,VALSAV
	JRST CHKANS

ASKRPQ:	MOVEI T1,[ASCIZ /
VALUE NOT IN PERMITTED RANGE/]
	SKIPGE DBLSTD	;NO ERROR IF STANDARD SETTING
	PUSHJ P,CONOUT	;PUT OUT THE MESSAGE
	HRLOS DBLSTD	;TRY SECOND STANDARD IF PRESENT
ASKRP1:	MOVE T1,MSGSAV
	MOVE P1,VALSAV
	JRST ASKRPT	;TRY AGAIN

MSGSAV:	0
DBLSTD:	0
VALSAV:	0
TYPONL:	0
MAX:	0
MIN:	0
KNOUNI:	0

COMMENT #
@@SUBROUTINE MAYREF
@@PURPOSE
SUBR TO TYPE WARNING THAT A CHANGE WILL CAUSE REFRESH.
@@ #

MAYREF:	SKIPL TYPONL
	SKIPL DBLSTD
	POPJ P,		;ONLY TYPING, OR DOING STANDARD
	JUMPE P2,CPOPJ	;NO STR
	HLLZ T1,STRREF(P2)
	JUMPN T1,CPOPJ	;ALREADY SET FOR REFRESH
	MOVEI T1,[ASCIZ /
CHANGE WILL CAUSE STR TO NEED REFRESHING/]
	PJRST CONOUT




COMMENT #
@@SUBROUTINE FTYUNI
@@PURPOSE
LITTLE SUBR TO POSSIBLY TYPE A UNIT NAME.
@@ #

FTYUNI:	SKIPE KNOUNI	;KNOW WHAT UNIT?
	POPJ P,		;YES
	PUSHJ P,SPUNAM
	AOS (P)
	SETOM KNOUNI
	PJRST CRLFOP

COMMENT #
@@SUBROUTINE SPUCLC
@@PURPOSE
SUBR TO CALC THE NUMBER OF SATS FOR A UNIT, GIVEN THE NO. OF
PAGES ON THE UNIT.
@@ENTRY
EXPECTS U/ UNIT DB.
@@ACCUM
DESTROYS T2 AND T3.
@@EXIT
SETS UNYSPU.
@@ #

SPUCLC:	MOVE	T2,UNIPPU(U)	;T2/ NO. OF PAGES ON THE UNIT.
	SUBI	T2,1		;
	IDIVI	T2,400*^D36	;DIVIDE BY NO. PAGES PER SAT.
	ADDI	T2,1		;
	DPB	T2,UNYSPU	;SET ANSWER.
	POPJ	P,

COMMENT #
@@SUBROUTINE UNITST
@@PURPOSE
SUBR TO CALC AND STORE THE NO. OF SATS ON A UNIT.  MAY FLAG
HOME PAGES NEED REWRITING.
@@ENTRY
EXPECTS U/ UNIT DB.
JUST RETURNS IF TYPONL IS < 0.
@@CALLS
SPUCLC AND SETCHG.
@@EXIT
STORES RESULT IN UNYSPU.
@@ #

UNITST:	SKIPGE	TYPONL
	POPJ	P,
	LDB	T3,UNYSPU
	PUSHJ	P,SPUCLC
	CAME	T3,T2
	PJRST	SETCHG
	POPJ	P,

COMMENT #
@@SUBROUTINE UNITID
@@PURPOSE
SUBR TO SET THE UNIT ID.
@@ #

UNITID:	PUSHJ	P,FTYUNI
	JFCL
	MOVEI	T1,[ASCIZ /
UNIT ID IS /]
	SKIPN	P1,UNIHID(U)
	MOVEI	T1,[ASCIZ /
ZERO UNIT ID - NEW ID NEEDED/]
	PUSHJ	P,CONMES
	SKIPE	T2,P1		;PRINT IF NON-ZERO.
	PUSHJ	P,PRNAME
	PUSHJ	P,CRLFOP
	SKIPGE	TYPONL
	POPJ	P,		;DONE IF ONLY PRINTING.
	PUSHJ	P,GETLIN
	SKIPA	T2,UNIHID(U)	;NO CHANGE, GET BACK OLD.
	PUSHJ	P,CTEXT	;READ
	JUMPE	T2,UNITID	;STILL 0, TRY AGAIN.
	EXCH	T2,UNIHID(U)
	CAME	T2,UNIHID(U)
	PJRST	SETCHG		;CHANGED.
	POPJ	P,		;NOT CHANGED

COMMENT #
@@SUBROUTINE STRTCH
@@PURPOSE
SUBR TO ALLOW THE REDEFINITION OF THE SIZE OF CRASH.SAV.
@@ #

STRTCH:	SETZM	MIN
	MOVE	T1,[^D8192]	;(2**22)/512.
	MOVEM	T1,MAX
	PUSHJ	P,MAYREF
	MOVE	P1,STRP4C(P2)
	MOVEI	T1,[ASCIZ /PAGES FOR CRASH.SAV = /]
	PUSHJ	P,ASKQMM
	POPJ	P,
	MOVEM	T2,STRP4C(P2)
	HRROS	STRREF(P2)
CHGSTR:	MOVE	T1,[PUSHJ P,SETCHG]
	PJRST	STOUNI



COMMENT #
@@SUBROUTINE
@@PURPOSE
SUBR TO ALLOW THE REDEFINITION OF THE NO. OF PAGES OF
OVERDRAW PER USER.
@@ #

STRTOV:	SETZM	MIN
	MOVE	T1,STRPPU(P2)
	MOVEM	T1,MAX
	MOVEI	T1,[ASCIZ /# OF PAGES ALLOWED FOR OVERDRAW PER USER = /]
	MOVM	P1,STROVR(P2)
	PUSHJ	P,ASKQMM
	POPJ	P,
	MOVNM	T2,STROVR(P2)
	PJRST	CHGSTR

COMMENT #
@@SUBROUTINE STSDEF
@@PURPOSE
SUBR TO DEFINE A STR.
@@ENTRY
EXPECTS
@@ACCUM
DESTROYS
@@CALLS
CONOUT, GETLIN, CTEXT, FNDSTR, GETUNI, CMPLOG, SETCHG,
STRTOV, AND STRTCH.
(AND ITS INTERNAL SUBRS STSINS, UNICHK, AND UNICK1.).
@@ #

STSDEF:	MOVE	T1,[SIXBIT/DSKB/] ;ALL STR NAMES ARE DSKB.
	PUSHJ	P,FNDSTR	;DOES THIS STR ALREADY EXIST?
	SKIPA	T1,[[ASCIZ /STR ALREADY EXISTS/]] ;YES, THIS IS A NO-NO.
	JRST	STSNEW		;NO, OKAY UNLESS ALREADY A STR.
	PJRST	CONOUT

STSNEW:	SKIPN	STRNAM(P2)	;DOES ANY STR EXIST?
	JRST	STSNE1		;NO, THIS IS IT.
	MOVEI	T1,[ASCIZ /
TOO MANY FILE STRS
/]
	PJRST	CONOUT

    ;HERE WITH A GOOD STR NAME.
STSNE1:	PUSHJ	P,CLRSTR
	MOVEM	T1,STRNAM(P2)
	HRROS	STRREF(P2)	;NEED REFRESH.
    ;HERE TO PUT THE UNITS IN THE STR.
STSNE2:	MOVEI	T1,[ASCIZ /TYPE NAMES OF PHYSICAL UNITS IN STR, EXTRA CR WHEN DONE/]
	PUSHJ	P,CONOUT
	MOVEI	P3,STRUNI(P2)
	SETZ	P1,
STSNXT:	PUSHJ	P,GETUNI	;GET A UNIT NAME
	JRST	[CAIE P3,STRUNI(P2)  ;FINISHED GETTING UNIT NAMES.
		JRST STSFIN
		JRST STSNE2]
	PUSHJ	P,STSINS	;INSERT UNIT.
	JRST	STSNXT		;ALREADY IN STR
	JRST	STSNXT		;CONTINUE

    ;SUBR INTERNAL TO STSDEF TO INSERT A UNIT IN THE STR.
STSINS:	HRRZ	T1,UNISTR(U)	;SEE IF THIS UNIT IS ALREADY IN A STR.
	JUMPE	T1,STSUN2	;T1 = 0 IF IT ISN'T
	MOVEI	T1,[ASCIZ .
UNIT ALREADY IN FILE STRUCTURE
.]
	PJRST	CONOUT		;TYPE MSG. & EXIT

STSUN2:	HRLM	U,(P3)		;LINK THIS UNIT DATA BLOCK TO PREVIOUS ONE
	HRRZM	P2,UNISTR(U)	;ATTACH THIS UNIT DATA BLOCK TO THIS STR
	HRRZ	T1,STRUNM(P2)	;GET LOGICAL UNIT # WITHIN STR
	DPB	T1,UNYLUN	;SAVE IT IN UNIT DATA BLOCK
	PUSHJ	P,CMPLOG	;COMPUTE SIXBIT LOGICAL UNIT NUM, STORE IN UNILOG
	PUSHJ	P,SETPUB
	MOVE	T1,UNIPPU(U)
	CAMLE	T1,STRPPU(P2)
	MOVEM	T1,STRPPU(P2)
	CAIE P1,0
	CAMGE	T1,UNIPPU(P1)	;COMPARE WITH SMALLEST SO FAR
	MOVE	P1,U		;SAVE ADDR OF SMALLEST IN P1
	AOS	STRUNM(P2)	;INCREMENT # OF UNITS IN STR
	PUSHJ	P,SETCHG	;FLAG THAT UNIT'S HOME PAGES MUST BE REWRITTEN
	MOVEI	P3,UNISTR(U)	;MAKE CURRENT UNIT PREDECESSOR
	JRST	CPOPJ1		;SKIP RETURN

    ;HERE TO FINISH UP.
STSFIN:	HLRZ	U,STRUNI(P2)
	HLRZ	U,UNISTR(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	U,.-1		;REPEAT IF ANY LEFT
	SETZM	TYPONL		;JUST IN CASE.
	MOVE	U,P1		;GET SMALLEST UNIT.
	LDB	P1,UNYKTP
	PUSH	P,P1		;SAVE IT.
	MOVE	T1,OVRDEF(P1)
	HRLOM	T1,DBLSTD
	PUSHJ	P,STRTOV	;SET OVERDRAW.
	MOVE	T1,(P)
	MOVE	T1,P4CDEF(T1)
	HRLOM	T1,DBLSTD
	PUSHJ	P,STRTCH	;SET DEFAULT SIZE OF CRASH.SAV.
	POP	P,P1
	MOVE	T1,[PUSHJ P,UNICK1]
	PUSHJ	P,STOUNI	;CHECK SATS.
	MOVE T1,[PUSHJ P,UNICHK]
	PJRST STOUNI		;NOW DO ALL UNITS.

    ;A LITTLE INTERNAL STSDEF SUBR.
UNICHK:	SETZM KNOUNI		;DO NOT KNOW UNIT.
	PJRST UNCHKA		;GO DO THE STANDARD STUFF.

    ;A LITTLE INTERNAL STSDEF SUBR.
UNICK1:	SETZM KNOUNI
	SETZM TYPONL		;JUST TO MAKE SURE.
	PJRST UNITST		;CHECK SATS.

;DEFAULT DEFS BY UNIT TYPE.


OVRDEF:	1	;DR
	^D50	;FH
	^D125	;DP
	^D125	;MF
	^D125	;3330
	200-3	;RM03

P4CDEF:	0	;DR
	0	;FH
	^D512	;DP
	^D512	;MF
	^D512	;3330
	1000	;RM03

COMMENT #
@@SUBROUTINE STSDSL
@@PURPOSE
SUBR TO DISSOLVE A STR.
CLEARS UNILOG, UNISTR, AND STRNAM AND FLAGS THAT ALL THE
STR'S UNITS' HOME PAGES NEED REWRITING.
@@ENTRY
EXPECTS
@@ACCUM
DESTROYS
@@CALLS
SETCHG.
@@ #

STSDSL:	PUSH	P,T2		;SAVE T2 AND
	PUSH	P,T1		;T1.
	MOVEI	P2,STRDDB
	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN STR.
	JUMPE	U,DISST2	;JUST UNLINK STR IF IT HAS NO UNITS.
	MOVSI	T1,UNPPRV	;UNIT MAY BE GOING PRIVATE.
DISST1:	SETZB	T3,UNILOG(U)	;CLEAR OUT NAME OF LOGICAL UNIT WITHIN STR.
	EXCH	T3,UNISTR(U)	;CLEAR OUT LINKS TO STR & NEXT UNIT DATA BLOCKS.
	IORM	T1,UNIDES	;UNIT IS NOW A PRIVATE PACK
	PUSHJ	P,SETCHG	;FLAG THAT THIS UNIT'S HOME PAGE MUST BE REWRITTEN.
	HLRZ	U,T3		;GET NEXT UNIT DATA BLOCK ADR.
	JUMPN	U,DISST1	;REPEAT IF THERE IS ONE.
DISST2:	PUSHJ	P,CLRSTR	;INDICATE STR NO LONGER EXISTS.
	POP	P,T1		;RESTORE T1 AND
	POP	P,T2		;T2.
	POPJ	P,		;RETURN - DON'T WORRY ABOUT RETURING CORE
				; AS RDHOME MUST BE CALLED AGAIN.



COMMENT #
@@SUBROUTINE CLRSTR
@@PURPOSE
LITTLE SUBR TO CLEAR OUT THE STR DB (SETTING STRNAM TO
ZERO INDICATES THAT THERE IS NO STR.).
@@ACCUM
DESTROYS NO ACS.
@@ #

CLRSTR:	PUSH	P,T1
	SETZM	STRDDB	
	HRLI	T1,STRDDB
	HRRI	T1,STRDDB+1
	BLT	T1,STRDDB+STRLEN-1
	POP	P,T1
	POPJ	P,

COMMENT #
@@SUBROUTINE ADDUNI
@@PURPOSE
SUBR TO ADD A UNIT TO THE SYSTEM STR.
@@ENTRY
EXPECTS
@@CALLS

@@ACCUM
DESTROYS
@@EXIT

@@ #

ADDUNI:	MOVEI	P2,STRDDB	;P2/ ADDR OF STR DB.
	SKIPN	STRNAM(P2)	;HAS THE STR BEEN DEFINED?
	JRST	ADDNOT		;NO, ILLEGAL TO ADD TO IT.
	MOVEI	T1,[ASCIZ .Enter unit name to add.]
	PUSHJ	P,CONOUT	;BY NOW P2=STR DDB.
	PUSHJ	P,GETUNI	;GET A UNIT NAME.
	JRST	CANTAD		;NOT A UNIT, CAN NOT ADD.
	JUMPE	U,CANTAD	;CAN NOT ADD ALL EITHER.
	HRRZ	T1,UNISTR(U)	;IS THE UNIT IN A STR ALREADY?
	JUMPE	T1,ADDUN2	;NO.
	MOVEI	T1,[ASCIZ .THAT unit is already in a structure.]
	JRST	CONOUT

    ;HERE WHEN WE HAVE A UNIT TO ADD, AND THE UNIT IS NOT
    ;ALREADY IN A STR.
ADDUN2:	MOVE	T1,UNIPPU(U)
	CAMLE	T1,STRPPU(P2)	;MUST NOT WANT TO CHANGE STRPPU
	JRST	CANTAD
	SETZM	TYPONL
	PUSHJ	P,UNCHKA	;SET UNIT ID AND NO. OF SATS PER UNIT.
	HRRZ T1,STRUNM(P2)
	LDB T2,UNYLUN
	DPB T1,UNYLUN	;CHANGE THIS UNIT NUMBER
	SETZM UNTTBL(T2)	;ZERO OLD CELL
	MOVE T1,T2
	SKIPE UNTTBL-1(T1)
	SOJA T1,.-1	;LOOK FOR ZERO
	CAMN T1,T2
	JRST ADUNT
	EXCH U,UNTTBL(T1)	;GET THAT ONE
	DPB T2,UNYLUN	;CHANGE ITS NUMBER
	EXCH U,UNTTBL(T2)	;AND STOR IN NEW PLACE (SETS U=0)
	EXCH U,UNTTBL(T1)	;GET OLD U BACK
ADUNT:	LDB T1,UNYLUN		;AND OLD UNIT NUMBER
	MOVEM U,UNTTBL(T1)	;STORE IN NEW PLACE
	HLLZ	T1,STRREF(P2)	;IS IT MARKED FOR REFRESH
	JUMPN	T1,ADDUN4	;YES, DO NOT NEED TO REFRESH PACK
	PUSH	P,P2		;SAVE THE STR POINTER.
	PUSHJ	P,UPDHOM	;WRITE HOME PAGES.
	POP	P,P2		;RESTORE STR PTR.
	MOVSI	P4,UNPCHG
	ANDCAM	P4,UNIDES(U)	;PAKREF WILL READ HOME PAGES.
	PUSHJ	P,PAKREF	;REFRESH PACK.
	JRST	CANTAD		;COULD NOT DO IT.
ADDUN4:	AOS	T1,STRUNM(P2)	;ONE MORE IN STR
	SUBI	T1,1		;
	HRRZM	P2,UNISTR(U)	;LINK TO STR DDB
	PUSHJ	P,CMPLOG	;MAKE A LOGICAL UNIT NAME
	HLRZ	T1,STRUNI(P2)
ADDUN5:	HLRZ	T2,UNISTR(T1)
	JUMPE	T2,ADDUN7	;FIND END OF CURRENT LIST
	MOVE	T1,T2
	JRST	ADDUN5
ADDUN7:	PUSH	P,T1		;SAVE LAST UNIT.
	HRLM	U,UNISTR(T1)
	PUSHJ	P,SETCHG	;MARK HOME PAGE CHANGED.
	PUSHJ	P,SETPUB
	POP	P,U		;WANT TO SET CHANGED HOME ON THIS ONE TOO.
	PUSHJ	P,SETCHG
	POPJ	P,

ADDNOT:	MOVEI T1,[ASCIZ .The SYSTEM structure has not been DEFINED yet.]
	JRST CONOUT

CANTAD:	HLLZS	UNISTR(U)	;
	MOVEI	T1,[ASCIZ .CAN NOT ADD UNIT TO STRUCTURE.]
	JRST	CONOUT

;SUBR TO REFRESH A STR.

STSREF:	MOVEI	T1,UFDHSI	; RANNO already setup!
	HRRM	T1,STRHSH+STRDDB
	SKIPN	RANHOM		; Is this a virgin pack set?
	  AOS	RANHOM		; If so, prevent RDHOME from complaining.
	PUSHJ	P,RWRHOM	;WRITE HOME PAGES.
	SETZM BATMAN
	PUSHJ P,RDHOME		; Read & Verify HOM pages
	 JFCL			; Ignore "all" errors
	 JFCL
	MOVE F,DDSTAR
	PUSHJ	P,REFSTR	;REFRESH THE STR.
	JRST	CNTADS		;LOST.
	PUSHJ	P,RDHOME	; Read & Verify new HOM pages
	 JFCL			; Just to make sure.
	 JFCL
	POPJ P,

CNTADS:	HRROS	STRREF(P2)	;MARK WE STILL NEED REFRESHING.
	MOVEI	T1,[ASCIZ /The structure WAS NOT successfully refreshed./]
	PJRST	CONOUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	Routine SETRAN - Start timer for pseudo-random number		;;
;;									;;
;;	Called by CMDSCN whenever it prompts the operator for		;;
;;	anything during ONCE and ONCDSK.  Needed in conjunction		;;
;;	with GETRAN which reads the current timer value for the		;;
;;	REFRESH command.						;;
;;									;;
;;	Clobbers T1, T2  - depending upon processor			;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SETRAN:			; Entry point to start timer for random number
IFCPU (<KL,KS>),<
IFCPU (<KL>),<
	EXTERN EPT
	SETZM	EPT+EPTLTB	; Clear EPT locations (KL)
	CONO	MTR,MO.TON	; Turn on MTR clock
>; END IFCPU (KL)
IFCPU (KS),<
	SETZB	T1,T2		; Set the Time Base
	WRTIME	T1		; To Zero.
>;END IFCPU (KS)
	POPJ	P,		; Return.
>;END IFCPU(<KL,KS>)

IFCPU (<KI,F3>),<
	MOVE	T1,[JRST CLKLVL]; New Clock-routine
	EXCH	T1,CH7+1	; Set New/Save Old Value
	MOVEM	T1,CLKRAN	; Store for later
	SETZM	CLKCNT		; Reset time base
	WRPI	1B25!1B35	; TURN ON CHANNEL SEVEN.
IFCPU (KI),<WRAPR 1B25!1B26!7B35>
IFCPU (F3),<WRAPR LP.ESF+LP.CSF+LP.CLK+7B35>
	POPJ	P,		; Return.

CLKLVL:	AOS	CLKCNT		;
IFCPU (KI),<WRAPR 1B25!1B26!7B35>	;
IFCPU (F3),<WRAPR LP.ESF+LP.CSF+LP.CLK+7B35>
	JEN	@CH7

CLKRAN:	Z			; Holder for old CH7+1
CLKCNT: Z			; Timer value
>;END IFCPU (<KI,F3>)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	Routine GETRAN - Read the time-base or clock value		;;
;;									;;
;;	Called by CMDSCN in ONCE and ONCDSK each time the operator	;;
;;	is prompted for a response.  Updates RANNO## with a new		;;
;;	random seed used by REFSTR each time.				;;
;;									;;
;;	Clobbers T1.							;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

External RANNO			  ; Located in REFSTR, set here each cmd line

GETRAN:	PUSH	P,T2		  ; Save this register (T2)
IFCPU (<KL,KS>),<RDTIME	T1>	  ; Read time base setup earlier + counter
IFCPU (KL),<LSH T2,-^D12>	  ; Strip low order zero bits on KL
IFCPU (<KI,F3>),<
	HRRZ T2,CLKCNT		  ; Read clock setup earlier + elapsed
IFCPU (KI),<WRAPR 1B24!7B35>	  ; Disable CLOCK now
IFCPU (F3),<WRAPR LP.CSF+LP.DSF+LP.CLK+7B35>
	WRPI	1B26!1B35	  ; Turn OFF channel seven
	MOVE	T1,CLKRAN	  ; Get previous channel 7
	MOVEM	T1,CH7+1	  ; Reset
>;End IFCUP(<KI,F3>)
	TRNN	T2,-1		  ; Make sure RH is neq 0
	  MOVEI	T2,(SIXBIT /CAT/) ; If not, set to 'CAT'
	HRRZM	T2,RANNO	  ; Store for later
	POP	P,T2		  ; Restore T2 from entry
	POPJ	P,		  ; Return.

;SUBR TO ALLOW OPER TO QUERY/SELECT DSKCLN TYPE
;
SPCDKN:	MOVEI	T1,[ASCIZ /
DSKCLN mode is: /]
	PUSHJ	P,OCONM		;MOVE MSG TO OUTPUT BUF
	PUSHJ	P,SPCDKP	;GET CURRENT DC MODE AND PRIORITY
	MOVSI	T1,DCN.ON	;INDIC OPER HAS SEEN AND/OR
	IORM	T1,DCN		; SELECTED DSKCLN MODE
	MOVE	T2,SCNDSK(T2)	;GET SIXBIT NAME OF CURRENT MODE
	CAIN	T3,^L<(DCN.DF)>	;IS MODE DEFAULT?
	MOVE	T2,[SIXBIT /NULL/]	;YES, TELL THIS TO OPER
	PUSHJ	P,PRNAME	;BUFFER MODE NAME
	PUSHJ	P,CRLFOP	;APPEND CRLF, DO CTY OUTPUT
SPCDK1:	MOVEI	T1,[ASCIZ /DSKCLN mode desired? /]
	PUSHJ	P,OCONM		;MOVE MSG TO OUTPUT BUF
	PUSHJ	P,OPOUT		;DO CTY OUTPUT
	PUSHJ	P,GETLIN	;GET OPER'S RESPONSE
	 POPJ	P,		;NULL, NO CHANGE IN MODE
	MOVEI	P1,SCNDSK	; Get address of Scan Table
	SETZM	CMDSCF		; Specify NO STR/UNIT stuff
	PUSHJ	P,CMDSCN	; Call Scanning routine
	  JRST	SPDKHP		; No good!
	DPB	P3,DCNYON	;SAVE IN DCN
NULDSK:	POPJ	P,		;RETURN

SPDKHP:	MOVEI	T1,[ASCIZ \
Bad entry: Type 'FULL', 'FAST', 'NONE'
 or just <Return> for default (NO CHANGE)\]
	PUSHJ	P,CONOUT	;TYPE ERROR MSG ON CTY
	JRST	SPCDK1		;LET OPER TRY AGAIN

;MODE-MNEMONIC CORRESPONDENCE TABLE
;
	DEFINE	MKDSK <
	X NONE,0,Ab.Nak,
	X FAST,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X FULL,0,Ab.Nak,
>

	SCNTB	(SPDKHP,SPDKHP,DSK)

;ROUTINE TO GET/SET DSKCLN MODE AND DETERMINE WHO LAST SET IT
;
SPCDKP:	MOVE	T2,DCN		;GET DSKCLN MODE WORD
	JFFO	T2,.+1		;DETERMINE HIGHEST PRIORITY MODE
	LDB	T2,DCNTAB(T3)	;FETCH IT
	DPB	T2,DCNYON	;OPER HAS SEEN OR SELECTED THIS MODE
	POPJ	P,		;RETURN

FILGO:	Movei T1,[Asciz\
Leaving the FILES dialogue...\]
	Pushj P,LNGMES		; Let everyone know we're leaving!
RWRHOM:	MOVSI P4,UNPCHG
	HLRZ U,SYSUNI		;FIRST UNIT
CHGHOM:	TDNE P4,UNIDES(U)
	PUSHJ P,UPDHOM		;REWRITE IF NEEDED.
	ANDCAM P4,UNIDES(U)
	HLRZ U,UNISYS(U)
	JUMPN U,CHGHOM
	POPJ P,


COMMENT #
@@SUBROUTINE UPDHOM
@@PURPOSE
SUBROUTINE TO READ A HOME PAGE, UPDATE IT FROM THE STR AND
UNIT DB, AND THEN WRITE IT OUT.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
@@ACCUM
DESTROYS
@@CALLS
SVOTAC, GETHOM, AND WTBOTH.
@@ #

UPDHOM:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	SETOM	NOERH		;NO ERRORS PRINTED FOR HOME READ.
	PUSHJ	P,GETHOM	;GET HOME PAGE INTO CORE.
	JRST	[MOVEI T1,%HOM
		PUSHJ P,CORZER
		JRST .+1]
	MOVEM	P2,%HOM+PAGNAM	;SAVE SIXBIT HOME PAGE IDENTIFIER
	HRRZ	P2,UNISTR(U)	;GET STR DATA BLOCK ADR.
	MOVE	T1,UNIHID(U)	;GET SIXBIT UNIT ID
	MOVEM	T1,%HOM+HOMHID	;SAVE IN HOME PAGE
	HLRZ	T1,UNISTR(U)	;GET NEXT UNIT DATA BLOCK ADR. IN STR
	SKIPE	T1		;SAVE 0 IF LAST UNIT IN STR OR NOT IN A STR
	MOVE	T1,UNIHID(T1)	;GET ITS ID
	MOVEM	T1,%HOM+HOMNXT	;SAVE IN HOME PAGE
	SKIPE	T1,P2		;SAVE 0 STR NAME IF UNIT NOT IN A STR
	MOVE	T1,STRNAM(P2)	;GET SIXBIT STR NAME
	MOVEM	T1,%HOM+HOMSNM	;SAVE IN HOME PAGE
	JUMPE	P2,UPDHM3	;BYPASS ALL REFERENCES TO VALUES IN STR DATA BLOCK
	HLRZ	T2,STRUNI(P2)	;GET ADR. OF 1ST UNIT DATA BLOCK IN STR
UPDHM1:	MOVE	T1,T2		;CURRENT UNIT_NEXT UNIT
	JUMPE	T1,UPDHM2	;IF NONE LEFT SAVE 0 IN HOMPRV
	HLRZ	T2,UNISTR(T1)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	MOVE	T1,UNIHID(T1)	;GET CURRENT UNIT'S SIXBIT ID
	CAME	T2,U		;IS ADR. OF NEXT UNIT DATA BLOCK SAME AS THIS ONE?
	JRST	UPDHM1		;YES - PUT SIXBIT ID INTO THIS UNIT'S HOME PAGE
UPDHM2:	MOVEM	T1,%HOM+HOMPRV	;SAVE IN HOME PAGE
				; 0 OR SIXBIT UNIT ID OF PREVIOUS UNIT IN STR
	HLLZ	T1,STRREF(P2)	;GET 'REFRESH' FLAG
	HLLM	T1,%HOM+HOMREF	;SAVE IN HOME PAGE
	HRRZ	T1,STRDDB+STRHSH ;
	HRLZM	T1,%HOM+HOMHSH	;
	HRRZ	T1,RANHOM	;Use Remembered HOMRAN value
	HRRM	T1,%HOM+HOMRAN	;
	MOVE	T1,STROVR(P2)	;GET -VE # PAGES USER IS ALLOWED TO OVERDRAW
	MOVEM	T1,%HOM+HOMOVR	;SAVE IN HOME PAGE
	MOVE	T1,STRP4C(P2)	;GET # PAGES FOR CRASH.SAV
	MOVEM	T1,%HOM+HOMP4C	;SAVE IN HOME PAGE

UPDHM3:	MOVE	T1,UNILOG(U)	;GET SIXBIT LOGICAL UNIT WITHIN STR
	MOVEM	T1,%HOM+HOMLOG	;SAVE IN HOME PAGE
	LDB	T1,UNYLUN	;GET LOGICAL UNIT # WITHIN STR
	MOVEM	T1,%HOM+HOMLUN	;SAVE IN HOME PAGE
	LDB	T1,UNYSPU	;GET # SAT BLOCKS PER UNIT
	MOVEM	T1,%HOM+HOMSPU	;SAVE IN HOME PAGE
	MOVEI	T1,%HOM+HOMEND+1 ;FIRST WORD TO CLEAR.
	CAILE	T1,%HOM+HOMDAT-1 ;SKIP IF AT LEAST ONE WORD.
	JRST	UPDHM4
	SETZM	(T1)		;CLEAR THE FIRST WORD
	CAIN	T1,%HOM+HOMDAT-1	;SKIP IF MORE
	JRST	UPDHM4
	HRLI	T1,%HOM+HOMEND+1
	HRRI	T1,%HOM+HOMEND+2
	BLT	T1,%HOM+HOMDAT-1	;CLEAR UNUSED WORDS
    ;HERE TO WRITE OUT.
UPDHM4:	MOVEM	P3,%HOM+PAGCOD	;SAVE CODE WORD IN HOME PAGE.
	MOVSI	P2,(SIXBIT .HOM.) ;RESTORE ARG.
	PUSHJ	P,WTBOTH	;WRITE OUT BOTH HOME PAGES
	STOPCD
	POPJ	P,		;RETURN

TYPSPC:	MOVE P1,NMSTPC
	MOVEI T1,[ASCIZ /NUMBER OF SAT PCBS = /]
	PJRST DECLOP

CHGSPC:	MOVEI T1,5
	MOVEM T1,MIN
	MOVEI T1,^D20
	MOVEM T1,MAX
	MOVEI T1,[ASCIZ /NUMBER OF SAT PCBS = /]
	MOVE P1,NMSTPC
	PUSHJ P,ASKQMM
	 POPJ P,
	MOVEM T2,NMSTPC
	POPJ P,


TYPRPC:	MOVE	P1,NMRBPC
	MOVEI	T1,[ASCIZ /NUMBER OF RIB PCBS = /]
	PJRST	DECLOP

CHGRPC:	MOVEI	T1,5
	MOVEM	T1,MIN
	MOVEI	T1,^D20
	MOVEM	T1,MAX
	MOVEI	T1,[ASCIZ /NUMBER OF RIB PCBS = /]
	MOVE	P1,NMRBPC
	PUSHJ	P,ASKQMM
	POPJ	P,
	MOVEM	T2,NMRBPC
	POPJ	P,

CHGBAT:	MOVEI	T1,[ASCIZ /TYPE UNIT NAME TO REFRESH BAT PAGES/]
	PUSHJ	P,CONOUT
	PUSHJ	P,GETUNI
	POPJ	P,
	PUSHJ	P,BATREF
	POPJ	P,
	POPJ	P,

TYPBAT:	MOVEI	T1,[ASCIZ /TYPE UNIT NAME/]
	PUSHJ	P,CONOUT
	PUSHJ	P,GETUNI
	POPJ	P,
	SETZM	BATMAN
	PUSHJ	P,CHKBAT
	JFCL			;IGNORE ERRORS.
	MOVE	T2,%BAT+BATFIR
	ADDI	T2,%BAT
	SETZB	P3,P1		;P1 IS PAGE COUNT, P3 REGION COUNT.
TYPBT1:	SKIPN	1(T2)
	JRST	TYPBT2		;DONE.
	ADDI	P3,1		;1 REGION.
	LDB	T1,BAYNBB
	ADDI	P1,1(T1)	;THIS MANY PAGES.
	AOBJP	T2,TYPBT2
	AOBJN	T2,TYPBT1
TYPBT2:	MOVEI	T1,[ASCIZ /# BAD PAGES = /]
	PUSHJ	P,DECLOP
	MOVE	P1,P3
	MOVEI	T1,[ASCIZ /# BAD REGIONS = /]
	PJRST	DECLOP

	LIT
	VAR


ONDLNR=.-%OND+1
ONDLNP=<ONDLNR!777>+1

ONSZCK(ONCDSK,OND)	;CHECK TO SEE IF ENOUGH PAGES ALLOCATED

DEPHASE

	END
 	=H