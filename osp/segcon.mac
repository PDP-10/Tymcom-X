TITLE SEGCON - SEGCON FOR PAGING SYSTEM VERS 2 AAA
COMMENT @
THIS SEGCON PROVIDES SHARABLE "HIGH SEGMENTS" BY MAPPING
FILES WITH .SHR EXTENSION

ALL FILES OF EXTENSION .SHR OR .HGH ON DSK ARE MAPPED. .SAV,
.LOW, ETC. AND ALL MAGTAPE FILES ARE READ INTO FRESHLY-
CREATED PRIV PAGES USING INPUT UUO, THEN PAGES MADE RDO IF
HIGH SEG.

THIS SEGCON ASSUMES ALL FILES TO BE OF "OLD" PRE-VM FORMAT
WHICH CONTAIN NO MAP INFO (BUT WHICH MAY POSSIBLY BE ZERO-
COMPRESSED..  .LOW, .SAV ONLY).  .SHR AND .HGH FILES ARE ASSUMED
TO CONTAIN THE EXACT CORE IMAGE DESIRED FOR PAGES 400 &FF.

@

;GENERAL SYMBOLS AND EXTERNALS
RUNCHN==0	;THE CHANNEL ON WHICH ALL SEGCON I/O DONE
FNCMDP==35 ;MAP DISK PAGE CHANIO FUNCTION
OPDEF VPROT [CALLI -70]
OPDEF VCREAT [CALLI -67]
OPDEF WSCTL [CALLI -74]
OPDEF VREMOV [CALLI -65]
OPDEF VREPL [CALLI -64]
OPDEF PAGSTS [CALLI -71]
OPDEF VCLEAR [CALLI -66]
;	EXTERNS FROM COMMON FOR LMAP DEFN
EXTERN CPRRED,CPRCOW,CPRRDW,%UPT,%UPS,XPNCOR,UPTSTS,SG.SWR
EXTERN UPTREL,UPTHRL,UPTJDA,UPTXAC,UPTPDL,%UPLMA,LMMEXS
EXTERN UPTPID,UPTSPD,UPTSTV
;	EXTERNS FROM JOBDAT
EXTERN JOBREL,JOBHRL,JOBNSV,JOBSA,JOBVER,JOBPOP,JOB41
EXTERN JOBCOR,JOBS41,JOBDDT,JOBREN,JOBFF,JOBSVM,JOBSV,JOBSDD
EXTERN JOBDA,JOBFDV,JOBEXM,JOBHRN,JOBHCR
;	EXTERNS FROM COMCON--MOSTLY UTILITY ROUTINES
EXTERN CTEXT,CTEXT1,MAPUPS,COMERR,PJPGNO,ERNAM,ERRMES
EXTERN DECIN1,NOTENF,CONMES,PRNAME,RELPR
EXTERN COMERA,INLMES
;	EXTERNS FROM SCNSER FOR TTY COMMAND READING
EXTERN TTCMCH,COMTYS,TTYFUW
;	EXTERNS FROM CLOCK1 FOR STARTING MONITOR JOBS, ETC:
EXTERN MSTART,TIMADJ,MONSTR,GTCGSZ
;	EXTERNS FROM FILSER
EXTERN GETLIC,LICMSK,LICMAX,LICSAM,UUPPID
;	JOB TABLES
EXTERN JOB,JBTSTS,JBTPRV,JBTNAM,JBTLIC,JBTSLC,JBTFPN
EXTERN JBTUPM,JBTMPC,JBTRCT,JBTSIN
;	EXTERNS FROM UUOCON
EXTERN RTZER,RESET,USRXIT
;MISC EXTERNS
EXTERN APRENB,CPOPJ,CPOPJ1,TPOPJ,MTSIZ,SAVDMP
EXTERN PVYCOR,CHGPWS
;	EXTERNS FROM CORE1 
EXTERN .WSRNG,PS.CPR,CRLIM%,CRDFL%,DOXCT
EXTERN WSATM%,PTPRF%,WS.ADD,PTNVP%
;EXTERNS FROM ERRCON

EXTERNAL ERRDNA,ERREUF,ERRFNF,ERRNSF,ERRPGN,ERRTRE,ERRJSU,ERRJSV
EXTERNAL ERRCAN,ERRMHB,ERRRMF,ERRMGF,ERRNSA


;SEGCON PERFORMANCE COUNTERS
URUNCT::	EXP 0	;NO. OF RUN UUO'S DONE
RNSGCT::	EXP 0	;RUNSEGS
GTSGCT::	EXP 0	;GETSEGS
COMMENT ! PDL STRUCTURE OBSERVED BY ALMOST EVERYONE
	IN SEGCON.
THIS PDL STRUCTURE IS NOT POPPED BACK UP FOR SUCCESS EXITS
FROM SEGCON EXCEPT FOR THE GETSEG UUO. ALL PHOLD-TYPE FAILURE
EXITS AND SUCCESS EXITS LEAVE IT PUSHED DOWN.  THE SGRELE
FAILURE EXIT TO THE USER PUSHES UPTPDL ONTO THE TOP OF
THE PDL AND JRSTS USRXIT. THE RNSEG SUCCESS EXIT PUSHES
JOBSA ONTO THE PDL AND JRSTS USRXIT.
!
	PHASE 0
XPAMOD:! 0	;MODE TO INIT RUNCHN
;BITS IN LH OF XPAMOD:
	INTERNAL NOSHR,HSLIC,LSLIC
	NOSHR==1	;FOR SGSET/SAVJOB COMMUNICATION
	HSLIC==2	;1 SAYS HL XPALIC SETUP FOR HS FILE
			; (ALSO USED TO FLAG PID SETUP IN XPAHPD)
	LSLIC==4	;1 SAYS RH XPALIC SETUP FOR LS FILE
			; (ALSO USED TO FLAG PID SETUP IN XPAPID)
XPADEV:! 0	;DEVICE (TYPICALLY DSK OR SYS)
XPALKB:! 0	;EXTENDED LOOKUP BLOCK WRD 0 (LENGTH)
XPAPPN:! 0
XPANAM:! 0
XPAEXT:! 0		;EXT FOR THIS LOOKUP, NOT NECESSAIRILY
			;THE ONE THE USER TYPED. SEE XPAUXT
XPAPRV:! 0
XPASIZ:! 0
	BLOCK 17-<.-XPALKB>
XPASTS:! 0		;RIB STATUS
XPAELB:! 0
XPAXT1:! 0
XPAQTF:! 0
XPAQTO:! 0
XPAMXA:! 0
XPAUSD:! 0
XPAAUT:! 0
	BLOCK 2		;UNM AND UN1
XPATRU:! 0
XPAXT2:! 0
XPAALP:! 0
XPASNM:! 0
XPAPJC:! 0	;-
XPAPJ1:! 0	;-
XPAPJ2:! 0	;-
XPAPID:! 0	;PROCESSOR ID
;BITS IN RH OF XPASTS WHICH CAUSE SEGCON TO REFUSE TO LOAD:
	BADBIT==RIPBFS!RIPHWE!RIPHRE!RIPBDR!RIPBDA
	EXTERN RIPBDA,RIPBDR,RIPHRE,RIPHWE,RIPBFS
;ADD MORE WORDS OF EXTENDED LOOKUP BLOCK HERE IF DESIRED
SGLLB==.-XPALKB-1		;LENGTH OF SEGCON LOOKUP BLOCK

XPAUN1:! 0
XPAUN2:! 0
XPAUXT:! 0		;EXTENSION (MAYBE NONE) OFFERED BY USER
XPANEW:! 0		;LICENSES TO PASS,,NEW CORE ARGUMENT
XPALIC:! 0		;HISEG LICENSE,,LOWSEG LICENSE FROM FILES
XPAHPD:! 0		;PLACE TO REMEMBER FIRST PID SEEN
XPACOM:! 0		;PLACE TO SAVE IO COMMAND WORD
SGLEB==.-XPAMOD		;LENGTH ENTIRE BLOCK
	DEPHASE

COMMENT ! REGISTER PG IS SET TO POINT TO THE BASE OF THIS BLOCK
 BY SAVARG ROUTINE. REGISTER P IS ADVANCED TO POINT TO THE WORD
 FOLLOWING THE BLOCK. IN GENERAL THE
 PDL LOOKS LIKE THIS:
	FLAGS,,RETURN ADDR	;NOT NEEDED.
	XPAMOD	-B	<------(PG)
	.	 L
	.	 O
	.	 C
	XPACOM	-K
	.
	DATA PUSHED P, AFTER ARG BLOCK SETUP
	.	<-----(P)
!
SUBTTL ARGUMENT SETUP ROUTINES


COMMENT @ SUBROUTINE GTUARG

FUNCTION: GET USER ARGS FROM HIS CORE TO EXEC PDL FOR
	RUN,RUNSEG/GETSEG. RETURN (PG) SETUP TO POINT
	TO THE ARG BLOCK IN PDL. SETUP XPACOM, XPAMOD

CALL:	MOVE T1,<CONTENTS OF USER AC> T1/ ADDR INCR,,ARG BLOCK
	PUSHJ P,GTUARG
	RETURN HERE ALWAYS. (PG) BEGINS THE ARG BLOCK
			     (P2)=FILENAME ALSO IN XPANAM(PG)


CALLS: SAVARG,SG2A,SG3
RESTRICTIONS:
DESTROYS:	T1,T2,T3,T4,P1,P2,P3,P4,W,U, RH(M), PG
PRESERVES:
			 PRESERVES LH AC "M"--VERY IMPORTANT.
	EVERYONE IN THIS MODULE MUST PRESERVE LH OF M INCASE
	ERROR EXIT NEEDS TO BE TAKEN. SGRELE EXPECTS LH(M)
	TO CONTAIN ORIGINAL LH(UPTMUU): USER AC #.

	AT (P)----> START-INCREMENT,,USER ARGBLOCK ADDR

@


GTUARG::
	HRR	M,T1		;MOVE ADR. OF ARG LIST TO M
	MOVE	T2,T1		;SAVE FOR START INCR IN LH
	UMOVE	U,0(M)		;DEVICE NAME
	UMOVE   P2,1(M)		;FILENAME
	UMOVE	P1,2(M)		;EXTENSION
	UMOVE	T4,4(M)		;PPN
	UMOVE	T3,5(M)		;LICENSE TO PASS,,CORE REQUESTED
	JUMPE	T4,GETARG	;NO PPN SPECIFIED
	TLNE	T4,-1		;REAL PPN?
	  JRST	GETARG		;YES. 
	UMOVE	P3,(T4)		;GET FIRST WORD OF USER NAME
	UMOVE	P4,1(T4)	;GET SECOND WORD OF USER NAME
	MOVEI	T4,1		;INDICATE USER NAME, NOT PPN
GETARG:
	TLZ	W,NOSHR!HSLIC!LSLIC	;CLEAR FLAGS IN MODE WORD
	HRRI	W,DR		;SET DUMP RECORDS MODE (MAGTAPE!)
	JSP	T1,SAVARG	;PUT THINGS IN PDL, SETUP PG/BLOCK ADDR
	PUSH	P,T2		;START-INCR,USERBLOCK
	XCTBU	<HLLZS JOBCOR>
	PUSHJ	P,SG3
	JRST	@-1(PG)		;RETURN TO OUR CALLER.

COMMENT	@ SUBROUTINE GNUARG
; ROUTINE TO SAVE ARGUMENTS FOR GET/RUN/SAVE FRMOPS, ETC. IN PDL.
; THE ARGUMENTS ARE RETURNED ON THE STACK, P IS ADVENCED PAST END OF
; BLOCK SO THINGS CAN STILL BE PUSHED; PG POINTS TO BASE OF ARG BLOCK
; ON STACK - ACCESS TO ARGUMENTS SHOULD BE RELATIVE TO PG NOT P.
; THE STRUCTURE OF THE PDL IS DESCRIBED BEGINNING AT XPAMOD:! .

EXPECTS:	
	W/	FLAGS,,???
	M/	ADDR OF USER ARGUMENT [-CNT,,ADR]

CALL:	PUSHJ	P,GNUARG	;WARNING - MUNGS STACK
	  error return		;stack restored
	success return		;stack munged

RESTRICTIONS:	MUNGS STACK!
DESTROYS:	T1,T2,U,RH(W),PG
PRESERVES:

@

	XPAUN1(PG)		;UN1
	XPAUN2(PG)		;UN2
GNUTAB:	; table of argument destinations 
	(P)			;START INCR IN LH
	XPADEV(PG)		;DEVICE
	XPAPPN(PG)		;PPN
	XPANAM(PG)		;NAME
	XPAUXT(PG)		;EXTENSION
	XPANEW(PG)		;CORE (NEW)
GNULEN==.-GNUTAB

GNUARG::
	HRRI	W,DR		;DUMP RECORDS MODE
	EXCH	W,(P)		;W _ RETURN ADDRESS; (P) _ FLAGS
	MOVE	PG,P		;PG/-XX,,BASE OF ARG BLOCK
	ADD	P,[SGLEB,,SGLEB];ADVANCE STACK PAST BLOCK
	JUMPGE	P,GNUPDL	;CRASH IF WE OVERFLOWED
				;NOTE - P REALLY ONE PAST WHAT IT NEEDS
				;TO BE, THIS IS FOR THE START INCR
	
	UMOVE	T2,(M)		;GET THE ARGUMENT COUNT
	HRRO	T1,M		;PUT THE ADDRESS IN RH (OF WORD 0)
	TLC	T1,(T2)		;T1/ -<CNT+1>,,ADR FOR USER BLOCK
	MOVE	T2,[XWD -GNULEN,GNUTAB] ;DESTINATION INDEX
GNUALP: UMOVE	U,(T1)		;GET THE DATA WORD
	MOVEM	U,@(T2)		;SAVE IT ON PDL
	AOBJP	T1,GNUA1	;UPDATE USER POINTER (IF OVERFLOW, DONE)
	AOBJN	T2,GNUALP	;UPDATE OUR POINTER (IF OVERFLOW, ERR)
				; BAD ARGUMENT COUNT ERROR
	MOVE	P,PG		;RESTORE STACK
	EXCH	W,(P)		;RESTORE RETURN ADDRESS
	POPJ	P,		;ERROR RETURN

	SETZM	@(T2)		;ZERO OUT THE UNSPECIFIED STUFF
GNUA1:	AOBJN	T2,.-1		;ANY UNSPECIFIED STUFF LEFT?
	
	MOVEI	T2,GNUTAB	;ADR OF TABLE FOR GNUPPN
	PUSHJ	P,GNUPPN	;GET USERNAME IF LH(PPN) IS 0
GNUA2:	SETZM	XPALIC(PG)	;GET LICENSES OFF FILES
	JRST	1(W)		;SKIP RETURN (SIC)

GNUPDL:	STOPCD			;PDL OV WHILE STACKING GET/RUN/SAVE ARGS


; CALL GNUPPN TO MAKE SURE THE PPN IS REAL, IF NOT, IT WILL FETCH
; THE USERNAME THROUGH TABLE-1,-2
;	T2/ ADDR OF DESTINATION TABLE

GNUPPN:	SKIPE	T1,@2(T2)	;GET PPN
	 TLNE	T1,-1		;IS IT A USER NAME?
	  POPJ	P,		; REAL PPN or NULL (leave it alone)
	UMOVE	U,0(T1)		;GET FIRST WORD
	MOVEM	U,@-2(T2)	;SAVE IT
	UMOVE	U,1(T1)		;GET SECOND WORD
	MOVEM	U,@-1(T2)	;SAVE IT
	MOVEI	U,1		;CODE 1 FOR PPN MEANS USE UN1,UN2
	MOVEM	U,@2(T2)	;SAVE IT
	POPJ	P,

COMMENT	@ SUBROUTINE GNUARX
; ROUTINE TO SAVE ARGUMENTS FOR GET/RUN/SAVE FRMOPS, ETC. IN %UPX+UPTXAC

EXPECTS:	
	W/	FLAGS,,???
	M/	ADDR OF USER ARGUMENT [-CNT,,ADR]
	%UPX ALL SET UP AND LOCKED

CALL:	PUSHJ	P,GNUARG	
	  error return		
	success return		

RESTRICTIONS:	
DESTROYS:	T1,T2,U,RH(W),PG
PRESERVES:

@

EXTERNAL %UPX

	%UPX+UPTXAC+P3		;UN1
	%UPX+UPTXAC+P4		;UN2
GNUTBX:	; table of argument destinations 
	%UPX+UPTXAC+S		;START INCR IN LH
	%UPX+UPTXAC+U		;DEVICE
	%UPX+UPTXAC+T4		;PPN
	%UPX+UPTXAC+P2		;NAME
	%UPX+UPTXAC+P1		;EXTENSION
	%UPX+UPTXAC+T3		;CORE (NEW)
GNULNX==.-GNUTBX

GNUARX::
	HRRI	W,DR		;DUMP RECORDS MODE
	MOVEM	W,%UPT+UPTXAC+W	;MODE AND FLAGS
	UMOVE	T2,(M)		;GET THE ARGUMENT COUNT
	HRRO	T1,M		;PUT THE ADDRESS IN RH (OF WORD 0)
	TLC	T1,(T2)		;T1/ -<CNT+1>,,ADR FOR USER BLOCK
	MOVE	T2,[XWDLNX,GNUTBX] ;DESTINATION INDEX
GNUAXL: UMOVE	U,(T1)		;GET THE DATA WORD
	MOVEM	U,@(T2)		;SAVE IT IN %UPX
	AOBJP	T1,GNUAX1	;UPDATE USER POINTER (IF OVERFLOW, DONE)
	AOBJN	T2,GNUAXL	;UPDATE OUR POINTER (IF OVERFLOW, ERR)
				; BAD ARGUMENT COUNT ERROR
	POPJ	P,		;ERROR RETURN

	SETZM	@(T2)		;ZERO OUT THE UNSPECIFIED STUFF
GNUAX1:	AOBJN	T2,.-1		;ANY UNSPECIFIED STUFF LEFT?
	
	MOVEI	T2,GNUTBX	;ADR OF TABLE FOR GNUPPN
	PUSHJ	P,GNUPPN	;GET USERNAME IF LH(PPN) IS 0
	MOVEM	W,%UPX+UPTXAC+W	;SAVE FLAGS AND MODE
	JRST	CPOPJ1

COMMENT ! ROUTINE SETOPN
FUNCTION: SETUP T1-T3 FOR OPEN OF RUNCHN
EXPECTS: PG/BLOCK IN PDL
!
SETOPN:
	MOVE T1,XPAMOD(PG)
	MOVE T2,XPADEV(PG)
	MOVEI T3,0		;ALWAYS IN DR MODE, NO BUFF HDRS
	POPJ P,


COMMENT ! ROUTINE SETACS - FOR SAVJOB ONLY
FUNCTION: SET UP T1-T3 FOR OPEN, P1-P4 FOR SHORT ENTER BLOCK
!
SETACS: PUSHJ P,SETOPN
	MOVE P1,XPANAM(PG)
	MOVE P2,XPAUXT(PG)
	MOVEI P3,0		;DATE, ALWAYS CURRENT
	MOVE P4,XPAPPN(PG)
	CAIN P4,1
	HRRI P4,XPAUN1(PG)
	POPJ P,
COMMENT @ SUBROUTINE SAVARG
; ROUTINE TO SAVE ARGUMENTS FROM COMMAND STRING IN PDL
;  ARGUMENTS ARE DEFINED RELATIVE TO BASE REGISTER PG
;

CALL:	GET ACS LOADED FROM UPTXAC (RUN/GET CMD..SGSET)
	OR
	GET ACS LOADED FROM USER CORE (UUOS..GTUARG)
	JSP T1,SAVARG
	RETURN HERE. (P) ADVANCED PAST END OF BLOCK
			(PG) POINTS AT BLOCK

RESTRICTIONS:
DESTROYS:

@


SAVARG:
	PUSH P,W	;MODE+FLAGS
	MOVE PG,P	;PG/-XX,,BASE ADDR OF ARG BLOCK
	ADD P,[SGLEB-1,,SGLEB-1];ADV P PAST ENTIRE BLOCK
	JUMPGE P,SVARG2	;PDL OV
	MOVEM U,XPADEV(PG)
	MOVEM T4,XPAPPN(PG)	;PPN OR CODE 1
	MOVEM P2,XPANAM(PG)
	MOVEM P1,XPAUXT(PG)
	MOVEM P3,XPAUN1(PG)
	MOVEM P4,XPAUN2(PG)
	MOVEM T3,XPANEW(PG)	;LICENSES TO PASS,NEW CORE ALLOC
	SETZM XPALIC(PG)	;HI&LOW SEG LICENSES FROM FILES
	JRST (T1)	;RETURN TO OUR CALLER
;NOTE: AFTER RETURNING, GARBAGE STILL LIES IN THE LOCATIONS
; IN BLOCK NOT EXPLICITLY SET. SETLKB CLEARS THIS


SVARG2:	STOPCD		;OVERFLEW PDL!
COMMENT @ ROUTINE SGSET AND SGSETD

FUNCTION: GET THE "RUN","SAVE","SSAVE","GET"
	COMMAND ARGS TO UPTXAC  AREA THEN SCHEDULE
	THE APPROPRIATE MONITOR JOB.

CALLERS:	SGSETD:  SAVE/SSAVE ONLY
		SGSET:	 GET, RUNCOM
	NOTE: IMPLICIT "RUN" COMMANDS (LOGIN,LOGOUT,RESRUN..)
		COME THRU THERE TOO.

CALL:	MOVE S,XWD FLAGS, ADDR OF MONITOR JOB TO RUN
	MOVSI T2,DEVICE NAME
	MOVE W, PHONLY BIT IF NEEDED (KJOB)
	MOVE J,JOB NO. OF JOB TYPING THIS COMMAND
	SET JBTNAM(J) AS APPROPRIATE..0 OR FILENAME
	PJRST SGSET

EXIT:	THIS JOB SET TO RUN THE MONITOR JOB IN S
	RETURN TO CLOCK LEVEL COMMAND PROCESSING

DESTROYS:
RESTRICTIONS:
CALLS: CTEXT,CTEX1,PJPGNO,MAPUPS,COMTYS,DECIN1

LOCATIONS SET: SGSET LEAVES DATA IN THESE LOCS, WHICH GETS
PICKED UP INTO THE INDICATED ACS WHEN THE MONJOB RUNS.
XGADEV..U	XGAMOD..W	XGAPPN..T4	XGAEXT..P1
XGANAM..P2	XGANEW..T3	XGAUN1..P3	XGAUN2..P4

JBTNAM(J) IS ALSO SET UPON EXIT

FLAGS & OTHER ARGS:
SAVE/SSAVE CALL.. S_<0 OR NSRBIT>,,SAVJOB; JBTNAM(J)_0
GET CALL..S_0,,GETJOB; JBTNAM(J)_0; T2_"DSK"
RUNCOM CALL..(ALSO RCOM,ARCOM,RESRUN)
	S_1B16,,RUNJOB  THIS 1B16 TELLS PJPGNO TO PICK UP
		%UPT+UPTRPN FOR PPN. RESTR CMD MODE
	S_1B17,,RUNJB2 KJOB RUN ENTRY+1 ON LOGOUT
	S_0,,RUNJOB NORMAL RUN ENTRY+0
	T2_"DSK" OR "SYS"
	JBTNAM(J)_0 OR FILENAME

@

SGSETD::	MOVSI T2,'DSK';ASSUME DSK
SGSET::	PUSH P,T2	;SAVE DEVICE NAME
	PUSHJ P,MAPUPS	;MAKE LMAP&UPT ADDR'ABLE IN EXEC SLOT
			;(DESTROY T1-T4,PG ONLY)
	POP P,XGADEV	;PUT DEVICE AWAY FOR MON JOB
	SETZM %UPS+UPTPID	;CLEAR PID AND SAVED PID FOR RUN GET AND
	SETZM %UPS+UPTSPD	; SAVE COMMANDS.
	AND W,[XWD PHONLY,0]	;SAVE PHONLY
	TLNE	S,NSRBIT
	TLO	W,NOSHR		;INDICATE NON-SHAREABLE HIGH SEG
	MOVEM W,XGAMOD	;SAVE PHYSICAL ONLY BIT
	PUSHJ P,CTEXT1	;GET T2/SIXBIT TEXT
	JUMPE T2,SGSET4	;SEE IF "(DIRECTORY)"
	CAIE T3,":"		;END WITH :?
	JRST SGSETF		;NO
	MOVEM T2,XGADEV
	PUSHJ P,CTEXT
SGSETF:	SKIPN T2
	MOVE T2,JBTNAM(J)
	JUMPE T2,NOTENF
	SETZM XGAPPN
SGSET3:
	MOVEM T2,JBTNAM(J)	;SAVE FILE NAME FOR SYSTAT COMMAND
	MOVEM T2,XGANAM		;FOR LATER PICKUP BY SETACS
	MOVEI T2,0		;ASSUME USER DID NOT SPECIFY AN EXTENSION
				; 0 WILL BE TURNED INTO SAV OR DMP
	CAIN T3,"."		;IS AN EXTENSION SPECIFIED
	PUSHJ P,CTEXT		;YES. GET EXTENSION
	HLRZS T2		;SEE IF THE USER
	CAIE T2,(SIXBIT /SHR/)  ;HAS SPECIFIED AN
	CAIN T2,(SIXBIT /HGH/)  ;IMPROPER LOW EXTENSION
	JRST SGSET5		;COMPLAIN
	CAIN T2,(SIXBIT/SWR/)	;WRITEABLE HISEG?
	JRST SGSET5		;YES,COMPLAIN
	HRLZM T2,XGAEXT		;STORE IT FOR LOOKUP
	PUSHJ P,PJPGNO		;GET PROJ. PROG. NO.
	SKIPE P2		;DO NOT STORE IF NONE
	MOVEM P2,XGAPPN	;STORE 0 IF NO []'S TYPED BY USER
	PUSHJ P,DECIN1	;AMOUNT OF CORE (OPTIONAL THIRD ARG.) IN 1K BLOCKS
	JRST SGSET1		;DOES NOT RETURN IF ERROR, RETURN HERE IF NO ARG. T2/0
	JRST COMERA		;ILLEGAL CHARACTER
	JUMPE T2,COMERR
	MOVEI T1,^D10
	CAILE T3," "	;IF HE GAVE AN ARG WITHOUT "P" OR "K"
	CAIN T3,"K"
	JRST SGSET2	;OR WITH "K", SHIFT ^D10
	MOVEI T1,^D9	;ELSE 9 IF "P"
	CAIE T3,"P"	;MEANS PAGES
	JRST COMERR	;HE TERMINATED WITH SOMETHING ELSE
SGSET2:	LSH T2,(T1)	;CONVERT TO WORDS
	SUBI T2,1
	CAILE T2,777777	;BOMB IF HE SAID MORE THAN ALL OF CORE
	JRST COMERR
SGSET1:	HRRZM T2,XGANEW		;LICENSE_0,,CORE_WORDS FROM ARG TYPED
	HRRZ T2,S		;SCHEDULE MONITOR JOB
				; GUARRANTEE LH OF PC WORD IS 0, SINCE IT WILL
				; BE ADDED TO STARTING ADDRESS(IF RUN COM)
	JRST MSTART		;START JOB WITH PC IN MONITOR MODE

;READ (USERNAME),STICK IN XGAUN1,2

SGSET4:	MOVE T3,TTCMCH
	CAIE T3,"("
	JRST SGSETF
	MOVSI T2,'DSK'
	MOVEM T2,XGADEV
	MOVSI P2,(POINT 6,0)
	HRRI P2,XGAUN1
	MOVEI T2,1
	MOVEM T2,XGAPPN
	MOVEI T2,^D12		;MAX NUMBER OF CHRS
	SETZM XGAUN1
	SETZM XGAUN2
RUNM1:	PUSHJ P,COMTYS
	CAIG T3,40
	JRST NOTENF	;DID NOT FINISH
	CAIN T3,")"
	JRST UNMDN
	SUBI T3,40
	SOJL T2,RUNM1
	IDPB T3,P2
	JRST RUNM1
;TERMINATING ")" RECEIVED
UNMDN:	PUSHJ P,COMTYS	;SKIP )
	PUSHJ P,CTEXT1	;GET FILE NAME
	JUMPN T2,SGSET3
	JRST NOTENF
SGSET5:	;USER TYPED RUN[GET/SAVE/SSAVE] FILE.[SHR/HGH/SWR]
	JSP T1,ERRMES
	ASCIZ /
PLEASE DONT SPECIFY A HISEGMENT EXTENSION/

; EXEC AC LOCATION DEFINITIONS FOR PASSING PARAMETERS
; BETWEEN COMMAND LEVEL AND UUO LEVEL.

DEFINE XX(A,B)
<A==B>
	XX 	XGADEV,%UPS+UPTXAC+U
	XX	XGAMOD,%UPS+UPTXAC+W
	XX	XGAPPN,%UPS+UPTXAC+T4
	XX	XGAEXT,%UPS+UPTXAC+P1
	XX	XGANAM,%UPS+UPTXAC+P2
	XX	XGANEW,%UPS+UPTXAC+T3
	XX	XGAUN1,%UPS+UPTXAC+P3
	XX	XGAUN2,%UPS+UPTXAC+P4
COMMENT % ROUTINES SG1,SG3

FUNCTION:	FOR SAVJOB,RUNJOB,RUNJB2 SG1 SETS UP THE
	FAMILIAR PDL STRUCTURE WITH ARG BLOCK POINTED TO
	BY PG, DIDDLES FLAGS IN XPAMOD, DOES RESET, ETC.

	SG3 DOES: XPACOM(PG)_(IF (DDT OR JOBFF-1>UPTREL)
		THEN (-UPTREL+JOBSVM,,JOBSVM)
		ELSE (1-JOBFF+JOBSVM,,JOBSVM)  )

IMPORTANT: THIS IS WHERE IO MODE GETS SET TO DR=16. DUMP RECORDS.
	FOR DISK, THIS MODE = DUMP. BUT FOR MAGTAPE, THIS MODE
	MAKES A BIG DIFFERENCE. CODE IN READLS AND READHS
	ASSUMES THAT DATA IS ON TAPE THIS WAY. READLS READS
	IOWD WORDS FROM TAPE OR UNTIL EOF. EOF EXPECTED AFTER
	HI AND LO SEGS ON TAPE.

	THE JRST@ -1(PG) EXIT RETURNS CONTROL TO SG1'S CALLER.

CALL:	JSP T2,SG1..
	PUSHJ P,SG3..
RETURNS: A CALL FROM LOC:  JSP T2,SG1 LEAVES PDL AS FOLLOWS ON RETURN:

	FLAGS,,LOC+1	(NOT NEEDED ONCE SG1 HAS RETURNED)
	XPAMOD		<-----(PG)
	 ..
	 ..
	XPACOM		<-----(P)
%


SG1:	JSP T1,MONSTR		;SETUP J,P,PUSH T2,T1
	JSP T1,SAVARG		;SAVE ARGUMENTS IN PDL
	MOVSI T1,LMMEXS		;IF VP 0 DOES NOT EXIST,
	TDNE T1,%UPLMA+0	;BETTER CREATE IT SO THAT
	JRST SG1A		;ALL REFS TO JOBDATA AREA WILL
	SETZB T1,T2		;SUCCEED. FROM T1/0 TO T2/0,
	PUSHJ P,CORXPN		;CREATE. CLOB T1,W
	JRST [PUSH P,[0]	;CANT CREATE PG 0, COMPLAIN.
		JSP T1, NOROOM]
	MOVEI T1,777
	HRRM T1,%UPT+UPTREL
SG1A:

	CALLI 0		;RESET
	MOVE W,XPAMOD(PG)	;GET PHYSICAL ONLY FLAG
	HRRI W,DR		;DUMP RECORD MODE = 16 (FOR MAGTAPE'S BENEFIT)
	AND W,[XWD PHONLY!NOSHR,-1] ;NOTE HSLIC,LSLIC_0 HERE
	MOVEM W,XPAMOD(PG)
	XCTBU <HLLZS JOBCOR>	;SO CKSARG WILL WORK ?
				; WORK ON FIRST CALL(SAVE AND GET)
	PUSHJ	P,SG3
	JRST @-1(PG)		;RETURN



SG3::	

	UMOVE T1,JOBFF	;FIRST FREE LOC IN JOB(SET FROM LH OF
				; JOBSA WHICH IS SET BY LOADER
	MOVEI T1,-1(T1)	;MAKE LAST LOC TO SAVE OR GET(MAKE 0=777777)
	XCTBU <SKIPN JOBDDT>  ;SAVE ALL IF DDT IN USE
	XCTBU <CAMLE	T1,JOBREL>	;NO, ADDRESS TOO LARGE?
	UMOVE T1,JOBREL		;YES, DUMP ALL OF CORE RATHER THAN GIVE
				; ADDRESS CHECK MESSAGE-HIGHEST REL.ADR.
	MOVNS T1		;-HIGHEST ADR TO SAVE OR GET
	ADDI T1,JOBSVM		;LOWER CORE NOT DUMPED
	HRLI T1,JOBSVM		;IE FIRST LOC-1 TO BE DUMPED
	MOVSM T1,XPACOM(PG)	;STORE IOWD WORD OF THIS SIZE CORE

	POPJ P,

COMMENT ! CHANGE LINES 5400:5500 IF LH UPTREL EVER USED
	FOR ANYTHING !
SUBTTL UTILITY ROUTINES
COMMENT @ SOBROUTINE SGDO
FUNCTION: EXECUTE THE INPUT/OUTPUT UUO AT (P), CHECK FOR
	IO ERRORS & ABORT IF SO (NO RETURN TO SGDO CALLER)
	EXPAND LOWSEG CORE IF NEEDED, & RETURN.
CALL:	SETUP DUMP MODE IOLIST
	PUSHJ P,SGDO
	INPUT/OUTPUT UUO
	RETURN HERE IF NO ERRORS, CORE EXPANDED
RESTRICTIONS:
CALLS: EXPAND,SGIOCK
DESTROYS:

@


SGDO:	XCT @(P)		;EXECUTE INPUT OR OUTPUT M
	PUSHJ	P,SGIOCK	;CHECK FOR ERRORS ON IO
	PUSHJ P,EXPAND	;EXPAND CORE IMAGE
	MOVSI	T1,XPNCOR	;CLEAR CORE EXPANDED BIT
	ANDCAM	T1,%UPT+UPTSTS
	AOS (P)		;SKIP OVER M IN CALLING SEQUENCE
	POPJ	P,


COMMENT @ SUBROUTINE SGIOCK
FUNCTION: CHECK IF ANY OF IOBKTL,IODTER,IODERR,IOMPM HAPPENED
	ON LAST UUO FOR CHANNEL RUNCHN. IF NO, RETURN. IF
	YES, RETURN TO USER OR CMD LEVEL, NO RETURN TO
	SGIOCK CALLER.
DESTROYS:	S,T1.
RETURNS: S/ IO STATUS FOR RUNCHN
CALL:	PUSHJ P,SGIOCK
	RETURN HERE IO OK, S/STATUS
RESTRICIONS:
CALLS: SGRELE TO DECIDE WHERE TO GO FOR THE ERROR RETURN


RIBERB:	ENTRY RIBERB USED WHEN LOOKUP FINDS FILE WITH RIBSTS
		ERROR BITS. FAKES A TRANSMISSION ERROR.

MAPIOF:	ENTRY MAPIOF FOR USE WHEN VMAP UUO RETURNS
	ERROR CODE FOR CONDITION WHICH WOULD HAVE GIVEN IOIMPM,
	IODTER, ETC WITH INPUT UUO UNDER OLD MONITOR. VMAP SETS
	NO DEVIOS BITS.
@

SGIOCK::
	GETSTS RUNCHN,S	
	TRNN S,IOBKTL!IODTER!IODERR!IOIMPM	;ANY ERRORS ON SAVE-GET DEVICE?
	POPJ P,		;NO, GIVE OK RETURN
RIBERB:
MAPIOF:	MOVEI T1,TRNERR	;YES, ERROR CODE IN CASE THIS IS RUN UUO
				; (TRANSMISSION ERROR)
	PUSHJ P,SGRELE	;RELEASE DEVICE AND ERROR RETURN TO USER IF RUN M
			; OR RETURN HERE.
	MOVE	P3,XPANAM(PG)	;Error exit wants file name
	HLLZ	P4,XPAEXT(PG)	; and extension for type-out
	PJRST	ERRTRE		;PRINT TRANSMISSION ERROR MESSAGE.

COMMENT ! ROUTINE DOLOOK
FUNCTION: SETUP THE LOOKUP BLOCK, DO THE EXTENDED LOOKUP
	CK RIB ERROR BITS, FAKE A TRANSMISSION ERROR IF ANY ON.
	RETURN THINGS IN P2-P4
EXPECTS: T1/EXT TO TRY
	PG/ BLOCK
	XPANAM,XPAPPN,XPAUN1,UN2 SET
DESTROYS: T1,P2,P3,P4
RETURNS: NOSKIP IF LOOKUP FAILED
	 NORETURN IF RIB ERROR BITS
	 SKIP RETURN P2/0,,EXT
		     P3/FILE PROT BITS 27-35
		   P4/SIZE IN WORDS
!
DOLOOK:	MOVEM T1,XPAEXT(PG)
	MOVE T1,XPAPPN(PG)
	CAIN T1,1
	HRRI T1,XPAUN1(PG)
	MOVEM T1,XPAPPN(PG)
	MOVEI T1,UUPPID+SGLLB	;GET COUNT, FLAG PID ACCESS.
	MOVEM T1,XPALKB(PG)
	MOVSI T1,XPAPRV(PG)
	HRRI T1,XPAPRV+1(PG)
	SETZM -1(T1)
	BLT T1,XPALKB+SGLLB(PG)	;ZERO OUT FROM XPAPRV TO END
	LOOKUP RUNCHN,XPALKB(PG)
	 POPJ P,
	MOVE T1,XPASTS(PG)	;RIB STATUS BITS
	TRNE T1,BADBIT
	JRST RIBERB		;FAIL,FAKE TRANSMISSION ERROR
	HLRZ P2,XPAEXT(PG)
	MOVE P4,XPASIZ(PG)
	LDB P3,[POINT 9,XPAPRV(PG),8]
	JRST CPOPJ1
COMMENT @ SUBROUTINE CKIOWD
FUNCTION: VERIFY THAT XPANEW (USER CORE ARG) IF GIVEN IS
	AT LEAST LARGE AS SIZE OF THE FILE TO BE READ. IF
	NOT CAUSE "XX PAGES NEEDED" & STOP,
	(OR FRETURN TO RUNUUO WITH NECERR 'NOT ENUF CORE')
CALL:	HRLE T2,-NO WORDS IN FILE
	PUSHJ P,CKIOWD
	RETURN HERE T1/ MAX(XPANEW,WORDS IN FILE) IOR 1777
FAIL:	NO RETURN TO CKIOWD CALLER--EXIT THRU SGRELE
DESTROYS:
RESTRICTIONS:
@

CKIOWD:	MOVEI T1,JOBSVM	;FIRST LOC-1 READ OR WRITTEN IN USER AREA
	SUB T1,T2		;HIGHEST LOC=FIRST LOC-1+LENGTH OF FILE
				; FALL INTO CKSARG

COMMENT @ SUBROUTINE CKSARG
FUNCTION: VERIFY THAT XPANEW (IF GIVEN (NON-ZERO)), IS AT
	LEAST AS LARGE AS JOBCOR VALUE PASSED IN T1.
	IF NOT, FRETURN THRU SGRELE TO CMD/USER, NO
	RETURN TO CKSARG CALLER. IF YES, RETURN
	T1/ MAX(XPANEW,JOBCOR)
RESTRICTION: JOBDAT MUST HAVE BEEN INITIALIZED BEFORE
	JOBCOR VALUE PICKED UP & PASSED TO CKSARG.
	COULD BE INIT'ZD FROM VESTIG. JOBDAT BY INIJDA.
CALL:	UHRRZ T1,JOBCOR
	PUSHJ P,CKSARG
	RETURN HERE T1/ MAX(XPANEW,JOBCOR) IOR 1777

@

CKSARG:	IORI T1,1777		;MAKE SURE 1K-1
	PUSH P,T1		;SAVE IT (ALSO CORRECT PLACE FOR NOROOM)
	HRRZ T1,XPANEW(PG)	;GET REQUESTED
	JUMPE T1,TPOPJ		;NONE, USE SIZE FROM FILE
	IORI T1,1777		;USER CORE ARG 1K INCREMENTS
	CAMGE T1,(P)		;DOES HE WANT AT LEAST WHATS NEEDED?
	JSP T1, NOROOM		;NO, ERROR
	MOVEM T1,(P)		;YES, SAVE IT
	JRST TPOPJ		;AND RETURN

COMMENT @ ERROR EXIT NOROOM
FUNCTION: FRETURN TO USER WITH NECERR OR TO CMD LEVEL
	WITH "XX PAGES NEEDED" MSG. NO RETURN TO NOROOM CALLER.
CALL:	PUSH P,WORDS USER CORE REQ WHICH FAILED/WAS BAD
	JRST NOROOM
NOTE: MANY PLACES JSP T1,NOROOM AS AN AID TO DEBUGGING

RESTRICTIONS:
@

NOROOM:	MOVEI T1,NECERR	;ERROR CODE IN CASE THIS IS RUN M(NOT ENOUGH CORE)
	PUSHJ P,SGRELE	;RELEASE DEVICE AND ERROR RETURN TO USER IF RUN M
			; OR RETURN HERE.
	POP P,M		;GET AMOUNT OF CORE REQUESTED
	LSH	M,-^D9	;TURN TO PAGES.
	ADDI	M,1	;ADD 1
	PJRST	ERRPGN		;PRINT N PAGES NEEDED.





COMMENT @ ERROR EXIT SGERRA
FUNCTION:	TO FAIL-RETURN TO USER/CMD LEVEL WHEN
	OPEN UUO FAILS FOR A CMD/UUO. DECISION HOW TO
	RETURN MADE BY SGRELE.
@
SGERRA:	MOVEI T1,DNAERR	;ERROR CODE IN CASE RUN UUO(DEVICE NOT AVAILABLE)
	PUSHJ P,SGRELE	;RETURN TO USER IF RUN UUO
			; OR RETURN HERE.
	MOVEI	F,XPADEV-DEVNAM(PG) ;SO DEVNAM(F) GIVES DEVICE NAME.
	PJRST	ERRDNA		;PRINT DEVICE XXX NOT AVAILABLE




COMMENT @ ERROR EXIT NOFILE
FUNCTION: TO RETURN TO USER/CMD LEVEL WHEN FILE LOOKUP FAILS.
ENTER:	PDL LOOKUP BLOCK AS RETURNED BY FAILING LOOKUP, PG/BLOCK

@

NOFILE:	MOVEI T1,FNFERR	;ERROR CODE IN CASE THIS IS RUN M(FILE NOT FOUND)
				; CHANGE ERROR CODE TO DISK ERROR CODE IF DEV IS DSK
	PUSHJ P,SGRELL	;RETURN DISK LOOKUP OR ENTER ERROR CODE IF DSK
				; RELEASE DEVICE AND ERROR RETURN TO USER IF HE WANTED
				; OR RETURN HERE.
	MOVE P3,XPANAM(PG)	;GET NAME IN P3
	HLLZ P4,XPAUXT(PG)	;AND EXTENTION IN P4 FOR ERRFNF
	PJRST ERRFNF		;PRINT FILE(.EXT) NOT FOUND
COMMENT @ SUBROUTINE GETCOR
FUNCTION: GIVEN CORUUO ARG IN T1, DO CORE UUO & RETURN THE
	ARG UNCHANGED. IF UUO FAILS, DO "NOROOM" STUFF.
RESTRICTION: WILL NOT THROW AWAY CORE. ONLY USED TO INCREASE
	SIZE OF LOWSEG, NEVER CALLED WITH NON-ZERO
	LH(T1).
@

GETCOR: PUSH P,T1	;SAVE CORE ARG IN CASE OF ERROR
	XCTBU <HRRZ T1,JOBREL>	;CURRENT LOWSEG SIZE
	CAML T1,0(P)		;SKIP IF CURRENT .LT. REQUEST
	JRST TPOPJ		;DONT BOTHER DOING UUO
	MOVE T1,0(P)
	CALLI T1,11		;CORE UUO
	JSP T1, NOROOM		;NOT AVAILABLE, PRINT ERROR AND AMOUNT TRYING FOR
	JRST TPOPJ



COMMENT @ ERROR EXIT GETERR
FUNCTION: FOR EXPAND AND GETJB IF FILE FORMAT APPEARS NOT
 TO BE A SAVE FILE. 
@

GETERR:	MOVEI T1,NSFERR	;ERROR CODE IN CASE THIS IS RUN M(NOT SAVE FILE)
	PUSHJ P,SGRELE	;RELEASE DEVICE AND ERROR RETURN TO USER IF RUN M
	PJRST ERRNSF		;PRINT NOT A SAVE FILE.


;SUBROUTINE TO ADJUST LOW SEG CORE ACCORDING TO ARG
; ON GET OR PREVIOUS SAVE
;CALL:	PUSHJ P,LOWFIN
;	ALWAYS RETURN

LOWFIN:	XCTBU <HRRZ T1,JOBCOR>	;CORE ARG FROM PREVIOUS SAVE(THIS MONITOR
				; ALWAYS STORES SOMETHING)
	SKIPN T1		;IS THIS AN OLD FORMAT FILE WITH NO CORE ARG TO SAVE?
	UMOVE T1,JOBREL		;YES, USE ASSIGNMENT MADE WEN LOW FILE READ IN
	PUSHJ P,CKSARG	;RETURN ONLY IF USER'S SUPLLIED ARG IS 0 OR NOT
				; SMALLER THAN SAVE CORE ARG, RETURN LARGER
	PUSHJ P,GETCOR	;TRY TO GET THIS AMOUNT OF CORE
	UMOVE T1,JOBREL		;HIGHEST LOC ASSIGNED TO LOW SEG
	XCTBU <HRRM T1,JOBCOR>	;SET INITIAL CORE ASSIGNMENT IN JOB DATA AREA FOR
				; USER TO USE TO RESET CORE TO INITIAL SETTING WHEN
				; PROGRAM IS RESTARTED
	POPJ P,
COMMENT @ SUBROUTINE SGRELE, ENTRY SGRELL
FUNCTION: SGRELE RETURNS ERROR CODE IN T1 TO USER UUO FAIL-RETURN,
 IF PC.USR IS ON (THIS IS HOW WE KNOW WHETHER WE CAME FROM A UUO OR
 FROM A CMD..BUT VARIOUS ROUTINES ZERO PC.USR TO FORCE CMD
 FRETURNS) UNLESS A HALT FOLLOWS THE UUO,IN WHICH CASE
 RETURN TO CMD LEVEL.
	ENTRY SGRELL IS TO RETURN DSK LOOKUP ERROR

	IF THE RETURN IS TO CMD LEVEL, CODE RETURNED TO JRSTS OFF TO ERR??? FOR THE ERROR INVOLVED.

	SGRELE RELEASES THE RUNCHN DEVICE.

EXPECTS: PG/BLOCK  M/ USER AC# BITS 4-12   J/JOB
@

SGRELL:				;LOOKUP OR ENTER FAILURE
	MOVE T2,DEVMOD(F)	;IS THIS DEVICE A DISK?
	TLNE T2,DVDSK
	HRRZ T1,XPAEXT(PG)	;YES, RETURN DISK SERVICE ERROR CODE
SGRELE:	MOVE T2,%UPT+UPTPDL	;GET FIRST PC ON PD LIST
	TLNN T2,PC.USR		;IS IT IN USER MODE(IE USER M)?
	JRST SGREL		;NO, MUST BE MONITOR COMMAND OR CALLER OVERLAYED
				; RELEASE DEVICE, FIND TTY, AND RETURN TO CALLER
	LDB M,[POINT 4,M,12] 	;GET CALLING AC NUMBER
	XCTBU <HLRZ T2,(T2)> 	;GET OPCODE OF RETURN INST
	CAIN T2,(HALT)		;RETURNING TO HALT?
	JRST SGREL		;YES, RELEASE DEVICE,FIND TTY, AND RETURN TO CALLER
				;SAVE SPACE GIVEN BACK AT USRXIT
SGRLE2:	
	UMOVEM T1,(M)		;STORE ERROR NUMBER IN USER AC.
	SKIPE %UPT+UPTJDA+RUNCHN;SKIP UNNECESSARY RELEASE
	RELEAS RUNCHN,		;RELEASE DEVICE(IF INITED)
	PUSH P,%UPT+UPTPDL	;PUT RETURN ON END OF PDLIST
	JRST USRXIT		;AND RETURN TO USER TO HANDLE ERROR


COMMENT @ SUBROUTINE SGREL
FUNCTION: RELEASE THE FUNCHN DEVICE IF INITTED. IF MAGTAPE,
	SKIP TO EOF UNLESS END-OF-TAPE.
CALL:	PUSHJ P,SGREL
	RETURN HERE F/ FLAGS,,RUNCHN DDB
DESTROYS: F
RESTRICTIONS:
CALLS: 
CALLERS: SAVGET AND SEGCON STUFF
@

SGREL:	SKIPN F,%UPT+UPTJDA+RUNCHN	;SKIP IF STILL INITTED
	POPJ P,
	PUSH P,T1
	MOVE T1,DEVMOD(F)
	TLNE T1,DVMTA		;MAGTAPE?
	TLNN F,INPB	;YES, WAS AN INPUT DONE?
	JRST SGREL1		;NO
	CLOSE RUNCHN,CLSOUT		;YES, CLOSE MTA INPUT
	STATO RUNCHN,IOTEND+IODEND	;AT END OF APTE?
	MTAPE RUNCHN,16		;NO SKIP TO EOF
SGREL1:	RELEASE RUNCHN,		;NO RELEASE DEVICE
	POP P,T1
	POPJ P,		;RETURN

SUBTTL SAVJOB
COMMENT @ MONITOR JOB SAVJOB - SAVE JOB AREA ON FILE/TAPE
FUNCTION:
	FOR MAGTAPE:
IF HISEG EXISTS SAVE IT UNCOMPRESSED ELSE WRITE A NULL HISEG;
IF LOWSEG EXISTS SAVE IT ZERO-COMPRESSED ELSE
	WRITE A ZERO-COMPRESSED EMPTY LOWSEG;;
PRINT "JOB SAVED";
	
	FOR DISK:
IF HISEG EXISTS THEN BEGIN "HS"
	SAVE IT UNCOMPRESSED ON (FN.HGH IF NOSHR ELSE FN.SHR)
	DELETE OBSELETE .SHR OR .HGH
	IF USER GAVE EXT THEN DONE "HS"
	IF NO LOWSEG REQUIRED THEN DELETE OBSOLETE .LOW & GOTO SAVFIN
	EXT_'LOW'
	END "HS";
SAVE COMPRESSED LOWSEG OF WHATEVER SIZE ON FN.<EXT OR 'SAV'>;
SAVFIN: PRINT "JOB SAVED";
PRINT "JOB SAVED";

ENTRY: MONITOR JOB RUN BY SCHEDULER. MUST SET UP OWN ACS
	ALSO CALLED BY FRMOP AT SAVFMU.
EXIT: CORE UN-COMPRESSED 

IDIOSYNCRACIES:

RESTRICTIONS: EXPECTS PREVIOUS CONTEXT = USER SPACE

DESTROYS:

@

INTERNAL SAVJOB,SAVFRM,SAVFMU

SAVFRM:
SAVJOB: JSP T2,SG1		;SETUP AC P,J,PG,RESET DEVICES
	PUSH P,[0]		;A PLACE FOR SAVE OF EXT OF FILE CREATED
SAVFMU:	PUSHJ P,HSEXIS		;SKIP IF NO HISEG
	SKIPA T2,%UPT+UPTHRL
	JRST SAVJ2
	HRRZS T2
	SUBI T2,377777		;SIZE CURRENT HISEG
	PUSHJ P,ADJCOR		;REDUCE XPANEW (IF GIVEN ) BY SIZE CURR HISEG
SAVJ2:	HLRO T2,XPACOM(PG)	;SET BY SG3 VIA SG1 CALL
		;TO [JOBSVM-(C(JOBFF)-1)] OR [JOBSVM-C(UPTREL)]
	PUSHJ P,CKIOWD	;VALIDATE XPANEW,RETURN T1/MAX(REAL SIZE,XPANEW)
	XCTBU <HRRM T1,JOBCOR>	;WHEN FILE GOTTEN THIS WILL BE USED
	PUSHJ P,SETACS
	OPEN RUNCHN,T1
	 JRST SGERRA
	MOVE F,%UPT+UPTJDA+RUNCHN
;IF NO HISEG THEN BEGIN IF DVMTA THEN SAVNUL END
	PUSHJ P,HSEXIS
	JRST SAVJ3
	MOVE T4,DEVMOD(F)
	TLNE T4,DVMTA
	PUSHJ P,SAVNUL	;DESTROYS MANY ACS
	JRST SAVJB5
;ELSE BEGIN /*HISEG EXISTS*/
SAVJ3:	PUSHJ P,SETACS		;GETS T1, P1-P4 AGAIN
	MOVSI P2,'SHR'
	TLNE T1,NOSHR		;FROM SGSET. OFF IF SSAVE CMD
	MOVSI P2,'HGH'
	ENTER RUNCHN,P1
	JRST SAVERR
	HLLM P2,0(P)	;REMEMBER THE EXT WE CREATED
	HRRZ T2,%UPT+UPTHRL	;NON-ZERO SINCE WE KNOW HS EXISTS
	SUBI T2,377777	;T2/ 1ST FREE IN HS,RELATIVE TO 400000
	XCTFU <HLLZ T1,JOBHRL> ;FIRST FREE IN HISEG,SET BY LOADER
	TLNE T1,-1	;HAS LOADER SET IT OR WAS THIS SEG CREATED
	XCTFU <SKIPE JOBDDT>;BY REMAP? IS USER USING DDT?
	XCTBU <HRLM T2,JOBHRL> ;SET 1ST FREE TO 1 PAST END
;IF HISEG NOT LOADED FROM .SWR FILE AND USER HAS WRITE (OR COW) PRIV
; ON HISEG (TEST PG 400 ONLY),INIT'ZE VESTIGIAL JOBDATA AREA.

	MOVE T1,%UPT+UPTSTS
	TLNE T1,SG.SWR
	JRST SAVJB4
	MOVE T1,[<CPRRDW>B7+1B17+400]
	VPROT T1,
	SKIPA		;SIGH. SEE IF WE CAN MAKE IT COW FOR HIM
	JRST SAVJB3	;RDW SUCCEEDED. INIT'ZE.
	MOVE T1,[<CPRCOW>B7+1B17+400]
	VPROT T1,
	 JRST SAVJB4	;CANNOT DO EITHER, PROCEED W/O COMPLAINT
SAVJB3:	
	MOVE T1,[XWD -100,377777]	;FAKE PDL POINTER
	XCTBU <PUSH T1,JOBSA>	;SAVE JOB STARTING ADDRESS (RH)
				; AND INITIAL FIRST FREE LOC (LH)
	XCTBU <PUSH T1,JOB41>	;SAVE USER LOC 41(USER M HANDLER JSR)
	XCTBU <PUSH T1,JOBCOR>	;SAVE USER TYPED THIRD (CORE) ARG (RH) AND
				; HIGHEST DATA LOC LOADED IN LOW SEG (LH)
	XCTBU <HRR T2,JOBREN>	;SAVE REENTER COMMAND STARTING ADDRESS
	XCTFU <HLL T2,JOBHRL> ; & 1ST FREE LOC (REL TO 400000) SET BY LOADER
	XCTTU <PUSH T1,T2>
	XCTBU <PUSH T1,JOBVER>	;SAVE BOTH HALVES OF PROGRAM VERSION NUMBER
				; LH IS USED FOR PROGRAMMER NUMBER LAST MODIFYING
	XCTTU <PUSH T1,[EXP 0]>	;CLEAR REST OF 10 (OCTAL) LOCATIONS FOR FUTURE
	AOBJN T1,.+1	;LEAVE JOBHSM ALONE FOR DDT
	XCTTU <PUSH T1,[0]>	;MORE TO CLEAR
	MOVE T1,[<CPRRED>B7+1B17+400]
	VPROT T1,
	STOPCD		;SHOULD NEVER HAPPEN
 ;OUTPUT THE ENTIRE HISEG UNCOMPRESSED
SAVJB4:	XCTFU <HLLZ T1,JOBHRL> ; 1ST FREE = LENGTH+1
	SKIPN T1		;NEVER ALLOW 0 WORDCOUNT
	JRST [HRLZ T1,%UPT+UPTHRL	;IN CASE LH JOBHRL NOT
		SUB T1,[377777,,0]		;SET UP
		JRST .+1]
	MOVNS T1	;-SIZE,,0
	HRRI T1,377777	;T1/IOWD SIZE,400000
	MOVEI T2,0	;T1,T2 IOLIST
	OUTPUT RUNCHN,T1
	PUSHJ P,SGIOCK	;RET ONLY IF ALL OK
	CLOSE RUNCHN,
;DELETE .SHR IF .HGH WRITTEN AND VICE VERSA
	PUSHJ P,SETACS
	HLLZ P2,0(P)	;THE EXT WE CREATED
	CAMN P2,[SIXBIT/SHR/]
	SKIPA P2,[SIXBIT/HGH/]
	MOVSI P2,(SIXBIT/SHR/)
	PUSHJ P,DELET
COMMENT @
IF (USER GAVE NO EXTENSION) THEN
	BEGIN
	EXT_'LOW';
	IF LH(JOBCOR)<JOBDA THEN
	 BEGIN
	 DELETE FN.LOW
	 IF DVMTA THEN OPEN CHANNEL & SAVNUL;
	 GOTO SAVFIN;
	 END;
	END;
@

	PUSHJ P,SETACS
	JUMPN P2,SAVJB5
	MOVSI P2,'LOW'
	MOVEM P2,XPAUXT(PG)
	XCTBU <HLRZ T4,JOBCOR>
	CAIL T4,JOBDA
	JRST SAVJB5
	PUSHJ P,DELET	;ZAP FN.LOW
	MOVE T4,DEVMOD(F)
	TLNN T4,DVMTA
	JRST SAVFIN
	OPEN RUNCHN,T1
	 JRST SGERRA
	PUSHJ P,SAVNUL
	JRST SAVFIN
;END /*HISEG EXISTS */
;HERE WHEN THERE IS NO HS TO SAVE, OR THERE IS A .LOW OR .EXT TO
;SAVE ALONG WITH THE .HGH/.SHR. F STILL SETUP

SAVJB5:	PUSHJ P,SETACS	;WILL PICK UP .LOW IF HISEG NEEDED LOW
	OPEN RUNCHN,T1	;
	 JRST SGERRA
	SKIPN P2
	MOVSI P2,SAVDMP	;NONE OFFERED, USE .SAV
	ENTER RUNCHN,P1
	 JRST SAVERR
;REMEMBER TO POP EXT OUT OF STACK SAVERR OR SAVFIN
;FALL THRU FROM ABOVE TO COMPRESS CORE FOR SAVJOB, THEN WRITE
	UMOVE T1,JOB41   	;SAVE USER M HANDLING JSR
	UMOVEM T1,JOBS41	;IN UPPER PART OF JOB DATA AREA
	XCTBU <SETZM JOBEXM>
	XCTBU <SETZM JOBFDV>
	UMOVE T1,JOBDDT	;SAVE DDT STARTING ADDRESS HIGHER UP IN JOB DATA AREA
	UMOVEM T1,JOBSDD	;SO COMPRESS ALWAYS MOVES CODE DOWN
	XCTBU <HRRZ	T3,JOBSA>	;SAV START ADDRESS FOR 10DMP
	MOVEI	T1,JOBSV ;POINT TO 1ST DATA WORD
	MOVEI	T2,JOBSDD ;IT STARTS AT JOBSDD
	HLRO J,XPACOM(PG)	;IOWD FOR THIS SIZE CORE(-LENGTH TO WRITE)
	MOVNS J		;POSITIVE LENGTH
	ADDI J,JOBSVM	;ADD IN FIRST LOC-1 TO WRITE=HIGHEST LOC TO WRITE
				; TO MAKE END TEST
CMPLP1:	MOVEM	T1,U		;SAVE 1ST LOC FOR IOWD
	CAMLE	T2,J	 ;SEARCH FOR 1ST NON-0 WORD
	AOJA	T1,CMPTHR	  ;THROUGH
	XCTBU <SKIPN	(T2)>		 ;THIS A DATA WORD?
	AOJA	T2,.-3	;NO. KEEP LOOKING
	MOVNI	P1,1		;YES. P1 WILL BE AN IOWD
	HRLI	P1,-1(T2)	;1ST LOCATION - 1
CMPLP2:	XCTBU <PUSH	T1,(T2)>	;SAVE A DATA WORD
	AOS	T2
	CAMG	T2,J	;AT TOP?
	XCTBU <SKIPN	(T2)>		;NO. NEXT WORD NON-0?
	JRST	.+2		;NO. THROUGH THIS BLOCK
	SOJA	P1,CMPLP2	;COUNT THE WORD AND CHECK NEXT
	XCTBU <MOVSM	P1,(U)>	;SAVE IOWD IN FRONT OF BLOCK
	AOJA	T1,CMPLP1	;LOOK FOR NEXT NON-0 BLOCK
CMPTHR:	HRLI	T3,254000	;SET A JRST C(JOBSA)
	UMOVEM	T3,-1(T1)	;AT END OF FILE
	SUBI	T1,JOBSV ;COMPUTE WORD COUNT
	MOVN	T2,T1		;MAKE AN IOWD
	HRL	T2,XPACOM(PG) ;START ADDRESS
	MOVSS T2
	MOVSI	T1,XPNCOR	;FLAG THAT CORE NEEDS EXPANDING
	ORM	T1,%UPT+UPTSTS
				; CORE ON START ,DDT,SAVE, REENTER,SSAVE IN CASE
				; THIS SAVE IO DOES NOT GO TO COMPLETION. (CONTROL C
				; OR DEVICE FULL, SO THAT CORE DOES NOT GET EXPANDED
SVLSUU:	MOVE 	T1,T2
	SETZB	T2,T3
	JUMPL	T1,SVLSU1	;check for overflow; (+)
	MOVE	T2,T1		;too big - break it in half
	HRLI	T1,-400000
	ADD	T2,[400000,,400000]
SVLSU1:	PUSHJ 	P,SGDO		;WILL EXECUTE THE FOLLOWING UUO:
	OUTPUT 	RUNCHN,T1	;CK ERRORS,EXPAND
				; RETURN HERE ONLY IF NO ERRORS
				;FIX J? DOES IT MATTER?

SAVFIN:
	POP 	P,T1		;FIX STACK,GET EXT SAVED
	PUSHJ 	P,SGREL		;RELEASE RUNCHN
	MOVE	T2,%UPT+UPTPDL	;GET ULTIMATE RETURN ADDRESS
	TLNN 	T2,PC.USR	;IS IT IN USER MODE (IE. A UUO)?
	 JRST	SAVFN1		; NO - MUST BE COMMAND
	AOS	T2		;SKIP RETURN FROM UUO
	JRST	USRXIT		;GO HOME
SAVFN1: MOVE 	P3,XPANAM(PG)	;GET NAME OF THING WE SAVED.
	SETZ 	P4,		;NO EXTENSION TO BE TYPED.
	PJRST 	ERRJSV		;JOB SAVED EXIT CONDITION.

SAVERR:
	POP P,T1		;FIX STACK,GET SAVED EXT
	MOVEI T1,PRTERR		;PROT ERR IN CASE RET TO USER
;;	HRRZS %UPT+UPTPDL	;DON'T RET TO USER, PC.USR_0;REMOVED FOR SAVE FRMOP
	PUSHJ P,SGRELE		;RELEASE RUNCHN & RETURN HERE
	MOVE P3,P1		;GET FAILING FILE NAME IN P3
	HLLZ P4,P2		;AND FAILING EXT IN P4
	PJRST ERREUF		;PRINT ATTEMPTED ENTER UUO FAILED.

COMMENT @ SUBROUTINE DELET
FUNCTION: FOR SAVJOB, TO DELETE OBSOLETE FILES WHEN
	A NEW ONE HAS BEEN SAVED.
CALL:	GET P1-P4 SETUP FOR LOOKUP OF FILE TO DELETE
	PUSHJ P,DELET
	RETURN HERE ALWAYS
DESTROYS:	P2,P3,P4.  P2 LEFT-HALF = EXT IS PRESERVED
@

DELET:	LOOKUP RUNCHN,P1
	POPJ P,
	RENAME RUNCHN,[0]
	JFCL
	POPJ P,

COMMENT @ SUBROUTINE SAVNUL
FUNCTION: WRITE A NULL SEGMENT TO MAGTAPE
	THIS ROUTINE WRITES A LITTLE RECORD WHICH GETS READ
	ON MAGTAPE GET AS A VESTIGIAL JOB DATA AREA.  ITS
	JOBHRN LOC HAS ZERO WHICH MEANS THAT THERE REALLY
	IS NO HISEG.  ITS JOBHCR LOC HAS DATA USED TO SET
	XPANEW ON THE GET SO THAT THE LOWSEG GETTER READLS
	HAS SOME IDEA HOW MUCH CORE TO GRAB FOR THE INPUT
	OPERATION TO WRITE ON.  AFTER READHS USES THE JOBHCR
	DATA THIS NULL HISEG IS DESTROYED.
CALL:	OPEN RUNCHN,
	PUSHJ P,SAVNUL
	RETURN HERE IF ALL IO OK ELSE FRETURN THRU SGIOCK
DESTROYS: LOTS OF ACS:  T1,T2,T3..
RESTRICTIONS: USE ONLY WHEN NO REAL HISEG EXISTS
IDIOSYNCRACIES: SINCE THIS ROUTINE MAY BE CALLED UPON TO
 WRITE A NULL-HISEG RECORD WHEN THERE IS A CORE IMAGE
 OF 777 PGS IN THE LOWSEG, IT CANNOT COMPOSE THE RECORD
 TO BE WRITTEN TO TAPE IN ITS STANDARD VESTIGIAL JOBDAT
 LOCATION AT 400000.  SO IT IS COMPOSED AT LOC
 JOBNSV IN THE LOSEG JOBDAT.  ANY DATA THERE IS OVERWRITTEN;
 NORMALLY THERE WOULD BE NONE, SINCE JOBNSV LIES WITHIN
 THE JOBJDA ARRAY WHICH WOULD AT THIS TIME BE EMPTY SINCE
 ALL CHANNELS ARE CLOSED.   

SEE ROUTINES READHS AND READLS AND GETMTJ FOR MORE
UNDERSTANDING OF MAGTAPE GET/RUN.
@

SAVNUL:	
	MOVEI	T1,JOBNSV
	XCTBU	SETZM JOBHRN(T1) ;THIS SAYS NO HISEG REALLY EXISTS
	UMOVE	T2,JOBCOR
	UMOVEM	T2,JOBHCR(T1)	;THIS SAYS SIZE OF LOSEG, IF ANY
				;CORE ARG GIVEN TO SAVE CMD
	MOVNI	T1,JOBHRN+1	;-(SIZE OF RECORD)
	HRLI	T1,JOBNSV-1	;LOC WHERE RECORD COMPOSED
	MOVSM	T1,T2		;T2/ OUTPUT IOWD
	MOVEI	T3,0		;END OF IOLIST
	OUTPUT	RUNCHN,T2	;WRITE THE NULL SEGMENT
	PUSHJ	P,SGIOCK	;CHECK FOR ERRORS (RETURN IF OK)
	CLOSE	RUNCHN,		;WRITE EOF
	POPJ	P,
SUBTTL EXPAND
COMMENT @ ROUTINE EXPAND
FUNCTION: EXPAND A CONTRACTED LOW SEGMENT IF (JOBSV)<0
	  SET JOBHRL TO HISEG END IF HISEG EXISTS. USED BY
	  SAVJOB VIA SGDO AFTER COMPRESSING CORE FOR SAVE.
	  USED BY RUNJOB/GETJOB VIA SGDO.
CALL:	MOVE J,JOB NUMBER
	PUSHJ P,EXPAND
	RETURN HERE SUCCESS
FAILURE EXITS: GETERR OR NOROOM..NO RET TO EXPAND CALLER
CALLS:	GETCOR, GETERR, HSSIZE
RESTRICTIONS:
DESTROYS: P1,P2,T1,T2

@
EXPAND:	
	XCTBU <SKIPL	T1,JOBSV> ;IF FIRST LOC IS POSITIVE
	JRST	SGDOER		;OLD FORMAT, SO DONT EXPAND
;COME HERE TO DO THE ACTUAL EXPANSION OF A FILE
EXPND1:	MOVEI T1,JOBSV ;IT WAS READ INTO JOBSV
	UMOVE	T2,(T1)	;FIRST IOWD
EXPLP1:	
	HLRO	P1,T2	;YES. GET WORDCOUNT
	MOVNS	P1		;+N
	HRLM	P1,T2	;CONVERT IOWD TO +N IN LH
	ADDI	T1,1(P1)	 ;ADDRESS OF NEXT IOWD
	ADDI	T2,(P1)	;YES. CHANGE RH OF IOWD
	XCTBU <EXCH	T2,(T1)>	;MAKE IT XWD +N,A+N-1 AFTER DATA BLOCK
	JUMPL	T2,EXPLP1	;CONTINUE IF NEXT THING IS AN IOWD
	HLRZ P1,T2
	CAIE P1,(JRST)
	CAIN P1,(HALT)
	SKIPA
	JRST EXPLP1		;ASSUME JUST LARGE COUNT
	PUSH	P,T1		;SAVE DATA LOCATION
	XCTBU <HRRZ	T1,(T1)>	  ;TOP REAL LOCATION NEEDED

	TRO	T1,1777	;MAKE IT NK-1
	PUSHJ	P,GETCOR	;NO. GET IT
EXPCOR:	POP	P,T2
	HRRZ T1,%UPT+UPTREL	;TOP CORE ADDR
				;(OK TO USE UPTREL INSTEAD - USER CAN'T BE RUNNING)
	HRRZI P1,(T2)		;TOP DATA LOC
	HRLI	P1,1(P1)	;SET TO ZERO TO TOP OF CORE
	HRRI	P1,2(P1)
	CAIL T1,1(P1)		;ATLEAST 1 WORD TO TOP OF CORE?
	XCTBU <SETZM	-1(P1)>		;YES CLEAR FIRST ONE
	CAILE T1,1(P1)		;MORE THAN ONE WORD TO TOP OF CORE?
	XCTBU <BLT	P1,(T1)>	;YES. CLEAR TO TOP OF CORE
	HRROI	T1,(T2)	;FROM DATA POINTER
EXPLP2:	XCTBU <HRRZ	P1,(T1)>	;TO DATA POINTER
	CAIGE P1,(T1)		;MAKE SURE WE DO NOT GO BACKWARDS
	JRST GETERR		;CAN HAPPEN TOO MANY IOWDS W/O 0'S
	XCTBU <HLRZ	P2,(T1)>	;WORD COUNT
	SUBI	T2,1(P2)	;POINT T2 TO PREVIOUS IOWD
	XCTBU <SETZM	(T1)>		;ZERO THIS IOWD
	SOSA	T1		;POINT TO DATA
EXPLP3:	SOS	P1
	CAIGE P1,JOBSDD	;DON'T STORE DATA BELOW JOBSDD
	SOSA T1
	XCTBU <POP	T1,(P1)>	;MOVE A DATA WORD
	XCTBU <SETZM	1(T1)>		;ZERO WHERE IT CAME FROM
	SOJG	P2,EXPLP3		;LOOP IF MORE DATA
	CAILE	T2,JOBSV 		;THROUGH?
	JRST	EXPLP2		;NO. DO NEXT BLOCK
	XCTBU <EXCH	P2,JOBSDD> ;YES. ZERO JOBSDD
	UMOVEM P2,JOBDDT	;SET USER DDT STR ADR
SGDOER:	MOVSI T1,XPNCOR		;EXPANDED
	ANDCAM T1,%UPT+UPTSTS	;CLEAR FLAG      (WAS ANDCM ..AA)
	PUSHJ P,HSEXIS
	SKIPA T2,%UPT+UPTHRL
	POPJ P,
	XCTBU <HRRM T2,JOBHRL> ;MAY NOT HAVE BEEN ABLE TO WHILE
		;COMPRESSED..JOBHRL GETS MOVED
	POPJ P,
SUBTTL GETJB - MAIN ROUTINE TO LOAD CORE IMAGES FOR RUN/GET/RUNUUO
COMMENT @ GETJOB MONITOR JOB FOR ".GET" COMMAND
ENTRY: RUN BY SCHEDULER AFTER SETUP BY SGSET. NO ACS SETUP.
	ALSO BY FRMOP AT GETFMU.
@
INTERNAL GETJOB,GETFRM,GETFMU

GETFRM:
GETJOB:	JSP T2,SG1		;SETUP PDL WITH TYPED ARGS,(PG)..
	MOVE J,JOB
GETFMU:	HRLS T1,JBTLIC(J)
	HRLM T1,JBTSLC(J)
	PUSHJ P,MGETJB		;GET THE JOB, RTN ONLY IF ALL OK
	MOVE P3,XPANAM(PG)	;GET NAME OF THING WE GOT
	SETZ P4,		;NO EXTENSION
	PJRST ERRJSU		;JOB SETUP EXIT CONDITION

COMMENT @ RUNJOB, RUNJB2 (FOR MONITOR RUN ENTRY+1 ON LOGOUT)
FUNCTION: DO THE ".RUN" COMMAND. RUNJB2 ENTRY FOR SETTING
	UP START ADDRESS = ENTRY+1.  USE MOST OF THE CODE
	FOR RUNUUO.
ENTRY: FROM SCHEDULER AFTER SETUP BY SGSET.
	ALSO BY FRMOP AT RUNFM1.  NOTE FRMOP'S MONJOB LEAVES
	START INCRIMENT IN S, SO IT RUN US AT RUNFRM.
@
INTERNAL RUNJOB,RUNJB2,RUNFRM,RUNFMU

RUNJOB:	JSP T2,SG1		;SETUP ACS
	PUSH P,[0]		;START INCR=0
RUNFMU:	MOVE J,JOB
	HRLS T1,JBTLIC(J)
	HRLM T1,JBTSLC(J)
	PUSHJ P,MGETJB		;GET THE JOB,
	JRST RNSEG		;FINISH UP AS IF RUNUUO

RUNJB2:	JSP T2,SG1		;SETUP ACS
	PUSH P,[1,,0]		;START INCR=1
	JRST RUNFMU

RUNFRM:	JSP T2,SG1		;SETUP ACS
	PUSH P,S		;SAVE START INCR
	JRST RUNFMU

Comment !	LOGOFF uuo

	MOVS ac,[start-address-increment]
	LOGOFF ac,		; if JBTSTS[KJP]=0 then run SYS:LOGOUT
				; else run the ALP program (if any)
	  <error return>	; return here if can't run program,
				; if this instr is a HALT, print msg
				; on user's tty
	<no-ALP-set return>	; return here if there is no ALP in
				; effect and JBTSTS[KJP]=1

	JBTSTS[KJP] is set by LOGOUT program before doing LOGOFF uuo.
	This way, a LOGOUT uuo may be used by any program to start the
	logout sequence.  It is used by LOGOUT, however, to run the
	ALP if one exists.
!
EXTERN	UPTALD,UPTALP,UPTALN,SYSPPN,LGONAM

LOGOFF::
	MOVE	U,%UPT+UPTALD	; device name
	MOVE	T4,%UPT+UPTALP	; PPN
	MOVE	P2,%UPT+UPTALN	; program name

	MOVE	T3,JBTSTS(J)
	TRNE	T3,KJP		; test for JBTSTS[KJP]
	  JRST	RUNAL1

	TLO	W,PHONLY	; force physical only for this
	MOVSI	U,(SIXBIT "SYS"); get real logout device
	SETZ	T4,		; no ppn
	MOVE	P2,LGONAM	; get real logout name

RUNAL1:	JUMPE	P2,CPOPJ1	; uuo is no-op if no prog to run
	MOVE	T2,T1		; start address increment
	TLZ	T2,-2		; only let start at ST and ST+1
	SETZB	P1,T3		; no ext, no lic, no core
	PUSHJ	P,GETARG	; put args on stack
	MOVEM	P2,JBTNAM(J)	; show new name
	PUSHJ	P,GETJB		; get both segments (if any)
	PJRST	RNSEG		; do rest as if run uuo
COMMENT @ RUN UUO
;CALL:	MOVE AC,[XWD N,D]
;	CALL AC,[SIXBIT /RUN/]
;	ERROR RETURN		;UNLESS LH=HALT(PRINT CONSOLE MESS. IF YES)
;	IK OK, TRANSFER TO C(JOBSA)+N FOR NEW PROGRAM

;WHERE:	D/	DEVICE NAME
;	D+1/	FILE NAME
;	D+2/	FILE EXT OR 0 (LH SIXBIT)
;	D+3/	IGNORED
;	D+4/	PPN OR 0 (CURR UFD) OR 0,,ADDRESS OF SIXBIT/12-CHAR USERNAME/
;	D+5/	XWD LICENSE TO PASS,,NEW CORE ASSIGNMENT
@

	INTERN URUN,RNSEG,GTJBFN

URUN:	PUSHJ P,RESET		;RELEASE DEVICES
				; WARNING! THIS GOES VERY DEEP IN
				; PUSHDOWN. SEE MCO 518
				; (AC M PRESERVED IN RESET)
	UMOVE T1,(M)		;RESTORE CONTENTS OF USER'S CALLING AC
	PUSHJ P,GTUARG	;SETUP USUAL ARG BLOCK IN PDL
			;START ADDR INCR AT LH 0(P).
			;AC "M" PRESERVED IN CASE SGRELE NEEDS IT.
	MOVEM P2,JBTNAM(J)
	AOS URUNCT		;KEEP TRACK OF RUN UUO'S DONE
	PUSHJ P,GETJB		;GET BOTH LOW AND HIGH SEGMENTS


; RNSEG  .. FALL THRU OR COME HERE FROM RUNSEGUUO OR RUNJOB (RUN CMD)
RNSEG:	MOVE J,JOB
	MOVEI T2,PVEXO
	TDNN T2,JBTPRV(J)	;CHECK IF RUN ONLY
	JRST URUN1B		;NO
	HRLOI T2,1
	ANDM T2,(P)		;YES, RESET START INC TO 0 OR 1
URUN1B:	HLRZ T2,(P)
	CAIG T2,1
	JRST URUN2		;ALL OK
	HRLS T2,JBTLIC(J)	;NOT 1 OR 0, RESET LICENSE
	HRLM T2,JBTSLC(J)
URUN2:	MOVSI T2,JACCT		;IN NORMAL CASE, RESET JACCT
	ANDCAM T2,JBTSTS(J)
URUN4:	HLRZ T2,(P)		;GET STARTING ADDRESS INCREMENT(0 IF RUN COM)
	XCTBU <ADDB T2,JOBSA>	;ADD STARTING ADDRESS TO BOTH
				; SO THAT <CONTROL>C START WILL START
				; PROGRAM AT SAME STARTING ADDRESS
	TRNN T2,777700	;SEE IF LEGITIMATE START ADDRESS
	PJRST	ERRNSA		;SAY NO START ADDRESS.
	HRLI T2,PC.USR!PC.PUB	;SET USER MODE BIT IN PC
	PUSH P,T2		;PUT ON PD LIST
	JRST USRXIT		;ENTER NEW PROGRAM AS IF FROM UUO
COMMENT @ PROCEDURE GETJB AND MGETJB

FUNCTION:	TO GET BOTH "HIGH" & "LOW" SEGMENTS SETUP
	FOR THE RUNUUO,GET/RUN CMDS. CALLED BY URUN1,GETJOB.

CALL:	GET USER ARGS TO PDL FROM TTY OR ARG BLOCK
	MOVE PG,ADDR OF ARG BLOCK IN PDL
	PUSH P,START-ADDR-INCR,,ARB BITS
	PUSHJ P,GETJB (FOR RUNUUO)
   OR,	PUSHJ P,MGETJB (RUN,GET COMMANDS)
	RETURN ON SUCCESS
FAILURE:FAIL EXITS FROM GETJB DO NOT RETURN TO ITS CALLER: THEY
	GO THRU SGRELE WHICH RETURNS EITHER TO USER OR
	CMD LEVEL PHOLD WITH MSG.

RETURNS:	MOST AC'S DESTROYED
	LICENSE SET UP
	ACCOUNTING RECORD WRITTEN (GTJBFN DOES THIS)
	EXO BIT SETUP
	PREVIOUS MEMORY VREMOVED BEFORE CURRENT CORE IMAGE
	 LOADED

FILE SEARCH SEQUENCE: FN.SHR( THEN FN.EXT OR FN.LOW IF EXT=0),
	FN.HGH(FN.<EXT OR 'LOW'>),
	FN.<EXT OR 'SAV'>,
	FN.'SWR'

ENTRIES: GETJB	FOR RUNUUO. CAUSES DELAY IN REMOVE OF EXISTING PAGES
	MGETJB FOR RUN/GET COMMANDS. VREMOV ALL CORE EXCEPT PG 1
		BEFORE ANY LOOKUPS, ETC.

@

MGETJB: TDZA U,U	;MONITOR JOB ENTRY
GETJB:	MOVEI U,1	;RUNUUO ENTRY
	NOCHARGE		;NO MICROCYCLES DURING RUN OR GET
	MOVEI T1,PVEXOG	;TURN OFF PVEXOG. ROUTINE "FOUND"
	ANDCAM T1,JBTPRV(J);IN LOOKUP CODE WILL TURN IT ON IF
		;GETB IS ON (WHICH IT WILL BE,SEE BELOW), YET
		;USER HASNT GOT READ PRIV ON THE FILE. ERGO
		;HE HAS EXO PRIV ONLY.
	JUMPN U,GETJB0	;IF USER CALLED, KEEP CORE UNTIL LOOKUPS SUCCEED
	PUSHJ P,TIMADJ
	PUSHJ P,KILLLS	;VREMOV PAGES 1-377 LEAVE PG 0
	PUSHJ P,KILLHS	;VREMOV PAGES 400 - 777
GETJB0:	PUSHJ P,SETOPN	;T1-T3 FOR OPEN
	OPEN RUNCHN,T1
	 JRST SGERRA
	MOVSI F,GETB
	IORB F,%UPT+UPTJDA+RUNCHN	;GET BIT ON IN F,MEMORY
					;GETLIC CALLED FROM GTJBFN
					;NEEDS GETB IN F
	MOVSI T1,'SHR'	;BEGIN FILE SEARCH SEQUENCE 
	PUSHJ P,DOLOOK
	 JRST [	MOVSI T1,'HGH'
		PUSHJ P,DOLOOK
		 JRST [	SKIPN T1,XPAUXT(PG)
			MOVSI T1,SAVDMP
			PUSHJ P,DOLOOK
			 JRST [	MOVSI T1,'SWR'
				PUSHJ P,DOLOOK
				JRST NOFILE
				JRST GETJB1]
			JRST GETJB1]
		JRST GETJB1]
;WHEN WE GET HERE, P2/0,,EXT P3/FILE PROT P4/SIZE IN WORDS
GETJB1:
	JUMPE U,GETJB2	;IF RUN/GET CMD, ALREADY REMOVED CORE
	PUSHJ P,TIMADJ	;NEW SPACE-TIME INTEGRAL. DESTROY NO ACS
	;HERE IT WOULD BE NICE TO CHECK P4/XPASIZ
	;AGAINST USERS PVYCOR AND GIVE HIM A NOROOM FRETURN
	;BEFORE WE HAVE DESTROYED HIS CORE IMAGE. HOWEVER
	;SINCE LOWSEGS ARE COMPRESSED, XPASIZ/WORDS DOESNT
	;REFLECT THE ACTUAL CORE REQUIREMENT SO NOTHING WOULD
	;BE GAINED. WHEN WE CHANGE TO MAPPING LOWSEGS COW AND
	;NO COMPRSSION IN ANY FILES, THEN WE COULD DO
	;THE CHECK HERE. XPASIZ WOULD BE REAL PAGES IN FILE.
	PUSHJ P,KILLLS	;VREMOV OLD LOWSEG 1-377. UPTREL FIXED
	PUSHJ P,KILLHS	;AND OLD HISEG, 400-777. UPTHRL FIXED
GETJB2:	HRRZS %UPT+UPTPDL	;PC.USR_0 NO MORE RETURN TO USER
	;SETZB T1,T2	;START=STOP=VP 0. TRY TO CREATE PG 0
	;PUSHJ P,CORXPN	;IF ALREADY EXISTS, FRETURN W/0,,CREXV%
	;JFCL		;FAILED,PROBABLY EXISTS
	MOVSI T1,SG.SWR
	ANDCAM T1,%UPT+UPTSTS	;CLEAR FLAG; MAPHS SETS IF NEEDED
	MOVE T4,DEVMOD(F)
	TLNE T4,DVMTA
	JRST GETMTJ	;GET MAGTAPE JOB SPECIAL CONSIDERATIONS
	MOVE T2,P4	;T2/SIZE IN WORDS
	CAIN P2,'SWR'
	JRST GETJB3
	CAIE P2,'SHR'
	CAIN P2,'HGH'	;IF ASKING FOR HISEG, ADJUST XPANEW
GETJB3:	JUMPG T2,[ PUSHJ P,ADJCOR	;DOWNWARD BY SIZE IN T2
		   JRST .+1]
;IF NOT 'SWR','HGH' OR 'SHR', DO LOWJOB
	CAIN P2,'SWR'
	JRST HGHJOB
	CAIE P2,'SHR'
	CAIN P2,'HGH'
	JRST HGHJOB
; LOWJOB..FALL THRU FROM ABOVE IF EXT IS FOR LOWSEG,
; OR COME HERE FROM SHRJB4 BELOW WHEN HISEG FILE
; REQUERES A <128K LOW FILE TO BE READ.
;   ENTER WITH P4/ SIZE AS USUAL EXCEPT IF DVMTA, P4/0

LOWJOB:
	PUSHJ P,READLS	;READ,EXPAND IF NECESSARY
	 JSP T1, GTJBNR		;NOROOM FAIL EXIT
	PUSHJ P,LOWFIN	;GIVE WHATEVER MORE CORE XPANEW REQURES
	UMOVE T1,JOBS41	;RESTORE USER UUO JSR LOC
	UMOVEM T1,JOB41
	PUSHJ P,GETLIC	;GET T1/0,,FILE LIC; SKIP IF MAGTAPE. EXPECTS F
	SKIPA
	MOVEI T1,0
	HRRM T1,XPALIC(PG)
	MOVSI T1,LSLIC
	IORM T1,XPAMOD(PG)	;INDICATE A LOWSEG LIC GOTTEN & SETUP
	PJRST GTJBFN	;FINISH UP LICENSE,EXO,ACT RECORD,..

HGHJOB:
SHRJOB:	;ENTER HERE WITH FILE LOOKED-UP & P4/SIZE IN WORDS
	PUSHJ P,MAPHS		;MAKE SHAREABLE RDO FILE PAGES
	JSP T1,[ CAIN T4,FALCOR
		JRST GTJBNR	;NO ROOM,CORE LIMIT FAILURE
		JRST MAPIOF]	;OTHER ERROR. SAY "TRANSMISS. ERROR".
; SHRJB2..COME HERE FROM GETMTJ TOO
SHRJB2:	PUSHJ P,INIJDA	;MOVE DOWN VESTIGIAL JOBDAT
	PUSHJ P,GETLIC	;EXPECTS F. GET T1/0,,FILE LIC; 
	SKIPA		;GOOD RTN
	MOVEI T1,0	;MAGTAPE RETURN
	HRLM T1,XPALIC(PG)
	MOVSI T1,HSLIC	;INDICATE A HISEG LIC
	IORM T1,XPAMOD(PG)	;GOTTEN & SETUP
	MOVE T1,XPAPID(PG)	;GET WHATEVER PID THERE IS ON THIS FILE
	MOVEM T1,XPAHPD(PG)	;AND SAVE IT AS THE HISEG PID.
	XCTBU <HLRZ T2,JOBCOR>	;DOES THIS HISEG NEED
		;A LOW FILE READ? TRUE IF DATA TO BE LOADED
		;ABOVE JOBDAT AREA.
	SKIPE T1,XPAUXT(PG)	;IF HE HAVE AN EXT,
	JRST SHRJB4		;READ IT REGARDLESS. OTHERWISE,
	CAIGE T2,JOBDA		;DATA EXISTS ABOVE JOBDAT?
	JRST SHRJB3		;NO, CREATE BLANK LOSEG; NO FILE TO READ IN
	MOVSI T1,'LOW'		;DIDNT GIVE AN EXT, TRY LOW
SHRJB4:
	PUSHJ P,DOLOOK	;RETURN P2,P3,P4 SUCCESS SKIP
	 JRST [	PUSHJ P,KILLHS
		;JSP T1,REPDP
		JRST NOFILE]	;RET TO USER OR CMD LEVEL
	MOVE T4,DEVMOD(F)
	TLNE T4,DVMTA
	MOVEI P4,0		;FORCE USE OF XPANEW FOR MT
	CAIGE P4,400000		;P4/WORDS IN (COMPRESSED) FILE
	JRST LOWJOB		;READ & CREATE LOWSEG
	JSP T1,GTJBNR		;SIZE >128K; NOROOM FAIL

;COME HERE WHEN HIGH FILE REQUIRES NO LOW FILE DATA TO BE
;READ IN. CREATE A BLANK LOWSEG

SHRJB3:
	MOVE T1,[JOBDA,,JOBDA+1]	;CLEAR PG 0 FROM TOP OF
	XCTBU <SETZM -1(T1)>	;JOBDATA AREA TO 777
	XCTBU <BLT T1,777>	;INCASE PREV PROG LEFT ANY DATA THERE
	XCTFU <HRRZ T2,JOBCOR>	;T2/SIZE TO MAKE THE LOWSEG
	IORI T2,1777
	MOVE P4,T2	;INCASE CORXPN FAILS,& FOR UPTREL BELOW
	LSH T2,-9
	MOVEI T1,1	;FROM PG 1 TO T2/STOP PG.
	PUSHJ P,CORXPN	;CREATE PRIV RDW PAGES
	 JRST GTJBNR	;NO ROOM
	HRRM P4,%UPT+UPTREL
	XCTBU <HRRZM P4,JOBREL>
	PUSHJ P,LOWFIN	;ADD WHATEVER MORE CORE XPANEW SAYS
	PJRST GTJBFN	;FINISH UP, SUCCESS.

GETMTJ:	;DEVICE IS MAGTAPE. FIND OUT IF HISEG EXISTS ON TAPE.
	;NONE EXISTS IF JOBHRN IN RECORD ON TAPE = 0.
	;THIS MONITOR & PREVIOUS ONES ALWAYS WRITE 2 FILES ON TAPE
	;FOR ANY SAVE, WHETHER 2 SEG OR NOT.
	MOVEI P4,0	;IMPORTANT. P4 HAS "FILE SIZE". SEE READLS
	PUSHJ P,READHS		;READ INTO PRIV PGS, MAKE RDO
	JRST SHRJB2		;SUCCESS. GOOD HISEG READ.
	JUMPE T1,GTJBNR		;FAILURE. T1/0 IF NO ROOM
	CAIG T1,1		;FAILURE. CODE T1=1?
	PJRST ERRMHB		;YES. HISEG FORMAT BAD OR SYS ERRORS
	PUSHJ P,KILLHS	;FAILURE CODE 2. ZERO LENGTH HISEG
	JRST LOWJOB		;SO KILL 1 PG CREATED & GO GET LOW
;COME HERE IF MAPHS,READHS,READLS FAILS. P4/SIZE IN WORDS
; OF FILE . SET UP FOR " XX PAGES REQUIRED" MESSAGE & GO

GTJBNR:	;JSP T1,REPDP	;FIX STACK
	PUSH P,P4	;NOOOM EXPECTS THIS
	PUSHJ P,KILLLS	;DESTROY CORE IMAGE SINCE LICENSE,EXO
	PUSHJ P,KILLHS	;ETC NOT YET SET.
	JSP T1,NOROOM
COMMENT @ SUBROUTINE GTJBFN

FUNCTION: COMMON FINISH-UP ROUTINE FOR GET/RUN,RUNUUO,
	RUNSEGUUO.  
	SETUP  LICENSE.  WRITE STREAM ACCT'G RECORD.
	SET EXO BIT IF NEED BE.  RELEASE RUNCHN

EXPECTS: F/RUNCHN DDB J/JOB  XPAMOD/ HSLIC,LSLIC SETUP
	XPALIC/ LICENSE(HI FILE),,LICENSE(LOW FILE) SETUP IF ANY
	PG/ ADDR OF ARG BLK IN PDL
CALL:
	PUSHJ P,GTJBFN
	RETURN HERE

DESTROYS:T1,T2,T3,T4
CALLS: LICMAX,ACTWRT,SGREL,LICMSK,GETLIC (ONLY USER OF GETLIC)
	LICSAM (ONLY USER OF LICSAM AS OF 8/77)

IDIOSYNCRACIES:	THIS ROUTINE IMPLEMENTS A POLICY THAT NO LICENSED
	'SWR' FILE WILL BE ALLOWED TO RUN WITHOUT THE EXECUTE-ONLY
	BIT SET IN JBTPRV. THESE FILES RUN WITH MAX-WRITE SET, SO
	MODIFICATIONS MADE BY THE RUNNING COPY TO ITSELF CHANGE
	THE FILE PAGES DIRECTLY.
	A FURTHER POLICY IMPLEMENTED HERE IS: IF BOTH
	HIGH AND LOW FILES WERE GOTTEN, THE RESULTING LICENSE WILL
	BE THE "AND" OF THE 2 FILE LICENSES--ONLY THOSE IN
	COMMON TO THE 2 FILES WILL BE SET.
	THE SAME POLICY IS USED FOR SETTING UP PIDS - IF THE CORE
	IMAGE WAS OBTAINED FROM TWO FILES, THE PIDS FROM THE FILES
	MUST MATCH EXACTLY OR NO PID IS GIVEN.
@

EXTERNAL %UPT,UPTMFR,JBTMFR,ALLMFR,EXOMFR,JBTPNO,RDXMFR

GTJBFN::
	HLLZ T2,XPANEW(PG)	;LICENSE CALLER WANTS TO PASS
	HLR T2,JBTLIC(J)	;WHAT HE HAS
	PUSHJ P,LICMSK		;CAN PASS NO MORE THAN HE HAS
				;RETURN T2/...,,LIC TO PASS
	MOVE T3,DEVMOD(F)
	TLNE T3,DVDSK
	SKIPA T3,DEVPPN(F)	;CALC NEW JBTFPN
	MOVEI T3,0		;NONE IF OFF MAGTAPE
	CAME T3,JBTFPN(J)	;IF NOT FROM SAME UFD,
	TRZ T2,LICRMT		;CANNOT PASS LICRMT
	MOVEM T3,JBTFPN(J)	;SET NEW JBTFPN
	PUSH P,T2		;PASSED LIC
	MOVE T1,XPAMOD(PG)	;FLAGS HSLIC,LSLIC
	MOVE T2,XPALIC(PG)	;2 LICENSES
	TLC T1, HSLIC!LSLIC
	TLCN T1,HSLIC!LSLIC		;SKIP IF BOTH NOT ON ORIGINALLY
	JRST [	PUSHJ P,LICSAM	;BOTH HI & LOW GOTTEN. RETURN T2/ ...,,LICENSES
				;COMMON TO BOTH HALVES
		MOVE T3,XPAHPD(PG) ;GET HISEG PID
		CAME T3,XPAPID(PG) ;MAKE SURE ITS SAME AS LOSEG PID
		SETZM XPAPID(PG)	;NOT, HE GETS NO PID AT ALL.
		JRST GTJBF1]
	TLNN T1,HSLIC		;JUST HISEG?
	JRST GTJBF1		;NO, JUST LOSEG, XPAPID AND T2 SETUP OK
	HLRZS T2		;GET HISEG LICENSE IN T2
	MOVE T3,XPAHPD(PG)	;AND HISEG PID IS ONE TO USE
	MOVEM T3,XPAPID(PG)
GTJBF1:	MOVE T3,JBTPRV(J)
	MOVE T4,%UPT+UPTSTS
	TLNE T4,SG.SWR
	TRNN T2,-1
	SKIPA			;NOT A SWR FILE OR NO LICENSE
	TROA  T3,PVEXOG
	TRNE T3,PVEXOG		;LOOKUP MAY ALSO HAVE SET THIS BIT
	TROA T3,PVEXO		;PVEXOG ON, GOTTA SET PVEXO
	TRZ  T3,PVEXO		;NOT ON,RESET PVEXO
	MOVEM T3,JBTPRV(J)
	HRL T2,JBTLIC(J)	;T2/JOB LIC,,FILE LIC
	PUSHJ P,LICMAX		;T2/...,MAX OF THESE
	POP P,T1		;T1/PASSED LIC
	HRL T2,T1		;T2/PASS,,MAX(FILE,JOB)
	PUSHJ P,LICMAX		;T2/..,,MAX OF THESE
	HRLM T2,JBTLIC(J)
	HRLM T2,JBTSLC(J)
	MOVE	T3,JBTPRV(J)	;GET PVEXO AGAIN AFTER LICMAX SMASHED IT
	MOVEI	T1,EXOMFR	;ASSUME EXECUTE ONLY
	TRNE	T3,PVEXO	;IS IT?
	JRST	GTJBF2		;YES.
	MOVEI	T1,RDXMFR	;ASSUME EXECUTE ONLY + READING THINGS
	HRL	T2,JBTLIC(J)	;GET FRAME'S LIC,,PROCESS LIC
	TLZ	T2,LICRMT	;IF PROCESS HAS HF, FORCE MISMATCH
	PUSHJ	P,LICMAX	;GET MAX OF THOSE
	HRRZ	T3,JBTLIC(J)	;GET JOB LICENSE AGAIN
	CAIE	T3,(T2)		;MAKE SURE FRAME HAS ALL LICENSE BEING GIVEN TO THIS PROCESS
	JRST	GTJBF2		;LICENSES ARE DIFFERENT, DOESN'T GET ALL ACCESS
	SKIPN	XPAPID(PG)	;IF ITS NOT GOING TO HAVE A PID,
	MOVEI	T1,ALLMFR	;THEN HE CAN HAVE ALL ACCESS.
GTJBF2:	MOVE	T3,(T1)
	MOVEM	T3,JBTMFR(J)	;SET UP FIRST WORD
	MOVSI	T3,1(T1)	;BLT FROM THAT TABLE
	HRRI	T3,%UPT+UPTMFR	;TO MIR TABLE
	BLT	T3,%UPT+UPTMFR+.ARSIZ-1
	AOS	JBTPNO(J)	;OK, WE'RE IN A NEW PROG NOW. INVALIDATE
				; ALL RIGHTS GIVEN AWAY BY PAST FRAME OCCUPANT.

	MOVE	T1,XPAPID(PG)	;GET FINAL PID DETERMINATION (SEE ABOVE)
	MOVEM	T1,%UPT+UPTPID	;SET IT UP.
	SETZM	%UPT+UPTSPD	;NO PREVIOUS PID.
	SETZM	%UPT+UPTSTV	;NO START VECTOR YET.
	EXTERN ACTWRT
	MOVEI T1,0
	PUSHJ P,ACTWRT		;WRITE TYPE 0 ACT RECORD IF NEEDED
	MOVEI T1,16		;WRITE LICENSE RECORD IF
	PUSHJ P,ACTWRT		;NEEDED
	PUSHJ P,SGREL		;RELEASE DEVICES
	POPJ P,
SUBTTL HI AND LOW "SEGMENT" GETTERS

COMMENT @ ENTRY PTS FOR VACUOUS ROUTINES NOLONGER NEEDED 

ASGHGH::	STOPCD	;ASSFIN,DEASG IN COMCON CALLED
	;THIS TO MAKE UNSHAREABLE A SEG WHOSE JBTDEV HOME
	;DEVICE WAS BEING ASSIGNED/DESIGNED



CHKMED::	STOPCD  ;CALLERS SHOULD BE CHANGED. USED TO
		;TURN ON MEDDLE,UWP. ONLY CK'D IF SG WAS SHAREABLE
ANYSAV:: STOPCD
DODELE:: STOPCD
IFDELE::	STOPCD
RELSEG:: STOPCD
CLRNAM:: STOPCD
KILHGC::  STOPCD
HRESET:: STOPCD
RNMSEG:: STOPCD
LEAVE THESE COMMENTED OUT TO CATCH UNDEF GLOBALS @

USPY::	POPJ P,	;NO MORE SPY UUO.
COMMENT @ SUBROUTINE KILPGS VERSION 2 CALL UUOS
FUNCTION: VCLEAR PAGES FROM T1/START VP TO T2/STOP VP
EXPECTS: T1,T2,J/JOB
CALL:	MOVEI T1,START VP
	MOVEI T2,STOP VP
	PUSHJ P,KILPGS
	ALWAYS RETURN HERE
FAIL:	STOPCD IF START>STOP.
CALLS:	VCLEAR UUO
DESTROYS: T1,T2,W
IDIOSYNCRACIES: IF START=STOP, VCLEAR THAT PAGE ONLY.
RESTRICTIONS: CALL ONLY AT UUO LEVEL DUE TO VCLEAR WAIT

@

KILPGS::
	CAMLE T1,T2
	STOPCD
	TDNN T1,[-1,,777000]	;ALLOW PAGE NOS. 0-777 ONLY
	TDNE T2,[-1,,777000]
	STOPCD
	HRRZI W,1(T2)
	SUB W,T1
	HRLZS W
	IOR W,T1	;W/[STOP-START+1],,START
	HLRZ T2,JBTUPM(J)	;EXISTENT PAGES
	JUMPE T2,CPOPJ		;NOTHING TO DO
	VCLEAR W,
	STOPCD		;ANY ERROR IMPLIES BAD PAGE NO
	POPJ P,


COMMENT @ SUBROUTINE CORXPN VERSION 2
FUNCTION: TO VCREAT PAGES FROM T1/START PG TO T2/STOP PG
	STATUS PRIV RDW, & PUT THEM IN UWS.
RESTRICTIONS: STOPCD IF START>STOP
	LMAP MUST BE IN %UPT..
DESTROYS: W,T1
CALL:	MOVEI T1,START VP#
	MOVEI T2,STOP VP#
	PUSHJ P,CORXPN
	ERROR RTN, T1 CLOBBERED, W/ VP#,,ERROR CODE
	SUCCESS RTN T1,T2 UNCHANGED
@

CORXPN::
	CAMGE T2,T1
	STOPCD
	TDNN T1,[-1,,777000]
	TDNE T2,[-1,,777000]
	STOPCD
	HRRZI W,1(T2)
	SUB W,T1
	HRLZS W
	IOR W,T1	;W/ [STOP-START+1],,START
	PUSH P,W
	TLO W,<CPRRDW>B<^D7+^D18>
	VCREAT W,
	 JRST [	POP P,T1
		POPJ P,]
	POP P,W
	TLO W,WS.ADD	;ADD-TO-UWS BIT
	MOVE T1,[XWD .WSRNG,W]	;SET WS BY RANGE, ARG BLOCK W
	WSCTL T1,
	PUSHJ P, [HRRZS T1	;ERROR CODE
		CAIE T1,WSATM%	;"ADDED TOO MUCH"?
		STOPCD
		POPJ P,]
	JRST CPOPJ1
COMMENT @ SUBROUTINE KILLLS
FUNCTION: KILL PAGES 1-377, LEAVE PG 0 ALONE, SET JOBREL/0,,777
RESTRICTION: DESIRED LMAP MUST BE IN %UPT..; THIS ROUTINE
	WRITES ON JOBDATA AREA IN USER SPACE SO PREVIOUS
	CONTEXT MUST NOT BE MONITOR SPACE.
STOPCD: NEVER
RETURN:	NOSKIP RTN ALWAYS
DESTROY:T1,T2,W, (PG?,..)
@
KILLLS::MOVEI T1,777
	UXCTBU <HRRZM T1,JOBREL>
	HRRM T1,%UPT+UPTREL
	MOVEI T1,1
	MOVEI T2,377
	PJRST KILPGS


COMMENT @ SUBROUTINE KILLHS-- KILL EVERYTING FROM 400 - 777

RESTRUCTION: DESIRED LMAP MUST BE MAPPED IN %UPT..
DESTROYS: T1,T2,W, RESETS JOBHRL
RETURNS:	ALWAYS NOSKIP RETURN
STOPCD: NEVER
CALLS: KILPGS
@

KILLHS::MOVEI T1,400
	MOVEI T2,777
			;CLEAR LH JOBHRL=1ST FREE IN HISEG,
	UXCTTU <SETZM JOBHRL>	;RH_HI ADDR
	HLLZS %UPT+UPTHRL
	PJRST KILPGS


COMMENT ! DO NOT CALL KILLLS OR KILLHS FROM WITHIN
	UUO'S ISSUED BY THE MONITOR, WITHOUT CHANGING THE
	EXECUTIVE XCT'S HERE TO USE DOXCT
	IN CORE1.
!
COMMENT @ SUBROUTINE READLS

FUNCTION: CREATE A "LOW SEGMENT" OF PRIVATE RDW PAGES
	COPIED FROM THE FILE/DEVICE ON RUNCHN.
	
	SET JOBREL&UPTREL WHEN DONE. SEGMENT SIZE IN 1K INCREMENTS

	READLS ASSUMES THAT ADJCOR HAS BEEN CALLED FIRST IF
	A HISEG EXISTS, TO REDUCE XPANEW. READLS VALIDATES
	XPANEW AGAINST THE SIZE PRESENTED IN P4, USING CKIOWD.
	CKIOWD DOES NOROOM IF XPANEW IS TOO SMALL.

	READLS IS THE ONLY PLACE CKIOWD IS CALLED DURING A GET.


	WHERE POSSIBLE, READLS WILL MAP THE REQUESTED LOW
	FILE INTO USER SPACE ABOVE UPTREL/HRL AND
	BLT THE WHOLE BUSINESS DOWN INTO ITS PROPER POSITION
	BEFORE CALLING EXPAND. 


EXPECTS: PG/ ADDR OF ARG BLOCK IN PDL
	F/DDB FOR RUNCHN
	P2-P4 AS RETURNED BY DOLOOK, P4/SIZE IN WORDS
		(EXCEPT IF DVMTA, P4/0)
	PAGE 0 EXISTS, NO OTHER LOWSEG MEMORY
	XPACOM(PG)/ XXX,,JOBSVM
	J/JOB
CALL:
	PUSHJ P,READLS
	 ERROR RETURN
	SUCCESS RETURN
	(ANY I/O ERRORS RETURN DIRECTLY TO USER/CMD LEVEL VIA SGIOCK)
DESTROYS: T1-4,,,S
RETURNS:	RUNCHN OPEN, RDW MEMORY ASSIGNED& IO COMPLETE
	FILE EXPANDED IF EXPANSION NEEDED

RESTRICTIONS: THIS ROUTINE WRITES ON JOBREL IN PREVIOUS
		CONTEXT. THAT HAD BETTER BE THE USER SPACE.
	ALSO THIS CALLS EXPAND WHICH WRITES ON PREVIOUS SPACE.
CALLS: CORXPN,SGDO(SGIOCK,EXPAND),VCREATE,PAGSTS,INPUTUUO

MAGTAPE IDIOSYNCRACIES:  P4/0 FORCES USE OF XPANEW IOR 1777
	WHICH IS THE VALUE RETURNED BY CKIOWD. THUS IF USER
	GIVES NO CORE ARG HE GETS 1K AND RECORDS ON TAPE WILL
	BE READ INTO THAT 1K UNTIL IT OR RECORDS ARE EXHAUSTED.
	IF THERE ARE MORE THAN 1K OF RECORDS, THE REST
	ARE LOST AND (IS THERE AN ERROR INDICATION?) MERRILY
	WE PROCEED.

@

RDLSW:	EXP 1	;PATCH THIS SWITCH TO TURN OFF MAPPING LOWSEGS
READLS::
	JUMPL P4,CPOPJ	;FILE TOO BIG OR SIZE <0 ( ? ! )
	CAILE P4,777777
	POPJ P,
	MOVN T2,P4
	PUSHJ P,CKIOWD	;RET IF ALL OK, T1/MAX(SIZE,XPANEW) IOR 1777
	PUSH P,T1	;SAVE +(SIZE OF CORE AREA)
	MOVN T2,T1
	ADDI T2,JOBSVM
	SKIPE P4	;IF MAG TAPE, IOWD LENGTH = XPANEW-JOBSVM
	MOVN T2,P4	;ELSE FOR DSK,FILE LENGTH
	HRLM T2,XPACOM(PG); -LENGTH,,JOBSVM
	LSH T1,-9	;FOR CORXPN. STOP PG
	MOVEI T2,1	;START PG.
	EXCH T1,T2
	PUSHJ P,CORXPN	;FROM 1 TO (XPANEW OR FILE SIZE) IOR 1777
	JRST TPOPJ	;FIX PDL GET SIZE BACK,FAIL RETURN
	POP P,T1	;SAVED +SIZE
	UMOVEM T1,JOBREL
	HRRM T1,%UPT+UPTREL
	SKIPE P4	;MAG TAPE DEVICE?
	SKIPN RDLSW	;SWITCH PATCHED?
	JRST RDLSUU	;MT OR JUST DO INPUT UUO ALWAYS

	HRRZ T2,%UPT+UPTHRL
	CAMG T2,T1	;IF END OF HISEG < END LOWSEG
	MOVE T2,T1	;USE END OF LOWSEG
	MOVEI T4,1(T2)
	LSH T4,-9	;T4/BEG PG NO OF MAPPING AREA
	MOVE T3,P4	;GET T3 TO
	ADDI T3,777	;BE FILE SIZE IN
	LSH T3,-9	;PAGES
	MOVEI T1,777777	;END OF 256K
	SUB T1,T2	;WORDS AVAIL FROM END LOW[HI]SEG TO END MEMORY
	LSH T1,-9	;AVAIL PGS
	CAMGE T1,T3	;AVAIL .GE. FILE SIZE?
	JRST RDLSUU	;NO, DO INPUT UUO
	HRLZ T2,T3	;T2/<CONTIG>,,0
	HRR T2,T4	;T2/<CONTIG>,,BEG VP FOR MAPPING
	MOVE T4,T2	;A COPY FOR VREMOV BELOW
	TLO T2,<CPRRED>B<^D7+^D18>
	PUSH P,JBTPRV(J)
	MOVEI T1,177
	DPB T1,PVYCOR	;CAN HAVE 256K FOR A MOMENT
	MOVEI T3,1	;FILE PAGE TO BEGIN MAPPING
	MOVE T1,[FNCMDP,,RUNCHN]
	CHANIO T1,T2	;T2,T3 IS THE ARG BLOCK. MAP THE WHOLE FILE
	JRST RDLSFM	;TROUBLE. ANALYZE
	POP P,JBTPRV(J)	;BACK TO HIS CORE LIMIT
	HLRO T2,XPACOM(PG)	;-WORDS IN FILE
	MOVNS T2
	MOVE T3,T2	;A COPY FOR BLT PTR COMPUTE BELOW
	ADDI T2,177	;ROUND UP TO BLOCK BDRY
	LSH T2,-7	;T2/BLOCKS IN FILE
	ADDM T2,JBTRCT	;TREAT AS IF THESE BLOCKS WERE INPUT
	ADDM T2,JBTRCT(J)
	PUSHJ P,GTCGSZ	;GET T1/CHARG SIZE IN K. CLOBBER NO AC'S
	IMUL T1,T2	;T1/BLKS READ * JOB SIZE
	ADDM T1,JBTSIN
	ADDM T1,JBTSIN(J)
	MOVE T2,T4	;CONTIG,,BEG VP
	TLO T2,WS.ADD
	MOVE T1,[.WSRNG,,T2]
	WSCTL T1,	;T2 IS ARG BLOCK
	JFCL
	HRRZ T1,XPACOM(PG)
	ADDI T1,1	;T1/USERADDR=JOBSV
	HRRZ T2,T4	;T2/BEG PG MAPPING AREA
	LSH T2,9	;CONVERT VP# TO WORD NO.,MAPPED AREA
	HRL T1,T2	;T1/MAPPED WORD ADDR,,JOBSV
	HRRZ T2,XPACOM(PG)	;T2/JOBSVM
	ADD T2,T3	;T2/JOBSV+FILESIZE-1=END OF BLT
	XCTBU <BLT T1,(T2)>	;FROM HI USER SPACE TO LOW
	VREMOV T4,	;GET RID OF MAPPED STUFF NOW,BLT DONE
	STOPCD
	PUSHJ P,EXPAND	;FINISH UP LIKE SGDO
	JRST CPOPJ1	;& SKIP RETURN

RDLSFM:	;MAP THE WHOLE FILE FAILED. 
	POP P,JBTPRV(J)
	HRRZ T3,T1	;MAP ERROR CODE
	CAIE T3,FALLKO	;LOOKUP ONLY
	CAIN T3,FALBDS	;BAD SAT
	JRST MAPIOF	;GIVE "TRANS. ERROR" MSG & STOP JOB
	CAIE T3,FALHOL	;FILE HAD A HOLE?
	CAIN T3,FALRBE	;RIB ERR
	JRST MAPIOF
	STOPCD		;SOME OTHER ERROR. BUG.

; RDLSUU -- DO LOWSEG VIA INPUT UUO AS IN OLD SYSTEM.
;	build IOWD command list in T1,T2,T3 - may have to break it
;	in half if lh(XPACOM) so big it appears positive

RDLSUU:	MOVE 	T1,XPACOM(PG)
	SETZB	T2,T3
	JUMPL	T1,RDLSU1	;check for overflow; (+)
	MOVE	T2,T1		;too big - break it in half
	HRLI	T1,-400000
	ADD	T2,[400000,,400000]
RDLSU1:	PUSHJ 	P,SGDO		;WILL EXECUTE THE FOLLOWING UUO:
	INPUT 	RUNCHN,T1	;AND EXPAND CORE IF REQURED
				;(EXPAND MAY DO CORE UUO & CHANGE
				;JOBREL & UPTREL)
	JRST CPOPJ1
COMMENT @ SUBROUTINE READHS

FUNCTION: CREATE A PRIVATE RDO "HISEG" OF PAGES
	READ OFF OF MAGTAPE ON RUNCHN, USING INPUT UUO.

	NOT USED FOR FILES ON DSK. ONLY ON MAG TAAPE

	SET JOBHRL, UPTHRL PROPERLY

CALL:	
	MOVE F,%UPT+UPTJDA+RUNCHN
	PUSHJ P,READHS
	 SUCCESS RTN: ALL I/O COMPLETE,MEM MADE RDO,
		RUNCHN OPEN. 
	 ERROR RETURN: SOME (MAYBE 0) RDW MEMORY ASSIGNED,
		RUNCHN OPEN. 
		T1/ 0 - CORXPN FAIL. NOROOM
		T1/1 -  SIZE ON TAPE BAD or VPROT failure
		T1/ 2 - SIZE ON TAPE 0 - NULL HISEG RECORDED
			or EOF seen
DESTROYS: T1-T4
CALLS: INPUT,VPROT,CORXPN,SGIOCK
I/O ERROR: SGIOCK EXITS TO USER/CMD LEVEL IF
	ANY I/O ERROR. NO RETURN TO READHS.
RESTRICTIONS: WRITES ON JOBHRL IN PREVIOUS CONTEXT. MAKE SURE
		THAT THAT IS USER SPACE. (PC.UIO !)
@


READHS::
	MOVE T3,DEVMOD(F)
	TLNN T3,DVMTA	;IF ITS NOT A MAG TAPE DEVICE,
	STOPCD		;CALLER CONFUSED
	MOVEI T2,<MTSIZ+377777>B<^D35+^D9>	;STOP PG
	MOVEI T1,400	;START
	PUSHJ P,CORXPN
	JRST RDHSE0	;FRET ERR CODE 0
	MOVSI T1,-MTSIZ
	HRRI T1,400000-1; -(SIZE),,377777
	MOVEI T2,0	;IOLST_T1,T2
	INPUT RUNCHN,T1	;READ THE STUFF 
	PUSHJ P,SGIOCK	;RET IF ALL OK, ELSE TO USER/CMD LEVEL
	TRNE S,IODEND		;EOF? S SETUP BY SGIOCK
	JRST RDHSE2		;THERE IS NO HISEG
	UHLRZ	T2,JOBHCR+400000	;HI LOSEG NONZERO DATA LOC
	UHRRZ	T1,JOBHCR+400000	;SAVE TO TAPE CORE ARG
	CAMG	T1,T2			;USE THE LARGER VALUE
	MOVE	T1,T2
	MOVEI	T2,-1			;NOW MAKE SURE XPANEW
	TDNN	T2,XPANEW(PG)		;IS SET UP FOR READLS
	HRRM	T1,XPANEW(PG)		;OTHERWISE ONLY 1K ASSIGNED
					;FOR READING LOWSEG OFF OF TAPE
	UHLRZ T2,JOBHRN+400000	;REAL SIZE OF THE HISEG
	JUMPE T2,[MTAPE RUNCHN,16	;SKIP OVER EOF
		  JRST RDHSE2]	;FRET CODE 2
	PUSH P,T2
	CAIG T2,MTSIZ	;WHOLE HS IN 1 RECORD?
	JRST RDHS1	;YUP
	ADDI T2,400000
	LSH T2,-9	;STOP PAGE
	MOVEI T1,401	;START PAGE. ALREADY CREATED PG 400
	CAIG T2,777	;
	CAMGE T2,T1	;VALIDATE SIZE RECORDED ON TAPE
	JRST [POP P,T1	;BAD
		JRST RDHSE1]	;FRET CODE 1
	PUSHJ P,CORXPN
	JRST [POP P,T1	;FRETURN NOROOM
		JRST RDHSE0]	;CODE 0
	MOVN T1,0(P)	;-SIZE
	MOVSI T1,MTSIZ(T1)	;-(SIZE-MTSIZ),,0 ADJUST FOR
	HRRI T1,377777+MTSIZ	;1 RECORD ALREADY READ
		;T1/ -SIZE+MTSIZE,,377777+MTSIZ = IOWD
	MOVEI T2,0	;T1,T2 ARE IOLST
	INPUT RUNCHN,T1
	PUSHJ P,SGIOCK	;RETURNS ONLY IF NO IO ERRORS
RDHS1:	STATO RUNCHN,IOTEND+IODEND	;MAGTAPE AT END OF TAPE OR END OF FILE?
	MTAPE RUNCHN,16		;NO, SKIP OVER THE EOF
	SETSTS RUNCHN,DR		;RESET THE EOF BIT
;NOW MAKE HISEG MEMORY RDO.
	MOVE T1,0(P)	;T1/SIZE
	ADDI T1,777	;CONTIG=SIZE+777 LSH -9
	LSH T1,-9
	HRLZS T1	;IN LH
	IOR T1,[<CPRRED>B7+400]
	VPROT T1,	;MAKE PGS 400->LENGTH RDO
	JRST [POP P,T1	;FAIL,RETURN
		JRST RDHSE1] ; CODE 1
	MOVE T3,[<CPRRED>B7+1B17+400]	;FOR ADD1PG
	POP P,T1	;+SIZE
	MOVEI T2,777(T1);PAGES IN SEG = SIZE+777 LSH -9
	LSH T2,-9	;FOR ADD1PG
	ADDI T1,377777
	TRNE T1,1000	;SKIP IF NEEDS 1 PG TO MAKE 1K MULTIPLE
	TROA T1,1777	;ALREADY OK
	PUSHJ P,ADD1PG
	UMOVEM T1,JOBHRL
	HRRM T1,%UPT+UPTHRL
	POPJ P,		;SUCCESS EXIT NOSKIP

;FAILURE RETURNS TO SETUP T1
RDHSE0:	JSP T1,RDHSEX
RDHSE1:	JSP T1,RDHSEX
RDHSE2:	JSP T1,RDHSEX
RDHSEX:	SUBI T1,RDHSE0+1
	HRRZS T1
	JRST CPOPJ1	;SKIP RTN FAILURE
COMMENT ! ROUTINE MAPHS
FUNCTION: CREATE A SEGMENT OF SHAREABLE PAGES MAPPED
	READ-ONLY FROM THE FILE OPEN ON RUNCHN, MAPPING
	INTO CONTIGUOUS VP'S STARTING AT 400. MAP CONTIGUOUS
	FILE PAGES STARTING AT FILE PG 1. ASSUME
	THAT THE FILE CONTAINS A LITERAL CORE IMAGE.
	(NO ZERO-COMPRESSION).

	FOR 'SWR' FILES ONLY, MAP PAGES MAX-WRITEABLE,
	BUT CURR PROT = RDO, SAME AS OTHERS.


	CREATE AN EXTRA PRIVATE WITH READ-ONLY CURRENT
	PROTECTION AT THE END OF THE "SEGMENT" IF
	ONE IS NEEDED TO MAKE AN EVEN 1K SIEGMENT SIZE.

	SET JOBHRL AND UPTHRL APPROPRIATELY. PUT ALL MAPPED
	PAGES IN UWS IF POSSIBLE. FLAG SG.SWR IN
	UPTSTS SET IF SEGMENT CAME FROM A .SWR FILE.

EXPECTS: F/DDB 	GETB SET UNLESS GETSEG; J/JOB
	P4/FILE SIZE IN WORDS
	P2/0,,EXT FROM LOOKUP
	P3/PROTECTION OF FILE FROM XPAPRV
CALL:	PUSHJ P,MAPHS
	ERROR RETURN: T4/VMAP ERROR CODE. SOME MEMORY ASSIGNED,
			RUNCHN OPEN.
	SUCCESS: CHAN OPEN, ALL MAPPING COMPLETE, SOME
		(HOLPFULLY ALL) PAGES IN UWS
DESTROYS: T1-T4
RESTRICTION: WRITES ON PREVIOUS ADDRESS SPACE AT JOBHRL. MAKE
	SURE THIS IS USER SPACE.
idiosyncracies:  This routine implements "writeable high-segments"
by a kludge.  When the extension is ".SWR" and the UUO is
RUN or RUNSEG, we set ENTRB so that MAP will set LMPMXW in all
slots.  Then we immediately turn off ENTRB. [Note that the
user may not have priv to, and may not have ever done, an ENTER
on the SWR file--this is what ENTRB usually implies].  If he
has not got at least update priv on the file, we set PVEXOG in
JBTPRV so that PVEXO will get set and he wont be able to meddle
with the prog/file.  If the ext is SWR and uuo is GETSEG, we
give him ENTRB only if he has update priv, and we don't bother with
PVEXOG.
!
EXTERN CHKACC	;IN FILFND
EXTERN FNCUPD,FNCRED,FNCEXC	;IN COMMOD
EXTERN FALCOR,FALRBE,FALBDS,FALLKO,FALHOL	;IN MAPIO
EXTERN GETLI1	;IN FILUUO (PART OF GETLIC)

MAPHS::
	MOVEI T4,FALCOR	;IN CASE WE FRET RIGHT HERE
	JUMPLE P4,CPOPJ	;FRET TOO SMALL
	CAILE P4,400000-1
	POPJ P,		;FRET TOO BIG
	MOVE T2,DEVMOD(F)
	TLNN T2,DVDSK	;IS IT A MAPPING DEVICE? SKIP IF YES
	STOPCD		;CALLER CONFUSED.
	PUSH P,P4	;SIZE
	CAIE P2,'SWR'
	JRST MAPHS1	;NOT FANCY. JUST SHR OR HGH
	MOVEI T1,FNCRED	;GETSEG NEEDS READ PRIV
	TLNE F,GETB
	MOVEI T1,FNCEXC	;RUN/RUNSEG NEEDS EXECUTE PRIV
	MOVE T4,P3	;PROT FROM LOOKUP
	MOVE T2,DEVPPN(F)
	PUSHJ P,CHKACC	;CAN HE EXECUTE[READ] IT?. SKIP YES
	JRST MAPHS1	;NO. MAP WILL FAIL
	MOVEI T1,FNCUPD
	MOVE T4,P3	;PROT FROM LOOKUP
	MOVE T2,DEVPPN(F)
	PUSHJ P,CHKACC	;SKIP IF FNCUPD OK. CLOB T1-T4 ONLY
			;EXPECTS J/JOB,T1,T2,T4
	SKIPA T1,[PVEXOG]	;NO UPDATE ACCESS
	MOVEI T1,0		;UPDATE ACCESS ALLOWED. NO EXO BIT
	TLNN F,GETB		;SKIP IF RUN/RUNSEG
	 JRST [JUMPN T1,MAPHS1	;GETSEG: IF NO UPDATE ACCESS,
		JRST MAPHS0]	;[T1/PVEXOG], AVOID SETTING
			;ENTRB. ELSE T1/0 UPDATE ACCESS OK, SET ENTRB
	IORM T1,JBTPRV(J)
MAPHS0:	MOVSI F,ENTRB		;KLUDGE: TRICK VMAP UUO INTO
	IORM F,%UPT+UPTJDA+RUNCHN  ;SETTING MAX-WRITE BITS
MAPHS1:	HRRZ T2,(P)	;SIZE
	ADDI T2,777	;CALCULATE CONTIG FOR VMAP
	LSH T2,-9
	PUSH P,T2	;SAVE CONTIG FOR CHARGING,ADD1PG
	HRLZS T2
	IOR T2,[<CPRRED>B7+400]	;T2/<PROT>B7+<CONTIG>B17+400
	MOVEI T3,1	;FILE PAGE NO.
	MOVE T1,[FNCMDP,,RUNCHN] ;FNC MAP DSK PAGES,,RUN CHANN
	CHANIO T1,T2	;T2,T3 IS THE ARG BLOCK
	JRST MAPHSE	;RECOVER FROM ERROR
	MOVSI F,ENTRB
	ANDCAB F,%UPT+UPTJDA+RUNCHN	;FIX F,ENTRB OFF IN BOTH
	TLZ T2,(<377>B7)
	TLO T2,WS.ADD	;PUT PAGECOUNT PGS IN UWS
	MOVE T1,[XWD .WSRNG,T2]	;FROM 400 ON, WSCTL FUNCTION .WSRNG
	WSCTL T1,
	PUSHJ P, [HRRZS T1	;ERROR CODE
		CAIE T1,WSATM%	;"ADDED TOO MUCH"?
		STOPCD		;BUG PROBABLY
		POPJ P,]	;OK TO IGNORE
	PUSHJ P,GETLI1		;GET T1/HI SEG FILE LICENSE
	MOVE T4,0(P)		;CONTIG. PAGES FOR CHARGING
	TRNE T1,LICXC		;XC LICENSE?
	  JRST NOCHRG		;YES. DON'T CHARGE FOR GET
	ADDM T4,JBTMPC		;SYSTEM MAPPED PAGE COUNT
	ADDM T4,JBTMPC(J)	;CHARGE THIS GUY
	PUSHJ P,CHGPWS	;TAKE T4. CHARGE FOR PUT IN WS. CLOB T1-T4
NOCHRG:	MOVE T3,[<CPRRED>B7+1B17+400]	;FOR ADD1PG
	POP P,T2	;CONTIG.
	POP P,T1	;SIZE
	ADDI T1,377777	;PROSPECTIVE JOBHRL
	TRNE T1,1000	;SKIP IF NOT 1K BOUNDARY YET
	TROA T1,1777	;IT'S OK, SKIP & SET JOBHRL
	PUSHJ P,ADD1PG	;RETURN T1/JOBHRL VALUE. TAKE T2/ T3/
	UMOVEM T1,JOBHRL	;CLEAR LH=1ST FREE,SET RH=HI ADDR
	HRRM T1,%UPT+UPTHRL
	MOVSI T1,SG.SWR	
	CAIN P2,'SWR'	;IF .SWR FILE, FLAG THAT
	IORM T1,%UPT+UPTSTS	;IT IS, FOR SAVJOB & SETUWP UUO
	JRST CPOPJ1

MAPHSE:	;HERE IF CHANIO VMAP FAILS.
	POP P,T4	;CONTIG, FORGET IT
	POP P,T4	;SIZE. FORGET IT
	MOVSI F,ENTRB
	ANDCAB F,%UPT+UPTJDA+RUNCHN	;ENTRB OFF IN F,MEMORY
	HRRZ T4, T1	;ERROR CODE
	CAIE T4,FALLKO	;LOOKUP ONLY
	CAIN T4,FALCOR	;OVER CORE LIMIT
	POPJ P,
	CAIE T4,FALRBE	;RIB ERR
	CAIN T4,FALBDS	;BAD SAT
	POPJ P,
	CAIN T4,FALHOL	;HOLE IN FILE?
	POPJ P,
MAPHSF:	STOPCD		;SOME OTHER ERROR
COMMENT @ SUBROUTINE ADJCOR
FUNCTION: COMPARE XPANEW (USERS NEW-CORE-SIZE ARG) WITH SIZE
	OF THE HISEG PASSED IN T2, AND REDUCE XPANEW AS
	FOLLOWS:
	IF SIZE .LE. 0 THEN STOPCD   CALLER CONFUSED
	IF XPANEW=0 THEN RETURN, USER DIDNOT SPECIFY NEWCORE
	IF XPANEW>SIZE THEN XPANEW:=XPANEW-SIZE
	ELSE RETURN
CALL:	MOVE T2,SIZE OF PROSPECTIVE HS TO BE READ IN/MAPPED IN
		OR,
	MOVE T2,SIZE OF EXISTING HISEG  (SAVE COMMAND)
	MOVE PG, ADDR OF USER ARG BLOCK IN UPTPDL
	PUSHJP,ADJCOR
	RETURN HERE T1,T2 DESTROYED, XPANEW ADJUSTED DOWNWARD
RESTRICTIONS: DONT CALL IF SIZE(HISEG) OR SIZE(FILE)=0
IDIOSYNCRACIES:
@


ADJCOR:
	SKIPG T2
	STOPCD
	HRRZ T1,XPANEW(PG)
	JUMPE T1,CPOPJ
	CAMLE T1,T2	;SKIP IF XPANEW .LE. SIZE
	SUB T1,T2
	HRRM T1,XPANEW(PG)
	POPJ P,

COMMENT @ SUBROUTINE ADD1PG

FUNCTION: FOR READHS,MAPHS. IF "SEGMENT" CREATED WAS
	NOT AN EVEN NUMBER OF PAGES, ADD 1 MORE PAGE AT ITS
	END, AND
	RETURN T1/ JOBHRL VALUE TO SET

CALL:	MOVE T2,COUNT OF PAGES CURRENTLY IN THE "SEGMENT"
	MOVE T3,<PROT>B7+1B17+BEGINNING PG NO OF SEGMENT
	PUSHJ P,ADD1PG
	RETURN HERE, T1/UPTHRL VALUE

ERROR EXIT: IF VCREAT FAILS, SET UP P4 FOR GTJBNR
	(GET JOB NOROOM EXIT) AND JSP. PDL GETS FIXED THERE.

DESTROY: T2,T3,T4,W,PG
RETURNS: T1/ VALUE FOR UPT<REL/HRL>
RESTRICTIONS:CALL ONLY IF 1 MORE PG NEEDED. DONT USE FOR LOWSEG

@

ADD1PG:	MOVE W,T3
	SKIPG T2	;GOTTA BE AT LEAST ONE PG
	STOPCD		;CALLER CONFUSED
	ADD W,T2	;W/<PROT>B7+1B17+NEW LAST PG IN SEG
	VCREAT W,	;W/<PROT>B7+1B17,,PAGE#
	JRST [	HLRZ P4,W	;FOR GTJBNR,FAILING VP#
		LSH  P4,9	;WORDS
		HRRZS W		;VCREAT ERROR
		CAIE W,CRLIM%	;OVER CORE LIMITS?
		CAIN W,CRDFL%	;OR NO DISK?
		JSP T1,GTJBNR	;KILL MEMORY & SAY "XX PGS NEEDED"
		STOPCD()]	;OTHER ERRORS IMPLY BUG
	TLZ W,(<377>B7)
	TLO W,WS.ADD	;W/<ADD>B7+1B17+VP#
	MOVE T1,[XWD .WSRNG,W]
	WSCTL T1,	;ADD TO WS BY RANGE
	JFCL		;PROBABLY "ADDED TOO MUCH" ERROR.
	HRRZ T1,W
	LSH T1,9
	IORI T1,1777
	POPJ P,
COMMENT @ SUBROUTINES LSSIZE, HSSIZE
FUNCTION:	RETURN SIZE IN PAGES OF "LOWSEG" AND "HISEG"
	FOR THE JOB WHOSE CONTEXT PAGES ARE MAPPED IN %UPT...
CALL:	MAP IN APPROPRIATE CONTEXT PGS
	PUSHJ P,LSSIZE
	OR
	PUSHJ P,HSSIZE
	SUCCESS RETURN  T2/NUMBER OF PAGES OR ZERO IF NONE
DESTROY: T2
RESTRICTIONS:

IDIOSYNCRACIES:  THE VALUE RETURNED IS THE PAGE NO. (RELATIVE TO 0 OR 400) OF
	THE HIGHEST PAGE IN THE "SEGMENT".  IF IT HAS HOLES,
	THEN THE VALUE RETURNED IS NOT REALLY THE SIZE OF THE
	SEGMENT

@

LSSIZE::
	HRRZ T2,%UPT+UPTREL
	LSH T2,-9
	POPJ P,

HSSIZE::
	SKIPN T2,%UPT+UPTHRL
	POPJ P,			;RET T2/0
	HRRZS T2
	LSH T2,-9
	SUBI T2,377
	POPJ P,
COMMENT @ SUBROUTINE HSEXIS

FUNCTION:	SKIP IF HISEG DOES NOT EXIST FOR THIS USER.
	WHAT THIS MEANS IS: DO NOT  SKIP IF USER CREATED A SET
	OF PAGES IN THE RANGE 400-777 VIA A REMAP,RUNSEG OR 
	GETSEG UUO, OR BY RUN OR GET CMD ON A .HGH OR .SHR FILE.

RESTRICTIONS:  CALL ONLY WHEN CONTEXT PAGES FOR JOB IN QUESTION
	ARE MAPPED IN %UPT..

DESTROYS: T1
CALL:	PUSHJ P,HSEXIS
	RETURN HISEG EXISTS
	RETURN HISEG DOES NOT EXIST

@

HSEXIS::
	HRRZ T1,%UPT+UPTHRL
	JUMPN T1,CPOPJ
	JRST CPOPJ1
COMMENT @ SUBROUTINE REPDP

FUNCTION: RESET PDL POINTER AS IT WAS BEFORE GTUARG OR SG1 WAS CALLED;
	IE, BEFORE THE USER ARG BLOCK WAS SET UP FOR REFERENCE
	BY XPAXXX(PG).
EXPECTS: (PG) POINTING AT 0TH WORD OF ARG BLOCK
CALL:	JSP T1,REPDP
	ALWAYS RETURNS HERE. T1 PRESERVED,PG DESTROYED
@

REPDP:	MOVE P,PG
	MOVEM T1,-1(P)	;OVERWRITE THE PUSHJ P,GTUARG CALL
	POP P,PG	;GET XPADEV,CLOBBER PG
	POPJ P,

COMMENT @ SUBROUTINE INIJDA - INIT JOB DATA AREA.

FUNCTION: FOR RUNUUO,RUN/GET CMDS, MOVE VESTIGIAL
	JOBDAT DOWN.
CALL:	PUSHJ P,INIJDA
	ALWAYS RETURN HERE
DESTROY: T1,T2
RESTRICTION: USE WHEN PAGE 0 EXISTS AND "HISEG" EXISTS
	USE ONLY WHEN PREVIOUS CONTEXT = USER SPACE (PC.UIO )
@

INIJDA:
	MOVSI T1,JOBSV		;CLEAR JOB DATA AREA
	HRRI T1,JOBSV+1		;WHERE IO WOULD BE DONE INTO
	XCTTU <SETZM JOBSV>	;IF A LOW FILE EXISTS
	XCTBU <BLT T1,JOBDA-1> ;DO THIS IN CASE THERE IS NO LOW FILE
	XCTTU <SETZM JOBDDT>	;ALSO CLEAR DDT STARTING ADDRESS
	HRROI T1,JOBPOP+400000	;ABSOLUTE ADDRESS OF HIGH SEG(LH=-1 FOR
				; POPS SO NO PDL UNDERFLOW)
	XCTBU <POP T1,JOBVER>	;RESTORE BOTH HALVES OF PROG. VERSION NO.
	XCTFU <POP T1,T2>		;RESTORE
	XCTBU <HLLM T2,JOBHRL> ; 1ST FREE LOC IN HISEG,REL TO 400000
	XCTBU <HRRZM T2,JOBREN> ;PROGRAM REENTER ADR, LH=0
				; SAVED FOR FUTURE USE
	XCTBU <POP T1,JOBCOR> ;HIGHEST DATA LOC IN LOW SEG(LH)
				; AMOUNT OF CORE IN RH TO BE ASSIGNED(#K-1)
	XCTBU <POP T1,JOB41>	;USER M HANDLER JSR
	XCTBU <POP T1,JOBSA>	;FIRST FREE LOC IN LOW SEG(LH), START COMMAND
				; STARTING ADDRESS(RH)
	POPJ P,
SUBTTL REMAP
COMMENT @ UREMAP - KERNEL OF REMAP UUO

FUNCTION: EMULATE THE FUNCTION OF THE OLD PRE-VM SYSTEM REMAP
	UUO AS CLOSELY AS POSSIBLE. DIFFERENCES:
1) THE OLD LOWSEG CAN BE DAMAGED AND PARTIALLY GONE
   BEFFORE THE REMAP IS COMPLETE.
2) THIS REMAP WILL NOT FAIL-RETURN TO THE USER ON ERROR
   IF ANY CHANGE HAS BEEN MADE TO VM SPACE AT OR ABOVE
   HIS CALLING PC VALUE

DESTROYS: T1-T4,P1-P4,F,S,
EXPECTS: PROPER LMAP MAPPED, J/JOB, T1/REQUESTED NEW TOP OF LOWSEG
RESTRICTIONS: THIS ROUTINE WRITES ON PREVIOUS CONTEXT AT JOBREL
	AND JOBHRL. DON'T CALL FROM EXEC IF PC.UIO=0
@


UREMAP::
	JUMPL T1,CPOPJ
	IORI T1,1777
	CAIG T1,400000-1
	XCTBU <CAMLE T1,JOBREL>
	POPJ P,
	MOVE P1,T1
	MOVEI F,0	;FLAGS. 1B35=0 SAYS NO CHANGE TO VM SPACE
	PUSHJ P,HSEXIS	;SKIP IF NO HISEG. THIS IS IMPORTANT.
		;PAGES MAY EXIST ABOVE 400 AS PART OF "LOWSEG"
		;BEING REMAPPED. KILL ONLY "HISEG" PAGES.
	PUSHJ P,[TRO F,1	;FLAG CHANGE MADE VM SPACE
		PJRST KILLHS]
	XCTBU <HRRZ P4,JOBREL>
	CAMN P1,P4
	POPJ P,		;FAIL RET W/OLD HISEG GONE
	MOVNI S,1	;SETUP S AS FLAG: IF REQUEST=377777
	CAIN P1,377777	;THEN NO NEED TO REPLICATE PAGES, JUST
	MOVEI S,0	;MAKE THEN RDO WHERE THEY ARE.
	TLO F,(1B0)	;FLAG IN F: IF LOWSEG>128K & REQ<377777,
	CAILE P4,377777	;THEN TOP PART OF LOWSEG WILL BE IN THE
	CAIL P1,377777	;WAY FOR LAST FEW REPLICATES. MUST VREMOV
	JRST .+2	;PAGES ONE AT A TIME AS THEY ARE REPLICATED
	TLZ F,(1B0)	;OTHERWISE CAN VREMOV ALL IN ONE CALL AT END
UREMP2:	;SAVE PVYCOR USER MAX CORE SIZE AND SET TO MAX
	;SO REPLICATES DONT GO OVER MAX CORE.
	;CHECK OUT HISEG SIZE, & SET UP FOR REPLICATE LOOP
	PUSH P,JBTPRV(J)	;SAVE HIS PVYCOR & STUFF
	MOVEI T1,177		;CAN HAVE 255K DURING REMAP
	DPB T1,PVYCOR
	LSH P4,-9	;PAGE NO. LAST PG TO REMAP
	HRRZI P3,1(P1)
	LSH P3,-9	;PAGE NO. 1ST PG TO REMAP (REQ+1)LSH -9
	SUBI P4,400(P3)	;PROSPECTIVE HISEG>400000 WORDS?
	JUMPG P4,URMPFX	;YES. ILLEGAL
	ADDI P4,400(P3)	;RESTORE P4
	JUMPE S,[ SUB P4,P3	;COUNT OF PAGES MOVED
		HRLZI T2,1(P4)	;CONTIG. PG. COUNT FOR VPROT
		HRR T2,P3
		TLO T2,<CPRRED>B<^D7+^D18>
		VPROT T2,	;SET RDO PROT ON PGS 400->END
		JRST URMPFX
		JRST UREMP7]	;FINISH UP
	MOVEI T1,T2	;POINT AT ARG BLOCK T2:T3
	MOVE T3,P4	;FOR T3_LAST(P4) STEP -1 UNTIL FIRST(P3)
		;REPLICATE(SOURCE=T3,PROT=RDO,DEST=400+T3-P3)
		;IF (F=0) THEN VREMOV(PAGE=SOURCE PAGE=T3)
		;ELSE WAIT TO DO REMOV'S UNTIL LOOP DONE
		;DONE LOOP
UREMP3:	HRRZ T2,T3
	ADDI T2,400
	SUB T2,P3
	TLO T2,<<CPRRED>B7+1B17>B<^D18+^D35>	;T2/<PROT>B7+1B17,,DEST. VP#
	VREPL T1,	;T3/SOURCE VP#.  T1/ ARG BLOCK
	JRST URMPFX
	TRO F,1		;FLAG THAT VM SPACE CHANGED
UREMP4:	JUMPL F,UREMP5	;F/1B0 IF DONT NEED TO VREMOVE PAGE AT A TIME
	HRRZ T2,T3
	TLO  T2,1	;T2/<COUNT=1>,,VP#
	;TLO T2,(1B7)	;NO CLR REF BIT
	VREMOV T2,
	JRST URMPFX
UREMP5:	SUBI T3,1	;STEP -1
	CAML T3,P3	;UNTIL P3
	JRST UREMP3
	SUB P4,P3	;COUNT OF PAGES MOVED
	HRLZI T2,1(P4)	;CONTIGUOUS PG CT FOR VREMOV
	HRR T2,P3	;START VP#
	JUMPGE F,UREMP6	;JUMP IF WE ALREADY DID THE VREMOVS
	;TLO T2,(1B7)	;NO CLR REF BIT
	VREMOV T2,
	JRST URMPFX
UREMP6:	HRRI T2,400	;<CONTIG>,,START VP#
	TLO T2,WS.ADD	;ADD-TO-UWS BIT
	MOVE T1,[XWD .WSRNG,T2]	;ADD TO WS BY RANGE
	WSCTL T1,
	PUSHJ P, [HRRZS T1	;ERROR CODE
		CAIE T1,WSATM%	;"ADDED TOO MUCH"?
		STOPCD		;BUG IN UREMAP
		POPJ P,]	;OK TO IGNORE
UREMP7:	;FROM UREMP2 TO UREMP7 JBTPRV(J) IS SAVED ON PDL. RESTORE
	;IT, SET JOBHRL & UPTHRL ETC.
	POP P,JBTPRV(J)
	LSH P4,9	;WORDS. SIZE NEW HISEG
	IORI P4,400000+777;NEW LAST HISEG ADDR
	UXCTBU  <HRRM P4,JOBHRL>	;SET RH; LH= 1ST FREE IN HS, LEAVE ALONE
	HRRM P4,%UPT+UPTHRL	;AND SYSTEM'S COPY
	UXCTTU  <MOVEM P1,JOBREL>	;KEEP LH JOBREL CLEAR
	HRRM P1,UPTREL+%UPT
	MOVSI T1,SG.SWR		;CLEAR THE "SWR" SEGMENT STATUS
	ANDCAM T1,%UPT+UPTSTS	;BIT. THIS SEG CREATED BY REMAP
	JRST CPOPJ1

URMPFX:	;HERE IF SOME VUUO FAILED,ETC. F/1B35 SET IF ANYTHING
	;DONE TO VM SPACE. (IE.,KILLHS,VREPL,VREMOV)
	;P1/REQUESTED JOBREL=ADDRESS AT WHICH WE BEGAN DIDDLING VM SPACE
	;0(P)/ SAVED JBTPRV, WITH PVYCOR

	POP P,JBTPRV(J)
	HRRZ T1,%UPT+UPTPDL	;USERS CALLING PC
	TRNE F,1
	CAMG T1,P1		;IF CALLERS PC ABOVE REQUEST AND
	POPJ P,
	PJRST ERRRMF	;REMAP UUO FAILURE
SUBTTL RUNSEG/GETSEG

COMMENT ! URUNHI -- KERNEL OF RUNSEG UUO
	  UGETHI -- KERNEL OF GETSEG UUO
FUNCTION: CALLED LIKE RUNUUO. REPLACE ANY EXISTING PAGES
	IN HISEG (ANY PAGES WHATSOEVER IN 400-777) WITH
	THE CORE IMAGE LIVING IN THE FILE NAMED BY THE
	USER. IGNORE THE USER'S EXTENSION: SEARCH FOR
	FN.SHR, FH.HGH, FINALLY FN.SWR. IF NONE OF THESE
	FOUND, FRETURN. IF ONE IS FOUND, MAP IT IN UNLESS
	IT'S ON MAGTAPE, IN WHICH CASE READ IT IN.

	FOR GETSEG, RETURN AFTER VM SET UP. FOR RUNSEG,
	INITIALIZE SOME OF JOBDAT FROM VESTIGIAL JOBDAT,
	SETUP EXO,LICENSE AND WRITE ACT RECORD, RESET
	TRAPS, AND RUN HIM FROM JOBSA FROM THE VESTIG. JOBDAT.

DESTROYS: MOST AC'S
EXPECTS: J/JOB, T1/USER ADDR INCR,,ARG BLK ADDR

IDIOSYNCRACIES: DESTROYS OLD HISEG BEFORE NEW ONE READ
	IN (UNLIKE PRE-VM SYSTEM). NO RETURN TO USER IF
	ERROR OCCURS AFTER OLD HISEG REMOVED.

!

URUNHI::
	AOS RNSGCT		;KEEP TRACK OF RUNSEG'S DONE
	PUSHJ P,GTUARG	;PUT USER ARGS IN PDL, SETUP PG
	MOVEM P2,JBTNAM(J)
	MOVSI F,GETB
	JRST RNGT0	;COMMON CODE

UGETHI::
UGTSEG::
	AOS GTSGCT		;KEEP TRACK OF GETSEG'S DONE
	PUSHJ P,GTUARG
	MOVEI F,0	;NO GETB. USER MUST HAVE READ ACCESS TO
			;FILE FOR GETSEG TO WORK

RNGT0:	;COMMON RUNSEG/GETSEG CODE.
	XCTBU <HRRZ T4,JOBREL>
	CAIL T4,400000	;IF HE ALREADY HAS >128K LOWSEG,
	JRST NORMFX	;CANT DO RUN/GETSEG
	TLNN F,GETB	;SKIP IF RUNSEG
	JRST RNGT1
	MOVE T1,JBTPRV(J)	;IF CURRENTLY EXECUTE-ONLY,
	TRNE T1,PVEXO		;MAKE SURE NEXT PROGRAM IS
	TROA T1,PVEXOG		;EXECUTE ONLY ALSO
	TRZ T1,PVEXOG
	MOVEM T1,JBTPRV(J)
RNGT1:
	PUSHJ P,SETOPN	;SETUP T1-T3
	OPEN RUNCHN,T1
	JRST SGERRA	;HANDLES RET TO USER/CMD LEVEL
	IORB F,%UPT+UPTJDA+RUNCHN	;SET GETB RUNSEG ONLY
	MOVSI T1,'SHR'	;BEGIN SEARCH SEQ
	PUSHJ P,DOLOOK
	 JRST [	MOVSI T1,'HGH'
		PUSHJ P,DOLOOK
		 JRST [	MOVSI T1,'SWR'
			PUSHJ P,DOLOOK
			JRST NOFILE
			JRST RNGT2]
		JRST RNGT2]
RNGT2:	;HERE P2,P3,P4 ARE RETURNED BY DOLOOK P4/SIZE IN WORDS
	PUSHJ P,TIMADJ		;NEW SPACE-TIME INTEGRAL. NO AC CLOB
	PUSHJ P,KILLHS	;NO MEM ABOVE 400 ON RETURN
	MOVSI T1,SG.SWR
	ANDCAM T1,%UPT+UPTSTS
	HRRZ T1,%UPT+UPTPDL	;USER'S CALLING PC
	CAIL T1,400000		;IF FROM JUST-DELETED HISEG,
	HRRZS %UPT+UPTPDL	;NO FRETURN TO USER. PC.USR_0
	MOVE T1,DEVMOD(F)	;F SETUP FROM IORB ABOVE
	TLNE T1,DVMTA	;IF MAGTAPE, READ PAGES
	JRST [	PUSHJ P,READHS	;USING INPUT UUO
		JRST RNGT3	;SUCCESS
		PJRST ERRMGF]	;MAGTAPE GET FAILURE
	PUSHJ P,MAPHS		;MAP THE PAGES
	JRST RNGTF0		;TROUBLE
RNGT3:	;SUCCESS..NEW CORE IMAGE GOTTEN
	TLNN F,GETB		;IF GETSEG,
	JRST [	JSP T1,REPDP	;FIX PDL,
		PUSHJ P,SGREL	;RELEASE RUNCHN
		MOVSI T1,PC.USR
		IORM T1,%UPT+UPTPDL	;(IN CASE WAS TURNED OFF)
		JRST CPOPJ1]	;SRETURN TO USER.
	PUSHJ P,GETLIC	;TAKES F. GET T1/..,,FILE LIC
	SKIPA		;DSK RTN
	MOVEI T1,0	;MAG TAPE RTN
	HRLM T1,XPALIC(PG)	;
	MOVSI T1,HSLIC
	IORM T1,XPAMOD(PG)
	MOVE T1,XPAPID(PG)	;GET PID, IF ANY, FROM HS FILE
	MOVEM T1,XPAHPD(PG)	;PUT WHERE GTJBFN WANTS IT
	PUSHJ P,GTJBFN
	HRROI T2,JOBPOP+400000	;MOVE VESTIGIAL JOBDAT DOWN
	XCTBU <POP T2,JOBVER>
	XCTFU <POP T2,T1>
	XCTBU <HRRZM T1,JOBREN>
	XCTBU <POP T2,JOBCOR>
	XCTBU <POP T2,JOB41>
	XCTFU <POP T2,T1>	;LEAVE JOBFF ALONE
	XCTBU <HRRM T1,JOBSA>	;IN LH OF JOBSA
	XCTBU <SETZM JOBDDT>
	MOVEI T1,0
	PUSHJ P,APRENB		;RESET TRAPS
	MOVE	T1,JBTSTS(J)
	TRZ	T1,WAKFLG+EXCFLG	;RESET WAKE AND EXIT IN CHILD
	MOVEM	T1,JBTSTS(J)	; INTERRUPT PENDING FLAGS
	JRST RNSEG	;GO START HIM UP

RNGTF0:	;MAPHS FAILED. T4/CODE
	CAIE T4,FALCOR	;OVER CORE LIMIT
	JRST MAPIOF	;GIVE POPJ TRNERR CODE TO USER OR
			;RETURN TO CMD LEVEL IF PC.USR OFF, WITH
			;MSG "TRANS. ERROR".
	MOVE T4,P4	;SIZE RETURNED BY DOLOOK
	PUSHJ P,KILLHS	;ZAP ANY PORTION OF HISEG GOTTEN,
NORMFX:
	;JSP T1,REPDP
	PUSH P,T4	;NOROOM EXPECTS THIS
	JSP T1,NOROOM	;AND SAY "XX PAGES NEEDED"
SUBTTL SETUWP UUO
COMMENT @ USTUWP - KERNEL OF SETUWP
FUNCTION: SET PROT ON ALL HISEG PAGES (ANY PAGES BETWEEN
	400 AND UPTHRL) TO READ-ONLY (USER ARG NON-ZERO) OR
COPY-ON-WRITE (USER ARG 0) OR READ-WRITE (USER ARG 0
AND SEGNEMT WAS MAPPED FROM A 'SWR' FILE.


EXPECTS: T1/ARG (0:SET RDW   1:SET RDO)
	J/JOB    M/USER AC#
DESTROYS: T1-T4,P1
RESTRICTIONS: 
@

USTUWP::
	MOVE P1,T1	;USERS ARG
	PUSHJ P,HSEXIS	
	JRST USTUW0	;HS EXISTS
	AOS (P)		;GIVE SKIP RTN
	JRST RTZER	;NONE,GIVE OK RETURN WITH 0
			;AS PREVIOUS UWP SETTING
USTUW0:
	MOVEI T2,400
	PAGSTS T2,
	STOPCD		;NOT SUPPOSED TO HAPPEN
	ANDI T2,PS.CPR	;STATUS OF PG 400 CUR PROT ONLY
	CAIL T2,CPRCOW
	TDZA T2,T2
	MOVEI T2,1
	UMOVEM T2,(M)	;RETURN (IF CPRRED THEN 1 ELSE 0) TO USER
	PUSHJ P,HSSIZE	;RETURN T2/PAGES IN HISEG
	HRLZS T2
	MOVE T3,[<CPRRED>B7+400]
	JUMPN P1,USTUW1	;WANTS RDO
	MOVE T1,%UPT+UPTSTS
	MOVEI T3,400
	TLNN T1,SG.SWR
	TLOA T3,<CPRCOW>B<^D7+^D18>	;COW IF HGH OR SHR FILE
	TLO  T3,<CPRRDW>B<^D7+^D18>	;RDW IF SWR FILE
USTUW1:	IOR T2,T3	;T2/<PROT>B7+<CONTIG>B17+400
	VPROT T2,
	SKIPA
	JRST CPOPJ1	;SUCCESS
USTUW2:	MOVE T4,T2	;SAVE VPROT ERROR CODE
	PUSHJ P,HSSIZE
	HRLZS T2
	IOR T2,[<CPRRED>B7+400]	;MAKE HISEG RDO AGAIN
	VPROT T2,
	JFCL		;IFNORE FAILURES
	HRRZ T1,T4	;ORIGINAL VPROT ERROR CODE
	CAIE T1,PTPRF%	;PROT EXCEEDS ALLOWABLE
	CAIN T1,PTNVP%	;NON-EXISTENT VP (USER MAY HAVE VREMOVED ONE)
	POPJ P,
USTUW3:	STOPCD		;OTHER ERROR IMPLIES BUG
END
  }C[E