	TITLE	DR11C Interface to simulated Tymnet node
	SUBTTL	DSB, 3/11/79

;The DR11C simulates a channel for use JG's LSI11
; which simulates a Tymnet node.

;DR11C interrupt routine.
;Input ready for KS10 (REQUEST A):
;Routine IR, vector IRV.
;Normally, data is interpreted as a stream of 16 bit
; words to be deposited in the base-host ring.  The
; input handler expects non-data packets to use the 100
; bit of the packet type to indicate the packet length, and the
; special type 177 is reserved to indicate the
; start of a block mode i/o request.  If the 100 bit is
; on, the packet must be two pdp-11 words long.  If on
; and the low order 6 bits are not 77, the packet must
; be four pdp-11 words long.  Data packets contain
; a count of course.
;The packet type 177 signals a block i/o request.
; The next 2 pdp-11 words contain information about the
; direction, size and address involved.
; The whole packet looks like:
;   177 HOC   LOC HOA   MA LOA, where
; each group of two symbols represents two bytes within
; the pdp-11 word read.  HOC*400+LOC is the two's
; complement of the number of words to be transferred.
; If positive, this is a block mode output request for the
; specified number of words.  If negative, it is an input
; request; the number of words is the negative of the count.
; If the count is 0, the input handler crashes the system.
; HOA*400*400+MA*400+LOA is the pdp-10 address from which
; data is read or to which it is written.
;For block mode output, the address and count are stored,
; and the SBMO flag set.  The output handler will commance
; the output at some future time.
;For block mode input, the next pdp-11 words in the
; input stream are deposited starting at the
; specified address, and then the input handler reverts
; to its previous state.
;Output to node done (REQUEST B):
;Routine OD, vector ODV.
;Normally, data is taken from the host-base ring two
; bytes at a time and sent to the node.  To send the
; word with value ESCWD, send ESCWD followed by 0.
;When a block mode output request has been
; detected by the input done interrupt routine, normal
; operation is suspended and the request
; fulfilled, preceding the data by two
; words with values ESCWD followed
; by 1.
;  After the block mode transmission, normal output processing resumes.


;Clock level routine (CLKDR):
;This routine starts output if no output done interrupt
; is expected and a block mode output request has been
; made or the host-base ring isn't empty.
;Also, if input had to stop because the base-host ring
; was full (IRFULL<>0) and the ring now has some space,
; input is resumed.

	ENTRY	DR11C,DRINI

DR11C::

EXTERN EPT,CH7,IRING,ORING,IRP620,IRPPDP,ORP620,ORPPDP
EXTERN MSKIRG,MSKORG,KEYSET,CRSCHK,SYSCRS

ESCWD==177777

IROVF:	BLOCK 2
SBMO:	0
EDRODI:	0
IRFULL:	0
WRIOAC:	0
CLKOAC:	0
CLKT1:	0
CLKT2:	0
ODOAC:	0
IROAC:	0
BLXCNT:	0		;BUFFER WORD FOR BLOCK MODE OUTPUT COUNT
BLXPNT:	0		;BUFFER WORD FOR BLOCK MODE OUTPUT POINTER
BLKCNT:	0		;BLOCK MODE OUTPUT WORD (PDP-11) COUNT
BLKSIZ:	0		;BLOCK MODE OUTPUT BLOCK SIZE (FOR DEBUGGING)
BLKPNT:	0		;BLOCK MODE OUTPUT BYTE POINTER
OSTATE:	0		;CURRENT OUTPUT STATE (FOR DEBUGGING)

;DR11C hardware parameters.
DEFINE IOREG(REGISTERNAME,ADDRESS,BITNAMES,MSB)
<BIT==100000
IFNB <MSB>,<BIT==MSB>
IFNB <ADDRESS>,<DR'REGISTERNAME: 3,,ADDRESS>
IRP BITNAMES,<REGISTERNAME'BITNAMES==BIT
BIT==BIT/2
>>

IOREG(CSR,767770,<RB,,,,,,,,RA,IEA,IEB,,,,1,0>)
 ODV==304/4	;Node causes dispatch here when it's read OB.
 DRFN==CSR0   ;Data ready for node (set by KS10 after loading OB).
 IRV==300/4	;Node causes dispatch here when it's written IB.
 KRFMD==CSR1  ;KS10 ready for more data (set by KS10 after reading IB).
IOREG(OB,767772)
IOREG(IB,767774)

;Command to select ac block 4, which is used exclusively
; by the DR11C driver.
SDRACB:	404000,,0

	PAGE
	SUBTTL Node has data for KS10 interrupt

;HERE ON "INPUT DONE" INTERRUPT FROM DR11C

IR:	0			;JSR TO HERE ON INPUT READY INTERRUPT
	RDUBR	IROAC		;CHANGE AC BLOCKS
	WRUBR	SDRACB
	RDIO	T1,@DRIB	;Get word for us.
	MOVEI	U,KRFMD		;SET DR11C BIT INDICATING WE HAVE THE WORD
	BCIO	U,@DRCSR
	JRST	(P1)		;DISPATCH ON THE INPUT STATE

;HERE WHEN INPUT MESSAGE IS COMPLETE

IRPD:	MOVEM	T2,IRP620	;UPDATE INPUT PUTTER POINTER TO MAKE THIS
				;  MESSAGE VISABLE TO THE HOST
	JSP	P1,IRDIS	;GET NEXT PDP-11 WORD

;HERE AT THE START OF A NEW MESSAGE

IRSOM:	TRNN	T1,100000	;IS THIS A DATA MESSAGE?
	 JRST	IR12E		;NO-GO CHECK SOME MORE
	LDB	T2,[POINT 7,T1,27];YES-GET BYTE COUNT
	ADDI	T2,5		;CALCULATE NUMBER OF PDP-10 WORDS IN MESSAGE
	LSH	T2,-2
	MOVE	S,T2
	MOVE	T2,IRP620

;HERE TO PROCESS FIRST PDP-11 WORD FOR A PDP-10 WORD

IRDA:	MOVE	U,T2		;BUMP RING PUTTER POINTER
	ADDI	U,1
	ANDI	U,MSKIRG
	CAMN	U,IRPPDP	;IS THE INPUT RING FULL NOW?
	 JRST	IRFDP		;YES-GO HANDLE THAT
	DPB	T1,[POINT 16,IRING(T2),15];NO-STORE PDP-11 WORD IN RING
	JSP	P1,IRDIS	;GET SECOND PDP-11 WORD FOR THE PDP-10 WORD
IRDB:	DPB	T1,[POINT 16,IRING(T2),31];STORE PDP-11 WORD IN RING
	ADDI	T2,1		;BUMP POINTER
	ANDI	T2,MSKIRG
	SOJLE	S,IRPD
	MOVEI	P1,IRDA		;RESET INPUT STATE
IRDIS:	MOVEI	T1,KRFMD	;SET DR11 BIT INDICATING WE HAVE TAKEN INPUT
	BSIO	T1,@DRCSR
IRDIS1:	MOVSI	T1,100000	;RESTORE AC BLOCK
	ANDCA	T1,IROAC
	WRUBR	T1
	JEN	@IR		;DISMISS INTERRUPT

;HERE FOR OTHER THAN DATA MESSAGES

IR12E:	TRZE	T1,40000	;IS THIS A 1 WORD MESSAGE?
	 JRST	IR2OE		;NO-NEED TO CHECK SOME MORE
	MOVE	T2,IRP620	;YES-GET POINTER
	MOVE	U,T2
	ADDI	U,1		;BUMP IT
	ANDI	U,MSKIRG
	CAMN	U,IRPPDP	;IS THE RING FULL NOW?
	 JRST	IRF1WD		;YES
	DPB	T1,[POINT 16,IRING(T2),15];NO-STORE FIRST PDP-11 WORD
	JSP	P1,IRDIS	;GET 2ND PDP-11 WORD FOR MESSAGE
IR1B:	DPB	T1,[POINT 16,IRING(T2),31];STORE 2ND WORD
	ADDI	T2,1		;BUMP POINTER
	ANDI	T2,MSKIRG
	MOVEM	T2,IRP620	;UPDATE POINTER IN MEMORY (THIS MAKES THE
				;  MESSAGE VISABLE TO TYMCOM-X)
	MOVEI	P1,IRSOM	;RESET INPUT STATE
	JRST	IRDIS		;AND GO GET NEXT INPUT

;HERE IF NOT 1 WORD MESSAGE

IR2OE:	LDB	T2,[POINT 6,T1,27];IS THIS AN ESCAPE?
	CAIN	T2,77
	 JRST	IRESC		;YES
	MOVE	T2,IRP620	;NO-ITS A 2 WORD MESSAGE-GET POINTER
	MOVEI	S,2		;2 PDP-10 WORDS IN THIS MESSAGE
IR2A:	MOVE	U,T2		;IS THE INPUT RING FULL NOW?
	ADDI	U,1
	ANDI	U,MSKIRG
	CAMN	U,IRPPDP
	 JRST	IRF2WD		;YES
	DPB	T1,[POINT 16,IRING(T2),15];NO-STORE DATA IN RING
	JSP	P1,IRDIS	;GET NEXT PDP-11 WORD
IR2B:	DPB	T1,[POINT 16,IRING(T2),31];STORE IT IN THE RING TOO
	ADDI	T2,1		;BUMP RING POINTER
	ANDI	T2,MSKIRG
	SOJLE	S,IRPD		;NEED MORE INPUT FOR THIS MESSAGE?
	MOVEI	P1,IR2A		;NO-RESET STATE
	JRST	IRDIS		;AND GO GET NEXT MESSAGE

;HERE FOR ESCAPE (SPECIAL MESSAGE FOR INTERRUPT SERVICE)
;  THIS MESSAGE IS USED TO INDICATE THE START OF BLOCK MODE INPUT OR TO
;  REQUEST BLOCK MODE OUTPUT.  IT CONSISTS OF AN "ESCAPE" BYTE (= 177)
;  FOLLOWED BY 5 DATA BYTE.  THE FIRST TWO DATA BYTES CONTAIN THE PDP-11 WORD
;  COUNT.  THE NEXT 3 BYTES CONTAIN THE PDP-10 MEMORY ADDRESS FOR THE XFER.
;  THE COUNT IS NEGATIVE FOR INPUT XFERS, AND POSITIVE FOR OUTPUT XFERS.
;  A ZERO COUNT IS ILLEGAL!

IRESC:	MOVE	T2,T1		;SAVE INITIAL INPUT WORD (WHICH CONTAINS THE
				;  HIGH ORDER HALF OF THE COUNT)
	JSP	P1,IRDIS	;GET NEXT INPUT
	MOVE	P2,T1		;SAVE HIGH ORDER 8 BITS OF ADDRESS
	ANDI	T2,377		;GET PDP-11 WORD COUNT IN T2
	LSH	T2,8
	LSH	T1,-8
	TRO	T2,(T1)
	JSP	P1,IRDIS	;GET NEXT INPUT (LOW ORDER 16 BITS OF ADDRESS)
	ANDI	P2,377		;COMBINE LOW AND HIGH ADDRESS PARTS
	LSH	P2,8+8
	TRO	P2,(T1)
	HRLI	P2,442000	;MAKE INTO BYTE POINTER TO THE DATA
	TRNN	T2,100000	;INPUT XFER?
	 JRST	IRBMO		;NO-OUTPUT
	TRC	T2,177777	;YES-MAKE THE COUNT POSITIVE
	MOVEI	W,1(T2)		;AND GET IT IN THE RIGHT AC
	MOVE	M,P2		;GET BYTE POINTER IN A SAFE AC (??)
	JSP	P1,IRDIS	;GET FIRST BLOCK MODE DATA WORD

;HERE WITH NEXT BLOCK MODE INPUT DATA (NOTE THAT WE LOOP HERE BY JRST'ING TO
;  IRDIS FOR ADDITIONAL WORDS SO AS NOT TO CHANGE THE STATE)

	IDPB	T1,M		;STORE BLOCK MODE INPUT DATA
	SOJG	W,IRDIS		;LOOP IF WE NEED MORE
IRBMI2:	MOVEI	P1,IRSOM	;FINISHED-RESET INPUT STATE
	JRST	IRDIS		;AND GO GET NEXT INPUT

;HERE IF BLOCK COUNT IS POSITIVE - THIS IS A REQUEST TO START BLOCK MODE OUTPUT

IRBMO:	SKIPN	T2		;MAKE SURE NOT ZERO!
	 STOPCD
	MOVEM	T2,BLXCNT	;STORE COUNT
	MOVEM	T2,BLKSIZ	;ALSO SAVE IT FOR DEBUGGING!
	MOVEM	P2,BLXPNT	;STORE BYTE POINTER FOR BLOCK MODE OUTPUT
	SETOM	SBMO		;REQUEST BLOCK MODE OUTPUT
	MOVEI	P1,IRSOM	;RESET INPUT STATE
	JRST	IRDIS		;AND CONTINUE

;HERE WHEN THE BASE-HOST RING IS FULL.  SAVE THE DATA AND POINTER AWAY AND
;  DISMISS THE INTERRUPT - INPUT WILL BE STARTED AGAIN AT CLK LEVEL WHEN SOME
;  SPACE IS AVAILABLE IN THE RING AGAIN.

;ENTER HERE IF FULL RING IS DETECTED WHEN PROCESSING 2 WORD MESSAGE

IRF2WD:	MOVEI	P1,IR2B		;SET NEW STATE
	JRST	IRFUL		;CONTINUE

;ENTER HERE IF FULL RING IS DETECTED WHEN PROCESSING 1 WORD MESSAGE

IRF1WD:	SKIPA	P1,[IR1B]	;SET NEW STATE

;ENTER HERE IF FULL RING IS DETECTED WHEN PROCESSING DATA MESSAGE

IRFDP:	MOVEI	P1,IRDB		;SET NEW STATE
IRFUL:	DMOVEM	T1,IROVF	;STORE DATA AND POINTER
	SETOM	IRFULL		;SET FLAG TO TELL CLK ROUTINE THAT THE INPUT
				;  RING IS FULL
	JRST	IRDIAND JUST DISMISS THE INTERRUPT FOR NOW

	PAGE
	SUBTTL Node ready for data interrupt

;HERE ON "OUTPUT DONE" INTERRUPT FROM DR11C

OD:	0			;JSR TO HERE ON OUTPUT DONE INTERRUPT
	RDUBR	ODOAC		;SAVE CURRENT AC BLOCK NUMBER
	WRUBR	SDRACB		;SETUP OUR AC BLOCK
	MOVEI	U,DRFN		;CLEAR BIT IN DR11C STATUS WORD
	BCIO	U,@DRCSR
	JRST	(P3)		;DISPATCH ON CURRENT STATE

;HERE ON OUTPUT DONE INTERRUPT DISPATCH AFTER OUTPUTTING NORMAL DATA (NOT
;  BLOCK MODE DATA)

ODLH:	SKIPE	SBMO		;DO WE NEED TO START BLOCK MODE NOW?
	 JRST	ODBMO		;YES-GO DO THAT
	MOVE	T3,ORP620	;NO-GET OUTPUT TAKER POINTER
	CAMN	T3,ORPPDP	;ARE PUTTER AND TAKER EQUAL?
	 JRST	ODIDL		;YES-RING IS EMPTY-WE HAVE NOTHING TO DO NOW
	LDB	T4,[POINT 16,ORING(T3),15];NO-GET DATA FROM THE RING
	JSP	P3,ODDIS	;OUTPUT DATA AND CHANGE STATE

;HERE FROM OUTPUT DONE INTERRUPT DISPATCH TO OUTPUT 2ND 16 BIT BYTE FROM THE
;  WORD IN THE OUTPUT RING

ODLH0:	CAIE	T4,ESCWD	;WAS THE PREVIOUS DATA OUTPUT = ESCAPE?
	 JRST	ODLH1		;NO
	SETZ	T4,		;YES-FOLLOW IT WITH 0
	JSP	P3,ODDIS	;OUTPUT DATA AND CHANGE STATE
ODLH1:	LDB	T4,[POINT 16,ORING(T3),31];GET 2ND 16 BIT BYTE IN THE WORD
	AOJ	T3,		;BUMP RING POINTER
	ANDI	T3,MSKORG	;MOD THE SIZE OF THE RING
	MOVEM	T3,ORP620	;UPDATE RING POINTER IN MEMORY
	CAIE	T4,ESCWD	;IS THIS EQUAL TO ESCAPE?
	 JRST	ODRH1		;NO
	JSP	P3,ODDIS	;YES-OUTPUT IT AND CHANGE STATE
	SETZ	T4,		;FOLLOW THE ESCAPE WITH 0
ODRH1:	MOVEI	P3,ODLH		;CHANGE STATE TO START OVER NEXT TIME
ODDIS:	WRIO	T4,@DROB	;OUTPUT THE DATA
	JSR	OUTBUG		;FOR DEBUGGING!
	MOVEI	U,DRFN		;SET STATUS BIT TO MAKE IT VISIBLE TO THE NODE
	BSIO	U,@DRCSR
	SETOM	EDRODI		;INDICATE EXPECTING OUTPUT DONE INTERRUPT NOW
ODIDL1:	MOVEM	P3,OSTATE	;SAVE OUTPUT STATE FOR DEBUGGING
	MOVSI	U,100000	;RESTORE AC BLOCK
	ANDCA	U,ODOAC
	WRUBR	U
	JEN	@OD		;DISMISS INTERRUPT

;HERE WHEN HAVE NOTHING MORE TO OUTPUT

ODIDL:	SETZM	EDRODI		;INDICATE IDLE
	JRST	ODIDL1		;GO DISMISS

;HERE TO START BLOCK MODE OUTPUT

ODBMO:	SETZM	SBMO		;CLEAR BLOCK MODE REQUEST WORD
	MOVE	T4,BLXCNT	;SETUP THE COUNT
	MOVEM	T4,BLKCNT
	MOVE	T4,BLXPNT	;AND THE POINTER
	MOVEM	T4,BLKPNT
	MOVEI	T4,ESCWD	;OUTPUT AN ESCAPE FIRST
	JSP	P3,ODDIS

;HERE ON OUTPUT DONE INTERRUPT AFTER ESCAPE HAS BEEN OUTPUT TO START BLOCK
;  MODE OUTPUT - THIS STATE IS SET ABOVE (BY JSP P3,ODDIS) AND IN THE CLK
;  ROUTINE WHICH STARTS OUTPUT WHEN IT IS IDLE

ODBMO0:	MOVEI	T4,1		;FOLLOW THE ESCAPE BY 1
	JSP	P3,ODDIS

;HERE TO OUTPUT DATA WORD FOR BLOCK MODE - THIS STATE IS INITIALLY SET BY THE
;  JSP P3,ODDIS ABOVE IS LEFT UNCHANGED TO CAUSE US TO LOOP HERE UNTIL THE
;  ENTIRE BLOCK HAS BEEN OUTPUT

	ILDB	T4,BLKPNT	;GET 16 BITS OF BLOCK MODE DATA
	SOSL	BLKCNT		;REDUCE COUNT AND TEST
	 JRST	ODDIS		;CONTINUE IF MORE TO OUTPUT
	MOVEI	P3,ODLH		;FINISHED WITH BLOCK MODE DATA-RESET STATE
	JRST	ODLH		;CONTINUE

	PAGE
	SUBTTL Clock interrupt (every 17ms)
CLKDR::	SKIPA
	 0
	SKIPE	EDRODI		;Expecting output done interrupt?
	 JRST	CLKIR		;Yes, check for input unblocking.
	SKIPN	SBMO		;No, start block mode output?
	 JRST	CLKOR		;No, check output ring.
	SETZM	SBMO		;YES-CLEAR REQUEST
	RDUBR	CLKOAC		;SWITCH AC BLOCKS
	WRUBR	SDRACB
	MOVEI	P3,ODBMO0	;INITIALIZE OUTPUT STATE
	MOVE	T4,BLXCNT	;SETUP THE COUNT
	MOVEM	T4,BLKCNT
	MOVE	T4,BLXPNT	;AND THE POINTER
	MOVEM	T4,BLKPNT
	MOVEI	T4,ESCWD	;OUTPUT AN ESCAPE
	WRIO	T4,@DROB
	JSR	OUTBUG		;FOR DEBUGGING!
	SETOM	EDRODI		;INDICATE BLOCK OUTPUT ACTIVE
	MOVSI	T4,100000
	ANDCAM	T4,CLKOAC
	MOVEI	T4,DRFN		;TELL THE NODE WE HAVE DONE OUTPUT
	BSIO	T4,@DRCSR
	WRUBR	CLKOAC		;RESTORE AC BLOCK
	JRST	CLKIR		;GO CHECK INPUT STUFF

;HERE TO SEE IF NEED TO START OUTPUT FROM THE RING

CLKOR:	MOVEM	T1,CLKT1	;Host-base ring empty?
	MOVE	T1,ORP620
	CAME	T1,ORPPDP
	 JRST	CLKSO		;No, start output.
	MOVE	T1,CLKT1	;YES-RESTORE T1
	JRST	CLKIR		;AND CONTINUE

;HERE IS HAVE SOMETHING IN THE OUTPUT RING

CLKSO:	MOVE	T1,CLKT1	;RESTORE T1
	RDUBR	CLKOAC		;SWITCH AC BLOCKS
	WRUBR	SDRACB
	MOVSI	T3,100000	;???
	ANDCAM	T3,CLKOAC	;???
	MOVE	T3,ORP620	;GET RING POINTER
	LDB	T4,[POINT 16,ORING(T3),15];GET DATA FROM RING
	MOVEI	P3,ODLH0	;RESET OUTPUT STATE
	WRIO	T4,@DROB	;SEND DATA TO THE DR11
	JSR	OUTBUG		;FOR DEBUGGING!
	SETOM	EDRODI		;INDICATE EXPECTING INTERRUPT NOW
	WRPI	LI.PIF		;Out of acs!  Prevent IR from smashing.
	MOVEI	U,DRFN
	BSIO	U,@DRCSR	;SET DR11 STATUS BIT TO MAKE OUTPUT VISIBLE
	WRPI	LI.PIN
	WRUBR	CLKOAC

;HERE TO SEE IF NEED TO RESTART STOPPED INPUT

CLKIR:	SKIPN	IRFULL		;Input stopped?
	 JRST	CLKDR+1		;No.
	MOVEM	T2,CLKT2	;YES-SAVE T2
	MOVE	T2,IROVF+1	;GET SAVED RING POINTER
	ADDI	T2,1		;PLUS ONE
	ANDI	T2,MSKIRG	;MOD THE RING SIZE
	CAME	T2,IRPPDP	;Still full?
	 JRST	CLKIN		;No, resume input.
	MOVE	T2,CLKT2	;YES-RESTORE T2
	JRST	CLKDR+1		;AND CONTINUE

;HERE WHEN CAN RESUME INPUT WHICH WAS STOPPED BECAUSE THE INPUT RING WAS FULL

CLKIN:	MOVEM	T1,CLKT1	;SAVE T1
	DMOVE	T1,IROVF	;GET NEXT PDP-11 WORD FOR RING AND RING POINTER
	DPB	T1,[POINT 16,IRING(T2),15];STORE IT IN THE RING
	SETZM	IRFULL		;INDICATE INPUT NOT STOPPED NOW
	MOVEI	T1,KRFMD	;SET DR11 BIT TO ACCEPT LAST INPUT WORD
	BSIO	T1,@DRCSR
	DMOVE	T1,CLKT1	;RESTORE T1 AND T2 (T2 SAVED ABOVE!)
	JRST	CLKDR+1		;CONTINUE

	PAGE
;DEBUG ROUTINES!!!!!!

;SUBROUTINE TO STORE WORD IN OUTPUT DEBUG RING

OUTBUG:	0			;JSR TO HERE TO SAVE ON REGISTERS!
	IBP	DBOPNT		;BUMP POINTER
	HRRZ	PG,DBOPNT	;CHECK FOR WARP-AROUND
	CAIGE	PG,DBORGE
	JRST	OUTB02
	MOVEI	PG,DBORNG
	HRRM	PG,DBOPNT
OUTB02:	DPB	T4,DBOPNT	;STORE DATA IN DEBUG RING
	JRST	@OUTBUG		;RETURN

;THE DEBUG RING FOR OUTPUT

DBOPNT:	0
DBORNG:	BLOCK	^D500
DBORGE:

	PAGE
;This routine assumes the priority interrupt system is off.
DRINI::	SKIPN DRDO##
	 POPJ P,
	MOVE	T1,[POINT 18,DBORNG];INITIALIZE DEBUG OUTPUT RING POINTER
	MOVEM	T1,DBOPNT
	MOVSI T1,(<JFCL>)
	MOVEM T1,KEYSET
	MOVE T2,EPT+103
	MOVE T1,[JSR IR]
	MOVEM T1,IRV(T2)
	MOVE T1,[JSR OD]
	MOVEM T1,ODV(T2)
	MOVE T1,[JRST CLKDR]
	EXCH T1,CH7+1
	MOVEM T1,CLKDR+1
	SETZM SBMO
	SETZM EDRODI		;Output not active.
	SETZM IRFULL		;Input not blocked.
	RDUBR WRIOAC
	WRUBR SDRACB
	MOVEI P1,IRSOM
	MOVEI P3,ODIDL1
	MOVSI T1,100000
	ANDCA T1,WRIOAC
	WRUBR T1
	MOVEI T1,CSRIEA+CSRIEB
	WRIO T1,@DRCSR
	POPJ P,

END
    P*r3>