	TITLE	KMC	ROUTINES TO ACCESS KMC11 FOR DEBUGGING
	SUBTTL	NEXILIS/JRG
;DEFINE AC'S

P=1
A=2
B=3
C=4
D=5
E=6
ADR=10		;KMC11 DEVICE ADDRESS
T1=11
T2=12
T3=13

;DEFINE KS10 IOT INSTRUCTIONS

	OPDEF	TIOE  [710B8]
	OPDEF	TIOEB [720B8]
	OPDEF	TION  [711B8]
	OPDEF	TIONB [721B8]
	OPDEF	RDIO  [712B8]
	OPDEF	RDIOB [722B8]
	OPDEF	WRIO  [713B8]
	OPDEF	WRIOB [723B8]
	OPDEF	BSIO  [714B8]
	OPDEF	BSIOB [724B8]
	OPDEF	BCIO  [715B8]
	OPDEF	BCIOB [725B8]
	OPDEF	RDAPR [70024B14]
	OPDEF	WRAPR [70020B14]

;DEFINE SOME KMC11 MICRO INSTRUCTIONS

BTOUT= 061220		;MOVE BREG,OUT1 <CSR0>
MEMOUT=041220		;MOVE MEM,OUT1 <CSR0>
OUTOB= 120400		;MOVE INP1 <CSR0>,BREG
SPTOB= 060600		;MOVE SPAD <0>,BREG
MPJUMP=100400		;UNCONDITIONAL JUMP
MPJMPZ=101400		;JUMP IF Z IS SET
MPNOP= 000000		;NOP (MOVE # 0,NOP)
INPOUS=021000		;MOVE INBUS TO OUTBUS*
INSOUS=121000		;MOVE INBUS* TO OUTBUS*
INSOUT=122000		;MOVE INBUS* TO OUTBUS
LITOUS=001000		;MOVE LITERAL TO OUTBUS*
IN1TOM=122400		;MOVE INP1 <0>,MEM
MARINC=014000		;MAR INCREMENT
MARLOD=010000		;MAR LOAD (LOW 8 BITS)
MARLDX=004000		;MAR LOAD (HIGH 2 BITS)
LITBRG=000400		;MOVE LITERAL TO BREG
BRGSP0=063220		;MOVE BREG TO SP0
BRGOUS=061220		;MOVE BREG TO OUTBUS*
SP0OUS=061200		;MOVE SP0 TO OUTBUS*
CLRSP0=003000		;CLEAR SP0
S0COUS=061100		;MOVE SP0 + C TO OUTBUS*
INSSP0=123000		;MOVE INBUS* TO SP0
SPDXXX=060120		;MOVE SP0 + SP0 TO NOWHERE
TSTINS=120000		;TEST INBUS*

;DEFINE CSR1 BITS

MPRUN= 100000		;RUN
MPINI= 040000		;INIT
MPCWRT=020000		;CRAM WRITE
MPCRAM=002000		;CRAM INPUT/OUTPUT THROUGH CSR6
MPXCT= 001000		;EXECUTE MICRO INSTRUCTION FROM CSR6
MPSTEP=000400		;SINGLE STEP

;DEFINE WORDS AND BITS FOR THE KS10 CTY INTERFACE

CTYIWD==32		;INPUT FROM CTY WORD
  CTYICH==377B35	;CTY INPUT CHARACTER
  CTYIVL==1B27		;INPUT VALID FLAG

CTYOWD==33		;OUTPUT TO CTY WORD
  CTYOCH==377B35	;CTY OUTPUT CHARACTER
  CTYOVL==1B27		;OUTPUT VALID FLAG

	PAGE
;THIS ENTIRE PROGRAM IS A SUBROUTINE WHICH IS ENTERED FROM DDT BY
;	PUSHJ P,KMC$X

KMC::	MOVEM	17,SAVEAC+17	;SAVE ALL MONITOR AC'S
	MOVEI	17,SAVEAC
	BLT	17,SAVEAC+16
	MOVE	P,[IOWD 20,STACK];SETUP OUR STACK
	MOVE	ADR,[3,,760540]	;POINT TO THE KMC
	SETZ	T2,		;STOP THE KMC
	RDIOB	T1,1(ADR)	;SAVE CURRENT CSR1
	WRIOB	T2,1(ADR)
	MOVEM	T1,CSR+1
	PUSHJ	P,SAVKMC	;SAVE THE KMC'S STATE
	MOVEI	A,[ASCIZ "
*** KMC DEBUG ROUTINES ***

"]
	PUSHJ	P,OUTSTR
LOOP:	MOVEI	C,"%"		;TYPE A PROMPT
	PUSHJ	P,OUTCHR
	PUSHJ	P,GETOCT	;GET A NUMBER FROM HIM
	CAIN	C,15
	JRST	LOOP
	CAIN	C,"/"		;CRAM?
	JRST	CRAM		;YES
	CAIN	C,"["		;DATA?
	JRST	DATA		;YES
	CAIN	C,"\"		;CSR?
	JRST	GCSR		;YES
	CAIN	C,"!"		;SCRATCH PAD?
	JRST	SPAD		;YES
	CAIN	C,"P"		;MICRO-PC?
	JRST	DSPPC		;YES
	CAIN	C,"C"		;C BIT?
	JRST	DSPCBT		;YES
	CAIN	C,"Z"		;Z BIT?
	JRST	DSPZBT		;YES
	CAIN	C,"M"		;MAR?
	JRST	DSPMAR		;YES
	CAIN	C,"B"		;BRG?
	JRST	DSPBRG		;YES
	CAIN	C,"S"		;DOES HE WANT TO SINGLE STEP THE KMC
	JRST	SNGSTP		;YES
	CAIN	C,"R"		;DOES HE WANT TO RUN THE KMC FOR A WHILE?
	JRST	RUNKMC		;YES
	CAIN	C,"X"		;DOES HE WANT TO LEAVE?
	JRST	GOAWAY		;YES
UNKTRM:	MOVEI	A,[ASCIZ "
? UNKNOWN TERMINATOR
"]
ERROR:	PUSHJ	P,OUTSTR	;TYPE THE ERROR MESSAGE
	JRST	LOOP		;CONTINUE

	PAGE
;HERE TO GO BACK TO DDT

GOAWAY:	MOVEI	A,[ASCIZ "
RETURNING TO DDT

"]
	PUSHJ	P,OUTSTR
	PUSHJ	P,RSTKMC	;RESTORE KMC STATE
	MOVE	T1,CSR+1	;START THE KMC IF IT WAS RUNNING
	ANDI	T1,200
	WRIOB	T1,1(ADR)
	MOVSI	17,SAVEAC	;RESTORE AC'S
	BLT	17,17
	POPJ	P,		;AND LEAVE

	PAGE
;HERE TO CHANGE CONTENTS OF A CRAM LOCATION

CRAM:	LSH	A,-1		;FIX IT UP
CRAM1:	ANDI	A,1777		;JUST 10 BITS
	MOVEM	A,CADDR		;SAVE CRAM ADDRESS
	MOVEI	T1,MPCRAM	;SET CRAM IN CSR1
	BSIO	T1,0(ADR)
	WRIO	A,4(ADR)	;STORE CRAM ADDRESS IN CSR4
	PUSHJ	P,TAB		;TYPE A TAB
	RDIO	A,6(ADR)	;GET CRAM CONTENTS
	PUSHJ	P,OUTWRD	;TYPE IT
	PUSHJ	P,TAB		;AND A TAB
	PUSHJ	P,GETOCT	;GET HIS INPUT
	JUMPE	B,CRAM2		;DON'T CHANGE IT IF NO NEW VALUE GIVEN
	WRIO	A,6(ADR)	;STORE NEW CONTENTS IN CSR6
	MOVEI	T1,MPCWRT	;GET CRAM WRITE BIT
	BSIO	T1,0(ADR)	;DO IT
	SETZ	T1,
	WRIO	T1,0(ADR)
CRAM2:	CAIN	C,15		;DOES HE WANT MORE?
	JRST	LOOP		;NO
	CAIE	C,12		;MAYBE
	JRST	UNKTRM		;ERROR!
	AOS	A,CADDR		;YES-GET NEXT ADDRESS
	ANDI	A,1777
	LSH	A,1		;FIX IT UP
	PUSHJ	P,OUTWRD	;TYPE IT
	MOVEI	C,"/"
	PUSHJ	P,OUTCHR
	MOVE	A,CADDR
	JRST	CRAM1		;CONTINUE

	PAGE
;HERE TO CHANGE CONTENTS OF A DATA LOCATION

DATA:	ANDI	A,1777		;JUST 10 BITS
	MOVEM	A,DADDR		;REMEMBER ADDRESS FOR LATER
	PUSHJ	P,TAB		;TYPE A TAB
	PUSHJ	P,SETMAR	;SET THE MAR
	MOVEI	A,MEMOUT	;GET LAST INSTRUCTION WE NEED
	PUSHJ	P,MPEX		;DO IT
	RDIOB	A,0(ADR)	;GET THE DATA
	PUSHJ	P,OUTBYT	;TYPE IT
	PUSHJ	P,TAB
	PUSHJ	P,GETOCT	;GET HIS NEXT INPUT
	JUMPE	B,DATA2		;DO NOTHING IF NOTHING TYPED
	WRIOB	A,0(ADR)	;PUT NEW VALUE IN KMC CSR0
	MOVEI	A,IN1TOM	;GET MICRO INSTRUCTION
	PUSHJ	P,MPEX		;EXECUTE IT
DATA2:	CAIN	C,15		;CARRIAGE RETURN?
	JRST	LOOP		;YES
	CAIE	C,12		;LINE FEED?
	JRST	UNKTRM		;NO-ERROR
	AOS	A,DADDR		;YES-BUMP AND FETCH ADDRESS
	ANDI	A,1777
	PUSHJ	P,OUTWRD	;TYPE IT
	MOVEI	C,"["
	PUSHJ	P,OUTCHR
	MOVE	A,DADDR		;GET ADDRESS AGAIN
	JRST	DATA		;CONTINUE

	PAGE
;HERE TO CHANGE CONTENTS OF A SCRATCH PAD LOCATION
;  INORDER TO READ A SCRATCH PAD REGISTER, WE MUST FIRST SAVE THE CURRENT
;  VALUE OF THE BRG AND THEN COPY THE DESIRED SCRATCH PAD REGISTER TO THE BRG
;  (THERE IS NO WAY TO COPY A SCRATCH PAD REGISTER DIRECTLY TO A CSR!).  WE
;  THEN COPY THE BRG TO CSR0 SO WE CAN GET THE VALUE.  FINALLY, WE RESTORE THE
;  ORIGINAL VALUE TO THE BRG!!

SPAD:	ANDI	A,17		;JUST 4 BITS
	MOVEM	A,SPADDR	;SAVE ADDRESS
	PUSHJ	P,TAB
	MOVEI	A,BTOUT		;MOVE BREG TO CSR0
	PUSHJ	P,MPEX
	RDIOB	T3,0(ADR)	;GET BRG CONTENTS
	MOVE	A,SPADDR	;GET SCRATCH PAD ADDRESS
	IORI	A,SPTOB		;MAKE INTO MICRO INSTRUCTION
	PUSHJ	P,MPEX		;DO IT (COPIES SCRATCH PAD TO BRG)
	MOVEI	A,BTOUT		;NOW COPY BRG TO CSR0
	PUSHJ	P,MPEX
	RDIOB	A,0(ADR)
	PUSHJ	P,OUTBYT	;OUTPUT THE VALUE
	PUSHJ	P,TAB		;AND A TAB
	PUSHJ	P,GETOCT	;GET A POSSIBLE NEW VALUE
	JUMPE	B,SPAD2		;GO ON IF NO NEW VALUE
	ANDI	A,377		;MAKE SURE ONLY 8 BITS
	IORI	A,LITBRG	;MAKE INTO IMMEDIATE INSTRUCTION
	PUSHJ	P,MPEX		;DO IT (LOADS VALUE INTO BRG)
	MOVE	A,SPADDR	;GET SCRATCH PAD ADDRESS
	IORI	A,BRGSP0	;MAKE INTO INSTRUCTION
	PUSHJ	P,MPEX		;DO IT (COPIES BRG INTO SCRATCH PAD REG)
SPAD2:	WRIOB	T3,0(ADR)	;RESTORE BRG
	MOVEI	A,OUTOB
	PUSHJ	P,MPEX
	CAIN	C,15		;CR?
	JRST	LOOP		;YES
	CAIE	C,12		;LF?
	JRST	UNKTRM		;NO-ERROR
	AOS	A,SPADDR	;YES-GET NEXT ADDRESS
	ANDI	A,17
	PUSHJ	P,OUTBYT	;OUTPUT IT
	MOVEI	C,"!"
	PUSHJ	P,OUTCHR
	MOVE	A,SPADDR	;GET ADDRESS AGAIN
	JRST	SPAD		;CONTINUE

	PAGE
;HERE TO CHANGE CONTENTS OF A KMC CSR
;  WE USE THE TERM CSR IN A SOMEWHAT EXTENDED SENSE.  OUR CSR NUMBERS
;  CORRESPOND TO THE KMC REGISTERS AS FOLLOWS:
;	CSR0 -CSR7  = OUTBUS*/INBUS* REGISTERS 0-7 (THESE ARE THE
;			ACTUAL UNIBUS CSR'S)
;	CSR10-CSR17 = OUTBUS/INBUS REGISTERS 0-7
;	CSR20       = OUTBUS*/INBUS* REGISTER 10 (NPR CONT)
;	CSR21       = OUTBUS*/INBUS* REGISTER 11 (UP MISC)

GCSR:	CAILE	A,21		;VALID CSR ADDRESS?
	JRST	BADADR		;NO-COMPLAIN!
	MOVEM	A,CSADDR	;REMEMBER THE ADDRESS
	PUSHJ	P,TAB		;OUTPUT A TAB
	CAIL	A,10		;IS THIS A SIMPLE ONE?
	JRST	GCSR1		;NO
	MOVE	A,CSR(A)	;YES-GET CSR CONTENTS
	JRST	GCSR4		;AND CONTINUE

;HERE FOR NON-CSR CSR REGISTER

GCSR1:	CAIGE	A,20		;IS IT A HIGH * REGISTER?
	JRST	GCSR2		;NO
	ANDI	A,1		;YES-JUST 1 BIT!
	LSH	A,4		;GET IT IN THE RIGHT PLACE
	IORI	A,INSOUS+200	;MAKE INTO MICRO INSTRUCTION
	JRST	GCSR3		;CONTINUE

GCSR2:	ANDI	A,7		;JUST 3 BITS
	LSH	A,4
	IORI	A,INPOUS	;MAKE INTO MICRO INSTRUCTION
GCSR3:	PUSHJ	P,MPEX		;DO IT (COPIES REGISTER WE WANT INTO CSR0)
	RDIOB	A,0(ADR)	;GET VALUE
GCSR4:	PUSHJ	P,OUTBYT	;OUTPUT IT
	PUSHJ	P,TAB		;AND ANOTHER TAB
	PUSHJ	P,GETOCT	;GET HIS INPUT
	JUMPE	B,GCSR8		;GO ON IF NOT CHANGING IT
	MOVE	T1,A		;COPY VALUE TO A SAFE PLACE
	MOVE	A,CSADDR	;GET ADDRESS
	CAIL	A,10		;IS THIS A SIMPLE ADDRESS?
	JRST	GCSR5		;NO
	MOVEM	T1,CSR(A)	;YES-STORE NEW VALUE
	JRST	GCSR8		;CONTINUE

GCSR5:	CAIGE	A,20		;WHICH SET?
	JRST	GCSR6		;???
	ANDI	A,1		;JUST 1 BIT
	IORI	A,INSOUS+10	;MAKE INTO MICRO INSTRUCTION
	JRST	GCSR7		;CONTINUE

GCSR6:	ANDI	A,7		;JUST 3 BITS
	IORI	A,INSOUT	;MAKE MICRO INSTRUCTION
GCSR7:	WRIOB	T1,0(ADR)	;PUT NEW VALUE IN CSR0
	PUSHJ	P,MPEX		;COPY IT TO THE RIGHT KMC REGISTER
GCSR8:	CAIN	C,15		;DOES HE WANT MORE?
	JRST	LOOP		;NO
	CAIE	C,12		;MAYBE
	JRST	UNKTRM		;IF ERROR
	AOS	A,CSADDR	;YES-GET NEXT ADDRESS
	CAILE	A,21		;AT END YET?
	SETZ	A,		;YES-START OVER
	MOVEM	A,CSADDR
	PUSHJ	P,OUTBYT	;OUTPUT IT
	MOVEI	C,"\"
	PUSHJ	P,OUTCHR
	MOVE	A,CSADDR
	JRST	GCSR

;HERE IF HE GAVE US A BAD ADDRESS

BADADR:	MOVEI	A,[ASCIZ "
? BAD ADDRESS
"]
	JRST	ERROR

	PAGE
;HERE TO DISPLAY AND CHANGE THE MAR

DSPMAR:	PUSHJ	P,TAB		;OUTPUT A TAB
	MOVE	A,MAR		;OUTPUT CURRENT MAR
	PUSHJ	P,OUTWRD
	PUSHJ	P,TAB
	PUSHJ	P,GETOCT	;GET NEW VALUE
	JUMPE	B,LOOP		;IS HE CHANGING IT?
	MOVEM	A,MAR		;YES-STORE NEW VALUE
	JRST	LOOP		;CONTINUE

	PAGE
;HERE TO DISPLAY AND CHANGE THE MICRO-PC

DSPPC:	PUSHJ	P,TAB		;OUTPUT A TAB
	MOVE	A,MPPC		;GET CURRENT MICRO-PC
	LSH	A,1		;FIX IT UP
	PUSHJ	P,OUTWRD	;O IT
	PUSHJ	P,TAB
	PUSHJ	P,GETOCT	;GET POSSIBLE NEW VALUE
	JUMPE	B,LOOP		;DID HE CHANGE IT?
	LSH	A,-1		;YES-FIX IT UP
	MOVEM	A,MPPC		;AND SAVE IT
	JRST	LOOP		;THATS ALL

	PAGE
;HERE TO DISPLAY AND CHANGE THE C BIT

DSPCBT:	PUSHJ	P,TAB		;OUTPUT A TAB
	MOVE	A,CFLAG		;GET CURRENT VALUE OF THE C BIT
	PUSHJ	P,ONOFF		;OUTPUT IT
	PUSHJ	P,TAB
	PUSHJ	P,GETOCT	;GET POSSIBLE NEW VALUE
	JUMPE	B,LOOP		;IF NO CHANGE
	MOVEM	A,CFLAG		;STORE NEW VALUE
	JRST	LOOP		;FINISHED

;HERE TO DISPLAY AND CHANGE THE Z BIT

DSPZBT:	PUSHJ	P,TAB		;OUTPUT A TAB
	MOVE	A,ZFLAG		;GET CURRENT VALUE OF THE Z BIT
	PUSHJ	P,ONOFF		;OUTPUT IT
	PUSHJ	P,TAB
	PUSHJ	P,GETOCT	;GET POSSIBLE NEW VALUE
	JUMPE	B,LOOP		;IF NO CHANGE
	MOVEM	A,ZFLAG		;STORE NEW VALUE
	JRST	LOOP		;FINISHED

	PAGE
;HERE TO DISPLAY AND CHANGE THE BRG

DSPBRG:	PUSHJ	P,TAB		;OUTPUT A TAB
	MOVEI	A,BRGOUS	;COPY BRG TO CSR0
	PUSHJ	P,MPEX
	RDIO	A,0(ADR)	;GET VALUE
	PUSHJ	P,OUTBYT	;OUTPUT IT
	PUSHJ	P,TAB
	PUSHJ	P,GETOCT
	JUMPE	B,LOOP		;FINISHED IF NOT CHANGING IT
	ANDI	A,377		;JUST 8 BITS
	IORI	A,LITBRG	;MAKE INTO MICRO INSTRUCTION
	PUSHJ	P,MPEX		;PUT NEW VALUE INTO THE BRG
	JRST	LOOP		;FINISHED NOW

	PAGE
;HERE TO SINGLE STEP THE KMC

SNGSTP:	MOVEM	A,COUNT	;SAVE COUNT
	PUSHJ	P,NEWLIN
SNGST2:	PUSHJ	P,RSTKMC	;RESTORE STATE OF KMC (ALMOST)
	MOVEI	A,MPSTEP/400	;GET SINGLE STEP BIT
	BSIOB	A,1(ADR)	;DO ONE REAL INSTRUCTION
	BCIOB	A,1(ADR)
SNGST4:	PUSHJ	P,SAVKMC	;SAVE THE STATE
	SOSLE	COUNT		;FINISHED?
	JRST	SNGST2		;NO-CONTINUE
	JRST	LOOP		;THATS ALL

	PAGE
;HERE TO RUN THE KMC FOR SOME NUMBER OF INSTRUCTIONS

RUNKMC:	MOVEM	A,COUNT		;SAVE COUNT
	PUSHJ	P,NEWLIN
	PUSHJ	P,RSTKMC	;RESTORE STATE OF KMC
	MOVEI	A,MPSTEP/400	;GET SINGLE STEP BIT
RUNKM2:	BSIOB	A,1(ADR)	;DO ONE REAL INSTRUCTION
	BCIOB	A,1(ADR)
	SOSLE	COUNT		;WANT MORE?
	JRST	RUNKM2		;YES-CONTINUE
	JRST	SNGST4		;NO-GO FINISH UP

	PAGE
;SUBROUTINE TO SAVE THE CURRENT STATE OF THE KMC
;	PUSHJ	P,SAVKMC

SAVKMC:	RDIOB	T1,0(ADR)	;SAVE THE KMC'S CSR'S
	MOVEM	T1,CSR+0
	RDIOB	T1,2(ADR)
	MOVEM	T1,CSR+2
	RDIOB	T1,3(ADR)
	MOVEM	T1,CSR+3
	RDIOB	T1,4(ADR)
	MOVEM	T1,CSR+4
	RDIOB	T1,5(ADR)
	MOVEM	T1,CSR+5
	RDIOB	T1,6(ADR)
	MOVEM	T1,CSR+6
	RDIOB	T1,7(ADR)
	MOVEM	T1,CSR+7

;THE FOLLOWING CODE IS ALL NEEDED JUST TO READ THE KMC'S MICRO-PC!  THERE IS
;  NO WAY TO DO THIS DIRECTLY, SO WE SAVE THE ENTIRE CONTENTS OF THE CRAM AND
;  LOAD THE ENTIRE CRAM, EXCEPT FOR LOCATION 0, WITH NO-OP'S.  WE
;  LOAD LOCATION 0 WITH AN INSTRUCTION TO SET CSR2 TO 2.  WE THEN CLEAR CSR2
;  AND SINGLE STEP THE KMC UNTIL CSR2 BECOMES NON-0!  BY COUNTING THE NUMBER
;  OF TIMES WE HAVE STEPPED THE KMC, WE HAVE THE VALUE OF THE MICRO-PC WHEN WE
;  STARTED!! (WE DIDN'T DESIGN THIS TURKEY!)

	MOVEI	B,MPCRAM	;SET BIT TO ADDRESS CRAM
	WRIO	B,0(ADR)
	MOVE	C,[POINT 18,SVCRAM];GET BYTE POINTER FOR SAVE AREA
	SETZ	A,		;START AT LOCATION 0
GETPC2:	WRIO	A,4(ADR)	;LOAD ADDRESS
	RDIO	T1,6(ADR)	;GET CONTENTS
	IDPB	T1,C		;SAVE IT
	CAIGE	A,2000		;DONE YET?
	AOJA	A,GETPC2	;NO-CONTINUE
	SETZ	A,		;START AT 0 AGAIN
	MOVEI	B,MPCWRT	;SET TO WRITE IN THE CRAM
GETPC4:	MOVEI	T1,1(A)		;CALCULATE INSTRUCTION FOR JUMP .+1
	LSH	T1,3
	ANDI	T1,14000
	IORI	T1,1(A)
	ANDI	T1,14377
	IORI	T1,MPJUMP	;ADD THE INSTRUCTION BITS
	PUSHJ	P,PUTCRM	;STORE IT IN THE CRAM
	CAIGE	A,1775		;DONE YET?
	JRST	GETPC4		;NO-CONTINUE
	MOVEI	T1,MPJMPZ+3*4000+377;INSTRUCTION TO JUMP TO 1777 IF Z IS SET
	PUSHJ	P,PUTCRM
	MOVEI	T1,LITOUS+2	;INSTRUCTION TO WRITE 2 TO CSR2 (REPORTS
	PUSHJ	P,PUTCRM	;  THAT Z WAS CLEAR)
	MOVEI	T1,LITOUS+202	;INSTRUCTION TO WRITE 202 TO CSR2 (REPORTS
	PUSHJ	P,PUTCRM	;  THAT Z WAS SET)
	SETZ	A,		;CLEAR SOME REGISTERS
	WRIO	A,0(ADR)
	WRIO	A,2(ADR)
	MOVEI	B,MPSTEP	;GET SINGLE STEP BIT
	MOVEI	A,1776		;GET INITIAL COUNT
GETPC6:	WRIO	B,0(ADR)	;DO ONE INSTRUCTION
	BCIO	B,0(ADR)
	RDIOB	T1,2(ADR)	;ARE WE AT LOCATION 0?
	JUMPN	T1,GETPC7	;YES
	SOJGE	A,GETPC6	;NO-CONTINUE
	MOVEI	A,[ASCIZ "
% CANNOT DETERMINE PC, C, OR Z!!
"]
	JRST	OUTSTR		;TELL HIM WE COULDN'T DO IT!

;HERE WHEN WE HAVE REACHED LOCATION 1776 OR 1777

GETPC7:	MOVEM	A,MPPC		;REMEMBER PC
	LSH	T1,-7		;GET Z VALUE IN LOW ORDER BIT
	MOVEM	T1,ZFLAG	;AND REMEMBER IT
	MOVEI	A,SP0OUS	;SAVE SP0 IN T3
	PUSHJ	P,MPEX
	RDIOB	T3,0(ADR)
	MOVEI	A,CLRSP0	;GET INSTRUCTIN TO CLEAR SP0
	PUSHJ	P,MPEX		;DO IT
	MOVEI	A,S0COUS	;GET INSTRUCTION TO ADD C TO SP0 AND STORE
	PUSHJ	P,MPEX		;  RESULT IN CSR0 AND DO IT
	RDIOB	T1,0(ADR)	;GET IT
	MOVEM	T1,CFLAG	;REMEMBER IT FOR LATER
	MOVEI	A,INSSP0	;RESTORE SP0 FROM T3
	WRIOB	T3,0(ADR)
	PUSHJ	P,MPEX
	MOVEI	B,MPCRAM	;SETUP TO RESTORE CRAM CONTENTS
	WRIO	B,0(ADR)
	MOVEI	B,MPCWRT
	MOVE	C,[POINT 18,SVCRAM];POINT TO SAVED DATA
	SETZ	T2,
GETPC8:	ILDB	T1,C		;GET CONTENTS
	WRIO	T1,6(ADR)	;STORE IT
	WRIO	T2,4(ADR)	;STORE ADDRESS
	BSIO	B,0(ADR)	;PUT IT IN THE CRAM
	BCIO	B,0(ADR)
	CAIGE	T2,1777		;DONE?
	AOJA	T2,GETPC8	;NO-CONTINUE
	PUSHJ	P,GETMAR	;GET THE MEMORY ADDRESS REGISTER
	MOVEM	T3,MAR		;AND SAVE IT
	MOVEI	A,[ASCIZ "PC = "];TELL HIM WHERE HE IS
	PUSHJ	P,OUTSTR
	MOVE	A,MPPC		;GET CURRENT MICRO-PC
	LSH	A,1		;FIX IT UP
	PUSHJ	P,OUTWRD
	MOVEI	A,[ASCIZ "  Z = "]
	PUSHJ	P,OUTSTR	;TELL HIM THE STATE OF THE Z FLAG
	MOVE	A,ZFLAG
	PUSHJ	P,ONOFF
	MOVEI	A,[ASCIZ "  C = "]
	PUSHJ	P,OUTSTR	;TELL HIM THE STATE OF THE C FLAG
	MOVE	A,CFLAG
	PUSHJ	P,ONOFF
	MOVEI	A,[ASCIZ "  M = "];TELL HIM ABOUT THE MAR
	PUSHJ	P,OUTSTR
	MOVE	A,MAR
	PUSHJ	P,OUTWRD
	JRST	NEWLIN		;FINISH THE LINE AND RETURN

	PAGE
;SUBROUTINE TO STORE INSTRUCTION INTO THE CRAM
;	C(T1) = INSTRUCTION TO STORE
;	C(A)  = CRAM ADDRESS
;	PUSHJ	P,PUTCRM

PUTCRM:	WRIO	T1,6(ADR)	;STORE INSTRUCTION
	WRIO	A,4(ADR)	;STORE ADDRESS
	BSIO	B,0(ADR)	;DO IT
	BCIO	B,0(ADR)
	AOJA	A,CPOPJ		;BUMP ADDRESS AND RETURN

	PAGE
;SUBROUTINE TO RESTORE THE STATE OF THE KMC
;	PUSHJ	P,RSTKMC

RSTKMC:	MOVE	A,MAR		;RESTORE MAR
	PUSHJ	P,SETMAR
	MOVEI	A,SP0OUS	;GET INSTRUCTION TO MOVE SP0 TO CSR0
	PUSHJ	P,MPEX		;DO IT
	RDIOB	T3,0(ADR)	;SAVE CONTENTS OF SP0
	MOVEI	A,INSSP0	;GET INSTRUCTION TO MOVE CSR0 TO SP0
	SETZ	T1,		;ASSUME C SHOULD BE CLEAR
	SKIPE	CFLAG		;RIGHT?
	MOVEI	T1,200		;NO-SET IT
	WRIOB	T1,0(ADR)	;STORE DATA
	PUSHJ	P,MPEX		;DO IT
	MOVEI	A,SPDXXX	;MOVE SP0 + SP0 TO NOWHERE
	PUSHJ	P,MPEX		;DO IT (WILL SET C IF CFLAG WAS NON-0)
	MOVEI	A,INSSP0	;GET INSTRUCTION TO RESTORE SP0
	WRIOB	T3,0(ADR)	;STORE VALUE
	PUSHJ	P,MPEX		;DO IT
	MOVEI	A,TSTINS	;GET INSTRUCTION TO TEST CSR0
	SETZ	T1,		;ASSUME Z SHOULD BE CLEAR
	SKIPE	ZFLAG		;RIGHT?
	MOVEI	T1,377		;NO-IT SHOULD BE SET
	WRIOB	T1,0(ADR)
	PUSHJ	P,MPEX		;DO IT (WILL SET Z IF ZFLAG WAS NON-0)
	MOVE	A,MPPC		;GET KMC PC
	MOVE	B,A		;SPLIT IT UP
	LSH	B,3
	ANDI	A,377
	ANDI	B,14000
	IOR	A,B		;PUT IT BACK TOGETHER!
	IORI	A,MPJUMP	;MAKE IT INTO A JUMP MICRO INSTRUCTION
	PUSHJ	P,MPEX		;DO IT
	MOVE	T1,CSR+0	;RESTORE THE KMC CSR'S
	WRIOB	T1,0(ADR)
	MOVE	T1,CSR+2
	WRIOB	T1,2(ADR)
	MOVE	T1,CSR+3
	WRIOB	T1,3(ADR)
	MOVE	T1,CSR+4
	WRIOB	T1,4(ADR)
	MOVE	T1,CSR+5
	WRIOB	T1,5(ADR)
	MOVE	T1,CSR+6
	WRIOB	T1,6(ADR)
	MOVE	T1,CSR+7
	WRIOB	T1,7(ADR)
	POPJ	P,		;FINISHED

	PAGE
;SUBROUTINE TO SET MAR
;	C(A) = NEW VALUE FOR MAR
;	PUSHJ	P,SETMAR

SETMAR:	PUSH	P,A		;SAVE ADDRESS
	ANDI	A,377		;GET OFFSET IN PAGE
	IORI	A,MARLOD	;MAKE INTO KMC INSTRUCTION
	PUSHJ	P,MPEX		;DO IT
	POP	P,A		;GET ADDRESS FOR LAST TIME
	LSH	A,-10		;GET PAGE NUMBER
	ANDI	A,3
	IORI	A,MARLDX	;MAKE INTO KMC INSTRUCTIN
				;FALL INTO MPEX

;SUBROUTINE TO EXECUTE KMC11 INSTRUCTION
;	C(A) = INSTRUCTIN TO EXECUTE
;	PUSHJ	P,MPEX

MPEX:	MOVEI	T1,MPXCT	;SET TO EXECUTE FROM CSR6
	BSIO	T1,0(ADR)
	WRIO	A,6(ADR)	;GIVE THE INSTRUCTION TO THE KMC
	MOVEI	T1,MPSTEP	;EXECUTE THE INSTRUCTION
	BSIO	T1,0(ADR)
	SETZ	T1,		;DISABLE THE DEVICE
	WRIOB	T1,1(ADR)
CPOPJ:	POPJ	P,		;THATS ALL

;SUBROUTINE TO GET CURRENT VALUE OF THE MAR
;	PUSHJ	P,GETMAR
;	C(T3) = CURRENT MAR
;  WARNING - DESTROYS KMC MAR!!!

GETMAR:	MOVEI	T3,2000		;GET VALUE
GETMA2:	SOJLE	T3,CPOPJ	;DECREMENT, BE SAFE!
	MOVEI	A,MARINC	;INCREMENT THE MAR
	PUSHJ	P,MPEX
	MOVEI	A,INSOUS+200	;GET THE MAR OVERFLOW FLAG
	PUSHJ	P,MPEX
	RDIOB	A,0(ADR)
	TRNN	A,100		;IS IT SET?
	JRST	GETMA2		;NO-CONTINUE
	POPJ	P,		;YES-FINISHED

	PAGE
	SUBTTL	SUBROUTINES

;SUBROUTINE TO OUTPUT A HORIZONTAL TAB
;	PUSHJ	P,TAB

TAB:	MOVEI	C,40		;JUST TYPE 3 SPACES AND CALL IT A TAB!
	PUSHJ	P,OUTCHR
	PUSHJ	P,OUTCHR
				;FALL INTO OUTCHR

;SUBROUTINE TO OUTPUT SINGLE CHARACTER TO THE CTY
;	C(C) = CHARACTER TO OUTPUT
;	PUSHJ	P,OUTCHR

OUTCHR:	MOVEI	D,CTYOVL	;IS IT READY FOR OUTPUT?
	MOVEI	E,400000
OUTCH2:	TDNE	D,CTYOWD
	SOJG	E,OUTCH2	;NO-WAIT UNTIL IT IS
	MOVEM	C,CTYOWD	;YES-STORE CHARACTER
	IORM	D,CTYOWD	;MAKE IT VISIBLE
	RDAPR	D		;GET CURRENT APR PI LEVEL
	ANDI	D,7
	WRAPR	12000(D)	;POKE THE 8080
	POPJ	P,		;THATS ALL

;SUBROUTINE TO OUTPUT CR-LF
;	PUSHJ	P,NEWLIN

NEWLIN:	MOVEI	A,[ASCIZ "
"]				;GET CR-LF
				;AND FALL INTO OUTSTR

;SUBROUTINE TO OUTPUT ASCIZ STRING TO THE CTY
;	C(A) = ADDRESS OF STRING
;	PUSHJ	P,OUTSTR

OUTSTR:	HRLI	A,(POINT 7,0)	;MAKE INTO A BYTE POINTER
OUTST2:	ILDB	C,A		;GET NEXT CHARACTER
	JUMPE	C,CPOPJ		;IF FINISHED
	PUSHJ	P,OUTCHR	;OUTPUT THE CHARACTER
	JRST	OUTST2		;CONTINUE

	PAGE
;SUBROUTINE TO OUTPUT 16 BIT OCTAL VALUE
;	C(A) = VALUE TO OUTPUT;       C(A) = VALUE TO OUTPUT
;	PUSHJ	P,OUTWRD

OUTWRD:	LDB	C,[POINT 1,A,20];GET FIRST DIGIT
	PUSHJ	P,OUTOC2	;OUTPUT IT
	LDB	C,[POINT 3,A,23];GET 2ND DIGIT
	PUSHJ	P,OUTOC2	;OUTPUT IT
	LDB	C,[POINT 3,A,26];GET 3RD DIGIT
	PUSHJ	P,OUTOC2	;OUTPUT IT
	LDB	C,[POINT 3,A,29];GET 4TH DIGIT
	JRST	OUTOC1		;CONTINUE

;SUBROUTINE TO OUTPUT OCTAL VALUE
;	C(A) = VALUE TO OUTPUT
;	CALL	OUTBYT

OUTBYT:	LDB	C,[POINT 2,A,29];GET FIRST DIGIT
OUTOC1:	PUSHJ	P,OUTOC2	;OUTPUT IT
	LDB	C,[POINT 3,A,32];GET 2ND DIGIT
	PUSHJ	P,OUTOC2	;OUTPUT IT
	LDB	C,[POINT 3,A,35];GET 3RD DIGIT
OUTOC2:	ADDI	C,60		;CHANGE IT ASCII
	JRST	OUTCHR		;OUTPUT IT AND RETURN

	PAGE
;SUBROUTINE TO OUTPUT SINGLE BIT VALUE
;	C(A) = BIT TO OUTPUT
;	PUSHJ	P,ONOFF

ONOFF:	JUMPN	A,ONOFF2	;IF NOT 0
	MOVEI	C,"0"		;0
	JRST	OUTCHR

ONOFF2:	MOVEI	C,"1"		;1
	JRST	OUTCHR

	PAGE
;SUBROUTINE TO INPUT SINGLE CHARACTER FROM THE CTY
;	PUSHJ	P,GETCHR
;	C(C) = CHARACTER

GETCHR:	MOVEI	D,CTYIVL	;IS THERE AN INPUT CHARACTER AVAILABLE?
	TDNN	D,CTYIWD
	JRST	GETCHR		;NO-WAIT FOR ONE
	MOVE	C,CTYIWD	;YES-GET IT
	SETZM	CTYIWD		;ALLOW ANOTHER
	ANDI	C,177		;JUST 7 BITS
	CAIN	C,177		;RUBOUT?
	JRST	GETCH1		;YES
	CAIE	C,12		;LINE FEED?
	CAIN	C,15		;OR CARRIAGE RETURN?
	JRST	GETCH2		;YES
	JRST	OUTCHR		;NO-ECHO CHARACTER AND RETURN

;HERE TO ECHO CR OR LF

GETCH1:	MOVEI	C,"X"		;RUBOUT-ECHO "XXX"
	PUSHJ	P,OUTCHR
	PUSHJ	P,OUTCHR
	PUSHJ	P,OUTCHR
	SETZ	C,		;AND RETURN A 0
GETCH2:	PUSH	P,C		;SAVE CHARACTER
	MOVEI	C,15		;GET A CR
	PUSHJ	P,OUTCHR	;OUTPUT IT
	MOVEI	C,12		;GET A LINE FEED
	PUSHJ	P,OUTCHR	;OUTPUT IT
	POP	P,C		;RESTORE INPUT CHARACTER
	POPJ	P,		;AND RETURN

;SUBROUTINE TO INPUT OCTAL VALUE FROM THE CTY
;	PUSHJ	P,GETOCT
;	C(A) = VALUE
;	C(B) = NUMBER OF DIGITS TYPED (0 IF NULL NUMBER)
;	C(C) = TERMINATING CHARACTER

GETOCT:	SETZB	A,B		;CLEAR VALUE AND CHARACTER COUNT
GETOC2:	PUSHJ	P,GETCHR	;GET NEXT CHARACTER
	CAIG	C,"7"		;IS IT A VALID DIGIT?
	CAIGE	C,"0"
	JRST	GETOC4		;NO
	ADDI	B,1		;YES-BUMP CHARACTER COUNT
	ANDI	C,7		;GET JUST VALUE OF DIGIT
	LSH	A,3		;SHIFT VALUE
	IOR	A,C		;MERGE IN NEW DIGIT
	JRST	GETOC2		;CONTINUE

GETOC4:	JUMPN	C,CPOPJ		;IF NOT STOPPED BY RUBOUT
	SETZ	B,		;RUBOUT-SAY NO INPUT
	MOVEI	C,15		;BUT RETURN A CR
	POPJ	P,		;AND RETURN

	PAGE
	SUBTTL	DATA

SAVEAC:	BLOCK	20		;PLACE TO SAVE MONITOR AC'S
STACK:	BLOCK	20		;OUR STACK
DADDR:	EXP	0		;LAST DATA ADDRESS OPENED
CADDR:	EXP	0		;LAST CRAM ADDRESS OPENED
CSADDR:	EXP	0		;LAST CSR ADDRESS OPENED
SPADDR:	EXP	0		;LAST SCRATCH PAD ADDRESS OPENED
MPPC:	EXP	0		;PLACE TO SAVE KMC MICRO-PC
MAR:	EXP	0		;PLACE TO SAVE KMC MAR
CFLAG:	EXP	0		;PLACE TO SAVE KMC C VALUE
ZFLAG:	EXP	0		;PLACE TO SAVE KMC Z VALUE
COUNT:	EXP	0		;SINGLE STEP COUNTER
CSR:	BLOCK	10		;PLACE TO SAVE KMC CSR'S
SVCRAM:	BLOCK	1000		;PLACE TO SAVE ENTIRE CRAM WHILE READING THE
				;  MICRO-PC!

	END
  a ZH