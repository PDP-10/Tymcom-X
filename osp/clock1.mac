TITLE	CLOCK1 - CLOCK, CONTEXT SWITCHING, AND JOB STARTUP AND STOP ROUTINES - V450

XP VCLOCK1,450
		; PUT VERSION NUMBER IN GLOB LISTING AND LOADER STORAGE MAP

	ENTRY CLOCK1		;ALWAYS LOAD CLOCK1 IF LIBRARY SEARCH
CLOCK1:

INTERNAL CLOCK

EXTERNAL CLKFLG,COMMAN,CONMES,DEVCHK,UPSCLK,UPTSTS,UPTABK
EXTERNAL UPTLDC,UPTJOB
EXTERNAL TIMPCD,PCDCNT
EXTERNAL DEVSRC,JBTPPN,RELEA9,SCHEDF,JBTUPM,%UPT,JBYUWS
EXTERNAL TIME,TIMEF,USRCLK,CURUPT,UPT,EPT
EXTERNAL UPTPC,UPTPDL,UPTXAC,UPTACP
EXTERNAL CIPWTM
EXTERNAL JOBOPC,UPTUAC,%UPS
EXTERNAL ERRTLE

CLKSAV:	0		;SAVE CLK CONI HERE
CLOCK:	POINT 36,CIPWTM,35	;BYTE POINTER TO CLOCK REQ QUEUE
DEFINE CALMAP
<>

SUBTTL	CLOCK - LOW PRIORITY CLOCK SERVICE(CLK)

;THIS ROUTINE RUNS ON THE LOWEST PRIORITY PI CHANNEL AND AT UUO LEVEL.

;TO CAUSE AN INTERRUPT ON CLK CHANNEL:
;	SETOM CLKFLG	;FLAG THAT INTERRUPT HAS BEEN REQUESTED
;	WRPI CLKREQ	;REQUEST PI INTERUPT ON LOWEST PI CHANNEL
;THE FOLLOWING OTHER FLAGS MUST ALSO BE SET
;APRERR-APR DETECTED ERROR IN CURRENT JOB
;SCHEDF-RESCHEDULING MUST TAKE PLACE(EVEN THOUGH PC IN EXEC MODE)
;TIMEF-APR CLOCK HAS TICKED ON HIGH PRIORITY CHANNEL
;SEE APRSER AND RUNCSS TO SEE HOW THIS ROUTINE IS CALLED

;CLK SERVICE PERFORMS THE FOLLOWING ON A REGULAR BASIS:
;PROCESSES CLOCK QUEUE REQUESTS
;CALLS CONSOLE MONITOR COMMAND DECODER
;CALLS CORE SHUFFLER
;THEN CALLS SCHEDULER
;IF THE CURRENT JOB IS IN EXEC MODE THE ABOVE 4 TASKS ARE
;DELAYED UNTIL THE CURRENT JOB ENTERS A STOPPABLE STATE: I.E., UNTIL
;	1. JOB STARTS TO WAIT FOR A BUSY SHARABLE DEVICE
;	2. JOB STARTS TO WAIT FOR IO TO COMPLETE
;	3. CONTROL ABOUT TO RETURN TO USER MODE
;THEN CLK SERVICE IS ENTERED AT UUO LEVEL

;THE CLOCK REQUEST QUEUE PROVIDES THE REST OF THE MONITOR
;WITH THE ABILITY TO BE TRAPPED TO AFTER A NUMBER OF CLOCK TICKS
;HAVE OCCURRED.
;
;TO MAKE A REQUEST:
;	WRPI LI.PIF
;	IDPB AC,CLOCK		;STORE CLOCK REQUEST IN QUEUE
;	WRPI LI.PIN		;TURN PI BACK ON
;C(AC)=XWD ADDRESS,NO. OF CLOCK TICKS+DATA*10000
;WHERE DATA IS 6 BITS OF INFO NEEDED WHEN TIME RUNS OUT
;CLK SERVICE WILL PUSHJ P,ADR
;WHEN TIME RUNS OUT WITH DATA RIGHT JUSTIFIED IN AC T1
;ALL ACS ARE FREE TO USE WHEN CALL IS MADE

INTERNAL CLKINI

CLKINI:	MOVEI T1,CIPWTM		;SETUP CLOCK QUEUE BYTE POINTER
	HRRM T1,CLOCK		;LH NEVER CHANGES(36 BIT BYTE)
	POPJ P,


;HERE AT UUO LEVEL WHEN JOB GOES INTO IO WAIT OR SHARABLE DEVICE WAIT
;CALL:	PUSHJ P,WSCHED
;	RETURN HERE WHEN RUNABLE AGAIN

INTERNAL WSCHED

WSCHED:	MOVEM 17,%UPT+UPTXAC+17	;SAVE AC17 IN DUMP ACS (P4 IN NEW ACS)
WSCHD1:	POP P,%UPT+UPTPC	;SAVE PC IN USER'S UPT.
	MOVEI 17,%UPT+UPTXAC	;SAVE ACS 0-16 IN DUMP ACS
	BLT 17,%UPT+UPTXAC+16	;IN CURRENT UPT JOB DATA AREA
WSCHD2:	MOVE P,[IOWD EPLLEN,UPT+UPTPDL] ;NULL JOB PD LIST. USED TO CALL SCHEDULER
				;AND COMMAND DECODER O'E GET PD OVF.
	CHGSTS	CLKSAV		;THIS IS ZERO AT INTERRUPT LEVEL
				; ELSE CHARGING CLOCK STATUS.
	NOCHARGE		;DON'T CHARGE FOR CONTEXT SWITCHING
	EXTERN	WRSMAP		;/WRS
	MOVE	J,JOB		;/WRS
	PUSHJ	P,WRSMAP	;/WRS - ignore if no state change
	JRSTF @[PC.UIO,,RSCHED]		;GO RESCHEDULE

;HERE AT UUO LEVEL WHEN CURRENT JOB RETURNS TO USER MODE
;FROM A UUO CALL AND EITHER:
;	1. CURRENT JOB TYPED CONTROL C WHILE IN EXEC MODE
;	2. CLOCK FLAG WENT OFF WHILE CURRENT JOB WAS
;		IN EXEC MODE

;CALL:	MOVE T1,JBTSTS(J)
;	PUSHJ P,USCHD1		;FROM UUOCON(M HANDLER RETURN TO USER)
;	RETURN HERE WHEN RUNABLE
INTERNAL USCHD1

USCHD1:	TLNE T1,CNTRLC		;DID USER TYPE CONTROL C WHILE IN EXEC MODE?
	PUSHJ P,TRHALT		;YES, STOP JOB AND TURN OFF RUN BIT, STORE HALT INFO IN CONTEXT PAGES

;HERE AT UUO LEVEL FROM MONRET M
;SAME CALL AS USCHD1, EXCEPT T1 NOT SETUP

INTERNAL USCHED
EXTERNAL STPFLG,TRHALT

USCHED:	POP P,%UPT+UPTPC	;SAVE PC IN USER'S UPT.
	MOVEM P,%UPT+UPTXAC+P	;SAVE P IN UPT DUMP AC AREA.
	SETOM STPFLG		;SET A FLAG TO SAY CAN STOP JOB
	JRST WSCHD2		;GO RESCHEDULE


;HERE AT CLK INTERRUPT LEVEL

INTERNAL CLKINT
EXTERNAL CLKCHL
EXTERNAL CLKBIT

CLKINT:	SKIPA
	JRST .			;CHECK OTHER CHANNELS
	WRPI CLKBIT+1B22	;CLEAR PROGRAM REQUEST ON THIS CHANNEL
	SKIPN CLKFLG
	JRST CLKINT+1		;NOT FOR THIS INTERUPT
	EXCH 17,CLKCHL		;IS CURRENT JOB IN USER MODE?
	TLNN 17,PC.USR
	SKIPE SCHEDF		;NO, IS THIS A FORSCED RESCHEDULING INTERRUPT?
	JRSTF @[XWD PC.UIO,SAVPC] ;YES, IT IS OK TO RESCHEDULE NOW
	EXCH 17,CLKCHL		;NO, LEAVE TIMEF SET AND DISMISS INT.
	JEN @CLKCHL

SAVPC:	SETZM CLKSAV		;CLEAR CONI SAVE FLAGS
	MOVEM 17,%UPT+UPTPC	;SAVE USERS PC (USER OR EXEC)
	TLNE 17,PC.USR
	JRST CLKUSM		;IN USER MODE, NO SAVE OF EXEC ACS
	EXCH 17,CLKCHL		;GET REGISTER 17 BACK
	MOVEM 17,%UPT+UPTXAC+17	;AND STORE IN RIGHT PLACE
	MOVEI 17,%UPT+UPTXAC	;SOURCE=0,DESTINATION=DUMP AC 0
	BLT 17,%UPT+UPTXAC+16	;SAVE ACS 0-16 JUST BELOW AC 17
	JRST	CLKEXM	
CLKUSM:
IFNCPU (KI),<
	MOVE	17,CLKCHL	;WAS USER'S AC 17, RESTORE IT.
	EXECAC			;SWITCH TO EXEC AC BLOCK, WITH USERS AS PREVIOUS.
>;END IFNCPU (KI)
	SETOM STPFLG
CLKEXM:	MOVE P,[IOWD EPLLEN,UPT+UPTPDL] ;SET UP PUSH DOWN LIST IN NULL JOB DATA
				; AREA IN LOWER CORE
IFCPU (KS),<NOCHARGE>		;FREEZE TIME BASE FOR CHARGING
	SKIPGE	%UPT+UPTJOB	;JOB GOING AWAY?
	SETOM	JOB		;YES, SPECIAL FLAG THAT SAYS SO.

EXTERNAL COMCNT,NXTJOB,HNGTIM,POTLST,LSTWRD,SCNINT,HNGMIN,CKRMT
EXTERNAL JOB,PMONTB,MONHNG,DWNFLG,TAKDWN,INTERM,SATWRT

RSCHED:	SKIPE	%UPT+UPTLDC	;JOB HAS ANY SLOTS IN P3 AND P4?
	STOPCD		;YES, CRASH.
	SKIPGE J,JOB
	JRST RSCH1		;SPECIAL CASE, JOB GOES AWAY
	SKIPE JBTLIM(J)
	PUSHJ P,TIMADJ		;IN CASE HE WANTS TIME LIMIT
RSCH1:	PUSHJ	P,CKRMT		;CALL REMOTE PERIPHERAL SERVICE
	SKIPN TIMEF		;HAS CLOCK GONE OFF SINCE LAST CALL?
	JRST CIP6		;NO, JUST RESCHEDULE

;TIME ACCOUNTING

EXTERNAL MIDNIT,THSDAT

EXTERNAL NULTIM,NULMNT
	SKIPN	J,JOB		;WAS LAST JOB NULL JOB?
	SKIPN	POTLST		;YES-WAS IT A LOST TICK?
	JRST	INCTIM		;NO-PROCEED NORMALLY
	AOS	LSTWRD		;YES-INCREMENT LOST TIME COUNT
	SETZM	POTLST		;AND CLEAR LOST TICK INDICATION
;MIDNITE CHECK

INCTIM:	JUMPN	J,.+2		;IS IT NULL JOB?
	AOS NULTIM		;YES
	MOVE T2,TIME
	CAMGE T2,MIDNIT		;GONE PAST MIDNITE?
	JRST CIP2		;NO
	MOVN T2,MIDNIT		;RESET TIME
	ADDM T2,TIME
	AOS THSDAT		;AND INCREMENT DATE

;PROCESS TIMING REQUESTS STORED IN QUEUE

;CLOCK REQUEST.
;BITS 1-6 ARE A TABLE INDEX TO THE FUNCTION TO CALL
;BITS 7-11 ARE A TYPE FILED. ONLY 1 REQ/JOB/TYPE
;BITS 12-18 ARE THE JOB NUMBER
;IF BIT 0=0 THEN BITS 19-35 ARE THE TIME COUNT IN JIFFIES
;IF BIT 0 IS NON-ZERO BITS 20-35 ARE THE TIME COUNT AND BIT 19
;  A 1 INDICATES TIME IN MINUTES, BIT 19 A 0, TIME IN SEC.

EXTERN HANGRB
CIP2:	SKIPGE DWNFLG
	SKIPLE HIGHJB
	JRST CIP2A
	SKIPN INTERM		;DO NOT GO DOWN IF LAST TERMINAL NOT OFF
	PUSHJ	P,HANGRB	;ALL THE RIBS OUT OF CORE?
	JRST	CIP2A		;
	SKIPGE	SATWRT		;DO NOT GO DOWN UNLESS ALL SATS OUT.
	JSR TAKDWN		;ORDERLY SHUTDOWN, ALL JOBS GONE
CIP2A:	HRRZ U,CLOCK
CIP4:	CAIN U,CIPWTM		;FINISHED YET?
	JRST CIP5		;YES
	SOSGE T2,(U)		;DECREMENT TIME COUNT
	JRST CIP4S		;BIT 0 ON, SEC. OR MIN.
CIP4T:	TRNE T2,377777		;IS TIME FIELD NOW 0?
	SOJA U,CIP4		;NO, CHECK NEXT REQUEST
	WRPI LI.PIF		;MOVE LAST REQ. TO REPLACE THIS
	MOVE T1,@CLOCK
	SOS CLOCK
	MOVEM T1,(U)
	WRPI LI.PIN
	LDB T1,[POINT 7,T2,18]	;GET JOB NUMBER
	LDB T2,[POINT 6,T2,6]	;AND DISPATCH NUMBER
	PUSH P,U		;SAVE POINTER
	PUSHJ P,@CLKDSP(T2)	;DISPATCH
	POP P,U
	SOJA U,CIP4		;FINISH UP

CIP4S:	SKIPN HNGTIM		;IS THIS AN EVEN SECOND?
	JRST CIP4M		;YES, SEE IF WANT SECONDS OR MINUTES
CIP4S1:	AOS (U)			;NO, RESET REMAINING TIME
	SOJA U,CIP4		;AND GO ON

CIP4M:	TRZE T2,1B19		;SECONDS?
	SKIPN HNGMIN		;NO MINUTES, EVEN MINUTE?
	JRST CIP4T		;WANTED SECONDS OR EVEN MINUTE, TAKE TRAP
	JRST CIP4S1		;FORGET IT

CLKDSP:				;DISPATCH ROUTINES
	PHASE 0
.SLWAK:! EXP WAKE		;WAKE JOB
	0			;USED TO BE FOR BAD UNIT CODE
.SLTIM:! EXP TIMWAK		;WAKE UP THE TIMER
.SLHNG:! EXP MONHNG		;HANG ON DETACHED TIMOUT
	DEPHASE

INTERNAL .SLWAK,.SLTIM,.SLHNG

CIP5:	SKIPLE J,JOB
	PUSHJ P,USRCLK		;SEE IF USER WANTS A CLOCK TRAP
CIP5A:	SOSGE HNGTIM		;DECREMENT HUNG IO DEVICE 
	PUSHJ P,SECOND		;GO DO ONCE-A-SECOND JOBS
	SKIPE COMCNT		;ANY COMMANDS TO PROCESS?
	PUSHJ P,COMMAND		;YES, CALL COMMAND DECODER
	SKIPN	PCDCNT		;ANYTHING TO DO WITH PCBS?
	PUSHJ	P,TIMPCD	;YES, GO TO IT.
	PUSHJ P,SCNINT		;DO SCNSER STUFF AT CLOCK LEVEL
	SKIPL J,JOB
	SKIPN JBTLIM(J)
	JRST CIP6		;NO LIMIT DESIRED
	PUSHJ P,CLKTRU		;CALC CURRENT TRU FIGURE
	CAMGE T1,JBTLIM(J)	;IS IT OVER?
	JRST CIP6		;NO
	MOVSI T1,JACCT+KJP
	TDNN T1,JBTSTS(J)	;OR IS THIS ONE UNSTOPABLE
	SKIPN STPFLG
	JRST CIP6		;DO NOT STOP IN A DANGEROUS PLACE
	PUSHJ	P,ERRTLE	;GO DO PROPER THING, RETURN AFTER CALLING STOP1.

;ERRTLE JRSTS BACK HERE TO CIP6 WHEN DONE.

CIP6::	PUSHJ P,NXTJOB		;CALL SCHEDULER

	SETZM CLKFLG		;CLEAR CLK INTERRUPT FLAG
				; SET ON ALL FORCED CLK INTERRUPTS
	SETZM TIMEF		;CLEAR TIMED (1 JIFFY) INTERRUPT FLAG.
	SETZM SCHEDF		;CLEAR FORCED SCHEDULING FLAG
	SETZM STPFLG
	CAMN J,JOB		;IS NEXT JOB SAME AS LAST ONE?
	JRST CIP8		;YES, JUST RESTORE ACS AND DISMISS
	PUSH P,J
	SKIPL J,JOB		;(IN CASE JOB GOING AWAY, NO TIMADJ)
	PUSHJ P,TIMADJ		;UPDATE TIME CELLS BEFORE SWITCHING JOBS
	POP P,J
;DIFFERENT JOB, SAVE SOFTWARE STATE(HAE ALREADY SAVED)

EXTERNAL CLKTRU

	SKIPN	T2,JOB		;IF NULL JOB,
	JRST	CIP6C		;DON'T SAVE ACS.
	JUMPL	T2,CIP7		;IF LAST JOB LOGGED OUT,
				; DON'T TOUCH UPT AT ALL, ITS GONE.
IFNCPU (KI),<
	MOVE	T1,%UPT+UPTACP	;IS "REAL" PREVIOUS AC BLOCK USER?
	TLNE	T1,(LG.PAC)	;IF NOT, MUST SAVE PREVIOUS AC BLOCK IN STACK.
	JRST	CIP6D		;YES, HAVE TO SAVE PREVIOUS.
CIP6E:
>;END IFNCPU (KI)
	MOVEI T1,%UPT+UPTUAC	;READY TO STORE USERS ACS (FROM AC BLOCK)
	XCTFU <BLT T1,%UPT+UPTUAC+17>
CIP6C:	SKIPN T1,CLKSAV		;EITHER FROM SAVE (WSCHED ETC)
	CHGSTS	T1	;FOR FROM CLOCK
	MOVSI T2,UPSCLK
	ANDCAM T2,%UPT+UPTSTS	;RESET SAVED BIT
	TRNE T1,CHGON
	IORM T2,%UPT+UPTSTS	;AND SET IF CLOCK IS ON

;RESTORE SOFTWARE STATE OF NEW JOB,THEN HARDWARE STATE

INTERNAL NULJOB
EXTERNAL USRXT7

NULJOB:				;TRANSFER HERE FROM SYSINI WITH J=0
CIP7:	MOVEM J,JOB		;STORE NEW CURRENT JOB NUMBER
	HRRZ T1,JBTUPM(J)	;GET ITS UPT ADDRESS
IFCPU (KI),<
	HRLM	T1,CURUPT
	WRUBR	CURUPT	;RESET THE PAGING HARDWARE TO
>;END IFCPU (KI)

IFNCPU (KI),<MOVEM T1,CURUPT>
				;  POINT TO THE UPT FOR THE NEW JOB
	JUMPE	J,NULJB		;
IFNCPU (KI),<
	HRLI	T1,(LG.LUB!LG.LAB!<EX0ACB>B8+<USRACB>B11)
	WRUBR	T1		;MAKE USER ACS ACCESSABLE FOR RESTORE.
>;END IFNCPU (KI)
IFCPU (<KL,F3>),<
ABKSET::DATAO	APR,%UPT+UPTABK	;PATCH HERE TO USE ADDRESS BREAK FOR MONITOR DEBUG
>;END IFCPU (<KL,F3>)
IFNCPU (<KL,F3>),<
ABKSET::JFCL			;ON KI, ALWAYS LOOKS PATCHED OUT.
>;END IFNCPU (<KL,F3>)
	MOVSI 17,%UPT+UPTUAC
	XCTTU <BLT 17,17>	;RESTORE USERS ACS
IFNCPU (KI),<
	MOVE	T1,%UPT+UPTACP	;GET AC STATUS STUFF
	TLNN	T1,(LG.PAC)	;PREVIOUS ACS ALREADY USER?
	JRST	CIP7A		;YES, NOTHING MORE TO DO.
	WRUBR	T1		;NO, GET REAL AC STUFF.
	MOVE	T1,%UPT+UPTACP	;IN CASE IT DISAPPEARED
	MOVSI	T2,-16(T1)	;POINTER TO RESTORE PREVIOUS ACS
	XCTTU	<BLT T2,17>	;RESTORE THEM.
	MOVE	T2,%UPT+UPTPC	;GET PC
	TLNN	T2,PC.UIO	;IF USER IOT IS OFF,
	JRST	CIP7A		;EVERYTHING IS NOW SET.
	TLZ	T1,(LG.PAC)	;NO, MUST ACCESS USER ACS IN XCTS
	WRUBR	T1		;SO SET IT UP.
>;END IFNCPU (KI)
CIP7A:
IFCPU (KI),<
	HLRZ T1,%UPT+UPTACP
	RDEBR T2
	TRZ T2,760000
	IOR T2,T1
	WREBR (T2)	;SET EXEC AC STACK POINTER
>;END IFCPU (KI)

;RESTORE HARDWARE STATE OF CURRENT JOB

IFNCPU (KS),<NOCHARGE>		;MAKE SURE CLOCK IS OFF (IN CASE IRP LEVEL)
IFCPU (KS),<SKIPE	TBON		;TEST IF CLOCK OFF
	  JRST	[RDTIME TBVALUE	;ELSE TURN OFF
		 SETZM	TBON	
		 JRST .+1]
>;END IFCPU (KS)
	MOVE	T1,%UPT+UPTSTS	;IS CLOCK SUPPOSED TO BE ON?
	TLNE	T1,UPSCLK
IFNCPU (KS),<CHARGE		>	;YES, TURN IT ON
IFCPU (KS),<SKIPA>			;TEST KS CHARGING STATE
	JRST	CIP9		;GO RETURN TO THE PROGRAM.
IFCPU (KS),<SKIPN	TBON	;SKIP IF ALREADY ON
	  JRST	[WRTIME TBVALUE
		 SETOM TBON
		 JRST .+1]
	JRST	CIP9>

CIP8:	SKIPN T1,CLKSAV	;FROM INTERUPT LEVEL?
	JRST CIP9		;YES
	TRNE	T1,CHGON	;WAS CLOCK ON WHEN USER CAME IN?
IFNCPU (KS),<CHARGE	>		;YES, RESTORE STATE OF THE CLOCK.
IFCPU (KS),<SKIPA>
	JRST	CIP7B
IFCPU (KS),<SKIPN	TBON		;SKIP IF CLOCK ALREADY ON
	  JRST	[WRTIME TBVALUE
		 SETOM TBON
		 JRST .+1]>

CIP7B:
	CALMAP

CIP9:	MOVSI 17,%UPT+UPTXAC	;RESTORE DUMP ACS
	MOVE T3,%UPT+UPTPC
	TLNN T3,PC.USR
	JRST	[BLT 17,17	;RESTORE ACS FOR EXEC MODE
		JEN @%UPT+UPTPC]
	MOVE P,[IOWD EPLLEN,%UPT+UPTPDL]
	JRST USRXT7	;AND GO THROUGH USRXIT FOR TRAPS

;THE NULL JOB
;RUNS IN USER MODE WITH PC=1 AND COUNTS IN AC 0

NULJB:
IFNCPU (KS),<CHARGE>
IFCPU (KS),<SKIPN	TBVALUE	;SKIP IF CLOCK ALREADY ON
	  JRST	[WRTIME TBVALUE
		 SETOM TBON
		 JRST .+1]
>;END IFCPU (KS)
IFCPU (<KL,F3>),<
	MOVE	T2,ABKSET	;GET SETTING INSTRUCTION
	CAMN	T2,[DATAO APR,%UPT+UPTABK] ;LEAVE ALONE IF NOT NORMAL MODE.
	DATAO	APR,[0]		;NO NULL JOB ADDRESS BREAK.
>; END IFCPU (<KL,F3>)
IFNCPU (KI),<
	HRLI	T1,(LG.LUB!LG.LAB!<USRACB>B8+<USRACB>B11)
	WRUBR	T1	;SET USER AC BLOCKS, UBR OF NULL JOB.
IFNCPU(F3),<
	SETZ	0,
	MOVE	1,[AOJA 1]	;THIS IS KL NULL JOB
>;END IFNCPU (F3)
IFCPU(F3),<
	MOVSI	17,F3NULJ
	BLT	17,17
>;END IFCPU (F3)
	JEN	@[PC.USR+PC.PUB+PC.UIO,,1] ;START IT.
>; END IFNCPU (KI)
IFCPU (F3),<;DO LIGHTS SHOW ON AN F3

F3NULJ:	0		;0/
	MOVEI	100000	;1/
	SOJG	2	;2/
	ROT	16,-3	;3/
	ROT	17,2	;4/
	MOVE	15,17	;5/
	IOR	15,16	;6/
	DATAO	PI,15	;7/
	JRST	1	;10/
	0		;11/
	0		;12/
	0		;13/
	0		;14/
	0		;15/
	17		;16/
	17		;17/
>;END IFCPU (F3)

IFCPU (KI),<
	JEN @%UPT+UPTPC ;ALSO DISMISS IF IN INT
>;END IFCPU (KI)

IFNCPU (KI),<
;HERE IF "REAL" PREVIOUS AC BLOCK IS NOT USER - MUST SAVE
; IT IN AC STACK. T1 CONTAINS UPTACP WORD.

CIP6D:	MOVE	T2,%UPT+UPTPC	;IF USER IOT IS CLEAR, ALREADY SET CORRECTLY
	TLNE	T2,PC.UIO
	WRUBR	T1		;SETUP "REAL" PREVIOUS ACS.
	HRRI	T1,-16(T1)	;GET FIRST ADDRESS IN RH OF T1, AC DATAO IN LH T1
	HRRZ	T2,T1		;0,,FIRST ADDRESS IN T2.
	TRNE	T1,17		;HOPE THERE'S ROOM LEFT
	STOPCD			;NO ROOM. CRASH.
	XCTFU	<BLT T2,17(T1)> ;SAVE PREVIOUS AC BLOCK
	TLZ	T1,(LG.PAC) ;SET TO SAVE USER ACS
	WRUBR	T1		;DON'T TRUST USER IOT
	JRST	CIP6E
>;END IFNCPU (KI)

;SUBROUTINE CALLED AT CLOCK LEVEL ONCE A SECOND

EXTERNAL SCNSEC,JFYSEC,RPTSAT

SECOND:	MOVE T1,JFYSEC		;RESTORE THE SECOND-COUNTER
	SUBI T1,1
	MOVEM T1,HNGTIM		;TO FULL SECOND
	PUSHJ P,UPELP		;UPDATE ELAPSED TIME
	PUSHJ P,UNISEC
	PUSHJ	P,SWPSEC	;DO SWAPPER ONCE A SECOND STUFF
	PUSHJ P,DEVCHK		;GO CHECK FOR HUNG DEVICES
	PUSHJ	P,RPTSAT	;REPORT ANY NEWLY BAD SATS.
IFCPU (KS),<PUSHJ	P,KSSEC>	;GO KEEP THE KEEP ALIVE COUNTER
	SOSGE HNGMIN		;ONCE A MINUTE
	PUSHJ P,MINUTE
; IF CTYBLF IS .GT. 0 THEN SET TO -1 NOTIFYING
;	OPRCTY IN SCNSER TO RING BELL NEXT TICK.
;	(AAA JAN 1977)
	SKIPLE CTYBLF
	SETOM CTYBLF
IFCPU (KS),<
; CHECK LOCATION 30 FOR NON-ZERO AND CALL HNGALL IF IT IS
;	THIS WAS, DEP ANY NON-ZERO IN 30 WILL ATTEMPT A SOFT CRASH
;	HP-CLOCK WILL COUNT DOWN AND HARD CRASH IF THIS HASN'T BEEN
;	DONE YET WHEN TIME EXPIRES
;	A SECOND DEP 30 WILL ALWAYS HARD CRASH IMMEDIATELY
	EXTERN CRSHWD,HNGALL
	SKIPE CRSHWD
	  PUSHJ P,HNGALL
>; END IFCPU (KS)
;NOW GO HANDLE TELETYPE PROBLEMS
	PJRST SCNSEC

;SUBROUTINE CALLED ONCE A SECOND TO COUNT THE KEEP ALIVE COUNTER
;  FOR THE KS 8080 FRONT END

IFCPU (KS),<

KSSEC:	LDB	T1,BKPALV	;GET THE CURRENT COUNT
	AOS	T1		;INCREMENT IT
	CAILE	T1,377		;WE COUNT IT MODULO 8 BITS
	SETZ	T1,
	DPB	T1,BKPALV	;PUT IN ITS PROPER PLACE
	POPJ	P,		;RETURN

BKPALV:	POINT	KPALVL,RLWORD##,KPALVE	;BYTE POINTER TO KEEP ALIVE COUNT
>;END IFCPU (KS)

NULSAV:	0

MINUTE:	MOVEI T1,^D59		;RESET COUNTER
	MOVEM T1,HNGMIN

;INACTIVITY TIMEOUT
;
EXTERN	JBTINA,HNGMON,JBYNTQ,JBYLIM,INAHIT

	SETCM	J,HIGHJB	;SETUP AOBJN WORD TO
	HRLZS	J		; ACCESS JBTINV TABLE
INACT2:	LDB	T3,JBYLIM
	JUMPE	T3,INACT1	;JUMP IF INACTIVITY HANG DISABLED
	MOVE	T1,JBTINA(J)
	CAIL	T3,(T1)		;Have we reached the limit?
	  JRST	INACT1		;  No!
	TLOE	T1,INAHIT	;RECORD FACT THAT INACTIVITY HIT OCCURED
	  JRST	INACT1		;ALREADY OCCURED
	MOVEM	T1,JBTINA(J)
	SKIPL	JBTSTS(J)	;Is job runable (not halted or ^C)?
	  JRST	INTKIL		;  No, ignore NTQ and just kill it
	LDB	T1,JBYNTQ	;GET NTQ CHANNEL
	JUMPE	T1,INTKIL	;NTQ NOT ENABLED, GO KILL JOB
	PUSH	P,J
	HRRZS	J		;OTHERWISE CAMN FAILS
	PUSHJ	P,TAKTRP	;FIRE NTQ
	POP	P,J
	JRST	INACT1
INTKIL:	MOVE	T1,J		;HANG JOB J
	HRLI	T1,(1B13!1B17)	; EVEN IF DETACH
	PUSHJ	P,HNGMON	; OR TIMEOUT SET
	 JFCL			;ALREADY HUNG
INACT1:	AOS	JBTINA(J)	;INCREMENT INACTIVE COUNT
	AOBJN	J,INACT2	;LOOP FOR REST OF JOBS

	MOVEI J,JOBN		;CHECK JOBS FOR JCONT
MINUT1:	MOVE T1,JBTSTS(J)
	TLNN T1,JERR		;CAN NOT CONTINUE
	TRNN T1,JDCON
	JRST MINUT2
	MOVE T1,J
	PUSHJ P,FCONRQ		;TRY TO FORCE A CONTINUE
	 JFCL			;CAN NOT, IGNORE IT
MINUT2:	SOJG J,MINUT1
	MOVE T1,NULTIM
	EXCH T1,NULSAV		;WHERE WE SAVE THE ONE FROM A MINUTE AGO
	SUB T1,NULSAV		;CALCULATE DIFFERENCE
	MOVNM T1,NULMNT		;AND SAVE IT (DIFF HAS WRONG SIGN)

EXTERNAL STRDDB,STRTAL

	MOVE T2,STRDDB+STRTAL	;GET ADVERTISED DISK SPACE REMAINING (ACTUALLY A LITTLE MORE)
	CAILE T2,^D100		;IF MORE THAN 100 PAGES LEFT, OK
	JRST WDOG
	MOVEI T1,[ASCIZ/
DISK SPACE LESS THAN 100. PAGES
/]
	SKIPG T2		;PRINT THAT UNLESS ITS ACTUALLY EMPTY
	MOVEI T1,[ASCIZ/
DISK FULL, PLEASE TAKE CORRECTIVE ACTION
/]
	PUSHJ P,DBLMSG		;PRINT ON CTY AND ON OPR TERM IF IT EXISTS
;	JRST WDOG		;AND FALL INTO CHKPNT WATCHDOG.

COMMENT #	** THE CHKPNT WATCHDOG ** 

ONCE A MINUTE THIS CODE EXAMINES THE SITUATION WITH THE STREAM
ACCOUNTING MECHANISM.
1. IF THE SYSTEM IS UN-SHUT (NOT IN AUTORESTRART,SHUT OR
   SUPERSHUT) AND NO ACT OWNER (PJOBN) EXISTS, A MESSAGE GOES TO
   BOTH OPR & CTY (OR JUST CTY IF NO OPR) AND THE BELL IS SET
   TO RING ONCE A SECOND.
2. IF SYSTEM IS IN ANY SHUT STATE, IT'S OK FOR ACTOWNER = 0
3. IF ACTOWNER HAS JERR ON (ILL INS,ILL MEM REF, EXIT..)
	THEN A REQUEST TO RESTART CHKPNT IS PUT OUT ON
	OPR & CTY AND THE CTY BELL IS SET TO RINGING.

4. A FAKE "SCHED 400000" IS DONE. THE ACTDED BIT IS SET,
   ALLOWING OPERATORS TO GET ONTO SYS AND FIX THINGS UP WITHOUT
   THEIR JOBS GOING INTO AC WAIT. SEE GETABS IN ACTSER.

CTY BELL FLAG CTYBLF WORKS AS FOLLOWS
0,,0	QUIET. MINUTE,SECOND & OPRCTY CODE DO NOTHING
0,,-1	THE BELL SHOULD RING (SET BY MINUTE CODE)
-1,,-1	BELL SHOULD RING NEXT TICK (SET BY SECOND CODE, RESET BY OPRCTY)

#


EXTERNAL ACTDDB,ALR620,GETOPR,SKDCOM,PJOB,ACTDED,STATES
EXTERNAL GTOPER,CTYBLF,CONMES,GETCTY

WDOG:		;CLOBBER F,T1,T2,..,J
	MOVEI F,ACTDDB
	LDB J,PJOBN	;J:=ACT OWNER JOB IF INITTED
	MOVE T2,[STAUTO!STSUPR!STSHUT];AUTO-RESTART,SHUT,SUPER-SHUT
	SETO T3,	;PREPARE FOR SET CTYBLF BELL FLAG
	TDNN T2,STATES	;IF ANY OF THESE ON, OK FOR ACT TO BE UN-INITTED
	JUMPE J,[HRRZM T3,CTYBLF	;BELL FLAG GOES ON
		MOVEI T1,[ASCIZ/
SYSTEM UN-SHUT WITHOUT ACCOUNTING.
LOG IN TO 'OPER' AND 'R CHKPNT'/]
		PUSHJ P,DBLMSG		;SEND TO 2 PLACES IF POSSIBLE
		MOVEI T2,ALRACT
		IORM T2,ALR620
		POPJ P,]
	JUMPE J,CPOPJ	;SOME KIND OF SHUT STATE WITH NO CHKPNT
	MOVE T1,JBTSTS(J)
	TLNN T1,JERR	;HAS ACT JOB DIED?
	POPJ P,		;NO
	HRRZM T3,CTYBLF	;BELL FLAG GOES ON (>0)
	MOVEI T2,ALRACT
	IORM T2,ALR620
	MOVSI T2,ACTDED	;DECLARE THE STREAM DEAD. SEE MGETABS (ACTSER)
	IORM  T2,DEVSTS(F)	;THIS LETS SOME JOBS GO W/O STREAM RECORDS
	PUSHJ P,DPJOB	;PUT CHKPNT JOB NO IN FATMSG
	MOVEI T1,FATMSG	;FATAL CHKPNT ERROR MSG
	PUSHJ P,DBLMSG	;PRINT 2 PLACES IF POSS.
	MOVEI T2,STSHUT
	PUSHJ	P,SKDCOM	;FAKE "SCHED 440000" & EXIT. DECLARE STREAM DEAD & SHUT SYS
	JRST	.+1
	POPJ	P,

FATMSG:	ASCII /CHKPNT PROGRAM FATAL ERROR
'R CHKPNT' AFTER ATTACHING TO JOB /
.JBNO==.-1

; DPJOB..PUT CHKPNT JOB NO. ON END OF ABOVE MSG. DEPENDS ON
; THE MSG BEING OF CORRECT LENGTH TO LEAVE 3 BYTES AVAIL IN
; LAST WORD, 2 FOR POSS JOB NO, 1 ZERO FOR TERMINATOR.

DPJOB:	LDB T1,PJOBN
	MOVE T3,[POINT 7,.JBNO,13]	;BEGIN 3RD BYTE IDPB
.DPJBL:	IDIVI T1,^D10
	HRLM T2,(P)	;SAV DIGIT ON STACK LH
	SKIPE T1
	PUSHJ P,.DPJBL
	HLRZ T1,(P)	;RETREIVE DIGIT
	ADDI T1,"0"
	IDPB T1,T3
	POPJ P,

; DBLMSG..TAKE MSG ADDR IN T1, TYPE IT OUT ON BOTH CTY AND OPR TTY IF
;THERE IS AN OPR TTY, ELSE JUST TO CTY. CLOB F,U,T1-T4. ALL
;OTHER ACS ARE NOT DESTROYED.

INTERNAL DBLMSG
DBLMSG:	PUSH P,T1
	PUSHJ P,GTOPER	;RET SKIPPING IF GOT OPR TTY
	JRST DBL2L	;ONLY CTY PRESENT
	MOVE T1,(P)	;RESTORE MSG ADDR
	PUSHJ P,CONMES	;ACCEPTS T1=MSG, CLOB T1
	PUSHJ P,GETCTY	;NOW GET CTY LDB & DDB IN U,F
DBL2L:	POP P,T1	;MSG ADDR
	PJRST CONMES	;MSG OUT TO CTY NOW, RETURN NO SKIP

;..GTOPER PREFERRENTIALLY RETURNS OPR TTY LDB,DDB ADDRS.
; IF THERE IS NONE, RETURNS NON SKIP CTY LDB ETC. SCNSER PG 117

;UPDATE ELAPSED AND CONNECT TIME COUNTERS

UPELP:	MOVE J,HIGHJB
	MOVE T1,UPTIME		;SEE HOW MANY SECONDS HAVE ELAPSED
	PUSH P,T1		;SAVE UPTIME
	IDIV T1,JFYSEC		;TO SECONDS
	EXCH T1,(P)		;UPTIME BACK
	EXCH T1,SAVUPT		;GET UPTIME LAST TIME CALLED
	IDIV T1,JFYSEC		;SECONDS FOR THAT
	POP P,T2
	SUB T2,T1		;NUMBER OF SECONDS SINCE LAST CALL
SECTIM:	MOVE T1,JBTSTS(J)
	TLNN T1,JNA
	JRST NXTSEC
	PUSHJ	P,GTCGSZ	;GET JOB'S CHARGING SIZE TO T1.
	IMUL T1,T2		;GET SIZE*ELAPSED SECONDS
	ADDM T1,JBTELP(J)
	ADDM T1,JBTELP
	HRRZ T1,TTYTAB(J)
	JUMPE T1,NXTSEC		;IGNORE IF NOT TTY
	HRRZ T1,DDBLDB(T1)	;SEE IF A U ATTACHED
	JUMPE T1,NXTSEC		;NO, IGNORE
	ADDM T2,JBTCNK(J)	;YES, N SEC. MORE OF CONNECT
	ADDM T2,JBTCNK
NXTSEC:	SOJG J,SECTIM
	POPJ P,

SAVUPT:	0			;SAVE UPTIME FOR CALULATING CONNECT AND ELAPSED TIMES

EXTERNAL JBTELP,JBTCNK,TTYTAB,DDBLDB,UPTIME

;GET THE SIZE OF A PARTICULAR JOB

GETSIZ::EXCH T2,(P)		;SIZE WILL BE ON TOP OF PDL ON RETURN
	PUSH P,T2
	LDB T2,JBYUWS		;GET USER WORKING SET SIZE
	LSH T2,-1		;NEEDS TO BE IN K
	EXCH T2,-1(P)
	POPJ P,
COMMENT #
@@SUBROUTINE GTCGSZ
@@PURPOSE
GET INTO T1 THE CHARGING SIZE OF THE JOB IN K.
@@ENTRY
EXPECTS J/ JOB NUMBER.
@@ACCUM
DESTROYS T1.
@@EXIT
RETURNS SIZE IN T1.
@@#

EXTERN	JBYSC3,JBYSC4
INTERN GTCGSZ

GTCGSZ:
	LDB	T1,JBYSC4	;See if there is a size-dependent scale
				; factor (XCHARG TRU-scale UUO)
	JUMPE	T1,[LDB	T1,JBYSC3
		   JUMPE T1,GTCGS1
		   POPJ	P,]
	PUSH	P,T2		;Get a scratch register
	PUSH	P,T1		;Save denominator of fraction
	PUSHJ	P,GTCGS1	;Get internal size to T1
	LDB	T2,JBYSC3	;Get numerator
	IMULI	T1,(T2)		;T1 gets size*numerator
	POP	P,T2		;Get back denominator
	IDIVI	T1,(T2)		;T1 gets quotient
	POP	P,T2		;Restore work register
	POPJ	P,

GTCGS1:	LDB	T1,JBYUWS	;
	ADDI	T1,1		;ROUND UP.
	LSH	T1,-1		;
	POPJ	P,

;INTERRUPT HANDLERS FOR THE DK10 REAL TIME CLOCK

IFCPU (KI),<
;INITIALIZE

TIMINI:	SETZM TIMCNT		;COUNT OF OVERFLOWS
	DATAO CLK,[0]		;SET STOP COUNT TO 0
	CONO CLK,CLKCDN+CLKCOV+CLKON+CLKUSR+CLKCLR+TIMCHN
	SETZM TM2CNT
	DATAO CLK2,[0]		;MAKE SURE SECOND CLOCK IS RESET
	POPJ P,

TIMCNT:	0

TIMINT:	CONSO CLK,CLKCDN+CLKCOV	;IS IT THE DK10?
	JRST TIMINT		;NO
	DATAO CLK,[0]		;JUST TO MAKE SURE
	AOS TIMCNT
	CONO CLK,CLKCDN+CLKCOV+CLKON+CLKUSR+TIMCHN
	JEN @TIMCHL

EXTERNAL TIMCHN,TIMCHL,TM2CHN,TM2CHL

INTERNAL TIMINI,TIMINT,TM2INT,STSTIM


TM2INT:	CONSO CLK2,CLKCDN+CLKCOV
	JRST TM2INT
	DATAO CLK2,[0]
	AOS TM2CNT
	CONO CLK2,CLKCDN+CLKCOV+CLKON+TM2CHN
	JEN @TM2CHL

STSTIM:	CONO CLK2,CLKSTP
	DATAI CLK2,T1
	HRL T1,TM2CNT		;GET HIGH ORDER PART OF CLOCK
	DATAO CLK2,[0]
	CONO CLK2,CLKON+TM2CHN
	POPJ P,

TM2CNT:	0
>;END IFCPU (KI)
;ROUTINES TO SIMULATE TURNING ON AND OFF THE CLOCK FOR THE KS

;  TO TURN ON THE CLOCK FOR THE USER THE TIME BASE IS SET
;    TO THE VALUE IN TBVALUE, INITIALLY SET TO 0
;  TO TURN OFF THE CLOCK THE CURRENT VALUE OF THE TIME BASE
;    IS SAVED IN TBVALUE AND USED TO RESET THE TIME BASE
;    WHEN THE CLOCK IS TURNED BACK ON

IFCPU (KS),<
INTERNAL KSCHRG,KSNOCH,TBON,TBVALUE

;TURN ON CHARGING
KSCHRG:	SKIPE	TBON		;TEST IF OFF
	  POPJ	P,		;RETURN IF ALREADY ON
	WRTIME	TBVALUE		;SET THE TIME BASE 
	SETOM	TBON		;FLAG THE CHARGING ON
	POPJ	P,

;TURN CHARGING OFF IF ON
KSNOCH:	SKIPN	TBON		;TEST IF CHARGING ON
	  POPJ	P,		;  IF NOT JUST RETURN
	RDTIME	TBVALUE		;ELSE SAVE CURRENT VALUE OF TIME BASE
	SETZM	TBON		;FLAG THE CHARGING OFF
	POPJ	P,


TBVALUE::0			;CURRENT VALUE OF THE TIME BASE 
	 0			;LOWER HALF OF TIME BASE
TBON::	 0			;CHARGING FLAG, #0=ON, 0=OFF
>;END IFCPU (KS)
;TIMADJ ADJUSTS IN CORE COUNTS FOR A JOB.
;DESTROYS NO ACS.

DEFINE	DADDMT	(AC,HM,LM) 	; DOUBLE ADD TO MEMORY TABLE
<	ADDM AC,HM
	PUSH P,AC+1
	ADD AC+1,LM
	TLZE AC+1,400000
	 AOS HM
	MOVEM AC+1,LM
	POP P,AC+1>


TIMADJ::CAME J,JOB
	POPJ P,			;NOT THE ONE RUNNING
	PUSH P,T1
	PUSH P,T2
	CHGSTS	T2		;SO WE CAN REMEBER IF IT WAS ON
	NOCHARGE		;TURN CLOCK OFF.
IFCPU (KI),<
	DATAI CLK,T1
	HRL T1,TIMCNT		;AND THE OVERFLOWS
	SETZM TIMCNT		;RESET OVERFLOW COUNT
	DATAO CLK,[0]		;JUST TO MAKE SURE INTEVAL IS 2^18
	CONO CLK,CLKCDN+CLKCOV+CLKCLR ;START FRESH.
>;END IFCPU (KI)
IFCPU (F3),<
IF2, <PRINTX WHAT DO WE DO ON FOONLY FOR ACCOUNTING?>
	SETZ	T1,		;ZERO FOR NOW
>;END IFCPU (F3)
IFCPU (KL),<
	PUSH	P,T2		;SAVE CLOCK STATE
	RDMACT	T1		;MBOX (UPDATE %UPT+UPTHMC,LMC)
	RDEACT	T1		;EBOX (UPDATE %UPT+UPTHEC,LEC)
MAGIC1:	ASHC	T1,-^D3		; EBOX DIVIDER (8)
	DADD	T1,%UPT+UPTHMC	;GET EBOX COUNTS PLUS MBOX COUNTS
MAGIC:	ASHC	T1,-^D15	; EBOX+MBOX DIVIDER (2^15)
		; MCY = EBOX/2^18 + MBOX/2^15
	SETZM %UPT+UPTHEC
	SETZM %UPT+UPTLEC
	SETZM %UPT+UPTHMC
	SETZM %UPT+UPTLMC
	MOVE T1,T2		;SAVE LOW ORDER FOR LATER
	POP	P,T2		;GET CLOCK STATE BACK FROM STACK.
>;END IFCPU (KL)
IFCPU (KS),<
	PUSH	P,T2		;SAVE T2
	DMOVE	T1,TBVALUE	;GET ELAPSED TIME
	SETZM	TBVALUE		;CLEAR UPPER HALF OF TIME BASE
	SETZM	TBVALUE	+1	;CLEAR LOWER HALF OF TIME BASE
MAGIC:	ASHC	T1,-^D12	;LEFT ADJUST TIME BASE
	MOVE	T1,T2		;MOVE ELAPSED TIME TO T1
	POP	P,T2		;RESTORE CHGSTS TO T2
>;END IFCPU (KS)
	TRNE	T2,CHGON	;WAS CLOCK ON?
	CHARGE			;YES, TURN IT BACK ON.
	JUMPE J,NULTAJ		;DO NOT ACCUMULATE FOR NULJOB
	PUSH P,T1
	ADD T1,JBTCMP		;ACCUMULATE TOTAL
	TLZE T1,400000
	AOS JBTCP2
	MOVEM T1,JBTCMP
	MOVE T1,(P)
	ADD T1,JBTCMP(J)
	TLZE T1,400000
	AOS JBTCP2(J)
	MOVEM T1,JBTCMP(J)
	POP	P,T2		;
	PUSHJ	P,CHKMTM	;Adjust micro-cycle timer
	PUSHJ	P,GTCGSZ	;GET JOB CHARGING SIZE TO T1.
	PUSH	P,T1		;
	PUSH	P,T2		;
	MOVE	T1,T2		;
	MUL T1,-1(P)		;GET KILOCORE-MICROCYCLES
	ADD T2,JBTKCT
	TLZE T2,400000
	ADDI T1,1
	MOVEM T2,JBTKCT
	ADDM T1,JBTCPU
	POP P,T1
	POP P,T2		;GET SIZE OFF PDL
	MUL T1,T2		;THIS IS LIKE JBTKCT ONLY MORE SO
	ADD T2,JBTKCT(J)	;LOW ORDER PART
	TLZE T2,400000		;OVERFLOW?
	ADDI T1,1		;YES, ADD 1 TO HIGH ORDR
	MOVEM T2,JBTKCT(J)
	ADDM T1,JBTCPU(J)
NULTAJ:	POP P,T2
	POP P,T1
	POPJ P,

EXTERNAL JBTKCT,JBTCPU,JBTCMP,JBTCP2


; Here with incremental micro-cycles in T2 to update micro-cycle
; timer if one is set up, and to take trap if requested and
; timer runs out.
; Clobbers T1, preserves all other AC's.

	EXTERNAL UPTMTM
CHKMTM:	SKIPN	%UPT+UPTMTM	;Is there a micro-cycle timer set up?
	  POPJ	P,		;No, just return
	ADDM	T2,%UPT+UPTMTM	;Decrement timer by elapsed u-cycles
	SKIPGE	%UPT+UPTMTM	;See if timer ran out
	  POPJ	P,		;No, return
	SETZM	%UPT+UPTMTM	;Yes, turn it off before trapping
	LDB	T1,JBYMCY##	;Get u-cycle interrupt channel, if any
	PUSHJ	P,TAKTRP##	;If channel set up, take trap
	POPJ	P,		;Else just return
SUBTTL	RUNCSS - RUN CONTROL(STARTING AND STOPPING OF JOBS)

;RUN CONTROL IS A COLLECTION OF ROUTINES WHICH
;SET AND CLEAR BITS IN THE JOB STATUS WORDS OF
;ALL JOBS SO THAT THE SCHEDULER WILL START AND STOP
;THEM ACCORDINGLY

;COMMON ERROR STOPPING ROUTINES
;CALLED AT ANY LEVEL(M,CLK, OR INTERRUPT)
;CALL:	MOVE J,JOB CAUSING ERROR OR BEING STOPPED
;	MOVE F,ADRRESS OF THAT JOB TTY DEVICE DATA BLOCK
;	MOVE U,BYTE POINTER TO LAST CHAR. ALREADY MOVED
;			;TO TTY OUTPUT BUFFER
;	PUSHJ P,KSTOP,PHOLD,HOLD,OR ESTOP
;	NEVER RETURN IF CALLED AT UUO LEVEL

;ROUTINE TO STOP JOB AFTER KJOB COMMAND
;CALLED AT UUO LEVEL IF JOB HAD CORE,CLK LEVEL IF NOT

INTERNAL KSTOP,DECHJB
EXTERNAL HIGHJB

KSTOP:	SETOM	%UPT+UPTJOB	;SPECIAL KJOB FLAG
	MOVE T1,JSCLR		;CLEAR SPECIAL BITS IN JBTSTS
	ANDCAM T1,JBTSTS(J)
	PUSHJ P,CLRJBT		;CLEAR JOB TABLES
	PUSHJ P,DECHJB
	JRST ESTOP

JSCLR:	XWD JNA+JLOG+JACCT,JACCT2+KJP+WAKFLG+EXCFLG
				; "SPECIAL" JBTSTS BITS

				; IF THIS IS THE LARGEST JOB IN USE,FIND NEXT
				; HIGHEST AND SET HIGHJB
DECHJB:	CAMGE	J,HIGHJB	;IS THIS THE BIGGEST JOB NUMBER ASSIGNED?
	POPJ P,
	MOVSI	T2,JNA+CMWB+JRQ	;YES, LOOK FOR LAST JOB WITH
				;JOB NUMBER ASSIGNED BIT OR COMMAND WAIT BIT
	HRRZ	T1,J		;SCAN DOWNWARD
	TDNN	T2,JBTSTS(T1)	;ARE BITS SET FOR THIS JOB?
	SOJG	T1,.-1		;NO,KEEP LOOKING,FINISHED(TRUE IF THIS THE ONLY JOB
	MOVEM	T1,HIGHJB	;YES,STORE NEW HIGHEST JOB NUMBER ASSIGNED
	POPJ P,

CLRJBT::SETZM	JBTPRV##(J)
	SETZM	RTIME##(J)	;CLEAR INCREMENTAL JOB RUNNING TIME
	SETZM	JBTDLK##(J)
	SETZM	JBTERN##(J)
	SETZM	JBTSLK##(J)
	SETZM	JBTSER##(J)
	SETZM	JBTSIN##(J)
	SETZM	JBTSOT##(J)
	SETZM	JBTCIN##(J)
	SETZM	JBTCOT##(J)
	SETZM	JBTBIO##(J)
	SETZM	JBTBET##(J)
	SETZM	JBTELP##(J)
	SETZM	JBTCNK##(J)
	SETZM	JBTBCS##(J)
	SETZM	JBTSOK##(J)
	SETZM	JBTCP2##(J)	;CLEAR HIGH ORDER MICRO-CYCLE WORD
	SETZM	JBTCMP##(J)
	SETZM	JBTCPU##(J)
	SETZM	JBTKCT##(J)	;CLEAR CORE-RUNNING TIME PRODUCT CODE
	SETZM	JBTLIC##(J)
	SETZM	JBTLIM##(J)
	SETZM	JBTUNM##(J)
	SETZM	JBTUN1##(J)
	SETZM	JBTAUN##(J)
	SETZM	JBTRCT##(J)	;CLEAR NO. OF DISK BLOCKS READ BY JOB
	SETZM	JBTWCT##(J)	;CLEAR NO. OF DISK BLOCKS WRITTEN BY JOB
	SETZM	JBTMPC##(J)	;
	SETZM	JBTPWS##(J)	;
	SETZM	JBTPWH##(J)
	SETZM	JBTPWL##(J)
	SETZM	JBTPPN##(J)
	SETZM	JBTAJF##(J)
	SETZM	JBTFTR##(J)	;NO NEIGHBORS PARENTS OR CHILDREN.
	SETOM	JBTSPN##(J)	;SETUP SO NEVER MATCHES ANYTHING.
	SETZM	JBTS2P##(J)	;OUR RIGHTS OVER PARENT INITIALLY ZERO.
	SETZM	JBTPNO##(J)	;PROGRAM NUMBER ZERO.
	SETZM	JBTWCH##(J)	;Clear WATCH
	SETZM	JBTINA##(J)	;CLEAR INACTIVITY TIMEOUT WORD
	SETZM	JBTSTA##(J)	;Clear .USESTAT command word
	POPJ P,

EXTERNAL JOBN,FCONRQ,UNISEC,TPOPJ,TIMWAK,SWPSEC
;SUBROUTINE TO STOP JOB, BUT NOT SET ERROR BIT, PUT TTY IN COMMAND MODE
;AND START TTY

INTERNAL HOLD0

HOLD0:	PUSHJ	P,CRLF		;PRINT EXTRA CRLF AFTER EXIT MESSAGE
HOLD1::	PUSHJ P,PRRSP3		;PRINT CRLF, [XXX], CRLF, CRLF, DOT
	PUSHJ P,TTYSTC		;START TTY AND LEAVE IN MONITOR MODE
	PJRST STOP1		;STOP JOB BUT DO NOT SET ERROR BIT
				;SO JOB CAN CONTINUE
;ROUTINE TO STOP JOB, SET ERROR BIT AND PRINT MESSAGE
;THEN ADD ^C<CRLF><CRLF><PERIOD>
;CALL:	MOVEI T1,ADR. OF MESSAGE
;	PUSHJ P,PHOLD

INTERNAL PHOLD

PHOLD:	PUSHJ P,CONMES		;MOVE MESSAGE TO TTY OUTPUT BUFFER
				; FALL INTO HOLD
;ROUTINE TO STOP JOB, SET ERROR BIT,
;AND ADD "^C<CRLF><CRLF><PERIOD>

INTERNAL HOLD
EXTERNAL TTYSTC,PRRSP3,TTKJOB,CRLF,PRRSP1

HOLD:	PUSHJ P,PRRSP1		;PRINT CRLF, [XXX], CRLF, CRLF, DOT
	PUSHJ P,TTYSTC		;MAKE SURE TTY STAYS IN MONITOR MODE
KJSTOP::MOVSI T1,JLOG
	TDNN T1,JBTSTS(J)	;IS JOB LOGGED IN
	PUSHJ P,TTKJOB		;NO, MUST KILL JOB
				; AND START TTY TYPING OUT MESSAGE
				; FALL INTO ESTOP

;ROUTINE TO STOP USER AND FLAG AS ERROR STOP

INTERNAL ESTOP
EXTERNAL JBTSTS,CBJERR
EXTERNAL CPOPJ

ESTOP:	JUMPE J,CPOPJ		;IS THIS ERROR IN JOB 0?
	MOVSI T1,JACCT		;NO, CLEAR ACCOUNTING BIT(IN CASE LOGGING
	HRRI T1,JACCT2		;ALSO USER SETABLE BIT
	ANDCAM T1,JBTSTS(J)	;IN OR OUT) SO USER CAN USE CONTROL C
				; TO RECOVER
	MOVSI T1,JERR		;SET ERROR BIT IN JOB STATUS WORD
	IORM T1,JBTSTS(J)	;SO JOB CAN NOT CONTINUE(CONT COM.)
	PUSHJ	P,CBJERR	;RELEASE INTERLOCK IF IN A CLUB.
				;FALL INTO STOP1

;ROUTINE TO STOP ANY JOB FROM BEING SCHEDULED
;CALL:
;	MOVE J, JOB NUMBER
;	PUSHJ P, STOP1
;	EXIT	;RETURN HERE IMMEDIATELY, IF CALLED FROM HIGHER
;PRIORITY PI CHANNEL THAN CLK(LOWEST), OTHERWISE WHEN JOB IS RUNABLE
;CALLED FROM COMMAND DECODER WHEN <CONTROL>C TYPED IN BY USER
;OR ON ANY ERROR MESSAGE(SEE PREVIOUS PAGE)

INTERNAL STOP1
EXTERNAL PJBSTS,REQTAB,MAXQ,AVALTB,EPLLEN

STOP1:	MOVSI T1, RUN
	WRPI  LI.PIF		;DONE AT INTERUPT LEVEL HIGHER THAN DT LEVEL
	TDNN T1,JBTSTS(J)	;NO, IS RUN BIT OFF IN JOB STATUS WORD
	JRST STOP1A		;YES
	TLO T1,CNTRLC		;TURN OFF. "USER HAS TYPED ^C WHILE STILL IN EXEC MODE."
	ANDCAM T1,JBTSTS(J)	;NO, SO CLEAR IT
	WRPI  LI.PIN
	LDB T1,PJBSTS		;GET JOB WAIT QUEUE CODE(IF ANY)
	CAIG T1,MAXQ		;DOES STATE HAVE Q ?
	SOSL REQTAB(T1)		;YES. REDUCE IT.
	JRST STOP1A		;NO
	SOSGE AVALTB(T1)	;YES REDUCE  COUNT
	SETZM AVALTB(T1)	;CLEAR AVAL FLAG IF NO ONE WAITING
STOP1A:	WRPI  LI.PIN		;MAKE SURE PI ON
	SKIPGE	JBTPRV(J)	;check for LogoutOnStop (PV.LOS)
	  PUSHJ P,TTKJOB	; if set, kill frame
	CAME J, JOB		;NO, IS THIS JOB CURRENT USER
	JRST REQUE		;NO, SET REQUE JOB FLAG
	SKIPL T1,JBTSTS(J)	;YES, RUN FLAG OFF?
	TLNN	T1,JERR		;YES. ERROR FLAG ON?
	JRST	STOP2		;NO
	SETOM	SCHEDF		;YES, FORCE RESCHEDULING EVEN IF JOB IN EXEC MODE
	JRST STOP2		;YES, MAKE CLK RESCHEDULE ANOTHER JOB

;ROUTINE TO REQUE JOB WHICH HAS HAD A COMMAND TYPED
;WHICH NEEDS CORE AND THE CORE IMAGE IS ON THE DISK.
;OR IS IN CORE AND HAS ACTIVE DEVICES.
;CALLED FROM COMMAND DECODER
;CALL:	MOVE J,JOB NO.
;	PUSHJ P,DLYCOM

INTERNAL DLYCOM

DLYCOM:	MOVSI T1,CMWB		;SET COMMAND WAIT BIT
	TDNE	T1,JBTSTS(J)	;IS JOB ALREDY IN COMMAND WAIT?
	POPJ	P,		;YES,JUST EXIT
	IORM T1,JBTSTS(J)	;IN JOB STATUS WORD
	PJRST	REQUE

;ROUTINE TO PUT JOB IN NO CORE QUEUE

INTERNAL NOCORQ
EXTERNAL NULQ

NOCORQ:	MOVEI T1,NULQ		;NO JOB NO. OR NO CORE QUEUE
	DPB T1,PJBSTS
	JRST REQUE

;ROUTINE TO SETUP MONITOR JOB TO RUN LATER AT UUO LEVEL
;CALLED BY COMMANDS WHICH MAY OR MAY NOT NEED TO
;RUN MONITOR JOB DEPENDING ON WHETHER JOB HAS CORE(KJOB,IJOB)
;TTY WILL REMAIN IN MONITOR MODE
;JOB MUST HAVE CORE ASSIGNED
;CALL:	MOVE J, JOB NUMBER
;	MOVEI T2,ADDR. OF MONITOR JOB TO BE RUN
;	PUSHJ P,MONJOB
;WHEN SCHEDULED TO RUN, MONITOR JOB MUST SET UP ITS OWN ACS

INTERNAL MONJOB

MONJOB:	PUSHJ P,MSTART		;START WITH PC IN MONITOR
	JRST SETRUN		;SET TTY TO START JOB WHEN COMMAND RESPONSE
				; IS FINISHED AND KEEP TTY IN MONITOR MODE

;ROUTINE CALLED BY ONE FRAME TO SET UP A MONITOR JOB IN ANOTHER FRAME.
; CALL WITH T2 SET TO NEW PC, J CONTAINS FRAME NUMBER,
; %UPX CONTAINS C(J)'S CONTEXT PAGES.
; CALLER IS RESPONSIBLE FOR CHECKING
; THAT THE FRAME IS NOT ALREADY RUNNING.

MONJBX::PUSHJ	P,MXSTRT	;START WITH PC IN MONITOR
	PJRST	SETRUN		;AND MAKE SCHEDULER RUN HIM.

;ROUTINE TO SETUP ACS FOR MONITOR JOB STARTING AT UUO LEVEL
;SETS UP J, WITH JOB NO. AND P
;WITH PUSH DOWN LIST ADR. IN JOB DATA AREA
;USED BY KJOB,CORE 0,SAVE,GET,RUN,R,REASSIGN AND FINISH COMMANDS
;CALL:	MOVEI T2,MONITOR JOB STOP ADDRESS
;	JSP T1,MONSTR
;	RETURN WITH ACS P AND J SETUP

INTERNAL MONSTR

MONSTR:	MOVE J,JOB		;CURRENT JOB NUMBER
	MOVSI P,-EPLLEN		;MINUS LENGTH OF SYSTEM PD LIST
	HRRI P,%UPT+UPTPDL-1	;FIRST LOC.-1 OF PD LIST
	TLZ	T2,PC.USR+PC.PUB ;MAKE SURE THESE ARE OFF (ONLY FOR
				; SAKE OF THE SIMULATOR, WHICH RUNS IN USER MODE)
				; AND RUNJOB DOES JSP T2,
	PUSH P,T2		;SAVE STOP ADRRESS
	PUSH P,T1		;SAVE RETURN ADDRESS
	JRST CLRINT		;AND GO CLEAR INTERUPT SYSTEM
;ROUTINE TO SET JOB STATE TO BE SCHEDULED TO RUN
;WITH SPECIFIED STARTING ADDRESS INCLUDING PC FLAGS
;CALLED ONLY WHEN JOB IN CORE AND AFTER JOB HAS BEEN
;SAFELY STOPPED IN ONE OF 3 STATES:
;1) PC IN USER MODE
;2) JOB IN A WAIT FOR SHARABLE DEVICE, OR IO WAIT
;3) JOB JUST ABOUT TO RETURN TO USER MODE FROM A UUO CALL
;CALL:	MOVE T2,STARTING PC
;	MOVE T1,OLD PC
;	MOVE J, JOB NUMBER
;	MOVE R,ADR. OF JOB DATA AREA WHICH MUST BE IN CORE
;	PUSHJ P,USTART(PC TO USER MODE),MSTART(PC TO MONITOR MODE)
;	RETURN HERE IMMEDIATELY

INTERNAL MSTART,USTART
EXTERNAL TTYSET,TYCIOS,UPTACP,USRXIT,MAPUPS
EXTERNAL CLRINT,%UPX

USTART:
	TLNE T1,PC.USR		;IS IT IN USER MODE TOO?
	JRST USTRT1		;YES.
	MOVE T1,%UPT+UPTPDL	;M PC HAS LAST PC
	HRRI T1,-1(T1)		;SUBTRACT 1 FROM RIGHT HALF AND
				; PRESERVE LH PC FLAGS.
				; (RH=0 ON HALT 0 OR FIRST START)
USTRT1:	UMOVEM T1,JOBOPC	;STORE OLD PC FOR USER TO LOOK AT
	HLL T2,T1		;PRESERVE USER APR FLAGS
	TLO T2,PC.USR!PC.PUB	;MAKE SURE NEW PC IN USER MODE
	TLZ T2,37!PC.UIO	;MAKE SURE NO INDIRECT BITS OR INDEX FIELD
	PUSH P,T2		;STARTING PC
	JRST USRXIT

MSTART:	PUSHJ	P,MAPUPS	;SET UP EXEC MAP.
	HRLI	T2,PC.UIO	;MAKE SURE PC IS EXEC MODE, IOT USER.
	MOVEM	T2,%UPS+UPTPC	;SAVE NEW PC
	MOVE T1,UPT+UPTACP	;RESET AC POINTER ON START
	MOVEM T1,%UPS+UPTACP
	MOVSI T1,UPSCLK		;CLOCK MUST RUN DURING MONJOB
	IORM T1,%UPS+UPTSTS
	MOVEI T1,UTRP		;CLEAR "TRAP" BIT FOR REE, DDT, ETC. AND
	HRLI T1,JERR+WTMASK+CNTRLC;CLEAR JOB ERR,WAIT CODE, TYPED ^C FLAG
	ANDCAM T1,JBTSTS(J)	;CLEAR ERROR AND WAIT STATUS BITS
	PUSHJ P,TYCIOS		;CLEAR IOW ON ALL TTY AND RMT DEVICES
	JRST TTYSET		;SET TTY STATE TO INITIAL COND.
				; TTYUSR OR TTYURC SHOULD BE CALLED
				; TO INDICATE WHETHER TTY TO USER OR EXEC MODE
				; AND THAT JOB IS TO RUN(RUN BIT =1) WHEN
				; MONITOR COMMAND RESPONSE FINISHES.
				; SEE SETRUN BELOW

MXSTRT:	HRLI	T2,PC.UIO	;MAKE SURE PC IS EXEC MODE, IOT USER.
	MOVEM	T2,%UPX+UPTPC	;SET THE PC
	MOVE	T1,UPT+UPTACP	;SETUP AC STACK POINTER AGAIN
	MOVEM	T1,%UPX+UPTACP
	MOVSI	T1,UPSCLK	;INITIAL STATE IS CLOCK RUNNING
	IORM	T1,%UPX+UPTSTS
	MOVE	T1,[JERR+WTMASK+CNTRLC,,UTRP]
	ANDCAM	T1,JBTSTS(J)
	PJRST	TYCIOS		;DON'T CALL TTYSET, MAY NOT BE A LINE


;ROUTINE TO SET JOB STATUS RUN BIT(RUN)
;CALLED BY SCANNER SERVICE WHEN TTY MONITOR COMMAND
;RESPONSE FINISHES.  THIS ACTION IS ENABLED BY CALLING
;TTYUSR, OR TTYURC IN SCNSER
;CALL:	MOVE J,JOB NUMBER
;	PUSHJ P,SETRUN

INTERNAL SETRUN,SETR2
EXTERNAL RNQUNT,JBYQNT,CBCONT,ILWQ

SETRUN:	LDB T1,PJBSTS		;GET JOB STATUS WAIT QUEUE CODE
	CAIN	T1,ILWQ		;SPECIAL CHECK
	PUSHJ	P,CBCONT	;FOR CLUBS.
	CAILE T1,MAXQ		;DOES JOB STATUS CODE HAVE A QUEUE?
	JRST SETR1		;NO
	AOSLE REQTAB(T1)	;ADD TO REQUEST COUNT
	JRST SETR1		;OTHERS WAITING?
	AOSG AVALTB(T1)		;MAKE AVAILABLE
	SETOM AVALTB(T1)	;FLAG AS JUST AVAILABLE, BECAUSE
				; NO JOB WAS USING DEVICE. SCHEDULER
				; WILL SCAN THIS QUEUE
SETR1:	MOVSI T1,RUN		;SET RUN BIT IN JOB STATUS WORD
	IORM T1,JBTSTS(J)
SETR2:	MOVE T1,@RNQUNT		;SET QUANTUM TIME TO RUN QUEUE QUANTUM
	DPB T1,JBYQNT		;RUN QUEUE QUANTUM

INTERNAL REQUE
EXTERNAL QJOB
;PRESERVES ALL BUT T1

REQUE:	
	EXTERN	WRSMAP		;/WRS
	PUSHJ	P,WRSMAP	;/WRS 
	MOVSI 	T1,JRQ		;MARK JOB TO BE REQUEUED WITH JRQ BIT
	TDNN 	T1,JBTSTS(J)	;INCREMENT COUNT ONLY ONCE FOR EACH JOB
	AOS 	QJOB		;INCREMENT COUNT OF NO. OF JOBS WAITING TO BE REQUEUED
	IORM 	T1,JBTSTS(J)	;SET REQUE BIT FOR SCHEDULER
	POPJ 	P,

;ROUTINE TO PUT A JOB TO SLEEP AND WAKE UP AGAIN LATER
;CALLED AFTER CLOCK QUEUE REQUEST PUT IN BY UUO ROUTINE

INTERNAL SETSLP
EXTERNAL SLPQ

SETSLP:	MOVEI 16,SLPQ		;SLEEP STATE CODE
	JRST SETSTT		;SET STATUS AND RESCHEDULE

;HERE AT CLOCK LEVEL WHEN CLOCK REQUEST TIMES OUT FOR SLEEP
;JOB NO. IN AC T1

INTERNAL WAKE
EXTERNAL RNQ,TTSCLR

WAKE:	MOVE J,T1		;JOB NO.
	PUSHJ P,TTSCLR		;CLEAR TTY SLEEP CONDITIONS
	LDB T1,PJBSTS		;GET QUEUE CODE
	CAIE T1,SLPQ		;IS JOB STILL SLEEPING?
	POPJ P,			;NO. RETURN TO CLOCK ROUTINE
	MOVEI T2,RNQ		;READY TO SET IN RUN Q
	DPB T2,PJBSTS		;YES, STORE RUN QUEUE CODE
				; (CONTROL C, START CAN GET JOB OUT OF SLEEP)
	JRST SETR2

;ROUTINE TO CHANGE A CLOCK REQUEST. SEARCH FOR ONE WITH SAME
;JOB AND TYPE. IF FOUND CHANGE IT (IF TIME=0 DELETE). IF NOT FOUND
;INSERT ONE

CHGCLK:	LDB T3,[POINT 12,T1,18]	;GET JOB NUMBER AND TYPE
	PUSH P,T1
	HRRZ T2,CLOCK
CHGCK1:	CAIN T2,CIPWTM
	JRST CLKADD		;NOT THERE, INSERT
	LDB T1,[POINT 12,(T2),18]
	CAME T1,T3
	SOJA T2,CHGCK1		;NOT CORRECT JOB OR TYPE
	POP P,T1
	TRNN T1,377777		;IS TIME 0?
	JRST CLKDEL		;YES, DELETE OLD REQ
	MOVEM T1,(T2)		;JUST CHANGE REQUEST
	POPJ P,

CLKDEL:	WRPI LI.PIF
	MOVE T1,@CLOCK
	SOS CLOCK
	MOVEM T1,(T2)
	WRPI LI.PIN
	POPJ P,

CLKADD:	POP P,T1
	TRNN T1,377777
	POPJ P,			;TIME=0, DO NOT ADD
	WRPI LI.PIF
	IDPB T1,CLOCK
	WRPI LI.PIN
	POPJ P,

CLKJOB:	POINT	7,T1,18		;Byte pointer to set job/frame # into
				; arg for CHGCLK call
;; Clock queue args for setting/resetting hung DDB timer (SCNSER/COMCON)
TIMSET:	BYTE (1) 1 (6) .SLHNG (5) 3 (7) 0 (1) 0 (16) ^D900
TIMRST:	BYTE (1) 0 (6) 0      (5) 3 (7) 0 (1) 0 (16) 0

INTERNAL CHGCLK,CLKJOB,TIMSET,TIMRST

;ROUTINE TO WAIT FOR A SHARABLE DEVICE
;CALLED AT UUO LEVEL ONLY BY DEVICE SERVICE ROUTINES
;CALL:	AOSLE XXREQ		;ADD 1 TO SHARABLE DEVICE REQUEST COUNT
;				;IS DEVICE AVAILABLE?
;	PUSHJ P,XXWAIT	;NO, PUT JOB IN WAIT QUEUE
;	RETURN WHEN DEVICE AVAILABLE

;INITIALLY THE REQUEST COUNT IS -N, WHERE N IS THE
;NUMBER OF JOBS WHICH CAN USE THE SHARABLE DEVICE AT THE SAME TIME
;A REQUEST COUNT OF 0 MEANS THE MAXIMUM NO. OF JOBS ARE
;USING THE DEVICE, A POSITIVE NUMBER IS THE
;NUMBER OF JOBS WAITING IN THE SHARABLE DEVICE WAIT QUEUE
;NUMERIC ACS  16 AND 17 ARE PRESERVED SINCE THE NEW AC CONVENTION DEPENDS
;ON THEM BEING SAVED. NUMERIC ACS ARE USED RATHER THAN SYMBOLIC SO THAT
;THE PROPER ACS WILL BE SAVED IN THE DUMP ACS EVEN IF THE SYMBOLIC AC 
;VALUES ARE CHANGED

INTERNAL	SIWAIT,	RIWAIT,	MTWAIT,	DAWAIT,	PRWAIT,	PSWAIT
INTERNAL	M2WAIT,	CBWAIT,	CAWAIT,	AXWAIT,	BPWAIT
INTERNAL	FCWAIT,	ACWAIT
EXTERNAL CNTTAB

SIWAIT:	RIWAIT:	MTWAIT:	DAWAIT:	PRWAIT:	PSWAIT:
M2WAIT:	CBWAIT:	CAWAIT:	AXWAIT:	BPWAIT:
FCWAIT:	ACWAIT:
DVWAIT:	MOVEM 16,%UPT+UPTXAC+16	;SAVE AC16 (SINCE IT IS A PRESERVED AC)
	MOVE 16,(P)		;GET ADR. OF CALLER
	MOVE 16,-2(16)		;GET AOSLE XXREQ INSTRUCTION
	SUBI 16,REQTAB		;COMPUTE WAIT-STATE QUEUE CODE
	AOS CNTTAB(16)		;COUNT TIMES WAITED FOR QUE
	MOVEM 17,%UPT+UPTXAC+17	;SAVE AC17
SETSTT:	MOVE 17,JOB		;CURRENT JOB NO.
	DPB 16,PJBS3		;STORE IN JOB STATUS WORD
	MOVE 16,%UPT+UPTXAC+16	;RESTORE AC16
	JRST WSCHD1		;GO SCHEDULE ANOTHER AND RETURN TO CALLER
				; WHEN SHARABLE DEVICE BECOMES AVAILABLE
				; SEE CLOCK AND CLKCSS

PJBS1:	POINT JWSIZ,JBTSTS(P3),JWPOS ;BYTE POINTER TO JOB STATUS
				; WORD WAIT QUEUE CODE
PJBS3:	POINT JWSIZ,JBTSTS(17),JWPOS

;ROUTINE TO SET JOB TO RUN AFTER IT HAS BEEN STOPPED
;BECAUSE IT HAD TO WAIT FOR IO TO COMPLETE FOR SOME DEVICE
;EACH SERVICE ROUTINE AT INTERRUPT LEVEL
;CHECK EACH TIME IT FINISHED A TASK(BUFFERFUL)
;TO SEE IF THE JOB USING THE DEVICE HAS
;PREVIOUSLY CAUGHT UP WITH DEVICE AND HAS BEEN STOPPED
;CALL:	MOVE F,ADR. OF DEVICE DATA BLOCK
;	MOVE S,DEVIOS(F)	;GET DEVICE IO STATUS WORD FROM DDB
;	TLZE S,IOW	;IS JOB IN AN IO WAIT FOR THIS DEVICE?
;	PUSHJ P,SETIOD	;YES, GO FLAG JOB TO START UP AGAIN
;	RETURN
;SETS THE JOB QUEUE WAIT CODE TO WSQ IN JOB STATUS WORD.
;THE SCHEDULER THEN SEES THAT THIS JOB HAS ITS
;IO WAIT SATISFIED AND IS WAITING TO BE RUN AGAIN

INTERNAL SETIOD
EXTERNAL WSQ,WSAVAL,TSQ,TSAVAL,PJOBN,SWQ
INTERNAL	STTIOD

PJBS2:	POINT JWSIZ,JBTSTS(T1),JWPOS ;LIKE PJBSTS BUT USES T1,NOT J

STTIOD:	LDB T1,PJOBN
	LDB T2,PJBS2
	CAIN T2,SWQ
	STOPCD
	MOVEI T2,TSQ	;PUT IN TTY IOWAIT SATISFIED QUEUE
	AOS TSAVAL
	JRST SETID1

SETIOD:	LDB T1,PJOBN
	LDB T2,PJBS2	;HIS CURRENT WAIT CODE
	CAIN T2,SWQ
	STOPCD
	MOVEI T2,WSQ	;PUT IN IO WAIT SATISFIED QUEUE
	AOS WSAVAL		;INCR. NO. OF JOBS WITH IO WAIT! 
				; SATISFIED. NON-ZERO WSAVAL WILL
				; CAUSE SCHED. TO SCAN FOR IO
				; SATISFIED JOB.
SETID1:	
	DPB T2,PJBS2		;IN JOB STATUS WORD
	EXTERN	WRSMP1		;/WRS
	PUSH	P,J		;/WRS
	MOVE	J,T1		;/WRS
	PUSHJ	P,WRSMP1	;/WRS - include even if no change
	POP	P,J		;/WRS
	MOVSI T2,JRQ		;SET JOB TO BE REQUEUED AT NEXT CLOCK TICK
	TDNN T2,JBTSTS(T1)	;IS REQUE BIT ALREADY ON?
	AOS QJOB		;NO, INCREMENT COUNT ONCE FOR EACH JOB
	IORM T2,JBTSTS(T1)	;SET REQUEUEING BIT FOR SCHEDULER
	SKIPE JOB		;IS NULL JOB RUNNING?
	POPJ P,			;NO LET OTHER JOB RUN TILL SCHEDULER IS TRAPPPED TO

;ROUTINE TO CAUSE CLK ROUTINE TO RESCHEDULE
;CALLED AT ANY LEVEL
;CALL:	PUSHJ P,STOP2	
;	RETURN IMMEDIATELY EXCEPT IF AT UUO LEVEL
;	IF AT UUO LEVEL, RETURN WHEN JOB IS RUNABLE AGAIN

EXTERNAL PICLK

STOP2:	WRPI LI.PIF		;PREVENT CLOCK INTERRUPT DURING STOP2 CODE
	SETOM CLKFLG		;SET FLAG TO INDICATE CLK INTERRUPT
				; EVEN THOUGH CLK INTERRUPT IS NOT A TIME INTERRUPT
	WRPI PICLK		;TURN PI BACK ON AND REQUEST INTERRUPT TO
				; CLK PI CHANNEL(LOWEST PRIORITY CHANNEL)
	CONSZ PI,177B27		;ANY INTERUPTS IN PROGRESS?
	POPJ P,			;YES, EXIT IMMEDIATELY
	PUSH P,T1
STOP3:	RDPI T1		;READ STATUS OF PI
	TLNE T1,CLKBIT		;IS THERE A REQUEST WAITING ON CH7?
	JRST STOP3		;YES, WAIT FOR IT TO HAPPEN
	JRST TPOPJ		;NO, EXIT

;ROUTINE TO WAIT TILL DEVICE CATCHES UP WITH USER AND BECOMES INACTIVE
;CALLING SEQUENCE
;     PUSHJ P, WAIT1
;     EXIT	  ALWAYS RETURNS HERE
 
;IF THE DEVICE IS INACTIVE (IOACT=0), RETURNS TO EXIT. OTHERWISE, SETS
;IOW:=1 AND ENTERS WAIT UNLESS IOACT BECOMES ZERO BEFORE THE
;JUMP IS MADE, IN WHICH CASE IT SETS IOW:=0 AND RETURNS TO EXIT.
;ON LEAVING THE WAIT STATE, RETURNS TO EXIT.
;WAIT1 DESTROYS S, P1, P2, AND P3.  ALL OTHER ACS ARE SAFE.
;THIS ROUTINE PREVENTS THE STATE IOACT=0 AND IOW=1 FROM OCCURING
;CALLING SEQUENCE
;     PUSHJ P, WSYNC
;     EXIT             ALWAYS RETURNS HERE
;SETS IOW:=1 AND ENTERS WAIT ROUTINE. RETURNS TO EXIT WHEN IOACT=0.

INTERNAL WAIT1

WAIT1:	MOVE S,DEVIOS(F)
	TRNN S, IOACT		;IS DEVICE ACTIVE? (IOACT=1?)
	POPJ P,			;RETURN
	PUSHJ P,WSYNC		;WAIT
	JRST WAIT1


;WSYNC IS CALLED TO WAIT UNTIL SETIOD IS CALLED BY INTERRUPT SERVICE ROUTINE
;IE  UNTIL CURRENT BUFFER ACTIVITY IS COMPLETED
;CALLED ONLY FROM UUO LEVEL
;CALL:	MOVE F,ADR. OF DEVICE DATA BLOCK
;	PUSHJ P,WSYNC
;	RETURN IMMEDIATELY IF DEVICE IS INACTIVE
;	RETURN WHEN DEVICE FINISHES NEXT BUFFER IF IT IS ACTIVE
;WSYNC DESTROYS S, P1, P2, AND P3.  ALL OTHER ACS ARE SAFE.

INTERNAL WSYNC
EXTERNAL IOWQ,TIOWQ,MBWQ,DEYCLS,ERRHDV

WSYNC:	MOVSI S,IOW		;SETUP DEVICE IO WAIT BIT
	LDB P3,DEYCLS		;DEVICE CLASS CODE
	MOVE P1,CLSQUE(P3)	;GET QUE FOR THIS CLASS

	MOVE P3,JOB		;CURRENT JOB NO.
	MOVEI P2,IOACT		;DEVICE ACTIVE BIT
	WRPI  LI.PIF		;TURN PI OFF
	TDNN P2,DEVIOS(F)	;IS THE DEVICE ACTIVE?
	JRST WSYNC1		;NO
	IORM S,DEVIOS(F)	;YES, SET DEVICE IO-WAIT BIT
				; AND SETUP S FOR RETURN WHEN WAIT SATISFIED
	MOVSI P2,IOHNG		;CLEAR HUNG BIT
	ANDCAM	P2,DEVIOS(F)
	DPB P1,PJBS1		;SET JOB WAIT STATE CODE
				; IN JOB STATUS WORD
	WRPI  LI.PIN		;TURN PI ON
	PUSHJ P,WSCHED		;CALL SCHEDULER TO FIN ANOTHER JOB TO RUN
				; RETURN WHEN NEXT BUFFERFUL IS FINISHED
				; WITH ACS 0-14 OCTAL RESTORED
				; RETURN WHEN IO-WAIT FINISHED
WSYNC1:	WRPI  LI.PIN
	ANDCAB S, DEVIOS(F)	;CLEAR DEVICE IO-WAIT BIT
	TLZN	S,IOHNG		;DID DEVICE TIME OUT?
	POPJ P,
	ANDCAM P2,DEVIOS(F)	;CLEAR HUNG BIT AND
	JRST	ERRHDV		;CALL ERRCON TO EXIT THE JOB.

CLSQUE:	EXP 	MBWQ,TIOWQ,0,IOWQ
	LIT

	END
   gù