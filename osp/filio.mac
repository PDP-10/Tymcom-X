TITLE	FILIO	DISK SERVICE ROUTINE

	ENTRY FILIO
FILIO:


IOSUPR==100000	;SUPER USETI/USETO DONE ON THIS CHAN


;THE FOLLOWING S BITS ARE DEFINED IN COMMON.MOD
;BECAUSE THEY WANT TO BE IN THE SAME POSITION IN S AS IN RIB STATUS WORD
;IOSHRE==100	;HARD READ ERROR ENCOUNTERED
;IOSHWE==200	;HARD WRITE ERROR ENCOUNTERED
;IOSSCE==400	;SOFTWARE CHECKSUM ERROR ENCOUNTERED
;IOSERR==IOSHRE+IOSHWE+IOSSCE
;IOSMER==-IOSERR
DEFINE DSKOFF <WRPI DSKPIF>
DEFINE DSKON <WRPI DSKPIN>

INTERN FILINT
INTERN RRSETB

EXTERN ALR620,BLKLSH,BLKSPP,CPOPJ,CPOPJ1,DEVBLK,DSKPIF,DSKPIN
EXTERN GETOPR,INLMES,IOSHRE,IOSHWE,PRNAME
EXTERN PTNUNI,PTSUNI,PWAIT1
EXTERN REMLST,SATONC,SYSUNI,UNTTBL,PIOMOD

EXTERN PGYPNO,PGYFPL,PGYBPL,PGYSTS,PGPDER,PGPDTE,PGYSIO,PGYADR
EXTERN PGYDRT,PGYUNI
IFCPU (KL),<EXTERN PGYCSH>

EXTERN RBYUNI,RBYPNO,RBREAL,RBINDX,RBSPAR


EXTERN KONPOS,KONRED,KONWRT,KONRCL,KONSTP,KONCPY
EXTERN KONCHN,KONLTM,KONPTR,KONADD,KONFIN
EXTERNAL KONOFS,KONHRD,KONSFT

EXTERN UNISTS,UNICHN,UNIBLK,UNICYL,UNPOFL
EXTERN UNISTT,UNIERR,UNYPGL,UNYPAC,UNYPPL
EXTERN UNIKON,UNYPPY,UNISTR,UNITAL,UNISYS
EXTERN UNIDES,UNINAM,UNIPPU,UNYLUN,UNISOF,UNIHBN
EXTERN UNIBRC,UNIDRC,UNIMSC,UNIUSC,UNISBN,UNIICT,UNIBWC,UNIDWC
EXTERN UNIHCT,UNISCT
EXTERN UNIHNG,UNISDI,UNIECT,UNIRCT,UNIRC1,UNPRRS
EXTERN UNIHDI,UNPFUS,UNIDIR,UNIFCT,UNYTIM
EXTERN UNICDA,UNYRCL,UNYRRT,UNYRTY,UNPDEV,UNYOCV,UNYRTO,UNYRCO


EXTERN KCMOFL,KCMFUS,KCMRER,KCMERR,KCMDTA,KCMIOS,KCMPOS

EXTERN LSTLST,PGYPNO,PGYLST,PGYSOP,SID.N,SOD.N,SPR.N,%UPT
EXTERN MAXPCB,FINPCB,MINPCB,MEMSZP
EXTERN PICLK,JOB,CLKFLG

EXTERN ADRDUM

IFCPU (KL),<EXTERN CSUCNT,CSVCNT,CSHSAV>

EXTERN CTLFND,PGYLMA,%SAT.C

EXTERN SLOCLE
REPEAT	0,<
NOTE ABOUT STATES OF CHANNELS, KONTROLLERS, UNITS, FILES:

			C	J	U	F
IDLE		I	I	I	I	I
SEEK WAIT	SW			SW
SEEK		S			S
POSITION WAIT	PW			PW	PW
POSITION	P			P	P
TRANSFER WAIT	TW			TW	TW
TRANSFER(BUSY)	T1 OR B	B	B	T1	T1

NOTE ABOUT QUEUES:
THERE ARE 2 QUEUES OF FILES
	SW/PW QUEUE FOR EACH UNIT
	TW QUEUE FOR CHANNEL
A FILE IS ONE AND ONLY ONE OF THE FOLLOWING CONDITIONS:WITH RESPECT TO QUEUES
	A.THE ONLY FILE IN SW/PW QUEUE FOR A UNIT (UNIT IN SW STATE)
	B.ONE OF PERHAPS MANY FILES IN PW QUEUE FOR A UNIT(UNIT IN PW,P,TW,OR T1 STATE)
	C.ONE OF PERHAPS MANY IN TW QUEUE FOR CHANNEL(CHAN AND KONTROL IN B STATE)
	D.NONE OF THE ABOVE (FILE IN I,P, OR T1 STATE)

NOTE:	#MEANS INSTRUCTION IS EXECUTED WITH ALL DISK PI CHANNELS OFF
	%MEANS INSTRUCTION IS EXECUTED WHILE JOB HAS CB RESOURCE
	*MEANS INSTRUCTION MAY BE EXECUTED AT INTERRUPT LEVEL
	(TO SAVE TYPING USED ONLY FOR INSTRUCTIONS NOT IN INTERRUPT MODULE ITSELF)

THE FOLLOWING TECO MACRO WILL PRODUCE A LISTING OF ONLY THE SUBROUTINE
NAMES AND COMMENTS PRIOR TO THEM:
ERDEV1:FILIO.MAC$EWDEV2:FILIO.SUB$
<_;SUBROUT$;0L.U1  !NTST! :S:$"GA ONTST$'.U20L1A-59"E LONTST$' Q2JI

$Q1,.PW 0,.K>EF

>

SUBTTL UUO LEVEL MODULE
;UUO LEVEL IO(F ALREADY SET TO DDB FOR FILE DOING IO)

;HERE TO START A SEEK
UUOSEK::PUSHJ	P,SEKPTR	;GET POINTER TO NEXT BLOCK.
	  POPJ	P,		;CAN'T DO IT.
	SKIPL	KONPOS(J)	;DOES CONTROLLER POSITION?
	SKIPE	T1,UNISTS(U)	;YES. IS UNIT IDLE?
	POPJ	P,		;NO. IGNORE SEEK REQUEST
	DSKOFF			;SINCE WE ARE DIDDLING QUEUES
	DPB T1,UNYPAC		;ALSO PAGE POINTER (0 FROM ABOVE)
	MOVEM T2,UNIBLK(U)
	LDB	T3,UNYPPY	;SEE IF A SEEK NEEDS TO BE DONE.
	LSH	T3,2		;
	IDIV T2,T3
	CAMN T2,UNICYL(U)	;ALREADY ON CYL?
	PJRST ONPOPJ		;YES, TURN ON PI AND GO
	MOVEI T1,SWCOD	;SET TO SEEK WAIT
	MOVEM T1,UNISTS(U)
	SKIPL KONLTM(J)
	JRST	UUOSK1	;GO DO I/O SEL OPERATION
	MOVEI T1,SCOD
	MOVEM T1,UNISTS(U)	;CHAN NOT REQUIRED, START SEEK
	AOS UNIUSC(U)	;COUNT SEEK
	PUSHJ P,@KONPOS(J)
ONPOPJ:	DSKON
	POPJ P,

UUOSK1:	PUSH	P,F	;SAVE F FROM IOSEL
	PUSHJ	P,IOSEL
	POP	P,F
	JRST	ONPOPJ	;Turn on PI and go


;ROUTINE TO GET NEXT BLOCK FOR SEEK.
; CALL WITH DEVPOS(F) POINTING TO NEXT BLOCK,
; RETURNS WITH T2 NEXT ABSOLUTE BLOCK ON DISK,
; U AND J SETUP WITH UDB AND KDB. SKIP IF SUCCESSFUL.

EXTERNAL USETST,BLKSPP,ATYBSZ,RBMASK,RELRIB,UNLFIL,RBYUNI
EXTERNAL DEVSUP,STRDDB,STRPPU,STRUNI,DEVPOS,DEVATB,DEVRET
EXTERNAL LOKUNM

SEKPTR:	MOVE	M,DEVPOS(F)	;GET NEXT BLOCK
	TLZ	M,(1B0)		;CLEAR POSSIBLE CHANGE FLAG.
	TLNE	S,IOSUPR	;SUPER I/O?
	JRST	SEKPTS		;YES, DO IT DIFFERENTLY

	HRRZ	T2,DEVATB(F)	;GET ATB
	JUMPE	T2,CPOPJ	;CAN'T DO IT IF NO FILE.
	LDB	T1,ATYBSZ	;GET SIZE IN BLOCKS
	CAMLE	M,T1		;EOF?
	POPJ	P,		;YES, CAN'T DO IT.
	ADDI	M,3		;ROUND UP TO NEAREST PAGE.
	LSH	M,-BLKSPP	;CONVERT TO PAGES FOR USETST
	JUMPE	M,CPOPJ		;BETTER NOT BE PAGE 0
	PUSHJ	P,LOKUNM	;LOCK FILE UNMODIFIED.
	PUSHJ	P,USETST	;SETUP DEVRET
	  JRST	[MOVEM S,DEVIOS(F) ;STORE STATUS
		POPJ P,]
	MOVE	T2,@DEVRET(F)	;GET POINTER WE WORKED SO HARD FOR
	PUSH	P,T2		;SAVE T2 FROM THESE GUYS
	PUSHJ	P,RELRIB
	PUSHJ	P,UNLFIL	;RELEASE RIB AND FILE
	POP	P,T2		;RESTORE T2.
	TLNN	T2,RBREAL	;IS NEXT THING A HOLE?
	POPJ	P,		;YES, ALL THAT FOR NOTHING.
	LDB	U,RBYUNI	;GET UNIT NUMBER
	MOVE	U,UNTTBL(U)	;GET UDB ADDRESS
	TLZ	T2,RBMASK	;GET RID OF XTRA BITS
	LSH	T2,BLKSPP	;CONVERT TO BLOCK
				;(ALWAYS OK TO POSITION TO 1ST BLOCK OF PAGE.)
	JRST	SEKPT1		;RETURN WITH T2, U AND J SETUP.

;HERE IF IT WAS SUPER I/O

SEKPTS:	MOVE	T2,M		;IN CASE ITS A UNIT
	HRRZ	U,DEVSUP(F)	;MAYBE HE INITED UNIT
	JUMPN	U,SEKPT1	;IF SO, JUST USE DEVPOS
	MOVE	T1,M		;NO, MUST COMPUTE BLOCK WITHING UNIT
	LSH	T1,-BLKSPP	;CONVERT TO PAGES
	IDIV	T1,STRDDB+STRPPU ;GET UNIT # IN T1, PAGE # IN T2
	LSH	T2,BLKSPP	;CONVERT BACK TO BLOCKS.
	MOVEI	U,STRDDB+STRUNI-UNISTR ;START WITH THIS
	HLRZ	U,UNISTR(U)	;GET NEXT UNIT IN STR
	SOJGE	T1,.-1		;KEEP GOING TILL GET THE RIGHT ONE
SEKPT1:	MOVE	J,UNIKON(U)	;GET KDB ADDRESS
	JRST	CPOPJ1		;AND RETURN.

;HERE FOR READ AND RESET BUFFERED LOG

RRSETB:	DSKOFF
	SKIPE UNISTS(U)	;IS UNIT DOING ANYTHING?
	JRST RRSETF		;YES, JUST FLAG FOR RESET
	MOVEI T1,RSCOD		;NO, FLAG THE OPERATION
	MOVEM T1,UNISTS(U)
	PUSHJ P,SETTIM
	PUSHJ P,@KONLTM(J)	;LATENCY ROUTINE FOR THIS
	DSKON
	JRST CPOPJ1

RRSETF:	MOVSI T1,UNPRRS
	IORM T1,UNIDES(U)	;UNIT CURRENTLY BUSY, FLAG FOR LATER
	DSKON
	JRST CPOPJ1

	SUBTTL	FILINT  - INTERRUPT HANDLING MODULE

COMMENT !
CALLED FROM DEVICE DEPENDENT INTERUPT ROUTINE
T3 CONTAINS THE DATAI FROM THE DEVICE
T2 CONTAINS THE CONI FROM THE DEVICE
T1 IS THE COMUNICATIONS WORD
  BITS 0-7 ARE THE POSITION (ATTENTION) BITS
  KCMOFL SAYS THAT THE UNIT IS OFF-LINE
  KCMRER SAYS THAT THERE WAS A RECOVERED DATA ERROR
  KCMFUS SAYS FIL-UNSAFE
  KCMERR SAYS ERROR OCCURED ON THIS DATA TRANSFER
  KCMDTA SAYS A DATA TRANSFER INTERUPT
  KCMIOS (BIT NOT SET BY INTERUPT ROUTINES) I/O SELECT NEEDED
  BITS 18-35 CONTAIN THE NUMBER OF BLOCKS (128 WORDS) TRANSFERED
U AND J HAVE BEEN SET UP BY THE DEVICE DEPENDENT ROUTINES
!

FILINT:	PUSH P,T3
	PUSH P,T2
	PUSH P,T1
	TLNE T1,KCMOFL!KCMFUS
	PUSHJ P,SETOFL	;SET UNIT OFF-LINE
	TLNE T1,776000!KCMPOS
	PUSHJ P,POSSAT	;POSITION INTERUPT
	TLNE T1,KCMRER
	PUSHJ P,ERRRCV	;RECOVERED ERROR
	TLNE T1,KCMDTA
	PUSHJ P,DTASAT	;DATA TRANSFER COMPLETED (ERROR POSSIBLE)
	TLNE T1,KCMIOS
	PUSHJ P,IOSEL
	POP P,T1
	POP P,T2
	POP P,T3
	POPJ P,

SETOFL:	MOVE T2,UNISTS(U)
	CAIN T2,CCOD
	JRST CPYOFL
	CAIE T2,TCOD	;WAS THIS UNIT IN TRANSFER?
	JRST SETOF1	;IF NOT, DO NOT FREE KON AND CHN
	PUSHJ P,SETID2L	;SET KON AND CHN IDLE
	MOVSI T1,KCMIOS
	IORB T1,-1(P)	;SET IOS BIT
SETOF1:	MOVEI T2,OWCOD
	MOVEM T2,UNISTS(U)
	MOVSI T2,UNPOFL
	TLNE T1,KCMFUS
	TLO T2,UNPFUS
	IORM T2,UNIDES(U)
	HLLM T2,LSTBDU	;SAVE LAST BAD UNIT AND STATUS
	HRRM U,LSTBDU
	MOVEI T2,1
	DPB T2,UNYTIM	;SET TIMER TO GO OFF NOW
	MOVE T1,-1(P)
	POPJ P,

LSTBDU:	0

CPYOFL:	HRROS UNIBLK(U)
CPYFIN:	SETZM UNISTS(U)
	PJRST ZERTIM	;CLEAR HUNG TIMER AND RETURN.

POSSAT:	PUSH P,U	;SAVE UNIT OF DATA TRANSFER IF ANY
	MOVSI P2,776000
	AND P2,-2(P)
	TLNE T1,KCMPOS	;SPECIAL (3330) U SET UP
	TDZA P2,P2		;ZERO P2 FOR JUFFO
	TDZA P4,P4		;ELSE ZERO P4
	JRST POSTS1		;HERE I SPECAAL WITH U SET
POSTST:	JFFO P2,.+2	;ANY BITS LEFT?
	JRST POSDON	;NO, FINISHED
	LSH P2,1(P3)	;GET RID OF BIT
	ADDB P4,P3	;SET UNIT INDEX
	SKIPN U,@KONPTR(J)
	AOJA P4,POSTST	;EXTRANEOUS INTERUPT
POSTS1:	MOVE T1,UNISTS(U)
	XCT PSTTBL(T1)
	AOJA P4,POSTST

PSTTBL:	PHASE 0
ICOD:!	SETOM UNICYL(U)	;JUST MARK SO FORCES SEEK
PWCOD:!	SETOM UNICYL(U)
PCOD:!	PUSHJ P,POSFIN	;FINISHED A POSITION OPERATION
SWCOD:!	SETOM UNICYL(U)
SCOD:!	PUSHJ P,SEKFIN	;FINISHED A SEEK
RSCOD:!	PUSHJ P,SEKFIN	;READ AND RESET BUFFERED LOG, TREAT LIKE SEEK
CWCOD::!	SETOM UNICYL(U)
CCOD::!	PUSHJ P,CPYFIN	;CAPACITY TEST FINISHED
TWCOD:!	STOPCD		;ONLLY NONN-OSITION UNITS ARE IN TW
TWFCOD:!	PUSHJ P,RESEK	;MUST BE OFF THEN ON, RESET FOR POS
TCOD:!	SETOM UNICYL(U)		;SHOULD HAVE BEEN AN OFF-LINE INT FIRST
RCOD:!	PUSHJ P,RCLFIN	;FINISHED RECAL, SET TO POS
OWCOD:!	PUSHJ P,UNIONL	;UNIT BACK ONLINE
	DEPHASE

POSDON:	POP P,U
	MOVE T1,-1(P)	;RESET COM WORD
	POPJ P,

SEKFN1:	SETOM UNICYL(U)
	TDZA T1,T1	;GO TO IDLE
POSFIN:	MOVEI T1,TWFCOD	;BUT IF POS FINISHED, TO TWF
COMFIN:	MOVEM T1,UNISTS(U)	;SET STATUS
	PUSHJ P,ZERTIM
	MOVSI T1,KCMIOS
	IORM T1,-3(P)		;NEED I/O SELECTION
	SKIPN -1(P)
	HRRM U,-1(P)		;SAVE UNIT IN CASE ONLY POS INTERUPOPJ P,

RESEK:
RCLFIN:	SETOM UNICYL(U)		;MUST HAVE BEEN OFF-LINE
RCLFN2:	MOVEI T1,PWCOD		;OR FINISHED RECAL, FORCE SEEK
	SKIPGE KONLTM(J)
	 MOVEI T1,TWFCOD	;SET TRANS WAIT FIXED
	JRST COMFIN

UNIONL:	MOVSI T1,UNPOFL!UNPFUS
	ANDCAM T1,UNIDES(U)
	LDB T1,UNYPAC		;OTHER KIND OF WAITER
	JUMPN T1,RCLFIN
	JRST SEKFN1		;ELSE NO ONE WAITING, JUST SET IDLE

SEKFIN:	PUSH P,P2		;NEED TO SAVE THIS AC
	PUSHJ P,PIKPOS		;SEE WHAT POSITION NEED DOING
	 JRST SEKFN2		;NO REQUESTS, GO TO IDLE
	JUMPE P2,SEKFN3		;NO POSITION NEEDED, TO TWF
	POP P,P2
	JRST RCLFN2		;GO TO PW

SEKFN2:	TDZA T1,T1		;NO REQU3EST, GO IDLE
SEKFN3:	MOVEI T1,TWFCOD		;NO POSITION NEEDED, TO TWF
	POP P,P2
	JRST COMFIN


ERRRCV:	AOS UNISCT(U)		;CALL IT A SOFT ERROR
	PUSHJ P,@KONSFT(J)	;SAVE ERROR STATUS IF NECESSARY.
	MOVE T2,-2(P)
	MOVEM T2,UNISOF(U)	;STORE CONI AND DATAI
	MOVE T2,-3(P)
	MOVEM T2,UNISDI(U)
	HRRZ T2,-1(P)		;GET NUMBER OF BLOCKS
	SUBI T2,1		;THIS IS THE NUMBER TO ADD TO START
	MOVEM T2,UNISBN(U)	;PUT THIS IN SOFT BLOCK FOR NOW
	LDB PG,UNYPAC		;GET PAGE INFO POINTER
	LDB T2,PGYPNO		;AND ADDRESS
	LSH	T2,BLKSPP	;CONVERT TO BLOCKS
	ADDM T2,UNISBN(U)
	LDB T2,UNYPPL		;ALSO GET OFFSET
	ADDM T2,UNISBN(U)	;FINISH SETTING BLOCK NUMBER
	POPJ P,

DTASAT:	LDB PG,UNYPAC		;GET ACTIVE PAGE NUMBER
	LDB S,PGYSIO		;MAKE SURE PAGE HAS I/O GOING
	SKIPN S
	STOPCD			;NO
	LDB S,PGYSOP
	JUMPE S,DTAST2		;IN
	MOVSI S,IO		;OUT
DTAST2:	TLNN T1,KCMERR		;IS THERE AN ERROR?
	 JRST DTAOK		;NO, TRANSFER IS OK
	MOVSI T2,UNPDEV
	MOVEI P3,IODERR
	TDNN T2,UNIRCT(U)
	 MOVEI P3,IODTER	;SET DATA OR DEVICE ERROR
	TRNE S,IONRCK
	 JRST DTAOK1		;IGNORE ERROR IF NO RETRY REQUESTED
	HRRZ P4,-1(P)		;GET NUMBER OF BLOCKS
	LDB T2,PGYPNO
	LSH T2,BLKSPP		;CONVERT TO BLOCKS
	ADD P4,T2
	LDB T2,UNYPPL
	ADD P4,T2		;PLUS BLOCK WITHIN PAGE
	SUBI P4,1		;-1 IS LAST BLOCK
DTAST3:	SKIPG UNIRCT(U)		;IS THE ERROR THE FIRST ONE?
	 JRST DTRSEC		;NO
	MOVEM P4,UNISBN(U)	;SAVE SOFT BLOCK NUMBER
	MOVE T2,-2(P)
	MOVEM T2,UNISOF(U)	;STORE THE SOFT ERROR STATUS
	MOVE T1,-3(P)
	MOVEM T1,UNISDI(U)
	SETZM UNIECT(U)		;RESET ERROR COUNT
	MOVSI T1,(1B0)
	IORM T1,UNIRCT(U)	;AND RESET BIT 0 (NOT FIRST)
DTRSEC:	LDB T1,UNYRTY		;CHECK NUMBER OF RETRYS REMAINING
	SOJGE T1,DTRRTY		;GO RETRY
	LDB T1,UNYRCL		;OUT OF RETRYS, TRY RECAL
	SOJGE T1,DTRRCL
	LDB T1,UNYOCV		;TRY OFFSET NEXT.
	SOJGE T1,DTROFS
	MOVEM P4,UNIHBN(U)	;SET HARD DATA ERROR BLOCK NUMBER
	MOVE T1,-2(P)		;STILL FAILS AFTER E.R.: CALL IT HARD ERROR.
	MOVEM T1,UNIERR(U)
	MOVE T1,-3(P)
	MOVEM T1,UNIHDI(U)
	MOVEI T1,1		;READY TO COUNT ERROR
	TRNN P3,IODTER
	 JRST [	MOVSS T1	;DEVICE ERROR
		JRST .+4]
	TLNE S,IO
	 TLOA P3,IOSHWE
	  TLO P3,IOSHRE
	ADDM T1,UNIHCT(U)
	MOVE P4,UNIHBN(U)	;SAVE HARD BLOCK NUMBER
	PUSHJ	P,@KONHRD(J)	;CALL DEVICE DEPENDENT HARD ERROR DATA SAVER.
	JRST DTAOK1

DTRRTY:	DPB T1,UNYRTY	;REST COUNT
	AOS UNIECT(U)		;COUNT 1 RECOVERY TRY
	MOVEI T1,TWFCOD		;SET TRANSFER FIXED (RETRY)
	PUSHJ P,IDL1		;SET IDLE AND STORE STATUS
KCIPOP:	MOVSI T1,KCMIOS		;NEED TO DO I/O SELECT
	POPJ P,

DTRRCL:	DPB T1,UNYRCL		;RESET COUNT
	LDB T1,UNYRRT		;SET RETRY COUNT AFTER RECAL
	DPB T1,UNYRTY
	MOVEI T1,RCOD
	PUSHJ P,IDL1
	PUSHJ P,SETTIM		;MAKE SURE IT HAPPENS EVENTUALLY
	PUSHJ P,@KONRCL(J)	;ISSUE RECAL
	JRST KCIPOP

DTROFS:	DPB T1,UNYOCV		;STORE UPDATED COUNT.
	LDB T1,UNYRTO		;RETRY COUNT AFTER OFFSET.
	DPB T1,UNYRTY
	LDB T1,UNYRCO		;RECAL COUNT AFTER OFFSET.
	DPB T1,UNYRCL
	PUSHJ P,@KONOFS(J)	;SETUP FOR OFFSET, STATE IN UNYOCV
	JRST DTRSEC		;AND TRY AGAIN.


IDL1:	MOVEM T1,UNISTS(U)
	PUSHJ P,ZERTIM
SETID2:	LDB PG,UNYPAC
	LDB T1,PGYPNO
	LSH T1,BLKSPP		;CONVERT TO BLOCKS
	LDB T3,UNYPPL
	ADD T1,T3		;INCLUDE OFFSET IN ADDRESS
	MOVEM T1,UNIBLK(U)
SETIDL:	MOVSI T1,(1B0)
	ANDCAM T1,KONPTR(J)
	HRRZ T3,KONCHN(J)
	ANDCAM T1,(T3)
	POPJ P,

DTAOK:	MOVEI P3,0	;NO ERRORS
	SKIPL UNIRCT(U)		;WAS THERE AN ERROR?
	 JRST DTAOK1		;NO
	MOVEI T1,1
	MOVSI T2,UNPDEV
	TDNE T2,UNIRCT(U)	;DEVICE OR DATA?
	 MOVSS T1		;DEVICE
	ADDM T1,UNISCT(U)
	PUSHJ P,@KONSFT(J)	;TELL DRIVER THAT SOFT ERROR HAS OCCURRED, MAYBE HAS TO SAVE SOME STATUS.
DTAOK1:	PUSHJ P,ZERTIM
	PUSHJ P,SETIDL		;KON AND CHN ARE NOW IDLE
	SETZM UNISTS(U)		;UNIT IS NOW IDLE
	SETZM UNIRCT(U)		;ZERO THIS FOR NEXT TIME
	SETZM UNIRC1(U)		;ZERO SECOND E.R. STORAGE CELL.

SWPFIN:	HRRZ P4,-1(P)		;GET THE NUMBER OF BLOCKS
	MOVEI T1,UNIICT(U)	;GET POINTER TO BLOCKS TRANS
	PUSHJ P,UPSTAT		;AND UPDATE
	JUMPE P3,NOSWPR		;NO SWAP ERRORS
	TLNN S,IO		;INPUT OR OUTPUT ERROR?
	 JRST SWPFIE		;INPUT
	LDB T2,PGYADR		;OUTPUT, GET DISK ADDRESS
	camle	pg,maxpcb	;Is page a pcb?
	jrst	swpfnp		;No
	push	p,pg
	ldb	t2,pgylma	;Yes, get address of page
	pushj	p,ctlfnd	;Determine pcb type
	cain	pg,%sat.c	;Is it a sat?
	pushj	p,slocle	;Yes, request slow dskcln
	pop	p,pg
swpfnp:	PUSHJ P,INSOHT		;PUT INTO OUTPUT ERROR HASH TABLE
	MOVE T1,P3		;COPY ERROR BITS
	ANDI T1,IODERR!IODTER	;JUST THESE
	LSH T1,^L<IODTER>-^L<OHTDTE>+^D18	;POSITION IT FOR OHT IORM
	IORM T1,OHTTAB(T4)	;PUT BITS INTO OHT
	JRST NOSWPR		;REJOIN CODE.
SWPFIE:	LDB T1,PGYSTS		;GET STATUS BITS
	ADDI P4,3		;FORCE TO END OF THIS PAGE
	TRZE P3,IODERR
	 TRO T1,PGPDER
	TRZE P3,IODTER
	 TRO T1,PGPDTE
	DPB T1,PGYSTS		;SET ERROR BITS.
NOSWPR:	CAIGE P4,4		;THIS MIGHT BE TRUE ON RECOVERABLE ERROR
	 JRST SWPPPL		;YES, MUST TAKE SPECIAL PAINS
SWPPLD:	LSH P4,-2		;CONVERT TO PAGES
	SKIPG	P4		;MUST BE AT LEAST ONE
	 STOPCD
	ADDM	P4,DSKAPC	;UPDATE SYSTEM-WIDE NEGATIVE CTR
	SKIPE JOB		;IF NULL JOB RUNNING
	 JRST SWPFI0		;(ITS NOT IF HERE)
	SETOM CLKFLG		;GET TO SCHED EARLY SO
	WRPI PICLK		;HE DOESN'T HAVE TO WAIT TILL NEXT TICK.
SWPFI0:	LDB PG,UNYPAC		;GET FIRST PAGE DONE
	MOVEI F,SOD.N		;ASSUME SWAP OUT DONE
	TLNN S,IO		;IS IT?
	 MOVEI F,SID.N		;NO, SWAP IN DONE
	CAIA			;SKIP OVER FIRST LDB
	 LDB PG,PGYFPL		;GET NEXT PAGE
	SOJG P4,.-1		;JUMP IF THIS IS NOT THE LAST

;HERE WITH LIST NUMBER IN F, FIRST PAGE DONE IN UNYPAC,
; LAST PAGE DONE IN PG.

;FIRST TAKE THE PAGES THAT HAVE BEEN COMPLETED OFF THE I/O LIST.

	LDB	P4,UNYPAC	;P4 GETS FIRST DONE.
	MOVE	P3,PG		;P3 GETS LAST DONE.
	LDB	T3,PGYFPL	;GET FIRST NOT DONE, IF ANY, IN T3
	MOVE	PG,P4		;ADDRESS FIRST DONE
	LDB	PG,PGYBPL	;GET PREVIOUS IN PG
	JUMPE	PG,[DPB T3,UNYPGL ;IN NO PREVIOUS, FIRST NOT DONE, IF ANY,
				; IS NEW FIRST ON I/O LIST
		    JRST .+2]	;SKIP OVER THE DPB
	DPB	T3,PGYFPL	;PREVIOUS POINTS FORWARD TO 1ST NOT DONE
	EXCH	PG,T3		;ADDRESS 1ST NOT DONE IF ANY, T3
				; HAS PREVIOUS
	SKIPE	PG		;IF NO 1ST NOT DONE, NOTHING TO POINT BACK
	DPB	T3,PGYBPL	;1ST NOT DONE POINTS BACK TO PREVIOUS

;NOW TAKE PAGES THAT HAVE COMPLETED I/O AND PUT THEM ALL TOGETHER
; ONTO THE CORRECT DONE LIST.

	SKIPN	T3,LSTLST(F)	;ANYONE AT ALL ON DONE LIST?
	JRST	NEWDON		;NO, JUST MAKE THIS THE DONE LIST
	HLRZ	PG,T3		;ADDRESS LAST IN DONE LIST
	DPB	P4,PGYFPL	;LAST IN LIST POINTS FORWARD TO FIRST DONE
	EXCH	P4,PG		;ADDR. FIRST DONE, P4/LAST IN DONE LIST
	DPB	P4,PGYBPL	;FIRST DONE POINTS BACK TO LAST IN DONE LIST
	EXCH	PG,P3		;ADDRESS LAST DONE, FIRST DONE IN P3.
	HRLM	PG,LSTLST(F)	;THIS IS THE NEW LAST IN DONE LIST
	SETZ	T1,		;LAST IN DONE LIST POINTS TO 0
	DPB	T1,PGYFPL
	JRST	SWPFI1		;RETURN

;HERE WHEN DONE LIST WAS EMPTY. T3 CONTAINS 0.

NEWDON:	HRL	P4,P3		;LAST DONE,,FIRST DONE
	MOVEM	P4,LSTLST(F)	;NEW DONE LIST
	HRRZ	PG,P4		;ADDRESS FIRST DONE
	DPB	T3,PGYBPL	;POINTS BACK TO A 0
	EXCH	PG,P3		;ADDRESS LAST DONE, FIRST DONE IN P3.
	DPB	T3,PGYFPL	;POINTS FORWARD TO A ZERO

;HERE AFTER PAGES ARE PUT ONTO THE DONE LIST. STORE NEW
; LIST NUMBER AND CALL FINPCB IF THIS IS A PCB, WHICH
; MAY CALL SWPENQ (SO PAGE HAS TO BE ON DONE LIST).
; P3 HAS FIRST PAGE DONE, LAST PAGE DONE IS LAST ON DONE LIST.

SWPFI1:	MOVE	PG,P3		;GET FIRST DONE IN PG.

SWPFI2:	DPB	F,PGYLST	;THIS PAGE NOW ON DONE LIST
	CAMGE	PG,MINPCB	;MUST BE AT LEAST FIRST PCB PAGE
	STOPCD			;PAGE NUMBER TOO LOW
	LDB	P3,PGYFPL	;SAVE NEXT MEMBER IN CASE FINPCB
				; CALLS SWPENQ TO START IT AGAIN.
	CAMG	PG,MAXPCB	;IS IT A PCB?
	PUSHJ	P,FINPCB	;YES, DO SPECIAL STUFF
	SKIPE	PG,P3		;GET NEXT PAGE IF ANY
	JRST	SWPFI2		;AND DO IT
	JRST	KCIPOP		;RETURN.

SWPPPL:	LDB T2,UNYPPL	;SEE IF ANY LEFT FROM BEFORE
	ADD P4,T2	;TOTAL TRANSFERED SO FAR
	DPB P4,UNYPPL	;NO, SAVE AMOUNT DONE NOW
	CAIL P4,4	;IF NOT, IT IS 4, WE SAVE THE 2 LOW 0 BITS
	JRST SWPPLD	;FINALLY FINISHED THAT PAGE
	LDB PG,UNYPAC
	LDB T2,PGYPNO	;RESET ADDRESS
	LSH	T2,BLKSPP	;CONVERT TO BLOCKS
	ADD T2,P4
	MOVEM T2,UNIBLK(U)
	MOVEI T2,PWCOD	;FOR POSITIONING AND NEED CHANNEL
	SKIPL KONLTM(J)	;DO WE NEED THE CHANNEL?
	SKIPGE KONPOS(J)	;OR NOT POSITION
	MOVEI T2,TWFCOD	;THEN TO TWF
	MOVEM T2,UNISTS(U)
	JRST KCIPOP

COMMENT ;@@SUBROUTINE SWPENQ
@@PURPOSE ADD ONE PAGE TO THE SWAP I/O REQUEST LIST
@@ENTRY PG CONTAINS CORE PAGE TO ADD TO LIST. PGYSOP IS 1
IF PAGE IS TO BE SWAPPED OUT, 0 OTHERWISE (PGYSIP IS ASSUMED
TO BE ON IF PGYSOP IS OFF). PGYADR CONTAINS UNIT
(PGYUNI) AND PAGE WITHIN UNIT (PGYPNO) THAT THE SWAP
I/O IS TO BE DONE TO/FROM.
@@ACCUM USES T1-T4, PG, F, U, J, P1-P4, S
@@EXIT PAGE NUMBER IS NOT RETURNED IN PG, CALLER MUST SAVE.
@@CALLS IOSEL, WHICH CALLS KONTROLLER DEPENDENT ROUTINES, STRTIO
@@RESTRICTIONS CORE PAGE MUST NOT HAVE SWAP I/O IN PROGRESS
ALREADY BEFORE CALLING. CALLER IS RESPONSIBLE FOR
HANDLING ALL INFO REGARDING THE PAGE'S TRANSITION TO THE
SWAP IN PROGRESS STATE (E.G. MARKING PAGE CLEAN, PUTTING
JOBS INTO WAIT FOR THE PAGE, ETC.)
CORE PAGE MUST BE GREATER THAN OR EQUAL TO THE FIRST PCB
CORE PAGE IN THE SYSTEM, AND MUST BE LESS THAN OR
EQUAL TO THE LAST CORE PAGE IN THE SYSTEM.
@@FUNCTION TAKE PAGE OFF LIST IT WAS ON.  INSERT REQUEST ON
UNIT'S I/O QUEUE SOAS TO KEEP I/O QUEUE SORTED
WITH RESPECT TO UNIT PAGE NUMBERS. CALL IOSEL TO START I/O
IF NOT ALREADY STARTED, AND RETURN.
@@;


SWPENQ::CAML	PG,MINPCB	;IS PAGE IN BOUNDS?
	CAML	PG,MEMSZP	;ONLY THESE PAGES CAN SWAP
	STOPCD			;TRIED TO PULL A FAST ONE.
	LDB	T1,PGYADR	;GET ADDRESS
	CAMN	T1,ADRDUM	;THIS REALLY HAVE A DISK PAGE?
	STOPCD			;NO, CRASH.
	DSKOFF	;LET NO ONE CHANGE THINGS. DO THIS
				; BEFORE REMLST, SINCE IF THIS IS
				; A PCB PAGE, COULD GO FROM SWAP DONE
				; LIST TO SPR LIST AT INTERRUPT LEVEL.
	PUSHJ	P,REMLST	;TAKE CORE PAGE OFF OLD LIST
	LDB	U,PGYUNI	;GET UNIT NUMBER FROM REQUEST
	MOVE	U,UNTTBL(U)	;GET UNIT DATA BLOCK
	MOVEI	T1,SPR.N	;LIST PAGE WILL BE GOING ON
	DPB	T1,PGYLST	;PUT IT THERE.
IFCPU (KL),<LDB	T1,PGYSOP	;GET DIRECTION
	MOVE	T1,@[CSUCNT
		     CSVCNT](T1) ;GET PROPER COUNT
	MOVEM	T1,@PGYCSH	;REMEMBER SWEEP NUMBER
>;END IFCPU (KL)
	LDB	F,UNYPGL
	JUMPE	F,SWPEN0	;NO REQUEST WAITING, QUE THIS
	MOVEI	T3,0		;THIS IS THE 'PREVIOUS PAGE'
	LDB	T1,PGYPNO	;GET THE DESIRED ADDRESS
	EXCH	F,PG		;SAVE REQUEST PAGE IN F
SQLP:	LDB T2,PGYPNO		;GET ADDRESS OF REQUEST IN QUE
	CAMG	T1,T2		;SEARCH TILL ONE GREATER
	JRST	SWPQFD		;THIS IS IT
	MOVE	T3,PG
	LDB	PG,PGYFPL	;GET NEXT
	JUMPN	PG,SQLP		;CONTINUE SEARCH
SWPQFD:	SKIPE PG
	DPB	F,PGYBPL	;LINK IN BACK POINTER
	EXCH	F,PG
	DPB	F,PGYFPL	;AND FORWAR LINK
	DPB	T3,PGYBPL	;SET BACK LINK
	EXCH	PG,T3
	JUMPE	PG,[DPB T3,UNYPGL	;SET UP LIST IF PREVIOUS=0
		JRST .+2]
	DPB	T3,PGYFPL	;ELSE SET FORWARD LINK IN OLD
	MOVE	PG,T3		;RESTORE PG
SQENT:	SOS	DSKAPC		;NEW PG ON QUEUES
	HRRZ	J,UNIKON(U)	;J/ KONTROLLER ADDRESS
	PUSHJ	P,IOSEL
	DSKON
	POPJ	P,

SWPEN0:	DPB	F,PGYFPL	;REQUEST IS FIRST AND LAST
	DPB	F,PGYBPL	;ON THE UNIT'S SWAP IN PROGRESS LIST
	DPB	PG,UNYPGL	;REQUEST IS FIRST ON LIST
	JRST	SQENT		;AND GET THINGS STARTED

DSKAPC:: Z		;SYSTEM-WIDE ACTIVE-PAGE COUNT ON ALL UNITS
			;KEPT AS -(NUMBER OUTSTANDING PAGES)

;SWPSTR ACTUALL STARTS THE I/O PROCESS FOR THE LIST IN UNYPAC

STRTIO:
SWPSTR:	LDB PG,UNYPAC
	LDB S,PGYSOP
IFCPU (KL),<
	MOVE	T1,@PGYCSH	;START WITH SWEEP NUMBER FOR PAGE WE KNOW WE'LL DO
	MOVEM	T1,CSNSAV
>;END IFCPU (KL)
	SKIPN S
	SKIPA T1,KONRED(J)	;IN
	MOVE T1,KONWRT(J)	;OUT
	PUSHJ P,(T1)		;CALL IT
	PUSHJ P,SETTIM
SWPGL1:	LDB T2,UNYPPL	;SEE IF FINISHING UP FROM ERROR
	JUMPN T2,SWPPST
	LDB T3,PGYPNO	;GET THE STARTING ADDRESS
	MOVE T2,PG	;THE FIRST PAGE
	MOVE T1,PG	;TO BOTH (T1 WILL INC AS WE FIND MORE)

SWPGLP:	LDB PG,PGYFPL	;GET THE NEXT PAGE
	JUMPE PG,SWPST1	;START IT UP, OUT OF LIST
	LDB T4,PGYSOP
	CAME T4,S
	JRST SWPST1	;DIFFERENT DIR, START IT
	LDB T4,PGYPNO	;GET PAGE NUMBER
	ADDI T3,1
	CAME T3,T4
	JRST SWPST1	;DISCONTINUOUS ADDRESS, START IT
	CAIN PG,1(T1)	;DISCONTINUOUS CORE ADDRESS?
	AOJA T1,SWPST0	;NO, INCREMENT AND CONTINUE
	SUBI T1,-1(T2)	;CORE IS DISCONTINUOSU,, GET NUMBER
	LSH T1,9	;CONVERT TO WORDS
	LSH T2,9	;CONVERT ADDRESS
	PUSHJ P,@KONADD(J)	;ADD TO SWAP LIST
	 PJRST	SWPSTD		;OUT OF ROOM OR SOMETHING.
IFCPU (KL),<
	MOVE	T4,@PGYCSH	;GET SWEEP NUMBER FOR THIS REQUEST
	CAMLE	T4,CSNSAV	;IF LARGER THAN LARGEST SEEN
	MOVEM	T4,CSNSAV	;THEN THIS IS LARGEST SEEN.
>;END IFCPU (KL)
	JRST SWPGL1	;START UP AGAIN, MORE TO DO

IFCPU (KL),<
SWPST0:	MOVE T4,@PGYCSH	;GET SWEEP NUMBER FOR THIS PAGE.
	CAMLE T4,CSNSAV	;IS THIS BIGGER THAN HIGHEST WE'VE SEEN?
	MOVEM T4,CSNSAV	;YES, THIS IS NEW SWEEP NUMBER
	JRST	SWPGLP	;GO SEE IF CAN ADD ANOTHER.
>;END IFCPU (KL)

IFNCPU (KL),<SWPST0==SWPGLP>

SWPST1:	SUBI T1,-1(T2)	;END OF LIST OR DISK IS DISCONT.
	LSH T1,9
	LSH T2,9
SWPST2:	PUSHJ P,@KONADD(J)
	 PJRST SWPSTD	;LISK ABOVE BUT CAN NOT CONTINUE
;	PJRST SWPSTD

SWPSTD:
IFCPU (KL),<MOVE	T3,S	;GET DIRECTION OF IO
	MOVE	T4,CSNSAV	;GET LARGEST SWEEP NUMBER
	CAME	T4,@[CSUCNT
		     CSVCNT](T3) ;NEED A SWEEP?
	 PJRST	[AOS CSHSAV	;NO, COUNT A SAVED SWEEP
		 PJRST @KONFIN(J)] ;AND START TRANSFER UP.
	JUMPN	T3,SWPCSV	;DO VALIDATE IF ITS OUTPUT
	CSHUNL			;INPUT, START AN UNLOAD.
	CAMN	T1,CSUCNT	;SWEEP NUMBER CHANGE YET?
	JRST	.-1		;NO, WAIT FOR APR INTERRUPT
	PJRST	@KONFIN(J)	;YES, CAN START I/O NOW.

SWPCSV:	CSHVAL			;IT WAS AN OUTPUT, DON'T UNLOAD CACHE
	CAMN	T1,CSVCNT	;WAIT UNTIL VALIDATE COMPLETES
	JRST	.-1
>;END IFCPU (KL)
IFCPU (KS),<SKIPN	S		;SKIP IF OUTPUT
	CSHIVL			;ON INPUT INVALIDATE CACHE
>;END IFCPU (KS)
	PJRST	@KONFIN(J)	;GO START UP I/O

IFCPU (KL),<
CSNSAV:	BLOCK	1		;HIGHEST SWEEP NUMBER SEEN IN CURRENT GROUP OF I/O REQUESTS
>;END IFCPU (KL)

SWPPST:	LSH T2,BLKLSH	;FIND NUMBER OF WORDS ALREADY TRANSFERED
	MOVEI T1,1000
	SUB T1,T2	;THIS IS THE NUMBER LEFT TO DO
	LSH PG,9
	ADD T2,PG	;THIS IS THE ADDRESS
	JRST SWPST2	;GO


;SELECT THE I/O TRANSFER TO BE STARTED. CALLED AT INTERUPT
;LEVEL OR AT UUO LEVEL WITH DSKOFF IN EFFECT

IOSEL::	PUSH P,U
	SKIPN UNISTS(U)
	JRST IOIDLE	;THE UNIT IS CURRENTLY IDLE
	SKIPGE KONPOS(J)	;DOES THIS UNIT POSITION?
	JRST IOCHN	;NO, SEE IF CHANEL FREE FOR TRANS
	SKIPGE KONLTM(J)	;DOES THIS UNIT NEED THE CHANEL
	JRST IOINC1	;NO, IF NOT IDLE, POSSIBLY RECAL RESTART
IOKON:	SKIPGE KONPTR(J)	;IS THE KONTROLER BUSY?
	JRST UPOPJ	;IF SO, NOTHING MORE TO DO
IOKON0:	MOVE T1,UNISTS(U)
	CAIN T1,CWCOD
	JRST CPYKON	;START UP CPACITY TEST
	CAIE T1,SWCOD
	CAIN T1,PWCOD
	SKIPA		;NOW WAITING TO MOVE
	JRST IOKON1	;TRY NEXT UNIT
	AOS UNISTS(U)	;SET TO S OR P
	CAIN T1,SWCOD	;IS THIS A USER REQUEST (SEEK UUO)
USRSEK:	AOSA UNIUSC(U)	;COUNT USER
MONSEK:	AOS UNIMSC(U)	;OR MONITOR SEEK
	PUSHJ P,SETTIM	;SET TIMER
	PUSHJ P,@KONPOS(J)	;START THE POSITION
IOKON1:	HLRZ U,UNIKON(U)	;NEXT UNIT ON KONTROLER
	CAME U,(P)	;IS IT THE ONE WE STARTED WITH?
	JRST IOKON0	;NO, CHECK IT
IOCHN:	HRRZ P1,KONCHN(J)	;POINTER TO CHANNEL
	SKIPGE (P1)		;IS IT IDLE
	JRST UPOPJ	;NO, DONE
	MOVEI P1,0	;THE "BEST" UNIT
	MOVEI P2,1	;JUST TO MAKE IT NON-ZERO
IOCHN0:	MOVE T1,UNISTS(U)
	CAIN T1,CWCOD
	JRST CPYCHN	;START CAPACITY TEST
	CAIN T1,TWFCOD
	JRST IOCHNF	;TWF, USE UNICDA AND UNIBLK
	CAIN T1,TWCOD
	PUSHJ P,PIKTRN	;TW, PICK BEST TRANSFER
IOCHN1:	HLRZ U,UNICHN(U)
	CAME U,(P)	;BACK WHERE WE STARTED?
	JUMPN P2,IOCHN0	;THIS IS WHY WE MADE IT NON-ZERO, IDEAL TRANS?
	SKIPN U,P1	;DID WE SEE A TRANSFER
	JRST UPOPJ	;NO
	HRRZ J,UNIKON(U)	;POINT TO CORRECT KONTROLER
	MOVEI T1,TCOD
	MOVEM T1,UNISTS(U)
	MOVSI T1,(1B0)
	HRRZ P1,KONCHN(J)	;POINTER TO CHANNEL
	IORM T1,(P1)
	IORM T1,KONPTR(J)	;MARK UNIT AND KON BUSY
STRTIU:	PUSHJ P,STRTIO	;START I/O TRANSFER
UPOPJ:	POP P,U
	HRRZ J,UNIKON(U)
	POPJ P,

;HERE IF THE UNIT IS IDLE

IOIDLE:	SKIPGE KONPOS(J)	;DOES UNIT POSITION?
	JRST IOINPS	;NO
	SKIPGE KONLTM(J)
	JRST IOINCH	;DOES NOT NEED CHANEL
	PUSHJ P,PIKPOS	;PICK THE BEST POSITION
	 JRST IOKON	;NO TRANSFERS WAITING
	MOVEI T1,PWCOD
	SKIPN P2	;P2 HAS CYL DIFF, WAS IT 0
	MOVEI T1,TWFCOD	;IF YES, TWF NOT PW
	MOVEM T1,UNISTS(U)
	JRST IOKON	;GO SEE IF KON IS FREE

IOINPS:	MOVEI T1,TWCOD
	LDB P1,UNYPGL	;IS THERE A TRANSFER WAITING?
	JUMPE P1,IOCHN	;NO, LEAVE IDLE.
	MOVEM T1,UNISTS(U)	;YES, SET TO TW
	JRST IOCHN	;AND SEE IF CHANEL IS READY

IOINCH:	MOVSI T1,UNPRRS
	TDNE T1,UNIDES(U)	;DOES HE WANT TO READ LOG?
	JRST RDRST		;YES
	PUSHJ P,PIKPOS
	 JRST UPOPJ	;NO TRANFERS, MUST BE DONE
IOINC2:	MOVEI T1,TCOD
	MOVEM T1,UNISTS(U)
	JRST STRTIU	;AND GO START IT UP

IOCHNF:	HRRZ J,UNIKON(U)
	MOVE T1,UNIBLK(U)	;CHECK LATENCY FOR THIS UNIT
	PUSHJ P,@KONLTM(J)	;THIS IS IN TWF
	SKIPE P1
	CAMGE T1,P2
	PUSHJ P,SAVBST	;BEST SO FAR
	JRST IOCHN1	;UNICDA ALREADY SET

IOINC1:	MOVEI T1,TWFCOD
	CAME T1,UNISTS(U)	;IS IT IN TWF?
	JRST UPOPJ	;NO, NOTHING TO DO
	JRST IOINC2	;YES, BACK ON LINE OR RECAL FINISHED

CPYKON:	AOS UNISTS(U)	;SET TO C
	HRRZ T1,KONCPY(J)
	PUSHJ P,(T1)
	JRST IOKON1

CPYCHN:	AOS UNISTS(U)
	HRRZ T1,KONCPY(J)
	PUSHJ P,(T1)
	JRST IOCHN1

RDRST:	ANDCAM T1,UNIDES(U)	;RESET FLAG
	MOVEI T1,RSCOD
	MOVEM T1,UNISTS(U)
	HRRZ J,UNIKON(U)	;JUST TO MAKE SURE
	PUSHJ P,SETTIM
	PUSHJ P,@KONLTM(J)
	JRST UPOPJ
COMMENT ! PIKPOS & PIKCYL 
PURPOSE: PICK THE BEST POSITION & CYLINDER TO DO NEXT
EXPECTS: U/UNIT
DESTROYS:  T1-T3,P1-P3,PG
RETURNS:
  NOSKIP: NO PAGES ON UNYPGL,NOTHING TO DO. T3/BLOCKS PER CYL
  SKIP: P1/ 1ST BLK OF NEXT CYL
	P2/ NUMBER OF CYLS TO MOVE
	P3/ PG/ OPTIMUM PG
	T3/ BLOCKS PER CYL
FUNCTION: CHAIN DOWN UNYPGL LOOKING FOR LARGEST DSK PAGE
 NUMBER .LE. UNICYL(U).  (IF ONE FOUND ON SAME CYL
 AS UNICYL(U), SOSLE FAIRNESS COUNT AND USE THIS ONE
 IF LARGER THAN LAST PAGE DONE ON THIS CYL AND FAIRNESS CNT
 NOT EXHAUSTED). AT THE POINT WE ENCOUNTER A DSK PAGE NUMBER
 WHOSE CYL IS > UNICYL, RESET FAIRNESS, CHECK
 WHICH DIRECTION WE'RE GOING. IF WE ARE GOING TOWARDS LARGER
 DISK PAGE NOS., EXIT WITH THIS AS THE OPTIMUM PAGE. IF
 WE WERE GOING TOWARDS SMALLER PAGES, USE THE LARGEST PAGE
 SMALLER THAN UNICYL WHICH WE ALREADY FOUND, IF ANY; OTHERWISE
 SET DIRECTION TOWARDS LARGER PAGES (="FORWARD") AND EXIT WITH THIS
 ONE AS OPTIMUM PAGE.

 IF ALL PAGES ON UNYPGL HAVE CYL < UNICYL, SET DIRECTION
 TOWARDS SMALLER (="BACKWARDS") AND USE LARGEST FOUND.

CAVEAT:  THIS IS A ROUGH DESCRIPTION OF THE DSK ALGORITHM,
 AND I DON'T GUARANTEE IT TO BE EXACT; MOREOVER, SOME
 BEING MAY CHANGE THE CODE WITHOUT CHANGING THIS COMMENT.
 IT IS INTENDED AS AN INTRODUCTORY GUIDE ONLY, TO THOSE WISHING
 TO PENETRATE THIS MYSTERIOUS REALM, AS I HAVE.
 GOOD LUCK.  MAGIC IS SAID TO WORK HERE. /AA
!
;THIS IS THE FAMOUS "ELEVATOR" ALGORITHM


PIKPOS:	MOVNI P1,1	;INITIALIZE TO -1 FOR FIRST REQ SELECTED
	MOVEI P3,0	;NONE SAVED
	LDB T3,UNYPPY
	LSH T3,2	;NUMBER OF BLOCKS PER CYL
	LDB PG,UNYPGL	;PAGES TO TRANSFER
	JUMPE PG,CPOPJ	;IF NO DDB'S AND NOT PAGES, EXIT
PIKPSL:	LDB T1,PGYPNO	;GET ADDRESS FOR PAGE
	LSH	T1,BLKSPP	;CONVERT TO BLOCKS
PKPSP:	CAML T1,P1	;CHECK AT ALL?
	JSP P2,PIKCYL	;YES, DO THE WORK
	LDB PG,PGYFPL	;NEXT
	JUMPN PG,PIKPSL	;MORE PAGES, CONTINUE

;BACK HERE FROM PIKCYL TO USE SAVED BEST-SO-FAR PAGE.

PKPSB:	MOVE PG,P3	;OUT OF PAGES. GET SAVED PAGE.
	MOVSI T2,(1B0)	;CHANGE DIRECTION TO BACKWARDS.
	IORM T2,UNIDIR(U) ;THIS IS A NORMAL WAY OUT IN BACKUP MODE
PIKPS2:	LDB T1,PGYPNO	;FOR A PAGE, GET ADDRESS
	LSH	T1,BLKSPP	;CONVERT TO BLOCKS
	MOVEM T1,UNIBLK(U)		;MUST SET DESIRED BLOCK
	IDIV T1,T3	;FIND THE CYL
	SUB T1,UNICYL(U)	;DIFF IS ENOUGH
	JUMPE T1,PIKPC1	;SET UNICDA AND UNYPAC FOR SELECTED RQ
	PUSHJ P,SETFCT	;DIFFERENT CYL, RESET FAIRNESS
PIKPC1:	MOVM P2,T1	;GET MAGNITUDE OF CHANGE FOR CALLERS
	DPB PG,UNYPAC		;AND PAGE NUMBER (F=0 FOR PAGE RQ)
	PJRST	CPOPJ1	;SKIP RETURN

;PIKCYL DOES THE REAL WORK FOR EACH CYL FOUND
;THE CALL IS JSP P2,PIKCYL
;IS GOES TO PIKPS2 TO USE CURRENT REQUEST
;IT RETURNS TO CALL+1 TO CONTINUE SCAN
;IT RETURNS TO PKPSB TO USE SAVE  BEST REQUEST

PIKCYL:	IDIV T1,T3	;GET CYL OF REQUEST
	CAML T1,UNICYL(U)	;SMALLER THAN CURRENT?
	JRST PIKCY1	;NO
PIKCYH:	MOVE	P3,PG	;SAVE PG, CLOSEST REQUEST SO FAR BELOW UNICYL
PIKCYB:	MOVEI P1,1(T1)	;SET BLOCK FOR NEXT CYL
	IMUL P1,T3
	JRST (P2)	;RETURN

PIKCY1:	SUB T1,UNICYL(U)	;SAME?
	JUMPE T1,PIKSMC		;YES, SPECIAL PROCESSING
	PUSHJ P,SETFCT	;RESET FAIRNESS COUNT (DIFF CYL)
	SKIPL UNIDIR(U)	;WHICH WAY?
	JRST PIKPS2		;FORWARD, USE THIS ONE
	JUMPN P3,PKPSB		;BACKWARD, IF ONE SAVED, USE IT
	MOVSI T2,(1B0)
	XORM T2,UNIDIR(U)	;RESET DIRECTION TO FORWARD SCAN
	JRST PIKPS2		;AND USE THIS ONE

PIKCYS:	SOSLE UNIFCT(U)		;SAME CYL, FAIRNESS EXAUSTED?
	JRST PIKPS2		;NO, USE THIS ONE
	JUMPE P3,PIKCY0		;NONE SAVED, SET DIR=FORWARD
	SKIPL UNIDIR(U)		;WHICH WAY
	JRST PIKCYB		;FORWARD, JUST SET FOR NEW SEARCH CYL
	PUSHJ P,SETFCT	;BACKWARDS, USED HELD REQUEST
	JRST PKPSB

PIKCY0:	MOVSI T2,(1B0)
	ANDCAM T2,UNIDIR(U)	;RESET DIR=FORWARD IN CASE ONE THERE
	JRST PIKCYH		;AND REMEMBER THIS IN CASE NONE

SETFCT:	MOVE T2,T3
	LSH T2,-5	;GET A MORE REASONABLE NUMBER
	MOVEM T2,UNIFCT(U)
	POPJ P,

PIKSMC:	LDB T2,PGYPNO	;GET ADDRESS BACK
	LSH	T2,BLKSPP	;CONVERT TO BLOCKS
	CAMLE T2,UNIBLK(U)
	JRST PIKCYS	;STILL GOING UP, CONTIMUE
	AOS P1,T2	;JUST LOOK A LITTLE HIGHER
	JUMPN P3,PKPSB	;ALREADY GOT ONE SAVED, GO
	MOVSI T2,(1B0)
	ANDCAM T2,UNIDIR(U)
	MOVE	P3,PG	;SAVE THIS
	SOS UNIFCT(U)	;JUST IN CASE
	JRST (P2)	;AND CONTINUE SCAN


;SUBROUTINE TO UPDATE UNIT STATISTICS AFTER IO
;ENTER WITH P4=NUMBER OF BLOCKS,  T1=UNIXRC(U)   (X=M,B OR D)
UPSTAT:	TLNE	S,IO		;WRITING?
	ADDI	T1,1		;YES. UNIXWC=UNIXRC+1
	ADDM	P4,(T1)		;UPDATE WORD IN UNIT BLOCK
	POPJ	P,		;AND RETURN

COMMENT;@@SUBROUTINE SMSTAT
@@PURPOSE UPDATE UNIT DATA BLOCK COUNTS (INCREMENT BY "N" BLOCKS)
@@ENTRY T1/ NUMBER OF BLOCKS DONE
	T2/ RETRIEVAL POINTER FOR BLOCKS
	S/  I/O STATUS (MODE AND IO BIT)
@@ACCUM USES T1-T3, U
@@EXIT ALWAYS NON-SKIP.
@@FUNCTION INCREMENT APPROPRIATE UNIT DATA BLOCK COUNT.
@@;

SMSTAT::LDB	U,RBYUNI	;GET UNIT NUMBER
	MOVE	U,UNTTBL(U)	;GET UNIT DATA BLOCK ADDRESS
	LDB	T3,PIOMOD	;GET MODE
	CAIL	T3,SD		;SKIP IF NOT DUMP MODE
	JRST	SMSTA1		;DO DUMP MODE

	MOVEI	T3,UNIBRC(U)	;ASSUME READ
	TLNE	S,IO		;SKIP IF READ
	MOVEI	T3,UNIBWC(U)	;NO, WRITE.
	ADDM	T1,(T3)		;BUMP COUNT AND
	POPJ	P,		;RETURN

SMSTA1:	MOVEI	T3,UNIDRC(U)	;ASSUME READ
	TLNE	S,IO		;SKIP IF READ
	MOVEI	T3,UNIDWC(U)	;WRITE
	ADDM	T1,(T3)		;INCREMENT
	POPJ	P,		;AND RETURN.

;HERE TO PICK THE BEST TRANSFER

;P1 HAS BEST UNIT, P2 ITS LATENCY TIME

PIKTRN:	MOVEI P3,0	;NO F FOUND
	HRRZ J,UNIKON(U)	;GET CORRECT KON
	LDB PG,UNYPGL	;START LOOKING FOR PAGE TRANSFERS
	JUMPE PG,CPOPJ	;NONE
PIKTP1:	LDB T1,PGYPNO
	PUSHJ P,@KONLTM(J)
	SKIPE P1
	CAMGE T1,P2
	PUSHJ P,SAVBST
	JUMPE P2,PIKTP0	;BEST POSSIBLE FOUND
	LDB PG,PGYFPL	;GET NEXT PAGE
	JUMPN PG,PIKTP1
	JUMPE P3,CPOPJ	;NONE FOUND
	MOVE PG,P3	;GET BEST BACK
PIKTP0:	DPB PG,UNYPAC
	LDB T1,PGYPNO
	LSH	T1,BLKSPP	;CONVERT TO BLOCKS
	MOVEM T1,UNIBLK(U)	;SET BLOCK
	POPJ P,
SAVBST:	MOVE	P3,PG		;BEST PAGE
	MOVE P1,U
	MOVE P2,T1
	POPJ P,

ZERTIM:	TDZA T1,T1
SETTIM:	MOVEI T1,3	;SET TIMER FOR 3 SECONDS
	DPB T1,UNYTIM
	POPJ P,

;CALLED ONCE A SECOND TO CHECK FOR UNITS THAT ARE HUNG

INTERNAL UNISEC

UNISEC:	HLRZ U,SYSUNI
	DSKOFF	;NO INTERUPTS WHILE CODE IN PROGRESS
USCLP:	LDB T1,UNYTIM
	SOJE T1,USCLP1	;ONLY IF COUNTS DOWN TO ZERO
	SKIPL T1
	DPB T1,UNYTIM	;PUT BACK IF WAS NOT ZERO
USCLP2:	HLRZ U,UNISYS(U)
	JUMPN U,USCLP
	DSKON
	PUSHJ	P,SATONC
	POPJ P,

USCLP1:	MOVE T1,UNISTS(U)
	XCT HNGCOD(T1)	;DO APPROPRIATE ACTION
	JRST USCLP2	;AND GET BACK TO THE CHECK

HNGCOD:	PHASE 0
ICOD:!	PUSHJ P,ZERTIM
PWCOD:!	PUSHJ P,ZERTIM	;THESE ARE MISTAKES, TIMER SHOULD NOT BE SET
PCOD:!	PUSHJ P,HNGPS	;POSITION OR SEEK HUNG
SWCOD:!	PUSHJ P,ZERTIM
SCOD:!	PUSHJ P,HNGPS
RSCOD:!	PUSHJ P,HNGRS
CWCOD::	PUSHJ P,ZERTIM
CCOD::	PUSHJ P,ZERTIM
TWCOD:!	PUSHJ P,ZERTIM
TWFCOD:!	PUSHJ P,ZERTIM
TCOD:!	PUSHJ P,HNGT	;HUNG IN TRANSFER
RCOD:!	PUSHJ P,HNGR	;RUNG IN RECAL
OWCOD:!	PUSHJ P,OFLUNI	;UNIT IS OFF-LINE
	DEPHASE

HNGR:	MOVEI T1,PCOD	;SET TO PCOD SO GET TO TRANSFER WAIT
HNGPS:	SUBI T1,1
	HRRZ J,UNIKON(U)
	PUSHJ P,@KONSTP(J)	;TRY TO STOP IT
	 SKIPA			;STOPPED, NOW RESTART
	JRST SETTIM		;STOPPD AND RESTARTED, RETIME
	MOVEM T1,UNISTS(U)
	AOS UNIHNG(U)		;RECORD HUNG RECOV FROM POS
	PUSHJ	P,HNGUNI	;Tell OPR about hung unit
HNGCOM:	PUSHJ P,ZERTIM	;RESET TIMER
	PJRST IOSEL	;AND START I/O IF POSSIBLE

hngt:	MOVSI T1,1
	ADDM T1,UNIHNG(U)	;RECORD HUNG RECOV FROM TRANS
	PUSHJ	P,HNGUNI	;Tell OPR about hung unit
	HRRZ J,UNIKON(U)
	PUSHJ P,@KONSTP(J)	;TRY TO STOP
	 SKIPA		;OK
	JRST SETTIM		;STOPPED AND RESTARTED, RETIME
	MOVEI T1,TWFCOD
	PUSHJ P,IDL1	;AND MARK IDLE
	JRST HNGCOM	;SEE ABOVE

HNGRS:	AOS UNIHNG(U)
	PUSHJ	P,HNGUNI	;Tell OPR about hung unit
	HRRZ J,UNIKON(U)
	PUSHJ P,@KONSTP(J)
	PUSHJ P,SETTIM
	PJRST @KONLTM(J)	;RESART PROCESS

OFLUNI:	MOVEI T1,ALRACT
	IORM T1,ALR620	;SET ALARM CELL
	PUSH P,U
	PUSHJ P,GETOPR
	JUMPE U,NOOPR
	PUSHJ P,INLMES
	BYTE (7) 7,7,7,7,7	;SOME BELLS
	ASCIZ /
UNIT /
	MOVE T2,(P)	;RESTORE U
	MOVE T2,UNINAM(T2)
	PUSHJ P,PRNAME
	PUSHJ P,INLMES
	ASCIZ / WENT OFF-LINE/
	MOVE T2,(P)
	MOVE T2,UNIDES(T2)
	TLNN T2,UNPFUS	;CHECK UNSAFE
	JRST TELOP4
	PUSHJ P,INLMES
	ASCIZ / (FILE UNSAFE)/
TELOP4:	PUSHJ P,INLMES
	ASCIZ /
PLEASE POWER IT DOWN, THEN TURN IT ON AGAIN.
/

NOOPR:	POP P,U
	MOVEI T1,^D60	;RESET OF 1 MIN
	DPB T1,UNYTIM
	POPJ P,

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	This routine is called to report the occurrence of	;;
;;	a true "hung" state to the system operator.  It does	;;
;;	not matter if the hung condition is immediately		;;
;;	corrected, only that it occurred at all.		;;
;;								;;
;;	Entered with U - Unit Data Block address (preserved)	;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

HNGUNI:	MOVEI	T1,ALRACT	;It's the Accounting flag, but who's perfect?
	IORM	T1,ALR620	;Irritate the operator
	PUSH	P,U		;Save from typeout routines
	PUSHJ	P,GETOPR	;Grab the operator's Line Data Block
	  JUMPE	U,UPOPJ		;None there, let confusion reign
	PUSHJ	P,INLMES	;In-line message
	BYTE (7) 7,7,7,7,7	;Bells (Clangor and Alarum)
	ASCIZ	/
Unit /
	MOVE	T2,(P)		;Get back Unit Data Block address
	MOVE	T2,UNINAM(T2)	;Get this unit's SIXBIT name
	PUSHJ	P,PRNAME	;Type it out
	PUSHJ	P,INLMES	;In-line message
	ASCIZ	/ Hung
/
	PJRST	UPOPJ		;Restore UDB and return


COMMENT;@@SUBROUTINE INSOHT
@@PURPOSE INSERT A DP ADDRESSIN THE OUTPUT ERROR HASH TABLE (OHT)
@@ENTRY T2 HAS DP ADDRESS. 1B0-1B8 MUST BE ZERO.
@@ PG has Core Page Number of Disk Page in T2.
@@ACCUM PRESERVES DP ADDRESS IN T2, CLEARS 1B0-1B8 IN T2,
SMASHES T1,T3,T4.
@@EXIT T2 HAS DP ADDRESS. T4 HAS INDEX, SO CALLER CAN SET BITS. ALWAYS RETURN NON-SKIP.
@@RESTRICTIONS CALL AT DISK INTERRUPT LEVEL OR DSK PI OFF ONLY,
ELSE CAN'T LOOK AT HEADER DATA (MAY BE CHANGED BY INSOHT, AND
THIS ROUTINE IS NOT REENTRANT.)
@@FUNCTION IF DP IS ALREADY IN OHT, RETURN.
OTHERWISE PUT DP IN OHT, INCREMENT OHTNUM, RETURN.
@@;

INSOHT::PUSHJ	P,SRCOHT	;SEE IF ITS THERE ALREADY
	  AOSA	OHTNUM		;NO, GOING TO PUT IT IN, INCREMENT
	JRST	INSOH2		;Count multiple calls for same DP,
				; overwrite OHTCPN entry, exit w/T4=index
	MOVSI	T4,-OHTLEN	;SET TO SEARCH OHTTAB FOR FREE CELL
INSOH1:	SETCM	T1,OHTTAB(T4)	;GET COMPLEMENT OF DATA
	TRNN	T1,-1		;IF ALL ZERO, THEN ITS FREE.
	TLNE	T1,777		;SKIP IF FREE
	JRST	INSOH3		;NOT FREE.
	LDB	T1,T3		;FREE. GET OLD FIRST
	DPB	T4,T3		;HEADER GETS NEW FIRST
	DPB	T1,[POINT OHTLNS,T2,OHTLNP]
	MOVEM	T2,OHTTAB(T4)	;STORE NEW DATA OVER THE -1
	TLZA	T2,777000	;CLEAR ALL BUT DISK ADDRESS.
INSOH2:	AOS	OHTREP		;# times called >once for same DP
	TLZ	T4,-1		;Clear out crap
	ROT	T4,-1		;Make low-order bit the sign bit
	SKIPGE	T4
	  JRST	.+3
	HRLM	PG,OHTCPN(T4)	;Write CPN into even-numbered table entry
	SKIPA
	HRRM	PG,OHTCPN(T4)	;Or odd-numbered entry
	ROT	T4,1		;Restore OHTTAB index
	POPJ	P,		;AND RETURN.

INSOH3:	AOBJN	T4,INSOH1	;NOT FREE, LOOK FOR ANOTHER
	STOPCD			;OHT FULL, CRASH.


SUBTTL OHT (OUTPUT ERROR HASH TABLE)

COMMENT;@@SUBROUTINE REMOHT
@@PURPOSE REMOVE DP ADDRESS FROM OHT. CALLED BY REMOVE VP.
@@ENTRY T2 CONTAINS DP ADDRESS
@@ACCUM PRESERVES T2, SMASHES T1,T3,T4
@@EXIT  ALWAYS NON-SKIP.  DSK PI CHANNEL STATE DESTROYED.
@@RESTRICTIONS DP MUST BE IN OHT. CALL ONLY AT UUO LEVEL,
REMOHT CAN HAVE ONLY ONE CALLER AT A TIME.
@@FUNCTION CALL SRCOHT TO FIND THE ENTRY TO BE REMOVED.
TURN DSK PI CHANNEL OFF. IF PREVIOUS POINTER IS NOT THE HEADER
POINTER, JUST REMOVE THE ENTRY BY POINTING PREVIOUS POINTER
TO NEXT ENTRY, SET REMOVED ENTRY DATA TO -1. IF PREVIOUS WAS THE
HEADER, MAY HAVE BEEN CHANGED AFTER RETURN FROM SRCOHT
AND BEFORE DSKPIF. CHECK TO SEE THAT PREVIOUS POINTER
STILL POINTS TO FOUND ENTRY. IF NOT (NEW ENTRY SNUCK IN AT HEADER)
CHAIN THRU HASH CHAIN UNTIL FIND THE POINTER THAT POINTS TO
ENTRY TO BE REMOVED. CRASH IF CANNOT FIND REMOVED ENTRY
AGAIN. THEN REMOVE ENTRY NORMALLY.
@@;


REMOHT::PUSHJ	P,SRCOHT	;FIND THE ENTRY
	  STOPCD		;HAD TO BE THERE
	DSKOFF	;TURN OFF DSK PIS
	CAME	T1,T3		;DID SRCOHT GIVE US HEADER PTR?
	JRST	REMOH2		;NO, ITS SAFE, ENTRIES ONLY ADDED AT HEAD OF CHAIN,
				; AND ONLY REMOVED AT UUO LEVEL.
REMOH1:	LDB	T1,T3		;HEADER. GET WHAT IT POINTS TO.
	CAMN	T1,T4		;MOST OF THE TIME, ITS OK.
	JRST	REMOH2		;THIS IS STILL THE FIRST ENTRY
	CAIN	T1,ENDOHT	;MAKE SURE ENTRY DIDN'T VANISH
	STOPCD			;IT DID, CRASH.
	MOVEI	T3,OHTTAB(T1)	;GET ADDRESS OF ENTRY
	HRLI	T3,(POINT OHTLNS,0,OHTLNP)	;FRESH BYTE POINTER
	JRST	REMOH1		;AND GIVE THAT IF WHAT IT POINTS TO IS ENTRY
				; THAT IS GOING AWAY.

REMOH2:	SOS	OHTNUM		;ONE LESS NOW.
	LDB	T1,[POINT OHTLNS,OHTTAB(T4),OHTLNP] ;GET NEW NEXT MEMBER
	DPB	T1,T3		;PREVIOUS POINTER POINTS TO NEXT
	SETOM	OHTTAB(T4)	;THIS WORD NOW FREE.
	DSKON		;ALLOW INSERTIONS AGAIN.
	POPJ	P,		;RETURN.

COMMENT;@@SUBROUTINE SRCOHT
@@PURPOSE USED WHEN SEARCHING OHT OR WHEN INSERTING OR DELETING
AN ENTRY FROM OHT. CALLERS SHOULD DO SKIPN OHTNUM BEFORE
CALLING TO SAVE TIME.
@@ENTRY T2 CONTAINS DP ADDRESS TO SEARCH FOR.
CAN CALL BOTH AT INTERRUPT AND UUO LEVEL.
@@ACCUM USES T1,T3,T4. PRESERVES T2.
@@EXIT IF DP NOT FOUND, NON-SKIP RETURN WITH
	T3/ BYTE POINTER TO HEADER FIELD.
	     (USE ONLY IF CALLING AT DSK IRP LEVEL OR DSKPIF)
IF DP IS FOUND, SKIP RETURN WITH
	T1/ HEADER POINTER (FOR VALIDITY CHECK OF T3).
	T3/ BYTE POINTER TO LAST LINK FIELD (MUST BE CHECKED, SEE
	     RESTRICTIONS)
	T4/ INDEX OF DP'S CELL.
@@RESTRICTIONS CALLER MUST CHECK VALIDITY OF LAST LINK POINTER

IF IT POINTS TO THE HEADER BYTE BY TURNING OFF DSK PI CHANNEL

AND MAKING SURE A NEW ENTRY DID NOT SNEAK IN IF ENTRY IS FOUND.

IF ENTRY IS NOT FOUND, CALLER MUST NOT USE BYTE POINTER TO HEADER FIELD
UNLESS DSK PI IS OFF OR AT DSK PI LEVEL, ELSE DATA COULD CHANGE.
@@FUNCTION COMPUTE HASH INDEX FOR DP. GET BYTE POINTER TO PROPER
HEADER BYTE FOR HASH CODE. IF CONTENTS OF HEADER IS ENDOHT,
RETURN WITH THE BYTE POINTER TO THE HEADER. ELSE, SAVE THE
POINTER TO THE HEADER. LOOK FOR THE DP. IF FOUND, GIVE SKIP
RETURN WITH BYTE POINTER TO PREVIOUS MEMBER (OR HEADER)
IN T3, INDEX IN T4. IF NOT FOUND, RETURN WITH BYTE
POINTER TO HEADER BYTE IN T3.  NOTE THAT A NEW ENTRY CAN SNEAK IN
WHILE SEARCHING, BUT NEW ENTRIES ARE ADDED TO BEGINNING OF
CHAIN ONLY, SO WORST THAT CAN HAPPEN IS THAT SEARCH WILL FAIL
TO FIND ENTRY THAT SNUCK IN, BUT THIS IS NO WORSE
THAN IF ENTRY SNUCK IN AFTER RETURN FROM SRCOHT.
CHAIN IS ALWAYS INTACT, REMOHT ONLY CALLED AT UUO LEVEL.
@@;

SRCOHT::MOVE	T3,T2		;COPY SO DON'T DESTROY T2
	IDIVI	T3,OHTLEN	;GET DP'S HASH INDEX IN T4
	MOVE	T3,T4		;GET INTO T3 FOR IDIVI AGAIN
	IDIVI	T3,OHTHPW	;INDEX TO OHTBYT IN T4, TO OHTHED IN T3.
	ADD	T3,OHTBYT(T4)	;GET POINTER TO HEADER FIELD.
	LDB	T4,T3		;GET FIRST ENTRY INDEX
	CAIN	T4,ENDOHT	;CHAIN EMPTY?
	POPJ	P,		;YES, RETURN WITH T3 POINTER TO HEADER BYTE
	PUSH	P,T3		;REMEMBER POINTER TO HEADER IN CASE SEARCH FAILS
SRCOH1:	MOVE	T1,T2		;COPY DP ADDRESS
	XOR	T1,OHTTAB(T4)	;T1 HAS INDEX IN 1B0-8, XOR IN THE REST
	TRNN	T1,-1		;SKIP IF ANY DIFFERENT BITS IN RH
	TLNE	T1,ENDOHT	;SKIP IF ALL BITS THE SAME IN RH OF LH
	JRST	SRCOH2		;NO MATCH.
	TLNN	T3,-1		;IF NOT THE HEADER POINTER,
	ADD	T3,[POINT OHTLNS,OHTTAB,OHTLNP] ;TURN T3 INTO POINTER TO LINK.
	POP	P,T1		;THROW AWAY HEADER POINTER
	JRST	CPOPJ1		;MATCHING CELL IN T4. SKIP RETURN.

SRCOH2:	LDB	T1,[POINT OHTLNS,T1,OHTLNP] ;GET INDEX.
	CAIN	T1,ENDOHT	;THIS THE LAST CELL?
	JRST	[POP P,T3	;GET HEADER POINTER IN T3 TO RETURN
		 POPJ P,]	;AND GIVE FAIL RETURN.
	MOVE	T3,T4		;NOT DONE, REMEMBER LAST INDEX
	MOVE	T4,T1		;GET NEXT TO DO IN T4
	JRST	SRCOH1		;AND GO CHECK FOR A MATCH
;ROUTINE TO INIT OHT. PRESERVES T2-T4, SMASHES ONLY T1.

OHTINI::SETOM	OHTHED		;HEADER BYTES ALL ONES, ALL SLOTS -1.
	MOVE	T1,[OHTHED,,OHTHED+1]
	BLT	T1,OHTTAB+OHTMAX
	SETZM	OHTNUM
	POPJ	P,

IFNDEF OHTLEN,<OHTLEN==77>
IFGE <OHTLEN-100>,<PRINTX OHTLEN MUST BE LESS THAN 100 OCTAL>

OHTMAX==OHTLEN-1		;MAX INDEX POSSIBLE


	ENDOHT==1B<^L<OHTMAX>-1>-1	; ALL ONES IN FIELD IS END SIGNAL.

;BITS IN OHT

XP OHTDER,(1B0)		;DEVICE ERROR
XP OHTDTE,(1B1)		;DATA ERROR
XP OHTPAR,(1B2)		;PARITY ERROR ON DIRTY CORE PAGE.

OHTLNM==<ENDOHT>B8	;MASK FOR LINK FIELD
OHTLNP==^L<OHTLNM&-OHTLNM> ;RIGHTMOST BIT OF FIELD
OHTLNS==OHTLNP-^L<OHTLNM>+1

OHTDPM==777,,777777	;FOR THE RECORD, DISK PAGE MASK.

OHTHPW==^D36/OHTLNS	;NUMBER OF HEADER POINTERS PER WORD.
OHTNUM::0
OHTREP:	0		;Count of repeat calls for same DP

OHTBYT:

	ZZ==OHTLNS
REPEAT OHTHPW,<
	POINT OHTLNS,OHTHED,ZZ-1
	ZZ==ZZ+OHTLNS>
OHTHED:	BLOCK	<OHTLEN+OHTHPW-1>/OHTHPW ;HEADER BYTES.
OHTTAB::BLOCK	OHTLEN
OHTCPN:	BLOCK	<OHTLEN+1>/2	;Halfword Core Page Number entries
	END
 g{\ç