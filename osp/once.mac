TITLE ONCE - ONCE ONLY INITIALIZATION AND OPERATOR DIALOGUE

EXTERN	REYDCA,DCNYUR,REYDCM,DCNYMN,RESTRT,REONCE,RESCOD,REPSID
EXTERN	RE.OND,RECOMP,RE.ONA,ONCMOD,DCFULL,DCNYOP,DCN.OP,DCN

;DETERMINE CTY SPEED

ONCGO:	JSR	APRINI		;MAKE SURE APR IS SETUP RIGHT
	LDB	T1,REYDCA	;COPY USER SELECTED
	DPB	T1,ONCMOD+DCNYUR-%OND	; DSKCLN TYPE
	LDB	T1,REYDCM	;COPY MONITOR SELECTED
	DPB	T1,ONCMOD+DCNYMN-%OND	; DSKCLN TYPE
	MOVE	T1,RESTRT	;COPY RESTRT WORD TO PRESERVE
	MOVEM	T1,ONCMOD+REONCE-%OND	; FLAGS AND VALIDATOR
	SETZM	RESTRT		;CLEAR JUST IN CASE
	SETZM	CRSHWD		;CLEAR HERE IN CASE CLOCK GOES OFF
				; (ON NON-F3 MACHINES WE MADE IT THROUGH FOR SOME REASON)
	MOVEI P,SYSPDL		;GET A PDL SETUP
	IFCPU (KL),<JSR SPCINI>	;ENTER SECONDARY PROTOCOL IF HAVEN'T ALREADY
	JSR MOVSTP		;MAKE SURE SYMBOL TABLE PTR MOVED
	MOVEI T3,0	;THIS WILL COUNT THE NUMBER OF CLOCK TICS
IFCPU (<KI,F3>),<
	CONSO APR,APRCLK	;WAIT FOR A CLOCK TIC
	JRST .-1
IFCPU (KI),<	WRAPR APRCLK>		;CLEAR THIS ONE
IFCPU (F3),<WRAPR LP.CSF+APRCLK>
	DATAO TTY,T3		;SEND THE ZERO
CTYSP1:	CONSO TTY,TT.OB		;IS IT DONE
	JRST CTYSP2		;YES
	CONSO APR,APRCLK	;DID CLOCK TIC
	JRST CTYSP1		;NO
IFCPU (KI),<	WRAPR	APRCLK>		;YES, CLEAR
IFCPU (F3),<WRAPR LP.CSF+APRCLK>
>;END IFCPU (<KI,F3>)
IFCPU (KL),<
	SETZB	T1,EPT+SPCMTD
	CONO	TIM,TO.CIT	;CLEAR TIMER
	CONO	TIM,TO.SIT!^D1666	;START TIMER
	MOVEI	T3,.DTCTO		;SEND NULL CHAR
	MOVEM	T3,EPT+SPCCMW
	CONO	DTE,TO11DB
CTYSP1:	EXCH	T1,EPT+SPCMTD		;CHECK FOR OUTPUT DONE
	JUMPN	T1,CTYSP2
	CONSO	TIM,TI.ITD		;TIMER TICKED YET?
	JRST	CTYSP1			;NO, KEEP WAITING
	CONO	TIM,TO.CTD!TO.SIT!^D1666 ;RESTART TIMER FOR NEXT TICK
>;END IFCPU (KL)
IFCPU (KS),<
	WRINT	ITMTIM		;SET TICK
	MOVEI	T3,CTYOVL	;SET VALID FLAG
	MOVEM	T3,CTYOWD##	;STORE IN 8080 OUTPUT WORD
	WRAPR	LP.SSF+LP.I8C	;INTERRUPT 8080 CONSOLE
CTYSP1:	HRRZ	T1,CTYOWD##	;CHARACTER TAKEN YET?
	JUMPE	T1,CTYSP2	;YES
	CONSO	APR,LP.ITD	;TIMER TICKED YET?
	JRST	CTYSP1		;NO KEEP WAITING
	WRINT	ITMTIM		;RESTART TIMER FOR NEXT TICK
>;END IFCPU (KS)
	AOJA T3,CTYSP1		;AND COUNT

CTYSP2:	MOVEI T1,0
	CAIGE T3,5
	MOVEI T1,2		;2 FILLS FOR 150CPS
	CAIGE T3,3
	MOVEI T1,5		;5 FILLS FOR 300CPS
	MOVEM T1,CTYFIL		;SAVE IN FILL NUMBER CELSS (IN SCNSER)

COMMENT # DESCRIPTION OF MONITOR PHYSICAL LAYOUT DYNAMICS

IT IS ASSUMED THAT THE MONITOR TAKES UP LESS THAN 256K OF MEMORY
TOTAL (INCLUDING ALL DYNAMICALLY ALLOCATED SPACE). IF THE MONITOR
TOOK UP MORE THAN THIS, IT WOULD HAVE TO SHARE SOME OF ITS VIRTUAL
PAGES TO ACCESS PHYSICAL PAGES IN MEMORY, WHICH IS NOT PRESENTLY
DONE.
IT IS ALSO ASSUMED THAT THE TOP OF THE SYMBOL TABLE IS LESS THAN
340000. IN THE FUTURE, THIS RESTRICTION COULD BE LIFTED
IF THE EXEC PER PROCESS PAGES WERE USED TO ACCESS THE SYMBOL TABLE
UNTIL IT COULD BE MOVED DOWN UNDERNEATH 340000 (IF THAT WAS
POSSIBLE.)

WHEN THE MONITOR IS FIRST LOADED INTO CORE BY THE BOOTSTRAP PROGRAM,
THE LAYOUT OF PHYSICAL MEMORY IS:

	SYMBOLS
	ONCE CODE
	DDT
	DEBUG
	PATCH			<--- SYSSIZ
	MONITOR CODE + ASSEMBLED TABLES

THE ONCE ONLY CODE MUST APPEAR LAST IN PHYSICAL MEMORY SO THAT IT
CAN BE REUSED AFTER THE SYSTEM IS INITIALIZED. THEREFORE,
THE MONITOR SCANS MEMORY UP TO 256K FOR THE FIRST NON-EXISTENT
LOCATION. THE ONCE CODE IS THEN LOCATED DIRECTLY UNDERNEATH
THIS LOCATION TO ALLOW THE MAXIMUM AMOUNT OF SPACE UNDER ITSELF
FOR THE MONITOR. THE ENTIRE MONITOR MUST FIT WITHIN THE
FIRST CONTIGUOUS BLOCK OF MEMORY.

THE ONCE CODE THEN CHECKS TO SEE IF IT CAN BLT ITSELF UP
TO THE TOP OF THE FIRST CONTIGUOUS BLOCK OF MEMORY WITHOUT
OVERWRITING THE SYMBOL TABLE. (IF IT CANNOT, A MESSAGE IS
PRINTED ON THE CONSOLE AND THE MONITOR CRASHES.)
THE ADDRESS SPACE THEN LOOKS LIKE THIS:

	ONCE TEMP. PGY, PCB, DDB
	ONCE CODE
	<BLANK AREA>
	SYMBOLS
	ONCE CODE
	DDT
	DEBUG
	PATCH			<--- SYSSIZ
	MONITOR CODE

THE ONCE CODE IS PHASED TO USE HIGH EXEC VIRTUAL LOCATIONS.
AFTER ONCE IS BLTTED TO ITS NEW LOCATION, MAP SLOTS ARE SET
UP FOR THE PROPER EXEC VIRTUAL PAGES, AND ONCE IS EXECUTED FROM THERE.

THEN ONCE CODE BLTS THE SYMBOLS DOWN TO THE TOP OF DDT.
(IT IS ASSUMED THAT DDT IS THE LAST MODULE IN THE MONITOR
BEFORE THE ONCE CODE).

	ONCE TEMP. PGY, PCB, DDB
	ONCE CODE
	<BLANK AREA>		<--- SYSSIZ IF DDT LOADED
	SYMBOLS
	DDT
	DEBUG
	PATCH			<--- SYSSIZ IF DDT NOT LOADED
	MONITOR CODE

ONCE THEN ALLOCATES SPACE FOR THE PGY TABLES, CHT, CALLS LINKDB
TO ALLOCATE THE MISCELLANEOUS DYNAMIC SPACE, THEN ALLOCATES
THE PCB TABLES AND PCB CORE PAGES.

	ONCE PCB, PGY, DDB
	ONCE CODE
	<POSSIBLY BLANK>		<--- SYSSIZ
	PCB PAGES
	PCB TABLES
	FREE CORE
	FREE CORE BIT TABLE
	FILSER CORE
	<SNOOP HISTOGRAM TABLE IF INCLUDED>
	LDB
	TTY CHUNKS
	TMPCOR
	DDBS
	CHT
	PGY TABLES	(LOWEST TABLES ACCESSED THRU EXEC VIRTUAL SPACE)
	STT TABLES	(ACCESSED THROUGH UNMAPPED AREA)
	<SYMBOLS IF LOADED>
	<DDT IF LOADED>
	<DEBUG IF DDT LOADED>
	<PATCH IF DDT LOADED OR PATSIZ UPDATED>
	MONITOR
# ;END COMMENT
;FIND OUT WHERE THE END OF THE FIRST CONTIGUOUS BLOCK OF MEMORY
; IS.
IFNCPU (F3),<

	WRAPR	CLRNXM		;CLEAR NXM FLAG
	MOVNI	T3,1000*^D16	;TEST REGISTER, ADDED TO BEFORE TEST
	MOVEI	T1,1000/^D16	;NUMBER OF 8K MODULES TO TEST
PTLP1:	ADDI T3,1000*^D16	;CHECK EVERY 16 PAGES (8K)
	MOVE	T2,20(T3)		;TEST LOC 20 (AVOID ACS)
	CONSZ	APR,APRNXM	;END OF MEM?
	JRST	PTLPD		;DONE,	STORE MEMSIZ AND HGHBLK FOR NOW.
	MOVE	T2,21(T3)
	MOVE	T2,22(T3)
	MOVE	T2,23(T3)		;IN CASE BAD INTERLEAVE
	CONSZ	APR,APRNXM	;IS IT?
	JRST	PTINTR		;YES, INTERLEAVE AND BOX OFF-LINE
	SOJG	T1,PTLP1		;TEST FOR 1000 PAGES
	ADDI	T3,1000*^D16
>;END IFNCPU (F3)
IFCPU (F3),<
	MOVSI	T3,1		;F3 ALWAYS HAS 512K, SO 256K IS ALWAYS THERE.
>;END IFCPU (F3)
PTLPD:	MOVEM T3,MEMSIZ		;STORE SIZE OF CORE (FOR NOW)
	LSH	T3,-9		;
	MOVEM	T3,HGHBLK	;
;NOW BLT ONCE, ONCDSK, AND REFSTR (FIRST MAKE SURE THEY FIT.)
;AND THEN SET UP AN AREA OF THE MAP TO POINT TO THEM.

COMMENT # LAYOUT OF EXEC VIRTUAL ADDRESS SPACE AFTER ALL THIS IS DONE:


VIRTUAL ADDRESS SYMBOLS AND LOCATIONS
(LISTED IN ORDER OF DECREASING VIRTUAL ADDRESSES)

		START				LENGTH

ONCE CODE	%ONC
ONCE PCB PAGES	BOTTM				NMOCPC*1000
ONCE DDB	BOTTM-ONCDDS+CNTPGY*NMOCPC	DDBLEN
PGY TABLES	BOTTM-ONCDDS			CNTPGY*NMOCPC

PHYSICAL ADDRESS LOCATIONS
(LISTED IN ORDER OF DECREASING PHYSICAL ADDRESS)

		START				END

ONCE PCB PAGES	C(MEMSIZ)-NMOCPC*1000		C(MEMSIZ)-1
<EMPTY SPACE>
ONCE DDB	END OF PGY + 1			BEG + DDBLEN
ONCE PGY	BEG OF PCB PAGES - ONCDDS	BEG + CNTPGY-NMOCPC
ONCE CODE

NOTE THAT THE ONCE CODE OCCUPIES THE HIGHEST VIRTUAL ADDRESS
LOCATIONS, BUT THE LOWEST PHYSICAL ONES.
#;END COMMENT.
ONCPYP==<<CNTPGY*NMOCPC>+DDBLEN+777>/1000
ONCDDS==1000			;[cab] This is the resolution!
;ONCDDS==ONCPYP*1000		;EXTRA SPACE AT TOP OF CORE TO ALLOCATE
				; ONCE ONLY PGY TABLES AND DDB.

	HLRO	T1,DDTSYM	;GET SIZE OF SYMBOL TABLE
	HRRZ	T2,DDTSYM	;AND START LOC.
	CAMGE	T2,PATSIZ	;IS PATSIZ BIGGER?
	MOVE	T2,PATSIZ	;YES, USE THAT AS BASE
	SUB	T2,T1		;T2=1ST UNUSED LOC.
	SUBI	T2,1		;T2=LAST USED LOC.
	TRO	T2,777		;GET TO A PAGE BOUNDARY.
	CAILE	T2,337777	;HAD BETTER FIT IN UNPAGED MEMORY
	JRST	PDDTNF		;DOES NOT.
	ADD	T2,TBLLNP	;ADD IN SIZE OF REFSTR,
	ADD	T2,TBLLNP+1	;ONCDSK, AND
	ADD	T2,TBLLNP+2	;ONCE.
	ADDI	T2,<NMOCPC*1000>+ONCDDS
	CAML	T2,MEMSIZ	;DOES ONCE + ONCE PCB, PGY, DDB FIT?
	JRST	PTSML		;NO, GO TYPE OUT THE PROBLEM.
	MOVEI	T2,1		;YES,  DO THEY FIT IN THE MAP?
BLTCK:	MOVE	T1,TBLLNP(T2)	;GET SIZE, ROUNDED UP TO A PAGE.
	ADD	T1,TBL%%%(T2)	;ADD IN ORIGIN.
	CAMLE	T1,TBL%%%+1(T2)	;PAST NEXT ORIGIN?
	JRST	BLTBAD		;YES, DIE.
	SOJGE	T2,BLTCK	;NO, GO TO NEXT CHECK.

;EVERYTHING FITS. NOW BLT AND SETUP MAP SLOTS.


	MOVEI	T1,3		;LENGTH OF BLT TABLE.
	MOVE	T2,MEMSIZ	;FIRST NON-EXIST LOCATION
	SUBI	T2,NMOCPC*1000+ONCDDS ;GET LAST LOCATION OF ONCE CODE
				; ITSELF + 1
BLTLP:	SUB	T2,TBLLNP-1(T1)	;T2=NEW START LOC.
	MOVE	P1,T2		;SAVE IT.
	HRL	T2,TBLSTT-1(T1)	;T2/OLD START,,NEW START.
	HLRZ	T3,TBLLNR-1(T1)	;SET UP T3 AS
	ADDI	T3,-1(T2)		;THE REAL END.
	BLT	T2,(T3)		;BLT.

    ;MAKE MAP ENTRIES FOR THIS MODULE.
	MOVE	U,TBLLNP-1(T1)	;GET U=
	LSH	U,-9		;THE NO. OF MAP ENTRIES.
	MOVE	T3,TBLNEW-1(T1)	;T3/BYTE POINTER.
	MOVE	T2,P1		;T2=
	LSH	T2,-9		;1ST REAL PAGE NO.
MAPLP:	TRO	T2,PGE.A!PGE.W!PGE.C ;MAKE IT A MAP ENTRY.
	IDPB	T2,T3		;INTO THE MAP WITH IT.
	TRZ	T2,PGE.A!PGE.W!PGE.C	;T2=
	AOJ	T2,.+1		;NEXT REAL PAGE NO.
	SOJG	U,MAPLP		;CONTINUE TO MAP.

	MOVE	T2,P1		;T2=CURRENT TOP.
	SOJG	T1,BLTLP	;GO TO NEXT BLT.

;SETUP EPT LOCATIONS, AND ON KL THE MAP FOR "UNMAPPED" REGION.

	MOVSI	T1,(JFCL)	;SET
IFCPU (KI),<MOVEM	T1,EPT+420>	;TRAP LOCS
	MOVEM	T1,EPT+421	;IN
	MOVEM	T1,EPT+422	;THE
	MOVEM	T1,EPT+423	;EPT.
IFNCPU (KI),<MOVEI	T1,PGE.A+PGE.W+PGE.C+0
	MOVE	T2,[POINT 18,EPT+EPTMP0]	;BUILD A POINTER
EPTMAP:	IDPB	T1,T2		;MAP 0 TO 337
	CAIE	T1,PGE.A+PGE.W+PGE.C+337
	AOJA	T1,EPTMAP

DEFINE X(A,B)<
	MOVE	T1,['B,,'A]
	PUSHJ	P,CSHCLR
>;END X MACRO DEFINITION

;HERE IS THE LIST OF REGIONS THAT MUST BE UNCACHED.

>;END IFNCPU (KI)

IFCPU (KL),<
DEFINE UNCACHE<
EXTERNAL IRING,SIZIRG,ORING,SIZORG,SAXBAS,SAXN,CHNUNC,CHNUNE
X	IRING,<1_SIZIRG>
X	ORING,<1_SIZORG>
X	150,165-150+1	;BASE VECTOR
X	30,1		;BASE DTS IN PHYSICAL LOC 30
X	SAXBAS,SAXN+^D16 ;SA-10 VECTORS
X	CHNUNC,CHNUNE-CHNUNC+1 ;CHANNEL, UNIT DATA BLOCKS.
>;END UNCACHE MACRO DEFINITION

>;END IFCPU (KL)
IFCPU (KS),<
DEFINE UNCACHE<
EXTERNAL IRING,SIZIRG,ORING,SIZORG
X	IRING,<1_SIZIRG>
X	ORING,<1_SIZORG>
X	150,165-150+1	;BASE VECTOR
X	30,1		;BASE DEPOSITS IN PHYSICAL LOC 30
X	31,1		;CTY RELOAD WORD
X	32,1		;CTY INPUT WORD
X	33,1		;CTY OUTPUT WORD
>;END UNCACHE MACRO DEFINITION
>;END IFCPU (KS)

IFCPU (<KL,KS>),<
	UNCACHE			;TURN OFF PGE.C FOR PROPER PAGES.
>;END IFCPU (<KL,KS>)
IFCPU (KL),<

	MOVE	T2,[POINT 18,EPT+EPTMP0]
	MOVSI	T3,-4		;NEED 4 CACHED PAGES.
FNDCSP:	ILDB	T1,T2		;GET SLOT
	TRNN	T1,PGE.C	;THIS ONE CACHED?
	AOJA	T3,FNDCSP	;NO, LOOK FOR 1 THAT IS.
	MOVEI	T1,1000		;GET ADDRESS
	IMULI	T1,(T3)		;FROM PAGE NUMBER
	HLRE	T4,T3		;GET NUMBER
	MOVMS	T4		;POSITIVE VERSION
	HRRM	T1,CSRTAB-1(T4)	;DONT WIPE OUT (T1).
	AOBJN	T3,FNDCSP
>;END IFCPU (KL)
IFCPU (KI),<MOVE T1,[IG.LLH+NULACB_^D15+UPT.PN,,IG.LRH+IG.TEN+EPT.PN]>
IFNCPU (KI),<MOVE T1,[UPT.PN]>		;GET CURUPT UP SO CAN DO CLRPTA
	MOVEM	T1,CURUPT
IFCPU (KI),<WRUBR [IG.LRH+IG.TEN+EPT.PN]>
IFNCPU (KI),<MOVE	T1,EBRSET
	MOVEM	T1,EPT+EPTEBR
	CLRPTA		;SETUP EBR, TURN ON PAGING
>;END IFNCPU (KI)

	JSP	T4,OPCBST	;Set up special ONCE PCB's
        CLRPTA                  ;CLEAR PAGING MEMORY, MAP HAS CHANGED
	MOVEI	T1,ONCGOP	;STORE IN
	HRRM	T1,SYSDSP	;CASE OF RESTART
ONCBUG:	JRST	ONCGOP		;AND GO (GOOD PLACE FOR BREAKPOINT)


IFLE <<%REF-%OND>*<%OND-%ONC>>, <PRINTX ONCE'S TBLS DEF MUST BE ARRANGED LOWEST TO HIGHEST.>

EXTERN REFLNR,REFLNP,ONDLNR,ONDLNP,REFSTT,ONDSTT,SYSDRB

DEFINE TBLS
< X ONC
  X OND
  X REF>

;SIZE ROUNDED UP TO A PAGE.
DEFINE X(A)
< A'LNP>
TBLLNP: TBLS

DEFINE X(A)
<EPTPGP (%'A'.N-1)>
TBLNEW: TBLS

;REAL SIZE,, OLD STARTING LOC.
DEFINE X(A)
<A'LNR,,A'STT>
TBLSTT:
TBLLNR: TBLS

DEFINE X(A)
<%'A>
TBL%%%: TBLS
;HERE ARE THE ERROR ROUTINES

PTSML:	PUSH	P,T2	;SAVE AMOUNT NEEDED
	MOVEI T1,[ASCIZ /
MUST HAVE /]
	PUSHJ P,PAGTYP	;TYPE INFORMATION ON ERROR
	POP	P,T1
	LSH T1,-WRDSPP	;CONVERT TO PAGES
	PUSHJ P,PAGDEC
	MOVEI T1,[ASCIZ / CONTIGUOUS MEMORY PAGES ON LINE
TO LOAD THIS MONITOR, ONLY /]
	PUSHJ P,PAGTYP
	MOVE	T1,MEMSIZ
	LSH	T1,-WRDSPP	;CONVERT TO PAGES
	PUSHJ	P,PAGDEC
	MOVEI	T1,[ASCIZ / PAGES ON LINE BEFORE FIRST HOLE.
/]
	PUSHJ	P,PAGTYP
	HALT .

PTINTR:	MOVEI T1,[ASCIZ /
INTERLEAVE SET INCORRECTLY OR MEMORY BOX OFF-LINE
ADDRESS /]
	PUSHJ P,PAGTYP
	MOVEI T1,3
INTLP:	WRAPR CLRNXM
	ADDI T3,1
	MOVE T2,20(T3)
	CONSO APR,APRNXM
	SOJG T1,INTLP
	MOVE T1,T3
	PUSHJ P,PAGOCT
	MOVEI T1,[ASCIZ / (OCTAL)
/]
	PUSHJ P,PAGTYP
	HALT .

BLTBAD:	MOVEI T1,[ASCIZ /
ONCE CODE BLT BAD, NOTIFY OPERATING SYSTEMS
/]
	PUSHJ P,PAGTYP
	HALT .

PDDTNF:	MOVEI	T1,[ASCIZ/
VIRGIN MONITOR DOES NOT FIT WITHIN 340000(8) LOCATIONS.
NOTIFY OPERATING SYSTEMS GROUP.
/]
	PUSHJ	P,PAGTYP
	HALT	.

PAGTYP:	HRLI T1,(POINT 7,0)
PAGTY2:	ILDB T2,T1
	JUMPE T2,PAGPOP
	PUSHJ P,PAGTYO
	JRST PAGTY2

IFCPU (<KL,KS>),<EXTERNAL CTYTYO>

PAGOCT:	MOVEI T4,10
	JRST PAGDC1
PAGDEC:	MOVEI T4,^D10
PAGDC1:	IDIVI T1,(T4)
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,PAGDC1
	HLRZ T2,(P)
	ADDI T2,"0"
PAGTYO:	IFCPU (<KI,F3>),<CONSZ TTY,TT.OB
	JRST PAGTYO>
	PUSH P,T1
	EXCH T2,T3
	PUSHJ P,PEVEN8
	POP P,T1
IFCPU (<KI,F3>),<	EXCH T2,T3
	DATAO TTY,T2>
IFCPU (<KL,KS>),< PUSHJ P,CTYTYO
	EXCH	T2,T3>
	ANDI T2,177
	CAIN T2,15
	SKIPN T2,CTYFIL		;NEED TO FILL
PAGPOP:	POPJ P,
IFCPU (<KI,F3>),<	CONSZ TTY,TT.OB
	JRST .-1
	DATAO TTY,[377]
	SOJG T2,.-3>
IFCPU (<KL,KS>),<	MOVEI T3,377
	PUSHJ	P,CTYTYO
	SOJG	T2,.-1>
	POPJ P,

PATSYM:	JSR MOVSTP		;MOVE SYMBOL TABLE POINTER
	JRST DDTX		;AND START EXEC DDT

MOVSTP:	0
	MOVE T1,JOBSYM
	MOVEM T1,DDTSYM		;MOVE THE SYMBOL TABLE POINTER
	MOVEI T1,DDTX
	HRRM T1,SYSDDT	;MAKE FOR ANOTHER RESTART
	MOVE T1,[JRST @MOVSTP]
	MOVEM T1,MOVSTP+1	;DO THIS ONLY ONCE
	JRST @MOVSTP		;AND RETURN

SYSZRO:	SETZM DDTX
	MOVE T1,[DDTX,,DDTX+1]
	BLT T1,DDTEND-1
	MOVE T1,JOBSYM
	SETZM (T1)
	AOBJN T1,.-1
	MOVE T1,[HALT 142]
	MOVEM T1,142
	EXIT

;PROCESSOR AND CLOCK INITIALIZATION

APRINI:	0

IFCPU (KI),<JRST @APRINI>

IFCPU (<KL,F3>),<
	WRAPR	LP.IOR+LP.CSF+APRMSK	;CLEAR ALL FLAGS
	WRPI	LI.CPP+LI.CPS+LI.COF+LI.PIF+LI.ACO ;AND PI SYSTEM
IFCPU (KL),<
	SWPIA			;THROW AWAY BAD CACHE DATA
	CONSZ	APR,LP.CSB	;WAIT FOR SWEEP BUSY TO CLEAR
	JRST	.-1
	WRAPR	LP.CSF+LP.CSD	;AND NOW CLEAR SWEEP DONE.
>;END IFCPU (KL)
	DATAO	APR,[0]		;TURN OFF ADDRESS BREK
	MOVE	T1,[EPT,,EPT+1]
	SETZM	EPT
	BLT	T1,EPT+777	;CLEAR ENTIRE EPT OUT
IFCPU (F3),<
	EXTERNAL EPTACB
	MOVEI	T1,EPT+EPTACB
	MOVEM	T1,EPT+EPTACP
>;END IFCPU F3
	WREBR	EPT.PN	;SET EPT UP FOR CTY ROUTINES
	WRUBR	[LG.LUB+UPT.PN] ;SET UPT UP TO NULL JOB'S UPT
	MOVEI	T1,UUOKNT
	MOVEM	T1,UPT+UPTKNT	;IN CASE OF UUO ERROR
	MOVEI	T1,PGFAIL	;IN CASE OF PAGE FAIL
	MOVEM	T1,UPT+UPTNPP
	MOVEI	T1,UUOKTR	;IN CASE OF PDL OVERFLOW OR SOMETHING
	MOVEM	T1,UPT+UPTKTR
	MOVEI	T1,EXCPDL	;PDL OVERFLOW INSTRUCTION
	MOVEM	T1,EPT+EPTPOV	;AN MUUO THAT GOES TO UUOKTR.
	EXECAC			;USE EXEC MODE ACS
IFCPU (KL),<
	CONO	TIM,TO.CIT+TO.CTD	;CLEAR INTERVAL TIMER
	CONO	MTR,MO.LAC+MO.TOF+MO.CTB ;CLEAR TIME BASE, TURN ACCOUNTING OFF
>;END IFCPU (KL)
	MOVEI	T1,NUMACB-1	;HIGHEST AC BLOCK NUMBER TO START WITH
APRIN1:	CAIN	T1,EX0ACB	;SKIP OVER ONE WE'RE USING
	JRST	APRIN2		;DON'T TOUCH
	MOVSI	T2,(LG.LAB+<EX0ACB>B8)
	DPB	T1,[POINT 3,T2,11] ;PUT INTO PREVIOUS AC FIELD
	WRUBR	T2		;SET PREVIOUS ACS
	MOVEI	T2,1		;0,,1
	XCTBU	<SETZM 0>	;CLEAR OUT 0
	XCTBU	<BLT T2,17>	;AND THE REST
APRIN2:	SOJGE	T1,APRIN1	;AND GO FOR ALL AC BLOCKS

	EXECAC			;BACK TO EXEC ACS
IFCPU (KL),<
	MOVE	T1,[POINT 3,CSATAB]
	MOVSI	T2,-200		;HOW BIG CACHE REFILL TABLE IS.
CSALUP:	ILDB	T3,T1		;GET NEXT 3 BIT DATA
	LSH	T3,^D35-^D20	;GET IT TO BIT 20
	DPB	T2,[POINT 7,T3,33]
	WRFIL	(T3)
	AOBJN	T2,CSALUP	;GO FOR MORE.
>;END IFCPU (KL)
	JRST	@APRINI
> ;END IFCPU (<KL,F3>).

IFCPU (KS),<
	WRAPR	LP.IOR+LP.CSF+APRMSK	;CLEAR ALL FLAGS
	WRAPR	LP.DSF+LP.TIM		;DISABLE TIMER
	WRPI	LI.CPP+LI.CPS+LI.COF+LI.PIF+LI.ACO ;AND PI SYSTEM
	WRHSB	[HLTSTS##]	;SET THE ADDRESS FOR HALT STATUS BLOCK
	EXECAC			;USE EXEC MODE AC
	WREBR	EPT.PN		;SET UP EPT
	SETZM	RLWORD##	;BE SURE KEEP ALIVE FLAG OFF
	MOVEI	T1,6		;AVOID AC BLOCK 7, MICROCODE USES IT.
APRIN1:	CAIN	T1,EX0ACB	;SKIP OVER ONE WE'RE USING
	JRST	APRIN2		;DON'T TOUCH
	MOVSI	T2,(LG.LAB+<EX0ACB>B8)
	DPB	T1,[POINT 3,T2,11] ;PUT INTO PREVIOUS AC FIELD
	WRUBR	T2		;SET PREVIOUS ACS
	MOVEI	T2,1		;0,,1
	XCTTU	<SETZ 0,>	;CLEAR ALL THE ACS
	XCTTU	<BLT T2,17>	;
APRIN2:	SOJGE	T1,APRIN1	;AND GO FOR ALL AC BLOCKS

	EXECAC			;BACK TO EXEC ACS
	MOVEI	T1,EPT+1
	HRLI	T1,EPT
	SETZM	EPT
	BLT	T1,EPT+777	;CLEAR ENTIRE EPT OUT
	JRST	@APRINI
>;END IFCPU (KS)

IFCPU (<KL,F3>),<EBRSET:	LG.CSL+LG.CSW+LG.TEN+EPT.PN> ;LOCATION TO SET EPTEBR FROM - MUST BE IN UNPAGED AREA.
IFCPU (KS),<EBRSET: LG.TEN+EPT.PN>

IFNCPU (<KI,F3>),<
;ROUTINE TO CLEAR CACHE BITS FOR EXEC MAP WHICH STARTS AT
; EPTMP0. CAL WITH SIZE,,START ADDRESS IN T1.

CSHCLR::HLRZ	T2,T1		;GET SIZE IN T2
	ADDI	T2,-1(T1)	;GET LAST ADDRESS
	LDB	T1,[POINT 9,T1,26] ;GET START PAGE NUMBER
	LDB	T2,[POINT 9,T2,26] ;GET END PAGE NUMBER
	CAIG	T1,337		;PROTECT AGAINST STUPID CALLERS
	CAILE	T2,337
	STOPCD
	SUBI	T2,-1(T1)	;OK, GET NUMBER OF PAGES TO DO
	ROT	T1,-1		;GET PLACE IN EPTMP0 TO START, EVEN/ODD IN 1B0
	MOVEI	T3,PGE.C	;ASSUME ODD
	SKIPL	T1		;SKIP IF ASSUMPTION CORRECT
CSHCL1:	MOVSS	T3		;SWITCH SIDES
	ANDCAM	T3,EPT+EPTMP0(T1) ;CLEAR CACHE BIT
	TLCE	T1,(1B0)	;IF NEXT ONE IS EVEN,
	AOS	T1		;GO TO NEXT WORD
	SOJG	T2,CSHCL1	;IF ANY LEFT, GO.
	POPJ	P,		;DONE, RETURN.

;DATA FOR LOADING 4 CACHE REFILL ALGORITHM

CSATAB:	012345673123
	212371271127
	656755670323
	022301234567
	077700074666
	446431331113
	077700070123
	456745574547
	012201210566
	056045654564
	012345670000
> ;END IFNCPU (<KI,F3>).
	LIT
	VAR
;HERE IS THE CODE WHICH GETS MOVED TO THE TOP OF CORE.

ONCSTT:				;DEFINE "OLD" STARTING LOC.

	PHASE	%ONC

;HERE ARE THE TEMPORARY "PCBS" FOR ONCDSK AND REFSTR.
; PAGE NUMBERS GET FILLED IN AFTER IT IS DETERMINED WHERE ONCE CODE WILL
; LIVE IN PHYSICAL MEMORY.
INTERNAL ONCPCB
ONCPCB:

CCOUNT==NMOCPC

DEFINE X (A)
<INTERNAL %'A'.P
%'A'.P:	Z
Z
Z
CCOUNT==CCOUNT-1
IFE CCOUNT,<Z>
IFN CCOUNT,<EXP %'A'.P+4>
>

OPCNAM



;HERE IS THE TABLE OF PCB ADDRESSES.

DEFINE X (A)
<XWD 0,%'A'.P
>

OPCBTB:
OPCBTB:	OPCNAM
Z
;HERE IS A LIST OF VIRTUAL ADDRESSES WHICH CORRESPOND TO
; THE INDEX INTO OPCBTB, FOR USE IN CONVERTING PCB ADDRESS
; INTO VIRTUAL ADDRESS TO LOOK IN FOR DATA.

DEFINE X (A)
<EXP %'A'
>;END MACRO DEFINITION
OPCADR:	OPCNAM



;HERE IS THE TABLE OF MAP SLOT POINTERS FOR THE PCBS.

DEFINE X (A)
<EPTPGS(%'A'.N,EPT)>

MPSLOT:
OPCNAM



ONCDDB::0			;LOCATION OF ONCE ONLY DDB THAT ONCDSK USES.
OPCLOW:	0			;LOWEST PHYSICAL PAGE USED FOR ONCE PCB PAGES.

IFCPU (KS),<
EUBRBT:	EPT+EPTUB0,,EPT+EPTUB1	;BLT WORD TO SETUP VECTOR INTERRUPT TBLS
    >; END IFCPU (KS)
EPGTBT:	EPTSET,,EPT+EPTPGT
UPGTBT:	UPTSET,,UPT+UPTPGT
EPIBLT:	LOC40,,EPT+42		;BLT WORD TO SETUP PI LOCS 40-61
CNCLBT:	CONFIG,,CONFIG+1	;BLT POINTER TO CLEAR CONFIG AREA
CNFCPY:	CONFIG,,CPYFIG		;BLT POINTER TO COPY CONFIG NAME/DATE
CPYBPT:	POINT 7,CPYFIG		;BYTE POINTER TO COPY OF CONFIG AREA
CNFBPT:	POINT 7,CONFIG		;BYTE POINTER TO CONFIG NAME/DATE

ONCWBR:
    IFCPU (KI),<XWD IG.LLH+NULACB_^D15+UPT.PN,IG.LRH+IG.TEN+EPT.PN>
    IFNCPU (KI),<EXP LG.LUB+UPT.PN>
ONCACB:
    IFCPU (KI),<XWD <UPTAC0-20>_9,%UPT+UPTAC0+17>
    IFNCPU (KI),<EXP LG.LAB+<EX0ACB>B8+<USRACB>B11+%UPT+UPTAC0+16>

;ROUTINE WHICH TAKES A PCB ADDRESS IN PG AND RETURNS THE VIRTUAL ADDRESS
; OF THE PCB'S DATA IN T2.
;CALLED BY ONCDSK. PRESERVES ALL ACS.

GETPEV::PUSH	P,T4		;PRESERVES ALL ACS
	SETZ	T4,
GETPE1:	SKIPN	T2,OPCBTB(T4)	;GET PCB ADDRESS
	STOPCD
	CAME	PG,T2		;SAME?
	AOJA	T4,GETPE1	;NO, LOOK AT NEXT.
	MOVE	T2,OPCADR(T4)	;YES, GET ADDRESS
	POP	P,T4		;RESTORE T4 AND
	POPJ	P,		;RETURN.
;NOW MOVE THE SYMBOL TABLE DOWN

ONCGOP:	MOVEI	P,SYSPDL
	MOVEI	T1,DDTEND+100	;LEAVE SOME EXTRA SPACE
	CAMGE	T1,PATSIZ	;MAKE SURE SOMEONE NOT TRYING TO RESERVE SPACE
	HRRZ	T1,PATSIZ	;THEY ARE, USE THAT AS PLACE TO BLT SYMBOLS TO
	HRL	T1,DDTSYM	;PLACE TO BLT SYMBOLS FROM
	HRRM	T1,DDTSYM	;STORE NEW HOME ADDRESS FOR SYMBOL TABLE
	HLRE	T2,DDTSYM
	MOVNS	T2		;GET SIZE OF SYMBOL TABLE
	ADDI	T2,-1(T1)	;GET LAST ADDRESS IN T2
	HLRZ	T3,T1		;GET SOURCE ADDRESS
	CAILE	T3,(T1)		;MAKE SURE ITS BEING BLTTED DOWN
	JRST	ONCG1A		;YES, JUST NORMAL BLT
	ADDI	T3,(T2)		;1ST SOURCE + LAST DEST - FIRST DEST
	SUBI	T3,(T1)		;GIVES LAST SOURCE.
SYMBK0:	MOVE	T4,(T3)		;MOVE SOURCE TO DEST
	MOVEM	T4,(T2)
	SUBI	T3,1		;SUBTRACT ONE FROM SOURCE ADDRESS
	CAIE	T2,(T1)		;DID JUST MOVE ONE TO FIRST DEST?
	SOJA	T2,SYMBK0 	;NO, KEEP GOING
	JRST	ONCGP0		;OK, DONE.
ONCG1A:	BLT	T1,(T2)		;HERE IS WHERE END GOES
ONCGP0:	MOVEI	T1,ONCGP1		;DO NOT EXECUTE MORE THAN ONCE
	HRRM	T1,SYSDSP
ONCGP1:	MOVEI	P,SYSPDL
	WRAPR	APRIOB		;DO AN IOB RESET
IFCPU (KI),<WRPI	PIPOW>		;AND RESET PI POWER FAILURE INTERUPT
IFNCPU (KI),<WRAPR	LP.CSF+LP.PWF>
	MOVE	T1,UPGTBT
IFNCPU (KS),<BLT  T1,UPT+UPTPTR>	;SET UP TRAPS LOCS
IFCPU (KS),<BLT  T1,UPT+UPTCTR+2>	;
IFNCPU (KI),<
	MOVE	T1,PGFUIO	;PAGE FAIL NEW PC
	MOVEM	T1,UPT+UPTNPP	;PAGE FAIL NEW PC WORD.
>;END IFNCPU (KI)
	MOVE	T1,EPGTBT	; EPT-PGT BLT WORD
	BLT	T1,EPT+EPTTR3	;BLT
	MOVE	T1,[JSR SYSCRS]
	MOVEM	T1,EPT+41	;NO LUUOS
	MOVEI	T1,UPT.PN+PGE.A+PGE.W+PGE.P+PGE.C
	DPB	T1,EPYPSN	;SET POINTER [EPTPTR(%UPS.N)]
	SETZM	UPSJOB		;NO ONE IS MAPPED THRU HERE.
	WRUBR	ONCWBR
	DPB	T1,USYPTN	;AND SET IN UPT [UPSPTR(%UPT.N)]
	CLRPTA			;MAPPING GOES INTO EFFECT.
	MOVE	T1,ONCACB
	MOVEM	T1,UPT+UPTACP
	JRSTF	@[PC.UIO,,.+1]	;MAKE SURE USER I/O IS ON
IFCPU (KI),<
	MOVSI	17,NULACS
	XCTTU	<BLT 17,17>	;LOAD NULL JOB ACS
	MOVSI	T1,PC.UIO!PC.USR!PC.PUB	;SET NULL PC (LOC 0)
	MOVEM	T1,UPT+UPTPC
>;END IFCPU (KI)
IFCPU (KI),<
	RDEBR	T1	;READ PAGER TO GET REAL SERIAL NUMBER
	LDB T1,[POINT 10,T1,9]
>;END IFCPU (KI)
IFNCPU (KI),<
	APRID	T1	;GET SERIAL NUMBER, UCODE VERSION, ETC.
	ANDI	T1,APRSER	;JUST SERIAL NUMBER
>;END IFNCPU (KI)
	MOVEM T1,SERIAL
	MOVEI T1,^D60
IFCPU (KI),<;NON-KI10 MACHINES ALWAYS 60HZ
	RDAPR	T2
	TLNE T2,(1B6)		;CHECK FOR 50 HZ
	MOVEI T1,^D50
>;END IFCPU (KI)
	MOVEM T1,JFYSEC
	IMULI T1,^D60
	MOVEM T1,JFYMIN
	IMULI T1,^D60
	MOVEM T1,JFYHR
	IMULI T1,^D24
	MOVEM T1,MIDNIT
	MOVE T1,JFYSEC
	MOVSI T2,(1B6)
	CAIE T1,^D60
	IORM T2,STATES		;SET STATES BIT IF 50 CYCLE
	IMULI T1,2
	MOVEM T1,JFY2SC
	IDIVI T1,^D24
	MOVEM T1,JFYS12
	MOVE	T1,JFYSEC
	IDIVI T1,2
	MOVEM T1,JFYSC2
	IDIVI T1,5
	MOVEM T1,QQYTTY
	MOVEM T1,QQYSD

;SETUP LOCATIONS 40 THRU 61

	MOVE T1,EPIBLT		;SETUP LOWER CORE PI LOCATIONS
	BLT T1,EPT+57
IFCPU (<KL>),<MOVSI T1,(HALT)
	MOVEM T1,EPT+EPTITI
IFCPU (KL),<	MOVEM T1,EPT+EPTDT0+DTEDII>
>;END IFCPU (<KL>)

;LINK DEVICE SERVICE ROUTINES TOGETHER (INTERUPT CHAIN)

	MOVSI T1,INTNUM	;NO, NEGATIVE NUMBER OF SERVICE ROUTINES*2
INTLOP:	HLRZ U,INTTAB(T1)	;GET NEXT PI NUMBER
	ANDI U,7		;MASK OUT NUMBER OF DDB'S

	LSH U,1		;SHIFT LEFT ONE SO MATCH PI LOCATIONS
	JUMPE U,NOPICH	;DOES THIS DEVICE HAVE A PI CHANNEL (PTY) ?
	MOVE J,EPT+40(U)	;YES, PICK UP JSR CH'N FROM LOWER CORE
INTLP1:	MOVE U,J		;SAVE IT IN U (EITHER A JRST DEV'NT OR
				; JEN @CH'N
	MOVE J,1(U)	;PICK UP INSTR. FOLLOWING INTERRUPT CONSO
	TLNN J,000740	;IS IT A JEN ?
	JRST INTLP1		;NO, KEEP LOOKING
	MOVE T2,INTTAB(T1)	;YES, LAST DEVICE SO FAR, GET DEV'NT
	HRLI T2,(JRST)	;MAKE JRST INSTR.
	MOVEM T2,1(U)	;CHANGE JEN @CH'N TO JRST DEV'NT
	MOVEM J,1(T2)	;MAKE DEV'NT+1 BE JEN @CH'N
NOPICH:	AOBJN T1,.+1		;PICKUP EVERY OTHER WORD
	AOBJN T1,INTLOP	;ANY MORE INTERRUPT SERVICE ROUTINES ?

IFCPU (KS),<

EXTERN TBISAV,TBISIZ
    ;SET UP TBLUBA FOR THE KS.
	MOVSI	T1,-TBISIZ	;Number of vectors in table
SETUBT:	HRRZ	T2,TBISAV(T1)	;GET VECTOR/4.
	MOVSI	T3,(JSR)	;BUILD JSR DEVINT.
	HLR	T3,TBISAV(T1)	;GET INTERRUPT ROUTINE ADDRESS.
	SKIPE	EPT+EPTVIT(T2)	;BETTER NOT BE ANOTHER WITH
	  STOPCD
	MOVEM	T3,EPT+EPTVIT(T2) ;SAME DISPATCH LOCATION.
	AOBJN	T1,SETUBT	;Loop TBISIZ times

    ;SET UP THE EPT SLOTS FOR THE VECTOR INTERRUPT TABLE PNTRS.
	SETZM	EPT+EPTUB0	;HOPE STRANGE ONES DIE IN LOW CORE.
	MOVE	T1,EUBRBT
	BLT	T1,EPT+EPUB17
	MOVEI	T1,EPT+EPTVIT	;ONLY UBA1 AND 
	MOVEM	T1,EPT+EPTUB1	;UBA3
	MOVEM	T1,EPT+EPTUB3	;PRESENTLY EXIST.

;NOW SET THE UBA1'S PIA

EXTERNAL PIHIGH,PILOW

	MOVEI	T1,PIHIGH*10+PIHIGH
	WRIO	T1,@[UA1,,UBAADR]

;NEED TO PUT IN UBA3'S AT SOME TIME


> ;END IFCPU (KS).


	MOVEI T1,ONCGP2
	HRRM T1,SYSDSP	;ONLY DO THIS ONCE
EXTERNAL OHTINI

ONCGP2:	MOVEI P,SYSPDL
	PUSHJ P,ONCTOS		;SET UP TTY
	PUSHJ	P,OHTINI	;INIT THIS HERE SO OUTPUT ERROS
				; ARE CLEARED ON RESTART.
	PUSHJ P,CRLF
	MOVEI T1,CONFIG
	PUSHJ P,CONMES
	MOVEI T1,[ASCIZ / /]
	PUSHJ P,CONMES
	MOVEI T1,SYSDAT
	PUSHJ P,CONMES
	MOVEI T1,[ASCIZ / MONITOR JUST LOADED
/]
	PUSHJ P,CONMES
	PUSHJ P,OPOUT
	PUSHJ	P,GETSYN	;SETUP SYSNUM FOR TTYINI, EVERYONE ELSE.
	HLRO T1,DDTSYM		;GET SIZE TO USE FOR SYSSIZ
	MOVNS T1
	ADD T1,DDTSYM
        IORI  T1,777            ;START WITH A FRESH PAGE
        ADDI T1,1
	HRRZM T1,SYSSIZ		;THIS IS IT, TOP OF SYMBOLS
IFCPU (KI),<;ONLY KI HAS DK10 UCYCLE CLOCK
CHKCLK:	CONSZ CLK,1B26
	JRST ONCTST	;ON EXTERNAL
	PUSHJ P,INLMES
	ASCIZ /
CLOCK ON INTERNAL - RESET AND TYPE <RETURN>
/
	PUSHJ P,OPOUT
	PUSHJ P,GETLIN
	 JRST CHKCLK
	JRST CHKCLK
>;END IFCPU (KI)
;THIS IS THE MAIN SCAN DISPATCH ROUTINE.
;NOTE *** This is different than the macro copied from ONCDSK!!!

EXTERNAL CMDSCN,CMDSCF			; Routine is in ONCDSK, Flag word
	DEFINE SCAN (A) <
	MOVEI	P1,SCN'A		; Get address of Scan Table
	SETZM	CMDSCF			; Specify NO STR/UNIT stuff
	PUSHJ	P,CMDSCN		; Call Scanning routine
	  JRST	HLP'A			; No good!
	XCT DSP'A'(P3)			; Yes?
	JRST	A'CMD			; Return as if cr typed.

A'HLP:	MOVE	P3,-2(P1)		; Setup AOBJN pointer for messages
A'HL1:	HRRZ	T1,(P3)			; Get address of message
	PUSHJ	P,LNGMES		; Print a long message
	AOBJN	P3,A'HL1		; Next?
	JRST	A'CMD			; Return.
>

	DEFINE SCNTB (NAM) <
	DEFINE X(SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	INS>	;INSTRUCTION TO EXECUTE

	JRST NUL'NAM		;FOR -1 RETURN
DSP'NAM: MK'NAM			;GENERATE DISPATCH TABLE
	SIZ'NAM==.-DSP'NAM
	-SIZ'NAM,,TXT'NAM	;AOBJN POINTER TO HELP
	-SIZ'NAM,,SCN'NAM	;AOBJN POINTER TO NAMES
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	<SIXBIT /SYM/>>
	LALL
SCN'NAM: MK'NAM			; Define Table to read
	SALL
	$XZ==0			; Need a counter
	DEFINE XZ$(ARGH)<LIT$'ARGH==.>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	xz$(\$XZ)
	ASCII \TEXT'TEXT1'TEXT2'TEXT3\
	Z
	$XZ==$XZ+1>
	MK'NAM
	$XZ==0
	DEFINE XZ$(ARGH)<LIT$'ARGH>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	XWD	BIT,XZ$(\$XZ)
	$XZ==$XZ+1>
	LALL
TXT'NAM: MK'NAM
>
INTERN	AB.ACK,AB.NAK,AB.VER,AB.TCV,AB.CVR

	AB.ACK==0B18		; OK (ACKnowledged) for ABbreviations.
	AB.NAK==1B18		; OK (Not AcKnowledged) for ABbreviations.
	AB.VER==1B19		; VERIFICATION required for Command.
	AB.TCV==1B20		; Verify if TYPE or CHANGE (TYPONL) [ONCDSK]
	AB.CVR==1B21		; No verify if at CONSOLE level

;The above code falls into here, so don't assume you
;can put anything between them. /CAB

;NOW THE ACTUAL CODE

ONCTST:
IFCPU (<KL,F3>),<WRAPR	LP.ESF+APRMSK+APRCHN	;ENABLE FOR SAKE OF PARITY ERRORS AND CACHE SWEEP DONE.
	WRPI	LI.PIN+LI.CON+<1_<7-APRCHN>> ;ALOW APR TO INTERRUPT.
>;END IFCPU (KL)
IFCPU (KS),<WRAPR	LP.ESF+APFMSK+LP.HPE+APRCHN	;ENABLE FOR ERRORS
	WRPI	LI.PIN+LI.CON+<1_<7-APRCHN>>	;ALLOW APR TO INTERRUPT
>;END IFCPU (KS)
	MOVSI 	T1,400000
	HRRI 	T1,1
	MOVEM 	T1,THSDAT
	SETZM 	TIME		;TIME AND DATE NOT RECIEVED FROM SUP
	MOVE	T2,REONCE	;GET ONCE COPY OF RESTRT WORD
	HLRZ	T1,T2		;POSITION VALIDATOR FOR TESTING
	CAIN	T1,RESCOD	;IS RESTRT VALID?
	JRST	.+3		;YES
	SETZ	T2,		;MAKE RECOMP IGNORE RESTRT
	SETZM	REPSID		;MAKE ONCDSK IGNORE RESTRT
	MOVEI	T3,RE.OND	;COMPUTE ACTION FOR
	PUSHJ	P,RECOMP+1	; ONCE RESTART
	TRNN	T2,RE.ONA	;MANUAL ONCE DESIRED?
	JRST	AUTORS		;NO: DO AUTO RESTART
	MOVEI	T1,[ASCIZ /
/]				; Type a free CRLF
	  CAIA			;   on entry.
HLPCMD:	MOVEI	T1,[ASCIZ /
?Unrecognized command - Please type HELP for help.
/]
HLPCM1:	PUSHJ P,OCONM
	PUSHJ P,OPOUT
TYPCMD:				; ** return from SCAN macro **
CHGCMD:				; ** return from SCAN macro **
CMDCMD:				; ** return from SCAN macro **
NULCMD:				; ** LABEL FOR NULL RETURN **
ONCCMD:	MOVEI T1,[ASCIZ /
ONCE>/]				;COMMAND PROMPT
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	PUSHJ P,GETLIN
	 JRST ONCCMD
	SCAN (CMD)		;SCAN FOR A COMMAND


	DEFINE MKCMD	<

X	TYPE,<JRST TYPIT>,AB.ACK,<
TYPE     Report information about the system.
         TYPE CORE   - the default minimum core available to users.
         TYPE SYSTEM - reports the system number.>
X	CHANGE,<JRST CHGIT>,AB.ACK,<
CHANGE   Change information about the system.
         CHANGE CORE   - changes the default minimum user core.
         CHANGE SYSTEM - changes the system number.>
X	FULL,<JRST FULLRS>,AB.NAK,<
FULL     Bring up the system with a FULL DSKCLN.  If there is any
         question about the integrity of the file system, then this>,<
         command should be used in place of GO.  Unless authorized,
         DO NOT enter the FILES dialogue to set the DSKCLN type.>
X	GO,<JRST AUTORS>,AB.ACK,<
GO       Bring up the system with the default settings and starts
         the auto-restart process.>
X	FILES,<PUSHJ P,FILOPT>,AB.NAK!AB.VER,<
FILES    Enter the FILES dialogue.  This is the subsystem of ONCE
         which is normally used ONLY for restructuring or repairing>,<
         the disk file system.  The commands in this subsystem could
         damage the file system if they are used incorrectly.  If you>,<
         are NOT sure of what you are doing, DO NOT enter this section.>
X	READONLY,<JRST REDOLY>,AB.ACK!AB.VER!AB.CVR,<
READONLY Bring up the system SHUT for emergency examination.
         Writing on the disk is prevented until DSKCLN has been run.>,<
         Note: You may not UNSHUT the system until DSKCLN has been run.>
X	CONSOLE,<PUSHJ P, FLGCTY>,AB.ACK,<
CONSOLE  Allow the system to be brought up on the CONSOLE terminal ONLY.
         The system MUST be reloaded before it can be brought up on the>,<
         network.  This command should be followed by a command to bring
	 up the system (one of: GO, FULL, MANUAL or READONLY).>
X	NETWORK,<PUSHJ P, FLGNET>,AB.ACK,<
NETWORK  Allow the system to be brought up on the NETWORK (default).
         This allows normal access to the system and overrides any>,<
         previous CONSOLE or NETWORK commands.  This command should be
         followed by a command to bring up the system. (see CONSOLE.)>
X	DDT,<JRST DDTX>,AB.ACK,<
DDT      Enter executive DDT.  To be used ONLY by software wizards
         for emergency patching and examination of the monitor.>,<
         UNDER NO CIRCUMSTANCES SHOULD YOU NORMALLY USE THIS COMMAND!>
X	MANUAL,<JRST MANRS>,AB.ACK!AB.VER!AB.CVR,<
MANUAL   Bring up the system in the SHUT state for DEBUGGING ONLY!
         The auto-restart process is not performed.>,<
         Note: You may not UNSHUT the system until DSKCLN has been run.>
X	BOOTS,<STOPCD>,AB.NAK!AB.VER,<
BOOTS    Crash the system with "BOOTS LOADED" immediately.>
IFKMC<
X	KMC,<JRST KMCMAN>,AB.ACK,<
KMC      Bring the system up loading the KMC-11 but without the>,<
         rest of the automatic restart procedure.  This must NEVER>,<
         be used for a restart after a system CRASH.  ONLY to be
         used when the system has been taken down gracefully and>,<
         DSKCLN has already been run.>
>;END IFKMC
X	HELP,<JRST CMDHLP>,AB.ACK,<
HELP     Type out this message.
>
>

	SCNTB (CMD)

TYPIT:	SETOM TYPONL	;ONLY TYPOUT
	SCAN (TYP)

	DEFINE MKTYP <
	X CORE,<PUSHJ P,TYPCOR>,AB.ACK,<
TYPE CORE   - Type the default minimum core available to users.>
	X SYSTEM,<PUSHJ P,TYPSYS>,AB.ACK,<
TYPE SYSTEM - Type the system number.>
	X HELP,<JRST TYPHLP>,AB.ACK,<
TYPE HELP   - Type out this message.
>
>
	SCNTB (TYP)
NULTYP:
HLPTYP:	MOVEI T1,[ASCIZ /
Type  "TYPE HELP"  for a list of options.
/]
	JRST	HLPCM1


CHGIT:	SETZM TYPONL	;NEED ANSWER
	SCAN (CHG)

	DEFINE MKCHG <
	X CORE,<PUSHJ P,CHGCOR>,ab.nak!ab.ver,<
CHANGE CORE   - Change the default minimum core available to users.>
	X SYSTEM,<PUSHJ P,CHGSYS>,ab.nak!ab.ver,<
CHANGE SYSTEM - Change the system number.  (This should ONLY be
                done when bringing up a system on hardware other>,<
                than what it was originally built for).>
	X HELP,<JRST CHGHLP>,ab.ack,<
CHANGE HELP   - Type out this message.
>
>
	SCNTB (CHG)
NULCHG:
HLPCHG:	MOVEI T1,[ASCIZ /
Type  "CHANGE HELP"  for a list of options.
/]
	JRST	HLPCM1

;CHANGE AND TYPE ROUTINES

TYPCOR:	HRRZ P1,CORLIM
	MOVEI T1,[ASCIZ /Default minimum user core = /]
	PJRST DECLOP

TYPSYS:	MOVE	P1,SYSNUM	;GET SYSTEM NUMBER.
	MOVEI T1,[ASCIZ /System number = /]
	PJRST DECLOP

CHGCOR:	HRRZ P1,CORLIM
	MOVEI T1,6
	MOVEM T1,MIN
	MOVEI T1,^D256
	MOVEM T1,MAX
	MOVEI T1,[ASCIZ /Default minimum user core = /]
	PUSHJ P,ASKQMM
	 POPJ P,
	HRRM T2,CORLIM
	POPJ P,

EXTERN CPOPJ

CHGSYS:	MOVE	P1,SYSNUM	;GET SYSTEM NUMBER
	MOVEI	T1,^D1
	MOVEM	T1,MIN
    IFCPU(<KI,KL>),<		; Don't allow numbers .gt. 255
	MOVEI	T1,^D255	;  on varian bases
    >;End IFCPU(<KI,KL>)
    IFNCPU(<KI,KL>),<		; It's OK on 11 bases to have
	MOVEI	T1,^D99999	;  larger host numbers
    >;End IFNCPU(<KI,KL>)
	MOVEM	T1,MAX
	MOVEI	T1,[ASCIZ /System number = /]
	PUSHJ	P,ASKQMM
	 POPJ	P,
	MOVEM	T2,SYSNUM	;STORE INTO GETTAB TABLE.
	MOVE	T1,CNFCPY	;BLT POINTER TO COPY CONFIG NAME/DATE
	BLT	T1,CPYFIG+4	;COPY
	SETZM	CONFIG
	MOVE	T1,CNCLBT
	BLT	T1,SYSDAT-1	;CLEAR OUT IN CASE NEW STRING SHORTER
	MOVE	T3,CPYBPT	;GET POINTER TO COPY AREA
	MOVE	T4,CNFBPT	;GET POINTER TO CONFIG AREA
	ILDB	T1,T3		;FIRST CHAR ALWAYS COPY
	IDPB	T1,T4
	PUSHJ	P,CPYSYN	;TURN T2 INTO STRING, DEPOSIT THRU T4.
CHGSY2:	ILDB	T1,T3		;SKIP OVER OLD NUMBER
	CAIL	T1,"0"
	CAILE	T1,"9"
	SKIPA			;FINISHED SKIPPING OLD SYSTEM NUMBER
	JRST	CHGSY2		;CONTINUE TO EAT SYSTEM NUMBER
CHGSY3:	IDPB	T1,T4		;FIRST TIME, PUT IN FIRST NON-SYSNUM CHAR
	ILDB	T1,T3		;GET NEXT SOURCE CHAR
	JUMPN	T1,CHGSY3	;IF NON-ZERO, COPY.
	POPJ	P,		;ZERO MEANS DONE.

;ROUTINE TO GET SYSTEM NUMBER INTO T2 FROM CONFIG.
; CALLED ONCE, AT TIME SYSTEM NAME IS PRINTED OUT ON CONSOLE.
; ALL OTHERS INTERESTED IN WHAT SYSTEM NUMBER IS SHOULD
; LOOK AT SYSNUM.

EXTERNAL SYSNUM

GETSYN:	MOVE	T4,CNFBPT	;GET BYTE POINTER INTO CONFIG
	SETZ	T2,		;WILL GET SYSTEM NUMBER
GETSY0:	ILDB	T1,T4		;GO TILL FIRST NUMBER
	CAIL	T1,"0"
	CAILE	T1,"9"
	JRST	GETSY0		;BETTER BE AT LEAST ONE.
GETSY1:	IMULI	T2,^D10
	ADDI	T2,-"0"(T1)
	ILDB	T1,T4
	CAIL	T1,"0"
	CAILE	T1,"9"
	SKIPA
	JRST	GETSY1
	MOVEM	T2,SYSNUM
	POPJ	P,

CPYSYN:	MOVE	T1,T2		;GET INTO T1
CPYSY1:	IDIVI	T1,^D10
	HRLM	T2,(P)		;SAVE ON STACK
	SKIPE	T1		;IF NO MORE DIGITS, START DEPOSITING.
	PUSHJ	P,CPYSY1	;CURSE, AND RECURSE.
	HLRZ	T1,(P)		;GET NEXT DIGIT
	ADDI	T1,"0"
	IDPB	T1,T4		;PUT INTO CONFIG
	POPJ	P,		;RETURN.

CPYFIG:	BLOCK	5+1		;5 WORDS FOR CONFIG, 1 FOR GOOD MEASURE.
COMMENT #
@@SUBROUTINE OPCBST/OPCBCL
@@PURPOSE
DEPENDING ON THE ENTRY POINT USED, EITHER (OPCBST)SETS UP OR
(OPCBCL)CLEARS THE TEMPORARY ONCE-TIME PCBS' MAP SLOTS
OPCBST ALSO SETS PCBTAB AND PGYXXX POINTERS.
CALLED WITH A JSP T4.
@@ENTRY
SEE PURPOSE.
@@ACCUM
DESTROYS T1, T2, AND T3.
@@ #

EXTERN PCBPAG,PCBTAB,PCBLNK

OPCBCL:	PUSH	P,PG		;

    ;HERE TO CLEAR THE USE AND SWAP DONE LISTS.  NO NEED TO CLEAR FPL/BPL/LST.
	SETZB	T2,USELST	;
	SETZM	SODLST		;
	SETZM	SIDLST		;
	MOVEI	T1,NMOCPC	;
	MOVE	PG,OPCLOW	;GET CP# OF LOWEST ONCE PCB
OPCBN1:	DPB	T2,PGYUSE	;
	DPB	T2,PGYERR	;
	DPB	T2,PGYDRT	;
	SOSLE	T1		;SKIP OVER AOJA IF DONE.
	AOJA	PG,OPCBN1	;
	JRST	OPCOUT

OPCBST:	PUSH	P,PG		;
	SETZM	ONCTIM		;FLAG FOR FINPCB.
	MOVEI	T1,OPCBTB	;SET UP POINTER TO LIST OF
	MOVEM	T1,PCBTAB	;PRIMARY PCBS.
	SETZ	T1,		;T1/ INDX TO TABLE OF PCB ADDRS.
	MOVE	PG,MEMSIZ	;FIRST NON-EX LOCATION
	SUBI	PG,1000		;1ST LOC OF LAST PAGE
	LSH	PG,-WRDSPP	;CONVERT TO PAGE NUMBER
OPCBS4:	SKIPN	T2,OPCBTB(T1)	;ANOTHER PCB?
	AOJA	PG,OPCBN0	;DONE. SET PG TO LOWEST PCB PAGE AND JUMP.
	HRLM	PG,PCBPAG(T2)	;YES, SET PAGE NUMBER IN PCB
	MOVEI	T3,PGE.A!PGE.W!PGE.C(PG)	;ITS
	DPB	T3,MPSLOT(T1)	;MAP ENTRY.
	SUBI	PG,1		;NEXT PAGE FOR ONCE PCBS.
	AOJA	T1,OPCBS4	;CONTINUE.
    ;SET BYTE PNTRS.
OPCBN0:	MOVEM	PG,OPCLOW	;REMEMBER LOWEST PHYSICAL PAGE USED FOR ONCE PCBS.
	MOVEI	T2,BOTTM-ONCDDS	;GET START OF ONCE ONLY PGY TABLES.
	SUB	T2,PG		;PGY IS INDEXED BY THAT MINIMUM INDEX.
	HRRM	T2,PGYUNU	;
	HRRM	T2,PGYPGO	;
	HRRM	T2,PGYFPL	;

	ADDI	T2,NMOCPC	;SECOND WORD.
	HRRM	T2,PGYLMA	;
	HRRM	T2,PGYLMV	;
	HRRM	T2,PGYLMJ	;
	HRRM	T2,PGYBPL	;

	ADDI	T2,NMOCPC	;THIRD WORD.
	HRRM	T2,PGYLST	;
	HRRM	T2,PGYDIO	;
	HRRM	T2,PGYADR	;
	HRRM	T2,PGYUNI	;
	HRRM	T2,PGYPNO	;

	ADDI	T2,NMOCPC	;FOURTH WORD.
	HRRM	T2,PGYSPT	;
	HRRM	T2,PGYSPB	;
	HRRM	T2,PGYSPO	;
	HRRM	T2,PGYCHT	;

	ADDI	T2,NMOCPC	;FIFTH WORD.
	HRRM	T2,PGYSTS
	HRRM	T2,PGYSIO	;
	HRRM	T2,PGYSIP	;
	HRRM	T2,PGYSOP	;
	HRRM	T2,PGYERR	;
	HRRM	T2,PGYNXM	;
	HRRM	T2,PGYDRT	;
	HRRM	T2,PGYATB	;
	HRRM	T2,PGYUSE	;

	ADDI	T2,NMOCPC	;SIXTH WORD
	HRRM	T2,PGYCSH

OPCBND:	MOVEI	T1,ONCPYP	;NUMBER OF PAGES FOR PGY AND DDB
	MOVEI	T2,EPT*2+<<BOTTM-ONCDDS>/1000>-1
	ROT	T2,-1
	TLNN	T2,(1B0)	;CAN'T USE EPTPTR, ONCPYP MADE OF EXTERNALS
	JRST	[HRLI T2,(POINT 18,0,17)
		 JRST .+2]	;IS EVEN USE RIGHT HAND SLOT
	HRLI	T2,(POINT 18,0,35) ;ODD, USE LEFT HAND SLOT
				;NOW HAVE PTR TO PAGE BEFORE ONE FOR PGY AND DDB.
	SKIPN	PG,T3		;IF T3 IS ZERO, CLEAR PG AND GO CLEAR MAP SLOTS
	JRST	OPCBNL
	MOVE	PG,OPCLOW	;GET LOWEST PAGE NUMBER OF ONCE PCBS
	SUBI	PG,ONCPYP	;GET FIRST PHYS PAGE OF PGY AND DDB
	TRO	PG,PGE.A!PGE.W!PGE.C ;MAKE INTO MAP SLOT POINTER
OPCBNL:	IDPB	PG,T2		;SET OR CLEAR SLOT
	ADDI	PG,1		;NEXT CP
	SOJG	T1,OPCBNL	;AND LOOP TILL DONE.
	CLRPTA			;GET MAPPING INTO EFFECT SO CAN USE IT BELOW.
	JUMPE	T3,OPCOUT	;IF CLEARING, JUST RETURN.
	MOVEI	T1,BOTTM-ONCDDS+CNTPGY*NMOCPC ;DDB LOCATION IN VIRTUAL SPACE
	MOVEM	T1,ONCDDB	;STORE IT FOR ONCDSK.

    ;HERE TO SET THE USE LIST.
OPCBN2:	MOVEI	T1,NMOCPC	;T1/ LOOP COUNTER.
	PUSH	P,T4		;T4/ PGYLST,
	MOVEI	T2,1		;T2/ PGYUSE.
	MOVEI	T4,USE.N	;
	SETZ	T3,		;BPL.
	MOVE	PG,OPCLOW	;PG/FIRST PAGE
	HRRM	PG,USELST	;
	HRRZM	PG,MINPCB	;
OPCBN3:	DPB	T3,PGYBPL	;
	DPB	T2,PGYUSE	;
	DPB	T4,PGYLST	;
	SOJLE	T1,OPCBN4	;
	MOVEI	T3,1(PG)	;
	DPB	T3,PGYFPL	;
	EXCH	T3,PG		;
	JRST	OPCBN3		;
OPCBN4:	SETZ	T3,		;
	DPB	T3,PGYFPL	;
	POP	P,T4		;
	HRLM	PG,USELST	;
	HRRZM	PG,MAXPCB	;STORE NO. OF HIGHEST PCB PAGE.
	MOVEI	T1,1(PG)	;FAKE
	HRRZM	T1,MEMSZP	;OUT SWPENQ AT ONCE TIME.
OPCOUT:	POP	P,PG		;RESTORE PG.
	JRST	(T4)		;
COMMENT ;@@SUBROUTINE EVASET
@@PURPOSE: Set up page map slots for mappable exec virtual
  address space (i.e., high seg)
@@ACCUM T1-T4
@@EXIT	EVAMAX/SETUP TO MAXIMUM VALUE EVASIZ CAN BE (ALWAYS %ONC FOR NOW).
@@;

EVASET:	MOVEI	T3,%ONC		;*****
	MOVEM	T3,EVAMAX	;*****FOR NOW EVAMAX IS ALWAYS %ONC
	MOVEI	T4,%ONC-%MIN	;GET NUMBER OF WORDS AVAILABLE
	LSH	T4,-WRDSPP	;NUMBER OF AVAILABLE PAGES
	MOVE	T2,EVAMIN	;SETUP EPT HIGH SEG
	IBP	T2		;DECREMENT THE POINTER
	SOS	T2		;BECAUSE EPTPTR WON'T WORK RIGHT FOR 377.
	MOVEI	T3,PGE.A+PGE.C+PGE.W+340 ;MAP SLOT POINTER

EVASE1:	IDPB	T3,T2		;SET MAP SLOT POINTER
	ADDI	T3,1		;NEXT PAGE
	SOJG	T4,EVASE1	;AND LOOP SETTING UP MAP SLOTS
	CLRPTA			;DONE, MAKE MAP SETTINGS HAPPEN.
	POPJ	P,		;RETURN.

EVAONC:	EPTPTR(%ONC.N)
EVAMIN:	EPTPTR(<%MIN/^O1000>)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	EVMINI - Routine to set the lower bound for dynamic	;;
;;	exec virtual memory allocation.  May be called more	;;
;;	than once if the FILES dialogue is used, but it		;;
;;	doesn't matter since it will allocate again in the	;;
;;	normal sequence.					;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EVMINI:	MOVE	T1,SYSSIZ	;GET CURRENT SYSTEM SIZE
	MOVEM	T1,EVASIZ	;INITIALIZE FOR EVMALC
	POPJ	P,

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	EVMALC - Routine to allocate EVM for ONCE.  Called	;;
;;	with # of words requested in T2, returns address in	;;
;;	T1.  Adjusts across the per-process area.  Zeroes out	;;
;;	storage before returning to caller.			;;
;;	Returns at call+1 always, T2 preserved.			;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	INTERN EVMALC
EVMALC:	SKIPN	T1,EVASIZ	;Current highest allocated EVM address
	  PUSHJ	P,EVMINI	;This can happen if called from FILES
	CAIL	T1,%MIN		;Already allocating in high-seg?
	  JRST	EVMAL1		;If so, no problem
	ADD	T1,T2		;See where this request puts us
	CAIG	T1,340000	;Into the per-process area, maybe?
	  JRST	EVMAL2		;No, how nice
	MOVEI	T1,%MIN		;Time to start high-seg allocation
	MOVEM	T1,EVASIZ
EVMAL1:	ADD	T1,T2		;Bump old high address up
	CAMLE	T1,EVAMAX	;Encroaching on ONCE?
	  STOPCD		;If so, monitor too big
EVMAL2:	EXCH	T1,EVASIZ	;Return start address for request
	PUSH	P,T1
	PUSH	P,T2
	SETZM	(T1)		;Clear first word for BLT
	ADDI	T2,-1(T1)	;Start address+length-1=last address
	ADDI	T1,1		;0,,start address + 1
	HRLI	T1,-1(T1)	;Start address,,start address + 1
	BLT	T1,(T2)		;Zero it all out
	POP	P,T2
	POP	P,T1
	POPJ	P,

EVASIZ::0			;UPDATED BY ALLOCATERS TO CONTAIN
				; LOCATION TO ALLOCATE AT.
EVAMAX::0			;HIGHEST LEGAL VALUE OF EVASIZ.
COMMENT ;@@SUBROUTINE EVACLR
@@PURPOSE CALLED BY ONCE TO CLEAR OUT THE UNUSED EXEC VIRTUAL
MAP SLOTS AFTER ALL THE DYNAMIC STORAGE IS ALLOCATED IN
EXEC VIRTUAL ADDRESS SPACE.
@@ENTRY	EVASIZ/	UPDATED LAST LOCATION USED + 1 OF DYNAMIC SPACE
@@ACCUM T1-T4
@@EXIT  EPT MAP SLOTS ZEROED TO STARTING PAGE OF ONCE
@@;

EVACLR:	MOVE	T4,EVASIZ	;GET FIRST UNUSED LOCATION
        IORI	T4,777		;MAKE SURE LAST LOC LOOKS LIKE IS 
				; LAST LOC OF A PAGE
	ADDI	T4,1		;T4 GETS FIRST UNUSED LOCATION
	CAMLE 	T4,EVAMAX	;MAKE SURE ONCE NOT OVERWRITTEN.
	 STOPCD			;TOO BAD.
	MOVE	T1,T4
	SUB	T1,EVAMAX	;GET -VE NUMBER OF UNUSED WORDS
	ASH	T1,-WRDSPP	;MAKE IT -VE NUMBER OF UNUSED PAGES
	LSH	T4,-WRDSPP	;CONVERT TO FIRST UNUSED VIRTUAL PAGE NUMBER
	MOVEI	T3,EPT*2-1(T4)
	LSH	T3,-1		;WORD IN EPT OF SLOT BEFORE ONE TO CLEAR
	HRLI	T3,(POINT 18,0,35) ;ASSUME ODD
	TRNE	T4,1		;IS IT? (TEST BACKWARDS BECAUSE ITS PAGE - 1)
	HRLI	T3,(POINT 18,0,17) ;NO, EVEN
	JUMPE	T1,CPOPJ	;IF NO USED AREA, JUST RETURN.
	SETZ	T4,		;TO CLEAR MAP SLOT WITH
EVACL1:	IDPB	T4,T3		;CLEAR MAP SLOT
	AOJL	T1,EVACL1	;AND LOOP
	CLRPTA			;MAPPINGS GO INTO EFFECT WITH THIS
	POPJ	P,		;RETURN.
COMMENT #
@@SUBROUTINE FINALC
@@PURPOSE
  SUBROUTINE TO
     1) SET UP THE SYSTEM PCBS AT INITIALIZATION TIME AND
        TO LINK THEM TO THEIR PAGES AND EACH OTHER.  SETS UP
        TABLE OF ADDRS AND POINTS PCBTAB TO IT.  SETS UP LRU/MRU
        TABLES FOR SAT PCBS AND RIB PCBS.  ALSO SETS %CTLST'S.
     2) ALLOCATE FREE CORE.  WILL USE REMAINING EXECUTIVE
        VIRTUAL MEMORY UP TO THE BEGINNING OF ONCE UNLESS
        RESTRICTED BY SPECIFYING FCWDS.
@@ACCUM
  DESTROYS T1 TO T4 AND P1 TO P4 AND PG.
@@CALLS
  EVMALC
@@ #

;FIRST GET CORE FOR BOTH THE PCBS AND THE THREE TABLES
;OF PCB ADDRS.

FINALC:	SETOM	ONCTIM		;FLAG FOR FINPCB.

	MOVE	T2,NMSTPC	;COUNT THE NO. OF
	ADD	T2,NMRBPC	;SYSTEM PCBS.
	MOVE	P1,T2		;SAVE COUNT IN P1, FOR BELOW.
	IMULI	T2,6		;GET ROOM FOR PCBS (@4 WORDS) +
	ADDI	T2,3		;3 TBLS WITH 1 WORD PER TYPE OF
				;PCB + A ZERO ENTRY AT END.
	PUSHJ	P,EVMALC	;Allocate, returns base in T1
	MOVE	T2,P1		;CALC T2/ LAST LOC OF PCBS +
	LSH	T2,2		;T4/ STARTING LOC OF THE 1ST
	ADDI	T2,-1(T1)	;TABLE, AND
	MOVEI	T4,1(T2)	;STORE T4
	MOVEM	T4,PCBTAB	;IN PCBTAB.
	MOVE	P2,T1		;SAVE THE PCBS' STARTING ADDR.

        MOVE    T1,EVASIZ       ;UPDATE SYSSIZ AND EVASIZ
        CAIGE   T1,%MIN         ;BEYOND THE PER PROCESS AREA?
         MOVEI  T1,%MIN         ;NO. SKIP OVER IT
        MOVEM   T1,EVASIZ
        SUBI    T1,%MIN-340000  ;ADJUST SYSSIZ BY PER PROCESS PAGES
        MOVEM   T1,SYSSIZ

;;
;; Free-core consists of a block of bit-map words, followed by a block
;; of allocatable free storage.  Each bit in the bit-map corresponds to a
;; four-word core block, therefore, each bit-map word maps 144 (decimal)
;; words of core.  The size of the total (bit-map + 4-wd blocks) storage
;; is therefore an even multiple of ^D145 => ^D144 allocatable words +
;; 1 bit-map word.

        EXTERNAL FRECOR,FREPTR,LOCORE

        SKIPE   T2,FRECOR       ;FRECORE specified explicitly?
         JRST   FREAL1          ;Yes. Allocate it
        MOVE    T2,EVAMAX       ;No.  Allocate what's available
        SUB     T2,EVASIZ
FREAL1:	IDIVI	T2,^D145	;See above
; T2 now contains number of words which will be used for bit-map
	MOVN	T3,T2		;Remember -N
	IMULI	T2,^D145	;Re-calculate total allocation
	PUSHJ	P,EVMALC	;Allocate storage, returns base in T1
        ADDM    T2,SYSSIZ       ;DON'T FORGET PHYSICAL MEMORY
	HRL	T1,T3		;Make AOBJN ptr for bit-map words
	MOVEM	T1,FREPTR	; for free-core allocation routines
	SETZM (T1)		;Clear out bit-map words to indicate
	AOBJN T1,.-1		; nothing allocated yet.
	HRRZM	T1,LOCORE	;Allocatable storage begins after bit-map

        PUSHJ   P,EVACLR        ;Clear out remaining exec page map slots.
    ;ADJUST SYSSIZ TO ACCOUNT FOR THE SYSTEM PCB PAGES.
	MOVE	T1,SYSSIZ	;GET INTO T1
        ADDI    T1,777          ;MAKE SURE 1ST PHYS PAGE CORRESPONDS
        TRZ     T1,777          ; TO 1ST PAGE RELEASED BY EVACLR
	MOVE	PG,T1		;SET PG TO
	LSH	PG,-WRDSPP	;NEXT PAGE NO.
	HRRZM	PG,USELST	;
	HRRZM	PG,MINPCB	;
	LSH	P1,WRDSPP	;
	ADD	T1,P1		;
	MOVEM	T1,SYSSIZ	;

    ;NOW GET PAGES FOR THE PCBS AND BUILD THE THREE TABLES.
	MOVE	T2,NMSTPC	;
	ADD	T2,NMRBPC	;
	MOVE	T3,PCBTAB	;SET UP T3 AS START OF SAT
	ADDI	T3,1(T2)	;PCB LRU/MRU TABLE, AS ARG
	MOVEM	T3,%CTLRU+%SAT.C ;FOR SPCBLN, ALONG WITH
        MOVE    T4,PCBTAB       ;GET BACK PCB TABLE ADDRESS
	MOVE	P1,NMSTPC	;PG AND P1.
	HRRM	P2,%CTLST+%SAT.C ;
	SETZ	P3,		;BPL.
	PUSHJ	P,SPCBLN	;LINK/LINK.
	HRRZI	P3,(PG)		;
	HRRZI	PG,1(PG)	;
	MOVEM	T3,%CTMRU+%SAT.C ;
	ADDI	T3,1		;
	MOVEM	T3,%CTLRU+%RIB.C ;
	MOVEM	T3,%CTLRU+%RB2.C ;
	MOVE	P1,NMRBPC	;SET UP AND CALL SPCBLN
	HRRM	P2,%CTLST+%RIB.C ;
	HRRM	P2,%CTLST+%RB2.C ;
	PUSHJ	P,SPCBLN	;FOR RIB PCBS.
	MOVEM	T3,%CTMRU+%RIB.C ;
	MOVEM	T3,%CTMRU+%RB2.C ;
	SETZM	(T4)		;MARK END OF PCBTAB TABLE.
	HRLM	PG,USELST	;
	HRRZM	PG,MAXPCB	;
	SETZ	T1,		;TERMINATEE THE LAST
	DPB	T1,PGYFPL	;PAGE ON THE LIST.
	POPJ	P,

    ;A LITTLE SUBR TO LINK A SET OF PCBS.
    ;ENTER WITH P1/ # OF PCBS TO LINK, P2/ ADDR OF FIRST
    ;PCB, P3/BPL, PG/ 1ST PAGE NO., T4 AND T3/ ADDRS OF TABLE ENTRIES
    ;TO STORE PCB ADDRS IN.
SPCBLN:	MOVEI	T1,1		;
	MOVEI	P4,USE.N	;
SPCBL1:	HRLZM	PG,PCBPAG(P2)	;SET PCBPAG.
	DPB	T1,PGYUSE	;
	DPB	P4,PGYLST	;
	DPB	P3,PGYBPL	;
	MOVEM	P2,(T4)		;MAKE THE TBL ENTRIES
	MOVEM	P2,(T3)		;AND
	ADDI	T4,1		;ADJUST THE TBL
	ADDI	T3,1		;PNTRS.
	ADDI	P2,4		;NO, GET P2/ ADDR OF NEXT PCB
	SOJLE	P1,SPCBL2	;DONE?
	HRRM	P2,-4+PCBLNK(P2) ;AND LINK CURRENT PCB TO IT.
	MOVEI	P3,1(PG)		;
	DPB	P3,PGYFPL	;
	EXCH	P3,PG		;
	JRST	SPCBL1		;
SPCBL2:	SETZM	(T3)		;CLEAR LAST+1 ENTRY IN LRU/MRU.
	POPJ	P,
COMMENT #
@@SUBROUTINE SETM2P
@@PURPOSE
SUBROUTINE TO SET UP INFO FOR THE M2, PS, PR, SI, AND RI QUEUES.
@@ACCUM
DESTROYS
@@ #

    ;SET M2REQ, PSREQ, PRREQ, SIREQ, AND RIREQ TO MINUS THE NO. OF RESOURCES,
    ;AND SET OF THE LH'S OF THE AOBJN PNTRS IN M2SWT, M2HAV,
    ;PSSWT, PRSWT, SISWT, AND RISWT SIMILARLY.
SETM2P:	MOVN	T2,NMSTPC	;
	MOVEM	T2,PSREQ	;
	HRLZM	T2,PSSWT	;
	MOVEM	T2,SIREQ	;
	HRLZM	T2,SISWT	;
	MOVN	T2,NMRBPC	;
	MOVEM	T2,PRREQ	;
	HRLZM	T2,PRSWT	;
	MOVEM	T2,RIREQ	;
	HRLZM	T2,RISWT	;
	IDIVI	T2,2		;LSH ISN'T IDIV ON NEGATIVE NO.
	MOVEM	T2,M2REQ	;
	HRLZM	T2,M2SWT	;
	HRLZM	T2,M2HAV	;

    ;GET THE SPACE FOR THE THREE TABLES.
	MOVMS	T2		;CALC
	PUSH	P,T2		;AND
	LSH	T2,1		;
	ADD	T2,NMSTPC	;SAVE THE
	ADD	T2,NMSTPC	;SAVE THE
	ADD	T2,NMRBPC	;TOTAL SPACE
	ADD	T2,NMRBPC	;TOTAL SPACE
	PUSH	P,T2		;REQUIRED.
	PUSHJ	P,GETWDS	;
	STOPCD
	POP	P,T2		;RESTORE TOTAL COUNT OF SPACE.
	PUSH	P,T1		;SAVE STARTING ADDRESS.
	ADDI	T2,-1(T1)	;CLEAR
	SETZM	(T1)		;THE
	ADDI	T1,1		;ACQUIRED
	HRLI	T1,-1(T1)	;SPACE.
	BLT	T1,(T2)		;

    ;BUILD THE RH OF THE AOBJN PNTRS IN M2SWT, PSSWT, AND PRSWT.
	POP	P,T1		;RESTORE STARTING LOCATION.
	HRRM	T1,PSSWT	;
	ADD	T1,NMSTPC	;
	HRRM	T1,PRSWT	;
	ADD	T1,NMRBPC	;
	HRRM	T1,M2SWT	;
	POP	P,T2		;
	ADDI	T1,(T2)		;
	HRRM	T1,M2HAV	;
	ADDI	T1,(T2)		;
	HRRM	T1,SISWT	;
	ADD	T1,NMSTPC	;
	HRRM	T1,RISWT	;
	POPJ	P,		;
; Routine to determine whether a particular physical page (number
; passed in T1) exists.  Non-skip return if not, skip return if so.
PGCHK:	TRO	T1,PGE.A
	DPB	T1,EPYPSN	;STORE IT [EPTPTR(%UPS.N)]
	CLRPTO	%UPS		;CLEAR PAGING MEMORY.
	TRZ	T1,PGE.A	;Clean up after self
IFCPU (KI),<WRAPR CLRNXM>	;IF KI, PI SYSTEM ISN'T ON.
IFNCPU (KI),<WRAPR CLRNXM+APRCHN> ;CLEAR NXM+APRCHN
	MOVE	T2,%UPS
	MOVE	T2,%UPS+1
	MOVE	T2,%UPS+2
	MOVE	T2,%UPS+3
PGCHK1:	CONSZ	APR,APRNXM
	  JRST	[WRAPR	CLRNXM
		 POPJ	P,]	;Page is missing, give non-skip return
	PJRST	CPOPJ1		;Good page

; Routine to type out message about dis-continuous core - highest
; previous physical page number is in PG and first page after hole
; is in T1. 
HOLMSG:	TLO	PG,(1B1)	;MARK DISCONTINUOUS CORE
	PUSH	P,T1
	PUSHJ	P,CLRSND
	PUSHJ	P,INLMES
	ASCIZ	/
"HOLE" IN CORE FROM /
	MOVEI	T1,1(PG)
	LSH	T1,9
	PUSHJ	P,RADIX8
	PUSHJ	P,INLMES
	ASCIZ	/ TO /
	MOVE	T1,(P)
	ANDI	T1,17777
	LSH	T1,9
	SUBI	T1,1
	PUSHJ	P,RADIX8
	PUSHJ	P,CRLF
	PUSHJ	P,OPOUT
	PJRST	TPOPJ
;HERE IS WHERE WE REALLY START THINGS

EXTERN SRPNDS,STRDDB,STRBTS

EXTERNAL CTYDO

FLGNET:	TDZA	T1,T1		; Zero flag for NET access
FLGCTY:	SETO	T1,		; Ones flag for CTY access
	MOVEM	T1,CTYDO	; Set CTYDO flag
IFKMC<
EXTERNAL DRDO,DZDO,KMCDO
	SETCAM	T1,DRDO		; Opposite for DR-11
	SETCAM	T1,DZDO		; Opposite for DZ-11
	SETCAM	T1,KMCDO	; Opposite for KMC-11
> ; End IFKMC
	MOVE	T1,[Exp [ASCIZ\
  Console\],[ASCIZ\
  Network\]]+1(T1)		; Print selection.
	PUSHJ	P,OCONM
	PUSHJ	P,OPOUT
	MOVEI	T1,[Asciz\ selected.
  Please type GO, FULL, MANUAL or READONLY to bring up the system.
\]				; Print something!
	PUSHJ	P,OCONM
	PUSHJ	P,OPOUT
	POPJ	P,		; Return to command level

MANRS:
IFKMC<	SKIPE	CTYDO
	  JRST	MANRSN
	MOVEI T1,[ASCIZ /
WARNING: THE KMC IS NOT LOADED WHEN COMING UP MANUALLY.
         THE HOST WILL NOT SYNCHRONIZE WITH THE MICRO-BASE.
/]
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
>;IFKMC.END
MANRSN:	MOVEI	T1,SRPNDS
	ANDCAM	T1,STRDDB+STRBTS
	SETOM	ADJMWS##	;TURN ON WORKING SET DIDDLER
	JRST	MANRS0

REDOLY:	MOVEI	T1,SRPNDS
	IORM	T1,STRDDB+STRBTS
MANRS0:	MOVSI	T1,(STAUTO)
	HRRI	T1,STSUPR
	ANDCAM T1,STATES	;SET FOR MANUAL RESTART
	JRST	AUTOR0

IFKMC<
KMCMAN:	SKIPN	KMCDO
	 JRST  KMCMER		;COMPLAIN KMC NOT ACTIVE
	SETOM 	KMCDO		;FLAG KMC MANUAL MODE
	MOVEI	T1,SRPNDS	;DONT LOCK DISK STRUCTURE
	ANDCAM	T1,STRDDB+STRBTS
	MOVEI	T1,STSUPR	;DONT SET SYSTEM AS SUPER SHUT
	ANDCAM	T1,STATES
	MOVEI	T1,STSHUT	;SET SYSTEM AS SHUT
	IORM	T1,STATES
	JRST AUTOR0
KMCMER:	MOVEI	T1,[ASCIZ/
KMC NOT SET AS ACTIVE IN SYSTEM/]
	JRST HLPCM1		;GO COMPLAIN
>;END IFKMC

FULLRS:	MOVEI	T1,DCFULL	; SET FULL DSKCLN restart code
	DPB	T1,DCNYOP	; Save for override!
	MOVSI	T1,DCN.OP	; Specify that OPR
	IORM	T1,DCN		; Has set this in once
;	JRST	AUTORS		;** FALL INTO AUTO RESTART CODE "GO"

AUTORS:	MOVEI	T1,SRPNDS	;MAN AND GO BOTH NEED DSKCLN.
	IORM	T1,STRDDB+STRBTS
AUTOR0:	SKIPN $1B		;DO WE WANT TO KEEP DDT
	 JRST RMVDDT		;NO
	MOVEI T1,[ASCIZ /
LOADED WITH EDDT
/]
	PUSHJ P,CONMES
	PUSHJ P,OPOUT
	JRST COMLOD	;TO THE COMMON LOAD CODE

RMVDDT:	MOVE T1,PATSIZ	;GET SIZE OF PATCH AREA
	MOVEM T1,SYSSIZ	;AND SAVE IT
	MOVEI T1,(HALT)
	HRLM T1,SYSDDT	;DO NOT LET DDT START IF NOT THERE
COMLOD: SETZM   EVASIZ          ;INITIALIZE EXEC VIRTUAL MEMORY
	PUSHJ	P,FILMAN	;DO MANDATORY FILE STUFF.
	JSP	T4,OPCBCL	;CLEAR THE ONCE TIME PCBS.
	PUSHJ	P,EVASET	;SET UP EXEC ADDRESS SPACE ABOVE 400000
				; FOR DYNAMIC STORAGE ALLOCATION.

;HERE IS WHERE WE START BUILDING THE PAGE TABLE
; PGY IS A LITTLE BIGGER THAN IT HAS TO BE BECAUSE EVASIZ
; WILL BE MOVED UP SOME MORE, MAKING THE FIRST PAGE
; DESCRIBED BY PGY LARGER THAN IT IS HERE.
; SYSSZP and CAVPGN get overwritten later when the final size of
; the monitor is determined.

PAGALC:	MOVE	PG,EVASIZ	;Current highest monitor address
	LSH	PG,-9		;Highest page # before PGY table base
	ADDI	PG,1		;First page referred to by PGY
	MOVEM	PG,SYSSZP	;Used to figure PGY displacement
; We (unfortunately) need to sweep memory twice - once to find the
; highest existing physical page number and again to report holes
; and build the free page table.
	MOVE	T1,PG
IFCPU (KL),<WRAPR LP.DSF+LP.NXM+LP.PAR> ;THESE WILL COME UP.
IFCPU (KS),<WRAPR LP.DSF+LP.NXM+LP.HPE	;THESE WILL COME UP.
	MOVEI	T2,PGCHK1	;SET PAGE FAIL WORD TO NXM TEST
	MOVEM	T2,UPT+UPTNPP>

IFCPU (KS),<MAXPAG==3777>	;FOR KS MAX IS 37777
IFCPU (<KI,KL>),<MAXPAG==17777>	;FOR NOW MAX IS 777
IFCPU (F3),<MAXPAG==1777>	;F3 ALWAYS HAS 512K

PGECNT:	PUSHJ	P,PGCHK		;Does page in T1 exist?
	  SKIPA			;No
	HRR	PG,T1		;Yes, remember highest physical page
	ADDI	T1,1		;Try next
	CAIG	T1,MAXPAG	;Past highest possible?
	  JRST	PGECNT		;Not yet

; PG now holds page # of highest physical core page.

	SUB	PG,SYSSZP	;Don't count monitor pages
	ADDI	PG,1		;Because SYSSZP is really first PGY page
	MOVE	T2,PG		;Now allocate for free page table
	PUSHJ	P,EVMALC	;Returns base in T1
	MOVE	PG,SYSSZP
	SUBI	T1,(PG)		;Because the zero'th entry is for the
	HRRM	T1,PGYFPL	; SYSSZP'th physical page
	MOVEM	PG,CFRLST	;First free page
	SETZM	CAVPGN		;Available pages for users
; Now, repeat the physical page scan, and pay attention this time.
	MOVEI	T1,1(PG)
PGSLP:	PUSHJ	P,PGCHK		;Page exists?
	  JRST	[TLO PG,(1B0)	;No, flag hole in memory
		 JRST PGSLP1]
	TLZE	PG,(1B0)	;This one exists, did a hole go by?
	  PUSHJ	P,HOLMSG	;Yes, sound the trumpets
	AOS	CAVPGN		;One more for the lucky user
	HRRZ	T2,PGYFPL	;Base address for free-page list
	ADDI	T2,(PG)		;Address of entry for last known
	MOVEM	T1,(T2)		; physical page - point to new page
	HRR	PG,T1		;Greet the new highest physical page
PGSLP1:	ADDI	T1,1		;Loop until boredom sets in
	CAIG	T1,MAXPAG	;Or until no more physically possible
	  JRST	PGSLP		;Lucky for us computers are easily amused
	AOS	CAVPGN		;This will get adjusted later to allow
				; for space allocated above SYSSIZ.

; PG should (!) once again have highest physical page #

IFCPU (<KL,F3>),<WRAPR	LP.ESF+LP.NXM+LP.PAR>	;RE-ENABLE THESE.
IFCPU (KS),<WRAPR LP.ESF+LP.NXM+LP.HPE+APRCHN	;RE-ENABLE THESE.
	MOVE	T1,PGFUIO	;RESTORE PAGE FAIL WORD
	MOVEM	T1,UPT+UPTNPP>

	HRRZ	T1,PGYFPL	;CLEAR ALL OF FIRST PGY
	ADDI	T1,(PG)		;TABLE WORD, AND SET
	SETZM	(T1)		;PGYFPL TO ZERO.
	HRLM	PG,CFRLST	;
	MOVEI	PG,1(PG)
	MOVEM	PG,MEMSZP	;SIZE IN PAGES
	MOVE	T2,PG		;To get allocated size of remaining PGY
	SUB	T2,SYSSZP	; tables, duplicate PGYFPL arithmetic.
	LSH	PG,9
	MOVEM	PG,MEMSIZ
	HRRZ	T1,PGYFPL
	HRRM	T1,PGYPGO	;
	HRRM	T1,PGYUNU	;
	PUSHJ	P,EVMALC	;Size in T2, returns base in T1
	SUB	T1,SYSSZP	;Adjust base address
	HRRM	T1,PGYLMA	;
	HRRM	T1,PGYLMV	;
	HRRM	T1,PGYLMJ	;
	HRRM	T1,PGYBPL	;
	PUSHJ	P,EVMALC	;Table size still in T2
	SUB	T1,SYSSZP
	HRRM	T1,PGYLST	;
	HRRM	T1,PGYDIO
	HRRM	T1,PGYADR
	HRRM	T1,PGYUNI
	HRRM	T1,PGYPNO
	PUSHJ	P,EVMALC
	SUB	T1,SYSSZP
	HRRM	T1,PGYSPT
	HRRM	T1,PGYSPB
	HRRM	T1,PGYSPO
	HRRM	T1,PGYCHT
	PUSHJ	P,EVMALC
	SUB	T1,SYSSZP
	HRRM	T1,PGYSIO
	HRRM	T1,PGYSTS
	HRRM	T1,PGYSIP
	HRRM	T1,PGYSOP
	HRRM	T1,PGYERR
	HRRM	T1,PGYNXM
	HRRM	T1,PGYDRT
	HRRM	T1,PGYATB
	HRRM	T1,PGYUSE
	PUSHJ	P,EVMALC
	SUB	T1,SYSSZP
	HRRM	T1,PGYCSH


CHTALC:	MOVE	T1,CAVPGN	;GET NUMBER OF USER PAGES
	JFFO	T1,.+1
	MOVN	T1,T2		;LSH IN RIGHT DIRECTION
	MOVSI	T2,(1B0)
	LSH	T2,-1(T1)	;GET NEXT HIGHEST POWER OF TWO - 2
				;(CHT START TABLE HAS # OF USER CORE PAGES
				; /2 HALFWORD ENTRIES).
	PUSHJ	P,EVMALC	;Returns base address in T1
	HRRM	T1,CHTPTR	;THIS IS WHERE CHT STARTS
	ROT	T2,1		;NOW GET MASK TO USE FOR GETTING BUCKET
	SUBI	T2,1		; NUMBER FROM DISK PAGE
	MOVEM	T2,CHTMSK	;AND SAVE IT.

	HRRZ	T1,CFRLST	;
	ADD	T1,CAVPGN	;PLUS FIRST PAGE (OLD SYSSIZ)
	LSH T1,-1	;CONVERT TO K
	PUSH P,T1
	CAIL T1,PMEMSZ	;TOO SMALL?
	JRST SIZOK	;NO
	PUSHJ P,CLRSND
	PUSHJ P,INLMES
	ASCIZ /
????SHOULD HAVE /
	MOVEI T1,PMEMSZ
	PUSHJ P,RADX10
	PUSHJ P,INLMES
	ASCIZ /K OF MEMORY.
/
SIZOK:	POP P,T1
	PUSHJ P,RADX10
	PUSHJ P,INLMES
	ASCIZ /K OF MEMORY ONLINE.
/
	PUSHJ P,OPOUT
	SKIPN	REFLAG		;AUTOMATIC "LOGIN" WANTED?
	JRST	SYS0		;NO.
	MOVE	T1,FSFPPN
	MOVEM	T1,REFLAG
	PUSHJ P,INLMES
	ASCIZ /TO AUTOMATICALLY LOGIN, LOGIN OVER SHUT
/
	PUSHJ	P,OPOUT
SYS0:	JSR LINKDB		;AND LINK UP ALL DDB'S
	HRLI T1,SYSBEG	;GET SET TO CLEAR LOW CORE
	SETZM SYSBEG
	HRRI T1,SYSBEG+1		;CLEAR SYSTEM DATA STORAGE
	MOVE F,MEMSIZ		;SAVE MEMSIZ(ALREADY SET UP)
	BLT T1,SYSEND
	MOVEM F,MEMSIZ
IFCPU (KL),<			; FOR KL with SIMULATOR LOADED
	SKIPE	KL$SIM##	;IF ITS LOADED,
	  JRST	SYS0A		;DON'T CLEAR JOB DATA AREA
	MOVE	T1,[XWD 62,63]	;CLEAR SYSTEM PDL'S ETC ABOVE TRAP LOCATIONS
	SETZM	62		;AND
	BLT	T1,136		;UP TO BASE OF COMMON
>; End IFCPU (KL)
SYS0A:	MOVSI T1, DVDIRIN+TTYATC
	HRRI T1,ASSCON+ASSPRG
	HLRZ F,DEVLST	;SCAN ALL DEVICES
SYS1:	ANDCAM T1, DEVMOD(F)	;CLEAR DIRECTORY IN CORE BIT,
				;ASSIGNED BY CONSOLE & PROGRAM
	SETZB T2,DEVLOG(F) ;CLEAR LOGICAL NAME AND T2
				; FOR NXM LOOP BELOW(SYS2-SYS3)

	MOVE M,DEVMOD(F)
	SETZM DEVIOS(F)
	SETZM DEVBUF(F)
	TLNE M,DVDSK!DVTTY
	JRST SYS2W	;DO NOT ASSIGN
	TRO M,ASSCON
	MOVEM M,DEVMOD(F)
	DPB T2,PJOBN	;ASSIGNED TO JOB 0
SYS2W:	HLRZ F, DEVSER(F)
	JUMPN F, SYS1
IFCPU (KI),<MOVE T1,ONCWBR
	HLRZM	T1,JBTUPM>
IFNCPU (KI),<MOVEI T1,UPT.PN
	MOVEM T1,JBTUPM>
	MOVEM T1,CURUPT
;NOW SET UP CORE THINGS.

	PUSHJ	P,FINALC	;SET UP THE SYSTEM TIME PCBS AND FREE CORE.
	PUSHJ	P,SETM2P	;SET UP INFO FOR M2 AND MP QS.
	MOVE	T2,SYSSIZ
	LSH	T2,-9	        ;CONVERT TO PAGES
	MOVEM	T2,SYSSZP
	HRRZ	T1,CFRLST	;
	HRRM	T2,CFRLST	;
	SUBI	T1,(T2)		;THE AMOUNT WE LOST
	SUB	T1,IOPQTA	;TAKE AWAY FROM CAVPGN FOR I/O PAGES.
	ADDB	T1,CAVPGN	;ADJUST FREE PAGES
	MOVEM	T1,USRMAX	;MAX VALUE FOR MWSLIM. PATCHERS NOTICE !!
				; (MUST NOT INCLUDE I/O PAGES, OR ELSE
				; MAY NOT BE ABLE TO SWAP JOBS IN)
	HRRZ	T2,T1		;NOT LARGER THAN 18 BITS
	CAILE	T2,VPMAX	;MWSLIM:=SMALLER OF USRMAX,VPMAX
	MOVEI	T2,VPMAX	;SO THAT HE GETS FULL LMAP
	MOVEM	T2,MWSLIM	;UNLESS NOT ENOUGH CORE FOR THAT.
	HRRZ	T2,T1		;18 BITS OF PAGE COUNT
	SUBI	T2,1
	LSH	T2,-2
	SUBI	T2,1
	LSH	T1,-1		;CONVERT USRMAX TO K
	CAMGE T1,CORLIM	;MAKE SURE WE HAVE AT LEAST THIS MUCH CORE
	STOPCD		;WE HAVE LESS, DON'T COME UP.
	MOVE T1,CORLIM
	LSH	T1,-1
	SUBI T1,1
	MOVEM T1,CORMXK	;SET UP CORMXK.
	MOVE PG,SYSSZP	;THE FIRST PAGE OF THE SYSTEM FOR USERS
	SETZ	W,		;
	SETO	T2,		;FOR SETTING PGYNXM AND PGYADR
	HRRZI	T4,CFR.N	;
	HRRZ	T3,CFRLST	;START OF FREE PAGE LIST.
NXPGLP:	CAMN PG,T3	;IS NEXT FREE = NEXT PAGE
	JRST PAGXM	;YES, MARK IT THERE
	DPB T2,PGYNXM	;NO, NOT THERE
	AOJA PG,NXPGLP	;AND CONTINUE

PAGXM:	DPB	W,PGYBPL	;
	DPB	T4,PGYLST	;
	DPB	T2,PGYADR	;SAY NO DP IN THIS CP YET.
	CAIGE PG,1000	;ARE WE ABOVE MAX ADDRESSABLE CORE?
EXTERN HGHBLK
	MOVEM PG,HGHBLK	;NO. SAVE HIGH BLOCK ADDRESS.
	LDB PG,PGYFPL	;NEXT FREE PAGE
	JUMPE PG,PAGXMD	;FINISHED
	EXCH	PG,T3	;GET T3/ FPL, PG/ BPL.
	HRRZI	W,(PG)	;SAVE BPL.
	AOJA PG,NXPGLP	;CONTINUE
PAGXMD:	MOVEI P,SYSPDL
	PUSHJ P,TTYINI	;INITIALIZE THINGS
	MOVEI T1,(HALT)
	HRLM T1,SYSDSP	;NO MORE 140 RESTART
IOGO:	SETZM CRSHWD		; POWER FAILURE INTERRUPTS
IFCPU (KI),<
	WRAPR	APRIOB!APRNXM!APRIOP!APRDST!APRDSR
	WRAPR	APRCH2+APRENC	;APR RESET (IO RESET)
	WRPI	211577		;CLEAR PI SYSTEM (AND MEM PARITY)
>;END IFCPU (KI)
IFCPU (<KL,F3>),<WRAPR	LP.IOR+LP.CSF+LP.NXM+LP.PAR ;DON'T CLEAR STUFF THAT SHOULDN'T BE ON
	WRAPR	LP.ESF+APRMSK+APRCHN		    ;ENABLE FOR EVERYTHING
	WRPI	LI.CPP+LI.CPS+LI.COF+LI.PIF+LI.ACO  ;CLEAR PI SYSTEM
IFCPU (KL),<PUSHJ P,ITMINI>	;START UP INTERVAL TIMER, INIT TIME BASE, ETC.
>;END IFCPU (<KL,F3>)
IFCPU (KS),<
	WRAPR	LP.IOR+LP.CSF+LP.NXM+LP.HPE +LP.80C;DON'T CLEAR STUFF THAT SHOULDN'T BE ON
	WRAPR	LP.ESF+APRMSK-<LP.TIM+LP.80C>+APRCHN	;ENABLE FOR EVERYTHING EXCEPT 8080 & TIME
	WRPI	LI.CPP+LI.CPS+LI.COF+LI.PIF+LI.ACO ;CLEAR PI SYSTEM
	PUSHJ	P,ITMINI	;START UP INTERVAL TIMER, INIT TIME BASE
>;END IFCPU (KS)
				; DO NOT CLEAR POWER FAIL AS THIS DISABLES
	MOVEI P,SYSPDL		;REUSABLE SPACE(SEE IOINI1)
	PUSHJ P,CTYSET##	;DO AFTER WRAPR	200000 SO PI ASSIGNMENT STAYS.
	PUSHJ P,NXTINI		;ALWAYS INITILIZE SCHEDULER FIST
				;SO DEVICES MAY RESET QUEUES IF DESIRED
	HLRZ	P3,DEVLST	;ADDR OF FIRST DDB
	SETZM SAVITM
IOG01:	MOVE F,P3		;SET UP F FOR INITIALIZATION CODE
				; (NOT ALWAYS USED)
	MOVE P3,DEVSER(P3)
	HRRZ T1,P3
	CAIE T1,@SAVITM		;SAME DEVICE
	PUSHJ P,DINI(P3)	;NO. INITIALIZE IT.
	HRRZM P3,SAVITM		;SKIP RETURN IF INITIALIZATION CODE IS TO BE CALLED
				; FOR EACH DEVICE (I.E. MULTIPLE U PRINTERS)
	HLRZS P3
	JUMPN P3,IOG01 		;LOOP FOR ALL DEVICES
IFKMC<
	PUSHJ P,DZINI##		;INITIALIZE DZ-11 DRIVER.
	PUSHJ P,DRINI##		;INITIALIZE DR-11C DRIVER
	PUSHJ P,KMCINI##	;INITIALIZE THE KMC COMMUNICATION
>; End IFKMC
	PUSHJ P,CLKINI		;INITIALIZE CLOCK QUEUE
	PUSHJ P,TMPINI		;TMPCOR
	PUSHJ P,QINI		;PUT ALL IN NULL QUE
	PUSHJ P,RMTINI		;DISPATCH
	SETZM	SYSDRB
IFCPU (KI),<PUSHJ P,TIMINI>	;DK-10
IFCPU (KI),<WRPI	52377>	;TURN ON PI SYSTEM
IFNCPU (KI),<WRPI LI.CON+LI.PIN+LI.ACO>

	MOVSI	T1,(STAUTO)	; See if we are in
	TDNN	T1,STATES	; "auto"-restart mode.
	  JRST	IOGO2		; No!  So don't say anything.
	MOVEI	T1,[ASCIZ \

System in auto-restart, running INITIA
\ ]
	MOVEI U,SCNLDB##	;ON CONSOLE
	PUSHJ P,CONMES##	;LET OPERATOR KNOW WHAT IS GOING ON

EXTERNAL CLRONC,NULJOB
IOGO2:	MOVEI	J,NULJOB	;GET WHERE TO MAKE CLRONC POPJ TO
	PUSH	P,J		;SAVE ON STACK
	SETZ	J,		;NEXT JOB IS NULL JOB
	JRSTF	@.+1		;CLEAR OUT EXEC MAP ONCE-TIME ENTRIES,
	  PC.UIO,,CLRONC	; SET PC.UIO AND POPJ TO NULJOB WHEN THRU.
;ERROR FOR NOW (DISCONTINUOUS CORE)

DSCCOR:	PUSHJ P,CLRSND
	PUSHJ P,INLMES
	ASCIZ /
????CORE IS NOT CONTIGUOUS, CORRECT BEFORE TRYING TO BRING UP SYSTEM/
	PUSHJ P,OPOUT
	HALT .
;RELOAD UPT AND EPT FROM THIS STUFF

LOC40:	JSR CH1
	STOPCD
	JSR CH2
	STOPCD
	JSR CH3
	STOPCD
	JSR CH4
	STOPCD
	JSR CH5
	STOPCD
	JSR CH6
	STOPCD
	JSR CH7
	STOPCD

UPTSET:
	USRMPE	;USER PAGE TRAP(SOFTWARE FOR KS AND KL)
	JFCL	;USER OVERFLOW
	ERRPOV	;USER PDL ERR
	JFCL	;USER TRAP 3
	0
	0
	0
	0
	UUOKNT	;KERNAL NO TRAP UUO
	UUOKTR	;KERNAL TRAP UUO
	UUOSNT	;SUPERVISOR NO TRAP
	UUOSTR	;SUPERVISOR TRAP
IFNCPU (KS),<UUOCNT	;CONCEALED NO TRAP
	UUOCTR	;CONCEALED TRAP
	XWD PC.UIO,UUOPNT	;PUBLIC NO TRAP
	XWD PC.UIO,UUOPTR>	;PUBLIC TRAP
IFCPU (KS),<XWD PC.UIO,UUOPNT	; NO TRAP, KS RUNS IN CONCEALED MODE
	XWD PC.UIO,UUOPTR	; TRAP,KS RUNS IN CONCEALED MODE
	0			;NO PUBLIC MODE ON KS
	0> ; End IFCPU (KS)

EPTSET:	EXCMPE	;EXEC MEM TRAP
	JFCL	;EXEC OVERFLOW
	EXCPDL	;EXEC PDLOV
	JFCL	;EXEC TRAP3

IFCPU (KI),<
NULACS:
	PHASE 0
	MOVEI 16,64000
	SOJG 16,.
NTS1:!	TLNE 17,400000
NTS2:!	TRNE 17,1
	JRST NULSHF
NTS3:!	TRNN 17,2
	JRST NULCMP
	TLC NTS1,004000	;CONVERT TXNE AND TXNN
	TLC NTS2,004000
	TLCA NTS3,004000
NULCMP:!TRCA 17,1
NULSHF:!ROT 17,1
	DATAO PI,17
	JRST 0
	0		;REG 16, SCRATCH
	1		;REG 17, STARTS AT 1
	DEPHASE
	PHASE NULACS+20
>;END IFCPU (KI)
IFCPU (<KL>),<
;ROUTINE TO INITIALIZE TIME BASE, ACCOUNTING CLOCK,
; AND INTERVAL TIMER.

ITMINI:	CONO	TIM,TO.CIT+TO.CTD	;CLEAR TIMER, TIMER DONE
	MOVE	T1,[JSR ITMINT]
	MOVEM	T1,EPT+EPTITI	;THIS IS THE IRP INSTRUCTION
	CONO	MTR,MO.TON+ITMCHN ;START TIME BASE, GIVE INTERVAL PI ASSIGNMENT
	SETZM	EPT+EPTHTB
	SETZM	EPT+EPTLTB
	SETZM	EPT+EPTHPA
	SETZM	EPT+EPTLPA
	WRPAE	[PE.CLR]	;CLEAR PERF METER
	WRUBR	[LG.IAM]	;CLEAR OUT E AND M BOX COUNTS
	SETZM	UPT+UPTHEC
	SETZM	UPT+UPTLEC
	SETZM	UPT+UPTHMC
	SETZM	UPT+UPTLMC
	CONO	MTR,MO.LAC+MO.AEN+MO.AO+MO.CTB
				;TURN ON ACCT METERS
	CONO	TIM,TO.SIT+TO.CTD+^D1666 ;GET INTERVAL TIMERSTARTED.
	POPJ	P,		;EVERYTHING ALL SET.
>;END IFCPU (KL)

IFCPU (KS),<
;ROUTINE TO INITIALIZE TIME BASE, INTERVAL COUNTER

EXTERNAL KAFPC,KPAFAL

ITMINI:	WRAPR	LP.CSF+LP.ITD	;CLEAR TIMER DONE
	WRTIME	ITMCLR		;CLEAR TIME BASE
	WRINT	ITMTIM		;SET INTERVAL UP
	WRAPR	LP.ESF+LP.TIM+APRCHN	;START INTERVAL TIMER
	HRLI	T1,(JRST 7,)	;SET UP 71 ,FOR CTY KEEP ALIVE FAILURE
	HRRI	T1,KAFPC	; ...
	MOVEM	T1,KPAFAL	; STORE IN LOW CORE
	MOVSI	T1,(KPACT)	;INIT RELOAD WORD,ENABLE KEEP ALIVE COUNTER
	JFCL	;**D*	MOVEM	T1,RLWORD##	;START KEEP ALIVE
	JFCL
	POPJ	P,

ITMCLR:	EXP 0,0			; Values to clear time base.
ITMTIM:	^D16B23			; Interval time.
>;END IFCPU (KS)
;TELTYPE ROUTINES

;ROUTINE TO READ A U FROM OPERATORS CONSOLE
;CALL:	PUSHJ P,GETLIN
;	JUST A CR TYPED IN
;	NORMAL RETURN (NOT A BLANK U)

GETLIN:	MOVE T1,LINEPI
	MOVEM T1,ONCTIP	;INITIAL STORAGE POINTER
	SETZM BKSLS	;NOT IN BACKSLASHES
	MOVEI T3,40		;PRIME COMMAND ROUTINES WITH A SPACE
	MOVEM T3,TTCMCH		; ..
	MOVEI J,0		;FLAG NO ALTMODE SEEN
GET1:	PUSHJ P,XTYI		;WAIT FOR A CHARACTER
IFCPU (<KI,F3>),<	DATAI TTY,T3>		;GET IT
IFCPU (<KL,KS>),<	PUSHJ	P,TYI1>
	ANDI T3,177		;STRIP PARITY
	CAIN T3,177		;RUBOUT?
	JRST DELETE		;YES
	CAIN T3,"U"-100
	JRST DELLIN
	CAIE T3,"C"-100
	CAIN T3,"O"-100
	JRST GET1	;IGNORE ^C AND ^O
	PUSHJ P,LEVBKS	;IN CAS IN BACKSLASHES
	CAIN T3,33		;ALTMODE/ESCAPE?
	JRST GETLN1		;YES
	CAIE T3,175		;OTHER ALTS?
	CAIN T3,176		; ..
	JRST GETLN1		;YES
GET2:	PUSHJ P,XTYO		;ECHO
	CAIL T3,140		;LOWER CASE?
	TRZ T3,40		;YES. MAKE UPPER
	IDPB T3,T1		;STORE IN INPUT BUFFER
	CAIE T3,15		;CAR RET?
	AOJA J,GET1		;NO. LOOP TILL BREAK
	MOVEI T3,12		;YES. ADD LF
	PUSHJ P,XTYO		;OUTPUT LF
	MOVEI T3,0		;TERMINATE INPUT STRING IN BUFFER
	IDPB T3,T1		; ..
	JUMPN J,CPOPJ1		;IF NON-NULL U, SKIP RET
	POPJ P,0		;NULL. NON-SKIP RET

BKSLS:	0
DELETE:	SOJL J,DELET1	;NOTHING THERE
	PUSHJ P,ENTBKS	;SEND \ IF NEEDED
	LDB T3,T1
	PUSHJ P,XTYO
	SUBI T1,1
	REPEAT 4,<IBP T1>
	JRST GET1	;BACK TO WORK

DELET1:	PUSHJ P,LEVBKS
	MOVEI T3,15
	PUSHJ P,XTYO
	MOVEI T3,12
	PUSHJ P,XTYO
	JRST GETLIN

GETLN1:	SETOM J		;MECHANISM USED TO BY-PASS PART OF DIALOGUE
	MOVEI T3,"$"
	PUSHJ P,XTYO
	MOVEI T3,15		; WHEN ALTMODE IS TYPED.
	JRST GET2

DELLIN:	PUSHJ P,LEVBKS
	PUSHJ P,ECHU		;ECHO THE ^U
	JRST GETLIN

LEVBKS:	SKIPN BKSLS
	POPJ P,		;NOT IN
COMBKS:	PUSH P,T3
	MOVEI T3,"\"
	PUSHJ P,XTYO
	POP P,T3
	SETCMM BKSLS	;COMPLIMENT
	POPJ P,

ENTBKS:	SKIPE BKSLS
	POPJ P,
	JRST COMBKS

ECHU:	PUSH P,T3
	MOVEI T3,"^"
	PUSHJ P,XTYO
	MOVE T3,(P)
	ADDI T3,100
	PUSHJ P,XTYO
	MOVEI T3,15
	PUSHJ P,XTYO
	MOVEI T3,12
	PUSHJ P,XTYO
	POP P,T3
	POPJ P,
OCONM:	PUSHJ P,CLRSND	;CLEAR OUTPUT SUPRESS FLAGS
	JRST CONMES		;OUTPUT MESSAGE

ONCTOS:	MOVEI T3,ONCTSZ		;SIZE OF BUFFER
	MOVEM T3,ONCCNT		;SO CANT OVERFLOW
	MOVEI T3,^D72
	MOVEM T3,LINWID	;SET LINE WIDTH
	MOVEI T3,ONCTYI		;ADDRESS FOR READ ROUTINES TO GO TO
	MOVEM T3,COMTIA		; ..
	MOVEI T3,ONCTYO		;ADDRESS FOR TYPEOUT ROUTINES TO GO TO
	MOVEM T3,COMTOA		; ..
	MOVE T3,LINEP		;INITIAL OUTPUT POINTER
	MOVEM T3,ONCTOP
CLRSND:	SETZM SUPTYP
	SETZM SUPTYC
	POPJ P,0

YESNO:	PUSHJ P,OCONM		;FIRST OUTPUT THE QUESTION
	PUSHJ P,OPOUT
	PUSHJ P,GETLIN	;NOW GET RESPONSE
	POPJ P,0		;JUST C-R
	PUSHJ P,COMTYI
	TRZ T3,40		;FIRST CHAR OF RESPONSE (U.C.)
	CAIN T3,"Y"		;WAS IT A Y ?
	AOS 0(P)		;YES. SKIP
	POPJ P,		;NO, MAYBE IT WAS "N". SO DON'T1 SKIP

LINWID:	0
SUPTYP:	0
SUPTYC:	0

RADIX8:	IDIVI T1,10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,RADIX8	;PRINT OCTAL
	HLRZ T3,(P)
	ADDI T3,"0"
	JRST COMTYO
;ROUTINE TO TYPE A U ON OPERATOR CONSOLE
;ECHO CHECK STOPS U AND RETURNS
;CALL:	U SET TO END OF MESSAGE

OPOUT:	MOVEI T3,0		;MAKE SURE STRING ENDS
	IDPB T3,ONCTOP		;WITH A NULL
	MOVE T1,LINEP		;AND RESTART AT BEGINNING
	MOVEM T1,ONCTOP	; ..
IFCPU (<KI,F3>),<CONO TTY,TT.CID>		;CLEAR INPUT FLAG
OPOUT1:	IFCPU (<KI,F3>),<CONSZ TTY,TT.ID>		;MAKE SURE NOT BEING INTERRUPTED
	IFCPU (KL),<SKIPE EPT+SPCMTI>
	IFCPU (KS),<SKIPE	CTYIWD##>	;SKIP IF NO INPUT
	JRST OPOUT2		;INPUT FLAG
OPOUT3:	ILDB T3,ONCTOP		;GET CHAR TO TYPE
	JUMPE T3,OTST3		;QUIT ON NULL, AND RESET OUTPUT
	PUSHJ P,XTYO		;TYPE CHAR
	JRST OPOUT1		;LOOP

OPOUT2:	IFCPU (<KI,F3>),<DATAI TTY,T3>
	IFCPU (<KL,KS>),<PUSHJ P,TYI1>
	ANDI T3,177	;GET RID OF PARITY BIT
	CAIE T3,"O"-100
	CAIN T3,"C"-100
	SKIPA
	JRST OPOUT1	;IGNORE ALL BUT ^O AND ^C
	PUSHJ P,ECHU
	CAIN T3,"C"-100
	SETOM SUPTYC	;IF ^C SET TO SUPRESS UNTIL QUESTION
	SETOM SUPTYP	;IN ANY CASE UNTIL CRLF
OTST3:	MOVE T3,LINEP	;RESET OUTPUT
	MOVEM T3,ONCTOP
	MOVEI T3,ONCTSZ
	MOVEM T3,ONCCNT
	POPJ P,

IFCPU (KL),<
TYI1:	MOVE	T3,EPT+SPCF11
	CONO	DTE,CL11PT
	SETZM	EPT+SPCMTI
	POPJ	P,
>;END IFCPU (KL)


IFCPU (KS),<
TYI1:	MOVE	T3,CTYIWD	;GET CHARACTER
	TRNN	T3,CTYIVL	;CHEK VALID
	JRST	OPOUT3		;JUMP IF CHAR. NOT YET VALID
	SETZM	CTYIWD##	;CLEAR INPUT WORD
	POPJ	P,
> ;END IFCPU (KS)
ONCTIP:	0			;TYPE-IN POINTER
ONCTOP:	0			;TYPE-OUT POINTER
ONCCNT:	0			;COUNTER FOR TYO
LINEP:	POINT 7,LINBUF		;INPUT AND OUTPUT U BUFFER
LINBUF:	BLOCK 30
ONCTSZ==<30*5>-1		;CHARACTERS WHICH FIT IN OUTPUT BUFFER
LINBFI:	BLOCK 30	;BUFFER FOR INPUT
LINEPI:	POINT 7,LINBFI
CORLIM:	USRLIM			;PRSET CORE LIMIT, MAY CHANGE
SAVITM:	0		;TEMP FOR INITIALIZING DEVICES
;WAIT TIL INPUT DONE ON BEFORE RETURNING WITH NEXT CHAR.

XTYI:	IFCPU (<KI,F3>),<CONSO TTY,TT.ID>
	IFCPU (KL),<SKIPN EPT+SPCMTI>
	IFCPU (KS),<SKIPN	CTYIWD##>
	JRST XTYI
	POPJ P,

ONCTYO:	SKIPE SUPTYC
	POPJ P,		;WANT ALL SUPPRESSED
	SKIPE SUPTYP
	JRST ETYCHK	;CHECK FOR LINE FEED TO END SUP
	SOSLE ONCCNT		;COUNT CHARACTERS
	IDPB T3,ONCTOP		;PUT IN BUFFER
	POPJ P,0		;AND RETURN

ONCTYI:	ILDB T3,ONCTIP		;GET INPUT CHARACTER
	MOVEM T3,TTCMCH		;STORE FOR RE-READS
	POPJ P,0		;AND RETURN TO CALLING ROUTINE

ETYCHK:	CAIN T3,12
	SETZM SUPTYP
	POPJ P,

XTYO:	IFCPU (<KI,F3>),<CONSZ TTY,TT.OB
	JRST XTYO>	;WAIT FOR NOT BUSY
	PUSH P,T1
	ANDI T3,177
	CAIE T3,12
	CAIN T3,177
	JRST NOFCR	;DO NOT COUNT LINE FEED OR RUBOUT
	CAIN T3,15
	JRST	[MOVEI T1,^D72
		MOVEM T1,LINWID	;RESET COUNT BEFORE CR
		JRST NOFCR]
	SOSL LINWID
	JRST NOFCR
	PUSH P,T3
	MOVEI T3,15
	PUSHJ P,XTYO
	MOVEI T3,12
	PUSHJ P,XTYO
	POP P,T3
IFCPU (<KI,F3>),<XTYO1:	CONSZ TTY,TT.OB
	JRST XTYO1
NOFCR:	PUSHJ P,PEVEN8	;GET PARITY
	DATAO TTY,T3>
IFCPU (<KL,KS>),<NOFCR:	PUSHJ P,TYO1>
	ANDI T3,177
	CAIN T3,15	;CHECK POSSIBLE RETURN
	SKIPN T1,CTYFIL	;YES, NEED FILLS?
	JRST TPOPJ	;NO
	MOVEI T3,177
	PUSHJ P,XTYO
	SOJG T1,.-1
	MOVEI T3,15
TPOPJ:	POP P,T1
	POPJ P,

IFCPU (KL),<
TYO1:	HRLM	T3,(P)
	MOVEI	T3,.DTCTO(T3)
	MOVEM	T3,EPT+SPCCMW
	CONO	DTE,TO11DB
	SETZ	T3,
	EXCH	T3,EPT+SPCMTD
	JUMPE	T3,.-1
	HLRZ	T3,(P)
	POPJ	P,
>;END IFCPU (KL)

;CHARACTER OUTPUT FOR CTY ON KS2020

IFCPU (KS),<
TYO1:	SKIPE	CTYOWD##		;WAIT TIL EMPTY
	JRST	.-1
	TRO	T3,CTYOVL		;SET THE VALID FLAG
	MOVEM	T3,CTYOWD##		;MOVE TO OUTPUT WORD
	WRAPR	LP.SSF!LP.I8C+APRCHN	;WHAP THE 8080
	SKIPE	CTYOWD			;WAIT TIL CHAR TAKEN
	JRST	.-1
	POPJ	P,
>;END IFCPU (KS)
;FINISH UP THINGS
	LIT
	VAR
ONCLNR=.-%ONC+1
ONCLNP=<ONCLNR!777>+1

ONSZCK(ONCE,ONC)	;CHECK TO SEE IF ENOUGH PAGES ALLOCATED

DEPHASE

;EXTERNALS AND INTERNALS


;GENERAL PARAMETERS

EXTERNAL CTYFIL,MEMSIZ,JOBSYM,SYSDSP,SYSPDL,DDTSYM,SYSDDT,DDTEND
EXTERNAL MEMSZP,SYSSZP,JBTUPM,UPSJOB
EXTERNAL PATSIZ,PMEMSZ,$1B,PJOBN,GETWDS
IFCPU (KI),<EXTERNAL APRCH2>
IFNCPU (KI),<EXTERNAL APRCHN>
EXTERNAL SYSBEG,SYSEND,SYSPDL,DEVLST,CRSHWD,NMRBPC,NMSTPC,WRDSPP
EXTERN %SAT.C,%RIB.C,%RB2.C,%CTLRU,%CTMRU,%CTLST
EXTERN %UPT,%UPS,EPYPSN,USYPTN
EXTERN M2REQ,M2SWT,PSREQ,PSSWT,PRREQ,PRSWT,M2HAV,SIREQ,SISWT,RIREQ,RISWT
IFCPU (<KL>),<EXTERNAL ITMCHN,ITMINT>
IFCPU (KL),<EXTERNAL SPCINI>

;ROUTINES IN OTHER PLACES

EXTERNAL PEVEN8,DDTX,CTEXT,COMTYI,CONMES,CPOPJ1,CRLF,FILMAN
EXTERN REFLAG,FSFPPN
EXTERNAL FILOPT,INLMES,LNGMES,DECLOP,ASKQMM,TYPONL,RADX10,ONCTIM
EXTERNAL LINKDB,NULJOB

;INTERNALS

INTERNAL ONCGO,PATSYM,YESNO,OPOUT,OCONM,GETLIN,CLRSND,ONCBUG
INTERN ONCLNP
INTERNAL SYSZRO

;FOR SETTING UP UPT

EXTERNAL CURUPT,EPT,EPT.PN,INTNUM,INTTAB,JFY2SC,JFYHR,JFYMIN
IFCPU (KL),<EXTERNAL CSRTAB>
EXTERNAL JFYSC2,JFYSEC,JOBN,MIDNIT,QQYSD,QQYTTY,JFYS12
EXTERNAL SERIAL,STATES,UPT,UPT.PN,UPTACP,UPTAC0,UPTPC
EXTERNAL SYSCRS,CH1,CH2,CH3,CH4,CH5,CH6,CH7,USRMPE
EXTERNAL ERRPOV,UUOKNT,UUOKTR,UUOSNT,UUOSTR,UUOCNT,UUOCTR
EXTERNAL UUOPNT,UUOPTR,EXCMPE,EXCPDL
IFNCPU (KI),<EXTERNAL PGFAIL,PGFUIO>	;NEED A PAGE FAIL DISPATCH ON KLS
IFNCPU (KI),<EXTERN EPTEBR>

;FOR TTY CONTRO AND USE DURING ONEC ONLY CODE

EXTERNAL COMTIA,COMTOA,TTCMCH,MAX,MIN,COMTYO

;VARIOUS SYSTEM PARAMETERS PRINTED AND MODIFIED

EXTERNAL CONFIG,SYSDAT,THSDAT,TIME,USRLIM,SYSSIZ

;STUFF FOR PAGE TABLE

EXTERN PGYUNU,PGYPGO,PGYFPL,PGYLMA,PGYLMJ,PGYLMV,PGYBPL
EXTERN PGYDIO,PGYADR,PGYUNI,PGYPNO,PGYSPT,PGYSPB,PGYSPO,PGYCHT,PGYSIO
EXTERN PGYSIP,PGYSOP,PGYERR,PGYNXM,PGYDRT,PGYATB,PGYUSE,PGYCSH
EXTERN PGYSTS
EXTERN PGYLST,CFRLST,CAVPGN,MAXPCB,CFR.N,USELST,USE.N,MINPCB
EXTERN SNDPGY,CNTPGY,IOPQTA,CHTPTR,CHTMSK
EXTERN SIDLST,SODLST
EXTERN USRMAX,MWSLIM

;STUFF FOR CORE CONTROL

EXTERNAL CORMXK

;INITIALIZE ROUTINES

EXTERNAL CLKINI,NXTINI,QINI,RMTINI,TMPINI,TTYINI
IFCPU (KI),<EXTERNAL TIMINI>
EXTERNAL DDBLEN


	END ONCGO
     a