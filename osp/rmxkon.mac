TITLE RMXKON
SUBTTL RM03 DRIVER
SALL

;THIS HACK WRITTEN BY DANIEL S. BLOM
;ASSEMBLE WITH KSSYM.MAC, WHICH SHOULD CONTAIN KS-10 I/O INSTRUCTION OPDEFS.

;DEPENDENCIES:
;IN ORDER TO CLEAR THE RH11C CONTROLLER, A DRIVE WHICH DEFINATELY EXISTS
; MUST BE SELECTED.  THIS CODE ASSUMES UNIT 0 ALWAYS EXIST.

EXTERN BITTBL,PIHIGH,PILOW,RMACB
EXTERN UNIPPU,UNYPPY,UNYBPT,UNYPUN,UNISVA,UNITWC,UNIOFS
EXTERN UNISBH,UNISB,UNISBS,SBSIZ
EXTERN UNIBLK,FILINT,KCMOFL,%OFLER,%OFLRS,KONCUA
EXTERN KCMDTA,KONPTR
EXTERN KCMFUS,KCMERR,KCMRER
EXTERN UNIRCT,UNPDEV,EPT,UNIDES,UNYUTP
EXTERN UNYOCV,UNYRTO,UNYRCO,UNYOS,UNIRC1,UNISB

;BIT TABLE, LSB=INDEX 0
ZOT==1
TIBTBL::
REPEAT 44,<ZOT
ZOT==ZOT+ZOT>

OPDEF CALL [PUSHJ P,]		;SUBROUTINE ENTRY/EXIT
OPDEF RET [POPJ P,]

DEFINE FOO(BAR,ZORP,BAZ,S)
<BAR'AD1: 1,,BAR'ADR
BAR'LOC=BAR'ADR
>

;DEVICE REGISTER BIT ASSIGNMENTS.  SEE USER MANUAL FOR SEMANTICS.  NOTE
; THAT THESE VALUES ARE ACTUALLY DEFINED IN KSSYM, REPEATED HERE FOR CLARITY.
FOO (CS1,776700,<SC,TRE,MCPE,,DVA,PSEL,A17,A16,RDY,IE,F4,F3,F2,F1,F0,GO>)
    ;FUNCTION CODES + GO BIT.
	F.PA==23
	F.RIP==21
	F.DC==11
	F.RD==71
	F.NO==1
	F.WD==61
	F.SEEK==5
	F.RECA==7
	F.OFFS==15
FOO (CS2,776710,<DLT,WOE,UPE,NED,NEM,PGE,MXF,MDPE,OR,IR,CLR,PAT,BAI,U2,U1,U0>)
FOO (DS,776712,<ATA,ERR,PIP,MOL,WRL,LBT,PGM,DPR,DRY,VV,,,,,,OM>)
FOO (WC,776702)
FOO (AS,776716)
FOO (ER1,776714,<DCK,UNS,OPI,DTE,WLE,IAE,AOE,HCRC,HCE,ECH,WCF,FER,PAR,RMR,ILR,ILF>)
FOO (ER2,776742,<BSE,SKI,OPE,IVC,LSC,LBC,,,DVC,,,DPE>)
FOO (EC1,776744)
FOO (EC2,776746)
FOO (BA,776704)
FOO (OF,776732,<OFD>,200)
FOO (LA,776720)
FOO (DA,776706)
FOO (DC,776734)
FOO (DT,776726)
FOO (PGR,763000,<REV,DIS,FST,VAL>,400000)
UA1AD1:	UA1,,UBAADR

;DISK PARAMETER ARRAYS.  IDX0, RM03.  IDX1, RP06.
PPC:	EXP ^D37,^D95			;PAGES PER CYLINDER
BPC:	EXP ^D37*4,^D95*4		;BLOCKS PER CYLINDER
PPU:	EXP ^D37*^D823,^D95*^D815	;PAGES PER UNIT
BPT:	EXP ^D30,^D20			;BLOCKS PER TRACK
USPR=^D17300	;MICROSECONDS PER REVOLUTION.

;INTERFACE TO FILIO AND FRIENDS.

;INITIALIZE UNIT AND SET PARAMETERS IN UDB.
RMXCPY::RDIO T3,@DTAD1
	ANDI T3,2
	LSH T3,-1
	DPB T3,UNYUTP		;0: RM03, 1: RP06
	MOVE T1,PPC(T3)
	DPB T1,UNYPPY		;PAGES PER CYLINDER
	MOVE T1,PPU(T3)
	MOVEM T1,UNIPPU(U)	;PAGES PER UNIT
	MOVE T1,BPT(T3)
	DPB T1,UNYBPT		;BLOCKS PER TRACK
	MOVEI T4,3		;TRY TO GET DRIVE 3 TIMES
CPY0:	MOVEI T3,CS2CLR		;CLEAR CONTROLLER.  SELECTS UNIT 0.
	WRIO T3,@CS2AD1
	LDB T1,UNYPUN		;SELECT DRIVE
	WRIO T1,@CS2AD1
	RDIO T2,@DSAD1
	RDIO T1,@CS2AD1		;CHECK CONTROLLER
	MOVEI T3,CS2CLR		;CLEAR CONTROLLER. NOTE SELECTS UNIT 0.
	WRIO T3,@CS2AD1
	TRNN T1,CS2NED		;DRIVE THERE?
	 JRST CPY1		;YES
	SKIPA T1,[%OFLRS]
CPYERR:	 MOVEI T1,%OFLER
	MOVEM T1,UNIBLK(U)
CPYER1:	MOVSI T1,KCMOFL
	JRST FILINT
CPY1:	TRNN T2,DSMOL		;DRIVE ON LINE?
	 JRST [	SETZM UNIBLK(U)
		JRST CPYER1]
	LDB T1,UNYPUN		;SELECT UNIT AGAIN.
	WRIO T1,@CS2AD1
	MOVEI T1,F.PA		;TRY TO SET DSVV
	WRIO T1,@CS1AD1
	RDIO T2,@DSAD1
	TRNE T2,DSVV		;VOLUME VALID?
	 JRST CPY2
	MOVEI T1,F.DC		;DRIVE CLEAR
	WRIO T1,@CS1AD1
	SOJG T4,CPY0
	JRST CPYERR		;GIVE UP IF STILL BAD
CPY2:	MOVSI T1,(1B1)
	TRNE T2,DSWRL		;WRITE LOCKED?
	 MOVEM T1,UNIBLK(U)	;YES, SET BIT
	TRNE T2,DSERR		;ANY RANDOM ERRORS LEFT?
	 JRST CPYERR		;YES, SAY OFFLINE.
	LDB T1,UNYPUN
	MOVE T1,BITTBL(T1)
	JRST FILINT

;SKIP IF CONTROLLER UP, SINGLE RETURN IF NOT.
RMXUPA::MOVEI T1,UBAINI		;CLEAR UBA
	WRIO T1,@UA1AD1
	MOVEI T1,PIHIGH*10+PILOW	;RESET PIA.  SILLY HARDWARE CLEARS IT.
	WRIO T1,@UA1AD1
	RDIO T1,@CS1AD1
CPOPJ1:	AOS (P)
CPOPJ:	RET

;STOP HUNG CONTROLLER.  SINGLE RETURN IF OPERATION COULDN'T
; BE RESTARTED, SKIP IF IT COULD.  CURRENTLY, ALWAYS SINGLE RETURNS.
RMXSTP::LDB T1,UNYPUN
	WRIO T1,@CS2AD1
	MOVEI T1,F.DC+CS1IE
	WRIO T1,@CS1AD1
	RET

;ISSUE RECALIBRATE (SAME EFFECT AS SEEK TO
; CYLINDER 0, BUT DOESN'T USE SEEK CIRCUITRY).  SKIP IF COULD (ALWAYS SKIPS).
RMXRCL::LDB T1,UNYPUN
	WRIO T1,@CS2AD1
	MOVEI T1,F.RECA+CS1IE
	WRIO T1,@CS1AD1
	POPJ P,0			;JRST CPOPJ1 /GL 6-11-80

;PERFORM LATENCY CALCULATION FOR BLOCK SPECIFIED BY T1.  THE
; LATENCY IS THE TIME REQUIRED FOR THE HEAD TO REACH
; THE SECTOR SPECIFIED BY T1 FROM THE
; CURRENT HEAD POSITION (WHICH IS GIVEN BY THE LA REGISTER).
RMXLTM::SETO T4,
	MOVEI T3,3		;TRY TWICE FOR CONSTANT
LTM1:	MOVE T2,T4
	RDIO T4,@LAAD1
	CAME T2,T4
	 SOJG T3,LTM1
	LSH T4,-6
	LDB T3,UNYUTP
	IDIV T1,BPC(T3)		;BLOCK WITHIN CYLINDER
	IDIV T2,BPT(T3)		;BLOCK WITHIN TRACK.
	LDB T1,UNYUTP
	SUBI T3,(T4)		;DELTA BLOCKS
	SKIPGE T3
	 ADD T3,BPT(T1)		;HAVE TO GO AROUND AGAIN.
	IMULI T3,USPR		;CLOSE ENOUGH SINCE RP06, RM03
				; SAME PERIOD
	MOVE T1,T3
	RET

;ENTER OFFSET MODE.  NOT YET IMPLEMENTED.
RMXOFS::SETZ T1,		;ALWAYS CLEAR OFFSET MODE FOR NOW.
	JRST RMXOF1
	LDB T1,UNYPUN		;SELECT UNIT.
	WRIO T1,@CS2AD1
	LDB T1,UNYOCV
	JUMPE T1,RMXOF1		;J-CLEAR OFFSET MODE.
	ANDI T1,1		;SET OFFSET DIRECTION.
	IMULI T1,OFOFD
	WRIO T1,@OFAD1
	MOVEI T1,1		;SET OFFSET MODE.
RMXOF1:	DPB T1,UNYOS
	RET

;HERE FROM FILIO TO COPY REGISTERS INTO PERMANENT PLACE FOR HARD ERRORS

RMXHRD::HRLI	T1,UNISB(U)	;GET SOURCE ADDRESS
	HRRI	T1,UNISBH(U)	;GET WHERE THE REG DATA GOES
	BLT	T1,UNISBH+SBSIZ-1 ;XFER THE DATA.
	POPJ	P,		;DONE.

;HERE TO COPY REGISTERS TO UNISBS FOR SOFT DATA, CALL FROM FILIO
RMXSFT::MOVSI	T2,UNISB(U)	;SOURCE
	HRRI	T2,UNISBS(U)	;DEST
	BLT	T2,UNISBS+SBSIZ-1 ;BLT THERE
	POPJ	P,		;AND RETURN.
;THE NEXT THREE ROUTINES FORM THE BODY OF THE TRANSFER CODE.
;RED,WRT INITIALIZE; ADD ATTEMPTS TO CONSOLIDATE MULTIPLE
; TRANSFERS IN THE SAME DIRECTION TO OR FROM THE DISK;
; FIN STARTS THE TRANSFER UP.
;THE TRANSFER WILL NOT CROSS A CYLINDER BOUNDARY.
;THE ACS P1-P4 ARE PRESERVED BY FILIO OVER THE PSEUDO CO-ROUTINE CALLS,
; AND ARE USED AS FOLLOWS:
;   P1/ READ OR WRITE COMMAND AS APPROPRIATE
;   P2/ RH: NUMBER OF PDP-10 WORDS ALREADY DECIDED TO TRANSFER.
;           THIS IS USUALLY ALSO THE VIRTUAL ADDRESS OF THE START OF THE XFR.
;       LH: PDP-10 PAGE OFFSET OF FIRST WORD TO BE TRANSFERRED. (USUALLY 0)
;   P3/ NUMBER OF WORDS BEFORE END OF CYLINDER.
;       THE ADD ROUTINE WILL NOT WRITE MORE THAN THIS NUMBER OF
;       WORDS AT ONCE.

RMXRED::SKIPA P1,[F.RD+CS1IE]
RMXWRT::MOVEI P1,F.WD+CS1IE
	SETZ P2,
	MOVE T1,UNIBLK(U)	;DISK ADR OF TRANSFER START.
	LDB T4,UNYUTP
	IDIV T1,BPC(T4)		;T1: CYLINDER
	MOVE P3,BPC(T4)
	SUBI P3,(T2)
	LSH P3,7		;P3: NUMBER OF WORDS TO END OF CYLINDER.
	CAILE P3,37000		;31P MAX. BECAUSE OF WC REGISTER.
	 MOVEI P3,37000
	LDB T4,UNYPUN		;UNIT USED FOR TRANSFER
	WRIO T4,@CS2AD1
	LDB T4,UNYUTP
	IDIV T2,BPT(T4)		;T2: TRACK, T3: SECTOR
	DPB T2,[101000,,T3]
	WRIO T3,@DAAD1
	RET

;ADD TRANSFER OF T1 WORDS TO/FROM CORE ADDRESS IN T2.
;TRANSFERS WHICH AREN'T EVEN MULTIPLES OF PAGES GOING TO
; PAGE BOUNDARIES WILL BE DONE ONE AT A TIME.
RMXADD::TRNN T1,777
	 TRNE T2,777
	  JRST ADDNPA		;NOT EVEN TRANSFER
ADDEVN:	CAMGE P3,T1		;More space than is actually left?
	 SKIPA T1,P3		;NO, ONLY TO END OF CYLINDER
	  AOS (P)		;YES, SET FOR SKIP RETURN
	SUBI P3,(T1)
	LDB T3,[111100,,P2]	;VIRTUAL PAGE THIS TRANSFER STARTS AT
	ADDI P2,(T1)
	LSH T1,-9		;CONVERT TO PAGES
	SKIPN T1		;BUT AT LEAST ONE MUST BE MAPPED.
	 MOVEI T1,1
	MOVE T4,T2		;PDP-10 ADR OF START OF THIS TRANSFER
	LSH T2,-9
	MOVNS T1
	HRL T2,T1
	ADD T3,[1,,PGRLOC]	;FIRST PAGING RAM ENTRY TO SET.
ADDPLP:	HRRZI T1,PGRFST+PGRVAL(T2)	;FAST, VALID.
	WRIO T1,@T3
	AOJ T3,
	ADDI T4,1000
	AOBJN T2,ADDPLP
	RET

ADDNPA:	MOVE P2,T2
	ANDI P2,777
	MOVSS P2
	CALL ADDEVN
	 STOPCD	(SLO)		;SYSTEM WOULD HANG OTHERWISE.
	RET			;CAN ONLY DO ODD TRANSFERS ONE AT A TIME.

RMXFIN::HLRZ T1,P2		;PDP-10 PAGE OFFSET OF TRANSFER START.
	LSH T1,2		;CONVERT TO -11 OFFSET.
	ANDI T1,3777		;OFFSET WITHIN -11 PAGE (USUALLY 0).
	WRIO T1,@BAAD1
	MOVEM T1,UNISVA(U)	;SAVE STARTING VIRTUAL ADR IN CASE OF ERROR.
	MOVNI P2,(P2)
	LSH P2,1
	MOVEM P2,UNITWC(U)	;SAVE TOTAL WORD COUNT IN CASE OF SOFT ERROR.
	WRIO P2,@WCAD1
	HRRZM U,KONCUA(J)	;SET UDB OF TRANSFERING UNIT
	LDB T2,UNYOS		;SET UP OFFSET MODE IF IN E.R.
	RDIO T1,@DSAD1
	TRO T1,(T2)
	WRIO T1,@DSAD1
	WRIO P1,@CS1AD1		;START TRANSFER.
	RET


RMXPOS::LDB T1,UNYPUN		;SELECT UNIT.
	WRIO T1,@CS2AD1
	MOVE T1,UNIBLK(U)
	LDB T2,UNYUTP
	IDIV T1,BPC(T2)
	WRIO T1,@DCAD1
	MOVEI T1,F.SEEK+CS1IE
	WRIO T1,@CS1AD1
	RET

;INTERRUPT HANDLER.
;ON ENTRY, ASSUMES J=KDB.  SETS U TO UDB OF TRANSFERRING
; UNIT IF IT INTERRUPTED.

;ASSUMES:
; INTR REQ <=> CS1.(SC & RDY) + (RDY 0-1 TRANSITION)
; CS1.SC <=> CS1.(TRE + MCPE) + ATTN
; CS1.TRE <=> ANY ERROR DURING TRANSFER
; ATTN <=> (DS.ERR SET FOR ANY DRIVE) +
;	 (POSITIONING DONE IN ANY DRIVE) +
;	 (DS.MOL CHANGES STATE FOR ANY DRIVE)
; DS.MOL STATE CHANGE <=> DS.VV=0

RM0INT::
RMXINT::0				;JSR HERE ON DISK INTERRUPT
	TBSAVE TBVRMX			;SAVE THE CURRENT VALUE OF THE TIME BASE
	MOVEM 17,RMXSAV+17
	MOVEI 17,RMXSAV
	BLT 17,RMXSAV+16
	MOVE P,RMXPDP
	MOVEI J,RMACB
	SETZB T1,P4
	SKIPN U,KONCUA(J)
	 SETO P4,
	RDIO T4,@CS1AD1
	TRNE T4,CS1SC		;SPECIAL CONDITION?
	 CALL SCINT		;YES, PROCESS
	JUMPL P4,INTDIS
;HERE TO ACCOUNT FOR TRANSFER
	RDIO T4,@BAAD1
	SUB T4,UNISVA(U)
	TRZE T4,777		;ROU TO BLOCKS
	 ADDI T4,1000
	LSH T4,-11
	HRRI T1,(T4)
	TLC T1,KCMDTA
	SETZM KONCUA(J)		;REMEMBER CONTROLLER NO LONGER BUSY
INTDIS:	RDIO T4,@CS1AD1		;MAKE SURE IE SET AND ERRORS CLEAR
	SETZ P1,
	TRNN T4,CS1IE
	 HRRZI P1,CS1IE
	TRNN T4,CS1TRE+CS1MCPE
	 IORI P1,CS1TRE
	SKIPE P1
	 WRIO P1,@CS1AD1
	SKIPE T1
	 CALL FILINT
	MOVSI 17,RMXSAV
	BLT 17,17
	TBSET TBVRMX		;RESET THE TIME BASE FOR CHARGING
	JEN @RMXINT
SCINT:	TRNN T4,CS1MCPE
	 TRNE T4,CS1TRE
	  CALL CONERR		;CONTROLLER OR TRANSFER ERROR
	SETZ T3,		;ATA BITS TO CLEAR
	RDIO P2,@ASAD1
ATA1:	JUMPE P2,SCRET
ATA2:	JFFO P2,.+1
	MOVNI P3,-43(P3)	;RH=UNIT NUMBER
	SKIPN @KONPTR(J)	;SYSTEM CONFIGURED TO HANDLE THIS UNIT?
	 JRST ATADIS		;NO, SPURIOUS INTERRUPT
	WRIO P3,@CS2AD1
	RDIO P1,@DSAD1
	TRNE P1,DSERR		;DRIVE ERRORS?
	 CALL DRVERR		;YES, JUST CLEAR THEM
	TRNN P1,DSVV		;DS.MOL STATE CHANGE?
	 CALL CHKONL		;YES, CHECK ONLINE STATUS
ATADIS:	MOVE P1,TIBTBL(P3)
	TRZN P2,(P1)		;CLEAR ATA TOO
	 JRST ATA3
	IOR T3,P1
	IOR T3,BITTBL(P3)
ATA3:	JUMPN P2,ATA2
SCRET:	WRIO T3,@ASAD1
	HLRZS T3
	TLO T1,(T3)		;SEEK DONE, SET FLAG FOR FILINT
	RET
CHKONL:	TRNN P1,DSMOL		;ONLINE?
	 JRST CHKON1		;NO
	MOVEI T4,F.RIP		;READ IN PRESET
	WRIO T4,@CS1AD1
	MOVEI T4,F.DC		;DRIVE CLEAR
	WRIO T4,@CS1AD1
	TDO T1,BITTBL(P3)	;SET FILIO FLAG
	RET
CHKON1:	JUMPN U,ONLRET		;FILIO INTERFACE LOSSAGE
	MOVE U,@KONPTR(J)
	TLOA T1,KCMOFL
ONLRET:	 TDZ P1,TIBTBL(P3)	;DON'T CLEAR BIT IF CAN'T REPORT
DRVERR:	SKIPE U
	 CALL SAVSTS		;READ RH11 AND DRIVE STATUS INTO UDB.
	RDIO T4,@ER1AD1
	TRNE T4,ER1UNS		;FILE UNSAFE?
	 JRST [	JUMPN U,DERET
		MOVE U,@KONPTR(J)
		TLO T1,KCMFUS+KCMOFL
		JRST .+1]
	MOVEI T4,F.DC		;CLEAR DRIVE ERRORS+ATA
	WRIO T4,@CS1AD1
DERET:	TDZ P1,TIBTBL(P3)	;DON'T CLEAR ATA BIT
	RET

;CONTOLLER ERROR OR ERROR DURING TRNASFER
CONERR:	CALL SAVSTS		;SAVE RH11 AND DRIVE STATUS IN UDB.
	JUMPL P4,CPOPJ		;RETURN IF NOT XFR
	LDB T4,UNYPUN
	WRIO T4,@CS2AD1
	MOVEI T4,DSMOL
	TDNN T4,UNISB+2(U)
	 JRST [	TLO T1,KCMOFL+KCMDTA
		JRST CONRET]
	MOVSI T4,-NERPAT
FNDERR:	MOVE T3,UNISB(U)
	MOVE T2,UNISB+1(U)
	TDNN T2,ERPAT(T4)
	 TDNE T3,CSPAT(T4)
	  CALL @XFRDSP(T4)	;PROCESS ERROR (ROUTINE MUST SKIP RETURN)
	   AOBJN T4,FNDERR
	TLC T1,KCMERR
	MOVEI T4,F.DC		;CLEAR DRIVE
	WRIO T4,@CS1AD1
CONRET:	MOVEI T4,CS1TRE
	WRIO T4,@CS1AD1
	RET

;ERROR PATTERNS
;TYPE,DEVICE,RETRY BEFORE RECAL,RECAL,
; RETRY AFTER RECAL,CS1,CS2,ER1,ER2,W,X,Y
; HERE W= NUMBER OF OFFSET STATES TO CYCLE THROUGH AFTER RECALS FINISHED.
;      X= NUMBER OF TIMES TO RETRY TRANSFER AFTER OFFSETING.
;      Y= NUMBER OF TIMES TO RECAL IF RETIRES AFTER OFFSET FAIL.
DEFINE ERRS <
X DEV,1,12,0,0,,<DLT,NEM,MXF>,<WCF>,,4,3,1
X PAR,0,12,0,0,<MCPE>,<MDPE,UPE>,<PAR>,<DPE>,0,0,0
X FMT,0,12,12,12,,,<HCRC,HCE,FER,ECH,DTE>,<BSE>,4,3,1
X PGM,1,1,0,0,,<PGE>,<WLE,RMR,IAE,AOE,ILR,ILF>,<IVC>,0,0,0
X SEK,1,0,12,12,,,<OPI>,<SKI>,4,1,1
X DAT,0,0,0,0,,,<DCK>,,0,0,0
X UNS,0,0,0,0,,<NED>,,<LSC,LBC,DVC,OPE>,0,0,0
>

;COMPLEXITY OF MACROS IS DUE TO THE LOSING ASSEMBLER BEING USED.
DEFINE BAZ(A,B,C,D) <
BAR A,<B>,ZZ
BAR C,<D>,ZZ1
ZZ,,ZZ1
>

DEFINE BAR(Y,X,Z) <
IFB <X>,<Z==0>
IFNB <X>,<
Z==0
IRP X,<Z==Z+Y'X>
>
>

DEFINE X(A,R1,R2,R3,R4,B,C,D,E,W,X,Y) <
A'ERR
>
XFRDSP:	ERRS
NERPAT==.-XFRDSP

DEFINE X(A,R1,R2,R3,R4,B,C,D,E,W,X,Y) <
BAZ CS1,<B>,CS2,<C>
>
CSPAT:	ERRS

DEFINE X(A,R1,R2,R3,R4,B,C,D,E,W,X,Y) <
BAZ ER1,<D>,ER2,<E>
>
ERPAT:	ERRS

DEFINE X(A,R1,R2,R3,R4,B,C,D,E,W,X,Y) <
R4+200000+UNPDEV*R1,,R3*1000+R2
Y,,X*1000+W
>
RCVPAT:	ERRS

;READ ALL REGISTERS INTO UDB.
SAVSTS:	PUSH P,T3
	LDB T3,UNYUTP
	MOVE T4,REGPTR(T3)
	MOVE T2,[POINT 18,UNISB(U)]
SAVST1:	ILDB T3,T4
	JUMPE T3,PT3J
	ADD T3,[1,,CS1ADR-1]
	RDIO T3,@T3
	IDPB T3,T2
	JRST SAVST1
PT3J:	POP P,T3
	RET
REGPTR:	POINT 6,RM03RG
	POINT 6,RP06RG
RM03RG:	BYTE (6) 1,11,15,43,3,13
	BYTE (6) 5,17,21,47,25,27
	BYTE (6) 31,33,35,41,7,45
	0
RP06RG:	BYTE (6) 1,11,15,43,3,13
	BYTE (6) 5,7,17,21,25,33
	BYTE (6) 31,35,37,41,45,47
	0

;HERE ON VARIOUS ERRORS WHICH OCCURRED DURING TRANSFER.
; T2/ ER1,,ER2   T3/ CS1,,CS2

;RECOVERABLE DATA ERROR
DATERR:	RDIO P2,@BAAD1		;FIRST -11 ADR AFTER ERROR BLOCK.
	SUBI P2,200*4		;-11 ADR OF ERROR BLOCK.
	LSH P2,-9-2		;-11 PAGE NUMBER OF ERROR BLOCK.
	ADD P2,PGRAD1
	RDIO P2,@P2		;-10 PAGE # OF ERROR BLOCK.
	LDB P2,[111300,,P2]
	TRO P2,PGE.A+PGE.W
	DPB P2,[EPTPGP(%ERR.N)]	;MAP %ERR TO PAGE CONTAINING ERROR BLOCK..
	CLRPT %ERR		;INVALIDATE THIS ENTRY IN THE PAGING CACHE.
	RDIO P2,@EC1AD1		;BIT NUMBER OF BURST.
	CAILE P2,^D18*^D256
	 JRST BADECC
	SOJL P2,BADECC
	IDIVI P2,44
	RDIO T2,@WCAD1		;-# 18. BIT WORDS LEFT IN TRANSFER.
	HRRZ T3,UNITWC(U)	;-# 18. BIT WORDS SUPPOSED TO DO.
	SUBM T2,T3		;+# 18. BIT WORDS TRANSFERRED.
	LSH T3,-1		;+# 36. BIT WORDS TRANSFERRED.
				;Also relative offset within transfer
				; of first block after error block.
	JUMPE	T3,BADECC	;Hdw is only supposed to report error
				; after >=1 physical transfer.
	SUBI	T3,200		;Relative offset of error block
	ANDI	T3,777		;Relative offset within error page
	TRNE T3,177		;DEVICE IS SUPPOSED TO INDICATE ECC TYPE ERRORS
	 JRST BADECC		; ONLY ON A SECTOR BOUNDARY.
	ADDI P2,(T3)		;FIRST WORD IN ERROR.
	RDIO T2,@EC2AD1		;ERROR BURST.
	SETZ T3,
	ROTC T2,(P3)
	MOVSS T2
	MOVSS T3
	TRC P2,177		;FIX SECOND WORD IF IN BLOCK.
	TRCE P2,177
	 XORM T3,%ERR+1(P2)
	XORM T2,%ERR(P2)
	TLCA T1,KCMRER+KCMERR	;RECOVERABLE
BADECC:	 TLC T1,KCMERR
	RET
;NOT A DATA ERROR, SET INITIAL ERROR RECOVERY VARIABLES AND PARAMETERS
; IF NOT ALREADY IN THE MIDDLE OF AN E.R. PROCEDURE.
DEVERR:PARERR:FMTERR:PGMERR:SEKERR:
	SKIPE UNIRCT(U)
	 RET
	LSH T4,1
	DMOVE T1,RCVPAT(T4)
	MOVEM T1,UNIRCT(U)
	MOVEM T2,UNIRC1(U)
	ASH T4,-1
	RET

UNSERR:	SETZM UNIRCT(U)
	SETZM UNIRC1(U)
 	TLO T1,KCMERR+KCMDTA+KCMOFL	;TAKE UNIT OFFLINE
	TLNE T2,ER1UNS		;UNSAFE?
	 TLO T1,KCMFUS
	RET

TBVRMX:	BLOCK 2			;2 WORDS TO SAVE THE TIME BASE VALUE
RMXSAV:	BLOCK 20
RMXPDP:	-60,,.
	BLOCK 60

END
    ' mâ