TITLE	PCBIO	PCB HANDLERS

	ENTRY PCBIO

PCBIO:



;EXTERNALS

EXTERN DEV1UN,DEVDRB

EXTERN RBREAL,RBSPAR,RBYPNO,RBYUNI,RBMASK

EXTERN UNIPPU,UNISTR,UNISTT,UNIMRC,UNIMWC

EXTERN STRDDB,STRUNI,STRBTS,SRPRPT

EXTERN PRAVAL,PSAVAL,PRQ,PSQ,PRREQ,PSREQ,PRWAIT,PSWAIT,PRSWT
EXTERN PSSWT,RIAVAL,RIQ,RIREQ,RISWT,RIWAIT,MLOWQ,SIREQ,QUEPCB
EXTERN FCAVAL,FCREQ,FCWAIT,M2AVAL,M2Q,M2REQ,M2SWT,M2WAIT,REQTAB
EXTERN SIAVAL,SIQ,SISWT,SIWAIT,AVALTB

EXTERN JBTPCB,PJBSTS,TPOPJ,TPOPJ1

EXTERN PGYSIP,PGYSOP,PGYDRT,PGYADR,PGYERR,PGYUNI,PGYSIO,PGYLMA

EXTERN %UPT,UPTRIB,UPTRB2,UPTSAT

EXTERN STYINC,STTLEN,STTAOB,STTPTR,SATFUL,GSATST
EXTERN STPCHK,STPINC,STTSTS,STPRPT,SATBAD,STPBAD,SATBRD

EXTERN DSKPIN,DSKPIF

EXTERN MINPCB,MAXPCB

EXTERN CPOPJ,CPOPJ1,SAVE4,JOB,BLKSPP,CURUPT,PJOBN,TPOPJ
EXTERN UNTTBL,NMSTPC,NMRBPC,TPOPJ,WSCHED,WAIT1,RNQ,SETRUN
EXTERN GIV4WD,GET4WD,CBUSER,SWPENQ,PAGWAK,PAGWAT


;SOME DEFINITIONS

DEFINE DSKOFF <WRPI DSKPIF>
DEFINE DSKON <WRPI DSKPIN>

;PCB'S ARE ALLOCATED FROM FREECORE AT ONCE TIME, NEVER MOVE
;THEREAFTER. ONCE ALLOCATES NMRBPC+NMSTPC PCB'S. THESE PARAMS
;LIVE IN LVDTBL IN COMMOD.
;
;STANDARD THROUGHOUT PCBIO: T2/ PCB ADDRESS
;
;THE FORM OF A PCB IS:

	PHASE 0
PCBPTR::! 0	;RETRIEVAL POINTER OF PAGE CURRENTLY LIVING IN THIS PCB
PCBTIM::!
PCBLKQ::! 0	;LH=CLOCK FOR CLOSE. RH=HEAD OF LOCK QUEUE IN QUEPCB
PCBSTS::!	;STATUS BITS (SEE PCUSTS,PCISTS BELOW)
PCBLCC::!	;LOCK COUNT, SEE PCYLCC
PCBUSC::! 0	;RH=USE COUNT
PCBPAG::!	;PHYSICAL CORE PAGE NUMBER CONTROLLED BY THIS PCB
PCBLNK::! 0	;RH=FORWARD LINK TO NEXT PCB OF SIMILAR TYPE
	DEPHASE

    PCUSTS: POINT 4,PCBSTS(T2),^D8 ;BITS OF PCBSTS NOT CHANGED
			;AT INTRPT LVL(MAY BE CHANGED BY FAULT).
    PCISTS:: POINT 5,PCBSTS(T2),^D4 ;BITS OF PCBSTS THAT MAY BE
			;CHANGED BY AN INTERRUPT.
    PCYLCC: POINT ^D9,PCBLCC(T2),^D17
    PCMLCC==:000777
;STATUS BITS IN PCISTS.
STDDRF==20	;DIRTY MONITOR FLAG
  STPDRF==400000	;ITS THE SIGN BIT
STDPRE==10	;DATA PRESENT
STDREA==4	;DATA READ
  STPREA==100000
STDWRT==2	;DATA WRITE
STDWAG==1	;DATA WRITE AGAIN

;STATUS BITS IN PCUSTS.
STWRTL==4
STCMPL==2
STSNEW==1

;STATUS CODES IN THE %CTSTS FIELDS:
STARDU==0
STAWTU==1
STALOK==2 ;CODES ABOVE THIS ARE LOCKED.
STACML==2
STAWTL==3
STARDL==4
STAWLN==5

;STATUS FIELDS QUYPCS GET THE SAME VALUES AS %CTSTS, BUT IN ADDITION,
STQPCB==1000	;THIS BIT SET IN QUYPCS FLAGS THAT LEFT HALF OF 
		;QUEPCB(J) IS A REAL PCB ADDRESS.


PCBTAB:: Z	;POINTER TO TABLE OF ADDRESSES OF PRIMARY PCBS,
		;SET UP BY ONCE CODE.

;A PCB IS IN ONE OF THE FOLLOWING STATES:
;
;	ONE COMPLETELY LOCKED ACCESSOR.
;	ONE WRITE LOCKED ACCESSOR + PERHAPS SOME READ UNLOCKED
;	    ACCESSORS + PERHAPS SOME WRITE UNLOCKED ACCESSORS.
;	SOME READ LOCKED ACCESSORS + PERHAPS SOME READ UNLOCKED
;	    ACCESSORS + PERHAPS SOME WRITE UNLOCKED ACCESSORS.
;	PERHAPS SOME READ UNLOCKED ACCESSORS + PERHAPS SOME
;		WRITE UNLOCKED ACCESSORS.
;A CONTROL BLOCK IS:

DEFINE CTLBLK (CLASS,TYPE,POSN)
<
%'CLASS'.C::
PHASE 0
%CTBYP::!  EPTPGS(%'CLASS'.N,%UPT)	;;BYTE PNTR TO MAP SLOT.
%CTLST::!  Z				;;RH=PNTR TO PCB CHAIN.
%CTUPT::!  %UPT+UPT'CLASS		;;ADDR OF UPT ENTRY(UPTRIB...)
%CTSTS::!  POINT 6,JBTPCB(T1),<<<POSN*6>-1>+18>
%CTADR:!  POINT 6,JBTPCB(T1),<<POSN*6>-1>
%CTLRU::!  Z				;;ADDR OF TOP OF FREE PCB LIST.
%CTMRU::!  Z				;;ADDR+1 MRU ON FREE PCB LIST.
%CTWRQ:! TYPE'REQ
%CTWVL:! TYPE'AVAL
DEPHASE >

%CTAMX==000077	;MAX PERMISSABLE VALUE TO DPB %CTADR

;;GEN THE CONTROL BLOCKS.
CTLBLK(RIB,RI,1)
CTLBLK(RB2,RI,2)
CTLBLK(SAT,SI,3)

;JBTPCB IS LAID OUT SO THAT, FOR T1/JOB, ALL %CTSTS FIELDS
;ARE IN RH (MORE FREQ ACCESSED) AND %CTADR FIELDS IN LH.
INTERN MAPRDL,MAPWTL,MAPRDU,MAPWTU,MAPCML,MAPWLN
INTERN STDPRE,STDREA,STDWRT,STDWAG,STPREA
INTERN STAWTU,STAWTL,STACML,STAWLN

;TABLE OF ENTRY POINTS, INDEXED BY STAXXX'S.
CODADR:	MAPRDU
	MAPWTU
	MAPCML
	MAPWTL
	MAPRDL
	MAPWLN

;TABLE OF PCUSTS BITS, INDEXED BY STAXXX'S.
CODBTS:	Z
	Z
	STCMPL
	STWRTL
	Z
	STWRTL!STSNEW

QUYPCP: POINT ^D8,QUEPCB(J),^D17 ;NO. OF PREVIOUS JOB IN QUEUE.
QUYPCS: POINT ^D10,QUEPCB(J),^D27 ;STATUS BITS FOR THIS JOB.
QUYPCN: POINT ^D8,QUEPCB(J),^D35 ;NO. OF NEXT JOB IN THE QUEUE.
PPCBWC:: EXP 0	;PRIM PCB WAIT COUNTER PERFORMANCE CHECKING
SPCBWC:: EXP 0	;SECONDARY..
COMMENT #
@@SUBROUTINE MAPRDL/MAPWTL/MAPRDU/MAPWTU/MAPCML/MAPWLN
@@PURPOSE
SUBROUTINES TO GET A PCB.
@@ENTRY
ENTRY POINTS ARE:
	MAPRDL--READ LOCKED
	MAPWTL--WRITE LOCKED
	MAPRDU--READ UNLOCKED
	MAPWTU--WRITE UNLOCKED
	MAPCML--COMPLETELY LOCKED
	MAPWLN--WRITE LOCKED NEW

EXPECTS PG/ADDR OF CONTROL BLOCK, T1/DISK POINTER, AND F/ DDB.
@@CALLS
CALLS THE SUBRS GETLRU, RESLRU, RESMRU, SETPCB, GET4WD,
FCWAIT, LINKPB, UNLNK2, CHKSTS, STUPLQ, AND ENLOKQ.
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@ #
;SET UP T2 WITH VARIOUS STATUS BITS.


MAPRDL:	MOVEI	T2,STARDL	;SET THE
	JRST	MAPALL		;STATUS
MAPWTL:	MOVEI	T2,STAWTL	;REQUESTED ON
	JRST	MAPALL		;ENTRY SO WE
MAPCML:	MOVEI	T2,STACML	;CAN
	JRST	MAPALL		;USE IT
MAPWLN:	MOVEI	T2,STAWLN	;BELOW.
	JRST	MAPALL

MAPRDU:	MOVEI	T2,STARDU
	JRST	MAPALL
MAPWTU:	MOVEI	T2,STAWTU	;FALL INTO MAPALL.


MAPALL:	PUSH	P,P1		;CARRY THE REQUEST STATUS IN
	HRRZ	P1,T2		;P1
	SKIPE	T1		;BE SURE RETR PTR IN
	TLNN	T1,RBREAL	;T1 IS IN
	STOPCD			;A CORRECT FORM.
	TLZ	T1,RBMASK-RBREAL ;
	MOVSI	T3,-3		;WE KNOW ABOUT 3 PCB CONTROL BLOCKS
MAPAL2:	CAMN	PG,MAPTBL(T3)	;CALLER MUST HAVE %RIB.C,ETC. IN PG
	JRST	MAPAL3		;GOOD, CALLER KNOWS WHAT HE IS DOING
	AOBJN	T3,MAPAL2
	STOPCD			;CALLER BLEW IT
MAPAL3:	LDB	T4,%CTBYP(PG)	;T4/MAP SLOT CONTENTS
	JUMPN	T4,.+2		;SLOT AND
	SKIPE	@%CTUPT(PG)	;UPTXXX HAD BETTER BOTH BE ZERO
	STOPCD			;(CALLER SUPPOSEDLY DOESNT HAVE A
				;PCB OF THIS TYPE !)
	JRST	@MAPTB1(T3)	;DISPATCH

MAPTBL:	%SAT.C
	%RB2.C
	%RIB.C

MAPTB1:	MAPSAT
	MAPRB2
	MAPRIB
MAPRIB:	PUSHJ	P,DMPSAT	;PREVENT DEADLOCKS.
MAPSAT:	PUSH	P,J		;WE USE THIS
	MOVE	J,JOB		;A LOT.
MPALOT:	PUSH	P,P2		;FLAG TO RESTART FREE CORE
	SETZ	P2,		;WAITERS.
	JRST	GETPCB

MAPRB2:	PUSHJ	P,DMPSAT	;PREVENT DEADLOCKS.
	PUSH	P,J		;
	MOVE	J,JOB		;
	LDB	T3,%CTBYP+%RIB.C ;GET MAP SLOT FOR RIB.
	SKIPE	@%CTUPT+%RIB.C	;SLOT AND UPTXXX HAD BETTER
	JRST	MAPR24		;BE BOTH 0 OR BOTH <>0.
	JUMPN	T3,MAPDIE	;HERE ON 0, WE DON'T HAVE %RIB,
	PUSHJ	P,GETM2		;SO JUST GET M2.
	JRST	MPALOT		;

MAPR24:    ;HERE ON HAVE TO RELEASE %RIB, Q FOR M2, AND THEN
	    ;GET %RIB AGAIN.
	JUMPN	T3,.+2		;
MAPDIE:	STOPCD			;UPTRIB AND %RIB SLOT DISAGREED
	PUSH	P,T1		;RETR PTR
	MOVE	T1,JOB
	LDB	T3,%CTSTS+%RIB.C ;SAVE THE STATUS OF
	PUSH	P,T3		;HOW WE GOT %RIB.
	HRRZ	T2,@%CTUPT+%RIB.C ;T2/ PCB ADDRESS FOR %RIB.
	PUSH	P,PCBPTR(T2)	;SAVE %RIB'S DISK POINTER.
	MOVEI	PG,%RIB.C	;RELEASE
	PUSHJ	P,MAPRLS	;%RIB.
	AOSLE	M2REQ		;GET
	PUSHJ	P,M2WAIT	;M2.
	PUSHJ	P,M2SRMV	;TAKE US OFF M2SWT.
	PUSHJ	P,M2HSWT	;PUT US ON M2HAV.
	POP	P,T1		;T1/DISK POINTER.
	POP	P,T2		;RESTORE %RIB'S STATUS.
	PUSHJ	P,@CODADR(T2)	;GET THE RIB AGAIN.
	POP	P,T1		;RESTORE %RB2'S DISK PNTR
	MOVEI	PG,%RB2.C	;AND PG.
	JRST	MPALOT



;TINY SUBR TO GET THE M2 RESOURCE.
;MUST BE CALLED WITH J/ JOB NUMBER.
;DESTROY NO ACS
GETM2::	AOSLE	M2REQ		;
	PUSHJ	P,M2WAIT	;GET M2.
	PUSHJ	P,M2SRMV	;TAKE US OFF M2SWT.
	PJRST	M2HSWT		;PUT US ON M2HAV.
    ;FIRST, LOOK FOR A PCB WITH THE DESIRED ADDRESS.
GETPCB:	HRRZ	T2,%CTLST(PG)	;GET A POINTER TO THE PCBS.
GETPC1:	CAMN	T1,PCBPTR(T2)	;FOUND THE ADDRESS WE WANT?
	JRST	[HLRZ T3,PCBPAG(T2) ;YES,  WE CAN USE THIS
		JUMPE T3,GTPCFN ;PCB IF (A) IT IS A
		HRRZ T4,PCBUSC(T2) ;SECONDARY, OR (B) IT
		JUMPN T4,GTPCFN ;IS A PRIMARY IN
		MOVE T4,PSREQ ;USE ALREADY, OR
		CAIE PG,%SAT.C ;(C) WE ARE ALLOWED
		MOVE T4,PRREQ ;TO GET A FREE PRIMARY.
		AOJLE T4,GTPCFN ;O'E, WE MUST WAIT IN A
		JRST GTSPCB] ;SECONDARY PCB.
	HRRZ	T2,PCBLNK(T2)	;GET NEXT PCB.
	JUMPN	T2,GETPC1	;JUMP IF THERE IS A NEXT ONE.

    ;NOT FOUND.  IS THERE A FREE PRIMARY PCB?
	MOVE	T4,PSREQ	;ARE WE ALLOWED
	CAIE	PG,%SAT.C	;TO GET A
	MOVE	T4,PRREQ	;FREE PRIMARY
	AOJG	T4,GTSPCB	;PCB?  JUMP ON NO.
	PUSHJ	P,GETLRU	;TRY TO GET LRU TO T2.
	JRST	GTWTIO		;JUMP IF ALL HAVE IO IN PROGRESS.

    ;HERE ON A FREE PRIMARY PCB.
	MOVEI	T3,PSREQ	;TELL THE WORLD
	CAIE	PG,%SAT.C	;WE HAVE OR WILL HAVE
	MOVEI	T3,PRREQ	;A PRIMARY
	AOSLE	(T3)		;PCB.
	STOPCD
	JUMPE	P2,.+2		;MAYBE FLAG TO RESTART THE
	SETOM	FCAVAL		;FREE CORE WAITERS.
	MOVEM	T1,PCBPTR(T2)	;PUT DSK PNTR IN 1ST LOC OF PCB.
	PUSHJ	P,SETPCB	;SET 2ND & 3RD LOCS IN PCB.
GTDONE:	HRRM	T2,@%CTUPT(PG)	;SET UPTXXX.
	HLRZ	T3,PCBPAG(T2)	;SET THE MAP
	TRO	T3,PGE.C	;TURN ON CACHE BIT.
	DPB	T3,%CTBYP(PG)
	SETZM	QUEPCB(J)
	HRRZ	T1,%CTLST(PG)	;CHAIN DOWN LIST OF PCB'S ON
	HLRZ	T3,PCBPAG(T1)	;THIS %XXX.C, SKIPPING OVER
	JUMPN	T3,GTDON3	;SECONDARY PCBS WHICH WE KEEP AT
	HRRZ	T1,PCBLNK(T1)	;THE FRONT OF THE LIST. (THEY
	JUMPN	T1,.-3		;HAVE PCBPAG/0 )
	STOPCD
GTDON3:	MOVEI	T4,1		;NOW COUNT IN T4/POSITION ON
GTDON4:	CAIN	T2,(T1)		;LIST OF OUR PCB
	JRST	GTDON6		
	HRRZ	T1,PCBLNK(T1)	
	JUMPN	T1,.+2		
	STOPCD
	AOJA	T4,GTDON4	
GTDON6:	;RECORD REQUEST STATUS %CTSTS AND PCB "ADDRESS" (REALLY
	;AN INDEX) IN %CTADR FOR THIS PCB FOR THIS JOB
	HRRZ	T1,J
	TRZ	P1,STQPCPB	P1,%CTSTS(PG)
	CAILE	T4,%CTAMX	;OVERFLOW %CTADR?
	STOPCD
	DPB	T4,%CTADR(PG)
	POP	P,P2		;RESTORE P2.
	POP	P,J		;
	POP	P,P1		;RESTORE P1.
	CLRPTO	%RIB	;CLEAR 3 POSSIBLE VIRTUAL ADDRESSES IT COULD BE
	CLRPTO	%RB2
	CLRPTO	%SAT	;(ON KI, WILL BE SLOWER).
	POPJ	P,
    ;HERE ON MAYBE NO PCB WITH OUR DISK ADDRESS, BUT NO FREE PRIMARY
    ;PCB.  MAKE A SECONDARY PCB AND THEN WAIT FOR A PRIMARY PCB.

GTSPCB:	PUSHJ	P,GT2ND		;
	JRST	GETPCB		;

      ;GET PRIMARY PCB.
GTSPC4:	CAIE	PG,%SAT.C	;DO
	JRST	GTSPC5		;THIS
	AOSLE	PSREQ		;OUT
	PUSHJ	P,PSWAIT	;IN
	PUSHJ	P,PSSRMV	;
	JRST	GTSPC6		;LONGHAND,
GTSPC5:	AOSLE	PRREQ		;SINCE CLOCK1
	PUSHJ	P,PRWAIT	;LOOKS AT THE AOSLE.
	PUSHJ	P,PRSRMV	;
GTSPC6:	PUSH	P,T2		;SAVE LOC OF 2NDARY PCB.

    ;IS THERE A PRIMARY PCB WITH OUR DISK PNTR ALREADY?
GTSP65:	HRRZ	T2,%CTLST(PG)	;SKIP OVER THE
	HLRZ	T3,PCBPAG(T2)	;SECONDARY
	JUMPN	T3,GTSPC7	;PCBS AT THE START
	HRRZ	T2,PCBLNK(T2)	;OF THE
	JUMPN	T2,.-3		;LIST.
	STOPCD
GTSPC7:	MOVE	T3,(P)		;GET THE
	MOVE	T3,PCBPTR(T3)	;PNTR WE WANT.
	CAMN	T3,PCBPTR(T2)	;MATCH?
	JRST	GTPRSC		;YES.
	HRRZ	T2,PCBLNK(T2)	;NO, CONTINUE LOOKING.
	JUMPN	T2,GTSPC7	;

    ;HERE ON NO PRIMARY WITH OUR POINTER ALREADY.
	PUSHJ	P,GETLRU	;GET A PRIM PCB AND CLR DATA PRESENT.
	JRST	GTWTI4		;
	JRST	GTSP80		;

GTWTIO:	PUSHJ	P,GT2ND		;
	JRST	GETPCB		;
	PUSH	P,T2		;SAVE LOC OF SECONDARY PCB.
	MOVEI	T3,PSREQ	;TELL THE WORLD
	CAIE	PG,%SAT.C	;WE HAVE OR WILL HAVE
	MOVEI	T3,PRREQ	;A PRIMARY
	AOSLE	(T3)		;PCB.
	STOPCD
GTWTI4:	CAIE	PG,%SAT.C	;
	JRST	GTWTI6		;
	AOSLE	SIREQ		;
	PUSHJ	P,SIWAIT	;
	SOSL	SIREQ		;
	SOS	SIAVAL		;
	PUSHJ	P,SISRMV		;
	JRST	GTSP65		;
GTWTI6:	AOSLE	RIREQ		;
	PUSHJ	P,RIWAIT	;
	PUSHJ	P,RISRMV		;
	SOSL	RIREQ		;
	SOS	RIAVAL		;
	JRST	GTSP65		;

      ;SECONDARY TO PRIMARY.
GTSP80:	SETZ	T3,		;
	DPB	T3,PCISTS	;
GTSPC8:	MOVE	T1,(P)		;T1/ LOC OF SECONDARY PCB.
	PUSHJ	P,UNLNK2	;REMOVE 2NDARY FROM PCB LIST.
	PUSH	P,T2		;GIVE IT BACK
	MOVE	T2,T1		;TO THE FREE
	MOVEI	T1,1		;CORE POOL.
	PUSHJ	P,GIV4WD	;
	POP	P,T2		;T2/ LOC OF PRIMARY PCB.
	POP	P,T1		;T1/ LOC OF 2NDARY PCB.
	HRRZ	T3,PCBLKQ(T1)	;PCB INFO TO
	HRRM	T3,PCBLKQ(T2)	;THE PRIMARY PCB EXCEPT
	MOVE	T3,PCBPTR(T1)	;COPY THE
	CAME	T3,PCBPTR(T2)	;
	JRST	GTSPC9		;
	DSKOFF			;
	LDB	T3,PCISTS	;
	MOVE	T4,PCBUSC(T1)	;
	MOVEM	T4,PCBUSC(T2)	;
	DPB	T3,PCISTS	;
	DSKON			;
	JRST	GTSP10		;
GTSPC9:	MOVEM	T3,PCBPTR(T2)	;2NDARY
	MOVE	T3,PCBUSC(T1)	;FOR THE PAGE NO AND THE FORWARD
	MOVEM	T3,PCBUSC(T2)	;LINK.

    ;GO THRU THE LOCK QUEUE, RESTARTING THE JOBS THAT CAN RUN.
GTSP10:	LDB	T1,QUYPCN	;T1/ NO. OF NEXT JOB IN THE QUEUE.
	HRRM	T1,PCBLKQ(T2)	;REMOVE US FROM LOCK QUEUE.
	JUMPE	T1,GTDONE	;JUMP IF NONE BUT US IN QUEUE.
	MOVE	J,T1		;
	HRLM	T2,QUEPCB(J)	;
	LDB	T1,QUYPCS	;
	TRO	T1,STQPCB	;
	DPB	T1,QUYPCS	;
	LDB	T1,PCUSTS	;T1/PCB UUO-LEVEL STATUS.
	LDB	T3,PCYLCC	;T3/PCB LOCK COUNT.
	PUSHJ	P,STUPLQ	;START UP SELECTED JOBS.
GTDON0:	MOVE	J,JOB		;RESTORE J.
	JRST	GTDONE		;
    ;HERE WITH A PRIMARY WHEN WE HAVE A SECONDARY WITH THE SAME ADDRESS.
GTPRSC:	HRRZ	T1,PCBUSC(T2)	;IF THE PRIMARY'S USE COUNT =
	JUMPN	T1,GTPRS2	;0, THEN GET IT OFF THE
	PUSHJ	P,GETTRU	;LRU/MRU LIST AND TREAT IT
	JRST	GTSPC8		;ALMOST LIKE A STRANGE PRIMARY.

GTPRS2:	MOVE	T1,(P)		;T1/ LOC OF SECONDARY PCB.
	PUSHJ	P,UNLNK2	;REMOVE IT FROM THE PCB LIST.
	EXCH	T2,(P)		;GIVE IT
	MOVEI	T1,1		;BACK TO THE
	PUSHJ	P,GIV4WD	;FREE CORE POOL.
	POP	P,T2		;RESTORE T2/ PRIMARY PCB ADDRESS.
	CAIE	PG,%SAT.C	;SINCE THIS PRIMARY
	JRST	GTPRS3		;IS ALREADY
	SOSL	PSREQ		;IN USE, WE SHOULDN'T
	SOS	PSAVAL		;COUNT
	JRST	GTPRS4		;OUR TAKING IT
GTPRS3:	SOSL	PRREQ		;AS TAKING
	SOS	PRAVAL		;A RESOURCE.
GTPRS4:	TRZ	P1,STQPCB	;
	PUSHJ	P,TAGONN	;CAN OUR REQUEST START?
	JRST	GTPRS8		;YES.

      ;HERE WHEN OUR REQUEST CAN'T START.
	MOVE	J,JOB		;ENLOKQ US AND
	PUSHJ	P,ENLOKQ	;OUR FOLLOWERS, TOO.
	MOVEI	T1,MLOWQ	;
	DPB	T1,PJBSTS	;
	LDB	T1,PCUSTS	;TRY TO
	LDB	T3,PCYLCC	;START
	HRRZ	J,PCBLKQ(T2)	;ANYBODY WHO
	PUSHJ	P,STUPLQ	;CAN.
	MOVE	J,JOB		;HAVE WE
	LDB	T1,PJBSTS	;STARTED? (DEBUGGING
	CAIE	T1,MLOWQ	; CHECK.).
	STOPCD
	PUSHJ	P,WSCHED	;
	JRST	GTDONE

      ;HERE WHEN OUR REQUEST CAN START.
GTPRS8:	LDB	J,QUYPCN	;DO WE HAVE FOLLOWERS?
	JUMPE	J,GTDON0	;NO.
	PUSHJ	P,ENLOKQ	;YES.  ENLOKQ THEM.
	LDB	T1,PCUSTS	;
	LDB	T3,PCYLCC	;
	HRRZ	J,PCBLKQ(T2)	;
	PUSHJ	P,STUPLQ	;SEE IF ANY OF THEM CAN START.
	JRST	GTDON0		;
    ;HERE ON FOUND A PCB WITH OUR DISK POINTER.
GTPCFN:	JUMPE	P2,.+2		;
	SETOM	FCAVAL		;
	JUMPE	T3,GTFND6	;ONLY PRIM PCBS HAVE A PAGE NO.

    ;HERE ON FOUND A PRIMARY PCB.
	PUSHJ	P,TAGONN	;SEE IF WE CAN START OUR REQ.
	JRST	GTDON0		;YES, WE CAN.
	AOS	PPCBWC		;PRIM PCB WAIT COUNTER
	TDZA	T4,T4		;CAN'T.  GO Q. (FLAG SAW PRIM.).

    ;HERE FOR FOUND A SECONDARY PCB.
GTFND6:	SETO	T4,		;FLAG SAW SECONDARY.
	MOVE	J,JOB		;RESTORE J.
	SETZM	QUEPCB(J)	;
	PUSHJ	P,ENLOKQ	;SINCE WE CAN'T START, PUT US
	MOVEI	T2,MLOWQ	;AT THE END OF THE QUEUE, AND
	DPB	T2,PJBSTS	;THEN
	PUSHJ	P,WSCHED	;WAIT.
	HLRZ	T2,QUEPCB(J)	;T2/ PCB ADDR.
	JUMPE	T4,GTDONE	;JUMP IF ORIG SAW PRIM.
	AOS	SPCBWC		;SECONDARY PCB WAIT COUNTER
	HLRZ	T3,PCBPAG(T2)	;ELSE, NOW HAVE A PRIMARY PCB?
	JUMPE	T3,GTSPC4	;JUMP ON NO.
	JRST	GTDONE		;
COMMENT #
@@SUBROUTINE TAGONN
@@PURPOSE
SUBR TO SEE IF WE CAN START A REQUEST FOR A PRIMARY PCB
THAT MAY HAVE USERS ALREADY.
@@ENTRY
EXPECTS T2/ ADDR OF PCB, P1/ USUAL REQUEST STATUS, PG/ CNTL
BLOCK ADDRESS.
@@ACCUM
DESTROYS T1 THRU T4 AND J.
@@EXIT
IF REQ CANNOT START, SKIP RETURN HAVING DONE NOTHING.  ELSE,
NON-SKIP RETURN WITH REQ STATUS IN PCB, ETC., READY TO
GO TO GTDON0.
@@ #

TAGONN:	LDB	T1,PCUSTS	;PCB
	TRNE	T1,STCMPL	;CMPL?
	JRST	CPOPJ1		;YES, WE CAN'T START.
	HRRZ	J,PCBLKQ(T2)	;NO.  ANYBODY IN THE
	JUMPE	J,TAGON2	;LOCK QUEUE?
      ;HERE WHEN THERE IS A LOCK QUEUE.
	CAIL	P1,STALOK	;ARE WE A REQ TO LOCK?
	JRST	CPOPJ1		;YES, CAN'T START.
      ;HERE WHEN THERE IS A LOCK Q AND WE ARE AN UNLOKQ REQ.
      ;WE CAN START PROVIDED THERE IS NOBODY IN THE LOCK QUEUE
      ;WHO WANTS TO CMPL.
TAGON1:	LDB	T1,QUYPCS	;
	TRZ	T1,STQPCB	;
	CAIN	T1,STACML	;
	JRST	CPOPJ1		;
	LDB	J,QUYPCN	;
	JUMPN	J,TAGON1	;
	AOS	PCBUSC(T2)	;OKAY, START
	POPJ	P,		;US.
      ;HERE WHEN NOBODY WAS IN THE LOCK QUEUE.  TRY TO
      ;START US UP.
TAGON2:	HRRZ	T1,PCBUSC(T2)	;IS ANYBODY AT ALL USING
	JUMPN	T1,TAGN25	;THIS PCB?
	PUSHJ	P,GETTRU	;NO, MUST BE ON LRU/MRU LIST.
	MOVEI	T3,PSREQ	;FLAG
	CAIE	PG,%SAT.C	;THAT WE
	MOVEI	T3,PRREQ	;HAVE TAKEN A
	AOSLE	(T3)		;PCB.
	STOPCD
TAGN25:	LDB	T1,PCUSTS	;TRY TO
	LDB	T3,PCYLCC	;START
	MOVEI	T4,(P1)		;US UP.
	PUSHJ	P,CHKST0	;
	JRST	[DPB T1,PCUSTS	;CAN.
		DPB T3,PCYLCC
		POPJ P,]
	JRST	CPOPJ1		;CAN'T.
COMMENT #
@@SUBROUTINE GT2ND
@@PURPOSE
SUBR TO GET CORE FOR AND BUILD A SECONDARY PCB.
@@ENTRY
@ACCUM
@@EXIT
@@ #

    ;FIRST GET THE CORE FOR THE SECONDARY PCB.
GT2ND:	PUSH	P,T1		;SAVE T1 FROM GET4WD.
	MOVEI	T2,1		;REQUEST ONE 4-WORD BLOCK.
	SKIPGE	FCREQ		;ANY WAITERS FOR FREE CORE?
	PUSHJ	P,GET4WD	;NO, TRY TO GET FREE CORE.
	JRST	[POP P,T1	;DIDN'T GET IT OR WAITERS.
		AOS FCREQ	;QUEUE UP
		PUSHJ P,FCWAIT	;FOR FREE CORE.
		SOSL FCREQ	;BACK.
		SETO	P2,	;FLAG TO RESTART WAITERS LATER.
		POPJ P,]
    ;SET UP SECONDARY PCB.
	MOVE	T2,T1		;LOC OF 2NDARY PCB TO T2.
	POP	P,PCBPTR(T2)	;PUT DSK PNTR IN 1ST PCB LOC.
	SETZM	PCBUSC(T2)	;CLR STATUS BECAUSE SETPCB ORS.
	HRRZS	PCBTIM(T2)	;SECONDARIES HAVE NO CLOCK.
	PUSHJ	P,SETPCB	;SET 2ND & 3RD LOCS IN PCB.
	SETZM	PCBPAG(T2)	;0 PAGE # & LINK IN 4TH PCB WRD.
	HRRM	J,PCBLKQ(T2)	;POINT TO US IN THE QUEUE.
	HRLZM	T2,QUEPCB(J)	;
	TRO	P1,STQPCB	;
	DPB	P1,QUYPCS	;
	PUSHJ	P,LINKPB	;LINK INTO THE PCB LIST.
	JRST	CPOPJ1		;
COMMENT #
@@SUBROUTINE MAPRLS/MAPREL
@@PURPOSE
SUBRS TO RELEASE A PCB.  MAPREL DOES THE WORK.  MAPRLS
SETS UP SOME ACS AND CALLS MAPREL.
@@ENTRY
MAPRLS AND MAPREL BOTH EXPECT PG/ADDR OF CONTROL BLOCK.
MAPREL ALSO EXPECTS T4/ JOB'S STATUS AND T2/ PCB ADDRESS.
@@CALLS
PLPGET AND SWPEQ1.
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@ #


MAPRLS:: MOVE	T1,JOB
	LDB	T4,%CTSTS(PG)	;T4/REQUEST STATUS FOR MAPREL
	HRRZ	T2,@%CTUPT(PG)	;T2/ADDR OF PCB.
	JUMPN	T2,.+2		;
	STOPCD
	PUSHJ	P,MAPREL	;

    ;FINISH UP.
MAPRDN:	SETZ	T4,		;CLEAR THE MAP
	DPB	T4,%CTBYP(PG)	;SLOT AND
	SETZM	@%CTUPT(PG)	;UPTXXX.
	CLRPTO	%RIB		;QUICKER JUST TO CLEAR THESE OUT OF
	CLRPTO	%RB2		;PAGE TABLE THAN TO FIGURE OUT WHICH
	CLRPTO	%SAT		; ONE TO DO.
	MOVE	T1,JOB		;
	DPB	T4,%CTADR(PG)	;ZERO THIS TOO
	CAIN	PG,%RB2.C	;IF WE ARE RELEASING RB2,
	PJRST	RELM2		;THEN GIVE BACK THE M2 RESOURCE.
	POPJ	P,		;


;TINY SUBR TO RELEASE THE M2 RESOURCE.
INTERN RELM2
RELM2:	SOSL	M2REQ		;GIVE
	SOS	M2AVAL		;BACK M2Q.
	PUSH	P,J		;
	MOVE	J,JOB		;
	PUSHJ	P,M2HRMV	;REMOVE US FROM M2HAV LIST.
	POP	P,J		;
	POPJ	P,


MAPREL:	SOS	PCBUSC(T2)	;DEC THE USE COUNT.
	LDB	T1,PCUSTS	;T1/PCUSTS.
	LDB	T3,PCYLCC	;T3/ LOCK COUNT.
	CAIGE	T4,STALOK	;LOCKED?
	JRST	MAPRL2		;NO.

    ;HERE WHEN WE ARE LOCKED.
	SOJ	T3,.+1		;DEC THE
	DPB	T3,PCYLCC	;LOCK COUNT.
	TRZE	T1,STWRTL!STCMPL!STSNEW ;IS THE PCB READ LOKED?
	DPB	T1,PCUSTS	;NO, CLR WL OR CL OR NEW BITS.

    ;NEED TO RESTART SOME WAITERS?
MAPRL2:	JUMPN	T3,CPOPJ	;IF LOK CT IS 0 AND LOK Q
	HRRZ	T4,PCBLKQ(T2)	;<>0, THEN RESTART AS MANY
	JUMPE	T4,MAPRL4	;AS WE CAN.
	PUSH	P,J		;SAVE J.
	MOVEI	J,(T4)		;J/ 1ST JOB NO. TO LOOK AT.
	PUSHJ	P,STUPLQ	;RESTART SOME WAITERS.
	POP	P,J		;RESTORE J.
MAPRL4:	HRRZ	T4,PCBUSC(T2)	;HAS THE USE COUNT GONE
	JUMPN	T4,CPOPJ	;TO 0?

    ;HERE ON THE USE COUNT=0.
	CAIE	PG,%SAT.C	;TAKE
	JRST	MAPRL5		;A
	SOSL	PSREQ		;JOB OUT
	SOS	PSAVAL		;OF
	JRST	.+3		;PS OR
MAPRL5:	SOSL	PRREQ		;PR
	SOS	PRAVAL		;WAIT.
	DSKOFF
	LDB	T1,PCISTS	;
	TRNE	T1,STDPRE	;IS DATA PRESENT?
	JRST	MAPRL6		;YES.
	TRNE	T1,STDREA	;READ IN PROGRESS (MAYBE SWAPPER REQ)?
	JRST	.+3		;YES, FINPCB WILL ADJUST COUNT.
	SOSL	@%CTWRQ(PG)	;
	SOS	@%CTWVL(PG)	;
	PUSHJ	P,RESLRU	;NO. PUT US BACK ON LIST AS LRU.
	DSKON			;
	POPJ	P,		;

    ;HERE ON DATA PRESENT.
MAPRL6:	PUSHJ	P,RESMRU	;PUT US BACK ON THE LIST AS MRU.
	PUSH	P,PG		;SAVE PG.
	HLRZ	PG,PCBPAG(T2)	;HAS THE
	LDB	T4,PGYDRT	;DATA BEEN
	JUMPE	T4,[POP P,PG	;MODIFIED?
		LDB	T1,PCISTS
		TRNE T1,STDWRT!STDWAG!STDREA
		JRST [DSKON
		     POPJ P,]
		SOSL @%CTWRQ(PG)
		SOS @%CTWVL(PG)
		DSKON
		POPJ P,]
	MOVE	T1,(P)		;YES.
	CAIE	T1,%SAT.C	;
	JRST	MAPRL7		;
	DSKON
	POP	P,PG		;DON'T WRITE IF A SAT PCB.
	MOVEI	T1,3		;
	MOVEM	T1,SATWRT	;
	POPJ	P,		;
     ;THIS IS AN ENTRY POINT.
MAPRL7:	DSKOFF			;YES.
	LDB	T1,PCISTS	;
	SETZ	T4,		;CLEAR DATA MODIFIED SINCE WE
	DPB	T4,PGYDRT	;ARE ABOUT TO WRITE IT OUT.
	TRON	T1,STDWRT	;IS DATA WRITE ALSO SET?
	JRST	MAPRL8		;NO.
	TRO	T1,STDWAG	;YES, SO SET DATA WRITE AGAIN.
	DPB	T1,PCISTS
	DSKON
	POP	P,PG		;RESTORE PG.
	POPJ	P,		;

    ;HERE TO REQUEST WRITE OUT.
MAPRL8:	DPB	T1,PCISTS	;
	DSKON
	PUSH	P,T2		;T2.
	MOVE	T4,PCBPTR(T2)	;
	DPB	T4,PGYADR	;
	PUSHJ	P,PAGOUT	;START THE PAGE OUT.
	POP	P,T2		;RESTORE T2.
	POP	P,PG		;
	POPJ	P,
COMMENT #
@@SUBROUTINE RELSAT/DMPSAT
@@PURPOSE
THESE ROUTINES JUST RELEASE THE SAT IF WE HAVE ONE TO
RELEASE.  DMPSAT SAVES ALL ACS.
@@ACCUM
RELSAT DESTROYS T1 THRU T4 AND PG.
DMPSAT DESTROYS NO ACS.
@@CALLS
MAPRLS.
@@ #

INTERN RELSAT

RELSAT:	MOVEI	PG,%SAT.C	;
	SKIPE	@%SAT.C+%CTUPT	;
	PJRST	MAPRLS		;
	POPJ	P,		;


DMPSAT:	SKIPN	@%SAT.C+%CTUPT	;
	POPJ	P,		;
	PUSH	P,T1		;
	PUSH	P,T2		;
	PUSH	P,T3		;
	PUSH	P,T4		;
	PUSH	P,PG		;
	MOVEI	PG,%SAT.C	;
	PUSHJ	P,MAPRLS	;
	POP	P,PG		;
	POP	P,T4		;
	POP	P,T3		;
	POP	P,T2		;
	POP	P,T1		;
	POPJ	P,




COMMENT #
@@SUBROUTINE RELRIB
@@PURPOSE
THIS ROUTINE JUST RELEASES THE RIB IN %RIB IF WE HAVE ONE TO
RELEASE.
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@CALLS
MAPRLS.
@@ #

INTERN RELRIB

RELRIB:	MOVEI	PG,%RIB.C	;
	SKIPE	@%RIB.C+%CTUPT	;
	PJRST	MAPRLS		;
	POPJ	P,		;



COMMENT #
@@SUBROUTINE RELRB2
@@PURPOSE
THIS ROUTINE JUST RELEASES THE RIB IN %RB2 IF WE HAVE ONE TO
RELEASE.
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@CALLS
MAPRLS.
@@ #

INTERN RELRB2

RELRB2:	MOVEI	PG,%RB2.C	;
	SKIPE	@%RB2.C+%CTUPT	;
	PJRST	MAPRLS		;
	POPJ	P,







INTERN STRIOS

STRIOS:	MOVEM	S,DEVIOS(F)	;STORE S IN DDB (STOIOS CHANGES T1)
	POPJ	P,		;AND RETURN
COMMENT #
@@SUBROUTINE PAGOUT/PAGIN/PAGIMD
@@PURPOSE
SUBR TO WRITE A PAGE OUT TO OR READ A PAGE IN FROM THE DISK.
@@ENTRY
EXPECTS PG/ LOGICAL PAGE NO. AND T2/ PCB ADDRESS.
PAGOUT AND PAGIN ALSO EXPECT F/ DDB ADDR.
EXPECTS PGYADR TO BE SET UP ALREADY.
ENTRY POINTS ARE PAGOUT (WRITE A PAGE), PAGIN (READ A PAGE), AND
PAGIMD(START A READ OR WRITE WITH SOME STUFF ALREADY SET UP).
@@ACCUM
DESTROYS T1-T4.
@@EXIT
@@ #

INTERN PAGOUT,PAGIN

PAGIN:	TDZA	T4,T4		;COMING IN.
PAGOUT:	MOVEI	T4,1		;GOING OUT.
	DPB	T4,PGYSOP	;MARK
	TRC	T4,1		;THE
	DPB	T4,PGYSIP	;DIRECTION.
	;PJRST	PAGIMD		;FALL THRU TO DO THE WORK

PAGIMD:	PUSH	P,P1		;SAVE
	PUSH	P,U		;
	PUSH	P,P2		;THESE
	PUSH	P,P3		;FROM
	PUSH	P,P4		;THE
	PUSH	P,PG		;CLUTCHES
	PUSH	P,F		;OF
	PUSH	P,J		;SWPENQ.
	CAMG	PG,MAXPCB	;CHECK FOR PAGE NUMBER
	CAMGE	PG,MINPCB	;IN CORRECT RANGE.
	STOPCD
	DPB	T2,PGYLMA	;SAVE REAL PCB ADDR FOR FINPCB
	PUSH	P,S		;
	PUSHJ	P,SWPENQ	;
	POP	P,S		;
	POP	P,J		;
	POP	P,F		;
	POP	P,PG		;
	POP	P,P4		;
	POP	P,P3		;
	POP	P,P2		;
	POP	P,U		;
	POP	P,P1		;
	POPJ	P,
COMMENT #
@@SUBROUTINE PPCBIO
@@PURPOSE
SUBR TO SET UP ARGS FOR PAGIMD AND CALL IT TO READ OR WRITE
A PCB.
@@ENTRY
EXPECTS T2/ PCB ADR AND T4/ 0 IF READ OR 1 IF WRITE..
@@ACCUM
DESTROYS T1, AND T3-T4.
@@ #

INTERN PPCBIO

PPCBIO:	PUSH	P,PG		;PG, AND
	PUSH	P,T2		;T2.
	HLRZ	PG,PCBPAG(T2)	;SET UP PG/ CORE PAGE NUMBER.
	DPB	T4,PGYSOP	;SET DIRECTION.
	TRC	T4,1		;
	DPB	T4,PGYSIP	;
	JUMPE	T4,PCBIO4	;DON'T RESET PGYADR IF WAG.
	MOVE	T4,PCBPTR(T2)	;SET
	DPB	T4,PGYADR	;PGYADR.
PCBIO4:	PUSHJ	P,PAGIMD	;REQUEST THE TRANSFER.
	POP	P,T2		;RESTORE T2,
	POP	P,PG		;PG, AND
	POPJ	P,
COMMENT #
@@SUBROUTINE FINPCB
@@PURPOSE
SUBR TO CLEAN UP AFTER THE IO TRANSFER OF A PCB.
@@ENTRY
EXPECTS PG/ CORE PAGE NUMBER.
@@ACCUM
DESTROYS T1-T4.
@@FUNCTION NOTE THAT IN SOME CASES A PCB WHICH HAS BEEN RELEASED
BUT WHOSE PCBPTR IS STILL SETUP AND HAD A WRITE OUT IN PROGRESS
CAN HAVE HAD A NEW ADDRESS STUCK INTO PCBPTR AND HAVE STDREA
OR STDWAG SET ON IT FOR THE NEW DATA. THIS IS WHY THE CHECK IS
MADE FOR STDREA OR STDWAG AFTER A WRITE COMPLETES.
@@ #


FINPCB:: CAMG	PG,MAXPCB	;JUST IN
	CAMGE	PG,MINPCB	;CASE, CHECK THE PAGE NUMBER.
	STOPCD
	LDB	T2,PGYLMA	;T2/PCB ADDR
	LDB	T1,PGYUNI	;
	MOVE	T1,UNTTBL(T1)	;
	LDB	T3,PCISTS	;T3/ STATUS.
	TRNE	T3,STDWRT	;DATA WRITE?
	JRST	FNPCWT		;YES.

    ;HERE ON COMPLETION OF A PCB READ.
	AOS	UNIMRC(T1)	;UPDATE STATISTICS.
	TRZN	T3,STDREA	;IF NOT DW, MUST BE DATA READ.
	STOPCD
	TRO	T3,STDPRE	;SET DATA PRESENT.
	DPB	T3,PCISTS	;
	PUSHJ	P,RSTWAI	;RESTART WAITERS.
	JUMPE	T4,CPOPJ	;JUMP OVER THIS IF ONCE-TIME.
	PUSH	P,PG		;IF THIS IS A SAT PCB,
	PUSHJ	P,CTLFND	;SET STYINC.  FIRST FIND PG.
	CAIE	PG,%SAT.C	;PG=%SAT.C?
	JRST	FNPCOT		;NO, NOT A SAT PCB.
;	PUSH	P,T2		;SAVE PCB ADDRESS.*****PART 1 OF 2.
	PUSH	P,U		;YES.  FIND THE ADDRESS OF
	MOVE	T2,PCBPTR(T2)	;
	PUSHJ	P,GSATST	;THE STT TABLE ENTRY.
	POP	P,U		;THEN SET
	MOVEI	T3,1		;1 IN
	DPB	T3,STYINC	;STYINC FOR IT.
;	POP	P,T2		;RESTORE T2/ PCB ADDRESS.****PART 2 OF 2.
	JRST	FNPCRU		;FIX UP COUNT IF SWAPPER REQ.

    ;HERE ON COMPLETION OF A PCB WRITE.
      ;EITHER WE HAVE TO WRITE IT AGAIN, OR READ IT, OR WE
      ;ARE DONE.
FNPCWT:	AOS	UNIMWC(T1)	;UPDATE STATISTICS.
	HLRZ	T4,PCBTIM(T2)	;INCREMENT THE CLOCK,
	HRRZI	T4,1(T4)	;AUTOMATICALLY TURNING
	HRLM	T4,PCBTIM(T2)	;OVERFLOW AROUND.
	TRZN	T3,STDWAG	;DATA WRITE AGAIN SET?
	JRST	FNPCW4		;NO.
      ;HERE ON HAVE TO RE-WRITE IT.
	DPB	T3,PCISTS	;YES, STORE THE STATUS.
	MOVEI	T4,1		;FLAG GOING OUT.
	PUSHJ	P,PPCBIO		;REQ TRANSFER (EXPECTS T2&T4).
	POPJ	P,
      ;HERE ON HAVE TO READ IT, OR DONE.
FNPCW4:	TRZ	T3,STDWRT	;CLEAR DATA WRITE.
	TRZE	T3,STDDRF	;CLEAR DIRTY MONITOR FLAG, AND IF IT WAS ON,
	SOS	PCDCNT		;DECREMENT THE COUNT.
	DPB	T3,PCISTS	;STORE THE STATUS.
	TRNE	T3,STDREA	;IS DATA READ SET?
	JRST	[SETZ	T4,
		PJRST PPCBIO]	;REQUEST THE TRANSFER.
	PUSHJ	P,RSTWAI 	;TAKE WAITERS OUT OF Q.
	JUMPE	T4,CPOPJ	;JUMP IF ONCE TIME.
	PUSH	P,PG		;SAVE PG.
	PUSHJ	P,CTLFND	;SET UP PG/ CNTL BLK ADDR.
FNPCRU:	MOVE	T1,%CTLRU(PG)	;IS THIS
	SKIPN	(T1)		;PCB ON
	JRST	FNPCOT		;THE LRU
	CAME	T2,(T1)		;MRU
	AOJA	T1,.-3		;LIST?
	CAIE	PG,%SAT.C	;YES, IS IT A SAT?
	JRST	FNPC45		;NO.
	MOVE	PG,(P)		;YES, IS IT
	LDB	T1,PGYDRT	;DIRTY?
	JUMPN	T1,FNPCOT	;JUMP ON YES (WILL NEED WRITING).
	MOVEI	PG,%SAT.C	;
FNPC45:	SOSL	@%CTWRQ(PG)	;YES, MARK IT
	SOS	@%CTWVL(PG)	;AS A RESOURCE NOW.
FNPCOT:	POP	P,PG		;RESTORE PG.
	POPJ	P,		;RETURN.




      ;LITTLE SUBR TO RESTART WAITERS.
      ;EXITS WITH T4<>0 IF THIS IS NOT ONCE-TIME.
RSTWAI:	SKIPN	T4,ONCTIM	;ONCE TIME?
	POPJ	P,		;YES, NOTHING ELSE TO DO.
	PUSH	P,T2		;SAVE T2.
	PUSH	P,J		;SAVE J FROM PAGWAK.
	SETZ	T2,		;
	DPB	T2,PGYSIO	;
	PUSHJ	P,PAGWAK	;WAKE ALL WAITERS FOR THIS PAGE.
	POP	P,J		;RESTORE J.
	POP	P,T2		;RESTORE T2.
	MOVE	T4,ONCTIM	;RETURN T4/ SYSTEM TIME.
	POPJ	P,

INTERN ONCTIM
ONCTIM:	Z			;FLAG FOR FINPCB, ITS ONCE TIME.
COMMENT #
@@SUBROUTINE WATPCB
@@PURPOSE
SUBR CALLED AT OUTPUT CLOSE, TO WAIT FOR ALL THE RIB PCBS WITH
WRITE IN PROGRESS TO FINISH UP, SO WE CAN BE SURE ALL THE RIBS,
ETC., HAVE BEEN WRITTEN.
@@ENTRY
EXPECTS F/ DDB.
@@ACCUM
DESTROYS T1-T4, AND PG.
@@#

INTERN WATPCB

    ;HERE TO FIND THE PCBS TO WAIT FOR.
WATPCB:	SETZ	T4,		;T4/ COUNT OF PCBS TO WAIT FOR.
	MOVEI	PG,%RIB.C	;GET T2/ ADDR OF
	PUSHJ	P,FNDPRM	;1ST PRIMARY PCB.
	DSKOFF
WATPC2:	LDB	T1,PCISTS	;IS THIS PCB IN THE
	TRNN	T1,STDWRT!STDWAG ;PROCESS OF WRITING OUT?
	JRST	WATPC4		;NO, IGNORE IT.
	HLRZ	T3,PCBTIM(T2)	;YES, GET ITS CLOCK, AND
	TRNN	T1,STDWAG	;ADJUST IT FOR THE NUMBER OF
	AOJA	T3,.+2		;WRITES WE HAVE TO WAIT FOR
	ADDI	T3,2		;TO BE SURE OUR DATA IS OUT
	HRRZI	T3,(T3)		;ON THE DISK.
	PUSH	P,T3		;SAVE CLOCK.
	PUSH	P,T2		;SAVE PCB ADDR.  COUNT THIS
	AOJA	T4,.+1		;PCB AND LOOK FOR MORE.
WATPC4:	HRRZ	T2,PCBLNK(T2)	;GET NEXT PCB.
	JUMPN	T2,WATPC2	;JUMP IF ANOTHER.
	JUMPE	T4,WATOUT	;DONE IF NONE OF INTEREST SEEN.

    ;HERE TO WAIT FOR THE PCBS.
WATPC5:	DSKON
	PUSH	P,T4		;SAVE COUNT.
	MOVE	T2,-1(P)	;T2/ PCB ON TOP OF THE STACK.
	PUSH	P,PG		;SAVE PG AND
	PUSH	P,J		;J FROM PAGWAT.
	HLRZ	PG,PCBPAG(T2)	;ARGS FOR
	MOVE	J,JOB		;PAGWAT.
	PUSHJ	P,PAGWAT	;WAIT FOR PCB ON TOP OF STACK.
	POP	P,J		;RESTORE PG
	POP	P,PG		;AND J.

    ;HERE TO SEE IF ANY PCBS LEFT TO WAIT FOR.
	POP	P,T4		;RESTORE COUNT OF PCBS.
	DSKOFF
WATPC6:	POP	P,T1		;FORGET THIS
	POP	P,T1		;PCB.
	SOJG	T4,WATPC7	;ANY PCBS LEFT TO WORRY ABOUT?
WATOUT:	DSKON
	POPJ	P,		;NO, DONE.
WATPC7:	MOVE	T2,(P)		;GET T2/ A PCB ADDR.
	HLRZ	T1,PCBTIM(T2)	;GET
	SUB	T1,-1(P)	;DIFFERENCE.
	MOVM	T3,T1		;IF > "POSSIBLE", THEN ONE OF US
	CAIG	T3,400000	;AT LEAST WENT AROUND TOP.
	MOVNS	T1		;NO.
	JUMPG	T1,WATPC5	;YES, JUMP ON PCB STILL BEHIND.
	JRST	WATPC6		;JUMP ON THIS PCB DONE.




COMMENT #
@@SUBROUTINE FNDPRM
@@PURPOSE
SUBR TO FIND THE ADDRESS OF THE FIRST PRIMARY PCB.
@@ENTRY
EXPECTS PG/ CONTROL BLOCK ADDRESS.
@@ACCUM
DESTROYS T1 AND T2.
@@EXIT
RETURNS PCB ADDR IN T2.
@@ #

FNDPRM:	HRRZ	T2,%CTLST(PG)	;
	HLRZ	T1,PCBPAG(T2)	;
	JUMPN	T1,CPOPJ	;
	HRRZ	T2,PCBLNK(T2)	;
	JUMPN	T2,.-3		;
	STOPCD
COMMENT #
@@SUBROUTINE GETLRU/GETLRS
@@PURPOSE
SUBROUTINE TO GET THE LRU FREE PRIMARY PCB WITH NO IO IN PROGRESS.
@@ENTRY
EXPECTS PG/ CONTROL BLOCK ADDR.
@@EXIT
IF NONE WITH NO IO IN PROGRESS, RETURNS.
IF SUCCESSFUL, SKIP RETURNS WITH T2/LRU AND CLEARS DATA PRESENT.
GETLRU ALSO REMOVES THE PCB FROM THE LIST OF FREE PRIMARY PCBS
ACCCORDING TO USE.
@@ACCUM
DESTROYS T2 AND T3.
@@ #

INTERN GETLRS
GETLRS:	PUSH	P,U		;SAVE U.
	SETZ	U,		;FLAG THIS IS SWAPPER ASKING.
	JRST	.+3
GETLRU:	PUSH	P,U		;SAVE U.
	SETO	U,		;FLAG THIS IS NORMAL.
	SKIPN	T2,@%CTLRU(PG)	;BETTER BE A FREE PCB.
	STOPCD
	PUSH	P,T4		;SAVE T4.
	MOVE	T3,%CTLRU(PG)	;T3/ ADDRESS INTO LIST.
GETLR1:	SKIPN	T2,(T3)		;T2/ NEXT LRU PCB.
	STOPCD
	LDB	T4,PCISTS	;IS IO IN PROGRESS FOR THIS
	TRNN	T4,STDWRT!STDWAG!STDREA ;PCB?
	JRST	GETLR2		;NO, MAYBE OKAY.
GETL15:	ADDI	T3,1		;YES, TRY NEXT.
	CAMGE	T3,%CTMRU(PG)	;OUT OF LIST?
	JRST	GETLR1		;NO, CONTINUE.
	POP	P,T4
	POP	P,U		;
	POPJ	P,

GETLR2:	CAIE	PG,%SAT.C	;IF THIS IS A SAT,
	JRST	GETLR7		;IT MAY NEED
	HLRZ	PG,PCBPAG(T2)	;WRITING
	LDB	T4,PGYDRT	;OUT.
	JUMPE	T4,GETLR6	;
	PUSH	P,T3		;
	PUSH	P,T1		;
	PUSH	P,[GETLR5]	;RETURN ADDRESS.
	PUSH	P,[%SAT.C]	;
	JRST	MAPRL7		;
GETLR5:	POP	P,T1		;
	POP	P,T3		;
	JRST	GETL15		;

    ;HERE WITH A GOOD PCB.
GETLR6:	MOVEI	PG,%SAT.C	;
GETLR7:	PUSH	P,T3		;SAVE LOC IN LRU LIST.
	CAIN	PG,%SAT.C	;
	PUSHJ	P,CLRYNC	;CLEAR STYINC.
	AOSG	@%CTWRQ(PG)	;
	JRST	GETLR9		;
	SKIPE	@%CTWVL(PG)	;
	AOS	@%CTWVL(PG)	;
GETLR9:	DSKOFF
	LDB	T3,PCISTS	;CLEAR
	TRZ	T3,STDPRE	;DATA
	DPB	T3,PCISTS	;PRESENT.
	EXCH	T1,(P)		;GET THIS PCB OFF THE
	JUMPE	U,.+2		;
	PUSHJ	P,GETTR2	;LRU LIST  AND
	POP	P,T1		;ADJUST %CTMRU.
	POP	P,T4		;RESTORE T4.
	POP	P,U		;
	JRST	CPOPJ1



COMMENT #
@@SUBROUTINE GETTRU
@@PURPOSE
SUBROUTINE TO REMOVE A SPECIFIC PCB FROM THE LRU/MRU LIST.
@@ENTRY
EXPECTS T2/ PCB ADDRESS AND PG/ CONTROL BLOCK ADDRESS.
@@ACCUM
DESTROYS T1, T3, AND T4.
@@ #

GETTRU:	DSKOFF
	LDB	T1,PCISTS	;
	TRNE	T1,STDWRT!STDWAG!STDREA
	JRST	GETTR1		;
	CAIE	PG,%SAT.C	;
	JRST	GETTR0		;
	HLRZ	PG,PCBPAG(T2)	;
	LDB	T1,PGYDRT	;
	MOVEI	PG,%SAT.C	;
	JUMPN	T1,GETTR1	;
GETTR0:	AOSG	@%CTWRQ(PG)	;
	JRST	GETTR1		;
	SKIPE	@%CTWVL(PG)	;
	AOS	@%CTWVL(PG)	;
GETTR1:	MOVE	T1,%CTLRU(PG)	;GET T1/ ADDR OF TOP OF LIST.
	SKIPN	(T1)		;FAIL IF EO LIST.
	STOPCD
	CAME	T2,(T1)		;FOUND IT?
	AOJA	T1,.-3		;NO, CONTINUE.
GETTR2:	MOVE	T3,1(T1)	;YES,  MOVE UP THE REST
	MOVEM	T3,(T1)		;OF THE
	SKIPE	1(T1)		;
	AOJA	T1,GETTR2	;LIST.
	SOS	%CTMRU(PG)	;DECREMENT
	CAIN	PG,%RIB.C	;%CTMRU.
	SOS	%CTMRU+%RB2.C	;
	CAIN	PG,%RB2.C	;
	SOS	%CTMRU+%RIB.C	;
	DSKON
	POPJ	P,

    ;LITTLE SUBR CALLED BY GETLRU TO CLEAR STYINC.
CLRYNC:	PUSH	P,T2		;SAVE T2.
	SKIPN	T2,PCBPTR(T2)	;CLR STYINC ONLY IF WAS IS CORE.
	JRST	CLROUT		;WASN'T.
	PUSH	P,T1		;SAVE T1 FROM GSATST.
	PUSH	P,U		;
	PUSHJ	P,GSATST	;GET T2/ STT ENTRY ADDRESS.
	POP	P,U		;
	POP	P,T1		;RESTORE T1.
	HRLZI	T3,STPINC!STPCHK ;CLEAR STPINC AND
	ANDCAM	T3,STTSTS(T2)	;STPCHK.
CLROUT:	POP	P,T2		;RESTORE T2.
	POPJ	P,		;
COMMENT #
@@SUBROUTINE RESLRU
@@PURPOSE
SUBROUTINE TO PUT A PCB ON THE LIST AS THE LRU PCB.
@@ENTRY
EXPECTS PG/ CONTROL BLOCK ADDR AND T2/ PCB ADDRESS.
@@ACCUM
DESTROYS NO ACS.
@@ #

RESLRU:	PUSH	P,T1		;SAVE T1
	PUSH	P,T3		;AND T3
	PUSH	P,T4		;AND T4.
	MOVE	T3,%CTMRU(PG)	;T3/ ADDR OF END OF LIST.
	MOVEI	T1,(T3)		;T1/ NO. OF ITEMS-1
	SUB	T1,%CTLRU(PG)	;ON THE LIST.
RESLR2:	MOVE	T4,(T3)		;MOVE FROM X
	MOVEM	T4,1(T3)	;TO X+1.
	SOJ	T3,.+1		;BACK UP POINTER.
	SOJGE	T1,RESLR2	;DONE?
	MOVEM	T2,1(T3)	;STORE LRU PCB.
	POP	P,T4		;YES, RESTORE
	POP	P,T3		;T4 AND T3
	POP	P,T1		;AND T1.
INCMRU:	AOS	%CTMRU(PG)	;
	CAIN	PG,%RIB.C	;
	AOS	%CTMRU+%RB2.C	;
	CAIN	PG,%RB2.C	;
	AOS	%CTMRU+%RIB.C	;
	POPJ	P,
	


COMMENT #
@@SUBROUTINE RESMRU
@@PURPOSE
SUBROUTINE TO PUT A PCB ON THE LIST AS THE MRU PCB.
@@ENTRY
EXPECTS PG/ CONTROL BLOCK ADDRESS AND T2/ PCB ADDRESS.
@@ACCUM
DESTROYS NO ACS.
@@ #

RESMRU:	MOVEM	T2,@%CTMRU(PG)	;STORE THRU THE POINTER.
	PJRST	INCMRU		;
COMMENT #
@@SUBROUTINE SETPCB
@@PURPOSE
SUBROUTINE TO SET UP THE 2ND AND 3RD LOCS IN A PCB SPECIFIED BY
T2, USING THE STATUS SAVED IN P1.
N.B., ORS THE STATUS INTO THE PCB.
@@ENTRY
SEE PURPOSE.
@@ACCUM
DESTROYS T1 AND T3.
@@ #

SETPCB:	HLLZS	PCBLKQ(T2)	;LOCK QUEUE = 0.
	MOVEI	T1,1		;ONE
	HRRM	T1,PCBUSC(T2)	;USER.
	CAIGE	P1,STALOK	;LOCKED?
	TDZA	T1,T1		;NO, LOCK COUNT=0.
	MOVEI	T1,1		;YES, LOCK COUNT=1.
	DPB	T1,PCYLCC	;SET LOCK COUNT TO 0 OR 1.
	LDB	T3,PCUSTS	;SET PCUSTS TO
	IOR	T3,CODBTS(P1)	;INCLUDE OUR
	DPB	T3,PCUSTS	;BITS.
	POPJ	P,
COMMENT #
@@SUBROUTINE UNLNK2
@@PURPOSE
SUBROUTINE TO REMOVE A SECONDARY PCB FROM THE LIST OF
PCBS.
@@ENTRY
EXPECTS T1/ADDR OF 2NDARY PCB AND PG/CONTROL BLOCK ADDR.
@@ #

UNLNK2:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;AND T3.
	SETZ	T3,		;T3 HAS PREVIOUS PCB TO OURS.
	HRRZ	T2,%CTLST(PG)	;GET 1ST PCB IN LIST.
UNLNK3:	CAIN	T2,(T1)		;OURS?
	JRST	UNLNK5		;YES.
	MOVEI	T3,(T2)		;NO.
	HRRZ	T2,PCBLNK(T2)	;GET NEXT.
	JUMPN	T2,UNLNK3	;CONTINUE.
	STOPCD
UNLNK5:	HRRZ	T2,PCBLNK(T2)	;GET NEXT PCB IN LIST.
	JUMPN	T3,.+3		;JUMP IF IN MIDDLE OF LIST.
	HRRM	T2,%CTLST(PG)	;OURS WAS FIRST IN LIST.
	JRST	.+2		;GO RETURN.
	HRRM	T2,PCBLNK(T3)	;OURS WAS IN MIDDLE OF LIST.
	POP	P,T3		;RESTORE T3
	POP	P,T2		;AND T2.
	POPJ	P,


COMMENT #
@@SUBROUTINE LINKPB
@@PURPOSE
SUBROUTINE TO LINK A SECONDARY PCB INTO THE LIST OF PCBS.
@@ENTRY;
EXPECTS T2/ADDR OF THE 2NDARY PCB AND PG/ADDR OF CONTROL BLK.
@@ACCUM
DESTROYS T1.
@@ #

LINKPB:	HRRZ	T1,%CTLST(PG)	;T1/ ADDR OF 1ST PCB IN LIST.
	HRRM	T1,PCBLNK(T2)	;POINT US TO IT.
	HRRM	T2,%CTLST(PG)	;POINT THE LIST HEADER TO US.
	POPJ	P,
COMMENT #
@@SUBROUTINE ENLOKQ
@@PURPOSE
SUBR TO ADD A JOB(S) AT THE END OF THE LOCK QUEUE FOR THE PCB
SPECIFIED BY T2.
@@ENTRY
EXPECTS J/ NO. AND P1/ STATUS OF THE JOB TO ADD.
@@ACCUM
DESTROYS T3 AND T4. @@#

ENLOKQ:	HRRZ	T4,PCBLKQ(T2)	;ANY JOB IN THE
	JUMPN	T4,ENLOK2	;LOCK QUEUE YET?
	HRRM	J,PCBLKQ(T2)	;NO, EASY TO
	HRLM	T2,QUEPCB(J)	;ADD US.
	ORI	P1,STQPCB	;
	DPB	P1,QUYPCS	;
	POPJ	P,
ENLOK2:	EXCH	T4,J		;YES, SEARCH AHEAD
	LDB	T3,QUYPCN	;AND
	JUMPE	T3,.+3		;FIND
	HRRZ	J,T3		;THE
	JRST	.-3		;LAST JOB IN THE QUEUE.
	DPB	T4,QUYPCN	;POINT IT TO US.
	EXCH	J,T4		;POINT US TO
	LDB	T3,QUYPCN	;
	SETZM	QUEPCB(J)	;
	DPB	T4,QUYPCP	;
	DPB	P1,QUYPCS	;
	DPB	T3,QUYPCN	;
	POPJ	P,
COMMENT #
@@SUBROUTINE UNLOKQ
@@PURPOSE
SUBR TO REMOVE A JOB FROM A PCB LOCK QUEUE.
@@ENTRY
EXPECTS J/ JOB NO.
@@ACCUM
DESTROYS T4.  SETS T2 TO PCB ADDRESS.
@@ #

UNLOKQ:	PUSH	P,T1		;SAVE T1.
	LDB	T1,QUYPCN	;T1/ NO. OF NEXT JOB.
	LDB	T4,QUYPCS	;T4/ OUR REQ STATUS.
	JUMPN	T1,UNLOK2	;

    ;HERE ON NO NEXT JOB.
	TRNN	T4,STQPCB	;IS OUR PREV THE PCB?
	JRST	UNLOK1		;NO.
	HLRZ	T2,QUEPCB(J)	;
	HLLZS	PCBLKQ(T2)	;YES--JUST SET THE LOK Q TO 0.
	JRST	UNLKO2		;
UNLOK1:	LDB	T4,QUYPCP	;T4/ NO. OF PREV JOB.
	EXCH	J,T4		;POINT PREV
	DPB	T1,QUYPCN	;TO
	MOVE	J,T4		;NEXT.
UNLKO2:	POP	P,T1		;
	POPJ	P,

    ;HERE ON A NEXT JOB EXISTS.
UNLOK2:	TRNN	T4,STQPCB	;PREV "JOB" IS PCB?
	JRST	UNLOK4		;NO.
	HLRZ	T2,QUEPCB(J)	;
	HRRM	T1,PCBLKQ(T2)	;YES. POINT PCB TO NEXT JOB.
	EXCH	J,T1		;POINT
	HRLM	T2,QUEPCB(J)	;NEXT JOB
	LDB	T4,QUYPCS	;BACK
	TRO	T4,STQPCB	;TO
	DPB	T4,QUYPCS	;THE
	MOVE	J,T1		;PCB.
	JRST	UNLKO2		;
UNLOK4:	LDB	T4,QUYPCP	;T4/ NO. OF PREV JOB.
	PUSH	P,J		;POINT NEXT
	MOVE	J,T1		;BACK TO
	DPB	T4,QUYPCP	;PREVIOUS, AND
	MOVE	J,T4		;PREVIOUS AHEAD
	DPB	T1,QUYPCN	;TO
	POP	P,J		;NEXT.
	JRST	UNLKO2		;
COMMENT #
@@SUBROUTINE CHKSTS/CHKST0
@@PURPOSE
SUBR CALLED BY THE PCB ROUTINES TO CHECK THE STATUS OF THE
REQUEST AGAINST THE STATUS OF THE PCB.  IF OKAY TO START THE
REQUEST, POSSIBLY THE LOCK COUNT IN T3 IS INCED, THE USE
COUNT IS INCED, AND THE PCB STATUS IN T1 IS UPDATED.
@@ENTRY
EXPECTS T1/PCUSTS, T2/PCB ADDRESS, T3/PCBLCC, AND T4/REQ
STATUS.
ENTRY POINT CHKSTS EXPECTS A LOCK REQUEST AND THE PCB TO NOT
BE CMPL.  ENTRY POINT CHKST0 DOES NOT HAVE THESE RESTRICTIONS.
@@ACCUM
DESTROYS T4.
@@EXIT
RETURNS CPOPJ1 IF CANNOT START REQUEST, ELSE CPOPJ.
@@ #

CHKST0:	TRNE	T1,STCMPL	;NO SENSE TRYING IF PCB IS
	JRST	CPOPJ1		;ALREADY COMPLETELY LOCKED.
	CAIGE	T4,STALOK	;REQ TO LOCK?
	JRST	CHKNSK		;NO.

CHKSTS:	CAIE	T4,STARDL 	;YES, TO READ LOCKED?
	JRST	CHKST4		;NO.
	TRNE	T1,STWRTL	;YES,  CAN WE?
	JRST	CPOPJ1		;NO.
	AOJA	T3,CHKNSK	;YES, INC LOCK COUNT.
CHKST4:	CAIE	T4,STAWTL	;WRITE LOCKED
	CAIN	T4,STAWLN	;OR
	JRST	.+2		;WRITE LOCK NEW?
	JRST	CHKST5		;NO, MUST BE CML LOK.
	JUMPN	T3,CPOPJ1	;CAN'T W LOCK UNLESS LOC CT=0.
	TRO	T1,STWRTL	;CAN, MARK IT.
	AOJA	T3,CHKNSK	;INC LOCK COUNT.
CHKST5:	HRRZ	T4,PCBUSC(T2)	;CML LOCKED.  USE COUNT=
	JUMPN	T4,CPOPJ1	;0?  IF NOT, CAN'T CM LOCK.
	TRO	T1,STCMPL	;CAN, MARK IT.
	AOJ	T3,.+1		;INC THE LOCK COUNT.
CHKNSK:	AOS	PCBUSC(T2)	;INC THE USE COUNT.
	POPJ	P,
COMMENT #
@@SUBROUTINE STUPLQ
@@PURPOSE
STARTS UP SOME JOBS WAITING IN THE LOCK QUEUE.
CANNOT START ANY JOB WHICH WOULD PREVENT A NON-STARTED JOB
AHEAD OF IT FROM RUNNING IF IT WANTED TO.
@@ENTRY
EXPECTS T1/PCUSTS, T2/PCB ADDRESS, T3/PCBLCC, AND J/NO. OF
FIRST JOB TO LOOK AT.
@@ACCUM
DESTROYS T4 AND J.
@@CALLS
CHKSTS, SETRUN, AND UNLOKQ.
@@ #

STUPLQ:	TRNE	T1,STCMPL	;NOTHING TO DO IF THE PCB IS
	POPJ	P,		;COMPLETELY LOCKED.
	PUSH	P,P2		;SAVE P2.  WILL BE FLAG THAT WE
	SETZ	P2,		;HAVEN'T SEEN JOB WE
	JRST	STUPL3		;CAN'T START.
STUPL2:	LDB	J,QUYPCN	;CONTINUE IF THERE IS ANOTHER
	JUMPE	J,STUPND	;JOB IN THE PCB'S LOK QUEUE.
STUPL3:	LDB	T4,QUYPCS	;T4/ REQ STATUS.
	TRZ	T4,STQPCB	;
	CAIGE	T4,STALOK	;REQ LOCKED?
	JRST	STUPL6		;NO.
	JUMPE	P2,STUPL4	;REQ IS LOKED, CAN'T START IT IF
	CAIN	P1,STACML	;ALREADY SEEN JOB WE CAN'T
	JRST	STUPND		;START.  GIVE UP IF
	JRST	STUPL2		;REQ IS CML SINCE NONE AFTER IT CAN START.
STUPL4:	PUSHJ	P,CHKSTS	;CAN START THIS REQ?
	JRST	STUPL7		;YES.
	HRRM	J,PCBLKQ(T2)	;NO, EITHER
	LDB	T4,QUYPCS	;FLAG THAT WE
	CAIN	T4,STACML	;HAVE SEEN A CAN'T START
	JRST	STUPND		;OR IF CMPL, QUIT
	AOJA	P2,STUPL2	;ENTIRELY.
STUPL6:	AOS	PCBUSC(T2)	;START UNLOKED REQ.
STUPL7:	PUSHJ	P,UNLOKQ	;REMOVE REQ FROM Q.
	LDB	T4,QUYPCN	;
	PUSH	P,T4		;
	LDB	T4,QUYPCS	;
	HRLZM	T2,QUEPCB(J)	;
	TRO	T4,STQPCB	;
	DPB	T4,QUYPCS	;
	PUSH	P,T1		;SAVE T1 FROM US AND SETRUN.
	MOVEI	T1,RNQ		;FLAG THE
	DPB	T1,PJBSTS	;JOB TO
	PUSHJ	P,SETRUN	;BE
	POP	P,T1		;RESTARTED.
	POP	P,J		;
	TRNE	T1,STCMPL	;GIVE UP IF WE JUST STARTED
	JRST	STUPND		;A CMPL REQL.
	JUMPN	J,STUPL3	;
STUPND:	DPB	T1,PCUSTS	;FINISH
	DPB	T3,PCYLCC	;UP.
	POP	P,P2		;
	POPJ	P,		;
COMMENT #
@@SUBROUTINE PCBCLR
@@PURPOSE
SUBR FOR USE BY DSKCLN'S UUO, TO ZAP ALL THE SYSTEM PCBS.
@@ACCUM
DESTROYS T1 THRU T4.
@@EXIT
NON-SKIP RETURNS IF PCB IO IS IN PROGRESS.
1 SKIP RETURNS IF ERRORS.
2 SKIP RETURNS IF OKAY.
@@ #

INTERN PCBCLR

    ;DOES ANYONE HAVE A PCB RESOURCE?
PCBCLR:	MOVM	T1,PSREQ	;
	CAME	T1,NMSTPC	;
	JRST	CPOPJ1		;YES.
	MOVM	T1,PRREQ	;
	CAME	T1,NMRBPC	;
	JRST	CPOPJ1		;YES.

    ;BE SURE NO PCB IO IS IN PROGRESS.
	SKIPL	SATWRT		;ANY SAT PCB IO TO GO?
	POPJ	P,		;YES.
	PUSH	P,PG		;MAYBE.
	MOVEI	PG,%RIB.C	;
PCBCL2:	HRRZ	T2,%CTLST(PG)	;
PCBC24:	LDB	T1,PCISTS	;IO IN PROGRESS
	TRNE	T1,STDWRT!STDWAG!STDREA ;FOR THIS PCB?
	JRST	[POP P,PG	;YES.
		POPJ P,]	;
	HRRZ	T2,PCBLNK(T2)	;NO.  GET NEXT PCB.
	JUMPN	T2,PCBC24	;
	CAIN	PG,%SAT.C	;DONE WITH PCBS?
	JRST	PCBCL3		;YES.
	MOVEI	PG,%SAT.C	;NO, STILL SAT PCBS TO DO.
	JRST	PCBCL2		;

    ;CLEAR ALL THE STT TABLES.
PCBCL3:	HRLZI	T3,STPBAD!STPINC!STPCHK!STPRPT ;
	HLRZ	T1,STRDDB+STRUNI ;T1/ UNIT DB.
PCBCL4:	HRRZ	T2,UNISTT(T1)	;T2/ STT ENTRY ADDRESS.
PCBC42:	SKIPN	STTPTR(T2)	;
	JRST	PCBC44		;AT END OF THIS UNIT'S TABLE.
	ANDCAM	T3,STTSTS(T2)	;
	SETZM	STTAOB(T2)	;
	ADDI	T2,STTLEN	;
	JRST	PCBC42		;
PCBC44:	HLRZ	T1,UNISTR(T1)	;
	JUMPN	T1,PCBCL4	;

    ;CLEAR THE PCBS AND ORDER THE LRU/MRU LISTS.
PCBCL6:	HRRZ	T2,%CTLST(PG)	;T2/ PCB ON LIST.
	HRRZ	T3,%CTLRU(PG)	;T3/ ADDR INTO LRU-MRU LIST.
PCBC62:	SETZM	PCBPTR(T2)	;
	SETZM	PCBTIM(T2)	;MAKES DEBUGGING EASIER.
	SETZM	PCBSTS(T2)	;
	MOVEM	T2,(T3)		;ORDER THE LRU/MRU
	ADDI	T3,1		;LIST.
	HRRZ	T2,PCBLNK(T2)	;JUMP ON ANOTHER PCB OF
	JUMPN	T2,PCBC62	;THIS TYPE TO DO.
	SETZM	(T3)		;CLEAR LAST SLOT IN LRU/MRU.
	HRRM	T3,%CTMRU(PG)	;
	CAIN	PG,%RIB.C	;
	HRRM	T3,%RB2.C+%CTMRU
	CAIN	PG,%RIB.C	;
	JRST	PCBCL8		;
	MOVEI	PG,%RIB.C	;
	JRST	PCBCL6		;

PCBCL8:	POP	P,PG		;

	SETZM	SATFUL		;

    ;CLEAR SOME INFO USED FOR BAD SATS.
	SETZM	SATBAD		;NO FIRST BAD SAT.
	SETZM	SATBRD		;
	HRRZI	T1,SRPRPT	;CLEAR THE NEW
	ANDCAM	T1,STRDDB+STRBTS ;BAD SAT BIT.

	AOS	(P)		;2 SKIP RETURN.
	JRST	CPOPJ1		;
COMMENT #
@@SUBROUTINE PCBSWN
@@PURPOSE
SUBR THAT FIXES UP PCB HANDLING WHEN A JOB GETS A SWAP IN ERROR.
@@ENTRY
EXPECTS J/ JOB NUMBER.
@@ACCUM
DESTROYS T1 THRU T4.
@@ #

INTERN PCBSWN

PCBSWN:	PUSH	P,PG		;SAVE PG.

    ;M2 HANDLING.
	MOVEI	T1,M2Q		;IF JOB HAS "JUST STARTED"
	MOVE	T2,M2SWT	;FROM M2 WAIT,
	PUSHJ	P,RMVJST	;REMOVE IT.
	JRST	[HRRZ	T1,J	;WAS. ONLY OTHER THING OF INTEREST
				;JOB CAN BE DOING IS
		MOVEI PG,%SAT.C
		SETZ T4,
		JRST PCBSW8]	;TO BE RUNNING WITH A SAT PCB.
	MOVE	T2,M2HAV	;IF THE JOB REALLY HAS M2, GIVE
	PUSHJ	P,RMVJST	;IT UP AND CONTINUE
	JRST	.+1		;HERE.

    ;PR AND PS HANDLING.
	SETZ	PG,		;FLAG FOR %RIB.C OR %RB2.C.
	MOVEI	T1,PRQ		;IF JOB HAS JUST STARTED FROM
	MOVE	T2,PRSWT	;PRIMARY PCB WAIT IN SCHED1, DO
	PUSHJ	P,RMVJST	;THINGS TO THE PCB LOCK QUEUES.
	JRST	PCBSW2		;JUST STARTED FROM WAIT IN PR.
	MOVEI	T1,RIQ		;
	MOVE	T2,RISWT	;
	PUSHJ	P,RMVJST	;
	JRST	[SOSL PRREQ	;
		SOS PRAVAL	;
		JRST PCBSW2]
	MOVEI	PG,%SAT.C	;
	MOVEI	T1,PSQ		;
	MOVE	T2,PSSWT	;
	PUSHJ	P,RMVJST	;
	JRST	PCBSW2		;JUST STARTED FROM WAIT IN PS.
	MOVEI	T1,SIQ		;
	MOVE	T2,SISWT	;
	PUSHJ	P,RMVJST	;
	JRST	[SOSL PSREQ	;
		SOS PSAVAL	;
		JRST PCBSW2]	;
	JRST	PCBSW3		;FROM NEITHER MP QUEUE.
PCBSW2:	PUSHJ	P,LOCADJ	;FROM ONE OF THE MP QUEUES.
	JRST	PCBSW6		;FIX UP THE PCB LOCK QUEUE.

    ;ANY REMAINING CONNECTION WITH THE PCBS, OTHER THAN
    ;RUNNING FREE WITH ONE?
PCBSW3:	SKIPN	QUEPCB(J)	;
	JRST	PCBSW6		;NO.

	LDB	T3,PJBSTS	;YES.  IF WE ARE REALLY LOCKED,
	CAIN	T3,MLOWQ	;WE CAN'T HAVE BEEN SWPD IN.
	JRST	PCBSW5		;REALLY LOCKED.

    ;HERE ON 1ST JOB IN THE LOCK QUEUE FOR A SECONDARY OR JUST
    ;STARTED FROM LOCK QUEUE FOR A PRIMARY PCB.
	HLRZ	T2,QUEPCB(J)	;
	PUSHJ	P,CTLFND	;SET UP PG TO CTL BLK ADDR.
	HLRZ	T3,PCBPAG(T2)	;JUMP IF JUST STARTED FOR
	JUMPN	T3,PCBS45	;A PRIMARY PCB.
	PUSHJ	P,LOCADJ	;1ST JOB IN LOK Q DYING HERE
	JRST	PCBSW5		;IS LIKE MP JOB DYING.
PCBS45:	LDB	T4,QUYPCS	;SET UP T4
	TRZ	T4,STQPCB	;FOR
	PUSHJ	P,MAPREL	;MAPREL, TO RELEASE THE PCB.
PCBSW5:	SETZM	QUEPCB(J)	;

    ;HERE TO SEE IF WE ARE RUNNING WITH A PCB.
    ;(NOT EVERYBODY WHO GETS HERE CAN HAVE ALL THREE, BUT
    ;EASIER TO CHECK IF THEY DO THAN AVOID CHECKING.).
PCBSW6:	HRRZ	T1,J	;SET UP T1 FOR %CTSTS/%CTADR
	MOVEI	T4,3		;T4/ INDEX FOR MAPTBL.
PCBSW7:	MOVE	PG,MAPTBL-1(T4)	;PG/ CNTROL BLOCK ADDR.
PCBSW8:	LDB	T3,%CTADR(PG)	;DO WE HAVE A PCB OF
	JUMPE	T3,.+2		;THIS TYPE?
	PUSHJ	P,PERRLS	;YES, RELEASE IT.
	SOJG	T4,PCBSW7	;TRY NEXT PCB TYPE, IF ANY LEFT.

	POP	P,PG		;RESTORE PG.
	POPJ	P,		;DONE.




COMMENT #
@@SUBROUTINE RMVJST
@@PURPOSE
SUBR TO SEE IF A JOB HAS EITHER "JUST STARTED" WITH A CERTAIN
TYPE OF RESOURCE OR IF THE JOB IS RUNNING WITH M2, DEPENDING
ON THE TABLE ADDRESS WITH WHICH WE ARE CALLED, AND IF SO TO
FREE THE JOB UP.
@@ENTRY
EXPECTS J/ JOB NUMBER, T1/ QUEUE NUMBER,  AND T2/ ADDRESS OF
TABLE OF INTERESTING JOBS.
@@ACCUM
DESTROYS T2 AND T3.
@@EXIT 
NORMAL RETURN IF FOUND AND SKIP RETURN IF NOT FOUND.
@@ #

RMVJST:	CAMN	J,(T2)		;IS THIS TABLE ENTRY OUR JOB?
	JRST	.+3		;YES.
	AOBJN	T2,.-2		;NO, MORE ENTRIES IN THE TABLE?
	PJRST	CPOPJ1		;NO, NOT FOUND.
	SETZM	(T2)		;FOUND, REMOVE IT.
	SOSL	REQTAB(T1)	;
	SOS	AVALTB(T1)	;
	POPJ	P,		;




COMMENT #
@@SUBROUTINE LOCADJ
@@PURPOSE
SUBR TO HANDLE REMOVING A JOB FROM AN MP QUEUE.
IF THERE IS NO FOLLOWING JOB IN THE PCB LOCK QUEUE, JUST
DISPOSE OF THE SECONDARY PCB.  ELSE, MAKE THE FOLLOWING
JOB THE FIRST JOB AND WAKE IT UP SO IT CAN QUEUE FOR MP.
@@ENTRY
EXPECTS J/ JOB NUMBER AND PG/ %SAT.C OR 0(MEANS %RIB.C OR %RB2.C
OR %SAT.C).
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@ #

LOCADJ:	HLRZ	T2,QUEPCB(J)	;T2/ PCB ADDR.
	LDB	T1,QUYPCN	;IS THERE A FOLLOWING JOB IN
	JUMPE	T1,LOCAD2	;THE PCB LOCK QUEUE?

    ;HERE WHEN THERE IS ANOTHER JOB IN THE LOCK QUEUE.
	HRLM	T2,QUEPCB(T1)	;YES.  MAKE THAT
	PUSH	P,J		;JOB
	MOVE	J,T1		;THE
	PUSH	P,P1		;FIRST
	LDB	P1,QUYPCS	;JOB
	TRO	P1,STQPCB	;IN THE
	DPB	P1,QUYPCS	;LOCK QUEUE,
	SETZM	PCBUSC(T2)	;AND SET THAT
	PUSHJ	P,SETPCB	;JOB'S INFO
	POP	P,P1		;IN THE
	HRRM	J,PCBLKQ(T2)	;PCB.
	MOVEI	T1,RNQ		;WAKE
	DPB	T1,PJBSTS	;THAT
	PUSHJ	P,SETRUN	;JOB UP, SO IT CAN
	POP	P,J		;QUEUE FOR MP.
	POPJ	P,

    ;HERE WHEN THERE IS NO OTHER JOB IN THE LOCK QUEUE.
LOCAD2:	JUMPN	PG,.+2		;IF NECESSARY, SET PG TO THE
	PUSHJ	P,CTLFND	;CORRECT CNTL BLK ADDR.
	MOVE	T1,T2		;REMOVE PCB FROM CTL BLK
	PUSHJ	P,UNLNK2	;LINKED LIST.
	MOVEI	T1,1		;GIVE BACK THE SECONDARY PCB
	PJRST	GIV4WD		;TO FREE CORE.






COMMENT #
@@SUBROUTINE PERRLS
@@PURPOSE
@@ENTRY
EXPECTS PG/ CNTL BLOCK ADDR, T3/ INDEX OF PCB FROM %CTADR,
J/ JOB NUMBER, AND T1 SET UP FOR %CTSTS/ADR
@@ACCUM
DESTROYS T3.
@@EXIT 
@@ #


PERRLS:	PUSH	P,T1		;SAVE T1,
	PUSH	P,T2		;T2, AND
	PUSH	P,T4		;T4 FOR CALLER.
	SETZ	T4,		;CLEAR %CTADR SO NEXT JOB WHICH LOGS
	DPB	T4,%CTADR(PG)	;IN GETTING THIS JOB NO. ISNT SCREWED UP
	LDB	T4,%CTSTS(PG)	;GET %CTSTS WHILE T1 STILL GOOD
	PUSHJ	P,ADRUNL	;GET T2/ PCB ADDRESS.
	PUSHJ	P,MAPREL	;RELEASE THE PCB.
	POP	P,T4		;RESTORE T1,
	POP	P,T2		;T2, AND
	POP	P,T1		;T4 FOR CALLER.
	POPJ	P,


COMMENT #
@@SUBROUTINE ADRUNL
@@PURPOSE
SUBR TO, GIVEN AN "INDEX" A LA %CTADR AND A CNTL BLK ADDR IN
PG, FIND THE PCB ADDRESS.
@@ENTRY
SEE PURPOSE;  EXPECTS INDEX IN T3.
@@ACCUM
DESTROYS T1, T2, AND T3.
@@EXIT
RETURNS T2/ PCB ADDRESS.
@@ #

INTERN ADRUNL

ADRUNL:	HRRZ	T2,%CTLST(PG)	;FIND THE PCB
ADRUN1:	HLRZ	T1,PCBPAG(T2)	;ADDRESS WE WANT, ACCORDING TO
	JUMPN	T1,ADRUN2	;THE NUMBER IN T3, BY
	HRRZ	T2,PCBLNK(T2)	;SKIPPING OVER THE SECONDARY
	JUMPN	T2,ADRUN1	;PCBS AND THEN
	STOPCD
ADRUN2:	SOJLE	T3,CPOPJ	;COUNTING
	HRRZ	T2,PCBLNK(T2)	;THRU
	JUMPN	T2,ADRUN2	;THE PRIMARY PCBS.
	STOPCD


COMMENT #
@@SUBROUTINE CTLFND
@@PURPOSE
SUBR TO SET UP IN PG THE ADDR OF THE PCB CONTROL BLOCK WHICH
CONTROLS THE PCB WHOSE ADDR IS IN T2.
@@ENTRY
SEE PURPOSE.
@@ACCUM
DESTROYS T1, T3, AND PG.
@@EXIT 
SEE PURPOSE.
@@ #

INTERN CTLFND
CTLFND:	MOVEI	T3,3		;T3/ INDEX FOR MAPTBL.
CTLFN1:	MOVE	PG,MAPTBL-1(T3)	;TRY THIS CNTL BLOCK.
	HRRZ	T1,%CTLST(PG)	;T1/ PCB ADDRESS.
	CAIN	T1,(T2)		;IS IT OUR PCB?
	POPJ	P,		;YES, DONE.
	HRRZ	T1,PCBLNK(T1)	;NO, GET NEXT PCB ADDRESS.
	JUMPN	T1,.-3		;TRY AGAIN.
	SOJG	T3,CTLFN1	;OUT OF PCBS FOR THIS CNL BLOCK.
	STOPCD			;OUT OF CTL BLKS.  BLEW IT.
COMMENT #
@@SUBROUTINE PSSSWT/PRSSWT/M2SSWT/M2HSWT
@@PURPOSE
PSSSWT, PRSSWT, AND M2SSWT MARK JOBS AS WAITING TO SWAP IN
FOR THE PS, PR, AND M2 RESOURCES, RESPECTIVELY.  M2HSWT
MARKS JOBS AS HAVING THE M2 RESOURCE.
@@ENTRY
EXPECTS J/ JOB NO.
@@ACCUM
DESTROYS NO ACS.
@@ #

INTERN PSSSWT,PRSSWT,M2SSWT,SISSWT,RISSWT
SISSWT:	PUSH	P,T1
	MOVE	T1,SISWT
	JRST	PCBSWT

PSSSWT:	PUSH	P,T1		;GET THE AOBJN
	MOVE	T1,PSSWT	;POINTER TO T1.
	JRST	PCBSWT		;

RISSWT:	PUSH	P,T1
	MOVE	T1,RISWT
	JRST	PCBSWT

PRSSWT:	PUSH	P,T1		;GET THE AOBJN
	MOVE	T1,PRSWT	;POINTER TO T1.
	JRST	PCBSWT		;

M2SSWT:	PUSH	P,T1		;GET THE AOBJN
	MOVE	T1,M2SWT	;POINTER TO T1.
	JRST	PCBSWT		;

M2HSWT:	PUSH	P,T1		;GET THE AOBJN
	MOVE	T1,M2HAV	;POINTER TO T1.

PCBSWT:	SKIPE	(T1)		;IS THIS A FREE SLOT?
	AOBJN	T1,.-1		;NO, TRY TO GET NEXT.
	JUMPL	T1,.+2		;FREE SLOT, OR OUT OF ROOM?
	STOPCD
	MOVEM	J,(T1)		;FREE SLOT, USE IT.
	JRST	TPOPJ		;EXIT, RESTORING T1 AS WE GO.




COMMENT #
@@SUBROUTINE PSSRMV/PRSRMV/M2SRMV/M2HRMV/RISRMV/SISRMV
@@PURPOSE
PSSRMV, PRSRMV, AND M2SRMV REMOVE JOBS FROM THE APPROPRIATE
WAITING TO SWAP IN LIST.  M2HRMV REMOVES JOBS FROM THE HAVE
M2 LIST.  ONLY M2HRMV DEMANDS THAT THE JOB BE ON THE LIST.
@@ENTRY
EXPECTS J/ JOB NO.
@@ACCUM
DESTROYS NO ACS.
@@ #

SISRMV:	PUSH	P,T1		;
	MOVE	T1,SISWT	;
	JRST	PCBRMV		;

RISRMV:	PUSH	P,T1		;
	MOVE	T1,RISWT	;
	JRST	PCBRMV		;

PSSRMV:	PUSH	P,T1		;GET THE AOBJN
	MOVE	T1,PSSWT	;POINTER TO T1.
	JRST	PCBRMV		;

PRSRMV:	PUSH	P,T1		;GET THE AOBJN
	MOVE	T1,PRSWT	;POINTER TO T1.
	JRST	PCBRMV		;

M2SRMV:	PUSH	P,T1		;GET THE AOBJN
	MOVE	T1,M2SWT	;POINTER TO T1.

PCBRMV:	CAMN	J,(T1)		;IS THIS OUR SLOT?
	JRST	.+3		;YES.
	AOBJN	T1,PCBRMV	;NO, LOOK AT NEXT SLOT.
	JRST	TPOPJ		;
	SETZM	(T1)		;CLEAR OUR SLOT.
	JRST	TPOPJ		;EXIT, RESTORING T1 AS WE GO.


M2HRMV:	PUSH	P,T1		;GET THE AOBJN
	MOVE	T1,M2HAV	;POINTER TO T1.
	CAMN	J,(T1)		;
	JRST	.+3		;
	AOBJN	T1,.-2		;
	STOPCD
	SETZM	(T1)		;
	JRST	TPOPJ		;

INTERN M2HAV
M2HAV: Z


;TINY SUBR TO SEE IF WE HAVE THE M2 RESOURCE.
INTERN HAVM2
HAVM2:	MOVE	T2,JOB		;
	MOVE	T1,M2HAV	;
	CAMN	T2,(T1)		;
	POPJ	P,		;YES, HAVE M2.
	AOBJN	T1,.-2		;
	JRST	CPOPJ1		;DO NOT HAVE M2.
COMMENT #
@@SUBROUTINE MAPXCH
@@PURPOSE
SUBR TO INTERCHANGE THE INFO FOR
%RIB AND %RB2.  IF BOTH ARE ZERO, NO NEED TO DO ANYTHING.  IF
BOTH ARE <>0, JUST INTERCHANGE INFO. IF %RIB IS =0 AND %RB2 IS
<>0, THEN RELEASE M2. IF %RIB IS <>0 AND %RB2 IS =0, THEN
GET M2.
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@ #

INTERN MAPXCH

MAPXCH: SKIPN	T1,@%RIB.C+%CTUPT ;IF BOTH ARE
	SKIPE	@%RB2.C+%CTUPT ;=0, NO
	JRST	.+2		;NEED TO DO
	POPJ	P,		;ANYTHING.
	JUMPE	T1,MAPXC4	;JUMP IF %RIB=0 AND %RB2 <>0.
	SKIPE	@%RB2.C+%CTUPT	;JUMP IF BOTH %RIB AND
	JRST	MAPXC7		;%RB2 <>0.

    ;HERE IF %RIB <>0 AND %RB2 =0.
	PUSH	P,PG		;SAVE PG AND
	PUSH	P,J		;J.
	MOVE	T1,JOB		;SAVE
	LDB	T3,%CTSTS+%RIB.C ;THE STATUS OF
	PUSH	P,T3		;HOW WE GOT %RIB.
	HRRZ	T2,@%CTUPT+%RIB.C ;T2/ PCB ADDRESS FOR %RIB.
	PUSH	P,PCBPTR(T2)	;SAVE %RIB'S DISK POINTER.
	MOVEI	PG,%RIB.C	;RELEASE
	PUSHJ	P,MAPRLS	;%RIB.
	POP	P,T1		;T1/DISK POINTER.
	POP	P,T2		;RESTORE %RIB'S STATUS.
	MOVEI	PG,%RB2.C	;THEN
	PUSHJ	P,@CODADR(T2)	;GET %RB2.
	POP	P,J		;RESTORE J AND
	POP	P,PG		;PG.
	POPJ	P,

    ;HERE IF %RIB =0 AND %RB2 <>0.
MAPXC4:	SOSL	M2REQ		;RELEASE AN
	SOS	M2AVAL		;M2 RESOURCE.
	PUSH	P,J		;TAKE US OFF
	MOVE	J,JOB		;THE LIST OF
	PUSHJ	P,M2HRMV	;PEOPLE WHO HAVE
	POP	P,J		;M2.

	MOVE	T1,@%RIB.C+%CTUPT ;
MAPXC7:	EXCH	T1,@%RB2.C+%CTUPT ;
	MOVEM	T1,@%RIB.C+%CTUPT ;

	LDB	T1,%RIB.C+%CTBYP ;
	LDB	T2,%RB2.C+%CTBYP ;
	DPB	T2,%RIB.C+%CTBYP ;
	DPB	T1,%RB2.C+%CTBYP ;


	MOVE	T1,JOB		;SETUP FOR %CTADR/STS

	LDB	T3,%RIB.C+%CTADR
	LDB	T4,%RB2.C+%CTADR
	DPB	T4,%RIB.C+%CTADR
	DPB	T3,%RB2.C+%CTADR

	LDB	T3,%RIB.C+%CTSTS
	LDB	T4,%RB2.C+%CTSTS
	DPB	T4,%RIB.C+%CTSTS
	DPB	T3,%RB2.C+%CTSTS
	CLRPTO	%RIB	;CLEAR PAGE TABLE FOR %RIB AND
	CLRPTO	%RB2	; %RB2.
	POPJ	P,


COMMENT #
@@SUBROUTINE SMMPXC
@@PURPOSE
SIMPLE SUBR LIKE MAPXCH, BUT ASSUMES CALLER KNOWS WHAT IT IS
DOING, SO SMMPXC DOESN'T WORRY ABOUT M2.
@@ACCUM
DESTROYS T1, T2, T3, AND T4.
@@ #


INTERN SMMPXC

SMMPXC: SKIPN	T1,@%RIB.C+%CTUPT ;IF BOTH ARE
	SKIPE	@%RB2.C+%CTUPT ;=0, NO NEED TO DO ANYTHING.
	JRST	MAPXC7		;
	POPJ	P,		;
COMMENT #
@@SUBROUTINE GETER1/GETER2
@@PURPOSE
SUBR TO RETURN IN T1 PGYERR FOR %RIB(GETER1) OR FOR
%SAT(GETER2).
@@ACCUM
DESTROYS T1.
@@EXIT
SEE PURPOSE
@@#

INTERN GETER1,GETER2
EXTERNAL OHTTAB,OHTDTE,OHTDER,OHTPAR,SRCOHT,OHTNUM

GETER2:	SKIPA	T1,[XWD %SAT.C,%SAT]
GETER1:	MOVE	T1,[XWD %RIB.C,%RIB]
	PUSH	P,PG		;SAVE PG.
	MOVE	PG,(T1)		;MAKE SURE READ HAS BEEN DONE.
	MOVSS	T1		;
	HRRZ	PG,@%CTUPT(T1)	;GET PG/ ADDR OF
	HLRZ	PG,PCBPAG(PG)	;PAGE.
	SKIPN	OHTNUM		;ANY OUTPUT ERRORS?
	JRST	GETERA		;NO, JUST LOOK AT PGYERR
	PUSH	P,T2
	PUSH	P,T3
	PUSH	P,T4
	LDB	T2,PGYADR	;GET ADDRESS TO SEARCH FOR INOHT
	PUSHJ	P,SRCOHT	;OUTPUT ERROR FOR THIS PAGE?
	  JRST	GETERB		;NO, POP ACS AND GET PGYERR IN T1.
	LDB	T1,[POINT 2,OHTTAB(T4),1] ;GET BITS IN RH(T1)
	MOVSI	T2,OHTPAR	;PARITY MAY BE ON IF READING LUD OR SOME USER FILE
				; THRU PCBS
	TDNE	T2,OHTTAB(T4)	;IS IT ON?
	TRO	T1,2		;YES, SET DEVICE ERROR BIT.
	POP	P,T4
	POP	P,T3
	POP	P,T2
	POP	P,PG
	POPJ	P,		;RETURN WITH OUTPUT ERROR BITS.

GETERA:	LDB	T1,PGYERR	;
	POP	P,PG		;RESTORE PG.
	POPJ	P,

GETERB:	POP	P,T4
	POP	P,T3
	POP	P,T2
	JRST	GETERA		;GET STUFF BACK AND CHECK FOR INPUT ERRORS.
COMMENT #
@@SUBROUTINE SATONC
@@PURPOSE
SUBR CALLED BY ONCE A SECOND CODE TO SEE IF ANY SATS NEED TO BE
WRITTEN OUT.
@@ENTRY
@@ACCUM
DESTROYS T1, T2, T3, T4, AND PG.
@@EXIT
@@ #

INTERN SATWRT,SATONC
SATWRT:-1	;ON ENTRY TO SATONC, SATWRT MEANS:
		;-1 MEANS NO SATS NEEDING TO BE WRITTEN OR
		;ON THEIR WAY OUT.  >0 MEANS AT LEAST ONE SAT
		;MAY NEED TO BE WRITTEN OUT.  0 MEANS THAT
		;SOME SATS MAY BE ON THEIR WAY OUT, BUT NONE
		;NEED TO BE STARTED OUT.

SATONC: SKIPGE	T1,SATWRT	;ANYTHING TO DO?
	POPJ	P,		;NO.
	JUMPE	T1,.+3		;JUMP IF JUST NEED TO CHECK IF THE SATS ARE FINISHED.
	SOSE	SATWRT		;ELSE, NOW LOOK AT SEE IF ANY
	POPJ	P,		;NEED TO BE WRITTEN?


    ;FIND THE ADDRESS OF THE FIRST PRIMARY SAT PCB.
	HRRZ	T2,%SAT.C+%CTLST ;T2/ ADDR OF CURRENT SAT PCB.
	HLRZ	PG,PCBPAG(T2)	;SKIP
	JUMPN	PG,SATON2	;OVER THE
	HRRZ	T2,PCBLNK(T2)	;SECONDARY
	JUMPN	T2,.-3		;PCBS.
	STOPCD

SATON2:	JUMPN	T1,SATON4	;JUMP IF MAYBE NEED TO START SOME OUT.

    ;HERE TO SEE IF ALL SAT WRITE OUTS ARE FINISHED.
SATON3:	LDB	T3,PCISTS	;WRITE IN PROGRESS FOR
	TRNE	T3,STDWRT!STDWAG ;THIS SAT PCB?
	POPJ	P,		;YES, NO NEED TO LOOK AT OTHERS.
	HRRZ	T2,PCBLNK(T2)	;NO.  LOOK AT
	JUMPN	T2,SATON3	;THE NEXT ONE.
	SETOM	SATWRT		;FLAG NO SATS ON WAY OUT.
	POPJ	P,

    ;HERE TO LOOK FOR SATS TO START OUT.
SATON4:	PUSH	P,T2		;SAVE ADDR OF 1ST PRIM PCB.
SATON5:	HLRZ	PG,PCBPAG(T2)	;
	LDB	T3,PGYDRT	;WAS THIS PCB
	JUMPE	T3,SATON8	;MODIFIED?
	HRRZ	T3,PCBUSC(T2)	;YES, IS IT STILL
	JUMPE	T3,.+3		;IN USE?
	AOS	SATWRT		;YES.
	JRST	SATON8		;
	PUSH	P,[SATON8]	;NO.  RETURN ADDRESS.
	PUSH	P,[0]
	JRST	MAPRL7		;

    ;LOOK AT NEXT PRIMARY PCB.
SATON8:	HRRZ	T2,PCBLNK(T2)	;ANOTHER ONE
	JUMPN	T2,SATON5	;LEFT?

	POP	P,T2		;NO.  T2/ADDR OF 1ST PRIM PCB.
	SKIPN	SATWRT		;SAW ONE WE COULDN'T START?
	JRST	SATON3		;NO, CHK IF ALL SAT WRITING IS DONE.
	MOVEI	T1,1		;YES, SAY
	MOVEM	T1,SATWRT		;SO.
	POPJ	P,		;
;ROUTINE TO HANDLE PCDTIM COUNTER.
; CALLED ONCE PER TICK IF PCDCNT IS ZERO.

TIMPCD::AOS	PCDTIM		;OK, INCREMENT ANOTHER TIME.

;LOOP THRU ALL PCBS AND GET PCDCNT SETUP, PCPDRF SET ON DIRTY PCBS

	MOVN	T4,NMRBPC	;GET -VE NUMBER OF RIB PCBS
	SUB	T4,NMSTPC	;TOTAL -VE NUMBER
	HRLS	T4
	HRR	T4,PCBTAB	;GET POINTER TO PCB ADDRESSES, BITS

PCDTM1:	MOVE	T2,(T4)		;GET PCB ADDRESS
	HLRZ	PG,PCBPAG(T2)	;GET CORE PAGE
	LDB	T1,PGYDRT	;SEE IF ITS DIRTY
	JUMPN	T1,PCDTM2	;JUMP IF YES.
	LDB	T1,PCISTS	;NOT DIRTY, GET STATUS BYTE OF PCB
	TRNN	T1,STDWRT!STDWAG ;ON ITS WAY OUT?
	JRST	PCDNX1		;NO, NOTHING TO WAIT FOR.
PCDTM2:	DSKOFF			;DON'T LET FINPCB FOOL AROUND
	LDB	T1,PGYDRT	;MAKE SURE ITS STILL EITHER DIRTY OR GOING OUT
	JUMPN	T1,PCDTM3	;JUMP IF STILL DIRTY
	LDB	T1,PCISTS	;NOT DIRTY, MAKE SURE DIDN'T FINISH YET
	TRNN	T1,STDWRT!STDWAG	;IF EITHER OF THESE STILL ON, IO STILL GOING
	JRST	PCDNXT		;ITS FINISHED NOW, NOTHING TO DO.
PCDTM3:	MOVSI	T1,STPDRF	;SET THE FLAG
	IORM	T1,PCBSTS(T2)	;IN THE PCB
	AOS	PCDCNT		;INCREMENT COUNT, SAVE IT FOR IRP CHECK
PCDNXT:	DSKON			;OK
PCDNX1:	AOBJN	T4,PCDTM1	;LOOP THRU ALL PCBS
	SKIPN	PCDCNT		;IF COUNT WENT TO ZERO ALREADY,
	AOS	PCDTIM		;THEN INCREMENT THE CLOCK
	POPJ	P,		;RETURN.

PCDTIM::0			;SYSTEM WIDE PCB DIRTY MONITOR CLOCK
PCDCNT::0			;NUMBER OF DIRTY PCBS FOR THIS CYCLE
COMMENT #
@@SUBROUTINE HANGRB
@@PURPOSE
A LITTLE SUBR CALLED AT HANG TIME TO BE SURE THAT ALL THE
RIBS HAVE BEEN WRITTEN.
@@ACCUM
DESTROYS NO ACS.
@@EXIT
SKIP RETURNS IF OKAY, ELSE NON-SKIP RETURNS.
@@ #

INTERN HANGRB

HANGRB:	PUSH	P,T1		;SAVE T1 AND
	PUSH	P,T2		;T2.
	HRRZ	T2,%RIB.C+%CTLST ;T2/ ADDR OF FIRST RIB PCB.
	HLRZ	T1,PCBPAG(T2)	;BETTER BE
	JUMPE	T1,HANGOT	;A PRIMARY.
HANGR3:	LDB	T1,PCISTS	;IO IN PROGRESS FOR THIS
	TRNE	T1,STDWRT!STDREA!STDWAG ;PCB?
	JRST	HANGOT		;YES, TAKE THE WAIT RETURN.
	HRRZ	T2,PCBLNK(T2)	;NO, IS THERE ANOTHER PCB?
	JUMPN	T2,HANGR3	;JUMP ON YES.
	AOS	-2(P)		;NO, WIN.
HANGOT:	POP	P,T2		;RESTORE T2 AND
	POP	P,T1		;T1.
	POPJ	P,
;SUBROUTINE TO CALL WAIT1
;THIS IS NEEDED SINCE WAIT1 CLOBBERS P1-P4

;THIS INSTRUCTION IS USED TO RESTORE PWAIT1 AFTER RESTART (SEE WTSATS)
INTERN PWAITZ
PWAITZ:	JSP	T4,SAVE4

INTERN PWAIT1
PWAIT1:	JSP	T4,SAVE4	;SAVE P1-P4
	PJRST	WAIT1		;GO TO WAIT1




COMMENT #
@@SUBROUTINE DRSCHK
@@PURPOSE
CALLED TO SEE IF A JOB HAS A SHARABLE DISK RESOURCE (CALLED BY
SCHEDULER TO GIVE JOB HIGHER PRIORITY.).
@@ENTRY
EXPECTS J/ JOB OF INTEREST.
@@ACCUM
DESTROYS NO ACS.
@@EXIT
SKIP RETURNS IF JOB DOES HAVE SHARABLE DISK RESOURCE, ELSE
NON-SKIP RETURNS.
@@ #

INTERN DRSCHK

DRSCHK:	CAMN	J,CBUSER	;HAS CB RESOURCE?
	JRST	CPOPJ1		;YES, SKIP RETURN.
	PUSH	P,T1		;SAVE T1.
	SKIPE	T1,QUEPCB(J)	;INVOLVED WITH THE PCBS?
	JRST	DRSCH2		;YES.
	MOVSI	T1,-1		;SHORTHAND TRICK: CHECK ALL %CTADR
	TDNE	T1,JBTPCB(J)	;BYTES (KNOWN TO LIVE IN LH) AT ONCE
	JRST	TPOPJ1		;TO SEE IF HAS %RIB,RB2 OR SAT. YES,
				;HAS AT LEAST ONE
	JRST	TPOPJ		;HAS NONE OF THEM
DRSCH2:	LDB	T1,QUYPCS	;LH QUEPCB FLAGGED AS A
	TRNN	T1,STQPCB	;PCB ADDR?
	JRST	TPOPJ		;NO, JUST QUEUED; NONSKIP RTN
	LDB	T1,PJBSTS	;YES, 1ST IN Q AND STATIONARY OR
	CAIN	T1,RNQ		;REALLY RUNNING OR ABOUT TO RUN?
	JRST	TPOPJ1		;REALLY RUNNING HAS SHARABLE RES.
	JRST	TPOPJ		;
	END
 @\