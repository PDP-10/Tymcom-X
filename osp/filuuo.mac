TITLE	FILUUO	DISK SERVICE ROUTINE

	ENTRY FILUUO
FILUUO:
	ENTRY FILSER	;FOR HISTORICAL REASONS
FILSER:			;  HYSTERICAL?

;DEFINITIONS IN M

UUOLUK==400000	;UUO IS A LOOKUP
EXTUUO==200000	;EXTENDED UUO
UUOMLK==100000	;MULTIPLE EXTENSION LOOKUP
UUOENT==040000	;UUO IS AN ENTER
UUOUFD==020000	;FILE UUO DEALS WITH IS A UFD
UUOREN==010000	;UUO IS A RENAME
UUOSIM==004000	;SET IN UPDATE IF ITS SIMULTANEOUS STYLE
UUOIRE==002000	;SET SO THAT FILFND STILL LEAVES ATB COUNT UP IF RIB ERROR,
		; WITH INFO FROM UFD IN THE ATB.
UUOMSK==777777	;CLEAR ALL BITS INCLUDING INDEX AND INDIR

;BITS IN UUXNUM.
UUPWDS==200000	;ENTER/RENAME--ALLOCATION WORD IS IN UNITS
		;OF WORDS, NOT BLOCKS.
UUPPID==100000	;LOOKUP/ENTER/RENAME - PID ACCESS BIT

INTERNAL UUOLUK,EXTUUO,UUOMLK,UUOENT,UUOUFD,UUOREN,UUOIRE
INTERNAL DSKRES,DSKKJB,JOBSTR,DSKSTP,DSKDSP
INTERNAL PRTWDW,PRTWDR
INTERNAL UUPPID

;EXTERNALS FROM OTHER PARTS OF THE MONITOR

EXTERNAL GETWDS,GIVWDS,TPOPJ,CPOPJ,CPOPJ1,TPOPJ1,PJOBN,WATPCB
EXTERNAL KMAPP,KFDEL,KFCRE,KFEXC,IOSERR,IOSRBE,IOSRIB,IOSUPR,KSMAPP
EXTERN KVLRIB,KFFIFP,KFTRN,KMOVPG
EXTERNAL JBTPRV,JBTPPN,JBTUNM,JBTUN1,JBTAUN,JBTSER
EXTERN NORED,NOWRT,PIDACC
EXTERNAL JBTDLK,JBTSLK,JBTERN,JBTLIC,JBYWPT,UPTPJC	;-
EXTERNAL UPTPID,UPTSPD
EXTERNAL TIME,JFYSEC,THSDAT,WAIT1,HIGHJB,JOB,UPTJDA,CLOSE1
EXTERNAL UPTRIB,UPTRB2,UPTSAT,QUEPCB,JBTABT,JBTSTS,CPOPJ2
EXTERNAL SYDNM4,STOIOS,SAVE4,GET4WD,GIV4WD,PWAIT1,CURUPT,EPT,ONCTIM
EXTERNAL UPTPDL,DATCOM,%UPT
EXTERNAL PDNMUP

;EXTERNAL IN OTHER PARTS OF FILSER

EXTERNAL SRCFIL,CHKPRV,FREATB,GETCBR,INVDDB,RIBRDL,RIBWTL,ZERDDB
EXTERNAL RELLOK,SRCNAM,GETAPG,DLTTRC,FNDDRB,GIVCBR
EXTERN GIVCB1,%RIB.C,MAPWLN,DLTNAM,USETI0,USETO0,DLTALL,%CTUPT
EXTERNAL DIRSRC,TSTWRT,LKDATB,ULKDBL,TSTWRS
EXTERNAL LOKPPB,NLKPPB,DEVLG,GUFBT,GIVCB1,RMVATB
EXTERNAL MAPWTL,%RB2.C,MAPRLS,MAPXCH,GETER1,RIBDIR,MAPRDU
EXTERNAL DIRBLK,PTROUT,CRBRWL,INSNAM,RRSETB,FPCSET
EXTERNAL PCBCLR,PTROU2,GIVPAG,UUOSEK
;EXTERNAL IN COMMOD

EXTERNAL MFDPPN,SYSPPN,BLKLSH,SYSDRB,UFDPRT,STNPRT,DSKDDB
EXTERN BLKSPP
EXTERNAL STRTAL,STROVR,CBUSER,INDPPN,SYSCOR
EXTERNAL SYSUNI,ETSUNI,METSLN,ETSTAB,STRDDB,STRLEN,STRUNI

EXTERNAL UNILOG,UNINAM,UNISYS,UNIKON,UNIDES,UNITAL,UNICHR
EXTERNAL UNIPPU,UNIHID,UNISTR
EXTERNAL UNYSIZ,UNYSPU,UNYWPS

EXTERNAL DEVATB,DEVDRB,DEVDBL,DEVELB,DEYTCT,DEYSTC
EXTERNAL DEVRB1,DDBCOR,DDBLEN,DEVRIB,DEVRET,DEVFLO,DEVPOS
EXTERNAL PTRCHG

EXTERNAL ATBFNB,ATBCNT,ATBSIZ,ATBPVW,ATBMSC,ATBLIC,ATBALP,ATBSTS
EXTERNAL ATBRIB,ATBPRV,ATBLCW,ATBDOR,ATBLNK,ATBMWC,ATBUMC
EXTERNAL ATBPID
EXTERNAL ATPMXU,ATPDIR,ATPCRE,ATPNDL,ATPDEL,ATPUPD,ATPDMP,ATMCNT,ATPCNT
EXTERNAL ATPSUP,ATPREN,ATPUFE,ATPPID,ATPALC,ATMCSC,ATMUFP,ATMUFU,ATMMWC,ATMUMC
EXTERNAL ATYBSZ,ATYBLK,ATYXCD,ATYCTM,ATYCSC,ATYCTD,ATYCDT
EXTERNAL ATYCNT,ATYPRV,ATYADT,ATYUF1,ATYUF2

EXTERNAL FNBEXT,FNBAPD,FNBNX,FNBRIB,FNBNAM,FNBDRB,FNBLNK,FNBUPD,FNBALT
EXTERNAL FNPNX,FNBATB,FNBDBL,FNYUFP

EXTERNAL FNCLOK,FNCRED,FNCEXC,FNCCRE,FNCSUP,FNCAPP
EXTERNAL FNCUPD,FNCTRN,FNCCAT,FNCDEL,FNCCNM,FNCCPR

EXTERNAL DRBCNT,DRBRIB,DRBALC,DRBMXA,DRBLNK,DRBUNM,DRBUN1,DRBNAM
EXTERNAL DRBNX,DRBFNB,DRYPRV,DRYCNT
EXTERNAL DRPMXC,DRPNX,DRMCNT,DRPLOG,DRBLOG

EXTERNAL RIBVER,RIBFUT,RIBPPN,RIBEST,RIBEXT,RIBPVW,RIBNAM,RIBPOS
EXTERNAL RIBFT1,RIBLCW,RIBMTA,RIBDEV,RIBSTS,RIBELB,RIBXT1,RIBQTF
EXTERNAL RIBQTO,RIBAUT,RIBUNM,RIBUN1,RIBTRU,RIBXT2,RIBSNM,RIBALC
EXTERNAL RIBUSD,RIBMXA,RIBPID,RIBCOD,CODRIB,RIBSLF,RIBSZS,RBMASK
EXTERNAL RIBALT
EXTERNAL RIPDIR,RIPHRE,RIPHWE,RIPLOG,RIBPFS,RIPNFS,RIPUFE,RIPPID
EXTERNAL RBYPN1,PTSPNO,PTNPNO,RBYUN1,RIBRIB,RIBSIZ,RIBALP,RIPBDR
EXTERNAL RIBPJC,RIBPJ1,RIBPJ2	;-
EXTERNAL RIPBDA,RIPBFS,RIBLST,RBDLTA,RBINDX,RIPSPP,RIPBDR

EXTERNAL STRHSH

EXTERNAL STRBTS,SRPNDS

EXTERNAL CMBLNK

EXTERNAL KONLTM

EXTERNAL UFPERR,UFDERR,UFDALP,UFDCDT,UFDEXT,UFDLIC,UFDNAM,UFDRIB
EXTERNAL UFYCTM,UFYPRV,UFYUF1,UFYUF2,UFYXCD,RBREAL,UFDSIZ
EXTERNAL UFYCDT,UFDLNK

;EXTERNS FROM SIMIO MODULE
EXTERN USETI0,USETO0,INBLT,OUTBLT,SIMRLS
EXTERN UPTPOS
EXTERN PCDTIM
COMMENT ! **************************************************

		DISK  DISPATCH  TABLE   DSKDSP

		( DEVSER(F) POINTS HERE )
***********************************************************!

	PHASE -2
DDO:	JRST OUTBLT		;DUMP OUTPUT
DDI:	JRST INBLT		;DMP INPUT.  SEE SIMIO
	DEPHASE
DSKDSP:
	PHASE 0
DDXZ:	DSPSIZ
DDINT:	POPJ P,
DBYT:	4400,,4400
DVSIZ:	MOVEI T1,DDBLEN
DINI:	POPJ P,
DHNG:	JRST CPOPJ1
DRL:	JRST DSKREL	;CALLS CLOS IN/OUT WHICH CALL SIMRLS
DCL:	JRST CLOSOU
DOU:	STOPCD		;BUFF OUTPUT. SIMBOU USES DDO EXCLUSIVELY
DIN:	STOPCD	;BUFF INPUT, SIMBIN USES DDI EXCLUSIVELY
DZAP:	POPJ P,		;FORGET ZAP
DGTRD:	POPJ P,		;FORGET GET READY
DMT:	POPJ P,
DGF:	JRST DSKUGF
DEN:	JRST UENTR
DLK:	JRST ULOOK
DRN:	JRST RENAM
DSI:	JRST USETI0
DSO:	JRST USETO0
DCLI:	JRST CLOSIN
DUFD:	JRST UFDUUO
DSEK:	JRST UUOSEK
DVMAP:	JRST	KMAPP
DFDEL:	JRST	KFDEL
DFCRE:	JRST	KFCRE
DFEXC:	JRST	KFEXC
DSIM:	JRST	USIMUP		;SIMULTANEOUS UPDATE CHANIO
DFVLR:	JRST	KVLRIB
DVSMAP:	JRST	KSMAPP
DFFIF:	JRST	KFFIFP
DFTRN:	JRST	KFTRN
DMOVPG:	JRST	KMOVPG		;MAKE VP MAPPABLE FROM FILE
	DSPSIZ==.-1
	DEPHASE

SUBTTL	INTERFACE SUBROUTINES WITH THE REST OF THE MONITOR

INTERN	TSTDSK,SETDDB,CLRDDB

;SUBROUTINE TO SAVE AND RESTORE TEMP ACS
;CALLED BY PUSHJ P,SAVT   RETURN EITHER CPOPJ OR CPOPJ1 WHEN THROUGH
INTERN SAVT
SAVT:	EXCH	T4,(P)		;SAVE T4, GET RETURN ADR.
	PUSH	P,T3		;SAVE T3
	PUSH	P,T2		;AND T2
	PUSHJ	P,(T4)		;RETURN TO CALLER
	  SKIPA			;POPJ RETURN
	AOS	-3(P)		;CPOPJ1 - SET SKIP RETURN
	POP	P,T2		;RESTORE T3 ACS
	POP	P,T3
	POP	P,T4
	POPJ	P,		;AND RETURN

;SUBROUTINE TO TEST IF THE DEVICE WHOSE NAME IS IN T1 IS A DISK
;ENTER WITH J (=J)= JOB NUMBER
;EXIT CPOPJ IF A DISK, WITH F=PROTOTYPE DDB
;EXIT CPOPJ1 IF NOT A DISK, OR A SINGLE-ACCESS DISK NOT FOR THIS JOB
;CALLED BY DEVPHY
TSTDSK:	JUMPE	T1,CPOPJ1	;"0" IS NOT A DISK
	PUSHJ	P,SAVT		;SAVE T2-T4
	MOVEI	F,DSKDDB	;SET F FOR PROTOTYPE DDB
	PUSHJ	P,ALIASD	;IS NAME AN ALIAS FOR "DSK"?
	  POPJ	P,		;YES. NON-SKIP RETURN
	CAMN T1,[SIXBIT /DSKB/]	;CHECK FOR STR NAME
	POPJ P,
	PUSHJ	P,SRUNI		;IS USER SUPPLYING A UNIT NAME?
	  JRST	CPOPJ1		;NOT A DISK - SKIP RETURN
	  JFCL			;PHYSICAL DSK NAME
	HRRZ	T3,UNISTR(U)	;YES, SET T3 TO STR DB LOC
	JUMPN	T3,CPOPJ	;JOB MUST BE PRIVILEGED IF UNIT NOT IN AN STR
	MOVSI T3,LICSTR
	TDNN T3,JBTLIC(J)	;SPECIAL FOR LICENSED JOB
	AOS (P)		;NO, ERROR RETURN
	POPJ P,		;YES, OK RETURN
;SUBROUTINE TO CLEAN UP THE ACCESS TABLES FOR A JOB AFTER A SWAP-READ ERROR
;SCANS THE DDB'S, WHEN IT FINDS ONE FOR THE JOB IT FIXES IT-
; DECREMENTS THE READ-COUNT IF READING, CLEARS THE STATUS BYTE IF WRITING
; AND INCREMENTS THE QUOTA IF CREATE OR SUPERSEDE
;IT EXITS BY RETURNING ANY SYSTEM RESOURCES THE JOB MIGHT HAVE
SWPCLN:	MOVEI	F,DSKDDB	;START AT PROTOTYPE DDB
	JSP T4,SAVE4	;SAVE SOME TEP ACS TO WORK IN (FOR CALLS)
SWPCL1:	HLRZ	F,DEVSER(F)	;LINK TO NEXT DDB
	JUMPE	F,CPOPJ		;DONE IF 0
	MOVE	T1,DEVMOD(F)
	TLNN	T1,DVDSK	;IS THIS DDB A DISK?
	POPJ P,			;NO, THROUGH
	LDB	T1,PJOBN	;YES, SAME JOB?
	CAME	T1,J
	JRST	SWPCL1		;NO, TRY NEXT DDB
	SKIPN P2,DEVATB(F)
	JRST SWPCL1
	HLRZ P4,P2	;DRB POINTER
	HRRZ P3,ATBFNB(P2)
	HRRZS P2
	LDB T1,DEYSTC	;WHAT WERE WE DOING
	MOVEI T2,0
	DPB T2,DEYSTC
	XCT .+1(T1)
	PHASE 0
	JRST SWPCL1
DECLUK:!	JRST SWPLUK
DECUPD:!	JRST SWPUPD
DECUP2:!	JRST SWPUP2	;WAS UPDATING BUT INPUT CLOSED
DECENT:!	JRST SWPENT	;FOR SUPERCEDE OR RENAME
DECSTP:!	STOPCD(SLO)	;IN THE MIDDLE OF A UUO
	DEPHASE

SWPENT:	MOVE T1,ATBALP(P2)	;NUMBER OF PAGES ALLOCATED
	ADDM T1,DRBALC(P4)	;RETURN TO HIS QUOTA
	PUSHJ P,FREATB	;RETURN ATB TO FREE STORAGE
	JRST SWPLK1	;AND RESET A FEW THINGS

SWPUPD:	MOVEI T1,ATPUPD
	ANDCAM T1,ATBSTS(P2)
	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	STOPCD(SLO)
SWPLUK:	SOS T1,ATBCNT(P2)
SWPLK2:	TRNN T1,ATMCNT!ATPUPD!ATPREN
	PUSHJ P,LKDATB	;MAKE DORMANT IF NOT IN USE
SWPLK1:	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	STOPCD(SLO)
	SETZM DEVATB(F)
	PUSHJ P,ULKDBL
	JRST SWPCL1

SWPUP2:	MOVSI T1,ATPUPD
	ANDCAB T1,ATBSTS(P2)
	JRST SWPLK2

INTERNAL SWPCLN
;UGETF

COMMENT ! ROUTINE DSKUGF -- UGETF FOR DSK FILE.
FUNCTION: RETURN TO USER LOC/ CURRENT POSITION,,FILE SIZE UNLESS
	EITHER VALUE EXCEEDS 18 BITS OR NO LOOKUP/ENTER DONE
	(IN WHICH CASES -1).
EXPECTS: M/ USER DATA LOCN ADDR
	F/ DDB
	W/ CHANNEL
!
DSKUGF:	PUSHJ P,WAIT1
	MOVNI T1,1		;READY FOR ERROR RETURN
	HRRZ T2,DEVATB(F)
	JUMPE T2,DSKUG1	;NO LOOKUP/ENTER, ERROR
	LDB	T1,ATYBSZ
	TLNE	T1,-1
	JRST	DSKUG2
	MOVE	T2,DEVPOS(F)
	TLNE	T2,377777	;DONT TEST USETI/O FLAG 1B0
	JRST	DSKUG2
	HRLI	T1,(T2)
DSKUG1:	UMOVEM T1,(M)		;RETURN TO USER
	POPJ P,
DSKUG2:	MOVNI	T1,1
	JRST	DSKUG1
; CALLED FROM COMMON IN CRASH CODE.
DSKSTP:	POPJ	P,

;HERE ON A LOGOUT, WHEN THERE ARE NO OTHER JOBS LOGGED IN UNDER THIS PPB
;CALLED BY LOGOUT , WITH AC=PPN  (DSKLGO M)
DSKLGO:	CAME	T1,SYSPPN	;YES. IS JBTPPN FOR SYS?
	CAMN	T1,MFDPPN	; OR AN MFD?
	POPJ	P,		;YES, DONT DELETE  CORE BLOCKS
	PUSHJ P,GETCBR
	HLRZ	T2,SYSDRB	;NO. SET TO SEARCH DRB'S
	MOVNI T3,1		;DO NOT CREATE A NEW ONE
	PUSHJ	P,SRCNAM	;FIND PPB FOR THIS JOB
	JUMPE T2,GIVCBR
	MOVEI	T1,DRPLOG	;FOUND - SET NLG
	ANDCAM	T1,DRBLOG(T2)	; IN PPB BLOCK
	PJRSCBR
INTERNAL DSKCLR
EXTERNAL ADJMWS

;CODE TO CLEAR CORE INFO (CALLED BY DSKFIXER)

DSKCTB:	JRST	DSKCL2		;0  CLEAR IN-CORE DISK INFO
	JRST	DSKCL3		;1  SET STTFPC FOR ALL SATS
	JRST	DSKCL4		;2  CLEAR SRPNDS ONLY
DCTBSZ==.-DSKCTB

DSKCLR:	MOVE T1,JBTLIC(J)
	TLC T1,LICWFL+LICWPJ
	TLCE T1,LICWFL+LICWPJ	;DOES HE HAVE WRITE ABSOLUTE??
	JRST CPOPJ1
	LDB	T1,[POINT 4,M,^D12] ;GET AC FIELD.
	CAIL	T1,DCTBSZ	;IS VALUE TOO LARGE?
	JRST	CPOPJ1		;YES
	XCT	DSKCTB(T1)	;DISPATCH
DSKCL4:	MOVEI	T1,SRPNDS	;CLEAR THE NEED DSKCLN FLAG
	ANDCAM	T1,STRDDB+STRBTS	; FOR THIS STRUCTURE
	SETOM	ADJMWS		;TURN MWS ADJUST
	POPJ	P,
DSKCL3:	MOVE	T1,PDNMUP(P)	;GET RETURN ADDR
	AOS	PDNMUP(P)	;INC PAST ARG
	UMOVE	T1,(T1)		;GET AOBJN WORD ADDR
	PUSHJ	P, FPCSET	;SET FREE PGS
	SOS	0(P)
	SETOM	ADJMWS		;TURN ON MWS ADJUST
	JRST	CPOPJ1
DSKCL2:	PUSHJ	P,PCBCLR	;ZAP ALL SAT AND RIB PCBS.
	 POPJ P,		;PCB I/O IN PROGRESS
	 JRST CPOPJ1	;CAN NOT CLEAR PCBS
	AOS %UPT+UPTPDL	;FOR MULTIPLE SKIP RETURN TO USER
	PUSHJ P,GETCBR
	HLRZ P4,SYSDRB		;ALL DRB BLOCKS
	JUMPE P4,GIVCB1		;SKIP RETURN, ALL DONE
DSKCL1:	LDB T1,DRYCNT		;GET COUNT
	JUMPN T1,GIVCBR		;DRB IN USE, ERROR
	HLRZ P3,DRBFNB(P4)	;NOW THE NAME BLOCK
	JUMPE P3,DSKCL7		;ALL DONE, GIVE BACK DRB
DSKCL6:	HLRZ P2,FNBATB(P3)	;FOR FOR THE ACCESS TABLE
	JUMPE P2,DSKCL5		;NONE THERE, GIVE BACK FNB
	PUSHJ P,RMVATB		;GET RID OF ATB (DRBCNT=0 SO OK)
	JRST DSKCL6

DSKCL5:	MOVE T1,SYSCOR
	EXCH T1,CMBLNK(P3)	;THIS POINTS TO NEXT FNB (MAYBE)
	HRLZM P3,SYSCOR		;NOW FNB RETURNED
	HLLM T1,DRBFNB(P4)	;SO LINK FROM DRB OK
	HLRZ P3,T1	;NEXT LINK
	JUMPN P3,DSKCL6

DSKCL7:	MOVE T1,SYSCOR	;NOW GIVE BACK DRB
	EXCH T1,CMBLNK(P4)
	HRLZM P4,SYSCOR
	HLLZM T1,SYSDRB	;RELINK START
	HLRZ P4,T1
	JUMPN P4,DSKCL1
	JRST GIVCB1
EXTERN USETST,UNLFIL,LOKUNM,RELRIB,IOBDRB

UFDUUO:	TLNN F,LOOKB
	POPJ P,
	HRRZ P2,DEVATB(F)	;MUST HAVE A UFD LOOKED UP
	MOVEI T1,ATPDIR
	TDNN T1,ATBSTS(P2)
	POPJ P,
	NOCHARGE
	UMOVE P4,1(M)	;NAME
	XCTBU <HLLZ P2,2(M)>	;EXTENSION
	XCTBU <SETZM 7(M)>	;ZERO COUNT
	;SETZM P3,P1	;NO MASK YET
	SETZB P3,P1	;NO MASK YET. AAA. PREV INSTR WRONG I THINK
	XCTBU <SKIPGE 3(M)>	;CHECK TO SEE IF WANT * AND #
	JRST UFDNMK		;NO
	EXCH P2,P4
	PUSHJ P,UFDMSK
	EXCH P2,P4
	MOVE P3,P1	;GET MASK
	PUSHJ P,UFDMSK
UFDNMK:	HLRZS P2
	HLRZS P1
	HRL P1,M	;P1/USER ADDR,,MASK
	XCTBU <SKIPN T1,4(M)>	;MONITOR WORD IS ZERO?
	JRST [	;SET UP INITIAL HASH LINK
		JUMPN P3,UFDNXM	;NOT ONE SPECIFIC NAME
		MOVE T1,P4
		TLZ T1,(1B0)
		HRRZ T2,STRDDB+STRHSH
		IDIV T1,T2
		MOVE T1,T2
		JRST UFDNXM]
;; P4/ NAME, P2/0,,EXT  P3/?  P1/USERADDR,,MASK  T1/HASH LINK
UFDNXM:	HRL P2,T1		;P2/HASH LINK,,FILE EXT
	TRZ T1,400000
	AOSG M,T1	;M/PAGE IN UFD
	POPJ P,		;PG 0 OR <0 BAD OR END
	PUSHJ P,LOKUNM	;LOCK(UNMODIFIABLE) F/UFD DDB
			;DESTROY NO ACS
	HRRZ T2,DEVATB(F)
	LDB T1,ATYBSZ	;SIZE OF UFD, IN BLOCKS
	ADDI T1,3
	LSH T1,-2	;T1/SIZE UFD, IN PAGES
	CAMGE T1,M	;SKIP IF PAGE IN M AT OR BEFORE EOF
	JRST [PUSHJ P,UNLFIL	;PAST EOF,UNLOCK
		TDO S,[IOEND,,IODEND]
		PJRST STOIOS]	;SET IN DEVIOS & NOSKIP RTN
	PUSHJ P,USETST	;GET @DEVRET(F) SETUP FOR
			;M/PAGE. CLOB T1-T4,U,PG. SKIP SUCCESS
	JRST	[TRO S,IODTER
		PJRST STOIOS]		;NOSKIP RTN
	PUSHJ P,UNLFIL	;UNLOCK,DESTROY NO ACS
	PUSHJ P,RELRIB	;RELEASE RIB IN %RIB, CLOB T1-T4,PG
	TRNE S,760000	;ANY ERRORS?
	POPJ P,		;
	HLRZ M,P1	;M/USER CONTROL BLOCK ADDR AGAIN
	MOVE T1,@DEVRET(F)
	TLNN T1,RBREAL
	JRST UFDSPR	;HOLE.
	MOVEI PG,%RIB.C
	PUSHJ P,MAPRDU	;READ IT
	LDB J,PJOBN
	MOVEI T2,UFDRLK
	MOVEM T2,JBTABT(J)
	PUSHJ	P,GTCGSZ	;GET T1/ CHARGING SIZE.
	ADDM T1,JBTSIN
	ADDM T1,JBTSIN(J)
	AOS JBTRCT
	AOS JBTRCT(J)
	MOVSI T2,-<1000/UFDSIZ>	;NUMBER OF ENTRIES TO SEARCH
	JUMPGE P2,UFDSFD	;DO NOT SEARCH FOR NAME, NEW BLK
	UMOVE T3,5(M)	;NAME TO SEARCH FOR
	XCTBU <HLRZ T4,6(M)>
UFDSLP:	CAME T3,%RIB+UFDNAM(T2)
	JRST UFDNSL	;NOT THIS ONE, CONTINUE
	HLRZ T1,%RIB+UFDEXT(T2)
	CAMN T1,T4
	JRST UFDSF0	;FOUND IT
UFDNSL:	ADDI T2,UFDSIZ-1
	AOBJN T2,UFDSLP
	JRST UFDRLK	;GIVE UP AND ERROR RETURN IF NOT FOUND

UFDSF0:	ADDI T2,UFDSIZ-1
	AOBJP T2,FINUS0	;FINISHED
UFDSFD:	PUSH P,P4
	PUSH P,P3
	UMOVE T4,(M)	;GET AOBJN POINTER
	JUMPGE T4,[POP P,P3	;ERROR IF NONE TO RETURN
		POP P,P4
		JRST UFDRLK]
UFDLLP:	SKIPN T1,%RIB+UFDNAM(T2)
	JRST UFDLCN
	ANDCM T1,(P)
	CAME T1,-1(P)
	JRST UFDLCN	;NOT THIS ONE
	HLRZ T1,%RIB+UFDEXT(T2)
	ANDCM T1,P1
	CAIE T1,(P2)
	JRST UFDLCN
	DMOVE P3,%RIB+UFDNAM(T2)
	AOBJP T4,FINSUP
	HLLZS P4
	XCTBU <DMOVEM P3,-1(T4)>
	UMOVE T3,3(M)
	TLNN T3,(1B1)
	JRST UFNBLK	;NO BLOCKS
	AOBJP T4,FINSUP
	HLRZ T1,%RIB+UFDALP(T2)
	TRNE T1,400000
	TLOA T1,-1
	LSH T1,2	;CONVERT TO BLOCKS, NEG IF UNKNOWN
	UMOVEM T1,(T4)
UFNBLK:	TLNN T3,(1B2)
	JRST UFNLIC	;NO LICENSE
	AOBJP T4,FINSUP
	HRRZ T1,%RIB+UFDLIC(T2)
	UMOVEM T1,(T4)
UFNLIC:	TLNN T3,(1B3)
	JRST UFNDAT
	AOBJP T4,FINSUP
	LDB P4,UFYCDT
	LDB P3,UFYXCD
	DPB P3,[POINT 2,P4,23]
	LDB P3,UFYCTM
	TLNN T3,200	;DOES HE WANT TIME AND DATE CONVERSION
	JRST UFNNCV
	IMUL P3,JFYSEC
	PUSH P,T2
	DMOVE T1,P3
	MOVS P4,T3
	ANDI P4,177
	TRZE P4,100
	TRO P4,400000
	HRLI P4,400020	;FROM GMT
	PUSH P,T3
	PUSHJ P,DATCOM
	 JFCL
	EXCH T1,T2
	IDIV T2,JFYSEC	;RECONVERT
	HRLM T2,T1
	POP P,T3
	POP P,T2
	XCTBU <MOVSM T1,(T4)>	;STORE CONVERTED
	JRST UFNDAT
UFNNCV:	HRLM P4,P3
	UMOVEM P3,(T4)
UFNDAT:	TLNN T3,(1B4)
	JRST UFNSTS
	AOBJP T4,FINSUP
	LDB P4,UFYPRV
	LDB T1,UFYUF2
	DPB T1,[POINT 8,P4,26]
	LDB T1,UFYUF1
	DPB T1,[POINT 4,P4,18]
	UMOVEM P4,(T4)
UFNSTS:	HRL P1,T2	;SAVE LOCATION
	XCTBU <AOS 7(M)>
	AOBJP T4,FINSUP
UFDLCN:	ADDI T2,UFDSIZ-1
	AOBJN T2,UFDLLP
	POP P,P3
	POP P,P4
	XCTBU <SKIPN 7(M)>
	JRST FINUS0
	JUMPN P3,[HLRZ T1,P2
		AOJA T1,FINNXB]
	SKIPN T1,%RIB+UFDLNK
	MOVEI T1,377777
	JRST FINNXB


UFDSP1:	PUSHJ P,RELLOK
	LDB	T1,PJOBN
	SETZM	JBTABT(T1)
UFDSPR:	JUMPE P3,UFDEOF	;SPECIFIC NAME, ONLY ONE HASH CODE
	HLRZ T1,P2
	TRZ T1,400000
	AOJA T1,UFDNXM

FINSUP:	POP P,P3
	POP P,P4
	XCTBU <SKIPN 7(M)>
	JRST UFDRLK	;ERROR IF NONE FOUND
	HLRZ T4,P1
	DMOVE T1,%RIB+UFDNAM(T4)	;GET LAST NAME STORED
	HLLZS T2
	XCTBU <DMOVEM T1,5(M)>
	HLRZ T1,P2
	TROA T1,400000	;SEARC THIS AGAIN
FINNXB:	TRZ T1,400000
	UMOVEM T1,4(M)
	AOS (P)
	JRST UFDRLK	;DONE

UFDEOF:	TDO S,[IOEND,IODEND]
	MOVEM S,DEVIOS(F)
	POPJ P,

UFDRLK:	LDB T1,PJOBN
	SETZM JBTABT(T1)
	PJRST RELLOK

FINUS0:	SKIPN T1,%RIB+UFDLNK
	JRST UFDSP1	;NO LINK, EOF IF SPECIAL NAME, ELSE NEXT
	JUMPN P3,UFDSP1	;LINK AND NOT SPECIAL
	PUSH P,T1
	PUSHJ P,RELLOK
	LDB	T1,PJOBN
	SETZM	JBTABT(T1)
	POP P,T1
	JRST UFDNXM
UFDMSK:	CAMN P2,[SIXBIT /*/]
	JRST	[MOVNI P1,1
		MOVEI P2,0
		POPJ P,]
	MOVE T2,P2
	XOR T2,[SIXBIT /######/]
	MOVEI P1,0
	MOVSI T1,770000
UFDMS0:	TDNN T2,T1
	TDO P1,T1
	LSH T1,-6
	JUMPN T1,UFDMS0
	ANDCM P2,P1	;GET RID OF #'S
	POPJ P,
;UUO TO SET PID TO NEW VALUE
; CALL:
;	MOVE	AC,[PID]
;	PIDSET	AC,
;	  <ERROR RETURN>	;NOT AUTHORIZED TO SET PID
;	<SUCCESS RETURN>
SETPID::JUMPE	T1,SETPIO	;ZERO ALWAYS OK
	LDB	T2,JBYWPT	;IF WF, CAN SET PID TO ANYTHING.
	CAILE	T2,1		;SKIP IF WP OR LESS
	JRST	SETPIO		;OK TO SET ANY PID IF WF OR WA.
	MOVS	T2,JBTAUN(J)	;GET UUN IN LH
	XOR	T2,T1		;LH = 0 IF ALL BITS MATCH
	TLNN	T2,-1		;SKIP IF MATCH ON AUN
	JRST	SETPIO		;OK, SAVE OLD PID AND SET NEW ONE
	CAMN	T1,%UPT+UPTSPD	;SETTING BACK TO LAST VALUE?
	JRST	SETPIO		;YES, THAT'S OK
	CAMN	T1,%UPT+UPTPID	;NOT CHANGING?
	AOS	(P)		;NOT CHANGING, DON'T BOTHER WITH UPTSPD
	MOVE	T1,%UPT+UPTPID	;GET CURRENT PID
	UMOVEM	T1,(M)		;RETURN "OLD" PID (SAME AS NEW)
	POPJ	P,		;NOT AUTHORIZED TO SET THIS PID

SETPIO:	EXCH	T1,%UPT+UPTPID	;SET NEW PID, GET OLD ONE
	SKIPE	T1		;DON'T SET SAVED PID TO ZERO, SO IF
				; JOB HAS PID, SETS IT TO ZERO, SETS IT
				; TO ANOTHER PID, DOESN'T LOSE ABILITY
				; TO RESET TO ORIGINAL PID.
	MOVEM	T1,%UPT+UPTSPD	;REMEMBER WHAT LAST ONE WAS SO CAN RESTORE IT.
	UMOVEM	T1,(M)		;RETURN OLD PID VALUE
	JRST	CPOPJ1
;SUBROUTINE TO BUILD A DISK DEVICE DATA BLOCK
;ENTER WITH T1=DEVICE NAME, F=LOC OF DDB (OR PROTOTYPE DDB)
;CALLED BY ASSPRG
;HERE FROM ONCE-ONLY CODE
INTERN SETDDO
SETDDO:	PUSH	P,DSKDDB	;SAVE NAME
	JRST	SETDD3		;GO CREATE THE DDB

;THIS IS THE NORMAL ENTRY POINT
SETDDB:	PUSHJ	P,SAVT		;SAVE T2-T4
	HRRZ	T3,F		;ADDR. OF THE DDB
	CAIE	T3,DSKDDB	;IS IT THE PROTOTYPE?
	MOVE	T1,DEVNAM(F)	;NO. GET THE PHYSICAL DEVICE NAME
	PUSH	P,T1		;SAVE NAME
	MOVE	T1,DEVMOD(F)
	TRNE	T1,ASSPRG	;DDB BEEN INITED?
	JRST	SETDD1		;YES. HAVE TO COPY PROTOTYPE
	CAIE	T3,DSKDDB	;IS IT PROTOTYPE?
	JRST	SETDD2		;NO. USE IT

;HERE WHEN WE MUST MAKE A COPY OF THE PROTOTYPE DDB
SETDD1:	MOVEI	T2,DDBCOR	;NO OF 4-WORD BLOCKS NEEDED
	PUSHJ	P,GET4WD	;GET THE CORE
	  JRST	TPOPJ		;CANT GET IT - RETURN
SETDD3:	HRR	F,T1		;LOC OF THE CORE
	HRLI	T1,DSKDDB	;FROM THE PROTOTYPE
	BLT	T1,DDBLEN-1(F)	;BLT THE NEEDED INFORMATION
	HRLM	F,DSKDDB+DEVSER	;LINK PROTOTYPE TO THEIS DDB
				;(COPY ALREADY CONTAINS LINK TO NEXT)
	MOVEI	T1,ASSCON+ASSPRG	;MAKE SURE ASSIGN BITS ARE OFF
	ANDCAM	T1,DEVMOD(F)	;(1 WILL BE TURNED ON BY ASSPRG)

SETDD4:	POP	P,DEVNAM(F)	;SET NAME INTO DDB
	JRST CPOPJ1		;SUCCESS RETURN

SETDD2:	MOVEI T1,DEVLOG+1(F)	;MAKE SURE DDB PROPERLY INITED
	HRLI T1,DSKDDB+DEVLOG+1	;BUT SKIP STUFF BEFORE THIS
	BLT T1,DEVRB1-1(F)
	SETZM DEVIOS(F)		;EXCEPT FOR DEVIOS
	JRST SETDD4
;SUBROUTINE TO CLEAR A DISK DEVICE DATA BLOCK
;ENTER WITH F=LOC OF DDB
;CALLED BY RELEASE CODE AND ONCDSK AT ONCE TIME

CLRDDB:
	;PUSHJ P,IOLDEL		;NO IOLIST TO DELETE IN VM SYSTEM

	MOVEI	T1,DSKDDB	;START AT PROTOTYPE
CLRDD1:	MOVE	T2,T1
	HLRZ	T1,DEVSER(T2)	;GET SUCCESSOR TO THIS DDB
	SKIPN	T1		;END?
	STOPCD(SLO)		;YES. ERROR
	CAIE	T1,(F)		;NO. IS LINK THE ONE WE WANT?
	JRST	CLRDD1		;NO. TRY NEXT

;HERE WITH T2=LOC OF DDB WHOSE LINK IS THE ONE WE WANT
	MOVE	T3,DEVSER(F)	;LINK OF DDB WE ARE REMOVING
	HLLM	T3,DEVSER(T2)	;SAVE IN LINK OF PREDECESSOR
	MOVEI	T1,DDBCOR	;NO OF 4-WORD BLOCKS TO RETURN
	HRRZ	T2,F		;LOC OF DDB TO CLEAR
	SKIPE	ONCTIM		;SKIP IF AT ONCE TIME
	PJRST	GIV4WD		;RETURN THE CORE AND RETURN TO CALLER
	POPJ 	P,

	INTERN	NAMSTR
;SUBROUTINE TO RETURN THE ACTUAL STR NAME FOR A DDB
;ENTER WITH F=LOC OF DDB
;EXIT CPOPJ IF NOT A DISK OR NO UNIT ASSOCIATED WITH DDB (LOOKUP NOT DONE)
;EXIT CPOPJ1 IF A DISK, WITH T1=NAME OF STR

NAMSTR:	MOVE	T1,DEVMOD(F)	;IS DEVICE A DISK?
	TLNN	T1,DVDSK
	POPJ P,
	MOVE T1,[SIXBIT /DSKB/]
	PJRST	CPOPJ1		;SKIP-RETURN
SUBTTL	COMCON - COMMAND DECODER INTERFACE ROUTINES

;SUBROUTINE TO PERFORM "DISK" COMMAND - PRINT DISK ACCESSES
;CALL:	MOVE	J,JOB NO.
;	PUSHJ	P,DSKCOM	;CALLED FROM COMCON - COMMAND DECODER
;	ALWAYS RETURN
;PRINTS INCREMENTAL READS AND WRITES, TOTAL READS AND WRITES
;TOTAL BLOCKS ALLOCATED, AND KILO-DISK-MIN FOR ALL STRS COMBINED

	INTERN	DSKCOM
EXTERN	DECIN,COMERA,ATT1,CRLF,JBTRCT,JBTWCT,JBYRCT,RADX10,JBTSIN
	EXTERN	JBYWCT,INLMES,JOBN,CHKSGJ

DSKCOM:	PUSHJ	P,DECIN		;GET DECIMAL JOB NO. ARG IF ANY
	  JRST	DSKCM1		;NO ARG, ASSUME USER'S OWN JOB(AC [=J)
	  JRST	COMERA		;BAD CHARACTER, PRINT ERROR
	CAIL	T2,JOBN		;JOB NUMBER TO LARGE?
	JRST	ATT1		;YES, PRINT NOT A JOB NO.
	EXCH	J,T2		;NO, SETUP JOB NUMBER
	PUSHJ P,CHKSGJ		;SEE IF HE CAN HAVE THAT INFO
	  JRST	[MOVE J,T2	;No - restore caller's frame number
		 JRST COMERA]	;And take common command error exit.
	PUSH P,T2		;SAVE JOB NUM (IN CASE DSK 0)
	PUSHJ P,DSKCM2
	POP P,J
	POPJ P,

;HERE WHEN USER DID NOT SPECIFY A JOB NUMBER - SO DO HIS WITH INCREMENTAL
DSKCM1:	PUSHJ	P,INLMES	;NO, PRINT MESSAGE
	ASCIZ	/RD,WT=/
	PUSHJ	P,DSKINC	;PRINT INCREMENTAL DISK READS
	PUSHJ	P,INLMES	;COMMA
	ASCIZ	/,/
	PUSHJ	P,PRTWDW	;PRINT NO OF INCREMENTAL DISK WRITES
	PUSHJ	P,CRLF		;PRINT CRLF
;HERE TO PRINT DATA FOR ANOTHER JOB(IE DO NOT PRINT INCREMENTAL)
DSKCM2:	PUSHJ	P,INLMES	;PRINT HEADING
	ASCIZ	/RD,WT=/
	LDB	T1,JBYRCT	;TOTAL NO. OF READS FOR JOB SINCE LOG-IN
	PUSHJ	P,RADX10	;PRINT DECIMAL
	PUSHJ	P,INLMES	;PRINT COMMA
	ASCIZ	/,/
	ADDI	J,JBTWCT-JBTRCT	;INCREASE JOB NO. BY DIFF. IN TABLE ORIGINS
	LDB	T1,JBYWCT	;TOTAL NO. OF WRITES FOR JOB SINCE LOGIN
	PUSHJ	P,RADX10	;PRINT DECIMAL
	MOVEI	J,JBTRCT-JBTWCT(J)	;RESTORE J TO ORIGINAL JOB NO. (ELSE COMCON CONFUSED)
	PJRST	CRLF		;PRINT CRLF AND RETURN

;SUBROUTINE TO PRINT NO OF DISK WRITES (RESULT OF WATCH COMMAND)
;CALL:	MOVE J,JOB NO [J=J]
;	PUSHJ P,PRTWDW
PRTWDW:	ADDI	J,JBTWCT-JBTRCT	;INCREASE JOB NO BY DIFF IN READ/WRITE TABLE ORIGINS
	PUSHJ	P,DSKINC	;PRINT INCREMENTAL DISK WRITES
	MOVEI	J,JBTRCT-JBTWCT(J)	;@ECREASE JOB NO BY DIFF IN TABLE ORIGINS
	POPJ	P,

;SUBROUTINE TO PRINT INCREMENTAL NO. OF BLOCKS READ OR WRITTEN
;CALL:	MOVE	J,JOB NO.(J=J)
;	PUSHJ	P,DSKINC
;	ALWAYS RETURN

	EXTERN	JBYIRD,JBRIRD

PRTWDR:				;PRINT INCREMENTAL NO OF BLOCKS READ
DSKINC:	LDB	T1,JBYRCT	;TOTAL NO OF READS(OR WRITES) FOR JOB
	LDB	T2,JBYIRD	;INCREMENTAL SETTING(LOW ORDER N BITS
				; OR TOTAL NO.)
	DPB	T1,JBYIRD	;UPDATE INCREMENTAL SETTING WITH CURRENT TOTAL
	SUB	T1,T2		;DIFFERENCE CUR TOTAL-LAST TOTAL
	ANDI	T1,JBRIRD	;MASK OUT ALL BITS OUTSIDE INCREMENTAL FIELD
	PJRST	RADX10		;PRINT DECIMAL AND RETURN
;COMMAND TO PRINT FILE STRUCTURES IN SYSTEM, AND UNITS NOT IN STRUCTURES
; (RESOURCES COMMAND)
DSKRES==CPOPJ		;FOR NOW

;SUBROUTINE TO CLEAN UP CORE ON A KJOB COMMAND
;CALLED AT CLOCK LEVEL IF NO CORE, M LEVEL IF CORE WHEN JOB IS KILLED
;CALL	MOVE J,JOB NUMBER
;	PUSHJ P,DSKKJB
DSKKJB:	MOVE	T1,JBTPPN(J)	;PPN OF JOB
	MOVE	T2,HIGHJB	;CHECK FOR OTHER JOBS WITH SAME PPN
DSKKLP:	CAIN	T2,(J)		;IS NEXT JOB=CURRENT JOB?
	SOJLE	T2,DSKLGO	;YES, DONT TEST PPN'S
	CAMN	T1,JBTPPN(T2)	;NO. IS ANOTHER JOB LOGGED IN UNDER SAME NUMBER?
	POPJ P,
	SOJG	T2,DSKKLP	;NO, KEEP LOOKING
	PJRST DSKLGO

INTERN CHGPPN
CHGPPN:	MOVSI T2,LICJAL
	TDNN T2,JBTLIC(J)
	POPJ P,
	PUSH P,T1
	PUSHJ P,DSKKJB	;GET RID OF OLD PPN
	POP P,JBTPPN(J)
	JRST CPOPJ1	;FINISHED
SUBTTL	CLOSE
;WHEN RENAME CALLS CLOSE, IT MAY ALREADY HAVE THE MONITOR BUFFER, AND THE RIB
;MAY BE IN IT. IF SO, DEPRIB IS ON IN S

;INPUT CLOSE
CLOSIN:	TLZN	F,LOOKB		;LOOKUP IN FORCE?
	PJRST	STOIOS		;NO. RETURN
	NOCHARGE
	TLNN F,ENTRB		;IF OUTPUT STILL OPEN, DON'T WIPE OUT UPTPOS.
	PUSHJ P,SIMRLS		;CLEAN UP SIMIO DATA BASE
	MOVEI T1,DECSTP
	DPB T1,DEYSTC	;IN CASE OF ERROR HERE
	PUSHJ P,GETCBR
	HRRZ P2,DEVATB(F)	;% CHECK ON STATUS OF FILE
	HLRZ P4,DEVDRB(F)
	SKIPE P2
	SKIPN P4
	STOPCD(SLO)
	MOVE T1,ATBSTS(P2)
	TRNE T1,ATPREN		;% IF RENAME ON, THE ONE WHO TURNS
	JRST CLSXT1		;% IT OFF WILL WORRY ABOUT READ COUNT=0
	PUSHJ P,TSTRES	;% MAKE SURE WE GIVE UP RESOURCES(UNLESS RENAME)
CLOSRN:	TRNN T1,ATMCNT-1	;% IS HE THE LAST READER?
	TRNN	T1,ATPDEL	;% FILE MARKED FOR DELETION?
	JRST	CLSIN2		;% NO
CLIDEL:	PUSHJ P,GIVCBR
	PUSHJ P,RIBWTL		;GET RIB WRITE LOCKED
	  JRST CLIBDR		;BAD RIB, FIX QUOTAS AND GO TO FREACC.
	PUSHJ	P,DLTALL	;I CAN'T BELIEVE I ATE THE WHOLE THING.
	 JFCL			;IGNORE ERROR RETURN
				;DON'T TRY TO ADJUST QUOTAS, GIVPAG SUBTRACTS AS IT GOES ALONG.
	SETZM	ATBRIB(P2)	;IN CASE THE FILE IS STILL MAPPED,
				; TELLS REMOVE THAT RIB WENT AWAY.
	PUSHJ	P,LOGTST	;RECOMPUTE RIBUSD IF PPN NOT LOGGED IN

;HERE WHEN THE FILE NAME WAS NOT FOUND IN THE UFD.
; ALSO COME HERE FROM DELETE CODE WHEN RIB ERROR OCCURS, ATBRIB CAN BE ZERO!
FREACC:	TLZ	F,RENMB!ENTRB		;TURN OFF RENMB SO CLOSE OUTPUT WONT DO ANYTHING
	PUSHJ P,GETCBR
	HRRZ P3,ATBFNB(P2)	;% FOR DELETING FNB
	PUSHJ P,ULKDBL		;% AND REMOVE DDB
	MOVNI	T1,ATPCNT	;% ONE LESS READER OF FILE
	ADDB	T1,ATBSTS(P2)	;% AND GET ATBSTS IN T1
	TLNN	T1,ATMUMC	;% ANYONE STILL HAVE A PAGE MAPPED?
	PJRST CLSN3A		;% NO, DELETE PPB ETC. IF NECESSARY
	PJRST CLSIN5		;% YES, JUST ZERO DEVATB AND LEAVE AT ALONE

;HERE IF BAD RIB TRYING TO DELETE ATPDEL FILE OR BAD RIB IN DELETE
; CODE

CLIBDR:	MOVE	T1,ATBALP(P2) ;TRY TO ADJUST QUOTAS PROPERLY
	ADD	T1,DRBALC(P4)  ;GET PROPER VALUE - AS IF WE DELETED THE PAGES
	SKIPL	DRBALC(P4)	;IF NEGATIVE, REPLACE ANYWAY
	SKIPL	T1		;DON'T DECREASE
	MOVEM	T1,DRBALC(P4)	;STORE NEW DRBALC
	PUSHJ	P,LOGTST	;IF DIRECTORY NOT CONNECTED TO, RECOMPUTE RIBUSD AND RIBMXA
	JRST	FREACC		;AND GO GET RID OF ATB IF WE CAN.
;HERE WHEN FILE IS NOT MARKED FOR DELETION
CLSIN2:	TRNN	M,CLSOUT	;% SUPPRESSING OUTPUT CLOSE?
	TLNN	F,ENTRB+RENMB	;% NO, ENTER OR RENAME DONE?(IF SO, CLSOUT WILL BE CALLED)
	SKIPA
	JRST CLSXIT		;% YES. RETURN
	MOVE	T1,JBTLIC(J)	;% GET PROCESS LIC
	TRNE	M,CLSDMP	;% SET DUMPED BIT?
	TLNN	T1,LICJAL+LICWFL	;% APPROPRIATE LIC?
	JRST	CLSIN7		;% NO
	MOVSI	T1,ATPDMP
	IORM	T1,ATBLCW(P2)	;% SET DUMPED BIT
	PUSHJ	P,UPDUF0	;% UPDATE THE UFD
	PUSHJ	P,GETCBR	;GET CB BACK
	JRST	CLSIN8		;UPDATE RIB
CLSIN7:	TRNE	M,CLSACC	;% SUPPRESS UPDATING ACCESS DATE?
	JRST	CLSIN3		;% YES, DONT WRITE RIB

;NOW CLEAR ATPALC IF ITS OK TO. IF CLSACC ON, TRY TO GUARANTEE
; THAT WE DON'T WRITE ANY DISK ON INPUT CLOSE - THUS THIS CALL
; IS AFTER CHECK ON CLSACC.

CLSIN8:	MOVE	T1,ATBLCW(P2)	;% GET LIC WORD
	TLNE	T1,ATPALC	;% IF THIS BIT IS SET,
	 PUSHJ	P,CLRACH	;% TRY TO CLEAR IT.
	LDB	T4,ATYADT	;% GET CURRENT ACCESS DATE FOR BELOW
	MOVE	T1,ATBLCW(P2)	;% GET NEW LIC WORD
	TLNE	T1,ATPALC	;% IF ATPALC HAS CHANGED (WENT OFF)
	TLNE	T1,ATPDMP	;%  OR ATPDMP IS SET
	 JRST	CLSN2B		;%  THEN ALWAYS UPDATE RIB
	CAME	T4,THSDAT	;% IS ACCESS DATE=TODAY?
	 TLNN	F,INPB!MAPB	;% DATE NEQ TODAY, ANY INPUTS DONE?
	  JRST	CLSIN3		;% NO NEED TO UPDATE ACCESS DATE, JUST SET A.T. DORMANT
CLSN2B: TLNE	F,INPB!MAPB	;% IN CASE FORCING RIB OUT DUE TO ATPALC
	 MOVE	T4,THSDAT	;% SET ACCESS DATE=TODAY IF INPUT DONE
	TRNN 	M,CLSACC	;% DO NOT RESET ACCESS IF HERE ON ERR
	 DPB	T4,ATYADT	;% IN AKB
	PUSHJ 	P,GIVCBR
	PUSHJ 	P,RIBWTL	;GET RIB WRITE LOCKED
	 JRST 	CLSN2A		;ERROR
	HLRZ T2,ATBMSC(P2)	;RESET ACCESS DATE
	HRRM T2,%RIB+RIBEXT
	MOVE T2,ATBLCW(P2)	;GET LIC WORD
	CAME T2,%RIB+RIBLCW	;IF ITS CHANGING
	MOVEM T2,%RIB+RIBLCW	;THEN CHANGE IT.
	PUSHJ P,RELLOK		;FINISHED WITH RIB
CLSN2A:	PUSHJ P,GETCBR
	MOVE T2,ATBSTS(P2)
	TRNE T2,ATPREN
	JRST CLSXT1		;% RENAME ON WHILE RIB FIDDLE, EXIT
	TRNE T2,ATMCNT-1		;% COUNT NOW 1?
	JRST CLSIN3		;% NO
	TRNE T2,ATPDEL		;% YES, HAS DELETE GONE ON?
	JRST CLIDEL		;%YES, GO DELETE FILE

;DELETE EXPECTS TO JUMP INTO THIS POINT ON RIB ERROR, WITH ATBRIB POSSIBLY 0.

CLSIN3:	TLNE	F,ENTRB+RENMB	;% ENTER OR RENAME DONE?
	JRST CLSXIT		;% YES, EXIT (UPDATE SUPPRESSING OUTPUT CLOSE)
	HRRZ P3,ATBFNB(P2)
	PUSHJ P,ULKDBL	;REMOVE DDB FROM LINKED LIST
	MOVNI T1,ATPCNT
	ADDB T1,ATBSTS(P2)	;DECREMENT COUNT
	TDNE T1,[ATMUMC,,ATMCNT!ATPUPD!ATPMXU]
	JRST CLSIN5		;STILL IN USE
	TLNE	F,INPB!MAPB		;% NO. ANY INPUTS BEEN DONE?
	JRST	CLSIN6		;% YES, JUST MAKE A.T. DORMANT
;HERE TO SEE IF NMB NOW HAS NO A.T.S IN ITS RING
CLSN3A:	PUSHJ P,FREATB		;% RETURN AT TO FREE STORAGE
	HLRZ T1,FNBATB(P3)	;% ANY ATBS LEFT?
	JUMPN T1,CLSIN5		;% YES, DO NOT DELETE FNB
	HRRZ T2,FNBDRB(P3)	;% GET SET TO REMOVE FNB
	MOVEI T3,DRBFNB-FNBLNK(T2)	;% FAKE A PRED.
	HLRZ T2,DRBFNB(T2)	;% FIRST FNB
CLSN3B:	CAIN T2,(P3)
	JRST CLSIN4
	MOVE T3,T2		;% RESET PRED
	HLRZ T2,FNBLNK(T2)	;% NEXT
	JUMPN T2,CLSN3B
	STOPCD(SLO)			;% MISSING

CLSIN4:	MOVE T1,FNBLNK(P3)	;% NOW LINK AROUND FNB
	HLLM T1,FNBLNK(T3)
	MOVE T2,SYSCOR
	HRLM P3,SYSCOR
	HLLM T2,CMBLNK(P3)	;% AND PUT FNB ON FREE LIST
	JRST CLSIN5

CLSIN6:	PUSHJ P,LKDATB		;%JUST PUT THE ATB ON DORMANT LIST
CLSIN5:	SETZM DEVATB(F)
	JRST CLSXT2

CLSXT1:	HRRZ P3,ATBFNB(P2)
	PUSHJ P,ULKDBL
	SETZM DEVATB(F)
	TDZA T1,T1	;FOR DEB IN DAYSTS
CLSXIT:	MOVEI T1,DECUP2	;HERE ON UPDATE CLOSE IN (SET DEYSTC
	DPB T1,DEYSTC
	MOVNI T1,ATPCNT
	ADDM T1,ATBSTS(P2)	;% DEC COUNT
CLSXT2:	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	STOPCD(SLO)
STOCBR:	MOVEM S,DEVIOS(F)
	HLLM F,%UPT+UPTJDA(W)
	PJRST GIVCBR
;CLOSE OUTPUT


CLOSOU:	TLNN	F,ENTRB	;ENTER OR RENAME DONE?
	POPJ	P,		;NO. RETURN
	PUSHJ P,TSTRES
	NOCHARGE	;TURN OFF CHARGING
	PUSHJ P,SIMRLS		;CLEAN UP SIMIO DATA BASE
	MOVEI T1,DECSTP
	DPB T1,DEYSTC
	HRRZ P2,DEVATB(F)
	HLRZ P4,DEVDRB(F)
	SKIPE P2
	SKIPN P4
	STOPCD(SLO)
	HRRZ P3,ATBFNB(P2)	;JUST TO MAKE SURE ITS LOADED
	PUSHJ P,PTROUT	;DUMP CHANGED POINTERS
	 JRST NOOUT2	;RIB ERROR
	 JRST CLSOU1	;NONE (RIB NOT GOTTEN)
	SKIPN %RIB+RIBRIB	;IS IT THE PRIME RIB IN CORE
	JRST CLSOU0	;YES, GO
	PUSHJ P,RELLOK	;GET RID OF IT
CLSOU1:	PUSHJ P,RIBWTL	;GET RIB WRITE LOCKED
	 JRST NOOUT2	;CAN NOT, RIB ERROR
;HERE WHEN THE FILE IS COMPLETELY WRITTEN
CLSOU0:	TRNE	M,CLSRST	;SHOULD THIS CLOSE ACT LIKE A RESET?
	TLO	F,RESETB	;YES. TURN ON RESETB
	HRRZ	P2,DEVATB(F)	;NO. JUST GET LOC OF A.T.
	MOVE	T2,ATBSTS(P2)	;STATUS OF FILE
	TRNN	T2,ATPCRE!ATPSUP ;SKIP IF NOT UPDATING
	TLZ	F,RESETB	;UPDATING, MAKE SURE FILE ISNT DELETED
	TLZN F,RESETB	;IS THIS A RESET?
	JRST CLSOU2	;NO, GO
	PUSHJ	P,DLTALL	;I CAN'T BELIEVE I ATE THE WHOLE THING.
	 JFCL
	SETZM	ATBRIB(P2) ;TELL REMOVE RIB IS GONE. NO ONE ELSE
			; CAN USE THIS ATB YET IS ASSUMPTION.
	PUSHJ P,LOGTST	;AND UFD QUOTAS
CLORS1:	PUSHJ P,GETCBR
	HRRZ P3,ATBFNB(P2)
	PUSHJ P,ULKDBL	;UNLINK DDB FROM FNB
	MOVEI T1,ATPCRE!ATPSUP	;TURN THESE OFF IN CASE THIS STAYS AROUND
	ANDCA T1,ATBSTS(P2)	;GET STATUS WITHOUT BITS
	TLNN T1,ATMUMC		;ANYTHING STILL MAPPED?
				; (MUST BE THIS JOB)
	JRST CLORS2		;NO, DELETE THE ATB
	TRO T1,ATPDEL		;YES, SET ATPDEL SO DECUMC WILL DELETE THE ATB
				;WHEN LAST PAGE IS UNMAPPED
	MOVEM T1,ATBSTS(P2)	;STORE
	JRST CLORS3
CLORS2:	PUSHJ P,FREATB	;RETURN ATB TO FREE CORE
CLORS3:	SOS T2,DRBCNT(P4)
	TRNE T2,DRPMXC
	STOPCD(SLO)		;DECREMNT COUNT
	SETZM DEVATB(F)
	TLZ F,ENTRB!RENMB!LOOKB
	PJRST STOCBR	;DONE

NOOUT2:	TLZE F,RESETB	;RIB ERROR, RESET?
	JRST CLORST	;YES, GO DUMP IT
	MOVE T1,ATBSTS(P2)
	TRNN	T1,ATPCRE!ATPSUP	;SKIP IF NOT UPDATE
	JRST	CLOUPD	;THIS IS UPDATE, MUST WATCH OUT FOR OTHER USERS OF FILE ETC.
	TRNE T1,ATPCRE	;IS THIS CREATE?
	JRST CLOSCR	;GO DO IT ANYWAY

CLORST:	MOVE T1,ATBALP(P2)	;TRY TO ADJUST QUOTAS
	ADD T1,DRBALC(P4)
	SKIPL DRBALC(P4)
	SKIPL T1
	MOVEM T1,DRBALC(P4) 
	JRST CLORS1
CLSOU2:	MOVE	T1,ATBSIZ(P2)	;RESET SOME THING IN RIB
	TRNE	T1,177
	SUBI	T1,200
	CAME	T1,%RIB+RIBSIZ	;CHANGE ONLY IF CHANGING
	MOVEM	T1,%RIB+RIBSIZ
	MOVE	T1,THSDAT
	MOVE	T3,ATBSTS(P2)
	TRNN	T3,ATPCRE!ATPSUP
	TLNE	F,INPB!OUTPB!MAPB	;IF UPDATE, RESET ONLY IF I/O
	DPB	T1,ATYADT		;SET ACCESS DATE
	HLRZ	T1,ATBMSC(P2)
	HRRZ	T2,%RIB+RIBEXT	;SEE IF CHANGING
	CAME	T1,T2
	HRRM	T1,%RIB+RIBEXT
	MOVE	T1,ATBLCW(P2)
	MOVE	T2,%RIB+RIBSTS
	TRNN	T2,RIPHWE!RIPHRE!RIPBDA!RIPBFS!RIPBDR
	TLZA	T1,ATPUFE
	TLO	T1,ATPUFE
	TRNE	T3,ATPSUP!ATPCRE	;IF NOT UPDATE,
	TLO	T1,ATPALC	;THEN HAVE TO SET THIS BECAUSE PRIME RIB GOT ALLOCATED
				;IF NOTHING ELSE.
	MOVEM	T1,ATBLCW(P2)	;GET SET FROM ERROR BITS
	CAME	T1,%RIB+RIBLCW 	;ONLY WRITE IF ITS CHANGING
	MOVEM	T1,%RIB+RIBLCW
	MOVE	T1,ATBALP(P2)
	CAME	T1,%RIB+RIBALP
	MOVEM	T1,%RIB+RIBALP
	MOVE	T1,ATBPVW(P2)
	CAME	T1,%RIB+RIBPVW
	MOVEM	T1,%RIB+RIBPVW
	HRRZ	T3,ATBFNB(P2)	;GET FNB
	MOVE	T1,ATBLCW(P2)	;GET ATPALC BIT
	TLNN	T1,ATPALC	;IF ATPALC IS SET, THEN NEED TO STORE RIBALT AND FNBALT
	JRST	CLSOU3
	MOVE	T2,PCDTIM	;OK, SET FNBALT AND RIBALT FOR ANY ALLOCATION
				; THAT MIGHT HAVE HAPPENED
	CAME	T2,%RIB+RIBALT  	;ONLY CHANGE IF ITS CHANGING
	MOVEM	T2,%RIB+RIBALT	;SET CORRECT VALUE.
	MOVEM	T2,FNBALT(T3)	;WE MAY BE INCREASING THE FNBALT FOR
				; THE OLD FILE, BUT DOESN'T MATTER SINCE
				; NORMALLY OLD FILE GOES AWAY UNLESS
				; CAN'T UPDATE UFD OR SOMETHING, IN WHICH
				; CASE NO HARM MAKING THIS BIGGER.
				; (IN THAT CASE, RIBALT WILL DIFFER FROM FNBALT)
CLSOU3:	PUSHJ	P,RELLOK	;ASSUME THIS WON'T RESCHEDULE.
				; (OR ELSE PCDTIM WILL BE WRONG FOR THE RIB.)
	MOVE	T2,ATBSTS(P2)
	TRNE	T2,ATPCRE
	JRST	CLOSCR		;CLOSE FOR CREATE
	PUSHJ	P,UPDUFD	;UPDATE THE UFD.
	MOVE	T1,ATBSTS(P2)
	TRNN	T1,ATPSUP 	;IF SUPERCEDE
	JRST	CLOUPD		;NOT, MUST BE UPDATE
	MOVSI	T2,ATPALC	;AND IF ALC IS ON,
	TDNE	T2,ATBLCW(P2)	;THEN
	PUSHJ	P,WATPCB	;MUST WAIT FOR UFPALC TO GO OUT.
				; OR ELSE MIGHT GET OLD UFD POINTER WITH NO
				; BIT ON POINTING TO FREE PAGE.
;SUPERCEDE MUST LOOK AT OTHER A.T.'S

	PUSHJ P,GETCBR
	MOVEI T2,ATPUPD!ATPSUP!ATPMXU
				;TURN SUP INTO UPD
				; SO THAT ANYONE WHO LOOKS UP THIS
				; FILE WHILE WE'RE STILL CLOSING WILL
				; GET THIS COPY.
	XORM T2,ATBSTS(P2)
	AOS T2,ATBMWC(P2)	;INCREMENT MAX WRITE COUNT
	TRNN T2,ATMMWC		;CHECK FOR OVERFLOW
	STOPCD(SLO)			;INCREMENTED TO ZERO.
	AOS FNBUPD(P3)		;BUMP COUNT OF UPDATERS
	HLRZ T2,FNBATB(P3)	;GET SET TO SEARCH
CLOSU1:	MOVE T1,ATBSTS(T2)
	TRNE T1,ATPCRE!ATPSUP!ATPREN
	STOPCD(SLO)		;IF THERE IS ONE SUP ATB, SHOULDN'T BE
			; ANY OTHER WRITERS.
	TRNE T1,ATPUPD!ATPDEL ;IGNORE OUR OWN AND DELETED ONES
	JRST CLOSU2	;IGNORE THESE
	SKIPE ATBDOR(T2)	;NOT DORMANT MUST BE READERS
	JRST CLOSU3
	MOVEI T1,ATPDEL
	IORM T1,ATBSTS(T2)	;MARK TO DELETE IT
	PUSHJ P,GIVCBR
	JRST CLOCOM	;AND GO

CLOSU2:	HLRZ T2,ATBLNK(T2)	;NEXT ATB
	JUMPN T2,CLOSU1
CLOSU4:	MOVE T1,ATBRIB(P2)
	EXCH T1,FNBRIB(P3)
	PUSHJ P,GIVCBR
	MOVEM T1,DEVRIB(F)	;NOW MUST DELETE OLD
	TLO S,IO
	PUSHJ P,CRBRWL
	 JRST	[PUSHJ P,RELLOK
		JRST CLOCOM]	;RIB ERROR, GIVE UP
	HLLZS DEVATB(F)	;DO NOT WANT ATBALP ADJUSTED
	PUSHJ	P,DLTALL	;I CAN'T BELIEVE I ATE THE WHOLE THING.
	 JFCL
	HRRM P2,DEVATB(F)	;RESTORE
	JRST CLOCOM	;NOW FOR COMMON CODE

CLOSU3:	PUSH P,P2
	MOVE P2,T2	;MUST REMOVE ATB
	PUSHJ P,RMVATB
	POP P,P2
	JRST CLOSU4	;AND FINISH UP
CLOSCR:	SETZ	T2,		;NO RET PNTR SUPPLIED TO INSNAM.
	PUSHJ P,INSNAM	;CREATE, INSERT NAME IN UFD
	 JRST CLOCOM	;COULDN'T(ALLOC FAIL, RIB ERR, DIR FULL).
	PUSHJ P,CREUFD	;PUT STUFF INTO THE DIRECTORY
	PUSHJ P,RELLOK
	MOVEI T1,ATPDIR
	TDNN T1,ATBSTS(P2)
	JRST CLOCOM
	PUSHJ P,GETCBR	;ITS A UFD. MUST WORRY IF DRB
	MOVE T1,DEVFIL(F)
	PUSHJ P,FNDDRB
	 JRST CLOUF1	;NONE THERE
	SETZM DRBRIB(T2)
	MOVEI T1,DRPNX
	ANDCAM T1,DRBNX(T2)
CLOUF1:	PUSHJ P,GIVCBR
	JRST CLOCOM

CLOUPD:	TLNN F,LOOKB	;IF CLOSING OUTPUT ONLY
	JRST CLOCOM
	PUSHJ	P,INVDDB	;INVALIDATE THE DDB, SET FILE LOC TO START.
		;FALL INTO COMMON CODE
	SKIPA T1,[DECLUK]	;SET TO LOOKUP IF ONLY OUT CLSD
CLOCOM:	MOVEI T1,0	;DONE WITH STATUS
	DPB T1,DEYSTC
	PUSHJ P,LOGTST	;RESET UFD USD INFO IF NEEDED
	MOVE T1,ATBRIB(P2)
	TLZ F,ENTRB!RENMB
	MOVEM T1,FNBRIB(P3)
	MOVSI T1,FNPNX
	ANDCAM T1,FNBNX(P3)	;MAKE SURE FNB MARKED AS THERE
	PUSHJ P,GETCBR
	MOVE T1,ATBSTS(P2)	;PICKUP ATBSTS
	TRZE T1,ATPSUP!ATPCRE	;CLEAR THESE, SKIP IF UPDATING
	JRST CLOCM1		;CREATE (SUPERCEDE TURNED INTO UPDATE)
	SOSGE FNBUPD(P3)	;DECREMENT UPDATE COUNT
	STOPCD(SLO)			;UNDERFLOW
	SOS T2,ATBMWC(P2)	;DECREMENT MWC FOR UPDATER
	TRNN T2,ATMMWC		;COUNT GO TO ZERO?
	TRZ T1,ATPMXU		;YES, CLEAR MAX WRITE BIT
	TRZ T1,ATPUPD		;CLEAR IN CASE IT WAS SINGLE UPDATER
CLOCM1:	MOVEM T1,ATBSTS(P2)	;STORE NEW ATBSTS.
	TDNN T1,[ATMUMC,,ATPMXU!ATMCNT] ;SKIP IF ANY USERS STILL
	PUSHJ P,LKDATB	;MAKE ATB DORMANT IF NO MORE USERS
	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	STOPCD(SLO)
	TLNE	F,LOOKB
	JRST	CLOCM2		;ALMOST DONE.
	PUSHJ	P,ULKDBL	;REMOVE FROM DDB LIST
	SETZM	DEVATB(F)	;NO MORE AT
CLOCM2:	PUSHJ	P,STOCBR	;
	PJRST	WATPCB		;
;TEST TO SEE IF THE USER IS LOGGED IN AND RESET UFD USD IF NOT

LOGTST:	MOVEI T2,DRPLOG
	TDNE T2,DRBLOG(P4)
	POPJ P,		;NOT LOGGED IN
	TLO S,IO
	PUSHJ P,RIBDIR
	 PJRST RELLOK	;CAN NOT GET IT
	HLRZ T1,DEVDRB(F)
	MOVE T2,%RIB+RIBQTF
	SUB T2,DRBALC(T1)
	MOVEM T2,%RIB+RIBUSD
	MOVE T2,%RIB+RIBQTF
	SUB T2,DRBMXA(T1)
	MOVEM T2,%RIB+RIBMXA
	PJRST RELLOK	;ALL DONE

;FILL IN THE UFD FROM THE IN CORE TABLES
; USES T1-T3. EXPECT P2/ATB ADDRESS.

CREUFD:	PUSH	P,P3		;SAVE P3 AND SETUP TO BE FNB ADDRESS
	HRRZ	P3,ATBFNB(P2)	;GET FNB ADDR IN P3
	PUSH	P,T4		;SVE T4 FOR COMPARES BELOW
	MOVE T1,DEVFIL(F)
	CAME	T1,%RIB+UFDNAM(T2) ;DON'T WRITE IF ITS THE SAME
	MOVEM T1,%RIB+UFDNAM(T2)	;T2 POINTS TO THE UFD SLOT
	HLLZ T1,DEVEXT(F)
	HLLZ	T4,%RIB+UFDEXT(T2)	;SEE IF ITS SAME
	CAME	T1,T4
	MOVEM	T1,%RIB+UFDEXT(T2)	;NOT, UPDATE.
	LDB T3,ATYPRV
	LDB	T4,UFYPRV		;SEE IF SAME
	CAME	T3,T4		;SKIP IF NO NEED TO WRITE
	DPB T3,UFYPRV
	LDB T3,ATYUF2
	LDB	T4,UFYUF2	;SEE IF ANY NEED TO WRITE
	CAME	T3,T4		;?
	DPB T3,UFYUF2
	LDB T1,ATYCDT
	CAME	T1,%RIB+UFDCDT(T2)	;ANY NEED TO WRITE?
	MOVEM T1,%RIB+UFDCDT(T2)	;CREATION DATE
	LDB T1,ATYXCD
	LDB	T4,UFYXCD	;SEE IF SAME
	CAME	T1,T4
	DPB T1,UFYXCD	;AND THE EXTENDED PART
	LDB T1,ATYCTM
	IMULI T1,^D60
	LDB T3,ATYCSC	;SECONDS
	ADD T1,T3
	LDB	T4,UFYCTM	;SEE IF SAME
	CAME	T1,T4
	DPB T1,UFYCTM	;AND STORE IN UFD
	LDB T1,ATYUF1
	LDB	T4,UFYUF1
	CAME	T1,T4
	DPB T1,UFYUF1	;MORE BITS
	MOVE T1,ATBLIC(P2)
	HRRZ	T4,%RIB+UFDLIC(T2)
	CAME	T1,T4
	HRRZM T1,%RIB+UFDLIC(T2)
	MOVE T1,ATBALP(P2)	;NUMBER OF ALLOCATED PAGES
	CAIL T1,400000
	MOVEI T1,400000	;SET FLAGIF VERY BIG. NEEDS LOOKUP
	HLRZ	T4,%RIB+UFDALP(T2)
	CAME	T1,T4
	HRLM T1,%RIB+UFDALP(T2)
	MOVE T1,ATBRIB(P2)
	CAME	T1,%RIB+UFDRIB(T2)
	MOVEM T1,%RIB+UFDRIB(T2)
	POP	P,T4		;RESTORE T4 AND
	POP	P,P3		;P3
	POPJ P,
;ROUTINE TO FILL IN ATB WITH PRELIMINARY INFORMATION FROM UFD
; ENTRY IN CASE WE GET A RIB ERROR TRYING TO READ RIB.
; CALLED FROM SRCFIL WITH CB, DRBCNT UP, RIB LOCKED STILL.
; DOES NOT FILL IN ATBRIB, SINCE INFO IS REALLY NOT VALID - IS
; OVERWRITTEN WITH THE REAL DATA FROM THE RIB NORMALLY.
; IF GET A RIB ERROR, PROTECTION AND PID ARE SETUP SO THAT
; USER CAN DELETE IT IF IT REALLY WAS HIS FILE AND IT WAS
; PROTECTED SO HE COULD DELETE IT.
; P2 HAS ATB ADDRESS, T2 HAS POINER TO UFD ENTRY (%RIB+UFD???(T2))

UFDATB::SKIPE	ATBRIB(P2)	;MAKE SURE NOTHING IN THERE ALREADY
	STOPCD(SLO)			;SORRY, DON'T OVERWRITE ATB INFO THAT IS BETTER THAN UFD INFO
	LDB	T1,UFYPRV	;GET PROTECTION CODE
	DPB	T1,ATYPRV	;STORE IT THERE.
	LDB	T1,UFYUF2	;GET DUMPED, ERROR, PID BITS ETC
	DPB	T1,ATYUF2
	MOVE	T1,%RIB+UFDCDT(T2) ;GET CREATION DATE
	DPB	T1,ATYCDT
	LDB	T1,UFYXCD	;GET REST OF BITS (EXTENDED)
	DPB	T1,ATYXCD
	LDB	T1,UFYCTM
	IDIVI	T1,^D60		;GET SECONDS IN T2, TIME IN T1
	DPB	T1,ATYCTM	;IN MINUTES
	DPB	T2,ATYCSC	;IN SECONDS
	LDB	T1,UFYUF1	;GET FIRST 4 BITS
	DPB	T1,ATYUF1	;AND STORE THEM
	HRRZ	T1,%RIB+UFDLIC(T2)
	HRRM	T1,ATBLIC(P2)	;STORE INTO RH OF ATBLIC.
				;(FOR INFO - CAN'T RUN ANYTHING ANYWAY)
	MOVE	T1,%RIB+UFDALP(T2) ;GET SIZE
	MOVEM	T1,ATBALP(P2)	;STORE. INCLUDES 400000,,0 IF DON'T KNOW HOW BIG.
	MOVSI	T1,ATPPID	;DOES THIS FILE HAVE A PID?
	TDNN	T1,ATBLCW(P2)	;IF NOT, JUST RETURN.
	POPJ	P,		;AND RETURN.
	MOVEI	T1,777777	;USE LAST SYSTEM PID
	MOVEM	T1,ATBPID(P2)	;SO THAT ITS PROTECTED AGAINST THE OWNER UNLESS HE HAS LICENSE.
	POPJ	P,		;RETURN NOW.
;ROUTINE CALLED BY ROUTINES THAT ALLOCATE BEFORE THEY ALLOCATE
; TO SET UFDALC AND ATBALC. GETS CB RESOURCE, NEEDS %RIB TO
; PUT UFD INTO.
; EXPECTS F/DDB ADDRESS
; USES T1-T3
; IF CALER DOESN'T WANT ANYTHING TO HAPPEN UNLESS ATPALC IS CLEAR,
; HE MUST CHECK HIMSELF. OTHERWISE ALL CHANGED UFD VALUES WILL GET
; UPDATED.

SETACH::PUSHJ	P,GETCBR	;GET CB RESOURCE
	HRRZ	T2,DEVATB(F)	;GET ATB ADDRESS IN T2 FOR FILSER ROUTINES
	HRRZ	T3,ATBFNB(T2)	;GET FNB ADDRESS IN T3
	MOVE	T1,ATBRIB(T2)	;MAKE SURE THIS FILE-ATB IS THE ONE WITH UFD ENTRY
	CAME	T1,FNBRIB(T3)
	PJRST	GIVCBR		;ITS NOT, DON'T HAVE TO SET THE BIT
	SETOM	FNBALT(T3)	;SO THAT NO ONE WILL CLEAR IT - ACTUALLY JUST DEBUGGING CHECK
	MOVSI	T1,ATPALC	;GET THE BIT
	TDNE	T1,ATBLCW(T2)	;IS IS SET ALREADY?
	PJRST	GIVCBR		;YES, THEN NO NEED TO WRITE OUT UFD AGAIN
	IORM	T1,ATBLCW(T2)	;NO, SO SET IT. NO ONE WILL CLEAR THIS
				; AFTER RELEASE OF CB, SINCE WE HAVE WRITE
				; BITS ON IN THIS ATB.
	PUSH	P,P2		;SAVE P2, NEED IT FOR ATB ADDRESS FOR UPDUF0
	MOVE	P2,T2		;GET ATB ADDRESS IN P2
	PUSHJ	P,UPDUF0	;DO THE COMMON WORK
	POP	P,P2		;RESTORE P2
	PUSH	P,T4		;BOY OH BOY, WATPCB CLOBBERS T4 AND WE CAN'T
	PUSHJ	P,WATPCB
	POP	P,T4
	POPJ	P,		;RETURN.

;HERE IF ATPALC WAS ON TO CLEAR IT
; WITH CB RESOURCE.
;EXPECTS ATB ADDRESS IN P2
;SMASHES T1-T3

CLRACH:	PUSHJ	P,TSTWRT	;DON'T MUCK WITH IT IF FILE IS OPEN FOR ANY SORT OF WRITE
	  POPJ	P,		;GO AWAY, STILL HAVE CB
	HRRZ	T3,ATBFNB(P2)	;GET FNB ADDR IN T3
	MOVE	T1,ATBRIB(P2)	;GET RIB POINTER
	CAME	T1,FNBRIB(T3)	;MAKE SURE THIS FILE IS STILL IN UFD
	POPJ	P,		;JUST RETURN WITH CB STILL
	MOVE	T1,FNBALT(T3)	;GET WHAT PCB DIRTY MONITOR CLOCK WAS AFTER ALLOCATION
	CAMLE	T1,PCDTIM	;IF ALT IS GREATER THAN CURRENT PCDTIM,
	JRST	CLRAC0		; THEN RIBALT MUST HAVE BEEN FROM PREVIOUS MONITOR.
				; SO CLEAR ATPALC.
	ADDI	T1,2		;ONE COUNT FOR THE PCBS THAT WERE ON THEIR
				; WAY OUT, ONE FOR THE ONES THAT WERE DIRTY
	CAMLE	T1,PCDTIM	;IF IT HAS INCREMENTED 2 TIMES, WE WIN
	POPJ	P,		;SORRY, EVERTHING HASN'T GONE OUT YET.

;NOW WE NOW THERE ARE NO MORE WRITERS OF FILE, THE ATB STILL 
; REPRESENTS THE FILE WHICH HAS A UFD ENTRY, AND ALL THE PCBS THAT
; WERE DIRTY AT THE LAST ALLOCATION CHANGE HAVE BEEN WRITTEN OUT
; AT LEAST ONCE, AND ALL THE PCBS WHICH HAD IO IN PROGRESS HAVE
; BEEN WRITTEN OUT ONCE AFTER THAT IO STOPPED. WE CAN NOW SAFELY
; SAY THAT ALL INFORMATION (RIBS, SATS, UFD ENTRIES) FOR THE FILE
; ARE ON THE DISK.
CLRAC0:	MOVSI	T1,ATPALC
	ANDCAM	T1,ATBLCW(P2)	;CLEAR IT AND
	PUSHJ	P,UPDUF0	;UPDATE THE UFD
	PJRST	GETCBR		;GET CB BACK FOR CALLER AND RETURN.
				;(NO NEED TO WAIT FOR CLEARED BIT TO MAKE IT BACK TO DISK.)
;ROUTINE TO UPDATE A UFD ENTRY FROM ATB INFORMATION
; CAL WITH CB AT UPDUF0 OR WITHOUT AT UPDUFD
; USES T1-T3, %RIB.
; EXPECTS ATB ADDRESS IN P2, DDB ADDRESS IN F.

UPDUF0:	PUSHJ	P,GIVCBR	;GIVE BACK CB CALLER SHOULD HAVE HAD.
UPDUFD:	PUSH	P,P4		;SVE THIS
	PUSH	P,T4		;MUST SAVE THIS TOO.
	HLRZ	P4,DEVATB(F)	;GET DRB ADDRESS
	PUSHJ	P,RIBDIR	;GET UFD RIB IN %RIB
	  JRST	UPDNUR		;NO UFD RIB, MUST CALL RELLOK
	PUSH	P,P3		;SAVE P3
	HRRZ	P3,ATBFNB(P2)	;GET FNB ADDRESS
	LDB	T1,FNYUFP	;GET POINTER TO THE UFD ENTRY
	TLO	S,IO		;NEED TO WRITE INTO IT
	TLZ	S,IOSRIB	;NOTHING IN %RIB, SO USE IT, NOT %RB2
	PUSHJ	P,DIRBLK	;GET PAGE OF THE UFD THAT ENTRY IS IN
	  PJSP	T1,[POP P,P3	;RESTORE P3
		    JRST UPDNU1] ;AND GO SAY MUST DO SLOW DSKCLN.
	PUSHJ	P,DIRSRC	;OK, GET ENTRY ADDRESS IN T2
	  JRST	.+2		;HAVE IT
	STOPCD(SLO)		;NEED TO RUN SLOW DSKCLN
	PUSHJ	P,CREUFD	;OK, UPDATE UFD IF NECESSARY
	PUSHJ	P,RELLOK	;GET RID OF IT NOW
	POP	P,P3		;RESTORE P3 AND
	POP	P,T4		; T4
	POP	P,P4
	POPJ	P,		;AND RETURN. (DON'T PJRST, RELLOK SMASHES T4.)

UPDNUR:	PUSHJ	P,RELLOK
UPDNU1:	POP	P,T4
	POP	P,P4		;RESTORE THIS.
	PJSP	T1,SLOCLN	;STORE PROBLEM PC AND RETURN POPJ.

;ROUTINE TO SET FNBALT. EXPECTS LIVE DDB IN F (RH(DEVATB) SETUP)
; PRESERVES T1, USES T2 AND T3.
; DON'T NEED CB, SINCE FILE SHOULD HAVE ATPMXU ON, PREVENTING
; SOMEONE ELSE FROM DELETING IT OUT FROM UNDER US (EITHER ITS
; ALREADY DELETED (TRUNCATING RENAME) OR IT IS STILL IN UFD.

SETALT::PUSH	P,T1		;PRESERVE T1
	PUSH	P,P2		;SAVE P2 ALSO
	HRRZ	P2,DEVATB(F)	;GET ATB IN P2
	HRRZ	T1,ATBFNB(P2)	;GET FNB
	MOVE	T3,FNBRIB(T1)	;GET POINTER
	MOVE	T2,PCDTIM	;GET READY IN CASE THIS IS FILE IN UFD
	CAMN	T3,ATBRIB(P2)	;IS THIS THE FILE IN THE UFD?
	MOVEM	T2,FNBALT(T1)	;YES, MAKE COUNT >= TO WHAT IT WAS
	POP	P,P2		;RESTORE
	JRST	TPOPJ		;AND RETURN.
;JSP T1, SLOCLN   IF NEED TO RUN SLOW DSKCLN AND WANT TO RET TO CALLER
;pushj p,slocle   if need to run slow dskcln and want to ret to next instr

slocle::move	t1,(p)		;get address of caller
SLOCLN::AOS	SLOCLC		;INCREMENT NUMBER OF TIMES GOT HERE
	MOVEM	T1,SLOCLP	;AND REMEMBER LAST PC
	POPJ	P,		;AND RETURN.

FASCLC::0			;Increment to force FAST Dskcln
SLOCLC::0
SLOWPC::0			;save PC of STOPCD(SLO) for crash code
SLOCRS::			;JSR here for STOPCD(SLO)
SLOCLP::0			;store PC here to force full next crash
	AOS	SLOCLC
	MOVEM	T1,SLOWPC	;cant trust this if we are reentered!
	MOVE	T1,SLOCRS
	SUBI	T1,1		;guess the real address
	EXCH	T1,SLOWPC	;save PC for the crash code
	JSR	SYSCRS##

NOCRPC::0			;save PC of STOPCD(NO) for crash code
NOCRS::	0			;JSR HERE IF FILE SYSTEM DOESN'T WANT TO
				; RUN DSKCLN UNTIL HARDWARE IS CHECKED OUT
	MOVEM	T1,NOCRPC	;cant trust this if we are reentered!
	MOVE	T1,NOCRS
	SUBI	T1,1		;guess the real address
	EXCH	T1,NOCRPC	;save PC for the crash code
	JSR	SYSCRS##

;RELEASE UUO
DSKREL:	PUSHJ	P,WAIT1		;WAIT FOR I/O TO STOP
	MOVE 	J,JOB
	PUSHJ	P,SIMRLS	;FIX SIMIO DATA BASE (DO THIS
				;HERE FOR SUPERIO)
	TLO	F,RESETB	;INDICATE RESET IN PROGRESS
	PUSHJ	P,CLOSIN	;CLOSE INPUT (IF NOT ALREADY DONE)
	PUSHJ	P,CLOSOU	;CLOSE OUTPUT (DITTO)
	TLZ	F,RESETB	;RESET BIT
	SETZM	DEVFIL(F)	;INDICATE FILE RELEASED
	SETZM 	DEVPOS(F)	;FOR GOOD MEASURE, MARK BAD POSITION
	SETZM DEVPPN(F)
	TLZ S,IOSUPR
	PJRST STOIOS
;THIS ROUTINE IS AN ERROR CHECKING ROUTINE CALLED AT THE START
;OF VARIOUS UUO'S. IT INSERTS A NEW RETURN ON THE PUSH-DOWN
;LIST WHICH WILL CHECK TO SEE THAT RESOURCES HAVE BEEN RELEASED.

TSTRES:	POP P,(P)	;CALLED WITH PUSHJ GET STACK DECED
	PUSHJ P,@1(P)	;NOW CALL USING OLD RETURN ADDRESS
	 SKIPA
	AOS (P)		;SKIP RETURN
	PUSH P,T1
	MOVE T1,JOB
	CAME T1,CBUSER	;SEE IF JOB HAS CB
	SKIPE QUEPCB(T1)	;OR A DIRECTORY
	STOPCD(SLO)	;YES, DIE
	SKIPN %UPT+UPTRIB	;NO BLOCKS LOCKED
	SKIPE %UPT+UPTRB2
	STOPCD(SLO)
	SKIPE %UPT+UPTSAT
	STOPCD(SLO)
	JRST TPOPJ
SUBTTL	LOOKUP

;LOOKUP
ULOOK:	PUSHJ P,TSTRES	;MAKE SURE WE EVENTUALLY GIVE ALL BACK
	TLNN	S,IOSUPR
	TLNE F,ENTRB
	JRST LUKER1	;CAN NOT DO LOOKUP AFTER ENTER
	NOCHARGE
	PUSHJ P,LKSET	;CHARGE 1 LOOKUP
	PUSHJ P,CHKARG	;CHECK ARGUMENT LIST
	 JRST ILNMER	;BAD NAME (ACTUALLY EXTENDED WITH SMALL COUNT)
	TLO M,UUOLUK	;SET FOR LOOKUP
	PUSHJ P,SETFIL	;GET FILE NAME STORED
	 JRST ILNMER	;BAD NAME
	MOVEI T1,DECSTP
	DPB T1,DEYSTC
	HLRZ T1,DEVEXT(F)	;SEE IF UFD
	TLNE M,EXTUUO		;ONLY ON EXTENDED UUO
	CAIE T1,'UFD'
	JRST ULOOK2		;NOT EXTENDED OR NOT UFD
	MOVE T1,DEVPPN(F)
	CAME T1,MFDPPN
	JRST ULOOK2
	MOVE T1,DEVFIL(F)
	TLNE T1,-1		;IS L.H. 0
	JRST ULOOK2		;NO
	PUSHJ P,LOKLUD		;GET USER NAME TO PPN
	MOVEM T1,DEVFIL(F)
	UMOVEM T1,UUXNAM(M)
ULOOK2:	TLNN M,EXTUUO	;CHECK FOR MULTIPLE EXTENSION LOOKUP
	JRST ULOOK3	;CAN NOT BE
	UMOVE T1,(M)
	TRNN T1,400000
	JRST ULOOK3	;THAT WAS THE FLAG

COMMENT ! DISABLE FANCY LOOKUP FEATURE 16 NOV 77 AAA.
	(GIVE ERROR 0 IF FANCY LOOKUP SPECIFIED) !
	JRST ILNMER
COMMENT !
;PROCESS FANCY (MULTIPLE EXTENSION) LOOKUP. READ USER ARGUMENT
;POINTED AT BY USER'S EXTENSION WORD, NOW IN DEVEXT(F).
;DEVEXT(F)/     USER BLOCK,,0		USER BLOCK/  N
;					          / EXT 1
;						  / EXT 2
;						...ETC...
;						  / EXT N

	HLRZ P2,DEVEXT(F)	;THIS IS THE CORE TABLE OF EXTENSIONS
	UMOVE T2,(P2)
	CAIGE T2,1000
	CAIG T2,0	;DON'T ALLOW TOO MANY
	JRST ERRLKM
	MOVE T1,P2
	ADD T1,T2
	UMOVE T1,(T1)	;TRY TO READ IT SO WE FAULT NOW
;PROCESS FANCY LOOKUP
	HRL P2,T2	;P2/ USER COUNT,,USER ADDR
	ADDI T2,1	;NEED <USER COUNT>EXTENSION WDS+1 COUNT WD
	HRLZ P3,T2	;P3/WDS BEING ALLOCATED,,0
	PUSHJ P,GETWDS	;TAKE T2/WDS NEEDED. RETURN T1/LOC FREECORE
	 JRST ERRNET	;NOT AVAILABLE
	HRR P3,T1	;P3/SIZE EXTBLOCK,,ADDR EXTBLOCK
	SETZM (T1)	;EXTBLOCK[0]_COUNT OF DISTINCT EXT'S SEEN
	HLRZ T2,P2	;T2/USER COUNT
	MOVNS T2	;T2/-USER COUNT
	HRLM T1,DEVEXT(F)	;DEVEXT(F)/EXTBLOCK ADDR,,0
	HRLM T2,P2	;P2/-USER COUNT,,USER ADDR SEE ULK2A
	UMOVE T2,1(P2)
	AOJA T1,ULK2D	;GO STORE IN MONITOR CORE
;ULK2C - ULK2A:  PICK UP EXTENSIONS FROM USER BLOCK
;AND CHECK TO SEE THAT THEY'RE NOT ALREADY IN MONITOR EXTBLOCK
;(DON'T REPEAT IF USER REPEATS AN EXT). INCREMENT EXTBLOCK
;CONTROL COUNT FOR EACH DISTINCT EXT SEEN.
;T1/EXTBLOCK ADDR	T2/GET USER EXT		T3/TEST EXTBLOCK EXT
;P2/USER AOBJN		P3/SIZE,,ADDR OF EXTBLOCK[0] CONTROL WORD

ULK2C:	 XCTBU <HLLZ T2,1(P2)>	;NORMAL LOOP. NEXT EXT
	MOVEI T3,1(P3)	;POINT TO MONITOR CORE
ULK2B:	CAMN T2,(T3)	;HAVE WE SEEN THIS EXT BEFORE?
	JRST ULK2A	;YES, SKIP IT
	CAIE T3,(T1)	;HAVE WE LOOKED AT ALL OF THEM?
	AOJA T3,ULK2B	;NO, CONTINUE
	ADDI T1,1	;THIS ONE IS NEW, STORE IT
ULK2D:	AOS (P3)	;COUNT ONE MORE
	HLLZM T2,(T1)	;AND STORE EXTENSION
ULK2A:	AOBJN P2,ULK2C	;ANY MORE FROM USER?


			;FINISHED ALL USER BLOCK.
	MOVN T2,(P3)	;T2/-COUNT DISTINCT EXTENSIONS
	HRLM T2,(P3)	;EXTBLOCK[0]_-COUNT,,COUNT FOR SRCFIL
	TLO M,UUOMLK	;SET FLAG
;******************************************************
	PUSHJ P,SRCFIL	;GO FIND FILE. P1-P4 PRESERVED
	 SKIPA		;NO FILE
	JRST FOUND0
;PASS SRCFIL THE FOLLOWING ARGUMENT:
;DEVEXT(F)/ FREECORE EXTBLOCK,,0
;FREECORE EXTBLOCK/ -COUNT,,COUNT
;		  / EXTENSION,,0
;		  / EXTENSION,,0
; ETC.
;( COUNT IS THE NUMBER OF UNIQUE EXTENSIONS PRESENT, NOT THE
;  SIZE OF THE FREECORE AREA ALLOCATED. THAT IS IN P3, FOR
;  CLNML.  COUNT MAY BE ALTERED BY SRCFIL AS IT FINDS NX FILES,
;  ETC.)
;********************************************************
	PUSHJ P,CLNML	;RETURN FREE CORE
	JRST STRERZ	;AND GIVE ERROR

CLNML:	;RETURN EXTBLOCK FREECORE. EXPECTS
	;P3/SIZE OF EXTBLOCK,,ADDR EXTBLOCK
	;DESTROYS T2
	PUSH P,T1
	HRRZ T2,P3	;T2/ADDR FREECORE
	HLRZ T1,P3	;T1/SIZE
	PUSHJ P,GIVWDS	;EXPECTS T1,T2
	JRST TPOPJ

FOUND0:	PUSHJ P,CLNML
	HLL T1,DEVEXT(F)
	XCTBU <HLLM T1,UUXEXT(M)>	;RETURN TO USER
	JRST FOUND

END FANCY LOOKUP !

;PROCESS ORDINARY SINGLE-EXTENSION LOOKUP. M/ UUOMLK IS OFF
; AND DEVEXT(F)/EXTENSION,,0

ULOOK3:	PUSHJ P,SRCFIL
	 JRST STRERZ
	TLZ	S,IOSRIB	;CLEAR DUMB FLAG.
			;FALL INTO FOUND
;HERE WHEN FILE NAME IS FOUND ON LOOKUP
FOUND:	HRRZ P2,DEVATB(F)	;GET ATB LOCATION
	HLRZ P4,DEVDRB(F)	;AND DRB
	MOVEI T1,FNCLOK
	PUSHJ P,CHKPRV
	 JRST LKER1		;CAN NOT REALLY DO THE LOOKUP
	MOVEI T1,FNCRED		;CAN LOOKUP, NOW CHECK READ
	TLNE F,GETB		;IF FROM GET OR RUN
	MOVEI T1,FNCEXC		;THEN EXECUTE IS ENOUGH
	PUSHJ P,CHKPRV
	SKIPA
	JRST FNDROK		;OK TO READ
	MOVSI T1,NORED
	IORM T1,DEVIAD(F)
FNDROK:	TLNN F,GETB		;IS IT A GET OR RUN??
	JRST FNDNGT		;NO
	MOVEI T1,FNCRED	;SEE IF HE CAN READ
	PUSHJ P,CHKPRV
	SKIPA			;NO, EXECUTE ONLY
	JRST FNDNGT
	MOVEI T1,PVEXOG
	LDB T2,PJOBN
	IORM T1,JBTPRV(T2)	;SET GOT EX ONLY R BIT
FNDNGT:	TLNE	M,EXTUUO	;EXTENDED M?
	JRST FOUND2	;YES
	MOVE T1,ATBSIZ(P2)
	CAILE T1,400000	;TOO BIG TO REPORT WORDS?
	JRST	[LSH T1,-BLKLSH	;YES, JUST REPORT BLOCKS
		JRST FOUND1]
	TRNE T1,177	;CORRECT FOR ADJUST MENT TO BLOCK FIELD
	SUBI T1,200
	MOVNS T1
FOUND1:	 XCTTU <HRLZM T1,UUNPPN(M)>	;GIVE USER SIZE
	MOVE T1,ATBPVW(P2)	;GET PRIVS, ETC
	UMOVEM T1,UUNATT(M)	;AND GIVE TO USER
	HLRZ T1,ATBMSC(P2)	;ACCESS DATE
	XCTBU <HRRM T1,UUNEXT(M)>
	JRST FOUND3	;FINISH UP

;HERE WHEN FILE IS FOUND FOR AN EXTENDED LOOKUP
FOUND2:	HLRZ	T1,ATBMSC(P2)	;ACCESS DATE
	XCTBU <HRRM T1,UUXEXT(M)>	;AND ACCESS DATE
	CAIGE	P1,UUXPRV		;STORE VALUES?
	JRST	FOUND3		;NO. FINISH UP
	MOVE	T1,ATBPVW(P2)	;PRIVILEGES WORD
	UMOVEM T1,UUXPRV(M)	;GIVE PRIVS TO USER
	CAIGE P1,UUXSIZ
	JRST FOUND3
	MOVE T1,ATBSIZ(P2)
	TRNE T1,177
	SUBI T1,200	;CORRECT FOR BLOCK ADJUSTMENT
	UMOVEM	T1,UUXSIZ(M)		;YES. SAVE IT
	CAILE	P1,UUXSIZ	;NEED MORE VALUES?
	JRST FOUND4	;YES. GO READ RIB

;HERE TO FINISH UP A LOOKUP IF THE RIB DOESN'T HAVE TO BE READ
FOUND3:	TLZ S,IO
	JRST FOUND8
;HERE WHEN USER WANTS MORE VALUES THAN ARE STORED IN ACCESS TABLE
;READ RIB (IF IT ISN'T ALREADY IN CORE)
FOUND4:	TLZ	S,IO		;NO MORE NEED TO WRITE IN RIB.
	SKIPE	@%RIB.C+%CTUPT	;DO WE HAVE THE RIB?
	JRST	FOUND5		;YES.
	PUSHJ	P,RIBRDL	;NO.
	JRST	FOUND8		;SOMETHING WRONG WITH RIB

;HERE WITH FILE RIB IN CORE
FOUND5:	SUBI P1,UUXVER-1	;NUMBER MORE TO TRANSFER
	MOVNS P1
	HRLS P1
	HRRI P1,UUXVER
	TLO M,P1		;FORCE INDEXING FOR M.
	XCT TUTAB-UUXVER(P1)	;XCT FOR SPECIAL ARGS
	UMOVEM T1,@M
	AOBJN P1,.-2
    ;HERE WHEN VALUES SET UP, OR NO NEED TO DO SO,  OR COULDN'T
    ;GET GOOD RIB TO DO SO.
FOUND8:	PUSHJ P,INVDDB	;INVALIDATE DDB AREA, SET FILE LOC TO START.
	PUSH	P,PG		;SAVE PG.
	PUSHJ	P,RELRIB	;GET RID OF RIB IF WE HAVE IT.
	POP	P,PG		;
	MOVEI T1,DECLUK
	DPB T1,DEYSTC
	MOVEM S,DEVIOS(F)
	PJRST CPOPJ1
;TABLE FOR LOADING ARGUMENTS TO RETURN TO USER

TUTAB:	MOVE T1,%RIB+RIBVER	;RIBVER
	MOVE T1,%RIB+RIBFUT
	MOVE T1,%RIB+RIBEST
	PUSHJ P,CLCALC		;SPECIAL FOR ALLOCATED
	MOVE T1,%RIB+RIBPOS
	MOVE T1,%RIB+RIBFT1
	MOVE T1,%RIB+RIBLCW
	MOVE T1,%RIB+RIBMTA
	MOVE T1,%RIB+RIBDEV
	MOVE T1,%RIB+RIBSTS
	MOVE T1,%RIB+RIBELB
	MOVE T1,%RIB+RIBXT1
	MOVE T1,%RIB+RIBQTF
	MOVE T1,%RIB+RIBQTO
	PUSHJ P,CLCMXA		;IF DIRECTORY, SPECIAL
	PUSHJ P,CLCUSD		;ALSO
	MOVE T1,%RIB+RIBAUT
	MOVE T1,%RIB+RIBUNM
	MOVE T1,%RIB+RIBUN1
	MOVE T1,%RIB+RIBTRU
	MOVE T1,%RIB+RIBXT2
	MOVE T1,ATBALP(P2)
	MOVE T1,%RIB+RIBSNM
	MOVE T1,%RIB+RIBPJC	;-
	MOVE T1,%RIB+RIBPJ1	;-
	MOVE T1,%RIB+RIBPJ2	;-
	MOVE T1,%RIB+RIBPID	;PROCESSOR ID

CLCALC:	LDB T1,ATYBLK	;GET NUMBER OF BLOCKS IN FILE (TO EOF)
	CAMGE T1,%RIB+RIBALC
	MOVE T1,%RIB+RIBALC	;GET LARGEST REQUEST
	POPJ P,

CLCMXA:	MOVEI T1,ATPDIR
	TDNN T1,ATBSTS(P2)
	JRST MXACL1
	PUSHJ P,GETCBR
	MOVE T1,DEVFIL(F)
	HLRZ T2,SYSDRB	;WHERE TO START AND NO CREATE
	MOVNI T3,1	;SET T3 NEG SO NO NEW BLOCK
	PUSHJ P,SRCNAM
	 JRST MXACL2	;JUST USE IT FROM RIB
	SKIPN DRBRIB(T2)
	JRST MXACL2	;ALSO IF RIB NOT READ YET
	MOVE P3,T2	;FOR RIBUSD
	MOVN T1,DRBMXA(P3)
	ADD T1,%RIB+RIBQTF
	PJRST GIVCBR

MXACL2:	PUSHJ P,GIVCBR
MXACL1:	MOVEI P3,0	;FOR RIBUSD IF WANTED
	MOVE T1,%RIB+RIBMXA
	POPJ P,

CLCUSD:	SKIPE P3
	SKIPA T1,%RIB+RIBQTF
	SKIPA T1,%RIB+RIBUSD	;JUST GET ARG FROM RIB
	SUB T1,DRBALC(P3)
	POPJ P,
SUBTTL	ENTER


COMMENT ! ROUTINE UENTR - DISPATCH HERE FROM DSKDSP 
CALL:	HRRZ AC,DEVSER(F)
	PUSHJ P,DEN(AC)
	RETURN HERE FAILURE
	SUCCESS
!
EXTERN SIMENT
UENTR:	NOCHARGE
	PUSHJ P,TSTRES
	TLNE	S,IOSUPR
	JRST	LUKER1
	PUSHJ P,ERNSET		;CHARGE 1 ENTER
	PUSHJ P,SIMENT		;DEAL WITH SIMIO DATA BASE
	TLNE	F,LOOKB		;LOOKUP IN FORCE?
	JRST	UPDATE		;YES. UPDATE
	PUSHJ	P,CHKARG	;NO. SET M FOR ENTER
	  JRST	ILNMER		;BAD NAME - ERROR
	TLO	M,UUOENT	;INDICATE ENTER
	PUSHJ P,SETFIL	;SET UP FILE NAME
	 JRST ILNMER
	MOVEI T1,DECSTP
	DPB T1,DEYSTC
	PUSHJ	P,SRCFIL	;SEARCH FOR MATCH, SET A.T.
	  JRST	STRERZ		;ERROR
	HRRZ	P2,DEVATB(F)	;LOC OF A.T.
	HLRZ P4,DEVDRB(F)
	MOVE T2,ATBSTS(P2)
	MOVEI T1,FNCCRE
	TRNN T2,ATPCRE
	MOVEI T1,FNCSUP	;CHECK SUP OR CRE
	TRNN T2,ATPNDL	;IF NO DELETE SET, FORGET IT
	PUSHJ P,CHKPRV
	 JRST ENTER1	;CAN NOT DO IT
	SKIPL DRBALC(P4)	;SEE IF HE HAS ROOM
	SKIPG STRDDB+STRTAL		;AND IF ROOM ON DISK
	JRST ENTER2	;NO ROOM
	SKIPN	T1,DEV1UN(F)	;SPECIAL UNIT STUFF?
	JRST	.+3		;NO.
	SKIPG	UNITAL(T1)	;YES, ROOM ON SPECIAL UNIT?
	JRST	ENTER2		;NO.
	SETZM ATBSIZ(P2)
	SETZM ATBALP(P2)	;FORCE TO ZERO
EXTERN FBIT
	MOVEI	T1,FBIT
	HRRZ	T3,DEVATB(F)	;T3/ ATB ADDR OR 0 IF NO ATB.
	PUSHJ P,GETAPG
	JRST	ENTER2		;COULDN'T GET PAGE.
	MOVEM T2,ATBRIB(P2)
	MOVE T1,T2
	MOVEI PG,%RIB.C
	PUSHJ P,MAPWLN
	SETZM %RIB
	MOVE T1,[%RIB,,%RIB+1]
	BLT T1,%RIB+777	;ZERO ENTIRE RIB
	MOVEI T1,RIPSPP
	LDB T2,PJOBN
	MOVE T2,JBTPPN(T2)
	CAMN T2,DEVPPN(F)	;IS IT THE SAME PPN AS CREATOR
	IORM T1,%RIB+RIBSTS	;YES, SET BIT
	HRRZS ATBMSC(P2)
	MOVEI T1,ATPDIR
	TLNE M,UUOUFD
	IORM T1,ATBSTS(P2)
	PUSHJ P,SAVLIC
	HRRZM T1,ATBLIC(P2)	;PRESERVE WHAT WE CAN
;-MOVE PJC IN UPT TO RIB EXCEPT ON UFD'S
	MOVE T1,[%UPT+UPTPJC,,%RIB+RIBPJC]	;-
	TLNN M,UUOUFD				;-
	BLT T1,%RIB+RIBPJ2			;-
	SETZM	ATBPID(P2)	;CLEAR PID NOW, GETS SETUP AGAIN AT SETVAL
				; IF USER IS ALLOWED
	SETZM	%RIB+RIBPID
				;ATPPID CLEARED ABOVE, STORED INTO RIBLCW AT SETEN5.
	PUSHJ P,GETEXT
	LSH T1,-^D14
	DPB T1,ATYXCD	;SET EXTENDED DATE FIELD
	MOVEI P3,UUNATT(M)	;SET P2 TO POINT TO PRV WORD
	TLNE M,EXTUUO
	MOVEI P3,UUXPRV(M)
	TLNE M,EXTUUO	;IS IT EXTENDED UUO
	CAIL P1,UUXPRV	;AND SPECIFIED
	XCTFU <SKIPA T2,(P3)>	;NOT EXTENDED OR SPECIFIED
	MOVEI T2,0	;NOT SPECIFIED, USE 0
	TDNE T2,[37,,-1]	;TIME, DATE GIVEN?
	JRST	SETEN1		;YES
	LDB T1,ATYXCD		;GET EXTENDED DATE
	JUMPN T1,SETEN1		;SINCE IT ALSO COUNTS
	HLL P3,T2	;SAVE LEFT HALF OF T2
	PUSHJ	P,GETGMT##	;GET T1/TIME T2/DATE
	MOVE	T3,T2
	IDIV	T1,JFYSEC
	IDIVI 	T1,^D60		;GET SECONDS PART TOO
	DPB 	T2,ATYCSC	;SAVE SECONDS PART
	HRRZ	T2,T3
	ROT 	T2,-^D12
	DPB 	T2,ATYXCD	;SAVE HIGH PART OF DATE
	ROT 	T2,^D12		;AND GET DATE BACK
	HLL 	T2,P3		;GET LEFT HALF BACK
	DPB	T1,[POINT 11,T2,23] ;STORE TIME IN T2
SETEN1:	MOVEI T3,ATPSUP
	TDNN T3,ATBSTS(P2)	;IS IT SUPERSEDE
	JRST SETEN2		;NO, USE STANDARD IF NO PROT GIVEN
	MOVSI T3,777000		;YES, USE OLD IF NO PROT GIVEN
	AND T3,ATBPRV(P2)
	JRST SETEN3
SETEN2:	TLNE	M,UUOUFD	;CREATE, SET UP DEFAULT PROT. DIRECTORY FILE?
	SKIPA	T3,UFDPRT	;YES. USE UFD STANDARD PROTECTION
	MOVE	T3,STNPRT	;NO. USE REGULAR STANDARD PROTECTION
SETEN3:	TLNN	T2,777740	;PROTECTION  ALREADY GIVEN? (OR MODE IF 000 DESIRED)
	OR	T2,T3		;NO, SET STANDARD PROTECTION
	DPB	S,[POINT 4,T2,12] ;MODE
	LDB	T1,[POINT 12,T2,35] ;GET DATE
	LDB T3,ATYXCD
	DPB T3,[POINT 2,T1,23]	;GET ALL OF DATE
	CAMG T1,THSDAT		;IN THE FUTURE?
	JRST SETN3A		;NO
	MOVE T1,THSDAT
	DPB T1,[POINT 12,T2,35]
	LSH T1,-^D12
	DPB T1,ATYXCD		;IN FUTURE, SET TODAY
SETN3A:	TLNE M,EXTUUO	;IF NOT EXTENDED
	CAIL	P1,UUXPRV		;SAVE IN USERS AREA
	UMOVEM	T2,(P3)		; IF HE ASKED FOR IT
	MOVEM	T2,ATBPVW(P2)	;SAVE IN AKB
	TLNN	M,EXTUUO	;EXTENDED M?
	JRST SETEN4
	XCTBU <HRRZ T4,UUXEXT(M)>
	ANDI T4,37777		;GET ONLY ACCESS DATE
	SKIPE	T4		;IF NONE GIVEN
	CAMLE	T4,THSDAT	;OR IF GREATER THAN TODAY
SETEN4:	MOVE	T4,THSDAT	;USE TODAY'S DATE
	DPB T4,ATYADT		;STORE THE ACCESS DATE
	MOVE T2,ATBSTS(P2)
	TRNN T2,ATPCRE		;IS THIS A CREATE??
	TRO T4,400000	;NO, SET OLD FILE FLAG
	LDB T2,ATYXCD
	DPB T2,[POINT 2,T4,21]	;SAVE EXTENDED DATE INFO
	TLNN M,EXTUUO
	JRST SETN5A		;NOT EXTENDED
	XCTBU <HRRM T4,UUXEXT(M)>	;GIVE ARG TO USER
	PUSHJ P,SETVAL
	SKIPA
SETN5A:	 XCTBU <HRRM T4,UUNEXT(M)>
;HERE WHEN THE RIB BLOCK IS SET UP. INSERT CONSTANT VALUES, WRITE IT
SETEN5:	MOVE T2,ATBRIB(P2)	;GET RIB POINTER
	MOVEM	T2,%RIB+RIBSLF	;SAVE ADR AS LAST WORD OF RIB
	LDB	T3,PJOBN	;JOB NUMBER
	MOVE	T3,JBTAUN(T3)	;AUTHORS PRJ,PRG NUMBER
	SKIPN	%RIB+RIBAUT	;IF NO PRJ,PRG GIVEN
	MOVEM	T3,%RIB+RIBAUT	;STORE USERS PRJ,PRG
	MOVEI	T3,CODRIB	;CODE WORD SHOWING THIS BLOCK IS A RIB
	MOVEM	T3,%RIB+RIBCOD	;SAVE IN RIB BLOCK
	MOVEI T1,1
	MOVEM T1,%RIB+RIBSZS		;SET SPARE RIB SIZE
	MOVE	T4,ATBPVW(P2)	;PRIVS, DATE
	MOVEM	T4,%RIB+RIBPVW	;SAVE IN RIB
	MOVE T4,ATBLCW(P2)
	MOVEM T4,%RIB+RIBLCW
	MOVE T4,%RIB+RIBSTS
	TLO T4,RIPLOG
	TLNE	M,UUOUFD	;DIRECTORY FILE?
	TROA	T4,RIPDIR	;YES. SET A BIT IN RIBSTS
	TRZ T4,RIPDIR
	MOVEM	T4,%RIB+RIBSTS	
	DMOVE T1,DEVFIL(F)	;GET NAME AND EXTENSION
	HLR T2,ATBMSC(P2)	;ACCESS DATE AND EXTENDED DATE
	DMOVEM T1,%RIB+RIBNAM	;TO RIB
	MOVE T1,DEVPPN(F)
	MOVEM T1,%RIB+RIBPPN
	TLNN M,UUOUFD	;IS THIS A DIRECTORY
	JRST SETENA	;NO
	HRRZ T1,STRDDB+STRHSH	;MUST PUT A FEW NX PTRS THERE
	MOVEI T2,1		;THIS WILL DO
	MOVEM T2,%RIB+RIBPFS-1(T1)
	SOJG	T1,.-1
	HRRZ	T1,STRDDB+STRHSH
	IMULI	T1,1000
	MOVEM T1,ATBSIZ(P2)
SETENA:	PUSHJ	P,ZERDDB	;ALL 0 BUT NOT READ RIB BEFORE CREATE PNTRS
	AOS (P)
	MOVEI T1,DECENT
	DPB T1,DEYSTC
	MOVEM S,DEVIOS(F)
	JRST RELLOK		;NO RELEASE RIB

;GET PART OF AOLD LICENSE THAT CAN STILL BEE SET ON FILE

SAVLIC:	LDB T4,PJOBN	;GET SET TO PRESERVE LICENSE ON SUP
	HLLZ T2,JBTLIC(T4)
	MOVE T3,JBTPPN(T4)
	XOR T3,DEVPPN(F)
	HRRZ T1,ATBLIC(P2)	;WILL BE 0 FOR CRE, OLD FOR SUP OR UPD
	PJRST FILLIC
;SIMULTANEOUS UPDATE CHANIO COMES HERE.

USIMUP:	NOCHARGE	;DON'T CHARGE MICROCYCLES
	PUSHJ	P,TSTRES	;SETUP STACK FOR RETURN CHECK
	TLNN	F,LOOKB		;GUY HAD TO DO LOOKUP
	JRST	LUKER1		;HE DIDN'T, ILLEGAL SEQUENCE OF UUOS
	PUSHJ	P,ERNSET	;CHARGE ONE ENTER
	PUSHJ	P,CHKAG1	;CHECK ARGS, SETUP M
	  JRST	ILNMER		;ILLEGAL NAME ERROR
	TLO	M,UUOSIM	;SET THE FLAG FOR UPDATE
	JRST	UPDAT1		;AND JOIN COMMON CODE.

;HERE WHEN THE ENTER IS AN UPDATE (LOOKUP ALREADY DONE)
; OR FROM THE SIMULTANEOUS UPDATE CHANIO, ABOVE, WITH UUOSIM SET.
UPDATE:	PUSHJ P,CHKAG1	;CHECK ARGUMENTS NOW
	 JRST ILNMER	;SAY ILLEGAL NAME
UPDAT1:	PUSHJ P,WAIT1	;WAIT FOR I/O TO STOP
	PUSHJ P,GETCBR
	PUSHJ P,GETNAM
	CAME T1,DEVFIL(F)
	JRST UILNMD	;%  NAME DOES NOT MATCH
	PUSHJ P,GETEXT
	HLLZS T1	;% ONLY WANT LEFT HALF
	HLLZ T2,DEVEXT(F)
	CAME T1,T2
	JRST UILNMD
	PUSHJ P,GETPPN
	CAME T1,DEVPPN(F)
	JRST UILNMD
	HRRZ P2,DEVATB(F)
	HLRZ P4,DEVDRB(F)	;% LOAD POINTERS FOR PROTECTION CHECK ETC
	MOVE	T1,ATBRIB(P2)	;SET UP
	MOVEM	T1,DEVRIB(F)	;FOR
	SETOM	DEVFLO(F)	;TRUNCATION.
;% HERE WHEN THE NAME, EXTENSION AND PRJ,PRG AGREE WITH THE LOOKED-UP FILE
	MOVSI T1,NOWRT
	ANDCAM T1,DEVIAD(F)	;% TURN OFF IN CASE ON FROM BEFORE
	MOVEI T2,ATPNDL		;% DO NOT ALLOW IF UNDELETABLE
	MOVEI	T1,FNCAPP	;% CHECK TO SEE IF APPEND IS LEGAL
	TDNN T2,ATBSTS(P2)
	PUSHJ	P,CHKPRV	;% OK?
	  JRST	UPDER2		;% NO. ERROR
	MOVEI T1,FNCUPD		;% NOW CHECK IF APPEND OR UPDATE
	PUSHJ P,CHKPRV
	SKIPA
	JRST WRTOK
	MOVSI T1,NOWRT
	IORM T1,DEVIAD(F)		;% SET NO WRITE BIT
WRTOK:	MOVEI T1,DECSTP
	DPB T1,DEYSTC
	MOVE	T3,ATBSTS(P2)	;% FILE STATUS
	TRNE	T3,ATPDEL	;% IF FILE IS GOING TO GO AWAY
	JRST	UPDER3		;% GIVE BEING MODIFIED ERROR
	TLNN	M,UUOSIM	;% THIS SIMULTANEOUS UPDATE?
	JRST	WRTOK1		;% NO, MAKE SURE NO OTHER WRITERS.
	PUSHJ	P,TSTWRS	;% BOMB IF SINGLE UPDATER OR SUPERCEDE
	  JRST	UPDER3		;% BEING MODIFIED SOMEHOW.
	MOVEI	T2,ATPMXU	;% DON'T SET ATPUPD
	JRST	WRTOK2		;% GO SET MXU
WRTOK1:	PUSHJ	P,TSTWRT	;% SINGLE UPDATE, IF OTHER WRITERS,
	  JRST	UPDER3		;% GIVE FILE BEING MODIFIED.
	MOVEI T2,ATPUPD!ATPMXU	;% MAX WRITE COUNT IS ABOUT TO BE INCED
WRTOK2:	IORM T2,ATBSTS(P2)
	HRRZ	T3,ATBFNB(P2)
	AOS	FNBUPD(T3)
	AOS T3,ATBMWC(P2)	;% INCREMENT COUNT WHICH INCLUDES UPDATERS
	TRNN T3,ATMMWC		;% MAKE SURE IT DIDN'T TO TO ZERO (OVERFLOW)
	STOPCD(SLO)
	AOS T2,DRBCNT(P4)	;% COUNT ONE MORE IN UFB IN CASE CLOSE IN
	TRNE T2,DRPMXC	;% OVERFLOW?
	STOPCD(SLO)
	PUSHJ P,GIVCBR	;% NOW ALL FINISHED WITH CB
	MOVSI T1,ATMUFP-ATPALC-ATPPID	;ZERO PRIV UFD BITS
	ANDCAM T1,ATBLCW(P2)
	PUSHJ P,SAVLIC		;GET LIC HE CAN STILL HAVE
	HRRM T1,ATBLIC(P2)	;AND SAVE IT
	MOVE T1,THSDAT
	DPB T1,ATYADT		;UPDATE ACCESS DATE
	TLNN	M,EXTUUO	;NO. EXTENDED ENTER?
	JRST	UPDEN3		;NO
	CAIGE P1,UUXPRV
	JRST UPNSDT		;NOT SETTING DATE
	UMOVE T1,UUXPRV(M)
	UMOVE T2,UUXEXT(M)	;GET EXTENSION WORD
	TRNN T2,140000		;TO SEE IF EXTENDED DATE INFO
	TDNE T1,[37,,-1]	;SEE IF DATE, TIME GIVEN
	SKIPA
	JRST UPNSDT
	DPB T1,ATYCDT
	LSH T1,-^D12
	DPB T1,ATYCTM
	MOVEI T1,0
	DPB T1,ATYCSC		;IF HE SETS IT LATTER OK
	LSH T2,-^D14
	DPB T2,ATYXCD		;SAVE EXTENDED DATE INFO
UPDTDN:	MOVE T1,ATBPVW(P2)
	CAIL P1,UUXPRV
	UMOVEM T1,UUXPRV(M)	;TELL THE USER
	HLRZ T1,ATBMSC(P2)
	XCTBU <HRRM T1,UUXEXT(M)>
	CAIGE P1,UUXSIZ
	JRST UPDTD2	;CAN NOT POSSIBLE WANT SIZE BACK
	MOVE T1,ATBSIZ(P2)
	TRNE T1,177
	SUBI T1,200	;ADJUST TO WORDS
	UMOVEM T1,UUXSIZ(M)	;AND GIVE IT TO USER
UPDTD2:	CAIGE	P1,UUXALC	;SPECIFYING ALLOCATION?
	JRST	UPDEND		;NO. TAKE GOOD RETURN.
	PUSHJ	P,ALCCHK	;MAYBE.
	JRST	UPDEND		;NO.
	JRST	DELGRP		;YES.

;HERE ON 4-WORD UPDATE   SET UP SIZE IN E+3
UPDEN3:	MOVE T1,ATBSIZ(P2)	;GET NUMBER OF WORDS IN FILE
	TRNE T1,177
	SUBI T1,200
	CAIG T1,400000
	JRST	[MOVNS T1
		JRST UPDEN4]
	LSH T1,-BLKLSH
UPDEN4:	 XCTBU <HRLZM T1,UUNPPN(M)>	;IN LH (E+3)
UPNSDT:	PUSHJ	P,GETGMT	;GET T1/TIME T2/DATE
	DPB 	T2,ATYCDT	;UPDATE 'CREATION' TIME
	LSH 	T2,-^D12
	DPB 	T2,ATYXCD
	IDIV 	T1,JFYSEC
	IDIVI 	T1,^D60
	DPB 	T1,ATYCTM
	DPB 	T2,ATYCSC
	TLNE M,EXTUUO
	JRST UPDTDN
	MOVE T1,ATBPVW(P2)
	UMOVEM T1,UUNATT(M)
	HLRZ T1,ATBMSC(P2)
	XCTBU <HRRM T1,UUNEXT(M)>
	JRST UPDEND		;MUST GO CLEAR LICENSE.

;SMALL SUBR TO SEE IF A FILE SHOULD BE TRUNCATED.
;EXPECTS P2/ ATB ADDRESS.
;DESTROYS T2 AND T3.
;NON-SKIP RETURNS IF CHANGE OF ALLOCATION IS NOT REQUESTED OR
;IF REQUEST IS >= ACTUAL SIZE.  ELSE SKIP RETURNS WITH 
;T2/ UUXALC IN UNITS OF WORDS.
ALCCHK:	UMOVE	T3,UUXNUM(M)	;IS TRUNCATION
	XCTFU	<SKIPN T2,UUXALC(M)> ;BEING
	TRNE	T3,UUPWDS	;REQUESTED?
	JRST	.+2		;YES.
	POPJ	P,		;NO.
	JUMPL	T2,CPOPJ	;
	TRNN	T3,UUPWDS	;IS UUXALC IN WORDS?
	JRST	[CAMLE T2,[XWD 1777,-1] ;NO, SO WE MUST
		POPJ P,		;CONVERT IT FROM BLOCKS.
		LSH T2,BLKLSH	;(WON'T OVERFLOW, SINCE WE
		JRST .+1]	;JUST CHECKED FOR THAT.).
	MOVE	T3,ATBSIZ(P2)	;GET THE ACTUAL FILE
	TRNE	T3,177		;SIZE IN
	SUBI	T3,200		;WORDS.
	CAMGE	T2,T3		;ACTUALLY WANT TO TRUNCATE?
	AOS	(P)		;YES.
	POPJ	P,		;NO.
DELGRP:	MOVEI T1,FNCTRN		;CAN WE TRUNCATE?
	PUSHJ P,CHKPRV
	 JRST UPDEND		;NO
	UMOVE T2,UUXALC(M)	;GET
	UMOVE	T1,UUXNUM(M)	;T2
	TRNN	T1,UUPWDS	;IN
	LSH	T2,BLKLSH	;WORDS.
	TLO M,UUOENT		;DELETE THINGS FROM RIB.
	PUSHJ P,DLTTRC		;FLAG SO WE NEED RB2DDB NEEDED.
	JRST	UPDND3		;ERROR ON TRUNCATION, BAD FILE NOW.
	JRST UPDEN2		;NOW HAVE PRIME RIB IN CORE, FINISH UP

UPDEND:	PUSHJ P,RIBWTL
	 JRST UPDND3
	MOVEI	T1,FNCCAT	;CAN HE CHANGE ATTRIBUTES?
	PUSHJ	P,CHKPRV
	  SETZ	P1,		;CAN'T TOUCH ATTRIBUTES, MAKE SETVAL DO NOTHING.
UPDEN2:	SETZM	ATBPID(P2)	;CLEAR PID AND BIT THAT SAYS THERE IS ONE
	SETZM	%RIB+RIBPID	;IN CASE NO VALID PID SPECIFIED.
	MOVSI	T1,ATPPID	;CLEAR BIT THAT SAYS THERE'S A PID
	ANDCAB	T1,ATBLCW(P2)	;STORE LICENSE NOW SO THAT SOMEONE DOESN'T
				; CHANGE CONTENTS OF LICENSED FILE WHILE
				; ITS BEING UPDATED AND STILL HAVE LICENSE
				; UNTIL CLOSE. (ALSO STORE ATPPID=RIPPID)
	MOVEM	T1,%RIB+RIBLCW
	TLNE	M,EXTUUO	;IF EXTENDED UUO, CALL SETVAL. (ELSE ALL DONE SETTING THINGS.)
	PUSHJ P,SETVAL
	TLNE M,UUOENT
	PUSHJ	P,INVDDB		;NEEDED IF PAGES DELETED
UPDEN5:	PUSHJ P,RELLOK		;NOW RELEASE RIB
UPDND4:	AOS (P)		;AND FALL INTO SETAPN
	MOVEI T1,DECUPD
	DPB T1,DEYSTC
	MOVEM S,DEVIOS(F)

SETAPN:	LDB T1,ATYBLK		;GET BLOCKS CURRENTLY IN FILE
	HRRZ T2,ATBFNB(P2)
	MOVEM T1,FNBAPD(T2)	;AND STORE IN CASE APPEND ONLY
	POPJ P,

UPDND3:	TLNE M,UUOENT
	PUSHJ P,INVDDB	;INVALIDATE THE DDB, SET FILE LOC TO START.
	JRST UPDND4	;COULD NOT GET RIB TO UPDATE
;CHECK ARGUMENT LIST AND TAKE CARE OF USER NAME INSTEAD OF PPN

CHKARG:	MOVSI S,IOSERR		;RESET SOME EXTRA BITS
	ANDCAB	S,DEVIOS(F)
	SKIPA T2,[<NORED!NOWRT!PIDACC>,,0] ;BITS TO CLEAR IN DEVIAD
CHKAG1:	MOVSI T2,PIDACC
	ANDCAM T2,DEVIAD(F)
	TLZ M,UUOMSK
	UMOVE P1,(M)		;GET COUNT OR NAME
	TLNN P1,-1	;SEE IF EXTENDED
	JRST CHKAGX	;YES
	PUSH P,M	;SAVE ARG POINTER (IN CASE EXTENDED)
CHKPPN:	XCTBU <MOVES T1,UUNPPN(M)> ;MAKE SURE CAN WRITE IN THIS
	JUMPLE T1,[LDB T3,PJOBN
		MOVE T1,JBTPPN(T3)	;USE JOBS IF 0 OR NEG
		JRST CHKPP1]
	TLNN T1,-1	;IS IT USER NAME?
	PUSHJ P,LOKLUD
CHKPP1:	TLNN F,SYSDEV	;SYS?
	JRST CHKPP2	;NO
	CAME T1,MFDPPN
	MOVE T1,SYSPPN	;USE SYS PPN UNLESS MFD PPN
CHKPP2:	UMOVEM T1,UUNPPN(M)	;SAVE FOR USER
	POP P,M
	JRST CPOPJ1

CHKAGX:	MOVSI T1,PIDACC		;GET READY TO SET
	TRNE P1,UUPPID		;CALER ASKING FOR PID ACCESS?
	IORM T1,DEVIAD(F)	;YES, SET BIT FOR CHKPRV
	ANDI P1,777		;MASK TO COUNT FIELD
	CAILE P1,UUXENT
	MOVEI P1,UUXENT		;MUST NOT BE TOO BIG
	JUMPE P1,CPOPJ1		;NOT REALLY EXTENDED, JUST 0 NAME
	TLO M,EXTUUO	;MARK EXTENDED UNLESS 0 NAME
	CAIGE P1,3	;BUT MUST BE AT LEAST 3
	POPJ P,		;OR ERROR
	HRRZ T1,M
	ADD T1,P1
	XCTBU <MOVES (M)>	;MAKE SURE CAN WRITE IN FIRST AND LAST
	XCTFU <MOVES (T1)>	;WORDS (ASSUMES LOOKUP BLOCK LESS THAN 1 PAGE LONG)
	PUSH P,M	;SAVE ARG
	SUBI M,UUNPPN-UUXPPN	;CORRECT M FOR EXTENDED PPN
	JRST CHKPPN	;AND GO TAKE CARE OF IT

;ROUTINES TO GET THE VARIOUS ARGS

GETNAM:	TLNN M,EXTUUO
	XCTFU <SKIPA T1,UUNNAM(M)>
	UMOVE T1,UUXNAM(M)
	POPJ P,		;NAME
GETEXT:	TLNN M,EXTUUO
	XCTFU <SKIPA T1,UUNEXT(M)>
	UMOVE T1,UUXEXT(M)
	POPJ P,

GETPPN:	TLNN M,EXTUUO
	XCTFU <SKIPA T1,UUNPPN(M)>
	UMOVE T1,UUXPPN(M)
	POPJ P,

;SET UF DEVFIL, DEVEXT, DEVPPN, LEAVE PPN IN T1

SETFIL:	PUSHJ P,GETNAM
	JUMPE T1,CPOPJ	;GERROR IF NAME 0
	MOVEM T1,DEVFIL(F)
	PUSHJ P,GETEXT
	HLLM T1,DEVEXT(F)
	PUSHJ P,GETPPN
	MOVEM T1,DEVPPN(F)
	JRST CPOPJ1
;LOOPUP USER NAME IN THE LUD FILE IF SPECIFIED INSTEAD OF PPN

LOKLUD:	 XCTBU <DMOVE T2,(T1)>	;GET USER NAME
	PUSH P,T1
	PUSH P,M
	MOVE T1,HIGHJB
LOKLU2:	CAMN T2,JBTUNM(T1)
	JRST LOKLU1	;FOUND ONE FOR A CURRENT JOB
LOKLU3:	SOJG T1,LOKLU2
	PUSHJ P,GETCBR	;NOT FOR A CURRENT JOB, NEED TO SEARCH CORE
	MOVEI T1,SYSDRB-DRBLNK	;POINTER TO FIRST PLACE
	JRST LOKLL4	;NOW START UP

LOKLL3:	CAMN T2,DRBUNM(T1)	;CHECK TO SEE IF LIST MATCH
	JRST LOKLL1	;POSSIBLE
LOKLL4:	HLRZ T1,DRBLNK(T1)
	JUMPN T1,LOKLL3	;CONTINUE SEARCHING
	PUSHJ P,GIVCBR
	JRST LOKLL5

LOKLU1:	CAME T3,JBTUN1(T1)
	JRST LOKLU3
	MOVE T1,JBTAUN(T1)
	POP P,M
	POP P,T2
	POPJ P,

LOKLL1:	CAME T3,DRBUN1(T1)
	JRST LOKLL4
	MOVE T1,DRBNAM(T1)	;GET PPN
	POP P,M
	POP P,T2
	PJRST GIVCBR
LOKLL5:	PUSH P,F
	MOVEM S,DEVIOS(F)	;MAKE SURE THIS STAYS AROUND
	MOVEI F,DSKDDB	;GET A DDB
	MOVSI T1,'DSK'
	PUSHJ P,SETDDB
	 JRST LUDER2		;CAN NOT GET DDB
	MOVE T1,JOB
	DPB T1,PJOBN
	MOVEI T1,ASSPRG
	IORM T1,DEVMOD(F)
	PUSH P,%UPT+UPTJDA(W)	;REPLACE HIS POINTER
	MOVEM F,%UPT+UPTJDA(W)
	MOVSI T2,'LUD'
	MOVEM T2,DEVFIL(F)
	MOVEI T2,'SYS'
	HRLM T2,DEVEXT(F)
	MOVSI M,UUOLUK
	MOVE T1,SYSPPN
	MOVEM T1,DEVPPN(F)
	SETOM	DEVFLO(F)		;
	PUSHJ P,SRCFIL
	JRST	LUDER0
	TLZE S,IOSRIB
	PUSHJ P,RELLOK	;MAKE SURE WE DON'T HAVE RIB
	MOVE T1,[555555555555]
	MOVEM T1,X
	MOVE T1,[361275431652]
	MOVEM T1,X+1
	MOVE T1,[612754316523]
	MOVEM T1,X+2
	MOVE T3,-3(P)
	UMOVE T1,(T3)
	MOVEM T1,N
	UMOVE T1,1(T3)
	MOVEM T1,N+1	;GET USER NAME
	MOVEI T3,0
	REPEAT 4,<PUSHJ P,RND>
	MOVE T1,X+2
	XOR T1,X+1
	MOVE T2,X
	XOR T2,T1
	PUSH P,P1
	PUSH P,T2	;THE HASHED USER NAME
	TLZ T1,400000
	IDIVI T1,LUDHSH
	TLZ S,IOSRIB!IOSRBE!IO
	MOVEI P1,100	;DO NOT LINK FOREVER
	JRST USRUSI	;GO GET THAT BLOCK

RND:	MOVE T1,N
	MOVE T2,N+1
	ADDM T1,X+1
	ROTC T1,-22
	MOVEM T1,N
	MOVEM T2,N+1
	MOVEI T4,5
RND1:	MOVE T1,X+1(T3)
	MUL T1,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
	ADDM T2,X+2(T3)
	AOJE T3,RND2
	MOVNI T3,1
	MOVE T1,X+1
	TRNE T1,1
	SKIPL X+2
	MOVEI T3,0
	MOVE T1,X
	EXCH T1,X+2
	MOVEM T1,X
RND2:	SOJG T4,RND1
	POPJ P,

LUDHSH==^D887
LHUN==4		;RELATIVE LOC OF HASHED USER NAME
LPPN==0		;PPN
LLINK==2	;SIZE OF ENTRY
OPDEF VREMOV [CALLI -65]
OPDEF PERSET [CALLI -72]

EXTERN PE.NER

MAPID==35	;CHANIO VMAP FUNCTION NO.
EXTERN CPRRED,FALHOL,FALPHP,%COW,%COW.N,PE.NER

USRUSI:	TLO	F,LOOKB		;FOOL MAP.
	MOVEM	F,%UPT+UPTJDA(W)
	PUSH	P,T2		;SAVE DESIRED BLOCK NUMBER.
	MOVE	T1,[<CPRRED>B7+1B17+%COW.N+<CNVVPN>]
	LSH	T2,-BLKSPP	;MAP IN THAT
	ADDI	T2,1		;COMES AS 0,1,2,3.
	HRRZI	T3,(W)		;PAGE OF
	HRLI	T3,MAPID	;THE
	CHANIO	T3,T1		;FILE.
	JRST	.+2		;LOST.
	JRST	USRUS2		;WON.
	TLZ	F,LOOKB		;
	MOVEM	F,%UPT+UPTJDA(W)
	POP	P,T1		;CLEAR PD A LITTLE.
	HRRZI	T3,(T3)		;GET T3/ ERROR CODE.
	CAIE	T3,FALHOL	;
	CAIN	T3,FALPHP	;
	JRST	LUDER1		;
	STOPCD(SLO)
USRUS2:	MOVE	T1,[PE.NER+1,,%COW.N+CNVVPN] ;SET IGNORE ERROR BIT
	PERSET	T1,		; (OLD PCB CODE IGNORED ERRORS TOO)
	  STOPCD(SLO)		;NOT SUPPOSED TO FAIL.
	TLZ	F,LOOKB		;
	MOVEM	F,%UPT+UPTJDA(W)
	POP	P,T1		;
	ANDI	T1,3		;
	LSH	T1,BLKLSH
	HRLI	T1,-200
SRUSR:	MOVE	T2,%COW+LHUN(T1) ;GET THE HASHED USER NAME.
	CAMN	T2,(P)
	JRST	FUNM		;FOUND IT.
	SKIPG	T2,%COW+LPPN(T1)
	JRST	BLKLNK		;END OR A LINK.
	MOVE	T2,%COW+LLINK(T1)
	ANDI	T2,177
	HRLS	T2
	ADD	T1,T2
	JUMPL	T1,SRUSR
	MOVE	T1,[XWD 1,%COW.N+CNVVPN] ;
	VREMOV	T1,
	STOPCD(SLO)
	JRST	LUDER1		;RAN OUT OF BUFFER.

BLKLNK:	MOVE	T1,[XWD 1,%COW.N+CNVVPN] ;
	VREMOV	T1,
	STOPCD(SLO)
	JUMPE	T2,LUDER1	;
	SOJGE	P1,USRUSI	;MAKE SURE WE ARE NOT LOOPING.
	JRST	LUDER1

FUNM:	POP	P,T2
	POP	P,P1
	MOVE	M,%COW+LPPN(T1)
	PUSHJ	P,UNLFIL	;
	MOVE	T1,[XWD 1,%COW.N+CNVVPN] ;
	VREMOV	T1,
	STOPCD(SLO)
	PUSHJ	P,GETCBR	;NOW NEED TO ADD TO LIST
	HLRZ	T2,SYSDRB
	MOVEI	T3,SYSDRB-DRBLNK ;SET TO SEARCH DRB
	MOVE	T1,M		;GET PPN
	PUSHJ	P,SRCNAM
	JUMPLE	T2,[MOVEM M,-3(P)	;NO CORE
		JRST FUNM1]
	EXCH	M,-3(P)		;ADDRESS OF USER NAME
	XCTBU	<DMOVE T3,(M)>
	DMOVEM	T3,DRBUNM(T2)
FUNM1:	PUSHJ	P,GIVCBR
LUDERR:	MOVEI M,0
	TLO F,INPB!LOOKB	;FLAG SO A.T. NOT DELETED
	PUSHJ P,CLOSIN
	PUSHJ P,CLRDDB
LUDER0:	POP P,%UPT+UPTJDA(W)	;THE PUSHED UPTJDA WORD
	POP P,F
	MOVE S,DEVIOS(F)	;RESTORE IOS
	POP P,M
	PJRST TPOPJ

LUDER1:	PUSHJ	P,UNLFIL	;
	POP P,T1
	POP P,P1
	JRST LUDERR

LUDER2:	POP P,F
	POP P,M
	PJRST TPOPJ

X:	BLOCK 3
N:	BLOCK 2
;ROUTINE TO CHARGE FOR 1 LOOKUP-ENTER

EXTERN GTCGSZ
LKSET:	LDB J,PJOBN
	PUSHJ	P,GTCGSZ	;GET CHARGING SIZE OF JOB.
	AOS JBTDLK(J)
	AOS JBTDLK		;ACCUMULATE TOTAL IN JOB 0
	ADDM T1,JBTSLK(J)
	ADDM T1,JBTSLK
	POPJ P,

;SIMILAR ROUTINE TO CHARGE FOR USETI'S, AND USETO'S

ERNSET:	LDB J,PJOBN
	PUSHJ	P,GTCGSZ
	AOS JBTERN(J)
	AOS JBTERN
	ADDM T1,JBTSER(J)
	ADDM T1,JBTSER
	POPJ P,
SUBTTL	RENAME
RENAM:	NOCHARGE
	PUSHJ P,WAIT1	;WAIT FOR I/O TO STOP
	PUSHJ P,TSTRES
	TLNE	S,IOSUPR
	JRST	LUKER1
	PUSHJ P,ERNSET		;CHARGE 1 RENAME
	TLZ S,IOSRIB
	PUSHJ P,CHKAG1		;CHECK ARGUMENTS
	 JRST ILNMER		;BAD COUNT FOR EXTENDED
	SKIPN	DEVFIL(F)	;IS THERE AN OPEN FILE?
	JRST	RENER0		;NO. ERROR RETURN
	TLNE F,ENTRB		;IS IT OPEN FOR OUTPUT
	TLNE F,OCLOSB
	JRST RECLSD		;NO
	PUSH P,M
	HRRI M,CLSIN	;CLOSE ONLY OUTPUT
	PUSHJ P,CLOSE1		;YES, CLOSE IT
	POP P,M
RECLSD:	TLZ S,IOSRIB	;JUST TO MAKE SURE
	HRRZ	P2,DEVATB(F)	;LOC OF ACCES BLOCK
	JUMPN	P2,RENAM1	;DONT HAVE TO LOOKUP IF THERE
	TLO	M,UUOLUK	;INDICATE LOOKUP FOR FNDFIL
	PUSHJ	P,GETNAM	;GET FILE NAME RENAMING TO
	SKIPN	T1		;IF TRYING TO DELETE,
	TLO	M,UUOIRE	;THEN IGNORE RIB ERROR, USE INFO FROM UFD FOR ACCESS CHECKING.
				; (SRCFIL WILL GIVE SKIP RETURN FOR RIB ERRORS TOO WHEN THIS IS ON.)
	MOVEI T1,DECSTP
	DPB T1,DEYSTC
	PUSHJ	P,SRCFIL	;SET UP AN ACCESS BLOCK FOR IT
	  JRST	STRERR		;ERROR - RETURN
	TLZE S,IOSRIB	;GIVE IT BACK IN CASE RETURNED WITH IT
	PUSHJ P,RELLOK
	TLZ M,UUOMSK-EXTUUO	;RESET ALL BITS BUT EXTENDED UUO
	PUSHJ	P,RENAM0	;GO DO REST OF RENAME
	  PJRST	CLOSIN		;ERROR - FIX UP ACCESS TABLE
				;(UUOCON WONT DO A CLOSE SINCE THE RENAME FAILED)
	PJRST	CPOPJ1		;GOOD RETURN
RENAM0:	TLO	F,LOOKB		;SET SO CLOSE INPUT WILL HAPPEN
	TLZ	F,OCLOSB+ICLOSB
	HRRZ	P2,DEVATB(F)	;LOC OF A.T. INTO P2

RENAM1:	PUSHJ P,GETCBR
	MOVE	T1,ATBRIB(P2)	;
	MOVEM	T1,DEVRIB(F)	;
	MOVE T1,ATBSTS(P2)
	TRNE T1,ATPNDL
	JRST UPDER2		;% CAN NOT BE DELETED
	TLO	M,UUOREN 	;% LIGHT UUOREN
	PUSHJ P,GETNAM	;% GET FILE NAME
	JUMPN T1,RENAM3	;% NON-ZERO, DO NOT DELETE
;HERE WHEN RENAMING A FILE TO 0 (DELETING)
RENAM2:	HLRZ	P4,DEVDRB(F)
	MOVEI	T1,FNCDEL
	PUSHJ	P,CHKPRV
	   JRST UPDER2		;% NO. ERROR RETURN
	PUSHJ	P,TSTWRT	;DO NOT ALLOW IF SOMEONE WRITING
	  JRST UPDER3		;% BEING UPDATED, ERROR
	MOVEI	T1,DECSTP
	DPB	T1,DEYSTC
	MOVE	T1,ATBSTS(P2)
	TRNN	T1,ATPDIR	;% DIRECTORY IS SPECIAL
	JRST	RENM2A
	MOVE	T1,DEVFIL(F)
	PUSHJ	P,FNDDRB	;% FIND THIS DIRECTORY BLOCK
	  JRST RENM2B		;% NOT THERE
	MOVE	T1,DRBCNT(T2)
	TRNE	T1,DRMCNT		;% IS COUNT UP?
	JRST	UPDER3		;% YES, CAN NOT DELETE
	SETZM	DRBRIB(T2)
	MOVEI	T1,DRPNX
	IORM	T1,DRBNX(T2)	;AND FALG NOT THERE
RENM2B:	MOVE	T1,ATBSTS(P2)
RENM2A:	TLZ	F,LOOKB		;ZERO LOOKB SO A FOLLOWING ENTER WILL SUCCEED
	HLLM	F,%UPT+UPTJDA(W) ;UUOCON WONT SAVE LH(F)
	TRNE	T1,ATPDEL	;%IF ALREADY MARKED FOR DELETE,
	JRST	RENM2C		;% GO DO INPUT CLOSE, ETC.
	TRO	T1,ATPUPD	;%SET UPD SO NO ONE ELSE CAN MODIFY, JUST READ
	MOVEM	T1,ATBSTS(P2)
	HRRZ	P3,ATBFNB(P2)	;% GET FNB ADDRESS FOR DLTNAM
	PUSHJ	P,GIVCBR
	PUSHJ	P,SETACH	;SET CHANGED BIT IN CASE UFD PAGE DOESN'T MAKE IT OUT BEFORE SYSTEM CRASH
	PUSHJ	P,DLTNAM	;REMOVE NAME FROM UFD
	HLLZS	M		;NO ONE ELSE CAN MAKE NEW UFD ENTRY SINCE ATPUPD IS ON
	PUSHJ	P,SIMRLS	;EXPECTS F,S,W; CLEAN UP SIMIO DATABASE
				;MAY SET IODTER IF VREMOV FAILURE,OUTPUT
	PUSHJ	P,GETCBR
	MOVSI	T1,FNPNX
	IORM	T1,FNBNX(P3)	;% TELL WORLD IT DOESN'T EXIST NOW.
	SETZM	FNBRIB(P3)	;% CLEAR SO HAS TO SCAN UFD AGAIN.
	MOVEI	T1,ATPDEL!ATPUPD
				;% (DEL CAN'T GO ON SINCE UPD IS ON.)
	XORB	T1,ATBSTS(P2)	;% TURN ON DEL, TURN OFF UPD
	JRST	RENM2D
RENM2C:	PUSHJ	P,GIVCBR
	PUSHJ	P,SIMRLS	;CLEAN UP SIMIO DATABASE
	PUSHJ	P,GETCBR
RENM2D:	AOS	(P)		;% GIVE SKIP RETURN TO THE RENAME UUO
	TLNN	S,IOSRBE	;% IF RIB ERROR, BETTER CHECK FOR OTHER USER
	PJRST	CLOSRN		;% JUMP INTO THE CLOSE CODE TO FINISH UP
				;% ASSUME IF THERE IS A RIB ERROR THAT CLOSE WILL IGNORE IT - WHICH RESULTS IN LOST PAGES.
	TRNE	T1,ATMCNT-1	;% IF LAST READER, NO NEW ONES CAN COME,
	JRST	CLSIN3		;% WE KNOW ATPDEL SET AND OTHER USERS, SO
				;% GO DO NORMAL CLOSE, LAST USER WILL DELETE THE FILE IN INPUT CLOSE
				;% (ATBRIB HAS TO BE NON-ZERO IF OTHER USER?
	PUSHJ	P,GIVCBR 	;% SO GIVE BACK CB AND
	JRST	CLIBDR		;GET RID OF ATB IF NO MAPPERS.
				;% NOTE THAT WE SKIP AROUND TRYING TO GET RIB IN CLOSE.
				;% NOTE THAT ATBRIB CAN BE ZERO IN RIB ERROR CASE!
				;% CODE THAT WE CALL HERE IN CLOSE HAD BETTER
				;% NOT CALL ANYTHING THAT NEEDS ATBRIB.
;HERE TO RENAME A FILE TO SOMETHING (NOT DELETE)
RENAM3:	MOVE T3,ATBSTS(P2)
	TRNN T3,ATPDEL	;% MUST NOT BE MARKED FOR DEL
	PUSHJ P,TSTWRT
	JRST UPDER3	;% BEING WRITTEN
	MOVEI T1,DECSTP
	DPB T1,DEYSTC
	MOVEI T1,ATPREN
	IORM T1,ATBSTS(P2)	;% SET RENAME
	HLRZ P4,DEVDRB(F)
	AOS T2,DRBCNT(P4)	;% ONE EXTR COUNT
	TRNE T2,DRPMXC
	STOPCD(SLO)
	PUSHJ P,GETPPN
	CAME	T1,DEVPPN(F)	;% YES. CHANGING PPN?
	JRST	RENM4B		;% YES.
	PUSHJ P,GETNAM
	CAME	T1,DEVFIL(F)	;% RENAMING TO SAME NAME?
	JRST	RENAM4		;% NO
	PUSHJ P,GETEXT
	HLLZS T1
	HLLZ	T2,DEVEXT(F)	;% OLD EXTENSION
	CAMN	T1,T2		;% SAME?
	JRST	RENAM6		;% YES

RENAM4:	SKIPA	T1,[FNCCNM]
RENM4B:	MOVEI	T1,FNCDEL	;% CHANGING DIRECTORIES
	PUSHJ	P,CHKPRV	;
	  JRST	RENER7		;
;% HERE WHEN RENAME HAS BEEN CHECKED (IF CHANGING DIRECTORIES)
RENM4A:	PUSHJ P,SETFIL	;% SET NAME INTO DEVFIL ETC
	 STOPCD(SLO)		;% ALREADY KNOW NAME NON-0
	PUSHJ P,GIVCBR
	PUSHJ	P,SRCFIL	;CHECK THAT NEW FILE NAME DOESN'T EXIST
	  JRST	RENER9		;NEW FILE NAME ALREADY EXISTS
	TLO M,UUOENT	;FLAG THIS SO WE KNOW NAME CHANGE
	HLRZ T1,DEVDRB(F)
	CAME T1,P4
	TLZ M,UUOREN	;REN ON IF NO DIR CHANGE
	PUSHJ P,RENNMR
	HRRZ T1,DEVATB(F)	;NEW ATB
	HRRM P2,DEVATB(F)	;PUT BACK OLD
	HLL T1,DEVDRB(F)
	HRLM P4,DEVDRB(F)
	MOVEM T1,ATBDOR(P2)	;CROSS LINK THROUGH ATBDOR
	HRRM P2,ATBDOR(T1)
	HRLM P4,ATBDOR(T1)
	PUSHJ P,RIBWTL
	 JRST RENRR2	;ERROR READING RIB
	TLNE M,UUOREN
	JRST RENAM7	;NOT CHANGING DIRECTORY
	HLRZ P4,ATBDOR(P2)
	HRRZ P2,ATBDOR(P2)
	PUSHJ P,RENNMR
	MOVEI T1,FNCCRE
	PUSHJ P,CHKPRV	;CAN WE CREATE IN NEW DIRECTORY?
	 JRST RENRR1	;NO
	HRRZ P2,DEVATB(F)
	HLRZ P4,DEVDRB(F)
	PUSHJ P,RENNMR
	HLRZ T1,ATBDOR(P2)
	MOVN T2,ATBALP(P2)	;FILE SIZE
	ADD T2,DRBALC(T1)
	CAMGE T2,STRDDB+STROVR
	JRST RENRR0	;NO ROOM IN NEW DIRECTORY
	MOVEM T2,DRBALC(T1)
	CAMGE T2,DRBMXA(T1)
	MOVEM T2,DRBMXA(T1)
	MOVE T1,ATBALP(P2)
	ADD T1,DRBALC(P4)
	SKIPL DRBALC(P4)	;DO NOT LET IT OVERFLOW
	SKIPL T1
	MOVEM T1,DRBALC(P4)
	PUSHJ P,SAVLIC
	HRRM T1,ATBLIC(P2)
	HRLOI T1,ATMUFP!ATMCSC	;SAVE UNPROTECTED PART OF UFD BITS
	ANDM T1,ATBLCW(P2)
;NOW INTERCHANGE THE ATB ETC
RENAM7:	PUSHJ P,GETCBR
	LDB T1,ATYCNT		;% GET COUNT IN OLD ATB
	MOVSI T2,ATMUMC		;% IF UMC IS NON-ZERO, THEN DRBCNT
	TDNE T2,ATBUMC(P2)	;% WAS INCREMENTED ONCE FOR IT
	ADDI T1,1		;% SO CAUSE DRBCNT TO GET INCREMENTED AND DECREMENTED CORRECTLY
	HLRZ T2,ATBDOR(P2)	;% NEW DRB
	MOVE T3,T1
	ADDB T3,DRBCNT(T2)
	TRNE T3,DRPMXC
	STOPCD(SLO)
	MOVNS T1
	ADDB T1,DRBCNT(P4)	;DECREMENT OLDCOUNT
	TRNE T1,DRPMXC
	STOPCD(SLO)
	HRRZ T4,ATBDOR(P2)
	HLL T1,ATBLNK(P2)	;OLD LINK
	HLL T2,ATBLNK(T4)	;NEW LINK
	HLLM T1,ATBLNK(T4)
	HLLM T2,ATBLNK(P2)	;INTERCHANGE
	HRRZ	T1,ATBFNB(T4)	;GET OLD FNB ADDRESS
	MOVE	T1,FNBALT(T1)	;GET OLD ALT
	MOVEM	T1,FNBALT(P3)	;AND PUT IT INTO NEW FNB
	DMOVE T1,ATBSIZ(P2)
	DMOVEM T1,ATBSIZ(T4)	;MOVE SOME INFORMATION
	MOVE T1,ATBALP(P2)
	MOVEM T1,ATBALP(T4)
	MOVE T1,ATBLCW(P2)
	MOVEM T1,ATBLCW(T4)
	HLL T1,ATBMSC(P2)
	HLLM T1,ATBMSC(T4)
	MOVEI T1,FNBATB-ATBLNK(P3)
RNM7A:	HLRZ T2,ATBLNK(T1)
	SKIPN T2
	STOPCD(SLO)
	CAIE T2,(P2)	;FOUNT POINTER TO CURRENT?
	JRST RNM7A
	HRLM T4,ATBLNK(T1)	;POINT TO NEW
	HRRZ T1,ATBFNB(T4)
	HRRM T1,ATBFNB(P2)	;REPLACE BACK POINTER WHILE WE HAVE IT
	MOVEI T1,FNBATB-ATBLNK(T1)
RNM7B:	HLRZ T2,ATBLNK(T1)
	SKIPN T2
	STOPCD(SLO)
	CAIE T2,(T4)
	JRST RNM7B
	HRLM P2,ATBLNK(T1)
	HRRM P3,ATBFNB(T4)	;AND OTHER BACK POINTER
	HRL T4,P4
	HLRZ P4,ATBDOR(P2)
	HLLM T4,ATBDOR(P2)	;NOW NEED TO RESET ATBDOR LINKS
	HRLM P4,ATBDOR(T4)	;ALSO
	HRRM P2,DEVATB(F)
	HRLM P4,DEVATB(F)	;NOW HAVE THE NEW ONE
	HRRZ P3,ATBFNB(P2)
	MOVE T1,FNBNAM(P3)
	MOVEM T1,DEVFIL(F)
	MOVEM T1,%RIB+RIBNAM
	MOVE T1,FNBEXT(P3)
	HRLM T1,DEVEXT(F)
	HRLM T1,%RIB+RIBEXT
	MOVE T1,DRBNAM(P4)	;RESET ALL NAMES
	MOVEM T1,DEVPPN(F)
	MOVEM T1,%RIB+RIBPPN
	HRRZ T3,ATBDOR(P2)	;GET OLD FNB
	HRRZ T3,ATBFNB(T3)
	MOVEI T1,FNBDBL-DEVDBL(T3)	;GET SET TO RELINK DDBS
	HRRZ T3,FNBDBL(T3)
DBRLP:	HRRZ T2,DEVATB(T3)
	CAIE T2,(P2)	;IF IT POINTS TO THIS ACCESS TABLE
	JRST DBRNXT	;(IF NOT IGNORE IT)
	HRRZ T2,DEVDBL(T3)	;THEN LINK AROUND
	HRRM T2,DEVDBL(T1)
	HRRZ T2,FNBDBL(P3)
	HRRM T2,DEVDBL(T3)	;AND LINKK INTO NEW
	HRRM T3,FNBDBL(P3)
	PUSH P,T1		;SAVE BACK POINTER
	DMOVE T1,DEVFIL(F)
	MOVEM T1,DEVFIL(T3)
	HLLM T2,DEVEXT(T3)
	MOVE T1,DEVPPN(F)
	MOVEM T1,DEVPPN(T3)	;RESET NAME
	HRLM P4,DEVDRB(T3)
	POP P,T3	;USE OLD BACK POINTER TO COUNTINUE
DBRNXT:	MOVE T1,T3	;REMEMBER BACK POINTER
	HRRZ T3,DEVDBL(T3)
	JUMPN T3,DBRLP
	PUSHJ P,GIVCBR		;FINISHED RESETTING
	JRST RENAM8
RENNXR:	MOVE P2,ATBDOR(P2)
	MOVEM P2,DEVATB(F)
	HLRZ P4,P2	;RESET ATB, DRB POINTERS ALSO

RENNMR:	HRRZ P3,ATBFNB(P2)
	MOVE T1,FNBNAM(P3)
	MOVEM T1,DEVFIL(F)	;PUT BACK OLD NAME BEFORE READING RIB
	HRRZ T1,FNBEXT(P3)
	HRLM T1,DEVEXT(F)
	MOVE T1,DRBNAM(P4)
	MOVEM T1,DEVPPN(F)
	POPJ P,
RENAM6:	PUSHJ P,GIVCBR
	MOVEI T1,FNCCPR		;CAN HE MODIFY FILE
	PUSHJ P,CHKPRV
	 JRST RENRR3
	PUSHJ P,RIBWTL
	 JRST RENRR4
;HERE WITH THE RIB IN THE MON BUF, M POINTING TO PPN WORD
RENAM8:	;;TLZ S,IOSRIB		;MAKE SURE WE DON'T CONFUCE DIR ROUTINES
	;;This was moved to RENSTS+1 so DLTTRC can't botch it up/WRS
	MOVSI	T1,ATPPID!ATPDMP	;CLEAR BIT THAT SAYS THERE
					; IS A PID AND FILE DUMPED BIT
	ANDCAM	T1,ATBLCW(P2)	;GETS STORED INTO RIB AT RENDEA
	SETZM	ATBPID(P2)	;ZERO PID IN ATB AND
	SETZM	%RIB+RIBPID	; RIB.
	TLNN	M,EXTUUO	;EXTENDED M?
	JRST	RENM8A	;NO. POINT TO ATT WORD
	CAIGE	P1,UUXPRV	;SPECIFYING ATTRIBUTES?
	JRST	RENDEA		;NO
	XCTFU <SKIPA P3,UUXPRV(M)>
RENM8A:	UMOVE P3,UUNATT(M)	;GET ATTRIBUTES WORD
	JUMPE P3,RENAM9		;NO CHANGE
	MOVE T2,P3
	XOR	T2,ATBPVW(P2)	;COMPARE WITH RIB ATTR. WORD
	PUSHJ P,GETEXT		;GET EXTENSION WORD
	HLRZ T3,ATBMSC(P2)
	XOR T1,T3
	TRNN T1,140000		;SEE IF EXTENDED DATE CHANGING
	JUMPE	T2,RENAM9	;SAME IF 0
	HRLOI	T3,37		;SET UP MASK FOR PRIVS, MODE
	ANDM	T3,ATBPVW(P2)	;TAKE PRIVS, MODE OUT OF RIB
	ANDCA	T3,P3		;GET PRIVS FROM USER
	IORM	T3,ATBPVW(P2)	;AND SET THEM IN RIB WORD
	MOVEI T1,ATPDIR
	TDNE T1,ATBSTS(P2)
	TLNN T2,777000
	JRST RENM9B	;ARE WE CHANGING PROT OF A UFD?
	PUSHJ P,GETCBR	;YEST
	MOVE T1,DEVFIL(F)
	PUSHJ P,FNDDRB	;SEE IF A DRB BLOCK FOR IT
	 JRST RENM9A
	LDB T1,ATYPRV
	EXCH P4,T2
	DPB T1,DRYPRV
	MOVE P4,T2
RENM9A:	PUSHJ	P,GIVCBR		;AND RETURN CB RESOURCE
RENM9B:	PUSHJ P,GETEXT
	TRNN T1,140000		;IS ANYTHING BUT PROTECTION
	TDNE P3,[37,,-1]	;NON-ZERO
	SKIPA			;YES
	JRST RENM9C		;NO, DO NOT CHANGE IT
	LSH T1,-^D14
	DPB T1,ATYXCD
	DPB P3,ATYCTD
	MOVE T1,ATBMSC(P2)
	HLRM T1,%RIB+RIBEXT	;NOW UPDATE RIB
RENM9C:	MOVE T1,ATBPVW(P2)
	MOVEM T1,%RIB+RIBPVW
	TLNN M,EXTUUO
	JRST	[UMOVEM T1,UUNATT(M)	;GIVE IT TO USER
		JRST RENDEA]
	CAIL P1,UUXPRV
	UMOVEM T1,UUXPRV(M)	;USER WANTS IT
RENAM9:	TLNN	M,EXTUUO	;
	JRST	RENDEA		;
	CAIGE	P1,UUXALC	;
	JRST	RENRIB		;NOT CHANGING ALLOC.
	PUSHJ	P,ALCCHK	;CHANGING ALLOCATION?
	JRST	RENRIB		;NO.
	PUSHJ	P,DLTTRC	;AND REMOVE PAGES
	JRST	.+2		;ERR ON TRUNC, BAD FILE NOW.
	JRST	RENM9D		;SUCCESS.
	PUSHJ	P,RIBWTL	;MOST UNGRACEFUL ERROR HANDLING.
	STOPCD(SLO)
RENM9D:	HRRZ	T1,ATBFNB(P2)	;GET FNB ADDRESS
	MOVE	T2,PCDTIM	;GET CURRENT PCB TIMER
	MOVEM	T2,FNBALT(T1)	;SET IN FNB AND
	MOVEM	T2,%RIB+RIBALT	;RIB.

;FALL INTO RENRIB
RENRIB:	PUSHJ	P,SETVAL	;STORE ARGUMENTS FROM USER IN RIB

RENDEA:	MOVE T1,ATBLCW(P2)
	MOVE T2,%RIB+RIBSTS
	TRNN T2,RIPHWE!RIPHRE!RIPBDA!RIPBFS!RIPBDR
	TLZA T1,ATPUFE
	TLO T1,ATPUFE	;KEEP ERROR BIT CORRECT
	MOVEM T1,ATBLCW(P2)
	MOVEM T1,%RIB+RIBLCW
	LDB T1,PJOBN
	HLL T1,JBTLIC(T1)	; KEEP JOB# IN RH FOR LATER
	TLNE T1,LICWFL		; LET USER SET RIPSPP IF HAS WF
	 JRST RENSTS
	MOVE T1,JBTPPN(T1)
	CAME T1,DEVPPN(F)	;IS IT THE SAME
	TRZA T2,RIPSPP	;NO RESET
	TRO T2,RIPSPP	;OR SET
RENSTS:	MOVEM T2,%RIB+RIBSTS
	PUSHJ P,RELLOK	;ALL DONE
	TLZ S,IOSRIB	;DIR### routines die if they think its there
	TLNE M,UUOENT	;IS THERE A NAME CHANGE?
	JRST RENNMC		;YES, DO IT
	PUSHJ P,RIBDIR
	 JRST RENR7A	;CAN NOT GET IT
	HRRZ P3,ATBFNB(P2)
	LDB T1,FNYUFP
	TLO	S,IO		;WANT UFD PAGE WRITEABLE.
	PUSHJ P,DIRBLK
	 JRST RENRR7	;CAN NOT GET IT
	PUSHJ P,DIRSRC
	 SKIPA		;FOUND IT
	STOPCD(SLO)		;SHOULD HAVE AT LEAST BEEN AN ERROR FLAG
	PUSHJ P,CREUFD	;UPDATE UFD WITH NEW VALUES
RENR7A:	PUSHJ P,RELLOK	;DONE WITH UFD BLOCK
RENRR7:	MOVEI T1,ATPREN
	ANDCAM T1,ATBSTS(P2)	;RESET FLAG
RENECM:	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	STOPCD(SLO)
	AOS (P)
	PUSHJ	P,WATPCB	;WAIT FOR THE RIB PCBS TO BE VAIDATED.
	MOVEI M,CLSACC	;NO ACCESS DATE UPDATE ON FORECED CLOSE
	PJRST CLOSE1	;FINISH UP

RENNMC:	TLNN M,UUOREN	;NAME CHANGE, DIRECTORY ALSO?
	JRST RENDCR	;YES, MUST DELETE OLD AND CREATE NEW
	HRRZ T1,ATBDOR(P2)
	HRRZ T1,ATBFNB(T1)
	MOVE T1,FNBNAM(T1)	;GET OLD NAME
	TLZ T1,(1B0)
	MOVE T2,DEVFIL(F)
	TLZ T2,(1B0)
	SUB T1,T2
	HRRZ	T2,STRDDB+STRHSH
	IDIVI T1,(T2)
	JUMPN T2,RENDCR	;DIFFERENT NAME FORCES DELETE AND CREATE
	PUSHJ P,RENNXR	;GET READY TO FIND OLD NAME
	HRRZ P3,ATBFNB(P2)
	PUSHJ P,RIBDIR
	 JRST	[PUSHJ P,RELLOK
		JRST RENZAP]	;CAN NOT READ UFD
	LDB T1,FNYUFP
	PUSHJ P,DIRBLK
	 JRST RENZAP
	PUSHJ	P,DIRSRC	;SEARCH THIS PAGE.
	 SKIPA
	STOPCD(SLO)		;SHOULD HAVE BEEN AN ERROR INDICATION
	PUSH P,T2	;SAVE LOCATION
	LDB	T1,FNYUFP	;SAVE THIS
	PUSH	P,T1		;FOR OTHER ENTRY.
	PUSHJ P,RENNXR	;GET NEW NAME BACK
	POP	P,T2		;GET OLD FNYUFP BACK.
	DPB	T2,FNYUFP
	POP P,T2
	JRST RENFL1	;AND DO IT LIKE CREATE

RENDCR:	PUSHJ P,RENNXR	;GET SET TO DELETE OLD NAME
	PUSHJ P,DLTNAM
	TLNN M,UUOREN	;CHANGE OF DIR OR JUST NAME
	PUSHJ P,LOGTST	;DIR, REWRITE IF NEEDED
RENZAP:	PUSHJ P,RENNXR	;NOW TRY TO CREATE NEW
	TLNN M,UUOREN
	PUSHJ P,LOGTST
	SETZ	T2,		;FLAG NO RET PNTR FOR INSNAM.
	PUSHJ	P,INSNAM
	JRST	RENFL2	;COULD NOT(ALLOC FAIL/RIB ERR/DIR FULL).
RENFL1:	PUSHJ P,CREUFD	;STORE INFORMATION
	PUSHJ P,RELLOK
RENFL2:	HRRZ P3,ATBFNB(P2)
	PUSHJ P,GETCBR
	MOVSI T1,FNPNX
	ANDCAM T1,FNBNX(P3)	;RESET FOR NEW NAME
	MOVE T1,ATBRIB(P2)
	MOVEM T1,FNBRIB(P3)
	MOVEI T2,ATPREN
	ANDCAM T2,ATBSTS(P2)
	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	STOPCD(SLO)
	MOVEI T1,0
	EXCH T1,ATBDOR(P2)
	SETZM ATBDOR(T1)
	HRRZ P2,T1
	HLRZ P4,T1
	HRRZ P3,ATBFNB(P2)
	PUSHJ P,FREATB	;GET RID OF ATB NOW ATTACHED TO OLD FNB
	MOVSI T1,FNPNX
	IORM T1,FNBNX(P3)
	SETZM FNBRIB(P3)
	PUSHJ P,GIVCBR
	JRST RENECM
;SUBROUTINE TO STORE USER-SUPPLIED ARGUMENTS IN THE RIB BLOCK
;CALLED BY ENTER AND RENAME
;ENTER WITH P1=NUMBER OF ARGS

;-SEP 76 AAA. ADDITIONS FOR PROJ CODES. WF USER CAN SET PJC AT WILL.
;-	WPJ USER CAN SET PJC ON RENAME OR UPDATE
SETVAL:	CAIGE P1,UUXVER
	POPJ P,		;NOT ENOUGH TO WORRY ABOUT
	MOVE  T4,UNPARG	;CAN ALWAYS SET THESE
	PUSH P,J
	LDB J,PJOBN
	LDB T2,JBYWPT
	CAILE T2,1
	IOR T4,WRTARG	;CAN SET THESE IF WRITE FILES
	MOVSI T2,LICJAL
	TDNE T2,JBTLIC(J)
	IOR T4,JALARG	;CAN SET THESE IF JL LIC
	MOVSI T2,LICWPJ		;-
	TDNN T2,JBTLIC(J)	;-
	JRST .+4		;-
	MOVEI T2,ATPCRE!ATPSUP	;-FOR RENAME OR UPDATE,
	TDNN T2,ATBSTS(P2)	;-(SKIP IF NEITHER)
	IOR T4,WPJARG		;-LICWPJ USER CAN SET THESE
	POP P,J
	MOVEI T2,ATPDIR
	TDNN T2,ATBSTS(P2)
	IOR T4,NONUA	;AND CAN SET THESE IF NOT A UFD
	SUBI P1,UUXVER-1	;NUMBER WE WANT TO SET
	MOVNS P1
	HRLS P1
	HRRI P1,UUXVER
	TLOA M,P1	;GET M SET FOR INDEXING
SETVL1:	LSH T4,1
	JUMPGE T4,SETVTU	;CAN NOT SET THIS
	UMOVE T1,@M	;GET ARG FROM USER
	XCT FUTAB-UUXVER(P1)	;AND DO RIGHT THING WITH IT
	AOBJN P1,SETVL1
	POPJ P,		;DONE

SETVTU:	XCT TUTAB-UUXVER(P1)	;FOR THOSE WE CAN NOT SET
	UMOVEM T1,@M		;GIVE THEM TO USER
	AOBJN P1,SETVL1
	POPJ P,

FUTAB:	MOVEM T1,%RIB+RIBVER
	MOVEM T1,%RIB+RIBFUT
	MOVEM T1,%RIB+RIBEST
	PUSHJ P,CLFALC		;ALLOCATED IS CACULATE TO SIM OLD
	MOVEM T1,%RIB+RIBPOS
	MOVEM T1,%RIB+RIBFT1
	PUSHJ P,CLFLIC		;CHECK ON LICENSE HE CAN SET
	MOVEM T1,%RIB+RIBMTA
	MOVEM T1,%RIB+RIBDEV
	PUSHJ P,CLFSTS		;SPECIAL FOR STATUS
	STOPCD(SLO)			;CAN NEVER SET ELB
	STOPCD(SLO)		;OR EUN
	PUSHJ P,CLFQTF		;QUOTA IN (MAX CHANGE DRBMXA AND ALC)
	MOVEM T1,%RIB+RIBQTO
	PUSHJ P,CLFMXA
	PUSHJ P,CLFUSD
	MOVEM T1,%RIB+RIBAUT
	PUSHJ P,CLFUNM
	PUSHJ P,CLFUN1
	MOVEM T1,%RIB+RIBTRU
	MOVEM T1,%RIB+RIBXT2
	STOPCD(SLO)		;CAN NOT SET ALP
	STOPCD(SLO)		;OR SNM
	MOVEM T1,%RIB+RIBPJC	;-CAN SET PJC
	MOVEM T1,%RIB+RIBPJ1	;-
	MOVEM T1,%RIB+RIBPJ2	;-
	PUSHJ P,CLFPID		;SET OR CLEAR PID
	STOPCD(SLO)		;CAN NEVER SET ALT
CLFALC:	UMOVE	T2,UUXNUM(M)	;ARG IN UNITS OF
	TRNE	T2,UUPWDS	;WORDS?
	JRST	CLFAL2		;YES.
CLFAL1:	CAMGE T1,%RIB+RIBEST	;NO. SO WE CAN SIMULATE EST SIZE
	MOVE T1,%RIB+RIBEST
	MOVEM T1,%RIB+RIBALC
	LDB T2,ATYBLK
	CAMLE T2,T1
	MOVE T1,T2
	UMOVEM T1,UUXALC(M)	;GIVE USER A FAKE NUMBER
	POPJ P,			;SO LOOKS LIKE ALLOC SUCCEDED
CLFAL2:	MOVE	T2,T1		;CONVERT THE ARG
	LSH	T1,-BLKLSH	;TO
	TRNE	T2,177		;BLOCKS, WATCHING OUT FOR
	AOJA	T1,CLFAL1	;OVERFLOW.
	JRST	CLFAL1		;

	DEFINE TXXGEN (AC,NUM,TYP)
<IFE NUM&777777,<TL'TYP AC,(NUM)>
 IFN NUM&777777,<
	IFE NUM&777777000000,<TR'TYP AC,NUM>
	IFN NUM&777777000000,<TD'TYP AC,[NUM]>>>

CLFSTS:	TXXGEN (T4,<1B0_<^L<ARGSTS>-^L<ARGPVS>>>,NN)
	JRST	CLFNPS		;NO.
	MOVEI T2,RIPDIR		;DO NOT LET DIR GET SET
	ANDM T2,%RIB+RIBSTS	;JUST THAT BIT
	TRZ T1,RIPDIR
	IORM T1,%RIB+RIBSTS	;PRIV CALL, SET STATUS
	POPJ P,

CLFNPS:	ORCMI T1,RIPBDA!RIPBFS!RIPHWE!RIPHRE ;SET TO 1 
				;ALL BITS BUT ONES WANTED CLEARED.
	ANDB T1,%RIB+RIBSTS	;(DON'T LET CLR RIPBDR.).
	UMOVEM T1,UUXSTS(M)	;TELL USER
	POPJ P,

CLFQTF:	MOVEI T2,ATPDIR
	TDNN T2,ATBSTS(P2)
	JRST CLFQT1		;NOT A DIRECTORY
	PUSHJ P,GETCBR		;TRY TO FIND DRB
	PUSH P,T1
	MOVE T1,DEVFIL(F)
	PUSHJ P,FNDDRB
	 JRST CLFQT2	;%NOT THERE
	SKIPN DRBRIB(T2)
	JRST CLFQT2	;%NOT REALLY READ YET
	MOVE P3,T2	;SAVE FOR LATER ARGUMENTS
	POP P,T1
	PUSHJ P,GIVCBR
	MOVE T2,T1
	SUB T2,%RIB+RIBQTF
	ADDM T2,DRBMXA(P3)
	ADDM T2,DRBALC(P3)
	JRST CLFQT3		;AND GO
CLFQT2:	PUSHJ P,GIVCBR
	POP P,T1
	TDZA P3,P3	;SET 0 AS FLAG FOR LATER ARGS
CLFQT1:	MOVNI P3,1	;NEGATIVE AS FLAG THAT NOT DIR
CLFQT3:	MOVEM T1,%RIB+RIBQTF
	POPJ P,

CLFUNM:	JUMPLE P3,CLFUM1
	MOVEM T1,DRBUNM(P3)	;STORE IT IN DRB IF CHANGING
	SETZM DRBUN1(P3)	;JUST IN CASE
	SETZM %RIB+RIBUN1
CLFUM1:	MOVEM T1,%RIB+RIBUNM
	POPJ P,

CLFUN1:	SKIPLE P3
	MOVEM T1,DRBUN1(P3)
	MOVEM T1,%RIB+RIBUN1
	POPJ P,

EXTERNAL JBTNAM
CLFUSD:	JUMPL P3,CLFUS1	;NOT A UFD
	JUMPL T1,CLFUS2	;DOES NOT WANT CHANGED
	JUMPE P3,CLFUS3	;NO DRB, JUST CHANGE RIB
	MOVE T2,%RIB+RIBQTF
	SUB T2,T1	;HAVE A DRB, CHANGE FOR NEW USD
	MOVEM T2,DRBALC(P3)
	CAMGE T2,DRBMXA(P3)
	MOVEM T2,DRBMXA(P3)	;AND THIS IF CHANGED
CLFUS1:	MOVEM T1,%RIB+RIBUSD
	POPJ P,

CLFUS3:	CAMLE T1,%RIB+RIBMXA	;MAY HAVE TO CHANGE THIS TOO
	MOVEM T1,%RIB+RIBMXA
	JRST CLFUS1

CLFUS2:	SKIPE P3
	SKIPA T1,%RIB+RIBQTF	;IF WE HAVE DRB, RETURN QTF-ALC
	SKIPA T1,%RIB+RIBUSD	;ELSE USD FROM RIB
	SUB T1,DRBALC(P3)
	UMOVEM T1,UUXUSD(M)
	POPJ P,

CLFMXA:	JUMPL P3,CLFMX1		;NOT A UFD, JUST ANOTHER ARG
	JUMPL T1,CLFMX2		;DO NOT WANT IT CHANGED
	JUMPE P3,CLFMX3		;CHANGE TO CURRENT USD AND REPORT OLD
	MOVE T2,DRBALC(P3)	;IF HAVE DRB, GET CURRENT
	EXCH T2,DRBMXA(P3)	;AND STORE FOR MAX. GET OLD
	SUB T2,%RIB+RIBQTF	;NOW OLD MAX-QUOTA
	MOVNM T2,%RIB+RIBMXA	;TEMP STORE OLD MAX
	SKIPA T1,%RIB+RIBQTF	;GET QUOTA
CLFMX3:	SKIPA T1,%RIB+RIBUSD	;IF NO DRB, GET CURRENT USED
	SUB T1,DRBALC(P3)	;IF DRB QUOTA-CURRENT QUOTA LEFT
	EXCH T1,%RIB+RIBMXA	;SET RIBMXA TO CURRENT USED, GET OLD
	UMOVEM T1,UUXMXA(M)
	POPJ P,

CLFMX1:	MOVEM T1,%RIB+RIBMXA
	POPJ P,

CLFMX2:	SKIPE P3	;IS THERE A DRB
	SKIPA T1,%RIB+RIBQTF	;YES
	SKIPA T1,%RIB+RIBMXA	;NO
	SUB T1,DRBMXA(P3)	;NOW HAVE CURRENT MAX
	UMOVEM T1,UUXMXA(M)
	POPJ P,

CLFPID:	JUMPGE	P3,CPOPJ	;FORGET IT FOR UFDS
	JUMPE	T1,CLFPIZ	;ZEROING PID IS ALWAYS OK
	MOVS	T2,T1		;GET SWAPPED COPY OF NEW PID IN T2 (UUN IN RH INSTEAD OF LEFT HALF)
	XOR	T2,JBTAUN(J)	;SEE IF PID UUN MATCHES JOB'S AUN UUN
	TRNN	T2,-1
	JRST	CLFPIO		;OK TO GIVE OUT THIS PID
	LDB	T2,JBYWPT
	CAILE	T2,1		;IF HAS WF OR WA,
	JRST	CLFPIO		;OK TO GIVE PID OUT
	CAME	T1,%UPT+UPTPID	;PROGRAM TRYING TO GIVE OUT ITS OWN PID?
	POPJ	P,		;NO, WAS HIS LAST CHANCE, NO PID.
CLFPIO:	MOVSI	T2,ATPPID
	IORM	T2,ATBLCW(P2)	;SET TO GOES INTO UFD ENTRY AND RIBLCW
CLFPIS:	MOVEM	T1,%RIB+RIBPID	;OK, STORE IN RIB AND IN
	MOVEM	T1,ATBPID(P2)	;ATB
	POPJ	P,
CLFPIZ:	MOVSI	T2,ATPPID
	ANDCAM	T2,ATBLCW(P2)
	JRST	CLFPIS
	DEFINE XA (A)
<	A==%%Z
	%%Z==%%Z_-1>
	%%Z==400000,,0

;DEFINE 'ALLOWED TO CHANGE' BIT NAMES

XA ARGVER
XA ARGFUT
XA ARGEST
XA ARGALC
XA ARGPOS
XA ARGFT1
XA ARGLIC
XA ARGMTA
XA ARGDEV
XA ARGSTS
XA ARGELB
XA ARGEUN
XA ARGQTF
XA ARGQTO
XA ARGMXA
XA ARGUSD
XA ARGAUT
XA ARGUNM
XA ARGUN1
XA ARGTRU
XA ARGUFD
XA ARGALP
XA ARGSNM
XA (ARGPJ0)	;-
XA (ARGPJ1)	;-
XA (ARGPJ2)	;-
XA ARGPID
XA ARGALT
XA (ARGPVS)	;FAKE TO REMEMBER STATUS PRIV

;NOW THE WORDS DEFINING BITS ALLOWED TO CHANGE

UNPARG:	ARGVER+ARGFUT+ARGEST+ARGALC+ARGPOS+ARGFT1+ARGLIC+ARGUFD+ARGSTS+ARGPID
WRTARG:	ARGMTA+ARGAUT+ARGPVS+ARGPJ0+ARGPJ1+ARGPJ2	;-
JALARG:	ARGQTF+ARGQTO+ARGMXA+ARGUSD+ARGUNM+ARGUN1+ARGTRU+ARGPVS
NONUA:	ARGUNM+ARGUN1+ARGTRU+ARGQTF+ARGQTO+ARGMXA+ARGUSD
WPJARG:	ARGPJ0+ARGPJ1+ARGPJ2	;-NEW FOR PJC
CLFLIC:	MOVE T2,ATBLCW(P2)	;GET CURRENT VALUE
	PUSH P,T4
	TLNE T1,77	;SPECIFYING SECONDS?
	TLOA T2,77	;YES, VOID OLD FOR MERGE
	TLO T1,77	;NO, VOID NEW FOR MERGE
	LDB T4,PJOBN
	MOVSI T3,LICJAL+LICWFL
	TDNE T3,JBTLIC(T4)
	TLOA T2,ATMUFP!ATMUFU	;LET HIM SET SPECIAL BITS
	TLO T2,ATMUFU	;JUST THE USUAL ONES
	HLLO T3,T2
	AND T1,T3	;ADJUST LEFT HALF
	HLL T2,JBTLIC(T4)
	TLNE	T2,LICWFL	;FIND OUT IF HE HAS WA
	TLNN	T2,LICWPJ	;
	TLZA	T1,ATPPID!ATPALC ;NO. IGNORE HIS ATPPID AND ATPALC ARGS.
	JRST	CLFLC1		;YES.
	MOVE	T3,ATBLCW(P2)	;DOESN'T HAVE WA. DON'T LET HIM CLEAR
	TLZ	T3,-<ATPPID!ATPALC>-1 ;ATPPID OR ALC
	IOR	T1,T3
CLFLC1:	MOVE T3,JBTPPN(T4)
	XOR T3,DEVPPN(F)
	PUSHJ P,FILLIC
	UMOVEM T1,UUXLCW(M)
	MOVEM T1,ATBLCW(P2)
	POP P,T4
	POPJ P,

FILLIC:	TLZ T2,LICRMT	;DON'T LOOK AT THIS ONE
	PUSH P,T3
	PUSHJ P,LICMAX
	POP P,T3
	TLNN T3,-1	;SAME PROJ??
	JRST LICSPJ
	TRNN T1,LICWFL	;CAN NOT SET WRIT PROJ UNLESS
	TRNE T2,LICWFL	;SOMEONE HAS WRITE FILE
	SKIPA
	TRZ T1,LICWPJ
	TRNN T1,LICRFL
	TRNE T2,LICRFL
	SKIPA
	TRZ T1,LICRPJ
	TRNN T2,LICRMT+LICWFL
	TRZ T1,LICRMT	;SOME ONE MUST HAVE WF OR RMT TO SET RMT
	JRST LICSPG
LICSPJ:	TDNN T3,[XWD INDPPN,-1]
	JRST LICSPG
	TRNN T2,LICRMT+LICWFL+LICWPJ
	TRZ T1,LICRMT	;NOT REMOTE UNLESS WAS OR WRITE
LICSPG:	TRO T2,LICRMT
	HRL T2,T1
	PUSHJ P,LICMSK
	HRRM T2,T1
	POPJ P,
;SET MAX LICENSE OF LEFT HALF OF T2 AND RIGHT HALF OF T2
LICMAX:	LDB T3,[POINT 2,T2,LICWPS]	;MAX OF WRITE PRVS
	LDB T4,[POINT 2,T2,LICWPS+^D18]
	CAMGE T4,T3
	MOVE T4,T3
	DPB T4,[POINT 2,T2,LICWPS+^D18]
	LDB T3,[POINT 2,T2,LICRPS]	;READ IS MAX OF READ
	CAMGE T3,T4		;WRITE PRV. IMPLIES READ SO INCLUDE
	MOVE T3,T4
	LDB T4,[POINT 2,T2,LICRPS+^D18]
	CAMGE T4,T3
	DPB T3,[POINT 2,T2,LICRPS+^D18]
	HLRZ T3,T2
	TRZ T3,LICFMK	;TURN OFF ALL READ AND WRITE DSK BITS
	IOR T2,T3
	POPJ P,

;SETS LICENSE BY MASKING. LEFT HALF OF T2 IS THE REQUESTED
;LICENSE. RIGHT HALF IS WHAT HE CAN HAVE
LICMSK:	LDB T3,[POINT 2,T2,LICWPS]
	LDB T4,[POINT 2,T2,LICWPS+^D18]
	CAMGE T4,T3
	 DPB T4,[POINT 2,T2,LICWPS]
	LDB T3,[POINT 2,T2,LICRPS]
	LDB T4,[POINT 2,T2,LICRPS+^D18]
	CAMGE T4,T3
	 DPB T4,[POINT 2,T2,LICRPS]
	HLRZ T3,T2
	TRO T2,LICFMK
	AND T2,T3
	TRZ T2,LICUNU	;TURN OFF UNUSED BITS JUST IN CASE
	POPJ P,



COMMENT ! LICSAM
EXPECTS: T2/ LICENSE (FROM HIGH FILE),,LICENSE(FROM LOW FILE)
FUNCTION: RETURN T2/ 0,,LICENSES COMMON TO BOTH HALVES
DESTROY: T3,T4
NOTE: VIRTUALLY IDENTICAL TO LICMSK. USED BY SEGCON
!
LICSAM:	LDB T3,[POINT 2,T2,LICWPS]
	LDB T4,[POINT 2,T2,LICWPS+^D18]
	CAME T4,T3
	TLZ T2,3B<LICWPS+^D18> ;DIFFERENT. ZAP WRITE PRIVS
	LDB T3,[POINT 2,T2,LICRPS]
	LDB T4,[POINT 2,T2,LICRPS+^D18]
	CAME T4,T3
	TLZ T2,3B<LICRPS+^D18>	;DIFFERENT. ZAP READ PRIVS
	HLRZ T3,T2	;T3/0,,LICS (READ,WRITE PRIVS FIXED)
	TRO T2,LICFMK	;R/W PRIV MASK
	AND T2,T3	;T2/0,,LICS(ANDED)+R/W PRIVS, FIXED
	TRZ T2,LICUNU
	POPJ P,

;GET LICENSE FROM CORE TABLES. F IS SET UP. RETURN IN T1
;NON-SKIP RETURN IF NOT DISK. USED BY SEGCON

GETLIC:	MOVE T1,DEVMOD(F)
	TLNE F,GETB		;IF OFF A GETSEG, NO LICENSE
	TLNN T1,DVDSK
	JRST CPOPJ1
GETLI1:	HRRZ T1,DEVATB(F)	;ENTERED HERE FROM SEGCON
	HRRZ T1,ATBLIC(T1)
	MOVE T2,JOB
	MOVE T2,JBTPPN(T2)
	XOR T2,DEVPPN(F)	;SEE IF IN SAME PROJECT
	TLNN T2,-1
	POPJ P,			;YES
	TRNN T1,LICWFL
	TRZ T1,LICWPJ		;RESET PROJECT READ AND WRITES
	TRNN T1,LICRFL		;FROM OTHER PROJECTS
	TRZ T1,LICRPJ
	POPJ P,

INTERNAL GETLIC,LICMAX,LICMSK,FILLIC,LICSAM,GETLI1
	SUBTTL ERROR RETURNS

ILNMER:	MOVEI T1,FNFERR
	JRST STRERR

LUKER1:	TLZ M,EXTUUO
	XCTFU <SKIPN T2,(M)>	;DO NOT KNOW YET IF EXTENDED
	JRST RENER0
	TLNN T2,-1
	TLO M,EXTUUO	;IT IS EXTENDED
RENER0:	MOVEI T1,ISUERR
	JRST STRERR
UILNMD:	MOVEI T1,AEFERR	;%
UPDERC:	PUSHJ P,GIVCBR
	JRST STRERR

UPDER2:	MOVEI T1,PRTERR	;%
	JRST UPDERC

UPDER3:	MOVEI T1,FBMERR	;%
	JRST UPDERC

CLRENT:	PUSHJ P,GETCBR
	MOVEI T1,ATPCRE!ATPSUP
CLRNT1:	ANDCAB T1,ATBSTS(P2)
CLRCOM:	HRRZ P3,ATBFNB(P2)	;% IN CASE WE NEED IT
	TDNN T1,[ATMUMC,,ATMCNT!ATPREN!ATPUPD!ATPSUP!ATPCRE!ATPMXU]
	JRST	[PUSHJ P,FREATB
		HLLZS	DEVATB(F)
		JRST .+1]
	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	 STOPCD(SLO)
	PUSHJ P,ULKDBL
	PJRST GIVCBR

LKER1:	PUSHJ	P,RELRIB	;GET RID OF RIB IF WE HAVE IT.
	MOVEI T1,PRTERR
	PUSHJ P,STRERR	;SET FLAG
	PUSHJ P,GETCBR
	MOVE T1,ATBCNT(P2)	;SET ARGUMENT
	MOVEI M,CLSACC!CLSOUT	;MAKE LOOK LIKE A CLOSE
	PJRST CLOSRN		;IN CASE ATPDEL IS SET (SUPERCEDE)

ENTER1:	PUSHJ P,CLRENT
	MOVEI T1,PRTERR
	JRST STRERZ

ENTER2:	PUSHJ P,CLRENT
	MOVEI T1,NRMERR
	JRST STRERZ

ERRLKM:	MOVEI T1,LKMERR
	JRST STRERR

ERRNET:	MOVEI T1,NETERR
STRERZ:	MOVEI T2,0
	DPB T2,DEYSTC
STRERR:	TLNN M,EXTUUO
	XCTBU <HRRM T1,UUNEXT(M)>
	TLNE M,EXTUUO
	XCTBU <HRRM T1,UUXEXT(M)>
	POPJ P,
RENER9:	HRRM P2,DEVATB(F)	;PUT THINGS BACK
	HRLM P4,DEVDRB(F)
	PUSH P,T1		;SAVE ERROR CODE
	PUSHJ P,RENNMR		;RESTORE OLD NAME
	POP P,T1
	JRST RENRCM		;AND GIVE ERROR

RENER7:	PUSHJ P,GIVCBR		;%
RENRR3:	MOVEI T1,PRTERR
RENRCM:	MOVEI T2,ATPREN
	ANDCAM T2,ATBSTS(P2)
	SOS T2,DRBCNT(P4)
	TRNE T2,DRPMXC
	STOPCD(SLO)
	MOVEI T2,DECLUK
	DPB T2,DEYSTC	;RESET, LOOKUP WAS IN FORCE AND IS AGAIN
	JRST STRERR

RENRR4:	MOVEI T1,TRNERR
	JRST RENRCM

RENRR2:	MOVEI T1,TRNERR
RENCLR:	PUSH P,T1		;SAVE IT
	HLRZ P4,ATBDOR(P2)	;OLD DRB
	HRRZ P2,ATBDOR(P2)
	PUSHJ P,GETCBR
	HRRZ P3,ATBFNB(P2)
	PUSHJ P,FREATB		;GIVE BACK ATB (NEW)
	SOS T1,DRBCNT(P4)
	TRNE T1,DRPMXC
	STOPCD(SLO)
	PUSHJ P,GIVCBR
	HRRZ P2,DEVATB(F)
	HLRZ P4,DEVDRB(F)
	SETZM ATBDOR(P2)	;REMOVE LINK
	POP P,T1
	JRST RENRCM		;AND GO

RENRR1:	PUSHJ P,RELLOK
	PUSHJ P,RENNXR
	MOVEI T1,PRTERR
	JRST RENCLR

RENRR0:	PUSHJ P,RELLOK
	MOVEI T1,NRMERR
	JRST RENCLR
;THIS IS PART OF THE SYSDEV UUO



INTERN SYDUNI
SYDUNI:	HRRI M,1(M)	;GET THE UNIT NAME SPECIFIED BY USER
	UMOVE T1,(M)
	HLRZ U,SYSUNI	;START OF UNIT CHAIN
	JUMPE T1,SYDUN1	;USER SPECIFIED 0, FIRST UNIT
SYDUN3:	CAMN T1,UNINAM(U)
	JRST SYDUN2	;FOUND UNIT SPECIFIED
	HLRZ U,UNISYS(U)	;NEXT UNIT
	JUMPN U,SYDUN3	;MORE LEFT?
	POPJ P,		;NO, NAME SPECIFIED NOT UNIT, ERROR RET

SYDUN2:	HLRZ U,UNISYS(U)	;GET NEXT UNIT
	JUMPE U,SYDNM4		;RETURN A 0 FOR END OF LIST
SYDUN1:	LDB T1,UNYSIZ		;GET THE SIZE WE CAN GIVE HIM
	MOVE T2,UNINAM(U)
SYDUN4:	UMOVEM T2,(M)		;GIVE HIM THE NAME OF THIS ONE
	MOVSI T2,LICSYS		;SEE IF HE CAN HAVE MORE
	TDNN T2,JBTLIC(J)
	JRST CPOPJ1	;NO
	SOJLE P1,CPOPJ1	;OR MAYBE DOES NOT WANT MORE
	HRRI M,1(M)
	JRST SYDCOM

INTERN SYDSTR
SYDSTR:	HRRI M,1(M)
	UMOVE T1,(M)
	JUMPE T1,SYDST1	;FIRST STRUCTURE REQUESTED
	CAME T1,[SIXBIT /DSKB/]	;FAKE IT
	POPJ P,		;NO, ERROR
	JRST SYDNM4	;SAY NOTHING MORE

SYDST1:	MOVE T2,[SIXBIT /DSKB/]
	MOVEI U,STRDDB	;STR DATA FROM COMMOD
	MOVEI T1,STRLEN
	JRST SYDUN4

EXTERNAL SYDCOM
SUBTTL  F.S. UUO FUNCTION AND ERROR RETURN CODES

;STRUUO FUNCTION CODES

XP .FSSRC,0	;DEFINE NEW SEARCH LIST (UNPRIVILEGED)
XP .FSDSL,1	;DEFINE NEW SEARCH LIST (PRIVILEGED)
XP .FSDEF,2	;DEFINE NEW FILE STRUCTURE
XP .FSRDF,3	;REDEFINE FILE STRUCTURE STATUS
XP .FSLOK,4	;LOCK OUT NEW INITS,ENTERS,LOOKUPS
XP .FSREM,5	;REMOVE FILE STRUCTURE FROM SYSTEM

;STRUUO & GOBSTR ERROR CODES

XP .ERILF,0	;ILLEGAL FUNCTION CODE
XP .ERSNF,1	;1 OR MORE FILE STRUCTURES NOT FOUND
XP .ERSSA,2	;1 OR MORE FILE STRUCTURES SINGLE ACCESS ONLY
XP .ERILE,3	;1 OR MORE ILLEGAL ENTRIES IN ARG. LIST
XP .ERTME,4	;TOO MANY ENTRIES IN SEARCH LIST
XP .ERUNA,5	;1 OR MORE UNITS NOT AVAILABLE
XP .ERPPN,6	;JOB # , PP # DO NOT MATCH
XP .ERMCN,7	;MOUNT COUNT NOT 0
XP .ERNPV,10	;NOT PRIVILEGED USER
XP .ERFSA,11	;F.S. ALREADY EXISTS
XP .ERILL,12	;ILLEGAL ARG. LIST LENGTH (LH UUO AC)
XP .ERUNC,13	;UNABLE TO COMPLETE THE FUNCTION
XP .ERNFS,14	;SYSTEM FULL OF FILE STRUCTURES
XP .ERNCS,15	;NOT ENOUGH FREE CORE FOR DATA BLOCK
XP .ERUNF,16	;ILLEGAL UNIT
XP .ERRSL,17	;FILE STRUCTURE REPEATED IN SEARCH LIST DEFINITION

;MACRO TO ASSOCIATE SYMBOLIC ADDRESS AND ERROR CODE

	DEFINE	ERCODE	(NAME,CODE)<
IFG <CODE-MXECOD>,<MXECOD==CODE>
	NAME==ECOD'CODE>

MXECOD==0	;NUMBER OF ERROR CODES TO GENERATE
SUBTTL SYSSTR M
;M TO RETURN NAME OF NEXT FILE STRUCTURE IN SYSTEM
;NOTE THAT ACCUMULATOR J IS J AND CONTAINS THE JOB NUMBER OF THE JOB
; EXECUTING THE M


INTERN SYSTUU
SYSTUU:	JUMPE	T1,SYSTU1	;% JUMP IF 1ST STR DESIRED
	CAME T1,[SIXBIT /DSKB/]	;ONLY LEGAL STR NAME
	  POPJ	P,		;% NO, ERROR RETURN
	TDZA T1,T1	;AFTER DSKB IS END
SYSTU1:	MOVE T1,[SIXBIT /DSKB/]
	JRST	RETARG
SUBTTL SYSPHY M
;CALLI AC,51
;M TO RETURN NAME OF NEXT PHYS.DEV. NAME IN SYSTEM
; CALLING SEQUENCE IS SIMILAR TO SYSSTR M


INTERN SYSPHY
SYSPHY:	HLRZ	U,SYSUNI	;U=ADDRESS 1ST UNIT D.B.
	JUMPE	T1,SYSPH4	;IF USER AC=0: RETURN 1ST UNIT

SYSPH2:	CAMN	T1,UNINAM(U)	;THIS UNIT PHYS.NAME = ARGUMENT?
	JRST	SYSPH3		;YES-GO RETURN NEXT PHYS.NAME
	HLRZ	U,UNISYS(U)	;NO--GET NEXT UNIT
	JUMPN	U,SYSPH2	;IF THIS IS LAST UNIT:
	POPJ	P,		;   GIVE ERROR RETURN

SYSPH3:	SETZ	T1,		;RETURN 0 IN CASE IT WAS LAST UNIT
	HLRZ	U,UNISYS(U)	;GET NEXT UNIT D.B.
	JUMPE	U,RETARG	;IF THAT WAS LAST UNIT: RETURN 0
SYSPH4:	MOVE	T1,UNINAM(U)	;OTHERWISE RETURN PHYS.NAME
	JRST	RETARG
SUBTTL GOBSTR M
; GENERALIZED JOBSTR M  -  CALLI AC,66


;ERROR RETURN CODES:

ERCODE GERIFS,\.ERILE	;1ST ARG. NOT VALID (-1 OR F.S. NAME IN JOBS SRCH LIST)
ERCODE GERPPN,\.ERPPN	;JOB# (1ST ARG) NO GOOD OR DOESNT MATCH PPN (2ND ARG)
ERCODE GERILL,\.ERILL	;ILLEGAL ARG.LIST LENGTH (LH OF M AC)
; ALSO .ERNPV		;(SUBROUT PRIVJ) NOT PRIVILEGED JOB

INTERN GOBSTR
GOBSTR:	JSP	T4,PRIVJ		;PRIVILEGED JOB?
	HRRM	T1,M		;RH M=ADDR. USERS ARG. LIST
	HLRZ	P1,T1		;P1=LENGTH OF ARG. LIST
	SKIPN	P1		;CONVERT 0 TO 3
	MOVEI	P1,3
	CAIGE	P1,3		;LENGTH 3 OR GREATER?
	JRST	GERILL		;NO--ERROR RETURN

	PUSHJ	P,CKJPPN	; JOB # MATCH PPN?
	  JRST	GERPPN		; NO--ERROR RETURN
	ADDI M,2		; POSITION FOR THE JOBSTR ARG
	PUSHJ	P,JOBST0	; PUSHJ TO JOBSTR CODE SO I
	  JRST	GERIFS		;   CAN HANDLE MY OWN ERROR RETURN
	JRST	CPOPJ1		; GOOD RETURN--PASS IT ON
;M  TO RETURN NEXT STR IN JOB'S OWN SEARCH LIST


;SO GOBSTR CAN USE THIS SAME CODE:
;   J HOLDS # OF JOB WHOSE SEARCH LIST IS TO BE SEARCHED (0 IS SYS SEARCH LIST)
;   P1=# OF ARGUMENTS

JOBSTR:	HRRM	T1,M		;ADDR OF USER'S ARGUMENT LIST
	HLRZ	P1,T1		;P1=NUMBER OF ARGS DESIRED
	SKIPN P1
	MOVEI P1,1		;CONVERT 0 TO 1

JOBST0:				; HERE FROM GOBSTR
	UMOVE T1,(M)		; GET 1ST ARG=STR NAME
	AOJE	T1,JOBST2	; JUMP IF BEGINNING DESIRED (-1)
	SOJN	T1,JOBST1	; JUMP IF NOT FENCE (0)
	MOVNI P2,1		; FENCE, NEXT IS END
	JRST JOBST8

JOBST1:	CAME T1,[SIXBIT /DSKB/]
	POPJ P,			; DSKB IS ONLY ALLOWED STR
	TDZA P2,P2		; FOLLOWED BY FENCE
JOBST2:	MOVE P2,[SIXBIT /DSKB/]	; FIRST STR IS DSKB
JOBST8:	UMOVEM	P2,(M)		; STORE STR NAME
	SOJE	P1,CPOPJ1	; SKIP RETURN IF NO MORE ARGS DESIRED
	XCTBU <SETZM	1(M)>	; ZERO FOR PPN WORD FOR NOW ***
	SOJE	P1,CPOPJ1	; SKIP RETURN IF NO MORE ARGS DESIRED
	XCTBU <SETZM 2(M)>	; STORE 0 FOR STATUS BITS
	JRST	CPOPJ1		; SKIP RETURN
SUBTTL STRUUO M
;M TO PERFORM VARIOUS FUNCTIONS FOR FILE STRUCTURES
;NOTE THAT ACCUMULATOR J IS J AND CONTAINS THE JOB NUMBER OF THE JOB
; EXECUTING THE M

;ERROR CODES

ERCODE ILLERR,\.ERILL	;ILLEGAL ARG.LIST LENGTH (LH M AC)
ERCODE NPVERR,\.ERNPV	;NOT PRIVILEGED PROGRAM
ERCODE PPNERR,\.ERPPN	;JOB #--PPN MISMATCH
ERCODE SNFERR,\.ERSNF	;F.S. NOT FOUND (NONEXISTANT)
INTERNAL SNFERR
ERCODE ILFERR,\.ERILF	;ILLEGAL FUNCTION
ERCODE UNFERR,\.ERUNF	;NO SUCH UNIT
ERCODE NCSERR,\.ERNCS	;NOT ENOUGH FREE CORE
INTERNAL NCSERR
ERCODE UNCERR,\.ERUNC	;UNABLE TO COMPLETE THE FUNCTION


INTERN STRUUO
STRUUO:	JSP	T4,SAVE4	;SAVE ALL 4 GLOBAL ACCUMULATORS
	MOVE	P4,T1		;SAVE T1 IN P4
	HRRM	T1,M		;ADDRESS OF ARGUMENT LIST
	UMOVE T1,(M)		;GET FIRST ARGUMENT = FUNCTION
	JUMPL	T1,ILFERR		;ILLEGAL IF NEGATIVE
	CAIL	T1,STRFNN	;SEE IF LEGAL FUNCTION
	JRST	ILFERR		;WELL, NO
	AOJA	M,@STRFNC(T1)
STRFNC:	XWD	ZERO5,SRCSTR	;(0) DEFINE NEW SEARCH LIST (UNPRIVILEGED)
	XWD	ZERO5,DSLSTR	;(1) DEFINE NEW SEARCH LIST (PRIVILEGED)
	XWD	ZERO5,ILFERR	;(2) DEFINE NEW FILE STRUCTURE
	XWD	ZERO5,ILFERR	;(3) REDEFINE FILE STRUCTURE (CHANGE BITS)
	XWD	ZERO5,ILFERR	;(4) LOCK OUT NEW INIT'S, ENTER'S ,ETC.
	XWD	ZERO5,ILFERR	;(5) REMOVE FILE STRUCTURE FROM SYSTEM
	XWD	ZERO5,ULKSTR	;(6) TEST/SET UFD INTERLOCK FOR LOGIN, LOGOUT, ETC
	XWD	ZERO5,UCLSTR	;(7) CLEAR UFD INTERLOCK
	XWD ZERO5,ETSSTR	;(10 ERROR TEST M (SIMULATE ERRORS) .FSETS
	RRSET			;(11) READ AND RESET BUFFERED LOG FOR 3330'S
STRFNN==.-STRFNC
SUBTTL STRUUO M - DEFINE NEW SEARCH LIST
;FUNCTIONS TO DECLARE NEW SEARCH LISTS

;FOR THIS JOB (UNPRIVILEGED)

SRCSTR:	HLRZ	P3,P4		; P3=ARG.LIST LENGTH - 1
	SOJA	P3,SLSTRR

;FOR ANY JOB (PRIVILEGED)

DSLSTR:	JSP	T4,PRIVJ		;PRIVILEGED JOB?
	PUSHJ	P,CKJPPN	; JOB # MATCH PPN?
	  JRST	PPNERR		; NO--ERROR RETURN
	HLRZ	P3,P4		; P3=ARG.LIST LENGTH - 4
	SUBI	P3,4
	ADDI M,3		; FOR CKJPPN
; RH(J)=# OF JOB WHOSE SEARCH LIST IS TO BE DEFINED
; P3=ARG.LIST LENGTH (EXCLUDING INITIAL STUFF LIKE FUNCTION NO.)

; FALL OR SKIP INTO HERE FROM DSLSTR CODE

SLSTRR:	JUMPLE	P3,CPOPJ1	; IF NO F.S. GIVEN, TREAT AS ERROR
SLSTR0:	UMOVE T1,(M)		; GET NEXT F.S. NAME
	JUMPE	T1,NPVERR	; NOT ALLOWED TO HAVE EMPTY LIST
	CAMN T1,[SIXBIT /DSKB/]		;NOT ALLOWED ANY BUT DSKB
	XCTBU <SKIPE 2(M)>	;NO SPECIAL STATUS ALLOWED
	JRST SNFERR
	ADDI M,3
	SUBI P3,3
	JUMPLE P3,CPOPJ1	;FINISHED (ASSUME FENCE)
	XCTBU <SKIPN 2(M)>	;ALLOW A FENCE
	CAILE P3,3		;BUT THAT MUST BE END OF LIST
	JRST SNFERR
	JRST CPOPJ1
SUBTTL	STRUUO - UFD INTERLOCK
LKCLNA==3			;MUST HAVE 3 ARGS INCLUDING FUNCTION CODE
ULKSTR:	TDZA	P3,P3		;CLEAR P3 AND SKIP
UCLSTR:	SETO	P3,		;SET P3 NON-0
	JSP	T4,PRIVJ	;ONLY RETURN IF PRIVILEGED JOB
	HLRZ	T1,P4		;T1=NUMBER OF ARGS
	CAIGE	T1,LKCLNA	;MUST HAVE ENOUGH ARGS
	PJRST	ILLERR		;NOT ENOUGH ARGUMENTS
	UMOVE P1,(M)		;GET STR NAME IN P1 FOR LOKPPB
	UMOVE P2,1(M)		;AND PPN IN P2
	PJUMPE	P3,LOKPPB	;IF ILK, CALL LOKPPB TO TEST/SET
	PUSHJ	P,NLKPPB	;ELSE CALL NLKPPB TO CLEAR
	PJRST	CPOPJ1		;AND RETURN OK

SUBTTL STRUUO - .FSETS ERROR TESTING

;.FSET-ERROR TESTING-FUNCTION TO FORCE CONI AND DATAI ERRORS ON A UNIT
;PART OF STRUUO.
;ARGS ARE FUNCTION, UNIT NAME, ETC. SEE COMMOD FOR
;TABLE OF ARGS-ETSTAB.
;USER MUST BE PRIVILEGED
; ERROR RETURN IF SOME UNIT IS ALREADY BEING ERROR TESTED (.ERUNC)
; UNIT NOT FOUND (.ERFUNF)

ETSSTR:	JSP	T4,PRIVJ	;CHECK FOR PRIVILEGED JOB
	UMOVE T1,(M)		;GET UNIT NAME
	SKIPE	ETSUNI		;ALREADY TESTING ERRORS ON SOME UNIT?
	JRST	UNCERR		;YES, GIVE ERROR RETURN SO TWO
				; USER'S DO NOT CONFUSE EACH OTHER
	SETOM	T2		;SET UNIT NAME MASK TO -1
	PUSHJ	P,SRUNI		;SEARCH FOR UNIT NAME
	  JRST	UNFERR		;UNIT NOT FOUND
	  JFCL			;LOGICAL UNIT NAME
	MOVSI	P1,METSLN	;-LENGTH OF ARG PICKUP
ETSLUP:	ADDI M,1		;GET NEXT USER ARG
	UMOVE T1,(M)
	MOVEM	T1,ETSTAB(P1)	;STORE
	AOBJN	P1,ETSLUP	;MORE?
	MOVEM	U,ETSUNI	;NOW SET UNIT ADDRESS WHICH
				;ENABLES FAKE ERROR TESTING
	JRST	CPOPJ1
SUBTTL M RETURNS AND ERROR CODES

;HERE TO PUT T1 IN USERS M AC AND SKIP RETURN

RETARG:	UMOVEM T1,(W)
	JRST	CPOPJ1

;THESE RETURNS TO PUT ERROR CODE IN USERS M AC AND NO-SKIP RETURN

	DEFINE XCOD(A)
<ECOD'A:	JSP T1,ECOD>

%%XCOD==-
	REPEAT MXECOD+1,<XCOD (\%%XCOD)
%%XCOD==%%XCOD+1>
ECOD:	SUBI	T1,ECOD0+1

	UMOVEM T1,(W)
	POPJ	P,
;CODE FOR INTERLOCK

;	JSP	T4,LOCK
;	--WILL BE UNLOCKED BY MATCHING POPJ (OR CPOPJ1)--

LOCK:	PUSHJ P,GETCBR
	MOVEI F,GIVCBR
	PUSH P,J
	MOVE J,JOB
	MOVEM F,JBTABT(J)	;SET IN CASE OF ADDRESS ERROR
	POP P,J
	MOVEI F,0		;JUST IN CASE
	PUSHJ P,(T4)
	 SKIPA
	AOS (P)
	MOVE J,JOB
	SETZM JBTABT(J)
	PJRST GIVCBR

RRSET:	MOVSI T1,LICSTR!LICJAL
	TDNN T1,JBTLIC(J)		;MUST HAVE ENOUGH LICENSE
	JRST NPVERR
	UMOVE T1,(M)	;THIS IS THE UNIT NAME
	MOVNI T2,1
	PUSHJ P,SRUNI
	 JRST UNFERR
	 JRST UNFERR	;DO NOT ACCEPT LOGICAL NAMES
	HRRZ J,UNIKON(U)
	SKIPL KONLTM(J)
	 JRST UNCERR	;ONLY FOR NON-CHANNEL DEVICES
	JRST RRSETB	;GO TO THE CODE IN FILIO
;% SUBROUTINE TO GET JOB # & PPN FROM ARG. LIST AND CK FOR A MATCH
;% CALL:		M=ADDRESS-1 OF JOB # ARG.
;% 		    PPN ARG. FOLLOWS
;% RETURN+0	IF RIDICULOUS JOB # OR DOESNT MATCH PPN
;% 		M & J ARE CHANGED
;% RETURN+1	IF JOB # ARG. MATCHES PPN ARG.: J=JOB # ARG.
;% 		IF JOB # ARG.=PPN ARG.=-1: J=J (CURRENT JOB #)

CKJPPN:	UMOVE T1,(M)		;% T1=JOB # (1ST ARG.)
	JUMPN T1,CKJPP2		;% NOT SYS
	UMOVE T1,1(M)
	CAME T1,SYSPPN
	POPJ P,			;% NO MATCH
	MOVEI J,0		;% JOB=0 FOR SYS SEARCH LIST
	JRST CPOPJ1
CKJPP2:	SKIPG	T1		;% IF -1: USE CURRENT JOB #
	MOVE	T1,J
	SKIPLE	T1		;% IS IT GOOD JOB #?
	CAMLE	T1,HIGHJB
	POPJ	P,		;% NO
	MOVE	J,JBTSTS(T1)	;% MAYBE  (CK JNA BIT)
	TLNN	J,JNA
	POPJ	P,		;% NO
	MOVE	J,T1		;% YES--MAKE J=JOB #
	UMOVE T1,1(M)		;% T1=PPN
	SKIPG	T1		;% IF -1: USE CURRENT PPN
	MOVE	T1,JBTPPN(J)
	CAME	T1,JBTPPN(J)	;% IS PPN FOR THIS JOB #?
	POPJ	P,		;% NO
	JRST	CPOPJ1		;% YES--GOOD MATCH


;SUBROUTINE TO CK FOR PRIVILEGED JOB (FAILSAFE PPN OR JACCT LIT)
;CALL:	JSP	T4,PRIVJ
;		J=JOB #
;		PRESERVES T1
;RETURNS IF PRIVILEGED OTHERWISE GOES TO NPVERR

PRIVJ:	MOVSI T3,LICSTR
	TDNE T3,JBTLIC(J)
	JRST (T4)		;HE CAN DO IT
	JRST NPVERR	;NO- GIVE ERROR RETURN
SUBTTL DSKCHR M

CODDSK==0
CODSFS==1
CODSTR==2
CODLUF==3
CODKNC==4
CODKON==5
CODPUN==6

INTERN DSKCHR
DSKCHR:	HLRZ	T3,T1		;COMPUTE LAST ADDRESS OF TABLE
	MOVN	J,T3
	HRLZS	J
	JSP	T4,LOCK		;LOCK DATA SO IT CAN BE BELIEVED

	HRR J,T1		;% REMEMBER START OF ARG LIST
	UMOVE T1,(T1)		;% GET DISK NAME
	JUMPE	T1,CPOPJ		;% ERROR IF ARG. ZERO
	MOVSI	S,CODDSK	;% PRESUME ARG. TO BE "DSK". SET CODE ACCORDINGLY
	PUSH	P,J		;% SAVE J
	MOVE	J,JOB		;% SET J TO CURRENT JOB
	PUSHJ	P,DEVLG		;% SEARCH ALL LOGICAL NAMES IN SYSTEM FOR A MATCH
	  JRST	DSKCHK		;% NO MATCH - CHECK FOR "DSK"
	MOVSI	T2,DVDSK
	TDNN	T2,DEVMOD(F)	;% IS IT A DISK?
	JRST	TPOPJ		;% NO - EXIT
	MOVE	T1,DEVNAM(F)	;% PICK UP
	MOVEI F,0		;% JUST TO MAKE SURE 0 IN CASE ERROR
;% HERE TO SEE WHETHER C(T1) IS "DSK","DS" OR "D"
DSKCHK:	PUSHJ	P,ALIASD	;% IS NAME AN ALIAS FOR "DSK"?
	  JRST	DSKFND		;% YES - FIND FIRST UNIT OF 1ST. STR FOR THIS JOB
	MOVSI	S,CODSTR	;% PRESUME ARG. TO BE STR NAME
	CAMN T1,[SIXBIT /DSKB/]	;% ONLY STR ALLOWED
	JRST DSKFND		;% YES, USE FIRST UNIT
	MOVSI S,CODLUF		;%ASSUME LOG. UNIT IN STR
	PUSHJ	P,SRUNI		;% SCAN ALL PHYSICAL AND LOGICAL UNIT NAMES
	  JRST	TPOPJ		;% NO MATCH - EXIT
	  JRST	LOGCHK		;% MATCH ON LOGICAL NAME
	SETCA	T2,0		;% MATCH ON PHYSICAL NAME
	JFFO	T2,.+2		;% DETERMINE # CHARS. IN ARG. FROM MASK
	STOPCD(SLO)		;% ERROR - 6 CH. ARG. CAN'T1 MATCH WITH REMAINING NAME
	MOVSI	S,CODKNC	;% PRESUME KONTROLLER NAME
	CAIG	T3,^D12		;% 1 OR 2 CHARS.?
	JRST	FNDSTR		;% YES. SETUP USER AC
	MOVSI	S,CODPUN	;% PRESUME PHYS. UNIT NAME
	CAIN	T3,^D18		;% 3 CHARS.?
	MOVSI	S,CODKON	;% YES KONTROLLER NAME
	JRST	FNDSTR		;% DEPOSIT VALUE IN TABLE AND SETUP USER AC.

;HERE WHEN ARG. WAS OR IMPLIED "DSK" TO FIND FIRST UNIT OF JOB'S FIRST FILE STRUCTURE

DSKFND:	HLRZ U,STRUNI+STRDDB	;% USE FIRST UNIT IN STR FOR DSK OR DSKB
	JRST FNDSTR


;SUBR TO SEE IF SPECIAL UNIT IN STR IS DESIRED (CALLED BY
;INIT/OPEN).

INTERN TST1UN
TST1UN:	MOVE	T1,DEVMOD(F)	;IS THIS A
	TLNN	T1,DVDSK	;DISK?
	POPJ	P,		;NO.
	MOVE	T1,DEVNAM(F)	;YES. IS IT DSK OR
	PUSHJ	P,ALIASD	;DS OR D?
	POPJ	P,		;YES.
	CAMN	T1,[SIXBIT/DSKB/] ;NO, DSKB?
	POPJ	P,		;YES.
	HLRZ	U,STRDDB+STRUNI ;NO, MAYBE A SPECIAL
TST1U2:	CAME	T1,UNINAM(U)	;UNIT?
	CAMN	T1,UNILOG(U)	;
	JRST	TST1U5		;YES.
	HLRZ	U,UNISTR(U)	;TRY AGAIN.
	JUMPN	U,TST1U2	;
	POPJ	P,		;
EXTERN DEV1UN
TST1U5:	MOVEM	U,DEV1UN(F)	;SPECIAL UNIT.
	POPJ	P,


;SUBROUTINE TO TEST IF A NAME IS AN ALIAS FOR "DSK"
;ENTER WITH NAME IN T1
;EXIT NAME IN T1, MASK IN T2
;RETURN CPOPJ IF NAME IS AN ALIAS FOR "DSK", CPOPJ1 OTHERWISE

INTERN	ALIASD

ALIASD:	PUSHJ	P,MSKUNI	;GENERATE MASK IN T2 FROM # OF CHARS. IN T1
	MOVSI	T3,(SIXBIT .DSK.)
	AND	T3,T2		;MASK OUT SUPERFLUOUS CHARS
	CAME	T1,T3		;MATCH ON "D", "DS" OR "DSK"?
	AOS	(P)		;NO. SET FOR SKIP RETURN
	POPJ	P,		;RETURN CPOPJ OR CPOPJ1
;% HERE WHEN A MATCH IS FOUND BETWEEN LOGICAL NAME(UNILOG) & C(T1)

LOGCHK:	CAME	T1,UNILOG(U)	;% EXACT MATCH WITH LOGICAL UNIT NAME?
	MOVEI	S,CODSFS	;% NO - MUST BE SUBSET OF STRS
FNDSTR:	MOVE	T1,UNIDES(U)	;% LOAD UP BITS FOR USER AC.
	TLZ T1,377		;GET RID OF UNIT BLOCK SIZE
	IOR	T1,S		;% "OR" IN ARG. TYPE CODE.
FNDST1:	POP P,J			;% RESTORE USER ARG
	UMOVEM	T1,(W)		;% STORE BITS IN USER AC.
	AOBJP	J,CPOPJ1	;% IS LENGTH >1?
	MOVSI	T1,MATLEN	;% SETUP LENGTH & INDEX INTO ARGTAB
	LDB T3,UNYSPU		;% SATS/UNIT =0 IF NOT IN STR
	MOVE P1,[647200,,0]	;% 1 FOR ARGS TO IGNORE IF NO FS
ARGLUP:	TLNE P1,400000
	SKIPE T3	;% HIGH ORDER BIT A 1, IGNORE IF NO FS
	SKIPA		;% ALWAYS RETURN OR IN FS
	TDZA T2,T2	;% IGNORE, RETURN 0
	XCT ARGTAB(T1)
	LSH P1,1	;% AND SHIFT FOR NEXT TEST
	UMOVEM	T2,(J)		;% DEPOSIT IN TABLE
	AOBJP	J,CPOPJ1	;% FINISHED?
	AOBJN	T1,ARGLUP	;% NO INCREMENT INDEX
	JRST	CPOPJ1		;% RETURN

ARGTAB:	PUSHJ	P,GUFBT		;LOC+1(.UFTAL)
	MOVE	T2,STRDDB+STRTAL	;LOC+2(.STTAL)
	MOVE	T2,UNITAL(U)	;LOC+3(.UNTAL)
	MOVE	T2,[SIXBIT /DSKB/]	;LOC+4(.STNAM)
	MOVE	T2,UNICHR(U)	;LOC+5(.UNCHR)
	MOVE	T2,UNIPPU(U)	;LOC+6(.UNPPU)
	MOVEI	T2,0	;LOC+7(.STMNT)
	LDB	T2,UNYWPS	;LOC+10(.UNWPS)
	LDB	T2,UNYSPU	;LOC+11(.UNSPU)
	MOVEI	T2,0		;LOC+12(.UNP4S) - OBSOLETE
	MOVEI	T2,0	;LOC+13(.STJOB)
	MOVE	T2,UNILOG(U)	;LOC+14(.UNLOG)
	MOVE	T2,UNINAM(U)	;LOC+15(.UNNAM)
	MOVE	T2,UNIHID(U)	;LOC+16(.UNHID)
	MOVEI	T2,0		;LOC+17(.UNUFS) - OBSOLETE
	MOVE T2,[LPNHOM##,,LP2HOM##]	;LOC+20(.UNHA)
	MOVE T2,[LPNBAT##,,LP2BAT##]	;LOC+21(.UNBA)
	MOVE T2,[NBOOTP##,,FBOOTB##]	;LOC+22(.UNBSA)
MATLEN==ARGTAB-.		;ADD NEW ENTRIES TO TABLE HERE
;SUBROUTINE TO SET UP A SEARCH-MASK FOR A NAME
;ENTER WITH T1 =NAME
;EXIT WITH T1=NAME, T2=MASK
MSKUNI:	SKIPN	T2,T1		;GET NAME
	POPJ	P,		;NOT A NAME - RETURN MASK =0
	MOVSI	T3,770000	;SET  UP MASK
UNIMS1:	TDON	T2,T3		;THIS CHARACTER 0?
	JRST	UNIMS2		;YES. HAVE MASK
	LSH	T3,-6		;NO, SHIFT AND TRY NEXT CHAR
	JUMPN	T3,UNIMS1
UNIMS2:	TDZ	T2,T3		;0 THE LAST BYTE
	POPJ	P,		;AND RETURN WITH MASK IN T2
;SUBROUTINE TO SEARCH UNIT DATA BLOCKS FOR A MATCH BETWEEN C(T1)
;AND AN EQUIVALENT NUMBER OF CHARACTERS OF UNILOG AND UNINAM
;CALL	MOVE	T2,MASK
;	MOVE	T1,SIXBIT NAME OF FILE STRUCTURE,UNIT,KONTROLLER, ETC.
;	PUSHJ	P,SRUNI
;	  NON MATCH RETURN	T1 & T2 ARE RESPECTED. U IS 0
;	  LOGICAL NAME MATCH	T1 & T2 ARE RESPECTED. U IS THE ADR. OF UNIT DATA BLOCK.
;	PHYSICAL NAME MATCH

INTERN SRUNI
SRUNI:	HLRZ	U,SYSUNI	;GET ADR. OF FIRST UNIT IN SYSTEM
LUPUNI:	MOVE	T3,UNILOG(U)	;GET LOGICAL UNIT NAME WITHIN STR
	AND	T3,T2		;MASK OUT UNWANTED CHARS.
	CAMN	T1,T3		;MATCH?
	JRST	CPOPJ1		;YES - FOUND A LOGICAL UNIT MATCH RETURN
	MOVE	T3,UNINAM(U)	;GET PHYSICAL UNIT NAME
	AND	T3,T2		;MASK
	CAMN	T1,T3		;MATCH?
	JRST	CPOPJ2		;YES - FOUND A PHYSICAL UNIT MATCH RETURN
	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT IN SYSTEM
	JUMPN	U,LUPUNI	;LAST ONE?
	POPJ	P,		;YES - RETURN
;SUBROUTINE TO COMPUTE SIXBIT LOGICAL UNIT NUMBER WITHIN STR
; T1 HAS NUMBER WITHIN STR IN RH, LH GARBAGE.

INTERN CMPLOG
CMPLOG:	PUSH	P,P3
	HRRZ	P3,T1
	LSH	P3,-^D3
	ADDI	P3,20
	LSH	P3,^D6
	ANDI	T1,7
	ADDI	P3,20(T1)
	MOVE	T1,[SIXBIT /DSKB/]
	PUSHJ	P,MSKUNI
	SETCA	T2,0
	JFFO	T2,.+2
	STOPCD(SLO)
	MOVEI	T2,^D24
	TRNE	P3,700
	JRST	INSUN2
	TRZ	P3,7700
	MOVEI	T2,^D30
INSUN2:	SUB	T2,T3
	LSH	P3,(T2)
	ADD	T1,P3
	MOVEM	T1,UNILOG(U)
	POP	P,P3
	POPJ	P,

	END
R.