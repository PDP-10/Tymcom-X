TITLE	SCHED1 - SCHEDULING ALGORITHM FOR SWAPPING SYSTEM

ENTRY SCHED		;THIS UNDEFINED GLOBAL IN COMMON CAUSES THIS
			; ROUTINE TO BE LOADED.
ENTRY SCHED1
SCHED1:

EXTERNAL JOB,JBTSTS,JBTQ,PJBSTS,PJBST2,TIMEF,TPOPJ
EXTERNAL CPOPJ1,TTYFND,TSETBI,HIGHJB,PGYSIO,PGYDIO,JBTICT
EXTERNAL %UPT, UPTNTV, AGENTV, JBTUID, SYSUID

INTERN NXTJOB


;INITIALIZE SCHEDULER  (CALLED FROM SYSINI BEFORE ALL OTHER
;	DEVICES ARE INITIALIZED)

INTERN NXTINI

NXTINI:	SETZM	QJOB		;CLEAR NUMBER OF JOBS NEEDING REQUEING
	SETZM	JOBQUE		;CLEAR JOB NUMBER TO BE REQUEUED
				;BE SWAPPED RIGHT NOW.
	POPJ	P,

DEFINE CALTAL
<>

DEFINE DSKOFF <WRPI DSKPIF>
DEFINE DSKON <WRPI DSKPIN>

SALL
IFNDEF SCDTRC,<SCDTRC==0>
IFE SCDTRC,<DEFINE TRACE(TYPE,INST,DATA1,DATA2,COND)<INST>>

IFN SCDTRC,<

DEFINE TRACE(TYPE,INST,DATA1,DATA2,COND)<
	JRST	[IFNB <COND><'COND
		   JRST ['INST
			  JRST .+1
			  JRST .+2]>
		 PUSH P,T1
		 MOVE T1,UPTIME##
		 HRL T1,J
		 PUSHJ P,PUTIN##
		 MOVEI T1,^D'TYPE
		 PUSHJ P,PUTIN
IFIDN <DATA1> <T1> <MOVE T1,(P)>
IFDIF <DATA1> <T1> <MOVE T1,'DATA1>
		PUSHJ P,PUTIN
IFIDN <DATA2> <T1> <MOVE T1,(P)>
IFDIF <DATA2> <T1> <MOVE T1,'DATA2>
		PUSHJ P,PUTIN
		POP P,T1
		'INST
		JRST .+1
		JRST .+2]
>;END TRACE MACRO DEFINITION
>;END IFN SCDTRC
;NXTJOB DECREMENTS CURRENT JOB'S QUANT. AND PROTECT
;TIMES AND REQUEUES IT IF QUANT. TIME GONE TO 0.
;SERVICES ANY JOB REQUEUING REQUESTED AT OTHER PRIORITY
;LEVELS THEN CALLS SHUFFLER,SWAPPER AND SCHEDULAR.
;MAKES NO ASSUMPTIONS RE. ACS
;RETURNS NEXT JOB TO RUN IN J.

EXTERNAL POTLST,JBMQNT,REQUE,DECHJB,DRSCHK

NXTJOB:	PUSHJ	P,SWPCHK	;DO SWAP DONE STUFF NOW, BECAUSE
				; SWAP OUT DONE REQUEUES JOBS
	SKIPN	TIMEF		;CLOCK TIC?
	JRST	NXTJB1		;NO.
	MOVE	J,HIGHJB	;GET HIGHEST JOB NO.
	MOVSI	T2,-1		;DECREMENT IN CORE PROTECT TIME
	SKIPL	JBTICT(J)	;UNLESS ALREADY < 0.
	ADDM	T2,JBTICT(J)	;DECREMENT.
	SOJG	J,.-2

NXTJB1:	SKIPG	J,JOB		;CURRENT JOB NO., IS IT NULL JOB?
	JRST	CKJB1		;YES,GO SEE IF OTHER JOBS NEED RESCHEDULING
	MOVEI	F,0		;GET READY IN CASE CURRENT JOB UNRUNABLE
	HLRZ	T2,JBTSTS(J)	;GET JOB STATUS BITS AND CODES
	TRZ	T2,RUNMSK!CMWB!MRQ	;MASK OUT DO NOT CARE BITS
	CAIE	T2,RUNABLE	;IS CURRENT JOB RUNABLE?
	JRST	CKJB0		;NO, REQUE CURRENT JOB
	HRLZI	T2,CMWB!MRQ
	TDNN	T2,JBTSTS(J)	;IF THE CURRENT JOB'S RUNNABLE
	SKIPN	TIMEF		;AND IT'S A CLOCK TICK,
	JRST	.+3
	SKIPLE	%UPT+UPTNTV	;  IF PAGE-AGE INTERVAL > 0,
	SOS	%UPT+UPTNTV	;    DECREMENT IT
	SOS	T2,JBTICT(J)	;DECREMENT QUANT. TIME
	TRNE	T2,JBMQNT	;HAS TIME GONE TO 0?
	JRST	CKJB1		;NO
	MOVEI	U,QTIME		;YES--REQUEUE AND RESET QUANT. TIME
	MOVE	T1,JBTSTS(J)
	TRNE	T1,SCHPRV
	MOVEI	U,QHIP		;SPECIAL HIGH PRIORITY Q
	MOVE	T1,JOBQUE
	PUSHJ	P,QXFER
	JRST	CKJB1

CKJB0:	PUSHJ	P, REQUE	;FLAG CURRENT TO BE REQUEUED
				;AND GO REQUEUE ALL
CKJB1:	SKIPG	F,QJOB		;SET	F NON ZERO IF ANY REQUEUEING TO DO
	JRST	CKJB5		;NO REQUEUEING NECESSARY
	MOVE	J,HIGHJB	;START WITH HIGHEST JOB NUMBER ASSIGNED
CKJB2:	MOVSI	T2,JRQ		;JOB NEEDS REQUEUEING BIT
	TDNN	T2,JBTSTS(J)	;THIS JOB?
	SOJG	J,.-1		;NO,KEEP LOOKING
	JUMPLE	J,CKJB5		;YES,LOOKED AT ALL JOBS?
				; (MAY NOT FIND A KJOBED JOB IF HIGHEST
				; GO DECR. COUNT QJOB ANYWAY)
	ANDCAM	T2,JBTSTS(J)	;NO,MARK THIS JOB AS DONE
	PUSHJ	P,DECHJB	;MAY HAVE ONLY HAD JRQ ON, GET RID
			;OF IT IF SO
CKJB3:	MOVE	T2,JBTSTS(J)	;JOB STATUS WORD
	TLNE	T2,CMWB!MRQ	;ANY POSSIBILITY THAT JOB HAS TO
				; GO INTO COMMAND WAIT QUEUE?
	JRST	CKJB4D		;YES, IF BOTH ARE ON, DO SO
CKJB9:	JUMPGE	T2,CKJB4	;NO--IS RUN BIT ON ?  IF NOT, JOB GOES TO STOP Q.
	LDB	U,PJBST2	;YES, JOB WAS RUNNABLE, GET QUEUE CODE.
	CAIE	U,SSQ		;COMING OUT OF SWAP OR
	CAIN	U,WSQ		;I/O WAIT?
	JRST	CKJB10		;YES--DO SPECIAL REQUEUEING IF HEAVY SWAPPING.
	CAIN	U,TIOWQ		;CURRENT JOB GOING INTO TTY I/O-WAIT ?
				;CAN AHPPEN IF ATTACHING BACK TO JOB IN
				; TTY INPUT WAIT
				;BESIDES IT IS GOOD PROTECTION TO PREVENT
				; CLOBBERING DISK PTR
	HRROS	JBTICT(J)	;YES, SET IN CORE PROTECT TIME TO -1, SO TTY-WAIT
				; JOB CAN BE SWAPPED OUT IMMEDIATELY IF SOMEONE
				; ELSE WANTS TO BE SWAPPED IN.
	CAIN	U,RNQ		;DOESS HE WANT TO RUN?
	PUSHJ	P,PRICHK	;YES, CHECK SHARABLE RES
	  JRST CKJB4B		;NO, REQUE NORMALLY
CKJB4C:	MOVEI	U,QHIP		;SPECIAL HIGHER PRIORITY REQUE
	JRST	CKJB4A
CKJB4D:	TLC	T2,CMWB!MRQ	;COMPLEMENT
	TLCE	T2,CMWB!MRQ	;SKIP IF THEY WERE BOTH ZERO
	JRST	CKJB9		;MUST BOTH BE ON TO PUT INTO CMQ
	MOVEI	U,QCMW		;MRQ AND CMWB BOTH ON, PUT INTO COMMAND WAIT Q
	JRST	CKJB4A		;GO XFER TO CMQ
CKJB4B:	SKIPA	U,QBITS(U)	;GET ADDRESS OF TRANSFER TABLE
CKJB4:	MOVEI	U,QSTOP		;IF RUN BIT WAS OFF
CKJB4A:	PUSHJ	P,QXFER		;REQUEUE THE JOB.
	JUMPE	F,SCHED		;IF FROM NXTJOB GO DIRECTLY TO SCHED
				; I.E. CURRENT JOB NO LONGER RUNNABLE(IOW)
				; BUT JRQ WASN'Q SET SO DON'Q DECR QJOB
	SOSLE	F,QJOB		;ANY MORE JOBS TO REQUEUE?
	SOJG	J,CKJB2		;YES,BUT LOOK AT EACH JOB ONLY ONCE PER CLOCK TICK

    ;CHECK AVAL FLAGS FOR SHARABLE DEVICES.
CKJB5:	MOVEI	F,AVLNUM-MINQ	;
CKJB6:	SKIPN	AVALTB+MINQ(F)	;FLAG=0?
	SOJGE	F,CKJB6		;YES - TRY NEXT ONE.
	JUMPL	F,CKJB7		;NO - OR FINISHED?
CKJB62:	HLR	J,AVLQTB+MINQ(F) ;NO--GET 1ST JOB IN Q.
CKJB6A:	HRRE	J,JBTQ(J)	;
	JUMPG	J,CKJB65	;JUMP UNLESS FINISHED QUEUE.
	HLR	J,AVLQTB+MINQ(F) ;GIVE AVAIL RES TO 1ST WAITER,
	HRRE	J,JBTQ(J)	;EVEN IF HE IS SWAPPED OUT.
	JUMPLE	J,CKJB8		;JUMP IF NONE REALLY IN THE WAIT Q
				; WHICH ACTUALLY HAPPENS WITH DECTAPE.
	JRST	CKJB6B		;YES, SOMEONE TO GIVE IT TO.
CKJB65:	MOVE	U,JBTSTS(J)	;NO.
	TLNE	U,MRQ		;LOW SEG OKAY TO RUN?
	JRST	CKJB6A		;NO.
CKJB6B:	XCT	MRKSWT+MINQ(F)	;MARK AS WAITING FOR SWAP IN FOR RESOURCE
	HRRZ	U,AVLQTB+MINQ(F) ;GET TRANS. TABLE ADDRESS
	PUSHJ	P,QXFER		;REQUEUE THE JOB AND PUT IT IN
				;PROCESSOR Q SO SCHEDULER WILL RUN IT
	AOSE	AVALTB+MINQ(F)	;RESET AVAL FLAG.
	JRST	CKJB62		;NOT ALL THESE RESOURCES ALLOCATED.
CKJB8:	SOJGE	F,CKJB6		;CONTINUE IF ANY MORE FLAGS TO LOOK AT
CKJB7:	AOSE	CALSWP		;IF SOMEONE WANTS A PAGE OR
	SKIPE	TIMEF		;IF THIS IS A CLOCK TICK CALL,
	PUSHJ	P,SWAP		;DO SWAPPING.

;SCHEDULAR--SEARCH THRU QUEUES ACCORDING TO SSCAN TABLE
;FOR 1ST JOB IN CORE--RETURN ITS NO. IN J

SCHED:	SETZM	POTLST		;CLEAR POTENTIALLY LOST TIME FLAG
	MOVEI	U,SSCAN		;ADDRESS OF SCAN TABLE
	JSP	F,QSCAN		;BEGIN SCAN
	  JRST	SCHD6		;NO MORE JOBS -- RETURN NULLJOB
	SETOM	POTLST		;SET POTENTIALLY LOST TIME FLAG FOR
				; CLOCK1
	MOVE	T1,JBTSTS(J)	;GET JOB STATUS WORD IN T1
	TLNE	T1,MRQ!JRQ	;IS HE RUNNABLE?
	JRST	(M)		;NO, HAS NO CONTEXT PAGES OR JRQ.


SCHD5:	TRACE(0,<HLREM	M,JOBQUE>,,,<CAMN J,JOB>)	;YES--SAVE ITS Q
	MOVSI	F,WTMASK	;CLEAR WAIT CODE
	ANDCAM	F,JBTSTS(J)
	SETZM	POTLST		;CLEAR POTENTIALLY LOST TIME AS A USER IS TO BE RUN
	MOVE	F,JOB		;WHO WE RAN BEFORE
	JUMPLE	F,CPOPJ		;IF IT WAS ANYBODY INTERESTING,
	MOVEM	F,OLDJOB	;REMEMBER FOR CRASH ANALYSIS
	POPJ	P,			;RETURN
SCHD6:	TRACE(1,<SETZ	J,>,,,<SKIPN JOB>)		;RETURN NULL JOB
	POPJ	P,
;SPECIAL LOGIC TO PERMIT TTY-I/O-WAIT-SATISFIED JOBS TO DISPLACE
;I/O BOUND JOBS IN CORE. JOBS COMING OUT OF I/O WAIT WILL BE
;REQUEUED ACCORDING TO THEIR CORE SIZE IF ANYONE IS WAITING TO
;BE SWAPPED IN. THIS WILL BE PARTICULARLY HARD ON LARGE I/O
;BOUND JOBS, BUT TOUGH ROCKS FOR THOSE NASTY CASES.

CKJB10:	PUSHJ	P,PRICHK	;HAVE SHARABLE RES?
	 JRST	.+2		;NO
	JRST	CKJB4C		;YES, SPECIAL REQUE
	SKIPL	JBTICT(J)	;YES. THIS JOBS INCORE PROTECT TIME RUN OUT?
	JRST	CKJB4B		;REQUEUE NORMALLY,ICPT STILL UP
	MOVEI	U,QRNW1		;TIME TO PUT THIS JOB IN A LOWER Q. RE-Q
	JRST	CKJB4A		; HIM TO END OF A QUEUE, DEPENDING ON SIZE

CALSWP::0			;SET TO -1 IF SOMEONE WANTS A PAGE
OLDJOB: 0			;PREVIOUS CONTENTS OF CELL "JOB"


; CHECK FOR SPECIAL SCHEDUALING PRIVILEGE
; T2 HAS JBTSTS WORD, IT GETS SMASHED.

PRICHK:	TRNE	T2,SCHPRV	;HAS SCHEDULING PRIVILEGE?
	JRST	CPOPJ1		;YES, PUT IN HIGH QUEUE
	JRST	DRSCHK		;NO. CHECK FOR SHAREABLE RESOURCE

SUBTTL	QCSS R. KRASIN

;THIS ROUTINE MUST BE ASSEMBLED WITH THE CONFIGURATION
;TAPE TO DEFINE NUMBER OF JOBS
;THIS SECTION CONTAINS 2 ROUTINES FOR Q MANIPULATION
;AND NECESSARY TABLES FOR SPECIFING OPERATIONS PERFORMED
;BY THEM.

INTERNAL QXFER,QSCAN

;STORAGE:
;EACH Q IS A RING STRUCTURED, FOWARD AND BACKWARD
;LINKED SRING LIST. THE "FIRST" LINK IN A Q IS
;A Q-HEADER POINTING TO THE FIRST AND LAST MEMBERS OF THE Q.
;A NULL Q HAS ONE LINK--THE Q-HEADER ITSELF.  THE LINKS MAKING
;UP THE QS ARE CONTAINED IN A TABLE (JBTQ) WITH NEGATIVE
;INDICIES (ADDRESSES LESS THAN JBTQ) USED FOR Q-HEADERS AND
;POSITIVE INDICIES USED FOR MEMBERS (JOBS). THUS ONLY ONE WORD
;PER LINK IS NECESSARY--ITS ADDRESS RELATIVE TO JBTQ GIVES THE
;JOB NO. (OR Q NO. IF NEGATIVE) WHICH IT REPRESENTS WHILE
;ITS CONTENTS CONTAINS THE LINKING POINTERS. THESE
;POINTERS ARE ALSO INDICIES RELATIVE TO JBTQ RATHER THAN
;ABSOLUTE ADDRESSES--RH(LINK)=FOWARD POINTER;
;LH(LINK)=BACKWARD POINTER.
;A JOB IS ASSUMED TO BE IN NO MORE THAN ONE Q AT A TIME, AND
;THE NULL JOB (JOB 0) DOES NOT APPEAR IN THE QS  (I.E. JBTQ
;ITSELF IS THE Q-HEADER FOR Q 0).

;ROUTINES:
;BOTH ROUTINES ARE "TABLE DRIVEN" IN THE SENSE THAT THE
;CALLING ROUTINE PROVIDES THE ADDRESS OF A TABLE WHICH
;DEFINES THE SPECIFIC OPERATIONS TO BE PERFORMED.

;QUEUE INITIALIN
;PUT ALL JOBS IN NULL QUEUE(JOB NO. NOT ASSIGNED)
;CALLED ON RESTART AT LOC. 143

INTERNAL QINI
EXTERNAL CPOPJ,JOBMAX,MXQUE
EXTERNAL JBQMN	;EQUALS JBTQ-NULQ

QINI:	MOVNI	T1,MXQUE	;MAKE ALL QUEUE HEADERS POINT TO THEMSELVES
	HRL	T1,T1		;BACKWARD POINTERS TOO
	MOVEM	T1,JBTQ(T1)
	AOBJN	T1,.-1

	MOVEI	T1,-NULQ	;PUT JOBS ALL IN NULQ QUEUE
	MOVSM	T1,JBTQ+1	;BACK POINTER FOR JOB 1
	MOVEI	J,JOBMAX	;MAX. JOB NO.
	MOVEM	T1,JBTQ(J)	;FORWARD POINTER OF JOBMAX JOB NO.
	HRLI	J,1		;SET NULQ HEADER TO POINT
	MOVSM	J,JBQMN		;TO JOB 1 AND JOBMAX.
	HRRZS	J
QINI1:	HRRM	J,JBTQ-1(J)	;JOB I-1 POINT TO JOB I
	SOJLE	J,QINI2		;FINISHED?
	HRLM	J,JBTQ+1(J)	;BACK POINTER JOB I+1 POINTS TO JOB I
	JRST	QINI1
QINI2:	SETZM	JBTQ		;CLEAR JOB 0.
	POPJ	P,

;DELETES A JOB FROM ITS "SOURCE-Q", DETERMINES A "DEST-Q"
;ACCORDING TO ONE OF 3 FUNCTIONS, AND INSERTS THE JOB AT
;THE BEGINNING OR END OF THIS DEST-Q. IN ADDITION IT MAY 
;RESET THE JOB'S QUANTUM TIME (RH JBTSTS).
;THE DRIVING TABLES ARE "TRANSFER TABLES":
;
;T.TABLE:	EXP <CODE>
;		XWD <QUANT-TAB>,<R-TAB>
;
;DEPENDING ON <CODE>, THE SECOND WORD IS EITHER DATA OR THE
;ADDRESSES OF "CORRESPONDANCE TABLES".
;
;THE PREFIX OF <CODE> SPECIFIES WHETHER THE JOB IS TO BE
;INSERTED AT THE BEGINNING OR END OF THE DEST-Q. THE SUFFIX
;DETERMINES THE FUNCTION USED TO SELECT THE DEST-Q.
;THE FOLLOWING ARE THE SIX CODES AND THEIR TABLE FORMATS:

;DEST-Q AS A FIXED (PREDETERMINED) Q:
;BQFIX:	INSERT AT BEG OF DEST-Q
;EQFIX:	INSERT AT END
;
; THE JOB IS TRANSFERED TO THE END OR BEG. OF THE Q <Q-TAB>
; IF <QUANT-TAB> = -1, QUANT. TIME IS NOT RESET.
; IF <QUANT-TAB> .G. 0 , QUANT. TIME IS RESET TO <QUANT-TAB>.
; SINCE THIS FUNCTION IS FULLY DEFINED BY THE SECOND WORD
; ALONE, NO CORRES. TABLE IS NECESSARY.
;DEST-Q AS A FUNCTION OF SOURCE-Q
;BQLINK:	INSRT AT BEG OF DEST-Q
;EQLINK:	INSERT AT END
;
; <Q-TAB>=ADDRES OF A CORRES. TABLE "LINKING" SOURCE-QS TO
; DEST-QS.
; IF <QUANT-TAB> = -1, QUANT. TIME IS NOT RESET.
; OTHERWISE <QUANT-TAB> IS TAKEN AS THE ADDRESS OF A
; TABLE OF QUANT. TIMES CORRESPONDING TO THE Q-LINKING TABLE.
; FORMAT OF THE TABLES ARE:
;
; <Q-TAB>:	XWD <SQ1>,<DQ1>	;1ST SOUQCE-Q:DEST-Q PAIR
;		...
;		XWD <SQN>,<DQN>	;NTH ...
;		Z		;ZERO TERMINATES TABLE
;
; <QUANT-TAB>:	EXP <QUANT1>	;CORRES. TO <Q-TAB>+0
;		...
;		EXP <QUANTN>	;CORRES. TO <Q-TAB>+N-1
;		Z
;
; UPON A CALL TO QXFER FOR THESE 2 CODES, AC T1 CONTAINES
; THE SOURCE-Q (CURRENT Q) OF THE JOB.  THE LH OF THE
; <Q-TAB> ENTRIES ARE SEARCHED FOR A MATCH..IF FOUND, THE
; RH IS TAKEN AS THE DEST-Q AND THE QUANT. TIME IS RESET
; (IF <QUANT-TAB> NOT -1) TO THE CORRRES. ENTRY IN THE
; <QUANT-TAB> TABLE.
; IF NO MATCH FOUND..NO TRANSFER TAKES PLACE.

;DEST-Q AS A FUNCTION OF JOB SIZE
;BQJSIZ	INSERT AT BEG OF DEST-Q
;EQJSIZ	INSERT AT END
;
; <Q-TAB>=ADDRESS OF A TABLE ASSOCIATING JOB SIZE
; (IN 1K BLOCKS) TO DEST-QS.
; <QUANT-TAB> HAS SAME MEANING AS FOR B-EQLINK
;
; <Q-TAB>:	XWD <JSIZ1>,<DQ1>
;		...
;		XWD <JSIZN>,<DQN>
;		Z
;
; <QUANT-TAB>: SIMILAR TO THAT FOR B-EQLINK
;
; THE <JSIZ>'S MUST BE IN INCREASING ORDER.
; THE TABLE IS SEARCHED UNTIL <JSIZ> IS LESS THAN OR
; EQUAL TO THE JOB SIZE, THEN THE CORRES. <DQ> IS
; TAKEN AS THE DEST-Q. IF THE TABLE IS EXAUSTED, NO
; TRANSFER TAKES PLACE.
; QUANT. TIME IS HANDLED AS IN B-EQLINK.
;CALLING SEQUENCE:
;	MOVE  J,[JOB NUMBER]
;	MOVE T1,[CURRENT Q]	;BQLINK AND EQLINK ONLY
;	MOVEI U,TRANS TABLE ADDRESS
;	PUSHJ P,QXFER
;	...		;RETURN
;  ON RETURN J IS UNALTERED; LH(PG)=-1  IF QUANT. TIME NOT
;  RESET; =QUANT. TIME IF RESET;RH(PG)=DEST.Q
;
;ACS:

EXTERNAL JBYQNT,GETSIZ

QXFER:
	SKIPN	J		;TRYING TO REQUE JOB 0?
	STOPCD	.		;YES, SHOULD NEVER HAPPEN, QUEUES WILL BE
				; MESSED UP AND SYSTEM WILL HANG IF ALLOWED
	MOVE	PG,1(U)		;GET TRANSFER TABLE ADDRESS
	JRST	@(U)		;DISPATCH

;DEST-Q AS FUNCTION OF SOURCE-Q
QLINK:	SKIPN	T2,(PG)		;END OF TABLE?
	POPJ	P,		;YES
	HLRE	T2,T2
	CAME	T2,T1		;NO--SOURCE-Q=LH(TABLE ENTRY)?
	AOBJP	PG,QLINK	;NO- CONTINUE SEARCH
	JRST	QX2		;YES

;DEST-Q AS FUNCTION OF JOB SIZE
QJSIZ:	PUSHJ	P,GETSIZ
	POP	P,T2		;GET SIZE INTO T2
	HRLZ	T1,T2		;MOVE TO LH FOR MATCHING
QX1:	SKIPN	T2,(PG)		;END OF TABLE?
	STOPCD
	CAMLE	T1,T2		;JOBSIZE .LE. LH(TABLE ENTRY)?
	AOBJP	PG,QX1		;NO--CONTINUE SEARCH, JUMP ALWAYS.

QX2:	MOVS	T1,PG		;T1 IS ADDR. OF QUANT.TIME(IF REQUESTED)
	HRRO	PG,(PG)		;RH(PG)=DEST-Q;LH=-1(NO QUANT.TIME REQ.)
	SKIPL	1(U)		;WAS QUANT. TIME REQUESTED?
	HRL	PG,(T1)		;YES--GET IT

;FIXED DEST-Q
QFIX:	MOVE	T2,JBTQ(J)	;DELETE JOB FROM SOURCE-Q
	MOVS	T1,T2		;T2=FORW. LINK, T1=BACK LINK
	HRRM	T2,JBTQ(T1)	;FORW. LINK PAST JOB
	TRACE(2,<HRLM	T1,JBTQ(T2)>,PG,<(U)>)	;BACK LINK PAST JOB

	SKIPGE	(U)		;END OR BEG. OF Q?
	HLR	PG,JBTQ(PG)	;END--THIS WILL LEAVE PG=IDX OF
				; CURRENT LAST LINK;T1=IDX OF Q-HEADER
	MOVE	T1,JBTQ(PG)	;BEG--T1=IDX OF CURRENT 1ST LINK
				; PG=IDX OF R-HEADER
	HRRM	J,JBTQ(PG)	;INSERT JOB IN DEST-Q
	HRLM	J,JBTQ(T1)
	HRRM	T1,JBTQ(J)
	HRLM	PG,JBTQ(J)

	JUMPL	PG,QX3		;RETURN IF QUANT. TIME NOT REQ.
	HLRZ	U,PG		;GET QUANTUM TIME FOR DPB
	MOVE	U,(U)		;GET QUANTUM TIME (POINTER IS @)
	DPB	U,JBYQNT	;STORE QUANTUM RUN TIME
	MOVEI	U,RNQ		;SET JOB STATUS WAIT
	DPB	U,PJBSTS	;CODE TO RUN QUEUE (0).
	PUSHJ	P,WRSMAP	;/WRS - ignore if same state
QX3:	POPJ	P,

BQFIX==QFIX
EQFIX==QFIX+1B0
BQLINK==QLINK
EQLINK==QLINK+1B0
BQJSIZ==QJSIZ
EQJSIZ==QJSIZ+1B0
	
repeat 0,<
	intern	MAPQUE
MAPQUE:	block	2000		;for debugging only! /WRS
; table of counts for state transactions...
;  MAPQUE[cs*40+ns] = count of times went from state <cs> to <ns>
	> ;End repeat 0

MAPQSW::POPJ	P,		;patch to JFCL to turn on MAPQUE
				;patch to POPJ P, to turn it off
	intern	WRSMAP,WRSMP1
WRSMP1:	XCT	MAPQSW
	PUSH	P,U
	JRST	WRSMA1
WRSMAP:	XCT	MAPQSW
	PUSH	P,U
	extern	JBTWRS		
	LDB	U,PJBSTS
	XOR	U,JBTWRS(J)
	TRNN	U,37		;if no change, ignore all this
	 JRST	WRSMA2
WRSMA1:	MOVE	U,JBTWRS(J)	;get history buffer
	LSH	U,5		;make room for latest value
	MOVEM	U,JBTWRS(J)	
	LDB	U,PJBSTS
	IORB	U,JBTWRS(J)
	ANDI	U,1777
	CAIN	U,-1		;Patch -1 to a specific state pair
	  STOPCD		;to crash on particular transition.
;	AOSG	MAPQUE(U)	;if its negative, crash
;	 STOPCD
WRSMA2:	POP	P,U
	POPJ	P,

WRSHDR:	1,,0			;for GETLNK gettab
	WRSVAL,,WRSNAM
WRSNAM:	sixbit	"JBTWRS"
;	sixbit	"MAPQUE"
WRSVAL:		JBTWRS
;		MAPQUE
	.LINK 1,WRSHDR
;SCANS THE QS RETURNING THE NUMBERS OF THE JOBS IN THE QS.
;THE ORDER AND MANNER IN WHICH THE QS ARE SEARCHED IS
;DETERMINED BY A "SCAN TABLE" ADDRESSED IN THE CALLING SEQ.
;THE SCAN TABLE HAS THE FORM:
;
;SCANTAB:	XWD <Q1>,<CODE1>	;SCN Q1 ACCRDING TO CODE1
;		...
;		XWD <QN>,<CODEN>	;QN ACCORDING TO CODEN
;		Z		;ZERO TERMINATES TABLE
;
;EACH Q MAY BE SCANNED IN ONE OF FOUR WAYS SPECIFIEDBY <CODE>
;THE CODES ARE:
;
;QFOR	SCAN WHOLE Q FOWARD
;QFOR1	SCAN FOR ONY THE 1ST MEMBER (IF ANY)
;QBAK	SCAN WHOLE Q BACKWARD
;QBAK1	SCAN BACKWARD FOR ALL MEMBERS EXCEPT THE 1ST
;
;CALLING SEQ.
;
;	MOVEI U,SCAN TABLE ADDRESS
;	JSP F,QSCAN	;SET UP F FOR REPEATED RETURNS
;	...		;RETURN HERE WHEN NO MORE JOBS
;	...		;RETURN HERE WITH NEXT JOB IN AC J
;			; AND ITS Q IN LH(M)
;
;	PERFORM ANY NECESSARY TESTING OF THIS JOB
;	J,U,F,M MUST BE PRESERVED
;
;	JRST (M)	;RETURN TO QSCAN TO GET NEXT JOB
;			; IF THIS ONE NOT ACCEPTABLE
;
;ACS:
QSCAN:	SKIPN	M,(U)		;END OF SCAN TABLE?
	JRST	(F)		;YES--RETURN TO CALL+1
	HLRE	J,M		;NO--GET NO. OF Q
	JRST	(M)		;DISPATCH

QFOR1:	MOVEI	M,QFOR2		;ONLY THE FIRST JOB

QFOR:	HRRE	J,JBTQ(J)	;SCAN FOWARD ALL JOBS
	JUMPG	J,1(F)		;RETURN THIS JOB NO. CALL+2 UNLESS--
QFOR2:	AOJA	U,QSCAN		;END OF THIS Q--GET NEXT Q

QBAK1:	HLRE	J,JBTQ(J)	;SCAN BACKWARD ALL JOBS EXCEPT 1ST
	SKIPLE	JBTQ(J)		;IS THIS THE FIRST MEMBER?
	JRST	1(F)		;NO--RETURN CALL+2
	AOJA	U,QSCAN		;YES--GET NEXT Q

QBAK:	HLRE	J,JBTQ(J)	;SCAN BACKWARD ALL JOBS
	JUMPG	J,1(F)		;RETURN CALL+2 WITH JOB NO. UNLESS
	AOJA	U,QSCAN		;BEG OF THIS Q--GET NEXT Q
;SHARABLE DEVICE JUST BECOME AVAILABLE(EXTENDED TO OTHER QUEUEW TOO)
;APPROPRIATE ENTRY IS SET NON-ZERO WHEN SCHEDULER SHOULD LOOK
;AT THAT QUEUE TO FIND A JOB TO RUN
;WSAVAL CONTAINS THE NO. OF JOBS WITH IO WAIT SATISFIED(0=NONE)

DEFINE X(A,B,C)
<INTERNAL A'AVAL,A'Q
A'Q==.-AVALTB
A'AVAL:	0
>

INTERNAL AVALTB

AVALTB:	QUEUES	;GENERATE THE AVAL FLAGS
LOC==.-AVALTB
NQUEUE==LOC		;NO. OF QUEUES COUNTING RUN QUEUE
XP MAXQ,NQUEUE-1	;MAX. STATE CODE WHICH HAS AN AVAL FLAG
XP MINQ,SIQ		;MINIMUM SHARABLE DEVICE QUEUE
XP AVLNUM,MAXQ		;MAX. STATE CODE WHICH HAS AN AVAL FLAG

;DEFINE STATE CODES WHICH DO NOT HAVE AVAL AND REQ FLAGS

DEFINE X(A,B,C)
<INTERNAL A'Q
A'Q==LOC
LOC==LOC+1
>
	CODES

XP MXCODE,LOC-1	;MAX. JOB STATE CODE
PQ0==LOC
LOC==LOC+1		;VERY HIGH PRIORITY QUE FOR SHARABLE RES
PQ1==LOC
LOC==LOC+1
PQ2==LOC
LOC==LOC+1
PQ3==LOC
LOC==LOC+1
CMQ==LOC		;COMMAND DELAY QUEUE

;HERE IS DEFINITION OF DUMMY SATISFIED STATE ISQ, WHICH IS WHERE
; A JOB GOES AFTER GETTING A CLUB INTERLOCK. DEFINE IT TO BE SAME
; AS TSQ, SO THAT JOB THAT GETS CLUB INTERLOCK GETS HIGH PRIORITY
; SOAS NOT TO BLOCK OTHER JOBS WAITING FOR THAT INTERLOCK. EVENTUALLY
; SHOULD PUT IN SOME CONTROL SO THAT THESE KIND OF JOBS DON'T RUN AWAY
; WITH THE SYSTEM.

XP ISQ,TSQ

;CORRESPONDENCE TABLE BETWEEN JOB STATUS CODES AND QUEUE TRANSFER TABLES
;USED BY SCHEDULER
;RUNCSS SETS JOB STATUS WORD TO NEW STATE CODE.
;SCHEDULER SETS UP QUEUE TRANSFER TABLE ADDRESS FROM
;FOLLOWING TABLE USING NEW STATE CODE AS INDEX

DEFINE X(A,B,C)
<	EXP Q'A'W
>

INTERNAL QBITS

QBITS:	QUEUES
	CODES
;SHARABLE DEVICE REQUEST TABLE(GENERALIZED FOR OTHER QUEUES TOO)
;CONTAINS THE NUMBER OF JOB WAITING TO USE SHARBLE DEVICE
;WSREQ AND RNREQ ARE UNUSED

DEFINE X(A,B,C)
<A'REQ:	-1
INTERNAL A'REQ
>

INTERNAL REQTAB,CNTTAB

REQTAB:	QUEUES	;GENERATE REQ TABLE

DEFINE X(A,B,C)
<A'CNT: 0
INTERNAL A'CNT
>

CNTTAB:	QUEUES

DEFINE X (A,B,C)
<	<SIXBIT /A'CNT/>
%%ZCNT==%%ZCNT+1>

	%%ZCNT==0
CNTNAM:	QUEUES

	%%ZCNT,,0
	.LINK	1,.-1
	CNTTAB,,CNTNAM

;CORRESPONDENCE TABLE LH=QUEUE CODE, RH=QUEUE TRANSFER TABLE ADR.
;INDEX INTO TABLE ALSO = QUEUE CODE
;FOR SHARABLE DEVICES ONLY
;SCHEDULER TAKES ONE JOB WAITING FOR A SHARABLE DEVICE AND
;PUTS IT IN THE APPROPRIATE RUN QUEUE ACCORDING TO
;QUEUE TRANSFER TABLE AS SPECIFIED BELOW BY THE JOB WAIT
;STATE CODE.

DEFINE X(A,B,C)
<	XWD -A'Q,Q'A'S
>

QRNS==0	;NO CORRESPONDENCE TABLES FO THESE QUEUES
QWSS==0
QTSS==0
QSSS==0

INTERNAL AVLQTB

AVLQTB:	QUEUES
;DEFINE A SET OF INSTRUCTIONS TO MARK A JOB AS WAITING FOR
;SWAP IN TO GRAB A RESOURCE. THIS IS IN CASE OF A SWAP ERROR
;AT THIS POINT, WE CAN THEN RECOVER.

	DEFINE X(A,B,C)
<FFLAG==0
IFIDN <A><M2>,<FFLAG==1>
IFIDN <A><PS>,<FFLAG==1>
IFIDN <A><PR>,<FFLAG==1>
IFIDN <A><SI>,<FFLAG==1>
IFIDN <A><RI>,<FFLAG==1>
IFE FFLAG,<MOVEM J,A'SWT>
IFN FFLAG,<PUSHJ P,A'SSWT
	EXTERN A'SSWT>
>

MRKSWT:	QUEUES

	DEFINE X(A,B,C)
<INTERNAL A'SWT
A'SWT:	0>

SWTTAB:	QUEUES

	DEFINE X(A,B,C)
<FFLAG==0
IFIDN <A><M2>,<FFLAG==1>
IFIDN <A><PS>,<FFLAG==1>
IFIDN <A><PR>,<FFLAG==1>
IFIDN <A><SI>,<FFLAG==1>
IFIDN <A><RI>,<FFLAG==1>
IFE FFLAG,<PUSHJ P,FRQUE>
IFN FFLAG,<POPJ P,>
>

CHKSWT:	QUEUES

;HERE TO FREE UP A RESOURCE SOMEONE WAS WAITING FOR ON A SWAP ERR
FRQUE:	CAME	J,SWTTAB+MINQ(F)
	POPJ	P,		;NOT THIS JOB
	SOSL	REQTAB+MINQ(F)
	SETOM	AVALTB+MINQ(F)
	SETZM	SWTTAB+MINQ(F)
	POPJ	P,

INTERNAL SWTTAB
INTERNAL JOBQUE
JOBQUE:	0	;QUEUE NUMBER OF CURRENTLY RUNNING JOB: PQ1,PQ2,PQ3

INTERNAL QJOB
QJOB:	Z	;NUMBER OF JOBS NEEDING Q TRANSFERS AT OTHER THAN CLOCK LEVEL

INTERNAL QSTOP,QTIME,SSCAN,QCMW
EXTERN QQYSD,QQYTTY

BQFIX==QFIX	;BEGINNING OF QUEUES FIXED QUEUE DISCIPLINE
EQFIX==QFIX+1B0	;END OF QUEUES " " "
BQLINK==QLINK
EQLINK==QLINK+1B0
BQJSIZ==QJSIZ
EQJSIZ==QJSIZ+1B0
DEFINE TTAB(FCTN,QUEUE,QUANT)
<		EXP FCTN
		XWD QUANT,-QUEUE
>
DEFINE PTTAB(FCTN,QUEUE,QUANT)
<		EXP FCTN
		XWD QUANT,QUEUE
>

QNULW:	TTAB EQFIX,NULQ,-1	;NULL QUEUE JOB NO. NOT ASSIGNED
QSTOP:QSTOPW:	TTAB EQFIX,STOPQ,-1	;UNRUNABLE JOBS TO END OF STOPQ
QCMW:	TTAB EQFIX,CMQ,-1		;COMMAND WAIT TILL JOB IN CORE
QRNW:	PTTAB EQJSIZ,QSTAB,QQSTAB	;JUST RUNABLE JOBS
QRNW1:	PTTAB EQJSIZ,QSTAB1,QQSTB1	;FOR IOW SAT OR DIOW SAT
	;WHICH ARE NOT IN SOME WAIT STATE BELOW,ENTER PROCESSOR
	;QS AT END AND GET QUANT. TIME ACCORDING TO THEIR SIZE

QWSW:	TTAB BQFIX,PQ1,QQYTTY	;IO WAIT SAT.(EXCEPT TTY+DSK)
	;ENTER FRONT OF PROCESSOR QS AND GET QUANT. TIME
	;ACCORDING TO JOB SIZE
QTSW:	TTAB BQFIX,PQ1,QQYTTY	;TTY IO WAIT SATISFIED(ENTER FRONT OF PQ1)

QSSW:	TTAB BQFIX,PQ1,QQYTTY	;PAGE WAIT SATISFIED.
QIOWW:	TTAB EQFIX,IOWQ,-1	;IOW(EXCEPT DSK+TTY) HELD IN IOWQ
QTIOWW:	TTAB EQFIX,TIOWQ,-1	;TTY IOW HELD IN TIOWQ
QSWW:	TTAB EQFIX,SWQ,-1	;JOBS WAITING FOR A PAGE TO FINISH
QMLOWW:	TTAB EQFIX,MLOWQ,-1
QILWW: TTAB EQFIX,ILWQ,-1
QFLWW:	TTAB EQFIX,FLWQ,-1
QMBWW:	TTAB EQFIX,MBWQ,-1
QCWW:	TTAB EQFIX,CWQ,-1
QSIW:	TTAB EQFIX,SIQ,-1	;SAT PRIMARY PCB NO IO WAIT.
QRIW:	TTAB EQFIX,RIQ,-1	;RIB PRIMARY PCB NO IO WAIT.
QPSW:	TTAB EQFIX,PSQ,-1	;SAT PRIMARY PCB WAIT.
QPRW:	TTAB EQFIX,PRQ,-1	;RIB PRIMARY PCB WAIT.
QM2W:	TTAB EQFIX,M2Q,-1	;2 PCB WAIT.
QFCW:	TTAB EQFIX,FCQ,-1	;FREE CORE WAIT QUEUE
QDAW:	TTAB EQFIX,DAQ,-1	;DEV. ALLOC.(DISK)
QCBW:	TTAB EQFIX,CBQ,-1	;CORE-BLOCK (DISK)
QMTW:	TTAB EQFIX,MTQ,-1	;MAG TAPE
QSLPW:	TTAB EQFIX,SLPQ,-1	;SLEEP M
QAXW:	TTAB EQFIX,AXQ,-1	;AUX. CIRCUIT WAIT
QACW:	TTAB EQFIX,ACQ,-1	;ACCOUNTING BUFFER WAIT
QBPW:	TTAB EQFIX,BPQ,-1	;BLOCK I/O PORT WAIT
;TRANSLATION TABLE FROM WAIT STATE TO SATISFIED STATE
;GO TO HEAD OF PQ1 TO MINIMIZE VULNERABILITY TO ^C FOUL UP
;RESET TOSMALL QUANTUM RUN TIME (ABOUT TO GO INTO IOWAIT ANYWAY)

QMTS:	TTAB BQFIX,PQ1,QQYSD	;MAG TAPE

QTIME:	PTTAB EQLINK,QTTAB,QQSTBL	;MOVE JOB TO LOWER Q
	;WHEN QUANT. TIME EXCEEDED AND RESET QUANT. TIME

QAXS:	TTAB BQFIX,PQ1,QQYSD	;AUX. CIRCUIT

QBPS:	TTAB BQFIX,PQ1,QQYSD	;BLOCK I/O PORT WAIT

QACS:	TTAB BQFIX,PQ1,QQYSD	;ACCOUNTING BUFFER
QSIS:QRIS:QM2S:QPRS:QPSS::QDAS:QCBS:QHIP:QFCS:	TTAB EQFIX,PQ0,[1]	;HAVE SHARABLE RES FOR DISK

;ENTER PROCESSOR QS ACCORDING TO JOB SIZE
QSTAB:	XWD 4,-PQ1	;PQ1 IF     SIZE .LE. 4K
	XWD ^D16,-PQ2	;PQ2 IF  4K .L. SIZE .LE. 16K
	XWD ^D256,-PQ3	;PQ3 IF 16 .L. SIZE
	Z

;PUT JOB FROM DIOW SAT OR IOW SAT IN Q IF HEAVY SWAP
QSTAB1:	XWD ^D5,-PQ1
	XWD ^D256,-PQ2

;PUT JOB DOWN A Q IF EXCEEDS QUANT. TIME
QTTAB:	XWD -PQ0,-PQ1
	XWD -PQ1,-PQ2
	XWD -PQ2,-PQ3
	XWD -PQ3,-PQ2	;BACK TO PQ2 TO COMPETE WITH IOWS JOBS
	Z

;QUANTUM TABLES

; QUANT. TIMES ACCORDING TO PROCESSOR Q:

INTERNAL RNQUNT
EXTERN JFYSEC
INTERN JFYS12

RNQUNT:
QQSTB1:
QQSTBL:	EXP JFYS12		;FROM PQ0 TO PQ1
QQSTAB:	EXP	JFYS12		;FROM PQ1 TO PQ2, 1/12 SECOND
	EXP	JFYSEC		;FROM PQ2 TO PQ3, 1 SECOND
	EXP	JFYSEC		;FROM PQ3 TO PQ2, 1 SECOND.
	Z


JFYS12: Z
INTERNAL ISCAN,OSCAN
ISCAN:	;SCAN FOR INPUT
	XWD -PQ0,QFOR	;SHARABLE DISK RESOURCE
	XWD -CMQ,QFOR	;MONITOR COMMAND WHICH NEEDS CORE IMAGE IN CORE
	XWD -PQ1,QFOR
	XWD -PQ2,QFOR
	XWD -PQ3,QFOR
	XWD -M2Q,QFOR1
	XWD -PRQ,QFOR1
	XWD -PSQ,QFOR1	;BRING IN MP FIRST --EARLY TO HELP KEEP DISK UP TO SPEED
	XWD -CBQ,QFOR1
	XWD -DAQ,QFOR1	;LOOK FOR 1ST JOBS IN OTHER SHAR.DEV QUEUES
	XWD -ILWQ,QFOR1		;BRING 1ST IL JOB IN, HE'S PROBABLY AT HEAD OF ONE OF THE CLUB INTERLOCK QUEUES
	Z		;PATCH SPACE
	Z
	Z		;FINAL ZERO TO FLAG END

OSCAN:	;SCAN FOR OUTPUT
	XWD -STOPQ,QFOR	;UNRUNABLE JOBS FIRST
	XWD -SLPQ,QFOR
	XWD -TIOWQ,QFOR		;TTY IOW
	XWD -MLOWQ,QBAK
	XWD -ILWQ,QBAK1		;EVERYONE BUT FIRST.
	XWD -FLWQ,QBAK
	XWD -MTQ,QBAK
	XWD -AXQ,QBAK
	XWD -BPQ,QBAK1
	XWD -ACQ,QBAK
	XWD -DAQ,QBAK1
	XWD -CBQ,QBAK1
	XWD -PSQ,QBAK1
	XWD -PRQ,QBAK1
	XWD -M2Q,QBAK1
	XWD -MBWQ,QBAK		;MONITOR BUFFER I/O WAIT
	XWD -SWQ,QBAK		;PAGE WAIT Q, TAKE LAST JOB TO ENTER
	XWD -ILWQ,QFOR1		;NOW FIRST MEMBER OF IL QUEUE.
				; ACTUALLY, WOULD HAVE TO SCAN CLUB DATA BASE, SINCE MANY INTERLOCKS.
				; BUT DON'T WANT TO LOCK IL PEOPLE IN CORE.
	XWD -DAQ,QFOR1
	XWD -CBQ,QFOR1
	XWD -PSQ,QFOR1
	XWD -PRQ,QFOR1
	XWD -M2Q,QFOR1
	XWD -PQ3,QBAK
	XWD -PQ2,QBAK
	XWD -PQ1,QBAK
	XWD -CMQ,QBAK
	XWD -PQ0,QBAK
	Z			;PATCH SPACE
	Z
	Z			;FINAL ZERO TO FLAG END

SSCAN:	XWD -PQ0,QFOR
	XWD -PQ1,QFOR	;SCHEDULER'S SCAN FOR NEXT JOB TO RUN
	XWD -PQ2,QFOR
	XWD -PQ3,QFOR
	Z		;FINAL ZERO TO FLAG END
SUBTTL SWAPPER

COMMENT \ GENERAL PLAN FOR SWAPPER

1) SERVICE SWAP IN DONE LIST, WHICH ADJUSTS SIPTOT AND
	TRANSFERS SWAP DONE PAGES TO THEIR NEW LISTS.

2) SERVICE SWAP OUT DONE LIST.  PUT PAGE ON CORRECT LIST
	(FREE, USED), INCREMENT THE CORRECT COUND (CLEAN
	RESERVED OR CLEAN FREE) , WAKE UP ANY JOBS WAITING
	FOR A COMPLETED PAGE TO FINISH SWAP OUT.

3) DO SWAP IN SCAN. BEGIN BY FILLLNG THE SWAP IN LIST UP
	[TO ITS QUOTA, SIPQTA. **OBSOLETE /AA**]  THEN, FOR ALL JOBS IN THE
	SWAP IN LIST, BRANCH TO THE APPROPRIATE PHASE OF
	THEIR SWAP IN, WHICH IS EITHER BRINGING IN ALL
	THE CONTEXT PAGES OR SCANNING THE LMAP TO SWAP IN
	NEEDED PAGES.  DURING THE FIRST CYCLE IN
	WHICH THE CONTEXT PAGES ARE IN, ALL LMAP SLOTS IN THE JOB'S
	MWS THAT CAN BE ACTIVATED ARE ACTIVATED, AND SIPTOT IS
	ADJUSTED TO MORE ACCURATELY REFLECT HOW MANY PAGES WILL BE SWAPPED
	IN.  AT ANY POINT IN EITHER OF THE TWO PHASES OF
	SWAP IN, IF A RESERVED PAGE IS NOT AVAILABLE YET, THIS
	JOB IS PASSED UNTIL NEXT CYCLE, WHEN A RESERVED PAGE MAY
	BE AVAILABLE. (THE REASON MORE JOBS ARE SCANNED
	WHEN NO RESERVED PAGES ARE AVAILABLE DURING A SWAP CYCLE
	RATHER THAN RETURNING FROM THE CYCLE IS IN CASE THERE
	ARE JOBS IN THE SWAP IN LIST THAT DON'T NEED MORE
	RESERVED PAGES TO ACTIVATE MORE OF THEIR MWS
	(HAPPENS IF A JOB NEEDS A PAGE THAT ANOTHER JOB HAS
	STARTED IN FOR ITSELF).  IF SIPTOT WAS ADJUSTED,
	THE SCHEDULER QUEUES ARE SCANNED FOR NEW JOBS TO ADD TO THE
	SWAP IN LIST.  THEN THE NEXT JOB ON THE SWAP IN LIST IS
	LOOKED AT.

4) WHEN A JOB'S ENTIRE LMAP IS SCANNED, THE JOB IS TAKEN
	OFF THE SWAP IN LIST AND SWAP IN DONE WILL WAKE THE
	JOB UP AFTER THE LAST PAGE THAT THE JOB IS WAITING
	FOR COMPLETES SWAP IN.
\
;EXTERNALS IN CORE1

EXTERNAL ACTLMS,DEALMS,FINXWS,GETCPA,GETDPA,GETRES,INSCHT,GETFRE
EXTERNAL NXSMWS,PUTLST,SRCCHT,MAPUPS,GETLMS,STOLMS,INCUSE,DECUSE
EXTERNAL UPSJOB,TSTVIR,INCCAV,PAGERR,IOSERR,NXTSTL

;EXTERNALS IN CORE1 FOR CORE PAGE LISTS AND COUNTS

EXTERNAL SIDLST,SODLST,CAVPGN,CRSPGN,DFRPGN,DFRLST,USELST
EXTERNAL CFR.N,DFR.N,USE.N,SID.N,SOD.N,SPR.N
EXTERNAL SCNLMC,FINLMC

;EXTERNALS IN PGY TABLES

EXTERNAL PGYLMJ,PGYSIP,PGYSOP,PGYSPT,PGYPGO
EXTERNAL PGYUSE,PGYADR,PGYATB,PGYDIO,PGYDRT,PGYFPL
EXTERNAL PGYSTS,PGPSIP,PGPSOP,PGPDRT

;EXTERNALS IN COMMON FOR LMAP DEFINITIONS

EXTERNAL LM3HDA,LMPACT
EXTERNAL LMPSUP,LMPVIR,LMYLMV,LMYLMJ,UP4LDA
EXTERNAL LMASRP

;EXTERNALS IN COMMON FOR UPT DEFINITIONS

EXTERNAL UPT,UPTEND,%UPS,%UPLMS,EPT,EPYPSM,%UPT.N
EXTERNAL UPTPBM,PBMMSK,UPTACP,UPTLDC,UPTJOB
EXTERNAL VPUMAX,NCTXPG,UPTRES
EXTERNAL USYLSP,USYRES,USYSIN,USYUWL,USYUWM

;EXTERNALS IN COMMON FOR JOB TABLE REFERENCES

EXTERNAL JBTSTS,JBTCTX,JBTICT,JBTFIT,CTXTAB
EXTERNAL JBYACT,JBYMWS,JBYSWS,PJBSTS,JBYCTR,JBYUWS
EXTERNAL JBTPGO

;EXTERNALS IN COMMON, MISCELLANEOUS

EXTERNAL CPOPJ,CPOPJ1,JOB,CURUPT,DSKPIF,DSKPIN,SAVE2
EXTERNAL MXPROT,PROT,PROT0,MINPCB,MAXPCB,ADRDUM

;EXTERNALS IN FILE SYSTEM

EXTERNAL GTSAPG,SWPENQ

;EXTERNALS IN CLOCK1

EXTERNAL REQUE

EXTERNAL JOBATB,MBIT,RBREAL,GTSPAG,ATBMWC,ATBSPT
EXTERNAL ATPDUM,ATPMXU,ATBDUM,ATBUMC,CPRRDW,LMPCUR,LMPMXW
EXTERNAL DABBIT,LM3ATB,JBTUPM,LMMERR,ATBSTS
DEFINE LSTCHK<JFCL>
;SERVICE THE SWAP IN DONE LIST.  THIS IS ADDED TO BY
; DISK INTERRUPT LEVEL.  CALLED BY SCHEDULER BEFORE REQUEUING
; JOBS, SINCE SWAP OUT DONE REQUEUES JOBS.  ALSO CALLED BY
; ONCE AFTER ALL DONE WITH ONCE PCB I/O.
; MINPCB, MAXPCB MUST BE SETUP.

SWPCHK::
SIDCHK:	HRRZ	PG,SIDLST	;GET FIRST ELEMENT ON SWAP IN DONE LIST
	JUMPE	PG,SODCHK	;NOTHING TO DO, GO CHECK SWAP OUT DONE
SIDLP1:	LDB	P1,PGYFPL	;GET NEXT PAGE ON SWAP IN DONE LIST
	CAMGE	PG,MINPCB	;TOO LOW?
	STOPCD			;YES
	CAMG	PG,MAXPCB	;IS IT A PCB?
	JRST	SIDL1A		;YES, DON'T ADJUST SIPTOT
	SOSGE	SIPTOT		;YES, DECREMENT
	STOPCD			;TOO MANY TIMES
SIDL1A:	SETZ	T1,
	DPB	T1,PGYSIP	;CLEAR PGYSIP FOR THIS PAGE
SIDLP2:	MOVEI	T4,USE.N	;ASSUME IT GOES ONTO USED LIST
	LDB	T1,PGYUSE	;GET CURRENT USE COUNT
	JUMPN	T1,SIDLP3	;JUMP IF BEING USED BY SOMEONE
	AOS	FRESID		;WHOEVER STARTED THIS IN DISAPPEARED.
	MOVEI	T4,CFR.N	;OOPS, DEACTIVATED IT BEFORE IT WAS
				; DONE. CAN'T BE DIRTY, SINCE
				; NO ONE WAS ALLOWED TO WRITE INTO IT.
	PUSHJ	P,INCCAV	;MAKE IT CLEAN AVAIL (OR ON I/O POOL)
SIDLP3:	DSKOFF	;STOP SWPINT FROM CHANGING SIDLST
	PUSHJ	P,PUTLST	;CANNOT BE FREE LIST, SINCE
				;CAN'T REMOVE PAGE WHILE ITS BEING
				;SWAPPED IN
	DSKON	;BACK ON
	CAMLE	PG,MAXPCB	;IF A PCB, FINPCB FIXED IT ALREADY.
	PUSHJ	P,PAGWAK	;WAKE UP ANY WAITERS.
	SKIPE	PG,P1		;GET NEXT PAGE TO CHECK
	JRST	SIDLP1		;GO IF THERE IS ONE
				; ELSE FALL INTO SODCHK
;HERE TO CHECK SWAP OUT DONE LIST. WAKE UP ALL JOBS THAT
; WERE IN PAGE WAIT THAT ARE IN THE I/O WAIT LIST FOR THE CORE PAGE,
; AND PUT THE CORE PAGE ON EITHER THE FREE OR USE LIST ACCORDING
; TO ITS USE COUNT.

SODCHK:	HRRZ	PG,SODLST	;GET FIRST CORE PAG ON LIST
	JUMPE	PG,CPOPJ	;NONE, GO SCAN FOR SWAP IN
SODLP1:	SETZ	T1,		;NO MORE SWAP OUT IN PROGRESS
	DPB	T1,PGYSOP

	LDB	P1,PGYFPL	;GET NEXT PAGE IN LIST
	LDB	T1,PGYUSE	;IS THIS PAGE BEING USED NOW?
				; (MAY NOT HAVE BEEN WHEN WE STARTED)
	JUMPE	T1,SODLP2	;JUMP IF NOT
	MOVEI	T4,USE.N	;YES, IT GOES ONTO USE LIST
	JRST	SODLP6		;GO PUT INTO THE LIST
SODLP2:	LDB	T1,PGYDRT	;WAS IT DIRTIED WHILE IT WAS ON ITS
				; WAY OUT? (RES HAD TO BE ZERO IF SO)
	JUMPE	T1,SODLP3	;JUMPN IF NOT
	MOVEI	T4,DFR.N	;YES, THEN IT GOES ON DIRTY FREE LIST INSTEAD
	AOS	DFRPGN		;ONE MORE DIRTY FREE PAGE
	JRST	SODLP6		;GO PUT IT ON DIRTY FREE LIST
SODLP3:	SKIPG	RIPPGN		;STILL NEED TO FILL UP CRSPGN?
	JRST	SODLP4		;NO, GO INCREMENT CAVPGN
	SOS	RIPPGN		;ONE LESS RESERVED IN PROGRESS
	AOS	CRSPGN		;ONE MORE RESERVED CLEAN
	JRST	SODLP5		;AND GO PUT ONTO CLEAN FREE LIST
SODLP4:	SOSGE	CAPPGN		;ONE LESS CLEAN AVAIL IN PROGRESS
	STOPCD			;LIST AND COUNTS DID NOT AGREE
	PUSHJ	P,INCCAV	;ONE MORE CLEAN AVAIL OR I/O PAGE.
SODLP5:	MOVEI	T4,CFR.N	;PUT INTO THE CLEAN FREE LIST
SODLP6:	DSKOFF	;MAKE SURE SWPINT DOESNT CHANGE SODLST
	PUSHJ	P,PUTLST	;PUT INTO THE LIST
	DSKON
	CAMLE	PG,MAXPCB	;IF ITS A PCB, FINPCB CALLED ALREADY.
	PUSHJ	P,PAGWAK	;WAKE UP ALL JOBS WAITING FOR THIS PAGE.
SODLP8:	SKIPE	PG,P1		;GET NEXT PAGE, IF ANY
	JRST	SODLP1		;THERE IS ONE, GO DO IT
	POPJ	P,		;RETURN TO SCHEDULER.
COMMENT ;@@SUBROUTINE PAGWAK
@@PURPOSE WAKE UP ALL JOBS ON WAIT QUEUE FOR A CORE PAGE
CALLED FROM SWAP IN DONE, SWAP OUT DONE, DIRECT I/O DONE
(WHEN PGYDIO GETS DECREMENTED AND GOES TO ZERO.)
@@ENTRY CORE PAGE NUMBER IN PG
CAN BE CALLED FROM UUO, CLOCK, OR INTERRUPT LEVEL.
@@ACCUM SMASHES J, T1,T2. PRESERVES P1-P4, T3, T4.
@@EXIT ALL JOBS ON PGYPGO LIST REQUEUED.
@@RESTRICTIONS ASSUMES ONLY ONE WAKER CAN EXIST FOR A CERTAIN
PAGE AT A TIME (TRUE BECAUSE SWAP IN, SWAP OUT, AND
DIRECT I/O HAVE TO BE MUTUALLY EXCLUSIVE OF EACH OTHER.)
ASSUMES THAT PAGWAT IS ONLY CALLED AT UUO LEVEL, AND
THAT IT TURNS OFF PI SYSTEM WHEN ADDING A JOB TO JBTPGO.
@@FUNCTION LOOP THRU JBTPGO AND REQUEUE ALL JOBS
@@;

PAGWAK::LDB	J,PGYPGO	;GET FIRST JOB TO WAKE
	JUMPE	J,CPOPJ		;IF NONE, JUST RETURN.
	MOVEI	T2,SSQ		;GET READY TO TAKE JOBS OUT OF WAIT.

PAGWK1:
	LDB	T1,PJBSTS	;Get previous job state
	CAIE	T1,SWQ		;Had better be...
	  STOPCD		;Changed from AOS BADSS
	DPB	T2,PJBSTS	;CHANGE STATE CODE
	PUSHJ	P,REQUE		;REQUE THE JOB
	HRRZ	J,JBTPGO(J)	;GET NEXT JOB ON LIST
	JUMPN	J,PAGWK1	;AND GO WAKE IT UP
	DPB	J,PGYPGO	;NO MORE WAITERS.
	POPJ	P,		;RETURN.

BADSS:	0			;Count of number of times job went to
				;SS state from something other than SW
SUBTTL SWAP IN SCAN

COMMENT \

THE SWAP IN SCAN'S OUTLINE IS AS FOLLOWS:

1) CHECK TO SEE IF ANOTHER JOB SHOULD BE ADDED TO THE
  SWAP IN LIST. IF SO, SCAN FOR ANOTHER JOB TO ADD.

2) FOR EACH JOB IN THE SWAP IN LIST, DISPATCH ON THE JOB'S
  SWAPPER STATE.  THE PHASES OF A JOB'S SWAP IN ARE AS FOLLOWS:
	A) CONTEXT PAGE CREATION PHASE.  IF CONTEXT PAGES HAVE
	  ALREADY BEEN CREATED, GO TO CONTEXT PAGE ACTIVATE SCAN.
	  ELSE, TRY TO ALLOCATE DISK PAGES FOR THE CONTEXT
	  PAGES.

	B) CONTEXT PAGE ACTIVATE SCAN. FOR ALL CONTEXT PAGES,
	  TEMPORARILY INCREMENT THE USE COUNTS FOR ALL CONTEXT
	  PAGES THAT HAPPEN TO BE IN CORE, SO THAT WHEN
	  SWPRES IS CALLED IT WILL NOT PICK ONE OF THEM TO
	  GIVE TO THIS JOB AS A RESERVED PAGE.

	C) CONTEXT PAGE SWAP IN SCAN. THIS PHASE SOMETIMES SPANS
	  SEVERAL SWAPPER CYCLE. CONTINUE TO INCREMENT USE
	  COUNTS FOR CONTEXT PAGES UNEXPECTEDLY FOUND IN CORE,
	  AND START CONTEXT PAGE SWAP INS IF THERE ARE ENOUGH
	  RESERVED PAGES AVAILABLE TO DO SO. WHILE DOING THIS,
	  CHECK TO SEE IF ALL CONTEXT PAGES ARE FINALLY IN.
	  IF THEY ARE, ACTIVATE ALL THE EXEC PER-PROCESS SLOTS
	  FOR THE CONTEXT PAGES, AND DECREMENT THE USE COUNTS
	  THAT WERE TEMPORARILY INCREMENTED BEFORE.

	D) LMAP ACTIVATE SCAN.  ACTIVATE ANY PAGES THAT THE
	  JOB WANTS (IN MWS) THAT HAPPEN TO BE IN CORE.
	  WHILE DOING THIS, COUNT UP THE NUMBER OF RESERVED PAGES
	  NEEDED TO SWAP IN THE WHOLE MWS. TRY TO RESERVE THIS
	  MANY. IF NOT, HAVE TO GIVE BACK ANY STOLEN RESERVED
	  PAGES (EITHER SOP+RES OR CRS TYPF).

	E) LMAP SWAP IN SCAN. NOW THAT ENOUGH PAGES ARE RESERVED,
	  SCAN THE LMAP AGAIN. ACTIVATE ANY PAGES UNEXPECTEDLY FOUND
	  IN CORE. IF RESERVED PAGE IS AVAILABLE, START SWAP INS.
	  IF NO MORE RESERVED PAGES ARE AVAILABLE FOR THIS CYCLE,
	  EXIT SWAPPER TILL NEXT CYCLE, WHEN MORE RESERVED PAGES
	  MAY BE AVAILABLE. (THUS, THIS PHASE CAN SPAN ACROSS
	  MANY SWAPPER CYCLES).  WHEN THE SCAN IS FINISHED,
	  THERE MAY BE RESERVED PAGES LEFT OVER (OR THEY MAY HAVE
	  RUN OUT BEFORE THE JOB'S WHOLE MWS WAS TAKEN
	  CARE OF).  THIS HAPPENS WHEN THE SWAP IS FOR A PRE-REFERENCE
	  AND THE JOB CHANGED ITS MWS SIZE, OR WHEN SWAPPING ACTIVITY
	  FOR OTHER JOBS HAS BROUGHT PAGES INTO CORE THAT THIS
	  JOB NEEDS.

	F) LMAP SWAP IN SCAN COMPLETE. TURN OFF
	  SWPINP, MRQ AND PRF FOR THE JOB, TAKE THE JOB OUT OF THE
	  SWAP IN LIST, SETUP IN CORE PROTECT TIME TO THE
	  CORRECT VALUE.

BEFORE STEPPING TO THE NEXT JOB IN STEP 2, STEP 1 IS REPEATED
  IF THERE HAS BEEN A CHANGE IN THE NUMBER OF PAGES CURRENTLY
  BEING SWAPPED IN.
\
;BEGIN A SWAPPER CYCLE.  INITIALIZE SWAPPER, BEGIN SCAN OF
;SCNED QUEUES

SWAP:

SWISCN:	AOS	SWCCNT		;CALLED ONCE AGAIN.
	PUSHJ	P,SRSINI	;INITIALIZE SWAPPER
	MOVEI	U,ISCAN		;START THE SCAN OUT FRESH
	HRRZ	J,JBTFIT	;INITIALIZE FIT TO FIRST JOB ON SWAP IN
	MOVEM	J,FIT		;LIST, IF ANY.

;HERE AT BEGINNING OF ANY CYCLE TO SCAN SCHED QUEUES
;FOR ELIGIBLE JOBS TO PUT ON FIT LIST.  ALLOW A NEW BIGFIT
;JOB ONTO LIST IF ONE NOT ALREADY THERE.

SWISC0:	JSP	F,QSCAN		;START THE SCAN OUT
	  JRST	SWISC1		;NONE LEFT

;HERE ALSO VIA JRST (M) FROM SWINJ2 &FF WHEN THERE ARE MORE JOBS
;WHICH COULD BE SCANNED HERE TO BE PUT ON S.I.L.
;BEFORE CONTEXT PAGES ARE SCANNED,
; NUMBER OF PAGES THAT HAVE TO BE SWAPPED IN FOR A JOB IS ASSUMED
; TO BE THE SIZE OF THE JOB'S MWS.  WHEN CONTEXT PAGES ARE FINALLY
; SWAPPED IN, NUMBER OF PAGES ACTUALLY NEEDED MAY DECREASE, THUS
; THE CHECK ON WHETHER OR NOT TO ADD TO THE SWAP IN LIST MUST
; BE RE-EXECUTED.  FIT CONTAINS NEXT JOB WE WERE GOING TO DO
; IN SWAP IN LIST, OR 0.

	MOVE	T1,JBTSTS(J)	;PUT JOB ON SWAP IN (FIT) LIST
	TRNN	T1,SWPINP	;UNLESS ALREADY THERE
	TDNN	T1,[MRQ,,PRF]	;AND IT HAS TO WANT TO BE THERE
	JRST	(M)		;JOB DOESN'T QUALIFY, SCAN SOME MORE

	SKIPE	BIGFIT		;IF SWAPPER ALREADY HAS A BIG JOB
	TRNN	T1,SETICP	;AND CURRENT CANDIDATE IS A BIGGIE,
	JRST	.+2		;WE WILL MARK HIM, HE'S GOING ONTO SWAP IN LIST.
	JRST	(M)		;FORGET HIM.  ALLOW ONLY 1 BIGFIT
				;JOB THRU AT A TIME, AND ANY NUMBER
				;OF OTHER MRQ'D JOBS
	TRNN	T1,SETICP	;HE'S GOING ON:  IS HE A BIGGIE?
	JRST	SWISCA		;NO,SWOSCN NEVER ATE HIM
	AOS	BIGCNT		;YES,RECORD A NEW ONE SELECTED
	TRACE	(3,<MOVEM J,BIGFIT>) ;YES, NEW ONE.
SWISCA:	MOVEI	T1,SWPINP
	IORM	T1,JBTSTS(J)	;RECORD SWPINP SET
	MOVEI	T1,SWSCCP	;INIT THE SWAPPING STATE
	DPB	T1,JBYSWS
	TRACE(4,<PUSHJ	P,PUTSIL>)	;PUT JOB ON SWAP IN LIST
	AOS	SIJCNT		;HAVE SELECTED ANOTHER JOB.
	SKIPN	FIT		;IF SWAP IN LIST SCAN WAS AT
				; BEGINNING OR END,
	MOVEM	J,FIT		;CONTINUE SCAN WITH THIS JOB
				; ELSE WITH ONE WE WERE GOING TO DO NEXT.
	LDB	T1,JBYMWS	;ESTIMATE # SWAP IN PAGES TO BE
	ADDB	T1,SIPTOT	;ALL OF MWS (CORRECTED AFTER CONTEXT PGES ARE IN)
				;DO NOT ADD TO SWAP IN LIST UNTIL
				; WE SEE WHAT WE CAN DO FOR THE
				; JOB WE JUST ADDED. WE MAY NEED
				; THE NEXT JOB WE WERE GOING TO SELECT FOR SWAPPING OUT.
SWISC1:	PUSH	P,U		;SAVE PLACE IN QUEUES ON THE STACK
	PUSH	P,M
	PUSH	P,F
	PUSH	P,J
	MOVE	J,FIT		;RESTORE NEXT JOB TO TRY
				;AND FALL INTO DISPATCH.
SUBTTL PHASE DISPATCH

;HERE FROM SWINJ2 IF WE ARE FINISHED SCANNING THE QUEUES
; OR ARE UP TO THE SWAP IN QUOTA. NEXT JOB, IF ANY, IN J
; POSITION IN QUEUES (U,F,M) STILL ON STACK.

SWISC2:	LSTCHK			;CHECK CORE PAGE LISTS
	JUMPE	J,SWIXIT	;IF NO MORE LEFT, EXIT FROM SWAPPER

;DISPATCH ON NEXT JOB'S SWAPPING STATE.

	LDB	T3,JBYSWS	;GET SWAPPER STATE FOR THIS JOB
	JRST	@SWIDSP(T3)	;DISPATCH TO APPROPRIATE SWAP IN ROUTINE

;TABLE OF SWAP IN ROUTINES, INDEXED BY STATE

SWIDSP:
	PHASE	0
SWSCCP:!SWICCP			;CREATE CONTEXT PAGES
SWSCSI:!SWICSI			;GET ALL CONTEXT PAGES IN
SWSSWI:!SWISWI			;SWAP IN MORE MWS PAGES

	DEPHASE


;HERE WITH QUEUE SCANNING INFO ON STACK AND WANT TO RETURN
; FROM SWAPPER

SWIXIT:	POP	P,J
	POP	P,F
	POP	P,M
	POP	P,U
	POPJ	P,
SUBTTL CONTEXT PAGE CREATION

;HERE TO ALLOCATE DISK SPACE FOR CONTEXT PAGES IF NOT ALREADY
; DONE. DISK PAGES ALREADY ALLOCATED UNLESS JOB IS JUST LOGGING
; IN.  MAY HAVE TO WAIT UNTIL SAT GETS INTO CORE.  ALSO,
; MAY BE OUT OF DISK SPACE, IN WHICH CASE LEAVE JOB ON SWAP IN
; LIST UNTIL CAN GET SOME ROOM.

SWICCP:	MOVSI	T1,CTXCEX	;CONTEXT PAGES EXIST ALREADY
	TDNE	T1,JBTCTX(J)	;
	JRST	SWICAS		;YES, RESERVE FOR SWAP IN
	MOVSI	T1,CTXVIR	;NO, GET READY TO MARK THEM VIRGIN
	IORM	T1,JBTCTX(J)	;THEY ARE VIRGIN. COPY FROM UPT
				; AND CLEAR JUST BEFORE ACTIVATING.
	DPB	T1,JBYMWS	;ZERO MWS SIZE, IT HAS TO BE 0
	MOVSI	W,-NCTXPG	;AOBJN POINTER TO CTXTAB
	SETZ	P1,		;CALL GTSAPG FIRST TIME.
	MOVEI	T1,SRPNDS
	TDNE	T1,STRDDB+STRBTS	;IF PRIOR TO DSKCLN,
	JRST	SWICND		;CREATE CONTEXT PAGES WITHOUT DPS ATTACHED.

SWICC1:	LDB	T2,CTXTAB(W)	;GET DISK ADDRESS, IF ANY
	JUMPN	T2,SWICC3	;ALREADY ALLOCATED
	HLLZ	T3,W		;T3 GETS -VE PAGES,,0
	MOVMS	T3		;# PAGES,,0
	PUSHJ	P,JOBATB	;GET JOB'S ATB ADDRESS
	HRR	T3,T1		;T3 HAS # PAGES,,ATB ADDRESS
	MOVEI	T1,MBIT		;JUST MARK AS MAPPED
	MOVE	T2,P1		;GET LAST PAGE ALLOCATED OR ZERO.
	PUSHJ	P,GTSPAG	;GET AS MANY PAGES AS WE CAN
	  JRST	SWINJ2		;COULD NOT, TRY NEXT CYCLE

SWICC2:	DPB	T2,CTXTAB(W)	;OK, ITS ALLOCATED NOW.
	AOS	T2		;POSSIBLE NEXT PAGE WE HAVE
	SOJLE	T3,SWICC3	;JUMP IF NO MORE IN THIS GROUP
	AOBJN	W,SWICC2	;HAVE ANOTHER, BETTER HAVE ANOTHER
				; CONTEXT PAGE TO DO
	STOPCD			;DO NOT, CRASH.
SWICC3:	MOVE	P1,T2		;REMEMBER NEXT PAGE TO ASK FOR.
	TLO	P1,RBREAL	;MAKE ACCEPTABLE TO GTSPAG.
	AOBJN	W,SWICC1	;STEP TO NEXT CP
	MOVSI	T1,CTXCEX	;NOW THEY EXIST
	IORM	T1,JBTCTX(J)
	JRST	SWICAS		;GO BRING THEM IN.
;HERE IF DSKCLN HASN'T RUN YET TO CREATE CONTEXT PAGES.
; DO NOT USE ANY DISK PAGES, JUST GET CORE AND SETUP PGYADR
; WITH "DUMMY" ADDRESSES.

SWICND:	SETZ	P1,		;RESERVED PAGE NEEDED COUNT SET TO 0.
	MOVE	P3,EPYPSM	;POINTER TO %UPS SLOTS [EPTPTR(%UPS.N-1)]
	MOVE	P4,ADRDUM
SWICN1:	PUSHJ	P,GETFRE	;GET A CP
	  STOPCD		;CRASH IF NONE AVAILABLE
	PUSHJ	P,INCCTX	;INCREMENT USE COUNT, ITS DECREMENTED LATER.
	DPB	P4,PGYADR	;SETUP DUMMY DISK ADDRESS CODE
	DPB	P4,CTXTAB(W)	;SETUP IN JBTCTX TOO.
	MOVEI	T2,PGE.A!PGE.W!PGE.C(PG)
	IDPB	T2,P3		;ANOTHER CONTEXT PAGE ADDRESSABLE
	AOBJN	W,SWICN1	;LOOP FOR ALL CONTEXT PAGES
	MOVSI	T1,CTXCEX	;MARK AS EXISTENT NOW
	IORM	T1,JBTCTX(J)
	CLRPTA			;PUT NEW MAPPING INTO EFFECT
	JRST	SWIC7A		;GO SETUP UPSJOB, CONTEXT DATA.
SUBTTL CONTEXT PAGE ACTIVATE SCAN
;HERE TO SEE HOW MANY PAGES WE NEED TO RESERVE IN ORDER
; TO BRING IN ALL THE JOB'S CONTEXT PAGES.
; INCREMENT USE COUNTS FOR CONTEXT PAGES IN CORE, ASSUMING
; THERE WILL BE ENOUGH RESERVED PAGES AVAILABLE, SO THAT WHEN
; SWPRES IS CALLED IT WILL NOT TAKE A CONTEXT PAGE
; THAT WE NEED FOR THIS JOB IN ORDER TO RESERVE A PAGE FOR
; ANOTHER CONTEXT PAGE FOR THE JOB WHICH IS NOT IN CORE.
;
;A PAGE IS RESERVED FOR EVERY CONTEXT PAGE
; 1) NOT IN CORE
; 2) SWAP OUT IN PROGRESS, CLEAN AND CAPPGN = 0
; 3) PAGE IS FREE AND CLEAN, BUT CAVPGN = 0 (NO FREE PAGES AVAILABLE, ALL RESERVED)
;
;SEPARATE COUNTS ARE KEPT FOR EACH OF THE THREE CASES
; ABOVE, SO THAT IF SWPRES CANNOT RESERVE THE REQUESTED AMOUNT
; OF PAGES, SWICRP CAN GIVE BACK THE STOLEN RESERVED PAGES.
; THESE STOLEN RESERVED PAGES WERE EITHER STOLEN FROM RIPPGN
; OR FROM CRSPGN, DEPENDING ON WHETHER OR NOT
; SWAP OUT WAS IN PROGRESS FOR THEM.
;
;IF PAGE IS CLEAN-FREE AND THERE ARE CLEAN-FREE-AVAILABLE
; PAGES LEFT, DON'T RESERVE, BUT DECREMENT COUNT OF CLEAN-FREE-
; AVAILABLE PAGES.  IF CORE PAGE FOUND IS DIRTY AND FREE,
; JUST DECREMENT COUNT OF DIRTY FREE PAGES.

SWICAS:	SKIPGE	JBTCTX(J)	;ALL IN (CHECK CTXCIN)
	JRST	[SETZ P1,	;YES, START WITH 0 RESERVED PAGES
		 PUSHJ P,MAPUPS	;MAKE SURE JOB'S UPT IS ADDRESSABLE.
		 JRST SWILAS]	;AND GO START LMAP ACTIVATE SCAN.

	SETZB	P1,P2		;P1 HAS NUMBER OF PAGES NOT IN CORE
				; P2 HAS NUMBER OF RESERVED SWAP
				; OUT PAGES STOLEN
	SETZ	S,		;S HAS NUMBER OF CLEAN RESERVED PAGES STOLEN
	MOVEI	W,NCTXPG-1	;HIGHEST CONTEXT PAGE INDEX

SWICA1:	LDB	T2,CTXTAB(W)	;GET DISK PAGE ADDRESS
	PUSHJ	P,SRCCHT	;IN CORE?
	  AOJA	P1,SWICA2	;NO, COUNT IT AND CHECK NEXT

;ASSUME WE WILL GET ENOUGH RESERVED PAGES. IF NOT, HAVE TO
; BACK OUT AT SWICRP

	MOVEI	T4,INCCTX	;ROUTINE TO CALL TO NAIL DOWN
	PUSHJ	P,NAILIT	;INCREMENT USE COUNT, IF POSSIBLE.
SWICA2:	SOJGE	W,SWICA1	;STEP TO NEXT CONTEXT PAGE
;HERE AFTER CONTEXT PAGE ACTIVATE SCAN IS OVER. TRY TO
; RESERVE THE REQUIRED AMOUNT OF PAGES. IF CAN'T, GO
; GIVE BACK THE TWO TYPES OF PAGES WE STOLE, AT SWICRP.

	MOVE	P3,P1		;NUMBER OF PAGES NOT IN CORE
	ADD	P3,P2		;NUMBER OF STOLEN SOP-RES PAGES
				; RESERVE SOME IN PLACE OF WHAT WE STOLE
	ADD	P3,S		;ALSO RESERVE ENOUGH TO COVER CLEAN
				; RESERVED WE STOLE
	JUMPE	P3,SWICA3	;JUMP IF NOTHING TO RESERVE
	PUSHJ	P,SWPRES	;RESERVE
	  TRACE(5,<JRST	SWICRP>);COULDN'T. GIVE BACK STOLEN PAGES.
SWICA3:	MOVEI	T1,SWSCSI	;CHANGE STATES
	DPB	T1,JBYSWS	;TO CONTEXT PAGE SWAP IN
	JRST	SWICS0		;AND GO THERE.
;ROUTINE TO NAIL DOWN A CONTEXT PAGE.  INCREMENT USE COUNT
; IF NOT INCREMENTED ALREADY, IF VIRGIN AND SWAP IN NOT
; IN PROGRESS SET UP THE CONTEXT PAGE BY CALLING ROUTINE
; FOR IT.

	JFCL			;ENTRY FOR STOLEN PAGES.
INCCTX:	MOVSI	T1,CTXUCU	;USE COUNT UP BIT
	IORM	T1,@CTXTAB(W)	;SET IT FOR THIS CONTEXT PAGE
	PJRST	INCUSE		;AND GO INCREMENT USE COUNT
SUBTTL CONTEXT PGE SWAP IN SCAN

;FIRST START AS MANY CONTEXT PAGES IN AS WE CAN, AT THE SAME
; TIME NOTING IF WE'VE SEEN ONE THAT ISN'T READY YET.
; (P2 NON-ZERO IS SET IF SUCH A CONTEXT PAGE EXISTS.)
; FOR CONTEXT PAGES WE HAVEN'T CHECKED YET, SEE IF THEY'RE
; IN CORE ALREADY.  IF NOT IN CORE AND WE CAN GET
; A RESERVED PAGE, INCRMENT ITS USE COUNT (SO IT WON'T BE SWAPPED
; OUT LATER WHEN SWAP IN PROGRESS GOES OFF FOR PAGE)
; AND SET THE BIT SAYING WE'VE DONE THIS (CTXUCU).
; START THE SWAP IN OF THE CONTEXT PAGE, GO CHECK NEXT
; ONE.
; IF THE CONTEXT PAGE WAS IN CORE, INCREMENT ITS USE COUND, SET THE BIT
; THAT SAYS WE'VE DONE THIS. IF SWAP OUT IS IN PROGRESS
; AND THE SWAP OUT PAGE IS RESERVED, DO NOT GIVE BACK
; THE RESERVED PAGE OBTAINED BEFORE. IF
; THE SWAP OUT PAGE IS NOT RESERVED, GIVE BACK A RESERVED
; PAGE, SINCE WE DON'T HAVE TO MAKE UP FOR THE ONE WE STOLE.
; IF SWAP IN IN PROGRESS, JUST NOTE THAT NOT ALL CONTEXT PAGES
; ARE READY.

SWICSI:	LDB	P1,JBYCTR	;GET NUMBER OF RESERVED PAGES LEFT
				; OVER FROM LAST TIME

;HERE AFTER RESERVING PAGES, NUMBER OF RESERVED PAGES IN P1
SWICS0:	MOVSI	P3,CTXUCU	;USE COUNT IS UP BIT
	SETZ	P2,		;IF THIS IS NON-ZERO, NOT ALL CONTEXT PAGES ARE IN YET
	MOVEI	W,NCTXPG-1	;START WITH HIGHEST CONTEXT PAGE INDEX
SWICS1:	LDB	T2,CTXTAB(W)	;GET THIS CONTEXT PAGE'S DP
	PUSHJ	P,SRCCHT	;GET ITS CP
	  JRST	SWICS3		;NOT IN YET, CHECK VIRGIN
	SETZ	S,		;FRESHEN UP FLAGS.
	PUSHJ	P,PAGERR	;SEE IF ANY ERRORS
	MOVSI	T1,CTXSWE	;THEN SET THIS FLAG
	TLNE	S,IOSERR	;IN JBTCTX
	IORM	T1,JBTCTX(J)	;FOR LATER.
	TDNN	P3,@CTXTAB(W)	;THIS PAGE IN ALREADY?
	JRST	SWICSA		;NO
	LDB	T1,PGYSIP	;YES, IS IT BEING SWAPPED IN STILL
	JUMPE	T1,SWICSD	;JUMP IF NOT, GO DO NEXT CONTEXT PAGE
	SOJA	P2,SWICSD	;STILL COMING IN, SET FLAG THAT SAYS
				; ALL CONTEXT PAGES NOT IN YET.
;HERE WHEN PAGE IS IN CORE FOR THE FIRST TIME.

SWICSA:	LDB	T1,PGYUSE	;PICKUP USE COUNT
	JUMPN	T1,SWICS4	;IF UP, CAN JUST INCREMENT AGAIN
	LDB	T1,PGYSIP	;IF SWAP IN IN PROGRESS,
	JUMPN	T1,[SOJA P2,SWICS4] ;FLAG TO CHECK LATER AND INCREMENT USE COUNT
	LDB	T1,PGYDRT	;IF ITS DIRTY,
	JUMPN	T1,SWICS4	;CAN ALWAYS INCREMENT ITS USE COUNT
	
	LDB	T1,PGYSOP	;SWAP OUT IN PROGRESS?
	JUMPE	T1,SWICSC	;NO, IS CLEAN-FREE.
	SKIPE	CAPPGN		;YES. IS IT AVAILABLE?
	JRST	SWICS4		;YES, GO INCREMENT USE COUNT
	SOSGE	RIPPGN		;NO, STEAL IT.
	STOPCD			;LIST AND COUNTS DIDN'T AGREE
	AOS	CAPPGN		;MAKE IT AVAILABLE
	SOJA	P1,SWICS4	;USE UP ANOTHER RESERVED PAGE AND
				; GO INCREMENT USE COUNT

;HERE IF CORE PAGE IS CLEAN-FREE. IF ANY CLEAN-AVAILABLE
; PAGES EXIST, DON'T USE UP A RESERVED PAGE, BUT INSTEAD
; LEAVE IT FOR NEXT CYCLE

SWICSC:	SKIPLE	CAVPGN		;CAN WE USE AN AVAILABLE PAGE?
	JRST	SWICS4		;YES, JUST INCREMENT USE COUNT
	SOSGE	CRSPGN		;NO. TAKE A CLEAN RESERVED PAGE
	STOPCD			;HAD TO BE ONE THERE
	AOS	CAVPGN		;INCREMENT CAVPGN FOR IT
	SOJA	P1,SWICS4	;ONE LESS FOR THIS JOB, GO INCRMENT USE COUNT
SWICS3:	PUSHJ	P,GETRES	;THERE'S ONE NOT IN YET. GET A RESERVED PAGE IF AVAILABLE
	  JRST	SWINJC		;NOT AVAILABLE, BUT WILL BE SOMEDAY.
				;(STORE JBYCTR)
	SOS	P1		;USED UP ANOTHER RESERVED PAGE.
	LDB	T2,CTXTAB(W)	;GET DISK ADDRESS
	PUSHJ	P,INSCHT	;PUT IN CHT AND SET PGYADR.
	MOVSI	T1,CTXVIR	;SEE IF CONTEXT PAGES ARE VIRGIN
	TDNE	T1,JBTCTX(J)	;ARE THEY?
	JRST	SWICS4		;YES, DON'T SWAP IT IN.
	SETO	P2,		;(BIT 35 MAY BE OFF BECAUSE OF SOJAS)
	DPB	P2,PGYSIP	;MARK SWAP IN IN PROGRESS
	AOS	SIPTOT		;WILL GET DECREMENTED AT SIDCHK
	SOSGE	CAVPGN		;ONE LESS CLEAN AVAIL PAGE.
	STOPCD			;TOO LOW.
	PUSHJ	P,SWPIO		;SWPIO TAKES CORE PAGE IN PG
				; LOOKS AT PGYSIP AND STARTS A SWAP IN

SWICS4:	PUSHJ	P,INCCTX	;INCREMENT USE COUNT IF NOT DONE ALREADY,
				; SO SWPRES WON'T TAKE IT AWAY.
SWICSD:	SOJGE	W,SWICS1	;LOOP FOR ALL CONTEXT PAGES
	JUMPE	P2,SWICS7	;JUMP IF ALL CONTEXT PAGES ARE IN FOR THIS JOB
	JRST	SWINJC		;STEP TO NEXT JOB
;HERE WHEN ALL THE CONTEXT PAGES ARE COMPLETELY IN.
; ACTIVATE THE PER PROCESS EXEC VIRTUAL SLOTS THAT MAP
; THE LMAP AND UPT, AND DECREMENT THE USE COUNTS FOR THE
; CONTEXT PAGES' CORE PAGES, SINCE THEY WERE INCREMENTED WHILE
; SWAPPING IN THE CONTEXT PAGES IN ORDER TO KEEP THEM FROM
; GOING AWAY.

EXTERNAL LMMEXS,LMPLOK,%UPX.N,USYPXM

SWICS7:	PUSHJ	P,MPSUPS	;ALL CONTEXT PAGES IN NOW, MAKE THE LMAP ADDRESSABLE
SWIC7A:	MOVEM	J,UPSJOB	;STORE THIS AS WE KNOW THESE WILL
				; STICK AROUND.
	MOVSI	T1,CTXVIR!CTXSWE ;ARE THESE CONTEXT PAGES VIRGIN
				;OR ARE THEY BAD?
	TDNE	T1,JBTCTX(J)	;IF SO, SET THEM UP AGAIN.
	JRST	SWICSV
	CAMN	J,%UPS+UPTJOB	;SUPPOSED TO BE OK. ARE THEY?
	JRST	SWICS8		;YES.
	MOVSI	T1,CTXSWE	;NO, SET SWAP ERROR, AND SET THEM UP FRESH
	IORM	T1,JBTCTX(J)	;BY FALLING INTO SWICSV.
SWICSV:	MOVE	T1,[UPT,,%UPS]	;COPY TRAP LOCS, PCS
	BLT	T1,%UPS+UPTFSL-1;TO LAST LOC BEFORE SOFTWARE PLACES
IFCPU (KL),<SETZM	%UPS+UPTHEC	;CLEAR OUT FUNKY METER DATA THAT WAS COPIED FROM 
	SETZM	%UPS+UPTLEC	;NULL JOB'S UPT
	SETZM	%UPS+UPTHMC
	SETZM	%UPS+UPTLMC
>;END IFCPU (KL)
	MOVE	T1,[%UPS+UPTFSL,,%UPS+UPTFSL+1]
				; GET READY TO ZERO OUT REST
	SETZM	%UPS+UPTFSL	;CLEAR FIRST SOFTWARE LOCATION
	BLT	T1,%UPS+UPTEND	;CLEAR OUT TO THE END
	MOVE	T1,PBMMSK	;SETUP PER PROCESS AREA BIT MASK
	MOVEM	T1,%UPS+UPTPBM	;USED FOR DYNAMIC ALLOC.
	MOVE	T1,UPT+UPTACP	;GET AC STACK POINTER
	MOVEM	T1,%UPS+UPTACP	;INIT THAT.
	HRRZ	T1, AGENTV
	MOVEM	T1, %UPS+UPTNTV	;FOR PAGE AGEING
	AOS	T1,SYSUID	;GET NEXT UNIVERSAL FRAME ID
	MOVEM	T1,JBTUID(J)	;STORE IT TILL FRAME DIES.

;NOW UPDATE THE DUMMY ATB COUNTS FOR THE CONTEXT PAGES ABOUT TO
; BE MAPPED. NOTE THAT THE DUMMY ATB CAN STILL HAVE VALUES
; IN IT FROM THE PREVIOUS OCCUPANT OF THE JOB NUMBER IF
; SOME OTHER JOB HAS PRIVATE PAGES MAPPED FROM THAT
; PREVIOUS OCCUPANT.

	PUSHJ	P,JOBATB	;NOW INIT THE JOB'S ATB
	MOVEI	T2,NCTXPG	;THIS MANY SLOTS WILL BE MAX-WRITE
	ADDM	T2,ATBMWC(T1) 	;THIS MANY MORE PAGES MAPPED WRITABLE.
	MOVS	T2,ATBDUM&ATBUMC&ATBSTS(T1) ;GET SWAPPED COPY
	TSO	T2,[ATPDUM,,ATPMXU] ;MAKE SURE DUMMY BIT IS ON, SET MXU
	ADDI	T2,NCTXPG	;INCREASE ATBUMC BY NCTXPG.
	MOVSM	T2,ATBDUM&ATBUMC&ATBSTS(T1)
				;SET THESE FIELDS

	MOVEI	T1,1000		;INIT UWS LIMIT AND MAX
	DPB	T1,USYUWM
	DPB	T1,USYUWL
	MOVEM	J,%UPS+UPTJOB	;REMEMBER WHO THIS IS FOR.
	SETZ	T1,		;CLEAR UWS SIZE NOW.
	DPB	T1,JBYUWS
	HRLM	T1,JBTUPM(J)	;NUMBER OF EXISTENT PAGES TOO.
				;MWS SIZE ALREADY CLEARED IF THESE ARE NEW
				; (AS OPPOSED TO ERROR, THEN STILL NEED MWS SIZE TO DECREMENT SIPTOT.)

SWICS8:	MOVE	W,[-NCTXPG,,<%UPT.N+CNVVPN>] ;AOBJN POINTER TO VIRTUAL PAGE
	MOVSI	T1,LMMEXS	;IF %UPX DOES NOT EXIST,
	TDNN	T1,%UPLMS+%UPX.N+CNVVPN
	SKIPA	P2,USYPXM	;JUST SET TO CURRENT %UPT [UPSPTR(%UPX.N-1)]
	SETZ	P2,		;ELSE LEAVE IT ALONE, ITS REAL.
	MOVE	F,EPYPSM	;TO GET CP NUMBER FROM EPT [EPTPTR(%UPS.N-1)]

SWICS5:	PUSHJ	P,GETLMS	;GET LMAP SLOT INFO
	MOVSI	T1,CTXVIR!CTXSWE ;VIRGIN OR SWAP ERROR?
	TDNN	T1,JBTCTX(J)	;?
	JRST	SWICSX		;NO, DON'T INIT SLOT CONTENTS
				; IF SWAP ERROR, BETTER NOT BE ANYONE SHARING THIS DP, OR
				; REMOVE WILL TURN OFF M BIT ON THEM.
	AOS	%UPS+UPTLDC	;SLOT EXISTS NOW, STOLMA DECREMENTS
	MOVSI	P3,<CPRRDW*LMPCUR>!LMPMXW ;MAKE IT READ WRITE, MAX WRITE
	LDB	T2,CTXTAB-<%UPT.N+CNVVPN>(W) ;GET DP ADDR
	DPB	T2,UP4LDA	;PUT LOW ORDER INTO UPT
	TRZ	P4,PGE.A	;MAKE SURE A BIT IS OFF
	LSH	T2,-LMASRP	;RIGHT JUSTIFY HI ORDER DP ADDR
	DPB	T2,LM3HDA	;PUT INTO SLOT
	MOVEI	T1,DABBIT(J)	;GET DUMMY ATB POINTER
	DPB	T1,LM3ATB	;PUT INTO THE SLOT
				;CONTEXT PAGES DON'T HAVE TO BE IN MWS
SWICSX:	ILDB	PG,F		;GET MAP SLOT FROM EPT
	ANDI	PG,17777	;JUST CP NUMBER
	HRRZ	T1,JBTUPM(J)	;IF ALREADY WAS HERE,
	JUMPN	T1,SWICS9	;DON'T SET IT UP AGAIN, ELSE
	MOVEI	T1,400000+USRACB_^D15(PG)
	HRRM	T1,JBTUPM(J)	; SETUP UPT ADDRESS.
SWICS9:	SETO	T1,		;CONTEXT PAGES ARE ALWAYS DIRTY
	DPB	T1,PGYDRT	;
	PUSHJ	P,DECUSE	;DECREMENT THE USE COUNT. IF USE COUNT
				; GOES TO ZERO, DFRPGN WILL BE INCREMENTED AND
				; PAGE WILL GO ONTO DIRTY FREE LIST, WHERE
				; ACTIVATE CAN GET IT.
	MOVSI	T1,CTXUCU	;GET BIT
	ANDCAM	T1,@CTXTAB-<%UPT.N+CNVVPN>(W)
				;CLEAR THE "USE COUNT UP FOR SWAPPER" BIT
	PUSHJ	P,ACTLMS	;ACTIVATE ANOTHER CONTEXT PAGE
	TRO	P4,PGE.A	;MAKE SURE CAN ACCESS THEM
	PUSHJ	P,STOLMS	;PUT LMAP INFO BACK INTO LMAP FROM P3,P4

	SKIPE	P2		;IF %UPX DOESN'T EXIST, HAVE TO SET IT
	IDPB	P4,P2		; UP TO SAME AS %UPT.

SWICS6:	AOBJN	W,SWICS5	;LOOP UNTIL FINISHED WITH ALL CONTEXT PAGES
	MOVSI	T1,CTXVIR	;CLEAR VIRGIN BIT
	ANDCA	T1,JBTCTX(J)	;AND SET THE BIT THAT SAYS
	TLO	T1,CTXCIN	;THAT CONTEXT PGES ARE IN CORE
	MOVEM	T1,JBTCTX(J)
	TLNE	T1,CTXSWE	;ERROR SOMEWHERE?
	JRST	SWECTX		;YES, GO KILL THE JOB.
	TLZN	T1,JSTCTX	;ONLY NEED CONTEXT PAGES IN?
	JRST	SWILAS		;NO, DO THE REST
	MOVEM	T1,JBTCTX(J)	;YES, RESET THE BIT NOW
SWERTN:	LDB	T1,JBYMWS	;GET MWS SIZE
	MOVNS	T1		;-VE
	ADDM	T1,SIPTOT	;RE INCREMENT SIPTOT
	SKIPE	P1		;IF ANY RESERVED PAGES LEFT,
	PUSHJ	P,DECRES	;GIVE 'EM BACK
	MOVEI	T1,NCTXPG	;WE SWAPPED THIS MANY IN
	DPB	T1,USYSIN	;SO ICPT GETS SET IF NEEDS TO BE
	JRST	SWIDN1		;GO TAKE OFF SWAP IN LIST, CLEAR 
				; MRQ OR WHATEVER AND RETURN.
SUBTTL LMAP ACTIVATE SCAN

;NOW THAT ALL THE CONTEXT PAGES ARE IN, ACTIVATE ALL LMAP
; SLOTS IN MWS THAT HAVE PAGES IN CORE WHILE COUNTING
; THE NUMBER OF PAGES THAT NEED TO BE RESERVED.
; BEFORE CALLING ACTLMS FOR AN LMAP SLOT THAT HAS ITS DISK
; PAGE IN CORE, EITHER THAT PAGE MUST BE
;	1) USED (USE COUNT NON-ZERO)
;	2) PGYSOP SET AND DIRTY OR CAPPGN NON-ZERO
;	3) CLEAN AND FREE WITH CAVPGN NON-ZERO
;	4) DIRTY FREE AND DFRPGN NON-ZERO
;	5) SWAP IN IN PROGRESS
;
;IF NONE OF THE ABOVE ARE TRUE, THEN THE PAGE IS
; IN ONE OF THE FOLLOWING STATES:
;	1) PGYSOP SET, CAPPGN = 0 AND CLEAN
;	2) CLEAN FREE, CAVPGN ZERO
;	3) NOT IN CORE.
;
;FOR CASE 1 ABOVE, CAPPGN IS INCREMENTED, RIPPGN DECREMENTED,
; AND ONE MORE PAGE IS RESERVED AT THE END OF THE ACTIVATE
; SCAN TO REPLACE THE SOP-RES PAGE WE STOLE.
;
;FOR CASE 2 ABOVE, CRSPGN IS DECREMENTED AND CAVPGN IS INCREMENTED
; IN ORDER THAT ACTLMS CAN ACTIVATE THE PAGE. ONE MORE PAGE
; IS RESERVED AT THE END OF THE ACTIVATE SCAN TO REPLACE
; THE CLEAN RESERVED PAGE WE STOLE.
;
;SEPARATE COUNTS ARE KEPT OF THE NUMBER OF PAGES THAT WERE
; NOT IN CORE, THE NUMBER OF SOP-RES PAGES STOLEN, AND
; THE NUMBER OF CLEAN RESERVED PAGES STOLEN.  NOTE THAT
; ONLY THE FIRST COUNT REPRESENTS RESERVED PAGES THAT
; ACTUALLY BELONG TO THE JOB - THE OTHER COUNTS REPRESENT
; RESERVED PAGES STOLEN FROM OTHER JOBS THAT WE WILL MAKE UP
; FOR.  THE REASON FOR KEEPING THE THREE SEPARATE COUNTS IS
; TO GIVE BACK STOLEN PAGES OF THE APPROPRIATE TYPE IN CASE
; SWPRES CAN'T GIVE THIS JOB THE REQUESTED NUMBER OF RESERVED
; PAGES.
;HERE DURING THE CYCLE IN WHICH WE COMPLETED THE CONTEXT
; PAGE SWAP IN SCAN. P1 HAS NUMBER OF RESERVED PAGES JOB HAS SO FAR.

SWILAS:	MOVEI	W,0		;START SCANNING WITH PAGE 0
	DPB	W,USYSIN	;INITIALIZE NUMBER OF SWAP IN PAGES
	MOVN	S,P1		;S CONTAINS COUNT OF CLEAN RESERVED
				; PAGES STOLEN. START IT OUT WITH
				; -VE NUMBER OF RESERVE PAGES WE HAVE
				; NOW.
	SETZB	P1,P2		;P1 CONTAINS COUNT OF PAGES NOT
				; IN CORE
				;P2 CONTAINS COUNT OF SOP-RES
				; PAGES STOLEN
	SETZM	STLBTM		;CLEAR OUT BIT MAP OF STOLEN PAGES KEPT BY ACTLMS AND NAILIT
	MOVE	T1,[STLBTM,,STLBTM+1]
	BLT	T1,STLBTM+<<VPMAX+^D35>/^D36>-1

	JSP	F,NXSMWS	;GET NEXT PAGE IN MWS FROM BIT TABLE
	  JRST	SWILA5		;NO MORE.
	MOVSI	T1,LMPACT	;QUICK CHECK FOR ACTIVE
	TDNN	T1,%UPLMS(W)	;IF NOT ACTIVE, GO GET LMAP SLOT
	JRST	SWILA2
	AOS	OKPCNT		;YES, ANOTHER ONE THAT WAS ALREADY OK
	JRST	(M)		;DON'T HAVE SLOT, JUST RETURN FOR NEXT PAGE.

SWILA2:	PUSHJ	P,GETLMS	;NEED SLOT NOW.
	PUSHJ	P,GETDPA	;GET DISK ADDRESS IN T2
	PUSHJ	P,SRCCHT	;IS IT IN CORE?
	  AOJA	P1,MWSMNX	;NO, RESERVE ANOTHER PAGE
SWILA3:	MOVEI	T4,ACTLMS	;NAILING ROUTINE
	PUSHJ	P,NAILIT	;MAKE SURE SWPRES DOESN'T TAKE THIS AWAY
	AOS	STLCNT		;ONE THAT WAS IN CORE BUT NOT ACTIVE.
SWILA4:	PUSHJ	P,STOLMS	;PUT LMAP DATA BACK
	JRST	(M)		;GET NEXT PAGE


;HERE FROM EVERYONE THAT CALLS NXSMWS WHEN THEY ARE DONE WITH
; SLOT DATA IN P3 AND P4 BUT DON'T WANT TO STORE IT BACK.
; AFTER ADJUSTING UPTLDC, JRST (M) TO GET NEXT MWS PAGE.

MWSMNX:	SOSGE	%UPS+UPTLDC	;DON'T NEED DATA ANYMORE
	STOPCD
	JRST	(M)		;GET NEXT MWS PAGE.
;SCAN IS FINISHED. SEE IF WE CAN RESERVE THE NEEDED PAGES

SWILA5:	MOVE	P3,P1		;NUMBER OF PAGES WE NEED FOR SWAP INS
	ADD	P3,P2		;PAGES TO RESERVE TO REPLACE STOLEN
				; SOP-RES PAGES
	ADD	P3,S		;PAGES TO REPLACE CLEAN RESERVED
	JUMPLE	P3,[JUMPE P3,SWILA6 ;GO IF NOTHING TO DO
		    EXCH P1,P3	;JOB OWNS SOME, GIVE THEM BACK
		    MOVMS P1	;NUMBER TO GIVE BACK
		    PUSHJ P,DECRES
		    MOVE P1,P3	;GET NUMBER NOT IN CORE AGAIN IN P1
		    JRST SWILA6] ;AND UPDATE SIPTOT
	PUSHJ	P,SWPRES	;GO RESERVE
	  TRACE(6,<JRST	SWIBKO>)		;OH OH, GIVE BACK STOLEN STUFF
	PUSHJ	P,MAPUPS	;MAKE THIS JOB'S LMAP ADDRESSABLE AGAIN

SWILA6:	LDB	S,JBYMWS	;ORIGINAL GUESS (COULDN'T CHANGE,
				; FOR IF JOB IS RUNNABLE WE WOULD
				; GET HERE ON FIRST SWAPPER CYCLE)
	SUBM	P1,S		;-VE AMOUNT WE OVERESTIMATED BY
	ADDM	S,SIPTOT	;DECREMENT SIPTOT
SWILA7:	MOVE 	T2,P3		;NOW DO A LITLE STATISTICS ON
	IMULI	T2,^D10		;PAGES TO SWAP IN AS FRACTION OF
	SETZ	T1,		;JOBS MWS
	LDB	T3,JBYMWS	;GET A NUMBER BETWEEN 0 AND 9
	DIV	T1,T3		;AND BUMP LITTLE HISTOGRAM
	SKIPGE	T1		;LITTLE SAFETY CHECK
	STOPCD
	CAIL	T1,SINTBS	;BIGGER TTHAN TBL SIZE?
	MOVEI	T1,SINTBS-1	;SIGH,LAST BUUCKET IS CATCH-ALL
	AOS	SINTB(T1)	;SEE PERFORMANCE COUNTERS AREA
	JUMPE 	P1,SWIDN1	;IF NO SWAP INS TO DO, DONE
	MOVEI	T3,SWSSWI	;OTHERWISE, NEXT PHASE
	DPB	T3,JBYSWS	;IS LMAP SWAP IN SCAN
				;FALL INTO LMAP SWAP IN SCAN
SUBTTL LMAP SWAP IN SCAN
;HERE WITH P1 CONTAINING NUMBER OF RESERVED PAGES.
; BEGIN (OR CONTINUE WITH) SWAP IN LMAP SCAN

	MOVEI	W,0		;START WITH PAGE 0
	DPB	W,USYLSP	;THIS IS THE FIRST LMAP SCAN POINTER
	JRST	SWISW0		;GO JOIN THE SCAN CODE.

;HERE IF THIS IS NOT THE FIRST TIME DOING THE SCAN FOR THIS JOB

SWISWI:	PUSHJ	P,MAPUPS	;MAKE JOB'S LMAP ADDRESSABLE
	LDB	W,USYLSP	;GET LMAP SCAN POINTER
	LDB	P1,USYRES	;RESERVED PAGE COUNT

;HERE WITH W/ LMAP SCAN POINTER, P1/RESERVED PAGES LEFT,
; P2/NUMBER OF PAGES WITH SWAP IN IN PROGRESS FOR THIS JOB

SWISW0:	JSP	F,NXSMWS	;GET A MWS PAGE, MAYBE ONE IN W.
	  JRST	SWIDON		;FINISHED WITH MWS.
	MOVSI	T1,LMPACT	;QUICK CHECK FOR ACTIVE
	TDNE	T1,%UPLMS(W)	;IF ACTIVE,
	JRST	(M)		;GET ONE THAT ISN'T.

SWISW7:	PUSHJ	P,GETLMS	;GET THE INACTIVE SLOT.
	PUSHJ	P,GETDPA	;NO, GET DISK ADDRESS
	PUSHJ	P,SRCCHT	; IN T2. IS IT IN CHT?
	  JRST	SWISIN		;NO, GO TRY TO SWAP IT IN
	LDB	T1,PGYSTS	;GET CP STATUS BITS
	TRNE	T1,PGPSIP	;SWAP IN GOING?
	JRST	SWIRD1		;YES, JUST ACTIVATE IT.
;CORE PAGE EXISTS FOR LMAP SLOT AND NO SWAP IN IN PROGRESS.
; IF USE COUNT IS UP, PAGE IS DIRTY, OR SWAP OUT IN PROGRESS
; AND CAPPGN IS NON-ZERO, JUST ACTIVATE. IF CAPPGN IS ZERO
; AND PAGE IS SOP AND THIS JOB HAS A RESERVED PAGE LEFT,
; DECREMENT RIPPGN AND INCREMENT CAPPGN (STEAL) AND GO ACTIVATE.
; IF RAN OUT OF RESERVED PAGES, JUST CHECK NEXT VP. IF PAGE
; IS CLEAN FREE AND CAVPGN IS NON-ZERO, JUST ACTIVATE. ELSE
; IF JOB HAS RESERVED PAGE LEFT, STEAL CLEAN RESERVED PAGE.

	LDB	T2,PGYUSE	;USE COUNT UP?
	JUMPN	T2,SWIRD1	;YES, JUST ACTIVATE
	TRNE	T1,PGPDRT	;IS PAGE DIRTY?
	JRST	SWIRD1		;YES, DFRPGN MUST BE .GT. ZERO
				; OR ITS A DIRTY SWAP OUT IN PROG PAGE
	TRNN	T1,PGPSOP	;SWAP OUT GOING?
	JRST	SWIRD0		;NO, ITS CLEAN FREE.
	SKIPE	CAPPGN		;CAN WE JUST TAKE IT?
	JRST	SWIRD1		;YES, GO ACTIVATE
	SOJL	P1,SWIRD2	;NO. HAVE RES PAGE LEFT?
	SOSGE	SIPTOT		;YES, NOT STARTING SWAP IN SO DECREMENT THIS
	STOPCD			;WENT BAD
	SOSGE	RIPPGN		;TRADE IT FOR THIS PAGE
	STOPCD			;HAD TO BE ONE, CAPPGN WAS ZERO
	AOS	CAPPGN		;NOW PAGE IS CLEAN AVAILABLE SOP
	JRST	SWIRD1		;NOW CAN GO ACTIVATE IT.
SWIRD0:	SKIPE	CAVPGN		;NO, PAGE IS CLEAN-FREE. AVAILABLE?
	JRST	SWIRD1		;YES, JUST ACTIVATE
	SOJL	P1,SWIRD2	;IF RAN OUT OF RESERVED PAGES, FORGET IT
	SOSGE	SIPTOT		;USING A RESERVED PAGE BUT NO SWAP IN
	STOPCD			;WENT NEGATIVE, SORRY.
	SOSGE	CRSPGN		;USE A RESERVED CLEAN PAGE
	STOPCD			;HAS TO BE NON-ZERO
	AOS	CAVPGN		;OK, MAKE IT AN AVAILABLE PAGE
SWIRD1:	PUSHJ	P,ACTLMS	;ACTIVATE THE SLOT
	AOS	STLCNT		;COUNT ANOTHER STOLEN PAGE.
	JRST	SWINVP		;GO DO NEXT PAGE

SWIRD2:	AOS	NSRCNT		;ANOTHER PGE WE COULDN'T STEAL
	JRST	MWSMNX		;DO NEXT MWS PAGE
;HERE IF INACTIVE PAGE IN MWS IS NOT IN CHT. IF JOB HAS A
; RESERVED PAGE, BEGIN SWAP IN.
; IF SLOT IS VIRGIN, MUST CHECK SPT VIA ROUTINE TSTVIR
; TO MAKE SURE NO ONE FIXED IT YET.

SWISIN:	JUMPLE	P1,SWINIR	;HAVE TO BE ABLE TO GET SOMETHING TO
				; SWAP IN WITH.
	PUSHJ	P,GETRES	;GET A RESERVED PAGE
	  JRST	SWINJB		;NONE AVAILABLE YET, STEP TO NEXT JOB
				;OK, HAVE A CLEAN CP, CAVPGN INCREMENTED FOR IT.
	PUSHJ	P,GETDPA	;OK, GET DISK ADDRESS FROM LMAP
	PUSHJ	P,INSCHT	;PUT INTO CHT, SET PGYADR
	PUSHJ	P,TSTVIR	;IS THIS A VIRGIN PAGE?
	  JRST	SWISN0		;NO, START THE SWAP IN
	JUMPL	T1,[AOS SIOSWP	;SAY SWAPPER GOT TO THIS FIRST
		    TLZ P3,LMPVIR ;NO MORE VIRGIN FILE PAGE
		    JRST SWISN0];GO SWAP IT IN.
	SOSGE	SIPTOT		;YES, USING RESERVED PAGE BUT NOT
	STOPCD			; STARTING SWAP IN, DECREMENT THIS.
	AOS	VIRCNT		;COUNT ANOTHER VIRGIN PAGE DONE.
	JRST	SWISN1		;SKIP SWAPPING IT IN AND JUST ACTIVATE
SWISN0:	SETO	S,		;MARK
	DPB	S,PGYSIP	;SWAP IN IN PROGRESS
	SOSGE	CAVPGN		;GETRES LEFT THIS INCREMENTED.
	STOPCD			;WENT NEGATIVE.
	AOS	SINCNT		;RACK UP ANOTHER SWAP IN STARTED.
	PUSHJ	P,SWPIO		;ADD CORE PAGE TO THE SWAP LIST
	LDB	S,USYSIN	;INCREMENT THE SWAPPED IN COUNT
	AOS	S
	DPB	S,USYSIN

SWISN1:	PUSHJ	P,ACTLMS	;ACTIVATE THE REGULAR OR VIRGIN PAGE
	SOJA	P1,SWINVP	;ONE LESS RESERVED PAGE AND
				; GO STORE P3, P4 BACK INTO LMAP
				; AND STEP TO NEXT VP.

SWINIR:	AOS	NIRCNT		;ANOTHER PAGE WE COULDN'T SWAP IN
	JRST	MWSMNX		;GO LOOK AT NEX MWS PAGE.
;HERE TO STEP TO NEXT VIRTUAL PAGE WHEN LMAP DATA IN P3 AND/OR
; P4 HAS BEEN MODIFIED.

SWINVP:	PUSHJ	P,STOLMS	;PUT LMAP DATA BACK INTO LMAP
	JRST	(M)		;AND GO GET NEXT MWS PAGE


;HERE WHEN FINISHED THE SECOND (SWAP IN) LMAP SCAN.
; GIVE BACK ANY EXTRA RESERVED PAGES WE DIDN'T USE
; (HAPPENS WHEN JOB IS RUNNING DURING ITS SWAP IN AND
; MAKES ITS MWS SIZE SMALLER), REMOVE JOB FROM SWAP IN LIST,
; AND WAKE THE JOB UP. IF PAGE JOB WANTS IS STILL COMING IN,
; JOB WILL WAIT FOR IN IN PAGE FAULT CODE.

SWIDON:	JUMPLE	P1,SWIDN1	;IF ANY LEFT,
	MOVN	T1,P1		;GET NUMBER OF RESERVED PAGES NEGATED
	ADDM	T1,SIPTOT	;DON'T HAVE TO DO THESE SWAP INS ANYMORE,
				; SOMEONE ELSE DID THEM.
	PUSHJ	P,DECRES	;GIVE BACK THE RESERVED PAGES
SWIDN1:	MOVE	T1,[PRF!SWPINP!(MRQ)] ;CLEAR ALL SWAPPING BITS
	ANDCAM	T1,JBTSTS(J)
	PUSHJ	P,REMSIL
	LDB	T1,USYSIN	;GET NUMBER OF PAGES WE SWAPPED IN
	TRACE(7,<MOVEI	T2,SETICP>,T1)	;GET THE BIT TO CHECK
	TDNN	T2,JBTSTS(J)	;HAS THIS JOB BEEN PERSECUTED?
	JRST	SWINJ2		;NO, NO NEED TO PROTECT IT
	PUSHJ	P,SETIPT	;OK, SETUP ICPT FROM C(T1)
				; (EVEN IF NOTHING SWAPPED IN, SET IT TO C(PROT0).
	ANDCAM	T2,JBTSTS(J)	;CLEAR SETICP
	JRST	SWINJ2		;AND GO DO NEXT JOB.
SUBTTL STEP TO NEXT JOB

;HERE IF CAN'T GET RESERVED PAGE YET IN CONTEXT PAGE SWAP IN
; SCAN. SAVE NUMBER OF RESERVED PAGES THE JOB OWNS IN
; JBYCTR

SWINJC:	DPB	P1,JBYCTR	;SAVE FOR NEXT TIME
	JRST	SWINJ2		;AND TO GET NEXT JOB

;HERE TO STEP TO NEXT JOB IN SWAP IN LIST. JOB NUMBER WE WERE
; WORKING ON IS IN J, AND THIS JOB IS NOT DONE WITH ITS
; SWAP IN SCAN YET, SO MUST REMEMBER LMAP SCAN POINTER,
; NUMBER OF RESERVED PAGES, AND NUMBER OF SWAP IN IN PROGRESS
; PAGES.

SWINJB:	SOSGE	%UPS+UPTLDC	;HAD P3 AND P4 SETUP, THROW AWAY NOW.
	STOPCD
	JSP	F,FINXWS	;FIX UP STACK THAT NXSMWS MESSED UP
	DPB	W,USYLSP	;STORE LMAP SCAN POINTER
	JUMPGE	P1,.+2		;IF P1 IS NEGATIVE,
	SETZ	P1,		;ITS REALLY ZERO.
	DPB	P1,USYRES	;AND NUMBER OF RESERVED PAGES
				; AND FALL INTO CODE BELOW

;HERE TO STEP TO NEXT JOB WHEN COMPLETELY THROUGH WITH A JOB.
; NO NEED TO STORE ANY POINTERS IN THE LMAP

SWINJ2:	HRRZ	J,JBTFIT(J)	;JOB IS NOT ON FIT LIST ANYMORE, BUT
				; NEXT JOB IN JBTFIT IS STILL CORRECT
	SKIPN	-2(P)		;IF NO MORE JOBS TO SCAN IN QUEUES,
	JRST	SWISC2		;JUST DO NEXT JOB IN S.I.L
	MOVEM	J,FIT		;GOING TO SCAN THE SCHED QUEUES
				; FOR MORE JOBS TO GO ON SWAP
				; IN LIST. REMEMBER NEXT JOB
				; THAT WE WERE GOING TO DO, IF ANY.
	POP	P,J
	POP	P,F		;
	POP	P,M		;SO RESTORE POSITION IN QUEUES
	POP	P,U		;
	JRST	(M)		;AND GO GET NEXT JOB ON SCHED QUEUES.
SUBTTL BACK OUT

;HERE IF FAILED TO RESERVED ENOUGH PAGES TO BRING IN ALL
; CONTEXT PAGES. ADJUST SIPTOT, REMOVE JOB FROM SWAP IN
; LIST. DECREMENT USE COUNT FOR ALL CONTEXT PAGES THAT
; HAD USE COUNT UP.  AFTER THIS, CAVPGN AND CAPPGN WILL
; BE INCREMENTED APPROPRIATELY.  THEN, DECREMENT
; CAVPGN AND CAPPGN WITH THE NUMBER OF CLEAN RESERVED AND
; RESERVED SOP PAGES COUNTS IN S AND P2, RESPECTIVELY, AND
; INCREMENT CRSPGN AND RIPPGN.

SWICRP:	LDB	T1,JBYMWS	;ORIGINAL SIPTOT GUESS
	MOVNS	T1		;GET NEGATIVE
	ADDM	T1,SIPTOT	;RESTORE SIPTOT BACK TO WHAT IT WAS
	MOVEI	W,NCTXPG-1	;START WITH LAST CONTEXT PAGE
	MOVSI	P1,CTXUCU	;BIT FOR QUICK CHECKING

SWICR1:	TDNN	P1,@CTXTAB(W)	;USE COUNT UP?
	JRST	SWICR2		;NO, CHECK NEXT
	LDB	T2,CTXTAB(W)	;GET DISK ADDRESS IN T2
	PUSHJ	P,SRCCHT	;GET CORE ADDRESS
	  STOPCD		;HAS TO BE THERE.
	PUSHJ	P,DECUSE	;GIVE IT BACK
	ANDCAM	P1,@CTXTAB(W)	;USE COUNT NOT UP ANYMORE
SWICR2:	SOJGE	W,SWICR1	;STEP TO NEXT CONTEXT PAGE
	PJRST	SWIBAD		;GO UPDATE CAV, CAP, RIP,CRS AND RETURN
;HERE IF CANNOT RESERVE ENOUGH PAGES TO START LMAP SWAP IN
; SCAN. S CONTAINS THE NUMBER OF CLEAN RESERVED PAGES WE
; STOLE, P2 CONTAINS TE NUMBER OF RESERVED SOP PAGES WE STOLE
; IF JOB STOLE ANY PAGES, DEACTIVATE THEM. STOLEN PAGES ARE RECORDED
; IN STLBTM BY ACTLMS/NAILIT.
; THEN ADJUST CRS, RIP, CAV, CAP.
;
;TAKE JOB OUT OF SWAP IN LIST, ADJUST SIPTOT BACK ALSO.
;
;S MAY BE NEGATIVE, IF THERE WERE RESERVED PAGES LEFT OVER
; FROM CONTEXT PAGE SWAP IN PHASE. IN THIS CASE, GIVE BACK
; THAT MANY RESERVED PAGES BY CALLING DECRES.
;

SWIBKO:	JUMPGE	S,SWIBK1	;IF ZERO OR OWE SOME, CONTINUE
	MOVM	P1,S		;JOB OWNS SOME. GIVE THEM BACK
	PUSHJ	P,DECRES	;
	SETZ	S,		;NO STOLEN CLEAN RESERVED
SWIBK1:	LDB	T1,JBYMWS	;GET THE GUESS AT HOW MANY SWAP INS
	MOVNS	T1		; AND SUBTRACT IT FROM SIPTOT
	ADDM	T1,SIPTOT
	SKIPN	S		;IF ANYTHING TO GIVE BACK, DO IT
	JUMPE	P2,SWIBD0	;ELSE DON'T DEACTIVATE ANYTHING.

	MOVEI	W,0		;START SCANNING AT PAGE ZERO.
	PUSHJ	P,MAPUPS	;GET UPT BACK AFTER SWPRES CALL.

	JSP	F,NXTSTL	;GET STOLEN PAGE.
	  JRST	SWIBAD		;NO MORE, GO UPDATE COUNTS
	PUSHJ	P,GETLMS	;GET LMAP SLOT CONTENTS
	TLNN	P3,LMPACT	;HAD BETTER BE ACTIVE.
	STOPCD			;OOPS.
	PUSHJ	P,DEALMS	;DEACTIVATE, MAYBE INCREMENT CAV OR CAP
	PUSHJ	P,STOLMS	;STUFF LMAP DATA BACK
	JRST	(M)		;GO FOR NEXT PAGE IN MWS

;NOW UPDATE CRS, RIP, CAP, CAV. COME HERE FROM SWICRP TOO.

SWIBAD:	ADDM	S,CRSPGN	;HOW MANY CLEAN RES. WE STOLE
	ADDM	P2,RIPPGN	;HOW MANY SOP RES WE STOLE
	MOVNS	S
	MOVNS	P2		;GET READY TO DECREMENT MEMORY
	ADDB	S,CAVPGN	;DECUSE INCREMENTED THIS SOME
	ADDB	P2,CAPPGN	;THIS TOO
	SKIPL	S		;IF EITHER IS NEGATIVE, THEN
	SKIPGE	P2		;SOMETHING DIDN'T MATCH.
	STOPCD
SWIBD0:	PUSHJ	P,REMSIL	;TAKE JOB OUT OF SWAP IN LIST
	MOVEI	T1,SWPINP	;CLEAR SWAP IN PROGRESS.
	ANDCAM	T1,JBTSTS(J)	;
	AOS	SIFCNT		;ANOTHER JOB FAILED.
	JRST	SWINJ2		;NOW GET NEXT JOB.
SUBTTL MISCELLANEOUS CELLS

COMMENT \
THE SWAPPER USES THE FOLLOWING COUNTS, WHICH ARE RELATED
TO PHYSICAL CORE PAGE HANDLING:

RIPPGN - COUNT OF THE TOTAL NUMBER OF PAGES ON SPRLST, SODLST THAT
  ARE TO BE PUT ONTO CLEAN RESERVED LIST AT SWAP OUT DONE.

CAPPGN - COUNT OF NUMBER OF CLEAN AVAILABLE SWAP OUT IN
  PROGRESS PAGES. RIPPGN+CAPPGN+DIRTY SOP PAGES ARE EQUAL
  TO ALL THE PAGES THAT HAVE SOP ON.

NOTE THAT AT ANY GIVEN TIME RIPPGN+CRSPGN IS EQUAL TO
  THE NUMBER OF RESERVED PAGES STILL OWNED BY ALL JOBS BEING
  SWAPPED IN.

SIPTOT - TOTAL COUNT OF PAGES THAT ALL JOBS IN SWAP IN LIST
  INTEND TO SWAP IN OR ARE ALREADY COMING IN.
\

RIPPGN::0			;RESERVED IN PROGRESS COUNT
CAPPGN::0			;CLEAN AVAILABLE SWAP OUT IN PROG. COUNT
SIPTOT:: 0			;TOTAL SWAP IN PAGES
COMMENT !  OBSOLETE SIPQTA MECHANISM /AAA
SIPQTA:: EXP M.SQTA##		;HOW MANY PGS TO STOP SWAPPIN IN AT
!

;MORE MISCELLANEOUS CELLS

FIT:	0			;ARG TO SWPRES, EQUAL TO JOB TRYING
				; TO RESERVE PAGES FOR
BIGFIT: 0			;THE "BIG" JOB WHICH SWAPPER IS
				;CURRENTLY TRYING TO GET IN.  "BIG"
				;MEANING SETICP HAS BEEN SET, JOB HAS BEEN EATEN.
				;TO COME IN FOR THE JOB.

OUTJOB: 0			;THE JOB WHICH SWOSCN IS EATING FROM.
				;KEPT FROM CYCLE TO CYCLE.
				;-1 IF HIT END OF OSCAN ;  0 IF NEED
				;TO SCAN FOR NEW OUTJOB
OUTJPG: 0			;PGS EATEN FROM OUTJOB (CYCLE TO CYCLE)


DIUQTA:	^D20			;UP TO DIUQTA DIRTY IN-USE
				;PAGES ARE CLEANED UP IN ONCE-A-
				;SECOND CODE.

;CELLS TO SAVE SWOSCN QUEUE POSITION (BETWEEN SWOSCN CALLS IN ANY ONE
;SWAP CYCLE)  TO PREVENT SCANNING SAME JOBS AGAIN

SVQPOS:	BLOCK	1		;SAVED POSITION IN OSCAN (U)
SVQRPC:	BLOCK	1		;SAVED COROUTINE PC (M)
SVQRTN:	BLOCK	1		;SAVED RETURN PC (F)

POSAVL:	0			;UPPER BOUND ON NUMBER OF ACTIVE PAGES GRABBABLE BY SWOSCN

;PERFORMANCE COUNTERS

SWCCNT:	BLOCK	1		;TIMES SWAPPER WAS CALLED
SIJCNT:	BLOCK	1		;JOBS WE ADDED TO SWAP IN LIST
SIFCNT:	BLOCK	1		;JOBS WE TOOK OFF SWAP IN LIST WITHOUT DOING ANYTHING
STLCNT:	BLOCK	1		;PAGES STOLEN SUCCESSFULLY
SINCNT:	BLOCK	1		;SWAP INS STARTED (NOT VIRGIN PAGES)
VIRCNT:	BLOCK	1		;NO. VIRGIN PAGES DONE
NSRCNT:	BLOCK	1		;COULDN'T STEAL, NO RESERVED PGES
NIRCNT:	BLOCK	1		;COULDN'T SWAP IN, NO RESERVED PGES
DEACNT:	BLOCK	1		;PAGES DEACTIVATED INSIDE SWOSCN, NOT INCLUDING CONTEXT PAGES
OKPCNT:	BLOCK	1		;PAGES ALREADY IN CORE AT BEG OF SWAP IN
NAPCNT:	BLOCK	1		;TIMES SWAP IN SCAN STOPPED BECAUSE KNEW NOT ENOUGH JOBS TO SWAP OUT
HEQCNT:	BLOCK	1		;SWAP IN SCAN STOPPED BECAUSE HIT END OF QS
PFLCNT::BLOCK	1		;NUMBER OF PAGE FAILS
PFWCNT::BLOCK	1		;NUMBER OF TIMES PAGE FAIL WAITED FOR SWAPPER
VRACNT::BLOCK	1		;NUMBER OF VIRGIN PAGES DONE INSIDE ACTIVATE
PFICNT::BLOCK	1		;NUMBER OF FAULTS FOR INACTIVE PAGE
TOTACT::BLOCK	1		;TOTAL NUMBER OF ACTIVE SLOTS IN SYSTEM
SIOCNT::BLOCK	1		;TOTAL VSTIO UUOS THAT STARTED A PAGE IN
SIOBOM::BLOCK	1		;TOTAL VSTIO UUOS THAT DIDN'T START A PAGE IN
				; FOR VP WHOSE DP WAS IN CORE BUT
				; WAS NOT AVAILABLE (RESERVED FOR ANOTHER JOB)
SIOSWP::BLOCK	1		;NUMBER OF TIMES SWAPPER BROUGHT
				;IN VIRGIN FILE PAGE INSTEAD OF ACTLMA.
FRESID::BLOCK	1		;TOTAL NUMBER OF TIMES PAGE WAS STARTED IN
				; BUT USE COUNT WENT TO 0 AT DONE TIME.

EATCNT::BLOCK	1		;JOBS TOTALLY EATEN AWAY IN SWOCTX
BIGCNT::BLOCK 	1		;JOBS SELECTED AS BIGFIT
OUTCNT::BLOCK	1		;JOBS SELECTED AS OUTJOB
SSTC1::		0		;SWAPPER/SCHEDULER TEMP COUNTER 1
SSTC2:		0		;TO USE THESE, HOOK UP TO CODE OF
SSTC3:		0		;INTEREST BY PATCHING MONITOR.  (MPL)ICP
SSTC4:		0		;OR ITS SUCCESSORS WILL BE ARRANGED TO
SSTC5:		0		;PRINT THESE OUT IF THEY ARE
SSTC6:		0		;INCREMENTING.  THEY WILL PRINT ON A
SSTC7:		0		;COUNTS/SECOND BASIS.
SSTC8:		0		;HAVE FUN!
SSTC9:		0		;
SSTC0:		0		;

STLBTM::BLOCK	<VPMAX+^D35>/^D36	;BIT MAP FOR PAGES STOLEN IN
				; LMAP ACTIVATE SCAN.
XP SINTBS,^D10 ;SIZE LITTLE HISTOGRAM OF SWAP-IN SIZES
SINTB:: BLOCK SINTBS		;SWILAS RECORDS SIZES OF SWAP-IN
				;REQUESTS HERE
LOKJOB::0			;NUMBER OF JOB TO AVOID SWAPPING FOR.
SUBTTL RESERVE PAGES

;SUBROUTINE TO RESERVE PAGES FOR A JOB BEING SWAPPED IN.
; ONCE THIS ROUTINE RETURNS SUCCESSFULLY FOR A JOB,
; THAT JOB IS GUARANTEED THAT THE REQUESTED AMOUNT OF CLEAN FREE
; PAGES WILL BECOME AVAILABLE IN SOME FINITE AMOUNT OF TIME.
; IN ORDER TO GUARANTEE THIS, PAGES MUST BE TRANSFERRED FROM
; THE CLEAN AVAILABLE SET TO THE CLEAN RESERVED SET. ONLY JOBS
; THAT HAVE RESERVED PAGES IN THE SWAPPER ARE ALLOWED TO TAKE
; A PAGE FROM THE CLEAN FREE LIST AND DECREMENT CRSPGN
; (RESERVED PAGE COUNT) INSTEAD OF CAVPGN, WHICH ANYONE CAN
; DECREMENT.  IF THERE ARE NOT ENOUGH CLEAN AVAILALE PAGES
; AROUND TO TRANSFER OVER TO THE CLEAN RESERVED SET
; TO SATISFY A REQUEST, THIS ROUTINE MUST RESORT TO SWAPPING
; OUT PAGES, FIRST FROM THE DIRTY FREE LIST, THEN FROM JOBS'
; PAGES FROM JOBS THAT ARE SUBJECT TO SWAP OUT. IF THIS IS
; STILL NOT ENOUGH, THE ERROR RETURN MUST BE GIVEN. IF THIS
; HAPPENS, NO PAGES ARE RESERVED FOR THE JOB
;
;BEFORE THIS ROUTINE STARTS ANY NEW SWAP OUTS, THE
; CLEAN AVAIL. SOP PAGES PAGE COUNT (CAPPGN) IS CHECKED TO SEE IF
; THERE ARE PAGES ON THEIR WAY OUT THAT CAN BE USED TO
; SATISFY A RESERVE REQUEST. IF SO, THESE ARE USED UP BEFORE
; ANY NEW SWAP OUTS ARE STARTED.
;
;GENERAL PLAN:
;
;1) SEE IF THERE ARE ENOUGH CLEAN AVAILABLE, CLEAN AVAIL. SOP PAGES, AND DIRTY
;  FREE PAGES TO SATISFY THIS REQUEST. IF SO, THERE IS NO NEED
;  TO SWAP OUT PAGES THAT ARE IN SOME JOB'S WORKING SET.
;  IF THERE ARE NOT ENOUGH PAGES, A ROUTINE IS CALLED TO SCAN
;  THE SCHEDULER QUEUES BACKWARD, DEACTIVATING ALL THE PAGES
;  IN THE JOBS' LMAP. THIS WILL MAKE MORE DIRTY AND CLEAN FREE
;  PAGES AVAILABLE. KEEP DOING THIS UNTIL ENOUGH CLEAN, DIRTY,
;  FREE AND CLEAN AVAIL. SOP PAGES PAGES ARE AVAILABLE TO SATISFY
;  THE CALLER'S REQUEST. STOP SCANNING JOBS WHEN THE CALLER'S
;  QUEUE POSITION IS REACHED.
;
;2) WHETHER OR NOT THE SCHEDULER QUEUES WERE SCANNED, TRANSFER
;  ENOUGH CLEAN AVAILABLE TO CLEAN RESERVED TO HELP SATISFY THE
;  REQUEST. USE ALL AVAILABLE CLEAN AVAIL. SOP PAGES PAGES.  THEN START
;  ENOUGH PAGES ON THE DIRTY FREE LIST SWAPPING OUT TO ENSURE THAT
;  WHEN THEY FINISH SWAPPING OUT, CRSPGN WILL BE INCREMENTED SUFFICIENTLY
;  TO SATISFY THE CALLER'S REQUEST.
;
;NOTE THAT DIRTY SWAP OUT IN PROG. PAGES ARE IN EFFECT TIED
; UP UNTIL THEY COMPLETE SWAP OUT, SINCE THEY HAVE
; TO BE STARTED OUT AGAIN BEFORE THEY CAN BE USED.
;ENTER HERE WITH P3 CONTAINING NUMBER OF PAGES TO RESERVE,
; J THE JOB NUMBER OF THE JOB TO RESERVE THEM FOR.

SWPRES:	JSP	T4,SWPSAV	;SAVE P1-P4, W, J, F, U, M
	MOVEM	J,FIT		;THIS IS WHERE TO STOP SCANNING

;FIRST SEE IF THERE ARE ENOUGH CLEAN AVAILABLE, DIRTY FREE,
; AND CLEAN AVAILABLE SOP PAGES TO SATISFY THE REQUEST

	MOVE	T1,CAVPGN	;CLEAN AVAILABLE
	ADD	T1,DFRPGN	;DIRTY FREE
	ADD	T1,CAPPGN	;PLUS ONES THAT WILL BECOME CLEAN AVAIL
	CAMG	P3,T1		;NEED MORE THAN THAT?
	JRST	SWPRS2		;NO. JUST USE WHAT WE NEED.

;HERE IF WE MUST MAKE ADDITIONAL CLEAN AVAILABLE AND DIRTY FREE
; PAGES BY DEACTIVATING LMAP SLOTS OF JOBS ELIGIBLE TO
;  HAVE PAGES STOLEN. NOTE THAT IF ENOUGH PAGES CANNOT
; BE FOUND AFTER ALL ELIGIBLE JOBS ARE SCANNED, THE PAGES
; DEACTIVATED THAT WERE IN JOB'S WORKING SETS REMAIN DEACTIVATED
; UNTIL THOSE JOBS PAGE FAULT AND HAVE THEIR WORKING SETS
; RE-ACTIVATED.  THIS OPENS THE POSSIBILITY OF LOWER PRIORITY
; JOBS TAKING PAGES AWAY FROM HIGHER PRIORITY ONES, SINCE
; ONCE THE PAGES ARE RETURNED TO A FREE LIST THERE IS NO
; METHOD OF DETERMINING THE PRIORITY OF THE JOB THAT WAS USING
; THEM.

	MOVE	P1,P3		;START WITH REQUESTED AMOUNT
	SUB	P1,T1		;GET HOW MANY WE NEED STILL
	PUSH	P,P3		;SAVE REQUEST AMOUNT ON STACK
	PUSHJ	P,SWOSCN	;TRY TO MAKE ENOUGH AVAILABLE
	  JRST	[POP P,P3	;COULD NOT FIND ENOUGH
		 POPJ P,]	;SO GIVE ERROR RETURN.
	POP	P,P3		;RESTORE ORIGINAL REQUEST AMOUNT.

;HERE IF THERE ARE NOW ENOUGH CLEAN AVAILABLE, DIRTY FREE, AND
; CLEAN AVAIL. SOP PAGES TO SATISFY THE REQUEST.

SWPRS2:	MOVE	T1,CAVPGN	;GET CLEAN AVAILABLE COUNT
	CAMLE	P3,T1	;ENOUGH OF THESE?
	JRST	SWPRS3		;NO
	MOVN	T1,P3		;YES. TRANSFER FROM CAVPGN
	ADDM	T1,CAVPGN	; TO
	ADDM	P3,CRSPGN	;CRSPGN.
	JRST	CPOPJ1		;AND GIVE GOOD RETURN

;NOT ENOUGH CLEAN AVAILABLE. ENOUGH COUNTING CLEAN AVAIL. SOP?

SWPRS3:	SUB	P3,T1		;HOW MANY WE STILL NEED
	ADDM	T1,CRSPGN	;TAKE ALL AVAILABLE CLEAN PAGES
	SETZM	CAVPGN
	MOVE	T1,CAPPGN	;GET NUMBER OF CLEAN AVAIL SOP PAGES
	CAMLE	P3,T1		;ENOUGH OF THESE TO COVER REQUEST?
	JRST	SWPRS4		;NO, TAKE ALL CAPPGN AND START SWAPPING OUT
	MOVN	T1,P3		;YES, TAKE FROM CAPPGN
	ADDM	T1,CAPPGN	;AND
	ADDM	P3,RIPPGN	;CAUSE THESE TO INCREMENT CRSPGN WHEN
	JRST	CPOPJ1		; THEY FINISH SWAPPING. GIVE GOOD RETURN.

;HERE IF CLEAN AVAIL. SOP PAGES WERE NOT ENOUGH TO SATISFY REQUEST.
; MUST START OUT PAGES FROM DIRTY FREE LIST.

SWPRS4:	SUB	P3,T1		;GET HOW MANY WE STILL NEED
	ADDM	T1,RIPPGN	;ALL CAPPGN CONVERTED TO RIPPGN
	SETZM	CAPPGN		;WE'VE TAKEN ALL CLEAN AVAIL. SOP PAGES
	AOS	(P)		;GIVE SKIP RETURN.
	PJRST	SWOSTR		;GO START OUT C(P3) PAGES.
;		FIND JOB TO SWAP OUT

;HERE TO SELECT (IF NECESSARY) A NEW OUTJOB, OR TO CONTINUE
;EATING AWAY FROM CURRENT OUTJOB.  SCAN FOR NEW OUTJOB ONLY IF
;CURRENT ONE CANNOT BE EATEN ANY LONGER (RAN OUT OF PGS OR NO
;LONGER ELIGIBLE TO BE EATEN).  COMPUTE POSAVL (UPPER BOUND
;ON HOW MANY PGS WE COULD POSSIBLY GET BY SCANNING) THE FIRST
;TIME IN ANY CYCLE THAT WE ARE FORCED TO SCAN .
;EXPECTS P1/PAGES WE STILL NEED (SO WE CAN USE GETLMS)


SWOSCN:	SKIPGE	J,OUTJOB	;ARE WE OUT OF JOBS THIS CYCLE?
	JRST	[AOS HEQCNT	;YES, INCREMENT COUNTER AND
		 POPJ P,]	;GIVE FAIL RETURN.
	SKIPN	T1,POSAVL	;SKIP IF WE ALREADY KNOW POSAVL THIS
	JRST	SWOSC0		;CYCLE. (DONT,CAN'T COMPARE YET)
	CAMLE	P1,T1		;ASKING FOR MORE THAN WE CAN GIVE?
	 JRST	[AOS NAPCNT
		 POPJ P,]	;FAIL RET
SWOSC0:
	MOVE 	M,SVQRPC	;LEFT BY QSCAN OR INIT BY SRSINI
	MOVE	F,SVQRTN	;LEFT BY JSP F,QSCAN
	MOVE	U,SVQPOS	;LAST POSITION IN OSCAN
	JUMPG	J,SWOSC3	;SEE IF CAN EAT MORE FROM JOB J

SWOSC1:	;ENTER HERE VIA JRST (M) IF OUTJOB EXISTING AT START
	;OF CYCLE NO LONGER ANY GOOD, OR FALL THRU FROM ABOVE IF
	;START CYCLE WITH NO OUTJOB.  NEED TO SCAN, SO COMPUTE
	;POSAVL FIRST.


;POSAVL:=MAX POSSIBLE PAGES SCANNING COULD PRODUCE THIS CYCLE =
;SUM(JBYACT) FOR ALL ELIGIBLE JOBS IN OSCAN.

	SETZ	P4,		;INIT COUNT
	MOVEI	U,OSCAN		;WHERE TO SCAN
	JSP	F,QSCAN		;START SCANNING
	  JRST	SWOSC2		;SCAN HIT END,GO STORE ANSWER
	MOVE	T1,JBTSTS(J)	;GET JBTSTS
	SKIPGE	JBTCTX(J)	;IF NO CORE, FORGET IT
	TDNE	T1,[<CMWB>B17!SWPINP] ;IF EITHER OF THESE ON, FORGET IT
	JRST	(M)		;GO FOR ANOTHER
	TLNE	T1,RUN		;HE'S ELIGIBLE, RUN OFF OR ICPT EXPIRED?
	SKIPGE	JBTICT(J)	; ICPT IS IN LH JBTICT
	JRST	.+2		;HE'S FAIR GAME
	JRST	(M)		;SORRY, CAN'T COUNT HIM.
	LDB	T1,JBYACT	;OK, GET NUMBER OF ACTIVE PAGES
	ADD	P4,T1		;ADD IT TO TOTAL
	JRST	(M)		;AND GO FOR MORE
SWOSC2:	MOVEM	P4,POSAVL	;THIS IS UPPER  BOUND
	CAMLE	P1,P4		;IS REQUEST IN LINE?
	JRST	[AOS NAPCNT	;NO, RETURN NOW.
		 POPJ P,]	;CAN'T DO ANTHING FOR HIM.



SWOSC4:	MOVEI	U,OSCAN		;SCAN TABLE TO FIND SWAP OUT JOBS
	SETZM	OUTJOB		;NO JOB TO EAT UNTIL QSCAN PRODUCES ONE
	JSP	F,QSCAN		;***SCAN QUEUES FOR JOB***
	  PJRST	SWODNN		;COULDN'T GET ENOUGH, ERROR RETURN

;CHECK ELIGIBILITY OF JOB IN J. MAY HAVE BEEN FOUND PREVIOUS CYCLE

SWOSC3:	CAMN	J,LOKJOB	;AVOID TAKING PAGES
	JRST	(M)		;FROM THIS GUY
	MOVE	T1,JBTSTS(J)	;GET JBTSTS WORD
	TRNE	T1,SWPINP	;SWAP ALREADY IN PROGRESS (IN?)
	JRST	(M)		;YES, GET ANOTHER JOB
	TLNN	T1,RUN		;IS RUN BIT OFF?
	JRST	SWOSC5		;IS OFF, IGNORE ICPT
	SKIPL	JBTICT(J)	;NO, IN CORE TIME OUT?
	JRST	(M)		;NOT YET, DON'T TOUCH THIS JOB
SWOSC5:	SKIPGE	JBTCTX(J)	;DON'T TOUCH IF NO CORE AND
	TLNE	T1,CMWB		;DON'T TOUCH JOBS WAITING FOR COMMANDS
	JRST	(M)
;		EAT AWAY AT JOB IN J

;HERE IF JOB IS OK TO TAKE PAGES FROM.  AVOID DEACTIVATING
; CONTEXT PAGES IF THERE ARE STILL ACTIVE PAGES IN THE LMAP,
; SINCE THIS WOULD LEAD TO DISASTER. IF ANY OF THE CONTEXT
; PAGES ARE DEACTIVATED, MUST SET MRQ SO THE SWAPPER CAN
; ACTIVATE CONTEXT PAGES AGAIN, WHICH IS NECESSARY BEFORE
; JOB CAN BE MADE RUNNABLE AGAIN, SINCE PAGE
; FAULT ASSUMES ADDRESSABLE CONTEXT PAGES.
;
;DEACTIVATE JOB'S PAGES ONE AT A TIME. IF PAGE HAS DIRECT
; I/O IN PROGRESS, AVOID DEACTIVATING IT AS DEACTIVATE WILL TRY
; TO INSTRUCT SCHEDULER TO WAIT UNTIL I/O HAS STOPPED FOR PAGE.
; (THIS WILL KEEP CONTEXT PAGES FROM BEING DEACTIVATED, IF IT
; HAPPENS, SINCE THERE IS NO ATTEMPT TO DEACTIVATE THE PAGE
; IF IT IS FOUND WITH THE DIC COUNT UP). IF USE COUNT IS NON-ZER
; AFTER DEACTIVATING, JUST STEP TO NEXT PAGE, SINCE
; THE CORE PAGE WAS NOT MADE AVAILABLE. IF USE COUNT IS NOW ZERO,
; AND IF SWAP OUT IN PROGRESS IS OFF (SWPINP COULDN'T BE ON BECAUSE
; LMAP SLOT WAS ACTIVE) DECREMENT COUNT OF HOW MANY PAGES
; ARE NEEDED, SINCE THE PAGE WAS RETURNED TO THE FREE LIST
; (CLEAN OR DIRTY) BY DECUSE, WHICH WAS CALLED BY DEALMS.
; IF SWAP OUT IN PROGRESS WAS ON, INCREMENT CAPPGN AND CALLER
; WILL TRANSFER THAT QUANTITY TO RIPPGN.

SWOSJ0:	SETZB	W,OUTJPG	;W/VP STARTS AT 0; NO PGS EATEN FROM OUTJOB
	TRACE(9,<MOVEM	J,OUTJOB>)	;THIS JOB IS NOW ON ITS WAY OUT
	MOVE	T1,[MRQ,,SETICP] ;SAY WE'VE EATEN HIM, AND NAIL HIM DOWN SO HE DOESNT
	IORM	T1,JBTSTS(J)	;CHANGE QUEUES ETC.
	AOS	OUTCNT		;ONE MORE GUY CHOSEN AS OUTJOB
	PUSH	P,U
	PUSH	P,M
	PUSH	P,F		;SAVE ACS THAT NXSMWS USES
	PUSHJ	P,MAPUPS	;MAKE THIS JOB'S LMAP ADDRESSABLE
	MOVSI	P2,LMPACT	;FOR QUICK CHECKING

SWOSJ1:	JSP	F,NXSMWS	;GET NEXT MWS PAGE
	  JRST	SWOCTX		;NO MORE MWS PAGES, GO EAT CONTEXT PAGES.
	TDNN	P2,%UPLMS(W)	;IS IT ACTIVE?
	JRST	(M)		;NO, GET NEXT ONE
	PUSHJ	P,GETLMS	;GET LMAP SLOT DATA IN P3, P4
	TLNE	P3,LMPLOK	;IF THE VP IS LOCKED IN CORE,
	JRST	MWSMNX		; CAN'T HAVE IT.
	PUSHJ	P,GETCPA	;GET CORE PAGE NUMBER IN PG
	LDB	T1,PGYDIO	;ANY DIRECT I/O GOING ON IN THIS PAGE?
	JUMPN	T1,MWSMNX	;YES, CAN'T DEACTIVATE IT YET. MAYBE
				; NEXT SWAPPER CYCLE
	PUSHJ	P,DEALMS	;OK. DEACTIVATE.
	AOS	DEACNT		;COUNT ANOTHER ONE
	SKIPLE	POSAVL		;UNLESS POSAVL WASNT COMPUTED,
	SOS	POSAVL		;NOTE ONE LESS POSSIBLE AVAIL PG
	AOS	T2,OUTJPG	;PGS EATEN FROM OUTJOB
	PUSHJ	P,STOLMS	;PUT LMAP SLOT DATA BACK
	LDB	T1,PGYUSE	;SEE IF IT WAS MADE AVAILABLE
	JUMPN	T1,(M)		;JUMP IF NOT YET. MAYBE LATER.

;HERE IF WE JUST DEACTIVATED THE SLOT AND ITS USE COUNT
; WENT TO ZERO.

	LDB	T1,PGYSTS	;GET CP STATUS BITS
	TRNN	T1,PGPSIP!PGPSOP ;ANY SWAPPING GOING?
	JRST	SWOSJ4		;NO, COUNT ONE LESS PAGE
	TRNN	T1,PGPSIP	;IF SWAP IN OR
	TRNE	T1,PGPDRT	;DIRTY SWAP OUT
	JRST	(M)		;IT DOES US NO GOOD.
				;NO, CAPPGN WAS INCREMENTED BY DECUSE
				; WHEN THIS SLOT WAS DEACTIVATED.
				; CALLER WILL DECREMENT CAPPGN AND INCREMENT RIPPGN.
SWOSJ4:	SOJG	P1,(M)		;NEED ONE LESS PAGE NOW.
	JSP	F,FINXWS	;FIX UP STACK
SWOS4A:	POP	P,F		;RESTORE SAVED ACS
	POP	P,M
	POP	P,U
	JRST	SWODON		;WE HAVE ALL WE NEED, GIVE GOOD RETURN
;HERE WHEN WE HAVE DEACTIVATED EVERYTHING WE CAN IN THE MWS FOR
; THE UNFORTUNATE JOB. TRY TO DEACTIVATE ALL THE CONTEXT PGES.
; CANNOT DO IT IF ANY OTHER PAGES LEFT ACTIVE. IF WE DO
; DEACTIVATE THE CONTEXT PAGES, IT MUST BE DONE ALL AT ONCE
; OR ELSE WE CAN'T MAKE THE ENTIRE LMAP ADDRESSABLE TO DEACTIVATE
; ANY REMAINING ONES.

SWOCTX:	MOVSI	T1,MRQ		;EITHER TAKING HIS CONTEXT PAGES, SO NEED MRQ ON
	IORM	T1,JBTSTS(J)	;OR CAN'T TAKE THEM, SO SET MRQ TO SETTLE HIM DOWN.
	LDB	T1,JBYACT	;GET NUMBER OF ACTIVE PAGES INCLUDING CONTEXT PGES.
	CAME	J,JOB		;IF THIS IS CURRENT JOB, ACS NOT YET
				;SAVED, SO CAN'T DO IT YET.
	CAILE	T1,NCTXPG	;ANY PAGES ACTIVE OTHER THAN THE CONTEXT PAGES?
	JRST	SWOSJ5		;CAN'T DEACTIVATE CONTEXT PAGES
	MOVSI	T1,CTXCIN	;NO. FLAG THAT CONTEXT PAGES NOT IN ANYMORE
	ANDCAM	T1,JBTCTX(J)
	HLLZS	JBTUPM(J)	;CLEAR OUT RH OF JBTUPM (UPT ADDRESS)
	AOS	EATCNT		;ONE MORE JOB TOTALLY EATEN
	MOVE	W,[-NCTXPG,,%UPT.N+CNVVPN] ;GET AOBJN POINTER
SWOCT1:	PUSHJ	P,GETLMS	;GET SLOT DATA
	PUSHJ	P,GETCPA	;GET CORE ADDRESS
	LDB	T1,PGYDIO	;NO DIO ALLOWED IN CONTEXT PAGES
	SKIPE	T1
	STOPCD			;(ONLY PRIV PEOPLE CAN TO THIS)
	LDB	T1,PGYSIP	;SWAP IN CAN'T BE GOING ON
				; (SWAP OUT CAN HAPPEN IF JOB
				; HAS RECONNECTED WHILE IT WAS GOING OUT)
	SKIPE	T1
	STOPCD
	PUSHJ	P,DEALMS	;DEACTIVATE THIS ONE
	SKIPLE	POSAVL		;UNLESS POSAVL WASNT COMPUTED,
	SOS	POSAVL		;NOTE ONE LESS POSSIBLE AVAIL PG
	CAMN	J,UPSJOB	;DID DEALMS CHANGE %UPS?
	JRST	SWOCT2		;NO
	PUSH	P,PG		;SAVE PG FROM MPSUPS
	PUSHJ	P,MPSUPS	;YES, POINT IT BACK TO US
	MOVEM	J,UPSJOB	;STORE BY HAND, MPSUPS ZEROES IT.
	POP	P,PG		;GET CP BACK THAT DEALMS SAVED FOR US.
SWOCT2:	PUSHJ	P,STOLMS	;PUT DATA BACK

;NOW SEE IF WE HAVE HELPED MATTERS ANY

	LDB	T1,PGYUSE	;GET USE COUNT NOW
	JUMPN	T1,SWOCT3	;IF USE COUNT UP, HAVEN'T FREED IT.
	LDB	T1,PGYSTS	;GET CP STATUS BITS
	TRNE	T1,PGPSOP	;ONE LESS IF NOT A DIRTY SOP PAGE
	TRNN	T1,PGPDRT
	SOS	P1		;ITS GOOD.
SWOCT3:	AOBJN	W,SWOCT1	;DO NEXT ONE.
	SETZM	UPSJOB		;CONTEXT PAGES ARE GONE, WERE MAPPED IN %UPS.
	JUMPLE	P1,SWOS4A	;IF HAVE SATISFIED HUNGER,
				; GO FIX STACK AND RETURN.

SWOSJ5:	POP	P,F		;RESTORE F, NO MORE MWS PAGES IN THIS JOB
	POP	P,M		;RESTORE M
	POP	P,U		;RESTORE U AND
	JRST	(M)		;GO FOR ANOTHER JOB.
;HERE WHEN REQUESTED NUMBER OF PAGES HAVE BEEN SUCCESSFULLY
; RESERVED, AND ALL I/O THAT CAN BE STARTED UP IS STARTED UP.

SWODON:
	MOVEM	F,SVQRTN	;SAVE COROUTINE RETURN, CONTINUE
	MOVEM	M,SVQRPC	;PC (M) AND OSCAN POSITION (U) IN
	MOVEM	U,SVQPOS	;CASE FURTHER SWOSCN CALLS THIS
				;CYCLE NEED TO CONTINUE SCAN
	JRST	CPOPJ1		;SKIP RETURN.

;HERE IF NO MORE JOBS IN QUEUES TO SCAN

SWODNN:	AOS	HEQCNT		;REASON WE STOPPED
	SETOM	OUTJOB		;SET OUTJOB NEGATIVE AS A FLAG
				;TO FURTHER SWOSCN CALLS THIS
				;CYCLE:  OUT OF JOBS
	POPJ	P,		;AND RETURN.
;SUBROUTINES SWOSTR AND CLNALL. IF ENTER AT SWOSTR, P3
; CONTAINS THE NUMBER OF PAGES ON THE DIRTY FREE LIST
; THAT SHOULD BE STARTED OUT. RIPPGN IS ADJUSTED.
;
;CLNALL STARTS OUT ALL PAGES ON DIRTY FREE LIST AND UP TO
;DIUQTA DIRTY IN-USE PAGES. CALLED PERIODICALLY.



SWPSEC::			;HERE ONCE A SEC FROM CLOCK1
CLNALL:	HRRZ	PG,DFRLST	;LIST MAY BE EMPTY..
	JUMPE	PG,USECLN	;TRY ELSEWHERE
	MOVEI	P3,20001	;ONE GREATER THAN MAXIMUM PHYS PAGE
	PUSHJ	P,SWOST0	;CALL COMMON CODE
	SUBI	P3,20002	;GET -VE NUMBER THAT WERE ON DFRLST
	JUMPE	P3,USECLN	;DID NOTHING. TRY ELSEWHERE
	ADDM	P3,DFRPGN	;DECREMENT DFRPGN
	MOVNS	P3		;GET NUMBER THAT WERE ON DFRLST
	ADDM	P3,CAPPGN	;NOW THIS MANY ARE CLEAN AVAIL SOP.

USECLN:	SKIPG	P1,DIUQTA	;DIRTY-IN-USE CLEANUP QUOTA
	POPJ	P,
	HRRZ	PG,USELST
	JUMPE	PG,CPOPJ
USECL1:	LDB	P2,PGYFPL	;GET BEFORE SWPIO ERASES IT
	LDB	T1,PGYDRT
	JUMPE	T1,USECL2	;CLEAN PAGE?
	CAMG	PG,MAXPCB	;AVOID CLEANUP OF PCB'S
	JRST	USECL2
	LDB	T2,PGYADR	;DSK PAGE FOR THIS CORE PG
	CAMN	T2,ADRDUM	;PHONY?
	JRST	USECL2		;YES,HANGING AROUND FROM SYS INIT'ZN STILL
	DPB	T1,PGYSOP	;OK..THIS IS A CANDIDATE PAGE TO CLEANUP
	PUSHJ	P,SWPIO		;GET IT GOING
USECL2:	SKIPE	PG,P2		;WAS THERE ANOTHER PG ON USELST
	SOJG	P1,USECL1	;ANOTHER EXISTS. DIUQTA RUN OUT?
	POPJ	P,		;ALL DONE.



SWOSTR:	MOVN	T1,P3		;GET -VE NUMBER TO GO
	ADDM	T1,DFRPGN	;THIS MANY LESS NOW.
	ADDM	P3,RIPPGN	;THIS MANY MORE SOP-RES.

SWOST0:	MOVEI	P4,1		;QUICK SOURCE OF ONES
	HRRZ	PG,DFRLST	;FIRST PAGE
	JUMPE	PG,CPOPJ	;END OF LIST, DONE

SWOST1:	DPB	P4,PGYSOP	;SWAP OUT NOW IN PROGESS
	LDB	P2,PGYFPL	;GET NEXT PAGE BEFORE ITS TOO LATE
	PUSHJ	P,SWPIO		;PUT ON I/O ACTIVE LIST
	SKIPE	PG,P2
	SOJG	P3,SWOST1	;AND CONTINUE WHILE THERE ARE SOME LEFT
	POPJ	P,
;ROUTINE TO GIVE BACK RESERVED PAGES, NUMBER TO GIVE
; BACK IN P1. FIRST TRY TO TRANSFER ENOUGH PAGES FROM RESERVED
; TO CLEAN AVAILABLE IN PROGRESS TO GIVE BACK ENOUGH.  IF THAT
; IS NOT ENOUGH, TRANSFER PAGES FROM CRS TO CAV
; NOTE: WE SHOULD REALLY TAKE CARE OF IOSPGN HERE, BUT
; FOR NOW ITS NOT WORTH IT.

DECRES:	MOVE	T1,RIPPGN	;GET COUNT OF RESERVED IN PROGRESS
	CAML	P1,T1		;ENOUGH IN PROGRESS
	JRST	DECRS1		;NO, HAVE TO DO MORE
	ADDM	P1,CAPPGN	;YES, JUST MAKE MORE CLEAN AVAIL SOP
				; PAGES, WILL BECOME FREE WHEN DONE.
	POPJ	P,		;RETURN

DECRS1:	ADDM	T1,CAPPGN	;ALL FORMERLY RESERVED SOP PAGES ARE
				; NOW CLEAN FREE SOP PAGES.
	SETZM	RIPPGN		;SEE? NO MORE.
	SUBM	P1,T1		;T1 GETS HOW MANY MORE WE NEED
	ADDM	T1,CAVPGN	;CREATE THAT MANY MORE CLEAN AVAIL.
	MOVNS	T1		;SUBTRACT IT OFF CRSPGN
	ADDM	T1,CRSPGN
	POPJ	P,		;RETURN.
;ROUTINE TO INITIALIZE SWAPPER FOR NEXT CYCLE

SRSINI:
	SETZM	POSAVL		;UPPER BOUND ON GRABBABLE PAGES.
	MOVEI	T1,SWOSC1	;INITIALIZE FOR SWOSCN
	MOVEM	T1,SVQRPC	;TO FORCE COMPLETE NEW OSCAN WHEN
				;ENTERING SWAPPER WITH A JOB IN OUTJOB
	SKIPGE	OUTJOB		;IF LEFT -1 LAST CYCLE (HEQ),
	SETZM	OUTJOB		;FORCE NEW OSCAN IN SWOSCN
	POPJ	P,
;ROUTINE NAILIT. CALLED WITH ROUTINE THAT NAILS DOWN
; A CORE PAGE IN T4 (EITHER ACTLMS OR INCCTX),
; PAGE TO NAIL DOWN IN PG, LMAP SLOT DATA IN P3, P4.
; INCREMENTS S IF HAD TO STEAL A CLEAN RESERVED PAGE,
; INCREMENTS P2 IF HAD TO STEAL A RESERVED SWAP OUT IN
; PROGRESS PAGE.


NAILIT:	LDB	T1,PGYUSE	;IF USE COUNT UP, CAN JUST ACTIVATE
	JUMPN	T1,(T4)		;CALL THE CORRECT ACTIVATE ROUTINE.
	LDB	T1,PGYSTS	;GET CP STATUS BITS
	TRNE	T1,PGPSIP!PGPDRT ;IF SWAP IN OR DIRTY
	JRST	(T4)		;JUST NAIL IT.
	TRNN	T1,PGPSOP	;IF SWAP OUT GOING
	JRST	NAILI2		;(MUST BE CLEAN FREE)

;SWAP OUT IN PROGRESS.

	SKIPE	CAPPGN		;IS THERE ONE AVAILABLE?
	JRST	(T4)		;YES, JUST NAIL FOR FREE.
	SOSGE	RIPPGN		;NO, MUST STEAL ONE.
	STOPCD			;BUT CAPPGN WAS ZERO!
	AOS	CAPPGN		;NOW MAKE STOLEN ONE AVAILABLE
	AOJA	P2,-1(T4)	;RECORD THEFT AND NAIL DOWN.
				; AD GO NAIL, TELLING ROUTINE IT WAS STOLEN.

;HERE IF PAGE DOES NOT HAVE SWAPPING GOING ON TO OR
; FROM IT.

NAILI2:	SKIPLE	CAVPGN		;NO, CLEAN. AVAILABLE?
	JRST	(T4)		;YES. CAVPGN OK, GO ACTIVATE
	SOSGE	CRSPGN		;STEAL A CLEAN-RESERVED PAGE
	STOPCD			;COUNTS AND CFRLST DON'T AGREE
	AOS	CAVPGN		;ONE MORE AVAILABLE PAGE NOW
	AOJA	S,-1(T4)	;REMEMBER WE STOLE ONE OF THESE
				; AND GO NAIL IT, TELLING ROUTINE ITS STOLEN. RETURN.
SUBTTL START SWAPPING I/O

COMMENT ;@@SUBROUTINE SWPIO
@@PURPOSE START SWAPPING I/O FOR CORE PAGE IN PG
@@ENTRY CORE PAGE IN PG, WITH PGYSIP OR PGYSOP ON
INDICATING DIRECTION OF DESIRED SWAP.
@@ACCUM PRESERVES ALL BUT T ACS
@@EXIT CORE PAGE IN PG
@@RESTRICTIONS CALLER MUST UPDATE CAVPGN OR RIPPGN IF THIS IS A
SWAP OUT PAGE.
@@FUNCTION IF SWAP IN IS REQUESTED, JUST ENTER REQUEST
USING SWPENQ. IF SWAP OUT IS REQUESTED, MARK PAGE
CLEAN, TURN OFF W BITS FOR ALL SLOTS ON LMA CHAIN.
IF ONE OF THE SLOTS IS A CONTEXT PAGE SLOT, DON'T MARK
CLEAN AND DISCONTINUE TURNING W BITS OFF.
@@;

SWPIO::	JSP	T4,SWPSAV	;SAVE F,J,W,M,U,P1-P4
	LDB	T1,PGYSIP	;SWAP IN REQUESTED?
	JUMPN	T1,SWPENQ	;YES, JUST CAL SWPENQ
	LDB	T1,PGYSOP
	SKIPN	T1
	STOPCD			;DON'T KNOW WHAT HE WANTS
	MOVEI	T1,SRPNDS	;IF DSKCLN HAS YET TO FINISH,
	TDNE	T1,STRDDB+STRBTS
	JRST	SWPIO3		;THEN DO SPECIAL THING.
	JSP	F,SCNLMC	;START SCANNING THE LMA CHAIN
	  JRST	SWPIO2		;END OF CHAIN
	CAIG	W,VPUMAX	;IS IT A CONTEXT PGE?
	JRST	SWPIO1		;NO, JUST TURN OFF W BIT
	JSP	F,FINLMC	;YES. STOP SCANNING
	JRST	SWPENQ		;AND LEAVE THE PAGE DIRTY.

SWPIO1:	TRZ	P4,PGE.W	;PAGE IS CLEAN NOW, DON'T LET PEOPLE
	JRST	(M)		;WRITE. STEP TO NEXT SLOT
SWPIO2:	LDB	T1,PGYDRT	;MAKE SURE NOT SWAPPING OUT CLEAN PAGE
	SOSE	T1		;CHECK AND ZERO T1 IF OK
	STOPCD			;YES, TOO MUCH SWAPPING GOING ON
	DPB	T1,PGYDRT
	PJRST	SWPENQ		;AND GO START I/O.
;CONTINUED ON NEXT PAGE
;THE FOLLOWING CODE EXISTS AS A CHECK DURING THE TIME WHEN
; DSKCLN IS RUNNING. SINCE WHEN DSKCLN STARTS UP THE STATE OF
; THE SATS IS QUESTIONABLE (SYSTEM MAY HAVE JUST CRASHED)
; THE INITIAL PAGES ALLOCATED MAY ACTUALLY BELONG TO SOME POOR
; USER'S FILE. HOWEVER, THESE PAGES WILL NEVER GET WRITTEN OUT
; IF ALL OF INITIA'S AND DSKCLN'S PAGES FIT INTO CORE.
; THEREFORE, THE ONLY PAGES ALLOWED TO BE WRITTEN OUT
; BEFORE DSKCLN HAS FINISHED ITS WORK ARE SUPER PAGES, WHICH WE
; ASSUME ARE SATS THAT DSKCLN IS FIXING.
; WHEN DSKCLN DOES THE NODSLN UUO, WE CRASH IF
; DFRLST IS NON-ZERO, SINCE THESE PAGES WILL BE WRITTEN
; OUT EVENTUALLY, AND SINCE THEY WERE GENERATED BEFORE
; DSKCLN FINISHED, THEY MIGHT BE PART OF USER'S FILES.
; WE CAN ONLY HOPE THAT AFTER THE NODSLN UUO THE DIRTY PAGES
; REMAINING (WHICH MUST BE ACTIVE SOMEWHERE) WILL NEVER GET OUT.
; SINCE REMOVE TAKES PRIVATE PAGES OUT OF THE CHT BEFORE THEY
; ARE WRITTEN AND VALIDATE NEVER WRITES THEM, WE SHOULD BE OK.

EXTERN SRPNDS,STRDDB,STRBTS

SWPIO3:	LDB	T1,PGYLMJ	;MAKE SURE ITS ACTIVE.
	SKIPN	T1		;IF NOT AND DSKCLN RUNNING,
	STOPCD			;ITS BAD, MAY WRITE ON USER'S FILE.
	JSP	F,SCNLMC	;OK SO FAR, SCAN LMA CHAIN
	  JRST	SWPIO2		;ALL SLOTS SUPER, GO CLEAN UP PAGE AND START IT OUT.
	TLNN	P3,LMPSUP	;MAKE SURE ITS SUPER SLOT
	STOPCD			;NOT, MAYBE WRITING ON USER'S FILE
	TRZ	P4,PGE.W	;OK, CAUSE FAULT NEXT WRITE
	JRST	(M)		;AND GO TO NEXT SLOT IF ANY.
;ROUTINES TO PUT JOB ON SWAP IN LIST, REMOVE FROM SWAP IN
; LIST.

PUTSIL:	HLRZ	T1,JBTFIT	;GET LAST MEMBER
	HRLZM	T1,JBTFIT(J)	;NEW LAST POINTS BACK TO OLD LAST, FORWARD
				; TO ZERO
	HRRM	J,JBTFIT(T1)	;OLD LAST POINTS FORWARD TO NEW LAST
	HRLM	J,JBTFIT	;THIS IS NOW LAST.
	POPJ	P,		;RETURN.

REMSIL:	MOVE	T1,JBTFIT(J)	;GET LAST,,NEXT
	HLRZ	T2,T1		;GET LAST IN T2
	HRLM	T2,JBTFIT(T1)	;NEXT POINTS BACK TO LAST
	HRRM	T1,JBTFIT(T2)	;AST POINTS FORWARD TO NEXT
	CAMN	J,BIGFIT	;IF WE REMOVE BIGFIT FROM SIL FOR ANY
	SETZM	BIGFIT		;REASON, ALLOW SWAPPER TO CONSIDER NEW ONE
	POPJ	P,		;RETURN

;ROUTINE TO SET IN CORE TIME ACCORDING TO NUMBER OF PAGES
; SWAPPED IN SUPPLIED AS ARG IN T1.  PRESERVES ALL BUT T1.

SETIPT:	IMUL	T1,PROT
	ADD	T1,PROT0
	CAMLE	T1,MXPROT
	MOVE	T1,MXPROT	;UPPER LIMIT ON FUNCTION. /AA
	PUSH	P,T2		;SAVE T2
	HLRE	T2,JBTICT(J)	;GET ICPT TIME
	CAMGE	T2,T1		;DON'T SET IT BELOW WHAT IT IS
	TRACE(8,<HRLM	T1,JBTICT(J)>)	;OK, SET IT.
	POP	P,T2		;RESTORE T2
	POPJ	P,
;ROUTINE TO SAVE LOTS OF ACS. CALLED BY JSP T4,SWPSAV.
; CALLED IN SWPIO, SWPRES WHERE LOTS OF ACS ARE NEEDED.

SWPSAV:	MOVE	T1,P		;GET COPY OF P
	ADD	P,[^D10,,^D10]	;SAVE 10 ACS. ADVANCE STACK POINTER
	EQV	T1,P		;SIGN BIT MUST NOT CHANGE
	SKIPL	T1		;CHECK FOR OVERFLOW
	STOPCD			;THERE WAS.
	MOVSI	T1,J		;AC TO START XFER FROM
	HRRI	T1,-^D9(P)	;ADDRESS TO SAVE
	BLT	T1,-^D9+U-J(P)	;SAVE THRU AC U
	MOVSI	T1,W		;START FROM W NOW
	HRRI	T1,-^D9+U-J+1(P)	;ADDRESS TO START XFER TO
	BLT	T1,(P)		;SAVE THE REST
	PUSHJ	P,(T4)		;CALL THE CALLER
	  SKIPA
	AOS	-^D10(P)	;FOR SKIP RETURNS
	MOVEI	T1,J		;RESTORE TO J
	HRLI	T1,-^D9(P)	;FROM STACK
	BLT	T1,U		;THRU U
	MOVEI	T1,W		;START WITH W
	HRLI	T1,-^D9+U-J+1(P)	;WHERE W IS
	BLT	T1,P4		;THRU P4
	MOVE	T1,P		;GET COPY OF POINTER
	SUB	P,[^D10,,^D10]	;BACK IT UP
	EQV	T1,P		;MAKE SURE SIGN BIT DIDN'T CHANGE
	SKIPL	T1		;DID IT/
	STOPCD			;YES, PDL OVERFLOW THEN.
	POPJ	P,		;AND RETURN TO CALLER'S CALLER.
COMMENT ;@@SUBROUTINE MPSUPS
@@PURPOSE MAKE LMAP ADDRESSABLE THRU UPT WHEN THE LMAP'S
VIRTUAL ADDRESSES %UPT+X DO NOT POINT TO THEMSELVES YET.
CALLED JUST AFTER ALL CONTEXT PAGES ARE BROUGHT IN.
@@ENTRY J CONTAINS JOB NUMBER
@@ACCUM T1-T4, PG, P2
@@GLOBAL
@@EXIT J CONTAINS JOB NUMBER, EXEC ADDRESS %UPS CONTAINS
LMAP AND UPT. %UPT ACCESSES ARE NOT LIMITED TO %UPT+777, I.E.
THE LMAP TAKES UP MORE THAN ONE PAGE AND THIS ROUTINE SETS UP
ALL REQUIRED PAGES IN JOB'S CONTEXT PAGES.
@@RESTRICTIONS 
@@CALLS
@@FUNCTION FOR EACH OF THE JOB'S CONTEXT PAGES, FIND DISK ADDRESS
, FIND PHYSICAL CORE ADDRESS OF THE DISK ADDRESS IN THE CHT,
CRASH IF ITS NOT THERE. OTHERWISE, SETUP THE APPROPRIATE
EXEC MAP SLOT WITH THE "A" AND "W" BITS ON, AND THE
PHYSICAL CORE ADDRESS.
WHEN ALL MAP SLOTS ARE SETUP, DO DATAO PAG, TO CLEAR THE
ASSOCIATIVE PAGING MEMORY AND RETURN. DO NOT CHECK UPSJOB
AS CONTEXT PAGES AREN'T AROUND YET, AND DO NOT SET IT UP SINCE
WE ARE NOT SURE THEY WILL STICK AROUND AFTER
THIS CALL. INSTEAD, CLEAR UPSJOB SO NO ONE WILL GET CONFUSED.
IF CALLER IS SURE THEY WILL STICK AROUND, HE CAN SETUP UPSJOB
HIMSELF.
@@ ;

EXTERNAL UPSJOB,SAVE1

MPSUPS:	JSP	T4,SAVE1	;SAVE P1 FOR BYTE POINTER,
				; P2 IS AOBJN POINTER
	MOVE	P1,EPYPSM	;  [EPTPTR(%UPS.N-1)]
	MOVSI	P2,-NCTXPG	;-VE NUMBER OF CONTEXT PAGES

MPSUP1:	LDB	T2,CTXTAB(P2)	;GET NEXT CONTEXT PAGE DP
	PUSHJ	P,SRCCHT	;GET ITS CORE PAGE ADDRESS
	  STOPCD		;HAS TO BE THERE
	TRO	PG,PGE.A!PGE.W!PGE.C	;MAKE IT ACCESSIBLE
	IDPB	PG,P1		;PUT IT INTO RIGHT SLOT
	AOBJN	P2,MPSUP1	;AND STEP TO NEXT CONTEXT PAGE

	MOVEI	P2,<NCTXPG-1>*1000
MPSUP2:	CLRPTO	%UPS(P2)
	SUBI	P2,1000
	JUMPGE	P2,MPSUP2
	SETZM	UPSJOB		;NO ONE BUT CALLER SHOULD BELIEVE %UPS
				;UNLESS CALLER SETS UP UPSJOB.
	POPJ	P,		;AND RETURN
;HERE FROM CONTEXT PAGE ACTIVATE IF THERE WAS AN ERROR
; READING IN THE CONTEXT PAGES. AN OUTPUT ERROR FOR CONTEXT
; PAGES WILL SHOW UP WHEN THEY ARE NEXT SWAPPED IN, SO WE
; GET HERE FOR BOTH INPUT AND OUTPUT ERRORS.

EXTERNAL ERRSWP,PCBSWN,HNGMON,CBSWER,SWPERC,MONJOB

SWECTX:	LDB	T1,JBYMWS	;GET MWS SIZE WE WERE
	MOVNS	T1		;AND DECREMENT SIPTOT
	ADDM	T1,SIPTOT
	MOVSI	T1,CTXSWE	;CLEAR THIS SO DON'T GO THRU HERE AGAIN NEXT TIME IF NO ERROR
	ANDCAM	T1,JBTCTX(J)	;AND LEAVE RH ZERO FOR CLEARING MWS IMIT.
	DPB	T1,JBYMWS	;SO DON'T DECREMENT SIPTOT AGAIN.
	MOVSI	T1,1		;COUNT CONTEXT PAGE SWAP ERROR
	ADDM	T1,SWPERC
	PUSHJ	P,PCBSWN	;CLEAN UP PCBS
	PUSHJ	P,SDVCLN	;CLEAN UP DEVICES
	PUSHJ	P,CBSWER	;AND CLUB STUFF.
	MOVEI	T2,ERRSWP	;ADDRESS OF MONITOR JOB TO RUN
	PUSHJ	P,MONJOB	;START IT UP THERE.
	JRST	SWERTN		;AND GO BACK TO MAIN CODE.

; CLEAN UP DEVICES AND DISK IN PROGRESS

EXTERNAL DEVLST,JBTABT,PJOBN,RELEA9

SDVCLN:	
	SKIPE T1,JBTABT(J)
	PUSHJ P,(T1)		;CALL ABORT ROUTINE IF ANY
	HLRZ F,DEVLST
SWPER5:	LDB T1,PJOBN		;DEVICE BELONG TO THIS JOB?
	CAMN T1,J
	PUSHJ P,RELEA9		;YES. RELEASE DEVICE
	HLRZ F,DEVSER(F)	;NEXT DEVICE
	JUMPN F,SWPER5		;LOOP THROUGH ALL DEVICES
	MOVEI F,AVLNUM-MINQ
	XCT CHKSWT+MINQ(F)	;RELEASE SHARABLE RESOURCE IF ANY
	SOJGE F,.-1
	POPJ P,
	END
   Nm