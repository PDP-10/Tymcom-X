TITLE COMMON - MONITOR COMMON DATA AREA AND CONFIGURATION DEFINITION - V534
SUBTTL PART 3 COMMON.MAC - T. HASTINGS/CMF/TL/CHW/AF/TW/PFC/RCC/PH   TS  29 OCT 70
XP VCOMMN,534
				;PUT VERSION NUMBER IN GLOB AND LOADER STORAGE MAP

REPEAT 0, <
;THE COMMON SUBPROGRAM CONSISTS OF 3 FILES ASSEMBLED TOGETHER AS ONE SUBPROGRAM:
  1. S.MAC - THE USUAL SYSTEM SYMBOL DEFINITIONS ASSEMBLED WITH
	EVERY MONITOR SUBPROGRAM
  2. CONFIG.MAC - THE CONFIGURATION DEFINITION FILE GENERATED BY THE
	CONFIGURATION PROGRAM (MONGEN) OR BY AN EDITOR (SEE ABOVE)
  3. COMMON.MAC - THE REST OF THIS PROGRAM WHICH IS THE SAME SOURCE FOR
	ALL CONFIGURATIONS.  HOWEVER, THE ASSEMBLIES ARE CONDITIONED BY
	SYMBOLS AND MACROS DEFINED IN 2.

	THE FOLLOWING SYMBOLS AND TABLES ARE GENERATED BELOW:

	A. MONITOR STARTUP LOCATIONS (140-147), HENCE LOAD THIS FIRST.
	B. JOB TABLES - LENGTH DEPENDENT ON MAXIMUM NUMBER OF JOBS ALLOWED
	C. ALL VARIABLE STORAGE NOT ASSOCIATED WITH A PARTICULAR DEVICE
	D. COMMON SUBROUTINE RETURNS
	E. COMMON BYTE POINTERS
	F. TABLE OF SERVICE ROUTINE INTERRUPT LOCS TO BE LINKED BY ONCE ONLY CODE
	G. TABLE OF DEVICE DATA BLOCK ADDRESSES AND NUMBER TO BE USED BY ONCE TO
		LINK THEM TOGETHER AND GENERATE MULTIPLE COPIES.
        H. ASSIGNMENT OF PI CHANNELS
	I. PI CHANNEL SAVE AND RESTORE ROUTINES
	J. M TRAP LOCATIONS 40/41, 60/61
	K. SYSTEM CRASH STOP CONI'S.
	L. CONFIGURATION DEPENDENT CODE FOR CERTAIN DEVICES AND THE SWAPPER.

LEVEL D DISK SERVICE PARAMETERS:

  ALL SYMBOLS AND LOCATIONS ARE IN A SEPARATE FILE CALLED
  COMMOD.MAC WHICH IS ALSO ASSEMBLED WITH S AND CONFIG (BUT NOT WITH FEATURS FILES).
  THE SEPARATE FILE IS FOR TWO REASONS:
    1.  ANTICIPATING MULTIPROCESSING SYSTEMS WHICH SHARE DISKS AND 1 16K MEMORY
        (THE DATA MUST BE IN THE COMMON MEMORY)
    2.  ELIMINATE THE NEED TO ASSEMBLE COMMOD IF NOT A DISK SYSTEM
        (COMMOD.MAC TAKES LOTS OF CORE FOR ITS COMPLICATED MACROS)
  HOWEVER, THE TWO FILES MAY BE ASSEMBLED TOGETHER IF DESIRED.
  TO DO THIS, COMMON.MAC MUST PRECEED COMMOD.MAC, AND SYMBOL FTCMBTH MUST BE DEFINED.
  THUS, A COMMAND STRING WOULD BE

	.R MACRO
	*COMMON,COMMON/C_TTY:,DSK:S,CONFIG,COMMON,COMMOD
	FTCMBTH==0
	^Z

	END OF PASS 1

	FTCMBTH==0
	^Z
>
;THE FOLLOWING STANDARD SYMBOLS CAN BE SUPERCEDED BY A CUSTOMER HAVING
; PREVIOUSLY DEFINED THEM ON THE CONFIG.MAC FILE


IFNDEF LISTSN, <XP LISTSN,1>	;FORCE THE S.MAC FILE TO BE LISTED ON THE FRONT OF
				; COMMON (UNLESS LISTSN DEFINED TO BE 0 WITH MONGEN)

IFNDEF APRSN, <XP APRSN,0>	;SERIAL NUMBER OF ARITHMETIC PROCESSOR

				;STANDARD MAG TAPE DENSITY
IFNDEF STDENS, <XP STDENS,3>	;STANDARD == ODD PARITY ("BINARY" MODE) AT 800 BPI
				;STDENS,D
				;D=1 (200 BPI), OR D=2 (556 BPI), OR D=3 (800 BPI)

				;NUMBER OF CLOCK TICKS (JIFFIES) PER SECOND

				;NUMBER OF NANO-SECONDS PER MEMORY CYCLE
IFNDEF NSPMEM, <XP NSPMEM,^D1000>	;STANDARD == 1000 NANO-SECONDS PER MEMORY CYCLE



				;NUMBER OF TIMES TO TRY ON DECTAPE ERRORS
IFNDEF DTTRY, <XP DTTRY,4>	;STANDARD == 4 TRIES

				;SIZE OF MAGTAPE RECORDS (DATA WORDS IN BUFFER)
IFNDEF MTSIZ, <XP MTSIZ,^D128>	;STANDARD == 128 WORDS PER BUFFER

				;SIZE OF LPT BUFFER (NUMBER OF DATA WORDS+2)
IFNDEF LPTSIZ, <XP LPTSIZ,^D24+2>	;STANDARD == 24 WORDS PER LPT BUFFER

				;MAXIMUM NUMBER OF CONSECUTIVE DECTAPE BLOCKS TO BE
				; SEARCHED BEFORE RESCHEDULING IF ANOTHER JOB IS
				; WAITING TO USE THE DECTAPE CONTROL.
IFNDEF BLKQNT, <XP BLKQNT,^D50>	;STANDARD == 50 DECTAPE BLOCKS SEARCHED (3 SECS.)

IFNDEF M.SQTA,<XP M.SQTA,^D8> ;STANDARD == ^D8 PAGE TO SWAP IN AT, LIMIT SWAP RATE. (obsolete /AAA)
				; A TIME.
IFNDEF M.IQTA,<XP M.IQTA,0>;STANDARD == ONE I/O PGE FOR EVERY FOURTH JOB. (never implemented /AAA)
				; (ZERO UNTIL BUG IS FIXED)
IFNDEF M.SBSZ,<XP M.SBSZ,0>	;SNOOP BUFFER SIZE. STANDARD=NONE

IFNDEF AGESIZ,<XP AGESIZ,^D3>	;STANDARD = 3 BITS PER AGES CELL

IFNDEF SHRFPG,<XP SHRFPG,0>	;EXPECTED SHARED FILE PAGES..SET
				;NON-ZERO IN CONFIG FOR SYSTEMS WHOSE
				;LOADS INCLUDE ALOT OF FILE PAGE SHARING. /AAA

IFNDEF FHIN,<XP FHIN,^D22>	;STANDARD = 22 FRAME HANDLE SLOTS PER FRAME
IFNDEF OPNFPF,<XP OPNFPF,^D10>	;STANDARD = 10 OPN FILES/FRAME AVERAGE ESTIMATE
FHD1==DSK
DPC1==DPC
LPT2==234
LP0==LPT
LP1==LPT2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	DEFINE SYSDEV
<	SIXBIT	"DSK">
	DEFINE SYSNAM
<IFNDEF SYSX0L,<EXTERNAL SYSX0L,SYSX0R,SYSX1L,SYSX1R,SYSX2L
	EXTERNAL SYSX2R,SYSX3L,SYSX3R,SYSX4L,SYSX4R>
	SYSX0L,,SYSX0R
	SYSX1L,,SYSX1R
	SYSX2L,,SYSX2R
	SYSX3L,,SYSX3R
	SYSX4L,,SYSX4R>

	DEFINE SYSDAT
<IFNDEF SYSX5L,<EXTERNAL SYSX5L,SYSX5R,SYSX6L,SYSX6R>
	SYSX5L,,SYSX5R
	SYSX6L,,SYSX6R>

IFNDEF DSKN,<XP DSKN,1>	;Assume (for the sake of argument) that
			;there are disk drives on this system.
XP PMEMSZ,^D512
IFCPU(<KI,KL>),<
  IFNDEF CHNN,<XP CHNN,0>
  IFNDEF SAXN,<XP SAXN,1>
  > ; End IFCPU(<KI,KL>)
IFCPU(<KS,F3>),<
  IFNDEF CHNN,<XP CHNN,1>
  IFNDEF SAXN,<XP SAXN,0>
  > ; End IFCPU(<KS,F3>)

IFNCPU(F3),<IFNDEF APXN,<XP APXN,0>>
IFCPU(F3),<IFNDEF APXN,<XP APXN,1>>

IFNDEF RA10N,<XP RA10N,0>
IFNDEF RP10N,<XP RP10N,0>
IFNDEF RD10N,<XP RD10N,0>

IFNCPU(<KS,F3>),<
  IFNDEF MAGN,<XP MAGN,0>
  IFNDEF MAGUN,<XP MAGUN,0>
  > ; End IFNCPU(<KS,F3>)
IFCPU(<KS,F3>),<
  IFNDEF MAGN,<XP MAGN,1>
  IFNDEF MAGUN,<XP MAGUN,1>
  > ; End IFCPU(<KS,F3>)

IFCPU(KS),<
  IFNDEF LPTN,<XP LPTN,1>	;On 2020, assume LPT unless told otherwise
  IFE LPTN,<XP LPRUN,0>		;If no device, # units = zip
  IFG LPTN,<XP LPRUN,1		;# of units - current max. of one
	XP LPRVEC,754> ;End IFG LPTN
  > ;End IFCPU(KS)
IFCPU(F3),<IFNDEF LPTN,<XP LPTN,0>>
IFCPU(<KI,KL>),<IFNDEF LPTN,<XP LPTN,1>>

IFCPU(KI),<
  IFNDEF PTRN,<PTRN==1>
  IFNDEF PTPN,<XP PTPN,1> >
IFNCPU(KI),<
  IFNDEF PTRN,<PTRN==0>		;NOT GLOBAL BECAUSE OF DSKSER USE
  IFNDEF PTPN,<XP PTPN,0> >
IFNDEF PLTN,<XP PLTN,0>
IFNDEF CDRN,<XP CDRN,0>
IFNDEF CR10N,<XP CR10N,0>

IFNDEF NUMPRT,<XP NUMPRT,0>
IFNDEF COREN,<XP COREN,^D8>

COMMENT ! FREE CORE ALLOCATION CALCULATIONS.  ALLOCATE FOR
	DSK DDB'S, BLOCK IO BUFFERS, SPT SECTIONS, ETC.
!

INTERNAL BIOCOR
EXTERNAL DDBCOR			;NUMBER FREECORE BLOCKS PER DDB
EXTERNAL SPTNME,SPTSIZ
XP CORSIZ,4		;NO. OF WORDS IN MONITOR FREE CORE BLOCKS
XP BIOSIZ,<^D6+^D100>	;BLOCK I/O BUFFER SIZE
			;(HEADER + DATA AREA)
XP BIONUM,^D10		;NO. OF PORTS CONFIGURED FOR BLOCK I/O
BIOCOR==<BIOSIZ+CORSIZ-1>/CORSIZ  ;NO. OF 4WD BLOCKS FOR BIO BUFFER.
IF2,<
IFDEF FCWDS,<
DDBWDS==OPNFPF*DDBCOR*CORSIZ	;ESTIMATE OPNFPF DDB'S PER FRAME
EFCWDS==JOBN*DDBWDS
IFL JOBN-6,<EFCWDS==6*DDBWDS>	;PUT FLOOR UNDER FCWDS IF JOBN.LT.6
RMTWDS==NUMPRT*^D65		;CORE FOR REMOTE BASE
BIOWDS==<BIOSIZ/2>*BIONUM	;FREECORE NEEDED FOR BLOCK IO BUFFERS
SPTWDS==<SHRFPG/SPTNME>*SPTSIZ	;(VERY) ROUGH EST. OF SPT FREECORE
EFCWDS==EFCWDS+BIOWDS+SPTWDS+RMTWDS
;IFL FCWDS-EFCWDS,<PRINTX FCWDS IS SMALLER THAN THE ESTIMATE EFCWDS
;>
>;END IFDEF
IFNDEF FCWDS,<FCWDS==0
>;END IFNDEF
>;END IF2

IFNDEF INDPPN,<XP INDPPN,777777>	;NON-ZERO IF CUSTOMER WANTS PROGRAMMER NOS
				; IN PROJECT X TO BE INDEPENDENT OF THOSE IN PROJECT Y

;NOTE--IN ORDER TO RESERVE PI-CHANNELS FOR
;NON-STANDARD USAGE, FOR EACH CHANNEL (SAY N)
;DEFINE SYMBOL UNIQN==1 VIA CONFIG.  FOR
;EXAMPLE, TO RESERVE CHANNEL 4, DEFINE
;UNIQ4==1.


;DEFINE PARAMETERS THAT SPECIFY SIZE OF CORTAB, NUMBER OF BITS PER
;ENTRY, AND BYTE POINTERS FOR CORE ALLOCATION ROUTINES

INTERNAL CTNMCI,CTNBSA,CTNBPW

CTNBPE==1	;NUMBER OF BITS PER ENTRY IN CORTAB
		;MUST EVENLY DIVIDE 36 AND BE 1 OR A POWER OF TWO
CTNMCI==1	;PUT THIS IN CORTAB TO INDICATE A BLOCK IN USE BY MONITOR OR NXM

CTNBPW==^D36/CTNBPE
		;NUMBER OF BYTES/WORD

Z1==0
Z2==CTNBPE

	XLIST
REPEAT Z2/2,<
Z2==Z2/2
IFN Z2,<Z1==Z1+1>
>
	LIST

CTNBSA==Z1	;THE LARGEST POWER OF TWO IN CTNBPE

DEFINE NMCLC (SET,DE,X,U)
<$U==0
IRP U,<IFE X-$U,<SET==DE'U'UN>
	$U=$U+1>>

DEFINE CHNCLC (DE,NUM)
<$UU==0
	REPEAT NUM,<
	NMCLC (XX,DE,\$UU,<A,B,C,D,E,F,G>)
	IFN XX,<ALLKON==ALLKON+1>
	$UU==$UU+1>>

ALLKON==0
	CHNCLC (FH,RD10N)
	CHNCLC (DP,RP10N)
	CHNCLC (MD,RA10N)


;PERFORM TRANSLATION FROM HARDWARE TO SOFTWARE DESIGNATION
; FOR ALL DISK SYMBOLS

	FHDN==RD10N
	DPCN==RP10N
	MDFN==RA10N

	LOC 137
	CONFIG		;ALWAYS A POINTER TO CONFIGURATION
	RELOC


;SYSTEM INITIALIZATION DISPATCH TABLE, STARTING AT LOCATION 140
;THIS SUBROUTINE MUST BE LOADED FIRST
;ROUTINE "ONCE" IS ONCE ONLY CODE. IT CONVERTS THE DATE
;AND SETS UP I/O SERVICE CHAIN,

EXTERNAL ONCGO
INTERNAL SYSDSP,SYSDDT,SYSINA

	COMORG==140		;ORIGIN OF COMMON IS 140
	LOC COMORG		;MAKE LISTING BE SAME AS LOADING SO IT WILL BE EASY
				; TO EXAMINE SYSTEM LOCATIONS WITH CONSOLE SWITCHES
				; WITHOUT NEEDING A STORAGE MAP

SYSDSP: JRST ONCGO	;(140) INITIALIZE SYSTEM VARIABLES ONCE ONLY
SYSDDT:	
;IFG DDTN, <		;(141) IF EXEC DDT IS LOADED.....
EXTERNAL PATSYM,SYSZRO
	JRST PATSYM		;PATCH SYMBOL TABLE POINTER, THEN ENTER EXEC DDT
;>
;IFE DDTN, <
;	HALT .		;(141) HALT IF EXEC DDT NOT LOADED.
;>
	JRST SYSZRO	;(142) ONCE CODE TO ZAP EDDT & SYMBOL TABLE.
SYSINA:	HALT .		;{143) [OBSOLETE /AAA]INITIALIZE SYSTEM VARIABLES ALWAYS
	HALT .		;(144) ERECOVERY
	HALT .		;(145) DO ONCE ONLY CODE OVER AGAIN
	HALT .		;(146) [OBSOLETE /AAA] IN CASE NO CONSOLE TTY..
	JSR CRS147	;(147) FOR USE WHEN DEPOSIT-IN-30 WILL NOT
				;CRASH SYSTEM (CHANNEL 1 NOT ENABLED, OR
				;APR WAS FROZEN, HAD TO BE RESET.

;MACRO TO SET UP BUFFER SPACE EITHER BEFORE OR AFTER THE PAGE
;TABLES, WHICHEVER WORKS OUT BETTER

	DEFINE MAKBUF (NAM,SIZ,LOC)
<IF1,<IFNDEF NAM,<IFGE LOC-<.+SIZ>,<NAM:	BLOCK SIZ>>>
IF2,<IFE <.-NAM>,<NAM:	BLOCK SIZ>>>

	DEFINE BUFS (LOC)
<	MAKBUF (IRING,1_SIZIRG,LOC)
	MAKBUF (ORING,1_SIZORG,LOC)
IFN NUMPRT,<
	MAKBUF (QTOST,^D48,LOC)
	MAKBUF(RMTDDP,NUMPRT,LOC)
	MAKBUF (QPRTST,NUMPRT,LOC)
>
>

;MACROS TO GENERATE KS10 VFU LOADING DATA.
;CODE COPIED FROM T10 MODULE LP2SER
DEFINE MOD(A,B),<A-<<A/B>*B>>
..BC==0
..B==0
DEFINE OUTBYT(C),<
..C==C
..BC==..BC+1
IFE ..BC-1,<..C==<..C&377>_<^D18>>
IFE ..BC-2,<..C==<..C&377>_<^D26>>
IFE ..BC-3,<..C==<..C&377>>
IFE ..BC-4,<..C==<..C&377>_<^D8>>
..B==..C!..B
IFE ..BC-4,<EXP ..B
	    ..BC==0
	    ..B==0>
>;OUTBYT MACRO DEFINITION
DEFINE LASBYT,<
IFN ..B,<EXP ..B
>
>;LASBYT MACRO DEFINITION
DEFINE VFUBIT(LINE),<
..BT==0
IFE LINE,<..BT==..BT!1>		;;LINE 0 GETS CH. 1
IFE MOD(LINE,36),<..BT==..BT!2>	;;EVERY 30 LINES GET CH. 2
IFE MOD(LINE,4),<..BT==..BT!4>	;;EVERY 4TH LINE GETS CH. 3
IFE MOD(LINE,3),<..BT==..BT!10>	;;EVERY 3RD LINE GETS CH. 4
IFE MOD(LINE,12),<..BT==..BT!40>	;;EVERY 10TH LINE GETS CH. 6
IFLE LINE-<LPTLPP-1>,<..BT==..BT!20>	;;ALL LINES.LE.LINES/PAGE GET CH. 5
IFGE LINE-LPTLPP,<..BT==20>	;;LINES ABOVE LINES/PAGE GET ONLY CH. 5
OUTBYT(..BT)
..BT==0
IFE MOD(LINE,24),<..BT==..BT!1>	;;EVERY 20TH LINE GETS CH. 7
IFLE LINE-<LPTLPP-1>,<..BT==..BT!2>	;;LINES 0-LINES/PAGE GET CH. 8
IFE LINE-<LPTLPP-1>,<..BT==..BT!40>	;;LAST LINE ON PAGE GETS CH. 12
IFGE LINE-LPTLPP,<..BT==0>	;;LINES ABOVE LAST GET NOTHING
OUTBYT(..BT)
>;VFUBIT MACRO DEFINITION

IFN NUMPRT,<
XP MNUMPT,-NUMPRT
INTERNAL QPRTST,RMTDDP,QTOST,LIVWRD,QFRMST

XP QTOND,<QTOST+^D23>
XP QFRMST,<QTOST+^D24>
XP QFRMND,<QTOST+^D47>
XP QPRTND,<QPRTST+NUMPRT-1>
>

XP SIZIRG,7		;SIZE OF INPUT RING (AS POWER OF 2)
XP SIZORG,10		;SIZE OF OUTPUT RING (AS POWER OF 2)
IFNCPU (F3),<

	LOC 150		;GENERATE DATA LOCS FOR 620

KEY620:	0		;FILLED WITH 6337510626 WHEN SYS UP
	0		;ALARM CELL
DMP620:	0		;PUT IN LOC FOR 620 TO DUMP CORE
	IRING_4		;LOC OF INPUT RING (IN 620 FORMAT)
	1_<SIZIRG+4>	;SIZE OF INPUT RING
IRPPDP:	0		;PDP-10 POINTER TO INPUT RING
IRP620:	0		;620 POINTER TO INPUT RING
	ORING_4		;LOC OF OUTPUT RING FOR 620
	1_<SIZORG+4>	;SIZE OF OUTPUT RING
ORPPDP:	0		;PDP-10 POINTER TO OUTPUT RING
ORP620:	0		;620 POINTER TO OUTPUT RING
D620FN:	-1		;SET 0 BY 620 WHEN 10 COMES UP, NON-0 WHEN
			;620 FINISHED DUMPING
LIVWRD:	BLOCK 1
IFN NUMPRT,<QTOST_4>
IFE NUMPRT,<0>
>;END IFNCPU (F3)

	LOC <.+1>&777776	;GET TO EVEN LOC FOR CHANNEL COMMAND WORDS

LOCOCW:	BLOCK ALLKON*2

IFNCPU (F3),<
IFN SAXN,<	BUFS (300)
	LOC 300
SAXBAS:	BLOCK SAXN*^D16
INTERNAL SAXBAS>
	BUFS(1000)
>;END IFNCPU (F3)

	LOC 1000

IFCPU (KI),<XP NULUPL,1000>		;KI ONLY NEEDS ONE PAGE FOR NULL UPT
IFNCPU (KI),<XP NULUPL,2000>		;KLKS NEEDS MORE, MORE STUFF RESERVED FOR HARDWARE.
EPT:	BLOCK 1000

IFCPU(F3),<;GENERATE F3 BASE LOCATIONS
IFN SIZIRG-7,<PRINTX F3 INPUT RING SIZE MUST BE 200 OCTAL
QQQQQQ>
IFN SIZORG-10,<PRINTX F3 OUTPUT RING SIZE MUST BE 400 OCTAL
QQQQQQ>

KEY620:	0
BBORQ:	0		;BLOCK I/O REQUEST STORAGE WORD FOR UCODE
BBOIO:	0		;BLOCK I/O IO WORD FOR MICROCODE
	0
	0
IRPPDP:	0		;2005 HOST IRING POINTER
IRP620:	0		;2006 BASE IRING POINTER
	0
	0
ORPPDP:	0		;HOST OUTPUT RING POINTER
ORP620:	0		;BASE OUTPUT RING POINTER
	LOC 2200	;FIXED BY F3 MICROCODE
IRING:	BLOCK	200
ORING:	BLOCK	400
	LOC 3000
>;END IFCPU (F3)
UPT:	BLOCK NULUPL

IFCPU (KS),< IFG LPTN,<
;PAGE ALIGNED DATA USED BY KS10 LPT DRIVER.
;THIS DATA MUST ALL FIT INTO ONE PAGE OR LPTSER MUST
; BE CHANGED TO USE MORE THAN ONE PAGING RAM LOCATION
IFNDEF LPTLPP,<LPTLPP==^D60>	;default lines/page is 60
IFNDEF LPTFS,<LPTFS==^D66>	;default form size is 66
NXDLPT::EXP LPRUN		;IF 0 THEN LPT IS A NON-EXISTANT DEVICE
LPVLPT::VLDATL,,<<.&777>*4>+4	;output pointer to load DAVFUQ
	XWD 356,37437		;start code,,channels 1-11
	REPEAT <<LPTFS-4>/2>,<	;this sets up most of the lines
	XWD 37037,37037		;generate 2 DAVFU lines w/ ch2-ch11
	>;REPEAT
	IFE MOD(LPTFS,2),<XWD 37037,37077
			  XWD 167400,0>;for even form sizes
	IFN MOD(LPTFS,2),<XWD 37077,16740>;for odd form sizes
VLDATL==.-LPVLPT-1
	BLOCK ^D46-VLDATL	;leave room for form sizes up to ~88/GL
LPCFPT::1,,<<.&777>*4>+4
	BYTE (2) 0 (8) 14,15
NEWTOF::1,,<<.&777>*4>+4	;new top of form /GL
	BYTE (2) 0 (8) 357,0	;stop byte /GL
LPTEPT::LTEDAT,,<<.&777>*4>+4
REPEAT ^D16,<BYTE (2) 0 (8) "8","8" (2) 0 (8) "8","8">
	BYTE (2) 0 (8) 12,15
LTEDAT==.-LPTEPT-1

IFN LPTN-1,<PRINTX LPT BUFFER ALLOCTION DONE FOR ONLY ONE PRINTER.>
LPBSIZ==40
LPTBUF:	BLOCK <LPBSIZ*5>/4+1



>>;IFCPU KS, IFG LPTN

XP EPT.PN,<EPT_-9>
XP UPT.PN,<UPT_-9>


IFNCPU (KI),<XP EPTEBR,EPTFSL>		;WHERE TO DO CONO PAG FROM.

IFCPU (F3),<XP EPTACB,100>		;PLACE FOR F3 TO STORE NON-CURRENT AC BLOCKS

;LMAP AND UPT GENERATION

%UPT.V==UPTFSL		;START OF UPT LOCATIONS RELATIVE TO %UPT

;LMAP AND UPT MACROS
	SALL		;MAKE COMMENTS COME OUT IN SPITE OF MACRO BUG.

DEFINE UVAR(LABEL)<UARRAY(LABEL,1)>

DEFINE UARRAY(LABEL,SIZE)<
		XP LABEL,%UPT.V
		%UPT.V==%UPT.V+'SIZE
>;END UARRAY MACRO DEFINITION


;DEFINE UPT LOCATIONS
XP EPLLEN,176	;LENGTH EXEC PDL 

;THE FOLLOWING LOCATIONS MUST BE IN THE FIRST ^D512 WORDS

	XP XACSTL,4	;LENGTH OF EXEC AC STACK
UARRAY(UPTAC0,<<20*XACSTL>+1>)	;MUST BE FIRST
	IFN UPTAC0&17,<PRINTX UPTAC0 MUST BE ON 20 WORD BOUNDARY>
				; XTRA WD IS FOR STACK POINTER OVERFLOW CASE
UVAR(UPTSTS)	;JOB IN CORE STATUS BITS
			;18-35	STARTING ADDRESS IF STRTAD SET
	XP XPNCOR,1	;17	CORE NEEDS TO BE EXPANDED
	XP STRTAD,2	;16	RIGHT HALF CONTAINS A STARTING ADDRESS
	XP UPSCLK,4	;15	CLOCK SHOULD BE ON
	XP SAVCHG,10	;14	CHARGES ARE SAVED IN UPT
	XP REC.WR,20	;13	WRITE STREAM ACCTG RECORD NEXT EXIT
	XP LSAREC,40	;12	LOCAL STREAM ACCTG DONE
	XP SG.SWR,100	;11	CURRENT HISEG LOADED FROM .SWR FILE
	XP UPNPSR,^D10	;8-10	(POS) PENDING STREAM REC TYPE
	XP UPSPSR,^D3	;	(SIZ) SEE START CMD AND USRXIT
	XP UPSSWE,2000	;7	JOB GOT SWAP ERROR FOR USER PAGE
			;	WHILE IT OWNED DISK RESOURCE, AND
			;	JBTABT NOT SET UP. UTRP SET WITH
			;	THIS BIT SO USRXIT SEES IT.
	XP UPSABK,4000	;6	ADDRESS BREAK DURING UUO.
	XP STRTCL,10000	;5	INCREMENT START ADDRESS BEFORE USING IT.
			;0-4	(UNUSED)

 UPYPSR::POINT UPSPSR,%UPT+UPTSTS,UPNPSR ;POINTER TO PENDING STREAM REC TYPE
 USYPSR::POINT UPSPSR,%UPS+UPTSTS,UPNPSR ; One for %UPS
 UXYPSR::POINT UPSPSR,%UPX+UPTSTS,UPNPSR ; One for %UPX

UVAR(UPTJOB)		;HAS JOB NUMBER OWNING THIS UPT
UVAR(UPTPC)		;HAS THE JOB'S PC WHEN NEXT SET TO RUN
UVAR(UPTACP)		;STACK POINTER TO SAVED EXEC AC'S
UVAR(UPTLDC)		;COUNT OF NUMBER OF LMAP SLOTS KEPT IN ACS FROM THIS UPT
UVAR(UPTABK)		;ADDRESS BREAK WORD.
UARRAY(UPTPDL,EPLLEN)	;SYSTEM UUO PDL FOR CURRENT JOB

IFG <%UPT.V-NULUPL>,<PRINTX EPLLEN TOO LARGE> ;THE ABOVE UPT LOCATIONS
				;MUST FIT INTO THE NULL JOB'S UPT, WHICH
				; IS SHORTER THAN NORMAL ONES.
	XP NUMCHN,^D48		;MAX NUMBER OF IO CHANNELS
	XP MAXCHN,<NUMCHN-1>
UARRAY(UPTJDA,NUMCHN)	;RH==DDB ADDRESSES (JOB DEV ASSIGNMENTS)
			;LH= VARIOUS STATUS BITS FOR CHANNEL:
			;(INITB,LOOKB,ICLOSB..ETC SEE S.MAC)
UARRAY(UPTSIM,NUMCHN)	;SIMULATED BUFF/DUMP MODE
			;IO DATABASE. LH=SEQUENCE STAMP. RH=
			;SIMIO STATUS BITS+PAGE NUMBER FIELD
UARRAY(UPTPOS,NUMCHN)	;BLOCK POSITION IN (DSK) FILE ON THIS CHANNEL
;UARRAY(UPTPCN,^D32)	;DEBUG. PAGE CHANNEL NUMBER SIMIO
UVAR(UPTPBM)		;PAGE BIT MAP. BITS 0-31 SET IF PER-PROCESS
			;PGS 340-377 USED FOR SIMIO
UVAR(UPTIOC)	;SIMIO IO COUNT, FOR SEQ. STAMP
UARRAY(UPTXAC,20)	;EXEC ACS HERE WHEN JOB ISN'T RUNNING.
UARRAY(UPTUAC,20)	;USER ACS WHEN JOB ISN'T RUNNING (USED
			; TO BE AT PAGE 0)
	XP CHGSIZ,<^D22>
UARRAY (UPTCHG,CHGSIZ)	;SAVED TRU COMPONENTS. 17 PRE-P031

UVAR(UPTHCU)		;HIGHEST USER I/O CHANNEL IN USE.
UVAR(UPTENB)		;LH=UNUSED,RH=APR CONSO FLAGS FOR USER
			; APR TRAPPING.  SET BY APRENB UUO.
UVAR(UPTTPN)		;HAS TRAP NUMBERS FOR VARIOUS TRAPS
UVAR(UPTTP1)		;MORE TRAP NUMBERS
UVAR(UPTMTM)		;Micro-cycle interrupt timer
UVAR(UPTABL)		;SAVED LOCATION FOR ADDRESS BREAK (SO CAN REPORT WHERE UUO WAS)
UVAR(UPTUFI)		;USER WORKING SET PAGE FAULT INFORMATION
UVAR(UPTXFI)		;LIKE UFI, BUT FOR TIMES TRAP CAN'T HAPPEN
UVAR(UPTUEI)		;USER ERROR INFORMATION (FOR PAGES)
UVAR(UPTXEI)		;LIKE UEI, BUT USED WHEN TRAP CAN'T HAPPEN
UVAR(UPTURI)		;USER REF BIT TRAP INFO
UVAR(UPTXRI)		;LIKE URI, BUT USED WHEN TRAP CAN'T HAPPEN.
UVAR(UPTUII)		;ILL MEM REF, WRITE VIOL, ADDR BREAK INFO WORDS
UVAR(UPTXII)		; RETURNED BY PGISTS UUO.

  XP UPTTCB,UPTTPN	;FIRST LOC TO CLEAR IN APRENB
  XP UPTTCE,UPTXII	;LAST LOC.
UVAR(UPTREL)		;LH/0; RH/LOWSEG HI ADDR OR 0 IF NO LOWSEG
UVAR(UPTHRL)		;LH/0;  RH/HISEG HI ADDR, OR 0 IF NO HISEG
UVAR(UPTRNM)		;RESTRICTED COMMAND FILE NAME
UVAR(UPTRPN)		;RESTRICTED COMMAND FILE PPN
UVAR(UPTALD)		;ALTERNATE LOGOUT PROGRAM DEVICE
UVAR(UPTALP)		;ALTERNATE LOGOUT PROGRAM PPN
UVAR(UPTALN)		;ALTERNATE LOGOUT PROGRAM NAME
UVAR(UPTPJC)		;SESSION PROJECT CODE WORD 0
UVAR(UPTPJ1)		;WORD 1
UVAR(UPTPJ2)		;WORD 2,BIT 35 IS "LICENSE REQD" BIT
UVAR(UPTSAT)		;HAS STATUS BITS FOR + ADDR OF %SAT PCB.
UVAR(UPTRIB)		;HAS STATUS BITS FOR + ADDR OF %RIB PCB.
UVAR(UPTRB2)		;HAS STATUS BITS FOR + ADDR OF %RB2 PCB.
UVAR(UPTPID)		;PID FOR CURRENT PROGRAM - FROM RUN FILE'S PID.
UVAR(UPTSPD)		;SAVED PID, SO PIDSET UUO CAN SET IT TO 0 AND BACK

UVAR(UPTLOG)		;Originating Port for this frame.

UVAR(UPTLKJ)		;JOB NUMBER OF JOB WHO OWNS CONTEXT PAGE WRITE LOCK FOR THESE CONTEXT PAGES
UVAR(UPTLKW)		;HEAD OF WAITERS FOR CTX PAGE WRITE INTERLOCK
UVAR(UPTOFD)		;FRAME DESCRIPTOR SET BY SETOTF UUO.
UVAR(UPTLKC)		;NUMBER OF TIMES OWNER OF LOCK CALLED FOR IT AGIN+1
			; (NESTED PAGE FAULTS INSIDE UUOS, ETC.)
UVAR(UPTETP)		;(0) CLASS,,TYPE WITHIN CLASS OF ERROR TRAP
XP UPTHST,UPTETP	;FIRST LOCATION OF HALT STATUS BLOCK
UVAR(UPTECN)		;(1) COUNT TO TELL HOW MANY ERRORS HAPPENED.
UVAR(UPTEPC)		;(2) PC OF ERROR TRAP
UVAR(UPTEUP)		;(3) PC OF LAST TOP LEVEL UUO PERFORMED
UVAR(UPTEDV)		;(4) DEVICE NAME, LOCATION, ETC.
UVAR(UPTELC)		;(5) LOCATION, OTHER DATA
UVAR(UPTEL1)		;(6) ANOTHER LOCATION FOR ERROR DATA.
XP FHSMXC,<UPTEL1-UPTHST+1> ;MAXIMUM COUNT

XP FHIMAX,FHIN-1	;MAXIMUM VALUE FOR INDEXING INTO UPTFHT

UARRAY(UPTFHT,FHIN)	;FRAME HANDLE ADDRESSES.

UARRAY(UPTS2P,.ARSIZ)	;BITS FOR ACCESS RIGHTS OF SELF OVER PARENT
UARRAY(UPTP2S,.ARSIZ)	;BITS FOR ACCESS RIGHTS OF PARENT OVER SELF
UARRAY(UPTMFR,.ARSIZ)	;MAX INWARD RIGHTS FOR THINGS THAT NEED CONTEXT PAGES IN.

UVAR(UPTSTV)		;CONTAINS SIZE,,START ADDRESS OF START VECTOR
;DEFINE LMAP LOCATIONS
UARRAY(UPTLMA,<VPMAX+1>);BASIC LMAP SLOT DATA, INDEXED BY VP
UARRAY(UPTMWB,<<VPMAX+1+^D35>/^D36>)
			;MONITOR WORKING SET BIT TABLE.
AGECPW==:<^D36/AGESIZ>
AGEMAX==:<<1_AGESIZ>-1>
UARRAY(UPTAGE,<<^D512+AGECPW-1>/AGECPW>)
			;PAGE AGE TABLE
UARRAY(UPTUWB,<<^D512+^D35>/^D36>)
			;USER WORKING SET BIT TABLE
UVAR(UPTUWS)		;USER WORKING SET DATA
			;CURRENT SIZE IS IN JBYUWS.
 UPYUWL::POINT 10,%UPT+UPTUWS,25	;CURRENT LIMIT
 USYUWL::POINT 10,%UPS+UPTUWS,25 ;ONE FOR %UPS
 UXYUWL::POINT 10,%UPX+UPTUWS,25 ;ONE FOR %UPX
 UPYUWM::POINT 10,%UPT+UPTUWS,35	;CEILING FOR CURRENT LIMIT
 USYUWM::POINT 10,%UPS+UPTUWS,35 ;ONE FOR %UPS
 UXYUWM::POINT 10,%UPX+UPTUWS,35 ;ONE FOR %UPX

UVAR(UPTNTV)		;TICKS UNTIL NEXT PAGE AGE RECOMPUTATION
UVAR(UPTMAT)		;# OF MATURE PAGES (AGE >= C(AGEMAT))
UVAR(UPTELD)		;# OF ELDERLY PAGES (AGE >= C(AGEELD))
UVAR(UPTRPT)		;POINTER FOR CIRCULAR PAGE REPLACEMENT ALGORITHM

UVAR(UPTRES)		;WORD FOR SWAPPER TO REMEMBER RESERVED PAGES
 USYSIN::POINT 10,%UPS+UPTRES,15	;NUMBER OF PAGES SWAPPED IN
			; FOR SETTING UP ICPT
 USYRES::POINT 10,%UPS+UPTRES,25	;NUMBER OF RESERVES PAGES JOB OWNS STILL
 USYLSP::POINT 10,%UPS+UPTRES,35	;LMAP SCAN POINTER (WHERE
			; SWAPPER STARTS SWAPPING IN ON A CYCLE

XP UPTEND,%UPT.V-1	;LAST LOCATION IN UPT TO CLEAR.
NCTXPG==:<%UPT.V!777+1>/1000
ONSZCK(CONTEXT,NCTXPG,CTX)	;CHECK TO SEE IF ENOUGH SPACE ALLOC FOR CTX PGS
VPUMAX==:VPMAX-NCTXPG	;MAXIMUM NON-CONTEXT PAGE VP

XP %UPT.N,VPUMAX+1-CNVVPN 	;START PAGE OF CONTEXT PAGES
XP %UPT,<%UPT.N_9>	;START ADDRESS OF CONTEXT PAGES IN UPT
XP %UPLMA,%UPT+UPTLMA	;THIS ADDR+VP GIVES LMAP SLOT DATA
XP %UPLMX,%UPX+UPTLMA	;DITTO FOR %UPX.

XP %COW.N,%UPT.N-1	;USED FOR COPY ON WRITE
XP %COW,<%COW.N_^D9>

;%UPX IS A SPECIAL SET OF PAGES THAT EITHER CONTAINS POINTERS IDENTICAL
; TO %UPT POINTERS IF THE SLOTS DON'T EXIST, OR LMAP SLOTS FOR
; ANOTHER FRAMES'S CONTEXT PAGES.

XP %UPX.N,%COW.N-NCTXPG	;PLACE FOR VIRTUAL UUOS THAT WORK ON OTHER FRAMES TO
			; ACCESS CURRENT CONTEXT PAGES
XP %UPX,<%UPX.N_^D9>

;ADD OTHER PERMANENTLY ALLOCATED EXEC PER PROCESS VALUES ABOVE HERE
XP %LEP.N,%UPX.N-1	;LAST DYNAICALLY ALLOCATED EXEC PER PROCESS PAGE

PBMMSK::-1_<340-%LEP.N+1>	;MASK FOR DYNAMIC ALLOCATER.
				; 1 MEANS IN USE.

XP %UPS.N,EVPMAX-NCTXPG+1	;FIRST EPT PAGE NUMBER THAT CONTEXT PGES MAPPED IN
XP %UPS,<%UPS.N_9>	;FIRST CONTEXT PAGE ADDRESS IN EPT
XP %UPLMS,%UPS+UPTLMA	;THIS ADDR PLUS VP GIVES 36 BIT LMAP SLOT DATA

UPYPTN:: UPMPTR(%UPT.N)		; 
UPYPTM:: UPMPTR(%UPT.N-1)	; (CORE1)
UPYPXN:: UPMPTR(%UPX.N)		; 
UPYPXM:: UPMPTR(%UPX.N-1)	; (CORE1)

USYPTN:: UPSPTR(%UPT.N)		; (ONCE)(CORE1)
USYPXN:: UPSPTR(%UPX.N)		; 
USYPTM:: UPSPTR(%UPT.N-1)	; 
USYPXM:: UPSPTR(%UPX.N-1)	; (SCHED1)

UXYPTN:: UPXPTR(%UPT.N,%UPT)	; 
UXYPTM:: UPXPTR(%UPT.N-1,%UPT)	; (COMCON)

EPYPSN:: EPTPTR(%UPS.N)		; (ONCE)(PICON)(UUOCON)
EPYPSM:: EPTPTR(%UPS.N-1)	; (CORE1)(SCHED1)

;LMAP BIT DEFINITIONS

XP LMPSHR,400000	;SHARED (OFF IS UNSHARED)

XP LMSCUR,2		;SIZE OF PROTECTION FIELD
XP LMNCUR,2		;BIT POSITION
XP LMPCUR,(1B<LMNCUR>)	;THE BIT

LMYCUR:: POINT LMSCUR,%UPLMA(W),LMNCUR ;CURRENT PROTECTION: WRITE,
			;COW, OR READ ONLY.
LM3CUR:: POINT LMSCUR,P3,LMNCUR
	XP CPRRED,1
	XP CPRCOW,2
	XP CPRRDW,3
	XP MAXCPR,CPRRDW	;MAXIMUM DEFINED PROTECTION.
XP LMMCUR,300000	;DEFINED ONLY BECAUSE OF LMMEXS.
XP LMMEXS,LMPSHR!LMMCUR ;IF ALL OF THE MASKED BITS ARE OFF,
			;THE PAGE IS NON-EXISTENT.
XP LMPACT,40000		;ACTIVE (SEMI IN-CORE BIT)
XP LMPMXW,20000		;MAXIMALLY WRITEABLE
  XP LMMMXW,LMPMXW!LMMCUR ; For use as Maximally writeable MASK
  XP LMMRED,LMPMXW!(<CPRRDW>B<LMNCUR>) ; Max WRITE, READ ONLY
  XP LMMRDW,LMPMXW!(<CPRRDW>B<LMNCUR>) ; PROTOTYPE LMAP SLOT
XP LMPREF,10000		;REF
XP LMPVIR,4000		;VIRGIN
XP LMPDER,2000		;DEVICE ERROR
XP LMPDTE,1000		;DATA ERROR
 XP LMMERR,LMPDER!LMPDTE ;MASK
LMYERR::POINT 2,%UPLMA(W),^L<LMPDTE>-^D18 ;SWAP ERROR BITS
LM3ERR::POINT 2,P3,^L<LMPDTE>-^D18	;ONE FOR P3
XP LMPSUP,400		;THIS IS A SUPER MAPPED PAGE.
  XP LMMSUP,LMPSUP!LMMMXW ; Super mapped, Maximally writeable MASK
XP LMPNER,200		;IGNORE I/O ERROR ON THIS PAGE.
XP LMPLOK,100		;SLOT IS LOCKED IN CORE (NEVER DEACTIVATED EXCEPT IN REMOVE)


LMYOVR: POINT ^D23,%UPLMA(W),^D35 ;AN AREA OF THE LMA SLOT
			; THAT IS SHARED BY LMYLMA, LMYSPT, LMYATB, AND
			; LMYHDA.
LM3OVR: POINT ^D23,P3,^D35
 LMYOV1: POINT ^D13,%UPLMA(W),^D25
 LM3OV1: POINT ^D13,P3,^D25
 LMYOV2: POINT ^D10,%UPLMA(W),^D35
 LM3OV2: POINT ^D10,P3,^D35

;THE FOLLOWING FIELDS EXIST IN AN ACTIVE LMAP SLOT.

XPP LMYLMA,LMYOVR	;LINK OF PGYLMA CHAIN.ITS FORM IS
			; THAT OF A JOB-VM PNTR. THE END OF
			; THE CHAIN HAS A ZERO (THE SPT ENTRY
			; ADDR IS IN PGYSPT, SEE BELOW.).
 XPP LMYLMJ,LMYOV1
 XPP LMYLMV,LMYOV2
 XPP LM3LMJ,LM3OV1
 XPP LM3LMV,LM3OV2

;THE FOLLOWING FIELDS EXIST IN AN INACTIVE SHARED LMAP SLOT.

XPP LMYSPT,LMYOVR	;AN SPT-ENTRY PNTR.
XPP LM3SPT,LM3OVR
 LMYSPB::POINT 18,%UPLMA(W),31 ;BASE ADDRESS OF SPT SECTION
 LM3SPB::POINT 18,P3,31		;SAME, BUT IN P3
 LMYSPO::POINT 4,%UPLMA(W),35	;OFFSET INTO ENTRIES OF THIS ENTRY
 LM3SPO::POINT 4,P3,35		;ONE FOR P3

;THE FOLLOWING FIELDS EXIST IN AN INACTIVE UNSHARED LMAP SLOT.

XPP LMYATB,LMYOV1	;ADDR OF THE ATB. (REALLY AN OFFSET FROM
			;THE START OF A CORE STORAGE AREA.).
XPP LM3ATB,LM3OV1
XPP LMYHDA,LMYOV2	;HIGH PART OF THE DISK ADDRESS. (TOTAL
			; DISK ADDRESS REQUIRES
			; 8 BITS FOR UNIT FIELD AND 19 BITS FOR
			; PAGE NUMBER.).LOW PART OF DISK ADDR
			; IS IN UPT AT THIS POINT.
XPP LM3HDA,LM3OV2

XP LMASRP,^D17		;LSH BY THIS TO GET RID OF LOW 17 BITS,
			; OBTAINING HI ORDER DISK ADDRESS.

;PARTS OF LMAP IN UPT MAP AREA

UP4LDA::POINT 17,P4,35	;LOW ORDER PART OF DISK ADDRESS


;END OF LMAP/UPT DEFN'S



	BUFS(10000)		;REMAINING BUFFERS


XP MSKIRG,<1_SIZIRG-1>
XP MSKORG,<1_SIZORG-1>

;define paging ram indexes for tape and KMC on 2020

IFCPU(KS),<			;DEFINE THE PAGING RAM INDICES FOR TAPE
IFNDEF LPTBAS,<LPTBAS==0>	;PDP11 PAGE RESERVED FOR LPT
XP UBATAP,<LPTBAS_-9>+1
>;END IFCPU(KS)

IFCPU(KS),<			;DEFINE THE PAGING RAM INDICIES FOR KMC
XP UBACM0,UBATAP+^D32		;SET CM 0 ADDRESS INDEX FOR PAGING RAM
XP UBAEND,^D64			;END OF PAGING RAM
XX==0
IFG 1000-<ORING+<1_SIZORG>>,<	;IF BOTH RINGS FIT INTO PAGE 0
	XP UBANXT,UBACM0+1	;SET RAM INDEX FOR BLOCK IO AFTER RINGS
	XP UBIRBG,UBACM0	;SET IRING BEGIN TO PAGE 0
	XX==1>
IFL IRING-1000,<XP UBIRBG,UBACM0>;SET INDEX FOR START OF IRING
IFGE IRING-1000,<XP UBIRBG,UBACM0+1>
IFE XX,<			;ELSE RINGS DONT FIT IN PAGE 0
	XX==<<ORING+<1_SIZORG>+777>_-9>-<IRING_-9>;CALC. # PAGES FOR RINGS
	XP UBANXT,UBIRBG+XX	;SET RAM INDEX FOR BLOCK IO TO AFTER RINGS
>;END IFE XX
>;END IFCPU(KS)

INTERNAL LOCOCW,KEY620,ALR620,IRING,ORING,IRPPDP,IRP620,ORPPDP
INTERNAL ORP620,IRING,ORING,EPT,UPT
IFNCPU (F3),<INTERNAL DMP620>

;SYSTEM DATA STORAGE

;SPECIAL ABSOLUTE LOCATIONS IN LOWER MEMORY

INTERNAL MTIOC,MTCCW,RAXIOC,RAXCCW,CRSHWD
INTERNAL DPCIOC,DPCCCW,RCXIOC,RCXCCW,DDTSYM
INTERNAL BOOTWD,KSSS4
INTERNAL RLWORD,CTYIWD,CTYOWD,KPAFAL
INTERNAL RESTRT,REPSID

	DPCIOC==22		;CHANNEL ADDRESS FOR RP10 DATA CHANNEL (LEVEL C ONLY)
	DPCCCW==DPCIOC+1	;CHAN STORE LOC FOR RP10
BOOTWD==DPCIOC			;CHANNEL ADR. PAIR FOR BOOTS (LEVEL D BOOTS STRAP)
	MTIOC==24		;CHANNEL ADDRESS FOR TM10B DATA CHANNEL
	MTCCW==MTIOC+1		;FINAL CONTROL WORD STORED HERE
KSSS4==MTIOC			;SENSE SWITCH 4 WORD FOR KS CTY
	RAXIOC==26		;XWD 0,ADDRESS FOR RA-10'S DATA CHANNEL (LEVEL C ONLY)
				; MUST BE EVEN AND .LT. 777
	RAXCCW==RAXIOC+1		;XWD CONTROL WORD ADDRESS,DATA ADDRESS
				; STORED ON CHANNEL TERMINATION
	REPSID==26		;RESTART PACK SET ID
	RESTRT==27		;RESTART STATES AND ACTIONS
	CRSHWD==30		;NORMALLY THIS WORD WILL BE 0.  IF IT IS ACCIDENTALLY
				; OR PURPOSEFULLY OVERWRITTEN THE MONITOR WILL
				; ATTEMPT TO SAVE THE AC'S AND THE STATE OF
				; ALL DEVICES, THEN HALT.   [A LA 147 RESTART]
	RLWORD==31		;FOR KS-RELOAD WORD USED IN COMMUNICATING WITH THE 8080
	CTYIWD==32		;KS/8080(CTY) INPUT WORD
	CTYOWD==33		;KS/8080(CTY) OUTPUT WORD
	RCXIOC==34		;INITIAL CONTROL WORD FOR RC-10'S DATA CHANNEL
				; (TRANSFERS CHANNEL TO SEQUENCE OF IOWD'S IN FHDINT)
				; MUST BE IN EVEN LOC IN FIRST 1K OF MEMORY
	RCXCCW==RCXIOC+1		;CHANNEL STORES FINAL CONTROL WORD HERE ON
				; TERMINATION OF RC-10 DATA TRANSFER.
	DDTSYM==36		;CONTAINS ADDRESS OF POINTER TO EXEC DDT SYMBOL TABLE
	KPAFAL==71		;ADDRESS OF INSTRUCTION EXECUTED BY THE
				;THE KS CTY WHEN KEEP ALIVE FAILS
;PROTECTED JOB DATA STORAGE AND OTHER LOCATIONS SET EACH TIME
;A NEW JOB IS RUN (SEE CLKINT)

INTERNAL SYSBEG,SYSEND,JOB



SYSBEG:				;FIRST LOCATION CLEARED ON 143 RESTART (SEE SYSINI)
XP SYSBG1,SYSBEG+1

JOB:	0			;CURRENT JOB RUNNING AT M LEVEL



;OTHER SYSTEM DATA STORAGE

	INTERNAL COMCNT,CLKFLG,TIMEF,APRPC,SCHEDF,NFCNT
	INTERNAL STPFLG,NSWTBL,NSWMXL
	INTERNAL HNGTIM,CIPWT,CIPWTM,NULERR,POTLST,HNGMIN

COMCNT:	0			;NUMBER OF COMMANDS TYPED-IN BUT NOT DECODED
				;SET BY SCNSER, DECREMENTED BY COMCON
NFCNT:	0			;COUNT OF TIMES COMCNT NON-ZERO,
				;BUT NO WAITING COMMANDS
HNGTIM:	0			;HUNG DEVICE TIME COUNT CHECK FOR HUNG I/O
				;DEVICES WHEN THIS GOES TO ZERO (ONCE PER HNGSEC)
HNGMIN:	0			;COUNTER FOR ONCE A MINUTE
CLKFLG:	0			;NON-ZERO WHEN CLK INTERRUPT FORCED FOR ANY REASON
STPFLG:	0			;SET WHEN CURRENT JOB MAY BE STOPPED
				;CLK INT AND NOT EXEC MODE OR USCHED
TIMEF:	0			;NON-ZERO FOR CLOCK INTERRUPT ON APR
				;SET BY APRSER, TESTED AND CLEARED BY CLK ROUTINE
				;SET BY APRSER, CLEARED BY CLK ROUTINE (CLOCK)
				;LH=-1 ON MEM PARITY ERROR
APRPC:	0			;PC WHEN APR ERROR DETECTED
SCHEDF:	0			;FORCED RESCHEDULING FLAG FOR CLK ROUTINE
				;USED TO FORCE RESCHEDULING WHEN JOB IS IN EXEC MODE
NULERR:	0			;SET NON-ZERO IF MONITOR DETECTS ERROR WHILE
				; NULL JOB IS RUNNING
POTLST:	0			;-1 WHEN SCHEDULER SEES THAT THERE ARE JOBS WHICH
				; ARE POTENTIALLY RUNABLE BUT HAS TO RUN NULL JOB.
				;0 WHEN IT FINDS A REAL JOB TO RUN OR NULL JOB IS
				; ONLY JOB WHICH WANTS TO RUN.  'LSTWRD' IS
				; INCREMENTED EVERY JIFFY IF THIS FLAG IS -1 AND
				; PREVIOUS JOB WAS NULL JOB.
SLJOBN==JOBN*2			;LEAVE TWO ENTRIES PER JOB
CIPWT:	BLOCK SLJOBN+3		;CLOCK REQUEST QUEUE
				; LH-MONITOR ADDRESS TO PUSHJ TO AT CLOCK LEVEL
				; WHEN BITS 24-35 COUNT DOWN TO ZERO
				; BITS 18-23 ARE DATA SET IN AC T1 WHEN PUSHJ DONE
				; BITS 24-35 ARE NUMBER OF CLK TICKS LEFT TO GO
	CIPWTM==CIPWT-1		;FIRST LOC-1 OF CLOCK QUEUE
	INTERNAL EPOCNT,EPOREC


;STORAGE FOR VARIOUS CORE ALLOCATION FUNCTIONS

	INTERNAL UPTIME,HIGHJB,CLRWRD,LSTWRD
	INTERNAL MEMSIZ,PARTOT,PARSPR,PARCON,PARADR,PARWRD,PARPC,PARFLG
	INTERNAL CORMXK,HLTBRK,NULTIM,NULMNT,CRSCNT

	XP PAGSIZ,1000		;BASIC UNIT OF CORE IN WORDS

NSWTBL:				;FIRST LOCATION OF MONITOR DATA STORAGE
				; RETURNED BY GETTAB M (THESE LOCATIONS
				; PRESENT IN NON-SWAPPING SYSTEMS TOO)
				; OCTAL NUMBERS IN () CORRESPOND TO GETTAB ARG
	BLOCK 10		;(0-7) NO-LONGER USED FOR CORTAB.
CORMAX:	0			;(10) MAXIMUM CORE REQUEST+1 (IE LARGEST REL. ADR,+1)
				; CAN BE RESTRICTED TO LESS THAN ALL OF USER CORE
				; BY BUILD AND/OR ONCE
	0			;(11) 1 BIT BYTE POINTER TO LAST FREE BLOCK POSSIBLE
				; SET BY SYSINI ON 143 STARTUP
	0			;(12) TOTAL NUMBER OF FREE+DORMANT+IDLE CORE BLKS LEFT
	0			;(13) JOB NUMBER SHUFFLER HAS TEMPORARILY STOPPED FOR
				; ITS I/O DEVICES TO BECOME INACTIVE BEFORE SHUFFLING
	0			;(14) ABSOLUTE ADDRESS OF LOWEST HOLE IN CORE, 0=NONE
UPTIME:	0			;(15) NUMBER OF CLOCK TICKS SINCE SYSTEM LOADED OR
				; RESTARTED AT 143
	0			;(16) TOTAL NUMBER OF WORDS SHUFFLED BY SYSTEM
	0			;(17) JOB CURRENTLY USING THE SYSTEM TAPE
				; NEEDED SO CONTROL C WILL NOT TIE UP SYSTEM TAPE
HIGHJB:	0			;(20) HIGHEST JOB NUMBER CURRENTLY ASSIGNED
CLRWRD:	0			;(21) TOTAL NUMBER OF WORDS CLEARED BY 'CLRCOR' RTN.
LSTWRD:	0			;(22) TOTAL NUMBER OF CLOCK TICKS WHEN NULL JOB RAN
				; BUT OTHER JOBS WANTED TO RUN AND COULD NOT
				; DO SO BECAUSE: ---
				;  1. SWAPPED OUT OR ON WAY IN OR OUT
				;  2. MONITOR WAITING FOR I/O TO STOP SO
				;      IT CAN SHUFFLE OR SWAP
				;  3. JOB BEING SWAPPED OUT BECAUSE IT IS
				;      EXPANDING CORE


MEMSIZ:	0		;(23)SIZE OF PHYSICAL MEMORY IN WORDS (=FIRST NON EXIST WORD)
			; SET BY SYSINI ON 143 RESTARTS UNLESS SYMBOLS SAVED BY
			; PATCHING SYSLIM SMALLER.
PARTOT:	0		;(24) TOTAL NUMBER OF BAD MEMORY PARITY ERRORS FOUND BY MONITOR
			;WHILE PROCESSOR WAS IN USER MODE
			; WHILE SYSTEM WAS RUNNING (IF MONITOR HALTS
			; THIS LOC ALREADY UPDATED)
PARSPR:	0		;(25) TOTAL NUMBER OF SPURIOUS MEMORY PARITY ERRORS
			; FOUND BY APR, I.E. ONES WHICH DID NOT OCCUR
			; WHEN MONITOR SWEPT THRU CORE LOOKING FOR BAD
			; PARITY.
PARCON:	0		;(26) COUNT OF NUMBER OF TIMES OPERATOR PUSHED CONTINUE
			; AFTER MEMORY PARITY HALT (PC) IN EXEC MODE OR MORE THAN 1
			; BAD PARITY WORD WHEN PC WAS IN USER MODE)
PARADR:	0		;(27) LAST BAD PHYSICAL MEMORY ADDRESS FOUND
			; WHEN MONITOR SWEPT THRU CORE AFTER
			; PROCESSOR DETECTED FIRST BAD PARITY
PARWRD:	0		;(30) CONTENTS OF LAST BAD WORD FOUND BY MONITOR
			; WHEN MONITOR SWEPT THRU CORE AFTER FIRST PARITY
PARPC:	0		;(31) PC OF LAST MEM PARITY (NOT COUNTING SWEEP THRU CORE)
			;INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
			; TO USERS IN NON-SWAP AND SWAP SYSTEMS
EPOCNT:	0		;(32) TOTAL #  OF PDL OVF'S  AT M LEVEL IN EXEC MODE
EPOREC:	0		;(33) # OF PDL OVF'S AT M LEVEL IN EXEC MODE
NULTIM:	0		;(34) NUMBER OF CLOCK TICS NULL JOB HAS BEEN
			;RUNNING SINCE STARTUP
NULMNT:	0		;(35) NUMBER OF CLOCK TICES NULL JOB RAN
			;IN PREVIOUS MINUTE
ALR620:	0		;(36) 620 ALARM CELL (UNHAPPY MSGS)
USRMAX::0		;(37) MAXIMUM SIZE THAT A JOB'S MWS CAN GET.
			; SETUP BY ONCE TO BE NUMBER OF USER PAGES AVAILABLE.
SYSUID::0		;(40) last allocated universal frame id number
THSTIM::0		;(41) UPTIME when SCNSER last ran
MXTIM::	0		;(42) all time max of (THSTIM-UPTIME)

NSWMXL==<.-NSWTBL-1>B26	;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9

SYSBG2:				;1ST. LOCATION FOR ONCE ONLY CODE TO BE ASSEMBLED HERE
;CORE ALLOCATION DATA NOT AVAILABLE VIA GETTAB
INTERNAL LASCOR	; (FOR DEBUGGING ONLY)
LASCOR:	0			;LAST JOB OR HIGH SEG TO CALL CORE ROUTINES
PARFLG:	0			;-NO. OF PARITY ERRORS ALLOWED IN EXEC MODE
			; BEFORE HALT.  USED TO DETECT SWEEP THRU CORE

RCMAX:	177		;MAX SIZE OF USER JOB IN K
CORMXK:	0		;MIN-MAXIMUM SIZE OF USER JOB IN K
MWSLIM::0		;CURRENT MWS LIMIT. SETUP BY ONCE TO C(USRMAX)
HLTBRK:	0		;IF NON-ZERO, WE WILL HALT ON ADRESS BRK
;DATA LOCATIONS PRESENT ONLY IN SWAPPING SYSTEMS

	INTERNAL SWPTBL,SWPMXL,SWPERC
	INTERNAL FULCNT
SWPTBL:				;FIRST LOCATION OF MONITOR DATA STORAGE
				; RETURNED BY GETTAB M (THESE LOCATIONS
				; PRESENT ONLY IN SWAP SYSTEMS)
				; OCTAL NUMBERS IN () CORRESPOND TO GETTAB ARG
	0			;(0) CURRENT BIGGEST HOLE IN CORE (IN PAGES)
	0			;(1) IF +, THEN JOB NUMBER OF JOB BEING SWAPPED IN,
				;IF -, THEN JOB NUMBER OF JOB BEING SWAPPED OUT
	0			;(2) JOB NUMBER BEING FORCED TO SWAP OUT
	0			;(3) JOB NUMBER WAITING TO BE FITTED INTO CORE
	0			;(4) NUMBER OF FREE PAGES OF SWAPPING SPACE LEFT
				; (COUNTING DORMANT SEGMENTS AS IF FREE).
				; PRINTED WITH CORE COMMAND (NO ARG) OR ERROR
				; USUALLY THE SAME AS THE AMOUNT OF VIRTUAL CORE
				; LEFT IN SYSTEM, EXCEPT WHILE R,RUN,KJOB,GET
				; COMMAND ARE WAITING TO BE SWAPPED IN, BECAUSE
				; THE OLD DISK SPACE HAS NOT BEEN RETURNED YET,
				; BUT VIRTUAL CORE IS ONLY 140 WORDS FOR SWAPIN
SWPERC:	0			;(5) LH= NUMBER OF SWAPPER READ OR WRITE FAILURES
				; RH= ERROR BITS (BITS 18-21) + NUMBER OF J OF
				; DISCARDED SWAPPING SPACE

				;INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
				; TO USER PROGS IN SWAPPING SYSTEMS
	INTERNAL LASIN,LASOUT
LASIN:	0			;(6) last job or high seg swapped in
LASOUT:	0			;(7) last job or high seg swapped out
SWPMXL==<.-SWPTBL-1>B26	;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9

;MORE SWAPPING SYSTEM LOCATIONS (NOT RETURNED BY GETTAB)

FULCNT:	0			;PRINT DISK IS FULL EVERY 30 SECONDS

;DEFINE BLOCK FOR BIT TABLE DENOTING 4 WORD BLOCKS AVAILABLE (=0), IN USE (=1)
; USE MULTIPLES OF 4*^D36 WORDS SO THE TABLE WILL HAVE A MULTIPLE OF ^D36 BITS
; ADD 7 WORDS TO ACCOMODATE A POSSIBLE 1K BEYOND FRECOR AMOUNT

;MONITOR TABLES WITH ONE ENTRY PER JOB

	INTERNAL JBTSTS,JBTNAM,JBMQNT,JBTCTX,JBTUPM
	INTERNAL JOBMAX,JBTMAX,MJOBN,JOBMXL,JBTMXL,JBTIOA

	JOBMAX==JOBN-1		;MAXIMUM LEGAL JOB NUMBER
	JOBMXL==<JOBMAX>B26	;HIGHEST JOB NUMBERSHIFTED LEFT 9 (FOR GETTAB M)
	MJOBN==-JOBN		;NEGATIVE NUMBERS OF JOBS (COUNTING NULL JOB)
	JBTMAX==JOBMAX		;HIGHEST INDEX IN JBT TABLES
	JBTMXL==<JBTMAX>B26	;HIGHEST JBT ENTRY SHIFTED LEFT 9 (FOR GETTAB M)
JBTSTS:	BLOCK 	JOBN		;JOB STATUS WORD
				;LH==STATUS BITS (SEE S.MAC FOR DESCRIPTION)
				;BITS 18-23=EXTENDED JOB STATUS BITS
	INTERN	JBTWRS
JBTWRS:	BLOCK	JOBN		;LAST 6 JOB STATE CODES (DEBUGGING)
JBTCTX:	BLOCK	JOBN*NCTXPG	;DISK ADDRESSES, STATUS BITS FOR
				; CONTEXT PAGES

JBTIOA:	BLOCK	JOBN		;RH=COUNT OF CAN'T SWAP WHILE IO
				;WHICH USES USER CORE IS IN
				;PROGRESS. =0 MEANS SWAPPABLE.

JBTUPM:	BLOCK	JOBN		;LH = NUMBER OF EXISTENT PAGES IN
				; USER ADDRESS SPACE. RH = USER
				; AC BLOCK, LOAD UBR BIT
				; AND PHYSICAL PAGE NUMBER OF UPT

JBTPGO::BLOCK	JOBN		;LH SEE BELOW, RH LINK TO NEXT JOB
				; WAITING FOR CORE PAGE. CHAIN STARTS
				; IN PGYPGO.

JBTFIT::BLOCK	JOBN		;DOUBLY LINKED LIST OF JOBS BEING
				; SWAPPED IN.

JBTMWS::BLOCK	JOBN		;MONITOR WORKING SET WORD
				;BITS 26-35 (JBYUWS) UWS SIZE
				;BITS 16-25 (JBYMWL) MWS SIZE LIMIT
				;BITS  6-15 (JBYMWS) MWS SIZE
				;BITS  0-5  (JBYPPP) # OF PER-PROCESS
				;PAGES

JBTICT::BLOCK	JOBN		;LH=IN CORE PROTECT TIME FOR JOB
				;RH=QUANTUM RUN TIME

XP JBSQNT,^D12
XP JBNQNT,^D35
XP JBMQNT,7777

JBTFTR::BLOCK	JOBN		;FRAME TREE TABLE. CONTAINS 3 12 BIT
				; FIELDS - PARENT, RIGHT HAND NEIGHBOR, AND LEFTMOST CHILD.

JBTUID::BLOCK	JOBN		;UNIVERSAL FRAME ID

JBTPNO::BLOCK	JOBN		;"PROGRAM NUMBER" - RIGHTS GO AWAY AFTER MISMATCH AGAINST THIS

JBTP2S::BLOCK	JOBN		;FAST ACCESS RIGHTS BITS FOR PARENT TO SELF

JBTS2P::BLOCK	JOBN		;FAST ACCESS RIGHTS BITS FOR SELF TO PRENT

JBTMFR::BLOCK	JOBN		;FAST MAXIMUM INWARD RIGHTS 
				; (DEFAULT RIGHTS FOR FRAMES THAT DON'T KNOW EACH OTHER WELL)

JBTSPN::BLOCK	JOBN		;SELF TO PARENT RIGHTS PROGRAM NUMBER

	INTERNAL JBTPPN
JBTPPN:	BLOCK JOBN		;XWD PROJECT NUMBER,PROGRAMMER NUMBER
	XP ITMDEV,JOBMXL	;LH SYMBOL FOR GETTAB M SO THAT JBTDEV IS
				;UNDEFINED, IE. MAKE INDEXING BYITEM BE 0
	INTERNAL RTIME
RTIME:	BLOCK JOBN		;TOTAL RUN TIME SINCE LAST IJOB OR RUNTIME

;TABLE USED BY TEMPORARY FILE STORAGE M WHICH
; KEEPS SHORT FILES (CCL) IN CORE TO SPEED UP SYSTEM.
; (ESPECIALLY USEFUL ON BIG SYSTEMS WITH SLOW DISKS.)

	INTERNAL JBTTMP
JBTTMP:	BLOCK	JOBN		;ONE ENTRY PER JOB, FREE SPACE FOR NULL JOB.
				; EACH ENTRY HAS THE FORM   XWD <QUOTA>,<LINK>

JBTNAM:	BLOCK JOBN		;NAME OF FILE USED IN LAST R,RUN,GET, ETC
				; USED BY SYSTAT PROGRAM
	INTERNAL JBTKCT
JBTKCT:	BLOCK JOBN		;PRODUCT OF CORE LENGTH (IN J) * NUMBER OF JIFFIES
				; PROGRAM USED CPU. USED FOR TIME ACCOUNTING.

	INTERN JBTWCH
JBTWCH:	BLOCK JOBN		;BITS 1-5 = ENABLE BITS - SEE S.MAC
				;BITS 13-35 = TIME OF DAY IN JIFFIES USER
				;STARTED TO WAIT FOR RESPONSE FROM SYSTEM
				;REST UNUSED

	INTERN JBTSTA
JBTSTA:	BLOCK	JOBN		;Used by .USESTAT command

JBTLIC:	BLOCK JOBN	;FOR LICENSE BITS
JBTSLC:	BLOCK JOBN	;LH FOR SAVE LICENSE BITS
			; RH OF JBTSLC USED FOR INTERRUPT ASSIGNMENTS.
			; DON'T USE LH FOR ANYTHING ELSE - GETS ZEROED BY PICON!!!
JBTFPN:	BLOCK JOBN	;PPN OF PROGRAM LAST RUN OR CURRENTLY
			;BEING RUN BY THIS JOB.  (0 IF PROGRAM
			;CAME FROM MAGTAPE.).
	INTERNAL JBTLIC,JBTFPN,JBTAUN,JBTUNM,JBTUN1,JBTLIM,JBTSLC
JBTAUN:	BLOCK JOBN
JBTUNM:	BLOCK JOBN
JBTUN1:	BLOCK JOBN
JBTLIM:	BLOCK JOBN
JBTDLK:	BLOCK JOBN	;LOOKUPS
JBTERN:	BLOCK JOBN	;ENTERS AND RENAMES
JBTSLK:	BLOCK JOBN	;LOOKUPS*SIZE
JBTSER:	BLOCK JOBN	;ENTERS AND RENAMES*SIZE
JBTSIN:	BLOCK JOBN	;DISK BLOCKS READ*SIZE
JBTSOT:	BLOCK JOBN	;DISK BLOCKS WRITTEN*SIZE
JBTCIN:	BLOCK JOBN	;CHRS IN
JBTCOT:	BLOCK JOBN	;CHRS OUT
JBTELP:	BLOCK JOBN	;ELAPSED TIME*SIZE
JBTCNK:	BLOCK JOBN	;CONNECT TIME (DETACHED NOT COUNTED)
JBTBCS:	BLOCK JOBN	;BREAK CHRS *SIZE
JBTSOK:	BLOCK JOBN	;FROM SOAKEM UUO
JBTCMP:	BLOCK JOBN	;MICRO CYCLES FROM DK10
JBTCP2:	BLOCK JOBN	;HIGH ORDER PART OF MICRO CYCLES
JBTCPU:	BLOCK JOBN	;HIGH ORDER BITS OF MICRO CYC*SIZE

INTERNAL JBTDLK,JBTSLK,JBTSER,JBTSIN,JBTSOT,JBTCIN,JBTCOT
INTERNAL JBTELP,JBTCNK,JBTBCS,JBTCMP,JBTCPU,JBTERN,JBTSOK,JBTCP2

INTERNAL JBTABT

JBTABT:	BLOCK JOBN	;ROUTINE TO CALL ON SWAP ERROR OR ILL MEM REF


INTERNAL JBTBET,JBTBIO		;BLOCK I/O USAGE TABLES.

JBTBET:	BLOCK JOBN		;ELAPSED TIME IN BLOCK I/O MODE (IN SECONDS)
JBTBIO:	BLOCK JOBN		;BIO CHARS IN/OUT

JBTAJF::BLOCK JOBN		;# FAULTS FOR PAGES IN UWS BUT NOT
				;IN MWS (# FAULTS CCAUSED BY MWS
				;ADJUST ALGORITHM)

JBTSCA::BLOCK	JOBN			;TRU scaling word

JBTENB:	BLOCK JOBN	;CHANELS ENABLED. BIT 0 IS 1 IF PI SYSTEM
			;IS ENABLED, BITS 1-35 INDICATE CHANELS ENABLED

JBTPIP:	BLOCK JOBN	;CHANELS IN PROGRESS. BITS 0 INDICATES
			;OLD APRENB SYSTEM. IF BIT 0=1 BITS 1 IS TRAP
			;IN PROGRESS. IF BIT 0=0 BITS 1-35 ARE THE
			;CHANELS IN PROGRESS

JBTAWQ:	BLOCK JOBN	;CHANELS AWAITING REQUEST. IF BIT0=1
			;MEANS TAKE A TRAP AS SOON AS POSSIBLE
			;IF OLD STYLE APRENB, ALL BITS BUT BIT 0 USED
			;TO STORE FLAGS GIVING REASON FOR TRAP

;THIS MAY NOT GO AWAY

;BITS 0-5 UUO TRAP NUMBER
;BITS 6-11 CLOCK TRAP NUMBER
;BITS 12-17 PAGE TRAP NUMBER
;BITS 18-23 HUNG DEVICE TRAP NUMBER
;BITS 24-29 TIMER TRAP NUMBER
;BITS 30-35 DEVICE ERROR TRAP NUMBER


INTERNAL JBTENB,JBTPIP,JBTAWQ


	INTERNAL JBTPRV
JBTPRV:	BLOCK JOBN		;PRIVILEGE BITS FOR JOB SET BY LOGIN

QUEPCB:: BLOCK	JOBN		;PCBIO DATABASE AREA.
JBTPCB:: BLOCK	JOBN		;FOR LAYOUT, SEE PCBIO MODULE.

JBTCLB: BLOCK JOBN		;TABLE USED BY
INTERN	JBTCLB			;THE CLUB FACILITY.

JBTINA:: BLOCK	JOBN		;INACTIVITY TIMEOUT
				;LH - LIMIT
				; NOTE THAT THIS FIELD IS MUCH LARGER THAN
				; IT NEEDS TO BE
				;RH - # MIN SINCE JOB LAST RAN

;THE FOLLOWING ARE USED TO CREATE MXQUE
;THE MAXIMUM QUEUE SIZE, USED BY SWAPPING SCHEDULER (SCHED)
	XP	MXQUE,0

	DEFINE	X	<MXQUE==MXQUE+1;>
	QUEUES
DEFINE	X	(A)

		<A'Z==MXQUE
		MXQUE==MXQUE+1;>
	CODES
		MXQUE==MXQUE+4

	INTERNAL JBTQ,JBQMN

	BLOCK MXQUE		;NUMBER OF QUEUES FOR SWAPPING SCHEDULER
JBTQ:	BLOCK JOBN		;ONE ENTRY PER JOB,
				; LH=PREVIOUS JOB, RH=NEXT JOB IN QUEUE
				; NEGATIVE MEANS THIS IS FIRST (LH) OR LAST (RH)
				; JOB IN QUEUE
	JBQMN==JBTQ-NULZ		;J1
;THE FOLLOWING GLOBALS ARE USED IN VARIOUS ROUTINES SUCH AS
;ONCE,SCNSER,DLSINT,BTHINT,ETC.

IFNDEF PPORTN,<PPORTN==:<JOBN/4>*2>
IFNDEF RPORTN,<XP RPORTN,PORTN-PPORTN>
IFNDEF PORTN,<XP PORTN,RPORTN+PPORTN>
IFG <PORTN-^D255>, <
	PRINTX MORE THAN 255 PORTS!!!
	QQQQQ
>
IFL <RPORTN-^D11>, <
	PRINTX MUST HAVE AT LEAST 11 REAL PORTS
	QQQQQ
>
XP RMXLIN,RPORTN-1	;"REAL" PORT #S ARE BELOW RPORTN,
			;PTY PORT #S ARE ABOVE RMXLIN

SCNN==JOBN+PORTN+1	;Number of TTY DDBs - enough for all jobs
			; plus all ports (TTY, AUX CIR, PTY, CTY).
IFG <SCNN-^D255>,<
IF2,<PRINTX More than 255 TTY DDBs requested - allocating 255 only.>
SCNN==^D255>
XP MXLIN,PORTN-1
NFLG==<PORTN+^D36>/^D36
XP NMXFLG,-NFLG
XP NMXLIN,-PORTN
XP LINMXL,<<MXLIN>B26>

ACTN==1			;NUMBER OF ACCOUNTING DDBS

	INTERN TTYTAB,COMFLG,NCMFLG

;TTYTAB IS A TABLE OF CONTROLLING (ATTACHED) TTY'S FOR EACH JOB,
;INDEXED BY JOB NUMBER. IF C(TTYTAB)=0 THEN NO TTY IS ATTACHED.
;OTHERWISE, RH(TTYTAB(N)) IS CONTROLLING DDB FOR JOB N.

TTYTAB:	BLOCK JOBN

;COMFLG is a bit table with one bit per frame, indicating whether
; there is a command pending for that frame.  Whenever the
; COMFLG bit is set for a particular frame, the "command
; request" bit (CMDCMR) in the left half of TTYTAB should also
; be set.
CFLG==<JOBN/^D36>+1	;Number of entries in COMFLG table
XP NCMFLG,-CFLG
COMFLG:	BLOCK	CFLG

	SYSEND==.-1		;END OF CLEARED STORAGE ON RESTART


;ONCE ONLY CODE TO CREATE DEVICE DATA BLOCKS

	LOC SYSBG2		;PUT IN SYSTEM DATA AREA SO NOT TO TAKE
				; VALUABLE SPACE.  THIS AREA IS CLEARED
				; BY SYSINI AFTER IT HAS BEEN EXECUTED

COMMENT ! ROUTINE LINKDB
FUNCTION:  ONCE-TIME CODE TO ALLOCATE / CREATE / LINK DEVICE DDB'S,
FILSER CORE BLOCK, TTY DDB'S, AND VARIOUS OTHER SYSTEM DATA AREAS.
JSR HERE FROM ONCE CODE.

!

	INTERNAL LINKDB
	EXTERNAL DSKDDB,EVMALC,EVAMAX

LINKDB:	0
				;SO THAT E.G. SAT TABLES MAY BE SCANNED
				; BE OVERLAYED BY MULTIPLE DEVICE DATA
				; BLOCK GENERATION)

EXTERN STRDDB,STRNAM,QUESTR
	MOVE	T1,STRNAM+STRDDB ;STORE ADDR OF FASTEST (ONLY)
	MOVEM	T1,QUESTR	;STR FOR QUEUEING CUSPS.

	MOVSI	P1,INTNUM	;NEG NUMBER OF ENTRIES IN TABLE
	MOVEI	F,DEVLST-DEVSER ;MAKE DEVLST LOOK LIKE DEVSER IN A DDB
LOOP:	MOVE	P2,INTTB1(P1)	;GET NEXT DEVICE DATA BLOCK ADDRESS
	JUMPE	P2,NEXT		;0 MEANS NO DOB FOR DEVICE
	CAIN	F,(P2)		;IS THIS THE SAME AS LAST TIME (DSK)
	  JRST	NEXT		;YES, IGNOREM
	MOVE	M,DEVMOD(P2)
	TLNN	M,DVTTY		;IS IT TTY
	  JRST	NTYLNK		;NO
	MOVEM	P2,FRETTY
	MOVEM	F,TTYFLK
	JRST	TTYLNK
NTYLNK:	HRLM	P2,DEVSER(F)	;YES, STORE IN PREVIOUS DEVICE DATA BLOCK
TTYLNK:	HRRZ	F,P2		;MAKE F POINT TO CURRENT DOB
	LDB	M,[POINT 8,INTTAB(P1),8] ;GET NUMBER OF DDB'S
	HLRZ	U,DEVSER(F)	;MULTI FT'S ARE ALREADY LINKED.
	JUMPE	U,NOTFT
	HRRZI	F,(U)		;FT.
	HLRZ	U,DEVSER(F)	;FIND
	JUMPN	U,.-2		;LAST
	JRST	NEXT		;ONE.
NOTFT:	SOJLE	M,NEXT		;ONE OR LESS ?
	HRRZ	U,F		;NO, CREATE MULTIPLE COPIES OF DOB
				; SAVE ORIGINAL IN U
	MOVEI	P3,1		;STARTING WITH DEV1,DEV2,DEV77
	LDB	P4,PUNIT	;START UNIT NUMBER FROM
				; ASSEMBLE DEVICE DATA BLOCK
				; PTY STARTS UNIT NUMBER AT 1 INSTEAD OF 0
				; ALTHOUGH DEVICE NAMES ARE PTY0,PTY1,ETC.

MULDDB:	HLRZ	T2,INTTB1(P1)	;Size of these DDB's
	PUSHJ	P,EVMALC	;Allocate EVM for new DDB
	HRLM	T1,DEVSER(F)	;Point previous DDB to new one
	HRL	F,U		;Set up BLT word
	HRR	F,T1		;Make new DDB the current one
	ADDI	T1,(T2)		;Last word to be BLT'ed +1
	MOVE	T3,F		;KL SMASHES BLT AC
	BLT	T3,-1(T1)	;MOVE ORIGINAL TO FREE STORAGE
	MOVE	PG,[POINT 6,DEVNAM(F),17] ;BYTE POINTER TO NEWLY CREATED
				; DDB PHYSICAL NAME
	MOVE	J,P3		;MAKE COPY OF UNIT NUMBER
	TRNN	J,70		;IS IT 10 OR MORE ?
	  JRST	SMALL		;NO
	ROT	J,-3		;YES, CONVERT HIGH ORDER OCTAL DIGIT TO
	ADDI	J,20		;SIXBIT
	IDPB	J,PG		;AND STORE
	TRZ	J,-1		;CLEAR OUT HIGH ORDER DIGIT
	ROT	J,3		;MOVE LOW ORDER DIGIT BACK
SMALL:	ADDI	J,20		;CONVERT LOW ORDER DIGIT IN SIXBIT
	IDPB	J,PG		;AND STORE IN PHYSICAL NAME
	ADDI	P4,1		;INCREMENT BINARY UNIT NUMBER
	DPB	P4,PUNIT	;STORE UNIT NUMBER
	CAIGE	P3,(M)		;COMPARE WITH HIGHEST DEVICE NUMBER
	AOJA	P3,MULDDB	;DO ANOTHER COPY
	HRRZS	DEVSER(F)		;REMOVE THE LINK
NEXT:	MOVE	P3,DEVMOD(F)
	TLNE	P3,DVTTY
	  MOVE	F,TTYFLK	;NO BACK TO REAL LINKING
	AOBJN	P1,.+1		;MOVE BY TWOS
	AOBJN	P1,LOOP		;ANY MORE DEVICES
	MOVEI	P1,0		;NO, FLAG END OF DDB CHAIN WITH 0 LINK
	HRLM	P1,DEVSER(F)	;YES, STORE 0 IN CASE LAST DDB IS MULTIPLE
TMPALC:	MOVEI	T2,TMPSZT	;Total storage for TMPINI
	PUSHJ	P,EVMALC	;Allocation base address returned in T1
	HRLI	T1,TMPSZ
	MOVEM	T1,TMPTAB	;FREE DATA SPACE,ADDRESS OF TABLE
	HRLZI	T1,TMPSZJ
	HRRI	T1,TMPBKS
	MOVEM	T1,TMPTAB+1	;USER QUOTA,NUMBER OF BLOCKS IN AREA

EXTERN LDBLEN,SCNLDB,LDPLNO,TTYFLK,FRETTY	;SCNSER GLOBALS

;FOLLOWING CODE ALLOCATES SPACE FOR THE LINE DATA BLOCKS & FOR CHARACTER LISTS

LINALC:	HLRZ	T2,TTCLST	;Number of bufferlets
	IMULI	T2,TTCHKS	;Times chunk size
	ADDI	T2,3		;In case misaligned
	PUSHJ	P,EVMALC	;Allocate storage
	ADDI	T1,3
	TRZ	T1,3		;MAKE SURE A MULTIPLE OF 4
	HRRM	T1,TTCLST	;SAVE AS FIRST CHARACTER CHUNK ADDR

LDBALC:	MOVSI	J,-PORTN-1	;Enough for zero through PORTN
	MOVEI	T2,LDBLEN	;Constant throughout loop
LNKTTL:	PUSHJ	P,EVMALC	;Allocate one LDB (Size in T2)
	HRRM	T1,LINTAB(J)	;Store address into table
	HRLI	U,SCNLDB	;GET THE ADR OF THE PROTO LDB
	HRRI	U,(T1)		;Rest of BLT word
	ADDI	T1,(T2)		;Last word of BLT target + 1
	MOVE	T3,U		;KL SMASHES BLT AC
	BLT	T3,-1(T1)	;COPY THE LDB
	DPB	J,LDPLNO	;STORE PHYSICAL LINE NUMBER IN LDB
	AOBJN	J,LNKTTL	;NO. MAKE ANOTHER ONE

;ALLOCATE BUFFER FOR SNOOP HISTOGRAMS, IF ANY DESIRED

SNBALC:	SKIPN	T2,HFDBUF	;SIZE NONZERO IN LH?
	  JRST	NOSNBF		;NO, ALLOCATE NOTHING FOR SNOOPING
	HLRZS	T2		;T2/0,,MAX HISTOGRAM SIZE FOR SNOOPING
	PUSHJ	P,EVMALC	;Returns base address in T1
	HRRM	T1,HFDBUF	;HFDBUF/SIZE,,BEGINNING LOCATION
NOSNBF:	;DONE SNOOP BUFF ALLOC
	EXTERN CMBLNK,CORNUM,SYSCOR,CMBSIZ,CORBAS

FILALC:	MOVE	T2,CORNUM	;Number of core blocks
	IMULI	T2,CMBSIZ	;Times block size gives total storage
	PUSHJ	P,EVMALC	;Allocate, returns base in T1
	MOVEM	T1,CORBAS	;REMEMBER START OF FILSER FREE CORE SO CAN
				; COMPUTE ATB POINTERS, WHICH ARE RELATIVE.
	HRLZM	T1,SYSCOR	;FIRST FREE FILSER CORE BLOCK
	MOVE	T2,CORNUM	;GET # OF BLOCKS TO BE GENERATED
	ADDI	T1,CMBSIZ	;COMPUTE ADR. OF NEXT BLOCK
	HRLZM	T1,-CMBSIZ+CMBLNK(T1) ;YES - SAVE ADR. OF NEXT BLOCK IN THIS BLOCK
	SOJG	T2,.-2	;FINISHED YET?
	SETZM	-CMBSIZ+CMBLNK(T1)	;YES - ZERO LINK IN LAST BLOCK TO SIGNALEND OF LIST
	JRST @LINKDB		;RETURN TO CALLER


	EXTERNAL TMPTAB

;MORE PARAMETERS FOR TEMPORARY IN-CORE FILE STORAGE FOR SHORT (CCL) FILES

TMPNX==JOBN*^D20	;IF SIZE OF SPACE NOT SET, DEFAULT VALUE
TMPBKS==<TMPNX+TMPBL>/<TMPBL+1>	;NUMBER OF BLOCKS (LINKED LIST) IN AREA
TMPSZ==TMPBKS*TMPBL		;NUMBER OF DATA WORDS AVAILABLE
TMPSZT==TMPBKS*<TMPBL+1>		;TOTAL TABLE LENGTH (ROUNDED)
TMPBKJ==<<^D60+TMPBL>/<TMPBL+1>> ;USER SPACE QUOTA. DEFAULT VALUE
TMPSZJ==TMPBKJ*TMPBL		;QUOTA OF DATA WORDS PER USER


				; (DO NOT DESTROY ONCE)
				; FLAG NON-ZERO IF CALLED BY JRST LINKDB
				; (OK TO DESTROY ONCE CODE)

	INTERN DDSTAR
DDSTAR:	Z		;STARTING ADDR OF STR DATA BLOCKS ETC. IN HIGH CORE
			;(USED BY ONCMOD AND REFSTR)


;;MACROS TO DEFINE PI CHANNEL NUMBER AND GENERATE INTERRUPT CHAINING
;; INFORMATION FOR ONCE SO IT CAN LINK THE DEVICE INTERRUPT SERVICE
;; ROUTINES AND THE DEVICE DATA BLOCKS

;;TABLE INTTAB IS GENERATED WITH PAIRS OF ENTRIES FOR EACH DEVICE
;; WHICH HAS A DEVICE DATA BLOCK
;;FIRST WORD: BIT 0==1 IF DECTAPE, BITS 1-9==NUMBER OF DDBS, BITS 9-17==PI
;; CHANNEL (0-7) WHERE 0 MEANS NO PI CHANNEL (E.G., PTY)
;;SECOND WORD: LH==0 IF SINGLE DEVICE,==LENGTH OF DDB IF MULTIPLE, RH==DDB ADDRESS

;;MACRO FOR DEVICES WHICH ARE ALWAYS PRESENT (AND WHICH DO NOT USE A
;; CHANNEL SAVE ROUTINE AND HAVE NO DDB)  EXAMPLES ARE APR, CTY, PEN, CLK...

;DEFINE SPASGINT (DEV,PI) <
;	DEV'N==1
;			ASGINT DEV,PI
;>

DEFINE ASGINT (DEV,PI) <
	IFG DEV'N, <IFG PI, <
	IFE <PI-.CH>, <.CHAS==1		;;CHANNEL PI IN USE.
>
	UNASS'PI==0		;;MARK CHANNEL AS ASSIGNED
	INTERNAL DEV'CHN
		DEV'CHN==PI
	EXTERNAL DEV'INT		;;INTERRUPT SERVICE CONSO INSTRUCTION
		XWD PI,DEV'INT	;;GENERATE INTERRUPT ENTRY POINT FOR ONCE
		XWD 0,0		;;NO DDB TO CHAIN TOGETHER
	ASGIN1 DEV,\PI
>>
>

DEFINE ASGIN1 (DEV,PI) <
	IFDEF	CH'PI, <		;;WAIT TILL PASS 2 TO DEFINE
		DEV'CHL==CH'PI
		INTERNAL DEV'CHL
>>

;;MACRO FOR OPTIONAL DEVICES WHICH ALWAYS USE A CHANNEL SAVE ROUTINE
;; (EXAMPLES: CDR, DSK, PTR, ETC.  ALSO PTY WITH 0 PI)

;DEFINE SPASGDDB (DEV,PI,NUM) <
;	DEV'N==NUM
;	NOSAV==1
;	ASGSAV DEV,PI
;>


DEFINE ASGSAV (DEV,PI) <
	IFG DEV'N, <IFG PI, <
	UNASS'PI==0		;;MARK CHANNEL AS ASSIGNED
IF2, < IFNDEF DEV'INT, <EXTERNAL DEV'INT>>	;;INTERRUPT SERVICE CONSO INSTRUCTION
>
IF2, < IFNDEF DEV'DDB, <EXTERNAL DEV'DDB>>	;;DEVICE DATA BLOCK ADDRESS
	ASGSV1 DEV,\PI
	>>

;;MACRO FOR:	1. COMPLETION OF THE DEFINITION REQUIRED FOR THOSE
;;		   DEVICES INVOKING THE ASGSAV MACRO
;;		2. COMPLETE DEFINITION FOR THOSE DEVICES WITH THEIR INTERRUPT
;;		   ENTRY POINT AND DDB'S HERE IN COMMON  (EXAMPLE: LPT'S)

DEFINE ASGSV1 (DEV,PI) <
	IFG PI, <
	IFE <PI-.CH>, <.CHAS==1		;;CHANNEL PI IN USE.
>
		DEV'CHN==PI		;;DEFINE DEVICE CHANNEL NUMBER
		INTERNAL DEV'CHN	;;DECLARE INTERNAL - ONLY IF DEVICE WANTED
IFE NOSAV,<
	ASGSV2 DEV,PI
>
>

	DTBIT==0			;;ASSUME THIS IS NOT A DECTAPE
	IFIDN <DEV> <DTA>, <DTBIT==1>	;;IS IT P-10 DECTAPES ?
	IFIDN <DEV> <DTC>, <DTBIT==1>	;; OR P-6 DECTAPES ?

	IFE PI, <
		XWD DEV'N*1000+0,0	;;NO PI CHANNEL FOR THIS DEVICE
	>
	IFG PI, <
		XWD DTBIT*400000+DEV'N*1000+PI,DEV'INT	;;FIRST WORD OF INTTAB ENTRY
		IFE DEV'N,<EXTERNAL DEV'INT> ;;LEVEL D DISK IN COMMOD
	>

	IFG DEV'N-1, <
		XWD DEV'DDS,DEV'DDB	;;MULTIPLE DEVICE SECOND WORD OF INTTAB ENTRY
		EXTERNAL DEV'DDS
	>
	IFE DEV'N-1, <
		XWD 0,DEV'DDB		;;SINGLE DEVICE SECOND WORD OF INTTAB ENTRY
	>
	IFE DEV'N,<
	0	;NO DDBS FOR DISK
		DEFBIT DEV
		DSKPIF==DSKPIF!DEV'BIT ;;KEEP LOG. OR OF PI OFF BIT FOR DSK CONTROLLERS
		DSKPIN==DSKPIN!DEV'BIT ;;AND FOR PI ON
	>
>		;;END ASGSV1 DEFINITION



;;MACRO'S TO ALLOW GENERATION OF MULTIPLE INTTAB ENTRIES FOR MULTIPLE
;; DEVICES SUCH AS U-PRINTERS

DEFINE MULASG (DEV,DE,PI,DSKFL) <
	IFG DEV'N, <
		UNASS'PI==0		;;MARK CHANNEL AS ASSIGNED
		ZZ==0
		REPEAT DEV'N, <
			DEVASG DE,\ZZ,PI,DSKFL
			ZZ==ZZ+1
		>
	>
>

DEFINE DEVASG (DE,X,PI,DSKFL) <
	IFE DSKFL,<DE'X'N==1
		ASGSV1 DE'X,\PI>
	IFL DSKFL,<DE'X'N=0	;-VE MEANS NO DDB GENERATED HERE
		ASGSV1 DE'X,\PI>
	IFG DSKFL,<	;DISK
		NMCLC (XX,DE,X,<A,B,C,D,E,F,G>)
		IFN XX,<DE'X'N==0	;SOME UNITS ON CONTROLER
			ASGSV1 DE'X,\PI>>>

;;MACROS TO CONTROL ASSIGNMENT OF PI CHANNELS TO DEVICES

DEFINE NEXTCH < .CH==.CH+1		;;START ASSIGNING TO NEXT LOWER CHANNEL
.CHAS==0
NEXTCU \.CH	
>
DEFINE NEXTCQ <	IFN .CHAS, <NEXTCH>>	;;START ASSIGNING TO NEXT LOWER CHANNEL IF
					;; CURRENT CHANNEL HAS BEEN USED.
DEFINE NEXTCU (N) < IFDEF UNIQ'N, < IFN UNIQ'N, <NEXTCH>>>	;;TO SKIP OVER ANY
					;; SPECIALLY SPECIFIED CHANNELS (RECURSIVELY!)

DEFINE DEFBIT (DEV) <
	DEV'BIT==1
	REPEAT 7-DEV'CHN, <DEV'BIT==DEV'BIT*2>
>

;;INITIALLY ASSUME NO PI CHANNEL SAVE ROUTINES NEEDED

	USED1==0
	USED2==0
	USED3==0
	USED4==0
	USED5==0
	USED6==0
	USED7==0

;;ALL CHANNELS ARE INITIALLY UNASSIGNED

	UNASS1==1
	UNASS2==1
	UNASS3==1
	UNASS4==1
	UNASS5==1
	UNASS6==1
	UNASS7==1


;MACRO TO ALLOW GENERATION OF CHANNEL SAVE ROUTINES ONLY

;DEFINE SPASGSAV (DEV,PI,%ACNUM) <
;	HIGAC'PI==%ACNUM
;	DEV'HAC==%ACNUM
;INTERNAL HIGAC'PI,DEV'HAC

;	ASGSV2 DEV,PI
;>

DEFINE ASGSV2 (DEV,PI) <
		USED'PI==1		;SET FLAG SO THAT A CHANNEL SAVE
					; ROUTINE WILL BE GENERATED FOR
					; THIS PI CHANNEL

IFDEF DEV'ACB,<;DEFINED IF A KL10 AND AC BLOCK ALLOCATED TO THIS DEVICE'S CHANNEL
	IFDEF ACBPI'PI,<IFN DEV'ACB-ACBPI'PI,<PRINTX CONFLICTING AC BLOCK ASSIGNMENTS
		QQQQQQ>>
	ACBPI'PI==<DEV'ACB>	;NEGATIVE IS FLAG FOR CHANNEL
				; MACROS TO GENERATE DIFFERENT CODE.
>;END IFDEF DEV'ACB

	IFDEF SAV'PI, <		;WAIT TILL CHANNEL SAVE ROUTINES
					; ARE DEFINED BELOW (IN PASS 2)

		DEV'SAV==SAV'PI		;CHANNEL AC SAVE ROUTINE LOCATION
		DEV'RET==RET'PI		;CHANNEL AC RESTORE ROUTINE LOCATION
					; (USUALLY POPJ USED)
		DEV'CHL==CH'PI		;LOCATION WHERE INTERRUPT PC IS STORED
		DEV'SAC==SAVAC'PI	;STARTING CHANNEL SAVE LOCATION FOR AC'S
		DEV'P==CH'PI'P	;LOCATION WHERE P STORED
		DEV'JEN==CH'PI'JEN	;LOCATION WHERE INT. IS DISMISSED

		INTERN DEV'SAV, DEV'RET, DEV'CHL, DEV'SAC,DEV'P,DEV'JEN
>>



;NOW GENERATE THE TABLE FOR ONCE AND DEFINE PI CHANNEL ASSIGNMENTS

	INTERNAL INTTAB,INTTB1,INTNUM,SCNN,DSKPIF,DSKPIN

				; ONE FOR EACH JOB + NULL JOB (EXTRA ONE)
		APRN==1		;ALWAYS AN APR
		CLKN==1		;ALWAYS LOWEST PRIORITY CLOCK
IFCPU (KI),<;DK10 ONLY AVAILABLE ON KI10
		TIMN==1		;ALWAYS A DK10
		TM2N==1		;SECOND DK-10 FOR TIMING
>;END IFCPU KI

IFCPU (<KI,KL,F3>),<
	DSKPIN==LI.CON	;SET PI ON BIT - WILL ALSO HAVE PI ON FOR DISK CONTOLLERS
	DSKPIF==LI.COF	;AND FOR PI OFF
> ;END IFCPU KI,KL,F3

INTTAB:			;TABLE OF DATA FOR DEFINING PI CHAN AND NUMBER OF DOB
	NOSAV==0	;DO NOT SUPPRESS GENERATION OF SAVE ROUTINES
	INTTB1==INTTAB+1

	ASGSAV SCN,0	;NO PI CHANNEL FOR SCNSER (AT CLOCK)
	ASGSAV ACT,0

.CHAS==0
.CH==0
NEXTCH		;BEGIN AT CHANNEL 1

IFCPU (<KI,KL,F3>),<
;THE FOLLOWING DEVICES MUST HAVE A UNIQUE, HIGH PRIORITY
; CHANNEL FOR BLOCK I/O TRANSFERS.


IFNDEF BLKMXC, <BLKMXC==.CH>	;REMEMBER THIS CHANNEL ON PASS 1
.CH==BLKMXC			;ON PASS 2, SKIP OVER BLKI CHANNELS


;THE FOLLOWING ARE GROUPED ON A CHANNEL FOR HIGH-PRIORITY DEVICES
	ASGSAV CDR,\.CH
> ;END IFCPU KI,KL,F3
	ASGINT APR,\.CH
IFCPU (KI),<;DK10S ONLY EXIST ON KI
	ASGINT TIM,\.CH
	ASGINT TM2,\.CH
>;END IFCPU KI

NEXTCQ

IFCPU (<KI,KL,F3>),<
;THE FOLLOWING ARE MEDIUM-PRIORITY DEVICES, AS A GROUP
	ASGSAV PTR,\.CH
	MULASG LPT,LP,\.CH,0
;	ASGSAV DTA,\.CH
;	ASGSAV DTC,\.CH
;	ASGSAV MTA,\.CH
;	ASGSAV MTB,\.CH
;	ASGSAV MTC,\.CH

NEXTCQ



;THE FOLLOWING ARE LOWER-PRIORITY DEVICES, AS A GROUP
				;FIRST ARE THE VARIOUS TYPES OF DISK CONTROLLERS....

	MULASG FHD,FH,\.CH,1
	MULASG DPC,DP,\.CH,1
	MULASG SAX,SA,\.CH,-1
	MULASG APX,AP,\.CH,-1
IFN SAXN,<
SAXCHN==SA0CHN
SAXSAV==SA0SAV
INTERNAL SAXSAV,SAXCHN>
IFN APXN,<APXCHN==:AP0CHN
APXSAV==:AP0SAV
>
	ASGSAV DSK,0	;GET DSK IN CHAIN, NO INTERUPT CODE (SEE ABOVE
	ASGSAV MAG,\.CH


DEFINE MNYASG(DE,UU)
<IRP UU,<IFNDEF DE'UU'UN, <STOPI>
	 IFDEF DE'UU'UN, <DE'UU'N==DE'UU'UN
			  ASGSAV DE'UU,0
			 >
	>
>

MNYASG(FT,<A,B,C,D,E,F,G,H,J,K,L>)


;	ASGSAV PEN,\.CH
	ASGSAV PTP,\.CH
;	ASGSAV CDP,\.CH
	ASGSAV PLT,\.CH

NEXTCQ

;THE DISPLAY GETS ITS OWN LOW-PRIORITY CHANNEL
;	ASGSAV DIS,\.CH

NEXTCQ
> ;END IFCPU KI,KL,F3

IFCPU (KS),<

;GEN INTTAB ENTRIES OF FORM: NO. OF DDBS, DEVINT
;			LENGTH OF DDBS , PROTOT DDB ADDR.
DEFINE GENDDB (DEV) <
	IFG DEV'UN,<
		EXTERN DEV'INT,DEV'DDS,DEV'DDB
		XWD DEV'UN*1000,DEV'INT
		XWD DEV'DDS,DEV'DDB>
> ;END DEF OF GENDDB.

;SET THE INTTAB ENTRY FOR THE DISK

EXTERN RMXINT
	XWD	0,RMXINT	;WORD 1 OF INTTAB
	0

	ASGSAV DSK,0
IFN LPTN,<1*1000,,0
	LP0DDS,,LP0DDB>

IFCPU(KS),<
	0,,MAGINT##		;Entry for tapes.  Note 0 "units" indicates
	MAGDDS##,,MAGDDB##	; the DDBs are already linked.
>;IFCPU(KS)END 

INTERNAL PIHIGH,PILOW

PIHIGH==3	;PI FOR DISK AND TAPE.
PILOW==2	;PI FOR OTHER DEVICES.

	DSKPIF==LI.COF!<1_<7-PIHIGH>>
	DSKPIN==LI.CON!<1_<7-PIHIGH>>
> ;END IFCPU KS.



;LAST IS THE SCHEDULER, ON CHANNEL 7 BY ITSELF

IFG <.CH-7>, <	PRINTX ;NOT ENOUGH PI'S TO SERVICE THIS CONFIGURATION.
		PRINTX ;SUGGEST EDITING COMMON TO PUT MORE DEVICES ON
		PRINTX ; A SINGLE CHANNEL
>

.CH==7
	ASGINT CLK,\.CH

;	SPCINT
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NOT USE A CHANNEL SAVE ROUTINE AND HAVE
				; NO DEVICE DATA BLOCK
;	SPCDDB
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				;WHICH HAVE MULTIPLE DEVICE DATA BLOCKS (0 MEANS NONE)
;	SPCSAV
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NEED A CHANNEL SAVE ROUTINE

;END OF THE ASSIGNMENT TABLE

	INTNUM==INTTAB-.	;-LENGTH OF INTERRUPT CHANNEL ASSIGNMENT TABLE

XP ITMCHN,APRCHN		;INTERVAL TIMER PI ASSIGNMENT SAME AS THAT OF APR.

IFCPU (KS),<
RM0VEC=254
MAGVEC=224
IFNDEF RM0UN,<RM0UN=4>
IFNDEF MAGUN,<MAGUN=1>
;GEN DISPATCH VECTOR TABLE ENTRIES.
DEFINE GENVEC (DEV), <
	IRP DEV
		<IFG DEV'UN,<
			IFNDEF DEV'INT,<EXTERNAL DEV'INT>
			XWD DEV'INT,DEV'VEC/4
			>
>
>

TBISAV:
	GENVEC <RM0,LPR,MAG>
	TBISIZ==.-TBISAV

INTERNAL TBISIZ,TBISAV
;EPT+EPTVIT WILL BE THE REAL TABLE, NO CONFLICT ASSUMED
;  BETWEEN THE DEVICE VECTOR ADDRESSES AND EPT DEFINED SLOTS
>;END IFCPU KS


	IFLE .-SYSEND, <LOC SYSEND+1>
				; SET LOC UP TO SYSEND+1, UNLESS ONCE ONLY CODE
				; IS BIGGER

;SYSTEM CONSTANTS AND PARAMETERS

INTERNAL CNFMXL,CONFIG,SYSDAT,MEMNSP,FREPTR,LOCORE
INTERNAL LGONAM

;; Negative indexes from CNFTBL are used by CRSHID and are not GETTAB-able.
;; Their position is subject to change and should not be published!

	CRSDB,,NUMTAB##		;(-2) so CRSHID can do "GETTABs"
CURUPT::0			;(-1) CONTAINS DATAO STUFF FOR CURRENT UPT

CNFTBL::;origin of GETTAB table 11 (configuration data)
	; octal numbers in () correspond to the index relative to CNFTBL
	; certain tools expect physical address 137 to point to CNFTBL
	; (these locations not cleared by SYSINI) 
CONFIG: SYSNAM			;(0-4) NAME OF SYSTEM, IN ASCII
	LOC CONFIG+5		; ALWAYS LEAVE 5 WORDS (24 CHARS)
SYSDAT: SYSDAT			;(5,6) GENERATE SYSTEM DATE
	LOC SYSDAT+2		; ALWAYS LEAVE 2 WORDS (9 CHARS)
SYSTAP: SYSDEV			;(7) NAME OF SYSTEM DEVICE, IN SIXBIT
;LOCATIONS SETUP BY ONCE ONLY OPERATOR DIALOGUE AND NEVER RESET ON RESTARTS
INTERNAL SYSSZP,MEMSZP
EXTERNAL PATCH
TIME::	0			;(10) TIME OF DAY IN JIFFIES (60TH OR 50THS OF A SEC)
THSDAT::0			;(11) TODAY'S DATE ((Y-1964)*12+(M-1))*31+(D-1)
SYSSIZ::exp PATCH		;(12) SIZE OF MONITOR (FIRST LOC NOT USED)
INTERN HGHBLK
DEVOPR::sixbit /CTY/		;(13) SIXBIT PHYSICAL NAME OF OPERATORS CONSOLE
				; (IF THIS LOCATION CONTAINS 0, NONE HAS
				; BEEN DESIGNATED)
				; PUBLIC LOGICAL NAME "OPR" WILL BE THIS
				; DEVICE. ALSO UNEXPLAINED MONITOR ERROR
				; MESSAGES WILL BE TYPED ON TTY OPR:
DEVLST::xwd 0,0			;(14) LH CONTAINS ADDRESS OF FIRST DEVICE DATA BLOCK
				; ONCE ONLY CODE LINKS DEVICE DATA BLOCKS
	xwd 0,JOBN		;(15) AOBJN POINTER TO 1ST HIGH SEG IN JBTXXX TABLES
				; LH= - NUMBER OF HIGH SEGS,  RH= 1ST HIGH SEG NUMBER
				;(NO MORE HISEGS, BUT SOME USE THIS
				; TO GET NUMBER OF JOBS, USE C(RH)-1)
	0			;(16) FLAG TO INDICATE WHETHER BOTH HARDWARE AND
				; SOFTWARE HAVE 2 RELOC REG CAPACITY
				; NON-ZERO IF BOTH DO, 0 IF EITHER OR BOTH DO NOT
				; SET BY ONCE ONLY CODE

;STATES WORD LH BITS:
	ZZ==0
	ZZ==ZZ!1B0		; 1 IF DISK SYSTEM (ANALOGOUS TO FTDISK)
	ZZ==ZZ!1B1		; 1 IF SWAPPING SYSTEM (ANALOGOUS TO FTSWAP)
	ZZ==ZZ!1B2		; 1 IF LOGIN (ANALOGOUS TO FTLOGIN)
	ZZ==ZZ!1B3		; 1 FOR TTCALL, FULL DUPLEX
	ZZ==ZZ!1B4		; 1 IF PRIVILEGE FEATURE INCLUDED
	ZZ==ZZ!1B5		; 1 IF REENTRANT SOFTWARE
	ZZ==ZZ!1B9		; 1 IF LEVEL D DISK SOFTWARE
	IFN INDPPN,<ZZ==ZZ!1B10>; 1 IF INDEPENDENT PROJ-R NUMBERS
	ZZ==ZZ!1B11		; 1 FOR IMAGE, 8-BIT SCNSER

;STATES WORD RH BITS(INDICATE OPERATIONAL STATE OF SYSTEM):
COMMENT $ AAA OCT 76 HERE REMOVE OBSOLETE COMMENT CLAIMING
 THAT 1B35 MEANS NO LOGIN EXCEPT FROM CTY, 1B34 MEANS NO LOGIN
 FROM REMOTE TTYS..DONT ANSWER RINGING DATA SETS. CONFIG SETS
 "REMOTE" BIT IN LINTAB.
STATES WORD BITS: (DEFINED IN S.MAC)
STAUTO	;1 IF SYSTEM IN AUTO-RESTART 
STSHUT	;1 IF SYSTEM SHUT
STSUPR	;1 IF SYSTEM SUPER-SHUT
STMDED	;1 IF CHKPNT WATCHDOG FOUND CHKPNT DEAD         
STRLB	;1 IF RESTRICTED LOGINS. SEE LOGINN, NONRES-7. AAA   $

STATES::exp ZZ!STAUTO!STSHUT!STSUPR ;(17) LH BITS=TYPE OF SYSTEM
				; RH PATCHED BY "SCHED" COMMAND TO
				; INDICATE OPERATIONAL STATE OF SYSTEM
SERIAL::exp APRSN		;(20) SERIAL NUMBER OF CENTRAL PROCESSOR (APR)
MEMNSP:	exp NSPMEM		;(21) NANO-SEC PER MEMORY CYCLE
FREPTR:: 0			;(22) AOBJN WORD POINTING TO USE BIT MAP OF
				; MONITOR FREECORE BLOCKS. SET BY ONCE
				; NEVER CHANGED WHILE MONITOR RUNS.
LOCORE:: 0			;(23) LH=0, RH=ABS. ADR. OF 1ST FREECORE CHUNK
				; SET BY ONCE ONLY CODE AND NEVER CHANGED WHILE
				; MONITOR RUNS.
NUMLIN:	exp PORTN		;(24) # OF PORTS
LGONAM:	sixbit .LOGOUT.		;(25) NAME OF LOGOUT PROGRAM
JFYSEC:	0			;(26) JIFFIES/SEC
JFYMIN:	0			;(27) JIFFIES/MIN
JFYHR:	0			;(30) JIFFIES/HOUR
HGHBLK:	0			;(31) HIGHEST BLOCK IN ADRESSABLE CORE
HFDBUF::xwd M.SBSZ,0		;(32) HISTOGRAM FACILITY (SNOOPY)
				; BUFF PTR. 0 IF NONE ALLOCATED BY LNKDB
				; (STANDARD); ELSE SIZE,,BEG LOC
SYSNUM::.-.			;(33)SYSTEM NUMBER, FILLED IN BY ONCE ONLY.
FRECOR::exp FCWDS		;(34)AMOUNT OF FREECORE ALLOCATED
CRSCNT:	exp ^D1800		;(35)TICS ALLOWED FOR SOFT CRASH
	SAV30,,NUMTAB##		;(36)ADDRESS OF THINGS FOR CRSHID
extern	PATCH,PATEND,TTYINI,TTIEND
DSKPAT:	PATCH-PATEND,,PATCH	;(37)AOBJN pointer to PATCH area patches
RUNPAT:	TTYINI-TTIEND,,TTYINI	;(40)AOBJN pointer to TTYINI area patches
CNFCPU::CPUTYP			;(41)cpu model index (KI,KL,KS,F3)
PATMAP::0			;(42)bit mask of patches installed
CNFSID::;SYSID			;(43)sixbit monitor ID (serial number)
SYSIDL##,,SYSIDR##; work around MACRO/LOADER bug regarding 36bit externs

;* * *
;* * * THIS IS THE END OF THE CONFIG GETTAB TABLE: add new entries above
;* * *
CNFMXL==<.-CNFTBL-1>B26		;MAXIMUM ENTRY IN CNFTBL FOR GETTAB M

;REMOTE PORT STUFF

IFE NUMPRT,<
XP VALRMT,CPOPJ
XP IDLRMT,CPOPJ
XP DDT620,CPOPJ
XP CRERMT,CPOPJ
XP ZAPRMT,CPOPJ
XP RMTRSI,CPOPJ
XP CKRMT,CPOPJ	;THESE ROUTINES NOT REALLY THERE
XP RMTINI,CPOPJ
CH2RMT::	JRST (T1)	;DOES NOTHING OF NO RMTSER
>

;GETTAB TABLE OF QUEUE CODES FOR JOBS - TABLE(RH)=25
;MUST BE A SEPARATE TABLE SINCE THE NUMBER OF ENTRIES VARIES ACCORDING
;TO THE CONFIGURATION

;ENTRIES ARE 2 SIXBIT CHARACTERS, THREE PER WORD
;STATE CODE 0 IS LEFT THIRD, 1 IS MIDDLE THIRD, 2 IS RIGHT THIRD OF FIRST WORD
;STATE CODE 3 IS LEFT THIRD OF SECOND WORD, ETC.

INTERN STSTBL,STSMXL

STSTBL:

DEFINE X(A,B,C)
<	IFE ZZ-ZZ/3*3-0,
  <	  XX==   <SIXBIT /A/&7777B11>B35>
	IFE ZZ-ZZ/3*3-1,
  <	  XX==XX!<SIXBIT /A/&7777B11>B47>
	IFE ZZ-ZZ/3*3-2,
  <	  XX==XX!<SIXBIT /A/&7777B11>B59
	  EXP XX>
ZZ==ZZ+1
>

ZZ==0
	QUEUES
	CODES
	IFN ZZ-ZZ/3*3-0,<
	  EXP XX>

STSMXL==<.-STSTBL-1>B26		;MAX ENTRY IN STSTBL FOR GETTAB M


INTERNAL ODPTBL,ODPMXL,SWPHGH,K4SWAP,ICPFAC,PROT,PROT0
INTERNAL DCN

EXTERN	DCNDFT			; Default DSKCLN bits from ONCDSK

ODPTBL:				;FIRST LOCATION IN MONITOR DATA AREA FOR DISK-
				; RELATED LOCATIONS WHICH ARE NOT SET TO 0 
				; WHEN THE SYSTEM IS STARTED UP.
				; ODPTBL IS GETTAB TABLE NUMBER 15.

SWPHGH:	0	; (obsolete)	;(0) HIGHEST LOGICAL BLOCK # ASSIGNED FOR 
				; SWAPPING. SPACE IS ASSIGNED FROM HIGHEST 
				; BLOCK # DOWNWARDS.

K4SWAP:	0	; (obsolete)	;(1) # OF J OF DISK WORDS SET ASIDE FOR 
				; SWAPPING. ASSIGNED AT ONCE ONLY REFRESH 
				; TIME.

ICPFACTOR==1			;FACTOR BY WHICH TO MULTIPLY AVERAGE SWAP-IN 
				; TIMES TO PRODUCE IN-CORE PROTECT TIMES.
	KXFTIM==0		;SET PROTECT TIMES TO 0
SEEKTM==0			;ONCE ONLY CODE MUST SET PROT,PROT0
				; DEPENDING ON FASTEST UNIT USED FOR SWAPPING

PROT:	EXP ICPFACTOR*KXFTIM	;(2) IN-CORE PROTECT TIME PARAMETER TO BE
				; MULTIPLIED BY <J-1> OF CORE IN JOB.

PROT0:	EXP ICPFACTOR*<SEEKTM+KXFTIM>;(3) IN-CORE PROTECT TIME PARAMETER TO 
				; BE ADDED TO ABOVE RESULT.

MXPROT::  EXP ^D60		;(4) MAX VALUE FOR ICPT FUNCTION, KEEP CORE 
				; FROM GETTING CLOGGED WITH HUGE JOBS WITH 
				; HUGE ICPT WHICH SCHEDULER DOESNT WANT TO 
				; RUN. /AA

DCN:	DCFULL+(DCNDFT)		;(5) DSKCLN TYPE DESIRED, DEF IS FULL,
				; INIT .HM

;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY
; ONCE ONLY CODE AND WHICH PERTAIN ONLY TO DISK SYSTEMS.
ODPMXL==<.-ODPTBL-1>B26		;MAXIMUM ENTRY IN ODPTBL FOR GETTAB M

;DISK LOCATIONS NOT IN GETTAB

INTERN REFLAG

REFLAG:	Z			;FLAG LOCATION TO INDICATE WHETHER ANY REFRESHING
				; OCCURRED AND TO CONTAIN THE [PROJ,R]
				; NUMBERS FOR AUTOMATIC LOG-IN FOLLOWING REFRESH.



;MORE DATA LOCATIONS SETUP AT ASSEMBLY TIME OR ONCE ONLY TIME
; BUT NOT OF INTEREST TO USER PROGRAMS

	INTERNAL PMONTB,MONTAB,MIDNIT
	INTERNAL JFYSEC,JFYMIN,JFYHR,JFYSC2,JFY2SC,QQYTTY,QQYSD


				; PROTECTED FROM I/O
;MONTH TABLE FOR DAYTIME COMMAND PRINTING

PMONTB:	POINT 6,MONTAB(T1),5	;POINTER TO NUMBER OF DAYS INMONTH
MONTAB:	EXP ^D30B5+"JAN"
	EXP ^D27B5+"FEB"
	EXP ^D30B5+"MAR"
	EXP ^D29B5+"APR"
	EXP ^D30B5+"MAY"
	EXP ^D29B5+"JUN"
	EXP ^D30B5+"JUL"
	EXP ^D30B5+"AUG"
	EXP ^D29B5+"SEP"
	EXP ^D30B5+"OCT"
	EXP ^D29B5+"NOV"
	EXP ^D30B5+"DEC"
MIDNIT: 0		;NO OF JIFFIES TILL MIDNIGHT
JFYSC2:	0		;JIFFIES IN 1/2 SEC
JFY2SC:	0		;JIFFIES IN 2 SEC
QQYTTY:	0		;JIFFIES IN 1/10 SEC
QQYSD:	0		;JIFFIES IN 1/10 SEC
SYSSZP:	0	;SYSTEM SIZE IN PAGES
MEMSZP:	0	;MEMORY SIZE IN PAGES
MAXPCB::0	;LARGEST PCB PAGE NUMBER
MINPCB::0	;SMALLEST PCB PAGE NUMBER

;TABLE TRANSLATING BIT NUMBERS TO BITS

	ZZ==1B0

BITTBL::REPEAT ^D36,<
	ZZ
	ZZ==ZZ_<-1>
>;END REPEAT ^D36

;Table which gives the absolute number of bit 0 in any given
; word in a bit table.  This is used by SCNSER and COMCON to
; determine what port or frame number a given bit in a given
; word corresponds to.
; NFLG is the number of words in SCNSER's LINFLG table;
; CFLG is the number of words in COMCON's COMFLG table;
; BFLG is MAX(NFLG,CFLG)+1 for safety.
BFLG==NFLG+1
IFG <CFLG-NFLG>,<BFLG==CFLG+1>
XYZZY==0
BITNTB:	REPEAT BFLG,<XYZZY
	XYZZY==XYZZY+^D36>
	INTERNAL BITNTB

;STOP PROCEDURE WHEN SHUTTING DOWN SYSTEM
;BECAUSE OF CATOSTROPHIC FAILURE OR ANY OTHER REASON
;TRANSFER HERE FROM LOC 147 OR DEPOSIT NON-ZERO IN 30

INTERNAL APRSTS,PISTS,BADINT,CRASHX,PAGCNI
INTERNAL SYSCRS,PAGDTI
IFCPU (KS),<INTERNAL HLTSTS,KAFPC>
IFCPU (KL),<INTERNAL TIMSTS,MTRSTS,SBDST1,SBDST2>
	EXTERNAL CRSHAC,FILSER	;DEFINED IN SYSINI TO BE 143 RESTART CODE
				;SO MONITOR CANNOT BE RESTARTED AT 143 AFTER
				;BEING STARTED AT 147.
FHD2==174		;DEVICE CODE FOR SECOND FIXED HEAD CONTROLLER
DPC==250		;DISK PACK CONTROL - NOT IN MACRO.SVE FOR SPMON
DPC2==254		;DEVICE CODE FOR SECOND DISK PACK CONTROLLER

BTMOUT==^D30		;WAIT 30 SECS FOR BASE TO DUMP ITSELF
			; INTO PDP10 MEMORY.

CRS147:	0			;JSR here from 147
	JRST	CRASHX
IFCPU (KS),<
KACRS:	JSR SYSCRS	;keep alive failure
>; IFCPU KS
BADINT:	0		;bad interrupts weve gotten

SUBTTL	CRSDB - crash data block definitions

IFCPU (KL),<
SBDST1:	4B4+0		;(-5) controller 4 (DMA20) + function 0
       	0		;(-4) result stored here
SBDST2:	4B4+1		;(-3) controller 4 (DMA20) + function 1
       	0		;(-2) result stored here
ERASTS::0		;(-1) error address register (RDERA)
>; IFCPU KL

IFCPU (KS),<
KAFPC:	0		;(-25) 4 word block for XPCW if keep alive fails
	0		;(-24)
	0		;(-23)
	KACRS		;(-22)
HLTSTS:	0		;(-21) MAG register
	0		;(-20) PC register
	0		;(-17) HR register
	0		;(-16) AR register
	0		;(-15) ARX register
	0		;(-14) BR register
	0		;(-13) BRX register
	0		;(-12) ONE (1) register
	0		;(-11) EBR register
	0		;(-10) UBR register
	0		;(-7) MASK register
	0		;(-6) FLG (flags,page fail code) register
	0		;(-5) PI register
	0		;(-4) XWD1 (1,,1) register
	0		;(-3) T0 register
	0		;(-2) T1 register
	0		;(-1) VMA (with flags)
>; IFCPU KS

CRSDB::	; * * * CRASH DATA BLOCK * * *
	; + index are processor independent
	; - index are processor dependent
	; CRSDB is pointed to by lh(CONFIG-2) so CRSHID can find it
;symbol				index  instruction          cpus
;------				-----  ----------- 	    ----
PISTS:		0		;(0)  CONI  PI,  (RDPI)	    ILS3
APRSTS:		0		;(1)  CONI  APR, (RDAPR)    ILS3
PAGDTI:		0		;(2)  DATAI PAG, (RDUBR)    ILS3
PAGCNI:		0		;(3)  CONI  PAG, (RDEBR)    ILS3
AIDSTS::	0		;(4)  BLKI  APR, (APRID)    .LS.
APRDTI::	0		;(5)  DATAI APR,     	    IL.3
		0		;(6)
		0		;(7)
		0		;(10)
		0		;(11)
		0		;(12)
		0		;(13)
		EPT,,CRSHAC	;(14) address of some useful stuff
; note - the old CRSHID knows the the position of these locations 
; relative to CRASHX - don't change them until old CRSHID is flushed
SAV30:		0		;(15) value of 30 saved here
STOPCN::	0		;(16) count of times we tried to crash
STOPPC::	0		;(17) real PC of first STOPCD we hit

SYSCRS:	0			;JSR here on bad error
CRASHX: SKIPE	STOPCN		;only go through here once
	 HALT	.+1
	AOS	STOPCN
	MOVEM 	17,CRSHAC+17	;SAVE ALL ACS
PISTS1:	RDPI 	PISTS		;STORE PI STATUS 
	WRPI 	LI.PIF
APRST1:	RDAPR 	APRSTS		;STORE APR STATUS
; note - old CRSHID knows <PISTS1-CRASHX> and <APRST1-CRASHX>

IFCPU(F3), <
OPDEF TNCONO [744000,,0]
	TNCONO	0		;RESET INTERFACE TO NODE
>;END IFCPU(F3)
IFNCPU (KI),<;IF KL OR KS, NEED TO SWITCH TO AC BLOCK 0 FIRST
	MOVE	17,CRSHAC+17	;GET 17 BACK
>;END IFNCPU (KI)
	RDEBR	PAGCNI		;save these before they get clobbered
	RDUBR	PAGDTI		
IFNCPU (KI),<;IF KL OR KS, NEED TO SWITCH TO AC BLOCK 0 FIRST
	WRUBR	[LG.LAB+0B8+0B11] ;SWITCH TO BLOCK 0
	MOVEM	17,CRSHAC+17	;SAVE 17 AGAIN
>;END IFNCPU (KI)
	MOVEI 17,CRSHAC		;SOURCE==0, DESTINATION==CRSHAC
	BLT 17,CRSHAC+16	;SO DDT CAN LOOK AT SAVED CRASH LATER

IFCPU(KL),< SWPUA               ;SWEEP CACHE TO MEMORY
        CONSO   APR,LP.CSD      ;SWEEP DONE?
         JRST   .-1             ;NOT YET
> ;END IFCPU(KL)

	MOVE	1,CRSHWD	;save what was in 30 before base zaps it
	MOVEM	1,SAV30

;; make both old and new CRSHID work - remove when old CRSHID is flushed
if2,<printx contains CRSHID kludge>
	MOVE	1,PISTS
	MOVEM	1,PISTS1
	MOVE	1,APRSTS
	MOVEM	1,APRST1

	extern	SLOWPC,NOCRPC
	SKIPE	1,SYSCRS	;guess the actual PC of the STOPCD
	 SUBI	1,1		;the JSR itself, not the return address
	SKIPE 	SLOWPC		;pickup PCs from STOPCD(SLO)
	 MOVE	1,SLOWPC
	SKIPE 	NOCRPC		;pickup PCs from STOPCD(NO)
	 MOVE	1,NOCRPC
	SKIPE	CRS147		;was it from 147 restart?
	 MOVEI	1,147		;fake it
	MOVEM	1,STOPPC

	DEFINE LPTMC (A)
<INTERNAL LPT'A'STS
LPT'A'STS: CONI LP'A,.>

	DEFINE FHXMC (A)
<INTERNAL FH'A'STS,FH'A'DTI
FH'A'STS: CONI FHD'A,.
FH'A'DTI: DATAI FHD'A,.>

	DEFINE DPXMC (A)
<INTERNAL DP'A'STS,DP'A'DTI
DP'A'STS: CONI DPC'A',.
DP'A'DTI: DATAI DPC'A,.>

	DEFINE SAXMC (A)
<INTERNAL SA'A'STS
SA'A'STS: CONI SAX'A,.>

%LPTNN==0

IFNCPU (KS),<DATAI APR,APRDTI>
IFCPU (<KI,F3>),<;KI 10 AND FOONLY DEVICES
TTYSTS:	CONI TTY,.
>
IFCPU (KI),<;KI10 DEVICES
IFN PTRN,<INTERNAL PTRSTS
PTRSTS:	CONI PTR,.>
IFN PTPN,<INTERNAL PTPSTS
PTPSTS:	CONI PTP,.>
CLKCNI::CONI CLK,.
>;END IFCPU KI

IFCPU (KL),<;KL ONLY DEVICES
	APRID	AIDSTS
	RDERA	ERASTS
	SBDIAG	SBDST1
	SBDIAG	SBDST2
TIMSTS:	CONI TIM,.
MTRSTS:	CONI MTR,.
>;END IFCPU KL

IFCPU (KS),<; KS DEVICES ONLY
	APRID	AIDSTS
TIMSTS:	RDINT	.
KMCSTP: SETZ T1,
	WRIO T1,@[3,,760540]		;STOP THE KMC
IFG MAGUN,<
MAGSTS:	JSP T1,[RDIO T2,@[3,,772440]
		MOVEM T2,-1(T1)
		JRST (T1)]
>;MAGUN
IFG LPTN,<
LPRSTS:	SKIPG	NXDLPT
	  JRST	DSKSTS
	JSP T1,[RDIO T2,@[3,,775400]
		MOVEM T2,-1(T1)
		JRST (T1)]
>;LPTN
DSKSTS:	JSP T1,[RDIO T2,@[1,,776700]
		MOVEM T2,-1(T1)
		JRST (T1)]
>;END IFCPU KS
IFCPU (<KI,KL>),< ;KI/KL DEVICES ONLY
IFN CDRN!CR10N,<INTERNAL CRSTS
CRSTS:	CONI CR,.>
IFN PLTN,<INTERNAL PLTSTS
PLTSTS:	CONI PLT,.>
	REPEAT LPTN,<LPTMC (\%LPTNN)
%LPTNN==%LPTNN+1>
%RD10N==1
	REPEAT RD10N,<FHXMC(\%RD10N)
%RD10N==%RD10N+1>
%RP10N==1
	REPEAT RP10N,<DPXMC(\%RP10N)
%RP10N==%RP10N+1>
%SAXN==0
	REPEAT SAXN,<SAXMC(\%SAXN)
%SAXN==%SAXN+1>
>;END IFCPU KI,KL
;NOW SAVE UPT AND ALL CONTEXT PGS IN PHYSICAL PGS 337-NCTXPG TO 337
	SKIPN	JOB		;
	JSR	GOBOOT		;NULL JOB RUNNING
	MAP	T1,%UPT		;PREVENT PG FAULTS HERE
	MOVEM	T1,CRSBLK	;SAVE IN CASE WE JSR GOBOOT
IFCPU (KI),<TRNE	T1,MAP.M	;ONLY SAVE IF PAGED ACCESSIBLE REFERENCE (DON'T NEED TO WRITE)
	JSR	GOBOOT>		;NO GOOD.
IFNCPU (KI),<
	TLNE	T1,PFW.H	;IF HARD FAILURE, FORGET IT
	JSR	GOBOOT
	TLNE	T1,PFW.R	;SKIP IF UNPAGED REF - THATS NO GOOD.
	TLNN	T1,PFW.A	;IF A BIT IS ON, ITS OK, ELSE NOT
	JSR	GOBOOT		;YES, CANT ADDRESS UPT
>;END IFNCPU (KI)
SUPT0:
	MOVEI	P,CRSBLK-1
IFCPU (KI),<MOVE	T1,PAGDTI	;GET DATAI PAG WORD FROM ABOVE
	TDO	T1,[400000,,400000] ;SET LOAD LEFT AND RIGHT
	EXCH	T1,CURUPT	;PUT IN CURUPT SO CLRPTA WILL WORK
	MOVEM	T1,SAVCUP	;SAVE THIS SO WE CAN RESTORE LATER
>;END IFCPU KI
%CTXPG==%UPT.N
REPEAT NCTXPG,
<	LDB	T1,[UPXPTR (%CTXPG,%UPT)]
	ANDI	T1,17777		;JUST PAGE NUMBER
	HRLZS	T1
	PUSH	P,T1
%CTXPG==%CTXPG+1>
;
;NOW CRSBLK/ 	CTX[0](=PHYS PG NO FOR CTX PG 0),,0
;		CTX[1]..,,0
;..ETC..
;P/--->		CTX[N]..,,0
;
;NOW MAKE LIST OF STATUS OF PHYSICAL PGS 337-NCTXPG TO 337
;IN RH OF PDL, SETTING 400000 FOR ANY PHYSICAL PG WHICH IS OCCUPIED
;BY ONE OF THE CONTEXT PGS.
	MOVSI T4,-NCTXPG
A0:	MOVSI T3,-NCTXPG
A1:	HLRZ T1,CRSBLK(T3)
	MOVEI T2,337-NCTXPG+1(T4)	;T2/PHYS PG NO NOW CHECKING
	CAIN T1,(T2)	;THIS PHYS PG OCCUPED BY CTX PG?
	TRO  T2,400000	;YES,FLAG
	IORM T2,CRSBLK(T4)	;THIS ENTRY/XX,,PHYS PG NO.+FLAG
	AOBJN T3,A1	;NEXT CTX PG, SEE IF MATCHES
	AOBJN T4,A0	;NEXT PHYS PG

;
;NOW FOR EACH CONTEXT PG, IF CTX[I]>=770, SEARCH FOR A PHYSICAL
;PG IN THE TABLE MARKED "NOT OCCUPIED" AND BLT THIS
;CTX PG INTO IT AND MARK IT OCCUPIED. CHANGE THE MAP TO POINT
;AT THE NEW PHYS PGS OCCUPIED, PUSHING OVERWRITTEN DATA INTO
;CRSBLK IN CASE SOMEBODY WANTS TO LOOK AT IT WITH FILDDT.
;THE TABLE NOW LOOKS LIKE THIS:
;CRSBLK/	CTX[0],, "33X"+400000 IF OCCUPIED 
;		CTX[1],,"33X+1" +FLAG
;..ETC..
;P/--->		CTX[N],,337+FLAG

	HLRZ T1,CRSBLK	;T1/PHYS PG NO OF UPT
	TRO T1,PGE.A!PGE.W
	DPB T1,[EPTPGP(%UPS.N)]	;ALL FIXUPS OF MAP SLOTS
	CLRPTA			;PUT MAPPING INTO EFFECT.
	MOVSI T4,-NCTXPG
B0:	HLRZ T1,CRSBLK(T4)	;T1/CTX[I]=PHYS PG FOR I'TH CTX PG
	MOVE T3,HGHBLK		;FROM HGHBLK-2 TO HGHBLK WILL BE
	CAIGE T1,-2(T3)		;OCCUPIED BY BOOTS. IT THIS CTX
				;PAGE AT OR ABOVE THERE? BOOTS
				;DOESNT SAVE ANYTHING PAST ITS
				;OWN STARTING POINT.
	JRST B4		;THIS PG DOESNT NEED MOVING
	MOVSI T3,-NCTXPG
B2:	HRRZ T1,CRSBLK(T3)	;PG NO+FLAG, J'TH PHYS PG 
	TRZE T1,400000
	JRST B3		;OCCUPADO
	TRO T1,PGE.A!PGE.W
	DPB T1,[EPTPGP(<%ERR_-9>)]	;ADDRESS THIS PHYS PG THRU %ERR
	CLRPTA			;PUT MAPPING INTO EFFECT
	MOVEI T2,%UPT.N(T4)	;T2/VIRT PG NO. THIS CTX PG
	HRLZ PG,T2
	LSH PG,^D9		;PG/VIRT ADDR THIS CTX PG,,0
	HRRI PG,%ERR		;PG/FROM CTX PG,,TO %ERR
	BLT PG,%ERR+777		;BLT UNTIL END OF PAGE IN %ERR
	CAIE T2,%UPT.N		;SPECIAL IF MOVING UPT
	JRST B2B
	PUSH P,PAGDTI		;SAVE FROM OVERWRITE
IFCPU (KI),<
	DPB T1,[POINT 13,PAGDTI,17];NOTE NEW UPT LOCATION. T1/PHYS PG
	DPB T1,[EPTPGP(%UPS.N)]	;T1/PGE.A!PGE.W+PHYS PG
	MOVE PG,PAGDTI
	TDO PG,[XWD 400000,400000]
>;END IFCPU KI
IFCPU (KL),<
	DPB	T1,[POINT 13,PAGDTI,35]
	DPB	T1,[EPTPGP(%UPS.N)]	;MAKE UPT ADDRESSABLE THRU %UPS.
	MOVE	PG,PAGDTI	;PUT IN PAGDTI FOR FILDDT SAKE
	TLZ	PG,(LG.LAB+LG.LPC+LG.LUB-LG.LUB) ;JUST LOAD AC BLKS
>;END IFCPU KL
IFCPU (<KS,F3>),<
	DPB	T1,[POINT 13,PAGDTI,35]
	DPB	T1,[EPTPGP(%UPS.N)];	MAKE UPT ADDRESSABLE THRU%UPS.
	MOVE	PG,PAGDTI	;PUT IN PAGDTI FOR FILDDT SAKE
	TLZ	PG,(LG.LAB+LG.LUB-LG.LUB)	;JUST LOAD AC BLKS
>;END IFCPU <KS,F3>
	WRUBR	PG
B2B:
	MOVEI PG,-340(T2)
	LSH PG,-1		;INDEX FOR THIS PG=(PG-340)/2
	PUSH P,%UPS+UPTEP0(PG)	;SAVE BEFORE OVERWRITING
	TRNN T2,1		;SKIP IF ODD PG
	SKIPA U,[POINT 18,%UPS+UPTEP0(PG),17]
	MOVE U,[POINT 18,%UPS+UPTEP0(PG),35]
	DPB T1,U		;T1/BITS+NEW PHYS PG NO THIS CTX PG
	MOVEI T1,400000
	IORM T1,CRSBLK(T3)		;MARK THIS PHYS PG OCCUPIED
	JRST B4			;NEXT CTX PG


;TRY NEXT PHYS PG, THIS ONE OCCUPIED
B3:	AOBJN T3,B2		;SHOULD JUMP
	JRST	B5		;ALL OCCUPIED, QUIT.
;SEE IF NEXT CTX PG NEEDS HELP
B4:	AOBJN T4,B0
;FELL THRU, ALL CTX PGS DONE
B5:

IFCPU (KI),<
	MOVE	T1,SAVCUP	;GET OLD CURUPT BACK
	MOVEM	T1,CURUPT	;FOR LOOKING AT IN DUMP.
>;END IFCPU KI
	JRST	LODBTS
GOBOOT:	EXP 	0	;CRASH CODE MAY JSR HERE IF TROUBLES
LODBTS::		;GLOBAL SO ANYONE CAN LODBTS$G IN DDT
	WRAPR APRIOB		;RESET SYSTEM
	JRSTF @[PC.UIO,,.+1]	;SET USER I-O
IFCPU (KI),<
	MOVEI T1,3		;NO. OF USER AC BLOCKS
	MOVE T3,[1B0+1B2+1B18+1B22+EPT.PN+<UPT.PN>B17]
	MOVEI T4,CRSHAC+20
	MOVE P1,T4		;PERM COPY OF BLT POINTER.
SYSTO1:	WRUBR	T3		;SET PAGER FOR AC BLOCK
	XCTFU <BLT T4,17(P1)>	;STORE IT
	ADD T3,[1B2]		;NEXT BLOCK
	MOVEI T4,20		;NEXT PLACE TO STORE INTO
	ADDB P1,T4		;P1 AND T4
	SOJG T1,SYSTO1		;LOOP THROUGH ALL BLOCKS
	WRUBR	[XWD 400000,400000]	;TURN OFF PAGING
	DATAO PTR,[0]	;IN CASE ADDRESS BREAK IS ON
>;END IFCPU KI

IFCPU (<KL>),<CONO	MTR,0	>	;TURN OFF INTERVAL TIMER PI SO WON'T UPDATE KEY ANYMORE.
IFCPU (KS),<WRAPR LP.DSF+LP.CSF+LP.TIM>	;DISABLE INTERVAL TIMER INTRPT
IFNCPU (KI),<
	WRUBR	[LG.LAB+0B8+0B11]	;MAKE SURE RUNNING IN AC BLOCK 0.
					; (IN CASE SOMEONE SAYS LODBTS$G)
IFCPU (KS),<MOVSI	T1,(KPACT)	;CLEAR KEEP ALIVE ACTIVE
	ANDCAM	T1,RLWORD>
	MOVEI	T1,NUMACB	;SAVE THIS MANY AC BLOCKS
	MOVSI	T3,(LG.LAB+0B8+1B11)	;START WITH BLOCK 1
	MOVEI	T4,CRSHAC+20	;PLACE TO STORE AC BLOCK 1
	MOVE	P1,T4		;PERMANENT BLT POINTER
SYSTO1:	WRUBR	T3
	XCTFU	<BLT T4,17(P1)>
	ADD	T3,[1B11]	;NEXT BLOCK
	MOVEI	T4,20
	ADDB	P1,T4
	SOJG	T1,SYSTO1	;GO SAVE ANOTHER
> ;END IFNCPU KI
IFCPU (KS),<WREBR	EPT.PN>		;TURN OFF PAGING
IFCPU (KL),<
	SWPUA			;OK, SAVE CACHE NOW.
	CONSZ	APR,LP.CSB	;WAIT FOR CACHE SWEEP BUSY TO CLEAR
	JRST	.-1
	WREBR	EPT.PN	;TURN OFF CACHE NOW.
	DATAO	APR,[0]		;CLEAR ADDRESS BREAK
>;END IFCPU KL
IFCPU (F3),<WREBR EPT.PN>	;TURN OFF PAGING
	MOVEI	P,SYSPDL	;SETUP P TO SPARE AREA
	EXTERNAL DSKSTP
	PUSHJ	P,DSKSTP
	SETZ	T2,		;CLEAR HANG FLAGS
IFNCPU (F3),<
	MOVEI 17,FILSER		;NOW TELL 620 WHERE TO DUMP
	LSH 17,4	;AS A 620 STYLE ADDRESS
	MOVEM 17,DMP620
	MOVEI 17,BTMOUT	;NUMBER OF SECONDS TO WAIT FOR BASE
	IMUL 17,JFYSEC	;NUMBER OF CLOCK TICKS TO WAIT
IFCPU (<KL>),<CONO TIM,TO.CTD+TO.SIT+^D1666>
IFCPU (KS),<WRINT	[<^D16>B23]>	;SET LEAP TICK
SYSTO2:	SKIPE D620FN	;IS 620 FINISHED?
	JRST SYSTO3	;YES.
IFCPU (KI),<
	CONSO APR,APRCLK ;CLOCK TICKED YET?
	JRST SYSTO2	;NO.
	WRAPR APRCLK		;YES, CLEAR IT
>;END IFCPU KI
IFCPU (<KL>),<
	CONSO	TIM,TI.ITD	;DONE WITH 16 MS COUNT?
	JRST	SYSTO2		;NO
	CONO	TIM,TO.CTD+TO.SIT+^D1666 ;YES, START ANOTHER
>;END IFCPU KL
IFCPU (KS),<
	CONSO	APR,LP.ITD	;DONE WITH 16MS COUNT?
	JRST	SYSTO2	;NO
	WRINT	[<^D17>B23]	;SET INTERVAL
	WRAPR	LP.CSF+LP.ITD+APRCHN	;START TIMER
>;END IFCPU KS
	SOJG 17,SYSTO2	;AND GO IF HAVE TO WAIT SOME MORE.
	MOVEI P1,[ASCIZ/
BASE NOT RESPONDING /]
	JSP T1,CTYTYP
	IORI	T2,RE.BTA!DCFULL	;STOP AUTO RELOAD (AND FORCE
					; FULL DSKCLN)
				; SO THAT BASE CAN BE RESTARTED
	SETOM	BASDWN		;INDICATE BASE NOT RESPONDING
	PUSHJ	P,CTYTIM
>;END IFNCPU (F3)
SYSTO3:	SKIPE SYSCRS
	JRST MONCRS	;SOFTWARE CRASH
	MOVEI P1,[ASCIZ /
CRASHED BY DEPOSIT IN 30 /]
	MOVE T1,SAV30
	CAME T1,CRSHWD	;IS SAV30=30
	JRST CRSMSP	;NO, PROBABLY A DEPOSIT IN 30
	MOVEI P1,[ASCIZ /
BASE INITIATED CRASH /]
CRSMSP:	SKIPE TAKDWN	;CRASHED WITH HANGUP?
	MOVEI P1,[ASCIZ /
HANGUP RUN /]
	JSP T1,CTYTYP	;PRINT MESSAGE
	PUSHJ	P,CTYTIM
MONCRS:
	SKIPN	NOCRS##		;HARDWARE TROUBLE?
	JRST	MONCR1		;NO
	MOVEI	P1,[ASCIZ /
SEVERE ERR ENCOUNTERED: HARDWARE SUSPECT/]
	JSP	T1,CTYTYP	;PRINT MESSAGE
	IORI	T2,RE.BTA!RE.ONA!DCFULL	;WANT MAN BTS, MAN ONC, FULL DC
MONCR1:	MOVE	T1,STRDDB+STRBTS	;HAS DSKCLN NOT
	TRNN	T1,SRPNDS	; COMPLETED?
	SKIPE	SLOCLC##	;REQUIRE SLOW DSKCLN?
	IORI	T2,DCFULL	;YES
	MOVE	T4,REUSER	;GET CURRENT RESTART STATE
	SKIPE	TAKDWN		;HANG CRASH?
	JRST	MONCR2		;YES
	IORI	T2,DCFAST	;NO: FORCE FAST DSKCLN
	LSH	T4,-RENUM	;MOVE CRASH TAKEDOWN RESTRT INTO POS
	SKIPA
MONCR2:	IORI	T2,RE.BTA	;YES: RUN BOOTS IN MANUAL
	ANDI	T4,1_RENUM-1	;ISOLATE DESIRED BITS
	HRLI	T4,RESCOD	;VALIDATE RESTART
	MOVEM	T4,RESTRT	;SAVE IN INTER-MONITOR WORD
	DPB	T2,REYMON	;PUT MON RESTART STATE IN RESTART WORD
	HLRZ	T1,STRDDB+STRPID	;GET PACK SET ID
	MOVEM	T1,REPSID	;SAVE IN INTER-MONITOR AREA
IFCPU (KI),<
	WRAPR APRIOB	;RESET AGAIN TO MAKE SURE
	WRPI 411577		;AND PI SYSTEM
>;END IFCPU KI
IFNCPU (KI),<
	WRPI	LI.CPS+LI.COF+LI.PIF+LI.ACO ;CLEAR PI SYSTEM
	WRAPR	LP.CSF+LP.PWF+LP.IOR ;AND APR
>;END IFNCPU (KI)
	MOVEI P,SYSPDL
	MOVEI	T3,RE.BTD	;COMPUTE ACTION FOR BOOTS
	PUSHJ	P,RECOMP	; RESTART
	TRNE	T2,RE.BTA	;MANUAL BOOTS DESIRED?
	SETZM	BTSTR		;YES
	LDB	S,REYDCA	;GET USER SPECIFIED DSKCLN TYPE
	MOVE	T4,RESTRT
	TRNN	T4,RE.DCD	;IS IT DEFINED?
	LDB	S,REYDCM	;NO: GET MONITOR DSKCLN TYPE
	MOVE	T1,REUSER	;GET USER RESTART
	TRNN	T1,RE.DCW	;DON'T WRITE DC TYPE TO HOME BLOCKS?
	CAIN	S,DCFULL	;IS FULL DSKCLN DESIRED?
	JRST	LDBTS		;YES: GO LOAD BOOTS
	SKIPN	STRDDB		;STRDDB AND UNI TABLES SETUP?
	JRST	LDBTS		;NO: CAN'T WRITE TO DISK
	PUSHJ	P,BTPREP	;PREPARE FOR LOADING BOOTS
	HRLI	S,HOMDCV	;GET HOME DSKCLN TYPE VALIDATOR
	SETZ	P4,		;INIT PREVIOUS PHYSICAL UNIT ID
	HLRZ	U,STRDDB+STRUNI	;GET ADDR OF FIRST UNIT DB IN STR
	MOVE	F,HGHBLK	;HIGHEST DIRECTLY ADDR PAGE
	SUBI	F,1		; LESS ONE (TO PRESERVE SAX SAVE AREA)
	LSH	F,11
NXTUNT:	MOVEI	PG,LPNHOM	;1ST HOME PAGE
	SKIPA
HOMP2:	MOVEI	PG,LP2HOM	;2ND HOME PAGE
	PUSHJ	P,PMDRD		;READ PAGE OFF DISK
	 JSR	TDERR		;TAKE DOWN ERROR
	MOVSI	T1,'HOM'
	MOVEI	T2,CODHOM
	CAMN	T1,HOMNAM(F)	;VERIFY HOM PG SIXBIT NAME
	CAME	T2,HOMCOD(F)	;VERIFY HOM PG CODE
	JSR	TDERR
	CAME	P4,HOMPRV(F)	;CHECK PREVIOUS PHYS UNIT FOR CONSIS
	JSR	TDERR
	MOVEM	S,HOMDCT(F)	;PUT IN CORE COPY OF HOME BLOCK
	PUSHJ	P,PMDWT		;WRITE BACK TO DISK
	 JSR	TDERR
	HRRZS	PG
	CAIE	PG,LP2HOM	;SEE IF BOTH HOME BLOCKS PROCESSED
	JRST	HOMP2		;NO: DO 2ND BLOCK
	MOVE	P4,HOMHID(F)	;SAVE CURRENT UNIT PHYSICAL ID
	HLRZ	U,UNISTR(U)	;POINT TO NEXT UNIT DB
	JUMPN	U,NXTUNT	;FINISHED IF NO MORE UNITS
	SKIPA			;ALREADY DID PREP
LDBTS::	PUSHJ	P,BTPREP	;PREPARE FOR LOADING BOOTS
	SETZM	BOOTCL+1	;CLEAR LAST WORD OF CMD LST

IFN SAXN,<
;  LOOK FOR BOOTS ON 3330 DRIVES.

	MOVE	PG,BTADR	;DISK ADDRESS, SIZE OF BOOTS
	HRRZ	F,BOOTCL	;BOOTS CORE ADDRESS
BPBR1:	MOVSI	J,-7		;INIT CHANNEL COUNTER
BPBR0:	SETZ	W,		;INITIAL DEVICE
BPBR2:	PUSHJ	P,SAXRED	;PROCURE BOOTS
	 JRST	BPBR		;COULD NOT GET IT
	JSP	T4,ISBOOT	;HAS BOOTS BEEN LOADED?
BPBR:	MOVEI	W,1(M)		;NO: INCREMENT DEVICE COUNTER
	CAIG	W,77		;HAS MAXIMUM BEEN REACHED?
	JRST	BPBR2		;NO: TRY NEXT UNIT
	AOBJN	J,BPBR0		;CONTINUE IF MORE CHANNELS TO TRY
> ;END IFN SAXN

;  NO GOOD 3330 UNIT WITH BOOTS.  TRY 2314 UNITS.

IFCPU (<KI,KL>),<
	MOVEI T1,BOOTCL-1
	HRRZM T1,BOOTWD		;SET LOWER CORE FOR CHL
	MOVSI J,-KONNUM	;TRY VARIOUS KONTROLERS ALSO

DPLOOP:	PUSHJ P,DPREAD	;WILL DO A RECAL
	PUSHJ P,DPREAD	;AND THEN READ
	XCT CNSZ(J)		;CHECK FOR ERRORS
	JRST DPNEXT	;AND TRY NEXT UNIT
	MOVE	T2,BOOTCL	;GET ADDR OF FIRST WORD
	MOVE T3,(T2)	;CHECK FIRST WORD
	CAMN T3,BOOTFI	;IS IT CORRECT
	JUMPG T4,BOOTYP	;YES, SAY LOADED IF NOT TIMEOUT
DPNEXT:	XCT CLRATN(J)		;MAKE SURE ALL ATTENTIONS CLEAR
	ADD T1,NXUNIT
	TLZN T1,700000	;OUT OF UNITS?
	JRST DPLOOP	;NO, TRY NEXT
	AOBJN J,DPLOOP	;TRY NEXT CONTROLLER
>; END IFCPU KI,KL

IFCPU (<KS,F3>),<		;READ BOOTS FROM KS OR F3 UNITS
	MOVE	PG,BTADR	;DISK ADDR, SIZE OF BOOTS
	HRRZ	F,BOOTCL	;BOOTS CORE ADDR
	MOVSI	W,-7		;INIT UNIT COUNTER
RMRPBT:
IFCPU(F3),<PUSHJ P,APXPRD>
IFCPU(KS),<PUSHJ P,RMRPRD>
	 SKIPA			;FAILED
	JSP	T4,ISBOOT	;GOT SOMETHING, SEE IF BOOTS
	AOBJN	W,RMRPBT	;NOT BOOTS, TRY NEXT UNIT IF ONE
> ;END IFCPU(<KS,F3>)
	MOVE 10,.+1
	HALT 10		;CAN NOT FIND BOOTS, HALT


TAKDWN:: 0	;CLOCK1 COMES HERE ON ORDERLY SHUTDOWN
	JRST	CRASHX

;DETERMINE CORE START ADDR FOR BOOTS AND SAVE SA-X AREA FOR POSTERITY
;
BTPREP:	MOVE	T2,HGHBLK	;HIGH BLOCK IN ADDRESSABLE CORE
	LSH T2,11
IFNCPU (KS),<SUBI T2,BCDSSZ-1000	;STARTING PLACE TO READ IN
	HRRM T2,BOOTCL>
IFCPU (KS),<SUBI T2,2000-140	;STARTING PLACE TO READ IN
	HRRZM T2,BOOTCL>
IFN SAXN, <
	ADDI	T2,BCDSSZ-100	;END OF BOOTS+100
	HRLI	T2,SAXBAS	;SA-10 BASE LOCS ADDRESS
	BLT	T2,37(T2)	;SAVE BASE LOCS
>
	POPJ	P,

ISBOOT:	HRRZ	T2,BOOTCL	;GET BOOTS STARTING ADDR
	MOVE	T3,(T2)		;GET FIRST WORD OF BOOTS
	CAME	T3,BOOTFI	;IS IT CORRECT?
	JRST	(T4)		;NO: RETURN
BOOTYP:	MOVEI	P1,[ASCIZ /
BOOTS LOADED /]
	JSP	T1,CTYTYP	;TYPE OUT MESSAGE
	PUSHJ	P,CTYTIM	; AND DATE IT
	MOVEI	1,BTSTR		;GET ADDR OF BOOTS COMMAND STRING
	JRST	5(T2)		;PASS CONTROL TO BOOTS

;ROUTINE TO COMPUTE RESTART STATE
;
RECOMP:	MOVE	T2,RESTRT	;GET INTER-MONITOR WORD
	TDNE	T2,T3		;IS USER ACTION DEFINED?
	POPJ	P,		;YES
IFCPU (KI), <RDAPR T1>		;READ SENSE SWITCHES
IFCPU (F3),<DATAI APR,T1>	;READ PANEL SWITCHES
IFCPU (KL), <PUSHJ P,SPCGSW##>	;GET KLDCP SWITCHES
IFCPU (KS), <MOVE T1,KSSS4>	;GET SSW WORD
IFCPU (KI), <TLNE T1,SS4>	;IS SS4 ON?
IFNCPU (KI), <TRNE T1,SS4>	;IS SS4 ON?
	JRST	[LSH	T3,-NUMREV	;SET SELECTED
		 TDO	T2,T3		; ACTION BIT
		 POPJ	P,]
	LSH	T2,-RENUM		;NO: RETURN MONITOR ACTION
	POPJ	P,

TDERR:	0			;JSR HERE IF RESTART ERROR DETECTED
	MOVEI	P1,[ASCIZ /
SERIOUS RESTART ERROR DETECTED
/]
	JSP	T1,CTYTYP
	JRST	LDBTS		;GO GET BOOTS

;TYPE DATE AND TIME ON CTY
CTYTIM:	PUSH	P,T2		;PRESERVE T2
	PUSH	P,J
	PUSH	P,COMTOA	;SAVE CURRENT TYPEOUT ROUTINE
	MOVEI	T1,CTYTYO
	MOVEM	T1,COMTOA
	SETZ	J,
	MOVEI	T1,20		;SET TIME ZONE TO GMT
	DPB	T1,PVYTIM
	PUSHJ	P,DAYTIM	;USE "DAYTIME" CMD
	POP	P,COMTOA	;RESTORE TYPEOUT POINTER
	POP	P,J
	POP	P,T2
	POPJ	P,

;PRIMITIVE DISK READ SET UP AND DISPATCH
PMDRD:	PUSHJ	P,PMDSET	;SET UP TO READ
	HRRZ	T1,PMDDSP(T1)	;GET READ ADDRESS
	PJRST	(T1)		;READ FROM SELECTED UNIT

;PRIMITIVE DISK WRITE SET UP AND DISPATCH
PMDWT:	PUSHJ	P,PMDSET	;SET UP TO WRITE
	HLRZ	T1,PMDDSP(T1)	;GET WRITE ADDRESS
	PJRST	(T1)		;WRITE TO SELECTED UNIT

;SET UP FOR PRIMITIVE DISK ROUTINES
PMDSET:	LDB	J,UNYSCN	;GET CHANNEL NUMBER
	LDB	W,UNYPUN	;GET UNIT NUMBER OFFSET
	LDB	T1,UNYKTP	;GET DEVICE TYPE
	TLNN	PG,-1		;IS # OF RECORDS SPECIFIED?
	TLO	PG,4		;NO: DEFAULT TO ONE PAGE
	POPJ	P,

;MACRO TO GENERATE DISPATCH TABLE ENTRIES
DEFINE PMD (WT,RD)<
	IFNDEF WT, <TDERR+1,,TDERR+1>
	IFDEF WT, <WT,,RD> >

;PRIMITIVE DRIVER DISPATCH TABLE
PMDDSP:	;WRITER,,READER
	PMD(QQQQ,QQQQ)		;0  DR
	PMD(QQQQ,QQQQ)		;1  FH
	PMD(QQQQ,QQQQ)		;2  DP
	PMD(QQQQ,QQQQ)		;3  MD
	PMD(SAXWRI,SAXRED)	;4  SAX
	PMD(RMRPWT,RMRPRD)	;5  RM/RP
	PMD(APXPWT,APXPRD)	;6  F3 CDC/AMPEX DRIVES

;MACRO TO DEFINE RESTART SYMBOLS AND BYTE POINTERS.
; SYMBOL SUFFIX INERPRETATIONS:
;	'A'  [USER SELECTED] RESTART ACTION.
;	'D'  DEFINITION STATE OF USER ACTION.
;	'M'  MONITOR RESTART ACTION.
;
DEFINE RESYM (DCNAM,DCS,ACT)<
  INTERN  REUSER,REY'DCNAM'A,REY'DCNAM'M,RESCOD,RE.'DCNAM'D,DCSIZ
	DCSIZ==DCS
	RESCOD=='RES'			;INTER-MONITOR WORD VALIDATOR
	REUSER:	EXP	0		;RECEPTACLE FOR USER RESTART
	NUMREV==1			;COUNT NUM OF
	IRP ACT, <NUMREV==NUMREV+1>	; RESTART TYPES
	RENUM==DCSIZ+2*NUMREV-1		;NUMBER OF RESTART BITS
	REYMON: POINT DCSIZ+NUMREV-1,RESTRT,35-RENUM
	REY'DCNAM'A: POINT DCSIZ,RESTRT,35
	RE.'DCNAM'D==1_<DCSIZ+NUMREV-1>
	REY'DCNAM'M: POINT DCSIZ,RESTRT,35-RENUM
  INTERN  DCNAM'FULL,DCNAM'FAST, DCNAM'NONE
	DCNAM'FULL==7
	DCNAM'FAST==1
	DCNAM'NONE==0
	REXX==1_DCSIZ
	IRP ACT, <RE.'ACT'A==REXX
		  RE.'ACT'D==REXX_NUMREV
		  RE.'ACT'M==REXX_RENUM
		  REXX==REXX_1>
	RE.'DCNAM'W==1B19
>

RESYM (DC,DC.SIZ,<ON,BT>);CREATE SYMBOLS FOR THE 3 BIT DSKCLN TYPE
			; FIELD 'DC' AND FOR RESTART CONDITIONS
			; 'ON' - AUTO/MANUAL ONCE AND
			; 'BT' - STRING/MANUAL BOOTS

INTERN	RE.ONA,RE.OND

BASDWN:	0		;NON-ZERO IF BASE DIDN'T RESPOND TO DUMP REQ

IFCPU (KI),<SAVCUP: BLOCK 1>	;PLACE TO SAVE CURUPT ON KI10

BCDSZ==1600			;SIZE OF BOOTS CODE
BCDSSZ==BCDSZ+200		;SIZE OF BOOTS + SAX SAVE AREA
IFCPU (<KI,KL,F3>), <BTADR: BCDSZ_-7,,3	;SIZE OF BOOTS, DISK ADDR>
IFCPU (KS), <BTADR: BCDSZ_-7,,11	;SIZE OF BOOTS, DISK ADDR>
BOOTCL:	XWD -BCDSZ,0
	0

BOOTFI:	WRAPR 200000

BTSTLN==^D24			;MAX CHARS IN BOOTS COMMAND STRING
BTSTR:	BYTE	(7)"/","D",15,15,0	;DEFAULT STRING: DUMP MEM,
					; LOAD AND RUN DEFAULT MON
	BLOCK	BTSTLN/5

INTERN	BTSTR,BTSTLN,RECOMP

EXTERNAL CTYTYP,COMTOA,DAYTIM
EXTERNAL CTYTYO
EXTERN	HOMDCV,STRDDB,STRPID,STRUNI,LPNHOM,LP2HOM,HOMNAM,CODHOM
EXTERN	STRBTS,SRPNDS
EXTERN	HOMCOD,HOMPRV,HOMDCT,HOMHID,UNISTR,UNYSCN,UNYPUN,UNYKTP
IFN SAXN,<

COMMENT !PRIMITIVE ROUTINES TO READ OR WRITE A SPECIFIED NUMBER OF
	 RECORDS STARTING AT AN ARBITRARY DISK PAGE FROM/TO ANY 3330 
	 TYPE DRIVE CONNECTED TO AN SA-10.
	 PARAMETERS:	PG/ # OF RECORDS,,DISK PAGE
			F/ CORE ADDR (NOT NECESSARILY ON PG BOUNDARY)
			J/ 1B33  SA-10
			   3B35  SUB-CHANNEL
			W/ UNIT
	 CALL:	PUSHJ P,SAXRED  TO READ
		PUSHJ P,SAXWRI  TO WRITE
	 RETURN:	SUCCESS: M=W, SKIP RETURN
			ERROR: NON-SKIP RETURN
			       M=W OR 77  IF CHANNEL NOT AVAILABLE
				=W OR 7  IF NO MORE UNITS ON THIS
					 KONTROLLER
				=W  IF UNIT NUMBER GOOD BUT OTHER ERROR
	 ACS ALTERED:	T1-T4,M,P1-P3
!

SAXWRI:	MOVEI	P1,SAXWCD
	SKIPA
SAXRED:	MOVEI	P1,SAXRCD
	DPB	P1,SAYBB	;STORE READ OR WRITE CODE
    ;STORE DEVICE ADDRESS IN COMMANDS.
	MOVEI	T1,SAUN0(W)	;COMPUTE DEVICE ADDRESS
	MOVE	M,[POINT 8,SACLST,23] ;B HOLDS PNTR.
	DPB	T1,M		;DEV ADDR TO SEEK
	HRRI	M,2(M)		;
	DPB	T1,M		;DEV ADDR TO SEARCH ID EQUAL.
	HRRI	M,3(M)		;
	DPB	T1,M		;DEV ADDR TO READ/WRITE CMD.

	HRLI	T1,77		;CLEAR CORE
	ANDCAM	T1,SACADR	; ADDR FIELD
	HRRM	F,SACADR	;SET INIT DESTINATION ADDR
	SETZ	P3,		;INIT RECORD INDEX
NEXREC:	HRRZ	T1,PG		;COPY PAGE NUM
	LSH	T1,2		;CONVERT TO RECORD NUM
	ADD	T1,P3		;COMPUTE CURRENT RECORD NUM
	IDIVI	T1,SABPC	;COMPUTE CYLINDER,
	IDIVI	T2,SABPT	; HEAD,
	ADDI	T3,1		; AND RECORD NUMBERS
	DPB	T1,SAYCC	;STORE CYLINDER NUMBER
	DPB	T2,SAYCC+1	;STORE HEAD NUMBER
	DPB	T3,SAYCC+2	;STORE RECORD NUMBER

	MOVEI	P1,SAX1AD	;GET ADDR OF SA-10 1
	TRNE	J,4		;SKIP IF SELECTED SA-10
	MOVEI	P1,SAX2AD	;GET ADDR OF SA-10 2
	HRRZ	M,J		;WHICH SA-10?
	LSH	M,2
	ADDI M,SAXREG		;NOW HAVE BASE FOR THIS CHANNEL
	MOVEI	T1,SACLST
	HRLI	T1,200000	;TIC COMMAND
	MOVEM	T1,(M)		;STORE IN BASE AREA
	MOVEI	P2,1		;SET A UNIQUE BIT IN P2 THAT CORR. TO
	LSH	P2,(J)		; THE SA-10, SUB-CHAN BEING REFERENCED
	TDNE P2,CHNFLG		;DO WE KNOW ITS NOT THERE
	JRST	STRT4A		;YES, GIVE UP ON IT
	MOVEI	T1,21
	SETCMI	T2,(J)
	ORI	T2,-4		;ZERO EXTRANEOUS BIT IF SET
	LSH	T1,7(T2)	;SET UP BIT FOR STAT FLAG FOR THIS CHAN
	SETCA	T2,		;RECOVER CHANNEL NUMBER
	LSH T2,3		;CONVERT TO CORRECT POSITION FOR CONO
	HRL T2,T1		;SAVE STATUS BIT IN LEFT HALF
RESTAR:	PUSHJ P,IOCNI		;READ STATUS
	JUMPE	T4,STRT4	;JUMP IF SA-10 IS MISSING
	MOVEI T1,640(T2)
	PUSHJ P,IOCNO		;SET STATUS BIT
	MOVEI T1,440(T2)
	PUSHJ P,IOCNO		;AND GO FLAG
	MOVEI T1,600(T2)
	PUSHJ P,IOCNO		;AND THEN CLEAR STATUS
	MOVEI	T4,^D100000
	HLRZ T1,T2		;GET STATUS BIT
	PUSHJ P,IOCNSO		;AND DO THE CONSO
	SOJG	T4,.-1
	JUMPE	T4,STRT4	;JUMP ON TIMEOUT
	MOVE	T4,1(M)		;GET STATUS
	TLNE T4,(1B2)
	JRST STRT4A		;SELECT ERROR
	MOVEI T1,400000		;IN CASE WE HAVE TO RESET
	TLNN	T4,BSY
	JRST	STRT3		;NOT BUSY
	TLNE	T4,SM		;BUSY+STATUS MODIFIER?
	JRST	STRT2		;YES
	TLNE	T4,CUE
	JRST	RESTAR		;JUMP ON BUSY+CU END
STRT3:	TLNN	T4,CE+DE	;CHANNEL END AND DEVICE END?
	JRST	STRT5		;NO. ERROR
	TLNN	T4,175114	;OTHER ERRORS?
	JRST	NEXRC1		;THIS RECORD PROC. OK, CONTINUE
STRT5:	PUSHJ P,IOCNO		;T1 IS LOADED WITH BIT 18
	HRRZ	M,W		;UNIT NUM SUPPLIED WAS GOOD
	POPJ	P,
STRT4:	IORM	P2,CHNFLG	;MARK CHANNEL NOT THERE
	MOVEI	T1,77		;AND WORD FOR BAD CHANNEL
	SKIPA
STRT4A:	MOVEI	T1,7		;AND WORD FOR NO MORE DEV ON KONT
	MOVE	M,W		;COPY UNIT NUMBER
	TDO	M,T1		;SET TO TOP OF MULT OF 10
	POPJ	P,
STRT2:	MOVEI T1,600(T2)
	PUSHJ P,IOCNO		;CLEAR STATUS
	HLR T1,T2		;NO WAIT FOR STATUS BIT
	PUSHJ P,IOCNSO
	JRST	.-1
	MOVE	T4,1(M)
	TLNE	T4,CUE
	JRST	RESTAR
	JRST	STRT2

NEXRC1:	MOVEI	T1,200		;LOAD RECORD SIZE
	ADDM	T1,SACADR	;POINT TO NEXT RECORD
	ADDI	P3,1		;INCREMENT RECORD COUNTER
	HLRZ	T1,PG		;HAVE ALL RECORDS BEEN
	CAME	P3,T1		; READ/WRITTEN?
	JRST	NEXREC		;NO: DO NEXT RECORD
	MOVE	M,W		;UNIT NUM SUPPLIED WAS GOOD
	JRST	XPOPJ1		;SUCCESS RETURN

IOCNSO:	MOVSI T3,(CONSO (T1))	;SETUP IO INSTR.
IOXCT:	DPB P1,[POINT 7,T3,9]	;PUT IN I/O DEVICE FIELD
	XCT T3			;DO THE IO
	POPJ P,			;NO SKIP RETURN
XPOPJ1:	AOS (P)			;SKIP RETURN
XPOPJ:	POPJ P,			;NO SKIP RETURN
IOCNI:	SKIPA T3,[CONI T4]	;FOR SA-10
IOCNO:	MOVSI T3,(CONO (T1))
	JRST IOXCT

; SA-10 COMMAND LIST AND DEFINITIONS

SACLST:
SACIDE==SACLST+2
SACTIC==SACIDE+2
SACCMD==SACTIC+1
SACADR==SACCMD+1

CMDLST:
	BYTE	(8)72,7		;SEEK
	BYTE	(12)-6(24)SACARG
	BYTE	(8)73,61	;SEARCH ID EQUAL
	BYTE	(12)-5(24)SACARG
	XWD	200000,SACIDE	;TIC
	BYTE	(8)160		;READ OR WRITE
	BYTE	(12)-200
	0
SAYBB:	POINT	8,SACCMD,15
SAYCC:	POINT	32,SACARG,31
	POINT	16,SACARG+1,15
	POINT	8,SACARG+1,23

SABPC==<^D18*^D19>&777774
SABPT==^D18
SAXWCD==5
SAXRCD==6
SAUN0==300
SAXREG==300
SAX1AD==274_-2		;SA-10 1
SAX2AD==400_-2		;SA-10 2
BSY==(BYTE (8)0,20)
CUE==(BYTE (8)0,40)
SM==(BYTE (8)0,100)
CE==(BYTE (8)0,10)
DE==(BYTE (8)0,4)

CHNFLG:	Z			;DEFECTIVE CHANNEL FLAG WORD
SACARG:	BLOCK	2		;SEEK/SEARCH BLOCK
> ;END IFN SAXN
IFCPU (<KI,KL>),<
DPREAD:	TLC T1,700000	;CHANGE READ TO RECAL AN BACK
	XCT CNO(J)	;CLEAR CONTROLLER
	HRRI T1,BOOTWD+45000	;SET FOR BLOCK 4
	XCT DSKRD(J)
	MOVEI T4,^D100000
	XCT CNSO(J)
	SOJG T4,.-1
	POPJ P,

	DEFINE DPKON(A,B)
<	A DPC,B
	A DPC2,B>

CNSZ:	DPKON (CONSZ,377720)
CLRATN:	DPKON (DATAO,CLRATW)
CNO:	DPKON (CONO,175710)
DSKRD:	DPKON (DATAO,T1)
CNSO:	DPKON (CONSO,10)
	KONNUM==.-CNSO

CLRATW:	500000,,776
NXUNIT:	XWD 10000,0
>;END IFCPU KI,KL
IFCPU (KS),<

COMMENT	!PRIMITIVE ROUTINES TO READ OR WRITE A SPECIFIED NUMBER OF
	 RECORDS STARTING AT AN ARBITRARY DISK PAGE FROM/TO AN
	 RM03/RP06 DISK DRIVE INTERFACED TO A KS THRU A UBA.
	 PARAMETERS:	PG/ # OF RECORDS,,DISK PAGE
			F/ CORE ADDR (NOT NECESSARILY ON PG BOUNDARY)
			W/ UNIT
	 CALL:	PUSHJ P,RMRPRD	TO READ
		PUSHJ P,RMRPWT	TO WRITE
	 RETURN:	SUCCESS: SKIP
			FAILURE: NON-SKIP
	 ACS ALTERED:	T1-T4,P1-P2
!

DEFINE	RDREG(DEST,REG)	;EXPECTS THE UBA NUMBER IN T2
<	RDIO	DEST,REG'ADR(T2)>

DEFINE	WRREG(SRC,REG)	;EXPECTS THE UBA NUMBER IN T2
<	WRIO	SRC,REG'ADR(T2)>


RMRPRD:	SKIPA	P1,[F.RD]	;DO DISK READ
RMRPWT:	MOVEI	P1,F.WD		;DO DISK WRITE
	HRLZI	T2,UA1	;SET THE ADDRESS TO UBA1
	MOVEI T3,CS2CLR
	WRREG T3,CS2;			CLEAR RH11
	WRREG W,CS2;			SELECT UNIT
	RDREG T4,DS;			DRIVE EXISTS?
	RDREG T3,CS2
	TRNN T3,CS2NED
	  TRNN T4,DSMOL
	   POPJ	P,
	MOVEI T4,F.RIP			;READ IN PRESET
	WRREG T4,CS1
	MOVEI T4,^D100000
	MOVEI T3,DSDRY		;WAIT UNTIL INITIALIZATION DONE
	TION  T3,DSADR(T2)
	  SOJG T4,.-1
	JUMPLE	T4,RMPOPJ
	RDREG T4,DS
	TRNE T4,DSERR
	  POPJ	P,
	MOVEI T4,F.RECA
	WRREG T4,CS1;			ISSUE RECALIBRATE
	MOVEI T3,^D100000
	RDREG T4,DS
	TRNN T4,DSDRY
	 SOJG T3,.-2
	JUMPLE T3,RMPOPJ
	TRNE T4,DSERR
	 POPJ	P,
;TRY UNIT
	RDREG P2,DT
	ANDI P2,2		;Adr is function of unit type.
	LSH	P2,-1		;0:RM03, 1:RP06
	MOVEI	T1,^D148	;CALCULATE
	CAIE	P2,0		; ABSOLUTE
	MOVEI	T1,^D380	; DISK
	HRRZ	T3,PG		; SECTOR
	LSH	T3,2		; ADDR
	IDIV	T3,T1		; FROM
	WRREG	(T3,DC)		; UNIT
	MOVE	T3,T4		; RELATIVE
	MOVEI	T1,^D30		; PAGE
	CAIE	P2,0		; NUMBER
	MOVEI	T1,^D20		; AND
	IDIV	T3,T1		; PASS
	DPB	T3,[POINT 5,T4,27]	; TO
	WRREG	(T4,DA)		; DRIVE
	HLRZ	T3,PG		;SET WORD
	LSH	T3,10		; COUNT
	MOVNS	T3
	WRREG T3,WC
	MOVE T4,F		;SET VIRTUAL CORE ADDRESS
	SETZ T3,				;SET VIRTUAL CORE ADR
	ROTC T3,-9
	ROT T3,13
	WRREG T3,BA
	MOVE T3,[UA1,,PGRADR]
	TRO T4,PGRFST+PGRVAL		;SET PHYSICAL CORE ADR
	WRIO T4,@T3
	AOJ T4,
	AOJ T3,
	WRIO T4,@T3
	WRREG P1,CS1
	movei	t3,^D100	;busy wait loop index
rmp1:	movei	t4,^D2000	;bus saturation avoidance loop index
	sojg	t4,.		;only do read every few ms to avoid
				; saturating the bus
	RDREG T4,CS1
	TRNN T4,CS1RDY		;done?
	 sojg	t3,rmp1		;no, try again if haven't timed out
	JUMPLE	T3,RMPOPJ
	TRNN	T4,CS1TRE	;ANY ERRORS?
	AOS	(P)		;NO: READ/WRITE SUCCEEDED
RMPOPJ:	POPJ	P,
>;END IFCPU KS

IFCPU(F3),<
;AMPEX/CDC TYPE DRIVE HANDLER FOR F3 PROCESSOR

RTYCNT==20000

DRVTYP==CDC
CDC==1
AMPEX==0

IFE DRVTYP-CDC,<
SPT==^D8		;SECTORS PER TRACK (DEPENDS ON HOW FORMATTED)
TPC==^D10		;TRACKS PER CYLINDER (NUMBER OF HEADS)
CPU==^D823-^D10		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>
IFE DRVTYP-AMPEX,<
SPT==^D8		;SECTORS PER TRACK
TPC==^D5		;TRACKS PER CYL (NUMBER OF HEADS)
CPU==^D815-^D5		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>;END IFN AMPEX
PPC==SPT*TPC			;PAGES PER CYLINDER
BPC==PPC*4			;BLOCKS PER CYLINDER
PPU==PPC*CPU			;PAGES PER UNIT
SPT==^D8				;SECTORS PER TRACK
BPT==SPT*^D4			;BLOCKS PER TRACK
USPR==^D17300	;MICROSECONDS PER REVOLUTION.

;DISK IOTS AND REGISTER BIT NAMES.
OPDEF RCMD	[715000000000]	;READ COMMAND REGISTER
	SUNT==1B0		;SELECTED UNIT NOT THERE (SELECT ERROR)
	SUWP==1B1		;SELECTED UNIT WRITE PROTECT
	SUNR==1B2		;SELECTED UNIT NOT READY
;---
	SUOC==1B3		;SELECTED UNIT ON CYLINDER
				; SHOULD ALWAYS BE SET EXCEPT AFTER RECAL UNTIL HEADS ALIGN
	SUSE==1B4		;SELECTED UNIT SEEK ERROR (DETECTED BY DRIVE)
				; RECAL MANDATORY AFTER THIS ERROR, FAULT CLEAR WILL NOT TURN THIS OFF.
	SUF==1B5		;SELECTED UNIT FAULT (DETECTED BY DRIVE)
;---
	SUA==1B6		;SELECTED UNIT ATTENTION
				; SET BY LEADING EDGE OF ON CYLINDER (BIT 3)
	HDECC==1B7		;ECC ERROR ON HEADER
	CI==1B8			;CONTROL IDLE (ONLY IF NO DATA XFER AND NO SEEKS OR RECALS GOING)
;---
	SECC==1B9		;SOFT ECC ERROR (NOT YET IMPLEMENTED IN F3 MICROCODE)
	HECC==1B10		;ECC UNRECOVERABLE ERROR

;FOLLOWING BITS ARE DETECTED BY CONTROLLER:
	ROE==1B11		;READ OVERRUN ERROR
;---
	WOE==1B12		;WRITE OVERRUN ERROR
	SOE==1B13		;SECTOR OVERRUN ERROR
	IPE==1B14		;INTERNAL PARITY ERROR (ONLY VALID IF AE, BIT 28, IS ZERO)
;---

;FOLLOWING ARE FROM LAST LCMD

	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH COMMAND 4)
;---
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
;	19 UNUSED
;	20 UNUSED
;---
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
;---
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
;---
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)

;END OF FROM RCMD BITS
	AE==1B28		;ANY  ERROR (EXCEPT IPE, BIT 14)
	AA==1B29		;ANY UNIT ATTENTION
;---

;FROM LCMD
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE

	NA==1B31		;NOT ACTIVE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
;---
;BITS 33, 34 NOT IMPLEMENTED.

	MPE==1B35		;MEMORY PARITY ERROR
;---
OPDEF RMA	[716000000000]	;READ MEMORY ADDRESS
OPDEF RDA	[717000000000]	;READ DISK ADDRESS (IN PAGES)
	AMSUNI==^D3		;SIZE OF UNIT BYTE
	AMPUNI==^D6		;RIGHTMOST BIT
	ROTUNI==-<AMPUNI+1>	;NUMBER OF PLACES TO ROTATE TO GET UNIT FIELD IN
	AMSCYL==^D12
	AMPCYL==^D19
	AMSTRK==^D8
	AMPTRK==^D27
	AMSSEC==^D8
	AMPSEC==^D35
	LDAMSK==034000,,177400	;MASK FOR $0% AND $0O IN DDT
OPDEF RECC	[720000000000]	;READ CONTROL REGISTER
OPDEF LCMD	[721000000000]	;LOAD COMMAND REGISTER
	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH COMMAND 4)
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
OPDEF LMA	[722000000000]	;LOAD MEMORY ADDRESS
OPDEF LDA	[723000000000]	;LOAD DISK ADDRESS
	SU==1B7			;SELECT UNIT
				;MUST BE CLEARED AND SET TO SELECT A UNIT.
OPDEF LECC	[724000000000]	;CLEARS ECC LOGIC, STARTS AND INITS CONTROL.
	SC==1			;START CONTROL
	IC==2			;INIT CONTROL (SEND BEFORE STARTING CMD)
OPDEF DCONO	[740000000000]	;CONO TO DISK CONTROL TO SET PI ASSIGNMENT
OPDEF DCONI	[741000000000]	;CONI FROM DISK CONTROL OPCODE
	DIDLE==10		;SET IF CONTROL IS IDLE
	DPIA==7B35		;PI ASSIGNMENT.
				;NOTE THAT NONZERO PI ASSIGNMENT SETS DIE (SEE LCMD)
OPDEF DCONSO	[742000000000]
OPDEF DCONSZ	[743000000000]

;ROUTINE TO START A FUNCTION UP ON CONTROL

DOKON:	LECC	[IC]		;INIT CONTROL
	LCMD	T1		;DO THE COMMAND
	LECC	[SC]		;START CONTROLLER
	POPJ	P,		;AND RETURN.

CLRKON:	MOVE	T1,[CF+FC]	;COMMAND FUNCTION FAULT CLEAR
DOWKON:	PUSHJ	P,DOKON		;DO THE COMMAND AND THEN
WATKON:	MOVEI	T2,RTYCNT	;NUMBER OF TIMES TO WAIT
	RCMD	T1
	TLNN	T1,(CI)		;CONTLOL IDLE YET?
	SOJG	T2,.-2		;NO
	JUMPG	T2,CPOPJ1	;JUMP IF IT WENT IDLE
	POPJ	P,		;DIDN'T.

APINI:	HRRZ	T1,W	;GET UNIT SELECTED
	ROT	T1,ROTUNI
	LDA	T1
	TLO	T1,(<SU>)
	LDA	T1
	PUSHJ	P,CLRKON	;CLEAR CONTROL
	  JFCL			;IGNORE ERRORS FOR NOW
	RCMD	T1		;GET STATUS
	TLNE	T1,(<SUNT!SUNR>) ;NON-SKIP IF NOT THERE OR NOT READY
	POPJ	P,
	PUSHJ	P,CLRKON	;CLEAR OUT CONTROL AGAIN
	  POPJ	P,		;TIMEOUT
	MOVE	T1,[CF+FC+RECAL]
	PUSHJ	P,DOWKON	;DO A RECAL IN CASE IT HAD SEEK ERROR
	  POPJ	P,		;NO GOOD.
	MOVSI	T1,^D10		;WAIT A LONG TIME
	RCMD	T2
	TRNN	T2,NA		;SKIP IF NOT ACTIVE ANYMORE.
	SOJG	T1,.-2
	JUMPE	T1,CPOPJ	;GO IF TIMED OUT
	RCMD	T1		;GET STATUS BITS AGAIN
	TRNN	T1,AE		;ERROR RETURN IF ANY ERRORS
	AOS	(P)		;NO ERRORS
	POPJ	P,

;PRIMITIVE ROUTINE TO READ OR WRITE A SPECIFIED NUMBER OF
; PAGES STARTING AT AN ARBITRARY DISK PAGE TO/FROM ANY
; CDC OR AMPEX DRIVE (DEPENDING ON HOW ASSEMBLED) CONNECTED
; TO AN F3.
;
;PG/ # RECORDS,,DISK PAGE
;F/ CORE ADDRESS (NOT NECESSARILY ON A PAGE BOUNDARY)
;W/ UNIT
;
;CALL: PUSHJ P,APXPRD OR APXPWT TO READ OR WRITE
; SUCCESS - SKIP
; FAILURE - NON-SKIP
; USES ACS T1-T4,P1-P2. PRESERVES ARG ACS.

APXPRD:	SKIPA	P2,[APREAD]
APXPWT:	MOVEI	P2,APWRIT	;APPROPRIATE ROUTINE TO CALL.
	PUSHJ	P,APINI		;INIT THE UNIT
	  POPJ	P,		;COULDN'T INIT THE DRIVE.
	PUSH	P,PG		;NEED TO SAVE THIS
	PUSH	P,F		;SO CAN DO MORE THAN ONE REC AND PRESERVE ARGS.
	HLRZ	T1,PG		;GET COUNT OF BLOCKS WANTED.
	ADDI	T1,3
	LSH	T1,-2		;TURN INTO PAGES.
	MOVNS	T1		;- COUNT
	HRL	PG,T1		;MAKE INTO AN AOBJN POINTER
APXPX1:	PUSHJ	P,(P2)		;CALL THE ROUTINE TO DO ONE PAGE
	  JRST	APXPER		;NO GOOD.
	ADDI	F,1000		;ADVANCE MEMORY ADDRESS
	AOBJN	PG,APXPX1
	AOS	-2(P)		;OK, GIVE SUCCESS RETURN.

APXPER:	POP	P,F
	POP	P,PG
	POPJ	P,

;HERE TO READ OR WRITE ONE PAGE WITH RH(PG) CONTAINING THE BLOCK NUMBER
; W CONTAINING THE UNIT NUMBER AND F CONTANING THE MEMORY ADDRESS.

APWRIT:	SKIPA	P1,[WRITE]
APREAD:	MOVEI	P1,READ
	HRRZ	T1,PG		;GET PAGE NUMBER
	IDIVI	T1,PPC		;GET T1/CYL, T2/PAGES INTO CYL
	IDIVI	T2,SPT		;GET T2/TRACK, T3/SECTOR IN TRACK
	DPB	T2,[POINT AMSTRK,T3,AMPTRK]
	DPB	T1,[POINT AMSCYL,T3,AMPCYL]
	HRRZ	T1,W
	ROT	T1,ROTUNI	;GET UNIT NUMBER INTO POSITION
	TDO	T3,T1
	LDA	T3
	TLO	T3,(<SU>)
	LDA	T3
	PUSHJ	P,CLRKON	;CLEAR OUT CONTROL
	  JFCL			;IGNORE, WILL CATCH LATER.
	LMA	F		;LOAD MEMORY ADDRESS
				;NUMBER OF WORDS IS ALWAYS 1000
	MOVE	T1,P1		;GET COMMAND INTO T1 FOR DOKON
	PUSHJ	P,DOKON	;START THE TRANSFER
	MOVSI	T1,^D10		;TIMEOUT IS ABOUT 10 SECONDS.
	RCMD	T2
	TRNN	T2,NA
	SOJG	T1,.-2
	JUMPE	T1,CPOPJ	;TIMED OUT, ERROR
	RCMD	T1		;OK, GET COMMAND
	TRNE	T1,AE		;MAKE SURE NO ERROR BITS ON
	POPJ	P,		;SORRY.
	TLNE	T1,(<IPE>)	;THIS IS ONLY VALID IF AE OFF
	POPJ	P,		;NO GOOD.
	RMA	T1
	TLZ	T1,777774	;CLEAR UNUSED BITS
	SUB	T1,F		;GET NUMBER OF WORDS XFERRED
	CAIE	T1,1000
	POPJ	P,		;WRONG COUNT
	JRST	CPOPJ1	;OK, SUCCESSFUL XFER.
>;END IFCPU (F3)
;COMMON SUBROUTINE RETURNS

	INTERNAL CPOPJ,CPOPJ1,DPOPJ,TPOPJ,TPOPJ1,CPOPJ2,IPOPJ1,IPOPJ
CPOPJ2:	AOS	(P)		;DOUBLE SKIP SUBROUTINE RETURN
CPOPJ1:	AOSA	(P)		;SKIP SUBROUTINE RETURN
DPOPJ:	MOVEM	S,DEVIOS(F) ;DEPOSIT I/O STATUS WORD IN DDB
CPOPJ:	POPJ	P,

TPOPJ1:	AOS	-1(P)		;RESTORE T1 THEN SKIP RETURN
TPOPJ:	POP	P,T1		;RESTORE T1
	POPJ	P,		;AND RETURN
IPOPJ1:	AOS -1(P)		;SET FOR SKIP RETURN
IPOPJ:	POP P,J		;RESTORE J (USUALLY JOB NUMBER)
	POPJ P,



;SUBROUTINES TO SAVE AND RESTORE PRESERVED ACS

INTERN	SAVE1,SAVE2,SAVE3,SAVE4

SAVE1:	PUSH	P,P1
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-1(P)
	JRST	RES1

SAVE2:	PUSH	P,P1
	PUSH	P,P2
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-2(P)
	JRST	RES2

SAVE3:	PUSH	P,P1
	PUSH	P,P2
	PUSH	P,P3
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-3(P)
	JRST	RES3

SAVE4:	PUSH	P,P1
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-4(P)
	POP	P,P4
RES3:	POP	P,P3
RES2:	POP	P,P2
RES1:	POP	P,P1
	POPJ	P,


; SYSTEM BYTE POINTERS

	INTERNAL PUUOAC,PIOMOD,PJOBN,PUNIT,PJBSTS,PDVTIM,PDVCNT
	INTERNAL IADPTR,JBYQNT,DEYCLS,DEYMCT,DEYTCT,PJBST2

PUUOAC:	POINT	4,M,12	;M AC FIELD
PIOMOD:	POINT	4,S,35	;MODE BITS
XP PJBNLH,350700		;LEFT HALF OF "POINT 7,XXX,6"
PJOBN:	XWD PJBNLH+F,DEVCHR	;DEVICE JOB ASSIGNMENT
PUNIT:	POINT	7,DEVCHR(F),23 ;DEVICE UNIT NUMBER
PJBSTS:	POINT	JWSIZ,JBTSTS(J),JWPOS ;JOB WAIT STATE (QUEUE) CODE
PJBST2:	POINT	JWSIZ,T2,JWPOS	;ONE FOR T2
				;IN JOB STATUS WORD
PDVTIM:	POINT	3,DEVCHR(F),9	;CODE FOR TIME DEVICE MAY
					;BE ACTIVE BEFORE BEING DECLARED
					;HUNG. N MEANS 2^N-1 SECONDS
PDVCNT:	POINT	7,DEVCHR(F),16 ;COUNTED DOWN EACH SECOND,
				;1 TO 0 TRANSITION MEANS HUNG DEVICE
IADPTR:	POINT	2,DEVIAD(F),2	;COUNT OF NUMBER OF USER CHANNELS INITED
				; ON THIS DEVICE (DECTAPE ONLY)
DEYCLS:	POINT 2,DEVCLS(F),1	;DEVICE CLASS CODE
DEYMCT:	POINT 4,DEVCLS(F),13	;DEVICE MAX FREE CORE COUNT
DEYTCT:	POINT 4,DEVCLS(F),17	;DEVICE CURRENT FREE CORE COUNT
JBYQNT:	POINT JBSQNT,JBTICT(J),JBNQNT ;POINTER TO QUANTUM RUN TIME FOR JOB
				;(NO OF JIFFIES BEFORE NEXT LOWER RUN QUEUE)

CTXTAB::				;TABLE OF BYTE POINTERS TO DISK
				; ADDRESSES. ALSO USED TO COMPUTE
				; EFFECTIVE ADDRESSES IN JBTCTX
ZZ==0
REPEAT NCTXPG,<
	POINT 27,JBTCTX+ZZ(J),35 ;POINTER TO DISK ADDRESS FOR PAGE ZZ
	ZZ==ZZ+JOBN
>

JBYSWS::POINT 2,JBTPGO(J),1 ;SWAPPER STATE
JBYACT::POINT 10,JBTPGO(J),11	;NUMBER OF ACTIVE LMAP SLOTS
JBYCTR::POINT 5,JBTPGO(J),17	;NUMBER OF PAGES RESERVED FOR
				;CONTEXT PAGES
IFG NCTXPG-<1_<5-1>>,<PRINTX JBYCTR FIELD OVERFLOW>
JBYPPP::POINT 6,JBTMWS(J),5	;# OF PER-PROCESS PAGES
JBYMWS::POINT 10,JBTMWS(J),15	;MONITOR WORKING SET SIZE
JBYMWL::POINT 10,JBTMWS(J),25	;LIMIT
JBYUWS::POINT 10,JBTMWS(J),35	;USER WORKING SET SIZE.

	INTERN JBYWCH
JBYWCH:	POINT 23,JBTWCH(J),35 ;BYTE POINTER TO TIME OF DAY STARTED WAITING
				;END FT WATCH

INTERNAL JBYRPT,JBYWPT,PVYMOD,PVZMOD,PVYCOR,PVYCRM,PVYTIM,PVYHNG

JBYRPT:	POINT 2,JBTLIC(J),LICRPS
JBYWPT:	POINT 2,JBTLIC(J),LICWPS
JBLMSZ==:^D17			;INACTIVITY TIMEOUT LIMIT FIELD SIZE
JBLMSK==:<1_JBLMSZ>-1		;INACTIVITY TIMEOUT LIMIT MASK
INAHIT==:(1B0)			;INACTIVITY TIMEOUT LIMIT HAS BEEN HIT
JBYLIM:: POINT JBLMSZ,JBTINA(J),17	;BYTE POINTER TO LIMIT FIELD
PVYMOD:	POINT PVSMOD,JBTPRV(J),PVNMOD
PVZMOD:	POINT PVSMOD,JBTPRV(T1),PVNMOD
PVYCOR:	POINT PVSCOR,JBTPRV(J),PVNCOR
PVYTIM:	POINT PVSTIM,JBTPRV(J),PVNTIM
PVYCRM:	POINT PVSCRM,JBTPRV(J),PVNCRM
PVYHNG:	POINT PVSHNG,JBTPRV(J),PVNHNG
INTBYP:
JBYUUO:	POINT 6,%UPT+UPTTPN,5	;(0) UUO TRAP NUMBER
JBYCLK:	POINT 6,%UPT+UPTTPN,11	;(1) CLOCK TRAP NUMBER
JBYPGT:	POINT 6,%UPT+UPTTPN,17	;(2) PAGE TRAP NUMBER
JBYHNG:	POINT 6,%UPT+UPTTPN,23	;(3) HUNG DEVICE TRAP NUMBER
JBYTIM:	POINT 6,JBTIOA(J),5	;(4) TIMER TRAP NUMBER
JBYERR:	POINT 6,%UPT+UPTTPN,29	;(5) DEVICE ERROR TRAP NUMBER
JBYWAK:	POINT 6,JBTIOA(J),11	;(6) WAKE UUO
JBYSAL::POINT 6,%UPT+UPTTP1,5	;(7) UWS FAULT, SIZE AT LEAST LIMIT
JBYSLL::POINT 6,%UPT+UPTTP1,11	;(10) UWS FAULT, SIZE LESS THAN LIMIT
JBYREF::POINT 6,%UPT+UPTTP1,17	;(11) REF BIT TRAP
JBYPER::POINT 6,%UPT+UPTTP1,23	;(12) TRAP ON I/O ERRORS.
JBYNTQ::POINT 6,JBTIOA(J),17	;(13) NOTICE TO QUIT (TO BE HUNG)
JBYEXC::POINT 6,JBTSLC(J),35	;(14) FRAME EXITED INTERRUPT.
JBYMCY::POINT 6,%UPT+UPTTP1,29	;(15) Micro-cycle interrupt timer
INTRNM==.-INTBYP	;NUMBER OF SETTABLE APR INTERUPTS

INTERNAL JBYWAK,JBYNTQ
INTERNAL JBYUUO,JBYCLK,JBYPGT,JBYHNG,JBYTIM,JBYERR,INTRNM,INTBYP

JBYSC1: POINT 9,JBTSCA(J),8	;Numerator for non-kcore factor
JBYSC2: POINT 9,JBTSCA(J),17	;Denominator for non-kcore
JBYSC3: POINT 9,JBTSCA(J),26	;Num. for kcore factor
JBYSC4: POINT 9,JBTSCA(J),35	;Denom. for kcore (or 0 if absolute)

INTERNAL JBYSC1,JBYSC2,JBYSC3,JBYSC4
COMMENT ;
HERE IS THE INNFORMATION FOR THE PAGE TABLE. THIS TABLE
IS USED FOR SWAP IN AND OUT AND OTHER THINGS. THE BYTES
ARE ARRANGED SO THAT THE MOST FREQUENTLY USED BYTES ARE
RIGHT JUSTIFIED IN THE WORD TO MINIMIZE SHIFTING TIME REQUIRED
DURING THE BYTE INSTRUCTIONS.

THIS TABLE IS ALLOCATED AT ONCE TIME AND ALL POINTER ADDRESSES ARE
ADJUSTED. THE POINTER WILL HAVE A LOWER ADDRESS THAN THE FIRST
ENTRY SO THAT ALL THE MONITOR PAGES ARE NOT POINTED TO
;

;FIRST WORD

PGYUNU::POINT 6,.-.(PG),10	;UNUSED
PGYPGO::POINT 12,.-.(PG),22	;OUTPUT WAIT FOR THIS PAGE LINK
PGYFPL::POINT 13,.-.(PG),35	;FORWARD LINK (PAGE NUMBER)
			;PGYFPL MUST BE IN THE FIRST WORD.

;SECOND WORD

PGYLMA::POINT 22,.-.(PG),22	;LMA CHAIN START (LINKS
INTERN SNDPGY
SNDPGY==PGYLMA	;DEFINED FOR ONCE TIME.  MUST BE A PNTR
			;TO THE SECOND WORD, AND PGYFPL MUST BE
			;IN THE FIRST WORD.
				; ALL ACTIVE SLOTS FOR CORE PAGE
 PGYLMV::POINT 10,.-.(PG),10	;VP NUMBER OF NEXT SLOT
 PGYLMJ::POINT 12,.-.(PG),22	;JOB NUMBER OF NEXT SLOT, 0 IF END
PGYBPL::POINT 13,.-.(PG),35	;BACKWARD LINK (PAGE NUMBER)

;THIRD WORD

PGYLST::POINT 3,.-.(PG),2	;WHICH LIST PAGE IS ON (SEE CORE1
				; FOR LIST NUMBER DEFINITIONS)
	XP DIOMAX,77		;MAXIMUM THAT DIO CAN BE.
PGYDIO::POINT 6,.-.(PG),8	;DIRECT I/O COUNT (TAPE, NOT DISK)
  XP PGPDIO,001000
PGYADR::POINT 27,.-.(PG),35	;DISK ADDRESS. (RETRIEVAL POINTER FORMAT)
 PGYUNI::POINT 8,.-.(PG),16	;UNIT NUMBER PART
 PGYPNO::POINT 19,.-.(PG),35	;PAGE ADDRESS WITHIN UNIT

;FOURTH WORD

PGYSPT::POINT 22,.-.(PG),22	;SPT BASE + OFFSET
 PGYSPB::POINT 18,.-.(PG),18	;SPT BASE
 PGYSPO::POINT 4,.-.(PG),22	;OFFSET
PGYCHT::POINT 13,.-.(PG),35	;LINK TO NEXT CORE PAGE ON CHT

;FIFTH WORD

PGYNXM::POINT 1,.-.(PG),0	;NXM
PGYERR::POINT 2,.-.(PG),2	;IODERR,IODTER
PGYSIP::POINT 1,.-.(PG),3	;SWAP IN IN PROGRESS
PGYSOP::POINT 1,.-.(PG),4	;SWAP OUT IN PROGRESS
PGYDRT::POINT 1,.-.(PG),5	;DIRTY

PGYSTS::POINT 6,.-.(PG),5	;CORE PAGE STATUS WORD
	XP PGPNXM,40		;BIT IN STATUS WORD FOR NXM
	XP PGPDER,20		;DEVICE ERROR
	XP PGPDTE,10		;DATA ERROR
	 XP PGMERR,PGPDER!PGPDTE ;MASK FOR ERRORS
	XP PGPSIP,4		;SWAP IN IN PROGRESS
	XP PGPSOP,2		;SWAP OUT IN PROGRESS
				; MUST BE 1B34!! (SEE DECUSE)
	XP PGPDRT,1		;DIRTY
				;MUST BE 1B35!! (SEE DECUSE)

PGYSIO::POINT 2,.-.(PG),4	;COVERS SIP AND SOP.

PGYATB::POINT 13,.-.(PG),18	;PLACE TO REMEMBER ATB ADDRESS WHILE
				; PAGE IS ON LMA CHAIN (SO DON'T HAVE
				; FIND LAST SLOT ON CHAIN TO FIND ATB)
	XP USEMAX,377777	;MAXIMUM THAT USE COUNT CAN BE.
PGYUSE::POINT 17,.-.(PG),35	;NUMBER OF REASONS WHY PAGE IS IN CORE
				;MUST BE RIGHT JUSTIFIED FOR AOS @PGYUSE.

;SIXTH WORD

PGYCSH::POINT 36,.-.(PG),35	;WHOLE WORD (TO MAKE CODE FASTER)
				; SAVED CACHE SWEEP SERIAL NUMBER.
INTERN CNTPGY
CNTPGY==6		;NUMBER OF PGY WORDS (FOR ONCE).

ADRNCT::EXP	1B<35-27>-1	;IF PGYADR IS EQUAL TO THIS, CORE PAGE
			; IS NOT IN CHT AND HAS NO DP ASSOCIATED WITH IT.
ADRDUM::EXP	1B<35-27>-2	;IF PGYADR IS EQUAL TO THIS, CORE PAGE
			; HAS NO DISK PAGE ASSOCIATED WITH IT, BUT
			; CAN BE USED AS A PRIVATE PAGE AS LONG AS ITS NOT
			; DEACTIVATED. USED BEFORE DSKCLN FINISHED FIXING DISK.
;(WAS A PROBLEM WITH DSKCLN DOING SUPER I/O AND WRITING IN ITSELF,
; AND DSKCLN OVERWRITING RIBS AFTER IT HAD CHECKED THEM BY
; WRITING IN ITS OWN CORE IMAGE)

IFCPU (KL),<
;HERE ARE FOUR LOCATIONS WHICH HAVE THE ADDRESSES OF FOUR CACHED
; PAGES. BY LOADING THE RELATIVE ADDRESS IN THE PAGE
; INTO T1 AND THEN REFERENCING @CSRTAB+0,1,2,3, ONE CAN ENSURE
; THAT A CERTAIN FOUR WORD CHUNK HAS BEEN UNLOADED FROM THE CACHE
; WITHOUT HAVING TO DO A CACHE SWEEP.
;
;USE THE MACRO "CSHREF" TO DO THIS.

CSRTAB::.-.(T1)
	.-.(T1)
	.-.(T1)
	.-.(T1)
>;END IFCPU KL
;TABLES FOR MWS ADJUST AND PAGE AGEING CODE

AGEHST::BLOCK AGEMAX+1	;HISTOGRAM FOR OBSERVING AGE DISTRIBUTION

AGEPTR::		;TABLE OF BYTE POINTERS FOR ACCESSING
			;AGE CELLS
ZZBIT=2
REPEAT <AGECPW>,<
	POINT AGESIZ,%UPT+UPTAGE(T1),ZZBIT
	ZZBIT=ZZBIT+AGESIZ
>


;DEFINE PI CHANNEL SAVE AND RESTORE ROUTINES IF A DEVICE IS ON THE CHANNEL

	PDL==42		;LENGTH OF INTERRUPT PI PUSH DOWN LIST

DEFINE CHAN (PI)<
	XLIST
   IFNDEF ACBPI'PI,<;IF NO AC BLOCK ALLOCATED TO THIS CHANNEL,
	IFNDEF HIGAC'PI,<XP HIGHAC,17>
  >;END IFNDEF ACBPI'PI
	IFDEF HIGAC'PI,<
	IFGE HIGAC'PI-10,<XP HIGHAC,<HIGAC'PI>>
	IFL HIGAC'PI-11,<XP HIGHAC,11>
>
  IFNDEF ACBPI'PI,<;IF NO AC BLOCK ALLOCATED TO THIS CHANNEL,
	HIACBL==HIGHAC
  >;END IFNDEF ACBPI'PI
	INTERNAL SAV'PI,RET'PI,CH'PI,CH'PI'JEN,CH'PI'P,CH'PI'PD1
CH'PI:	0		;PC STORED HERE BY JSR ON INTERRUPT TO CHANNEL PI
	JEN @CH'PI	;LAST INSTRUCTION ON CONSO DEV, CHAIN

IFNDEF ACBPI'PI,<;IF NO AC BLOCK ALLOCATED TO THIS CHANNEL, GENERATE NORMAL AC SAVE CODE.

;HERE FROM AN INTERRUPT ROUTINE WHICH HAS FOUND ITS DEVICE NEEDS SERVICE
;SAVE ACS 0 THRU HIGHAC, CALLED BY JSR, SETS UP P TO PUSH DOWN LIST FOR THIS PI

SAV'PI:	0		;CALLED BY JSR
IFCPU (KS),<TBSAVE TBVA'PI>	;SAVE CURRENT TIME BASE VALUE
	EXCH	HIGHAC,CH'PI	;;GET PI, SAVE HIGHAC
	TLNN	HIGHAC,PC.USR	;;IF FROM USER MODE,
	JRST	SAV'PI'A		;;(NOT USER MODE)
	EXCH	HIGHAC,CH'PI	;NO NEED TO SAVE ANYTHING
	EXECAC
	MOVE	P,CH'PI'P	;;GET PDL FOR THIS PI LEVEL
	JRST	@SAV'PI		;;AND RETURN.

SAV'PI'A:
IFNCPU (KI),<RDUBR	SAVPG'PI>	;;NEED TO SAVE STATE ON KL
	EXCH	HIGHAC,CH'PI	;GET PC AND AC HIGHAC BACK IN RIGHT PLACES
	MOVEM HIGHAC,SAVAC'PI+HIGHAC	;SAVE AC HIGHAC
	MOVEI HIGHAC,SAVAC'PI	;SETUP TO SAVE 0 THRU HIGHAC-1
	BLT HIGHAC,SAVAC'PI+HIGHAC-1	;SAVE ACS
	MOVE P,CH'PI'P	;SETUP PUSH DOWN POINTER
	JRST @SAV'PI			;RETURN TO CALLER AND PROCESS INTERRUPT
>;END IF HIGAC'PI

IFDEF ACBPI'PI,<;IF CHAN HAS AC BLK,THEN WE ARE TO USE AN AC BLOCK FOR THIS CHANNEL.
SAV'PI:	0		;JSR TO HERE
IFCPU (KS),<TBSAVE TBVA'PI>		;SAVE THE CURRENT TIME BASE VALUE
	RDUBR	SAVPG'PI	;REMEMBER AC BLOCK SETTING
	WRUBR	[LG.LAB+<ACBPI'PI>B8+<ACBPI'PI>B11]
	MOVE	P,CH'PI'P	;GET PDL POINTER FOR THIS CHANNEL
	JRST	@SAV'PI		;AND RETURN.
>;END IFDEF ACBPI'PI

;HERE FROM INTERRUPT ROUTINE WHEN IT HAS FINISHED SERVICING INTERRUPT
;RESTORE ACS AND DISMISS INTERRUPT
;USUALLY TRANSFERRED TO BY POPJ P,

IFNDEF ACBPI'PI,<;IF CHANNEL DOESN'T HAVE AN AC BLOCK,

RET'PI:	MOVE	HIGHAC,CH'PI	;;GET RETURN PC
	TLNN	HIGHAC,PC.USR	;IF FROM USER MODE
	JRST	RET'PI'A
	USERAC			;;DON'T HAVE TO RESTORE
	JRST	CH'PI'JEN

RET'PI'A:MOVSI HIGHAC,SAVAC'PI	;RESTORE ACS 0 THRU HIGHAC
	BLT HIGHAC,HIGHAC
IFNCPU (KI),<WRUBR	SAVPG'PI>	;IF KL, NEED TO SWITCH BACK BY HAND.
>;END IFNDEF ACBPI'PI

IFDEF ACBPI'PI,<;IF AC BLOCK ASSIGNED TO THIS CHANNEL,

RET'PI:	MOVE	17,SAVPG'PI	;GET DATAI PAG WORD
	TLZ	17,(LG.LUB+LG.LPC+LG.LAB-LG.LAB) ;JUST LG.LAB SET
	WRUBR	17		;BACK TO ORIGINAL AC BLOCKS
>;END IFDEF ACBPI'PI
CH'PI'JEN:
IFCPU (KS),<	TBSET  TBVA'PI>		;RESET THE TIME BASE FOR KS
		JEN @CH'PI		;DISMISS INTERRUPT ON THIS PI CHANNEL


SAVAC'PI:: BLOCK HIACBL+1
IFNCPU (KI),<
SAVPG'PI::BLOCK	1		;PLACE TO DO DATAI PAG TO IN KL VERSION
>;END IFNCPU (KI)
IFCPU (KS),<
TBVA'PI: 0			;2 WORDS FOR SAVING THE TIME BASE
	 0>
CH'PI'P:	XWD -PDL+1,.+1		;INITIAL PUSH DOWN POINTER
CH'PI'PD1:	EXP RET'PI	;FIRST WORD ON LIST,
				; POPJ WILL RETURN TO DISMISS INTERRUPT
	BLOCK PDL-1		;PUSHDOWN LIST SPACE
	LIST
>



;GENERATE THE CHANNEL SAVE ROUTINE ONLY FOR PI WHICH NEED THEM (ASGSAV MACRO USED)

	IFN USED1, <CHAN 1>
	IFN USED2, <CHAN 2>
	IFN USED3, <CHAN 3>
	IFN USED4, <CHAN 4>
	IFN USED5, <CHAN 5>
	IFN USED6, <CHAN 6>
	IFN USED7, <CHAN 7>

;GENERATE NULL CHANNEL SAVE ROUTINES FOR THOSE CHANNELS NOT USED

DEFINE NULL (PI)<
	XLIST
	INTERNAL CH'PI
CH'PI:	0
	JEN	@CH'PI
	LIST
>

;GENERATE UNASSIGNED CHAN ROUTINES FOR THOSE CHANNELS NOT ASSIGNED

DEFINE UNASS (PI)<
	XLIST
	INTERNAL CH'PI
CH'PI:	0
	MOVEM	T1,SAVAC'PI
	MOVEI	T1,1_<7-PI>	;LOAD CHANNEL FLAG
	ORM	T1,BADINT	;INDICATE ILL INT OCCURED ON THIS CHAN
	WRPI	LI.COF!1_<7-PI>	;TURN CHANNEL OFF
	MOVE	T1,SAVAC'PI
	JEN	@CH'PI
SAVAC'PI: 0			;SAVE WORD
	LIST
>

	IFE USED1+UNASS1, <NULL 1>
	IFE USED2+UNASS2, <NULL 2>
	IFE USED3+UNASS3, <NULL 3>
	IFE USED4+UNASS4, <NULL 4>
	IFE USED5+UNASS5, <NULL 5>
	IFE USED6+UNASS6, <NULL 6>
	IFE USED7+UNASS7, <NULL 7>

	IFN UNASS1, <UNASS 1>
	IFN UNASS2, <UNASS 2>
	IFN UNASS3, <UNASS 3>
	IFN UNASS4, <UNASS 4>
	IFN UNASS5, <UNASS 5>
	IFN UNASS6, <UNASS 6>
	IFN UNASS7, <UNASS 7>

	IFE COREN, <COREN==^D256		;NO RESTRICTION IF 0 TYPED>
	XP USRLIM,COREN			;DEFINE GLOBAL RESTRICTING MAXIMUM SIZE OF
					; CORE FOR ANY SINGLE USER
					; ONCE ONLY CODE CAN ALTER THIS VALUE
					; (PATCH RH CORLIM IN SYSINI)

;APR AND PI BITS
	INTERN	REQCLK,PICLK
	INTERNAL APRNOT

	CLKBIT==1
	REPEAT 7-CLKCHN, <CLKBIT==CLKBIT*2>
	INTERNAL CLKBIT
	REQCLK==1B24+CLKBIT	;REQUEST INTERRUPT ON LOW PRIORITY CLK CHANNEL
	PICLK==LI.PIN+REQCLK	;TURN ON PI,REQUEST INTERRUPT ON CLK CHANNEL
IFCPU (KI),<;ONLY NEEDED FOR KI10, WHICH HAS 2 PI ASSIGNMENTS INSTEAD OF 1.
	XP APRCH2,<APRCHN_3+APRCHN>		;BOTH CLOCK AND ERROR
>;END IFCPU KI
XP PIPROG,77400		;PI STATUS REGISTER
			;ONES IF ANY PI'S IN PROGRESS
			;DO NOT DEFINE IF P-6 SO UNDEFINED
			;GLOBAL WILL BE CLUE TO P-6 USER
			;TO CHANGE CODE
	APRNOT==PIPROG-<400_<7-APRCHN>>	;DEFINE ALL PI IN PROGRESS FLAGS EXCEPT
					; APR FOR HALT TEST IN APRINT.

;INTERNAL HERE FOR 10/40N, MUST BE SAME AS IN COMMOD



;SCANNER ENTRY POINTS AND BIT DEFINITIONS

INTERNAL LINTAB,LINFLG

LINFLG:	BLOCK NFLG		;FOR U OUTPUT BITS

LINTAB:		;U CHARACTERISTICS BITS (NOT CLEARED ON SYSTEM STARTUP)
;XP LINTBE,LINTAB+PORTN

;TELETYPE U CHARACTERISTICS (LH OF LINTAB)
;USED BY SCNSER

XP TTVINI,200			;RUN INITIAL CUSP
XP TTVIN2,400			;RUN INITIAL CUSP FROM SETUUO

;LINES TO RUN INITIA

INI0==1	;LINE 0 INITIA AT START TIME
IN21==1	;LINE 1 INITIA FROM SETUUP
IN22==1	;ALSO LINE 2
IN23==1	;AND LINE 3
IN24==1	;AND LINE 4
IN25==1	;AND LINE 5 (see INITIA.MAC for what these are used for)

;NOW DEFINE THE U TABLE FOR EACH TTY'S CHARACTERISTICS
;USING THE INFO FROM CONFIG, AND DATA FROM TTYTAB AREA.

DEFINE GENLIN(LIN)<
ZZ==0

.GNLN(LIN,INI)
.GNLN(LIN,IN2)

	XWD ZZ,0		;LINE LIN
>

DEFINE .GNLN (N,BIT) <
IFDEF BIT'N,<ZZ==ZZ+BIT'N*TTV'BIT>
>

LINTAB:	LIN==0
REPEAT PORTN+1,<GENLIN(\LIN)
LIN==LIN+1
>


INTERN TTFREE,TTCLST

;THE FOLLOWING SLIDING SCALE DEFINES THE LENGTH OF THE TTY FREE LIST

IFNDEF TTCHKN,<IFL PORTN-10,<XP TTCHKN,7*PORTN>>
IFNDEF TTCHKN,<IFL PORTN-20,<XP TTCHKN,6*PORTN>>
IFNDEF TTCHKN,<XP TTCHKN,^D10*PORTN>

TTFREE:	EXP .-.			;FILLED IN AT ONCE TIME BY FREE LIST ADR
TTCLST:	XWD TTCHKN,.-.		;# OF TTY CHUNKS,,ADDRESS OF FIRST ONE
XP TTCHKS,4				;CHUNK SIZE

CSUPTN:: BLOCK 1	;PHYS PG NO UPT SAVED IN ON CRASH
CRSBLK:: BLOCK ^D10	;HARDWARE MAP DATA OVERWRITTEN IS SAVED HERE AFTER PAGCNI
INTERN SYSPDL
SYSPDL:	BLOCK 56			;UNTIL FIND A BETTER PLACE FOR IT
					;USED BY ONCE ONLY CODE AS PUSH DOWN LIST
					;UPTPDL NOT USED BECAUSE ONCE CLAERS IT OUT




	INTERN	SAVDMP

		SAVDMP==<SIXBIT /   SAV/>	;EXTENSION FOR SAVED FILES == "SAV"

;CARD READER ENTRY POINT AND BITS

	IFG CDRN, <
	INTERNAL CDRBTS
		CDRBTS==1670+CDRCHN
>

;CARD PUNCH ENTRY POINT

;	IFG CDPN, <
;	EXTERNAL CDPSER		;ENTRY POINT
;>



	IFG LPTN, <

;PROTOTYPE DEFINITION FOR U PRINTER DEVICE DATA BLOCKS

LPTDON==100

DEFINE	LPTDDB (N) <
IFCPU (<KI,KL>),<	;KI/KL DDB GENERATION.

	XLIST				;TURN OFF LISTING DURING EXPANSION

	INTERN LP'N'DDB

LP'N'SV1==LP'N'SAC+F		;DEFINE F SAVE LOCATION

LPTCON==.-LP'N'DDB
LP'N'INT: CONSO LP'N,0			;(-4) SKIP IF INTERRUPT FOR THIS LPT
	  JRST .-1			;(-3)  GO TO NEXT SKIP CHAIN ELEMENT
	  MOVEM F,LP'N'SV1		;(-2) SAVE F IN CHANNEL SAVE AREA
	  JSP F,LPTINT		;(-1) SET UP DDB ADDRESS AND BRANCH
LP'N'DDB:
LP'N'NAM: 
	LPNAM==SIXBIT /LPT/
	IFE LPTN-1, <LPNAM>		;( 0) PHYSICAL DEVICE NAME
	IFN LPTN-1, <LPNAM+<20+$LPNUM>B23> ;( 0) PHYSICAL DEVICE NAME
	  XWD 6*HUNGST,<N>B23+LPTSIZ    ;( 1) DEVICE CHARACTERISTICS
					; HUNG TIME IS 63 SECS (CODE 6)
	  0				;( 2) DEVICE I/O STATUS
	  XWD 0,LPTDSP			;( 3) LH=DDB LINK, RH=DSP TABLE ADDR.
LPTMOD==1_A+1_AL+1_I			;LPT LEGAL MODES
	  XWD DVOUT+DVLPT,LPTMOD	;( 4) DEVICE CHARACTERISTICS
	  0 				;( 5) LOGICAL DEVICE NAME
	  0				;( 6) BUFFER HEADER ADDRESSES
LPTPTR==.-LP'N'DDB
LP'N'PTR: 0				;( 7) BLOCK OUTPUT POINTER
	  0			;(10) CURRENT OUTPUT BUFFER ADDRESS
LP'N'CLS:	XWD  0,LP'N'BUF	;(11) CLASS AND MON. BUFF. POINTER
LP'N'STS:	0			;(12) DEVICE STATUS WORD
LP'N'PWC:	XWD LP'N'BL/2,0	;(13) WAKEUP COUNT LIMIT
LP'N'WUC:	0		;(14) ACTIVE WAKEUP COUNT
LP'N'CTR:	0		
LP'N'INW:	0		;(16) INTERRUPT WORD
LPTCH==.-LP'N'DDB
	  EXP 11*LP'N'CHN!LPTDON	;(15) INTERRUPT CHANNEL ASSIGNMENTS
LPTSVE==.-LP'N'DDB
	  MOVE F,LP'N'SV1		;(16) RESTORE F, SAVE AC'S
	  JSR LP'N'SAV			;(17)  AND ESTABLISH P
	  MOVEI F,LP'N'NAM		;(20) SET UP DDB ADDRESS AND RETURN
	  JRST LPTNXT			;(21)  TO COMMON INTERRUPT HANDLER
LPTEX1==.-LP'N'DDB
	  MOVE F,LP'N'SV1		;(22) RESTORE F AND
	  JEN @LP'N'CHL			;(23)  DISMISS INTERRUPT
LPTSV2==.-LP'N'DDB
	  0				;(24) SAVE LOCATION FOR U
LPTECH==.-LP'N'DDB
	  CONSZ LP'N,LPTECM		;(25) THE REST OF THE DDB CONTAINS
LPTDNE==.-LP'N'DDB
	  CONSO LP'N,LPTDON		;(26)  THE ACTUAL I/O INSTRUCTIONS
LPTCSO==.-LP'N'DDB
	  CONSO LP'N,(U)		;(27)  USED BY THE COMMON SERVICE
LPTCSZ==.-LP'N'DDB
	  CONSZ LP'N,(U)		;(30)  ROUTINE TO CONTROL A U
LPTCNI==.-LP'N'DDB
	  CONI  LP'N,U		;(31)  PRINTER. THEY ARE EXECUTED
LPTCNO==.-LP'N'DDB
	  CONO  LP'N,(U)		;(32)  BY MEANS OF AN XCT INSTRUCTION
LPTDTO==.-LP'N'DDB
	  DATAO LP'N,(U)		;(33)  INDEXED TO THE PROPER DDB
LPTBKO==.-LP'N'DDB
	  BLKO  LP'N,LP'N'PTR		;(34)
LPXSTS==.-LP'N'DDB
	CONI LP'N,LP'N'STS		;(35) DEVICE STATUS WORD CONI

SIZLPT==.-LP'N'DDB
;
;  MONITOR BUFFER DEFINITON
;
  LP'N'BL=400
	XWD LP'N'BUF,LP'N'BUF	;IN AND OUT
	EXP LP'N'BUF+LP'N'BL	;LAST
LP'N'BUF:	BLOCK	LP'N'BL	;BUFFER SPACE
;
	INTERN LPTCON,LPTPTR,LPTCH,LPTSVE,LPTEX1,LPTSV2,LPTECH
	INTERN LPTDNE,LPTCSO,LPTCSZ,LPTCNI,LPTCNO,LPTDTO,LPTBKO


	INTERN LPXSTS,SIZLPT
	LIST				;TURN LISTING BACK ON AFTER EXPANSION
>;END IFCPU KI,KL
IFCPU (KS),<	;KS10 LPT DDB GENERATION
LPTBAS==0	;the first of 4000 bytes of -11 virtual adr space
		; reserved for use by the LPT.  this space
		; will be mapped to -10 page containing LPTBUF
LP'N'DDB::
LP'N'NAM: 
	PHASE 0
	LPNAM==SIXBIT /LPT/
	IFE LPTN-1, <LPNAM>		;( 0) PHYSICAL DEVICE NAME
	IFN LPTN-1, <LPNAM+<20+$LPNUM>B23> ;( 0) PHYSICAL DEVICE NAME
	  XWD 6*HUNGST,<N>B23+LPTSIZ    ;( 1) DEVICE CHARACTERISTICS
					; HUNG TIME IS 63 SECS (CODE 6)
	  0				;( 2) DEVICE I/O STATUS
	  XWD 0,LPTDSP			;( 3) LH=DDB LINK, RH=DSP TABLE ADDR.
LPTMOD==1_A+1_AL+1_I			;LPT LEGAL MODES
	  XWD DVOUT+DVLPT,LPTMOD	;( 4) DEVICE CHARACTERISTICS
	  0 				;( 5) LOGICAL DEVICE NAME
	  0				;( 6) BUFFER HEADER ADDRESSES
	EXP 0,0				;7,10 UNUSED
	XWD  0,LP'N'BUF		;(11) CLASS AND MON. BUFF. POINTER
LPTSTS::!0			;(12) DEVICE STATUS WORD
	XWD 200,0		;(13) WAKEUP COUNT LIMIT
	0			;(14) ACTIVE WAKEUP COUNT
LPTBA::!3,,775400		;(16) BASE ADR OF LP20 REGISTERS
LPT11A::!<LPTBUF&777>_2+LPTBAS	;(17) -11 ADR OF START OF MONITOR BFR
LPTWC::!0		;(20) WORD COUNT OF MOST RECENT XFR
LPTFUN::!0		;(21) MOST RECENT FUNCTION TYPE.
LPTEC::!0		;(22) NUMBER OF LPT ERRORS
LPTLBA::!LPTBUF,,<<LPTBUF&777>*4+LPTBAS>;(23) -10,,-11 ADR OF LPT BUFFER
LPTSB::!BLOCK 4			;(24-27) DEVICE REGS ON ERROR
	DEPHASE
SIZLPT==.-LP'N'DDB
	LP'N'BUF,,LP'N'BUF
	LP'N'BUF+LPBSIZ
LP'N'BUF:BLOCK LPBSIZ
INTERN SIZLPT
LP'N'DDS==.-LP'N'DDB
>;IFCPU KS

>;LPTDDB MACRO DEFINITION


IFCPU (<KI,KL>),<EXTERN LPTNXT,LPTECM,LPTINT>
	EXTERN LPTDSP




		$LPNUM==0		;TEMPORARY SYMBOL USED TO FACILITATE
					; MACRO GENERATION

		REPEAT LPTN, <

			LPTDDB \$LPNUM
			$LPNUM==$LPNUM+1
		>
	>;IFG LPTN


;PLOTTER ENTRY POINT

;PAPER TAPE READER ENTRY POINT AND MASK

	INTERNAL PTRMSK
		PTRMSK==0		;MASK==0 IF P-10 READER

;PAPER TAPE PUNCH ENTRY POINT






	LIT

	RELOC .-COMORG

	END
 E 7