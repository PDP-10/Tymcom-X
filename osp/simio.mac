TITLE SIMIO -- VM SYSTEM SIMULATE OLD-STYLE BUFFERED/DUMP IO DSK
SUBTTL AAA APRIL 77    TABLES, EXTERNS..

ENTRY SIMIO
SIMIO:

OPDEF VREMOV [CALLI -65]
OPDEF PREREF [CALLI -75]
OPDEF VPGSTS [CALLI -71]
OPDEF VALPAG [CALLI -76]
OPDEF PERSET [CALLI -72]
OPDEF VDSKPT [CALLI -102]

COMMENT ! THE SIMIO DATA BASE RESIDES IN UPT
IT CONSISTS OF A PAGE BITMAP (UPTPBM, 1 WORD) WHICH
HAS A BIT SET FOR EACH PER-PROCESS PAGE IN USE, AN IO COUNT
(UPTIOC, 1 WORD) WHICH IS INCREMENTED EACH TIME A REQUEST
IS SERVICED BY SIMIO, RESET WHEN IT OVERFLOWS 18 BITS, AND USED
AS A SEQUENCE-STAMP TO KEEP TRACK OF THE LEAST-RECENTLY USED
CHANNEL; AN ARRAY UPTPOS[0:MAXCHN] WHICH HAS THE BLOCK POSITION
IN THE DSK FILE ON EACH CHANNEL 
	0 - NO INPUT DONE, ILLEGAL POSITION (UNLESS SUPERIO)
	<0 - ILLEGAL
	>0 - BLOCK POSITION WHICH WILL BE READ/WRITTEN NEXT
		CALL TO SIMIO. POSITION ADVANCES AS TRANSFER
		ROUTINES INBLT,OUTBLT EXIT.
AND AN ARRAY UPTSIM[0:MAXCHN] WHICH HOLDS SIMIO STATUS INFO
FOR EACH CHANNEL:
BYTE(18)<SEQUENCE-STAMP>(1)GOTPHP(1)NEDRMV(1)NEDMAP(1)GOTHOL
		(4)0(10)<PER-PROCESS VP# FOR THIS CHAN>

PAGES IN PER-PROCESS AREA ARE ASSIGNED TO CHANNELS AS NEEDED,
AND STOLEN FROM THEM ONLY IF NO PAGE IS FREE TO BE ASSIGNED.
UPYCVP PICKS UP THE PAGE-NUMBER ASSIGNED TO CHANNEL IN W. IF 0, NO
PAGE ASSIGNED. 

FOR DEBUGGING, AN EXTRA ARRAY UPTPCN[340:377] IS KEPT TO
VERIFY THAT NO CHANNELS SHARE A PAGE DUE TO ALLOCATION/DE-
ALLOCATION BUGS. THIS CAN COME OUT WHEN CONFIDENCE IS
GAINED.
(6/25/80.  UPTPCN is now removed. /AA)
!

UPSCVP==^D10	;SIZE 
UPNCVP==^D35	;POSITION
UPYCVP:	POINT UPSCVP,%UPT+UPTSIM(W),UPNCVP	;CHANNEL VIRTUAL PAGE
GOTPHP==1B18	;GOT PAST HIGHEST PG FRETURN FROM FCREATE, THIS CHAN
NEDRMV==1B19	;THIS CHAN NEEDS VREMOV OF UPYCVP PAGE
NEDMAP==1B20	;THIS CHAN NEEDS UPTPOS MAPPED INTO UPYCVP
GOTHOL==1B21	;UPTPOS CURRENTLY POINTS AT A HOLE PAGE
		;(ANY REFERENCE TO UPYCVP PAGE WILL FAULT FOR
		; NXM BECAUSE NO PAGE EXISTS TO MAP IN)


DEFINE PAGE(AC,CELL)
< IFNB <CELL>,<MOVE AC,CELL>
	TLNN S,IOSUPR
	ADDI AC,3
	LSH  AC,-2>

	;GENERAL EXTERNS FROM COMMON
EXTERN CPOPJ,CPOPJ1,JOB,%UPT,PBMMSK
	;LMAP AND DATABASE EXTERNS FROM COMMON
EXTERN CPRRDW,CPRRED,VPUMAX,UPTJDA,NUMCHN
EXTERN UPTPOS,UPTSIM,UPTIOC,UPTPBM
;EXTERN UPTPCN
EXTERN LMYERR
	;FILSER EXTERNS FOR ERROR CODES,MISC
EXTERN BLKLSH,FALHOL,FALCPL,FALPHP,FALNHL
EXTERN WRTCHG,NOWRT,IOBDRB,ATBSIZ,JBTRCT,JBTSIN,SIMCRE
	;MISC
EXTERN ADRERR,GTCGSZ,PIOMOD,SMSTAT
	;FROM CORE1
EXTERN EI.OER,EI.DER,EI.DTE,VL.WAT,VLIOE%,PE.NER,FALOPE
EXTERN PS.DTE,PS.DER



FCRID==2	;FCREATE UUO ID FOR SIMIOM,SIMIOS
FNCFCR==40	;FCREATE CHANIO FUNCTION NO.
MAPID==1	;MAP UUO ID
FNCMFP==35	;MAP FILE PAGE CHANIO FUNCTION NO.
FNCMSP==43	;MAP SUPER PAGE CHANIO FUNCTION
SUBTTL EXEC PER PROCESS PAGE ("PPP") MANAGEMENT

COMMENT ! ROUTINE PPPGET
FUNCTION: FIND A PPP AVAILABLE IN THE BITMAP, MARK IN IN USE,
		RETURN ITS PAGE NO.
CALL:	PUSHJ P,PPPGET
	FAIL RETURN, NO PAGE AVAIL, T1/T2/GARB T3/GARB
	SUCCESS RETURN, T2/0,,VP#
DESTROY: T1-T2
NOTICE:  THIS ROUTINE AND ITS FRIEND BELOW EXPECT
	THAT UPTPBM HAS BEEN INITIALIZED TO PBMMSK AT JOB CREATION
	TIME.  A BIT SET IN UPTPBM 0-31 INDICATES THAT
	THE CORRESPONDING PAGE IS IN USE.
!
PPPGET:	SETCM T1,%UPT+UPTPBM	;PICK UP COMPLEMENT, SO JIFFO WORKS
	JFFO T1,.+2
	POPJ P,		;NO FREE PAGES
	MOVSI T1,(1B0)
	MOVNS T2
	LSH T1,(T2)
	TDNE T1,PBMMSK		;IF BIT MOVED THIS FAR DOWN,
	STOPCD			;UPTPBM IS FOULED UP.
	IORM T1,%UPT+UPTPBM	;PAGE'S BIT_1
	MOVNS T2
	ADDI T2,1000	;1ST PPP PAGE MAPS TO VP# 1000, ETC.
	JRST CPOPJ1

COMMENT ! ROUTINE PPPPUT
FUNCTION: MARK A PPP FREE IN BITMAP. STOPCD IF ALREADY MARKED FREE
CALL:	MOVE T1,VP# TO GIVE BACK
	PUSHJ P,PPPPUT
	RETURN HERE T1,T2 CLOB
!
PPPPUT:
	SUBI T1,1000
	SKIPGE T1
	STOPCD
	MOVSI T2,(1B0)
	MOVNS T1
	LSH T2,(T1)
	TDNN T2,PBMMSK	;ARE WE PUTTING BACK AN ILLEGAL BIT?
	TDNN T2,%UPT+UPTPBM ; OR HAS BIT ALREADY BEEN RESET?
	STOPCD
	ANDCAM T2,%UPT+UPTPBM
	POPJ P,
COMMENT ! ROUTINE SIMRLS -- CALLED BY CLOSE CODE
FUNCTION: RETURN ANY PAGE ASSIGNED TO CHANNEL, TO FREELIST.
	VREMOV THE PAGE IF IT'S STILL MAPPED.
	ZAP SEQUENCE COUNT THIS CHAN.
EXPECTS: F,S,W
DESTROYS: T1-T4

!
SIMRLS::
	LDB T1,UPYCVP
	JUMPE T1,SIMRL2	;NO PG ASSIGNED,JUST CLEAN UP
	;CAME W,%UPT+UPTPCN-1000(T1)	;DEBUG
	;STOPCD
	MOVE T2,%UPT+UPTSIM(W)
	TRNE T2,GOTHOL!NEDMAP	;IF PAGE IS A HOLE OR NEEDS
				;MAPPING, NOTHING IS THERE TO VREMOV
	JRST SIMRL1		;HOLE OR NEDMAP, SKIP VREMOV
	PUSHJ P,SIMRMV		;VREMOV IT,GET UPDATED S/DEVIOS
	MOVEM S,DEVIOS(F)	;MAY HAVE SET IODTER,IODERR
	LDB T1,UPYCVP		;RECOVER VP#
SIMRL1:	;SETZM %UPT+UPTPCN-1000(T1)
	PUSHJ P,PPPPUT		;TAKES T1/VP#
SIMRL2:	SETZM %UPT+UPTSIM(W)
	SETZM %UPT+UPTPOS(W)		;FOR GOOD MEASURE, CLEAR FILE POSN
	POPJ P,

COMMENT ! ROUTINE SIMENT -- CALLED BY UENTR IN FILUUO
FUNCTION: IF PAGE IS ASSIGNED ON THIS CHANNEL (USER HAS DONE
	LOOKUP & SOME INPUT'S),& PAGE DOESNT ALREADY NEED
	MAPPING (NEDMAP=1), SET NEDRMV SO THAT THE
	PAGE WILL BE UN-MAPPED AND RE-MAPPED, THIS TIME WITH
	READ-WRITE PROT.
EXPECTS: W/CHANNEL
DESTROY: T1
CALL:	PUSHJ P,SIMENT
	RETURN HERE ALWAYS
!

SIMENT::
	LDB T1,UPYCVP
	JUMPE T1,CPOPJ
	MOVE T1,%UPT+UPTSIM(W)
	TRNN T1,NEDMAP
	TRO T1,NEDRMV
	MOVEM T1,%UPT+UPTSIM(W)
	POPJ P,

COMMENT ! ROUTINE STEALP VERSION 2
FUNCTION: SEARCH ALL CHANNELS WITH PAGE ASSIGNED (NONE: STOPCD)
	FOR THE ONE WITH SMALLEST SEQ NO. THIS IS THE LRU CHANNEL.
	TAKE ITS PAGE AND GIVE IT TO CURRENT CHANNEL.
	LEAVES THE TWO UPTSIM SLOTS AS FOLLOWS:
	OLD: SEQUENCE-NUMBER,,NEDMAP=1, NO UPYCVP
	NEW: SEQUENCE-NUMBER,,NEDMAP=1,UPYCVP=PER PROCESS PAGE
EXPECTS: W
DESTROYS: T1-T4,PG
CALL:	PUSHJ P,STEALP
	RETURN HERE ALWAYS
!

STEALC:: EXP 0  ;COUNTER HOW MANY TIMES DID SYSTEM STEAL
STEALP:
	AOS STEALC
	PUSH P,W
	MOVEI T1,777777	;T1/SMALLEST SEQ VALUE YET FOUND
	MOVNI T2,1	;T2/CHANNEL IT WAS FOUND ON. -1 FLAGS NONE
	MOVSI W,-NUMCHN	;AOBJN
STELP1:
	LDB T3,UPYCVP
	JUMPE T3,STELP3	;NONE ASSIGNED
	HLRZ T4,%UPT+UPTSIM(W);T4/SEQ NO.
	CAML T4,T1
	JRST STELP3
	MOVE T1,T4
	HRRZ T2,W
STELP3:	AOBJN W,STELP1
	SKIPGE T2	;
	STOPCD		;DIDNT FIND CHAN W/PG ASSIGNED,T2 STILL -1
	MOVE T1,%UPT+UPTSIM(T2)	;UPTSIM(OLD CHANNEL)
	TRNN T1,NEDMAP	;SKIP IF OLD CHAN ALREADY NEEDED MAP
	JRST [	MOVE W,T2	;W_OLD CHAN
		PUSH P,F
		PUSH P,S
		PUSH P,T2
		MOVE F,%UPT+UPTJDA(T2) ;F/DDB FOR OLD CHAN
		MOVE S,DEVIOS(F)	;S/OLD CHAN STATUS
		PUSHJ P,SIMRMV		;F,S,W ALL FOR OLD CHAN
		MOVEM S,DEVIOS(F)	;SIMRMV MAY REPORT ERROR IN S
		POP P,T2		;T2/OLD CHAN
		POP P,S
		POP P,F
		MOVE T1,%UPT+UPTSIM(T2) ;UPTSIM(OLD CHAN),UPDATED BY SIMRMV
		JRST .+1]
	POP P,W		;W/CURRENT CHANNEL
;T2/OLD CHAN, T1/UPTSIM(T2), W/CURRENT CHAN
	TRZ T1,NEDRMV!GOTHOL!GOTPHP	;OLD CHAN NEEDS
			;ONLY TO MAP, REMOVE DONE. MAPPER WILL
			;SET GOTPHP,GOTHOL
	LDB PG,[POINT UPSCVP,T1,UPNCVP]	;THE VP SLOT WE'RE STEALING
	;CAME T2,%UPT+UPTPCN-1000(PG)	;DEBUG
	;STOPCD
	MOVEI T4,0
	DPB T4,[POINT UPSCVP,T1,UPNCVP] ;OLD CHAN NOW HAS NO PAGE
	MOVEM T1,%UPT+UPTSIM(T2)
	MOVE T3,%UPT+UPTSIM(W)	;T3/UPTSIM(CURRENT CHAN)
	TRZ T3,NEDRMV!GOTHOL!GOTPHP ;CURRENT CHAN DOESNT NEED
		;TO REMOVE,THAT'S ALREADY DONE
		;GOTHOL & GOTPHP WILL BE SET IF NEEDED WHEN
		;PAGE IS MAPPED.
	TRO T3,NEDMAP	;CURR CHAN NEEDS TO MAP UPTPOS DATA
	DPB PG,[POINT UPSCVP,T3,UPNCVP] ;NEW CHAN NOW HAS VP SLOT
	MOVEM T3,%UPT+UPTSIM(W)
	;MOVEM W,%UPT+UPTPCN-1000(PG)	;DEBUG
	POPJ P,
SUBTTL DATA XFER SETUP ROUTINES
COMMENT ! ROUTINE SIMIOA -- ASSIGN PG, SETUP MAP,REMOV BITS
FUNCTION:	GET NEW PPP ASSIGNED IF NEEDED. SET NEDRMV
	IF HAD TO STEAL A PAGE. SET NEDMAP IF HAD TO
	ASSIGN A PAGE. UPDATE SEQUENCE COUNT TO SHOW THE
	CURRENT CHANNEL MOST RECENTLY USED.
EXPECTS: F,S,W
DESTROYS: T1-T4,PG
CALL:	PUSHJ P,SIMIOA
	RET HERE ALWAYS
!

SIMIOA:
	LDB T1,UPYCVP	;T1/ASSIGNED PG
	JUMPN T1,SIMIA3	;GOT ONE ALREADY,NO NEED TO FINAGLE
	PUSHJ P,PPPGET	;RETRN T2/NEW PG
	JRST SIMIA1	;NONE TO GET, GOTTA STEAL
	;SKIPE %UPT+UPTPCN-1000(T2)	;DEBUG
	;STOPCD		;DEBUG
	DPB T2,UPYCVP	;W/CHANN GETS THE PG
	;MOVEM W,%UPT+UPTPCN-1000(T2)	;DEBUG
	JRST SIMIA2
SIMIA1:	PUSHJ P,STEALP	;GIVES US THE PG OF THE LRU CHANNEL
SIMIA2:	MOVEI T1,NEDMAP	;CURR CHAN NEEDS TO MAP IN THE
	IORM T1,%UPT+UPTSIM(W)	;DATA AT %UPT+UPTPOS(W)
SIMIA3:	AOS T1,%UPT+UPTIOC		;UPDATE SEQ COUNT
	TLNE T1,-1		;ONLY 18 BITS BEFORE OVERFLOW
	PUSHJ P,SIMIA5		;FIX OVERFLOW
	HRLM T1,%UPT+UPTSIM(W)	;STAMP CURR CHAN MOST RECENT
	POPJ P,			;RETURN

COMMENT ! ROUTINE SIMIA5
FUNCTION: FIX UP WHEN UPTIOC OVERFLOWS 18 BITS. RESET
	UPTIOC AND ALL CHANNEL SEQ NOS. THEN RETURN T1
	SET FOR STAMP CURR CHAN AGAIN.
!
SIMIA5:
	SETZM %UPT+UPTIOC	;IO COUNT BACK TO 0
	MOVSI T1,-NUMCHN
	HRRZS %UPT+UPTSIM(T1)	;ZERO LEFT HALF
	AOBJN T1,.-1
	AOS T1,%UPT+UPTIOC	;CURR CHAN NOW 1,ALL OTHERS 0
	POPJ P,
COMMENT ! ROUTINE SIMIOB
FUNCTION:1)IF FILE VIRGIN, DEVPOS_UPTPOS_1,NEDMAP_1,SET J/POS, EXIT.
	2) IF A USETI/O HAS HAPPENED (DEVPOS SIGN BIT ON),
		UPTPOS_DEVPOS_DEVPOS TLZ 1B0, SET J/POS,
		CLEAR GOTPHP & SET NEDRMV IF CHANGING PGS, EXIT.
	3) IF NEITHER OF THESE, THEN UPTPOS IS CORRECT BLOCK
		POSITION FOR CURRENT DATA XFER. SET J/POS & EXIT.
 IS POS ?
POS IS THE WORD NUMBER IN THE CURRENT PAGE, SET UP FOR BLT'S.
POS ALWAYS AT AN INGEGRAL BLOCK (200 WDS) BOUNDARY:
BLOCK IN FILE:	  1	  2	  3	  4	  5	ETC.
POS VALUE:	000	200	400	600	000	ETC.

CALL:	PUSHJ P,SIMIOB
	ALWAYS RETURN HERE, J/POS
EXPECTS: F,S,W,DEVPOS(F) %UPT+UPTPOS(W)
DESTORY: T1,T2,T3,J
!

SIMIOB:
	TLZE S,IOBEG		;IF VERY FIRST I/O UUO,
	JRST [	MOVEM S,DEVIOS(F)
		SKIPL T1,DEVPOS(F)	;CHECK FOR USETI/O FIRST
		MOVEI T1,1	;OR START FILE AT BLK 1,
		TLZ T1,(1B0)	;CLEAR USETI/O FLAG,
		MOVEM T1,DEVPOS(F)	;AND NOTE CURRENT
		MOVEM T1,%UPT+UPTPOS(W)	;POSN IN BOTH PLACES,
		JRST SIMIB2]	;NOW GO SET POS
	SKIPL T1,DEVPOS(F)	;SIGN SET IF ANY USETI/O
	JRST SIMIB2	;NONE. JUST SEQUENTIAL IN'S OR OUT'S
	TLZ T1,(1B0)
	MOVEM T1,DEVPOS(F)	;RESTORE WITHOUT USETI/O FLAG
	MOVE T2,%UPT+UPTPOS(W)	;BLOCK WE'D HAVE TOUCHED NEXT IF NO USETI/O HAD HAPPENED
	MOVE T3,%UPT+UPTSIM(W)	;STATUS
	MOVEM T1,%UPT+UPTPOS(W)	;NEW BLOCK
	TRNE T3,NEDMAP!NEDRMV	;IF EITHER BIT IS ON, WE CAN FORGET
	JRST SIMIB1	;ABOUT UPYCVP PG AND USE THE USETI/O'D PG
	PAGE (T2)		;FORMER PAGE
	PAGE (T1)		;T1/USETIO'D PAGE
				;RESET GOTPHP AFTER ANY
	CAMN T1,T2		;USETI/O WHICH CHANGES PAGES,
	JRST SIMIB2		;BECAUSE BREAKS SEQUENCE OF
				;FCREATES AT EOF AND
				;WE ARE NOT SURE ANY MORE
SIMIB1:	TRZ T3,GOTPHP		;THAT NEXT VMAP WOULD GET FALPHP ERROR
	TRNN T3,NEDMAP		;IF PAGE ALREADY MAPPED,SET
	TRO T3,NEDRMV		;NEDRMV TO GET RID OF OLD DATA
		;BEFORE MAPPING NEW UPTPOS INTO UPYCVP
	MOVEM T3,%UPT+UPTSIM(W)

SIMIB2:
	;CALCULATE POS FROM CURRENT %UPT+UPTPOS(W)
	MOVE T1,%UPT+UPTPOS(W)	;BLOCK POSITION
	TLNN S,IOSUPR
	SUBI T1,1
	IDIVI T1,4		;T2/BLOCKS MOD 4
	LSH T2,BLKLSH  		;T2/WORD POSITION IN PAGE
	HRRZM T2,J
	POPJ P,
COMMENT ! ROUTINE SIMADV
FUNCTION: ADVANCE UPTPOS BY WORDCOUNT OF JUST-COMPLETED DATA
	XFER, WATCHING FOR CROSSING PAGE BOUNDARY
CALL:	MOVE T4,BLOCK COUNT OF XFER
	PUSHJ P,SIMADV
	RETURN HERE, PAGE DIDNT CHANGE
	RETURN HERE, PAGE CHANGED, NEDRMV SET
EXPECTS: F,W,S
DESTROY: T1,T2,T4
!

SIMADV:
	PAGE (T2,%UPT+UPTPOS(W))
	ADDB T4,%UPT+UPTPOS(W)
	MOVE T1,T4
	PAGE (T4)
	EXCH T1,DEVPOS(F)	;UPDATE DEVPOS, BUT CHECK THAT
	TLNE T1,(1B0)		;USETIO FLAG STILL OFF
	STOPCD
	CAMN T4,T2		;PAGE(OLD UPTPOS)=PAGE(NEW UPTPOS)?
	POPJ P,		;YES
	MOVEI T2,NEDRMV
	IORM T2,%UPT+UPTSIM(W)
	JRST CPOPJ1


COMMENT ! ROUTINE SIMRMV
FUNCTION: REMOVE PAGE ASSIGNED TO W/CHANNEL, UNLESS
	THAT PAGE IS A HOLE (DISCOVERED DURING INBLT)
	IF PAGE IS RDW (ENTRB SET OR DOING SUPER OUTPUT),CHECK FOR
	ERROR ON THE VALIDATE AND RETURN UPDATED S/DEVIOS.

	SET NEDMAP. CLEAR NEDRMV,GOTHOL

CALL:	PUSHJ P,SIMRMV
	RETURN HERE ALWAYS
EXPECTS: F,S,W
DESTROY: T1-T3, UPDATE S/DEVIOS(F)
!

SIMRMV:
	MOVE T3,%UPT+UPTSIM(W)
	TRNE T3,GOTHOL	;SKIP IF VP HAS A HOLE MAPPED
	 JRST SIMRM2	;NOTHING MAPPED THERE,JUST CLEAN UP
	LDB T2,UPYCVP		;ASSIGNED VP#, BETTER BE NON-ZERO
	SKIPN T2
	STOPCD
	HRLI T2,1		;T2/<COUNT=1>,,VP#
	TLNE S,IOSUPR	;PAGE IS RDW IF SUPER-OUTPUT
	TLNN S,IO	;OR ENTRB, ELSE RDO
	TLNE F,ENTRB	;IF RDW, NEED TO CHECK SUCCESS
	SKIPA		;OF THE VALIDATE
	JRST SIMRM1	;RDO--INPUT--PRETTY SIMMPLE
;BEGIN CODE FOR OUTPUT ONLY--AT SOME POINT IN THE USAGE ON
;THIS CHANNEL THE PAGE WAS WRITEABLE EVEN THOUGH WE MAY
;NEVER HAVE WRITTEN IT.
	MOVE T1,T2	;T1/1,,VP#
	PERSET T2,	;PE.NER:=0 IE, WATCH FOR ERRORS
	STOPCD
	VREMOV T2,	;MAY GET FALOPE; OTHERS ARE BUG
	SKIPA
	JRST SIMRM2	;GREAT! GO CLEAN UP
	HRRZS T2	;T2/ERR CODE
	CAIE T2,FALOPE
	STOPCD
	MOVE T2,T1	;T2/1,,VP#
	VPGSTS T2,	;GET T2/ERROR BITS ETC.
	STOPCD
	MOVE S,DEVIOS(F);MOST UP-TO-DATE DEVIOS
	TLNE T2,PS.DTE	;DATA ERR
	TRO S,IODTER
	TLNE T2,PS.DER	;DEVICE
	TRO S,IODERR
	MOVE T2,T1	;T2/1,,VP#
	HRLI T2,PE.NER+1 ;T2/<IGNORE ERRORS>+<COUNT=1>,,VP#
	PERSET T2,
	STOPCD
	MOVE T2,T1	;T2/1,,VP#
;END CODE FOR STRICTLY OUTPUT--RDW PAGE. BEGIN COMMON CODE FOR
;FAILING OUTPUT REMOV AND INPUT REMOVE
SIMRM1:	VREMOV T2,
	STOPCD		;PE.NER SET, NOT EVEN FALOPE EXPECTED
SIMRM2:	;EXPECT T3/UPTSIM(W)   CLEAN UP
	TRZ T3,NEDRMV!GOTHOL
	TRO T3,NEDMAP
	MOVEM T3,%UPT+UPTSIM(W)
	POPJ P,
COMMENT ! ROUTINE SIMIOM -- PAGE MAPPER
FUNCTION: MAP THE UPTPOS PAGE WITH APPROPRIATE PROTECTION INTO
	VP ASSIGNED FOR THE CHANNEL. ON OUTPUT, CREATE & MAP
	FILE PAGES IF OUTPUT IS INTO A HOLE OR PAST EOF.
	ON CREATE FILE PAGE, BACK OFF CHARGES IMPOSED BY THE
	UUO, AND LATER ON WHEN BLOCKS ARE XFERRED, CHARGE BY
	THE BLOCK.
 PROT_(IF SUPER-OUTPUT OR ENTRB THEN RDW ELSE RDO)

CALL:	PUSHJ P,SIMIOM
	 ERROR , T1/UUO IDENTIFIER,,UUO ERROR CODE
	SUCCESS
DESTROY: T1-T4
EXPECTS: F,S,W
CALLS: MAPUUO,FCREATE, MAPERR, FCRERR
	ON MAP OR FCREATE ERRORS, JSP T2,XXXERR 
	ERROR CODE IN T1. BY CONVENTION T1 IS THE UUO AC HERE.
	THE JSP T2 IS TO ALLOW TRACKING DURING DEBUG. THE XXXERR CODE
	WILL POPJ FAIL RETURN UNLESS STOPCD IS INDICATED.

WORKING-SETS: THIS ROUTINE DOES NOT PUT ANY MAPPED PAGE INTO
	UWS OR MWS. WHEN THE PAGE IS TOUCHED, IT WILL COME INTO
	THE MWS. THE BLTS IN INBLT,OUTBLT ARE THE PLACES
	WHERE THE PAGE GETS TOUCHED.

EXITS:  SIMIMX -- SUCCESS. NEDMAP RESET
	MAPERR/FCRERR - FAIL.  NEDMAP STILL SET (EXIT THRU SIMIMF)

!
SIMIOM:
	PUSH P,P1
	PUSH P,P2	;USE THESE TWO FOR MAP UUO ARG BLK
	MOVEI T1,NEDRMV		;DEBUG CHK. THIS SHOULD B OFF
	TDNE T1,%UPT+UPTSIM(W)
	STOPCD
	LDB P1,UPYCVP	;ASS PG
	HRLI P1,<<CPRRED>B7+1B17>B<^D35+^D18>
	TLNE S,IOSUPR
	TLNN S,IO
	TLNE F,ENTRB
	HRLI P1,<<CPRRDW>B7+1B17>B<^D35+^D18>
	PAGE (P2,%UPT+UPTPOS(W))
	HRRZ T1,W
	HRLI T1,FNCMFP	;MAP FILE PAGE CHANIO FUNCTION
	TLNE S,IOSUPR	;UNLESS SUPER
	HRLI T1,FNCMSP
	TLNE S,IO	;SKIP IF PRESENTLY DOING INPUT
	JRST SIMIM1
	CHANIO T1,P1
	JSP T2,MAPERR
SIMIMX:	;GENERAL SUCCESS EXIT AFTER MAPPING, IN OR OUT. P1,P2
	;ARE MAP ARG BLOCK. 
	HRLI P1,PE.NER+1	;P1/<IGNORE>+<COUNT=1>B17+VP#
	PERSET P1,	;TELL SYSTEM TO IGNORE SWAP ERR THIS PG
	STOPCD		;NO ERRORS PERMISSABLE THIS UUO
	MOVEI T1,NEDMAP		;THIS SHOULD BE ON
	XORB T1,%UPT+UPTSIM(W)	;RESET IT
	TRNE T1,NEDMAP		;SKIP IF IT WAS
	STOPCD
	AOS -2(P)		;BEHIND P1,P2 IN PDL
SIMIMF:	;GENERAL FAILURE EXIT. T1/UUOID,,CODE
	POP P,P2
	POP P,P1
	MOVE S,DEVIOS(F);VMAPS MAY HAVE SET DEVIOS BITS
	POPJ P,

SIMIM1:	;OUTPUT. IF IOSUPR, DO SMAP & DONT ANALYZE FAILURES
	TLNE S,IOSUPR
	JRST [CHANIO T1,P1	;DO SUPER-MAP
		JSP T2,MAPERR	;LET SIMIOS DISPATCH ON ERR CODE
		JRST SIMIMX]	;SUCCESS
	;REGULAR OUTPUT. IF ALREADY GOT "PAST HIGHEST PAGE" AND NO USETI/O
	;HAS INTERVENED, THEN GO DIRECTLY TO THE FCREATE. OTHERWISE
	;TRY TO MAP THE PAGE. THIS MAY GIVE "PAST HIGHEST PAGE"
	;ERROR. SET GOTPHP IF SO, & GO CREATE.
	;POSSIBLE TO GET APPEND-ONLY FILE VIOLATION HERE.
	; SEE IF MAP WILL SUCCEED WITH THE PRIVILEDGE
	;BIT GETB ON. (A HACK IN MAPUUO ALLOWS SUCCEED ON MAPPING
	;BEFORE EOF IF GETB ON AND IT'S THE VERY LAST PAGE).

	MOVEI T2,GOTPHP
	TDNE T2,%UPT+UPTSIM(W)
	JRST SIMIM2	;GOT FALPHP ONCE ALREADY

	CHANIO T1,P1	;TRY TO MAP THE PAGE ONTO WHICH
	SKIPA			;WE'RE GOING TO WRITE
	JRST SIMIMX	;'RAY!
	
	;T1/VP#,,MAPUUO ERROR CODE
	HRRZS T1
	CAIN T1,FALPHP  	;PAST HIGHEST PAGE?
	JRST [ MOVEI T1,GOTPHP
		IORM T1,%UPT+UPTSIM(W)
		JRST SIMIM2]
	CAIN T1,FALHOL	;A HOLE?
	JRST SIMIM2	;P2/PG NO OF HOLE
	CAME T1,FALCPL	;POSSIBLE APPEND-ONLY VIOLATION?
	JSP T2,MAPERR		;NON OF THESE. BOMB

;DEAL WITH POSSIBLE APPEND-ONLY VIOLATION, OR MAYBE LEGITIMATE
;APPEND REQUEST REQUIRING SPECIAL PRIVILEDGED MAP TO GET THE
;LAST PAGE AND WRIT IN IT.
	TLNE S,IOSUPR	;IF SUPERIO, CANT BE APPEND ERR
	JSP T2,MAPERR
	MOVEI T2,NOWRT  
	TDNN T2,DEVIAD(F)	;APPEND-ONLY FILES HAVE NOWRT ON
	JSP T2,MAPERR		;SOME OTHER MAP FAILURE
	HRRZ T2,DEVATB(F)
	LDB T3,ATYBSZ		;INTEGRAL # BLKS ALREADY IN FILE
	CAML T3,%UPT+UPTPOS(W)	;SKIP IF CURR POSITION IS
				;PAST THE LAST BLOCK (ALTHO IT'S
				;IN THE LAST PAGE)
	JSP T2,MAPERR		;GIVE FALCPL FRETURN, USER NOT
				;ADVANCED FAR ENUF IN FILE YET.
	TLNN F,ENTRB		;IF ENTRB OFF, MAP WILL FAIL
	JSP T2,MAPERR		;SO DONT BOTHER. 
	MOVSI F,GETB		;TURN ON PRIVILEDGE FLAG
	IORM F,%UPT+UPTJDA(W)	;IN MEMORY ONLY (AC F DOESNT MATTER)
	HRRZ T1,W		;CHANIO MAP ARG:
	HRLI T1,FNCMFP		;T1/"MAP FILE PG",,CHANNEL
	CHANIO T1,P1		;TRY PRIVILEDGED MAP APPEND-ONLY
	 JRST [	ANDCAB F,%UPT+UPTJDA(W)	;GETB_0 IN F,MEMORY
		JSP T2,MAPERR]	;NOT EVEN PRIVILEDGED WORKED
	ANDCAB F,%UPT+UPTJDA(W)	;GETB_0 IN F,MEMORY & RESOTRE F
	JRST SIMIMX

;CREATING PAGES TO EXTEND FILE OR FILL HOLE: OUTPUT
;NEVER COME HERE IF IOSUPR
;EXPECTS: P1/ MAPUUO ARG   P2/ PAGE NUMBER TO MAP

COMMENT ! AFTER TRYING TO MAP THE PG, SOMEONE ELSE MAY SNEAK
 IN AND CREATE IT BEFORE WE DO HERE; SO THIS SIMCRE MAY
 FAIL. OR SOMEBODY MAY TRUNCATE FILE AFTER
 WE CREATE THE PG, SO THE MAP HERE MAY FAIL. THESE
 WIERDNESSES ARISE ONLY WHEN SIMULATNEOUS UPDATERS
 ARE FOOLING WITH THE FILE VIA SIMIO. THERE IS NO
 CHECK HERE TO PREVENT AN INFINITE LOOP OF FAILURES
 BECAUSE SUPPOSEDLY THAT WONT EVER HAPPEN. EVENTUALLY EITHER
 THE PAGE WILL GET CREATED & MAPPED BY US, OR CREATED
 BY SOMEBODY ELSE AND MAPPED BY US. !

SIMIM2:	MOVE T1,P2	;T1/PG NO. FAILING MAP UUO
	PUSHJ P,SIMCRE	;EXPECTS T1. CLOB T1-T4,U,PG.
		;SIMCRE SUCCEEDS SKIPPING WITH FILE
		;SIZE ATBSIZ SET TO WORD 1 IN THIS
		;CREATED PG, IFF THIS IS LAST PG IN FILE.
	JRST [	HRRZS T1	;ERR CODE
		CAIE T1,FALNHL	;NOT A HOLE?
		JSP T2,FCRERR	;SOME OTHER PROBLEM
		JRST SIMIM3]	;SOME SNEAKY PERSON CREATED IT
				;BEHIND OUR BACK. GO MAP IT.
; No longer need to charge back because SIMCRE calls VMOVPG
; which doesn't accumulate disk writes.
;	MOVNI T1,4	;UNDO 4 BLOCKS CHARGED
;	PUSHJ P,WRTCHG	;USING STANDARD ROUTINE
			;AND CHARGE BY THE BLOCK AS XFERRED
SIMIM3:	HRRZ T1,W		;NOW TRY TO MAP THE CREATED PG
	HRLI T1,FNCMFP		;CHANIO MAPUUO ARG
	CHANIO T1,P1		;MAP THE (P2) PAGE
	JRST [	HRRZS T1	;ERR CODE
		CAIE T1,FALHOL	;IF HOLE
		CAIN T1,FALPHP	;OR PAST HIGHEST PAGE,
		JRST SIMIM2	;TRY TO CREATE (AGAIN?)
		JSP T2,MAPERR]	;SOME OTHER PROBLEM
	JRST SIMIMX		;MAP SUCCEEDED,HOORAY

;UUO FAILURES, COME HERE. T1/DATA,, UUO ERROR NUMBER
;THEN SETUP T1/ UUO IDENTIFIER INTEGER,, UUO ERROR NUMBER,
;AND FAIL RETURN FROM SIMIOM. CALLERS OR THEIR CALLERS
;WILL INTERPRET T1 AND SET BITS IN DEVIOS, ETC.

MAPERR:
	HRRZS T1
	HRLI T1,MAPID
	JRST SIMIMF	;EXIT,FIX PDL

FCRERR:	;FCREATE
	HRRZS T1
	HRLI T1,FCRID
	JRST SIMIMF
SUBTTL DEVICE SERVICE ROUTINES CALLED BY INPUT,OUTPUT,USETX,CLOSE UUOS

COMMENT ! ROUTINE OUTBLT
FUNCTION: MOVE <USERWC> WORDS TO CURRENT FILE POSITION
	FROM USER AND UPDATE MRU CHANN AND CURR FILE POSITION.

CALL:	MOVE T4,[XWD <USERWC>,,<USERADDR>]
	HRRZ AC,DEVSER(F)
	PUSHJ P,DDO(AC)		;OUTBLT IS THE DSK DUMP OUTPUT ROUTINE
	RETURN ALWAYS HERE. S,DEVIOS UPDATED
EXPECTS: F,S,W	(J)=JOB/JOB NO;		PRESERVES F,U,W
DESTROYS: T1-T4,PG,SETS J_JOB
EXITS: OUBLT4 (SUCCESS), SIMIOS( UUO FAILURE) OUBLTE (DATA ERROR)
!

OUTBLT::
	JSP T1,CKARG
	TLNN S,IO	;SHOULD BE ON; IF WAS OFF, SOMEBODY
	STOPCD		;GOOFED, CALLED OUTBLT DURING INPUT
	PUSH P,P1	;NEED AC FOR COUNT
	PUSH P,T4	;0(P)/USERWC,,USERADDR DURING THIS ROUTINE (NOT PRESERVED)
	TLNN S,IOSUPR	;SKIP IF DOING SUPERIO
	JRST OUBLTA	;REGULAR IO,NO NEED TO CHECK THIS:
	MOVE T2,DEVIAD(F);GET PRIV BITS SET BY SUPBEG WHEN HE DID
	TLNN T2,NOWRT	;HIS FIRST SUPER USETI/O/INPUT
	JRST OUBLTA	;OK FOR HIM TO WRITE (WA LICENSE)
	TRO S,IOIMPM
	JRST OUBLTE	;SLAP HIS HANDS
OUBLTA:
	PUSHJ P,SIMIOA	;ASSIGN PAGE, UPDATE MRU CHAIN
OUBLT0:	PUSHJ P,SIMIOB	;GET J/POS,DEVPOS(F),%UPT+UPTPOS(W) SET
	HLRZ T1,0(P)	;T1/<USERWC>
	MOVEI P1,1000
	SUB P1,J		;1000-POS = SPACE TO END OF PAGE
	CAML P1,T1
	MOVE P1,T1	;P1_MIN( [1000-POS] , <USERWC> )
	MOVE T4,%UPT+UPTSIM(W)
	TRNE T4,NEDRMV	;DOES UPYCVP PG NEED VREMOV
	PUSHJ P,SIMRMV	;YES; NEDMAP_1
	MOVEI T4,NEDMAP	;DOES UPTPOS PAGE NEED MAPPING IN?
	TDNN T4,%UPT+UPTSIM(W)	;SKIP YES
	JRST OUBLT1		;NO,PAGE ALREADY ADDRESSABLE
	PUSHJ P,SIMIOM	;YES,TRY TO MAP PAGE. CREATE IT IF
			;HOLE OR PAST EOF.
	PJRST SIMIOS	;FAILED. T1/UUOID,,CODE

OUBLT1:	;COMPUTE BLT POINTERS FOR XFER DATA TO FILE PG 
	;ADDRESSABLE IN UPYCVP
	LDB T3,UPYCVP	;T3/ASSIGNED VP# 1000--VPUMAX
	SUBI T3,CNVVPN	;T3/EXEC VP# 340--370 ETC.
	LSH T3,9
	ADDI T3,(J)	;T3/EXEC ADDR OF BLK IN ASSIGNED VP
	HRL J,T3	;J/EXEC ADDR OF BLK,,WORD NO. IN PG
	HRRZ T4,T3
	HRL T3,0(P)	;T3/USERADDR,,FILE WORDADDR
	ADDI T4,-1(P1)	;T4/END OF BLT
OUBLT2:	;NOW TOUCH PG FOR FIRST TIME, CAUSING PG FLT TO GET DATA
	;OR ASSIGN COR PG OF ZEROS (IF NEW FILE PG).
	;BLT WORDS TO FILE PG FROM USER SPACE
	JSP T1,.+1	;SAVE FLAGS LH OF T1
	JRSTF @[XWD PC.UIO,.+1]	;FORCE USER MAP
	XCTFU <BLT T3,(T4)>
	HRRI T1,.+2	;FIX RH OF T1 FOR
	JRSTF @T1	;RESTORE FLAGS
	PUSHJ P,ERRINF		;GET S/BITS OR SKIP IF NO ERR
	JRST OUBLTE		;SET DEVIOS,FIX STK,RTN

OUBLT3:	;IF COUNT .NE. 0 MOD 200, BLT ZEROS TO BALANCE OF
	;UPTPOS BLOCK IN FILE PAGE: [VP+POS+COUNT,VP+POS+(COUNT IOR 177)]
	;AND SET COUNT TO NEXT HIGHER MULTIPLE OF 200

	MOVE T2,P1	;COUNT
	IDIVI T2,200
	JUMPE T3,[MOVE T4,T2	;T4/INTEGRAL BLK COUNT
		JRST OUBLT4]
	HLRZ T3,J	;T3/EXEC VIRT ADDR OF BEGINNING OF BLK
	ADD T3,P1	;ADD COUNT
	HRRZ T4,T3
	IORI T4,200-1	;T4/END BLT: VP+POS+COUNT IOR 177
	HRLS T3
	SETZM (T3)	;POSSIBLE PG. FLT. & DATA ERROR
	HRRI T3,1(T3)	;T3/VP+POS+COUNT,,VP+POS+COUNT+1
	CAIL T4,(T3)	;SKIP IF NO BLT NECESSARY. (1 SETZM ENUF)
	BLT T3,(T4)	;NO REF TO USER SPACE. POSSIBLE
			;PG FLT & PERHAPS DATA ERROR.
	PUSHJ P,ERRINF		;SKIP IF NO ERR
	JRST OUBLTE		;S/BITS ARE SET
	HRRZI T4,1(T2)	;T4/1+COUNT//200 = NEXT MULTIPLE 200
OUBLT4:	;ADVANCE UPTPOS BY INTEGRAL BLK COUNT IN T4.
	;AND CHARGE USER FOR BLOCKS WRITTEN
	;AND UPDATE READ/WRITE COUNTS PER UNIT
	PUSH P,T4
	PUSHJ P,SIMADV	;CHECKS FOR PG BOUNDARY
	JFCL		;(DIDNT CROSS, DONT CARE)
	MOVE T1,0(P)	;BLKS XFERRED
	LDB T2,UPYCVP	;T2/VP# ASSIGNED THIS CHAN
	VDSKPT T2,	;GET T2/RETR. PTR THIS PAGE, SKIP SUCCESS
	SKIPA		;FAILED, DONT UPDATE.
	PUSHJ P,SMSTAT	;EXPECTS S/IO+MODE,T1/BLKS, T2/RETR. PTR
	POP P,T1
	MOVE J,JOB
	PUSHJ P,WRTCHG	;CHARGE FOR T1/BLOCKS WRITTEN

	;IF MORE WORDCOUNT EXISTS, CONTINUE LOOPING, ELSE
	;UNWIND STACK & EXIT

	MOVN T2,P1
	HRL P1,T2	;P1/-COUNT,,COUNT
	ADDB P1,0(P)	;UPDATE 0(P)/USERWC,,USERADDR
	HLRES P1
	JUMPG P1,OUBLT0	;WHILE WC.GT. 0 XFER DATA, MAY NEED TO
		;MAP ANOTHER FILE PAGE
	LDB T1,PIOMOD	;IF DUMP OUTPUT, VALIDATE & WAIT.
	CAIGE T1,SD	;SKIP IF DUMP MODE
	JRST OUBLT6	;FIX PDL & RETURN. BUFFERED
	LDB T1,UPYCVP
	TLO T1,VL.WAT+1	;T1/<WAIT>+<COUNT>+VP#
	VALPAG T1,	;DO NOT RETURN UNTIL DATA WRITTEN
	STOPCD		;EVEN IO ERR SHOULD SKIP, PE.NER SET !
	MOVE S,DEVIOS(F);MOST UP TO DATE DEVIOS
	PUSHJ P,ERRINF	;GET BITS IN S,SKIP IF NONE SET

OUBLTE:	;PAGE SHOWED ERROR WHEN TOUCHED OR VALIDATE FAILED. EXIT
	;WITH DEVIOS BITS ON

	MOVEM S,DEVIOS(F)


OUBLT6: ;HERE FROM OUBLT4 FOR SUCCESS RTN
	POP P,T1	;GET RID OF MODIFIED USERWC,,USERADDR
	POP P,P1
	MOVE J,JOB	;FOR ALL EXITERS
	POPJ P,

COMMENT ! ROUTINE CKARG
FUNCTION: CHECK T4/USERWC,,USERADDR FOR INBLT,OUTBLT
	GOTO ADRERR IF USER TRYING TO DO IO TO AC'S
	STOPCD IF USERWC BAD (CALLING MONITOR ROUTINE
	SHOULD HAVE CAUGHT IT.  
ADDRESS-CHECKING FOR I/O:  SINCE ALL 'I/O' IS DONE
	WITH BLT'S, IF THE USER OFFERS AN ILLEGAL ADDRESS,
	THE BLT WILL GET AN ILL MEM REF WHEN IT PAGE-FAULTS.
	SO SOME DATA TRANSFER WILL TAKE PLACE UP TO THE
	POINT OF THE ILLEGAL ADDRESS, WHEREAS UNDER THE
	OLD DIRECT DUMP & BUFFERED IO SYSTEM ALL
	ADDRESSES WERE CHECKED BEFORE ANY I/O BEGAN.
CALL:	MOVE T4,[USERWC,,USERADDR]
	JSP T1,CKARG
	RETURN HERE, T2/GARB
!
CKARG:	HLRZ T2,T4
	CAIGE T2,1
	STOPCD		;CALLER CONFUSED
	HRRZ T2,T4	;USERADDR
	CAIG T2,17	;BELOW 17 IS AC'S
	JRST ADRERR
	JRST (T1)	;RETURN
COMMENT ! ROUTINE INBLT
FUNCTION: MOVE <USERWC> WORDS FROM CURRENT FILE POSN TO
	<USERADDR>, UPDATE MRU CHANN AND FILE POSN, AND IF
	CURR POSN GOES TO FIRST BLK NEXT PAGE, MAP & PREREF
	THE PAGE .  IN CASE USER IS TRYING TO
	INPUT FROM A HOLE, BLT ZEROS TO HIS DATA AREA.
	     DO NOT ENFORCE INTEGRAL-MULTIPLE OF 200-WORD
	XFERS, BUT SIMULATE DISK CONTROLLER ADVANCING
	TO NEXT BLOCK BOUNDARY BY ADVANCING POS BY INTEGRAL
	MULTIPLE OF 200 WORDS, AND CHARGE HIM FOR INTEGRAL
	BLOCKS READ.  HANDLE ANY ERRORS, SETTING DEVIOS BITS
	VIA SIMIOS EXIT.
EXPECTS: F,S,W, (J)=JOB/JOB NUMBER
DESTROYS: T1-T4,PG, SETS J_JOB
CALL:	MOVE T4,[<USERWC>,,<USERADDR>]
	HRRZ AC,DEVSER(F)
	PUSHJ P,DDI(AC)		;INBLT IS DSK DUMP INPUT ROUTINE
	ALWAYS RETURN HERE. S,DEVIOS UPDATED
EXIT: THRU INBLT5 (SUCCESS), INBLTE (DATA ERROR) OR
	SIMIOS (UUO FAILURES)
!

INBLT::
	JSP T1,CKARG
	PUSH P,P1	;NEED AC FOR COUNT
	PUSH P,T4	;0(P)/ USERWC,,USERADDR DURING INBLT
	TLNE S,IO	;THIS SHOULD BE OFF
	STOPCD		;WASNT. SOMEBODY CALLED INBLT DURING OUTPUT
	PUSHJ P,SIMIOA	;ASSIGN PAGE, UPDATE MRU CHAIN
INBLT0:	PUSHJ P,SIMIOB	;GET J/POS,DEVPOS(F),%UPT+UPTPOS(W) SET
	HLRZ T1,0(P)	;T1/<USERWC>
	MOVEI P1,1000
	SUB P1,J	;1000-POS = SPACE TO END OF PG
	CAML P1,T1
	MOVE P1,T1	;P1_MIN( [1000-POS] , <USERWC> )
	MOVEI T4,NEDRMV	;DOES UPYCVP PG NEED REMOVE?
	TDNE T4,%UPT+UPTSIM(W)
	PUSHJ P,SIMRMV	;YES,REMOVE,NEDMAP_1; NEDRMV_GOTHOL_0
	MOVEI T4,GOTHOL	;ARE WE LOOKING AT
	TDNE T4,%UPT+UPTSIM(W)	;HOLE PAGE IN FILE?
	JRST INBLT7	;YES
	MOVEI T4,NEDMAP	;DOES CURRENT UPTPOS DATA
	TDNN T4,%UPT+UPTSIM(W)	;NEED MAPPING IN?
	JRST INBLT1		;NO. DATA MUST ALREADY BE ADDRESSABLE
	PUSHJ P,SIMIOM		;YES, TRY TO GET IT
	JRST [CAME T1,[MAPID,,FALHOL]	;DID WE HIT A HOLE
		JRST SIMIOS		;NO,HANDLE OTHER ERRORS
		MOVEI T1,GOTHOL	;MAKE NOTE THAT CURR PG
		IORM T1,%UPT+UPTSIM(W);IS A HOLE,
		JRST INBLT7]	;AND GO PROCESS HOLE


INBLT1:
	LDB T3,UPYCVP
	SUBI T3,CNVVPN	;T3/EXEC VP# 340 - 370 ETC.
	LSH T3,9
	ADDI T3,(J)	;T3/EXEC ADDR OF BLK IN ASSIGNED PG
	HRL J,T3	;J/EXEC ADDR OF BLK,,WORD NO IN PG
	HRLZS T3
	HRR T3,0(P)	;T3/DATA WORD ADDR,,USERADDR
	HRRZ T4,0(P)
	ADDI T4,-1(P1)	;T4/END OF BLT=USERADDR+COUNT-1
INBLT2:	;NOW TOUCH FILE PAGE FOR FIRST TIME. XFER WORDS TO
	;USER SPACE. MAY CAUSE PG FLT TO GET DATA PAGE IN.
	;P1/COUNT	T3/BLT PTR	T4/ENDING USER ADDR

	JSP T1,.+1	;SAVE FLAGS
	JRSTF @[XWD PC.UIO,.+1]	;SET UIO. ENFORCE USER MAP
	XCTTU <BLT T3,(T4)>	;PROBABLE PG FAULT
	HRRI T1,.+2	;FIX RH OF T1,
	JRSTF @T1	;RESTORE FLAGS
	PUSHJ P,ERRINF	;SKIP IF NO ERR
	JRST INBLTE	;S/BITS SETUP. SET DEVIOS,EXIT

INBLT3:	;IF COUNT MOD 200 .NE. 0, SET BLOCK COUNT TO
	;NEXT HIGHER INTEGRAL MULTIPLE OF 200.

	MOVE T2,P1	;COUNT
	IDIVI T2,200	;T3/REMDR
	SKIPE T3
	ADDI T2,1
	HRRZ T4,T2	;T4/ACTUAL CHARGE COUNT & COUNT TO
			;ADVANCE UPTPOS
INBLT4:	;ADVANCE UPTPOS BY BLK CNT IN T4,UPDATE UNIT
	;READ COUNTS, CHARGE USER FOR HIS I/O
	PUSH P,T4	;INTEGRAL BLOCK COUNT 
	PUSHJ P,SIMADV	;ADVANCE UPTPOS,WATCH FOR PG BOUNDARY
	TDZA T3,T3	;DIDNT CROSS
	MOVEI T3,1	;CROSSED IT
	PUSH P,T3
	MOVE T1,-1(P)	;BLOCK COUNT
	MOVE J,JOB
	ADDM T1,JBTRCT	;UPDATE SYSTEM TOTAL
	ADDM T1,JBTRCT(J)	;AND THIS GUY'S
	LDB T2,UPYCVP	;T2/ASSIGNED VP# THIS CHAN
	VDSKPT T2,	;GET T2/RETR. PTR THIS PG
	SKIPA		;FAILURE (WHY?) DONT UPDATE
	PUSHJ P,SMSTAT	;UNIT COUNTS: EXPECTS S,T1,T2; CLOB T3,U
	PUSHJ	P,GTCGSZ	;GET T1/ CHARGING SIZE.
	POP P,T3	;FLAG 1 CROSSED PG BDRY, 0 DIDNT CROSS
	POP P,T2	;BLOCKS
	IMUL T1,T2
	ADDM T1,JBTSIN	;SYSTEM TOTAL
	ADDM T1,JBTSIN(J); AND HIS
	MOVN T2,P1
	HRL P1,T2	;P1/-COUNT,,COUNT
	ADDB P1,0(P)	;UPDATE 0(P)/USERWC,,USERADDR
	HLRES P1
	JUMPG P1,INBLT0	;WHILE WC>0, XFER DATA. MAY NEED TO MAP
			;NEX FILE PG. SIMADV NOTICED THAT.

	;WC WENT TO ZERO. IF IOSUPR, REMOVE PG & EXIT. IF
	;CROSS FILE PG BOUNDARY, NEDRMV IS SET=1 SO REMOVE IT,
	;MAP NEXT PG IN, PREREFERENCE IT & RETURN SUCCESS

	TLNN S,IOSUPR	;IF IOSUPR, REMOVE UNCONDITIONALLY
			;THIS KEEPS US FROM HOLDING ONTO A PAGE
			;MAPPED RDO IN CASE HE DOES OUTPUT NEXT.
			;(DSKCLN SHOULDNT SUFFER HERE BECAUSE
			;IT DOES ALL FULL-PAGE I/O, SO WE'RE
			;GOING TO THROW AWAY PG ANYWAY).
	JUMPE T3,INBLT5	;PAGE DIDNT CHANGE
	PUSHJ P,SIMRMV		;VREMOV CURRENT,RESET GOTHOL ETC
	TLNE S,IOSUPR
	JRST INBLT5
	PUSHJ P,SIMIOM		;MAP CURRENT UPTPOS
	JRST INBLT5	;ERROR, HANDLE NEXT TIME
	LDB T1,UPYCVP	;T1/ASSIGNED PG NO.
	PREREF T1,
	STOPCD ;(NEVER SPOSED TO HAPPEN)
;GENERAL EXIT
INBLT5:	POP P,T4	;UNWIND STACK
	POP P,P1	;RESTORE AC
	MOVE J,JOB	;MAKE SURE FOR ALL EXITERS
	POPJ P,

INBLT7:	;PROCESS REQUEST TO READ FROM A HOLE. BLT ZEROS IN
	;USER SPACE. NO REFERENCE TO PER-PROCESS PAGE. AS LONG
	;AS GOTHOL IS ON, DO THIS. NOTE THAT SIMRMV CLEARS
	;GOTHOL, AND SIMADV FORCES SIMRMV TO BE CALLED WHEN
	;IT DETECTS A PG BOUNDARY WAS CROSSED.
	;P1/COUNT	0(P)/USERWC,,USERADDR

	HRR T3,0(P)	;T3/USERADDR
	JSP T1,.+1	;SAVE FLAGS
	JRSTF @[XWD PC.UIO,.+1]
	XCTBU <SETZM (T3)>	;POSSIBLE PG FLT HERE
	HRLS T3
	HRRI T3,1(T3)	;T3/USERADDR,,USERADDR+1
	HRRZ T4,0(P)
	ADDI T4,-1(P1)	;T4/END OF BLT
	CAIL T4,(T3)	;SKIP IF BLT NOT NEEDED. 1 SETZM TOOK CARE OF IT.
	XCTBU <BLT T3,(T4)>	;BLT ZEROS "INPUT FROM 
	HRRI T1,INBLT3	;A HOLE" IN USER SPACE. NO REF TO EXEC
	JRSTF @T1	;ADDRESS. RESET FLAGS AFTER FIXING T1 RH
			;RETURN INLINE TO INBLT3

INBLTE: ;DISK PAGE SHOWED UP W/ERROR AFTER
	;TOUCHED IT FOR 1ST TIME. EXIT WITH STK FIXED AND 
	;DEVIOS SET
	;IF SUPERIO, REMOVE PAGE IN CASE HE DOES OUTPUT
	;NEXT.  (KEEPS US FROM HOLDING ONTO A PAGE MAPPED RDO)
	MOVEM S,DEVIOS(F)
	TLNE S,IOSUPR
	PUSHJ P,SIMRMV	;UPYCVP MUST EXIST OR STOPCD
	JRST INBLT5
COMMENT ! ERROR EXIT SIMIOS,FOR INBLT,OUTBLT
FUNCTION: TRANSLATE VUUO ERROR CODES INTO DEVIOS ERROR BITS.
	RETURN (FAILURE..SINCE ERROR BITS ARE ON)
CALL: MOVE T1,[UUOID,,UUO-ERROR-CODE]
	PJRST SIMIOS
	RETURNS POPJ TO CALLER'S CALLER
UPDATES: S,DEVIOS, SETS J_JOB TO RESTORE FROM INBLT,OUTBLT
EXPECTS: S,F,T1, ALSO EXPECTS T4,P1 IN PDL
DESTROYS: T1
CALLERS: INBLT, OUTBLT
(AS LONG AS THIS CODE ONLY HANDLES FCREATE & MAP
ERRORS, NO NEED TO VREMOV THE PAGE BEFORE EXITING, BECAUSE
NO PAGE WAS MAPPED IF MAP FAILED, AND MAP NOT DONE IF
FCREATE FAILED.)
!

SIMIOS:
	POP P,T4	;GET <USERWC>,,<USERADDR> BACK (MODIFIED)
	POP P,P1	;RESTORE AC USED FOR WORDCOUNT
	MOVE J,JOB
	PUSH P,T1
	HLRZS T1
	CAILE T1,%%TL
	STOPCD	;BAD UUOID
	XCT %%SIMT-MAPID(T1)

%%SIMT:! JRST MAP.E
	 JRST FCR.E
	 STOPCD		;VREMOV
	 STOPCD		;PREREF
	 STOPCD		;PAGSTS
%%TL==.-%%SIMT

MAP.E:
FCR.E:
	POP P,T1
	HRRZS T1
	CAILE T1,%%ERTL
	STOPCD
	XCT %%UUET(T1)
	MOVEM S,DEVIOS(F)
	POPJ P,


	SALL
%%UUET: STOPCD		;FALCTG - CONTIG FIELD 0
	STOPCD		;FALDVR - VM PG OUT OF RANGE
	STOPCD		;FALCPU - CUR PROT UNDEF
	STOPCD		;FALVEX - VM PG EXISTS WHICH SHOULDNT
	STOPCD		;FALNEX - VM PG DOESNT EXIST WHICH SHOULD
	STOPCD		;FALSVR - VREPLIC. VP OUT OF RANGE
	TDO S,[IOEND,,IODEND]	;FALPHP - PAST EOF, END OF UNIT/STR
	TRO S,IOIMPM	;FALFPZ - PAGE <0 OR 0
	STOPCD		;FALCOR - PVYCOR LIMIT EXCEEDED
	TRO S,IODTER	;FALRBE - RIB ERR
	TRO S,IODTER	;FALBDS - BAD SAT
	TRO S,IOIMPM	;FALCPL - CUR PROT ILLEGAL
		;SHOULD NEVER GET THIS UNLESS SOMEBODY WITH READ-
		;ABSOLUTE DOES SUPER-USETI THEN OUTPUT, WHICH
		;WILL SNEAK BY ALL CHECKS IN SIMDMP,SIMBOU, BUT
		;FILSER WILL COUGH BECAUSE IT CHECKS WRITE-ABSOLUTE
		;BEFORE DOING SMAP WITH PROT=RDW.
	TRO S,IOIMPM	;FALLKO - TRYING TO MAP LOOKUP-ONLY FILE
	STOPCD		;FALHOL - PAGE IS A HOLE (CATCH THIS IN SIMIOM)
	STOPCD		;FALNHL - FCREATE: NOT A HOLE
	TRO S,IOIMPM	;FALSNM - SUPER MAP NAME BAD
	TRO S,IODTER	;FALOPE - IO ERR ON VALIDATION OF PG VREMOV)
	STOPCD		;FALSAM - SAME PG NOS. (REPLIC,FEXCH)
	STOPCD		;FALSUP - MAP BUT IOSUPR ON. SHOULDNT HAPPEN
	TRO S,IOIMPM	;FALNOF - NO FILE
	TRO S,IOIMPM	;FALNWT - NO WRITE (ENTERED BUT APPEND ONLY,
			;OR NOT ENTERED: NOTE--UNDER PRE-VM SYS,
			;NOT ENTERED,IOIMPM; APP ONLY,IOBKTL
	TRO S,IOBKTL	;FALAQA - DISK FULL/QUOTA EXCEEDED
	STOPCD		;FALCTL - ^C. NOT SPOSED TO GET THIS ERROR
%%ERTL==.-%%UUET
	XALL


COMMENT ! ROUTINE ERRINF
FUNCTION: FOR INBLT,OUTBLT, TO SET IODERR/IODTER IN S IF
	PERSTS UUO INDICATES THAT THE PAGE JUST TOUCHED
	HAD EITHER OF THESE ERRORS.
DESTROYS: T1
RETURNS: SKIPPING IF NO BITS SET
	NOSKIP IF S/ IODTER,IODERR WERE SET


ERRINF:
	AOS (P)
	PUSH P,T2
	MOVE T1,[-2,,T1]	;GET 2 WDS DATA INTO T1,T2
	PERSTS T1,		;T2 ONLY ONE OF INTEREST
	STOPCD			;NO PERMISSABLE ERROR RTNS
	JUMPL T2,[SOS -1(P)	;NOSKIP RTN
		TLNE T2,EI.DER	;PAGE GOT DEVICE ERROR?
		TRO S,IODERR
		TLNE T2,EI.DTE	;DATA ERR
		TRO S,IODTER
		JRST .+1]
	POP P,T2
	POPJ P,
!
COMMENT ! ROUTINE ERRINF, VERSION 2
FUNCTION: FOR INBLT,OUTBLT, SET IODERR/IODTER IN S IF
	LMYERR IS ON IN LMAP SLOT FOR THE PAGE
	FOR THE CURRENT CHANNEL.
EXPECTS: W/CHANNEL
DESTROYS: T1
RETURNS: SKIPPING IF NO BITS SET IN S
	NON-SKIP IF S/IODTER,IODERR WERE SET

ERRINF:
	PUSH P,W
	LDB W,UPYCVP	;W/VP # THIS CHANN
	CAIGE W,1000		;PER PROCESS PG?
	STOPCD
	LDB T1,LMYERR		;T1/LMAP ERROR BITS THIS PG
	POP P,W
	JUMPE T1,CPOPJ1		;SKIP, NO ERROR
	TRNE T1,LMPDTE
	TRO S,IODTER
	TRNE T1,LMPDER
	TRO S,IODERR
	POPJ P,
;BIT DEFN'S IN LMYERR FIELD:
LMPDTE==1
LMPDER==2
!

COMMENT ! ERRINF, VERSION 3
FUNCTION: FOR INBLT,OUBLT; SET IODERR/IODTER IN S
	IF VPGSTS UUO SHOWS ERRORS FOR THE PAGE
NOTE:	VPGSTS LOOKS IN OHT, WHICH MAY RECORD OUTPUT ERRORS
	CAUSED BY OTHER SHARERS OF THIS PAGE
	OR BY SWAP OUT FAILURE. OR PARITY PROBLEMS.
	THESE ARE REPORTED TO HIM NOW ALSO AS IF HE HAD CAUSED THEM.

EXPECTS: S/DEVIOS(F)	W/CHANNEL
DESTROY: T1
CALL:	PUSHJ P,ERRINF
 ERROR, S/IODERR,IODTER SET AS NEEDED
OK, NO BITS SET IN S BY THIS CALL
!


ERRINF:
	LDB T1,UPYCVP
	VPGSTS T1,
	STOPCD
	TLNE T1,PS.DTE
	TRO S,IODTER
	TLNE T1,PS.DER
	TRO S,IODERR
	TLNE T1,PS.DTE!PS.DER
	POPJ P,			;THIS CALL CAUSED SOME BIT TO SET
	JRST CPOPJ1		;NONE SET THIS CALL
COMMENT ! ROUTINE SIMBIN -- BUFFERED MODE INPUT
FUNCTION: DSK CLASS BUFFERED INPUT SIMULATION ROUTINE.  FOR
	THAT PORTION OF USER BUFFER RING AT AND AHEAD OF
	DEVIAD(F), WHOSE USE BITS ARE 0,
	TRANSFER DATA FROM DISK PAGE(S) TO BUFFERS, SETTING
	USE BITS AND ADVANCING DEVIAD. RETURN WHEN BUFFER
	ENCOUNTERED WHOSE USEBIT=1.
CALL:	XCT CLIBUF(DEYCLS)	CAUSES PUSHJ P,SIMBIN
	RETURN HERE ALWAYS
CALLERS:
EXPECTS: F,S,W,U/ RING HEADER; DEVIAD(F)/BUFFER TO WRITE ON
PRESERVES: F,W,U,RING HEADER: DOES NOT TOUCH RING HEADER
UPDATES: S,DEVIOS; DEVIAD; BUFFER STATUS & WORDCOUNT WORDS
!

SIMBIN::
	TLNN F,ENTRB!LOOKB	;GOTTA HAVE ONE OF THESE,
	TLNE S,IOSUPR		;OR THIS, ELSE
	SKIPA
	TRO S,IOIMPM		;BOMB HIM
	HRRZ T2,DEVIAD(F)	;NEXT BUFFER TO WRITE ON
	TLNE S,IOEND		;ALREADY HIT END?
	TRO S,IODEND		;YES,SIGNAL USER
SIMBI1:	TDNN S,[IOEND,,IOIMPM!IODTER!IODERR!IODEND!IOBKTL]
	XCTBU <SKIPGE (T2)>	;USE BIT ON(BUFF FULL)? SKIP NO
	JRST SIMBIX
	NOCHARGE		;NO MICROCYCLE CHARGE UNTIL USRXIT
	HRRZI T4,2(T2)		;<USERADDR> DATA BEGINNING LOCN
	HRLI T4,200		;DSK BUFFERS DATA ALWAYS 200 WDS
	HRRZ T1,DEVSER(F)
	PUSHJ P,DDI(T1)	;XFER 1 BLOCK DATA TO USER
		;PASS T4/<USERWC>,,<USERADDR>
	MOVEI T4,200		;BUFFER WC IS 200,PROBABLY
	HRRZ T1,DEVIAD(F)
	TLNE S,IOSUPR		;(FOR SURE 200 IF SUPER IO)
	JRST SIMBI2		;SKIP THE ABT STUFF
	HRRZ T2,DEVATB(F)
	LDB T3,ATYBSZ		;TRUE FILE SIZE IN BLOCKS
	ADDI T3,1		;ADJUST TO ACCOUNT FOR THE FACT
				;THAT UPTPOS ALREADY ADVANCED TO
				;NEXT BLOCK BY INBLT
				;T4/BUFFER WORDCOUNT IS 200
	CAMLE T3,%UPT+UPTPOS(W)	;UNLESS AT OR PAST LAST BLK
	JRST SIMBI2		;IN FILE. IF PAST, QUIT NOW
	TLO S,IOEND		;WITHOUT TOUCHING BUFF WC OR
	CAME T3,%UPT+UPTPOS(W)	;STATUS. IF AT LAST BLOCK,
	JRST SIMBIX		;(PAST LAST BLOCK)
	LDB T4,ATYWSZ		;STORE PARTIAL WORDCOUNT OF LAST BLK
	SKIPN T4		;WHICH IS <200 IF PARTIAL,
	MOVEI T4,200		;OR 200 IF FULL
SIMBI2:	;T4/BUFF WC   T1/DEVIAD   S/CURR STATUS
	UMOVEM T4,1(T1)	;INSTALL WORDCOUNT IN BUFF
	UMOVEM S,-1(T1)		;INSTALL BUFFER STATUS
	MOVSI T2,IOUSE
	XCTBU <IORB T2,(T1)>	;MARK BUFFER FULL & GET NEXT
	HRRM T2,DEVIAD(F)	;DEVIAD IS NOW ADVANCED LIKE
				;ADVBFF WOULD DO.
	TRNN S,IOCON	;SKIP IF SYNC MODE, 1 BUFF AT A TIME
	JRST SIMBI1	;CONTINUE UNLESS ERRORS OR HIT FULL BUFF
			;(MEANS WE FINISHED THE RING)
SIMBIX:	MOVEM S,DEVIOS(F)
	POPJ P,
COMMENT ! ROUTINE SIMBOU - SIMULATED BUFFERED DSK OUTPUT
FUNCTION: DSK CLASS DEVICE DEPENDENT ROUTINE. MOVES DATA
	TO FILE PAGE(S) FROM USER BUFFER RING BEGINNING
	AT CURRENT (DEVOAD), QUITTING WHEN IT ENCOUNTERS
	A BUFFER THAT'S EMPTY (USE BIT OFF).
	THIS ROUTINE CAN BE CALLED BY USETO AND CLOSE CODE.
	ON EXIT, DEVOAD IS FULLY ADVANCED.
	APPROPRIATE DEVIOS BITS TURNED ON HERE IF ERRORS.
CALL:	MOVE AC,DSK DEVICE CLASS (DEYCLS)
	XCT CLOBUF(AC)	;CAUSES PUSHJ P,SIMBOU
	RETURN HERE ALWAYS
EXPECTS: F,S,W,U/RING HEADER--NOT TOUCHED; DEVOAD/BUFFER TO EMPTY
DESTROYS: T1-T4,PG
UPDATES:DEVIOS,DEVOAD,ATBSIZ,USER BUFFER STATUS WORDS
RESTRICTIONS:
!

SIMBOU::
	TLNN F,ENTRB
	TLNE S,IOSUPR
	SKIPA
	JRST SIMBO3	;GOTTA HAVE IOSUPR OR ENTRB
	TRNE S,IOIMPM!IODTER!IODERR!IOBKTL ;ERROR ALREADY ?
	JRST SIMBO4	;YES,EXIT ADVANCING 1 BUFFER
	TLZ S,IOEND	;RESET FLAG MAY HAVE BEEN SET BY USETO
	NOCHARGE ;NO MICROCYCLES UNTIL USRXIT
	HRRZ T2,DEVOAD(F)
SIMBO1:
	XCTBU <SKIPL (T2)>	;BUFFER THATS EMPTY (USEBIT=0)?
	JRST SIMBOX
	XCTFU <HRRZ T4,1(T2)>	;T4/USER WC
	SKIPLE T4		;ASSUME 200 IF CRUMMY WC
	CAILE T4,200		;IE, NOT 1.LE.WC.LE.200
	MOVEI T4,200
	PUSH P,T4		;WORDCOUNT
	HRLZS T4
	HRRI T4,2(T2)		;USER DATA ADDR STARTS AFTER WC WORD
	HRRZ T1,DEVSER(F)
	TLNE S,IOSUPR		;IF SUPER IO, NO NEED TO FUSS
	JRST [	PUSHJ P,DDO(T1)	;WITH ATB STUFF. PASS T4/WC,,ADDR
		POP P,T1	;GET WC BACK OUT,DONT NEED
		JRST SIMBO2]	;AND GO FIX USER BUFF HDR
	PUSHJ P,DDO(T1)		;CALL DSK DMP SERVICE ROUTINE
				;PASS T4/USERWC,,USERADDR
	HRRZ T2,DEVATB(F)
	LDB T3,ATYBSZ		;INTEGRAL NO. BLKS IN FILE
	MOVE T4,%UPT+UPTPOS(W)	;CURRENT POSITION (ALREADY ADVANCED)
	SUBI T4,1
	POP P,T1		;WC, MAY BE <200
	PAGE (T3)		;T3/ACTUAL PAGES NOW IN FILE
	PAGE (T4)		;T4/PG IN WHICH WE JUST WROTE
	CAME T3,T4		;IF NOT THE SAME, WE WROTE IN HOLE,
	JRST SIMBO2		;OR SOMEBODY SNUK IN, TRUNCATED/
				;EXTENDED FILE. LEAVE ABTSIZ ALONE.
	MOVE T4,%UPT+UPTPOS(W)	;T4/OUR BLK POSN(ADVANCED).
	SUBI T4,1		;T4/OUR BLK NO, .GE. 1
	LSH T4,7		;CONVERT T4 TO ATBSIZ FORMAT:
	ANDI T1,177		;(INTEGRAL BLKS)LSH 7+
	ADDB T4,T1		;WORDS MOD 200
	TRNN T1,177		;COPY IN T1: ROUND UP WHOLE BLOCK
	ADDI T1,200		;IF WHOLE BLOCK WRITTEN. T1/200+
				;OUR WORDS IN FILE
	MOVE T3,ATBSIZ(T2)	;ATBSIZ: ROUND UP WHOLE BLOCK IF
	TRNN T3,177		;WHOLE BLK WRITTEN (NO PARTIAL WRDS)
	ADDI T3,200		;T3/200+WORDS IN FILE
	CAMLE T1,T3		;IF OUR WORDS+200>FILE WORDS+200,
	MOVEM T4,ATBSIZ(T2)	;UPDATE
SIMBO2:
	HRRZ T1,DEVOAD(F)
	UMOVEM S,-1(T1)		;STORE STATUS IN USER BUFF HDR
	MOVSI T2,IOUSE
	XCTBU <ANDCAB T2,(T1)>	;RESET USE BIT IN CURRENT BUFF,
	HRRM T2,DEVOAD(F)	;AND GET NEXT BUFF ADDR, TO DDB
	TRNE S,IOCON!IOIMPM!IODTER!IODERR!IOBKTL ;DID WE GET ANY ERROR?
	JRST SIMBOX	;YES, EXIT WITHOUT ADVANCING FURTHER
			;IS IOCON SET? YES EXIT NOW HAVING
			;ADVANCED ONE BUFFER
	JRST SIMBO1	;NO ERRORS, T2/NEXT BUFFER IN RING.
SIMBO3:	;ERROR BEFORE BEGAN PROCESSING, NEED TO SET IOIMPM
	TRO S,IOIMPM
SIMBO4:	;ERROR BEFORE BEGAN PROCESSING--ADVANCE 1 BUFF,EXIT
	HRRZ T1,DEVOAD(F)
	MOVSI T2,IOUSE
	XCTBU <ANDCAB T2,(T1)> ;RESET CURRENT BUFFER USE BIT,
	HRRM T2,DEVOAD(F)	 ;AND GET T2/NEXT BUFF ADDR TO DDB
SIMBOX:	MOVEM S,DEVIOS(F)
	POPJ P,
COMMENT ! ROUTINE SIMDMP -- SIMIO DUMP MODE INPUT & OUTPUT
FUNCTTION: PICK UP USER IOWD'S, TRANSLATE THEM INTO INBLT/OUTBLT
	ARG [+<USERWC>,,<USERADDR>], & CALL APPROPRIATE
	SERVICE ROUTINE; CONTINUE UNTIL ERROR BIT OR END OF
	USER DMP MODE COMMAND LIST.
CALL:	MOVEI M,ADDRESS OF USER IO COMMAND LIST
	MOVEI AC,DSK DEVICE CLASS
	XCT CLODMP(AC) OR XCT CLIDMP(AC) CAUSES PUSHJ P,SIMDMP
	ALWAYS RETURN HERE. S,DEVIOS UPDATED W/ERROR BITS IF NEEDED
EXPECTS: S,J,F,W, M/ USER CMD LIST ADDR
DESTROYS: T1-T4
RESTRICTIONS:
UPDATES: DEVIOS
!

SIMDMP::
	MOVSI T2,ENTRB	;IF OUTPUT, GOTTA HAVE THIS OR SUPERIO;
	TLNN S,IO	;ELSE IF INPUT, CAN HAVE EITHER OF THESE
	TLO T2,LOOKB	;OR SUPER. BUT IN ANY CASE, 
	TDNN F,T2	;GOTTA HAVE ONE OF THESE
	TLNE S,IOSUPR		;OR THIS, ELSE
	SKIPA
	TRO S,IOIMPM		;BOMB HIM
	NOCHARGE	;NO MICROCYCLES UNTIL USRXIT
	TLNE S,IO
	JRST SIMD0
	TLNE S,IOEND	;INPUT. ALREADY HIT END?
	TRO S,IODEND	;YES,SIGNAL USER
SIMD0:	MOVNI T3,3	;THIS IS A "GOTO" COUNT
SIMD1:	MOVEI T2,IODTER!IODERR!IOIMPM!IOBKTL	;OUTPUT. ONLY TEST ERROR BITS
	TLNN S,IO	;(SKIP IF OUTPUT)
	TRO T2,IODEND	;INPUT. TEST IODEND ALSO
	XCTFU <SKIPE T1,(M)>	;T1/USER IOWD. EXIT IF END CMD LIST,
	TRNE S,(T2)	;OUTPUT: TEST ERRORS; INPUT TEST EOF TOO.
	JRST SIMDX	;UPDATE DEVIOS.
	TLNE T1,-1	;A "GOTO" WORD?
	JRST SIMD2	;NO
	AOJGE T3,ADRERR	;TOO MANY GOTO WORDS
	HRR M,T1	;DO THE "GOTO"
	JRST SIMD1

SIMD2:	;T1/-USERWC,,USERADDR-1
	HLRE T4,T1	;T4/-USERWC
	MOVNS T4
	JUMPLE T4,[TRO S,IOBKTL
		JRST SIMDX]
	PUSH P,M
	PUSH P,T4		;+USERWC
	HRLS T4
	HRRI T4,1(T1)		;T4/+USERWC,,USERADDR
	HRRZ T1,DEVSER(F)
	MOVEI T3,DDI(T1)	;WHICH WAY ARE WE GOING, IN OR OUT?
	TLNE S,IO
	MOVEI T3,DDO(T1)	;OUT
	TLNE S,IOSUPR		;IF DOING SUPER IO, NO NEED
	JRST [	PUSHJ P,(T3)	;TO FUSS W/ATB STUFF. CALL IN/OUT
		POP P,T4	;ROUTINE, PASS T4. RETURN,
		POP P,M		;POP USERWC,USER LIST ADDR
		AOJA M,SIMD0]	; ADVANCE,DO NEXT IOWD
	PUSHJ P,(T3)		;DO THE IN/OUT ROUTINE. T4/WC,,ADDR
	HRRZ T2,DEVATB(F)	;FOR ALL REFS TO ATYBSZ,ATBSIZ
	POP P,T4		;T4/USERWC
	POP P,M			;USER LIST ADDR
	LDB T1,ATYBSZ		;T1/ACTUAL BLOCKS IN FILE NOW
	MOVE T3,%UPT+UPTPOS(W)	;IN/OUT POSN (ADVANCED)
	SUBI T3,1		;ADJUST FOR ALREADY ADVANCED
	TLNN S,IO		;SKIP IF OUTPUT
	JRST SIMD3		;DOING INPUT
	;DOING OUTPUT. SEE IF ATBSIZ NEEDS UPDATE
	TLZ S,IOEND		;RESET FLAG MAY HAVE BEEN SET BY USETO
	PAGE (T1)		;T1/REAL PAGES IN FILE
	PAGE (T3)		;T3/PG IN WHICH WE JUST WROTE
	CAME T1,T3		;IF DIFFERENT, WE WROTE IN HOLE,
		;OR SOMEONE SNUCK IN, EXTENDED/TRUNCATED FILE
		;SINCE WE MAPPED THIS PG, SO DONT
		;TOUCH ATBSIZ.
	AOJA M,SIMD0		;JUST GO FOR NEXT USER IOWD
	;WE ARE IN SAME PAGE
	MOVE T3,%UPT+UPTPOS(W)	;CONVERT OUR UPTPOS/USERWC TO
	SUBI T3,1		;ATBSIZ FORMAT: (INTEGRAL BLKS)LSH 7
	LSH T3,7		;+WORDS MOD 200
	ANDI T4,177
	ADDB T3,T4		;COPY IN T4 ROUND UP WHOLE BLOCK
	TRNN T4,177		;IF WHOLE BLK WRITTEN (NO PARTIAL
	ADDI T4,200		;WC) FOR CAMLE BELOW
	MOVE T1,ATBSIZ(T2)	;ATBSIZ: ROUND UP BY A WHOLE BLOCK
	TRNN T1,177		;IF WHOLE BLK (NO PARTIAL WC)
	ADDI T1,200		;FOR CAMLE. T1/200+FILE WORDS
				;T4/200+OUR WORDS
	CAMLE T4,T1		;IF WE ARE PAST ATBSIZ,
	MOVEM T3,ATBSIZ(T2)	;UPDATE.
	AOJA M,SIMD0		;GO GET NEXT USER IOWD


SIMD3:	;HERE ON INPUT AFTER INBLT
	CAML T1,T3		;SKIP IF AFTER EOF
	AOJA M,SIMD0		;NOT,LEAVE S,DEVIOS ALONE
	TDO S,[IOEND,,IODEND]	;SET BOTH BITS NOW & QUIT

SIMDX:	MOVEM S,DEVIOS(F)
	POPJ P,
	SUBTTL	USETI/USETO


COMMENT #
@@SUBROUTINE USETI0
@@PURPOSE
USETI ROUTINE.
@@ENTRY
EXPECTS F/ DDB, S/ DEVIOS, AND M/ LOG. NO. OF DESIRED BLOCK.
@@ACCUM
DESTROYS P1-P3, T1-T4, AND ?
@@EXIT
@@ #

USETI0::	NOCHARGE
	TLNE	S,IOSUPR	;SUPER USETI DONE ALREADY?
	JRST	SPRCON		;YES. GET NEW BLOCK NUMBER.
	TLNN	F,LOOKB!ENTRB	;NO. LOOKUP DONE?
	JRST	SPRBGN		;NO. SUPER USETI IF PRIVILEGED.

	JUMPE	M,ERRFUL	;
	TLNE	S,IOBDRB	;IS THIS FILE DEAD?
	JRST	ERRBDR		;YES.
	TLZ	S,IO		;
	HRRZ	T2,DEVATB(F)	;LOC OF ACCESS TABLE.
	LDB	T1,ATYBSZ	;HIGHEST REL BLK WRITN IN FILE.
	JUMPN	T1,.+2		;NOT SURE THIS
	SETOM	DEVFLO(F)	;IS NECESSARY.
	JUMPL	M,USTIN2	;WANT TO BE SET UP AFTER EOF?
	CAMLE	M,T1		;NO.  REQ BLK PAST HIGHEST BLK?
	JRST	USTIN2		;YES.
	MOVEM	M,DEVPOS(F)	;
	JRST	USTIN4		;
USTIN2:	ADDI	T1,1		;
	MOVEM	T1,DEVPOS(F)	;
	TDOA	S,[XWD IOEND,IODEND]
USTIN4:	TDZ	S,[XWD IOEND,IODEND]
	MOVSI	T1,400000	;FLAG TO SIMIOB
	IORM	T1,DEVPOS(F)	;THAT SOMETHING'S HAPPENED.
	PJRST	STOIOS		;STORE S AND RETURN.
COMMENT #
@@SUBROUTINE USETO0
@@PURPOSE
USETO ROUTINE.
@@ENTRY
EXPECTS F/ DDB, S/ DEVIOS, AND M/ LOG. NO. OF DESIRED BLOCK.
@@ACCUM
DESTROYS
@@EXIT
@@ #

EXTERN FALRBE,FALAQA,SWEPHO,SETACH,ATYBSZ,ATYWSZ
EXTERN INLMES,PRNAME,STRDDB,STRNAM,TTYFUW,TTYSTR
EXTERN DEVATB,DEVFLO,DEVLOK,DEVPOS,DEVSUP,ERRBDR,ERRFUL,ERRIMP
EXTERN LOKMOD,RELRIB,RELSAT,STOIOS,TRHALT,SUPBEG,SUPBND,UNLFIL
EXTERN WSCHED,IOSUPR

USETO0:: NOCHARGE
	TLNE	S,IOSUPR	;SUPER USETI OR USETO DONE ALREADY?
	JRST 	[MOVE T1,DEVIAD(F) ;YES, GET NORED,NOWRT BITS
		TLNE T1,NOWRT	;SKIP IF LEGAL TO WRITE
		PJRST ERRIMP	;GIVE IOIMPM
		JRST SPRCON]	;GET NEW BLOCK NUMBER.
	TLNN	F,ENTRB		;NO. ENTER BEEN DONE?
	JRST	SPRBGN		;NO. (1ST) SUPER USETO IF LEGAL.

	JUMPLE	M,ERRFUL
USETO1:	MOVE	S,DEVIOS(F)	;
	TLNE	S,IOBDRB	;
	JRST	ERRBDR		;SET SOME FLAG AND EXIT.
	TLO	S,IO		;
	SKIPE	DEVLOK(F)	;
	STOPCD
	HRRZ	T2,DEVATB(F)	;LOC OF ACCESS TABLE.
USETO2:	LDB	T1,ATYBSZ	;HIGHEST REL BLK WRITN IN FILE.
	CAMLE	M,T1		;WANT ONE ABOVE HIGHEST?
	JRST	USETO4		;YES.
USOOUT:	MOVE	T1,M		;
	TLO	T1,400000	;
	MOVEM	T1,DEVPOS(F)	;SIGNAL SIMIOB THAT USETO DONE
	PUSHJ	P,UNLFIL	;MAYBE HAVE TO UNLOCK THE FILE.
	MOVEM	S,DEVIOS(F)
	POPJ 	P,

    ;HERE WHEN WANT BLOCK PAST EOF.
USETO4:	CAMLE	M,[XWD 2000,0]	;(2**35)/128.
	JRST	[PUSHJ P,UNLFIL
		PJRST ERRFUL]
	MOVE	T4,T1		;
	ADDI	T4,3		;REQ BLK IN LAST
	TRZ	T4,3		;PARTIAL PAGE OF
	ADDI	T4,1		;FILE, OR FIRST IN
	CAMLE	M,T4		;NEXT PAGE?
	JRST	USETO5		;NO.
USOOU4:	MOVE	T4,M		;YES, SET

;HERE WHEN THE USETO HAS EXTENDED BY AT LEAST A BLOCK AND PERHAPS ONE
;OR MORE PAGES. SET THE FILE SIZE, SET IOEND, AND GO TO
;SET DEVPOS AND FRIENDS. IOEND IS SET TO PREVENT ANY
;INPUTS FROM SUCCEEDING AFTER THIS USETO WHICH ARE NOT PRECEEDED
;BY AT LEAST ONE OUTPUT. SIMDMP AND SIMBOU RESET IOEND.

	SUBI	T4,1		;THE NEW
	DPB	T4,ATYBSZ	;FILE SIZE: BLOCKS,WORDS
	SETZ	T4,		;WORDS IN LAST BLK
	DPB	T4,ATYWSZ	;
	TLO	S,IOEND		;KEEP INPUT'S FROM SUCCEEDING,
	JRST	USOOUT		;& GO DO DEVPOS

    ;HERE WHEN EXTENDING FILE.
USETO5:	SKIPN	DEVLOK(F)	;SECOND TIME AROUND?
	PUSHJ	P,LOKMOD	;NO, NEED TO LOCK.
	MOVE	S,DEVIOS(F)	;
	TLNE	S,IOBDRB	;
	JRST	[PUSHJ P,UNLFIL ;SET SOME FLAG AND EXIT.
		JRST ERRBDR]
	LDB	T3,ATYBSZ	;DID THE FILE SIZE CHANGE WHILE
	CAME	T1,T3		;WE WERE WAITING FOR THE LOCK?
	JRST	USETO2		;YES.
	PUSH	P,M		;NO.
	PUSHJ	P,SETACH	;FLAG FILE'S ALLOCATION AS CHANGING
	ADDI	M,2		;SET UP THE ARGS
	LSH	M,-2		;FOR SWEEP--M/ OLD
	LSH	T4,-2		;HPW+1
	SUB	M,T4		;AND
	EXCH	M,T4		;T4/ # PAGES TO
	ADDI	M,1		;CREATE AS
	SETZ	T1,		;(STOP ON CNTRL C.).
	PUSHJ	P,SWEPHO	;HOLES.
	JRST	USEROR		;ERROR RETURN.
	POP	P,M		;SUCCESS RETURN.
	PUSHJ	P,RELSAT	;
	PUSHJ	P,RELRIB	;
	HRRZ	T2,DEVATB(F)	;
	JRST	USOOU4		;

    ;HERE ON ERROR RETURN FROM SWEEP.  (RIB ERROR, CAN'T
    ;ALLOCATE, OR CONTROL C WAITING.).
USEROR:	POP	P,M		;
	PUSH	P,T1		;SAVE ERROR CODE FROM SWEPHO
	PUSHJ	P,RELSAT	;
	PUSHJ	P,RELRIB	;
	PUSHJ	P,UNLFIL	;
	POP	P,T1		;GET CODE BAK.
	CAIN	T1,FALRBE	;WAS IT A RIB ERROR?
	PJRST	ERRBDR		;YES.
	HRRZ	T2,DEVATB(F)	;
	LDB	T2,ATYBSZ	;SET DEVPOS 1B0 TO ALERT
	TLO	T2,400000	;SIMIOB THAT SOME OF THE USETO
	MOVEM	T2,DEVPOS(F)	;GOT DONE
	CAIN	T1,FALAQA	;ALLOCATION FAILURE?
	JRST	[TRO S,IOBKTL	;SET AN ERROR FLAG,NO DISK
		POPJ P,]	;LEFT TO ALLOCATE. RETURN FROM USETO
	MOVE	J,JOB		;BETTER SETUP J BEFORE CALLING TRHALT.
	PUSHJ	P,TRHALT	; CONTROL C WAITING.
	PUSHJ	P,WSCHED	;
	JRST	USETO1		;
    ;HERE ON FIRST SUPER USETI/O.
EXTERN BLKSPP
SPRBGN:	TLNE	F,ENTRB+LOOKB
	JRST	ERRFUL		;LOSE IF EITHER SO FAR.
	PUSHJ	P,SUPBEG	;START UP-CHK PRIV AND NAME.
	PJRST	ERRIMP		;SOMETHING WRONG.
SPRCN2:	JUMPL	M,ERRFUL	;OKAY, BUT REQ PAG MUST BE >=0.
	PUSH	P,M		;
	LSH	M,-BLKSPP	;
	PUSHJ	P,SUPBND	;CHECK BOUNDS.
	JRST	[POP P,M	;OUT OF BOUNDS.  SET IOBKTL.
		JRST ERRFUL]	;
	POP	P,M		;
	JRST	USOOUT		;WIN.




    ;HERE ON CONTINUING SUPER IO. INPUT OR OUTPUT
SPRCON:	HRRZ	U,DEVSUP(F)	;GET U/ SPECIFIC UNIT OR 0(STR).
	JRST	SPRCN2		;



	END
    E@|n