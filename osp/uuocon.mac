TITLE	UUOCON - UUO HANDLER AND UUO ROUTINES

IFNDEF .ELINK,<
    IFDEF  .LNKEND,<SYN .LNKEND,.ELINK>
If2,<PRINTX .ELINK needs to be changed to .LNKEND for macro %53B>
>

UUOCON:	ENTRY UUOCON	;ALWAYS LOAD UUOCON(IF LIB SEARCH)

IFNDEF MAXCAL,<XP MAXCAL,56>
			;DEFINE HIGHEST CALLI UUO WHICH HAS
			; CORRESPONDING CALL M

COMMENT ! UUOCON
FUNCTION: PUBLIC NO-TRAP MUUO HANDLER AND CALL [SIXBIT /NAME/],
 CALLI AC,INDEX HANDLER. THE USER'S UPT MUUO NEW PC WORD
 CAUSES EXECUTION TO START HERE AT UUOPNT WHEN HE GIVES AN
 MUUO. IF MUUO IS EXECUTED AS A RESULT OF A TRAP CONDITION,
 THEN THE NEW PC WORD SELECTED POINTS AT UUOPTR.

RESTRICTION: UUOS CANNOT BE CALLED BY INTERRUPT SERVICE ROUTINES.
 THE UUO HANDLER IS PURE OTHERWISE (ALL STORAGE IN CONTEXT
 PAGES AND JBT TABLES, ETC.)
!
SUBTTL UUOPNT DISPATCH,CALLI'S & ETC.

INTERNAL USRXIT,UUOKNT,UUOPNT,UUOPN1,USRXT7
INTERNAL NINTRP,NOUTRP,NWATRP,NERTRP,NEFTRP,NSPTRP
EXTERNAL ERRCAL
EXTERNAL UPTSTS,STRTAD,STRTCL,ERRNSA,EPT,PGYNXM,CURUPT,%UPT,%UPS,EPYPSN
EXTERNAL UPTNTV,UPTABK
EXTERNAL UPSSWE,UPSABK,ERRABK
EXTERN JOBOPC,TTYRES,CHGPPN,EPLLEN
EXTERNAL JOBDDT
IFCPU (KI),<EXTERNAL TIMCHN>
EXTERNAL UPTPDL,UPTRNM,UPTRPN
EXTERNAL ERRPIO,UPTXEI
EXTERNAL TTYFNU,JBTWCH
EXTERN CORUUO,HOLD,ILLINS
EXTERN ERRIUC,JOBKL
EXTERN UGTSEG,URUN,USCHD1,UUOERR,LOGOFF
EXTERN WSYNC
EXTERNAL PUUOAC,UUOMNR
EXTERNAL JOB,JBTSTS,TIMEF,JBTUPM
EXTERNAL UPTACP,STKAC,KTRRET
EXTERN JOBOPC,UPNPSR,UPSPSR
EXTERNAL ADJMWS, AGEPAG
EXTERNAL CPOPJ1,CPOPJ,TPOPJ,TPOPJ1
EXTERNAL CBLAMB,DEVLST,DVCNSG,STDRNG,TTYFND,TTYUUO,UUOTAB
EXTERNAL CLKTRP
EXTERNAL WRTACR
	XP	PDNMUP,-2	;PDNMUP(P) IS WHERE UUO ROUTINES LOOK AT PC.

UUOPNT:	EXECAC		;SWITCH TO EXEC MODE ACS
	SKIPN	JOB
	STOPCD	.		;MUST BE UUO FROM NULL JOB.
	MOVE	M,%UPT+UPTMUU
UUOPN1:	MOVEI	F,0		;BECAUSE ERRCON LOOKS FOR ADDRESS CHECK ERROR
	MOVE	P,[IOWD EPLLEN,%UPT+UPTPDL] ;SETUP STACK POINTER
	PUSH	P,%UPT+UPTMUP	;PC OF UUO GOES ON FIRST.
	AOBJN	P,.+1		;SAVE ROOM FOR PHONEY CLOCK WORD
				; SO THAT MUP IS ALWAYS AT SAME PLACE.
	PUSHJ	P,UUODSP	;CALL THE DISPATCH ROUTINE
	  JRST	UUOPN3		;NON-SKIP RETURN
UUOPN2:	AOSA	PDNMUP+1(P)	;SKIP RETURN
	JRST	UUOPN4		;DOUBLE SKIP, A LITTLE SLOWER.
UUOPN3:	POP	P,T1		;GET JUNK OFF STACK
	JRST	USRXIT		;AND RETURN TO USER

UUOPN4:	AOS	PDNMUP+1(P)	;ONE MORE TIME FOR DOUBLE SKIP
	JRST	UUOPN2		;AND GO BACK.

UUOKNT:
IFCPU (KI),<MOVEM	17,@%UPT+UPTACP	;SAVE 17 FIRST
	JSP	17,STKAC	;PUSH THE REST ON THE AC STACK
>;END IFCPU (KI)
IFNCPU (KI),<
	MOVEM	16,@%UPT+UPTACP ;FOR KL, SAVE AC 16
	JSP	16,STKAC
>;END INCPU (KI)
	MOVE	M,%UPT+UPTMUU	;GET UUO INTO M FIRST IN CASE PDL OV
	PUSH	P,%UPT+UPTMUP	;PUT PC ONTO STACK
	MOVEI	F,0		;NO PDL OV, SO CLEAR F FOR ILL MEM REF/ADDRESS CHECK DISTINCTION
	CHGSTS	T1		;GET STATE OF CHARGING CLOCK
	PUSH	P,T1		;SAVE THAT ON STACK
	PUSHJ	P,UUODSP	;DO THE UUO
	  SKIPA			;NON-SKIP
	AOS	PDNMUP+1(P)	;SKIP
	POP	P,T1		;GET CLOCK STATE BACK
	TRNE	T1,CHGON	;IF CHARGING WAS ON,
	CHARGE			;THEN TURN IT BACK ON NOW.
	POP	P,%UPT+UPTMUP	;GET PC BACK INTO MUP
	JRST	KTRRET		;AND RETURN TO UUO CALLER.
COMMENT ; CONVENTIONS FOR UUO AND CALLI SUBROUTINES

UUO ROUTINES:

CALL: UUO ROUTINES ARE CALLED WITH PUSHJ TYPE CALL.

ENTRY: M CONTAINS THE UUO, W CONTAINS AC NUMBER (CHANNEL NUMBER),
PDNMUP(P) HAS PC OF UUO CALLER. J IS NOT SETUP. F SHOULD BE
SET TO ZERO.

ACCUM: UUO SUBROUTINES CAN USE ALL ACS EXCEPT P.

EXIT: POPJ RETURN FOR NON-SKIP RETURN TO UUO CALLER, CPOPJ1
TYPE RETURN FOR SKIP RETURN TO UUO CALLER, AND CPOPJ2 TYPE
RETURN FOR DOUBLE SKIP RETURN. IF STATE OF CHARGING CLOCK
WAS CHANGED, NO NEED TO RESTORE, UUO EXIT CODE RESTORES CLOCK
TO BE ON.

CALLI ROUTINES:

CALL: CALLI ROUTINES ARE CALLED WITH PUSHJ TYPE CALL.

ENTRY: T1 CONTAINS CONTENTS OF USER AC, W AND RH(M) CONTAIN
USER AC NUMBER (FOR STORING RETURN ARGS), J CONTAINS JOB NUMBER,
LH(W) HAS 1B0 SET IF THE CALLI IS PHYSICAL ONLY (THOSE CALLIS
IN WHICH 1B18 AND 1B19 ARE DIFFERENT ARE PHYSICAL ONLY).
IF CHARGING CLOCK STATE WAS CHANGED, NO NEED TO RESTORE IT,
UUO EXIT CODE WILL RESTORE.

ACCUM: CAN SMASH ALL ACS EXCEPT P

EXIT: POPJ FOR NON-SKIP, CPOPJ1 FOR SKIP, CPOPJ2 FOR DOUBLE
SKIP. STATE OF CHARGING CLOCK NEED NOT BE RESTORED IF IT
WAS CHANGED.
;

UUODSP:	LDB	W,PUUOAC	;GET USER'S CHANNEL/AC NUMBER
	TLNE	M,777000	;OPCODE OF 0 OR OPCODES GREATER THAN
	TLNE	M,700000	; 077 ARE ILLEGAL INSTRUCTIONS
	JRST	INSSIM		;missing INStruction SIMulator
	HLLZ	T2,M		;GET LH OF UUO INTO LH OF T2
	ROT	T2,^D8		;SHIFT ALL BUT LO ORDER BIT INTO RH OF T2
	SKIPGE	T2		;IF UUO IS ODD,
	SKIPA	U,UUOTAB-20(T2)	;DISPATCH FROM RH ELSE
	MOVS	U,UUOTAB-20(T2)	; DISPATCH FROM LH
	JRST	(U)		;RETURN ADDRESS IS ON PDL.

; below lies the famous missing INStruction SIMulator
ifndef SIMINS,<
  ifcpu (F3),< SIMINS==1 >		;1=simulate, 0=don't simulate
  ifncpu (F3),< SIMINS==0 >		;1=simulate, 0=don't simulate
> ;end ifndef SIMINS
ife SIMINS,<
	INSSIM=ILLINS
> ;end ife SIMINS
ifn SIMINS,<
INSSIM:	HLRZ	T2,M
	TRZ	T2,777
	CAIN	T2,(FIXR)
	 JRST	U.FIXR
	CAIN	T2,(FLTR)
	 JRST	U.FLTR
	JRST 	ILLINS
	
U.FIXR:
	UMOVE	T1,(M)		;get contents of eff addr
	HRLZI	T2,(0.5)	;Assume argument is positive
	JUMPGE	T2,.+2		;Still assuming...
	MOVE	T2,[600000,,1]	;If negative, use -.49999999...
	FADR	T1,T2		;Round up or down, sign depending
	FIX	T1,T1		;Strip off fractional part
	UMOVEM	T1,(W)		;put into users AC
	POPJ	P,		;return

U.FLTR: UMOVE	T1,(M)		;get contents of eff addr
	CAMN	T1,[xwd 400000,0]	;special case
	 JRST	[HRLZI	T2,533400
		 JRST	GOODGO]
	MOVM	T2,T1		;get absolute value
	TLNN	T2,777000	;will a FSC work?
	 JRST	[FSC	T2,233	;yup
		 JRST	SIGNGO]
	JFFO	T2,.+1		;drop leading zeros
	LSH	T2,(T3)
	MOVNI	T3,-244(T3)	;= 233 (ls=1) + 9 (handles ROT) - shifts
	ROTC	T2,-11		;put in exponent field, get LSBITS
	JUMPG	T3,SIGNGO	;if fraction less than 1/2 LSBIT ignore
	TLNN	T3,377		;if fraction is precisely 1/2 LSBIT
	 JUMPL	T1,SIGNGO	; then nothing on negatives
	HLRZ	T3,T2		;otherwise, create a 1/2 LSBIT
	SUBI	T3,033000
	TLZ	T3,000377	;only MSBIT used
	FADRI	T2,(T3)		;and add it in with rounding
SIGNGO:	JUMPGE	T1,GOODGO
	MOVN	T2,T2
GOODGO:	UMOVEM	T2,(W)		;put into users AC
	POPJ	P,		;return
> ;end ifn SIMINS

USRXIT:
      ;DEBUGGING CHECK.
EXTERN %RIB.C,%RB2.C,%SAT.C,%CTUPT,%UPX,UPTJOB,UPTLKJ,UPYPSR
	MOVE	T1,%UPT+UPTJOB
	CAME	T1,%UPX+UPTLKJ
	CAMN	T1,%UPT+UPTLKJ
	STOPCD				;GOING BACK TO USER WITOUT GIVING UP ALL CONTEXT PAGE LOCKS.
	HRRZ	T1,@%RIB.C+%CTUPT	;
	JUMPN	T1,USRDIE	;
	HRRZ	T1,@%RB2.C+%CTUPT	;
	JUMPN	T1,USRDIE	;
	HRRZ	T1,@%SAT.C+%CTUPT	;
	JUMPE	T1,.+2		;
USRDIE:	STOPCD
      ;END OF DEBUGGING CHECK.

	MOVE J,JOB		;CURRENT JOB NUMBER
	MOVE T1,JBTSTS(J)	;STATUS WORD FOR CURRENT USER
	TRNE T1,UTRP	;IS THERE A START,REEN OR DDT WAITING
	JRST 	[LDB T1,UPYPSR	;PENDING STREAM RECORD TYPE
		PUSHJ P,ACTWRT	;WRITE IT. CLOB T1-T4
		MOVE T2,%UPT+UPTSTS
		TLZE T2,UPSSWE		;GOT SWAP ERROR IN BAD PLACE?
		JRST USRSWE		;YES.
		TLZE T2,UPSABK	;ADDRESS BREAK WAITING
		JRST UUOABK	;YES, GO DO IT.
		TLNN T2,STRTAD	;ADDRESS OR INDIRECT?
		UMOVE T2,(T2)	;INDIRECT
		TLNE T2,STRTCL	;WANTS CCL START ADDRESS?
		AOS T2		;YES, CCL IS ONE MORE THAN STANDARD
		TRNN T2,-1	;NO ZERO STARTING ADDR ALLOWED
		JRST ERRNSA
		EXCH T2,(P)	;GET JOB'S OLD PC, FORCE
		HLLM T2,(P)	;NEW PC TO START ADDRESS,KEEP FLAGS FROM PDL,
		UMOVEM T2,JOBOPC ;TELL USER WHERE TRAP WAS
		MOVEI T1,UTRP	;RESET TRAP FLAG,
		ANDCAB T1,JBTSTS(J) ;AND RESTORE T1
		JRST .+1]
	TLNN T1,CMWB!CNTRLC	;IS MONITOR TRYING TO STOP THIS USERS
				; IO OR IS HE TRYING TO STOP HIS JOB
				; (BY TYPING ^C WHILE HE WAS IN MONITOR)?
	SKIPE TIMEF		;NO. HAS CLOCK TICKED WHILE IN MONITOR?
	PUSHJ P,USCHD1	;YES, GO CALL SCHEDULER
				;STOPPING JOB IF CONTROL C TYPED IN EXEC
	POP P,T3		;USER RETURN ADDRESS
USRXT7:	MOVE J,JOB		;MAKE SURE SET UP FOR CLKTRP
	PUSHJ P,CLKTRP		;SEE IF TRAPPING NEEDED
	MOVEM T3,%UPT+UPTMUP	;T3 CHANGED IF NEEDED
	JUMPE	J, USRXT8
	SKIPN	%UPT+UPTNTV	;IF PAGE-AGE QUANTUM HAS EXPIRED,
	PUSHJ	P, AGEPAG	;  INCREMENT PAGE AGES
USRXT8:	HLLZS	JBTINA##(J)	;RESET INACTIVITY COUNT
	CHARGE			;TURN CHARGING CLOCK BACK ON
	USERAC			;SWITCH BACK TO USER'S ACS IF KL
	JEN @%UPT+UPTMUP		;RESTORE FLAGS AND RETURN TO USER
				; DISMISS INTERRUPT ONLY ON TRPJEN M
				; IN ALL OTHER CASES NO INTERRUPTS
				; IN PROGRESS

EXTERNAL GETLMA,STOLMA,LMMERR,VPUMAX,%UPLMA
USRSWE:	MOVEM	T2,%UPT+UPTSTS		;STORE THIS WITH UPSSWE OFF
	MOVEI	T1,UTRP
	ANDCAM	T1,JBTSTS(J)		;TURN THIS OFF NOW
	MOVEI	W,VPUMAX		;MUST TURN OFF "A" BITS
	MOVSI	T1,LMMERR		; FOR PAGES WE IGNORED ERRORS ON
	TDNN	T1,%UPLMA(W)	;ANY ERRORS?
USRSW1:	SOJGE	W,.-1		;NO, DO NEXT
	JUMPL	W,USRSW2

	PUSHJ	P,GETLMA	;FOUND ONE, MUST FORCE FAULT
	TRZ	P4,PGE.A!PGE.W	;SO USER DOESN'T TOUCH PAGE
	PUSHJ	P,STOLMA
	MOVSI	T1,LMMERR	;SETUP MASK AGAIN
	JRST	USRSW1		;AND CHECK FOR NEXT PAGE.

USRSW2:	HRRZ	M,%UPT+UPTXEI	;GET PAGE GOT I/O ERROR ON (MAYBE LAST OF MANY)
	LSH	M,^D9		;MAKE INTO LOCATION
	PJRST	ERRPIO		;WILL GO BACK THRU ABTUUO TO USRXIT.

UUOABK:	MOVEM	T2,%UPT+UPTSTS	;STORE UPTSTS WITHOUT UPSABK ON
	MOVEI	T2,UTRP		;CLEAR UTRP
	ANDCAM	T2,JBTSTS(J)	;FORGETT PENDING DDT, REE, ETC.
	HRRZ	M,%UPT+UPTABK	;SETUP M SO MESSAGE PRINTS OUT LOCATION OF ADDRESS BREAK
	JRST	ERRABK		;PRINT ADDRESS BREAK. RETURNS THRU USRXIT.
; CALLING SEQUENCE
;	CALL D,[SIXBIT/NAME/]
; WHERE NAME IS THE NAME OF A SYSTEM ROUTINE.
; IF NO SYSTEM ROUTINE WITH THE SPECIFIED NAME IF FOUND, THIS ROUTINE
; EXITS TO UUOERR.
;CONTENTS OF USER AC PLACED IN AC T1,M SET TO POINT
;TO USER AC, R IN LH.
;J SET TO JOB NUMBER

UCALL::	UMOVE T1,(M)	;SET T1 FROM CONTENTS OF USER ADDRESS
	MOVSI T2,-UCLLEN-CCLLEN-1	;-SUM OF LENGTHS OF SIXBIT TABLES,
				; -1 FOR THE CARRY TO LH IN AOBJN
	HRRI T2,-CCLLEN	;- LENGTH OF CUSTOMER TABLE
	CAMN T1,UCLTAB(T2)	;SEARCH SYSTEM ROUTINE NAME TABLE
	JRST	UCALLF
	AOBJN T2,.-2
	JRST	ERRCAL		;CALL ARGUMENT NOT FOUND
UCALLF:	HRRM T2,M		;STORE INDEX IN M, JUST AS IF USER HAD DONE CALLI M

;CALLI M	-	CALL IMMEDIATE
;CALLI D,E
;WHERE E IS RELATIVE INDEX IN CALL TABLE


UCALLI::HRRE T2,M		;GET CALLI NUMBER(POS.=DIGITAL,NEG.=CUSTOMER DEFINED)
	JUMPL T2,UCALL1		;IF NEG CALLI, TEST IS REVERSED
	TRZE T2,UPHNLY		;TEST BIT TO SPECIFY PHYSICAL ONLY
	HRLI W,PHONLY		;AND REMEMBER IT IN LH OF W
	JRST UCALL2
UCALL1:	TRON T2,UPHNLY
	HRLI W,PHONLY
UCALL2:	CAML T2,[-CCILEN]	;MORE NEGATIVE THAN MOST NEGATIVE CUSTOMER DEFINED M?
	CAIL T2,UCILEN	;MORE POSITIVE THAT DIGITAL DEFINED CALLI?
	POPJ P,		;YES, RETURN TO USER TREAT AS NO-OP SO
				; PROGRAMS AHEAD OF MONITOR WILL STILL
				; RUN WITHOUT ERROR MESSAGE
	HRR M,W		;M AC FIELD
	UMOVE T1,(M)		;PICK UP CONTENTS OF USER AC
	ROT T2,-1		;DEVIDE BY 2 AND SAVE REMAINDER
	MOVE J,JOB		;SETUP CURRENT JOB NUMBER(IN CASE THIS IS CALLI)
	SKIPGE	T2		;IS CALLI ODD?
	SKIPA	U,UCLJMP(T2)	;YES, USE RH
	MOVS	U,UCLJMP(T2)	;NO, USE LH
	JRST	(U)		;DISPATCH.

;CALL M DISPATCH TABLE
;NEW M'S MUST BE ADDED AT END SINCE CALLI DEPENDS ON
;POSITION IN TABLE, CUSTOMERS SHOULD ADD M'S IN CNAMES MACRO SO CALLI ADDRESS
;WILL BE NEGATIVE.  IN THIS WAY BOTH DIGITAL AND ITS CUSTOMERS CAN ADD M'S
;WITHOUT CONFLICT, DIGITAL GOING POSITIVE, CUSTOMERS GOING NEGATIVE.
; (ALSO, TOWARD TOP OF PAGE)

EXTERNAL DDTIN,DDTOUT,CPOPJ,DSKCLR,URUNHI,HNGUUO,AUXRED,ZAPCIR
EXTERNAL INTADR,INTENB,INTACT,INTASS,SETTIM,SETTR1,SETTR2,TINASS
EXTERNAL REDPIP,DDT620,VALRMT,IDLRMT,ZAPRMT,CRERMT,CREAUX
EXTERNAL POLPRT,RDHIST,SNOOPU,EVICT,RETACH,CREPTY
EXTERNAL UVALID,UPRERF,UWSCTL,URFBIT,UPROT,UPGSTS,UCREAT
EXTERNAL UPFSTS,UPESTS,UPESET,UVDSKP,VPGFIL,SETPID
EXTERNAL BLTPAG,UPISTS,UPRSTS,OTFSET,ABKUUO
EXTERNAL UCBADD,UCBHNG,UCBINI,UCBINW,UCBLEV,UCBMEM,UCBRLI,UCBSTS,UCBWAK
EXTERNAL VCLEAU,VFLCKU,VREMOU,VREPLU
EXTERNAL MOVBUF,SETMOD,WAIT,UUOSK1,STVSET
IFCPU (<KS,F3>),<EXTERNAL CIOPR>
IFNCPU (<KS,F3>),<CIOPR==CPOPJ>

DEFINE CNAMES <
	X FLSTOP,FLSTOP		; (-147) Fail stop, continue allowed
	X SETINA,SETINA		; (-146) SET INACTIVITY TIMEOUT LIMIT
	X SETMAI,SETMAI		; (-145) Set (new) mail waiting bit
	X SETMCY,SETMCY##	; (-144) Set micro-cycle timer
	X DAYTIM,DAYTIM		; (-143) RETURN DATE AND TIME
	X FLEXIT,FLEXIT		; (-142) Fail exit, no continue
	X CREPTY,CREPTY		; (-141) CREATE PTY
	X CIOPR,CIOPR		; (-140) 2020/F3 COMMUNICATIONS UUO
	X SETSTV,STVSET		; (-137) SET START VECTOR
	X VPEEK,NPEEK		; (-136) PEEK WITH ERROR RETURN
	X RETACH,RETACH		; (-135) MOVE A TTY
	X EVICT,EVICT		; (-134) CAUSE NTQ SOFT. INT.
	X PGRSTS,UPRSTS		; (-133) GET REF BIT FAULT INFO
	X PGISTS,UPISTS		; (-132) GET ILL MEM REF/ADDR BREAK FAULT INFO
	X SETABK,ABKUUO		; (-131) SET ADDRESS BREAK
	X LOGOFF,LOGOFF		; (-130) RUN ALT. LOGOUT PROGRAM
	X SETALP,SETALP		; (-127) SET ALT. LOGOUT PROGRAM
	X SETOTF,OTFSET		; (-126) SET "OTHER" FRAME UUO FOR VUUOS
	X CONT,CONTUU		; (-125) PUT TERMINAL IN USER MODE
	X PUTROY,PUTROY		; (-124) PUT ROYALTY STREAM RECORD
	X BLTPAG,BLTPAG		; (-123) BLT DATA TO A LOCKED PAGE
	X PIDSET,SETPID		; (-122) SET PROGRAM'S PID
	X FOO,CPOPJ		; (-121) DEFUNCT GET PAGE FAULT WORD UUO
	X BITPOK,BITPOK		; (-120) POKE WITH MASK
	X RDHIST,RDHIST		; (-117) READ SNOOP HISTOGRAM
	X SNOOP,SNOOPU		; (-116) START/STOP SNOOP HISTOGRAM
	X POLPRT,POLPRT		; (-115) POLL PORTS
	X CLBADD,UCBADD		; (-114) ADD SELF TO CLUB.
	X CLBLEV,UCBLEV		; (-113) REMOVE SELF FROM CLUB.
	X CLBINW,UCBINW		; (-112) GET CLB INTRLK (WAIT).
	X CLBINI,UCBINI		; (-111) GET CLB INTRLK (IMMED).
	X CLBRLI,UCBRLI		; (-110) RELEASE CLB INTRLK.
	X CLBMEM,UCBMEM		; (-107) GET INFO ABOUT CLB MBR.
	X CLBSTS,UCBSTS		; (-106) GET STATUS OF CLB MBR.
	X CLBWAK,UCBWAK		; (-105) WAKE JOB IN SAME CLB.
	X CLBHNG,UCBHNG		; (-104) HANG JOB IN SAME CLUB.
	X VPGFIL,VPGFIL		;(-103) GET FILENAME ETC FOR VP
	X VDSKPT,UVDSKP		;(-102) GET DISK POINTER FOR VP
	X PGFSTS,UPFSTS		;(-101) GET AND CLEAR PAGE FAULT STATUS
	X PGESTS,UPESTS		;(-100) GET AND CLEAR PAGE ERROR STATUS
	X VFSTAT,VFLCKU		;(-77) SEE IF THE F BIT IS ON.
	X VALPAG,UVALID		;(-76) VALIDATE AND WAIT
	X PREREF,UPRERF		;(-75) PRE REFERENCE A VIRTUAL PAGE
	X WSCTL,UWSCTL		;(-74) WORKING SET CONTROL
	X REFBIT,URFBIT		;(-73) REFERENCE BIT CONTROL
	X PERSET,UPESET		;(-72) SET/CLEAR IGNORE ERROR BIT
	X PAGSTS,UPGSTS		; (-71) GET PAGE STATUS
	X VPROT,UPROT		; (-70) SET VM PAGE PROTECTION
	X VCREAT,UCREAT		; (-67) CREATE PRIVATE VM PAGE
	X VCLEAR,VCLEAU		; (-66) CLEAR VM PAGE.
	X VREMOV,VREMOU		; (-65) REMOVE VM PAGE.
	X VREPLC,VREPLU		; (-64) REPLICATE VM PAGE.
	X PUTLSA,LSAUUO		; (-63) GENERATE LOCAL STR ACCTG REC
	X PUTSAR,PUTSAR		; (-62) PUT STREAM ACCT'G RECORD
	X CHPRJ,CHPJC##		; (-61) CHANGE PROJ CODE
	X XCHARG,XCHARG		;(-60) SAVE (ETC) CHARGING
	X SETRCF,RECMFL		;(-57)DEFINE RESTRICTED COMMAND FILE AND PPN
	X TYMCHG,SOAKEM		;(-56) ADD TRU CHARGES
	X DATUUO,DATUUO		;(-55) CONVERT DATES AND TIMES
	X DDT620,DDT620		;(-54) INTERROGATE REMOTE 620
	X VALRMT,VALRMT		;(-53) VALIDATE REMOTE PASSWORD
	X INTRMT,INTRMT		;(-52) SET REMOTE INTERRUPTS
	X IDLRMT,IDLRMT		;(-51) SET REMOTE IDLE
	X ZAPRMT,ZAPRMT		;(-50) ZAP REMOTE
	X CRERMT,CRERMT		;(-47) CREATE REMOTE PORT
	X AUXRED,AUXRED		;(-46) READ AUX CIRCUIT INFO
	X ZAPCIR,ZAPCIR		;(-45) ZAP AUX CIR
	X CREAUX,CREAUX		;(-44) CREATE AUX CIR
	X REDPIP,REDPIP		;(-43) READ PI IN PROGRESS BITS
	X TINASS,TINASS		;(-42) ASSIGN TTY INTERRUPTS
	X SETTR2,SETTR2		;(-41) SET TRAP 2 INSTR (PDLOV)
	X SETTR1,SETTR1		;(-40) SET TRAP 1 INSTR (OVERFLOW)
	X SETTIM,SETTIM		;(-37) SET INTERRUPT TIMER
	X INTASS,INTASS		;(-36) ASSIGN APR INTERRUPTS
	X INTACT,INTACT		;(-35) CAUSE PSEUDO INTERRUPT
	X INTENB,INTENB		;(-34) ENABLE INTERUTP CHANNELS
	X INTADR,INTADR		;(-33) TURN ON NEW INTERRUPT SYSTEM
SIXSTP==-1
	X HANG,HNGUUO		;(-32) HANG A JOB
	X CHKLIC,CHKLIC		;(-31) CHECK SETTABLE LICENSE
	X LEVDEF,LEVDEF		;(-30) LEAVE DEFERED ECHO MODE
	X MOVBUF,MOVBUF		;(-27) MOVE I/O BUFFER
	X SETMOD,SETMOD		;(-26) SET TTY MODE (SETSTS BUT NO INIT)
	X RUNSEG,URUNHI		;(-25) RUN A HIGH SEG
	X SYSDVF,SYSDVF		;(-24) GET DEVICE INFO
	X DISMIS,DISMIS		;(-23) DISMAISS TRAP
	X DSKCLR,DSKCLR		;(-22) CLEAR DSK CORE INFO
	X SETJAL,SETJAL		;(-21) SET JACCT, LOGIN
	X ONEJOB,ONEJOB		;(-20) SEE IF ONLY JOB ON SYSTEM
	X SETMAL,SETMAL		;(-17) SET MAIL WAITING
	X GETTMC,GETTMC		;(-16) GET TERM CHRS
	X SETTMC,UUOMNR		;(-15) SET TERM CHRS
	X REDNXT,REDNXT		;(-14) READ NEXT CHR
	X WAITCH,WAITCH		;(-13) WAIT FOR CHARACTER
	X POKE,POKE		;(-12) POKE M
	X SETPRV,SETPRV		;(-11) MOVING SETPRV HERE
	X SETLIC,SETLIC		;(-10) SET JBTLIC
	X SETE,SETE		;(-7) SETE WITH SYS PASSWORD
	X ATTACH,ATTUUO		;(-6) ATTACH, DETACH M
	X UUOERR,UUOMNR		;(-5) PLACE FOR CUSTOMERS TO PATCH UUOS
	X UUOERR,UUOMNR		;(-4) 
	X UUOERR,UUOMNR		;(-3)SET BITS IN JBTPRV
	X 6WDBLK,UUOMNR		;(-2) FOR COMPATABILITY
	X LIGHTS,LIGHTS		;(-1) SET LIGHTS (EXAMPLE OF CUSTOMER DEFINED M)
>

DEFINE NAMES,<
	X RESET,RESET		;(0)RESET IO
	X DDTIN,DDTIN		;(1)EXT-GET DDT CHAR.
	X SETDDT,SETDDT		;(2)SETDDT LOC IN PROTECTED JOB DATA
	X DDTOUT,DDTOUT		;(3)EXT:SEND DDT CHAR.
	X DEVCHR,DVCHR		;(4)DEVICE CHARACTISTICS
	X DDTGT,CPOPJ		;(5)GET DDT MODE
	X GETCHR,DVCHR		;(6)DEVICE CHAR.(DIFF. NAME)
	X DDTRL,CPOPJ		;(7)RELEASE DDT MODE
	X WAIT,WAIT		;(10)WAIT TILL DEVICE INACTIVE
	X CORE,CORUUO		;(11)CORE M
	X EXIT,EXIT		;(12)EXIT
	X UTPCLR,CPOPJ		;(13)CLEAR DEC TAPE DIRECTORY 
	X DATE,DATE		;(14)GET DATE
	X LOGIN,LOGIN		;(15)LOGIN
	X APRENB,APRENB		;(16)ENABLE APR FOR TRAPPING
	X LOGOUT,LOGOUT		;(17)LOGOUT
	X SWITCH,SWITCH		;(20)RETURN DATA SWITCHES
	X REASSIGN,REASSIGN	;(21)REASSIGN DEVICE TO ANOTHER JOB
	X TIMER,TIMER		;(22)RETURN JIFFY CLOCK TIME
	X MSTIME,MSTIME		;(23)RETURN TIME OF DAY IN MS
	X GETPPN,GETPPN		;(24)RETURN PROJECT-PROGRAMMER NUMBER
	X TRPSET,UTRPST		;(25)SET USER-IOT
	X TRPJEN,UUOMNR		;(26)DISMISS INTERRUPT TO EXEC MODE(SUPERCEDED BY UJEN)
	X RUNTIM,JOBTIM		;(27)RETURN TOTAL JOB RUNNING TIME
	X PJOB,JOBNO		;(30)RETURN JOB NUMBER
	X SLEEP,SLEEP		;(31)SLEEP FOR N SECONDS, THEN RETURN TO USER
	X SETPOV,SETPOV		;(32)SET PUSH DOWN OVERFLOW TRAP
				; (FOR COMPATIBILITY ONLY)
	X PEEK,UPEEK		;(33)TO PEEK AT CERTAIN MONITOR PARAMETERS
	X GETLIN,GETLN		;(34) GET TTY UNE NUMBER
	X RUN,URUN		;(35) RUN DEV:FILE
	X SETUWP,SETUWP		;(36) SET OR CLEAR USER MODE WRITE PROTECT
	X REMAP, REMAP		;(37) REMAP TOP OF LOW SEGMENT INTO HIGH SEG
	X GETSEG,UGTSEG		;(40) GET SHARABLE HIGH SEG
	X GETTAB,GETTAB		;(41) GET EXEC ADDRESS OF A JOB TABLE
	X FOO,CPOPJ		;(42) OBSOLETE SPY UUO
	X SETNAM,SETNAM		;(43) SETNAME OF THIS PROGRAM
	X TMPCOR,TMPUUO		;(44) TEMPORARY FILE STORAGE M (CCL)
	X DSKCHR,DSKCHR		;(45) DISK CHARACTERISTICS
	X SYSSTR,SYSTUU		;(46)RETURN NEXT STR IN SYSTEM
	X JOBSTR,JOBSTR		;(47) RETURN NEXT STR IN JOB
	X STRUUO,STRUUO		;(50) VARIOUS FUNCTION FOR STRS
	X SYSPHY,SYSPHY		;(51) RETURN ALL PHYSICAL DEVS AND UNITS IN SYSTEM
	X FRECHN,CPOPJ		;(52) RETURN 1ST FREE USER CHAN IN AC, STARTING FROM C(AC)
	X DEVTYP,CPOPJ		;(53) EXTENDED DEVICE CHARACTERISTICS AND BUFFER SIZE
	X DEVSTS,DEVSTA		;(54) DEVSTS
	X DEVPPN,DEVPPU		;(55) RETURN PPN FOR DEVICE
	X SEEK,UUOSK1		;(56) SEEK
	X RTTRP,CPOPJ		;(57) REAL TIME TRAP
	X LOCK,CPOPJ		;(60) LOCK JOB IN CORE
	X JOBSTS,CPOPJ		;(61) RETURN STATUS OF JOB AND ITS PTY
	X LOCATE,CPOPJ		;(62) FOR REMOTE COMM
	X WHERE,CPOPJ		;(63) FOR REMOTE COMM
	X DEVNAM,UDEVNM		;(64) GET PHYSICAL DEVICE NAME
	X CTLJOB,CPOPJ		;(65) FIND CONTROLLER OF THIS JOB (IF BY PTY)
	X GOBSTR,GOBSTR		;(66) GENERALIZED JOBSTR (ANY JOB'S SEARCH LIST)
	X FOO,CPOPJ		;(67) RESERVED
	X FOO,CPOPJ		;(70) RESERVED
	X HPQ,CPOPJ		;(71) SET HIGH PRIORITY QUE
	X HIBER,HIBER		;(72) HIBERNATE
	X WAKE,WAKUUO		;(73) WAKE SLEEPING JOB
	X CHGPPN,CHGPPN	;(74) CHANGE PPN
	X SETUUO,SETUUO		;(75) SET
	X DEVGEN,CPOPJ		;(76) GENERIC NUMBER
	X OTHUSR,CPOPJ		;(77) SEE IF OTHER USER
	X CHKACC,CPOPJ		;(100) SEE IF ACCESS ALLOWED
	X DEVSIZ,DVSIZU		;(101) BUFFER SIZE AND NUMBER
	X CPOPJ,CPOPJ		;2 SPARE M'S FOR PATCHING - DIGITAL ONLY
	X CPOPJ,CPOPJ		;ALWAYS ADD NEW M'S ABOVE THESE
				;CUSTOMERS SHOULD ADD M'S ABOVE
				;IN CNAMES MACRO RATHER THAN NAMES MACRO
				; SO THAT THEIR CALLI INDECES WILL
				; BE NEGATIVE
>
;GENERATE SIXBIT TABLE OF M NAMES

DEFINE X (A,B) <
IFN SIXSTP,<EXP SIXBIT /A/>
>

;GENERATE CUSTOMER CALL/CALLI M'S
SIXSTP==0

CCLTAB:	CNAMES
CCLLEN==.-CCLTAB		;LENGTH OF CUSTOMER DEFINED CALL/CALLI M'S
			;(MINIMUM CALLI NUMBER, TOO)

;GENERATE DIGITAL M'S

DEFINE X (A,B)  <
	IFL .-UCLTAB-MAXCAL,<EXP SIXBIT /A/>
>

UCLTAB:	NAMES
UCLLEN==.-UCLTAB		;DEFINE LENGTH OF DIGITAL M TABLE
DEFINE X (A,B)
<	ZZ==ZZ+1
	DEFINE XX (C)		;DEFINE XX IN CASE JOB NUMBER OF CUSTOMER M'S
<	XWD UUOERR,C
>>
ZZ==0
;COUNT NUMBER OF CUSTOMER DEFINED M'S
	CNAMES
CCILEN==ZZ

;GENERATE HALF WORD M DISPATCH TABLE

DEFINE X (A,B)
<	IFE ZZ&1,
<	DEFINE XX (C)
<
	XWD B,C
>>
	IFN ZZ&1,
<
	XX B
>
ZZ==ZZ+1
>
;GENERATE CUSTOMER TABLE

	CNAMES

ZZ==0

;FIX UP SYMBOLS NOT IN UUOCON

EXTERNAL REASSIGN,WAKUUO

EXTERN TMPUUO
EXTERN DSKCHR,SYSTUU,JOBSTR,STRUUO,SYSPHY,GOBSTR
EXTERNAL APRENB,SETPOV,SLEEP,HIBER,DISMIS	;IN PICON

;GENERATE DIGITAL TABLE

UCLJMP:	NAMES

	IFN ZZ&1,<XX CPOPJ>	;GEN. LAST WORD IF ODD NUMBER OF UUOS
UCILEN==<.-UCLJMP>*2	;MAX DIGITAL CALLI INDEX

;EXIT M ROUTINE
;CALL:	CALL FIELD, [SIXBIT/EXIT/]
;IF FIELD - 0, PRINT EXIT ^C.  CONT WILL NOT WORK
;IF FIELD NON-ZERO, JUST PRINT.  DO NOT RELEASE DEVICES

EXTERNAL ERREXI,ERREX1,IORELS

EXIT:	MOVSI T1,JACCT		;CLEAR PRIVILEGED CUSP BIT ON EXIT FOR
				; BENEFIT OF PLEASE AND RECALL
	HRRI T1,JACCT2		;ALSO USER SETTABLE ONE
	ANDCAM T1,JBTSTS(J)
	JUMPN W,EXIT1	;AC FIELD NON-ZERO?
	PUSHJ P,IORELS	;NO, RELEASE ALL DEVICES
	PUSHJ P,RESET		;AFTER CLOSING OUT FILES, RELEASE RT DEV
				;UNLOCK JOB, RESET APR
 EXTERNAL ACTWRT
	MOVEI T1,1
	PUSHJ P,ACTWRT		;WRITE TYPE 1 ACCOUNTING RECORD
	PJRST	ERREXI		;MOVE "EXIT" TO OUTPUT BUFFER
			; AND STOP JOB, AND START TTY, CONT WILL NOT WORK
EXIT1:	MOVEI T1,2
	PUSHJ P,ACTWRT		;WRITE TYPE 2 ACCOUNTING RECORD
	PJRST	ERREX1

;Frame Exit Routine(s)
; Specified AC is stored into %UPT+UPTELC
;FLEXIT - Fail exit, not continuable
;FLSTOP - Fail stop, continuable

EXTERNAL ERRFEX,ERRFX1

FLEXIT:	MOVSI	T1,JACCT	;CLEAR PRIVILEGED CUSP BIT ON EXIT FOR
				; BENEFIT OF PLEASE AND RECALL
	HRRI T1,JACCT2		;ALSO USER SETTABLE ONE
	ANDCAM T1,JBTSTS(J)
	PUSHJ P,IORELS		;NO, RELEASE ALL DEVICES
	PUSHJ P,RESET		;AFTER CLOSING OUT FILES, RELEASE RT DEV
				;UNLOCK JOB, RESET APR
	MOVEI T1,1
	PUSHJ P,ACTWRT		;WRITE TYPE 1 ACCOUNTING RECORD
	UMOVE	T4,(W)		;Pick up arg from user's AC
	PJRST	ERRFEX		;MOVE "EXIT" TO OUTPUT BUFFER
				; AND STOP JOB, START TTY, CONT WILL NOT WORK

FLSTOP:	MOVSI	T1,JACCT	;CLEAR PRIVILEGED CUSP BIT ON EXIT FOR
				; BENEFIT OF PLEASE AND RECALL
	HRRI T1,JACCT2		;ALSO USER SETTABLE ONE
	ANDCAM T1,JBTSTS(J)
	MOVEI T1,2
	PUSHJ P,ACTWRT		;WRITE TYPE 2 ACCOUNTING RECORD
	UMOVE	T4,(W)		;Pick up arg from user's AC
	PJRST	ERRFX1

; 
;  CODE TO HANDLE SOFTWARE I/O INTERRUPT UUO
;

NINTRP:	POINT 6,DEVINT(F),5		;INPUT INTERRUPT
NOUTRP:	POINT 6,DEVINT(F),11		;OUTPUT INTERRUPT 
NWATRP:	POINT 6,DEVINT(F),17		;IO WAIT INTERRUPT
NERTRP:	POINT 6,DEVINT(F),23		;ERROR INTERRUPT
NEFTRP:	POINT 6,DEVINT(F),29		;EOF INTERRUPT
NSPTRP:	POINT 6,DEVINT(F),35		;SPECIAL INTERRUPT
NUMINT==.-NINTRP
;CONT UUO
;CALLI -125

;	CONT
;	  <NO-LICENSE or DETACHED>
;	<NORMAL-RETURN>

EXTERN	TTYUSM				; ROUTINE IN SCNSER
EXTERN	DDBLDB				; HOME OF LDB POINTER IN DDB

CONTUU:	MOVE F,TTYTAB(J)		; FIND THE DDB
	HRRZ U,DDBLDB(F)		; FIND THE LDB
	JUMPE U,CPOPJ			; ERROR IF DETACHED
	PUSHJ P,TTYUSM			; DO THE WORK
	JRST CPOPJ1
COMMENT ! NEW VM SYSTEM RESET UUO KERNEL
FUNCTIONS: 1) (NEW) GUARANTEE THAT PAGE 0 BECOMES PRIVATE-RDW
	2) RESET CONTROLLING TTY
	3) DIDDLE PC FLAGS
	4) (NEW) SET USER WS LIMIT TO MAX
	5) SET JWSADJ BIT FROM ADJMWS
	6) RESET XCHARG "CHARGES SAVED IN UPT" BIT
	7) RESET TRAP SYSTEM

DESTROYS: PRACTICALLY ALL AC'S. 
EXPECTS: J/JOB
PRESERVES: M
!


EXTERN PS.CPR,PS.FIL,UPYUWL,UPYUWM,CPRRDW,CPRRED,RESFRH
EXTERN IOKILL,CHNCHK,CHNCK1

RESET::
	MOVEI PG,0
	CALLI PG,-71 	;GET PG/ PAGE STATUS, VP 0
	JFCL		;NOT SPOSED TO HAPPEN
	TRNN PG,PS.FIL	;SKIP IF FILE PAGE
	JRST RSET1	;PRIVATE, MAY NEED TO MAKE RDW
	MOVSI PG,1	;PG/<CONTIG>,,VP#
	CALLI PG,-65	;REMOVE PAGE 0
	JFCL
	MOVSI PG,<<CPRRDW>B7+1B17>B<^D18+^D35>
	CALLI PG,-67	;CREAT NEW PAGE 0
	JFCL		;SIGH
	JRST RSET2
RSET1:	;PRIVATE PAGE, JUST MAKE SURE IT'S RDW
	ANDI PG,PS.CPR
	CAIE PG,CPRRED	
	JRST RSET2	;NOT DO- MUST BE COW OR RDW
	MOVSI PG,<<CPRRDW>B7+1B17>B<^D18+^D35>
	CALLI PG,-70	;VPROT PG,
	JFCL		;SIGH
RSET2:	PUSHJ P,TTYRES	;RESET CONTROLLING TTY
	PUSHJ P,IOKILL	;RELEASE ALL DEVICES
	MOVSI T1,777777-PC.USR-PC.PUB	;CLEAR ALL M PC FLAGS IN LH, EXCEPT USER MODE
	ANDCAM T1,%UPT+UPTPDL	;LEAVE USER MODE OFF TOO, IF EXEC DOING CALL RESET
	MOVSI T1,SAVCHG
	ANDCAM T1,%UPT+UPTSTS	;RESET "XCHARG DONE" FLAG
	SETZM	JBTSCA##(J)	;Reset TRU scaling factor
	LDB T1,UPYUWM		;CONSOLE-SETTABLE WS MAXIMUM
	DPB T1,UPYUWL		;PROGRAMMABLE LIMIT
	MOVE	T1, JBTSTS(J)
	SKIPE	ADJMWS
	TROA	T1, JWSADJ
	TRZ	T1, JWSADJ
	MOVEM	T1, JBTSTS(J)	;SET PER-JOB MWS ADJUST BIT FROM ADJMWS
	PUSHJ	P,RESFRH	;GET RID OF ALL FRAME HANDLES
	MOVEI T1,0
	PJRST APRENB		;ALSO RESET INTERRUPTS

; RESTRICED COMMAND FILE AND PPN UUO
;
RECMFL:	UMOVE T2,(T1)		;GET NAME
	MOVEM T2,%UPT+UPTRNM
	UMOVE T2,1(T1)		;GET PPN
	MOVEM T2,%UPT+UPTRPN
	POPJ P,

SETPRV:	MOVE	T2,PRVMSK	;get mask of legal bits
	TLO	T2,PVLOS	;allow user to SET PVLOS LogoutOnStop
	AND	T1,T2		;mask selected bits
	MOVE	T3,T1
	SETZ	T2,		;IF WANT TO RESET TIMEOUT
	TLNE	T3,PVDINA	;SET OR RESET INACTIVITY TIMEOUT?
	MOVEI	T2,^D15		;SET.   DEFAULT TIMEOUT IS 15 MIN
	XOR	T3,JBTPRV(J)
	TLNE	T3,PVDINA	;HAS PVDINA CHANGED?
	DPB	T2,JBYLIM##	;YES, UPDATE
	MOVE	T2,PRVMSK
	ANDCAM	T2,JBTPRV(J)	;TURN OFF
	IORM	T1,JBTPRV(J)	;SET AS HE WANTED
	LDB	T1,PVYCRM	;GET MAX CORE HE CAN HAVE
	LDB	T2,PVYCOR	;AMOUNT HE JUST SET IT TO
	CAMLE	T2,T1		;TOO MUCH?
	MOVE	T2,T1		;YES, RESET TO MAX
	CAMGE	T2,CORMXK
	MOVE	T2,CORMXK
	DPB	T2,PVYCOR
	POPJ	P,

SETINA:	SETCMI	T2,JBLMSK##
	TDNE	T1,T2		;LIMIT TOO BIG?
	POPJ	P,		;YES, ERROR RETURN
	DPB	T1,JBYLIM##	;SET LIMIT
	JRST	CPOPJ1

INTERNAL PRVMSK
PRVMSK:	XWD PVNOAT!PVMTIM!PVMCOR!PVSCMD,PVMMOD!PVEXO!PVMHNG!PVRCMD!PVDINA

comment !	SETALP uuo

	MOVEI	ac,	[sixbit "<device>"
			 xwd <gan>,<uun>
			 sixbit "<filename>"]
	SETALP	ac,
	  <error return>	; if already set, if logout in progress
				; or if no PPN given
	<ok return>
!
	EXTERN  UPTALD,UPTALP,UPTALN
SETALP:
	MOVE	T2,JBTSTS(J)
	SKIPN	%UPT+UPTALN	; IF ONE ALREADY SET - ERROR
	 TRNE	T2,KJP		; IF LOGOUT IN PROGRESS - ERROR
	  POPJ	P,
	UMOVE	T2,0(T1)	; GET DEVICE
	MOVEM	T2,%UPT+UPTALD
	UMOVE	T2,1(T1)	; GET PPN
	MOVEM	T2,%UPT+UPTALP
	UMOVE	T2,2(T1)	; GET NAME
	MOVEM	T2,%UPT+UPTALN
	PJRST	CPOPJ1		; SKIP RETURN
;ATTACH UUO -- CALLED WITH ONE OF
;
;	T1/	NEGATIVE (EQUIVALENT TO T1/ 0)
;	T1/	BITS,,0  (DETACH TTY FROM CURRENT JOB)
;	T1/	BITS,,JOB # (DETACH FROM CURRENT, ATTACH TO SPEC.)
;
;	BITS = 1 TO SUPPRESS FORCING THE ATTACHEE INTO COMMAND MODE
;	     + 2 TO SUPPRESS FORCING AN EXIT FOR THE DETACHEE

ATTUUO:	SKIPGE	T1		;IF T1 < 0,
	SETZ	T1,		;    T1 := 0
	TRNN	T1,-1		;IF T1.RIGHT = 0,
	JRST	TDTUUO		;    DO A DETACH
	HRRZ	T3, T1		;T3/ JOB NUMBER
	MOVSI	T2, JNA
	CAIGE	T3, JOBN
	TDNN	T2, JBTSTS(T3)
	POPJ	P,		;JOB DOES NOT EXIST
	MOVSI	T2, JLOG
	TDNN	T2, JBTSTS(J)	;IF CALLER ISN'T LOGGED-IN,
	JRST	TRYATT		;    ALLOW ATTACH TO ANY AUN
	MOVSI	T2, LICJAL
	TDNE	T2, JBTLIC(J)	;IF CALLER HAS JL LICENSE,
	JRST	TRYATT		;    ALLOW ATTACH TO ANY AUN
	MOVE	T2, JBTAUN(J)	;OTHERWISE,
	CAME	T2, JBTAUN(T3)	;    AUN'S MUST MATCH
	POPJ	P,

TRYATT:	PUSH	P, T1		;SAVE <BITS>
	PUSHJ	P, TATUUO	;CALL SCNSER'S ATTACH ROUTINE
	  JRST	TPOPJ		;(IT COULDN'T ATTACH)
	POP	P, T1		;RESTORE <BITS>
	TLNE	T1, 2		;IF SUPRESS-EXIT BIT SET,
	POPJ	P,		;    JUST RETURN
	MOVE	J, JOB		;OTHERWISE, FORCE AN EXIT UUO
	MOVSI	T1, JLOG
	TDNN	T1, JBTSTS(J)
	JRST	JOBKL		;OR JUST KILL THE JOB IF NOT LOGGED-IN
	MOVEI	W, 0		;FORCE AN EXIT 0,
	JRST	EXIT

EXTERNAL TATUUO,TDTUUO,PVYCRM,PVYCOR,CORMXK
COMMENT !

INTRMT AC,0
	ASSIGNS CERTAIN INTERRUPT CAUSING CONDITIONS TO PSEUDO-
	INTERRUPT CHANNELS, USING THE NEW PSEUDO-INTERRUPT 
	SYSTEM. MUST BE PRECEDED BY INTADR UUO.

	AC BITS 18-35 HAVE CHANEL NUMBER ON WHICH DEVICE IS INITED
		AN INIT MUST HAVE BEEN DONE
	AC BITS 9-17 HAVE THE INTERUPT CHANNEL NUMBER
	AC BITS 0-8 HAVE THE REASON FOR THE INTERUPT

		0  INPUT AVAILABLE
		1  OUTPUT BUFFER AVAILABLE. MUST HAVE INTERUPTED
		   FOR I/O WAIT
		2  UUO WOULD PLACE JOB IN I/O WAIT
		3  END OF FILE ON INPUT (NOT YET USED)
		4  ERROR ON INPUT OR OUTPUT (NOT YET USED)
		5  PORT ZAPPED

	NOTE THAT THE ERROR RETURN IS ALWAYS TAKEN IF THE PORT IS
	ALREADY ZAPPED

	SKIP RETURN IF SUCCESSFUL. AC HAS PREVIOUS CHANNEL ASSIGNMENT.
	NON-SKIP RETURN  IF NONSUCCESSFUL, ERROR CODE IN AC RIGHT
		NOPORT==> PORT NOT ASSIGNED TO THIS JOB
		NXCOND==> NON-EXISTENT CONDITION
		NXCHAN==> NON-EXISTENT CHANNEL
		NOINT==> NOT PRECEDED BY INTADR
!



EXTERN JBTPIP
INTERN	INTRMT
;T1 HAS USER AC CONTENTS
EXTERNAL TAKTRP,CHNCK1
INTERNAL RETERR
NXICHN==1		;INCORRECT CHANNEL NUMBER
NXCOND==5		;NON EXISTENT INTERRUPT CONDITION
NXCHAN==6		;NON EXISTENT INTERRUPT CHANNE
NOINT==7		;INTADR UUO NOT CALLED
INTRMT:	MOVEI T2,NXICHN		;INCASE ERROR RETURN FROM CHNCK1
	HRRZ W,T1	;GET PROPOSED CHANNEK NUMBER
	PUSH P,T1
	MOVEI T1,DDINT
	PUSHJ P,CHNCK1	;SEE IF REAL CHANNEL
	 JFCL	;BAD CHAN
	JRST [POP P,T1	;NOT IN DISPAT TABLE,UNWIND STK &
		JRST RETERR]; RTN NXICHN ERR COD
	POP P,T1
	SKIPGE JBTPIP(J)
	JRST INTER1	;NO INTADR DONE
	LDB T2,[POINT 9,T1,8]
	CAIL T2,NUMINT	;LEGAL CONDITION?
	JRST INTER2	;NO
	LDB T1,[POINT 9,T1,17]
	CAILE T1,^D35	;LEGAL CHANNEL?
	JRST INTER3
	LDB T3,NINTRP(T2)	;GET OLD CHANNEL
	UMOVEM T3,(W)	;AND RETURN
	DPB T1,NINTRP(T2)
	JUMPE T1,CPOPJ1	;IF 0, COULD NOT INTERUPT NOW
	MOVE P1,T1		;SAVE CHANNEL NUMBER
	PUSHJ P,DDINT(T4)		;CALL DEVICE DEPENDENT ROUTINE 
	JRST INTER3		;ERROR RETURN
	SKIPA		;O.K. BUT NO TRAP NOW
	JRST [MOVE T1,P1		;TAKE TRAP. RECOVER CHANNEL NUMBER
	      PUSHJ P,TAKTRP
	      JRST CPOPJ1]
	JRST CPOPJ1


INTER1:	MOVEI T2,NOINT
	JRST RETERR
INTER2:	MOVEI T2,NXCOND
	JRST RETERR
INTER3:	MOVEI T2,NXCHAN
RETERR:	UMOVEM T2,(M)
	POPJ P,
EXTERNAL JBTLIC,LICMAX,LICMSK,JBTSLC

	;SETLIC UUO. SETS BOTH HALVES OF JBTLIC
	;CHECKS TO SEE IF MAX OF CURRENT TWO HALVES ALLOWES
	;DESIRED SETTING. IF NOT SETS AS MUCH AS IT CAN GET
	;CALL
	;	MOVE AC,DESIRED LICENSE
	;	CALL AC,[SIXBIT /SETLIC/] OR CALLI AC,-10

SETLIC:	MOVE T2,JBTLIC(J)
	HLL T2,JBTSLC(J)	;SAVED LIC ALWAY >= JBTLIC L.H.
	PUSH P,T1		;LICENSE DESIRED
	PUSHJ P,JOBLIC		;FIND WHAT CAN BE SET
	MOVE	T2,(P)		;Get max of new
	HLR	T2,JBTSLC(J)	; and old
	PUSHJ	P,LICMAX	; process lic
	HRLM	T2,JBTSLC(J)	;Save so can restore if reduced later
	POP P,T2		; GET LICENSE HE CAN GET OFF STACK
	EXCH T2,JBTLIC(J)	; GIVE IT TO HIM
	XOR T2,JBTLIC(J)	; SEE WHAT CHANGED
	TRNN T2,-1		; SEE IF HE CHANGED THE JOB LICENSE
	  POPJ P,
	MOVEI T1,14		;RECORD THAT HE SET LICENSE
	PJRST ACTWRT		;AND RETURN FROM UUO NOSKIP

JOBLIC:	PUSH P,T2		;SAVE CURRENT LICENSE
	MOVSS (P)		;IN L.H. KEEP CUR. JOB LIC.
	PUSHJ P,LICMAX		;FIND MAX OF JOB AND PROCESS
	HRRM T2,(P)		;SAVE LICENSE JOB CAN GET
	HLL T2,-2(P)		;GET DESIRED PROCESS
	PUSHJ P,LICMSK
	HRLM T2,-2(P)		;AND SAVE IT
	POP P,T2		;RESTORE MAX CAN HAVE
	MOVE T1,JBTLIC(J)	;GET HIS CURRENT LICENSE
	TLNN T1,LICWCR		;IF HAS WC, LET HIM INCREASE JOB LIC
	 HLRS T2		; NO, CAN NOT INCREASE JOB LIC
	HRL T2,-1(P)		;DESIRED JOB LIC
	PUSHJ P,LICMSK		;WHAT HE CAN HAVE
	TRZ T2,LICRMT		;CAN NOT HAVE REMOTE IN JOB (obsolete?)
	HRRM T2,-1(P)		;RETURN ALLOWED JOB LICENSE
	POPJ P,

	;CHKLIC UUO. CHECKS ON LICENSE A JOB CAN SET
	;CALL
	;	MOVEI AC,LOC
	;	MOVSI AC,BITS
	;	CALL AC,[SIXBIT /CHKLIC/] OR CALLI AC,-31
	;
	;LOC:	DESIRED LICENSE
	;	PRETEND THIS IS IN LICENSE WORD (SEE BITS)
	;	XOR OF PPN OF USER AND FILE IF SET FOR FILE
	;BITS 1=USE LOC+1 INSTEAD OF JBTLIC
	;     2=SET TO FILE NOT CORE

CHKLIC:	PUSH P,M
	HRR M,T1
	MOVE T3,T1	;SAVE LEFT HALF BITS
	XCTFU <PUSH P,(M)>
	TLNN T3,1
	SKIPA T2,JBTLIC(J)
	UMOVE T2,1(M)
	TLNE T3,2	;TO FILE?
	JRST CKLCFL	;YES
	PUSHJ P,JOBLIC
	POP P,T1
	POP P,M
	UMOVEM T1,(M)		;STORE IT IN THE USER'S AREA.
	POPJ P,			;RETURN.
CKLCFL:	HLLZS T2	;USE ONLY THE PROCESS LIC
	UMOVE T3,2(M)	;GET THE XOR TO USE
	POP P,T1
	PUSHJ P,FILLIC
	POP P,M
	UMOVEM T1,(M)		;STORE T1 IN USER'S AREA.
	POPJ P,			;RETURN.

EXTERNAL FILLIC
	;SETE UUO. TAKES A 2 WORD SYSTEM PASSWORD AND
	;HASHES IT. THEN COMPARES WITH THE NTH ENTRY OF A TABLE
	;IF COMPARES, TABLES HAS WHAT LICENSE MAY BE SET
	;CALL
	;	MOVEI AC,BLOCK
	;	CALL AC,[SIXBIT /SETE/] OR CALLI AC,-7
	;	ERROR RETURN - INCORRECT PASSWORD
	;	NORMAL RETURN

	;BLOCK:	WORD 1 OF PASSWORD
	;	WORD 2 OF PASSWORD
	;	NUMBER OF SYSTEM PASSWORD
	;	LICENSE DESIRED

EXTERNAL SETECD,SETENM,SETELV
;TABLES IN SETE##.MAC DEFINE NAMES,PASSWORDS 

SETE:	HRR M,T1
	PUSHJ P,INIRDM	;INITIALIZE
	UMOVE P1,1(M)	;ONE WORD OF USER HASH
	PUSH P,M
	UMOVE M,(M)	;THE OTHER WORD
	MOVE T3,[POINT 7,HNMAM]	;MORE CHRS (O HASH
HS3:	ILDB F,T3
	JUMPE F,ENDHSH
	PUSHJ P,LOPRDM
	JRST HS3

LOPRDM:	ADDM F,M
	ADDM F,P3
	MOVEI F,12
HS2:	MOVE T1,M(T4)
	MUL T1,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
	ADDM T2,P1(T4)
	CAIE T4,3
	AOJA T4,HS1
	MOVE T4,P4
	ADDM T4,M
	LSH T4,-42	;GET HIGH 2 BITS FOR NEW INDEX
HS1:	SOJG F,HS2
	POPJ P,

INIRDM:	MOVE T1,[XINIT,,P2]
	BLT T1,P4
	MOVEI T4,0
	POPJ P,

INTERNAL INIRDM,LOPRDM
ENDHSH:	MOVE P4,M	;SAVE HASH RESULT
	POP P,M
	XCTFU <SKIPL T1,2(M)> ;GET PASSWORD NUMBER, SKIP IF NO GOOD.
	CAIL T1,SETENM
	POPJ P,		;TOO BIG, ERROR RETURN
	CAME P4,SETECD(T1)	;GET PASSWORD
	POPJ P,		;WRONG
	MOVE T2,SETELV(T1)	;MAX HE CAN HAVE
	XCTBU <HRL T2,3(M)>
	PUSHJ P,LICMSK
	TRZ T2,LICRMT
	HRRM T2,JBTLIC(J)
	MOVEI T1,15
	PUSHJ P,ACTWRT
	JRST CPOPJ1	;GOOD RETURN

XINIT:	555555555555
	361275431652
	555555555555

HNMAM:	ASCIZ /TYMSHR/

WAITCH:	MOVEI W,-1
	PJRST TTYUUO

GETTMC:	MOVEI W,-2
	PJRST TTYUUO

SETTMC:	MOVEI W,-3
	PJRST TTYUUO

REDNXT:	MOVEI W,-4
	PJRST TTYUUO

LEVDEF:	MOVEI W,-5
	PJRST TTYUUO

; SETMAL and SETMAI UUO's use a common routine

SETMAL:	movei t4,pvmail		; bit to set in priv word
	jrst setml1		; jump off to worker

SETMAI:	hrlzi t4,pvnmai		; [new mail] bit in priv word

; Subroutine to do SETMAL or SETMAI UUO.  Takes bit to set in T4.

SETML1:	push p,t4		; [dws] save t4
	MOVE T2,SYSPPN
	MOVEI T1,FNCDEL
	MOVEI T4,077
	PUSHJ P,CHKPRJ		;SEE IF CAN WRITE ON THE MAILBOX
	 SKIPA			;YES
	  jrst [pop p,t4
		popj p,]	; [dws] no, pop t4 and go home
	pop p,t4		; [dws] restore t4
	UMOVE T1,(M)		;GET ADDRESS FROM USER AREA.
	HRR M,T1		;SET TO GET USER NAME
	UMOVE T1,(M)		;GET ARGUMENT FROM USER AREA.
	MOVE T2,T1
	HRRI M,1(M)		;INCREMENT POINTER TO USER AREA.
	UMOVE T1,(M)		;AND FETCH ARGUMENT.
	MOVE P1,HIGHJB
NXMAL:	JUMPE T2,FNDMAL		;ALL USERS
	CAMN T2,JBTUNM(P1)
	CAME T1,JBTUN1(P1)
	JRST NOMAL		;NOT FOR HIM
FNDMAL:	PUSH P,T1
	move t1,t4		; [dws] pick up bit to use
	IORM T1,JBTPRV(P1)
	POP P,T1
NOMAL:	SOJG P1,NXMAL
	POPJ P,

EXTERNAL FNCDEL,CHKPRJ
SYSDVF:	HRRM T1,M	;POINT M AT THE LOC SPECIFIED IN AC
	HLRZ P1,T1	;GET COUNT
	SOSG P1
	MOVEI P1,1	;MUST BE AT LEAST 2
	UMOVE T1,(M)
	CAIL T1,0
	CAIL T1,SYDTBL	;CHECK RANGE OF ARG
	POPJ P,
	SKIPE SYDDSP(T1)	;SO WE CAN USE EXTERN
	JRST @SYDDSP(T1)
	POPJ P,			;NOT IMPLIMENTED

SYDDSP:	SYDNAM		;DEVICE BY NAME
	SYDLOC		;DEVICE BY LOCATION OF DDB
	SYDUNI		;UNIT
	SYDSTR		;STRUCTURE
IFDEF  FTAUN,<SYDFTA>	;FTA UNIT
IFNDEF FTAUN,<Z>	; ------
IFCPU (KS),<
IFDEF  MAGUN,<SYDTMX>	;TU45 UNIT
IFNDEF MAGUN,<Z>	; ------
> ; End IFCPU (KS)
IFNCPU (KS),<Z>		; Non - TU45 unit  === Possibly can be left out?

SYDTBL==.-SYDDSP

SYDNAM:	HRRI M,1(M)		;INCREMENT PTR TO USER'S AREA.
	UMOVE T1,(M)		;AND PICK UP ARGUMENT.
	HLRZ U,DEVLST
	MOVSI T2,DVDSK!DVTTY!DVRMT	;DON'T GIVE INFO ABOUT THESE
	JUMPE T1,SYDNM1		;ASKING FOR FIRST DEVICE
SYDNM3:	TDNN T2,DEVMOD(U)
	CAME T1,DEVNAM(U)	;IS NAME CORRECT AND NOT DSK OR TTY
	SKIPA
	JRST SYDNM2	;YES
	HLRZ U,DEVSER(U)
	JUMPN U,SYDNM3
	POPJ P,			;NOT A DEVICE, ERROR RET

SYDNM2:	HLRZ U,DEVSER(U)
	JUMPE U,SYDNM4	;OUT OF DEVICES
SYDNM1:	MOVE T2,DEVMOD(U)	;IS IT A GOOD DEVICE
	TLNE T2,DVTTY!DVDSK!DVRMT
	JRST SYDNM2	;NO
	EXCH F,U	;FOR PJOBN
	LDB J,PJOBN
	EXCH F,U
	PUSHJ P,CHKSEG		;SEE IF CAN GET INFO ABOUT THIS JOB
	 JRST SYDNM2	;NO, SAY NOTHING ABOUT DEVICE
	MOVE T1,DEVNAM(U)
	UMOVEM T1,(M)
SYDLC5:	SOJLE P1,CPOPJ1		;DOES HE WANT ANY MORE?
	HRRI M,1(M)		;INCREMENT PTR TO USER'S AREA.
	UMOVE T1,1(M)		;AND GO TO NEXT ENTRY.
	HRRZ T1,DEVSER(U)
	XCT DVSIZ(T1)	;GET THE DDB SIZE
SYDCOM:	UMOVEM T1,(M)	;RETURN SIZE TO USER
	CAILE P1,1(T1)	;GET MIN OF REQUESTED AND AVAILABLE
	MOVEI P1,1(T1)	;1(T1)SINCE WE SOJLE FIRST
SYDNM5:	SOJLE P1,CPOPJ1	;DONE
	ADDI M,1	;POINT TO FIRST WORD FOR DDB ETC
	ADD P1,M
	HRL M,U		;GET THE BLT SET UP
	XCTTU <BLT M,-1(P1)>	;GIVE TO USER
	JRST CPOPJ1

SYDLOC:	HRRI M,1(M)		;INCREMENT PTR.
	UMOVE T1,(M)		;AND GET NEXT ENTRY.
	HLRZ U,DEVLST
	JUMPE T1,SYDLC1
SYDLC3:	CAIN T1,(U)
	JRST SYDLC2	;FOUND
	HLRZ U,DEVSER(U)
	JUMPN U,SYDLC3
	POPJ P,		;NOT IN LIST (MAYBE DSK GONE AWAY)

SYDLC2:	HLRZ U,DEVSER(U)
	JUMPE U,SYDNM4
SYDLC1:	EXCH F,U	;FOR PJOBN
	LDB J,PJOBN
	EXCH F,U
	PUSHJ P,CHKSEG
	 JRST SYDLC2
	UMOVEM U,(M)
	JRST SYDLC5

SYDNM4:	XCTBU <SETZM (M)>
	JRST CPOPJ1

INTERNAL SYDNM4,SYDCOM

IFDEF FTAUN,<EXTERN SYDFTA>
IFCPU (KS),<IFDEF MAGUN,<EXTERN SYDTMX>>

EXTERNAL SYDUNI,SYDSTR
;RETURN JOB NUMBER FOR THIS JOB

JOBNO:	UMOVEM J,(M)		;COPY JOB NUMBER TO USER'S AREA.
	POPJ P,			;AND RETURN.

;RETURN THE DATE TO THE USER

EXTERNAL THSDAT

DATE:	PUSHJ P,GETUDT
	 MOVEI T2,0
	UMOVEM T2,(W)
	POPJ P,

;RETURN JOB RUNNING TIME IN MILLISECONDS

JOBTIM:
EXTERNAL JOBN
	SKIPL T1
	CAILE T1,JOBN
	JRST	RTZER
	SKIPN J,T1		;GET JOB NUMBER DESIRED
	MOVE J,JOB		;CURRENT JOB
	PUSHJ P,CHKSEG		;SEE IF LEGAL
	 JRST RTZER		;NO
	PUSHJ P,TIMADJ	;READ CLOCK
	PUSHJ 	P,CLKTRU	;GET TRU'S
	UMOVEM 	T1,(M)		;MOVE INFO TO USER'S AREA.
	POPJ 	P,		;AND RETURN.

;RETURN TIME OF DAY IN MILLISECONDS

EXTERNAL TIME,JFYSEC

MSTIME:	PUSHJ 	P,GETUDT
	 MOVEI 	T1,0
	IMULI 	T1,^D1000
	IDIV 	T1,JFYSEC
	UMOVEM 	T1,(M)		;INFO TO USER'S AREA.
	POPJ 	P,		;AND RETURN.

;return elapsed time since 1/1/64 00:00 in seconds
;	MOVEI	ac,time-zone
;	DAYTIM 	ac,
;	<only return>

DAYTIM:	PUSHJ	P,GETGMT	;GET GMT DATE AND TIME IN 2 T2,T1
	UMOVE	P4,(M)		;GET DESIRED TIME ZONE
	TRO	P4,600000	;REQUEST 1 WORD FORMAT
	HRLI	P4,400020	;FROM GMT 2 WORD TYMSHARE FORMAT
	PUSHJ	P,DATCOM	;CONVERT THE DATE
	 MOVEI	T1,0		;WHATEVER HAPPENED?
	UMOVEM	T2,(M)		;RETURN RESULT
	POPJ	P,
	
;PEEK INTO MONITOR M
;CALL	MOVEI	AC,<MONITOR ADDRESS>
;	CALL	AC,[SIXBIT .NPEEK.]
;IF AC BIT 0=1 DO VIRTUAL PEEK ELSE PHYSICAL

	EXTERN MEMSIZ,UPSJOB

NPEEK:
	MOVSI T2,LICSPY
	TDNN T2,JBTLIC(J)	;CAN HE DO IT?
	POPJ P,			;NO. TAKE ERROR RETURN
	JUMPL T1,UPEEK1		;JUMP IF VIRTUAL PEEK DESIRED
	PUSHJ P,PEKCHK		;CHECK ADDRESS VALIDITY
	 POPJ P,		;ADDRESS INVALID, ERROR RETURN
	MOVE	T1,%UPS(T1)
UPEEK3:	UMOVEM T1,(M)		;MOVE TO USER'S AREA
	JRST CPOPJ1		;AND RETURN
IFCPU (KI),<
UPEEK1:	MAP T2,(T1)		;SEE IF ADDR IS READALBE WITHOUT FAULT
	TRC T2,MAP.FL!MAP.M	;PG IS READABLE IF FL AND M
	TRNN T2,MAP.FL!MAP.M	;BOTH NOT SET
	POPJ P,			;PAGE NOT READABLE
>;END IFCPU (KI)
IFNCPU (KI),<
UPEEK1:	TRNN T1,-20		;CHECK IF ADDR POINTS TO AN AC
	JRST UPEEK2		;AC POINTED TO, SO ADDR OK
	MAP T2,(T1)		;SEE IF ADDR IS READABLE WITHOUT FAULT
	TLNN T2,PFW.A		;READABLE IF PG IS ACCESSIBLE
	POPJ P,			;PAGE NOT READABLE
>;END IFNCPU (KI)
UPEEK2:	MOVE T1,(T1)		;FETCH REQUESTED WORD
	JRST UPEEK3		;FINISH UP

;OLD PEEK. SAME AS NPEEK EXCEPT RETURNS ZERO IF UNSUCCESSFUL
;AND HAS ONLY ONE RETURN POINT.

UPEEK:	PUSHJ P,NPEEK		;ATTEMPT THE PEEK
	 JRST RTZER		;ERROR: RETURN 0
	POPJ P,			;SUCCES

;POKE M CALL
;MOVEI AC,D
;CAL AC,[SIXBIT /POKE/]
; D/  DATA TO STORE
; D+1/ LOC TO STORE INTO
;      WITH SIGN BIT=1 FOR VIRTUAL POKE, 0 FOR PHYSICAL

POKE:	MOVSI T2,LICWCR	;HAVE PRIV
	TDNN T2,JBTLIC(J)
	 POPJ P,			;NO, ERROR RETURN
	UMOVE T4,(T1)		;GET VALUE TO POKE FROM USER
	UMOVE T1,1(T1)		;GET ADDRESS TO POKE AT
	JUMPL T1,POKE1		;JUMP IF VIRTUAL POKE DESIRED
	PUSHJ P,PEKCHK
	 POPJ P,
	MOVEM T4,%UPS(T1)
	JRST CPOPJ1
POKE1:	PUSHJ P,POKCHK		;SEE IF VIRTUAL POKE LEGAL
	 POPJ P,		;BAD ADDR, ERROR RETURN
	MOVEM T4,(T1)		;POKE REQUESTED WORD
	JRST CPOPJ1		;AND RETURN

PEKCHK:	TLZ T1,400000	;CLEAR SIGN BIT
	MOVE PG,T1	;GET ABSOLUTE ADDRESS
	JUMPL PG,CPOPJ	;BAD IF NEGATIVE
	CAIL PG,20	;BAD IF IN AC'S (PHYSICAL ONLY)
	 CAML PG,MEMSIZ	;BAD IF NO MEMORY THERE
	  POPJ P,	;ERROR RETURN - DON'T MAP IT
	LSH PG,-11	;GET BLOCK NUMBER
	LDB T3,PGYNXM	;DOES BLOCK EXIST?
	CAIL PG,340	;SKIP IF IN UNMAPPED AREA
	 JUMPN T3,CPOPJ	;NO. ERROR
	TRO PG,PGE.P!PGE.A!PGE.W
			;NO CACHE BIT, OR ELSE CAN DRAG AREA INTO CORE
			;THAT SHOULD NOT BE CACHED!
	MOVE T3,EPYPSN	; From [EPTPTR(%UPS.N)]
	DPB PG,T3
	SETZM UPSJOB		;NO REAL UPT MAPPED THRU HERE ANYMORE
	CLRPTO	%UPS		;SETUP UPS SLOT IN MAP TO POINT TO BLOCK
	ANDI T1,777		;T1_OFFSET IN BLOCK
	JRST CPOPJ1	;EITHER WRITE OK OR READ OK

IFCPU (KI),<
POKCHK:	MAP T2,(T1)	;SEE IF ADDR IS WRITEABLE WITHOUT FAULT
	TRNE T2,MAP.FL	;SKIP IF WRITEABLE
	POPJ P,		;ERROR RETURN
	JRST CPOPJ1	;SKIP RETURN
>;END IFCPU (KI)
IFNCPU (KI),<
POKCHK:	TRNN T1,-20	;CHECK IF ADDR POINTS TO AN AC
	JRST CPOPJ1	;AC POINTED TO, SO ADDR GOOD
	MAP T2,(T1)	;SEE IF ADDR IS WRITEABLE WITHOUT FAULT
	TLC T2,PFW.A!PFW.W	;PG IS WRITEABLE IF A & W BOTH NOT SET
	TLNE T2,PFW.A!PFW.W	;SKIP IF WRITEALBE
	POPJ P,		;ERROR RETURN
	JRST CPOPJ1	;SKIP RETURN
>;END IFNCPU (KI)
;BITPOK	UUO
;CALL:
;	MOVE AC,FOO
;	BITPOK AC,
;	  <ERROR>
;	<NORMAL>
;
;FOO:	<ADDRESS>
;	<ANDCAM WORD>
;	<IORM WORD>
;
;WITH SIGN BIT OF <ADDRESS>=1 FOR VIRTUAL POKE, 0 FOR PHYSICAL

;ON SUCCESS, IF (RC) LICENSE, (AC):=OLD VALUE OF <ADDRESS>

BITPOK:	MOVSI T2,LICWCR		; CHECK FOR WC LICENSE
	TDNN T2,JBTLIC(J)
	 POPJ P,
	HRR T4,T1		; USER ADDRESS OF ARGUMENTS
	UMOVE T1,(T4)		; GET PHYS ADR FROM USER
	JUMPL T1, [PUSHJ P,POKCHK	;SEE IF POKE LEGAL
		    POPJ P,		;BAD ADDR, ERROR RETURN
		   MOVE T3,(T1)		;GET OLD VALUE TO RETURN
		   JRST .+4]		;PROCEED
	PUSHJ P,PEKCHK		; SEE IF VALID
	 POPJ P,		;  BAD ADR - ERROR RETURN
	MOVE T3,%UPS(T1)	; GET OLD VALUE TO RETURN
	MOVSI T2,LICSPY		; SEE IF WE SHOULD RETURN OLD VALUE
	TDNE T2,JBTLIC(J)
	 UMOVEM T3,(M)		;  RETURN OLD VALUE IN AC (IF RC LIC)
	UMOVE T2,1(T4)		; GET ANDCAM WORD FROM USER
	UMOVE T3,2(T4)		; GET IORM WORD FROM USER
	JUMPL T1, [ANDCAM T2,(T1)	;CLEAR BITS AS NECESSARY
		   IORM T3,(T1)		;SET BITS AS NECESSARY
		   JRST CPOPJ1]		;NORMAL RETURN
	ANDCAM T2,%UPS(T1)	; CLEAR BITS AS NECESSARY
	IORM T3,%UPS(T1)	; SET BITS AS NECESSARY
	JRST CPOPJ1
;TRPSET UUO - SET USER IOT

;CALL	SETZ AC,	OR	SETO AC,
;	TRPSET AC,
;	  <NO WC LICENSE>
;	<OKAY>

UTRPST:	MOVSI T2,PC.UIO		; CLEAR IT ALWAYS
	ANDCAM T2,PDNMUP(P)
	MOVSI T3,LICWCR		; TEST WC LICENSE
	TDNN T3,JBTLIC(J)
	  POPJ P,		; NO LIC - ERROR RETURN
	JUMPE T1,CPOPJ1		; WANTS IT OFF (ALREADY IS)
	JUMPG T1,CPOPJ		; CAN'T HAVE POSITIVE ARGUMENT
	IORM T2,PDNMUP(P)	; SET U-IOT AND GO HOME
	JRST CPOPJ1
;DATE UUO
;	AC T1 CONTAINS LOC
;LOC:	DATE
;	TIME
;	FROM,,TO
;
;FROM AND TO FORMATS:
;	'400000	DATE FORMAT IS 2 WORDS; DAYS SINCE 1/1/64,,TICS
;	'600000 DATE FORMAT IS 1 WORD; SECS PAST 1/1/64 00:00
;	'xx	TIME ZONE CODE - OR 0 FOR USER LOCAL
;		'20 IS GMT, '50 IS PST SUBJECT TO DAYLIGHT, ETC.

DATUUO:	MOVE M,T1
	UMOVE T1,1(M)
	UMOVE T2,(M)
	UMOVE P4,2(M)
	PUSHJ P,DATCOM
	 POPJ P,	;ERROR RETURN
	UMOVEM T1,1(M)
	UMOVEM T2,(M)
	JRST CPOPJ1

DATCOM:	JUMPL 	T2,CPOPJ	;NEGATIVE DATE IS ILLEGAL
	LDB 	T3,PVYTIM	;GET USERS TIME ZONE
	SKIPN 	T3
	 MOVEI 	T3,50		;IF NONE, SET PDT
	TRNN 	P4,77
	 TRO 	P4,(T3)		;SET ZONES IF 0
	TLNN 	P4,77
	 TLO 	P4,(T3)
 	TLNE	P4,200000	;ONE WORD FORMAT?
	 JRST	[EXCH	T1,T2
		IDIV	T1,[^D60*^D60*^D24];T1/DATE T2/SECS
		IMUL	T2,JFYSEC;T1/DATE T2/TICS
		EXCH	T1,T2	;T1/tics T2/date 
		JRST	.+1]
	PUSH 	P,T2		;SAVE DATE ON STACK
	IDIV 	T1,JFYHR	;GET HOURS IN T1 AND MIN-SEC-JIF IN T2
	EXCH 	T2,(P)
	PUSH 	P,T1
	MOVE 	T1,T2		;DATE IN T1 HR IN (P) MIN-JIF IN -1(P)
	TLNN 	P4,400000	;IN DAYS SINCE JAN 1,1964?
	 PUSHJ 	P,DEC2YR	;NO, CONVERT
	IMULI 	T1,^D24		;CONVERT DAYS TO HRS
    	POP 	P,T2
	ADD 	T1,T2		;NOW HAVE HRS SINCE JAN 1
	TLNN 	P4,40		;DAYLIGHT SAVINGS?
	 JRST 	NODST1
	PUSHJ 	P,DSTCHK	;YES, IS IT
	SUBI 	T1,1		;YES, CONERT TO STANDARD
NODST1:	HLRZ 	T2,P4
	ANDI 	T2,37		;TIME ZONE OF SOURCE
	SUB 	T1,T2
	MOVE 	T2,P4
	ANDI 	T2,37
	ADD 	T1,T2		;NOW HAVE CONVERTED TO NEW
	TRNN 	P4,40		;NEW IN DAYLIGHTSAVINGS TIME
	 JRST 	NODST2		;NO
	PUSHJ 	P,DSTCHK
	ADDI 	T1,1		;IT IS
NODST2:	JUMPL 	T1,TPOPJ	;ERROR, NEGATIVE DATE
	IDIVI 	T1,^D24		;GET DAYS
	IMUL 	T2,JFYHR	;CONVERT HRS TO TICKS
	ADDB 	T2,(P)
	TRNE	P4,200000	;WANT 1 WORD FORMAT?
	 JRST	[IMUL 	T1,[^D60*^D60*^D24];T1/SECS(DATE PART) T2/TICS
		IDIV	T2,JFYSEC;T2/SECS T3/0
		ADD 	T1,T2	;T1/DATE T2/SECS
		JRST 	.+1]
	TRNN 	P4,400000	;WANT DEC FORMAT?
	 PUSHJ 	P,YR2DEC
	MOVE 	T2,T1	;GET DATE IN T2
	JRST 	TPOPJ1	;TIME IN T1 AND SKIP
YR2DEC:	IDIVI T1,^D<365*4+1>
	IMULI T1,4	;CREATE REAL YEARS
	CAIG T2,^D366
	JRST BREAK1	;THIS IS IN A LEAP YEAR
	SUBI T2,1	;FOR LEAP YEAR
	IDIVI T2,^D365
	ADD T1,T2	;HAVE CORRECT NUMBER OF YEARS
	CAIL T3,^D59
	AOSA T2,T3	;ADD 1, TABLE IS FOR LEAP YEAR
	MOVE T2,T3
BREAK1:	MOVEI T3,1
	CAML T2,MONTB(T3)	;CHECK MONTH TABLE
	AOJA T3,.-1
	SUB T2,MONTB-1(T3)	;NOW DAYS IN T2, MONTH IN T3
	IMULI T1,^D12	;YEARS-64*12
	ADDI T1,-1(T3)	;+MONTHS-1
	IMULI T1,^D31	;*31
	ADD T1,T2	;+DAYS-1
	POPJ P,

MONTB:	DEC 0,31,60,91,121,152,182,213,244,274,305,335,366

DEC2YR:	IDIVI T1,^D31	;T2 HAS DAYS-1
	PUSH P,T2
	IDIVI T1,^D12	;T1 YR-64, T2 MN-1, (P) DY-1
	MOVE T2,MONTB(T2)
	TRNE T1,3	;IS IT NON-LEAP YEAR
	CAIGE T2,^D60	;AND AFTER FEB 28
	SKIPA
	SUBI T2,1	;YES, COMPENSATE
	ADDM T2,(P)
	MOVEI T2,3(T1)
	LSH T2,-2	;NUMBER OF LEAP YEARS
	IMULI T1,^D365
	ADD T1,T2
	ADDM T1,(P)
	JRST TPOPJ

	INTERNAL DSTCHK
;CHECK TO SEE IF TIME IN DAYLIGHT SAVING RANGE
;CALL:
;	MOVEI T1,HOURS SINCE 1-JAN-64
;	PUSHJ P,DSTCHK
;	 <YES-DST IN EFFECT>
;	<NO---DST NOT IN EFFECT>
;
DSTCHK:	MOVSI T3,-DLTLEN	;GET LENGTH OF TABLE
DSTCK1:	CAMGE T1,DLTTAB(T3)	;IS IT AFTER START TIME
	JRST CPOPJ1		;NO, NOT DAYLIGHT SAVINGS
	CAMGE T1,DLTTAB+1(T3)	;AFTER END?
	POPJ P,			;NO, IN CORRECT RANGE
	ADDI T3,1		;GET NEXT PAIR IN TABLE
	AOBJN T3,DSTCK1
	JRST CPOPJ1		;OUT OF TABLE, MUST BE NOT D.S.T

EXTERNAL PVYTIM,JFYHR
;TABLE FOR DAYLIGHT SAVINGS TIME. ENTRIES ARE IN PAIRS
;FIRST IS START, SECOND END. NUMBER IS HOURS SINCE JAN 1,1964

DLTTAB:	OCT 5341,15761		;APR 26-OCT 25 1964
	OCT 26401,37271		;APR 25-OCT 31 1965
	OCT 47441,60331		;APR 24-OCT 30 1966
	OCT 70751,101371	;APR 30-OCT 29 1967
	OCT 112011,122431	;APR 28-OCT 27 1968
	OCT 133051,143471	;APR 27-OCT 26 1969
	OCT 154111,164531	;APR 26-OCT 25 1970
	OCT 175151,206041	;APR 25-OCT 31 1971
	OCT 216461,227101	;APR 30-COT 29 1972
	OCT 237521,250141	;APR 29-OCT 28 1973
	OCT 253361,271201	;JAN 6-OCT 27 1974 (SPECIAL)
	OCT 276651,312241	;FEB 23-OCT 26 1975
	OCT 322661,333551	;APR 25-OCT 31 1976
	OCT 343721,354611	;APR 24-OCT 30 1977
	OCT 365231,375651	;APR 30-OCT 29 1978
	OCT 406271,416711	;APR 29-OCT 28 1979
	OCT 427331,437751	;APR 27-OCT 26 1980
	OCT 450371,461011	;APR 26-OCT 25 1981
	OCT 471431,502321	;APR 25-OCT 31 1982
	OCT 512471,523361	;APR 24-OCT 30 1983
	OCT 534001,544421	;APR 29-OCT 28 1984
	OCT 555041,565461	;APR 28-OCT 27 1985
	OCT 576101,606521	;APR 27-OCT 26 1986
	OCT 617141,627561	;APR 26-OCT 25 1987
	OCT 640201,651071	;APR 24-OCT 30 1988
	OCT 661511,672131	;APR 30-OCT 29 1989
	OCT 702551,713171	;APR 29-OCT 28 1990
	OCT 723611,734231	;APR 28-OCT 27 1991
	OCT 744651,755271	;APR 26-OCT 25 1992
	OCT 765711,776601	;APR 25-OCT 31 1993
	OCT 1006751,1017641	;APR 24-OCT 30 1994
	OCT 1030261,1040701	;APR 30-OCT 29 1995
	OCT 1051321,1061741	;APR 28-OCT 27 1996
	OCT 1072361,1103001	;APR 27-OCT 26 1997
	OCT 1113421,1124041	;APR 26-OCT 25 1998
	OCT 1134461,1145351	;APR 25-OCT 31 1999
	OCT 1155771,1166411	;APR 30-OCT 29 2000
	OCT 1177031,1207451	;APR 29-OCT 28 2001
	OCT 1220071,1230511	;APR 28-OCT 27 2002
	OCT 1241131,1251551	;APR 27-OCT 26 2003
	OCT 1262171,1273061	;APR 25-OCT 31 2004
	OCT 1303231,1314121	;APR 24-OCT 30 2005
	OCT 1324541,1335161	;APR 30-OCT 29 2006
	OCT 1345601,1356221	;APR 29-OCT 28 2007
	OCT 1366641,1377261	;APR 27-OCT 26 2008

DLTLEN==<.-DLTTAB>/2
;SETUUO SET VARIOUS THINGS

SETUUO:	HLRZ 	T2,T1		;GET ARGUMENT NUMBER
	CAIL 	T2,SUUNUM
	POPJ 	P,		;TOO LARGE
	HLLZ 	T3,SUUTAB(T2)	;GET LICENSE NEEDED
	JUMPE	T3,SETUU1	;Jump if none required
	TDNE	T3,JBTLIC(J)	;If it has any of these licenses
	  JRST	SETUU1		;Go to it
	JUMPN	T2,CPOPJ	;Return if not OPRSND
	MOVE	T3,JBTFPN(J)	;Find program's source PPN
	CAME	T3,SYSPPN	;Always let SYS programs type on CTY
	  POPJ	P,		;Not from (SYS), error out
SETUU1:	HRRZ 	T2,SUUTAB(T2)	;AND DISPATCH
	JRST 	(T2)

SUUTAB:	LICOPR,,OPRSND
	LICOPR,,SCHSET		;(1) SCHEDULE
	0,,INISET		;(2) INIT2 FUNCTION
	LICOPR!LICJAL,,TIMSET	;(3) SET TIME
	LICOPR!LICJAL,,DATSET	;(4) SET DATE
	LICOPR!LICJAL,,OPRSET	;(5) SET OPR
	0,,SETWTC		;(6) SET WATCH
	LICJAL,,SCSPRV		;(7) SET OR CLEAR SCHPRV
	0,,SETTLK		;(10) TALK TO JOB'S CMND PORT
	LICSPY!LICOPR!LICWCR,,BTCMD	;(11) READ/WRITE BOOTS CMND STRING
	LICSPY!LICOPR!LICWCR,,REST	;(12) READ/WRITE RESTART BITS
SUUNUM==.-SUUTAB

EXTERNAL OPRSND,INISET,SKDCOM,DWNFLG,JFYMIN,COMSOP

; RETURN GMT T1/TIME T2/DATE
GETGMT::MOVE	T2,THSDAT
	MOVE	T1,TIME
	CAME	T2,THSDAT	;WATCH OUT FOR MIDNIGHT!
	 JRST	GETGMT
	POPJ	P,

; RETURN LOCAL DATE IN T2, TIME IN T1
GETUDT:	PUSHJ	P,GETGMT
	MOVSI 	P4,400020	;FROM GMT DAYS TO USER DEC FORMAT
	JRST 	DATCOM

TIMSET:	HRRZS 	T1
COMTMS:	IMUL 	T1,JFYMIN	;CONVERT TO JIFFIES
	PUSH 	P,T1
	PUSHJ 	P,GETUDT	;GET CURRENT DATE AND TIME
	 MOVEI 	T2,0		;ERROR SET 0 DATE
	POP 	P,T1		;BECAUSE OF DAYLIGHT SAVINGS
COMDTS:	MOVEI 	P4,400020	;FROM USER TO GMT DAYS
	PUSHJ 	P,DATCOM
	 POPJ 	P,		;ERROR
	MOVEM 	T2,THSDAT
	MOVEM 	T1,TIME
	JRST 	CPOPJ1

DATSET:	HRRZ 	T2,T1
COMDAS:	PUSH 	P,T2
	PUSHJ 	P,GETUDT
	 MOVEI 	T1,0		;ERROR, SET 0 TIME
	POP 	P,T2
	JRST 	COMDTS

SCHSET:	SKIPE 	DWNFLG
	POPJ 	P,		;IN PROCESS OF HANGUP, CAN NOT SET
	HRRZ 	T2,T1
	PJRST	SKDCOM

OPRSET:	PUSHJ 	P,TTYFNU
	JUMPE 	U,CPOPJ		;NO TTY
	MOVE 	T1,F
	AOS 	(P)		;GIVE SKIP RETURN
	JRST 	COMSOP		;COMMON SET OPR IN COMCON

SETWTC:	ANDI 	T1,WCHALL
	HRLZS 	T1
	IORM 	T1,JBTWCH(J)
	JRST 	CPOPJ1

COMMENT ! FUNCTION 7: SET OR CLEAR SCHPRV
CALLED: MOVSI 	AC,7
	HRRI  	AC,NONZERO TO SET SCHPRV, ELSE LEAVE 0 TO CLEAR
	SETUUO 	AC,
	 ERROR, NOT LICENSED TO DO THIS
	SUCCESS AC UNCHANGED
!

SCSPRV:	MOVE 	T2,JBTSTS(J)	;SET OR CLEAR SCHPRV
	TRNE 	T1,-1		;RH USER AC 0 IF WANTS CLEARED
	TROA 	T2,SCHPRV
	TRZ  	T2,SCHPRV
	MOVEM 	T2,JBTSTS(J)
	JRST 	CPOPJ1
INTERNAL COMTMS,COMDAS,GETUDT,DATCOM

COMMENT	! .STTLK (10) -- TALK TO JOB'S COMMAND PORT

	HRLI	AC, .STTLK
	HRRI	AC, ADDR
	SETUUO	AC,
	  ERROR RETURN	;AC/ ERROR CODE (SEE SCNSER)
	NORMAL RETURN	;COMPLETE MESSAGE SENT, AC UNCHANGED

ADDR:	JOB #
	ILDB POINTER TO NULL-TERMINATED STRING

!
EXTERNAL STTLK,TKROM%

SETTLK:	PUSH	P, T1
	XCTFU	<MOVE T2, 1(T1)>	;T2/ BYTE POINTER
	XCTFU	<MOVE T1, 0(T1)>	;T1/ TALKEE JOB #
	PUSHJ	P, STTLK	;TRY TO TALK
	  JRST	.+2		;(FAILURE)
	JRST	TPOPJ1		;(SUCCESS -- RESTORE ADDR)
	POP	P, T3		;T3/ ADDR
	CAIN	T1, TKROM%	;IF RAN OUT OF ROOM,
	XCTTU	<MOVEM T2, 1(T3)>	;UPDATE BYTE POINTER
	UMOVEM	T1, (W)		;STORE ERROR CODE
	POPJ	P,

COMMENT !FUNCTION 11 (.BTSTR): READ/WRITE BOOTS COMMAND STRING

	HRLI	AC,.BTSTR
	HRRI	AC,<CONTROL WORD ADDR>
	SETUUO	AC,
	  ERROR RETURN		;LACKING LIC OR BAD STRING LENGTH
	NORMAL RETURN

CONTROL WORD: BITS 18-35: ADDR OF SOURCE/DESTINATION ASCIZ STRING
	      1B0=0 FOR READ -- REQUIRES RC, OP, OR WC
	      1B0=1 FOR WRITE -- REQUIRES WC
		    IF STRING IS TOO LONG IT WILL BE TRUNCATED
		     AND THE ERROR RETURN TAKEN
		    AN ADDR OF ZERO CLEARS COMMAND STRING
	      IF CONTROL WORD ADDR IS ZERO NEITHER READ NOR WRITE

RETURN MAXIMUM STRING LENGTH IN CHARACTERS IN AC

!

EXTERN	BTSTR,BTSTLN

BC.RDW==(1B0)			;CONTROL WORD READ/WRITE BIT

BTCMD:	HRRZ	T1,T1		;ISOLATE CONTROL WORD ADDR
	JUMPE	T1,BTCMD1	;IF ZERO ONLY WANT BTSTLN
	UMOVE	T1,(T1)		;FETCH CONTROL WORD
	MOVE	T3,[POINT 7,BTSTR]	;PREPARE BTSTR BYTE PTR
	TLNE	T1,BC.RDW	;STRING READ DESIRED?
	JRST	BTCMD2		;NO: GO WRITE
	HRLI	T1,(POINT 7,)	;PREPARE USER STRING BYTE PTR
BTCMD3:	ILDB	T2,T3		;GET CHAR FROM BTSTR
	XCTFU	<IDPB T2,T1>	;GIVE TO USER
	JUMPE	T2,BTCMD1	;DONE IF 'NULL'
	JRST	BTCMD3		;CONTINUE WITH NEXT CHAR
BTCMD2:	MOVSI	T2,LICWCR	;USER MUST HAVE WC LIC
	TDNN	T2,JBTLIC(J)	; TO MODIFY BOOTS CMD STRING
	POPJ	P,		;DOES NOT, ERRROR RETURN
	HRRZ	T1,T1		;ISOLATE USER STRING ADDR
	JUMPE	T1,BTCMD5	;CLEAR STRING
	HRLI	T1,(POINT 7,)	;PREPARE USER STRING BYTE PTR
	MOVEI	T4,BTSTLN	;INIT CHAR COUNTER
BTCMD4:	XCTFU	<ILDB T2,T1>	;GET A CHARACTER FROM USER
	JUMPE	T2,BTCMD5	;DONE IF 'NULL'
	JUMPE	T4,BTCMD6	;ERROR IF STRING TOO LONG
	IDPB	T2,T3		;PLACE IN BTSTR
	SOJA	T4,BTCMD4	;CONTINUE IF ROOM IN STRING
BTCMD6:	SOS	(P)		;SET TO NON-SKIP RETURN
BTCMD5:	SETZ	T2,		;PUT 'NULL' TERMINATOR AT
	IDPB	T2,T3		; END OF STRING
BTCMD1:	MOVEI	T1,BTSTLN	;GET MAX STRING LENGTH
	UMOVEM	T1,(W)		;GIVE TO USER
	JRST	CPOPJ1		;SKIP RETURN

COMMENT !FUNCTION 12 (.REST): READ/WRITE RESTART BITS

	HRLI	AC,.REST
	HRRI	AC,<BITS>
	SETUUO	AC,
	  ERROR RETURN		;MISSING LIC
	SUCCESS RETURN

<BITS>:		1B18=0  READ RESTART BITS INTO AC
		    =1  SWAP AC RESTART BITS WITH CURRENT RESTART BITS

		1B19=0  WRITE DSKCLN TYPE TO DISK
		    =1  DO NOT WRITE DSKCLN TYPE TO DISK

		377B27  CRASH RESTART
		377B35  HANG RESTART

	THE FORMAT OF THE CRASH AND HANG RESTART FIELDS ARE IDENTICAL.
	LET THE LEFT MOST BIT OF EITHER FIELD BE LABELED '0', THEN
	THE FIELDS ARE INTERPRETED AS FOLLOWS:

		7B2  DEFINITION STATE OF ACTIONS, 1=DEFINED,
		     BITS CORRESSPOND LEFT TO RIGHT WITH THE
		     THREE ACTIONS

		1B3=0  STRING PASSED TO BOOTS
		   =1  MANUAL BOOTS
		1B4=0  AUTO ONCE
		   =1  MANUAL ONCE
		7B7  DSKCLN TYPE
		 

FOR READ OP, RC, OR WC IS NEEDED.  FOR SWAP WC IS REQUIRED.

!

EXTERN	REUSER

REST:	MOVE	T2,REUSER	;GET CURRENT RESTART BITS
	UMOVEM	T2,(W)		;PASS ALONG TO USER
	TRNN	T1,1B18		;SWAP DESIRED?
	JRST	CPOPJ1		;NO. SUCCESS RETURN
	MOVSI	T2,LICWCR	;GET WC MASK
	TDNN	T2,JBTLIC(J)	;DOES USER HAVE WC SET?
	POPJ	P,		;NO. ERROR RETURN
	HRRM	T1,REUSER	;SET RESTART BITS
	JRST	CPOPJ1		;SUCCESS RETURN
;SET OR CLEAR USER MODE WRITE PROTECT BIT IN HIGH SEG FOR THIS USER ONLY
;CALL:	MOVEI AC,0 OR 1
;	CALL AC,[SIXBIT /SETUWP/] OR CALLI AC,34
;	ERROR - MACHINE OR MONITOR CANNOT HANDLE TWO REG, OR TRYING TO CLEAR
;			;UWP OF A SHARABLE SEG(AC=1 ON RETURN)
;	OK RETURN - AC CONTAINS PREVIOUS SETTING( OR JOB HAS NO HIGH SEG)

	EXTERN USTUWP
SETUWP:	JRST USTUWP		;GO TO ROUTINE IN SEGCON

;M TO REMAP TOP PART OF LOW SEGMENT INTO HIGH SEGMENT
;PREVIOUS HIGH SEG(IF ANY) IS KILLED AND A NEW SEGMENT NUMBER IS ASSIGNED
;TO THIS JOB. REMAP IS USED BY LOADER AND GET
;CALL:	MOVEI AC,NEW HIGHEST USER ADR IN LOW SEG(EXEC ORS IN 1777)
;	CALL AC,[SIXBIT /REMAP/] OR CALLI AC,35
;	ERROR RETURN, MACHINE OR EXEC CANNOT HANDLE 2 REG OR DESIRED ADR
;			;GREATER THAN OLD LOW SEG
;	OK RETURN, LOW SEG ABOVE ARG NOW THE HIGH SEG

	EXTERN UREMAP
REMAP:	JRST UREMAP		;CORE1 MODULE IN SEGCON
;SET LIGHTS ON CONSOLE FROM USER PROGRAM

;CALL AC,[SIXBIT /DATAO/] OR CALLI AC,-1

;THIS IS AN EXAMPLE OF A USER DEFINED M WITH A NEGATIVE CALLI ARG.

LIGHTS:
IFCPU (KI),<DATAO PI,T1>		;SENT USER'S AC TO CONSOLE LIGHTS
	POPJ P,		;RETURN TO HIM

;RETURN TIME OF DAY IN JIFFIES (60THS,50THS OR MS)

TIMER:	PUSHJ P,GETUDT
	 MOVEI T1,0
	UMOVEM T1,(M)		;MOVE TO USER'S AREA.
	POPJ P,			;AND RETURN.

;RETURN DATA SWITCHES

IFCPU (KL),<EXTERN SPCGSW>
SWITCH:
IFCPU (<KI,F3>),<DATAI T1>
IFCPU (KL),<PUSHJ	P,SPCGSW>
IFCPU (KS),<MOVE T1,KSSS4##> ;FAKE SENSE SWITCHES ON KS2020
	UMOVEM T1,(M)		;MOVE TO USER'S AREA.
	POPJ P,			; AND RETURN.

;RETURN DEVICE CHARACTERISTICS

EXTERNAL PJOBN

DVCHR:	PUSHJ P,DVCNSG	;SEARCH FOR DEVICE
	TDZA T1,T1		;NOT A DEVICE, RETURN ZERO
	SKIPA T1,DEVMOD(F);DEVICE FOUND,RETURN DEVMOD
	JRST	[UMOVEM T1,(M)	;RETURN ZERO, DEVICE NOT FOUND.
		POPJ P,]	;AND RETURN.
	TLZ T1,DVAVAL	;THIS BIT USED FOR OTHER PURPOSES IN CORE
	LDB T2,PJOBN		;GET JOB NO.  USING DEVICE
	CAME T2,JOB		;DOES CURRENT USER ALREADY HAVE IT?
	TRNN T1,ASSCON+ASSPRG	;NO, IS IT ASSIGNED?
	TLO T1,DVAVAL		;NO, BUT HE CAN GET IT.
	UMOVEM T1,(M)		;MOVE TO USER'S AREA.
	POPJ P,			;AND RETURN.

;RETURN PROJECT-PROGRAMMER NUMBER IN AC

GETPPN:
	EXTERNAL JBTPPN
	MOVSI T1,JACCT
	TDNE T1,JBTSTS(J)	;LOGIN OR LOGOUT CUSP RUNNING ?
	JRST GETPPL		;YES, SPECIAL PROJ,R NUMBER CHANGE.
	MOVE T1,JBTPPN(J)	;NO, RETURN PROJECT-PROGRAMMER NO. OF THIS JOB.
	UMOVEM T1,(M)		;INFO TO USER'S AREA.
	POPJ P,			; AND RETURN.

INTERN RTZER

RTZER:	XCTBU <SETZM (M)>	;RETURN A ZERO TO THE USER AC.
	POPJ P,			;AND RETURN.

EXTERN	SYSPPN
DEVPPU:	PUSHJ P,DVCNSG
	 JRST RTZER		;NOT A DEVICE
	TLNE F,SYSDEV
	SKIPA T1,SYSPPN
	MOVE T1,JBTPPN(J)
	UMOVEM T1,(M)		;MOVE PPN TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.
;RETURN BUFFER SIZE, STANDARD NO OF BUFFERS
;CALL:	MOVE AC,LOC OF (2 WORRD) OPEN BLOCK
;CALLI AC,DVSIZ
;NOT IMPLEMENTED RETURN
;AC=XWD NO OF BUFS,BUF SIZE

DVSIZU:	PUSH	P,M		;SAVE UUO
	HRR	M,T1		;GET LOC OF OPEN-BLOCK
	UMOVE T1,(M)		;PICK UP MODE FROM USER'S AREA.
	MOVE	P1,T1		;SAVE IT
	HRRI M,1(M)		;INCREMENT POINTER TO USER'S AREA.
	UMOVE T1,(M)		;AND GET THE DEVICE.
	PUSHJ	P,DVCNSG	;FIND ITS DDB
	  TDZA	T1,T1		;NOT A DEVICE
	SKIPA	M,P1		;FOUND - SET UUO=MODE
	SOJA	T1,SIZRET	;NOT A DEV - RETURN AC=-1
	MOVEI	T2,1		;SET FOR MODE TEST
	ANDI	P1,17		;GET MODE ALONE
	LSH	T2,(P1)		;POSITION THE BIT
	MOVNI	T1,2		;IF MODE IS ILLEGAL,
	CAIL	P1,SD		;TEST FOR DUMP MODE
	TDZA	T1,T1		;IT IS, RETURN AC=0
	TDNN	T2,DEVMOD(F)	; RETURN AC=-2
	PJRST	SIZRET
	LDB T1,[POINT 12,DEVCHR(F),35]
	HRLI	T1,STDRNG	;T1/BUFF IN STD RING,,BUFF SIZE
	ADDI	T1,2		;BUMP SIZE BY 2 HOUSEKEEPING WRDS
SIZRET:	POP	P,M		;RESTORE LOC OF AC
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

UDEVNM:	PUSHJ P,DVCNSG		;FIND DEVICE OR CHANNEL
	 JRST RTZER		;NON-RETURN 0
	MOVE T1,DEVNAM(F)	;GET REAL NAME
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

	EXTERNAL JBTSOK

SOAKEM:	ANDI T1,377		;MAKE SURE IN RANGE 0-255
	IMULI T1,^D1000
	MOVE T2,T1		;A COPY
	ADD T1,JBTSOK(J)
	JUMPLE T1,CPOPJ1	;IGNORE IF OVERFLOW
	MOVEM T1,JBTSOK(J)
	ADDM T2,JBTSOK
	JRST CPOPJ1
;DEVICE STATUS CONI RETRIEVAL CALLI M

;     CALL AC,[SIXBIT/DEVSTS/]
;                 OR
;    CALLI AC,54

;             WHERE AC CONTAINS THE CHANNEL NUMBER OF THE
;		INIT'ED DEVICE....
;		THE CONI STATUS WORD IN THE DDB (DEVSTS)
;		IS RETURNED IN AC 

DEVSTA:	PUSHJ P,DVCNSG		;FIND DEVICE OR CHANNEL
	 JRST RTZER
	MOVE T1,DEVSTS(F)
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

SETJAL:	MOVSI T2,LICJAL
	TDNE T2,JBTLIC(J)	;CAN HE DO IT?
	SKIPA T2,JALMSK		;YES, ALL THINGS
	MOVEI T2,JACCT2		;ONLY JACCT2 FOR NORMAL USER
	PUSHJ P,CKLGO		;SEE IF WAITING FOR LOGOUT
	TRZ T2,JACCT2		;IF SO, CAN NOT SET THIS
	PUSH P,T1
	AND T1,T2		;THE BITS HE CAN SET
	IORM T1,JBTSTS(J)
	XOR T1,T2
	ANDCAM T1,JBTSTS(J)
	POP P,T1		;GET BACK REQUEST
	XOR T1,JBTSTS(J)
	AND T1,JALMSK
	JUMPE T1,CPOPJ1		;ALL SET, GOOD RETURN
	POPJ P,			;SOME NOT SET, ERROR RETURN

JALMSK:	XWD JACCT+JLOG,JACCT2+KJP

ONEJOB:	MOVE T1,STATES		;CHECK FOR SUPER SHUT
	TRC T1,600000
	TRCE T1,600000
	POPJ P,			;NOT SUPER-SHUT
	MOVE T1,HIGHJB
	SOJLE T1,CPOPJ1	;IF HIGHEST IS JOB 1 MUST BE OK
	MOVSI T2,JNA
	TDNE T2,JBTSTS(T1)	;JOB NUMBER ASSIGNED?
	POPJ P,			;YES
	SOJG T1,.-2
	JRST CPOPJ1		;ONLY JOB AND SUPER-SHUT

EXTERNAL STATES,CKLGO

SETDDT:	UMOVEM T1,JOBDDT	;SET JOBDDT IN JOB DATA AREA 
	POPJ P,		;RETURN TO USER

EXTERNAL	HIGHJB
GETPPL:	MOVE T1,JBTPPN(J)	; AND GET OLD NUMBERS.
	MOVE T2,HIGHJB	;CHECK FOR OTHER USERS UNDER SAME PP NUMBER.
PPNLUP:	CAIN T2,(J)	;IS NEXT JOB TO BE LOOKED AT CURRENT JOB ?
	SOJLE T2,[UMOVEM T1,(M)	;YES, FINISHED SCANNING ALL JOBS ?
		POPJ P,]	;IF SO, RETURN.
	CAMN T1,JBTPPN(T2)	;NO, ANOTHER USER UNDER SAME PROJ,R NUMBER ?
	AOSA	(P)		;YES, SKIP RETURN TO USER (LOGIN OR LOGOUT)
	SOJG T2,PPNLUP	;NO, KEEP LOOKING
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	POPJ P,			; AND RETURN.

GETLN:	PUSHJ	P,TTYFND	;FIND USER'S TTY DATA BLOCK.
	MOVE	T1,DEVNAM(F)	;GET DEVICE NAME IN SIXBIT
	UMOVEM T1,(M)		;MOVE IT TO USER'S AREA.
	POPJ P,			; AND RETURN.
;LOGIN UUO USED ONLY BY LOGIN AND LOGOUT CUSPS
;CALL:	CALL AC,[SIXBIT /LOGIN/]
;WHERE AC CONTAINS XWD -NO. OF ENTRIES,LOCATION
;WHICH IS A LIST OF JOB STATISTICS TO BE STORED IN MONITOR
;RETURNS TO UUO +1 IF SUCCESSFUL AND THAT LOC DOES NOT CONTAIN A HALT

LOGIN:	MOVSI	T2,JLOG		;IS USER ALREADY LOGGED IN?
	TDNE	T2,JBTSTS(J)
	JRST	UUOERR		;YES, PRINT ILLEGAL M
	HLRE	P1,T1		;NO, -NO. OF WORDS
	HRR	M,T1		;FIRST REL. LOC.
	MOVE	P2,[XWD -LOGTOP,LOGTAB]	;SET FOR LOOP
LOGIN1:	AOSG	P1		;FINISHED HIS COUNT?
	XCTBU <SKIPA P3,(M)>	;NO, GET NEXT WORD FROM USER AREA
	MOVEI	P3,0		;YES, STORE 0
	MOVEM	P3,@(P2)	;NO, STORE J
	ADDI	M,1		;GET NEXT J
	AOBJN	P2,LOGIN1	;FINISHED NO. OF MONITOR TABLES?
	MOVN	T1,P1		;HAS USER SUPPLIED
	CAIGE	T1,3		; PROJECT CODE?
	JRST	LOGIN2		;NO, LET HIM WRITE HIS OWN ACT REC
	HRL	T1,M		;GET THE PROJECT
	HRRI	T1,%UPT+UPTPJC	; CODE INTO
	XCTFU <BLT T1,%UPT+UPTPJ2> ; THE UPT
	MOVEI	T1,40		;WRITE THE LOGIN
	PUSHJ	P,WRTACR	; ACT RECORD
LOGIN2:	IORM	T2,JBTSTS(J)	;YES, FINALLY SET LOGIN BIT

;;Copy originating port from LDB (if one exists)

	SKIPN	T1,TTYTAB(J)	;Address of TTY DDB
	JRST	LOGIN3		;None there???
	HRRZ	T1,DDBLDB(T1)	;Address of Line Data Block
	JUMPE	T1,LOGIN3	;Skip if detached
	MOVE	T1,LDBLOG##(T1)	;Originating port from network
	SKIPN	%UPT+UPTLOG##	;If already set, don't set again
	MOVEM	T1,%UPT+UPTLOG## ;Set into UPT

LOGIN3:	LDB	T1,PVYCOR	;JUST MAKE SURE NOT TOO MUCH CORE
	LDB	T2,PVYCRM
	CAMLE	T1,T2
	MOVE	T1,T2
	CAMGE	T1,CORMXK
	MOVE	T1,CORMXK
	DPB	T1,PVYCOR
	UMOVE	T1,@PDNMUP(P)	;GET NEXT INSTR FROM USER AREA
	LSH	T1,-30		;LOOK AT TOP 12 BITS
	CAIE	T1,2542		;HALT?
	POPJ	P,0		;NO. RETURN TO USER.
	PUSHJ	P,IORELS	;RELEASE ALL DEVICES
	PUSHJ	P,TTYFUW	;FIND TTY AND PRINT ^C
	JRST	HOLD

	EXTERN	TTYFUW

;TABLE OF POINTERS TO TABLES(STORED WITH JOB NUMBER AS INDEX)
;TO MAKE LOGIN SET MORE TABLES IN MONITOR, JUST ADD TABLE NAMES AT END
; THIS TABLE IS ALSO USED BY CREFRM UUO.

LOGTAB::XWD	J,JBTPPN##	;PROJECT-PROGRAMMER NUMBER
	XWD	J,JBTPRV##	;JOB PRIVILEGE BITS
	XWD	J,JBTAUN##
	XWD	J,JBTUNM##
	XWD	J,JBTUN1##

XP	LOGTOP,.-LOGTAB	;NO. OF TABLES TO BE SET

;LOGOUT M

LOGOUT:	MOVSI	T1,JLOG
	TDNN	T1,JBTSTS(J)	;IS JOB ALREADY LOGGED OUT ?
	JRST	JOBKL		;NO, GO COMPLETE WORK OF LOGOUT CUSP.
	JRST	EXIT	;YES, TREAT AS "EXIT"

;HERE WITH FD IN J AND ACCESS RIGHTS NUMBER IN P3 TO SEE IF CALLER
; CAN GET INFORMATION. IF SO, GO TO FINTAB, IF NOT, POPJ AND GIVE ERROR RETURN.

EXTERNAL FARCHK

ACCWAY:	MOVE	P4,J		;GET FD INTO P4 WHERE IT BELONGS
	PUSH	P,T1		;SVE TABLE ADDRESS
	PUSHJ	P,FARCHK	;CHECK THE FD, SEE IF CALLER HAS RIGHTS
	  JRST	TPOPJ		;NO, GIVE ERROR RETURN TO UUO CALLER
	POP	P,T1		;OK, RESTORE T1 AND
	JRST	FINTAB		;GIVE HIM THE DATA.

SYSWAY:	MOVE T2,JOB
	MOVE T2,JBTLIC(T2)
	TLNN T2,LICSYS
	POPJ P,		;MUST HAVE SYSTAT
	JRST FINTAB

ACJWAY:	SKIPA	P3,[.ARRAD]	;NEED READ ACCT DATA FOR THIS
JLNWAY:	MOVEI	P3,.ARRDS	;NEED READ STATE TO GET FRAME'S TTY NAME
	MOVE	P4,J		;GET FD IN P4 FOR FARCHK
	PUSH	P,NUMTAB(T1)	;SAVE ADDRESS TO GO TO ON STACK.
	PUSHJ	P,FARCHK	;MAKE SURE FD IS OK, CHECK ACCESS
	  JRST	TPOPJ		;NO GOOD, GIVE ERROR
	POPJ	P,		;GET ROUTINE ADDRESS OFF STACK AND GO TO IT.

TAJWAY:	PUSHJ P,TIMADJ
	MOVEI	P3,.ARRAD	;WAYTAJ IS USED TO READ ACCOUNTING DATA
	JRST	ACCWAY		;GO CHECK.

JPOPJ:	POP P,J
	POPJ P,

DEFINE X(NAM,DO)<
WAY'NAM==<.-WAYTAB>_5
IFGE <.-WAYTAB>-17,<PRINTX TOO MANY WAYS IN GETTAB
QQQQQQ>
IFNB <DO>,<DO>
IFB <DO>,<JRST [MOVEI P3,.AR'NAM
		JRST ACCWAY]>
>;END X MACRO DEFINITION

DEFINE WAYS<
X(RPI)
X(RFI)
X(RUN)
X(RDS)
X(RAD)
X(JLN,<JRST JLNWAY>)
X(ACJ,<JRST ACJWAY>)
X(SYS,<JRST SYSWAY>)
X(TAJ,<JRST TAJWAY>)
X(JMP,<JRST @NUMTAB(T1)>)
>;END WAYS MACRO DEFINITION

;GENERATE TABLE OF WAYS

WAYTAB:	JFCL				;IF NO WAY, DO NOTHING.
	WAYS
;HERE FROM COMCON WITH C(T2) FRAME TRYING TO EXECUTE COMMAND,
; C(J) TARGET FRAME NUMBER

EXTERNAL JOBMAX


CHKSGJ:	PUSH P,T1
	MOVEI T1,LICSYS
	JRST	CHKSJ1

;HERE WITH C(JOB) CURRENT FRAME NUMBER, FRAME NUMBER TO CHECK FOR IN
; C(J) (UNCHECKED)

CHKSEG:	MOVE	T2,JOB
	CAILE	J,JOBMAX	;IN RANGE?
	POPJ	P,		;NO, GIVE ERROR RETURN.
	PUSH	P,T1
	MOVSI	T1,LICSYS
CHKSJ1:	TDNE T1,JBTLIC(T2)
	JRST TPOPJ1	;HAS SYSTAT, GIVE IT TO HIM
	MOVE T1,JBTAUN(J)
	XOR T1,JBTAUN(T2)
	JUMPE T1,TPOPJ1	;SAME AUN, OK TO HAVE IT
	TLNE T1,-1
	JRST TPOPJ	;NOT SAME PROJECT, NEVER CAN GET IT
	MOVEI T1,PVACTS	;CHECK ACCOUNT SUP
	TDNE T1,JBTPRV(T2)
	AOS -1(P)
	JRST TPOPJ

;HERE TO DO NUMTAB - TAKE CARE OF NEGATIVE INDICES.

DONUMT:	MOVEI	T2,NUMTAB(J)	;GET ADDRESS HE WANTS
	CAIGE	T2,ENDGTB	;IF PAST END OR
	CAIGE	T2,MINTAB	;BEFORE THE BEGINNING
	POPJ	P,		;ERROR RETURN.
	MOVE	T3,JOB		;MUST HAVE SY
	MOVE	T3,JBTLIC(T3)
	TLNN	T3,LICSYS	;OR ELSE
	POPJ	P,		;GIVE HIM ERROR RETURN
	CAIN	T2,NUMTAB+23	;WANTS ADDRESS OF NUMTAB ITSELF?
	SKIPA	T1,[NUMTAB]	;RETURN ADDRESS OF NUMTAB TO HIM.
	MOVE	T1,(T2)		;GET THE DATA
	UMOVEM	T1,(M)
	JRST	CPOPJ1		;AND RETURN.
;GETTAB UUO
;UUO TO RETURN CONTENTS OF A MONITOR JOB TABLE ENTRY
;CALL:	HRROI AC, MONITOR JOB TABLE NUMBER
;	HRLI AC, JOB NUMBER (OPTIONAL) LH .LT. 0 MEANS CURRENT JOB
;	CALL AC, [SIXBIT /GETTAB/] OR CALLI AC,41
;	  ERROR RETURN (AC PRESERVED) IF BAD TABLE OR INDEX, NOT PRIVILEGED
;	NORMAL RETURN - AC CONTAINS VALID DATA
	EXTERN TTYTAB,JOBMXL,JBTMXL,STSTBL,STSMXL
	EXTERNAL GETLOG,TIMADJ,JBTCMP,JBTCPU,JBTBCS,JBTFPN
	EXTERNAL JBTCNK,JBTELP,JBTCOT,JBTCIN,JBTSOT,JBTSIN
	EXTERNAL JBTBET,JBTBIO
	EXTERNAL JBTSER,JBTSLK,JBTDLK,LINJOB,JBTERN
NOMXL==777000			;DEFINED TO FOOL OLD NUMTAB WATCHERS

GETTAB:	HLRZ J,T1		;GET USER SUPPLIED JOB NUMBER
	CAIN J,-1		;DID HE SUPPLY ONE?
	MOVE J, JOB		;NO, USE CURRENT JOB NUMBER
GETTB1:	HRRE T2,T1		;IN CASE NEGATIVE
	ADDI T2,NUMTAB
	CAIGE T2,ENDGTB
	CAIGE T2,MINTAB	;IS IT IN RANGE
	POPJ P,		;YES. ERROR RETURN, AC UNCHANGED
	LDB T2,[POINT 9,NUMTAB(T1),8]	;MAX LEGAL ARG.
	CAIN T2,NOMXL_-^D9	;IF SPECIAL CODE (777) THEN
	JRST	GETTB2		;NO BOUNDS CHECK, SOMEONE ELSE WILL DO IT.
	CAMLE J,T2		;DOES HIS ARG EXCEED LEGAL ONE?
	POPJ P,0		;YES. ERROR RETURN
GETTB2:	LDB T2,[POINT 4,NUMTAB(T1),12]	;GET ACTION TYPE
	XCT WAYTAB(T2)	;DO IT
FINTAB:	MOVE T1,@NUMTAB(T1)	;GET CONTENTS OF MONITOR TABLE
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

;THE MONITOR JOB TABLE NUMBERS:
        INTERN NUMTAB
	EXTERN JBTNAM,NSWTBL,CNFTBL,NSWMXL,CNFMXL,JBTCP2
	EXTERNAL JBTLIM,GETLPS,GETMOD,JBTBET,JBTBIO
	EXTERN JBTMPC,JBTPWS,JBTPWH,JBTPWL
	EXTERN ODPMXL,ODPTBL,LVDMXL,LVDTBL,JBTWCT,JBTRCT
	EXTERN SWPTBL,SWPMXL
	EXTERN JBTKCT,JBTFTR,JBTUID,JBTPNO
MINTAB:
	XWD NOMXL+WAYRPI,JBTINA(J)	;(-55)INACTIVITY TIMEOUT
	XWD NOMXL+WAYRFI,JBTFTR(J)	;(-54)PARENT, BROTHER, CHILD
	XWD NOMXL+WAYRFI,JBTUID(J)	;(-53)UNIVERSAL ID NUMBER FOR FRAME
	XWD NOMXL+WAYRPI,JBTPNO(J)	;(-52)PROGRAM NUMBER FOR FRAME
	XWD NOMXL+WAYACJ,PWSGET		;(-51)DP PGS TO WS*SIZE.
	XWD NOMXL+WAYRAD,JBTPWS(J)	;(-50) NO. PAGES TO UWS.
	XWD NOMXL+WAYRAD,JBTMPC(J)	;(-47) NO. PAGES MAPPED.
	XWD NOMXL+WAYACJ,MCYGET		;(-46)GET D.P. MICROCYCLES
	XWD NOMXL+WAYACJ,KCTGET		;(-45)GET D.P. KILO-CORE-TICKS
	XWD NOMXL+WAYACJ,TRUGET		;(-44)GET D.P. TRU TO AC,AC+1
	XWD NOMXL+WAYACJ,TRUGN2		;(-43) HIGH PART OF TRU
	XWD NOMXL+WAYTAJ,JBTCP2(J)	;(-42) HIGH PART OF MICRO-CYCLES
	XWD NOMXL+WAYRAD,JBTBIO(J)	;(-41) BIO CHAR CHARGE
	XWD NOMXL+WAYRAD,JBTBET(J)	;(-40) BIO TIME CHARGE
	XWD NOMXL+WAYRAD,JBTSOK(J)	;(-37) SOAKEM ARG
	XWD NOMXL+WAYJMP,GETLNK		;(-36) LINKED GETTAB
	XWD NOMXL+WAYRAD,[0]		;(-35) RMT CHR CHARGE
	XWD NOMXL+WAYRAD,[0]		;(-34) RMT TIME CHARGE
	XWD NOMXL+WAYRAD,JBTERN(J)	;(-33) ENTERS+RENAMES
	XWD NOMXL+WAYJMP,GETLPS		;(-32) GET TTY LINE POS
	XWD NOMXL+WAYJMP,GETMOD		;(-31) GET TTY MODE
	XWD NOMXL+WAYRDS,JBTLIM(J)	;(-30) TIME LIMIT
	XWD NOMXL+WAYJLN,JOBLIN		;(-27) JOB TO LINE
	XWD NOMXL+WAYJMP,LINJOB		;(-26) LINE TO JOB
	XWD NOMXL+WAYRPI,JBTFPN(J)	;(-25) JBTFPN
	XWD NOMXL+WAYJMP,GETLOG		;(-24) LDBLOG BY U NUMBER
	XWD NOMXL+WAYRFI,JBTAUN(J)	;(-23) ACCOUNT USER NUM
	XWD NOMXL+WAYRUN,JBTUNM(J)	;(-22) FIRST PART OF USER NAME
	XWD NOMXL+WAYRUN,JBTUN1(J)	;(-21) SECOND PART
	XWD NOMXL+WAYRPI,JBTLIC(J)	;(-20) LICENSE (NEEDS READ PROCESS DATE TO PROTECT PROCESS LICENSE)
	XWD WAYJMP,CPOPJ		;(-17)
	XWD WAYJMP,CPOPJ		;(-16)
	XWD NOMXL+WAYTAJ,JBTCMP(J)	;(-15) CLOCK TIM
	XWD NOMXL+WAYTAJ,JBTCPU(J)	;(-14) HIGH PART OF KCT
	XWD NOMXL+WAYRAD,JBTBCS(J)	;(-13) BREAK CHRS*SIZE
	XWD NOMXL+WAYRAD,JBTCNK(J)	;(-12) CONNECT TIME
	XWD NOMXL+WAYRAD,JBTELP(J)	;(-11) ELAPSED TIME*SIZE
	XWD NOMXL+WAYRAD,JBTCOT(J)	;(-10) CHRS OUT
	XWD NOMXL+WAYRAD,JBTCIN(J)	;(-7) CHRS IN
	XWD NOMXL+WAYRAD,JBTSOT(J)	;(-6) DISK BLOCKS OUT*SIZE
	XWD NOMXL+WAYRAD,JBTSIN(J)	;(-5) DISK BLOCKS IN*SIZE
	XWD NOMXL+WAYRAD,JBTSER(J)	;(-4) ENTER+RENAME*SIZE
	XWD NOMXL+WAYRAD,JBTSLK(J)	;(-3) LOOKUPS*SIZE
	XWD NOMXL+WAYRAD,JBTDLK(J)	;(-2) LOOKUPS
	XWD WAYJMP,CPOPJ		;(-1)
NUMTAB:	XWD NOMXL+WAYRUN,JBTSTS(J)	;(0) - JOB STATUS BITS
	XWD JBTMXL+WAYRPI,[0]		;(1) - JOB SIZE -1 AND PAGE NO. OF UPT FORMERLY,
					; NOW RETURN 0 FOR CHKPNT.

	XWD NOMXL+WAYRFI,JBTPPN(J)	;(2) - PROJECT,PROGRAMMER NUMBER
	XWD NOMXL+WAYRPI,JBTNAM(J)	;(3) - PROGRAM BEING RUN
	XWD NOMXL+WAYACJ,TRUGN		;(4) - TRU'S
	XWD NOMXL+WAYTAJ,JBTKCT(J)	;(5) - KILO-CORE TICKS(JIFFIES*SIZE IN J)

	XWD NOMXL+WAYRPI,JBTPRV(J)	;(6) - PRIVILEGE BITS SET BY LOGIN
	XWD NOMXL+WAYJMP,SIMJSW		;(7) - FAKE JBTSWP, TEMPORARY TILL SYSTAT FIXED.
	XWD NOMXL+WAYRDS,TTYTAB(J)	;(10) - TTY TRANSLATOR TABLE (DDB ADDRESS)
	XWD CNFMXL,CNFTBL(J)		;(11) - CONFIGURATION DATA
	XWD NSWMXL+WAYSYS,NSWTBL(J)	;(12) - NON-SWAPPING DATA
	XWD SWPMXL+WAYSYS,SWPTBL(J)	;(13) - SWAPPER DATA

	XWD WAYJMP,CPOPJ		;(14) - OBSOLETE (OLD HISEG NUMBER)
					;LH=J+NOMXL IF REENTRANT SOFTWARE
					;LH=0+NOMXL, SO ALL ENTRIES RETURN 0
					; IF NON-REENTRANT SOFTWARE
	XWD ODPMXL+WAYSYS,ODPTBL(J)	;(15) - ONCE ONLY DISK PARAMETERS
	XWD LVDMXL,LVDTBL(J)		;(16)- LEVEL D DISK PARAMS
	XWD NOMXL+WAYRAD,JBTRCT(J)	;(17) - DISK BLOCKS READ BY JOB
	XWD NOMXL+WAYRAD,JBTWCT(J)	;(20) - DISK BLOCKS WRITTEN BY JOB
	XWD WAYJMP,CPOPJ		;(21) - ACC. DSK-BLOCK-SECONDS ALLOCATED BY JOB
	XWD WAYJMP,CPOPJ		;(22) - TIME OF DAY DSK BLOCKS LAST ALLOCATED+TOTAL BLOCKS ALLOCATED
	XWD NOMXL+WAYJMP,DONUMT		;(23) - THE GETTAB ADDRESSES THEMSELVES (GETTAB IMMEDIATE)
	XWD WAYJMP,CPOPJ		;(24) - OBSOLETE (OLD DEVICE NAME FOR HISEGS)
					; OF SHARABLE HIGH SEG
	XWD STSMXL,STSTBL(J)		;(25) - SIXBIT NAMES FOR JOB QUEUE CODES
	XWD WAYJMP,CPOPJ		;(26) - RESERVED FOR REMOTE COMMUNICATIONS
	XWD WAYJMP,CPOPJ		;(27) - PHYSICAL CORE ALLOCATION TABLE
ENDGTB==.
GTTBLN==.-NUMTAB			;LENGTH OF TABLE
;M TO SET CURRENT PROGRAM NAME
;	MOVE AC,[SIXBIT /NAME/]
;	ALWAYS RETURN
SETNAM:
	MOVEM T1,JBTNAM(J)	;STORE PROGRAM NAME FOR SYSTAT AND SYSDPY
	SETZM JBTFPN(J)	;ZERO THIS OUT FOR CHAIN FROM LOADER
	MOVEI T1,3
	JRST ACTWRT		;WRITE TYPE 3 ACCOUNTING RECORD AND RETURN

TRUGN:	PUSHJ P,TIMADJ		;READ CLOCK AND UPDATE COUNTS
	PUSHJ P,CHKSEG
	 POPJ P,		;CAN NOT GIVE HIM THIS INFO
	PUSHJ P,CLKTRU		;CALCULATE TRU'S
	UMOVEM T1,(M)		;MOVE T1 TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

	INTERNAL CLKTRU,CHKSEG,CHKSGJ

TRUGN2:	PUSHJ P,TIMADJ
	PUSHJ P,CHKSEG
	 POPJ P,		;JUST LIKE ABOVE
	PUSHJ P,CLKTRU
	UMOVEM T2,(M)		;BUT STORE HIGH PART
	JRST CPOPJ1

;-THREE GETTABS WHICH RETURN DOUBLE-PRECISION QUANTITY
;	IN AC,AC+1 (NO WRAPAROUND).

TRUGET:	PUSHJ P,TIMADJ
	PUSHJ P,CHKSEG
	 POPJ P,	;JUST LIKE ABOVE
	PUSHJ P,CLKTRU
	UMOVEM T1,1(M)	;LOW ORDER TO AC+1
	UMOVEM T2,(M)	;HI TO AC
	JRST CPOPJ1
KCTGET:	PUSHJ P,TIMADJ
	PUSHJ P,CHKSEG
	 POPJ P,
	MOVE T1,JBTCPU(J)
	UMOVEM T1,(M)
	MOVE T1,JBTKCT(J)
	UMOVEM T1,1(M)
	JRST CPOPJ1
MCYGET:	PUSHJ P,TIMADJ
	PUSHJ P,CHKSEG
	 POPJ P,
	MOVE T1,JBTCP2(J)
	UMOVEM T1,(M)
	MOVE T1,JBTCMP(J)
	UMOVEM T1,1(M)
	JRST CPOPJ1

;ROUTINE TO RETURN JBTPWH/JBTPWL.
PWSGET:	PUSHJ	P,CHKSEG
	POPJ	P,
	MOVE	T1,JBTPWH(J)
	UMOVEM	T1,(M)
	MOVE	T1,JBTPWL(J)
	UMOVEM	T1,1(M)
	JRST	CPOPJ1

;TEMPORARY ROUTINE TO FAKE UP IMGIN AND IMGOUT IN JBTSWP

SIMJSW:	CAILE	J,JOBMAX	;IN RANGE?
	POPJ	P,		;NO, FORGET IT.
	HLRZ	T1,JBTUPM(J)	;GET NUMBER OF EXISTENT PAGES
	MOVE	T2,T1		;COPY INTO T2
	LSH	T1,^D9		;SHIFT IT INTO OTHER PLACE
	IOR	T1,T2		;GET INTO BOTH IMGIN AND IMGOUT
	UMOVEM	T1,(M)		;STORE RETURN VALUE
	JRST	CPOPJ1		;AND RETURN.
	DEFINE SINGL1 (MULT,QUANT,%%X,%%Y)
<IFG %%X+%%Y-5,<%%Z==1
	REPEAT %%X+%%Y-5,<%%Z==%%Z*^D10>
	PUSH P,T2
	OPSET (IDIV,T1,%%Z)
	EXCH T1,(P)
	EXCH T1,T2
	OPSET (DIV,T1,%%Z)
	MOVE T2,T1
	POP P,T1>
	ADD T2,-1(P)
	TLZE T2,(1B0)
	ADDI T1,1
	MOVEM T2,-1(P)
	ADDM T1,(P)
>

	DEFINE OPSET (OP,AC,ARG)
<IFG ARG-777777,<OP AC,[ARG]>
IFLE ARG-777777,<OP'I AC,ARG>
>

	DEFINE SINGLE (MULT,QUANT)
<%%X==0
%%Y==0
IRPC MULT,<%%X==%%X+1>
IRPC QUANT,<%%Y==%%Y+1>
%%Z==1
REPEAT 5-%%X-%%Y,<%%Z==%%Z*^D10>
	OPSET(MUL,T1,^D'MULT*%%Z)
	SINGL1(MULT,QUANT,%%X,%%Y)
>
	DEFINE SINGLL(VAL,MULT,QUANT)
<	MOVE T1,JBT'VAL(J)
	SINGLE(MULT,QUANT)>

	DEFINE DOUBLE(VAL1,VAL2,MULT,QUANT)
<	MOVE T1,JBT'VAL1(J)
	MOVE T2,JBT'VAL2(J)
	OPSET(IMUL,T1,^D'MULT)
	PUSH P,T1
	MOVE T1,T2
	OPSET(MUL,T1,^D'MULT)
	ADDM T1,(P)
	POP P,T1
%%X==0
%%Y==0
IRPC MULT,<%%X==%%X+1>
IRPC QUANT,<%%Y==%%Y+1>
	SINGL1(MULT,QUANT,%%X,%%Y)
>
COMMENT !  CLKTRU: CALCULATE DOUBLE-PRECISION TRU'S &
	RETURN IN T1 (LOW), T2 (HI).

	IN THE MACRO CALLS 'DOUBLE', 'SINGLE', & 'SINGLL'
	THE CONSTANTS HAVE THESE MEANINGS:
  DOUBLE(V1,V2,RATE,QUANT)..THE D.P. ENTITY (V1,V2) CHARGES AT
  0.RATE TRU'S PER QUANTITY OF ENTITY..IE, 0.03371 TRU'S
   PER 100,000 [MICROCYCLES*SIZE]
 SINGLL(V,RATE,QUANT)..  0.RATE TRU'S PER QUANT OF V
 SINGLE(RATE,QUANT)..  0.RATE TRU'S PER QUANT OF ITEM IN T1

WHEN CHANGING THIS ALGORITHM, PLEASE CHANGE (MONDOC)TRUFRM.DOC
AND THE FORTRAN COST CALCULATION PROGRAM APPROPRIATELY, AND
SEND OUT A MEMO TO THE PEOPLE WHO NEED TO KNOW ABOUT THE CHANGE.
!
EXTERNAL JBSRCT,JBRIRD,JBYSC1,JBYSC2

	SALL
CLKTRU:	PUSH P,[0]		;Double precision running total
	PUSH P,[0]		; is accumulated on top of PDL

;; First, compute the size-independent components.

	DOUBLE (CP2,CMP,9004,100000) ;Double-precision micro-cycles
	SINGLL(SOK,001,1)	;SOAKEM UUO charges

	MOVE T1,JBTCOT(J)	;Characters out
	ADD T1,JBTCIN(J)	;Characters in
	SINGLE(856,1000)

	SINGLL(BET,004,1)	;Elapsed time in block i/o mode
	SINGLL(BIO,4,1000)	;Block i/o characters in+out
	SINGLL(MPC,000168,1)	;ONE-TENTH DISK READ FOR MAP.
	SINGLL(PWS,02696,1)	;# pages put into UWS

	MOVE T1,JBTERN(J)	;Enters + renames
	LSH T1,2
	ADD T1,JBTDLK(J)	;Lookups
	IMULI T1,3
	MOVE T2,JBTRCT(J)	;Disk blocks read
	ADD T2,JBTWCT(J)	;Disk blocks written
	SKIPE J		;NOT FOR JOB 0
	TLZ T2,JBRIRD_<JBSRCT-^D18> ;ONLY LOW ORDER 24 BITS
	ADD T1,T2
	SINGLE (00674,1)

;; Before performing the kilocore-dependent calculations, see if
;; a kilocore-independent scale factor should be applied (from the
;; XCHARG TRU-scaling call) - any size-dependent TRU scaling is
;; done by adjusting the charging size in GTCGSZ.

	LDB	T2,JBYSC1	;Is there a scale factor numerator?
	JUMPE	T2,CLKTRX	;Jump around code if not
	IMULM	T2,0(P)		;First, multiply high-order word
	MOVE	T1,-1(P)	;Copy low-order word
	MUL	T1,T2		;D.P. result clobbers T2
	ADDM	T1,0(P)		;Sum up high-order partial products
	MOVEM	T2,-1(P)	;Save new low-order word

	LDB	T1,JBYSC2	;Get divisor
	EXCH	T1,0(P)		;Save divisor, get high-order product
	IDIV	T1,0(P)		;T1 gets quotient, t2 gets remainder
	EXCH	T1,T2		;T2  "      "    , T1  "       "
	EXCH	T2,-1(P)	;-1(P) gets high-order quotient, T2
				; gets low-order product
	DIV	T1,0(P)		;T1 gets (T1,,T2)/0(P)
	TLZE	T1,400000	;Correct for double precision
	AOS	-1(P)		;Carry into high-order word
	EXCH	T1,-1(P)	;Swap low-order quot. with high-order
	MOVEM	T1,0(P)		;Store high-order quotient

;; Now, calculate all the size-dependent components (i.e.,
;;   units*size.

CLKTRX:
	DOUBLE (CPU,KCT,03371,100000) ;D.P. microcycles*size
	DOUBLE (PWH,PWL,00154,10000) ;D.P. <pgs put in UWS>*size
	SINGLL(ELP,00016,1)	;<Elapsed time>*size
	SINGLL(BCS,00535,1)	;<Break chars seen>*size

	MOVE T1,JBTSER(J)	;<Enters + Renames>*size
	LSH T1,2
	ADD T1,JBTSLK(J)	;Lookups*size
	IMULI T1,3
	ADD T1,JBTSIN(J)	;<Disk blocks read>*size
	ADD T1,JBTSOT(J)	;<Disk blocks written>*size
	SINGLE(00077,1)
;; Calculation complete, get double-precision result from PDL
;;   into T1 and T2.

	POP P,T2
	POP P,T1
	POPJ P,		;ALL CALCULATED T1 IS LOW PART T2 HIGH
	XALL

JOBLIN:	PUSHJ P,CHKSEG		;CAN HE GET THIS INFO
	 POPJ P,		;NO
	HRRZ T1,TTYTAB(J)	;IS THERE ONE THERE??
	JUMPE T1,[UMOVEM T1,(M)	;STORE IN USER'S AREA.
		 POPJ P,]	;AND RETURN.
	MOVE T1,DEVNAM(T1)	;YES, GET NAME, (ELSE RET 0)
	UMOVEM T1,(M)		;MOVE TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

; GETLNK--FOR LINKED GETTAB. SCAN LIST STRUCTURE
;  & RETURN VALUES. USED FOR TEMP DEBUGGING TABLES
;  PUT IN MONITOR.  USED AS FOLLOWS:
;  MOVE AC,[EVEN'INDEX,,-36]
;  GETTAB AC,
;   OOPS
;  RETURN AC=SIXBIT TABLEE NAME.  DO  I WANT THIS TABLE?
;  NO..EVEN'INDEX:=EVEN'INDEX+2 & GETTAB AGAIN
;  YES..EVEN'INDEX:=EVEN'INDEX+1
;  GETTAB AC,
;   ..
;  RETURN AC=DATA FROM TABLE PREVIOUSLY NAMED

COMMENT !   DATA STRUCTURE:
1. A LINKED (IN RH) LIST OF 2-WD HEADER BLOCKS BEGINNING
  AT LNKHED, INITIALIZED BY LOADER.  LAST RH=0.  FORMAT OF 
  HEADER BLOCK:
2. HEADER: XWD COUNT,NEXT'HEADER  (COUNT IS SIZE OF NAME & VALUE TABLES)
	XWD NAME'TABLE,VALUE'TABLE
3. FORMAT OF NAME'TABLE:
	NAME'TABLE: SIXBIT /NAME/	(I.E., /JBTXXX/, ETC.)
	SIXBIT /NAME/
	..
	.. (TOTAL OF COUNT ENTRIES)
4. FORMAT OF VALUE TABLE ANALAGOUS
!
GETLNK:	MOVSI T1,LICSYS
	MOVE T2,JOB
	TDNN T1,JBTLIC(T2)
	POPJ P,		;NEED SYSTAT LIC
	HRRZ T2,LNKHED	;GET POINTER TO LIST
LNKLP:	JUMPE T2,CPOPJ	;COUNT TOO BIG, NON-SKIP RETURN
	HLRZ T1,(T2)	;GET COUNT
	LSH T1,1	;*2 FOR NAMES
	CAMGE J,T1
	JRST LNKFND	;THIS IS THE RIGHT PLACE
	SUB J,T1	;DECREASE DESIRED COUNT
	HRRZ T2,(T2)
	JRST LNKLP	;AND CONTINUE

LNKFND:	ROT J,-1		;DIVIDE BY 2 AND REM TO HIGH BIT
	SKIPL J		;SEE IF EVEN OR ODD
	SKIPA T1,1(T2)	;EVEN, NAME POINTER
	HLRZ T1,1(T2)	;ODD, DATA POINTER
	ADD T1,J
	MOVE T1,(T1)
	UMOVEM T1,(M)		;INFO TO USER'S AREA.
	JRST CPOPJ1		;AND SKIP RETURN.

LNKHED:	0
	.ELINK 1,LNKHED	;SET UP LINK
SUBTTL XCHARG

EXTERNAL SAVCHG,CHGSIZ,UPTCHG

COMMENT ! XCHARG UUO SEVERAL FUNCTIONS

CALL:	MOVE AC,[-COUNT,,ADDR]
	XCHARG AC,
	 ERROR RTN, AC/CODE FUNCTIONS 4 OR 5 ONLY
	OK RTN, AC/UNCHANGED
LOC:	FUNCTION NUMBER
	BITMASK,SOME FUNCTIONS
	TABLE SPACE
	.	.
	.	.
LICENSE: SOME FUNCTIONS REQUIRE XC LICENSE

DESTROYS: PRACTICALLY ALL AC'S

!




XCHARG:	UMOVE T2,(T1)	;CODE
	SKIPL T2
	CAIL T2,XCHFUN	;SEE IF IN RANGE
	POPJ P,
	PUSHJ P,TIMADJ		;UPDATE CLOCK CHARGES BEFORE
				;ANY READ,RESET,ETC.
	XCT XCHFNT(T2)

XCHFNT:	JRST XCHSAV	;SAVE (0)
	JRST XCHRED	;READ SAVED (1)
	JRST XCHCRD	;READ CURRENT (2)
	JRST CPOPJ	;NO-OP. WAS RESET CHARGES (3) JRST XCHRST
	JRST XCHF4	;RESET & SAVE CHARGES (4). USE USER DATA
	JRST XCHF5	;FN 5,TRANSACTION CHARGE RECORD
	JRST XCHF6	;FN 6 TRU COMPONENT CHECKPOINT RECORD
	JRST XCHSCA	;FN 7, TRU Scaling
XCHFUN==.-XCHFNT

XCHCTB:	400000,,JBTCPU(J)	;SIGN BIT SEZ "WORD 1 OF D.P. VALUE".
	JBTKCT(J)
	400000,,JBTCP2(J)	;MICROCYCLES NOW D.P. P031
	JBTCMP(J)
	JBTELP(J)
	JBTBCS(J)
	JBTCIN(J)
	JBTCOT(J)
	JBTBET(J)
	JBTBIO(J)
	JBTSER(J)
	JBTSLK(J)
	JBTSIN(J)
	JBTSOT(J)
	JBTERN(J)
	JBTDLK(J)
	JBTRCT(J)
	JBTWCT(J)
	JBTMPC(J)
	JBTPWS(J)
	400000,,JBTPWH(J)
	JBTPWL(J)

XCHFLN==.-XCHCTB

XCHSAV:	MOVSI T1,-XCHFLN	;NUMBER OF SOURCES
	MOVSI T2,-CHGSIZ	;NUMBER OF SAVES
	MOVSI T3,SAVCHG
	IORM T3,%UPT+UPTSTS	;SAVE IN STATUS WORD
XCHSV1:	MOVE T3,@XCHCTB(T1)
	MOVEM T3,%UPT+UPTCHG(T2)
	AOBJP T2,CPOPJ1
	AOBJN T1,XCHSV1
	JRST CPOPJ1		;DON'T OVERRUN EITHER

XCHRED:	AOBJP T1,CPOPJ		;NUMBER REQUESTED
	UMOVE T2,(T1)
	MOVSI T3,-XCHFLN
	MOVSI T4,SAVCHG
	TDNN T4,%UPT+UPTSTS
	POPJ P,		;NOTHING SAVED
XCHRD1:	TLNN T2,(1B0)
	JRST XCHRD2
	MOVE T4,%UPT+UPTCHG(T3)
	AOBJP T1,CPOPJ1
	UMOVEM T4,(T1)
XCHRD2:	LSH T2,1
	JUMPE T2,CPOPJ1
	AOBJN T3,XCHRD1
	JRST CPOPJ1
XCHCRD:	AOBJP T1,CPOPJ	;GET BITS
	UMOVE T2,(T1)
	MOVSI T3,-XCHFLN
XCHCR1:	TLNN T2,(1B0)
	JRST XCHCR2
	MOVE T4,@XCHCTB(T3)
	AOBJP T1,CPOPJ1
	UMOVEM T4,(T1)
XCHCR2:	LSH T2,1
	JUMPE T2,CPOPJ1
	AOBJN T3,XCHCR1
	JRST CPOPJ1

COMMENT ! ;-CHANGE SEPT 76 A.ATKINSON TO WRITE STREAM
XCHRST:	MOVSI T2,LICXC		;CAN HE DO IT
	TDNN T2,JBTLIC(J)
	POPJ P,		;NO
	AOBJP T1,CPOPJ	;NO BITS
	UMOVE T2,(T1)
	MOVSI T3,SAVCHG
	TDNN T3,%UPT+UPTSTS
	POPJ P,		;CHARGES NOT SAVE SINCE LAST RESET
	AOBJP T1,XCHRS0
	UMOVE T3,(T1)	;GET SAOK CHARGE
	MOVE T1,T3	;GET A COPY
	ADD T3,JBTSOK(J)
	JUMPLE T3,XCHRS0
	MOVEM T3,JBTSOK(J)
	ADDM T1,JBTSOK
XCHRS0:	MOVSI T1,-CHGSIZ
	MOVSI T3,-XCHFLN
	TLNE T2,(3B1)
	TLO T2,(3B1)	;THESE MUST BOTH BE TOGETHER (DOUBLE PRECISION WORDS)
XCHRS1:	TLNN T2,(1B0)
	JRST XCHRS2
	MOVE T4,%UPT+UPTCHG(T1)
	MOVEM T4,@XCHCTB(T3)
XCHRS2:	AOBJP T3,CPOPJ1
	AOBJP T1,CPOPJ1
	LSH T2,1
	JUMPN T2,XCHRS1
	JRST CPOPJ1
;-NOW FOLLOWS CODE TO DO ABOVE FUNCTION PLUS WRITE ACT REC
!
REPEAT 0,<	;REMOVE THIS FUNCTION. AAA 15 NOV
XCHRST:	MOVSI T2,LICXC
	TDNN T2,JBTLIC(J)
	POPJ P,
	AOBJP T1,CPOPJ
	UMOVE P2,(T1)	;-P2:=USER BITMASK
	MOVSI T3,SAVCHG
	TDNN T3,%UPT+UPTSTS
	POPJ P,		;-DIDNT SAV CHGS
	AOSE ACREQ	;-IF ANYONE WAITING ON ACT DEVICE,
	PUSHJ P,ACWAIT	;-WE WAIT TOO
	PUSH P,T1	;-SAV FOR XCHRS0
	MOVEI P1,XCHARL	;SIZE REC WE'D LIKE TO WRITE
	PUSHJ P,BACTJB	;-MAY WE WRITE ACT?
	 JRST [SETO U,	;-NO. U:=FLAG NO ACT & GO
		JRST XCHRS0];-DO THE UUO WITHOUT ACT RECORD
	 JRST [JFCL ACREQ	;-CANT WRITE AT THE MOMENT,
		PUSHJ P,ACWAIT	;-WAIT TIL BUFF EMPTIED BY
		JRST .+1]	;-ACT OWNER, THEN CONTINUE
;-DOUBLE SKIP RTN, CAN WRITE IMMEDIATELY.
	SETZ U,		;-U:=FLAG "YES", DO UUO WITH ACT RECORD
XCHRS0:	POP P,T1	;-USER ARG PTR
	AOBJP T1,XCHRS1	;-GO AHEAD IF NO SOAKEM VALUE
	UMOVE T3,(T1)	;-SOAKEM VALUE TO
	ADD T3,JBTSOK(J);-ADD TO SOAKEM
	JUMPLE T3,XCHRS1
	MOVEM T3,JBTSOK(J)
	UMOVE T3,(T1)
	ADDM T3,JBTSOK
;-WRITE 4-WD HEADER PART OF ACT RECORD
XCHRS1:	JUMPL U,XCHRS2	;U=-1 IF NOT DOING ACT REC
	PUSHJ P,CBLAMB	;-T1:=LENGTH,T2:=LOC OF BUFFER SPACE
	MOVEI T3,XCHTAR	;-XCHARG REC TYPE
	MOVEI T4,XCHARL;-&LENGTH
	PUSHJ P,WACRHW	;-WRITE  HEADER WORDS,RETURN T1,T2
			;-FOR MORE WRITING IN ACTBUF
	MOVE T3,JBTNAM(J);-WHO IS GIVING AWAY TRU'S?
	PUSHJ P,PUTBUF	;-RECORD IT
	MOVE T3,JBTFPN(J)
	PUSHJ P,PUTBUF
	MOVE T3,JBTSOK(J)
	PUSHJ P,PUTBUF
XCHRS2:	MOVSI P1,-CHGSIZ	;-SET UP LOOP CONTROL
	MOVSI P3,-XCHFLN

;-IN THE FOLLOWING CODE, REGISTER ASSIGNMENTS ARE:
;-P1: AOBJN INDEX IN UPT ARRAY
;-P3: AOBJN INDEX IN XCHCBT ARRAY
;-T1: LENGTH OF REMAINING ACTBUF AREA, AS RET'D BY CBLAMB
;-T2: LOC OF THIS BLOCK,
;-T3: DATA VALUE PASSED TO PUTBUF TO STORE IN ACTBUF
;-T4: SECOND HALF OF DOUBLE-PREC. VALUES, FIRST IN T3.
;-U: FLAG -1 IF NO ACT WRITE,0 IF YES
;-P2: USER'S BITMASK OF VALUES TO BE RESET

;-IF BITMASK VALUE IS 0 (RESET NOT DESIRED FOR THIS COMPONENT)
;-THEN JBT'S ARE RESET WITH THEMSELVES & 0 WRITTEN TO ACTBUF.

XCHRS3:	SKIPG XCHCTB(P3)	;SKIP IF SINGLE-PRECISION COMPONENT
	JRST XCHRSD		;DOUBLE
	TLNN P2,(1B0)
	SKIPA T4,@XCHCTB(P3)	;FORCE DIFF=0 & NO RESET
	MOVE T4,%UPT+UPTCHG(P1)
	MOVE T3,@XCHCTB(P3)
	SUB T3,T4
	SKIPL U		;ACT WRITE WANTED?
	PUSHJ P,PUTBUF	;YES.T3=DIFF OR ZERO TO ACTBUF
	MOVEM T4,@XCHCTB(P3);RESET OR RESTORE JBT

;-LOOP TEST
XCHRLT:	AOBJP P1,XCHRFA	;FINISH ACTBUF IF UPT DONE
	LSH P2,1	;NEXT BIT IN USER MASK
	AOBJN P3,XCHRS3	;LOOP WHILE XCHCTB VALUES REMAIN,THEN FALL THRU
;-FINISH ACT
XCHRFA:	JUMPL U,CPOPJ1	;-IF NO ACT,DONE SKIP RTN
	SETZ T3,	;-0 TO FINISH OUT XCHARG RECORD
;-WHILE P3=XCHFLN INDEX NOT FINISHED,WRITE ZEROS TO
;-COMPLETE XCHARL- WORD RECORD
;-WHEN DONE, FINACB IN ACTSER CLEAN UP & UNINTERLOCK
XCHRF2:	AOBJP P3,FINACB
	PUSHJ P,PUTBUF	;PUT 0
	JRST XCHRF2

;-XCHRSD..DOUBLE PRECISION ROUTINE. VALUES D.P. IN XCHCTB
;-HAVE 1ST WORD FLAGGED IN XCHCBT SIGN BIT.

XCHRSD:	TLNN P2,(3B0)	;SKIP IF EITHER OF 2 WDS OF DP IS TO BE RESET
	 JRST [PUSH P,@XCHCTB(P3);PUT CURRENT VALUE INTO
		PUSH P,@XCHCTB+1(P3);-1(P) HIGH,(P) LOW ORDER,
		JRST .+3	]	;FORCE DIFF=0 & NO UPDATE
	PUSH P,%UPT+UPTCHG(P1)
	PUSH P,%UPT+UPTCHG+1(P1)	;SAVED INTO -1(P),(P)
	MOVE T3,@XCHCTB(P3)
	MOVE T4,@XCHCTB+1(P3)
	SUB T4,(P)	;LOW ORDER-LOW
	SUB T3,-1(P)	;HI - HI
	TLZE T4,(1B0)	;TEST/RESET CARRY,SKIP IF NONE
	SUBI T3,1
;NOW T3/T4=D.P. DIFFERENCE (OR ZERO IF P2&3B0=0), -1(P)/(P)=
;RESET/RESTORE VALUE
	JUMPL U,.+4	;WANT ACT WRITE,JUMP IF NO
	PUSHJ P,PUTBUF	;HI ORDER TO ACTBUF
	MOVEM T4,(T2)	;LOW ORDER TO BUF
	PUSHJ P,MORBUF	;ADVANCE PTR ONE
	POP P,@XCHCTB+1(P3);RESET/RESTORE LOW ORDER TO JBT'S
	POP P,@XCHCTB(P3)	;HI ORDER
;ADVANCE P1 P2 P3 ONE TO ACCOUNT FOR 2ND WORD OF DP PAIR
	AOBJP P1,.+1
	AOBJP P3,.+1
	LSH P2,1
	JRST XCHRLT	;NOW PERFORM LOOP TEST
>;END REPEAT 0 TO REMOVE XCHRST FN 3
;XCHF4..RESET CHARGES, USING VALUES FROM USER. PERFORM
;	SIMULTANEOUS SAVE OF NEW VALUES (IMPLICIT FN 0).
;	REQUIRE THAT CURRENT.GE. USER .GE. SAVED  FOR
;	EVERY COMPONENT TOUCHED. IF THIS IS UNTRUE, NO
;	CHANGE TO CURRENT OR SAVED FOR THAT COMPONENT.

;-EXTERNALS FROM ACTSER & SCHEDULER
EXTERNAL GETABS,FINACB,PUTBUF,MORBUF,WACRHW
XCHARL==XCHFLN+^D8	;XCHARG REC LENG=
;	5 HEADER WRDS
;	1 JBTNAM
;	1 JBTFPN
;	1 JBTSOK
;  XCHFLN  DIFFERENCES


INTERNAL XCHARL ;REF'D IN ACTSER CODE
XCHTAR==10		;XCHARG ACT REC TYPE

;ERROR RETURNS.
XCF4NL: JSP P4,XC4FR	;NO LIC (0)
XCF4NS:! JSP P4,XC4FR	;NO PREVIOUS SAVE (1)
XCF4NA:! JSP P4,XC4FR	;NO ACCT'G (2) .. SYS UP FOR FREE
XCF4BC:!		;BAD COMPONENT (3) HANDLED SPECIALLY
XCF7BC:! JSP P4,XC4FR	;Except for fn 7
XCF4BA:! JSP P4,XC4FR	;BAD AC (4)
XCF4BB:! JSP P4,XC4FR	;BAD BITMASK (5)
XC4FR:!	SUBI P4,XCF4NL+1
	XCTBU <HRRZM P4,(M)>;MOVE ERR CODE RH P4 TO USER AC
	POPJ P,

UBMASK:	Z	;USERS BITMASK
XCBADC: Z	;FOR SAVE BAD COMPONENT BIT POSITIONS FOUND

DEFINE CURRENT(OFFSET<0>)<@XCHCTB+OFFSET(P3)>
DEFINE SAVVAL(OFFSET<0>)<%UPT+OFFSET+UPTCHG(P1)>
DEFINE HISAV <%UPT+UPTCHG(P1)>
DEFINE LOSAV <%UPT+UPTCHG+1(P1)>

;REGISTER ASSIGN IN LOOP WHICH DOES THE WORK:
; P4-TRAVELLING BIT FOR UBMASK TEST
; P3-XCHCTB AOBJN 
; P2-USER AOBJN
; P1-UPT AOBJN

;T1-CBLAMB/PUTBUF/MORBUF BLOCK SIZE
;T2-BLOCK ADDRESS WITHIN ACTBUF
;T3-
;T4-WORKING STORAGE. T3 IS ARG TO PUTBUF
;M- USER AC #
;U-DATA FOR DP COMPARE
;PG- DATEA FOR DP COMPARE

;NAMES OF REGISTERS FOR HELP IN UNDERSTANDING CODE. NOTE U,PG
HICUR==T3
LOCUR==T4
HIUSR==U
LOUSR==PG	;U,PG ARE NOT  CONSECUTIVE

;HERE WHEN A SINGLE PRECISION COMPONENT IS BAD
.XCBSP:	IORM P4,XCBADC	;RECORD WHICH COMPONENT WAS BAD
	SETZB HICUR,LOCUR
	JRST .XCACCT
;HERE IF BAD DP COMP
.XCBDP:	IORM P4,XCBADC
	SETZB HICUR,LOCUR
	JRST .XCDACCT

XCHF4:	MOVSI T2,LICXC
	TDNN T2,JBTLIC(J)
	JRST XCF4NL		;ERR RTN 0
	AOBJP T1,XCF4BA		;T1:= -(COUNT-1),,LOC+1
	HLRE T2,T1		;T2/-(COUNT-1)
	MOVNS T2
	ADDI T2,-1(T1)		;T2/ADDR LAST WD IN ARG BLK
	UMOVE T2,(T2)		;MAKE SURE CAN READ IT
	UMOVE T2,(T1)		;T2:=USER BITMASK
	HLRZ T3,T1		;BEGIN CHECKOUT COUNT,MASK
	CAIGE T3,-3	;T3=0,,7777XX E=0,,777775
	CAIG T3,-XCHFLN-2	;-(XCHFLN+1)<=COUNT<=-4
	JRST XCF4BA		;COUNT BAD
	MOVSI T4,(1B0)	
	ASH T4,(T3)
	ANDCA T4,T2
	JUMPN T4,XCF4BB		;YES IF T4#0
	MOVSI T3,SAVCHG		;CHECK IF PREVIOUS SAVE,
	TDNN T3,%UPT+UPTSTS	;XCHARG FN 0
	JRST XCF4NS		;NO,COMPLAIN
	PUSH P,T1		;USER AOBJN,SAVE FROM GETACB
	PUSH P,T2		;USER BITMASK, SAVE
	MOVEI P1,XCHARL		;LENGTH OF XCHARG RECORD
;MAY WE WRITE THE RECORD FOR THIS XCHARG
XCHBAJ:	PUSHJ P,GETABS		;GET SPACE IN ACT BUFFER
	  JRST [POP P,T2	;UNWIND
		POP P,T1
		JRST XCF4NA]	;STREAM DEAD, FRETURN
;NOW CAN WRITE
XCHF4A:	PUSHJ P,CBLAMB	;T1:=SIZE,T2:=LOC OF BLOCK IN ACTBUF
	MOVEI T3,XCHTAR	;REC TYPE
	MOVEI T4,XCHARL	;LENGTH
	PUSHJ P,WACRHW	;WRITE HEADER WDS
	MOVE T3,JBTNAM(J)
	PUSHJ P,PUTBUF
	MOVE T3,JBTFPN(J)
	PUSHJ P,PUTBUF
	MOVE T3,JBTSOK(J)
	PUSHJ P,PUTBUF
;PREPARE LOOP. RETREIVE USER AOBJN,BITMASK,SET MONITOR AOBJN'S
	POP P,UBMASK
	POP P,P2	;USER AOBJN,WAS IN T1 BEFORE
	AOBJP P2,.+1	;NOW P2 PTS AT 1ST COMPONENT
	SETZM XCBADC
	MOVSI P3,-XCHFLN
	MOVSI P1,-CHGSIZ
	MOVSI P4,(1B0)	;TRAVELLING BIT FOR MASK TESTS
;LOOP TOP
XCF4L0:	SKIPG XCHCTB(P3);SKIP IF SINGLE PRECISION
	JRST XCF4DP	;DOUBLE
	TDNE P4,UBMASK	;SKIP IF NO RESET DESIRED THIS COMP
	XCTFU <SKIPA LOUSR,(P2)>
	MOVE LOUSR,CURRENT
;LOUSR:=EITHER CURRENT OR USER
	MOVE T4,SAVVAL
	MOVE T3,CURRENT
	CAMG LOUSR,T3
	CAMGE LOUSR,T4
	JRST .XCBSP	;OUT OF RANGE,FLAG BAD COMP
	MOVEM LOUSR,CURRENT
	MOVEM LOUSR,SAVVAL
	SUB T3,LOUSR
.XCACCT:
	PUSHJ P,PUTBUF		;RECORD DIFFERENCE
;LOOP TEST,USED FOR BOTH S.P. AND D.P.
XCF4L1:	AOBJP P1,XCF4L2
	LSH P4,-1		;TRAVELLING BIT MOVES DOWN ONW
	AOBJP P2,XCF4L2
	AOBJN P3,XCF4L0		;NEXT COMPONENT
;LOOP END
;FINISH ACT RECORD WITH 0'S
XCF4L2:	SETZ T3,
	AOBJP P3,XCF4L3
	PUSHJ P,PUTBUF
	JRST XCF4L2
;CLEAN UP ACTBUF,RETURN FROM XCHARG UUO SKIP IF NO BAD COMP
XCF4L3:	PUSHJ P,FINACB	;UNINTERLOCK,FIX BUFF PTRS
	JFCL		;ALWAYS SKIPS, IGNORE
	SKIPN T1,XCBADC	;SEE IF BAD COMPONENTS HIT,FRETURN IF SO
	JRST CPOPJ1
	IORI T1,XCF4BC-XCF4NL;RETURN BITS 0-32=BITMASK, 33-35=CODE
	UMOVEM T1,(M)
	POPJ P,

;CODE FOR DOUBLE-PRECISION COMPONENTS
;	EXECUTED INSTEAD OF CODE BETWEEN XCF4L0+2,XCF4L2

XCF4DP:	TDNN P4,UBMASK
	JRST [MOVE HIUSR,CURRENT
		MOVE LOUSR,CURRENT(1)
		JRST .+3]
	UMOVE HIUSR,(P2)
	UMOVE LOUSR,1(P2)
	MOVE HICUR,CURRENT
	MOVE LOCUR,CURRENT(1)
;(HIUSR,LOUSR) NOW = USER VALUE OR CURRENT IF NO RESET DESIRED
;TEST IF CURRENT>=USER>=SAVED IS TRUE
	CAMN HIUSR,HICUR
	CAMG LOUSR,LOCUR
	CAMLE HIUSR,HICUR
	JRST .XCBDP	;BAD,USER>CURRENT
	CAMN HIUSR,HISAV
	CAML LOUSR,LOSAV
	CAMGE HIUSR,HISAV
	JRST .XCBDP	;BAD,USER<SAVED
	MOVEM HIUSR,SAVVAL
	MOVEM LOUSR,SAVVAL(1)
	MOVEM HIUSR,CURRENT
	MOVEM LOUSR,CURRENT(1)
	SUB LOCUR,LOUSR
	SUB HICUR,HIUSR
	TLZE LOCUR,(1B0)
	SUBI HICUR,1
.XCDACCT:
	PUSHJ P,PUTBUF	;SAVE HI-ORDER DIFF
	MOVEM LOCUR,(T2)	;AND LOW
	PUSHJ P,MORBUF		;ADVANCE T1,T2
	LSH P4,-1		;ADVANCE BIT & ALL AOBJN'S
	AOBJP P1,.+1
	AOBJP P2,.+1		;TO ACCOUNT FOR EXTRA
	AOBJP P3,XCF4L1		;WORD ALREADY PROCESSED
	JRST XCF4L1
;XCHARG FUNCTION 5 -- TRANSACTION RECORD OUTPUT

TRNTAR==:17	;TRANSACTION RECORD TYPE NUMBER SEE ACTSER
TRNARL==:36	;TRANS. ACCTG REC LENGTH
TRNNHW==10	;TRANS. NUMBER HEADER WORDS

XCF5NL==XCF4NL	;NO LICENSE ERROR
XCF5BA==XCF4BA	;BAD AC ERROR
XCF5NA==XCF4NA	;NO ACCOUNTING ERROR

XCHF5:	;EXPECTING T1/USER -COUNT,,ADDR
	MOVSI T2,LICXC
	TDNN T2,JBTLIC(J)
	JRST XCF5NL	;NO LICENSE
	HLRE T2,T1
	CAMLE T2,[-2]
	JRST XCF5BA	;MINIMUM 2 (FUNCTION NO, 1 WORD DATA)
	PUSH P,T1	;SAVE USER AOBJN
	MOVEI P1,TRNARL	;GET TRNARL WORDS IN ACCTG DEVICE
	PUSHJ P,GETABS	;AND RETURN F/ACTDDB SKIPPING IF CAN
	 JRST [	POP P,T1;USER AOBJN. NO ACCTG ACTIVE
		JRST XCF5NA]	;GIVE ERROR CODE
;NOW HAVE ACT DEVICE LOCKED DOWN
	PUSHJ P,CBLAMB	;GET T2/LOC T1/COUNT OF ACTBUF BLOCK
	MOVEI T3,TRNTAR
	MOVEI T4,TRNARL
	PUSHJ P,WACRHW	;WRITE ACT HEADER WORDS:HDR,DATE,ETC.
	MOVE T3,JBTNAM(J)
	PUSHJ P,PUTBUF	;DEPOSIT T3 ACCORDING TO T2,T1
	MOVE T3,JBTFPN(J)
	PUSHJ P,PUTBUF
	MOVE T3,JBTSOK(J)
	PUSHJ P,PUTBUF
	POP P,P2	;USER AOBJN
	MOVEI P1,TRNARL-TRNNHW
;P1/MONITOR COUNTER, ITEMS LEFT TO GO IN RECORD
;P2/USER POINTER, AFTER AOBJN PTS AT DATA TO LOAD NEXT
;T2/LOC FOR PUTBUF TO WRITE IN ACTBUF
;T1/LENGTH CURRENT ACTBUF BLOCK, FOR PUTBUF
;T3/ARG TO PUTBUF, DATA
;T4/SPARE

XCF5L1:	AOBJN P2,.+2	;IF USER DATA RUNS OUT BEFORE RECORD LENGTH,
	TDZA T3,T3	;PAD REC W/ZEROS
	UMOVE T3,(P2)
	PUSHJ P,PUTBUF
	SOJG P1,XCF5L1	;CONTINUE FOR RECORD LENGTH
	UMOVEM P2,(M)	;RETURN UPDATED AOBJN TO USER
	PJRST FINACB	;RELEASE ACT,UPDATE BUFF PTRS,SKIP RTN
;XCHARG FUNCTION 6 -- TRU COMPONENT CHECKPOINT

TCCTAR==:21	;TCC RECORD TYPE NUMBER SEE ACTSER
TCCNHW==10	;NUMBER HEADER WORDS
TCCARL==:TCCNHW+XCHFLN+3	;TCC REC LENGTH

XCF6NL==XCF4NL	;NO LICENSE ERROR
XCF6NA==XCF4NA	;NO ACCTG ERROR CODE

COMMENT ! XCHARG FUNCTION 6 PUTS A RECORD IN THE STREAM WHICH LOGS THE
EXACT VALUE OF EACH TRU COMPONENT AND OTHER CHARGING VARIABLES
[CONNECT TIME ETC];  THE PURPOSE IS TO BE ABLE LATER TO
SCAN STREAM FILES AND DETERMINE WHICH PROGRAMS USE WHICH RESOURCES
SO AS TO BE ABLE TO PREDICT EFFECT OF CHANGING TRU ALGORITHM
COEFFICIENTS OR XCHARGING POLICIES.

THIS UUO SHOULDN'T BE ISSUED MORE THAN ONCE BETWEEN ANY RUN/RUNSEG
AND EXIT.

XC LICENSE IS REQUIRED

!

XCHF6:	;EXPECTS M/USER AC, J/JOB
	MOVE T2,JBTLIC(J)
	TLNN T2,LICXC
	 JRST XCF6NL		;NO LICENSE,SLAP HIS HAND
	MOVEI P1,TCCARL
	PUSHJ P,GETABS		;TRY TO GET SPACE ON ACT DEV
	 JRST XCF6NA		;CANT GET IT; ACT MUST BE DOWN
;NOW ACT DEVICE LOCKED DOWN FOR US
	PUSHJ P,CBLAMB	;GET T2/LOC T1/COUNT OF ACTBUF BLOCK
	MOVEI T3,TCCTAR
	MOVEI T4,TCCARL
	PUSHJ P,WACRHW		;WRITE HEADER FOR OUR REC TYPE,LENGTH
	MOVE T3,JBTNAM(J)
	PUSHJ P,PUTBUF		;CONTINUE HEADER SECTION
	MOVE T3,JBTFPN(J)
	PUSHJ P,PUTBUF
	MOVE T3,JBTSOK(J)
	PUSHJ P,PUTBUF

;TRANSFER TRU COMPONENT VALUES TO RECORD. EXPECTS J/JOB
	MOVSI P3,-XCHFLN	;XCHCTB LENGTH
XCF6L1:	MOVE T3,@XCHCTB(P3)
	PUSHJ P,PUTBUF
	AOBJN P3,XCF6L1

;TRANSFER CONNECT & DISPATCH BASE CHARGING PARAMETERS (NOT ACTUALLY
;PART OF TRU COMPUTATION, BUT USED IN CHARGING USER ANYWAY.

	MOVE T3,JBTCNK(J)
	PUSHJ P,PUTBUF
;	MOVE T3,JBTRMT(J)
	SETZ	T3,
	PUSHJ P,PUTBUF
;	MOVE T3,JBTRMC(J)
	SETZ	T3,
	PUSHJ P,PUTBUF
	PJRST	FINACB		;RELEASE ACT AND SKIP RETURN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	XCHARG Function 7 - Scale TRU's				;;
;;								;;
;;	Calling sequence:					;;
;;		MOVE	AC,[-count,addr]			;;
;;		XCHARG	AC,					;;
;;		  <error> /AC=error code (0 or 3)		;;
;;		<success return> /old JBTSCA(J) stored into	;;
;;				 /addr+2			;;
;;								;;
;;	addr:	7	;function code				;;
;;		BYTE (9) SC1,SC2,SC3,SC4			;;
;;		previous scaling word (stored if successful)	;;
;;								;;
;;	Where:	SC1 & SC2 are the numerator & denominator of an	;;
;;	integer fraction scaling factor (SC1/SC2) to be applied	;;
;;	to the non-kilocore (size-independent) portion of the	;;
;;	TRU function, and SC3 & SC4 are the numerator &		;;
;;	denominator of the kilocore (size-dependent) portion,	;;
;;	with the special case of SC3>0 and SC4=0 indicating	;;
;;	that the value in SC3 should be substituted for the	;;
;;	current charging size in K.				;;
;;	The value of "count" is ignored.			;;
;;	Error if job does not have XC license			;;
;;		or if SC1>0 and SC2=0.				;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EXTERNAL JBTSCA

	XCF7NL=XCF4NL

XCHSCA:
	MOVSI	T2,LICXC	;XC license
	TDNN	T2,JBTLIC(J)	;Does it have it?
	  JRST	XCF7NL		;No, give error
	UMOVE	T2,1(T1)	;Get new scaling word
	LDB	T3,[POINT 9,T2,8] ;Check for special case
	JUMPE	T3,XCHSC1	;SC1=0, no matter what SC2 is
	LDB	T3,[POINT 9,T2,17] ;Pick up SC2
	JUMPE	T3,XCF7BC	;Bad component
XCHSC1:
	EXCH	T2,JBTSCA(J)	;Store new, load old
	UMOVEM	T2,2(T1)	;Store old into user's arg block
	PJRST	CPOPJ1

;-PUTSAR     PUT STREAM ACCOUNTING RECORD UUO.
;	A.ATKINSON NEW SEPT 76 WITH P031 MONITOR
;-CALL:	MOVEI AC,RECORD
;	PUTSAR AC,
;	 ERROR: AC=ERR CODE
;	OK RTN,AC PRESERVED

BADSRT==3 ;BAD STR REC TYPE
SRNLIC==1 ;NO LICENSE TO WRITE THIS ONE
SRSZW==2  ;SIZE WRONG
SRNAO==0  ;NO ACT OWNER, BUFFER FULL, SYS UP FOR FREE

;-RECORD FORMAT:
; WORD 0:	HEADER WORD: TYPE,BIT 0-8; SIZE, BITS 30-35
; WORD 1:	DATE WORD: MONITOR WILL DATE STAMP HERE
; WORD 2:	AUN OR OTHER DATA
; WORD 3:	TRU'S OR OTHER DATA
; WORDS 4 THRU SIZE-1 : DATA ACCORDING TO TYPE

;EXTERNALS FROM ACTSER,ETC.
EXTERNAL ACYSIZ,ACRTAB,ACYTYP,ACTDDB
EXTERNAL ACUTAB ;-USER PART OF ACRTAB
EXTERNAL ACURTL ;-LENG OF USER PART
EXTERNAL ACYMIN ;MIN SIZE IF REC VAR LEN ELSE ZERO
EXTERNAL UPTPJC,UPTPJ1,UPTPJ2 ;FROM COMMON

PUTSAR:	UMOVE P2,(T1)	;P2:=USER HEADER WORD
	LDB P3,[POINT 9,P2,8];  P3:=PROPOSED TYPE
;SEARCH ACRTAB (ACTSER) FOR DESCRIPTOR FOR THIS TYPE.
;IF NOT FOUND,OR LICENSE BAD, OR SIZE WRONG,FRETURN
	MOVE T3,[XWD -ACURTL,ACUTAB]
	LDB T2,ACYTYP
	CAME T2,P3
	AOBJN T3,.-2
	MOVEI P4,BADSRT	;IN CASE NOT FOUND
	JUMPG T3,PTSRFX	;NOT FOUND
	HLLZ T4,ACRTAB(T3)
	MOVEI P4,SRNLIC	;IN CASE NO LIC
	TDNN T4,JBTLIC(J)
	JRST PTSRFX	;NOT LICENSED TO WRITE THIS ONE
	LDB P1,ACYSIZ
	LDB T2,[POINT 6,P2,35];USER SIZE FIELD
	MOVEI P4,SRSZW	;IN CASE 
	CAME T2,P1
        JRST    [LDB    T4,ACYMIN
                 JUMPE  T4,PTSRFX       ;ERROR IF REC LEN FIXED
                 CAML   T2,T4           ;YES: TOO SMALL OR
		 CAMLE	T2,P1	; TOO LARGE?
		 JRST	PTSRFX	;YES, ERROR
		 MOVE	P1,T2	;SET REC SIZE TO THAT WHICH USER SUP
		 JRST	.+1]	;CONTINUE
	ADDI T2,-1(T1)	;T2/ADDR LAST WRD OF RECORD
	UMOVE T2,(T2)	;MAKE SURE CAN GET IT
	XCTBU <MOVES 1(T1)> ;MAKE SURE CAN WRITE DATE WORD
;SEE IF OK TO WRITE THIS RECORD. SIZE IN P1
	MOVE P2,T1	;P2 POINT TO USER DATA FROM NOW ON
PTSBAJ:	PUSHJ P,GETABS		;GET C(P1) ACT BUFFER SPACE
	  JRST [MOVEI P4,SRNAO   ;ERR CODE FAIL PUTSAR
		JRST PTSRFX]	;STREAM DEAD.
;DATE STAMP RECORD IN USER MEMORY
PTSR1:	MOVE T3,TIME
	IDIV T3,JFYSEC
	HRL T3,THSDAT
	UMOVEM T3,1(P2)	;WORD 1 OF RECORD
;MOVE USER BLOCK TO ACTBUF. P2 POINTS TO USER BLOCK
	MOVEI F,ACTDDB
	PUSHJ P,CBLAMB	;T2=LOC,T1=LENG OF CONTIGUOUS ACTBUF BLOCK
	MOVNS P1	;P1:= -SIZE USER REC
	HRL P2,P1	;P2:= -SIZ,,USER LOC
PTSR2:	UMOVE T3,(P2)
	PUSHJ P,PUTBUF	;CALLS CBLAMB IF WRAPAROUND
	AOBJN P2,PTSR2
;CLEAN UP ACTBUF, UNINTERLOCK & EXIT SKIPPING
	JRST FINACB	;IN ACTSER
;RETURN ERROR CODE FROM P4 TO USER AC
PTSRFX:	UMOVEM P4,(M)
	JRST CPOPJ


COMMENT ! PUT ROYALTY STREAM RECORD UUO
EXPECTS: T1/ CONTENTS OF USER AC, BYTE(1)FLAG BYTE(35)ROYALTY ID
	J/JOB
RETURNS: SKIPPING ON SUCCESS, NO SKIP IF CANNOT GET
	SPACE IN ACT DEVICE BUFFER. 
!

ROYTAR==:20	;ROYALTY TYPE ACT RECORD SEE ACTSER
ROYARL==:11	;ROYALTY ACT RECORD LENGTH


PUTROY::
	PUSH P,T1	;SAVE FLAG & ROYALTY ID
	MOVEI P1,ROYARL	;SEE IF WE CAN GET SPACE
	PUSHJ P,GETABS	;TO WRITE ROYARL WORDS
	 JRST TPOPJ	;CANNOT, POP OUT T1 AND NOSKIP RETURN
;NOW HAVE ACT DEVICE LOCKED DOWN
	PUSHJ P,CBLAMB	;GET T2/LOC T1/COUNT OF ACTBUF FREE BLOCK
	MOVEI T3,ROYTAR
	MOVEI T4,ROYARL
	PUSHJ P,WACRHW	;WRITE HEADER WORDS: HDR,DATE,TIME,ETC.
	MOVE T3,JBTNAM(J)
	PUSHJ P,PUTBUF	;DEPOSIT JBTNAM IN BUF,UPDATE T1,T2
	MOVE T3,JBTFPN(J)
	PUSHJ P,PUTBUF	;AND FPN
	MOVE T3,JBTSOK(J)
	PUSHJ P,PUTBUF
	POP P,T3	;RECOVER SAVED FLAG & ROYALTY ID
	PUSHJ P,PUTBUF
	PJRST FINACB	;RELEASE ACT DEVICE,CLEANUP BUFFER, SKIP RTN
COMMENT ! LSAUUO KERNEL -- GENERATE LOCAL STREAM ACCOUNTING RECORD
PURPOSE: ALLOW PROGRAM RUN OUT OF OWN UFD TO BE TRACKED IN 
	THE STREAM.
FUNCTION: WRITE TYPE 13 STREAM RECORD UNLESS USER HAS
	ALREADY ISSUED THIS UUO ONCE SINCE THE LAST
	RUN UUO/RUN CMD.   NOTE THAT IF PROGRAM IS RUN OUT
	OF ANOTHER UFD, ORDINARY TYPE 0 RUN RECORD IS WRITTEN,
	BUT THIS UUO WILL ALLOW 1 MORE TO GO IN, WITH
	SPECIAL SIXBIT /IDENTIFIER/.
CALL:	MOVE AC,[SIXBIT /IDENTIFIER/] (ANY 36 BITS OK)
	CALLI AC,-63
	ALWAYS RETURNHERE, AC PRESERVED
NOTE: THESE /IDENTIFIER/'S SHOW UP IN STREAM AS THE PROGRAM
	NAME. THERE MUST BE AGREEMENT AMONG TECH DIVISION
	GROUPS ABOUT WHO USES WHAT /IDENTIFIER/ FOR CONFLICTS
	TO BE AVOIDED.
!

LSAUUO::	;EXPECTS J/JOB, T1/C(USER AC)
	PUSH P,JBTNAM(J)
	SKIPE T1	;IF USER PASSES 0, USE JBTNAM(J)
	MOVEM T1,JBTNAM(J) ;ELSE TEMPORARILY JBTNAM_IDENTIFIER
	MOVEI T1,13
	PUSHJ P,ACTWRT	;GO WRITE TYPE 13 USING JBTNAM(J)
	POP P,JBTNAM(J)
	POPJ P,
	END
    je	2/