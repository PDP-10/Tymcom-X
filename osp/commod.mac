TITLE	COMMOD - COMMON DATA LOCATIONS USED BY DISK SERVICE

	DEFINE GENMSK(SIZE,POS)
<<1B<35-SIZE>-1>B<POS>>


;ALL DATA LOCATIONS USED BY FILSER ARE HERE INSTEAD OF COMMON IN ANTICIPATION
; OF MULTI PROCESSING SYSTEMS WHICH SHARE DISKS AND ONE MEMORY BANK(DISK BUFFERS+DATA)
				;(MAY BE SET BY DSKCLN.).
; NO DATA LOCATIONS SHOULD BE PUT INTO COMMON FOR LEVEL D

REPEAT 0,<
ASSEMBLY INSTRUCTIONS:

.COM S+CONFIG+COMMOD/C

TO ASSEMBLE COMMON AND COMMOD TOGETHER:

.R MACRO

*COMMON,COMMON_S,CONFIG,TTY:COMMON,COMMOD
FTCMBTH==1
^Z
^Z

TO ASSEMBLE COMMOD WITH DATDMP(EXEC/USER MODE DATA BASE DUMPER):

.COM S+CONFIG+DATDMP+COMMOD/C

TO ASSEMBLE COMMOD WITHOUT DATDMP:
.CON S+CONFIG+COMMOD/C

>


;DEFINITIONS OF DSK DEVICE-DEPENDENT BITS IN DEVIOS & S
; ALL IN LEFT HALF

;BITS IN SAME POSITION AS IN RIB STATUS, FOR ERRORS
IOSHRE==RIPHRE	;HARD READ ERR,HARD WRITE ERR,
IOSHWE==RIPHWE
IOBDRB==RIPBDR	;FILE IS BAD(DEAD),DONT LET ANYONE AT IT.
IOSERR==IOSHRE!IOSHWE!IOBDRB

IOSRIB==400000	;RIB IS CURRENT IN (IN %RIB)
IOSRBE==200000	;SOME KIND OF ERROR READING RIB OR UFD
IOSUPR==100000	;SUPER USETI/USETO MODE
IOSALC==040000	;ALLOCATION FOR SOMETHING OTHER THAN FILE (UFD)
IOSSAE==020000	;SAT IS BAD.

INTERNAL IOSHRE,IOSHWE,IOSERR,IOSRBE,IOSRIB,IOSALC,IOSUPR
INTERN IOBDRB,IOSSAE


;SYMBOLS WHICH MAY BE DEFINED IN CONFIG IF A USER DOES NOT LIKE
;STANDARD DEFNS.  HOWEVER MOST CUSTOMERS WILL BE HAPPY WITH THE STANDARD
;VALUES.

	INTERN CCWMAX,PRVFIL,PRVUFD,PTRLEN

IFNDEF CCWMAX,<XP CCWMAX,^D10>	;MAX. NO OF DATA CHANNEL COMMAND WORDS. CUSTOMER MAY
			; CHANGE TO BIGGER OR SMALLER VALUE TO INCREASE THRUPUT
			; OR DECREASE SPACE.
IFNDEF PRVFIL,<PRVFIL==047>	;STANDARD FILE PRIVILEGE
				;OWNER=EVERYTHING,PROJ=READ,REST=NO ACCESS
IFNDEF PRVUFD,<PRVUFD==754>	;STANDARD UFD PRIVILEGE
				;OWNER=ALL,PROJ=ALL,REST=READ+LOOKUPS
IFNDEF PTRLEN,<PTRLEN==^D10>	;NO. OF IN CORE RETRIEVAL POINTERS PER FILE
				; LENGTH AFFECTS SIZE OF DEVICE DATA BLOCK
IFNDEF UNVRSF,<XP UNVRSF,^D500>	;RECIPROCAL SAFETY FACTOR FOR EACH UNIT
				; IE NO. BLKS ON UNIT/UNVRSF
				; IS SUBTRACTED FROM NO OF FREE BLOCKS
				; SEE STRTAL,UNITAL


IFNDEF OPNFPF,<OPNFPF==^D10>	;OPEN FIL/FRAME ESTIMATE. MUST BE SAME
				;VALUE AS IFNDEF'D IN COMMON. MAY
				;BE DEF'D IN CONFIG FOR SOME SYSTEMS. /AA

IFCPU(<KI,KL>),<
  IFNDEF CHNN,<XP CHNN,0>
  IFNDEF SAXN,<XP SAXN,1> >
IFCPU(<KS,F3>),<
  IFNDEF CHNN,<XP CHNN,1>
  IFNDEF SAXN,<XP SAXN,0> >

IFCPU(KS),<
  IFNDEF RMXN,<XP RMXN,1>
  IFNDEF RMAUN,<XP RMAUN,4>
  IFNDEF C0RMN,<XP C0RMN,1>
  IFNDEF C0APN,<XP C0APN,0>
> ; End IFCPU(KS)

IFCPU(F3),<
  IFNDEF FTAUN,<XP FTAUN,0>
  IFNDEF C0APN,<XP C0APN,1>	;NUMBER OF APN CONTROLS ON "CHANNEL 0"
  IFNDEF C0RMN,<XP C0RMN,0>
  IFNDEF APXN,<XP APXN,1>	;ONE AMPEX CONTROL
  IFNDEF APAUN,<XP APAUN,4>	;CONFIGURE FOR FOUR UNITS ON FIRST CONTROL
  > ; End IFCPU(F3)

IFCPU(<KI,KL>),<
  IFNDEF FTA,<FTA==200>
  IFNDEF FTATYP,<XP FTATYP,2>
  > ; End IFCPU(<KI,KL>)

IFNDEF C0DPN,<XP C0DPN,0>
IFNDEF C1DPN,<XP C1DPN,0>
IFNDEF C0FHN,<XP C0FHN,0>
IFNDEF C1FHN,<XP C1FHN,0>
IFNDEF C0MDN,<XP C0MDN,0>
IFNDEF C1MDN,<XP C1MDN,0>

IFNDEF DPAUN,<XP DPAUN,0>
IFNDEF SYRDPR,<XP SYRDPR,444000>	;NON-PRIVILEGED FILES IN SYS
				; HOME.SYS,SAT.SYS
IFNDEF SYNRPR,<XP SYNRPR,447000>	;PRIVILEGED FILES IN SYS
			; CRASH.SAV, SNAP.SYS,RECOV.SYS,BADBLK.SYS
IFNDEF MFDPRV,<XP MFDPRV,544000>	;MFD PRIVILEGES(ALL CAN READ,LOOKUP)
			; BUT NOT CREATE
IFNDEF SYSPRV,<XP SYSPRV,754000>	;SYS UFD PRIVILEGES(PROJ 1 READ,CREATE
			;LOOKUP, OTHERS READ
			; LOOKUP ONLY


;LIMITS OF VARIOUS FIELD WIDTHS IN FILE STRUCTURES

	INTERN	BLKSIZ,BLKLSH,BLKBPK,WRDSPP


XP BLKSPK,^D3	;# OF PLACES TO SHIFT LEFT TO CONVERT BLOCKS TO K.
XP BLKSPP,^D2	;# OF PLACES TO SHIFT LEFT TO CONVERT BLOCKS TO PAGES.
BLKSIZ==^D128		;NO. OF WORDS IN A DISK BLOCK (MUST BE POWER OF 2)
BLKLSH==^D7		;NO. OF PLACES TO SHIFT LEFT TO CONVERT FROM
			; BLOCKS TO WORDS
XP WRDSPP,^D9	;# OF PLACES TO SHIFT LEFT TO CONVERT PAGES TO 
		;WORDS.
BLKBPK==^D1024/BLKSIZ	;NO. OF BLOCKS PER J WORDS

;COMMON LOCATIONS (FOR COMMON SEARCH ROUTINES)
INTERNAL CMBLNK,CMBNAM

CMBNAM==0	;NAME DRBNAM AND FNBNAM MUST BE THE SAME AS THIS

CMBLNK==1	;LINK (LH) DRBLNK AND FNBLNK MUST BE SAME

CMBDWN==2	;DOWN POINTER (LH) DRBFNB AND FNBATB MUST BE SAME
XP CMBSIZ,ATBSPT+1	;SIZE OF A CORE BLOCK


;PAG - PARAMETERS WHICH APPEAR IN MORE THAN ONE DISK PAGE.
INTERN PAGNAM,PAGCOD,PAGSLF

PAGNAM==0		;SIXBIT NAME OF LPAGE (HOM OR BAT).
PAGCOD==776		;SELF INDENTIFYING CODE FOR PAGE RH ONLY, LH=0.
PAGSLF==777		;RETRIEVAL POINTER TO THIS PAGE.


COMMENT ; ATB (ACCESS TABLE BLOCK ) DEFINITIONS

THERE IS ONE ATB FOR EACH ACTUAL FILE ON THE DISK THAT IS
IN USE. THE 'FILE' THE ATB CORRESPONDS TO MAY NOT APPEAR
IN THE DIRECTORY, IT MAY HAVE BEEN SUPERCEDED OR NOT YET
ENTERED. IN THIS CASE, THE ATB WILL BE IN THE MARKED FOR
DELETION, OR IN THE CREATE STATE. THE FOLLOWING ARE THE ATB
STATES

CREATE
SUPERCEDE
READ
UPDATE
RENAME
MARKED FOR DELETION.

THERE MAY BE ANY NUMBER OF ATB'S MARKED FOR DELETETION FOR A FILE NAME.
THESE ATBS CANNOT HAVE ANY "WRITE" FIELDS ON (UPD, CRE, SUP, MXU)
THE REMAINING ATBS FOR A GIVEN FILE NAME CAN ONLY OCCUR IN THE
FOLLOWING CONFIGURATIONS:
1) EXACTLY ONE SUPERCEDE ATB, WHOSE UMC,CNT,MWC FIELDS MAY
   BE NON-ZERO, PLUS A POSSIBLE ATB WHICH HAS ALL "WRITE"
   FIELDS AND BITS ZERO, AND ATBCNT AND/OR ATBUMC NON-ZERO.
   SOMETIMES THIS SUPERCEDE ATB HAS ATPUPD
   ON INSTEAD OF ATPSUP SO THAT USERS WHO LOOKUP THE
   FILE WHILE THE NEW VERSION IS BEING CLOSED WILL GET
   THE NEW VERSION.  THUS, THE SUPERCEDE ATB CAN ONLY HAVE
   ATBCNT NON-ZERO AFTER ATPUPD IS SET. ATBUMC AND MWC
   CAN BE NON-ZERO DUE TO EITHER THE SUPERCEDER OR TO LOOKUPS
   DONE AFTER ATPUPD IS SET.
2) EXACLY ONE ATB WITH ATPUPD OR ATPMXU ON (SINGLE OR SIMULTANEOUS
   UPDATE).  ATBCNT, ATBMWC, AND ATBUMC MAY BE INCREMENTED.
3) EXACTLY ONE ATB WITH ATPCRE ON. ATMUMC MAY BE NON-ZERO,
   BUT ONLY THE CREATOR HAS ANYTHING MAPPED FROM THE FILE
   BEING CREATED. ATBCNT MUST BE ZERO, SINCE NO CHANNEL
   INCLUDING THE OWNER CAN HAVE A FILE BEING CREATED
   OPEN FOR READ OR UPDATE.
4) EXACLY ONE ATB WITH ATPREN ON. ATBUMC AND ATBCNT MAY
   BE NON-ZERO, REPRESENTING READERS OF THE FILE WHEN
   THE RENAME IS BEING DONE, BUT ATPMXU, ATPCRE, ATPSUP,
   AND ATPUPD MUST BE ZERO, I.E. NO WRITERS OF THE FILE
   CAN EXIST.
;
INTERNAL ATPCNT,ATPUFE,ATPPID,ATPALC,ATBRIB,ATMCSC,ATBSTS,ATMUFU,ATYCNT
INTERNAL ATBPVW,ATPDMP,ATYADT,ATYBLK,ATYCDT,ATYCSC,ATYCTD
INTERNAL ATYCTM,ATYPRV,ATYUF1,ATYUF2,ATYXCD
INTERN ATYBSZ,ATYWSZ,ATYALP,ATPSUP,ATPUPD,ATPCRE,ATPREN
INTERN ATPDEL,ATPNDL,ATPDIR,ATBDOR,ATBLNK,ATBSIZ,ATBPRV
INTERN ATBMSC,ATBLIC,ATBLCW,ATBFNB,ATBCNT,ATBALP,ATMUFP,ATMCNT
INTERN ATPDUM,ATPUMC,ATMUMC,ATBUMC,ATBSPT,ATPMWC,ATPMWC,ATMMWC
INTERN ATBMWC,ATPMXU,ATBDUM,ATBLOK,ATSWRD,ATSBLK,ATBPID

ATBRIB==0	;RETRIEVAL POINTER FOR THE FILE'S RIB
ATBFNB==1	;RH POINTER TO THE NAME BLOCK FOR THIS FILE
ATBLNK==1	;LH LINK TO NEXT ATB FOR THIS FILE
ATBSIZ==2	;NUMBER OF WORDS IN THIS FILE (IN 3 FIELDS)
		;(THAT IS, NUMBER OF HIGHEST WORD WRITTEN.).
 ATSWRD==7	;7 BITS OF WORDS
 ATNWRD==^D35	;RIGHT 7 BITS
 ATBWRD==ATBSIZ

 ATSBLK==2	;2 BITS OF BLOCKS
 ATNBLK==^D28
 ATBBLK==ATBSIZ

 ATSPGS==^D26
 ATNPGS==^D26
 ATBPGS==ATBSIZ	;PAGES IN FILE (FULL PAGES)

 ATYBSZ: POINT ATSBLK+ATSPGS,ATBSIZ(T2),ATNBLK ;POINTER TO NO.
		;OF BLOCKS (ROUNDED UP) IN FILE.

ATYWSZ: POINT ATSWRD,ATBSIZ(T2),ATNWRD ;POINTER TO NO. OF WORDS
		;IN LAST BLOCK OF FILE.

ATBPVW==3	;PRIV WORD FOR LOOKUP (DATE, MODE, ETC)
 ATSPRV==^D9	;PRIV FIELD
 ATNPRV==^D8
 ATBPRV==ATBPVW

 ATSMOD==4	;MODE
 ATNMOD==^D12
 ATBMOD==ATBPRV

 ATSCTM==^D11	;CREATION TIME IN MIN
 ATNCTM==^D23
 ATBCTM==ATBPVW

 ATSCDT==^D12	;CREATION DATE (LOW 12 BITS)
 ATNCDT==^D35
 ATBCDT==ATBPVW


ATBLCW==4	;LIC ETC, GOES IN RIBCNA

ATSUF1==4	;FIRST 4 UFD BITS
 ATNUF1==3
 ATBUF1==ATBLCW

 ATSUF2==^D8	;NEXT 8 BITS
 ATNUF2==^D11
 ATBUF2==ATBLCW

 ATPDMP==(1B4)	;IF ON SAYS FILE DUMPED SINCE LAST CAHNGE
 ATPUFE==(1B5)	;A BIT SO AN ERROR GETS RECORDED IN THE UFD
		;NOTE THAT ATPUFE MUST=RIPUFE.
 ATPPID==(1B6)	;FOR UFDS, MEANS THIS UFD SHOULD HAVE SPECIAL PID
		; STORAGE ACCOUNTING (NOT USED BY MONITOR).
		;FOR FILES, MEANS THIS FILE HAS A NON-ZERO PID
		; (KEPT BY THE MONITOR).
 ATPALC==(1B7)	;BIT THAT SAYS ALLOCATION HAS CHANGED ON THIS FILE.
		; BIT APPEARS IN UFD SO DSKCLN CAN SCAN IN FAST MOE
		; AND ONLY OR IN THE BITS IN THE SATS FOR FILES WITH
		; THIS BIT ON.

 ATMUFP==(GENMSK(2,\<ATNUF1-ATSUF1+2>)+GENMSK(4,\<ATNUF2-ATSUF2+4>))
 ATMUFU==(GENMSK(ATSUF1,ATNUF1)+GENMSK(ATSUF2,ATNUF2))
ATMUFU==ATMUFU-ATMUFP
 ATSCSC==^D6	;CREATION TIME SECONDS
 ATNCSC==^D17
 ATBCSC==ATBLCW

 ATMCSC==(GENMSK(ATSCSC,ATNCSC))

 ATSLIC==^D18
 ATNLIC==^D35
 ATBLIC==ATBLCW	;LIC IN RH

ATBMSC==5	;MISC STUFF
 ATSXCD==2	;EXTENDED DATE INFO
 ATNXCD==^D3	;HIGH ORDER 2 BITS UNUSED
 ATBXCD==ATBMSC

 ATSADT==^D14	;ACCESS DATE
 ATNADT==^D17
 ATBADT==ATBMSC

ATBLOK==ATBMSC	;FIRST DDB ON ATOMIC FILE LOCKING QUEUE.

ATBDOR==6	;DORMANT POINTTBALP==7	;NUMBER OF ALLOCATED PAGES (RIGHT 26 BITS ONLY)
		;BIT 0 MUST BE 0.
		;INCLUDES RIBS.
		;DOES NOT INCLUDE HOLES.
  ATYALP: POINT ^D26,ATBALP(T2),^D35

ATBPID==10	;PROCESSOR ID OF THE FILE. IN ATB FOR ACCESS CHECKING.

;THE FOLLOWING LOCATIONS ARE CONTAINED IN BOTH A REAL
; ATB AND DUMMY ATBS.

XP DABOFS,11	;HOW MUCH TO SUBTRACT FROM ADDRESS IN JBTDAB
		; TO GET SOMETHING THAT CAN BE INDEXED BY THE
		; FOLLOWING WORD VALUES.

ATBSTS==11	;GENERAL STATUS INFORMATION
 ATBDUM==ATBSTS	;WORD WITH "THIS IS A DUMMY ATB BIT" IN IT
 ATPDUM==400000	;THIS IS A DUMMY ATB (MUST BE SIGN BIT)

 ATSUMC==^D17	;COUNT OF NUMBER OF SLOTS MAPPING
		; A PAGE FROM THIS FILE WHOSE DP IS NOT IN SPT,
		; PLUS ONE IF AN SPT EXISTS.
 ATNUMC==^D17	;ALL BUT SIGN BIT
 ATPUMC==(1B<ATNUMC>) ;FOR INCREMENTING
 ATMUMC==(GENMSK(ATSUMC,ATNUMC))
 ATBUMC==ATBSTS

 ATSCNT==^D8	;COUNT OF NUMBER OF I/O CHANNELS OPEN FOR READ.
 ATNCNT==^D35	;RIGHT JUSTIFIED
 ATBCNT==ATBSTS
 ATPCNT==1B<ATNCNT>
 ATMCNT==GENMSK(ATSCNT,ATNCNT)

 ATPCRE==000400	;CREATE
 ATPSUP==001000	;SUPERCEDE
 ATPREN==002000	;RENAME
 ATPUPD==004000	;SINGLE UPDATE (ALSO USED TO LOCK THE FILE)
 ATPDEL==010000	;MARKED FOR DELETEION
 ATPNDL==020000	;DO NOT ALLOW DELETE, RENAME, SUPERCEDE, ETC
 ATPDIR==040000	;THIS IS A DIRECTORY
 ATPMXU==100000	;THE MAX WRITE COUNT IS UP. (SO DON'T HAVE TO CHECK ANOTHER WORD
		; TO SEE IF ATB IS UNUSED.

ATBSPT==12	;SPT AND MAX WRITE WORD
		;LH IS SPT POINTER TO FIRST SPT TABLE, RH
		; IS MAX WRITE COUNT

 ATSMWC==^D18	;COUNT OF 1) NUMBER OF I/O CHANNELS OPEN FOR UPDATE (BOTH FLAVORS)
		; 2) NUMBER OF SLOTS MAPPING A PAGE OF THIS FILE
		;THAT HAVE MAX WRITE BIT SET.
 ATNMWC==^D35	;POSITION RIGHT JUSTIFIED SO CAN AOS
 ATPMWC==1B<ATNMWC>
 ATMMWC==GENMSK(ATSMWC,ATNMWC)
 ATBMWC==ATBSPT

XP DABSIZ,ATBSPT-DABOFS+1	;NUMBER OF WORDS PER DUMMY ATB.

ATYADT:	POINT ATSADT,ATBADT(P2),ATNADT
ATYCDT:	POINT ATSCDT,ATBCDT(P2),ATNCDT
ATYCSC:	POINT ATSCSC,ATBCSC(P2),ATNCSC
ATYCTM:	POINT ATSCTM,ATBCTM(P2),ATNCTM
ATYPRV:	POINT ATSPRV,ATBPRV(P2),ATNPRV
ATYUF1:	POINT ATSUF1,ATBUF1(P2),ATNUF1
ATYUF2:	POINT ATSUF2,ATBUF2(P2),ATNUF2
ATYXCD:	POINT ATSXCD,ATBXCD(P2),ATNXCD
ATYCTD:	POINT ATSCTM+ATSCDT,ATBCTM(P2),ATNCDT
ATYBLK:	POINT ATSBLK+ATSPGS,ATBBLK(P2),ATNBLK
ATYCNT:	POINT ATSCNT,ATBCNT(P2),ATNCNT


COMMENT ; FNB - THE FILE NAME BLOCK, THERE IS ONE OF THESE FOR
EACH FILE IN USE OR DORMANT. THERE MAY BE SEVERAL ATB'S FFOR
EACH FNB IF SOME ARE MARKED FOR DELETION OR THERE IS A SUPERCEDE
AND A READ BLOCK ;

INTERN FNBNAM,FNBLNK,FNBEXT,FNBATB,FNBDRB,FNBRIB,FNBAPD
INTERN FNBSTS,FNBDBL,FNPLOK,FNBLOK,FNYUFP,FNPNX,FNBNX,FNBUPD,FNBALT
FNBNAM==0	;FILE NAME IN SIXBIT
FNBLNK==1	;LH POINTER TO NEXT FNB FOR THIS USER
FNBEXT==1	;RH EXTENSION OF FILE IN SIXBIT
FNBATB==2	;LH POINTER TO ATB'S FOR THIS FILE
FNBDRB==2	;RH POINTER TO DIRECTORY BLOCK (DRB)
FNBRIB==3	;RETRIEVAL POINTER TO FILE RIB
FNBAPD==4	;APPEND WORD (IF UPDATE APPEND MODE)

FNBSTS==5	;A STATUS WORD

 FNSNX==1	;DOES NOT EXIST BIT
 FNNNX==0
 FNBNX==FNBSTS
 FNPNX==400000

 FNSLOK==1	;LOCKED, USED SO FNB NOT TAKEN TO MAKE ATB
 FNNLOK==1
 FNPLOK==200000
 FNBLOK==FNBSTS

 FNSUFP==^D26	;PAGE OF UFD IN WHICH FILE NAME EXISTS (0 IF CRE)
 FNNUFP==^D35
 FNBUFP==FNBSTS

FNBDBL==6	;RH POINTER TO DDB CHAIN OF READERS (FOR INSERT DELETE BLOCK)

FNBUPD==7		;COUNT OF UPDATERS FOR THIS FILE.
FNBALT==10		;PCB DIRTY MONITOR CLOCK FOR FILE. KEEP HERE
			; INSTEAD OF ATB SINCE ONLY ONE PER UFD ENTRY, NOT
			; ONE PER VERSION OF FILE.

IFN <FNBNAM-CMBNAM>,<PRINTX ERROR IN FNBNAM DEF
	QQQQQ>
IFN <FNBLNK-CMBLNK>,<PRINTX ERROR IN FNBLNK DEF
	QQQQQ>
IFN <FNBATB-CMBDWN>,<PRINTX ERROR IN FNBATB DEF
	QQQQQ>
FNYUFP:	POINT FNSUFP,FNBUFP(P3),FNNUFP


COMMENT ; DRB - THE DIRECTORY BLOCK. ONE PER USER NAME WITH FILES
OPEN ;

INTERN DRBNAM,DRBLNK,DRBCNT,DRBSTS,DRBRIB,DRBMXA,DRBLOK
INTERN DRBLOG,DRBFNB,DRPLOK,DRBUNM,DRBUN1,DRBALC,DRPLOG

INTERNAL DRYPRV,DRYCNT,DRPNX,DRPMXC,DRMCNT,DRBNX
DRBNAM==0	;NAME OF DIRECTORY (PPN)
DRBLNK==1	;LH NEXT DRB IN SYSTEM

 DRSCNT==^D15	;COUNT OF PEOPLE USING THIS DRB
 DRNCNT==^D35
 DRBCNT==DRBLNK	;RH
 DRPMXC==1B<DRNCNT-DRSCNT>
 DRMCNT==GENMSK(DRSCNT,DRNCNT)

DRBSTS==DRBLNK	;STATUS BITS IN HIGH 3 BITS OF COUUNT

 DRSNX==1	;NX BIT
 DRNNX==^D20
 DRPNX==100000
 DRBNX==DRBSTS

 DRSLOK==1	;INTERLOCK BIT
 DRNLOK==^D19
 DRPLOK==200000
 DRBLOK==DRBSTS

 DRSLOG==1	;USER LOGGED IN BIT, KEEP DRB AROUND
 DRNLOG==^D18
 DRPLOG==400000
 DRBLOG==DRBSTS

DRBFNB==2	;LH FIRST FNB FOR THIS USER
DRBPRV==DRBFNB	;STATUS WORD

 DRSPRV==^D9	;PROTECTION CODE
 DRNPRV==^D35

 DRBSLT==DRBFNB	;SLOT NUMBER OF UFD BLOCK WITH KNOWN HOLE
 DRSSLT==^D9
 DRNSLT==^D26
DRBALC==3	;ALLOCATION LEFT IN THIS DIR (FROM QUOTA IN)
DRBMXA==4	;MAX ALLOCATION HAS EVER BIN (FOR ACCOUNTING)
DRBRIB==5	;RETRIEVAL POINTER TO RIB
DRBUNM==6	;USER NAME (IF KNOWN 0 IF NOT)
DRBUN1==7	;SECOND HALF OF USER NAME (IF KNOWN)

IFN <DRBNAM-CMBNAM>,<PRINTX ERROR IN DRBNAM DEF
	QQQQQ>
IFN <DRBLNK-CMBLNK>,<PRINTX ERROR IN DRBLNK DEF
	QQQQQ>
IFN <DRBFNB-CMBDWN>,<PRINTX ERROR IN DRBFNB DEF
	QQQQQ>

DRYPRV:	POINT DRSPRV,DRBPRV(P4),DRNPRV
DRYCNT:	POINT DRSCNT,DRBCNT(P4),DRNCNT


COMMENT ; SPT (SHARED PAGE TABLE) DEFINITIONS

THE SHARED PAGE TABLE CONSISTS OF ONE OR MORE SPT SECTIONS,
THE FIRST OF WHICH IS POINTED TO BY AN ATB THROUGH
ATBSPT.  EACH SECTION CONSISTS OF A HEADER, CONTAINING
FORWARD AND BACKWARD LINKS TO OTHER SPT SECTIONS, AND
A BACK LINK TO THE ORIGINATING ATB. ALSO CONTAINED
IN THE HEADER IS A COUNT OF FREE ENTRY SLOTS IN THE SPT
SECTION, FOR FAST INSERTION OF NEW ENTRIES IN THE
SPT.

THE SPT ENTRIES THEMSELVES ARE FOUND AFTER THE HEADER. EACH
ENTRY CONSISTS OF TWO WORDS. ENTRY WORDS OF THE SAME TYPE
APPEAR CONSECUTIVELY, RATHER THAN HAVING EACH TWO WORD ENTRY
CONTIGUOUS IN MEMORY, TO MAKE LOOPS SHORTER. DATA IN THE
ENTRIES CAN BE ACCESSED BY DIRECTU
ENTRIES CAN BE ACCESS EITHER DIRECTLY OR THROUGH THE BYTE
POINTERS PROVIDED.

SPTS DO NOT COME FROM FILSER CORE. THEY COME FROM DDB FREE CORE.
;

XP SPTBEG,0		;FIRST WORD

 XP SPTBLN,SPTBEG	;LH = BACK LINK TO LAST SPT. SET TO
			; ATB+ATBSPT-SPTLNK FOR FIRST
			; SPT SECTION SO THAT SPTLNK(AC) CAN STORE
			; INTO FORWARD POINTER OF ATB. NOTE THAT
			; SPTLNK AND ATBSPT MUST BE IN SAME HALF
			; OF A WORD.

 XP SPTNFE,SPTBEG	;RH = NUMBER OF FREE ENTRIES
  XP SPSNFE,^D4		;FIELD IS 4 BITS WIDE (15 ENTRIES)
  XP SPNNFE,^D35	;RIGHT JUSTIFIED FOR AOS AND SOSING.
  XP SPPNFE,1B<SPNNFE>	;RIGHTMOST BIT
  XP SPMNFE,<GENMSK(SPSNFE,SPNNFE)> ;MASK

  SPYNFE::POINT SPSNFE,SPTNFE(T4),SPNNFE	;BYTE POINTER TO FIELD

 XP SPTNME,1_SPSNFE-1	;NUMBER OF ENTRIES IS THIS.
 XP SPTNMM,<SPTNME>B<SPNNFE> ;# entries justified.

XP SPTLNK,SPTBEG+1	;NEXT WORD OF HEADER IS LINK IN LH,
 XP SPTATB,SPTBEG+1	;AND ATB BACK POINTER IN RH, JUST LIKE IN
			; OTHER FILSER CORE BLOCKS.

XP SPTEN1,SPTBEG+2	;FIRST ENTRY WORD

;SPT ENTRY DEFINITIONS, RELATIVE TO SPT ENTRY ADDRESS.
; FIRST SPT ENTRY ADDRESS IS SPT SECTION BASE ADDRESS
; PLUS SPTEN1.

XP SPTUSC,0*SPTNME	;USE COUNT. RIGHT JUSTIFIED SO CAN AOS AND SOS
 XP SPSUSC,^D18		;18 BITS WIDE
 XP SPNUSC,^D35		;RIGHT JUSTIFIED IN WORD
 XP SPPUSC,1B<SPNUSC>	;RIGHTMOST BIT
 XP SPMUSC,<GENMSK(SPSUSC,SPNUSC)> ;MASK

XP SPTVIR,0*SPTNME	;WORD WITH VIRGIN BIT IN IT
 XP SPPVIR,400000	;ITS THE SIGN BIT. CAN DO SKIPL SPTVIR(T1)

XP SPTPNO,1*SPTNME	;THE NEXT SPTNME WORDS ARE THE DISK PAGE NUMBER
			; ALL BY ITSELF FOR QUICK COMPARES IN SRCSPT.

XP SPHSIZ,SPTEN1-SPTBEG	;SIZE OF SPT SECTION HEADER
XP SPTSIZ,<2*SPTNME>+SPHSIZ ;NUMBER OF WORDS IN AN SPT SECTION


;MORE OF SPT DEFINITIONS

;SPT POINTER FORMAT. AN SPT POINTER IS JUST THE SPT SECTION ADDRESS
; CONCATENATED WITH A RIGHT JUSTIFIED SPT ENTRY OFFSET.

XP SPSOFS,SPSNFE	;SIZE OF OFFSET FIELD SAME AS SIZE OF
			; FREE ENTRY FIELD. ONE VALUE IS UNUSED.
XP SPNOFS,^D35		;OFFSET IS RIGHT JUSTIFIED.
XP SPMOFS,<GENMSK(SPSOFS,SPNOFS)> ;THE MASK

SP4OFS::POINT SPSOFS,T4,SPNOFS	;POINTER TO POINTER IN T4

XP SPSBAS,^D18	;ITS AN 18 BIT ADDRESS
XP SPNBAS,^D35-SPSOFS	;STARTS WHERE OFFSET ENDED
XP SPMBAS,<GENMSK(SPSBAS,SPNBAS)> ;A MASK FOR THE BASE

SP4BAS::POINT SPSBAS,T4,SPNBAS	;BYTE POINTER TO SPT POINTER IN T4


;DEV:	DEVICE DATA BLOCK (ONE FOR EACH ACTIVE SOFTWARE USER CHANNEL)

EXTERN	DSKDSP
INTERN DEVNAM,DEVCHR,DEVIOS,DEVSER,DEVMOD,DEVLOG,DEVBUF,DEVIAD,DEPMGN,DEVBTS
INTERN DEVOAD,DEVRET,DEVPOS,DEVRIB,DEYRPS,NORED,NOWRT,PIDACC
INTERN DEVFLO,DEVSZS,DEVATB,DEVDRB,PTRCHG,DEYSTC,DEV1UN,DEVFUF
INTERN PTRLEN,DEVRB1,DEVRBN,DEVSUP,DEPFLK,DEVLOK
INTERN DDBCOR,DSKDDB,DDBLEN,DEVELB,DEVDBL
INTERN DEVBLK

DSKDDB:			;ADDRESS OF PROTOTYPE DISK DDB FOR SYSTEM.
			; LINKED TO DDB LIST BUT NEVER USED.

PHASE	0

DEVNAM:!SIXBIT	/DSK/	;DEVICE NAME IN SIXBIT OF STR OR MORE USUALLY GENERIC DSK
DEVCHR:!XWD 0*HUNGST,201 ;HUNG TIME COUNT, BUFFER SIZE
DEVIOS:!0		;LH=MONITOR, RH=USER IO STATUS
DEVSER:!EXP DSKDSP	;LH=LINK TO NEXT DDB, RH=DISPATCH TABLE ADDRESS
			; IN FILSER SAME FOR ALL DISKS
DEVMOD:!XWD DVIN+DVOUT+DVDSK+DVDIR,154407 ;LH=CHARACTERISTICS, RH=MODES
DEVLOG:!0		;LOGICAL NAME IN SIXBIT
DEVBUF:!0		;LH=OUTPUT BUFFER HEADER, RH=INPUT BUFFER HEADER
DEVIAD:!0		;BIT 13=0, RH=POINTER TO USER INPUT BUFFER
  NORED==400000		;
  NOWRT==200000		;
  PTRCHG==100000	;ON IF RETRIEVAL PNTRS IN DDB HAVE BEEN
			;MODIFIED (AND CONSEQUENTLY HAVE TO BE
			;WRITTEN OUT TO THE RIB.).
  PIDACC==40000		;SET IF DDB IS SUBJECT TO PID ACCESS RULES.
			; (IF LAST UUO HAS UUPPID ON ON EXTENDED BLOCK)

DEVOAD:!0
			;BIT 13=0,BITS 14-17=R, RH=POINTER TO USER OUTPUT BUFFER
DEVCLS:!BYTE (2) 2 (8)0 (4) 0!;CLASS 2, 0 BLKS FOR IO LIST
DEVSTS:!0		;WORD FOR DEVICE CONI
DEVBLK:!0		;THIS REMAINS HERE FOR USE BY
			;DIRECTORY-MANIPULATION ROUTINES
			;(INSNAM,INSFAK,INSEOF), AND
			;GETBLK ROUTINE FILRIB, WHEN THERE
			;ARE SPARE RIB PNTRS.
DEVABC==DEVBLK		;(NO LONGER USED FOR DSK, VM SYSTEM)
DEVBWC:!0		;(NO LONGER USED FOR DSK, VM SYSTEM).
DEVFIL:!0		;OLD FILE NAME (LAST LOOKUP OR ENTER) - ARG TO FNDFIL
DEVEXT:!XWD 0,0		;LH=OLD FILE EXTENSION (LAST LOOKUP OR ENTER) -ARG TO FNDFIL
DEVSUP==DEVEXT		;RH=LOC FOR USE BY SUPER IO. WHEN IOSUPR
			;IS ON, THIS LOC=0 IF STR IS INITED,
			;ELSE IT IS DDB OF UNIT THAT IS INITED.
DEVPPN:!0		;OLD DIRECTORY NAME (PROJ,R) -NOT ARG TO FNDFIL
DEVPOS:!0		;BLK POSITION IN FILE, TO BE
DEVREL==DEVPOS ;TEMP DEBUGGING AID.
INTERN DEVREL ;TEMP DEBUGGING AID.
			;READ/WRITTEN NEXT INPUT/OUTPUT UUO.
			;SIGN BIT SET IF USETI/O SET IT AND
			;SIMIO HAS NOT YET ADJUSTED UPTPOS
DEVRET:!XWD ZERO18,0	;RH=CORE  ADR IN DDB OF CURRENT RETRIEVAL POINTER


DEVLOK:!0		;BOTH HALVES USED BY THE RIB STRUCTURE
			;LOCKING ROUTINES.
DEV1UN:!0		;UNIT DB ADDRESS IF THIS IS SPECIAL
			;UNIT IN STR STUFF (ELSE ZERO).
DEVFLO:!0		;DEVREL ASSOCIATED WITH THE FIRST
			;RETRIEVAL POINTER IN THE DDB, OR
			;-1 IF NO RET PNTRS IN THE DDB.
			;(IF 1ST RET PNTR IS A SPARE RIB PNTR,
			;FLO=DEVREL OF THE 1ST REAL RET PNTR
			;AT THE BOTTOM OF ITS CHAIN.).
DEVFUF:!0		;DEVFLO TYPE LOCATION FOR USE BY THE 
			;ROUTINES IN FILFNX, ETC. THAT READ THE UFD, ETC.
DEVSZS:!0		;RIBSZS OF THE RIB FROM WHICH THE DDB
			;RET PNTRS CAME.  (OR IF = 0, FLAG
			;THAT JUST THE PRIME RIB RET
			;PNTR IS IN THE DDB.).
DEVRIB:!0		;DISK POINTER TO THE RIB FROM WHICH
			;THE DDB RET PNTRS CAME.
DEVELB:!0		;TO STORE BLOCK (REALLY PAGE) NUMBER OF ERR
DEVRPS:!0		;BITS 0 TO 8 ARE THE REL ADDR IN
			;RIB OF LAST OF THE DDB RETRIEVAL PNTRS.
  DESRPS==^D9
  DENRPS==^D8
DEVSTC==DEVRPS		;CODE IN CASE SWPCLN NEEDED
  DESSTC==3
  DENSTC==^D11
DEVBTS==DEVRPS		;PLACE FOR SOME STATUS BITS.
  DEPMGN==000040	;BIT 12.
  DEPFLK==000020	;BIT 13. FILE IS LOCKED FOR MODIFYING.
			;BITS 14 TO 17 ARE UNDEFINED
DEVDBL==DEVRPS		;RH IS LINK FOR DDBS ON FNB

DEVRB1:!0		;FIRST RETRIEVAL POINTER GOES HERE IN DDB
			;FOR NORMAL IO.  FOR SUPER USETI/O RH
			;HAS UNIT DB ADDR.
	BLOCK PTRLEN-2	;IN-CORE RET. PTRS HERE 3,4,...RBN-1
DEVRBN:!0		;LAST RETRIEVAL PTR IN CORE

DEVATB:!0		;RH=ADDRESS OF ATB.
DEVDRB==DEVATB		;LH=ADDRESS OF DRB.

CORSIZ==4		;NO OF WORDS IN MONITOR FREE CORE BLOCKS
DDBCOR==<.-DEVNAM+CORSIZ-1>/CORSIZ ;NO OF MONITOR FREE CORE BLOCKS FOR DDB
DDBLEN==.-DEVNAM	;LENGTH OF DSK DDB IN WORDS

DEPHASE

DEYRPS: POINT DESRPS,DEVRPS(F),DENRPS ;REL POSITION OF LAST DDB
			;PNTR IN ITS RIB.
DEYSTC:	POINT DESSTC,DEVSTC(F),DENSTC	;STATUS CODE FOR SWPCLN




;WORD POSITIONS IN HOME FILE DATA PAGE.
;PREFIX "HOM"
;EACH FILE STRUCTURE HAS ONE HOME FILE HOME.SYS.

	INTERN HOMNAM,HOMHID,HOMSNM,HOMNXT,HOMPRV,HOMLOG
	INTERN HOMLUN,HOMSAT,HOMMFD,HOMCRS
	INTERN HOMREF,HOMOVR
	INTERN HOMSPU,HOMCOD,CODHOM,HOMSLF,HOMTAB
	INTERN HOMSUF,HOMPUF,HOMP4C,HOMEND
	INTERN HOMDAT,HOMHMS,HOMRAN,HOMHSH
	INTERN HOMDCV,HOMDCT

;DATA LOCATIONS IN HOME BLOCK:
;WRITTEN BY MAP PROGRAM:

HOMNAM==0	;"HOM" IN SIXBIT (WRITTEN BY MAP PROGRAM)
HOMHID==1	;SIXBIT UNIT ID (WRITTEN BY MAP PROGRAM)


;WRITTEN BY OPTIONAL ONCE ONLY DIALOG:

HOMSNM==2	;SIXBIT FILE STRUCTURE NAME THIS UNIT BELONGS TO
		; 0 INDICATES NOT IN A FILE STRUCTURE
		; [IGNORED BY MONITOR WHEN A PACK IS MOUNTED
		; FILE STRLST.SYS IS FINAL AUTHORITY FOR THE STR NAME]
HOMNXT==3	;SIXBIT UNIT ID OF NEXT UNIT IN THIS FILE STRUCTURE.
		; 0 IF THIS UNIT IS LAST OR ONLY UNIT IN FILE STRUCTURE.
		; [CHECKED BY MONITOR AND OMOUNT CUSP WHENEVER PACK IS MOUNTED]
HOMPRV==4	;SIXBIT UNIT ID OF PREVIOUS UNIT IN THIS FILE STRUCTURE.
		; 0 IF THIS UNIT IS ONLY UNIT IN FILE STRUCTURE.
		; [CHECKED BY MONITOR & OMOUNT CUSP WHENEVER PACK IS MOUNTED]
HOMLOG==5	;SIXBIT LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT
		; (E.G. DSKA0,DSKC12)
HOMLUN==6	;LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT
		; [CHECKED BY MONITOR AND OMOUNT CUSP WHENEVER PACK MOUNTED]
HOMREF==10	;NON-ZERO IF FILE STRUCTURE MUST BE REFRESHED
		; BECAUSE SOME PARAMETER FOR THIS UNIT HAS BEEN CHANGED
		; SET BY DISK ONCE ONLY CODE,CHECKED WHEN SYSTEM IS STARTED
		; AND BY OMOUNT WHEN PACK MOUNTED
HOMSPU==15	;# SAT PAGES PER UNIT.
HOMOVR==16	;-# OF PAGES OF OVERDRAW ALLOWED A USER ON THIS STR BEFORE
		; NO MORE OUTPUTS ALLOWED.


;WORDS WRITTEN BY REFRESHER:

HOMTAB==17	;FIRST LOC OF TABLE OF LOG. PAGE NOS OF SYSTEM FILES
HOMSAT==HOMTAB	;LOGICAL PAGE NO. WITHIN STR(NOT UNIT) OF 1ST RIB FOR SAT.SYS
HOMHMS==20	; " FOR HOME.SYS
HOMCRS==22	; " FOR CRASH.SAV
HOMSUF==23	; " SYS UFD
HOMPUF==24	; " PRINTR UFD
HOMMFD==25	; " FOR MFD [1,1].UFD

HOMP4C==26	;PAGES FOR CRASH.SAV FILE..
HOMHSH==27	;LH IS HASH CONSTANT.
HOMRAN==27	;RH IS PACK SET IDENTIFIER.
HOMEND==27	;LAST WORD NOT TO ZERO BY ONCDSK.
HOMDCV==(SIXBIT/DCV/)	;DSKCLN TYPE VALIDATOR
HOMDCT==30	;DSKCLN TYPE
HOMSER==174	;SERIAL NUMBER INCREMENTED ON SYSTEM UP
HOMDAT==774	;CONTAINS DATE OF LAST PACK COPY
HOMCOD==PAGCOD	;CONTAINS UNLIKELY CODE, LH=0
CODHOM==070717  ;THE UNLIKELY CODE FOR THE HOME BLOCK
HOMSLF==PAGSLF	;LH=0, RH=THIS PAGE ADDR WITHIN UNIT (SELF).


;WORD POSITIONS FOR RETRIEVAL INFORMATION BLOCK
;PREFIX "RIB"
;THE FIRST "RIBDDB" LOCATIONS OF THE RIB ARE KEPT IN CORE IN THE
; DDB WHILE THE FILE IS ACTIVE, THEY ARE FLAGGED (DDB).
;SOME OF THE SAME INFORMATION ALSO APPEARS IN THE ACCESS TABLE ENTRY
; THEY ARE FLAGGED (ACT).
;THE ORDER OF THESE ARGUMENTS CORRESPONDS EXACTLY TO THE EXTENDED LOOKUP,
; ENTER, RENAME BLOCKS.  WORDS APPEARING IN EXTENDED LOOKUP, ENTER, RENAME
; ARE FLAGGED WITH (ENT). SEE LEVEL D PROJECT SPECIFICATION FOR MORE
; INFORMATION ON LOOKUP/ENTRY/RENAME ARGUMENTS AND VALUES.
;A FEW EXTRA WORDS WHICH HAVE MEANING FOR UFD'S ONLY HAVE BEEN ADDED
; TO ALL FILES.  THEY HAVE NO MEANING FOR DATA FILES.  THESE WORDS ARE
; FLAGGED (UFD-ONLY).
;ALL QUANTITIES ARE IN BLOCKS EXCEPT THE FILE SIZE (RIBSIZ), WHERE
;USER MAY WANT TO KNOW NO. OF DATA WORDS IN LAST BLOCK

	INTERN RIBPPN,RIBNAM,RIBEXT,RIBPRV,RIYPRV,RIBUNM,RIBUN1
	INTERN PRTEXC,PRTRED,PRTAPP,PRTUPD,PRTWRT,PRTREN,PRTCPR,RIRXLK,RIRXCR,RIRXRD
	INTERN RIBSIZ,RIBVER,RIBSFS,RIBPFS,RIBLST,RIBALP,RIBMXA
	INTERN RIBMTA,RIBQTF,RIBQTO,RIBUSD,RIPDIR,RIPPID,RIPALC
	INTERN RIBSTS,RIPLOG,RIPHRE,RIPHWE,RIPBDA,RIPBFS,RIPBDR
	INTERN RIBRIB,RIBSZS,RIBSNM,RIBRPS,RIBLCW,RIBMSC,RIBPVW
	INTERN RIBCOD,CODRIB,RIBSLF,RIBELB,RIBFUT,RIBFT1,RIPUFE
	INTERN RIPNDL,RIPNFS,RIBAUT,RIBDEV,RIBPOS,RIBEST,RIBALC
	INTERN RBSPAR,RBREAL,RBINDX,RBDLTA,RBLVSP,RBLVPR
	INTERN PTSUNI,PTNUNI,PTSPNO,PTNPNO,RIBTRU,RIBXT1,RIBXT2
	INTERN RBYUNI,RBYPNO,RBMASK,RBYUN1,RBYUN4,RBYPN1,RB1PNO
	INTERN RBYUNA,RBYUNR,RBYUNV
	INTERN RIBPJC,RIBPJ1,RIBPJ2,RIBPID,RIBALT	;-

RIBRIB==0	;POINTER TO THE NEXT UPPER RIB, 0 IN PRIME RIB
RIBRPS==1	;LOCATION (WORD) OF POINTER TO THIS RIB IN NEXT UPPER RIB
RIBSZS==2	;NUMBER OF BLOCKS REPRESENTED BY EACH SUBRIB POINTER
		;IN THIS RIB
RIBSNM==3	;NUMBER OF SUBRIBS THIS RIB HAS (FIRST LEVEL ONLY)

RIBSFS==4	;FIRST RIB POINTER LOCATION IN A SUBRIB

RIBPPN==4	;(ACT)(DDB) (ENT) PROJECT,PROGRAMMER # IN OCTAL OR PROJECT
		; NAME (3 CHAR SIXBIT LEFT JUSTIFIED IN LH) OR PROGRAMMER
		; INITIALS (3 CHAR SIXBIT LEFT JUSTIFIED IN RH) (AS LOOKUP ENTER
		; RENAME ARG APPEARS AT RIBSIZ POSITION) OF UFD IN WHICH
		; THIS FILE APPEARS.  NEVER CONVERTED TO DECIMAL BY MAN OR MACHINE.
RIBNAM==RIBPPN+1;(ACT)(DDB) (ENT) 6 CHAR FILE NAME IN SIXBIT (OR OCTAL PROJECT
		; PROGRAMMER NO. OR SIXBIT IF THIS FILE IS MDF OR UFD).
RIBEXT==RIBNAM+1;(ACT)(DDB) (ENT) LH 3 CHAR FILE EXTENSION IN SIXBIT; BITS 24-35
RIBMSC==RIBEXT	; ACCESS DATE. BYTE=RIBACD.
RIBPVW==7	;(ACT)(DDB) (ENT)FILE ATTRIBUTES 0-8 ACCESS CODE, 9-12 MODE, 13-23
		; CREATION TIME IN MINUTES SINCE MIDNIGHT, 24-35 CREATION DATE
RIBPRV==RIBPVW	;ANOTHER SYMBOL FOR SAME LOCATION
  RISPRV==^D9
  RINPRV==^D8



RIYPRV:	POINT RISPRV,RIBPRV+%RIB,RINPRV  ;BYTE POINTER TO ACCESS PRIVILEGES
		;ACCESS PRIVILEGES DEFINED IN INCREASING ORDER OF POWER FOR 
		; DATA FILES (IE NON-DIRECTORY)
		; BITS 0-2 FOR ANY JOB WITH MATCHING PROGRAMMER NO.
		; (NO MATTER WHAT THE PROJECT)
		; BITS 3-5 FOR ANY JOB WITH MATCHING PROJECT NO.
		; (NO MATTER WHAT THE R NO.
		; BITS 6-8 NEITHER PROJ NOR R MATCH
  PRTEXC==1	;EXECUTE ONLY-IE GET, R,RUN ACCESS
  PRTRED==2	;READ ONLY
  PRTAPP==3	;APPEND (ALLOCATE, DEALLOCATE, APPEND)
  PRTUPD==4	;UPDATE
  PRTWRT==5	;WRITE (SUPERSEDE,TRUNCATE)
  PRTREN==6	;RENAME (CHANGE ATTRIBUTES, NAME, EXT, DIR)
  PRTCPR==7	;CHANGE PRIVILEGE
		;ACCESS PROVILEGES FOR DIRECTIORY FILES (RIPDIR SET IN RIBSTS)
		; 3 INDEPENDANT ACCESS PRIVILEGES
		; BITS 0-2 FOR ANY JOB WITH MATCHING PROG. NO, 3-5 MATCHING PROJ 
		; 6-8 NEITHER MATCHING
  RIRXLK==4	;1 ALLOWS LOOKUPS IN DIRECTORY
  RIRXCR==2	;1 ALLOWS CREATES IN DIRECTORY
		; (IE ADD NAMES WHICH ARE NOT ALREADY THERE)
  RIRXRD==1	;1 ALLOWS DIRECTORY TO BE READ AS A DATA FILE
RIBSIZ==10	;(ACT)(DDB) (ENT) RIGHT ADJUSTED WRITTEN LENGTH
		;OF FILE IN WORDS (POSITIVE QUANTITY).
		; MAYBE LESS THAN NO. OF WORDS ALLOCATED
RIBVER==RIBSIZ+1;(ENT) VERSION NUMBER (LIKE JOBVER)
		; LH=PROGRAMMER NUMBER LAST MAKING CHANGE
		; RH=OCTAL VERSION NUMBER NEVER CONVERTED TO DECIMAL
		; BY MAN OR MACHINE.
RIBFUT==12	;RESERVED
RIBEST==13	;WAS ESTIMMATED SIZE. TREATED SPECIALLY TO
		;MAKE OLD PROGRAMS THAT LOOKED AT IT WORK
RIBALC==14	;SIMMILARY WAS AMMOUNT ALLOCATED
RIBPOS==15	;USED TO BE POSITION ALLOCATED. NOW AVAIL
RIBFT1==16	;ALSO RESERVED


RIBLCW==17	;LICENSE WORD
  RIPDMP==ATPDMP	;(LH)SET BY MONITOR IF FILE CHANGED, CLEARED
			; BY TAPE BACKUP PROGRAM.
  RIPUFE==ATPUFE	;(LH)THIS FILE HAS AN ERROR OF SOME SORT(RIPHWE,
		;RIPHRE,RIPBDR,RIPBFS,RIBBDA.).
		;NOTE THAT RIPUFE MUST=ATPUFE.
  RIPPID==ATPPID	;(LH)IF UFD, SET BY SYS ADMINISTRATOR TO FLAG
			; THAT THIS UFD NEEDS SPECIAL PID STORAGE ACCOUTNING.
			; IF FILE, SET/CLEARED BY MONITOR WHEN PID IS
			; SET/CLEARED.

  RIPALC==ATPALC	;(LH)FOR FILES, NOT UFDS, SAYS THAT
			; THIS FILE HAS HAD AN ALLOCATION CHANGE
			; AND THE MONITOR DOESN'T KNOW IF ALL RIBS
			; AND SATS AND UFDS HAVE BEEN WRITTEN OUT YET.
RIBMTA==20	;(ENT) 36 BIT TAPE LABEL IF FILE HAS BEEN PUT ON MAGTAPE
RIBDEV==21	;VALUE ONLY-FILE STRUCTURE NAME FILE STARTS ON

RIBSTS==22	;STATUS BITS FOR ALL FILES IN UFD(LH),
		; THIS FILE IN RH

  RIPLOG==400000;(LH) IF 1 SAYS USER IS LOGGED IN. SET BY LOGIN CUSP
		; RENAME UUO.  SET TO 0 BY LOGOUT CUSP RENAME UUO.
		; BIT CHECKED BY LOGIN IN ORDER TO DETERMINE IF 
		; RIBTOT IS TO BE BELIEVED (IF RIBLOG==1) SYSTEM
		; MUST HAVE CRASHED OR BEEN RELOADED WITHOUT LOGGING
		; OUT ALL USERS.

  RIPBDA==1	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY DAMAGE
		; ASSESSMENT CUSP
  RIPBFS==10	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY FAILSAFE
		; WHEN READING MAGNETIC TAPE TO RESTORE TO DISK.
  RIPHRE==100	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
		; READ DATA ERROR DETECTED BY MONITOR.(IODTER)

  RIPHWE==200	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
		; WRITE DATA ERROR DETECTED BY MONITOR.(IODTER)

  RIPBDR==2000	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY OPERATING SYSTEM.


INTERN RIPSPP

  RIPDIR==400000;(RH) 1 IF THIS FILE IS A DIRECTORY FILE (UFD OR MFD)
		; RATHER THAN A DATA FILE. NEEDED TO PROTECT
		; THE SYSTEM FROM THE USER WHO MIGHT TRY
		; TO MODIFY A DIRECTORY AS A DATA FILE
  RIPNDL==200000	;(RH)[NO DELETE] 1 IF THIS FILE CANNOT BY
		; DELETED EVEN BY A PRIVILEGED PROGRAM.  THESE FILES ARE IN
		; SOME SENSE FAKE OR CRUCIAL TO FILE STRUCTURE.
		; EG. HOME.SYS, SAT.SYS, MAINT.SYS, BADBLK.SYS
		; NAME CHANGED FOR SAVE REASONS AS NO DELETES ABOVE.
  RIPNFS==40000	;(RH)[NO FAILSAFE] 1 IF THIS FILE SHOULD NOT
		; BE DUMPED BY FAILSAFE BECAUSE IT IS A FUNNY FILE AND
		; SHOULD NOT BE RESTORED OR IS PART OF THE SKELETON
		; FILE STRUCTURE.  (BADBLK.SYS,SAT.SYS,HOME.SYS,MAINT.SYS
		; RECOV.SYS).  (SNAP.SYS, CRASH.SAV, UFD'S AND MFD
		; DO NOT HAVE RIPNFS ON, SO THEY ARE ALL SAVED).
RIPSPP==1000	;FILE HAD DEVPPN=JBTPPN AT CREATION TIME


RIBELB==23	;ERROR BLOCK IN FILE
RIBXT1==24	;EXTRA ARGUMENT
RIBQTF==25	;(UFD ONLY) FIRST COME FIRST SERVE LOGGED IN QUOTA IN TOTAL
		; NUMBER OF DATA + RIB BLOCKS (I.E. ALL OVERHEAD BLOCKS TOO
		; EXCEPT NOT UFD + ITS RIB - THAT IS CHARGED TO 1,1) ALLOWED THIS
		; USER IN THIS DIRECTORY IN THIS FILE STRUCTURE WHILE
		; LOGGED-IN.  SET BY LOGINN. SEE THE DRB


RIBQTO==26	;(UFD-ONLY) LOGGED-OUT QUOTA IN TOTAL NUMBER OF DATA + RIB
		; BLOCKS ALLOWED THIS USER IN THIS DIRECTORY IN THIS STR
		; WHILE LOGGED-OUT.(I.E. ALL OVERHEAD BLOCKS TOO EXCEPT UFD
		; + ITS RIB -  THAT'S CHARGED TO 1,1).  SET BY LOGIN FROM ACCT.SYS
		; FILE (SO LOGOUT WILL NOT HAVE TO SEARCH ACCT.SYS).
		; LOGOUT WILL FORCE USER TO DELETE ENOUGH FILES SO AS TO BE
		; BELOW THIS LIMIT.  THIS QUANTITY IS NOT KEPT IN CORE

RIBMXA==27	;MAX USD HAS EVER BEEN. MAY BE USED FOR
		;ACOUNTING

RIBUSD==30	;(UFD-ONLY) COUNT OF BLOCKS USED (INCLUDING ALL OVERHEAD BLOCKS)
		; WHEN JOB WAS LOGGED OUT
		; (PROVIDED LOGBIT=0). WRITTEN BY LOGOUT, READ BY LOGIN.
RIBAUT==31	;PROJ-R # OF AUTHOR OF FILE, IE USER DOING
		; CREATE OR SUPERSEDE. (USUALLY THE SAME AS OWNER, IE
		; UFD IN WHICH FILE EXISTS, EXCEPT WHEN A FILE
		; IS CREATED OR SUPERSEDED IN SOMEONE ELSES UFD)
RIBUNM==32	;FOR UFDS ONLY, THIS AND RIBUN1 ARE THE
		;SIXBIT USER NAME.  FOR OTHERS, THESE WORDS
		;ARE 0.
RIBUN1==33	;SEE RIBUNM.
RIBTRU==34	;PRIVILEGED ARG FOR EACH CUSTOMER TO DEFINE
RIBXT2==35	;ANOTHER EXTRA ARGUMENT
RIBALP==36	;NUMBER OF PAGES ALLOCATED TO THIS FILE(REALLY)
RIBPJC==37	;FILE PROJECT CODE WORD 0
RIBPJ1==40
RIBPJ2==41
RIBPID==42
RIBALT==43
;(SEE RIBPFS, NEXT PAGE)




;THE NEXT LOCATIONS ARE USED FOR RIB POINTERS. THE RIB POINTERS
;HAVE THE FOLLOWING FORMAT
    RBSPAR==400000
;	BIT 0 POINTER TO A SPARE RIB NOT DATA
    RBREAL==200000
;	BIT 1 IS POINTER TO A REAL PAGE (AS OPPOSED TO JUST A PLACE HOLDER.).
    RBINDX==100000
;	BIT 2 SPECIAL BLOCK (INDEX) SKIP UNLESS MODE 200+N
    RBDLTA==40000
;	BIT 3 POINTER HAS BEEN CHANGED
;
    RBMASK==RBSPAR!RBREAL!RBINDX!RBDLTA

	PTSUNI==^D8
	PTNUNI==^D16
	PTSPNO==^D19
	PTNPNO==^D35
RBYUNI: POINT PTSUNI,T2,PTNUNI
RBYUN1: POINT PTSUNI,T1,PTNUNI
RBYUN4: POINT PTSUNI,T4,PTNUNI
RBYUNA:	POINT PTSUNI,ATBRIB(P2),PTNUNI
RBYUNR:	POINT PTSUNI,DRBRIB(P1),PTNUNI
RBYUNV:	POINT PTSUNI,DEVRIB(F),PTNUNI
;	BITS 9-16 UNIT NUMBER
RBYPNO:	POINT PTSPNO,T2,PTNPNO
RBYPN1:	POINT PTSPNO,T1,PTNPNO
RB1PNO:	POINT PTSPNO,P1,PTNPNO
;	BITS 17-35 PAGE NUMBER ON UNIT

RIBPFS==51		;FIRST SPOT WHICH CAN BE USED FOR RIB POINTERS


RIBCOD==PAGCOD	;CONTAINS UNLIKELY DATA WORD (I.E., NOT ASCII OR FLOATING POINT)
		;LH=0
  CODRIB==666666  ; THE UNLIKELY CODE
RIBLST==RIBCOD-1	;LAST LOCATION FOR POINTERS
  RBLVPR==RIBLST-RIBPFS+1  ;NO. OF PRIME RIB PNTRS.
  RBLVSP==RIBLST-RIBSFS+1  ;NO. OF SPARE RIB PNTRS.
INTERN TWOLVL,ONELVL
TWOLVL==RBLVSP*RBLVSP
ONELVL==RBLVSP

RIBSLF==PAGSLF	;A POINTER TO THIS RIB ITSELF


;VESTIGIAL STR DB.


INTERN STRNAM,STRUNI,STROVR,STRTAL,STRPPU,STRP4C,STRREF,STRUNM
INTERN STRDDB,STRLEN,STRHSH,STRPID,STRBTS,SRPRPT,SRPNDS,STRPID


STRDDB:

PHASE 0

STRNAM:!0	;SIXBIT NAME OF FILE STR.  ALSO, <>0 IS FLAG
		;THAT STR EXISTS.

STRHSH:!
STRUNI:!0	;LH=ADDR OF FIRST UNIT DATA BLOCK IN THIS STR.
		;END OF LIST IS 0.  LH IN UNI IS UNISTR.
		;RH IS HASH CONSTANT.

STRP4C:!0	;PAGES FOR CRASH.SAV.

STRUNM:!0	;RH=NO. OF UNITS IN THIS FILE STR.
STRREF==STRUNM	;LH=LH=NON-ZERO IF THIS STR NEEDS REFRESHING
		;BEFORE IT CAN BE USED.

STROVR:!0	;-NO. OF PAGES A USER IS ALLOWED TO WRITE OR
		;ALLOCATE BEYOND HIS RESERVED+FCFS QUOTA.

STRTAL:!0	;NO. OF FCFS FREE PAGES LEFT IN THIS STR MINUS
		;A SAFETY FACTOR (STVSFC - MONGEN SYMBOL).
		;THIS SAFETY FACTOR GUARANTEES THAT CLOSES
		;CAN BE DONE.

STRPPU:!0	;NO. OF PAGES PER UNIT IN THIS STR.

STRPID:!0	;LH=STR PACK SET ID
STRBTS==STRPID	;RH=SOME STATUS BITS
		;BITS 18 - 33 ARE UNDEFINED.
		;BIT 34 MEANS DSKCLN NEEDS TO BE RUN FOR THIS STR.
		;BIT 35 MEANS A SAT HAS BEEN FOUND BAD SINCE
		;THE LAST REPORT.
    SRPNDS==2
    SRPRPT==1

STRLEN==.-STRNAM

DEPHASE


;WORD POSITIONS IN USER FILE DIRECTORIES
;PREFIX "UFD"
;THESE HAVE SAME FORMAT AS THE MFD.
;NEITHER THE MFD NOR THE UFD NAME APPEAR IN THE UFD.
;FILE ENTRIES OCCUR IN PAIRS.

INTERNAL UFDHSI,UFDLNK,UFDSIZ,UFDRIB,UFYUF1,UFYUF2,UFPERR,UFDERR
INTERNAL UFDCDT,UFDALP,UFYPRV,UFDNAM,UFDEXT,UFDLIC,UFYXCD
INTERNAL UFYCTM,UFYCDT
UFDNAM==0	;SIXBIT FILE NAME
UFDEXT==1	;LH=SIXBIT EXTENSION, RH=CUP WHICH SPECIFIES
		; UNIT WITHIN FILE STRUCTURE AND LOGICAL BLOCK NUMBER OF
		; FIRST RIB OF FILE.  SEE MFDEXT ABOVE.
UFDPRV==1	;PRVTECTION IN UFD
  UFSPRV==^D9
  UFNPRV==^D35
UFDUF2==1
  UFNUF2==^D26
  UFSUF2==^D8
  UFPDMP==1B19
  UFPERR==1B20
  UFPPID==1B21		;FOR UFD, MEANS SPECIAL PID STORAGE ACCOUNTING, NOT
			; SET BY MONITOR, SET BY USER.
			;FOR REGULAR FILE, SET/CLEARED BY MONITOR WHEN PID
			; IS SET/CLEARED.
  UFPALC==1B22		;NOT CURRENTLY USED FOR UFD, FOR FILE,
			; MEANS NOT ALL RELEVANT DATA IS GUARANTEED
			; TO BE ON DISK.
  UFDERR==UFDUF2
UFDUF1==2
  UFSUF1==4
  UFNUF1==4
UFDXCD==2	;EXTENDED DATE BITS
  UFSXCD==2
  UFNXCD==6
UFDCTM==2	;CREATION TIME
  UFSCTM==^D17
  UFNCTM==^D23
UFDCDT==2	;CREATION DATE
  UFSCDT==^D12
  UFNCDT==^D35
UFDALP==3	;SPACE ALLOCATED
UFDLIC==3	;LICENSE BITS
  UFPTMP==1B23	;SET BY USER TO SAY THAT THIS IS A TMP FILE,
		;EVEN THOUGH IT MAY NOT HAVE THE EXT TMP.
  ;THERE ARE OTHER BITS IN USE IN UFDLIC...WHO KNOWS WHAT
  ;THEY ARE.....
UFDRIB==4	;RETRIEVAL PNTR TO PRIME RIB OF FILE.

UFDHSI==7	;THIS IS THE HASH CODE USED TO LOOKUP FILES
UFDLNK==^D511	;THIS IS WHERE THE LINK TO THE NEXT BLOCK IS
UFDSIZ==5	;NUMBER OF WORDS/ENTRY

;BYTE POINTERS

UFYUF2:	POINT UFSUF2,%RIB+UFDUF2(T2),UFNUF2
UFYUF1:	POINT UFSUF1,%RIB+UFDUF1(T2),UFNUF1
UFYPRV:	POINT UFSPRV,%RIB+UFDPRV(T2),UFNPRV
UFYXCD:	POINT UFSXCD,%RIB+UFDXCD(T2),UFNXCD
UFYCTM:	POINT UFSCTM,%RIB+UFDCTM(T2),UFNCTM
UFYCDT:	POINT UFSCDT,%RIB+UFDCDT(T2),UFNCDT


;MONITOR JOB TABLES - ONE ENTRY PER JOB

	INTERN JBTRCT,JBTWCT,JBTMPC,JBTPWH,JBTPWL,JBTPWS
	INTERN JBRIRD,JBRIWT,JBYIRD,JBYRCT,JBYIWT,JBYWCT,JBSRCT
	INTERN SYSBG3,SYSEN3

SYSBG3:			;1ST. LOCATION CLEARED BY ACCINI ON 143 (RE)START
JBTRCT:	BLOCK	JOBN	;NO. OF DISK BLOCKS READ ON ALL STRS SINCE JOB LOGGED IN
			;JOB 0=SWAP READ ON ALL UNITS
			;JOB 0 = SWAP READ ON ALL UNITS
			; ACTUALLY IT IS A COPY OF THE LOW ORDER 12 BITS
			; OF THE ACCUMULATED READS FOR THIS JOB.
			; IT IS RESET TO NEW LOW ORDER TOTAL AFTER EVERY
			; "DISK" COMMAND.  IN THIS WAY ONLY ONE COUNT NEED
			; BE INCREMENTED EVERY READ INSTEAD OF TWO.
			; INCREMENTAL DISK BLOCKS READ IS COMPUTED BY:
			;  LDB T1,JBYRCT;LDB T2,JBYIRD;DPB T1,JBYIRD;SUB T1,T2
			;  ANDI T1,JBRIRD
  JBSIRD==^D12		;BYTE SIZE
  JBNIRD==^D11		;BYTE PTR POS.
  JBRIRD==1_JBSIRD-1	;BITS IN BYTE AFTER RIGHT JUSTIFIED
  JBSRCT==^D24		;BYTE SIZE
  JBNRCT==^D35		;BYTE PTR POS
JBTWCT:	BLOCK	JOBN	;NO. OF DISK BLOCK WRITTEN ON ALL STRS SINCE JOB LOGGED IN
			;JOB 0=SWAP WRITE ON ALL UNITS
  JBSIWT==^D12		;BYTE SIZE
  JBNIWT==^D11		;BYTE PTR POS
  JBRIWT==1_JBSIWT-1	;BITS IN BYTE AFTER BEING RIGHT JUSTIFIED
  JBSRCT==^D24		;BYTE SIZE
  JBNRCT==^D35		;BYTE PTR POS

JBTMPC:	BLOCK JOBN	;NO. OF PAGES MAPPED BY USER DOING A
			;MAP UUO.

JBTPWS:	BLOCK JOBN	;NO. OF PAGES USER HAS PUT INTO THE UWS.

JBTPWH: BLOCK JOBN	;HIGH PART OF NO. PAGES INTO UWS TIMES
			;SIZE.
JBTPWL: BLOCK JOBN	;LOW PART OF NO. PAGES INTO UWS TIMES
			;SIZE.
JBTDAB::BLOCK	<JOBN-1>*DABSIZ ;DUMMY ACCESS TABLES. SEE ATB DEFINITIONS
			; FOR DATA FORMAT.


SYSEN3==.-1		;LAST LOCATION CLEARED BY ACCINI ON 143 (RE)START

JBYIRD:	POINT JBSIRD,JBTRCT(J),JBNIRD	;BYTE POINTER
JBYRCT:	POINT JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINTER
JBYIWT:	POINT JBSIWT,JBTWCT(J),JBNIWT	;BYTE POINTER
JBYWCT:	POINT JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINTER


;STT - SAT TABLE FOR SATS IN CORE AND DISK FOR A UNIT.
;THERE IS ONE ENTRY FOR EACH SAT ON THE UNIT, EVEN THOUGH NOT
;ALL SATS ARE KEPT IN CORE.
;THERE IS AN EXTRA ZERO WORD TO MARK THE END OF EACH STT.
;
;AN ENTRY CONSISTS OF:

INTERNAL STTFPC,STTPTR,STTAOB,STTSTS,STTLEN,STYINC,STYBAD,STYCHK
INTERNAL STPINC,STPBAD,STPCHK,STPRPT

STTPTR==0	;DISK POINTER TO THIS SAT.
STTFPC==1	;FREE PAGE COUNT.
STTAOB==2	;AOBJN WORD.  (NOT REALLY.  REALLY THE LH/
		;-BIT NO IN WORD AND RH/WORD WRS START OF SAT.).
STTSTS==3	;BITS OF INTEREST.
  STYINC: POINT 1,STTSTS(T2),1	;ON IF SAT IS IN CORE IN A PCB.
  STPINC==200000
  STYBAD: POINT 1,STTSTS(T2),2	;ON IF SAT IS BAD.
  STPBAD==100000
  STYCHK: POINT 1,STTSTS(T2),3	;ON IF SAT HAS BEEN CHECKED.
  STPCHK==40000
  STPRPT==20000	;ON IF THE SAT NEEDS TO BE REPORTED AS BAD.

STTLEN==STTSTS-STTPTR+1


;"SYS" - SYSTEM WIDE QUANTITIES
; NO SPECIAL PREFIX

INTERN	MFDPPN,SYSPP,FSFPPN,SPLPPN,SYSDRB
	INTERNAL ACTPPN,CBUSER,CBADR,CNTBLK
INTERN	SYSDOR,SYSCOR
INTERN	STNPRT,CUSPPP,DUMPPP,HELPPP,SYSPP,QUEPPN
INTERN  SYSUNI,LVDTBL,LVDMXL,UFDPRT,SYSPPN,CORNUM,QUESTR,CRUPPN
INTERN  ETSUNI,ETSGTI,ETSBDT,ETSDCO,ETSDCA,ETSBCN,ETSCCO,ETSCCA
INTERN  ETSTAB,METSLN

LVDTBL:!	;GETTAB TABLE NO. 16(OCTAL)-LEVEL D DISK PARAMTERS

MFDPPN:	XWD 1,1		;(0)PROJECT-PROGRAMMER NUMBER FOR STORING UFDS ONLY
			;  (ALL OTHER FILE STRUCTURE FILES ARE STORED IN DEVICE SYS
			;  (SEE SYSPPN))
CUSPPP:
SYSPP:
SYSPPN:	XWD 1,4		;(1)PROJ-R NO. FOR DEVICE 'SYS' (I.E. CUSPS,LIBRARY)
			;  DIRECTORIES ARE STORED IN MDFPPN
DUMPPP:
FSFPPN:	XWD 1,2		;(2)PROJ-R NO. FOR FAILSAFE - ALL PRIVILEGED PROGRAM

HELPPP:	XWD 2,5		;(3)SYSTAT AND HELP RUN UNDER THIS NUMBER
			;  (IF NOT ALREADY LOGGED IN)
QUEPPN:
SPLPPN:	XWD 11653,115244;(4)PROJ-R NO. FOR PRINTR SPOOLING PROGRAM

SYSDRB:	XWD 0,0		;(5)LH=FIRST DRB IN FILSER FREECORE
			;  [THIS NEXT COMMENT LOOKS OBSOLETE.../AAA]
			;  RH=CORE ADDRESS OF NEXT PPB BLOCK TO SCAN
			;  NAME LIST TO RECLAIM GRABBABLE NMB BLOCK
			;  IF RH=0 CORE GRABBER SHOULD START OVER AT BEGINNING
			;  OF PPB LIST (I.E., LH OF SYSPPB)

	0		;(6) NOT USED

SYSUNI:	XWD FIRUNI,UNISYS;(7)LH=CORE ADDRESS(DOWNWARD POINTER)OF FIRST UNIT
			;  RH UNUSED
			;  DATA BLOCK IN SYSTEM
			;  RH=UNUSED.

	XWD	0,0	;(10) PLACE HOLDER FOR OBSOLETED ENTRY
FFCBLK==JOBN*<2+<2*OPNFPF>> ;  FILSER FREE CORE BLKS SYSTEM-WIDE. FOR
			;  EACH JOB ASSUME 2 DRB'S (LOGGED-IN AND GFD'D
			;  DIRECTORY).  FOR EACH OF THE OPNFPF FILES
			;  ASSUMED, EXPECT 1 ATB AND 1 FNB.
IFL FFCBLK-^D50,<FFCBLK==^D50>	;INSURE AT LEAST 50 FILSER BLOCKS
				; EVEN IF JUST A 1 JOB SYSTEM

CORNUM:	EXP FFCBLK	;(11)# PERMANENT FILSER CORE BLOCKS GENERATED AT ONCE ONLY TIME

STNPRT:	XWD PRVFIL*1000,0;(12)STANDARD PRIVILEGE

UFDPRT:	XWD PRVUFD*1000,0;(13)STANDARD UFD PRIVILEGE
			;  SYMBOL PRVUFD SHOULD NOT BE USED. INSTEAD
			;  UFDPRT SHOULD BE USED, SO CAN PATCH STANDARD.

INTERN  NMSTPC,NMRBPC

IFNDEF RPCBN,<RPCBN==7>
IFLE <RPCBN-4>,<RPCBN==5>
NMRBPC: EXP RPCBN	;(14) NO. OF SYSTEM-TIME PCBS FOR RIBS (CAN
			;  BE CHANGED AT ONCE ONLY TIME.

IFNDEF SPCBN,<SPCBN==17>
IFLE <SPCBN-4>,<SPCBN==5>
NMSTPC: EXP SPCBN	;(15) NO. OF SYSTEM-TIME PCBS FOR SATS (CAN
			;  BE CHANGED AT ONCE ONLY TIME.

QUESTR:	0		;(16) SIZBIT NAME OF FILE STRUCTURE
			;  FOR QUEUEING PROGRAMS LIKE PRINT,UMOUNT, ETC
			;  SETUP BY MANDATORY ONCE ONLY CODE TO BE
			;  THE FIRST(FASTEST) STR WHICH IS UP(TABSTR(0)).

ACTPPN:	XWD 6,270	;(17)ACCOUNTING, JL ON CAN ACCESS THESE

CRUPPN:	XWD	10,1	;(20) UFD FOR DUMPING CRASHES

LKBSIZ:	EXP UUXENT	;(21) SIZE OF LARGEST MEANINGFUL
			;  EXTENDED LOOKUP BLOCK

LVDMXL==<.-LVDTBL-1>B26	;END OF GETTAB TABLE


;SYSTEM VARIABLES NOT IN GETTAB:

SYSDOR:	XWD 0,0		;BEGINNING OF DORMANT ACCESS BLOCK LIST FOR SYSTEM
			;LH=ADDRESS OF FIRST DORMANT ACCESS BLOCK IN SYSTEM
			;LH=0 IF NO DORMANT ACCESS BLOCKS
			;RH=ADDRESS OF LAST DORMANT ACCESS BLOCK IN SYSTEM
SYSCOR:	XWD .,ZERO18	;BEGINNING OF PERMANENT FILSER CORE BLOCK LIST
			;LH=ADDRESS OF FIRST FREE FILSER CORE BLOCK,RH=0 ALWAYS
			; IF NO FREE BLOCKS, WHOLE WORD=0.
			; BLOCKS ARE LINKED TOGETHER BY CORLNK WORD.

CORBAS::0		;CONTAINS BASE ADDRESS OF FILSER CORE BLOCKS
			; FOR ATB POINTER COMPUTATIONS.
INTERN MFDRIB
MFDRIB:	0		;RETRIEVAL POINTER TO PRIME RIB OF MFD.

;SOFTWARE ERROR TESTING - SET AND CLEAR SELECTED CONI OR DATAI ERROR BIT
; N TIMES AFTER M TIMES
; .FSETS M ARGS ARE IN SAME ORDER AS BELOW:
ETSUNI:	0		;(0) CONTAINS UNIT DATA BLOCK ADDRESS OF
			; A UNIT WHICH IS BEING ERRROR TESTED WITH
			; .FSETS UUO.  IF THIS LOC CONTAINS 0, NO
			; ERROR TESTING (FOLLOWING LOC ARE IGNORED)!
ETSTAB:			;0TH ENTRY FOR ARG PICKUP LOOP
ETSGTI:	0		;(1)NO, OF GOOD TRANSFER INTERRUPTS BEFORE BAD TIMES
ETSBDT:	0		;(2)NO. OF BAD DATAI BEFORE CLEARING ETSUNI
ETSDCO:	0		;(3)ERROR DATAI BITS ORED WITH DATAI BITS
ETSDCA:	0		;(4)ERROR DATAI BITS ANDCMED WITH DATAI BITS
ETSBCN:	0		;(5)NO. OF BAD CONI BEFORE CLEARING ETSUNI
ETSCCO:	0		;(6)ERROR CONI BITS ORED WITH CONI BITS
ETSCCA:	0		;(7)ERROR CONI BITS ANDCMED WITH CONI BITS
ETSLEN==.-ETSTAB	;LENGTH OF .FSETS ARGS
XP METSLN,-ETSLEN

CBUSER:	0		;USER OF CB QUE (FOR ERROR TRACING)
;ALL THE FOLLOWING HAVE F IN LH ADR OF CALL IN RH FOR ERROR TRACE
CBADR:	0
CNTBLK:	0

CNTFLN:	SIXBIT /CNTBLK/

	1,,0
	.LINK 1,.-1
	CNTBLK,,CNTFLN

			; DEVICE SYS. (4 BIT BYTES ENDED WITH BYTE FSNEND
			; OR OFF THE END OF WORD, IE MAX OF 9 BYTES)


;BAD ALLOCATION FILE.

; A (DUPLICATED) PAGE IN HOME.SYS.
; PROGRAMS SEARCHING HOME.SYS SHOULD LOOK FOR SIXBIT IDENTIFICATION IN
; FIRST WORD OF EACH PAGE.

INTERNAL BATNBB,BAYNBB,BA1NBB,BATREG,BATFIR,BRMAX,BATPAT
INTERNAL CODBAT,BANNBB,BASNBB,BATNAM,BATSLF,BATCOD
INTERNAL BATCNT,BATELB

BATNAM==PAGNAM	;CONTAINS SIXBIT /BAT/ FOR IDENTIFICATION
	BATNUM==777		;MAX NUMBER OF BAD PAGES IN A REGION-1
BATFIR==1	;LH=-MAX. POSSIBLE NO. OF WORDS FOR BAD REGIONS MAP AND MONITOR
		; CAN ADD BEFORE PAGE FILLS UP
		;RH=REL ADR. WITHIN THIS PAGE OF FIRST BAD REGION PAIR
		; MAP R FORCES LH TO BE EVEN NUMBER.
		;ALL PROGRAMS SHOULD SCAN THE BAT PAGE BY STARTING WITH THIS WORD
		; RATHER THAN KNOWING WHERE DATA PAIRS START.  IN THIS WAY
		; ADDITIONAL HEADER WORDS CAN BE ADDED WITHOUT INVALIDATING ANY
		; PROGRAMS WHICH READ BAT PAGE.
		;BOTH HALVES WRITTEN BY MAP PROGRAM AND NEVER CHANGED BY MONITOR
BATPAT==2		;TOTAL NUMBER OF BAD PAGES

BATCNT==3	;NO. OF DISTINCT BAD REGION WORD PAIRS

BATREG==4	;FIRST BAD REGION WORD GOES HERE. THIS SYMBOL NEVER APPEARS IN ANY
		; CODE WHICH READS BAT PAGE - EXCEPT MAP PROGRAM OR OPTIONAL ONCE
		;ONLY CODE WHICH WRITES IT THE FIRST TIME.  INSTEAD SEE RH OF BATFIR
		;NOTE: BATREG MUST BE AN EVEN NUMBER



;THE MAP PROGRAM IS NOT PART OF THE MONITOR - IT RUNS AS A STAND-ALONE PROGRAM
; WHICH WRITES AN INITIAL BAT PAGE WITH ALL THE BAD REGIONS IT FINDS.
;BOTH THE MAP PROGRAM AND THE MONITOR WRITE TWO WORD ENTRIES OF THE SAME FORMAT
;THE MONITOR ADDS TWO-WORD ENTRIES WHENEVER IT FINDS BAD REGIONS
;WHILE READING, WRITING, OR POSITIONING (READ OR WRITE)
;THE MAP R AND MONITOR STORE LOGICAL RATHER THAN PHYSICAL ADDRESSES

BATNBB==0	;NUMBER OF BAD PAGES-1 IN THIS BAD REGION(NOT CLUSTERS
		; -SINCE BADNESS IS INDEPENDENT
		; OF THE CLUSTER SIZE - WORD ADR(WITHIN 2 WORD ENTRY)
  BASNBB==^D9	;BYTE SIZE
  BANNBB==^D8	;BYTE PTR. POS.
MAPBIT==1B9	;ALWAYS ON TO ENSURE THAT THIS WORD IS NON-ZERO
BAYNBB:	POINT BASNBB,BATNBB(T2),BANNBB	;BYTE PTR
BA1NBB: POINT BASNBB,%RIB+BATNBB(T1),BANNBB	; Used in (CORE1)
;BITS 18-35 ARE DATE OF ENTRY

BATELB==1	;ERROR LOGICAL PAGE ADR. WITHIN UNIT - WORD ADR. (WITHIN 2 WORD ENTRY)
		; OF FIRST LOGICAL PAGE IN BAD REGION OF PAGES
BATCOD==PAGCOD	;CONTAINS UNLIKELY CODE
		;LH=0
CODBAT==505050	;UNLIKELY CODE FOR BAT PAGE
BATSLF==PAGSLF	;LH=0, RH=THIS PAGE(NOT CLUSTER) AADR. WITHIN UNIT

BRMAX==BATCOD-BATREG	;MAX LENGTH OF AREA FOR APPENDING BAD REGIONS


;DEFINE PROTECTION LEVELS AND UFD PROTECTION BITS

;UFD

UFRXLK==4	;"TRANSPARENT" UFD
UFRXCR==2	;CAN CREATE NEW FILE
UFRXRD==1	;CAN READ UFD AS A FILE

INTERNAL UFRXLK,UFRXCR,UFRXRD

;PROTECTION FUNCTIONS. NESTED

FNCLOK==1	;LOKUP ONLY
FNCEXC==2	;EXECUTE
FNCRED==3	;READ
FNCAPP==4	;APPEND
FNCUPD==5	;UPDATE
FNCCRE==6	;CREATE
FNCCAT==7	;CHANGE ATRIBUTES
FNCCNM==10	;CHANGE NAME
FNCCPR==11	;CHANGE PROTECTION
FNCSUP==12	;SUPERCEDE
FNCTRN==13	;TRUNCATE
FNCDEL==14	;DELETE

INTERNAL FNCLOK,FNCEXC,FNCRED,FNCAPP,FNCUPD,FNCCRE
INTERNAL FNCCAT,FNCCNM,FNCCPR,FNCSUP,FNCTRN,FNCDEL


;CHN:	CHANNEL DATA BLOCK

;THESE LOCATIONS ARE SET, LOOKED AT AND CHANGED
;BY FILSER. DEVICE DEPENDENT MODULES DO NOT LOOK AT THEM.
;PARAMETERS FOR CHNCB:

	DEFINE	CHNCB <

INTERN CHNBSY

$CHUNN==0	;UNIT NUMBER WITHIN CHANEL
$KCHNN==0	;KONTROLER NUMBER WITHIN CHANNEL

REPEAT %KNCHN(\$CHN,FH),<KONTCB FH>
REPEAT %KNCHN(\$CHN,DP),<KONTCB DP>
REPEAT %KNCHN(\$CHN,MD),<KONTCB MD>
REPEAT %KNCHN(\$CHN,RM),<KONTCB RM>
REPEAT %KNCHN(\$CHN,AP),<KONTCB AP>

IFN $CHUNN,<NMCHUN(\$CHN,\$CHUNN)==NMCHUN(\$CHN,0)>

%NCH(INTERNAL,\$CHN)
CHNBSY==0	;;MAKE SURE FIRST ENTRY IN DATA BLOCK ELSE MACRO ERROR
NMCH(\$CHN):0	;;0 IS IDLE, NEGATIVE IS BUSY
		;; MUST BE WORD 0 OF CHN DATA BLOCK
		;; SO AOSG @KONCHN(J) WILL TEST BUSY AND SET
		;; BUSY IN ONE INSTRUCTION
NMKCN(\$CHN,\$KCHNN)==0
$CHN==$CHN+1
>	;END MACRO DEF OF CHNCB


;SA-10 DATA BLOCKS AND CHANNEL DATA BLOCKS

COMMENT ;

THE SA-10 STRUCTURE IS CONTROLLED BY THE FOLLOWING SYMBOLS.
SAXN IS THE NUMBER OF SA-10'S CONNECTED TO THE SYSTEM
FOR EACH SA-10 (#=THE NUMBER OF THE SA-10)
SAX# IS THE DEVICE MNEMONIC
SA#INT IS THE INTERUPT LOCATION

SAXC#N IS THE NUMBER OF CHANNELS ON THIS SA-10
BP<#1><#2> IS THE NUMBER OF 3330'S ON THE CHANNEL WHERE
<#1> IS THE SA-10 NUMBER AND <#2> IS THE CHANNEL NUMBER
FT<#1><#2> IS THE NUMBER OF 3420'S (MAGTAPES)
;

	DEFINE SAXCB (NUM)
<$SAXCN==0
;GENERATE THE CHANNEL BLOCKS

	REPEAT SAXC'NUM'N,<SACCB (NUM,\$SAXCN)>

SA'NUM'INT: CONSO SAX'NUM,1B18
	JRST .
	JSR SAXSAV
	JSP M,SAXINT

SAX'NUM'CB: 
	PHASE 0
SAXCNI:!	CONI SAX'NUM,T1
SAXCNO:!	CONO SAX'NUM,(T1)
SAXDTI:!	DATAI SAX'NUM,T1
%%XXQ=0
SAXCHL:!	REPEAT SAXC'NUM'N,<NMSCH(NUM,\%%XXQ)
	%%XXQ==%%XXQ+1>
	REPEAT 4-SAXC'NUM'N,<0>

INTERNAL SAXCNI,SAXCNO,SAXDTI,SA'NUM'INT,SAXCHL
EXTERNAL SAXSAV
	DEPHASE
>

;NOW THE SA-10 CHANNEL BLOCK

	DEFINE SACCB(XNUM,CNUM)
<IFE BP'XNUM'CNUM+FT'XNUM'CNUM,<SC'XNUM'CNUM'CB==0>
IFN BP'XNUM'CNUM+FT'XNUM'CNUM,<
$SAXUN==0	;NUMBER OF UNITS (MAX)
$CHUNN==0	;ALSO NUMBER OF UNITS BUT ACTUAL NOT MAX
$KCHNN==0
	REPEAT BP'XNUM'CNUM,<KONTCB (BP)>
	REPEAT FT'XNUM'CNUM,<KONTCB (FT)>
IFN BP'XNUM'CNUM,<NMCHUN(\$CHN,\$CHUNN)==NMCHUN(\$CHN,0)>
NMKCN(\$CHN,\$KCHNN)==0
SC'XNUM'CNUM'CB:
NMCH(\$CHN):
	PHASE 0
	0	;NORMALLY CHANNEL BUSY
CHNSTB:!	SAXBAS+XNUM*^D16+CNUM*4+1
CHNGO:!	CONO SAX'XNUM,4B29+1B30+<CNUM>B32+SAXCHN
CHNCLR:!	CONO SAX'XNUM,6B29+<CNUM>B32+SAXCHN
CHNIIE:!	CONO SAX'XNUM,7B29+1B30+<CNUM>B32+SAXCHN
CHNMER:!	Z
CHNACT:!	Z
CHNKON:!	NMKCN(\$CHN,0)
CHNBMX:!REPEAT $SAXUN,<-1>
	0	;BLOCK MULTIPLEXOR LIST
	DEPHASE
$CHN==$CHN+1
INTERNAL CHNSTB,CHNGO,CHNCLR,CHNIIE,CHNACT,CHNKON,CHNBMX,SC'XNUM'CNUM'CB
INTERNAL CHNMER
EXTERNAL SAXBAS,SAXCHN
>
$SAXCN==$SAXCN+1>


;CONTROLER NUMBERS




;SA10 COMMON INTERUPT CODE
EXTERNAL EPT,CURUPT

IFN SAXN,<
SAXINT:	XCT SAXCNI(M)	;READ
	TRNE T1,1B19!1B20	;IS IT MEMERROR
	JRST SAXMEM	;YES
	ANDI T1,170	;GET INTERUPT REQUEST FLAG
	JFFO T1,.+2
	STOPCD	;MUST BE ONE OF THEM
	MOVE T1,T2
	ADDI T1,SAXCHL-^D29(M)
	SKIPN PG,(T1)	;GET POINTER TO CHANNEL
	JRST SAXIGN	;UNREC CHANNEL, DISMIS IT
	AOS	CHNACT(PG)	;CHANNEL ACTIVE.
	LDB T2,[POINT 8,@CHNSTB(PG),23]	;GET UNIT
	HRRZ J,CHNKON(PG)	;START OF CHAIN
	JUMPE J,SAXIGN	;NO KONTROLERS SHOULD BE THERE
SAXLP1:	HRRZ T3,KONBSU(J)	;GET BASE ADDRESS
	CAMGE T2,T3	;IS IT THE SAME?
	JRST SAXLP2
	HRRZ T3,KONUMX(J)	;MAX UNIT ADDRESS
	CAMGE T2,T3
	JRST @KONSNT(J)	;YES, GET TO INTERUPT CODE
SAXLP2:	HLRZ J,KONCHN(J)	;MOVE DOWN CHAIN
	JUMPN J,SAXLP1
SAXIGN:	SUBI T1,SAXCHL(M)
	LSH T1,3
	IORI T1,6B29+SAXCHN	;GET SET TO DISMISS
	XCT SAXCNO(M)
	POPJ P,

SAXMEM:	MOVE T2,T1
	MOVEI T1,2B32+SAXCHN	;GET SET TO FIND CORRECT CHANNEL
	XCT SAXCNO(M)
	XCT SAXDTI(M)
	LDB T1,[POINT 2,T1,17] ;GET NO. OF CHANNEL WITH BAD MEMORY REF.
	ADDI T1,SAXCHL(M)
	SKIPN PG,(T1)		;GET R=CHAN DDB ADDRESS.
	STOPCD		;MUST BE ON A REAL CHANNEL OR NOT RUNNING
	ANDI T2,7B20	;GGET BITS
	HRLZS T2
	IORM	T2,CHNSTB(PG)	;STORE IT HERE.
	HLLM	T2,CHNMER(PG)	;SET UP 1ST 3 BITS OF CHNMER.
	MOVEI	T1,1B32		;GET PART
	XCT	SAXCNO(M)	;OF
	XCT	SAXDTI(M)	;THE
	MOVE	T2,T1		;MEMORY
	TLZ	T2,777774	;ADDRESS INTO T2.
	MOVEI	T1,5B32		;GET THE REST OF
	XCT	SAXCNO(M)	;THE
	XCT	SAXDTI(M)	;MEMORY ADDRESS
	DPB	T1,[POINT 2,T2,15] ;INTO T2 AND ALSO TO PART OF
	DPB	T2,[POINT ^D22,CHNMER(PG),^D24] ;CHNMER.
	MOVE	T1,T2		;REFERENCE
	LSH	T1,-9		;THE
	TRO	T1,PGE.A!PGE.P!PGE.W ;"BAD"
	DPB	T1,[EPTPGP(%ERR.N)] ;LOC TO
	CLRPTO	%ERR		;CRASH THE SYSTEM IF
	ANDI	T2,777		;IT IS REALLY
	MOVE	T2,%ERR(T2)	;BAD.
	MOVEI	T1,3B32		;GET MEM
	XCT	SAXCNO(M)	;BUFFER
	XCT	SAXDTI(M)	;LH AND XOR IT
	XORI	T2,(T1)		;INTO WORD IN T2.
	MOVEI	T1,2B32		;GET MEM
	XCT	SAXCNO(M)	;BUFFER
	XCT	SAXDTI(M)	;RH AND
	HRLZS	T1		;XOR IT
	XOR	T1,T2		;INTO T2.
	JFFO	T1,.+2		;FIND NO. OF 1ST BAD BIT.
	MOVEI	T2,^D36		;MARK NONE.
	DPB	T2,[POINT 6,CHNMER(PG),^D30] ;STORE NO.
	MOVE	T1,CHNGO(PG)	;CLEAR THE
	TRC	T1,7B29+1B19 	;MEM ERR AND
	XCT	SAXCNO(M)	;THE CHANNEL.
	POPJ	P,
>


REPEAT 0,<
A SERIES OF MACROS ARE INCLUDED HERE FOR GENERATING CHANNEL, KONTROLLER,
AND UNIT CORE BLOCKS.  THE VARIOUS CORE BLOCKS ARE LINKED TOGETHER
APPROPRIATELY; THE NUMBER OF EACH TYPE AND APPROPRIATE LINKAGE ARE
DETERMINED BY SYMBOLS GENERATED BY MONGEN.  SYMBOLS GENERATED ARE:

	CHNN	TOTAL NUMBER OF DATA CHANNELS (DF10) FOR DISKS
		CHANNELS ARE NUMBERED FROM 0 TO CHNN - 1

	CNFH	NUMBER OF FIXED HEAD KONTROLLERS ON CHANNEL N
	CNDP	NUMBER OF DISK PACK KONTROLLERS ON CHANNEL N
	CNMD	NUMBER OF MASS FILE (BRYANT DISK) KONTROLLERS ON CHANNEL N

		KONTROLLERS OF EACH TYPE ARE LETTERED A,B,C, ETC., SO
		THE FIRST DISK PACK KONTROLLER IS DPA, THE SECOND DPB, ETC.

	XXYUN	NUMBER OF UNITS ON KONTROLLER XXY

THE CHNCB MACRO GENERATES A CHANNEL CORE BLOCK, THEN CALLS MACROS TO
GENERATE KONTROLLER AND UNIT CORE BLOCKS.  ITS ARGUMENT IS THE CHANNEL NUMBER,
IN ASCII.  CHNCB CALLS MACRO KONTCB FOR EACH KONTROLLER ON THE CHANNEL.  THERE
IS A REPEAT LOOP FOR EACH KONTROLLER TYPE, REPEATED CNXX TIMES, WHERE N IS THE
CHANNEL NUMBER AND XX IS THE KONTROLLER TYPE, EACH LOOP CALLING KONTCB ONCE.
THE ARGUMENTS FOR KONTCB ARE THE KONTROLLER TYPE, A LIST CONTAINING THE LETTERS
TO IDENTIFY SUCCESSIVE KONTROLLERS, AND THE CHANNEL NUMBER, IN ASCII.

KONTCB FIRST CALLS MACRO XXKON TO GENERATE A KONTROLLER CORE BLOCK FOR THE
KONTROLLER, THEN REPEATS XXYUN TIMES CALLING UNITCB MACRO TO GENERATE UNIT CORE
BLOCKS FOR THE KONTROLLER.  ARGUMENTS FOR XXKON ARE KONTROLLER TYPE (XX),
KONTROLLER IDENTIFIER, AND THE ASCII VALUE OF SYMBOL XXNUM, WHICH IS INCREMENTED
FOR EACH KONTROLLER OF TYPE XX.  XXKON FORMS SYMBOL XX'XXNUM (XX0, XX1, ...),
WHICH IS USED AS THE DEVICE CODE FOR THE KONTROLLER.  ARGUMENTS FOR UNITCB
INCLUDE KONTROLLER TYPE, KONTROLLER IDENTIFIER, UNIT NUMBER, AND SYMBOLS TO USE
IN LINKING THE UNIT CORE BLOCKS TOGETHER (SEE UNITCB MACRO).

EACH XXKON MACRO SHOULD CALL THE KONKON MACRO FOR THE KONTROLLER INDEPENDENT
PART OF THE KONTROLLER CORE BLOCK.  ARGUMENTS FOR KONKON MACRO ARE KONTROLLER
TYPE (XX), KONTROLLER IDENTIFIER (Y), AND SYMBOL XX'NUM WHICH IS THE DEVICE CODE
FOR THE KONTROLLER.  NUM IS INCREMENTED FOR EACH KONTROLLER OF TYPE XX.

THE UNIT CORE BLOCKS ARE LINKED IN THREE DIFFERENT WAYS.  ALL UNIT CORE
BLOCKS ON A KONTROLLER ARE LINKED IN A RING (THE LAST POINTS TO THE FIRST),
ALL UNIT CORE BLOCKS ON A CHANNEL ARE LINKED IN A RING, AND ALL UNIT CORE
BLOCKS IN THE SYSTEM ARE LINKED IN A LIST (THE LAST LINK IS 0).  TO
COMPLETE THIS LINKAGE, KONTCB CALLS MACRO KONCLS TO CLOSE THE KONTROLLER
RING, AFTER ALL UNIT CORE BLOCKS FOR THAT KONTROLLER HAVE BEEN GENERATED; CHNCB
CALLS CHNCLS TO CLOSE THE CHANNEL RING; AND AFTER ALL SYSTEM UNIT CORE BLOCKS
HAVE BEEN GENERATED, SYSCLS IS CALLED TO TERMINATE THE SYSTEM LIST.

TO ADD ANOTHER KONTROLLER TYPE XY, YOU MUST ADD ANOTHER REPEAT LOOP IN CHNCB,
REPEATING CNXY TIMES AND PASSING ARGUMENT XY TO KONTCB MACRO.  KONTCB
CALLS MACRO XYKON FOR THE KONTROLLER DEPENDENT PART OF THE KONTROLLER CORE
BLOCK; THAT MUST ALSO BE SUPPLIED.  XYKON SHOULD CALL THE KONKON MACRO FOR
THE KONTROLLER INDEPENDENT PART OF THE KONTROLLER CORE BLOCK.
>


INTERN	KONERM,KOPOFL,KOPFUS

;DEVICE INDEPENDENT STUFF

KONERM==740000		;MASK FOR ERROR BITS RETURNED IN T1 ON NON-SKIP RETURNS
KOPOFL==400000		;'OFF-LINE' OR 'NOT-READY' OR 'FILE UNSAFE' BIT (LIGHTS UNPOFL IN UNIDES)
KOPFUS==200000		;FILE UNSAFE

DEFINE KONTCB(%TYP)
<KONCB1 (%TYP,<A,B,C,D,E,F,G,H,I,J,K,L>)>

	DEFINE KONCB1(%TYP,TYPL)
<$U==0
IRP TYPL,<IFE $U-$'%TYP'NUM,<STOPI
		IFN %TYP'TYPL'UN,<
			$KNUNN==0	;UNIT NUMBER IN KON
			REPEAT %TYP'TYPL'UN,<%TYP'ITCB (%TYP,TYPL,\$'%TYP'NUM)>
			NMKNUN(%TYP'TYPL,\$KNUNN)==NMKNUN(%TYP'TYPL,0)
			IFIDN <%TYP> <FT>,<NMFTDB(TYPL,\$KNUNN)==>
			%TYP'KON(TYPL,\$'%TYP'NUM)
			$KCHNN==$KCHNN+1>
	IFE %TYP'TYPL'UN,<$'%TYP'NUM==$'%TYP'NUM+1>
		>
	$U==$U+1
>>



;KONTROLLER DATA BLOCK DISK PACKS (ONE DEFINITION NO MATTER
;HOW MANY DISK PACK KONTROLLERS)

;RP10 - CONTROLLER FOR RP01(MEMOREX) DISK PACK UNIT AND/OR RP02
;  (MEMOREX) DISK PACK UNIT:

XP TYPDP,2		;ALWAYS DEFINE CONTROLLER TYPE CODE - SEE UNIKTP

DEFINE DPKON (TYPL,N)<
DPFIX==0			;;NOT A FIXED HEAD DEVICE (IF 0)
KONMXU==10
DPCHN==0
INTCON (DP,TYPL,DP'N)
EXTERNAL DP'N'CHN
KONKON (DP,TYPL,DP'N'CHN)
KONUNL (DP,TYPL)	;GENERATE UNIT LIST
DFCON(DP,TYPL,DP'N)

;;KONTROLLER TYPE DEPENDENT PART OF KONTROLLER DATA BLOCK
DPC==250			;;DEF DISK PACK CONTROLLER DEVICE CODE
DPC2==254			;;AND SECOND CONTROLLER(UNTIL ADDED TO MACRO)
DPINF==10			;;INTERRUPT FLAGS FOR CONSO INSTR.
				;;(DONE FLAGS)

IFNDEF	DP0,<DP0==DPC>		;;DEFINE STANDARD MNEMONIC DEFINITIONS
IFNDEF	DP1,<DP1==DPC2>		;;BUT ALLOW FOR OVERRIDE

	INTERN DPXCO1,DPXDOT,DPXDO1,DPXDI1,DPXCIT

DPXCO1:! CONO	DP'N,(T2)
DPXDOT:! DATAO	DP'N,T1
DPXDO1:! DATAO	DP'N,T2
DPXDI1:! DATAI	DP'N,T2
DPXCIT:! CONI	DP'N,T1
	DEPHASE
$DPNUM==$DPNUM+1
>	;;END MACRO DEF OF DPKON


;RC10 CONTROLLER FOR RD10(BURROUGHS) FIXED HEAD DISK UNIT AND/OR
; RM10B(BRYANT) DRUM UNIT:

XP TYPFH,1			;ALWAYS DEFINE KONTROLLER TYPE CODE - SEE UNIKTP

DEFINE	FHKON (TYPL,N)<

FHFIX==400000			;BIT 0 = 1 IF FIXED HEAD DEVICE
KONMXU==10	;MAX NUMBER OF UNITS THIS KONTROLER
FHCHN==0	;DOES REQUIRE CHANNEL
INTCON (FH,TYPL,FH'N)
EXTERNAL FH'N'CHN
KONKON (FH,TYPL,FH'N'CHN)
KONUNL (FH,TYPL)
DFCON (FH,TYPL,FH'N)

FHD==170
FHD2==174
FHINF==10			;INTERRUPT FLAGS FOR CONSO INSTR.
				;;(DONE FLAG)

IFNDEF	FH0,<FH0==FHD>
IFNDEF	FH1,<FH1==FHD2>

	INTERN	FHXCI1,FHXCOT,FHXCO1,FHXDI2,FHXDOT,FHXIWD

FHXCI1:!CONI	FH'N,T2
FHXCOT:!CONO	FH'N,(T1)
FHXCO1:!CONO	FH'N,(T2)
FHXDI2:!DATAI	FH'N,T3
FHXDOT:!DATAO	FH'N,T1
FHXIWD:!0			;INITWD STORAGE

	DEPHASE
$FHNUM==$FHNUM+1
>	;END MACRO DEF OF FHKON



;3330 CONTROLER

	DEFINE BPKON(TYPL,N)
<BPFIX==0
BPCHN==400000
TYPBP==4	;TYPE 4

KONMXU==BP'TYPL'MX

	KONKON(BP,TYPL,0)
	KONSAX(BP,TYPL,N)
BPXCUB:!	0	;KONTROL UNIT BUSY BITS
	KONUNL (BP,TYPL)
	DEPHASE

INTERNAL BPXCUB
$BPNUM==$BPNUM+1
>

	DEFINE KONSAX(%TYP,TYPL,N)
<
KONBSU:!	XWD NMSCH(\$SAXN,\$SAXCN)+CHNBMX+$SAXUN,%TYP'TYPL
KONBMX==KONBSU	;L.H. POINTER TO BLOCK MULTIPLEX AREA FOR KON
		;R.H. BASE UNIT ADDRESS
KONUMX:! %TYP'TYPL+KONMXU
KONSNT:!%TYP'XINT	;POINTER TO INTERUPT ROUTINE
$SAXUN==$SAXUN+KONMXU
INTERNAL KONBSU,KONBMX,KONSNT
EXTERNAL %TYP'XINT
>

;Macro to generate data blocks for the 2020 disk system.
DEFINE RMKON(TYPL,N)
<RMFIX==0		;Not fixed head.
RMCHN==0		;Operations require channel to be idle
KONMXU==8		;Maximum number of units on this controller
	KONKON(RM,TYPL,0)
	KONUNL(RM,TYPL)
KONCUA:!ZERO18,,0	;UDB of transferring unit
	DEPHASE
INTERN KONCUA
$RMNUM==$RMNUM+1
>

;FOR APX AMPEX F3 DISKS

DEFINE APKON(TYPL,N)<
APFIX==0		;NOT FIXED HEAD
APCHN==0		;CHANNEL MUST BE IDLE
KONMXU==4		;MAXIMUM NUMBER OF UNITS IS 4
	KONKON(AP,TYPL,0)
	KONUNL(AP,TYPL)
KONCUA::!ZERO18,,0	;UDB OF XFERRING UNIT
	XP BLMSIZ,<^D8*^D10>
KONBLM::!BLOCK BLMSIZ+1	;;LIST OF MEMORY ADDRESSES
			;; (IN FORMAT OF LMA DISK INSTRUCTION)
			;; MUST BE ENOUGH TO HOLD ENTIRE CYLINDER.
			;; ONE EXTRA SO THAT ZERO TERMINATES THE LIST.
KONNLM::!BLOCK 1	;PLACE TO STORE ADDRESS OF NEXT LMA TO DO AT IRP LEVEL
KONNLD::!BLOCK 1	;PLACE TO STORE LDA DATA FOR NEXT XFER TO START AT IRP LEVEL
KONNL1::!BLOCK 1	;;COPY OF KONNLD WITH SU SET TO MAKE STARTING XFER FASTER

KONXFR::!BLOCK	1	;;INSTRUCTION TO EXECUTE AFTER A TRANSFER
KONNRM::!BLOCK 1	;;PLACE TO STORE VALUE WE EXPECT ON RMA AT END OF XFER.
			;; (SO DON'T WASTE PRECIOUS INSTRUCTIONS BETWEEN
			;; TRANSFERS OF A CHAIN.
KONNCM::!BLOCK 1	;PLACE TO STORE LCMD DATA FOR NEXT XFER (USUALLY SAME)
KONLRC::!BLOCK 1	;;PLACE TO REMEMBER RCMD OF LAST XFER TO INTERRUPT
KONLRM::!BLOCK 1	;;LAST RMA FOR XFER TO INTERRUPT
KONLRD::!BLOCK 1	;;LAST RDA FOR LAST XFER TO INTERRUPT
	DEPHASE
$APNUM==$APNUM+1
>

;3803 KONTROLLER FOR 3420'S

DEFINE FTKCHN(XX)
<XX==1B32
REPEAT 3-$SAXCN,<XX==XX*2>
>

	DEFINE FTKON(TYPL,N)
<FTFIX==0
FTCHN==0
TYPFT==0

KONMXU==10

	KONKON(FT,TYPL,0)
	KONSAX(FT,TYPL,N)
$SAXUN==$SAXUN+1  ;FOR SPECIAL SENSE LOC.
	KONUNL (FT,TYPL)

	DEPHASE

;OVERLAYING HERE.
	IFL KONLEN-FTXSMY+FTXMCH,<
PRINTX ERROR IN FTKON OVERLAY OF KONT. DB.  SEE COMMOD AT THIS PRINTX.
>
	STAR==.
	RELOC FT'TYPL'CB
	PHASE 0
	FTKCHN YY
FTXMCH:! XWD FT'TYPL'TYP,YY	;TYPE INFO,, CHN NO AS STAT FLG.
FTXBSY:! 0
FTXSNS:! BYTE(8)72,4,FT'TYPL	;SENSE.
FTXDAT:! BYTE(1)1(11)-^D24(24)FTXSTS+FT'TYPL'CB ;INFO TO FTXSTS.
FTXHLT:! Z			;HALT
FTXSS1:! Z
FTXSS2:! Z
FTXSM0:! Z
FTXSMY:! Z			;MEM ERR FLAG,, BUSY BITS
	DEPHASE
	RELOC STAR
	PHASE STAR-FT'TYPL'CB
FTXSTS:! Z
	Z
	Z
	Z
	Z
	Z
FTXSPR:! Z
FTXSP1:! Z
FTXSX1:! Z				;MOST RECENT SAXBAS+1(+5, ETC.)
	DEPHASE

INTERNAL FTXMCH,FTXBSY,FTXSNS,FTXSS1,FTXSPR,FTXSP1,FTXSX1
INTERNAL FTXSS2,FTXSMY,FTXSTS,FTXSM0

$FTMODE==1_D+1_DR+1_B+1_IB+1_I+1_AL+1_A

EXTERNAL MTSIZ
EXTERNAL FTADSP

$FTNUM==$FTNUM+1
>


	DEFINE INTCON (%TYP,TYPL,SYM)

<	EXTERNAL %TYP'XINT,SYM'SAV
	INTERNAL SYM'INT,KONINT

SYM'INT: CONSO	SYM,%TYP'INF		;;(4)SKIP IF INTERRUPT FOR THIS KONTROLLER
				;;ALWAYS HAVE INTERRUPT ROUTINE LOOKING FOR INTERRUPS
				;;THIS FLAG NEVER CLEARED (NEEDED FOR DISK PACKS
				;;OPERATOR MOUNTING AND REMOVING PACKS)
	JRST	.		;;(-3)GO TO NEXT SKIP CHAIN ELEMENT
	JSR	SYM'SAV		;;(-2) SAVE INTERRUPT ACS
	JSP	J,%TYP'XINT	;;(-1) SETUP ADDRESS OF KONTROLLER DATA BLOCK
				;; AND BRANCH INTO CODE WHICH IS COMMON
				;; TO ALL KONTROLLERS OF SAME TYPE
				;; (INTERRUPT DISMISSED BY EXTRA POPJ OR JRST XXRET)
KONINT==SYM'INT-.		;;INDEX TO CLEAR AND SET INTERRUPT CONSO FLAGS
>
	DEFINE KONUNL (%TYP,TYPL)
<;GENERATE UNIT LIST FOR KONTROLLER

	%%KONUS==.
	DEPHASE
%TYP'TYPL'CU:

$U1==0
	REPEAT %TYP'TYPL'UN,<
	NMUN(\$U1,%TYP'TYPL)
	$U1=$U1+1>
	BLOCK KONMXU-$U1	;UNIT ADDRESSES
	PHASE %%KONU+KONMXU
>


;KON:	KONTROLLER DATA BLOCK
;DEFINE FIRST PART OF KONTROLLER DATA BLOCK
;WHICH IS THE SAME FOR ALL KONTROLLER DATA BLOCKS

;FOR EACH KONTROLLER IN SYSTEM:
; PARAMETERS FOR KONKON
; %TYP  - KONTROLLER TYPE (ASCIZ) EG. DP,FH,DR,MD
; TYPL   - KONTROLLER NUMBER SYMBOL (ASCIZ) EG. A,B,C
; SYM - KONTROLLER SYMBOL (ASCIZ) EG. DP0,DP1,FH0,FH1

DEFINE	KONKON (%TYP,TYPL,SYM)<

	INTERN KONPOS,KONRED,KONWRT,KONADD,KONFIN,KONCPY,KONRCL
	INTERN KONLTM,KONCHN,KONPTR,KONOFS
	INTERN KOYPI,KONUPA,KONDWN,KOPDWN,KONSTP,KONHRD,KONSFT

				;; FROM DEV. DEP. CODE
%TYP'TYPL'CB::!	PHASE	0	;;CHANGE PHASE SO CAN DEFINE ALL SYMBOLS
				;; RELATIVE TO BEGINNING OF KONTROLLER
				;; DATA BLOCK. ALSO A CHECK TO BE SURE ALL
				;; KONTROLLER DATA BLOCKS ARE DEFINED THE
				;; SAME WAY.

NMKCN(\$CHN,\$KCHNN)==%TYP'TYPL'CB



;;MACRO DEFINITION CONTINUED
;;ENTRY POINTS INTO KONTROLLER TYPE DEPENDENT CODE:
;;INDIRECT AND INDEX FIELDS MUST BE 0 SINCE PUSHJ P,@KONYYY(J)
;; IS USED TO CALL

IFDIF <%TYP> <FT>, <EXTERN %TYP'XRED,%TYP'XWRT,%TYP'XADD
    EXTERN %TYP'XFIN,%TYP'XPOS,%TYP'XLTM,%TYP'XUPA,%TYP'XCPY
    EXTERN %TYP'XRCL,%TYP'XSTP,%TYP'XOFS,%TYP'XHRD,%TYP'XSFT>

IFIDN <%TYP> <FT>, <%TYP'XRED==0
		%TYP'XWRT==0
		%TYP'XADD==0
		%TYP'XFIN==0
		%TYP'XPOS==0
		%TYP'XLTM==0
		%TYP'XUPA==0
		%TYP'XCPY==0
		%TYP'XRCL==0
		%TYP'XSTP==0
		%TYP'XOFS==0
		%TYP'XHRD==0
		%TYP'XSFT==0
		>

KONRED:!XWD SYM_^D15,%TYP'XRED	;;ENTRY POINT TO READ
KOBPI==KONRED			;;PI CHANNEL THIS KONTROLLER IS ASSIGNED TO-WORD ADR.
  KOSPI==^D3			;;BYTE SIZE
  KONPI==^D2			;;BYTE PTR POS.
KONWRT:!XWD ZERO5,%TYP'XWRT	;;ENTRY POINT TO WRITE
KONADD:!XWD ZERO5,%TYP'XADD	;;ENTRY POINT TO READ,STOP ON ERR
KONFIN:!XWD ZERO5,%TYP'XFIN	;;ENTRY POINT TO WRITE,STOP ON ERR
KONPOS:!XWD %TYP'FIX!ZERO5,%TYP'XPOS ;;ENTRY POINT TO POSITION-BIT 0=1 IF FIXED HEAD DEV.
KONLTM:!XWD %TYP'CHN,%TYP'XLTM	;;ENTRY POINT TO RETURN TIME TO BEGINNING OF TRANSFER
				;; I.E. LATENCY TIME
KONUPA:!XWD ZERO5,%TYP'XUPA	;;ENTRY POINT TO TEST IF KONTROLLER IS ON-LINE
KONDWN==KONUPA			;;BIT0=1 IF KONTROLLER IS DOWN - WORD ADDRESS
  KOPDWN==400000		;; THE BIT (SET BY KONCHK - NOT BY %TYP'XUPA)
				;;KONTROLLER WAS OFF-LINEWHEN SYSTEM STARTED
				;; AND OPERATOR COULD NOT PUT IT ON-LINE
				;; SKIP RETURN IF YES, NO SKIP IF NOT

KONCPY:!XWD ZERO5,%TYP'XCPY	;;ENTRY POINT TO DETERMINE TYPE & CAPACITY OF UNIT
KONRCL:!XWD ZERO18,%TYP'XRCL	;;ENTRY POINT TO RECALIBRATE THIS UNIT
				;; NO-SKIP IN UNIT DOES NOT RECALIBRATE OR IS BAD
				;; SKIP RETURN IF RECALIBRATE STARTED OK
KONSTP:!XWD ZERO5,%TYP'XSTP	;;ENTRY POINT TO STOP A HUNG DISK
				;; NO-SKIP IF CAN'T, SKIP IF CAN
KONOFS:!XWD ZERO5,%TYP'XOFS	;;ENTRY POINT TO SET UNIT IN OFFSET MODE
KONHRD:!XWD ZERO5,%TYP'XHRD	;;ROUTINE TO CALL FOR HARD ERRORS
KONSFT:!XWD ZERO5,%TYP'XSFT	;;ROUTINE TO CALL FOR SOFT ERRORS
KONLEN==KONSFT-KONRED	;FTKON OVERLAYS UNNEEDED KONT. DB LOCS.
KONCHN:!XWD NMKCN(\$CHN,\<$KCHNN+1>),NMCH(\$CHN)	;;ADDRESS OF CHANNEL DATA BLOCK TO WHICH THIS KON
				;; CONNECTED (@USED TO TEST CHANNEL BUSY)
KONPTR:!XWD ZERO5,%TYP'TYPL'CU(P3) ;;USED TO PICKUP UNIT DATA BLOCK ADDRESS
				;; GIVEN PHYSICAL UNIT NUMBER IN AC P3. (@ USED)

>


	DEFINE DFCON (%TYP,TYPL,SYM)
<	INTERNAL KONCOM,KONCUA,KONIOC,KONSWC
EXTERNAL LOCOCW
KONSWC:!0		;SAVE WORD COUNT FOR THIS OPERATION
KONCOM:!XWD -CCWMAX,%TYP'TYPL'CB+KONLST
KONLST:!BLOCK CCWMAX
	0
KONCUA:!XWD ZERO18,0		;;CURRENT UNIT DATA BLOCK ADDRESS DOING
				;; DATA TRANSFER (OR LAST ONE)
KONIOC:!XWD ZERO18,SYM'IOC	;;CONTAINS ADR. OF LOWER CORE CHANNEL 
				;; PAIR FOR THIS PHYSICAL KONTROLLER
				;; (DIFF. PAIR FOR EACH KONTROLLER SO NO
				;;CHANNEL CONFLICT IF RECONFIGURE CHANNELS)
XP SYM'IOC,LOCOCW+$LOCW
$LOCW==$LOCW+2
KONINS:!			;;ADD IO INSTRUCTIONS AND ALL DATA LOCATIONS HERE:

>		;;END KONKON MACRO (SAME FOR ALL KONTROLLERS)

;;BYTE POINTERS
KOYPI:	POINT KOSPI,KOBPI(J),KONPI     ;;PI CHANNEL THIS KONTROLLER ASSIGNED TO

;INTERUPT COMMUNICATION BITS

KCMPOS==(1B7)	;SPECIAL POSITION INTERUPT (U IS UNIT)
KCMRER==(1B8)	;RECOVERED ERROR
KCMFUS==(1B9)	;FILE UNSAFE
KCMERR==(1B10)	;ERROR
KCMDTA==(1B11)	;DATA TRANSFER
KCMIOS==(1B12)	;I/O SELECT NEEDED (ONLY SET BY DEV-INDEP)
KCMOFL==(1B13)	;OFF-LINE

INTERNAL KCMOFL,KCMRER,KCMFUS,KCMERR,KCMDTA,KCMIOS,KCMPOS


;UNI:	UNIT DATA BLOCK

;PARAMETERS FOR UNITCB
;%TYP	- KONTROLLER TYPE (E.G. FH,DP,MD)
;TYPL	- KONTROLLER IDENTIFIER (STARTS AT A)

;UNI:	UNIT DATA BLOCK
;POINTED TO BY EACH STR (FANOUT)(STRTAB)
;POINTS TO NEXT UNI IN SYS (ACCROSS POINTER)(LH UNISYS)
;POINTS TO NEXT UNI WITHIN CHANNEL (RING)(RH UNICHN)
;POINTE TO NEXT UNI WITHIN KONTROLLER(ACCROS POINTER)(LH UNIKON)
;POINTS TO ITS CHN (UPWARD PTR)(RH UNICHN)
;POINTS TO ITS KON (UPWARD PTR)(RH UNIKON)
;POINTS TO NEXT UNI IN STR(ACCROSS PTR)(LH UNISTR)
;POINTS TO ITS STR DATA BLOCK(UPWARD POINTER)(RH UNISTR)

INTERN UNYPUN,UNYLUN,UNYWPS,UNYUTP,UNYBPT,UNYPPY,UNYKNM
INTERN UNYKTP,UNYLN1
INTERNAL UNYTIM,UNYRTY,UNYRCL,UNYRRT,UNYPPL,UNYPGL,UNYPAC
INTERNAL UNYOCV,UNYRTO,UNYRCO,UNYOS
DEFINE UNITCB (%TYP,TYPL)
<
INTERN UNINAM,UNILOG,UNIHID,UNISYS,UNISTR,UNIKON
INTERN UNIHCT,UNISCT,UNIMCT,UNIERR,UNISOF,UNIHBN,UNIBRC,UNIBWC
INTERN UNIDRC,UNIDWC,UNIMRC,UNIMWC,UNIHNG,UNIICT,UNIOCT,UNIMSC
INTERN UNIUSC,UNISDI,UNIHDI,UNIECT,UNISBN,UNISTS,UNICDA
INTERN UNIPPU,UNICHR,UNICYL,UNIBLK,UNICHN,UNIQUE,UNPOFL
INTERN UNITAL,UNIDES,UNPHWP,UNPRRS,UNISTT,UNPCHG,UNPMSB,UNPDEV
INTERN UNIRCT,UNIFCT,UNIDIR,UNPFUS,UNPPRV,UNIUTP
INTERN UNITIM,UNPUTP,UNPSER,UNPRER,UNPCER,UNIRC1

%NUN (INTERNAL,\$KNUNN,%TYP'TYPL)
IFNDEF FIRUNI,<FIRUNI:>	;;DEFINE FIRST UNIT DATA BLOCK ADR. IN SYSTEM
NMUN(\$KNUNN,%TYP'TYPL):	%SUN(\$KNUNN,%TYP'TYPL)
UNINAM==0	;;(0)SIXBIT PHYSICAL UNIT NAME WITHIN KONTROLLER
		;;LAST DIGIT IS 0 TO 7 -LEFT JUSTIFIED
		;; EXAMPLE:  DRA0,FHA0,MDA0,DPA0;;DPA1,DPB3
		;;[NEVER CHANGED BY MONITOR]

	PHASE	1
UNILOG:!0	;;(1)SIXBIT LOGICAL UNIT NAME WITHIN STR
		;; LAST DIGIT OR TWO IS 0 TO 77 LEFT JUSTIFIED
		;; EXAMPLE:  DSKA0,DSKB0,DSKC0;;DSKA17 [SET FROM HOMLOG BY HOMRED]
UNIHID:!0	;;(2)SIXBIT HOME BLOCK IDNAME - NEVER CHANGED IN HOME BLOCK
		;; SET WHEN SECTOR HEADERS ARE WRITTEN.  FOR DISK PACKS
		;; THE HOME BLOCK ID NAME IS THE PACK ID.
NMSYUN(\$SYUNN)==NMUN(\$KNUNN,%TYP'TYPL)
UNISYS:!XWD NMSYUN(\<$SYUNN+1>),0 ;;(3)LH=CORE ADDRESS(ACCROSS POINTER) OF NEXT
		;; UNIT DATA BLOCK IN SYSTEM, LH=0 IN LAST UNIT IN SYSTEM
UNILUN==UNISYS	;;RH. LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT-WORD ADR.
  UNSLUN==^D6	;;BYTE SIZE
  UNNLUN==^D35	;;BYTE PTR POS.

UNISTR:!0	;LH=ADDRESS OF NEXT UNIT DATA BLCOK IN STR
		;LH=0 IN LAST UNIT IN FILE STRUCTURE
		;RH=UPWARD POINTER TO FILE STR. DATA BLOCK.
		;WORD=0 IF THIS UNIT IS NOT IN A STR

NMCHUN(\$CHN,\$CHUNN)==NMUN(\$KNUNN,%TYP'TYPL)
UNICHN:!XWD NMCHUN(\$CHN,\<$CHUNN+1>),NMCH(\$CHN)	;;(5)LH=ADDRESS OF NEXT UNIT DATA BLOCK ON SAME CHANNEL
		;; LAST UNIT POINTS BACK TO FIRST UNIT (RING)
		;; RH=UPWARD POINTER TO CHANNEL DATA BLOCK.
NMKNUN(%TYP'TYPL,\$KNUNN)==NMUN(\$KNUNN,%TYP'TYPL)
UNIKON:!XWD NMKNUN(%TYP'TYPL,\<$KNUNN+1>),%TYP'TYPL'CB	;;(6)LH=ADDRESS OF NEXT UNIT DATA BLOCK ON SAME KON
		;; LAST UNIT POINTS BACK TO FIRST UNIT (RING)
		;; RH=UPWARD POINTER TO KONTROLLER DATA BLOCK
	XWD 0,0	;; (7) PLACE HOLDER FOR OBSOLETE ENTRY

;ERROR STATISTICS:
UNIHCT:!0	;;(10)NO. OF HARD DISK ERRORS ON THIS UNIT (RETRYS FAILED TO CLEAR ERROR)
		;; LH=NO. DEVICE+SEARCH ERRORS(IODERR)(CHAN+CONTROL)(SEE UNIPCT)
		;; RH=NO. DATA ERRORS(IODTER)(HARDWARE PARITY AND SEARCH)
UNISCT:!0	;;(11)NO. OF SOFT + NO. OF HARD ERRORS - INCREMENTED ON EVERY ERROR
		;; INTERRUPT
		;;LH=NO. SOFT+HARD DEVICE+SEARCH ERRORS(SEE UNIPCT)
		;; RH=NO SOFT+HARD DATA ERRORS
UNIMCT:!0	;;(12)NO. OF MONITOR DETECTED ERRORS(3 12 BIT FIELDS)
		;; USER PROGRAM SEES IOIMPM ERROR BIT SET FOR ALL 3 TYPES OF ERRORS
  UNPSER==100	;;NO. OF SAT FAILURES(NO. OF FREE BIT-PAIRS ON DISK SAT
		;; DISAGREE WITH EXPECTED NO AS STORED IN CORE)
  UNPRER==10000	;;NO. OF RIB REDUNDANT INFO FAILED TO COMPARE
  UNPCER==1	;;NO. OF SOFTWARE FOLDED CHECKSUM FAILURES(SWAP+USER IO)
		;; (MUST BE RIGHT JUSTIFIED FOR AOS)
UNIERR:!0	;;(13)LAST HARD ERROR DEVICE STATUS(IE STYTRY TIMES FAILED IN A ROW)
		;; WHICH OCCURRED ON THIS UNIT. SET BY MOVEM T2,UNIERR(U)
		;; IN FILSER WHERE T2 IS SET DIRECTLY FROM
		;; KONTROLLER STATUS WORD IN KONTROLLER DEPENDENT ROUTINE.
UNISOF:!0	;;(14)LAST SOFT OR HARD ERROR DEVICE STATUS
UNIHBN:!0	;;(15)LAST LOGICAL BLOCK NUMBER ON HARD ERROR

;;PERFORMANCE MONITORING DATA LOCATIONS:!
;;NOTE FOLLOWING 6 ENTRIES ARE MUTUALLY EXCLUSIVE AND ACCOUNT FOR ALL
;; TRANSFERS ON THIS UNIT(EXCEPT ERROR RETRYS)
;WRITE COUNT MUST BE READ COUNT+1
UNIBRC:!0	;;(16)NO. OF BUFFERED MODE 128 WORD BLOCKS READ
UNIBWC:!0	;;(17)NO. OF BUFFERRED MODE 128 WORD BLOCKS WRITTEN
UNIDRC:!0	;;(20)NO. OF DUMP MODE 128 WORD BLOCKS READ(INCLUDEING GETS)
UNIDWC:!0	;;(21)NO. OF DUMP MODE 128 WORD BLOCKS WRITTEN(INCLUDING SAVES)
UNIMRC:!0	;;(22)NO. OF MONITOR PAGES READ(SAT,UFD,MFD,BAT)
UNIMWC:!0	;;(23)NO. OF MONITOR PAGES WRITTEN(
		;; SAT,UFD,MFD,BAT)
UNIHNG:!0	; NO OF HUNG TIME OUTS WHICH COUNT NOT BE RECOVERED
		;LH HUNG FROM TRANSFER, RH OTHER (POSITION)


UNIICT:!0	;;(24)NO. OF 128 WORD BLOCKS SWAPPED IN(SET BY SWPINT)
UNIOCT:!0	;;(25)NO. OF 128 WORD BLOCKS SWAPPED OUT(SET BY SWPINT)
;;NOTE:!FOLLOWING 2 ENTRIES ARE MUTUALLY EXCLUSIVE AND ACCOUNT FOR ALL SEEKS
;; ON THIS UNIT EXCEPT END OF CYLINDER ADN RECALLIBRATION AND SEEK UUOS
UNIMSC:!0	;;(26)COUNT OF NO. OF MONITOR+SWAP SEEKS
UNIUSC:!0	;;(27)COUNT OF NO. OF USER(BUFFER+DUMP) SEEKS
		;; (INCLUDES GETS AND SAVES)

;;MORE ERROR STATISTICS:!
	0	;;(31) PLACE HOLDER FOR OBSOLETE ENTRY
UNISDI:!0	;;(32)LAST SOFT OR HARD ERROR DATAI IN STATUS WORD
		;; DATA,DEVICE,SEARCH ERRORS
UNIHDI:!0	;;(33)LAST HARD ERROR DATAI IN STATUS WORD
		;; DATA,DEVICE,SEARCH ERRORS
UNIECT:!0	;;(34) NO. OF CONSECUTIVE TIMES AN ERROR STATUS WAS RETURNED
		;; FOR THE LAST OPERATION ON THIS UNIT. (IE, FIRST+RETRIES
		;; WITH ERRORS).  SET BACK TO 1 ON FIRST ERROR, RATHER THAN
		;; BEGINNING OF NEW OPERATION, SO USER PROGRAMS HAVE MORE
		;; TIME TO LOOK AT IT.
UNISBN:!0	;;(35) BLOCK NUMBER WITH LAST SOFT ERROR
UNISTS:!0	;;STATUS WORD FOR UNIT - SET, CHANGED BY FILSER ONLY
		;;ONLY WHOLE WORD USED SO THAT EXCH TRICK CAN BE USED
		;;THESE SAME CODES ARE USED IN DEYCOD BYTE

UNIQUE:!XWD 0,0	;;LH=ADDRESS OF FIRST (LONGEST WAITING) DEVICE DATA BLOCK (FILE)
		;; IN POSITION WAIT FOR THIS UNIT (PW QUEUE)
		;;RH=ADDRESS OF LAST (SHORTEST WAITING) DEVICE DATA BLOCK (FILE)
		;; IN POSITION WAIT FOR THIS UNIT
		;;AS A FLAG, BOTH HALVES ARE SET TO 0 WHEN NO FILES IN
		;; POSITION WAIT QUEUE.
		;;NOTE:!THE FILE WHICH IS IN P STATE IS NOT IN QUEUE
		;; QUEUE SEARCH
UNICDA:!0	;;RH=CURRENT DEVICE DATA BLOCK ADDRESS OF FILE CURRENTLY
		;; POSITIONING OR TRANSFERRING ON THIS UNIT
UNIPPU:!0	;;NO. OF LOGICAL PAGES PER UNIT(RETURNED BY DSKCHR)
		;; SET BY TESTING IN ONCMOD



UNICHR:!0	;;UNIT CHARACTERISTICS (RETURNED IN DSKCHR M);;
UNIBPT==UNICHR	;;BITS 9-17= # BLOCKS/TRACK - SET BY TESTING IN ONCMOD
  UNSBPT==^D9
  UNNBPT==^D17
UNIPPY==UNICHR	;;BITS18-35= # PAGES/CYLINDER (THE SMALLEST IF CYLINDER
  UNSPPY==^D18	;; HAVE DIFFERENT SIZES (MDF)) - SET BY TESTING IN ONCMOD
  UNNPPY==^D35
UNIWPS:!0	;;# OF WORDS PER SAF BLOCK ON DISK FOR THIS UNIT-WORD ADR.
		;; LIMITED TO 128 WORDS OR CLUSTER SIZE WHICHEVER IS SMALLER
		;;BIT 9 UNUSED.
  UNSWPS==^D9	;;BYTE SIZE
  UNNWPS==^D8	;;BYTE PTR. POS.
UNISPU==UNIWPS	;;NO. OF SAT BLOCKS ON THIS UNIT - WORD ADR.
  UNSSPU==^D8	;;BYTE SIZE
  UNNSPU==^D17	;;PYTE PTR POS.
UNICYL:!-1	;;PHYSICAL CYLINDER UNIT IS CURRENTLY AT OR POSITIONING TOWARDS.
		;; THIS IS ONLY WORD SET AND LOOKED AT BY DEVICE DEPENDENT ROUTINE.
		;; USED BY FILSER TO SEE IF UNITS IN POSITION, NEVER CHANGED BY FILSER
		;; INITIALIZE TO -1 SO FORCE POSITIONING FOR FIRST READ
		;; ELSE GET POSITIONING ERROR AND FALSE ERROR DATA
UNIBLK:!0	;;LOGICAL BLOCK NUMBER WITHIN THE UNIT.
		;; ARG TO DEVICE DEPENDENT ROUTINES
UNISTT:!0	;;LH IS UNDEFINED.
		;;RH=ADDR OF STT FOR THIS UNIT.
UNITAL:!0	;;NO. OF FREE BLOCKS(RESERVED+FCFS) LEFT ON THIS UNIT
		;; [NO SAFETY FACTOR FOR UNIT
		;; INSTEAD THERE IS ONE FOR THE STR]
UNIDES:!BYTE (10)0(8)%UNSZ(\$SYUNN)(3)$CHN(6)TYP'%TYP(3)$'%TYP'NUM(2)0(4)$KNUNN


		;;WORD RETURNED IN AC FOR DSKCHR M DESCRIBES THIS DISK
		;; UNIT IN TERMS OF STR NUMBER, CHANNEL,
		;; KONTROLLER UNIT NUMBER. ETC.
		;; $K   = BINARY NUMBER OF NEXT UNIT ON KONTROLLER (STARTS AT 0)
		;; $CHN = BINARY CHANNEL NUMBER (STARTS AT 0)
		;; XX   = BINARY KONTROLLER NUMBER (STARTS 0 FOR EACH KONTROLLER TYPE)
		;;HENCE, UNIDES RH=(3)CHANNEL NUM(6)KONTROLLER TYPE
		;; (3)KONTROLLER NUM(3)UNIT TYPE(3)UNIT NUMBER
  UNPOFL==200000 ;;BIT 1=1 IF THE UNIT IS OFF U
  UNPHWP==100000 ;;BIT 2=1 IF THE UNIT IS HARDWARE WRITE PROTECTED
  UNPCHG==040000 ;;TIMESHARED BIT-A PARAMETER WAS CHANGED SO HOME BLOCK MUST BE WRITTEN
		;;  USED ONLY DURING ONCE ONLY CODE THEN CLEARED BEFORE SYSTEM STARTED
  UNPPRV==020000	;BIT 4=THIS IS A PRIVATE PACK.
 UNPFUS==4000	;BIT 6=1 IF FILE UNSAFE.
  UNPRRS==2000	;;BIT 7=1 IF UNIT NEEDS READ AND RESET BUFFERED LOG
		;; EITHER SINGLE ACCESS OR WRITE PROTECTED FROM ALL JOBS
  UNPMSB==400	;;BIT 9=1 IF THIS UNIT HAS MORE THAN ONE SAT BLOCK


UNISIZ==UNIDES	;;SIZE OF UNIT DATA BLOCK
  UNSSIZ==^D8	;;BYTE SIZE
  UNNSIZ==^D17	;;BYTE PTR POS.

		;;BITS 15 - 17 ARE A CODE WHICH TELLS WHETHER THE ARGUMENT PASSED TO
		;; MONITOR IN LOC WAS:(NEVER STORED IN UNIT DATA BLOCK)
		;; 0	GENERIC DEVICE DSK OR LOGICAL NAME FOR IT (E.G., DSK)
		;; 1	SUBSET OF STR BECAUSE OF AN STR ABBREVIATION
		;; 2	STR NAME OR LOGICAL NAME FOR IT (E.G., DSKA)
		;; 3	UNIT WITHIN A FILE STRUCTURE OR A LOGICAL NAME FOR IT
		;; 	(E.G., DSKA0)
		;; 4	A KONTROLLER CLASS NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DR,FH,DP,MD)
		;; 5	A KONTROLLER NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DRA,FHA,DPA,MDA,DPB)
		;; 6	A PHYSICAL DISK UNIT NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DRA0,DPA3)
		;;RH CONFIGURATION INFORMATION:
UNISCN==UNIDES	;;BITS 18-20 DATA CHANNEL NUMBER SOFTWARE THINKS HARDWARE IS
  UNSSCN==^D3	;; CONNECTED TO.  STARTS AT 0 SO FIRST DATA CHANNEL IS 0.
  UNNSCN==^D20	;;BYTE PTR POS.
UNIKTP==UNIDES	;;BITS 21-26 CONTROLLER TYPE
  UNSKTP==^D6	;;BYTE SIZE
  UNNKTP==^D26	;;BYTE PTR POS.
  TYPDR==0	;; 0	DR (FUTURE DRUM, IF ANY)
  TYPFH==1	;; 1	FH (BURROUGHS DISK OR BRYANT DRUM)
  TYPDP==2	;; 2	DP (MEMOREX RP01,RP02)
  TYPMD==3	;; 3	MD (BRYANT MASS DISK)
  TYPRM==5	;; 5    RM (RH11C CONTROLLER FOR RM03, RP06 UNITS)
  TYPAP==6	;; 6	AP (AMPEX OR CDC DISKS FOUND ON F3)
INTERN TYPRM	;;USED BY FILIO.
UNIKNM==UNIDES	;;BITS 27-29 KONTROLLER NUMBER.  STARTS AT 0, SO FIRST KONTROLLER OF
  UNSKNM==^D3	;; EACH TYPE STARTS AT 0.  (E.G., DPA=0,DPB=1,ETC.)
  UNNKNM==^D29	;;BYTE PTR POS.
UNIUTP==UNIDES	;;BITS 30-32 UNIT TYPE - A KONTROLLER DEPENDENT FIELD USED TO
  UNSUTP==^D2	;; DISTINGUISH VARIOUS OPTIONS OF A UNIT ON ITS KONTROLLER
  UNNUTP==^D31	;;BITS 21-26   BITS 30-32
		;;	0	     0
		;;	1	     0	BURROUGHS DISK ON RC10
		;;		     1	BRYANT DRUM ON RC10
		;;	2	     0	RP01
		;;		     1	RP02
		;;	3	     0	DUAL POSITIONER
		;;		     1	SINGLE POSITIONER
		;;	5	     0  RM03 UNIT
		;;		     1  RP06 UNIT
  UNPUTP==20	;;THE BIT
UNIPUN==UNIDES	;;BITS 33-35 PHYSICAL UNIT NUMBER WITHIN KONTROLLER - STARTS AT 0 FOR
  UNSPUN==^D4	;; EACH KONTROLLER SO FIRST UNIT IS 0
  UNNPUN==^D35	;;BYTE PTR POS.

	0	; Place holder for obsolete entry
	0	;   "	  "	"	"	"
UNIRCT:!0	;;HOLDRS RETRY COUNTS FROM DEVICE DEPENDENT CODE
UNIRTY==UNIRCT	;;NUMBER OF TIMES TO RETRY BEFORE RECAL
 UNSRTY==^D9
 UNNRTY==^D35	;POSITION OF FIELD
UNIRCL==UNIRCT	;;NUMBER OF TIMES TO RECALIBRATE
 UNSRCL==^D9
 UNNRCL==^D26
UNIRRT==UNIRCT	;;NUMBER OF TIMES TO RETRY BETWEEN RECALS
 UNSRRT==^D9
 UNNRRT==^D17

 UNPDEV==001000	;;FLAG THAT THIS WAS A DEVICE ERROR NOT DATA ERROR

UNIFCT:!0	;;FAIRNESS COUNT (USED ON UNITS WHICH POSITION)
UNIDIR:!0	;;ON UNITS WHICH POSITION, BIT 0 IS DIRECTION OF
		;;LAST POSITION
UNITIM==UNIDIR	;;TIMER FOR HUNG DEVICE (AND OFF-LINE)
 UNSTIM==6	;;SIZE
 UNNTIM==6
UNIPAC==UNIDIR	;;ACTIVE PAGE POINTER FOR PAGE REQ'S
 UNSPAC==^D13	;;SIZE
 UNNPAC==^D19	;;LOCATION
UNIPGL==UNIDIR	;;LIST OF PAGES TO DO REQUESTS FOR (POINTER TO FIRST)
 UNSPGL==^D13	;;SIZE
 UNNPGL==^D32	;;LOCATION
UNIPPL==UNIDIR	;;NUMBER OF BLOCKS OF PAGE COMPLETED (IN CASE OF ERROR)
 UNSPPL==2	;;SIZE
 UNNPPL==^D34	;;LOCATION

UNIRC1:!0	;;SECOND CELL USED BY E.R.
 UNIOCV==UNIRC1	;;STATE OF OFFSET E.R. 0 IMP FINISHED; ODD IMP AWAY,
  UNSOCV==^D9			;; EVEN IMP TOWARDS SPINDLE. (VARIABLE W)
  UNNOCV==^D35
 UNIRTO==UNIRC1	;;NUMBER OF TIMES TO RETRY AFTER OFFSET (PARAMETER X)
  UNSRTO==^D9
  UNNRTO==^D26
 UNIRCO==UNIRC1	;;NUMBER OF TIMES TO RECAL AFTER RETRIES AFTER OFFSET
  UNSRCO==^D9			;; (PARAMETER Y)
  UNNRCO==^D17
 UNIOS==UNIRC1	;;1 IFF SHOULD ENTER OFFSET MODE BEFORE STARTING A TRANSFER
  UNSOS==^D1
  UNNOS==^D7

$SYUNN==$SYUNN+1
$KNUNN==$KNUNN+1
$CHUNN==$CHUNN+1
>	;;END MACRO DEF OF UNITCB




	DEFINE DPITCB(%TYP,TYPL,N)
<	UNITCB (%TYP,TYPL)
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE>

	DEFINE RMITCB(%TYP,TYPL,N)
<	UNITCB(%TYP,TYPL)
UNISVA:!0		;Starting virtual address of transfer on unit.
UNITWC:!0
UNIOFS:!0
	XP SBSIZ,11	;NUMBER OF WORDS NEEDED TO SAVE RH11 REGISTERS.
UNISBH:!BLOCK SBSIZ	;RH11C/Rm03 registers of most recent hard error.
UNISBS:!BLOCK SBSIZ	; ditto for soft errors.
UNISB:!	BLOCK SBSIZ	;RH11C/RM03 registers saved here on error.
	; 0,10,14,42,2,12,4,16,20,22,24,26,30,32,34,40,6,44 saved in
	; that order (see SAVSTS in RM03), two per word, first in Lh.
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
INTERN UNISVA,UNITWC,UNIOFS>

	DEFINE APITCB(%TYP,TYPL,N)
<	UNITCB(%TYP,TYPL)
	XP SBSIZ,4	;NUMBER OF LOCATIONS NEEDED TO SAVE F3 DISK REGISTERS
UNISBH::!BLOCK SBSIZ	;CONTROL REGISTERS OF MOST RECENT HARD ERROR
UNISBS::!BLOCK SBSIZ	;SAME FOR SOFT ERRORS
UNISB::! BLOCK SBSIZ	;USED BY DEVICE DEPENDENT ROUTINE
UNITWC::! BLOCK 1	;TOTAL WORD COUNT, FOR INTERRUPT LEVEL CHECING
UNISVA::! BLOCK 1	;PLACE TO SAVE MEMORY ADDRESS
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
>
IFCPU (<KI,KL>),<
UNISB==0
UNISBH==0
UNISBS==0>

INTERN UNISB,UNISBS,UNISBH

	DEFINE FHITCB(%TYP,TYPL,N)
<	UNITCB(%TYP,TYPL)
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE>

	DEFINE BPITCB(%TYP,TYPL,N)
<	UNITCB(%TYP,TYPL)
UNISWC:!0	;SAVE WORD COUNT FOR THIS OPERATION
UNICNA:!0	;CONTINUE ADDRESS FOR LARGE TRANSFERS
UNICNC:!0	;CONTINUE COUNT
UNICCC:!0	;CURRENT COUNT IF TRANSFER BROKEN
UNISNS:!BYTE (8) 72,4,$KNUNN+BP'TYPL-1	;SENSE COMMAND
	BYTE (12) -^D24 (24) UNISND+NMUN(\<$KNUNN-1>,%TYP'TYPL)
	BYTE (8) 200
UNISND:!BLOCK 6		;READ SENSE INFORMATION HERE
UNISNC:!0	;NUMBER OF SENSES DONE
UNISVC:!0	;SAVE COUNT HERE ON SENSE
UNISCM:!0	;SAVE COMMAND HERE ON SENSE
UNIACT:!0	;SAVE CHANNEL ACTIVE COUNT FOR HUNG
UNICOM:!-BPCMSZ,,.+1+NMUN(\<$KNUNN-1>,%TYP'TYPL)
	BLOCK BPCMSZ
	%UNSZ(\<$SYUNN-1>)==.
	DEPHASE
>

IFCPU (<KI,KL>),<	;**D*
	INTERNAL UNICOM,UNISWC,UNICNA,UNICNC,UNICCC,UNIACT
	INTERNAL UNISNS,UNISND,UNISVC,UNISCM,UNISNC
>; END IFCPU (<KI,KL>)
;SIZE OF 3330 COMMAND LIST IS ENOUGH FOR 1 TRACK (18 RECORDS)
;THIS IS 18*7 (7 PER RECORD. 2 DATA ADDRS 2 TRANSFER 3 SEARCH AND
;TIC) +1 FOR STOP +3 FOR SET SECTOR AND SET SECTOR DATA
;+2 FOR SEEK (DATA SAME AS FOR FIRST SEARCH ID) +1 IN CASE
;LAST TRANSFER IS IN 2 PARTS (CRROSSES PAGE BOUNDARY)

BPCMSZ==^D<18*7+1+3+2+1>


DEFINE NMFTDB(TYPL,NUMM)
<FT'TYPL'NUMM'DB>

DEFINE NMFTDI(TYPL,NUMM)
<INTERNAL FT'TYPL'NUMM'DB>

DEFINE SYFTNM(NM)
<%SYF'NM>

DEFINE FTDDB(TYPL,NUMM)
<NMFTDB(TYPL,\NUMM): PHASE 0
IFE NUMM,<FT'TYPL'DDB==NMFTDB(TYPL,\NUMM)
	NMFTDI(TYPL,D)>
DEVNAM:!%SUN(\NUMM,FT'TYPL)
DEVCHR:!XWD 7*HUNGST,MTSIZ+1
DEVIOS:!Z
DEVSER:!XWD NMFTDB(TYPL,\<NUMM+1>),FTADSP
DEVMOD:!XWD DVIN+DVOUT+DVMTA,$FTMODE
DEVLOG:!Z
DEVBUF:!Z
DEVIAD:!0
DEVOAD:!0
DEVCLS:!XWD 600000,DEVLSA+NMFTDB(TYPL,\NUMM)
DEVSTS:!Z
DEVABC:!Z
DEVBWC:!Z
DEVLSA:!BLOCK LENFXL
DEVUDB:!NMUN(\NUMM,FT'TYPL)	;STORAGE FOR DR,, UNIT DB ADDR.
DEVCNT:!Z
DEVFNJ:!Z			;FN IN PROGRESS,,IBM 9 TRK ADJ.
DEVADD:!<FT'TYPL+$KNUNN>*10000
DEVDWC:!Z
DEVER1:!Z
DEVER2:!Z
DEVOUT:!Z
DEVINS:!Z
DEV40:! Z
DEVNOI:!Z
DEVACT:!Z
DEVDIO:!Z			;LH UNUSED, RH USED FOR PGYDIO
				;CALCULATIONS.


INTERNAL DEVUDB,DEVCNT,DEVFNJ,DEVADD,DEVDWC,DEVER1,DEVER2
INTERNAL DEVNOI,DEVINS,DEV40,DEVOUT,DEVACT,DEVDIO
NMFTDI(TYPL,\NUMM)

XP FT'TYPL'DDS,.
INTERNAL FT'TYPL'DDS

DEPHASE
>


INTERNAL FTCMLN
FTCMLN==104

	DEFINE FTITCB (%TYP,TYPL,%%N)
<%NUN(INTERNAL,\$KNUNN,%TYP'TYPL)
NMUN(\$KNUNN,%TYP'TYPL):
SYFTNM(\$SYFTN)==.

	PHASE 0
UNIDDB:! NMFTDB(TYPL,\$KNUNN)	;ADDR OF ASSOCIATED DDB.

UNILNK:! SYFTNM(\<$SYFTN+1>)

;ERROR REPORTING.
FDHFUN:! Z		;FN IN PROGRESS WHEN DEVICE HUNG.
FDHCNT:! Z		;# OF TIMES UNIT HAS HUNG.
FDHCNI:! Z
FDCNI1:! Z
FDCNIE:! Z
FDNRE1:! Z		;# READS NOT SUCCEEDING ON 1ST TRY.
FDNWR1:! Z		;# WRITES NOT SUCCEEDING ON 1ST TRY.
FDNREE:! Z		;" READS     "       "   EVER.
FDNWRE:! Z		;" WRITES    "       "   EVER.
FDERBT:! Z
FDSENS:! Z
	Z
	Z
	Z
	Z
	Z
FDSCHR:! Z
	Z
	Z
	Z
	Z
	Z
FDMEMR:! Z		;INFORMATION ABOUT THE LAST MEM ERR
			;SEEN (CHNMER COPY).

INTERNAL FDHFUN,FDHCNT,FDHCNI,FDCNI1,FDCNIE,FDNRE1
INTERNAL FDNWR1,FDNREE,FDNWRE,FDERBT,FDSENS,FDMEMR,FDSCHR

;END OF ERROR REPORTING.

UNIKNT:! XWD NMCH(\$CHN),FT'TYPL'CB  ;CHAN DB,,KONT DB.
UNIERO:! BLOCK 7		;ERROR SPACE IS HERE TO UNICMD.
UNICMD:! BLOCK FTCMLN		;NORMAL COMMAND SPACE IS FROM
UNIDON:!			;UNICMD TO UNIDON.
UNIDCR:! BLOCK 1		;DURING DATA CHECK-READ RECOVERY
				;READ CMD SAVED HERE,
UNIDCN:! BLOCK 1		;NEXT CMD SAVED HERE,
UNIDC1:! BLOCK 1		;POINTER TO READ SAVED HERE.
UNITYP:! Z			;LH=7/9 TRK, DENS.
				;RH=FOR HUNG ROUTINE.(SIGN BIT MUST
				;BE 0).
UNISX1:! Z			;MOST RECENT SAXBAS+1(+5, ETC.)
				;FOR THIS UNIT.
UNISX2:! Z			;SAXBAS+2, OR +6, ETC.
UNISX3:! Z			;SAXBAS+3, OR +7, ETC.
$SYFTN==$SYFTN+1		;NO. OF FT UNITS ON SYSTEM.

FTULNH==.-UNIDDB+1
DEPHASE

FTDDB(TYPL,$KNUNN)

INTERNAL UNIDDB,UNILNK,UNIKNT,UNIERO,UNICMD,UNIDON,UNIDCR
INTERNAL UNIDCN,UNIDC1,UNITYP,FTULNH,UNISX1,UNISX2,UNISX3
$KNUNN==$KNUNN+1
%'%TYP'TYPL'0==0	>

IFNDEF MAGUN,<
  IFNCPU(<KS,F3>),<XP MAGUN,0>
  IFCPU(<KS,F3>),<XP MAGUN,1>
  > ; End IFNDEF MAGUN
IFN MAGUN,<;IF ANY KS10 OR F3 STYLE TAPE CONTROLLERS
;Magtape data structures: KDB, UDBs, DDBs
;Note: the KS-10 allows only one TM03 and a maximum of 4 TU45s.

;UDB.
DEFINE MTUDB(NUMBER),<
TU'NUMBER'CB::
	PHASE 0
TUBDDB::!TU'NUMBER'DDB		;(0)Address of this unit's DDB
TUBDA::!NUMBER			;(1) 7*<TM03 #> + <TU45 #> (TM03 #=0)
TUBKDB::!TMX0CB			;(2)Pointer to KBD of this unit.
UNITYP::!0			;(3)Lh: <>0 if unit online, 0 ow. Rh:<>0 if
				; device has timed out once.
TUBHC::!0			;(4)Number of times this unit called, "hung."
TUBIWC::!0			;(5)WC register before transfer.
TUBIFC::!0			;(6)FC register before transfer.
TUBCNT::!0			;(7)DEVCNT copied b4 transfer
TUBCLS::!0			;(10)DEVCLS copied b4 transfer
TUBER1::!0			;(11)Error rec. coroutine adr or 0
TUBER2::!0			;(12)Error rec. # tries left.
TUBS::!	0			;(13)Lh: On line state. Rh: rewind state
TUBEC::!0			;(14)number of device errors
TUBSB::!BLOCK 7			;(15:23)device regs last error.
TUBICW::!0			;INITIAL COMMAND WORD FOR CHANNEL
LENFXL==44
TUBCOM::!BLOCK LENFXL		;SPACE FOR COMMAND LIST, ONE WORD FOR EVERY DDB IOWD
MTUDBL==.			;Length of magtape UDB.
INTERNAL MTUDBL
	DEPHASE
>
ZZ==0
REPEAT MAGUN,<
	MTUDB(\ZZ)
ZZ==ZZ+1
>
TUYTMN::POINT 3,TUBDA(U),32	;Pointer to TM03 number
TUYTUN::POINT 3,TUBDA(U),35	;Pointer to TU45 number.

;KDB.
TMX0CB::
	PHASE 0
TKBCUN::!0			;(0)Address of UDB of currently active unit
IFCPU (KS),<
TKBCBA::!UA3,,772440		;(1)Base address of Rh11C
>;END IFCPU(KS)
TKBSPR::!0			;(2)Count of spurious interrupts received
TKBIUN::!-MAGUN,,TMX0CB+.+1	;Pointer to vector of addressess
				; of all UDBs on the TM03.
	DEPHASE

DEFINE TUCBNM(NUM)<
	TU'NUM'CB
>
ZZ==0
REPEAT MAGUN,<
TUCBNM(\ZZ)
ZZ==ZZ+1>

;There must be one extra 0 at the end of the vector.
REPEAT 5-MAGUN,<0>

;DDB.
;This macro, given a unit number, returns the name of the DDB.  It is
; necessary because of MACRO's primative macro processor.
DEFINE MFOO1(X)<TU'X'DDB>
DEFINE MTDDB(NUMBER),<
TU'NUMBER'DDB::
	PHASE 0
DEVNAM::!<SIXBIT/MTA/>+<NUMBER+20>_14
DEVCHR::!XWD 7*HUNGST,MTSIZ##+1
DEVIOS::!0
DEVSER::!XWD MFOO1(\<NUMBER+1>),MAGDSP##
DEVMOD::!XWD DVIN+DVOUT+DVMTA,<1_D+1_DR+1_B+1_IB+1_I+1_AL+1_A>
DEVLOG::!0
DEVBUF::!0
DEVIAD::!0
DEVOAD::!0
DEVCLS::!XWD 600000,DEVLSA+TU'NUMBER'DDB
DEVSTS::!0
DEVABC::!0
DEVBWC::!0
LENFXL==44		;At least that's what it is in other systems.
DEVLSA::!BLOCK LENFXL
DEVUDB::!TU'NUMBER'CB
DEVDIO::!0
DEVFNJ::!0
DEVMD1::!0			;Rh: mode.
DEVER1::!0			;Rh: MTER after error
DEVDWC::!0
DEVCNT::!0
MAGDDS==.
INTERNAL MAGDDS
	DEPHASE
>
;This makes the last link 0.
MFOO1(\<MAGUN>)==0

MAGDDB::
ZZ==0
REPEAT MAGUN,<
	MTDDB(\ZZ)
ZZ==ZZ+1
>
>;END IFN MAGUN


;DEFINE NAME DEFINERS

	DEFINE %NCH (ARG,NUM)	;FUNCTION USING NAME OF CHANNEL
<ARG CHN'NUM'CB>

	DEFINE NMCH(NUM)	;NAME OF CHANNEL
<%NCH (,NUM)>

	DEFINE NMCHUN(CHN,UNIN)	;UNIT WITHIN CHANEL
<%CH'CHN'UNIN>

	DEFINE %KNCHN (CHN,TYP)	;NUMBER OF TYPES OF UNIT ON CHANNEL
<C'CHN'TYP'N>

	DEFINE NMKNUN (SYM,NUM)	;NAME OF UNIT ON KONTROLER
<%'SYM'NUM>

	DEFINE %NUN(ARG,NUM,TYP)	;FUNCTION OF UNIT
<ARG TYP'NUM'CB>

	DEFINE NMUN (NUM,TYP)	;NAME OF UNIT
<%NUN (,NUM,TYP)>

	DEFINE %SUN (NUM,TYP)	;SIXBIT NAME OF UNIT
<SIXBIT /TYP'NUM/>

	DEFINE NMSYUN (NUM)	;UNIT WITHIN SYSTEM
<%SYS'NUM>

	DEFINE NMKCN(CHN,KON)	;NAME OF KON IN CHL
<%CK'CHN'KON>

	DEFINE NMSCH(SAN,CHN)	;NAME OF CHANNEL ON SA-10
<SC'SAN'CHN'CB>

	DEFINE %UNSZ(NUM)	;SIZE OF UNIT DATA BLOCK
<%SIZ'NUM>

INTERN UNYPUN,UNYLUN,UNYWPS,UNYUTP,UNYKTP,UNYBPT,UNYPPY,UNYKNM
INTERN UNYSPU,UNYSIZ,UNYLN1,UNYSCN

UNYSCN:	POINT UNSSCN,UNISCN(U),UNNSCN	;CHANNEL #
UNYPUN:	POINT UNSPUN,UNIPUN(U),UNNPUN	;PHYSICAL UNIT # (0-7) WITHIN KONTROLLER
					; ARG TO KONTROLLER ROUTINES
UNYLUN:	POINT UNSLUN,UNILUN(U),UNNLUN	;LOGICAL UNIT # (0-77) WITHIN STR
UNYLN1:	POINT UNSLUN,UNILUN(T1),UNNLUN	;LOGICAL UNIT # - FOR ONCE ONLY
UNYWPS:	POINT UNSWPS,UNIWPS(U),UNNWPS	;+VE NO. OF WORDS PER SAT BLOCK
UNYUTP:	POINT UNSUTP,UNIUTP(U),UNNUTP	;UNIT TYPE(KONTROLLER DEPENDENT)
					; SET BY ONCE ONLY
UNYBPT:	POINT UNSBPT,UNIBPT(U),UNNBPT	;BLOCKS/TRACK - ARG TO KONTROLLER ROUTINES
UNYPPY:	POINT UNSPPY,UNIPPY(U),UNNPPY	;PAGES PER CYLINDER
					; THE SMALLEST IF CYLINDERS; HAVE DIFFERENT
					; SIZES(MDF) - ARG TO KONTROLLER ROUTINES
					; BEING MOUNTED, MOUNTED
UNYKTP:	POINT UNSKTP,UNIKTP(U),UNNKTP	;KONTROLLER TYPE THIS UNIT IS CONNECTED TO
					; ONCE ONLY USES
UNYSPU:	POINT UNSSPU,UNISPU(U),UNNSPU	;# SAT BLOCKS ON THIS UNIT
UNYKNM:	POINT UNSKNM,UNIKNM(U),UNNKNM	;KONTROLLER NO. WITHIN THIS TYPE
					; START AT 0 FOR A, 1 FOR B, ETC
UNYTIM:	POINT UNSTIM,UNITIM(U),UNNTIM	;TIMER FOR HUNG DEVICE
UNYPAC:	POINT UNSPAC,UNIPAC(U),UNNPAC	;ACTIVE PAGE POINTER
UNYPGL:	POINT UNSPGL,UNIPGL(U),UNNPGL	;RQUEST LIST POINTER
UNYRTY:	POINT UNSRTY,UNIRTY(U),UNNRTY	;RETRY COUNT
UNYRCL:	POINT UNSRCL,UNIRCL(U),UNNRCL	;RECAL COUNT
UNYRRT:	POINT UNSRRT,UNIRRT(U),UNNRRT	;RETRY COUNT BETWEEN RECALS
UNYOCV:	POINT UNSOCV,UNIOCV(U),UNNOCV	;OFFSET STATE (ERROR RECOVERY).
UNYRTO:	POINT UNSRTO,UNIRTO(U),UNNRTO	;RETRY THIS MANY TIMES AFTER OFFSET.
UNYRCO:	POINT UNSRCO,UNIRCO(U),UNNRCO	;RECAL AFTER RETRY AFTER OFFSET.
UNYOS:	POINT UNSOS,UNIOS(U),UNNOS	;1 <=> SET OFFSET MODE BEFORE XFR
UNYSIZ:	POINT UNSSIZ,UNISIZ(U),UNNSIZ	;UNIT DATA BLOCK SIZE
UNYPPL:	POINT UNSPPL,UNIPPL(U),UNNPPL	;PARTIAL PAGE TRANSFER BYTE

$FTNUM==0
$SYFTN==0	;NO. OF FTS ON SYSTEM (FOR ERROR REPORTING.)
$BPNUM==0
$FHNUM==0
$DPNUM==0
$MDNUM==0
$RMNUM==0
$APNUM==0
$SYUNN==0	;UNIT WITHIN SYSTEM
$CHN==0		;CHANNEL NUMBER
$LOCW==0	;USED FOR DEFINING LOW CORE CHANNEL KONTROL WORD

IFCPU (KL),<BLOCK 1000>;MAKE SURE NO IMPORTANT CODE IS UNCACHED.
CHNUNC::		;START OF UNCACHED AREA
REPEAT CHNN,<CHNCB>
$SAXN==0
	REPEAT SAXN,<SAXCB (\$SAXN)
$SAXN==$SAXN+1>
XP CHNUNE,.-1		;END OF UNCACHED AREA.
IFCPU (KL),<BLOCK 1000> ;MAKE SURE NO IMPORTANT CODE IS UNCACHE.

NMSYUN(\$SYUNN)==0
SYFTNM(\$SYFTN)==0

	INTERN UNTTBL,UNTLEN
UNTTBL: REPEAT <$SYUNN+2>,<Z>
UNTLEN==.-UNTTBL

	END
 	