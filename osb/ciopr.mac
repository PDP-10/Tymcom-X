TITLE CIOPR UUO TO FIDDLE WITH COMMUNICATIONS INTERFACE.

	STOPCD(,ENTRY,CIOPR)
	lall

;(who is JMS? Joseph M Smith did not work for TYMSHARE in 1980)
; **jms4480** KMC SUPPORT FOR NODLOD.SAI ADDED 4-4-1980 /JMS
; **gl 7180** PROTECTIVE CODE FOR UNEXPECTED INTERRUPTS
; **lb 7780** SET/CLEAR MANUAL DOWN FLAG WHEN LOADING DRS

EXTERNAL CPOPJ,CPOPJ1

;Enter here from UUOCON

CI.OPR::UMOVE	T1,(W)		;FUNCTION,,ADR OF ARG BLOCK
	HLRZ	T2,T1		;T2:=FUNCTION CODE
	CAILE	T2,DLFTL-1	;IN RANGE?
	 JRST	[SETO T1,
		 JRST DLEE]
	XCT	DLFT(T2)	;YES, PERFORM FUNCTION.
	 AOSA (P)		;SUCCESS
DLEE:	  UMOVEM T1,(W)		;ERROR CODE FOR USER.
	POPJ P,


IFCPU (KS),<	;ENDS ON LAST PAGE.
					; Default definition to JFCL
	DEFINE KMCMDN,<JFCL 0>
	DEFINE KMCMUP,<JFCL 0>

IFKMC<					; If this is for a KMC system
  IFDEF KMCVEC,<			;   and the KMC is defined
	DEFINE KMCMDN,<PUSHJ P,KMCSMN##>
	DEFINE KMCMUP,<PUSHJ P,KMCCMN##>>>

;DR11C hardware parameters.

DEFINE IOREG(REGISTERNAME,OFFSET,BITNAMES,MSB),<
 BIT==100000
IFNB <MSB>,<BIT==MSB>
DR'REGISTERNAME==OFFSET
IRP BITNAMES,<REGISTERNAME'BITNAMES==BIT
              BIT==BIT/2>
>

IOREG(CSR,0,<RB,,,,,,,,RA,IEA,IEB,,,,1,0>)
 DRFN==CSR0   ;Data ready for node (set by KS10 after loading OB).
 ODOFS==1	;High vector = dispatch when node's read OB.
 KRFMD==CSR1  ;KS10 ready for more data (set by KS10 after reading IB).
 IROFS==0	;Low vector = dispatch when node's written IB.
IOREG(OB,2)
IOREG(IB,4)

;Macro to make a DR11c known to the system.
;Since the concatenation operator can't be used outside of
; macro definitions, we have to use the SETxxx macros.

DEFINE SETBASEADDRESS(N,ADDRESS),<DR'N'BA==ADDRESS>

DEFINE SETVECTORADDRESS(N,ADDRESS),<DR'N'VL==ADDRESS>

DEFINE DR11C(BASEADDRESS,VECTORBASE),<
SETBASEADR(\NUMDR,BASEADDRESS)
SETVECTORADDRESS(\NUMDR,VECTORADDRESS)
IF1,<BLOCK 8>
IF2,<DRINTH(\NUMDR)>
NUMDR==NUMDR+1
>

NUMDR==0

;macro to protect against & count unexpected dr interrupts. /GL 7-1-80
;  and to move a JSR DX#INT into EPT+base+vec.
DEFINE DRXJSR(N,UBA,VEC),<
	JRST	DY'N'CNT+1
DX'N'INT: EXP 0
	AOS DX'N'CNT
	JEN @DX'N'INT
DX'N'CNT: EXP 0
DY'N'INT: EXP 0
	AOS DY'N'CNT
	JEN @DY'N'INT
DY'N'CNT: EXP 0
	MOVE	T2,EPT+100+UBA	;T2/ BASE VECTOR ADDRESS
	MOVE	T1,[JSR DX'N'INT]
	MOVEM	T1,VEC'/4(T2)
	HRRI	T1,DY'N'INT
	MOVEM	T1,VEC'/4+1(T2)
>  ;End of DEFINE DRXJSR

;Insert definitions here.
DR11C(767770,300/4)
DR11C(767760,310/4)		; **jms4480**
DR11C(767750,320/4)		; **jms4480**
DR11C(767740,330/4)		; **jms4480**

DEFINE DRINTH(N),<	;DR'N interrupt handler
DR'N'IRF:0
DR'N'IR:0
	SETOM DR'N'IRF
	JEN @DR'N'IR
DR'N'ODF:-1
DR'N'OD:0
	SETOM DR'N'ODF
	JEN @DR'N'OD
>;DEFINE DRINTH

DRIVTB:			;Interrupt vector table
DEFINE DRVECL(N) <
	DR'N'VL
>

IF1,<BLOCK NUMDR>
IF2,<
ZZ==0
REPEAT NUMDR,<
	DRVECL(\ZZ)
ZZ==ZZ+1
>>

DRFLTB:			;Flag address table
DEFINE DRFLAG(N) <
	DR'N'IRF,,DR'N'ODF
>
IF1,<BLOCK NUMDR>
IF2,<
ZZ==0
REPEAT NUMDR,<
	DRFLAG(\ZZ)
ZZ==ZZ+1
>>

DRBATB:			;Base address table
DEFINE DRBADR(N) <
	3,,DR'N'BA
>
IF1,<BLOCK NUMDR>
IF2,<
ZZ==0
REPEAT NUMDR,<
	DRBADR(\ZZ)
ZZ==ZZ+1
>>
SUBTTL	Dispatch for KS version of CIOPR

;FUNCTION HANDLERS ARE PASSED ADR OF ARG BLOCK IN T1.RH.
;SINGLE RETURN IF FUNCTION EXECUTED NORMALLY.
;ON ERROR, SKIP RETURN WITH ERROR CODE IN T1.
DLFT:	PUSHJ	P,DLSCI		;0 SELECT COMMUNICATIONS INTERFACE.
	PUSHJ	P,DLSEDR	;1 PREPARE DR11C FOR DATA.
	PUSHJ	P,DLWDR		;2 WRITE WORD TO DR11C.
	PUSHJ	P,DLRDR		;3 READ WORD FROM DR11C.
	PUSHJ	P,DLDDR		;4 RELEASE DR11C TO KMC & NEXILIS NODE.
	PUSHJ	P,DLKMCD	;5 GIVES ERROR RETURN IF KMCDO IS 0
DLFTL==.-DLFT

;DLKMCD (FUNCTION 5) - TEST IF KMC IS SELECTED

DLKMCD:	SKIPN	KMCDO##		;(5) CHECK IF KMCDO IS SET
	  AOS	(P)
	POPJ	P,

;DLSCI (FUNCTION 0) - SELECT COMMUNICATIONS INTERFACE.
; ARG 0: INTERFACE TYPE: 0=CTYSIM, 1=DZKON, 2=TYMBASE NODE, 3=DR11C
; **jms4480** THIS FUNCTION DOES NOT ALLOW  FOR MULTIPLE
; **jms4480** DR'S (ALSO DR0 MUST BE USED). TO USE MORE THAN
; **jms4480** 1 DR, THE KMC IS REQUIRED IN WHICH CASE THE (KMC)
; **jms4480** INTERFACE SHOULD BE CLEARED FROM USER LEVEL.

DLSCI:	PUSHJ	P,DLREI		;REMOVE EXISTING INTERFACES.
	UHRRZ	T2,(T1)		;GET INTERFACE TYPE.
	CAILE	T2,3
	 JRST	DLE0		;ILLEGAL INTERFACE TYPE.
	JRST	@.+1(T2)
	DLICTY		;0 CTY
	DLIDZ		;1 DZ
	DLINN		;2 KMC
	DLIDR		;3 DR
;*;	DLREI

;DLREI.  REMOVE LINKS BETWEEN DZKON, CTYSIM AND SYSTEM.
DLREI:	SKIPE	CTYDO##
	 JFCL	;**D*	 PUSHJ P,DLRCTY
	SKIPE	DZDO##
	 PUSHJ	P,DLRDZ
	SKIPE	DRDO##
	 PUSHJ	P,DLRDRI
	SKIPE	KMCDO##
	 JFCL			;KMC IS NEVER REMOVED
	POPJ	P,

EXTERNAL EPT,CPOPJ1

;Remove DR interface

DLRDRI:	MOVEI	T2,0		;Clear DR0's CSR
	MOVE	T3,DRBATB	; **jms4480** ONLY DR0 SUPPORTED
				; **jms4480** AT THIS LEVEL.
	WRIO	T2,DRCSR(T3)
	MOVEI	T3,CH7##
	MOVEI	T2,CLKDR##
	WRPI	LI.PIF
	PUSHJ	P,DLUIR		;Unlink CLKDR from CH7
	  STOPCD
	WRPI	LI.PIN
	POPJ	P,

;Remove CTY interface

DLRCTY:	MOVEI	T3,CH7##
	MOVEI	T2,CH7LK##
	WRPI	LI.PIF
	PUSHJ	P,DLUIR		;Unlink CH7LK from CH7
	  STOPCD
	MOVEI	T3,CH6##
	MOVEI	T2,CH6LK##
	PUSHJ	P,DLUIR		;Unlink CH6LK from CH6
	  STOPCD
	MOVEI	T3,CH6##
	MOVEI	T2,CH6KST##
	PUSHJ	P,DLUIR		;Unlink CH6KST from CH6
	  STOPCD
	SETZM	CTYDO##
	WRPI	LI.PIN
	POPJ	P,

;Remove DZ interface

DLRDZ:	WRPI	LI.PIF
	PUSHJ	P,DZREM##	;TURN OFF DZ11S.
	MOVEI	T3,CH7##
	MOVEI	T2,DZPINT##
	PUSHJ	P,DLUIR		;Unlink DZPINT from CH7
	  STOPCD
	MOVEI	T3,CH6##
	MOVEI	T2,PERINT##
	PUSHJ	P,DLUIR		;Unlink PERINT from CH6
	  STOPCD
	MOVEI	T3,CH6##
	MOVEI	T2,CONINT##
	PUSHJ	P,DLUIR		;Unlink CONINT from CH6
	  STOPCD
	SETZM	DZDO##
	WRPI	LI.PIN
	POPJ	P,

;DLUIR.  UNLINK INTERRUPT ROUTINE WHOSE ADDRESS IS IN
; T2 FROM CHAIN ON CHANNEL IN T3.
;SINGLE RETURN IF COULDN'T FIND THE ROUTINE.  OTHERWISE
; SKIP AFTER UNLINKING IT.
DLUIR:	SKIPA	P2,T3		;Unlink Interrupt Routine
DLUIR0:	 SKIPA	T3,T4		;PREVIOUS:=CURRENT
	  HRRZI	T4,(T3)		;T3:=PREVIOUS
	HRRZ	T4,1(T4)	;T4:=CURRENT
	CAIN	T4,(P2)		;LOOPED AROUND?
	 POPJ	P,		;YEP, DIDN'T FIND IT.
	CAIE	T4,(T2)
	 JRST	DLUIR0
DLUIR1:	MOVE	T4,1(T4)	;PREVIOUS.NEXT:=CURRENT.NEXT.
	MOVEM	T4,1(T3)
	JRST	CPOPJ1

;Install DR11C interface to NEXILIS node

DLIDR:	WRPI	LI.PIF
	SETOM	DRDO##
	PUSHJ	P,DRINI##
	WRPI	LI.PIN
	POPJ	P,

;Install CTY interface

DLICTY:	WRPI	LI.PIF
	SETOM	CTYDO##
	SETOM	NOWIN##		;SAY PORT LOGGED IN.
	PUSHJ	P,CTYSET##
	WRPI	LI.PIN
	POPJ	P,

;Install DZ-11 driver interface

DLIDZ:	WRPI	LI.PIF
	SETOM	DZDO##
	PUSHJ	P,DZINI##
	WRPI	LI.PIN
	POPJ	P,

;Install KMC to NEXILIS node interface

DLINN:
;*;	SETOM	KMCDO##		;ASSUME KMCDO IS ALREADY SET
	POPJ	P,

;DLWDR (FUNCTION 2) - WRITE WORD TO SELECTED DR11C.
; ARG 0: DR11C#,,16 BIT WORD TO SEND
DLWDR:	PUSHJ	P,DLSDR		;GET DR11C BASE ADDRESS.
	  JRST	CPOPJ1		;ERROR.
	HRRZ	T4,DRFLTB(T2)	;SEE IF PREVIOUS OUTPUT TAKEN.
	SKIPN	(T4)
	 JSP	T1,DLWAIT
	WRPI	LI.PIF
	SETZM	(T4)		;CLEAR TAKEN FLAG.
	WRIO	T3,DROB(P1)	;SEND WORD
	MOVEI	T3,DRFN
	BCIO	T3,DRCSR(P1)
	BSIO	T3,DRCSR(P1)	;TELL DR NEW DATA IS READY
	WRPI	LI.PIN
	POPJ	P,

;DLRDR (FUNCTION 3) - READ WORD FROM SELECTED DR11C.
; ARG 0: DR11C #,,ADR TO RECEIVE WORD READ.
DLRDR:	PUSHJ	P,DLSDR		;GET DR11C BASE ADDRESS.
	  JRST	CPOPJ1		;ERROR.
	HLRZ	T4,DRFLTB(T2)	;CHECK IF PREVIOUS INPUT RECEIVED.
	SKIPN	(T4)
	 JSP	T1,DLWAIT
	WRPI	LI.PIF
	SETZM	(T4)		;CLEAR FLAG.
	RDIO	T4,DRIB(P1)	;GET WORD
	UMOVEM	T4,(T3)		;GIVE IT TO USER
	MOVEI	T4,KRFMD
	BCIO	T4,DRCSR(P1)
	BSIO	T4,DRCSR(P1)	;TELL DR INPUT HAS BEEN READ
	WRPI	LI.PIN
	POPJ	P,

;DLSEDR (FUNCTION 1) - SELECT DR11C FOR USE BY THE 2020.
; ARG 0: DR11C #,,0
DLSEDR:	PUSHJ	P,DLSDR		;GET HANDLES ON DR11C
	 JRST	CPOPJ1		;ERROR.
	MOVE	T1,T2		;SET UP T1 FOR SETTING MANUAL DOWN FLAG
	SKIPE	KMCDO##		;DONT SET IF NO KMC
	  KMCMDN		;SET DR MANUALLY DOWN
	HRRZ	T4,EPT+103	;SETUP INTERRUPT VECTORS.
	ADD	T4,DRIVTB(T2)
	HLRZ	T1,DRFLTB(T2)
	ADD	T1,[JSR 1]
	MOVEM	T1,IROFS(T4)
	HRRZ	T1,DRFLTB(T2)
	ADD	T1,[JSR 1]
	MOVEM	T1,ODOFS(T4)
	MOVEI	T1,CSRIEA+CSRIEB ;ENABLE BOTH INTERRUPTS
	WRIO	T1,DRCSR(P1)
	MOVEI	T1,^D1000	;GIVE IT A CHANCE TO INTERRUPT
	SOJG	T1,.		;ASSUME NO INT PENDING AFTER THIS.
	HLRZ	T4,DRFLTB(T2)	;CLEAR INPUT READY FLAG
	SETZM	(T4)
	HRRZ	T4,DRFLTB(T2)	;SET DR11C READY FOR OUR OUTPUT FLAG
	SETOM	(T4)
	POPJ	P,

;DLDDR (FUNCTION 4) - DESELECT DR11C.
; ARG 0: DR11C #,,0
DLDDR:	PUSHJ P,DLSDR		;GET HANDLES ON DR11C
	 JRST CPOPJ1		;ERROR.
	HRRZ T4,DRFLTB(T2)	;MAKE SURE LAST OUTPUT TAKEN.
	MOVEI P2,-1		;SET COUNT OF 777777
DLDDR1:	SKIPN (T4)		;CHECK FOR DATA ACCEPTED
	 SOJG P2,DLDDR1		;KEEP TRYING
	MOVEI T1,0		;DISABLE INTERRUPTS
	WRIO T1,DRCSR(P1)
	SKIPN (T4)
	 JSP T1,DLWAIT
	MOVE T1,T2		
	SKIPE	CTYDO##
	  POPJ	P,		;IF RUNNING FORM CONSOLE QUIT NOW.
	SKIPN KMCDO##		;DONT REINSTALL DR DRIVER IF KMC ACTIVE
	 PUSHJ P,DLIDR		;REINSTALL DR11C DRIVER
	SKIPE KMCDO##		;DO CLEAR MANUAL DOWN FLAG IF KMC ACTIVE
	 KMCMUP			;"MANUALLY UP"
	POPJ P,			;WITH OR WITHOUT KMC
	POPJ P,

;DLSDR.  LOAD P1 WITH BASE ADDRESS OF DR11C SPECIFIED BY USER.
; IN ARG 0.  SKIP IF LEGAL DR11C, SINGLE RETURN OTHERWISE.
; T3.RH HAS ARG0.RH.  T2 HAS DR11C NUMBER.
DLSDR:	UMOVE T3,(T1)
	HLRZ T2,T3		;DR11C NUMBER
	CAILE T2,NUMDR-1
	 JRST DLE0		;ILLEGAL DR11C NUMBER.
	MOVE P1,DRBATB(T2)	;T2:=DR11C BASE ADDRESS.
	JRST CPOPJ1

;DLWAIT.  WAIT UNTIL PREDICATE TRUE (SKIPS).  PUT PREDICATE
; BEFORE JSP T1,DLWAIT.  IF PREDICATE FAILS, SLEEPS FOR
; A WHILE, THEN TRIES AGAIN.  UP TO 100 TRIES ARE ALLOWED.
DLWAIT:	MOVEI P2,-1
DLWT1:	MOVEI P3,2		;RESCHEDULE
;	SLEEP P3,	;**D* REMOVED ??
	XCT -2(T1)		;EXECUTE TEST INSTRUCTION
	 SOJG P2,DLWT1		;RE EXECUTE LOOP IF TEST FAILED
	JUMPE P2,DLE1		;GO HANDLE ERROR IF P2 WENT TO ZERO
	JRST (T1)		;TEST SUCCEEDED-  RETURN TO CALLER

;ROUTINES FOR RETURNING ERROR CODES.
DLE0:	JSP T1,DLERR
DLE1:	JSP T1,DLERR
DLE2:	JSP T1,DLERR
DLERR:	HRRZI T1,-DLE0+1(T1)
	JRST CPOPJ1

;ROUTINE TO SETUP EPT FOR DR INTERRUPT PROTECTION. /GL 7-1-80
DRPROT::		;DESTROYS T1
	DRXJSR(1,3,300)		;DR#,UBA#,11VECTOR
	DRXJSR(2,3,310)
	DRXJSR(3,3,320)
	DRXJSR(4,3,330)
	POPJ	P,

> ;END IFCPU (KS) STARTING PAGE 1.
SUBTTL	Dispatch for F3 version of CIOPR

IFCPU (F3),<
;FUNCTION HANDLERS ARE PASSED ADR OF ARG BLOCK IN T1.RH.
;SINGLE RETURN IF FUNCTION EXECUTED NORMALLY.
;ON ERROR, SKIP RETURN WITH ERROR CODE IN T1.
DLFT:	PUSHJ	P,DLSCI		;0 SELECT COMMUNICATIONS INTERFACE.
	PUSHJ	P,DLSEDR	;1 PREPARE DR11C FOR DATA.
	PUSHJ	P,DLWDR		;2 WRITE WORD TO DR11C.
	PUSHJ	P,DLRDR		;3 READ WORD FROM DR11C.
	PUSHJ	P,DLDDR		;4 RELEASE DR11C TO KMC & NEXILIS NODE.
	PUSHJ	P,DLKMCD	;5 GIVES ERROR RETURN IF KMCDO IS 0
DLFTL==.-DLFT

;ERROR CODE RETURNS
ERRET0:	JSP T1,ERRETN	;ERROR RETURN WITH T1/ ERROR CODE
ERRET1:	JSP T1,ERRETN
ERRET2:	JSP T1,ERRETN
ERRETN:	HRRZI T1,-ERRET0+1(T1)
	JRST CPOPJ1



DLSCI:	UHRRZ	T2,(T1)		;(0) GET INTERFACE TYPE
	SETZM	T1
	CAIE	T2,2		;ONLY TYMBASE IS LEGAL
	 JRST	ERRET0		;ERROR RETURN 0
	POPJ	P,		;NON-ERROR RETURN
repeat 10,<jfcl>

DLSEDR:	UMOVE	T3,(T1)	        ;(1) SELECT DR
	SETZM	T1
	HLRZ	T2,T3		;/T2 INTERFACE NUMBER
	CAIE	T2,0		;ONLY ALLOWED TO SELECT DR 0
	 JRST ERRET0
	POPJ P,
repeat 10,<jfcl>

DLWDR:	UMOVE	T3,(T1)		;(2) WRITE TO DR
	SETZM	T1
	HLRZ	T2,T3		;/T2 INTERFACE NUMBER
	CAIE	T2,0
	 JRST	ERRET0
PRINTF	(<[No code to let F3 load its own base]>)
	POPJ	P,		;NOOP
repeat 10,<jfcl>

DLRDR:	UMOVE	T3,(T1)		;(3) READ FROM DR
	SETZM	T1
	HLRZ	T2,T3		;/T2 INTERFACE NUMBER
	CAIE	T2,0
	 JRST	ERRET0
	POPJ	P,		;NOOP
repeat 10,<jfcl>

DLDDR:	UMOVE	T3,(T1)		;(4) DONE WITH DR
	SETZM	T1
	HLRZ	T2,T3		;/T2 INTERFACE NUMBER
	CAIE	T2,0
	 JRST	ERRET0
	POPJ	P,		;NOOP
repeat 10,<jfcl>

DLKMCD:	SETOM	T1		;(5) CHECK IF KMCDO IS SET
	JRST	CPOPJ1		;SKIP RETURN FOR ERROR (NO KMC ON F3s)
repeat 10,<jfcl>

>  ;End IFCPU(F3)

	$END	(CIO)		;End of CIOSER (CIOLIT: CIOEND:)
  