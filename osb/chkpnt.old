TYMSPC==30	;TYMSHARE SPEC NO.
TYMREL==3	;TYM RELEASE NO.
JOBVER==137
DEFINE TITL(TS,TR)<
TITLE CHKPNT VERSION TS'.'TR
VCOMPIL=<TS,,TR>>
TITL(\TYMSPC,\TYMREL)
IF2,<printx License required: SY GD HF JL>
LOC JOBVER
EXP VCOMPILE
RELOC
EXTERNAL JOBFF,JOBREL
;-EDITED SEPT 76 AAA CONVERT ALL FACT REF TO STREAM REF.
;	NOW CHKPNT WRITES CHECKPOINT RECORDS INTO THE STREAM
;	VIA NEW CALLI & RETRIEVES THEM LIKE ALL OTHER
;	STREAM RECORDS, WRITES THEM INTO STREAM ACCOUNT
;	FILE.  LOGIN,LOGOUT ALSO WRITE TO THE STREAM.
;	[ALMOST] ALL MODS FOR THIS CHANGE IDENTIFIED BY ";-".
P=17
OPDEF RET [POPJ P,]
PTR=16
PTR2=15
T1=1
T2=2
T3=3
T4=4
T5=5
	N1=T5+1 ;-
	N2=N1+1 ;-
	N3=N2+1 ;-
	N4=N3+1 ;-ALL THESE N AC'S USED FOR NUMBER OUTPUT ROUTINES
FIL==1		;-"USE" FILE, STAT&ERROR INFO, (SYS)MMDDYY.DAT
STREAM==2	;-(UN1)MMDDYY.SAT . ALL ACCTG RECORDS
ACTDV==3	;-CHANNEL FOR INPUT FROM ACT DEVICE SEE "GETACT"
OPDEF CALL [PUSHJ P,]	;-
OPDEF SRETURN [JRST CPOPJ1] ;-SKIP (SUCCESS) RTN
OPDEF INTRMT [CALLI -52]; -ASSOCIATED WITH ACCOUNTING DEVICE
IFE DEB,<OPDEF PUTSAR [CALLI -62];-PUT STREAM ACCT REC>
IFN DEB,<OPDEF PUTSAR [CAIA]>
ARRAY PDL,USEPDL[40],SBUF,BUF[200],ABUF[3],USESAC[20],DCNV[3]
DEB==0
;DEB==1
;-RECORD TYPE DEFINITIONS & TYPE-CHECKING CONVENTIONS
;-	RECORDS OF TYPES 0-MAXSTY-1 ARE CHECKED FOR PROPER
;-	LENGTH BY STMTYC WHEN INPUT FROM ACTDEV. RECORD
;-	TYPES 400,401,402 ETC. NOT CHECKED.  THEY DO NOT
;-	COME IN FROM ACTDEV, BUT ARE PLACED IN STREAM RECORDS
;-	BY CHKPNT ON THE WAY OUT.
;-FOLLOWING REC TYPES ARE WRITTEN BY CHKPNT INTO STREAM.
RESTYP==400	;RESTART RECORD
RESLNG==2
UPTYP==43	;UPTIME RECORD
UPLENG==3
ERRTYP==402	;ERROR REC
ERRLNG==2
ER3TYP==403	;DEBUG TYPE ERROR HEADER. SEE STMERS
ER4TYP==404	;DEBUG TYPE ERROR TRAILER. SEE STMERS. AAA DEC 76
DUMTYP==401	;DUMMY RECORD FILL TO END OF BLOCK
		;(LENGTH VARIABLE)
CKPTYP==41	;CHECKPOINT REC
;(CKPLNG==DEFINED FOLLOWING CHECK ROUTINE)
MAXSTY==44+1	;CURRENTLY TATTLETALE IS MAX TYPE
DEFINE XMSG(NAME)
<IF2,<PRINTX CHKPNT EXPECTS ALL STREAM TYPES .LT. NAME>>
XMSG(\MAXSTY)
ARRAY STYTYP[MAXSTY];-SIZE OF EACH TYPE OF RECORD.SEE STMTYC
; HEADER WORD FORMAT:
; BITS 0-8:	RECORD TYPE
; BITS 9-17:	JOB NO.
; BITS 18-29:	SUPERVISOR INFO. (LOGIN REC ONLY)
; BITS 30-35:	LENGTH OF REC, INCLUDING HEADER WD
LICTAB==-20	;JOB LICENSE
OPRLIC==100000	;OP LICENSE BIT
HFLIC==2000	;HOME FILES OTHERWISE KNOWN AS RMT LIC
ASSPRG==200000	;DEVICE IS INNITTED..USED TO CHK ACT DEV AT STPT
LICJAL==1000
SYLIC==40000	;SYSTAT LICENSE
LICGDV==20000	;GET DEVICES
STSTAB==0	;JBTSTS
JACCT==1
JNA==40000
PRVTAB==6	;JBTPRV
  NOATT==200000 ;IN LH JBTTPRV
UPTENT==15	;ENTRY FOR UPTIME
UPTTAB==12	;TABLE FOR UPTIME
NULENT==34	;ENTRY FOR NULTIME
NULTAB==12	;TABLE FOR NULTIME
LOSENT==22	;ENTRY FOR LOST TIME
LOSTAB==12	;TABLE FOR LOST TIME
JOBENT==15	;ENTRY FOR SEGMENT POINTER (JOB NUMBER)
JOBTAB==11	;TABLE FOR SEGMENT POINTER
TIMCAS==4	;INTERUPT REASON - TIMER
IOWCAS==2	;IOWAIT
NTQCAS==13	;INTERRUPT REASON - NOTICE TO QUIT (SYS GOING DOWN)
OPDEF LOGOFF [CALLI -130]
INPCAS==0	;INPUT AVAIL
CHKOFS==5	;NUMBER OF 5 MIN PERIODS FOR CHKPNT
;SEE 'CHECK' ROUTINE 'GTAB' TABLE WHICH DEFINES THE CHKPNT
;	RECORD WRITTEN TO THE STREAM FOR THE USE OF THESE
;	GETTAB ITEMS:
TRUGET==-44	;RETURN DOUBLE PRECISION TRU'S
KCTGET==-45	;RETURN DOUBLE PRECISION KILO-COORE-TICKS
MCYGET==-46	;GETS D.P. MICRO CYCLES
TRUTAB==4	;SINGL PREC. USED BY FNDMOD (STAT & USAGE)
AUNTAB==-23	;AUN
BCSTAB==-13	;BREAK CHRS*SIZE
CINTAB==-7	;CHRS IN
CNKTAB==-12	;CONNECT TIME
COTTAB==-10	;CHRS OUT
DLKTAB==-2	;LOOKUPS
ELPTAB==-11	;ELAPSED TIME*SIZE
ENTTAB==-33	;ENTERS
JOBLIN==-27	;JOB TO LINE CONVERSION
LOGTAB==-24	;LOGIN INFO FROM SUPERVISOR
RCTTAB==17	;BLOCKS READ
RMCTAB==-35	;REMOTE CHARACTERS
RMSTAB==-34	;REMOTE TIME
SERTAB==-4	;ENTERS*SIZE
SINTAB==-5	;BLOCKS IN*SIZE
SLKTAB==-3	;LOOKUPS*SIZE
SOTTAB==-6	;BLOCKS OUT*SIZE
WCTTAB==20	;BLOCKS WRITTEN
SOKTAB==-37	;FROM SOAKEM UUO
JBTBET==-40	;BIO ELAPSED TIME
JBTBIO==-41	;BIO CHRS
JBTMPC==-47	;MAPPED PG COUNT
JBTPWS==-50	;PG TO WORKING SET
JBTPWH==-51	;D.P. PWS*SIZE;  PWH IS HI ORDER, PWL LOW
JLOG==4 ;JOB LOGGED IN BIT
;GETTAB TABLES
STAITM==17	;ITEM FOR STATES WORD
  STSUPR==200000	;SUPER-SHUT BIT
 STSHUT==400000 ;SHUT BIT IN "STATES"
STMDED==1B21	;STREAM DEAD BIT
SUUSCD==1	;SETUUO SCHED OPERATION CODE TO SET STATES WORD
STATAB==11	;TABLE FOR STATES
DATITM==11	;ITEM FOR DATE
DATTAB==11	;TABLE FOR DATE
TIMITM==10	;ITEM FOR TIME
TIMTAB==11	;TABLE FOR TIME
JFYITM==26
JFYTAB==11	;ITEM AND TABLE FOR JIFFIES/SEC
LNKTAB==-36
ACTDED==400000	;BIT IN ACTDDB DEVSTS WORD SET BY WATCHDOG
		;WHEN CHKPNT IS FOUND DEAD, AND CHECKED BY CHKPNT
		;JUST BEFORE INITTING DEVICE TO GOVERN UN-SHUTTING
		;OF SYS. THIS BIT USED TO LIVE IN STATES WORD. /AA
		;THE INIT UUO RESETS IT.

SUBTTL INITIALIZE. OPEN FILES, ASSIGN INTERRUPTS,..
;-STPT PROG MAIN ENTRY PT.
STPT:	RESET
IFE DEB,<	HRROI T1,LICTAB
	GETTAB T1,
	 SKIPA		;SAY NOT OP IF CANNOT GET IT
	TLNN T1,OPRLIC
	 JRST [MOVEI T1,[ASCIZ/
CHKPNT MISSING OP LICENSE,QUITTING/]
		JRST NOTRUN]
	TLC T1,HFLIC!SYLIC!LICJAL!LICGDV	;NEEDS THESE
	TLCE T1,HFLIC!SYLIC!LICJAL!LICGDV
	 JRST [MOVEI T1,[ASCIZ/
CHKPNT LICENSE(S) MISSING,QUITTING/]
		JRST NOTRUN]
MUPLP:
	REPEAT 0,<
	MOVE T1,[STAITM,,STATAB]
	GETTAB T1,		;WAIT FOR AUTO RESTART TO GO OFF
	 MOVEI T1,0
	TLNE T1,1
	JRST WATMUP		;STILL ON, WAIT
	>;REMOVE THIS FOR SYNC WITH INITIA. AAA DEC 76
	MOVE T1,[DATITM,,DATTAB]
	GETTAB T1,		;AND DATE NON-NEG, RESP FROM SUP
	 MOVEI T1,0
	JUMPGE T1,OKUP
WATMUP: MOVEI T1,5	;WAIT 5 SEC
	SLEEP T1,
	JRST MUPLP
OKUP:	HRROI T1,STSTAB
	GETTAB T1,
	 JRST NOJAL
	TLO T1,JACCT
	SETJAL T1,	;SET JACCT BIT
	 JRST NOJAL>
;-END IFE DEB
	MOVE P,[IOWD 40,PDL]
	MOVEI T1,(SIXBIT/ACT/)	;SEE IF ACT DEVICE WAS NOTED AS
	DEVSTS T1,		;HUNG (CHKPNT DIED) BY WATCHDOG
	JFCL			;ALWAYS SKIPS
	TLNN T1,ACTDED		;CHECK THIS BIT BEFORE INITTING,
	TDZA T1,T1		;AS INIT RESETS IT ON SUCCESS.
	MOVEI T1,1		;T1/0 OR 1. LATER USE TO KNOW
	MOVEM T1,RERUN# 	;WHETHER TO UN-SHUT SYSTEM OR NOT
	INIT ACTDV,10	;****INIT ACT DEV WORD MODE INPUT***
	SIXBIT /ACT/
	ABUF
	 JRST [ MOVEI T1,[ASCIZ/
CHKPNT already running./]
		MOVSI T2,(SIXBIT .ACT.); SEE IF DEVICE
		DEVCHR T2,	;ALREADY INITTED. MEANS CHKPNT
		TRNN T2,ASSPRG	;RUNNING IF SO
		 MOVEI T1,[ASCIZ/
Aborting. notify operating system group/]
		JRST NOTRUN]
	MOVEI T1,[ASCIZ/
CHKPNT cant assign ACT device. 
Leave system up; Notify operating system group./]
	PJOB T2,	;***REASSIGN ACT TO THIS JOB*******
	MOVEI T3,ACTDV
	REASSI T2,
	JUMPE T3,NOTRUN
;SET UP FOR STATISTICS GATHERING (SYS)MMDDYY.DAT
	OPEN FIL,OPN	;DUMP RECORDS MODE
	 JRST NODSK
	SETZM USEFIL#		;FLAG ON WHETHER STAT GATHERER
	SETZM USEBUF#
	MOVE T1,[JFYITM,,JFYTAB]
	GETTAB T1,
	 MOVEI T1,^D60
	MOVEM T1,JFYSEC#
	DATE T1,	;TIME-ZONE ADJUSTED DATE
	MOVSS T1	;GET IN PROPER POSITION
	CALL	NEWUSE	;OPEN OLD(OR NEW) (SYS)MMDDYY.DAT FOR APPEND.
	 CALL	NOUSE
;SET UP FOR STREAM FILE OUTPUT (UN1)MMDDYY.SAT
	SETZM STMFIL#
	SETZM STMBUF#
	OPEN STREAM,OPN
	 JRST NODSK	;FATAL MSG
	MOVE T1,[DATITM,,DATTAB]
	GETTAB T1,	;GMT DATE
	 MOVEI T1,0
	MOVSS T1
	CALL	NEWSTM;OPEN OLD(OR NEW) (UN1)MMDDYY.SAT FOR APPEND.
	 CALL NOSTM
	SKIPE USEFIL
	JRST GOPG3
GOPG2A: DATE T1,
	MSTIME T2,
	DATE T3,
	CAME T1,T3
	JRST GOPG2A
	IDIVI T2,^D1000
	MOVSS T1
	HRR T1,T2
	CAMLE T1,USETRM
	JRST	[CALL	NEWUSE
		 CALL	NOUSE
		JRST .+1]
	MOVEM T1,(PTR)	;GENERATE THE RECORD
	HRROI T1,2
	MOVEM T1,1(PTR)
	MOVE T1,JFYSEC
	MOVEM T1,2(PTR) ;GIV JIFFIES/SEC FOR REFERENCE
	CALL NXTREC
	MOVEM PTR,TIMPTR#
GOPG3:	SKIPE STMFIL
	JRST GOPG4
GOPG3A: MOVE T1,[DATITM,,DATTAB];CHECK FOR MIDNITE TRANSITION
	GETTAB T1,
	 MOVEI T1,0
	MOVE T2,[TIMITM,,TIMTAB]
	GETTAB T2,
	 MOVEI T2,0
	MOVE T3,[DATITM,,DATTAB]
	GETTAB T3,
	 MOVEI T3,0
	CAME T1,T3
	JRST GOPG3A
	INBUF ACTDV,4	;***4 INPUT BUFFERS FOR ACT DEV***
	MOVSS T1
	IDIV T2,JFYSEC
	HRR T1,T2
	CAMLE T1,STMTRM
	JRST	[CALL	NEWSTM
		 CALL	NOSTM
		JRST .+1]
	MOVEM T1,SBUF+1
	MOVEM T1,LSTSTD#	;IN CASE OF ERRORS
	MOVE T1,[BYTE (9)RESTYP,0 (18) RESLNG]	;RESTART REC TO STREAM
	MOVEM T1,SBUF
	MOVNI T1,2
	ADDM T1,SBCNT
	MOVEI T1,2
	ADDM T1,SBLOC
	SETOM STMBUF
	SETZM STYTYP
	MOVE T1,[STYTYP,,STYTYP+1]
	BLT T1,STYTYP+MAXSTY-1
	SETZM ACTLOC	;SEE ACTDTA+3. SAVED PC FOR LEVEL 2 PI.
;-HERE REMOVE CALL GETFCT,CALL APPEND UPTIME RECORD
;-FROM "STRHED" AREA
GOPG4:
GOPG5:	MOVE T1,[UPTENT,,UPTTAB]
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,LSTTIM#
	MOVE T1,[NULENT,,NULTAB]
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,LSTNUL#
	MOVE T1,[LOSENT,,LOSTAB]
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,LSTLOS#
	SETOM LSTSWP#	;FOR DISK STATS
	SETOM LSTDSK#
	SETOM LSTMON#
	SETZM LSTPAR#	;AND PARITY STATS
	SETZM UNILST#
	MOVE T1,[JOBENT,,JOBTAB]
	GETTAB T1,
	 MOVE T1,[-^D96,,0]
	MOVNS T1
	HRLZS T1
	MOVEM T1,JOBPTR#	;JOBPTR:=-NUMB JOBS,,0
	MOVEI T1,CHKOFS
	MOVEM T1,CHKCEL#	;SEE TIMINT+5
GOPG6:
	MOVEI T1,0	;CLEAR TIMER
	SETTIM T1,
	 CALL	BADUUO
	MOVE T1,[1,,^D300]	;TIMER FIRES IN 300 SEC=5 MIN
	SETTIM T1,
	 CALL	BADUUO
	MOVEI T1,INTTAB ;ASSIGN SOFTWARE PI SYSTEM. INTTAB,
	HRLI T1,6	;NEXT PG., IS XFER VECTOR
	INTADR T1,
	 CALL	BADUUO
	MOVSI T1,760000 ;ENABLE PI LEVELS 1,2,3,4
	INTENB T1,
	  CALL	BADUUO
	MOVE T1,[NTQCAS,,4];ASSIGN LEV 4 TO CAUSE 11=NoticeToQuit
	INTASS T1,
	  CALL BADUUO
	MOVE T1,[TIMCAS,,3];ASSIGN LEV 3 TO CAUSE 4=TIMCAS=TIMER
	INTASS T1,
	  CALL	BADUUO
	SKIPE STMFIL
	  JRST DETACH
	MOVE T1,[IOWCAS_9+1,,ACTDV];PI LEV 1 <->IO WAIT ACTDV
	INTRMT T1,
	  CALL	BADUUO
	MOVE T1,[INPCAS_9+2,,ACTDV];PI LEV 2 <->INPUT AVAIL
	INTRMT T1,			;FROM ACTDV
	  CALL	BADUUO
; ANNOUNCE CHKPNT INITIALIZATION CONSOLE TTY
GOPG7:
	MOVE T1,[POINT 7,STMERM]
	MOVEM T1,STMERP
	MOVEI T1,[BYTE(7)15,12,1,1,1,1,1,1,1,1,1,0] ;CR DELAY ?!?
	CALL APPERM
	MOVEI T1,[ASCIZ/CHKPNT on job /]
	CALL APPERM
	PJOB N1,
	CALL DECWR
	MOVEI T1,[BYTE(7)15,12]
	CALL APPERM
	MOVEI T1,0	;END MSG W/NULL
	IDPB T1,STMERP
	MOVEI T1,STMERM ;NOW PT AT MSG
	CALL ERRMES	;NOT REALLY AN ERROR MSG
	HRROI T1,PRVTAB ;NOW SET NO ATTACH IN JBTPRV TO KEEP
	GETTAB T1,	;CLOWNS FROM INADVERTENTLY ATTACHING
	 CALL GETER	;TO CHKPNT
	TLO T1,NOATT	;
	SETPRV T1,
;NOW UN-SHUT SYSTEM IF THIS RUN OF CHKPNT IS RECOVERING
;FROM AN ACTDED STATE (FORMER COPY OF CHKPNT DIED).
;THE WATCHDOG IN CLOCK1 SHUT THE SYSTEM WHEN IT DECLARED
;THE ACT DEVICE DEAD.
GOPG8:	MOVE T1,[STAITM,,STATAB]
	GETTAB T1,
	 CALL GETER
	HRLI T1,SUUSCD	;T1/<SETUUO SCHED FN NO.>,,SCHED VALUE
	TRZ T1,STSHUT
	SKIPE RERUN		;SET UP BEFORE INIT OF ACTDV
	SETUUO T1,
	JFCL
; NOW THAT LEVEL 2 IS ENABLED, WE MAY IMMEDIATELY BEGIN
;  GETTING INTERRUPTS. DATA EXISTING IN ACT BUFFER BEFORE
;  CHKPNT BEGAN WILL APPEAR FIRST IN THE STREAM FILE,
;  FOLLOWED BY:
;-HERE PUT UPTIME RECORD IN STREAM
	MOVE T1,[BYTE (9)UPTYP,0(18)UPLENG]	;PUT UPTIME
	MOVE T3,[UPTENT,,UPTTAB]	;RECORD INTO
	GETTAB T3,			;STREAM. GET UPTIME
	SETZ T3,	;(SORRY..)
	MOVEI T2,0	;DATE SUPPLIED BY MONITOR
	MOVEI T4,T1	;POINT AT RECORD
	PUTSAR T4,	;PUT IT IN.
	CALL BADPUT
	CALL	CHECK	;WRITE BEGINNING CKPT RECORDS FOR EVERYBODY
DETACH: MOVNI T1,1
	ATTACH T1,	;****DETACH FROM TTY***
	OUTCHI 0	;HANG HERE. INTERRUPT DRIVEN FROM NOW ON.
	MOVEI T1,0
	SETTIM T1,	;TURN OFF TIMER
	  CALL	BADUUO
	OUTSTR [ASCIZ "
CHKPNT attached! Shutting down...
"]			       ; output to TTY
	MOVEI T1,[ASCIZ "
CHKPNT attached! Shutting down...
"]
	SETUUO T1,	       ; output to CTY
	  JFCL
	PUSHJ P,BYEBYE	       ; clean up
	OUTSTR [ASCIZ "
CHKPNT shut down.  There is now no accounting for this system.
If this was unintentional, run (SYS)CHKPNT."]
	MOVEI T1,[ASCIZ/
CHKPNT shut down.
/]
	SETUUO T1,
	  JFCL
	EXIT
NTQINT: 		       ; Note: HERE ON NTQ interrupt (LEV 4)
			       ; this interrupt is never DISMIS'd
	MOVEI T1,0
	SETTIM T1,	;TURN OFF TIMER
	  CALL	BADUUO
	MOVEI T1,[ASCIZ "
CHKPNT received notice to quit - shutting down
"]
	SETUUO T1,	       ; Tell CTY
	  JFCL
	SETZ T1,	       ; deassign (assign to job 0)
	MOVSI T1+1,(sixbit "ACT"); the ACT device
	REASSI T1,	       ; turn of INIT BY CONSOLE bit
	PUSHJ P,BYEBYE
	MOVSI 1 	       ; Silence LOGOUT
	LOGOFF		       ; Go away!
	EXIT		       ; In case LOGOFF fails
;-CLEAN UP & EXIT AFTER RE-ATTACH or NTQ
BYEBYE: CALL CHECK	;LAST CKPT RECORDS TO STREAM
	CALL FINSTS	;LAST USE&STAT INFO TO "USE" FILE
	SKIPE STMFIL
	  POPJ P,
	MTAPE ACTDV,0	;ASK FOR EOF ON ACTDV INPUT. SEE GETACT
	MOVSI T1,(1B0+1B2)
	INTACT T1,	;FIRE LEVEL 2 ACTDTA
	  CALL BADUUO
	CLOSE STREAM,0	;LAST LEVEL 2 DID REL ACTDV+CLOSE STREAM,4
	MOVSI T1,1	;DISABLE
	INTADR T1,	;ENTIRE PI SYS. NO MORE INTERRUPTS
	  CALL BADUUO
	POPJ P,

;INTERRUPT TRANSFER VECTOR. 3 LEVELS OF SOFTWARE PI.
;
;LEVEL 1- ACTIOW. USED TO BLAST FREE FROM "INPUT ACTDV," IN
;	LEVEL 2 WHICH HANGS FOR INPUT WAIT. LOCATION INTTAB
;	IS MONKEYED WITH & SAVED IN ACTLOC. NEXT TIME LEVEL 2
;	FIRES IT CONTINUES WHERE IT LEFT OFF.
;LEVEL 2- ACTDTA. FIRES WHEN MONITOR BUFFER APPROACHING FULL.
;	DOES INPUT ACTDV, WRITE IN SBUF POINTER SBLOC COUNTER
;	SBCNT. WRITES SBUF TO STREAM OCCASIONALLY
;	(&OPENS NEW FILES AS NEEDED??)
;LEVEL 3- TIMINT. TIMER FIRES EVERY 300 SECS. GATHER USAGE
;	&STAT INFO, WRITE "USE" FILE AS NEEDED.
;	EVERY "CHKOFS" INTERRUPTS, CALL "CHECK" & WRITE
;	CHKPNT RECORDS INTO THE STREAM FOR INPUT BY LEVEL 2.
;LEVEL 4- NTQCAS. NOTICE TO QUIT interrupt goes off at least 60
;	seconds before the system goes down.  This gives us time
;	to clean up.
INTTAB: 0
	ACTIOW
	0
	ACTDTA
	0
	TIMINT
	0
	NTQINT
OPN:	16
	SIXBIT /DSK/
	0
USENAM: 5 ;LOOKUP BLOCK FOR (SYS)MMDDYY.DAT
	1,,4
	0
	SIXBIT /DAT/
	0
	0
STMNAM: 5 ;LOOKUP BL FOR (UN1)MMDDYY.SAT
	STMUSR
	0
	SIXBIT /SAT/
	0
	0
STMUSR: SIXBIT /UN1/
	0
SUBTTL LEVEL 2,1 INTERRUPT ROUTINES
ARRAY ACTSAV,ACISAV[20],ACTPDL[40]
;-************LEVEL 2 PI ROUTINE "ACTDTA"***********
ACTDTA: MOVEM 17,ACTSAV+17	;SAVE AC'S FROM LOWER LEVEL
	MOVEI 17,ACTSAV
	BLT 17,ACTSAV+16
	SKIPN ACTLOC#	;IS THERE AN OLD PC?
	JRST ACTINI
	MOVSI 17,ACISAV ;YES, RESTORE ACS
	BLT 17,17
	JRST @ACTLOC
ACTINI: MOVE P,[IOWD 40,ACTPDL]
	MOVE T1,[CALL LV2DBG]
	MOVEM T1,ACTINI
	JRST ACTLP
LV2DBG: MOVEI T1,[ASCIZ/
CHKPNT SPURIOUS LV 2 INTERRUPT, FATERR/]
	IFN SERDBG,<LIGHTS T1,> ;IN CASE $B SET IN MONITOR
	JRST FATERR
ACTLP:	CALL	GETACT	;THIS SHOULD BE THE HEADER WORD WITH COUNT
	CALL	STMTYC	;CHACK TYPE
	 JRST STMERS	;ERROR. MESSAGE, THEN RTN TO ACTLPC
ACTLPC: PUSH P,T1	;HEADER WORD TO STACK
	CALL GETACT	;DATE/TIME WORD
	CAMLE T1,STMTRM ;IS .LE. DATE ON CURR FILE?
	JRST	[CALL NEWSTM; NEED A NEW FILE
		CALL NOSTM	;FATAL, NO RETURN
		JRST ACTCP1]	;NOW OK, TRANSFER REC TO SBUF
ACTCP1: LDB T2,[POINT 6,(P),35] ;-SIZE FIELD OF HEADER IN STK
	CAMLE T2,SBCNT
	JRST [CALL STMNXR	;OUTPUT RECORD
		CALL SETSTM	;RE-SPECIFY FILE
		CALL NOSTM	;ERROR, DIE
		JRST ACTCP1]	;SHOULD BE ROOM NOW
ACTCP2: MOVE T3,SBLOC
	EXCH T1,(P)
	CALL	ACTDP	;STORE FIRST WORD
	POP P,T1
	MOVEM T1,LSTSTD ;SAVE IN CASE OF ERROR
	CALL	ACTDP	;AND SECOND
	SUBI T2,2
	JUMPLE T2,ACTFN1
	CALL	GETACT
	CALL	ACTDP
	SOJG T2,.-2
ACTFN1: SETOM STMBUF	;RECORD THAT DATA IS PRESENT IN SBUF
	MOVEM T3,SBLOC
	JRST ACTLP
ACTDP: MOVEM T1,SBUF(T3)
	SOS SBCNT
	AOJA T3,CPOPJ
GETACT: SOSG ABUF+2
	IN ACTDV,0
	JRST GETAC1	;ALL OK
	STATZ ACTDV,20000
	JRST ACTEOF	;HAPPENS WHEN CLOSING DOWN
	SETSTS ACTDV,10 ;CLEAR ERROR BIT
GETAC1: ILDB T1,ABUF+1
	POPJ P,
ACTEOF: RELEASE ACTDV,0
	SKIPE STMBUF
	CALL	STMNXR	;DUMP RECORD
	CLOSE STREAM,4
LEVACT: MOVSI 17,ACTSAV
	BLT 17,17
	DISMIS		;LEAVE INTERUPT LEVEL
STMCOM: IOWD 200,SBUF
	0
;-CHECK TYPES & LENGTHS OF INCOMING RECORDS
STMTYC: LDB T3,[POINT 9,T1,8]	;TYPE
	CAIL T3,MAXSTY
	POPJ P, 	;TYPE TOO BIG
	SKIPE T2,STYTYP(T3)
	JRST ACTTY1	;HAVE TYPE ALREADY
	MOVE T2,T3
	UGETF ACTDV,T2
	MOVEM T2,STYTYP(T3)
ACTTY1: LDB T3,[POINT 6,T1,35]	;-T3:=SIZE FIELD
	PUSH	P,T4
        TLNN    T2,-1           ;IS REC VAR LEN?
        JRST    ACTTY2          ;NO
        HLRZ    T4,T2           ;GET MIN SIZE IN T4
        HRRZS   T2              ; AND MAX IN T2
        CAML    T3,T4           ;SIZE TOO SMALL OR
        CAMLE   T3,T2           ; TOO LARGE?
	JRST	ACTTY3		;YES, ERROR RETURN
        SKIPA
ACTTY2: CAMN    T3,T2
        AOS     -1(P)
ACTTY3:	POP	P,T4
	POPJ P,
;-*************************************END OF LEVEL 2****
;-LEVEL 1 HI PRIORITY INTERRUPT. UNHANG STUCK "IN ACTDV,0"
;	& SAVE PC FOR CONTINUE LATER WHEN INPUT AVAILABLE.
ACTIOW: MOVEM 17,ACISAV+17	;SAVE ACS FOR NEXT TIME
	MOVEI 17,ACISAV
	BLT 17,ACISAV+16
	MOVEI T1,LEVACT
	EXCH T1,INTTAB
	MOVEM T1,ACTLOC ;SAVE LOC INTERUPTED FROM
	DISMIS		;AND DISMIS AND FORCE LOWER LEVE DISMIS
;****END LEVEL 1 **********
INTEGER STMERP ;POINTER FOR MAKING STRING ERR MSG
ARRAY STMERM [^D80/5]	;80 CHARS AT LEAST
ARRAY SERAC [6] ;FOR DUMP AC'S ON ENTRY TO STMERS

SERDBG==0	;FLAG 1 FOR DEBUG STM ERR RECORDS,0 FOR NORMAL
;-HERE IF ACT DATA INCONSISTENT. CALLED JRST STMERS FROM LEVEL 2
STMERS: MOVEM T5,SERAC+5
	MOVEI T5,SERAC	;FROM AC0 TO SERAC+0
	BLT T5,SERAC+4
	IFN SERDBG, <LIGHTS 0,> ; SYSCRS OR $B AT LIGHTS IN MONITOR
		; TO CATCH THIS & EXAMINE ACTBUF
	MOVE T1,[POINT 7,STMERM]
	MOVEM T1,STMERP ;INIT STR PTR FOR MAKE MESSAGE
	MOVEI T1,[ASCIZ/
CHKPNT DATA ERROR /]
	CALL APPERM
	MOVE T4,SERAC+T1	;RECOVER BAD HEADER FROM T1
	CALL OUTNUM	;MAKE STRING IN N1,N2,N3 POINT AT IN T1
	CALL APPERM
	MOVEI T1," "
	IDPB T1,STMERP
	MOVE T4,LSTSTD
	CALL OUTNUM
	CALL APPERM
	MOVEI T1," "
	IDPB T1,STMERP
	CALL APPERD	;WRITE DATE ON STRING END
	SETZ T1,	;WRITE NULL TO TERMINATE
	IDPB T1,STMERP	;ERR MSG STR
	MOVEI T1,STMERM
	CALL ERRMES	;PUT ALL ON CONSOLE TTY
IFE SERDBG,<
; NOW PUT ERROR REC INTO STREAM
	MOVEI T1,ERRLNG
	CAMG T1,SBCNT	;IS THERE ROOM?
	JRST STMER0	;YES
	CALL STMNXR
	CALL SETSTM
	 CALL NOSTM
STMER0: MOVE T3,SBLOC
	MOVE T1,[BYTE (9)ERRTYP,0(18)ERRLNG]	;ERR REC HEADER
	CALL ACTDP	;WRITE IT
	MOVE T1,LSTSTD
	CALL ACTDP	;RECORD LAST GOOD REC TIME,DATE
	MOVEM T3,SBLOC	;REPLACE INDEX
	SETOM STMBUF
; EAT WORDS UNTIL GOOD HEADER APPEARS
STMER1: CALL GETACT	;NEXT WORD
	CALL STMTYC	;SKIP IF GOOD HEADER WORD
	JRST ST;BAD,EAT ANOTHER
	PUSH P,T1	;SAVE THIS GOOD HEADER
	MOVSI T5,SERAC	;FROM SERAC+0 TO AC0
	BLT T5,T5	;THRU T5=AC5
	POP P,T1	;RECOVER THIS GOOD HEADER
	JRST ACTLPC	;NOW GO CONTINUE W/GOOD RECORDS
>; END USUAL CODE FOR HANDLE STREAM ERROR
IFN SERDBG,<
;SPECIAL CODE TO PUT ALL ERROR DATA INTO STREAM FILE
;PRECEEDED BY A 403000,,0 HEADER & TRAILED BY A 404000,,0
IF2,<PRINTX SPECIAL STREAM ERROR DEBUG CODE INCLUDED>
	MOVSI T1,(BYTE (9)ER3TYP)
	CALL DBGDP
	MOVE T1,SERAC+T1
	CALL DBGDP	;PUT IN BAD HEADER VALUE
STMERL: CALL GETACT	;GET DATA FR ACT DEV
	CALL STMTYC	;SKIP IF GOOD HEADER
	JRST [CALL DBGDP;BAD, PUT IN ERR REC
		JRST STMERL]; KEEP ON TILL GOOD
	PUSH P,T1	;SAVE THE GOOD HEADER
	MOVSI T1,(BYTE (9)ER4TYP)
	CALL DBGDP	;WRITE IT
	MOVSI T5,SERAC	;RESTORE 0 - T5
	BLT T5,T5
	POP P,T1	;RECOV GOOD HEADER
	JRST ACTLPC	;CONTINUE W/GOOD RECORDS
DBGDP:	SKIPLE SBCNT
	JRST DBGDP2
	PUSH P,T1
	CALL STMNXR
	CALL SETSTM
	 CALL NOSTM
	POP P,T1
DBGDP2: MOVE T3,SBLOC
	CALL ACTDP
	MOVEM T3,SBLOC
	POPJ P,
>; END SPECIAL DEBUG CODE.
;-HERE AT LEVEL 2 TO WRITE SBUF TO STREAM FILE. PUSHJ HERE
STMNXR: PUSH P,T1
	MOVEI T1,200
	SUB T1,SBLOC
	JUMPE T1,TPOPO		;BUFFER IS FULL
	HRLI T1,(BYTE (9)DUMTYP)	;SKIP RECORD
	PUSH P,T2
	MOVE T2,SBLOC
	MOVEM T1,SBUF(T2)
	POP P,T2
TPOPO:	OUTPUT STREAM,STMCOM
	SETZM STMBUF
	CLOSE STREAM,6
	POP P,T1
	POPJ P,

;-NEWUSE .. GENERATE NEW "USE" FILE, SET PTR,USEBUF,CLREAR BUF
;	CALLED AT INITIALIZATION & IN LEVEL 3
NEWUSE: PUSH P,T1
	HLLOM T1,USETRM#
	HLRZS T1	;JUST DATE
	CALL	GENNMM	;GENNERATE NAME
	MOVEM T3,USENAM+2
	SKIPE USEBUF
	OUTPUT FIL,COM	;NEEDS AN OUTPUT
	CLOSE FIL,0	;DONE WITH THE FILE
	SETZM USEBUF
NEWUS1: LOOKUP FIL,USENAM
	 JRST NEWUSF	;NEED TO GENERATE A NEW FILE
NEWUS2: SETZM USENAM+4	;SO DATE GETS UPDATED
	HLLZS USENAM+3
	ENTER FIL,USENAM
	 JRST TPOPJ	;ERROR
	MOVE T1,USENAM+5
	ADDI T1,177
	LSH T1,-7
	USETO FIL,1(T1)
	SETZM BUF	;CLEAR BUFFER
	MOVE T1,[BUF,,BUF+1]
	BLT T1,BUF+177
	MOVSI PTR,-8
	HRRI PTR,BUF
	SETZM USEBUF	;NOT NOW IN USE
TPOPJ1: AOS -1(P)
TPOPJ:	POP P,T1
	POPJ P,
NEWUSF: HRRZ T1,USENAM+3
	JUMPN T1,TPOPJ	;UNLESS NOT FOUND, ITS ERROR
	ENTER FIL,USENAM
	 JRST TPOPJ	;CAN NOT ENTER
	CLOSE FIL,4
	JRST NEWUS1	;AND GO
;-ENTER HERE FROM LEVEL 3,"NXTREC"
SETFIL: PUSH P,T1
	JRST NEWUS2
;-NEWSTM..GENERATE NEW (UN1)MMDDYY.SAT STREAM FILE. OR
;	PUT EXISTING ONE IN UPDATE MODE,WIND FORWARD TO
;	APPEND DATA. SET SBLOC,SBCNT,CLEAR SBUF
;	CALLED AT INITZN & IN LEVEL 2
;IT CAN HAPPEN THAT NEWSTM IS UNABLE TO OPEN MMDDYY.SAT.
; IT TRIES 64 ALTERNATIVES MMDDYY.S01, S02, ...
; IF CHKPNT SHOULD DIE & A NEW COPY BE RUN, THE NEW
; COPY MIGHT APPEND MORE DATA TO MMDDYY.SAT EVEN THOUGH
; .S01 .S02 ETC. FILES MIGHT EXIST & BE MORE CURRENT.  IF
; THIS PROVES TO BE A PROBLEM, CODE MUST BE PUT AT
; OKUP: INIT'ZN CODE TO LOCATE HIGHEST EXTENSION PRESENT
; FOR MMDDYY AND PUT THAT IN STMNAM+3 BEFORE CALLING
; NEWSTM 1ST TIME.
NEWSTM: PUSH P,T1
	HLLOM T1,STMTRM#
	HLRZS T1	;JUST DATE
	CALL GENNM1	;CONV T1 TO DEC STYLE DATE,MAKE NAME
	MOVEM T3,STMNAM+2
	SKIPE STMBUF
	CALL STMNXR
	CLOSE STREAM,0
	SETZM STMBUF	;FIX 1 DEC 76 AAA , WAS SETZM USEBUF
NEWST1: LOOKUP STREAM,STMNAM
	JRST [	HRRZ T1,STMNAM+3	;ERROR CODE FROM LOOKUP
		JUMPN T1,TPOPJ
		ENTER STREAM,STMNAM
		 JRST TPOPJ
		CLOSE STREAM,4
		JRST NEWST1]
NEWST2: SETZM STMNAM+4	;FORCE UDATE CREATION TIME
	HLLZS STMNAM+3	;& ACCESS TIME.
	ENTER STREAM,STMNAM
	JRST [	HRRZ T1,STMNAM+3	;ENTER ERR COD
		JUMPE T1,TPOPJ		;NOT FOUND!? NEWSTM FAIL RTN
		CLOSE STREAM,0		;BUSY OR FILE ERR. ADVANCE
		CALL NXTALT		;TO NEXT ALTERNATE EXTENSION
		JRST NEWST1]		;GET NEW FILE TO UPDATE MODE
	MOVE T1,STMNAM+5	;FILE POSN
	ADDI T1,177
	LSH T1,-7
	USETO STREAM,1(T1)
	SETZM SBUF
	MOVE T1,[SBUF,,SBUF+1]
	BLT T1,SBUF+177
	SETZM SBLOC#
	MOVEI T1,200
	MOVEM T1,SBCNT# ;BUFFER POSITION ND COUNT
	SETZM STMBUF
	JRST TPOPJ1
;-ENTER HERE FROM "ACTCP1" LEVEL 2
;-RE-OPEN OUTPUT SIDE OF STREAM CHANNEL. INT ROUTINE HAS
; ALREADY DONE CLOSE CH,4.  NOW FORCE UPDATE OF ACCESS,
; CREATION TIMES & RE-OPEN FOR APPEND.
SETSTM: PUSH P,T1
	JRST NEWST2
;-NXTALT.. ENTER HERE TO GET NEXT ALTERNATIVE EXTENSION FOR
;	STREAM FILES. USUALLY USE MMDDYY.SAT, BUT IF NEED BE,
;	CHKPNT WILL OPEN MMDDYY.S01, MMDDYY.S02,,,QUIT AT
;	MMDDYY.S77 & CALL NOSTM, FATAL ERROR.
NXTALT: HLRZ T1,STMNAM+3
	CAIN T1,(SIXBIT/S77/)
	CALL NOSTM		;RAN OUT OF ALTERNATIVES
	CAIN T1,(SIXBIT/SAT/)
	MOVEI T1,(SIXBIT/S00/)
	ADDI T1,1
	TRNN T1,7	;DID WE CARRY?
	ADDI T1,100-10	;YES.  "S07" --> "S10", ETC.
	HRLZM T1,STMNAM+3
	POPJ P,
;-GENNAM..GENERATE NAME OF FORM MMDDYY IN T3 FOR OPENING
;	NEW "USE" OR "STREAM" FILE. THIS ROUTINE EXTRACTED
;	FROM OLD "APPEND" PKG.
;ENTRIES:
;	GENNAM:  NO ARGS. GET DATE FR SYS, CONVERT, RETURN T2,T3
;	GENNM1:  T1=GMTDAT VALUE TO USE. CONVERT, RETURN T2,T3
;	GENNMM:  T1=DEC DATE,CONVERT, RETURN T3
;RETURNS: RT0 ALWAYS
;	T3=SIXBIT NAME MMDDYY
;	T2 CORRESPONDING NUMERIC MMDDYY GENNAM,GENNM1 ONLY
;CALLED: "NEWUSE" & "NEWSTM"
GENNAM: MOVE T1,[DATITM,,DATTAB]
	GETTAB T1,
	 MOVEI T1,0
GENNM1: MOVEM T1,GMTDAT#	;SAVE IT
	MOVEM T1,DCNV
	SETZM DCNV+1
	MOVSI T1,400000 ;JUST FROM DAYS TO DEC STYLE DATE
	MOVEM T1,DCNV+2
	MOVEI T1,DCNV
	DATUUO T1,
	 JFCL
	MOVE T1,DCNV
GENNMM: IDIVI T1,^D31
	PUSH P,T2	;DAY-1
	IDIVI T1,^D12
	PUSH P,T2	;MONTH-1
	ADDI T1,^D64
	CAIL T1,^D100
	SUBI T1,^D100	;CONVERT 20XX INTO XX
	MOVE T2,[POINT 6,T3,29] ;SPOT FOR FIRST DIGIT
	PUSHJ P,SXNM
	POP P,T1	;MONTH-1
	ADDI T1,1
	MOVE T2,[POINT 6,T3,5]
	PUSHJ P,SXNM
	POP P,T1
	ADDI T1,1
	MOVE T2,[POINT 6,T3,17] ;DAY
	PUSHJ P,SXNM
	MOVE T2,GMTDAT
	POPJ P,
SXNM:	PUSH P,T2	;BYTE POINTER
	IDIVI T1,^D10
	ADDI T1,'0'
	DPB T1,(P)
	ADDI T2,'0'
	IDPB T2,(P)
	POP P,T2
	POPJ P,
SUBTTL TIMER-LEVEL CODE FOR "USE" & CHKPNT RECORDS.
;HERE WHEN THE TIMER GOES OFF
TIMINT: MOVEM 17,USESAC+17
	MOVEI 17,USESAC
	BLT 17,USESAC+16
	MOVE P,[IOWD 40,USEPDL]
	MOVE PTR,TIMPTR
	SOSL CHKCEL
	JRST NOCHK
	CALL	CHECK
	MOVEI T1,CHKOFS
	MOVEM T1,CHKCEL
NOCHK:	SKIPE USEFIL
	JRST DONINT
	CALL	GENERR
	CALL	GENSTS
DONINT: MOVE T1,[1,,^D300]	;SET TIMER AGAIN
	SETTIM T1,
	 CALL	BADUUO
	MOVEM PTR,TIMPTR
	MOVSI 17,USESAC
	BLT 17,17
	DISMIS		;AND LEAVE INTERUPT
;-ENTER HERE AT NON INTERRUPT LEVEL TO FINISH STAT INFO.
FINSTS: MOVE PTR,TIMPTR
	CALL	GENERR	;CLEAN UP ANY EXTRA ERRORS
	SETZB T1,SNSCNT#;THIS IS TO GET THE FINAL SENSE DONE ON 3330'S
RRSET:	SYSPHY T1,	;GET THE NEXT UNIT NAME
	 JRST NOWERR	;ERROR FROM SYSPHY, GET ERRORS NOW
	JUMPE T1,NOWERR ;OR ON END OF LIST
	MOVEM T1,RRSETB+1;SET UNIT NAME TO FORCE READ AND RESET LOG
	MOVE T2,[2,,RRSETB]
	STRUUO T2,
	 JRST RRSET	;ERROR RETURN, DO NOT FORCE ONE
	AOS SNSCNT	;COUNT ONE MORE TO DO
	JRST RRSET
NOWERR: CALL	GENERR	;FOR NOW JUST FINISH UP ERROR CONDTIONS
	SKIPE USEFIL	;IN CASE HAD TO SWITCH FILES AND COULD NOT
	POPJ P, 	;JUST GIVE UP
	SKIPG SNSCNT	;ANY MORE TO DO?
	JRST FINERR	;NO, DONE
	MOVEI T1,1
	SLEEP T1,	;SLEEP FOR A SECOND
	JRST NOWERR	;AND TRY AGAIN
FINERR: SKIPE USEBUF
	OUTPUT FIL,COM	;WRITE LAST BUFFER
	CLOSE FIL,4	;AND CLOSE IT
	POPJ P,
RRSETB: 11		;STRUUO FUNCTION 11, READ AND RESET BUFFERED LOG (FOR 3330)
	0		;UNIT NAME GOES HERE
;GENERATE STATUS INFORMATION
GENSTS: SKIPE USEFIL
	POPJ P,
	MOVE T1,CURTIM
	HRL T1,CURDAT
	MOVEM T1,(PTR)
	MOVE T1,[UPTENT,,UPTTAB]
	GETTAB T1,
	 JRST GETER
	MOVEM T1,LSTUPT#
	EXCH T1,LSTTIM
	SUB T1,LSTTIM
	MOVNM T1,1(PTR)
	MOVNM T1,INCUPT#	;FOR DSK RECORD
	MOVE T1,[NULENT,,NULTAB]
	GETTAB T1,
	 JRST GETER
	EXCH T1,LSTNUL
	SUB T1,LSTNUL
	MOVNM T1,2(PTR)
	MOVE T1,[LOSENT,,LOSTAB]
	GETTAB T1,
	 JRST GETER
	EXCH T1,LSTLOS
	SUB T1,LSTLOS
	MOVNM T1,3(PTR)
	HLRE T1,JOBPTR	;T1/-NUMBER JOBS SYSTEM CONFIGURED FOR
	MOVNS T1
	SUBI T1,1	;T1/LAST JOB NO.
	HRRZ T2,JOBFF
	MOVE T3,T2	;T2 WILL REMEMBER FORMER JOBFF
	ADDI T3,1(T1)
	IORI T3,1777
	CAMG T3,JOBREL
	JRST COROK
	CORE T3,
	 JRST CORER
COROK:	CALL	SIZJOB
	SOJG T1,.-1
	MOVE T3,5(PTR)
	IDIV T3,4(PTR)
	MOVEM T3,6(PTR)
SRLP1:	HRRZ T1,JOBFF
	CAML T1,T2
	JRST FNDMOD	;FIND MEDIAN JOB SIZE
	HRRZ T3,(T1)
	HRL T3,T1
	ADDI T1,1
SRLP:	CAML T1,T2
	JRST FINSRL
	MOVE T4,(T1)
	CAIG T4,(T3)
	AOJA T1,SRLP
	HRRZ T3,T4
	HRL T3,T1
	AOJA T1,SRLP
FINSRL: MOVE T4,-1(T2)
	MOVSS T3
	EXCH T4,(T3)
	MOVEM T4,-1(T2)
	SOJA T2,SRLP1
FNDMOD:	MOVE T1,4(PTR)
	SUBI T1,1
	IDIVI T1,2
	ADD T1,JOBFF
	MOVE T3,(T1)
	ADD T1,T2
	ADD T3,(T1)
	IDIVI T3,2
	MOVEM T3,7(PTR)
	CALL	NXTREC
	SKIPE USEFIL
	POPJ P, 	;IN CASE WE LOST WRITING THAT ONE
	SKIPGE T1,LSTDSK	;FIRST TIME?
	JRST	[MOVE T1,CURDSK
		MOVEM T1,LSTDSK
		MOVE T1,CURMON
		MOVEM T1,LSTMON
		MOVE T1,CURSWP
		MOVEM T1,LSTSWP
		MOVEI T1,TRUTAB ;NUMBER OF TRU'S TOTAL
		GETTAB T1,
		 MOVEI T1,0
		MOVEM T1,LSTTRU#
		POPJ P,]	;JUST SET VARIABLES
	MOVE T2,CURDSK
	MOVEM T2,LSTDSK
	SUB T2,T1
	MOVEM T2,3(PTR) ;DISK USAGE
	MOVE T1,CURSWP
	EXCH T1,LSTSWP
	SUB T1,LSTSWP
	MOVNM T1,4(PTR) ;AND SWP
	HRROI T1,7
	MOVEM T1,1(PTR)
	MOVE T1,INCUPT
	MOVEM T1,2(PTR) ;INCREMENTAL UPTIME
	MOVEI T1,TRUTAB
	GETTAB T1,
	 MOVEI T1,0
	EXCH T1,LSTTRU
	SUB T1,LSTTRU
	TLO T1,400000	;JUST IN CASE OF SINGLE PRECISION OVERFLOW
	MOVNM T1,5(PTR) ;INCREMENTAL TRU'S
	MOVE T1,CURTIM
	HRL T1,CURDAT
	MOVEM T1,(PTR)
	MOVE T1,CURMON
	EXCH T1,LSTMON
	SUB T1,LSTMON
	MOVNM T1,6(PTR) 	;NUMBER OF PAGES OF MONITOR (PCB) I/O
				; FALL INTO NXTREC TO WRITE
NXTREC: ADDI PTR,17
	SETOM USEBUF		;BUFFER HAS DATA
	AOBJN PTR,CPOPJ
	OUTPUT FIL,COM
	CLOSE FIL,6
	CALL SETFIL
	 JRST NOUSE		;ERROR
	POPJ P,
COM:	IOWD 200,BUF
	0
NOJAL: MOVEI T1,[ASCIZ /
CHKPNT HAS INSUFFICIENT LICENSE/]
;ENTER AT NOTRUN T1/ADDR OF ASCIZ
NOTRUN: MOVEI T2,0
	SETNAM T2,	;FOR INITIA
	GETLIN T3,	;MAKE SURE WE CAN OUTSTR W/O HANGING UP
	HLRZS	T3	;RETURNS LH ZERO IF DETACHED
	JUMPE T3,FATERR ;NO TTY,PUT ON CTY & DIE
	OUTSTR (T1)	;JRST NOTRUN with T1/ addr or asciz err msg
	CALL ERRMES	;CTY too
	EXIT
FATERR: CALL ERRMES	;CALL FATERR W/T1 PT AT MESSAGE
	RESET
	MOVEI T1,0
	SETNAM T1,	;FOR INITIA
	HALT .
ERRMES: SETUUO T1,
	 JFCL
	POPJ P,
NODSK:	MOVEI T1,[ASCIZ /
CHKPNT unable to access DSK:/]
	JRST FATERR
NOUSE:	MOVEI T1,[ASCIZ /
CHKPNT not gathering statistical data (not fatal)/]
	CALL	ERRMES
	SETOM USEFIL
	RELEASE FIL,0
	POPJ P,
NOSTM:	RELEASE STREAM,
	RELEASE ACTDV,
	MOVE T1,[POINT 7,STMERM]
	MOVEM T1,STMERP
	MOVEI T1,[ASCIZ/
job /]
	CALL APPERM
	PJOB N1,
	CALL DECWR
	MOVEI T1,[ASCIZ/ CHKPNT no acctg files. 
Leave system up; notify operating system group/]
	CALL APPERM
	MOVEI T1,STMERM
	JRST FATERR
BADUUO: MOVEI T1,[ASCIZ /
CHKPNT illegal uuo function./]
	JRST FATERR
GETER:	MOVEI T1,[ASCIZ /
CHKPNT GETTAB error./]
	JRST FATERR
CORER:	MOVEI T1,[ASCIZ /
CHKPNT insufficient core./]
	JRST FATERR
BADPUT: MOVEI T1,[ASCIZ/
CHKPNT PUT-STREAM UUO failure,/]
	CALL ERRMES
	CAIG T4,3
	CAIGE T4,0	;CODES 0-3 LEGAL
	MOVEI T4,4
	MOVE T1,BADMSG(T4)
	CALL ERRMES
	MOVEI T1,[ASCIZ/
location:/]
	CALL ERRMES
	HRRZ T4,(P)
	CALL OUTNUM
	JRST FATERR
BADMSG: [ASCIZ/ no ACT owner!?/]
	[asciz/ license wrong/]
	[asciz/ size wrong/]
	[asciz/ bad record type/]
	[asciz/ illeg error code/]
;OUTNUM..MAKE OUTPUT 12-DIGIT OCTAL STRING OUT OF NUMBER IN T4.
; RETURN RT0: T1/ "N1" POINT AT STRING FOR ERRMES TO PRINT
;	T2/ GARB (USED BYTE PTR)
;	T4/ GARB
;	T5/GARB
;	N1,N2,N3/ ASCII STRING
OUTNUM: MOVE T1,T4	;SAVE DATA FOR 2 HALFWORD OPERATIONS
	MOVE T2,[POINT 7,N1]
	SETZB N1,N2
	SETZ N3,
	HLRZ T4,T1
	CALL OUTNU1	;DO LEFT HALF
	MOVEI T4,","
	IDPB T4,T2
	IDPB T4,T2	;LEFT HALF,,RIGHT HALF
	HRRZ T4,T1
	MOVEI T1,N1	;POINT AT STRING
OUTNU1:
	IDIVI T4,^D8
	PUSH P,T4+1	;T5 HAS REMDR
	SKIPE T4
	PUSHJ P,.-3
	POP P,T4
	ADDI T4,"0"
	IDPB T4,T2
	POPJ P,
;APPERM APPEND STRING POINTED TO BY T1 TO STMERM.
; QUIT ON NULL
APPERM: HRLI T1,(POINT 7,0)	;MAKE BYTE PTR
	PUSH P,T1
APPER2: ILDB T1,(P)
	JUMPE T1,APPERX
	IDPB T1,STMERP
	JRST APPER2
APPERX: POP P,T1
	POPJ P,
;-APPERD..WRITE DATE TO END OF STMERM STRING
;CLOBBER T1,N1,N2,N3
APPERD:
	MSTIME T1,
	IDIVI T1,^D1000 ;T1:=SECONDS
	IDIVI T1,^D60	;T1_MIN T2_SEC
	PUSH P,T2
	IDIVI T1,^D60	;T1_HRS, T2_MIN
	MOVE N1,T1
	PUSHJ P,DECWR
	MOVEI T1,":"
	IDPB T1,STMERP
	MOVE N1,T2	;MINUTES
	PUSHJ P,DECWR
	IDPB T1,STMERP	;COLON SEPARATOR
	POP P,N1	;SAVED SECONDS
	PUSHJ P,DECWR
	MOVEI T1," "
	IDPB T1,STMERP	;APPENDED "HH:MM:SS " TO STR
	DATE T2,
	IDIVI T2,^D31	;T2 MONTHS,T3 DAYS
	MOVEI N1,1(T3)
	PUSHJ P,DECWR	;N1 DAYS TO STRING
	IDIVI T2,^D12
	MOVEI N1,MONTAB(T3)	;POINT N1 AT MONTH STR
	HRLI N1,(POINT 7,0)	;MAKE BYTE PTR
STMER7: ILDB T1,N1
	IDPB T1,STMERP	;COPY MONTH NAME TO ER MSG STR
	TLNE N1,760000	;SKIP IF 5 CHARS WRITTEN
	JRST STMER7
	MOVEI N1,^D1964(T2)
	PUSHJ P,DECWR	;YEAR TO STRING
	POPJ P,
MONTAB: ASCII /-JAN-/
	ASCII /-FEB-/
	ASCII /-MAR-/
	ASCII /-APR-/
	ASCII /-MAY-/
	ASCII /-JUN-/
	ASCII /-JUL-/
	ASCII /-AUG-/
	ASCII /-SEP-/
	ASCII /-OCT-/
	ASCII /-NOV-/
	ASCII /-DEC-/
;NUMBER WRITERS: DECWR, OCTWR
;EXPECTS N1/ NUMBER TO CONVERT & APPEND TO APPERM STRING
;STMERP/ BP TO CURRENT STRING POS
; RADIX WRITER RDXWR EXPECTS N4/ RADIX ALSO
;CLOBBER N1-N4
OCTWR:	SKIPA N4,[^D8]
DECWR:	MOVEI N4,^D10
RDXWR:	MOVEI N3,"0"
	CAIG N1,-1(N4)
	IDPB N3,STMERP	;INSURE LEADING ZERO
RDXWR2: IDIV N1,N4
	HRLM N2,0(P)
	SKIPE N1
	PUSHJ P,RDXWR2
	HLRZ N3,0(P)
	ADDI N3,"0"
	IDPB N3,STMERP
	POPJ P,
;SIXBIT APPENDER   APP6B
;EXPECTS T3,T4 SIXBIT STRING TO APPEND TO STMERM
;STMERP/ BP TO CURR STRING POS
;CLOBBERS: T2,T3,T4	  WRITES 12 CHARS MAX, STOPS ON NULL
		LSHC T3,6	;LOAD OUT OF TOP BYTE OF T3+T4
APP6B:	LDB T2,[POINT 6,T3,5]
	ADDI T2,40
	IDPB T2,STMERP
	CAIE T2,40	;GOT A 00 BYTE?
	JRST APP6B-1	;NO,SHIFT 6 AND CONTINUE
	POPJ P,
UNINAM==0
UNILOG==2
UNIHCT==10
UNISCT==11
UNIERR==13
UNISOF==14
UNIHBN==15
UNIICT==25
UNIOCT==26
UNIBRC==16
UNIDRC==20
UNIMRC==22
UNIBWC==17
UNIDWC==21
UNIMWC==23
UNISDI==32
UNIHDI==33
UNIECT==34
UNISBN==35
UNIDIL==56	;LENGTH OF DEVICE INDENDENDENT PART OF UNITCB
UNISNS==UNIDIL+10	;SENSE BYTE GO HERE IN UNIT DATA BLOCK
UNISNC==UNIDIL+16	;SENSE COUNT HERE
SWPSIZ==^D9
SWPPOS==^D35
UNISBH==UNIDIL+4	;REGISTERS SAVED HERE ON HARD ERROR
UNISHS==UNIDIL+15	;REGISTERS SAVED HERE ON SOFT ERROR
  NRSW==11	;NUMBER OF RH11/RM03 STATUS WORDS SAVED.
UNIDES==50
UNIKTP==UNIDES	;;BITS 21-26 CONTROLLER TYPE OF UNIT'S CONTROLLER.
  UNSKTP==^D6	;;BYTE SIZE
  UNNKTP==^D26	;;BYTE PTR POS.
  TYPDR==0	;; 0	DR (FUTURE DRUM, IF ANY)
  TYPFH==1	;; 1	FH (BURROUGHS DISK OR BRYANT DRUM)
  TYPDP==2	;; 2	DP (MEMOREX RP01,RP02)
  TYPMD==3	;; 3	MD (BRYANT MASS DISK)
  TYPBP==4	;; 4	BP (CONTROLLER FOR 3330 UNITS)
  TYPRM==5	;; 5	RM (RH11C CONTROLLER FOR RM03 UNITS)
  MCT==5	;; HIGHEST CONTROLLER TYPE WE KNOW ABOUT.
UNIUTP==UNIDES	;BITS 30-31, UNIT TYPE WITHIN CONTROLLER
  UNSUTP==2	;BYTE SIZE
  UNNUTP==^D31	;POSITION
UNYUTP: POINT UNSUTP,UNIUTP+SYSBLK,UNNUTP
UNYKTP: POINT UNSKTP,UNIKTP+SYSBLK,UNNKTP	;TYPE CODE OF UNIT'S CONTROLLER.
GENERR: SKIPE USEFIL
	POPJ P,
	DATE T1,
	MOVEM T1,CURDAT#
	MSTIME T1,
	IDIVI T1,^D1000
	MOVEM T1,CURTIM#
	DATE T1,
	CAME T1,CURDAT
	 JRST GENERR		;PASSING MIDNIGHT
	MOVSS T1
	HRR T1,CURTIM
	CAMG T1,USETRM
	 JRST GENER2		;NEED NEW FILE?
	CALL NEWUSE		;YES
	 JRST NOUSE		;COULD NOT GET IT
	MOVE T1,CURTIM
	HRL T1,CURDAT
	MOVEM T1,(PTR)
	HRROI T1,10
	MOVEM T1,1(PTR)
	MOVE T1,JFYSEC
	MOVEM T1,2(PTR) ;MAKE SURE KNOWN
	CALL NXTREC
;HERE TO WRITE STREAM RECORDS FROM UDBS.
;FOR EACH UNIT IN THE SYSTEM, SAVE ANY NEW ERRORS AND SENSE DATA.
; THE FORMER ARE TYPE -1,,0 RECORDS, THE LATTER -1,,4.
GENER2: SKIPE USEFIL
	 POPJ P,
	MOVEI T1,2		;SET TO READ ALL UDBS BY NAME
	MOVEM T1,LOC
	SETZM SYSNAM
	SETZM CURSWP#
	SETZM CURMON#
	SETZM CURDSK#
NXTUNI: MOVE T1,[XWD 120,LOC]	;LOOP THROUGH HERE UNTIL END OF UDB LIST.
	SYSDVF T1,
	 JRST GETER
	SKIPN T1,SYSNAM 	;FINISHED?
	 JRST DOMTA		;YES.
	MOVE T2,SYSBLK+UNIMRC
	ADD T2,SYSBLK+UNIMWC	;NUMBER OF PCB PAGES
	ADDM T2,CURMON
	LSH T2,2		;TO BLOCKS
	MOVNS T2		;SUBTRACT FROM "SWAP" COUNT
	ADD T2,SYSBLK+UNIICT
	ADD T2,SYSBLK+UNIOCT
	ADDM T2,CURSWP		;RECORD THINGS FOR TRANSFERS
	MOVE T2,SYSBLK+UNIBRC
	ADD T2,SYSBLK+UNIDRC
	ADD T2,SYSBLK+UNIMRC
	ADD T2,SYSBLK+UNIBWC
	ADD T2,SYSBLK+UNIDWC
	ADD T2,SYSBLK+UNIMWC
	ADDM T2,CURDSK
	MOVE T2,SYSBLK+UNIHCT
	IOR T2,SYSBLK+UNISCT
	JUMPE T2,DOSNS		;J-NO ERRORS ON CURRENT UNIT.
	CALL FNDUNI		;FIND THE UNIT IN THE LIST.
	 JRST UNICOM		;NEW UNIT, DO NOT CHECK ERRORS.
	MOVE T1,SYSBLK+UNIHCT	;COMPARE ERROR TALLY NOW WITH WHAT IT
	XOR T1,2(T2)		; WHAT IT WAS THE LAST TIME THROUGH.
	MOVE T3,SYSBLK+UNISCT
	XOR T3,3(T2)
	IOR T1,T3
	JUMPE T1,DOSNS		;J-NO NEW ERRORS WERE RECORDED.
UNICOM: MOVE T1,CURTIM		;ERRORS, WRITE ERROR RECORD.
	HRL T1,CURDAT
	MOVEM T1,(PTR)
	MOVSI T1,-1
	MOVEM T1,1(PTR)
	HRROI T1,4		;GET TRU FOR JOB
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,2(PTR)
	MOVE T1,SYSBLK+UNINAM
	MOVEM T1,3(PTR)
	MOVEM T1,1(T2)		;IN CASE THIS IS A NEW UNIT.
	MOVE T1,SYSBLK+UNILOG
	MOVEM T1,4(PTR)
	MOVE T1,SYSBLK+UNIHCT
	MOVEM T1,5(PTR)
	MOVEM T1,2(T2)		;SAVE ERRORS.
	MOVE T1,SYSBLK+UNISCT
	MOVEM T1,6(PTR)
	MOVEM T1,3(T2)
	LDB T1,UNYKTP		;CONTROLLER TYPE.
	CAILE T1,MCT		;DO WE KNOW ABOUT IT?
	 MOVEI T1,MCT		;NO, CALL IT THIS ONE.
	CALL @[EXP ERRBP,ERRBP,ERRBP,ERRBP,ERRBP,ERRRM](T1)
	PUSH P,T2		;SAVE AROUND NXTREC.
	CALL NXTREC		;ADVANCE RECORD BUFFER POINTER.
	POP P,T2
	SKIPE USEFIL
	 RET
	LDB T1,UNYKTP
	CAIE T1,TYPBP		;3330S?
	 JRST NXTUNI		;NO, SO NO SENSE DATA.
	JRST DOSNS
;Two records are written to report Rm03 errors:
; #1 (type 0):
;   0: tad, 1: -1,,0 2: tru count of CHKPNT 3: UNINAM 4: UNILOG
;   5: UNIHCT 6: UNISCT 7-17: UNISBH.
; #2 (type 1):
;   0: ? 1: -1,,100 2: ? 3: UNIHBN 4: UNISBN 5: UNIECT 6-16: UNISBS.
ERRRM:	MOVSI T1,SYSBLK+UNISBH	;RM03 HARD ERROR DATA.
	HRRI T1,7(PTR)
	BLT T1,17(PTR)
	PUSH P,T2
	MOVSI T1,400000
	LDB T2,UNYUTP		;UNIT TYPE
	SKIPE T2
	 IORM T1,7(PTR) 	;FLAG RP06
	CALL NXTREC		;ADVANCE RECORD BUFFER POINTER
	POP P,T2
	MOVE T1,CURTIM
	HRL T1,CURDAT
	MOVEM T1,0(PTR)
	HRROI T1,100		;SECOND ERROR RECORD, TYPE (-1,,100)
	MOVEM T1,1(PTR)
	MOVSI T1,SYSBLK+UNISHS	;RM03 SOFT ERROR DATA.
	HRRI T1,6(PTR)
	BLT T1,16(PTR)
	MOVE T1,SYSBLK+UNIHBN
	MOVEM T1,3(PTR)
	MOVE T1,SYSBLK+UNISBN
	MOVEM T1,4(PTR)
	MOVE T1,SYSBLK+UNIECT
	MOVEM T1,5(PTR)
	RET
ERRBP:	MOVE T1,SYSBLK+UNIERR	;3330 ERROR DATA.
	MOVEM T1,7(PTR)
	MOVE T1,SYSBLK+UNISOF
	MOVEM T1,10(PTR)
	MOVE T1,SYSBLK+UNIHBN
	MOVEM T1,11(PTR)
	MOVE T1,SYSBLK+UNISDI
	MOVEM T1,12(PTR)
	MOVE T1,SYSBLK+UNIHDI
	MOVEM T1,13(PTR)
	MOVE T1,SYSBLK+UNIECT
	MOVEM T1,14(PTR)
	MOVE T1,SYSBLK+UNISBN
	MOVEM T1,15(PTR)	;SOFT ERROR BLOCK NUMBER
	RET

DOSNS:	MOVE T1,SYSNAM+1	;CHECK TO SEE IF SENSE BYTES
	CAIGE T1,UNISNC 	;IS THERE A SENSE COUNT?
	 JRST NXTUNI		;NO, NOTHING TO DO.
	JUMPN T2,DOSNS1 	;WAS THIS UNIT FOUND ALREADY?
	SKIPN SYSBLK+UNISNC	;HAS A SENSE BEEN DONE?
	 JRST NXTUNI		;NO, FORGET IT.
	MOVE T1,SYSNAM		;GET UNIT DESCRIPTOR IN T2.
	CALL FNDUNI
	 MOVEM T1,1(T2)
DOSNS1: MOVE T1,SYSBLK+UNISNC
CAMN T1,4(T2)		;SEE IF CHANGED SINCE UNIT DATA STORED.
	 JRST NXTUNI
	MOVEM T1,4(T2)		;RESET IN CORE.
	MOVE T1,CURTIM
	HRL T1,CURDAT
	MOVEM T1,(PTR)
	HRROI T1,4		;ERROR CODE TYPE 4
	MOVEM T1,1(PTR)
	HRROI T1,4
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,2(PTR) 	;ALL THIS SETS BASIC INFORMATION
	MOVE T1,SYSBLK+UNINAM
	MOVEM T1,3(PTR)
	MOVEI T1,4(PTR)
	HRLI T1,SYSBLK+UNISNS	;GET READY FOR SENSE DATA
	BLT T1,11(PTR)
	CALL NXTREC		;ADVANCE RECORD BUFFER POINTER.
	SOS SNSCNT		;DECREMENT COUNT OF SENSE REMAINING IF LAST
	SKIPE USEFIL
	 POPJ P,
	JRST NXTUNI

;RETURN NEW 5 WORD UNIT DESCRIPTOR ADDRESS IN T2, CONSED ONTO FRONT OF
; CHAIN OF UNITS.  THE CHAIN IS SINGLY LINKED THROUGH THE RIGHT HALF OF
; THE FIRST WORD IN THE DESCRIPTOR.
NEWUNI: MOVE T2,JOBFF
	ADDI T2,5
	CAMG T2,JOBREL
	 JRST UNCROK
	IORI T2,1777
	CORE T2,
	 JRST CORER
UNCROK: MOVEI T2,5
	EXCH T2,JOBFF
	ADDM T2,JOBFF
	MOVE T3,UNILST
	MOVEM T3,(T2)
	HRRZM T2,UNILST
	SETZM 1(T2)		;JUST TO MAKE SURE.
	SETZM 2(T2)
	SETZM 3(T2)
	SETZM 4(T2)
	POPJ P,
;STORAGE FOR UDB READ USING SYSDVF.
LOC:	2
SYSNAM: 0
	0
SYSBLK: BLOCK 115
;FIND A UNIT IN THE UNIT DESCRIPTOR LIST. THE NAME OF THE UNIT IS IN T1.
;RETURN POINTER TO 5 WORD BLOCK IN T2
;SKIP RETURN IF OLD, NON-SKIP WITH NEW BLOCK CREATED IF NEW.
FNDUNI: MOVEI T2,UNILST
SRCUNI: HRRZ T2,(T2)
	JUMPE T2,NEWUNI 	;END OF LIST
	CAME T1,1(T2)		;CHECK NAME
	 JRST SRCUNI		;NOT THE SAME
	JRST CPOPJ1
DOMTA: MOVEI T4,0	;THIS IS THE LINKED GETTAB POINTER
MTASRC: MOVEI T1,LNKTAB
	HRL T1,T4
	GETTAB T1,
	 JRST DOFTA	;MUST BE OUT OF GETTABS
	CAMN T1,[SIXBIT /MTANAM/]
	JRST GOTMTA
	ADDI T4,2
	JRST MTASRC	;CONTINUE SEARCHING
GOTMTA: MOVEI T1,LNKTAB
	HRLI T1,17(T4)	;CHECK FOR ERRORS
	GETTAB T1,
	 JRST DOFTA	;SOMETHING WRONG
	JUMPE T1,MTANXT ;NO ERRORS
	MOVEI T1,LNKTAB
	HRLI T1,1(T4)
	GETTAB T1,	;GET THE UNIT NAME
	 JRST DOFTA
	CALL FNDUNI
	 JRST NEWMTA	;THIS IS A NEW UNIT
	MOVEI T1,LNKTAB
	HRLI T1,17(T4)
	GETTAB T1,
	 JRST DOFTA
	CAME T1,2(T2)	;HAS ERROR COUNT CHANGED?
	JRST NEWMTA	;YES, PUT OUT A RECORD
MTANXT: ADDI T4,32
	JRST MTASRC	;SKIP THIS MTA BLOCK
NEWMTA: MOVE T1,CURTIM
	HRL T1,CURDAT
	MOVEM T1,(PTR)
	HRROI T1,1
	MOVEM T1,1(PTR)
	MOVEI T1,LNKTAB
	HRLI T1,1(T4)
	GETTAB T1,
	 JRST DOFTA
	MOVEM T1,3(PTR)
	MOVEM T1,1(T2)	;IN CASE NEW UNIT
	MOVEI T1,LNKTAB
	HRLI T1,17(T4)
	GETTAB T1,
	 JRST DOFTA
	MOVEM T1,4(PTR)
	MOVEM T1,2(T2)	;IN CASE NEW UNIT
	DEFINE INFO (FROM,TO)
<	MOVEI T1,LNKTAB
	HRLI T1,FROM(T4)
	GETTAB T1,
	 JRST DOFTA
	MOVEM T1,TO(PTR)>
	INFO (15,5)
	INFO (21,6)
	INFO (23,7)
	INFO (25,10)
	INFO (27,11)
	INFO (31,12)
	CALL	NXTREC	;WRITE THE RECORD
	SKIPE USEFIL
	POPJ P,
	JRST MTANXT
;GENERATE A RESTART RECORD
RSTREC: MSTIME T1,
	IDIVI T1,^D1000
	MOVEM T1,(PTR)
	DATE T1,
	HRLM T1,(PTR)
	HRROI T1,2
	MOVEM T1,1(PTR)
	JRST NXTREC
DOFTA: SETZM SYSNAM
	MOVEI T1,4
	MOVEM T1,LOC	;SET FOR FTA
FTALP:	MOVE T1,[XWD 73+3,LOC]
	SYSDVF T1,
	 JRST DOTMX		;NOW MAGTAPES ON 2020
	SKIPN T1,SYSNAM
	 JRST DOTMX
	MOVE T2,SYSBLK+FTARCT
	ADD T2,SYSBLK+FTARFL
	ADD T2,SYSBLK+FTAWCT
	ADD T2,SYSBLK+FTAWFL
	ADD T2,SYSBLK+FTAHNC	;HUNG COUNT
	JUMPE T2,FTALP	;NO ERRORS
	PUSH P,T2
	CALL	FNDUNI
	 JRST NEWFTA	;THIS IS A NEW FTA
	POP P,T3		;GET BACK ERROR COUNT
	CAMN T3,2(T2)	;NUMBER OF ERRORS CHANGED?
	JRST FTALP	;NO, DO NOT RECORD
	SKIPA
NEWFTA: POP P,T3
	MOVE T1,SYSBLK+FTARCT
	MOVEM T1,4(PTR)
	MOVE T1,SYSBLK+FTARFL
	MOVEM T1,5(PTR)
	MOVE T1,SYSBLK+FTAWCT
	MOVEM T1,6(PTR)
	MOVE T1,SYSBLK++FTAWFL
	MOVEM T1,7(PTR)
	MOVE T1,SYSBLK+FTASCI
	MOVEM T1,10(PTR)
	MOVE T1,SYSBLK+FTAHCI
	MOVEM T1,11(PTR)
	MOVE T1,SYSBLK+FTAHNC
	MOVEM T1,12(PTR)
	MOVE T1,SYSBLK+FTAHFN	;HUNG FUNCTION
	MOVEM T1,13(PTR)
	MOVE T1,SYSBLK+FTACIH	;CONI ON HUNG
	MOVEM T1,14(PTR)
	CALL	NXTREC	;DUMP THAT RECORD
	SKIPE USEFIL
	POPJ P,
	MOVE T1,CURTIM
	HRL T1,CURDAT
	MOVEM T1,(PTR)
	HRROI T1,5	;SENSE FOR FTA
	MOVEM T1,1(PTR)
	HRROI T1,4
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,2(PTR)
	MOVE T1,SYSBLK+FTANAM
	MOVEM T1,3(PTR)
	MOVEI T1,4(PTR)
	HRLI T1,SYSBLK+FTASNS	;SENSE BYTES
	BLT T1,11(PTR)
	CALL	NXTREC	;DUMP RECORD
	SKIPE USEFIL
	POPJ P,
	JRST FTALP	;AND CONTINUE
FTARCT==7	;RECOVERABLE READ ERRORS
FTARFL==11	;NON-RECOVERABLE READ ERRORS
FTAWCT==10	;RECOVERABLE WRITE ERRORS
FTAWFL==12	;NON-RECOVERABLE WRITE ERRORS
FTAHNC==3	;NUMBER OF TIMES HUNG
FTANAM==-2	;THIS WILL FORCE USE OF SYSNAM
FTASCI==5	;CONI ON LAST SOFT (RECOVERABLE) ERROR
FTAHCI==6	;CONI ON LAST HARD (NON-RECOVERBLE) ERROR
FTAHFN==2	;FUNCTION WHEN LAST HUNG
FTACIH==4	;CONI ON LAST HANG
FTASNS==14	;FIRST WORD OF 6 WORDS OF SENSE BYTES FOR LAST ERROR
;HERE TO LOG ERRORS ON 2020 MAGTAPES (TU45A, TM02 CONTROLLER)
DOTMX:	SETZM SYSNAM
	MOVEI T1,5
	MOVEM T1,LOC	;SET FOR TMX
TMXLP:	MOVE T1,[XWD 24+3,LOC]
	SYSDVF T1,
	 JRST DOPAR	;NOW PARITY ERRORS.
	SKIPN T1,SYSNAM
	 JRST DOPAR
	MOVE T2,SYSBLK+TMXEC
	ADD T2,SYSBLK+TMXHC	;HUNG COUNT
	JUMPE T2,TMXLP	;NO ERRORS
	PUSH P,T2
	CALL	FNDUNI
	 JRST NEWTMX	;THIS IS A NEW TMX
	POP P,T3		;GET BACK ERROR COUNT
	CAMN T3,2(T2)	;NUMBER OF ERRORS CHANGED?
	JRST TMXLP	;NO, DO NOT RECORD
	SKIPA
NEWTMX: POP P,T3
	MOVEM T3,2(T2)	;RECORD NUMBER OF ERRORS
	MOVE T1,CURTIM
	HRL T1,CURDAT
	MOVEM T1,(PTR)
	HRROI T1,101	;TMX ERROR CODE
	MOVEM T1,1(PTR)
	HRROI T1,4
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,2(PTR)
	MOVE T1,SYSBLK+TMXNAM
	MOVEM T1,3(PTR)
	MOVEM T1,1(T2)	;IN CASE NEW UNIT
	MOVE T1,SYSBLK+TMXHC
	MOVEM T1,4(PTR)
	MOVE T1,SYSBLK+TMXEC
	MOVEM T1,5(PTR)
	HRRI T1,6(PTR)
	HRLI T1,SYSBLK+TMXSB
	BLT T1,14(PTR)
	CALL NXTREC
	SKIPE USEFIL
	POPJ P,
	JRST TMXLP
TMXHC==4
TMXEC==14
TMXSB==15
TMXNAM==-2
PARTBL==12	;PARITY ERRORS DATA HERE
PARSPR==25	;TOTAL NUMBER OF PARITY INTERUPTS
PARTOT==24	;NUMBER OF PARITY ERRORS FOUND IN CORE
PARADR==27	;ADDRESS OF LAST PARITY ERROR
PARWRD==30	;DATA FROM LAST PARITY ERROR
PARPC==31	;PC OF LAST PARITY ERROR
DOPAR:	MOVE T1,[PARSPR,,PARTBL]
	GETTAB T1,
	 MOVEI T1,0
	CAMG T1,LSTPAR	;MORE THAN BEFORE?
	POPJ P, 	;NO, DO NOT RECORD
	MOVEM T1,2(PTR)
	MOVEM T1,LSTPAR ;SAVE AND GENERATE RECORD
	MOVE T1,[PARTOT,,PARTBL]
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,3(PTR)
	MOVE T1,[PARADR,,PARTBL]
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,4(PTR)
	MOVE T1,[PARWRD,,PARTBL]
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,5(PTR)
	MOVE T1,[PARPC,,PARTBL]
	GETTAB T1,
	 MOVEI T1,0
	MOVEM T1,6(PTR)
	HRROI T1,6
	MOVEM T1,1(PTR)
	MOVE T1,CURTIM
	HRL T1,CURDAT
	MOVEM T1,(PTR)
	JRST NXTREC	;GOT THE PARITY RECORD
;SIZJOB EXPECTS T1/ 0,,JOB #
SIZJOB: HRLZ T3,T1
	GETTAB T3,	;GET JBTSTS(J)
	 JRST GETER
	TLNN T3,JNA
	POPJ P, 	;NO JOB YET
	AOS 4(PTR)
	MOVE T3,T1
	CALL	SIZE	;RETURN T4/ SIZE IN K
	HRL T3,T1
	HRRI T3,14
	GETTAB T3,
	JRST NOSEG	;IFNORE ERR FOR VM/NON-VM SYS COMPATIBILITY
	JUMPLE T3,NOSEG ;NO HIGH SEG
	HRRZS T3
	PUSH P,T4
	CALL	SIZE	;SIZE OF HIGH SEG
	POP P,T3
	ADD T4,T3
NOSEG:	ADDM T4,5(PTR)	;TOTAL SIZE
	MOVEM T4,(T2)	;SAVE IN LIST
	ADDI T2,1
	CAILE T4,^D56
	MOVEI T4,^D56
	IDIVI T4,10
	ADDI T4,10(PTR)
	AOS (T4)
	POPJ P,
;SIZE EXPECTS T3/JOB #;  RETURNS T4/SIZE IN K
SIZE:	HRL T4,T3
	HRRI T4,1
	GETTAB T4,	;ALWAYS RETURNS 0 SINCE P032/C
	 JRST GETER
	JUMPE T4,SWAP
	HLRZS T4
	ADDI T4,1777
	LSH T4,-^D10
	POPJ P,
SWAP:	HRL T4,T3
	HRRI T4,7
	GETTAB T4,	;SIMULATED IN VM SYS FROM COUNT OF EXISTENT PAGES
	 JRST GETER
	LDB T4,[POINT SWPSIZ,T4,SWPPOS]
	LSH T4,-1	;CONVERT PAGES TO K
	POPJ P,
;-CHECK:  WRITE A CHECKPOINT RECORD TO STREAM FOR ALL JOBS
;	ALIVE IN SYSTEM.
CHECK:	MOVE T5,JOBPTR	;THIS WAS SET AT INITIALIZATION
	AOBJP T5,CHKEND ;DONE IF OUT OF JOBS
CHKLP:	HRL T1,T5
	HRRI T1,STSTAB	;GET STATUS
	GETTAB T1,
	 JRST CHKNXT	;TRY NEXT IF CAN NOT GET IT
	TLNE T1,JLOG	;IF NOT LOGGED IN
	TLNN T1,JNA	;OR JOB NUMBER NOT ASSIGNED
	JRST CHKNXT	;SKIP THIS ONE
CHKCOK: MOVSI T2,-GTBLEN
;FOLLOWING LOOP INDEX T2 THRU GTAB. T3:=CURR JOB,,GETTAB ITEM;
;(T5=JOBPTR=AOBJN INITIAL -NUMBER JOBS,,0),
;T3:=GETTAB DATA, OR [T3,T4] :=DOUBLE PRECISION GETTAB DATA,
;T1:=INDEX IN LH GTAB(T2) FOR PLACEMENT IN CKPREC
GTBLOP: HRRZ T3,GTAB(T2)
	HRL T3,T5	;T3:=JOB,,GETTAB ITEM
	GETTAB T3,
	 SETZB T3,T3+1	;DEFAULT ZERO. (T3+1 INCASE D.P.)
	HLRZ T1,GTAB(T2)
	TRZE T1,(1B0)	;TEST & RESET D.P. FLAG
	MOVEM T3+1, CKPREC+1(T1);DEPOSIT LOW ORDER VALUE
	MOVEM T3,CKPREC(T1)
	AOBJN T2,GTBLOP
	MOVE T3,CKPHED	;-HEADER WORD FOR CHKPNT REC
	MOVEM T3,CKPREC
	DPB T5,[POINT 9,CKPREC,17]	;JOB NO. IN HEADER
;-MONITOR DUPPLIES TIME STAMP.
	SETOM CKPFLG	;FLAG WORD 5 THIS IS CKPNT REC
	HRLOI T2,77
	ANDM T2,CKPRCT
	ANDM T2,CKPWCT	;MASK BLOCK WRITTEN & READ
	HRL T2,T5
	HRRI T2,JOBLIN	;GET TTY LINE NAME
	GETTAB T2,
	SKIPA		;FAIL
	TLNN T2,-1
	JRST [SETZ T3,
		JRST LINFIN]
	HRRZS T2
	MOVEI T3,0
	LDB T4,[POINT 6,T2,23]
	JUMPE T4,LINFIN
	MOVEI T3,-'0'(T4)
	LDB T4,[POINT 6,T2,29]
	JUMPE T4,LINFIN
	IMULI T3,10
	ADDI T3,-'0'(T4)
	LDB T4,[POINT 6,T2,35]
	JUMPE T4,LINFIN
	IMULI T3,10
	ADDI T3,-'0'(T4)
LINFIN: HRLS T3
	HRRI T3,LOGTAB
	GETTAB T3,
	 MOVEI T3,0
LINFN1: MOVEM T3,CKPLOG
	LDB T3,[POINT 4,T3,11]	;GET TTY TYPE
	DPB T3,[POINT 12,CKPREC,29]
;SEND THIS CHKPNT RECORD TO STREAM, ON TO NEXT JOB, IF ANY
	MOVEI T4,CKPREC
	PUTSAR T4,	;(USE T4 FOR BADPUT)
	CALL BADPUT
CHKNXT: AOBJN T5,CHKLP	;NEXT JOB, IF ANY
CHKEND: POPJ P,
CPOPJ1:	 AOS (P)
CPOPJ:	POPJ P,
;LEFT HALF IS INDEX FOR PLACEMENT INTO CKPREC. RH IS GETTAB ITEM
;	SIGN BIT FLAGS ITEM AS WORD 1 OF DOUBLE PRECISION VALUE
GTAB:	2,,AUNTAB
	400003,,TRUGET	;HI ORDER TRU
	;4 IS LOW ORDER TRU
	;5 IS -1 FLAG THISS REC FROM CHKPNT
	400006,,KCTGET
	;7 IS LOW ORDER KILO CORE TICKS
	10,,DLKTAB	;LOOKUPS
	11,,SLKTAB	;LOOKUPS*SIZE
	12,,SERTAB	;ENTER+RENAMES*SIZE
	13,,SINTAB	;BLOCKS READ * SIZE
	14,,SOTTAB	; BLOCKS WR  * SIZE
	15,,CINTAB	;CHARS IN
	16,,COTTAB	;CHARS OUT
	17,,ELPTAB	;SECONDS ELAPSED * SIZE
	20,,CNKTAB	;SECONDS CONNECT NO DETACH
	21,,BCSTAB	;BR CHARS*SIZE
	22,,RCTTAB	;BLOCKS READ
	23,,WCTTAB	;	WRITTEN
	24,,LOGTAB	;SUPERV LOGIN INFO
	25,,ENTTAB	;USETI USETO'S
	26,,RMSTAB	;REM PERIPH TIME
	27,,RMCTAB	;REM PERIPH CHARS
	30,,SOKTAB	;PREM CHARG CELL
	31,,JBTBET	;SECONDS ELAPSED BLOCK PORT IO
	32,,JBTBIO	;BLOCK PORT CHARS
	400033,,MCYGET	;MICRO CYCLES
	;34 IS LOW MICRO CYCLES
	35,,JBTMPC	;MAPPED PG COUNT
	36,,JBTPWS	;PGS TO WORKING SET
	400037,,JBTPWH	;HI ORDER PWS*SIZE
	;40 IS LOW ORDER PWS*SIZE
GTBLEN==.-GTAB
;DEFINITIONS OF CHKPNT STREAM RECORD HEAADER,DATA LOCATIONS
CKPLNG==GTBLEN+^D7	;-CHKPNT REC LENGTH=
; TABLE LENGTH GTBLEN
;+HEADER WORD
;+DATE WORD (1)
;+LOW TRU (4)
;+FLAG (5)
;+LOW KCT (7)
;+LOW MICRO CYCLES (34)
;+LOW PWS*SIZE (40)
CKPHED: BYTE (9)CKPTYP,0(18)CKPLNG	;HEADER
CKPREC: BLOCK CKPLNG
CKPFLG==CKPREC+5
CKPRCT==CKPREC+22
CKPWCT==CKPREC+23	;BLOCKS READ,WRITTEN
CKPLOG==CKPREC+24	;SUPERVISOR LOGIN INFO
END STPT
  ~ ð