TITLE	TMPUUO -- TEMPORARY FILE STORAGE M - V001
SUBTTL	TONY LAUCK  25 APR 69

	STOPCD(,ENTRY,TMPUUO)

REPEAT 0,<

		TEMPORARY FILE STORAGE FOR JOB UUO.

   THE "TMPCOR" M IS USED TO ENABLE A JOB TO LEAVE SEVERAL SHORT
FILES IN CORE FROM THE RUNNING OF ONE USER PROGRAM OR CUSP TO THE
NEXT. THESE FILES MAY BE REFERRED TO BY A THREE CHARACTER FILE NAME,
AND ARE UNIQUE TO EACH JOB, I.E. A JOB CAN ONLY REFERENCE ITS OWN
FILES. ALL FILES ARE ALWAYS DELETED WHEN A JOB IS KILLED.

   EACH FILE APPEARS TO THE USER AS ONE DUMP MODE BUFFER. THE ACTUAL SIZE OF A
TEMPORARY FILE, THE NUMBER OF TEMPORARY FILES A USER CAN HAVE,
AND THE TOTAL CORE SPACE A USER CAN TIE UP ARE PARAMETERS DETER-
MINED AT MONGEN TIME. ALL TEMPARARY FILES RESIDE IN A FIXED AREA
IN THE MONITOR, BUT THE SPACE IS DYNAMICALLY ALLOCATED AMOUNG
DIFFERENT JOBS AND THE SEVERAL DIFFERENT FILES OF ANY GIVEN JOB.

   THE PRIMARY PURPOSE OF THE TEMPORARY STORAGE SYSTEM IS FOR SHORT
CONTROL FILES, E.G. CCL FILES, TO LIVE IN CORE, THEREBY SPEEDING
UP RESPONSE TIMES AND REDUCING DISK OPERATIONS. ACCORDINGLY,
SHOULD A PROGRAM ATTEMPT TO WRITE A FILE WHEN THERE IS
INSUFFICIENT SPACE, EITHER IN THE ENTIRE BUFFER AREA OR BECAUSE
THE USER HAS EXCEEDED HIS QUOTA, THE M GIVES AN ERROR RETURN.
THE CUSP CAN THEN WRITE THE DATA AS A SHORT DISK FILE.
SIMILARLY, SHOULD A PROGRAM FAIL TO FIND A FILE UPON READING IT,
IT WILL GET AN ERROR RETURN AND CAN THEN LOOKUP A SHORT DISK FILE.

   IT IS VERY IMPORTANT TO REALIZE THE TEMPORARY NATURE OF THESE
FILES. FOR EXAMPLE, UPON WRITING, THE OLD FILE IS DELETED BEFORE
CHECKING FOR SPACE FOR A NEW VERSION. THE OLD FILE COULD BE LOST WITHOUT
A NEW ONE REPLACING IT. ALSO, THERE CAN BE NO GUARANTEE THAT FILES
WILL FIT IN CORE.

   THE TMPCOR M IS NOT INTENDED TO REPLACE A FUTURE, MORE
GENERAL, DEVICE INDEPENDENT SERVICE ROUTINE FOR "CORE". HOWEVER,
THE SPACE TAKEN UP BY DEVICE DATA BLOCKS, ETC., IN THAT MORE
GENERAL ROUTINE WOULD REPRESENT UNNECESSARY OVERHEAD FOR EXTREMELY
SHORT DATA, SUCH AS CCL COMMAND FILES.
>
	REPEAT 0,<
	FORMAT OF TEMPORARY FILE STORAGE UUO.

	CALL AC, [SIXBIT /TMPCOR/]	;CALLI INDEX=44
	;ERROR RETURN
	;NORMAL RETURN

   C(AC) MUST ALWAYS BE SET UP BY THE USER PROGRAM PRIOR TO EXECUTING
THE UUO. IT IS CHANGED BY THE M AND RETURNS A VALUE THAT DEPENDS
ON THE PARTICULAR FUNCTION PERFORMED.

	C(AC) = XWD CODE,BLOCK

BLOCK:	XWD	NAME,0		;NAME IS FILE NAME
	IOWD	BUFLEN,BUFFER	;USER BUFFER AREA (ZERO  FOR NO BUFFER)
>
	REPEAT 0,<
		CODE-0	--  GET FREE SPACE

   THE IS THE ONLY FORM OF THE TEMP M THAT DOES NOT USE A TWO
WORD PARAMETER BLOCK. C(AC) WOULD ORDINARLY BE SET TO ZERO FOR THE
GET FREE SPACE UUO. THE USER PROGRAM ALWAYS GETS A NORMAL RETURN
(UNLESS THE SYSTEM DOES NOT HAVE THE TEMP M). C(AC) IS SET TO
THE NUMBER OF WORDS OF FREE SPACE AVAILABLE TO THE USER.

		CODE=1	--  READ FILE

   IF THE SPECIFIED FILE NAME IS NOT FOUND, C(AC) IS SET TO THE
NUMBER OF FREE WORDS OF SPACE AVIALABLE FOR TEMP FILES, AND THE
ERROR RETURN IS TAKEN.

   IF THE FILE IS FOUND, C(AC) IS SET TO THE LENGTH OF THE
FILE IN WORDS, AND AS MUCH OF THE FILE AS WILL FIT IS COPIED INTO
THE USERS BUFFER. THE USER CAN CHECK FOR TRUNCATION BY COMPARING
C(AC) WITH BUFLEN UPON SUCCESSFUL RETURN FROM THE TEMP UUO.

		CODE=2	--  READ AND DELETE FILE

   THIS IS THE SAME AS CODE=1, EXCEPT THAT IF A FILE WAS FOUND
IT IS ALSO DELETED AND ITS SPACE RECLAIMED.
>
	REPEAT 0,<
		CODE=3	--  WRITE FILE

   IF THERE IS ALREADY A FILE OF THE SPECIFIED NAME, IT IS
DELETED AND ITS SPACE IS RECLAIMED.

   THE REQUESTED SIZE OF THE FILE IS SPECIFIED BY BUFLEN.
IF THERE IS NOT ENOUGH SPACE TO WRITE THE ENTIRE FILE, NOTHING
IS WRITTEN, C(AC) IS SET TO THE NUMBER OF FREE WORDS OF SPACE
AVAILABLE TO THE USER, AND THE ERROR RETURN IS TAKEN.

   IF THERE IS ENOUGH SPACE, THE FILE IS WRITTEN. C(AC) IS SET TO
THE AMOUNT OF SPACE LEFT AFTER THE FILE HAS BEEN WRITTEN AND THE
NORMAL RETURN IS TAKEN. FILES ARE ALWAYS FILLED UP WITH ZEROS TO THE
NEXT EVEN MULTIPLE OF THE BLOCK LENGTH (TMPBL).
 THIS EVEN LENGTH IS READ BACK IN.

		CODE=4	--  READ DIRECTORY

   THE ERROR RETURN IS NEVER TAKEN.

   C(AC) IS SET TO THE NUMBER OF DIFFERENT FILES IN THE JOB'S
TEMPORARY FILE AREA. IN ADDITION, AN ENTRY IS MADE FOR EACH FILE
IN THE USER BUFFER AREA UNTIL THERE IS NO MORE SPACE OR ALL FILES HAVE
BEEN LISTED. THE USER PROGRAM CAN CHECK FOR TRUNCATION BY COMPARING
C(AC) UPON RETURN WITH BUFLEN.

   DIRECTORY ENTRY FORMAT
	XWD  NAME,SIZE	;NAME=FILE NAME, SIZE =FILE LENGTH IN WORDS.

		CODE=5	--  READ AND CLEAR DIRECTORY

   THIS IS THE SAME AS CODE=4 EXCEPT THAT ANY FILES IN THE JOB'S
TEMPORARY STORAGE AREA ARE ALSO DELETED AND THEIR SPACE RECLAIMED.

   THIS M IS EXECUTED BY THE LOGOUT CUSP.
>
	REPEAT 0,<
		IMPLEMENTATION

	MASTER DIRECTORY

  THIS IS A TABLE JOBN+1 ENTRIES LONG.

JBTTMP:	XWD FREE,IDLE
JBTTM1: XWD SPACE,LINK
	   .
	   .
	   .

MREE = NO. OF FREE BLOCKS IN MONITOR BUFFER AREA
IDLE  =  LINK TO FIRST FREE BLOCK OR 0 IF NO FREE BLOCKS
SPACE  =  NO OF FREE BLOCKS REMAINING IN JOBS QUOTA
LINK  =  LINK TO FIRST BLOCK OF FIRST FILE OF JOB, 0 IF NONE.

	IDLE BLOCK FORMAT

	XWD 0,LINK
	REPEAT TMPBL, <0
			>

   LINK  = LINK TO NEXT BLOCK ON IDLE CHAIN, 0 IF NO MORE.

	USER BLOCK FORMAT

	XWD NAME,LINK
	BLOCK TMPBL	;USER DATA OR ZERO FILL.

   NAME = USER FILE NAME.
   LINK = LINK TO NEXT BLOCK IN THIS FILE OR NEXT FILE OF THIS USER

   IF A FILE IS SEVERAL BLOCKS LONG, EACH BLOCK HAS THE FILE NAME.
   A LINK OF 0 INDICATES NO MORE DATA IN THE FILE, AND NO MORE FILES
FOR THIS USER.

   THEREFORE, A FILE ENDS WHEN ITS LAST BLOCK HAS A ZERO LINK, OR
WHEN IT LINKS TO A FILE OF DIFFERENT NAME.

	MONITOR BUFFER AND PARAMETERS

TMPBUF:	BLOCK TMPBKS*<TMPBL+1>	;BUFFER AREA FOR ALL FILES.

	TMPBKS IS THE NUMBER OF BLOCKS THE STORAGE AREA IS COMPUTED.
	IT IS COMPUTED BY MACRO DURING THE ASSEMBLY OF COMMON.
	TMPBL IS A PARAMETER IN S.MAC.
>
	REPEAT 0,<
	FACTORS AFFECTING SYSTEM

   1. MONITOR MUST INITALIZE THE TEMP FILES ON RESTART.
	A) CLEAR ENTIRE BUFFER AREA
	B) SET FREE COUNT TO TOTAL NUMBER OF 5 WORD BLOCKS
	C) LINK ALL BLOCKS ON IDLE CHAIN
	D) SET ALL USERS SPACE TO THEIR QUOTA AND LINKS TO 0

   2.  LOGOUT MUST DO A CLEAR OF USERS DIRECTORY

   3. PIP SHOULD CLEAR USERS DIRECTORY ON A DEL *.TMP COMMAND

   4.  PIP SHOULD READ AND WRITE TEMP FILES. DEVICE TMP:?

   5.  ALL CCL CUSPS MUST BE CHANGED TO DO TEMP UUO.
>
	INTERN	TMPINI,TMPTAB
	EXTERN	MJOBN,JBTTMP
	EXTERN	CPOPJ,CPOPJ1,UUOERR

TMPTAB:	0			;FREE DATA SPACE,ADDRESS OF TABLE
	0			;USER QUOTA,NUMBER OF BLOCKS

TMPINI:	HLLZ	T2,TMPTAB+1	;LIMIT OF TEMP FILES PER USER
	MOVSI	T1,MJOBN
	MOVEM	T2,JBTTMP(T1)
	AOBJN	T1,.-1

	MOVE	T1,TMPTAB	;FREE DATA SPACE,ADDRESS OF TABLE
	MOVEM	T1,JBTTMP	;SET UP SPACE, ADDR OF NULL LIST
	HRRZ	T2,TMPTAB+1	;COUNT OF BLOCKS
TMPIN1:	ADDI	T1,TMPBL+1	;LINK ALL BLOCKS TO NULL LIST
	HRRZM	T1,-TMPBL-1(T1)
	SOJG	T2,TMPIN1

	HLLZS	-TMPBL-1(T1)	;DONT LINK LAST BLOCK
	POPJ	P,
;Entry point from UUOCON

TMP.UU::AOS	(P)		;SET FOR GOOD RETURN
	UMOVE	W,(M)	;GET USERS AC
	TLNN	W,-1		;IS CODE = 0?
	JRST	TMPSP		;YES, SO JUST RETURN SPACE LEFT
	EXCH	W,M	;SAVE AC ADR, GET C(AC)
	UMOVE T1,(M)
	HLLZ	S,T1		;SAVE FILE NAME
	HRRI	M,1(M)	;GET SECOND WORD OF BLOCK
	UMOVE T1,(M)
	HLRE	F,T1	;GET USERS BUFFER LENGTH
	MOVNS	F
	HRRZ	T4,T1	;USERS BUFFER ADDRESS
	MOVE	M,W	;GET AC BACK
	XCTBU <HLRZ	W,(M)>	;GET CODE
	CAILE	W,TMPDL	;CHECK IF IT IS LEGAL
	JRST	UUOERR		;NO
	JRST	@TMPDIS-1(W)	;DISPATCH TO APPROPRIATE ROUTINE

TMPDIS:	JRST	TMPREA
	JRST	TMPREA
	JRST	TMPWR
	JRST	TMPDIR
	JRST	TMPDIR

	TMPDL== .-TMPDIS
	;ROUTINE TO READ, OR READ AND DELETE A TEMPORARY FILE

TMPREA:	PUSHJ	P,TMPSRC	;FIND FILE
	JRST	TMPSPB		;NONE, SO RETURN SPACE
	SETZ	T1,		;ZERO USER COUNT
TMPRE1:	HRLI	P1,-TMPBL	;SET COUNT TO NO WORDS IN BLOCK
TMPRE2:	SOSL	F		;COUNT DOWN USER BUFFER SPACE
	XCTTU <PUSH	T4,1(P1)>	;IF SPACE, COPY 1 WORD
	ADDI	T1,1		;ADD TO USER COUNT
	AOBJN	P1,TMPRE2	;GO ON WITH BUFFER IF MORE WORDS
	SUBI	P1,TMPBL	;GET BACK TO START OF BLOCK
	TRNN	W,1		;SHOULD WE DELETE?
	PUSHJ	P,TMPDEL	;DELETE THIS BLOCK
	PUSHJ	P,TMPCHA	;CHAIN TO NEXT BLOCK IN FILE
	JRST	TMPRE1		;FOUND, GO HANDLE IT
TMPFLL:	SOJL	F,[UMOVEM T1,(M)	;FILL REST OF USERS BUFFER
		   POPJ P,	]	;AND RETURN.
	XCTBU <SETZM	1(T4)>	;WITH ZEROS, THEN GIVE HIM COUNT
	AOJA	T4,TMPFLL

	;ROUTINE TO CHAIN TO NEXT BLOCK OF A FILE

TMPCHA:	HRRZ	P1,(P1)	;CHAIN TO NEXT BLOCK
	HLLZ	P3,(P1)	;GET FILE NAME
	CAMN	P3,S		;MATCH?
	JUMPN	P1,CPOPJ	;YES, IS THERE A BLOCK?
	JRST	CPOPJ1		;NO, SKIP RETURN

	;ROUTINE TO FIND A FILE

TMPSRC:	MOVEI	P2,JBTTMP(J) ;GET ADDRESS OF FIRST LINK
TMPSR1:	HRRZ	P1,(P2)	;CHAIN FORWARD
	JUMPE	P1,CPOPJ	;NONE, FILE NOT FOUND
	HLLZ	T2,(P1)	;GET FILE NAME
	CAMN	T2,S	;MATCH?
	JRST	CPOPJ1		;YES, SKIP RETURN
	HRRZ	P2,P1		;SAVE OLD POINTER
	JRST	TMPSR1		;AND KEEP ON LOOKING

	;ROUTINE TO DELETE A BLOCK

TMPDEL:	HRRZ	P3,(P1)	;LINK AROUND BLOCK
	HRRM	P3,(P2)
	HRRZ	P3,JBTTMP	;LINK OLD BLOCK TO IDLE
	MOVEM	P3,(P1)
	HRRM	P1,JBTTMP	;LINK START OF IDLE CHAIN TO BLOCK
	HRRZ	P1,P2		;RESTORE P1 FOR TMPCHA
	MOVSI	P3,TMPBL	;UPDATE FREE COUNTERS
	ADDM	P3,JBTTMP
	ADDM	P3,JBTTMP(J)
	POPJ	P,
	;ROUTINE TO WRITE A FILE FOR USER

TMPWR:	PUSHJ	P,TMPSRC	;SEE IF THERE WAS AN OLD FILE
	JRST	TMPWR2		;NO
TMPWR1:	PUSHJ	P,TMPDEL	;DELETE A BLOCK
	PUSHJ	P,TMPCHA	;CHAIN TO NEXT BLOCK
	JRST	TMPWR1		;THERE WAS ONE, GO ON

TMPWR2:	PUSHJ	P,TMPSPC	;GET SPACE FOR USER
	SKIPE	T1
	CAMLE	F,T1	;DOES HE WANT MORE?
	JRST	TMPSPB		;YES, SO TELL HIM HE LOST

	HRRZ	P3,JBTTMP(J) ;SAVE LINK TO FIRST FILE
	MOVEI	P2,JBTTMP(J) ;SET OLD BLOCK ADDRESS

TMPWR3:	HRRZ	P1,JBTTMP	;GET ADDRESS OF FIRST IDLE BLOCK
	HRRZ	T2,(P1)	;GET ITS SUCCESSOR
	HRRM	T2,JBTTMP	;LINK THAT BLOCK TO IDLE CHAIN
	HRRM	P1,(P2)	;LINK LAST BLOCK OF USER TO NEW BLOCK
	HRRZ	P2,P1		;SAVE OLD BLOCK ADDRESS
	MOVSI	T2,-TMPBL	;DECREASE JOB AND TOTAL SPACE
	ADDM	T2,JBTTMP
	ADDM	T2,JBTTMP(J)

	HLLM	S,(P1)	;INSERT FILE NAME
	HRLI	T4,-TMPBL	;SET FOR NO WORDS/BLOCK
TMPWR4:	SOJL	F,TMPWR6	;DOES HE WANT TO WRITE MORE?
	XCTFU <PUSH	P1,1(T4)> ;YES, SO STICK IN HIS WORD
TMPWR5:	AOBJN	T4,TMPWR4	;UPDATE USER ADDR, IS BLOCK DONE?
	JUMPG	F,TMPWR3	;YES, DOES HE HAVE MORE?

	HRRM	P3,-TMPBL(P1)	;NO, LINK LAST BLOCK TO HIS FILES
	JRST	TMPSP		;GET SPACE AND RETURN

TMPWR6:	SETZM	1(P1)		;FILL FINAL BLOCK WITH ZERO
	AOJA	P1,TMPWR5	;AND GO ON UNTIL BLOCK DONE

	;ROUTINE TO COMPUTE SPACE FOR USERS TMP FILES

TMPSPC:	HLRZ	T1,JBTTMP	;TOTAL FREE SPACE
	HLRZ	T2,JBTTMP(J) ;USER LIMIT
	CAMLE	T1,T2	;SPACE IS MINIMUM OF THE TWO
	MOVE	T1,T2
	POPJ	P,

	;ROUTINE TO GET SPACE AND RETURN TO USER (SKIP AND NO SKIP)

TMPSPB:	SOS	(P)		;NO SKIP RETURN
TMPSP:	PUSHJ	P,TMPSPC	;GET SPACE
UMOVEM T1,(M)		;RETURN ARGUMENT TO USER SPACE.
	POPJ P,			;AND RETURN.
	;READ DIRECTORY, READ AND CLEAR DIRECTORY

TMPDIR:	SETZ	T1,		;ZERO COUNT OF FILES
	MOVEI	P2,JBTTMP(J) ;SET LINK TO DELETE
	HRRZ	P1,(P2)	;LINK TO FIRST BLOCK
TMPDI1:	JUMPE	P1,TMPFLL	;IF NONE, ZERO REST OF USERS BUFFER
	HLLZ	S,(P1)	;GET FILE NAME
	MOVEI	T2,1		;SET LENGTH TO 1
TMPDI2:	TRNE	W,1		;DELETE?
	PUSHJ	P,TMPDEL	;YES, DELETE BLOCK
	PUSHJ	P,TMPCHA	;GET NEXT BLOCK OF FILE
	AOJA	T2,TMPDI2	;THERE IS ONE, SO COUNT BLOCKS
	IMULI	T2,TMPBL	;GET LENGTH IN WORDS
	HLL	T2,S	;DONE, GET LENGTH, NAME OF OLD ONE
	SOSL	F		;IS THERE SPACE LEFT IN USER AREA?
	XCTTU <PUSH	T4,T2>	;YES, STOW ENTRY
	AOJA	T1,TMPDI1	;COUNT FILES, GO ON FOR NEXT ONE

	$END	(TMP)		;End of TMPUUO (TMPLIT: TMPEND:)
     