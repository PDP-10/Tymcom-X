TITLE FTASER -- CODE FOR SA-10 -- IBM 3803/3420 TAPES ON THE PDP-10.
SUBTTL

	STOPCD(,ENTRY,FTASER)

IFNCPU(<KI,KL>),<PRINTX FTASER works on KI and KL only>

COMMENT %@@MODULE FTASER
@@PURPOSE DEVICE DEPENDENT CODE FOR THE IBM 3803/3420 FTAS ON
THE PDP-10.

@@ENTRY ALL OF THE ROUTINES IN THIS MODULE EXPECT P TO BE
A PDL AC.

@@TABLES ALMOST ALL OF THE ROUTINES IN THIS MODULE USE
THE DDB AND UNIT DB.

@@FUNCTION THE DETAILED COMMAND CODES, ERROR BIT DEFINITIONS,
ETC. CAN BE FOUND IN THE FIRST SEVERAL PAGES OF THE FTASER
SOURCE LISTING.

@@RESTRICTIONS THE COMMENTS UNDER THE RESTRICTIONS HEADINGS
FOR EACH SUBR IN THIS MODULE TO THE EFFECT THAT THE SUBR
IS CALLED AT A GIVEN LEVEL MEANS THAT THAT IS THE LEVEL THAT
IT IS PRESENTLY CALLED AT,  NOT THAT THAT IS THE ONLY
LEVEL THAT IT COULD BE CALLED AT.  THIS HAS BEEN DONE BECAUSE
IT WILL AID IN UNDERSTANDING THE FUNCTION OF THE SUBRS
AND BECAUSE IN MANY CASES BECAUSE OF A ROUTINE'S FUNCTION IT
WOULD BE NONSENSICAL TO CONSIDER CALLING IT AT A DIFFERENT
LEVEL. @@%


;EXTERNALS:

    ;IN CHANNEL DB.
	EXTERN CHNSTB,CHNGO,CHNCLR,CHNBMX,CHNIIE,CHNACT,CHNMER

    ;IN KONTROLLER DB.
	EXTERN KONBMX,KONBSU,KONPTR
	EXTERN FTXMCH,FTXSNS,FTXSTS,FTXSS1,FTXSS2
	EXTERN FTXSMY,FTXSM0,FTXBSY,FTXSPR,FTXSP1,FTXSX1
	EXTERN FTCMLN

    ;IN UNIT DB.
	EXTERN FTA0CB,FTADDS,FTA0DB,FTULNH

	EXTERN DEVUDB,DEVCNT,DEVFNJ,DEVADD,DEVDWC,DEVACT
	EXTERN DEVER1,DEVER2,DEVNOI,DEVOUT,DEVINS,DEV40,DEVDIO

	EXTERN UNIDDB,UNILNK,UNIKNT,UNIERO,UNICMD,UNIDON,UNITYP
	EXTERN UNIDCR,UNIDCN,UNIDC1,UNISX1,UNISX2,UNISX3
	EXTERN FDHFUN,FDHCNT,FDHCNI,FDNRE1,FDNWR1,FDMEMR
	EXTERN FDNREE,FDNWRE,FDERBT,FDCNI1,FDCNIE,FDSENS,FDSCHR

    ;OTHER.
	EXTERN SETHNG,PIOMOD,CPOPJ,CPOPJ1,WAIT1,OUT,SETIOD
	EXTERN HNGSTP,JBTIOA,PJOBN,SYDNM4,SYDCOM,JBTLIC,PWAIT1
	EXTERN DSKPIF,DSKPIN,PAGWAK,PGYDIO


;INTERNALS:

    INTERN FTXINT,FTADSP,SYDFTA

;FORMAT OF SA-10 WORDS:

;    UNIT COMMAND LIST WORDS:

;        DEVICE COMMAND WORDS:

;            BITS	MEAN
;            0		1=NO MEMORY TRANSFER, 0=MEM TRANS.
;     	     1&4	00-WORD MODE
;            		01-BYTE MODE
;            		10-NATURAL MODE
;            		11-TAPE COMPATABILITY MODE
;            2		1=EXECUTE,0=HALT
;            3		CHAIN TO NEXT COMMAND
;            5		PROGRAM INTERRUPT
;            6		1=IGNORE LENGTH ERR,0=DON'T IGNORE
;            8-15	DEVICE COMMAND
;            16-23	DEVICE ADDRESS

;        DATA WORDS:

;            BITS	MEAN
;            0		1=THIS IS THE LAST DATA WORD IN THIS
;	    		GROUP, 0=NOT LAST.
;            1-11	2'S COMPLEMENT OF WORD/BYTE COUNT
;            14-35	1ST MEM ADDR, UNLESS 0 & WE ARE READING
;			FROM THE DEVICE, IN WHICH CASE MEANS
;			NO DATA TRANSFER.

;        TRANSFERS IN CHANNEL:

;            BITS	MEAN
;            0		MUST BE 0
;            1		MUST BE 1
;            14-35	ADDR OF NEXT COMMAND


;    BMX WORDS:

;	     BITS	MEAN
;	     0-7	DEVICE ADDRESS
;	     8-11	1101-START DEVICE
;	    		1110-WAITING ON DEVICE
;	    		1111-TERMINATED DEVICE
;	    		0000-END OF LIST
;	     14-35	ADDR OF DEVICE(UNIT) CMD LST

;FORMAT OF SA-10 WORDS (CONT.):

;    INSTRUCTIONS:

;	 CONO:

;	     BITS	MEAN
;	     18		RESET SA10
;	     19		CLEAR MEMORY ERRORS
;	     30		1(0)=SET(CLEAR) ACCORDING TO THE
;	    		FOLLOWING BITS:
;	    		    BIT		MEANS
;	    		    26		1-CLOCK:
;	    				    IF RUNNING:
;	    					SET=NOOP
;	    					CLEAR=STOP
;	    				    IF NOT RUNNING:
;	    					SET=START
;	  	  				CLEAR=PULSE.
;	    		    27-29	0-NOOP
;	    				3-RESET THE CHANNEL
;	    				SPECIFIED BY BITS 31&32.
;	    				4-GO FLAG
;	    				5-STATUS REQUEST FLAG
;	    				6-STATUS FLAG
;	    				7-INTERRUPT ENABLE FLAG.
;	     31-32	CHANNEL
;	     33-35	PIA

;	 CONI:

;	     BITS	MEAN
;	     18		PI REQUEST
;	     19		P.E.
;	     20		NXM
;	     21-24	INTERRUPT ENABLE ON CHAN 0,1,2,3.
;	     25-28	GO FLAG          "    "        "
;	     29-32	STATUS FLAG      "    "        "
;	     33-35	PIA

;	 DATAI:

;	     READS ONE OF 6 WORDS:
;	        WORD	BITS OF INTEREST
;		0	-
;		1	16-35 MEM ADDR FOR WHICH WE GOT A MEM ERR.
;		2	16&17 CHANNEL FOR WHICH WE GOT A MEM ERR.
;		3-5	-
;	     (TO SELECT THE WORD READ, DO A CONO CLR+NOOP+BITS
;	      30-32 SPECIFYING THE WORD NUMBER.)

;FLAGS:

    ;FOR UNIT CMDS:

	NOMXFR==400000
	EXECUT==100000
	CMDCHN==40000
	FRCINT==10000
	IGNLEN==4000
	OFFSET==2000
	    CNEXNO==CMDCHN!EXECUT!NOMXFR

	;DATA MODES.
	    MODE9D==220000
	    MODE9I==020000
	    MODE7==200000
	    MODE7I==020000

	;CMDS, SHIFTED FOR BITS 8-15, PLUS OTHER FLAGS.
	    MS7T2==CNEXNO!114
	    MS7T5==CNEXNO!514
	    MS7T8==CNEXNO!1114
	    MS7TE2==CNEXNO!214
	    MS7TE5==CNEXNO!614
	    MS7TE8==CNEXNO!1214
	    MS7TO2==CNEXNO!314
	    MS7TO5==CNEXNO!714
	    MS7TO8==CNEXNO!1314
	    MS9T8==CNEXNO!1454
	    MS9T16==CNEXNO!1414
	    MS9T62==CNEXNO!1514
	    SENSE==EXECUT!CMDCHN!MODE9I!20
	    REW==CNEXNO!34
	    REWNCH==EXECUT!NOMXFR!34
	    WTM==CNEXNO!174
	    SKR==CNEXNO!334
	    BSR==CNEXNO!234
	    REWUNL==CNEXNO!74
	    RWUNCH==EXECUT!NOMXFR!74
	    ERG==CNEXNO!134
	    READFW==EXECUT!CMDCHN!10
	    READBK==14
	    WRITE==EXECUT!CMDCHN!IGNLEN!4
	    TIE==EXECUT!CMDCHN!MODE9I!OFFSET!154

    ;FOR TRANSFERS IN CHANNEL:
	TIC==200000


    ;FOR DATA WORDS:
	LASDAT==400000


    ;FOR HALTS:
	HALT==400000


    ;FOR BMX WORDS:
	STRTDV==15
	TERMDV==17


    ;TO SET UP BMX MODE:
	BMX==400000

;FLAGS (CONT.):

    ;FOR CONOS:
	CLERSA==400000
	CLRMER==200000

    ;FOR CONIS:
	MEMERR==300000

    ;IN THE FIRST STATUS WORD:
	ASYNCH==400000
	SELERR==100000
	 BUSIN==40000
	CNTLER==20000
	LENERR==4000
	PRGINT==2000
	  ATTN==1000
	STAMOD==400
	 CUEND==200
	  BUSY==100
	CHNEND==40
	DEVEND==20
	UNITCK==10
	UNITEX==4

    ;IN BYTE 0 OF SENSE DATA.
    ;(ASSUMING BYTE 0 IS LEFT-ADJUSTED).
	CMDREJ==400000
	INTREQ==200000
	BUSOUT==100000
	EQPCHK==40000
	DATCHK==20000
	OVERUN==10000
	CNVCHK==2000

    ;FOR UNIT/KONTROLLER CHARACTERISTICS:
    ;(RETURNED TO THE USER BY A UGETF, AND SOME ALSO KEPT IN
    ;LH(UNITYP) FOR THE UNIT AND LH(FTXMCH) FOR THE KONT.).
	WRPROT==400000
	TUA==200000
	TUB==100000
	READY==2
	LOADPT==40000
	TAPEIN==20000
	IBMCMP==10000
	TRK9==100  ;(JUST FOR KONTROLLER).
	TRK7==40
	DS6250==20
	DS1600==10
	DS800==4
	DS556==2
	DS200==1

    ;IN S.
	COMPAT==400000
	HNGFTA==200000
	IOLEND==100000

;BYTE POINTERS FOR SENSE DATA.

	;WHEN SENSING INTO UNIT CMD AREA.
BYUUN7:	POINT 1,UNICMD+3(T3),^D11    ;UNIT HAS 7 TRACK CAPABILITY.
BYULDP: POINT 1,UNICMD+3(T3),^D12    ;LOAD POINT.
BYUTAB: POINT 2,UNICMD+3(T3),^D10    ;TU A AND B.
BYUWPT: POINT 1,UNICMD+3(T3),^D14    ;FILE PROTECTED.
BYUTIN: POINT 1,UNICMD+4(T3),2       ;TAPE INDICATE.
BYUDUL:	POINT 1,UNICMD+4(T3),^D18    ;UNIT IS DUAL DENSITY.
BYUMDL:	POINT 1,UNICMD+4(T3),^D20    ;UNIT MODEL NUMBER.
BYUK62:	POINT 1,UNICMD+5(T3),^D12    ;KONT CAN 6250.
BYUK79:	POINT 2,UNICMD+6(T3),9       ;KONT NRZI CAPABILITY.

	;WHEN SENSING INTO THE KONT. DB.
BYKNOI: POINT 1,FTXSTS(J),8	     ;NOISE BIT.
BYKLDP:	POINT 1,FTXSTS(J),^D12       ;LOAD POINT.
BYKNTC:	POINT 1,FTXSTS(J),^D15       ;NOT CAPABLE.
BYKIDB:	POINT 1,FTXSTS+1(J),^D11     ;ID BURST CHECK.
BYK160: POINT 1,FTXSTS+1(J),^D19     ;MODE OF TAPE UNIT,
				     ;DEPENDING ON MODEL NO.
BYKMDL: POINT 4,FTXSTS+1(J),^D23     ;UNIT MODEL NO.


;FLAGS FOR KONTROLLER MODELS:
    MODEL1==1
    MODEL2==2

;"FUNCTIONS IN PROGRESS" ARE:
;    (ORDER OF ASSIGNMENTS MATTERS):

    FNPREW==1	;REWIND.
    FNPWTM==2	;WTM.
    FNPSKR==3	;SKR.
    FNPBSR==4	;BSR.
    FNPRWU==5	;REWIND/UNLOAD.
    FNPERG==6	;ERG.
    FNPSKF==7	;SKF.
    FNPBSF==10	;BSF.
    FNPUGF==11	;UGETF OR MTAPE SENSE.
    FNPRED==12	;READ.
    FNPWRT==13	;WRITE.


;TABLE USED BY VARIOUS PLACES (MTAPE FNS, CMD SEQUENCE
;GENERATORS, ETC.).
;    (ORDER OF TABLE MATTERS):

    FT1TBL:
    TBLREW: REWNCH
    TBLWTM: WTM
    TBLSKR: SKR
    TBLBSR: BSR
    TBLRWU: RWUNCH
    TBLERG: ERG
    TBLTIE: TIE


;MISC.:

    MSKCTD: XWD 777777,740000	;MASK TO CHANGE THE COUNT BYTE
				;FROM THE DDB INTO A NUMBER.
    MSKCTU: XWD 777777,774000	;MASK TO CHANGE THE COUNT BYTE
				;FROM UNIT CMD WORD INTO A NUMBER.
    MSKMMD==777760		;MASKS OUT ALL BUT MEM ADDR
				;FROM DDB WORDS.
    MSKMMU==777700		;MASKS OUT ALL BUT MEM ADDR
				;FROM UNIT CMD WORDS.
    DATASZ: XWD 777777,774000	;-(2**11).

;ERROR RETRY COUNTS.
    INSERR==^D10
    NOISE==^D15
    OUTERR==^D15

;INTERRUPT ERROR FLAGS.
;    (ORDER OF ASSIGNMENT MATTERS).
;    (MINUS ERRORS ARE FATAL):
    ERSELE==-1		;SELECT ERROR.
    ERBSIN==-2		;BUS IN PARITY ERROR.
    ERCNTL==-3		;CONTROL ERROR.
    EREQCK==-4		;EQUIPMENT CHECK.
    ERINRQ==-5		;INTERVENTION REQUIRED.
    ERCMRJ==-6		;CMD REJECT.
    ERNTCP==-7		;NOT CAPABLE.
    ERSPBY==-8		;SPUROUS BUSY.
    ERCNSN==-9		;CAN'T SENSE OR DEVICE BUSY.
    ERMEMR==^D10	;MEMORY ERROR.
    ERBSOU==^D11	;BUS OUT CHECK.
    EROVRN==^D12	;OVERRUN.
    ERDCER==^D13	;DATA CHECK--ERASE GAP.
    ERWWTM==^D14	;DATA CHECK-WRITE/WRITE TAPE MARK.
    ERDCRE==^D15	;DATA CHECK--READING.
    ERIDBR==^D16	;ID BURST CHECK.
    ERPRGI==^D17	;THIS IS JUST FOR FDERBT PURPOSES.  IT
			;MEANS WE PROCESSED A PROGRAM INTRPT
			;THAT HAD UNIT EXCEPTION ON.


;ERROR LOGGING.

    ;FDHFUN--FN IN PROGRESS AT HUNG.
    ;FDHCNT--NO. OF HUNGS.
    ;FDHCNI--CONI AT HUNG.

    ;FDNRE1--NO. OF FAILS ON 1ST ATTEMPTS TO READ A RECORD.
    ;FDNWR1-- "  "    "    "  "     "     " WRITE "   "
    ;FDNREE--NO. OF FAILS ON ALL ATTEMPTS TO READ A RECORD.
    ;FDNWRE-- "   "   "    "  "       "    " WRITE "   "

    ;FDERBT--HAS A BIT SET FOR EACH ERROR WE EVER SEE (BIT IS
             ;ABS. MAGNITUDE OF ERXXXX).

    ;FDCNI1--ERROR BIT FOR LAST 1ST FAILURE ON A CMD.
    ;FDCNIE--ERROR BIT FOR LAST TOTAL FAILURE ON A CMD.

    ;FDSENS--SENSE BYTES FROM THE LAST GOOD SENSE DUE TO A
	     ;UNIT CHECK.

    ;DEVSTS--LH IS LIKE FDERBT; RH IS INCREMENTED EVERYTIME
    	     ;FDNRE1 OR FDNWR1 IS INCREMENTED.  DEVSTS IS
	     ;CLEARED AT RELEASE.


;DISPATCH TABLE.

	PHASE -2
DDO:	JRST FTAWRT
DDI:	JRST FTARED
	DEPHASE
FTADSP:	PHASE 0
DDXZ:	DSPSIZ
DDINT:	POPJ P,
DBYT:	4400,,4400
DVSIZ:	MOVEI T1,FTADDS
DINI:	JRST FTAINI
DHNG:	JRST FTAHNG
DRL:	JRST FTAREL
DCL:	JRST FTACLS
DOU:	JRST FTAWRT
DIN:	JRST FTARED
DZAP:	POPJ P,
DGTRD:	JRST FTAGRD
DMT:	JRST FTAPE
DGF:	JRST FTAUGF
	DSPSIZ==.-1
	DEPHASE


COMMENT %@@SUBROUTINE FTAINI

@@PURPOSE INITIALIZATION ROUTINE.

	(1) SETS UP UNIT 7/9 TRK AND DENSITY INFO IN LH(UNITYP)
	    OR ZEROES IT TO MARK THAT THE UNIT NEEDS INITIAL-
	    IZATION.
	(2) SETS UP PART OF DEVICE LIST ENTRY FOR ALL DEVICES
	    WHOSE KONTROLLER IS ACCESSIBLE.

@@ACCUM DESTROYS T1, T2, AND T3.
@@FUNCTION
SENSES EACH UNIT (GIVES UP ON ALL UNITS ON A GIVEN KONTROLLER
IF IT CAN'T ACCESS THE KONTROLLER FOR ONE OF THE UNITS)
TO DETERMINE THE INFORMATION NECESSARY TO SET UP UNITYP.
RETRIES A FEW TIMES IF NECESSARY.

@@EXIT SEE PURPOSE.

@@CALLS SUBRSN, SFISKN, AND SFISUN, AND ITS OWN ROUTINE SCLRCH
(WHICH CLEARS THE STATUS FLAG FOR A CHANNEL).

@@ERRORS
IF A KONTROLLER IS INACCESSIBLE OR ALWAYS RETURNS
ERRORS, ALL OF ITS UNITS ARE MARKED INACCESSIBLE BY
SETTING LH(UNITYP) IN THEIR UNIT DBS TO 0.  IF A UNIT IS IN-
ACCESSIBLE OR ALWAYS RETURNS ERRORS, OR IF IT CANNOT BE
USED FOR SOME OTHER REASON (EX: HAS NRZI ONLY AND KONTROLLER
DOES NOT HANDLE NRZI) ITS LH(UNITYP) IS ALSO SET TO 0.
(WHENEVER A USER ATTEMPTS TO USE A UNIT WITH 0 IN THE LH(UNITYP)
AN ATTEMPT WILL BE MADE TO INITIALIZE LH(UNITYP) BY THE ROUTINE
SAVAIL.).

@@RESTRICTIONS CALLED BY SYSINI, WITH THE PI SYSTEM OFF. @@%


COMMENT %@@SUBROUTINE SFISKN
@@PURPOSE ORIGINALLY THIS WAS A PART OF THE SYSTEM INITIALIZATION
ROUTINE.  IT AND SFISUN WERE MADE INTO SUBRS SO THEY COULD ALSO
BE CALLED IF THE UNITS BECAME AVAILABLE AFTER THE SYSTEM
CAME UP.
@@ENTRY EXPECTS T2=KONT DB, T3=UNIT DB, AND THE SENSE INFORMATION
IN ITS USUAL PLACE IN THE UNIT COMMAND LIST AREA.
@@ACCUM DESTROYS T1.
@@FUNCTION SAVES THE KONT 6250 CAPABILITY AND KONT NRZI (7 OR 9
TRACK) CAPABILITY BITS IN BOTH LH(FTXMCH) AND T4.
@@EXIT SEE FUNCTION.
@@RESTRICTIONS CALLED AT SYSTEM INITIALIZATION TIME OR AT UUO
LEVEL. @@%

COMMENT %@@SUBROUTINE SFISUN
@@PURPOSE ORIGINALLY THIS WAS A PART OF THE SYSTEM INITIALIZATION
ROUTINE.  IT AND SFISKN WERE MADE INTO SUBRS SO THEY COULD ALSO
BE CALLED IF THE UNITS BECAME AVAILABLE AFTER THE SYSTEM
CAME UP.
@@ENTRY EXPECTS T3=UNIT DB, T4=LH(FTXMCH), AND THE SENSE
INFORMATION IN ITS USUAL PLACE IN THE UNIT'S COMMAND LIST
AREA.
@@ACCUM DESTROYS T2.
@@FUNCTION SETS UP T1 AND THE LH(UNITYP) WITH DENSITY AND 7
TRACK INFO FOR THE UNIT.
@@EXIT SEE FUNCTION.
@@RESTRICTIONS CALLED AT SYSTEM INITIALIZATION TIME OR AT UUO
LEVEL. @@%
FTAINI:	PUSH	P,P3
	PUSH	P,T4
	PUSH	P,U
	PUSH	P,F
	MOVEI	T3,FTA0CB	;T3=UNIT DB.
	MOVEM	T3,FIUNIT
	MOVE	T2,UNIKNT(T3)	;T2=CHN DB,,KONT DB.

    ;LOOK AT THE NEXT KONTROLLER.
FINXKN:	MOVEM	T2,FIKONT
	SETZM	FIFLAG		;MARK AS 1ST LOOK AT KONT.
	HLRZ	T1,KONBMX(T2)	;ADJUST
	ADDI	T1,1		;FOR SPECIAL SENSE
	HRLM	T1,KONBMX(T2)	;LOCATION.
	HRRZ	T1,FTXMCH(T2)	;CHAN. NO. (STATUS FLAG.).
	MOVEM	T1,FICHAN	;SAVE IT.
	HLRZ	T4,T2		;GET CHANNEL DB.
	MOVE	U,CHNSTB(T4)	;U=4 WORD AREA ADDRESS+1.
	MOVEI	P3,CHNBMX(T4)	;SET CHANNEL
	HRLI	P3,TIC!BMX	;TO BMX
	MOVEM	P3,-1(U)	;MODE.
	SETZ	P3,		;UNIT 0.
	HLLZ	T1,CHNCLR(T4)	;RESET
	TRO	T1,CLERSA	;THE
	XCT	T1		;SA10.
FINXUN:	HRRZS	UNITYP(T3)	;ZERO THE UNIT CHARACTERISTICS.
	MOVEI	T4,^D10		;COUNT OF ERROR RETRIES
	MOVEM	T4,FIRTCN	;ALLOWED EACH UNIT.
	MOVE	F,UNIDDB(T3)
	PUSHJ	P,SUBRSN	;GEN SENSE/DW/HALT.
	SETZM	(U)		;JUST TO BE SAFE.
	HLRZ	T1,KONBMX(T2)	;GET BMX
	ADDI	T1,(P3)		;ADDR.
	HRRZ	T4,KONBSU(T2)	;DEV
	ADDI	T4,(P3)		;ADDR
	SETZM	(T1)		;TO
	DPB	T4,[POINT 8,(T1),7] ;DEV LIST.

FIGO:	MOVEI	T4,UNICMD(T3)	;POINT THE DEV LIST
	HRRM	T4,(T1)		;ENTRY TO THE UNIT CMD LIST.
	MOVEI	T4,STRTDV	;PUT START INTO THE DEV
	DPB	T4,[POINT 4,(T1),^D11] ;LIST.
	HLRZ	T4,T2		;T4=CHAN DB.
	MOVE	T4,CHNGO(T4)	;GO, BUT
	TRZ	T4,7		;TURN OFF
	XCT	T4		;PIA FIELD.

    ;WAIT.
	TLO	T4,40		;CHANGE TO CONI.
	HRRI	T4,T1		;CONI SAXN,T1.
	MOVEI	T2,^D50000	;WAIT COUNT.
FIWAIT:	XCT	T4		;DO CONI.
	TDNE	T1,FICHAN	;STATUS FLAG FOR THIS CHN UP?
	JRST	FILOOK		;YES.
	SOJG	T2,FIWAIT	;MAYBE TRY AGAIN.

    ;HERE ON NO STATUS FLAG AFTER A LONG WHILE.
FIDIE:	HRRZ	T3,UNILNK(T3)	;GET NEXT UNIT.
	JUMPE	T3,FINOUT	;JUMP IF NONE LEFT.
	MOVE	T2,UNIKNT(T3)	;GET KONT.
	CAME	T2,FIKONT	;SAME AS LAST KONT?
	JRST	FIDIE2		;NO, SO CAN TRY THIS UNIT.
	HRRZS	UNITYP(T3)	;YES.  MAKE UNIT UNAVAILABLE.
	JRST	FIDIE		;GO TO NEXT UNIT.
FIDIE2:	MOVEM	T3,FIUNIT	;TRY THIS
	JRST	FINXKN		;KONTROLLER.


    ;HERE WITH FIFLAG=0(1ST TRY AT A KONT) OR =-1 (NOT FIRST).
FILOOK:	MOVE	T4,(U)		;GET 1ST STATUS WORD.
	MOVE	T2,FIKONT	;RESTORE T2/CHANNEL,,KONT.
	TRNN	T1,MEMERR	;ERRORS?
	TLNE	T4,SELERR!BUSIN!CNTLER!PRGINT!ATTN!BUSY
	JRST	FIRTRY		;RETRY.
	SKIPN	FIFLAG		;NEED TO SET UP KONT?
	JRST	FISEKN		;YES.
	HLRZ	T4,FTXMCH(T2)	;NO.
	JRST	FISETU		;SET UP UNIT INFO.

    ;HERE ON RETRY.
FIRTRY:	TLNE	T4,BUSY		;SPURIOUS
	TLNN	T4,STAMOD	;CU BUSY?
	JRST	FIRTR2		;NO.
	PUSHJ	P,SCLRCH	;YES, CLEAR THE STATUS FLAG.
	PUSH	P,T2		;SAVE T2.
	MOVEI	T2,^D50000	;WAIT FOR
	HLLZ	T1,CHNGO(T4)	;THE STATUS FLAG TO BE STORED.
	TLO	T1,40		;MAKE THIS
	HRRI	T1,T4		;A
	XCT	T1		;CONI T4.
	TDNN	T4,FICHAN	;STATUS FLAG THERE?
	SOJG	T2,.-2		;NO, LOOK AGAIN.
	JUMPE	T2,[POP P,T2	;RESTORE T2.
		JRST FIDIE]	;GO DIE IF NO STATUS.
	POP	P,T2		;RESTORE T2.
FIRTR2:	SOSG	FIRTCN		;RETRIES LEFT?
	JRST	FIGTN2		;NO.
FIRTR4:	PUSHJ	P,SCLRCH	;CLEAR THE STATUS.
	HLRZ	T1,KONBMX(T2)	;GET BMX
	ADDI	T1,(P3)		;ADDR.
	JRST	FIGO

	;SET UP KONT INFO.
FISEKN:	PUSHJ	P,SFISKN	;SUBR SO CAN BE ONLINE LATER.
	JRST	FISETU		;LOOK AT UNIT.
SFISKN:	HLRZ	T4,FTXMCH(T2)	;GET MODEL NO.
	CAIE	T4,MODEL2	;MODEL 2?
	JRST	FISEK2		;NO.
	LDB	T1,BYUK62	;YES,  CAN THE KONT
	JUMPE	T1,FISEK2	;6250?
	TRO	T4,DS6250	;YES.
    ;N.B., IBM'S VALUES OF BYKN79 ARE 00=NONE OF 7 OR 9,
    ;01=7, 10=9, 11=SPARE.  CALCOMP'S VALUES ARE 00=NONE OF 7 OR 9,
    ;01=NEVER USED, 10=9, AND 11=7.
FISEK2:	LDB	T1,BYUK79	;GET KONT. NRZI CAPABILITY.
	TRNE	T1,1		;7TRK NRZI?
	TRO	T4,TRK7		;YES.
	TRNE	T1,2		;9 TRK NRZI?
	TRO	T4,TRK9		;YES.
	HRLM	T4,FTXMCH(T2)	;STORE KONT. INFORMATION.
	POPJ	P,


    ;SET UP UNIT INFO.
FISETU:	LDB	T2,BYUTAB	;IS THE UNIT READY?  (ELSE
	CAIE	T2,READY	;DON'T BELIEVE IT.).
	JRST	FIGTNX		;NO.
	PUSHJ	P,SFISUN	;SUBR SO CAN BE ONLINE LATER.
	JRST	FIGTNX
SFISUN:	MOVEI	T1,FDSCHR(T3)	;SAVE THE SENSE INFORMATION
	HRLI	T1,UNICMD+3(T3)	;WHEN THE UNIT
	MOVEI	T2,5(T1)	;CHARACTERISTICS ARE SET FOR
	BLT	T1,(T2)		;STC.
	LDB	T2,BYUUN7	;UNIT 7 TRK BIT.
	JUMPE	T2,FIST9T	;7 OR 9 TRACK UNIT?

    ;7 TRACK UNIT.
	TRNN	T4,TRK7		;KONT 7 TRACK CAPAB?
	POPJ	P,		;NO--WHAT A LOSER.
	HRLZI	T1,TRK7!DS556!DS800
	TRNE	T4,2		;MODEL 2 HAS 200 DENS.
	TLO	T1,DS200
	JRST	FISTOT		;GO STORE INFO.

    ;9 TRACK UNIT.
FIST9T:	SETZ	T1,
	LDB	T2,BYUMDL	;UNIT MODEL IS
	JUMPN	T2,FIST94	;3/5/7 OR 4/6/8?
    ;9 TRACK, MODEL 3/5/7.
	LDB	T2,BYUDUL	;3/5/7. 1600/800 OR 1600.
	JUMPE	T2,FISTO0	;DUAL?
	TRNE	T4,TRK9!TRK7	;KONT HAS 9 NRZI?
	TLO	T1,DS800	;YES. 1600/800.
	JRST	FISTO0		;NO. JUST 1600.
    ;9 TRACK, MODEL 4/6/8.
FIST94:	TRNE	T4,DS6250	;4/6/8.  6250/1600 OR 6250.
	TLO	T1,DS6250	;KONT HAS 6250 CAPAB.
	LDB	T2,BYUDUL	;DUAL BIT.
	JUMPE	T2,FISTOT	;UNIT HAS DUAL?
FISTO0:	TLO	T1,DS1600
FISTOT:	HLLM	T1,UNITYP(T3)	;SAVE IN UNIT DB.
	POPJ	P,

    ;GET NEXT UNIT.
FIGTNX:	SETOM	FIFLAG		;FLAG ALREADY SEEN THIS KONT.
FIGTN2:	PUSHJ	P,SCLRCH	;CLEAR THE STATUS FLAG.
	HRRZ	T3,UNILNK(T3)	;HERE WHEN MAYBE ALREADY SEEN THIS KONT.
	JUMPE	T3,FINOUT	;JUMP ON NO NEXT UNIT.
	HRRZM	T3,FIUNIT
	MOVE	T2,UNIKNT(T3)	;T2=KONT.
	CAMN	T2,FIKONT	;SAME AS LAST KONT?
	AOJA	P3,FINXUN	;YES.
	JRST	FINXKN		;GO TO NEXT KONT.
FINOUT:	POP	P,F		;
	POP	P,U		;STOP.
	POP	P,T4
	POP	P,P3
	POPJ	P,

FIUNIT: Z			;UNIT DB.
FIKONT: Z			;CHANNEL DB,, KONT DB.
FICHAN: Z			;CHANNEL STATUS FLAG.LAG: Z
FIRTCN: Z			;RETRY COUNT.


;"SUBR" (CALLED ONLY BY FTAINI) TO CLEAR THE STATUS FLAG FOR A CHANNEL.
SCLRCH:	HLRZ	T4,FIKONT	;GET CHN DB ADDR.
	MOVE	T1,CHNCLR(T4)	;
	TRZ	T1,7		;
	XCT	T1		;
	POPJ	P,

COMMENT %@@SUBROUTINE FTAREL
@@PURPOSE RELEASE ROUTINE.
@@ENTRY EXPECTS F=DDB.
@@ACCUM SETS S TO DEVIOS.
@@FUNCTION WAITS FOR IO TO COMPLETE FOR THE UNIT AND THEN CLEARS
COMPAT IN DEVIOS, IBM BYTE ADJUSTMENT AND FUNCTION IN PROGRESS
(THE HALVES OF DEVFNJ), AND DEVSTS.
@@EXIT SEE FUNCTION.
@@CALLS WAIT1.
@@RESTRICTIONS CALLED AT UUO LEVEL. @@%


FTAREL:	PUSHJ	P,WAIT1		;WAIT FOR IO TO COMPLETE.
	TLZ	S,COMPAT	;TURN OFF IBM COMPATABILITY.
	SETZM	DEVFNJ(F)	;TURN OFF IBM BYTE ADJUSTMENT.
	MOVEM	S,DEVIOS(F)	;STORE S.
	SETZM	DEVSTS(F)	;CLEAR DEVSTS.
	POPJ	P,

COMMENT %@@SUBROUTINE FTACLS
@@PURPOSE CLOSE ROUTINE.
@@ENTRY EXPECTS F=DDB.
@@ACCUM SAVES U AND F.  OTHERS MAY BE DESTROYED.
@@FUNCTION IF OUTPUT HAS BEEN DONE, AN ATTEMPT IS MADE TO
WRITE TWO TAPE MARKS (LOGICAL EOT) ON THE TAPE AND THEN TO
BACKSPACE OVER ONE OF THEM.
@@CALLS WAIT1, FT1CM2 (PART OF THE FTAPE ROUTINE), SAVAIL,
FHGSTP, AND ITS OWN INTERNAL ROUTINE FTACL6.
@@ERRORS IF THE TAPE IS WRITE LOCKED, JUST EXIT (IOIMPM HAS
BEEN SET AT INTERRUPT LEVEL.).
@@RESTRICTIONS CALLED AT UUO LEVEL. @@%


FTACLS:	TLNN	F,OUTPB		;OUTPUT BEEN DONE?
	POPJ	P,		;NO.
	PUSHJ	P,WAIT1		;WAIT.
	MOVEI	M,FNPWTM	;SET UP FOR WTM
	HRRZ	T3,DEVUDB(F)	;AND
	PUSHJ	P,FTACL6	;GO.
	TRNE	S,IOIMPM	;WRITE LOCKED?
	POPJ	P,		;YES.
	MOVEI	M,FNPWTM	;SET UP FOR WTM
	PUSHJ	P,FTACL6	;AND GO.
	MOVEI	M,FNPBSR	;SET UP BSR
	PUSHJ	P,FTACL6	;AND GO.
	TRZ	S,IODEND	;CLEAR EOF
	MOVEM	S,DEVIOS(F)	;SINCE WRITING.
	POPJ	P,

FTACL6:	PUSHJ	P,SAVAIL	;MAKE THE DEVICE AVAILABLE.
FTACL7:	PUSHJ	P,FT1CM2	;GO.
	PUSHJ	P,WAIT1		;WAIT.
	TLNN	S,HNGFTA	;INTERVENTION REQUIRED?
	POPJ	P,		;NO.
FTACL8:	PUSHJ	P,FHGSTP	;YES, SAY SO.
	MOVE	S,DEVIOS(F)	;STILL
	TLNN	S,HNGFTA	;REQUIRED?
	JRST	FTACL7		;NO, TRY AGAIN.
	PUSHJ	P,SAVA45	;YES, MAKE THE DEVICE AVAIL.
	JRST	FTACL7		;TRY AGAIN.

COMMENT %@@SUBROUTINE FTAHNG
@@PURPOSE HUNG DEVICE ROUTINE.
@@ENTRY EXPECTS F=DDB.
@@ACCUM DESTROYS T1 AND T2.
@@FUNCTION IF THE DEVICE CODE IS NEITHER WAIT NOR START, SOME-
THING IS WRONG, SO HANG.  IF THE DEVICE CODE IS WAIT, WAS IT
PREVIOUSLY WAIT? YES--HANG.  NO--MARK PREVIOUS IS WAIT AND
RETURN.  THE DEVICE CODE IS START; IS THE CHANNEL ACTIVE?  NO--
HANG.  YES--RETURN.
@@EXIT SKIP RETURNS UNLESS IT THINKS THE DEVICE IS HUNG, IN
WHICH CASE IT CLEANS UP SOME LOCATIONS AND THEN NON-SKIP
RETURNS.
@@CALLS SETHNG, SDCIOA, AND CPOPJ.
@@ERRORS SEE FUNCTION AND EXIT CONDITIONS.
@@RESTRICTIONS @@%

DEFINE DSKOFF <WRPI DSKPIF>
DEFINE DSKON <WRPI DSKPIN>

FTAHNG: DSKOFF
	TRNN	S,IOACT		;DID AN INTERRUPT SNEAK IN?
	JRST	FTAHC2		;YES.
	PUSH	P,T3		;SAVE T3.
	HRRZ	T3,DEVUDB(F)	;T3=UNIT DB.
	HRRZ	T2,UNIKNT(T3)	;T2=ADDR OF KONT PART
	HLRZ	T2,KONBMX(T2)	;OF DEVICE LIST.
	LDB	T1,[POINT 3,DEVADD(F),^D23] ;T1=UNIT NO.
	ADD	T2,T1		;T2=ADDR OF DEV LIST ENTRY.
	LDB	T1,[POINT 4,(T2),^D11] ;T1=CODE.
	CAIE	T1,16		;WAIT CODE?
	JRST	FTAHN4		;NO.
	HRRZ	T1,UNITYP(T3)	;YES. GET PREV WAS WAIT FLG.
	JUMPN	T1,FTAHN8	;JUMP ON PREV WAS WAIT.
	AOS	UNITYP(T3)	;FLAG PREV IS NOW WAIT.
FTAHCT:	PUSHJ	P,SETHNG	;RESET THE HUNG TIME.
	POP	P,T3		;RESTORE T3.
FTAHC2:	DSKON
	JRST	CPOPJ1		;CONTINUE.

FTAHN4:	CAIE	T1,15		;START CODE?
	JRST	FTAHN8		;NO--STRANGE ERROR OR HUNG.
	HLRZ	T1,UNIKNT(T3)	;GET THE CHANNEL ACTIVE
	MOVE	T1,CHNACT(T1)	;FLAG WORD.
	CAMN	T1,DEVACT(F)	;WHAT IT WAS WHEN WE STARTED?
	JRST	FTAHN8		;YES--HUNG.
	MOVEM	T1,DEVACT(F)	;NO--UPDATE US.
	JRST	FTAHCT		;CONTINUE.

FTAHN8:	AOS	FDHCNT(T3)	;COUNT HUNG OCCURRENCE.
	HRRZS	DEVER1(F)	;TURN OFF E.P.
	HLRZ	T1,UNIKNT(T3)	;GET CHANNEL DB.
	HLLZ	T1,CHNGO(T1)	;T1 HAS CONO.
	TLO	T1,40		;MAKE CONI.
	HRRI	T1,FDHCNI(T3)	;CONI SAXN,FDHCNI(T3).
	XCT	T1		;LOG CONI AT HUNG.
	LDB	T1,[POINT 4,(T2),^D11] ;IF THE DEVICE LIST ENTRY
	CAIN	T1,TERMDV	;IS NOT TERMINATE,
	JRST	FTAHN9		;THEN
	HLRZ	T1,UNIKNT(T3)	;WHAP A UNIT. T1/ CHN DB.
	MOVE	T1,CHNGO(T1)	;MAKE
	TRC	T1,7B29		;SELECTIVE RESET.
	XCT	T1		;CAUSE CONTROL ERROR.
	MOVEI	T1,TERMDV	;PUT TERMINATE INTO
	DPB	T1,[POINT 4,(T2),^D11] ;DEV LIST ENTRY.
FTAHN9:	HLRZ	T1,DEVFNJ(F)	;GET FN IN
	HRRZM	T1,FDHFUN(T3)	;PROGRESS WHEN HUNG.
	POP	P,T3		;RESTORE T3.
	PUSHJ	P,SDCIOA	;DEC DON'T SWAP CNT AND CLR FNP.
	DSKON
	POPJ	P,

COMMENT %@@SUBROUTINE SDCIOA
@@PURPOSE SUBR TO DECREMENT THE "DON'T SWAP WHILE
IOACT" COUNT (JBTIOA) AND TURN OFF THE FNP.
@@ENTRY EXPECTS F=DDB AND T1=FNP.  ADDITIONAL ENTRY POINT IS
SDCIO2.
@@ACCUM DESTROYS T1 AND T2.
@@FUNCTION (1) CLEAR THE FNP KEY IN THE LH(DEVFNJ), AND (2)
FOR FNS READ AND WRITE, DEC JBTIOA AS WELL.
@@EXIT SEE FUNCTION.
@@RESTRICTIONS CALLED AT BOTH UUO AND INTERRUPT LEVEL. @@%

SDCIOA:	CAIGE	T1,FNPRED	;READ OR WRITE?
	JRST	SDCIO4		;NO.
SDCIO2:	LDB	T1,PJOBN	;YES, GET JOB NO.
	SOS	JBTIOA(T1)	;ADJ DON'T SWP WHILE "IO" CNT.
SDCIO3:	PUSHJ	P,DECDIO	;ADJ PGYDIOS & MAYBE PAGWAK.
SDCIO4:	HRRZS	DEVFNJ(F)	;CLEAR THE FNP.
	POPJ	P,

COMMENT #
@@SUBROUTINE DECDIO
@@PURPOSE
DECS PGYDIO FOR THE PAGES OF THE COMMAND WORDS BETWEEN WHERE
DEVDIO POINTS AND THE END OF THE LIST.
CALLS PAGWAK IF PGYDIO GOES TO ZERO.
@@ENTRY
EXPECTS
@@ACCUM
DESTROYS T1 AND T2.
@@ #

DECDIO:	PUSH	P,T4		;
	HRRZ	T4,DEVDIO(F)	;GET T4/ ADDR OF LIST.
	SKIPN	T1,(T4)		;ALL DONE WITH BUFFERED?
	JRST	[POP P,T4	;YES.
		POPJ P,]	;
	PUSH	P,PG		;SAVE PG AND
	PUSH	P,J		;J.
DECDI2:	PUSHJ	P,BUFKRN	;PROCESS UP TO THE NEXT 0.
	LDB	T2,PIOMOD	;DONE IF D OR
	CAIL	T2,DR		;DR.
	JRST	.+3		;
	SKIPE	T1,1(T4)	;BUFFERED, NEED
	AOJA	T4,DECDI2	;TWO ZEROES TO BE DONE.
	POP	P,J		;RESTORE J
	POP	P,PG		;AND PG.
	POP	P,T4		;RESTORE T4.
	POPJ	P,




COMMENT #
@@SUBROUTINE BUFDIO
@@PURPOSE
FOR BUFFERED MODE, DECS PGYDIO FOR THE PAGES OF THE COMMAND
WORDS BETWEEN WHERE DEVDIO POINTS AND THE NEXT ZERO.  LEAVES
DEVDIO POINTING AT THE WORD AFTER THE ZERO WORD.
CALLS PAGWAK IF PGYDIO GOES TO ZERO.
@@ENTRY
EXPECTS
@@ACCUM
DESTROYS NO ACS.
@@ #

BDIO:	PUSH	P,T1		;
	PUSH	P,T2		;
	PUSH	P,T4		;
	PUSH	P,PG		;SAVE PG AND
	PUSH	P,J		;J.
	HRRZ	T4,DEVDIO(F)	;GET T4/ ADDR OF LIST.
	SKIPN	T1,(T4)		;
	 STOPCD (.,JOB,MTANIB,,<No IOWDs in BDIO>)
	PUSHJ	P,BUFKRN	;PROCESS TO THE NEXT 0.
	MOVEI	T4,1(T4)	;ADJUST
	HRRM	T4,DEVDIO(F)	;DEVDIO.
	POP	P,J		;RESTORE J
	POP	P,PG		;AND PG.
	POP	P,T4		;
	POP	P,T2		;
	POP	P,T1		;
	POPJ	P,




;TINY SUBR USED BY BDIO AND DECDIO.
;  EXPECTS T1/ CONTENTS OF CMD WORD, T4/ ADDR OF THAT CMD WORD.
;  RETURNS T4/ ADDR OF NEXT ZERO WORD.
;  DESTROYS T1, T2, T4, PG, AND J.
BUFKRN:	ADDI	T1,1		;-COUNT AND ADDRESS-1+1.
	LDB	PG,[POINT 13,T1,26] ;GET PHYSICAL PAGE NUMBER.
	LDB	T1,PGYDIO	;GET DIRECT I/O COUNT.
	SOJGE	T1,.+2		;SHOULD BE NON-ZERO.
	 STOPCD                 ;;BUFKRN+4
	DPB	T1,PGYDIO	;
	JUMPN	T1,.+2		;
	PUSHJ	P,PAGWAK	;WAKE UP ALL THE JOBS.
	MOVEI	T4,1(T4)	;GO TO NEXT WORD.
	SKIPE	T1,(T4)		;ALL DONE?
	JRST	BUFKRN		;NO.
	POPJ	P,

COMMENT %@@SUBROUTINE SYDFTA
@@PURPOSE CODE FOR THE SYSDVF UUO.
@@ENTRY
@@ACCUM
@@FUNCTION
@@EXIT
@@CALLS
@@ERRORS
@@RESTRICTIONS @@%

SYDFTA:	ADDI	M,1		;POINT M TO THE UNIT NAME.
	UMOVE	T1,(M)		;T1/ UNIT NAME.
	MOVEI	U,FTA0DB	;U/ 1ST UNIT'S DDB ADDR.
	JUMPN	T1,FTDVF2	;JUMP UNLESS WANT 1ST UNIT.
	MOVE	U,DEVUDB+FTA0DB	;POINT TO UNIT BLOCK
	MOVE	T1,FTA0DB+DEVNAM ;GET NAME OF 1ST UNIT.
	JRST	FTDVF7		;GO FINISH UP.
FTDVF2:	CAMN	T1,DEVNAM(U)	;MATCH?
	  JRST	FTDVF5		;YES.
	HRRZ	U,DEVUDB(U)	;NO.  U/ UNIT DB ADDR.
	SKIPN	U,UNILNK(U)	;GET NEXT UNIT DB ADDR?
	  JRST	SYDNM4		;NO, NO UNITS LEFT.
	MOVE	U,UNIDDB(U)	;YES, U/ DDB ADDR.
	JRST	FTDVF2		;GO LOOK AT THIS UNIT.
FTDVF5:	MOVE	U,DEVUDB(U)	;FOUND MATCH.
	SKIPN	U,UNILNK(U)	;IS THERE A NEXT UNIT?
	  JRST	SYDNM4		;NO.
	MOVE	T1,UNIDDB(U)	;YES, GET AND
	MOVE	T1,DEVNAM(T1)	;STORE ITS
FTDVF7:	UMOVEM	T1,(M)		;NAME.
	MOVEI	T1,FTULNH	;T1/ LENGTH OF UDB.
	MOVSI	T2,LICSYS!LICSPY;
	TDNN	T2,JBTLIC(J)	;
	  JRST	CPOPJ1		;
	SOJLE	P1,CPOPJ1	;
	AOJA	M,SYDCOM	;

COMMENT %@@SUBROUTINE FTAUGF
@@PURPOSE UGETF ROUTINE.

IF RH(E)=0,	RETURN BYTE COUNT FOR LAST USER RECORD FILLED TO E+1.
	=1,	GET LH(E) SENSE WORDS INTO E+1, E+2, ETC.
		(IF LH(E) IS >6, 6 WORDS ARE RETURNED.).
	=2,	COMPACTED SENSE DATA INTO E+1 AS FOLLOWS:
			BIT 0 -- FILE PROTECTED
			BITS 1&2 -- TUA&B
			BIT 3 -- LOAD POINT
			BIT 4 -- TAPE INDICATE
			BIT 5 -- IBM COMPATIBLE UNIT
			BIT 12 -- 7 TRACK
			BITS 13 TO 17 -- 6250,1600,800,556,200

@@ENTRY EXPECTS M TO BE ADDR OF E AND F=DDB.
@@ACCUM SAVES F AND M.  OTHER ACS MAY BE DESTROYED.
@@FUNCTION FOR ARG 0, PICK UP CONTENTS OF DEVDWC.  FOR ARGS 1
AND 2, SENSE THE UNIT AND DETERMINE THE INFORMATION.
@@CALLS WAIT1, SGTDEV, FHGSTP, SUBRSN, AND SUBRG2.
@@ERRORS ANY OF THE FOLLOWING CAUSE E+1 TO BE SET TO -1:
(1) E DOES NOT HAVE ONE OF THE FORMS DESCRIBED UNDER PURPOSE.
(2) RH(E)=0 AND THE MODE IS NEITHER D NOR DR.
(3) RH(E)=1 AND LH(E)<1.
@@RESTRICTIONS CALLED AT UUO LEVEL. @@%


FTAUGF:	UHRRZ U,(M)		;GET RH(E).
	CAIG	U,2		;ARG IN
	JRST	FFUGF2		;BOUNDS?
FFUERR:	XCTTU	<SETOM 1(M)> ;ERROR
	POPJ	P,		;RETURN.

FFUGF2:	PUSHJ	P,WAIT1		;WAIT FOR IOACT TO GO OFF.
FFUGF3:	HRRZ	T3,DEVUDB(F)	;GET UNIT DB ADDR.
	HLRZ	T1,UNITYP(T3)	;GET UNIT CHARACTERISTICS.
	JUMPG	U,FFUSEN	;GO TO PERFORM FUNCTION.

    ;ARG 0.
	LDB	T1,PIOMOD	;MUST BE DR OR
	CAIGE	T1,DR		;D, ELSE
	JRST	FFUERR		;ERROR.
	MOVE	T1,DEVDWC(F)	;GET BYTE COUNT.
FFUSTO:	UMOVEM T1,1(M) 		;STORE IN E+1
	POPJ	P,		;AND RETURN.

    ;ARGS 1 AND 2.
FFUSEN:	JUMPN	T1,FFUS2	;JUMP ON AVAILABLE UNIT.
FFUS1:	PUSHJ	P,SGTDEV	;TRY TO GET IT.
	JRST	FFUS2		;WIN.
	PUSHJ	P,FHGSTP	;SAY TROUBLE.
	MOVE	S,DEVIOS(F)	;RESTORE S.
	JRST	FFUS1		;TRY AGAIN.
FFUS2:	PUSHJ	P,SUBRSN	;GET SENSE CMD SET UP.
	HRRZI	T1,FNPUGF	;SET UP
	HRLM	T1,DEVFNJ(F)	;FN IN PROGRESS.
	PUSHJ	P,SUBRG2	;GO.
	PUSHJ	P,WAIT1		;WAIT.
	SOJN	U,FFUAR2	;GO TO ARG 1 OR ARG 2.

    ;ARG=1
FFUAR1:	UHLRZ T2,(M)		;GET LH(E).
	CAILE	T2,6		;MAX. OF
	MOVEI	T2,6		;SIX WORDS.
	JUMPE	T2,FFUERR	;MUST BE AT LEAST 1.
	HRLZI	T1,UNICMD+3(T3) ;SET UP TO
	HRRI	T1,1(M)		;BLT.
	ADDI	T2,(M)		;BLT AND
	XCTTU	<BLT T1,(T2)> ;THEN
	POPJ	P,		;RETURN.

    ;ARG=2.
FFUAR2:	HLLZ	T1,UNITYP(T3)	;GET TRK, DENSITY INF.
	LDB	T2,BYUWPT	;FILE PROTECTED?
	JUMPE	T2,.+2		;JUMP ON NO,
	TLO	T1,WRPROT	;ELSE SET BIT.
	LDB	T2,BYUTAB	;GET TUA&B
	DPB	T2,[POINT 2,T1,2] ;AND STORE THEM.
	LDB	T2,BYUTIN	;AT
	JUMPE	T2,.+2		;EOT?
	TLO	T1,TAPEIN	;YES.
	LDB	T2,BYULDP	;AT
	JUMPE	T2,.+2		;LOAD POINT?
	TLO	T1,LOADPT	;YES.
	TLO	T1,IBMCMP	;IBM COMPATIBLE UNIT.
	JRST	FFUSTO		;SET UP E AND RETURN.

COMMENT %@@SUBROUTINE FTAPE
@@PURPOSE SET UP AND GO FOR MTAPE FUNCTIONS.
0 WAIT	10 GO TO LEOT  100 DEC, 9 TRACK	        201 7 TRACK SPECIAL, ADJ 0
1 REW	11 REW/UNL     101 IBM,     "   ADJ 0	202    "      "        "  1
3 WTM	13 ERG         102  "       "    "  1	203    "      "        "  2
6 SKR	16 SKF         103  "       "    "  2	204    "      "        "  3
7 BSR	17 BSF         104  "       "    "  3
@@ENTRY EXPECTS M=ADDR OF E, F=DDB, AND S=DEVIOS.
AN ADDITIONAL ENTRY POINT IS FT1CM2.
@@ACCUM SAVES F. OTHERS MAY BE DESTROYED. SETS T3=UNIT DB ADDR
AND S=DEVIOS.
@@CALLS WAIT1, CPOPJ, SAVAIL, SUBRSM, SUBRGO, AND ITS INTERNAL
ROUTINE FT1CM2.
@@RESTRICTIONS CALLED AT UUO LEVEL. @@%


    ;DISPATCH TABLE FOR FNS.
FTPTBL:	XWD FT1CMD,FTDIE
	XWD FT1CMD,FTDIE
	XWD FTDIE,FTDIE
	XWD FT1CMD,FT1CMD
	XWD FT1CMD,FTLEOT
	XWD FT1CMD,FTDIE
	XWD FTDIE,FTDIE
	XWD FTSKBS,FTSKBS


FTAPE:	PUSHJ	P,WAIT1		;WAIT FOR IOACT TO GO OFF.
	HRRZI	M,(M)		;GET FN.
	JUMPE	M,CPOPJ		;FN 0 IS DONE.

FTP2:	PUSHJ	P,SAVAIL	;MAKE THE UNIT AVAILABLE.
	HLRZ	T1,UNITYP(T3)	;UNIT CHAR TO T1.
	CAILE	M,204		;FN OUT OF BOUNDS?
	JRST	FTDIE		;YES.
	CAIL	M,201		;BETWEEN 201 AND 204?
	JRST	FT7SPC		;YES, 7 TRK SPECIAL.
	CAILE	M,104		;<= 104?
	JRST	FTDIE		;NO.
	CAIL	M,100		;FNS 100-104 GO
	JRST	FT9TRK		;TO FT9TRK.

	TRNE	M,777760	;FN OUT OF
	JRST	FTDIE		;BOUNDS.

	TRNN	S,IOPAR		;EVEN PARITY?
	JRST	FTP6		;NO.
	TLNE	S,COMPAT	;YES, ONLY
	TRNN	T1,TRK7		;LEGAL IF IBM
	JRST	FTDIE		;MODE AND 7 TRACK.

FTP6:	ROT	M,-1		;GET
	JUMPL	M,.+2		;DISPATCH
	SKIPA	T1,FTPTBL(M)	;ADDR
	HLRZ	T1,FTPTBL(M)	;AND
	JRST	(T1)		;GO.

    ;HERE ON USER ERROR.
FTDIE:	TRO	S,IOIMPM	;FLAG AND
	JRST	FTOUT		;EXIT.

    ;7 TRACK SPECIAL MODE.
FT7SPC:	TRNN	T1,TRK7		;7 TRACK?
	JRST	FTDIE		;NO.
	SUBI	M,100		;YES,
	JRST	FTOUT0		;OKAY.

    ;9 TRACK FNS (100 TO 104).
FT9TRK:	TRNN	S,IOPAR		;EVEN PARITY IS A NO-NO.
	TRNE	T1,TRK7		;POSSIBLE TO DO 9 TRACK?
	JRST	FTDIE		;NO--DIE.
	CAIN	M,100		;DEC=COMPAT
	TLZA	S,COMPAT	;OFF,
FTOUT0:	TLOA	S,COMPAT	;IBM=COMPAT ON.
	JRST	FTOUT		;
	SUBI	M,101		;STORE THE
	HRRZM	M,DEVFNJ(F)	;BYTE ADJUST FOR IBM MODE.
FTOUT:	MOVEM	S,DEVIOS(F)	;STORE S AND
	POPJ	P,		;EXIT.


    ;1 CMD FNS (1,3,6,7,11,13).
FT1CMD:	JUMPG	M,FT1CM2	;"FN IN
	MOVEI	M,1(M)		;PROGRESS" TO LH
FT1CM2:	HRLM	M,DEVFNJ(F)	;OF DEVFNJ.
	PUSHJ	P,SUBRSM	;SM CMD TO UNICMD.
	HRLZ	T1,FT1TBL-1(M)	;SET UP THE ACTUAL
	TDO	T1,DEVADD(F)	;FN AND DEV ADDR AND
	MOVEM	T1,UNICMD+1(T3)	;STORE IT.
	HRLZI	T1,HALT		;HALT
	MOVEM	T1,UNICMD+2(T3)	;CMD.
	PJRST	SUBRGO		;GO.

    ;SKF AND BSF (16 AND 17).
FTSKBS:	MOVEI	U,FNPSKF	;"FN IN
	JUMPG	M,.+2		;PROGRESS" TO
	MOVEI	U,FNPBSF	;LH OF
FTSKB2:	HRLM	U,DEVFNJ(F)	;DEVFNJ.
	PUSHJ	P,SUBRSM	;SM CMD TO UNICMD.
	MOVEI	T2,9		;GEN A
	HRLZ	T1,FT1TBL-5(U)	;CMD LIST
	TDO	T1,DEVADD(F)	;FULL OF
	MOVEI	U,(T3)		;SKR'S AND
FTSKB4:	MOVEM	T1,UNICMD+1(U)	;BSR'S
	AOJ	U,.+1		;AND THEN
	SOJG	T2,FTSKB4	;GEN A
	MOVEM	T1,UNICMD+1(U)	;HALT
	HRLZI	T1,HALT		;CMD AND
	MOVEM	T1,UNICMD+2(U)	;THEN
	PJRST	SUBRGO		;GO.

    ;LEOT (10).
    ;
    ;    1ST, BSR SINCE MAY BE AN EOF OR CONTAIN EOT.
    ;    2ND, SKF.  DONE IF EOT.  IN ANY EVENT, SAW AN EOF.
    ;    3RD, SKR.  DONE IF EOT.  DONE ALSO IF EOF SINCE
    ;    	TWO IN A ROW (IF THIS CASE, ADJUST TAPE BY A
    ;		BSR BEFORE EXITING.).
    ;    THEN, GO TO 2ND TO KEEP TRYING.

FTLEOT:	MOVEI	M,FNPBSR	;1ST STEP--
	PUSHJ	P,FT1CM2	;BSR.
	PUSHJ	P,WAIT1		;WAIT FOR COMPLETION.
FTLEO4:	MOVEI	U,FNPSKF	;2ND STEP--
	PUSHJ	P,FTSKB2	;SKF.
	PUSHJ	P,WAIT1		;WAIT.
	TLNE	S,IOLEND	;DONE IF
	POPJ	P,		;EOT.
	MOVEI	M,FNPSKR	;3RD STEP--
	PUSHJ	P,FT1CM2	;SKR.
	PUSHJ	P,WAIT1		;WAIT.
	TDNN	S,[XWD IOLEND,IODEND] ;DONE ON EOT
	JRST	FTLEO4		;OR EOF.
	TRNN	S,IODEND	;EOF?
	POPJ	P,		;NO.  EOT/DONE.
	MOVEI	M,FNPBSR	;FIN WITH
	JRST	FT1CM2		;BSR.

COMMENT %@@SUBROUTINE FTARED/WRT
@@PURPOSE READ AND WRITE ROUTINES.
@@ENTRY EXPECTS S=DEVIOS AND F=DDB.
@@ACCUM SAVES F AND M.  OTHERS MAY BE DESTROYED.  SETS T3=UNIT
DDB AND S=DEVIOS.
@@FUNCTION CAUSES THE UNIT CMD AREA TO BE SET UP WITH THE
APPROPRIATE COMMANDS TO DO THE READS/WRITES SPECIFIED BY THE
DDB LIST, SETS UP, AND GOES.  (EXCEPT IF THIS IS A BUFFERED
MODE REQUEST WITH A 0 COUNT, IN WHICH CASE IT JUST RETURNS.).
@@CALLS SAVAIL, WAIT1, SCOMBL, SUBRG1, AND SDCIO2.
@@ERRORS CERTAIN BAD DDB LISTS (SEE SCOMBL.).
@@RESTRICTIONS CALLED AT UUO LEVEL. @@%
FTARED:	TLZA	S,IO		;SET IO BIT ON FOR WRITE AND OFF
FTAWRT:	TLO	S,IO		;FOR READ. ALSO USE AS A FLAG.
	PUSHJ	P,SAVAIL	;MAKE THE UNIT AVAILABLE.
	HRRZ	T1,DEVCLS(F)	;START DIO CALCS AT
	HRRM	T1,DEVDIO(F)	;BEGINNING OF LIST.
	HLRZ	T1,UNITYP(T3)	;UNIT CHAR TO T3.
	TRNN	S,IOPAR		;EVEN PARITY?
	JRST	FTARW3		;NO.
	TLNE	S,COMPAT	;YES, ONLY LEGAL IF IBM
	TRNN	T1,TRK7		;MODE AND
	JRST	FTARW5		;7 TRACK.
FTARW3:	PUSHJ	P,WAIT1		;WAIT FOR UNIT CMD LIST TO FREE UP.
	LDB	T1,PIOMOD	;GET MODE.
	CAIL	T1,DR		;DUMP OR DR AND BEGINNING OF
	TLZN	S,IOBEG		;IOWD MEAN NOTHING READ YET.
	JRST	.+2		;DEVDWC HOLDS COUNT OF ITEMS
	SETZM	DEVDWC(F)	;READ FROM START OF LAST IOWD.
	SETZM	DEVCNT(F)	;NOTHING CONTINUED YET.
	MOVEI	T1,FNPRED	;SET UP THE
	TLNE	S,IO		;FN IN PROGRESS
	MOVEI	T1,FNPWRT	;IN
	HRLM	T1,DEVFNJ(F)	;DEVFNJ.
	LDB	T2,PJOBN	;GET THE JOB NO.
	AOS	JBTIOA(T2)	;INC "DON'T SWP WHILE "IO" CNT.
	PUSHJ	P,SCOMBL	;SET UP THE UNIT CMD LIST.
	JRST	SUBRG1		;GO.
	AOS	DEVABC(F)	;ONLY GET HERE ON OUTPUT.
	PUSHJ	P,BDIO		;DEC PGYDIOS.
	PJRST	SDCIO2		;RETURN HERE ON NOTHING TO DO.

FTARW5:	LDB	T1,PIOMOD	;ADJUST DEVABC IF BUFFERED
	CAIGE	T1,DR		;MODE.
	AOS	DEVABC(F)	;
	TRO	S,IOIMPM	;SET IMPROPER
	MOVEM	S,DEVIOS(F)	;MODE.
	PJRST	SDCIO3		;EXIT, CLEARING PGYDIOS.

COMMENT %@@SUBROUTINE SGTDEV
@@PURPOSE SUBR TO GET A DEVICE IF IT WASN'T AVAILABLE WHEN
THE SYSTEM CAME UP.
@@ENTRY EXPECTS T3=UNIT DB AND F=DDB.
@@ACCUM DESTROYS NO ACS.
@@FUNCTION SETS UP PART OF THE DEVICE LIST ENTRY.
TRIES TO SENSE THE UNIT TO GET THE INFORMATION
FOR LH(UNITYP); IF SUCCESSFUL, ALSO STORES KONTROLLER CAPABI-
LITIES IN LH(FTXMCH).
@@EXIT SKIP RETURNS IF CAN'T ACCESS THE UNIT.
@@CALLS SUBRSN, SUBRG2, WAIT1, SFISKN, AND SFISUN.
@@ERRORS SKIP RETURN IF COULDN'T ACCESS THE UNIT.
@@RESTRICTIONS CALLED AT UUO LEVEL. @@%

SGTDEV:	PUSH	P,T1		;SAVE
	PUSH	P,T2		;SOME OF
	PUSH	P,T4		;THE
	PUSH	P,P3		;ACS.
	LDB	P3,[POINT 3,DEVADD(F),^D23] ;GET UNIT NO.
	HRRZ	T2,UNIKNT(T3)	;T2/ KONT DB ADDRESS.
	HLRZ	T1,KONBMX(T2)	;T1/START OF DEVICE LIST.
	HRRZ	T2,KONBSU(T2)	;T2/KONTROLLER DEVICE ADDRESS.
	ADDI	T1,(P3)		;ADDRESS OF UNIT'S ENTRY.
	ADDI	T2,(P3)		;UNIT'S DEVICE ADDRESS.
	SETZM	(T1)		;ZERO THE DEVICE LIST ENTRY.
	DPB	T2,[POINT 8,(T1),7] ;
	SETZM	UNICMD+3(T3)	;0 TU A&B JUST IN CASE.
	SETZM	UNICMD+11(T3)	;FLAG FOR 1ST TRY.
	PUSHJ	P,SUBRSN	;SET UP A SENSE CMD.
	HRRZI	T1,FNPUGF	;SET FN IN
	HRLM	T1,DEVFNJ(F)	;PROGRESS.
	PUSHJ	P,SUBRG2	;GO.
	PUSHJ	P,WAIT1		;WAIT.
	LDB	T2,BYUTAB	;CAN WE BELIEVE
	CAIN	T2,READY	;THIS DEVICE?
	JRST	SGTDV4		;YES.
	AOS	-4(P)		;SKIP RETURN ON LOSE.
	JRST	SGTDV5		;
SGTDV4:	HRRZ	T2,UNIKNT(T3)	;GET KONT DB ADDRESS BACK.
	HLRZ	T4,FTXMCH(T2)	;SET UP KONT CAPABILITIES.
	TRZ	T4,TRK9!TRK7!DS6250
	HRLM	T4,FTXMCH(T2)	;
	PUSHJ	P,SFISKN	;YES, SET UP KONTROLLER INFO.
	PUSHJ	P,SFISUN	;SET UP UNIT INFO.
SGTDV5:	POP	P,P3		;RESTORE
	POP	P,T4		;THE ACS THAT
	POP	P,T2		;WERE
	POP	P,T1		;SAVED.
	POPJ	P,

COMMENT %@@SUBROUTINE SAVAIL
@@PURPOSE SUBR TO MAKE THE UNIT AVAILABLE.
@@ENTRY EXPECTS F=DDB.
@@ACCUM DESTROYS S, T3, AND T4.
(T3 IS SET TO UNIT DB AND S TO DEVIOS).
@@FUNCTION
	 IS LH(UNITYP)<>0 (UNIT INITIALIZED AT SYSTEM START)?
		1. IF NO, CALL SGTDEV REPEATEDLY UNTIL IT
		   WINS (EACH TIME IT FAILS TELL THE USER WITH
		   FHGSTP). WHEN IT WINS, RETURN.
		2. IF YES, THEN CHECK HNGFTA IN DEVIOS.
			A. IF HNGFTA IS NOT SET, RETURN.
			B. IF HNGFTA IS SET, SENSE TO SEE IF
			   INTERVENTION IS STILL REQUIRED.
			   IF IT IS, SAY SO VIA HNGSTP.  ON
			   CONTINUE FROM HNGSTP, GO TO STEP 2.
			   IF IT IS NOT, CLEAR HNGFTA & RETURN.
@@EXIT RETURNS WHEN THE UNIT IS PROBABLY AVAILABLE (SEE
FUNCTION AND ERRORS.).
@@CALLS SGTDEV, FHGSTP, SUBRSN, SUBRG2, AND WAIT1.
@@ERRORS NOTE THAT THIS ROUTINE DOES NOT ALWAYS SENSE TO
SEE THAT THE UNIT IS AVAILABLE; IF LH(UNITYP) IS SET AND
HNGFTA IS NOT SET, IT JUST RETURNS, EVEN THOUGH THE UNIT MAY
REALLY NOT BE READY. THIS IS TO AVOID SENSING BEFORE EVERY
OPERATION.
@@RESTRICTIONS CALLED AT UUO LEVEL.@@%
;
;SETS UP T3 AND S.

SAVAIL:	PUSH	P,T1		;SAVE T1.
	HRRZ	T3,DEVUDB(F)	;T3=UNIT DDB ADDRESS.
	HLRZ	T1,UNITYP(T3)	;UNIT AVAIL AT SYSTEM START?
	JUMPN	T1,SAVAL4	;JUMP ON YES.

    ;HERE WHEN UNIT WAS NOT UP WHEN SYSTEM CAME UP.
SAVAL2:	PUSHJ	P,SGTDEV	;NO, TRY TO GET IT NOW.
	JRST	SAVAL8		;WON, GO RETURN.
	PUSHJ	P,FHGSTP	;LOST, SAY SO.
	JRST	SAVAL2		;TRY AGAIN.

    ;HERE WHEN UNIT IS UP.
SAVAL4:	MOVE	S,DEVIOS(F)	;IS HNGFTA
	TLNN	S,HNGFTA	;SET?
	JRST	SAVAL8		;NO, SO RETURN.
	JRST	SAVAL5		;YES.
SAVA45:	PUSH	P,T1		;SAVE OF T1 DUE TO RELS BELOW.
SAVAL5:	PUSHJ	P,SUBRSN	;YES, SET UP THE SENSE.
	HRRZI	T1,FNPUGF	;SET UP
	HRLM	T1,DEVFNJ(F)	;THE FN IN PROGRESS.
	SETZM	UNICMD+3(T3)	;JUST TO BE SAFE, 0 TO INTREQ.
	PUSH	P,T2		;SAVE T2.
	PUSHJ	P,SUBRG2	;GO.
	POP	P,T2		;RESTORE T2.
	PUSHJ	P,PWAIT1	;WAIT.
	MOVE	S,DEVIOS(F)	;GET NEW S.
	MOVE	T1,UNICMD+3(T3)	;INT REQ
	TLNE	T1,INTREQ	;STILL?
	JRST	SAVAL6		;YES, GO SAY SO.
	TLZ	S,HNGFTA	;NO, SO CLEAR
	MOVEM	S,DEVIOS(F)	;IT.
	JRST	SAVAL8		;GO RETURN.
SAVAL6:	PUSHJ	P,FHGSTP	;SAY INT REQ.
	MOVE	S,DEVIOS(F)	;INTRPT LEVEL
	TLNE	S,HNGFTA	;CLEARED HNGFTA?
	JRST	SAVAL5		;NO, GO SEE IF CLEAR.

SAVAL8:	POP	P,T1		;RESTORE T1.
	POPJ	P,		;



FTAGRD:	PUSH	P,T3		;
	PUSH	P,T4		;
	PUSHJ	P,SAVAIL	;
	POP	P,T4		;
	POP	P,T3		;
	POPJ	P,

SUBTTL INTERRUPT PROCESSING

COMMENT %@@SUBROUTINE FTXINT
@@PURPOSE INTERRUPT PROCESSING @@%

;THE DDB INTERRUPT/ERROR LOCS OF SPECIAL INTEREST HERE ARE:
;
;	DEVER1:	LH=1 IF JUST SENSED DUE TO A UNIT CHECK, ELSE 0.
;		RH=ADDR OF CMD WE LAST SAW AN ERROR ON.
;		   (REALLY ADDR OF NEXT CMD).
;
;	DEVER2: LH=PHASE OF DATA CHECK-READ RECOVERY, OR 0.
;		RH=0 IF TAPE CLEANING IS ALLOWED (I.E., WE
;		   DID NOT HIT THE LOAD POINT WHILE TC).
;
;	DEVNOI: # OF ALLOWED NOISE RECORDS PER "REAL RECORD".
;
;	DEVOUT: # OF ALLOWED "OUTSIDE" ERRORS LEFT FOR THIS
;		RECORD.
;
;	DEVINS: # OF ALLOWED "INSIDE" ERRORS PER DC-R, OR RETRY
;		COUNT FOR DC-R PHASES 4 AND 5.
;
;	DEV40:  40 COUNT FOR DC-R PHASES.
;
;	    ;STORAGE DURING DC-R RECOVERY:
;	UNIDCR: SAVED READ CMD.
;	UNIDCN: SAVED NEXT CMD.
;	UNIDC1: ADDR OF READ CMD.
;
;
;PHASES OF DC-R RECOVERY ARE:
;
;    1		READING FORWARDS 40 TIMES.
;    2		READING BACKWARDS 40 TIMES.
;    3		READING BACKWARDS 40 TIMES, AFTER A WIN BUT LENGTH
;    		ERROR IN PHASE 2.  ADJUSTED COUNTS AND MEM ADDRS.
;    11,12,13	TAPE CLEANING SEQUENCE, PART 1, WITHIN PHASES 1,
;		2,3.
;    21,22,23	TAPE CLEANING SEQUENCE, PART 2, WITHIN PHASES 1,
;		2,3.
;    4		ADJUST TAPE WITH SKR AND STOP.  (THIS FLAG IS ALSO USED
;		FOR TAPE ADJUSTMENT WHEN WE DIED ON WRITING.)
;    5		ADJUST TAPE WITH SKR AND CONTINUE.
;    6		ADJUST TAPE WITH BSR FOR PHASE 7.
;    7		ONCE ONLY READ FORWARDS AFTER PHASES 2 OR 3 HAVE FAILED.
;
;
;ON ENTRY, J=KONT DB AND R=CHANNEL DB.
;
;WORKING ACS ARE T3=UNIT DB, F=DDB, R=CHANNEL DB, J=KONT DB,
;P3="UNIT NUMBER", U=4 WORD AREA ADDRESS+1, AND S.
;
;OTHER ACS DESTROYED ARE T1,T2,T4, AND M.

    ;SET UP T1,T3,S,U,P3, AND F.
FTXINT:	MOVE	U,CHNSTB(PG)	;U=4 WORD AREA ADDR+1.
	MOVE	T1,(U)		;T1=1ST STATUS WORD.
	MOVEM	T1,FTXSX1(J)	;SAVE IT FOR DEBUGGING.
	LDB	P3,[POINT 3,T1,^D23] ;P3=UNIT NO.
	SKIPE	T3,@KONPTR(J)	;T3=UNIT DB.
	JRST	FTXIN2
	TLNE	T1,ASYNCH	;INTRPT FOR NON-EXIST UNIT.
	TLNN	T1,CUEND	;BETTER BY ASYNCH CUEND,
	JRST	FTXIN1		;ELSE IT IS SPURIOUS.
	TLNE	T1,DEVEND
	JRST	FTXIN1
	SETZM	FTXBSY(J)	;HERE ON ASYNCH CUEND.
	JRST	FXBSY4		;GO RESTART WAITERS.
FTXIN1:	AOS	FTXSPR(J)	;INC COUNT OF SPURIOUS INTRPTS.
	MOVEM	T1,FTXSP1(J)	;SAVE LAST ONE.
	JRST	FXDSM2		;DISMISS.
FTXIN2:	MOVE	F,UNIDDB(T3)	;F=DDB.
	MOVE	S,DEVIOS(F)	;GET S.
	MOVEM	T1,UNISX1(T3)	;SAVE
	MOVE	T2,1(U)		;SAXBAS LOCS
	MOVEM	T2,UNISX2(T3)	;FOR
	MOVE	T2,2(U)		;DEBUGGING
	MOVEM	T2,UNISX3(T3)	;PURPOSES.

	TLNE	T1,BUSY		;BUSY SET?
	JRST	FTXIN4		;YES.
	SKIPE	FTXBSY(J)	;NO, RESTART SINCE PREV BUSY+CUEND?
	PUSHJ	P,SSTAL0	;YES, RESTART WAITING UNITS.
	SETZM	FTXBSY(J)
	TLNE	T1,CUEND	;NOT BUSY + CUEND +
	TLNE	T1,DEVEND	;NOT DEVEND IS ASYNCH CUEND.
	JRST	FTXIN4		;NO.
	TLNN	T1,UNITCK!UNITEX ;EXCEPT UC OR UE.
	JRST	FXBSY4		;YES, GO RESTART WAITERS.


;IS THERE A FN IN PROGRESS?
FTXIN4:	HLRZ	M,DEVFNJ(F)	;GET FN.
	JUMPN	M,FXERCK	;JUMP ON REALLY A FN.
	TLNE	T1,UNITCK	;IF UNIT CHECK,
	JRST	FXUCG1		;WE MUST SENSE.
	TLZ	S,HNGFTA	;ELSE MAYBE THE UNIT
	MOVEM	S,DEVIOS(F)	;WAS READIED.
	JRST	FXDSM2		;DISMISS.



    ;HERE WHEN A FN IS IN PROGRESS.
;CHECK FOR ERRORS (SEQUENCE OF CHECKING IS IMPORTANT).
FXERCK:	SKIPL	CHNSTB(PG)	;FIRST SEE IF NO ERRORS OR
	TLNE	T1,SELERR!BUSIN!CNTLER!PRGINT!CUEND!BUSY!UNITCK
	JRST	FXER1		;OTHER INTERESTING THINGS
	HLRZ	T4,DEVER1(F)	;INCLUDING JUST SENSING AFTER A
	JUMPN	T4,FXSNC2	;UC HAS HAPPENED.
FXERC6:	HRRZ	T2,DEVER1(F)	;WERE WE ERROR PROCESSING?
	JUMPE	T2,FXNRML	;JUMP ON NO.
	HLRZ	T4,DEVER2(F)	;GET PHASE OF DC-R.
	JUMPE	T4,FXNRML	;JUMP ON NOT IN DC-R RECOVERY.
	CAIE	T4,7		;WIN ON PHASES 1
	CAIN	T4,1		;OR 7 IS
	JRST	FXNRML		;REALLY A WIN.
	HRRZ	T4,1(U)		;MAYBE GOT PAST
	CAIG	T4,(T2)		;ERROR?
	JRST	FXWON		;NO.
	CAIE	T4,1(T2)	;SPECIAL CASE OF WIN ON PHASES 2 OR 3?
	JRST	FXNRML		;NO.

;HERE WHEN WON ON A PHASE OF DC-R RECOVERY.
;(PHASES 2,3,4,5 OR TC1(11,12,13) OR TC2(21,22,23).).

FXWON:	HLRZ	T4,DEVER2(F)	;GET PHASE.
	CAIGE	T4,11		;TAPE CLEANING?
	JRST	FXWON1		;NO.

    ;WON ON TC.
	MOVEI	T1,INSERR	;WE WILL NOW EITHER
	HRRZM	T1,DEVINS(F)	;TC2 OR READ AGAIN.
	CAIL	T4,21		;WON ON TC2?
	JRST	FXWON0		;YES.

    ;WON ON TC1.
	ADDI	T4,10		;SHOW THIS IS
	HRLM	T4,DEVER2(F)	;TC2.
	HRLZI	T1,SKR		;SET
	PUSHJ	P,STC12		;UP TC2 SEQUENCE AND
	JRST	FXDSM2		;GO.

    ;WON ON TC2.
FXWON0:	SUBI	T4,20		;CHANGE THE PHASE
	HRLM	T4,DEVER2(F)	;BACK TO 1, 2, OR 3.
	HRRZ	T4,UNIDC1(T3)	;GEN SM,TIE,
	PUSHJ	P,STIE		;TIC.
	JRST	FXDSM2		;GO.

    ;WON ON PHASES 2,3,4,5, OR 6.
FXWON1:	LDB	T2,PIOMOD	;GET MODE.
	JRST	@.-1(T4)
	FXWON2		;WON ON PHASE 2.
	FXWON3		;WON ON PHASE 3.
	FXWON4		;WON ON PHASE 4.
	FXWON5		;WON ON PHASE 5.
	FXWNP7		;WON ON PHASE 6.

    ;WON ON PHASE 4.
FXWON4:	CAIL	T2,DR		;BUFFERED?
	JRST	FXSTOP		;NO, STOP.
	HLRZ	T1,DEVFNJ(F)	;YES.
	CAIE	T1,FNPWRT	;WRITING?
	JRST	FXWN44		;NO.
	AOS	DEVABC(F)	;YES.
	PUSHJ	P,BDIO		;DEC PGYDIOS.
	JRST	FXSTOP
FXWN44:	TLNN	S,IOEND		;READING.  BUMP BUFFER COUNT?
	PUSHJ	P,SBUFZR	;YES.
	JRST	FXSTOP		;STOP.

    ;WON ON PHASE 5.
    ;(HERE ON BUFFERED OR (DR AND NEITHER HALT NOR IOBKTL)).
FXWON5:	CAIN	T2,DR		;BUFFERED?
	JRST	FXWN57		;NO, DR.
	HRRZ	T1,DEVER1(F)	;T1=ADDR OF
	SOJ	T1,.+1		;LAST DW.
	PUSHJ	P,SBUFCT	;CALC (DEVBWC) AND DEVABC.
	MOVS	T1,UNIDCN(T3)	;HALT
	CAIN	T1,HALT		;NEXT?
	JRST	FXSTOP		;YES.
	TLNE	S,IOW		;NO.
	PUSHJ	P,SETIOD	;UNWAIT.
FXWN57:	HRRZ	T4,DEVER1(F)	;RESTORE
	MOVE	T1,UNIDCN(T3)	;NEXT
	MOVEM	T1,(T4)		;CMD.
	PUSHJ	P,SSMTIC	;GEN SM, TIC.
	SETZM	DEVER1(F)	;TURN OFF
	SETZM	DEVER2(F)	;E.P.
	JRST	FXDSM2		;GO.


    ;WON ON PHASE 2.
FXWON2:	TLNN	T1,UNITEX	;UNIT EXCEPTION?
	JRST	FXWN21		;NO.
	CAIL	T2,DR		;YES.  SAW
	TROA	S,IODEND	;TM
	TRZ	S,IODEND	;SO
	TLO	S,IOEND		;SET UP S.

    ;COMMON ROUTINE FOR END, READ NOTHING IN LAST "REQUEST",
    ;ADJUST TAPE.
    ;HERE ON SAW TAPE MARK ON PHASE 2, AND SOME FATAL ERRORS.
FCMRDA:	CAIE	T2,DR		;DR?
	JRST	FXWNP4		;NO.
	HRRZ	T1,1(U)		;YES.
	PUSHJ	P,SGPREV
	MOVEI	T1,-1(T4)
	PUSHJ	P,SDMPCT
	JRST	FXWNP4		;ALL GO TO PHASE 4.

FXWN21:	TLNN	T1,LENERR	;LENGTH ERROR?
	JRST	FXWON3		;NO.
	PUSHJ	P,SLENER	;YES.
	JRST	FXWN28		;TAPE > REQUEST.
	TLNE	S,COMPAT	;TAPE < REQ.
	JRST	FXWN22		;MAYBE SET
	MOVE	T1,@UNIDC1(T3)	;THE ODD
	TRNN	T4,1		;NO.
	TLZA	T1,2000		;OF
	TLO	T1,2000		;WORDS
	MOVEM	T1,@UNIDC1(T3)	;BIT.
FXWN22:	MOVE	M,T4		;SAVE ACTUAL.
	HRRZ	T1,DEVER1(F)	;SET UP  T1
	MOVEI	T1,-1(T1)	;FOR SWRDRD.
	PUSHJ	P,SWRDRD	;T4=REQUEST.
	AOJ	T1,.+1		;T1=ADDR OF 1ST DW.
	SUB	T4,M		;T4=REQUEST-TAPE.
FXWN23:	LDB	M,[POINT ^D11,(T1),^D11] ;FIND
	TDO	M,MSKCTU	;UNUSED
	ADD	T4,M		;DATA
	JUMPLE	T4,.+2		;WORDS.
	AOJA	T1,FXWN23	;T1=ADDR OF 1ST USED DW.
	JUMPL	T4,.+2		;JUMP ON EXACTLY
	AOJA	T1,FXWN25	;FINISHED DW.
	LDB	T2,[POINT ^D24,(T1),^D35] ;ADJUST
	ADD	T2,M		;THE
	SUB	T2,T4		;"1ST"
	DPB	T4,[POINT ^D11,T2,^D11] ;DATA
	MOVEM	T2,(T1)		;WORD.
FXWN25:	MOVE	T2,UNIDC1(T3)	;T2=ADDR OF CMD.
	CAIL	T2,-1(T1)	;MOVE?
	JRST	FXWN26		;NO NEED.
	MOVE	M,(T2)		;YES. MOVE
	SETZM	(T2)		;THE CMD
	CAIGE	T2,-2(T1)	;DOWN AND ZERO THE
	AOJA	T2,.-2		;UNUSED PLACES SO SDMPCT/SBUFST
	MOVEM	M,1(T2)		;WILL WORK.
	ADDI	T2,1		;NOTE THE
	MOVEM	T2,UNIDC1(T3)	;NEW POSITION OF CMD.
	HRRZ	T4,DEVER1(F)	;MARK
	HRLZI	M,LASDAT	;LAST DW AS
	IORM	M,-1(T4)	;LAST.
FXWN26:	MOVEI	M,3		;SET UP FOR PHASE 3.
    ;GO ON START OF PHASES 2,3, OR 7.
FXPHGO:	HRRZI	T1,^D40		;SET 40
	HRRZM	T1,DEV40(F)	;COUNT.
	HRRZI	T1,INSERR	;SET
FXPHG2:	MOVEM	T1,DEVINS(F)	;INSIDE ERROR COUNTS.
	HRLM	M,DEVER2(F)	;STORE PHASE.
	HRRZ	T4,UNIDC1(T3)	;GEN SM,
	PUSHJ	P,SSMTIC	;TIC
	JRST	FXDSM2		;GO.


    ;HERE ON TAPE > REQUEST
FXWN28:	CAIE	T2,D		;BUFFERED AND DR
	TRO	S,IOBKTL	;SET IOBKTL.
	JRST	FXWNP7		;GO TO PHASE 4.

    ;WON ON PHASE 3 OR ON PHASE 2 WITH NO LEN ERR.
FXWON3:	CAIGE	T2,DR		;BUFFERED?
	JRST	FXWNP5		;YES.  JUST GO TO PHASE 5.
	CAIE	T2,DR		;DR?
	JRST	FXWN32		;NO.  D.
	MOVS	T1,UNIDCN(T3)	;DR.  NEXT IS HALT?
	CAIE	T1,HALT		;HALT?
	JRST	FXWNP5		;NO, GO TO PHASE 5.
FXWN32:	HRRZ	T4,DEVER1(F)	;YES.  SET UP T1
	MOVEI	T1,-1(T4)	;FOR SDMPCT.
	PUSHJ	P,SDMPCT	;CALC DEVDWC AND
				;STOP WITH PHASE 4.


    ;SET UP PHASE 4 (ADJUST AND STOP).
FXWNP4:	HRRZI	M,4		;PHASE IS 4.
	JRST	FXWNAJ		;

    ;SET UP PHASE 5 (ADJUST AND CONTINUE).
FXWNP5:	HRRZI	M,5		;PHASE IS 5.
FXWNAJ:	HRLZI	T1,SKR		;GEN SKR.
	JRST	FXWNA2

    ;SET UP PHASE 6 (ADJUST FOR PHASE 7.).
FXWNP6:	HRRZI	M,6		;PHASE IS 6.
	HRLZI	T1,BSR		;GEN BSR.
FXWNA2:	HRLM	M,DEVER2(F)	;STORE PHASE.
	PUSHJ	P,SSKBSR	;GEN SM/SKR OR BSR/HALT AND RETRY COUNT.
	JRST	FXDSM2		;GO.

;"NORMAL" (I.E., ONLY UNIT EXCEPTION OR LENGTH ERROR) END OF
;INTERRUPT PROCESSING.
;
;AT START, M=FN IN PROGRESS AND T1=1ST STATUS WORD.

FXNRML:	SETZM	DEVER2(F)	;TURN OFF ERROR
	SETZM	DEVER1(F)	;PROCESSING.
	CAIG	M,FNPBSF	;MTAPE FN?
	JRST	FXNMMT		;YES.
	CAIL	M,FNPRED	;NO.  FTARED/WRT?
	JRST	FXNMRW		;YES.
	LDB	T1,BYUTIN	;MUST BE UGETF OR MTAPE SENSE.
	JUMPE	T1,.+2		;TAPE INDICATE ON?
	TDOA	S,[XWD IOLEND,IOTEND] ;YES, SET EOT.
FXSTP0:	TDZ	S,[XWD IOLEND,IOTEND]


    ;DISMISS THE INTERRUPT.
FXSTOP:	TLNE	S,IOW
	PUSHJ	P,SETIOD
	TRZ	S,IOACT
	MOVEM	S,DEVIOS(F)
	HLRZ	T1,DEVFNJ(F)	;GET THE FN IN PROGRESS.
	PUSHJ	P,SDCIOA	;DEC DON'T SWAP CNT AND CLR FNP.
FXDSM2:	XCT	CHNGO(PG)
	XCT	CHNCLR(PG)
	POPJ	P,

    ;DISMISS THE INTERRUPT.
FXDSM1:	PUSHJ	P,FSTHNG
	JRST	FXDSM2

;NORMAL END OF INTERRUPT PROCESSING FOR MTAPE FNS.
;
;N.B., UNIT EXCEPTION HERE MEANS (1) WTM OR ERG SAW EOT, OR
;(2) SKR(SKF) OR BSR(BSF) SAW A TM.


FXNMMT:	CAILE	M,FNPERG	;1 CMD FNS?
	JRST	FXMT6		;NO.

    ;NORMAL END OF INTERRUPT PROCESSING FOR MTAPE 1 CMD FNS.
    ;(REW, REW/UNL, ERG, WTM, SKR, BSR).
	CAIN	M,FNPRWU	;REWIND UNLOAD?
	JRST	FXDSM2		;YES, IGNORE THIS INITIAL INTRPT.
	CAIE	M,FNPREW	;REWIND?
	JRST	FXMT2		;NO.
	TLNN	T1,DEVEND	;YES, WHICH INTRPT?
	JRST	FXDSM2		;1ST ONE, IGNORE IT.
	JRST	FXMT0		;LAST ONE, PROCESS IT.
FXMT2:	CAIE	M,FNPERG	;ERG OR
	CAIN	M,FNPWTM	;WTM?
	JRST	FXMT00		;YES.
	TLNE	T1,UNITEX	;NO, BSR OR SKR.
	TRO	S,IODEND	;IF UNITEX, SAW TM.
	JRST	FXMTSN		;GO SENSE FOR EOT.
FXMT00:	TLNE	T1,UNITEX	;HERE ON ERG OR WTM.
	TDOA	S,[XWD IOLEND,IOTEND] ;IF UNITEX, SAW
	TDZ	S,[XWD IOLEND,IOTEND] ;AN
	JRST	FXSTOP		;EOT.
FXMT0:	TDZ	S,[XWD IOLEND,IOTEND] ;HERE ON REW
	SKIPN	DEVER1(F)	;BSR/F MAY GET HERE FROM EP
	TRO	S,IOBOT		;BUT EP DOES NOT SET IOBOT.
	JRST	FXSTOP		;


    ;NORMAL END OF INTERRUPT PROCESSING FOR MTAPE >1 CMD FNS.
FXMT6:	TLNN	T1,UNITEX	;UNIT EXCEPTION?
	JRST	FXMT7		;NO, CONTINUE.
	TRO	S,IODEND	;YES, SAW EOF.
FXMTSN:	MOVEM	S,DEVIOS(F)	;STORE S.
	PUSHJ	P,SUBRSN	;YES.  SENSE
	MOVEI	T1,FNPUGF	;FOR
	HRLM	T1,DEVFNJ(F)	;EOT.
	MOVEI	T1,UNICMD(T3)
	PUSHJ	P,SUBSTI
	SETZM	DEVER1(F)
	SETZM	DEVER2(F)
	JRST	FXDSM2
FXMT7:	PUSHJ	P,SUBRST
	JRST	FXDSM2

;NORMAL END OF INTERRUPT PROCESSING FOR FTARED/WRT.

FXNMRW:	LDB	T2,PIOMOD	;T2=MODE.
	TLNN	T1,UNITEX	;UNIT EXCEPTION?
	JRST	FXRW5		;NO.


    ;HERE ON UNIT EXCEPTION.
	CAIE	M,FNPWRT	;WRITING?
	JRST	FXRW2		;NO.

    ;HERE ON WRITING AND UNIT EXCEPTION.
	TDO	S,[XWD IOLEND,IOTEND] ;TRIED TO WRITE PAST EOT.
	CAIL	T2,DR		;THIS IS A CROCK FOR
	JRST	FXSTOP		;A HARDWARE PROBLEM THAT
	HRRZ	T1,1(U)		;OCCURRED ON C33, IN WHICH
	HLRZ	T1,-1(T1)	;UNIT EX ON WRITE PAST EOT DID
	CAIE	T1,HALT		;NOT BREAK CHAINING, CAUSING
	JRST	FCMWR4		;THE LAST BUFFER TO BE PROCESSED
	JRST	FXSTOP		;TWICE, 1=PRGINT,2=HALT+UNITEX.
    ;COMMON ROUTINE FOR MUST STOP WRITING.  ADJUSTS DEVABC
    ;FOR BUFFERED MODE.
FCMWRT:	CAIL	T2,DR		;IF BUFFERED,
	JRST	FXSTOP		;
FCMWR4:	AOS	DEVABC(F)	;BUMP BUFFER COUNT.
	PUSHJ	P,BDIO		;DEC PGYDIOS.
	JRST	FXSTOP		;STOP.

    ;HERE ON READING AND UNIT EXCEPTION.
FXRW2:	TLO	S,IOEND		;TRIED TO
	CAIGE	T2,DR		;READ PAST
	JRST	.+3		;EOT.
	TRO	S,IODEND	;D OR
	JRST	FCMRD1		;DR.
	TRZ	S,IODEND	;BUFFERED.
	JRST	FXSTOP		;

;COMMON ROUTINE FOR END, READ NOTHING IN LAST "REQUEST".
;HERE ON READ EOF OR FATAL READ ERROR.
FCMRD0:	CAIGE	T2,DR		;D OR DR?
	JRST	FCMRD2		;NO.
FCMRD1:	CAIE	T2,DR		;YES.  DR?
	JRST	FXSTOP		;D.  DONE.
	HRRZ	T1,1(U)		;DR.  SET UP T1.
	PUSHJ	P,SGPREV	;T4=ADDR OF PREVIOUS CMD.
	MOVEI	T1,-1(T4)	;SET UP
	PUSHJ	P,SDMPCT	;DEVDWC.
	JRST	FXSTOP		;STOP.
FCMRD2:	PUSHJ	P,SBUFZR	;0 TO (DEVBWC), BUMP DEVABC.
	JRST	FXSTOP		;STOP.



    ;HERE ON A HALT OR LENGTH ERROR.
FXRW5:	CAIE	M,FNPWRT	;WRITING?
	JRST	FXRW7		;NO.
	TDZ	S,[XWD IOLEND,IOTEND] ;YES, NO UE SO NOT PAST EOT.

    ;WRITING, HALT.
FXRWCN:	CAIE	T2,D		;BUF OR DR AND MORE TO DO?
FXRWC2:	SKIPN	DEVCNT(F)	;MORE TO DO?
	JRST	FXSTOP		;NO.
	PUSHJ	P,SCOMBL	;YES.  SET IT UP
	JRST	.+2		;AND GO.
	JRST	FXSTOP		;DONE.
	TLNN	S,IOW		;IN IOW?
	JRST	FXDSM2		;NO, JUST CONTINUE.
	LDB	T2,PIOMOD	;GET MODE.
	CAIE	T2,DR		;DR?
	PUSHJ	P,SETIOD	;NO,  BUFF. CALL SETIOD.
	JRST	FXDSM2		;CONTINUE.

    ;READING, HALT OR LEN ERR.
FXRW7:	TLNE	T1,LENERR	;LENGTH ERROR?
	JRST	FXRW9		;YES.

    ;READING, HALT.
	CAIGE	T2,DR		;BUFFERED?
	JRST	FXRWC2		;YES, GO SEE IF MORE TO DO.
	HRRZ	T1,1(U)		;NO.  T1= ADDR OF LAST
	SUBI	T1,2		;DATA WORD.
FXRW8:	PUSHJ	P,SDMPCT	;SDMPCT(SET UP DEVDWC).
	JRST	FXRWCN		;GO SEE IF MORE TO DO.

    ;READING, LENGTH ERROR.
FXRW9:	PUSHJ	P,SLENER	;SOME LEN ERR PROCESSING.
	JRST	FXRW15		;HERE ON TAPE >REQUEST.

    ;TAPE < REQUEST.
	CAIN	T2,DR		;DR?
	JRST	FXRW12		;YES.
	CAIE	T2,D		;NO, D?
	JRST	.+3		;NO.
FXRW10:	ADDM	T4,DEVDWC(F)	;YES, D.
	JRST	FXSTOP
	PUSHJ	P,SBUFST	;BUFFERED. STORE T4 IN (DEVBWC).
FXRW11:	PUSHJ	P,SGDEV1	;IS THE NEXT
	HLRZ	T1,(T4)		;COMMAND A
	CAIN	T1,HALT		;HALT?
	JRST	FXRWC2		;YES.
	TLNE	S,IOW		;NO.  TAKE OUT OF
	PUSHJ	P,SETIOD	;IOW AND GEN A
	PUSHJ	P,SSMTIC	;SM AND TIC AND THEN
	JRST	FXDSM2		;CONTINUE.

    ;TAPE < REQUEST, DR.
FXRW12:	MOVE	M,T4		;M HAS TAPE COUNT.
	PUSHJ	P,SGDEV1	;GET AND SAVE
	PUSH	P,T4		;ADDR OF
	MOVEI	T1,-1(T4)	;NEXT CMD.
	PUSHJ	P,SWRDRD	;T4 HAS REQUEST.
	SUB	T4,M		;T4 HAS REQUEST - TAPE.
	MOVN	T4,T4		;ADJUST DEVDWC SO COMES OUT OKAY
	ADDM	T4,DEVDWC(F)	;WHEN WORD COUNT CALCED AT END.
	POP	P,T1		;T1 HAS ADDR OF NEXT CMD.
FXRW13:	HLRZ	T4,(T1)		;IS THE NEXT CMD
	CAIN	T4,HALT		;A HALT?
	SOJA	T1,FXRW8	;YES, SEE IF MORE TO DO.
	HRRZI	T4,(T1)		;
	PUSHJ	P,SSMTIC	;GEN SM & TIC AND THEN
	JRST	FXDSM2		;CONTINUE.


    ;TAPE > REQUEST.
FXRW15:	CAIN	T2,DR		;DR?
	JRST	FXRW16		;YES.
	CAIN	T2,D		;NO, D?
	JRST	FXRW10		;YES.
	PUSHJ	P,SBUFST	;BUFFERED. STORE T4 IN (DEVBWC).
	TRO	S,IOBKTL	;THIS IS A FATAL ERROR.
	JRST	FXSTOP		;STOP.

    ;TAPE > REQUEST, DR.
FXRW16:	TRO	S,IOBKTL	;FLAG ERROR.
	PUSHJ	P,SGDEV1	;T1=ADDR OF
	MOVE	T1,T4		;NEXT CMD FOR
	JRST	FXRW13		;HALT CHECK.

    ;HERE WITH AN ERROR OR OTHER INTERESTING THING.
FXER1:	TLNE	T1,PRGINT	;PROGRAMMED INTRPT?
	JRST	FXPRGI		;YES.
	TLNE	T1,UNITCK	;NO.  UNIT CHECK?
	JRST	FXUCGO		;YES.
	TLNN	T1,BUSY		;NO.  BUSY?
	JRST	FXER11		;NO.
	HLRZ	T4,DEVER1(F)	;YES.  DURING SENSE DUE TO
	JUMPN	T4,.+3		;A UC? IF SO, JUMP.
	TLNE	T1,STAMOD!CUEND!DEVEND ;NO.  REAL DEVICE BUSY?
	JRST	FXBUSY		;NO.
	PUSHJ	P,SSTAL0	;YES OR DURING S DUE TO UC.
	JUMPN	T4,FXSNC1	;JUMP IF DURING S DUE TO UC.
	JRST	FXSNC0		;ELSE REAL DEVICE BUSY.
FXER11:	TLNE	T1,CUEND	;CONTROL UNIT END?
	JRST	FXBSY6		;YES.
	HLRZ	T4,DEVER1(F)	;NO.  SENSE DUE TO UC?
	JUMPE	T4,FXEROR	;NO.  MAY ALSO BE SELERR/BUSIN/CNTLER/MEMERR.


    ;HERE ON JUST SENSED DUE TO UC AND ONE OR MORE OF SELECT
    ;ERROR, BUSIN, CONTROL ERROR, AND MEM ERROR ARE ON.
	PUSHJ	P,SSTAL0	;RESTART ANY WAITING UNITS.
	MOVE	T4,FTXSS1(J)	;WERE
	TLNN	T4,SELERR!BUSIN!CNTLER ;OLD ERRORS
	SKIPGE	FTXSMY(J)	;INCLUDING MEM ERROR?
	JRST	FXSNC4		;YES--SO SENSE INFO DOESN'T MATTER.
FXSNC1:	HLRZ	T2,KONBMX(J)	;CLEAR THE SPECIAL
	SETOM	-1(T2)		;SENSE LOC.
FXSNC0:	HRREI	T2,ERCNSN	;FLAG TYPE OF ERROR AND GO TO
	JRST	FXER09		;E. P.
    ;OK HERE--SINCE SENSE INFO IS OK OR ELSE WE DON'T NEED IT.
FXSNC2:	PUSHJ	P,SSTAL0
	MOVEI	T1,FDSENS(T3)	;LOG THE
	HRLI	T1,FTXSTS(J)	;SENSE
	BLT	T1,FDSENS+5(T3)	;BYTES.
FXSNC4:	HLRZ	T1,KONBMX(J)	;CLEAR THE SPECIAL
	SETOM	-1(T1)		;SENSE LOC.
	MOVE	T1,FTXSS2(J)	;RESTORE
	MOVEM	T1,1(U)		;THE
	LDB	T1,[POINT 1,FTXSMY(J),0] ;OLD STATUS
	DPB	T1,[POINT 1,CHNSTB(PG),0] ;AND
	MOVE	T1,FTXSM0(J)	;BOTH WORDS
	MOVEM	T1,CHNMER(PG)	;OF
	MOVE	T1,FTXSS1(J)	;MEM
	MOVEM	T1,(U)		;ERR INFORMATION.
	HRRZS	DEVER1(F)	;TURN OFF THE S DUE TO U C FLAG.
	JRST	FXEROR		;GO PROCESS ERROR.


   ;HERE ON PROGRAMMED INTERRUPT.
FXPRGI:	SETZM	DEVER2(F)	;TURN OFF E.P.
	LDB	T2,PIOMOD	;GET MODE.
	CAIL	T2,DR		;HERE BUFFERED OR DR.  WHICH?
	JRST	FXDSM2		;DR.
	TLNN	S,IO		;BUFFERED.  WRITING?
	JRST	FXPRG1		;NO.
	AOS	DEVABC(F)	;YES.  BUMP BUFFER
	PUSHJ	P,BDIO		;DEC PGYDIOS.
	TLNE	T1,UNITEX	;CROCK FOR HARDWARE PROBLEM
	TDO	S,[XWD IOLEND,IOTEND] ;ON C33.
	JRST	FXPRG2		;COUNT.
FXPRG1:	HRRZ	T1,1(U)		;BUFFERED.
	MOVEI	T1,-1(T1)	;POINT T1 TO LAST DATA WORD TO
	PUSHJ	P,SBUFCT	;SET UP (DEVBWC) AND DEVABC.
FXPRG2:	HRRZ	T1,1(U)		;CALL SETIOD IF
	HLRZ	T1,(T1)		;WAITING, UNLESS
	CAIN	T1,HALT		;NEXT IS
	JRST	FXDSM2		;HALT.
	TLNE	S,IOW		;WAITING?
	PUSHJ	P,SETIOD	;YES.
	JRST	FXDSM2


    ;HERE ON A UNIT CHECK, NEED TO SENSE.
FXUCGO:	MOVEI	T4,1		;MARK SENSE.
	HRLM	T4,DEVER1(F)	;SENSE DUE TO UC.
	MOVEM	T1,FTXSS1(J)	;SAVE 1ST AND 2ND
	MOVE	T1,1(U)		;STATUS
	MOVEM	T1,FTXSS2(J)	;WORDS
	MOVE	T1,CHNMER(PG)	;AND
	MOVEM	T1,FTXSM0(J)	;BOTH
	MOVE	T1,CHNSTB(PG)	;MEM ERR INFOS
	HLLM	T1,FTXSMY(J)	;IN KONT DB.
	TLZ	T1,700000	;CLEAR THE MEM ERR
	HLLM	T1,CHNSTB(PG)	;FLAGS.
FXUCG1:	DPB	P3,[POINT 3,FTXSNS(J),^D23] ;SET UP A SENSE.
	MOVEI	T1,FTXSNS(J)	;POINT THE
	HLRZ	T2,KONBMX(J)	;SPECIAL SENSE LOC
	SUBI	T2,1		;IN THE DEVICE
	HRRZM	T1,(T2)		;LIST TO THE SENSE.
	MOVEI	T1,STRTDV	;DPB A START
	DPB	T1,[POINT 4,(T2),^D11] ;CODE INTO IT.
	LDB	T1,[POINT 8,DEVADD(F),^D23] ;PUT THE DEVICE ADDR
	DPB	T1,[POINT 8,(T2),7] ;INTO IT.
	PUSHJ	P,FSTHNG	;SET THE HUNG TIME
	JRST	FXDSM2		;AND GO.


    ;HERE ON BUSY.
FXBUSY:	TLNE	T1,STAMOD	;BUSY + STATUS MODIFIER + ?
	JRST	FXBSY2		;YES.
    ;HERE ON BUSY+POSSIBLY CUEND).
    ;I.E., BUSY+CUEND OR BUSY+DEVEND.
FXBSY1:	TLNE	T1,CUEND	;BUSY+CUEND?
	SETOM	FTXBSY(J)	;YES, FLAG RESTART.
	PUSHJ	P,SAJSNS	;
	SETZ	T1,		;RESTART
	PUSHJ	P,SSTONE	;THIS ONE UNIT AND
	JRST	FXDSM2		;DISMISS THE INTERUPT.
    ;HERE ON BUSY + SM + ?
FXBSY2:	HLRZ	T4,UNITYP(T3)	;ATTEMPTING TO INITIALIZE?
	JUMPN	T4,FXBSY3	;JUMP ON NO.
	SKIPE	UNICMD+11(T3)	;YES,  FIRST TRY?
	JRST	FXBSY3		;NO, ASSUME REAL KU BUSY.
	SETOM	UNICMD+11(T3)	;YES.  SET NOT 1ST TRY.
	HLRZ	T4,KONBMX(J)	;GET DEVICE LIST ADDRESS
	ADDI	T4,(P3)		;FOR THIS UNIT.
	HRRZI	M,UNICMD(T3)	;POINT THE DEV LIST
	HRRM	M,(T4)		;TO THE START OF THE CMD LIST.
	MOVEI	M,STRTDV	;SET START CODE
	DPB	M,[POINT 4,(T4),^D11] ;IN THE DEVICE LIST ENTRY.
	PUSHJ	P,FSTHNG	;
	JRST	FXDSM2		;
FXBSY3:	MOVNI	T4,(P3)		;SET THE
	HRRZI	M,400000	;UNIT BUSY
	LSH	M,(T4)		;BIT IN
	IORM	M,FTXSMY(J)	;FTXSMY.
	PUSHJ	P,SAJSNS	;
	PUSHJ	P,FSTHNG
	TLNN	T1,CUEND	;BUSY+SM+CUEND?
	JRST	FXDSM2		;NO, BUSY+SM. DISMISS.
FXBSY4:	PUSHJ	P,SSTALL	;HERE ON CUEND OR BUSY+SM+CUEND,
	JRST	FXDSM2		;SO RESTART ALL BUSY-BITTED
				;UNITS AND DISMISS THE INTRPT.
    ;HERE ON NOT BUSY+CUEND+DEVEND.
FXBSY6:	TLNN	T1,UNITEX	;UNIT EXCEPTION?
	JRST	FXBS63		;NO.  SEE IF DONE.
	HLRZ	T4,DEVFNJ(F)	;YES. STOP IF
	CAIE	T4,FNPSKF	;SKIP FILE OR
	CAIN	T4,FNPBSF	;BACKSPACE FILE.
	JRST	FXBS65		;STOP.
FXBS63:	HLRZ	T4,KONBMX(J)	;SEE IF
	ADDI	T4,(P3)		;WE FINISHED
	HRRZ	T4,(T4)		;THE LIST OF
	HLRZ	T1,(T4)		;COMMANDS.
	CAIN	T1,HALT		;DID WE?
	JRST	FXBS64		;YES.
	HLRZ	T1,-1(T4)	;MAYBE NOT.
	CAIE	T1,HALT		;DID WE?
	JRST	FXBSY7		;NO.
FXBS64:	MOVE	T1,(U)		;
	TLNE	T1,ASYNCH	;ASYNCH NON-INTERESTING
	TLNE	T1,SELERR!BUSIN!CNTLER!LENERR!UNITEX ;STATUS
	JRST	FXBS65		;DOES NOT
	MOVEM	T4,1(U)		;UP PROPERLY.
FXBS65:	PUSHJ	P,SSTAL0	;YES.
	HRLZI	T1,CUEND	;TURN OFF CUEND
	ANDCAB	T1,(U)		;IN T1 & STATUS.
	JRST	FXERCK		;FALL THRU AGAIN.
FXBSY7:	SETOM	FTXBSY(J)	;DIDN'T FINISH.  FLAG
	PUSHJ	P,SSMTIC	;RESTART OTHERS AND GEN A SM/TIC
	JRST	FXDSM2		;TO US AND GO AGAIN.

;SUBR TO RESTART ALL BUSY-BITTED UNITS. (DESTROYS SOME ACS).
SSTALL:	HRLZ	T1,FTXSMY(J)	;GET BUSY BITS. (ENTRY POINT)
	HLLZS	FTXSMY(J)	;CLEAR THEM.
	SETZ	P3,		;START AT UNIT 0.
SSTAL2:	JFFO	T1,.+2		;UNITS LEFT?
	POPJ	P,		;NO, ALL DONE.
	LSH	T1,1(T2)	;GET RID OF BIT.
	ADDI	P3,(T2)		;UPDATE UNIT.
SSTONE:	HLRZ	T4,KONBMX(J)	;GET BMX ADDR. (ENTRY POINT).
	ADDI	T4,(P3)		;GET UNIT ADDR.
	HRRZI	M,STRTDV	;PUT THE START
	DPB	M,[POINT 4,(T4),^D11] ;CODE.
	HRRZ	M,(T4)		;ADJUST BACK
	SUBI	M,1		;THE ADDR OF
	HRRM	M,(T4)		;THE CMDS.
	AOJA	P3,SSTAL2	;GO TO NEXT UNIT.


;SUBR TO RESTART ALL BUSY-BITTED UNITS. (DESTROYS NO ACS).
SSTAL0:	PUSH	P,P3
	PUSH	P,T1
	PUSH	P,T2
	PUSH	P,T4
	PUSH	P,M
	PUSHJ	P,SSTALL
	POP	P,M
	POP	P,T4
	POP	P,T2
	POP	P,T1
	POP	P,P3
	POPJ	P,


;SUBR TO COMPENSATE FOR GETTING TO THE END OF THE CMD LIST
;ON SENSE WHEN BUSY.  (OTHER CMDS THAN SENSE GET TO START+1).
;
;DESTROYS T2 AND T4.

SAJSNS:	HLRZ	T2,DEVFNJ(F)	;NORMAL
	CAIE	T2,FNPUGF	;SENSE?
	POPJ	P,		;NO, NO SENSE AT ALL.
	HLRZ	T4,KONBMX(J)	;SENSE.  PUT THE
	ADDI	T4,(P3)		;START ADDR +1
	HRRZI	T2,UNICMD+1(T3)	;INTO
	HRRM	T2,(T4)		;THE DEVICE LIST.
	POPJ	P,		;

    ;HERE ON AN ERROR OR HITTING LOAD POINT OR INTERV. REQ.
    ;THE PURPOSE OF THIS ROUTINE IS TO CHECK FOR ERRORS IN THE
    ;PROPER SEQUENCE AND SET UP THE ERROR FLAG IN T2 FOR FXER0.
    ;
    ;EXPECTS THE 1ST STATUS WORD IN T1.
    ;
    ;DESTROYS T1, T4, AND M.

    ;FIRST, FIND THE TYPE OF "ERROR".
FXEROR:	TLNN	T1,CNTLER	;CONTROL ERROR?
	JRST	FXERR2		;NO.
	HRREI	T2,ERCNTL	;CNTRL ERR OR MEM ERR.
	SKIPL	CHNSTB(PG)	;MEMORY ERROR?
	JRST	FXERR1		;NO, REALLY A CONTROL ERROR.
	HRREI	T2,ERMEMR	;YES, REALLY A MEMORY ERROR.
	MOVE	T4,CHNMER(PG)	;SAVE CHNMER IN THE UNIT DB
	MOVEM	T4,FDMEMR(T3)	;ERROR AREA.
FXERR1:	PUSHJ	P,SUBTRM	;JUST IN CASE, PUT TERM IN THE
	JRST	FXER09		;DEV LIST. GO SET IODERR.
FXERR2:	HRREI	T2,ERSELE	;SELECT ERROR OR
	TLNN	T1,SELERR!BUSIN	;BUS IN?
	JRST	FXER00		;NO.
	TLNN	T1,SELERR	;YES, SELECT ERROR?
	HRREI	T2,ERBSIN	;NO, BUS IN.
	JRST	FXER09		;GO SET IODERR.

    ;HERE ALSO LOOK AT SENSE BYTE 0.
FXER00:	MOVE	T4,FTXSTS(J)	;GET BYTE 0.
	TLNN	T4,EQPCHK	;EQUIPMENT CHECK?
	JRST	FXER01		;NO.
	HRREI	T2,EREQCK	;FOR MODEL 2, EQUIP
	HLRZ	M,FTXMCH(J)	;CHECK IS
	TLNN	T1,DEVEND	;ONLY VALID IF
	TLNN	M,MODEL2	;DEV END IS ALSO SET
	JRST	FXER09		;GO SET IODERR.
FXER01:	HRREI	T2,ERBSOU	;BUS
	TLNE	T4,BUSOUT	;OUT CHECK?
	JRST	FXER0		;YES.
	TLNN	T4,INTREQ	;INTERVENTION REQUIRED?
	JRST	FXER02		;NO.
	HRREI	T2,ERINRQ	;YES.
	TLNE	T1,DEVEND	;DEV END?
	JRST	.+3		;YES.
	TLO	S,IOSTBL!HNGFTA	;NO.  FLAG INT REQ FOR UUOCON.
	JRST	FXER09		;(CAN'T CALL HNGSTP HERE).
	HLRZ	M,DEVFNJ(F)	;DEV END.
	CAIN	M,FNPRWU	;REW/UNL?
	JRST	FXSTP0		;YES, OKAY.
	TLO	S,IOSTBL!HNGFTA	;NO, FLAG INT REQ FOR UUOCON.
FXER02:	TLNN	T4,CMDREJ	;COMMAND REJECT?
	JRST	FXER03		;NO.
	TRO	S,IOIMPM	;YES.  SET IOIMPM.
	HRREI	T2,ERCMRJ	;THIS AND NOT CAPABLE ARE THE ONLY FATAL ERRORS
	JRST	FXER0		;THAT DON'T SET IODERR.
FXER03:	HRREI	T2,EROVRN	;OVER-
	TLNE	T4,OVERUN	;RUN?
	JRST	FXER0		;YES.
	LDB	T2,BYKLDP	;NO.  LOAD POINT?
	JUMPE	T2,FXER05	;JUMP ON NO.

    ;HERE ON LOAD POINT.
    ;ONLY BSR/BSF/TC1/ROR ARE INTERESTING.
	HLRZ	M,DEVFNJ(F)	;GET FN IN PROGRESS.
	CAIE	M,FNPBSR	;BSR/BSF GO TO
	CAIN	M,FNPBSF	;NORMAL END OF
	JRST	FXMT0		;MTAPE 1 CMD FNS.
	HRRZ	M,DEVER1(F)	;GET ADDR OF LAST ERROR.
	JUMPE	M,FXER05	;LOAD PT. OKAY IF NOT IN E. P.
	HRRZ	T2,1(U)		;GET CMD STOPPED ON.
	CAILE	T2,(M)		;GOT PAST?
	JRST	FXER05		;YES.  OKAY.
	HLRZ	M,DEVER2(F)	;NO.  GET PHASE OF DC-R RECOVERY.
	JUMPE	M,FXER05	;NONE.
	CAIE	M,2		;DIED IN ROR?
	JRST	FXER04		;NO.
	AOS	FDNREE(T3)	;YES,
	HRLZI	T2,4		;LOG
	IORM	T2,FDERBT(T3)	;INFO
	IORM	T2,DEVSTS(F)	;EVERYWHERE
	MOVEM	T2,FDCNIE(T3)	;AND
	LDB	T2,PIOMOD	;GO
	JRST	FCMRD0		;DIE COMPLETELY.
FXER04:	CAIG	M,13		;IN
	CAIGE	M,11		;TC1?
	JRST	FXER05		;NO.
	JRST	FSLDPT		;YES, ADJUST TAPE AND CONT. WITH NORMAL ERR PROCESSING.

FXER05:	TLNN	T4,DATCHK	;DATA CHECK?
	JRST	FXER06		;NO.
	HLRZ	M,DEVFNJ(F)	;YES. READ/W-WTM/ OR ERG?
	HRREI	T2,ERDCRE	;
	CAIN	M,FNPRED	;DC-READ?
	JRST	FXER0		;YES.
	HRREI	T2,ERDCER	;NO.
	CAIN	M,FNPERG	;ERG FN?
	JRST	FXER0		;YES, ERG ERROR.
	HRRZ	T4,1(U)		;NO, IN
	CAIL	T4,UNICMD(T3)	;ERROR SPACE?
	HRREI	T2,ERWWTM	;NO, W/WTM.
	JRST	FXER0		;YES, ERG.
FXER06:	TLNN	T4,CNVCHK	;DATA CONVERTER CHECK?
	JRST	FXER65		;NO.
	SETZM	DEVER2(F)	;YES, TURN OFF E.P.
	MOVE	T1,(U)		;RESTORE T1
	HLRZ	M,DEVFNJ(F)	;AND M AND GO
	TLNE	T1,LENERR	;PROCESS ODD NO. OF
	JRST	FXNMRW		;WORDS READ.
	HRRZ	T1,1(U)		;GET T1= ADDR OF NEXT LOC.
	LDB	T2,PIOMOD	;GET MODE.
	CAIL	T2,DR		;BUFFERED?
	JRST	FXER62		;NO, D OR DR.
	MOVEI	T1,-1(T1)	;YES, BUFFERED.
	PUSHJ	P,SBUFCT	;CALC.
	JRST	FXRW11		;
FXER62:	HLRZ	T4,(T1)		;D OR DR.  GET NEXT LOC.
	CAIE	T4,HALT		;LAST REQUEST?
	JRST	FXER64		;NO, GO CONTINUE.
	ADDI	T1,1		;YES, PRETEND U POINTED TO
	HRRM	T1,1(U)		;HALT+1.
	SUBI	T1,2		;GO
	JRST	FXRW8		;PROCESS.
FXER64:	HRRZI	T4,(T1)		;GEN SM AND
	PUSHJ	P,SSMTIC	;TIC AND
	JRST	FXDSM2		;GO.
FXER65:	LDB	T4,BYKNTC	;NOT CAPABLE?
	JUMPE	T4,FXER07	;NO.
	TRO	S,IOIMPM	;YES.  SETS IOIMPM.
	HRREI	T2,ERNTCP	;LIKE CMD REJ, DOES NOT
	JRST	FXER0		;SET IODERR, EVEN THO FATAL.
FXER07:	HRLZ	T4,FTXMCH(J)	;GET KONT. MODEL NO.
	TLNE	T4,MODEL2	;MODEL 2?
	JRST	FXER08		;NO.
	HRREI	T2,ERIDBR	;YES, ID BURST CHECK IS POSSIBLE.
	LDB	T4,BYKIDB	;DID IT OCCUR?
	JUMPN	T4,FXER0	;JUMP ON YES.
FXER08:	HRREI	T2,EREQCK	;THIS IS AN EQUIP. CHK.
FXER09:	TRO	S,IODERR	;FATAL ERRS EXCEPT CMD REJ/NOT CAPABLE SET IODERR.

;HERE WITH THE ERROR FLAG IN T2.
FXER0:	MOVSI	T1,700000	;CLEAR THE
	ANDCAM	T1,CHNSTB(PG)	;MEM ERR FLAG.
	HRLZI	T1,400000	;SET
	SKIPL	T4,T2		;UP
	MOVNI	T4,(T2)		;BOTH
	LSH	T1,(T4)		;DEVSTS
	IORM	T1,DEVSTS(F)	;AND
	IORM	T1,FDERBT(T3)	;FDERBT.
	JUMPLE	T2,FXER16	;JUMP ON FATAL.
	TRNE	S,IONRCK	;NON-FATAL, ALLOWED TO RETRY?
	JRST	FXER16		;NO.
    ;HERE ON NON-FATAL.
	HLRZ	M,DEVFNJ(F)	;SPECIAL CASE CHECK FOR WRITE IN
	CAIE	M,FNPWRT	;CASE LOST PLACE ON THE TAPE.
	JRST	FXEREP		;NOT WRITE.
	CAIE	T2,ERIDBR	;WRITE.  ONE OF THE ERRORS THAT
	CAIN	T2,ERDCER	;CAN'T LOSE ITS PLACE?
	JRST	FXEREP		;YES.
	PUSH	P,T1		;NO. SAVE T1 FROM SNOICT.
	PUSHJ	P,SNOICT	;GET T4/COUNT DONE.
	POP	P,T1		;RESTORE T1.
	CAILE	T4,^D12		;DIE IF MAYBE NOISE RECORD.
	JRST	FXEREP		;ELSE CONTINUE.
	TRO	S,IODTER	;CALL THIS A DATA ERROR.


    ;FATAL ERROR.
FXER16:	MOVEM	T1,FDCNIE(T3)	;STORE LAST FATAL ERROR.
	HLRZ	T2,DEVFNJ(F)	;IS THIS ALSO
	HRRZ	T4,DEVER1(F)	;THE 1ST ERROR FOR THIS CMD?
	JUMPE	T4,FXER21	;JUMP ON YES.
	HRRZ	M,1(U)		;STILL
	CAIG	M,(T4)		;MAYBE
	JRST	FXER22		;NO.
FXER21:	MOVEM	T1,FDCNI1(T3)	;LOG 1ST ERROR FOR THIS CMD.
	CAIGE	T2,FNPRED	;READ OR WRITE?
	JRST	FXSTOP		;NO, DONE.
	ADDI	T2,FDNRE1-FNPRED(T3) ;YES,
	AOS	(T2)		;LOG IN FDNRE1 OR FDNWR1
	AOS	DEVSTS(F)	;AND DEVSTS.
	JRST	FXER23		;
FXER22:	CAIGE	T2,FNPRED	;NOT 1ST ERROR.  R/W?
	JRST	FXSTOP		;NO, DONE.
	ADDI	T2,FDNRE1-FNPRED(T3) ;
FXER23:	AOS	2(T2)		;LOG ERROR IN FDNREE OR FDNWRE.
	MOVE	T1,T2		;
	LDB	T2,PIOMOD	;GET MODE.
	CAIN	T1,FDNRE1(T3)	;READ?
	JRST	FCMRD0		;YES, GO TO COMMON END ROUTINE.
	JRST	FCMWRT		;WRITING, GO TO COMMON END ROUTINE.

;ERROR PROCESSING.
;
;IF THIS IS THE FIRST ERROR FOR THIS RECORD/CMD, JUST SET UP THE
;ERROR PROCESSING AND GO.  OTHERWISE, WORRY ABOUT WHERE WE ARE
;IN DC-R RECOVERY, IF SOME OF THE OLD ERROR RECOVERY MUST BE
;RETAINED DUE TO TAPE SPACING, IF WE ARE OUT OF RETRIES, ETC.

FXEREP:	HRRZ	M,DEVER1(F)	;GET OLD ERROR LOC.
	JUMPE	M,FEPFS1	;CURRENT=1ST ERR FOR THIS UNIT CMD LIST?
	HRRZ	T4,1(U)		;NO, CURRENT ERR LOC TO T4.
	CAIG	T4,(M)		;GOT PAST OLD ERROR?
	JRST	FEPOLD		;NO.


    ;HERE ON 1ST NON-FATAL ERROR IN A RECORD.
FEPFS1:	MOVEM	T1,FDCNI1(T3)	;LOG 1ST-NON-FATAL.
	HLRZ	T1,DEVFNJ(F)	;
	CAIGE	T1,FNPRED	;READ/WRITE?
	JRST	.+3		;NO.
	ADDI	T1,FDNRE1-FNPRED(T3) ;YES.  LOG
	AOS	(T1)		;1ST R/W
	AOS	DEVSTS(F)	;ERROR.
	PUSHJ	P,SGDEV1	;POINT DEVER1 TO
	HRRZM	T4,DEVER1(F)	;THE NEXT CMD.
	CAIN	T2,ERDCRE	;DC-R?
	JRST	FEPFS4		;YES.
	SETZM	DEVER2(F)	;CLEAR PHASE AND NO TC.
	HRRZI	T1,OUTERR-1	;SET UP
	MOVEM	T1,DEVOUT(F)	;DEVOUT.
	JRST	FEPNEW		;
FEPFS4:	MOVEI	T1,1		;THERE ON DC-R.
	HRLZM	T1,DEVER2(F)	;DC-R PHASE 1.
	HRRZI	T1,^D40		;SET UP
	MOVEM	T1,DEV40(F)	;THE 40 COUNT.
	HRRZI	T1,INSERR	;SET UP THE
	MOVEM	T1,DEVINS(F)	;INSIDE COUNT.
	HRRZI	T1,NOISE	;SET UP THE
	MOVEM	T1,DEVNOI(F)	;NOISE COUNT.
	HRRZ	T1,1(U)		;SET
	PUSHJ	P,SGPREV	;UP
	MOVEM	T4,UNIDC1(T3)	;UNIDC1.
	PUSHJ	P,SNOISE	;NOISE RECORD?
	JRST	FEPNEW		;NO.
	MOVE	T4,UNIDC1(T3)	;YES, SET UP T4 FOR
	PUSHJ	P,SSMTIC	;GEN SM, TIC.
	JRST	FXDSM2		;GO.
FEPNEW:	PUSHJ	P,SNEW		;GEN AN ERROR PROCEDURE AND
	JRST	FXDSM2		;GO.

    ;HERE ON AN ERROR WHEN WE ARE E.P. ALREADY.
FEPOLD:	HLRZ	T4,DEVER2(F)	;ARE WE ALREADY IN DC-R RECOVERY?
	JUMPN	T4,FEPOL2	;YES, PROBABLY.


    ;HERE WHEN WE ARE NOT ALREADY IN DC-R RECOVERY.
	SOSE	DEVOUT(F)	;ALLOWED ANOTHER OUTSIDE ERR?
	JRST	FEPL06		;YES.
	CAIG	T2,ERBSOU	;NO.  CALL MEM ERR OR BUS OUT
	TROA	S,IODERR	;DEV ERR,
	TRO	S,IODTER	;CALL OTHERS DATA ERRORS.
	MOVEM	T1,FDCNIE(T3)	;LOG FATAL ERROR.
	HLRZ	T1,DEVFNJ(F)	;READ OR
	CAIGE	T1,FNPRED	;WRITE?
	JRST	FXSTOP		;NO.
	ADDI	T1,FDNREE-FNPRED(T3) ;LOG
	AOS	(T1)		;FATAL R/W ERROR.
	MOVE	M,T2		;SAVE ERROR.
	LDB	T2,PIOMOD	;GET MODE.
	CAIE	T1,FNPRED	;READ?
	JRST	FEPL04		;NO.
	CAIE	M,ERBSOU	;YES.  BUS OUT
	JRST	FCMRD0		;REQUIRES ADJUST,
	JRST	FCMRDA		;ELSE NOT ADJUST.
FEPL04:	CAIE	M,ERBSOU	;BUS OUT ERR AND
	JRST	FCMWRT		;NO
	MOVE	T2,(U)		;DEV END
	TLNN	T2,DEVEND	;REQUIRE
	JRST	FXWNP4		;ADJUST (VIA PHASE 4) BEFORE STOP.
	JRST	FCMWRT		;ALL OTHERS JUST STOP.
FEPL06:	CAIN	T2,ERDCRE	;YES, NEW ERROR DC-R?
	JRST	FEPFS4		;YES.  MUST BE IN NORMAL SPACE.
	HRRZ	T4,1(U)		;NO,
	CAILE	T4,UNICMD(T3)	;NEW ERR IN THE ERR SPACE?
	JRST	FEPNEW		;NO, IN NORMAL SPACE.
FEPMOD:	PUSHJ	P,SMOD		;NEW ERROR IS IN ERROR SPACE, SO
	JRST	FXDSM2		;MODIFY ERROR SPACE AND RETRY.

    ;HERE WHEN WE ARE ALREADY IN DC-R RECOVERY.
    ;WE MAY HAVE BEEN IN PHASES 1-7 OR TC1(11,12,13)
    ;OR TC2(21,22,23).

FEPOL2:	CAIG	T4,3		;ALREADY IN PHASES 1,2, OR 3?
	JRST	FEPOL3		;YES.

    ;HERE WHEN DIED IN PHASES 4,5,6,7, OR TC.
	SOSE	DEVINS(F)	;INSIDE/RETRIES LEFT?
	JRST	FEPMOD		;YES, GO SET THEM UP.
	CAIG	T2,ERBSOU	;NO.  CALL MEM ERR OR BUS OUT
	TROA	S,IODERR	;DEV ERR,
	TRO	S,IODTER	;CALL OTHERS DATA ERRORS.
	CAIE	T4,4		;LOG FATAL ERR FOR
	CAIN	T4,5		;TC.  (PHASES
	JRST	.+3		;4 AND 5 HAVE
	MOVEM	T1,FDCNIE(T3)	;ALREADY
	AOS	FDNREE(T3)	;LOGGED.
	LDB	T2,PIOMOD	;GET MODE.
	CAIN	T4,4		;WITH PHASE 4, WIN OR
	JRST	FXWON4		;LOSE MAKES NO DIFFERENCE.
	CAIE	T4,5		;PHASE 5 OR 6 OR 7 OR TC?
	JRST	FCMRD0		;NOT 5, STOP WITH NOTHING IN CURRENT READ.
	PUSHJ	P,SGDEV1	;PHASE 5.
	MOVEI	T1,-1(T4)	;READ EVERYTHING
	CAIL	T2,DR		;ALTHOUGH
	JRST	.+3		;WE CAN NEITHER ADJUST
	PUSHJ	P,SBUFCT	;THE TAPE NOR
	JRST	FXSTOP		;CONTINUE.
	PUSHJ	P,SDMPCT	;DEVDWC
	JRST	FXSTOP		;AND STOP.


    ;HERE WHEN ALREADY IN DC-R RECOVERY PHASES 1,2, OR 3.
FEPOL3:	CAIN	T2,ERDCRE	;NEW=DC-R?
	JRST	FEPOL4		;YES.
	SOSE	DEVINS(F)	;NO.  INSIDE ERROR TRIES LEFT?
	JRST	FEPL33		;YES.
    ;LOST COMPLETELY ON THIS RECORD.
	CAIG	T2,ERBSOU	;CALL MEM ERR OR BUS OUT
	TROA	S,IODERR	;DEV ERR,
	TRO	S,IODTER	;CALL OTHERS DATA ERRORS.
	AOS	FDNREE(T3)	;LOG
	MOVEM	T1,FDCNIE(T3)	;ERROR INFO.
    ;DECIDE IF CALC AND ADJUST, OR JUST CALC.
	MOVEI	M,(T2)		;SAVE ERROR FLAG.
	LDB	T2,PIOMOD	;GET MODE.
	CAIE	T4,1		;PHASE 1?
	JRST	FEPL32		;NO, 2 OR 3.
	CAIE	M,ERBSOU	;YES.  1 AND OVRN OR MEM ERR
	JRST	FCMRDA		;ADJUSTS, ELSE
	JRST	FCMRD0		;CAN'T ADJUST.
FEPL32:	CAIE	M,ERBSOU	;PHASES 2 OR 3 AND OVRN
	JRST	FXWNP6		;ADJUST, ELSE DON'T ADJUST.

    ;SET UP PHASE 7.
FXWNP7:	MOVE	T1,UNIDCR(T3)	;RESTORE READ
	MOVEM	T1,@UNIDC1(T3)	;FORWARDS CMD.
	MOVE	T1,UNIDCN(T3)	;RESTORE
	HRRZ	T4,DEVER1(F)	;THE
	MOVEM	T1,(T4)		;NEXT CMD.
	PUSH	P,J		;REVERSE
	SETO	J,		;THE
	PUSHJ	P,SREVRS	;DATA WORDS.
	POP	P,J		;RESTORE J.
	MOVEI	M,7		;PHASE IS 7.
	MOVEI	T1,1		;ONE TRY ONLY.
	JRST	FXPHG2

    ;RETRY AFTER AN INSIDE ERROR.
FEPL33:	HRRZ	T1,1(U)		;NEW ERROR IN
	CAIG	T1,UNICMD(T3)	;ERROR SPACE?
	JRST	FEPMOD		;YES.
	JRST	FEPNEW		;NO.


    ;HERE WHEN DIED WITH A DC-R, WHEN ALREADY IN PHASES 1,2, OR 3.
FEPOL4:	MOVE	M,T1		;SAVE ERROR BIT.
	PUSHJ	P,SNOISE	;NOISE RECORD?
	JRST	FEPL45		;NO.
	LDB	T2,PIOMOD	;YES.
	JUMPG	T1,FEPL42	;JUMP ON MORE ALLOWED.
	TRO	S,IODTER	;FLAG DATA ERROR.
	AOS	FDNREE(T3)	;LOG
	MOVEM	M,FDCNIE(T3)	;ERROR.
	JRST	FCMRD0		;GO CALC. (CAN'T ADJUST).
FEPL42:	HRRZ	T1,1(U)		;MORE ALLOWED,
	SOJ	T1,.+1		;SO
	PUSHJ	P,SGPREV	;TRY
	PUSHJ	P,SSMTIC	;AGAIN.
	JRST	FXDSM2		;GO.
FEPL45:	SOSN	T1,DEV40(F)	;NOT A NOISE RECORD.  CHECK 40
	JRST	FEPOL5		;COUNT=0?  YES, GO TO CHANGE PHASE OR DIE.
    ;TRY TO EITHER READ AGAIN OR TC.
	HRRZI	T4,INSERR	;SET UP INSIDE
	HRRZM	T4,DEVINS(F)	;ERROR COUNT.
	PUSH	P,T1+1		;IS
	IDIVI	T1,4		;IT
	MOVE	T1,T1+1		;TIME
	POP	P,T1+1		;TO TC?
	JUMPN	T1,FEPNEW	;JUMP ON NO.
	HRRZ	T4,DEVER2(F)	;YES, CAN WE TC?
	JUMPN	T4,FEPNEW	;JUMP ON NO.
	HLRZ	T4,DEVER2(F)	;YES.  CHANGE PHASE
	ADDI	T4,10		;TO
	HRLM	T4,DEVER2(F)	;TC1.
	HRLZI	T1,BSR		;GEN THE
	PUSHJ	P,STC12		;TC1 SEQUENCE.
	JRST	FXDSM2		;GO.

    ;HERE ON END OF PHASES 1,2, OR 3.
FEPOL5:	HLRZ	T1,DEVER2(F)	;END OF
	CAIE	T1,1		;PHASE 1?
	JRST	FEPL51		;NO.
	HLRZ	T2,UNITYP(T3)	;YES.  ROR IS NOT
	TRNE	T2,TRK7		;POSSIBLE FOR 7
	TLNE	S,COMPAT	;TRACK ODD
	JRST	FEPL52		;PARITY.
FEPL51:	AOS	FDNREE(T3)	;COUNT ERROR.
	TRO	S,IODTER	;FLAG DATA ERROR.
	MOVEM	M,FDCNIE(T3)	;LOG FATAL ERROR.
	LDB	T2,PIOMOD	;GET MODE.
	CAIE	T1,1		;PHASE 1?
	JRST	FXWNP7		;GO TO PHASE 7.
	JRST	FCMRD0		;GO TO CALC (NO ADJUSTMENT NEEDED.).
    ;SET UP PHASE 2.
FEPL52:	MOVE	T1,@UNIDC1(T3)	;SET UP
	MOVEM	T1,UNIDCR(T3)	;UNIDCR.
	TLZ	T1,FRCINT	;TURN OFF
	MOVEI	T2,READBK	;PRGINT
	DPB	T2,[POINT 8,T1,^D15] ;IN
	MOVEM	T1,@UNIDC1(T3)	;THE READ (NOW BACKWARDS) CMD.
	HRRZ	T4,DEVER1(F)	;SET
	MOVE	T1,(T4)		;UP
	MOVEM	T1,UNIDCN(T3)	;UNIDCN.
	HRLZI	T1,HALT		;MAKE THE
	MOVEM	T1,(T4)		;"NEXT CMD" = HALT.
	PUSH	P,J		;REVERSE
	SETZ	J,		;THE
	PUSHJ	P,SREVRS	;DWS.
	POP	P,J		;RESTORE J.
	MOVEI	M,2		;SET PHASE=2
	JRST	FXPHGO		;SET UP AND GO.

SUBTTL UTILITY SUBROUTINES.


COMMENT %@@SUBROUTINE SUBSTI
@@PURPOSE SUBR WHICH POINTS THE DEV LIST
ENTRY TO RH(T1), DPBS START, CLRS "PREV WAS WAIT" FLAG, AND
RESETS THE HUNG TIME.
@@ENTRY EXPECTS J=KONT DB, F=DDB, AND P3=UNIT NO.
@@ACCUM DESTROYS T1 AND T2.
@@CALLS FSTHNG.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%

SUBSTI:	HLRZ	T2,KONBMX(J)	;GET POINTER TO
	ADDI	T2,(P3)		;DEV LIST ENTRY.
	HRRM	T1,(T2)		;POINT IT.
	MOVEI	T1,STRTDV	;DPB THE
	DPB	T1,[POINT 4,(T2),^D11] ;START CODE.
	PJRST	FSTHNG		;SET HUNG TIME & CLR PREV=WAIT.


COMMENT %@@SUBROUTINE SUBTRM
@@PURPOSE SUBROUTINE WHICH DPBS TERMINATE
INTO THE DEVICE LIST ENTRY.
@@ENTRY EXPECTS J=KONT DB AND P3=UNIT NO.
@@ACCUM DESTROYS T1 AND T4.
@@RESTRICTIONS @@%


SUBTRM:	HLRZ	T4,KONBMX(J)	;GET POINTER TO
	ADDI	T4,(P3)		;DEV LIST ENTRY.
	MOVEI	T1,TERMDV	;TERMINATE CODE.
	DPB	T1,[POINT 4,(T4),^D11] ;STORE IT.
	POPJ	P,		;RETURN.


COMMENT %@@SUBROUTINE SUBRST/SUBRS0
@@PURPOSE SUBR WHICH SETS UP S, ERR PROCESSING, AND
POINTS THE DEV LIST ENTRY TO UNICMD AND DPBS START INTO IT.
@@ACCUM DESTROYS NO ACS.
@@ENTRY EXPECTS UNIT DB ADDR IN T3 AND F=DDB.
ENTRY POINT SUBRST CLEARS IOBOT; ENTRY POINT SUBRS0 DOES NOT.
@@CALLS FSTHNG.
@@RESTRICTIONS @@%

SUBRST:	TRZ	S,IOBOT
SUBRS0:	TRZ	S,IOIMPM!IODERR!IODTER!IOBKTL!IODEND!IOBOT ;
	PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;AND T2
	PUSH	P,P3		;AND P3.
	TRO	S,IOACT		;SET
	TLNN	S,IOLEND	;BITS
	TRZA	S,IOTEND	;IN
	TRO	S,IOTEND	;S.
	MOVEM	S,DEVIOS(F)	;STORE S.
	HLRZ	T2,UNIKNT(T3)	;SET
	MOVE	T2,CHNACT(T2)	;CHANNEL ACTIVE
	MOVEM	T2,DEVACT(F)	;FLAG WORD.
	HRRZ	T2,UNIKNT(T3)	;T2=KONT DB.
	LDB	P3,[POINT 3,DEVADD(F),^D23]
	HLRZ	T2,KONBMX(T2)
	ADDI	T2,(P3)
	MOVEI	T1,UNICMD(T3)
	HRRM	T1,(T2)		;POINT THE DEV LIST.
	MOVEI	T1,STRTDV	;STORE THE START
	DPB	T1,[POINT 4,(T2),^D11] ;CODE.
	PUSHJ	P,FSTHNG	;SET HUNG TIME & CLR PREV=WAIT.
	SETZM	DEVER1(F)	;CLEAR THE
	SETZM	DEVER2(F)	;E. P.
	POP	P,P3		;RESTORE P3
	POP	P,T2		;AND T2
	POP	P,T1		;AND T1.
	POPJ	P,		;RETURN.


COMMENT %@@SUBROUTINE SUBRG2/SUBRGO/SUBRG1
@@PURPOSE SUBROUTINE WHICH SETS UP S, DEV LIST ENTRY (FOR START
OF NORMAL CMD AREA), AND ERROR PROCESSING, AND THEN GOES.
@@ACCUM DESTROYS T2.
@@ENTRY EXPECTS UNIT DB ADDR IN T3 AND F=DDB.
ENTRY POINT SUBRGO SETS UP AND GOES; ENTRY POINT SUBRG2 DOES THE
SAME, EXCEPT IT DOES NOT CLEAR IOBOT; ENTRY POINT SUBRG1 JUST
GOES.
@@CALLS SUBRS0 AND SUBRST.
@@RESTRICTIONS @@%

SUBRG2:	PUSHJ	P,SUBRS0	;LIKE SUBRST, BUT DON'T CLR IOBOT.
	JRST	SUBRG1
SUBRGO:	PUSHJ	P,SUBRST	;SETS UP S AND THE DEV LIST ENTRY.
SUBRG1:	HLRZ	T2,UNIKNT(T3)	;T2=CHAN DB.
	XCT	CHNIIE(T2)	;START
	XCT	CHNGO(T2)	;UP AND
	POPJ	P,		;RETURN.

COMMENT %@@SUBROUTINE FSTHNG
@@PURPOSE SUBROUTINE TO CLEAR THE "PREVIOUS WAS WAIT" HUNG
TIME FLAG (RH(UNITYP)) AND RESET THE HUNG TIME.
@@ACCUM DESTROYS NO ACS.
@@ENTRY EXPECTS T3=UNIT DB ADDR AND F=DDB.
@@CALLS SETHNG.
@@RESTRICTIONS CALLED AT BOTH UUO AND INTERRUPT LEVEL. @@%

FSTHNG:	HLLZS	UNITYP(T3)	;CLEAR THE PREV WAS WAIT FLAG.
	PJRST	SETHNG		;RESET THE HUNG TIME.



COMMENT %@@SUBROUTINE FHGSTP
@@PURPOSE SUBROUTINE TO SAVE SOME ACS AND CALL HNGSTP (THE
DEVICE NOT READY MESSAGE SENDER.).
@@ENTRY EXPECTS F=DDB.
@@ACCUM DESTROYS T4.
@@RESTRICTIONS CALLED AT UUO LEVEL. @@%

FHGSTP:	PUSH	P,U
	PUSH	P,PG		;
	PUSH	P,W
	PUSH	P,M
	PUSH	P,T1
	PUSH	P,T2
	PUSH	P,T3
	PUSHJ	P,HNGSTP
	POP	P,T3
	POP	P,T2
	POP	P,T1
	POP	P,M
	POP	P,W
	POP	P,PG
	POP	P,U
	POPJ	P,

COMMENT %@@SUBROUTINE SUBRSN
@@PURPOSE SUBR TO SET UP A SENSE IN THE NORMAL CMD SPACE.
@@ENTRY EXPECTS UNIT DB ADDR IN T3 AND F=DDB.
@@ACCUM DESTROYS NO ACS.
@@RESTRICTIONS THIS IS A "UUO TYPE" SENSE INTO THE NORMAL
COMMAND AREA.  IT IS NOT NOT NOT THE ERROR SENSE INTO THE
KONTROLLER DB AREA.  IT IS DONE BY UGETF, INITIALIZATION, ETC. @@%

SUBRSN:	PUSH	P,T2		;SAVE T2.
	MOVE	T2,DEVADD(F)	;BUILD
	TLO	T2,SENSE	;SENSE CMD.
	MOVEM	T2,UNICMD(T3)	;STORE IT.
	MOVEI	T2,UNICMD+3(T3) ;BUILD
	TLO	T2,(BYTE (1)1(11)-^D24) ;DATA WORD.
	MOVEM	T2,UNICMD+1(T3)	;STORE IT.
	HRLZI	T2,HALT		;STORE
	MOVEM	T2,UNICMD+2(T3)	;HALT CMD.
	POP	P,T2		;RESTORE T2.
	POPJ	P,		;RETURN.

COMMENT %@@SUBROUTINE SUBRSM
@@PURPOSE SUBR TO GEN A SM CMD IN UNICMD.
CMD HAS CMD CHAIN AND EXECUTE AND DEVICE ADDRESS.
SUBRSM LOOKS AT THE DENSITY AND PARITY FIELDS IN THE STATUS
WORD PLUS THE DENSITY AND 7 TRACK BITS IN UNITYP.
@@ENTRY EXPECTS S=DEVIOS, T3=UNI DB, AND F=DDB.
@@@ACCUM DESTROYS T1.
@@EXIT SEE PURPOSE.
@@RESTRICTIONS CALLED AT UUO LEVEL. @@%
;
;DESTROYS AC T1.
;EXPECTS UNIT DB ADDR IN T3 AND F=DDB.
;
;IF TWO DENSITIES ARE AVAILABLE AND THE USER ASKS FOR
;MEDIUM DENSITY, LOW DENSITY IS RETURNED.

SUBSTB:	XWD MS9T8,MS7T2
	XWD MS9T16,MS7T5
	XWD MS9T62,MS7T8

SUBST1:	XWD MS7TE2,MS7TO2
	XWD MS7TE5,MS7TO5
	XWD MS7TE8,MS7TO8


SUBRSM:	PUSH	P,T2		;SAVE T2.
	LDB	T1,[POINT 2,S,^D28] ;GET DENSITY ASKED.
	JUMPN	T1,.+2		;STANDARD DENSITY=
	MOVEI	T1,3		;HIGHEST DENSITY.
	HLLZ	T2,UNITYP(T3)	;GET TRK/DENS AVAIL.
	TLNN	T2,TRK7		;7 OR 9 TRACK?
	JRST	SUBSM4

    ;7 TRACK (800/556 OR 800/556/200.)
	CAIG	T1,1		;IF ASK LOW
	TLNE	T2,DS200	;BUT NO 200
	JRST	.+2		;THEN
	MOVEI	T1,2		;GET 556.
	HRLZ	T2,SUBSTB-1(T1)	;NORMAL 7 TRACK
	TLNN	S,COMPAT	;MODE?
	JRST	SUBSM2		;YES.
	HRLZ	T2,SUBST1-1(T1)	;NO.  EVEN OR
	TRNE	S,IOPAR		;ODD
	HLLZ	T2,SUBST1-1(T1)	;PARITY.
SUBSM2:	MOVE	T1,T2		;MOVE IT TO T1.
SUBSOT:	TDO	T1,DEVADD(F)	;AND
	MOVEM	T1,UNICMD(T3)	;STORE.
	POP	P,T2		;RESTORE T2 AND
	POPJ	P,		;RETURN.

    ;9 TRACK(6250 OR 6250/1600 OR 1600 OR 1600/800.).
SUBSM4:	CAIE	T1,1		;ONLY 1 AND 2 SINCE NO
	SUBI	T1,1		;9 TRK HAS >2 DENS.
	TLNN	T2,DS6250
	JRST	SUBSM6		;GO TO 1600 OR 1600/800.
	TLNN	T2,DS1600	;HERE ON 6250 OR 6250/1600.
	MOVEI	T1,2		;PLAIN 6250.
SUBSMT:	HLLZ	T1,SUBSTB(T1)	;SET UP AND
	JRST	SUBSOT		;RETURN.
SUBSM6:	TLNN	T2,DS800	;HERE ON 1600 OR 1600/800.
	MOVEI	T1,2		;PLAIN 1600.
	SOJA	T1,SUBSMT	;SET UP AND RETURN.

COMMENT %@@SUBROUTINE SCOMBL
@@PURPOSE SUBR TO GENERATE CMDS FROM THE DDB CMD BUFFER INTO
THE UNIT CMD AREA.
@@ENTRY EXPECTS UNIT DB ADDR IN T3 AND F=DDB.
@@ACCUM DESTROYS T1, T2, AND U.
@@FUNCTION GOES TO ONE OF 3 SECTIONS DEPENDING ON WHETHER THE
MODE IS D, B, OR DR.  D MODE, UNLIKE B AND DR, CAN ALWAYS
PROCESS A COMPLETE DDB LIST IN ONE UNIT COMMAND AREA.  D MODE
IS THEREFORE STRAIGHTFORWARD.  B MODE CALCS HOW MANY SPACES IN
THE UNIT CMD LIST IT NEEDS FOR THE NEXT BUFFER;  IF IT CAN FIT
IT IN, IT DOES AND THEN LOOKS AT THE NEXT BUFFER;  IF IT
CAN'T FIT IT IN, IT SETS UP A CONTINUATION WORD IN DEVCNT.
FRCINT (CAUSE A PROGRAM INTERRUPT) IS SET FOR EACH B CMD SO
THAT THE BUFFERS CAN BE PROCESSED INDIVIDUALLY.
DR SPINS OFF 200 WORD OR LESS RECORDS FROM THE DDB LIST
INTO THE UNIT CMD LIST;  IF IT HAS EXHAUSTED THE UNIT CMD
LIST BEFORE THE DDB LIST IS DONE, IT STORES CONTINATION
INFORMATION IN DEVCNT AND LH(DEVUDB).
(AT ENTRY, DEVCNT<>0 IS THE FLAG TO B AND DR MODES THAT THEY
HAVE TO START IN THE MIDDLE OF THE DDB LIST.)

ALL 3 MODES GO TO SCMFIN TO GEN A HALT CMD, SET UP S, ETC.,
AND THEN SCOMBL RETURNS.

IBM 9 TRACK BYTE ADJUSTMENTS ARE AS FOLLOWS: (A) BUFFERED--
SUBTRACTED FROM EACH BUFFER BYTE COUNT, (B) DUMP--SUBTRACTED
FROM EACH "DUMP RECORD" COUNT, AND (C) DUMP RECORDS--SUBTRACTED
FROM EACH RECORD COUNT.
@@EXIT SKIP RETURNS IF BUFFERED MODE AND THE CONT OF DATA
TO TRANSFER IS 0.
@@CALLS SUBRSM, STOCMD, STODTS, SDTCAL, AND SUBRST.
@@ERRORS CERTAIN ILLEGAL DDB LISTS (TOO LARGE A BUFFER, A
ZERO DATA COUNT FOR D OR DR MODES) CAUSE A STOPCD.
@@RESTRICTIONS CALLED AT BOTH UUO AND INTERRUPT LEVEL. @@%

;DEVER1 AND DEVNOI ARE USED FOR TEMP STORAGE HERE ONLY.


SCOMBL:	PUSHJ	P,SUBRSM	;GEN SM IN UNICMD.
	MOVEI	T2,UNICMD+1(T3)	;T2=DEST PNTR.
	LDB	U,PIOMOD	;GET MODE.
	PUSH	P,T4		;SAVE T4
	PUSH	P,M		;AND M
	PUSH	P,PG		;AND PG.
	CAIN	U,DR		;DR GOES
	JRST	SCOMDR		;TO SCOMDR.
	CAIE	U,D		;BUFFERED GOES
	JRST	SCOMBF		;TO SCOMBF.

    ;DUMP.
	MOVE	T1,DEVCLS(F)	;TI=ORIGIN PNTR.
	SKIPN	(T1)		;MUST BE
	STOPCD			;SOMETHING.
	PUSHJ	P,STOCMD	;GEN A R/W CMD INTO T2.
	PUSHJ	P,STODTS	;GEN THE DATA WORDS.
	JRST	SCMFIN		;GO FINISH UP.

    ;BUFFERED.
SCOMBF:	SKIPE	T1,DEVCNT(F)	;CONTINUING?
	JRST	SCMBF1		;YES.
SCMBF0:	MOVE	T1,DEVCLS(F)	;NOT CONTINUING.
	SKIPN	(T1)		;MUST BE
	STOPCD			;SOMETHING THE FIRST TIME.
SCMBF1:	PUSHJ	P,SDTCAL	;U=# DATA WORDS+2
	JUMPE	U,SCMBF3	;NEEDED.
	CAIL	U,FTCMLN	;FOR THIS BUFFER.
	 STOPCD (.,JOB,MTATMW,,<Too many data words>) ;;SCMBF1+3
	ADDI	U,(T2)		;
	CAIG	U,UNIDON(T3)	;ROOM?
	JRST	SCMBF2		;YES.
	MOVEM	T1,DEVCNT(F)	;NO.  SET UP CONTINUATION
	JRST	SCMFIN		;AND GO FINISH UP.
SCMBF2:	PUSHJ	P,STOCMD	;GEN A R/W CMD TO (T2).
	PUSHJ	P,STODTS	;GEN ALL THE DATA WORDS.
SCMBF3:	MOVEI	T1,1(T1)	;AT EO BUFFER.  AT EO
	SKIPE	(T1)		;LIST?
	JRST	SCMBF1		;NO.
	CAIE	T2,UNICMD+1(T3)	;YES--ANYTHING TO DO?
	JRST	SCMFN0		;YES.
	JRST	SCMFN2		;NO.

    ;DUMP RECORDS.
SCOMDR:	SKIPN	M,DEVCNT(F)	;CONTINUING?
	JRST	SCMDR1		;NO.
	HLRZ	T1,DEVUDB(F)	;YES.  SET UP T1
	JRST	SCMDR2		;AND GO.
SCMDR1:	MOVE	T1,DEVCLS(F)	;
	SKIPN	M,(T1)		;NOT CONTINUING.  MUST BE SOMETHING
	 STOPCD			;THE FIRST TIME.;;SCMDR1+2
SCMDR2:	MOVNI	U,^D128		;SET UP
	TLNN	S,COMPAT	;THE "ALMOST 200
	JRST	SCMD25		;WORD"
	ASH	U,2		;SIZE
	HRRZ	T4,DEVFNJ(F)	;IN
	ADDI	U,(T4)		;DEVNOI.
SCMD25:	MOVEM	U,DEVNOI(F)	;
SCMDR3:	LDB	T4,[POINT ^D14,M,^D13] ;GET THE
	TDO	T4,MSKCTD	;COUNT FROM THIS
	TLNE	S,COMPAT	;DDB
	ASH	T4,2		;WORD.
	TLZ	M,MSKMMD	;GET THE CORRECT
	ADDI	M,1		;MEM ADDR ALSO.
SCMDR4:	MOVE	U,DEVNOI(F)	;RECORD SIZE=ABOUT 200 WORDS.
	CAIGE	T2,UNIDON-4(T3)	;ROOM FOR SM,R/W,D,D,HALT?
	JRST	SCMDR6		;YES.
	TLNE	S,COMPAT	;NO, GET WORD COUNT OR
	ASH	T4,-2		;BYTE COUNT.
	SUBI	M,1		;SET
	DPB	T4,[POINT ^D14,M,^D13] ;UP
	MOVEM	M,DEVCNT(F)	;FOR
	HRLM	T1,DEVUDB(F)	;CONTINUATION.
	JRST	SCMFIN		;GO GEN A HALT CMD.
SCMDR6:	HRRZM	T2,DEVER1(F)	;SAVE CMD LOC.
	PUSHJ	P,STOCMD	;GEN A READ CMD.
SCMDR7:	CAMG	T4,U		;COUNT>=REST OF RECORD?
	JRST	SCMDR8		;YES.
	MOVE	PG,T4		;SET PG UP WITH COUNT
	TLNE	S,COMPAT	;POSSIBLY THIS
	SKIPE	1(T1)		;IS A
	JRST	.+3		;SHORT
	HRRZ	PG,DEVFNJ(F)	;LAST
	ADD	PG,T4		;RECORD.
	PUSHJ	P,STODAT	;FOR STODAT.
	MOVEI	T1,1(T1)	;AT END OF
	SKIPE	M,(T1)		;LIST?
	JRST	SCMD75		;NO.
	HRLZI	PG,LASDAT	;YES.  TURN OFF
	IORM	PG,-1(T2)	;DATA CHAINING.
	JRST	SCMFN0
SCMD75:	SUB	U,T4		;NO, CORRECT "RECORD SIZE".
	LDB	T4,[POINT ^D14,M,^D13] ;SET
	TDO	T4,MSKCTD	;UP
	TLNE	S,COMPAT	;THE
	ASH	T4,2		;COUNT.
	TLZ	M,MSKMMD	;GET CORRECT
	ADDI	M,1		;MEM ADDR.
	JRST	SCMDR7		;GO GEN ANOTHER DATA WORD.
SCMDR8:	MOVE	PG,U		;SET PG UP WITH CURRENT
	PUSHJ	P,STODAT	;FOR STODAT.
	HRLZI	PG,LASDAT	;TURN OFF
	IORM	PG,-1(T2)	;DATA CHAINING.
	TLNN	S,COMPAT	;SET UP U TO
	JRST	.+3		;ADJUST
	HRRZ	PG,DEVFNJ(F)	;T4 AND
	SUBI	U,(PG)		;M.
	SUB	T4,U		;ADJUST COUNT.
	JUMPE	T4,SCMD84	;JUMP ON EXACTLY DONE.
	TLNE	S,COMPAT	;ADJUST THE
	ASH	U,-2		;MEM ADDR FOR WHAT
	SUB	M,U		;WE JUST PROCESSED.
	JRST	SCMDR4		;GO GEN ANOTHER CMD.
SCMD84:	MOVEI	T1,1(T1)	;INCREMENT ORIGIN PNTR.
	SKIPE	M,(T1)		;EOR (AND EOL) ?
	JRST	SCMDR3		;GO GEN ANOTHER CMD.


SCMFN0:	SETZM	DEVCNT(F)	;CLEAR CONTINUATION.
SCMFIN:	HRLZI	PG,HALT		;HALT
	MOVEM	PG,(T2)		;CMD.
	PUSHJ	P,SUBRST		;SET UP S, HUNG TIME, DEV LIST AND E.P.
SCMFN2:	POP	P,PG		;RESTORE PG.
	POP	P,M		;AND M
	POP	P,T4		;AND T4.
	CAIN	T2,UNICMD+1(T3)	;BUFFERED, NOTHING TO DO?
	AOS	(P)		;YES.
	POPJ	P,		;RETURN.

COMMENT %@@SUBROUTINE STOCMD
@@PURPOSE SUBR TO STORE A READ FORWARDS OR A WRITE CMD IN (T2).
CMD HAS CMD CHAIN AND MODE.  CMD HAS PRGINT, IF BUFFERED.
T2 IS INCREMENTED BY ONE ON EXIT.
@@ENTRY EXPECTS UNIT DB ADDR IN T3, S=DEVIOS, AND F=DDB.
@@ACCUM NO ACS ARE DESTROYED.
@@FUNCTION  SEE PURPOSE.  INFO IN S AND DEVADD IS USED TO
BUILD THE COMMAND.
@@EXIT SEE PURPOSE.
@@RESTRICTIONS CALLED AT BOTH THE UUO AND INTERRUPT LEVELS. @@%


STOCMD:	PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;AND T2.
	MOVE	T1,DEVADD(F)	;T1 TEMPORARILY HOLDS THE CMD.
	LDB	T2,PIOMOD	;GET MODE.
	CAIGE	T2,DR		;SET PRGM INTRPT FLAG
	TLO	T1,FRCINT	;FOR BUFFERED MODE.

    ;SET MODE.
	HLRZ	T2,UNITYP(T3)	;GET INFO.
	TRNN	T2,TRK7		;7 TRACK?
	JRST	STOCM4		;NO.
	TLNN	S,COMPAT	;YES.  SPECIAL MODE?
	TLOA	T1,MODE7	;NO.
	TLO	T1,MODE7I	;YES.
	JRST	STOCM6		;
STOCM4:	TLNN	S,COMPAT	;9 TRACK.  IBM?
	TLOA	T1,MODE9D	;NO.  DEC.
	TLO	T1,MODE9I	;YES. IBM.

STOCM6:	TLNN	S,IO		;WRITING?
	TLOA	T1,READFW	;NO. READ CMD.
	TLO	T1,WRITE	;YES. WRITE CMD.
	POP	P,T2		;RESTORE T2.
	MOVEM	T1,(T2)		;STORE CMD.
	AOJ	T2,.+1		;BUMP T2.
	POP	P,T1		;RESTORE T1.
	POPJ	P,		;RETURN.


COMMENT %@@SUBROUTINE STODAT
@@PURPOSE SUBR TO STORE A DATA WORD IN (T2).
DATA CHAINS.
@@ENTRY EXPECTS PG HAS WORD OR BYTE COUNT AND M HAS MEMORY ADDRESS.
@@ACCUM DESTROYS NO ACS.
@@FUNCTION BUILDS A DATA WORD IN (T2) FROM THE INFORMATION
IN PG AND M.  INCS T2.
@@EXIT SEE FUNCTION.
T2 IS INCREMENTED BY ONE ON EXIT.
@@RESTRICTIONS CALLED AT BOTH UUO AND INTERRUPT LEVEL. @@%


STODAT:	TLZ	M,MSKMMU	;JUST IN CASE.
	MOVEM	M,(T2)		;STORE MEM ADDR.
	CAME	PG,DATASZ
	DPB	PG,[POINT ^D11,(T2),^D11]
	AOJ	T2,.+1
	POPJ	P,


COMMENT %@@SUBROUTINE STODTS
@@PURPOSE SUBR TO GENERATE DATA WORDS FROM THE DDB WORDS
STARTING AT (T1) AND CONTINUING UNTIL A 0 DDB WORD IS HIT.
@@ENTRY EXPECTS T1=ORIGIN PNTR, T2=DEST PNTR, F=DDB, AND T3=UNIT DB.
@@ACCUM DESTROYS ACS T4, PG, AND M.
@@EXIT ON EXIT T1 POINTS TO THE 0 DDB WORD AND T2 POINTS TO THE NEXT
DESTINATION.
@@CALLS STODAT.
@@RESTRICTIONS CALLED AT BOTH UUO AND INTERRUPT LEVELS @@%

STODTS:	MOVE	M,(T1)		;SET UP MEM ADDR.
STODS1:	LDB	T4,[POINT ^D14,M,^D13] ;GET THE
	JUMPE	T4,STOD15	;COUNT
	TDO	T4,MSKCTD	;OF WORDS
	TLNE	S,COMPAT	;OR
	ASH	T4,2		;BYTES.
STOD15:	TLZ	M,MSKMMD	;POINT TO CORRECT
	ADDI	M,1		;MEM ADDR.
	TLNE	S,COMPAT	;LAST DDB WORD IN
	SKIPE	1(T1)		;IBM 9 TRACK?
	JRST	STODS2		;NO.
	HRRZ	PG,DEVFNJ(F)	;YES,
	ADDI	T4,(PG)		;ADJUST COUNT.
STODS2:	CAML	T4,DATASZ	;COUNT > COUNT FIELD?
	JRST	STODS4		;NO.
	MOVE	PG,DATASZ	;YES.  DO MAXIMUM.
	PUSHJ	P,STODAT	;GEN THE DATA WORD.
	SUB	T4,PG		;ADJUST THE COUNT.
	TLNE	S,COMPAT	;ADJUST
	ASH	PG,-2		;THE MEM
	SUB	M,PG		;ADDR.
	JRST	STODS2		;GO GEN ANOTHER DATA WORD.
STODS4:	MOVE	PG,T4		;HERE ON END OF DDB WORD.
	PUSHJ	P,STODAT	;GEN THE DATA WORD.
	MOVEI	T1,1(T1)	;GET NEXT DDB WORD, AND
	SKIPE	M,(T1)		;IF IT IS <> 0,
	JRST	STODS1		;CONTINUE.
	HRLZI	PG,LASDAT	;DONE.  TURN OFF DATA
	IORM	PG,-1(T2)	;CHAINING IN LAST DATA WORD.
	POPJ	P,


COMMENT %@@SUBROUTINE SDTCAL
@@PURPOSE SUBR TO FIND OUT HOW MANY DATA WORDS WE NEED
FOR THIS BUFFER.  RETURN ANSWER+2 (R/W AND HALT) IN U.
THIS IS A LOOK AHEAD ROUTINE TO SEE IF WE CAN FIT THIS
BUFFER INTO THE SPACE LEFT IN OUR COMMAND AREA.
@@ENTRY EXPECTS T1 = ADDR OF THE 1ST DDB DATA LOC WE ARE INTERESTED IN.
@@ACCUM DESTROYS AC T4.
@@EXIT SEE PURPOSE.
@@ERRORS IF ONE OF THE DDB WORDS HAS A 0 COUNT FIELD, THE
NEXT DDB WORD MUST BE 0, ELSE STOPCD.
@@RESTRICTIONS CALLED AT BOTH UUO AND INTERRUPT LEVELS. @@%

SDTCAL:	PUSH	P,T1		;SAVE T1
	PUSH	P,PG		;AND PG.
	SETZ	U,		;U HOLDS THE COUNT.
SDTCL1:	LDB	T4,[POINT ^D14,(T1),^D13] ;GET THE COUNT
	JUMPN	T4,SDTCL2	;FROM ONE DDB WORD.
	AOJ	T1,.+1		;IF 0, CAN
	SKIPE	(T1)		;ONLY BE ONE
	 STOPCD			;ENTRY FOR      ;;SDTCL1+4
	JRST	SDTCL4		;THIS BUFFER.
SDTCL2:	TDO	T4,MSKCTD	;CORRECT FORM.
	TLNN	S,COMPAT	;BYTE MODE?
	JRST	SDTCL3		;NO.
	ASH	T4,2		;YES, CORRECT COUNT.
	SKIPE	1(T1)		;IF
	JRST	SDTCL3		;LAST,
	HRRZ	PG,DEVFNJ(F)	;ADJUST
	ADDI	T4,(PG)		;THE COUNT.
SDTCL3:	ADD	T4,DATASZ	;ROUND UP
	ADDI	T4,1		;A LITTLE.
	PUSH	P,T4+1		;SAVE T4+1.
	IDIV	T4,DATASZ	;CONVERT TO DW'S.
	POP	P,T4+1		;RESTORE T4+1.
	ADD	U,T4		;ADD INTO U.
	MOVEI	T1,1(T1)	;LOOK AT NEXT DDB WORD.
	SKIPE	(T1)		;LAST?
	JRST	SDTCL1		;NO, CONTINUE.
	ADDI	U,2		;ADD IN R/W AND HALT.
SDTCL4:	POP	P,PG		;RESTORE PG.
	POP	P,T1		;AND T1.
	POPJ	P,

COMMENT %@@SUBROUTINE SGPREV
@@PURPOSE SUBR TO GET THE ADDR OF THE PREVIOUS READ CMD INTO T4.
THIS SUBR STARTS AT THE TOP OF THE COMMAND LIST AND WORKS
DOWN, SINCE WE CAN'T WORK UP.
@@ENTRY EXPECTS T3=UNIT DB AND T1=ADDR OF PRESENT CMD OR BETWEEN
PRESENT AND PREVIOUS.
(T1 MUST POINT TO A LOCATION > 1ST CMD).
@@ACCUM DESTROYS NO ACS.
@@EXIT SEE PURPOSE.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL.  @@%

;The SA10 reports the address of the COUNT,,ADDR word that was being
;processed when the error occurred.  There may have been several other
;COUNT,,ADDR words between this one and the READ/WRITE command that this
;word belongs to.  Search for the READ/WRITE command.

SGPREV:	PUSH	P,T2		;SAVE T2.
				;T1 has pointer from RH of location 302
	MOVEI	T2,UNICMD+1(T3)	;Skip set-density, get addr of read cmd
	MOVE	T4,T2		;Use top of command list if FTACFC
	CAIL	T1,UNICMD(T3)	;Does it point before the command list
	CAILE	T1,UNIDON(T3)	; or after the end of the command list?
	 STOPCD	(SGPRV4,INFO,FTACFC,,<FTA error - Cannot Find Command>);;SGPREV+3
SGPRV2:	SKIPN	(T2)		;SKIP 0
	AOJA	T2,.-1		;FILLERS.
	HRRZI	T4,(T2)		;SAVE CURRENT.
	AOJ	T2,.+1		;POINT TO 1ST DATA WORD.
SGPRV3:	SKIPL	(T2)		;LAST DATA WORD IS < 0.
	AOJA	T2,SGPRV3	;WALK DOWN THE DATA WORDS.
	CAILE	T1,1(T2)	;GONE PAST CMD?
	AOJA	T2,SGPRV2	;T2=ADDR OF NEXT CMD.
SGPRV4:	POP	P,T2		;RESTORE T2.
	POPJ	P,		;RETURN.


COMMENT %@@SUBROUTINE SGDEV1
@@PURPOSE SUBR TO GET THE "ADDRESS OF THE CMD WE STOPPED ON WITH
AN ERROR" INTO T4.
FOR NON-READ/NON-WRITE, ADDR=ADDR OF FAILED CMD+1.
FOR READ/WRITE, ADDR=ADDR OF NEXT READ/WRITE CMD.
@@ENTRY EXPECTS T3=UNIT DB AND U=4 WORD AREA ADDR+1.
@@ACCUM DESTROYS NO ACS.
@@EXIT SEE PURPOSE.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%

SGDEV1:	PUSH	P,T1		;SAVE T1.
	HRRZ	T4,1(U)		;T4=ADDR OF NEXT CMD.
	HLRZ	T1,DEVFNJ(F)	;GET FN IN PROGRESS.
	CAILE	T4,UNICMD+1(T3)	;IN ERROR SPACE
	CAIGE	T1,FNPRED	;OR NOT R/W?
	JRST	SGDEV5		;YES.
	MOVEI	T1,UNICMD+1(T3)	;R/W.  T1=1ST CMD ADDR.
SGDEV2:	SKIPN	(T1)		;SKIP 0
	AOJA	T1,.-1		;FILLERS.
	AOJ	T1,.+1		;T1=1ST DATA WORD ADDR.
SGDEV3:	SKIPL	(T1)		;LAST DATA WORD IS < 0.
	AOJA	T1,SGDEV3	;TRY AGAIN.
	AOJ	T1,.+1		;T1=ADDR OF NEXT R/W CMD.
	CAIGE	T1,(T4)		;GOT PAST ERROR?
	JRST	SGDEV2		;NO.
	HRRZI	T4,(T1)		;GOT PAST ERROR.  T4=ADDR.
SGDEV5:	POP	P,T1		;RESTORE T1.
	POPJ	P,		;AND RETURN.

COMMENT %@@SUBROUTINE SWRDRD
@@PURPOSE SUBR WHICH RETURNS IN T4 THE SUM OF THE WORD/BYTE
COUNTS BETWEEN THE DATA WORD POINTED TO BY (T1) AND THE PREVIOUS
READ CMD INCLUSIVE.  ON EXIT, T1 POINTS TO THE PREVIOUS READ
CMD.
@@ENTRY EXPECTS T3=UNIT DB AND T1 AS STATED IN PURPOSE.
(T1 MUST POINT TO A LOC > 1ST CMD.).
@@ACCUM DESTROYS NO ACS.
@@EXIT SEE PURPOSE.
@@CALLS SGPREV.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%

SWRDRD:	PUSH	P,T2		;SAVE T2
	PUSH	P,M		;AND M.
	PUSHJ	P,SGPREV	;GET T4=ADDR OF PREVIOUS CMD.
	PUSH	P,T4		;STORE IT.
	MOVEI	M,1(T4)		;M HAS ADDR OF 1ST DATA WORD.
	SETZ	T4,		;T4 HOLDS COUNT.
SWRDR1:	CAMLE	M,T1		;MORE DATA WORDS TO LOOK AT?
	JRST	SWRDR5		;
	LDB	T2,[POINT ^D11,(M),^D11] ;GET A COUNT.
	TDO	T2,MSKCTU	;MAKE A CORRECT NO.
	SUB	T4,T2		;ADD IT INTO THE COUNT.
	AOJA	M,SWRDR1
SWRDR5:	POP	P,T1		;YES.  GET ADDR.
	POP	P,M		;RESTORE M
	POP	P,T2		;AND T2.
	POPJ	P,		;RETURN.


COMMENT %@@SUBROUTINE SDMPCT
@@PURPOSE SUBR WHICH RETURNS IN DEVBWC THE SUM OF THE WORD/BYTE
COUNTS BETWEEN THE DATA WORD POINTED TO BY (T1) AND THE
BEGINNING OF THE UNIT CMD LIST INCLUSIVELY.
@@ENTRY EXPECTS T3=UNIT DB AND T1 AS STATED UNDER PURPOSE.
(T1 MUST POINT TO A LOC > 1ST CMD.).
@@ACCUM DESTROYS NO ACS.
@@EXIT SEE PURPOSE.
@@CALLS SWRDRD.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL.  @@%

SDMPCT:	PUSH	P,M		;SAVE M.
	SETZ	M,		;M HOLDS COUNT.
SDMPC2:	CAIG	T1,UNICMD+1(T3)	;AT B OF LIST?
	JRST	SDMPC4		;YES.
	PUSHJ	P,SWRDRD	;NO.  GET NEXT COUNT.
	ADD	M,T4		;ADD IT IN.
	SKIPE	-1(T1)		;Done if no previous command
	SOJA	T1,SDMPC2	;SEE IF CONTINUE.
SDMPC4:	ADDM	M,DEVDWC(F)	;DONE.  STORE COUNT IN DEVDWC.
	POP	P,M		;RESTORE M.
	POPJ	P,		;RETURN.

COMMENT %@@SUBROUTINE SBUFCT
@@PURPOSE SUBR WHICH SUMS THE WORD/BYTE COUNTS BETWEEN THE DATA
WORD POINTED TO BY T1 AND THE PREVIOUS READ CMD, INCLUSIVELY,
AND STORES IT IN DEVBWC.  ALSO INCREMENTS DEVABC.
@@ENTRY EXPECTS T3=UNIT DB, T1=ADDR OF A DATA WORD, F=DDB, AND
S=DEVIOS.
@@ACCUM DESTROYS NO ACS.
@@EXIT SEE PURPOSE.
@@CALLS SWRDRD AND SBUFST.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%

SBUFCT:	PUSH	P,T4
	PUSH	P,T1
	PUSHJ	P,SWRDRD	;GET COUNT.
	PUSHJ	P,SBUFST	;
	POP	P,T1
	POP	P,T4
	POPJ	P,


COMMENT %@@SUBROUTINE SBUFZR
@@PURPOSE SUBR WHICH "STORES" A ZERO COUNT FOR THE CURRENT
BUFFER READ.
@@ENTRY EXPECTS F=DDB.
@@ACCUM DESTROYS NO ACS.
@@FUNCTION STORES 0 VIA DEVBWC. INCS DEVABC.
@@EXIT SEE FUNCTION.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%

SBUFZR:	PUSH	P,T1
	PUSHJ	P,BDIO		;DEC PGYDIOS.
	HRRZ	T1,DEVBWC(F)
	SETZM	(T1)
	AOJ	T1,.+1
	HRRM	T1,DEVBWC(F)
	AOS	DEVABC(F)
	POP	P,T1
	POPJ	P,


COMMENT %@@SUBROUTINE SBUFST
@@PURPOSE SUBR WHICH "STORES" (T4) FOR THE CURRENT BUFFER
READ.
@@ENTRY EXPECTS F=DDB AND S=DEVIOS.
@@ACCUM DESTROYS T1.
@@FUNCTION STORES (T4) VIA DEVBWC.  INCS DEVABC.
@@EXIT SEE FUNCTION.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%

SBUFST:	TLNN	S,COMPAT	;BIT COUNT?
	JRST	SBUFS2		;NO, AS IS.
	PUSH	P,T2		;YES.  SAVE T2.
	MOVE	T1,T4		;COUNT TO T1.
	IDIVI	T1,4		;T1/WORDS T2/BYTES.
	IMULI	T1,^D36		;CONVERT TO BITS.
	JUMPE	T2,SBUFS1	;JUMP ON NO BYTES.
	LSH	T2,3		;CONVERT TO BITS.
	ADD	T1,T2		;SUM TO T1.
SBUFS1:	TLO	T1,400000	;TURN ON BIT FLAG BIT.
	POP	P,T2		;RESTORE T2.
	MOVE	T4,T1		;SUM TO T4.
SBUFS2:	PUSHJ	P,BDIO		;DEC PGYDIOS.
	HRRZ	T1,DEVBWC(F)	;
	MOVEM	T4,(T1)		;STORE THE COUNT.
	AOJ	T1,.+1		;INCREMENT TNE
	HRRM	T1,DEVBWC(F)	;STORAGE ADDRESS.
	AOS	DEVABC(F)
	POPJ	P,

COMMENT %@@SUBROUTINE STC12
@@PURPOSE SUBR TO GENERATE THE 1ST OR 2ND PART OF THE TAPE
CLEANING SEQUENCE, RESET THE INSIDE ERROR COUNT, AND SET UP
THE DEV LIST.
@@ENTRY EXPECTS T3=UNIT DB AND T1=BSR(TC1) OR SKR(TC2).
@@ACCUM DESTROYS NO ACS.
@@CALLS SCMGN5 (IN SSMTIC/SREW...SSKTIE).
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL.  @@%

STC12:	PUSH	P,M
	PUSH	P,T2
	MOVE	T2,UNICMD(T3)	;SET UP A SM AT THE
	MOVEM	T2,UNIERO(T3)	;TOP OF THE ERROR SPACE.
	HRRZI	M,4
	HLRZ	T2,DEVER2(F)	;GET PHASE.
	CAME	T1,[XWD SKR,0] 	;SET UP TC2?
	SETCA	T2,		;NO, TC1.
	TRNE	T2,2
	AOJ	M,.+1
	TDO	T1,DEVADD(F)	;FINISH PROTOTYPE CMD.
	PUSH	P,T3		;SAVE T3.
	MOVEM	T1,UNIERO+1(T3)
	AOJ	T3,
	SOJG	M,.-2
	HRLZI	T1,HALT		;GEN AND STORE A
	MOVEM	T1,UNIERO+1(T3)	;HALT CMD.
	POP	P,T3
	MOVEI	T1,INSERR	;RESET INSIDE ERROR
	MOVEM	T1,DEVINS(F)	;COUNT.
	MOVEI	T1,UNIERO(T3)
	POP	P,T2
	JRST	SCMGN5		;FINISH UP IN MAIN SUBR.


COMMENT %@@SUBROUTINE SSMTIC/SREW/SBSR/SSTIE/SBSERG/SBSTIE/SSKTIE
@@PURPOSE SUBR, WITH VARIOUS ENTRY POINTS, WHICH GENERATES
VARIOUS SEQUENCES OF ERROR RECOVERY AND TAPE POSITIONING.
THE SEQUENCES ARE ALL OF THE FORM SM/CMD1/..../CMDN/TIC, WHERE
THE CMDS ARE OPTIONAL AND THE TIC IS TO THE RH(T4).
ALSO SETS UP THE DEV LIST ENTRY, ETC.
@@ENTRY EXPECTS T4 AS A POINTER, T3=UNIT DB, P3=UNIT NUMBER, AND F=DDB.
SCMGN5 IS THE ADDITIONAL ENTRY POINT.
@@ACCUM DESTROYS ACS T1 AND T4.
@@CALLS SUBSTI.
@@RESTRICTION CALLED AT INTERRRUPT LEVEL.S @@%

SSMTIC:	MOVEI	T1,SSEND	;SM/TIC.
	JRST	SCMGN1

SREW:	MOVEI	T1,.+2		;SM/REW/TIC.
	JRST	SCMGN1
	XWD	REW,0
SSEND:	Z

SBSR:	MOVEI	T1,.+2		;SM/BSR/TIC.
	JRST	SCMGN1
	XWD	BSR,0
	Z

STIE:	MOVEI	T1,.+2		;SM/TIE/TIC.
	JRST	SCMGN1
	XWD	TIE,0
	Z

SBSERG:	MOVEI	T1,.+2		;SM/BSR/ERG/TIC.
	JRST	SCMGN1
	XWD	BSR,0
	XWD	ERG,0
	Z

SBSTIE:	MOVEI	T1,.+2		;SM/BSR/TIE/TIC.
	JRST	SCMGN1
	XWD	BSR,0
	XWD	TIE,0
	Z

SSKTIE:	MOVEI	T1,.+2		;SM/SKR/TIE/TIC.
	JRST	SCMGN1
	XWD	SKR,0
	XWD	TIE,0
	Z

SCMGN1:	PUSH	P,M		;SAVE M AND
	PUSH	P,T4		;T4.
	MOVE	M,UNICMD(T3)	;GET AND STORE THE
	MOVEM	M,UNIERO(T3)	;SM CMD.
	MOVEI	M,UNIERO+1(T3)	;M IS POINTER TO ERROR SPACE.
SCMGN3:	MOVE	T4,(T1)		;GET NEXT CMD TO GENERATE.
	JUMPE	T4,SCMGN4	;END OF LIST?
SCMG33:	TDO	T4,DEVADD(F)	;
	MOVEM	T4,(M)		;STORE CMD.
	MOVE	T4,(T1)		;GET CMD AGAIN.
	CAME	T4,[XWD TIE,0]	;TIE?
	JRST	SCMG35		;NO.
	HLRZ	T4,FTXMCH(J)	;YES.  SEE IF A TIE CMD WILL BE
	TRNE	T4,TRK7!TRK9	;ACCEPTABLE TO THE KONTROLLER.
	JRST	.+3		;YES IT WILL.
	MOVSI	T4,IGNLEN	;NO, IT WILL
	IORM	T4,(M)		;GIVE LENGTH ERROR.
	MOVEI	T4,FTXSTS(J)	;BUILD DATA
	HRLI	T4,777700	;WORD.
	ADDI	M,1		;ADJUST PNTR TO ERROR SPACE.
	MOVEM	T4,(M)		;STORE DATA WORD.
SCMG35:	AOJ	M,.+1		;MOVE DOWN IN ERROR SPACE.
SCMG36:	AOJA	T1,SCMGN3	;POINT TO NEXT REQUEST.
SCMGN4:	POP	P,T4		;SET UP
	TLO	T4,TIC		;THE TIC
	MOVEM	T4,(M)		;CMD.
	MOVEI	T1,UNIERO(T3)	;SET UP THE DEVICE
SCMGN5:	PUSHJ	P,SUBSTI	;LIST ENTRY, ETC.
	POP	P,M
	POPJ	P,


COMMENT %@@SUBROUTINE SSKBSR
@@PURPOSE SUBR TO GENERATE SM/SKR OR BSR/HALT, SET UP THE
DEVICE LIST ENTRY, AND RESET DEVINS;  FOR VARIOUS TAPE ADJUSTMENTS.
@@ENTRY EXPECTS T3=UNIT DB, T1= BSR OR SKR, J=KONT DB, AND
P3=UNIT NO.
@@ACCUM DESTROYS ACS T1 AND T2.
@@CALLS SUBSTI.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%

SSKBSR:	TDO	T1,DEVADD(F)	;SKR OR BSR
	MOVEM	T1,UNIERO+1(T3)	;CMD.
	MOVE	T1,UNICMD(T3)	;SM
	MOVEM	T1,UNIERO(T3)	;CMD
	HRLZI	T1,HALT		;HALT
	MOVEM	T1,UNIERO+2(T3)	;CMD.
	MOVEI	T1,^D10		;SET UP
	MOVEM	T1,DEVINS(F)	;RETRY COUNT.
	MOVEI	T1,UNIERO(T3)
	JRST	SUBSTI

COMMENT %@@SUBROUTINE FSLDPT
@@PURPOSE "SUBR" (NEVER RETURNS) TO HANDLE HITTING LOAD
POINT DURING TAPE CLEANING.
@@ENTRY EXPECTS T2=ADDR OF FAILED CMD+1, M=PHASE OF DC-R RECOVERY,
F=DDB, J=KONT. DB, P3=UNIT NO., PG=CHAN DB, AND T3=UNIT DB.
@@ACCUM DESTROYS M,T1,T2, AND T4.
@@FUNCTION MARK THAT WE SHOULD NOT TAPE CLEAN FOR THIS RECORD.
GENERATE THE APPROPRIATE TAPE ADJUSTMENT.  SET UP AND GO.
@@CALLS SUBSTI AND FXDSM1.
@@RESTRICTIONS @@%

FSLDPT:	HRRM	M,DEVER2(F)	;TURN OFF TC.
	HRLZI	T1,SKR		;T1=A SKR
	TDO	T1,DEVADD(F)	;CMD.
	MOVEM	T1,UNIERO+1(T3)	;AT LEAST 1 NEEDED.
	SUBI	T2,UNIERO+2(T3)	;T2=NO. OF BSR'S DONE-1.
	CAIE	M,11		;PHASE 1 AND
	CAIE	T2,1		;NEED SKR/BSR?
	JRST	FSLDP4		;NO, JUST SKR'S.
	HRLZI	T1,BSR		;YES.  STORE
	TDO	T1,DEVADD(F)	;THE
	MOVEM	T1,UNIERO+2(T3)	;BSR.
	MOVEI	T4,UNIERO+3(T3)	;HALT.
	JRST	FSLDP6
FSLDP4:	CAIN	M,11		;PHASE 1?
	SUBI	T2,2		;YES.
	MOVEI	T4,UNIERO+2(T3)	;HERE FOR JUST
	SOJL	T2,.+3		;A
	MOVEM	T1,(T4)		;SEQ. OF
	AOJA	T4,.-2		;SKR'S
FSLDP6:	HRLZI	T1,HALT		;PLUS
	MOVEM	T1,(T4)		;HALT.
	HLRZ	T1,DEVER2(F)	;PRETEND
	ADDI	T1,10		;THIS
	HRLM	T1,DEVER2(F)	;IS TC2.
	MOVEI	T1,INSERR	;RESTORE THE INSIDE
	MOVEM	T1,DEVINS(F)	;ERROR COUNT.
	MOVEI	T1,UNIERO(T3)	;POINT THE
	PUSHJ	P,SUBSTI	;DEV LIST,
	JRST	FXDSM1		;AND GO.

COMMENT %@@SUBROUTINE SREVRS
@@PURPOSE SUBR TO REVERSE THE DATA WORDS FROM READING BACKWARDS
TO READING FORWARDS OR VICE VERSA.
@@ENTRY EXPECTS J=0 FOR TO BACKWARDS, -1 FOR TO FORWARDS.
EXPECTS T3=UUNIT DB, F=DDB, AND S=DEVIOS.
@@ACCUM DESTROYS T1,T2,T4, AND M.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%

SREVRS:	MOVE	T1,UNIDC1(T3)	;T1=
	AOJ	T1,.+1		;ADDR OF 1ST DW.
	HRRZ	T4,DEVER1(F)	;T4=
	SOJ	T4,.+1		;ADDR OF LAST DW.
	PUSH	P,PG		;SAVE PG.
	SETZ	PG,		;R HOLDS SUM.
SREVR2:	LDB	M,[POINT ^D11,(T1),^D11] ;DATA
	LDB	T2,[POINT ^D24,(T1),^D35] ;WORDS
	TDO	M,MSKCTU	;BE REVERSED.
	PUSH	P,M		;SAVE COUNT.
	TLNE	S,COMPAT	;WORD
	LSH	M,-2		;COUNT TO M.
	ADDI	M,1		;ADJUSTMENT.
	JUMPE	J,SREVR3	;ADJUST
	ADD	T2,M		;THE
	JRST	.+2		;MEM
SREVR3:	SUB	T2,M		; ADDR.
	POP	P,M		;RESTORE COUNT.
	DPB	M,[POINT ^D11,T2,^D11] ;CREATE NEW DW.
	MOVEM	T2,(T1)		;STORE ADJUSTED WORD.
	SUB	PG,M		;SAVE COUNT OF WORDS.
SREVR4:	CAIGE	T1,(T4)		;DONE WITH INTERNAL ADJUST?
	AOJA	T1,SREVR2	;NO.
	MOVE	T1,UNIDC1(T3)	;YES, RESTORE
	AOJ	T1,.+1		;T1=ADDR OF 1ST DW.
	TLNN	S,COMPAT	;SET
	TRNN	PG,1		;BIT
	JRST	SREVR7		;7 OF CMD TO
	HRLZI	M,2000		;WORD MODE AND
	IORM	M,-1(T1)	;ODD NO. OF WORDS.
SREVR7:	MOVE	M,(T1)		;EXCH
	EXCH	M,(T4)		;THE
	MOVEM	M,(T1)		;WORDS.
	AOJ	T1,.+1		;ADJUST PNTR.
	CAIGE	T1,(T4)		;DONE?
	SOJA	T4,SREVR7	;NO.
	HRRZ	T4,DEVER1(F)	;YES.  TURN
	HRLZI	PG,LASDAT	;ON THE LAST
	IORM	PG,-1(T4)	;DATA FLAG.
	POP	P,PG		;RESTORE PG.
	POPJ	P,

COMMENT %@@SUBROUTINE SLENER
@@PURPOSE SUBR CALLED ON LENGTH ERROR.
IF TAPE > REQUEST, RETURNS T4/REQUEST.
"   "   <    "   ,    "    T4/TAPE AND SKIP RETURNS.
@@ENTRY EXPECTS T3=UNIT DB AND U=4 WORD AREA ADDR+1.
@@ACCUM DESTROYS NO ACS.
@@EXIT SEE PURPOSE.
@@CALLS SGDEV1, SGPREV, SWRDRD, AND CPOPJ1.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%


SLENER:	PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;AND T2.
	LDB	T2,[POINT ^D12,1(U),^D11] ;GET COUNT.
	PUSHJ	P,SGDEV1	;GET T4=NEXT CMD ADDR.
	HRRZ	T1,1(U)		;TAPE >REQUEST OR
	CAIL	T1,(T4)		;REQ>TAPE?
	JUMPE	T2,SLTGR	;JUMP ON TAPE>REQ.

    ;HERE ON TAPE < REQUEST.
	JUMPE	T2,.+2		;MAKE STATUS COUNT
	TDO	T2,MSKCTU	;CORRECT NUMBER.
	PUSHJ	P,SGPREV	;T4=PREVIOUS CMD.
	SUBI	T1,2		;T1=ADDR OF 1ST DW BEFORE FAILED DW.
	CAIG	T1,(T4)		;ONE THERE?
	TDZA	T4,T4		;NO.  T4 COUNT =0.
SLTLR1:	PUSHJ	P,SWRDRD	;T4=COUNT EXCEPT FOR FAILED DW.
	HRRZ	T1,1(U)		;GET
	LDB	T1,[POINT ^D11,-1(T1),^D11] ;THE
	TDO	T1,MSKCTU	;COUNT
SLTLR4:	SUB	T1,T2		;LAST COUNT - LEFT OVER.
	SUB	T4,T1		;BEFORE + THIS = TOTAL.
	POP	P,T2		;RESTORE T2
	POP	P,T1		;AND T1
	JRST	CPOPJ1		;SKIP RETURN.

    ;HERE ON TAPE > REQUEST.
SLTGR:	SOJ	T1,.+1		;POINT T1 TO THE LAST DATA WORD.
	PUSHJ	P,SWRDRD	;T4=REQUEST.
	POP	P,T2		;RESTORE T2
	POP	P,T1		;AND T1.
	POPJ	P,		;RETURN.

COMMENT %@@SUBROUTINE SNEW
@@PURPOSE SUBR TO GENERATE AN ERROR PROCEDURE, WHEN NO OLD
ERROR PROCEDURES MATTER.
@@ENTRY EXPECTS ERROR FLAG IN T2, T3=UNIT DB, P3=UNIT NUMBER,
U=ADDR OF 4 WORD AREA+1, J=KONT DB, AND F=DDB.
SNEW4 IS AN ADDITIONAL ENTRY POINT.
@@ACCUM DESTROYS T1, T2, AND T4.
@@FUNCTION DETERMINES WHOCH CMDS TO SET UP IN THE UNIT'S
ERROR SPACE, AND SETS THEM UP.
@@EXIT SEE FUNCTION.
@@CALLS SGPREV, SBSERG, SREW, SBSTIE, SSKTIE, SSMTIC, SBSR, AND SUBSTI.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%

IF2,<PRINTX [Should use BMX pointer if async error status]>
SNEW:	HRRZ	T1,1(U)		;SET UP T4 FOR THE CMD
;22-Jun-87 - crash dump on F38 shows that SA10 may leave garbage at 1(U)
	PUSHJ	P,SGPREV	;GENERATORS TO TIC TO.
	CAIGE	T2,ERWWTM
	JRST	SNEW2

	CAIN	T2,ERWWTM
	JRST	SBSERG		;DATA CHECK-WRT OR WTM(14).
	CAIN	T2,ERIDBR
	JRST	SREW		;ID BURST CHECK(16).
	HLRZ	T2,DEVER2(F)	;GET PHASE.
	CAIN	T2,1		;PHASE 1 BSR,
	JRST	SBSTIE		;PHASES
	JRST	SSKTIE		;2 AND 3 SKR.

    ;HERE WITH MEM ERR(10), BUS OUT CHECK(11), OVERRUN(12), OR
    ;DATA CHECK-ERG(13).
SNEW2:	CAIN	T2,ERDCER	;DC-ERG?
	JRST	SNEW4		;YES.
	HLRZ	M,DEVFNJ(F)	;NO.  GET FN IN PROGRESS.
	CAIE	T2,ERBSOU	;BUS OUT?
	JRST	SNEW31		;NO.
	MOVE	T2,(U)		;YES,  BUS OUT.  GET STATUS WORD.
	TLNE	T2,DEVEND	;DEVICE END
	CAIE	M,FNPWRT	;AND WRITING?
	JRST	SSMTIC		;NO.
	JRST	SBSR		;YES, NEED TO BACKSPACE.
SNEW31:	CAIL	M,FNPRED	;HERE ON MEM ERR AND OVRN.
	JRST	SBSR		;BACKSPACE IF READ/WRITE.
SNEW4:	MOVEI	T1,UNICMD(T3)	;HERE ON TRY AGAIN.
	JRST	SUBSTI


COMMENT %@@SUBROUTINE SMOD
@@PURPOSE SUBR TO GEN AN ERROR PROCEDURE WHEN THE OLD ERROR
PROCEDURE MATTERS.
@@ENTRY EXPECTS U=ADDR OF 4 WORD AREA+1, T3=UNIT DB,
P3=UNIT NUMBER, J=KONT DB, AND F=DDB.
@@ACCUM DESTROYS T1, T2, AND T4.
@@CALLS SUBSTI.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%
;THE NEW ERRORS THAT CAN OCCUR IN ERR SPACE ARE MEM ERR, BUS OUT,
;OVRN, AND DC-ERG.  ALL OF THESE UNDER THESE CIRCUMSTANCES JUST
;RETRY.

SMOD:	HRRZ	T2,1(U)		;GET ADDR OF
	SOJ	T2,.+1		;FAILED CMD.
	CAIG	T2,UNIERO(T3)	;NEED TO REARRANGE ERR SPACE?
	JRST	SNEW4		;NO.
	MOVEI	T1,UNIERO+1(T3)	;YES.
	MOVE	T4,(T2)		;MOVE UP THE CMDS
SMOD2:	MOVEM	T4,(T1)		;UNTIL HALT OR TIC
	AOJ	T2,.+1		;IS SEEN (BOTH HAVE
	MOVE	T4,(T2)		;EXECUT
	TLNE	T4,EXECUT	;=0).
	AOJA	T1,SMOD2	;NOT SEEN YET.
	MOVEM	T4,1(T1)	;STORE HALT/TIC.
	MOVEI	T1,UNIERO(T3)	;SET UP DEV LIST TO POINT TO THE
	JRST	SUBSTI		;TOP OF ERROR SPACE.

COMMENT %@@SUBROUTINE SNOISE
@@PURPOSE SUBR TO DETERMINE IF THE RECORD WE JUST GOT A
DC-R ON WAS A NOISE RECORD.

IF NOT A NOISE RECORD, NORMAL RETURN.
IF A NOISE RECORD, SKIP RETURN WITH DECREMENTED DEVNOI IN
T1.
@@ENTRY EXPECTS T3=UNIT DB, F=DDB, J=KONT DB, AND U=ADDR OF 4
WORD AREA+1.
@@ACCUM DESTROYS T1 AND T4.
@@FUNCTION CALL SNOICT TO GET A COUNT OF THE BYTES READ. THE
RECORD IS A NOISE RECORD IF THE COUNT IS LESS THAN 12 AND
THE NOISE BIT IS NOT SET.
@@EXIT SEE PURPOSE.
@@CALLS SNOICT, CPOPJ, AND CPOPJ1.
@@RESTRICTIONS @@%


SNOISE:	PUSHJ	P,SNOICT	;GET COUNT TO T4 IN BYTES.
	CAIL	T4,^D12		;POSSIBLE NOISE RECORD?
	POPJ	P,		;NO.
	LDB	T4,BYKNOI	;YES.
	JUMPN	T4,CPOPJ	;NOISE BIT SET?
	SOS	T1,DEVNOI(F)	;NO.
	JRST	CPOPJ1


COMMENT %@@SUBROUTINE SNOICT
@@PURPOSE SUBR TO CALC THE NUMBER OF BYTES ACTUALLY READ
OR WRITTEN FOR THIS COMMAND AND RETURN THE COUNT IN T4.
@@ENTRY EXPECTS T3=UNIT DB AND U=ADDR OF 4 WORD AREA+1.
@@ACCUM DESTROYS T1.
@@EXIT SEE PURPOSE.
@@CALLS SWRDRD.
@@RESTRICTIONS CALLED AT INTERRUPT LEVEL. @@%
SNOICT:	HRRZ	T1,1(U)		;GET COUNT
	SOJ	T1,.+1		;OF
	PUSHJ	P,SWRDRD	;WORDS
	LDB	T1,[POINT ^D12,1(U),^D11] ;OR
	JUMPE	T1,.+3		;BYTES THAT
	TDO	T1,MSKCTU	;WERE
	ADD	T4,T1		;READ.
	TLNN	S,COMPAT	;IF THIS WAS WORD MODE,
	ASH	T4,2		;CONVERT TO A BYTE COUNT.
	POPJ	P,		;RETURN.

	$END	(FTA)		;End of FTASER (FTALIT: FTAEND:)
      	Kg!