;THIS MODULE ASSEMBLED WITH FOONLY PARAMETER FILE - F3SYM.MAC

	IF2,<IFNDEF LISTSN,<		;LIST F3SYM.MAC IN COMMON ONLY
				TAPE>>

					;SKIP PASS2 IN ALL OTHER CASES
IF2,<
SUBTTL FOONLY PARAMTER DEFINTIONS FOR PDP-10 MONITOR
;	/EVS 3 MAR 78
>;END IF2

;CPU TYPE SYMBOL DEFINITION

CPUTYP==CPUF3

DEFINE IFKMC<REPEAT 0,>
DEFINE IFNKMC,<REPEAT 1,>

DEFINE PRINTF(A,B,C,D),<IF2,<;;Output message on MONKS build only
PRINTX A B C D>>
DEFINE PRINTF(A,B,C,D),<;;;PRINTX A B C D>	;;Output on MONKS builds only
SUBTTL FOONLY INSTRUCTION AND OPCODE DEFINITIONS

OPDEF	ADJSP	[105000000000]	;Adjust stack pointer
OPDEF	DADD	[114000000000]	;Double integer ADD
OPDEF	DSUB	[115000000000]	;Double integer SUB
OPDEF	DMUL	[116000000000]	;Double integer MUL (quad-word result)
OPDEF	DDIV	[117000000000]	;Double integer DIV (quad-word dividend)
OPDEF	ADJBP	[IBP]		;Adjust byte pointer if AC field nonzero
OPDEF	PXCT	[XCT]		;Previous context XCT

  APR==0
OPDEF	APRID	[700000000000]	;BLKI  APR, Read APR ID (CPU serial number)
OPDEF	WRFIL	[700100000000]	;BLKO  APR, Write cache refill algorithm
OPDEF	WRADB	[700140000000]	;DATAO APR, Write Address Break register
OPDEF	RDADB	[700040000000]	;DATAI APR, Read Address Break register
OPDEF	WRAPR	[700200000000]	;CONO  APR, Write APR priority assignment
OPDEF	RDAPR	[700240000000]	;CONI  APR, Read APR status bits
  PI==4
OPDEF	RDERA	[700400000000]	;BLKI  PI,  Read Error Address Register
OPDEF	SBDIAG	[700500000000]	;BLKO  PI,  SBUS diagnostic
OPDEF	WRPI	[700600000000]	;CONO  PI,  Write PI status
OPDEF	RDPI	[700640000000]	;CONI  PI,  Read PI status
  PAG==10
OPDEF	CLRPT	[701100000000]	;BLKO  PAG, clear pager tables
OPDEF	WREBR	[701200000000]	;CONO  PAG, write Exec Base Register
OPDEF	RDEBR	[701240000000]	;CONI  PAG, read Exec Base Register
OPDEF	WRUBR	[701140000000]	;DATAO PAG, write User Base Register
OPDEF	RDUBR	[701040000000]	;DATAI PAG, read User Base Register
  CCA==14
OPDEF	SWPIA	[DATAI CCA,]	;INVALIDATE ALL CACHE DATA, DONT WRITE TO CORE
OPDEF	SWPVA	[BLKO  CCA,]	;SWEEP CACHE, VALIDATING CORE, CACHE VALID
OPDEF	SWPUA	[DATAO CCA,]	;UNLOAD ALL PAGES, UPDATING CORE, CACHE INVALID
OPDEF	SWPIO	[CONI  CCA,]	;INVALIDATE ONE PAGE
OPDEF	SWPVO	[CONSZ CCA,]	;VALIDATE ONE PAGE
OPDEF	SWPUO	[CONSO CCA,]	;UNLOAD ONE PAGE
  TIM==20
OPDEF	RDPERF	[BLKI  TIM,]	;READ DOUBLE-WORD PERFORMANCE METER
OPDEF	RDTIME	[DATAI TIM,]	;READ DOUBLE-WORD TIME BASE
OPDEF	WRPAE	[BLKO  TIM,]	;WRITE PERFORMANCE ANALYSIS ENABLES
  MTR==24
OPDEF	RDMACT	[BLKI  MTR,]	;READ DOUBLE-WORD MBOX ACCOUNTING
OPDEF	RDEACT	[DATAI MTR,]	;READ DOUBLE-WORD EBOX ACCOUNTING

SUBTTL	FOONLY external devices (disk, tape, network)

OPDEF	RCMD	[715000000000]	;READ COMMAND REGISTER
OPDEF	RMA	[716000000000]	;READ MEMORY ADDRESS
OPDEF	RDA	[717000000000]	;READ DISK ADDRESS (IN PAGES)
OPDEF	RECC	[720000000000]	;READ CONTROL REGISTER
OPDEF	LCMD	[721000000000]	;LOAD COMMAND REGISTER
OPDEF	LMA	[722000000000]	;LOAD MEMORY ADDRESS
OPDEF	LDA	[723000000000]	;LOAD DISK ADDRESS
OPDEF	LECC	[724000000000]	;CLEARS ECC LOGIC, STARTS AND INITS CONTROL.
OPDEF	MTRS	[726000000000]	;new Mag Tape Read Status
OPDEF	MTOP	[727000000000]	;new Mag Tape OPeration
OPDEF	MTSZ	[730000000000]	;new Mag Tape CONSZ
OPDEF	MTSO	[731000000000]	;new Mag Tape CONSO
 OPDEF	OMTOP	[726000000000]	;old Mag Tape OPeration
 OPDEF	OMTRS	[727000000000]	;old Mag Tape Read Status
 OPDEF	OMTWR	[731000000000]	;old Mag Tape WRite data
 OPDEF	OMTRD	[732000000000]	;old Mag Tape ReaD data
 OPDEF	TPCONI	[733000000000]	;old TaPe CONI
 OPDEF	TPCONO	[734000000000]	;old TaPe CONO
 OPDEF	TPCNSO	[735000000000]	;old TaPe CONSO
 OPDEF	TPDATI	[736000000000]	;old TaPe DATAI
OPDEF	DCONO	[740000000000]	;CONO TO DISK CONTROL TO SET PI ASSIGNMENT
OPDEF	DCONI	[741000000000]	;CONI FROM DISK CONTROL
OPDEF	DCONSO	[742000000000]	;CONSO DSK,
OPDEF	DCONSZ	[743000000000]	;CONSZ DSK,
OPDEF	TNCONO	[744000000000]	;CONO to TYMNET
OPDEF	TNOUT	[745000000000]	;DATAO to TYMNET
OPDEF	TNIN	[746000000000]	;DATAI from TYMNET

OPDEF	DADD	[114B8]		;DOUBLE ADD
OPDEF	DSUB	[115B8]		;DOUBLE SUB
OPDEF	DMUL	[116B8]		;DOUBLE MUL
OPDEF	DDIV	[117B8]		;DOUBLE DIV
OPDEF	ADJSP	[105B8]		;ADJUST STACK POINTER
OPDEF	PXCT	[XCT]		;PREVIOUS CONTEXT EXECUTE
OPDEF	ADJBP	[IBP]		;ADJUST BYTE POINTER
	SUBTTL	HARDWARE BITS -- FOR FOONLY PROCESSOR

;APRID BITS.

APRSER==7777		;PROCESSOR SERIAL NUMBER.


;LEFT HALF RDAPR (APR CONI) BITS.

LP.NEE==1B7		;NXM ERROR ENABLED
LP.IFE==1B8		;I/O PAGE FAIL ERROR ENABLED
LP.PEE==1B9		;PARITY ERROR ENABLED
LP.PDE==1B11		;PAGE TABLE DIRECTORY PARITY ERROR ENABLED
LP.PFE==1B12		;POWER FAIL ENABLED

;RIGHT HALF CONI (APR CONI) BITS

LP.NXM==1B25		;NXM
LP.IOF==1B26		;I/O PAGE FAIL
LP.PAR==1B27		;PARITY ERROR
LP.INT==1B32		;INTERRUPT REQUEST
LP.PIA==7B35		;PIA

;WRAPR (CONO APR BITS)
LP.IOR==1B19		;IO RESET
LP.ESF==1B20		;ENABLE SELECTED FLAGS (BITS 24-31)
LP.DSF==1B21		;DISABLE SELECTED FLAGS (BITS 24-31)
LP.CSF==1B22		;CLEAR SELECTED FLAGS (BITS 24-31)
LP.SSF==1B23		;SET SELECTED FLAGS (BITS 24-31)
LP.NXM==1B25		;NXM
LP.IOF==1B26		;I/O PAGE FAIL
LP.PAR==1B27		;PARITY ERROR
LP.PWF==1B30		;POWER FAIL
LP.CLK==1B31		;POWER LINE FREQUENCY CLOCK FLAG.
LP.PIA==7B35		;PIA

;HERE ARE APR BITS THAT ARE COMPATIBLE BETWEEN FOONLY AND KI10.
; USE NAMES FORMERLY USED FOR KI10 APR BITS TO MAKE
; THINGS EASIER.

XP APRIOB,LP.IOR	;IOB RESET
XP APRIOP,LP.IOF	;IO PAGE FAIL
XP APRNXM,LP.NXM	;NXM
XP APRPAR,LP.PAR	;(MB) PARITY ERROR
XP APRPOW,LP.PWF	;POWER FAILURE
XP APRCLK,LP.CLK	;POWER LINE CLOCK

;MASKS FOR INTERRUPTS

XP APFMSK,LP.IOF+LP.PWF+LP.NXM ;FATAL ERROR INTERRUPTS
XP APRMSK,APFMSK+LP.PAR+LP.CLK		;MASK FOR ALL INTERRUPT CONDITIONS

DEFINE CLPARF<CONO APR,LP.CSF+LP.PAR> ;CLEAR PARITY ERROR MACRO
XP CLRNXM,<LP.CSF+LP.NXM+LP.PAR>	;CONO APR,CLRNXM CLEARS NXM
				;(NXM ALSO CAUSES MB PARITY ERROR TO COME UP)

;LEFT HALF CONI PI BITS
LI.PR1==1B11		;PROGRAM P1 REQUEST FOR CHANNEL 1
LI.PR2==1B12		;PROGRAM PI REQUEST FOR CHANNEL 2
LI.PR3==1B13		;PROGRAM PI REQUEST FOR CHANNEL 3
LI.PR4==1B14		;PROGRAM PI REQUEST FOR CHANNEL 4
LI.PR5==1B15		;PROGRAM PI REQUEST FOR CHANNEL 5
LI.PR6==1B16		;PROGRAM PI REQUEST FOR CHANNEL 6
LI.PR7==1B17		;PROGRAM PI REQUEST FOR CHANNEL 7

;RIGHT HALF PI CONI BITS.

LI.IP1==1B21			;INTERRUPT IN PROGRESS ON PI CHANNEL 1
LI.IP2==1B22			;INTERRUPT IN PROGRESS ON PI CHANNEL 2
LI.IP3==1B23			;INTERRUPT IN PROGRESS ON PI CHANNEL 3
LI.IP4==1B24			;INTERRUPT IN PROGRESS ON PI CHANNEL 4
LI.IP5==1B25			;INTERRUPT IN PROGRESS ON PI CHANNEL 5
LI.IP6==1B26			;INTERRUPT IN PROGRESS ON PI CHANNEL 6
LI.IP7==1B27			;INTERRUPT IN PROGRESS ON PI CHANNEL 7
LI.IPA==LI.IP1+LI.IP2+LI.IP3+LI.IP4+LI.IP5+LI.IP6+LI.IP7
				;INTERRUPT IN PROGRESS ON ANY OR ALL PI CHANNELS
LI.PIA==1B28			;PI ACTIVE
LI.CO1==1B29			;PI CHANNEL 1 ON
LI.CO2==1B30			;PI CHANNEL 2 ON
LI.CO3==1B31			;PI CHANNEL 3 ON
LI.CO4==1B32			;PI CHANNEL 4 ON
LI.CO5==1B33			;PI CHANNEL 5 ON
LI.CO6==1B34			;PI CHANNEL 6 ON
LI.CO7==1B35			;PI CH7NNEL 7 ON
LI.ACO==LI.CO1+LI.CO2+LI.CO3+LI.CO4+LI.CO5+LI.CO6+LI.CO7

;BITS IN CONO PI (WRPI)

LI.CPP==1B22		;CLEAR PROGRAM REQUEST
LI.CPS==1B23		;CLEAR PI SYSTEM
LI.REQ==1B24		;REQUEST INTERRUPT ON CHANNEL (EVEN IF CHAN IS OFF)
LI.CON==1B25		;TURN SELECTED CHANNEL ON
LI.COF==1B26		;TURN SELECTED CHANNEL OFF
LI.PIF==1B27		;TURN SYSTEM OFF
LI.PIN==1B28		;TURN SYSTEM ON
LI.ACO==LI.ACO		;MASK FOR SELECTING CHANNELS.
;BITS FOR FOONLY PROGRAM CLOCKS

;CONO BITS
TO.ETO==1B32		;ENABLE TIMER INTERRUPT
TO.PIA==7B35		;PIA

;CONI BITS
TI.DON==1B32		;TIMER DONE INTERRUPT REQUEST
TI.PIA==7B35		;PIA

;DATAO SETS TIMER REGISTER, WHEN IT OVERFLOWS AS AN UNSIGNED NUMBER,
; THE INTERRUPT COMES IN. THUS, LOADING IT WITH A NEGATIVE NUMBER,
; WILL CAUSE IT TO INTERRUPT IN THAT MANY MICROSECONDS.
; (THE COUNTER COUNTS AT A ONE MICROSECOND RATE.)
;LEFT HALF WRPAE BITS

PE.CP0==1B0		;CHANNEL 0 PERFORMANCE ENABLE
PE.CP1==1B1		; CHANNEL 1
PE.CP2==1B2
PE.CP3==1B3
PE.CP4==1B4
PE.CP5==1B5
PE.CP6==1B6
PE.CP7==1B7
PE.CPI==1B8		;CHANNEL PERFORMANCE IGNORE

PE.UCI==1B9		;MICROCODE STATE IGNORE
PE.PRL==1B10		;PROBE LOW ENABLE
PE.PRI==1B11		;PROBE STATE IGNORE

PE.CCR==1B12		;CACHE REFILL ENABLE
PE.CCF==1B13		;CACHE FILL ENABLE
PE.EWB==1B14		;EBOX WRITE BACK
PE.SWB==1B15		;SWEEP WRITE BACK ENABLE
PE.CCI==1B16		;CACHE CONDITION IGNORE

;RIGHT HALF WRPAE BITS

PE.PP0==1B18		;PI 0 PERFORMANCE ENABLE
PE.PP1==1B19
PE.PP2==1B20
PE.PP3==1B21
PE.PP4==1B22
PE.PP5==1B23
PE.PP6==1B24
PE.PP7==1B25
PE.NPI==1B26		;NO PI

PE.PCU==1B27		;PC USER ENABLE
PE.PCI==1B28		;PC IGNORE
PE.EVM==1B29		;EVENT MODE (RATHER THAN DURATION MODE)
PE.CLR==1B30		;CLEAR PERFORMANCE METER

;COMBINATIONS

PE.PIN==PE.NPI!<377*<PE.PP7>>	;PI CONDI9ION IGNORE


;VALUES FOR THE CLOCKS

.EBCPT==10000		;EBOX COUNTS/EBOX TICK
.MBCPT==10000		;MBOX COUNTS/MBOX TICK
.TBCPT==10000		;TIME BASE COUNTS/TIME BASE TICK

TB.LTP==^L<.TBCPT>	;POSITION THAT TIME BASE STARTS COUNTING IN
;BITS IN CONO PAG
LG.CSL==1B18		;CACHE STRATEGY LOOK
LG.CSW==1B19		;CACHE STRATEGY WRITE
LG.KLP==1B21		;KL PAGING IN EFFECT.
LG.TEN==1B22		;TRAP ENABLE
LG.EPT==7777		;ADDRESS OF EPT

;BITS IN WRUBR (DATAO PAG).
LG.LAB==1B0		;LOAD AC BLOCKS
LG.LPC==1B1		;LOAD PREV CONTEXT
LG.LUB==1B2		;LOAD USER BASE REGISTER
LG.CAC==7B8		;CURRENT AC BLOCK #
LG.PAC==7B11		;PREV. AC BLOCK #
LG.CSX==1B12		;CSWX
LG.PCS==37B17		;PREVIOUS CONTEXT SECTION
LG.IAM==1B18		;INHIBIT STORING ACCOUNTING METER
LG.UPT==17777		;ADDRESS OF UBR

;DEFINITIONS FOR CONSOLE TELETYPE

;BITS IN CONO TTY

TT.CIB==1B25		;CLEAR INPUT BUSY
TT.CID==1B26		;CLEAR INPUT DONE
TT.COB==1B27		;CLEAR OUTPUT BUSY
TT.COD==1B28		;CLEAR OUTPUT DONE
TT.SIB==1B29		;SET INPUT BUSY
TT.SID==1B30		;SET INPUT DONE
TT.SOB==1B31		;SET OUTPUT BUSY
TT.SOD==1B32		;SET OUTPUT DONE

TT.PIA==7B35		;PI ASSIGNMENT MASK

;BITS IN CONI TTY

TT.IB==1B29		;INPUT BUSY
TT.ID==1B30		;INPUT DONE
TT.OB==1B31		;OUTPUT BUSY
TT.OD==1B32		;OUTPUT DONE

TT.PIA==7B35		;MASK FOR READING PI ASSIGNMENT
SUBTTL HARDWARE PAGING PARAMETERS

;PAGE FAIL (AND MAP INSTRUCTION) WORD DEFINITIONS

XP PFW.U,(1B0)		;USER/EXEC ADDRESS SPACE BIT
XP PFW.H,(1B1)		;"HARDWARE" REASON FOR PAGE FAIL.

;THE FOLLOWING DEFINITIONS APPLY IF PFW.H IS ZERO:

XP PFW.A,(1B2)		;COPY OF A BIT FROM MAP SLOT
XP PFW.W,(1B3)		;W BIT FROM MAP SLOT
XP PFW.S,(1B4)		;S BIT
XP PFW.T,(1B5)		;ON IF WRITE WAS ATTEMPTED.
			; (DOESN'T SAY THATS WHY IT FAILED, THOUGH.)
XP PFW.P,(1B6)		;PUBLIC BIT FROM MAP SLOT
XP PFW.C,(1B7)		;CACHE BIT
XP PFW.R,(1B8)		;PAGED REFERENCE (MAP INSTRUCTION)

;IF PFW.H IS 1, FOLLOWING CODES APPLY:

XP PF.PRV,21		;PROPRIETARY VIOLATION
XP PF.RFE,22		;PAGE REFILL ERROR
XP PF.ABK,23		;ADDRESS BREAK
XP PF.ILI,24		;ILLEGAL INDIRECT (KL PAGING ONLY)
XP PF.PTP,25		;PAGE TABLE PARITY ERROR
XP PF.ILS,27		;ILLEGAL SECTION (EXTENDED ADDRESSING)
XP PF.ARP,36		;AR DATA PARITY ERROR
XP PF.AXP,37		;ARX DATA PARITY ERROR

;PAGE MAP POINTER BITS (KI PAGING)

XP PGE.A,400000
XP PGE.P,200000
XP PGE.W,100000
XP PGE.S,40000
XP PGE.C,20000		;CACHE BIT
;PC BITS.

XP PC.FPD,1B22	;FIRST PART DONE
XP PC.USR,1B23
XP PC.UIO,1B24	;USER IO
XP PC.PUB,1B25	;PUBLIC
XP PC.ADR,1B26	;ADDRESS FAILURE INHIBIT
XP PC.TRP,3B28	;TRAP FLAGS
XP PC.OV,1B18	;OVERFLOW
XP PC.FOV,1B21	;FLOATING OVERFLOW
XP PC.FXU,1B29	;FLOATING EXPONENT UNDERFLOW
XP PC.DCK,1B30	;DIVIDE CHECK
;LOCATIONS IN UPT FIXED BY FOONLY HARDWARE

XP UPTGP0,0		;PAGE 0 OF USER
XP UPTEP0,400		;FIRST PAGE OF EXEC (340) IN UPT

XP UPTPGT,420		;(REALLY SOFTWARE LOCATION).
XP UPTOVT,421		;OVERFLOW TRAP INSTRUCTION
XP UPTPOV,422		;PDL OVERFLOW
XP UPTTR3,423		;TRAP 3
XP UPTMUU,424		;MUUO STORED HERE
XP UPTMUP,425		;MUUO PC STORED HERE
XP UPTPCW,426		;PROCESS CONTEXT WORD (SECTION, ETC)
			; (427 UNUSED)
XP UPTKNT,430		;KERNAL NO TRAP WORD
XP UPTKTR,431		;KERNEL TRAP
XP UPTSNT,432		;SUPERVISOR NO TRAP
XP UPTSTR,433		;SUPERVISOR TRAP
XP UPTCNT,434		;CONCEALED NO TRAP
XP UPTCTR,435		;CONCEALED TRAP
XP UPTPNT,436		;PUBLIC NO TRAP
XP UPTPTR,437		;PUBLIC TRAP
			; (440 TO 477 AVAILABLE TO SOFTWARE.)
XP UPTPFW,500		;PAGE FAIL WORD, USER OR EXEC, STORED HERE.
XP UPTOPP,501		;OLD PAGE FAIL PC
XP UPTNPP,502		;NEW PAGE FAIL PC
			; (503 AVAILBLE TO SOFTWARE)
XP UPTHEC,504		;HI ORDER EBOX CLOCK WORD
XP UPTLEC,505		;LO ORDER EBOX CLOCK WORD
XP UPTHMC,506		;HI ORDER MBOX CLOCK WORD
XP UPTLMC,507		;LO ORDER MBOX CLOCK WORD
			;(510-577 RESERVED FOR USE BY HARDWARE)

XP UPTFSL,600		;BEGINNING OF CONTIGUOUS AREA AVAILABLE TO
			; SOFTWARE.

;AC BLOCK DEFINITIONS

XP USRACB,0		;USER AC BLOCK (MUST BE DEFINED AS ZERO)
XP EX0ACB,1		;FOR EXEC MODE.
XP EX1ACB,2		; ALTERNATE BETWEEN THESE TWO AS UUOS AND PAGE FAULTS ARE DONE.
XP NULACB,2		;CONTAINS NULL JOB
XP NUMACB,4		;NUMBER OF AC BLOCKS ON THIS MACHINE.

;MACRO TO USE WHEN JUST ENTERING EXEC MODE TO SWITCH TO
; THE EXEC AC BLOCK

DEFINE EXECAC,<SALL
	DATAO PAG,[LG.LAB+<EX0ACB>B8+<USRACB>B11]>

DEFINE USERAC,<SALL
	DATAO	PAG,[LG.LAB+<USRACB>B8+<USRACB>B11]
>
;LOCATIONS IN EPT FIXED BY FOONLY HARDWARE

XP EPTACP,37		;POINTER TO PLACE IN EVM WHERE AC BLOCKS ARE KEPT WHEN NOT CURRENT.
XP EPTLUU,40		;LOCAL UUO STORED HERE
XP EPTLUI,41		;INSTRUCTION EXECUTED FOR LOCAL UUOS

			; (42-57) STANDARD PI INTERRUPT INSTRUCTIONS
			; (40+2*N)
			; (60-63) RESERVED FOR CHANNELS
			; (64-137) RESERVED FOR HARDWARE

;DTE HARDWARE LOCATIONS. 8 WORDS FOR EACH LOCATION,
; MAXIMUM OF 4 DTES.

XP EPTDT0,140		;DTE20 0
XP EPTDT1,150		;DTE20 1
XP EPTDT2,160		;DTE20 2
XP EPTDT3,170		;DTE20 3
	XP DTEEBP,0	;TO ELEVEN BYTE POINTER
	XP DTETBP,1	;TO 10 BYTE POINTER
	XP DTEDII,2	;INTERRUPT INSTRUCTION LOCATION
	XP DTEUNU,3	;UNUSED
	XP DTEEPW,4	;EXAMINE PROTECT WORD (NON-PRIV DTES)
	XP DTEERW,5	;EXAMINE RELOCATION WORD
	XP DTEDPW,6	;DEPOSIT PROTECTION WORD
	XP DTEDRW,7	;DEPOSIT RELOCATION WORD

;PAGE MAP POINTERS

XP EPTPG0,200		;FIRST WORD OF PAGE MAP SLOTS (PG 400) IN EPT

XP EPTPGT,420		;(SOFTWARE LOCATION IN KL)
XP EPTOVT,421		;OVERFLOW
XP EPTPOV,422		;PDL OVERFLOW
XP EPTTR3,423		;TRAP 3
			; (424-443 RESERVED FOR USE BY HARDWARE)
;THE FOLLOWING LOCATIONS ARE ESTABLISHED BY SOFWARE CONVENTION
; BETWEEN THE KL-10 AND ITS CONSOLE FRONT END.
; THEY ARE USED FOR THE "SECONDARY PROTOCOL".

XP SPCDBG,444		;BEGINNING OF SPC DATA AREA
XP SPCFLG,444		;SET NON-ZERO WHEN SECONDARY PROTOCOL COMMAND
			; IS COMPLETE. MUST
			; BE CLEARED BEFORE SECONDARY PROTOCOL COMAND IS ISSUED.

XP SPCF11,450		;FROM-11 DATA.
XP SPCCMW,451		;SPC COMMAND WORD
	XP .DTESP,11B27		;ENTER SECONDARY PROTOCOL
	XP .DTCTO,10B27		;OUTPUT CHARACTER ON CTY
	XP .DTRSW,3B27		;READ SWITCHES INTO SPCSWR AND SPCF11.
XP SPCMTD,455		;CTY OUTPUT DONE FLAG. (SPCFLG SET IMMEDIATELY,
			; THIS ONE SETS WHEN CHAR IS ACTUALLY OUT.)
XP SPCMTI,456		;CTY INPUT PRESENT. IF NON-ZERO, CTY
			; CHAR IS PRESENT IN SPCF11.
	XP SPCSWR,457	;SWITCHES APPEAR HERE.
XP SPCDND,457		;END OF SPC DATA AREA
	  XP SS4,4	;"SENSE SWITCH 4" (USED FOR AUTO RELOAD SELECTION.)

			; (460-507 RESERVED FOR USE BY HARDWARE)

;METER LOCATIONS

XP EPTHTB,510		;HI ORDER TIME BASE WORD
XP EPTLTB,511		;LO ORDER TIME BASE WORD (THESE FOR UCODE USE ONLY.)

XP EPTHPA,512		;HI ORDER PERFORMANCE ANALYSIS COUNT
XP EPTLPA,513		;LO ORDER
XP EPTITI,514		;INTERVAL TIMER INTERRUPT INSTRUCTION

			; (515-577 RESERVED FOR USE BY HARDWARE)

XP EPTMP0,600		;FIRST LOCATION OF MAP SLOTS FOR EXEC
			; PAGES 0-337. (USED TO BE UNMAPPED,
			; BUT NEED SLOTS TO CONTROL CACHE.)
XP EPTFSL,760		;START OF CONTIGUOUS BLOCK AVAILABLE TO SOFTWARE.
SUBTTL SYSTEM MACROS - CLEAR PAGE TABLE

;MACROS TO CLEAR EITHER ALL OF PAGE TABLE, OR ONE ENTRY.

DEFINE CLRPTA,<SALL
	IF2,<IFNDEF EPT,<EXTERN EPT>
	     IFNDEF EPTEBR,<EXTERN EPTEBR>>
	CONO	PAG,@EPT+EPTEBR>


;CLEAR ONE ENTRY IN PAGE TABLE. ARG IS ADDRESS OF
; LOCATION TO CLEAR (CAN BE INDEXED, INDIRECT).

DEFINE CLRPTO(ARG)<SALL
	IFB <ARG>,<PRINTX MISSING ARGUMENT TO CLRPTO
			QQQQQQ>
	CLRPT	ARG>

;MACRO TO CLEAR PAGE TABLE FOR PAGE WHOSE NUMBER IS IN RH(W).
; PAGE NUMBER IS IN CORE1 STYLE FORMAT (1000 IS EXEC
; 340)

DEFINE CLRPTW<SALL
	IF2,<IFNDEF CLPTW,<EXTERN CLPTW>>
	PUSHJ	P,CLPTW>
SUBTTL SYSTEM MACROS - CHARGING

;MACROS TO MANIPULATE CHARGING CLOCK.

DEFINE CHARGE<SALL
	JFCL>

DEFINE NOCHARGE<SALL
	JFCL>

DEFINE CHGSTS(LOC)<SALL
	SETZM	LOC>

	XP	CHGON,0		;BIT TO LOOK AT AFTER CHGSTS.
;MACROS TO MOVE DATA BETWEEN THE USER AND THE OPERATING SYSTEM.

DEFINE UMOVE(A,B)
	<XCTFU	<MOVE A,B>>

DEFINE UMOVEM (A,B)
	<XCTTU	<MOVEM A,B>>
SUBTTL SYSTEM MACROS - EXECUTIVE EXECUTE.
;SAME IN KS AND KL.

;BITS IN PXCT AC FIELD
	PX.EAC==10		;EFFECTIVE ADDRESS OF OBJECT INSTRUCTION
	PX.MEM==4		;MEMORY OPERAND (BOTH FETCH AND STORE)
	PX.BYT==2		;EFFECTIVE ADDRESS OF BYTE POINTER
	PX.SRC==1		;STACK WORD IN PUSH/POP; SOURCE IN BLT

	DEFINE	XCTBU(INST)<SALL
	GINST==<PXCT PX.MEM,[INST]>


	PXGEN(<INST>,<DPB,IDPB,LDB,ILDB>,<PX.SRC>)
			;;INCLUDE BYTE INSTRUCTIONS BECAUSE XCTBU IS USED ON KI10 FOR READ-MODIFY-WRITE.
	PXGEN(<INST>,<BLT,PUSH,POP>,<PX.SRC!PX.MEM>)
	GINST
	PURGE GINST
>;END XCTBU MACRO DEFINITION

	DEFINE XCTFU(INST)<SALL
	GINST==<PXCT PX.MEM,[INST]>
		;;INCLUDE DPB AND IDPB BECAUSE XCTFU USED FOR RMW ON KI
	PXGEN(<INST>,<LDB,ILDB,DPB,IDPB,POP,BLT>,<PX.SRC>)
	GINST
	PURGE GINST
>;END XCTFU MACRO DEFINITION

	DEFINE XCTTU(INST)<SALL
	GINST==<PXCT PX.MEM,[INST]>
	PXGEN(<INST>,<LDB,ILDB,IDPB,DPB>,<QQQQQQ>)	;;CAN'T LOAD USERS AC THIS WAY.
				;;MAKE IDPB AND DPB ILLEGAL BECAUSE CAN'T DO IT ON KI, MUST USE FU OR BU INSTEAD.
	PXGEN(<INST>,<PUSH>,<PX.SRC>)
	PXGEN(<INST>,<POP,BLT>,<PX.MEM>)
	GINST
	PURGE GINST
>;END XCTTU MACRO DEFINITION


	DEFINE PXGEN(INST,CODES,BITS)<
	ZZ==0
	IRPC INST,<
	ZZ1==0
	IFIDN < > <INST>,<ZZ1==1>
	IFIDN <	> <INST>,<ZZ1==1>
	IFN ZZ1,<STOPI>
	IFE ZZ1,<
	ZZ==ZZ_6
	ZZ==ZZ+''INST''
>;END IFE ZZ1
>;END IRPC INST
	IRP CODES,<
	IFE <ZZ-''CODES''>,<GINST==<PXCT BITS,[INST]>>
>;END IRP CODES

	PURGE ZZ1
>;END PXGEN MACRO DEFINITION
SUBTTL CACHE SWEEP CONTROL MACROS

;MACRO TO START CACHE UNLOAD

DEFINE CSHUNL<
	PUSHJ	P,CSUNL##>ACRO TO START CACHE VALIDATE

DEFINE CSHVAL <PUSHJ P,CSVAL##>

;MACRO TO MAKE SURE EDGES OF USER'S BUFFER DID NOT GET INTO
; CACHE DURING INPUT TRANSFER BY USER OR OTHER ENTITY
; REFERENCING ADJACENT WORD TO BUFFER. RESTRICTION - BUFFER
; CANNOT BE IN MONITOR PAGES 0-337, OR ELSE ONE OF THE
; FOUR REFERENCES MAY BE TO THE BUFFER ITSELF.
; T1 HAS ADDRESS OF WORD TO THROW OUT OF CACHE.

DEFINE CSHREF<SALL
IF2,<IFNDEF CSRTAB,<EXTERNAL CSRTAB>>
	ANDI	T1,777		;;GET REL LOCATION IN PAGE
	SKIP	@CSRTAB+0
	SKIP	@CSRTAB+1
	SKIP	@CSRTAB+2
	SKIP	@CSRTAB+3
>;END CSHREF MACRO DEFINITION.
	ASUPPRESS		;ONLY LIST REFERENCED SYMBOLS

IFDEF LISTSN,<IFN LISTSN,<PAGE>>	;No $END for KISYM,KLSYM,KSSYM,F3SYM
  CQ+Fˆ