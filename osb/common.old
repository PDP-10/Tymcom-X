TITLE COMMON - MONITOR COMMON DATA AREA AND CONFIGURATION DEFINITION - V534
SUBTTL PART 3 COMMON.MAC - T. HASTINGS/CMF/TL/CHW/AF/TW/PFC/RCC/PH   TS  29 OCT 70

;*;	STOPCD(,ENTRY,COMMON)	;This macro is expanded at relocatable address

PRINTF([CPU status variables at .CPSLF:: need to be defined by a macro])

XP VCOMMN,534		;PUT VERSION NUMBER IN GLOB AND LOADER STORAGE MAP

REPEAT 0, <
;THE COMMON SUBPROGRAM CONSISTS OF 3 FILES ASSEMBLED TOGETHER AS ONE SUBPROGRAM:
  1. S.MAC - THE USUAL SYSTEM SYMBOL DEFINITIONS ASSEMBLED WITH
	EVERY MONITOR SUBPROGRAM
  2. CONFIG.MAC - THE CONFIGURATION DEFINITION FILE GENERATED BY THE
	CONFIGURATION PROGRAM (MONGEN) OR BY AN EDITOR (SEE ABOVE)
  3. COMMON.MAC - THE REST OF THIS PROGRAM WHICH IS THE SAME SOURCE FOR
	ALL CONFIGURATIONS.  HOWEVER, THE ASSEMBLIES ARE CONDITIONED BY
	SYMBOLS AND MACROS DEFINED IN 2.

	THE FOLLOWING SYMBOLS AND TABLES ARE GENERATED BELOW:

	A. MONITOR STARTUP LOCATIONS (140-147), HENCE LOAD THIS FIRST.
	B. JOB TABLES - LENGTH DEPENDENT ON MAXIMUM NUMBER OF JOBS ALLOWED
	C. ALL VARIABLE STORAGE NOT ASSOCIATED WITH A PARTICULAR DEVICE
	D. COMMON SUBROUTINE RETURNS
	E. COMMON BYTE POINTERS
	F. TABLE OF SERVICE ROUTINE INTERRUPT LOCS TO BE LINKED BY ONCE ONLY CODE
	G. TABLE OF DEVICE DATA BLOCK ADDRESSES AND NUMBER TO BE USED BY ONCE TO
		LINK THEM TOGETHER AND GENERATE MULTIPLE COPIES.
        H. ASSIGNMENT OF PI CHANNELS
	I. PI CHANNEL SAVE AND RESTORE ROUTINES
	J. M TRAP LOCATIONS 40/41, 60/61
	K. SYSTEM CRASH STOP CONI'S.
	L. CONFIGURATION DEPENDENT CODE FOR CERTAIN DEVICES AND THE SWAPPER.

LEVEL D DISK SERVICE PARAMETERS:

  ALL SYMBOLS AND LOCATIONS ARE IN A SEPARATE FILE CALLED
  COMMOD.MAC WHICH IS ALSO ASSEMBLED WITH S AND CONFIG (BUT NOT WITH FEATURS FILES).
  THE SEPARATE FILE IS FOR TWO REASONS:
    1.  ANTICIPATING MULTIPROCESSING SYSTEMS WHICH SHARE DISKS AND 1 16K MEMORY
        (THE DATA MUST BE IN THE COMMON MEMORY)
    2.  ELIMINATE THE NEED TO ASSEMBLE COMMOD IF NOT A DISK SYSTEM
        (COMMOD.MAC TAKES LOTS OF CORE FOR ITS COMPLICATED MACROS)
  HOWEVER, THE TWO FILES MAY BE ASSEMBLED TOGETHER IF DESIRED.
  TO DO THIS, COMMON.MAC MUST PRECEED COMMOD.MAC, AND SYMBOL FTCMBTH MUST BE DEFINED.
  THUS, A COMMAND STRING WOULD BE

	.R MACRO
	*COMMON,COMMON/C_TTY:,DSK:S,CONFIG,COMMON,COMMOD
	FTCMBTH==0
	^Z

	END OF PASS 1

	FTCMBTH==0
	^Z
>
;THE FOLLOWING STANDARD SYMBOLS CAN BE SUPERCEDED BY A CUSTOMER HAVING
; PREVIOUSLY DEFINED THEM ON THE CONFIG.MAC FILE

NDL LISTSN,1	;FORCE THE S.MAC FILE TO BE LISTED ON THE FRONT OF
		; COMMON (UNLESS LISTSN DEFINED TO BE 0 WITH MONGEN)

ND AXXDVN,<BYTE(3)0(9)502(6)0(18)1000>	;DEC Monitor version
ND A00CVN,<BYTE(6)'P'(9)034(6)'P',0(9)0> ;Customer version P034/P00
IFNCPU(F3),<ND DEFDEB,DF.RJE!DF.RDC>	;Reload on JOB and DEBUG stopcodes
ND DEFDEB,0		;Default setting for DEBUGF
ND DEFBPT,0		;Default setting for SET EDDT ON/OFF

				;STANDARD MAG TAPE DENSITY
IFNDEF STDENS, <XP STDENS,3>	;STANDARD == ODD PARITY ("BINARY" MODE) AT 800 BPI
				;STDENS,D
				;D=1 (200 BPI), OR D=2 (556 BPI), OR D=3 (800 BPI)

				;NUMBER OF CLOCK TICKS (JIFFIES) PER SECOND

				;NUMBER OF NANO-SECONDS PER MEMORY CYCLE
IFNDEF NSPMEM, <XP NSPMEM,^D1000>	;STANDARD == 1000 NANO-SECONDS PER MEMORY CYCLE



				;NUMBER OF TIMES TO TRY ON DECTAPE ERRORS
IFNDEF DTTRY, <XP DTTRY,4>	;STANDARD == 4 TRIES

				;SIZE OF MAGTAPE RECORDS (DATA WORDS IN BUFFER)
IFNDEF MTSIZ, <XP MTSIZ,^D128>	;STANDARD == 128 WORDS PER BUFFER

				;SIZE OF LPT BUFFER (NUMBER OF DATA WORDS+2)
IFNDEF LPTSIZ, <XP LPTSIZ,^D24+2>	;STANDARD == 24 WORDS PER LPT BUFFER

				;MAXIMUM NUMBER OF CONSECUTIVE DECTAPE BLOCKS TO BE
				; SEARCHED BEFORE RESCHEDULING IF ANOTHER JOB IS
				; WAITING TO USE THE DECTAPE CONTROL.
IFNDEF BLKQNT, <XP BLKQNT,^D50>	;STANDARD == 50 DECTAPE BLOCKS SEARCHED (3 SECS.)

IFNDEF M.SQTA,<XP M.SQTA,^D8> ;STANDARD == ^D8 PAGE TO SWAP IN AT, LIMIT SWAP RATE. (obsolete /AAA)
				; A TIME.
IFNDEF M.IQTA,<XP M.IQTA,0>;STANDARD == ONE I/O PGE FOR EVERY FOURTH JOB. (never implemented /AAA)
				; (ZERO UNTIL BUG IS FIXED)
IFNDEF M.SBSZ,<XP M.SBSZ,0>	;SNOOP BUFFER SIZE. STANDARD=NONE

IFNDEF AGESIZ,<XP AGESIZ,^D3>	;STANDARD = 3 BITS PER AGES CELL

IFNDEF SHRFPG,<XP SHRFPG,0>	;EXPECTED SHARED FILE PAGES..SET
				;NON-ZERO IN CONFIG FOR SYSTEMS WHOSE
				;LOADS INCLUDE ALOT OF FILE PAGE SHARING. /AAA

IFNDEF FHIN,<XP FHIN,^D22>	;STANDARD = 22 FRAME HANDLE SLOTS PER FRAME
IFNDEF OPNFPF,<XP OPNFPF,^D10>	;STANDARD = 10 OPEN FILES/FRAME AVERAGE ESTIMATE

ND TIMZON,^D<-8>		;Default to Pacific Standard Time

FHD1==170		;DEVICE CODE FOR FIRST FIXED HEAD CONTROLLER
FHD2==174		;            FOR SECOND FIXED HEAD CONTROLLER
DPC1==250		;DEVICE CODE FOR FIRST DISK PACK CONTROLLER (RP02)
DPC2==254		;            FOR SECOND DISK PACK CONTROLLER
LPT1==124		;DEVICE CODE FOR FIRST LINE PRINTER
LPT2==234		;            FOR SECOND LINE PRINTER
LPT3==230		;            FOR THIRD LINE PRINTER
LP0==LPT1
LP1==LPT2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	DEFINE SYSDEV
<	SIXBIT	"DSK">
	DEFINE SYSNAM
<IFNDEF SYSX0L,<EXTERNAL SYSX0L,SYSX0R,SYSX1L,SYSX1R,SYSX2L
	EXTERNAL SYSX2R,SYSX3L,SYSX3R,SYSX4L,SYSX4R>
	SYSX0L,,SYSX0R
	SYSX1L,,SYSX1R
	SYSX2L,,SYSX2R
	SYSX3L,,SYSX3R
	SYSX4L,,SYSX4R>

	DEFINE SYSDAT
<IFNDEF SYSX5L,<EXTERNAL SYSX5L,SYSX5R,SYSX6L,SYSX6R>
	SYSX5L,,SYSX5R
	SYSX6L,,SYSX6R>

XP DSKN,1		;SYSTEM HAS DISK DRIVES
XP PMEMSZ,^D512
IFCPU(<KI,KL>),<
  IFNDEF CHNN,<XP CHNN,0>
  IFNDEF SAXN,<XP SAXN,1>
  > ; End IFCPU(<KI,KL>)
IFCPU(<KS,F3>),<
  IFNDEF CHNN,<XP CHNN,1>
  IFNDEF SAXN,<XP SAXN,0>
  > ; End IFCPU(<KS,F3>)

IFNCPU(F3),<IFNDEF APXN,<XP APXN,0>>
IFCPU(F3),<IFNDEF APXN,<XP APXN,1>>

IFNDEF RA10N,<XP RA10N,0>
IFNDEF RP10N,<XP RP10N,0>
IFNDEF RD10N,<XP RD10N,0>

IFNCPU(<KS,F3>),<
  IFNDEF MAGN,<XP MAGN,0>
  IFNDEF MAGUN,<XP MAGUN,0>
  > ; End IFNCPU(<KS,F3>)
IFCPU(<KS,F3>),<
  IFNDEF MAGN,<XP MAGN,1>
  IFNDEF MAGUN,<XP MAGUN,1>
  > ; End IFCPU(<KS,F3>)

IFCPU(KS),<
  IFNDEF LPTN,<XP LPTN,1>	;On 2020, assume LPT unless told otherwise
  IFE LPTN,<XP LPRUN,0>		;If no device, # units = zip
  IFG LPTN,<XP LPRUN,1		;# of units - current max. of one
	XP LPRVEC,754> ;End IFG LPTN
  > ;End IFCPU(KS)
IFCPU (F3),<IFNDEF LPTN,<XP LPTN,0>>
IFCPU (<KI,KL>),<IFNDEF LPTN,<XP LPTN,1>>

IFCPU (KI),<
  IFNDEF PTRN,<PTRN==1>
  IFNDEF PTPN,<XP PTPN,1> >
IFNCPU(KI),<
  IFNDEF PTRN,<PTRN==0>		;NOT GLOBAL BECAUSE OF DSKSER USE
  IFNDEF PTPN,<XP PTPN,0> >
IFNDEF PLTN,<XP PLTN,0>
IFNDEF CDRN,<XP CDRN,0>
IFNDEF CR10N,<XP CR10N,0>

IFNDEF NUMPRT,<XP NUMPRT,0>
IFNDEF COREN,<XP COREN,^D8>

COMMENT ! FREE CORE ALLOCATION CALCULATIONS.  ALLOCATE FOR
	DSK DDB'S, BLOCK IO BUFFERS, SPT SECTIONS, ETC.
!

INTERNAL BIOCOR
EXTERNAL DDBCOR			;NUMBER FREECORE BLOCKS PER DDB
EXTERNAL SPTNME,SPTSIZ
XP CORSIZ,4		;NO. OF WORDS IN MONITOR FREE CORE BLOCKS
XP BIOSIZ,<^D6+^D100>	;BLOCK I/O BUFFER SIZE
			;(HEADER + DATA AREA)
XP BIONUM,^D10		;NO. OF PORTS CONFIGURED FOR BLOCK I/O
BIOCOR==<BIOSIZ+CORSIZ-1>/CORSIZ  ;NO. OF 4WD BLOCKS FOR BIO BUFFER.
IF2,<
IFDEF FCWDS,<
DDBWDS==OPNFPF*DDBCOR*CORSIZ	;ESTIMATE OPNFPF DDB'S PER FRAME
EFCWDS==JOBN*DDBWDS
IFL JOBN-6,<EFCWDS==6*DDBWDS>	;PUT FLOOR UNDER FCWDS IF JOBN.LT.6
RMTWDS==NUMPRT*^D65		;CORE FOR REMOTE BASE
BIOWDS==<BIOSIZ/2>*BIONUM	;FREECORE NEEDED FOR BLOCK IO BUFFERS
SPTWDS==<SHRFPG/SPTNME>*SPTSIZ	;(VERY) ROUGH EST. OF SPT FREECORE
EFCWDS==EFCWDS+BIOWDS+SPTWDS+RMTWDS
;IFL FCWDS-EFCWDS,<PRINTX FCWDS IS SMALLER THAN THE ESTIMATE EFCWDS
;>
>;END IFDEF
IFNDEF FCWDS,<FCWDS==0
>;END IFNDEF
>;END IF2

IFNDEF INDPPN,<XP INDPPN,777777>	;NON-ZERO IF CUSTOMER WANTS PROGRAMMER NOS
				; IN PROJECT X TO BE INDEPENDENT OF THOSE IN PROJECT Y

;NOTE--IN ORDER TO RESERVE PI-CHANNELS FOR
;NON-STANDARD USAGE, FOR EACH CHANNEL (SAY N)
;DEFINE SYMBOL UNIQN==1 VIA CONFIG.  FOR
;EXAMPLE, TO RESERVE CHANNEL 4, DEFINE
;UNIQ4==1.


;DEFINE PARAMETERS THAT SPECIFY SIZE OF CORTAB, NUMBER OF BITS PER
;ENTRY, AND BYTE POINTERS FOR CORE ALLOCATION ROUTINES

INTERNAL CTNMCI,CTNBSA,CTNBPW

CTNBPE==1	;NUMBER OF BITS PER ENTRY IN CORTAB
		;MUST EVENLY DIVIDE 36 AND BE 1 OR A POWER OF TWO
CTNMCI==1	;PUT THIS IN CORTAB TO INDICATE A BLOCK IN USE BY MONITOR OR NXM

CTNBPW==^D36/CTNBPE
		;NUMBER OF BYTES/WORD

Z1==0
Z2==CTNBPE

	XLIST
REPEAT Z2/2,<
Z2==Z2/2
IFN Z2,<Z1==Z1+1>
>
	LIST

CTNBSA==Z1	;THE LARGEST POWER OF TWO IN CTNBPE

DEFINE NMCLC (SET,DE,X,U)
<$U==0
IRP U,<IFE X-$U,<SET==DE'U'UN>
	$U=$U+1>>

DEFINE CHNCLC (DE,NUM)
<$UU==0
	REPEAT NUM,<
	NMCLC (XX,DE,\$UU,<A,B,C,D,E,F,G>)
	IFN XX,<ALLKON==ALLKON+1>
	$UU==$UU+1>>

ALLKON==0
	CHNCLC (FH,RD10N)
	CHNCLC (DP,RP10N)
	CHNCLC (MD,RA10N)


;PERFORM TRANSLATION FROM HARDWARE TO SOFTWARE DESIGNATION
; FOR ALL DISK SYMBOLS

	FHDN==RD10N
	DPCN==RP10N
	MDFN==RA10N

	LOC 137
	CONFIG		;ALWAYS A POINTER TO CONFIGURATION
	RELOC


;SYSTEM INITIALIZATION DISPATCH TABLE, STARTING AT LOCATION 140
;THIS SUBROUTINE MUST BE LOADED FIRST
;ROUTINE "ONCE" IS ONCE ONLY CODE. IT CONVERTS THE DATE
;AND SETS UP I/O SERVICE CHAIN,

	COMORG==140		;ORIGIN OF COMMON IS 140
	LOC COMORG		;MAKE LISTING BE SAME AS LOADING SO IT WILL BE EASY
				; TO EXAMINE SYSTEM LOCATIONS WITH CONSOLE SWITCHES
				; WITHOUT NEEDING A STORAGE MAP

SYSDSP::JRST ONCGO##	;(140) INITIALIZE SYSTEM VARIABLES ONCE ONLY
SYSDDT::JRST PATSYM##	;(141) PATCH SYMBOL TABLE POINTER, THEN ENTER EXEC DDT
	JRST SYSZRO##	;(142) ONCE CODE TO ZAP EDDT & SYMBOL TABLE.
	HALT .		;(143) INITIALIZE SYSTEM VARIABLES ALWAYS
	HALT .		;(144) ERROR RECOVERY
	HALT .		;(145) DO ONCE ONLY CODE OVER AGAIN
SYSBTS::JRST BOTLOD##	;(146) Reload BOOTS from HOM pages on disk
S..147::JSR  CRS147	;(147) CRASH, without STOPCD printout ;;SYSINA+4

; Macro to setup buffers if they fit between the current point
;  and the specified location.

	DEFINE MAKBUF (NAM,SIZ,LOC)
<IF1,<IFNDEF NAM,<IFGE LOC-<.+SIZ>,<NAM:	BLOCK SIZ>>>
IF2,<IFE <.-NAM>,<NAM:	BLOCK SIZ>>>

DEFINE BUFS (LOC)<

	MAKBUF (IRING,1_SIZIRG,LOC)
	MAKBUF (ORING,1_SIZORG,LOC)

    IFN NUMPRT,<
	MAKBUF (QTOST,^D48,LOC)
	MAKBUF (RMTDDP,NUMPRT,LOC)
	MAKBUF (QPRTST,NUMPRT,LOC)
    >;END IFN NUMPRT

>

;MACROS TO GENERATE KS10 VFU LOADING DATA.
;CODE COPIED FROM T10 MODULE LP2SER
DEFINE MOD(A,B),<A-<<A/B>*B>>
..BC==0
..B==0
DEFINE OUTBYT(C),<
..C==C
..BC==..BC+1
IFE ..BC-1,<..C==<..C&377>_<^D18>>
IFE ..BC-2,<..C==<..C&377>_<^D26>>
IFE ..BC-3,<..C==<..C&377>>
IFE ..BC-4,<..C==<..C&377>_<^D8>>
..B==..C!..B
IFE ..BC-4,<EXP ..B
	    ..BC==0
	    ..B==0>
>;OUTBYT MACRO DEFINITION
DEFINE LASBYT,<
IFN ..B,<EXP ..B
>
>;LASBYT MACRO DEFINITION
DEFINE VFUBIT(LINE),<
..BT==0
IFE LINE,<..BT==..BT!1>		;;LINE 0 GETS CH. 1
IFE MOD(LINE,36),<..BT==..BT!2>	;;EVERY 30 LINES GET CH. 2
IFE MOD(LINE,4),<..BT==..BT!4>	;;EVERY 4TH LINE GETS CH. 3
IFE MOD(LINE,3),<..BT==..BT!10>	;;EVERY 3RD LINE GETS CH. 4
IFE MOD(LINE,12),<..BT==..BT!40>	;;EVERY 10TH LINE GETS CH. 6
IFLE LINE-<LPTLPP-1>,<..BT==..BT!20>	;;ALL LINES.LE.LINES/PAGE GET CH. 5
IFGE LINE-LPTLPP,<..BT==20>	;;LINES ABOVE LINES/PAGE GET ONLY CH. 5
OUTBYT(..BT)
..BT==0
IFE MOD(LINE,24),<..BT==..BT!1>	;;EVERY 20TH LINE GETS CH. 7
IFLE LINE-<LPTLPP-1>,<..BT==..BT!2>	;;LINES 0-LINES/PAGE GET CH. 8
IFE LINE-<LPTLPP-1>,<..BT==..BT!40>	;;LAST LINE ON PAGE GETS CH. 12
IFGE LINE-LPTLPP,<..BT==0>	;;LINES ABOVE LAST GET NOTHING
OUTBYT(..BT)
>;VFUBIT MACRO DEFINITION

IFN NUMPRT,<
XP MNUMPT,-NUMPRT
INTERNAL QPRTST,RMTDDP,QTOST,LIVWRD,QFRMST

XP QTOND,<QTOST+^D23>
XP QFRMST,<QTOST+^D24>
XP QFRMND,<QTOST+^D47>
XP QPRTND,<QPRTST+NUMPRT-1>
>


IFNCPU(F3),<

IFNDEF SIZIRG,<XP SIZIRG,7>	;SIZE OF INPUT RING (AS POWER OF 2)
IFNDEF SIZORG,<XP SIZORG,10>	;SIZE OF OUTPUT RING (AS POWER OF 2)

	LOC 150		;GENERATE DATA LOCS FOR 620 BASE

KEY620:	0		;(150) FILLED WITH 63375150626 WHEN SYS UP
	0		;(151) ALARM CELL
DMP620:	0		;(152) PUT IN LOC FOR 620 TO DUMP CORE
	IRING_4		;(153) LOC OF INPUT RING (IN 620 FORMAT)
	1_<SIZIRG+4>	;(154) SIZE OF INPUT RING
IRPPDP:	0		;(155) PDP-10 POINTER TO INPUT RING
IRP620:	0		;(156) 620 POINTER TO INPUT RING
	ORING_4		;(157) LOC OF OUTPUT RING FOR 620
	1_<SIZORG+4>	;(160) SIZE OF OUTPUT RING
ORPPDP:	0		;(161) PDP-10 POINTER TO OUTPUT RING
ORP620:	0		;(162) 620 POINTER TO OUTPUT RING
D620FN:	-1		;(163) SET 0 BY 620 WHEN 10 COMES UP, NON-0 WHEN
			;      620 FINISHED DUMPING
LIVWRD:	BLOCK 1		;(164) Used by RMTSER if NUMPRT # 0
IFN NUMPRT,<QTOST_4>	;(165) if NUMPRT # 0
IFE NUMPRT,<0>		;(165) if NUMPRT = 0
	0		;(166) NOT USED
	0		;(167) NOT USED
;Locations 150-167 are BLT'ed to 170-207 when the system crashes.  /JMS
>;END IFNCPU(F3)

	LOC 170		;Even on the F3, so CRSHID can dump the rings
BASAVE::BLOCK 20	;(170-207) Copy of IRING/ORING pointers in crash

IFN SAXN,<
	LOC 300		;This location set by DIP switches on the SA-10
SAXBAS::BLOCK 40	;4 words per channel, 4 channels per SA-10, 2 SA-10s
  SA0BAS=:SAXBAS	;SA #0 (TYMCOM-X uses only channels 0 and 1)
  SA1BAS=:SA0BAS+20	;SA #1 (if any)
>;END IFN SAXN
	LOC 340
SASAVE::BLOCK 40	;340-377 Copy of SAXBAS in crash


IFN RA10N!RP10N!RD10N,<
	LOC	540		; Channel command words (for now)
	LOC <.+1>&777776	;GET TO EVEN LOC FOR CHANNEL COMMAND WORDS
LOCOCW:	BLOCK ALLKON*2

ifn <.+200>&777000,<PRINTX *** CHANNEL COMMAND WORDS PAST 600 ***>
ifn <.&777000>,<PRINTX *** CHANNEL COMMAND WORDS OVERWRITING EPT ***
STOPI>
>  ;End of RA10N!RP10N!RD10N

%100=:100	;Symbols for DDT
%200=:200
%400=:400
%600=:600
%1000=:1000
%2000=:2000
%3000=:3000
%4000=:4000

	LOC 1000
EPT:	BLOCK 1000		;EPT in locations 1000-1777
IFCPU(F3),<;GENERATE F3 BASE LOCATIONS	(depends on LOC 2000)

IFNDEF SIZIRG,<XP SIZIRG,7>	;SIZE OF INPUT RING (AS POWER OF 2)
IFNDEF SIZORG,<XP SIZORG,10>	;SIZE OF OUTPUT RING (AS POWER OF 2)

IFN SIZIRG-7,<PRINTX F3 INPUT RING SIZE MUST BE 200 OCTAL
STOPI>
IFN SIZORG-10,<PRINTX F3 OUTPUT RING SIZE MUST BE 400 OCTAL
STOPI>

KEY620:	0		;(2000) Set to 63375150626 when system is up
BBORQ:	0		;(2001) BLOCK I/O REQUEST STORAGE WORD FOR UCODE
BBOIO:	0		;(2002) BLOCK I/O IO WORD FOR MICROCODE
	IRING_4		;(173) LOC OF INPUT RING (for CRSHID, ignored by uCODE)
	1_<SIZIRG+4>	;(174) SIZE OF INPUT RING (for CRSHID, ignored by uCODE)
IRPPDP:	0		;(2005) HOST IRING POINTER
IRP620:	0		;(2006) BASE IRING POINTER
	ORING_4		;(177) LOC OF INPUT RING (for CRSHID, ignored by uCODE)
	1_<SIZORG+4>	;(200) SIZE OF INPUT RING (for CRSHID, ignored by uCODE)
ORPPDP:	0		;(2011) HOST OUTPUT RING POINTER
ORP620:	0		;(2012) BASE OUTPUT RING POINTER
D620FN:	-1		;(2013) BASE NEVER DUMPS IN PDP-10 MEMORY
LIVWRD:	0		;(2014) Unused if NUMPRT = 0
	0		;(2015) QTOST_4 if NUMPRT # 0
	0		;(2016) NOT USED
	0		;(2017) NOT USED
;Locations 2000-2017 are BLT'ed to 170-207 when the system crashes.  /JMS
			;(2020-2200) unused

	LOC 2200	;LOCATION FIXED BY F3 MICROCODE
IRING:	BLOCK	200	;SIZE FIXED BY F3 MICROCODE
ORING:	BLOCK	400	;SIZE FIXED BY F3 MICROCODE

	LOC 3000	;LOC 2000 for all but F3
>;END IFCPU (F3)

IFCPU (KI),<XP NULUPL,1000>	;KI ONLY NEEDS ONE PAGE FOR NULL UPT
IFNCPU(KI),<XP NULUPL,2000>	;KLKS NEEDS MORE, MORE STUFF RESERVED FOR HARDWARE.
PRINTF(<[Need to consider making NULUPL 3 pages for CRASH]>)

UPT:	BLOCK NULUPL	;KI=2, KL=2&3, KS=2&3, F3=3&4
IFCPU (KS),< IFG LPTN,<	;PAGE ALIGNED DATA USED BY KS10 LPT DRIVER.
;THIS DATA MUST ALL FIT INTO ONE PAGE OR LPTSER MUST
; BE CHANGED TO USE MORE THAN ONE PAGING RAM LOCATION
IFNDEF LPTLPP,<LPTLPP==^D60>	;default lines/page is 60
IFNDEF LPTFS,<LPTFS==^D66>	;default form size is 66
NXDLPT::EXP LPRUN		;IF 0 THEN LPT IS A NON-EXISTANT DEVICE
LPVLPT::VLDATL,,<<.&777>*4>+4	;output pointer to load DAVFUQ
	XWD 356,37437		;start code,,channels 1-11
	REPEAT <<LPTFS-4>/2>,<	;this sets up most of the lines
	XWD 37037,37037		;generate 2 DAVFU lines w/ ch2-ch11
	>;REPEAT
	IFE MOD(LPTFS,2),<XWD 37037,37077
			  XWD 167400,0>;for even form sizes
	IFN MOD(LPTFS,2),<XWD 37077,16740>;for odd form sizes
VLDATL==.-LPVLPT-1
	BLOCK ^D46-VLDATL	;leave room for form sizes up to ~88/GL
LPCFPT::1,,<<.&777>*4>+4
	BYTE (2) 0 (8) 14,15
NEWTOF::1,,<<.&777>*4>+4	;new top of form /GL
	BYTE (2) 0 (8) 357,0	;stop byte /GL
LPTEPT::LTEDAT,,<<.&777>*4>+4
REPEAT ^D16,<BYTE (2) 0 (8) "8","8" (2) 0 (8) "8","8">
	BYTE (2) 0 (8) 12,15
LTEDAT==.-LPTEPT-1

IFN LPTN-1,<PRINTX LPT BUFFER ALLOCTION DONE FOR ONLY ONE PRINTER.>
LPBSIZ==40
LPTBUF:	BLOCK <LPBSIZ*5>/4+1



>>;IFCPU KS, IFG LPTN

XP EPT.PN,<EPT_-9>
XP UPT.PN,<UPT_-9>


IFNCPU(KI),<XP EPTEBR,EPTFSL>		;WHERE TO DO CONO PAG FROM.

IFCPU (F3),<XP EPTACB,100>		;PLACE FOR F3 TO STORE NON-CURRENT AC BLOCKS

	LOC <.+777>&777000	;Page aligned for Rings in same page

	BUFS(10000)		;REMAINING BUFFERS

XP MSKIRG,<1_SIZIRG-1>
XP MSKORG,<1_SIZORG-1>

;Everything defined before here have fixed locations in absolute low core
SUBTTL	Start of relocatable COMMON (byte pointers, etc)

	STOPCD(,ENTRY,COMMON)	;Default for noname stopcodes

;LMAP AND UPT GENERATION

%UPT.V==UPTFSL		;START OF UPT LOCATIONS RELATIVE TO %UPT (440 or 600)
  UP%000=:%UPT+000	;User page map
  UP%200=:%UPT+200	;User HISEG map
  UP%400=:%UPT+400	;Funnyspace map
  UP%500=:%UPT+500	;Page fail words (KI uses 426)
  UP%600=:%UPT+600	;Stack and such  (KI uses 440)
  UP%PGT=:%UPT+UPTPGT	;Trap instructions (420-423)
  UP%MUU=:%UPT+UPTMUU	;UUO or illegal instruction stored here (424)
  UP%MUP=:%UPT+UPTMUP	;PC of UUO or illegal instruction (425)
  UP%KNT=:%UPT+UPTKNT	;Start of dispatch table (430-437)

;LMAP AND UPT MACROS
	SALL		;MAKE COMMENTS COME OUT IN SPITE OF MACRO BUG.

DEFINE UVAR(LABEL)<UARRAY(LABEL,1)>

DEFINE UARRAY(LABEL,SIZE)<
		XP LABEL,%UPT.V
		%UPT.V==%UPT.V+'SIZE
>;END UARRAY MACRO DEFINITION


;DEFINE UPT LOCATIONS
XP EPLLEN,176	;LENGTH EXEC PDL

;THE FOLLOWING LOCATIONS MUST BE IN THE FIRST ^D512 WORDS

	XP XACSTL,4	;LENGTH OF EXEC AC STACK
UARRAY(UPTAC0,<<20*XACSTL>+1>)	;MUST BE FIRST
	IFN UPTAC0&17,<PRINTX UPTAC0 MUST BE ON 20 WORD BOUNDARY>
  UP%AC0=:%UPT+UPTAC0	; XTRA WD IS FOR STACK POINTER OVERFLOW CASE
UVAR(UPTSTS)	;JOB IN CORE STATUS BITS18-35	STARTING ADDRESS IF STRTAD SET
	XP XPNCOR,1	;17	CORE NEEDS TO BE EXPANDED
	XP STRTAD,2	;16	RIGHT HALF CONTAINS A STARTING ADDRESS
	XP UPSCLK,4	;15	CLOCK SHOULD BE ON
	XP SAVCHG,10	;14	CHARGES ARE SAVED IN UPT
	XP REC.WR,20	;13	WRITE STREAM ACCTG RECORD NEXT EXIT
	XP LSAREC,40	;12	LOCAL STREAM ACCTG DONE
	XP SG.SWR,100	;11	CURRENT HISEG LOADED FROM .SWR FILE
	XP UPNPSR,^D10	;8-10	(POS) PENDING STREAM REC TYPE
	XP UPSPSR,^D3	;	(SIZ) SEE START CMD AND USRXIT
	XP UPSSWE,2000	;7	JOB GOT SWAP ERROR FOR USER PAGE
			;	WHILE IT OWNED DISK RESOURCE, AND
			;	JBTABT NOT SET UP. UTRP SET WITH
			;	THIS BIT SO USRXIT SEES IT.
	XP UPSABK,4000	;6	ADDRESS BREAK DURING UUO.
	XP STRTCL,10000	;5	INCREMENT START ADDRESS BEFORE USING IT.
			;0-4	(UNUSED)

 UPYPSR::POINT UPSPSR,%UPT+UPTSTS,UPNPSR ;POINTER TO PENDING STREAM REC TYPE
 USYPSR::POINT UPSPSR,%UPS+UPTSTS,UPNPSR ; One for %UPS
 UXYPSR::POINT UPSPSR,%UPX+UPTSTS,UPNPSR ; One for %UPX

UVAR(UPTJOB)		;HAS JOB NUMBER OWNING THIS UPT
UVAR(UPTPC)		;HAS THE JOB'S PC WHEN NEXT SET TO RUN
  UP%PC=:%UPT+UPTPC
UVAR(UPTACP)		;STACK POINTER TO SAVED EXEC AC'S
UVAR(UPTLDC)		;COUNT OF NUMBER OF LMAP SLOTS KEPT IN ACS FROM THIS UPT
UVAR(UPTABK)		;ADDRESS BREAK WORD.
UVAR(UPTUUO)		;Top level MUUO (called from user mode)
  UP%UUO=:%UPT+UPTUUO
UARRAY(UPTPDL,EPLLEN)	;SYSTEM UUO PDL FOR CURRENT JOB
  UP%PDL=:%UPT+UPTPDL
IFG <%UPT.V-NULUPL>,<PRINTX EPLLEN TOO LARGE> ;THE ABOVE UPT LOCATIONS
				;MUST FIT INTO THE NULL JOB'S UPT, WHICH
				; IS SHORTER THAN NORMAL ONES.
	XP NUMCHN,^D48		;MAX NUMBER OF IO CHANNELS
	XP MAXCHN,<NUMCHN-1>
UARRAY(UPTJDA,NUMCHN)	;RH==DDB ADDRESSES (JOB DEV ASSIGNMENTS)
  UP%JDA=:%UPT+UPTJDA	;LH= VARIOUS STATUS BITS FOR CHANNEL:
			;(INITB,LOOKB,ICLOSB..ETC SEE S.MAC)
UARRAY(UPTSIM,NUMCHN)	;SIMULATED BUFF/DUMP MODE
			;IO DATABASE. LH=SEQUENCE STAMP. RH=
			;SIMIO STATUS BITS+PAGE NUMBER FIELD
UARRAY(UPTPOS,NUMCHN)	;BLOCK POSITION IN (DSK) FILE ON THIS CHANNEL
;*;UARRAY(UPTPCN,^D32)	;DEBUG. PAGE CHANNEL NUMBER SIMIO
UVAR(UPTPBM)		;PAGE BIT MAP. BITS 0-31 SET IF PER-PROCESS
			;PGS 340-377 USED FOR SIMIO
UVAR(UPTIOC)	;SIMIO IO COUNT, FOR SEQ. STAMP
UARRAY(UPTXAC,20)	;EXEC ACS HERE WHEN JOB ISN'T RUNNING.
UARRAY(UPTUAC,20)	;USER ACS WHEN JOB ISN'T RUNNING (USED
  UP%UAC=:%UPT+UPTUAC	; TO BE AT PAGE 0)
	XP CHGSIZ,<^D22>
UARRAY (UPTCHG,CHGSIZ)	;SAVED TRU COMPONENTS. 17 PRE-P031

UVAR(UPTHCU)		;HIGHEST USER I/O CHANNEL IN USE.
UVAR(UPTENB)		;LH=UNUSED,RH=APR CONSO FLAGS FOR USER
			; APR TRAPPING.  SET BY APRENB UUO.
UVAR(UPTTPN)		;HAS TRAP NUMBERS FOR VARIOUS TRAPS
UVAR(UPTTP1)		;MORE TRAP NUMBERS
UVAR(UPTMTM)		;Micro-cycle interrupt timer
UVAR(UPTABL)		;SAVED LOCATION FOR ADDRESS BREAK (SO CAN REPORT WHERE UUO WAS)
UVAR(UPTUFI)		;USER WORKING SET PAGE FAULT INFORMATION
UVAR(UPTXFI)		;LIKE UFI, BUT FOR TIMES TRAP CAN'T HAPPEN
UVAR(UPTUEI)		;USER ERROR INFORMATION (FOR PAGES)
UVAR(UPTXEI)		;LIKE UEI, BUT USED WHEN TRAP CAN'T HAPPEN
UVAR(UPTURI)		;USER REF BIT TRAP INFO
UVAR(UPTXRI)		;LIKE URI, BUT USED WHEN TRAP CAN'T HAPPEN.
UVAR(UPTUII)		;ILL MEM REF, WRITE VIOL, ADDR BREAK INFO WORDS
UVAR(UPTXII)		; RETURNED BY PGISTS UUO.

  XP UPTTCB,UPTTPN	;FIRST LOC TO CLEAR IN APRENB
  XP UPTTCE,UPTXII	;LAST LOC.
UVAR(UPTREL)		;LH/0; RH/LOWSEG HI ADDR OR 0 IF NO LOWSEG
UVAR(UPTHRL)		;LH/0;  RH/HISEG HI ADDR, OR 0 IF NO HISEG
UVAR(UPTRNM)		;RESTRICTED COMMAND FILE NAME
UVAR(UPTRPN)		;RESTRICTED COMMAND FILE PPN
UVAR(UPTALD)		;ALTERNATE LOGOUT PROGRAM DEVICE
UVAR(UPTALP)		;ALTERNATE LOGOUT PROGRAM PPN
UVAR(UPTALN)		;ALTERNATE LOGOUT PROGRAM NAME
UVAR(UPTPJC)		;SESSION PROJECT CODE WORD 0
UVAR(UPTPJ1)		;WORD 1
UVAR(UPTPJ2)		;WORD 2,BIT 35 IS "LICENSE REQD" BIT
UVAR(UPTSAT)		;HAS STATUS BITS FOR + ADDR OF %SAT PCB.
UVAR(UPTRIB)		;HAS STATUS BITS FOR + ADDR OF %RIB PCB.
UVAR(UPTRB2)		;HAS STATUS BITS FOR + ADDR OF %RB2 PCB.
UVAR(UPTPID)		;PID FOR CURRENT PROGRAM - FROM RUN FILE'S PID.
UVAR(UPTSPD)		;SAVED PID, SO PIDSET UUO CAN SET IT TO 0 AND BACK

UVAR(UPTLOG)		;Originating Port for this frame.
  UP%LOG=:%UPT+UPTLOG
UVAR(UPTLKJ)		;JOB NUMBER OF JOB WHO OWNS CONTEXT PAGE WRITE LOCK FOR THESE CONTEXT PAGES
UVAR(UPTLKW)		;HEAD OF WAITERS FOR CTX PAGE WRITE INTERLOCK
UVAR(UPTOFD)		;FRAME DESCRIPTOR SET BY SETOTF UUO.
UVAR(UPTLKC)		;NUMBER OF TIMES OWNER OF LOCK CALLED FOR IT AGIN+1
			; (NESTED PAGE FAULTS INSIDE UUOS, ETC.)
UVAR(UPTETP)		;(0) CLASS,,TYPE WITHIN CLASS OF ERROR TRAP
XP UPTHST,UPTETP	;FIRST LOCATION OF HALT STATUS BLOCK
UVAR(UPTECN)		;(1) COUNT TO TELL HOW MANY ERRORS HAPPENED.
UVAR(UPTEPC)		;(2) PC OF ERROR TRAP
UVAR(UPTEUP)		;(3) PC OF LAST TOP LEVEL UUO PERFORMED
UVAR(UPTEDV)		;(4) DEVICE NAME, LOCATION, ETC.
UVAR(UPTELC)		;(5) LOCATION, OTHER DATA
UVAR(UPTEL1)		;(6) ANOTHER LOCATION FOR ERROR DATA.
XP FHSMXC,<UPTEL1-UPTHST+1> ;MAXIMUM COUNT

XP FHIMAX,FHIN-1	;MAXIMUM VALUE FOR INDEXING INTO UPTFHT

UARRAY(UPTFHT,FHIN)	;FRAME HANDLE ADDRESSES.

UARRAY(UPTS2P,.ARSIZ)	;BITS FOR ACCESS RIGHTS OF SELF OVER PARENT
UARRAY(UPTP2S,.ARSIZ)	;BITS FOR ACCESS RIGHTS OF PARENT OVER SELF
UARRAY(UPTMFR,.ARSIZ)	;MAX INWARD RIGHTS FOR THINGS THAT NEED CONTEXT PAGES IN.

UVAR(UPTSTV)		;CONTAINS SIZE,,START ADDRESS OF START VECTOR
;DEFINE LMAP LOCATIONS
UARRAY(UPTLMA,<VPMAX+1>);BASIC LMAP SLOT DATA, INDEXED BY VP
UARRAY(UPTMWB,<<VPMAX+1+^D35>/^D36>)
			;MONITOR WORKING SET BIT TABLE.
AGECPW==:<^D36/AGESIZ>
AGEMAX==:<<1_AGESIZ>-1>
UARRAY(UPTAGE,<<^D512+AGECPW-1>/AGECPW>)
			;PAGE AGE TABLE
UARRAY(UPTUWB,<<^D512+^D35>/^D36>)
			;USER WORKING SET BIT TABLE
UVAR(UPTUWS)		;USER WORKING SET DATA
			;CURRENT SIZE IS IN JBYUWS.
 UPYUWL::POINT 10,%UPT+UPTUWS,25	;CURRENT LIMIT
 USYUWL::POINT 10,%UPS+UPTUWS,25 ;ONE FOR %UPS
 UXYUWL::POINT 10,%UPX+UPTUWS,25 ;ONE FOR %UPX
 UPYUWM::POINT 10,%UPT+UPTUWS,35	;CEILING FOR CURRENT LIMIT
 USYUWM::POINT 10,%UPS+UPTUWS,35 ;ONE FOR %UPS
 UXYUWM::POINT 10,%UPX+UPTUWS,35 ;ONE FOR %UPX

UVAR(UPTNTV)		;TICKS UNTIL NEXT PAGE AGE RECOMPUTATION
UVAR(UPTMAT)		;# OF MATURE PAGES (AGE .GE. C(AGEMAT))
UVAR(UPTELD)		;# OF ELDERLY PAGES (AGE .GT. C(AGEELD))
UVAR(UPTRPT)		;POINTER FOR CIRCULAR PAGE REPLACEMENT ALGORITHM

UVAR(UPTRES)		;WORD FOR SWAPPER TO REMEMBER RESERVED PAGES
 USYSIN::POINT 10,%UPS+UPTRES,15	;NUMBER OF PAGES SWAPPED IN
			; FOR SETTING UP ICPT
 USYRES::POINT 10,%UPS+UPTRES,25	;NUMBER OF RESERVES PAGES JOB OWNS STILL
 USYLSP::POINT 10,%UPS+UPTRES,35	;LMAP SCAN POINTER (WHERE
			; SWAPPER STARTS SWAPPING IN ON A CYCLE

XP UPTEND,%UPT.V-1	;LAST LOCATION IN UPT TO CLEAR.
NCTXPG==:<%UPT.V!777+1>/1000
ONSZCK(CONTEXT,NCTXPG,CTX)	;CHECK TO SEE IF ENOUGH SPACE ALLOC FOR CTX PGS
VPUMAX==:VPMAX-NCTXPG	;MAXIMUM NON-CONTEXT PAGE VP

XP %UPT.N,VPUMAX+1-CNVVPN 	;START PAGE OF CONTEXT PAGES
XP %UPT,<%UPT.N_9>	;START ADDRESS OF CONTEXT PAGES IN UPT
XP %UPLMA,%UPT+UPTLMA	;THIS ADDR+VP GIVES LMAP SLOT DATA
XP %UPLMX,%UPX+UPTLMA	;DITTO FOR %UPX.

XP %COW.N,%UPT.N-1	;USED FOR COPY ON WRITE
XP %COW,<%COW.N_^D9>

;%UPX IS A SPECIAL SET OF PAGES THAT EITHER CONTAINS POINTERS IDENTICAL
; TO %UPT POINTERS IF THE SLOTS DON'T EXIST, OR LMAP SLOTS FOR
; ANOTHER FRAMES'S CONTEXT PAGES.

XP %UPX.N,%COW.N-NCTXPG	;PLACE FOR VIRTUAL UUOS THAT WORK ON OTHER FRAMES TO
			; ACCESS CURRENT CONTEXT PAGES
XP %UPX,<%UPX.N_^D9>

;ADD OTHER PERMANENTLY ALLOCATED EXEC PER PROCESS VALUES ABOVE HERE
XP %LEP.N,%UPX.N-1	;LAST DYNAICALLY ALLOCATED EXEC PER PROCESS PAGE

PBMMSK::-1_<340-%LEP.N+1>	;MASK FOR DYNAMIC ALLOCATER.
				; 1 MEANS IN USE.

XP %UPS.N,EVPMAX-NCTXPG+1	;FIRST EPT PAGE NUMBER THAT CONTEXT PGES MAPPED IN
XP %UPS,<%UPS.N_9>	;FIRST CONTEXT PAGE ADDRESS IN EPT
XP %UPLMS,%UPS+UPTLMA	;THIS ADDR PLUS VP GIVES 36 BIT LMAP SLOT DATA

UPYPTN:: UPMPTR(%UPT.N)		;
UPYPTM:: UPMPTR(%UPT.N-1)	; (CORE1)
UPYPXN:: UPMPTR(%UPX.N)		;
UPYPXM:: UPMPTR(%UPX.N-1)	; (CORE1)

USYPTN:: UPSPTR(%UPT.N)		; (ONCE)(CORE1)
USYPXN:: UPSPTR(%UPX.N)		;
USYPTM:: UPSPTR(%UPT.N-1)	;
USYPXM:: UPSPTR(%UPX.N-1)	; (SCHED1)

UXYPTN:: UPXPTR(%UPT.N,%UPT)	;
UXYPTM:: UPXPTR(%UPT.N-1,%UPT)	; (COMCON)

EPYPSN:: EPTPTR(%UPS.N)		; (ONCE)(PICON)(UUOCON)
EPYPSM:: EPTPTR(%UPS.N-1)	; (CORE1)(SCHED1)
;LMAP BIT DEFINITIONS

XP LMPSHR,400000	;SHARED (OFF IS UNSHARED)

XP LMSCUR,2		;SIZE OF PROTECTION FIELD
XP LMNCUR,2		;BIT POSITION
XP LMPCUR,(1B<LMNCUR>)	;THE BIT

LMYCUR:: POINT LMSCUR,%UPLMA(W),LMNCUR ;CURRENT PROTECTION: WRITE,
			;COW, OR READ ONLY.
LM3CUR:: POINT LMSCUR,P3,LMNCUR
	XP CPRRED,1
	XP CPRCOW,2
	XP CPRRDW,3
	XP MAXCPR,CPRRDW	;MAXIMUM DEFINED PROTECTION.
XP LMMCUR,300000	;DEFINED ONLY BECAUSE OF LMMEXS.
XP LMMEXS,LMPSHR!LMMCUR ;IF ALL OF THE MASKED BITS ARE OFF,
			;THE PAGE IS NON-EXISTENT.
XP LMPACT,40000		;ACTIVE (SEMI IN-CORE BIT)
XP LMPMXW,20000		;MAXIMALLY WRITEABLE
  XP LMMMXW,LMPMXW!LMMCUR ; For use as Maximally writeable MASK
  XP LMMRED,LMPMXW!(<CPRRDW>B<LMNCUR>) ; Max WRITE, READ ONLY
  XP LMMRDW,LMPMXW!(<CPRRDW>B<LMNCUR>) ; PROTOTYPE LMAP SLOT
XP LMPREF,10000		;REF
XP LMPVIR,4000		;VIRGIN
XP LMPDER,2000		;DEVICE ERROR
XP LMPDTE,1000		;DATA ERROR
 XP LMMERR,LMPDER!LMPDTE ;MASK
LMYERR::POINT 2,%UPLMA(W),^L<LMPDTE>-^D18 ;SWAP ERROR BITS
LM3ERR::POINT 2,P3,^L<LMPDTE>-^D18	;ONE FOR P3
XP LMPSUP,400		;THIS IS A SUPER MAPPED PAGE.
  XP LMMSUP,LMPSUP!LMMMXW ; Super mapped, Maximally writeable MASK
XP LMPNER,200		;IGNORE I/O ERROR ON THIS PAGE.
XP LMPLOK,100		;SLOT IS LOCKED IN CORE (NEVER DEACTIVATED EXCEPT IN REMOVE)


LMYOVR: POINT ^D23,%UPLMA(W),^D35 ;AN AREA OF THE LMA SLOT
			; THAT IS SHARED BY LMYLMA, LMYSPT, LMYATB, AND
			; LMYHDA.
LM3OVR: POINT ^D23,P3,^D35
 LMYOV1: POINT ^D13,%UPLMA(W),^D25
 LM3OV1: POINT ^D13,P3,^D25
 LMYOV2: POINT ^D10,%UPLMA(W),^D35
 LM3OV2: POINT ^D10,P3,^D35

;THE FOLLOWING FIELDS EXIST IN AN ACTIVE LMAP SLOT.

XPP LMYLMA,LMYOVR	;LINK OF PGYLMA CHAIN.ITS FORM IS
			; THAT OF A JOB-VM PNTR. THE END OF
			; THE CHAIN HAS A ZERO (THE SPT ENTRY
			; ADDR IS IN PGYSPT, SEE BELOW.).
 XPP LMYLMJ,LMYOV1
 XPP LMYLMV,LMYOV2
 XPP LM3LMJ,LM3OV1
 XPP LM3LMV,LM3OV2

;THE FOLLOWING FIELDS EXIST IN AN INACTIVE SHARED LMAP SLOT.

XPP LMYSPT,LMYOVR	;AN SPT-ENTRY PNTR.
XPP LM3SPT,LM3OVR
 LMYSPB::POINT 18,%UPLMA(W),31 ;BASE ADDRESS OF SPT SECTION
 LM3SPB::POINT 18,P3,31		;SAME, BUT IN P3
 LMYSPO::POINT 4,%UPLMA(W),35	;OFFSET INTO ENTRIES OF THIS ENTRY
 LM3SPO::POINT 4,P3,35		;ONE FOR P3

;THE FOLLOWING FIELDS EXIST IN AN INACTIVE UNSHARED LMAP SLOT.

XPP LMYATB,LMYOV1	;ADDR OF THE ATB. (REALLY AN OFFSET FROM
			;THE START OF A CORE STORAGE AREA.).
XPP LM3ATB,LM3OV1
XPP LMYHDA,LMYOV2	;HIGH PART OF THE DISK ADDRESS. (TOTAL
			; DISK ADDRESS REQUIRES
			; 8 BITS FOR UNIT FIELD AND 19 BITS FOR
			; PAGE NUMBER.).LOW PART OF DISK ADDR
			; IS IN UPT AT THIS POINT.
XPP LM3HDA,LM3OV2

XP LMASRP,^D17		;LSH BY THIS TO GET RID OF LOW 17 BITS,
			; OBTAINING HI ORDER DISK ADDRESS.

;PARTS OF LMAP IN UPT MAP AREA

UP4LDA::POINT 17,P4,35	;LOW ORDER PART OF DISK ADDRESS


;END OF LMAP/UPT DEFN'S
;define paging ram indexes for tape and KMC on 2020

IFCPU(KS),<			;DEFINE THE PAGING RAM INDICES FOR TAPE
IFNDEF LPTBAS,<LPTBAS==0>	;PDP11 PAGE RESERVED FOR LPT
XP UBATAP,<LPTBAS_-9>+1
>;END IFCPU(KS)

IFCPU(KS),<			;DEFINE THE PAGING RAM INDICIES FOR KMC
XP UBACM0,UBATAP+^D32		;SET CM 0 ADDRESS INDEX FOR PAGING RAM
XP UBAEND,^D64			;END OF PAGING RAM
XX==0
IFG 1000-<ORING+<1_SIZORG>>,<	;IF BOTH RINGS FIT INTO PAGE 0
	XP UBANXT,UBACM0+1	;SET RAM INDEX FOR BLOCK IO AFTER RINGS
	XP UBIRBG,UBACM0	;SET IRING BEGIN TO PAGE 0
	XX==1>
IFL IRING-1000,<XP UBIRBG,UBACM0>;SET INDEX FOR START OF IRING
IFGE IRING-1000,<XP UBIRBG,UBACM0+1>
IFE XX,<			;ELSE RINGS DONT FIT IN PAGE 0
	XX==<<ORING+<1_SIZORG>+777>_-9>-<IRING_-9>;CALC. # PAGES FOR RINGS
	XP UBANXT,UBIRBG+XX	;SET RAM INDEX FOR BLOCK IO TO AFTER RINGS
>;END IFE XX
>;END IFCPU(KS)

INTERNAL KEY620,ALR620,IRING,ORING,IRPPDP,IRP620,ORPPDP
INTERNAL ORP620,IRING,ORING,EPT,UPT
IFNCPU(F3),<INTERNAL DMP620>
SUBTTL	Magic locations in low memory (used by BOOT, CTY, etc)
;*; DPCIOC==22		;CHANNEL ADDRESS FOR RP10 DATA CHANNEL (LEVEL C ONLY)
;*; DPCCCW==DPCIOC+1	;CHANNEL STORE, TERMINATION WORD FOR RP10
;*; MTIOC==24		;CHANNEL ADDRESS FOR TM10B DATA CHANNEL
;*; MTCCW==MTIOC+1	;FINAL CONTROL WORD STORED HERE
;*; RAXIOC==26		;XWD 0,ADDRESS FOR RA-10'S DATA CHANNEL (LEVEL C ONLY)
;*; RAXCCW==RAXIOC+1	;CHANNEL STORE, TERMINATION WORD
;*; RCXIOC==34		;INITIAL CONTROL WORD FOR RC-10'S DATA CHANNEL
;*; RCXCCW==RCXIOC+1	;CHANNEL STORES FINAL CONTROL WORD HERE ON TERMINATION

;*; CURJOB=:20	;RH=Current job on master CPU, LH=Current job on slave CPU
;*; CLKDDT=:21	;Jump to EDDT if DEBUG set, else physical addr of BOOTS data
    BOOTWD=:22	;Pointer to BOOT text
           ;23	; zero (22 and 23 used to read BOOTS from RP02 disk)
    KSSS4=: 24	;"Sense Switch 4" word for KS
;*; CRSDTM=:24	;(TOPS10) Date/Time of previous crash (default time on RELOAD)
           ;25	; zero (24 and 25 used to read BOOTS from TM10B tape)
;*; CRSWHY=:25	;(TOPS10) Stopcode name (duplicates %SYSNM but in low core)
    REPSID=:26	;Restart Pack Set ID to verify consistancy of disk packs
    RESTRT=:27	;Restart states and actions (MANUAL, FULL DSKCLN, etc)
;*; CPNDDT=:27	;(TOPS10) Nonzero if at EDDT breakpoint, slave CPUs loop in ACs
    CRSHWD=:30	;If nonzero, jump to REBOOT at clock tick
    RLWORD=:31	;KS reload bits, to enable/disable Keep-Alive with the 8080
    CTYIWD=:32	;2020 CTY input word
    CTYOWD=:33	;2020 CTY output word
    KLIIWD=:34	;2020 KLINIK input word
    KLIOWD=:35	;2020 KLINIK output word
    DDTSYM=:36	;Like JOBSYM, but after symbol table has been moved
;*; CRSSTS=:36	;(TOPS10) Copy of STATES word (restored on auto-reload)
;*; SYSSNP=:37	;(TOPS10) If nonzero, JSR @SYSSNP at clock tick (output to LPT)
    FORTY=: 40	;LUUO stored at here on KL-10 (not in the EPT)
    JOB41=: 41	;JSR to LUUO handler on KL-10
        ;42-57	;Priority interrupt for KA-10
    JOBREL=:44	;(user mode) Size of SYSTEM.SAV
;*; ARSLOC=:70	;(TOPS10) Instruction executed on a reload after power failure
    KAFLOC=:71	;Instruction executed on a Keep Alive Failure
	KPAFAL=:KAFLOC	;Symbol for ONCE *HACK*
;*; WRSINS=:72	;(TOPS10) Instruction executed on a Warm ReStart
           ;73	; zero
    JOBDDT=:74	;<ending,,starting> address of EDDT
;*; JOBHSO=:75	;(TOPS10) High Segment Origin
;*; JOBBPT=:76	;(TOPS10) Address of DDT's breakpoint #0
;*; LIGHTS= 77	;(TOPS10) Data to be displayed in lights (KA-10 and KI-10)
;*; JOBEDV=:112	;(TOPS10) Address of Exec Data Vector
    DDTSA=: 114	;Like JOBDDT, but after symbol table has been moved
    JOBHRL=:115	;(TOPS10) Length,,start of hiseg
    JOBSYM=:116	;Pointer to DDT symbol table as set up by LINK/LOADER
    JOBSA=: 120	;RH has starting address, LH has initial JOBFF
    JOBFF=: 121	;First Free location in lowseg, used by DDT autopatch
    JOBS41=:122	;Copy of JOB41 when creating/reading SAV file
    JOBCOR=:133	;Size of SYSTEM.SAV
    JOBCST=:136	;Reserved for customer definition
    JOBVER=:137	;Version number, pointer to CONFIG table in TYMCOM-X

REPEAT 0,< ;TOPS-10 definitions not applicable to TYMCOM-X
COMORG=:140	;Data area.  In TOPS-10, this is copyright text in ASCIZ.
        LOC 400
SYSDSP::JRST	SYSTRT	;(400) INITIALIZE SYSTEM VARIABLES IF CPU0
SYSDDT::JRST	PATSYM##;(401) PATCH SYMBOL TABLE POINTER, THEN ENTER EXEC DDT
	HALT	.	;(402)
	HALT	.	;(403)
	JRST	STPALL	;(404) SET CRSHWD TO -1 AND DO A 406
			;  START TO STOP ALL OTHER CPU'S AND
			;  GET TO BOOTS.  MOSTLY FOR DEBUGGING.
	JRST	STPCPU	;(405) STARTING THE BOOT CPU AT 405 IS THE SAME
			;  AS A 407 START.  ON ALL OTHER CPUS, A 405
			;  START WILL CAUSE THE CPU TO SAVE THE
			;  MACHINE STATE AND JUMP INTO THE AC'S UNTIL
			;  MANUALLY RESTARTED THROUGH 400.
	JRST	STPLDB	;(406) SET SR.LBH IN .CPSBR AND DO A 407
			;  START TO FORCE BOOTS TO BE LOADED ON
			;  THIS CPU REGARDLESS OF WHO IS THE BOOT
			;  CPU NOW
SYSCRH:	JRST	SYSTOP	;(407) MONITOR CRASH AND RELOAD LOCATION
ABSTAB::EXP	NUMTAB##;(410) ABSOLUTE LOCATION OF GETAB TABLE TABLE.
			; USED TO BE LOC 151. NEEDED TO DO GETTAB UUO
			; SIMULATION ON A CRASHED MONITOR.
MBTCOM::EXP	0	;(411) ABSOLUTE LOCATION USED FOR MONBTS COMMUNICATION
UCDSIZ::EXP	0	;(412) XWD NUMBER PAGES,NUMBER BYTES IN THE DX20/RP20
			;      MICROCODE STORED IN MEMORY
UCDADR::EXP	0	;(413) PHYSICAL ADDRESS OF THE START OF THE DX20/RP20
			;      MICROCODE STORED IN MEMORY.  IF THIS WORD IS
			;      ZERO, THERE IS NO MICROCODE LOADED REGARDLESS
			;      OF THE VALUE OF UCDSIZ.
	BLOCK	3	;(414,415,416)
	BLOCK	1	;(417) CUSTOMER'S WORD
>  ;End of REPEAT 0
SUBTTL	Start of zeroed data

SYSBEG::		;FIRST LOCATION CLEARED ON 143 RESTART (SEE SYSINI)

   JOB=:.CPJOB		;Number of current job stored in CDB

COMCNT::0			;NUMBER OF COMMANDS TYPED-IN BUT NOT DECODED
				;SET BY SCNSER, DECREMENTED BY COMCON
HNGTIM::0			;HUNG DEVICE TIME COUNT CHECK FOR HUNG I/O
				;DEVICES WHEN THIS GOES TO ZERO (ONCE PER HNGSEC)
CLKFLG::0			;NON-ZERO WHEN CLK INTERRUPT FORCED FOR ANY REASON
STPFLG::0			;SET WHEN CURRENT JOB MAY BE STOPPED
				;CLK INT AND NOT EXEC MODE OR USCHED
TIMEF::	0			;NON-ZERO FOR CLOCK INTERRUPT ON APR
				;SET BY APRSER, TESTED AND CLEARED BY CLK ROUTINE
				;SET BY APRSER, CLEARED BY CLK ROUTINE (CLOCK)
				;LH=-1 ON MEM PARITY ERROR
APRPC::	0			;PC WHEN APR ERROR DETECTED
SCHEDF::0			;FORCED RESCHEDULING FLAG FOR CLK ROUTINE
				;USED TO FORCE RESCHEDULING WHEN JOB IS IN EXEC MODE
NULERR::0			;SET NON-ZERO IF MONITOR DETECTS ERROR WHILE
				; NULL JOB IS RUNNING
POTLST::0			;-1 WHEN SCHEDULER SEES THAT THERE ARE JOBS WHICH
				; ARE POTENTIALLY RUNABLE BUT HAS TO RUN NULL JOB.
				;0 WHEN IT FINDS A REAL JOB TO RUN OR NULL JOB IS
				; ONLY JOB WHICH WANTS TO RUN.  'LSTWRD' IS
				; INCREMENTED EVERY JIFFY IF THIS FLAG IS -1 AND
				; PREVIOUS JOB WAS NULL JOB.
SLJOBN==JOBN*2			;LEAVE TWO ENTRIES PER JOB
CIPWT::	BLOCK SLJOBN+3		;CLOCK REQUEST QUEUE
				; LH-MONITOR ADDRESS TO PUSHJ TO AT CLOCK LEVEL
				; WHEN BITS 24-35 COUNT DOWN TO ZERO
				; BITS 18-23 ARE DATA SET IN AC T1 WHEN PUSHJ DONE
				; BITS 24-35 ARE NUMBER OF CLK TICKS LEFT TO GO
	CIPWTM==:CIPWT-1		;FIRST LOC-1 OF CLOCK QUEUE
;STORAGE FOR VARIOUS CORE ALLOCATION FUNCTIONS


	XP PAGSIZ,1000		;BASIC UNIT OF CORE IN WORDS

NSWTBL::			;Words 0-7 were CORTAB on a PDP-6 monitor
	0			;(0) unused
	0			;(1) unused
	0			;(2) unused
	0			;(3) unused
	0			;(4) unused

;; NEW entries here re-using ancient CORTAB entries	;;  backwards
;;	which have also been made obsolete by DEC.	;;  from 7-0

BASVER::BYTE(8)0,0,0		;(5) BASE debug, version, release numbers
KSYS::  0			;(6) Minutes until timesharing ends
INADEF::INADFL			;(7) DEFAULT INACTIVITY TIMEOUT LIMIT MINUTES
CORMAX::0			;(10) MAXIMUM CORE REQUEST+1 (IE LARGEST REL. ADR,+1)
				; CAN BE RESTRICTED TO LESS THAN ALL OF USER CORE
				; BY BUILD AND/OR ONCE
	0			;*(11) 1 BIT BYTE POINTER TO LAST FREE BLOCK POSSIBLE
				; SET BY SYSINI ON 143 STARTUP
	0			;?(12) TOTAL NUMBER OF FREE+DORMANT+IDLE CORE BLKS LEFT
	0			;*(13) JOB NUMBER SHUFFLER HAS TEMPORARILY STOPPED FOR
				; ITS I/O DEVICES TO BECOME INACTIVE BEFORE SHUFFLING
	0			;*(14) ABSOLUTE ADDRESS OF LOWEST HOLE IN CORE, 0=NONE
UPTIME::0			;(15) NUMBER OF CLOCK TICKS SINCE SYSTEM LOADED OR
				; RESTARTED AT 143
	0			;*(16) TOTAL NUMBER OF WORDS SHUFFLED BY SYSTEM
	0			;*(17) JOB CURRENTLY USING THE SYSTEM TAPE
				; NEEDED SO CONTROL C WILL NOT TIE UP SYSTEM TAPE
HIGHJB::0			;(20) HIGHEST JOB NUMBER CURRENTLY ASSIGNED
CLRWRD::0			;(21) TOTAL NUMBER OF WORDS CLEARED BY 'CLRCOR' RTN.
LSTWRD::0			;(22) TOTAL NUMBER OF CLOCK TICKS WHEN NULL JOB RAN
				; BUT OTHER JOBS WANTED TO RUN AND COULD NOT
				; DO SO BECAUSE: ---
				;  1. SWAPPED OUT OR ON WAY IN OR OUT
				;  2. MONITOR WAITING FOR I/O TO STOP SO
				;      IT CAN SHUFFLE OR SWAP
				;  3. JOB BEING SWAPPED OUT BECAUSE IT IS
				;      EXPANDING CORE
MEMSIZ::0		;(23)SIZE OF PHYSICAL MEMORY IN WORDS (=FIRST NON EXIST WORD)
			; SET BY SYSINI ON 143 RESTARTS UNLESS SYMBOLS SAVED BY
			; PATCHING SYSLIM SMALLER.
PARTOT::0		;(24) TOTAL NUMBER OF BAD MEMORY PARITY ERRORS FOUND BY MONITOR
			;WHILE PROCESSOR WAS IN USER MODE
			; WHILE SYSTEM WAS RUNNING (IF MONITOR HALTS
			; THIS LOC ALREADY UPDATED)
PARSPR::0		;(25) TOTAL NUMBER OF SPURIOUS MEMORY PARITY ERRORS
			; FOUND BY APR, I.E. ONES WHICH DID NOT OCCUR
			; WHEN MONITOR SWEPT THRU CORE LOOKING FOR BAD
			; PARITY.
PARCON::0		;(26) COUNT OF NUMBER OF TIMES OPERATOR PUSHED CONTINUE
			; AFTER MEMORY PARITY HALT (PC) IN EXEC MODE OR MORE THAN 1
			; BAD PARITY WORD WHEN PC WAS IN USER MODE)
PARADR::0		;(27) LAST BAD PHYSICAL MEMORY ADDRESS FOUND
			; WHEN MONITOR SWEPT THRU CORE AFTER
			; PROCESSOR DETECTED FIRST BAD PARITY
PARWRD::0		;(30) CONTENTS OF LAST BAD WORD FOUND BY MONITOR
			; WHEN MONITOR SWEPT THRU CORE AFTER FIRST PARITY
PARPC::	0		;(31) PC OF LAST MEM PARITY (NOT COUNTING SWEEP THRU CORE)
			;INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
			; TO USERS IN NON-SWAP AND SWAP SYSTEMS
EPOCNT::0		;*(32) TOTAL #  OF PDL OVF'S  AT M LEVEL IN EXEC MODE
EPOREC::0		;*(33) # OF PDL OVF'S AT M LEVEL IN EXEC MODE
NULTIM::0		;(34) NUMBER OF CLOCK TICS NULL JOB HAS BEEN
			;RUNNING SINCE STARTUP
NULMNT::0		;(35) NUMBER OF CLOCK TICES NULL JOB RAN
			;IN PREVIOUS MINUTE
ALR620:	0		;(36) 620 ALARM CELL (UNHAPPY MSGS)
USRMAX::0		;(37) MAXIMUM SIZE THAT A JOB'S MWS CAN GET.
			; SETUP BY ONCE TO BE NUMBER OF USER PAGES AVAILABLE.
SYSUID::0		;(40) last allocated universal frame id number
THSTIM::0		;(41) UPTIME when SCNSER last ran
MXTIM::	0		;(42) all time max of (THSTIM-UPTIME)

NSWMXL==:<.-NSWTBL-1>B26	;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9

SYSBG2:			;1ST. LOCATION FOR ONCE ONLY CODE TO BE ASSEMBLED HERE
			;CORE ALLOCATION DATA NOT AVAILABLE VIA GETTAB
LASCOR::0		;LAST JOB OR HIGH SEG TO CALL CORE ROUTINES
PARFLG::0		;-NO. OF PARITY ERRORS ALLOWED IN EXEC MODE
			; BEFORE HALT.  USED TO DETECT SWEEP THRU CORE

RCMAX:	177		;MAX SIZE OF USER JOB IN K
CORMXK::0		;MIN-MAXIMUM SIZE OF USER JOB IN K
MWSLIM::0		;CURRENT MWS LIMIT. SETUP BY ONCE TO C(USRMAX)
HLTBRK::0		;IF NON-ZERO, WE WILL HALT ON ADRESS BRK
;DATA LOCATIONS PRESENT ONLY IN SWAPPING SYSTEMS

SWPTBL::			;FIRST LOCATION OF MONITOR DATA STORAGE
				; RETURNED BY GETTAB M (THESE LOCATIONS
				; PRESENT ONLY IN SWAP SYSTEMS)
				; OCTAL NUMBERS IN () CORRESPOND TO GETTAB ARG
	0			;(0) CURRENT BIGGEST HOLE IN CORE (IN PAGES)
	0			;(1) IF +, THEN JOB NUMBER OF JOB BEING SWAPPED IN,
				;IF -, THEN JOB NUMBER OF JOB BEING SWAPPED OUT
	0			;(2) JOB NUMBER BEING FORCED TO SWAP OUT
	0			;(3) JOB NUMBER WAITING TO BE FITTED INTO CORE
	0			;(4) NUMBER OF FREE PAGES OF SWAPPING SPACE LEFT
				; (COUNTING DORMANT SEGMENTS AS IF FREE).
				; PRINTED WITH CORE COMMAND (NO ARG) OR ERROR
				; USUALLY THE SAME AS THE AMOUNT OF VIRTUAL CORE
				; LEFT IN SYSTEM, EXCEPT WHILE R,RUN,KJOB,GET
				; COMMAND ARE WAITING TO BE SWAPPED IN, BECAUSE
				; THE OLD DISK SPACE HAS NOT BEEN RETURNED YET,
				; BUT VIRTUAL CORE IS ONLY 140 WORDS FOR SWAPIN
SWPERC::0			;(5) LH= NUMBER OF SWAPPER READ OR WRITE FAILURES
				; RH= ERROR BITS (BITS 18-21) + NUMBER OF J OF
				; DISCARDED SWAPPING SPACE

				;INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
				; TO USER PROGS IN SWAPPING SYSTEMS
LASIN::	0			;(6) last job or high seg swapped in
LASOUT::0			;(7) last job or high seg swapped out
SWPMXL==:<.-SWPTBL-1>B26	;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9
;MORE SWAPPING SYSTEM LOCATIONS (NOT RETURNED BY GETTAB)

FULCNT::0			;PRINT DISK IS FULL EVERY 30 SECONDS

;DEFINE BLOCK FOR BIT TABLE DENOTING 4 WORD BLOCKS AVAILABLE (=0), IN USE (=1)
; USE MULTIPLES OF 4*^D36 WORDS SO THE TABLE WILL HAVE A MULTIPLE OF ^D36 BITS
; ADD 7 WORDS TO ACCOMODATE A POSSIBLE 1K BEYOND FRECOR AMOUNT
;MONITOR TABLES WITH ONE ENTRY PER JOB

	JOBMAX==:JOBN-1		;MAXIMUM LEGAL JOB NUMBER, HIGHEST JBT INDEX
	JOBMXL==:<JOBMAX>B26	;HIGHEST JOB NUMBER SHIFTED LEFT 9 (FOR GETTAB M)
	MJOBN==:-JOBN		;NEGATIVE NUMBERS OF JOBS (COUNTING NULL JOB)

JBTSTS::BLOCK 	JOBN		;JOB STATUS WORD
				;LH==STATUS BITS (SEE S.MAC FOR DESCRIPTION)
				;BITS 18-23=EXTENDED JOB STATUS BITS
	INTERN	JBTWRS
JBTWRS:	BLOCK	JOBN		;LAST 6 JOB STATE CODES (DEBUGGING)
JBTCTX::BLOCK	JOBN*NCTXPG	;DISK ADDRESSES, STATUS BITS FOR
				; CONTEXT PAGES

JBTIOA::BLOCK	JOBN		;LH=UNUSED (Was interrupt assignments!!!)
				;RH=COUNT OF CAN'T SWAP WHILE IO
				;WHICH USES USER CORE IS IN
				;PROGRESS. =0 MEANS SWAPPABLE.

JBTUPM::BLOCK	JOBN		;LH = NUMBER OF EXISTENT PAGES IN
				; USER ADDRESS SPACE. RH = USER
				; AC BLOCK, LOAD UBR BIT
				; AND PHYSICAL PAGE NUMBER OF UPT

JBTPGO::BLOCK	JOBN		;LH SEE BELOW, RH LINK TO NEXT JOB
				; WAITING FOR CORE PAGE. CHAIN STARTS
				; IN PGYPGO.

JBTFIT::BLOCK	JOBN		;DOUBLY LINKED LIST OF JOBS BEING
				; SWAPPED IN.

JBTMWS::BLOCK	JOBN		;MONITOR WORKING SET WORD
				;BITS 26-35 (JBYUWS) UWS SIZE
				;BITS 16-25 (JBYMWL) MWS SIZE LIMIT
				;BITS  6-15 (JBYMWS) MWS SIZE
				;BITS  0-5  (JBYPPP) # OF PER-PROCESS
				;PAGES

JBTICT::BLOCK	JOBN		;LH=IN CORE PROTECT TIME FOR JOB
				;RH=QUANTUM RUN TIME

XP JBSQNT,^D12
XP JBNQNT,^D35
XP JBMQNT,7777
INTERN	JBMQNT

JBTFTR::BLOCK	JOBN		;FRAME TREE TABLE. CONTAINS 3 12 BIT
				; FIELDS - PARENT, RIGHT HAND NEIGHBOR, AND LEFTMOST CHILD.

JBTUID::BLOCK	JOBN		;UNIVERSAL FRAME ID
JBTPNO::BLOCK	JOBN		;"PROGRAM NUMBER" - RIGHTS GO AWAY AFTER MISMATCH AGAINST THIS
JBTSPN::BLOCK	JOBN		;SELF TO PARENT RIGHTS PROGRAM NUMBER
JBTP2S::BLOCK	JOBN		;FAST ACCESS RIGHTS BITS FOR PARENT TO SELF
JBTS2P::BLOCK	JOBN		;FAST ACCESS RIGHTS BITS FOR SELF TO PRENT
JBTMFR::BLOCK	JOBN		;FAST MAXIMUM INWARD RIGHTS
				; (DEFAULT RIGHTS FOR FRAMES THAT DON'T KNOW EACH OTHER WELL)

JBTPPN::BLOCK JOBN	;.GTPPN=2  GFD'd Project Programmer Number
JBTNM1::BLOCK JOBN	;.GTNM1=31 GFD'd Username (1st half) sixbit chars 1-6
JBTNM2::BLOCK JOBN	;.GTNM2=32 GFD'd Username (2nd half) sixbit chars 7-12

	XP ITMDEV,JOBMXL	;LH SYMBOL FOR GETTAB M SO THAT JBTDEV IS
				;UNDEFINED, IE. MAKE INDEXING BYITEM BE 0

RTIME::	BLOCK JOBN		;TOTAL RUN TIME SINCE LAST IJOB OR RUNTIME

JBTTMP::BLOCK	JOBN		;TMPCOR POINTERS, FREE SPACE FOR NULL JOB.
				; EACH ENTRY HAS THE FORM   XWD <QUOTA>,<LINK>

JBTNAM::BLOCK JOBN		;NAME OF FILE USED IN LAST R,RUN,GET, ETC
				; USED BY SYSTAT PROGRAM, subject to SETNAM
JBTPRG==:JBTNAM			;Name of program, immune to SETNAM uuo

JBTKCT::BLOCK JOBN		;PRODUCT OF CORE LENGTH (IN J) * NUMBER OF JIFFIES
				; PROGRAM USED CPU. USED FOR TIME ACCOUNTING.

JBTWCH::BLOCK JOBN		;BITS 1-5 = ENABLE BITS - SEE S.MAC
				;BITS 13-35 = TIME OF DAY IN JIFFIES USER
				;STARTED TO WAIT FOR RESPONSE FROM SYSTEM
				;REST UNUSED

JBTINT::BLOCK	JOBN		; INTASS interrupt channel assignments.
				; Bits  0-6  (4)  Timer trap (SETTIM)
				; Bits  7-11 (6)  Wake UUO
				; Bits 12-17 (13) Notice to quit/hang
				; Bits 18-23 (14) Frame exit interrupt
				; Bits 24-29 (16) TRU limit exceeded

JBTSTA::BLOCK	JOBN		;Used by .USESTAT command

JBTLIC::BLOCK	JOBN		;FOR LICENSE BITS
JBTSLC::BLOCK	JOBN		; LH FOR SAVE LICENSE BITS
				; RH UNUSED (WAS INTERRUPT ASSIGNMENTS)

JBTFPN::BLOCK JOBN		;PPN OF PROGRAM LAST RUN OR CURRENTLY
				;BEING RUN BY THIS JOB.  (0 IF PROGRAM
				;CAME FROM MAGTAPE.).

JBTAUN::BLOCK JOBN	;.GTAUN=-23 Logged-in PPN (Accounting user number)
JBTUNM::BLOCK JOBN	;.GTUNM=-22 Logged-in Username (1st half) sixbit chars
JBTUN1::BLOCK JOBN	;.GTUN1=-21 Logged-in Username (2nd half) sixbit chars
JBTSLM::BLOCK JOBN	; Console settable TRU limit     - Frame global
JBTLIM::BLOCK JOBN	; Console/UUO settable TRU limit - Process local

JBTDLK::BLOCK JOBN	;LOOKUPS
JBTERN::BLOCK JOBN	;ENTERS AND RENAMES
JBTSLK::BLOCK JOBN	;LOOKUPS*SIZE
JBTSER::BLOCK JOBN	;ENTERS AND RENAMES*SIZE
JBTSIN::BLOCK JOBN	;DISK BLOCKS READ*SIZE
JBTSOT::BLOCK JOBN	;DISK BLOCKS WRITTEN*SIZE
JBTCIN::BLOCK JOBN	;CHRS IN
JBTCOT::BLOCK JOBN	;CHRS OUT
JBTELP::BLOCK JOBN	;ELAPSED TIME*SIZE
JBTCNK::BLOCK JOBN	;CONNECT TIME (DETACHED NOT COUNTED)
JBTBCS::BLOCK JOBN	;BREAK CHRS *SIZE
JBTSOK::BLOCK JOBN	;FROM SOAKEM UUO
JBTCMP::BLOCK JOBN	;MICRO CYCLES FROM DK10
JBTCP2::BLOCK JOBN	;HIGH ORDER PART OF MICRO CYCLES
JBTCPU::BLOCK JOBN	;HIGH ORDER BITS OF MICRO CYC*SIZE

JBTABT::BLOCK JOBN	;ROUTINE TO CALL ON SWAP ERROR OR ILL MEM REF


JBTBET::BLOCK JOBN		;ELAPSED TIME IN BLOCK I/O MODE (IN SECONDS)
JBTBIO::BLOCK JOBN		;BIO CHARS IN/OUT

JBTAJF::BLOCK JOBN		;# FAULTS FOR PAGES IN UWS BUT NOT
				;IN MWS (# FAULTS CCAUSED BY MWS
				;ADJUST ALGORITHM)

JBTSCA::BLOCK	JOBN			;TRU scaling word

JBTENB::BLOCK JOBN	;CHANELS ENABLED. BIT 0 IS 1 IF PI SYSTEM
			;IS ENABLED, BITS 1-35 INDICATE CHANELS ENABLED

JBTPIP::BLOCK JOBN	;CHANELS IN PROGRESS. BITS 0 INDICATES
			;OLD APRENB SYSTEM. IF BIT 0=1 BITS 1 IS TRAP
			;IN PROGRESS. IF BIT 0=0 BITS 1-35 ARE THE
			;CHANELS IN PROGRESS

JBTAWQ::BLOCK JOBN	;CHANELS AWAITING REQUEST. IF BIT0=1
			;MEANS TAKE A TRAP AS SOON AS POSSIBLE
			;IF OLD STYLE APRENB, ALL BITS BUT BIT 0 USED
			;TO STORE FLAGS GIVING REASON FOR TRAP

;THIS MAY NOT GO AWAY

;BITS 0-5 UUO TRAP NUMBER
;BITS 6-11 CLOCK TRAP NUMBER
;BITS 12-17 PAGE TRAP NUMBER
;BITS 18-23 HUNG DEVICE TRAP NUMBER
;BITS 24-29 TIMER TRAP NUMBER
;BITS 30-35 DEVICE ERROR TRAP NUMBER

JBTPRV::BLOCK JOBN		;PRIVILEGE BITS FOR JOB SET BY LOGIN

QUEPCB::BLOCK	JOBN		;PCBIO DATABASE AREA.
JBTPCB::BLOCK	JOBN		;FOR LAYOUT, SEE PCBIO MODULE.

JBTCLB::BLOCK JOBN		;TABLE USED BY THE CLUB FACILITY

JBTINA:: BLOCK	JOBN		;INACTIVITY TIMEOUT
				;LH - LIMIT
				; NOTE THAT THIS FIELD IS MUCH LARGER THAN
				; IT NEEDS TO BE
				;RH - # MIN SINCE JOB LAST RAN

;THE FOLLOWING ARE USED TO CREATE MXQUE
;THE MAXIMUM QUEUE SIZE, USED BY SWAPPING SCHEDULER (SCHED)
	XP	MXQUE,0

	DEFINE	X	<MXQUE==MXQUE+1;>
	QUEUES
DEFINE	X	(A)

		<A'Z==MXQUE
		MXQUE==MXQUE+1;>
	CODES
		MXQUE==MXQUE+4

	BLOCK MXQUE		;NUMBER OF QUEUES FOR SWAPPING SCHEDULER
JBTQ::	BLOCK JOBN		;ONE ENTRY PER JOB,
				; LH=PREVIOUS JOB, RH=NEXT JOB IN QUEUE
				; NEGATIVE MEANS THIS IS FIRST (LH) OR LAST (RH)
				; JOB IN QUEUE
	JBQMN==:JBTQ-NULZ	;J1
;THE FOLLOWING GLOBALS ARE USED IN VARIOUS ROUTINES SUCH AS
;ONCE,SCNSER,DLSINT,BTHINT,ETC.

IFNDEF PPORTN,<PPORTN==:<JOBN/4>*2>
IFNDEF RPORTN,<XP RPORTN,PORTN-PPORTN>
IFNDEF PORTN,<XP PORTN,RPORTN+PPORTN>
IFG <PORTN-^D255>, <
	PRINTX MORE THAN 255 PORTS!!!
	STOPI>
IFL <RPORTN-^D11>, <
	PRINTX MUST HAVE AT LEAST 11 REAL PORTS
	STOPI>
XP RMXLIN,RPORTN-1	;"REAL" PORT #S ARE BELOW RPORTN,
			;PTY PORT #S ARE ABOVE RMXLIN

SCNN==JOBN+PORTN+1	;Number of TTY DDBs - enough for all jobs
			; plus all ports (TTY, AUX CIR, PTY, CTY).
IFG <SCNN-^D255>,<
IF2,<PRINTX More than 255 TTY DDBs requested - allocating 255 only.>
SCNN==^D255>
XP MXLIN,PORTN-1
NFLG==<PORTN+^D36>/^D36
XP NMXFLG,-NFLG
XP NMXLIN,-PORTN
XP LINMXL,<<MXLIN>B26>

ACTN==1			;NUMBER OF ACCOUNTING DDBS
;TTYTAB IS A TABLE OF CONTROLLING (ATTACHED) TTY'S FOR EACH JOB,
;INDEXED BY JOB NUMBER. IF C(TTYTAB)=0 THEN NO TTY IS ATTACHED.
;OTHERWISE, RH(TTYTAB(N)) IS CONTROLLING DDB FOR JOB N.

TTYTAB::BLOCK JOBN

;COMFLG is a bit table with one bit per frame, indicating whether
; there is a command pending for that frame.  Whenever the
; COMFLG bit is set for a particular frame, the "command
; request" bit (CMDCMR) in the left half of TTYTAB should also
; be set.
CFLG==<JOBN/^D36>+1	;Number of entries in COMFLG table
XP NCMFLG,-CFLG
COMFLG::BLOCK	CFLG
	INTERN NCMFLG

	SYSEND=:.-1		;END OF CLEARED STORAGE ON RESTART
SUBTTL	ONCE ONLY CODE TO CREATE DEVICE DATA BLOCKS

	LOC SYSBG2		;PUT IN SYSTEM DATA AREA SO NOT TO TAKE
				; VALUABLE SPACE.  THIS AREA IS CLEARED
				; BY SYSINI AFTER IT HAS BEEN EXECUTED

COMMENT ! ROUTINE LINKDB
FUNCTION:  ONCE-TIME CODE TO ALLOCATE / CREATE / LINK DEVICE DDB'S,
FILSER CORE BLOCK, TTY DDB'S, AND VARIOUS OTHER SYSTEM DATA AREAS.
JSR HERE FROM ONCE CODE.

!

LINKDB::0
				;SO THAT E.G. SAT TABLES MAY BE SCANNED
				; BE OVERLAYED BY MULTIPLE DEVICE DATA
				; BLOCK GENERATION)

PRINTF(<[LINKDB: Store STRNAM of only STR in QUESTR]>)
	MOVE	T1,STRNAM##+STRDDB## ;STORE ADDR OF FASTEST (ONLY)
	MOVEM	T1,QUESTR##	;STR FOR QUEUEING CUSPS.

	MOVSI	P1,INTNUM	;NEG NUMBER OF ENTRIES IN TABLE
	MOVEI	F,DEVLST-DEVSER ;MAKE DEVLST LOOK LIKE DEVSER IN A DDB
LOOP:	MOVE	P2,INTTB1(P1)	;GET NEXT DEVICE DATA BLOCK ADDRESS
	JUMPE	P2,NEXT		;0 MEANS NO DOB FOR DEVICE
	CAIN	F,(P2)		;IS THIS THE SAME AS LAST TIME (DSK)
	 JRST	NEXT		;YES, IGNOREM
	MOVE	M,DEVMOD(P2)
	TLNN	M,DVTTY		;IS IT TTY
	 JRST	NTYLNK		;NO
	MOVEM	P2,FRETTY##
	MOVEM	F,TTYFLK##
	JRST	TTYLNK

NTYLNK:	HRLM	P2,DEVSER(F)	;YES, STORE IN PREVIOUS DEVICE DATA BLOCK
TTYLNK:	HRRZ	F,P2		;MAKE F POINT TO CURRENT DOB
	LDB	M,[POINT 8,INTTAB(P1),8] ;GET NUMBER OF DDB'S
	HLRZ	U,DEVSER(F)	;MULTI FT'S ARE ALREADY LINKED.
	JUMPE	U,NOTFT
	HRRZI	F,(U)		;FT.
	HLRZ	U,DEVSER(F)	;FIND
	JUMPN	U,.-2		;LAST
	JRST	NEXT		;ONE.

NOTFT:	SOJLE	M,NEXT		;ONE OR LESS ?
	HRRZ	U,F		;NO, CREATE MULTIPLE COPIES OF DOB
				; SAVE ORIGINAL IN U
	MOVEI	P3,1		;STARTING WITH DEV1,DEV2,DEV77
	LDB	P4,PUNIT	;START UNIT NUMBER FROM
				; ASSEMBLE DEVICE DATA BLOCK
				; PTY STARTS UNIT NUMBER AT 1 INSTEAD OF 0
				; ALTHOUGH DEVICE NAMES ARE PTY0,PTY1,ETC.

MULDDB:	HLRZ	T2,INTTB1(P1)	;Size of these DDB's
	PUSHJ	P,EVMALC##	;Allocate EVM for new DDB
	HRLM	T1,DEVSER(F)	;Point previous DDB to new one
	HRL	F,U		;Set up BLT word
	HRR	F,T1		;Make new DDB the current one
	ADDI	T1,(T2)		;Last word to be BLT'ed +1
	MOVE	T3,F		;KL SMASHES BLT AC
	BLT	T3,-1(T1)	;MOVE ORIGINAL TO FREE STORAGE
	MOVE	PG,[POINT 6,DEVNAM(F),17] ;BYTE POINTER TO NEWLY CREATED
				; DDB PHYSICAL NAME
	MOVE	J,P3		;MAKE COPY OF UNIT NUMBER
	TRNN	J,70		;IS IT 10 OR MORE ?
	 JRST	SMALL		;NO
	ROT	J,-3		;YES, CONVERT HIGH ORDER OCTAL DIGIT TO
	ADDI	J,20		;SIXBIT
	IDPB	J,PG		;AND STORE
	TRZ	J,-1		;CLEAR OUT HIGH ORDER DIGIT
	ROT	J,3		;MOVE LOW ORDER DIGIT BACK
SMALL:	ADDI	J,20		;CONVERT LOW ORDER DIGIT IN SIXBIT
	IDPB	J,PG		;AND STORE IN PHYSICAL NAME
	ADDI	P4,1		;INCREMENT BINARY UNIT NUMBER
	DPB	P4,PUNIT	;STORE UNIT NUMBER
	CAIGE	P3,(M)		;COMPARE WITH HIGHEST DEVICE NUMBER
	AOJA	P3,MULDDB	;DO ANOTHER COPY
	HRRZS	DEVSER(F)	;REMOVE THE LINK
	PFALL	NEXT
NEXT:	MOVE	P3,DEVMOD(F)
	TLNE	P3,DVTTY
	 MOVE	F,TTYFLK##	;NO BACK TO REAL LINKING
	AOBJN	P1,.+1		;MOVE BY TWOS
	AOBJN	P1,LOOP		;ANY MORE DEVICES

;End of DDB loop

	MOVEI	P1,0		;NO, FLAG END OF DDB CHAIN WITH 0 LINK
	HRLM	P1,DEVSER(F)	;YES, STORE 0 IN CASE LAST DDB IS MULTIPLE
TMPALC:	MOVEI	T2,TMPSZT	;Total storage for TMPINI
	PUSHJ	P,EVMALC##	;Allocation base address returned in T1
	HRLI	T1,TMPSZ
	MOVEM	T1,TMPTAB##	;FREE DATA SPACE,ADDRESS OF TABLE
	HRLZI	T1,TMPSZJ
	HRRI	T1,TMPBKS
	MOVEM	T1,TMPTAB##+1	;USER QUOTA,NUMBER OF BLOCKS IN AREA

;FOLLOWING CODE ALLOCATES SPACE FOR THE LINE DATA BLOCKS & FOR CHARACTER LISTS

LINALC:	HLRZ	T2,TTCLST	;Number of bufferlets
	IMULI	T2,TTCHKS	;Times chunk size
	ADDI	T2,3		;In case misaligned
	PUSHJ	P,EVMALC##	;Allocate storage
	ADDI	T1,3
	TRZ	T1,3		;MAKE SURE A MULTIPLE OF 4
	HRRM	T1,TTCLST	;SAVE AS FIRST CHARACTER CHUNK ADDR

LDBALC:	MOVSI	J,-PORTN-1	;Enough for 0 through PORTN
	MOVEI	T2,LDBLEN##	;Constant throughout loop
TTY0:	SKIP	T1,[CTYLDB##]	;Make TTY0 be the CTY
  PRINTF(<[Need to change SKIP to SKIPA at TTY0: for CTY]>)
LNKTTL:	PUSHJ	P,EVMALC##	;Allocate one LDB (Size in T2)
	HRRM	T1,LINTAB(J)	;Store address into table
	HRLI	U,CTYLDB##	;GET THE ADR OF THE PROTO LDB
	HRRI	U,(T1)		;Rest of BLT word
	ADDI	T1,(T2)		;Last word of BLT target + 1
	MOVE	T3,U		;KL SMASHES BLT AC
	BLT	T3,-1(T1)	;COPY THE LDB
	DPB	J,LDPLNO##	;STORE PHYSICAL LINE NUMBER IN LDB
	AOBJN	J,LNKTTL	;NO. MAKE ANOTHER ONE

;ALLOCATE BUFFER FOR SNOOP HISTOGRAMS, IF ANY DESIRED

SNBALC:	SKIPN	T2,HFDBUF	;SIZE NONZERO IN LH?
	 JRST	NOSNBF		;NO, ALLOCATE NOTHING FOR SNOOPING
	HLRZS	T2		;T2/0,,MAX HISTOGRAM SIZE FOR SNOOPING
	PUSHJ	P,EVMALC##	;Returns base address in T1
	HRRM	T1,HFDBUF	;HFDBUF/SIZE,,BEGINNING LOCATION
NOSNBF:	;DONE SNOOP BUFF ALLOC
;ALLOCATE CORE BLOCKS
FILALC:	MOVE	T2,CORNUM##	;Number of core blocks
	IMULI	T2,CMBSIZ##	;Times block size gives total storage
	PUSHJ	P,EVMALC##	;Allocate, returns base in T1
	MOVEM	T1,CORBAS##	;REMEMBER START OF FILSER FREE CORE SO CAN
				; COMPUTE ATB POINTERS, WHICH ARE RELATIVE.
	HRLZM	T1,SYSCOR##	;FIRST FREE FILSER CORE BLOCK
	MOVE	T2,CORNUM##	;GET # OF BLOCKS TO BE GENERATED
	ADDI	T1,CMBSIZ##	;COMPUTE ADR. OF NEXT BLOCK
	HRLZM	T1,-CMBSIZ##+CMBLNK##(T1) ;YES - SAVE ADR. OF NEXT BLOCK IN THIS BLOCK
	SOJG	T2,.-2		;FINISHED YET?
	SETZM	-CMBSIZ##+CMBLNK##(T1)	;YES - ZERO LINK IN LAST BLOCK TO SIGNALEND OF LIST
	JRST	@LINKDB		;RETURN TO CALLER
;MORE PARAMETERS FOR TEMPORARY IN-CORE FILE STORAGE FOR SHORT (CCL) FILES

TMPNX==JOBN*^D20	;IF SIZE OF SPACE NOT SET, DEFAULT VALUE
TMPBKS==<TMPNX+TMPBL>/<TMPBL+1>	;NUMBER OF BLOCKS (LINKED LIST) IN AREA
TMPSZ==TMPBKS*TMPBL		;NUMBER OF DATA WORDS AVAILABLE
TMPSZT==TMPBKS*<TMPBL+1>		;TOTAL TABLE LENGTH (ROUNDED)
TMPBKJ==<<^D60+TMPBL>/<TMPBL+1>> ;USER SPACE QUOTA. DEFAULT VALUE
TMPSZJ==TMPBKJ*TMPBL		;QUOTA OF DATA WORDS PER USER


				; (DO NOT DESTROY ONCE)
				; FLAG NON-ZERO IF CALLED BY JRST LINKDB
				; (OK TO DESTROY ONCE CODE)

DDSTAR::Z		;STARTING ADDR OF STR DATA BLOCKS ETC. IN HIGH CORE
			;(USED BY ONCMOD AND REFSTR)
;;MACROS TO DEFINE PI CHANNEL NUMBER AND GENERATE INTERRUPT CHAINING
;; INFORMATION FOR ONCE SO IT CAN LINK THE DEVICE INTERRUPT SERVICE
;; ROUTINES AND THE DEVICE DATA BLOCKS

;;TABLE INTTAB IS GENERATED WITH PAIRS OF ENTRIES FOR EACH DEVICE
;; WHICH HAS A DEVICE DATA BLOCK
;;FIRST WORD: BIT 0==1 IF DECTAPE, BITS 1-9==NUMBER OF DDBS, BITS 9-17==PI
;; CHANNEL (0-7) WHERE 0 MEANS NO PI CHANNEL (E.G., PTY)
;;SECOND WORD: LH==0 IF SINGLE DEVICE,==LENGTH OF DDB IF MULTIPLE, RH==DDB ADDRESS

;;MACRO FOR DEVICES WHICH ARE ALWAYS PRESENT (AND WHICH DO NOT USE A
;; CHANNEL SAVE ROUTINE AND HAVE NO DDB)  EXAMPLES ARE APR, CTY, PEN, CLK...

;DEFINE SPASGINT (DEV,PI) <
;	DEV'N==1
;			ASGINT DEV,PI
;>

DEFINE ASGINT (DEV,PI) <
	IFG DEV'N, <IFG PI, <
	IFE <PI-.CH>, <.CHAS==1		;;CHANNEL PI IN USE.
>
	UNASS'PI==0		;;MARK CHANNEL AS ASSIGNED
	DEV'CHN==:PI		;;DEFINE INTERNAL PI CHAN FOR DEV'CHN
	XWD	PI,DEV'INT##	;;GENERATE INT SERVICE CONSO ENTRY FOR ONCE
	XWD	0,0		;;NO DDBS TO CHAIN TOGETHER
	ASGIN1 DEV,\PI
>>
>

DEFINE ASGIN1 (DEV,PI) <
IFDEF CH'PI,<			;;WAIT TILL PASS 2 TO DEFINE
	DEV'CHL==:CH'PI		;;DEFINE INTERNAL DEV'CHL
>>

;;MACRO FOR OPTIONAL DEVICES WHICH ALWAYS USE A CHANNEL SAVE ROUTINE
;; (EXAMPLES: CDR, DSK, PTR, ETC.  ALSO PTY WITH 0 PI)

;DEFINE SPASGDDB (DEV,PI,NUM) <
;	DEV'N==NUM
;	NOSAV==1
;	ASGSAV DEV,PI
;>


DEFINE ASGSAV (DEV,PI) <
	IFG DEV'N, <IFG PI, <
	UNASS'PI==0		;;MARK CHANNEL AS ASSIGNED
IF2, < IFNDEF DEV'INT, <EXTERNAL DEV'INT>>	;;INTERRUPT SERVICE CONSO INSTRUCTION
>
IF2, < IFNDEF DEV'DDB, <EXTERNAL DEV'DDB>>	;;DEVICE DATA BLOCK ADDRESS
	ASGSV1 DEV,\PI
	>>

;;MACRO FOR:	1. COMPLETION OF THE DEFINITION REQUIRED FOR THOSE
;;		   DEVICES INVOKING THE ASGSAV MACRO
;;		2. COMPLETE DEFINITION FOR THOSE DEVICES WITH THEIR INTERRUPT
;;		   ENTRY POINT AND DDB'S HERE IN COMMON  (EXAMPLE: LPT'S)

DEFINE ASGSV1 (DEV,PI) <
	IFG PI,<
	IFE <PI-.CH>,<.CHAS==1>		;;CHANNEL PI IN USE.
		DEV'CHN==:PI		;;DEFINE DEVICE CHANNEL NUMBER
	IFE NOSAV,<ASGSV2 DEV,PI>
	>

	DTBIT==0			;;ASSUME THIS IS NOT A DECTAPE
	IFIDN <DEV> <DTA>, <DTBIT==1>	;;IS IT P-10 DECTAPES ?
	IFIDN <DEV> <DTC>, <DTBIT==1>	;; OR P-6 DECTAPES ?

	IFE PI,<XWD DEV'N*1000+0,0>	;;NO PI CHANNEL FOR THIS DEVICE
	IFG PI, <
	    XWD DTBIT*400000+DEV'N*1000+PI,DEV'INT	;;FIRST WORD OF INTTAB ENTRY
	    IFE DEV'N,<EXTERNAL DEV'INT> ;;LEVEL D DISK IN COMMOD
	>

	IFG DEV'N-1,<XWD DEV'DDS##,DEV'DDB> ;;MULTIPLE DEVICE 2ND WRD OF INTTAB ENTRY
	IFE DEV'N-1,<XWD 0,DEV'DDB>	;;SINGLE DEVICE 2ND WRD OF INTTAB ENTRY

	IFE DEV'N,<
	0	;NO DDBS FOR DISK
		DEFBIT DEV
		DSKPIF==DSKPIF!DEV'BIT ;;KEEP LOG. OR OF PI OFF BIT FOR DSK CONTROLLERS
		DSKPIN==DSKPIN!DEV'BIT ;;AND FOR PI ON
	>
>		;;END ASGSV1 DEFINITION



;;MACRO'S TO ALLOW GENERATION OF MULTIPLE INTTAB ENTRIES FOR MULTIPLE
;; DEVICES SUCH AS U-PRINTERS

DEFINE MULASG (DEV,DE,PI,DSKFL) <
	IFG DEV'N, <
		UNASS'PI==0		;;MARK CHANNEL AS ASSIGNED
		ZZ==0
		REPEAT DEV'N, <
			DEVASG DE,\ZZ,PI,DSKFL
			ZZ==ZZ+1
		>
	>
>

DEFINE DEVASG (DE,X,PI,DSKFL) <
	IFE DSKFL,<DE'X'N==1
		ASGSV1 DE'X,\PI>
	IFL DSKFL,<DE'X'N=0	;-VE MEANS NO DDB GENERATED HERE
		ASGSV1 DE'X,\PI>
	IFG DSKFL,<	;DISK
		NMCLC (XX,DE,X,<A,B,C,D,E,F,G>)
		IFN XX,<DE'X'N==0	;SOME UNITS ON CONTROLER
			ASGSV1 DE'X,\PI>>>

;;MACROS TO CONTROL ASSIGNMENT OF PI CHANNELS TO DEVICES

DEFINE NEXTCH < .CH==.CH+1		;;START ASSIGNING TO NEXT LOWER CHANNEL
.CHAS==0
NEXTCU \.CH	
>
DEFINE NEXTCQ <	IFN .CHAS, <NEXTCH>>	;;START ASSIGNING TO NEXT LOWER CHANNEL IF
					;; CURRENT CHANNEL HAS BEEN USED.
DEFINE NEXTCU (N) < IFDEF UNIQ'N, < IFN UNIQ'N, <NEXTCH>>>	;;TO SKIP OVER ANY
					;; SPECIALLY SPECIFIED CHANNELS (RECURSIVELY!)

DEFINE DEFBIT (DEV) <
	DEV'BIT==1
	REPEAT 7-DEV'CHN, <DEV'BIT==DEV'BIT*2>
>

;;INITIALLY ASSUME NO PI CHANNEL SAVE ROUTINES NEEDED

	USED1==0
	USED2==0
	USED3==0
	USED4==0
	USED5==0
	USED6==0
	USED7==0

;;ALL CHANNELS ARE INITIALLY UNASSIGNED

	UNASS1==1
	UNASS2==1
	UNASS3==1
	UNASS4==1
	UNASS5==1
	UNASS6==1
	UNASS7==1


;MACRO TO ALLOW GENERATION OF CHANNEL SAVE ROUTINES ONLY

;DEFINE SPASGSAV (DEV,PI,%ACNUM) <
;	HIGAC'PI==%ACNUM
;	DEV'HAC==%ACNUM
;INTERNAL HIGAC'PI,DEV'HAC

;	ASGSV2 DEV,PI
;>

DEFINE ASGSV2 (DEV,PI) <
		USED'PI==1		;SET FLAG SO THAT A CHANNEL SAVE
					; ROUTINE WILL BE GENERATED FOR
					; THIS PI CHANNEL

IFDEF DEV'ACB,<;DEFINED IF A KL10 AND AC BLOCK ALLOCATED TO THIS DEVICE'S CHANNEL
	IFDEF ACBPI'PI,<IFN DEV'ACB-ACBPI'PI,<PRINTX CONFLICTING AC BLOCK ASSIGNMENTS
		STOPI>>
	ACBPI'PI==<DEV'ACB>	;NEGATIVE IS FLAG FOR CHANNEL
				; MACROS TO GENERATE DIFFERENT CODE.
>;END IFDEF DEV'ACB

	IFDEF SAV'PI, <		;WAIT TILL CHANNEL SAVE ROUTINES
					; ARE DEFINED BELOW (IN PASS 2)

		DEV'SAV==SAV'PI		;CHANNEL AC SAVE ROUTINE LOCATION
		DEV'RET==RET'PI		;CHANNEL AC RESTORE ROUTINE LOCATION
					; (USUALLY POPJ USED)
		DEV'CHL==CH'PI		;LOCATION WHERE INTERRUPT PC IS STORED
		DEV'SAC==SAVAC'PI	;STARTING CHANNEL SAVE LOCATION FOR AC'S
		DEV'P==CH'PI'P	;LOCATION WHERE P STORED
		DEV'JEN==CH'PI'JEN	;LOCATION WHERE INT. IS DISMISSED

		INTERN DEV'SAV, DEV'RET, DEV'CHL, DEV'SAC,DEV'P,DEV'JEN
>>
;NOW GENERATE THE TABLE FOR ONCE AND DEFINE PI CHANNEL ASSIGNMENTS

	INTERNAL INTTAB,INTTB1,INTNUM,SCNN,DSKPIF,DSKPIN

				; ONE FOR EACH JOB + NULL JOB (EXTRA ONE)
		APRN==1		;ALWAYS AN APR
		CLKN==1		;ALWAYS LOWEST PRIORITY CLOCK
IFCPU (KI),<;DK10 ONLY AVAILABLE ON KI10
		TIMN==1		;ALWAYS A DK10
		TM2N==1		;SECOND DK-10 FOR TIMING
>;END IFCPU (KI)

IFCPU (<KI,KL,F3>),<
	DSKPIN==LI.CON	;SET PI ON BIT - WILL ALSO HAVE PI ON FOR DISK CONTOLLERS
	DSKPIF==LI.COF	;AND FOR PI OFF
> ;END IFCPU KI,KL,F3

INTTAB:			;TABLE OF DATA FOR DEFINING PI CHAN AND NUMBER OF DOB
	NOSAV==0	;DO NOT SUPPRESS GENERATION OF SAVE ROUTINES
	INTTB1==INTTAB+1

	ASGSAV SCN,0	;NO PI CHANNEL FOR SCNSER (AT CLOCK)
	ASGSAV ACT,0

.CHAS==0
.CH==0
NEXTCH		;BEGIN AT CHANNEL 1

IFCPU (<KI,KL,F3>),<
;THE FOLLOWING DEVICES MUST HAVE A UNIQUE, HIGH PRIORITY
; CHANNEL FOR BLOCK I/O TRANSFERS.


IFNDEF BLKMXC, <BLKMXC==.CH>	;REMEMBER THIS CHANNEL ON PASS 1
.CH==BLKMXC			;ON PASS 2, SKIP OVER BLKI CHANNELS


;THE FOLLOWING ARE GROUPED ON A CHANNEL FOR HIGH-PRIORITY DEVICES
	ASGSAV CDR,\.CH
> ;END IFCPU KI,KL,F3
	ASGINT APR,\.CH
IFCPU (KI),<;DK10S ONLY EXIST ON KI
	ASGINT TIM,\.CH
	ASGINT TM2,\.CH
>;END IFCPU (KI)

NEXTCQ

IFCPU (<KI,KL,F3>),<
;THE FOLLOWING ARE MEDIUM-PRIORITY DEVICES, AS A GROUP
	ASGSAV PTR,\.CH
	MULASG LPT,LP,\.CH,0
;	ASGSAV DTA,\.CH
;	ASGSAV DTC,\.CH
;	ASGSAV MTA,\.CH
;	ASGSAV MTB,\.CH
;	ASGSAV MTC,\.CH

NEXTCQ



;THE FOLLOWING ARE LOWER-PRIORITY DEVICES, AS A GROUP
				;FIRST ARE THE VARIOUS TYPES OF DISK CONTROLLERS....

	MULASG FHD,FH,\.CH,1
	MULASG DPC,DP,\.CH,1
	MULASG SAX,SA,\.CH,-1
	MULASG APX,AP,\.CH,-1
IFN SAXN,<SAXCHN==:SA0CHN
	  SAXSAV==:SA0SAV>
IFN APXN,<APXCHN==:AP0CHN
	  APXSAV==:AP0SAV>
	ASGSAV DSK,0	;GET DSK IN CHAIN, NO INTERUPT CODE (SEE ABOVE
	ASGSAV MAG,\.CH


DEFINE MNYASG(DE,UU)
<IRP UU,<IFNDEF DE'UU'UN, <STOPI>
	 IFDEF DE'UU'UN, <DE'UU'N==DE'UU'UN
			  ASGSAV DE'UU,0
			 >
	>
>

MNYASG(FT,<A,B,C,D,E,F,G,H,J,K,L>)


;	ASGSAV PEN,\.CH
	ASGSAV PTP,\.CH
;	ASGSAV CDP,\.CH
	ASGSAV PLT,\.CH

NEXTCQ

;THE DISPLAY GETS ITS OWN LOW-PRIORITY CHANNEL
;	ASGSAV DIS,\.CH

NEXTCQ
> ;END IFCPU KI,KL,F3

IFCPU (KS),<

;GEN INTTAB ENTRIES OF FORM: NO. OF DDBS, DEVINT
;			LENGTH OF DDBS , PROTOT DDB ADDR.
DEFINE GENDDB (DEV) <
	IFG DEV'UN,<
		EXTERN DEV'INT,DEV'DDS,DEV'DDB
		XWD DEV'UN*1000,DEV'INT
		XWD DEV'DDS,DEV'DDB>
> ;END DEF OF GENDDB.

;SET THE INTTAB ENTRY FOR THE DISK

	XWD	0,RMXINT##	;WORD 1 OF INTTAB
	0

	ASGSAV DSK,0
IFN LPTN,<1*1000,,0
	LP0DDS,,LP0DDB>

IFCPU(KS),<
	0,,MAGINT##		;Entry for tapes.  Note 0 "units" indicates
	MAGDDS##,,MAGDDB##	; the DDBs are already linked.
>;IFCPU(KS)END

PIHIGH==:3	;PI FOR DISK AND TAPE.
PILOW==:2	;PI FOR OTHER DEVICES.

	DSKPIF==LI.COF!<1_<7-PIHIGH>>
	DSKPIN==LI.CON!<1_<7-PIHIGH>>
> ;END IFCPU KS.



;LAST IS THE SCHEDULER, ON CHANNEL 7 BY ITSELF

IFG <.CH-7>, <	PRINTX ;NOT ENOUGH PI'S TO SERVICE THIS CONFIGURATION.
		PRINTX ;SUGGEST EDITING COMMON TO PUT MORE DEVICES ON
		PRINTX ; A SINGLE CHANNEL
>

.CH==7
	ASGINT CLK,\.CH

;	SPCINT
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NOT USE A CHANNEL SAVE ROUTINE AND HAVE
				; NO DEVICE DATA BLOCK
;	SPCDDB
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				;WHICH HAVE MULTIPLE DEVICE DATA BLOCKS (0 MEANS NONE)
;	SPCSAV
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NEED A CHANNEL SAVE ROUTINE

;END OF THE ASSIGNMENT TABLE

	INTNUM==INTTAB-.	;-LENGTH OF INTERRUPT CHANNEL ASSIGNMENT TABLE

XP ITMCHN,APRCHN		;INTERVAL TIMER PI ASSIGNMENT SAME AS THAT OF APR.

IFCPU (KS),<
RM0VEC=254
MAGVEC=224
IFNDEF RM0UN,<RM0UN=4>
IFNDEF MAGUN,<MAGUN=1>
;GEN DISPATCH VECTOR TABLE ENTRIES.
DEFINE GENVEC (DEV), <
	IRP DEV
		<IFG DEV'UN,<
			IFNDEF DEV'INT,<EXTERNAL DEV'INT>
			XWD DEV'INT,DEV'VEC/4
			>
>
>

TBISAV::GENVEC <RM0,LPR,MAG>
	TBISIZ==:.-TBISAV

;EPT+EPTVIT WILL BE THE REAL TABLE, NO CONFLICT ASSUMED
;  BETWEEN THE DEVICE VECTOR ADDRESSES AND EPT DEFINED SLOTS
>;END IFCPU KS


	IFLE .-SYSEND, <LOC SYSEND+1>
				; SET LOC UP TO SYSEND+1, UNLESS ONCE ONLY CODE
				; IS BIGGER
;SYSTEM CONSTANTS AND PARAMETERS

;; Negative indexes from CNFTBL are used by CRSHID and are not GETTAB-able.
;; Their position is subject to change and should not be published!

	CRSDB,,NUMTAB##		;(-2) so CRSHID can do "GETTABs"
CURUPT::0			;(-1) CONTAINS DATAO STUFF FOR CURRENT UPT

CNFTBL:: ;origin of GETTAB table 11 (configuration data)
	; octal numbers in () correspond to the index relative to CNFTBL
	; certain tools expect physical address 137 to point to CNFTBL
	; (these locations not cleared by SYSINI)
CONFIG::SYSNAM			;(0-4) NAME OF SYSTEM, IN ASCII
	LOC CONFIG+5		; ALWAYS LEAVE 5 WORDS (24 CHARS)
SYSDAT::SYSDAT			;(5,6) GENERATE SYSTEM DATE
	LOC SYSDAT+2		; ALWAYS LEAVE 2 WORDS (9 CHARS)
SYSTAP::SYSDEV			;(7) NAME OF SYSTEM DEVICE, IN SIXBIT
;LOCATIONS SETUP BY ONCE ONLY OPERATOR DIALOGUE AND NEVER RESET ON RESTARTS
TIME::	0			;(10) TIME OF DAY IN JIFFIES (60TH OR 50THS OF A SEC)
THSDAT::0			;(11) TODAY'S DATE ((Y-1964)*12+(M-1))*31+(D-1)
SYSSIZ::exp PATCH##		;(12) SIZE OF MONITOR (FIRST LOC NOT USED)
DEVOPR::sixbit /CTY/		;(13) SIXBIT PHYSICAL NAME OF OPERATORS CONSOLE
				; (IF THIS LOCATION CONTAINS 0, NONE HAS
				; BEEN DESIGNATED)
				; PUBLIC LOGICAL NAME "OPR" WILL BE THIS
				; DEVICE. ALSO UNEXPLAINED MONITOR ERROR
				; MESSAGES WILL BE TYPED ON TTY OPR:
DEVLST::xwd 0,0			;(14) LH CONTAINS ADDRESS OF FIRST DEVICE DATA BLOCK
				; ONCE ONLY CODE LINKS DEVICE DATA BLOCKS
	xwd 0,JOBN		;(15) AOBJN POINTER TO 1ST HIGH SEG IN JBTXXX TABLES
				; LH= - NUMBER OF HIGH SEGS,  RH= 1ST HIGH SEG NUMBER
				;(NO MORE HISEGS, BUT SOME USE THIS
				; TO GET NUMBER OF JOBS, USE C(RH)-1)
	0			;(16) FLAG TO INDICATE WHETHER BOTH HARDWARE AND
				; SOFTWARE HAVE 2 RELOC REG CAPACITY
				; NON-ZERO IF BOTH DO, 0 IF EITHER OR BOTH DO NOT
				; SET BY ONCE ONLY CODE

;STATES WORD LH BITS:
	ZZ==0
	ZZ==ZZ!1B0		; 1 IF DISK SYSTEM (ANALOGOUS TO FTDISK)
	ZZ==ZZ!1B1		; 1 IF SWAPPING SYSTEM (ANALOGOUS TO FTSWAP)
	ZZ==ZZ!1B2		; 1 IF LOGIN (ANALOGOUS TO FTLOGIN)
	ZZ==ZZ!1B3		; 1 FOR TTCALL, FULL DUPLEX
	ZZ==ZZ!1B4		; 1 IF PRIVILEGE FEATURE INCLUDED
	ZZ==ZZ!1B5		; 1 IF REENTRANT SOFTWARE
	ZZ==ZZ!1B9		; 1 IF LEVEL D DISK SOFTWARE
				; 0 if level C, 2 if spooled disk
	IFN INDPPN,<ZZ==ZZ!1B10>; 1 IF INDEPENDENT PROJ-R NUMBERS
	ZZ==ZZ!1B11		; 1 FOR IMAGE, 8-BIT SCNSER
;B12-B17 defined for TOPS-10, not applicable to TYMCOM-X
	ZZ==ZZ!0B12		; 1 if dual processor system
	ZZ==ZZ!0B13		; 1 if TOPS-10 style multiple RIBs
	ZZ==ZZ!0B14		; 1 if high precision time accounting
;*;	ZZ==ZZ!1B15		; 1 if exclude monitor overhead from accounting
	ZZ==ZZ!0B16		; 1 if system includes real-time clock
;*;	ZZ==ZZ!1B17		; 1 if system built for FOROTS version 5A

;STATES word, TOPS-10 RH bits:
;000001=1B35  no login except on CTY or subjob of OPSER
;000002=1B34  no login on "remote" lines (don't answer datasets)
;000004=1B33  batch jobs only
;000010=1B32  no logins from ANF10 or DECnet nodes
;000100=1B29  allow ASSIGN of restricted devices
;000200=1B28  allow unspooling for all users
;000400=1B27  no operator in attendance
;001000=1B26  no automatic reload of ANF-10 nodes (NETLDR program)

;STATES word, TYMCOM-X RH bits (defined in S.MAC):
;STAUTO	;1B17 System in auto-restart (note: this is an LH bit!)
;STSHUT	;1B18 System is shut
;STSUPR	;1B19 System is super-shut (don't allow shut-override)
;STRLB	;1B20 Restricted logins.  See LOGINN.MAC at NONRES-7
;STMDED	;1B?? IF CHKPNT WATCHDOG FOUND CHKPNT DEAD

STATES::exp ZZ!STAUTO!STSHUT!STSUPR ;(17) LH BITS=TYPE OF SYSTEM
				; RH PATCHED BY "SCHED" COMMAND TO
				; INDICATE OPERATIONAL STATE OF SYSTEM
SERIAL::exp <APRSN&777777>	;(20) SERIAL NUMBER OF CENTRAL PROCESSOR (APR)
				; GETS OVERWRITTEN BY APRID IN ONCE
MEMNSP::exp NSPMEM		;(21) NANO-SEC PER MEMORY CYCLE
FREPTR:: 0			;(22) AOBJN WORD POINTING TO USE BIT MAP OF
				; MONITOR FREECORE BLOCKS. SET BY ONCE
				; NEVER CHANGED WHILE MONITOR RUNS.
LOCORE:: 0			;(23) LH=0, RH=ABS. ADR. OF 1ST FREECORE CHUNK
				; SET BY ONCE ONLY CODE AND NEVER CHANGED WHILE
				; MONITOR RUNS.
NUMLIN::exp PORTN		;(24) # OF PORTS
LGONAM::SIXBIT /LOGOUT/		;(25) NAME OF LOGOUT PROGRAM
JFYSEC::0			;(26) JIFFIES/SEC
JFYMIN::0			;(27) JIFFIES/MIN
JFYHR::	0			;(30) JIFFIES/HOUR
HGHBLK::0			;(31) HIGHEST BLOCK IN ADRESSABLE CORE
HFDBUF::xwd M.SBSZ,0		;(32) HISTOGRAM FACILITY (SNOOPY)
				; BUFF PTR. 0 IF NONE ALLOCATED BY LNKDB
				; (STANDARD); ELSE SIZE,,BEG LOC
SYSNUM::.-.			;(33)SYSTEM NUMBER, FILLED IN BY ONCE ONLY.
FRECOR::exp FCWDS		;(34)AMOUNT OF FREECORE ALLOCATED
CRSCNT::exp ^D1800		;(35)TICS ALLOWED FOR SOFT CRASH
	SAV30,,NUMTAB##		;(36)ADDRESS OF THINGS FOR CRSHID
extern	PATCH,PATEND,TTYINI,TTIEND
DSKPAT::PATCH-PATEND,,PATCH	;(37)AOBJN pointer to PATCH area patches
RUNPAT::TTYINI-TTIEND,,TTYINI	;(40)AOBJN pointer to TTYINI area patches
CNFCPU::CPUTYP			;(41)cpu model index (KI,KL,KS,F3)
PATMAP::0			;(42)bit mask of patches installed
CNFSID::;SYSID			;(43)sixbit monitor ID (serial number)
SYSIDL##,,SYSIDR##; work around MACRO/LOADER bug regarding 36bit externs

REPEAT 0,<;Definitions from TOPS-10 COMMON.702
PTYCNF:	XWD	PTYOFS##,PTYN	;(22) PTY PARAMETERS FOR BATCH
FREPTR::0			;(23) AOBJN WORD POINTING TO USE BIT MAP OF
				; MONITOR 4-WORD CORE BLOCKS. SET BY ONCE ONLY CODE
				; NEVER CHANGED WHILE MONITOR RUNS.
LOCORE::0			;(24) LH=0, RH=ABS. ADR. IN MONITOR OF FIRST WORD OF
				; MONITOR TO BE ALLOCATED IN 4-WORD CHUNKS.
				; SET BY ONCE ONLY CODE AND NEVER CHANGED WHILE
				; MONITOR RUNS.
STBPTR::EXP	0		;(25) POINTER NOT USED WITH NETWORKS
OPRLDB::0			;(26) LDB OF OPR TELETYPE
TTFREE::0			;(27) FILLED IN AT ONCE TIME BY FREE LIST ADR
TTCLST::XWD	TTCHKN,0	;(30) NUMBER OF TTY CHUNKS, ADDRESS OF FIRST ONE
TTFREN::0			;(31) NUMBER OF FREE TTY CHUNKS AT THE MOMENT
LINSAV::0			;(32) POINTER TO CURRENT TTY SEEN BY COMMAND DECODER
LINPTR::XWD MTTYLN##,LINTAB	;(33) POINTER TO EXAMINE TTY LINE TABLE,
MONVER:	EXP	A00VER		;(34) VERSION OF MONITOR (LH FOR CUSTOMER)
DSCPTR::XWD MDSLN##,DSCTAB##	;(35) POINTER TO DATASET CONTROL TABLE
DLSRWD::0			;(36) LAST RECEIVE INTERRUPT FROM DC10
CCIRWD::0			;(37) LAST RECEIVE INTERRUPT FROM 680
SEGPT1::EXP	JOBN		;(40) LAST DORMANT SEG NUMBER THROWN AWAY
				; TO FREE UP A SEG NUMBER.
LASPOK::0			;(41) CONTAINS ADR. OF LAST LOCATION CHANGED
				; IN MONITOR BY A SUCCESSFUL POKE UUO.  (NOT CLEARED
				; ON 403 RESTART SINCE CHANGE IS STILL VALID
LASPUC::0			;(42) RH=COUNT OF NUMBER OF SUCCESSFUL POKE UUOS
				; SINCE SYSTEM WAS LOADED.
				; LH=JOB NO. OF LAST JOB WHICH
				; SUCCEEDED IN CHANGING MONITOR VIA POKE
				; THE TWO ABOVE LOCATIONS ARE USEFUL
				; IN CRASH ANALYSIS AND FOR DAEMON LOGGING
WHYCOD::0			;(43) CONTAINS SIXBIT UNABBREVIATED OPERATOR ANSWER
				; FOR WHY RELOAD ONCE ONLY QUESTION.  SEE ONCE (WHYTAB)
				; FOR A LIST OF POSSIBLE CODES.  0 MEANS FTWHY=0 SO NO
				; QUESTION
>  ;End of TOPS-10 7.02 conflicting definitions

TICSEC:: ^D60		;(44) CONTAINS NUMBER OF TICKS PER SECOND
PDBPTR:	XWD 0,0;JBTPDB	;(45) RH=POINTER TO TABLE OF PDB'S FOR JOBS
			; LH=0 FOR FUTURE EXPANSION
RTCUPS:: 0		;(46) RESOLUTION (UNITS/SEC.) OF CLOCK USED FOR RUN ACCT
SYSCHN::0;XWD CHN0CB##,0;(47) LH=ADR OF FIRST CHANNEL (DF10) DATA BLOCK, RH=UNUSED
LOGMAX::EXP	JOBMAX	;(50) MAX.# JOBS ALLOWED TO BE LOGGED IN
BATMAX::EXP 0;	M.BMAX	;(51) MAX.# BATCH JOBS ALLOWED
BATMIN::EXP 0;	M.BMIN	;(52) MIN.# BATCH JOBS GUARENTEED (RESERVED)
DATE::	 0		;(53) DATE TIME IN UNIVERSAL DATE/TIME (UDT) FORMAT
	;See also GMTUDT; LH = DAYS SINCE NOV. 17, 1858, RH = FRACTION OF A DAY
LOGNUM:: 0		;(54) NUMBER JOBS CURRENTLY LOGGED IN
BATNUM:: 0		;(55) NUMBER BATCH JOBS CURRENTLY LOGGED IN.
LOCYER:: 0		;(56) LOCAL YEAR
LOCMON:: 0		;(57) LOCAL MONTH (1,2,...,12)
LOCDAY:: 0		;(60) LOCAL DAY OF MONTH (1,2,3,...)
LOCHOR:: 0		;(61) LOCAL HOUR (MIDNIGHT=0) reset by HOUR routine
LOCMIN:: 0		;(62) LOCAL MINUTE (0,1,...,59)
LOCSEC:: 0		;(63) LOCAL SECOND (0,1,...,59)
GMTDIF:: <TIMZON>B17/^D24;(64) DIFFERENCE BETWEEN LOCAL AND GMT TIME. (UDT)
			; IN SAME UNITS AS DATE --
			; E.G. DATE + GMTDIF = LOCAL DATE-TIME
			; (LH = DAY, RH = FRACT. OF DAY)
DEBUGF:: DEFDEB!DEFBPT	;(65) DEBUGGING STATES WORD - SIGN BIT=1 IF SYSTEM PROG IS
			; DEBUGGING MONITOR (SPEED UP ONCE ONLY)
			; BIT1=1 TO RELOAD ON DEBUG STOPCD'S
			; BIT2=1 TO RELOAD ON STOPCD'S WHICH ONLY
			; AFFECT 1 JOB
			; BIT3=1 TO DISABLE AUTO-RELOADS
			; BIT4=1 TO STOP SYSTEM IF ANY CPU GETS A CPU STOPCD
FRUSED:: 0		;(66) AMOUNT OF FREE CORE IN USE
RCCMAX:: 0		;(67) NUMBER OF BYTES IN TTY CHUNKS
CNFCVN: EXP	A00CVN	;(70) CUSTOMER VERSION (=C(136))
CNFDVN: EXP	AXXDVN	;(71) DEC VERSION (=C(137))
CNFCHN::EXP 0;	M.CHN	;(72) NUMBER OF DATA CHANNELS
CNFRTD::EXP 0;	M.RTD	;(73) NUMBER OF REAL TIME DEVICES
CNFHPQ::EXP 0;	M.HPQ	;(74) NUMBER OF HPQ'S
CNFLDB::EXP	DDBLDB##;(75) WORD IN TTY DDB WHICH POINTS TO LDB
CNFMVO::EXP 0;	PSIMVO	;(76)MAX. VECTOR OFFSET FOR PISYS. UUO
CNFMIP::EXP 0;	PSIMPI	;(77)MAX. PRIORITY FOR PSISER
CNFMTA::XWD 0;	TUBRID##,MT0DDB##  ;(100) POINTER TO FIRST MTA DDB AND INDEX
				   ; OF START OF DAEMON INFORMATION
CNFET1:	EXP 0;	JOBDAC##+T1	;(101) EXEC AC1 IN USER'S ADDRESS SPACE
CNFLSD:	EXP 0;	DEVLSD		;(102) LENGTH OF SHORT DDB
CNFLLD:	EXP 0;	DEVLLD		;(103) LENGTH OF LONG DDB
CNFLDD:	EXP	DDBLEN##	;(104) LENGTH OF DISK DDB
CNFEXM:	EXP	JOBEXM##	;(105) WORD IN JOBDAT USED BY "E" AND "D" COMMAND
	ZZ==0
	ZZ==ZZ!1B35		;BIT 35=1 IF SWAP SPACE ALLOCATED IN PAGES
;IFN M.TM10,<ZZ==ZZ!1B34>	;BIT 34=1 IF MTA ERROR REPORTING
	ZZ==ZZ!1B33		;BIT 33=1 IF VM MONITOR
;IFN M.IPCF,<ZZ==ZZ!1B32>	;BIT 32=1 IF IPCSER IS LOADED
;IFN M.PSI,<ZZ==ZZ!1B31>	;BIT 31=1 IF PSISER IS LOADED
;IFN M.MSG,<ZZ==ZZ!1B30>	;BIT 30=1 IF MSGSER IS LOADED
	ZZ==ZZ!1B29		;BIT 29=1 IF NON-SUPER ENTER IS SUPPORTED
;IFN FTNSCHED,<ZZ==ZZ!1B28>	;BIT 28=1 IF NEW SCHEDULER IS PRESENT
;IFN M.EQDQ,<ZZ==ZZ!1B27>	;BIT 27 IF ENQ/DEQ IS LOADED
;IF2, <ZZ==ZZ!<<ZGAL>B26>>	;BIT 26=1 IF MONITOR CONTAINS GALAXY-10 FEATURES
;ZZ==ZZ!1B25			;BIT 25=1 MONITOR SUPPORTS MASSBUS ERROR REPORTING
;ZZ==ZZ!1B24			;BIT 24=1 IF NEW TAPSER
;ZZ==ZZ!1B23			;BIT 23=1 IF NEW ERROR REPORTING
;ZZ==ZZ!1B22			;BIT 22=1 IF MONITOR SUPPORT MORE THAN 127 JOBS.
;IFN M.EXE,<ZZ==ZZ!1B21>	;BIT 21=1 IF "SAVE" COMMAND PRODUCES EXE FILE
;IFN M.EMRT,<ZZ==ZZ!ST%EMR>	;BIT 20=1 IF EBOX/MBOX RUNTIME IS IN EFFECT (KL ONLY)
;IFN M.XPI,<ZZ==ZZ!ST%XPI>	;BIT 19=1 IF PI TIME IS EXCLUDED FROM USER RUNTIME (KL ONLY)
;ZZ==ZZ!1B18			;BIT 18=1 IF FULL 6 CHAR DEVICE NAMES
;IFN M.ITA,<ZZ==ZZ!ST%ITA>	;BIT 17=1 IF INTERVAL TIMER ON KL10 IS AVAILABLE
;IFE M.CLSS,<ZZ==ZZ!ST%NCS>	;BIT 16=1 IF NOT CLASS SYSTEM SCHED.
;ZZ==ZZ!ST%NER			;BIT 15=1 MONITOR SUPPORTS 6.03 ERROR REPORTING
;IFN M.ACV,<ZZ==ZZ!ST%ACV>	;BIT 14=1 IF ACCOUNT VERIFICATION SHOULD BE DONE
;IFN FTKL10!FTKS10,<ZZ==ZZ!ST%LSC> ;BIT 13=1 IF LOW SEGMENT OF MONITOR IS CACHED
;IFN FTMDA,<ZZ==ZZ!ST%MDA>	;BIT 12=1 IF ALLOCATOR WILL RUN
;IFN FTKLP,<ZZ==ZZ!1B11>	;BIT 11=1 IF KL RATHER THAN KI PAGING
;IFN M.DECN,<ZZ==ZZ!1B10>	;BIT 10=1 IF PHASE 3 DECNET LOADED
CNFST2::EXP	ZZ		;(106) FLAG BITS DEFINED ABOVE
PISYMN: EXP 0;	M.PSI*C$MIN	;(107) MINIMUM CONDITION FOR PISYS.UUO
PITLEN: EXP 0;	PITSIZ		;(110)LENGTH OF PI TABLE
CNFPIA::EXP 0;	JBTPIA		;(111)ADDRESS OF JBTPIA
%CNMNT:	BYTE	(1)0(17)0(6)5(6)0(6)0	;(112) TYPE OF MONITOR
					;    (1)=STRANGE
					;    (17)=RESERVED TO DEC
					;    (6)=TYPE:	1=TOPS-10
					;		2=I.T.S.
					;		3=TENEX
					;		4=TOPS-20
					;		5=TYMCOM-X
					;		REST RESERVED TO DEC
					;    (6)=SUBTYPE (RESERVED TO DEC)
					;    (6)=RESERVED TO CUSTOMERS

;* * *
;* * * THIS IS THE END OF THE CONFIG GETTAB TABLE: add new entries above
;* * *
CNFMXL==:<.-CNFTBL-1>B26		;MAXIMUM ENTRY IN CNFTBL FOR GETTAB M

  REPEAT 0,<	;Unimplemented items from 7.02
	CR0DDB,,CDRCNT##	;(113)OFFSET TO CARD COUNT FOR CDR
	CP0DDB##,,CDPCTO##	;(114)OFFSET TO CARD COUNT FOR CDP
EXP	PAGSIZ			;(115)BASIC UNIT OF CORE ALLOCATION
EXP	MINMAX			;(116)MIN VALUE FOR CORMAX
EXP	M.CLSN			;(117)NUMBER OF SCHEDULER CLASSES
EXP	0			;(120)EXPONENTIAL FACTOR USED IN COMPUTING USER TIME
SYSORG::	0		;(121)
SYSLEN::	0		;(122)
NWCORE::2000*M.NKC		;(123)NUMBER OF WORDS OF CORE
NXMPTR::0			;(124)AOBJN POINTER TO NXMTAB USED TO SCAN FOR ZEROES
	EXP	NETNDB##	;(125)POINTER TO THE FIRST NODE BLOCK
CNFTKB:	EXP	TKBCDB##	;(126)POINTER FROM KDB TO CDB FOR MAGTAPES
	EXP	0		;(127) OBSOLETE
HNGLST::XWD	0,0		;(130)LH IS ADDRESS OF FIRST DEVICE WHICH SHOULD BE
				; CHECKED TO SEE IF IT IS HUNG
	EXP	BOOTXT		;(131) ADDRESS OF RELOAD CCL TEXT
	EXP	TUBDDB##	;(132) OFFSET OF DDB PTR'S IN TUB
	EXP	MT0KDB##	;(133) 1ST MTA KDB IN SYS
NOCPUS::EXP	M.CPU		;(134) NO OF CPUS MONITOR WAS BUILT FOR
CNFDJB:	XWD	PJBNLH,DEVJOB	;(135) GETTABLE PJOBN (SANS INDEX FIELD)
UPTIME::
SYSUPT::EXP	0		;(136) SYSTEM UPTIME
BOOTCP::EXP	-1		;(137) BOOT CPU NUMBER
BOOTCT::EXP	CT0LIN		;(140) BOOT CPU CTY LINE NUMBER
NCPRUN::EXP	M.CPU		;(141) NUMBER OF CPUS ALLOWED TO RUN
STRMON::SIXBIT	/SYS/		;(142) FILE STRUCTURE MONITOR WAS BOOTED FROM
FILMON::SIXBIT	/SYSTEM/	;(143) FILE NAME
EXTMON::SIXBIT	/EXE/		;(144) EXTENSION
PPNMON::XWD	1,4		;(145) PPN
SYSNBP::EXP	MAXNBP		;(146) MAXIMUM NUMBER OF BREAK POINTS FOR SNOOP.
MONVFF::EXP	MONORG		;(147) FIRST FREE VIRTUAL ADDRESS ABOVE MONITOR
LDBVRG::EXP	0		;(150) VIRTUAL ADDRESS OF THE ORGIN OF LDBS
FOPHXC::EXP	HIGHXC-20	;(151) NUMBER OF EXTENDED CHANNELS AVAILABLE VIA FILOP.
MONHSO:	EXP	MONORG		;(152) VIRTUAL ADDRESS OF START OF MONITOR HIGHSEG
RSDTTM::EXP	0		;(153) UNIVERSAL DATE/TIME OF LAST ROLE SWITCH
CNFDCH:	EXP	LDBDCH##	;(154) OFFSET OF LDBDCH IN LDB'S
SFDMON::EXP	0		;(155) 1ST SFD MONITOR WAS BOOTED FROM
	EXP	0		;(156) 2ND SFD MONITOR WAS BOOTED FROM
	EXP	0		;(157) 3RD SFD MONITOR WAS BOOTED FROM
	EXP	0		;(160) 4TH SFD MONITOR WAS BOOTED FROM
	EXP	0		;(161) 5TH SFD MONITOR WAS BOOTED FROM
	EXP	FRCLIN		;(162) TTY LINE NUMBER OF FRCLIN
PTYPTR:	XWD	-PTYN,PTYTAB	;(163) POINTER TO PTY TABLE
	XWD	-LATLEN##,NETLAT## ;(164)-LENGTH,,LOCATION LINK ADDRESS TABLE
CNFLPD:	EXP	.PDLEN		;(165) LENGTH OF A PDB
	XWD	0,PAGSIZ	;(166) XWD FLAG, SIZE OF LARGEST JOBPEK TRANSFER
				; WHERE FLAG=0 IF SWAP SPACE JOBPEK'S MAY NOT
				; CROSS A PAGE BOUNDARY, FLAG=1 IF THEY MAY
	EXP	CNFDAE		;(167) XWD OLD DAEMON NAME,CURRENT MONITOR
				; VERSION. OLD DAEMON NAME IS THE SIXBIT NAME
				; OF THE PREVIOUS MONITOR, E.G. 701.
CNFHSH::XWD	-HSHLEN,HSHTAB	;(170) AOBJN POINTER TO HSHTAB
	EXP	<.PDACS-.PDBEG>	;(171) OFFSET IN PDB FOR ACCOUNT STRING
	XWD	TOPLN1##,TOPTB1## ;(172) POINTER TO TOPTB1, TRMOP DISPATCH
	EXP	JBTSFD##	;(173) POINTER TO JBTSFD
	EXP	CIPWT		;(174) POINTER TO CLOCK QUEUE
CNFMXL==:<.-CNFTBL-1>B26	;MAXIMUM ENTRY IN CNFTBL FOR GETTAB UUO

;----------------------------------
;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY ONCE ONLY CODE.
; OR ARE CONSTANTS WHICH ARE NOT CLEARED AT STARTUP
;-------------------------------------
TICMIN::JIFMIN			;NUMBER OF TICKS PER MINUTE (CALCULATED BY ONCE)
TIMLST::0			;VALUE OF "TIME" LAST TIME AT CLOCK LEVEL
				; USED FOR ALL TIMING FUNCTIONS, E.G.,
				; MAINTAINING CLOCK QUEUE AND SMITHSONIAN DATE
>  ;End of TOPS-10 definitions
;REMOTE PORT STUFF

IFE NUMPRT,<
XP VALRMT,CPOPJ
XP IDLRMT,CPOPJ
XP DDT620,CPOPJ
XP CRERMT,CPOPJ
XP ZAPRMT,CPOPJ
XP RMTRSI,CPOPJ
XP CKRMT,CPOPJ	;THESE ROUTINES NOT REALLY THERE
XP RMTINI,CPOPJ
CH2RMT::	JRST (T1)	;DOES NOTHING OF NO RMTSER
>

;GETTAB TABLE OF QUEUE CODES FOR JOBS - TABLE(RH)=25
;MUST BE A SEPARATE TABLE SINCE THE NUMBER OF ENTRIES VARIES ACCORDING
;TO THE CONFIGURATION

;ENTRIES ARE 2 SIXBIT CHARACTERS, THREE PER WORD
;STATE CODE 0 IS LEFT THIRD, 1 IS MIDDLE THIRD, 2 IS RIGHT THIRD OF FIRST WORD
;STATE CODE 3 IS LEFT THIRD OF SECOND WORD, ETC.

STSTBL::

DEFINE X(A,B,C)
<	IFE ZZ-ZZ/3*3-0,
  <	  XX==   <SIXBIT /A/&7777B11>B35>
	IFE ZZ-ZZ/3*3-1,
  <	  XX==XX!<SIXBIT /A/&7777B11>B47>
	IFE ZZ-ZZ/3*3-2,
  <	  XX==XX!<SIXBIT /A/&7777B11>B59
	  EXP XX>
ZZ==ZZ+1
>

ZZ==0
	QUEUES
	CODES
	IFN ZZ-ZZ/3*3-0,<
	  EXP XX>

STSMXL==:<.-STSTBL-1>B26	;MAX ENTRY IN STSTBL FOR GETTAB UUO
ODPTBL::			;FIRST LOCATION IN MONITOR DATA AREA FOR DISK-
				; RELATED LOCATIONS WHICH ARE NOT SET TO 0
				; WHEN THE SYSTEM IS STARTED UP.
				; ODPTBL IS GETTAB TABLE NUMBER 15.

SWPHGH::0	; (obsolete)	;(0) HIGHEST LOGICAL BLOCK # ASSIGNED FOR
				; SWAPPING. SPACE IS ASSIGNED FROM HIGHEST
				; BLOCK # DOWNWARDS.

K4SWAP:	0	; (obsolete)	;(1) # OF J OF DISK WORDS SET ASIDE FOR
				; SWAPPING. ASSIGNED AT ONCE ONLY REFRESH
				; TIME.

ICPFACTOR==:1			;FACTOR BY WHICH TO MULTIPLY AVERAGE SWAP-IN
				; TIMES TO PRODUCE IN-CORE PROTECT TIMES.
KXFTIM==1			;SET PROTECT TIMES TO 1
IFCPU (<KI,KL>),<SEEKTM==1>	;Set PROT0 to 2 for KI and KL
IFNCPU(<KI,KL>),<SEEKTM==3>	;Set PROT0 to 4 for KS and F3

PROT::	EXP ICPFACTOR*KXFTIM	;(2) IN-CORE PROTECT TIME PARAMETER TO BE
				; MULTIPLIED BY <J-1> OF CORE IN JOB.

PROT0::	EXP ICPFACTOR*<SEEKTM+KXFTIM>;(3) IN-CORE PROTECT TIME PARAMETER TO
				; BE ADDED TO ABOVE RESULT.

MXPROT::  EXP ^D60		;(4) MAX VALUE FOR ICPT FUNCTION, KEEP CORE
				; FROM GETTING CLOGGED WITH HUGE JOBS WITH
				; HUGE ICPT WHICH SCHEDULER DOESNT WANT TO
				; RUN. /AA

DCN::	DCFULL+(DCNDFT)		;(5) DSKCLN TYPE DESIRED, DEF IS FULL, INIT HM
EXTERN	DCNDFT			; Default DSKCLN bits from ONCDSK

;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY
; ONCE ONLY CODE AND WHICH PERTAIN ONLY TO DISK SYSTEMS.
ODPMXL==:<.-ODPTBL-1>B26	;MAXIMUM ENTRY IN ODPTBL FOR GETTAB M

;DISK LOCATIONS NOT IN GETTAB

REFLAG:: 0			;FLAG LOCATION TO INDICATE WHETHER ANY REFRESHING
				; OCCURRED AND TO CONTAIN THE [PROJ,R]
				; NUMBERS FOR AUTOMATIC LOG-IN FOLLOWING REFRESH.
;MORE DATA LOCATIONS SETUP AT ASSEMBLY TIME OR ONCE ONLY TIME
; BUT NOT OF INTEREST TO USER PROGRAMS

;MONTH TABLE FOR DAYTIME COMMAND PRINTING

PMONTB::POINT 6,MONTAB(T1),5	;POINTER TO NUMBER OF DAYS IN MONTH
MONTAB::EXP ^D30B5+"JAN"
	EXP ^D27B5+"FEB"
	EXP ^D30B5+"MAR"
	EXP ^D29B5+"APR"
	EXP ^D30B5+"MAY"
	EXP ^D29B5+"JUN"
	EXP ^D30B5+"JUL"
	EXP ^D30B5+"AUG"
	EXP ^D29B5+"SEP"
	EXP ^D30B5+"OCT"
	EXP ^D29B5+"NOV"
	EXP ^D30B5+"DEC"
MIDNIT::0		;NO OF JIFFIES TILL MIDNIGHT
JFYSC2::0		;JIFFIES IN 1/2 SEC
JFY2SC::0		;JIFFIES IN 2 SEC
QQYTTY::0		;JIFFIES IN 1/10 SEC
QQYSD::	0		;JIFFIES IN 1/10 SEC
SYSSZP::0	;SYSTEM SIZE IN PAGES
MEMSZP::0	;MEMORY SIZE IN PAGES
MAXPCB::0	;LARGEST PCB PAGE NUMBER
MINPCB::0	;SMALLEST PCB PAGE NUMBER

;TABLE TRANSLATING BIT NUMBERS TO BITS

BITTBL::ZZ==1B0
REPEAT ^D36,<
	ZZ
	ZZ==ZZ_<-1>
>;END REPEAT ^D36

;Table which gives the absolute number of bit 0 in any given word in a
; bit table.  This is used by SCNSER and COMCON to determine what port
; or frame number a given bit in a given word corresponds to.
; NFLG is the number of words in SCNSER's LINFLG table;
; CFLG is the number of words in COMCON's COMFLG table;
; BFLG is MAX(NFLG,CFLG)+1 for safety.

	BFLG==NFLG+1
IFG <CFLG-NFLG>,<BFLG==CFLG+1>

BITNTB::XYZZY==0
REPEAT BFLG,<
	XYZZY
	XYZZY==XYZZY+^D36
>
SUBTTL	Feature Test Table  (GETTAB '71)

FETTBL::
FETUUO:	1B30!1B32!1B34			;(0) Monitor Call features
FETRTS:	1B26!1B33!1B34			;(1) Realtime & Scheduler features
FETCON:	1B23!1B24!1B26!1B27!1B29!1B30!1B31!1B32!1B33!1B34!1B35 ;(2) Command features
FETACC:	1B28!1B31!1B33!1B34!1B35	;(3) Accounting features
FETERR:					;(4) Error Recovery features
    IFCPU (KI),<1B22!1B27!1B29!1B31!1B35> ;(4) KI
    IFCPU (KL),<1B22!1B23!1B29!1B31!1B35> ;(4) KL
    IFCPU (KS),<1B21!1B22!1B29!1B31!1B35> ;(4) KS
    IFCPU (F3),<1B22!1B24!1B29!1B31!1B35> ;(4) KA bit used for F3
FETDEB:	1B30!1B32!1B33			;(5) Debugging features
FETSTR:	1B20!1B27!1B28!1B29!1B30!1B32!1B33!1B35		;(6) File structure features
FETDSK:	1B20!1B21!1B22!1B23!1B29!1B32!1B33!1B34!1B35	;(7) Internal disk features
FETSCN:	1B32!1B35			;(10) Scanner features
FETPER:	1B29!1B30!1B31!1B32!1B35	;(11) I/O features
FETPE2:	Z				;(12) More I/O features
FETDS2:	Z				;(13) More Internal Disk features
FETST2:	Z				;(14) More File Structure features
FETUU2:	Z				;(15) More Monitor Call features
FETLEN==.-FETTBL		; Table length
FETMXL==:<FETLEN-1>_^D9		; Length-1 for GETTABs
SUBTTL	Start of STOPCD data (see DIE:: in ERRCON)

;Data base to limit the number of STOPCD's per unit time so that we don't keep
;getting "continuable" STOPCD's that really aren't.  The data base consists of
;two tables, SCCTAB and SCLTAB.  SCCTAB is the count of the number of STOPCD's
;processed during the period indicated by the offset to it in the table.  SCLTAB
;contains, in the left half, the period for this entry and, in the right half,
;the limit of the number of STOPCD's during the period.  Both tables must be
;ordered such that the period of each entry is monotonically increasing.  The
;limits of each period are changable via the MONGEN dialog and may be changed
;by the customer.  When a STOPCD is processed by DIE, STCLIM increments the
;counts of STOPCD's for each entry and compares each with the limit for the
;entry.  If a limit has been exceeded, DIE turns the continuable STOPCD into a
;"stop" STOPCD.  If no limit has been exceeded, STCLIM puts in a clock request
;to call DECSCC after the period of the lowest entry in the table.  DECSCC
;decrements the count of STOPCD's for this entry and puts in a clock request to
;decrement the next higher count.  This continues until all have been
;decremented.  Note, that since the clock queue is used to decrement STOPCD
;counts, the period of the largest entry cannot be larger than 2**18-1 ticks.

SCCTAB::EXP	0		;Number of stopcodes in the last 60 seconds
	EXP	0		;Number of stopcodes in the last  8 minutes
	EXP	0		;Number of stopcodes in the last 60 minutes
SCCTBL==:.-SCCTAB		;LENGTH OF TABLE

ND LIM1MS,2	;Default values, can be overridden by MONGEN
ND LIM8MS,4
ND LIM1HS,8

SCLTAB::XWD	^D60,  LIM1MS	;Period = 1 minute,  Limit = LIM1MS = 2
	XWD	^D480, LIM8MS	;Period = 8 minutes, Limit = LIM8MS = 4
	XWD	^D3600,LIM1HS	;Period = 1 hour,    Limit = LIM1HS = 8

  ;Data for STOPCD processor (see DIE:: in ERRCON)
GMTUDT::^D<30-17+31+1<<1964-1859>*365>+<<1964-1859>/4>-1>,,0 ;112773,,0
			;Number of days since 17-NOV-1858 and 1-JAN-1964
DINITF:: 0		;Nonzero during disk initialization (ONCE)
DIECDB:: 0		;Physical address of CPU Data Block of crashing CPU
EPTSTS:: 0		;EPT status
UPTSTX:: 0		;UPT status

CCPNAM==:'CRSCPY'	;Name of program to run to copy crash

IFCPU (KL),<
SKPMRN::	;Routine to skip if master PDP-11 is running on KL
	JRST	CPOPJ1
CSDMP::	CSHUNL	;Routine to do a cache sweep on a KL
	POPJ	P,
>  ;End of IFCPU KL
SUBTTL	SYSTBL - System wide error data, GETTAB table .GTSYS=51

SYSTBL::!
%SYERR:: 0		;(00) System wide error count
%SYCCO::
CMNOTF:: 0		;(01) Number of times COMCNT was wrong
%SYDEL:: 0		;(02) Count of errors when error logging was disabled
%SYSPC:: 0		;(03) EXEC PC of most recent stopcode
%SYNDS:: 0		;(04) Number of DEBUG stopcodes
%SYNJS:: 0		;(05) Number of JOB stopcodes
%SYNCP::
COMTOT:: 0		;(06) Number of commands processed
%SYSJN:: 0		;(07) Job that caused most recent stopcode
%SYSTN:: 0		;(10) TTY name belong to user at most recent stopcode
%SYSPN:: 0		;(11) Program name running at most recent stopcode
%SYSUU:: 0		;(12) UUO in progress at most recent stopcode
%SYSUP:: 0		;(13) PC of UUO at most recent stopcode
%SYSPP:: 0		;(14) PPN of user running at most recent stopcode
%SYSPD:: 0		;Program directory
%SYSCP:: 0		;Number of CPU that got most recent stopcode
%SYSNM:: 0		;Name of most recent stopcode
%SYSTY:: 0		;Type of most recent stopcode
%SYSDT:: 0		;Date/time of most recent stopcode
%SYNCS:: 0		;Number of continued CPU stopcodes
%SYNIS:: 0		;Number of INFO/EVENT stopcodes
SYSMXL==:<.-SYSTBL-1>B26

DSKBAD:: 0		;Number of INFO/JOB stopcodes that set SLOCRS

SUBTTL	GTBWHY - Operator Reload Comments, GETTAB table .GTWHY=52
;In a running monitor, this table contains the comment the Operator gave when
;reloading the system, such as "Base crash - had to reload KL".
;In a crash dump, this table has the ACs in use at the time of a STOPCD.

CRSHAC:: BLOCK	20	;Operators answer to "Why reload" question in ASCIZ
PREVAC:: BLOCK	20	;Previous context ACs
WHYMXL==:<.-CRSHAC-1>B26

.CPCAC:: BLOCK 20	;Contents of AC block 0
.CPCA0=.CPCAC
.CPCA1::		;This block is not contiguous with .CPCAC in TOPS-10
IFCPU (F3),<BLOCK 20*3>	;AC blocks 1,2,3
IFCPU (KI),<BLOCK 20*3>	;AC blocks 1,2,3
IFCPU (KL),<BLOCK 20*5>	;AC blocks 1,2,3,4,5 (6 and 7 are special in microcode)
IFCPU (KS),<BLOCK 20*5>	;AC blocks 1,2,3,4,5
SUBTTL	SVSETS - Save all AC sets, call via JSR .CPSVA

;Routine to save all AC sets in .CPAC0, .CPAC1, etc.  Returns with
;all ACs preserved and the following locations set up:
;
;	.CPCPG - Argument to DATAO PAG, to restore current AC set
;	.CPACA - Address of saved values for current AC set.
;
;Call:
;		JSR	.CPSVA
;		 return here always

SVSETS:	DATAI	PAG,.CPCPG	;Save current state of AC blocks
IFNCPU(KI),<
	WRUBR	[LG.LAB+1B8]	;Save AC set 1
	MOVEM	17,.CPCA1+17
	MOVEI	17,.CPCA1+00
	BLT	17,.CPCA1+16
	MOVE	17,.CPCA1+17
	WRUBR	[LG.LAB+2B8]	;Save AC set 2
	MOVEM	17,.CPCA1+37
	MOVEI	17,.CPCA1+20
	BLT	17,.CPCA1+36
	MOVE	17,.CPCA1+37
	WRUBR	[LG.LAB+3B8]	;Save AC set 3
	MOVEM	17,.CPCA1+57
	MOVEI	17,.CPCA1+40
	BLT	17,.CPCA1+56
	MOVE	17,.CPCA1+57
IFG <NUMACB-4>,< ;F3 has only 0-3
	WRUBR	[LG.LAB+4B8]	;Save AC set 4
	MOVEM	17,.CPCA1+77
	MOVEI	17,.CPCA1+60
	BLT	17,.CPCA1+76
	MOVE	17,.CPCA1+77
>  ;End IFGE NUMACB-4
IFG <NUMACB-5>,< ;F3 has only 0-3
	WRUBR	[LG.LAB+5B8]	;Save AC set 5
	MOVEM	17,.CPCA1+117
	MOVEI	17,.CPCA1+100
	BLT	17,.CPCA1+116
	MOVE	17,.CPCA1+117
>  ;End IFGE NUMACB-5
	WRUBR	[LG.LAB+0B8]	;And leave AC set 0 as the current one
	MOVEM	17,.CPCA0+17
	MOVEI	17,.CPCA0+00
	BLT	17,.CPCA0+16
	LDB	17,[POINT 3,.CPCPG,8] ;Get number of current AC set
	JUMPN	17,SVSET1	;Go if not AC set 0
	MOVEI	17,.CPCA0	;AC set 0 might not be at .CPCA1-20
	JRST	SVSET2
SVSET1:	IMULI	17,20		;Compute offset into .CPCA1 of this set
	ADDI	17,.CPCA1-20	;Compute address of this nonzero set
SVSET2:	MOVEM	17,.CPACA	;Set address of active AC set
>  ;End IFNCPU(KI)
  PAGE
IFCPU (KI),<	;EXEC mode always uses AC block 0
	MOVEM	17,.CPCA0+17	;Save AC 17 of block 0
	MOVEI	17,.CPCA0	;Place to store rest of AC's
	BLT	17,.CPCA0+16	;Save the rest
	JRSTF	@[PC.UIO,,.+1]	;Make XCTFU work
	DATAO	PAG,[IG.LLH!1B2]  ;Make AC set 1 be the user set
	MOVEI	17,.CPCA1+00
	XCTFU	<BLT 17,.CPCA1+17>;Save AC block 1
	DATAO	PAG,[IG.LLH!2B2]  ;Make AC set 2 be the user set
	MOVEI	17,.CPCA1+20	
	XCTFU	<BLT 17,.CPCA1+37>;Save AC block 2
	DATAO	PAG,[IG.LLH!1B2]  ;Make AC set 1 be the user set
	MOVEI	17,.CPCA1+40
	XCTFU	<BLT 17,.CPCA1+57>;Save AC block 3
	MOVE	17,[IG.LLH+IG.LRH];Get Load Left and Load Right bits
	IORM	17,.CPCPG	;Set for restore
	MOVEI	17,.CPCA0	;Address of saved AC block
	MOVEM	17,.CPACA	;Set address of active AC set
>  ;End IFCPU (KI)

;Save important stuff where CRSHID can find it
	MOVE	17,CRSHWD
	MOVEM	17,SAV30	;Save contents of location 30
IFN SAXN,<
	MOVE	17,[SAXBAS,,SASAVE]
	BLT	17,SASAVE+37	;Save SA-10 area in 340-377
>  ;End IFN SAXN
	MOVE	17,[KEY620,,BASAVE]
	BLT	17,BASAVE+17	;Save IRING/ORING pointers in 170-207
	MOVE	17,.CPCA0+17	;Restore AC 17 of set 0
	DATAO	PAG,.CPCPG	;Restore current AC set
	JRSTF	@.CPSVA		;Return to caller
SUBTTL	RCDSTB and CPUSTS - Save CPU status

;ROUTINE TO RECORD THE CPU AND DEVICE STATUS BLOCKS.
;CALL:	PUSHJ	P,RCDSTB
;	RETURN

RCDSTB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
  ftdaem==0
IFN FTDAEM,<
	MOVEI	T1,.ERCSB	;CPU STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY FOR DAEMON
	MOVEI	T1,.ERDSB	;DEVICE STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY
>;END IFN FTDAEM
IFE FTDAEM,<DAEEST::>
	POPJ	P,		;RETURN

;SUBROUTINE TO STORE INFORMATION IN THE CPU STATUS BLOCK

CPUSTS::	;Taken from DEC's COMMON.702
IFNCPU(KI),<APRID .CPAPD	;(0) APRID >
IFCPU (KI),<CONI  PAG,T1	;(0) APR SERIAL NUMBER
	    LSH   T1,-^D26	;Only the serial number
	    MOVEM T1,.CPAPD  >
	CONI	APR,.CPACN	;(1) CONI APR,
	CONI	PI,.CPPIC	;(2) CONI PI,
	DATAI	PAG,.CPPGD	;(3) DATAI PAG,
	CONI	PAG,.CPPGC	;(4) CONI PAG,
IFCPU (KI),<HLRZ T1,.CPPGD	;Get UBR
	    HRRZ T2,.CPPGD	;Get EBR >
IFNCPU(KI),<HRRZ T1,.CPPGD	;Get UBR
	    HRRZ T2,.CPPGC	;Get EBR >
	MOVEM	T1,UPTSTX	;Store for FILDDT
	MOVEM	T2,EPTSTS	;           "
	ANDI	T1,17777	;Just the UBR
	LSH	T1,^D9		;Address of UPT
	CAML	T1,MEMSIZ	;Within physical memory?
	 TLO	T1,(1B0)	;No, flag it as being unreliable
	MOVEM	T1,.CPUPT	;Store physical address of UPT in the CDB
	MOVE	T1,[%UPT+424,,.CPUP0] ;(5) UPT LOCS 424-427
	SKIPL	.CPUPT		;Don't try to access funnyspace if bad UBR
	 BLT	T1,.CPUP0+3	;(5-10)
IFCPU(KL),<
	DTE0==200	;Data Ten/Eleven interface (DTE0=console front end)
	DTE1==204
	DTE2==210
	DTE3==214
	RH20==540	;RH20 Massbus controller - Disk and Tape on KL
	RH21==544	; (RP04/RP05/RP06 disks)
	RH22==550	; (DX20 with TU70/TU71/TU72 tape drives)
	RH23==554	; (DX20 with RP20 fixed disk)
	RH24==560
	RH25==564
	RH26==570
	RH27==574
	MTR== 024	;Meter
	TIM== 020	;Timer

	RDERA	.CPERA		;(11) RDERA
	CONI	RH20,.CPRHC+0	;(12) CONI RH20, FOR ALL 8 RH'S
	CONI	RH21,.CPRHC+1
	CONI	RH22,.CPRHC+2
	CONI	RH23,.CPRHC+3
	CONI	RH24,.CPRHC+4
	CONI	RH25,.CPRHC+5
	CONI	RH26,.CPRHC+6
	CONI	RH27,.CPRHC+7
	CONI	DTE0,.CPDTC+0	;(22) CONI DTEn
	CONI	DTE1,.CPDTC+1
	CONI	DTE2,.CPDTC+2
	CONI	DTE3,.CPDTC+3
	HRLZ	T1,.CPEPT	;(26) EPT LOCS 0-37 (RH20 LOGOUT AREAS)
	HRRI	T1,.CPEP0
	BLT	T1,.CPEP0+37	;(26-65)
	MOVE	T1,.CPEPT	;(66) EPT LOCS 140-177  (DTE CONTROL BLOCKS)
	HRLI	T1,140(T1)
	HRRI	T1,.CPEP1
	BLT	T1,.CPEP1+37	;(66-125)
>  ;END IFCPU(KL)
IFNCPU(KI),<
	MOVE	T1,[%UPT+500,,.CPUP1] ;(126) UPT LOCS 500-503  (PAGE FAIL)
	SKIPL	.CPUPT		;Don't try to access funnyspace if bad UBR
	 BLT	T1,.CPUP1+3
>  ;END IFNCPU(KI)
IFCPU(<KL,KS>),<;F3 does not have AC blocks 4-7
	EXECAC	(6)		;(132) AC BLOCK 6, REGS 0-3 AND 12
	MOVEM	0,.CP6
	MOVEM	1,.CP6+1
	MOVEM	2,.CP6+2
	MOVEM	3,.CP6+3
	MOVEM	12,.CP6+4
	EXECAC	(7)		;(136) AC BLOCK 7, REGS 0-2
	MOVEM	0,.CP7
	MOVEM	1,.CP7+1
	MOVEM	2,.CP7+2
	DATAO	PAG,.CPPGD	;RESTORE ORIGIONAL AC BLOCK
>;END IFCPU(KL,KS)
IFCPU(KL),<PUSHJ P,REDSBC>	;READ SBDIAG INFO
	MOVEI	T1,SR.CSB	;SET FLAG TO INDICATE CPU
	IORM	T1,.CPSBR	;STATUS BLOCK READ ON THIS CPU
	POPJ	P,
SUBTTL	S-BUS diagnostic routines
IFCPU(KL),<;ROUTINE TO CLEAR SBUS ERRORS IN EACH MEMORY CONTROLLER.  RETURNS
	   ;CPOPJ ALWAYS AND PRESERVES ALL AC'S.

CLRSBD::PUSHJ	P,SAVE3		;SAVE P1-P3
	MOVSI	P1,-.SBNMC	;MAKE AOBJN POINTER TO ALL MEM CONTROLLERS
	MOVSI	P2,SB.CLR	;BIT TO CLEAR ALL ERRORS
CLRSB1:	DPB	P1,[POINT 5,P2,4] ;STORE MEMORY CONTROLLER NUMBER
	SBDIAG	P2		;CLEAR THE ERROR BITS
	AOBJN	P1,CLRSB1	;LOOP FOR ALL CONTROLLERS
	POPJ	P,		;RETURN

;ROUTINES TO PERFORM SBDIAG FUNCTIONS 0 AND 1 FOR EACH MEMORY CONTROLLER.
;CALL REDSBD TO JUST READ THE DATA.  CALL REDSBC TO READ THE DATA AND
;CLEAR THE ERRORS.  THE FORMAT OF THE SBDIAG STATUS BLOCK IS AS FOLLOWS:
;	WORD 0: -NUMBER OF DATA BLOCKS,,OFFSET TO FIRST BLOCK
;EACH DATA BLOCK HAS THE FOLLOWING FORMAT:
;	WORD 0: -NUMBER OF WORDS FOLLOWING,,CONTROLLER NUMBER
;	WORD 1: SBDIAG FUNCTION 0 FROM-MEMORY WORD
;	WORD 2: SBDIAG FUNCTION 1 FROM-MEMORY WORD
;DESTROYS T1, PRESERVES ALL OTHERS

REDSBD::TDZA	T1,T1		;CLEAR T1 AND SKIP
REDSBC::MOVSI	T1,SB.CLR	;BIT TO CLEAR ERRORS
	JSP	T4,SAVE4	;SAVE P1-P4 ;*NOTE*: Not PUSHJ P,SAVE4 !
	SETZM	.CPSBD		;CLEAR FIRST WORD OF BLOCK FOR COUNT
	MOVSI	P1,-.SBNMC	;AOBJN POINTER TO MEMORY CONTROLLERS
	MOVEI	P2,.CPSBD+1	;START FIRST BLOCK HERE
	HRLI	P2,-.SBFNC	;-FUNCTIONS TO LH
REDSB1:	MOVEI	P3,0		;SET TO BUILD TO-MEMORY WORD
	DPB	P1,[POINT 5,P3,4] ;STORE MEMORY CONTROLLER
	SBDIAG	P3		;DO FUNCTION 0
	PUSH	P,P4		;SAVE FUNCTION 0 FROM-MEMORY WORD
	JUMPE	T1,REDSB2	;AVOID 2ND SBDIAG IF NOT CLEARING CONTROLLER
	IOR	P3,T1		;SET SB.CLR
	SBDIAG	P3		;DO FUNCTION 0 TO CLEAR CONTROLLER
REDSB2:	TRO	P3,1		;MAKE IT FUNCTION 1
	SBDIAG	P3		;DO FUNCTION 1
	POP	P,P3		;RESTORE FUNCTION 0 FROM-MEMORY WORD
	SKIPN	P3		;ANYTHING THERE?
	 JUMPE	P4,REDSB3	;NO, NO MEMORY CONTROLLER IF BOTH ZERO
	MOVEM	P3,1(P2)	;SAVE FUNCTION 0 WORD IN THE BLOCK
	MOVEM	P4,2(P2)	;  ALONG WITH FUNCTION 1 WORD
	HRRZM	P1,0(P2)	;SAVE CONTROLLER NUMBER AS WORD 0
	HLLM	P2,0(P2)	;MAKE IT -WORDS,,CONTROLLER
	AOS	.CPSBD		;COUNT THIS CONTROLLER
	ADDI	P2,.SBFNC+1	;INCREMENT TO NEXT BLOCK
REDSB3:	AOBJN	P1,REDSB1	;LOOP FOR NEXT CONTROLLER
	MOVN	P1,.CPSBD	;GET NUMBER OF BLOCKS WE STORED
	JUMPE	P1,CPOPJ	;LEAVE IT ZERO IF NONE
	HRLI	P1,1		;MAKE SWAPPED HEADER WORD
	MOVSM	P1,.CPSBD	;SAVE IN WORD 0
	POPJ	P,		;RETURN
>;END IFCPU (KL)
;SUBROUTINE TO READ AND STORE DEVICE STATUS

DVCSTS::POPJ P, ;*HACK*;	;Don't do CONI of all possible I/O devices
REPEAT 0,<;;Not needed yet for TYMCOM-X hardware
; 000=CPA   004=PI    010=PAG   014=CCA   020=TIM   024=MTR   030=ADC2  034=
; 040=      044=      050=      054=      060=DLB1  064=DLC2  070=CLK1  074=CLK2
; 100=PTP   104=PTR   110=CDP   114=CDR   120=TTY   124=LPT1  130=DIS1  134=DIS2
; 140=PLT1  144=PLT2  150=CR1   154=CR2   160=DLB2  164=DLC2  170=DSK1  174=DSK2
; 200=DTE0  204=DTE1  210=DTE2  214=DTE3  220=DX10  224=      230=LPT3  234=LPT2
; 240=DLS1  244=DLS2  250=DPC1  254=DPC2  260=DPC3  264=DPC4  270=FSD1  274=FSD2
; 300=DCSA  304=DCSB  310=      314=      320=DTC1  324=DTS1  330=DTC2  334=DTS2
; 340=TMC1  344=TMS1  350=TMC2  354=TMS2  360=FSD3  364=      370=      374=
; 400=      404=      410=      414=      420=      424=      430=      434=
; 440=      444=      450=      454=      460=DSS1  464=DSI1  470=DSS2  474=DSI2
; 500=      504=      510=      514=      520=      524=      530=      534=
; 540=RH20  544=RH21  550=RH22  554=RH23  560=RH24  564=RH25  570=RH26  574=RH27
; 600=      604=      610=      614=      620=      624=      630=      634=
; 640=      644=      650=      654=      660=      664=      670=      674=
; 700=      704=      710=      714=      720=      724=      730=      734=
; 740=user  744=user  750=user  754=user  760=user  764=user  770=user  774=user

;Device codes, in alphabetical order
	CCI== 014	;Computer-Computer Interface (KI to PDP-8 on DA-10)
	CLK1==070	;Real-time clock
	CLK2==074
	CDP== 110	;Card punch
	CDR== 114	;Card reader
	CDR1==150	;Buffered card reader
	CDR2==154
	DAC== 320	;DECtape controller (TD10+TU55)
	DAS== 324
	DBC== 330	;DTB:
	DBS== 334
	DLB1==060	;Old PDP-11 interface
	DLB2==160
	DLC1==064
	DLC2==164
	DLS1==240	;Data line scanner
	DLS2==244
	DPC1==250	;Disk pack control (RD10 with RP02 or RP03)
	DPC2==254
	DPC3==260
	DPC4==264
	DX10==220	;Old TU-70 tape controller
	FHD1==170	;Fixed Head Disk controller (RD10)
	FHD2==174
	FSD1==270	;?
	FSD2==274
	FSD3==360
	LPT1==124	;Lineprinter
	LPT2==234
	LPT3==230
	PLT1==140	;Plotter
	PLT2==144
	PTP== 100	;Paper tape reader/punch
	PTR== 104
	TMC1==340	;Magtape controller
	TMS1==344
	TMC2==350
	TMS2==354
	TTY== 120	;Console TTY (KI only)

DVCSTS::
IFCPU (KI),<CONI TTY,.CPTTY	;Console CTY
	    CONI CCI,.CPCCI >       ;DA-CONI 014, sweeps cache on KL)
IFCPU (<KI,KL>),< ;Read status of devices on the I/O bus
	CONI	PTR,.CPPRA
	CONI	PTP,.CPPPA
	CONI	DLS1,.CPDLS
;	CONI	DLS2,.CP---
	CONI	DAC,.CPDAC
	CONI	DAS,.CPDAS
	CONI	TMS1,.CPTMS
	CONI	TMC1,.CPTMC
;	CONI	TMS2,.CP---
;	CONI	TMC2,.CP---
	CONI	DX10,.CPDX1
	CONI	FHD1,.CPDSK
	CONI	FHD2,.CPFH2
	CONI	FSD1,.CPFSD
	CONI	FSD2,.CPFS2
	CONI	FSD3,.CPFS3
	CONI	DPC1,.CPDPC
	CONI	DPC2,.CPDP2
	CONI	DPC3,.CPDP3
	CONI	DPC4,.CPDP4
	CONI	DBS,.CP2DS
	CONI	DBC,.CP2DC
	CONI	DLC1,.CPDLC
	CONI	DLB1,.CPDLB
	CONI	DLC2,.CPDC2
	CONI	DLB2,.CPDB2
	CONI	CDP,.CPCDP
;	CONI	CDR,.CP---
	CONI	CDR1,.CPCRA
	CONI	CDR2,.CPCRB
	CONI	LPT1,.CPLPT
	CONI	LPT2,.CPLPB
	CONI	LPT3,.CPLPC
	CONI	PLT1,.CPPLA
	CONI	PLT2,.CPPLB
IFCPU (KI),<DATAI APR,.CPDST >		;CONSOLE SWITCHES
IFCPU (KL),<DATAI APR,.CPDAK >		;ADDRESS BREAK CONDITIONS
	DATAI	DSK1,.CPDDK
	DATAI	FHD2,.CPDH2
	DATAI	FSD1,.CPDFS
	DATAI	FSD2,.CPDS2
	DATAI	FSD3,.CPDS3
	DATAI	DPC1,.CPDDP
	DATAI	DPC2,.CPDD2
	DATAI	DPC3,.CPDD3
	DATAI	DPC4,.CPDD4
	DATAI	DLC1,.CPDDC
	DATAI	DLB1,.CPDDB
	DATAI	DLC2,.CPD2C
	DATAI	DLB2,.CPD2B
>;END IFCPU (<KI,KL>)
IFCPU (KL),<
	CONI	TIM,.CPTMR	;KL interval timer status
	CONI	MTR,.CPMTR	;KL meter status
	DATAO	RH20,RH2IVI
	DATAI	RH20,.CPIVI+1
	DATAO	RH21,RH2IVI
	DATAI	RH21,.CPIVI+3
	DATAO	RH22,RH2IVI
	DATAI	RH22,.CPIVI+5
	DATAO	RH23,RH2IVI
	DATAI	RH23,.CPIVI+7
	DATAO	RH24,RH2IVI
	DATAI	RH24,.CPIVI+11
	DATAO	RH25,RH2IVI
	DATAI	RH25,.CPIVI+13
	DATAO	RH23,RH2IVI
	DATAI	RH26,.CPIVI+15
	DATAO	RH27,RH2IVI
	DATAI	RH27,.CPIVI+17
>;END IFCPU (KL)
IFCPU (KS),<
	RDINT	.CPTMR		;READ INTERVAL TIMER
	RDTIME	.CPTMB		;READ TIME BASE
	PUSH	P,%UPT+.LMPFP
	PUSH	P,%UPT+.LMPFW
	MOVE	T1,[-KSCTBL,,KSCTAB] ;POINTER TO DEVICE ADDRESS TABLE
	MOVE	T2,[EXP XC.UIO+KSCTRP] ;TRAP ADDRESS FOR NX DEVICES
	EXCH	T2,%UPT+.LMPFN	;SET IT AND SAVE CURRENT ONE
	MOVEI	T3,.CPUB1	;FIRST STORE ADDRESS IN CDB SUB-TABLE
KSCLOP:	RDIO	T4,@(T1)	;READ SOME REGISTER
	MOVEM	T4,(T3)		;SAVE IT IN RIGHT SLOT
KSCTRP:	AOS	T3		;BUMP CDB ADDRESS
	AOBJN	T1,KSCLOP	;DO NEXT
	EXCH	T2,%UPT+.LMPFN	;RESTORE TRAP ADDRESS
	JRST	KSCEND		;DONE

KSCTAB==.			;START OF KS10 DEVICE ADDRESS TABLE
UB1STS:	XWD	1,UNBSTW	;UBA1 STATUS REGISTER
UB3STS:	XWD	3,UNBSTW	;UBA3 STATUS REGISTER
RH1STS:	RH11CA			;RPCS1
RH1ST2:	RH11CA+10		;RPCS2
RH2STS:	RH21CA			;MTCS1
RH2ST2:	RH21CA+10		;MTCS2
LPTSTS:	LP11CA			;LPT CSRA
LPTST2:	LP11CA+2		;LPT CSRB
CDRSTS:	CD11BA			;CDR CDST
KSCEND==.			;END OF KS10 DEVICE ADDRESS TABLE
KSCTBL==KSCEND-KSCTAB	;LENGTH OF KS10 DEVICE ADDRESS TABLE
	POP	P,%UPT+.LMPFW
	POP	P,%UPT+.LMPFP
>;END IFCPU (KS)
LENDVS==:<.-DVCSTS-1>B26
	MOVEI	T1,SR.DSB		;SET FLAG TO INDICATE
	IORM	T1,.CPSBR		;DEVICE STATUS BLOCK READ
	POPJ	P,
IFCPU (KL),< RH2IVI:	740000,,0 >
>  ;End of REPEAT 0
SUBTTL	TYPCSB - Routine to type relevant parts of the CPU status block

TYPCSB::PUSHJ	P,INLMES##
	ASCIZ/
CPU Status Block
/
	PUSHJ	P,INLMES##
	ASCIZ/
APRID = /
	MOVE	T1,.CPAPD	;GET APRID
	PUSHJ	P,HWDPNT##	;TYPE IT
IFCPU (KL),<
	PUSHJ	P,INLMES##
	ASCIZ/
ERA = /
	SKIPN	T1,.CPAER
	 MOVE	T1,.CPERA	;GET ERA
	PUSHJ	P,HWDPNT##	;TYPE IT
>  ;END IFCPU (KL)
	PUSHJ	P,INLMES##
	ASCIZ/
CONI APR, = /
	MOVE	T1,.CPACN	;GET CONI APR
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PI, = /
	SKIPN	T1,.CPCPI
	 MOVE	T1,.CPPIC	;GET CONI PI
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PAG, = /
	MOVE 	T1,.CPPGC	;GET CONI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
DATAI PAG, = /
	MOVE	T1,.CPPGD	;GET DATAI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
IFNCPU(KL),<PUSHJ P,CRLF##>	;Force blank line after CPU status block
IFCPU (KL),<
	PUSHJ	P,INLMES##
	ASCIZ/
AR ARX Data Word = /
	MOVE	T1,.CP7		;GET AC BLOCK 7 LOC 0
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
IO Page Fail Word = /
	MOVE 	T1,.CP7+2	;GET AC BLOCK 7 LOC 2
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/

SBUS Diags:

CNTRLR FNC 0          FNC 1
/
	PUSHJ	P,TYPSBD	;TYPE SBDIAG INFORMATION
>  ;END IFCPU(KL)
	PJRST	CRLF##		;END WITH CRLF AND RETURN
;Routine to type the SBDIAG functions and values on CTY during crash

IFCPU(KL),<
TYPSBD::PUSH	P,P1		;SAVE P1
	PUSH	P,P2		;  AND P2
	MOVE	P1,.CPSBD	;GET -# BLOCKS,, OFFSET TO FIRST
	HRRZI	P2,.CPSBD(P1)	;POINT AT FIRST BLOCK
TYPSB1:	HLL	P2,0(P2)	;MAKE P2 BE AOBJN POINTER TO THIS BLOCK
	HRRZ	T1,0(P2)	;GET CONTROLLER LOGICAL ADDRESS
	PUSHJ	P,OCTPNT##	;PRINT IT
	HRRI	P2,1(P2)	;ADVANCE TO FIRST OF FUNCTION WORDS
TYPSB2:	PUSHJ	P,PRSPC##	;SEPARATE FIELDS WITH A SPACE
	MOVE	T1,0(P2)	;GET NEXT FUNCTION WORD
	PUSHJ	P,HWDPNT##	;TYPE IT
	AOBJN	P2,TYPSB2	;LOOP FOR ALL WORDS IN THIS BLOCK
	PUSHJ	P,CRLF##	;TYPE CRLF AT END OF LINE
	AOBJN	P1,TYPSB1	;LOOP FOR ALL BLOCKS
	POP	P,P2		;RESTORE P2
	POP	P,P1		;  AND P1
	POPJ	P,		;RETURN
>  ;END IFCPU(KL)
SUBTTL	CRSDB - crash data block definitions

  ;Per CPU data (This table needs to be rearranged in the right order)

.CPSLF:: .		;Pointer to start of CDB for this CPU
.CPDWD:: -1		;DIE word, checks for recursion in stopcode handler
.CPCPC:: 0		;Continue PC, defaults to location after STOPCD macro
.CPCPI:: 0		;Saves CONI PI, during STOPCD
.CPCPG:: 0		;Pager status (including AC set in use) at STOPCD
.CPSCB:: 0		;STOPCD block address
.CPSNM:: 0		;STOPCD name
.CPSPC:: 0		;STOPCD EXEC PC
.CPSTY:: 0		;STOPCD type
.CPSDT:: 0		;STOPCD date/time
.CPSJN:: 0		;STOPCD job number
.CPSPN:: 0		;STOPCD program name
.CPSPD:: 0		;STOPCD program directory
.CPSPP:: 0		;STOPCD PPN
.CPSTN:: 0		;STOPCD TTY name
.CPSUU:: 0		;STOPCD UUO
.CPSUP:: 0		;STOPCD user PC
.CPSND:: 0		;STOPCD number of DEBUG stopcodes
.CPSNJ:: 0		;STOPCD number of JOB stopcodes
.CPSNC:: 0		;STOPCD number of CPU stopcodes
.CPSNI:: 0		;STOPCD number of INFO/EVENT stopcodes

.GTCRS:: ;Crash data block (The numbers in parens are defined for TOPS-10)
.CPAPD:: 0		;(0) APRID
.CPACN:: 0		;(1) CONI APR,
.CPPIC:: 0		;(2) CONI PI,
.CPPGD:: 0		;(3) DATAI PAG,
.CPPGC:: 0		;(4) CONI PAG,
.CPUP0:: BLOCK 4	;(5-10) UPT LOCS 424-427 (MUUO AREA)
  ;11-125 meaningful on KL only
.CPERA:: 0		;(11) RDERA
.CPRHC:: BLOCK 8	;(12-21) CONI RH20, FOR ALL 8 RH'S
.CPDTC:: BLOCK 4	;(22-25) CONI DTEn
.CPEP0:: BLOCK 40	;(26-65) EPT LOCS 0-37 (RH20 LOGOUT AREAS)
.CPEP1:: BLOCK 40	;(66-125) EPT LOCS 140-177  (DTE CONTROL BLOCKS)
  ;125-141 not on KI
.CPUP1:: BLOCK 4	;(126-131) UPT LOCS 500-503  (PAGE FAIL AREA)
.CP6::   BLOCK 5	;(132-135) AC BLOCK 6, REGS 0-3 AND 12
.CP7::   BLOCK 3	;(136-141) AC BLOCK 7, REGS 0-2
  ;142-211 on KL only
.CPSBD:: BLOCK 50	;(142-211) SBDIAG DATA
.CPSBR:: 0		;Status, SR.CSB set if 0-136 have saved data


.CPUPT:: UPT		;Physical address of the UPT, negative if invalid
.CPEPT:: EPT		;Physical address of the EPT for this CPU
.CPCPN:: 1		;Number of this CPU
.CPJOB:: 0		;Number of job running on this CPU
.CPISF:: 0		;In Scheduler-context Flag
.CPCTN:: '0'-'0'	;CTY: is line 0, TTY0:=CTYLDB
.CPTOA==:COMTOA##	;Address of routine to output to the CTY
.CPEPD:: IOWD 60,.CPPDL	;To reset the stack
.CPPDL:: BLOCK 60	;Stack for error processing
.CPDDT:: JFCL		;Instruction to enter DDT on this CPU
.CPLOG:: APRNAM		;Logical name (AA, BB, CC, etc)
.CPCPU:: APRSN		;CPU type in LH,,Serial number system was built for
			;ONCE does sets SERIAL to APRID but leaves .CPCPU alone
.CPSNO:: SYSNO		;System number from CONFIG.MAC
.CPSVA:: 0		;Do JSR .CPSVA to save all AC blocks
	 JRST SVSETS	;Jump to routine to save ACs
.CPACA:: 0		;Address of active ACs

;End of DEC's crash data block
;-------------------------------------------------------------------------------
;Start of TYMSHARE's crash data block

IFCPU (KL),<
.CPPER:  0		;(-6) Results of CONI APR, on PARITY/NXM interrupt
.CPSB0:  4B4+0		;(-5) SBUS DIAG, controller 4 (DMA20), function 0
.CPS0A:  0		;(-4) result stored here
.CPSB1:  4B4+1		;(-3) SBUS DIAG, controller 4 (DMA20), function 1
.CPS1A:  0		;(-2) result stored here
.CPAER:  0		;(-1) Results of RDERA on PARITY/NXM interrupt
	SAVERA==:.CPAER		;RDERA SAVERA done in PICON
	SAVAPR=:.CPPER		;CONI APR,SAVAPR done in PICON
	SAVSB0=:.CPSB0		;SBDIAG SAVSB0 done in PICON
	SAVSB1=:.CPSB1		;SBDIAG SAVSB1 done in PICON
	ERASTS=:.CPAER		;Label for CRASHX
	SBDST1=:.CPSB0		;Label for CRASHX
	SBDST2=:.CPSB1		;Label for CRASHX
>; IFCPU KL

IFCPU (KS),<
KAFPC::	0		;(-25) 4 word block for XPCW if keep alive fails
	0		;(-24)
	0		;(-23)
	KAFCRS		;(-22)
HLTSTS::0		;(-21) MAG register
	0		;(-20) PC register
	0		;(-17) HR register
	0		;(-16) AR register
	0		;(-15) ARX register
	0		;(-14) BR register
	0		;(-13) BRX register
	0		;(-12) ONE (1) register
	0		;(-11) EBR register
	0		;(-10) UBR register
	0		;(-7) MASK register
	0		;(-6) FLG (flags,page fail code) register
	0		;(-5) PI register
	0		;(-4) XWD1 (1,,1) register
	0		;(-3) T0 register
	0		;(-2) T1 register
	0		;(-1) VMA (with flags)
>; IFCPU KS

CRSDB::	; * * * CRASH DATA BLOCK * * *
	; + index are processor independent
	; - index are processor dependent
	; CRSDB is pointed to by lh(CONFIG-2) so CRSHID can find it
;symbol			index  instruction          cpus
;------			-----  ----------- 	    ----
PISTS::	0		;(0)  CONI  PI,  (RDPI)	    ILS3
APRSTS::0		;(1)  CONI  APR, (RDAPR)    ILS3
PAGDTI::0		;(2)  DATAI PAG, (RDUBR)    ILS3
PAGCNI::0		;(3)  CONI  PAG, (RDEBR)    ILS3
AIDSTS::0		;(4)  BLKI  APR, (APRID)    .LS.
APRDTI::0		;(5)  DATAI APR, (RSW)	    IL.3 (KL address break)
	0		;(6)
	0		;(7)
	0		;(10)
	0		;(11)
	0		;(12)
	0		;(13)
	EPT,,CRSHAC	;(14) address of some useful stuff
SAV30::	0		;(15) value of 30 saved here
STOPCN::0		;(16) count of times we tried to crash
STOPPC::0		;(17) real PC of first STOPCD we hit
CRSLEN==.-CRSDB
CRSMXL==:<CRSLEN-1>_^D9

  ;These variables should be moved somewhere else
BADINT::0		;bad interrupts weve gotten
BADQUE::0		;attempts to assign a job not in NUL queue
BADQTM::0		;time last job assignment was made
SUBTTL	JSR SYSCRS and JRST CRASHX routines

SLOCRS::0	;Nonzero for slow DSKCLN, set by STOPCD(.,DSKCLN) or STOPCD(SLO)
NOCRS:: 0	;Nonzero for no dump + manual DSKCLN, PC of STOPCD(NO) in RH

KAFCRS::MOVEM	P,KAFPDL	;Save possible stack pointer
	MOVEI	P,KAFPDL	;Point to 1-word stack
S..KAF:: STOPCD (.,CPU,KAF,,<Keep Alive Failure>)
KAFPDL:	BLOCK	2		;Old P at KAFPDL+0, PUSHJ stores PC at KAFPDL+2

TAKDWN:: 0			;JSR here from CLOCK1 on an orderly shutdown
	SOS	P,TAKDWN	;TAKDWN nonzero if HANGIT ran
	MOVEM	P,STOPPC
	JRST	CRASHX

CRS147:: 0			;JSR here from a 147 restart
	SOS	P,CRS147
	MOVEM	P,STOPPC
	JRST	CRASHX

CRASH2:: 0			;JSR here from PICON when DEPOSIT 1 IN 30
	SOS	P,CRASH2
	MOVEM	P,STOPPC
	PFALL	CRASHX

CRASHX::AOS	STOPCN		;Count number of times thru here
	MOVE	P,CRSHWD	;Save what was in 30 before base zaps it
	MOVEM	P,SAV30
IFN SAXN,<MOVE	P,[SAXBAS,,SASAVE]
	  BLT	P,SASAVE+37	;Save SA-10 area in 340-377  >  ;End IFN SAXN
	MOVE	P,[KEY620,,BASAVE]
	BLT	P,BASAVE+17	;Save IRING/ORING pointers in 170-207
	JRST	CRASHZ

REBOOT::	;Enter here from DIE, the STOPCD processor
;Start of CRSHID kludge
	MOVE	P,.CPCPI	;Get CONI PI that DIE saved
	MOVEM	P,PISTS		;(0) for CRSHID
	MOVE	P,.CPACN	;Get CONI APR from RCDSTB
	MOVEM	P,APRSTS	;(1) for CRSHID
	MOVE	P,.CPPGD	;Get DATAI PAG from RCDSTB
	MOVEM	P,PAGDTI	;(2) for CRSHID
	MOVE	P,.CPPGC	;Get CONI PAG from RCDSTB
	MOVEM	P,PAGCNI	;(3) for CRSHID
	MOVE	P,.CPAPD	;Get APRID from RCDSTB
	MOVEM	P,AIDSTS	;(4) for CRSHID
IFNCPU(KS),<DATAI APR,APRDTI>	;(5) Console switches or KL address break
	AOS	STOPCN		;(16) Tell CRSHID that CRSDB is valid
	MOVE	P,.CPSPC	;Get the STOP-PC saved by DIE
	MOVEM	P,STOPPC	;(17) for CRSHID (15=SAV30)
;End of CRSHID kludge

CRASHZ:	MOVE	P,.CPEPD	;Set up stack
	JSR	CRSDEV		;Read device status (again)
	JSR	CRSMAP		;Remap context pages into exec memory
	JRST	LODBTS		;Load boots
SUBTTL	CRSDEV - Read status of all devices at time of crash

CRSDEV:	0			;JSR here from CRASHX
IFCPU(F3),<
	TNCONO	0		;RESET INTERFACE TO NODE
>;END IFCPU(F3)
	CONI	PAG,PAGCNI	;RDEBR for all but KI
	DATAI	PAG,PAGDTI	;RDUBR for all but KI
IFNCPU(KI),<WRUBR [LG.LAB+0B8+0B11]> ;SWITCH TO BLOCK 0

IFCPU(KL),<
	SWPUA			;Sweep cache, unload all words to memory
        CONSO   APR,LP.CSD      ;Wait for sweep done
         JRST   .-1
> ;END IFCPU(KL)

DEFINE LPTMC (A)<
LPT'A'STS::CONI LP'A,.
> ; End Define LPTMC

DEFINE FHXMC (A)<
FH'A'STS::CONI FHD'A,.
FH'A'DTI::DATAI FHD'A,.
> ; End Define FHXMC

DEFINE DPXMC (A)<
DP'A'STS::CONI DPC'A',.
DP'A'DTI::DATAI DPC'A,.
> ; End Define DPXMC

DEFINE SAXMC (A)<
SA'A'STS::CONI SAX'A,.
> ; End Define SAXMC

%LPTNN==0

IFNCPU(KS),<DATAI APR,APRDTI>
IFCPU (<KI,F3>),<	;KI 10 AND FOONLY DEVICES
TTYSTS:	CONI TTY,.
> ; End IFCPU(<KI,F3>)
IFCPU (KI),<		;KI10 DEVICES
IFN PTRN,<PTRSTS::CONI PTR,.>
IFN PTPN,<PTPSTS::CONI PTP,.>
CLKCNI::CONI CLK,.
>;END IFCPU (KI)

IFCPU (KL),<		;KL ONLY DEVICES
	APRID	AIDSTS
	SKIPN	ERASTS		;Don't wipe out value saved by PICON:APRINT
	 RDERA	ERASTS
	SKIPN	SBDST1+1
	 SBDIAG	SBDST1
	SKIPN	SBDST2+1
	 SBDIAG	SBDST2
TIMSTS::CONI TIM,.
MTRSTS::CONI MTR,.
>;END IFCPU (KL)

IFCPU (KS),<		; KS DEVICES ONLY
	APRID	AIDSTS
TIMSTS:	RDINT	.
KMCSTP: SETZ T1,
	WRIO T1,@[3,,760540]		;STOP THE KMC
IFG MAGUN,<
MAGSTS:	JSP T1,[RDIO T2,@[3,,772440]
		MOVEM T2,-1(T1)
		JRST (T1)]
> ; End IFG MAGUN
IFG LPTN,<
LPRSTS:	SKIPG	NXDLPT
	  JRST	DSKSTS
	JSP T1,[RDIO T2,@[3,,775400]
		MOVEM T2,-1(T1)
		JRST (T1)]
> ; End IFG LPTN
DSKSTS:	JSP T1,[RDIO T2,@[1,,776700]
		MOVEM T2,-1(T1)
		JRST (T1)]
> ; END IFCPU (KS)
IFCPU (<KI,KL>),<	;KI/KL DEVICES ONLY
    IFN CDRN!CR10N,<
CRSTS::	CONI CR,.
    > ; End IFN CDRN!CR10N
    IFN PLTN,<
PLTSTS::CONI PLT,.
    > ; End IFN PLTN
    REPEAT LPTN,<
	LPTMC (\%LPTNN)
	%LPTNN==%LPTNN+1
    > ; End REPEAT LPTN
	%RD10N==1
    REPEAT RD10N,<
	FHXMC(\%RD10N)
	%RD10N==%RD10N+1
    > ; End REPEAT RD10N
	%RP10N==1
    REPEAT RP10N,<
	DPXMC(\%RP10N)
	%RP10N==%RP10N+1
    > ; End REPEAT RP10N
	%SAXN==0
    REPEAT SAXN,<
	SAXMC(\%SAXN)
	%SAXN==%SAXN+1
    > ; End REPEAT SAXN
> ; END IFCPU (<KI,KL>)

	JRST	@CRSDEV		;End of CRSDEV routine


SUBTTL	End of STOPCD data (see DIE:: in ERRCON)
;-------------------------------------------------------------------------------
SUBTTL	CRSMAP - Map context pages into just before physcial page 337

CRSMAP:	0			;JSR here from CRASHX
	SKIPN	JOB		;
	 JSR	GOBOOT		;NULL JOB RUNNING
	MAP	T1,%UPT		;PREVENT PG FAULTS HERE
	MOVEM	T1,CRSBLK	;SAVE IN CASE WE JSR GOBOOT
IFCPU (KI),<
	TRNE	T1,MAP.M	;ONLY SAVE IF PAGED ACCESSIBLE REFERENCE (DON'T NEED TO WRITE)
	 JSR	GOBOOT		;NO GOOD.
> ; End IFCPU (KI)
IFNCPU(KI),<
	TLNE	T1,PFW.H	;IF HARD FAILURE, FORGET IT
	 JSR	GOBOOT
	TLNE	T1,PFW.R	;SKIP IF UNPAGED REF - THATS NO GOOD.
	TLNN	T1,PFW.A	;IF A BIT IS ON, ITS OK, ELSE NOT
	 JSR	GOBOOT		;YES, CANT ADDRESS UPT
>;END IFNCPU(KI)
SUPT0:
	MOVEI	P,CRSBLK-1
IFCPU (KI),<
	MOVE	T1,PAGDTI	;GET DATAI PAG WORD FROM ABOVE
	TDO	T1,[400000,,400000] ;SET LOAD LEFT AND RIGHT
	EXCH	T1,CURUPT	;PUT IN CURUPT SO CLRPTA WILL WORK
	MOVEM	T1,SAVCUP	;SAVE THIS SO WE CAN RESTORE LATER
>;END IFCPU (KI)
	%CTXPG==%UPT.N
REPEAT NCTXPG,<
	LDB	T1,[UPXPTR (%CTXPG,%UPT)]
	ANDI	T1,17777		;JUST PAGE NUMBER
	HRLZS	T1
	PUSH	P,T1
	%CTXPG==%CTXPG+1
> ; End REPEAT NCTXPG


;; NOW CRSBLK/ 	CTX[0](=PHYS PG NO FOR CTX PG 0),,0
;;		CTX[1]..,,0
;;..ETC..
;;  P		CTX[N]..,,0
;;
;;  NOW MAKE LIST OF STATUS OF PHYSICAL PGS 337-NCTXPG TO 337
;;  IN RH OF PDL, SETTING 400000 FOR ANY PHYSICAL PG WHICH IS OCCUPIED
;;  BY ONE OF THE CONTEXT PGS.

	MOVSI	T4,-NCTXPG
A0:	MOVSI	T3,-NCTXPG
A1:	HLRZ	T1,CRSBLK(T3)
	MOVEI	T2,337-NCTXPG+1(T4)	;T2/PHYS PG NO NOW CHECKING
	CAIN	T1,(T2)			;THIS PHYS PG OCCUPED BY CTX PG?
	  TRO	T2,400000		;YES,FLAG
	IORM	T2,CRSBLK(T4)		;THIS ENTRY/XX,,PHYS PG NO.+FLAG
	AOBJN	T3,A1			;NEXT CTX PG, SEE IF MATCHES
	AOBJN	T4,A0			;NEXT PHYS PG


;;  NOW FOR EACH CONTEXT PG, IF CTX[I] .GE. 770, SEARCH FOR A PHYSICAL
;;  PG IN THE TABLE MARKED "NOT OCCUPIED" AND BLT THIS
;;  CTX PG INTO IT AND MARK IT OCCUPIED. CHANGE THE MAP TO POINT
;;  AT THE NEW PHYS PGS OCCUPIED, PUSHING OVERWRITTEN DATA INTO
;;  CRSBLK IN CASE SOMEBODY WANTS TO LOOK AT IT WITH FILDDT.
;;  THE TABLE NOW LOOKS LIKE THIS:
;;
;;  CRSBLK/	CTX[0],, "33X"+400000 IF OCCUPIED
;;		CTX[1],,"33X+1" +FLAG
;;..ETC..
;;  P/		CTX[N],,337+FLAG

	HLRZ	T1,CRSBLK		;T1/PHYS PG NO OF UPT
	TRO	T1,PGE.A!PGE.W
	DPB	T1,[EPTPGP(%UPS.N)]	;ALL FIXUPS OF MAP SLOTS
	CLRPTA				;PUT MAPPING INTO EFFECT.
	MOVSI	T4,-NCTXPG
B0:	HLRZ	T1,CRSBLK(T4)		;T1/CTX[I]=PHYS PG FOR I'TH CTX PG
	MOVE	T3,HGHBLK		;FROM HGHBLK-2 TO HGHBLK WILL BE
	CAIGE	T1,-2(T3)		;OCCUPIED BY BOOTS. IT THIS CTX
					;PAGE AT OR ABOVE THERE? BOOTS
					;DOESNT SAVE ANYTHING PAST ITS
					;OWN STARTING POINT.
	  JRST	B4			;THIS PG DOESNT NEED MOVING
	MOVSI	T3,-NCTXPG
B2:	HRRZ	T1,CRSBLK(T3)		;PG NO+FLAG, J'TH PHYS PG
	TRZE	T1,400000
	  JRST	B3			;OCCUPADO
	TRO	T1,PGE.A!PGE.W
	DPB	T1,[EPTPGP(<%ERR_-9>)]	;ADDRESS THIS PHYS PG THRU %ERR
	CLRPTA				;PUT MAPPING INTO EFFECT
	MOVEI	T2,%UPT.N(T4)		;T2/VIRT PG NO. THIS CTX PG
	HRLZ	PG,T2
	LSH	PG,^D9			;PG/VIRT ADDR THIS CTX PG,,0
	HRRI	PG,%ERR			;PG/FROM CTX PG,,TO %ERR
	BLT	PG,%ERR+777		;BLT UNTIL END OF PAGE IN %ERR
	CAIE	T2,%UPT.N		;SPECIAL IF MOVING UPT
	  JRST	B2B
	PUSH	P,PAGDTI		;SAVE FROM OVERWRITE
IFCPU (KI),<
	DPB	T1,[POINT 13,PAGDTI,17]	;NOTE NEW UPT LOCATION. T1/PHYS PG
	DPB	T1,[EPTPGP(%UPS.N)]	;T1/PGE.A!PGE.W+PHYS PG
	MOVE	PG,PAGDTI
	TDO	PG,[XWD 400000,400000]
	DATAO	PAG,PG
>;END IFCPU (KI)
IFNCPU(KI),<
	DPB	T1,[POINT 13,PAGDTI,35]
	DPB	T1,[EPTPGP(%UPS.N)]	;MAKE UPT ADDRESSABLE THRU %UPS.
PRINTF(<[MOVE PG,PAGDTI at B2B-3 destroys valuable data]>)
	MOVE	PG,PAGDTI		;PUT IN PAGDTI FOR FILDDT SAKE
	TLZ	PG,(LG.LAB)		;DON'T LOAD AC BLOCKS
	WRUBR	PG
>;END IFNCPU(KI)
B2B:	MOVEI	PG,-340(T2)
	LSH	PG,-1			;INDEX FOR THIS PG=(PG-340)/2
	PUSH	P,%UPS+UPTEP0(PG)	;SAVE BEFORE OVERWRITING
	TRNN	T2,1			;SKIP IF ODD PG
	 SKIPA	U,[POINT 18,%UPS+UPTEP0(PG),17]
	 MOVE	U,[POINT 18,%UPS+UPTEP0(PG),35]
	DPB	T1,U			;T1/BITS+NEW PHYS PG NO THIS CTX PG
	MOVEI	T1,400000
	IORM	T1,CRSBLK(T3)		;MARK THIS PHYS PG OCCUPIED
	JRST	B4			;NEXT CTX PG


;TRY NEXT PHYS PG, THIS ONE OCCUPIED
B3:	AOBJN	T3,B2			;SHOULD JUMP
	JRST	B5			;ALL OCCUPIED, QUIT.

B4:	AOBJN	T4,B0			;SEE IF NEXT CTX PG NEEDS HELP
B5:					;FELL THRU, ALL CTX PGS DONE
IFCPU (KI),<
	MOVE	T1,SAVCUP		;GET OLD CURUPT BACK
	MOVEM	T1,CURUPT		;FOR LOOKING AT IN DUMP.
>;END IFCPU (KI)
	JRST	@CRSMAP			;End of CRSMAP routine
SUBTTL	GOBOOT and LODBTS - Load BOOTS from disk

GOBOOT:	EXP 	0			;JSR here if CRSMAP has troubles
LODBTS::				;Global so anyone can LODBTS$G in DDT
	WRAPR	APRIOB			;Reset system
	JRSTF	@[PC.UIO,,.+1]		;Set user I-O in PC flags
IFNCPU(KS),<WRADB [0]>			;Clear address break
IFCPU (KI),<				;AC block 0 always selected on KI
	DATAO	PAG,[XWD 400000,400000]	;Turn off paging
>;END IFCPU (KI)
IFCPU (KL),<
	CONO	MTR,0			;Turn off interval timer and meter
	SWPUA				;Sweep cache, unload all to memory
	CONSZ	APR,LP.CSB		;Wait for Cache Sweep Busy to clear
	 JRST	.-1			;(do this before the WREBR)
>;END IFCPU (KL)
IFCPU(<KL,KS,F3>),<
	WRUBR	[LG.LAB+0B8+0B11]	;AC block 0 (in case of LODBTS$G)
	WREBR	EPT.PN			;Turn off paging (turn off KL cache)
>;END IFNCPU(KI)
IFCPU (KS),<
	WRAPR	LP.DSF+LP.CSF+LP.TIM	;Disable interval timer interrupt
	MOVSI	T1,(KPACT)		;Clear keep alive active
	ANDCAM	T1,RLWORD
>;END IFCPU (KS)
SYSTOP:	MOVEI	P,SYSPDL		;SETUP P TO SPARE AREA
;*;	PUSHJ	P,FILSTP##		;In FILUUO, currently just a POPJ
	SETZ	T2,			;CLEAR HANG FLAGS

;;*;; No longer allow base to dump into PDP-10 memory!!! /CARL ;;*;;
;;
;; IFNCPU(F3),< BTMOUT==^D30 ;Wait 30 seconds for base to dump into PDP10 memory
;;	MOVEI	17,FILUUO##		;NOW TELL 620 TO DUMP INTO FILSER
;;	LSH	17,4			;AS A 620 STYLE ADDRESS
;;	MOVEM	17,DMP620
;;	MOVEI	17,BTMOUT		;NUMBER OF SECONDS TO WAIT FOR BASE
;;	IMUL	17,JFYSEC		;NUMBER OF CLOCK TICKS TO WAIT
;; IFCPU (KL),<CONO TIM,TO.CTD+TO.SIT+^D1666>
;; IFCPU (KS),<WRINT [<^D16>B23]>		;SET LEAP TICK
;; SYSTO2:	SKIPE	D620FN			;IS 620 FINISHED?
;;		  JRST	SYSTO3			;YES.
;; IFCPU (KI),<
;;	CONSO	APR,APRCLK		;CLOCK TICKED YET?
;;	 JRST	SYSTO2			;NO.
;;	WRAPR	APRCLK			;YES, CLEAR IT
;; >;END IFCPU (KI)
;; IFCPU (KL),<
;;	CONSO	TIM,TI.ITD		;DONE WITH 16 MS COUNT?
;;	 JRST	SYSTO2			;NO
;;	CONO	TIM,TO.CTD+TO.SIT+^D1666 ;YES, START ANOTHER
;; >;END IFCPU (KL)
;; IFCPU (KS),<
;;	CONSO	APR,LP.ITD		;DONE WITH 16MS COUNT?
;;	 JRST	SYSTO2			;NO
;;	WRINT	[<^D17>B23]		;SET INTERVAL
;;	WRAPR	LP.CSF+LP.ITD+APRCHN	;START TIMER
;; >;END IFCPU (KS)
;;	SOJG	17,SYSTO2		;AND GO IF HAVE TO WAIT SOME MORE.
;;	MOVEI	P1,[ASCIZ/
;; Base not responding (Waiting for BASE DUMP into PDP-10 memory) /]
;;	JSP	T1,CTYTYP##
;;	IORI	T2,RE.BTA!DCFULL	;STOP AUTO RELOAD (AND FORCE FULL DSKCLN)
;;					; SO THAT BASE CAN BE RESTARTED
;;	SETOM	BASDWN			;INDICATE BASE NOT RESPONDING
;;	PUSHJ	P,CTYTIM
;; >;END IFNCPU(F3)
;;*;; No longer allow base to dump into PDP-10 memory!!! /CARL ;;*;;
;Try to determine cause of crash, output message to CTY

SYSTO3:	MOVEI	P1,[ASCIZ /
Crashed by deposit 1 in 30 /]
	MOVE	T1,SAV30
	SOJE	T1,SYSTO6		;Skip next tests if DM 30,1
	MOVEI	P1,[ASCIZ /
Crashed by deposit nonzero in location 30 /]
	MOVE	T1,CRSHWD		;*HACK*
	CAIN	T1,177777		;*HACK* new base uses this in 30
	 JRST	SYSTO4			;*HACK* when it wants the 10 down
	LDB	T1,[POINT 16,SAV30,15]	; Get Base ORING pointer field
	CAME	T1,ORP620		; Does it match?
	 JRST	SYSTO5			; No! Skip this (not base)
	LDB	T1,[POINT 16,SAV30,31]	; Get Base IRING pointer field
	CAME	T1,IRP620		; Does it match?
	 JRST	SYSTO5			; No! Skip this (not base)
	MOVE	T1,SAV30		; Get entire quantity
	CAMN	T1,CRSHWD		; Does it STILL match 30?
SYSTO4:	 MOVEI	P1,[ASCIZ /
Base initiated crash /]
SYSTO5:	SKIPE	TAKDWN			;CRASHED WITH HANGUP?
	 MOVEI	P1,[ASCIZ /
HANGUP run /]
	SKIPE	CRS147
	 MOVEI	P1,[ASCIZ /
Manual restart (from location 147) /]
	SKIPN	SLOCRS			;STOPCD(SLO) or STOPCD(,DSKCLN)?
	SKIPE	NOCRS			;STOPCD(NO) (too many RIB errors)?
	 MOVEI	P1,[ASCIZ /
Full DSKCLN requested /]
SYSTO6:	JSP	T1,CTYTYP##		;PRINT MESSAGE
	PUSHJ	P,CTYTIM		;Output time (as GMT)

MONCRS:	SKIPN	NOCRS			;HARDWARE TROUBLE?
	 JRST	MONCR1			;NO
	MOVEI	P1,[ASCIZ /
Severe ERROR encountered: HARDWARE SUSPECT /]
	JSP	T1,CTYTYP##		;PRINT MESSAGE
	IORI	T2,RE.BTA!RE.ONA!DCFULL	;STOPCD(NO) WANT MAN BTS, MAN ONC, FULL DC

PRINTF(<[MONCRS @MONCR1 check DSKCLN completed only SYSTEM structure?]>)
MONCR1:	MOVE	T1,STRDDB##+STRBTS##	;HAS DSKCLN NOT
	TRNN	T1,SRPNDS##		; COMPLETED?
	SKIPE	SLOCRS			;Is it a STOPCD(.,DSKCLN) ?
	 IORI	T2,DCFULL		;Yes, set FULL-DSKCLN (old STOPCD(SLO))
	MOVE	T4,REUSER		;GET CURRENT RESTART STATE
	SKIPE	TAKDWN			;HANG CRASH?
	 JRST	MONCR2			;YES
	IORI	T2,DCFAST		;NO: FORCE FAST DSKCLN
	LSH	T4,-RENUM		;MOVE CRASH TAKEDOWN RESTRT INTO POS
	SKIPA
MONCR2:	 IORI	T2,RE.BTA		;YES: RUN BOOTS IN MANUAL
	ANDI	T4,1_RENUM-1		;ISOLATE DESIRED BITS
	HRLI	T4,RESCOD		;VALIDATE RESTART
	MOVEM	T4,RESTRT		;SAVE IN INTER-MONITOR WORD
	DPB	T2,REYMON		;PUT MON RESTART STATE IN RESTART WORD
PRINTF(<[MONCRS @MONCR2+5 Save STRPID in inter-monitor area REPSID]>)
	HLRZ	T1,STRDDB##+STRPID##	;GET PACK SET ID
	MOVEM	T1,REPSID		;SAVE IN INTER-MONITOR AREA
IFCPU (KI),<
	WRAPR	APRIOB			;RESET AGAIN TO MAKE SURE
	WRPI	411577			;AND PI SYSTEM
>;END IFCPU (KI)
IFNCPU(KI),<
	WRPI	LI.CPS+LI.COF+LI.PIF+LI.ACO ;CLEAR PI SYSTEM
	WRAPR	LP.CSF+LP.PWF+LP.IOR	;AND APR
>;END IFNCPU(KI)
	MOVEI	P,SYSPDL
	MOVEI	T3,RE.BTD		;COMPUTE ACTION FOR BOOTS
	PUSHJ	P,RECOMP		; RESTART
	TRNE	T2,RE.BTA		;MANUAL BOOTS DESIRED?
	 SETZM	BTSTR			;YES
	LDB	S,REYDCA		;GET USER SPECIFIED DSKCLN TYPE
	MOVE	T4,RESTRT
	TRNN	T4,RE.DCD		;IS IT DEFINED?
	 LDB	S,REYDCM		;NO: GET MONITOR DSKCLN TYPE
	MOVE	T1,REUSER		;GET USER RESTART
	TRNN	T1,RE.DCW		;DON'T WRITE DC TYPE TO HOME BLOCKS?
	CAIN	S,DCFULL		;IS FULL DSKCLN DESIRED?
	 JRST	LDBTS			;YES: GO LOAD BOOTS
PRINTF(<[Need a SYSTEM structure to check BOOTS options?]>)
	SKIPN	STRDDB##		;STRDDB AND UNI TABLES SETUP?
	 JRST	LDBTS			;NO: CAN'T WRITE TO DISK (No STR!)

	PUSHJ	P,BTPREP		;PREPARE FOR LOADING BOOTS
	HRLI	S,HOMDCV##		;GET HOME DSKCLN TYPE VALIDATOR
	SETZ	P4,			;INIT PREVIOUS PHYSICAL UNIT ID
	MOVEI	U,STRDDB##		;DSKCLN stuff only on prime STR!
	HLRZ	U,STRUNI##(U)		;GET ADDR OF FIRST UNIT DB IN STR
	MOVE	F,HGHBLK		;HIGHEST DIRECTLY ADDR PAGE
	SUBI	F,1			; LESS ONE (TO PRESERVE SAX SAVE AREA)
	LSH	F,PAGLSH
NXTUNT:	MOVEI	PG,LPNHOM##		;1ST HOME PAGE
	SKIPA
HOMP2:	MOVEI	PG,LP2HOM##		;2ND HOME PAGE
	PUSHJ	P,PMDRD			;READ PAGE OFF DISK
	  JSR	TDERR			;TAKE DOWN ERROR
	MOVSI	T1,'HOM'
	MOVEI	T2,CODHOM##
	CAMN	T1,HOMNAM##(F)		;VERIFY HOM PG SIXBIT NAME
	CAME	T2,HOMCOD##(F)		;VERIFY HOM PG CODE
	 JSR	TDERR
	CAME	P4,HOMPRV##(F)		;CHECK PREVIOUS PHYS UNIT FOR CONSIS
	 JSR	TDERR
	MOVEM	S,HOMDCT##(F)		;PUT IN CORE COPY OF HOME BLOCK
	PUSHJ	P,PMDWT			;WRITE BACK TO DISK
	  JSR	TDERR
	HRRZS	PG
	CAIE	PG,LP2HOM##		;SEE IF BOTH HOME BLOCKS PROCESSED
	 JRST	HOMP2			;NO: DO 2ND BLOCK
	MOVE	P4,HOMHID##(F)		;SAVE CURRENT UNIT PHYSICAL ID
	HLRZ	U,UNISTR##(U)		;POINT TO NEXT UNIT DB
	JUMPN	U,NXTUNT		;FINISHED IF NO MORE UNITS
	JRST	LDBTS1			;ALREADY DID PREP

;ROUTINE TO COMPUTE RESTART STATE
;
RECOMP::MOVE	T2,RESTRT	;GET INTER-MONITOR WORD
	TDNE	T2,T3		;IS USER ACTION DEFINED?
	POPJ	P,		;YES
IFCPU (KI),<RDAPR T1>		;READ SENSE SWITCHES
IFCPU (F3),<DATAI APR,T1>	;READ PANEL SWITCHES
IFCPU (KL),<PUSHJ P,SPCGSW##>	;GET KLDCP SWITCHES
IFCPU (KS),<MOVE T1,KSSS4>	;GET SSW WORD
IFCPU (KI),<TLNE T1,SS4>	;IS SS4 ON?
IFNCPU(KI),<TRNE T1,SS4>	;IS SS4 ON?
	JRST	[LSH	T3,-NUMREV	;SET SELECTED
		 TDO	T2,T3		; ACTION BIT
		 POPJ	P,]
	LSH	T2,-RENUM		;NO: RETURN MONITOR ACTION
	POPJ	P,

;MACRO TO DEFINE RESTART SYMBOLS AND BYTE POINTERS.
; SYMBOL SUFFIX INERPRETATIONS:
;	'A'  [USER SELECTED] RESTART ACTION.
;	'D'  DEFINITION STATE OF USER ACTION.
;	'M'  MONITOR RESTART ACTION.
;
DEFINE RESYM (DCNAM,DCS,ACT)<
  INTERN  REUSER,REY'DCNAM'A,REY'DCNAM'M,RESCOD,RE.'DCNAM'D,DCSIZ
	DCSIZ==DCS
	RESCOD=='RES'			;INTER-MONITOR WORD VALIDATOR
	REUSER:	EXP	0		;RECEPTACLE FOR USER RESTART
	NUMREV==1			;COUNT NUM OF
	IRP ACT, <NUMREV==NUMREV+1>	; RESTART TYPES
	RENUM==DCSIZ+2*NUMREV-1		;NUMBER OF RESTART BITS
	REYMON: POINT DCSIZ+NUMREV-1,RESTRT,35-RENUM
	REY'DCNAM'A: POINT DCSIZ,RESTRT,35
	RE.'DCNAM'D==1_<DCSIZ+NUMREV-1>
	REY'DCNAM'M: POINT DCSIZ,RESTRT,35-RENUM
  INTERN  DCNAM'FULL,DCNAM'FAST, DCNAM'NONE
	DCNAM'FULL==7
	DCNAM'FAST==1
	DCNAM'NONE==0
	REXX==1_DCSIZ
	IRP ACT, <RE.'ACT'A==REXX
		  RE.'ACT'D==REXX_NUMREV
		  RE.'ACT'M==REXX_RENUM
		  REXX==REXX_1>
	RE.'DCNAM'W==1B19
>

RESYM (DC,DC.SIZ,<ON,BT>);CREATE SYMBOLS FOR THE 3 BIT DSKCLN TYPE
			; FIELD 'DC' AND FOR RESTART CONDITIONS
			; 'ON' - AUTO/MANUAL ONCE AND
			; 'BT' - STRING/MANUAL BOOTS

INTERN	RE.ONA,RE.OND


;TYPE DECIMAL NUMBER ON CTY
CTYDEC::PUSH	P,T2		;PRESERVE T2
	PUSH	P,COMTOA	;SAVE CURRENT TYPEOUT ROUTINE
	MOVEI	T3,CTYTYO##
	MOVEM	T3,COMTOA
	PUSHJ	P,RADX10##	;OUTPUT DECIMAL NUMBER IN T1
	POP	P,COMTOA	;RESTORE TYPEOUT POINTER
	POP	P,T2
	POPJ	P,

;TYPE DATE AND TIME ON CTY
CTYTIM::PUSH	P,T2		;PRESERVE T2
	PUSH	P,COMTOA	;SAVE CURRENT TYPEOUT ROUTINE
	MOVEI	T1,CTYTYO##
	MOVEM	T1,COMTOA
	PUSHJ	P,GMTTIM	;Output time as GMT
	POP	P,COMTOA	;RESTORE TYPEOUT POINTER
	POP	P,T2
	POPJ	P,

GMTTIM::PUSH	P,J
	SETZ	J,
	MOVEI	T1,20		;SET TIME ZONE TO GMT
	DPB	T1,PVYTIM
	PUSHJ	P,DAYTIM##	;USE "DAYTIME" CMD
	POP	P,J
	POPJ	P,

;DETERMINE CORE START ADDR FOR BOOTS AND SAVE SA-X AREA FOR POSTERITY
;
BTPREP:	MOVE	T2,HGHBLK	;HIGH BLOCK IN ADDRESSABLE CORE
	LSH	T2,PAGLSH
IFNCPU(KS),<SUBI T2,BCDSSZ-1000	;STARTING PLACE TO READ IN
	HRRM	T2,BOOTCL>
IFCPU (KS),<SUBI T2,2000-140	;STARTING PLACE TO READ IN
	HRRZM	T2,BOOTCL>
IFN SAXN,<
	ADDI	T2,BCDSSZ-100	;END OF BOOTS+100
	HRLI	T2,SAXBAS	;SA-10 BASE LOCS ADDRESS
	BLT	T2,37(T2)	;SAVE BASE LOCS (300-337)
>
	POPJ	P,

TDERR::	0			;JSR HERE IF RESTART ERROR DETECTED
	MOVEI	P1,[ASCIZ /
SERIOUS RESTART ERROR DETECTED
/]
	JSP	T1,CTYTYP##
	JRST	LDBTS		;GO GET BOOTS

;*; BASDWN:	0		;NON-ZERO IF BASE DIDN'T RESPOND TO DUMP REQ
IFCPU (KI),<SAVCUP: BLOCK 1>	;PLACE TO SAVE CURUPT ON KI10

;End of SYSCRS/REBOOT routine

LDBTS::	PUSHJ	P,BTPREP		;PREPARE FOR LOADING BOOTS
	PFALL	LDBTS1			; (adjusts RH of BOOTCL)
SUBTTL	Load BOOTS from the disk        ;*; Start of MONBTS ;*;
PRINTF([The routine to load BOOTS should be moved to a different module])
LDBTS1:	SETZM	BOOTCL+1		;CLEAR LAST WORD OF CMD LST

IFN SAXN,<
;  LOOK FOR BOOTS ON 3330 DRIVES.
	MOVE	PG,BTADR	;<# OF BLOCKS,,DISK PAGE ADDR> FOR BOOTS
	HRRZ	F,BOOTCL	;BOOTS CORE ADDRESS (as set up by BTPREP)
BPBR1:	MOVSI	J,-7		;INIT CHANNEL COUNTER
BPBR0:	SETZ	W,		;INITIAL DEVICE
BPBR2:	PUSHJ	P,SAXRED	;PROCURE BOOTS
	 JRST	BPBR		;COULD NOT GET IT
	JSP	T4,ISBOOT	;HAS BOOTS BEEN LOADED?
BPBR:	MOVEI	W,1(M)		;NO: INCREMENT DEVICE COUNTER
	CAIG	W,77		;HAS MAXIMUM BEEN REACHED?
	 JRST	BPBR2		;NO: TRY NEXT UNIT
	AOBJN	J,BPBR0		;CONTINUE IF MORE CHANNELS TO TRY
> ;END IFN SAXN

;  NO GOOD 3330 UNIT WITH BOOTS.  TRY 2314 UNITS.

IFCPU (<KI,KL>),<
	MOVEI	T1,BOOTCL-1
	HRRZM	T1,BOOTWD	;SET LOWER CORE FOR CHL
	MOVSI	J,-KONNUM	;TRY VARIOUS KONTROLERS ALSO

DPLOOP:	PUSHJ	P,DPREAD	;WILL DO A RECAL
	PUSHJ	P,DPREAD	;AND THEN READ
	XCT	CNSZ(J)		;CHECK FOR ERRORS
	 JRST	DPNEXT		;AND TRY NEXT UNIT
	MOVE	T2,BOOTCL	;GET ADDR OF FIRST WORD
	MOVE	T3,(T2)		;CHECK FIRST WORD
	CAMN	T3,BOOTFI	;IS IT CORRECT
	JUMPG	T4,BOOTYP	;YES, SAY LOADED IF NOT TIMEOUT
DPNEXT:	XCT	CLRATN(J)	;MAKE SURE ALL ATTENTIONS CLEAR
	ADD	T1,NXUNIT
	TLZN	T1,700000	;OUT OF UNITS?
	 JRST	DPLOOP		;NO, TRY NEXT
	AOBJN	J,DPLOOP	;TRY NEXT CONTROLLER
>; END IFCPU KI,KL

IFCPU (<KS,F3>),<		;READ BOOTS FROM KS OR F3 UNITS
	MOVE	PG,BTADR	;DISK ADDR, SIZE OF BOOTS
	HRRZ	F,BOOTCL	;BOOTS CORE ADDR
	MOVSI	W,-7		;INIT UNIT COUNTER
RMRPBT:
IFCPU(F3),<PUSHJ P,APXPRD>
IFCPU(KS),<PUSHJ P,RMRPRD>
	 SKIPA			;FAILED
	JSP	T4,ISBOOT	;GOT SOMETHING, SEE IF BOOTS
	AOBJN	W,RMRPBT	;NOT BOOTS, TRY NEXT UNIT IF ONE
> ;END IFCPU(<KS,F3>)
	JRST	BOTLOD##	;Can't read BOOTS, give BOTLOD a try

ISBOOT:	HRRZ	T2,BOOTCL	;GET BOOTS STARTING ADDR
	MOVE	T3,(T2)		;GET FIRST WORD OF BOOTS
	CAME	T3,BOOTFI	;IS IT CORRECT?
	JRST	(T4)		;NO: RETURN
BOOTYP:	MOVEI	P1,[ASCIZ /
BOOTS LOADED /]
	JSP	T1,CTYTYP##	;TYPE OUT MESSAGE
	PUSHJ	P,CTYTIM	; AND DATE IT
	MOVEI	1,BTSTR		;GET ADDR OF BOOTS COMMAND STRING
	JRST	5(T2)		;PASS CONTROL TO BOOTS

;PRIMITIVE DISK READ SET UP AND DISPATCH
PMDRD:	PUSHJ	P,PMDSET	;SET UP TO READ
	HRRZ	T1,PMDDSP(T1)	;GET READ ADDRESS
	PJRST	(T1)		;READ FROM SELECTED UNIT

;PRIMITIVE DISK WRITE SET UP AND DISPATCH
PMDWT:	PUSHJ	P,PMDSET	;SET UP TO WRITE
	HLRZ	T1,PMDDSP(T1)	;GET WRITE ADDRESS
	PJRST	(T1)		;WRITE TO SELECTED UNIT

;SET UP FOR PRIMITIVE DISK ROUTINES
PMDSET:	LDB	J,UNYSCN##	;GET CHANNEL NUMBER
	LDB	W,UNYPUN##	;GET UNIT NUMBER OFFSET
	LDB	T1,UNYKTP##	;GET DEVICE TYPE
	TLNN	PG,-1		;IS # OF RECORDS SPECIFIED?
	 TLO	PG,4		;NO: DEFAULT TO ONE PAGE
	POPJ	P,

;MACRO TO GENERATE DISPATCH TABLE ENTRIES
DEFINE PMD (WT,RD)<
	IFNDEF WT, <TDERR+1,,TDERR+1>
	IFDEF WT, <WT,,RD> >

;PRIMITIVE DRIVER DISPATCH TABLE
PMDDSP:	;WRITER,,READER
	PMD(QQQQ,QQQQ)		;0  DR
	PMD(QQQQ,QQQQ)		;1  FH
	PMD(QQQQ,QQQQ)		;2  DP
	PMD(QQQQ,QQQQ)		;3  MD
	PMD(SAXWRI,SAXRED)	;4  SAX
	PMD(RMRPWT,RMRPRD)	;5  RM/RP
	PMD(APXPWT,APXPRD)	;6  F3 CDC/AMPEX DRIVES

BCDSZ==1600			;SIZE OF BOOTS CODE
BCDSSZ==BCDSZ+200		;SIZE OF BOOTS + SAX SAVE AREA
IFCPU (<KI,KL,F3>), <BTADR: BCDSZ_-7,,3	;SIZE OF BOOTS, DISK ADDR>
IFCPU (KS), <BTADR: BCDSZ_-7,,11	;SIZE OF BOOTS, DISK ADDR>
BOOTCL:	XWD -BCDSZ,0		;RH changed by BTPREP
	0

BOOTFI:	WRAPR	200000		;First word of BOOTS is CONO APR,200000


BTSTLN==:^D24			;MAX CHARS IN BOOTS COMMAND STRING
BTSTR::	BYTE	(7)"/","D",15,15,0	;DEFAULT STRING: DUMP MEM,
					; LOAD AND RUN DEFAULT MON
	BLOCK	BTSTLN/5

IFN SAXN,<

COMMENT !PRIMITIVE ROUTINES TO READ OR WRITE A SPECIFIED NUMBER OF
	 RECORDS STARTING AT AN ARBITRARY DISK PAGE FROM/TO ANY 3330
	 TYPE DRIVE CONNECTED TO AN SA-10.
	 PARAMETERS:	PG/ # OF RECORDS,,DISK PAGE
			F/ CORE ADDR (NOT NECESSARILY ON PG BOUNDARY)
			J/ 1B33  SA-10
			   3B35  SUB-CHANNEL
			W/ UNIT
	 CALL:	PUSHJ P,SAXRED  TO READ
		PUSHJ P,SAXWRI  TO WRITE
	 RETURN:	SUCCESS: M=W, SKIP RETURN
			ERROR: NON-SKIP RETURN
			       M=W OR 77  IF CHANNEL NOT AVAILABLE
				=W OR 7  IF NO MORE UNITS ON THIS
					 KONTROLLER
				=W  IF UNIT NUMBER GOOD BUT OTHER ERROR
	 ACS ALTERED:	T1-T4,M,P1-P3
!

SAXWRI:	MOVEI	P1,SAXWCD
	SKIPA
SAXRED:	MOVEI	P1,SAXRCD
	DPB	P1,SAYBB	;STORE READ OR WRITE CODE
    ;STORE DEVICE ADDRESS IN COMMANDS.
	MOVEI	T1,SAUN0(W)	;COMPUTE DEVICE ADDRESS
	MOVE	M,[POINT 8,SACLST,23] ;B HOLDS PNTR.
	DPB	T1,M		;DEV ADDR TO SEEK
	HRRI	M,2(M)		;
	DPB	T1,M		;DEV ADDR TO SEARCH ID EQUAL.
	HRRI	M,3(M)		;
	DPB	T1,M		;DEV ADDR TO READ/WRITE CMD.

	HRLI	T1,77		;CLEAR CORE ADDR FIELD
	ANDCAM	T1,SACADR	; (ALL 24 BITS)
	HRRM	F,SACADR	;SET INIT DESTINATION ADDR

;PG has # of blocks in LH, disk page address in RH

	SETZ	P3,		;INIT RECORD INDEX
NEXREC:	HRRZ	T1,PG		;COPY PAGE NUM
	IMULI	T1,1000/SAWPR	;CONVERT TO RECORD NUM
	ADD	T1,P3		;COMPUTE CURRENT RECORD NUM
	IDIVI	T1,SARPC	;COMPUTE CYLINDER,
	IDIVI	T2,SARPT	; HEAD,
	ADDI	T3,1		; AND RECORD NUMBERS
	DPB	T1,SAYCC	;STORE CYLINDER NUMBER
	DPB	T2,SAYCC+1	;STORE HEAD NUMBER
	DPB	T3,SAYCC+2	;STORE RECORD NUMBER

	MOVEI	P1,SAX1AD	;GET ADDR OF SA-10 1
	TRNE	J,4		;SKIP IF SELECTED SA-10
	 MOVEI	P1,SAX2AD	;GET ADDR OF SA-10 2
	HRRZ	M,J		;WHICH SA-10?
	LSH	M,2
	ADDI	M,SAXREG	;NOW HAVE BASE FOR THIS CHANNEL
	MOVEI	T1,SACLST
	HRLI	T1,200000	;TIC COMMAND
	MOVEM	T1,(M)		;STORE IN BASE AREA
	MOVEI	P2,1		;SET A UNIQUE BIT IN P2 THAT CORR. TO
	LSH	P2,(J)		; THE SA-10, SUB-CHAN BEING REFERENCED
	TDNE	P2,CHNFLG	;DO WE KNOW ITS NOT THERE
	 JRST	STRT4A		;YES, GIVE UP ON IT
	MOVEI	T1,21
	SETCMI	T2,(J)
	ORI	T2,-4		;ZERO EXTRANEOUS BIT IF SET
	LSH	T1,7(T2)	;SET UP BIT FOR STAT FLAG FOR THIS CHAN
	SETCA	T2,		;RECOVER CHANNEL NUMBER
	LSH	T2,3		;CONVERT TO CORRECT POSITION FOR CONO
	HRL	T2,T1		;SAVE STATUS BIT IN LEFT HALF
RESTAR:	PUSHJ	P,IOCNI		;READ STATUS
	JUMPE	T4,STRT4	;JUMP IF SA-10 IS MISSING
	MOVEI	T1,640(T2)
	PUSHJ	P,IOCNO		;SET STATUS BIT
	MOVEI	T1,440(T2)
	PUSHJ	P,IOCNO		;AND GO FLAG
	MOVEI	T1,600(T2)
	PUSHJ	P,IOCNO		;AND THEN CLEAR STATUS
	MOVEI	T4,^D100000
	HLRZ	T1,T2		;GET STATUS BIT
	PUSHJ	P,IOCNSO	;AND DO THE CONSO
	 SOJG	T4,.-1
	JUMPE	T4,STRT4	;JUMP ON TIMEOUT
	MOVE	T4,1(M)		;GET STATUS
	TLNE	T4,(1B2)
	 JRST	STRT4A		;SELECT ERROR
	MOVEI	T1,400000	;IN CASE WE HAVE TO RESET
	TLNN	T4,BSY
	 JRST	STRT3		;NOT BUSY
	TLNE	T4,SM		;BUSY+STATUS MODIFIER?
	 JRST	STRT2		;YES
	TLNE	T4,CUE
	 JRST	RESTAR		;JUMP ON BUSY+CU END
STRT3:	TLNN	T4,CE+DE	;CHANNEL END AND DEVICE END?
	 JRST	STRT5		;NO. ERROR
	TLNN	T4,175114	;OTHER ERRORS?
	 JRST	NEXRC1		;THIS RECORD PROC. OK, CONTINUE
STRT5:	PUSHJ	P,IOCNO		;T1 IS LOADED WITH BIT 18
	HRRZ	M,W		;UNIT NUM SUPPLIED WAS GOOD
	POPJ	P,

STRT4:	IORM	P2,CHNFLG	;MARK CHANNEL NOT THERE
	MOVEI	T1,77		;AND WORD FOR BAD CHANNEL
	SKIPA
STRT4A:	MOVEI	T1,7		;AND WORD FOR NO MORE DEV ON KONT
	MOVE	M,W		;COPY UNIT NUMBER
	TDO	M,T1		;SET TO TOP OF MULT OF 10
	POPJ	P,

STRT2:	MOVEI	T1,600(T2)
	PUSHJ	P,IOCNO		;CLEAR STATUS
	HLR	T1,T2		;NO WAIT FOR STATUS BIT
	PUSHJ	P,IOCNSO
	 JRST	.-1
	MOVE	T4,1(M)
	TLNE	T4,CUE
	 JRST	RESTAR
	JRST	STRT2

NEXRC1:	MOVEI	T1,SAWPR	;LOAD RECORD SIZE
	ADDM	T1,SACADR	;POINT TO NEXT RECORD LOCATION IN CORE
	ADDI	P3,1		;INCREMENT RECORD COUNTER
	HLRZ	T1,PG		;Get requested number of blocks
	IDIVI	T1,SAWPR/200	;Convert to number of records
	CAMGE	P3,T1		;Done all of them?
	 JRST	NEXREC		;NO: DO NEXT RECORD
	MOVE	M,W		;UNIT NUM SUPPLIED WAS GOOD
	JRST	XPOPJ1		;SUCCESS RETURN

IOCNSO:	MOVSI	T3,(CONSO (T1))	;SETUP IO INSTR.
IOXCT:	DPB	P1,[POINT 7,T3,9];PUT IN I/O DEVICE FIELD
	XCT	T3		;DO THE IO
	 POPJ	P,		;NO SKIP RETURN
XPOPJ1:	AOS	(P)		;SKIP RETURN
XPOPJ:	POPJ	P,		;NO SKIP RETURN

IOCNI:	SKIPA	T3,[CONI T4]	;FOR SA-10
IOCNO:	MOVSI	T3,(CONO (T1))
	JRST	IOXCT

; SA-10 COMMAND LIST AND DEFINITIONS

SACLST:
SACIDE==SACLST+2
SACTIC==SACIDE+2
SACCMD==SACTIC+1
SACADR==SACCMD+1

CMDLST:
	BYTE	(8)72,7		;SEEK
	BYTE	(12)-6(24)SACARG
	BYTE	(8)73,61	;SEARCH ID EQUAL
	BYTE	(12)-5(24)SACARG
	XWD	200000,SACIDE	;TIC
	BYTE	(8)160		;READ OR WRITE
	BYTE	(12)-SAWPR
	0
SAYBB:	POINT	8,SACCMD,15
SAYCC:	POINT	32,SACARG,31
	POINT	16,SACARG+1,15
	POINT	8,SACARG+1,23

	ND DSKTYP,^D<3330>	;Set to ^D<3650> for C24

IFE DSKTYP-^D<3330>,<;Formatted in blocks
  SAWPR==200			;Words per record
  SARPT==^D18			;Records per track
  SARPC==<SARPT*^D19>&777774	;Records per cylinder (85 pages per cyl)
>  ;End of 3330 in blocks
IFE DSKTYP-^D<3675>,<;Formatted in pages
  SAWPR==1000			;Words per record
  SARPT==^D5			;Records per track
  SARPC==SARPT*^D19		;Records per cylinder (95 pages per cyl)
>  ;End of 3675 in pages
IFE DSKTYP-^D<3650>,<;Formatted in pages
  SAWPR==1000			;Words per record
  SARPT==^D7			;Records per track
  SARPC==SARPT*^D30		;Records per cylinder (210 pages per cyl)
>  ;End of 3650 in pages
SAXWCD==5	;Disk write code
SAXRCD==6	;Disk read code
SAUN0==300	;Unit 0 at X'C0'
SAXREG==300
SAX1AD==274_-2		;SA-10 1
SAX2AD==400_-2		;SA-10 2
BSY==(BYTE (8)0,20)
CUE==(BYTE (8)0,40)
SM==(BYTE (8)0,100)
CE==(BYTE (8)0,10)
DE==(BYTE (8)0,4)

CHNFLG:	Z			;DEFECTIVE CHANNEL FLAG WORD
SACARG:	BLOCK	2		;SEEK/SEARCH BLOCK
> ;END IFN SAXN
IFCPU (<KI,KL>),<
DPREAD:	TLC T1,700000	;CHANGE READ TO RECAL AN BACK
	XCT CNO(J)	;CLEAR CONTROLLER
	HRRI T1,BOOTWD+45000	;SET FOR BLOCK 4
	XCT DSKRD(J)
	MOVEI T4,^D100000
	XCT CNSO(J)
	SOJG T4,.-1
	POPJ P,

	DEFINE DPKON(A,B)
<	A DPC,B
	A DPC2,B>

CNSZ:	DPKON (CONSZ,377720)
CLRATN:	DPKON (DATAO,CLRATW)
CNO:	DPKON (CONO,175710)
DSKRD:	DPKON (DATAO,T1)
CNSO:	DPKON (CONSO,10)
	KONNUM==.-CNSO

CLRATW:	500000,,776
NXUNIT:	XWD 10000,0
>;END IFCPU KI,KL
IFCPU (KS),<

COMMENT	!PRIMITIVE ROUTINES TO READ OR WRITE A SPECIFIED NUMBER OF
	 RECORDS STARTING AT AN ARBITRARY DISK PAGE FROM/TO AN
	 RM03/RP06 DISK DRIVE INTERFACED TO A KS THRU A UBA.
	 PARAMETERS:	PG/ # OF RECORDS,,DISK PAGE
			F/ CORE ADDR (NOT NECESSARILY ON PG BOUNDARY)
			W/ UNIT
	 CALL:	PUSHJ P,RMRPRD	TO READ
		PUSHJ P,RMRPWT	TO WRITE
	 RETURN:	SUCCESS: SKIP
			FAILURE: NON-SKIP
	 ACS ALTERED:	T1-T4,P1-P2
!

DEFINE	RDREG(DEST,REG)	;EXPECTS THE UBA NUMBER IN T2
<	RDIO	DEST,REG'ADR(T2)>

DEFINE	WRREG(SRC,REG)	;EXPECTS THE UBA NUMBER IN T2
<	WRIO	SRC,REG'ADR(T2)>


RMRPRD:	SKIPA	P1,[F.RD]	;DO DISK READ
RMRPWT:	MOVEI	P1,F.WD		;DO DISK WRITE
	HRLZI	T2,UA1	;SET THE ADDRESS TO UBA1
	MOVEI T3,CS2CLR
	WRREG T3,CS2;			CLEAR RH11
	WRREG W,CS2;			SELECT UNIT
	RDREG T4,DS;			DRIVE EXISTS?
	RDREG T3,CS2
	TRNN T3,CS2NED
	  TRNN T4,DSMOL
	   POPJ	P,
	MOVEI T4,F.RIP			;READ IN PRESET
	WRREG T4,CS1
	MOVEI T4,^D100000
	MOVEI T3,DSDRY		;WAIT UNTIL INITIALIZATION DONE
	TION  T3,DSADR(T2)
	  SOJG T4,.-1
	JUMPLE	T4,RMPOPJ
	RDREG T4,DS
	TRNE T4,DSERR
	  POPJ	P,
	MOVEI T4,F.RECA
	WRREG T4,CS1;			ISSUE RECALIBRATE
	MOVEI T3,^D100000
	RDREG T4,DS
	TRNN T4,DSDRY
	 SOJG T3,.-2
	JUMPLE T3,RMPOPJ
	TRNE T4,DSERR
	 POPJ	P,
;TRY UNIT
	RDREG P2,DT
	ANDI P2,2		;Adr is function of unit type.
	LSH	P2,-1		;0:RM03, 1:RP06
	MOVEI	T1,^D148	;CALCULATE
	CAIE	P2,0		; ABSOLUTE
	MOVEI	T1,^D380	; DISK
	HRRZ	T3,PG		; SECTOR
	LSH	T3,2		; ADDR
	IDIV	T3,T1		; FROM
	WRREG	(T3,DC)		; UNIT
	MOVE	T3,T4		; RELATIVE
	MOVEI	T1,^D30		; PAGE
	CAIE	P2,0		; NUMBER
	MOVEI	T1,^D20		; AND
	IDIV	T3,T1		; PASS
	DPB	T3,[POINT 5,T4,27]	; TO
	WRREG	(T4,DA)		; DRIVE
	HLRZ	T3,PG		;SET WORD
	LSH	T3,10		; COUNT
	MOVNS	T3
	WRREG T3,WC
	MOVE T4,F		;SET VIRTUAL CORE ADDRESS
	SETZ T3,				;SET VIRTUAL CORE ADR
	ROTC T3,-9
	ROT T3,13
	WRREG T3,BA
	MOVE T3,[UA1,,PGRADR]
	TRO T4,PGRFST+PGRVAL		;SET PHYSICAL CORE ADR
	WRIO T4,@T3
	AOJ T4,
	AOJ T3,
	WRIO T4,@T3
	WRREG P1,CS1
	movei	t3,^D100	;busy wait loop index
rmp1:	movei	t4,^D2000	;bus saturation avoidance loop index
	sojg	t4,.		;only do read every few ms to avoid
				; saturating the bus
	RDREG T4,CS1
	TRNN T4,CS1RDY		;done?
	 sojg	t3,rmp1		;no, try again if haven't timed out
	JUMPLE	T3,RMPOPJ
	TRNN	T4,CS1TRE	;ANY ERRORS?
	AOS	(P)		;NO: READ/WRITE SUCCEEDED
RMPOPJ:	POPJ	P,
>;END IFCPU KS

IFCPU(F3),<	;AMPEX/CDC TYPE DRIVE HANDLER FOR F3 PROCESSOR

RTYCNT==20000

DRVTYP==CDC
CDC==1
AMPEX==0

IFE DRVTYP-CDC,<
SPT==^D8		;SECTORS PER TRACK (DEPENDS ON HOW FORMATTED)
TPC==^D10		;TRACKS PER CYLINDER (NUMBER OF HEADS)
CPU==^D823-^D10		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>
IFE DRVTYP-AMPEX,<
SPT==^D8		;SECTORS PER TRACK
TPC==^D5		;TRACKS PER CYL (NUMBER OF HEADS)
CPU==^D815-^D5		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>;END IFN AMPEX
PPC==SPT*TPC		;PAGES PER CYLINDER
BPC==PPC*4		;BLOCKS PER CYLINDER
PPU==PPC*CPU		;PAGES PER UNIT
SPT==^D8		;SECTORS PER TRACK
BPT==SPT*^D4		;BLOCKS PER TRACK
USPR==^D17300		;MICROSECONDS PER REVOLUTION.

;DISK IOTS AND REGISTER BIT NAMES.
PRINTF([F3 disk definitions are duplicated in COMMON and APXKON])

OPDEF RCMD	[715000000000]	;READ COMMAND REGISTER
	SUNT==1B0		;SELECTED UNIT NOT THERE (SELECT ERROR)
	SUWP==1B1		;SELECTED UNIT WRITE PROTECT
	SUNR==1B2		;SELECTED UNIT NOT READY
;---
	SUOC==1B3		;SELECTED UNIT ON CYLINDER
				; SHOULD ALWAYS BE SET EXCEPT AFTER RECAL UNTIL HEADS ALIGN
	SUSE==1B4		;SELECTED UNIT SEEK ERROR (DETECTED BY DRIVE)
				; RECAL MANDATORY AFTER THIS ERROR, FAULT CLEAR WILL NOT TURN THIS OFF.
	SUF==1B5		;SELECTED UNIT FAULT (DETECTED BY DRIVE)
;---
	SUA==1B6		;SELECTED UNIT ATTENTION
				; SET BY LEADING EDGE OF ON CYLINDER (BIT 3)
	HDECC==1B7		;ECC ERROR ON HEADER
	CI==1B8			;CONTROL IDLE (ONLY IF NO DATA XFER AND NO SEEKS OR RECALS GOING)
;---
	SECC==1B9		;SOFT ECC ERROR (NOT YET IMPLEMENTED IN F3 MICROCODE)
	HECC==1B10		;ECC UNRECOVERABLE ERROR

;FOLLOWING BITS ARE DETECTED BY CONTROLLER:
	ROE==1B11		;READ OVERRUN ERROR
;---
	WOE==1B12		;WRITE OVERRUN ERROR
	SOE==1B13		;SECTOR OVERRUN ERROR
	IPE==1B14		;INTERNAL PARITY ERROR (ONLY VALID IF AE, BIT 28, IS ZERO)
;---

;FOLLOWING ARE FROM LAST LCMD

	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH COMMAND 4)
;---
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
;	19 UNUSED
;	20 UNUSED
;---
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
;---
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
;---
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)

;END OF FROM RCMD BITS
	AE==1B28		;ANY  ERROR (EXCEPT IPE, BIT 14)
	AA==1B29		;ANY UNIT ATTENTION
;---

;FROM LCMD
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE

	NA==1B31		;NOT ACTIVE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
;---
;BITS 33, 34 NOT IMPLEMENTED.

	MPE==1B35		;MEMORY PARITY ERROR
;---
OPDEF RMA	[716000000000]	;READ MEMORY ADDRESS
OPDEF RDA	[717000000000]	;READ DISK ADDRESS (IN PAGES)
	AMSUNI==^D3		;SIZE OF UNIT BYTE
	AMPUNI==^D6		;RIGHTMOST BIT
	ROTUNI==-<AMPUNI+1>	;NUMBER OF PLACES TO ROTATE TO GET UNIT FIELD IN
	AMSCYL==^D12
	AMPCYL==^D19
	AMSTRK==^D8
	AMPTRK==^D27
	AMSSEC==^D8
	AMPSEC==^D35
	LDAMSK==034000,,177400	;MASK FOR $0% AND $0O IN DDT
OPDEF RECC	[720000000000]	;READ CONTROL REGISTER
OPDEF LCMD	[721000000000]	;LOAD COMMAND REGISTER
	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH COMMAND 4)
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
OPDEF LMA	[722000000000]	;LOAD MEMORY ADDRESS
OPDEF LDA	[723000000000]	;LOAD DISK ADDRESS
	SU==1B7			;SELECT UNIT
				;MUST BE CLEARED AND SET TO SELECT A UNIT.
OPDEF LECC	[724000000000]	;CLEARS ECC LOGIC, STARTS AND INITS CONTROL.
	SC==1			;START CONTROL
	IC==2			;INIT CONTROL (SEND BEFORE STARTING CMD)
OPDEF DCONO	[740000000000]	;CONO TO DISK CONTROL TO SET PI ASSIGNMENT
OPDEF DCONI	[741000000000]	;CONI FROM DISK CONTROL OPCODE
	DIDLE==10		;SET IF CONTROL IS IDLE
	DPIA==7B35		;PI ASSIGNMENT.
				;NOTE THAT NONZERO PI ASSIGNMENT SETS DIE (SEE LCMD)
OPDEF DCONSO	[742000000000]
OPDEF DCONSZ	[743000000000]

;ROUTINE TO START A FUNCTION UP ON CONTROL

DOKON:	LECC	[IC]		;INIT CONTROL
	LCMD	T1		;DO THE COMMAND
	LECC	[SC]		;START CONTROLLER
	POPJ	P,		;AND RETURN.

CLRKON:	MOVE	T1,[CF+FC]	;COMMAND FUNCTION FAULT CLEAR
DOWKON:	PUSHJ	P,DOKON		;DO THE COMMAND AND THEN
WATKON:	MOVEI	T2,RTYCNT	;NUMBER OF TIMES TO WAIT
	RCMD	T1
	TLNN	T1,(CI)		;CONTLOL IDLE YET?
	SOJG	T2,.-2		;NO
	JUMPG	T2,CPOPJ1	;JUMP IF IT WENT IDLE
	POPJ	P,		;DIDN'T.

APINI:	HRRZ	T1,W	;GET UNIT SELECTED
	ROT	T1,ROTUNI
	LDA	T1
	TLO	T1,(<SU>)
	LDA	T1
	PUSHJ	P,CLRKON	;CLEAR CONTROL
	  JFCL			;IGNORE ERRORS FOR NOW
	RCMD	T1		;GET STATUS
	TLNE	T1,(<SUNT!SUNR>) ;NON-SKIP IF NOT THERE OR NOT READY
	POPJ	P,
	PUSHJ	P,CLRKON	;CLEAR OUT CONTROL AGAIN
	  POPJ	P,		;TIMEOUT
	MOVE	T1,[CF+FC+RECAL]
	PUSHJ	P,DOWKON	;DO A RECAL IN CASE IT HAD SEEK ERROR
	  POPJ	P,		;NO GOOD.
	MOVSI	T1,^D10		;WAIT A LONG TIME
	RCMD	T2
	TRNN	T2,NA		;SKIP IF NOT ACTIVE ANYMORE.
	SOJG	T1,.-2
	JUMPE	T1,CPOPJ	;GO IF TIMED OUT
	RCMD	T1		;GET STATUS BITS AGAIN
	TRNN	T1,AE		;ERROR RETURN IF ANY ERRORS
	AOS	(P)		;NO ERRORS
	POPJ	P,

;PRIMITIVE ROUTINE TO READ OR WRITE A SPECIFIED NUMBER OF
; PAGES STARTING AT AN ARBITRARY DISK PAGE TO/FROM ANY
; CDC OR AMPEX DRIVE (DEPENDING ON HOW ASSEMBLED) CONNECTED
; TO AN F3.
;
;PG/ # RECORDS,,DISK PAGE
;F/ CORE ADDRESS (NOT NECESSARILY ON A PAGE BOUNDARY)
;W/ UNIT
;
;CALL: PUSHJ P,APXPRD OR APXPWT TO READ OR WRITE
; SUCCESS - SKIP
; FAILURE - NON-SKIP
; USES ACS T1-T4,P1-P2. PRESERVES ARG ACS.

APXPRD:	SKIPA	P2,[APREAD]
APXPWT:	MOVEI	P2,APWRIT	;APPROPRIATE ROUTINE TO CALL.
	PUSHJ	P,APINI		;INIT THE UNIT
	  POPJ	P,		;COULDN'T INIT THE DRIVE.
	PUSH	P,PG		;NEED TO SAVE THIS
	PUSH	P,F		;SO CAN DO MORE THAN ONE REC AND PRESERVE ARGS.
	HLRZ	T1,PG		;GET COUNT OF BLOCKS WANTED.
	ADDI	T1,3
	LSH	T1,-2		;TURN INTO PAGES.
	MOVNS	T1		;- COUNT
	HRL	PG,T1		;MAKE INTO AN AOBJN POINTER
APXPX1:	PUSHJ	P,(P2)		;CALL THE ROUTINE TO DO ONE PAGE
	  JRST	APXPER		;NO GOOD.
	ADDI	F,1000		;ADVANCE MEMORY ADDRESS
	AOBJN	PG,APXPX1
	AOS	-2(P)		;OK, GIVE SUCCESS RETURN.

APXPER:	POP	P,F
	POP	P,PG
	POPJ	P,

;HERE TO READ OR WRITE ONE PAGE WITH RH(PG) CONTAINING THE BLOCK NUMBER
; W CONTAINING THE UNIT NUMBER AND F CONTANING THE MEMORY ADDRESS.

APWRIT:	SKIPA	P1,[WRITE]
APREAD:	MOVEI	P1,READ
	HRRZ	T1,PG		;GET PAGE NUMBER
	IDIVI	T1,PPC		;GET T1/CYL, T2/PAGES INTO CYL
	IDIVI	T2,SPT		;GET T2/TRACK, T3/SECTOR IN TRACK
	DPB	T2,[POINT AMSTRK,T3,AMPTRK]
	DPB	T1,[POINT AMSCYL,T3,AMPCYL]
	HRRZ	T1,W
	ROT	T1,ROTUNI	;GET UNIT NUMBER INTO POSITION
	TDO	T3,T1
	LDA	T3
	TLO	T3,(<SU>)
	LDA	T3
	PUSHJ	P,CLRKON	;CLEAR OUT CONTROL
	  JFCL			;IGNORE, WILL CATCH LATER.
	LMA	F		;LOAD MEMORY ADDRESS
				;NUMBER OF WORDS IS ALWAYS 1000
	MOVE	T1,P1		;GET COMMAND INTO T1 FOR DOKON
	PUSHJ	P,DOKON	;START THE TRANSFER
	MOVSI	T1,^D10		;TIMEOUT IS ABOUT 10 SECONDS.
	RCMD	T2
	TRNN	T2,NA
	SOJG	T1,.-2
	JUMPE	T1,CPOPJ	;TIMED OUT, ERROR
	RCMD	T1		;OK, GET COMMAND
	TRNE	T1,AE		;MAKE SURE NO ERROR BITS ON
	POPJ	P,		;SORRY.
	TLNE	T1,(<IPE>)	;THIS IS ONLY VALID IF AE OFF
	POPJ	P,		;NO GOOD.
	RMA	T1
	TLZ	T1,777774	;CLEAR UNUSED BITS
	SUB	T1,F		;GET NUMBER OF WORDS XFERRED
	CAIE	T1,1000
	POPJ	P,		;WRONG COUNT
	JRST	CPOPJ1	;OK, SUCCESSFUL XFER.
>;END IFCPU (F3)
;*; End of MONBTS ;*;
SUBTTL	COMMON SUBROUTINE RETURNS

CPOPJ2::AOS	(P)		;DOUBLE SKIP SUBROUTINE RETURN
RSKP::!				;FOR MACSYM USERS
CPOPJ1::AOSA	(P)		;SKIP SUBROUTINE RETURN
DPOPJ::	MOVEM	S,DEVIOS(F)	;DEPOSIT I/O STATUS WORD IN DDB
RTN::!
CPOPJ::	POPJ	P,

TPOPJ1::AOSA	-1(P)		;RESTORE T1 THEN SKIP RETURN
TTPOPJ::POP	P,T2
TPOPJ::	POP	P,T1		;RESTORE T1
	POPJ	P,		;AND RETURN
JPOPJ1::			;DUPLICATE NAME (PREFERRED)
IPOPJ1::AOS	-1(P)		;SET FOR SKIP RETURN
JPOPJ::				;DUPLICATE NAME (PREFERRED)
IPOPJ::	POP	P,J		;RESTORE J (USUALLY JOB OR HIGH SEG NUMBER)
	POPJ	P,
	POP	P,
T2POJ1::AOS	-1(P)
T2POPJ::POP	P,T2		;RESTORE T2
	POPJ	P,
MPOPJ::	POP	P,M
	POPJ	P,
WPOPJX::CAIA			;NETSER PUSHES THIS ADDR ON THE STACK THEN
WPOPJ1::AOS	-1(P)		; EVENTUALLY DOES A CPOPJ1 RETURN
WPOPJ::	POP	P,W
	POPJ	P,
T3POPJ::POP	P,T3
	POPJ	P,
P3POPJ::POP	P,P3
	POPJ	P,


FUPOJ1::POP	P,F
UPOPJ1::
LPOPJ1::AOSA	-1(P)		;SKIP AND RESTORE LINE
FUPOPJ::POP	P,F
UPOPJ::
LPOPJ::	POP	P,U		;RESTORE LINE AND RETURN
	POPJ	P,0		;RETURN
FPOPJ1::AOS	-1(P)
FPOPJ::	POP	P,F		;RESTORE F
	POPJ	P,0		;RETURN
ZPOPJ::	TDZA	T1,T1
M1POPJ::SETOM	T1
	POPJ	P,


ANYCPU::CAME	J,.CPJOB
	AOS	(P)
	POPJ	P,		;TURN ON DEVICE PI LEVEL

ONPOPJ::SYSPIN			;Turn on PI system
	POPJ	P,

DEFINE	NTGIVE,<		;;ROUTINE TO GIVE UP THE INTERLOCK ON AN ERROR
;*;	IFNDEF NTLERR,<EXTERNAL NTLERR>
;*;	PUSHJ	P,NTLERR>	;;GIVE UP THE INTERLOCK ONLY IF WE OWN IT

GIVLOK::NTGIVE
	POPJ	P,
;SUBROUTINES TO SAVE AND RESTORE PRESERVED ACS

SAVE1::	PUSH	P,P1		;JSP T4,SAVE1 to save P1
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-1(P)
	JRST	RES1

SAVE2::	PUSH	P,P1		;JSP T4,SAVE2 to save P1 and P2
	PUSH	P,P2
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-2(P)
	JRST	RES2

SAVE3::	PUSH	P,P1		;JSP T4,SAVE3 to save P1,P2,P3
	PUSH	P,P2
	PUSH	P,P3
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-3(P)
	JRST	RES3

SAVE4::	PUSH	P,P1		;JSP T4,SAVE4 to save P1,P2,P3,P4
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	PUSHJ	P,(T4)
	  SKIPA
	AOS	-4(P)
	POP	P,P4
RES3:	POP	P,P3
RES2:	POP	P,P2
RES1:	POP	P,P1
	POPJ	P,
SUBTTL	SYSTEM BYTE POINTERS

PUUOAC::POINT	4,M,12		;M AC FIELD
PIOMOD::POINT	4,S,35		;MODE BITS
XP PJBNLH,350700		;LEFT HALF OF "POINT 7,XXX,6"
PJOBN::	XWD PJBNLH+F,DEVCHR	;DEVICE JOB ASSIGNMENT
PUNIT::	POINT	7,DEVCHR(F),23	;DEVICE UNIT NUMBER
PJBSTS::POINT	JWSIZ,JBTSTS(J),JWPOS ;JOB WAIT STATE (QUEUE) CODE
PJBST2::POINT	JWSIZ,T2,JWPOS	;ONE FOR T2
				;IN JOB STATUS WORD
PDVTIM::POINT	3,DEVCHR(F),9	;CODE FOR TIME DEVICE MAY
				;BE ACTIVE BEFORE BEING DECLARED
				;HUNG. N MEANS 2^N-1 SECONDS
PDVCNT::POINT	7,DEVCHR(F),16	;COUNTED DOWN EACH SECOND,
				;1 TO 0 TRANSITION MEANS HUNG DEVICE
IADPTR::POINT	2,DEVIAD(F),2	;COUNT OF NUMBER OF USER CHANNELS INITED
				; ON THIS DEVICE (DECTAPE ONLY)
DEYCLS::POINT 2,DEVCLS(F),1	;DEVICE CLASS CODE
DEYMCT::POINT 4,DEVCLS(F),13	;DEVICE MAX FREE CORE COUNT
DEYTCT::POINT 4,DEVCLS(F),17	;DEVICE CURRENT FREE CORE COUNT
JBYQNT::POINT JBSQNT,JBTICT(J),JBNQNT ;POINTER TO QUANTUM RUN TIME FOR JOB
				;(NO OF JIFFIES BEFORE NEXT LOWER RUN QUEUE)

CTXTAB::			;TABLE OF BYTE POINTERS TO DISK
				; ADDRESSES. ALSO USED TO COMPUTE
				; EFFECTIVE ADDRESSES IN JBTCTX
ZZ==0
REPEAT NCTXPG,<
	POINT 27,JBTCTX+ZZ(J),35 ;POINTER TO DISK ADDRESS FOR PAGE ZZ
	ZZ==ZZ+JOBN
>

JBYSWS::POINT 2,JBTPGO(J),1	;SWAPPER STATE
JBYACT::POINT 10,JBTPGO(J),11	;NUMBER OF ACTIVE LMAP SLOTS
JBYCTR::POINT 5,JBTPGO(J),17	;NUMBER OF PAGES RESERVED FOR
				;CONTEXT PAGES
IFG NCTXPG-<1_<5-1>>,<PRINTX JBYCTR FIELD OVERFLOW>
JBYPPP::POINT 6,JBTMWS(J),5	;# OF PER-PROCESS PAGES
JBYMWS::POINT 10,JBTMWS(J),15	;MONITOR WORKING SET SIZE
JBYMWL::POINT 10,JBTMWS(J),25	;LIMIT
JBYUWS::POINT 10,JBTMWS(J),35	;USER WORKING SET SIZE.

JBYWCH::POINT 23,JBTWCH(J),35 ;BYTE POINTER TO TIME OF DAY STARTED WAITING

JBYRPT::POINT 2,JBTLIC(J),LICRPS
JBYWPT::POINT 2,JBTLIC(J),LICWPS
JBLMSZ==:^D17				;INACTIVITY TIMEOUT LIMIT FIELD SIZE
JBLMSK==:<1_JBLMSZ>-1			;INACTIVITY TIMEOUT LIMIT MASK
INADFL==:^D15				;INACTIVITY TIMEOUT DEFAULT LIMIT
INAHIT==:(1B0)				;INACTIVITY TIMEOUT LIMIT HAS BEEN HIT
JBYINA:: POINT JBLMSZ,JBTINA(J),17	;POINTER TO INACTIVITY LIMIT FIELD (J)
JBYIN2:: POINT JBLMSZ,JBTINA(T2),17	;POINTER TO INACTIVITY LIMIT FIELD (T2)
PVYMOD::POINT PVSMOD,JBTPRV(J),PVNMOD
PVZMOD::POINT PVSMOD,JBTPRV(T1),PVNMOD
PVYCOR::POINT PVSCOR,JBTPRV(J),PVNCOR
PVYTIM::POINT PVSTIM,JBTPRV(J),PVNTIM
PVYCRM::POINT PVSCRM,JBTPRV(J),PVNCRM
PVYHNG::POINT PVSHNG,JBTPRV(J),PVNHNG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;									;;;
;;;	NOTE:  This following table is in order by INTASS cause number	;;;
;;;	       and should not be re-arranged for any reason.		;;;
;;;									;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INTBYP::
JBYUUO::POINT 6,%UPT+UPTTPN,5	;(0) UUO TRAP NUMBER
JBYCLK::POINT 6,%UPT+UPTTPN,11	;(1) CLOCK TRAP NUMBER
JBYPGT::POINT 6,%UPT+UPTTPN,17	;(2) PAGE TRAP NUMBER
JBYHNG::POINT 6,%UPT+UPTTPN,23	;(3) HUNG DEVICE TRAP NUMBER
JBYTIM::POINT 6,JBTINT(J),5	;(4) TIMER TRAP NUMBER
JBYERR::POINT 6,%UPT+UPTTPN,29	;(5) DEVICE ERROR TRAP NUMBER
JBYWAK::POINT 6,JBTINT(J),11	;(6) WAKE UUO
JBYSAL::POINT 6,%UPT+UPTTP1,5	;(7) UWS FAULT, SIZE AT LEAST LIMIT
JBYSLL::POINT 6,%UPT+UPTTP1,11	;(10) UWS FAULT, SIZE LESS THAN LIMIT
JBYREF::POINT 6,%UPT+UPTTP1,17	;(11) REF BIT TRAP
JBYPER::POINT 6,%UPT+UPTTP1,23	;(12) TRAP ON I/O ERRORS.
JBYNTQ::POINT 6,JBTINT(J),17	;(13) NOTICE TO QUIT (TO BE HUNG)
JBYEXC::POINT 6,JBTINT(J),23	;(14) FRAME EXITED INTERRUPT.
JBYMCY::POINT 6,%UPT+UPTTP1,29	;(15) Micro-cycle interrupt timer
JBYLIM::POINT 6,JBTINT(J),29	;(16) TRU limit interrupt
INTRNM==:.-INTBYP	;NUMBER OF SETTABLE APR INTERUPTS

JBYSC1::POINT 9,JBTSCA(J),8	;Numerator for non-kcore factor
JBYSC2::POINT 9,JBTSCA(J),17	;Denominator for non-kcore
JBYSC3::POINT 9,JBTSCA(J),26	;Num. for kcore factor
JBYSC4::POINT 9,JBTSCA(J),35	;Denom. for kcore (or 0 if absolute)
COMMENT $
HERE IS THE INNFORMATION FOR THE PAGE TABLE. THIS TABLE
IS USED FOR SWAP IN AND OUT AND OTHER THINGS. THE BYTES
ARE ARRANGED SO THAT THE MOST FREQUENTLY USED BYTES ARE
RIGHT JUSTIFIED IN THE WORD TO MINIMIZE SHIFTING TIME REQUIRED
DURING THE BYTE INSTRUCTIONS.

THIS TABLE IS ALLOCATED AT ONCE TIME AND ALL POINTER ADDRESSES ARE
ADJUSTED. THE POINTER WILL HAVE A LOWER ADDRESS THAN THE FIRST
ENTRY SO THAT ALL THE MONITOR PAGES ARE NOT POINTED TO
$

;FIRST WORD

PGYUNU::POINT 6,.-.(PG),10	;UNUSED
PGYPGO::POINT 12,.-.(PG),22	;OUTPUT WAIT FOR THIS PAGE LINK
PGYFPL::POINT 13,.-.(PG),35	;FORWARD LINK (PAGE NUMBER)
			;PGYFPL MUST BE IN THE FIRST WORD.

;SECOND WORD

PGYLMA::POINT 22,.-.(PG),22	;LMA CHAIN START (LINKS
SNDPGY==:PGYLMA	;DEFINED FOR ONCE TIME.  MUST BE A PNTR
			;TO THE SECOND WORD, AND PGYFPL MUST BE
			;IN THE FIRST WORD.
				; ALL ACTIVE SLOTS FOR CORE PAGE
PGYLMV::POINT 10,.-.(PG),10	;VP NUMBER OF NEXT SLOT
PGYLMJ::POINT 12,.-.(PG),22	;JOB NUMBER OF NEXT SLOT, 0 IF END
PGYBPL::POINT 13,.-.(PG),35	;BACKWARD LINK (PAGE NUMBER)

;THIRD WORD

PGYLST::POINT 3,.-.(PG),2	;WHICH LIST PAGE IS ON (SEE CORE1
				; FOR LIST NUMBER DEFINITIONS)
	XP DIOMAX,77		;MAXIMUM THAT DIO CAN BE.
PGYDIO::POINT 6,.-.(PG),8	;DIRECT I/O COUNT (TAPE, NOT DISK)
  XP PGPDIO,001000
PGYADR::POINT 27,.-.(PG),35	;DISK ADDRESS. (RETRIEVAL POINTER FORMAT)
PGYUNI::POINT 8,.-.(PG),16	;UNIT NUMBER PART
PGYPNO::POINT 19,.-.(PG),35	;PAGE ADDRESS WITHIN UNIT

;FOURTH WORD

PGYSPT::POINT 22,.-.(PG),22	;SPT BASE + OFFSET
PGYSPB::POINT 18,.-.(PG),18	;SPT BASE
PGYSPO::POINT 4,.-.(PG),22	;OFFSET
PGYCHT::POINT 13,.-.(PG),35	;LINK TO NEXT CORE PAGE ON CHT

;FIFTH WORD

PGYNXM::POINT 1,.-.(PG),0	;NXM
PGYERR::POINT 2,.-.(PG),2	;IODERR,IODTER
PGYSIP::POINT 1,.-.(PG),3	;SWAP IN IN PROGRESS
PGYSOP::POINT 1,.-.(PG),4	;SWAP OUT IN PROGRESS
PGYDRT::POINT 1,.-.(PG),5	;DIRTY

PGYSTS::POINT 6,.-.(PG),5	;CORE PAGE STATUS WORD
	XP PGPNXM,40		;BIT IN STATUS WORD FOR NXM
	XP PGPDER,20		;DEVICE ERROR
	XP PGPDTE,10		;DATA ERROR
	 XP PGMERR,PGPDER!PGPDTE ;MASK FOR ERRORS
	XP PGPSIP,4		;SWAP IN IN PROGRESS
	XP PGPSOP,2		;SWAP OUT IN PROGRESS
				; MUST BE 1B34!! (SEE DECUSE)
	XP PGPDRT,1		;DIRTY
				;MUST BE 1B35!! (SEE DECUSE)

PGYSIO::POINT 2,.-.(PG),4	;COVERS SIP AND SOP.

PGYATB::POINT 13,.-.(PG),18	;PLACE TO REMEMBER ATB ADDRESS WHILE
				; PAGE IS ON LMA CHAIN (SO DON'T HAVE
				; FIND LAST SLOT ON CHAIN TO FIND ATB)
	XP USEMAX,377777	;MAXIMUM THAT USE COUNT CAN BE.
PGYUSE::POINT 17,.-.(PG),35	;NUMBER OF REASONS WHY PAGE IS IN CORE
				;MUST BE RIGHT JUSTIFIED FOR AOS @PGYUSE.

;SIXTH WORD

PGYCSH::POINT 36,.-.(PG),35	;WHOLE WORD (TO MAKE CODE FASTER)
				; SAVED CACHE SWEEP SERIAL NUMBER.
CNTPGY==:6		;NUMBER OF PGY WORDS (FOR ONCE).

ADRNCT::EXP	1B<35-27>-1	;IF PGYADR IS EQUAL TO THIS, CORE PAGE
			; IS NOT IN CHT AND HAS NO DP ASSOCIATED WITH IT.
ADRDUM::EXP	1B<35-27>-2	;IF PGYADR IS EQUAL TO THIS, CORE PAGE
			; HAS NO DISK PAGE ASSOCIATED WITH IT, BUT
			; CAN BE USED AS A PRIVATE PAGE AS LONG AS ITS NOT
			; DEACTIVATED. USED BEFORE DSKCLN FINISHED FIXING DISK.
;(WAS A PROBLEM WITH DSKCLN DOING SUPER I/O AND WRITING IN ITSELF,
; AND DSKCLN OVERWRITING RIBS AFTER IT HAD CHECKED THEM BY
; WRITING IN ITS OWN CORE IMAGE)

IFCPU (KL),<
;HERE ARE FOUR LOCATIONS WHICH HAVE THE ADDRESSES OF FOUR CACHED
; PAGES. BY LOADING THE RELATIVE ADDRESS IN THE PAGE
; INTO T1 AND THEN REFERENCING @CSRTAB+0,1,2,3, ONE CAN ENSURE
; THAT A CERTAIN FOUR WORD CHUNK HAS BEEN UNLOADED FROM THE CACHE
; WITHOUT HAVING TO DO A CACHE SWEEP.
;
;USE THE MACRO "CSHREF" TO DO THIS.

CSRTAB::.-.(T1)
	.-.(T1)
	.-.(T1)
	.-.(T1)
>;END IFCPU KL
;TABLES FOR MWS ADJUST AND PAGE AGEING CODE

AGEHST::BLOCK AGEMAX+1	;HISTOGRAM FOR OBSERVING AGE DISTRIBUTION

AGEPTR::		;TABLE OF BYTE POINTERS FOR ACCESSING
			;AGE CELLS
ZZBIT=2
REPEAT <AGECPW>,<
	POINT AGESIZ,%UPT+UPTAGE(T1),ZZBIT
	ZZBIT=ZZBIT+AGESIZ
>


;DEFINE PI CHANNEL SAVE AND RESTORE ROUTINES IF A DEVICE IS ON THE CHANNEL

	PDL==42		;LENGTH OF INTERRUPT PI PUSH DOWN LIST

DEFINE CHAN (PI)<
	XLIST
   IFNDEF ACBPI'PI,<;IF NO AC BLOCK ALLOCATED TO THIS CHANNEL,
	IFNDEF HIGAC'PI,<XP HIGHAC,17>
  >;END IFNDEF ACBPI'PI
	IFDEF HIGAC'PI,<
	IFGE HIGAC'PI-10,<XP HIGHAC,<HIGAC'PI>>
	IFL HIGAC'PI-11,<XP HIGHAC,11>
>
  IFNDEF ACBPI'PI,<;IF NO AC BLOCK ALLOCATED TO THIS CHANNEL,
	HIACBL==HIGHAC
  >;END IFNDEF ACBPI'PI
	INTERNAL SAV'PI,RET'PI,CH'PI,CH'PI'JEN,CH'PI'P,CH'PI'PD1
CH'PI:	0		;PC STORED HERE BY JSR ON INTERRUPT TO CHANNEL PI
	JEN @CH'PI	;LAST INSTRUCTION ON CONSO DEV, CHAIN

IFNDEF ACBPI'PI,<;IF NO AC BLOCK ALLOCATED TO THIS CHANNEL, GENERATE NORMAL AC SAVE CODE.

;HERE FROM AN INTERRUPT ROUTINE WHICH HAS FOUND ITS DEVICE NEEDS SERVICE
;SAVE ACS 0 THRU HIGHAC, CALLED BY JSR, SETS UP P TO PUSH DOWN LIST FOR THIS PI

SAV'PI:	0		;CALLED BY JSR
IFCPU (KS),<TBSAVE TBVA'PI>	;SAVE CURRENT TIME BASE VALUE
	EXCH	HIGHAC,CH'PI	;;GET PI, SAVE HIGHAC
	TLNN	HIGHAC,PC.USR	;;IF FROM USER MODE,
	JRST	SAV'PI'A		;;(NOT USER MODE)
	EXCH	HIGHAC,CH'PI	;NO NEED TO SAVE ANYTHING
	EXECAC
	MOVE	P,CH'PI'P	;;GET PDL FOR THIS PI LEVEL
	JRST	@SAV'PI		;;AND RETURN.

SAV'PI'A:
IFNCPU(KI),<RDUBR	SAVPG'PI>	;;NEED TO SAVE STATE ON KL
	EXCH	HIGHAC,CH'PI	;GET PC AND AC HIGHAC BACK IN RIGHT PLACES
	MOVEM HIGHAC,SAVAC'PI+HIGHAC	;SAVE AC HIGHAC
	MOVEI HIGHAC,SAVAC'PI	;SETUP TO SAVE 0 THRU HIGHAC-1
	BLT HIGHAC,SAVAC'PI+HIGHAC-1	;SAVE ACS
	MOVE P,CH'PI'P	;SETUP PUSH DOWN POINTER
	JRST @SAV'PI			;RETURN TO CALLER AND PROCESS INTERRUPT
>;END IF HIGAC'PI

IFDEF ACBPI'PI,<;IF CHAN HAS AC BLK,THEN WE ARE TO USE AN AC BLOCK FOR THIS CHANNEL.
SAV'PI:	0		;JSR TO HERE
IFCPU (KS),<TBSAVE TBVA'PI>		;SAVE THE CURRENT TIME BASE VALUE
	RDUBR	SAVPG'PI	;REMEMBER AC BLOCK SETTING
	WRUBR	[LG.LAB+<ACBPI'PI>B8+<ACBPI'PI>B11]
	MOVE	P,CH'PI'P	;GET PDL POINTER FOR THIS CHANNEL
	JRST	@SAV'PI		;AND RETURN.
>;END IFDEF ACBPI'PI

;HERE FROM INTERRUPT ROUTINE WHEN IT HAS FINISHED SERVICING INTERRUPT
;RESTORE ACS AND DISMISS INTERRUPT
;USUALLY TRANSFERRED TO BY POPJ P,

IFNDEF ACBPI'PI,<;IF CHANNEL DOESN'T HAVE AN AC BLOCK,

RET'PI:	MOVE	HIGHAC,CH'PI	;;GET RETURN PC
	TLNN	HIGHAC,PC.USR	;IF FROM USER MODE
	JRST	RET'PI'A
	USERAC			;;DON'T HAVE TO RESTORE
	JRST	CH'PI'JEN

RET'PI'A:MOVSI HIGHAC,SAVAC'PI	;RESTORE ACS 0 THRU HIGHAC
	BLT HIGHAC,HIGHAC
IFNCPU(KI),<WRUBR	SAVPG'PI>	;IF KL, NEED TO SWITCH BACK BY HAND.
>;END IFNDEF ACBPI'PI

IFDEF ACBPI'PI,<;IF AC BLOCK ASSIGNED TO THIS CHANNEL,

RET'PI:	MOVE	17,SAVPG'PI	;GET DATAI PAG WORD
	TLZ	17,(LG.LUB+LG.LPC+LG.LAB-LG.LAB) ;JUST LG.LAB SET
	WRUBR	17		;BACK TO ORIGINAL AC BLOCKS
>;END IFDEF ACBPI'PI
CH'PI'JEN:
IFCPU (KS),<	TBSET  TBVA'PI>		;RESET THE TIME BASE FOR KS
		JEN @CH'PI		;DISMISS INTERRUPT ON THIS PI CHANNEL


SAVAC'PI:: BLOCK HIACBL+1
IFNCPU(KI),<
SAVPG'PI::BLOCK	1		;PLACE TO DO DATAI PAG TO IN KL VERSION
>;END IFNCPU (KI)
IFCPU (KS),<
TBVA'PI: 0			;2 WORDS FOR SAVING THE TIME BASE
	 0>
CH'PI'P:	XWD -PDL+1,.+1		;INITIAL PUSH DOWN POINTER
CH'PI'PD1:	EXP RET'PI	;FIRST WORD ON LIST,
				; POPJ WILL RETURN TO DISMISS INTERRUPT
	BLOCK PDL-1		;PUSHDOWN LIST SPACE
	LIST
>



;GENERATE THE CHANNEL SAVE ROUTINE ONLY FOR PI WHICH NEED THEM (ASGSAV MACRO USED)

	IFN USED1, <CHAN 1>
	IFN USED2, <CHAN 2>
	IFN USED3, <CHAN 3>
	IFN USED4, <CHAN 4>
	IFN USED5, <CHAN 5>
	IFN USED6, <CHAN 6>
	IFN USED7, <CHAN 7>

;GENERATE NULL CHANNEL SAVE ROUTINES FOR THOSE CHANNELS NOT USED

DEFINE NULL (PI)<
	XLIST
CH'PI::	0
	JEN	@CH'PI
	LIST
>

;GENERATE UNASSIGNED CHAN ROUTINES FOR THOSE CHANNELS NOT ASSIGNED

DEFINE UNASS (PI)<
	XLIST
CH'PI::	0
	MOVEM	T1,SAVAC'PI
	MOVEI	T1,1_<7-PI>	;LOAD CHANNEL FLAG
	ORM	T1,BADINT	;INDICATE ILL INT OCCURED ON THIS CHAN
	WRPI	LI.COF!1_<7-PI>	;TURN CHANNEL OFF
	MOVE	T1,SAVAC'PI
	JEN	@CH'PI
SAVAC'PI: 0			;SAVE WORD
	LIST
>

	IFE USED1+UNASS1, <NULL 1>
	IFE USED2+UNASS2, <NULL 2>
	IFE USED3+UNASS3, <NULL 3>
	IFE USED4+UNASS4, <NULL 4>
	IFE USED5+UNASS5, <NULL 5>
	IFE USED6+UNASS6, <NULL 6>
	IFE USED7+UNASS7, <NULL 7>

	IFN UNASS1, <UNASS 1>
	IFN UNASS2, <UNASS 2>
	IFN UNASS3, <UNASS 3>
	IFN UNASS4, <UNASS 4>
	IFN UNASS5, <UNASS 5>
	IFN UNASS6, <UNASS 6>
	IFN UNASS7, <UNASS 7>
	IFE COREN, <COREN==^D256		;NO RESTRICTION IF 0 TYPED>
	XP USRLIM,COREN			;DEFINE GLOBAL RESTRICTING MAXIMUM SIZE OF
					; CORE FOR ANY SINGLE USER
					; ONCE ONLY CODE CAN ALTER THIS VALUE
					; (PATCH RH CORLIM IN SYSINI)

;APR AND PI BITS
	INTERN	REQCLK,PICLK
	INTERNAL APRNOT

	CLKBIT==1
	REPEAT 7-CLKCHN, <CLKBIT==CLKBIT*2>
	INTERNAL CLKBIT
	REQCLK==1B24+CLKBIT	;REQUEST INTERRUPT ON LOW PRIORITY CLK CHANNEL
	PICLK==LI.PIN+REQCLK	;TURN ON PI,REQUEST INTERRUPT ON CLK CHANNEL
IFCPU (KI),<;ONLY NEEDED FOR KI10, WHICH HAS 2 PI ASSIGNMENTS INSTEAD OF 1.
	XP APRCH2,<APRCHN_3+APRCHN>		;BOTH CLOCK AND ERROR
>;END IFCPU (KI)
XP PIPROG,77400		;PI STATUS REGISTER
			;ONES IF ANY PI'S IN PROGRESS
			;DO NOT DEFINE IF P-6 SO UNDEFINED
			;GLOBAL WILL BE CLUE TO P-6 USER
			;TO CHANGE CODE
	APRNOT==PIPROG-<400_<7-APRCHN>>	;DEFINE ALL PI IN PROGRESS FLAGS EXCEPT
					; APR FOR HALT TEST IN APRINT.
;SCANNER ENTRY POINTS AND BIT DEFINITIONS

LINFLG::BLOCK NFLG		;FOR LINE OUTPUT BITS

;XP LINTBE,LINTAB+PORTN

;TELETYPE LINE CHARACTERISTICS (LH OF LINTAB)
;USED BY SCNSER

XP TTVINI,200			;RUN INITIAL CUSP
XP TTVIN2,400			;RUN INITIAL CUSP FROM SETUUO

;LINES TO RUN INITIA

INI0==1	;LINE 0 INITIA AT START TIME
IN21==1	;LINE 1 INITIA FROM SETUUP
IN22==1	;ALSO LINE 2
IN23==1	;AND LINE 3
IN24==1	;AND LINE 4
IN25==1	;AND LINE 5 (see INITIA.MAC for what these are used for)

;NOW DEFINE THE U TABLE FOR EACH TTY'S CHARACTERISTICS
;USING THE INFO FROM CONFIG, AND DATA FROM TTYTAB AREA.

DEFINE GENLIN(LIN)<
ZZ==0

.GNLN(LIN,INI)
.GNLN(LIN,IN2)

	XWD ZZ,0		;LINE LIN
>

DEFINE .GNLN (N,BIT) <
IFDEF BIT'N,<ZZ==ZZ+BIT'N*TTV'BIT>
>

LINTAB:: LIN==0	;LINE CHARACTERISTICS BITS (NOT CLEARED ON SYSTEM STARTUP)
REPEAT PORTN+1,<GENLIN(\LIN)
                LIN==LIN+1>


;THE FOLLOWING SLIDING SCALE DEFINES THE LENGTH OF THE TTY FREE LIST

IFNDEF TTCHKN,<IFL PORTN-10,<XP TTCHKN,7*PORTN>>
IFNDEF TTCHKN,<IFL PORTN-20,<XP TTCHKN,6*PORTN>>
IFNDEF TTCHKN,<XP TTCHKN,^D10*PORTN>

TTFREE::EXP .-.			;FILLED IN AT ONCE TIME BY FREE LIST ADR
TTCLST::XWD TTCHKN,.-.		;# OF TTY CHUNKS,,ADDRESS OF FIRST ONE
XP TTCHKS,4				;CHUNK SIZE

CSUPTN:: BLOCK 1	;PHYS PG NO UPT SAVED IN ON CRASH
CRSBLK:: BLOCK ^D10	;HARDWARE MAP DATA OVERWRITTEN IS SAVED HERE AFTER PAGCNI
SYSPDL::BLOCK 56			;UNTIL FIND A BETTER PLACE FOR IT
					;USED BY ONCE ONLY CODE AS PUSH DOWN LIST
					;UPTPDL NOT USED BECAUSE ONCE CLEARS IT OUT
	SAVDMP==:<SIXBIT /   SAV/>	;EXTENSION FOR SAVED FILES == "SAV"
;CARD READER ENTRY POINT AND BITS

	IFG CDRN, <
		CDRBTS==:1670+CDRCHN
>

;CARD PUNCH ENTRY POINT

;	IFG CDPN, <
;	EXTERNAL CDPSER		;ENTRY POINT
;>



	IFG LPTN, <

;PROTOTYPE DEFINITION FOR U PRINTER DEVICE DATA BLOCKS

LPTDON==100

DEFINE	LPTDDB (N) <
IFCPU (<KI,KL>),<	;KI/KL DDB GENERATION.

	XLIST				;TURN OFF LISTING DURING EXPANSION

LP'N'SV1==LP'N'SAC+F		;DEFINE F SAVE LOCATION

LPTCON==.-LP'N'DDB
LP'N'INT: CONSO LP'N,0			;(-4) SKIP IF INTERRUPT FOR THIS LPT
	  JRST .-1			;(-3)  GO TO NEXT SKIP CHAIN ELEMENT
	  MOVEM F,LP'N'SV1		;(-2) SAVE F IN CHANNEL SAVE AREA
	  JSP F,LPTINT		;(-1) SET UP DDB ADDRESS AND BRANCH
LP'N'DDB::
LP'N'NAM:
	LPNAM==SIXBIT /LPT/
	IFE LPTN-1, <LPNAM>		;( 0) PHYSICAL DEVICE NAME
	IFN LPTN-1, <LPNAM+<20+$LPNUM>B23> ;( 0) PHYSICAL DEVICE NAME
	  XWD 6*HUNGST,<N>B23+LPTSIZ    ;( 1) DEVICE CHARACTERISTICS
					; HUNG TIME IS 63 SECS (CODE 6)
	  0				;( 2) DEVICE I/O STATUS
	  XWD 0,LPTDSP##		;( 3) LH=DDB LINK, RH=DSP TABLE ADDR.
LPTMOD==1_A+1_AL+1_I			;LPT LEGAL MODES
	  XWD DVOUT+DVLPT,LPTMOD	;( 4) DEVICE CHARACTERISTICS
	  0 				;( 5) LOGICAL DEVICE NAME
	  0				;( 6) BUFFER HEADER ADDRESSES
LPTPTR==.-LP'N'DDB
LP'N'PTR: 0				;( 7) BLOCK OUTPUT POINTER
	  0			;(10) CURRENT OUTPUT BUFFER ADDRESS
LP'N'CLS:	XWD  0,LP'N'BUF	;(11) CLASS AND MON. BUFF. POINTER
LP'N'STS:	0			;(12) DEVICE STATUS WORD
LP'N'PWC:	XWD LP'N'BL/2,0	;(13) WAKEUP COUNT LIMIT
LP'N'WUC:	0		;(14) ACTIVE WAKEUP COUNT
LP'N'CTR:	0		
LP'N'INW:	0		;(16) INTERRUPT WORD
LPTCH==.-LP'N'DDB
	  EXP 11*LP'N'CHN!LPTDON	;(15) INTERRUPT CHANNEL ASSIGNMENTS
LPTSVE==.-LP'N'DDB
	  MOVE F,LP'N'SV1		;(16) RESTORE F, SAVE AC'S
	  JSR LP'N'SAV			;(17)  AND ESTABLISH P
	  MOVEI F,LP'N'NAM		;(20) SET UP DDB ADDRESS AND RETURN
	  JRST LPTNXT			;(21)  TO COMMON INTERRUPT HANDLER
LPTEX1==.-LP'N'DDB
	  MOVE F,LP'N'SV1		;(22) RESTORE F AND
	  JEN @LP'N'CHL			;(23)  DISMISS INTERRUPT
LPTSV2==.-LP'N'DDB
	  0				;(24) SAVE LOCATION FOR U
LPTECH==.-LP'N'DDB
	  CONSZ LP'N,LPTECM		;(25) THE REST OF THE DDB CONTAINS
LPTDNE==.-LP'N'DDB
	  CONSO LP'N,LPTDON		;(26)  THE ACTUAL I/O INSTRUCTIONS
LPTCSO==.-LP'N'DDB
	  CONSO LP'N,(U)		;(27)  USED BY THE COMMON SERVICE
LPTCSZ==.-LP'N'DDB
	  CONSZ LP'N,(U)		;(30)  ROUTINE TO CONTROL A U
LPTCNI==.-LP'N'DDB
	  CONI  LP'N,U		;(31)  PRINTER. THEY ARE EXECUTED
LPTCNO==.-LP'N'DDB
	  CONO  LP'N,(U)		;(32)  BY MEANS OF AN XCT INSTRUCTION
LPTDTO==.-LP'N'DDB
	  DATAO LP'N,(U)		;(33)  INDEXED TO THE PROPER DDB
LPTBKO==.-LP'N'DDB
	  BLKO  LP'N,LP'N'PTR		;(34)
LPXSTS==.-LP'N'DDB
	CONI LP'N,LP'N'STS		;(35) DEVICE STATUS WORD CONI

SIZLPT==.-LP'N'DDB
;
;  MONITOR BUFFER DEFINITON
;
  LP'N'BL=400
	XWD LP'N'BUF,LP'N'BUF	;IN AND OUT
	EXP LP'N'BUF+LP'N'BL	;LAST
LP'N'BUF:	BLOCK	LP'N'BL	;BUFFER SPACE
;
	INTERN LPTCON,LPTPTR,LPTCH,LPTSVE,LPTEX1,LPTSV2,LPTECH
	INTERN LPTDNE,LPTCSO,LPTCSZ,LPTCNI,LPTCNO,LPTDTO,LPTBKO
	INTERN LPXSTS,SIZLPT
	LIST				;TURN LISTING BACK ON AFTER EXPANSION
>;END IFCPU KI,KL
IFCPU (KS),<	;KS10 LPT DDB GENERATION
LPTBAS==0	;the first of 4000 bytes of -11 virtual adr space
		; reserved for use by the LPT.  this space
		; will be mapped to -10 page containing LPTBUF
LP'N'DDB::
LP'N'NAM:
	PHASE 0
	LPNAM==SIXBIT /LPT/
	IFE LPTN-1, <LPNAM>		;( 0) PHYSICAL DEVICE NAME
	IFN LPTN-1, <LPNAM+<20+$LPNUM>B23> ;( 0) PHYSICAL DEVICE NAME
	  XWD 6*HUNGST,<N>B23+LPTSIZ    ;( 1) DEVICE CHARACTERISTICS
					; HUNG TIME IS 63 SECS (CODE 6)
	  0				;( 2) DEVICE I/O STATUS
	  XWD 0,LPTDSP##		;( 3) LH=DDB LINK, RH=DSP TABLE ADDR.
LPTMOD==1_A+1_AL+1_I			;LPT LEGAL MODES
	  XWD DVOUT+DVLPT,LPTMOD	;( 4) DEVICE CHARACTERISTICS
	  0 				;( 5) LOGICAL DEVICE NAME
	  0				;( 6) BUFFER HEADER ADDRESSES
	EXP 0,0				;7,10 UNUSED
	XWD  0,LP'N'BUF		;(11) CLASS AND MON. BUFF. POINTER
LPTSTS::!0			;(12) DEVICE STATUS WORD
	XWD 200,0		;(13) WAKEUP COUNT LIMIT
	0			;(14) ACTIVE WAKEUP COUNT
LPTBA::!3,,775400		;(16) BASE ADR OF LP20 REGISTERS
LPT11A::!<LPTBUF&777>_2+LPTBAS	;(17) -11 ADR OF START OF MONITOR BFR
LPTWC::!0		;(20) WORD COUNT OF MOST RECENT XFR
LPTFUN::!0		;(21) MOST RECENT FUNCTION TYPE.
LPTEC::!0		;(22) NUMBER OF LPT ERRORS
LPTLBA::!LPTBUF,,<<LPTBUF&777>*4+LPTBAS>;(23) -10,,-11 ADR OF LPT BUFFER
LPTSB::!BLOCK 4			;(24-27) DEVICE REGS ON ERROR
	DEPHASE
SIZLPT==:.-LP'N'DDB
	LP'N'BUF,,LP'N'BUF
	LP'N'BUF+LPBSIZ
LP'N'BUF:BLOCK LPBSIZ
LP'N'DDS==.-LP'N'DDB
>;IFCPU KS

>;LPTDDB MACRO DEFINITION


IFCPU (<KI,KL>),<EXTERN LPTNXT,LPTECM,LPTINT>

		$LPNUM==0		;TEMPORARY SYMBOL USED TO FACILITATE
					; MACRO GENERATION

		REPEAT LPTN, <

			LPTDDB \$LPNUM
			$LPNUM==$LPNUM+1
		>
	>;IFG LPTN


;PLOTTER ENTRY POINT

;PAPER TAPE READER ENTRY POINT AND MASK

		PTRMSK==:0		;MASK==0 IF PDP-10 READER

;PAPER TAPE PUNCH ENTRY POINT

	LIT

	RELOC .-COMORG

	END

    X r