TITLE BPXKON - KONTROLER ROUTINE FOR 3330 ON 3803 ON SA-10

	STOPCD(,ENTRY,BPXKON)
	ND FTDPAG,0	;Use UNIBLK instead of UNIPAG

	INTERNAL BPXRED,BPXWRT,BPXRCL,BPXPOS,BPXLTM,BPXSTP
	INTERNAL BPXCPY,BPXUPA,BPXINT,BPXADD,BPXFIN

;GENERAL FILSER EXTERNALS

	EXTERNAL KCMDTA,KCMERR,KCMOFL,KCMRER,KCMPOS
	EXTERNAL %OFLER,%OFLFM

;ENTERNALS IN KONTROLER DATA BLOCK AND DEV DEPENDENT KON DATA

	EXTERNAL BPXCUB
	EXTERNAL KONBMX,KONBSU,KONPTR,KONCHN,KONCPY

;CHANNEL EXTERNALS
	EXTERNAL CHNGO,CHNSTB,CHNCLR,CHNBMX,CHNIIE,CHNACT,CHNMER

;UNIT EXTERNALS
	EXTERNAL UNICOM,UNPDEV,UNIONC,UNICYL,UNYBPT,UNYPPY
IFE FTDPAG,<EXTERN UNIBLK>
IFN FTDPAG,<EXTERN UNIPAG>
	EXTERNAL UNYPUN,UNIPPU,UNYUTP,UNISWC,UNIACT
	EXTERNAL UNICNA,UNICNC,UNICCC,UNIRCT
	EXTERNAL UNISNS,UNISND,UNISNC,UNISVC,UNISCM

;IN COMMON FOR PAGE DATA (WHEN FIXING ERRORS)
	EXTERNAL EPT.PN,EPT,CURUPT

;GENERAL EXTERNALS
	EXTERNAL CPOPJ,CPOPJ1
;EXTERNAL FOR SWEEPING CACHE

;ERROR BITS FOR THE CONI GENERATED

ERRCMR==1B30	;COMMAND REJECT
ERRBOP==1B29	;BUS OUT PARITY
ERRBIP==1B28	;BUS IN PARITY
ERRPRT==1B27	;PROTECTION (SET FILE MASK) FAILURE
ERRUNK==1B26	;UNKNOWN ERROR (NO BITS CHECK BUT UNIT CHECK)
ERROVR==1B25	;OVERRUN
ERRNXM==1B24	;NXM
ERRPAR==1B23	;PARITY ERROR
ERRSRC==1B22	;SEARCH ERROR (NO RECORD FOUND)
ERRINV==1B21	;INVALID TRACK FORMAT
ERRRCV==1B20	;RECOVERABLE DATA CHECK
ERRDTA==1B19	;UNRECOVERABLE DATA CHECK
ERRCNT==1B18	;COUNT ERROR (CHANNEL TERMINATION)
ERRBSY==(1B17)	;BUSY
ERRATN==(1B16)	;ATTENTION FLAG
ERRUXC==(1B15)	;UNIT EXCEPTION
ERREQP==(1B14)	;PERMANENT EQUIPMENT CHECK
ERREQC==(1B13)	;EQUIPMENT CHECK
ERRLEN==(1B12)	;LENGTH ERROR
ERRCON==(1B11)	;CONTROL ERROR
ERRSEL==(1B10)	;SELECT ERROR
ERRWPT==(1B9)	;WRITE PROTECT ERROR (COMMAND REJECT ALSO ON)

;SA-10 ERROR BITS

SELER==(1B2)	;SELECT ERROR
BUSIER==(1B3)	;BUS IN PARITY ERROR
CONERR==(1B4)	;CONTROL ERROR
LENERR==(1B6)	;LENGTH ERROR

;SA-10 REPORTED STATUS BITS
ATTEN==(1B8)	;ATTENTION
STSMOD==(1B9)	;STATUS MODIFIER
CUEND==(1B10)	;CONTROL UNIT END
BUSY==(1B11)	;BUSY
UCHK==(1B14)	;UNIT CHECK
UXCP==(1B15)	;UNIT EXCEPTION
DEVEND==(1B13)	;DEVICE END (COMES FROM PACK ON LINE)
;OPERATION CODES FOR 3330

BPXRD==6	;READ
BPXWT==5	;WRITE
RECAL==23	;RECALIBRATE
SEEK==7	;SEEK
SETSEC==43	;SET SECTOR
SRCIDE==61	;SEARCH ID=
SENSE==4	;SENSE
SEEKCY==13	;SEEK CYLINER (USED FOR SEEK UUO)
RRBL==244	;READ AND RESET BUFFERED LOG

;SA-10 CONTROL BITS

NOMEMT==200	;NO MEMORY TRANSFER (BYTE ORIENTATION FOR BITS
XCTCMD==40	;EXECUTE COMMAND
CHAIN==20	;CHAIN COMMAND
IGNLEN==2	;IGNORE LENGHT ERROR
OFFSET==1	;BYTE MODE OFFSET
TRWORD==0	;TRANSFER WORD MODE
TRBYTE==10	;TRANSFER BYTE MODE
TRBIT==100	;TRANSFER BIT STREAM MODE
TRTAP==110	;TRANSFER TAPE COMPATABILITY

BYTMOD==TRBYTE+CHAIN+XCTCMD+IGNLEN
NOXFR==NOMEMT+XCTCMD+IGNLEN
STROFA==XCTCMD+CHAIN+TRBYTE+OFFSET+IGNLEN
WRDMOD==TRBIT+XCTCMD+CHAIN

TICBIT==(1B1)	;BIT FOR TIC

BPERT==^D<18*19>&777774

	DEFINE XOR(A,B)
	<A!B-A&B>
SUBTTL	BPXINT -- Interrupt handler

;At this point J points to the Kontroller Data Block,
; PG points to the Channel Data block, and
; M points to the SA-10 Data Block

BPXINT::MOVE	T1,@CHNSTB(PG)	;Get the status word (location 305 in low core)
	AOS	P3,SAXPTR##	;Save last ^D512 status words
	ANDI	P3,777		;Wrap within the buffer
	MOVEM	P3,SAXPTR##
	MOVEM	T1,SAXBUF##(P3)
	LDB	P3,[POINT 4,T1,23] ;Get unit # (P3 used in @KONPTR)
	MOVE	U,@KONPTR(J)	;Get pointer to unit CB (BPA0CB, etc)
	SKIPL CHNSTB(PG)	;CHECK FOR MEMORY ERROR ALSO
	TLNE T1,ANYERR
	 JRST ERRCHK	;CHECK FOR UNUSUAL CONDITION
	SETZB P1,P2	;NO ERROR, P1 HAS FAKE CONI P2 SYNDROM
	PUSH P,P2	;AND ON STACK IS FAKE DATAI
DATACK:	JUMPE U,DISMS1	;WE GET HERE AFTER STATUS READ
	MOVE T1,UNICOM(U)	;GET POINTER TO CONTROL BLOCK
	LDB T2,[POINT 8,(T1),15]	;AND GET FIRST COMMAND
	CAIN T2,SEEK	;IS IT A SEEK (HEAD AND CYL)
	JRST DATA	;PG`THEN IT WAS A DATA TRANS
	CAIE T2,RECAL
	CAIN T2,SEEKCY
	JRST POSINT	;RECAL OR SEEK CYL SEEK UUO OR ERROR
	CAIN T2,RRBL
	JRST POSNTS	;TREAT AS POSITION INTERUPT EXCEPT IN SENCE COUNT FOR BUFF LOG
	SKIPN (T1)	;IS ENTIRE WORD 0?
	JRST POSINT	;YES, MUST BE ON-LINE
	JRST ERRSEN		;A TIC FOR THE SENSE
DISMS1:	POP P,T1	;ADJUST STACK
DISMIS:	MOVSI T1,7B20	;HALVES HAVE BEEN SWITCHED
	ANDCAM T1,CHNSTB(PG)	;RESET MEMORY ERROR BITS
	XCT CHNGO(PG)	;START THE SA-10 CHANNEL (IN CASE GO LOST)
	XCT CHNCLR(PG)	;AND CLEAR STATUS FLAG
	POPJ P,		;ALL DONE

ANYERR==UCHK!BUSY!CUEND!LENERR!CONERR!BUSIER!SELER!ATTEN!UXCP

ERRCHK:	TLNE T1,UCHK	;IS IT A UNIT CHECK
	JRST RDSTS	;YES, WE MUST DO A READ STATUS
	TLNE T1,BUSY
	JRST CHKBSY	;CHECK BUSY
	TLNE T1,CUEND
	JRST KONENC	;IF SO, RESTART WAITING DEVICES
	JRST ERROR	;ASSUME ERROR CONDITION
RDSTS:	SKIPE UNISVC(U)	;HAVE WE ALREADY SET UP THE SENSE?
	JRST	[MOVE T2,UNICOM(U)	;YES, MUST SET T2
		JRST RDSTSS]	;AND GO
	MOVE T3,CHNSTB(PG)	;HERE TO READ STATUS, SAVE SECOND
	MOVE T3,1(T3)	;OF STATUS STORED BY SA-10
	MOVEM T3,UNISVC(U)	;HAS COUNT INFO
	MOVEI T3,UNISNS(U)
	HRLI T3,TICBIT	;SET UP FOR TIC TO SENSE
	MOVE T2,UNICOM(U)
	EXCH T3,(T2)	;SET IT AND GET OLD COMMAND
	MOVEM T3,UNISCM(U)
RDSTSS:	PUSHJ P,STRTU	;GET UNIT READY TO START
	JRST DISMIS	;AND GET OUT OF INTERUPT

STRTU:	MOVE T3,KONBSU(J)
	ADD T3,P3	;GENERAT UNIT NUMBER
STRTU1:	HRLI T2,(15B11)	;A START CODE
	DPB T3,[POINT 8,T2,7]	;SET IT UP
	HLRZ T3,KONBMX(J)
	ADD T3,P3	;SET TO POINT TO LIST
	MOVEM T2,(T3)
	POPJ P,		;ALL DONE WITH LIST SETUP

;HERE ON A BUSY INDICATION

CHKBSY:	TLNN T1,STSMOD	;IS IT BUSY AND STATUS MODIFIER
	JRST DEVBSY	;NO, SOME TYPE OF DEVICE BUSY
CUBSY:	MOVN T2,P3	;CONTROL UNIT BUSY
	MOVSI T3,(1B0)	;SET A MAST THAT UNIT NEEDS RESTART
	LSH T3,(T2)
	IORM T3,BPXCUB(J)
	TLNE T1,CUEND	;CHECK FOR CONTROL UNIT END ALSO
KONENC:	PUSHJ P,KONEND	;YES, RESTART WAITERS
	JRST DISMIS	;AND JUST DISMIS IF NOT
SUBTTL	BPXINT -- Control-Unit end

;Memorex 3672 and Ampex control units handle 2 strings = 16 disks (0-17)
;Memorex 3674 handles 4 strings = 32 disks (00-37) if no logical volumes
;Memorex 3674 + 4 strings of 3652 = 64 logical volumes (00-77)
;   When CUEND comes in, we need to start all waiting units that are
; connected to the control unit.  The old BPXKON assumes only 16 disks
; per controller.  But if we attempt to start I/O on unit 340 and the
; controller is busy, then when it becomes not busy it will report the
; lowest unit assigned to the controller.  The code added here will
; restart units 340-377 when not-busy comes in on unit 300.

KONEND:	PUSH	P,J		;Save KON address
	MOVEI	J,BPACB##	;*HACK* Start at 1st string *HACK*
KONEN1:	HLLZ	T1,BPXCUB(J)	;Get mask of 16 unit busy flags
	HRRZS	BPXCUB(J)	;Clear them in KON data block
	MOVEI	P3,0		;Start with relative unit 0
	TLZ	T1,(1B16!1B17)	;Keep only bits 0-15 (2 strings per KON)
	JUMPN	T1,CRST		;Continue if interrupt for this KON
KONEN2:	HLRZ	T1,KONCHN(J)	;Pointer to next KON
	JUMPE	T1,JPOPJ##	;No next kontroller, unaccountable interrupt
	MOVE	J,T1		;Switch to next set of 16 units
	JRST	KONEN1		;See if 3rd or 4th string caused CUEND

CRST:	JFFO	T1,.+2		;Find first unit that was busy
	 JRST	KONEN2		;Got all of them, now try BPB and BPC
	LSH	T1,1(T2)	;Get rid of bit JFFO found
	ADD	P3,T2		;Update unit number (00-17)
	SKIPN	U,@KONPTR(J)	;Get pointer to unit's CB (indexed by P3)
	 AOJA	P3,CRST		;No such unit
	HRRZ	T2,UNICOM(U)	;Point to channel command list
	PUSHJ	P,STRTU		;Restart unit
	AOJA	P3,CRST		;And check for more on this KON

;Top of page to here was extracted from CPXKON.MAC on 22-Apr-88 by JMS
;so that system F30 could run with 3 strings of 3765 (in blocks) could
;run on a single 3674 controller.

DEVBSY:	TLNN T1,CUEND!DEVEND	;IS IT CONTROL UNIT END OR DEV END AND BUSY
	JRST ERROR	;NO, DEVICE BUSY IS ERROR
	AOS BPSTRD	;COUNT NUMBER OF TIMES GO BUSY CUEND
	JRST RDSTS	;BUSY CUEND, TREAT AS UNIT CHECK

BPSTRD:	0
	1,,0
	.LINK 1,.-1
	BPSTRD,,[SIXBIT /BPSTRD/]
POSNTS:	AOS UNISNC(U)	;INCREMENT SNESE COUNT (READ AND RESET LOG)
POSINT:	MOVN T2,P3	;GET SET TO GENERAT A BIT FOR DEVICE
	MOVSI T1,(1B0)
	LSH T1,(T2)
	TDNE T1,KONCPY(J)
	JRST BPXCNX	;THIS IS THE RESULT OF A CAPACITY TEST
POSDIS:	HRLI T1,KCMPOS
	SETZB P1,(P)	;NO CONI OR DATAI INFO
FILDIS:	POP P,T3	;GET DATAI TO CORRECT PLACE
FILDS1:	MOVE T2,UNICOM(U)
	SETZM (T2)	;ZERO OUT COMMAND AREA SO RECOGNIZE ON-LINE
	MOVE T2,P1	;CONI
	XCT CHNGO(PG)
	XCT CHNCLR(PG)
	JRST FILINT##	;Tell FILIO

ERRSEN:	MOVE T2,UNISCM(U)
	AOS UNISNC(U)	;COUNT AA SENSE DONE
	MOVEM T2,(T1)	;RESTORE THE FIRST COMMAND
	MOVEI T1,0		;ALSO ZERO UNISVC FOR NEXT SENSE
	EXCH T1,UNISVC(U)	;AND THE COUNT INFO
	MOVE T2,CHNSTB(PG)
	MOVEM T1,1(T2)
	PUSH P,U	;AT END OF SENSE, RESTART WAITERS
	PUSH P,P3	;THIS TAKES CARE OF BUSY, CUENDD
	PUSHJ P,KONEND	;WHICH MUST WAIT FOR SNESE TO FINISH
	POP P,P3	;NORMALLY NO WAITERS SO MAKES LITTLE
	POP P,U		;OR NO DIFF IF NOT BUSY, CUEND
	JUMPN P1,DATACK	;FORGET IT IF SOME OTHER ERROR DETECTED
	HLLZ T2,UNISND(U)	;GET STATUS BITS
	TLZ T2,3
	JFFO T2,BYT0	;CHECK FOR ANY ON
	HRR T2,UNICOM(U)	;LOOKS LIKE ENVIRON DATA
	PUSHJ P,STRTU
	JRST DISMS1	;JUST RESTART UNIT

BYT0:	JRST @BYT0T(T3)	;DISPATCH ON BIT

BYT0T:	CMDRJC	;COMMAND REJECT BYTE 0 BIT 0
	OFLIN	;OFF-LINE (INTERVENTION REQUIRED) BYTE 0 BIT 1
	BUSOPA	;BUSS OUT PARITY ERROR BYTE 0 BIT 2
	EQCHK	;EQUIPMENT CHECK BYTE 0 BIT 3
	DTACHK	;DATA CHECK BYTE 0 BIT 4
	OVRUN	;PERMANENT OVERRUN BYTE 0 BIT 5
	UNKNO	;UNKNOWN, BIT UNUSED BYTE 0 BIT 6
	UNKNO	;UNKNOWN, BIT UNUSED BYTE 0 BIT 7


BYT1T:	UNKNO	;UNKNNOWN PERMANENT ERROR OTHER SHOULD BE ON
		;BYTE 1 BIT 0
	INVTRK	;INVALID TRACK BYTE 1 BIT 1
	UNKNO	;UNKNOWN EOC BYYTE 1 BIT 2
	UNKNO	;UNKNOWN UNUSED BYTE 1 BIT 3
	NOREC	;NO RECORD FOUND BYTE 1 BIT 4
	PROTEC	;FILE PROTECTED BYTE 1 BIT 5
	UNKNO	;WRITE INHIBITED CMD REJECT SHOULD BE ON BYTE 1 BIT 6
	UNKNO	;OPERATION INCOMPLETE, OTHER SHOULD BE ON TOO BYTE 1 BIT 7
;SENSE ERROR DATA

PROTEC:	TROA P1,ERRPRT	;PROTECT ERROR
OVRUN:	TRO P1,ERROVR	;DATA OVERRUN
ERRNO:	MOVE P2,RTYZRO	;NO RETRYS
ERRCOM:	MOVE T1,UNISND+1(U)	;PHYSICAL DRIVE NUMBER IS HERE
	MOVEM T1,(P)
ERRCM1:	SKIPN UNIRCT(U)	;HAS RETRYPATTERN BEEN SET YET?
	MOVEM P2,UNIRCT(U)	;NO, SET IT
	JRST DATACK	;AND CHECK ON TRANSFER

BUSOPA:	TRO P1,ERRBOP
ERRONE:	MOVE P2,RTYONE	;ONE RETRY
	JRST ERRCOM

OFLIN:	MOVE T1,UNISND+1(U)
	MOVEM T1,(P)
	LDB T2,UNYPUN
	MOVNS T2
	MOVSI T1,(1B0)
	LSH T1,(T2)
OFLIN2:	ANDCAM T1,KONCPY(J)	;TURN OFF CAPACITY TEST BIT IF OFF-LINE
	MOVSI T1,KCMOFL
	JRST FILDIS	;DISMISS INTERRUPT, CALL FILINT IN FILIO

EQCHK:	MOVSI T1,(1B8)
	TDNN T1,UNISND(U)
	TLOA P1,ERREQC
	TLOA P1,ERREQP
ERRTEN:	SKIPA P2,RTYTEN
	JRST ERRNO	;NO RETRY ON PERM ERROR
	JRST ERRCOM	;10 RETRY ON CORRECTABLE ERROR

UNKNO:	TRO P1,ERRUNK	;UNKNOWN ERROR
	JRST ERRTEN	;RETRY 10 TIMES

NOREC:	TROA P1,ERRSRC	;CALL IT A SEARCH ERROR
INVTRK:	TRO P1,ERRINV
ERRDT0:	MOVE P2,RTYDT0	;DATA ERROR, 0 RETRYS
	JRST ERRCOM

CMDRJC:	TRO P1,ERRCMR
	MOVSI T1,(1B14)
	TDNE T1,UNISND(U)
	TLO P1,ERRWPT	;WRITE PROTECT ERROR
	JRST ERRNO

	DEFINE SYND(RTY,RCL,RRT,MOD)
<	XWD RRT+200000+UNPDEV*MOD,RCL_9+RTY>

RTYCNT:	SYND (^D100,0,0,1)
RTYZRO:	SYND(0,0,0,1)
RTYONE:	SYND(1,0,0,1)
RTYTEN:	SYND(^D10,0,0,1)
RTYDT0:	SYND(0,0,0,0)
DTACHK:	MOVSI T1,(1B17)	;SEE IF CORRECTABLE
	TDNN T1,UNISND(U)
	JRST DTAUNC	;NO, NOT CORRECTABLE
	LDB P3,[POINT 24,UNISND+5(U),23]	;GET SYNDROM BYTES
	LSH P3,^D12	;LEFT JUSTIFY
	MOVEI P4,0
	LDB P1,[POINT 16,UNISND+4(U),15]
	LDB P2,[POINT 8,UNISND+3(U),31]
	DPB P2,[POINT 8,P1,19]	;HERE ISS THE RESTART DISP
	LDB P2,[POINT 16,UNISND+4(U),31]	;HERE IS THE ERROR DISP
	SUB P1,P2	;NUMBER OF BYTES TO OFFSET FROM START
	LSH P1,3	;CONVERT P1 TO NUMBER OF BITS
	IDIVI P1,^D36	;NOW HAVE WORDS IN P1, BITS IN P2
	MOVNS P2
	LSHC P3,(P2)	;AND SHIFT SYNDROM TO DOUBLE WORD POSITION
	JUMPN P3,GORCV	;SEE IF ANY LEFT IN P3
	ADDI P1,1	;NO, 1 EXTRA WORD
	EXCH P3,P4	;AND GET BITS TO P3
GORCV:	HRRZ T1,CHNSTB(PG)	;GET POINTER TO COMMAND CHAIN
	SOS P2,1(T1)	;POINTS TO FIRST DATA WORD OF RECORD
	SKIPL (P2)	;POINTER ALWAYS POINTS 1 AFTER 1ST DATA WD
	AOJA P2,.-1	;GET IT TO POINT TO LAST
	ADDI P2,2	;IF LAST RECORD, NOW 1 AFTER HALT
	HRRZS P2	;AND GET RID OF COUNT. NOW LOOKS LIKE TO END OF RECORD
	EXCH P2,1(T1)	;GET THE OLD WORD PNTS TO 1ST TRANS
LOKRCV:	LDB T1,[POINT 11,(P2),11]	;GET COUNT
	MOVNS T1
	ANDI T1,3777
	CAMLE T1,P1	;IS IT LESS OR EQUAL TO OFFSET COUNT
	JRST FNDRCV	;IF YES, WE HAVE FOUND THE TRANS WORD
	SUB P1,T1	;DECREMENT OFFSET REMAINING
	SKIPL (P2)	;AND IF MORE TRANSFER WORDS
	AOJA P2,LOKRCV	;TRY NEXT BLOCK OF DATA
FINRCV:	MOVEI P1,ERRRCV
	MOVEI P2,0	;ALL DONE, RECOVERABLE ERR AND NOT RETRY
	JRST ERRCOM

FNDRCV:	LDB T2,[POINT 24,(P2),35]
	JUMPE T2,NOTRN	;NO TRANSFER IF ADDRESS IS 0
	ADD T2,P1	;ADD IN THE OFFSET
	LDB T1,[POINT 13,T2,26]	;PAGE NUMBER
	ANDI T2,777	;AND DISP WITHIN PAGE
	TRO T1,PGE.A!PGE.W!PGE.P	;SET ACCESS
	DPB T1,[EPTPGP (%ERR.N)]
	CLRPTO	%ERR		;CLEAR PAGE TABLE ENTRY FOR %ERR
	XORM P3,%ERR(T2)	;FIX UP THE ERROR
NOTRN:	JUMPE P4,FINRCV	;IF REST OF BYTES 0, DONE
	MOVE P3,P4
	MOVEI P4,0	;MOVE BYTES AND SET REMAINDER TO
	AOJA P1,LOKRCV	;COUNT OF 1 MORE, LET COMMON CODE LOOK

DTAUNC:	TRO P1,ERRDTA	;UNRECOVERABLE
	JRST ERRNO
DATA:	MOVE T1,CHNSTB(PG)	;GET SET TO COUNT WORDS TRANS
	SOS T1,1(T1)	;THIS IS THE TERMINATE WORD
	HRRZ T3,UNISWC(U)	;EXPECTED COUNT
	HLRZ T2,UNISWC(U)	;EXPECTED END
	CAIN T2,(T1)	;ARE THEY THE SAME?
	JRST DTADON	;YES, ALL OK
	HRRZS UNISWC(U)	;FOR COUNT CHECKING
	HRRZ T2,UNICOM(U)	;POINTER TO COMMAND LIST
	MOVEI T3,0	;COUNT SO FAR
CNTLP:	SKIPGE T4,(T2)	;BIT 0 ONLY ON FOR HALT IN DATA TANS
	JRST CNTDON	;IT IS A HALT
	CAIN T2,(T1)	;DO WE END NOW?
	JRST CNTDON	;YES, FINISHED COUNTING
	TLNN T4,(1B2)	;THIS IS THE EXECUTE BIT
	AOJA T2,CNTLP	;IF NOT ON, THIS MUST BE TIC
	TLNN T4,(1B4)	;CHECK BYTE MODE
	AOJA T2,DTATRN	;NOT BYTE MODE, MUST BE DATA
	ADDI T2,1	;CHECK FOR TRANSFER
BYTARG:	CAIN T2,(T1)
	JRST CNTDON	;ENDED HERE
	SKIPGE (T2)
	AOJA T2,CNTLP	;NEGATIVE IS LAST TRANS
	AOJA T2,BYTARG	;ELSE MORE TRANSFER WORDS

DTATRN:	LDB T4,[POINT 11,(T2),11]	;GET COUNT FIELD
	CAIN T2,(T1)
	JRST LSTCNT	;IF TERMINATE HERE, THIS IS PARTIAL COUNT
	TRC T4,3777
	ADDI T3,1(T4)	;INCREMENT COUNT
	SKIPGE (T2)
	AOJA T2,CNTLP	;NEGATIVE IS LASTTRANSFER
	AOJA T2,DTATRN	;MORE DATA

LSTCNT:	LDB T1,[POINT 11,T1,11]	;PARTIAL TRANS, GET REMAINING COUNT
	SUB T1,T4	;SUBTRACT ORIGINAL COUNT
	ANDI T1,3777	;JUST IN CASE ALL REALLY TRANS (T1=0)
	ADD T3,T1
CNTDON:	CAMN T3,UNISWC(U)	;IS IT THE SAME?
	JRST DTADON	;YES, FINISHED
CNTBAD:	TRO P1,ERRCNT	;SET COUNT ERROR FLAG
	SKIPE (P)	;IS THERE DATAI INFO
	JRST DTADON	;YES, SOME OTHER ERROR ALSO
	SETOM (P)	;FLAG SOFT ERROR
	MOVE P2,RTYCNT
	SKIPN UNIRCT(U)
	MOVEM P2,UNIRCT(U)	;SET TO RETRY
DTADON:	SKIPN T3
	MOVEI T3,200	;SET AMOUNT TRANSFERED
	ADDI T3,177	;MUST BE EVEN NUMBER OF RECORDS
	LSH T3,-7	;AND AT LEAST ONE
	MOVE T1,T3
	ADD T1,UNICCC(U)	;ADD IN COUNT SO FAR
IFN FTDPAG,<
	LSH T1,-2	;CONVERT TO PAGES
	SKIPN T1	;AT LEAST 1
	 MOVEI T1,1
>
	HRLI T1,KCMDTA	;DATA TRANS
	JUMPE P1,FILFAK	;FINISHED, ANY ERRORS?
	TRNN P1,ERRRCV	;IS IT RECOVERABLE DATA?
	TLOA T1,KCMERR
	TLO T1,KCMRER	;YES, FLAG IT
	JRST FILDIS	;DISMISS INTERRUPT, CALL FILINT IN FILIO
;HERE TO REGENERATE COMMAND LIST WITHOUT CALLING FILIO

FILFAK:	SKIPN UNICNA(U)
	JRST FILDIS	;NO MORE TO REGEN
	ADDM T3,UNICCC(U)	;INCREASE COUNT
	XCT CHNGO(PG)
	XCT CHNCLR(PG)	;RESTART SA-10
	POP P,P4	;GARBAGE WORD

COMMENT ; WE KNOW THAT THIS TRANSFER WILL BE ON RECORD 1 OF
THE HEAD NUMBERED ONE HIGHER THAN THE FIRST TRANSFER THE
LAST TIME. ALSO THE SEEK, SET SECTOR, SEARCH ID EQUAL, READ OR WRITE
ARE ALREADY SET UP. ALL WE HAVE DO DO IS MODIFY THE ADDRESS OF
THE SEEK AND SET SECTOR ANDD CALL THE ADD ROUTINE;

	PUSHJ P,BPXSET	;SET UP P1 AND P3
	MOVEI T1,1
	DPB T1,[POINT 8,(P3),23]	;RECORD 1
	MOVSI T1,(BYTE (8) 0,1)	;NOW INCREMENT THE HEAD NUMBER
	ADDB T1,(P3)
	LDB T1,[POINT 16,T1,15]	;NOW GET JUST THE HEAD
	MOVEI P4,BPERT*200	;SET UP TO EOC
	IMULI T1,^D18*200	;BLOCKS/TRACK
	SUB P4,T1	;THIS IS LEFT TO EOC
	MOVEI P2,^D18*200	;AND WE HAVE 1 TRACK WORTH NOW
	MOVE T1,RECTBL
	MOVEM T1,1(P3)
	HRLI P1,4(P1)	;NOW SET UP FOR MORE ADDITIONS
	ADDI P1,11
	SUBI P3,3
	SETZM UNISWC(U)
	HRL P3,BPBRK1	;NOT IMMEDIATE IN CASE CHANGED FOR BREAKPOINTS
	MOVE T1,UNICNC(U)
	MOVE T2,UNICNA(U)
	SETZM UNICNA(U)	;IN CASE THIS ONE FINISHES IT
	PUSHJ P,BPXAD1
	 JFCL
	PJRST BPXFIN	;AND GO
;HERE ON AN SA-10 DETECTED ERROR

ERROR:	SETZB P1,P2
	PUSH P,P1	;SET DATAI AND CONI, RETRY INFO
	SETOM (P)	;FLAG AS CHANNEL IN DATAI WORD
	SKIPGE CHNSTB(PG)
	JRST MEMERR	;MEMORY ERROR
	TLNE T1,SELER
	JRST SELERR	;SELECT ERROR TRY AGAIN
	MOVE P2,RTYCNT	;SET FOR LOTS OF RETRYS
	TLNE T1,LENERR	;LENGTH ERROR
	TLO P1,ERRLEN
	TLNE T1,CONERR
	TLO P1,ERRCON
	TLNE T1,BUSIER
	TRO P1,ERRBIP
	TLNE T1,BUSY
	TLO P1,ERRBSY
	TLNE T1,ATTEN
	TLO P1,ERRATN
	TLNE T1,UXCP
	TLO P1,ERRUXC
	JRST ERRCM1	;CHECK ON DATA NOW

SELERR:	TLO P1,ERRSEL
	MOVE P2,RTYONE	;ONE RETRY
	JRST ERRCM1

MEMERR:	MOVE P2,RTYCNT	;LOST OF RETRYS
	MOVE T1,CHNMER(PG)
	TRO T1,1	;FLAG NO STATUS INFORMATION BUT MEM DATA
	MOVEM T1,(P)
	MOVE T1,CHNSTB(PG)
	TLNE T1,1B19	;HALVES HAVE BEEN SWITCHED
	TRO P1,ERRPAR
	TLNE T1,1B20
	TRO P1,ERRNXM
	MOVSI T1,7B20
	ANDCAM T1,CHNSTB(PG)	;RESET ERROR BITS
	JRST ERRCM1
;READ AND WRITE ROUTINE

COMMENT ;
THESE ROUTINES SET UP THE START OF THE COMMAND LIST FOR A
READ OR WRITE. UNICOM(U) POINTS TO THE COMMAND LIST AREA.
COMMANDS ARE BILT FROM THE FRONT (LOW ADDRESS) DOWN AND
DATA (FOR SEEK SET SECTOR ETC) FROM THE BACK UP. AFTER
BPXWRT OR BPXRED IS CALLED, THE DATA IS AS FOLLOWS

	A SEEK COMMAND
	 THE DATA TRANSFER FOR THE SEEK
	A SET SECTOR COMMAND
	 THE DATA TRANSFER FOR THE SET SECTOR
#1	A SEARCH ID =
	 THE DATA TRANSFER FOR THE SEARCH
	A TIC TO THE SEARCH
	THE READ OR WRITE COMMAND
#2	...
	HALTS TO START OF DATA
	...
#3	THE DATA FOR THE SEEK (AND SEARCH ID=)
	(2 WORDS)
	THE DATA FOR THE SET SECTOR COMMAND

REGISTERS P1, P2, P3, AND P4 ARE ALSO SET UP FOR BPXADD AND
BPXFIN.
P1 LEFT HALF POINTS TO THE SEARCH (#1)
P1 RIGHT HALF POINTS TO THE FIRS FREE COMMAND LOCATION (#2+1)

P2 INS THE NUMBER OF WORDS LEFT TO END OF TRACK OR END OF
	CYLINDER WHICHEVER COMES FIRST

P3 LEFT HALF CONTAINS A DISPATCH ADDRESS FOR BPXADD
P3 RIGHT HALF CONTAINS A POINTER TO THE NEXT PLACE TO PUT A
	SEARCH DATA LIST (#3-2)

P4 CONTAINS THE NUMBER OF WORDS LEFT TO END OF CYLINDER
	FOR TRANSFER CONTINUATION AT INTERUPT LEVEL
;

;SET UP P1 AND P3

BPXSET:	HRRZ P1,UNICOM(U)
	HLRO P3,UNICOM(U)	;COUNT AREA
	MOVNS P3
	ADDI P3,-2(P1)
	SETZM UNISVC(U)		;CLEAR SAVE COUNT IN CASE HUNG RESTART
	POPJ P,
BPXWRT:	MOVSI T2,(BYTE (8) WRDMOD,BPXWT)
	JRST BPXGO
BPXRED:	MOVSI T2,(BYTE (8) WRDMOD,BPXRD)
BPXGO:	LDB T3,UNYPUN
	ADD T3,KONBSU(J)
	DPB T3,[POINT 8,T2,23]
	SETZM UNICCC(U)	;O COUNT SO FAR
	SETZM UNICNA(U)	;AND NO CONTINUATION ADDRESS
BPXGO1:	PUSHJ P,BPXSET	;SET UP ARGUMENT
	SUBI P3,1	;SAVE 1 WORD FOR SET SECTOR ARGUMENT
	MOVEM T2,7(P1)	;STORE THE COMMAND
	PUSHJ P,BPXSSO	;SET UP THE SEARCH DATA
	MOVE T3,RECTBL-1(T4)	;T4 IS LEFT WITH RECORD NUMBER
	MOVEM T3,4(P3)	;SET THE SECTOR ADDRESS
	PUSHJ P,BPXSSC	;GENERATE SEEK DATA ALREADY SET
	TLC T2,(BYTE (8) 0,XOR (SETSEC,SEEK))	;CHANGE SEEK TO SET SECTOR
	MOVEM T2,(P1)
	MOVEI T3,4(P3)
	HRLI T3,(BYTE (12) -1)
	MOVEM T3,1(P1)	;NOW HAVE SET SECTOR COMMAND
	ADDI P1,2
	HRLS P1		;SAVE POINTER TO THE SEARCH ID
	PUSHJ P,BPXSSR	;SET UP THE SEARCH ID=
	ADDI P1,2	;POINT AFTER WHERE TRANSFER WILL GO
	SETZM UNISWC(U)	;NO SAVE WORD COUNT
BPBRK1:	HRLI P3,BPXAC2	;SET INITIAL ROUTINE FOR ADD
			;(USED TO BE BPXA1)
	POPJ P,		;FINISHED, P4 AND P2 SET IN BPXSSO

;THIS TABLE IS GENERATED ON THE BASIS OF DATA FROM READ SECTOR

	DEFINE RECGEN (A)
<IRP A <	BYTE (8) A>>

RECTBL:	RECGEN <2,11,17,26,35,44,52,61,70,77,105,114,123>
	RECGEN <132,140,147,156,165>

COMMENT ;
PLANTING BREAKPOINTS IS NOW A PROBLEM. CHANGE BPBRK1 TO
HRLI P3,BPXAC2	SO UNIT IS NOT STARTED AND
CHANGE BPBRK2 TO JFCL SO THAT BPXFIN STARTS UNIT
;
;SET UP SEARCH ADDRESS
;RETURNS T4=RECORD NUMBER(+1)
;	CALL BPXSSO FROM BPXRED, BPXWRT, BPXPOS
;	 ALSO SETS UNICYL(U) P2=WORDS TO END OF TRACK
;	 P4=WORDS TO END OF CYLINDER

BPXSSO:
IFE FTDPAG,<
	MOVE T3,UNIBLK(U)
>
IFN FTDPAG,<
	MOVE T3,UNIPAG(U)
	LSH T3,P2BLSH		;CONVERT TO BLOCKS
>
	IDIVI T3,BPERT		;DIVIDE BY BLOCKS/CYLINDER
	MOVEM T3,UNICYL(U)
	MOVEI P4,BPERT		;FIND BLOCKS TO EOC
	SUB P4,T4
	DPB T3,[POINT 32,(P3),31]	;SET CYL AND 2 BYTES OF 0
	MOVE T3,T4
	IDIVI T3,^D18		;BLOCKS/TRACK
IF2,<PRINTX [BPCMSZ in COMMOD must big enough for at least 18 blocks]>
;*; XP BPCMSZ,^D<18*7+1+3+2+1>	;LOADER will complain if this does not match
;*; ;Above line commented out - can be more than 18 as of P035/B06.
	MOVEI P2,^D18
	SUB P2,T4		;FIND BLOCKS TO END OF TRACK
	CAMLE P2,P4
	MOVE P2,P4	;LAST TRACK ON CYL HAS ONLY 16 BLOCKS
	LSH P2,B2WLSH
	LSH P4,B2WLSH
	ADDI T4,1	;INC RECORD NUMBER
	DPB T3,[POINT 16,1(P3),15]	;SET HEAD NUMBER
	DPB T4,[POINT 8,1(P3),23]	;AND RECORD NUMBER
	SUBI P3,2	;ADJUST DATA POINTER
	POPJ P,

;SET UP A SEEK COMMAND. SOME COMMAND (READ OR WRITE) IS IN
;T2.  P3 POINTS TO THE SEEK ARG

BPXSSC:	TLZ T2,(BYTE (8) 377,377)	;LEAVE DEVICE NUMBER
	TLO T2,(BYTE (8) BYTMOD,SEEK)	;SET SEEK
BPXSC1:	MOVEM T2,(P1)
	MOVSI T3,(BYTE (12) -6)
	HRRI T3,2(P3)
	MOVEM T3,1(P1)
	ADDI P1,2
	POPJ P,
;SET UP A SEARCH ID= AND BRANCH; DATA AT 2(P3)

BPXSSR:	TLZ T2,(BYTE (8) 377,377)	;LEAVE DEVICE NUMBER
	TLO T2,(BYTE (8) STROFA,SRCIDE)	;SET SEARCH AND OFFSET
	MOVEM T2,(P1)
	HRLI T3,(BYTE (12) -5)
	HRRI T3,2(P3)
	MOVEM T3,1(P1)
	HRRZ T3,P1
	TLO T3,TICBIT	;GENERATE TIC TO SEARCH ID=
	MOVEM T3,2(P1)
	ADDI P1,3
	POPJ P,

BPXSDA:	LDB T2,UNYPUN	;GET UNIT NUMBER
	ADD T2,KONBSU(J)	;PLUS BASE UNIT ADDRESS
	ANDI T2,377
	LSH T2,^D12	;TO CORRECT POSITION
	POPJ P,
COMMENT ;
ADD SOMETHING TO THE REQUEST LIST. T2 HAS TRANSFER ADDRESS
T1 HAS COUNT
P1-P4 ARE SET AS DESCRIBED IN BPXRED, BPXWRT. THERE IS
ALWAYS ENOUGHT COMMAND LIST TO TRANSFER THE COUNT LEFT IN P2
THE DISPATCH ADDRESS IS ONE OF THE FOLLOWING

BPXA1	ADD A TRANSFER, UNLESS AN ODD NUMBER (NOT MULT OF 200)
	 WORDS, START UNIT
BPXA4	ADD A TRANSFER BUT SET UP THE SEARCH ID= AND DATA
	 FOR THE SEARCH FIRST. DO NOT START UNIT
BPXAP2	FINISH A PARTIAL WORD COUNT TRANSFER AND START UNIT
BPXAP3	LIKE BPXAP2 BUT DO NOT START UNIT
TRNHD1	NEED A SEEK HEAD (JUST SEEK) BEFORE STARTING
;

BPXADD:
IFN FTDPAG,<;FILIO gave us pages
	LSH T1,P2WLSH	;Word count
	LSH T2,P2WLSH	;Word address
>
	ADDI T2,1	;INCREMENT TRANSFER ADDRESS (FOR SETCA ADD)
BPXAD1:	PUSH P,T2	;HERE TO CONTINUE AT INTERUPT LEVEL
	HLRZ T3,P3
	JRST (T3)	;DISPATCH

BPXA1:	MOVEI T3,200	;MAX TRANSFER WE CAN DO NOW
	PUSHJ P,SETXFR	;SET UP THE TRANSFER
	 JRST BPXAP1	;NOT EVEN BLOCK
	MOVEM T3,-1(P1)	;STORE TRANSFER
	PUSHJ P,STRTUP	;START THE TRANSFER GOING
BPXAC3:	JUMPE P2,TRNCNT	;RAN OUT OF COUNT TO EOT
	JUMPN T1,BPXAC1	;NOT OUT OF COUNT, CONTINUE TRANSFER
BPXAC4:	HRLI P3,BPXA4	;SET NEW DISPATCH ADDRESS
T2POP1:	AOS -1(P)
T2POPJ:	POP P,T2
	POPJ P,

SETXFR:	CAMLE T3,T1	;CHECK WORD COUNT
	MOVE T3,T1	;USE SMALLER
	ADDM T3,UNISWC(U)
	SUB P2,T3
	SUB P4,T3
	MOVE T2,-1(P)
	ADDM T3,-1(P)	;UPDATE TRANSFER ADDRESS
	SUB T1,T3	;ADJUST COUNT
	SETCA T3,
	ROT T3,-^D12
	ADD T3,T2	;T2 HAS HAD 1 ADDED TO IT
	TRNN P2,177	;SEE IF NOW EVEN
	AOS (P)		;IT IS, SKIP RETURN
	POPJ P,		;NON-SKIP IF NOT
STRTUP:	HRRZ T2,UNICOM(U)
	HRLI T2,(15B11)	;START STATUS
	LDB T3,[POINT 8,(T2),23]	;GET UNIT NUMBER
	DPB T3,[POINT 8,T2,7]	;STORE IN COMMAND
	HLRZ T4,KONBMX(J)
	ADD T3,T4
	SUB T3,KONBSU(J)	;SUBTRACT OFF START
	MOVEM T2,(T3)	;AND STORE
	HRRZ T2,KONCHN(J)
	XCT CHNIIE(T2)
	XCT CHNGO(T2)
	POPJ P,

;HERE TO CONTINUE DOING A TRANSFER

SETCMD:	DMOVE T3,2(P3)	;GET SEARCH ARG
	ADDI T4,1B23	;INCREMENT RECORD (WILL NOT OVERFLOW SEE P2 COUNT)
	DMOVEM T3,(P3)
SETCM1:	MOVE T3,P1
	BLT T3,4(P1)	;COPY SEARCH TRANS TIC READ TRANS
	HRRM P3,1(P1)	;UPDATE SEARCH POINTER
	HRRM P1,2(P1)	;AND TIC
	HRLS P1
	ADDI P1,5	;NOW P1 IS SET FOR NEXT TIME
	SUBI P3,2	;AND P3
	POPJ P,

BPXAC1:	PUSHJ P,SETCMD
	CAIGE T1,200	;IS THERE ENOUGH FOR A RECORD
	JRST BPXAC2	;NO, SET UP A TRANSFER ADDRESS
	MOVEI T3,200
	ADDM T3,UNISWC(U)
	ADDM T3,(P)	;UPDATE TRANSFER ADDRESS
	ADDM T3,-1(P1)	;AND IN THE TRANSFER
	SUBI T1,200
	SUBI P2,200
	SUBI P4,200
	JRST BPXAC3	;CONTINUE THE TRANSFER IF MORE CAN GO
BPXA4:	PUSHJ P,SETCMD
BPXAC2:	MOVEI T3,200
	PUSHJ P,SETXFR	;SET UP THE TRANSFER
	 JRST BPXAP4	;LIKE BPXAP1 BUT NO STAT OF UNIT
	MOVEM T3,-1(P1)
	JRST BPXAC3	;CONTINUE TRANSFER

BPXAP1:	HRLI P3,BPXAP2	;BPXAP1 AND BPXAP4 SAME EXCETP
	SKIPA		;FOR DISPATCH ADDRESS
BPXAP4:	HRLI P3,BPXAP3
	TLZ T3,(1B0)	;SET BIT 0 TO SAY CHAINED TRANS
	MOVEM T3,-1(P1)
	JRST T2POP1	;AND RETURN TO USER

BPXAP2:	MOVE T3,P2
	ANDI T3,177	;CAN FINISH THE BLOCK
	PUSHJ P,SETXFR
	 JRST BPXEP2	;NOT YET EVEN, MUST BE END OF REQUEST
	MOVEM T3,(P1)	;STORE TRANSFER WORD
	PUSHJ P,STRTUP
	HRRZS P3	;SINCE STARTUP CALLED (FOR BPBRK2)
	JRST BPXAP5	;COMMON CODE

BPXAP3:	MOVE T3,P2
	ANDI T3,177
	PUSHJ P,SETXFR
	 JRST BPXEP3	;NOT YET EVEN, MUST BE END OF REQUEST
	MOVEM T3,(P1)	;SAVE TRANSFER
BPXAP5:	ADDI P1,1
	HRRZ T3,P3
	SUBI T3,(P1)	;NO SEE HOW MUCH MORE WILL FIT
	IDIVI T3,7	;SINCE WE USED AN EXTRA WORD
	LSH T3,B2WLSH
	CAMGE T3,P2
	MOVE P2,T3	;RESET IF SMALLER NOW
	JUMPE P2,TRNCNT	;RAN OUT OF ROOM
	JUMPN T1,BPXA4	;CONTINUE TRANSFER IF MORE REQUEST
	JRST BPXAC4	;ELSE RESET DISPATCH AND RETURN

BPXEP2:	MOVEM T3,(P1)
	PUSHJ P,STRTUP	;NOT STARTED YET
	SKIPA
BPXEP3:	MOVEM T3,(P1)	;SAVE TRANSFER REQUEST
	ADDI P1,1
	HRLI P3,BPXEP4	;SET TO HALT IF MORE REQUESTS
	MOVEI P2,0	;MAKE IT LOOK LIKE NOT A SHORT TRANSFER
	MOVSI T3,(BYTE (8) IGNLEN)
	IORM T3,-3(P1)	;SINCE THERE IS AN EXTRA TRANSFER WORD
	JRST T2POP1	;AND RETURN

BPXEP4:	STOPCD	;ERROR HALT FROM ABOVE
;Here from BPXADD if P2 has gone to zero, indicating end of track.
;If P4 is also zero, we have hit the end of the cylinder and should stop.
;If there are more words to transfer, we have to switch heads and
;continue on the next track.

TRNCNT:	JUMPE P4,T2POP0	;STOP AT END OF CYLINDER
	HRRZ T3,P3
	LDB P2,[POINT 8,3(P3),23]	;GET LAST RECORD NUMBER
	CAIE P2,^D18	;WAS IT RECORD 18?
	 JRST T2POP0	;NO, COMMAND LIST MUST BE FULL
	SUBI T3,2(P1)	;SEE HOW MUCH MORE WILL FIT
	IDIVI T3,7	;(7 command words to xfer 1 block)
;Make sure we don't attempt to go past end of track if command list is set for
;^D25 blocks.  Fixed in P035/B06
	CAILE	T3,^D18	;More than one track's worth left?
	 MOVEI	T3,^D18	;Yes, limit ourselves so as to notice end of track
	LSH T3,B2WLSH	;# of words that can be handled (assuming full blocks)
	TRZE T1,177	;GET RID OF PARTIAL REQUEST
	 JUMPE T1,T2POP0;PARTIAL REQUEST AND NO MORE, GET LATER
	JUMPE T1,TRNCN1	;NOTHING MORE REQUESTED THIS TIME
	CAMGE P4,T1
	 SKIPA T1,P4	;PICK SMALLER , DO NOT CROSS CYL
	MOVE P4,T1	;BUT MAKE SURE TRANSFER STOPS ON EVEN REC BOUNDARY
	CAMG T1,T3	;WILL REMAINDER OF TRANSFER FIT?
	 JRST TRNHED	;YES
	POP P,UNICNA(U)	;NO, SET TO CONTINUE AT INTERUPT LEVEL
	MOVEM T1,UNICNC(U)
	SKIPA		;DO NOT NEED EXTRA POP (IN T2POP0)
T2POP0:	 POP P,T2
	MOVEI P2,0	;SO IT DOES NOT THINK ITS A SHORT TRANS
	POPJ P,		;RETURN TO USER, NO MORE POSSIBLE THIS TIME

TRNCN1:	CAIGE T3,4_B2WLSH
	 JRST T2POP0	;NOT VERY MUCH SPACE, SAY OUT OF ROOM
	HRLI P3,TRNHD1	;SET NEW TRANSFER ADDRESS
TRNHED:	MOVE P2,T3
	CAMGE P4,P2
	MOVE P2,P4	;NOW HAVE RESET END OF LIST POINTERS
	JUMPE T1,T2POP1	;FROM TRNCN1 ABOVE
TRNHD1:	DMOVE T3,2(P3)
	ADD T4,[BYTE (8) 0,0,-^D17]	;INC HEAD, REC TO 1
	DMOVEM T3,(P3)
	SUBI P3,2
	HLRZ T2,P1
	MOVE T2,3(T2)	;GET SOME COMMAND
	PUSHJ P,BPXSSC	;FOR SET SEEK
	ADDI P3,2	;NEED TO FOR SETCMD
	PUSHJ P,SETCM1	;RESET COMMAND
	JRST BPXAC2	;AND GO FINISH UP
;FINISH UP THE COMMAND LIST

BPXFIN:	TRNN P2,177	;IS THIS TRANSFER EVEN?
	JRST BPXFN1	;YES
	MOVSI T3,(BYTE (8) IGNLEN)	;SET TO IGNORE LENGTH ERR
	IORM T3,-2(P1)	;CAN ONLY BE 1 SHORT TRANSFER WORD
	MOVSI T3,(1B0)
	IORM T3,-1(P1)	;FINISH ON DATA CHAIN
BPXFN1:	MOVSI T3,(BYTE (8) 200)
	MOVEM T3,(P1)	;SET HALT AND DO NOT WAIT FOR CLR STS
	HRLM P1,UNISWC(U)	;SAVE END OF UNIT POINTER
	HLRZ T2,P3	;CHECK ON DISPATCH ADDRESS
BPBRK2:;CAIN T2,BPXAP2	;ALWAYS START UP. (USED TO BE STARTED SOMETIMES.)
	PJRST STRTUP	;HAVE NOT STARTED UNIT YET
	POPJ P,

BPXFN2:	LDB P3,UNYPUN
	HRRZ T2,UNICOM(U)	;BASE ADDRESS OF CMD LST
	PUSHJ P,STRTU	;PUT THE START IN THE BLOCK MUX LIST
	HRRZ T1,KONCHN(J)
	XCT CHNIIE(T1)	;MAKEE SURE INTERUPT ENABLED
	XCT CHNGO(T1)	;SET GO FLAG
	POPJ P,

;POSITION REQUEST

BPXPOS:	PUSHJ P,BPXSET	;SET UP DATA ADDRESSES
	PUSHJ P,BPXSSO	;SET UP SEAR ADDRESS
	PUSHJ P,BPXSDA	;JUST LIKE BPXSSC BUT USE SEEKCY NOT SEEK
	TLO T2,(BYTE (8) BYTMOD,SEEKCY)	;SO CAN TELL AT INT. LEV.
	PUSHJ P,BPXSC1	;SET THE SEEK
	HRLI P3,BPXAP2	;TO FORCE STARTUP
	JRST BPXFN1	;START DEVICE

;RECALIBRATE REQUEST

BPXRCL:	PUSHJ P,BPXSDA	;SET DEVICE ADDRESS
	TLO T2,(BYTE (8) NOXFR,RECAL)
	MOVE P1,UNICOM(U)
	MOVEM T1,(P1)	;STORE
BPXRCC:	HRLI P3,BPXAP2	;TO FORCE STARTUP
	AOJA P1,BPXFN1	;AND START


BPXLTM:	PUSHJ P,BPXSET	;SET UP COMMAND POINTERS
	PUSHJ P,BPXSDA	;SET THE DEVICE ADDRESS
	TLO T2,(BYTE (8) BYTMOD,RRBL)
	MOVEM T2,(P1)
	MOVSI T3,(BYTE (12) -^D24)
	HRRI T3,UNISND(U)	;SENSE DATA HERE
	MOVEM T3,1(P1)
	AOJA P1,BPXRCC	;THIS WILL INCREMENT ONCE MORE, SET STOP, START UNIT, AND EXIT
BPXSTP:	LDB T2,UNYPUN	;GET THE UNIT NUMBER
	HLRZ T3,KONBMX(J)	;AND THE BLOCK MUX ADDRESS
	ADD T2,T3
	LDB T3,[POINT 4,(T2),11]	;GET THE CONTROL CODE
	CAIN T3,17	;AND SEE IF ITS STOP
	POPJ P,		;YES, FORCE UNIT RESTART
	HRRZ T2,KONCHN(J)	;GET A POINTER TO CHANNEL
	MOVE T3,CHNACT(T2)	;COUNT OF INTERUPTS THIS CHANNEL
	CAME T3,UNIACT(U)	;SAME AS FOR UNIT
	JRST BPXST2		;NO, MAYBE MISSED GO OR SOME OTHER
				;UNIT HAS DONE A SEL RESET OR JUST
				;WAITING FOR SOMEONE W`ELSE
	MOVE T3,CHNGO(T2)	;AN APPROPRIATE COMMAND
	TRC T3,7B29		;CONVERT GO TO RESET (SELECTIVE)
	XCT T3			;ISSUE IT
	AOSA CHNACT(T2)		;AND PREVENT ONES FROM OTHER UNITS
				;SEL RESET SHOULD CAUSE CONTROL CHECK ON HUNG UNIT
BPXST2:	MOVEM T3,UNIACT(U)	;SO WE KNOW NEXT TIME THROUGH
	XCT CHNIIE(T2)		;ENABLE AND GO JUST IN CASE
	XCT CHNGO(T2)	;WE MAY HAVE LOST A CONO BIT
	JRST CPOPJ1		;FORCE NO RESTART IN DEV INDEP. CODE

BPXUPA:	HRRZ T3,KONCHN(J)
	LDB T2,[POINT 7,CHNGO(T3),9]	;GET DEVICE
	MOVE T1,[CONI T1]
	DPB T2,[POINT 7,T1,9]
	XCT T1
	JUMPE T1,CPOPJ	;NONE, NO SA-10
	PUSHJ P,RSTSA
	HRRZ T2,KONBSU(J)
	MOVEI T1,UPCHK
	PUSHJ P,DOIT
	JUMPLE T1,CPOPJ	;DID NOT, GIVE UP
	MOVSI T1,SELER
	TDNE T1,(T4)	;IS IT SELECT ERROR?
	POPJ P,		;YES, OFF-LINE
	MOVEI T1,CHNBMX(T3)
	TLO T1,600000
	MOVEM T1,-1(T4)	;RESET LIST BASE POINTER TO BLOCK MULTIPLEXER MODE
	JRST CPOPJ1

UPCHK:	BYTE (8) NOXFR,3	;NO-OP
	0

RSTSA:	MOVE T1,CHNGO(T3)
	HRRI T1,1B18!1B19
	XCT T1
	POPJ P,

DOIT:	MOVE T4,CHNSTB(T3)	;POINTER TO BASE ADR
	DPB T2,[POINT 8,(T1),23]	;SET DEVICE
	TLO T1,(1B1)
	EXCH T1,-1(T4)	;SET CMD
	SETZM (T4)
	PUSH P,T1
IFCPU (KL),<;IF KL, MUST SWEEP CACHE TO GET COMMAND TO MEMORY.
	CSHUNL			;START SWEEP, GET OLD NUMBER IN T1
	CAMN T1,CSUCNT##	;WAIT UNTIL NUMBER INCREMENTS
	 JRST	.-1		;BEFORE SETTING GO FLAG IN CHANNEL.
>;END IFCPU (KL)
	MOVE T1,CHNGO(T3)
	TRZ T1,7
	XCT T1
	MOVEI T1,^D50000
	SKIPN (T4)
	SOJG T1,.-1
	POP P,-1(T4)
	POPJ P,
BPXCPY:	LDB T2,UNYPUN
	MOVN T3,T2
	MOVSI T1,(1B0)	;SET A BIT FLAG THAT UNIT IS IN TEST
	LSH T1,(T3)
	IORM T1,KONCPY(J)
	PUSHJ P,BPXSDA	;SET CAPACITY FLAG
	TLO T2,(BYTE (8) BYTMOD,SEEKCY)
	MOVE T1,UNICOM(U)
	MOVEM T2,(T1)
	MOVE T2,SEK500	;A SEEK TO CYL 500
	MOVEM T2,1(T1)
	MOVSI T2,(BYTE (8) 200)
	MOVEM T2,2(T1)
	MOVEI T1,^D500
	MOVEM T1,UNICYL(U)
	SETZM UNIONC(U)		;SET MESSAGE -1 FOR OFF-LINE
	JRST BPXFN2	;AND START UP

;HERE WHEN WE GET AN INTERUPT FROM THE UNIT IN TEST

BPXCNX:	MOVE T2,UNICYL(U)
	CAIE T2,^D500
	JRST BPXCP2	;PASS 2 DATA
	TRZE P1,ERRCMR	;IS COMMAND REJECT ON?
	TDZA T3,T3	;YES, TYPE 0 MOD I
	MOVEI T3,1	;NO, TYPE 1 MOD II
	DPB T3,UNYUTP
	JUMPN P1,ERROFL	;ANYTHING ELSE IS AN ERROR, CALL IT OFF-LINE
	HRRZ T2,UNICOM(U)
	HRR T1,T2
	HRLI T1,WRT100	;NOW TRY TO WRITE ON RECORD 100
	BLT T1,11(T2)	;PUT IN COMMAND LIST
	ADDM T2,6(T2)	;ADJUST THE TIC
	LDB T1,UNYPUN
	ADD T1,KONBSU(J)	;GENERATE UNIT NUMBER
	DPB T1,[POINT 8,(T2),23]
	ADDI T2,2
	DPB T1,[POINT 8,(T2),23]	;AND IN SEEK
	ADDI T2,2
	DPB T1,[POINT 8,(T2),23]	;AND IN SEARCH ID =
	ADDI T2,3
	DPB T1,[POINT 8,(T2),23]	;AND IN WRITE
	HRRZ T2,UNICOM(U)
	POP P,T1	;CLEAR STACK
	SETZM UNICYL(U)
	HRRZ T3,KONBSU(J)	;GET BASE UNIT ADDRESS
	ADD T3,P3
	DPB T3,[POINT 8,(T2),23]	;AND PUT UNIT NUMBER IN SENSE CMD
	PUSHJ P,STRTU1	;FILL IN BLOCK MX LIST
	JRST DISMIS	;AND GO

;BPXKON DOESN'T NEED TO DO ANYTHING SPECIAL FOR HARD OR SOFT ERRORS.

BPXHRD::POPJ	P,
BPXSFT::POPJ	P,
BPXOFS::POPJ	P,		;NO OFFSET RECOVERY FOR BP UNITS.
SEK500:	BYTE (12) -6 (24) .+1
	BYTE (16) 0,^D500,0

WRT100:	BYTE (8) BYTMOD,SEEKCY
	BYTE (12) -6 (24) SEK0	;JUST SO IT LOOKS LIKE POSITION
	BYTE (8) BYTMOD,SEEK
	BYTE (12) -6 (24) SEK0	;SO IT REALLY POSITIONS
	BYTE (8) BYTMOD+OFFSET,SRCIDE
	BYTE (12) -5 (24) SEK0
	TICBIT,,4
	BYTE (8) BYTMOD,BPXWT
	BYTE (12) -1 (24) SEK0
	BYTE (8) 200

SEK0:	BYTE (16) 0,0,0 (8) 100	;CYL 0 HEAD 0 REC 100

ERROFL:	MOVEI T2,%OFLER	;SAY OFF-LINE BECAUSE OF ERROR
ERROF1:	MOVEM T2,UNIONC(U)
	JRST OFLIN2		;SEN OFF-LINE SIGNAL

BPXCP2:	MOVEI T3,0	;IN CASE WE CAN WRITE
	JUMPE P1,BPXCDN	;FINISHED, NO ERROR
	MOVEI T2,%OFLFM	;BAD FORMAT
	TRNE P1,ERRSRC	;NO RECORD FOUND?
	JRST ERROF1
	TDZ P1,[ERRWPT,,ERRCMR]	;RESET WRITE PROTECT
	JUMPN P1,ERROFL	;IF ANY OTHERS, ITS AN ERROR
	MOVSI T3,(1B1)	;SAY WRITE PROTECT
BPXCDN:	MOVEM T3,UNIONC(U) ;STORE 1B1 FOR ONCDSK
	MOVSI	T2,(0B0+1B8)	;1 block per record when formatted in blocks
	MOVEM	T2,UNICHR##(U)
	LDB T3,UNYUTP
	LDB T2,CPYBPT
	DPB T2,UNYBPT
	LDB T2,CPYBPY
	LSH	T2,-2
	DPB T2,UNYPPY
	LDB T2,CPYBPU
	LSH	T2,-2
	MOVEM T2,UNIPPU(U)
	ANDCAM T1,KONCPY(J)	;RESET TEST BIT
	SETZM UNISNC(U)	;ZERO SENSE COUNT
	JRST POSDIS	;AND GIVE INTERUPT TO FILSER

CPYBPT:	POINT 6,CPYDAT(T3),5	;BLOCKS/TRACK
CPYBPY:	POINT 10,CPYDAT(T3),15	;BLOCKS/CYLINDER
CPYBPU:	POINT 20,CPYDAT(T3),35	;BLOCKS/UNIT

	RADIX 10
CPYDAT:	BYTE (6) 18 (10) BPERT (20) BPERT*404
	BYTE (6) 18 (10) BPERT (20) BPERT*808

	RADIX 8

	$END	(BPX)		;End of BPXKON (BPXLIT: BPXEND:)

   DuE=