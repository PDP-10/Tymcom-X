TITLE	APXKON - DRIVER FOR F3 DISKS (AMPEX & CDC)

	STOPCD(,ENTRY,APXKON)

	ND	FTDPAG,0	;Use UNIBLK instead of UNIPAG
EXTERN BITTBL,APACB
EXTERN UNIPPU,UNYPPY,UNYPUN,UNICYL,UNITWC,UNISBS,UNISBH,SBSIZ
EXTERN KCMOFL,%OFLER,%OFLRS,KONCUA,KCMPOS
EXTERN KCMDTA,KONPTR
EXTERN KCMFUS,KCMERR,KCMRER
EXTERN UNIRCT,UNPDEV,EPT,UNIDES,UNYUTP,UNPFUS,UNPOFL
EXTERN UNYOCV,UNYRTO,UNYRCO,UNYOS,UNIRC1,UNISB,UNICHR,UNIONC
IFE FTDPAG,<EXTERN UNIBLK,UNYBPT>	;Position, blocks per track
IFN FTDPAG,<EXTERN UNIPAG,UNYPPT>	;Position, pages per track

DEFINE DSKOFF<CONO PI,DSKPIF##>
DEFINE DSKON<CONO PI,DSKPIN##>

DSKCHN==APXCHN##	;PIA FOR DISK CONTROLLER

;BIT TABLE, LSB=INDEX 0
ZOT==1
TIBTBL::
REPEAT ^D36,<ZOT
ZOT==ZOT+ZOT>

OPDEF CALL [PUSHJ P,]		;SUBROUTINE ENTRY/EXIT
OPDEF RET [POPJ P,]

RTYCNT==20000			;HOW MANY CYCLES TO WAIT
SUBTTL	Disk geometry
AMPEX==0	; 75 megabyte
CDC==  1	;150 megabyte
NAMPEX==2	;300 megabyte

DRVTYP==CDC	;X930 and X62 both use CDC disks

IFE DRVTYP-CDC,<  ;150 megabyte
PPT==^D8		;Sectors (pages) per track
TPC==^D10		;Tracks per cylinder (# of heads)
CPU==^D823-^D10		;Cylinders per unit (minus 10 maintainence cylinders)
USPR==^D17300		;Microseconds per revoluntion
>
IFE DRVTYP-AMPEX,< ;Old 75 megabyte
PPT==^D8		;Sectors (pages) per track
TPC==^D5		;Tracks per cylinder (# of heads)
CPU==^D815-^D5		;Cylinders per unit (minus 5 for maintainence)
USPR==^D17300		;Microseconds per revoluntion
>
IFE DRVTYP-NAMPEX,< ;New 300 megabyte
PPT==^D?		;SECTORS PER TRACK
TPC==^D?		;TRACKS PER CYL (NUMBER OF HEADS)
CPU==^D???-^D?		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
USPR==^D?		;Microseconds per revoluntion
>
PPC==PPT*TPC		;Pages per cylinder
PPU==PPC*CPU		;Pages per unit
BPT==PPT*4		;Blocks per track
BPC==PPC*4		;Blocks per cylinder

SUBTTL	DISK IOTS AND REGISTER BIT NAMES.
OPDEF	RCMD	[715000000000]	;READ DISK COMMAND REGISTER
	SUNT==1B0		;SELECTED UNIT NOT THERE (SELECT ERROR)
	SUWP==1B1		;SELECTED UNIT WRITE PROTECT
	SUNR==1B2		;SELECTED UNIT NOT READY
;---
	SUOC==1B3		;SELECTED UNIT ON CYLINDER
				; SHOULD ALWAYS BE SET EXCEPT AFTER RECAL UNTIL HEADS ALIGN
	SUSE==1B4		;SELECTED UNIT SEEK ERROR (DETECTED BY DRIVE)
				; RECAL MANDATORY AFTER THIS ERROR, FAULT CLEAR WILL NOT TURN THIS OFF.
	SUF==1B5		;SELECTED UNIT FAULT (DETECTED BY DRIVE)
;---
	SUA==1B6		;SELECTED UNIT ATTENTION
				; SET BY LEADING EDGE OF ON CYLINDER (BIT 3)
	HDECC==1B7		;ECC ERROR ON HEADER
	CI==1B8			;CONTROL IDLE (ONLY IF NO DATA XFER AND NO SEEKS OR RECALS GOING)
;---
	SECC==1B9		;SOFT ECC ERROR (NOT YET IMPLEMENTED IN F3 MICROCODE)
	HECC==1B10		;ECC UNRECOVERABLE ERROR

;FOLLOWING BITS ARE DETECTED BY CONTROLLER:
	ROE==1B11		;READ OVERRUN ERROR
;---
	WOE==1B12		;WRITE OVERRUN ERROR
	SOE==1B13		;SECTOR OVERRUN ERROR
	IPE==1B14		;INTERNAL PARITY ERROR (ONLY VALID IF AE, BIT 28, IS ZERO)
;---

;FOLLOWING ARE FROM LAST LCMD

	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH CF AND FC)
;---
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
;	19 UNUSED
;	20 UNUSED
;---
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
;---
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
;---
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)

;END OF FROM RCMD BITS
	AE==1B28		;ANY  ERROR (EXCEPT IPE, BIT 14)
	AA==1B29		;ANY UNIT ATTENTION
;---

;FROM LCMD
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE

	NA==1B31		;NOT ACTIVE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
;---
;BITS 33, 34 NOT IMPLEMENTED.

	MPE==1B35		;MEMORY PARITY ERROR
;---
OPDEF	RMA	[716000000000]	;READ DISK MEMORY ADDRESS
OPDEF	RDA	[717000000000]	;READ DISK ADDRESS (IN PAGES)
	AMSUNI==^D3		;SIZE OF UNIT BYTE
	AMPUNI==^D6		;RIGHTMOST BIT
	ROTUNI==-<AMPUNI+1>	;NUMBER OF PLACES TO ROTATE TO GET UNIT FIELD IN
	AMSCYL==^D12
	AMPCYL==^D19
	AMSTRK==^D8
	AMPTRK==^D27
	AMSSEC==^D8
	AMPSEC==^D35
	LDAMSK==034000,,177400	;MASK FOR $0% AND $0O IN DDT
OPDEF	RECC	[720000000000]	;READ DISK CONTROL REGISTER
OPDEF	LCMD	[721000000000]	;LOAD DISK COMMAND REGISTER
	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH CF AND FC)
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
OPDEF	LMA	[722000000000]	;LOAD DISK MEMORY ADDRESS
OPDEF	LDA	[723000000000]	;LOAD DISK ADDRESS
	SU==1B7			;SELECT UNIT
				;MUST BE CLEARED AND SET TO SELECT A UNIT.
OPDEF	LECC	[724000000000]	;CLEARS ECC LOGIC, STARTS AND INITS CONTROL.
	SC==1			;START CONTROL
	IC==2			;INIT CONTROL (SEND BEFORE STARTING CMD)
OPDEF	DCONO	[740000000000]	;CONO TO DISK CONTROL TO SET PI ASSIGNMENT
	ATNENB==20		;ENABLE FOR ATTENTION BIT
OPDEF	DCONI	[741000000000]	;CONI FROM DISK CONTROL OPCODE
	DIDLE==10		;SET IF CONTROL IS IDLE
	DPIA==7B35		;PI ASSIGNMENT.
				;NOTE THAT NONZERO PI ASSIGNMENT SETS DIE (SEE LCMD)
OPDEF	DCONSO	[742000000000]	;DISK CONSO
OPDEF	DCONSZ	[743000000000]	;DISK CONSZ
SUBTTL	BITS FOR FAKED UP CONI

ERRCMR==1B30			;COMMAND REJECT (WRITE LOCK, ETC)
ERRBOP==1B29			;BUS OUT PARITY
ERRBIP==1B28	;BUS IN PARITY
ERRUNK==1B26	;UNKNOWN ERROR (NO BITS CHECK BUT UNIT CHECK)
ERROVR==1B25	;OVERRUN
ERRPAR==1B23	;PARITY ERROR
ERRINV==1B21	;INVALID TRACK FORMAT
ERRRCV==1B20	;RECOVERABLE DATA CHECK
ERRDTA==1B19	;UNRECOVERABLE DATA CHECK
ERRCNT==1B18	;COUNT ERROR (CHANNEL TERMINATION)
ERRATN==1B16	;ATTENTION FLAG
ERREQP==1B14	;PERMANENT EQUIPMENT CHECK
ERREQC==1B13	;EQUIPMENT CHECK
ERRLEN==1B12	;LENGTH ERROR
ERRCON==1B11	;CONTROL ERROR
ERRSEL==1B10	;SELECT ERROR
ERRWPT==1B9	;WRITE PROTECT ERROR COMMAND REJECT ALSO ON
SUBTTL	ROUTINE TO START A FUNCTION UP ON CONTROL

DEFINE KONSTR(LOC)<
	LECC	[IC]		;INIT CONTROL
	LCMD	LOC		;DO THE COMMAND
	LECC	[SC]		;START CONTROLLER
>;END KONSTR MACRO DEFINITION



CLRKON:	DCONO	0		;MAKE SURE NO INTERRUPT GENERATED FROM THIS
	KONSTR(<[CF+FC]>)	;COMMAND FUNCTION FAULT CLEAR
WATKON:	MOVEI	T2,RTYCNT	;NUMBER OF TIMES TO WAIT
	RCMD	T1
	TLNN	T1,(CI)		;CONTLOL IDLE YET?
	SOJG	T2,.-2		;NO
	JUMPG	T2,CPOPJ1	;JUMP IF IT WENT IDLE
	POPJ	P,		;DIDN'T.

;ROUTINE TO START NEXT TRANSFER.
;DON'T INDEX BY J HERE TO SAVE TIME (ONLY 60US, THIS ROUTINE TAKES 36 US
; WITH (J)!). IF HAVE OTHER KONTROLLERS LATER, MUST FIGURE OUT WHAT TO DO -
; PROBABLY WILL HAVE TO HAVE 1 ROUTINE FOR EACH KONTROLLER.
;UNIT MUST ALREADY BE SELECTED.

DEFINE NXTXFR <
	LMA	@KONNLM+APACB	;LOAD MEM ADDRESS
	LDA	KONNLD+APACB
	LDA	KONNL1+APACB	;NOW WITH SU BIT SET
	KONSTR(<KONNCM+APACB>)		;START UP TRANSFER
	DCONO	DSKCHN		;
>
SUBTTL	INTERFACE TO FILIO AND FRIENDS.

;INITIALIZE UNIT AND SET PARAMETERS IN UDB.

APXCPY::MOVSI	T3,(1B0+4B8)	;Set the sign bit, 4 blocks per record
	MOVEM	T3,UNICHR(U)	;Formatted in pages
	MOVEI	T3,2
	DPB	T3,UNYUTP	;2 for CDC disks formatted in pages
	MOVEI	T1,PPC
	DPB	T1,UNYPPY	;Pages per cylinder
	MOVEI	T1,PPU
	MOVEM	T1,UNIPPU(U)	;Pages per unit
	MOVEI	T1,BPT
	DPB	T1,UNYBPT	;Blocks per track
	LDB	T1,UNYPUN	;SELECT DRIVE
	ROT	T1,ROTUNI
	LDA	T1		;SELECT DRIVE
	TLO	T1,(<SU>)
	LDA	T1
	PUSHJ	P,CLRKON	;CLEAR CONTROL
	  JFCL			;IGNORE IF COULDN'T DO IT SO WE CAN GET ERROR STATUS.
	RCMD	T1		;GET STATUS
	JUMPL	T1,CPYOFL	;JUMP IF SELECT ERROR.
	MOVSI	T2,200000	;SET/CLEAR WRITE LOCK STATUS
	TLNN	T1,(<SUWP>)
	 MOVEI	T2,0
	MOVEM	T2,UNIONC(U)	;Set 1B1 if write locked
	TLNE	T1,(SUF+ROE+WOE+SOE) ;ANY WEIRD ERROR BITS?
	 JRST	CPYERR		;YES, LET ONCE TELL POOR GUY
	KONSTR(<[CF+FC+RECAL]>)
	PUSHJ	P,WATKON	;DO IT
	  JRST	CPYERR		;COULD NOT, STORE ERROR STATUS IN ERRCPY
	MOVSI	T2,1		;WAIT A LONG TIME FOR RECAL TO FINISH
	RCMD	T1
	TRNN	T1,NA
	 SOJG	T2,.-2
	JUMPE	T2,CPYERR
	TLNE	T1,(SUSE+SUF+ROE+WOE+SOE)
	 JRST	CPYERR
	LDB	T1,UNYPUN
	MOVE	T1,BITTBL(T1)
	JRST	FILINT##

CPYERR:	MOVEM	T1,ERRCPY#	;STORE FOR DIAGNOSTIC PURPOSES
	SKIPA	T1,[%OFLER]	;Offline - error
CPYOFL:	 MOVEI	T1,%OFLRS	;Offline - no response
	MOVEM	T1,UNIONC(U)
	MOVSI	T1,KCMOFL
	JRST	FILINT##
;SKIP IF CONTROLLER UP, SINGLE RETURN IF NOT.
APXUPA::
CPOPJ1:	AOS (P)
CPOPJ:	RET

;STOP HUNG CONTROLLER.  SINGLE RETURN IF OPERATION WASN'T
; BE RESTARTED, SKIP IF IT WAS.  CURRENTLY, ALWAYS SINGLE RETURNS.
APXSTP::PUSH	P,T1		;MUST PRESERVE T1
	PUSHJ	P,CLRKON
	  JFCL
	POP	P,T1
	SETZM	KONCUA(J)	;INIDICATE THAT NO XFER GOING NOW.
	SETZM	KONXFR(J)	;CLEAR OUT FLAG THAT WOULD START A TRANSFER
				; ON NEXT DISK INTERRUPT
	POPJ	P,

;ISSUE RECALIBRATE (SAME EFFECT AS SEEK TO
; CYLINDER 0, BUT DOESN'T USE SEEK CIRCUITRY). NON-SKIP RETURN ALWAYS.
APXRCL::DCONO	0		;MAKE SURE NO INTERRUPT COMES IN FOR THIS
				;COMMAND FINISH.
	KONSTR(<[CF+FC+RECAL]>)
	PUSHJ	P,WATKON	;DO COMMAND, WAIT FOR CONTROL TO RETURN
				;THEN DRIVE IS STARTING TO RECAL.
				;FUNCTIONS DONE TO CONTROL AFTER THIS WILL WAIT TILL RECAL IS FINISHED.
	  JFCL			;IGNORE
	LDB	P2,UNYPUN	;GET UNIT NUMBER
	MOVE	P2,BITTBL(P2)	;GET BIT
	IORB	P2,SEKWRD	;RECAL SAME AS SEEK
	PJRST	SEKXIT		;GO TAKE CARE OF SEEKS WHOSE INTERRUPTS
				; WERE LOST AS A RESULT OF STARTING CONTROL

;Perform latency calculation for disk page number specified in T1.
; The latency is the time required for the disk to rotate until the requested
; page is under the heads.  The number of microseconds is returned in T1.

APXLTM::RDA	T2		;Try to get a constant value
	RDA	T3		;Read disk address
	RDA	T4
	CAMN	T2,T3
	 MOVE	T4,T3
IFE FTDPAG,<;T1 has block number to check for latency time
	LSH	T4,P2BLSH	;Convert RDA to block number
	IDIVI	T1,BPC		;BLOCK WITHIN CYLINDER
	IDIVI	T2,BPT		;BLOCK WITHIN TRACK.
	SUBI	T3,(T4)		;DELTA BLOCKS
	SKIPGE	T3
	 ADDI	T3,BPT		;HAVE TO GO AROUND AGAIN.
>
IFN FTDPAG,<;T1 has page number to check for latency time
	IDIVI	T1,PPC		;Page within cylinder
	IDIVI	T2,PPT		;Page within track
	SUBI	T3,(T4)		;Delta pages
	SKIPGE	T3
	 ADD	T3,PPT		;Have to go around again
>
	IMULI	T3,USPR		;Microseconds per revolution
	MOVE	T1,T3
	RET			;Return time in T1

;ENTER OFFSET MODE.  NOT YET IMPLEMENTED.
APXOFS::SETZ T1,		;ALWAYS CLEAR OFFSET MODE FOR NOW.
	DPB T1,UNYOS
	RET


;THE NEXT THREE ROUTINES FORM THE BODY OF THE TRANSFER CODE.
;RED,WRT INITIALIZE; ADD ATTEMPTS TO CONSOLIDATE MULTIPLE
; TRANSFERS IN THE SAME DIRECTION TO OR FROM THE DISK;
; FIN COMPLETES THE WORK FOR THE GROUP OF TRANSFERS.
;THE TRANSFER WILL NOT CROSS A CYLINDER BOUNDARY.
;THE ACS P1-P4 ARE PRESERVED BY FILIO OVER THE PSEUDO CO-ROUTINE CALLS,
; AND ARE USED AS FOLLOWS:
;   P1/ NUMBER OF PAGES TO END OF CYLINDER
;   P2/ AOBJN POINTER TO MEMORY TABLE

;APXRED/APXWRT. CALL WITH J/KDB, U/UDB, UNIBLK(U)/BLOCK NUMBER

EXTERNAL BLMSIZ,KONNLM,KONNCM,KONNLD,KONNL1,KONBLM,KONNRM
EXTERNAL KONXFR,KONLRC,KONLRM,KONLRD

APXWRT::SKIPA	T1,[WRITE]
APXRED::MOVEI	T1,READ		;READ COMMAND
	MOVEM	T1,KONNCM(J)	;SETUP NEXT COMMAND TO DO.
	SETZ	T1,		;GET READY TO CLEAR AND TEST KONCUA
	EXCH	T1,KONCUA(J)	;MAKE SURE TRANSFER NOT ALREADY GOING
	SKIPE	T1		;IF WAS ALREADY SET,
	 AOS	DBLXFR		;INCREMENT COUNT - SOMETIMES THIS IS OK
				; (WHEN WE TRY TO RESTART AN XFER) BUT
				; WANT TO KNOW FOR DEBUGGING TOO.

	MOVE	T1,[DCONSO DIDLE] ;INSTRUCTION TO PUT INTO APXINT FOR XFERS
	MOVEM	T1,APXINT	;FOR SPEED.
	MOVEI	P2,KONBLM(J)	;GET ADDRESS
	HRLI	P2,-BLMSIZ	;MAKE AOBJN POINTER
	HRRZM	P2,KONNLM(J)	;INIT THE POINTER TO LMA TABLE.
IFE FTDPAG,<;SETNLD uses block #
	MOVE	T1,UNIBLK(U)	;DISK ADR OF TRANSFER START.
>
IFN FTDPAG,<;SETNLD uses page #
	MOVE	T1,UNIPAG(U)	;Page number on disk where transfer starts
>
	PUSHJ	P,SETNLD	;SET KONNLD, KONNL1, RETURN CYL IN T1
	MOVEM	T1,UNICYL(U)	;REMEMBER CYLINDER WE ARE WORKING ON. DON'T
				; LEAVE IT.
	AOS	P1,T1		;GET NEXT CYLINDER NUMBER
IFE FTDPAG,<;FILIO gave us a block #
	IMULI	P1,BPC		;P1/BLOCK NUMBER OF FIRST BLOCK ON NEXT CYL
	SUB	P1,UNIBLK(U)	;GET MAX NUMBER OF BLOCKS WE CAN DO
	LSH	P1,B2PLSH	;GET MAX NUMBER OF PAGES WE ARE ALLOWED
>
IFN FTDPAG,<;FILIO gave us a page #
	IMULI	P1,PPC		;P1/Page number of first page on next cyl
	SUB	P1,UNIPAG(U)	;Get max number of pages we can do
>				;(NOT SUPPOSED TO GO PAST END OF CYLINDER)
	PUSHJ	P,CLRKON	;MAKE SURE CONTROLLER IS RESET.
	  JFCL			;IGNORE
	RET			;P1/Pages to EOC, P2/AOBJN pointer to table

;CALLER WANTS TO TRANSFER T1 WORDS TO ADDR IN T2.
;CALLER MAY THINK HE'S DOING LESS, BUT APXKON WILL ALWAYS
; XFER 1000 WORDS STARTING AT EVEN PAGE ADDRESS.
;NON-SKIP RETURN IF CANNOT ADD ANY MORE TRANSFERS NOW BECAUSE OF EOC OR
; OUT OF NLM TABLE. IF FIRST CALL TO APXADD NON-SKIPS, GUARANTEED TO
; HAVE STARTED AT LEAST ONE PAGE TRANSFER.

;J points to Kontroller's KDB, U points to unit's UDB

IFE FTDPAG,<;T1 has block number, T2 has word address
APXADD::ADDI	T1,777		;ROUND UP TO NEAREST PAGE, ALL XFERS = 1000 WORDS
	MOVE	P4,T1		;GET COUNT IN WORDS IN P4
	LSH	P4,W2PLSH	;CONVERT TO PAGES
>
IFN FTDPAG,<;T1 has # of pages to transfer, T2 has memory page # (P034/P05)
APXADD::MOVE	P4,T1		;Pages to transfer
	LSH	T2,P2WLSH	;Word address where transfer starts
>
APXAD0:	TRZ	T2,777		;MAKE SURE ALWAYS START ON A PAGE BOUNARY
	MOVEM	T2,(P2)		;SET MEMORY ADDRESS FOR TRANSFER.
	SKIPE	KONCUA(J)	;HAVE WE STARTED XFER YET?
	 JRST	APXAD1		;YES.
	NXTXFR			;START TRANSFER OF THE FIRST PAGE.
				; DSK PI OFF SO DON'T WORRY ABOUT IRPS
	SETZM	KONXFR(J)	;INDICATE NO OTHER XFER TO START
	MOVE	T1,@KONNLM(J)	;GET MEM ADDR AGAIN
	ADD	T1,[777774,,1000] ;GET WHAT RMA SHOULD RETURN NEXT TIME
	MOVEM	T1,KONNRM(J)	;NEXT RMA VALUE.
	AOS	KONNLM(J)	;MUST POINT TO NEXT LMA TO DO AT INTERRUPT LEVEL.

	HRRZM	U,KONCUA(J)	;INDICATE XFER IS GOING NOW.
IFE FTDPAG,<;SETNLD uses block #
	MOVE	T1,UNIBLK(U)	;GET CURRENT BLOCK NUMBER
	ADDI	T1,4		;COMPUTE LDA FOR NEXT PAGE
>
IFN FTDPAG,<;SETNLD uses page #
	MOVE	T1,UNIPAG(U)	;Get current page number
	ADDI	T1,1		;Compute LDA for next page
>
	PUSHJ	P,SETNLD	;SET KONNLD, KONNL1
	JRST	APXAD2


APXAD1:	SETOM	KONXFR(J)	;INDICATE MUST START ANOTHER XFER AFTER CURRENT
APXAD2:	AOBJP	P2,CPOPJ	;JUMP IF OUT OF NLM TABLE.
				; DO THIS FIRST SO ON NON-SKIP P2 ALWAYS
				; POINTS TO LOCATION OF A ZERO WORD.
	SOJLE	P1,CPOPJ	;IF PAST EOC, GIVE NON-SKIP RETURN.
	SOJLE	P4,CPOPJ1	;JUMP IF DONE WITH COUNT THIS CALL
	MOVEI	T2,1000		;1000 + LAST MEM ADDRES IS
	ADD	T2,-1(P2)		;GET ADDRESS IN T2
	JRST	APXAD0
	



;HERE TO FINISH UP TRANSFER STUFF. P2 POINTS TO NEXT FREE LMA TABLE ENTRY,
; POSSIBLY THE EXTRA ONE THAT IS RESERVED TO BE ZERO IF REST OF LIST
; IS FULL.
APXFIN::SETZM	(P2)
	POPJ	P,		;XFER ALREADY STARTED.

;HERE TO START A POSITION. CALLED EITHER AT DISK INTERRUPT LEVEL
; OR WITH DISK PI OFF.
APXPOS::SKIPE	KONCUA(J)	;MAKE SURE CONTROL IS IDLE
	STOPCD			;BUT SOMEWHERE
	MOVE	T1,[JRST APSINT] ;PLACE TO GO FOR SEEKS
	MOVEM	T1,APXINT	;OVERWRITE PREVIOUS INSTRUCTION
	LDB	T3,UNYPUN	;GET UNIT NUMBER
	MOVE	T3,BITTBL(T3)	;GET BIT
	IORM	T3,SEKWRD	;TURN ON FLAG SAYING SEEK IN PROGRESS.
				; (DISK PI OFF OR AT PI LEVEL SO NO
				; ONE CAN SNEAK IN AND FINISH.)
IFE FTDPAG,<;SETNLD uses block #
	MOVE	T1,UNIBLK(U)	;COMPUTE LDA
>
IFN FTDPAG,<;SETNLD uses page #
	MOVE	T1,UNIPAG(U)	;COMPUTE LDA
>
	PUSHJ	P,SETNLD	;AND SETUP KONNLD, KONNL1
	MOVEM	T1,UNICYL(U)	;SET CYLINDER ALSO
	LDA	KONNLD(J)
	LDA	KONNL1(J)	;SELECT UNIT AND SET DISK ADDRESS.
	PUSHJ	P,CLRKON	;CLEAR CONTROLLER
	  JFCL
	WRPI	LI.PIF		;TURN OFF PI SYSTEM
	KONSTR	(<[READ]>)	;START A READ
	MOVEI	T1,^D15*4	;WAIT AT LEAST 15 USECS
	SOJG	T1,.
	LECC	[IC]		;BLAST CONTROL, IT STOPS THE XFER
				;BIT LEAVES A SEEK GOING
	WRPI	LI.PIN
SEKXIT:	MOVE	P2,SEKWRD	;GET SEEK BIT TABLE
	PUSHJ	P,SEKINT	;PROCESS ANY SEEKS WHICH HAVE COMPLETED,
				; SINCE BLASTING CONTROL WILL CAUSE US
				; TO LOSE ATTENTION INTERRUPT.
	JUMPN	T1,SEKXT1	;IF SEEKS HAVE COMPLETED, CAUSE INTERRUPT
	DCONO	ATNENB+DSKCHN	;NONE COMPLETE, ENABLE FOR THE ONE WE STARTED
	POPJ	P,		;AND RETURN
SEKXT1:	IORM	T1,SEKWRD	;SEKINT TURNED THEM OFF, TURN BACK ON FOR INTERRUPT
				; LEVEL
	DCONO	DSKCHN		;THIS SHOULD CAUSE INTERRUPT FROM STARTING
				; AND ABORTING THE  XFER (I HOPE)
	POPJ	P,		;AND RETURN. USED TO CALL FILINT, BUT
				;OVERFLOWED STACK BECAUSE FILINT CALLED US
				;BACK.
				;WILL PROCESS FINISHED SEEKS AT INTERRUPT LEVEL.
;INTERRUPT HANDLER.
;ONLY HAVE 60US TO START UP NEXT TRANSFER - ONLY 60US OF TIME
; BETWEEN LAST PAGE TRANSFERRED AND NEXT ONE COMING UP UNDER THE HEADS
; SO START NEXT TRANSFER UP IN KONNLM LIST IMMEDIATELY - NEXT LDA DATA
; COMPUTED BEFOREHAND.
;IF UNIT WAS TRANSFERRING, IT IS SELECTED SO THAT RCMD WILL GET ITS STATUS.

AP0INT::
APXINT::JRST	.-.		;FILLED IN WITH DCONSO OR JRST APSINT
	JRST	.		;FOR LINKING INTERRUPTS IN
				;DON'T BOTHER WITH DCONO 0 YET, MIGHT START AN XFER.

	RCMD	KONLRC+APACB	;SAVE LAST RCMD
	RMA	KONLRM+APACB	;AND RMA IN CASE SOMETHING WENT WRONG.
	RDA	KONLRD+APACB	;IN CASE WE GET ERROR
	SKIPN	KONXFR+APACB	;IF NON ZERO, MUST START ANOTHER XFER.
	JRST	APXXFL		;THIS WAS THE LAST ONE.
	NXTXFR			;MACRO CALL TO START NEXT TRANSFER.


;HERE IF NO NEXT TRANSFER TO START.

APXXFL:	JSR	APXSAV##	;SAVE ALL ACS NOW
	MOVEI	J,APACBIPN	U,KONCUA(J)	;BETTER BE SETUP
	 STOPCD			;NOT
	MOVE	T1,KONLRC(J)	;GET LAST RCMD VALUE
	TRNN	T1,NA		;WAS UNIT FINISHED?
	 JRST	APXINE		;NO, SPURIOUS INTERRUPT. SINCE WE MAY HAVE
				;STARTED NEXT, BLAST KONTROL AND CALL IT AN ERROR.
	TLNN	T1,(SUOC)	;MAKE SURE ITS ON CYLINDER, IF NOT ERROR.
	 JRST	APXINE		;GO BLAST POSSIBLE CURRENT XFER.
	TRNN	T1,AE		;IF ANY ERROR OR
	TLNE	T1,(IPE)	;IPE (ONLY VALID IF AE OFF)
	 JRST	APXINE		;GO SHUT DOWN TRANSFERS.
	MOVE	T1,KONLRM(J)	;GET RMA VALUE FOR LAST XFER
	CAME	T1,KONNRM(J)	;IS IT WHAT IS SUPPOSED TO BE?
	 JRST	APXINE		;NO, GO DO ERROR.


	SKIPN	KONXFR(J)	;THIS THE LAST TRANSFER?
	 JRST	APXIN0		;YES, GO PROCESS END OF XFER CHAIN.
	AOS	T1,KONNLM(J)	;STEP TO NEXT THING TO DO IN LIST
	MOVE	T2,-1(T1)	;GET LMA DATA OF THE CURRENT XFER JUST STARTED
	ADD	T2,[777774,,1000] ;WHAT NEXT RMA HAD BETTER LOOK LIKE
	MOVEM	T2,KONNRM(J)	;SAVE FOR NEXT INTERRUPT
	SKIPN	(T1)		;ANOTHER XFER AFTER THIS ONE?
	 JRST	APXECN		;NO, END OF CHAIN, SWITCH INTERRUPT INSTRUCTION.
	SUBI	T1,KONBLM(J)	;GET NUMBER OF PAGES PAST FIRST WE ARE
IFE FTDPAG,<;SETNLD uses block #
	LSH	T1,P2BLSH	;CONVERT TO BLOCKS
	ADD	T1,UNIBLK(U)
>
IFN FTDPAG,<;SETNLD uses page #
	ADD	T1,UNIPAG(U)
>
	JRST	SETNLD		;GO SET KONNLD AND KONNL1 FROM BLOCK IN T1

APXECN:	SETZM	KONXFR(J)	;INDICATE NO XFER TO START AFTER NEXT ONE.
	POPJ	P,		;RETURN FROM THIS INTERRUPT.

APXINE:	PUSHJ	P,CLRKON	;BLAST THE NEXT XFER WE STARTED IF ANY
	SETZM	@KONNLM(J)	;ERROR, MAKE SURE WE DON'T CONTINUE THE LIST
APXIN0:	MOVE	T1,[JRST APSINT]
	MOVEM	T1,APXINT	;MAKE SURE SPURIOUS/UNEXPECTED INTERRUPTS GO
	DCONO	0		;TURN OFF IDLE FLAG SO WE DON'T CATCH INTERRUPTS
				; BELONGING TO OTHERS ON THE PI CHANNEL.
	JRST	APXIN2		;WHERE THEY CAN DO NO HARM.

;HERE IF NO TRANSFER GOING - PROBABLY SEEK INTERRUPT.
APSINT:	DCONSO	DIDLE		;INTERRUPTING?
	 JRST	APXINT+1	;NO, ANOTHER DEVICE
	DCONO	0		;TURN OFF INTERRUPT.
	JSR	APXSAV##	;SET EVERYTHING UP
	MOVEI	J,APACB
APXIN2:	SETZB	T1,T2		;T1 HAS FILIO COMM WORD, T2/CONI WORD
	SKIPE	P2,SEKWRD	;IF OUTSTANDING SEEKS GOING,
	 PUSHJ	P,SEKINT	;CHECK FOR COMPLETION.
	SKIPN	U,KONCUA(J)
	 JRST	INTDIS		;IGNORE IT
	PUSHJ	P,SDA		;SELECT THE UNIT
	MOVE	T4,KONLRC(J)	;GET RCMD DATA OF LAST XFER TO INTERRUPT
	TRNN	T4,NA		;TRANSFER COMPLETE IF NOT ACTIVE IS ON.
	 JRST	INTDIS		;STILL GOING, CALL FILIO IF HAVE TO.
;HERE TO ACCOUNT FOR TRANSFER
;UNIT WHICH TRANSFERRED IS NOW SELECTED.
;PRINTX MUST DO SOMETHING FOR MPE - POOLE SAYS ITS DISCONNECTED
	TLCN	T4,(SUOC)	;IF NOT ON CYLINDER, SOMETHING IS WRONG.
	 TRO	T4,AE		;COMPLEMENT SO CONERR WILL SEE ITS AN ERROR, SET AE

	TRNN	T4,AE		;ANY ERROR?
	TLNE	T4,(IPE)	;INTERNAL PARITY ERROR? (DATA PATH PROBLEM)
	 CALL	CONERR		;SET KCMERR IN T1
	MOVE	T3,KONLRD(J)	;GET LAST RDA FOR XFER JUST INTERRUPTED.

;NOW COMPUTE HOW MANY PAGES WERE TRANSFERRED. NEVER TELL FILIO THAT
; LESS THAN A COMPLETE PAGE WAS TRANSFERRED. ALWAYS SAY THAT ALL 4 BLOCKS
; WERE DONE, AND FILIO WILL TRY TO RETRY THE LAST BLOCK, BUT WE
; WILL IGNORE LOW ORDER 2 BITS AND RETRANSFER THE WHOLE PAGE.
; KONNLM WILL POINT TO NEXT TRANSFER WE WERE TO DO, SO NUMBER
; OF PAGES TRANSFERRED WILL BE C(KONNLM)-KONBLM.

	MOVE	M,KONNLM(J)	;GET POINTER TO 1 PAST LAST MEM ADDR WE JUST DID
	SUBI	M,KONBLM(J)	;GET NUMBER OF PAGES WE DID
	CAMLE	M,XFRMAX	;COLLECT MAX NUMBER OF PAGES WE DID AT ONCE.
	 MOVEM	M,XFRMAX	;TO SEE IF WE'RE EXCERCISING THIS CODE.
IFE FTDPAG,<;Tell FILINT the number of blocks transfered
	LSH	M,P2BLSH	;CONVERT TO BLOCKS. ALWAYS SAY DID ALL 4 BLOCKS
>
	HRR	T1,M		;PUT NUMBER OF BLOCKS WE DID IN RH(T1)
	MOVE	T4,KONLRM(J)	;GET RMA OF LAST XFER TO INTERRUPT
	TLZ	T4,777774	;CLEAR UNUSED BITS (THEY WILL BE ONES)
	MOVE	W,KONNLM(J)	;GET ADDRESS+1 OF MEM ADDRESS OF LAST XFER.
	SUB	T4,-1(W)	;SUBTRACT OFF BEGINNING ADDRESS.
	CAIE	T4,1000		;BETTER HAVE XFERRED ONE AND ONLY ONE PAGE
	 PUSHJ	P,CNTERR	;HANDLE IT (SET RETRY PATTERN ERROR BIT IN T1)
	TLO	T1,KCMDTA	;FLAG THIS AS A DATA TRANSFER
	SETZM	KONCUA(J)	;REMEMBER CONTROLLER NO LONGER BUSY
INTDIS:	SKIPE	T1		;IF ANYTHING IN COMM WORD
	 PUSHJ	P,FILINT##	;CALL FILIO
	SKIPN	KONCUA(J)	;IF NO CURRENT TRANSFER GOING AND
	SKIPN	SEKWRD		;HAVE SEEKS GOING,
	 POPJ	P,		;XFER GOING OR NO SEEKS
	DCONO	ATNENB+DSKCHN	;THEN ENABLE FOR ATTENTION BITS.
	POPJ	P,		;RETURN FROM INTERRUPT.
;HERE IF ANY OUTSTANDING SEEKS. SEE IF ANY ARE DONE, IF SO, CALL FILIO.
; CALLER BEWARE THAT UNIT SELECTED IS CHANGED.
; SEKPTR WORD IN P2.

SEKINT:	SETZ	T1,		;START OUT WITH ZERO
SEKIN1:	JFFO	P2,.+2
	 POPJ	P,		;NO MORE TO CHECK.
	CAIG	P3,3		;FORGET BAD UNIT NUMBERS
	SKIPN	U,@KONPTR(J)	;OR UNITS NOT CONFIGURED FOR
	 JRST	SEKNXT
	PUSHJ	P,SDA		;SELECT THIS UNIT
	RCMD	T4		;GET STATUS
	TLNN	T4,(SUOC!SUSE)	;ON CYLINDER OR SEEK ERROR? (SUOC NOT ON THEN)
	 JRST	SEKNXT		;NOT YET, FORGET IT FOR NOW.

	TLNN	T4,AE
	TLNE	T4,(IPE)	;ANY ERRORS?
	 JRST	SEKBAD		;YES, TURN OFF BIT IN SEKWRD BUT DON'T TELL FILIO, LET IT TIME OUT.
SEKDON:	MOVE	T3,BITTBL(P3)	;GET THE BIT REPRESENTING THE UNIT
	TDO	T1,T3		;TURN IT ON IN FILIO COMMUNICATION WORD
SEKDN1:	ANDCAM	T3,SEKWRD	;TURN IT OFF IN SEKWRD
	ANDCAM	T3,P2		;ALSO TURN OFF IN BITS TO CHECK
	JRST	SEKIN1		;AND CONTINUE

SEKNXT:	MOVE	T3,BITTBL(P3)
	ANDCAM	T3,P2		;JUST TURN OFF IN P2
	JRST	SEKIN1		;AND CONTINUE.

SEKBAD:	MOVE	T3,BITTBL(P3)
	JRST	SEKDN1

;ROUTINE TO SELECT A DISK UNIT. SMASHES T3.
; UDB IN U.

SDA:	LDB	T3,UNYPUN
	ROT	T3,ROTUNI
	LDA	T3
	TLO	T3,(<SU>)
	LDA	T3
	POPJ	P,		;RETURN.

;ROUTINE TO COMPUTE LDA DATA FOR PAGE NUMBER IN T1.
;USES T1-T4. EXPECTS UDB IN U, PAGE NUMBER IN T1.
;RETURNS CYLINDER NUMBER IN T1. LDA DATA IN T3.

GETLDA:
IFE FTDPAG,<;T1 has block number
	LSH	T1,B2PLSH	;CHANGE TO PAGE NUMBER
>
	IDIVI	T1,PPC		;T1: CYL
	IDIVI	T2,PPT		;T2: TRACK, T3: PAGE
	DPB	T2,[POINT AMSTRK,T3,AMPTRK]
	DPB	T1,[POINT AMSCYL,T3,AMPCYL]
	LDB	T4,UNYPUN	;SELECT UNIT FOR TRANSFER.
	ROT	T4,ROTUNI
	TDO	T3,T4		;PUT EVERYTHING IN T3
	POPJ	P,		;AND RETURN.

;ROUTINE TO SET KONNLD AND KONNL1 FROM UNIPAG
; CALL WITH U/UDB, J/KDB, T1/DISK ADDRESS
;SETS KONNLD,KONNL1,UNICYL. RETURNS LDA DATA IN T3 IN CASE ANYONE IS INTERESTED.
;RETURNS CYLINDER NUMBER IN T1

SETNLD:	PUSHJ	P,GETLDA	;GET CYLINDER # IN T1, DATA IN T3
	MOVEM	T3,KONNLD(J)	;SET KONNLD
	TLO	T3,(<SU>)	;COPY WITH SU SET TO MAKE NXTXFR FAST
	MOVEM	T3,KONNL1(J)
	POPJ	P,		;AND RETURN.

XFRMAX:	0			;MAX NUMBER OF PAGES WE DID IN ONE CALL TO FILINT
SEKWRD:	0			;BIT TABLE FOR UNITS THAT HAVE SEEKS IN PROGRESS.
DBLXFR:	0			;NUMBER OF TIMES APXRED/WRT WAS CALLED WHEN
				; THERE WAS AN XFER IN PROGRESS.
;MACRO TO SET DEVICE INDEPENDENT ERROR BITS (FAKE CONI),
; RETRY PATTERNS BASED ON ERROR BITS
;ARGUMENTS TO X MACRO ARE RCMD BIT, FAKE CONI BIT, DEVICE ERROR,
; RETRIES BEFORE RECAL, RECALS, RETRIES AFTER RECAL
; ENTRIES LATER IN ERRGEN LIST TAKE PRECEDENCE FOR RETRY PATTERNS
; AFTER ENTRIES EARLIER IN THE LIST.



DEFINE ERRGEN <
X (SECC,ERRDTA,0,100,1,100)		;SOFT ECC ERROR, TREAT SAME AS HARD FOR NOW
X (IPE,<ERRBIP!ERRBOP>,1,100,0,0)	;INTERNAL PARITY ERROR. ONLY LOOKED AT IF ALL OTHER BITS ARE OFF.
X (SOE,ERROVR,1,100,0,0)	;SECTOR OVERRUN
X (WOE,ERROVR,1,100,0,0)	;WRITE OVERRUN
X (ROE,ERROVR,1,100,0,0)	;READ OVERRUN
X (HECC,ERRDTA,0,100,1,100)	;HARD ECC ERROR.
X (HDECC,ERRINV,0,100,1,100)	;HEADER ECC ERROR, RETRY 100 TIMES, RECAL, RETRY ANOTHER 100

X (SUOC,ERREQC,1,0,10,10)	;IF SUOC WASN'T ON, TREAT AS SEEK ERROR
X (SUSE,ERREQC,1,0,10,10)	;SEEK ERROR, RECAL UP TO 8 TIMES, THEN RETRY 8 TIMES.
X (SUNR,ERREQC,1,10,0,0)	;NOT READY, RETRY 8 TIMES
X (SUNT,ERRSEL,1,0,0,0)		;NOT THERE.
>;END ERRGEN MACRO DEFINITION

DEFINE ERRPAT(DEV,RTY,RCL,RRT)
<XWD RRT+200000+UNPDEV*DEV,RCL_9+RTY>

DEFINE X(DEVB,CONIB,DEV,RTY,RCL,RRT) <
	TLNE	T4,('DEVB)
	 JRST	[TXO T2,'CONIB
		 MOVE T3,[ERRPAT(DEV,RTY,RCL,RRT)]
		 SKIPN UNIRCT(U)
		  MOVEM T3,UNIRCT(U)
		 JRST .+1]
>;END X MACRO DEFINITION

DEFINE TXO(A,B)<
IFE 'B&777777000000,<TRO A,'B>
IFE 'B&777777,<TLO A,('B)>
IFN 'B&777777000000,<IFN 'B&777777,<TDO A,['B]>>
>;END TXO DEFINITION

;ERROR DURING TRANSFER.
CONERR:	SETZ	T2,		;CLEAR OUT CONI WORD
	TRNE	T4,AE		;IF AE IS ON, IGNORE
	 TLZ	T4,(IPE)	;IPE, IT CAN BE ON AND DOESN'T MEAN ANYTHING.
	TLNN	T4,(IPE+SUNT+SUNR)	;BAD BITS ON?
	 JRST	CONER0
	TLNN	T4,(IPE)	;THIS?
	 JRST	CONOFL		;NO, JUST MARK OFFLINE
	TLO	T1,KCMFUS	;YES, THIS IS SERIOUS - SAY FILE UNSAFE
	MOVSI	T3,UNPFUS	;SET IN UDB
	IORM	T3,UNIDES(U)
CONOFL:	TLO	T1,KCMOFL	;SAY IT WENT OFF LINE
	MOVSI	T3,UNPOFL
	IORM	T3,UNIDES(U)	;MARK UDB SAYING ITS OFFLINE

CONER0:	ERRGEN
	PUSHJ	P,SAVSTS	;SAVE RCMD,RMA,RDA OF LAST XFER IN UDB
	PUSH	P,T1		;SAVE T1
	KONSTR	(<[CF+FC]>)	;CLEAR FAULTS
	POP	P,T1
	TLO	T1,KCMERR	;SAY THERE WAS A TRANSFER ERROR
	RET

;HERE IF THERE IS A COUNT ERROR.

CNTERR:	MOVE	T3,[ERRPAT(1,100,0,0)]
	SKIPN	UNIRCT(U)
	 MOVEM	T3,UNIRCT(U)	;SET RETRY PATTERN IF NECESSARY
	TRO	T2,ERRCNT
	TLO	T1,KCMERR
	RDA	T3		;GET DATAI IN T3 (WHERE IT HAPPENED)
	POPJ	P,		;AND RETURN.

;READ ALL REGISTERS INTO UDB.

SAVSTS:	MOVE	T3,KONLRC(J)	;GET LAST RCMD
	MOVEM	T3,UNISB(U)	;SAVE
	MOVE	T3,KONLRM(J)	;LAST RMA
	MOVEM	T3,UNISB+1(U)
	MOVE	T3,KONLRD(J)	;LAST RDA
	MOVEM	T3,UNISB+2(U)	;STORE
	POPJ	P,		;SAVE. (NO LONGER SAVE ECC REG.)

;HERE FROM FILIO TO COPY REGISTERS INTO PERMANENT PLACE FOR HARD ERRORS

APXHRD::HRLI	T1,UNISB(U)	;GET SOURCE ADDRESS
	HRRI	T1,UNISBH(U)	;GET WHERE THE REG DATA GOES
	BLT	T1,UNISBH+SBSIZ-1(U) ;XFER THE DATA.
	POPJ	P,		;DONE.

;HERE TO COPY REGISTERS TO UNISBS FOR SOFT DATA, CALL FROM FILIO
APXSFT::MOVSI	T2,UNISB(U)	;SOURCE
	HRRI	T2,UNISBS(U)	;DEST
	BLT	T2,UNISBS+SBSIZ-1(U) ;BLT THERE
	POPJ	P,		;AND RETURN.

	$END	(APX)		;End of APXKON (APXLIT: APXEND:)

    Z'^b